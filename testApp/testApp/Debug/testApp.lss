
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000c4d6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000013a  00802000  0000c4d6  0000c56a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fa7  0080213a  0080213a  0000c6a4  2**0
                  ALLOC
  3 .stab         00002718  00000000  00000000  0000c6a4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a2a  00000000  00000000  0000edbc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000003c0  00000000  00000000  0000f7e8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000c4e0  00000000  00000000  0000fba8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002153  00000000  00000000  0001c088  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003e5b  00000000  00000000  0001e1db  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001c00  00000000  00000000  00022038  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004558  00000000  00000000  00023c38  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000511a  00000000  00000000  00028190  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000120  00000000  00000000  0002d2aa  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 66 14 	jmp	0x28cc	; 0x28cc <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 7a 13 	jmp	0x26f4	; 0x26f4 <__vector_16>
      44:	0c 94 aa 13 	jmp	0x2754	; 0x2754 <__vector_17>
      48:	0c 94 da 13 	jmp	0x27b4	; 0x27b4 <__vector_18>
      4c:	0c 94 0a 14 	jmp	0x2814	; 0x2814 <__vector_19>
      50:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 c8 40 	jmp	0x8190	; 0x8190 <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 2d 30 	jmp	0x605a	; 0x605a <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 6b 16 	jmp	0x2cd6	; 0x2cd6 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 a9 15 	jmp	0x2b52	; 0x2b52 <__vector_79>
     140:	0c 94 d9 15 	jmp	0x2bb2	; 0x2bb2 <__vector_80>
     144:	0c 94 09 16 	jmp	0x2c12	; 0x2c12 <__vector_81>
     148:	0c 94 39 16 	jmp	0x2c72	; 0x2c72 <__vector_82>
     14c:	0c 94 06 02 	jmp	0x40c	; 0x40c <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 85 10 	jmp	0x210a	; 0x210a <__vector_104>
     1a4:	0c 94 a8 0e 	jmp	0x1d50	; 0x1d50 <__vector_105>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_overflow>:
     1e8:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     1f8:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     208:	54 41 0a 00                                         TA..

0000020c <chb_err_init>:
     20c:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     21c:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e6 ed       	ldi	r30, 0xD6	; 214
     244:	f4 ec       	ldi	r31, 0xC4	; 196
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	aa 33       	cpi	r26, 0x3A	; 58
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	aa e3       	ldi	r26, 0x3A	; 58
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a1 3e       	cpi	r26, 0xE1	; 225
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 39 01 	call	0x272	; 0x272 <main>
     26a:	0c 94 69 62 	jmp	0xc4d2	; 0xc4d2 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <main>:
 * Created: 1/29/2013 2:50:50 PM
 *  Author: Vlad
 */ 
# include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     272:	cf 93       	push	r28
     274:	df 93       	push	r29
     276:	cd b7       	in	r28, 0x3d	; 61
     278:	de b7       	in	r29, 0x3e	; 62
     27a:	61 97       	sbiw	r28, 0x11	; 17
     27c:	cd bf       	out	0x3d, r28	; 61
     27e:	de bf       	out	0x3e, r29	; 62
	moteID = 0;
     280:	10 92 cd 50 	sts	0x50CD, r1
	RadioMonitorMode = DATA_GATHERING;
     284:	81 e0       	ldi	r24, 0x01	; 1
     286:	80 93 5f 40 	sts	0x405F, r24
	char message[15];
	strcpy(message,"start sampling");
     28a:	ce 01       	movw	r24, r28
     28c:	03 96       	adiw	r24, 0x03	; 3
     28e:	20 e0       	ldi	r18, 0x00	; 0
     290:	30 e2       	ldi	r19, 0x20	; 32
     292:	4f e0       	ldi	r20, 0x0F	; 15
     294:	f9 01       	movw	r30, r18
     296:	00 80       	ld	r0, Z
     298:	2f 5f       	subi	r18, 0xFF	; 255
     29a:	3f 4f       	sbci	r19, 0xFF	; 255
     29c:	fc 01       	movw	r30, r24
     29e:	00 82       	st	Z, r0
     2a0:	01 96       	adiw	r24, 0x01	; 1
     2a2:	41 50       	subi	r20, 0x01	; 1
     2a4:	44 23       	and	r20, r20
     2a6:	b1 f7       	brne	.-20     	; 0x294 <main+0x22>
	chb_init();
     2a8:	0e 94 52 20 	call	0x40a4	; 0x40a4 <chb_init>
	chb_set_short_addr(moteID);
     2ac:	80 91 cd 50 	lds	r24, 0x50CD
     2b0:	88 2f       	mov	r24, r24
     2b2:	90 e0       	ldi	r25, 0x00	; 0
     2b4:	0e 94 ec 2d 	call	0x5bd8	; 0x5bd8 <chb_set_short_addr>
 	SD_init();
     2b8:	0e 94 a0 4d 	call	0x9b40	; 0x9b40 <SD_init>
 	getBootSectorData();
     2bc:	0e 94 a0 41 	call	0x8340	; 0x8340 <getBootSectorData>
	uint16_t MotesInSystem = 1;
     2c0:	81 e0       	ldi	r24, 0x01	; 1
     2c2:	90 e0       	ldi	r25, 0x00	; 0
     2c4:	89 83       	std	Y+1, r24	; 0x01
     2c6:	9a 83       	std	Y+2, r25	; 0x02
	while(1){
		while(MotesReadyToSynch < MotesInSystem){
     2c8:	28 c0       	rjmp	.+80     	; 0x31a <main+0xa8>
			//store samples in SD card as they come in
			if(StartOfFreeSpace >= 512){
     2ca:	80 91 c7 50 	lds	r24, 0x50C7
     2ce:	90 91 c8 50 	lds	r25, 0x50C8
     2d2:	a0 91 c9 50 	lds	r26, 0x50C9
     2d6:	b0 91 ca 50 	lds	r27, 0x50CA
     2da:	80 30       	cpi	r24, 0x00	; 0
     2dc:	f2 e0       	ldi	r31, 0x02	; 2
     2de:	9f 07       	cpc	r25, r31
     2e0:	f0 e0       	ldi	r31, 0x00	; 0
     2e2:	af 07       	cpc	r26, r31
     2e4:	f0 e0       	ldi	r31, 0x00	; 0
     2e6:	bf 07       	cpc	r27, r31
     2e8:	c0 f0       	brcs	.+48     	; 0x31a <main+0xa8>
				cli();
     2ea:	f8 94       	cli
				//atomically write the data that accumulated in the FRAM buffer to the SD card
				writeFile("DATA",FRAMReadBuffer,StartOfFreeSpace);						
     2ec:	20 91 c7 50 	lds	r18, 0x50C7
     2f0:	30 91 c8 50 	lds	r19, 0x50C8
     2f4:	40 91 c9 50 	lds	r20, 0x50C9
     2f8:	50 91 ca 50 	lds	r21, 0x50CA
     2fc:	8f e0       	ldi	r24, 0x0F	; 15
     2fe:	90 e2       	ldi	r25, 0x20	; 32
     300:	60 ee       	ldi	r22, 0xE0	; 224
     302:	73 e2       	ldi	r23, 0x23	; 35
     304:	0e 94 35 48 	call	0x906a	; 0x906a <writeFile>
				StartOfFreeSpace = 0;					
     308:	10 92 c7 50 	sts	0x50C7, r1
     30c:	10 92 c8 50 	sts	0x50C8, r1
     310:	10 92 c9 50 	sts	0x50C9, r1
     314:	10 92 ca 50 	sts	0x50CA, r1
				sei();
     318:	78 94       	sei
	chb_set_short_addr(moteID);
 	SD_init();
 	getBootSectorData();
	uint16_t MotesInSystem = 1;
	while(1){
		while(MotesReadyToSynch < MotesInSystem){
     31a:	20 91 75 50 	lds	r18, 0x5075
     31e:	30 91 76 50 	lds	r19, 0x5076
     322:	89 81       	ldd	r24, Y+1	; 0x01
     324:	9a 81       	ldd	r25, Y+2	; 0x02
     326:	28 17       	cp	r18, r24
     328:	39 07       	cpc	r19, r25
     32a:	78 f2       	brcs	.-98     	; 0x2ca <main+0x58>
				StartOfFreeSpace = 0;					
				sei();
			}				
		}
		//send synch message
		MotesReadyToSynch = 0;	//reset unsynched motes number
     32c:	10 92 75 50 	sts	0x5075, r1
     330:	10 92 76 50 	sts	0x5076, r1
		//if following does not work use copy string workaround
		chb_write(0xFFFF,message,strlen(message));
     334:	ce 01       	movw	r24, r28
     336:	03 96       	adiw	r24, 0x03	; 3
     338:	9c 01       	movw	r18, r24
     33a:	f9 01       	movw	r30, r18
     33c:	01 90       	ld	r0, Z+
     33e:	00 20       	and	r0, r0
     340:	e9 f7       	brne	.-6      	; 0x33c <main+0xca>
     342:	cf 01       	movw	r24, r30
     344:	01 97       	sbiw	r24, 0x01	; 1
     346:	82 1b       	sub	r24, r18
     348:	93 0b       	sbc	r25, r19
     34a:	9c 01       	movw	r18, r24
     34c:	40 e0       	ldi	r20, 0x00	; 0
     34e:	50 e0       	ldi	r21, 0x00	; 0
     350:	be 01       	movw	r22, r28
     352:	6d 5f       	subi	r22, 0xFD	; 253
     354:	7f 4f       	sbci	r23, 0xFF	; 255
     356:	8f ef       	ldi	r24, 0xFF	; 255
     358:	9f ef       	ldi	r25, 0xFF	; 255
     35a:	0e 94 19 21 	call	0x4232	; 0x4232 <chb_write>
	}	
     35e:	00 00       	nop
	chb_set_short_addr(moteID);
 	SD_init();
 	getBootSectorData();
	uint16_t MotesInSystem = 1;
	while(1){
		while(MotesReadyToSynch < MotesInSystem){
     360:	dc cf       	rjmp	.-72     	; 0x31a <main+0xa8>

00000362 <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     362:	cf 93       	push	r28
     364:	df 93       	push	r29
     366:	0f 92       	push	r0
     368:	0f 92       	push	r0
     36a:	cd b7       	in	r28, 0x3d	; 61
     36c:	de b7       	in	r29, 0x3e	; 62
     36e:	89 83       	std	Y+1, r24	; 0x01
     370:	9a 83       	std	Y+2, r25	; 0x02
	moteID = 1;
     372:	81 e0       	ldi	r24, 0x01	; 1
     374:	80 93 cd 50 	sts	0x50CD, r24
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     378:	83 e0       	ldi	r24, 0x03	; 3
     37a:	80 93 5f 40 	sts	0x405F, r24
	chb_init();
     37e:	0e 94 52 20 	call	0x40a4	; 0x40a4 <chb_init>
	chb_set_short_addr(moteID);
     382:	80 91 cd 50 	lds	r24, 0x50CD
     386:	88 2f       	mov	r24, r24
     388:	90 e0       	ldi	r25, 0x00	; 0
     38a:	0e 94 ec 2d 	call	0x5bd8	; 0x5bd8 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     38e:	80 e8       	ldi	r24, 0x80	; 128
     390:	91 e0       	ldi	r25, 0x01	; 1
     392:	28 ec       	ldi	r18, 0xC8	; 200
     394:	fc 01       	movw	r30, r24
     396:	21 83       	std	Z+1, r18	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     398:	80 e4       	ldi	r24, 0x40	; 64
     39a:	99 e0       	ldi	r25, 0x09	; 9
     39c:	29 e0       	ldi	r18, 0x09	; 9
     39e:	fc 01       	movw	r30, r24
     3a0:	20 83       	st	Z, r18
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     3a2:	80 e4       	ldi	r24, 0x40	; 64
     3a4:	99 e0       	ldi	r25, 0x09	; 9
     3a6:	22 e0       	ldi	r18, 0x02	; 2
     3a8:	fc 01       	movw	r30, r24
     3aa:	26 83       	std	Z+6, r18	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     3ac:	80 e4       	ldi	r24, 0x40	; 64
     3ae:	99 e0       	ldi	r25, 0x09	; 9
     3b0:	69 81       	ldd	r22, Y+1	; 0x01
     3b2:	7a 81       	ldd	r23, Y+2	; 0x02
     3b4:	44 ef       	ldi	r20, 0xF4	; 244
     3b6:	51 e0       	ldi	r21, 0x01	; 1
     3b8:	64 9f       	mul	r22, r20
     3ba:	90 01       	movw	r18, r0
     3bc:	65 9f       	mul	r22, r21
     3be:	30 0d       	add	r19, r0
     3c0:	74 9f       	mul	r23, r20
     3c2:	30 0d       	add	r19, r0
     3c4:	11 24       	eor	r1, r1
     3c6:	fc 01       	movw	r30, r24
     3c8:	26 a3       	lds	r18, 0x56
     3ca:	37 a3       	lds	r19, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     3cc:	80 e4       	ldi	r24, 0x40	; 64
     3ce:	98 e0       	ldi	r25, 0x08	; 8
     3d0:	20 e0       	ldi	r18, 0x00	; 0
     3d2:	3a ef       	ldi	r19, 0xFA	; 250
     3d4:	fc 01       	movw	r30, r24
     3d6:	26 a3       	lds	r18, 0x56
     3d8:	37 a3       	lds	r19, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     3da:	80 e4       	ldi	r24, 0x40	; 64
     3dc:	98 e0       	ldi	r25, 0x08	; 8
     3de:	21 e0       	ldi	r18, 0x01	; 1
     3e0:	fc 01       	movw	r30, r24
     3e2:	26 83       	std	Z+6, r18	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     3e4:	80 e4       	ldi	r24, 0x40	; 64
     3e6:	98 e0       	ldi	r25, 0x08	; 8
     3e8:	21 e0       	ldi	r18, 0x01	; 1
     3ea:	fc 01       	movw	r30, r24
     3ec:	20 83       	st	Z, r18
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     3ee:	80 ea       	ldi	r24, 0xA0	; 160
     3f0:	90 e0       	ldi	r25, 0x00	; 0
     3f2:	20 ea       	ldi	r18, 0xA0	; 160
     3f4:	30 e0       	ldi	r19, 0x00	; 0
     3f6:	f9 01       	movw	r30, r18
     3f8:	22 81       	ldd	r18, Z+2	; 0x02
     3fa:	27 60       	ori	r18, 0x07	; 7
     3fc:	fc 01       	movw	r30, r24
     3fe:	22 83       	std	Z+2, r18	; 0x02
	sei(); //  Enable global interrupts
     400:	78 94       	sei
}
     402:	0f 90       	pop	r0
     404:	0f 90       	pop	r0
     406:	df 91       	pop	r29
     408:	cf 91       	pop	r28
     40a:	08 95       	ret

0000040c <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     40c:	78 94       	sei
     40e:	1f 92       	push	r1
     410:	0f 92       	push	r0
     412:	0f b6       	in	r0, 0x3f	; 63
     414:	0f 92       	push	r0
     416:	00 90 3b 00 	lds	r0, 0x003B
     41a:	0f 92       	push	r0
     41c:	11 24       	eor	r1, r1
     41e:	2f 93       	push	r18
     420:	3f 93       	push	r19
     422:	4f 93       	push	r20
     424:	5f 93       	push	r21
     426:	6f 93       	push	r22
     428:	7f 93       	push	r23
     42a:	8f 93       	push	r24
     42c:	9f 93       	push	r25
     42e:	af 93       	push	r26
     430:	bf 93       	push	r27
     432:	ef 93       	push	r30
     434:	ff 93       	push	r31
     436:	cf 93       	push	r28
     438:	df 93       	push	r29
     43a:	cd b7       	in	r28, 0x3d	; 61
     43c:	de b7       	in	r29, 0x3e	; 62
     43e:	28 97       	sbiw	r28, 0x08	; 8
     440:	cd bf       	out	0x3d, r28	; 61
     442:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     444:	80 e4       	ldi	r24, 0x40	; 64
     446:	98 e0       	ldi	r25, 0x08	; 8
     448:	fc 01       	movw	r30, r24
     44a:	10 82       	st	Z, r1
	TCD1.CTRLA = 0x00;
     44c:	80 e4       	ldi	r24, 0x40	; 64
     44e:	99 e0       	ldi	r25, 0x09	; 9
     450:	fc 01       	movw	r30, r24
     452:	10 82       	st	Z, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
     454:	82 e0       	ldi	r24, 0x02	; 2
     456:	80 93 5f 40 	sts	0x405F, r24
	unsigned char message[8];
	strcpy(message,"reset");
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	24 e1       	ldi	r18, 0x14	; 20
     460:	30 e2       	ldi	r19, 0x20	; 32
     462:	46 e0       	ldi	r20, 0x06	; 6
     464:	f9 01       	movw	r30, r18
     466:	00 80       	ld	r0, Z
     468:	2f 5f       	subi	r18, 0xFF	; 255
     46a:	3f 4f       	sbci	r19, 0xFF	; 255
     46c:	fc 01       	movw	r30, r24
     46e:	00 82       	st	Z, r0
     470:	01 96       	adiw	r24, 0x01	; 1
     472:	41 50       	subi	r20, 0x01	; 1
     474:	44 23       	and	r20, r20
     476:	b1 f7       	brne	.-20     	; 0x464 <__vector_83+0x58>
	itoa((int)(moteID),buff,10);
     478:	80 91 cd 50 	lds	r24, 0x50CD
     47c:	88 2f       	mov	r24, r24
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	23 ed       	ldi	r18, 0xD3	; 211
     482:	30 e5       	ldi	r19, 0x50	; 80
     484:	b9 01       	movw	r22, r18
     486:	4a e0       	ldi	r20, 0x0A	; 10
     488:	50 e0       	ldi	r21, 0x00	; 0
     48a:	0e 94 85 5f 	call	0xbf0a	; 0xbf0a <itoa>
	strcat(message,buff);
     48e:	23 ed       	ldi	r18, 0xD3	; 211
     490:	30 e5       	ldi	r19, 0x50	; 80
     492:	ce 01       	movw	r24, r28
     494:	01 96       	adiw	r24, 0x01	; 1
     496:	b9 01       	movw	r22, r18
     498:	0e 94 6c 5f 	call	0xbed8	; 0xbed8 <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
     49c:	0e 94 91 0e 	call	0x1d22	; 0x1d22 <ADC_Pause_Sampling>
	chb_write(0x0000,message,strlen(message));
     4a0:	ce 01       	movw	r24, r28
     4a2:	01 96       	adiw	r24, 0x01	; 1
     4a4:	9c 01       	movw	r18, r24
     4a6:	f9 01       	movw	r30, r18
     4a8:	01 90       	ld	r0, Z+
     4aa:	00 20       	and	r0, r0
     4ac:	e9 f7       	brne	.-6      	; 0x4a8 <__vector_83+0x9c>
     4ae:	cf 01       	movw	r24, r30
     4b0:	01 97       	sbiw	r24, 0x01	; 1
     4b2:	82 1b       	sub	r24, r18
     4b4:	93 0b       	sbc	r25, r19
     4b6:	9c 01       	movw	r18, r24
     4b8:	40 e0       	ldi	r20, 0x00	; 0
     4ba:	50 e0       	ldi	r21, 0x00	; 0
     4bc:	80 e0       	ldi	r24, 0x00	; 0
     4be:	90 e0       	ldi	r25, 0x00	; 0
     4c0:	be 01       	movw	r22, r28
     4c2:	6f 5f       	subi	r22, 0xFF	; 255
     4c4:	7f 4f       	sbci	r23, 0xFF	; 255
     4c6:	0e 94 19 21 	call	0x4232	; 0x4232 <chb_write>
}	
     4ca:	28 96       	adiw	r28, 0x08	; 8
     4cc:	cd bf       	out	0x3d, r28	; 61
     4ce:	de bf       	out	0x3e, r29	; 62
     4d0:	df 91       	pop	r29
     4d2:	cf 91       	pop	r28
     4d4:	ff 91       	pop	r31
     4d6:	ef 91       	pop	r30
     4d8:	bf 91       	pop	r27
     4da:	af 91       	pop	r26
     4dc:	9f 91       	pop	r25
     4de:	8f 91       	pop	r24
     4e0:	7f 91       	pop	r23
     4e2:	6f 91       	pop	r22
     4e4:	5f 91       	pop	r21
     4e6:	4f 91       	pop	r20
     4e8:	3f 91       	pop	r19
     4ea:	2f 91       	pop	r18
     4ec:	0f 90       	pop	r0
     4ee:	00 92 3b 00 	sts	0x003B, r0
     4f2:	0f 90       	pop	r0
     4f4:	0f be       	out	0x3f, r0	; 63
     4f6:	0f 90       	pop	r0
     4f8:	1f 90       	pop	r1
     4fa:	18 95       	reti

000004fc <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     4fc:	cf 93       	push	r28
     4fe:	df 93       	push	r29
     500:	cd b7       	in	r28, 0x3d	; 61
     502:	de b7       	in	r29, 0x3e	; 62
     504:	6b 97       	sbiw	r28, 0x1b	; 27
     506:	cd bf       	out	0x3d, r28	; 61
     508:	de bf       	out	0x3e, r29	; 62
     50a:	8e 8b       	std	Y+22, r24	; 0x16
     50c:	9f 8b       	std	Y+23, r25	; 0x17
     50e:	68 8f       	std	Y+24, r22	; 0x18
     510:	79 8f       	std	Y+25, r23	; 0x19
     512:	4a 8f       	std	Y+26, r20	; 0x1a
     514:	5b 8f       	std	Y+27, r21	; 0x1b
	uint32_t sum = 0;
     516:	19 82       	std	Y+1, r1	; 0x01
     518:	1a 82       	std	Y+2, r1	; 0x02
     51a:	1b 82       	std	Y+3, r1	; 0x03
     51c:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     51e:	80 e0       	ldi	r24, 0x00	; 0
     520:	90 e1       	ldi	r25, 0x10	; 16
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	8d 83       	std	Y+5, r24	; 0x05
     528:	9e 83       	std	Y+6, r25	; 0x06
     52a:	af 83       	std	Y+7, r26	; 0x07
     52c:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     52e:	19 86       	std	Y+9, r1	; 0x09
     530:	1a 86       	std	Y+10, r1	; 0x0a
     532:	1b 86       	std	Y+11, r1	; 0x0b
     534:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     536:	81 e0       	ldi	r24, 0x01	; 1
     538:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     53c:	80 e0       	ldi	r24, 0x00	; 0
     53e:	92 e0       	ldi	r25, 0x02	; 2
     540:	0e 94 af 1c 	call	0x395e	; 0x395e <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     544:	80 e0       	ldi	r24, 0x00	; 0
     546:	92 e0       	ldi	r25, 0x02	; 2
     548:	20 e0       	ldi	r18, 0x00	; 0
     54a:	32 e0       	ldi	r19, 0x02	; 2
     54c:	f9 01       	movw	r30, r18
     54e:	21 81       	ldd	r18, Z+1	; 0x01
     550:	29 7e       	andi	r18, 0xE9	; 233
     552:	fc 01       	movw	r30, r24
     554:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     556:	80 e0       	ldi	r24, 0x00	; 0
     558:	92 e0       	ldi	r25, 0x02	; 2
     55a:	20 e0       	ldi	r18, 0x00	; 0
     55c:	32 e0       	ldi	r19, 0x02	; 2
     55e:	f9 01       	movw	r30, r18
     560:	24 81       	ldd	r18, Z+4	; 0x04
     562:	28 7f       	andi	r18, 0xF8	; 248
     564:	23 60       	ori	r18, 0x03	; 3
     566:	fc 01       	movw	r30, r24
     568:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     56a:	80 e0       	ldi	r24, 0x00	; 0
     56c:	92 e0       	ldi	r25, 0x02	; 2
     56e:	20 e0       	ldi	r18, 0x00	; 0
     570:	32 e0       	ldi	r19, 0x02	; 2
     572:	f9 01       	movw	r30, r18
     574:	22 81       	ldd	r18, Z+2	; 0x02
     576:	2f 7c       	andi	r18, 0xCF	; 207
     578:	fc 01       	movw	r30, r24
     57a:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     57c:	80 e2       	ldi	r24, 0x20	; 32
     57e:	92 e0       	ldi	r25, 0x02	; 2
     580:	20 e2       	ldi	r18, 0x20	; 32
     582:	32 e0       	ldi	r19, 0x02	; 2
     584:	f9 01       	movw	r30, r18
     586:	20 81       	ld	r18, Z
     588:	20 7e       	andi	r18, 0xE0	; 224
     58a:	21 60       	ori	r18, 0x01	; 1
     58c:	fc 01       	movw	r30, r24
     58e:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     590:	80 e2       	ldi	r24, 0x20	; 32
     592:	92 e0       	ldi	r25, 0x02	; 2
     594:	29 e0       	ldi	r18, 0x09	; 9
     596:	fc 01       	movw	r30, r24
     598:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCA);
     59a:	80 e0       	ldi	r24, 0x00	; 0
     59c:	92 e0       	ldi	r25, 0x02	; 2
     59e:	20 e0       	ldi	r18, 0x00	; 0
     5a0:	32 e0       	ldi	r19, 0x02	; 2
     5a2:	f9 01       	movw	r30, r18
     5a4:	20 81       	ld	r18, Z
     5a6:	21 60       	ori	r18, 0x01	; 1
     5a8:	fc 01       	movw	r30, r24
     5aa:	20 83       	st	Z, r18
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     5ac:	80 e0       	ldi	r24, 0x00	; 0
     5ae:	92 e0       	ldi	r25, 0x02	; 2
     5b0:	0e 94 67 1e 	call	0x3cce	; 0x3cce <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     5b4:	80 e0       	ldi	r24, 0x00	; 0
     5b6:	92 e0       	ldi	r25, 0x02	; 2
     5b8:	60 e2       	ldi	r22, 0x20	; 32
     5ba:	72 e0       	ldi	r23, 0x02	; 2
     5bc:	40 e0       	ldi	r20, 0x00	; 0
     5be:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <ADC_Offset_Get_Unsigned>
     5c2:	8d 8b       	std	Y+21, r24	; 0x15
    ADC_Disable(&ADCA);
     5c4:	80 e0       	ldi	r24, 0x00	; 0
     5c6:	92 e0       	ldi	r25, 0x02	; 2
     5c8:	20 e0       	ldi	r18, 0x00	; 0
     5ca:	32 e0       	ldi	r19, 0x02	; 2
     5cc:	f9 01       	movw	r30, r18
     5ce:	20 81       	ld	r18, Z
     5d0:	2e 7f       	andi	r18, 0xFE	; 254
     5d2:	fc 01       	movw	r30, r24
     5d4:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     5d6:	80 e2       	ldi	r24, 0x20	; 32
     5d8:	92 e0       	ldi	r25, 0x02	; 2
     5da:	fc 01       	movw	r30, r24
     5dc:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     5de:	80 e0       	ldi	r24, 0x00	; 0
     5e0:	92 e0       	ldi	r25, 0x02	; 2
     5e2:	20 e0       	ldi	r18, 0x00	; 0
     5e4:	32 e0       	ldi	r19, 0x02	; 2
     5e6:	f9 01       	movw	r30, r18
     5e8:	23 81       	ldd	r18, Z+3	; 0x03
     5ea:	2f 73       	andi	r18, 0x3F	; 63
     5ec:	fc 01       	movw	r30, r24
     5ee:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     5f0:	80 e0       	ldi	r24, 0x00	; 0
     5f2:	92 e0       	ldi	r25, 0x02	; 2
     5f4:	20 e0       	ldi	r18, 0x00	; 0
     5f6:	32 e0       	ldi	r19, 0x02	; 2
     5f8:	f9 01       	movw	r30, r18
     5fa:	20 81       	ld	r18, Z
     5fc:	21 60       	ori	r18, 0x01	; 1
     5fe:	fc 01       	movw	r30, r24
     600:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     602:	80 e0       	ldi	r24, 0x00	; 0
     604:	92 e0       	ldi	r25, 0x02	; 2
     606:	0e 94 67 1e 	call	0x3cce	; 0x3cce <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     60a:	80 e0       	ldi	r24, 0x00	; 0
     60c:	92 e0       	ldi	r25, 0x02	; 2
     60e:	20 e0       	ldi	r18, 0x00	; 0
     610:	32 e0       	ldi	r19, 0x02	; 2
     612:	f9 01       	movw	r30, r18
     614:	21 81       	ldd	r18, Z+1	; 0x01
     616:	28 60       	ori	r18, 0x08	; 8
     618:	fc 01       	movw	r30, r24
     61a:	21 83       	std	Z+1, r18	; 0x01

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     61c:	1d 86       	std	Y+13, r1	; 0x0d
     61e:	1e 86       	std	Y+14, r1	; 0x0e
     620:	56 c0       	rjmp	.+172    	; 0x6ce <CO_collectTemp+0x1d2>

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     622:	80 e2       	ldi	r24, 0x20	; 32
     624:	92 e0       	ldi	r25, 0x02	; 2
     626:	fc 01       	movw	r30, r24
     628:	83 81       	ldd	r24, Z+3	; 0x03
     62a:	88 2f       	mov	r24, r24
     62c:	90 e0       	ldi	r25, 0x00	; 0
     62e:	81 70       	andi	r24, 0x01	; 1
     630:	90 70       	andi	r25, 0x00	; 0
     632:	00 97       	sbiw	r24, 0x00	; 0
     634:	b1 f3       	breq	.-20     	; 0x622 <CO_collectTemp+0x126>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     636:	2d 89       	ldd	r18, Y+21	; 0x15
     638:	80 e2       	ldi	r24, 0x20	; 32
     63a:	92 e0       	ldi	r25, 0x02	; 2
     63c:	62 2f       	mov	r22, r18
     63e:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <ADC_ResultCh_GetWord_Signed>
     642:	8f 87       	std	Y+15, r24	; 0x0f
     644:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResult;
     646:	8f 85       	ldd	r24, Y+15	; 0x0f
     648:	98 89       	ldd	r25, Y+16	; 0x10
     64a:	cc 01       	movw	r24, r24
     64c:	a0 e0       	ldi	r26, 0x00	; 0
     64e:	b0 e0       	ldi	r27, 0x00	; 0
     650:	29 81       	ldd	r18, Y+1	; 0x01
     652:	3a 81       	ldd	r19, Y+2	; 0x02
     654:	4b 81       	ldd	r20, Y+3	; 0x03
     656:	5c 81       	ldd	r21, Y+4	; 0x04
     658:	82 0f       	add	r24, r18
     65a:	93 1f       	adc	r25, r19
     65c:	a4 1f       	adc	r26, r20
     65e:	b5 1f       	adc	r27, r21
     660:	89 83       	std	Y+1, r24	; 0x01
     662:	9a 83       	std	Y+2, r25	; 0x02
     664:	ab 83       	std	Y+3, r26	; 0x03
     666:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResult) { max = tempResult;}
     668:	8f 85       	ldd	r24, Y+15	; 0x0f
     66a:	98 89       	ldd	r25, Y+16	; 0x10
     66c:	9c 01       	movw	r18, r24
     66e:	40 e0       	ldi	r20, 0x00	; 0
     670:	50 e0       	ldi	r21, 0x00	; 0
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	9a 85       	ldd	r25, Y+10	; 0x0a
     676:	ab 85       	ldd	r26, Y+11	; 0x0b
     678:	bc 85       	ldd	r27, Y+12	; 0x0c
     67a:	82 17       	cp	r24, r18
     67c:	93 07       	cpc	r25, r19
     67e:	a4 07       	cpc	r26, r20
     680:	b5 07       	cpc	r27, r21
     682:	48 f4       	brcc	.+18     	; 0x696 <CO_collectTemp+0x19a>
     684:	8f 85       	ldd	r24, Y+15	; 0x0f
     686:	98 89       	ldd	r25, Y+16	; 0x10
     688:	cc 01       	movw	r24, r24
     68a:	a0 e0       	ldi	r26, 0x00	; 0
     68c:	b0 e0       	ldi	r27, 0x00	; 0
     68e:	89 87       	std	Y+9, r24	; 0x09
     690:	9a 87       	std	Y+10, r25	; 0x0a
     692:	ab 87       	std	Y+11, r26	; 0x0b
     694:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResult) { min = tempResult;}
     696:	8f 85       	ldd	r24, Y+15	; 0x0f
     698:	98 89       	ldd	r25, Y+16	; 0x10
     69a:	9c 01       	movw	r18, r24
     69c:	40 e0       	ldi	r20, 0x00	; 0
     69e:	50 e0       	ldi	r21, 0x00	; 0
     6a0:	8d 81       	ldd	r24, Y+5	; 0x05
     6a2:	9e 81       	ldd	r25, Y+6	; 0x06
     6a4:	af 81       	ldd	r26, Y+7	; 0x07
     6a6:	b8 85       	ldd	r27, Y+8	; 0x08
     6a8:	28 17       	cp	r18, r24
     6aa:	39 07       	cpc	r19, r25
     6ac:	4a 07       	cpc	r20, r26
     6ae:	5b 07       	cpc	r21, r27
     6b0:	48 f4       	brcc	.+18     	; 0x6c4 <CO_collectTemp+0x1c8>
     6b2:	8f 85       	ldd	r24, Y+15	; 0x0f
     6b4:	98 89       	ldd	r25, Y+16	; 0x10
     6b6:	cc 01       	movw	r24, r24
     6b8:	a0 e0       	ldi	r26, 0x00	; 0
     6ba:	b0 e0       	ldi	r27, 0x00	; 0
     6bc:	8d 83       	std	Y+5, r24	; 0x05
     6be:	9e 83       	std	Y+6, r25	; 0x06
     6c0:	af 83       	std	Y+7, r26	; 0x07
     6c2:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     6c4:	8d 85       	ldd	r24, Y+13	; 0x0d
     6c6:	9e 85       	ldd	r25, Y+14	; 0x0e
     6c8:	01 96       	adiw	r24, 0x01	; 1
     6ca:	8d 87       	std	Y+13, r24	; 0x0d
     6cc:	9e 87       	std	Y+14, r25	; 0x0e
     6ce:	8d 85       	ldd	r24, Y+13	; 0x0d
     6d0:	9e 85       	ldd	r25, Y+14	; 0x0e
     6d2:	f4 e0       	ldi	r31, 0x04	; 4
     6d4:	80 30       	cpi	r24, 0x00	; 0
     6d6:	9f 07       	cpc	r25, r31
     6d8:	08 f4       	brcc	.+2      	; 0x6dc <CO_collectTemp+0x1e0>
     6da:	a3 cf       	rjmp	.-186    	; 0x622 <CO_collectTemp+0x126>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     6dc:	80 e0       	ldi	r24, 0x00	; 0
     6de:	92 e0       	ldi	r25, 0x02	; 2
     6e0:	20 e0       	ldi	r18, 0x00	; 0
     6e2:	32 e0       	ldi	r19, 0x02	; 2
     6e4:	f9 01       	movw	r30, r18
     6e6:	21 81       	ldd	r18, Z+1	; 0x01
     6e8:	27 7f       	andi	r18, 0xF7	; 247
     6ea:	fc 01       	movw	r30, r24
     6ec:	21 83       	std	Z+1, r18	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     6ee:	80 e0       	ldi	r24, 0x00	; 0
     6f0:	92 e0       	ldi	r25, 0x02	; 2
     6f2:	20 e0       	ldi	r18, 0x00	; 0
     6f4:	32 e0       	ldi	r19, 0x02	; 2
     6f6:	f9 01       	movw	r30, r18
     6f8:	20 81       	ld	r18, Z
     6fa:	22 60       	ori	r18, 0x02	; 2
     6fc:	fc 01       	movw	r30, r24
     6fe:	20 83       	st	Z, r18
	ADC_Disable(&ADCA);
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	92 e0       	ldi	r25, 0x02	; 2
     704:	20 e0       	ldi	r18, 0x00	; 0
     706:	32 e0       	ldi	r19, 0x02	; 2
     708:	f9 01       	movw	r30, r18
     70a:	20 81       	ld	r18, Z
     70c:	2e 7f       	andi	r18, 0xFE	; 254
     70e:	fc 01       	movw	r30, r24
     710:	20 83       	st	Z, r18

	ADCPower(FALSE);
     712:	80 e0       	ldi	r24, 0x00	; 0
     714:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>

	average = sum / NUM_SAMPLES;
     718:	89 81       	ldd	r24, Y+1	; 0x01
     71a:	9a 81       	ldd	r25, Y+2	; 0x02
     71c:	ab 81       	ldd	r26, Y+3	; 0x03
     71e:	bc 81       	ldd	r27, Y+4	; 0x04
     720:	07 2e       	mov	r0, r23
     722:	7a e0       	ldi	r23, 0x0A	; 10
     724:	b6 95       	lsr	r27
     726:	a7 95       	ror	r26
     728:	97 95       	ror	r25
     72a:	87 95       	ror	r24
     72c:	7a 95       	dec	r23
     72e:	d1 f7       	brne	.-12     	; 0x724 <CO_collectTemp+0x228>
     730:	70 2d       	mov	r23, r0
     732:	89 8b       	std	Y+17, r24	; 0x11
     734:	9a 8b       	std	Y+18, r25	; 0x12
     736:	ab 8b       	std	Y+19, r26	; 0x13
     738:	bc 8b       	std	Y+20, r27	; 0x14

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     73a:	89 89       	ldd	r24, Y+17	; 0x11
     73c:	9a 89       	ldd	r25, Y+18	; 0x12
     73e:	ab 89       	ldd	r26, Y+19	; 0x13
     740:	bc 89       	ldd	r27, Y+20	; 0x14
     742:	28 ee       	ldi	r18, 0xE8	; 232
     744:	33 e0       	ldi	r19, 0x03	; 3
     746:	40 e0       	ldi	r20, 0x00	; 0
     748:	50 e0       	ldi	r21, 0x00	; 0
     74a:	bc 01       	movw	r22, r24
     74c:	cd 01       	movw	r24, r26
     74e:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
     752:	dc 01       	movw	r26, r24
     754:	cb 01       	movw	r24, r22
     756:	2f ef       	ldi	r18, 0xFF	; 255
     758:	3f e0       	ldi	r19, 0x0F	; 15
     75a:	40 e0       	ldi	r20, 0x00	; 0
     75c:	50 e0       	ldi	r21, 0x00	; 0
     75e:	bc 01       	movw	r22, r24
     760:	cd 01       	movw	r24, r26
     762:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
     766:	da 01       	movw	r26, r20
     768:	c9 01       	movw	r24, r18
     76a:	9c 01       	movw	r18, r24
     76c:	22 53       	subi	r18, 0x32	; 50
     76e:	30 40       	sbci	r19, 0x00	; 0
     770:	8e 89       	ldd	r24, Y+22	; 0x16
     772:	9f 89       	ldd	r25, Y+23	; 0x17
     774:	fc 01       	movw	r30, r24
     776:	20 83       	st	Z, r18
     778:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     77a:	89 85       	ldd	r24, Y+9	; 0x09
     77c:	9a 85       	ldd	r25, Y+10	; 0x0a
     77e:	ab 85       	ldd	r26, Y+11	; 0x0b
     780:	bc 85       	ldd	r27, Y+12	; 0x0c
     782:	28 ee       	ldi	r18, 0xE8	; 232
     784:	33 e0       	ldi	r19, 0x03	; 3
     786:	40 e0       	ldi	r20, 0x00	; 0
     788:	50 e0       	ldi	r21, 0x00	; 0
     78a:	bc 01       	movw	r22, r24
     78c:	cd 01       	movw	r24, r26
     78e:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
     792:	dc 01       	movw	r26, r24
     794:	cb 01       	movw	r24, r22
     796:	2f ef       	ldi	r18, 0xFF	; 255
     798:	3f e0       	ldi	r19, 0x0F	; 15
     79a:	40 e0       	ldi	r20, 0x00	; 0
     79c:	50 e0       	ldi	r21, 0x00	; 0
     79e:	bc 01       	movw	r22, r24
     7a0:	cd 01       	movw	r24, r26
     7a2:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
     7a6:	da 01       	movw	r26, r20
     7a8:	c9 01       	movw	r24, r18
     7aa:	9c 01       	movw	r18, r24
     7ac:	22 53       	subi	r18, 0x32	; 50
     7ae:	30 40       	sbci	r19, 0x00	; 0
     7b0:	8a 8d       	ldd	r24, Y+26	; 0x1a
     7b2:	9b 8d       	ldd	r25, Y+27	; 0x1b
     7b4:	fc 01       	movw	r30, r24
     7b6:	20 83       	st	Z, r18
     7b8:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     7ba:	8d 81       	ldd	r24, Y+5	; 0x05
     7bc:	9e 81       	ldd	r25, Y+6	; 0x06
     7be:	af 81       	ldd	r26, Y+7	; 0x07
     7c0:	b8 85       	ldd	r27, Y+8	; 0x08
     7c2:	28 ee       	ldi	r18, 0xE8	; 232
     7c4:	33 e0       	ldi	r19, 0x03	; 3
     7c6:	40 e0       	ldi	r20, 0x00	; 0
     7c8:	50 e0       	ldi	r21, 0x00	; 0
     7ca:	bc 01       	movw	r22, r24
     7cc:	cd 01       	movw	r24, r26
     7ce:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
     7d2:	dc 01       	movw	r26, r24
     7d4:	cb 01       	movw	r24, r22
     7d6:	2f ef       	ldi	r18, 0xFF	; 255
     7d8:	3f e0       	ldi	r19, 0x0F	; 15
     7da:	40 e0       	ldi	r20, 0x00	; 0
     7dc:	50 e0       	ldi	r21, 0x00	; 0
     7de:	bc 01       	movw	r22, r24
     7e0:	cd 01       	movw	r24, r26
     7e2:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
     7e6:	da 01       	movw	r26, r20
     7e8:	c9 01       	movw	r24, r18
     7ea:	9c 01       	movw	r18, r24
     7ec:	22 53       	subi	r18, 0x32	; 50
     7ee:	30 40       	sbci	r19, 0x00	; 0
     7f0:	88 8d       	ldd	r24, Y+24	; 0x18
     7f2:	99 8d       	ldd	r25, Y+25	; 0x19
     7f4:	fc 01       	movw	r30, r24
     7f6:	20 83       	st	Z, r18
     7f8:	31 83       	std	Z+1, r19	; 0x01
}
     7fa:	6b 96       	adiw	r28, 0x1b	; 27
     7fc:	cd bf       	out	0x3d, r28	; 61
     7fe:	de bf       	out	0x3e, r29	; 62
     800:	df 91       	pop	r29
     802:	cf 91       	pop	r28
     804:	08 95       	ret

00000806 <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     806:	0f 93       	push	r16
     808:	1f 93       	push	r17
     80a:	cf 93       	push	r28
     80c:	df 93       	push	r29
     80e:	cd b7       	in	r28, 0x3d	; 61
     810:	de b7       	in	r29, 0x3e	; 62
     812:	a9 97       	sbiw	r28, 0x29	; 41
     814:	cd bf       	out	0x3d, r28	; 61
     816:	de bf       	out	0x3e, r29	; 62
     818:	8c a3       	lds	r24, 0x5c
     81a:	9d a3       	lds	r25, 0x5d
     81c:	6e a3       	lds	r22, 0x5e
     81e:	7f a3       	lds	r23, 0x5f
     820:	48 a7       	lds	r20, 0x78
     822:	59 a7       	lds	r21, 0x79
	uint32_t sum = 0;
     824:	19 82       	std	Y+1, r1	; 0x01
     826:	1a 82       	std	Y+2, r1	; 0x02
     828:	1b 82       	std	Y+3, r1	; 0x03
     82a:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     82c:	80 e0       	ldi	r24, 0x00	; 0
     82e:	90 e1       	ldi	r25, 0x10	; 16
     830:	a0 e0       	ldi	r26, 0x00	; 0
     832:	b0 e0       	ldi	r27, 0x00	; 0
     834:	8d 83       	std	Y+5, r24	; 0x05
     836:	9e 83       	std	Y+6, r25	; 0x06
     838:	af 83       	std	Y+7, r26	; 0x07
     83a:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     83c:	19 86       	std	Y+9, r1	; 0x09
     83e:	1a 86       	std	Y+10, r1	; 0x0a
     840:	1b 86       	std	Y+11, r1	; 0x0b
     842:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     844:	81 e0       	ldi	r24, 0x01	; 1
     846:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     84a:	84 e0       	ldi	r24, 0x04	; 4
     84c:	60 e0       	ldi	r22, 0x00	; 0
     84e:	0e 94 39 35 	call	0x6a72	; 0x6a72 <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     852:	84 e0       	ldi	r24, 0x04	; 4
     854:	60 e0       	ldi	r22, 0x00	; 0
     856:	0e 94 05 36 	call	0x6c0a	; 0x6c0a <PortEx_OUTSET>
     85a:	80 e0       	ldi	r24, 0x00	; 0
     85c:	90 e0       	ldi	r25, 0x00	; 0
     85e:	a8 ec       	ldi	r26, 0xC8	; 200
     860:	b2 e4       	ldi	r27, 0x42	; 66
     862:	8d 8b       	std	Y+21, r24	; 0x15
     864:	9e 8b       	std	Y+22, r25	; 0x16
     866:	af 8b       	std	Y+23, r26	; 0x17
     868:	b8 8f       	std	Y+24, r27	; 0x18
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     86a:	6d 89       	ldd	r22, Y+21	; 0x15
     86c:	7e 89       	ldd	r23, Y+22	; 0x16
     86e:	8f 89       	ldd	r24, Y+23	; 0x17
     870:	98 8d       	ldd	r25, Y+24	; 0x18
     872:	20 e0       	ldi	r18, 0x00	; 0
     874:	30 e0       	ldi	r19, 0x00	; 0
     876:	4a ef       	ldi	r20, 0xFA	; 250
     878:	55 e4       	ldi	r21, 0x45	; 69
     87a:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
     87e:	dc 01       	movw	r26, r24
     880:	cb 01       	movw	r24, r22
     882:	89 8f       	std	Y+25, r24	; 0x19
     884:	9a 8f       	std	Y+26, r25	; 0x1a
     886:	ab 8f       	std	Y+27, r26	; 0x1b
     888:	bc 8f       	std	Y+28, r27	; 0x1c
	if (__tmp < 1.0)
     88a:	11 e0       	ldi	r17, 0x01	; 1
     88c:	69 8d       	ldd	r22, Y+25	; 0x19
     88e:	7a 8d       	ldd	r23, Y+26	; 0x1a
     890:	8b 8d       	ldd	r24, Y+27	; 0x1b
     892:	9c 8d       	ldd	r25, Y+28	; 0x1c
     894:	20 e0       	ldi	r18, 0x00	; 0
     896:	30 e0       	ldi	r19, 0x00	; 0
     898:	40 e8       	ldi	r20, 0x80	; 128
     89a:	5f e3       	ldi	r21, 0x3F	; 63
     89c:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
     8a0:	88 23       	and	r24, r24
     8a2:	0c f0       	brlt	.+2      	; 0x8a6 <CO_collectBatt+0xa0>
     8a4:	10 e0       	ldi	r17, 0x00	; 0
     8a6:	11 23       	and	r17, r17
     8a8:	29 f0       	breq	.+10     	; 0x8b4 <CO_collectBatt+0xae>
		__ticks = 1;
     8aa:	81 e0       	ldi	r24, 0x01	; 1
     8ac:	90 e0       	ldi	r25, 0x00	; 0
     8ae:	8d 8f       	std	Y+29, r24	; 0x1d
     8b0:	9e 8f       	std	Y+30, r25	; 0x1e
     8b2:	46 c0       	rjmp	.+140    	; 0x940 <CO_collectBatt+0x13a>
	else if (__tmp > 65535)
     8b4:	11 e0       	ldi	r17, 0x01	; 1
     8b6:	69 8d       	ldd	r22, Y+25	; 0x19
     8b8:	7a 8d       	ldd	r23, Y+26	; 0x1a
     8ba:	8b 8d       	ldd	r24, Y+27	; 0x1b
     8bc:	9c 8d       	ldd	r25, Y+28	; 0x1c
     8be:	20 e0       	ldi	r18, 0x00	; 0
     8c0:	3f ef       	ldi	r19, 0xFF	; 255
     8c2:	4f e7       	ldi	r20, 0x7F	; 127
     8c4:	57 e4       	ldi	r21, 0x47	; 71
     8c6:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
     8ca:	18 16       	cp	r1, r24
     8cc:	0c f0       	brlt	.+2      	; 0x8d0 <CO_collectBatt+0xca>
     8ce:	10 e0       	ldi	r17, 0x00	; 0
     8d0:	11 23       	and	r17, r17
     8d2:	61 f1       	breq	.+88     	; 0x92c <CO_collectBatt+0x126>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     8d4:	6d 89       	ldd	r22, Y+21	; 0x15
     8d6:	7e 89       	ldd	r23, Y+22	; 0x16
     8d8:	8f 89       	ldd	r24, Y+23	; 0x17
     8da:	98 8d       	ldd	r25, Y+24	; 0x18
     8dc:	20 e0       	ldi	r18, 0x00	; 0
     8de:	30 e0       	ldi	r19, 0x00	; 0
     8e0:	40 e2       	ldi	r20, 0x20	; 32
     8e2:	51 e4       	ldi	r21, 0x41	; 65
     8e4:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
     8e8:	dc 01       	movw	r26, r24
     8ea:	cb 01       	movw	r24, r22
     8ec:	bc 01       	movw	r22, r24
     8ee:	cd 01       	movw	r24, r26
     8f0:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
     8f4:	dc 01       	movw	r26, r24
     8f6:	cb 01       	movw	r24, r22
     8f8:	8d 8f       	std	Y+29, r24	; 0x1d
     8fa:	9e 8f       	std	Y+30, r25	; 0x1e
     8fc:	12 c0       	rjmp	.+36     	; 0x922 <CO_collectBatt+0x11c>
     8fe:	80 e2       	ldi	r24, 0x20	; 32
     900:	93 e0       	ldi	r25, 0x03	; 3
     902:	8f 8f       	std	Y+31, r24	; 0x1f
     904:	98 a3       	lds	r25, 0x58
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     906:	8f 8d       	ldd	r24, Y+31	; 0x1f
     908:	98 a1       	lds	r25, 0x48
     90a:	8c 01       	movw	r16, r24
     90c:	c8 01       	movw	r24, r16
     90e:	01 97       	sbiw	r24, 0x01	; 1
     910:	f1 f7       	brne	.-4      	; 0x90e <CO_collectBatt+0x108>
     912:	8c 01       	movw	r16, r24
     914:	0f 8f       	std	Y+31, r16	; 0x1f
     916:	18 a3       	lds	r17, 0x58
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     918:	8d 8d       	ldd	r24, Y+29	; 0x1d
     91a:	9e 8d       	ldd	r25, Y+30	; 0x1e
     91c:	01 97       	sbiw	r24, 0x01	; 1
     91e:	8d 8f       	std	Y+29, r24	; 0x1d
     920:	9e 8f       	std	Y+30, r25	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     922:	8d 8d       	ldd	r24, Y+29	; 0x1d
     924:	9e 8d       	ldd	r25, Y+30	; 0x1e
     926:	00 97       	sbiw	r24, 0x00	; 0
     928:	51 f7       	brne	.-44     	; 0x8fe <CO_collectBatt+0xf8>
     92a:	17 c0       	rjmp	.+46     	; 0x95a <CO_collectBatt+0x154>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     92c:	69 8d       	ldd	r22, Y+25	; 0x19
     92e:	7a 8d       	ldd	r23, Y+26	; 0x1a
     930:	8b 8d       	ldd	r24, Y+27	; 0x1b
     932:	9c 8d       	ldd	r25, Y+28	; 0x1c
     934:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
     938:	dc 01       	movw	r26, r24
     93a:	cb 01       	movw	r24, r22
     93c:	8d 8f       	std	Y+29, r24	; 0x1d
     93e:	9e 8f       	std	Y+30, r25	; 0x1e
     940:	8d 8d       	ldd	r24, Y+29	; 0x1d
     942:	9e 8d       	ldd	r25, Y+30	; 0x1e
     944:	89 a3       	lds	r24, 0x59
     946:	9a a3       	lds	r25, 0x5a
     948:	89 a1       	lds	r24, 0x49
     94a:	9a a1       	lds	r25, 0x4a
     94c:	8c 01       	movw	r16, r24
     94e:	f8 01       	movw	r30, r16
     950:	31 97       	sbiw	r30, 0x01	; 1
     952:	f1 f7       	brne	.-4      	; 0x950 <CO_collectBatt+0x14a>
     954:	8f 01       	movw	r16, r30
     956:	09 a3       	lds	r16, 0x59
     958:	1a a3       	lds	r17, 0x5a
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     95a:	80 e4       	ldi	r24, 0x40	; 64
     95c:	92 e0       	ldi	r25, 0x02	; 2
     95e:	0e 94 af 1c 	call	0x395e	; 0x395e <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     962:	80 e4       	ldi	r24, 0x40	; 64
     964:	92 e0       	ldi	r25, 0x02	; 2
     966:	20 e4       	ldi	r18, 0x40	; 64
     968:	32 e0       	ldi	r19, 0x02	; 2
     96a:	f9 01       	movw	r30, r18
     96c:	21 81       	ldd	r18, Z+1	; 0x01
     96e:	29 7e       	andi	r18, 0xE9	; 233
     970:	fc 01       	movw	r30, r24
     972:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     974:	80 e4       	ldi	r24, 0x40	; 64
     976:	92 e0       	ldi	r25, 0x02	; 2
     978:	20 e4       	ldi	r18, 0x40	; 64
     97a:	32 e0       	ldi	r19, 0x02	; 2
     97c:	f9 01       	movw	r30, r18
     97e:	24 81       	ldd	r18, Z+4	; 0x04
     980:	28 7f       	andi	r18, 0xF8	; 248
     982:	23 60       	ori	r18, 0x03	; 3
     984:	fc 01       	movw	r30, r24
     986:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     988:	80 e4       	ldi	r24, 0x40	; 64
     98a:	92 e0       	ldi	r25, 0x02	; 2
     98c:	20 e4       	ldi	r18, 0x40	; 64
     98e:	32 e0       	ldi	r19, 0x02	; 2
     990:	f9 01       	movw	r30, r18
     992:	22 81       	ldd	r18, Z+2	; 0x02
     994:	2f 7c       	andi	r18, 0xCF	; 207
     996:	fc 01       	movw	r30, r24
     998:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     99a:	80 e6       	ldi	r24, 0x60	; 96
     99c:	92 e0       	ldi	r25, 0x02	; 2
     99e:	20 e6       	ldi	r18, 0x60	; 96
     9a0:	32 e0       	ldi	r19, 0x02	; 2
     9a2:	f9 01       	movw	r30, r18
     9a4:	20 81       	ld	r18, Z
     9a6:	20 7e       	andi	r18, 0xE0	; 224
     9a8:	21 60       	ori	r18, 0x01	; 1
     9aa:	fc 01       	movw	r30, r24
     9ac:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     9ae:	80 e6       	ldi	r24, 0x60	; 96
     9b0:	92 e0       	ldi	r25, 0x02	; 2
     9b2:	29 e0       	ldi	r18, 0x09	; 9
     9b4:	fc 01       	movw	r30, r24
     9b6:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCB);
     9b8:	80 e4       	ldi	r24, 0x40	; 64
     9ba:	92 e0       	ldi	r25, 0x02	; 2
     9bc:	20 e4       	ldi	r18, 0x40	; 64
     9be:	32 e0       	ldi	r19, 0x02	; 2
     9c0:	f9 01       	movw	r30, r18
     9c2:	20 81       	ld	r18, Z
     9c4:	21 60       	ori	r18, 0x01	; 1
     9c6:	fc 01       	movw	r30, r24
     9c8:	20 83       	st	Z, r18
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     9ca:	80 e4       	ldi	r24, 0x40	; 64
     9cc:	92 e0       	ldi	r25, 0x02	; 2
     9ce:	0e 94 67 1e 	call	0x3cce	; 0x3cce <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     9d2:	80 e4       	ldi	r24, 0x40	; 64
     9d4:	92 e0       	ldi	r25, 0x02	; 2
     9d6:	60 e6       	ldi	r22, 0x60	; 96
     9d8:	72 e0       	ldi	r23, 0x02	; 2
     9da:	40 e0       	ldi	r20, 0x00	; 0
     9dc:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <ADC_Offset_Get_Unsigned>
     9e0:	8b a3       	lds	r24, 0x5b
    ADC_Disable(&ADCB);
     9e2:	80 e4       	ldi	r24, 0x40	; 64
     9e4:	92 e0       	ldi	r25, 0x02	; 2
     9e6:	20 e4       	ldi	r18, 0x40	; 64
     9e8:	32 e0       	ldi	r19, 0x02	; 2
     9ea:	f9 01       	movw	r30, r18
     9ec:	20 81       	ld	r18, Z
     9ee:	2e 7f       	andi	r18, 0xFE	; 254
     9f0:	fc 01       	movw	r30, r24
     9f2:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     9f4:	80 e6       	ldi	r24, 0x60	; 96
     9f6:	92 e0       	ldi	r25, 0x02	; 2
     9f8:	fc 01       	movw	r30, r24
     9fa:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     9fc:	80 e4       	ldi	r24, 0x40	; 64
     9fe:	92 e0       	ldi	r25, 0x02	; 2
     a00:	20 e4       	ldi	r18, 0x40	; 64
     a02:	32 e0       	ldi	r19, 0x02	; 2
     a04:	f9 01       	movw	r30, r18
     a06:	23 81       	ldd	r18, Z+3	; 0x03
     a08:	2f 73       	andi	r18, 0x3F	; 63
     a0a:	fc 01       	movw	r30, r24
     a0c:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     a0e:	80 e4       	ldi	r24, 0x40	; 64
     a10:	92 e0       	ldi	r25, 0x02	; 2
     a12:	20 e4       	ldi	r18, 0x40	; 64
     a14:	32 e0       	ldi	r19, 0x02	; 2
     a16:	f9 01       	movw	r30, r18
     a18:	20 81       	ld	r18, Z
     a1a:	21 60       	ori	r18, 0x01	; 1
     a1c:	fc 01       	movw	r30, r24
     a1e:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     a20:	80 e4       	ldi	r24, 0x40	; 64
     a22:	92 e0       	ldi	r25, 0x02	; 2
     a24:	0e 94 67 1e 	call	0x3cce	; 0x3cce <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     a28:	80 e4       	ldi	r24, 0x40	; 64
     a2a:	92 e0       	ldi	r25, 0x02	; 2
     a2c:	20 e4       	ldi	r18, 0x40	; 64
     a2e:	32 e0       	ldi	r19, 0x02	; 2
     a30:	f9 01       	movw	r30, r18
     a32:	21 81       	ldd	r18, Z+1	; 0x01
     a34:	28 60       	ori	r18, 0x08	; 8
     a36:	fc 01       	movw	r30, r24
     a38:	21 83       	std	Z+1, r18	; 0x01

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     a3a:	1d 86       	std	Y+13, r1	; 0x0d
     a3c:	1e 86       	std	Y+14, r1	; 0x0e
     a3e:	56 c0       	rjmp	.+172    	; 0xaec <CO_collectBatt+0x2e6>

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     a40:	80 e6       	ldi	r24, 0x60	; 96
     a42:	92 e0       	ldi	r25, 0x02	; 2
     a44:	fc 01       	movw	r30, r24
     a46:	83 81       	ldd	r24, Z+3	; 0x03
     a48:	88 2f       	mov	r24, r24
     a4a:	90 e0       	ldi	r25, 0x00	; 0
     a4c:	81 70       	andi	r24, 0x01	; 1
     a4e:	90 70       	andi	r25, 0x00	; 0
     a50:	00 97       	sbiw	r24, 0x00	; 0
     a52:	b1 f3       	breq	.-20     	; 0xa40 <CO_collectBatt+0x23a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     a54:	2b a1       	lds	r18, 0x4b
     a56:	80 e6       	ldi	r24, 0x60	; 96
     a58:	92 e0       	ldi	r25, 0x02	; 2
     a5a:	62 2f       	mov	r22, r18
     a5c:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <ADC_ResultCh_GetWord_Signed>
     a60:	8f 87       	std	Y+15, r24	; 0x0f
     a62:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResultB;
     a64:	8f 85       	ldd	r24, Y+15	; 0x0f
     a66:	98 89       	ldd	r25, Y+16	; 0x10
     a68:	cc 01       	movw	r24, r24
     a6a:	a0 e0       	ldi	r26, 0x00	; 0
     a6c:	b0 e0       	ldi	r27, 0x00	; 0
     a6e:	29 81       	ldd	r18, Y+1	; 0x01
     a70:	3a 81       	ldd	r19, Y+2	; 0x02
     a72:	4b 81       	ldd	r20, Y+3	; 0x03
     a74:	5c 81       	ldd	r21, Y+4	; 0x04
     a76:	82 0f       	add	r24, r18
     a78:	93 1f       	adc	r25, r19
     a7a:	a4 1f       	adc	r26, r20
     a7c:	b5 1f       	adc	r27, r21
     a7e:	89 83       	std	Y+1, r24	; 0x01
     a80:	9a 83       	std	Y+2, r25	; 0x02
     a82:	ab 83       	std	Y+3, r26	; 0x03
     a84:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResultB) { max = tempResultB;}
     a86:	8f 85       	ldd	r24, Y+15	; 0x0f
     a88:	98 89       	ldd	r25, Y+16	; 0x10
     a8a:	9c 01       	movw	r18, r24
     a8c:	40 e0       	ldi	r20, 0x00	; 0
     a8e:	50 e0       	ldi	r21, 0x00	; 0
     a90:	89 85       	ldd	r24, Y+9	; 0x09
     a92:	9a 85       	ldd	r25, Y+10	; 0x0a
     a94:	ab 85       	ldd	r26, Y+11	; 0x0b
     a96:	bc 85       	ldd	r27, Y+12	; 0x0c
     a98:	82 17       	cp	r24, r18
     a9a:	93 07       	cpc	r25, r19
     a9c:	a4 07       	cpc	r26, r20
     a9e:	b5 07       	cpc	r27, r21
     aa0:	48 f4       	brcc	.+18     	; 0xab4 <CO_collectBatt+0x2ae>
     aa2:	8f 85       	ldd	r24, Y+15	; 0x0f
     aa4:	98 89       	ldd	r25, Y+16	; 0x10
     aa6:	cc 01       	movw	r24, r24
     aa8:	a0 e0       	ldi	r26, 0x00	; 0
     aaa:	b0 e0       	ldi	r27, 0x00	; 0
     aac:	89 87       	std	Y+9, r24	; 0x09
     aae:	9a 87       	std	Y+10, r25	; 0x0a
     ab0:	ab 87       	std	Y+11, r26	; 0x0b
     ab2:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResultB) { min = tempResultB;}
     ab4:	8f 85       	ldd	r24, Y+15	; 0x0f
     ab6:	98 89       	ldd	r25, Y+16	; 0x10
     ab8:	9c 01       	movw	r18, r24
     aba:	40 e0       	ldi	r20, 0x00	; 0
     abc:	50 e0       	ldi	r21, 0x00	; 0
     abe:	8d 81       	ldd	r24, Y+5	; 0x05
     ac0:	9e 81       	ldd	r25, Y+6	; 0x06
     ac2:	af 81       	ldd	r26, Y+7	; 0x07
     ac4:	b8 85       	ldd	r27, Y+8	; 0x08
     ac6:	28 17       	cp	r18, r24
     ac8:	39 07       	cpc	r19, r25
     aca:	4a 07       	cpc	r20, r26
     acc:	5b 07       	cpc	r21, r27
     ace:	48 f4       	brcc	.+18     	; 0xae2 <CO_collectBatt+0x2dc>
     ad0:	8f 85       	ldd	r24, Y+15	; 0x0f
     ad2:	98 89       	ldd	r25, Y+16	; 0x10
     ad4:	cc 01       	movw	r24, r24
     ad6:	a0 e0       	ldi	r26, 0x00	; 0
     ad8:	b0 e0       	ldi	r27, 0x00	; 0
     ada:	8d 83       	std	Y+5, r24	; 0x05
     adc:	9e 83       	std	Y+6, r25	; 0x06
     ade:	af 83       	std	Y+7, r26	; 0x07
     ae0:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     ae2:	8d 85       	ldd	r24, Y+13	; 0x0d
     ae4:	9e 85       	ldd	r25, Y+14	; 0x0e
     ae6:	01 96       	adiw	r24, 0x01	; 1
     ae8:	8d 87       	std	Y+13, r24	; 0x0d
     aea:	9e 87       	std	Y+14, r25	; 0x0e
     aec:	8d 85       	ldd	r24, Y+13	; 0x0d
     aee:	9e 85       	ldd	r25, Y+14	; 0x0e
     af0:	f4 e0       	ldi	r31, 0x04	; 4
     af2:	80 30       	cpi	r24, 0x00	; 0
     af4:	9f 07       	cpc	r25, r31
     af6:	08 f4       	brcc	.+2      	; 0xafa <CO_collectBatt+0x2f4>
     af8:	a3 cf       	rjmp	.-186    	; 0xa40 <CO_collectBatt+0x23a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     afa:	80 e4       	ldi	r24, 0x40	; 64
     afc:	92 e0       	ldi	r25, 0x02	; 2
     afe:	20 e4       	ldi	r18, 0x40	; 64
     b00:	32 e0       	ldi	r19, 0x02	; 2
     b02:	f9 01       	movw	r30, r18
     b04:	21 81       	ldd	r18, Z+1	; 0x01
     b06:	27 7f       	andi	r18, 0xF7	; 247
     b08:	fc 01       	movw	r30, r24
     b0a:	21 83       	std	Z+1, r18	; 0x01
	ADC_Disable(&ADCB);
     b0c:	80 e4       	ldi	r24, 0x40	; 64
     b0e:	92 e0       	ldi	r25, 0x02	; 2
     b10:	20 e4       	ldi	r18, 0x40	; 64
     b12:	32 e0       	ldi	r19, 0x02	; 2
     b14:	f9 01       	movw	r30, r18
     b16:	20 81       	ld	r18, Z
     b18:	2e 7f       	andi	r18, 0xFE	; 254
     b1a:	fc 01       	movw	r30, r24
     b1c:	20 83       	st	Z, r18

	average = sum / NUM_SAMPLES;
     b1e:	89 81       	ldd	r24, Y+1	; 0x01
     b20:	9a 81       	ldd	r25, Y+2	; 0x02
     b22:	ab 81       	ldd	r26, Y+3	; 0x03
     b24:	bc 81       	ldd	r27, Y+4	; 0x04
     b26:	07 2e       	mov	r0, r23
     b28:	7a e0       	ldi	r23, 0x0A	; 10
     b2a:	b6 95       	lsr	r27
     b2c:	a7 95       	ror	r26
     b2e:	97 95       	ror	r25
     b30:	87 95       	ror	r24
     b32:	7a 95       	dec	r23
     b34:	d1 f7       	brne	.-12     	; 0xb2a <CO_collectBatt+0x324>
     b36:	70 2d       	mov	r23, r0
     b38:	89 8b       	std	Y+17, r24	; 0x11
     b3a:	9a 8b       	std	Y+18, r25	; 0x12
     b3c:	ab 8b       	std	Y+19, r26	; 0x13
     b3e:	bc 8b       	std	Y+20, r27	; 0x14
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     b40:	84 e0       	ldi	r24, 0x04	; 4
     b42:	60 e0       	ldi	r22, 0x00	; 0
     b44:	0e 94 9d 35 	call	0x6b3a	; 0x6b3a <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     b48:	80 e0       	ldi	r24, 0x00	; 0
     b4a:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     b4e:	89 89       	ldd	r24, Y+17	; 0x11
     b50:	9a 89       	ldd	r25, Y+18	; 0x12
     b52:	ab 89       	ldd	r26, Y+19	; 0x13
     b54:	bc 89       	ldd	r27, Y+20	; 0x14
     b56:	28 ee       	ldi	r18, 0xE8	; 232
     b58:	33 e0       	ldi	r19, 0x03	; 3
     b5a:	40 e0       	ldi	r20, 0x00	; 0
     b5c:	50 e0       	ldi	r21, 0x00	; 0
     b5e:	bc 01       	movw	r22, r24
     b60:	cd 01       	movw	r24, r26
     b62:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
     b66:	dc 01       	movw	r26, r24
     b68:	cb 01       	movw	r24, r22
     b6a:	2f ef       	ldi	r18, 0xFF	; 255
     b6c:	3f e0       	ldi	r19, 0x0F	; 15
     b6e:	40 e0       	ldi	r20, 0x00	; 0
     b70:	50 e0       	ldi	r21, 0x00	; 0
     b72:	bc 01       	movw	r22, r24
     b74:	cd 01       	movw	r24, r26
     b76:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
     b7a:	da 01       	movw	r26, r20
     b7c:	c9 01       	movw	r24, r18
     b7e:	9c 01       	movw	r18, r24
     b80:	22 53       	subi	r18, 0x32	; 50
     b82:	30 40       	sbci	r19, 0x00	; 0
     b84:	8c a1       	lds	r24, 0x4c
     b86:	9d a1       	lds	r25, 0x4d
     b88:	fc 01       	movw	r30, r24
     b8a:	20 83       	st	Z, r18
     b8c:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     b8e:	89 85       	ldd	r24, Y+9	; 0x09
     b90:	9a 85       	ldd	r25, Y+10	; 0x0a
     b92:	ab 85       	ldd	r26, Y+11	; 0x0b
     b94:	bc 85       	ldd	r27, Y+12	; 0x0c
     b96:	28 ee       	ldi	r18, 0xE8	; 232
     b98:	33 e0       	ldi	r19, 0x03	; 3
     b9a:	40 e0       	ldi	r20, 0x00	; 0
     b9c:	50 e0       	ldi	r21, 0x00	; 0
     b9e:	bc 01       	movw	r22, r24
     ba0:	cd 01       	movw	r24, r26
     ba2:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
     ba6:	dc 01       	movw	r26, r24
     ba8:	cb 01       	movw	r24, r22
     baa:	2f ef       	ldi	r18, 0xFF	; 255
     bac:	3f e0       	ldi	r19, 0x0F	; 15
     bae:	40 e0       	ldi	r20, 0x00	; 0
     bb0:	50 e0       	ldi	r21, 0x00	; 0
     bb2:	bc 01       	movw	r22, r24
     bb4:	cd 01       	movw	r24, r26
     bb6:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
     bba:	da 01       	movw	r26, r20
     bbc:	c9 01       	movw	r24, r18
     bbe:	9c 01       	movw	r18, r24
     bc0:	22 53       	subi	r18, 0x32	; 50
     bc2:	30 40       	sbci	r19, 0x00	; 0
     bc4:	88 a5       	lds	r24, 0x68
     bc6:	99 a5       	lds	r25, 0x69
     bc8:	fc 01       	movw	r30, r24
     bca:	20 83       	st	Z, r18
     bcc:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     bce:	8d 81       	ldd	r24, Y+5	; 0x05
     bd0:	9e 81       	ldd	r25, Y+6	; 0x06
     bd2:	af 81       	ldd	r26, Y+7	; 0x07
     bd4:	b8 85       	ldd	r27, Y+8	; 0x08
     bd6:	28 ee       	ldi	r18, 0xE8	; 232
     bd8:	33 e0       	ldi	r19, 0x03	; 3
     bda:	40 e0       	ldi	r20, 0x00	; 0
     bdc:	50 e0       	ldi	r21, 0x00	; 0
     bde:	bc 01       	movw	r22, r24
     be0:	cd 01       	movw	r24, r26
     be2:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
     be6:	dc 01       	movw	r26, r24
     be8:	cb 01       	movw	r24, r22
     bea:	2f ef       	ldi	r18, 0xFF	; 255
     bec:	3f e0       	ldi	r19, 0x0F	; 15
     bee:	40 e0       	ldi	r20, 0x00	; 0
     bf0:	50 e0       	ldi	r21, 0x00	; 0
     bf2:	bc 01       	movw	r22, r24
     bf4:	cd 01       	movw	r24, r26
     bf6:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
     bfa:	da 01       	movw	r26, r20
     bfc:	c9 01       	movw	r24, r18
     bfe:	9c 01       	movw	r18, r24
     c00:	22 53       	subi	r18, 0x32	; 50
     c02:	30 40       	sbci	r19, 0x00	; 0
     c04:	8e a1       	lds	r24, 0x4e
     c06:	9f a1       	lds	r25, 0x4f
     c08:	fc 01       	movw	r30, r24
     c0a:	20 83       	st	Z, r18
     c0c:	31 83       	std	Z+1, r19	; 0x01
}
     c0e:	a9 96       	adiw	r28, 0x29	; 41
     c10:	cd bf       	out	0x3d, r28	; 61
     c12:	de bf       	out	0x3e, r29	; 62
     c14:	df 91       	pop	r29
     c16:	cf 91       	pop	r28
     c18:	1f 91       	pop	r17
     c1a:	0f 91       	pop	r16
     c1c:	08 95       	ret

00000c1e <ADCPower>:

void ADCPower(uint8_t on) {
     c1e:	0f 93       	push	r16
     c20:	1f 93       	push	r17
     c22:	cf 93       	push	r28
     c24:	df 93       	push	r29
     c26:	cd b7       	in	r28, 0x3d	; 61
     c28:	de b7       	in	r29, 0x3e	; 62
     c2a:	2f 97       	sbiw	r28, 0x0f	; 15
     c2c:	cd bf       	out	0x3d, r28	; 61
     c2e:	de bf       	out	0x3e, r29	; 62
     c30:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
     c32:	8f 85       	ldd	r24, Y+15	; 0x0f
     c34:	88 23       	and	r24, r24
     c36:	09 f4       	brne	.+2      	; 0xc3a <ADCPower+0x1c>
     c38:	ce c0       	rjmp	.+412    	; 0xdd6 <ADCPower+0x1b8>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     c3a:	80 e0       	ldi	r24, 0x00	; 0
     c3c:	96 e0       	ldi	r25, 0x06	; 6
     c3e:	2e ed       	ldi	r18, 0xDE	; 222
     c40:	fc 01       	movw	r30, r24
     c42:	21 83       	std	Z+1, r18	; 0x01
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     c44:	80 e2       	ldi	r24, 0x20	; 32
     c46:	96 e0       	ldi	r25, 0x06	; 6
     c48:	2e e0       	ldi	r18, 0x0E	; 14
     c4a:	fc 01       	movw	r30, r24
     c4c:	21 83       	std	Z+1, r18	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     c4e:	80 e4       	ldi	r24, 0x40	; 64
     c50:	96 e0       	ldi	r25, 0x06	; 6
     c52:	23 e0       	ldi	r18, 0x03	; 3
     c54:	fc 01       	movw	r30, r24
     c56:	21 83       	std	Z+1, r18	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     c58:	80 e8       	ldi	r24, 0x80	; 128
     c5a:	96 e0       	ldi	r25, 0x06	; 6
     c5c:	20 e1       	ldi	r18, 0x10	; 16
     c5e:	fc 01       	movw	r30, r24
     c60:	21 83       	std	Z+1, r18	; 0x01
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     c62:	80 ea       	ldi	r24, 0xA0	; 160
     c64:	96 e0       	ldi	r25, 0x06	; 6
     c66:	2e e0       	ldi	r18, 0x0E	; 14
     c68:	fc 01       	movw	r30, r24
     c6a:	21 83       	std	Z+1, r18	; 0x01

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     c6c:	80 e0       	ldi	r24, 0x00	; 0
     c6e:	96 e0       	ldi	r25, 0x06	; 6
     c70:	2e e9       	ldi	r18, 0x9E	; 158
     c72:	fc 01       	movw	r30, r24
     c74:	25 83       	std	Z+5, r18	; 0x05
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     c76:	80 e2       	ldi	r24, 0x20	; 32
     c78:	96 e0       	ldi	r25, 0x06	; 6
     c7a:	28 e0       	ldi	r18, 0x08	; 8
     c7c:	fc 01       	movw	r30, r24
     c7e:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     c80:	80 e4       	ldi	r24, 0x40	; 64
     c82:	96 e0       	ldi	r25, 0x06	; 6
     c84:	23 e0       	ldi	r18, 0x03	; 3
     c86:	fc 01       	movw	r30, r24
     c88:	25 83       	std	Z+5, r18	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     c8a:	80 e8       	ldi	r24, 0x80	; 128
     c8c:	96 e0       	ldi	r25, 0x06	; 6
     c8e:	20 e1       	ldi	r18, 0x10	; 16
     c90:	fc 01       	movw	r30, r24
     c92:	25 83       	std	Z+5, r18	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     c94:	80 ea       	ldi	r24, 0xA0	; 160
     c96:	96 e0       	ldi	r25, 0x06	; 6
     c98:	2e e0       	ldi	r18, 0x0E	; 14
     c9a:	fc 01       	movw	r30, r24
     c9c:	25 83       	std	Z+5, r18	; 0x05
		channelStatus = 0x00; // POR to zeros
     c9e:	10 92 7e 50 	sts	0x507E, r1
     ca2:	80 e0       	ldi	r24, 0x00	; 0
     ca4:	90 e0       	ldi	r25, 0x00	; 0
     ca6:	a8 ec       	ldi	r26, 0xC8	; 200
     ca8:	b2 e4       	ldi	r27, 0x42	; 66
     caa:	89 83       	std	Y+1, r24	; 0x01
     cac:	9a 83       	std	Y+2, r25	; 0x02
     cae:	ab 83       	std	Y+3, r26	; 0x03
     cb0:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     cb2:	69 81       	ldd	r22, Y+1	; 0x01
     cb4:	7a 81       	ldd	r23, Y+2	; 0x02
     cb6:	8b 81       	ldd	r24, Y+3	; 0x03
     cb8:	9c 81       	ldd	r25, Y+4	; 0x04
     cba:	20 e0       	ldi	r18, 0x00	; 0
     cbc:	30 e0       	ldi	r19, 0x00	; 0
     cbe:	4a ef       	ldi	r20, 0xFA	; 250
     cc0:	55 e4       	ldi	r21, 0x45	; 69
     cc2:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
     cc6:	dc 01       	movw	r26, r24
     cc8:	cb 01       	movw	r24, r22
     cca:	8d 83       	std	Y+5, r24	; 0x05
     ccc:	9e 83       	std	Y+6, r25	; 0x06
     cce:	af 83       	std	Y+7, r26	; 0x07
     cd0:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     cd2:	11 e0       	ldi	r17, 0x01	; 1
     cd4:	6d 81       	ldd	r22, Y+5	; 0x05
     cd6:	7e 81       	ldd	r23, Y+6	; 0x06
     cd8:	8f 81       	ldd	r24, Y+7	; 0x07
     cda:	98 85       	ldd	r25, Y+8	; 0x08
     cdc:	20 e0       	ldi	r18, 0x00	; 0
     cde:	30 e0       	ldi	r19, 0x00	; 0
     ce0:	40 e8       	ldi	r20, 0x80	; 128
     ce2:	5f e3       	ldi	r21, 0x3F	; 63
     ce4:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
     ce8:	88 23       	and	r24, r24
     cea:	0c f0       	brlt	.+2      	; 0xcee <ADCPower+0xd0>
     cec:	10 e0       	ldi	r17, 0x00	; 0
     cee:	11 23       	and	r17, r17
     cf0:	29 f0       	breq	.+10     	; 0xcfc <ADCPower+0xde>
		__ticks = 1;
     cf2:	81 e0       	ldi	r24, 0x01	; 1
     cf4:	90 e0       	ldi	r25, 0x00	; 0
     cf6:	89 87       	std	Y+9, r24	; 0x09
     cf8:	9a 87       	std	Y+10, r25	; 0x0a
     cfa:	46 c0       	rjmp	.+140    	; 0xd88 <ADCPower+0x16a>
	else if (__tmp > 65535)
     cfc:	11 e0       	ldi	r17, 0x01	; 1
     cfe:	6d 81       	ldd	r22, Y+5	; 0x05
     d00:	7e 81       	ldd	r23, Y+6	; 0x06
     d02:	8f 81       	ldd	r24, Y+7	; 0x07
     d04:	98 85       	ldd	r25, Y+8	; 0x08
     d06:	20 e0       	ldi	r18, 0x00	; 0
     d08:	3f ef       	ldi	r19, 0xFF	; 255
     d0a:	4f e7       	ldi	r20, 0x7F	; 127
     d0c:	57 e4       	ldi	r21, 0x47	; 71
     d0e:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
     d12:	18 16       	cp	r1, r24
     d14:	0c f0       	brlt	.+2      	; 0xd18 <ADCPower+0xfa>
     d16:	10 e0       	ldi	r17, 0x00	; 0
     d18:	11 23       	and	r17, r17
     d1a:	61 f1       	breq	.+88     	; 0xd74 <ADCPower+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     d1c:	69 81       	ldd	r22, Y+1	; 0x01
     d1e:	7a 81       	ldd	r23, Y+2	; 0x02
     d20:	8b 81       	ldd	r24, Y+3	; 0x03
     d22:	9c 81       	ldd	r25, Y+4	; 0x04
     d24:	20 e0       	ldi	r18, 0x00	; 0
     d26:	30 e0       	ldi	r19, 0x00	; 0
     d28:	40 e2       	ldi	r20, 0x20	; 32
     d2a:	51 e4       	ldi	r21, 0x41	; 65
     d2c:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
     d30:	dc 01       	movw	r26, r24
     d32:	cb 01       	movw	r24, r22
     d34:	bc 01       	movw	r22, r24
     d36:	cd 01       	movw	r24, r26
     d38:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
     d3c:	dc 01       	movw	r26, r24
     d3e:	cb 01       	movw	r24, r22
     d40:	89 87       	std	Y+9, r24	; 0x09
     d42:	9a 87       	std	Y+10, r25	; 0x0a
     d44:	12 c0       	rjmp	.+36     	; 0xd6a <ADCPower+0x14c>
     d46:	80 e2       	ldi	r24, 0x20	; 32
     d48:	93 e0       	ldi	r25, 0x03	; 3
     d4a:	8b 87       	std	Y+11, r24	; 0x0b
     d4c:	9c 87       	std	Y+12, r25	; 0x0c
     d4e:	8b 85       	ldd	r24, Y+11	; 0x0b
     d50:	9c 85       	ldd	r25, Y+12	; 0x0c
     d52:	8c 01       	movw	r16, r24
     d54:	c8 01       	movw	r24, r16
     d56:	01 97       	sbiw	r24, 0x01	; 1
     d58:	f1 f7       	brne	.-4      	; 0xd56 <ADCPower+0x138>
     d5a:	8c 01       	movw	r16, r24
     d5c:	0b 87       	std	Y+11, r16	; 0x0b
     d5e:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     d60:	89 85       	ldd	r24, Y+9	; 0x09
     d62:	9a 85       	ldd	r25, Y+10	; 0x0a
     d64:	01 97       	sbiw	r24, 0x01	; 1
     d66:	89 87       	std	Y+9, r24	; 0x09
     d68:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     d6a:	89 85       	ldd	r24, Y+9	; 0x09
     d6c:	9a 85       	ldd	r25, Y+10	; 0x0a
     d6e:	00 97       	sbiw	r24, 0x00	; 0
     d70:	51 f7       	brne	.-44     	; 0xd46 <ADCPower+0x128>
     d72:	17 c0       	rjmp	.+46     	; 0xda2 <ADCPower+0x184>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     d74:	6d 81       	ldd	r22, Y+5	; 0x05
     d76:	7e 81       	ldd	r23, Y+6	; 0x06
     d78:	8f 81       	ldd	r24, Y+7	; 0x07
     d7a:	98 85       	ldd	r25, Y+8	; 0x08
     d7c:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
     d80:	dc 01       	movw	r26, r24
     d82:	cb 01       	movw	r24, r22
     d84:	89 87       	std	Y+9, r24	; 0x09
     d86:	9a 87       	std	Y+10, r25	; 0x0a
     d88:	89 85       	ldd	r24, Y+9	; 0x09
     d8a:	9a 85       	ldd	r25, Y+10	; 0x0a
     d8c:	8d 87       	std	Y+13, r24	; 0x0d
     d8e:	9e 87       	std	Y+14, r25	; 0x0e
     d90:	8d 85       	ldd	r24, Y+13	; 0x0d
     d92:	9e 85       	ldd	r25, Y+14	; 0x0e
     d94:	8c 01       	movw	r16, r24
     d96:	f8 01       	movw	r30, r16
     d98:	31 97       	sbiw	r30, 0x01	; 1
     d9a:	f1 f7       	brne	.-4      	; 0xd98 <ADCPower+0x17a>
     d9c:	8f 01       	movw	r16, r30
     d9e:	0d 87       	std	Y+13, r16	; 0x0d
     da0:	1e 87       	std	Y+14, r17	; 0x0e
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     da2:	80 e4       	ldi	r24, 0x40	; 64
     da4:	96 e0       	ldi	r25, 0x06	; 6
     da6:	20 e4       	ldi	r18, 0x40	; 64
     da8:	fc 01       	movw	r30, r24
     daa:	22 83       	std	Z+2, r18	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     dac:	80 e0       	ldi	r24, 0x00	; 0
     dae:	80 93 7f 50 	sts	0x507F, r24
     db2:	80 93 d2 50 	sts	0x50D2, r24
     db6:	80 93 d7 23 	sts	0x23D7, r24
     dba:	80 93 77 50 	sts	0x5077, r24
		PortEx_DIRSET(0xFF, PS_BANKA);
     dbe:	8f ef       	ldi	r24, 0xFF	; 255
     dc0:	61 e0       	ldi	r22, 0x01	; 1
     dc2:	0e 94 39 35 	call	0x6a72	; 0x6a72 <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     dc6:	8f ef       	ldi	r24, 0xFF	; 255
     dc8:	61 e0       	ldi	r22, 0x01	; 1
     dca:	0e 94 05 36 	call	0x6c0a	; 0x6c0a <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     dce:	8f ef       	ldi	r24, 0xFF	; 255
     dd0:	0e 94 64 08 	call	0x10c8	; 0x10c8 <set_filter>
     dd4:	42 c0       	rjmp	.+132    	; 0xe5a <ADCPower+0x23c>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     dd6:	80 e0       	ldi	r24, 0x00	; 0
     dd8:	96 e0       	ldi	r25, 0x06	; 6
     dda:	2e ed       	ldi	r18, 0xDE	; 222
     ddc:	fc 01       	movw	r30, r24
     dde:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     de0:	80 e2       	ldi	r24, 0x20	; 32
     de2:	96 e0       	ldi	r25, 0x06	; 6
     de4:	2e e0       	ldi	r18, 0x0E	; 14
     de6:	fc 01       	movw	r30, r24
     de8:	26 83       	std	Z+6, r18	; 0x06
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     dea:	80 e4       	ldi	r24, 0x40	; 64
     dec:	96 e0       	ldi	r25, 0x06	; 6
     dee:	23 e0       	ldi	r18, 0x03	; 3
     df0:	fc 01       	movw	r30, r24
     df2:	26 83       	std	Z+6, r18	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     df4:	80 e8       	ldi	r24, 0x80	; 128
     df6:	96 e0       	ldi	r25, 0x06	; 6
     df8:	20 e1       	ldi	r18, 0x10	; 16
     dfa:	fc 01       	movw	r30, r24
     dfc:	26 83       	std	Z+6, r18	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     dfe:	80 ea       	ldi	r24, 0xA0	; 160
     e00:	96 e0       	ldi	r25, 0x06	; 6
     e02:	2e e0       	ldi	r18, 0x0E	; 14
     e04:	fc 01       	movw	r30, r24
     e06:	26 83       	std	Z+6, r18	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     e08:	80 e0       	ldi	r24, 0x00	; 0
     e0a:	96 e0       	ldi	r25, 0x06	; 6
     e0c:	2e ed       	ldi	r18, 0xDE	; 222
     e0e:	fc 01       	movw	r30, r24
     e10:	22 83       	std	Z+2, r18	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     e12:	80 e2       	ldi	r24, 0x20	; 32
     e14:	96 e0       	ldi	r25, 0x06	; 6
     e16:	2e e0       	ldi	r18, 0x0E	; 14
     e18:	fc 01       	movw	r30, r24
     e1a:	22 83       	std	Z+2, r18	; 0x02
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     e1c:	80 e4       	ldi	r24, 0x40	; 64
     e1e:	96 e0       	ldi	r25, 0x06	; 6
     e20:	23 e0       	ldi	r18, 0x03	; 3
     e22:	fc 01       	movw	r30, r24
     e24:	22 83       	std	Z+2, r18	; 0x02
		PORTE.DIRCLR = PIN4_bm;
     e26:	80 e8       	ldi	r24, 0x80	; 128
     e28:	96 e0       	ldi	r25, 0x06	; 6
     e2a:	20 e1       	ldi	r18, 0x10	; 16
     e2c:	fc 01       	movw	r30, r24
     e2e:	22 83       	std	Z+2, r18	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     e30:	80 ea       	ldi	r24, 0xA0	; 160
     e32:	96 e0       	ldi	r25, 0x06	; 6
     e34:	2e e0       	ldi	r18, 0x0E	; 14
     e36:	fc 01       	movw	r30, r24
     e38:	22 83       	std	Z+2, r18	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     e3a:	80 e4       	ldi	r24, 0x40	; 64
     e3c:	96 e0       	ldi	r25, 0x06	; 6
     e3e:	20 e4       	ldi	r18, 0x40	; 64
     e40:	fc 01       	movw	r30, r24
     e42:	22 83       	std	Z+2, r18	; 0x02
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     e44:	80 e0       	ldi	r24, 0x00	; 0
     e46:	80 93 7f 50 	sts	0x507F, r24
     e4a:	80 93 d2 50 	sts	0x50D2, r24
     e4e:	80 93 d7 23 	sts	0x23D7, r24
     e52:	80 93 77 50 	sts	0x5077, r24
		channelStatus = 0x00;
     e56:	10 92 7e 50 	sts	0x507E, r1
		
	}
}
     e5a:	2f 96       	adiw	r28, 0x0f	; 15
     e5c:	cd bf       	out	0x3d, r28	; 61
     e5e:	de bf       	out	0x3e, r29	; 62
     e60:	df 91       	pop	r29
     e62:	cf 91       	pop	r28
     e64:	1f 91       	pop	r17
     e66:	0f 91       	pop	r16
     e68:	08 95       	ret

00000e6a <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     e6a:	0f 93       	push	r16
     e6c:	1f 93       	push	r17
     e6e:	cf 93       	push	r28
     e70:	df 93       	push	r29
     e72:	cd b7       	in	r28, 0x3d	; 61
     e74:	de b7       	in	r29, 0x3e	; 62
     e76:	6a 97       	sbiw	r28, 0x1a	; 26
     e78:	cd bf       	out	0x3d, r28	; 61
     e7a:	de bf       	out	0x3e, r29	; 62
     e7c:	89 8f       	std	Y+25, r24	; 0x19
     e7e:	6a 8f       	std	Y+26, r22	; 0x1a
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     e80:	89 8d       	ldd	r24, Y+25	; 0x19
     e82:	28 2f       	mov	r18, r24
     e84:	30 e0       	ldi	r19, 0x00	; 0
     e86:	81 e0       	ldi	r24, 0x01	; 1
     e88:	90 e0       	ldi	r25, 0x00	; 0
     e8a:	02 c0       	rjmp	.+4      	; 0xe90 <set_ampGain+0x26>
     e8c:	88 0f       	add	r24, r24
     e8e:	99 1f       	adc	r25, r25
     e90:	2a 95       	dec	r18
     e92:	e2 f7       	brpl	.-8      	; 0xe8c <set_ampGain+0x22>
     e94:	61 e0       	ldi	r22, 0x01	; 1
     e96:	0e 94 68 36 	call	0x6cd0	; 0x6cd0 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     e9a:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e9c:	88 2f       	mov	r24, r24
     e9e:	90 e0       	ldi	r25, 0x00	; 0
     ea0:	81 70       	andi	r24, 0x01	; 1
     ea2:	90 70       	andi	r25, 0x00	; 0
     ea4:	88 23       	and	r24, r24
     ea6:	31 f0       	breq	.+12     	; 0xeb4 <set_ampGain+0x4a>
     ea8:	80 e0       	ldi	r24, 0x00	; 0
     eaa:	96 e0       	ldi	r25, 0x06	; 6
     eac:	20 e4       	ldi	r18, 0x40	; 64
     eae:	fc 01       	movw	r30, r24
     eb0:	25 83       	std	Z+5, r18	; 0x05
     eb2:	05 c0       	rjmp	.+10     	; 0xebe <set_ampGain+0x54>
	else {PORTA.OUTCLR = PIN6_bm;}
     eb4:	80 e0       	ldi	r24, 0x00	; 0
     eb6:	96 e0       	ldi	r25, 0x06	; 6
     eb8:	20 e4       	ldi	r18, 0x40	; 64
     eba:	fc 01       	movw	r30, r24
     ebc:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     ebe:	8a 8d       	ldd	r24, Y+26	; 0x1a
     ec0:	88 2f       	mov	r24, r24
     ec2:	90 e0       	ldi	r25, 0x00	; 0
     ec4:	82 70       	andi	r24, 0x02	; 2
     ec6:	90 70       	andi	r25, 0x00	; 0
     ec8:	00 97       	sbiw	r24, 0x00	; 0
     eca:	31 f0       	breq	.+12     	; 0xed8 <set_ampGain+0x6e>
     ecc:	80 e2       	ldi	r24, 0x20	; 32
     ece:	96 e0       	ldi	r25, 0x06	; 6
     ed0:	22 e0       	ldi	r18, 0x02	; 2
     ed2:	fc 01       	movw	r30, r24
     ed4:	25 83       	std	Z+5, r18	; 0x05
     ed6:	05 c0       	rjmp	.+10     	; 0xee2 <set_ampGain+0x78>
	else {PORTB.OUTCLR = PIN1_bm;}
     ed8:	80 e2       	ldi	r24, 0x20	; 32
     eda:	96 e0       	ldi	r25, 0x06	; 6
     edc:	22 e0       	ldi	r18, 0x02	; 2
     ede:	fc 01       	movw	r30, r24
     ee0:	26 83       	std	Z+6, r18	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     ee2:	8a 8d       	ldd	r24, Y+26	; 0x1a
     ee4:	88 2f       	mov	r24, r24
     ee6:	90 e0       	ldi	r25, 0x00	; 0
     ee8:	84 70       	andi	r24, 0x04	; 4
     eea:	90 70       	andi	r25, 0x00	; 0
     eec:	00 97       	sbiw	r24, 0x00	; 0
     eee:	31 f0       	breq	.+12     	; 0xefc <set_ampGain+0x92>
     ef0:	80 e2       	ldi	r24, 0x20	; 32
     ef2:	96 e0       	ldi	r25, 0x06	; 6
     ef4:	24 e0       	ldi	r18, 0x04	; 4
     ef6:	fc 01       	movw	r30, r24
     ef8:	25 83       	std	Z+5, r18	; 0x05
     efa:	05 c0       	rjmp	.+10     	; 0xf06 <set_ampGain+0x9c>
	else {PORTB.OUTCLR = PIN2_bm;}
     efc:	80 e2       	ldi	r24, 0x20	; 32
     efe:	96 e0       	ldi	r25, 0x06	; 6
     f00:	24 e0       	ldi	r18, 0x04	; 4
     f02:	fc 01       	movw	r30, r24
     f04:	26 83       	std	Z+6, r18	; 0x06
     f06:	80 e0       	ldi	r24, 0x00	; 0
     f08:	90 e0       	ldi	r25, 0x00	; 0
     f0a:	a0 e8       	ldi	r26, 0x80	; 128
     f0c:	bf e3       	ldi	r27, 0x3F	; 63
     f0e:	89 83       	std	Y+1, r24	; 0x01
     f10:	9a 83       	std	Y+2, r25	; 0x02
     f12:	ab 83       	std	Y+3, r26	; 0x03
     f14:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
     f16:	69 81       	ldd	r22, Y+1	; 0x01
     f18:	7a 81       	ldd	r23, Y+2	; 0x02
     f1a:	8b 81       	ldd	r24, Y+3	; 0x03
     f1c:	9c 81       	ldd	r25, Y+4	; 0x04
     f1e:	2b ea       	ldi	r18, 0xAB	; 171
     f20:	3a ea       	ldi	r19, 0xAA	; 170
     f22:	4a e2       	ldi	r20, 0x2A	; 42
     f24:	51 e4       	ldi	r21, 0x41	; 65
     f26:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
     f2a:	dc 01       	movw	r26, r24
     f2c:	cb 01       	movw	r24, r22
     f2e:	8d 83       	std	Y+5, r24	; 0x05
     f30:	9e 83       	std	Y+6, r25	; 0x06
     f32:	af 83       	std	Y+7, r26	; 0x07
     f34:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     f36:	11 e0       	ldi	r17, 0x01	; 1
     f38:	6d 81       	ldd	r22, Y+5	; 0x05
     f3a:	7e 81       	ldd	r23, Y+6	; 0x06
     f3c:	8f 81       	ldd	r24, Y+7	; 0x07
     f3e:	98 85       	ldd	r25, Y+8	; 0x08
     f40:	20 e0       	ldi	r18, 0x00	; 0
     f42:	30 e0       	ldi	r19, 0x00	; 0
     f44:	40 e8       	ldi	r20, 0x80	; 128
     f46:	5f e3       	ldi	r21, 0x3F	; 63
     f48:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
     f4c:	88 23       	and	r24, r24
     f4e:	0c f0       	brlt	.+2      	; 0xf52 <set_ampGain+0xe8>
     f50:	10 e0       	ldi	r17, 0x00	; 0
     f52:	11 23       	and	r17, r17
     f54:	19 f0       	breq	.+6      	; 0xf5c <set_ampGain+0xf2>
		__ticks = 1;
     f56:	81 e0       	ldi	r24, 0x01	; 1
     f58:	89 87       	std	Y+9, r24	; 0x09
     f5a:	a3 c0       	rjmp	.+326    	; 0x10a2 <set_ampGain+0x238>
	else if (__tmp > 255)
     f5c:	11 e0       	ldi	r17, 0x01	; 1
     f5e:	6d 81       	ldd	r22, Y+5	; 0x05
     f60:	7e 81       	ldd	r23, Y+6	; 0x06
     f62:	8f 81       	ldd	r24, Y+7	; 0x07
     f64:	98 85       	ldd	r25, Y+8	; 0x08
     f66:	20 e0       	ldi	r18, 0x00	; 0
     f68:	30 e0       	ldi	r19, 0x00	; 0
     f6a:	4f e7       	ldi	r20, 0x7F	; 127
     f6c:	53 e4       	ldi	r21, 0x43	; 67
     f6e:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
     f72:	18 16       	cp	r1, r24
     f74:	0c f0       	brlt	.+2      	; 0xf78 <set_ampGain+0x10e>
     f76:	10 e0       	ldi	r17, 0x00	; 0
     f78:	11 23       	and	r17, r17
     f7a:	09 f4       	brne	.+2      	; 0xf7e <set_ampGain+0x114>
     f7c:	89 c0       	rjmp	.+274    	; 0x1090 <set_ampGain+0x226>
	{
		_delay_ms(__us / 1000.0);
     f7e:	69 81       	ldd	r22, Y+1	; 0x01
     f80:	7a 81       	ldd	r23, Y+2	; 0x02
     f82:	8b 81       	ldd	r24, Y+3	; 0x03
     f84:	9c 81       	ldd	r25, Y+4	; 0x04
     f86:	20 e0       	ldi	r18, 0x00	; 0
     f88:	30 e0       	ldi	r19, 0x00	; 0
     f8a:	4a e7       	ldi	r20, 0x7A	; 122
     f8c:	54 e4       	ldi	r21, 0x44	; 68
     f8e:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
     f92:	dc 01       	movw	r26, r24
     f94:	cb 01       	movw	r24, r22
     f96:	8a 87       	std	Y+10, r24	; 0x0a
     f98:	9b 87       	std	Y+11, r25	; 0x0b
     f9a:	ac 87       	std	Y+12, r26	; 0x0c
     f9c:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     f9e:	6a 85       	ldd	r22, Y+10	; 0x0a
     fa0:	7b 85       	ldd	r23, Y+11	; 0x0b
     fa2:	8c 85       	ldd	r24, Y+12	; 0x0c
     fa4:	9d 85       	ldd	r25, Y+13	; 0x0d
     fa6:	20 e0       	ldi	r18, 0x00	; 0
     fa8:	30 e0       	ldi	r19, 0x00	; 0
     faa:	4a ef       	ldi	r20, 0xFA	; 250
     fac:	55 e4       	ldi	r21, 0x45	; 69
     fae:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
     fb2:	dc 01       	movw	r26, r24
     fb4:	cb 01       	movw	r24, r22
     fb6:	8e 87       	std	Y+14, r24	; 0x0e
     fb8:	9f 87       	std	Y+15, r25	; 0x0f
     fba:	a8 8b       	std	Y+16, r26	; 0x10
     fbc:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
     fbe:	11 e0       	ldi	r17, 0x01	; 1
     fc0:	6e 85       	ldd	r22, Y+14	; 0x0e
     fc2:	7f 85       	ldd	r23, Y+15	; 0x0f
     fc4:	88 89       	ldd	r24, Y+16	; 0x10
     fc6:	99 89       	ldd	r25, Y+17	; 0x11
     fc8:	20 e0       	ldi	r18, 0x00	; 0
     fca:	30 e0       	ldi	r19, 0x00	; 0
     fcc:	40 e8       	ldi	r20, 0x80	; 128
     fce:	5f e3       	ldi	r21, 0x3F	; 63
     fd0:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
     fd4:	88 23       	and	r24, r24
     fd6:	0c f0       	brlt	.+2      	; 0xfda <set_ampGain+0x170>
     fd8:	10 e0       	ldi	r17, 0x00	; 0
     fda:	11 23       	and	r17, r17
     fdc:	29 f0       	breq	.+10     	; 0xfe8 <set_ampGain+0x17e>
		__ticks = 1;
     fde:	81 e0       	ldi	r24, 0x01	; 1
     fe0:	90 e0       	ldi	r25, 0x00	; 0
     fe2:	8a 8b       	std	Y+18, r24	; 0x12
     fe4:	9b 8b       	std	Y+19, r25	; 0x13
     fe6:	46 c0       	rjmp	.+140    	; 0x1074 <set_ampGain+0x20a>
	else if (__tmp > 65535)
     fe8:	11 e0       	ldi	r17, 0x01	; 1
     fea:	6e 85       	ldd	r22, Y+14	; 0x0e
     fec:	7f 85       	ldd	r23, Y+15	; 0x0f
     fee:	88 89       	ldd	r24, Y+16	; 0x10
     ff0:	99 89       	ldd	r25, Y+17	; 0x11
     ff2:	20 e0       	ldi	r18, 0x00	; 0
     ff4:	3f ef       	ldi	r19, 0xFF	; 255
     ff6:	4f e7       	ldi	r20, 0x7F	; 127
     ff8:	57 e4       	ldi	r21, 0x47	; 71
     ffa:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
     ffe:	18 16       	cp	r1, r24
    1000:	0c f0       	brlt	.+2      	; 0x1004 <set_ampGain+0x19a>
    1002:	10 e0       	ldi	r17, 0x00	; 0
    1004:	11 23       	and	r17, r17
    1006:	61 f1       	breq	.+88     	; 0x1060 <set_ampGain+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1008:	6a 85       	ldd	r22, Y+10	; 0x0a
    100a:	7b 85       	ldd	r23, Y+11	; 0x0b
    100c:	8c 85       	ldd	r24, Y+12	; 0x0c
    100e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1010:	20 e0       	ldi	r18, 0x00	; 0
    1012:	30 e0       	ldi	r19, 0x00	; 0
    1014:	40 e2       	ldi	r20, 0x20	; 32
    1016:	51 e4       	ldi	r21, 0x41	; 65
    1018:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    101c:	dc 01       	movw	r26, r24
    101e:	cb 01       	movw	r24, r22
    1020:	bc 01       	movw	r22, r24
    1022:	cd 01       	movw	r24, r26
    1024:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    1028:	dc 01       	movw	r26, r24
    102a:	cb 01       	movw	r24, r22
    102c:	8a 8b       	std	Y+18, r24	; 0x12
    102e:	9b 8b       	std	Y+19, r25	; 0x13
    1030:	12 c0       	rjmp	.+36     	; 0x1056 <set_ampGain+0x1ec>
    1032:	80 e2       	ldi	r24, 0x20	; 32
    1034:	93 e0       	ldi	r25, 0x03	; 3
    1036:	8c 8b       	std	Y+20, r24	; 0x14
    1038:	9d 8b       	std	Y+21, r25	; 0x15
    103a:	8c 89       	ldd	r24, Y+20	; 0x14
    103c:	9d 89       	ldd	r25, Y+21	; 0x15
    103e:	8c 01       	movw	r16, r24
    1040:	c8 01       	movw	r24, r16
    1042:	01 97       	sbiw	r24, 0x01	; 1
    1044:	f1 f7       	brne	.-4      	; 0x1042 <set_ampGain+0x1d8>
    1046:	8c 01       	movw	r16, r24
    1048:	0c 8b       	std	Y+20, r16	; 0x14
    104a:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    104c:	8a 89       	ldd	r24, Y+18	; 0x12
    104e:	9b 89       	ldd	r25, Y+19	; 0x13
    1050:	01 97       	sbiw	r24, 0x01	; 1
    1052:	8a 8b       	std	Y+18, r24	; 0x12
    1054:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1056:	8a 89       	ldd	r24, Y+18	; 0x12
    1058:	9b 89       	ldd	r25, Y+19	; 0x13
    105a:	00 97       	sbiw	r24, 0x00	; 0
    105c:	51 f7       	brne	.-44     	; 0x1032 <set_ampGain+0x1c8>
    105e:	28 c0       	rjmp	.+80     	; 0x10b0 <set_ampGain+0x246>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1060:	6e 85       	ldd	r22, Y+14	; 0x0e
    1062:	7f 85       	ldd	r23, Y+15	; 0x0f
    1064:	88 89       	ldd	r24, Y+16	; 0x10
    1066:	99 89       	ldd	r25, Y+17	; 0x11
    1068:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    106c:	dc 01       	movw	r26, r24
    106e:	cb 01       	movw	r24, r22
    1070:	8a 8b       	std	Y+18, r24	; 0x12
    1072:	9b 8b       	std	Y+19, r25	; 0x13
    1074:	8a 89       	ldd	r24, Y+18	; 0x12
    1076:	9b 89       	ldd	r25, Y+19	; 0x13
    1078:	8e 8b       	std	Y+22, r24	; 0x16
    107a:	9f 8b       	std	Y+23, r25	; 0x17
    107c:	8e 89       	ldd	r24, Y+22	; 0x16
    107e:	9f 89       	ldd	r25, Y+23	; 0x17
    1080:	8c 01       	movw	r16, r24
    1082:	f8 01       	movw	r30, r16
    1084:	31 97       	sbiw	r30, 0x01	; 1
    1086:	f1 f7       	brne	.-4      	; 0x1084 <set_ampGain+0x21a>
    1088:	8f 01       	movw	r16, r30
    108a:	0e 8b       	std	Y+22, r16	; 0x16
    108c:	1f 8b       	std	Y+23, r17	; 0x17
    108e:	10 c0       	rjmp	.+32     	; 0x10b0 <set_ampGain+0x246>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1090:	6d 81       	ldd	r22, Y+5	; 0x05
    1092:	7e 81       	ldd	r23, Y+6	; 0x06
    1094:	8f 81       	ldd	r24, Y+7	; 0x07
    1096:	98 85       	ldd	r25, Y+8	; 0x08
    1098:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    109c:	dc 01       	movw	r26, r24
    109e:	cb 01       	movw	r24, r22
    10a0:	89 87       	std	Y+9, r24	; 0x09
    10a2:	89 85       	ldd	r24, Y+9	; 0x09
    10a4:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    10a6:	88 8d       	ldd	r24, Y+24	; 0x18
    10a8:	18 2f       	mov	r17, r24
    10aa:	1a 95       	dec	r17
    10ac:	f1 f7       	brne	.-4      	; 0x10aa <set_ampGain+0x240>
    10ae:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    10b0:	8f ef       	ldi	r24, 0xFF	; 255
    10b2:	61 e0       	ldi	r22, 0x01	; 1
    10b4:	0e 94 05 36 	call	0x6c0a	; 0x6c0a <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    10b8:	6a 96       	adiw	r28, 0x1a	; 26
    10ba:	cd bf       	out	0x3d, r28	; 61
    10bc:	de bf       	out	0x3e, r29	; 62
    10be:	df 91       	pop	r29
    10c0:	cf 91       	pop	r28
    10c2:	1f 91       	pop	r17
    10c4:	0f 91       	pop	r16
    10c6:	08 95       	ret

000010c8 <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
    10c8:	cf 93       	push	r28
    10ca:	df 93       	push	r29
    10cc:	00 d0       	rcall	.+0      	; 0x10ce <set_filter+0x6>
    10ce:	cd b7       	in	r28, 0x3d	; 61
    10d0:	de b7       	in	r29, 0x3e	; 62
    10d2:	8b 83       	std	Y+3, r24	; 0x03
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
    10d4:	8b 81       	ldd	r24, Y+3	; 0x03
    10d6:	83 70       	andi	r24, 0x03	; 3
    10d8:	89 83       	std	Y+1, r24	; 0x01
	uint8_t upperCS = filterConfig & 0x0C;
    10da:	8b 81       	ldd	r24, Y+3	; 0x03
    10dc:	8c 70       	andi	r24, 0x0C	; 12
    10de:	8a 83       	std	Y+2, r24	; 0x02

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
    10e0:	8b 81       	ldd	r24, Y+3	; 0x03
    10e2:	88 2f       	mov	r24, r24
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	85 70       	andi	r24, 0x05	; 5
    10e8:	90 70       	andi	r25, 0x00	; 0
    10ea:	00 97       	sbiw	r24, 0x00	; 0
    10ec:	51 f0       	breq	.+20     	; 0x1102 <set_filter+0x3a>
    10ee:	80 91 7e 50 	lds	r24, 0x507E
    10f2:	98 2f       	mov	r25, r24
    10f4:	90 7f       	andi	r25, 0xF0	; 240
    10f6:	8b 81       	ldd	r24, Y+3	; 0x03
    10f8:	82 95       	swap	r24
    10fa:	8f 70       	andi	r24, 0x0F	; 15
    10fc:	89 2b       	or	r24, r25
    10fe:	80 93 7e 50 	sts	0x507E, r24
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
    1102:	8b 81       	ldd	r24, Y+3	; 0x03
    1104:	88 2f       	mov	r24, r24
    1106:	90 e0       	ldi	r25, 0x00	; 0
    1108:	8a 70       	andi	r24, 0x0A	; 10
    110a:	90 70       	andi	r25, 0x00	; 0
    110c:	00 97       	sbiw	r24, 0x00	; 0
    110e:	49 f0       	breq	.+18     	; 0x1122 <set_filter+0x5a>
    1110:	8b 81       	ldd	r24, Y+3	; 0x03
    1112:	98 2f       	mov	r25, r24
    1114:	90 7f       	andi	r25, 0xF0	; 240
    1116:	80 91 7e 50 	lds	r24, 0x507E
    111a:	8f 70       	andi	r24, 0x0F	; 15
    111c:	89 2b       	or	r24, r25
    111e:	80 93 7e 50 	sts	0x507E, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
    1122:	84 e0       	ldi	r24, 0x04	; 4
    1124:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>

	
	SPIBuffer[0] = channelStatus;
    1128:	80 91 7e 50 	lds	r24, 0x507E
    112c:	80 93 66 50 	sts	0x5066, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
    1130:	89 81       	ldd	r24, Y+1	; 0x01
    1132:	88 23       	and	r24, r24
    1134:	19 f0       	breq	.+6      	; 0x113c <set_filter+0x74>
    1136:	81 e0       	ldi	r24, 0x01	; 1
    1138:	0e 94 a5 39 	call	0x734a	; 0x734a <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
    113c:	8a 81       	ldd	r24, Y+2	; 0x02
    113e:	88 23       	and	r24, r24
    1140:	19 f0       	breq	.+6      	; 0x1148 <set_filter+0x80>
    1142:	81 e0       	ldi	r24, 0x01	; 1
    1144:	0e 94 bd 39 	call	0x737a	; 0x737a <upperMuxCS>

	SPICS(TRUE);
    1148:	81 e0       	ldi	r24, 0x01	; 1
    114a:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
    114e:	80 ec       	ldi	r24, 0xC0	; 192
    1150:	98 e0       	ldi	r25, 0x08	; 8
    1152:	2f ef       	ldi	r18, 0xFF	; 255
    1154:	fc 01       	movw	r30, r24
    1156:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1158:	00 00       	nop
    115a:	80 ec       	ldi	r24, 0xC0	; 192
    115c:	98 e0       	ldi	r25, 0x08	; 8
    115e:	fc 01       	movw	r30, r24
    1160:	82 81       	ldd	r24, Z+2	; 0x02
    1162:	88 23       	and	r24, r24
    1164:	d4 f7       	brge	.-12     	; 0x115a <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
    1166:	80 ec       	ldi	r24, 0xC0	; 192
    1168:	98 e0       	ldi	r25, 0x08	; 8
    116a:	fc 01       	movw	r30, r24
    116c:	83 81       	ldd	r24, Z+3	; 0x03
    116e:	80 93 72 50 	sts	0x5072, r24

	nop();
    1172:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
    1174:	80 ec       	ldi	r24, 0xC0	; 192
    1176:	98 e0       	ldi	r25, 0x08	; 8
    1178:	20 91 66 50 	lds	r18, 0x5066
    117c:	fc 01       	movw	r30, r24
    117e:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1180:	00 00       	nop
    1182:	80 ec       	ldi	r24, 0xC0	; 192
    1184:	98 e0       	ldi	r25, 0x08	; 8
    1186:	fc 01       	movw	r30, r24
    1188:	82 81       	ldd	r24, Z+2	; 0x02
    118a:	88 23       	and	r24, r24
    118c:	d4 f7       	brge	.-12     	; 0x1182 <set_filter+0xba>
	SPIBuffer[12] = SPIC.DATA;
    118e:	80 ec       	ldi	r24, 0xC0	; 192
    1190:	98 e0       	ldi	r25, 0x08	; 8
    1192:	fc 01       	movw	r30, r24
    1194:	83 81       	ldd	r24, Z+3	; 0x03
    1196:	80 93 72 50 	sts	0x5072, r24
	SPICS(FALSE);
    119a:	80 e0       	ldi	r24, 0x00	; 0
    119c:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
    11a0:	89 81       	ldd	r24, Y+1	; 0x01
    11a2:	88 23       	and	r24, r24
    11a4:	19 f0       	breq	.+6      	; 0x11ac <set_filter+0xe4>
    11a6:	80 e0       	ldi	r24, 0x00	; 0
    11a8:	0e 94 a5 39 	call	0x734a	; 0x734a <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
    11ac:	8a 81       	ldd	r24, Y+2	; 0x02
    11ae:	88 23       	and	r24, r24
    11b0:	19 f0       	breq	.+6      	; 0x11b8 <set_filter+0xf0>
    11b2:	80 e0       	ldi	r24, 0x00	; 0
    11b4:	0e 94 bd 39 	call	0x737a	; 0x737a <upperMuxCS>
	SPIDisable();
    11b8:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>
}
    11bc:	23 96       	adiw	r28, 0x03	; 3
    11be:	cd bf       	out	0x3d, r28	; 61
    11c0:	de bf       	out	0x3e, r29	; 62
    11c2:	df 91       	pop	r29
    11c4:	cf 91       	pop	r28
    11c6:	08 95       	ret

000011c8 <enableADCMUX>:

void enableADCMUX(uint8_t on) {
    11c8:	cf 93       	push	r28
    11ca:	df 93       	push	r29
    11cc:	0f 92       	push	r0
    11ce:	cd b7       	in	r28, 0x3d	; 61
    11d0:	de b7       	in	r29, 0x3e	; 62
    11d2:	89 83       	std	Y+1, r24	; 0x01
	if(on) {
    11d4:	89 81       	ldd	r24, Y+1	; 0x01
    11d6:	88 23       	and	r24, r24
    11d8:	59 f0       	breq	.+22     	; 0x11f0 <enableADCMUX+0x28>
		PORTA.DIRSET = PIN5_bm;
    11da:	80 e0       	ldi	r24, 0x00	; 0
    11dc:	96 e0       	ldi	r25, 0x06	; 6
    11de:	20 e2       	ldi	r18, 0x20	; 32
    11e0:	fc 01       	movw	r30, r24
    11e2:	21 83       	std	Z+1, r18	; 0x01
		PORTA.OUTSET = PIN5_bm;
    11e4:	80 e0       	ldi	r24, 0x00	; 0
    11e6:	96 e0       	ldi	r25, 0x06	; 6
    11e8:	20 e2       	ldi	r18, 0x20	; 32
    11ea:	fc 01       	movw	r30, r24
    11ec:	25 83       	std	Z+5, r18	; 0x05
    11ee:	0a c0       	rjmp	.+20     	; 0x1204 <enableADCMUX+0x3c>
	} else {
		PORTA.OUTCLR = PIN5_bm;
    11f0:	80 e0       	ldi	r24, 0x00	; 0
    11f2:	96 e0       	ldi	r25, 0x06	; 6
    11f4:	20 e2       	ldi	r18, 0x20	; 32
    11f6:	fc 01       	movw	r30, r24
    11f8:	26 83       	std	Z+6, r18	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    11fa:	80 e0       	ldi	r24, 0x00	; 0
    11fc:	96 e0       	ldi	r25, 0x06	; 6
    11fe:	20 e2       	ldi	r18, 0x20	; 32
    1200:	fc 01       	movw	r30, r24
    1202:	22 83       	std	Z+2, r18	; 0x02
	}
}
    1204:	0f 90       	pop	r0
    1206:	df 91       	pop	r29
    1208:	cf 91       	pop	r28
    120a:	08 95       	ret

0000120c <CO_collectADC>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV, int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {
    120c:	2f 92       	push	r2
    120e:	3f 92       	push	r3
    1210:	4f 92       	push	r4
    1212:	5f 92       	push	r5
    1214:	6f 92       	push	r6
    1216:	7f 92       	push	r7
    1218:	8f 92       	push	r8
    121a:	9f 92       	push	r9
    121c:	af 92       	push	r10
    121e:	bf 92       	push	r11
    1220:	cf 92       	push	r12
    1222:	df 92       	push	r13
    1224:	ef 92       	push	r14
    1226:	ff 92       	push	r15
    1228:	0f 93       	push	r16
    122a:	1f 93       	push	r17
    122c:	cf 93       	push	r28
    122e:	df 93       	push	r29
    1230:	cd b7       	in	r28, 0x3d	; 61
    1232:	de b7       	in	r29, 0x3e	; 62
    1234:	ec 97       	sbiw	r28, 0x3c	; 60
    1236:	cd bf       	out	0x3d, r28	; 61
    1238:	de bf       	out	0x3e, r29	; 62
    123a:	8b a3       	lds	r24, 0x5b
    123c:	6c a3       	lds	r22, 0x5c
    123e:	4d a3       	lds	r20, 0x5d
    1240:	5e a3       	lds	r21, 0x5e
    1242:	2f a3       	lds	r18, 0x5f
    1244:	38 a7       	lds	r19, 0x78
    1246:	09 a7       	lds	r16, 0x79
    1248:	1a a7       	lds	r17, 0x7a
    124a:	eb a6       	lds	r30, 0xbb
    124c:	cc a6       	lds	r28, 0xbc

	int64_t sum = 0;
    124e:	19 82       	std	Y+1, r1	; 0x01
    1250:	1a 82       	std	Y+2, r1	; 0x02
    1252:	1b 82       	std	Y+3, r1	; 0x03
    1254:	1c 82       	std	Y+4, r1	; 0x04
    1256:	1d 82       	std	Y+5, r1	; 0x05
    1258:	1e 82       	std	Y+6, r1	; 0x06
    125a:	1f 82       	std	Y+7, r1	; 0x07
    125c:	18 86       	std	Y+8, r1	; 0x08
	int64_t average;
	int64_t min = ADC_MAX;
    125e:	8f ef       	ldi	r24, 0xFF	; 255
    1260:	89 87       	std	Y+9, r24	; 0x09
    1262:	8f ef       	ldi	r24, 0xFF	; 255
    1264:	8a 87       	std	Y+10, r24	; 0x0a
    1266:	8f e7       	ldi	r24, 0x7F	; 127
    1268:	8b 87       	std	Y+11, r24	; 0x0b
    126a:	1c 86       	std	Y+12, r1	; 0x0c
    126c:	1d 86       	std	Y+13, r1	; 0x0d
    126e:	1e 86       	std	Y+14, r1	; 0x0e
    1270:	1f 86       	std	Y+15, r1	; 0x0f
    1272:	18 8a       	std	Y+16, r1	; 0x10
	int64_t max = -ADC_MAX;
    1274:	81 e0       	ldi	r24, 0x01	; 1
    1276:	89 8b       	std	Y+17, r24	; 0x11
    1278:	1a 8a       	std	Y+18, r1	; 0x12
    127a:	80 e8       	ldi	r24, 0x80	; 128
    127c:	8b 8b       	std	Y+19, r24	; 0x13
    127e:	8f ef       	ldi	r24, 0xFF	; 255
    1280:	8c 8b       	std	Y+20, r24	; 0x14
    1282:	8f ef       	ldi	r24, 0xFF	; 255
    1284:	8d 8b       	std	Y+21, r24	; 0x15
    1286:	8f ef       	ldi	r24, 0xFF	; 255
    1288:	8e 8b       	std	Y+22, r24	; 0x16
    128a:	8f ef       	ldi	r24, 0xFF	; 255
    128c:	8f 8b       	std	Y+23, r24	; 0x17
    128e:	8f ef       	ldi	r24, 0xFF	; 255
    1290:	88 8f       	std	Y+24, r24	; 0x18
	uint16_t period;
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1292:	81 e0       	ldi	r24, 0x01	; 1
    1294:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    1298:	8b a1       	lds	r24, 0x4b
    129a:	6b a5       	lds	r22, 0x6b
    129c:	0e 94 35 07 	call	0xe6a	; 0xe6a <set_ampGain>
	set_filter(filterConfig);
    12a0:	8c a1       	lds	r24, 0x4c
    12a2:	0e 94 64 08 	call	0x10c8	; 0x10c8 <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    12a6:	8b a1       	lds	r24, 0x4b
    12a8:	85 30       	cpi	r24, 0x05	; 5
    12aa:	31 f0       	breq	.+12     	; 0x12b8 <CO_collectADC+0xac>
    12ac:	8b a1       	lds	r24, 0x4b
    12ae:	86 30       	cpi	r24, 0x06	; 6
    12b0:	19 f0       	breq	.+6      	; 0x12b8 <CO_collectADC+0xac>
    12b2:	8b a1       	lds	r24, 0x4b
    12b4:	87 30       	cpi	r24, 0x07	; 7
    12b6:	19 f4       	brne	.+6      	; 0x12be <CO_collectADC+0xb2>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    12b8:	81 e0       	ldi	r24, 0x01	; 1
    12ba:	0e 94 43 11 	call	0x2286	; 0x2286 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    12be:	81 e0       	ldi	r24, 0x01	; 1
    12c0:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <enableADCMUX>
	setADCInput(channel);
    12c4:	8b a1       	lds	r24, 0x4b
    12c6:	0e 94 6f 1c 	call	0x38de	; 0x38de <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    12ca:	84 e0       	ldi	r24, 0x04	; 4
    12cc:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    12d0:	80 ec       	ldi	r24, 0xC0	; 192
    12d2:	98 e0       	ldi	r25, 0x08	; 8
    12d4:	24 e5       	ldi	r18, 0x54	; 84
    12d6:	fc 01       	movw	r30, r24
    12d8:	20 83       	st	Z, r18
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    12da:	80 ea       	ldi	r24, 0xA0	; 160
    12dc:	96 e0       	ldi	r25, 0x06	; 6
    12de:	21 e0       	ldi	r18, 0x01	; 1
    12e0:	fc 01       	movw	r30, r24
    12e2:	22 83       	std	Z+2, r18	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    12e4:	80 ea       	ldi	r24, 0xA0	; 160
    12e6:	96 e0       	ldi	r25, 0x06	; 6
    12e8:	22 e0       	ldi	r18, 0x02	; 2
    12ea:	fc 01       	movw	r30, r24
    12ec:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    12ee:	80 ea       	ldi	r24, 0xA0	; 160
    12f0:	96 e0       	ldi	r25, 0x06	; 6
    12f2:	21 e0       	ldi	r18, 0x01	; 1
    12f4:	fc 01       	movw	r30, r24
    12f6:	22 87       	std	Z+10, r18	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_LO_gc;				
    12f8:	80 ea       	ldi	r24, 0xA0	; 160
    12fa:	96 e0       	ldi	r25, 0x06	; 6
    12fc:	21 e0       	ldi	r18, 0x01	; 1
    12fe:	fc 01       	movw	r30, r24
    1300:	21 87       	std	Z+9, r18	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    1302:	80 e8       	ldi	r24, 0x80	; 128
    1304:	96 e0       	ldi	r25, 0x06	; 6
    1306:	20 e2       	ldi	r18, 0x20	; 32
    1308:	fc 01       	movw	r30, r24
    130a:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    130c:	80 e4       	ldi	r24, 0x40	; 64
    130e:	9a e0       	ldi	r25, 0x0A	; 10
    1310:	23 e2       	ldi	r18, 0x23	; 35
    1312:	fc 01       	movw	r30, r24
    1314:	21 83       	std	Z+1, r18	; 0x01
	// set period
	period = (1 << (21 - spsExponent)) - 1;
    1316:	8c a5       	lds	r24, 0x6c
    1318:	88 2f       	mov	r24, r24
    131a:	90 e0       	ldi	r25, 0x00	; 0
    131c:	25 e1       	ldi	r18, 0x15	; 21
    131e:	30 e0       	ldi	r19, 0x00	; 0
    1320:	28 1b       	sub	r18, r24
    1322:	39 0b       	sbc	r19, r25
    1324:	81 e0       	ldi	r24, 0x01	; 1
    1326:	90 e0       	ldi	r25, 0x00	; 0
    1328:	02 c0       	rjmp	.+4      	; 0x132e <CO_collectADC+0x122>
    132a:	88 0f       	add	r24, r24
    132c:	99 1f       	adc	r25, r25
    132e:	2a 95       	dec	r18
    1330:	e2 f7       	brpl	.-8      	; 0x132a <CO_collectADC+0x11e>
    1332:	01 97       	sbiw	r24, 0x01	; 1
    1334:	89 8f       	std	Y+25, r24	; 0x19
    1336:	9a 8f       	std	Y+26, r25	; 0x1a
	TCE1.PER = period;
    1338:	80 e4       	ldi	r24, 0x40	; 64
    133a:	9a e0       	ldi	r25, 0x0A	; 10
    133c:	29 8d       	ldd	r18, Y+25	; 0x19
    133e:	3a 8d       	ldd	r19, Y+26	; 0x1a
    1340:	fc 01       	movw	r30, r24
    1342:	26 a3       	lds	r18, 0x56
    1344:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = period / 2;
    1346:	80 e4       	ldi	r24, 0x40	; 64
    1348:	9a e0       	ldi	r25, 0x0A	; 10
    134a:	29 8d       	ldd	r18, Y+25	; 0x19
    134c:	3a 8d       	ldd	r19, Y+26	; 0x1a
    134e:	36 95       	lsr	r19
    1350:	27 95       	ror	r18
    1352:	fc 01       	movw	r30, r24
    1354:	22 af       	sts	0x72, r18
    1356:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1358:	80 e4       	ldi	r24, 0x40	; 64
    135a:	9a e0       	ldi	r25, 0x0A	; 10
    135c:	20 e4       	ldi	r18, 0x40	; 64
    135e:	3a e0       	ldi	r19, 0x0A	; 10
    1360:	f9 01       	movw	r30, r18
    1362:	20 81       	ld	r18, Z
    1364:	20 7f       	andi	r18, 0xF0	; 240
    1366:	21 60       	ori	r18, 0x01	; 1
    1368:	fc 01       	movw	r30, r24
    136a:	20 83       	st	Z, r18
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    136c:	80 ea       	ldi	r24, 0xA0	; 160
    136e:	90 e0       	ldi	r25, 0x00	; 0
    1370:	20 ea       	ldi	r18, 0xA0	; 160
    1372:	30 e0       	ldi	r19, 0x00	; 0
    1374:	f9 01       	movw	r30, r18
    1376:	22 81       	ldd	r18, Z+2	; 0x02
    1378:	21 60       	ori	r18, 0x01	; 1
    137a:	fc 01       	movw	r30, r24
    137c:	22 83       	std	Z+2, r18	; 0x02
	sei();
    137e:	78 94       	sei

	sampleCount = 0;
    1380:	10 92 73 50 	sts	0x5073, r1
    1384:	10 92 74 50 	sts	0x5074, r1
	discardCount = 0;
    1388:	10 92 5e 40 	sts	0x405E, r1
	
	// wait for ADC to collect samples
	while(sampleCount < NUM_SAMPLES);
    138c:	00 00       	nop
    138e:	80 91 73 50 	lds	r24, 0x5073
    1392:	90 91 74 50 	lds	r25, 0x5074
    1396:	f4 e0       	ldi	r31, 0x04	; 4
    1398:	80 30       	cpi	r24, 0x00	; 0
    139a:	9f 07       	cpc	r25, r31
    139c:	c0 f3       	brcs	.-16     	; 0x138e <CO_collectADC+0x182>

	// turn off timer and interupts
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    139e:	80 e4       	ldi	r24, 0x40	; 64
    13a0:	9a e0       	ldi	r25, 0x0A	; 10
    13a2:	20 e4       	ldi	r18, 0x40	; 64
    13a4:	3a e0       	ldi	r19, 0x0A	; 10
    13a6:	f9 01       	movw	r30, r18
    13a8:	20 81       	ld	r18, Z
    13aa:	20 7f       	andi	r18, 0xF0	; 240
    13ac:	fc 01       	movw	r30, r24
    13ae:	20 83       	st	Z, r18
	PMIC.CTRL &= ~PMIC_LOLVLEN_bm;	
    13b0:	80 ea       	ldi	r24, 0xA0	; 160
    13b2:	90 e0       	ldi	r25, 0x00	; 0
    13b4:	20 ea       	ldi	r18, 0xA0	; 160
    13b6:	30 e0       	ldi	r19, 0x00	; 0
    13b8:	f9 01       	movw	r30, r18
    13ba:	22 81       	ldd	r18, Z+2	; 0x02
    13bc:	2e 7f       	andi	r18, 0xFE	; 254
    13be:	fc 01       	movw	r30, r24
    13c0:	22 83       	std	Z+2, r18	; 0x02
	cli();
    13c2:	f8 94       	cli

	SPIDisable();	
    13c4:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>
	enableADCMUX(FALSE);
    13c8:	80 e0       	ldi	r24, 0x00	; 0
    13ca:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <enableADCMUX>
	ADCPower(FALSE);
    13ce:	80 e0       	ldi	r24, 0x00	; 0
    13d0:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>

	// collect average, max and min of SP samples
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
    13d4:	10 92 73 50 	sts	0x5073, r1
    13d8:	10 92 74 50 	sts	0x5074, r1
    13dc:	69 c1       	rjmp	.+722    	; 0x16b0 <CO_collectADC+0x4a4>
		sum += data24Bit[sampleCount];
    13de:	80 91 73 50 	lds	r24, 0x5073
    13e2:	90 91 74 50 	lds	r25, 0x5074
    13e6:	88 0f       	add	r24, r24
    13e8:	99 1f       	adc	r25, r25
    13ea:	88 0f       	add	r24, r24
    13ec:	99 1f       	adc	r25, r25
    13ee:	8c 59       	subi	r24, 0x9C	; 156
    13f0:	9f 4b       	sbci	r25, 0xBF	; 191
    13f2:	fc 01       	movw	r30, r24
    13f4:	80 81       	ld	r24, Z
    13f6:	91 81       	ldd	r25, Z+1	; 0x01
    13f8:	a2 81       	ldd	r26, Z+2	; 0x02
    13fa:	b3 81       	ldd	r27, Z+3	; 0x03
    13fc:	8d a7       	lds	r24, 0x7d
    13fe:	9e a7       	lds	r25, 0x7e
    1400:	af a7       	lds	r26, 0x7f
    1402:	b8 ab       	sts	0x58, r27
    1404:	bb 0f       	add	r27, r27
    1406:	88 0b       	sbc	r24, r24
    1408:	98 2f       	mov	r25, r24
    140a:	dc 01       	movw	r26, r24
    140c:	89 ab       	sts	0x59, r24
    140e:	8a ab       	sts	0x5a, r24
    1410:	8b ab       	sts	0x5b, r24
    1412:	8c ab       	sts	0x5c, r24
    1414:	a9 80       	ldd	r10, Y+1	; 0x01
    1416:	ba 80       	ldd	r11, Y+2	; 0x02
    1418:	cb 80       	ldd	r12, Y+3	; 0x03
    141a:	dc 80       	ldd	r13, Y+4	; 0x04
    141c:	ed 80       	ldd	r14, Y+5	; 0x05
    141e:	fe 80       	ldd	r15, Y+6	; 0x06
    1420:	0f 81       	ldd	r16, Y+7	; 0x07
    1422:	18 85       	ldd	r17, Y+8	; 0x08
    1424:	2d a5       	lds	r18, 0x6d
    1426:	2a 0d       	add	r18, r10
    1428:	e1 e0       	ldi	r30, 0x01	; 1
    142a:	2a 15       	cp	r18, r10
    142c:	08 f0       	brcs	.+2      	; 0x1430 <CO_collectADC+0x224>
    142e:	e0 e0       	ldi	r30, 0x00	; 0
    1430:	3e a5       	lds	r19, 0x6e
    1432:	3b 0d       	add	r19, r11
    1434:	a1 e0       	ldi	r26, 0x01	; 1
    1436:	3b 15       	cp	r19, r11
    1438:	08 f0       	brcs	.+2      	; 0x143c <CO_collectADC+0x230>
    143a:	a0 e0       	ldi	r26, 0x00	; 0
    143c:	fe 2f       	mov	r31, r30
    143e:	f3 0f       	add	r31, r19
    1440:	e1 e0       	ldi	r30, 0x01	; 1
    1442:	f3 17       	cp	r31, r19
    1444:	08 f0       	brcs	.+2      	; 0x1448 <CO_collectADC+0x23c>
    1446:	e0 e0       	ldi	r30, 0x00	; 0
    1448:	ae 2b       	or	r26, r30
    144a:	3f 2f       	mov	r19, r31
    144c:	4f a5       	lds	r20, 0x6f
    144e:	4c 0d       	add	r20, r12
    1450:	b1 e0       	ldi	r27, 0x01	; 1
    1452:	4c 15       	cp	r20, r12
    1454:	08 f0       	brcs	.+2      	; 0x1458 <CO_collectADC+0x24c>
    1456:	b0 e0       	ldi	r27, 0x00	; 0
    1458:	fa 2f       	mov	r31, r26
    145a:	f4 0f       	add	r31, r20
    145c:	e1 e0       	ldi	r30, 0x01	; 1
    145e:	f4 17       	cp	r31, r20
    1460:	08 f0       	brcs	.+2      	; 0x1464 <CO_collectADC+0x258>
    1462:	e0 e0       	ldi	r30, 0x00	; 0
    1464:	be 2b       	or	r27, r30
    1466:	4f 2f       	mov	r20, r31
    1468:	58 a9       	sts	0x48, r21
    146a:	5d 0d       	add	r21, r13
    146c:	a1 e0       	ldi	r26, 0x01	; 1
    146e:	5d 15       	cp	r21, r13
    1470:	08 f0       	brcs	.+2      	; 0x1474 <CO_collectADC+0x268>
    1472:	a0 e0       	ldi	r26, 0x00	; 0
    1474:	fb 2f       	mov	r31, r27
    1476:	f5 0f       	add	r31, r21
    1478:	e1 e0       	ldi	r30, 0x01	; 1
    147a:	f5 17       	cp	r31, r21
    147c:	08 f0       	brcs	.+2      	; 0x1480 <CO_collectADC+0x274>
    147e:	e0 e0       	ldi	r30, 0x00	; 0
    1480:	ae 2b       	or	r26, r30
    1482:	5f 2f       	mov	r21, r31
    1484:	69 a9       	sts	0x49, r22
    1486:	6e 0d       	add	r22, r14
    1488:	b1 e0       	ldi	r27, 0x01	; 1
    148a:	6e 15       	cp	r22, r14
    148c:	08 f0       	brcs	.+2      	; 0x1490 <CO_collectADC+0x284>
    148e:	b0 e0       	ldi	r27, 0x00	; 0
    1490:	fa 2f       	mov	r31, r26
    1492:	f6 0f       	add	r31, r22
    1494:	e1 e0       	ldi	r30, 0x01	; 1
    1496:	f6 17       	cp	r31, r22
    1498:	08 f0       	brcs	.+2      	; 0x149c <CO_collectADC+0x290>
    149a:	e0 e0       	ldi	r30, 0x00	; 0
    149c:	be 2b       	or	r27, r30
    149e:	6f 2f       	mov	r22, r31
    14a0:	7a a9       	sts	0x4a, r23
    14a2:	7f 0d       	add	r23, r15
    14a4:	a1 e0       	ldi	r26, 0x01	; 1
    14a6:	7f 15       	cp	r23, r15
    14a8:	08 f0       	brcs	.+2      	; 0x14ac <CO_collectADC+0x2a0>
    14aa:	a0 e0       	ldi	r26, 0x00	; 0
    14ac:	fb 2f       	mov	r31, r27
    14ae:	f7 0f       	add	r31, r23
    14b0:	e1 e0       	ldi	r30, 0x01	; 1
    14b2:	f7 17       	cp	r31, r23
    14b4:	08 f0       	brcs	.+2      	; 0x14b8 <CO_collectADC+0x2ac>
    14b6:	e0 e0       	ldi	r30, 0x00	; 0
    14b8:	ae 2b       	or	r26, r30
    14ba:	7f 2f       	mov	r23, r31
    14bc:	8b a9       	sts	0x4b, r24
    14be:	80 0f       	add	r24, r16
    14c0:	f1 e0       	ldi	r31, 0x01	; 1
    14c2:	80 17       	cp	r24, r16
    14c4:	08 f0       	brcs	.+2      	; 0x14c8 <CO_collectADC+0x2bc>
    14c6:	f0 e0       	ldi	r31, 0x00	; 0
    14c8:	a8 0f       	add	r26, r24
    14ca:	e1 e0       	ldi	r30, 0x01	; 1
    14cc:	a8 17       	cp	r26, r24
    14ce:	08 f0       	brcs	.+2      	; 0x14d2 <CO_collectADC+0x2c6>
    14d0:	e0 e0       	ldi	r30, 0x00	; 0
    14d2:	fe 2b       	or	r31, r30
    14d4:	8a 2f       	mov	r24, r26
    14d6:	9c a9       	sts	0x4c, r25
    14d8:	91 0f       	add	r25, r17
    14da:	ef 2f       	mov	r30, r31
    14dc:	e9 0f       	add	r30, r25
    14de:	9e 2f       	mov	r25, r30
    14e0:	29 83       	std	Y+1, r18	; 0x01
    14e2:	3a 83       	std	Y+2, r19	; 0x02
    14e4:	4b 83       	std	Y+3, r20	; 0x03
    14e6:	5c 83       	std	Y+4, r21	; 0x04
    14e8:	6d 83       	std	Y+5, r22	; 0x05
    14ea:	7e 83       	std	Y+6, r23	; 0x06
    14ec:	8f 83       	std	Y+7, r24	; 0x07
    14ee:	98 87       	std	Y+8, r25	; 0x08
		if (max < data24Bit[sampleCount]) { max = data24Bit[sampleCount];}
    14f0:	80 91 73 50 	lds	r24, 0x5073
    14f4:	90 91 74 50 	lds	r25, 0x5074
    14f8:	88 0f       	add	r24, r24
    14fa:	99 1f       	adc	r25, r25
    14fc:	88 0f       	add	r24, r24
    14fe:	99 1f       	adc	r25, r25
    1500:	8c 59       	subi	r24, 0x9C	; 156
    1502:	9f 4b       	sbci	r25, 0xBF	; 191
    1504:	fc 01       	movw	r30, r24
    1506:	80 81       	ld	r24, Z
    1508:	91 81       	ldd	r25, Z+1	; 0x01
    150a:	a2 81       	ldd	r26, Z+2	; 0x02
    150c:	b3 81       	ldd	r27, Z+3	; 0x03
    150e:	1c 01       	movw	r2, r24
    1510:	2d 01       	movw	r4, r26
    1512:	bb 0f       	add	r27, r27
    1514:	88 0b       	sbc	r24, r24
    1516:	98 2f       	mov	r25, r24
    1518:	dc 01       	movw	r26, r24
    151a:	68 2e       	mov	r6, r24
    151c:	78 2e       	mov	r7, r24
    151e:	88 2e       	mov	r8, r24
    1520:	98 2e       	mov	r9, r24
    1522:	88 8d       	ldd	r24, Y+24	; 0x18
    1524:	89 15       	cp	r24, r9
    1526:	5c f1       	brlt	.+86     	; 0x157e <CO_collectADC+0x372>
    1528:	88 8d       	ldd	r24, Y+24	; 0x18
    152a:	89 15       	cp	r24, r9
    152c:	09 f0       	breq	.+2      	; 0x1530 <CO_collectADC+0x324>
    152e:	42 c0       	rjmp	.+132    	; 0x15b4 <CO_collectADC+0x3a8>
    1530:	8f 89       	ldd	r24, Y+23	; 0x17
    1532:	88 15       	cp	r24, r8
    1534:	20 f1       	brcs	.+72     	; 0x157e <CO_collectADC+0x372>
    1536:	8f 89       	ldd	r24, Y+23	; 0x17
    1538:	88 15       	cp	r24, r8
    153a:	e1 f5       	brne	.+120    	; 0x15b4 <CO_collectADC+0x3a8>
    153c:	8e 89       	ldd	r24, Y+22	; 0x16
    153e:	87 15       	cp	r24, r7
    1540:	f0 f0       	brcs	.+60     	; 0x157e <CO_collectADC+0x372>
    1542:	8e 89       	ldd	r24, Y+22	; 0x16
    1544:	87 15       	cp	r24, r7
    1546:	b1 f5       	brne	.+108    	; 0x15b4 <CO_collectADC+0x3a8>
    1548:	8d 89       	ldd	r24, Y+21	; 0x15
    154a:	86 15       	cp	r24, r6
    154c:	c0 f0       	brcs	.+48     	; 0x157e <CO_collectADC+0x372>
    154e:	8d 89       	ldd	r24, Y+21	; 0x15
    1550:	86 15       	cp	r24, r6
    1552:	81 f5       	brne	.+96     	; 0x15b4 <CO_collectADC+0x3a8>
    1554:	8c 89       	ldd	r24, Y+20	; 0x14
    1556:	85 15       	cp	r24, r5
    1558:	90 f0       	brcs	.+36     	; 0x157e <CO_collectADC+0x372>
    155a:	8c 89       	ldd	r24, Y+20	; 0x14
    155c:	85 15       	cp	r24, r5
    155e:	51 f5       	brne	.+84     	; 0x15b4 <CO_collectADC+0x3a8>
    1560:	8b 89       	ldd	r24, Y+19	; 0x13
    1562:	84 15       	cp	r24, r4
    1564:	60 f0       	brcs	.+24     	; 0x157e <CO_collectADC+0x372>
    1566:	8b 89       	ldd	r24, Y+19	; 0x13
    1568:	84 15       	cp	r24, r4
    156a:	21 f5       	brne	.+72     	; 0x15b4 <CO_collectADC+0x3a8>
    156c:	8a 89       	ldd	r24, Y+18	; 0x12
    156e:	83 15       	cp	r24, r3
    1570:	30 f0       	brcs	.+12     	; 0x157e <CO_collectADC+0x372>
    1572:	8a 89       	ldd	r24, Y+18	; 0x12
    1574:	83 15       	cp	r24, r3
    1576:	f1 f4       	brne	.+60     	; 0x15b4 <CO_collectADC+0x3a8>
    1578:	89 89       	ldd	r24, Y+17	; 0x11
    157a:	82 15       	cp	r24, r2
    157c:	d8 f4       	brcc	.+54     	; 0x15b4 <CO_collectADC+0x3a8>
    157e:	80 91 73 50 	lds	r24, 0x5073
    1582:	90 91 74 50 	lds	r25, 0x5074
    1586:	88 0f       	add	r24, r24
    1588:	99 1f       	adc	r25, r25
    158a:	88 0f       	add	r24, r24
    158c:	99 1f       	adc	r25, r25
    158e:	8c 59       	subi	r24, 0x9C	; 156
    1590:	9f 4b       	sbci	r25, 0xBF	; 191
    1592:	fc 01       	movw	r30, r24
    1594:	80 81       	ld	r24, Z
    1596:	91 81       	ldd	r25, Z+1	; 0x01
    1598:	a2 81       	ldd	r26, Z+2	; 0x02
    159a:	b3 81       	ldd	r27, Z+3	; 0x03
    159c:	89 8b       	std	Y+17, r24	; 0x11
    159e:	9a 8b       	std	Y+18, r25	; 0x12
    15a0:	ab 8b       	std	Y+19, r26	; 0x13
    15a2:	bc 8b       	std	Y+20, r27	; 0x14
    15a4:	bb 0f       	add	r27, r27
    15a6:	88 0b       	sbc	r24, r24
    15a8:	98 2f       	mov	r25, r24
    15aa:	dc 01       	movw	r26, r24
    15ac:	8d 8b       	std	Y+21, r24	; 0x15
    15ae:	8e 8b       	std	Y+22, r24	; 0x16
    15b0:	8f 8b       	std	Y+23, r24	; 0x17
    15b2:	88 8f       	std	Y+24, r24	; 0x18
		if (min > data24Bit[sampleCount]) { min = data24Bit[sampleCount];}
    15b4:	80 91 73 50 	lds	r24, 0x5073
    15b8:	90 91 74 50 	lds	r25, 0x5074
    15bc:	88 0f       	add	r24, r24
    15be:	99 1f       	adc	r25, r25
    15c0:	88 0f       	add	r24, r24
    15c2:	99 1f       	adc	r25, r25
    15c4:	8c 59       	subi	r24, 0x9C	; 156
    15c6:	9f 4b       	sbci	r25, 0xBF	; 191
    15c8:	fc 01       	movw	r30, r24
    15ca:	80 81       	ld	r24, Z
    15cc:	91 81       	ldd	r25, Z+1	; 0x01
    15ce:	a2 81       	ldd	r26, Z+2	; 0x02
    15d0:	b3 81       	ldd	r27, Z+3	; 0x03
    15d2:	8d ab       	sts	0x5d, r24
    15d4:	9e ab       	sts	0x5e, r25
    15d6:	af ab       	sts	0x5f, r26
    15d8:	b8 af       	sts	0x78, r27
    15da:	bb 0f       	add	r27, r27
    15dc:	88 0b       	sbc	r24, r24
    15de:	98 2f       	mov	r25, r24
    15e0:	dc 01       	movw	r26, r24
    15e2:	89 af       	sts	0x79, r24
    15e4:	8a af       	sts	0x7a, r24
    15e6:	8b af       	sts	0x7b, r24
    15e8:	8c af       	sts	0x7c, r24
    15ea:	88 89       	ldd	r24, Y+16	; 0x10
    15ec:	fc ad       	sts	0x6c, r31
    15ee:	f8 17       	cp	r31, r24
    15f0:	dc f1       	brlt	.+118    	; 0x1668 <CO_collectADC+0x45c>
    15f2:	88 89       	ldd	r24, Y+16	; 0x10
    15f4:	2c ad       	sts	0x6c, r18
    15f6:	82 17       	cp	r24, r18
    15f8:	09 f0       	breq	.+2      	; 0x15fc <CO_collectADC+0x3f0>
    15fa:	51 c0       	rjmp	.+162    	; 0x169e <CO_collectADC+0x492>
    15fc:	8f 85       	ldd	r24, Y+15	; 0x0f
    15fe:	9b ad       	sts	0x6b, r25
    1600:	98 17       	cp	r25, r24
    1602:	90 f1       	brcs	.+100    	; 0x1668 <CO_collectADC+0x45c>
    1604:	8f 85       	ldd	r24, Y+15	; 0x0f
    1606:	eb ad       	sts	0x6b, r30
    1608:	8e 17       	cp	r24, r30
    160a:	09 f0       	breq	.+2      	; 0x160e <CO_collectADC+0x402>
    160c:	48 c0       	rjmp	.+144    	; 0x169e <CO_collectADC+0x492>
    160e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1610:	fa ad       	sts	0x6a, r31
    1612:	f8 17       	cp	r31, r24
    1614:	48 f1       	brcs	.+82     	; 0x1668 <CO_collectADC+0x45c>
    1616:	8e 85       	ldd	r24, Y+14	; 0x0e
    1618:	2a ad       	sts	0x6a, r18
    161a:	82 17       	cp	r24, r18
    161c:	09 f0       	breq	.+2      	; 0x1620 <CO_collectADC+0x414>
    161e:	3f c0       	rjmp	.+126    	; 0x169e <CO_collectADC+0x492>
    1620:	8d 85       	ldd	r24, Y+13	; 0x0d
    1622:	99 ad       	sts	0x69, r25
    1624:	98 17       	cp	r25, r24
    1626:	00 f1       	brcs	.+64     	; 0x1668 <CO_collectADC+0x45c>
    1628:	8d 85       	ldd	r24, Y+13	; 0x0d
    162a:	e9 ad       	sts	0x69, r30
    162c:	8e 17       	cp	r24, r30
    162e:	b9 f5       	brne	.+110    	; 0x169e <CO_collectADC+0x492>
    1630:	8c 85       	ldd	r24, Y+12	; 0x0c
    1632:	f8 ad       	sts	0x68, r31
    1634:	f8 17       	cp	r31, r24
    1636:	c0 f0       	brcs	.+48     	; 0x1668 <CO_collectADC+0x45c>
    1638:	8c 85       	ldd	r24, Y+12	; 0x0c
    163a:	28 ad       	sts	0x68, r18
    163c:	82 17       	cp	r24, r18
    163e:	79 f5       	brne	.+94     	; 0x169e <CO_collectADC+0x492>
    1640:	8b 85       	ldd	r24, Y+11	; 0x0b
    1642:	9f a9       	sts	0x4f, r25
    1644:	98 17       	cp	r25, r24
    1646:	80 f0       	brcs	.+32     	; 0x1668 <CO_collectADC+0x45c>
    1648:	8b 85       	ldd	r24, Y+11	; 0x0b
    164a:	ef a9       	sts	0x4f, r30
    164c:	8e 17       	cp	r24, r30
    164e:	39 f5       	brne	.+78     	; 0x169e <CO_collectADC+0x492>
    1650:	8a 85       	ldd	r24, Y+10	; 0x0a
    1652:	fe a9       	sts	0x4e, r31
    1654:	f8 17       	cp	r31, r24
    1656:	40 f0       	brcs	.+16     	; 0x1668 <CO_collectADC+0x45c>
    1658:	8a 85       	ldd	r24, Y+10	; 0x0a
    165a:	2e a9       	sts	0x4e, r18
    165c:	82 17       	cp	r24, r18
    165e:	f9 f4       	brne	.+62     	; 0x169e <CO_collectADC+0x492>
    1660:	89 85       	ldd	r24, Y+9	; 0x09
    1662:	9d a9       	sts	0x4d, r25
    1664:	98 17       	cp	r25, r24
    1666:	d8 f4       	brcc	.+54     	; 0x169e <CO_collectADC+0x492>
    1668:	80 91 73 50 	lds	r24, 0x5073
    166c:	90 91 74 50 	lds	r25, 0x5074
    1670:	88 0f       	add	r24, r24
    1672:	99 1f       	adc	r25, r25
    1674:	88 0f       	add	r24, r24
    1676:	99 1f       	adc	r25, r25
    1678:	8c 59       	subi	r24, 0x9C	; 156
    167a:	9f 4b       	sbci	r25, 0xBF	; 191
    167c:	fc 01       	movw	r30, r24
    167e:	80 81       	ld	r24, Z
    1680:	91 81       	ldd	r25, Z+1	; 0x01
    1682:	a2 81       	ldd	r26, Z+2	; 0x02
    1684:	b3 81       	ldd	r27, Z+3	; 0x03
    1686:	89 87       	std	Y+9, r24	; 0x09
    1688:	9a 87       	std	Y+10, r25	; 0x0a
    168a:	ab 87       	std	Y+11, r26	; 0x0b
    168c:	bc 87       	std	Y+12, r27	; 0x0c
    168e:	bb 0f       	add	r27, r27
    1690:	88 0b       	sbc	r24, r24
    1692:	98 2f       	mov	r25, r24
    1694:	dc 01       	movw	r26, r24
    1696:	8d 87       	std	Y+13, r24	; 0x0d
    1698:	8e 87       	std	Y+14, r24	; 0x0e
    169a:	8f 87       	std	Y+15, r24	; 0x0f
    169c:	88 8b       	std	Y+16, r24	; 0x10
	SPIDisable();	
	enableADCMUX(FALSE);
	ADCPower(FALSE);

	// collect average, max and min of SP samples
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
    169e:	80 91 73 50 	lds	r24, 0x5073
    16a2:	90 91 74 50 	lds	r25, 0x5074
    16a6:	01 96       	adiw	r24, 0x01	; 1
    16a8:	80 93 73 50 	sts	0x5073, r24
    16ac:	90 93 74 50 	sts	0x5074, r25
    16b0:	80 91 73 50 	lds	r24, 0x5073
    16b4:	90 91 74 50 	lds	r25, 0x5074
    16b8:	f4 e0       	ldi	r31, 0x04	; 4
    16ba:	80 30       	cpi	r24, 0x00	; 0
    16bc:	9f 07       	cpc	r25, r31
    16be:	08 f4       	brcc	.+2      	; 0x16c2 <CO_collectADC+0x4b6>
    16c0:	8e ce       	rjmp	.-740    	; 0x13de <CO_collectADC+0x1d2>
		sum += data24Bit[sampleCount];
		if (max < data24Bit[sampleCount]) { max = data24Bit[sampleCount];}
		if (min > data24Bit[sampleCount]) { min = data24Bit[sampleCount];}
	}
	average = sum / NUM_SAMPLES;
    16c2:	29 81       	ldd	r18, Y+1	; 0x01
    16c4:	3a 81       	ldd	r19, Y+2	; 0x02
    16c6:	4b 81       	ldd	r20, Y+3	; 0x03
    16c8:	5c 81       	ldd	r21, Y+4	; 0x04
    16ca:	6d 81       	ldd	r22, Y+5	; 0x05
    16cc:	7e 81       	ldd	r23, Y+6	; 0x06
    16ce:	8f 81       	ldd	r24, Y+7	; 0x07
    16d0:	98 85       	ldd	r25, Y+8	; 0x08
    16d2:	a2 2e       	mov	r10, r18
    16d4:	b3 2e       	mov	r11, r19
    16d6:	c4 2e       	mov	r12, r20
    16d8:	d5 2e       	mov	r13, r21
    16da:	e6 2e       	mov	r14, r22
    16dc:	f7 2e       	mov	r15, r23
    16de:	08 2f       	mov	r16, r24
    16e0:	19 2f       	mov	r17, r25
    16e2:	11 23       	and	r17, r17
    16e4:	0c f0       	brlt	.+2      	; 0x16e8 <CO_collectADC+0x4dc>
    16e6:	6c c0       	rjmp	.+216    	; 0x17c0 <CO_collectADC+0x5b4>
    16e8:	22 24       	eor	r2, r2
    16ea:	2a 94       	dec	r2
    16ec:	0f 2e       	mov	r0, r31
    16ee:	f3 e0       	ldi	r31, 0x03	; 3
    16f0:	3f 2e       	mov	r3, r31
    16f2:	f0 2d       	mov	r31, r0
    16f4:	44 24       	eor	r4, r4
    16f6:	55 24       	eor	r5, r5
    16f8:	66 24       	eor	r6, r6
    16fa:	77 24       	eor	r7, r7
    16fc:	88 24       	eor	r8, r8
    16fe:	99 24       	eor	r9, r9
    1700:	2a 2d       	mov	r18, r10
    1702:	22 0d       	add	r18, r2
    1704:	e1 e0       	ldi	r30, 0x01	; 1
    1706:	2a 15       	cp	r18, r10
    1708:	08 f0       	brcs	.+2      	; 0x170c <CO_collectADC+0x500>
    170a:	e0 e0       	ldi	r30, 0x00	; 0
    170c:	3b 2d       	mov	r19, r11
    170e:	33 0d       	add	r19, r3
    1710:	f1 e0       	ldi	r31, 0x01	; 1
    1712:	3b 15       	cp	r19, r11
    1714:	08 f0       	brcs	.+2      	; 0x1718 <CO_collectADC+0x50c>
    1716:	f0 e0       	ldi	r31, 0x00	; 0
    1718:	e3 0f       	add	r30, r19
    171a:	a1 e0       	ldi	r26, 0x01	; 1
    171c:	e3 17       	cp	r30, r19
    171e:	08 f0       	brcs	.+2      	; 0x1722 <CO_collectADC+0x516>
    1720:	a0 e0       	ldi	r26, 0x00	; 0
    1722:	fa 2b       	or	r31, r26
    1724:	3e 2f       	mov	r19, r30
    1726:	4c 2d       	mov	r20, r12
    1728:	44 0d       	add	r20, r4
    172a:	e1 e0       	ldi	r30, 0x01	; 1
    172c:	4c 15       	cp	r20, r12
    172e:	08 f0       	brcs	.+2      	; 0x1732 <CO_collectADC+0x526>
    1730:	e0 e0       	ldi	r30, 0x00	; 0
    1732:	f4 0f       	add	r31, r20
    1734:	a1 e0       	ldi	r26, 0x01	; 1
    1736:	f4 17       	cp	r31, r20
    1738:	08 f0       	brcs	.+2      	; 0x173c <CO_collectADC+0x530>
    173a:	a0 e0       	ldi	r26, 0x00	; 0
    173c:	ea 2b       	or	r30, r26
    173e:	4f 2f       	mov	r20, r31
    1740:	5d 2d       	mov	r21, r13
    1742:	55 0d       	add	r21, r5
    1744:	f1 e0       	ldi	r31, 0x01	; 1
    1746:	5d 15       	cp	r21, r13
    1748:	08 f0       	brcs	.+2      	; 0x174c <CO_collectADC+0x540>
    174a:	f0 e0       	ldi	r31, 0x00	; 0
    174c:	e5 0f       	add	r30, r21
    174e:	a1 e0       	ldi	r26, 0x01	; 1
    1750:	e5 17       	cp	r30, r21
    1752:	08 f0       	brcs	.+2      	; 0x1756 <CO_collectADC+0x54a>
    1754:	a0 e0       	ldi	r26, 0x00	; 0
    1756:	fa 2b       	or	r31, r26
    1758:	5e 2f       	mov	r21, r30
    175a:	6e 2d       	mov	r22, r14
    175c:	66 0d       	add	r22, r6
    175e:	e1 e0       	ldi	r30, 0x01	; 1
    1760:	6e 15       	cp	r22, r14
    1762:	08 f0       	brcs	.+2      	; 0x1766 <CO_collectADC+0x55a>
    1764:	e0 e0       	ldi	r30, 0x00	; 0
    1766:	f6 0f       	add	r31, r22
    1768:	a1 e0       	ldi	r26, 0x01	; 1
    176a:	f6 17       	cp	r31, r22
    176c:	08 f0       	brcs	.+2      	; 0x1770 <CO_collectADC+0x564>
    176e:	a0 e0       	ldi	r26, 0x00	; 0
    1770:	ea 2b       	or	r30, r26
    1772:	6f 2f       	mov	r22, r31
    1774:	7f 2d       	mov	r23, r15
    1776:	77 0d       	add	r23, r7
    1778:	f1 e0       	ldi	r31, 0x01	; 1
    177a:	7f 15       	cp	r23, r15
    177c:	08 f0       	brcs	.+2      	; 0x1780 <CO_collectADC+0x574>
    177e:	f0 e0       	ldi	r31, 0x00	; 0
    1780:	e7 0f       	add	r30, r23
    1782:	a1 e0       	ldi	r26, 0x01	; 1
    1784:	e7 17       	cp	r30, r23
    1786:	08 f0       	brcs	.+2      	; 0x178a <CO_collectADC+0x57e>
    1788:	a0 e0       	ldi	r26, 0x00	; 0
    178a:	fa 2b       	or	r31, r26
    178c:	7e 2f       	mov	r23, r30
    178e:	80 2f       	mov	r24, r16
    1790:	88 0d       	add	r24, r8
    1792:	e1 e0       	ldi	r30, 0x01	; 1
    1794:	80 17       	cp	r24, r16
    1796:	08 f0       	brcs	.+2      	; 0x179a <CO_collectADC+0x58e>
    1798:	e0 e0       	ldi	r30, 0x00	; 0
    179a:	f8 0f       	add	r31, r24
    179c:	a1 e0       	ldi	r26, 0x01	; 1
    179e:	f8 17       	cp	r31, r24
    17a0:	08 f0       	brcs	.+2      	; 0x17a4 <CO_collectADC+0x598>
    17a2:	a0 e0       	ldi	r26, 0x00	; 0
    17a4:	ea 2b       	or	r30, r26
    17a6:	8f 2f       	mov	r24, r31
    17a8:	91 2f       	mov	r25, r17
    17aa:	99 0d       	add	r25, r9
    17ac:	e9 0f       	add	r30, r25
    17ae:	9e 2f       	mov	r25, r30
    17b0:	a2 2e       	mov	r10, r18
    17b2:	b3 2e       	mov	r11, r19
    17b4:	c4 2e       	mov	r12, r20
    17b6:	d5 2e       	mov	r13, r21
    17b8:	e6 2e       	mov	r14, r22
    17ba:	f7 2e       	mov	r15, r23
    17bc:	08 2f       	mov	r16, r24
    17be:	19 2f       	mov	r17, r25
    17c0:	2a 2d       	mov	r18, r10
    17c2:	3b 2d       	mov	r19, r11
    17c4:	4c 2d       	mov	r20, r12
    17c6:	5d 2d       	mov	r21, r13
    17c8:	6e 2d       	mov	r22, r14
    17ca:	7f 2d       	mov	r23, r15
    17cc:	80 2f       	mov	r24, r16
    17ce:	91 2f       	mov	r25, r17
    17d0:	0a e0       	ldi	r16, 0x0A	; 10
    17d2:	0e 94 fe 54 	call	0xa9fc	; 0xa9fc <__ashrdi3>
    17d6:	a2 2e       	mov	r10, r18
    17d8:	b3 2e       	mov	r11, r19
    17da:	c4 2e       	mov	r12, r20
    17dc:	d5 2e       	mov	r13, r21
    17de:	e6 2e       	mov	r14, r22
    17e0:	f7 2e       	mov	r15, r23
    17e2:	08 2f       	mov	r16, r24
    17e4:	19 2f       	mov	r17, r25
    17e6:	ab 8e       	std	Y+27, r10	; 0x1b
    17e8:	bc 8e       	std	Y+28, r11	; 0x1c
    17ea:	cd 8e       	std	Y+29, r12	; 0x1d
    17ec:	de 8e       	std	Y+30, r13	; 0x1e
    17ee:	ef 8e       	std	Y+31, r14	; 0x1f
    17f0:	f8 a2       	lds	r31, 0x98
    17f2:	09 a3       	lds	r16, 0x59
    17f4:	1a a3       	lds	r17, 0x5a

	//convert to uV
	*avgV = (int32_t) -(average * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    17f6:	2b 8d       	ldd	r18, Y+27	; 0x1b
    17f8:	3c 8d       	ldd	r19, Y+28	; 0x1c
    17fa:	4d 8d       	ldd	r20, Y+29	; 0x1d
    17fc:	5e 8d       	ldd	r21, Y+30	; 0x1e
    17fe:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1800:	78 a1       	lds	r23, 0x48
    1802:	89 a1       	lds	r24, 0x49
    1804:	9a a1       	lds	r25, 0x4a
    1806:	0f 2e       	mov	r0, r31
    1808:	f0 ea       	ldi	r31, 0xA0	; 160
    180a:	af 2e       	mov	r10, r31
    180c:	f0 2d       	mov	r31, r0
    180e:	0f 2e       	mov	r0, r31
    1810:	f5 e2       	ldi	r31, 0x25	; 37
    1812:	bf 2e       	mov	r11, r31
    1814:	f0 2d       	mov	r31, r0
    1816:	0f 2e       	mov	r0, r31
    1818:	f6 e2       	ldi	r31, 0x26	; 38
    181a:	cf 2e       	mov	r12, r31
    181c:	f0 2d       	mov	r31, r0
    181e:	dd 24       	eor	r13, r13
    1820:	ee 24       	eor	r14, r14
    1822:	ff 24       	eor	r15, r15
    1824:	00 e0       	ldi	r16, 0x00	; 0
    1826:	10 e0       	ldi	r17, 0x00	; 0
    1828:	0e 94 b7 53 	call	0xa76e	; 0xa76e <__muldi3>
    182c:	22 2e       	mov	r2, r18
    182e:	33 2e       	mov	r3, r19
    1830:	44 2e       	mov	r4, r20
    1832:	55 2e       	mov	r5, r21
    1834:	66 2e       	mov	r6, r22
    1836:	77 2e       	mov	r7, r23
    1838:	88 2e       	mov	r8, r24
    183a:	99 2e       	mov	r9, r25
    183c:	a2 2c       	mov	r10, r2
    183e:	b3 2c       	mov	r11, r3
    1840:	c4 2c       	mov	r12, r4
    1842:	d5 2c       	mov	r13, r5
    1844:	e6 2c       	mov	r14, r6
    1846:	f7 2c       	mov	r15, r7
    1848:	08 2d       	mov	r16, r8
    184a:	19 2d       	mov	r17, r9
    184c:	2a 2d       	mov	r18, r10
    184e:	3b 2d       	mov	r19, r11
    1850:	4c 2d       	mov	r20, r12
    1852:	5d 2d       	mov	r21, r13
    1854:	6e 2d       	mov	r22, r14
    1856:	7f 2d       	mov	r23, r15
    1858:	80 2f       	mov	r24, r16
    185a:	91 2f       	mov	r25, r17
    185c:	aa 24       	eor	r10, r10
    185e:	aa 94       	dec	r10
    1860:	bb 24       	eor	r11, r11
    1862:	ba 94       	dec	r11
    1864:	0f 2e       	mov	r0, r31
    1866:	ff e7       	ldi	r31, 0x7F	; 127
    1868:	cf 2e       	mov	r12, r31
    186a:	f0 2d       	mov	r31, r0
    186c:	dd 24       	eor	r13, r13
    186e:	ee 24       	eor	r14, r14
    1870:	ff 24       	eor	r15, r15
    1872:	00 e0       	ldi	r16, 0x00	; 0
    1874:	10 e0       	ldi	r17, 0x00	; 0
    1876:	0e 94 66 55 	call	0xaacc	; 0xaacc <__divdi3>
    187a:	22 2e       	mov	r2, r18
    187c:	33 2e       	mov	r3, r19
    187e:	44 2e       	mov	r4, r20
    1880:	55 2e       	mov	r5, r21
    1882:	66 2e       	mov	r6, r22
    1884:	77 2e       	mov	r7, r23
    1886:	88 2e       	mov	r8, r24
    1888:	99 2e       	mov	r9, r25
    188a:	a2 2c       	mov	r10, r2
    188c:	b3 2c       	mov	r11, r3
    188e:	c4 2c       	mov	r12, r4
    1890:	d5 2c       	mov	r13, r5
    1892:	e6 2c       	mov	r14, r6
    1894:	f7 2c       	mov	r15, r7
    1896:	08 2d       	mov	r16, r8
    1898:	19 2d       	mov	r17, r9
    189a:	2a 2d       	mov	r18, r10
    189c:	3b 2d       	mov	r19, r11
    189e:	4c 2d       	mov	r20, r12
    18a0:	5d 2d       	mov	r21, r13
    18a2:	6e 2d       	mov	r22, r14
    18a4:	7f 2d       	mov	r23, r15
    18a6:	80 2f       	mov	r24, r16
    18a8:	91 2f       	mov	r25, r17
    18aa:	01 e0       	ldi	r16, 0x01	; 1
    18ac:	0e 94 8a 54 	call	0xa914	; 0xa914 <__ashldi3>
    18b0:	22 2e       	mov	r2, r18
    18b2:	33 2e       	mov	r3, r19
    18b4:	44 2e       	mov	r4, r20
    18b6:	55 2e       	mov	r5, r21
    18b8:	66 2e       	mov	r6, r22
    18ba:	77 2e       	mov	r7, r23
    18bc:	88 2e       	mov	r8, r24
    18be:	99 2e       	mov	r9, r25
    18c0:	a2 2c       	mov	r10, r2
    18c2:	b3 2c       	mov	r11, r3
    18c4:	c4 2c       	mov	r12, r4
    18c6:	d5 2c       	mov	r13, r5
    18c8:	e6 2c       	mov	r14, r6
    18ca:	f7 2c       	mov	r15, r7
    18cc:	08 2d       	mov	r16, r8
    18ce:	19 2d       	mov	r17, r9
    18d0:	2a 2d       	mov	r18, r10
    18d2:	3b 2d       	mov	r19, r11
    18d4:	4c 2d       	mov	r20, r12
    18d6:	5d 2d       	mov	r21, r13
    18d8:	6e 2d       	mov	r22, r14
    18da:	7f 2d       	mov	r23, r15
    18dc:	80 2f       	mov	r24, r16
    18de:	91 2f       	mov	r25, r17
    18e0:	0f 2e       	mov	r0, r31
    18e2:	f3 e0       	ldi	r31, 0x03	; 3
    18e4:	af 2e       	mov	r10, r31
    18e6:	f0 2d       	mov	r31, r0
    18e8:	bb 24       	eor	r11, r11
    18ea:	cc 24       	eor	r12, r12
    18ec:	dd 24       	eor	r13, r13
    18ee:	ee 24       	eor	r14, r14
    18f0:	ff 24       	eor	r15, r15
    18f2:	00 e0       	ldi	r16, 0x00	; 0
    18f4:	10 e0       	ldi	r17, 0x00	; 0
    18f6:	0e 94 66 55 	call	0xaacc	; 0xaacc <__divdi3>
    18fa:	a2 2e       	mov	r10, r18
    18fc:	b3 2e       	mov	r11, r19
    18fe:	c4 2e       	mov	r12, r20
    1900:	d5 2e       	mov	r13, r21
    1902:	e6 2e       	mov	r14, r22
    1904:	f7 2e       	mov	r15, r23
    1906:	08 2f       	mov	r16, r24
    1908:	19 2f       	mov	r17, r25
    190a:	2a 2d       	mov	r18, r10
    190c:	3b 2d       	mov	r19, r11
    190e:	4c 2d       	mov	r20, r12
    1910:	5d 2d       	mov	r21, r13
    1912:	6e 2d       	mov	r22, r14
    1914:	7f 2d       	mov	r23, r15
    1916:	80 2f       	mov	r24, r16
    1918:	91 2f       	mov	r25, r17
    191a:	da 01       	movw	r26, r20
    191c:	c9 01       	movw	r24, r18
    191e:	b0 95       	com	r27
    1920:	a0 95       	com	r26
    1922:	90 95       	com	r25
    1924:	81 95       	neg	r24
    1926:	9f 4f       	sbci	r25, 0xFF	; 255
    1928:	af 4f       	sbci	r26, 0xFF	; 255
    192a:	bf 4f       	sbci	r27, 0xFF	; 255
    192c:	2d a1       	lds	r18, 0x4d
    192e:	3e a1       	lds	r19, 0x4e
    1930:	f9 01       	movw	r30, r18
    1932:	80 83       	st	Z, r24
    1934:	91 83       	std	Z+1, r25	; 0x01
    1936:	a2 83       	std	Z+2, r26	; 0x02
    1938:	b3 83       	std	Z+3, r27	; 0x03
	*maxV = (int32_t) -(max * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    193a:	29 89       	ldd	r18, Y+17	; 0x11
    193c:	3a 89       	ldd	r19, Y+18	; 0x12
    193e:	4b 89       	ldd	r20, Y+19	; 0x13
    1940:	5c 89       	ldd	r21, Y+20	; 0x14
    1942:	6d 89       	ldd	r22, Y+21	; 0x15
    1944:	7e 89       	ldd	r23, Y+22	; 0x16
    1946:	8f 89       	ldd	r24, Y+23	; 0x17
    1948:	98 8d       	ldd	r25, Y+24	; 0x18
    194a:	0f 2e       	mov	r0, r31
    194c:	f0 ea       	ldi	r31, 0xA0	; 160
    194e:	af 2e       	mov	r10, r31
    1950:	f0 2d       	mov	r31, r0
    1952:	0f 2e       	mov	r0, r31
    1954:	f5 e2       	ldi	r31, 0x25	; 37
    1956:	bf 2e       	mov	r11, r31
    1958:	f0 2d       	mov	r31, r0
    195a:	0f 2e       	mov	r0, r31
    195c:	f6 e2       	ldi	r31, 0x26	; 38
    195e:	cf 2e       	mov	r12, r31
    1960:	f0 2d       	mov	r31, r0
    1962:	dd 24       	eor	r13, r13
    1964:	ee 24       	eor	r14, r14
    1966:	ff 24       	eor	r15, r15
    1968:	00 e0       	ldi	r16, 0x00	; 0
    196a:	10 e0       	ldi	r17, 0x00	; 0
    196c:	0e 94 b7 53 	call	0xa76e	; 0xa76e <__muldi3>
    1970:	22 2e       	mov	r2, r18
    1972:	33 2e       	mov	r3, r19
    1974:	44 2e       	mov	r4, r20
    1976:	55 2e       	mov	r5, r21
    1978:	66 2e       	mov	r6, r22
    197a:	77 2e       	mov	r7, r23
    197c:	88 2e       	mov	r8, r24
    197e:	99 2e       	mov	r9, r25
    1980:	a2 2c       	mov	r10, r2
    1982:	b3 2c       	mov	r11, r3
    1984:	c4 2c       	mov	r12, r4
    1986:	d5 2c       	mov	r13, r5
    1988:	e6 2c       	mov	r14, r6
    198a:	f7 2c       	mov	r15, r7
    198c:	08 2d       	mov	r16, r8
    198e:	19 2d       	mov	r17, r9
    1990:	2a 2d       	mov	r18, r10
    1992:	3b 2d       	mov	r19, r11
    1994:	4c 2d       	mov	r20, r12
    1996:	5d 2d       	mov	r21, r13
    1998:	6e 2d       	mov	r22, r14
    199a:	7f 2d       	mov	r23, r15
    199c:	80 2f       	mov	r24, r16
    199e:	91 2f       	mov	r25, r17
    19a0:	aa 24       	eor	r10, r10
    19a2:	aa 94       	dec	r10
    19a4:	bb 24       	eor	r11, r11
    19a6:	ba 94       	dec	r11
    19a8:	0f 2e       	mov	r0, r31
    19aa:	ff e7       	ldi	r31, 0x7F	; 127
    19ac:	cf 2e       	mov	r12, r31
    19ae:	f0 2d       	mov	r31, r0
    19b0:	dd 24       	eor	r13, r13
    19b2:	ee 24       	eor	r14, r14
    19b4:	ff 24       	eor	r15, r15
    19b6:	00 e0       	ldi	r16, 0x00	; 0
    19b8:	10 e0       	ldi	r17, 0x00	; 0
    19ba:	0e 94 66 55 	call	0xaacc	; 0xaacc <__divdi3>
    19be:	22 2e       	mov	r2, r18
    19c0:	33 2e       	mov	r3, r19
    19c2:	44 2e       	mov	r4, r20
    19c4:	55 2e       	mov	r5, r21
    19c6:	66 2e       	mov	r6, r22
    19c8:	77 2e       	mov	r7, r23
    19ca:	88 2e       	mov	r8, r24
    19cc:	99 2e       	mov	r9, r25
    19ce:	a2 2c       	mov	r10, r2
    19d0:	b3 2c       	mov	r11, r3
    19d2:	c4 2c       	mov	r12, r4
    19d4:	d5 2c       	mov	r13, r5
    19d6:	e6 2c       	mov	r14, r6
    19d8:	f7 2c       	mov	r15, r7
    19da:	08 2d       	mov	r16, r8
    19dc:	19 2d       	mov	r17, r9
    19de:	2a 2d       	mov	r18, r10
    19e0:	3b 2d       	mov	r19, r11
    19e2:	4c 2d       	mov	r20, r12
    19e4:	5d 2d       	mov	r21, r13
    19e6:	6e 2d       	mov	r22, r14
    19e8:	7f 2d       	mov	r23, r15
    19ea:	80 2f       	mov	r24, r16
    19ec:	91 2f       	mov	r25, r17
    19ee:	01 e0       	ldi	r16, 0x01	; 1
    19f0:	0e 94 8a 54 	call	0xa914	; 0xa914 <__ashldi3>
    19f4:	22 2e       	mov	r2, r18
    19f6:	33 2e       	mov	r3, r19
    19f8:	44 2e       	mov	r4, r20
    19fa:	55 2e       	mov	r5, r21
    19fc:	66 2e       	mov	r6, r22
    19fe:	77 2e       	mov	r7, r23
    1a00:	88 2e       	mov	r8, r24
    1a02:	99 2e       	mov	r9, r25
    1a04:	a2 2c       	mov	r10, r2
    1a06:	b3 2c       	mov	r11, r3
    1a08:	c4 2c       	mov	r12, r4
    1a0a:	d5 2c       	mov	r13, r5
    1a0c:	e6 2c       	mov	r14, r6
    1a0e:	f7 2c       	mov	r15, r7
    1a10:	08 2d       	mov	r16, r8
    1a12:	19 2d       	mov	r17, r9
    1a14:	2a 2d       	mov	r18, r10
    1a16:	3b 2d       	mov	r19, r11
    1a18:	4c 2d       	mov	r20, r12
    1a1a:	5d 2d       	mov	r21, r13
    1a1c:	6e 2d       	mov	r22, r14
    1a1e:	7f 2d       	mov	r23, r15
    1a20:	80 2f       	mov	r24, r16
    1a22:	91 2f       	mov	r25, r17
    1a24:	0f 2e       	mov	r0, r31
    1a26:	f3 e0       	ldi	r31, 0x03	; 3
    1a28:	af 2e       	mov	r10, r31
    1a2a:	f0 2d       	mov	r31, r0
    1a2c:	bb 24       	eor	r11, r11
    1a2e:	cc 24       	eor	r12, r12
    1a30:	dd 24       	eor	r13, r13
    1a32:	ee 24       	eor	r14, r14
    1a34:	ff 24       	eor	r15, r15
    1a36:	00 e0       	ldi	r16, 0x00	; 0
    1a38:	10 e0       	ldi	r17, 0x00	; 0
    1a3a:	0e 94 66 55 	call	0xaacc	; 0xaacc <__divdi3>
    1a3e:	a2 2e       	mov	r10, r18
    1a40:	b3 2e       	mov	r11, r19
    1a42:	c4 2e       	mov	r12, r20
    1a44:	d5 2e       	mov	r13, r21
    1a46:	e6 2e       	mov	r14, r22
    1a48:	f7 2e       	mov	r15, r23
    1a4a:	08 2f       	mov	r16, r24
    1a4c:	19 2f       	mov	r17, r25
    1a4e:	2a 2d       	mov	r18, r10
    1a50:	3b 2d       	mov	r19, r11
    1a52:	4c 2d       	mov	r20, r12
    1a54:	5d 2d       	mov	r21, r13
    1a56:	6e 2d       	mov	r22, r14
    1a58:	7f 2d       	mov	r23, r15
    1a5a:	80 2f       	mov	r24, r16
    1a5c:	91 2f       	mov	r25, r17
    1a5e:	da 01       	movw	r26, r20
    1a60:	c9 01       	movw	r24, r18
    1a62:	b0 95       	com	r27
    1a64:	a0 95       	com	r26
    1a66:	90 95       	com	r25
    1a68:	81 95       	neg	r24
    1a6a:	9f 4f       	sbci	r25, 0xFF	; 255
    1a6c:	af 4f       	sbci	r26, 0xFF	; 255
    1a6e:	bf 4f       	sbci	r27, 0xFF	; 255
    1a70:	29 a5       	lds	r18, 0x69
    1a72:	3a a5       	lds	r19, 0x6a
    1a74:	f9 01       	movw	r30, r18
    1a76:	80 83       	st	Z, r24
    1a78:	91 83       	std	Z+1, r25	; 0x01
    1a7a:	a2 83       	std	Z+2, r26	; 0x02
    1a7c:	b3 83       	std	Z+3, r27	; 0x03
	*minV = (int32_t) -(min * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1a7e:	29 85       	ldd	r18, Y+9	; 0x09
    1a80:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a82:	4b 85       	ldd	r20, Y+11	; 0x0b
    1a84:	5c 85       	ldd	r21, Y+12	; 0x0c
    1a86:	6d 85       	ldd	r22, Y+13	; 0x0d
    1a88:	7e 85       	ldd	r23, Y+14	; 0x0e
    1a8a:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a8c:	98 89       	ldd	r25, Y+16	; 0x10
    1a8e:	0f 2e       	mov	r0, r31
    1a90:	f0 ea       	ldi	r31, 0xA0	; 160
    1a92:	af 2e       	mov	r10, r31
    1a94:	f0 2d       	mov	r31, r0
    1a96:	0f 2e       	mov	r0, r31
    1a98:	f5 e2       	ldi	r31, 0x25	; 37
    1a9a:	bf 2e       	mov	r11, r31
    1a9c:	f0 2d       	mov	r31, r0
    1a9e:	0f 2e       	mov	r0, r31
    1aa0:	f6 e2       	ldi	r31, 0x26	; 38
    1aa2:	cf 2e       	mov	r12, r31
    1aa4:	f0 2d       	mov	r31, r0
    1aa6:	dd 24       	eor	r13, r13
    1aa8:	ee 24       	eor	r14, r14
    1aaa:	ff 24       	eor	r15, r15
    1aac:	00 e0       	ldi	r16, 0x00	; 0
    1aae:	10 e0       	ldi	r17, 0x00	; 0
    1ab0:	0e 94 b7 53 	call	0xa76e	; 0xa76e <__muldi3>
    1ab4:	22 2e       	mov	r2, r18
    1ab6:	33 2e       	mov	r3, r19
    1ab8:	44 2e       	mov	r4, r20
    1aba:	55 2e       	mov	r5, r21
    1abc:	66 2e       	mov	r6, r22
    1abe:	77 2e       	mov	r7, r23
    1ac0:	88 2e       	mov	r8, r24
    1ac2:	99 2e       	mov	r9, r25
    1ac4:	a2 2c       	mov	r10, r2
    1ac6:	b3 2c       	mov	r11, r3
    1ac8:	c4 2c       	mov	r12, r4
    1aca:	d5 2c       	mov	r13, r5
    1acc:	e6 2c       	mov	r14, r6
    1ace:	f7 2c       	mov	r15, r7
    1ad0:	08 2d       	mov	r16, r8
    1ad2:	19 2d       	mov	r17, r9
    1ad4:	2a 2d       	mov	r18, r10
    1ad6:	3b 2d       	mov	r19, r11
    1ad8:	4c 2d       	mov	r20, r12
    1ada:	5d 2d       	mov	r21, r13
    1adc:	6e 2d       	mov	r22, r14
    1ade:	7f 2d       	mov	r23, r15
    1ae0:	80 2f       	mov	r24, r16
    1ae2:	91 2f       	mov	r25, r17
    1ae4:	aa 24       	eor	r10, r10
    1ae6:	aa 94       	dec	r10
    1ae8:	bb 24       	eor	r11, r11
    1aea:	ba 94       	dec	r11
    1aec:	0f 2e       	mov	r0, r31
    1aee:	ff e7       	ldi	r31, 0x7F	; 127
    1af0:	cf 2e       	mov	r12, r31
    1af2:	f0 2d       	mov	r31, r0
    1af4:	dd 24       	eor	r13, r13
    1af6:	ee 24       	eor	r14, r14
    1af8:	ff 24       	eor	r15, r15
    1afa:	00 e0       	ldi	r16, 0x00	; 0
    1afc:	10 e0       	ldi	r17, 0x00	; 0
    1afe:	0e 94 66 55 	call	0xaacc	; 0xaacc <__divdi3>
    1b02:	22 2e       	mov	r2, r18
    1b04:	33 2e       	mov	r3, r19
    1b06:	44 2e       	mov	r4, r20
    1b08:	55 2e       	mov	r5, r21
    1b0a:	66 2e       	mov	r6, r22
    1b0c:	77 2e       	mov	r7, r23
    1b0e:	88 2e       	mov	r8, r24
    1b10:	99 2e       	mov	r9, r25
    1b12:	a2 2c       	mov	r10, r2
    1b14:	b3 2c       	mov	r11, r3
    1b16:	c4 2c       	mov	r12, r4
    1b18:	d5 2c       	mov	r13, r5
    1b1a:	e6 2c       	mov	r14, r6
    1b1c:	f7 2c       	mov	r15, r7
    1b1e:	08 2d       	mov	r16, r8
    1b20:	19 2d       	mov	r17, r9
    1b22:	2a 2d       	mov	r18, r10
    1b24:	3b 2d       	mov	r19, r11
    1b26:	4c 2d       	mov	r20, r12
    1b28:	5d 2d       	mov	r21, r13
    1b2a:	6e 2d       	mov	r22, r14
    1b2c:	7f 2d       	mov	r23, r15
    1b2e:	80 2f       	mov	r24, r16
    1b30:	91 2f       	mov	r25, r17
    1b32:	01 e0       	ldi	r16, 0x01	; 1
    1b34:	0e 94 8a 54 	call	0xa914	; 0xa914 <__ashldi3>
    1b38:	22 2e       	mov	r2, r18
    1b3a:	33 2e       	mov	r3, r19
    1b3c:	44 2e       	mov	r4, r20
    1b3e:	55 2e       	mov	r5, r21
    1b40:	66 2e       	mov	r6, r22
    1b42:	77 2e       	mov	r7, r23
    1b44:	88 2e       	mov	r8, r24
    1b46:	99 2e       	mov	r9, r25
    1b48:	a2 2c       	mov	r10, r2
    1b4a:	b3 2c       	mov	r11, r3
    1b4c:	c4 2c       	mov	r12, r4
    1b4e:	d5 2c       	mov	r13, r5
    1b50:	e6 2c       	mov	r14, r6
    1b52:	f7 2c       	mov	r15, r7
    1b54:	08 2d       	mov	r16, r8
    1b56:	19 2d       	mov	r17, r9
    1b58:	2a 2d       	mov	r18, r10
    1b5a:	3b 2d       	mov	r19, r11
    1b5c:	4c 2d       	mov	r20, r12
    1b5e:	5d 2d       	mov	r21, r13
    1b60:	6e 2d       	mov	r22, r14
    1b62:	7f 2d       	mov	r23, r15
    1b64:	80 2f       	mov	r24, r16
    1b66:	91 2f       	mov	r25, r17
    1b68:	0f 2e       	mov	r0, r31
    1b6a:	f3 e0       	ldi	r31, 0x03	; 3
    1b6c:	af 2e       	mov	r10, r31
    1b6e:	f0 2d       	mov	r31, r0
    1b70:	bb 24       	eor	r11, r11
    1b72:	cc 24       	eor	r12, r12
    1b74:	dd 24       	eor	r13, r13
    1b76:	ee 24       	eor	r14, r14
    1b78:	ff 24       	eor	r15, r15
    1b7a:	00 e0       	ldi	r16, 0x00	; 0
    1b7c:	10 e0       	ldi	r17, 0x00	; 0
    1b7e:	0e 94 66 55 	call	0xaacc	; 0xaacc <__divdi3>
    1b82:	a2 2e       	mov	r10, r18
    1b84:	b3 2e       	mov	r11, r19
    1b86:	c4 2e       	mov	r12, r20
    1b88:	d5 2e       	mov	r13, r21
    1b8a:	e6 2e       	mov	r14, r22
    1b8c:	f7 2e       	mov	r15, r23
    1b8e:	08 2f       	mov	r16, r24
    1b90:	19 2f       	mov	r17, r25
    1b92:	2a 2d       	mov	r18, r10
    1b94:	3b 2d       	mov	r19, r11
    1b96:	4c 2d       	mov	r20, r12
    1b98:	5d 2d       	mov	r21, r13
    1b9a:	6e 2d       	mov	r22, r14
    1b9c:	7f 2d       	mov	r23, r15
    1b9e:	80 2f       	mov	r24, r16
    1ba0:	91 2f       	mov	r25, r17
    1ba2:	da 01       	movw	r26, r20
    1ba4:	c9 01       	movw	r24, r18
    1ba6:	b0 95       	com	r27
    1ba8:	a0 95       	com	r26
    1baa:	90 95       	com	r25
    1bac:	81 95       	neg	r24
    1bae:	9f 4f       	sbci	r25, 0xFF	; 255
    1bb0:	af 4f       	sbci	r26, 0xFF	; 255
    1bb2:	bf 4f       	sbci	r27, 0xFF	; 255
    1bb4:	2f a1       	lds	r18, 0x4f
    1bb6:	38 a5       	lds	r19, 0x68
    1bb8:	f9 01       	movw	r30, r18
    1bba:	80 83       	st	Z, r24
    1bbc:	91 83       	std	Z+1, r25	; 0x01
    1bbe:	a2 83       	std	Z+2, r26	; 0x02
    1bc0:	b3 83       	std	Z+3, r27	; 0x03

}
    1bc2:	ec 96       	adiw	r28, 0x3c	; 60
    1bc4:	cd bf       	out	0x3d, r28	; 61
    1bc6:	de bf       	out	0x3e, r29	; 62
    1bc8:	df 91       	pop	r29
    1bca:	cf 91       	pop	r28
    1bcc:	1f 91       	pop	r17
    1bce:	0f 91       	pop	r16
    1bd0:	ff 90       	pop	r15
    1bd2:	ef 90       	pop	r14
    1bd4:	df 90       	pop	r13
    1bd6:	cf 90       	pop	r12
    1bd8:	bf 90       	pop	r11
    1bda:	af 90       	pop	r10
    1bdc:	9f 90       	pop	r9
    1bde:	8f 90       	pop	r8
    1be0:	7f 90       	pop	r7
    1be2:	6f 90       	pop	r6
    1be4:	5f 90       	pop	r5
    1be6:	4f 90       	pop	r4
    1be8:	3f 90       	pop	r3
    1bea:	2f 90       	pop	r2
    1bec:	08 95       	ret

00001bee <CO_collectADC_cont>:

void CO_collectADC_cont(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent) {
    1bee:	cf 93       	push	r28
    1bf0:	df 93       	push	r29
    1bf2:	00 d0       	rcall	.+0      	; 0x1bf4 <CO_collectADC_cont+0x6>
    1bf4:	00 d0       	rcall	.+0      	; 0x1bf6 <CO_collectADC_cont+0x8>
    1bf6:	cd b7       	in	r28, 0x3d	; 61
    1bf8:	de b7       	in	r29, 0x3e	; 62
    1bfa:	8b 83       	std	Y+3, r24	; 0x03
    1bfc:	6c 83       	std	Y+4, r22	; 0x04
    1bfe:	4d 83       	std	Y+5, r20	; 0x05
    1c00:	2e 83       	std	Y+6, r18	; 0x06

uint16_t period;

// Turn on power to ADC and PortEx
ADCPower(TRUE);
    1c02:	81 e0       	ldi	r24, 0x01	; 1
    1c04:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
//get data to write files to SD card
//getBootSectorData();
// set gain, filters, and ADC input for appropriate VIN
set_ampGain(channel, gainExponent);
    1c08:	8b 81       	ldd	r24, Y+3	; 0x03
    1c0a:	6d 81       	ldd	r22, Y+5	; 0x05
    1c0c:	0e 94 35 07 	call	0xe6a	; 0xe6a <set_ampGain>
set_filter(filterConfig);
    1c10:	8c 81       	ldd	r24, Y+4	; 0x04
    1c12:	0e 94 64 08 	call	0x10c8	; 0x10c8 <set_filter>

// if acc channel then enable DC Pass
// it is assumed that if not using high frequency acc specific function then
// DC Pass is wanted.
if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) ||
    1c16:	8b 81       	ldd	r24, Y+3	; 0x03
    1c18:	85 30       	cpi	r24, 0x05	; 5
    1c1a:	31 f0       	breq	.+12     	; 0x1c28 <CO_collectADC_cont+0x3a>
    1c1c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c1e:	86 30       	cpi	r24, 0x06	; 6
    1c20:	19 f0       	breq	.+6      	; 0x1c28 <CO_collectADC_cont+0x3a>
    1c22:	8b 81       	ldd	r24, Y+3	; 0x03
    1c24:	87 30       	cpi	r24, 0x07	; 7
    1c26:	19 f4       	brne	.+6      	; 0x1c2e <CO_collectADC_cont+0x40>
(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    1c28:	81 e0       	ldi	r24, 0x01	; 1
    1c2a:	0e 94 43 11 	call	0x2286	; 0x2286 <ACC_DCPassEnable>

enableADCMUX(TRUE);
    1c2e:	81 e0       	ldi	r24, 0x01	; 1
    1c30:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <enableADCMUX>
setADCInput(channel);
    1c34:	8b 81       	ldd	r24, Y+3	; 0x03
    1c36:	0e 94 6f 1c 	call	0x38de	; 0x38de <setADCInput>
SPIInit(SPI_MODE_1_gc);
    1c3a:	84 e0       	ldi	r24, 0x04	; 4
    1c3c:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1c40:	80 ec       	ldi	r24, 0xC0	; 192
    1c42:	98 e0       	ldi	r25, 0x08	; 8
    1c44:	24 e5       	ldi	r18, 0x54	; 84
    1c46:	fc 01       	movw	r30, r24
    1c48:	20 83       	st	Z, r18

// Configure IO13 (PF0) to capture ADC DRDY signal
PORTF.DIRCLR = PIN0_bm;
    1c4a:	80 ea       	ldi	r24, 0xA0	; 160
    1c4c:	96 e0       	ldi	r25, 0x06	; 6
    1c4e:	21 e0       	ldi	r18, 0x01	; 1
    1c50:	fc 01       	movw	r30, r24
    1c52:	22 83       	std	Z+2, r18	; 0x02
PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    1c54:	80 ea       	ldi	r24, 0xA0	; 160
    1c56:	96 e0       	ldi	r25, 0x06	; 6
    1c58:	22 e0       	ldi	r18, 0x02	; 2
    1c5a:	fc 01       	movw	r30, r24
    1c5c:	20 8b       	std	Z+16, r18	; 0x10
//PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_PULLUP_gc;
PORTF.INT1MASK = PIN0_bm;
    1c5e:	80 ea       	ldi	r24, 0xA0	; 160
    1c60:	96 e0       	ldi	r25, 0x06	; 6
    1c62:	21 e0       	ldi	r18, 0x01	; 1
    1c64:	fc 01       	movw	r30, r24
    1c66:	23 87       	std	Z+11, r18	; 0x0b
PORTF.INTCTRL = PORT_INT1LVL_MED_gc;
    1c68:	80 ea       	ldi	r24, 0xA0	; 160
    1c6a:	96 e0       	ldi	r25, 0x06	; 6
    1c6c:	28 e0       	ldi	r18, 0x08	; 8
    1c6e:	fc 01       	movw	r30, r24
    1c70:	21 87       	std	Z+9, r18	; 0x09
//f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
//the TCE1 counter increments every pulse of the system clock and once it reaches a certain value it 
//toggles pin 5 (clock input to ADC). This effectively divides the system clock into a desired clock rate for 
//the ADC. 
// Set IO14 (PE5) to output
PORTE.DIRSET = PIN5_bm;
    1c72:	80 e8       	ldi	r24, 0x80	; 128
    1c74:	96 e0       	ldi	r25, 0x06	; 6
    1c76:	20 e2       	ldi	r18, 0x20	; 32
    1c78:	fc 01       	movw	r30, r24
    1c7a:	21 83       	std	Z+1, r18	; 0x01
// Set Waveform generator mode(single slope) and enable the CCx output to IO14 (PE5)
TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1c7c:	80 e4       	ldi	r24, 0x40	; 64
    1c7e:	9a e0       	ldi	r25, 0x0A	; 10
    1c80:	23 e2       	ldi	r18, 0x23	; 35
    1c82:	fc 01       	movw	r30, r24
    1c84:	21 83       	std	Z+1, r18	; 0x01
// set period
period = (1 << (21 - spsExponent)) - 1;
    1c86:	8e 81       	ldd	r24, Y+6	; 0x06
    1c88:	88 2f       	mov	r24, r24
    1c8a:	90 e0       	ldi	r25, 0x00	; 0
    1c8c:	25 e1       	ldi	r18, 0x15	; 21
    1c8e:	30 e0       	ldi	r19, 0x00	; 0
    1c90:	28 1b       	sub	r18, r24
    1c92:	39 0b       	sbc	r19, r25
    1c94:	81 e0       	ldi	r24, 0x01	; 1
    1c96:	90 e0       	ldi	r25, 0x00	; 0
    1c98:	02 c0       	rjmp	.+4      	; 0x1c9e <CO_collectADC_cont+0xb0>
    1c9a:	88 0f       	add	r24, r24
    1c9c:	99 1f       	adc	r25, r25
    1c9e:	2a 95       	dec	r18
    1ca0:	e2 f7       	brpl	.-8      	; 0x1c9a <CO_collectADC_cont+0xac>
    1ca2:	01 97       	sbiw	r24, 0x01	; 1
    1ca4:	89 83       	std	Y+1, r24	; 0x01
    1ca6:	9a 83       	std	Y+2, r25	; 0x02
TCE1.PER = period;
    1ca8:	80 e4       	ldi	r24, 0x40	; 64
    1caa:	9a e0       	ldi	r25, 0x0A	; 10
    1cac:	29 81       	ldd	r18, Y+1	; 0x01
    1cae:	3a 81       	ldd	r19, Y+2	; 0x02
    1cb0:	fc 01       	movw	r30, r24
    1cb2:	26 a3       	lds	r18, 0x56
    1cb4:	37 a3       	lds	r19, 0x57
TCE1.CCBBUF = period / 2;
    1cb6:	80 e4       	ldi	r24, 0x40	; 64
    1cb8:	9a e0       	ldi	r25, 0x0A	; 10
    1cba:	29 81       	ldd	r18, Y+1	; 0x01
    1cbc:	3a 81       	ldd	r19, Y+2	; 0x02
    1cbe:	36 95       	lsr	r19
    1cc0:	27 95       	ror	r18
    1cc2:	fc 01       	movw	r30, r24
    1cc4:	22 af       	sts	0x72, r18
    1cc6:	33 af       	sts	0x73, r19
// Set oscillator source and frequency and start
TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1cc8:	80 e4       	ldi	r24, 0x40	; 64
    1cca:	9a e0       	ldi	r25, 0x0A	; 10
    1ccc:	20 e4       	ldi	r18, 0x40	; 64
    1cce:	3a e0       	ldi	r19, 0x0A	; 10
    1cd0:	f9 01       	movw	r30, r18
    1cd2:	20 81       	ld	r18, Z
    1cd4:	20 7f       	andi	r18, 0xF0	; 240
    1cd6:	21 60       	ori	r18, 0x01	; 1
    1cd8:	fc 01       	movw	r30, r24
    1cda:	20 83       	st	Z, r18

// Enable interrupts.
PMIC.CTRL |= PMIC_MEDLVLEN_bm;
    1cdc:	80 ea       	ldi	r24, 0xA0	; 160
    1cde:	90 e0       	ldi	r25, 0x00	; 0
    1ce0:	20 ea       	ldi	r18, 0xA0	; 160
    1ce2:	30 e0       	ldi	r19, 0x00	; 0
    1ce4:	f9 01       	movw	r30, r18
    1ce6:	22 81       	ldd	r18, Z+2	; 0x02
    1ce8:	22 60       	ori	r18, 0x02	; 2
    1cea:	fc 01       	movw	r30, r24
    1cec:	22 83       	std	Z+2, r18	; 0x02
//enable RR of lowlvl interrupts
PMIC.CTRL |= PMIC_RREN_bm; 
    1cee:	80 ea       	ldi	r24, 0xA0	; 160
    1cf0:	90 e0       	ldi	r25, 0x00	; 0
    1cf2:	20 ea       	ldi	r18, 0xA0	; 160
    1cf4:	30 e0       	ldi	r19, 0x00	; 0
    1cf6:	f9 01       	movw	r30, r18
    1cf8:	22 81       	ldd	r18, Z+2	; 0x02
    1cfa:	20 68       	ori	r18, 0x80	; 128
    1cfc:	fc 01       	movw	r30, r24
    1cfe:	22 83       	std	Z+2, r18	; 0x02
//perhaps next two lines are redundant...
// chb_init();
// chb_set_short_addr(moteID);

sampleCount = 0;
    1d00:	10 92 73 50 	sts	0x5073, r1
    1d04:	10 92 74 50 	sts	0x5074, r1
TotalSampleCount = 0;
    1d08:	10 92 a1 50 	sts	0x50A1, r1
    1d0c:	10 92 a2 50 	sts	0x50A2, r1
discardCount = 0;
    1d10:	10 92 5e 40 	sts	0x405E, r1
sei();
    1d14:	78 94       	sei
}
    1d16:	26 96       	adiw	r28, 0x06	; 6
    1d18:	cd bf       	out	0x3d, r28	; 61
    1d1a:	de bf       	out	0x3e, r29	; 62
    1d1c:	df 91       	pop	r29
    1d1e:	cf 91       	pop	r28
    1d20:	08 95       	ret

00001d22 <ADC_Pause_Sampling>:


void ADC_Pause_Sampling(){
    1d22:	cf 93       	push	r28
    1d24:	df 93       	push	r29
    1d26:	cd b7       	in	r28, 0x3d	; 61
    1d28:	de b7       	in	r29, 0x3e	; 62
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    1d2a:	80 ea       	ldi	r24, 0xA0	; 160
    1d2c:	96 e0       	ldi	r25, 0x06	; 6
    1d2e:	fc 01       	movw	r30, r24
    1d30:	13 86       	std	Z+11, r1	; 0x0b
}
    1d32:	df 91       	pop	r29
    1d34:	cf 91       	pop	r28
    1d36:	08 95       	ret

00001d38 <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
    1d38:	cf 93       	push	r28
    1d3a:	df 93       	push	r29
    1d3c:	cd b7       	in	r28, 0x3d	; 61
    1d3e:	de b7       	in	r29, 0x3e	; 62
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    1d40:	80 ea       	ldi	r24, 0xA0	; 160
    1d42:	96 e0       	ldi	r25, 0x06	; 6
    1d44:	21 e0       	ldi	r18, 0x01	; 1
    1d46:	fc 01       	movw	r30, r24
    1d48:	23 87       	std	Z+11, r18	; 0x0b
}	
    1d4a:	df 91       	pop	r29
    1d4c:	cf 91       	pop	r28
    1d4e:	08 95       	ret

00001d50 <__vector_105>:
ISR(PORTF_INT1_vect) {
    1d50:	1f 92       	push	r1
    1d52:	0f 92       	push	r0
    1d54:	0f b6       	in	r0, 0x3f	; 63
    1d56:	0f 92       	push	r0
    1d58:	00 90 3b 00 	lds	r0, 0x003B
    1d5c:	0f 92       	push	r0
    1d5e:	11 24       	eor	r1, r1
    1d60:	2f 92       	push	r2
    1d62:	3f 92       	push	r3
    1d64:	4f 92       	push	r4
    1d66:	5f 92       	push	r5
    1d68:	6f 92       	push	r6
    1d6a:	7f 92       	push	r7
    1d6c:	8f 92       	push	r8
    1d6e:	9f 92       	push	r9
    1d70:	af 92       	push	r10
    1d72:	bf 92       	push	r11
    1d74:	cf 92       	push	r12
    1d76:	df 92       	push	r13
    1d78:	ef 92       	push	r14
    1d7a:	ff 92       	push	r15
    1d7c:	0f 93       	push	r16
    1d7e:	1f 93       	push	r17
    1d80:	2f 93       	push	r18
    1d82:	3f 93       	push	r19
    1d84:	4f 93       	push	r20
    1d86:	5f 93       	push	r21
    1d88:	6f 93       	push	r22
    1d8a:	7f 93       	push	r23
    1d8c:	8f 93       	push	r24
    1d8e:	9f 93       	push	r25
    1d90:	af 93       	push	r26
    1d92:	bf 93       	push	r27
    1d94:	ef 93       	push	r30
    1d96:	ff 93       	push	r31
    1d98:	cf 93       	push	r28
    1d9a:	df 93       	push	r29
    1d9c:	00 d0       	rcall	.+0      	; 0x1d9e <__vector_105+0x4e>
    1d9e:	cd b7       	in	r28, 0x3d	; 61
    1da0:	de b7       	in	r29, 0x3e	; 62
			nop();
		}		
	}
	*/		
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    1da2:	80 91 5e 40 	lds	r24, 0x405E
    1da6:	88 23       	and	r24, r24
    1da8:	34 f0       	brlt	.+12     	; 0x1db6 <__vector_105+0x66>
		discardCount++;
    1daa:	80 91 5e 40 	lds	r24, 0x405E
    1dae:	8f 5f       	subi	r24, 0xFF	; 255
    1db0:	80 93 5e 40 	sts	0x405E, r24
    1db4:	81 c1       	rjmp	.+770    	; 0x20b8 <__vector_105+0x368>
	}		
	else {
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
    1db6:	84 e0       	ldi	r24, 0x04	; 4
    1db8:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1dbc:	80 ec       	ldi	r24, 0xC0	; 192
    1dbe:	98 e0       	ldi	r25, 0x08	; 8
    1dc0:	24 e5       	ldi	r18, 0x54	; 84
    1dc2:	fc 01       	movw	r30, r24
    1dc4:	20 83       	st	Z, r18
		SPICS(TRUE); // CS SPI-SS
    1dc6:	81 e0       	ldi	r24, 0x01	; 1
    1dc8:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1dcc:	80 ea       	ldi	r24, 0xA0	; 160
    1dce:	96 e0       	ldi	r25, 0x06	; 6
    1dd0:	22 e0       	ldi	r18, 0x02	; 2
    1dd2:	fc 01       	movw	r30, r24
    1dd4:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1dd6:	19 82       	std	Y+1, r1	; 0x01
    1dd8:	1a c0       	rjmp	.+52     	; 0x1e0e <__vector_105+0xbe>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1dda:	80 ec       	ldi	r24, 0xC0	; 192
    1ddc:	98 e0       	ldi	r25, 0x08	; 8
    1dde:	2a ea       	ldi	r18, 0xAA	; 170
    1de0:	fc 01       	movw	r30, r24
    1de2:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1de4:	00 00       	nop
    1de6:	80 ec       	ldi	r24, 0xC0	; 192
    1de8:	98 e0       	ldi	r25, 0x08	; 8
    1dea:	fc 01       	movw	r30, r24
    1dec:	82 81       	ldd	r24, Z+2	; 0x02
    1dee:	88 23       	and	r24, r24
    1df0:	d4 f7       	brge	.-12     	; 0x1de6 <__vector_105+0x96>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1df2:	89 81       	ldd	r24, Y+1	; 0x01
    1df4:	88 2f       	mov	r24, r24
    1df6:	90 e0       	ldi	r25, 0x00	; 0
    1df8:	20 ec       	ldi	r18, 0xC0	; 192
    1dfa:	38 e0       	ldi	r19, 0x08	; 8
    1dfc:	f9 01       	movw	r30, r18
    1dfe:	23 81       	ldd	r18, Z+3	; 0x03
    1e00:	8a 59       	subi	r24, 0x9A	; 154
    1e02:	9f 4a       	sbci	r25, 0xAF	; 175
    1e04:	fc 01       	movw	r30, r24
    1e06:	20 83       	st	Z, r18
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1e08:	89 81       	ldd	r24, Y+1	; 0x01
    1e0a:	8f 5f       	subi	r24, 0xFF	; 255
    1e0c:	89 83       	std	Y+1, r24	; 0x01
    1e0e:	89 81       	ldd	r24, Y+1	; 0x01
    1e10:	83 30       	cpi	r24, 0x03	; 3
    1e12:	18 f3       	brcs	.-58     	; 0x1dda <__vector_105+0x8a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1e14:	80 ea       	ldi	r24, 0xA0	; 160
    1e16:	96 e0       	ldi	r25, 0x06	; 6
    1e18:	22 e0       	ldi	r18, 0x02	; 2
    1e1a:	fc 01       	movw	r30, r24
    1e1c:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1e1e:	80 e0       	ldi	r24, 0x00	; 0
    1e20:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>

		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[0]) + 3) = 0xFF; // sign extension if negative
    1e24:	80 91 66 50 	lds	r24, 0x5066
    1e28:	88 23       	and	r24, r24
    1e2a:	34 f4       	brge	.+12     	; 0x1e38 <__vector_105+0xe8>
    1e2c:	87 e6       	ldi	r24, 0x67	; 103
    1e2e:	90 e4       	ldi	r25, 0x40	; 64
    1e30:	2f ef       	ldi	r18, 0xFF	; 255
    1e32:	fc 01       	movw	r30, r24
    1e34:	20 83       	st	Z, r18
    1e36:	04 c0       	rjmp	.+8      	; 0x1e40 <__vector_105+0xf0>
		else *(((uint8_t*)&data24Bit[0]) + 3) = 0x00;				
    1e38:	87 e6       	ldi	r24, 0x67	; 103
    1e3a:	90 e4       	ldi	r25, 0x40	; 64
    1e3c:	fc 01       	movw	r30, r24
    1e3e:	10 82       	st	Z, r1
		*(((uint8_t*)&data24Bit[0]) + 2) = SPIBuffer[0];
    1e40:	86 e6       	ldi	r24, 0x66	; 102
    1e42:	90 e4       	ldi	r25, 0x40	; 64
    1e44:	20 91 66 50 	lds	r18, 0x5066
    1e48:	fc 01       	movw	r30, r24
    1e4a:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 1) = SPIBuffer[1];
    1e4c:	85 e6       	ldi	r24, 0x65	; 101
    1e4e:	90 e4       	ldi	r25, 0x40	; 64
    1e50:	20 91 67 50 	lds	r18, 0x5067
    1e54:	fc 01       	movw	r30, r24
    1e56:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 0) = SPIBuffer[2];
    1e58:	84 e6       	ldi	r24, 0x64	; 100
    1e5a:	90 e4       	ldi	r25, 0x40	; 64
    1e5c:	20 91 68 50 	lds	r18, 0x5068
    1e60:	fc 01       	movw	r30, r24
    1e62:	20 83       	st	Z, r18
		
		//convert ADC reading to voltage here (in uV)
		var = data24Bit[0];
    1e64:	80 91 64 40 	lds	r24, 0x4064
    1e68:	90 91 65 40 	lds	r25, 0x4065
    1e6c:	a0 91 66 40 	lds	r26, 0x4066
    1e70:	b0 91 67 40 	lds	r27, 0x4067
    1e74:	5c 01       	movw	r10, r24
    1e76:	6d 01       	movw	r12, r26
    1e78:	bb 0f       	add	r27, r27
    1e7a:	88 0b       	sbc	r24, r24
    1e7c:	98 2f       	mov	r25, r24
    1e7e:	dc 01       	movw	r26, r24
    1e80:	e8 2e       	mov	r14, r24
    1e82:	f8 2e       	mov	r15, r24
    1e84:	08 2f       	mov	r16, r24
    1e86:	18 2f       	mov	r17, r24
    1e88:	a0 92 a3 50 	sts	0x50A3, r10
    1e8c:	b0 92 a4 50 	sts	0x50A4, r11
    1e90:	c0 92 a5 50 	sts	0x50A5, r12
    1e94:	d0 92 a6 50 	sts	0x50A6, r13
    1e98:	e0 92 a7 50 	sts	0x50A7, r14
    1e9c:	f0 92 a8 50 	sts	0x50A8, r15
    1ea0:	00 93 a9 50 	sts	0x50A9, r16
    1ea4:	10 93 aa 50 	sts	0x50AA, r17
		*((int32_t*)&FRAMReadBuffer[sampleCount*4]) = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1ea8:	80 91 73 50 	lds	r24, 0x5073
    1eac:	90 91 74 50 	lds	r25, 0x5074
    1eb0:	88 0f       	add	r24, r24
    1eb2:	99 1f       	adc	r25, r25
    1eb4:	88 0f       	add	r24, r24
    1eb6:	99 1f       	adc	r25, r25
    1eb8:	9c 01       	movw	r18, r24
    1eba:	20 52       	subi	r18, 0x20	; 32
    1ebc:	3c 4d       	sbci	r19, 0xDC	; 220
    1ebe:	2a 83       	std	Y+2, r18	; 0x02
    1ec0:	3b 83       	std	Y+3, r19	; 0x03
    1ec2:	a0 90 a3 50 	lds	r10, 0x50A3
    1ec6:	b0 90 a4 50 	lds	r11, 0x50A4
    1eca:	c0 90 a5 50 	lds	r12, 0x50A5
    1ece:	d0 90 a6 50 	lds	r13, 0x50A6
    1ed2:	e0 90 a7 50 	lds	r14, 0x50A7
    1ed6:	f0 90 a8 50 	lds	r15, 0x50A8
    1eda:	00 91 a9 50 	lds	r16, 0x50A9
    1ede:	10 91 aa 50 	lds	r17, 0x50AA
    1ee2:	2a 2d       	mov	r18, r10
    1ee4:	3b 2d       	mov	r19, r11
    1ee6:	4c 2d       	mov	r20, r12
    1ee8:	5d 2d       	mov	r21, r13
    1eea:	6e 2d       	mov	r22, r14
    1eec:	7f 2d       	mov	r23, r15
    1eee:	80 2f       	mov	r24, r16
    1ef0:	91 2f       	mov	r25, r17
    1ef2:	0f 2e       	mov	r0, r31
    1ef4:	f0 ea       	ldi	r31, 0xA0	; 160
    1ef6:	af 2e       	mov	r10, r31
    1ef8:	f0 2d       	mov	r31, r0
    1efa:	0f 2e       	mov	r0, r31
    1efc:	f5 e2       	ldi	r31, 0x25	; 37
    1efe:	bf 2e       	mov	r11, r31
    1f00:	f0 2d       	mov	r31, r0
    1f02:	0f 2e       	mov	r0, r31
    1f04:	f6 e2       	ldi	r31, 0x26	; 38
    1f06:	cf 2e       	mov	r12, r31
    1f08:	f0 2d       	mov	r31, r0
    1f0a:	dd 24       	eor	r13, r13
    1f0c:	ee 24       	eor	r14, r14
    1f0e:	ff 24       	eor	r15, r15
    1f10:	00 e0       	ldi	r16, 0x00	; 0
    1f12:	10 e0       	ldi	r17, 0x00	; 0
    1f14:	0e 94 b7 53 	call	0xa76e	; 0xa76e <__muldi3>
    1f18:	22 2e       	mov	r2, r18
    1f1a:	33 2e       	mov	r3, r19
    1f1c:	44 2e       	mov	r4, r20
    1f1e:	55 2e       	mov	r5, r21
    1f20:	66 2e       	mov	r6, r22
    1f22:	77 2e       	mov	r7, r23
    1f24:	88 2e       	mov	r8, r24
    1f26:	99 2e       	mov	r9, r25
    1f28:	a2 2c       	mov	r10, r2
    1f2a:	b3 2c       	mov	r11, r3
    1f2c:	c4 2c       	mov	r12, r4
    1f2e:	d5 2c       	mov	r13, r5
    1f30:	e6 2c       	mov	r14, r6
    1f32:	f7 2c       	mov	r15, r7
    1f34:	08 2d       	mov	r16, r8
    1f36:	19 2d       	mov	r17, r9
    1f38:	2a 2d       	mov	r18, r10
    1f3a:	3b 2d       	mov	r19, r11
    1f3c:	4c 2d       	mov	r20, r12
    1f3e:	5d 2d       	mov	r21, r13
    1f40:	6e 2d       	mov	r22, r14
    1f42:	7f 2d       	mov	r23, r15
    1f44:	80 2f       	mov	r24, r16
    1f46:	91 2f       	mov	r25, r17
    1f48:	aa 24       	eor	r10, r10
    1f4a:	aa 94       	dec	r10
    1f4c:	bb 24       	eor	r11, r11
    1f4e:	ba 94       	dec	r11
    1f50:	0f 2e       	mov	r0, r31
    1f52:	ff e7       	ldi	r31, 0x7F	; 127
    1f54:	cf 2e       	mov	r12, r31
    1f56:	f0 2d       	mov	r31, r0
    1f58:	dd 24       	eor	r13, r13
    1f5a:	ee 24       	eor	r14, r14
    1f5c:	ff 24       	eor	r15, r15
    1f5e:	00 e0       	ldi	r16, 0x00	; 0
    1f60:	10 e0       	ldi	r17, 0x00	; 0
    1f62:	0e 94 66 55 	call	0xaacc	; 0xaacc <__divdi3>
    1f66:	22 2e       	mov	r2, r18
    1f68:	33 2e       	mov	r3, r19
    1f6a:	44 2e       	mov	r4, r20
    1f6c:	55 2e       	mov	r5, r21
    1f6e:	66 2e       	mov	r6, r22
    1f70:	77 2e       	mov	r7, r23
    1f72:	88 2e       	mov	r8, r24
    1f74:	99 2e       	mov	r9, r25
    1f76:	a2 2c       	mov	r10, r2
    1f78:	b3 2c       	mov	r11, r3
    1f7a:	c4 2c       	mov	r12, r4
    1f7c:	d5 2c       	mov	r13, r5
    1f7e:	e6 2c       	mov	r14, r6
    1f80:	f7 2c       	mov	r15, r7
    1f82:	08 2d       	mov	r16, r8
    1f84:	19 2d       	mov	r17, r9
    1f86:	2a 2d       	mov	r18, r10
    1f88:	3b 2d       	mov	r19, r11
    1f8a:	4c 2d       	mov	r20, r12
    1f8c:	5d 2d       	mov	r21, r13
    1f8e:	6e 2d       	mov	r22, r14
    1f90:	7f 2d       	mov	r23, r15
    1f92:	80 2f       	mov	r24, r16
    1f94:	91 2f       	mov	r25, r17
    1f96:	01 e0       	ldi	r16, 0x01	; 1
    1f98:	0e 94 8a 54 	call	0xa914	; 0xa914 <__ashldi3>
    1f9c:	22 2e       	mov	r2, r18
    1f9e:	33 2e       	mov	r3, r19
    1fa0:	44 2e       	mov	r4, r20
    1fa2:	55 2e       	mov	r5, r21
    1fa4:	66 2e       	mov	r6, r22
    1fa6:	77 2e       	mov	r7, r23
    1fa8:	88 2e       	mov	r8, r24
    1faa:	99 2e       	mov	r9, r25
    1fac:	a2 2c       	mov	r10, r2
    1fae:	b3 2c       	mov	r11, r3
    1fb0:	c4 2c       	mov	r12, r4
    1fb2:	d5 2c       	mov	r13, r5
    1fb4:	e6 2c       	mov	r14, r6
    1fb6:	f7 2c       	mov	r15, r7
    1fb8:	08 2d       	mov	r16, r8
    1fba:	19 2d       	mov	r17, r9
    1fbc:	2a 2d       	mov	r18, r10
    1fbe:	3b 2d       	mov	r19, r11
    1fc0:	4c 2d       	mov	r20, r12
    1fc2:	5d 2d       	mov	r21, r13
    1fc4:	6e 2d       	mov	r22, r14
    1fc6:	7f 2d       	mov	r23, r15
    1fc8:	80 2f       	mov	r24, r16
    1fca:	91 2f       	mov	r25, r17
    1fcc:	0f 2e       	mov	r0, r31
    1fce:	f3 e0       	ldi	r31, 0x03	; 3
    1fd0:	af 2e       	mov	r10, r31
    1fd2:	f0 2d       	mov	r31, r0
    1fd4:	bb 24       	eor	r11, r11
    1fd6:	cc 24       	eor	r12, r12
    1fd8:	dd 24       	eor	r13, r13
    1fda:	ee 24       	eor	r14, r14
    1fdc:	ff 24       	eor	r15, r15
    1fde:	00 e0       	ldi	r16, 0x00	; 0
    1fe0:	10 e0       	ldi	r17, 0x00	; 0
    1fe2:	0e 94 66 55 	call	0xaacc	; 0xaacc <__divdi3>
    1fe6:	a2 2e       	mov	r10, r18
    1fe8:	b3 2e       	mov	r11, r19
    1fea:	c4 2e       	mov	r12, r20
    1fec:	d5 2e       	mov	r13, r21
    1fee:	e6 2e       	mov	r14, r22
    1ff0:	f7 2e       	mov	r15, r23
    1ff2:	08 2f       	mov	r16, r24
    1ff4:	19 2f       	mov	r17, r25
    1ff6:	2a 2d       	mov	r18, r10
    1ff8:	3b 2d       	mov	r19, r11
    1ffa:	4c 2d       	mov	r20, r12
    1ffc:	5d 2d       	mov	r21, r13
    1ffe:	6e 2d       	mov	r22, r14
    2000:	7f 2d       	mov	r23, r15
    2002:	80 2f       	mov	r24, r16
    2004:	91 2f       	mov	r25, r17
    2006:	da 01       	movw	r26, r20
    2008:	c9 01       	movw	r24, r18
    200a:	b0 95       	com	r27
    200c:	a0 95       	com	r26
    200e:	90 95       	com	r25
    2010:	81 95       	neg	r24
    2012:	9f 4f       	sbci	r25, 0xFF	; 255
    2014:	af 4f       	sbci	r26, 0xFF	; 255
    2016:	bf 4f       	sbci	r27, 0xFF	; 255
    2018:	ea 81       	ldd	r30, Y+2	; 0x02
    201a:	fb 81       	ldd	r31, Y+3	; 0x03
    201c:	80 83       	st	Z, r24
    201e:	91 83       	std	Z+1, r25	; 0x01
    2020:	a2 83       	std	Z+2, r26	; 0x02
    2022:	b3 83       	std	Z+3, r27	; 0x03
		
		sampleCount++;
    2024:	80 91 73 50 	lds	r24, 0x5073
    2028:	90 91 74 50 	lds	r25, 0x5074
    202c:	01 96       	adiw	r24, 0x01	; 1
    202e:	80 93 73 50 	sts	0x5073, r24
    2032:	90 93 74 50 	sts	0x5074, r25
	//after 128 samples, store the data into sd card and reset sample buffer
	//after 30 samples, send the data over the radio
	if (sampleCount >= 30) { 
    2036:	80 91 73 50 	lds	r24, 0x5073
    203a:	90 91 74 50 	lds	r25, 0x5074
    203e:	8e 31       	cpi	r24, 0x1E	; 30
    2040:	91 05       	cpc	r25, r1
    2042:	d0 f1       	brcs	.+116    	; 0x20b8 <__vector_105+0x368>
		/*
		SD_write_block(10,FRAMReadBuffer,512);
		for (int i=0;i<512;i++) FRAMReadBuffer[i] = 0;
		SD_read_block(10,FRAMReadBuffer);
		*/
		sampleCount=0;
    2044:	10 92 73 50 	sts	0x5073, r1
    2048:	10 92 74 50 	sts	0x5074, r1
		TotalSampleCount++;
    204c:	80 91 a1 50 	lds	r24, 0x50A1
    2050:	90 91 a2 50 	lds	r25, 0x50A2
    2054:	01 96       	adiw	r24, 0x01	; 1
    2056:	80 93 a1 50 	sts	0x50A1, r24
    205a:	90 93 a2 50 	sts	0x50A2, r25
		//PORTF.OUTSET = PIN1_bm; //re-enable ADC for further sampling
		
		//write code to send the data over radio instead. Include some identifying info (like mote number) with the data.
		memmove(FRAMReadBuffer+2,FRAMReadBuffer,sampleCount*4); //move the data in the FRAM buffer up by 1 byte to make room for metadata
    205e:	80 91 73 50 	lds	r24, 0x5073
    2062:	90 91 74 50 	lds	r25, 0x5074
    2066:	9c 01       	movw	r18, r24
    2068:	22 0f       	add	r18, r18
    206a:	33 1f       	adc	r19, r19
    206c:	22 0f       	add	r18, r18
    206e:	33 1f       	adc	r19, r19
    2070:	82 ee       	ldi	r24, 0xE2	; 226
    2072:	93 e2       	ldi	r25, 0x23	; 35
    2074:	40 ee       	ldi	r20, 0xE0	; 224
    2076:	53 e2       	ldi	r21, 0x23	; 35
    2078:	ba 01       	movw	r22, r20
    207a:	a9 01       	movw	r20, r18
    207c:	0e 94 51 5f 	call	0xbea2	; 0xbea2 <memcpy>
		FRAMReadBuffer[0] = moteID;		//send moteID of the mote that gathered the data
    2080:	80 91 cd 50 	lds	r24, 0x50CD
    2084:	80 93 e0 23 	sts	0x23E0, r24
		FRAMReadBuffer[1] = (uint8_t)sampleCount;	//send the number of data samples gathered cast as a byte since no more than 30/31 samples should be send at a time
    2088:	80 91 73 50 	lds	r24, 0x5073
    208c:	90 91 74 50 	lds	r25, 0x5074
    2090:	80 93 e1 23 	sts	0x23E1, r24
		chb_write(0x0000,FRAMReadBuffer,sampleCount*4+2);	//send the samples and the metadata (for now just 1 byte containing moteID) to the base station
    2094:	80 91 73 50 	lds	r24, 0x5073
    2098:	90 91 74 50 	lds	r25, 0x5074
    209c:	88 0f       	add	r24, r24
    209e:	99 1f       	adc	r25, r25
    20a0:	88 0f       	add	r24, r24
    20a2:	99 1f       	adc	r25, r25
    20a4:	02 96       	adiw	r24, 0x02	; 2
    20a6:	9c 01       	movw	r18, r24
    20a8:	40 e0       	ldi	r20, 0x00	; 0
    20aa:	50 e0       	ldi	r21, 0x00	; 0
    20ac:	60 ee       	ldi	r22, 0xE0	; 224
    20ae:	73 e2       	ldi	r23, 0x23	; 35
    20b0:	80 e0       	ldi	r24, 0x00	; 0
    20b2:	90 e0       	ldi	r25, 0x00	; 0
    20b4:	0e 94 19 21 	call	0x4232	; 0x4232 <chb_write>
	}	
	}	
}
    20b8:	23 96       	adiw	r28, 0x03	; 3
    20ba:	cd bf       	out	0x3d, r28	; 61
    20bc:	de bf       	out	0x3e, r29	; 62
    20be:	df 91       	pop	r29
    20c0:	cf 91       	pop	r28
    20c2:	ff 91       	pop	r31
    20c4:	ef 91       	pop	r30
    20c6:	bf 91       	pop	r27
    20c8:	af 91       	pop	r26
    20ca:	9f 91       	pop	r25
    20cc:	8f 91       	pop	r24
    20ce:	7f 91       	pop	r23
    20d0:	6f 91       	pop	r22
    20d2:	5f 91       	pop	r21
    20d4:	4f 91       	pop	r20
    20d6:	3f 91       	pop	r19
    20d8:	2f 91       	pop	r18
    20da:	1f 91       	pop	r17
    20dc:	0f 91       	pop	r16
    20de:	ff 90       	pop	r15
    20e0:	ef 90       	pop	r14
    20e2:	df 90       	pop	r13
    20e4:	cf 90       	pop	r12
    20e6:	bf 90       	pop	r11
    20e8:	af 90       	pop	r10
    20ea:	9f 90       	pop	r9
    20ec:	8f 90       	pop	r8
    20ee:	7f 90       	pop	r7
    20f0:	6f 90       	pop	r6
    20f2:	5f 90       	pop	r5
    20f4:	4f 90       	pop	r4
    20f6:	3f 90       	pop	r3
    20f8:	2f 90       	pop	r2
    20fa:	0f 90       	pop	r0
    20fc:	00 92 3b 00 	sts	0x003B, r0
    2100:	0f 90       	pop	r0
    2102:	0f be       	out	0x3f, r0	; 63
    2104:	0f 90       	pop	r0
    2106:	1f 90       	pop	r1
    2108:	18 95       	reti

0000210a <__vector_104>:

ISR(PORTF_INT0_vect) {
    210a:	1f 92       	push	r1
    210c:	0f 92       	push	r0
    210e:	0f b6       	in	r0, 0x3f	; 63
    2110:	0f 92       	push	r0
    2112:	00 90 3b 00 	lds	r0, 0x003B
    2116:	0f 92       	push	r0
    2118:	11 24       	eor	r1, r1
    211a:	2f 93       	push	r18
    211c:	3f 93       	push	r19
    211e:	4f 93       	push	r20
    2120:	5f 93       	push	r21
    2122:	6f 93       	push	r22
    2124:	7f 93       	push	r23
    2126:	8f 93       	push	r24
    2128:	9f 93       	push	r25
    212a:	af 93       	push	r26
    212c:	bf 93       	push	r27
    212e:	ef 93       	push	r30
    2130:	ff 93       	push	r31
    2132:	cf 93       	push	r28
    2134:	df 93       	push	r29
    2136:	0f 92       	push	r0
    2138:	cd b7       	in	r28, 0x3d	; 61
    213a:	de b7       	in	r29, 0x3e	; 62
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    213c:	80 91 5e 40 	lds	r24, 0x405E
    2140:	88 23       	and	r24, r24
    2142:	34 f0       	brlt	.+12     	; 0x2150 <__vector_104+0x46>
		discardCount++;
    2144:	80 91 5e 40 	lds	r24, 0x405E
    2148:	8f 5f       	subi	r24, 0xFF	; 255
    214a:	80 93 5e 40 	sts	0x405E, r24
    214e:	84 c0       	rjmp	.+264    	; 0x2258 <__vector_104+0x14e>
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    2150:	81 e0       	ldi	r24, 0x01	; 1
    2152:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    2156:	80 ea       	ldi	r24, 0xA0	; 160
    2158:	96 e0       	ldi	r25, 0x06	; 6
    215a:	22 e0       	ldi	r18, 0x02	; 2
    215c:	fc 01       	movw	r30, r24
    215e:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    2160:	19 82       	std	Y+1, r1	; 0x01
    2162:	1a c0       	rjmp	.+52     	; 0x2198 <__vector_104+0x8e>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2164:	80 ec       	ldi	r24, 0xC0	; 192
    2166:	98 e0       	ldi	r25, 0x08	; 8
    2168:	2a ea       	ldi	r18, 0xAA	; 170
    216a:	fc 01       	movw	r30, r24
    216c:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    216e:	00 00       	nop
    2170:	80 ec       	ldi	r24, 0xC0	; 192
    2172:	98 e0       	ldi	r25, 0x08	; 8
    2174:	fc 01       	movw	r30, r24
    2176:	82 81       	ldd	r24, Z+2	; 0x02
    2178:	88 23       	and	r24, r24
    217a:	d4 f7       	brge	.-12     	; 0x2170 <__vector_104+0x66>
			SPIBuffer[bufIndex] = SPIC.DATA;
    217c:	89 81       	ldd	r24, Y+1	; 0x01
    217e:	88 2f       	mov	r24, r24
    2180:	90 e0       	ldi	r25, 0x00	; 0
    2182:	20 ec       	ldi	r18, 0xC0	; 192
    2184:	38 e0       	ldi	r19, 0x08	; 8
    2186:	f9 01       	movw	r30, r18
    2188:	23 81       	ldd	r18, Z+3	; 0x03
    218a:	8a 59       	subi	r24, 0x9A	; 154
    218c:	9f 4a       	sbci	r25, 0xAF	; 175
    218e:	fc 01       	movw	r30, r24
    2190:	20 83       	st	Z, r18
		discardCount++;
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    2192:	89 81       	ldd	r24, Y+1	; 0x01
    2194:	8f 5f       	subi	r24, 0xFF	; 255
    2196:	89 83       	std	Y+1, r24	; 0x01
    2198:	89 81       	ldd	r24, Y+1	; 0x01
    219a:	83 30       	cpi	r24, 0x03	; 3
    219c:	18 f3       	brcs	.-58     	; 0x2164 <__vector_104+0x5a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    219e:	80 ea       	ldi	r24, 0xA0	; 160
    21a0:	96 e0       	ldi	r25, 0x06	; 6
    21a2:	22 e0       	ldi	r18, 0x02	; 2
    21a4:	fc 01       	movw	r30, r24
    21a6:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    21a8:	80 e0       	ldi	r24, 0x00	; 0
    21aa:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0xFF; // sign extension if negative
    21ae:	80 91 66 50 	lds	r24, 0x5066
    21b2:	88 23       	and	r24, r24
    21b4:	7c f4       	brge	.+30     	; 0x21d4 <__vector_104+0xca>
    21b6:	80 91 73 50 	lds	r24, 0x5073
    21ba:	90 91 74 50 	lds	r25, 0x5074
    21be:	88 0f       	add	r24, r24
    21c0:	99 1f       	adc	r25, r25
    21c2:	88 0f       	add	r24, r24
    21c4:	99 1f       	adc	r25, r25
    21c6:	03 96       	adiw	r24, 0x03	; 3
    21c8:	8c 59       	subi	r24, 0x9C	; 156
    21ca:	9f 4b       	sbci	r25, 0xBF	; 191
    21cc:	2f ef       	ldi	r18, 0xFF	; 255
    21ce:	fc 01       	movw	r30, r24
    21d0:	20 83       	st	Z, r18
    21d2:	0d c0       	rjmp	.+26     	; 0x21ee <__vector_104+0xe4>
		else *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0x00;
    21d4:	80 91 73 50 	lds	r24, 0x5073
    21d8:	90 91 74 50 	lds	r25, 0x5074
    21dc:	88 0f       	add	r24, r24
    21de:	99 1f       	adc	r25, r25
    21e0:	88 0f       	add	r24, r24
    21e2:	99 1f       	adc	r25, r25
    21e4:	03 96       	adiw	r24, 0x03	; 3
    21e6:	8c 59       	subi	r24, 0x9C	; 156
    21e8:	9f 4b       	sbci	r25, 0xBF	; 191
    21ea:	fc 01       	movw	r30, r24
    21ec:	10 82       	st	Z, r1
	
		*(((uint8_t*)&data24Bit[sampleCount]) + 2) = SPIBuffer[0];
    21ee:	80 91 73 50 	lds	r24, 0x5073
    21f2:	90 91 74 50 	lds	r25, 0x5074
    21f6:	88 0f       	add	r24, r24
    21f8:	99 1f       	adc	r25, r25
    21fa:	88 0f       	add	r24, r24
    21fc:	99 1f       	adc	r25, r25
    21fe:	02 96       	adiw	r24, 0x02	; 2
    2200:	8c 59       	subi	r24, 0x9C	; 156
    2202:	9f 4b       	sbci	r25, 0xBF	; 191
    2204:	20 91 66 50 	lds	r18, 0x5066
    2208:	fc 01       	movw	r30, r24
    220a:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[sampleCount]) + 1) = SPIBuffer[1];
    220c:	80 91 73 50 	lds	r24, 0x5073
    2210:	90 91 74 50 	lds	r25, 0x5074
    2214:	88 0f       	add	r24, r24
    2216:	99 1f       	adc	r25, r25
    2218:	88 0f       	add	r24, r24
    221a:	99 1f       	adc	r25, r25
    221c:	01 96       	adiw	r24, 0x01	; 1
    221e:	8c 59       	subi	r24, 0x9C	; 156
    2220:	9f 4b       	sbci	r25, 0xBF	; 191
    2222:	20 91 67 50 	lds	r18, 0x5067
    2226:	fc 01       	movw	r30, r24
    2228:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[sampleCount]) + 0) = SPIBuffer[2];
    222a:	80 91 73 50 	lds	r24, 0x5073
    222e:	90 91 74 50 	lds	r25, 0x5074
    2232:	88 0f       	add	r24, r24
    2234:	99 1f       	adc	r25, r25
    2236:	88 0f       	add	r24, r24
    2238:	99 1f       	adc	r25, r25
    223a:	8c 59       	subi	r24, 0x9C	; 156
    223c:	9f 4b       	sbci	r25, 0xBF	; 191
    223e:	20 91 68 50 	lds	r18, 0x5068
    2242:	fc 01       	movw	r30, r24
    2244:	20 83       	st	Z, r18

		sampleCount++;
    2246:	80 91 73 50 	lds	r24, 0x5073
    224a:	90 91 74 50 	lds	r25, 0x5074
    224e:	01 96       	adiw	r24, 0x01	; 1
    2250:	80 93 73 50 	sts	0x5073, r24
    2254:	90 93 74 50 	sts	0x5074, r25
	}
}
    2258:	0f 90       	pop	r0
    225a:	df 91       	pop	r29
    225c:	cf 91       	pop	r28
    225e:	ff 91       	pop	r31
    2260:	ef 91       	pop	r30
    2262:	bf 91       	pop	r27
    2264:	af 91       	pop	r26
    2266:	9f 91       	pop	r25
    2268:	8f 91       	pop	r24
    226a:	7f 91       	pop	r23
    226c:	6f 91       	pop	r22
    226e:	5f 91       	pop	r21
    2270:	4f 91       	pop	r20
    2272:	3f 91       	pop	r19
    2274:	2f 91       	pop	r18
    2276:	0f 90       	pop	r0
    2278:	00 92 3b 00 	sts	0x003B, r0
    227c:	0f 90       	pop	r0
    227e:	0f be       	out	0x3f, r0	; 63
    2280:	0f 90       	pop	r0
    2282:	1f 90       	pop	r1
    2284:	18 95       	reti

00002286 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
    2286:	cf 93       	push	r28
    2288:	df 93       	push	r29
    228a:	0f 92       	push	r0
    228c:	cd b7       	in	r28, 0x3d	; 61
    228e:	de b7       	in	r29, 0x3e	; 62
    2290:	89 83       	std	Y+1, r24	; 0x01
	if (enable) {
    2292:	89 81       	ldd	r24, Y+1	; 0x01
    2294:	88 23       	and	r24, r24
    2296:	49 f0       	breq	.+18     	; 0x22aa <ACC_DCPassEnable+0x24>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    2298:	80 e2       	ldi	r24, 0x20	; 32
    229a:	60 e0       	ldi	r22, 0x00	; 0
    229c:	0e 94 39 35 	call	0x6a72	; 0x6a72 <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    22a0:	80 e2       	ldi	r24, 0x20	; 32
    22a2:	60 e0       	ldi	r22, 0x00	; 0
    22a4:	0e 94 05 36 	call	0x6c0a	; 0x6c0a <PortEx_OUTSET>
    22a8:	04 c0       	rjmp	.+8      	; 0x22b2 <ACC_DCPassEnable+0x2c>
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    22aa:	80 e2       	ldi	r24, 0x20	; 32
    22ac:	60 e0       	ldi	r22, 0x00	; 0
    22ae:	0e 94 9d 35 	call	0x6b3a	; 0x6b3a <PortEx_DIRCLR>
		//setPortEx(0x00, PS_BANKB);
	}
}
    22b2:	0f 90       	pop	r0
    22b4:	df 91       	pop	r29
    22b6:	cf 91       	pop	r28
    22b8:	08 95       	ret

000022ba <CO_collectSeismic3Channel>:

void CO_collectSeismic3Channel(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD) {
    22ba:	8f 92       	push	r8
    22bc:	9f 92       	push	r9
    22be:	af 92       	push	r10
    22c0:	bf 92       	push	r11
    22c2:	cf 92       	push	r12
    22c4:	df 92       	push	r13
    22c6:	ef 92       	push	r14
    22c8:	ff 92       	push	r15
    22ca:	0f 93       	push	r16
    22cc:	cf 93       	push	r28
    22ce:	df 93       	push	r29
    22d0:	cd b7       	in	r28, 0x3d	; 61
    22d2:	de b7       	in	r29, 0x3e	; 62
    22d4:	2e 97       	sbiw	r28, 0x0e	; 14
    22d6:	cd bf       	out	0x3d, r28	; 61
    22d8:	de bf       	out	0x3e, r29	; 62
    22da:	89 83       	std	Y+1, r24	; 0x01
    22dc:	6a 83       	std	Y+2, r22	; 0x02
    22de:	7b 83       	std	Y+3, r23	; 0x03
    22e0:	4c 83       	std	Y+4, r20	; 0x04
    22e2:	2d 83       	std	Y+5, r18	; 0x05
    22e4:	0e 83       	std	Y+6, r16	; 0x06
    22e6:	ef 82       	std	Y+7, r14	; 0x07
    22e8:	f8 86       	std	Y+8, r15	; 0x08
    22ea:	c9 86       	std	Y+9, r12	; 0x09
    22ec:	da 86       	std	Y+10, r13	; 0x0a
    22ee:	ab 86       	std	Y+11, r10	; 0x0b
    22f0:	bc 86       	std	Y+12, r11	; 0x0c
    22f2:	8d 86       	std	Y+13, r8	; 0x0d
    22f4:	9e 86       	std	Y+14, r9	; 0x0e
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    22f6:	81 e0       	ldi	r24, 0x01	; 1
    22f8:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    22fc:	8a 81       	ldd	r24, Y+2	; 0x02
    22fe:	9b 81       	ldd	r25, Y+3	; 0x03
    2300:	fc 01       	movw	r30, r24
    2302:	90 81       	ld	r25, Z
    2304:	85 e0       	ldi	r24, 0x05	; 5
    2306:	69 2f       	mov	r22, r25
    2308:	0e 94 35 07 	call	0xe6a	; 0xe6a <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    230c:	8a 81       	ldd	r24, Y+2	; 0x02
    230e:	9b 81       	ldd	r25, Y+3	; 0x03
    2310:	01 96       	adiw	r24, 0x01	; 1
    2312:	fc 01       	movw	r30, r24
    2314:	90 81       	ld	r25, Z
    2316:	86 e0       	ldi	r24, 0x06	; 6
    2318:	69 2f       	mov	r22, r25
    231a:	0e 94 35 07 	call	0xe6a	; 0xe6a <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    231e:	8a 81       	ldd	r24, Y+2	; 0x02
    2320:	9b 81       	ldd	r25, Y+3	; 0x03
    2322:	02 96       	adiw	r24, 0x02	; 2
    2324:	fc 01       	movw	r30, r24
    2326:	90 81       	ld	r25, Z
    2328:	87 e0       	ldi	r24, 0x07	; 7
    232a:	69 2f       	mov	r22, r25
    232c:	0e 94 35 07 	call	0xe6a	; 0xe6a <set_ampGain>
	set_filter(filterConfig);
    2330:	89 81       	ldd	r24, Y+1	; 0x01
    2332:	0e 94 64 08 	call	0x10c8	; 0x10c8 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2336:	8e 81       	ldd	r24, Y+6	; 0x06
    2338:	0e 94 43 11 	call	0x2286	; 0x2286 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    233c:	84 e0       	ldi	r24, 0x04	; 4
    233e:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2342:	80 ec       	ldi	r24, 0xC0	; 192
    2344:	98 e0       	ldi	r25, 0x08	; 8
    2346:	24 e5       	ldi	r18, 0x54	; 84
    2348:	fc 01       	movw	r30, r24
    234a:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    234c:	81 e0       	ldi	r24, 0x01	; 1
    234e:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    2352:	85 e0       	ldi	r24, 0x05	; 5
    2354:	0e 94 6f 1c 	call	0x38de	; 0x38de <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2358:	80 ea       	ldi	r24, 0xA0	; 160
    235a:	96 e0       	ldi	r25, 0x06	; 6
    235c:	22 e0       	ldi	r18, 0x02	; 2
    235e:	fc 01       	movw	r30, r24
    2360:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2362:	80 ea       	ldi	r24, 0xA0	; 160
    2364:	96 e0       	ldi	r25, 0x06	; 6
    2366:	21 e0       	ldi	r18, 0x01	; 1
    2368:	fc 01       	movw	r30, r24
    236a:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    236c:	80 e8       	ldi	r24, 0x80	; 128
    236e:	91 e0       	ldi	r25, 0x01	; 1
    2370:	28 e7       	ldi	r18, 0x78	; 120
    2372:	fc 01       	movw	r30, r24
    2374:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2376:	80 e0       	ldi	r24, 0x00	; 0
    2378:	98 e0       	ldi	r25, 0x08	; 8
    237a:	20 ef       	ldi	r18, 0xF0	; 240
    237c:	fc 01       	movw	r30, r24
    237e:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    2380:	80 e0       	ldi	r24, 0x00	; 0
    2382:	98 e0       	ldi	r25, 0x08	; 8
    2384:	2f 81       	ldd	r18, Y+7	; 0x07
    2386:	38 85       	ldd	r19, Y+8	; 0x08
    2388:	fc 01       	movw	r30, r24
    238a:	20 a7       	lds	r18, 0x70
    238c:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    238e:	80 e0       	ldi	r24, 0x00	; 0
    2390:	98 e0       	ldi	r25, 0x08	; 8
    2392:	29 85       	ldd	r18, Y+9	; 0x09
    2394:	3a 85       	ldd	r19, Y+10	; 0x0a
    2396:	fc 01       	movw	r30, r24
    2398:	22 a7       	lds	r18, 0x72
    239a:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    239c:	80 e0       	ldi	r24, 0x00	; 0
    239e:	98 e0       	ldi	r25, 0x08	; 8
    23a0:	2b 85       	ldd	r18, Y+11	; 0x0b
    23a2:	3c 85       	ldd	r19, Y+12	; 0x0c
    23a4:	fc 01       	movw	r30, r24
    23a6:	24 a7       	lds	r18, 0x74
    23a8:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    23aa:	80 e0       	ldi	r24, 0x00	; 0
    23ac:	98 e0       	ldi	r25, 0x08	; 8
    23ae:	2d 85       	ldd	r18, Y+13	; 0x0d
    23b0:	3e 85       	ldd	r19, Y+14	; 0x0e
    23b2:	fc 01       	movw	r30, r24
    23b4:	26 a7       	lds	r18, 0x76
    23b6:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    23b8:	80 e0       	ldi	r24, 0x00	; 0
    23ba:	98 e0       	ldi	r25, 0x08	; 8
    23bc:	2d 81       	ldd	r18, Y+5	; 0x05
    23be:	22 2f       	mov	r18, r18
    23c0:	30 e0       	ldi	r19, 0x00	; 0
    23c2:	21 50       	subi	r18, 0x01	; 1
    23c4:	30 40       	sbci	r19, 0x00	; 0
    23c6:	fc 01       	movw	r30, r24
    23c8:	26 a3       	lds	r18, 0x56
    23ca:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    23cc:	80 e0       	ldi	r24, 0x00	; 0
    23ce:	98 e0       	ldi	r25, 0x08	; 8
    23d0:	22 e0       	ldi	r18, 0x02	; 2
    23d2:	fc 01       	movw	r30, r24
    23d4:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    23d6:	80 e0       	ldi	r24, 0x00	; 0
    23d8:	98 e0       	ldi	r25, 0x08	; 8
    23da:	2f ef       	ldi	r18, 0xFF	; 255
    23dc:	fc 01       	movw	r30, r24
    23de:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    23e0:	80 e0       	ldi	r24, 0x00	; 0
    23e2:	98 e0       	ldi	r25, 0x08	; 8
    23e4:	20 e0       	ldi	r18, 0x00	; 0
    23e6:	38 e0       	ldi	r19, 0x08	; 8
    23e8:	f9 01       	movw	r30, r18
    23ea:	20 81       	ld	r18, Z
    23ec:	20 7f       	andi	r18, 0xF0	; 240
    23ee:	28 60       	ori	r18, 0x08	; 8
    23f0:	fc 01       	movw	r30, r24
    23f2:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    23f4:	10 92 58 40 	sts	0x4058, r1
    23f8:	10 92 59 40 	sts	0x4059, r1
	sampleCount = 0;
    23fc:	10 92 73 50 	sts	0x5073, r1
    2400:	10 92 74 50 	sts	0x5074, r1
	SPICount = 0;
    2404:	10 92 cb 50 	sts	0x50CB, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2408:	80 e0       	ldi	r24, 0x00	; 0
    240a:	80 93 3c 21 	sts	0x213C, r24
    240e:	80 93 3b 21 	sts	0x213B, r24
    2412:	80 93 3a 21 	sts	0x213A, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    2416:	80 ea       	ldi	r24, 0xA0	; 160
    2418:	90 e0       	ldi	r25, 0x00	; 0
    241a:	20 ea       	ldi	r18, 0xA0	; 160
    241c:	30 e0       	ldi	r19, 0x00	; 0
    241e:	f9 01       	movw	r30, r18
    2420:	22 81       	ldd	r18, Z+2	; 0x02
    2422:	26 60       	ori	r18, 0x06	; 6
    2424:	fc 01       	movw	r30, r24
    2426:	22 83       	std	Z+2, r18	; 0x02
	sei();
    2428:	78 94       	sei

	SPICS(TRUE);
    242a:	81 e0       	ldi	r24, 0x01	; 1
    242c:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2430:	80 e8       	ldi	r24, 0x80	; 128
    2432:	96 e0       	ldi	r25, 0x06	; 6
    2434:	20 e2       	ldi	r18, 0x20	; 32
    2436:	fc 01       	movw	r30, r24
    2438:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    243a:	80 e4       	ldi	r24, 0x40	; 64
    243c:	9a e0       	ldi	r25, 0x0A	; 10
    243e:	23 e2       	ldi	r18, 0x23	; 35
    2440:	fc 01       	movw	r30, r24
    2442:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    2444:	80 e4       	ldi	r24, 0x40	; 64
    2446:	9a e0       	ldi	r25, 0x0A	; 10
    2448:	2c 81       	ldd	r18, Y+4	; 0x04
    244a:	42 2f       	mov	r20, r18
    244c:	50 e0       	ldi	r21, 0x00	; 0
    244e:	20 e2       	ldi	r18, 0x20	; 32
    2450:	30 e0       	ldi	r19, 0x00	; 0
    2452:	02 c0       	rjmp	.+4      	; 0x2458 <CO_collectSeismic3Channel+0x19e>
    2454:	22 0f       	add	r18, r18
    2456:	33 1f       	adc	r19, r19
    2458:	4a 95       	dec	r20
    245a:	e2 f7       	brpl	.-8      	; 0x2454 <CO_collectSeismic3Channel+0x19a>
    245c:	fc 01       	movw	r30, r24
    245e:	26 a3       	lds	r18, 0x56
    2460:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    2462:	80 e4       	ldi	r24, 0x40	; 64
    2464:	9a e0       	ldi	r25, 0x0A	; 10
    2466:	2c 81       	ldd	r18, Y+4	; 0x04
    2468:	42 2f       	mov	r20, r18
    246a:	50 e0       	ldi	r21, 0x00	; 0
    246c:	20 e1       	ldi	r18, 0x10	; 16
    246e:	30 e0       	ldi	r19, 0x00	; 0
    2470:	04 2e       	mov	r0, r20
    2472:	02 c0       	rjmp	.+4      	; 0x2478 <CO_collectSeismic3Channel+0x1be>
    2474:	22 0f       	add	r18, r18
    2476:	33 1f       	adc	r19, r19
    2478:	0a 94       	dec	r0
    247a:	e2 f7       	brpl	.-8      	; 0x2474 <CO_collectSeismic3Channel+0x1ba>
    247c:	fc 01       	movw	r30, r24
    247e:	22 af       	sts	0x72, r18
    2480:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2482:	80 e4       	ldi	r24, 0x40	; 64
    2484:	9a e0       	ldi	r25, 0x0A	; 10
    2486:	20 e4       	ldi	r18, 0x40	; 64
    2488:	3a e0       	ldi	r19, 0x0A	; 10
    248a:	f9 01       	movw	r30, r18
    248c:	20 81       	ld	r18, Z
    248e:	20 7f       	andi	r18, 0xF0	; 240
    2490:	21 60       	ori	r18, 0x01	; 1
    2492:	fc 01       	movw	r30, r24
    2494:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES);
    2496:	00 00       	nop
    2498:	80 91 73 50 	lds	r24, 0x5073
    249c:	90 91 74 50 	lds	r25, 0x5074
    24a0:	f5 e5       	ldi	r31, 0x55	; 85
    24a2:	83 35       	cpi	r24, 0x53	; 83
    24a4:	9f 07       	cpc	r25, r31
    24a6:	c0 f3       	brcs	.-16     	; 0x2498 <CO_collectSeismic3Channel+0x1de>

	// turn off timer and interrupts
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    24a8:	80 e0       	ldi	r24, 0x00	; 0
    24aa:	98 e0       	ldi	r25, 0x08	; 8
    24ac:	20 e0       	ldi	r18, 0x00	; 0
    24ae:	38 e0       	ldi	r19, 0x08	; 8
    24b0:	f9 01       	movw	r30, r18
    24b2:	20 81       	ld	r18, Z
    24b4:	20 7f       	andi	r18, 0xF0	; 240
    24b6:	fc 01       	movw	r30, r24
    24b8:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    24ba:	80 e4       	ldi	r24, 0x40	; 64
    24bc:	9a e0       	ldi	r25, 0x0A	; 10
    24be:	20 e4       	ldi	r18, 0x40	; 64
    24c0:	3a e0       	ldi	r19, 0x0A	; 10
    24c2:	f9 01       	movw	r30, r18
    24c4:	20 81       	ld	r18, Z
    24c6:	20 7f       	andi	r18, 0xF0	; 240
    24c8:	fc 01       	movw	r30, r24
    24ca:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    24cc:	80 ea       	ldi	r24, 0xA0	; 160
    24ce:	90 e0       	ldi	r25, 0x00	; 0
    24d0:	20 ea       	ldi	r18, 0xA0	; 160
    24d2:	30 e0       	ldi	r19, 0x00	; 0
    24d4:	f9 01       	movw	r30, r18
    24d6:	22 81       	ldd	r18, Z+2	; 0x02
    24d8:	29 7f       	andi	r18, 0xF9	; 249
    24da:	fc 01       	movw	r30, r24
    24dc:	22 83       	std	Z+2, r18	; 0x02
	cli();
    24de:	f8 94       	cli

	SPICS(FALSE);
    24e0:	80 e0       	ldi	r24, 0x00	; 0
    24e2:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	SPIDisable();
    24e6:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>
	enableADCMUX(FALSE);
    24ea:	80 e0       	ldi	r24, 0x00	; 0
    24ec:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <enableADCMUX>
	ADCPower(FALSE);
    24f0:	80 e0       	ldi	r24, 0x00	; 0
    24f2:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
	
}
    24f6:	2e 96       	adiw	r28, 0x0e	; 14
    24f8:	cd bf       	out	0x3d, r28	; 61
    24fa:	de bf       	out	0x3e, r29	; 62
    24fc:	df 91       	pop	r29
    24fe:	cf 91       	pop	r28
    2500:	0f 91       	pop	r16
    2502:	ff 90       	pop	r15
    2504:	ef 90       	pop	r14
    2506:	df 90       	pop	r13
    2508:	cf 90       	pop	r12
    250a:	bf 90       	pop	r11
    250c:	af 90       	pop	r10
    250e:	9f 90       	pop	r9
    2510:	8f 90       	pop	r8
    2512:	08 95       	ret

00002514 <CO_collectSeismic3Channel_continuous>:

void CO_collectSeismic3Channel_continuous(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD) {
    2514:	8f 92       	push	r8
    2516:	9f 92       	push	r9
    2518:	af 92       	push	r10
    251a:	bf 92       	push	r11
    251c:	cf 92       	push	r12
    251e:	df 92       	push	r13
    2520:	ef 92       	push	r14
    2522:	ff 92       	push	r15
    2524:	0f 93       	push	r16
    2526:	cf 93       	push	r28
    2528:	df 93       	push	r29
    252a:	cd b7       	in	r28, 0x3d	; 61
    252c:	de b7       	in	r29, 0x3e	; 62
    252e:	2e 97       	sbiw	r28, 0x0e	; 14
    2530:	cd bf       	out	0x3d, r28	; 61
    2532:	de bf       	out	0x3e, r29	; 62
    2534:	89 83       	std	Y+1, r24	; 0x01
    2536:	6a 83       	std	Y+2, r22	; 0x02
    2538:	7b 83       	std	Y+3, r23	; 0x03
    253a:	4c 83       	std	Y+4, r20	; 0x04
    253c:	2d 83       	std	Y+5, r18	; 0x05
    253e:	0e 83       	std	Y+6, r16	; 0x06
    2540:	ef 82       	std	Y+7, r14	; 0x07
    2542:	f8 86       	std	Y+8, r15	; 0x08
    2544:	c9 86       	std	Y+9, r12	; 0x09
    2546:	da 86       	std	Y+10, r13	; 0x0a
    2548:	ab 86       	std	Y+11, r10	; 0x0b
    254a:	bc 86       	std	Y+12, r11	; 0x0c
    254c:	8d 86       	std	Y+13, r8	; 0x0d
    254e:	9e 86       	std	Y+14, r9	; 0x0e
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2550:	81 e0       	ldi	r24, 0x01	; 1
    2552:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2556:	8a 81       	ldd	r24, Y+2	; 0x02
    2558:	9b 81       	ldd	r25, Y+3	; 0x03
    255a:	fc 01       	movw	r30, r24
    255c:	90 81       	ld	r25, Z
    255e:	85 e0       	ldi	r24, 0x05	; 5
    2560:	69 2f       	mov	r22, r25
    2562:	0e 94 35 07 	call	0xe6a	; 0xe6a <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    2566:	8a 81       	ldd	r24, Y+2	; 0x02
    2568:	9b 81       	ldd	r25, Y+3	; 0x03
    256a:	01 96       	adiw	r24, 0x01	; 1
    256c:	fc 01       	movw	r30, r24
    256e:	90 81       	ld	r25, Z
    2570:	86 e0       	ldi	r24, 0x06	; 6
    2572:	69 2f       	mov	r22, r25
    2574:	0e 94 35 07 	call	0xe6a	; 0xe6a <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2578:	8a 81       	ldd	r24, Y+2	; 0x02
    257a:	9b 81       	ldd	r25, Y+3	; 0x03
    257c:	02 96       	adiw	r24, 0x02	; 2
    257e:	fc 01       	movw	r30, r24
    2580:	90 81       	ld	r25, Z
    2582:	87 e0       	ldi	r24, 0x07	; 7
    2584:	69 2f       	mov	r22, r25
    2586:	0e 94 35 07 	call	0xe6a	; 0xe6a <set_ampGain>
	set_filter(filterConfig);
    258a:	89 81       	ldd	r24, Y+1	; 0x01
    258c:	0e 94 64 08 	call	0x10c8	; 0x10c8 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2590:	8e 81       	ldd	r24, Y+6	; 0x06
    2592:	0e 94 43 11 	call	0x2286	; 0x2286 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2596:	84 e0       	ldi	r24, 0x04	; 4
    2598:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    259c:	80 ec       	ldi	r24, 0xC0	; 192
    259e:	98 e0       	ldi	r25, 0x08	; 8
    25a0:	24 e5       	ldi	r18, 0x54	; 84
    25a2:	fc 01       	movw	r30, r24
    25a4:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    25a6:	81 e0       	ldi	r24, 0x01	; 1
    25a8:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    25ac:	85 e0       	ldi	r24, 0x05	; 5
    25ae:	0e 94 6f 1c 	call	0x38de	; 0x38de <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    25b2:	80 ea       	ldi	r24, 0xA0	; 160
    25b4:	96 e0       	ldi	r25, 0x06	; 6
    25b6:	22 e0       	ldi	r18, 0x02	; 2
    25b8:	fc 01       	movw	r30, r24
    25ba:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    25bc:	80 ea       	ldi	r24, 0xA0	; 160
    25be:	96 e0       	ldi	r25, 0x06	; 6
    25c0:	21 e0       	ldi	r18, 0x01	; 1
    25c2:	fc 01       	movw	r30, r24
    25c4:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    25c6:	80 e8       	ldi	r24, 0x80	; 128
    25c8:	91 e0       	ldi	r25, 0x01	; 1
    25ca:	28 e7       	ldi	r18, 0x78	; 120
    25cc:	fc 01       	movw	r30, r24
    25ce:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    25d0:	80 e0       	ldi	r24, 0x00	; 0
    25d2:	98 e0       	ldi	r25, 0x08	; 8
    25d4:	20 ef       	ldi	r18, 0xF0	; 240
    25d6:	fc 01       	movw	r30, r24
    25d8:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    25da:	80 e0       	ldi	r24, 0x00	; 0
    25dc:	98 e0       	ldi	r25, 0x08	; 8
    25de:	2f 81       	ldd	r18, Y+7	; 0x07
    25e0:	38 85       	ldd	r19, Y+8	; 0x08
    25e2:	fc 01       	movw	r30, r24
    25e4:	20 a7       	lds	r18, 0x70
    25e6:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    25e8:	80 e0       	ldi	r24, 0x00	; 0
    25ea:	98 e0       	ldi	r25, 0x08	; 8
    25ec:	29 85       	ldd	r18, Y+9	; 0x09
    25ee:	3a 85       	ldd	r19, Y+10	; 0x0a
    25f0:	fc 01       	movw	r30, r24
    25f2:	22 a7       	lds	r18, 0x72
    25f4:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    25f6:	80 e0       	ldi	r24, 0x00	; 0
    25f8:	98 e0       	ldi	r25, 0x08	; 8
    25fa:	2b 85       	ldd	r18, Y+11	; 0x0b
    25fc:	3c 85       	ldd	r19, Y+12	; 0x0c
    25fe:	fc 01       	movw	r30, r24
    2600:	24 a7       	lds	r18, 0x74
    2602:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    2604:	80 e0       	ldi	r24, 0x00	; 0
    2606:	98 e0       	ldi	r25, 0x08	; 8
    2608:	2d 85       	ldd	r18, Y+13	; 0x0d
    260a:	3e 85       	ldd	r19, Y+14	; 0x0e
    260c:	fc 01       	movw	r30, r24
    260e:	26 a7       	lds	r18, 0x76
    2610:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    2612:	80 e0       	ldi	r24, 0x00	; 0
    2614:	98 e0       	ldi	r25, 0x08	; 8
    2616:	2d 81       	ldd	r18, Y+5	; 0x05
    2618:	22 2f       	mov	r18, r18
    261a:	30 e0       	ldi	r19, 0x00	; 0
    261c:	21 50       	subi	r18, 0x01	; 1
    261e:	30 40       	sbci	r19, 0x00	; 0
    2620:	fc 01       	movw	r30, r24
    2622:	26 a3       	lds	r18, 0x56
    2624:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2626:	80 e0       	ldi	r24, 0x00	; 0
    2628:	98 e0       	ldi	r25, 0x08	; 8
    262a:	22 e0       	ldi	r18, 0x02	; 2
    262c:	fc 01       	movw	r30, r24
    262e:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2630:	80 e0       	ldi	r24, 0x00	; 0
    2632:	98 e0       	ldi	r25, 0x08	; 8
    2634:	2f ef       	ldi	r18, 0xFF	; 255
    2636:	fc 01       	movw	r30, r24
    2638:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    263a:	80 e0       	ldi	r24, 0x00	; 0
    263c:	98 e0       	ldi	r25, 0x08	; 8
    263e:	20 e0       	ldi	r18, 0x00	; 0
    2640:	38 e0       	ldi	r19, 0x08	; 8
    2642:	f9 01       	movw	r30, r18
    2644:	20 81       	ld	r18, Z
    2646:	20 7f       	andi	r18, 0xF0	; 240
    2648:	28 60       	ori	r18, 0x08	; 8
    264a:	fc 01       	movw	r30, r24
    264c:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    264e:	10 92 58 40 	sts	0x4058, r1
    2652:	10 92 59 40 	sts	0x4059, r1
	sampleCount = 0;
    2656:	10 92 73 50 	sts	0x5073, r1
    265a:	10 92 74 50 	sts	0x5074, r1
	SPICount = 0;
    265e:	10 92 cb 50 	sts	0x50CB, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2662:	80 e0       	ldi	r24, 0x00	; 0
    2664:	80 93 3c 21 	sts	0x213C, r24
    2668:	80 93 3b 21 	sts	0x213B, r24
    266c:	80 93 3a 21 	sts	0x213A, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    2670:	80 ea       	ldi	r24, 0xA0	; 160
    2672:	90 e0       	ldi	r25, 0x00	; 0
    2674:	20 ea       	ldi	r18, 0xA0	; 160
    2676:	30 e0       	ldi	r19, 0x00	; 0
    2678:	f9 01       	movw	r30, r18
    267a:	22 81       	ldd	r18, Z+2	; 0x02
    267c:	26 60       	ori	r18, 0x06	; 6
    267e:	fc 01       	movw	r30, r24
    2680:	22 83       	std	Z+2, r18	; 0x02
	sei();
    2682:	78 94       	sei

	SPICS(TRUE);
    2684:	81 e0       	ldi	r24, 0x01	; 1
    2686:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    268a:	80 e8       	ldi	r24, 0x80	; 128
    268c:	96 e0       	ldi	r25, 0x06	; 6
    268e:	20 e2       	ldi	r18, 0x20	; 32
    2690:	fc 01       	movw	r30, r24
    2692:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2694:	80 e4       	ldi	r24, 0x40	; 64
    2696:	9a e0       	ldi	r25, 0x0A	; 10
    2698:	23 e2       	ldi	r18, 0x23	; 35
    269a:	fc 01       	movw	r30, r24
    269c:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    269e:	80 e4       	ldi	r24, 0x40	; 64
    26a0:	9a e0       	ldi	r25, 0x0A	; 10
    26a2:	2c 81       	ldd	r18, Y+4	; 0x04
    26a4:	42 2f       	mov	r20, r18
    26a6:	50 e0       	ldi	r21, 0x00	; 0
    26a8:	20 e2       	ldi	r18, 0x20	; 32
    26aa:	30 e0       	ldi	r19, 0x00	; 0
    26ac:	02 c0       	rjmp	.+4      	; 0x26b2 <CO_collectSeismic3Channel_continuous+0x19e>
    26ae:	22 0f       	add	r18, r18
    26b0:	33 1f       	adc	r19, r19
    26b2:	4a 95       	dec	r20
    26b4:	e2 f7       	brpl	.-8      	; 0x26ae <CO_collectSeismic3Channel_continuous+0x19a>
    26b6:	fc 01       	movw	r30, r24
    26b8:	26 a3       	lds	r18, 0x56
    26ba:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    26bc:	80 e4       	ldi	r24, 0x40	; 64
    26be:	9a e0       	ldi	r25, 0x0A	; 10
    26c0:	2c 81       	ldd	r18, Y+4	; 0x04
    26c2:	42 2f       	mov	r20, r18
    26c4:	50 e0       	ldi	r21, 0x00	; 0
    26c6:	20 e1       	ldi	r18, 0x10	; 16
    26c8:	30 e0       	ldi	r19, 0x00	; 0
    26ca:	04 2e       	mov	r0, r20
    26cc:	02 c0       	rjmp	.+4      	; 0x26d2 <CO_collectSeismic3Channel_continuous+0x1be>
    26ce:	22 0f       	add	r18, r18
    26d0:	33 1f       	adc	r19, r19
    26d2:	0a 94       	dec	r0
    26d4:	e2 f7       	brpl	.-8      	; 0x26ce <CO_collectSeismic3Channel_continuous+0x1ba>
    26d6:	fc 01       	movw	r30, r24
    26d8:	22 af       	sts	0x72, r18
    26da:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    26dc:	80 e4       	ldi	r24, 0x40	; 64
    26de:	9a e0       	ldi	r25, 0x0A	; 10
    26e0:	20 e4       	ldi	r18, 0x40	; 64
    26e2:	3a e0       	ldi	r19, 0x0A	; 10
    26e4:	f9 01       	movw	r30, r18
    26e6:	20 81       	ld	r18, Z
    26e8:	20 7f       	andi	r18, 0xF0	; 240
    26ea:	21 60       	ori	r18, 0x01	; 1
    26ec:	fc 01       	movw	r30, r24
    26ee:	20 83       	st	Z, r18
	
	// collect samples from ADC continuously
	while(1){
		nop();
    26f0:	00 00       	nop
	}
    26f2:	fe cf       	rjmp	.-4      	; 0x26f0 <CO_collectSeismic3Channel_continuous+0x1dc>

000026f4 <__vector_16>:
}


ISR(TCC0_CCA_vect) {
    26f4:	1f 92       	push	r1
    26f6:	0f 92       	push	r0
    26f8:	0f b6       	in	r0, 0x3f	; 63
    26fa:	0f 92       	push	r0
    26fc:	00 90 3b 00 	lds	r0, 0x003B
    2700:	0f 92       	push	r0
    2702:	11 24       	eor	r1, r1
    2704:	2f 93       	push	r18
    2706:	3f 93       	push	r19
    2708:	4f 93       	push	r20
    270a:	5f 93       	push	r21
    270c:	6f 93       	push	r22
    270e:	7f 93       	push	r23
    2710:	8f 93       	push	r24
    2712:	9f 93       	push	r25
    2714:	af 93       	push	r26
    2716:	bf 93       	push	r27
    2718:	ef 93       	push	r30
    271a:	ff 93       	push	r31
    271c:	cf 93       	push	r28
    271e:	df 93       	push	r29
    2720:	cd b7       	in	r28, 0x3d	; 61
    2722:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2724:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <sampleCurrentChannel>
}
    2728:	df 91       	pop	r29
    272a:	cf 91       	pop	r28
    272c:	ff 91       	pop	r31
    272e:	ef 91       	pop	r30
    2730:	bf 91       	pop	r27
    2732:	af 91       	pop	r26
    2734:	9f 91       	pop	r25
    2736:	8f 91       	pop	r24
    2738:	7f 91       	pop	r23
    273a:	6f 91       	pop	r22
    273c:	5f 91       	pop	r21
    273e:	4f 91       	pop	r20
    2740:	3f 91       	pop	r19
    2742:	2f 91       	pop	r18
    2744:	0f 90       	pop	r0
    2746:	00 92 3b 00 	sts	0x003B, r0
    274a:	0f 90       	pop	r0
    274c:	0f be       	out	0x3f, r0	; 63
    274e:	0f 90       	pop	r0
    2750:	1f 90       	pop	r1
    2752:	18 95       	reti

00002754 <__vector_17>:

ISR(TCC0_CCB_vect) {
    2754:	1f 92       	push	r1
    2756:	0f 92       	push	r0
    2758:	0f b6       	in	r0, 0x3f	; 63
    275a:	0f 92       	push	r0
    275c:	00 90 3b 00 	lds	r0, 0x003B
    2760:	0f 92       	push	r0
    2762:	11 24       	eor	r1, r1
    2764:	2f 93       	push	r18
    2766:	3f 93       	push	r19
    2768:	4f 93       	push	r20
    276a:	5f 93       	push	r21
    276c:	6f 93       	push	r22
    276e:	7f 93       	push	r23
    2770:	8f 93       	push	r24
    2772:	9f 93       	push	r25
    2774:	af 93       	push	r26
    2776:	bf 93       	push	r27
    2778:	ef 93       	push	r30
    277a:	ff 93       	push	r31
    277c:	cf 93       	push	r28
    277e:	df 93       	push	r29
    2780:	cd b7       	in	r28, 0x3d	; 61
    2782:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2784:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <sampleCurrentChannel>
}
    2788:	df 91       	pop	r29
    278a:	cf 91       	pop	r28
    278c:	ff 91       	pop	r31
    278e:	ef 91       	pop	r30
    2790:	bf 91       	pop	r27
    2792:	af 91       	pop	r26
    2794:	9f 91       	pop	r25
    2796:	8f 91       	pop	r24
    2798:	7f 91       	pop	r23
    279a:	6f 91       	pop	r22
    279c:	5f 91       	pop	r21
    279e:	4f 91       	pop	r20
    27a0:	3f 91       	pop	r19
    27a2:	2f 91       	pop	r18
    27a4:	0f 90       	pop	r0
    27a6:	00 92 3b 00 	sts	0x003B, r0
    27aa:	0f 90       	pop	r0
    27ac:	0f be       	out	0x3f, r0	; 63
    27ae:	0f 90       	pop	r0
    27b0:	1f 90       	pop	r1
    27b2:	18 95       	reti

000027b4 <__vector_18>:

ISR(TCC0_CCC_vect) {
    27b4:	1f 92       	push	r1
    27b6:	0f 92       	push	r0
    27b8:	0f b6       	in	r0, 0x3f	; 63
    27ba:	0f 92       	push	r0
    27bc:	00 90 3b 00 	lds	r0, 0x003B
    27c0:	0f 92       	push	r0
    27c2:	11 24       	eor	r1, r1
    27c4:	2f 93       	push	r18
    27c6:	3f 93       	push	r19
    27c8:	4f 93       	push	r20
    27ca:	5f 93       	push	r21
    27cc:	6f 93       	push	r22
    27ce:	7f 93       	push	r23
    27d0:	8f 93       	push	r24
    27d2:	9f 93       	push	r25
    27d4:	af 93       	push	r26
    27d6:	bf 93       	push	r27
    27d8:	ef 93       	push	r30
    27da:	ff 93       	push	r31
    27dc:	cf 93       	push	r28
    27de:	df 93       	push	r29
    27e0:	cd b7       	in	r28, 0x3d	; 61
    27e2:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    27e4:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <sampleCurrentChannel>
}
    27e8:	df 91       	pop	r29
    27ea:	cf 91       	pop	r28
    27ec:	ff 91       	pop	r31
    27ee:	ef 91       	pop	r30
    27f0:	bf 91       	pop	r27
    27f2:	af 91       	pop	r26
    27f4:	9f 91       	pop	r25
    27f6:	8f 91       	pop	r24
    27f8:	7f 91       	pop	r23
    27fa:	6f 91       	pop	r22
    27fc:	5f 91       	pop	r21
    27fe:	4f 91       	pop	r20
    2800:	3f 91       	pop	r19
    2802:	2f 91       	pop	r18
    2804:	0f 90       	pop	r0
    2806:	00 92 3b 00 	sts	0x003B, r0
    280a:	0f 90       	pop	r0
    280c:	0f be       	out	0x3f, r0	; 63
    280e:	0f 90       	pop	r0
    2810:	1f 90       	pop	r1
    2812:	18 95       	reti

00002814 <__vector_19>:

ISR(TCC0_CCD_vect) {
    2814:	1f 92       	push	r1
    2816:	0f 92       	push	r0
    2818:	0f b6       	in	r0, 0x3f	; 63
    281a:	0f 92       	push	r0
    281c:	00 90 3b 00 	lds	r0, 0x003B
    2820:	0f 92       	push	r0
    2822:	11 24       	eor	r1, r1
    2824:	2f 93       	push	r18
    2826:	3f 93       	push	r19
    2828:	4f 93       	push	r20
    282a:	5f 93       	push	r21
    282c:	6f 93       	push	r22
    282e:	7f 93       	push	r23
    2830:	8f 93       	push	r24
    2832:	9f 93       	push	r25
    2834:	af 93       	push	r26
    2836:	bf 93       	push	r27
    2838:	ef 93       	push	r30
    283a:	ff 93       	push	r31
    283c:	cf 93       	push	r28
    283e:	df 93       	push	r29
    2840:	cd b7       	in	r28, 0x3d	; 61
    2842:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2844:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <sampleCurrentChannel>
	SPICount = 0;
    2848:	10 92 cb 50 	sts	0x50CB, r1
	if(PORTB.OUT & PIN1_bm) {
    284c:	80 e2       	ldi	r24, 0x20	; 32
    284e:	96 e0       	ldi	r25, 0x06	; 6
    2850:	fc 01       	movw	r30, r24
    2852:	84 81       	ldd	r24, Z+4	; 0x04
    2854:	88 2f       	mov	r24, r24
    2856:	90 e0       	ldi	r25, 0x00	; 0
    2858:	82 70       	andi	r24, 0x02	; 2
    285a:	90 70       	andi	r25, 0x00	; 0
    285c:	00 97       	sbiw	r24, 0x00	; 0
    285e:	b1 f0       	breq	.+44     	; 0x288c <__vector_19+0x78>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    2860:	80 e0       	ldi	r24, 0x00	; 0
    2862:	96 e0       	ldi	r25, 0x06	; 6
    2864:	fc 01       	movw	r30, r24
    2866:	84 81       	ldd	r24, Z+4	; 0x04
    2868:	88 2f       	mov	r24, r24
    286a:	90 e0       	ldi	r25, 0x00	; 0
    286c:	80 74       	andi	r24, 0x40	; 64
    286e:	90 70       	andi	r25, 0x00	; 0
    2870:	00 97       	sbiw	r24, 0x00	; 0
    2872:	31 f0       	breq	.+12     	; 0x2880 <__vector_19+0x6c>
    2874:	80 e2       	ldi	r24, 0x20	; 32
    2876:	96 e0       	ldi	r25, 0x06	; 6
    2878:	22 e0       	ldi	r18, 0x02	; 2
    287a:	fc 01       	movw	r30, r24
    287c:	27 83       	std	Z+7, r18	; 0x07
    287e:	10 c0       	rjmp	.+32     	; 0x28a0 <__vector_19+0x8c>
		else PORTA.OUTTGL = PIN6_bm;
    2880:	80 e0       	ldi	r24, 0x00	; 0
    2882:	96 e0       	ldi	r25, 0x06	; 6
    2884:	20 e4       	ldi	r18, 0x40	; 64
    2886:	fc 01       	movw	r30, r24
    2888:	27 83       	std	Z+7, r18	; 0x07
    288a:	0a c0       	rjmp	.+20     	; 0x28a0 <__vector_19+0x8c>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    288c:	80 e0       	ldi	r24, 0x00	; 0
    288e:	96 e0       	ldi	r25, 0x06	; 6
    2890:	20 e4       	ldi	r18, 0x40	; 64
    2892:	fc 01       	movw	r30, r24
    2894:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTSET = PIN1_bm;
    2896:	80 e2       	ldi	r24, 0x20	; 32
    2898:	96 e0       	ldi	r25, 0x06	; 6
    289a:	22 e0       	ldi	r18, 0x02	; 2
    289c:	fc 01       	movw	r30, r24
    289e:	25 83       	std	Z+5, r18	; 0x05
	}
	
}
    28a0:	df 91       	pop	r29
    28a2:	cf 91       	pop	r28
    28a4:	ff 91       	pop	r31
    28a6:	ef 91       	pop	r30
    28a8:	bf 91       	pop	r27
    28aa:	af 91       	pop	r26
    28ac:	9f 91       	pop	r25
    28ae:	8f 91       	pop	r24
    28b0:	7f 91       	pop	r23
    28b2:	6f 91       	pop	r22
    28b4:	5f 91       	pop	r21
    28b6:	4f 91       	pop	r20
    28b8:	3f 91       	pop	r19
    28ba:	2f 91       	pop	r18
    28bc:	0f 90       	pop	r0
    28be:	00 92 3b 00 	sts	0x003B, r0
    28c2:	0f 90       	pop	r0
    28c4:	0f be       	out	0x3f, r0	; 63
    28c6:	0f 90       	pop	r0
    28c8:	1f 90       	pop	r1
    28ca:	18 95       	reti

000028cc <__vector_14>:

ISR(TCC0_OVF_vect) {
    28cc:	1f 92       	push	r1
    28ce:	0f 92       	push	r0
    28d0:	0f b6       	in	r0, 0x3f	; 63
    28d2:	0f 92       	push	r0
    28d4:	00 90 3b 00 	lds	r0, 0x003B
    28d8:	0f 92       	push	r0
    28da:	11 24       	eor	r1, r1
    28dc:	2f 93       	push	r18
    28de:	3f 93       	push	r19
    28e0:	4f 93       	push	r20
    28e2:	5f 93       	push	r21
    28e4:	6f 93       	push	r22
    28e6:	7f 93       	push	r23
    28e8:	8f 93       	push	r24
    28ea:	9f 93       	push	r25
    28ec:	af 93       	push	r26
    28ee:	bf 93       	push	r27
    28f0:	ef 93       	push	r30
    28f2:	ff 93       	push	r31
    28f4:	cf 93       	push	r28
    28f6:	df 93       	push	r29
    28f8:	cd b7       	in	r28, 0x3d	; 61
    28fa:	de b7       	in	r29, 0x3e	; 62
	writeSE2FRAM();
    28fc:	0e 94 fb 16 	call	0x2df6	; 0x2df6 <writeSE2FRAM>
}
    2900:	df 91       	pop	r29
    2902:	cf 91       	pop	r28
    2904:	ff 91       	pop	r31
    2906:	ef 91       	pop	r30
    2908:	bf 91       	pop	r27
    290a:	af 91       	pop	r26
    290c:	9f 91       	pop	r25
    290e:	8f 91       	pop	r24
    2910:	7f 91       	pop	r23
    2912:	6f 91       	pop	r22
    2914:	5f 91       	pop	r21
    2916:	4f 91       	pop	r20
    2918:	3f 91       	pop	r19
    291a:	2f 91       	pop	r18
    291c:	0f 90       	pop	r0
    291e:	00 92 3b 00 	sts	0x003B, r0
    2922:	0f 90       	pop	r0
    2924:	0f be       	out	0x3f, r0	; 63
    2926:	0f 90       	pop	r0
    2928:	1f 90       	pop	r1
    292a:	18 95       	reti

0000292c <CO_collectSeismic1Channel>:

void CO_collectSeismic1Channel(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint8_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD) {
    292c:	8f 92       	push	r8
    292e:	9f 92       	push	r9
    2930:	af 92       	push	r10
    2932:	bf 92       	push	r11
    2934:	cf 92       	push	r12
    2936:	df 92       	push	r13
    2938:	ef 92       	push	r14
    293a:	0f 93       	push	r16
    293c:	cf 93       	push	r28
    293e:	df 93       	push	r29
    2940:	cd b7       	in	r28, 0x3d	; 61
    2942:	de b7       	in	r29, 0x3e	; 62
    2944:	2c 97       	sbiw	r28, 0x0c	; 12
    2946:	cd bf       	out	0x3d, r28	; 61
    2948:	de bf       	out	0x3e, r29	; 62
    294a:	89 83       	std	Y+1, r24	; 0x01
    294c:	6a 83       	std	Y+2, r22	; 0x02
    294e:	4b 83       	std	Y+3, r20	; 0x03
    2950:	2c 83       	std	Y+4, r18	; 0x04
    2952:	0d 83       	std	Y+5, r16	; 0x05
    2954:	ee 82       	std	Y+6, r14	; 0x06
    2956:	cf 82       	std	Y+7, r12	; 0x07
    2958:	d8 86       	std	Y+8, r13	; 0x08
    295a:	a9 86       	std	Y+9, r10	; 0x09
    295c:	ba 86       	std	Y+10, r11	; 0x0a
    295e:	8b 86       	std	Y+11, r8	; 0x0b
    2960:	9c 86       	std	Y+12, r9	; 0x0c
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2962:	81 e0       	ldi	r24, 0x01	; 1
    2964:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2968:	89 81       	ldd	r24, Y+1	; 0x01
    296a:	6b 81       	ldd	r22, Y+3	; 0x03
    296c:	0e 94 35 07 	call	0xe6a	; 0xe6a <set_ampGain>
	set_filter(filterConfig);
    2970:	8a 81       	ldd	r24, Y+2	; 0x02
    2972:	0e 94 64 08 	call	0x10c8	; 0x10c8 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2976:	8e 81       	ldd	r24, Y+6	; 0x06
    2978:	0e 94 43 11 	call	0x2286	; 0x2286 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    297c:	84 e0       	ldi	r24, 0x04	; 4
    297e:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2982:	80 ec       	ldi	r24, 0xC0	; 192
    2984:	98 e0       	ldi	r25, 0x08	; 8
    2986:	24 e5       	ldi	r18, 0x54	; 84
    2988:	fc 01       	movw	r30, r24
    298a:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    298c:	81 e0       	ldi	r24, 0x01	; 1
    298e:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <enableADCMUX>
	setADCInput(channel);
    2992:	89 81       	ldd	r24, Y+1	; 0x01
    2994:	0e 94 6f 1c 	call	0x38de	; 0x38de <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2998:	80 ea       	ldi	r24, 0xA0	; 160
    299a:	96 e0       	ldi	r25, 0x06	; 6
    299c:	22 e0       	ldi	r18, 0x02	; 2
    299e:	fc 01       	movw	r30, r24
    29a0:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    29a2:	80 ea       	ldi	r24, 0xA0	; 160
    29a4:	96 e0       	ldi	r25, 0x06	; 6
    29a6:	21 e0       	ldi	r18, 0x01	; 1
    29a8:	fc 01       	movw	r30, r24
    29aa:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    29ac:	80 e8       	ldi	r24, 0x80	; 128
    29ae:	91 e0       	ldi	r25, 0x01	; 1
    29b0:	28 e7       	ldi	r18, 0x78	; 120
    29b2:	fc 01       	movw	r30, r24
    29b4:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    29b6:	80 e0       	ldi	r24, 0x00	; 0
    29b8:	99 e0       	ldi	r25, 0x09	; 9
    29ba:	20 ef       	ldi	r18, 0xF0	; 240
    29bc:	fc 01       	movw	r30, r24
    29be:	21 83       	std	Z+1, r18	; 0x01
	TCD0.CCA = averagingPtA;
    29c0:	80 e0       	ldi	r24, 0x00	; 0
    29c2:	99 e0       	ldi	r25, 0x09	; 9
    29c4:	2f 81       	ldd	r18, Y+7	; 0x07
    29c6:	38 85       	ldd	r19, Y+8	; 0x08
    29c8:	fc 01       	movw	r30, r24
    29ca:	20 a7       	lds	r18, 0x70
    29cc:	31 a7       	lds	r19, 0x71
	TCD0.CCB = averagingPtB;
    29ce:	80 e0       	ldi	r24, 0x00	; 0
    29d0:	99 e0       	ldi	r25, 0x09	; 9
    29d2:	29 85       	ldd	r18, Y+9	; 0x09
    29d4:	3a 85       	ldd	r19, Y+10	; 0x0a
    29d6:	fc 01       	movw	r30, r24
    29d8:	22 a7       	lds	r18, 0x72
    29da:	33 a7       	lds	r19, 0x73
	TCD0.CCC = averagingPtC;
    29dc:	80 e0       	ldi	r24, 0x00	; 0
    29de:	99 e0       	ldi	r25, 0x09	; 9
    29e0:	2b 85       	ldd	r18, Y+11	; 0x0b
    29e2:	3c 85       	ldd	r19, Y+12	; 0x0c
    29e4:	fc 01       	movw	r30, r24
    29e6:	24 a7       	lds	r18, 0x74
    29e8:	35 a7       	lds	r19, 0x75
	TCD0.CCD = averagingPtD;
    29ea:	80 e0       	ldi	r24, 0x00	; 0
    29ec:	99 e0       	ldi	r25, 0x09	; 9
    29ee:	2a 8d       	ldd	r18, Y+26	; 0x1a
    29f0:	3b 8d       	ldd	r19, Y+27	; 0x1b
    29f2:	fc 01       	movw	r30, r24
    29f4:	26 a7       	lds	r18, 0x76
    29f6:	37 a7       	lds	r19, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    29f8:	80 e0       	ldi	r24, 0x00	; 0
    29fa:	99 e0       	ldi	r25, 0x09	; 9
    29fc:	2d 81       	ldd	r18, Y+5	; 0x05
    29fe:	22 2f       	mov	r18, r18
    2a00:	30 e0       	ldi	r19, 0x00	; 0
    2a02:	21 50       	subi	r18, 0x01	; 1
    2a04:	30 40       	sbci	r19, 0x00	; 0
    2a06:	fc 01       	movw	r30, r24
    2a08:	26 a3       	lds	r18, 0x56
    2a0a:	37 a3       	lds	r19, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2a0c:	80 e0       	ldi	r24, 0x00	; 0
    2a0e:	99 e0       	ldi	r25, 0x09	; 9
    2a10:	22 e0       	ldi	r18, 0x02	; 2
    2a12:	fc 01       	movw	r30, r24
    2a14:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2a16:	80 e0       	ldi	r24, 0x00	; 0
    2a18:	99 e0       	ldi	r25, 0x09	; 9
    2a1a:	2f ef       	ldi	r18, 0xFF	; 255
    2a1c:	fc 01       	movw	r30, r24
    2a1e:	27 83       	std	Z+7, r18	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2a20:	80 e0       	ldi	r24, 0x00	; 0
    2a22:	99 e0       	ldi	r25, 0x09	; 9
    2a24:	20 e0       	ldi	r18, 0x00	; 0
    2a26:	39 e0       	ldi	r19, 0x09	; 9
    2a28:	f9 01       	movw	r30, r18
    2a2a:	20 81       	ld	r18, Z
    2a2c:	20 7f       	andi	r18, 0xF0	; 240
    2a2e:	28 60       	ori	r18, 0x08	; 8
    2a30:	fc 01       	movw	r30, r24
    2a32:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    2a34:	10 92 58 40 	sts	0x4058, r1
    2a38:	10 92 59 40 	sts	0x4059, r1
	sampleCount = 0;
    2a3c:	10 92 73 50 	sts	0x5073, r1
    2a40:	10 92 74 50 	sts	0x5074, r1
	SPICount = 0;
    2a44:	10 92 cb 50 	sts	0x50CB, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2a48:	80 e0       	ldi	r24, 0x00	; 0
    2a4a:	80 93 3c 21 	sts	0x213C, r24
    2a4e:	80 93 3b 21 	sts	0x213B, r24
    2a52:	80 93 3a 21 	sts	0x213A, r24
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm;
    2a56:	80 ea       	ldi	r24, 0xA0	; 160
    2a58:	90 e0       	ldi	r25, 0x00	; 0
    2a5a:	20 ea       	ldi	r18, 0xA0	; 160
    2a5c:	30 e0       	ldi	r19, 0x00	; 0
    2a5e:	f9 01       	movw	r30, r18
    2a60:	22 81       	ldd	r18, Z+2	; 0x02
    2a62:	26 60       	ori	r18, 0x06	; 6
    2a64:	fc 01       	movw	r30, r24
    2a66:	22 83       	std	Z+2, r18	; 0x02
	sei();
    2a68:	78 94       	sei

	SPICS(TRUE);
    2a6a:	81 e0       	ldi	r24, 0x01	; 1
    2a6c:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2a70:	80 e8       	ldi	r24, 0x80	; 128
    2a72:	96 e0       	ldi	r25, 0x06	; 6
    2a74:	20 e2       	ldi	r18, 0x20	; 32
    2a76:	fc 01       	movw	r30, r24
    2a78:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2a7a:	80 e4       	ldi	r24, 0x40	; 64
    2a7c:	9a e0       	ldi	r25, 0x0A	; 10
    2a7e:	23 e2       	ldi	r18, 0x23	; 35
    2a80:	fc 01       	movw	r30, r24
    2a82:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    2a84:	80 e4       	ldi	r24, 0x40	; 64
    2a86:	9a e0       	ldi	r25, 0x0A	; 10
    2a88:	2c 81       	ldd	r18, Y+4	; 0x04
    2a8a:	42 2f       	mov	r20, r18
    2a8c:	50 e0       	ldi	r21, 0x00	; 0
    2a8e:	20 e2       	ldi	r18, 0x20	; 32
    2a90:	30 e0       	ldi	r19, 0x00	; 0
    2a92:	02 c0       	rjmp	.+4      	; 0x2a98 <CO_collectSeismic1Channel+0x16c>
    2a94:	22 0f       	add	r18, r18
    2a96:	33 1f       	adc	r19, r19
    2a98:	4a 95       	dec	r20
    2a9a:	e2 f7       	brpl	.-8      	; 0x2a94 <CO_collectSeismic1Channel+0x168>
    2a9c:	fc 01       	movw	r30, r24
    2a9e:	26 a3       	lds	r18, 0x56
    2aa0:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    2aa2:	80 e4       	ldi	r24, 0x40	; 64
    2aa4:	9a e0       	ldi	r25, 0x0A	; 10
    2aa6:	2c 81       	ldd	r18, Y+4	; 0x04
    2aa8:	42 2f       	mov	r20, r18
    2aaa:	50 e0       	ldi	r21, 0x00	; 0
    2aac:	20 e1       	ldi	r18, 0x10	; 16
    2aae:	30 e0       	ldi	r19, 0x00	; 0
    2ab0:	04 2e       	mov	r0, r20
    2ab2:	02 c0       	rjmp	.+4      	; 0x2ab8 <CO_collectSeismic1Channel+0x18c>
    2ab4:	22 0f       	add	r18, r18
    2ab6:	33 1f       	adc	r19, r19
    2ab8:	0a 94       	dec	r0
    2aba:	e2 f7       	brpl	.-8      	; 0x2ab4 <CO_collectSeismic1Channel+0x188>
    2abc:	fc 01       	movw	r30, r24
    2abe:	22 af       	sts	0x72, r18
    2ac0:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2ac2:	80 e4       	ldi	r24, 0x40	; 64
    2ac4:	9a e0       	ldi	r25, 0x0A	; 10
    2ac6:	20 e4       	ldi	r18, 0x40	; 64
    2ac8:	3a e0       	ldi	r19, 0x0A	; 10
    2aca:	f9 01       	movw	r30, r18
    2acc:	20 81       	ld	r18, Z
    2ace:	20 7f       	andi	r18, 0xF0	; 240
    2ad0:	21 60       	ori	r18, 0x01	; 1
    2ad2:	fc 01       	movw	r30, r24
    2ad4:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES);
    2ad6:	00 00       	nop
    2ad8:	80 91 73 50 	lds	r24, 0x5073
    2adc:	90 91 74 50 	lds	r25, 0x5074
    2ae0:	f5 e5       	ldi	r31, 0x55	; 85
    2ae2:	83 35       	cpi	r24, 0x53	; 83
    2ae4:	9f 07       	cpc	r25, r31
    2ae6:	c0 f3       	brcs	.-16     	; 0x2ad8 <CO_collectSeismic1Channel+0x1ac>

	// turn off timer and interrupts
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2ae8:	80 e0       	ldi	r24, 0x00	; 0
    2aea:	99 e0       	ldi	r25, 0x09	; 9
    2aec:	20 e0       	ldi	r18, 0x00	; 0
    2aee:	39 e0       	ldi	r19, 0x09	; 9
    2af0:	f9 01       	movw	r30, r18
    2af2:	20 81       	ld	r18, Z
    2af4:	20 7f       	andi	r18, 0xF0	; 240
    2af6:	fc 01       	movw	r30, r24
    2af8:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2afa:	80 e4       	ldi	r24, 0x40	; 64
    2afc:	9a e0       	ldi	r25, 0x0A	; 10
    2afe:	20 e4       	ldi	r18, 0x40	; 64
    2b00:	3a e0       	ldi	r19, 0x0A	; 10
    2b02:	f9 01       	movw	r30, r18
    2b04:	20 81       	ld	r18, Z
    2b06:	20 7f       	andi	r18, 0xF0	; 240
    2b08:	fc 01       	movw	r30, r24
    2b0a:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    2b0c:	80 ea       	ldi	r24, 0xA0	; 160
    2b0e:	90 e0       	ldi	r25, 0x00	; 0
    2b10:	20 ea       	ldi	r18, 0xA0	; 160
    2b12:	30 e0       	ldi	r19, 0x00	; 0
    2b14:	f9 01       	movw	r30, r18
    2b16:	22 81       	ldd	r18, Z+2	; 0x02
    2b18:	29 7f       	andi	r18, 0xF9	; 249
    2b1a:	fc 01       	movw	r30, r24
    2b1c:	22 83       	std	Z+2, r18	; 0x02
	cli();
    2b1e:	f8 94       	cli

	SPICS(FALSE);
    2b20:	80 e0       	ldi	r24, 0x00	; 0
    2b22:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	SPIDisable();
    2b26:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>
	enableADCMUX(FALSE);
    2b2a:	80 e0       	ldi	r24, 0x00	; 0
    2b2c:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <enableADCMUX>
	ADCPower(FALSE);
    2b30:	80 e0       	ldi	r24, 0x00	; 0
    2b32:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
	
}
    2b36:	2c 96       	adiw	r28, 0x0c	; 12
    2b38:	cd bf       	out	0x3d, r28	; 61
    2b3a:	de bf       	out	0x3e, r29	; 62
    2b3c:	df 91       	pop	r29
    2b3e:	cf 91       	pop	r28
    2b40:	0f 91       	pop	r16
    2b42:	ef 90       	pop	r14
    2b44:	df 90       	pop	r13
    2b46:	cf 90       	pop	r12
    2b48:	bf 90       	pop	r11
    2b4a:	af 90       	pop	r10
    2b4c:	9f 90       	pop	r9
    2b4e:	8f 90       	pop	r8
    2b50:	08 95       	ret

00002b52 <__vector_79>:

ISR(TCD0_CCA_vect) {
    2b52:	1f 92       	push	r1
    2b54:	0f 92       	push	r0
    2b56:	0f b6       	in	r0, 0x3f	; 63
    2b58:	0f 92       	push	r0
    2b5a:	00 90 3b 00 	lds	r0, 0x003B
    2b5e:	0f 92       	push	r0
    2b60:	11 24       	eor	r1, r1
    2b62:	2f 93       	push	r18
    2b64:	3f 93       	push	r19
    2b66:	4f 93       	push	r20
    2b68:	5f 93       	push	r21
    2b6a:	6f 93       	push	r22
    2b6c:	7f 93       	push	r23
    2b6e:	8f 93       	push	r24
    2b70:	9f 93       	push	r25
    2b72:	af 93       	push	r26
    2b74:	bf 93       	push	r27
    2b76:	ef 93       	push	r30
    2b78:	ff 93       	push	r31
    2b7a:	cf 93       	push	r28
    2b7c:	df 93       	push	r29
    2b7e:	cd b7       	in	r28, 0x3d	; 61
    2b80:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2b82:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <sampleCurrentChannel>
}
    2b86:	df 91       	pop	r29
    2b88:	cf 91       	pop	r28
    2b8a:	ff 91       	pop	r31
    2b8c:	ef 91       	pop	r30
    2b8e:	bf 91       	pop	r27
    2b90:	af 91       	pop	r26
    2b92:	9f 91       	pop	r25
    2b94:	8f 91       	pop	r24
    2b96:	7f 91       	pop	r23
    2b98:	6f 91       	pop	r22
    2b9a:	5f 91       	pop	r21
    2b9c:	4f 91       	pop	r20
    2b9e:	3f 91       	pop	r19
    2ba0:	2f 91       	pop	r18
    2ba2:	0f 90       	pop	r0
    2ba4:	00 92 3b 00 	sts	0x003B, r0
    2ba8:	0f 90       	pop	r0
    2baa:	0f be       	out	0x3f, r0	; 63
    2bac:	0f 90       	pop	r0
    2bae:	1f 90       	pop	r1
    2bb0:	18 95       	reti

00002bb2 <__vector_80>:

ISR(TCD0_CCB_vect) {
    2bb2:	1f 92       	push	r1
    2bb4:	0f 92       	push	r0
    2bb6:	0f b6       	in	r0, 0x3f	; 63
    2bb8:	0f 92       	push	r0
    2bba:	00 90 3b 00 	lds	r0, 0x003B
    2bbe:	0f 92       	push	r0
    2bc0:	11 24       	eor	r1, r1
    2bc2:	2f 93       	push	r18
    2bc4:	3f 93       	push	r19
    2bc6:	4f 93       	push	r20
    2bc8:	5f 93       	push	r21
    2bca:	6f 93       	push	r22
    2bcc:	7f 93       	push	r23
    2bce:	8f 93       	push	r24
    2bd0:	9f 93       	push	r25
    2bd2:	af 93       	push	r26
    2bd4:	bf 93       	push	r27
    2bd6:	ef 93       	push	r30
    2bd8:	ff 93       	push	r31
    2bda:	cf 93       	push	r28
    2bdc:	df 93       	push	r29
    2bde:	cd b7       	in	r28, 0x3d	; 61
    2be0:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2be2:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <sampleCurrentChannel>
}
    2be6:	df 91       	pop	r29
    2be8:	cf 91       	pop	r28
    2bea:	ff 91       	pop	r31
    2bec:	ef 91       	pop	r30
    2bee:	bf 91       	pop	r27
    2bf0:	af 91       	pop	r26
    2bf2:	9f 91       	pop	r25
    2bf4:	8f 91       	pop	r24
    2bf6:	7f 91       	pop	r23
    2bf8:	6f 91       	pop	r22
    2bfa:	5f 91       	pop	r21
    2bfc:	4f 91       	pop	r20
    2bfe:	3f 91       	pop	r19
    2c00:	2f 91       	pop	r18
    2c02:	0f 90       	pop	r0
    2c04:	00 92 3b 00 	sts	0x003B, r0
    2c08:	0f 90       	pop	r0
    2c0a:	0f be       	out	0x3f, r0	; 63
    2c0c:	0f 90       	pop	r0
    2c0e:	1f 90       	pop	r1
    2c10:	18 95       	reti

00002c12 <__vector_81>:

ISR(TCD0_CCC_vect) {
    2c12:	1f 92       	push	r1
    2c14:	0f 92       	push	r0
    2c16:	0f b6       	in	r0, 0x3f	; 63
    2c18:	0f 92       	push	r0
    2c1a:	00 90 3b 00 	lds	r0, 0x003B
    2c1e:	0f 92       	push	r0
    2c20:	11 24       	eor	r1, r1
    2c22:	2f 93       	push	r18
    2c24:	3f 93       	push	r19
    2c26:	4f 93       	push	r20
    2c28:	5f 93       	push	r21
    2c2a:	6f 93       	push	r22
    2c2c:	7f 93       	push	r23
    2c2e:	8f 93       	push	r24
    2c30:	9f 93       	push	r25
    2c32:	af 93       	push	r26
    2c34:	bf 93       	push	r27
    2c36:	ef 93       	push	r30
    2c38:	ff 93       	push	r31
    2c3a:	cf 93       	push	r28
    2c3c:	df 93       	push	r29
    2c3e:	cd b7       	in	r28, 0x3d	; 61
    2c40:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2c42:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <sampleCurrentChannel>
}
    2c46:	df 91       	pop	r29
    2c48:	cf 91       	pop	r28
    2c4a:	ff 91       	pop	r31
    2c4c:	ef 91       	pop	r30
    2c4e:	bf 91       	pop	r27
    2c50:	af 91       	pop	r26
    2c52:	9f 91       	pop	r25
    2c54:	8f 91       	pop	r24
    2c56:	7f 91       	pop	r23
    2c58:	6f 91       	pop	r22
    2c5a:	5f 91       	pop	r21
    2c5c:	4f 91       	pop	r20
    2c5e:	3f 91       	pop	r19
    2c60:	2f 91       	pop	r18
    2c62:	0f 90       	pop	r0
    2c64:	00 92 3b 00 	sts	0x003B, r0
    2c68:	0f 90       	pop	r0
    2c6a:	0f be       	out	0x3f, r0	; 63
    2c6c:	0f 90       	pop	r0
    2c6e:	1f 90       	pop	r1
    2c70:	18 95       	reti

00002c72 <__vector_82>:

ISR(TCD0_CCD_vect) {
    2c72:	1f 92       	push	r1
    2c74:	0f 92       	push	r0
    2c76:	0f b6       	in	r0, 0x3f	; 63
    2c78:	0f 92       	push	r0
    2c7a:	00 90 3b 00 	lds	r0, 0x003B
    2c7e:	0f 92       	push	r0
    2c80:	11 24       	eor	r1, r1
    2c82:	2f 93       	push	r18
    2c84:	3f 93       	push	r19
    2c86:	4f 93       	push	r20
    2c88:	5f 93       	push	r21
    2c8a:	6f 93       	push	r22
    2c8c:	7f 93       	push	r23
    2c8e:	8f 93       	push	r24
    2c90:	9f 93       	push	r25
    2c92:	af 93       	push	r26
    2c94:	bf 93       	push	r27
    2c96:	ef 93       	push	r30
    2c98:	ff 93       	push	r31
    2c9a:	cf 93       	push	r28
    2c9c:	df 93       	push	r29
    2c9e:	cd b7       	in	r28, 0x3d	; 61
    2ca0:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2ca2:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <sampleCurrentChannel>
	SPICount = 0;
    2ca6:	10 92 cb 50 	sts	0x50CB, r1
}
    2caa:	df 91       	pop	r29
    2cac:	cf 91       	pop	r28
    2cae:	ff 91       	pop	r31
    2cb0:	ef 91       	pop	r30
    2cb2:	bf 91       	pop	r27
    2cb4:	af 91       	pop	r26
    2cb6:	9f 91       	pop	r25
    2cb8:	8f 91       	pop	r24
    2cba:	7f 91       	pop	r23
    2cbc:	6f 91       	pop	r22
    2cbe:	5f 91       	pop	r21
    2cc0:	4f 91       	pop	r20
    2cc2:	3f 91       	pop	r19
    2cc4:	2f 91       	pop	r18
    2cc6:	0f 90       	pop	r0
    2cc8:	00 92 3b 00 	sts	0x003B, r0
    2ccc:	0f 90       	pop	r0
    2cce:	0f be       	out	0x3f, r0	; 63
    2cd0:	0f 90       	pop	r0
    2cd2:	1f 90       	pop	r1
    2cd4:	18 95       	reti

00002cd6 <__vector_77>:

ISR(TCD0_OVF_vect) {
    2cd6:	1f 92       	push	r1
    2cd8:	0f 92       	push	r0
    2cda:	0f b6       	in	r0, 0x3f	; 63
    2cdc:	0f 92       	push	r0
    2cde:	00 90 3b 00 	lds	r0, 0x003B
    2ce2:	0f 92       	push	r0
    2ce4:	11 24       	eor	r1, r1
    2ce6:	2f 93       	push	r18
    2ce8:	3f 93       	push	r19
    2cea:	4f 93       	push	r20
    2cec:	5f 93       	push	r21
    2cee:	6f 93       	push	r22
    2cf0:	7f 93       	push	r23
    2cf2:	8f 93       	push	r24
    2cf4:	9f 93       	push	r25
    2cf6:	af 93       	push	r26
    2cf8:	bf 93       	push	r27
    2cfa:	ef 93       	push	r30
    2cfc:	ff 93       	push	r31
    2cfe:	cf 93       	push	r28
    2d00:	df 93       	push	r29
    2d02:	cd b7       	in	r28, 0x3d	; 61
    2d04:	de b7       	in	r29, 0x3e	; 62
	writeSE2FRAM();
    2d06:	0e 94 fb 16 	call	0x2df6	; 0x2df6 <writeSE2FRAM>
}
    2d0a:	df 91       	pop	r29
    2d0c:	cf 91       	pop	r28
    2d0e:	ff 91       	pop	r31
    2d10:	ef 91       	pop	r30
    2d12:	bf 91       	pop	r27
    2d14:	af 91       	pop	r26
    2d16:	9f 91       	pop	r25
    2d18:	8f 91       	pop	r24
    2d1a:	7f 91       	pop	r23
    2d1c:	6f 91       	pop	r22
    2d1e:	5f 91       	pop	r21
    2d20:	4f 91       	pop	r20
    2d22:	3f 91       	pop	r19
    2d24:	2f 91       	pop	r18
    2d26:	0f 90       	pop	r0
    2d28:	00 92 3b 00 	sts	0x003B, r0
    2d2c:	0f 90       	pop	r0
    2d2e:	0f be       	out	0x3f, r0	; 63
    2d30:	0f 90       	pop	r0
    2d32:	1f 90       	pop	r1
    2d34:	18 95       	reti

00002d36 <sampleCurrentChannel>:

void sampleCurrentChannel() {
    2d36:	cf 93       	push	r28
    2d38:	df 93       	push	r29
    2d3a:	cd b7       	in	r28, 0x3d	; 61
    2d3c:	de b7       	in	r29, 0x3e	; 62
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    2d3e:	80 ea       	ldi	r24, 0xA0	; 160
    2d40:	96 e0       	ldi	r25, 0x06	; 6
    2d42:	22 e0       	ldi	r18, 0x02	; 2
    2d44:	fc 01       	movw	r30, r24
    2d46:	26 83       	std	Z+6, r18	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2d48:	80 ec       	ldi	r24, 0xC0	; 192
    2d4a:	98 e0       	ldi	r25, 0x08	; 8
    2d4c:	2a ea       	ldi	r18, 0xAA	; 170
    2d4e:	fc 01       	movw	r30, r24
    2d50:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d52:	00 00       	nop
    2d54:	80 ec       	ldi	r24, 0xC0	; 192
    2d56:	98 e0       	ldi	r25, 0x08	; 8
    2d58:	fc 01       	movw	r30, r24
    2d5a:	82 81       	ldd	r24, Z+2	; 0x02
    2d5c:	88 23       	and	r24, r24
    2d5e:	d4 f7       	brge	.-12     	; 0x2d54 <sampleCurrentChannel+0x1e>
	SPIBuffer[SPICount] = SPIC.DATA;
    2d60:	80 91 cb 50 	lds	r24, 0x50CB
    2d64:	88 2f       	mov	r24, r24
    2d66:	90 e0       	ldi	r25, 0x00	; 0
    2d68:	20 ec       	ldi	r18, 0xC0	; 192
    2d6a:	38 e0       	ldi	r19, 0x08	; 8
    2d6c:	f9 01       	movw	r30, r18
    2d6e:	23 81       	ldd	r18, Z+3	; 0x03
    2d70:	8a 59       	subi	r24, 0x9A	; 154
    2d72:	9f 4a       	sbci	r25, 0xAF	; 175
    2d74:	fc 01       	movw	r30, r24
    2d76:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2d78:	80 ec       	ldi	r24, 0xC0	; 192
    2d7a:	98 e0       	ldi	r25, 0x08	; 8
    2d7c:	2a ea       	ldi	r18, 0xAA	; 170
    2d7e:	fc 01       	movw	r30, r24
    2d80:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2d82:	00 00       	nop
    2d84:	80 ec       	ldi	r24, 0xC0	; 192
    2d86:	98 e0       	ldi	r25, 0x08	; 8
    2d88:	fc 01       	movw	r30, r24
    2d8a:	82 81       	ldd	r24, Z+2	; 0x02
    2d8c:	88 23       	and	r24, r24
    2d8e:	d4 f7       	brge	.-12     	; 0x2d84 <sampleCurrentChannel+0x4e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    2d90:	80 91 cb 50 	lds	r24, 0x50CB
    2d94:	88 2f       	mov	r24, r24
    2d96:	90 e0       	ldi	r25, 0x00	; 0
    2d98:	01 96       	adiw	r24, 0x01	; 1
    2d9a:	20 ec       	ldi	r18, 0xC0	; 192
    2d9c:	38 e0       	ldi	r19, 0x08	; 8
    2d9e:	f9 01       	movw	r30, r18
    2da0:	23 81       	ldd	r18, Z+3	; 0x03
    2da2:	8a 59       	subi	r24, 0x9A	; 154
    2da4:	9f 4a       	sbci	r25, 0xAF	; 175
    2da6:	fc 01       	movw	r30, r24
    2da8:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2daa:	80 ec       	ldi	r24, 0xC0	; 192
    2dac:	98 e0       	ldi	r25, 0x08	; 8
    2dae:	2a ea       	ldi	r18, 0xAA	; 170
    2db0:	fc 01       	movw	r30, r24
    2db2:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2db4:	00 00       	nop
    2db6:	80 ec       	ldi	r24, 0xC0	; 192
    2db8:	98 e0       	ldi	r25, 0x08	; 8
    2dba:	fc 01       	movw	r30, r24
    2dbc:	82 81       	ldd	r24, Z+2	; 0x02
    2dbe:	88 23       	and	r24, r24
    2dc0:	d4 f7       	brge	.-12     	; 0x2db6 <sampleCurrentChannel+0x80>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    2dc2:	80 91 cb 50 	lds	r24, 0x50CB
    2dc6:	88 2f       	mov	r24, r24
    2dc8:	90 e0       	ldi	r25, 0x00	; 0
    2dca:	02 96       	adiw	r24, 0x02	; 2
    2dcc:	20 ec       	ldi	r18, 0xC0	; 192
    2dce:	38 e0       	ldi	r19, 0x08	; 8
    2dd0:	f9 01       	movw	r30, r18
    2dd2:	23 81       	ldd	r18, Z+3	; 0x03
    2dd4:	8a 59       	subi	r24, 0x9A	; 154
    2dd6:	9f 4a       	sbci	r25, 0xAF	; 175
    2dd8:	fc 01       	movw	r30, r24
    2dda:	20 83       	st	Z, r18
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2ddc:	80 ea       	ldi	r24, 0xA0	; 160
    2dde:	96 e0       	ldi	r25, 0x06	; 6
    2de0:	22 e0       	ldi	r18, 0x02	; 2
    2de2:	fc 01       	movw	r30, r24
    2de4:	25 83       	std	Z+5, r18	; 0x05
	SPICount +=3;
    2de6:	80 91 cb 50 	lds	r24, 0x50CB
    2dea:	8d 5f       	subi	r24, 0xFD	; 253
    2dec:	80 93 cb 50 	sts	0x50CB, r24
}
    2df0:	df 91       	pop	r29
    2df2:	cf 91       	pop	r28
    2df4:	08 95       	ret

00002df6 <writeSE2FRAM>:

void writeSE2FRAM() {
    2df6:	cf 93       	push	r28
    2df8:	df 93       	push	r29
    2dfa:	cd b7       	in	r28, 0x3d	; 61
    2dfc:	de b7       	in	r29, 0x3e	; 62
    2dfe:	29 97       	sbiw	r28, 0x09	; 9
    2e00:	cd bf       	out	0x3d, r28	; 61
    2e02:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    2e04:	1a 82       	std	Y+2, r1	; 0x02
    2e06:	1b 82       	std	Y+3, r1	; 0x03
    2e08:	1c 82       	std	Y+4, r1	; 0x04
    2e0a:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
    2e0c:	80 91 73 50 	lds	r24, 0x5073
    2e10:	90 91 74 50 	lds	r25, 0x5074
    2e14:	01 96       	adiw	r24, 0x01	; 1
    2e16:	80 93 73 50 	sts	0x5073, r24
    2e1a:	90 93 74 50 	sts	0x5074, r25
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2e1e:	80 ec       	ldi	r24, 0xC0	; 192
    2e20:	98 e0       	ldi	r25, 0x08	; 8
    2e22:	20 ed       	ldi	r18, 0xD0	; 208
    2e24:	fc 01       	movw	r30, r24
    2e26:	20 83       	st	Z, r18
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2e28:	19 82       	std	Y+1, r1	; 0x01
    2e2a:	4f c0       	rjmp	.+158    	; 0x2eca <writeSE2FRAM+0xd4>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2e2c:	89 81       	ldd	r24, Y+1	; 0x01
    2e2e:	88 2f       	mov	r24, r24
    2e30:	90 e0       	ldi	r25, 0x00	; 0
    2e32:	8a 59       	subi	r24, 0x9A	; 154
    2e34:	9f 4a       	sbci	r25, 0xAF	; 175
    2e36:	fc 01       	movw	r30, r24
    2e38:	80 81       	ld	r24, Z
    2e3a:	88 23       	and	r24, r24
    2e3c:	3c f4       	brge	.+14     	; 0x2e4c <writeSE2FRAM+0x56>
    2e3e:	ce 01       	movw	r24, r28
    2e40:	06 96       	adiw	r24, 0x06	; 6
    2e42:	03 96       	adiw	r24, 0x03	; 3
    2e44:	2f ef       	ldi	r18, 0xFF	; 255
    2e46:	fc 01       	movw	r30, r24
    2e48:	20 83       	st	Z, r18
    2e4a:	05 c0       	rjmp	.+10     	; 0x2e56 <writeSE2FRAM+0x60>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    2e4c:	ce 01       	movw	r24, r28
    2e4e:	06 96       	adiw	r24, 0x06	; 6
    2e50:	03 96       	adiw	r24, 0x03	; 3
    2e52:	fc 01       	movw	r30, r24
    2e54:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2e56:	ce 01       	movw	r24, r28
    2e58:	06 96       	adiw	r24, 0x06	; 6
    2e5a:	02 96       	adiw	r24, 0x02	; 2
    2e5c:	29 81       	ldd	r18, Y+1	; 0x01
    2e5e:	22 2f       	mov	r18, r18
    2e60:	30 e0       	ldi	r19, 0x00	; 0
    2e62:	2a 59       	subi	r18, 0x9A	; 154
    2e64:	3f 4a       	sbci	r19, 0xAF	; 175
    2e66:	f9 01       	movw	r30, r18
    2e68:	20 81       	ld	r18, Z
    2e6a:	fc 01       	movw	r30, r24
    2e6c:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    2e6e:	ce 01       	movw	r24, r28
    2e70:	06 96       	adiw	r24, 0x06	; 6
    2e72:	01 96       	adiw	r24, 0x01	; 1
    2e74:	29 81       	ldd	r18, Y+1	; 0x01
    2e76:	22 2f       	mov	r18, r18
    2e78:	30 e0       	ldi	r19, 0x00	; 0
    2e7a:	2f 5f       	subi	r18, 0xFF	; 255
    2e7c:	3f 4f       	sbci	r19, 0xFF	; 255
    2e7e:	2a 59       	subi	r18, 0x9A	; 154
    2e80:	3f 4a       	sbci	r19, 0xAF	; 175
    2e82:	f9 01       	movw	r30, r18
    2e84:	20 81       	ld	r18, Z
    2e86:	fc 01       	movw	r30, r24
    2e88:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2e8a:	ce 01       	movw	r24, r28
    2e8c:	06 96       	adiw	r24, 0x06	; 6
    2e8e:	29 81       	ldd	r18, Y+1	; 0x01
    2e90:	22 2f       	mov	r18, r18
    2e92:	30 e0       	ldi	r19, 0x00	; 0
    2e94:	2e 5f       	subi	r18, 0xFE	; 254
    2e96:	3f 4f       	sbci	r19, 0xFF	; 255
    2e98:	2a 59       	subi	r18, 0x9A	; 154
    2e9a:	3f 4a       	sbci	r19, 0xAF	; 175
    2e9c:	f9 01       	movw	r30, r18
    2e9e:	20 81       	ld	r18, Z
    2ea0:	fc 01       	movw	r30, r24
    2ea2:	20 83       	st	Z, r18
		sum += currentSample;
    2ea4:	2a 81       	ldd	r18, Y+2	; 0x02
    2ea6:	3b 81       	ldd	r19, Y+3	; 0x03
    2ea8:	4c 81       	ldd	r20, Y+4	; 0x04
    2eaa:	5d 81       	ldd	r21, Y+5	; 0x05
    2eac:	8e 81       	ldd	r24, Y+6	; 0x06
    2eae:	9f 81       	ldd	r25, Y+7	; 0x07
    2eb0:	a8 85       	ldd	r26, Y+8	; 0x08
    2eb2:	b9 85       	ldd	r27, Y+9	; 0x09
    2eb4:	82 0f       	add	r24, r18
    2eb6:	93 1f       	adc	r25, r19
    2eb8:	a4 1f       	adc	r26, r20
    2eba:	b5 1f       	adc	r27, r21
    2ebc:	8a 83       	std	Y+2, r24	; 0x02
    2ebe:	9b 83       	std	Y+3, r25	; 0x03
    2ec0:	ac 83       	std	Y+4, r26	; 0x04
    2ec2:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2ec4:	89 81       	ldd	r24, Y+1	; 0x01
    2ec6:	8d 5f       	subi	r24, 0xFD	; 253
    2ec8:	89 83       	std	Y+1, r24	; 0x01
    2eca:	89 81       	ldd	r24, Y+1	; 0x01
    2ecc:	8c 30       	cpi	r24, 0x0C	; 12
    2ece:	08 f4       	brcc	.+2      	; 0x2ed2 <writeSE2FRAM+0xdc>
    2ed0:	ad cf       	rjmp	.-166    	; 0x2e2c <writeSE2FRAM+0x36>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    2ed2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ed4:	9b 81       	ldd	r25, Y+3	; 0x03
    2ed6:	ac 81       	ldd	r26, Y+4	; 0x04
    2ed8:	bd 81       	ldd	r27, Y+5	; 0x05
    2eda:	24 e0       	ldi	r18, 0x04	; 4
    2edc:	30 e0       	ldi	r19, 0x00	; 0
    2ede:	40 e0       	ldi	r20, 0x00	; 0
    2ee0:	50 e0       	ldi	r21, 0x00	; 0
    2ee2:	bc 01       	movw	r22, r24
    2ee4:	cd 01       	movw	r24, r26
    2ee6:	0e 94 fe 5e 	call	0xbdfc	; 0xbdfc <__divmodsi4>
    2eea:	da 01       	movw	r26, r20
    2eec:	c9 01       	movw	r24, r18
    2eee:	8a 83       	std	Y+2, r24	; 0x02
    2ef0:	9b 83       	std	Y+3, r25	; 0x03
    2ef2:	ac 83       	std	Y+4, r26	; 0x04
    2ef4:	bd 83       	std	Y+5, r27	; 0x05
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2ef6:	ce 01       	movw	r24, r28
    2ef8:	02 96       	adiw	r24, 0x02	; 2
    2efa:	fc 01       	movw	r30, r24
    2efc:	80 81       	ld	r24, Z
    2efe:	80 93 68 50 	sts	0x5068, r24
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2f02:	ce 01       	movw	r24, r28
    2f04:	02 96       	adiw	r24, 0x02	; 2
    2f06:	fc 01       	movw	r30, r24
    2f08:	81 81       	ldd	r24, Z+1	; 0x01
    2f0a:	80 93 67 50 	sts	0x5067, r24
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    2f0e:	ce 01       	movw	r24, r28
    2f10:	02 96       	adiw	r24, 0x02	; 2
    2f12:	fc 01       	movw	r30, r24
    2f14:	82 81       	ldd	r24, Z+2	; 0x02
    2f16:	80 93 66 50 	sts	0x5066, r24


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2f1a:	80 e4       	ldi	r24, 0x40	; 64
    2f1c:	96 e0       	ldi	r25, 0x06	; 6
    2f1e:	20 e1       	ldi	r18, 0x10	; 16
    2f20:	fc 01       	movw	r30, r24
    2f22:	26 83       	std	Z+6, r18	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2f24:	80 e2       	ldi	r24, 0x20	; 32
    2f26:	96 e0       	ldi	r25, 0x06	; 6
    2f28:	28 e0       	ldi	r18, 0x08	; 8
    2f2a:	fc 01       	movw	r30, r24
    2f2c:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2f2e:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2f30:	80 ec       	ldi	r24, 0xC0	; 192
    2f32:	98 e0       	ldi	r25, 0x08	; 8
    2f34:	26 e0       	ldi	r18, 0x06	; 6
    2f36:	fc 01       	movw	r30, r24
    2f38:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2f3a:	00 00       	nop
    2f3c:	80 ec       	ldi	r24, 0xC0	; 192
    2f3e:	98 e0       	ldi	r25, 0x08	; 8
    2f40:	fc 01       	movw	r30, r24
    2f42:	82 81       	ldd	r24, Z+2	; 0x02
    2f44:	88 23       	and	r24, r24
    2f46:	d4 f7       	brge	.-12     	; 0x2f3c <writeSE2FRAM+0x146>
	SPIBuffer[12] = SPIC.DATA;
    2f48:	80 ec       	ldi	r24, 0xC0	; 192
    2f4a:	98 e0       	ldi	r25, 0x08	; 8
    2f4c:	fc 01       	movw	r30, r24
    2f4e:	83 81       	ldd	r24, Z+3	; 0x03
    2f50:	80 93 72 50 	sts	0x5072, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    2f54:	80 e2       	ldi	r24, 0x20	; 32
    2f56:	96 e0       	ldi	r25, 0x06	; 6
    2f58:	28 e0       	ldi	r18, 0x08	; 8
    2f5a:	fc 01       	movw	r30, r24
    2f5c:	25 83       	std	Z+5, r18	; 0x05
	nop(); // time for CS_FRAM to accept high signal
    2f5e:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2f60:	80 e2       	ldi	r24, 0x20	; 32
    2f62:	96 e0       	ldi	r25, 0x06	; 6
    2f64:	28 e0       	ldi	r18, 0x08	; 8
    2f66:	fc 01       	movw	r30, r24
    2f68:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2f6a:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2f6c:	80 ec       	ldi	r24, 0xC0	; 192
    2f6e:	98 e0       	ldi	r25, 0x08	; 8
    2f70:	22 e0       	ldi	r18, 0x02	; 2
    2f72:	fc 01       	movw	r30, r24
    2f74:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2f76:	00 00       	nop
    2f78:	80 ec       	ldi	r24, 0xC0	; 192
    2f7a:	98 e0       	ldi	r25, 0x08	; 8
    2f7c:	fc 01       	movw	r30, r24
    2f7e:	82 81       	ldd	r24, Z+2	; 0x02
    2f80:	88 23       	and	r24, r24
    2f82:	d4 f7       	brge	.-12     	; 0x2f78 <writeSE2FRAM+0x182>
	SPIBuffer[12] = SPIC.DATA;
    2f84:	80 ec       	ldi	r24, 0xC0	; 192
    2f86:	98 e0       	ldi	r25, 0x08	; 8
    2f88:	fc 01       	movw	r30, r24
    2f8a:	83 81       	ldd	r24, Z+3	; 0x03
    2f8c:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2f90:	80 ec       	ldi	r24, 0xC0	; 192
    2f92:	98 e0       	ldi	r25, 0x08	; 8
    2f94:	20 91 59 40 	lds	r18, 0x4059
    2f98:	fc 01       	movw	r30, r24
    2f9a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2f9c:	00 00       	nop
    2f9e:	80 ec       	ldi	r24, 0xC0	; 192
    2fa0:	98 e0       	ldi	r25, 0x08	; 8
    2fa2:	fc 01       	movw	r30, r24
    2fa4:	82 81       	ldd	r24, Z+2	; 0x02
    2fa6:	88 23       	and	r24, r24
    2fa8:	d4 f7       	brge	.-12     	; 0x2f9e <writeSE2FRAM+0x1a8>
	SPIBuffer[12] = SPIC.DATA;
    2faa:	80 ec       	ldi	r24, 0xC0	; 192
    2fac:	98 e0       	ldi	r25, 0x08	; 8
    2fae:	fc 01       	movw	r30, r24
    2fb0:	83 81       	ldd	r24, Z+3	; 0x03
    2fb2:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2fb6:	80 ec       	ldi	r24, 0xC0	; 192
    2fb8:	98 e0       	ldi	r25, 0x08	; 8
    2fba:	28 e5       	ldi	r18, 0x58	; 88
    2fbc:	30 e4       	ldi	r19, 0x40	; 64
    2fbe:	f9 01       	movw	r30, r18
    2fc0:	20 81       	ld	r18, Z
    2fc2:	fc 01       	movw	r30, r24
    2fc4:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2fc6:	00 00       	nop
    2fc8:	80 ec       	ldi	r24, 0xC0	; 192
    2fca:	98 e0       	ldi	r25, 0x08	; 8
    2fcc:	fc 01       	movw	r30, r24
    2fce:	82 81       	ldd	r24, Z+2	; 0x02
    2fd0:	88 23       	and	r24, r24
    2fd2:	d4 f7       	brge	.-12     	; 0x2fc8 <writeSE2FRAM+0x1d2>
	SPIBuffer[12] = SPIC.DATA;
    2fd4:	80 ec       	ldi	r24, 0xC0	; 192
    2fd6:	98 e0       	ldi	r25, 0x08	; 8
    2fd8:	fc 01       	movw	r30, r24
    2fda:	83 81       	ldd	r24, Z+3	; 0x03
    2fdc:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = SPIBuffer[0];
    2fe0:	80 ec       	ldi	r24, 0xC0	; 192
    2fe2:	98 e0       	ldi	r25, 0x08	; 8
    2fe4:	20 91 66 50 	lds	r18, 0x5066
    2fe8:	fc 01       	movw	r30, r24
    2fea:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2fec:	00 00       	nop
    2fee:	80 ec       	ldi	r24, 0xC0	; 192
    2ff0:	98 e0       	ldi	r25, 0x08	; 8
    2ff2:	fc 01       	movw	r30, r24
    2ff4:	82 81       	ldd	r24, Z+2	; 0x02
    2ff6:	88 23       	and	r24, r24
    2ff8:	d4 f7       	brge	.-12     	; 0x2fee <writeSE2FRAM+0x1f8>
	SPIBuffer[12] = SPIC.DATA;
    2ffa:	80 ec       	ldi	r24, 0xC0	; 192
    2ffc:	98 e0       	ldi	r25, 0x08	; 8
    2ffe:	fc 01       	movw	r30, r24
    3000:	83 81       	ldd	r24, Z+3	; 0x03
    3002:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = SPIBuffer[1];
    3006:	80 ec       	ldi	r24, 0xC0	; 192
    3008:	98 e0       	ldi	r25, 0x08	; 8
    300a:	20 91 67 50 	lds	r18, 0x5067
    300e:	fc 01       	movw	r30, r24
    3010:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3012:	00 00       	nop
    3014:	80 ec       	ldi	r24, 0xC0	; 192
    3016:	98 e0       	ldi	r25, 0x08	; 8
    3018:	fc 01       	movw	r30, r24
    301a:	82 81       	ldd	r24, Z+2	; 0x02
    301c:	88 23       	and	r24, r24
    301e:	d4 f7       	brge	.-12     	; 0x3014 <writeSE2FRAM+0x21e>
	SPIBuffer[12] = SPIC.DATA;
    3020:	80 ec       	ldi	r24, 0xC0	; 192
    3022:	98 e0       	ldi	r25, 0x08	; 8
    3024:	fc 01       	movw	r30, r24
    3026:	83 81       	ldd	r24, Z+3	; 0x03
    3028:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = SPIBuffer[2];
    302c:	80 ec       	ldi	r24, 0xC0	; 192
    302e:	98 e0       	ldi	r25, 0x08	; 8
    3030:	20 91 68 50 	lds	r18, 0x5068
    3034:	fc 01       	movw	r30, r24
    3036:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3038:	00 00       	nop
    303a:	80 ec       	ldi	r24, 0xC0	; 192
    303c:	98 e0       	ldi	r25, 0x08	; 8
    303e:	fc 01       	movw	r30, r24
    3040:	82 81       	ldd	r24, Z+2	; 0x02
    3042:	88 23       	and	r24, r24
    3044:	d4 f7       	brge	.-12     	; 0x303a <writeSE2FRAM+0x244>
	SPIBuffer[12] = SPIC.DATA;
    3046:	80 ec       	ldi	r24, 0xC0	; 192
    3048:	98 e0       	ldi	r25, 0x08	; 8
    304a:	fc 01       	movw	r30, r24
    304c:	83 81       	ldd	r24, Z+3	; 0x03
    304e:	80 93 72 50 	sts	0x5072, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    3052:	80 e2       	ldi	r24, 0x20	; 32
    3054:	96 e0       	ldi	r25, 0x06	; 6
    3056:	28 e0       	ldi	r18, 0x08	; 8
    3058:	fc 01       	movw	r30, r24
    305a:	25 83       	std	Z+5, r18	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    305c:	80 e4       	ldi	r24, 0x40	; 64
    305e:	96 e0       	ldi	r25, 0x06	; 6
    3060:	20 e1       	ldi	r18, 0x10	; 16
    3062:	fc 01       	movw	r30, r24
    3064:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    3066:	80 ec       	ldi	r24, 0xC0	; 192
    3068:	98 e0       	ldi	r25, 0x08	; 8
    306a:	24 e5       	ldi	r18, 0x54	; 84
    306c:	fc 01       	movw	r30, r24
    306e:	20 83       	st	Z, r18
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    3070:	80 e4       	ldi	r24, 0x40	; 64
    3072:	96 e0       	ldi	r25, 0x06	; 6
    3074:	20 e1       	ldi	r18, 0x10	; 16
    3076:	fc 01       	movw	r30, r24
    3078:	26 83       	std	Z+6, r18	; 0x06
	
	FRAMAddress +=3;
    307a:	80 91 58 40 	lds	r24, 0x4058
    307e:	90 91 59 40 	lds	r25, 0x4059
    3082:	03 96       	adiw	r24, 0x03	; 3
    3084:	80 93 58 40 	sts	0x4058, r24
    3088:	90 93 59 40 	sts	0x4059, r25
	checksumADC[0] += SPIBuffer[0];
    308c:	90 91 3a 21 	lds	r25, 0x213A
    3090:	80 91 66 50 	lds	r24, 0x5066
    3094:	89 0f       	add	r24, r25
    3096:	80 93 3a 21 	sts	0x213A, r24
	checksumADC[1] += SPIBuffer[1];
    309a:	90 91 3b 21 	lds	r25, 0x213B
    309e:	80 91 67 50 	lds	r24, 0x5067
    30a2:	89 0f       	add	r24, r25
    30a4:	80 93 3b 21 	sts	0x213B, r24
	checksumADC[2] += SPIBuffer[2];
    30a8:	90 91 3c 21 	lds	r25, 0x213C
    30ac:	80 91 68 50 	lds	r24, 0x5068
    30b0:	89 0f       	add	r24, r25
    30b2:	80 93 3c 21 	sts	0x213C, r24
}
    30b6:	29 96       	adiw	r28, 0x09	; 9
    30b8:	cd bf       	out	0x3d, r28	; 61
    30ba:	de bf       	out	0x3e, r29	; 62
    30bc:	df 91       	pop	r29
    30be:	cf 91       	pop	r28
    30c0:	08 95       	ret

000030c2 <calcChecksumFRAM>:


void calcChecksumFRAM() {
    30c2:	2f 92       	push	r2
    30c4:	3f 92       	push	r3
    30c6:	4f 92       	push	r4
    30c8:	5f 92       	push	r5
    30ca:	6f 92       	push	r6
    30cc:	7f 92       	push	r7
    30ce:	8f 92       	push	r8
    30d0:	9f 92       	push	r9
    30d2:	af 92       	push	r10
    30d4:	bf 92       	push	r11
    30d6:	cf 92       	push	r12
    30d8:	df 92       	push	r13
    30da:	ef 92       	push	r14
    30dc:	ff 92       	push	r15
    30de:	0f 93       	push	r16
    30e0:	1f 93       	push	r17
    30e2:	cf 93       	push	r28
    30e4:	df 93       	push	r29
    30e6:	00 d0       	rcall	.+0      	; 0x30e8 <calcChecksumFRAM+0x26>
    30e8:	0f 92       	push	r0
    30ea:	cd b7       	in	r28, 0x3d	; 61
    30ec:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    30ee:	aa 24       	eor	r10, r10
    30f0:	bb 24       	eor	r11, r11
    30f2:	cc 24       	eor	r12, r12
    30f4:	dd 24       	eor	r13, r13
    30f6:	ee 24       	eor	r14, r14
    30f8:	ff 24       	eor	r15, r15
    30fa:	00 e0       	ldi	r16, 0x00	; 0
    30fc:	10 e0       	ldi	r17, 0x00	; 0
    30fe:	a0 92 98 50 	sts	0x5098, r10
    3102:	b0 92 99 50 	sts	0x5099, r11
    3106:	c0 92 9a 50 	sts	0x509A, r12
    310a:	d0 92 9b 50 	sts	0x509B, r13
    310e:	e0 92 9c 50 	sts	0x509C, r14
    3112:	f0 92 9d 50 	sts	0x509D, r15
    3116:	00 93 9e 50 	sts	0x509E, r16
    311a:	10 93 9f 50 	sts	0x509F, r17
    311e:	2a 2d       	mov	r18, r10
    3120:	3b 2d       	mov	r19, r11
    3122:	4c 2d       	mov	r20, r12
    3124:	5d 2d       	mov	r21, r13
    3126:	6e 2d       	mov	r22, r14
    3128:	7f 2d       	mov	r23, r15
    312a:	80 2f       	mov	r24, r16
    312c:	91 2f       	mov	r25, r17
    312e:	20 93 90 50 	sts	0x5090, r18
    3132:	30 93 91 50 	sts	0x5091, r19
    3136:	40 93 92 50 	sts	0x5092, r20
    313a:	50 93 93 50 	sts	0x5093, r21
    313e:	60 93 94 50 	sts	0x5094, r22
    3142:	70 93 95 50 	sts	0x5095, r23
    3146:	80 93 96 50 	sts	0x5096, r24
    314a:	90 93 97 50 	sts	0x5097, r25
    314e:	20 93 88 50 	sts	0x5088, r18
    3152:	30 93 89 50 	sts	0x5089, r19
    3156:	40 93 8a 50 	sts	0x508A, r20
    315a:	50 93 8b 50 	sts	0x508B, r21
    315e:	60 93 8c 50 	sts	0x508C, r22
    3162:	70 93 8d 50 	sts	0x508D, r23
    3166:	80 93 8e 50 	sts	0x508E, r24
    316a:	90 93 8f 50 	sts	0x508F, r25
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    316e:	80 e0       	ldi	r24, 0x00	; 0
    3170:	80 93 3f 21 	sts	0x213F, r24
    3174:	80 93 3e 21 	sts	0x213E, r24
    3178:	80 93 3d 21 	sts	0x213D, r24
	FRAMAddress = FR_BASEADD;
    317c:	10 92 58 40 	sts	0x4058, r1
    3180:	10 92 59 40 	sts	0x4059, r1
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    3184:	19 82       	std	Y+1, r1	; 0x01
    3186:	1a 82       	std	Y+2, r1	; 0x02
    3188:	88 c2       	rjmp	.+1296   	; 0x369a <calcChecksumFRAM+0x5d8>
		readFRAM(FR_READ_BUFFER_SIZE);
    318a:	81 e7       	ldi	r24, 0x71	; 113
    318c:	9c e1       	ldi	r25, 0x1C	; 28
    318e:	0e 94 5c 3a 	call	0x74b8	; 0x74b8 <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    3192:	80 91 58 40 	lds	r24, 0x4058
    3196:	90 91 59 40 	lds	r25, 0x4059
    319a:	8f 58       	subi	r24, 0x8F	; 143
    319c:	93 4e       	sbci	r25, 0xE3	; 227
    319e:	80 93 58 40 	sts	0x4058, r24
    31a2:	90 93 59 40 	sts	0x4059, r25
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    31a6:	1b 82       	std	Y+3, r1	; 0x03
    31a8:	1c 82       	std	Y+4, r1	; 0x04
    31aa:	6b c2       	rjmp	.+1238   	; 0x3682 <calcChecksumFRAM+0x5c0>
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    31ac:	8b 81       	ldd	r24, Y+3	; 0x03
    31ae:	9c 81       	ldd	r25, Y+4	; 0x04
    31b0:	23 e0       	ldi	r18, 0x03	; 3
    31b2:	30 e0       	ldi	r19, 0x00	; 0
    31b4:	b9 01       	movw	r22, r18
    31b6:	0e 94 b5 5e 	call	0xbd6a	; 0xbd6a <__udivmodhi4>
    31ba:	9c 01       	movw	r18, r24
    31bc:	23 5c       	subi	r18, 0xC3	; 195
    31be:	3e 4d       	sbci	r19, 0xDE	; 222
    31c0:	f9 01       	movw	r30, r18
    31c2:	40 81       	ld	r20, Z
    31c4:	2b 81       	ldd	r18, Y+3	; 0x03
    31c6:	3c 81       	ldd	r19, Y+4	; 0x04
    31c8:	20 52       	subi	r18, 0x20	; 32
    31ca:	3c 4d       	sbci	r19, 0xDC	; 220
    31cc:	f9 01       	movw	r30, r18
    31ce:	20 81       	ld	r18, Z
    31d0:	24 0f       	add	r18, r20
    31d2:	83 5c       	subi	r24, 0xC3	; 195
    31d4:	9e 4d       	sbci	r25, 0xDE	; 222
    31d6:	fc 01       	movw	r30, r24
    31d8:	20 83       	st	Z, r18
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    31da:	8b 81       	ldd	r24, Y+3	; 0x03
    31dc:	9c 81       	ldd	r25, Y+4	; 0x04
    31de:	23 e0       	ldi	r18, 0x03	; 3
    31e0:	30 e0       	ldi	r19, 0x00	; 0
    31e2:	b9 01       	movw	r22, r18
    31e4:	0e 94 b5 5e 	call	0xbd6a	; 0xbd6a <__udivmodhi4>
    31e8:	00 97       	sbiw	r24, 0x00	; 0
    31ea:	09 f0       	breq	.+2      	; 0x31ee <calcChecksumFRAM+0x12c>
    31ec:	44 c0       	rjmp	.+136    	; 0x3276 <calcChecksumFRAM+0x1b4>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    31ee:	8b 81       	ldd	r24, Y+3	; 0x03
    31f0:	9c 81       	ldd	r25, Y+4	; 0x04
    31f2:	80 52       	subi	r24, 0x20	; 32
    31f4:	9c 4d       	sbci	r25, 0xDC	; 220
    31f6:	fc 01       	movw	r30, r24
    31f8:	80 81       	ld	r24, Z
    31fa:	88 23       	and	r24, r24
    31fc:	d4 f4       	brge	.+52     	; 0x3232 <calcChecksumFRAM+0x170>
    31fe:	80 91 64 50 	lds	r24, 0x5064
    3202:	90 91 65 50 	lds	r25, 0x5065
    3206:	fc 01       	movw	r30, r24
    3208:	10 82       	st	Z, r1
    320a:	fc 01       	movw	r30, r24
    320c:	11 82       	std	Z+1, r1	; 0x01
    320e:	fc 01       	movw	r30, r24
    3210:	12 82       	std	Z+2, r1	; 0x02
    3212:	2f ef       	ldi	r18, 0xFF	; 255
    3214:	fc 01       	movw	r30, r24
    3216:	23 83       	std	Z+3, r18	; 0x03
    3218:	2f ef       	ldi	r18, 0xFF	; 255
    321a:	fc 01       	movw	r30, r24
    321c:	24 83       	std	Z+4, r18	; 0x04
    321e:	2f ef       	ldi	r18, 0xFF	; 255
    3220:	fc 01       	movw	r30, r24
    3222:	25 83       	std	Z+5, r18	; 0x05
    3224:	2f ef       	ldi	r18, 0xFF	; 255
    3226:	fc 01       	movw	r30, r24
    3228:	26 83       	std	Z+6, r18	; 0x06
    322a:	2f ef       	ldi	r18, 0xFF	; 255
    322c:	fc 01       	movw	r30, r24
    322e:	27 83       	std	Z+7, r18	; 0x07
    3230:	14 c0       	rjmp	.+40     	; 0x325a <calcChecksumFRAM+0x198>
				else *temp64 = 0x0000000000000000;
    3232:	80 91 64 50 	lds	r24, 0x5064
    3236:	90 91 65 50 	lds	r25, 0x5065
    323a:	fc 01       	movw	r30, r24
    323c:	10 82       	st	Z, r1
    323e:	fc 01       	movw	r30, r24
    3240:	11 82       	std	Z+1, r1	; 0x01
    3242:	fc 01       	movw	r30, r24
    3244:	12 82       	std	Z+2, r1	; 0x02
    3246:	fc 01       	movw	r30, r24
    3248:	13 82       	std	Z+3, r1	; 0x03
    324a:	fc 01       	movw	r30, r24
    324c:	14 82       	std	Z+4, r1	; 0x04
    324e:	fc 01       	movw	r30, r24
    3250:	15 82       	std	Z+5, r1	; 0x05
    3252:	fc 01       	movw	r30, r24
    3254:	16 82       	std	Z+6, r1	; 0x06
    3256:	fc 01       	movw	r30, r24
    3258:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    325a:	80 91 64 50 	lds	r24, 0x5064
    325e:	90 91 65 50 	lds	r25, 0x5065
    3262:	02 96       	adiw	r24, 0x02	; 2
    3264:	2b 81       	ldd	r18, Y+3	; 0x03
    3266:	3c 81       	ldd	r19, Y+4	; 0x04
    3268:	20 52       	subi	r18, 0x20	; 32
    326a:	3c 4d       	sbci	r19, 0xDC	; 220
    326c:	f9 01       	movw	r30, r18
    326e:	20 81       	ld	r18, Z
    3270:	fc 01       	movw	r30, r24
    3272:	20 83       	st	Z, r18
    3274:	24 c0       	rjmp	.+72     	; 0x32be <calcChecksumFRAM+0x1fc>
			} else if(k%3 == 1) {
    3276:	8b 81       	ldd	r24, Y+3	; 0x03
    3278:	9c 81       	ldd	r25, Y+4	; 0x04
    327a:	23 e0       	ldi	r18, 0x03	; 3
    327c:	30 e0       	ldi	r19, 0x00	; 0
    327e:	b9 01       	movw	r22, r18
    3280:	0e 94 b5 5e 	call	0xbd6a	; 0xbd6a <__udivmodhi4>
    3284:	81 30       	cpi	r24, 0x01	; 1
    3286:	91 05       	cpc	r25, r1
    3288:	71 f4       	brne	.+28     	; 0x32a6 <calcChecksumFRAM+0x1e4>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    328a:	80 91 64 50 	lds	r24, 0x5064
    328e:	90 91 65 50 	lds	r25, 0x5065
    3292:	01 96       	adiw	r24, 0x01	; 1
    3294:	2b 81       	ldd	r18, Y+3	; 0x03
    3296:	3c 81       	ldd	r19, Y+4	; 0x04
    3298:	20 52       	subi	r18, 0x20	; 32
    329a:	3c 4d       	sbci	r19, 0xDC	; 220
    329c:	f9 01       	movw	r30, r18
    329e:	20 81       	ld	r18, Z
    32a0:	fc 01       	movw	r30, r24
    32a2:	20 83       	st	Z, r18
    32a4:	0c c0       	rjmp	.+24     	; 0x32be <calcChecksumFRAM+0x1fc>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    32a6:	80 91 64 50 	lds	r24, 0x5064
    32aa:	90 91 65 50 	lds	r25, 0x5065
    32ae:	2b 81       	ldd	r18, Y+3	; 0x03
    32b0:	3c 81       	ldd	r19, Y+4	; 0x04
    32b2:	20 52       	subi	r18, 0x20	; 32
    32b4:	3c 4d       	sbci	r19, 0xDC	; 220
    32b6:	f9 01       	movw	r30, r18
    32b8:	20 81       	ld	r18, Z
    32ba:	fc 01       	movw	r30, r24
    32bc:	20 83       	st	Z, r18
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    32be:	8b 81       	ldd	r24, Y+3	; 0x03
    32c0:	9c 81       	ldd	r25, Y+4	; 0x04
    32c2:	29 e0       	ldi	r18, 0x09	; 9
    32c4:	30 e0       	ldi	r19, 0x00	; 0
    32c6:	b9 01       	movw	r22, r18
    32c8:	0e 94 b5 5e 	call	0xbd6a	; 0xbd6a <__udivmodhi4>
    32cc:	82 30       	cpi	r24, 0x02	; 2
    32ce:	91 05       	cpc	r25, r1
    32d0:	09 f0       	breq	.+2      	; 0x32d4 <calcChecksumFRAM+0x212>
    32d2:	94 c0       	rjmp	.+296    	; 0x33fc <calcChecksumFRAM+0x33a>
    32d4:	a0 90 88 50 	lds	r10, 0x5088
    32d8:	b0 90 89 50 	lds	r11, 0x5089
    32dc:	c0 90 8a 50 	lds	r12, 0x508A
    32e0:	d0 90 8b 50 	lds	r13, 0x508B
    32e4:	e0 90 8c 50 	lds	r14, 0x508C
    32e8:	f0 90 8d 50 	lds	r15, 0x508D
    32ec:	00 91 8e 50 	lds	r16, 0x508E
    32f0:	10 91 8f 50 	lds	r17, 0x508F
    32f4:	80 91 64 50 	lds	r24, 0x5064
    32f8:	90 91 65 50 	lds	r25, 0x5065
    32fc:	fc 01       	movw	r30, r24
    32fe:	20 80       	ld	r2, Z
    3300:	fc 01       	movw	r30, r24
    3302:	31 80       	ldd	r3, Z+1	; 0x01
    3304:	fc 01       	movw	r30, r24
    3306:	42 80       	ldd	r4, Z+2	; 0x02
    3308:	fc 01       	movw	r30, r24
    330a:	53 80       	ldd	r5, Z+3	; 0x03
    330c:	fc 01       	movw	r30, r24
    330e:	64 80       	ldd	r6, Z+4	; 0x04
    3310:	fc 01       	movw	r30, r24
    3312:	75 80       	ldd	r7, Z+5	; 0x05
    3314:	fc 01       	movw	r30, r24
    3316:	86 80       	ldd	r8, Z+6	; 0x06
    3318:	fc 01       	movw	r30, r24
    331a:	97 80       	ldd	r9, Z+7	; 0x07
    331c:	2a 2d       	mov	r18, r10
    331e:	22 0d       	add	r18, r2
    3320:	e1 e0       	ldi	r30, 0x01	; 1
    3322:	2a 15       	cp	r18, r10
    3324:	08 f0       	brcs	.+2      	; 0x3328 <calcChecksumFRAM+0x266>
    3326:	e0 e0       	ldi	r30, 0x00	; 0
    3328:	3b 2d       	mov	r19, r11
    332a:	33 0d       	add	r19, r3
    332c:	f1 e0       	ldi	r31, 0x01	; 1
    332e:	3b 15       	cp	r19, r11
    3330:	08 f0       	brcs	.+2      	; 0x3334 <calcChecksumFRAM+0x272>
    3332:	f0 e0       	ldi	r31, 0x00	; 0
    3334:	e3 0f       	add	r30, r19
    3336:	a1 e0       	ldi	r26, 0x01	; 1
    3338:	e3 17       	cp	r30, r19
    333a:	08 f0       	brcs	.+2      	; 0x333e <calcChecksumFRAM+0x27c>
    333c:	a0 e0       	ldi	r26, 0x00	; 0
    333e:	fa 2b       	or	r31, r26
    3340:	3e 2f       	mov	r19, r30
    3342:	4c 2d       	mov	r20, r12
    3344:	44 0d       	add	r20, r4
    3346:	e1 e0       	ldi	r30, 0x01	; 1
    3348:	4c 15       	cp	r20, r12
    334a:	08 f0       	brcs	.+2      	; 0x334e <calcChecksumFRAM+0x28c>
    334c:	e0 e0       	ldi	r30, 0x00	; 0
    334e:	f4 0f       	add	r31, r20
    3350:	a1 e0       	ldi	r26, 0x01	; 1
    3352:	f4 17       	cp	r31, r20
    3354:	08 f0       	brcs	.+2      	; 0x3358 <calcChecksumFRAM+0x296>
    3356:	a0 e0       	ldi	r26, 0x00	; 0
    3358:	ea 2b       	or	r30, r26
    335a:	4f 2f       	mov	r20, r31
    335c:	5d 2d       	mov	r21, r13
    335e:	55 0d       	add	r21, r5
    3360:	f1 e0       	ldi	r31, 0x01	; 1
    3362:	5d 15       	cp	r21, r13
    3364:	08 f0       	brcs	.+2      	; 0x3368 <calcChecksumFRAM+0x2a6>
    3366:	f0 e0       	ldi	r31, 0x00	; 0
    3368:	e5 0f       	add	r30, r21
    336a:	a1 e0       	ldi	r26, 0x01	; 1
    336c:	e5 17       	cp	r30, r21
    336e:	08 f0       	brcs	.+2      	; 0x3372 <calcChecksumFRAM+0x2b0>
    3370:	a0 e0       	ldi	r26, 0x00	; 0
    3372:	fa 2b       	or	r31, r26
    3374:	5e 2f       	mov	r21, r30
    3376:	6e 2d       	mov	r22, r14
    3378:	66 0d       	add	r22, r6
    337a:	e1 e0       	ldi	r30, 0x01	; 1
    337c:	6e 15       	cp	r22, r14
    337e:	08 f0       	brcs	.+2      	; 0x3382 <calcChecksumFRAM+0x2c0>
    3380:	e0 e0       	ldi	r30, 0x00	; 0
    3382:	f6 0f       	add	r31, r22
    3384:	a1 e0       	ldi	r26, 0x01	; 1
    3386:	f6 17       	cp	r31, r22
    3388:	08 f0       	brcs	.+2      	; 0x338c <calcChecksumFRAM+0x2ca>
    338a:	a0 e0       	ldi	r26, 0x00	; 0
    338c:	ea 2b       	or	r30, r26
    338e:	6f 2f       	mov	r22, r31
    3390:	7f 2d       	mov	r23, r15
    3392:	77 0d       	add	r23, r7
    3394:	f1 e0       	ldi	r31, 0x01	; 1
    3396:	7f 15       	cp	r23, r15
    3398:	08 f0       	brcs	.+2      	; 0x339c <calcChecksumFRAM+0x2da>
    339a:	f0 e0       	ldi	r31, 0x00	; 0
    339c:	e7 0f       	add	r30, r23
    339e:	a1 e0       	ldi	r26, 0x01	; 1
    33a0:	e7 17       	cp	r30, r23
    33a2:	08 f0       	brcs	.+2      	; 0x33a6 <calcChecksumFRAM+0x2e4>
    33a4:	a0 e0       	ldi	r26, 0x00	; 0
    33a6:	fa 2b       	or	r31, r26
    33a8:	7e 2f       	mov	r23, r30
    33aa:	80 2f       	mov	r24, r16
    33ac:	88 0d       	add	r24, r8
    33ae:	e1 e0       	ldi	r30, 0x01	; 1
    33b0:	80 17       	cp	r24, r16
    33b2:	08 f0       	brcs	.+2      	; 0x33b6 <calcChecksumFRAM+0x2f4>
    33b4:	e0 e0       	ldi	r30, 0x00	; 0
    33b6:	f8 0f       	add	r31, r24
    33b8:	a1 e0       	ldi	r26, 0x01	; 1
    33ba:	f8 17       	cp	r31, r24
    33bc:	08 f0       	brcs	.+2      	; 0x33c0 <calcChecksumFRAM+0x2fe>
    33be:	a0 e0       	ldi	r26, 0x00	; 0
    33c0:	ea 2b       	or	r30, r26
    33c2:	8f 2f       	mov	r24, r31
    33c4:	91 2f       	mov	r25, r17
    33c6:	99 0d       	add	r25, r9
    33c8:	e9 0f       	add	r30, r25
    33ca:	9e 2f       	mov	r25, r30
    33cc:	a2 2e       	mov	r10, r18
    33ce:	b3 2e       	mov	r11, r19
    33d0:	c4 2e       	mov	r12, r20
    33d2:	d5 2e       	mov	r13, r21
    33d4:	e6 2e       	mov	r14, r22
    33d6:	f7 2e       	mov	r15, r23
    33d8:	08 2f       	mov	r16, r24
    33da:	19 2f       	mov	r17, r25
    33dc:	a0 92 88 50 	sts	0x5088, r10
    33e0:	b0 92 89 50 	sts	0x5089, r11
    33e4:	c0 92 8a 50 	sts	0x508A, r12
    33e8:	d0 92 8b 50 	sts	0x508B, r13
    33ec:	e0 92 8c 50 	sts	0x508C, r14
    33f0:	f0 92 8d 50 	sts	0x508D, r15
    33f4:	00 93 8e 50 	sts	0x508E, r16
    33f8:	10 93 8f 50 	sts	0x508F, r17
			if(k%9 == 5) sumFRAM[1] += *temp64;
    33fc:	8b 81       	ldd	r24, Y+3	; 0x03
    33fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3400:	29 e0       	ldi	r18, 0x09	; 9
    3402:	30 e0       	ldi	r19, 0x00	; 0
    3404:	b9 01       	movw	r22, r18
    3406:	0e 94 b5 5e 	call	0xbd6a	; 0xbd6a <__udivmodhi4>
    340a:	85 30       	cpi	r24, 0x05	; 5
    340c:	91 05       	cpc	r25, r1
    340e:	09 f0       	breq	.+2      	; 0x3412 <calcChecksumFRAM+0x350>
    3410:	94 c0       	rjmp	.+296    	; 0x353a <calcChecksumFRAM+0x478>
    3412:	a0 90 90 50 	lds	r10, 0x5090
    3416:	b0 90 91 50 	lds	r11, 0x5091
    341a:	c0 90 92 50 	lds	r12, 0x5092
    341e:	d0 90 93 50 	lds	r13, 0x5093
    3422:	e0 90 94 50 	lds	r14, 0x5094
    3426:	f0 90 95 50 	lds	r15, 0x5095
    342a:	00 91 96 50 	lds	r16, 0x5096
    342e:	10 91 97 50 	lds	r17, 0x5097
    3432:	80 91 64 50 	lds	r24, 0x5064
    3436:	90 91 65 50 	lds	r25, 0x5065
    343a:	fc 01       	movw	r30, r24
    343c:	20 80       	ld	r2, Z
    343e:	fc 01       	movw	r30, r24
    3440:	31 80       	ldd	r3, Z+1	; 0x01
    3442:	fc 01       	movw	r30, r24
    3444:	42 80       	ldd	r4, Z+2	; 0x02
    3446:	fc 01       	movw	r30, r24
    3448:	53 80       	ldd	r5, Z+3	; 0x03
    344a:	fc 01       	movw	r30, r24
    344c:	64 80       	ldd	r6, Z+4	; 0x04
    344e:	fc 01       	movw	r30, r24
    3450:	75 80       	ldd	r7, Z+5	; 0x05
    3452:	fc 01       	movw	r30, r24
    3454:	86 80       	ldd	r8, Z+6	; 0x06
    3456:	fc 01       	movw	r30, r24
    3458:	97 80       	ldd	r9, Z+7	; 0x07
    345a:	2a 2d       	mov	r18, r10
    345c:	22 0d       	add	r18, r2
    345e:	e1 e0       	ldi	r30, 0x01	; 1
    3460:	2a 15       	cp	r18, r10
    3462:	08 f0       	brcs	.+2      	; 0x3466 <calcChecksumFRAM+0x3a4>
    3464:	e0 e0       	ldi	r30, 0x00	; 0
    3466:	3b 2d       	mov	r19, r11
    3468:	33 0d       	add	r19, r3
    346a:	f1 e0       	ldi	r31, 0x01	; 1
    346c:	3b 15       	cp	r19, r11
    346e:	08 f0       	brcs	.+2      	; 0x3472 <calcChecksumFRAM+0x3b0>
    3470:	f0 e0       	ldi	r31, 0x00	; 0
    3472:	e3 0f       	add	r30, r19
    3474:	a1 e0       	ldi	r26, 0x01	; 1
    3476:	e3 17       	cp	r30, r19
    3478:	08 f0       	brcs	.+2      	; 0x347c <calcChecksumFRAM+0x3ba>
    347a:	a0 e0       	ldi	r26, 0x00	; 0
    347c:	fa 2b       	or	r31, r26
    347e:	3e 2f       	mov	r19, r30
    3480:	4c 2d       	mov	r20, r12
    3482:	44 0d       	add	r20, r4
    3484:	e1 e0       	ldi	r30, 0x01	; 1
    3486:	4c 15       	cp	r20, r12
    3488:	08 f0       	brcs	.+2      	; 0x348c <calcChecksumFRAM+0x3ca>
    348a:	e0 e0       	ldi	r30, 0x00	; 0
    348c:	f4 0f       	add	r31, r20
    348e:	a1 e0       	ldi	r26, 0x01	; 1
    3490:	f4 17       	cp	r31, r20
    3492:	08 f0       	brcs	.+2      	; 0x3496 <calcChecksumFRAM+0x3d4>
    3494:	a0 e0       	ldi	r26, 0x00	; 0
    3496:	ea 2b       	or	r30, r26
    3498:	4f 2f       	mov	r20, r31
    349a:	5d 2d       	mov	r21, r13
    349c:	55 0d       	add	r21, r5
    349e:	f1 e0       	ldi	r31, 0x01	; 1
    34a0:	5d 15       	cp	r21, r13
    34a2:	08 f0       	brcs	.+2      	; 0x34a6 <calcChecksumFRAM+0x3e4>
    34a4:	f0 e0       	ldi	r31, 0x00	; 0
    34a6:	e5 0f       	add	r30, r21
    34a8:	a1 e0       	ldi	r26, 0x01	; 1
    34aa:	e5 17       	cp	r30, r21
    34ac:	08 f0       	brcs	.+2      	; 0x34b0 <calcChecksumFRAM+0x3ee>
    34ae:	a0 e0       	ldi	r26, 0x00	; 0
    34b0:	fa 2b       	or	r31, r26
    34b2:	5e 2f       	mov	r21, r30
    34b4:	6e 2d       	mov	r22, r14
    34b6:	66 0d       	add	r22, r6
    34b8:	e1 e0       	ldi	r30, 0x01	; 1
    34ba:	6e 15       	cp	r22, r14
    34bc:	08 f0       	brcs	.+2      	; 0x34c0 <calcChecksumFRAM+0x3fe>
    34be:	e0 e0       	ldi	r30, 0x00	; 0
    34c0:	f6 0f       	add	r31, r22
    34c2:	a1 e0       	ldi	r26, 0x01	; 1
    34c4:	f6 17       	cp	r31, r22
    34c6:	08 f0       	brcs	.+2      	; 0x34ca <calcChecksumFRAM+0x408>
    34c8:	a0 e0       	ldi	r26, 0x00	; 0
    34ca:	ea 2b       	or	r30, r26
    34cc:	6f 2f       	mov	r22, r31
    34ce:	7f 2d       	mov	r23, r15
    34d0:	77 0d       	add	r23, r7
    34d2:	f1 e0       	ldi	r31, 0x01	; 1
    34d4:	7f 15       	cp	r23, r15
    34d6:	08 f0       	brcs	.+2      	; 0x34da <calcChecksumFRAM+0x418>
    34d8:	f0 e0       	ldi	r31, 0x00	; 0
    34da:	e7 0f       	add	r30, r23
    34dc:	a1 e0       	ldi	r26, 0x01	; 1
    34de:	e7 17       	cp	r30, r23
    34e0:	08 f0       	brcs	.+2      	; 0x34e4 <calcChecksumFRAM+0x422>
    34e2:	a0 e0       	ldi	r26, 0x00	; 0
    34e4:	fa 2b       	or	r31, r26
    34e6:	7e 2f       	mov	r23, r30
    34e8:	80 2f       	mov	r24, r16
    34ea:	88 0d       	add	r24, r8
    34ec:	e1 e0       	ldi	r30, 0x01	; 1
    34ee:	80 17       	cp	r24, r16
    34f0:	08 f0       	brcs	.+2      	; 0x34f4 <calcChecksumFRAM+0x432>
    34f2:	e0 e0       	ldi	r30, 0x00	; 0
    34f4:	f8 0f       	add	r31, r24
    34f6:	a1 e0       	ldi	r26, 0x01	; 1
    34f8:	f8 17       	cp	r31, r24
    34fa:	08 f0       	brcs	.+2      	; 0x34fe <calcChecksumFRAM+0x43c>
    34fc:	a0 e0       	ldi	r26, 0x00	; 0
    34fe:	ea 2b       	or	r30, r26
    3500:	8f 2f       	mov	r24, r31
    3502:	91 2f       	mov	r25, r17
    3504:	99 0d       	add	r25, r9
    3506:	e9 0f       	add	r30, r25
    3508:	9e 2f       	mov	r25, r30
    350a:	a2 2e       	mov	r10, r18
    350c:	b3 2e       	mov	r11, r19
    350e:	c4 2e       	mov	r12, r20
    3510:	d5 2e       	mov	r13, r21
    3512:	e6 2e       	mov	r14, r22
    3514:	f7 2e       	mov	r15, r23
    3516:	08 2f       	mov	r16, r24
    3518:	19 2f       	mov	r17, r25
    351a:	a0 92 90 50 	sts	0x5090, r10
    351e:	b0 92 91 50 	sts	0x5091, r11
    3522:	c0 92 92 50 	sts	0x5092, r12
    3526:	d0 92 93 50 	sts	0x5093, r13
    352a:	e0 92 94 50 	sts	0x5094, r14
    352e:	f0 92 95 50 	sts	0x5095, r15
    3532:	00 93 96 50 	sts	0x5096, r16
    3536:	10 93 97 50 	sts	0x5097, r17
			if(k%9 == 8) sumFRAM[2] += *temp64;
    353a:	8b 81       	ldd	r24, Y+3	; 0x03
    353c:	9c 81       	ldd	r25, Y+4	; 0x04
    353e:	29 e0       	ldi	r18, 0x09	; 9
    3540:	30 e0       	ldi	r19, 0x00	; 0
    3542:	b9 01       	movw	r22, r18
    3544:	0e 94 b5 5e 	call	0xbd6a	; 0xbd6a <__udivmodhi4>
    3548:	88 30       	cpi	r24, 0x08	; 8
    354a:	91 05       	cpc	r25, r1
    354c:	09 f0       	breq	.+2      	; 0x3550 <calcChecksumFRAM+0x48e>
    354e:	94 c0       	rjmp	.+296    	; 0x3678 <calcChecksumFRAM+0x5b6>
    3550:	a0 90 98 50 	lds	r10, 0x5098
    3554:	b0 90 99 50 	lds	r11, 0x5099
    3558:	c0 90 9a 50 	lds	r12, 0x509A
    355c:	d0 90 9b 50 	lds	r13, 0x509B
    3560:	e0 90 9c 50 	lds	r14, 0x509C
    3564:	f0 90 9d 50 	lds	r15, 0x509D
    3568:	00 91 9e 50 	lds	r16, 0x509E
    356c:	10 91 9f 50 	lds	r17, 0x509F
    3570:	80 91 64 50 	lds	r24, 0x5064
    3574:	90 91 65 50 	lds	r25, 0x5065
    3578:	fc 01       	movw	r30, r24
    357a:	20 80       	ld	r2, Z
    357c:	fc 01       	movw	r30, r24
    357e:	31 80       	ldd	r3, Z+1	; 0x01
    3580:	fc 01       	movw	r30, r24
    3582:	42 80       	ldd	r4, Z+2	; 0x02
    3584:	fc 01       	movw	r30, r24
    3586:	53 80       	ldd	r5, Z+3	; 0x03
    3588:	fc 01       	movw	r30, r24
    358a:	64 80       	ldd	r6, Z+4	; 0x04
    358c:	fc 01       	movw	r30, r24
    358e:	75 80       	ldd	r7, Z+5	; 0x05
    3590:	fc 01       	movw	r30, r24
    3592:	86 80       	ldd	r8, Z+6	; 0x06
    3594:	fc 01       	movw	r30, r24
    3596:	97 80       	ldd	r9, Z+7	; 0x07
    3598:	2a 2d       	mov	r18, r10
    359a:	22 0d       	add	r18, r2
    359c:	e1 e0       	ldi	r30, 0x01	; 1
    359e:	2a 15       	cp	r18, r10
    35a0:	08 f0       	brcs	.+2      	; 0x35a4 <calcChecksumFRAM+0x4e2>
    35a2:	e0 e0       	ldi	r30, 0x00	; 0
    35a4:	3b 2d       	mov	r19, r11
    35a6:	33 0d       	add	r19, r3
    35a8:	f1 e0       	ldi	r31, 0x01	; 1
    35aa:	3b 15       	cp	r19, r11
    35ac:	08 f0       	brcs	.+2      	; 0x35b0 <calcChecksumFRAM+0x4ee>
    35ae:	f0 e0       	ldi	r31, 0x00	; 0
    35b0:	e3 0f       	add	r30, r19
    35b2:	a1 e0       	ldi	r26, 0x01	; 1
    35b4:	e3 17       	cp	r30, r19
    35b6:	08 f0       	brcs	.+2      	; 0x35ba <calcChecksumFRAM+0x4f8>
    35b8:	a0 e0       	ldi	r26, 0x00	; 0
    35ba:	fa 2b       	or	r31, r26
    35bc:	3e 2f       	mov	r19, r30
    35be:	4c 2d       	mov	r20, r12
    35c0:	44 0d       	add	r20, r4
    35c2:	e1 e0       	ldi	r30, 0x01	; 1
    35c4:	4c 15       	cp	r20, r12
    35c6:	08 f0       	brcs	.+2      	; 0x35ca <calcChecksumFRAM+0x508>
    35c8:	e0 e0       	ldi	r30, 0x00	; 0
    35ca:	f4 0f       	add	r31, r20
    35cc:	a1 e0       	ldi	r26, 0x01	; 1
    35ce:	f4 17       	cp	r31, r20
    35d0:	08 f0       	brcs	.+2      	; 0x35d4 <calcChecksumFRAM+0x512>
    35d2:	a0 e0       	ldi	r26, 0x00	; 0
    35d4:	ea 2b       	or	r30, r26
    35d6:	4f 2f       	mov	r20, r31
    35d8:	5d 2d       	mov	r21, r13
    35da:	55 0d       	add	r21, r5
    35dc:	f1 e0       	ldi	r31, 0x01	; 1
    35de:	5d 15       	cp	r21, r13
    35e0:	08 f0       	brcs	.+2      	; 0x35e4 <calcChecksumFRAM+0x522>
    35e2:	f0 e0       	ldi	r31, 0x00	; 0
    35e4:	e5 0f       	add	r30, r21
    35e6:	a1 e0       	ldi	r26, 0x01	; 1
    35e8:	e5 17       	cp	r30, r21
    35ea:	08 f0       	brcs	.+2      	; 0x35ee <calcChecksumFRAM+0x52c>
    35ec:	a0 e0       	ldi	r26, 0x00	; 0
    35ee:	fa 2b       	or	r31, r26
    35f0:	5e 2f       	mov	r21, r30
    35f2:	6e 2d       	mov	r22, r14
    35f4:	66 0d       	add	r22, r6
    35f6:	e1 e0       	ldi	r30, 0x01	; 1
    35f8:	6e 15       	cp	r22, r14
    35fa:	08 f0       	brcs	.+2      	; 0x35fe <calcChecksumFRAM+0x53c>
    35fc:	e0 e0       	ldi	r30, 0x00	; 0
    35fe:	f6 0f       	add	r31, r22
    3600:	a1 e0       	ldi	r26, 0x01	; 1
    3602:	f6 17       	cp	r31, r22
    3604:	08 f0       	brcs	.+2      	; 0x3608 <calcChecksumFRAM+0x546>
    3606:	a0 e0       	ldi	r26, 0x00	; 0
    3608:	ea 2b       	or	r30, r26
    360a:	6f 2f       	mov	r22, r31
    360c:	7f 2d       	mov	r23, r15
    360e:	77 0d       	add	r23, r7
    3610:	f1 e0       	ldi	r31, 0x01	; 1
    3612:	7f 15       	cp	r23, r15
    3614:	08 f0       	brcs	.+2      	; 0x3618 <calcChecksumFRAM+0x556>
    3616:	f0 e0       	ldi	r31, 0x00	; 0
    3618:	e7 0f       	add	r30, r23
    361a:	a1 e0       	ldi	r26, 0x01	; 1
    361c:	e7 17       	cp	r30, r23
    361e:	08 f0       	brcs	.+2      	; 0x3622 <calcChecksumFRAM+0x560>
    3620:	a0 e0       	ldi	r26, 0x00	; 0
    3622:	fa 2b       	or	r31, r26
    3624:	7e 2f       	mov	r23, r30
    3626:	80 2f       	mov	r24, r16
    3628:	88 0d       	add	r24, r8
    362a:	e1 e0       	ldi	r30, 0x01	; 1
    362c:	80 17       	cp	r24, r16
    362e:	08 f0       	brcs	.+2      	; 0x3632 <calcChecksumFRAM+0x570>
    3630:	e0 e0       	ldi	r30, 0x00	; 0
    3632:	f8 0f       	add	r31, r24
    3634:	a1 e0       	ldi	r26, 0x01	; 1
    3636:	f8 17       	cp	r31, r24
    3638:	08 f0       	brcs	.+2      	; 0x363c <calcChecksumFRAM+0x57a>
    363a:	a0 e0       	ldi	r26, 0x00	; 0
    363c:	ea 2b       	or	r30, r26
    363e:	8f 2f       	mov	r24, r31
    3640:	91 2f       	mov	r25, r17
    3642:	99 0d       	add	r25, r9
    3644:	e9 0f       	add	r30, r25
    3646:	9e 2f       	mov	r25, r30
    3648:	a2 2e       	mov	r10, r18
    364a:	b3 2e       	mov	r11, r19
    364c:	c4 2e       	mov	r12, r20
    364e:	d5 2e       	mov	r13, r21
    3650:	e6 2e       	mov	r14, r22
    3652:	f7 2e       	mov	r15, r23
    3654:	08 2f       	mov	r16, r24
    3656:	19 2f       	mov	r17, r25
    3658:	a0 92 98 50 	sts	0x5098, r10
    365c:	b0 92 99 50 	sts	0x5099, r11
    3660:	c0 92 9a 50 	sts	0x509A, r12
    3664:	d0 92 9b 50 	sts	0x509B, r13
    3668:	e0 92 9c 50 	sts	0x509C, r14
    366c:	f0 92 9d 50 	sts	0x509D, r15
    3670:	00 93 9e 50 	sts	0x509E, r16
    3674:	10 93 9f 50 	sts	0x509F, r17
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    3678:	8b 81       	ldd	r24, Y+3	; 0x03
    367a:	9c 81       	ldd	r25, Y+4	; 0x04
    367c:	01 96       	adiw	r24, 0x01	; 1
    367e:	8b 83       	std	Y+3, r24	; 0x03
    3680:	9c 83       	std	Y+4, r25	; 0x04
    3682:	8b 81       	ldd	r24, Y+3	; 0x03
    3684:	9c 81       	ldd	r25, Y+4	; 0x04
    3686:	fc e1       	ldi	r31, 0x1C	; 28
    3688:	81 37       	cpi	r24, 0x71	; 113
    368a:	9f 07       	cpc	r25, r31
    368c:	08 f4       	brcc	.+2      	; 0x3690 <calcChecksumFRAM+0x5ce>
    368e:	8e cd       	rjmp	.-1252   	; 0x31ac <calcChecksumFRAM+0xea>

void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    3690:	89 81       	ldd	r24, Y+1	; 0x01
    3692:	9a 81       	ldd	r25, Y+2	; 0x02
    3694:	01 96       	adiw	r24, 0x01	; 1
    3696:	89 83       	std	Y+1, r24	; 0x01
    3698:	9a 83       	std	Y+2, r25	; 0x02
    369a:	89 81       	ldd	r24, Y+1	; 0x01
    369c:	9a 81       	ldd	r25, Y+2	; 0x02
    369e:	89 30       	cpi	r24, 0x09	; 9
    36a0:	91 05       	cpc	r25, r1
    36a2:	08 f4       	brcc	.+2      	; 0x36a6 <calcChecksumFRAM+0x5e4>
    36a4:	72 cd       	rjmp	.-1308   	; 0x318a <calcChecksumFRAM+0xc8>
			
		}
		
	}
	
}
    36a6:	24 96       	adiw	r28, 0x04	; 4
    36a8:	cd bf       	out	0x3d, r28	; 61
    36aa:	de bf       	out	0x3e, r29	; 62
    36ac:	df 91       	pop	r29
    36ae:	cf 91       	pop	r28
    36b0:	1f 91       	pop	r17
    36b2:	0f 91       	pop	r16
    36b4:	ff 90       	pop	r15
    36b6:	ef 90       	pop	r14
    36b8:	df 90       	pop	r13
    36ba:	cf 90       	pop	r12
    36bc:	bf 90       	pop	r11
    36be:	af 90       	pop	r10
    36c0:	9f 90       	pop	r9
    36c2:	8f 90       	pop	r8
    36c4:	7f 90       	pop	r7
    36c6:	6f 90       	pop	r6
    36c8:	5f 90       	pop	r5
    36ca:	4f 90       	pop	r4
    36cc:	3f 90       	pop	r3
    36ce:	2f 90       	pop	r2
    36d0:	08 95       	ret

000036d2 <FRAMWriteKnowns>:


void FRAMWriteKnowns() {
    36d2:	cf 93       	push	r28
    36d4:	df 93       	push	r29
    36d6:	cd b7       	in	r28, 0x3d	; 61
    36d8:	de b7       	in	r29, 0x3e	; 62
	FRAMAddress = FR_BASEADD;
    36da:	10 92 58 40 	sts	0x4058, r1
    36de:	10 92 59 40 	sts	0x4059, r1
	sampleCount = 0;
    36e2:	10 92 73 50 	sts	0x5073, r1
    36e6:	10 92 74 50 	sts	0x5074, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    36ea:	80 e0       	ldi	r24, 0x00	; 0
    36ec:	80 93 3c 21 	sts	0x213C, r24
    36f0:	80 93 3b 21 	sts	0x213B, r24
    36f4:	80 93 3a 21 	sts	0x213A, r24
	
	ADCPower(TRUE);
    36f8:	81 e0       	ldi	r24, 0x01	; 1
    36fa:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    36fe:	84 e0       	ldi	r24, 0x04	; 4
    3700:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    3704:	80 ec       	ldi	r24, 0xC0	; 192
    3706:	98 e0       	ldi	r25, 0x08	; 8
    3708:	20 ed       	ldi	r18, 0xD0	; 208
    370a:	fc 01       	movw	r30, r24
    370c:	20 83       	st	Z, r18
	SPIBuffer[0] = 0x0D;
    370e:	8d e0       	ldi	r24, 0x0D	; 13
    3710:	80 93 66 50 	sts	0x5066, r24
	SPIBuffer[1] = 0xF3;
    3714:	83 ef       	ldi	r24, 0xF3	; 243
    3716:	80 93 67 50 	sts	0x5067, r24
	SPIBuffer[2] = 0x57;
    371a:	87 e5       	ldi	r24, 0x57	; 87
    371c:	80 93 68 50 	sts	0x5068, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    3720:	cd c0       	rjmp	.+410    	; 0x38bc <FRAMWriteKnowns+0x1ea>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    3722:	80 e4       	ldi	r24, 0x40	; 64
    3724:	96 e0       	ldi	r25, 0x06	; 6
    3726:	20 e1       	ldi	r18, 0x10	; 16
    3728:	fc 01       	movw	r30, r24
    372a:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    372c:	80 e2       	ldi	r24, 0x20	; 32
    372e:	96 e0       	ldi	r25, 0x06	; 6
    3730:	28 e0       	ldi	r18, 0x08	; 8
    3732:	fc 01       	movw	r30, r24
    3734:	26 83       	std	Z+6, r18	; 0x06
		nop();
    3736:	00 00       	nop
		SPIC.DATA = FR_WREN;
    3738:	80 ec       	ldi	r24, 0xC0	; 192
    373a:	98 e0       	ldi	r25, 0x08	; 8
    373c:	26 e0       	ldi	r18, 0x06	; 6
    373e:	fc 01       	movw	r30, r24
    3740:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3742:	00 00       	nop
    3744:	80 ec       	ldi	r24, 0xC0	; 192
    3746:	98 e0       	ldi	r25, 0x08	; 8
    3748:	fc 01       	movw	r30, r24
    374a:	82 81       	ldd	r24, Z+2	; 0x02
    374c:	88 23       	and	r24, r24
    374e:	d4 f7       	brge	.-12     	; 0x3744 <FRAMWriteKnowns+0x72>
		SPIBuffer[12] = SPIC.DATA;
    3750:	80 ec       	ldi	r24, 0xC0	; 192
    3752:	98 e0       	ldi	r25, 0x08	; 8
    3754:	fc 01       	movw	r30, r24
    3756:	83 81       	ldd	r24, Z+3	; 0x03
    3758:	80 93 72 50 	sts	0x5072, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    375c:	80 e2       	ldi	r24, 0x20	; 32
    375e:	96 e0       	ldi	r25, 0x06	; 6
    3760:	28 e0       	ldi	r18, 0x08	; 8
    3762:	fc 01       	movw	r30, r24
    3764:	25 83       	std	Z+5, r18	; 0x05
		nop(); // time for CS_FRAM to accept high signal
    3766:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3768:	80 e2       	ldi	r24, 0x20	; 32
    376a:	96 e0       	ldi	r25, 0x06	; 6
    376c:	28 e0       	ldi	r18, 0x08	; 8
    376e:	fc 01       	movw	r30, r24
    3770:	26 83       	std	Z+6, r18	; 0x06
		nop();
    3772:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    3774:	80 ec       	ldi	r24, 0xC0	; 192
    3776:	98 e0       	ldi	r25, 0x08	; 8
    3778:	22 e0       	ldi	r18, 0x02	; 2
    377a:	fc 01       	movw	r30, r24
    377c:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    377e:	00 00       	nop
    3780:	80 ec       	ldi	r24, 0xC0	; 192
    3782:	98 e0       	ldi	r25, 0x08	; 8
    3784:	fc 01       	movw	r30, r24
    3786:	82 81       	ldd	r24, Z+2	; 0x02
    3788:	88 23       	and	r24, r24
    378a:	d4 f7       	brge	.-12     	; 0x3780 <FRAMWriteKnowns+0xae>
		SPIBuffer[12] = SPIC.DATA;
    378c:	80 ec       	ldi	r24, 0xC0	; 192
    378e:	98 e0       	ldi	r25, 0x08	; 8
    3790:	fc 01       	movw	r30, r24
    3792:	83 81       	ldd	r24, Z+3	; 0x03
    3794:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    3798:	80 ec       	ldi	r24, 0xC0	; 192
    379a:	98 e0       	ldi	r25, 0x08	; 8
    379c:	20 91 59 40 	lds	r18, 0x4059
    37a0:	fc 01       	movw	r30, r24
    37a2:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    37a4:	00 00       	nop
    37a6:	80 ec       	ldi	r24, 0xC0	; 192
    37a8:	98 e0       	ldi	r25, 0x08	; 8
    37aa:	fc 01       	movw	r30, r24
    37ac:	82 81       	ldd	r24, Z+2	; 0x02
    37ae:	88 23       	and	r24, r24
    37b0:	d4 f7       	brge	.-12     	; 0x37a6 <FRAMWriteKnowns+0xd4>
		SPIBuffer[12] = SPIC.DATA;
    37b2:	80 ec       	ldi	r24, 0xC0	; 192
    37b4:	98 e0       	ldi	r25, 0x08	; 8
    37b6:	fc 01       	movw	r30, r24
    37b8:	83 81       	ldd	r24, Z+3	; 0x03
    37ba:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    37be:	80 ec       	ldi	r24, 0xC0	; 192
    37c0:	98 e0       	ldi	r25, 0x08	; 8
    37c2:	28 e5       	ldi	r18, 0x58	; 88
    37c4:	30 e4       	ldi	r19, 0x40	; 64
    37c6:	f9 01       	movw	r30, r18
    37c8:	20 81       	ld	r18, Z
    37ca:	fc 01       	movw	r30, r24
    37cc:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    37ce:	00 00       	nop
    37d0:	80 ec       	ldi	r24, 0xC0	; 192
    37d2:	98 e0       	ldi	r25, 0x08	; 8
    37d4:	fc 01       	movw	r30, r24
    37d6:	82 81       	ldd	r24, Z+2	; 0x02
    37d8:	88 23       	and	r24, r24
    37da:	d4 f7       	brge	.-12     	; 0x37d0 <FRAMWriteKnowns+0xfe>
		SPIBuffer[12] = SPIC.DATA;
    37dc:	80 ec       	ldi	r24, 0xC0	; 192
    37de:	98 e0       	ldi	r25, 0x08	; 8
    37e0:	fc 01       	movw	r30, r24
    37e2:	83 81       	ldd	r24, Z+3	; 0x03
    37e4:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = SPIBuffer[0];
    37e8:	80 ec       	ldi	r24, 0xC0	; 192
    37ea:	98 e0       	ldi	r25, 0x08	; 8
    37ec:	20 91 66 50 	lds	r18, 0x5066
    37f0:	fc 01       	movw	r30, r24
    37f2:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    37f4:	00 00       	nop
    37f6:	80 ec       	ldi	r24, 0xC0	; 192
    37f8:	98 e0       	ldi	r25, 0x08	; 8
    37fa:	fc 01       	movw	r30, r24
    37fc:	82 81       	ldd	r24, Z+2	; 0x02
    37fe:	88 23       	and	r24, r24
    3800:	d4 f7       	brge	.-12     	; 0x37f6 <FRAMWriteKnowns+0x124>
		SPIBuffer[12] = SPIC.DATA;
    3802:	80 ec       	ldi	r24, 0xC0	; 192
    3804:	98 e0       	ldi	r25, 0x08	; 8
    3806:	fc 01       	movw	r30, r24
    3808:	83 81       	ldd	r24, Z+3	; 0x03
    380a:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = SPIBuffer[1];
    380e:	80 ec       	ldi	r24, 0xC0	; 192
    3810:	98 e0       	ldi	r25, 0x08	; 8
    3812:	20 91 67 50 	lds	r18, 0x5067
    3816:	fc 01       	movw	r30, r24
    3818:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    381a:	00 00       	nop
    381c:	80 ec       	ldi	r24, 0xC0	; 192
    381e:	98 e0       	ldi	r25, 0x08	; 8
    3820:	fc 01       	movw	r30, r24
    3822:	82 81       	ldd	r24, Z+2	; 0x02
    3824:	88 23       	and	r24, r24
    3826:	d4 f7       	brge	.-12     	; 0x381c <FRAMWriteKnowns+0x14a>
		SPIBuffer[12] = SPIC.DATA;
    3828:	80 ec       	ldi	r24, 0xC0	; 192
    382a:	98 e0       	ldi	r25, 0x08	; 8
    382c:	fc 01       	movw	r30, r24
    382e:	83 81       	ldd	r24, Z+3	; 0x03
    3830:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = SPIBuffer[2];
    3834:	80 ec       	ldi	r24, 0xC0	; 192
    3836:	98 e0       	ldi	r25, 0x08	; 8
    3838:	20 91 68 50 	lds	r18, 0x5068
    383c:	fc 01       	movw	r30, r24
    383e:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3840:	00 00       	nop
    3842:	80 ec       	ldi	r24, 0xC0	; 192
    3844:	98 e0       	ldi	r25, 0x08	; 8
    3846:	fc 01       	movw	r30, r24
    3848:	82 81       	ldd	r24, Z+2	; 0x02
    384a:	88 23       	and	r24, r24
    384c:	d4 f7       	brge	.-12     	; 0x3842 <FRAMWriteKnowns+0x170>
		SPIBuffer[12] = SPIC.DATA;
    384e:	80 ec       	ldi	r24, 0xC0	; 192
    3850:	98 e0       	ldi	r25, 0x08	; 8
    3852:	fc 01       	movw	r30, r24
    3854:	83 81       	ldd	r24, Z+3	; 0x03
    3856:	80 93 72 50 	sts	0x5072, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    385a:	80 e2       	ldi	r24, 0x20	; 32
    385c:	96 e0       	ldi	r25, 0x06	; 6
    385e:	28 e0       	ldi	r18, 0x08	; 8
    3860:	fc 01       	movw	r30, r24
    3862:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    3864:	80 e4       	ldi	r24, 0x40	; 64
    3866:	96 e0       	ldi	r25, 0x06	; 6
    3868:	20 e1       	ldi	r18, 0x10	; 16
    386a:	fc 01       	movw	r30, r24
    386c:	25 83       	std	Z+5, r18	; 0x05
		
		FRAMAddress +=3;
    386e:	80 91 58 40 	lds	r24, 0x4058
    3872:	90 91 59 40 	lds	r25, 0x4059
    3876:	03 96       	adiw	r24, 0x03	; 3
    3878:	80 93 58 40 	sts	0x4058, r24
    387c:	90 93 59 40 	sts	0x4059, r25
		checksumADC[0] += SPIBuffer[0];
    3880:	90 91 3a 21 	lds	r25, 0x213A
    3884:	80 91 66 50 	lds	r24, 0x5066
    3888:	89 0f       	add	r24, r25
    388a:	80 93 3a 21 	sts	0x213A, r24
		checksumADC[1] += SPIBuffer[1];
    388e:	90 91 3b 21 	lds	r25, 0x213B
    3892:	80 91 67 50 	lds	r24, 0x5067
    3896:	89 0f       	add	r24, r25
    3898:	80 93 3b 21 	sts	0x213B, r24
		checksumADC[2] += SPIBuffer[2];
    389c:	90 91 3c 21 	lds	r25, 0x213C
    38a0:	80 91 68 50 	lds	r24, 0x5068
    38a4:	89 0f       	add	r24, r25
    38a6:	80 93 3c 21 	sts	0x213C, r24
		
		sampleCount++;
    38aa:	80 91 73 50 	lds	r24, 0x5073
    38ae:	90 91 74 50 	lds	r25, 0x5074
    38b2:	01 96       	adiw	r24, 0x01	; 1
    38b4:	80 93 73 50 	sts	0x5073, r24
    38b8:	90 93 74 50 	sts	0x5074, r25
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    38bc:	80 91 73 50 	lds	r24, 0x5073
    38c0:	90 91 74 50 	lds	r25, 0x5074
    38c4:	f5 e5       	ldi	r31, 0x55	; 85
    38c6:	83 35       	cpi	r24, 0x53	; 83
    38c8:	9f 07       	cpc	r25, r31
    38ca:	08 f4       	brcc	.+2      	; 0x38ce <FRAMWriteKnowns+0x1fc>
    38cc:	2a cf       	rjmp	.-428    	; 0x3722 <FRAMWriteKnowns+0x50>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    38ce:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>
	ADCPower(FALSE);
    38d2:	80 e0       	ldi	r24, 0x00	; 0
    38d4:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
}
    38d8:	df 91       	pop	r29
    38da:	cf 91       	pop	r28
    38dc:	08 95       	ret

000038de <setADCInput>:



/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
    38de:	cf 93       	push	r28
    38e0:	df 93       	push	r29
    38e2:	0f 92       	push	r0
    38e4:	cd b7       	in	r28, 0x3d	; 61
    38e6:	de b7       	in	r29, 0x3e	; 62
    38e8:	89 83       	std	Y+1, r24	; 0x01
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    38ea:	89 81       	ldd	r24, Y+1	; 0x01
    38ec:	88 2f       	mov	r24, r24
    38ee:	90 e0       	ldi	r25, 0x00	; 0
    38f0:	81 70       	andi	r24, 0x01	; 1
    38f2:	90 70       	andi	r25, 0x00	; 0
    38f4:	88 23       	and	r24, r24
    38f6:	31 f0       	breq	.+12     	; 0x3904 <setADCInput+0x26>
    38f8:	80 e0       	ldi	r24, 0x00	; 0
    38fa:	96 e0       	ldi	r25, 0x06	; 6
    38fc:	20 e4       	ldi	r18, 0x40	; 64
    38fe:	fc 01       	movw	r30, r24
    3900:	25 83       	std	Z+5, r18	; 0x05
    3902:	05 c0       	rjmp	.+10     	; 0x390e <setADCInput+0x30>
	else {PORTA.OUTCLR = PIN6_bm;}
    3904:	80 e0       	ldi	r24, 0x00	; 0
    3906:	96 e0       	ldi	r25, 0x06	; 6
    3908:	20 e4       	ldi	r18, 0x40	; 64
    390a:	fc 01       	movw	r30, r24
    390c:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    390e:	89 81       	ldd	r24, Y+1	; 0x01
    3910:	88 2f       	mov	r24, r24
    3912:	90 e0       	ldi	r25, 0x00	; 0
    3914:	82 70       	andi	r24, 0x02	; 2
    3916:	90 70       	andi	r25, 0x00	; 0
    3918:	00 97       	sbiw	r24, 0x00	; 0
    391a:	31 f0       	breq	.+12     	; 0x3928 <setADCInput+0x4a>
    391c:	80 e2       	ldi	r24, 0x20	; 32
    391e:	96 e0       	ldi	r25, 0x06	; 6
    3920:	22 e0       	ldi	r18, 0x02	; 2
    3922:	fc 01       	movw	r30, r24
    3924:	25 83       	std	Z+5, r18	; 0x05
    3926:	05 c0       	rjmp	.+10     	; 0x3932 <setADCInput+0x54>
	else {PORTB.OUTCLR = PIN1_bm;}
    3928:	80 e2       	ldi	r24, 0x20	; 32
    392a:	96 e0       	ldi	r25, 0x06	; 6
    392c:	22 e0       	ldi	r18, 0x02	; 2
    392e:	fc 01       	movw	r30, r24
    3930:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    3932:	89 81       	ldd	r24, Y+1	; 0x01
    3934:	88 2f       	mov	r24, r24
    3936:	90 e0       	ldi	r25, 0x00	; 0
    3938:	84 70       	andi	r24, 0x04	; 4
    393a:	90 70       	andi	r25, 0x00	; 0
    393c:	00 97       	sbiw	r24, 0x00	; 0
    393e:	31 f0       	breq	.+12     	; 0x394c <setADCInput+0x6e>
    3940:	80 e2       	ldi	r24, 0x20	; 32
    3942:	96 e0       	ldi	r25, 0x06	; 6
    3944:	24 e0       	ldi	r18, 0x04	; 4
    3946:	fc 01       	movw	r30, r24
    3948:	25 83       	std	Z+5, r18	; 0x05
    394a:	05 c0       	rjmp	.+10     	; 0x3956 <setADCInput+0x78>
	else {PORTB.OUTCLR = PIN2_bm;}
    394c:	80 e2       	ldi	r24, 0x20	; 32
    394e:	96 e0       	ldi	r25, 0x06	; 6
    3950:	24 e0       	ldi	r18, 0x04	; 4
    3952:	fc 01       	movw	r30, r24
    3954:	26 83       	std	Z+6, r18	; 0x06

}
    3956:	0f 90       	pop	r0
    3958:	df 91       	pop	r29
    395a:	cf 91       	pop	r28
    395c:	08 95       	ret

0000395e <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    395e:	cf 93       	push	r28
    3960:	df 93       	push	r29
    3962:	0f 92       	push	r0
    3964:	0f 92       	push	r0
    3966:	cd b7       	in	r28, 0x3d	; 61
    3968:	de b7       	in	r29, 0x3e	; 62
    396a:	89 83       	std	Y+1, r24	; 0x01
    396c:	9a 83       	std	Y+2, r25	; 0x02
	if(&ADCA == adc){
    396e:	89 81       	ldd	r24, Y+1	; 0x01
    3970:	9a 81       	ldd	r25, Y+2	; 0x02
    3972:	22 e0       	ldi	r18, 0x02	; 2
    3974:	80 30       	cpi	r24, 0x00	; 0
    3976:	92 07       	cpc	r25, r18
    3978:	89 f4       	brne	.+34     	; 0x399c <ADC_CalibrationValues_Load+0x3e>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    397a:	80 e2       	ldi	r24, 0x20	; 32
    397c:	0e 94 2c 20 	call	0x4058	; 0x4058 <SP_ReadCalibrationByte>
    3980:	28 2f       	mov	r18, r24
    3982:	89 81       	ldd	r24, Y+1	; 0x01
    3984:	9a 81       	ldd	r25, Y+2	; 0x02
    3986:	fc 01       	movw	r30, r24
    3988:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    398a:	81 e2       	ldi	r24, 0x21	; 33
    398c:	0e 94 2c 20 	call	0x4058	; 0x4058 <SP_ReadCalibrationByte>
    3990:	28 2f       	mov	r18, r24
    3992:	89 81       	ldd	r24, Y+1	; 0x01
    3994:	9a 81       	ldd	r25, Y+2	; 0x02
    3996:	fc 01       	movw	r30, r24
    3998:	25 87       	std	Z+13, r18	; 0x0d
    399a:	10 c0       	rjmp	.+32     	; 0x39bc <ADC_CalibrationValues_Load+0x5e>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    399c:	84 e2       	ldi	r24, 0x24	; 36
    399e:	0e 94 2c 20 	call	0x4058	; 0x4058 <SP_ReadCalibrationByte>
    39a2:	28 2f       	mov	r18, r24
    39a4:	89 81       	ldd	r24, Y+1	; 0x01
    39a6:	9a 81       	ldd	r25, Y+2	; 0x02
    39a8:	fc 01       	movw	r30, r24
    39aa:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    39ac:	85 e2       	ldi	r24, 0x25	; 37
    39ae:	0e 94 2c 20 	call	0x4058	; 0x4058 <SP_ReadCalibrationByte>
    39b2:	28 2f       	mov	r18, r24
    39b4:	89 81       	ldd	r24, Y+1	; 0x01
    39b6:	9a 81       	ldd	r25, Y+2	; 0x02
    39b8:	fc 01       	movw	r30, r24
    39ba:	25 87       	std	Z+13, r18	; 0x0d
	}
}
    39bc:	0f 90       	pop	r0
    39be:	0f 90       	pop	r0
    39c0:	df 91       	pop	r29
    39c2:	cf 91       	pop	r28
    39c4:	08 95       	ret

000039c6 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    39c6:	cf 93       	push	r28
    39c8:	df 93       	push	r29
    39ca:	cd b7       	in	r28, 0x3d	; 61
    39cc:	de b7       	in	r29, 0x3e	; 62
    39ce:	25 97       	sbiw	r28, 0x05	; 5
    39d0:	cd bf       	out	0x3d, r28	; 61
    39d2:	de bf       	out	0x3e, r29	; 62
    39d4:	8b 83       	std	Y+3, r24	; 0x03
    39d6:	9c 83       	std	Y+4, r25	; 0x04
    39d8:	6d 83       	std	Y+5, r22	; 0x05
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    39da:	8b 81       	ldd	r24, Y+3	; 0x03
    39dc:	9c 81       	ldd	r25, Y+4	; 0x04
    39de:	21 e0       	ldi	r18, 0x01	; 1
    39e0:	fc 01       	movw	r30, r24
    39e2:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    39e4:	8b 81       	ldd	r24, Y+3	; 0x03
    39e6:	9c 81       	ldd	r25, Y+4	; 0x04
    39e8:	fc 01       	movw	r30, r24
    39ea:	24 81       	ldd	r18, Z+4	; 0x04
    39ec:	35 81       	ldd	r19, Z+5	; 0x05
    39ee:	8d 81       	ldd	r24, Y+5	; 0x05
    39f0:	88 2f       	mov	r24, r24
    39f2:	90 e0       	ldi	r25, 0x00	; 0
    39f4:	a9 01       	movw	r20, r18
    39f6:	48 1b       	sub	r20, r24
    39f8:	59 0b       	sbc	r21, r25
    39fa:	ca 01       	movw	r24, r20
    39fc:	89 83       	std	Y+1, r24	; 0x01
    39fe:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    3a00:	89 81       	ldd	r24, Y+1	; 0x01
    3a02:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3a04:	25 96       	adiw	r28, 0x05	; 5
    3a06:	cd bf       	out	0x3d, r28	; 61
    3a08:	de bf       	out	0x3e, r29	; 62
    3a0a:	df 91       	pop	r29
    3a0c:	cf 91       	pop	r28
    3a0e:	08 95       	ret

00003a10 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    3a10:	cf 93       	push	r28
    3a12:	df 93       	push	r29
    3a14:	cd b7       	in	r28, 0x3d	; 61
    3a16:	de b7       	in	r29, 0x3e	; 62
    3a18:	25 97       	sbiw	r28, 0x05	; 5
    3a1a:	cd bf       	out	0x3d, r28	; 61
    3a1c:	de bf       	out	0x3e, r29	; 62
    3a1e:	8b 83       	std	Y+3, r24	; 0x03
    3a20:	9c 83       	std	Y+4, r25	; 0x04
    3a22:	6d 83       	std	Y+5, r22	; 0x05
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3a24:	8b 81       	ldd	r24, Y+3	; 0x03
    3a26:	9c 81       	ldd	r25, Y+4	; 0x04
    3a28:	21 e0       	ldi	r18, 0x01	; 1
    3a2a:	fc 01       	movw	r30, r24
    3a2c:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    3a2e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a30:	9c 81       	ldd	r25, Y+4	; 0x04
    3a32:	fc 01       	movw	r30, r24
    3a34:	24 81       	ldd	r18, Z+4	; 0x04
    3a36:	35 81       	ldd	r19, Z+5	; 0x05
    3a38:	8d 81       	ldd	r24, Y+5	; 0x05
    3a3a:	99 27       	eor	r25, r25
    3a3c:	87 fd       	sbrc	r24, 7
    3a3e:	90 95       	com	r25
    3a40:	a9 01       	movw	r20, r18
    3a42:	48 1b       	sub	r20, r24
    3a44:	59 0b       	sbc	r21, r25
    3a46:	ca 01       	movw	r24, r20
    3a48:	89 83       	std	Y+1, r24	; 0x01
    3a4a:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    3a4c:	89 81       	ldd	r24, Y+1	; 0x01
    3a4e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3a50:	25 96       	adiw	r28, 0x05	; 5
    3a52:	cd bf       	out	0x3d, r28	; 61
    3a54:	de bf       	out	0x3e, r29	; 62
    3a56:	df 91       	pop	r29
    3a58:	cf 91       	pop	r28
    3a5a:	08 95       	ret

00003a5c <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    3a5c:	cf 93       	push	r28
    3a5e:	df 93       	push	r29
    3a60:	0f 92       	push	r0
    3a62:	0f 92       	push	r0
    3a64:	cd b7       	in	r28, 0x3d	; 61
    3a66:	de b7       	in	r29, 0x3e	; 62
    3a68:	89 83       	std	Y+1, r24	; 0x01
    3a6a:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3a6c:	89 81       	ldd	r24, Y+1	; 0x01
    3a6e:	9a 81       	ldd	r25, Y+2	; 0x02
    3a70:	21 e0       	ldi	r18, 0x01	; 1
    3a72:	fc 01       	movw	r30, r24
    3a74:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    3a76:	89 81       	ldd	r24, Y+1	; 0x01
    3a78:	9a 81       	ldd	r25, Y+2	; 0x02
    3a7a:	fc 01       	movw	r30, r24
    3a7c:	84 81       	ldd	r24, Z+4	; 0x04
    3a7e:	95 81       	ldd	r25, Z+5	; 0x05
}
    3a80:	0f 90       	pop	r0
    3a82:	0f 90       	pop	r0
    3a84:	df 91       	pop	r29
    3a86:	cf 91       	pop	r28
    3a88:	08 95       	ret

00003a8a <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    3a8a:	cf 93       	push	r28
    3a8c:	df 93       	push	r29
    3a8e:	0f 92       	push	r0
    3a90:	0f 92       	push	r0
    3a92:	cd b7       	in	r28, 0x3d	; 61
    3a94:	de b7       	in	r29, 0x3e	; 62
    3a96:	89 83       	std	Y+1, r24	; 0x01
    3a98:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3a9a:	89 81       	ldd	r24, Y+1	; 0x01
    3a9c:	9a 81       	ldd	r25, Y+2	; 0x02
    3a9e:	21 e0       	ldi	r18, 0x01	; 1
    3aa0:	fc 01       	movw	r30, r24
    3aa2:	23 83       	std	Z+3, r18	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    3aa4:	89 81       	ldd	r24, Y+1	; 0x01
    3aa6:	9a 81       	ldd	r25, Y+2	; 0x02
    3aa8:	fc 01       	movw	r30, r24
    3aaa:	84 81       	ldd	r24, Z+4	; 0x04
}
    3aac:	0f 90       	pop	r0
    3aae:	0f 90       	pop	r0
    3ab0:	df 91       	pop	r29
    3ab2:	cf 91       	pop	r28
    3ab4:	08 95       	ret

00003ab6 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    3ab6:	cf 93       	push	r28
    3ab8:	df 93       	push	r29
    3aba:	0f 92       	push	r0
    3abc:	0f 92       	push	r0
    3abe:	cd b7       	in	r28, 0x3d	; 61
    3ac0:	de b7       	in	r29, 0x3e	; 62
    3ac2:	89 83       	std	Y+1, r24	; 0x01
    3ac4:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3ac6:	89 81       	ldd	r24, Y+1	; 0x01
    3ac8:	9a 81       	ldd	r25, Y+2	; 0x02
    3aca:	21 e0       	ldi	r18, 0x01	; 1
    3acc:	fc 01       	movw	r30, r24
    3ace:	23 83       	std	Z+3, r18	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    3ad0:	89 81       	ldd	r24, Y+1	; 0x01
    3ad2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ad4:	fc 01       	movw	r30, r24
    3ad6:	85 81       	ldd	r24, Z+5	; 0x05
}
    3ad8:	0f 90       	pop	r0
    3ada:	0f 90       	pop	r0
    3adc:	df 91       	pop	r29
    3ade:	cf 91       	pop	r28
    3ae0:	08 95       	ret

00003ae2 <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    3ae2:	0f 93       	push	r16
    3ae4:	1f 93       	push	r17
    3ae6:	cf 93       	push	r28
    3ae8:	df 93       	push	r29
    3aea:	cd b7       	in	r28, 0x3d	; 61
    3aec:	de b7       	in	r29, 0x3e	; 62
    3aee:	6b 97       	sbiw	r28, 0x1b	; 27
    3af0:	cd bf       	out	0x3d, r28	; 61
    3af2:	de bf       	out	0x3e, r29	; 62
    3af4:	8a 8f       	std	Y+26, r24	; 0x1a
    3af6:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3af8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3afa:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3afc:	fc 01       	movw	r30, r24
    3afe:	84 81       	ldd	r24, Z+4	; 0x04
    3b00:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    3b02:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3b04:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3b06:	fc 01       	movw	r30, r24
    3b08:	14 82       	std	Z+4, r1	; 0x04
    3b0a:	80 e0       	ldi	r24, 0x00	; 0
    3b0c:	90 e0       	ldi	r25, 0x00	; 0
    3b0e:	a0 e8       	ldi	r26, 0x80	; 128
    3b10:	b2 e4       	ldi	r27, 0x42	; 66
    3b12:	8a 83       	std	Y+2, r24	; 0x02
    3b14:	9b 83       	std	Y+3, r25	; 0x03
    3b16:	ac 83       	std	Y+4, r26	; 0x04
    3b18:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3b1a:	6a 81       	ldd	r22, Y+2	; 0x02
    3b1c:	7b 81       	ldd	r23, Y+3	; 0x03
    3b1e:	8c 81       	ldd	r24, Y+4	; 0x04
    3b20:	9d 81       	ldd	r25, Y+5	; 0x05
    3b22:	2b ea       	ldi	r18, 0xAB	; 171
    3b24:	3a ea       	ldi	r19, 0xAA	; 170
    3b26:	4a e2       	ldi	r20, 0x2A	; 42
    3b28:	5f e3       	ldi	r21, 0x3F	; 63
    3b2a:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    3b2e:	dc 01       	movw	r26, r24
    3b30:	cb 01       	movw	r24, r22
    3b32:	8e 83       	std	Y+6, r24	; 0x06
    3b34:	9f 83       	std	Y+7, r25	; 0x07
    3b36:	a8 87       	std	Y+8, r26	; 0x08
    3b38:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3b3a:	11 e0       	ldi	r17, 0x01	; 1
    3b3c:	6e 81       	ldd	r22, Y+6	; 0x06
    3b3e:	7f 81       	ldd	r23, Y+7	; 0x07
    3b40:	88 85       	ldd	r24, Y+8	; 0x08
    3b42:	99 85       	ldd	r25, Y+9	; 0x09
    3b44:	20 e0       	ldi	r18, 0x00	; 0
    3b46:	30 e0       	ldi	r19, 0x00	; 0
    3b48:	40 e8       	ldi	r20, 0x80	; 128
    3b4a:	5f e3       	ldi	r21, 0x3F	; 63
    3b4c:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    3b50:	88 23       	and	r24, r24
    3b52:	0c f0       	brlt	.+2      	; 0x3b56 <ADC_Wait_8MHz+0x74>
    3b54:	10 e0       	ldi	r17, 0x00	; 0
    3b56:	11 23       	and	r17, r17
    3b58:	19 f0       	breq	.+6      	; 0x3b60 <ADC_Wait_8MHz+0x7e>
		__ticks = 1;
    3b5a:	81 e0       	ldi	r24, 0x01	; 1
    3b5c:	8a 87       	std	Y+10, r24	; 0x0a
    3b5e:	a3 c0       	rjmp	.+326    	; 0x3ca6 <ADC_Wait_8MHz+0x1c4>
	else if (__tmp > 255)
    3b60:	11 e0       	ldi	r17, 0x01	; 1
    3b62:	6e 81       	ldd	r22, Y+6	; 0x06
    3b64:	7f 81       	ldd	r23, Y+7	; 0x07
    3b66:	88 85       	ldd	r24, Y+8	; 0x08
    3b68:	99 85       	ldd	r25, Y+9	; 0x09
    3b6a:	20 e0       	ldi	r18, 0x00	; 0
    3b6c:	30 e0       	ldi	r19, 0x00	; 0
    3b6e:	4f e7       	ldi	r20, 0x7F	; 127
    3b70:	53 e4       	ldi	r21, 0x43	; 67
    3b72:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    3b76:	18 16       	cp	r1, r24
    3b78:	0c f0       	brlt	.+2      	; 0x3b7c <ADC_Wait_8MHz+0x9a>
    3b7a:	10 e0       	ldi	r17, 0x00	; 0
    3b7c:	11 23       	and	r17, r17
    3b7e:	09 f4       	brne	.+2      	; 0x3b82 <ADC_Wait_8MHz+0xa0>
    3b80:	89 c0       	rjmp	.+274    	; 0x3c94 <ADC_Wait_8MHz+0x1b2>
	{
		_delay_ms(__us / 1000.0);
    3b82:	6a 81       	ldd	r22, Y+2	; 0x02
    3b84:	7b 81       	ldd	r23, Y+3	; 0x03
    3b86:	8c 81       	ldd	r24, Y+4	; 0x04
    3b88:	9d 81       	ldd	r25, Y+5	; 0x05
    3b8a:	20 e0       	ldi	r18, 0x00	; 0
    3b8c:	30 e0       	ldi	r19, 0x00	; 0
    3b8e:	4a e7       	ldi	r20, 0x7A	; 122
    3b90:	54 e4       	ldi	r21, 0x44	; 68
    3b92:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
    3b96:	dc 01       	movw	r26, r24
    3b98:	cb 01       	movw	r24, r22
    3b9a:	8b 87       	std	Y+11, r24	; 0x0b
    3b9c:	9c 87       	std	Y+12, r25	; 0x0c
    3b9e:	ad 87       	std	Y+13, r26	; 0x0d
    3ba0:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3ba2:	6b 85       	ldd	r22, Y+11	; 0x0b
    3ba4:	7c 85       	ldd	r23, Y+12	; 0x0c
    3ba6:	8d 85       	ldd	r24, Y+13	; 0x0d
    3ba8:	9e 85       	ldd	r25, Y+14	; 0x0e
    3baa:	20 e0       	ldi	r18, 0x00	; 0
    3bac:	30 e0       	ldi	r19, 0x00	; 0
    3bae:	4a ef       	ldi	r20, 0xFA	; 250
    3bb0:	53 e4       	ldi	r21, 0x43	; 67
    3bb2:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    3bb6:	dc 01       	movw	r26, r24
    3bb8:	cb 01       	movw	r24, r22
    3bba:	8f 87       	std	Y+15, r24	; 0x0f
    3bbc:	98 8b       	std	Y+16, r25	; 0x10
    3bbe:	a9 8b       	std	Y+17, r26	; 0x11
    3bc0:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    3bc2:	11 e0       	ldi	r17, 0x01	; 1
    3bc4:	6f 85       	ldd	r22, Y+15	; 0x0f
    3bc6:	78 89       	ldd	r23, Y+16	; 0x10
    3bc8:	89 89       	ldd	r24, Y+17	; 0x11
    3bca:	9a 89       	ldd	r25, Y+18	; 0x12
    3bcc:	20 e0       	ldi	r18, 0x00	; 0
    3bce:	30 e0       	ldi	r19, 0x00	; 0
    3bd0:	40 e8       	ldi	r20, 0x80	; 128
    3bd2:	5f e3       	ldi	r21, 0x3F	; 63
    3bd4:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    3bd8:	88 23       	and	r24, r24
    3bda:	0c f0       	brlt	.+2      	; 0x3bde <ADC_Wait_8MHz+0xfc>
    3bdc:	10 e0       	ldi	r17, 0x00	; 0
    3bde:	11 23       	and	r17, r17
    3be0:	29 f0       	breq	.+10     	; 0x3bec <ADC_Wait_8MHz+0x10a>
		__ticks = 1;
    3be2:	81 e0       	ldi	r24, 0x01	; 1
    3be4:	90 e0       	ldi	r25, 0x00	; 0
    3be6:	8b 8b       	std	Y+19, r24	; 0x13
    3be8:	9c 8b       	std	Y+20, r25	; 0x14
    3bea:	46 c0       	rjmp	.+140    	; 0x3c78 <ADC_Wait_8MHz+0x196>
	else if (__tmp > 65535)
    3bec:	11 e0       	ldi	r17, 0x01	; 1
    3bee:	6f 85       	ldd	r22, Y+15	; 0x0f
    3bf0:	78 89       	ldd	r23, Y+16	; 0x10
    3bf2:	89 89       	ldd	r24, Y+17	; 0x11
    3bf4:	9a 89       	ldd	r25, Y+18	; 0x12
    3bf6:	20 e0       	ldi	r18, 0x00	; 0
    3bf8:	3f ef       	ldi	r19, 0xFF	; 255
    3bfa:	4f e7       	ldi	r20, 0x7F	; 127
    3bfc:	57 e4       	ldi	r21, 0x47	; 71
    3bfe:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    3c02:	18 16       	cp	r1, r24
    3c04:	0c f0       	brlt	.+2      	; 0x3c08 <ADC_Wait_8MHz+0x126>
    3c06:	10 e0       	ldi	r17, 0x00	; 0
    3c08:	11 23       	and	r17, r17
    3c0a:	61 f1       	breq	.+88     	; 0x3c64 <ADC_Wait_8MHz+0x182>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3c0c:	6b 85       	ldd	r22, Y+11	; 0x0b
    3c0e:	7c 85       	ldd	r23, Y+12	; 0x0c
    3c10:	8d 85       	ldd	r24, Y+13	; 0x0d
    3c12:	9e 85       	ldd	r25, Y+14	; 0x0e
    3c14:	20 e0       	ldi	r18, 0x00	; 0
    3c16:	30 e0       	ldi	r19, 0x00	; 0
    3c18:	40 e2       	ldi	r20, 0x20	; 32
    3c1a:	51 e4       	ldi	r21, 0x41	; 65
    3c1c:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    3c20:	dc 01       	movw	r26, r24
    3c22:	cb 01       	movw	r24, r22
    3c24:	bc 01       	movw	r22, r24
    3c26:	cd 01       	movw	r24, r26
    3c28:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    3c2c:	dc 01       	movw	r26, r24
    3c2e:	cb 01       	movw	r24, r22
    3c30:	8b 8b       	std	Y+19, r24	; 0x13
    3c32:	9c 8b       	std	Y+20, r25	; 0x14
    3c34:	12 c0       	rjmp	.+36     	; 0x3c5a <ADC_Wait_8MHz+0x178>
    3c36:	82 e3       	ldi	r24, 0x32	; 50
    3c38:	90 e0       	ldi	r25, 0x00	; 0
    3c3a:	8d 8b       	std	Y+21, r24	; 0x15
    3c3c:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3c3e:	8d 89       	ldd	r24, Y+21	; 0x15
    3c40:	9e 89       	ldd	r25, Y+22	; 0x16
    3c42:	8c 01       	movw	r16, r24
    3c44:	c8 01       	movw	r24, r16
    3c46:	01 97       	sbiw	r24, 0x01	; 1
    3c48:	f1 f7       	brne	.-4      	; 0x3c46 <ADC_Wait_8MHz+0x164>
    3c4a:	8c 01       	movw	r16, r24
    3c4c:	0d 8b       	std	Y+21, r16	; 0x15
    3c4e:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3c50:	8b 89       	ldd	r24, Y+19	; 0x13
    3c52:	9c 89       	ldd	r25, Y+20	; 0x14
    3c54:	01 97       	sbiw	r24, 0x01	; 1
    3c56:	8b 8b       	std	Y+19, r24	; 0x13
    3c58:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3c5a:	8b 89       	ldd	r24, Y+19	; 0x13
    3c5c:	9c 89       	ldd	r25, Y+20	; 0x14
    3c5e:	00 97       	sbiw	r24, 0x00	; 0
    3c60:	51 f7       	brne	.-44     	; 0x3c36 <ADC_Wait_8MHz+0x154>
    3c62:	28 c0       	rjmp	.+80     	; 0x3cb4 <ADC_Wait_8MHz+0x1d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3c64:	6f 85       	ldd	r22, Y+15	; 0x0f
    3c66:	78 89       	ldd	r23, Y+16	; 0x10
    3c68:	89 89       	ldd	r24, Y+17	; 0x11
    3c6a:	9a 89       	ldd	r25, Y+18	; 0x12
    3c6c:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    3c70:	dc 01       	movw	r26, r24
    3c72:	cb 01       	movw	r24, r22
    3c74:	8b 8b       	std	Y+19, r24	; 0x13
    3c76:	9c 8b       	std	Y+20, r25	; 0x14
    3c78:	8b 89       	ldd	r24, Y+19	; 0x13
    3c7a:	9c 89       	ldd	r25, Y+20	; 0x14
    3c7c:	8f 8b       	std	Y+23, r24	; 0x17
    3c7e:	98 8f       	std	Y+24, r25	; 0x18
    3c80:	8f 89       	ldd	r24, Y+23	; 0x17
    3c82:	98 8d       	ldd	r25, Y+24	; 0x18
    3c84:	8c 01       	movw	r16, r24
    3c86:	f8 01       	movw	r30, r16
    3c88:	31 97       	sbiw	r30, 0x01	; 1
    3c8a:	f1 f7       	brne	.-4      	; 0x3c88 <ADC_Wait_8MHz+0x1a6>
    3c8c:	8f 01       	movw	r16, r30
    3c8e:	0f 8b       	std	Y+23, r16	; 0x17
    3c90:	18 8f       	std	Y+24, r17	; 0x18
    3c92:	10 c0       	rjmp	.+32     	; 0x3cb4 <ADC_Wait_8MHz+0x1d2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3c94:	6e 81       	ldd	r22, Y+6	; 0x06
    3c96:	7f 81       	ldd	r23, Y+7	; 0x07
    3c98:	88 85       	ldd	r24, Y+8	; 0x08
    3c9a:	99 85       	ldd	r25, Y+9	; 0x09
    3c9c:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    3ca0:	dc 01       	movw	r26, r24
    3ca2:	cb 01       	movw	r24, r22
    3ca4:	8a 87       	std	Y+10, r24	; 0x0a
    3ca6:	8a 85       	ldd	r24, Y+10	; 0x0a
    3ca8:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3caa:	89 8d       	ldd	r24, Y+25	; 0x19
    3cac:	18 2f       	mov	r17, r24
    3cae:	1a 95       	dec	r17
    3cb0:	f1 f7       	brne	.-4      	; 0x3cae <ADC_Wait_8MHz+0x1cc>
    3cb2:	19 8f       	std	Y+25, r17	; 0x19

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3cb4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3cb6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3cb8:	29 81       	ldd	r18, Y+1	; 0x01
    3cba:	fc 01       	movw	r30, r24
    3cbc:	24 83       	std	Z+4, r18	; 0x04
}
    3cbe:	6b 96       	adiw	r28, 0x1b	; 27
    3cc0:	cd bf       	out	0x3d, r28	; 61
    3cc2:	de bf       	out	0x3e, r29	; 62
    3cc4:	df 91       	pop	r29
    3cc6:	cf 91       	pop	r28
    3cc8:	1f 91       	pop	r17
    3cca:	0f 91       	pop	r16
    3ccc:	08 95       	ret

00003cce <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    3cce:	0f 93       	push	r16
    3cd0:	1f 93       	push	r17
    3cd2:	cf 93       	push	r28
    3cd4:	df 93       	push	r29
    3cd6:	cd b7       	in	r28, 0x3d	; 61
    3cd8:	de b7       	in	r29, 0x3e	; 62
    3cda:	6b 97       	sbiw	r28, 0x1b	; 27
    3cdc:	cd bf       	out	0x3d, r28	; 61
    3cde:	de bf       	out	0x3e, r29	; 62
    3ce0:	8a 8f       	std	Y+26, r24	; 0x1a
    3ce2:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3ce4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3ce6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3ce8:	fc 01       	movw	r30, r24
    3cea:	84 81       	ldd	r24, Z+4	; 0x04
    3cec:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    3cee:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3cf0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3cf2:	21 e0       	ldi	r18, 0x01	; 1
    3cf4:	fc 01       	movw	r30, r24
    3cf6:	24 83       	std	Z+4, r18	; 0x04
    3cf8:	80 e0       	ldi	r24, 0x00	; 0
    3cfa:	90 e0       	ldi	r25, 0x00	; 0
    3cfc:	a0 e0       	ldi	r26, 0x00	; 0
    3cfe:	b3 e4       	ldi	r27, 0x43	; 67
    3d00:	8a 83       	std	Y+2, r24	; 0x02
    3d02:	9b 83       	std	Y+3, r25	; 0x03
    3d04:	ac 83       	std	Y+4, r26	; 0x04
    3d06:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3d08:	6a 81       	ldd	r22, Y+2	; 0x02
    3d0a:	7b 81       	ldd	r23, Y+3	; 0x03
    3d0c:	8c 81       	ldd	r24, Y+4	; 0x04
    3d0e:	9d 81       	ldd	r25, Y+5	; 0x05
    3d10:	2b ea       	ldi	r18, 0xAB	; 171
    3d12:	3a ea       	ldi	r19, 0xAA	; 170
    3d14:	4a e2       	ldi	r20, 0x2A	; 42
    3d16:	5f e3       	ldi	r21, 0x3F	; 63
    3d18:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    3d1c:	dc 01       	movw	r26, r24
    3d1e:	cb 01       	movw	r24, r22
    3d20:	8e 83       	std	Y+6, r24	; 0x06
    3d22:	9f 83       	std	Y+7, r25	; 0x07
    3d24:	a8 87       	std	Y+8, r26	; 0x08
    3d26:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3d28:	11 e0       	ldi	r17, 0x01	; 1
    3d2a:	6e 81       	ldd	r22, Y+6	; 0x06
    3d2c:	7f 81       	ldd	r23, Y+7	; 0x07
    3d2e:	88 85       	ldd	r24, Y+8	; 0x08
    3d30:	99 85       	ldd	r25, Y+9	; 0x09
    3d32:	20 e0       	ldi	r18, 0x00	; 0
    3d34:	30 e0       	ldi	r19, 0x00	; 0
    3d36:	40 e8       	ldi	r20, 0x80	; 128
    3d38:	5f e3       	ldi	r21, 0x3F	; 63
    3d3a:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    3d3e:	88 23       	and	r24, r24
    3d40:	0c f0       	brlt	.+2      	; 0x3d44 <ADC_Wait_32MHz+0x76>
    3d42:	10 e0       	ldi	r17, 0x00	; 0
    3d44:	11 23       	and	r17, r17
    3d46:	19 f0       	breq	.+6      	; 0x3d4e <ADC_Wait_32MHz+0x80>
		__ticks = 1;
    3d48:	81 e0       	ldi	r24, 0x01	; 1
    3d4a:	8a 87       	std	Y+10, r24	; 0x0a
    3d4c:	a3 c0       	rjmp	.+326    	; 0x3e94 <ADC_Wait_32MHz+0x1c6>
	else if (__tmp > 255)
    3d4e:	11 e0       	ldi	r17, 0x01	; 1
    3d50:	6e 81       	ldd	r22, Y+6	; 0x06
    3d52:	7f 81       	ldd	r23, Y+7	; 0x07
    3d54:	88 85       	ldd	r24, Y+8	; 0x08
    3d56:	99 85       	ldd	r25, Y+9	; 0x09
    3d58:	20 e0       	ldi	r18, 0x00	; 0
    3d5a:	30 e0       	ldi	r19, 0x00	; 0
    3d5c:	4f e7       	ldi	r20, 0x7F	; 127
    3d5e:	53 e4       	ldi	r21, 0x43	; 67
    3d60:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    3d64:	18 16       	cp	r1, r24
    3d66:	0c f0       	brlt	.+2      	; 0x3d6a <ADC_Wait_32MHz+0x9c>
    3d68:	10 e0       	ldi	r17, 0x00	; 0
    3d6a:	11 23       	and	r17, r17
    3d6c:	09 f4       	brne	.+2      	; 0x3d70 <ADC_Wait_32MHz+0xa2>
    3d6e:	89 c0       	rjmp	.+274    	; 0x3e82 <ADC_Wait_32MHz+0x1b4>
	{
		_delay_ms(__us / 1000.0);
    3d70:	6a 81       	ldd	r22, Y+2	; 0x02
    3d72:	7b 81       	ldd	r23, Y+3	; 0x03
    3d74:	8c 81       	ldd	r24, Y+4	; 0x04
    3d76:	9d 81       	ldd	r25, Y+5	; 0x05
    3d78:	20 e0       	ldi	r18, 0x00	; 0
    3d7a:	30 e0       	ldi	r19, 0x00	; 0
    3d7c:	4a e7       	ldi	r20, 0x7A	; 122
    3d7e:	54 e4       	ldi	r21, 0x44	; 68
    3d80:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
    3d84:	dc 01       	movw	r26, r24
    3d86:	cb 01       	movw	r24, r22
    3d88:	8b 87       	std	Y+11, r24	; 0x0b
    3d8a:	9c 87       	std	Y+12, r25	; 0x0c
    3d8c:	ad 87       	std	Y+13, r26	; 0x0d
    3d8e:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3d90:	6b 85       	ldd	r22, Y+11	; 0x0b
    3d92:	7c 85       	ldd	r23, Y+12	; 0x0c
    3d94:	8d 85       	ldd	r24, Y+13	; 0x0d
    3d96:	9e 85       	ldd	r25, Y+14	; 0x0e
    3d98:	20 e0       	ldi	r18, 0x00	; 0
    3d9a:	30 e0       	ldi	r19, 0x00	; 0
    3d9c:	4a ef       	ldi	r20, 0xFA	; 250
    3d9e:	53 e4       	ldi	r21, 0x43	; 67
    3da0:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    3da4:	dc 01       	movw	r26, r24
    3da6:	cb 01       	movw	r24, r22
    3da8:	8f 87       	std	Y+15, r24	; 0x0f
    3daa:	98 8b       	std	Y+16, r25	; 0x10
    3dac:	a9 8b       	std	Y+17, r26	; 0x11
    3dae:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    3db0:	11 e0       	ldi	r17, 0x01	; 1
    3db2:	6f 85       	ldd	r22, Y+15	; 0x0f
    3db4:	78 89       	ldd	r23, Y+16	; 0x10
    3db6:	89 89       	ldd	r24, Y+17	; 0x11
    3db8:	9a 89       	ldd	r25, Y+18	; 0x12
    3dba:	20 e0       	ldi	r18, 0x00	; 0
    3dbc:	30 e0       	ldi	r19, 0x00	; 0
    3dbe:	40 e8       	ldi	r20, 0x80	; 128
    3dc0:	5f e3       	ldi	r21, 0x3F	; 63
    3dc2:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    3dc6:	88 23       	and	r24, r24
    3dc8:	0c f0       	brlt	.+2      	; 0x3dcc <ADC_Wait_32MHz+0xfe>
    3dca:	10 e0       	ldi	r17, 0x00	; 0
    3dcc:	11 23       	and	r17, r17
    3dce:	29 f0       	breq	.+10     	; 0x3dda <ADC_Wait_32MHz+0x10c>
		__ticks = 1;
    3dd0:	81 e0       	ldi	r24, 0x01	; 1
    3dd2:	90 e0       	ldi	r25, 0x00	; 0
    3dd4:	8b 8b       	std	Y+19, r24	; 0x13
    3dd6:	9c 8b       	std	Y+20, r25	; 0x14
    3dd8:	46 c0       	rjmp	.+140    	; 0x3e66 <ADC_Wait_32MHz+0x198>
	else if (__tmp > 65535)
    3dda:	11 e0       	ldi	r17, 0x01	; 1
    3ddc:	6f 85       	ldd	r22, Y+15	; 0x0f
    3dde:	78 89       	ldd	r23, Y+16	; 0x10
    3de0:	89 89       	ldd	r24, Y+17	; 0x11
    3de2:	9a 89       	ldd	r25, Y+18	; 0x12
    3de4:	20 e0       	ldi	r18, 0x00	; 0
    3de6:	3f ef       	ldi	r19, 0xFF	; 255
    3de8:	4f e7       	ldi	r20, 0x7F	; 127
    3dea:	57 e4       	ldi	r21, 0x47	; 71
    3dec:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    3df0:	18 16       	cp	r1, r24
    3df2:	0c f0       	brlt	.+2      	; 0x3df6 <ADC_Wait_32MHz+0x128>
    3df4:	10 e0       	ldi	r17, 0x00	; 0
    3df6:	11 23       	and	r17, r17
    3df8:	61 f1       	breq	.+88     	; 0x3e52 <ADC_Wait_32MHz+0x184>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3dfa:	6b 85       	ldd	r22, Y+11	; 0x0b
    3dfc:	7c 85       	ldd	r23, Y+12	; 0x0c
    3dfe:	8d 85       	ldd	r24, Y+13	; 0x0d
    3e00:	9e 85       	ldd	r25, Y+14	; 0x0e
    3e02:	20 e0       	ldi	r18, 0x00	; 0
    3e04:	30 e0       	ldi	r19, 0x00	; 0
    3e06:	40 e2       	ldi	r20, 0x20	; 32
    3e08:	51 e4       	ldi	r21, 0x41	; 65
    3e0a:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    3e0e:	dc 01       	movw	r26, r24
    3e10:	cb 01       	movw	r24, r22
    3e12:	bc 01       	movw	r22, r24
    3e14:	cd 01       	movw	r24, r26
    3e16:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    3e1a:	dc 01       	movw	r26, r24
    3e1c:	cb 01       	movw	r24, r22
    3e1e:	8b 8b       	std	Y+19, r24	; 0x13
    3e20:	9c 8b       	std	Y+20, r25	; 0x14
    3e22:	12 c0       	rjmp	.+36     	; 0x3e48 <ADC_Wait_32MHz+0x17a>
    3e24:	82 e3       	ldi	r24, 0x32	; 50
    3e26:	90 e0       	ldi	r25, 0x00	; 0
    3e28:	8d 8b       	std	Y+21, r24	; 0x15
    3e2a:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3e2c:	8d 89       	ldd	r24, Y+21	; 0x15
    3e2e:	9e 89       	ldd	r25, Y+22	; 0x16
    3e30:	8c 01       	movw	r16, r24
    3e32:	c8 01       	movw	r24, r16
    3e34:	01 97       	sbiw	r24, 0x01	; 1
    3e36:	f1 f7       	brne	.-4      	; 0x3e34 <ADC_Wait_32MHz+0x166>
    3e38:	8c 01       	movw	r16, r24
    3e3a:	0d 8b       	std	Y+21, r16	; 0x15
    3e3c:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3e3e:	8b 89       	ldd	r24, Y+19	; 0x13
    3e40:	9c 89       	ldd	r25, Y+20	; 0x14
    3e42:	01 97       	sbiw	r24, 0x01	; 1
    3e44:	8b 8b       	std	Y+19, r24	; 0x13
    3e46:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3e48:	8b 89       	ldd	r24, Y+19	; 0x13
    3e4a:	9c 89       	ldd	r25, Y+20	; 0x14
    3e4c:	00 97       	sbiw	r24, 0x00	; 0
    3e4e:	51 f7       	brne	.-44     	; 0x3e24 <ADC_Wait_32MHz+0x156>
    3e50:	28 c0       	rjmp	.+80     	; 0x3ea2 <ADC_Wait_32MHz+0x1d4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3e52:	6f 85       	ldd	r22, Y+15	; 0x0f
    3e54:	78 89       	ldd	r23, Y+16	; 0x10
    3e56:	89 89       	ldd	r24, Y+17	; 0x11
    3e58:	9a 89       	ldd	r25, Y+18	; 0x12
    3e5a:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    3e5e:	dc 01       	movw	r26, r24
    3e60:	cb 01       	movw	r24, r22
    3e62:	8b 8b       	std	Y+19, r24	; 0x13
    3e64:	9c 8b       	std	Y+20, r25	; 0x14
    3e66:	8b 89       	ldd	r24, Y+19	; 0x13
    3e68:	9c 89       	ldd	r25, Y+20	; 0x14
    3e6a:	8f 8b       	std	Y+23, r24	; 0x17
    3e6c:	98 8f       	std	Y+24, r25	; 0x18
    3e6e:	8f 89       	ldd	r24, Y+23	; 0x17
    3e70:	98 8d       	ldd	r25, Y+24	; 0x18
    3e72:	8c 01       	movw	r16, r24
    3e74:	f8 01       	movw	r30, r16
    3e76:	31 97       	sbiw	r30, 0x01	; 1
    3e78:	f1 f7       	brne	.-4      	; 0x3e76 <ADC_Wait_32MHz+0x1a8>
    3e7a:	8f 01       	movw	r16, r30
    3e7c:	0f 8b       	std	Y+23, r16	; 0x17
    3e7e:	18 8f       	std	Y+24, r17	; 0x18
    3e80:	10 c0       	rjmp	.+32     	; 0x3ea2 <ADC_Wait_32MHz+0x1d4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3e82:	6e 81       	ldd	r22, Y+6	; 0x06
    3e84:	7f 81       	ldd	r23, Y+7	; 0x07
    3e86:	88 85       	ldd	r24, Y+8	; 0x08
    3e88:	99 85       	ldd	r25, Y+9	; 0x09
    3e8a:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    3e8e:	dc 01       	movw	r26, r24
    3e90:	cb 01       	movw	r24, r22
    3e92:	8a 87       	std	Y+10, r24	; 0x0a
    3e94:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e96:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3e98:	89 8d       	ldd	r24, Y+25	; 0x19
    3e9a:	18 2f       	mov	r17, r24
    3e9c:	1a 95       	dec	r17
    3e9e:	f1 f7       	brne	.-4      	; 0x3e9c <ADC_Wait_32MHz+0x1ce>
    3ea0:	19 8f       	std	Y+25, r17	; 0x19

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3ea2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3ea4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3ea6:	29 81       	ldd	r18, Y+1	; 0x01
    3ea8:	fc 01       	movw	r30, r24
    3eaa:	24 83       	std	Z+4, r18	; 0x04
}
    3eac:	6b 96       	adiw	r28, 0x1b	; 27
    3eae:	cd bf       	out	0x3d, r28	; 61
    3eb0:	de bf       	out	0x3e, r29	; 62
    3eb2:	df 91       	pop	r29
    3eb4:	cf 91       	pop	r28
    3eb6:	1f 91       	pop	r17
    3eb8:	0f 91       	pop	r16
    3eba:	08 95       	ret

00003ebc <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3ebc:	cf 93       	push	r28
    3ebe:	df 93       	push	r29
    3ec0:	cd b7       	in	r28, 0x3d	; 61
    3ec2:	de b7       	in	r29, 0x3e	; 62
    3ec4:	2a 97       	sbiw	r28, 0x0a	; 10
    3ec6:	cd bf       	out	0x3d, r28	; 61
    3ec8:	de bf       	out	0x3e, r29	; 62
    3eca:	8e 83       	std	Y+6, r24	; 0x06
    3ecc:	9f 83       	std	Y+7, r25	; 0x07
    3ece:	68 87       	std	Y+8, r22	; 0x08
    3ed0:	79 87       	std	Y+9, r23	; 0x09
    3ed2:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3ed4:	8a 85       	ldd	r24, Y+10	; 0x0a
    3ed6:	88 23       	and	r24, r24
    3ed8:	a9 f1       	breq	.+106    	; 0x3f44 <ADC_Offset_Get_Unsigned+0x88>
    {
      uint16_t offset=0;
    3eda:	19 82       	std	Y+1, r1	; 0x01
    3edc:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3ede:	1b 82       	std	Y+3, r1	; 0x03
    3ee0:	1c 82       	std	Y+4, r1	; 0x04
    3ee2:	24 c0       	rjmp	.+72     	; 0x3f2c <ADC_Offset_Get_Unsigned+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3ee4:	88 85       	ldd	r24, Y+8	; 0x08
    3ee6:	99 85       	ldd	r25, Y+9	; 0x09
    3ee8:	fc 01       	movw	r30, r24
    3eea:	80 81       	ld	r24, Z
    3eec:	28 2f       	mov	r18, r24
    3eee:	20 68       	ori	r18, 0x80	; 128
    3ef0:	88 85       	ldd	r24, Y+8	; 0x08
    3ef2:	99 85       	ldd	r25, Y+9	; 0x09
    3ef4:	fc 01       	movw	r30, r24
    3ef6:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3ef8:	88 85       	ldd	r24, Y+8	; 0x08
    3efa:	99 85       	ldd	r25, Y+9	; 0x09
    3efc:	fc 01       	movw	r30, r24
    3efe:	83 81       	ldd	r24, Z+3	; 0x03
    3f00:	88 2f       	mov	r24, r24
    3f02:	90 e0       	ldi	r25, 0x00	; 0
    3f04:	81 70       	andi	r24, 0x01	; 1
    3f06:	90 70       	andi	r25, 0x00	; 0
    3f08:	00 97       	sbiw	r24, 0x00	; 0
    3f0a:	b1 f3       	breq	.-20     	; 0x3ef8 <ADC_Offset_Get_Unsigned+0x3c>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    3f0c:	88 85       	ldd	r24, Y+8	; 0x08
    3f0e:	99 85       	ldd	r25, Y+9	; 0x09
    3f10:	60 e0       	ldi	r22, 0x00	; 0
    3f12:	0e 94 e3 1c 	call	0x39c6	; 0x39c6 <ADC_ResultCh_GetWord_Unsigned>
    3f16:	29 81       	ldd	r18, Y+1	; 0x01
    3f18:	3a 81       	ldd	r19, Y+2	; 0x02
    3f1a:	82 0f       	add	r24, r18
    3f1c:	93 1f       	adc	r25, r19
    3f1e:	89 83       	std	Y+1, r24	; 0x01
    3f20:	9a 83       	std	Y+2, r25	; 0x02
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    3f22:	8b 81       	ldd	r24, Y+3	; 0x03
    3f24:	9c 81       	ldd	r25, Y+4	; 0x04
    3f26:	01 96       	adiw	r24, 0x01	; 1
    3f28:	8b 83       	std	Y+3, r24	; 0x03
    3f2a:	9c 83       	std	Y+4, r25	; 0x04
    3f2c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f2e:	9c 81       	ldd	r25, Y+4	; 0x04
    3f30:	84 30       	cpi	r24, 0x04	; 4
    3f32:	91 05       	cpc	r25, r1
    3f34:	bc f2       	brlt	.-82     	; 0x3ee4 <ADC_Offset_Get_Unsigned+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    3f36:	89 81       	ldd	r24, Y+1	; 0x01
    3f38:	9a 81       	ldd	r25, Y+2	; 0x02
    3f3a:	96 95       	lsr	r25
    3f3c:	87 95       	ror	r24
    3f3e:	96 95       	lsr	r25
    3f40:	87 95       	ror	r24
    3f42:	1b c0       	rjmp	.+54     	; 0x3f7a <ADC_Offset_Get_Unsigned+0xbe>
    }
    else
    {        
      uint8_t offset=0;
    3f44:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3f46:	88 85       	ldd	r24, Y+8	; 0x08
    3f48:	99 85       	ldd	r25, Y+9	; 0x09
    3f4a:	fc 01       	movw	r30, r24
    3f4c:	80 81       	ld	r24, Z
    3f4e:	28 2f       	mov	r18, r24
    3f50:	20 68       	ori	r18, 0x80	; 128
    3f52:	88 85       	ldd	r24, Y+8	; 0x08
    3f54:	99 85       	ldd	r25, Y+9	; 0x09
    3f56:	fc 01       	movw	r30, r24
    3f58:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3f5a:	88 85       	ldd	r24, Y+8	; 0x08
    3f5c:	99 85       	ldd	r25, Y+9	; 0x09
    3f5e:	fc 01       	movw	r30, r24
    3f60:	83 81       	ldd	r24, Z+3	; 0x03
    3f62:	88 2f       	mov	r24, r24
    3f64:	90 e0       	ldi	r25, 0x00	; 0
    3f66:	81 70       	andi	r24, 0x01	; 1
    3f68:	90 70       	andi	r25, 0x00	; 0
    3f6a:	00 97       	sbiw	r24, 0x00	; 0
    3f6c:	b1 f3       	breq	.-20     	; 0x3f5a <ADC_Offset_Get_Unsigned+0x9e>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    3f6e:	88 85       	ldd	r24, Y+8	; 0x08
    3f70:	99 85       	ldd	r25, Y+9	; 0x09
    3f72:	0e 94 2e 1d 	call	0x3a5c	; 0x3a5c <ADC_ResultCh_GetWord>
    3f76:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3f78:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3f7a:	2a 96       	adiw	r28, 0x0a	; 10
    3f7c:	cd bf       	out	0x3d, r28	; 61
    3f7e:	de bf       	out	0x3e, r29	; 62
    3f80:	df 91       	pop	r29
    3f82:	cf 91       	pop	r28
    3f84:	08 95       	ret

00003f86 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3f86:	cf 93       	push	r28
    3f88:	df 93       	push	r29
    3f8a:	cd b7       	in	r28, 0x3d	; 61
    3f8c:	de b7       	in	r29, 0x3e	; 62
    3f8e:	2a 97       	sbiw	r28, 0x0a	; 10
    3f90:	cd bf       	out	0x3d, r28	; 61
    3f92:	de bf       	out	0x3e, r29	; 62
    3f94:	8e 83       	std	Y+6, r24	; 0x06
    3f96:	9f 83       	std	Y+7, r25	; 0x07
    3f98:	68 87       	std	Y+8, r22	; 0x08
    3f9a:	79 87       	std	Y+9, r23	; 0x09
    3f9c:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3f9e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3fa0:	88 23       	and	r24, r24
    3fa2:	c1 f1       	breq	.+112    	; 0x4014 <ADC_Offset_Get_Signed+0x8e>
    {
      int16_t offset=0;
    3fa4:	19 82       	std	Y+1, r1	; 0x01
    3fa6:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3fa8:	1b 82       	std	Y+3, r1	; 0x03
    3faa:	1c 82       	std	Y+4, r1	; 0x04
    3fac:	24 c0       	rjmp	.+72     	; 0x3ff6 <ADC_Offset_Get_Signed+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3fae:	88 85       	ldd	r24, Y+8	; 0x08
    3fb0:	99 85       	ldd	r25, Y+9	; 0x09
    3fb2:	fc 01       	movw	r30, r24
    3fb4:	80 81       	ld	r24, Z
    3fb6:	28 2f       	mov	r18, r24
    3fb8:	20 68       	ori	r18, 0x80	; 128
    3fba:	88 85       	ldd	r24, Y+8	; 0x08
    3fbc:	99 85       	ldd	r25, Y+9	; 0x09
    3fbe:	fc 01       	movw	r30, r24
    3fc0:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3fc2:	88 85       	ldd	r24, Y+8	; 0x08
    3fc4:	99 85       	ldd	r25, Y+9	; 0x09
    3fc6:	fc 01       	movw	r30, r24
    3fc8:	83 81       	ldd	r24, Z+3	; 0x03
    3fca:	88 2f       	mov	r24, r24
    3fcc:	90 e0       	ldi	r25, 0x00	; 0
    3fce:	81 70       	andi	r24, 0x01	; 1
    3fd0:	90 70       	andi	r25, 0x00	; 0
    3fd2:	00 97       	sbiw	r24, 0x00	; 0
    3fd4:	b1 f3       	breq	.-20     	; 0x3fc2 <ADC_Offset_Get_Signed+0x3c>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3fd6:	88 85       	ldd	r24, Y+8	; 0x08
    3fd8:	99 85       	ldd	r25, Y+9	; 0x09
    3fda:	60 e0       	ldi	r22, 0x00	; 0
    3fdc:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <ADC_ResultCh_GetWord_Signed>
    3fe0:	29 81       	ldd	r18, Y+1	; 0x01
    3fe2:	3a 81       	ldd	r19, Y+2	; 0x02
    3fe4:	82 0f       	add	r24, r18
    3fe6:	93 1f       	adc	r25, r19
    3fe8:	89 83       	std	Y+1, r24	; 0x01
    3fea:	9a 83       	std	Y+2, r25	; 0x02
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    3fec:	8b 81       	ldd	r24, Y+3	; 0x03
    3fee:	9c 81       	ldd	r25, Y+4	; 0x04
    3ff0:	01 96       	adiw	r24, 0x01	; 1
    3ff2:	8b 83       	std	Y+3, r24	; 0x03
    3ff4:	9c 83       	std	Y+4, r25	; 0x04
    3ff6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ff8:	9c 81       	ldd	r25, Y+4	; 0x04
    3ffa:	84 30       	cpi	r24, 0x04	; 4
    3ffc:	91 05       	cpc	r25, r1
    3ffe:	bc f2       	brlt	.-82     	; 0x3fae <ADC_Offset_Get_Signed+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    4000:	89 81       	ldd	r24, Y+1	; 0x01
    4002:	9a 81       	ldd	r25, Y+2	; 0x02
    4004:	99 23       	and	r25, r25
    4006:	0c f4       	brge	.+2      	; 0x400a <ADC_Offset_Get_Signed+0x84>
    4008:	03 96       	adiw	r24, 0x03	; 3
    400a:	95 95       	asr	r25
    400c:	87 95       	ror	r24
    400e:	95 95       	asr	r25
    4010:	87 95       	ror	r24
    4012:	1c c0       	rjmp	.+56     	; 0x404c <ADC_Offset_Get_Signed+0xc6>
    }
    else
    {        
      int8_t offset=0;
    4014:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    4016:	88 85       	ldd	r24, Y+8	; 0x08
    4018:	99 85       	ldd	r25, Y+9	; 0x09
    401a:	fc 01       	movw	r30, r24
    401c:	80 81       	ld	r24, Z
    401e:	28 2f       	mov	r18, r24
    4020:	20 68       	ori	r18, 0x80	; 128
    4022:	88 85       	ldd	r24, Y+8	; 0x08
    4024:	99 85       	ldd	r25, Y+9	; 0x09
    4026:	fc 01       	movw	r30, r24
    4028:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    402a:	88 85       	ldd	r24, Y+8	; 0x08
    402c:	99 85       	ldd	r25, Y+9	; 0x09
    402e:	fc 01       	movw	r30, r24
    4030:	83 81       	ldd	r24, Z+3	; 0x03
    4032:	88 2f       	mov	r24, r24
    4034:	90 e0       	ldi	r25, 0x00	; 0
    4036:	81 70       	andi	r24, 0x01	; 1
    4038:	90 70       	andi	r25, 0x00	; 0
    403a:	00 97       	sbiw	r24, 0x00	; 0
    403c:	b1 f3       	breq	.-20     	; 0x402a <ADC_Offset_Get_Signed+0xa4>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    403e:	88 85       	ldd	r24, Y+8	; 0x08
    4040:	99 85       	ldd	r25, Y+9	; 0x09
    4042:	60 e0       	ldi	r22, 0x00	; 0
    4044:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <ADC_ResultCh_GetWord_Signed>
    4048:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    404a:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    404c:	2a 96       	adiw	r28, 0x0a	; 10
    404e:	cd bf       	out	0x3d, r28	; 61
    4050:	de bf       	out	0x3e, r29	; 62
    4052:	df 91       	pop	r29
    4054:	cf 91       	pop	r28
    4056:	08 95       	ret

00004058 <SP_ReadCalibrationByte>:
 *  \param index The index to the calibration byte.
 *
 *  \return Calibration byte.
 */
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
    4058:	1f 93       	push	r17
    405a:	cf 93       	push	r28
    405c:	df 93       	push	r29
    405e:	cd b7       	in	r28, 0x3d	; 61
    4060:	de b7       	in	r29, 0x3e	; 62
    4062:	25 97       	sbiw	r28, 0x05	; 5
    4064:	cd bf       	out	0x3d, r28	; 61
    4066:	de bf       	out	0x3e, r29	; 62
    4068:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    406a:	8a ec       	ldi	r24, 0xCA	; 202
    406c:	91 e0       	ldi	r25, 0x01	; 1
    406e:	22 e0       	ldi	r18, 0x02	; 2
    4070:	fc 01       	movw	r30, r24
    4072:	20 83       	st	Z, r18
 	result = pgm_read_byte(index);
    4074:	8d 81       	ldd	r24, Y+5	; 0x05
    4076:	88 2f       	mov	r24, r24
    4078:	90 e0       	ldi	r25, 0x00	; 0
    407a:	89 83       	std	Y+1, r24	; 0x01
    407c:	9a 83       	std	Y+2, r25	; 0x02
    407e:	89 81       	ldd	r24, Y+1	; 0x01
    4080:	9a 81       	ldd	r25, Y+2	; 0x02
    4082:	fc 01       	movw	r30, r24
    4084:	14 91       	lpm	r17, Z
    4086:	1b 83       	std	Y+3, r17	; 0x03
    4088:	8b 81       	ldd	r24, Y+3	; 0x03
    408a:	8c 83       	std	Y+4, r24	; 0x04

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    408c:	8a ec       	ldi	r24, 0xCA	; 202
    408e:	91 e0       	ldi	r25, 0x01	; 1
    4090:	fc 01       	movw	r30, r24
    4092:	10 82       	st	Z, r1

	return result;
    4094:	8c 81       	ldd	r24, Y+4	; 0x04
}
    4096:	25 96       	adiw	r28, 0x05	; 5
    4098:	cd bf       	out	0x3d, r28	; 61
    409a:	de bf       	out	0x3e, r29	; 62
    409c:	df 91       	pop	r29
    409e:	cf 91       	pop	r28
    40a0:	1f 91       	pop	r17
    40a2:	08 95       	ret

000040a4 <chb_init>:
/*!

*/
/**************************************************************************/
void chb_init()
{
    40a4:	cf 93       	push	r28
    40a6:	df 93       	push	r29
    40a8:	cd b7       	in	r28, 0x3d	; 61
    40aa:	de b7       	in	r29, 0x3e	; 62
    memset(&pcb, 0, sizeof(pcb_t));
    40ac:	24 e1       	ldi	r18, 0x14	; 20
    40ae:	80 e4       	ldi	r24, 0x40	; 64
    40b0:	91 e2       	ldi	r25, 0x21	; 33
    40b2:	fc 01       	movw	r30, r24
    40b4:	32 2f       	mov	r19, r18
    40b6:	11 92       	st	Z+, r1
    40b8:	3a 95       	dec	r19
    40ba:	e9 f7       	brne	.-6      	; 0x40b6 <chb_init+0x12>
    pcb.src_addr = chb_get_short_addr();
    40bc:	0e 94 18 2e 	call	0x5c30	; 0x5c30 <chb_get_short_addr>
    40c0:	80 93 40 21 	sts	0x2140, r24
    40c4:	90 93 41 21 	sts	0x2141, r25
    chb_drvr_init();
    40c8:	0e 94 10 30 	call	0x6020	; 0x6020 <chb_drvr_init>
	radio_msg_received_int_enable();
    40cc:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <radio_msg_received_int_enable>
}
    40d0:	df 91       	pop	r29
    40d2:	cf 91       	pop	r28
    40d4:	08 95       	ret

000040d6 <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
    40d6:	cf 93       	push	r28
    40d8:	df 93       	push	r29
    40da:	cd b7       	in	r28, 0x3d	; 61
    40dc:	de b7       	in	r29, 0x3e	; 62
	PORTE.DIRSET = PIN2_bm;
    40de:	80 e8       	ldi	r24, 0x80	; 128
    40e0:	96 e0       	ldi	r25, 0x06	; 6
    40e2:	24 e0       	ldi	r18, 0x04	; 4
    40e4:	fc 01       	movw	r30, r24
    40e6:	21 83       	std	Z+1, r18	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    40e8:	80 e8       	ldi	r24, 0x80	; 128
    40ea:	96 e0       	ldi	r25, 0x06	; 6
    40ec:	24 e0       	ldi	r18, 0x04	; 4
    40ee:	fc 01       	movw	r30, r24
    40f0:	26 83       	std	Z+6, r18	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    40f2:	80 e8       	ldi	r24, 0x80	; 128
    40f4:	96 e0       	ldi	r25, 0x06	; 6
    40f6:	22 e0       	ldi	r18, 0x02	; 2
    40f8:	fc 01       	movw	r30, r24
    40fa:	20 8b       	std	Z+16, r18	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    40fc:	80 e8       	ldi	r24, 0x80	; 128
    40fe:	96 e0       	ldi	r25, 0x06	; 6
    4100:	24 e0       	ldi	r18, 0x04	; 4
    4102:	fc 01       	movw	r30, r24
    4104:	22 87       	std	Z+10, r18	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    4106:	80 e8       	ldi	r24, 0x80	; 128
    4108:	96 e0       	ldi	r25, 0x06	; 6
    410a:	23 e0       	ldi	r18, 0x03	; 3
    410c:	fc 01       	movw	r30, r24
    410e:	21 87       	std	Z+9, r18	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    4110:	80 ea       	ldi	r24, 0xA0	; 160
    4112:	90 e0       	ldi	r25, 0x00	; 0
    4114:	20 ea       	ldi	r18, 0xA0	; 160
    4116:	30 e0       	ldi	r19, 0x00	; 0
    4118:	f9 01       	movw	r30, r18
    411a:	22 81       	ldd	r18, Z+2	; 0x02
    411c:	24 60       	ori	r18, 0x04	; 4
    411e:	fc 01       	movw	r30, r24
    4120:	22 83       	std	Z+2, r18	; 0x02
	sei();
    4122:	78 94       	sei
}
    4124:	df 91       	pop	r29
    4126:	cf 91       	pop	r28
    4128:	08 95       	ret

0000412a <chb_get_pcb>:
/*!

*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    412a:	cf 93       	push	r28
    412c:	df 93       	push	r29
    412e:	cd b7       	in	r28, 0x3d	; 61
    4130:	de b7       	in	r29, 0x3e	; 62
    return &pcb;
    4132:	80 e4       	ldi	r24, 0x40	; 64
    4134:	91 e2       	ldi	r25, 0x21	; 33
}
    4136:	df 91       	pop	r29
    4138:	cf 91       	pop	r28
    413a:	08 95       	ret

0000413c <chb_gen_hdr>:
    Requires the dest addr, location to store data, and len of payload.
    Returns the length of the hdr. 
*/
/**************************************************************************/
static U8 chb_gen_hdr(U8 *hdr, U16 addr, U8 len)
{
    413c:	cf 93       	push	r28
    413e:	df 93       	push	r29
    4140:	cd b7       	in	r28, 0x3d	; 61
    4142:	de b7       	in	r29, 0x3e	; 62
    4144:	27 97       	sbiw	r28, 0x07	; 7
    4146:	cd bf       	out	0x3d, r28	; 61
    4148:	de bf       	out	0x3e, r29	; 62
    414a:	8b 83       	std	Y+3, r24	; 0x03
    414c:	9c 83       	std	Y+4, r25	; 0x04
    414e:	6d 83       	std	Y+5, r22	; 0x05
    4150:	7e 83       	std	Y+6, r23	; 0x06
    4152:	4f 83       	std	Y+7, r20	; 0x07
    U8 *hdr_ptr = hdr;
    4154:	8b 81       	ldd	r24, Y+3	; 0x03
    4156:	9c 81       	ldd	r25, Y+4	; 0x04
    4158:	89 83       	std	Y+1, r24	; 0x01
    415a:	9a 83       	std	Y+2, r25	; 0x02

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    415c:	8f 81       	ldd	r24, Y+7	; 0x07
    415e:	28 2f       	mov	r18, r24
    4160:	25 5f       	subi	r18, 0xF5	; 245
    4162:	89 81       	ldd	r24, Y+1	; 0x01
    4164:	9a 81       	ldd	r25, Y+2	; 0x02
    4166:	fc 01       	movw	r30, r24
    4168:	20 83       	st	Z, r18
    416a:	89 81       	ldd	r24, Y+1	; 0x01
    416c:	9a 81       	ldd	r25, Y+2	; 0x02
    416e:	01 96       	adiw	r24, 0x01	; 1
    4170:	89 83       	std	Y+1, r24	; 0x01
    4172:	9a 83       	std	Y+2, r25	; 0x02

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    4174:	8d 81       	ldd	r24, Y+5	; 0x05
    4176:	9e 81       	ldd	r25, Y+6	; 0x06
    4178:	ff ef       	ldi	r31, 0xFF	; 255
    417a:	8f 3f       	cpi	r24, 0xFF	; 255
    417c:	9f 07       	cpc	r25, r31
    417e:	11 f0       	breq	.+4      	; 0x4184 <chb_gen_hdr+0x48>
    4180:	21 e6       	ldi	r18, 0x61	; 97
    4182:	01 c0       	rjmp	.+2      	; 0x4186 <chb_gen_hdr+0x4a>
    4184:	21 e4       	ldi	r18, 0x41	; 65
    4186:	89 81       	ldd	r24, Y+1	; 0x01
    4188:	9a 81       	ldd	r25, Y+2	; 0x02
    418a:	fc 01       	movw	r30, r24
    418c:	20 83       	st	Z, r18
    418e:	89 81       	ldd	r24, Y+1	; 0x01
    4190:	9a 81       	ldd	r25, Y+2	; 0x02
    4192:	01 96       	adiw	r24, 0x01	; 1
    4194:	89 83       	std	Y+1, r24	; 0x01
    4196:	9a 83       	std	Y+2, r25	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    4198:	89 81       	ldd	r24, Y+1	; 0x01
    419a:	9a 81       	ldd	r25, Y+2	; 0x02
    419c:	28 e9       	ldi	r18, 0x98	; 152
    419e:	fc 01       	movw	r30, r24
    41a0:	20 83       	st	Z, r18
    41a2:	89 81       	ldd	r24, Y+1	; 0x01
    41a4:	9a 81       	ldd	r25, Y+2	; 0x02
    41a6:	01 96       	adiw	r24, 0x01	; 1
    41a8:	89 83       	std	Y+1, r24	; 0x01
    41aa:	9a 83       	std	Y+2, r25	; 0x02

    *hdr_ptr++ = pcb.seq++;
    41ac:	20 91 42 21 	lds	r18, 0x2142
    41b0:	89 81       	ldd	r24, Y+1	; 0x01
    41b2:	9a 81       	ldd	r25, Y+2	; 0x02
    41b4:	fc 01       	movw	r30, r24
    41b6:	20 83       	st	Z, r18
    41b8:	89 81       	ldd	r24, Y+1	; 0x01
    41ba:	9a 81       	ldd	r25, Y+2	; 0x02
    41bc:	01 96       	adiw	r24, 0x01	; 1
    41be:	89 83       	std	Y+1, r24	; 0x01
    41c0:	9a 83       	std	Y+2, r25	; 0x02
    41c2:	82 2f       	mov	r24, r18
    41c4:	8f 5f       	subi	r24, 0xFF	; 255
    41c6:	80 93 42 21 	sts	0x2142, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    41ca:	89 81       	ldd	r24, Y+1	; 0x01
    41cc:	9a 81       	ldd	r25, Y+2	; 0x02
    41ce:	24 e3       	ldi	r18, 0x34	; 52
    41d0:	32 e1       	ldi	r19, 0x12	; 18
    41d2:	fc 01       	movw	r30, r24
    41d4:	20 83       	st	Z, r18
    41d6:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    41d8:	89 81       	ldd	r24, Y+1	; 0x01
    41da:	9a 81       	ldd	r25, Y+2	; 0x02
    41dc:	02 96       	adiw	r24, 0x02	; 2
    41de:	89 83       	std	Y+1, r24	; 0x01
    41e0:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = addr;
    41e2:	89 81       	ldd	r24, Y+1	; 0x01
    41e4:	9a 81       	ldd	r25, Y+2	; 0x02
    41e6:	2d 81       	ldd	r18, Y+5	; 0x05
    41e8:	3e 81       	ldd	r19, Y+6	; 0x06
    41ea:	fc 01       	movw	r30, r24
    41ec:	20 83       	st	Z, r18
    41ee:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    41f0:	89 81       	ldd	r24, Y+1	; 0x01
    41f2:	9a 81       	ldd	r25, Y+2	; 0x02
    41f4:	02 96       	adiw	r24, 0x02	; 2
    41f6:	89 83       	std	Y+1, r24	; 0x01
    41f8:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = pcb.src_addr;
    41fa:	20 91 40 21 	lds	r18, 0x2140
    41fe:	30 91 41 21 	lds	r19, 0x2141
    4202:	89 81       	ldd	r24, Y+1	; 0x01
    4204:	9a 81       	ldd	r25, Y+2	; 0x02
    4206:	fc 01       	movw	r30, r24
    4208:	20 83       	st	Z, r18
    420a:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    420c:	89 81       	ldd	r24, Y+1	; 0x01
    420e:	9a 81       	ldd	r25, Y+2	; 0x02
    4210:	02 96       	adiw	r24, 0x02	; 2
    4212:	89 83       	std	Y+1, r24	; 0x01
    4214:	9a 83       	std	Y+2, r25	; 0x02
    
    // return the len of the header
    return hdr_ptr - hdr;
    4216:	29 81       	ldd	r18, Y+1	; 0x01
    4218:	3a 81       	ldd	r19, Y+2	; 0x02
    421a:	8b 81       	ldd	r24, Y+3	; 0x03
    421c:	9c 81       	ldd	r25, Y+4	; 0x04
    421e:	a9 01       	movw	r20, r18
    4220:	48 1b       	sub	r20, r24
    4222:	59 0b       	sbc	r21, r25
    4224:	ca 01       	movw	r24, r20
}
    4226:	27 96       	adiw	r28, 0x07	; 7
    4228:	cd bf       	out	0x3d, r28	; 61
    422a:	de bf       	out	0x3e, r29	; 62
    422c:	df 91       	pop	r29
    422e:	cf 91       	pop	r28
    4230:	08 95       	ret

00004232 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    4232:	ef 92       	push	r14
    4234:	ff 92       	push	r15
    4236:	0f 93       	push	r16
    4238:	1f 93       	push	r17
    423a:	cf 93       	push	r28
    423c:	df 93       	push	r29
    423e:	cd b7       	in	r28, 0x3d	; 61
    4240:	de b7       	in	r29, 0x3e	; 62
    4242:	e0 97       	sbiw	r28, 0x30	; 48
    4244:	cd bf       	out	0x3d, r28	; 61
    4246:	de bf       	out	0x3e, r29	; 62
    4248:	89 a7       	lds	r24, 0x79
    424a:	9a a7       	lds	r25, 0x7a
    424c:	6b a7       	lds	r22, 0x7b
    424e:	7c a7       	lds	r23, 0x7c
    4250:	2d a7       	lds	r18, 0x7d
    4252:	3e a7       	lds	r19, 0x7e
    4254:	4f a7       	lds	r20, 0x7f
    4256:	58 ab       	sts	0x58, r21
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    4258:	19 82       	std	Y+1, r1	; 0x01
    while (len > 0)
    425a:	62 c1       	rjmp	.+708    	; 0x4520 <chb_write+0x2ee>
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    425c:	8d a5       	lds	r24, 0x6d
    425e:	9e a5       	lds	r25, 0x6e
    4260:	af a5       	lds	r26, 0x6f
    4262:	b8 a9       	sts	0x48, r27
    4264:	85 36       	cpi	r24, 0x65	; 101
    4266:	91 05       	cpc	r25, r1
    4268:	a1 05       	cpc	r26, r1
    426a:	b1 05       	cpc	r27, r1
    426c:	20 f0       	brcs	.+8      	; 0x4276 <chb_write+0x44>
    426e:	84 e6       	ldi	r24, 0x64	; 100
    4270:	90 e0       	ldi	r25, 0x00	; 0
    4272:	a0 e0       	ldi	r26, 0x00	; 0
    4274:	b0 e0       	ldi	r27, 0x00	; 0
    4276:	8c 83       	std	Y+4, r24	; 0x04

        // gen frame header
        hdr_len = chb_gen_hdr(hdr, addr, frm_len);
    4278:	ce 01       	movw	r24, r28
    427a:	4f 96       	adiw	r24, 0x1f	; 31
    427c:	29 a5       	lds	r18, 0x69
    427e:	3a a5       	lds	r19, 0x6a
    4280:	b9 01       	movw	r22, r18
    4282:	4c 81       	ldd	r20, Y+4	; 0x04
    4284:	0e 94 9e 20 	call	0x413c	; 0x413c <chb_gen_hdr>
    4288:	8d 83       	std	Y+5, r24	; 0x05

        // send data to chip
		rtry = 0;
    428a:	1a 82       	std	Y+2, r1	; 0x02
    428c:	1b 82       	std	Y+3, r1	; 0x03
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    428e:	89 81       	ldd	r24, Y+1	; 0x01
    4290:	88 2f       	mov	r24, r24
    4292:	90 e0       	ldi	r25, 0x00	; 0
    4294:	2b a5       	lds	r18, 0x6b
    4296:	3c a5       	lds	r19, 0x6c
    4298:	28 0f       	add	r18, r24
    429a:	39 1f       	adc	r19, r25
    429c:	ce 01       	movw	r24, r28
    429e:	4f 96       	adiw	r24, 0x1f	; 31
    42a0:	b9 01       	movw	r22, r18
    42a2:	4c 81       	ldd	r20, Y+4	; 0x04
    42a4:	0e 94 32 2e 	call	0x5c64	; 0x5c64 <chb_tx>
    42a8:	8e 83       	std	Y+6, r24	; 0x06

             switch (status)
    42aa:	8e 81       	ldd	r24, Y+6	; 0x06
    42ac:	88 2f       	mov	r24, r24
    42ae:	90 e0       	ldi	r25, 0x00	; 0
    42b0:	83 30       	cpi	r24, 0x03	; 3
    42b2:	91 05       	cpc	r25, r1
    42b4:	31 f1       	breq	.+76     	; 0x4302 <chb_write+0xd0>
    42b6:	84 30       	cpi	r24, 0x04	; 4
    42b8:	91 05       	cpc	r25, r1
    42ba:	24 f4       	brge	.+8      	; 0x42c4 <chb_write+0x92>
    42bc:	81 30       	cpi	r24, 0x01	; 1
    42be:	91 05       	cpc	r25, r1
    42c0:	39 f0       	breq	.+14     	; 0x42d0 <chb_write+0x9e>
    42c2:	2e c0       	rjmp	.+92     	; 0x4320 <chb_write+0xee>
    42c4:	85 30       	cpi	r24, 0x05	; 5
    42c6:	91 05       	cpc	r25, r1
    42c8:	69 f0       	breq	.+26     	; 0x42e4 <chb_write+0xb2>
    42ca:	80 34       	cpi	r24, 0x40	; 64
    42cc:	91 05       	cpc	r25, r1
    42ce:	41 f5       	brne	.+80     	; 0x4320 <chb_write+0xee>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    42d0:	80 91 47 21 	lds	r24, 0x2147
    42d4:	90 91 48 21 	lds	r25, 0x2148
    42d8:	01 96       	adiw	r24, 0x01	; 1
    42da:	80 93 47 21 	sts	0x2147, r24
    42de:	90 93 48 21 	sts	0x2148, r25
                 break;
    42e2:	1f c0       	rjmp	.+62     	; 0x4322 <chb_write+0xf0>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    42e4:	80 91 49 21 	lds	r24, 0x2149
    42e8:	90 91 4a 21 	lds	r25, 0x214A
    42ec:	01 96       	adiw	r24, 0x01	; 1
    42ee:	80 93 49 21 	sts	0x2149, r24
    42f2:	90 93 4a 21 	sts	0x214A, r25
				 rtry++;
    42f6:	8a 81       	ldd	r24, Y+2	; 0x02
    42f8:	9b 81       	ldd	r25, Y+3	; 0x03
    42fa:	01 96       	adiw	r24, 0x01	; 1
    42fc:	8a 83       	std	Y+2, r24	; 0x02
    42fe:	9b 83       	std	Y+3, r25	; 0x03
                 break;
    4300:	10 c0       	rjmp	.+32     	; 0x4322 <chb_write+0xf0>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    4302:	80 91 4b 21 	lds	r24, 0x214B
    4306:	90 91 4c 21 	lds	r25, 0x214C
    430a:	01 96       	adiw	r24, 0x01	; 1
    430c:	80 93 4b 21 	sts	0x214B, r24
    4310:	90 93 4c 21 	sts	0x214C, r25
				 rtry++;
    4314:	8a 81       	ldd	r24, Y+2	; 0x02
    4316:	9b 81       	ldd	r25, Y+3	; 0x03
    4318:	01 96       	adiw	r24, 0x01	; 1
    431a:	8a 83       	std	Y+2, r24	; 0x02
    431c:	9b 83       	std	Y+3, r25	; 0x03
                 break;
    431e:	01 c0       	rjmp	.+2      	; 0x4322 <chb_write+0xf0>
 
             default:
                 break;
    4320:	00 00       	nop
             }
			if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
    4322:	8a 81       	ldd	r24, Y+2	; 0x02
    4324:	9b 81       	ldd	r25, Y+3	; 0x03
    4326:	18 16       	cp	r1, r24
    4328:	19 06       	cpc	r1, r25
    432a:	0c f0       	brlt	.+2      	; 0x432e <chb_write+0xfc>
    432c:	d5 c0       	rjmp	.+426    	; 0x44d8 <chb_write+0x2a6>
    432e:	80 e0       	ldi	r24, 0x00	; 0
    4330:	90 e0       	ldi	r25, 0x00	; 0
    4332:	a0 e2       	ldi	r26, 0x20	; 32
    4334:	b1 e4       	ldi	r27, 0x41	; 65
    4336:	8f 83       	std	Y+7, r24	; 0x07
    4338:	98 87       	std	Y+8, r25	; 0x08
    433a:	a9 87       	std	Y+9, r26	; 0x09
    433c:	ba 87       	std	Y+10, r27	; 0x0a
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    433e:	6f 81       	ldd	r22, Y+7	; 0x07
    4340:	78 85       	ldd	r23, Y+8	; 0x08
    4342:	89 85       	ldd	r24, Y+9	; 0x09
    4344:	9a 85       	ldd	r25, Y+10	; 0x0a
    4346:	2b ea       	ldi	r18, 0xAB	; 171
    4348:	3a ea       	ldi	r19, 0xAA	; 170
    434a:	4a ea       	ldi	r20, 0xAA	; 170
    434c:	5e e3       	ldi	r21, 0x3E	; 62
    434e:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    4352:	dc 01       	movw	r26, r24
    4354:	cb 01       	movw	r24, r22
    4356:	8b 87       	std	Y+11, r24	; 0x0b
    4358:	9c 87       	std	Y+12, r25	; 0x0c
    435a:	ad 87       	std	Y+13, r26	; 0x0d
    435c:	be 87       	std	Y+14, r27	; 0x0e
	if (__tmp < 1.0)
    435e:	11 e0       	ldi	r17, 0x01	; 1
    4360:	6b 85       	ldd	r22, Y+11	; 0x0b
    4362:	7c 85       	ldd	r23, Y+12	; 0x0c
    4364:	8d 85       	ldd	r24, Y+13	; 0x0d
    4366:	9e 85       	ldd	r25, Y+14	; 0x0e
    4368:	20 e0       	ldi	r18, 0x00	; 0
    436a:	30 e0       	ldi	r19, 0x00	; 0
    436c:	40 e8       	ldi	r20, 0x80	; 128
    436e:	5f e3       	ldi	r21, 0x3F	; 63
    4370:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    4374:	88 23       	and	r24, r24
    4376:	0c f0       	brlt	.+2      	; 0x437a <chb_write+0x148>
    4378:	10 e0       	ldi	r17, 0x00	; 0
    437a:	11 23       	and	r17, r17
    437c:	19 f0       	breq	.+6      	; 0x4384 <chb_write+0x152>
		__ticks = 1;
    437e:	81 e0       	ldi	r24, 0x01	; 1
    4380:	8f 87       	std	Y+15, r24	; 0x0f
    4382:	a3 c0       	rjmp	.+326    	; 0x44ca <chb_write+0x298>
	else if (__tmp > 255)
    4384:	11 e0       	ldi	r17, 0x01	; 1
    4386:	6b 85       	ldd	r22, Y+11	; 0x0b
    4388:	7c 85       	ldd	r23, Y+12	; 0x0c
    438a:	8d 85       	ldd	r24, Y+13	; 0x0d
    438c:	9e 85       	ldd	r25, Y+14	; 0x0e
    438e:	20 e0       	ldi	r18, 0x00	; 0
    4390:	30 e0       	ldi	r19, 0x00	; 0
    4392:	4f e7       	ldi	r20, 0x7F	; 127
    4394:	53 e4       	ldi	r21, 0x43	; 67
    4396:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    439a:	18 16       	cp	r1, r24
    439c:	0c f0       	brlt	.+2      	; 0x43a0 <chb_write+0x16e>
    439e:	10 e0       	ldi	r17, 0x00	; 0
    43a0:	11 23       	and	r17, r17
    43a2:	09 f4       	brne	.+2      	; 0x43a6 <chb_write+0x174>
    43a4:	89 c0       	rjmp	.+274    	; 0x44b8 <chb_write+0x286>
	{
		_delay_ms(__us / 1000.0);
    43a6:	6f 81       	ldd	r22, Y+7	; 0x07
    43a8:	78 85       	ldd	r23, Y+8	; 0x08
    43aa:	89 85       	ldd	r24, Y+9	; 0x09
    43ac:	9a 85       	ldd	r25, Y+10	; 0x0a
    43ae:	20 e0       	ldi	r18, 0x00	; 0
    43b0:	30 e0       	ldi	r19, 0x00	; 0
    43b2:	4a e7       	ldi	r20, 0x7A	; 122
    43b4:	54 e4       	ldi	r21, 0x44	; 68
    43b6:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
    43ba:	dc 01       	movw	r26, r24
    43bc:	cb 01       	movw	r24, r22
    43be:	88 8b       	std	Y+16, r24	; 0x10
    43c0:	99 8b       	std	Y+17, r25	; 0x11
    43c2:	aa 8b       	std	Y+18, r26	; 0x12
    43c4:	bb 8b       	std	Y+19, r27	; 0x13
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    43c6:	68 89       	ldd	r22, Y+16	; 0x10
    43c8:	79 89       	ldd	r23, Y+17	; 0x11
    43ca:	8a 89       	ldd	r24, Y+18	; 0x12
    43cc:	9b 89       	ldd	r25, Y+19	; 0x13
    43ce:	20 e0       	ldi	r18, 0x00	; 0
    43d0:	30 e0       	ldi	r19, 0x00	; 0
    43d2:	4a e7       	ldi	r20, 0x7A	; 122
    43d4:	53 e4       	ldi	r21, 0x43	; 67
    43d6:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    43da:	dc 01       	movw	r26, r24
    43dc:	cb 01       	movw	r24, r22
    43de:	8c 8b       	std	Y+20, r24	; 0x14
    43e0:	9d 8b       	std	Y+21, r25	; 0x15
    43e2:	ae 8b       	std	Y+22, r26	; 0x16
    43e4:	bf 8b       	std	Y+23, r27	; 0x17
	if (__tmp < 1.0)
    43e6:	11 e0       	ldi	r17, 0x01	; 1
    43e8:	6c 89       	ldd	r22, Y+20	; 0x14
    43ea:	7d 89       	ldd	r23, Y+21	; 0x15
    43ec:	8e 89       	ldd	r24, Y+22	; 0x16
    43ee:	9f 89       	ldd	r25, Y+23	; 0x17
    43f0:	20 e0       	ldi	r18, 0x00	; 0
    43f2:	30 e0       	ldi	r19, 0x00	; 0
    43f4:	40 e8       	ldi	r20, 0x80	; 128
    43f6:	5f e3       	ldi	r21, 0x3F	; 63
    43f8:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    43fc:	88 23       	and	r24, r24
    43fe:	0c f0       	brlt	.+2      	; 0x4402 <chb_write+0x1d0>
    4400:	10 e0       	ldi	r17, 0x00	; 0
    4402:	11 23       	and	r17, r17
    4404:	29 f0       	breq	.+10     	; 0x4410 <chb_write+0x1de>
		__ticks = 1;
    4406:	81 e0       	ldi	r24, 0x01	; 1
    4408:	90 e0       	ldi	r25, 0x00	; 0
    440a:	88 8f       	std	Y+24, r24	; 0x18
    440c:	99 8f       	std	Y+25, r25	; 0x19
    440e:	46 c0       	rjmp	.+140    	; 0x449c <chb_write+0x26a>
	else if (__tmp > 65535)
    4410:	11 e0       	ldi	r17, 0x01	; 1
    4412:	6c 89       	ldd	r22, Y+20	; 0x14
    4414:	7d 89       	ldd	r23, Y+21	; 0x15
    4416:	8e 89       	ldd	r24, Y+22	; 0x16
    4418:	9f 89       	ldd	r25, Y+23	; 0x17
    441a:	20 e0       	ldi	r18, 0x00	; 0
    441c:	3f ef       	ldi	r19, 0xFF	; 255
    441e:	4f e7       	ldi	r20, 0x7F	; 127
    4420:	57 e4       	ldi	r21, 0x47	; 71
    4422:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    4426:	18 16       	cp	r1, r24
    4428:	0c f0       	brlt	.+2      	; 0x442c <chb_write+0x1fa>
    442a:	10 e0       	ldi	r17, 0x00	; 0
    442c:	11 23       	and	r17, r17
    442e:	61 f1       	breq	.+88     	; 0x4488 <chb_write+0x256>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4430:	68 89       	ldd	r22, Y+16	; 0x10
    4432:	79 89       	ldd	r23, Y+17	; 0x11
    4434:	8a 89       	ldd	r24, Y+18	; 0x12
    4436:	9b 89       	ldd	r25, Y+19	; 0x13
    4438:	20 e0       	ldi	r18, 0x00	; 0
    443a:	30 e0       	ldi	r19, 0x00	; 0
    443c:	40 e2       	ldi	r20, 0x20	; 32
    443e:	51 e4       	ldi	r21, 0x41	; 65
    4440:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    4444:	dc 01       	movw	r26, r24
    4446:	cb 01       	movw	r24, r22
    4448:	bc 01       	movw	r22, r24
    444a:	cd 01       	movw	r24, r26
    444c:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    4450:	dc 01       	movw	r26, r24
    4452:	cb 01       	movw	r24, r22
    4454:	88 8f       	std	Y+24, r24	; 0x18
    4456:	99 8f       	std	Y+25, r25	; 0x19
    4458:	12 c0       	rjmp	.+36     	; 0x447e <chb_write+0x24c>
    445a:	89 e1       	ldi	r24, 0x19	; 25
    445c:	90 e0       	ldi	r25, 0x00	; 0
    445e:	8a 8f       	std	Y+26, r24	; 0x1a
    4460:	9b 8f       	std	Y+27, r25	; 0x1b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4462:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4464:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4466:	8c 01       	movw	r16, r24
    4468:	c8 01       	movw	r24, r16
    446a:	01 97       	sbiw	r24, 0x01	; 1
    446c:	f1 f7       	brne	.-4      	; 0x446a <chb_write+0x238>
    446e:	8c 01       	movw	r16, r24
    4470:	0a 8f       	std	Y+26, r16	; 0x1a
    4472:	1b 8f       	std	Y+27, r17	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4474:	88 8d       	ldd	r24, Y+24	; 0x18
    4476:	99 8d       	ldd	r25, Y+25	; 0x19
    4478:	01 97       	sbiw	r24, 0x01	; 1
    447a:	88 8f       	std	Y+24, r24	; 0x18
    447c:	99 8f       	std	Y+25, r25	; 0x19
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    447e:	88 8d       	ldd	r24, Y+24	; 0x18
    4480:	99 8d       	ldd	r25, Y+25	; 0x19
    4482:	00 97       	sbiw	r24, 0x00	; 0
    4484:	51 f7       	brne	.-44     	; 0x445a <chb_write+0x228>
    4486:	28 c0       	rjmp	.+80     	; 0x44d8 <chb_write+0x2a6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4488:	6c 89       	ldd	r22, Y+20	; 0x14
    448a:	7d 89       	ldd	r23, Y+21	; 0x15
    448c:	8e 89       	ldd	r24, Y+22	; 0x16
    448e:	9f 89       	ldd	r25, Y+23	; 0x17
    4490:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    4494:	dc 01       	movw	r26, r24
    4496:	cb 01       	movw	r24, r22
    4498:	88 8f       	std	Y+24, r24	; 0x18
    449a:	99 8f       	std	Y+25, r25	; 0x19
    449c:	88 8d       	ldd	r24, Y+24	; 0x18
    449e:	99 8d       	ldd	r25, Y+25	; 0x19
    44a0:	8c 8f       	std	Y+28, r24	; 0x1c
    44a2:	9d 8f       	std	Y+29, r25	; 0x1d
    44a4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    44a6:	9d 8d       	ldd	r25, Y+29	; 0x1d
    44a8:	8c 01       	movw	r16, r24
    44aa:	c8 01       	movw	r24, r16
    44ac:	01 97       	sbiw	r24, 0x01	; 1
    44ae:	f1 f7       	brne	.-4      	; 0x44ac <chb_write+0x27a>
    44b0:	8c 01       	movw	r16, r24
    44b2:	0c 8f       	std	Y+28, r16	; 0x1c
    44b4:	1d 8f       	std	Y+29, r17	; 0x1d
    44b6:	10 c0       	rjmp	.+32     	; 0x44d8 <chb_write+0x2a6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    44b8:	6b 85       	ldd	r22, Y+11	; 0x0b
    44ba:	7c 85       	ldd	r23, Y+12	; 0x0c
    44bc:	8d 85       	ldd	r24, Y+13	; 0x0d
    44be:	9e 85       	ldd	r25, Y+14	; 0x0e
    44c0:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    44c4:	dc 01       	movw	r26, r24
    44c6:	cb 01       	movw	r24, r22
    44c8:	8f 87       	std	Y+15, r24	; 0x0f
    44ca:	8f 85       	ldd	r24, Y+15	; 0x0f
    44cc:	8e 8f       	std	Y+30, r24	; 0x1e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    44ce:	8e 8d       	ldd	r24, Y+30	; 0x1e
    44d0:	18 2f       	mov	r17, r24
    44d2:	1a 95       	dec	r17
    44d4:	f1 f7       	brne	.-4      	; 0x44d2 <chb_write+0x2a0>
    44d6:	1e 8f       	std	Y+30, r17	; 0x1e
			if(rtry==20) return status;;		//after 20 tries give up on sending the message	
    44d8:	8a 81       	ldd	r24, Y+2	; 0x02
    44da:	9b 81       	ldd	r25, Y+3	; 0x03
    44dc:	84 31       	cpi	r24, 0x14	; 20
    44de:	91 05       	cpc	r25, r1
    44e0:	11 f4       	brne	.+4      	; 0x44e6 <chb_write+0x2b4>
    44e2:	8e 81       	ldd	r24, Y+6	; 0x06
    44e4:	27 c0       	rjmp	.+78     	; 0x4534 <chb_write+0x302>
		} while(status != CHB_SUCCESS);			
    44e6:	8e 81       	ldd	r24, Y+6	; 0x06
    44e8:	88 23       	and	r24, r24
    44ea:	09 f0       	breq	.+2      	; 0x44ee <chb_write+0x2bc>
    44ec:	d0 ce       	rjmp	.-608    	; 0x428e <chb_write+0x5c>
        // adjust len and restart
		frm_offset += frm_len;
    44ee:	99 81       	ldd	r25, Y+1	; 0x01
    44f0:	8c 81       	ldd	r24, Y+4	; 0x04
    44f2:	89 0f       	add	r24, r25
    44f4:	89 83       	std	Y+1, r24	; 0x01
        len = len - frm_len;
    44f6:	8c 81       	ldd	r24, Y+4	; 0x04
    44f8:	88 2f       	mov	r24, r24
    44fa:	90 e0       	ldi	r25, 0x00	; 0
    44fc:	a0 e0       	ldi	r26, 0x00	; 0
    44fe:	b0 e0       	ldi	r27, 0x00	; 0
    4500:	2d a5       	lds	r18, 0x6d
    4502:	3e a5       	lds	r19, 0x6e
    4504:	4f a5       	lds	r20, 0x6f
    4506:	58 a9       	sts	0x48, r21
    4508:	79 01       	movw	r14, r18
    450a:	8a 01       	movw	r16, r20
    450c:	e8 1a       	sub	r14, r24
    450e:	f9 0a       	sbc	r15, r25
    4510:	0a 0b       	sbc	r16, r26
    4512:	1b 0b       	sbc	r17, r27
    4514:	d8 01       	movw	r26, r16
    4516:	c7 01       	movw	r24, r14
    4518:	8d a7       	lds	r24, 0x7d
    451a:	9e a7       	lds	r25, 0x7e
    451c:	af a7       	lds	r26, 0x7f
    451e:	b8 ab       	sts	0x58, r27
{
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    4520:	8d a5       	lds	r24, 0x6d
    4522:	9e a5       	lds	r25, 0x6e
    4524:	af a5       	lds	r26, 0x6f
    4526:	b8 a9       	sts	0x48, r27
    4528:	00 97       	sbiw	r24, 0x00	; 0
    452a:	a1 05       	cpc	r26, r1
    452c:	b1 05       	cpc	r27, r1
    452e:	09 f0       	breq	.+2      	; 0x4532 <chb_write+0x300>
    4530:	95 ce       	rjmp	.-726    	; 0x425c <chb_write+0x2a>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    4532:	80 e0       	ldi	r24, 0x00	; 0
}
    4534:	e0 96       	adiw	r28, 0x30	; 48
    4536:	cd bf       	out	0x3d, r28	; 61
    4538:	de bf       	out	0x3e, r29	; 62
    453a:	df 91       	pop	r29
    453c:	cf 91       	pop	r28
    453e:	1f 91       	pop	r17
    4540:	0f 91       	pop	r16
    4542:	ff 90       	pop	r15
    4544:	ef 90       	pop	r14
    4546:	08 95       	ret

00004548 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    4548:	cf 93       	push	r28
    454a:	df 93       	push	r29
    454c:	cd b7       	in	r28, 0x3d	; 61
    454e:	de b7       	in	r29, 0x3e	; 62
    4550:	27 97       	sbiw	r28, 0x07	; 7
    4552:	cd bf       	out	0x3d, r28	; 61
    4554:	de bf       	out	0x3e, r29	; 62
    4556:	8e 83       	std	Y+6, r24	; 0x06
    4558:	9f 83       	std	Y+7, r25	; 0x07
    U8 i, len, seq, *data_ptr;

    data_ptr = rx->data;
    455a:	8e 81       	ldd	r24, Y+6	; 0x06
    455c:	9f 81       	ldd	r25, Y+7	; 0x07
    455e:	05 96       	adiw	r24, 0x05	; 5
    4560:	8a 83       	std	Y+2, r24	; 0x02
    4562:	9b 83       	std	Y+3, r25	; 0x03

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    4564:	0e 94 71 23 	call	0x46e2	; 0x46e2 <chb_buf_read>
    4568:	8c 83       	std	Y+4, r24	; 0x04
    456a:	8c 81       	ldd	r24, Y+4	; 0x04
    456c:	88 23       	and	r24, r24
    456e:	14 f4       	brge	.+4      	; 0x4574 <chb_read+0x2c>
    {
        return 0;
    4570:	80 e0       	ldi	r24, 0x00	; 0
    4572:	80 c0       	rjmp	.+256    	; 0x4674 <chb_read+0x12c>
    }
    *data_ptr++ = len;
    4574:	8a 81       	ldd	r24, Y+2	; 0x02
    4576:	9b 81       	ldd	r25, Y+3	; 0x03
    4578:	2c 81       	ldd	r18, Y+4	; 0x04
    457a:	fc 01       	movw	r30, r24
    457c:	20 83       	st	Z, r18
    457e:	8a 81       	ldd	r24, Y+2	; 0x02
    4580:	9b 81       	ldd	r25, Y+3	; 0x03
    4582:	01 96       	adiw	r24, 0x01	; 1
    4584:	8a 83       	std	Y+2, r24	; 0x02
    4586:	9b 83       	std	Y+3, r25	; 0x03

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    4588:	19 82       	std	Y+1, r1	; 0x01
    458a:	0f c0       	rjmp	.+30     	; 0x45aa <chb_read+0x62>
    {
        *data_ptr++ = chb_buf_read();
    458c:	0e 94 71 23 	call	0x46e2	; 0x46e2 <chb_buf_read>
    4590:	28 2f       	mov	r18, r24
    4592:	8a 81       	ldd	r24, Y+2	; 0x02
    4594:	9b 81       	ldd	r25, Y+3	; 0x03
    4596:	fc 01       	movw	r30, r24
    4598:	20 83       	st	Z, r18
    459a:	8a 81       	ldd	r24, Y+2	; 0x02
    459c:	9b 81       	ldd	r25, Y+3	; 0x03
    459e:	01 96       	adiw	r24, 0x01	; 1
    45a0:	8a 83       	std	Y+2, r24	; 0x02
    45a2:	9b 83       	std	Y+3, r25	; 0x03
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    45a4:	89 81       	ldd	r24, Y+1	; 0x01
    45a6:	8f 5f       	subi	r24, 0xFF	; 255
    45a8:	89 83       	std	Y+1, r24	; 0x01
    45aa:	99 81       	ldd	r25, Y+1	; 0x01
    45ac:	8c 81       	ldd	r24, Y+4	; 0x04
    45ae:	98 17       	cp	r25, r24
    45b0:	68 f3       	brcs	.-38     	; 0x458c <chb_read+0x44>
    // buffer as well to save resources.
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    45b2:	8e 81       	ldd	r24, Y+6	; 0x06
    45b4:	9f 81       	ldd	r25, Y+7	; 0x07
    45b6:	08 96       	adiw	r24, 0x08	; 8
    45b8:	8a 83       	std	Y+2, r24	; 0x02
    45ba:	9b 83       	std	Y+3, r25	; 0x03
    seq = *data_ptr;
    45bc:	8a 81       	ldd	r24, Y+2	; 0x02
    45be:	9b 81       	ldd	r25, Y+3	; 0x03
    45c0:	fc 01       	movw	r30, r24
    45c2:	80 81       	ld	r24, Z
    45c4:	8d 83       	std	Y+5, r24	; 0x05

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    45c6:	8e 81       	ldd	r24, Y+6	; 0x06
    45c8:	9f 81       	ldd	r25, Y+7	; 0x07
    45ca:	0b 96       	adiw	r24, 0x0b	; 11
    45cc:	8a 83       	std	Y+2, r24	; 0x02
    45ce:	9b 83       	std	Y+3, r25	; 0x03
    rx->dest_addr = *(U16 *)data_ptr;
    45d0:	8a 81       	ldd	r24, Y+2	; 0x02
    45d2:	9b 81       	ldd	r25, Y+3	; 0x03
    45d4:	fc 01       	movw	r30, r24
    45d6:	20 81       	ld	r18, Z
    45d8:	31 81       	ldd	r19, Z+1	; 0x01
    45da:	8e 81       	ldd	r24, Y+6	; 0x06
    45dc:	9f 81       	ldd	r25, Y+7	; 0x07
    45de:	fc 01       	movw	r30, r24
    45e0:	23 83       	std	Z+3, r18	; 0x03
    45e2:	34 83       	std	Z+4, r19	; 0x04
    data_ptr += sizeof(U16);
    45e4:	8a 81       	ldd	r24, Y+2	; 0x02
    45e6:	9b 81       	ldd	r25, Y+3	; 0x03
    45e8:	02 96       	adiw	r24, 0x02	; 2
    45ea:	8a 83       	std	Y+2, r24	; 0x02
    45ec:	9b 83       	std	Y+3, r25	; 0x03
    rx->src_addr = *(U16 *)data_ptr;
    45ee:	8a 81       	ldd	r24, Y+2	; 0x02
    45f0:	9b 81       	ldd	r25, Y+3	; 0x03
    45f2:	fc 01       	movw	r30, r24
    45f4:	20 81       	ld	r18, Z
    45f6:	31 81       	ldd	r19, Z+1	; 0x01
    45f8:	8e 81       	ldd	r24, Y+6	; 0x06
    45fa:	9f 81       	ldd	r25, Y+7	; 0x07
    45fc:	fc 01       	movw	r30, r24
    45fe:	21 83       	std	Z+1, r18	; 0x01
    4600:	32 83       	std	Z+2, r19	; 0x02
    data_ptr += sizeof(U16);
    4602:	8a 81       	ldd	r24, Y+2	; 0x02
    4604:	9b 81       	ldd	r25, Y+3	; 0x03
    4606:	02 96       	adiw	r24, 0x02	; 2
    4608:	8a 83       	std	Y+2, r24	; 0x02
    460a:	9b 83       	std	Y+3, r25	; 0x03

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    460c:	0e 94 95 23 	call	0x472a	; 0x472a <chb_buf_get_len>
    4610:	88 23       	and	r24, r24
    4612:	11 f4       	brne	.+4      	; 0x4618 <chb_read+0xd0>
    {
        pcb.data_rcv = false;
    4614:	10 92 43 21 	sts	0x2143, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    4618:	80 91 1a 20 	lds	r24, 0x201A
    461c:	9d 81       	ldd	r25, Y+5	; 0x05
    461e:	98 17       	cp	r25, r24
    4620:	71 f4       	brne	.+28     	; 0x463e <chb_read+0xf6>
    4622:	8e 81       	ldd	r24, Y+6	; 0x06
    4624:	9f 81       	ldd	r25, Y+7	; 0x07
    4626:	fc 01       	movw	r30, r24
    4628:	21 81       	ldd	r18, Z+1	; 0x01
    462a:	32 81       	ldd	r19, Z+2	; 0x02
    462c:	80 91 1b 20 	lds	r24, 0x201B
    4630:	90 91 1c 20 	lds	r25, 0x201C
    4634:	28 17       	cp	r18, r24
    4636:	39 07       	cpc	r19, r25
    4638:	11 f4       	brne	.+4      	; 0x463e <chb_read+0xf6>
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    463a:	80 e0       	ldi	r24, 0x00	; 0
    463c:	1b c0       	rjmp	.+54     	; 0x4674 <chb_read+0x12c>
    }
    else
    {
        prev_seq = seq;
    463e:	8d 81       	ldd	r24, Y+5	; 0x05
    4640:	80 93 1a 20 	sts	0x201A, r24
        prev_src_addr = rx->src_addr;
    4644:	8e 81       	ldd	r24, Y+6	; 0x06
    4646:	9f 81       	ldd	r25, Y+7	; 0x07
    4648:	fc 01       	movw	r30, r24
    464a:	81 81       	ldd	r24, Z+1	; 0x01
    464c:	92 81       	ldd	r25, Z+2	; 0x02
    464e:	80 93 1b 20 	sts	0x201B, r24
    4652:	90 93 1c 20 	sts	0x201C, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    4656:	8c 81       	ldd	r24, Y+4	; 0x04
    4658:	88 2f       	mov	r24, r24
    465a:	90 e0       	ldi	r25, 0x00	; 0
    465c:	09 97       	sbiw	r24, 0x09	; 9
    465e:	9c 01       	movw	r18, r24
    4660:	8e 81       	ldd	r24, Y+6	; 0x06
    4662:	9f 81       	ldd	r25, Y+7	; 0x07
    4664:	4a 81       	ldd	r20, Y+2	; 0x02
    4666:	5b 81       	ldd	r21, Y+3	; 0x03
    4668:	ba 01       	movw	r22, r20
    466a:	a9 01       	movw	r20, r18
    466c:	0e 94 5a 5f 	call	0xbeb4	; 0xbeb4 <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    4670:	8c 81       	ldd	r24, Y+4	; 0x04
    4672:	8b 50       	subi	r24, 0x0B	; 11
#endif
}
    4674:	27 96       	adiw	r28, 0x07	; 7
    4676:	cd bf       	out	0x3d, r28	; 61
    4678:	de bf       	out	0x3e, r29	; 62
    467a:	df 91       	pop	r29
    467c:	cf 91       	pop	r28
    467e:	08 95       	ret

00004680 <chb_buf_init>:
/*!

*/
/**************************************************************************/
void chb_buf_init()
{
    4680:	cf 93       	push	r28
    4682:	df 93       	push	r29
    4684:	cd b7       	in	r28, 0x3d	; 61
    4686:	de b7       	in	r29, 0x3e	; 62
    rd_ptr = 0;
    4688:	10 92 d4 21 	sts	0x21D4, r1
    wr_ptr = 0;
    468c:	10 92 d5 21 	sts	0x21D5, r1
    len = 0;
    4690:	10 92 d6 21 	sts	0x21D6, r1
}
    4694:	df 91       	pop	r29
    4696:	cf 91       	pop	r28
    4698:	08 95       	ret

0000469a <chb_buf_write>:
/*!

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    469a:	cf 93       	push	r28
    469c:	df 93       	push	r29
    469e:	0f 92       	push	r0
    46a0:	cd b7       	in	r28, 0x3d	; 61
    46a2:	de b7       	in	r29, 0x3e	; 62
    46a4:	89 83       	std	Y+1, r24	; 0x01
    chb_buf[wr_ptr] = data;
    46a6:	80 91 d5 21 	lds	r24, 0x21D5
    46aa:	88 2f       	mov	r24, r24
    46ac:	90 e0       	ldi	r25, 0x00	; 0
    46ae:	8c 5a       	subi	r24, 0xAC	; 172
    46b0:	9e 4d       	sbci	r25, 0xDE	; 222
    46b2:	29 81       	ldd	r18, Y+1	; 0x01
    46b4:	fc 01       	movw	r30, r24
    46b6:	20 83       	st	Z, r18
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    46b8:	80 91 d5 21 	lds	r24, 0x21D5
    46bc:	88 2f       	mov	r24, r24
    46be:	90 e0       	ldi	r25, 0x00	; 0
    46c0:	01 96       	adiw	r24, 0x01	; 1
    46c2:	20 e8       	ldi	r18, 0x80	; 128
    46c4:	30 e0       	ldi	r19, 0x00	; 0
    46c6:	b9 01       	movw	r22, r18
    46c8:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__divmodhi4>
    46cc:	80 93 d5 21 	sts	0x21D5, r24
    len++;
    46d0:	80 91 d6 21 	lds	r24, 0x21D6
    46d4:	8f 5f       	subi	r24, 0xFF	; 255
    46d6:	80 93 d6 21 	sts	0x21D6, r24
}
    46da:	0f 90       	pop	r0
    46dc:	df 91       	pop	r29
    46de:	cf 91       	pop	r28
    46e0:	08 95       	ret

000046e2 <chb_buf_read>:
/*!

*/
/**************************************************************************/
U8 chb_buf_read()
{
    46e2:	cf 93       	push	r28
    46e4:	df 93       	push	r29
    46e6:	0f 92       	push	r0
    46e8:	cd b7       	in	r28, 0x3d	; 61
    46ea:	de b7       	in	r29, 0x3e	; 62
    U8 data;

    data = chb_buf[rd_ptr];
    46ec:	80 91 d4 21 	lds	r24, 0x21D4
    46f0:	88 2f       	mov	r24, r24
    46f2:	90 e0       	ldi	r25, 0x00	; 0
    46f4:	8c 5a       	subi	r24, 0xAC	; 172
    46f6:	9e 4d       	sbci	r25, 0xDE	; 222
    46f8:	fc 01       	movw	r30, r24
    46fa:	80 81       	ld	r24, Z
    46fc:	89 83       	std	Y+1, r24	; 0x01
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    46fe:	80 91 d4 21 	lds	r24, 0x21D4
    4702:	88 2f       	mov	r24, r24
    4704:	90 e0       	ldi	r25, 0x00	; 0
    4706:	01 96       	adiw	r24, 0x01	; 1
    4708:	20 e8       	ldi	r18, 0x80	; 128
    470a:	30 e0       	ldi	r19, 0x00	; 0
    470c:	b9 01       	movw	r22, r18
    470e:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__divmodhi4>
    4712:	80 93 d4 21 	sts	0x21D4, r24
    len--;
    4716:	80 91 d6 21 	lds	r24, 0x21D6
    471a:	81 50       	subi	r24, 0x01	; 1
    471c:	80 93 d6 21 	sts	0x21D6, r24
    return data;
    4720:	89 81       	ldd	r24, Y+1	; 0x01
}
    4722:	0f 90       	pop	r0
    4724:	df 91       	pop	r29
    4726:	cf 91       	pop	r28
    4728:	08 95       	ret

0000472a <chb_buf_get_len>:
/*!

*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    472a:	cf 93       	push	r28
    472c:	df 93       	push	r29
    472e:	cd b7       	in	r28, 0x3d	; 61
    4730:	de b7       	in	r29, 0x3e	; 62
    return len;
    4732:	80 91 d6 21 	lds	r24, 0x21D6
}
    4736:	df 91       	pop	r29
    4738:	cf 91       	pop	r28
    473a:	08 95       	ret

0000473c <chb_get_state>:
/*!

*/
/**************************************************************************/
static U8 chb_get_state()
{
    473c:	cf 93       	push	r28
    473e:	df 93       	push	r29
    4740:	cd b7       	in	r28, 0x3d	; 61
    4742:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATUS) & 0x1f;
    4744:	81 e0       	ldi	r24, 0x01	; 1
    4746:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <chb_reg_read>
    474a:	8f 71       	andi	r24, 0x1F	; 31
}
    474c:	df 91       	pop	r29
    474e:	cf 91       	pop	r28
    4750:	08 95       	ret

00004752 <chb_get_status>:
/*!

*/
/**************************************************************************/
static U8 chb_get_status()
{
    4752:	cf 93       	push	r28
    4754:	df 93       	push	r29
    4756:	cd b7       	in	r28, 0x3d	; 61
    4758:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    475a:	82 e0       	ldi	r24, 0x02	; 2
    475c:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <chb_reg_read>
    4760:	82 95       	swap	r24
    4762:	86 95       	lsr	r24
    4764:	87 70       	andi	r24, 0x07	; 7
}
    4766:	df 91       	pop	r29
    4768:	cf 91       	pop	r28
    476a:	08 95       	ret

0000476c <chb_reset>:
/*!

*/
/**************************************************************************/
void chb_reset()
{
    476c:	0f 93       	push	r16
    476e:	1f 93       	push	r17
    4770:	cf 93       	push	r28
    4772:	df 93       	push	r29
    4774:	cd b7       	in	r28, 0x3d	; 61
    4776:	de b7       	in	r29, 0x3e	; 62
    4778:	e0 97       	sbiw	r28, 0x30	; 48
    477a:	cd bf       	out	0x3d, r28	; 61
    477c:	de bf       	out	0x3e, r29	; 62
    CHB_RST_DISABLE();
    477e:	84 e6       	ldi	r24, 0x64	; 100
    4780:	96 e0       	ldi	r25, 0x06	; 6
    4782:	24 e6       	ldi	r18, 0x64	; 100
    4784:	36 e0       	ldi	r19, 0x06	; 6
    4786:	f9 01       	movw	r30, r18
    4788:	20 81       	ld	r18, Z
    478a:	21 60       	ori	r18, 0x01	; 1
    478c:	fc 01       	movw	r30, r24
    478e:	20 83       	st	Z, r18
    CHB_SLPTR_DISABLE();
    4790:	84 e6       	ldi	r24, 0x64	; 100
    4792:	96 e0       	ldi	r25, 0x06	; 6
    4794:	24 e6       	ldi	r18, 0x64	; 100
    4796:	36 e0       	ldi	r19, 0x06	; 6
    4798:	f9 01       	movw	r30, r18
    479a:	20 81       	ld	r18, Z
    479c:	2d 7f       	andi	r18, 0xFD	; 253
    479e:	fc 01       	movw	r30, r24
    47a0:	20 83       	st	Z, r18
    47a2:	80 e0       	ldi	r24, 0x00	; 0
    47a4:	90 e0       	ldi	r25, 0x00	; 0
    47a6:	ae eb       	ldi	r26, 0xBE	; 190
    47a8:	b3 e4       	ldi	r27, 0x43	; 67
    47aa:	89 83       	std	Y+1, r24	; 0x01
    47ac:	9a 83       	std	Y+2, r25	; 0x02
    47ae:	ab 83       	std	Y+3, r26	; 0x03
    47b0:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    47b2:	69 81       	ldd	r22, Y+1	; 0x01
    47b4:	7a 81       	ldd	r23, Y+2	; 0x02
    47b6:	8b 81       	ldd	r24, Y+3	; 0x03
    47b8:	9c 81       	ldd	r25, Y+4	; 0x04
    47ba:	2b ea       	ldi	r18, 0xAB	; 171
    47bc:	3a ea       	ldi	r19, 0xAA	; 170
    47be:	4a ea       	ldi	r20, 0xAA	; 170
    47c0:	5e e3       	ldi	r21, 0x3E	; 62
    47c2:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    47c6:	dc 01       	movw	r26, r24
    47c8:	cb 01       	movw	r24, r22
    47ca:	8d 83       	std	Y+5, r24	; 0x05
    47cc:	9e 83       	std	Y+6, r25	; 0x06
    47ce:	af 83       	std	Y+7, r26	; 0x07
    47d0:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    47d2:	11 e0       	ldi	r17, 0x01	; 1
    47d4:	6d 81       	ldd	r22, Y+5	; 0x05
    47d6:	7e 81       	ldd	r23, Y+6	; 0x06
    47d8:	8f 81       	ldd	r24, Y+7	; 0x07
    47da:	98 85       	ldd	r25, Y+8	; 0x08
    47dc:	20 e0       	ldi	r18, 0x00	; 0
    47de:	30 e0       	ldi	r19, 0x00	; 0
    47e0:	40 e8       	ldi	r20, 0x80	; 128
    47e2:	5f e3       	ldi	r21, 0x3F	; 63
    47e4:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    47e8:	88 23       	and	r24, r24
    47ea:	0c f0       	brlt	.+2      	; 0x47ee <chb_reset+0x82>
    47ec:	10 e0       	ldi	r17, 0x00	; 0
    47ee:	11 23       	and	r17, r17
    47f0:	19 f0       	breq	.+6      	; 0x47f8 <chb_reset+0x8c>
		__ticks = 1;
    47f2:	81 e0       	ldi	r24, 0x01	; 1
    47f4:	89 87       	std	Y+9, r24	; 0x09
    47f6:	a3 c0       	rjmp	.+326    	; 0x493e <chb_reset+0x1d2>
	else if (__tmp > 255)
    47f8:	11 e0       	ldi	r17, 0x01	; 1
    47fa:	6d 81       	ldd	r22, Y+5	; 0x05
    47fc:	7e 81       	ldd	r23, Y+6	; 0x06
    47fe:	8f 81       	ldd	r24, Y+7	; 0x07
    4800:	98 85       	ldd	r25, Y+8	; 0x08
    4802:	20 e0       	ldi	r18, 0x00	; 0
    4804:	30 e0       	ldi	r19, 0x00	; 0
    4806:	4f e7       	ldi	r20, 0x7F	; 127
    4808:	53 e4       	ldi	r21, 0x43	; 67
    480a:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    480e:	18 16       	cp	r1, r24
    4810:	0c f0       	brlt	.+2      	; 0x4814 <chb_reset+0xa8>
    4812:	10 e0       	ldi	r17, 0x00	; 0
    4814:	11 23       	and	r17, r17
    4816:	09 f4       	brne	.+2      	; 0x481a <chb_reset+0xae>
    4818:	89 c0       	rjmp	.+274    	; 0x492c <chb_reset+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    481a:	69 81       	ldd	r22, Y+1	; 0x01
    481c:	7a 81       	ldd	r23, Y+2	; 0x02
    481e:	8b 81       	ldd	r24, Y+3	; 0x03
    4820:	9c 81       	ldd	r25, Y+4	; 0x04
    4822:	20 e0       	ldi	r18, 0x00	; 0
    4824:	30 e0       	ldi	r19, 0x00	; 0
    4826:	4a e7       	ldi	r20, 0x7A	; 122
    4828:	54 e4       	ldi	r21, 0x44	; 68
    482a:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
    482e:	dc 01       	movw	r26, r24
    4830:	cb 01       	movw	r24, r22
    4832:	8a 87       	std	Y+10, r24	; 0x0a
    4834:	9b 87       	std	Y+11, r25	; 0x0b
    4836:	ac 87       	std	Y+12, r26	; 0x0c
    4838:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    483a:	6a 85       	ldd	r22, Y+10	; 0x0a
    483c:	7b 85       	ldd	r23, Y+11	; 0x0b
    483e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4840:	9d 85       	ldd	r25, Y+13	; 0x0d
    4842:	20 e0       	ldi	r18, 0x00	; 0
    4844:	30 e0       	ldi	r19, 0x00	; 0
    4846:	4a e7       	ldi	r20, 0x7A	; 122
    4848:	53 e4       	ldi	r21, 0x43	; 67
    484a:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    484e:	dc 01       	movw	r26, r24
    4850:	cb 01       	movw	r24, r22
    4852:	8e 87       	std	Y+14, r24	; 0x0e
    4854:	9f 87       	std	Y+15, r25	; 0x0f
    4856:	a8 8b       	std	Y+16, r26	; 0x10
    4858:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    485a:	11 e0       	ldi	r17, 0x01	; 1
    485c:	6e 85       	ldd	r22, Y+14	; 0x0e
    485e:	7f 85       	ldd	r23, Y+15	; 0x0f
    4860:	88 89       	ldd	r24, Y+16	; 0x10
    4862:	99 89       	ldd	r25, Y+17	; 0x11
    4864:	20 e0       	ldi	r18, 0x00	; 0
    4866:	30 e0       	ldi	r19, 0x00	; 0
    4868:	40 e8       	ldi	r20, 0x80	; 128
    486a:	5f e3       	ldi	r21, 0x3F	; 63
    486c:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    4870:	88 23       	and	r24, r24
    4872:	0c f0       	brlt	.+2      	; 0x4876 <chb_reset+0x10a>
    4874:	10 e0       	ldi	r17, 0x00	; 0
    4876:	11 23       	and	r17, r17
    4878:	29 f0       	breq	.+10     	; 0x4884 <chb_reset+0x118>
		__ticks = 1;
    487a:	81 e0       	ldi	r24, 0x01	; 1
    487c:	90 e0       	ldi	r25, 0x00	; 0
    487e:	8a 8b       	std	Y+18, r24	; 0x12
    4880:	9b 8b       	std	Y+19, r25	; 0x13
    4882:	46 c0       	rjmp	.+140    	; 0x4910 <chb_reset+0x1a4>
	else if (__tmp > 65535)
    4884:	11 e0       	ldi	r17, 0x01	; 1
    4886:	6e 85       	ldd	r22, Y+14	; 0x0e
    4888:	7f 85       	ldd	r23, Y+15	; 0x0f
    488a:	88 89       	ldd	r24, Y+16	; 0x10
    488c:	99 89       	ldd	r25, Y+17	; 0x11
    488e:	20 e0       	ldi	r18, 0x00	; 0
    4890:	3f ef       	ldi	r19, 0xFF	; 255
    4892:	4f e7       	ldi	r20, 0x7F	; 127
    4894:	57 e4       	ldi	r21, 0x47	; 71
    4896:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    489a:	18 16       	cp	r1, r24
    489c:	0c f0       	brlt	.+2      	; 0x48a0 <chb_reset+0x134>
    489e:	10 e0       	ldi	r17, 0x00	; 0
    48a0:	11 23       	and	r17, r17
    48a2:	61 f1       	breq	.+88     	; 0x48fc <chb_reset+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    48a4:	6a 85       	ldd	r22, Y+10	; 0x0a
    48a6:	7b 85       	ldd	r23, Y+11	; 0x0b
    48a8:	8c 85       	ldd	r24, Y+12	; 0x0c
    48aa:	9d 85       	ldd	r25, Y+13	; 0x0d
    48ac:	20 e0       	ldi	r18, 0x00	; 0
    48ae:	30 e0       	ldi	r19, 0x00	; 0
    48b0:	40 e2       	ldi	r20, 0x20	; 32
    48b2:	51 e4       	ldi	r21, 0x41	; 65
    48b4:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    48b8:	dc 01       	movw	r26, r24
    48ba:	cb 01       	movw	r24, r22
    48bc:	bc 01       	movw	r22, r24
    48be:	cd 01       	movw	r24, r26
    48c0:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    48c4:	dc 01       	movw	r26, r24
    48c6:	cb 01       	movw	r24, r22
    48c8:	8a 8b       	std	Y+18, r24	; 0x12
    48ca:	9b 8b       	std	Y+19, r25	; 0x13
    48cc:	12 c0       	rjmp	.+36     	; 0x48f2 <chb_reset+0x186>
    48ce:	89 e1       	ldi	r24, 0x19	; 25
    48d0:	90 e0       	ldi	r25, 0x00	; 0
    48d2:	8c 8b       	std	Y+20, r24	; 0x14
    48d4:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    48d6:	8c 89       	ldd	r24, Y+20	; 0x14
    48d8:	9d 89       	ldd	r25, Y+21	; 0x15
    48da:	8c 01       	movw	r16, r24
    48dc:	c8 01       	movw	r24, r16
    48de:	01 97       	sbiw	r24, 0x01	; 1
    48e0:	f1 f7       	brne	.-4      	; 0x48de <chb_reset+0x172>
    48e2:	8c 01       	movw	r16, r24
    48e4:	0c 8b       	std	Y+20, r16	; 0x14
    48e6:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    48e8:	8a 89       	ldd	r24, Y+18	; 0x12
    48ea:	9b 89       	ldd	r25, Y+19	; 0x13
    48ec:	01 97       	sbiw	r24, 0x01	; 1
    48ee:	8a 8b       	std	Y+18, r24	; 0x12
    48f0:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    48f2:	8a 89       	ldd	r24, Y+18	; 0x12
    48f4:	9b 89       	ldd	r25, Y+19	; 0x13
    48f6:	00 97       	sbiw	r24, 0x00	; 0
    48f8:	51 f7       	brne	.-44     	; 0x48ce <chb_reset+0x162>
    48fa:	28 c0       	rjmp	.+80     	; 0x494c <chb_reset+0x1e0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    48fc:	6e 85       	ldd	r22, Y+14	; 0x0e
    48fe:	7f 85       	ldd	r23, Y+15	; 0x0f
    4900:	88 89       	ldd	r24, Y+16	; 0x10
    4902:	99 89       	ldd	r25, Y+17	; 0x11
    4904:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    4908:	dc 01       	movw	r26, r24
    490a:	cb 01       	movw	r24, r22
    490c:	8a 8b       	std	Y+18, r24	; 0x12
    490e:	9b 8b       	std	Y+19, r25	; 0x13
    4910:	8a 89       	ldd	r24, Y+18	; 0x12
    4912:	9b 89       	ldd	r25, Y+19	; 0x13
    4914:	8e 8b       	std	Y+22, r24	; 0x16
    4916:	9f 8b       	std	Y+23, r25	; 0x17
    4918:	8e 89       	ldd	r24, Y+22	; 0x16
    491a:	9f 89       	ldd	r25, Y+23	; 0x17
    491c:	8c 01       	movw	r16, r24
    491e:	f8 01       	movw	r30, r16
    4920:	31 97       	sbiw	r30, 0x01	; 1
    4922:	f1 f7       	brne	.-4      	; 0x4920 <chb_reset+0x1b4>
    4924:	8f 01       	movw	r16, r30
    4926:	0e 8b       	std	Y+22, r16	; 0x16
    4928:	1f 8b       	std	Y+23, r17	; 0x17
    492a:	10 c0       	rjmp	.+32     	; 0x494c <chb_reset+0x1e0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    492c:	6d 81       	ldd	r22, Y+5	; 0x05
    492e:	7e 81       	ldd	r23, Y+6	; 0x06
    4930:	8f 81       	ldd	r24, Y+7	; 0x07
    4932:	98 85       	ldd	r25, Y+8	; 0x08
    4934:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    4938:	dc 01       	movw	r26, r24
    493a:	cb 01       	movw	r24, r22
    493c:	89 87       	std	Y+9, r24	; 0x09
    493e:	89 85       	ldd	r24, Y+9	; 0x09
    4940:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4942:	88 8d       	ldd	r24, Y+24	; 0x18
    4944:	18 2f       	mov	r17, r24
    4946:	1a 95       	dec	r17
    4948:	f1 f7       	brne	.-4      	; 0x4946 <chb_reset+0x1da>
    494a:	18 8f       	std	Y+24, r17	; 0x18

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    494c:	84 e6       	ldi	r24, 0x64	; 100
    494e:	96 e0       	ldi	r25, 0x06	; 6
    4950:	24 e6       	ldi	r18, 0x64	; 100
    4952:	36 e0       	ldi	r19, 0x06	; 6
    4954:	f9 01       	movw	r30, r18
    4956:	20 81       	ld	r18, Z
    4958:	2e 7f       	andi	r18, 0xFE	; 254
    495a:	fc 01       	movw	r30, r24
    495c:	20 83       	st	Z, r18
    495e:	80 e0       	ldi	r24, 0x00	; 0
    4960:	90 e0       	ldi	r25, 0x00	; 0
    4962:	a0 e8       	ldi	r26, 0x80	; 128
    4964:	bf e3       	ldi	r27, 0x3F	; 63
    4966:	89 8f       	std	Y+25, r24	; 0x19
    4968:	9a 8f       	std	Y+26, r25	; 0x1a
    496a:	ab 8f       	std	Y+27, r26	; 0x1b
    496c:	bc 8f       	std	Y+28, r27	; 0x1c
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    496e:	69 8d       	ldd	r22, Y+25	; 0x19
    4970:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4972:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4974:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4976:	2b ea       	ldi	r18, 0xAB	; 171
    4978:	3a ea       	ldi	r19, 0xAA	; 170
    497a:	4a ea       	ldi	r20, 0xAA	; 170
    497c:	5e e3       	ldi	r21, 0x3E	; 62
    497e:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    4982:	dc 01       	movw	r26, r24
    4984:	cb 01       	movw	r24, r22
    4986:	8d 8f       	std	Y+29, r24	; 0x1d
    4988:	9e 8f       	std	Y+30, r25	; 0x1e
    498a:	af 8f       	std	Y+31, r26	; 0x1f
    498c:	b8 a3       	lds	r27, 0x58
	if (__tmp < 1.0)
    498e:	11 e0       	ldi	r17, 0x01	; 1
    4990:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4992:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4994:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4996:	98 a1       	lds	r25, 0x48
    4998:	20 e0       	ldi	r18, 0x00	; 0
    499a:	30 e0       	ldi	r19, 0x00	; 0
    499c:	40 e8       	ldi	r20, 0x80	; 128
    499e:	5f e3       	ldi	r21, 0x3F	; 63
    49a0:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    49a4:	88 23       	and	r24, r24
    49a6:	0c f0       	brlt	.+2      	; 0x49aa <chb_reset+0x23e>
    49a8:	10 e0       	ldi	r17, 0x00	; 0
    49aa:	11 23       	and	r17, r17
    49ac:	19 f0       	breq	.+6      	; 0x49b4 <chb_reset+0x248>
		__ticks = 1;
    49ae:	81 e0       	ldi	r24, 0x01	; 1
    49b0:	89 a3       	lds	r24, 0x59
    49b2:	a3 c0       	rjmp	.+326    	; 0x4afa <chb_reset+0x38e>
	else if (__tmp > 255)
    49b4:	11 e0       	ldi	r17, 0x01	; 1
    49b6:	6d 8d       	ldd	r22, Y+29	; 0x1d
    49b8:	7e 8d       	ldd	r23, Y+30	; 0x1e
    49ba:	8f 8d       	ldd	r24, Y+31	; 0x1f
    49bc:	98 a1       	lds	r25, 0x48
    49be:	20 e0       	ldi	r18, 0x00	; 0
    49c0:	30 e0       	ldi	r19, 0x00	; 0
    49c2:	4f e7       	ldi	r20, 0x7F	; 127
    49c4:	53 e4       	ldi	r21, 0x43	; 67
    49c6:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    49ca:	18 16       	cp	r1, r24
    49cc:	0c f0       	brlt	.+2      	; 0x49d0 <chb_reset+0x264>
    49ce:	10 e0       	ldi	r17, 0x00	; 0
    49d0:	11 23       	and	r17, r17
    49d2:	09 f4       	brne	.+2      	; 0x49d6 <chb_reset+0x26a>
    49d4:	89 c0       	rjmp	.+274    	; 0x4ae8 <chb_reset+0x37c>
	{
		_delay_ms(__us / 1000.0);
    49d6:	69 8d       	ldd	r22, Y+25	; 0x19
    49d8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    49da:	8b 8d       	ldd	r24, Y+27	; 0x1b
    49dc:	9c 8d       	ldd	r25, Y+28	; 0x1c
    49de:	20 e0       	ldi	r18, 0x00	; 0
    49e0:	30 e0       	ldi	r19, 0x00	; 0
    49e2:	4a e7       	ldi	r20, 0x7A	; 122
    49e4:	54 e4       	ldi	r21, 0x44	; 68
    49e6:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
    49ea:	dc 01       	movw	r26, r24
    49ec:	cb 01       	movw	r24, r22
    49ee:	8a a3       	lds	r24, 0x5a
    49f0:	9b a3       	lds	r25, 0x5b
    49f2:	ac a3       	lds	r26, 0x5c
    49f4:	bd a3       	lds	r27, 0x5d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    49f6:	6a a1       	lds	r22, 0x4a
    49f8:	7b a1       	lds	r23, 0x4b
    49fa:	8c a1       	lds	r24, 0x4c
    49fc:	9d a1       	lds	r25, 0x4d
    49fe:	20 e0       	ldi	r18, 0x00	; 0
    4a00:	30 e0       	ldi	r19, 0x00	; 0
    4a02:	4a e7       	ldi	r20, 0x7A	; 122
    4a04:	53 e4       	ldi	r21, 0x43	; 67
    4a06:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    4a0a:	dc 01       	movw	r26, r24
    4a0c:	cb 01       	movw	r24, r22
    4a0e:	8e a3       	lds	r24, 0x5e
    4a10:	9f a3       	lds	r25, 0x5f
    4a12:	a8 a7       	lds	r26, 0x78
    4a14:	b9 a7       	lds	r27, 0x79
	if (__tmp < 1.0)
    4a16:	11 e0       	ldi	r17, 0x01	; 1
    4a18:	6e a1       	lds	r22, 0x4e
    4a1a:	7f a1       	lds	r23, 0x4f
    4a1c:	88 a5       	lds	r24, 0x68
    4a1e:	99 a5       	lds	r25, 0x69
    4a20:	20 e0       	ldi	r18, 0x00	; 0
    4a22:	30 e0       	ldi	r19, 0x00	; 0
    4a24:	40 e8       	ldi	r20, 0x80	; 128
    4a26:	5f e3       	ldi	r21, 0x3F	; 63
    4a28:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    4a2c:	88 23       	and	r24, r24
    4a2e:	0c f0       	brlt	.+2      	; 0x4a32 <chb_reset+0x2c6>
    4a30:	10 e0       	ldi	r17, 0x00	; 0
    4a32:	11 23       	and	r17, r17
    4a34:	29 f0       	breq	.+10     	; 0x4a40 <chb_reset+0x2d4>
		__ticks = 1;
    4a36:	81 e0       	ldi	r24, 0x01	; 1
    4a38:	90 e0       	ldi	r25, 0x00	; 0
    4a3a:	8a a7       	lds	r24, 0x7a
    4a3c:	9b a7       	lds	r25, 0x7b
    4a3e:	46 c0       	rjmp	.+140    	; 0x4acc <chb_reset+0x360>
	else if (__tmp > 65535)
    4a40:	11 e0       	ldi	r17, 0x01	; 1
    4a42:	6e a1       	lds	r22, 0x4e
    4a44:	7f a1       	lds	r23, 0x4f
    4a46:	88 a5       	lds	r24, 0x68
    4a48:	99 a5       	lds	r25, 0x69
    4a4a:	20 e0       	ldi	r18, 0x00	; 0
    4a4c:	3f ef       	ldi	r19, 0xFF	; 255
    4a4e:	4f e7       	ldi	r20, 0x7F	; 127
    4a50:	57 e4       	ldi	r21, 0x47	; 71
    4a52:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    4a56:	18 16       	cp	r1, r24
    4a58:	0c f0       	brlt	.+2      	; 0x4a5c <chb_reset+0x2f0>
    4a5a:	10 e0       	ldi	r17, 0x00	; 0
    4a5c:	11 23       	and	r17, r17
    4a5e:	61 f1       	breq	.+88     	; 0x4ab8 <chb_reset+0x34c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4a60:	6a a1       	lds	r22, 0x4a
    4a62:	7b a1       	lds	r23, 0x4b
    4a64:	8c a1       	lds	r24, 0x4c
    4a66:	9d a1       	lds	r25, 0x4d
    4a68:	20 e0       	ldi	r18, 0x00	; 0
    4a6a:	30 e0       	ldi	r19, 0x00	; 0
    4a6c:	40 e2       	ldi	r20, 0x20	; 32
    4a6e:	51 e4       	ldi	r21, 0x41	; 65
    4a70:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    4a74:	dc 01       	movw	r26, r24
    4a76:	cb 01       	movw	r24, r22
    4a78:	bc 01       	movw	r22, r24
    4a7a:	cd 01       	movw	r24, r26
    4a7c:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    4a80:	dc 01       	movw	r26, r24
    4a82:	cb 01       	movw	r24, r22
    4a84:	8a a7       	lds	r24, 0x7a
    4a86:	9b a7       	lds	r25, 0x7b
    4a88:	12 c0       	rjmp	.+36     	; 0x4aae <chb_reset+0x342>
    4a8a:	89 e1       	ldi	r24, 0x19	; 25
    4a8c:	90 e0       	ldi	r25, 0x00	; 0
    4a8e:	8c a7       	lds	r24, 0x7c
    4a90:	9d a7       	lds	r25, 0x7d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4a92:	8c a5       	lds	r24, 0x6c
    4a94:	9d a5       	lds	r25, 0x6d
    4a96:	8c 01       	movw	r16, r24
    4a98:	c8 01       	movw	r24, r16
    4a9a:	01 97       	sbiw	r24, 0x01	; 1
    4a9c:	f1 f7       	brne	.-4      	; 0x4a9a <chb_reset+0x32e>
    4a9e:	8c 01       	movw	r16, r24
    4aa0:	0c a7       	lds	r16, 0x7c
    4aa2:	1d a7       	lds	r17, 0x7d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4aa4:	8a a5       	lds	r24, 0x6a
    4aa6:	9b a5       	lds	r25, 0x6b
    4aa8:	01 97       	sbiw	r24, 0x01	; 1
    4aaa:	8a a7       	lds	r24, 0x7a
    4aac:	9b a7       	lds	r25, 0x7b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4aae:	8a a5       	lds	r24, 0x6a
    4ab0:	9b a5       	lds	r25, 0x6b
    4ab2:	00 97       	sbiw	r24, 0x00	; 0
    4ab4:	51 f7       	brne	.-44     	; 0x4a8a <chb_reset+0x31e>
    4ab6:	28 c0       	rjmp	.+80     	; 0x4b08 <chb_reset+0x39c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4ab8:	6e a1       	lds	r22, 0x4e
    4aba:	7f a1       	lds	r23, 0x4f
    4abc:	88 a5       	lds	r24, 0x68
    4abe:	99 a5       	lds	r25, 0x69
    4ac0:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    4ac4:	dc 01       	movw	r26, r24
    4ac6:	cb 01       	movw	r24, r22
    4ac8:	8a a7       	lds	r24, 0x7a
    4aca:	9b a7       	lds	r25, 0x7b
    4acc:	8a a5       	lds	r24, 0x6a
    4ace:	9b a5       	lds	r25, 0x6b
    4ad0:	8e a7       	lds	r24, 0x7e
    4ad2:	9f a7       	lds	r25, 0x7f
    4ad4:	8e a5       	lds	r24, 0x6e
    4ad6:	9f a5       	lds	r25, 0x6f
    4ad8:	8c 01       	movw	r16, r24
    4ada:	f8 01       	movw	r30, r16
    4adc:	31 97       	sbiw	r30, 0x01	; 1
    4ade:	f1 f7       	brne	.-4      	; 0x4adc <chb_reset+0x370>
    4ae0:	8f 01       	movw	r16, r30
    4ae2:	0e a7       	lds	r16, 0x7e
    4ae4:	1f a7       	lds	r17, 0x7f
    4ae6:	10 c0       	rjmp	.+32     	; 0x4b08 <chb_reset+0x39c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4ae8:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4aea:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4aec:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4aee:	98 a1       	lds	r25, 0x48
    4af0:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    4af4:	dc 01       	movw	r26, r24
    4af6:	cb 01       	movw	r24, r22
    4af8:	89 a3       	lds	r24, 0x59
    4afa:	89 a1       	lds	r24, 0x49
    4afc:	88 ab       	sts	0x58, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4afe:	88 a9       	sts	0x48, r24
    4b00:	18 2f       	mov	r17, r24
    4b02:	1a 95       	dec	r17
    4b04:	f1 f7       	brne	.-4      	; 0x4b02 <chb_reset+0x396>
    4b06:	18 ab       	sts	0x58, r17
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    4b08:	84 e6       	ldi	r24, 0x64	; 100
    4b0a:	96 e0       	ldi	r25, 0x06	; 6
    4b0c:	24 e6       	ldi	r18, 0x64	; 100
    4b0e:	36 e0       	ldi	r19, 0x06	; 6
    4b10:	f9 01       	movw	r30, r18
    4b12:	20 81       	ld	r18, Z
    4b14:	21 60       	ori	r18, 0x01	; 1
    4b16:	fc 01       	movw	r30, r24
    4b18:	20 83       	st	Z, r18
    4b1a:	01 c0       	rjmp	.+2      	; 0x4b1e <chb_reset+0x3b2>
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
        {
            break;
        }
    }
    4b1c:	00 00       	nop
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    4b1e:	8d e1       	ldi	r24, 0x1D	; 29
    4b20:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <chb_reg_read>
    4b24:	81 30       	cpi	r24, 0x01	; 1
    4b26:	d1 f7       	brne	.-12     	; 0x4b1c <chb_reset+0x3b0>
    4b28:	8c e1       	ldi	r24, 0x1C	; 28
    4b2a:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <chb_reg_read>
    4b2e:	87 30       	cpi	r24, 0x07	; 7
    4b30:	a9 f7       	brne	.-22     	; 0x4b1c <chb_reset+0x3b0>
        {
            break;
    4b32:	00 00       	nop
        }
    }
	

}
    4b34:	e0 96       	adiw	r28, 0x30	; 48
    4b36:	cd bf       	out	0x3d, r28	; 61
    4b38:	de bf       	out	0x3e, r29	; 62
    4b3a:	df 91       	pop	r29
    4b3c:	cf 91       	pop	r28
    4b3e:	1f 91       	pop	r17
    4b40:	0f 91       	pop	r16
    4b42:	08 95       	ret

00004b44 <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    4b44:	cf 93       	push	r28
    4b46:	df 93       	push	r29
    4b48:	0f 92       	push	r0
    4b4a:	0f 92       	push	r0
    4b4c:	cd b7       	in	r28, 0x3d	; 61
    4b4e:	de b7       	in	r29, 0x3e	; 62
    4b50:	8a 83       	std	Y+2, r24	; 0x02
    U8 val = 0;
    4b52:	19 82       	std	Y+1, r1	; 0x01

    /* Add the register read command to the register address. */
    addr |= 0x80;
    4b54:	8a 81       	ldd	r24, Y+2	; 0x02
    4b56:	80 68       	ori	r24, 0x80	; 128
    4b58:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    4b5a:	8f e3       	ldi	r24, 0x3F	; 63
    4b5c:	90 e0       	ldi	r25, 0x00	; 0
    4b5e:	fc 01       	movw	r30, r24
    4b60:	80 81       	ld	r24, Z
    4b62:	80 93 57 40 	sts	0x4057, r24
    4b66:	f8 94       	cli
    RadioCS(TRUE);
    4b68:	81 e0       	ldi	r24, 0x01	; 1
    4b6a:	0e 94 27 31 	call	0x624e	; 0x624e <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    4b6e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b70:	0e 94 84 32 	call	0x6508	; 0x6508 <SPID_write>
    4b74:	89 83       	std	Y+1, r24	; 0x01
    val = SPID_write(val);
    4b76:	89 81       	ldd	r24, Y+1	; 0x01
    4b78:	0e 94 84 32 	call	0x6508	; 0x6508 <SPID_write>
    4b7c:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    4b7e:	80 e0       	ldi	r24, 0x00	; 0
    4b80:	0e 94 27 31 	call	0x624e	; 0x624e <RadioCS>
    CHB_LEAVE_CRIT();
    4b84:	8f e3       	ldi	r24, 0x3F	; 63
    4b86:	90 e0       	ldi	r25, 0x00	; 0
    4b88:	20 91 57 40 	lds	r18, 0x4057
    4b8c:	fc 01       	movw	r30, r24
    4b8e:	20 83       	st	Z, r18
    4b90:	78 94       	sei

    return val;
    4b92:	89 81       	ldd	r24, Y+1	; 0x01
}
    4b94:	0f 90       	pop	r0
    4b96:	0f 90       	pop	r0
    4b98:	df 91       	pop	r29
    4b9a:	cf 91       	pop	r28
    4b9c:	08 95       	ret

00004b9e <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    4b9e:	cf 93       	push	r28
    4ba0:	df 93       	push	r29
    4ba2:	00 d0       	rcall	.+0      	; 0x4ba4 <chb_reg_read16+0x6>
    4ba4:	0f 92       	push	r0
    4ba6:	cd b7       	in	r28, 0x3d	; 61
    4ba8:	de b7       	in	r29, 0x3e	; 62
    4baa:	8c 83       	std	Y+4, r24	; 0x04
    U8 i;
    U16 val = 0;
    4bac:	1a 82       	std	Y+2, r1	; 0x02
    4bae:	1b 82       	std	Y+3, r1	; 0x03

    for (i=0; i<2; i++)
    4bb0:	19 82       	std	Y+1, r1	; 0x01
    4bb2:	1d c0       	rjmp	.+58     	; 0x4bee <chb_reg_read16+0x50>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    4bb4:	9c 81       	ldd	r25, Y+4	; 0x04
    4bb6:	89 81       	ldd	r24, Y+1	; 0x01
    4bb8:	89 0f       	add	r24, r25
    4bba:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <chb_reg_read>
    4bbe:	88 2f       	mov	r24, r24
    4bc0:	90 e0       	ldi	r25, 0x00	; 0
    4bc2:	29 81       	ldd	r18, Y+1	; 0x01
    4bc4:	22 2f       	mov	r18, r18
    4bc6:	30 e0       	ldi	r19, 0x00	; 0
    4bc8:	22 0f       	add	r18, r18
    4bca:	33 1f       	adc	r19, r19
    4bcc:	22 0f       	add	r18, r18
    4bce:	33 1f       	adc	r19, r19
    4bd0:	22 0f       	add	r18, r18
    4bd2:	33 1f       	adc	r19, r19
    4bd4:	02 2e       	mov	r0, r18
    4bd6:	02 c0       	rjmp	.+4      	; 0x4bdc <chb_reg_read16+0x3e>
    4bd8:	88 0f       	add	r24, r24
    4bda:	99 1f       	adc	r25, r25
    4bdc:	0a 94       	dec	r0
    4bde:	e2 f7       	brpl	.-8      	; 0x4bd8 <chb_reg_read16+0x3a>
    4be0:	98 2f       	mov	r25, r24
    4be2:	8c 81       	ldd	r24, Y+4	; 0x04
    4be4:	89 2b       	or	r24, r25
    4be6:	8c 83       	std	Y+4, r24	; 0x04
U16 chb_reg_read16(U8 addr)
{
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    4be8:	89 81       	ldd	r24, Y+1	; 0x01
    4bea:	8f 5f       	subi	r24, 0xFF	; 255
    4bec:	89 83       	std	Y+1, r24	; 0x01
    4bee:	89 81       	ldd	r24, Y+1	; 0x01
    4bf0:	82 30       	cpi	r24, 0x02	; 2
    4bf2:	00 f3       	brcs	.-64     	; 0x4bb4 <chb_reg_read16+0x16>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    }
    return val;
    4bf4:	8a 81       	ldd	r24, Y+2	; 0x02
    4bf6:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4bf8:	24 96       	adiw	r28, 0x04	; 4
    4bfa:	cd bf       	out	0x3d, r28	; 61
    4bfc:	de bf       	out	0x3e, r29	; 62
    4bfe:	df 91       	pop	r29
    4c00:	cf 91       	pop	r28
    4c02:	08 95       	ret

00004c04 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    4c04:	cf 93       	push	r28
    4c06:	df 93       	push	r29
    4c08:	00 d0       	rcall	.+0      	; 0x4c0a <chb_reg_write+0x6>
    4c0a:	cd b7       	in	r28, 0x3d	; 61
    4c0c:	de b7       	in	r29, 0x3e	; 62
    4c0e:	8a 83       	std	Y+2, r24	; 0x02
    4c10:	6b 83       	std	Y+3, r22	; 0x03
    U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;
    4c12:	8a 81       	ldd	r24, Y+2	; 0x02
    4c14:	80 6c       	ori	r24, 0xC0	; 192
    4c16:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    4c18:	8f e3       	ldi	r24, 0x3F	; 63
    4c1a:	90 e0       	ldi	r25, 0x00	; 0
    4c1c:	fc 01       	movw	r30, r24
    4c1e:	80 81       	ld	r24, Z
    4c20:	80 93 57 40 	sts	0x4057, r24
    4c24:	f8 94       	cli
    RadioCS(TRUE);
    4c26:	81 e0       	ldi	r24, 0x01	; 1
    4c28:	0e 94 27 31 	call	0x624e	; 0x624e <RadioCS>

    /*Send Register address and write register content.*/
    dummy = SPID_write(addr);
    4c2c:	8a 81       	ldd	r24, Y+2	; 0x02
    4c2e:	0e 94 84 32 	call	0x6508	; 0x6508 <SPID_write>
    4c32:	89 83       	std	Y+1, r24	; 0x01
    dummy = SPID_write(val);
    4c34:	8b 81       	ldd	r24, Y+3	; 0x03
    4c36:	0e 94 84 32 	call	0x6508	; 0x6508 <SPID_write>
    4c3a:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    4c3c:	80 e0       	ldi	r24, 0x00	; 0
    4c3e:	0e 94 27 31 	call	0x624e	; 0x624e <RadioCS>
    CHB_LEAVE_CRIT();
    4c42:	8f e3       	ldi	r24, 0x3F	; 63
    4c44:	90 e0       	ldi	r25, 0x00	; 0
    4c46:	20 91 57 40 	lds	r18, 0x4057
    4c4a:	fc 01       	movw	r30, r24
    4c4c:	20 83       	st	Z, r18
    4c4e:	78 94       	sei
}
    4c50:	23 96       	adiw	r28, 0x03	; 3
    4c52:	cd bf       	out	0x3d, r28	; 61
    4c54:	de bf       	out	0x3e, r29	; 62
    4c56:	df 91       	pop	r29
    4c58:	cf 91       	pop	r28
    4c5a:	08 95       	ret

00004c5c <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    4c5c:	cf 93       	push	r28
    4c5e:	df 93       	push	r29
    4c60:	00 d0       	rcall	.+0      	; 0x4c62 <chb_reg_write16+0x6>
    4c62:	0f 92       	push	r0
    4c64:	cd b7       	in	r28, 0x3d	; 61
    4c66:	de b7       	in	r29, 0x3e	; 62
    4c68:	8a 83       	std	Y+2, r24	; 0x02
    4c6a:	6b 83       	std	Y+3, r22	; 0x03
    4c6c:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<2; i++)
    4c6e:	19 82       	std	Y+1, r1	; 0x01
    4c70:	1d c0       	rjmp	.+58     	; 0x4cac <chb_reg_write16+0x50>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    4c72:	9a 81       	ldd	r25, Y+2	; 0x02
    4c74:	89 81       	ldd	r24, Y+1	; 0x01
    4c76:	49 2f       	mov	r20, r25
    4c78:	48 0f       	add	r20, r24
    4c7a:	89 81       	ldd	r24, Y+1	; 0x01
    4c7c:	88 2f       	mov	r24, r24
    4c7e:	90 e0       	ldi	r25, 0x00	; 0
    4c80:	9c 01       	movw	r18, r24
    4c82:	22 0f       	add	r18, r18
    4c84:	33 1f       	adc	r19, r19
    4c86:	22 0f       	add	r18, r18
    4c88:	33 1f       	adc	r19, r19
    4c8a:	22 0f       	add	r18, r18
    4c8c:	33 1f       	adc	r19, r19
    4c8e:	8b 81       	ldd	r24, Y+3	; 0x03
    4c90:	9c 81       	ldd	r25, Y+4	; 0x04
    4c92:	02 c0       	rjmp	.+4      	; 0x4c98 <chb_reg_write16+0x3c>
    4c94:	96 95       	lsr	r25
    4c96:	87 95       	ror	r24
    4c98:	2a 95       	dec	r18
    4c9a:	e2 f7       	brpl	.-8      	; 0x4c94 <chb_reg_write16+0x38>
    4c9c:	98 2f       	mov	r25, r24
    4c9e:	84 2f       	mov	r24, r20
    4ca0:	69 2f       	mov	r22, r25
    4ca2:	0e 94 02 26 	call	0x4c04	; 0x4c04 <chb_reg_write>
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    U8 i;

    for (i=0; i<2; i++)
    4ca6:	89 81       	ldd	r24, Y+1	; 0x01
    4ca8:	8f 5f       	subi	r24, 0xFF	; 255
    4caa:	89 83       	std	Y+1, r24	; 0x01
    4cac:	89 81       	ldd	r24, Y+1	; 0x01
    4cae:	82 30       	cpi	r24, 0x02	; 2
    4cb0:	00 f3       	brcs	.-64     	; 0x4c72 <chb_reg_write16+0x16>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    }
}
    4cb2:	24 96       	adiw	r28, 0x04	; 4
    4cb4:	cd bf       	out	0x3d, r28	; 61
    4cb6:	de bf       	out	0x3e, r29	; 62
    4cb8:	df 91       	pop	r29
    4cba:	cf 91       	pop	r28
    4cbc:	08 95       	ret

00004cbe <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    4cbe:	cf 93       	push	r28
    4cc0:	df 93       	push	r29
    4cc2:	00 d0       	rcall	.+0      	; 0x4cc4 <chb_reg_write64+0x6>
    4cc4:	0f 92       	push	r0
    4cc6:	cd b7       	in	r28, 0x3d	; 61
    4cc8:	de b7       	in	r29, 0x3e	; 62
    4cca:	8a 83       	std	Y+2, r24	; 0x02
    4ccc:	6b 83       	std	Y+3, r22	; 0x03
    4cce:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<8; i++)
    4cd0:	19 82       	std	Y+1, r1	; 0x01
    4cd2:	14 c0       	rjmp	.+40     	; 0x4cfc <chb_reg_write64+0x3e>
    {
        chb_reg_write(addr + i, *(val + i));
    4cd4:	9a 81       	ldd	r25, Y+2	; 0x02
    4cd6:	89 81       	ldd	r24, Y+1	; 0x01
    4cd8:	49 2f       	mov	r20, r25
    4cda:	48 0f       	add	r20, r24
    4cdc:	89 81       	ldd	r24, Y+1	; 0x01
    4cde:	88 2f       	mov	r24, r24
    4ce0:	90 e0       	ldi	r25, 0x00	; 0
    4ce2:	2b 81       	ldd	r18, Y+3	; 0x03
    4ce4:	3c 81       	ldd	r19, Y+4	; 0x04
    4ce6:	82 0f       	add	r24, r18
    4ce8:	93 1f       	adc	r25, r19
    4cea:	fc 01       	movw	r30, r24
    4cec:	90 81       	ld	r25, Z
    4cee:	84 2f       	mov	r24, r20
    4cf0:	69 2f       	mov	r22, r25
    4cf2:	0e 94 02 26 	call	0x4c04	; 0x4c04 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    4cf6:	89 81       	ldd	r24, Y+1	; 0x01
    4cf8:	8f 5f       	subi	r24, 0xFF	; 255
    4cfa:	89 83       	std	Y+1, r24	; 0x01
    4cfc:	89 81       	ldd	r24, Y+1	; 0x01
    4cfe:	88 30       	cpi	r24, 0x08	; 8
    4d00:	48 f3       	brcs	.-46     	; 0x4cd4 <chb_reg_write64+0x16>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    4d02:	24 96       	adiw	r28, 0x04	; 4
    4d04:	cd bf       	out	0x3d, r28	; 61
    4d06:	de bf       	out	0x3e, r29	; 62
    4d08:	df 91       	pop	r29
    4d0a:	cf 91       	pop	r28
    4d0c:	08 95       	ret

00004d0e <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    4d0e:	cf 93       	push	r28
    4d10:	df 93       	push	r29
    4d12:	00 d0       	rcall	.+0      	; 0x4d14 <chb_reg_read_mod_write+0x6>
    4d14:	0f 92       	push	r0
    4d16:	cd b7       	in	r28, 0x3d	; 61
    4d18:	de b7       	in	r29, 0x3e	; 62
    4d1a:	8a 83       	std	Y+2, r24	; 0x02
    4d1c:	6b 83       	std	Y+3, r22	; 0x03
    4d1e:	4c 83       	std	Y+4, r20	; 0x04
    U8 tmp;

    tmp = chb_reg_read(addr);
    4d20:	8a 81       	ldd	r24, Y+2	; 0x02
    4d22:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <chb_reg_read>
    4d26:	89 83       	std	Y+1, r24	; 0x01
    val &= mask;                // mask off stray bits from val
    4d28:	9b 81       	ldd	r25, Y+3	; 0x03
    4d2a:	8c 81       	ldd	r24, Y+4	; 0x04
    4d2c:	89 23       	and	r24, r25
    4d2e:	8b 83       	std	Y+3, r24	; 0x03
    tmp &= ~mask;               // mask off bits in reg val
    4d30:	8c 81       	ldd	r24, Y+4	; 0x04
    4d32:	98 2f       	mov	r25, r24
    4d34:	90 95       	com	r25
    4d36:	89 81       	ldd	r24, Y+1	; 0x01
    4d38:	89 23       	and	r24, r25
    4d3a:	89 83       	std	Y+1, r24	; 0x01
    tmp |= val;                 // copy val into reg val
    4d3c:	99 81       	ldd	r25, Y+1	; 0x01
    4d3e:	8b 81       	ldd	r24, Y+3	; 0x03
    4d40:	89 2b       	or	r24, r25
    4d42:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(addr, tmp);   // write back to reg
    4d44:	8a 81       	ldd	r24, Y+2	; 0x02
    4d46:	69 81       	ldd	r22, Y+1	; 0x01
    4d48:	0e 94 02 26 	call	0x4c04	; 0x4c04 <chb_reg_write>
}
    4d4c:	24 96       	adiw	r28, 0x04	; 4
    4d4e:	cd bf       	out	0x3d, r28	; 61
    4d50:	de bf       	out	0x3e, r29	; 62
    4d52:	df 91       	pop	r29
    4d54:	cf 91       	pop	r28
    4d56:	08 95       	ret

00004d58 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    4d58:	cf 93       	push	r28
    4d5a:	df 93       	push	r29
    4d5c:	cd b7       	in	r28, 0x3d	; 61
    4d5e:	de b7       	in	r29, 0x3e	; 62
    4d60:	28 97       	sbiw	r28, 0x08	; 8
    4d62:	cd bf       	out	0x3d, r28	; 61
    4d64:	de bf       	out	0x3e, r29	; 62
    4d66:	8b 83       	std	Y+3, r24	; 0x03
    4d68:	9c 83       	std	Y+4, r25	; 0x04
    4d6a:	6d 83       	std	Y+5, r22	; 0x05
    4d6c:	4e 83       	std	Y+6, r20	; 0x06
    4d6e:	5f 83       	std	Y+7, r21	; 0x07
    4d70:	28 87       	std	Y+8, r18	; 0x08
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    4d72:	8d 81       	ldd	r24, Y+5	; 0x05
    4d74:	28 2f       	mov	r18, r24
    4d76:	30 e0       	ldi	r19, 0x00	; 0
    4d78:	88 85       	ldd	r24, Y+8	; 0x08
    4d7a:	88 2f       	mov	r24, r24
    4d7c:	90 e0       	ldi	r25, 0x00	; 0
    4d7e:	82 0f       	add	r24, r18
    4d80:	93 1f       	adc	r25, r19
    4d82:	80 38       	cpi	r24, 0x80	; 128
    4d84:	91 05       	cpc	r25, r1
    4d86:	0c f0       	brlt	.+2      	; 0x4d8a <chb_frame_write+0x32>
    4d88:	45 c0       	rjmp	.+138    	; 0x4e14 <chb_frame_write+0xbc>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    4d8a:	8f e3       	ldi	r24, 0x3F	; 63
    4d8c:	90 e0       	ldi	r25, 0x00	; 0
    4d8e:	fc 01       	movw	r30, r24
    4d90:	80 81       	ld	r24, Z
    4d92:	80 93 57 40 	sts	0x4057, r24
    4d96:	f8 94       	cli
    RadioCS(TRUE); 
    4d98:	81 e0       	ldi	r24, 0x01	; 1
    4d9a:	0e 94 27 31 	call	0x624e	; 0x624e <RadioCS>

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);
    4d9e:	80 e6       	ldi	r24, 0x60	; 96
    4da0:	0e 94 84 32 	call	0x6508	; 0x6508 <SPID_write>
    4da4:	8a 83       	std	Y+2, r24	; 0x02

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4da6:	19 82       	std	Y+1, r1	; 0x01
    4da8:	10 c0       	rjmp	.+32     	; 0x4dca <chb_frame_write+0x72>
    {
        dummy = SPID_write(*hdr++);
    4daa:	8b 81       	ldd	r24, Y+3	; 0x03
    4dac:	9c 81       	ldd	r25, Y+4	; 0x04
    4dae:	fc 01       	movw	r30, r24
    4db0:	20 81       	ld	r18, Z
    4db2:	8b 81       	ldd	r24, Y+3	; 0x03
    4db4:	9c 81       	ldd	r25, Y+4	; 0x04
    4db6:	01 96       	adiw	r24, 0x01	; 1
    4db8:	8b 83       	std	Y+3, r24	; 0x03
    4dba:	9c 83       	std	Y+4, r25	; 0x04
    4dbc:	82 2f       	mov	r24, r18
    4dbe:	0e 94 84 32 	call	0x6508	; 0x6508 <SPID_write>
    4dc2:	8a 83       	std	Y+2, r24	; 0x02

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4dc4:	89 81       	ldd	r24, Y+1	; 0x01
    4dc6:	8f 5f       	subi	r24, 0xFF	; 255
    4dc8:	89 83       	std	Y+1, r24	; 0x01
    4dca:	99 81       	ldd	r25, Y+1	; 0x01
    4dcc:	8d 81       	ldd	r24, Y+5	; 0x05
    4dce:	98 17       	cp	r25, r24
    4dd0:	60 f3       	brcs	.-40     	; 0x4daa <chb_frame_write+0x52>
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    4dd2:	19 82       	std	Y+1, r1	; 0x01
    4dd4:	10 c0       	rjmp	.+32     	; 0x4df6 <chb_frame_write+0x9e>
    {
        dummy = SPID_write(*data++);
    4dd6:	8e 81       	ldd	r24, Y+6	; 0x06
    4dd8:	9f 81       	ldd	r25, Y+7	; 0x07
    4dda:	fc 01       	movw	r30, r24
    4ddc:	20 81       	ld	r18, Z
    4dde:	8e 81       	ldd	r24, Y+6	; 0x06
    4de0:	9f 81       	ldd	r25, Y+7	; 0x07
    4de2:	01 96       	adiw	r24, 0x01	; 1
    4de4:	8e 83       	std	Y+6, r24	; 0x06
    4de6:	9f 83       	std	Y+7, r25	; 0x07
    4de8:	82 2f       	mov	r24, r18
    4dea:	0e 94 84 32 	call	0x6508	; 0x6508 <SPID_write>
    4dee:	8a 83       	std	Y+2, r24	; 0x02
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    4df0:	89 81       	ldd	r24, Y+1	; 0x01
    4df2:	8f 5f       	subi	r24, 0xFF	; 255
    4df4:	89 83       	std	Y+1, r24	; 0x01
    4df6:	99 81       	ldd	r25, Y+1	; 0x01
    4df8:	88 85       	ldd	r24, Y+8	; 0x08
    4dfa:	98 17       	cp	r25, r24
    4dfc:	60 f3       	brcs	.-40     	; 0x4dd6 <chb_frame_write+0x7e>
    {
        dummy = SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    4dfe:	80 e0       	ldi	r24, 0x00	; 0
    4e00:	0e 94 27 31 	call	0x624e	; 0x624e <RadioCS>
    CHB_LEAVE_CRIT();
    4e04:	8f e3       	ldi	r24, 0x3F	; 63
    4e06:	90 e0       	ldi	r25, 0x00	; 0
    4e08:	20 91 57 40 	lds	r18, 0x4057
    4e0c:	fc 01       	movw	r30, r24
    4e0e:	20 83       	st	Z, r18
    4e10:	78 94       	sei
    4e12:	01 c0       	rjmp	.+2      	; 0x4e16 <chb_frame_write+0xbe>
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    {
        return;
    4e14:	00 00       	nop
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    CHB_LEAVE_CRIT();
}
    4e16:	28 96       	adiw	r28, 0x08	; 8
    4e18:	cd bf       	out	0x3d, r28	; 61
    4e1a:	de bf       	out	0x3e, r29	; 62
    4e1c:	df 91       	pop	r29
    4e1e:	cf 91       	pop	r28
    4e20:	08 95       	ret

00004e22 <chb_frame_read>:
/*!

*/
/**************************************************************************/
static void chb_frame_read()
{
    4e22:	0f 93       	push	r16
    4e24:	1f 93       	push	r17
    4e26:	cf 93       	push	r28
    4e28:	df 93       	push	r29
    4e2a:	cd b7       	in	r28, 0x3d	; 61
    4e2c:	de b7       	in	r29, 0x3e	; 62
    4e2e:	e7 97       	sbiw	r28, 0x37	; 55
    4e30:	cd bf       	out	0x3d, r28	; 61
    4e32:	de bf       	out	0x3e, r29	; 62
    U8 i, len, data;

    CHB_ENTER_CRIT();
    4e34:	8f e3       	ldi	r24, 0x3F	; 63
    4e36:	90 e0       	ldi	r25, 0x00	; 0
    4e38:	fc 01       	movw	r30, r24
    4e3a:	80 81       	ld	r24, Z
    4e3c:	80 93 57 40 	sts	0x4057, r24
    4e40:	f8 94       	cli
    RadioCS(TRUE);
    4e42:	81 e0       	ldi	r24, 0x01	; 1
    4e44:	0e 94 27 31 	call	0x624e	; 0x624e <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    4e48:	80 e2       	ldi	r24, 0x20	; 32
    4e4a:	0e 94 84 32 	call	0x6508	; 0x6508 <SPID_write>
    len = SPID_write(0);
    4e4e:	80 e0       	ldi	r24, 0x00	; 0
    4e50:	0e 94 84 32 	call	0x6508	; 0x6508 <SPID_write>
    4e54:	8a 83       	std	Y+2, r24	; 0x02

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    4e56:	8a 81       	ldd	r24, Y+2	; 0x02
    4e58:	83 30       	cpi	r24, 0x03	; 3
    4e5a:	08 f4       	brcc	.+2      	; 0x4e5e <chb_frame_read+0x3c>
    4e5c:	66 c0       	rjmp	.+204    	; 0x4f2a <chb_frame_read+0x108>
    4e5e:	8a 81       	ldd	r24, Y+2	; 0x02
    4e60:	88 23       	and	r24, r24
    4e62:	0c f4       	brge	.+2      	; 0x4e66 <chb_frame_read+0x44>
    4e64:	62 c0       	rjmp	.+196    	; 0x4f2a <chb_frame_read+0x108>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    4e66:	8a 81       	ldd	r24, Y+2	; 0x02
    4e68:	08 2f       	mov	r16, r24
    4e6a:	10 e0       	ldi	r17, 0x00	; 0
    4e6c:	0e 94 95 23 	call	0x472a	; 0x472a <chb_buf_get_len>
    4e70:	88 2f       	mov	r24, r24
    4e72:	90 e0       	ldi	r25, 0x00	; 0
    4e74:	20 e8       	ldi	r18, 0x80	; 128
    4e76:	30 e0       	ldi	r19, 0x00	; 0
    4e78:	a9 01       	movw	r20, r18
    4e7a:	48 1b       	sub	r20, r24
    4e7c:	59 0b       	sbc	r21, r25
    4e7e:	ca 01       	movw	r24, r20
    4e80:	08 17       	cp	r16, r24
    4e82:	19 07       	cpc	r17, r25
    4e84:	f4 f4       	brge	.+60     	; 0x4ec2 <chb_frame_read+0xa0>
        {
            chb_buf_write(len);
    4e86:	8a 81       	ldd	r24, Y+2	; 0x02
    4e88:	0e 94 4d 23 	call	0x469a	; 0x469a <chb_buf_write>
            
            for (i=0; i<len; i++)
    4e8c:	19 82       	std	Y+1, r1	; 0x01
    4e8e:	0a c0       	rjmp	.+20     	; 0x4ea4 <chb_frame_read+0x82>
            {
                data = SPID_write(0);
    4e90:	80 e0       	ldi	r24, 0x00	; 0
    4e92:	0e 94 84 32 	call	0x6508	; 0x6508 <SPID_write>
    4e96:	8b 83       	std	Y+3, r24	; 0x03
                chb_buf_write(data);
    4e98:	8b 81       	ldd	r24, Y+3	; 0x03
    4e9a:	0e 94 4d 23 	call	0x469a	; 0x469a <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    4e9e:	89 81       	ldd	r24, Y+1	; 0x01
    4ea0:	8f 5f       	subi	r24, 0xFF	; 255
    4ea2:	89 83       	std	Y+1, r24	; 0x01
    4ea4:	99 81       	ldd	r25, Y+1	; 0x01
    4ea6:	8a 81       	ldd	r24, Y+2	; 0x02
    4ea8:	98 17       	cp	r25, r24
    4eaa:	90 f3       	brcs	.-28     	; 0x4e90 <chb_frame_read+0x6e>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    4eac:	80 e8       	ldi	r24, 0x80	; 128
    4eae:	96 e0       	ldi	r25, 0x06	; 6
    4eb0:	24 e0       	ldi	r18, 0x04	; 4
    4eb2:	fc 01       	movw	r30, r24
    4eb4:	25 83       	std	Z+5, r18	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    4eb6:	80 e8       	ldi	r24, 0x80	; 128
    4eb8:	96 e0       	ldi	r25, 0x06	; 6
    4eba:	24 e0       	ldi	r18, 0x04	; 4
    4ebc:	fc 01       	movw	r30, r24
    4ebe:	26 83       	std	Z+6, r18	; 0x06
    4ec0:	34 c0       	rjmp	.+104    	; 0x4f2a <chb_frame_read+0x108>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    4ec2:	0e 94 95 20 	call	0x412a	; 0x412a <chb_get_pcb>
    4ec6:	8c 83       	std	Y+4, r24	; 0x04
    4ec8:	9d 83       	std	Y+5, r25	; 0x05
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4eca:	19 82       	std	Y+1, r1	; 0x01
    4ecc:	07 c0       	rjmp	.+14     	; 0x4edc <chb_frame_read+0xba>
            {
                data = SPID_write(0);
    4ece:	80 e0       	ldi	r24, 0x00	; 0
    4ed0:	0e 94 84 32 	call	0x6508	; 0x6508 <SPID_write>
    4ed4:	8b 83       	std	Y+3, r24	; 0x03
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4ed6:	89 81       	ldd	r24, Y+1	; 0x01
    4ed8:	8f 5f       	subi	r24, 0xFF	; 255
    4eda:	89 83       	std	Y+1, r24	; 0x01
    4edc:	99 81       	ldd	r25, Y+1	; 0x01
    4ede:	8a 81       	ldd	r24, Y+2	; 0x02
    4ee0:	98 17       	cp	r25, r24
    4ee2:	a8 f3       	brcs	.-22     	; 0x4ece <chb_frame_read+0xac>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    4ee4:	8c 81       	ldd	r24, Y+4	; 0x04
    4ee6:	9d 81       	ldd	r25, Y+5	; 0x05
    4ee8:	fc 01       	movw	r30, r24
    4eea:	85 85       	ldd	r24, Z+13	; 0x0d
    4eec:	96 85       	ldd	r25, Z+14	; 0x0e
    4eee:	9c 01       	movw	r18, r24
    4ef0:	2f 5f       	subi	r18, 0xFF	; 255
    4ef2:	3f 4f       	sbci	r19, 0xFF	; 255
    4ef4:	8c 81       	ldd	r24, Y+4	; 0x04
    4ef6:	9d 81       	ldd	r25, Y+5	; 0x05
    4ef8:	fc 01       	movw	r30, r24
    4efa:	25 87       	std	Z+13, r18	; 0x0d
    4efc:	36 87       	std	Z+14, r19	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    4efe:	ce 01       	movw	r24, r28
    4f00:	06 96       	adiw	r24, 0x06	; 6
    4f02:	28 ee       	ldi	r18, 0xE8	; 232
    4f04:	31 e0       	ldi	r19, 0x01	; 1
    4f06:	b9 01       	movw	r22, r18
    4f08:	0e 94 4a 5f 	call	0xbe94	; 0xbe94 <strcpy_P>
            printf(buf);
    4f0c:	0f 92       	push	r0
    4f0e:	0f 92       	push	r0
    4f10:	8d b7       	in	r24, 0x3d	; 61
    4f12:	9e b7       	in	r25, 0x3e	; 62
    4f14:	01 96       	adiw	r24, 0x01	; 1
    4f16:	9e 01       	movw	r18, r28
    4f18:	2a 5f       	subi	r18, 0xFA	; 250
    4f1a:	3f 4f       	sbci	r19, 0xFF	; 255
    4f1c:	fc 01       	movw	r30, r24
    4f1e:	20 83       	st	Z, r18
    4f20:	31 83       	std	Z+1, r19	; 0x01
    4f22:	0e 94 a6 5f 	call	0xbf4c	; 0xbf4c <printf>
    4f26:	0f 90       	pop	r0
    4f28:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    4f2a:	80 e0       	ldi	r24, 0x00	; 0
    4f2c:	0e 94 27 31 	call	0x624e	; 0x624e <RadioCS>
    CHB_LEAVE_CRIT();
    4f30:	8f e3       	ldi	r24, 0x3F	; 63
    4f32:	90 e0       	ldi	r25, 0x00	; 0
    4f34:	20 91 57 40 	lds	r18, 0x4057
    4f38:	fc 01       	movw	r30, r24
    4f3a:	20 83       	st	Z, r18
    4f3c:	78 94       	sei
}
    4f3e:	e7 96       	adiw	r28, 0x37	; 55
    4f40:	cd bf       	out	0x3d, r28	; 61
    4f42:	de bf       	out	0x3e, r29	; 62
    4f44:	df 91       	pop	r29
    4f46:	cf 91       	pop	r28
    4f48:	1f 91       	pop	r17
    4f4a:	0f 91       	pop	r16
    4f4c:	08 95       	ret

00004f4e <chb_set_mode>:
/*!
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    4f4e:	cf 93       	push	r28
    4f50:	df 93       	push	r29
    4f52:	0f 92       	push	r0
    4f54:	cd b7       	in	r28, 0x3d	; 61
    4f56:	de b7       	in	r29, 0x3e	; 62
    4f58:	89 83       	std	Y+1, r24	; 0x01
    switch (mode)
    4f5a:	89 81       	ldd	r24, Y+1	; 0x01
    4f5c:	88 2f       	mov	r24, r24
    4f5e:	90 e0       	ldi	r25, 0x00	; 0
    4f60:	81 30       	cpi	r24, 0x01	; 1
    4f62:	91 05       	cpc	r25, r1
    4f64:	c1 f0       	breq	.+48     	; 0x4f96 <chb_set_mode+0x48>
    4f66:	82 30       	cpi	r24, 0x02	; 2
    4f68:	91 05       	cpc	r25, r1
    4f6a:	1c f4       	brge	.+6      	; 0x4f72 <chb_set_mode+0x24>
    4f6c:	00 97       	sbiw	r24, 0x00	; 0
    4f6e:	41 f0       	breq	.+16     	; 0x4f80 <chb_set_mode+0x32>
    4f70:	33 c0       	rjmp	.+102    	; 0x4fd8 <chb_set_mode+0x8a>
    4f72:	82 30       	cpi	r24, 0x02	; 2
    4f74:	91 05       	cpc	r25, r1
    4f76:	d1 f0       	breq	.+52     	; 0x4fac <chb_set_mode+0x5e>
    4f78:	83 30       	cpi	r24, 0x03	; 3
    4f7a:	91 05       	cpc	r25, r1
    4f7c:	11 f1       	breq	.+68     	; 0x4fc2 <chb_set_mode+0x74>
    4f7e:	2c c0       	rjmp	.+88     	; 0x4fd8 <chb_set_mode+0x8a>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    4f80:	8c e0       	ldi	r24, 0x0C	; 12
    4f82:	68 e0       	ldi	r22, 0x08	; 8
    4f84:	4f e3       	ldi	r20, 0x3F	; 63
    4f86:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4f8a:	86 e1       	ldi	r24, 0x16	; 22
    4f8c:	62 e0       	ldi	r22, 0x02	; 2
    4f8e:	43 e0       	ldi	r20, 0x03	; 3
    4f90:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>
        break;
    4f94:	21 c0       	rjmp	.+66     	; 0x4fd8 <chb_set_mode+0x8a>
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    4f96:	8c e0       	ldi	r24, 0x0C	; 12
    4f98:	6c e0       	ldi	r22, 0x0C	; 12
    4f9a:	4f e3       	ldi	r20, 0x3F	; 63
    4f9c:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4fa0:	86 e1       	ldi	r24, 0x16	; 22
    4fa2:	62 e0       	ldi	r22, 0x02	; 2
    4fa4:	43 e0       	ldi	r20, 0x03	; 3
    4fa6:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>
        break;
    4faa:	16 c0       	rjmp	.+44     	; 0x4fd8 <chb_set_mode+0x8a>
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    4fac:	8c e0       	ldi	r24, 0x0C	; 12
    4fae:	6c e1       	ldi	r22, 0x1C	; 28
    4fb0:	4f e3       	ldi	r20, 0x3F	; 63
    4fb2:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4fb6:	86 e1       	ldi	r24, 0x16	; 22
    4fb8:	62 e0       	ldi	r22, 0x02	; 2
    4fba:	43 e0       	ldi	r20, 0x03	; 3
    4fbc:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>
        break;
    4fc0:	0b c0       	rjmp	.+22     	; 0x4fd8 <chb_set_mode+0x8a>
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    4fc2:	8c e0       	ldi	r24, 0x0C	; 12
    4fc4:	60 e0       	ldi	r22, 0x00	; 0
    4fc6:	4f e3       	ldi	r20, 0x3F	; 63
    4fc8:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    4fcc:	86 e1       	ldi	r24, 0x16	; 22
    4fce:	63 e0       	ldi	r22, 0x03	; 3
    4fd0:	43 e0       	ldi	r20, 0x03	; 3
    4fd2:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>
        break;
    4fd6:	00 00       	nop
    }
}
    4fd8:	0f 90       	pop	r0
    4fda:	df 91       	pop	r29
    4fdc:	cf 91       	pop	r28
    4fde:	08 95       	ret

00004fe0 <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    4fe0:	0f 93       	push	r16
    4fe2:	1f 93       	push	r17
    4fe4:	cf 93       	push	r28
    4fe6:	df 93       	push	r29
    4fe8:	cd b7       	in	r28, 0x3d	; 61
    4fea:	de b7       	in	r29, 0x3e	; 62
    4fec:	6a 97       	sbiw	r28, 0x1a	; 26
    4fee:	cd bf       	out	0x3d, r28	; 61
    4ff0:	de bf       	out	0x3e, r29	; 62
    4ff2:	8a 8f       	std	Y+26, r24	; 0x1a
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    4ff4:	88 e0       	ldi	r24, 0x08	; 8
    4ff6:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4ff8:	4f e1       	ldi	r20, 0x1F	; 31
    4ffa:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    4ffe:	0e 94 9e 23 	call	0x473c	; 0x473c <chb_get_state>
    5002:	89 83       	std	Y+1, r24	; 0x01
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    5004:	89 81       	ldd	r24, Y+1	; 0x01
    5006:	86 30       	cpi	r24, 0x06	; 6
    5008:	21 f0       	breq	.+8      	; 0x5012 <chb_set_channel+0x32>
    500a:	89 81       	ldd	r24, Y+1	; 0x01
    500c:	89 30       	cpi	r24, 0x09	; 9
    500e:	09 f0       	breq	.+2      	; 0x5012 <chb_set_channel+0x32>
    5010:	d5 c0       	rjmp	.+426    	; 0x51bc <chb_set_channel+0x1dc>
    5012:	80 e0       	ldi	r24, 0x00	; 0
    5014:	90 e0       	ldi	r25, 0x00	; 0
    5016:	ac ed       	ldi	r26, 0xDC	; 220
    5018:	b2 e4       	ldi	r27, 0x42	; 66
    501a:	8a 83       	std	Y+2, r24	; 0x02
    501c:	9b 83       	std	Y+3, r25	; 0x03
    501e:	ac 83       	std	Y+4, r26	; 0x04
    5020:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5022:	6a 81       	ldd	r22, Y+2	; 0x02
    5024:	7b 81       	ldd	r23, Y+3	; 0x03
    5026:	8c 81       	ldd	r24, Y+4	; 0x04
    5028:	9d 81       	ldd	r25, Y+5	; 0x05
    502a:	2b ea       	ldi	r18, 0xAB	; 171
    502c:	3a ea       	ldi	r19, 0xAA	; 170
    502e:	4a ea       	ldi	r20, 0xAA	; 170
    5030:	5e e3       	ldi	r21, 0x3E	; 62
    5032:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    5036:	dc 01       	movw	r26, r24
    5038:	cb 01       	movw	r24, r22
    503a:	8e 83       	std	Y+6, r24	; 0x06
    503c:	9f 83       	std	Y+7, r25	; 0x07
    503e:	a8 87       	std	Y+8, r26	; 0x08
    5040:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    5042:	11 e0       	ldi	r17, 0x01	; 1
    5044:	6e 81       	ldd	r22, Y+6	; 0x06
    5046:	7f 81       	ldd	r23, Y+7	; 0x07
    5048:	88 85       	ldd	r24, Y+8	; 0x08
    504a:	99 85       	ldd	r25, Y+9	; 0x09
    504c:	20 e0       	ldi	r18, 0x00	; 0
    504e:	30 e0       	ldi	r19, 0x00	; 0
    5050:	40 e8       	ldi	r20, 0x80	; 128
    5052:	5f e3       	ldi	r21, 0x3F	; 63
    5054:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    5058:	88 23       	and	r24, r24
    505a:	0c f0       	brlt	.+2      	; 0x505e <chb_set_channel+0x7e>
    505c:	10 e0       	ldi	r17, 0x00	; 0
    505e:	11 23       	and	r17, r17
    5060:	19 f0       	breq	.+6      	; 0x5068 <chb_set_channel+0x88>
		__ticks = 1;
    5062:	81 e0       	ldi	r24, 0x01	; 1
    5064:	8a 87       	std	Y+10, r24	; 0x0a
    5066:	a3 c0       	rjmp	.+326    	; 0x51ae <chb_set_channel+0x1ce>
	else if (__tmp > 255)
    5068:	11 e0       	ldi	r17, 0x01	; 1
    506a:	6e 81       	ldd	r22, Y+6	; 0x06
    506c:	7f 81       	ldd	r23, Y+7	; 0x07
    506e:	88 85       	ldd	r24, Y+8	; 0x08
    5070:	99 85       	ldd	r25, Y+9	; 0x09
    5072:	20 e0       	ldi	r18, 0x00	; 0
    5074:	30 e0       	ldi	r19, 0x00	; 0
    5076:	4f e7       	ldi	r20, 0x7F	; 127
    5078:	53 e4       	ldi	r21, 0x43	; 67
    507a:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    507e:	18 16       	cp	r1, r24
    5080:	0c f0       	brlt	.+2      	; 0x5084 <chb_set_channel+0xa4>
    5082:	10 e0       	ldi	r17, 0x00	; 0
    5084:	11 23       	and	r17, r17
    5086:	09 f4       	brne	.+2      	; 0x508a <chb_set_channel+0xaa>
    5088:	89 c0       	rjmp	.+274    	; 0x519c <chb_set_channel+0x1bc>
	{
		_delay_ms(__us / 1000.0);
    508a:	6a 81       	ldd	r22, Y+2	; 0x02
    508c:	7b 81       	ldd	r23, Y+3	; 0x03
    508e:	8c 81       	ldd	r24, Y+4	; 0x04
    5090:	9d 81       	ldd	r25, Y+5	; 0x05
    5092:	20 e0       	ldi	r18, 0x00	; 0
    5094:	30 e0       	ldi	r19, 0x00	; 0
    5096:	4a e7       	ldi	r20, 0x7A	; 122
    5098:	54 e4       	ldi	r21, 0x44	; 68
    509a:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
    509e:	dc 01       	movw	r26, r24
    50a0:	cb 01       	movw	r24, r22
    50a2:	8b 87       	std	Y+11, r24	; 0x0b
    50a4:	9c 87       	std	Y+12, r25	; 0x0c
    50a6:	ad 87       	std	Y+13, r26	; 0x0d
    50a8:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    50aa:	6b 85       	ldd	r22, Y+11	; 0x0b
    50ac:	7c 85       	ldd	r23, Y+12	; 0x0c
    50ae:	8d 85       	ldd	r24, Y+13	; 0x0d
    50b0:	9e 85       	ldd	r25, Y+14	; 0x0e
    50b2:	20 e0       	ldi	r18, 0x00	; 0
    50b4:	30 e0       	ldi	r19, 0x00	; 0
    50b6:	4a e7       	ldi	r20, 0x7A	; 122
    50b8:	53 e4       	ldi	r21, 0x43	; 67
    50ba:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    50be:	dc 01       	movw	r26, r24
    50c0:	cb 01       	movw	r24, r22
    50c2:	8f 87       	std	Y+15, r24	; 0x0f
    50c4:	98 8b       	std	Y+16, r25	; 0x10
    50c6:	a9 8b       	std	Y+17, r26	; 0x11
    50c8:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    50ca:	11 e0       	ldi	r17, 0x01	; 1
    50cc:	6f 85       	ldd	r22, Y+15	; 0x0f
    50ce:	78 89       	ldd	r23, Y+16	; 0x10
    50d0:	89 89       	ldd	r24, Y+17	; 0x11
    50d2:	9a 89       	ldd	r25, Y+18	; 0x12
    50d4:	20 e0       	ldi	r18, 0x00	; 0
    50d6:	30 e0       	ldi	r19, 0x00	; 0
    50d8:	40 e8       	ldi	r20, 0x80	; 128
    50da:	5f e3       	ldi	r21, 0x3F	; 63
    50dc:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    50e0:	88 23       	and	r24, r24
    50e2:	0c f0       	brlt	.+2      	; 0x50e6 <chb_set_channel+0x106>
    50e4:	10 e0       	ldi	r17, 0x00	; 0
    50e6:	11 23       	and	r17, r17
    50e8:	29 f0       	breq	.+10     	; 0x50f4 <chb_set_channel+0x114>
		__ticks = 1;
    50ea:	81 e0       	ldi	r24, 0x01	; 1
    50ec:	90 e0       	ldi	r25, 0x00	; 0
    50ee:	8b 8b       	std	Y+19, r24	; 0x13
    50f0:	9c 8b       	std	Y+20, r25	; 0x14
    50f2:	46 c0       	rjmp	.+140    	; 0x5180 <chb_set_channel+0x1a0>
	else if (__tmp > 65535)
    50f4:	11 e0       	ldi	r17, 0x01	; 1
    50f6:	6f 85       	ldd	r22, Y+15	; 0x0f
    50f8:	78 89       	ldd	r23, Y+16	; 0x10
    50fa:	89 89       	ldd	r24, Y+17	; 0x11
    50fc:	9a 89       	ldd	r25, Y+18	; 0x12
    50fe:	20 e0       	ldi	r18, 0x00	; 0
    5100:	3f ef       	ldi	r19, 0xFF	; 255
    5102:	4f e7       	ldi	r20, 0x7F	; 127
    5104:	57 e4       	ldi	r21, 0x47	; 71
    5106:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    510a:	18 16       	cp	r1, r24
    510c:	0c f0       	brlt	.+2      	; 0x5110 <chb_set_channel+0x130>
    510e:	10 e0       	ldi	r17, 0x00	; 0
    5110:	11 23       	and	r17, r17
    5112:	61 f1       	breq	.+88     	; 0x516c <chb_set_channel+0x18c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5114:	6b 85       	ldd	r22, Y+11	; 0x0b
    5116:	7c 85       	ldd	r23, Y+12	; 0x0c
    5118:	8d 85       	ldd	r24, Y+13	; 0x0d
    511a:	9e 85       	ldd	r25, Y+14	; 0x0e
    511c:	20 e0       	ldi	r18, 0x00	; 0
    511e:	30 e0       	ldi	r19, 0x00	; 0
    5120:	40 e2       	ldi	r20, 0x20	; 32
    5122:	51 e4       	ldi	r21, 0x41	; 65
    5124:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    5128:	dc 01       	movw	r26, r24
    512a:	cb 01       	movw	r24, r22
    512c:	bc 01       	movw	r22, r24
    512e:	cd 01       	movw	r24, r26
    5130:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    5134:	dc 01       	movw	r26, r24
    5136:	cb 01       	movw	r24, r22
    5138:	8b 8b       	std	Y+19, r24	; 0x13
    513a:	9c 8b       	std	Y+20, r25	; 0x14
    513c:	12 c0       	rjmp	.+36     	; 0x5162 <chb_set_channel+0x182>
    513e:	89 e1       	ldi	r24, 0x19	; 25
    5140:	90 e0       	ldi	r25, 0x00	; 0
    5142:	8d 8b       	std	Y+21, r24	; 0x15
    5144:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5146:	8d 89       	ldd	r24, Y+21	; 0x15
    5148:	9e 89       	ldd	r25, Y+22	; 0x16
    514a:	8c 01       	movw	r16, r24
    514c:	c8 01       	movw	r24, r16
    514e:	01 97       	sbiw	r24, 0x01	; 1
    5150:	f1 f7       	brne	.-4      	; 0x514e <chb_set_channel+0x16e>
    5152:	8c 01       	movw	r16, r24
    5154:	0d 8b       	std	Y+21, r16	; 0x15
    5156:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5158:	8b 89       	ldd	r24, Y+19	; 0x13
    515a:	9c 89       	ldd	r25, Y+20	; 0x14
    515c:	01 97       	sbiw	r24, 0x01	; 1
    515e:	8b 8b       	std	Y+19, r24	; 0x13
    5160:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5162:	8b 89       	ldd	r24, Y+19	; 0x13
    5164:	9c 89       	ldd	r25, Y+20	; 0x14
    5166:	00 97       	sbiw	r24, 0x00	; 0
    5168:	51 f7       	brne	.-44     	; 0x513e <chb_set_channel+0x15e>
    516a:	28 c0       	rjmp	.+80     	; 0x51bc <chb_set_channel+0x1dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    516c:	6f 85       	ldd	r22, Y+15	; 0x0f
    516e:	78 89       	ldd	r23, Y+16	; 0x10
    5170:	89 89       	ldd	r24, Y+17	; 0x11
    5172:	9a 89       	ldd	r25, Y+18	; 0x12
    5174:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    5178:	dc 01       	movw	r26, r24
    517a:	cb 01       	movw	r24, r22
    517c:	8b 8b       	std	Y+19, r24	; 0x13
    517e:	9c 8b       	std	Y+20, r25	; 0x14
    5180:	8b 89       	ldd	r24, Y+19	; 0x13
    5182:	9c 89       	ldd	r25, Y+20	; 0x14
    5184:	8f 8b       	std	Y+23, r24	; 0x17
    5186:	98 8f       	std	Y+24, r25	; 0x18
    5188:	8f 89       	ldd	r24, Y+23	; 0x17
    518a:	98 8d       	ldd	r25, Y+24	; 0x18
    518c:	8c 01       	movw	r16, r24
    518e:	c8 01       	movw	r24, r16
    5190:	01 97       	sbiw	r24, 0x01	; 1
    5192:	f1 f7       	brne	.-4      	; 0x5190 <chb_set_channel+0x1b0>
    5194:	8c 01       	movw	r16, r24
    5196:	0f 8b       	std	Y+23, r16	; 0x17
    5198:	18 8f       	std	Y+24, r17	; 0x18
    519a:	10 c0       	rjmp	.+32     	; 0x51bc <chb_set_channel+0x1dc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    519c:	6e 81       	ldd	r22, Y+6	; 0x06
    519e:	7f 81       	ldd	r23, Y+7	; 0x07
    51a0:	88 85       	ldd	r24, Y+8	; 0x08
    51a2:	99 85       	ldd	r25, Y+9	; 0x09
    51a4:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    51a8:	dc 01       	movw	r26, r24
    51aa:	cb 01       	movw	r24, r22
    51ac:	8a 87       	std	Y+10, r24	; 0x0a
    51ae:	8a 85       	ldd	r24, Y+10	; 0x0a
    51b0:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    51b2:	89 8d       	ldd	r24, Y+25	; 0x19
    51b4:	18 2f       	mov	r17, r24
    51b6:	1a 95       	dec	r17
    51b8:	f1 f7       	brne	.-4      	; 0x51b6 <chb_set_channel+0x1d6>
    51ba:	19 8f       	std	Y+25, r17	; 0x19
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    51bc:	88 e0       	ldi	r24, 0x08	; 8
    51be:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <chb_reg_read>
    51c2:	88 2f       	mov	r24, r24
    51c4:	90 e0       	ldi	r25, 0x00	; 0
    51c6:	9c 01       	movw	r18, r24
    51c8:	2f 71       	andi	r18, 0x1F	; 31
    51ca:	30 70       	andi	r19, 0x00	; 0
    51cc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    51ce:	88 2f       	mov	r24, r24
    51d0:	90 e0       	ldi	r25, 0x00	; 0
    51d2:	28 17       	cp	r18, r24
    51d4:	39 07       	cpc	r19, r25
    51d6:	11 f4       	brne	.+4      	; 0x51dc <chb_set_channel+0x1fc>
    51d8:	80 e4       	ldi	r24, 0x40	; 64
    51da:	01 c0       	rjmp	.+2      	; 0x51de <chb_set_channel+0x1fe>
    51dc:	83 e4       	ldi	r24, 0x43	; 67
}
    51de:	6a 96       	adiw	r28, 0x1a	; 26
    51e0:	cd bf       	out	0x3d, r28	; 61
    51e2:	de bf       	out	0x3e, r29	; 62
    51e4:	df 91       	pop	r29
    51e6:	cf 91       	pop	r28
    51e8:	1f 91       	pop	r17
    51ea:	0f 91       	pop	r16
    51ec:	08 95       	ret

000051ee <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    51ee:	cf 93       	push	r28
    51f0:	df 93       	push	r29
    51f2:	0f 92       	push	r0
    51f4:	cd b7       	in	r28, 0x3d	; 61
    51f6:	de b7       	in	r29, 0x3e	; 62
    51f8:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(PHY_TX_PWR, val);
    51fa:	85 e0       	ldi	r24, 0x05	; 5
    51fc:	69 81       	ldd	r22, Y+1	; 0x01
    51fe:	0e 94 02 26 	call	0x4c04	; 0x4c04 <chb_reg_write>
}
    5202:	0f 90       	pop	r0
    5204:	df 91       	pop	r29
    5206:	cf 91       	pop	r28
    5208:	08 95       	ret

0000520a <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    520a:	0f 93       	push	r16
    520c:	1f 93       	push	r17
    520e:	cf 93       	push	r28
    5210:	df 93       	push	r29
    5212:	cd b7       	in	r28, 0x3d	; 61
    5214:	de b7       	in	r29, 0x3e	; 62
    5216:	c2 56       	subi	r28, 0x62	; 98
    5218:	d0 40       	sbci	r29, 0x00	; 0
    521a:	cd bf       	out	0x3d, r28	; 61
    521c:	de bf       	out	0x3e, r29	; 62
    521e:	9e 01       	movw	r18, r28
    5220:	2e 59       	subi	r18, 0x9E	; 158
    5222:	3f 4f       	sbci	r19, 0xFF	; 255
    5224:	f9 01       	movw	r30, r18
    5226:	80 83       	st	Z, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    5228:	84 e6       	ldi	r24, 0x64	; 100
    522a:	96 e0       	ldi	r25, 0x06	; 6
    522c:	fc 01       	movw	r30, r24
    522e:	80 81       	ld	r24, Z
    5230:	88 2f       	mov	r24, r24
    5232:	90 e0       	ldi	r25, 0x00	; 0
    5234:	82 70       	andi	r24, 0x02	; 2
    5236:	90 70       	andi	r25, 0x00	; 0
    5238:	00 97       	sbiw	r24, 0x00	; 0
    523a:	11 f0       	breq	.+4      	; 0x5240 <chb_set_state+0x36>
    {
        return RADIO_WRONG_STATE;
    523c:	84 e4       	ldi	r24, 0x44	; 68
    523e:	91 c4       	rjmp	.+2338   	; 0x5b62 <chb_set_state+0x958>
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    5240:	0e 94 9e 23 	call	0x473c	; 0x473c <chb_get_state>
    5244:	89 83       	std	Y+1, r24	; 0x01
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    5246:	89 81       	ldd	r24, Y+1	; 0x01
    5248:	82 31       	cpi	r24, 0x12	; 18
    524a:	49 f0       	breq	.+18     	; 0x525e <chb_set_state+0x54>
    524c:	89 81       	ldd	r24, Y+1	; 0x01
    524e:	81 31       	cpi	r24, 0x11	; 17
    5250:	31 f0       	breq	.+12     	; 0x525e <chb_set_state+0x54>
    5252:	89 81       	ldd	r24, Y+1	; 0x01
    5254:	81 30       	cpi	r24, 0x01	; 1
    5256:	19 f0       	breq	.+6      	; 0x525e <chb_set_state+0x54>
    5258:	89 81       	ldd	r24, Y+1	; 0x01
    525a:	82 30       	cpi	r24, 0x02	; 2
    525c:	39 f4       	brne	.+14     	; 0x526c <chb_set_state+0x62>
    {
        while (chb_get_state() == curr_state);
    525e:	00 00       	nop
    5260:	0e 94 9e 23 	call	0x473c	; 0x473c <chb_get_state>
    5264:	98 2f       	mov	r25, r24
    5266:	89 81       	ldd	r24, Y+1	; 0x01
    5268:	98 17       	cp	r25, r24
    526a:	d1 f3       	breq	.-12     	; 0x5260 <chb_set_state+0x56>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    526c:	ce 01       	movw	r24, r28
    526e:	8e 59       	subi	r24, 0x9E	; 158
    5270:	9f 4f       	sbci	r25, 0xFF	; 255
    5272:	fc 01       	movw	r30, r24
    5274:	80 81       	ld	r24, Z
    5276:	88 2f       	mov	r24, r24
    5278:	90 e0       	ldi	r25, 0x00	; 0
    527a:	86 31       	cpi	r24, 0x16	; 22
    527c:	91 05       	cpc	r25, r1
    527e:	09 f4       	brne	.+2      	; 0x5282 <chb_set_state+0x78>
    5280:	cd c1       	rjmp	.+922    	; 0x561c <chb_set_state+0x412>
    5282:	89 31       	cpi	r24, 0x19	; 25
    5284:	91 05       	cpc	r25, r1
    5286:	09 f4       	brne	.+2      	; 0x528a <chb_set_state+0x80>
    5288:	e9 c0       	rjmp	.+466    	; 0x545c <chb_set_state+0x252>
    528a:	88 30       	cpi	r24, 0x08	; 8
    528c:	91 05       	cpc	r25, r1
    528e:	09 f0       	breq	.+2      	; 0x5292 <chb_set_state+0x88>
    5290:	f7 c2       	rjmp	.+1518   	; 0x5880 <chb_set_state+0x676>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    5292:	84 e6       	ldi	r24, 0x64	; 100
    5294:	96 e0       	ldi	r25, 0x06	; 6
    5296:	24 e6       	ldi	r18, 0x64	; 100
    5298:	36 e0       	ldi	r19, 0x06	; 6
    529a:	f9 01       	movw	r30, r18
    529c:	20 81       	ld	r18, Z
    529e:	2d 7f       	andi	r18, 0xFD	; 253
    52a0:	fc 01       	movw	r30, r24
    52a2:	20 83       	st	Z, r18
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    52a4:	82 e0       	ldi	r24, 0x02	; 2
    52a6:	63 e0       	ldi	r22, 0x03	; 3
    52a8:	4f e1       	ldi	r20, 0x1F	; 31
    52aa:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>
    52ae:	80 e0       	ldi	r24, 0x00	; 0
    52b0:	90 e0       	ldi	r25, 0x00	; 0
    52b2:	a0 e8       	ldi	r26, 0x80	; 128
    52b4:	bf e3       	ldi	r27, 0x3F	; 63
    52b6:	8a 83       	std	Y+2, r24	; 0x02
    52b8:	9b 83       	std	Y+3, r25	; 0x03
    52ba:	ac 83       	std	Y+4, r26	; 0x04
    52bc:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    52be:	6a 81       	ldd	r22, Y+2	; 0x02
    52c0:	7b 81       	ldd	r23, Y+3	; 0x03
    52c2:	8c 81       	ldd	r24, Y+4	; 0x04
    52c4:	9d 81       	ldd	r25, Y+5	; 0x05
    52c6:	2b ea       	ldi	r18, 0xAB	; 171
    52c8:	3a ea       	ldi	r19, 0xAA	; 170
    52ca:	4a ea       	ldi	r20, 0xAA	; 170
    52cc:	5e e3       	ldi	r21, 0x3E	; 62
    52ce:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    52d2:	dc 01       	movw	r26, r24
    52d4:	cb 01       	movw	r24, r22
    52d6:	8e 83       	std	Y+6, r24	; 0x06
    52d8:	9f 83       	std	Y+7, r25	; 0x07
    52da:	a8 87       	std	Y+8, r26	; 0x08
    52dc:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    52de:	11 e0       	ldi	r17, 0x01	; 1
    52e0:	6e 81       	ldd	r22, Y+6	; 0x06
    52e2:	7f 81       	ldd	r23, Y+7	; 0x07
    52e4:	88 85       	ldd	r24, Y+8	; 0x08
    52e6:	99 85       	ldd	r25, Y+9	; 0x09
    52e8:	20 e0       	ldi	r18, 0x00	; 0
    52ea:	30 e0       	ldi	r19, 0x00	; 0
    52ec:	40 e8       	ldi	r20, 0x80	; 128
    52ee:	5f e3       	ldi	r21, 0x3F	; 63
    52f0:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    52f4:	88 23       	and	r24, r24
    52f6:	0c f0       	brlt	.+2      	; 0x52fa <chb_set_state+0xf0>
    52f8:	10 e0       	ldi	r17, 0x00	; 0
    52fa:	11 23       	and	r17, r17
    52fc:	19 f0       	breq	.+6      	; 0x5304 <chb_set_state+0xfa>
		__ticks = 1;
    52fe:	81 e0       	ldi	r24, 0x01	; 1
    5300:	8a 87       	std	Y+10, r24	; 0x0a
    5302:	a3 c0       	rjmp	.+326    	; 0x544a <chb_set_state+0x240>
	else if (__tmp > 255)
    5304:	11 e0       	ldi	r17, 0x01	; 1
    5306:	6e 81       	ldd	r22, Y+6	; 0x06
    5308:	7f 81       	ldd	r23, Y+7	; 0x07
    530a:	88 85       	ldd	r24, Y+8	; 0x08
    530c:	99 85       	ldd	r25, Y+9	; 0x09
    530e:	20 e0       	ldi	r18, 0x00	; 0
    5310:	30 e0       	ldi	r19, 0x00	; 0
    5312:	4f e7       	ldi	r20, 0x7F	; 127
    5314:	53 e4       	ldi	r21, 0x43	; 67
    5316:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    531a:	18 16       	cp	r1, r24
    531c:	0c f0       	brlt	.+2      	; 0x5320 <chb_set_state+0x116>
    531e:	10 e0       	ldi	r17, 0x00	; 0
    5320:	11 23       	and	r17, r17
    5322:	09 f4       	brne	.+2      	; 0x5326 <chb_set_state+0x11c>
    5324:	89 c0       	rjmp	.+274    	; 0x5438 <chb_set_state+0x22e>
	{
		_delay_ms(__us / 1000.0);
    5326:	6a 81       	ldd	r22, Y+2	; 0x02
    5328:	7b 81       	ldd	r23, Y+3	; 0x03
    532a:	8c 81       	ldd	r24, Y+4	; 0x04
    532c:	9d 81       	ldd	r25, Y+5	; 0x05
    532e:	20 e0       	ldi	r18, 0x00	; 0
    5330:	30 e0       	ldi	r19, 0x00	; 0
    5332:	4a e7       	ldi	r20, 0x7A	; 122
    5334:	54 e4       	ldi	r21, 0x44	; 68
    5336:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
    533a:	dc 01       	movw	r26, r24
    533c:	cb 01       	movw	r24, r22
    533e:	8b 87       	std	Y+11, r24	; 0x0b
    5340:	9c 87       	std	Y+12, r25	; 0x0c
    5342:	ad 87       	std	Y+13, r26	; 0x0d
    5344:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5346:	6b 85       	ldd	r22, Y+11	; 0x0b
    5348:	7c 85       	ldd	r23, Y+12	; 0x0c
    534a:	8d 85       	ldd	r24, Y+13	; 0x0d
    534c:	9e 85       	ldd	r25, Y+14	; 0x0e
    534e:	20 e0       	ldi	r18, 0x00	; 0
    5350:	30 e0       	ldi	r19, 0x00	; 0
    5352:	4a e7       	ldi	r20, 0x7A	; 122
    5354:	53 e4       	ldi	r21, 0x43	; 67
    5356:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    535a:	dc 01       	movw	r26, r24
    535c:	cb 01       	movw	r24, r22
    535e:	8f 87       	std	Y+15, r24	; 0x0f
    5360:	98 8b       	std	Y+16, r25	; 0x10
    5362:	a9 8b       	std	Y+17, r26	; 0x11
    5364:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    5366:	11 e0       	ldi	r17, 0x01	; 1
    5368:	6f 85       	ldd	r22, Y+15	; 0x0f
    536a:	78 89       	ldd	r23, Y+16	; 0x10
    536c:	89 89       	ldd	r24, Y+17	; 0x11
    536e:	9a 89       	ldd	r25, Y+18	; 0x12
    5370:	20 e0       	ldi	r18, 0x00	; 0
    5372:	30 e0       	ldi	r19, 0x00	; 0
    5374:	40 e8       	ldi	r20, 0x80	; 128
    5376:	5f e3       	ldi	r21, 0x3F	; 63
    5378:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    537c:	88 23       	and	r24, r24
    537e:	0c f0       	brlt	.+2      	; 0x5382 <chb_set_state+0x178>
    5380:	10 e0       	ldi	r17, 0x00	; 0
    5382:	11 23       	and	r17, r17
    5384:	29 f0       	breq	.+10     	; 0x5390 <chb_set_state+0x186>
		__ticks = 1;
    5386:	81 e0       	ldi	r24, 0x01	; 1
    5388:	90 e0       	ldi	r25, 0x00	; 0
    538a:	8b 8b       	std	Y+19, r24	; 0x13
    538c:	9c 8b       	std	Y+20, r25	; 0x14
    538e:	46 c0       	rjmp	.+140    	; 0x541c <chb_set_state+0x212>
	else if (__tmp > 65535)
    5390:	11 e0       	ldi	r17, 0x01	; 1
    5392:	6f 85       	ldd	r22, Y+15	; 0x0f
    5394:	78 89       	ldd	r23, Y+16	; 0x10
    5396:	89 89       	ldd	r24, Y+17	; 0x11
    5398:	9a 89       	ldd	r25, Y+18	; 0x12
    539a:	20 e0       	ldi	r18, 0x00	; 0
    539c:	3f ef       	ldi	r19, 0xFF	; 255
    539e:	4f e7       	ldi	r20, 0x7F	; 127
    53a0:	57 e4       	ldi	r21, 0x47	; 71
    53a2:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    53a6:	18 16       	cp	r1, r24
    53a8:	0c f0       	brlt	.+2      	; 0x53ac <chb_set_state+0x1a2>
    53aa:	10 e0       	ldi	r17, 0x00	; 0
    53ac:	11 23       	and	r17, r17
    53ae:	61 f1       	breq	.+88     	; 0x5408 <chb_set_state+0x1fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    53b0:	6b 85       	ldd	r22, Y+11	; 0x0b
    53b2:	7c 85       	ldd	r23, Y+12	; 0x0c
    53b4:	8d 85       	ldd	r24, Y+13	; 0x0d
    53b6:	9e 85       	ldd	r25, Y+14	; 0x0e
    53b8:	20 e0       	ldi	r18, 0x00	; 0
    53ba:	30 e0       	ldi	r19, 0x00	; 0
    53bc:	40 e2       	ldi	r20, 0x20	; 32
    53be:	51 e4       	ldi	r21, 0x41	; 65
    53c0:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    53c4:	dc 01       	movw	r26, r24
    53c6:	cb 01       	movw	r24, r22
    53c8:	bc 01       	movw	r22, r24
    53ca:	cd 01       	movw	r24, r26
    53cc:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    53d0:	dc 01       	movw	r26, r24
    53d2:	cb 01       	movw	r24, r22
    53d4:	8b 8b       	std	Y+19, r24	; 0x13
    53d6:	9c 8b       	std	Y+20, r25	; 0x14
    53d8:	12 c0       	rjmp	.+36     	; 0x53fe <chb_set_state+0x1f4>
    53da:	89 e1       	ldi	r24, 0x19	; 25
    53dc:	90 e0       	ldi	r25, 0x00	; 0
    53de:	8d 8b       	std	Y+21, r24	; 0x15
    53e0:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    53e2:	8d 89       	ldd	r24, Y+21	; 0x15
    53e4:	9e 89       	ldd	r25, Y+22	; 0x16
    53e6:	8c 01       	movw	r16, r24
    53e8:	c8 01       	movw	r24, r16
    53ea:	01 97       	sbiw	r24, 0x01	; 1
    53ec:	f1 f7       	brne	.-4      	; 0x53ea <chb_set_state+0x1e0>
    53ee:	8c 01       	movw	r16, r24
    53f0:	0d 8b       	std	Y+21, r16	; 0x15
    53f2:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    53f4:	8b 89       	ldd	r24, Y+19	; 0x13
    53f6:	9c 89       	ldd	r25, Y+20	; 0x14
    53f8:	01 97       	sbiw	r24, 0x01	; 1
    53fa:	8b 8b       	std	Y+19, r24	; 0x13
    53fc:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    53fe:	8b 89       	ldd	r24, Y+19	; 0x13
    5400:	9c 89       	ldd	r25, Y+20	; 0x14
    5402:	00 97       	sbiw	r24, 0x00	; 0
    5404:	51 f7       	brne	.-44     	; 0x53da <chb_set_state+0x1d0>
    5406:	29 c0       	rjmp	.+82     	; 0x545a <chb_set_state+0x250>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5408:	6f 85       	ldd	r22, Y+15	; 0x0f
    540a:	78 89       	ldd	r23, Y+16	; 0x10
    540c:	89 89       	ldd	r24, Y+17	; 0x11
    540e:	9a 89       	ldd	r25, Y+18	; 0x12
    5410:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    5414:	dc 01       	movw	r26, r24
    5416:	cb 01       	movw	r24, r22
    5418:	8b 8b       	std	Y+19, r24	; 0x13
    541a:	9c 8b       	std	Y+20, r25	; 0x14
    541c:	8b 89       	ldd	r24, Y+19	; 0x13
    541e:	9c 89       	ldd	r25, Y+20	; 0x14
    5420:	8f 8b       	std	Y+23, r24	; 0x17
    5422:	98 8f       	std	Y+24, r25	; 0x18
    5424:	8f 89       	ldd	r24, Y+23	; 0x17
    5426:	98 8d       	ldd	r25, Y+24	; 0x18
    5428:	8c 01       	movw	r16, r24
    542a:	f8 01       	movw	r30, r16
    542c:	31 97       	sbiw	r30, 0x01	; 1
    542e:	f1 f7       	brne	.-4      	; 0x542c <chb_set_state+0x222>
    5430:	8f 01       	movw	r16, r30
    5432:	0f 8b       	std	Y+23, r16	; 0x17
    5434:	18 8f       	std	Y+24, r17	; 0x18
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;
    5436:	24 c2       	rjmp	.+1096   	; 0x5880 <chb_set_state+0x676>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5438:	6e 81       	ldd	r22, Y+6	; 0x06
    543a:	7f 81       	ldd	r23, Y+7	; 0x07
    543c:	88 85       	ldd	r24, Y+8	; 0x08
    543e:	99 85       	ldd	r25, Y+9	; 0x09
    5440:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    5444:	dc 01       	movw	r26, r24
    5446:	cb 01       	movw	r24, r22
    5448:	8a 87       	std	Y+10, r24	; 0x0a
    544a:	8a 85       	ldd	r24, Y+10	; 0x0a
    544c:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    544e:	89 8d       	ldd	r24, Y+25	; 0x19
    5450:	18 2f       	mov	r17, r24
    5452:	1a 95       	dec	r17
    5454:	f1 f7       	brne	.-4      	; 0x5452 <chb_set_state+0x248>
    5456:	19 8f       	std	Y+25, r17	; 0x19
    5458:	13 c2       	rjmp	.+1062   	; 0x5880 <chb_set_state+0x676>
    545a:	12 c2       	rjmp	.+1060   	; 0x5880 <chb_set_state+0x676>

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    545c:	89 81       	ldd	r24, Y+1	; 0x01
    545e:	86 31       	cpi	r24, 0x16	; 22
    5460:	09 f0       	breq	.+2      	; 0x5464 <chb_set_state+0x25a>
    5462:	0b c2       	rjmp	.+1046   	; 0x587a <chb_set_state+0x670>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    5464:	82 e0       	ldi	r24, 0x02	; 2
    5466:	69 e0       	ldi	r22, 0x09	; 9
    5468:	4f e1       	ldi	r20, 0x1F	; 31
    546a:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>
    546e:	80 e0       	ldi	r24, 0x00	; 0
    5470:	90 e0       	ldi	r25, 0x00	; 0
    5472:	a0 e8       	ldi	r26, 0x80	; 128
    5474:	bf e3       	ldi	r27, 0x3F	; 63
    5476:	8a 8f       	std	Y+26, r24	; 0x1a
    5478:	9b 8f       	std	Y+27, r25	; 0x1b
    547a:	ac 8f       	std	Y+28, r26	; 0x1c
    547c:	bd 8f       	std	Y+29, r27	; 0x1d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    547e:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5480:	7b 8d       	ldd	r23, Y+27	; 0x1b
    5482:	8c 8d       	ldd	r24, Y+28	; 0x1c
    5484:	9d 8d       	ldd	r25, Y+29	; 0x1d
    5486:	2b ea       	ldi	r18, 0xAB	; 171
    5488:	3a ea       	ldi	r19, 0xAA	; 170
    548a:	4a ea       	ldi	r20, 0xAA	; 170
    548c:	5e e3       	ldi	r21, 0x3E	; 62
    548e:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    5492:	dc 01       	movw	r26, r24
    5494:	cb 01       	movw	r24, r22
    5496:	8e 8f       	std	Y+30, r24	; 0x1e
    5498:	9f 8f       	std	Y+31, r25	; 0x1f
    549a:	a8 a3       	lds	r26, 0x58
    549c:	b9 a3       	lds	r27, 0x59
	if (__tmp < 1.0)
    549e:	11 e0       	ldi	r17, 0x01	; 1
    54a0:	6e 8d       	ldd	r22, Y+30	; 0x1e
    54a2:	7f 8d       	ldd	r23, Y+31	; 0x1f
    54a4:	88 a1       	lds	r24, 0x48
    54a6:	99 a1       	lds	r25, 0x49
    54a8:	20 e0       	ldi	r18, 0x00	; 0
    54aa:	30 e0       	ldi	r19, 0x00	; 0
    54ac:	40 e8       	ldi	r20, 0x80	; 128
    54ae:	5f e3       	ldi	r21, 0x3F	; 63
    54b0:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    54b4:	88 23       	and	r24, r24
    54b6:	0c f0       	brlt	.+2      	; 0x54ba <chb_set_state+0x2b0>
    54b8:	10 e0       	ldi	r17, 0x00	; 0
    54ba:	11 23       	and	r17, r17
    54bc:	19 f0       	breq	.+6      	; 0x54c4 <chb_set_state+0x2ba>
		__ticks = 1;
    54be:	81 e0       	ldi	r24, 0x01	; 1
    54c0:	8a a3       	lds	r24, 0x5a
    54c2:	a3 c0       	rjmp	.+326    	; 0x560a <chb_set_state+0x400>
	else if (__tmp > 255)
    54c4:	11 e0       	ldi	r17, 0x01	; 1
    54c6:	6e 8d       	ldd	r22, Y+30	; 0x1e
    54c8:	7f 8d       	ldd	r23, Y+31	; 0x1f
    54ca:	88 a1       	lds	r24, 0x48
    54cc:	99 a1       	lds	r25, 0x49
    54ce:	20 e0       	ldi	r18, 0x00	; 0
    54d0:	30 e0       	ldi	r19, 0x00	; 0
    54d2:	4f e7       	ldi	r20, 0x7F	; 127
    54d4:	53 e4       	ldi	r21, 0x43	; 67
    54d6:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    54da:	18 16       	cp	r1, r24
    54dc:	0c f0       	brlt	.+2      	; 0x54e0 <chb_set_state+0x2d6>
    54de:	10 e0       	ldi	r17, 0x00	; 0
    54e0:	11 23       	and	r17, r17
    54e2:	09 f4       	brne	.+2      	; 0x54e6 <chb_set_state+0x2dc>
    54e4:	89 c0       	rjmp	.+274    	; 0x55f8 <chb_set_state+0x3ee>
	{
		_delay_ms(__us / 1000.0);
    54e6:	6a 8d       	ldd	r22, Y+26	; 0x1a
    54e8:	7b 8d       	ldd	r23, Y+27	; 0x1b
    54ea:	8c 8d       	ldd	r24, Y+28	; 0x1c
    54ec:	9d 8d       	ldd	r25, Y+29	; 0x1d
    54ee:	20 e0       	ldi	r18, 0x00	; 0
    54f0:	30 e0       	ldi	r19, 0x00	; 0
    54f2:	4a e7       	ldi	r20, 0x7A	; 122
    54f4:	54 e4       	ldi	r21, 0x44	; 68
    54f6:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
    54fa:	dc 01       	movw	r26, r24
    54fc:	cb 01       	movw	r24, r22
    54fe:	8b a3       	lds	r24, 0x5b
    5500:	9c a3       	lds	r25, 0x5c
    5502:	ad a3       	lds	r26, 0x5d
    5504:	be a3       	lds	r27, 0x5e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5506:	6b a1       	lds	r22, 0x4b
    5508:	7c a1       	lds	r23, 0x4c
    550a:	8d a1       	lds	r24, 0x4d
    550c:	9e a1       	lds	r25, 0x4e
    550e:	20 e0       	ldi	r18, 0x00	; 0
    5510:	30 e0       	ldi	r19, 0x00	; 0
    5512:	4a e7       	ldi	r20, 0x7A	; 122
    5514:	53 e4       	ldi	r21, 0x43	; 67
    5516:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    551a:	dc 01       	movw	r26, r24
    551c:	cb 01       	movw	r24, r22
    551e:	8f a3       	lds	r24, 0x5f
    5520:	98 a7       	lds	r25, 0x78
    5522:	a9 a7       	lds	r26, 0x79
    5524:	ba a7       	lds	r27, 0x7a
	if (__tmp < 1.0)
    5526:	11 e0       	ldi	r17, 0x01	; 1
    5528:	6f a1       	lds	r22, 0x4f
    552a:	78 a5       	lds	r23, 0x68
    552c:	89 a5       	lds	r24, 0x69
    552e:	9a a5       	lds	r25, 0x6a
    5530:	20 e0       	ldi	r18, 0x00	; 0
    5532:	30 e0       	ldi	r19, 0x00	; 0
    5534:	40 e8       	ldi	r20, 0x80	; 128
    5536:	5f e3       	ldi	r21, 0x3F	; 63
    5538:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    553c:	88 23       	and	r24, r24
    553e:	0c f0       	brlt	.+2      	; 0x5542 <chb_set_state+0x338>
    5540:	10 e0       	ldi	r17, 0x00	; 0
    5542:	11 23       	and	r17, r17
    5544:	29 f0       	breq	.+10     	; 0x5550 <chb_set_state+0x346>
		__ticks = 1;
    5546:	81 e0       	ldi	r24, 0x01	; 1
    5548:	90 e0       	ldi	r25, 0x00	; 0
    554a:	8b a7       	lds	r24, 0x7b
    554c:	9c a7       	lds	r25, 0x7c
    554e:	46 c0       	rjmp	.+140    	; 0x55dc <chb_set_state+0x3d2>
	else if (__tmp > 65535)
    5550:	11 e0       	ldi	r17, 0x01	; 1
    5552:	6f a1       	lds	r22, 0x4f
    5554:	78 a5       	lds	r23, 0x68
    5556:	89 a5       	lds	r24, 0x69
    5558:	9a a5       	lds	r25, 0x6a
    555a:	20 e0       	ldi	r18, 0x00	; 0
    555c:	3f ef       	ldi	r19, 0xFF	; 255
    555e:	4f e7       	ldi	r20, 0x7F	; 127
    5560:	57 e4       	ldi	r21, 0x47	; 71
    5562:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    5566:	18 16       	cp	r1, r24
    5568:	0c f0       	brlt	.+2      	; 0x556c <chb_set_state+0x362>
    556a:	10 e0       	ldi	r17, 0x00	; 0
    556c:	11 23       	and	r17, r17
    556e:	61 f1       	breq	.+88     	; 0x55c8 <chb_set_state+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5570:	6b a1       	lds	r22, 0x4b
    5572:	7c a1       	lds	r23, 0x4c
    5574:	8d a1       	lds	r24, 0x4d
    5576:	9e a1       	lds	r25, 0x4e
    5578:	20 e0       	ldi	r18, 0x00	; 0
    557a:	30 e0       	ldi	r19, 0x00	; 0
    557c:	40 e2       	ldi	r20, 0x20	; 32
    557e:	51 e4       	ldi	r21, 0x41	; 65
    5580:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    5584:	dc 01       	movw	r26, r24
    5586:	cb 01       	movw	r24, r22
    5588:	bc 01       	movw	r22, r24
    558a:	cd 01       	movw	r24, r26
    558c:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    5590:	dc 01       	movw	r26, r24
    5592:	cb 01       	movw	r24, r22
    5594:	8b a7       	lds	r24, 0x7b
    5596:	9c a7       	lds	r25, 0x7c
    5598:	12 c0       	rjmp	.+36     	; 0x55be <chb_set_state+0x3b4>
    559a:	89 e1       	ldi	r24, 0x19	; 25
    559c:	90 e0       	ldi	r25, 0x00	; 0
    559e:	8d a7       	lds	r24, 0x7d
    55a0:	9e a7       	lds	r25, 0x7e
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    55a2:	8d a5       	lds	r24, 0x6d
    55a4:	9e a5       	lds	r25, 0x6e
    55a6:	8c 01       	movw	r16, r24
    55a8:	c8 01       	movw	r24, r16
    55aa:	01 97       	sbiw	r24, 0x01	; 1
    55ac:	f1 f7       	brne	.-4      	; 0x55aa <chb_set_state+0x3a0>
    55ae:	8c 01       	movw	r16, r24
    55b0:	0d a7       	lds	r16, 0x7d
    55b2:	1e a7       	lds	r17, 0x7e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    55b4:	8b a5       	lds	r24, 0x6b
    55b6:	9c a5       	lds	r25, 0x6c
    55b8:	01 97       	sbiw	r24, 0x01	; 1
    55ba:	8b a7       	lds	r24, 0x7b
    55bc:	9c a7       	lds	r25, 0x7c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    55be:	8b a5       	lds	r24, 0x6b
    55c0:	9c a5       	lds	r25, 0x6c
    55c2:	00 97       	sbiw	r24, 0x00	; 0
    55c4:	51 f7       	brne	.-44     	; 0x559a <chb_set_state+0x390>
    55c6:	29 c0       	rjmp	.+82     	; 0x561a <chb_set_state+0x410>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    55c8:	6f a1       	lds	r22, 0x4f
    55ca:	78 a5       	lds	r23, 0x68
    55cc:	89 a5       	lds	r24, 0x69
    55ce:	9a a5       	lds	r25, 0x6a
    55d0:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    55d4:	dc 01       	movw	r26, r24
    55d6:	cb 01       	movw	r24, r22
    55d8:	8b a7       	lds	r24, 0x7b
    55da:	9c a7       	lds	r25, 0x7c
    55dc:	8b a5       	lds	r24, 0x6b
    55de:	9c a5       	lds	r25, 0x6c
    55e0:	8f a7       	lds	r24, 0x7f
    55e2:	98 ab       	sts	0x58, r25
    55e4:	8f a5       	lds	r24, 0x6f
    55e6:	98 a9       	sts	0x48, r25
    55e8:	8c 01       	movw	r16, r24
    55ea:	f8 01       	movw	r30, r16
    55ec:	31 97       	sbiw	r30, 0x01	; 1
    55ee:	f1 f7       	brne	.-4      	; 0x55ec <chb_set_state+0x3e2>
    55f0:	8f 01       	movw	r16, r30
    55f2:	0f a7       	lds	r16, 0x7f
    55f4:	18 ab       	sts	0x58, r17
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    55f6:	41 c1       	rjmp	.+642    	; 0x587a <chb_set_state+0x670>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    55f8:	6e 8d       	ldd	r22, Y+30	; 0x1e
    55fa:	7f 8d       	ldd	r23, Y+31	; 0x1f
    55fc:	88 a1       	lds	r24, 0x48
    55fe:	99 a1       	lds	r25, 0x49
    5600:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    5604:	dc 01       	movw	r26, r24
    5606:	cb 01       	movw	r24, r22
    5608:	8a a3       	lds	r24, 0x5a
    560a:	8a a1       	lds	r24, 0x4a
    560c:	89 ab       	sts	0x59, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    560e:	89 a9       	sts	0x49, r24
    5610:	18 2f       	mov	r17, r24
    5612:	1a 95       	dec	r17
    5614:	f1 f7       	brne	.-4      	; 0x5612 <chb_set_state+0x408>
    5616:	19 ab       	sts	0x59, r17
    5618:	30 c1       	rjmp	.+608    	; 0x587a <chb_set_state+0x670>
    561a:	2f c1       	rjmp	.+606    	; 0x587a <chb_set_state+0x670>

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    561c:	89 81       	ldd	r24, Y+1	; 0x01
    561e:	89 31       	cpi	r24, 0x19	; 25
    5620:	09 f0       	breq	.+2      	; 0x5624 <chb_set_state+0x41a>
    5622:	2d c1       	rjmp	.+602    	; 0x587e <chb_set_state+0x674>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    5624:	82 e0       	ldi	r24, 0x02	; 2
    5626:	69 e0       	ldi	r22, 0x09	; 9
    5628:	4f e1       	ldi	r20, 0x1F	; 31
    562a:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>
    562e:	80 e0       	ldi	r24, 0x00	; 0
    5630:	90 e0       	ldi	r25, 0x00	; 0
    5632:	a0 e8       	ldi	r26, 0x80	; 128
    5634:	bf e3       	ldi	r27, 0x3F	; 63
    5636:	8a ab       	sts	0x5a, r24
    5638:	9b ab       	sts	0x5b, r25
    563a:	ac ab       	sts	0x5c, r26
    563c:	bd ab       	sts	0x5d, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    563e:	6a a9       	sts	0x4a, r22
    5640:	7b a9       	sts	0x4b, r23
    5642:	8c a9       	sts	0x4c, r24
    5644:	9d a9       	sts	0x4d, r25
    5646:	2b ea       	ldi	r18, 0xAB	; 171
    5648:	3a ea       	ldi	r19, 0xAA	; 170
    564a:	4a ea       	ldi	r20, 0xAA	; 170
    564c:	5e e3       	ldi	r21, 0x3E	; 62
    564e:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    5652:	dc 01       	movw	r26, r24
    5654:	cb 01       	movw	r24, r22
    5656:	8e ab       	sts	0x5e, r24
    5658:	9f ab       	sts	0x5f, r25
    565a:	a8 af       	sts	0x78, r26
    565c:	b9 af       	sts	0x79, r27
	if (__tmp < 1.0)
    565e:	11 e0       	ldi	r17, 0x01	; 1
    5660:	6e a9       	sts	0x4e, r22
    5662:	7f a9       	sts	0x4f, r23
    5664:	88 ad       	sts	0x68, r24
    5666:	99 ad       	sts	0x69, r25
    5668:	20 e0       	ldi	r18, 0x00	; 0
    566a:	30 e0       	ldi	r19, 0x00	; 0
    566c:	40 e8       	ldi	r20, 0x80	; 128
    566e:	5f e3       	ldi	r21, 0x3F	; 63
    5670:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    5674:	88 23       	and	r24, r24
    5676:	0c f0       	brlt	.+2      	; 0x567a <chb_set_state+0x470>
    5678:	10 e0       	ldi	r17, 0x00	; 0
    567a:	11 23       	and	r17, r17
    567c:	19 f0       	breq	.+6      	; 0x5684 <chb_set_state+0x47a>
		__ticks = 1;
    567e:	81 e0       	ldi	r24, 0x01	; 1
    5680:	8a af       	sts	0x7a, r24
    5682:	e6 c0       	rjmp	.+460    	; 0x5850 <chb_set_state+0x646>
	else if (__tmp > 255)
    5684:	11 e0       	ldi	r17, 0x01	; 1
    5686:	6e a9       	sts	0x4e, r22
    5688:	7f a9       	sts	0x4f, r23
    568a:	88 ad       	sts	0x68, r24
    568c:	99 ad       	sts	0x69, r25
    568e:	20 e0       	ldi	r18, 0x00	; 0
    5690:	30 e0       	ldi	r19, 0x00	; 0
    5692:	4f e7       	ldi	r20, 0x7F	; 127
    5694:	53 e4       	ldi	r21, 0x43	; 67
    5696:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    569a:	18 16       	cp	r1, r24
    569c:	0c f0       	brlt	.+2      	; 0x56a0 <chb_set_state+0x496>
    569e:	10 e0       	ldi	r17, 0x00	; 0
    56a0:	11 23       	and	r17, r17
    56a2:	09 f4       	brne	.+2      	; 0x56a6 <chb_set_state+0x49c>
    56a4:	cc c0       	rjmp	.+408    	; 0x583e <chb_set_state+0x634>
	{
		_delay_ms(__us / 1000.0);
    56a6:	6a a9       	sts	0x4a, r22
    56a8:	7b a9       	sts	0x4b, r23
    56aa:	8c a9       	sts	0x4c, r24
    56ac:	9d a9       	sts	0x4d, r25
    56ae:	20 e0       	ldi	r18, 0x00	; 0
    56b0:	30 e0       	ldi	r19, 0x00	; 0
    56b2:	4a e7       	ldi	r20, 0x7A	; 122
    56b4:	54 e4       	ldi	r21, 0x44	; 68
    56b6:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
    56ba:	dc 01       	movw	r26, r24
    56bc:	cb 01       	movw	r24, r22
    56be:	8b af       	sts	0x7b, r24
    56c0:	9c af       	sts	0x7c, r25
    56c2:	ad af       	sts	0x7d, r26
    56c4:	be af       	sts	0x7e, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    56c6:	8e 01       	movw	r16, r28
    56c8:	01 5c       	subi	r16, 0xC1	; 193
    56ca:	1f 4f       	sbci	r17, 0xFF	; 255
    56cc:	6b ad       	sts	0x6b, r22
    56ce:	7c ad       	sts	0x6c, r23
    56d0:	8d ad       	sts	0x6d, r24
    56d2:	9e ad       	sts	0x6e, r25
    56d4:	20 e0       	ldi	r18, 0x00	; 0
    56d6:	30 e0       	ldi	r19, 0x00	; 0
    56d8:	4a e7       	ldi	r20, 0x7A	; 122
    56da:	53 e4       	ldi	r21, 0x43	; 67
    56dc:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    56e0:	dc 01       	movw	r26, r24
    56e2:	cb 01       	movw	r24, r22
    56e4:	f8 01       	movw	r30, r16
    56e6:	80 83       	st	Z, r24
    56e8:	91 83       	std	Z+1, r25	; 0x01
    56ea:	a2 83       	std	Z+2, r26	; 0x02
    56ec:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    56ee:	ce 01       	movw	r24, r28
    56f0:	cf 96       	adiw	r24, 0x3f	; 63
    56f2:	11 e0       	ldi	r17, 0x01	; 1
    56f4:	fc 01       	movw	r30, r24
    56f6:	60 81       	ld	r22, Z
    56f8:	71 81       	ldd	r23, Z+1	; 0x01
    56fa:	82 81       	ldd	r24, Z+2	; 0x02
    56fc:	93 81       	ldd	r25, Z+3	; 0x03
    56fe:	20 e0       	ldi	r18, 0x00	; 0
    5700:	30 e0       	ldi	r19, 0x00	; 0
    5702:	40 e8       	ldi	r20, 0x80	; 128
    5704:	5f e3       	ldi	r21, 0x3F	; 63
    5706:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    570a:	88 23       	and	r24, r24
    570c:	0c f0       	brlt	.+2      	; 0x5710 <chb_set_state+0x506>
    570e:	10 e0       	ldi	r17, 0x00	; 0
    5710:	11 23       	and	r17, r17
    5712:	49 f0       	breq	.+18     	; 0x5726 <chb_set_state+0x51c>
		__ticks = 1;
    5714:	ce 01       	movw	r24, r28
    5716:	8d 5b       	subi	r24, 0xBD	; 189
    5718:	9f 4f       	sbci	r25, 0xFF	; 255
    571a:	21 e0       	ldi	r18, 0x01	; 1
    571c:	30 e0       	ldi	r19, 0x00	; 0
    571e:	fc 01       	movw	r30, r24
    5720:	20 83       	st	Z, r18
    5722:	31 83       	std	Z+1, r19	; 0x01
    5724:	6e c0       	rjmp	.+220    	; 0x5802 <chb_set_state+0x5f8>
	else if (__tmp > 65535)
    5726:	ce 01       	movw	r24, r28
    5728:	cf 96       	adiw	r24, 0x3f	; 63
    572a:	11 e0       	ldi	r17, 0x01	; 1
    572c:	fc 01       	movw	r30, r24
    572e:	60 81       	ld	r22, Z
    5730:	71 81       	ldd	r23, Z+1	; 0x01
    5732:	82 81       	ldd	r24, Z+2	; 0x02
    5734:	93 81       	ldd	r25, Z+3	; 0x03
    5736:	20 e0       	ldi	r18, 0x00	; 0
    5738:	3f ef       	ldi	r19, 0xFF	; 255
    573a:	4f e7       	ldi	r20, 0x7F	; 127
    573c:	57 e4       	ldi	r21, 0x47	; 71
    573e:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    5742:	18 16       	cp	r1, r24
    5744:	0c f0       	brlt	.+2      	; 0x5748 <chb_set_state+0x53e>
    5746:	10 e0       	ldi	r17, 0x00	; 0
    5748:	11 23       	and	r17, r17
    574a:	09 f4       	brne	.+2      	; 0x574e <chb_set_state+0x544>
    574c:	49 c0       	rjmp	.+146    	; 0x57e0 <chb_set_state+0x5d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    574e:	6b ad       	sts	0x6b, r22
    5750:	7c ad       	sts	0x6c, r23
    5752:	8d ad       	sts	0x6d, r24
    5754:	9e ad       	sts	0x6e, r25
    5756:	20 e0       	ldi	r18, 0x00	; 0
    5758:	30 e0       	ldi	r19, 0x00	; 0
    575a:	40 e2       	ldi	r20, 0x20	; 32
    575c:	51 e4       	ldi	r21, 0x41	; 65
    575e:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    5762:	dc 01       	movw	r26, r24
    5764:	cb 01       	movw	r24, r22
    5766:	8e 01       	movw	r16, r28
    5768:	0d 5b       	subi	r16, 0xBD	; 189
    576a:	1f 4f       	sbci	r17, 0xFF	; 255
    576c:	bc 01       	movw	r22, r24
    576e:	cd 01       	movw	r24, r26
    5770:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    5774:	dc 01       	movw	r26, r24
    5776:	cb 01       	movw	r24, r22
    5778:	f8 01       	movw	r30, r16
    577a:	80 83       	st	Z, r24
    577c:	91 83       	std	Z+1, r25	; 0x01
    577e:	27 c0       	rjmp	.+78     	; 0x57ce <chb_set_state+0x5c4>
    5780:	ce 01       	movw	r24, r28
    5782:	8b 5b       	subi	r24, 0xBB	; 187
    5784:	9f 4f       	sbci	r25, 0xFF	; 255
    5786:	29 e1       	ldi	r18, 0x19	; 25
    5788:	30 e0       	ldi	r19, 0x00	; 0
    578a:	fc 01       	movw	r30, r24
    578c:	20 83       	st	Z, r18
    578e:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5790:	ce 01       	movw	r24, r28
    5792:	8b 5b       	subi	r24, 0xBB	; 187
    5794:	9f 4f       	sbci	r25, 0xFF	; 255
    5796:	fc 01       	movw	r30, r24
    5798:	80 81       	ld	r24, Z
    579a:	91 81       	ldd	r25, Z+1	; 0x01
    579c:	8c 01       	movw	r16, r24
    579e:	c8 01       	movw	r24, r16
    57a0:	01 97       	sbiw	r24, 0x01	; 1
    57a2:	f1 f7       	brne	.-4      	; 0x57a0 <chb_set_state+0x596>
    57a4:	8c 01       	movw	r16, r24
    57a6:	ce 01       	movw	r24, r28
    57a8:	8b 5b       	subi	r24, 0xBB	; 187
    57aa:	9f 4f       	sbci	r25, 0xFF	; 255
    57ac:	fc 01       	movw	r30, r24
    57ae:	00 83       	st	Z, r16
    57b0:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    57b2:	ce 01       	movw	r24, r28
    57b4:	8d 5b       	subi	r24, 0xBD	; 189
    57b6:	9f 4f       	sbci	r25, 0xFF	; 255
    57b8:	9e 01       	movw	r18, r28
    57ba:	2d 5b       	subi	r18, 0xBD	; 189
    57bc:	3f 4f       	sbci	r19, 0xFF	; 255
    57be:	f9 01       	movw	r30, r18
    57c0:	20 81       	ld	r18, Z
    57c2:	31 81       	ldd	r19, Z+1	; 0x01
    57c4:	21 50       	subi	r18, 0x01	; 1
    57c6:	30 40       	sbci	r19, 0x00	; 0
    57c8:	fc 01       	movw	r30, r24
    57ca:	20 83       	st	Z, r18
    57cc:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    57ce:	ce 01       	movw	r24, r28
    57d0:	8d 5b       	subi	r24, 0xBD	; 189
    57d2:	9f 4f       	sbci	r25, 0xFF	; 255
    57d4:	fc 01       	movw	r30, r24
    57d6:	80 81       	ld	r24, Z
    57d8:	91 81       	ldd	r25, Z+1	; 0x01
    57da:	00 97       	sbiw	r24, 0x00	; 0
    57dc:	89 f6       	brne	.-94     	; 0x5780 <chb_set_state+0x576>
    57de:	4c c0       	rjmp	.+152    	; 0x5878 <chb_set_state+0x66e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    57e0:	8e 01       	movw	r16, r28
    57e2:	0d 5b       	subi	r16, 0xBD	; 189
    57e4:	1f 4f       	sbci	r17, 0xFF	; 255
    57e6:	ce 01       	movw	r24, r28
    57e8:	cf 96       	adiw	r24, 0x3f	; 63
    57ea:	fc 01       	movw	r30, r24
    57ec:	60 81       	ld	r22, Z
    57ee:	71 81       	ldd	r23, Z+1	; 0x01
    57f0:	82 81       	ldd	r24, Z+2	; 0x02
    57f2:	93 81       	ldd	r25, Z+3	; 0x03
    57f4:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    57f8:	dc 01       	movw	r26, r24
    57fa:	cb 01       	movw	r24, r22
    57fc:	f8 01       	movw	r30, r16
    57fe:	80 83       	st	Z, r24
    5800:	91 83       	std	Z+1, r25	; 0x01
    5802:	ce 01       	movw	r24, r28
    5804:	89 5b       	subi	r24, 0xB9	; 185
    5806:	9f 4f       	sbci	r25, 0xFF	; 255
    5808:	9e 01       	movw	r18, r28
    580a:	2d 5b       	subi	r18, 0xBD	; 189
    580c:	3f 4f       	sbci	r19, 0xFF	; 255
    580e:	f9 01       	movw	r30, r18
    5810:	20 81       	ld	r18, Z
    5812:	31 81       	ldd	r19, Z+1	; 0x01
    5814:	fc 01       	movw	r30, r24
    5816:	20 83       	st	Z, r18
    5818:	31 83       	std	Z+1, r19	; 0x01
    581a:	ce 01       	movw	r24, r28
    581c:	89 5b       	subi	r24, 0xB9	; 185
    581e:	9f 4f       	sbci	r25, 0xFF	; 255
    5820:	fc 01       	movw	r30, r24
    5822:	80 81       	ld	r24, Z
    5824:	91 81       	ldd	r25, Z+1	; 0x01
    5826:	8c 01       	movw	r16, r24
    5828:	c8 01       	movw	r24, r16
    582a:	01 97       	sbiw	r24, 0x01	; 1
    582c:	f1 f7       	brne	.-4      	; 0x582a <chb_set_state+0x620>
    582e:	8c 01       	movw	r16, r24
    5830:	ce 01       	movw	r24, r28
    5832:	89 5b       	subi	r24, 0xB9	; 185
    5834:	9f 4f       	sbci	r25, 0xFF	; 255
    5836:	fc 01       	movw	r30, r24
    5838:	00 83       	st	Z, r16
    583a:	11 83       	std	Z+1, r17	; 0x01
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    583c:	20 c0       	rjmp	.+64     	; 0x587e <chb_set_state+0x674>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    583e:	6e a9       	sts	0x4e, r22
    5840:	7f a9       	sts	0x4f, r23
    5842:	88 ad       	sts	0x68, r24
    5844:	99 ad       	sts	0x69, r25
    5846:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    584a:	dc 01       	movw	r26, r24
    584c:	cb 01       	movw	r24, r22
    584e:	8a af       	sts	0x7a, r24
    5850:	ce 01       	movw	r24, r28
    5852:	87 5b       	subi	r24, 0xB7	; 183
    5854:	9f 4f       	sbci	r25, 0xFF	; 255
    5856:	2a ad       	sts	0x6a, r18
    5858:	fc 01       	movw	r30, r24
    585a:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    585c:	ce 01       	movw	r24, r28
    585e:	87 5b       	subi	r24, 0xB7	; 183
    5860:	9f 4f       	sbci	r25, 0xFF	; 255
    5862:	fc 01       	movw	r30, r24
    5864:	80 81       	ld	r24, Z
    5866:	18 2f       	mov	r17, r24
    5868:	1a 95       	dec	r17
    586a:	f1 f7       	brne	.-4      	; 0x5868 <chb_set_state+0x65e>
    586c:	ce 01       	movw	r24, r28
    586e:	87 5b       	subi	r24, 0xB7	; 183
    5870:	9f 4f       	sbci	r25, 0xFF	; 255
    5872:	fc 01       	movw	r30, r24
    5874:	10 83       	st	Z, r17
    5876:	03 c0       	rjmp	.+6      	; 0x587e <chb_set_state+0x674>
    5878:	02 c0       	rjmp	.+4      	; 0x587e <chb_set_state+0x674>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    587a:	00 00       	nop
    587c:	01 c0       	rjmp	.+2      	; 0x5880 <chb_set_state+0x676>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    587e:	00 00       	nop
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    5880:	9e 01       	movw	r18, r28
    5882:	2e 59       	subi	r18, 0x9E	; 158
    5884:	3f 4f       	sbci	r19, 0xFF	; 255
    5886:	82 e0       	ldi	r24, 0x02	; 2
    5888:	f9 01       	movw	r30, r18
    588a:	60 81       	ld	r22, Z
    588c:	4f e1       	ldi	r20, 0x1F	; 31
    588e:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>
    5892:	9e 01       	movw	r18, r28
    5894:	26 5b       	subi	r18, 0xB6	; 182
    5896:	3f 4f       	sbci	r19, 0xFF	; 255
    5898:	80 e0       	ldi	r24, 0x00	; 0
    589a:	90 e0       	ldi	r25, 0x00	; 0
    589c:	ac ed       	ldi	r26, 0xDC	; 220
    589e:	b2 e4       	ldi	r27, 0x42	; 66
    58a0:	f9 01       	movw	r30, r18
    58a2:	80 83       	st	Z, r24
    58a4:	91 83       	std	Z+1, r25	; 0x01
    58a6:	a2 83       	std	Z+2, r26	; 0x02
    58a8:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    58aa:	8e 01       	movw	r16, r28
    58ac:	02 5b       	subi	r16, 0xB2	; 178
    58ae:	1f 4f       	sbci	r17, 0xFF	; 255
    58b0:	ce 01       	movw	r24, r28
    58b2:	86 5b       	subi	r24, 0xB6	; 182
    58b4:	9f 4f       	sbci	r25, 0xFF	; 255
    58b6:	fc 01       	movw	r30, r24
    58b8:	60 81       	ld	r22, Z
    58ba:	71 81       	ldd	r23, Z+1	; 0x01
    58bc:	82 81       	ldd	r24, Z+2	; 0x02
    58be:	93 81       	ldd	r25, Z+3	; 0x03
    58c0:	2b ea       	ldi	r18, 0xAB	; 171
    58c2:	3a ea       	ldi	r19, 0xAA	; 170
    58c4:	4a ea       	ldi	r20, 0xAA	; 170
    58c6:	5e e3       	ldi	r21, 0x3E	; 62
    58c8:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    58cc:	dc 01       	movw	r26, r24
    58ce:	cb 01       	movw	r24, r22
    58d0:	f8 01       	movw	r30, r16
    58d2:	80 83       	st	Z, r24
    58d4:	91 83       	std	Z+1, r25	; 0x01
    58d6:	a2 83       	std	Z+2, r26	; 0x02
    58d8:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    58da:	ce 01       	movw	r24, r28
    58dc:	82 5b       	subi	r24, 0xB2	; 178
    58de:	9f 4f       	sbci	r25, 0xFF	; 255
    58e0:	11 e0       	ldi	r17, 0x01	; 1
    58e2:	fc 01       	movw	r30, r24
    58e4:	60 81       	ld	r22, Z
    58e6:	71 81       	ldd	r23, Z+1	; 0x01
    58e8:	82 81       	ldd	r24, Z+2	; 0x02
    58ea:	93 81       	ldd	r25, Z+3	; 0x03
    58ec:	20 e0       	ldi	r18, 0x00	; 0
    58ee:	30 e0       	ldi	r19, 0x00	; 0
    58f0:	40 e8       	ldi	r20, 0x80	; 128
    58f2:	5f e3       	ldi	r21, 0x3F	; 63
    58f4:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    58f8:	88 23       	and	r24, r24
    58fa:	0c f0       	brlt	.+2      	; 0x58fe <chb_set_state+0x6f4>
    58fc:	10 e0       	ldi	r17, 0x00	; 0
    58fe:	11 23       	and	r17, r17
    5900:	39 f0       	breq	.+14     	; 0x5910 <chb_set_state+0x706>
		__ticks = 1;
    5902:	ce 01       	movw	r24, r28
    5904:	8e 5a       	subi	r24, 0xAE	; 174
    5906:	9f 4f       	sbci	r25, 0xFF	; 255
    5908:	21 e0       	ldi	r18, 0x01	; 1
    590a:	fc 01       	movw	r30, r24
    590c:	20 83       	st	Z, r18
    590e:	05 c1       	rjmp	.+522    	; 0x5b1a <chb_set_state+0x910>
	else if (__tmp > 255)
    5910:	ce 01       	movw	r24, r28
    5912:	82 5b       	subi	r24, 0xB2	; 178
    5914:	9f 4f       	sbci	r25, 0xFF	; 255
    5916:	11 e0       	ldi	r17, 0x01	; 1
    5918:	fc 01       	movw	r30, r24
    591a:	60 81       	ld	r22, Z
    591c:	71 81       	ldd	r23, Z+1	; 0x01
    591e:	82 81       	ldd	r24, Z+2	; 0x02
    5920:	93 81       	ldd	r25, Z+3	; 0x03
    5922:	20 e0       	ldi	r18, 0x00	; 0
    5924:	30 e0       	ldi	r19, 0x00	; 0
    5926:	4f e7       	ldi	r20, 0x7F	; 127
    5928:	53 e4       	ldi	r21, 0x43	; 67
    592a:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    592e:	18 16       	cp	r1, r24
    5930:	0c f0       	brlt	.+2      	; 0x5934 <chb_set_state+0x72a>
    5932:	10 e0       	ldi	r17, 0x00	; 0
    5934:	11 23       	and	r17, r17
    5936:	09 f4       	brne	.+2      	; 0x593a <chb_set_state+0x730>
    5938:	df c0       	rjmp	.+446    	; 0x5af8 <chb_set_state+0x8ee>
	{
		_delay_ms(__us / 1000.0);
    593a:	ce 01       	movw	r24, r28
    593c:	86 5b       	subi	r24, 0xB6	; 182
    593e:	9f 4f       	sbci	r25, 0xFF	; 255
    5940:	fc 01       	movw	r30, r24
    5942:	60 81       	ld	r22, Z
    5944:	71 81       	ldd	r23, Z+1	; 0x01
    5946:	82 81       	ldd	r24, Z+2	; 0x02
    5948:	93 81       	ldd	r25, Z+3	; 0x03
    594a:	20 e0       	ldi	r18, 0x00	; 0
    594c:	30 e0       	ldi	r19, 0x00	; 0
    594e:	4a e7       	ldi	r20, 0x7A	; 122
    5950:	54 e4       	ldi	r21, 0x44	; 68
    5952:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
    5956:	dc 01       	movw	r26, r24
    5958:	cb 01       	movw	r24, r22
    595a:	9e 01       	movw	r18, r28
    595c:	2d 5a       	subi	r18, 0xAD	; 173
    595e:	3f 4f       	sbci	r19, 0xFF	; 255
    5960:	f9 01       	movw	r30, r18
    5962:	80 83       	st	Z, r24
    5964:	91 83       	std	Z+1, r25	; 0x01
    5966:	a2 83       	std	Z+2, r26	; 0x02
    5968:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    596a:	8e 01       	movw	r16, r28
    596c:	09 5a       	subi	r16, 0xA9	; 169
    596e:	1f 4f       	sbci	r17, 0xFF	; 255
    5970:	ce 01       	movw	r24, r28
    5972:	8d 5a       	subi	r24, 0xAD	; 173
    5974:	9f 4f       	sbci	r25, 0xFF	; 255
    5976:	fc 01       	movw	r30, r24
    5978:	60 81       	ld	r22, Z
    597a:	71 81       	ldd	r23, Z+1	; 0x01
    597c:	82 81       	ldd	r24, Z+2	; 0x02
    597e:	93 81       	ldd	r25, Z+3	; 0x03
    5980:	20 e0       	ldi	r18, 0x00	; 0
    5982:	30 e0       	ldi	r19, 0x00	; 0
    5984:	4a e7       	ldi	r20, 0x7A	; 122
    5986:	53 e4       	ldi	r21, 0x43	; 67
    5988:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    598c:	dc 01       	movw	r26, r24
    598e:	cb 01       	movw	r24, r22
    5990:	f8 01       	movw	r30, r16
    5992:	80 83       	st	Z, r24
    5994:	91 83       	std	Z+1, r25	; 0x01
    5996:	a2 83       	std	Z+2, r26	; 0x02
    5998:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    599a:	ce 01       	movw	r24, r28
    599c:	89 5a       	subi	r24, 0xA9	; 169
    599e:	9f 4f       	sbci	r25, 0xFF	; 255
    59a0:	11 e0       	ldi	r17, 0x01	; 1
    59a2:	fc 01       	movw	r30, r24
    59a4:	60 81       	ld	r22, Z
    59a6:	71 81       	ldd	r23, Z+1	; 0x01
    59a8:	82 81       	ldd	r24, Z+2	; 0x02
    59aa:	93 81       	ldd	r25, Z+3	; 0x03
    59ac:	20 e0       	ldi	r18, 0x00	; 0
    59ae:	30 e0       	ldi	r19, 0x00	; 0
    59b0:	40 e8       	ldi	r20, 0x80	; 128
    59b2:	5f e3       	ldi	r21, 0x3F	; 63
    59b4:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    59b8:	88 23       	and	r24, r24
    59ba:	0c f0       	brlt	.+2      	; 0x59be <chb_set_state+0x7b4>
    59bc:	10 e0       	ldi	r17, 0x00	; 0
    59be:	11 23       	and	r17, r17
    59c0:	49 f0       	breq	.+18     	; 0x59d4 <chb_set_state+0x7ca>
		__ticks = 1;
    59c2:	ce 01       	movw	r24, r28
    59c4:	85 5a       	subi	r24, 0xA5	; 165
    59c6:	9f 4f       	sbci	r25, 0xFF	; 255
    59c8:	21 e0       	ldi	r18, 0x01	; 1
    59ca:	30 e0       	ldi	r19, 0x00	; 0
    59cc:	fc 01       	movw	r30, r24
    59ce:	20 83       	st	Z, r18
    59d0:	31 83       	std	Z+1, r19	; 0x01
    59d2:	74 c0       	rjmp	.+232    	; 0x5abc <chb_set_state+0x8b2>
	else if (__tmp > 65535)
    59d4:	ce 01       	movw	r24, r28
    59d6:	89 5a       	subi	r24, 0xA9	; 169
    59d8:	9f 4f       	sbci	r25, 0xFF	; 255
    59da:	11 e0       	ldi	r17, 0x01	; 1
    59dc:	fc 01       	movw	r30, r24
    59de:	60 81       	ld	r22, Z
    59e0:	71 81       	ldd	r23, Z+1	; 0x01
    59e2:	82 81       	ldd	r24, Z+2	; 0x02
    59e4:	93 81       	ldd	r25, Z+3	; 0x03
    59e6:	20 e0       	ldi	r18, 0x00	; 0
    59e8:	3f ef       	ldi	r19, 0xFF	; 255
    59ea:	4f e7       	ldi	r20, 0x7F	; 127
    59ec:	57 e4       	ldi	r21, 0x47	; 71
    59ee:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    59f2:	18 16       	cp	r1, r24
    59f4:	0c f0       	brlt	.+2      	; 0x59f8 <chb_set_state+0x7ee>
    59f6:	10 e0       	ldi	r17, 0x00	; 0
    59f8:	11 23       	and	r17, r17
    59fa:	09 f4       	brne	.+2      	; 0x59fe <chb_set_state+0x7f4>
    59fc:	4d c0       	rjmp	.+154    	; 0x5a98 <chb_set_state+0x88e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    59fe:	ce 01       	movw	r24, r28
    5a00:	8d 5a       	subi	r24, 0xAD	; 173
    5a02:	9f 4f       	sbci	r25, 0xFF	; 255
    5a04:	fc 01       	movw	r30, r24
    5a06:	60 81       	ld	r22, Z
    5a08:	71 81       	ldd	r23, Z+1	; 0x01
    5a0a:	82 81       	ldd	r24, Z+2	; 0x02
    5a0c:	93 81       	ldd	r25, Z+3	; 0x03
    5a0e:	20 e0       	ldi	r18, 0x00	; 0
    5a10:	30 e0       	ldi	r19, 0x00	; 0
    5a12:	40 e2       	ldi	r20, 0x20	; 32
    5a14:	51 e4       	ldi	r21, 0x41	; 65
    5a16:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    5a1a:	dc 01       	movw	r26, r24
    5a1c:	cb 01       	movw	r24, r22
    5a1e:	8e 01       	movw	r16, r28
    5a20:	05 5a       	subi	r16, 0xA5	; 165
    5a22:	1f 4f       	sbci	r17, 0xFF	; 255
    5a24:	bc 01       	movw	r22, r24
    5a26:	cd 01       	movw	r24, r26
    5a28:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    5a2c:	dc 01       	movw	r26, r24
    5a2e:	cb 01       	movw	r24, r22
    5a30:	f8 01       	movw	r30, r16
    5a32:	80 83       	st	Z, r24
    5a34:	91 83       	std	Z+1, r25	; 0x01
    5a36:	27 c0       	rjmp	.+78     	; 0x5a86 <chb_set_state+0x87c>
    5a38:	ce 01       	movw	r24, r28
    5a3a:	83 5a       	subi	r24, 0xA3	; 163
    5a3c:	9f 4f       	sbci	r25, 0xFF	; 255
    5a3e:	29 e1       	ldi	r18, 0x19	; 25
    5a40:	30 e0       	ldi	r19, 0x00	; 0
    5a42:	fc 01       	movw	r30, r24
    5a44:	20 83       	st	Z, r18
    5a46:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5a48:	ce 01       	movw	r24, r28
    5a4a:	83 5a       	subi	r24, 0xA3	; 163
    5a4c:	9f 4f       	sbci	r25, 0xFF	; 255
    5a4e:	fc 01       	movw	r30, r24
    5a50:	80 81       	ld	r24, Z
    5a52:	91 81       	ldd	r25, Z+1	; 0x01
    5a54:	8c 01       	movw	r16, r24
    5a56:	c8 01       	movw	r24, r16
    5a58:	01 97       	sbiw	r24, 0x01	; 1
    5a5a:	f1 f7       	brne	.-4      	; 0x5a58 <chb_set_state+0x84e>
    5a5c:	8c 01       	movw	r16, r24
    5a5e:	ce 01       	movw	r24, r28
    5a60:	83 5a       	subi	r24, 0xA3	; 163
    5a62:	9f 4f       	sbci	r25, 0xFF	; 255
    5a64:	fc 01       	movw	r30, r24
    5a66:	00 83       	st	Z, r16
    5a68:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5a6a:	ce 01       	movw	r24, r28
    5a6c:	85 5a       	subi	r24, 0xA5	; 165
    5a6e:	9f 4f       	sbci	r25, 0xFF	; 255
    5a70:	9e 01       	movw	r18, r28
    5a72:	25 5a       	subi	r18, 0xA5	; 165
    5a74:	3f 4f       	sbci	r19, 0xFF	; 255
    5a76:	f9 01       	movw	r30, r18
    5a78:	20 81       	ld	r18, Z
    5a7a:	31 81       	ldd	r19, Z+1	; 0x01
    5a7c:	21 50       	subi	r18, 0x01	; 1
    5a7e:	30 40       	sbci	r19, 0x00	; 0
    5a80:	fc 01       	movw	r30, r24
    5a82:	20 83       	st	Z, r18
    5a84:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5a86:	ce 01       	movw	r24, r28
    5a88:	85 5a       	subi	r24, 0xA5	; 165
    5a8a:	9f 4f       	sbci	r25, 0xFF	; 255
    5a8c:	fc 01       	movw	r30, r24
    5a8e:	80 81       	ld	r24, Z
    5a90:	91 81       	ldd	r25, Z+1	; 0x01
    5a92:	00 97       	sbiw	r24, 0x00	; 0
    5a94:	89 f6       	brne	.-94     	; 0x5a38 <chb_set_state+0x82e>
    5a96:	58 c0       	rjmp	.+176    	; 0x5b48 <chb_set_state+0x93e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5a98:	8e 01       	movw	r16, r28
    5a9a:	05 5a       	subi	r16, 0xA5	; 165
    5a9c:	1f 4f       	sbci	r17, 0xFF	; 255
    5a9e:	ce 01       	movw	r24, r28
    5aa0:	89 5a       	subi	r24, 0xA9	; 169
    5aa2:	9f 4f       	sbci	r25, 0xFF	; 255
    5aa4:	fc 01       	movw	r30, r24
    5aa6:	60 81       	ld	r22, Z
    5aa8:	71 81       	ldd	r23, Z+1	; 0x01
    5aaa:	82 81       	ldd	r24, Z+2	; 0x02
    5aac:	93 81       	ldd	r25, Z+3	; 0x03
    5aae:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    5ab2:	dc 01       	movw	r26, r24
    5ab4:	cb 01       	movw	r24, r22
    5ab6:	f8 01       	movw	r30, r16
    5ab8:	80 83       	st	Z, r24
    5aba:	91 83       	std	Z+1, r25	; 0x01
    5abc:	ce 01       	movw	r24, r28
    5abe:	81 5a       	subi	r24, 0xA1	; 161
    5ac0:	9f 4f       	sbci	r25, 0xFF	; 255
    5ac2:	9e 01       	movw	r18, r28
    5ac4:	25 5a       	subi	r18, 0xA5	; 165
    5ac6:	3f 4f       	sbci	r19, 0xFF	; 255
    5ac8:	f9 01       	movw	r30, r18
    5aca:	20 81       	ld	r18, Z
    5acc:	31 81       	ldd	r19, Z+1	; 0x01
    5ace:	fc 01       	movw	r30, r24
    5ad0:	20 83       	st	Z, r18
    5ad2:	31 83       	std	Z+1, r19	; 0x01
    5ad4:	ce 01       	movw	r24, r28
    5ad6:	81 5a       	subi	r24, 0xA1	; 161
    5ad8:	9f 4f       	sbci	r25, 0xFF	; 255
    5ada:	fc 01       	movw	r30, r24
    5adc:	80 81       	ld	r24, Z
    5ade:	91 81       	ldd	r25, Z+1	; 0x01
    5ae0:	8c 01       	movw	r16, r24
    5ae2:	c8 01       	movw	r24, r16
    5ae4:	01 97       	sbiw	r24, 0x01	; 1
    5ae6:	f1 f7       	brne	.-4      	; 0x5ae4 <chb_set_state+0x8da>
    5ae8:	8c 01       	movw	r16, r24
    5aea:	ce 01       	movw	r24, r28
    5aec:	81 5a       	subi	r24, 0xA1	; 161
    5aee:	9f 4f       	sbci	r25, 0xFF	; 255
    5af0:	fc 01       	movw	r30, r24
    5af2:	00 83       	st	Z, r16
    5af4:	11 83       	std	Z+1, r17	; 0x01
    5af6:	28 c0       	rjmp	.+80     	; 0x5b48 <chb_set_state+0x93e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5af8:	8e 01       	movw	r16, r28
    5afa:	0e 5a       	subi	r16, 0xAE	; 174
    5afc:	1f 4f       	sbci	r17, 0xFF	; 255
    5afe:	ce 01       	movw	r24, r28
    5b00:	82 5b       	subi	r24, 0xB2	; 178
    5b02:	9f 4f       	sbci	r25, 0xFF	; 255
    5b04:	fc 01       	movw	r30, r24
    5b06:	60 81       	ld	r22, Z
    5b08:	71 81       	ldd	r23, Z+1	; 0x01
    5b0a:	82 81       	ldd	r24, Z+2	; 0x02
    5b0c:	93 81       	ldd	r25, Z+3	; 0x03
    5b0e:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    5b12:	dc 01       	movw	r26, r24
    5b14:	cb 01       	movw	r24, r22
    5b16:	f8 01       	movw	r30, r16
    5b18:	80 83       	st	Z, r24
    5b1a:	ce 01       	movw	r24, r28
    5b1c:	8f 59       	subi	r24, 0x9F	; 159
    5b1e:	9f 4f       	sbci	r25, 0xFF	; 255
    5b20:	9e 01       	movw	r18, r28
    5b22:	2e 5a       	subi	r18, 0xAE	; 174
    5b24:	3f 4f       	sbci	r19, 0xFF	; 255
    5b26:	f9 01       	movw	r30, r18
    5b28:	20 81       	ld	r18, Z
    5b2a:	fc 01       	movw	r30, r24
    5b2c:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5b2e:	ce 01       	movw	r24, r28
    5b30:	8f 59       	subi	r24, 0x9F	; 159
    5b32:	9f 4f       	sbci	r25, 0xFF	; 255
    5b34:	fc 01       	movw	r30, r24
    5b36:	80 81       	ld	r24, Z
    5b38:	18 2f       	mov	r17, r24
    5b3a:	1a 95       	dec	r17
    5b3c:	f1 f7       	brne	.-4      	; 0x5b3a <chb_set_state+0x930>
    5b3e:	ce 01       	movw	r24, r28
    5b40:	8f 59       	subi	r24, 0x9F	; 159
    5b42:	9f 4f       	sbci	r25, 0xFF	; 255
    5b44:	fc 01       	movw	r30, r24
    5b46:	10 83       	st	Z, r17

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    5b48:	0e 94 9e 23 	call	0x473c	; 0x473c <chb_get_state>
    5b4c:	28 2f       	mov	r18, r24
    5b4e:	ce 01       	movw	r24, r28
    5b50:	8e 59       	subi	r24, 0x9E	; 158
    5b52:	9f 4f       	sbci	r25, 0xFF	; 255
    5b54:	fc 01       	movw	r30, r24
    5b56:	80 81       	ld	r24, Z
    5b58:	28 17       	cp	r18, r24
    5b5a:	11 f4       	brne	.+4      	; 0x5b60 <chb_set_state+0x956>
    {
        return RADIO_SUCCESS;
    5b5c:	80 e4       	ldi	r24, 0x40	; 64
    5b5e:	01 c0       	rjmp	.+2      	; 0x5b62 <chb_set_state+0x958>
    }
    return RADIO_TIMED_OUT;
    5b60:	83 e4       	ldi	r24, 0x43	; 67
}
    5b62:	ce 59       	subi	r28, 0x9E	; 158
    5b64:	df 4f       	sbci	r29, 0xFF	; 255
    5b66:	cd bf       	out	0x3d, r28	; 61
    5b68:	de bf       	out	0x3e, r29	; 62
    5b6a:	df 91       	pop	r29
    5b6c:	cf 91       	pop	r28
    5b6e:	1f 91       	pop	r17
    5b70:	0f 91       	pop	r16
    5b72:	08 95       	ret

00005b74 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    5b74:	cf 93       	push	r28
    5b76:	df 93       	push	r29
    5b78:	0f 92       	push	r0
    5b7a:	0f 92       	push	r0
    5b7c:	cd b7       	in	r28, 0x3d	; 61
    5b7e:	de b7       	in	r29, 0x3e	; 62
    5b80:	89 83       	std	Y+1, r24	; 0x01
    5b82:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    5b84:	29 81       	ldd	r18, Y+1	; 0x01
    5b86:	3a 81       	ldd	r19, Y+2	; 0x02
    5b88:	80 e0       	ldi	r24, 0x00	; 0
    5b8a:	90 e0       	ldi	r25, 0x00	; 0
    5b8c:	b9 01       	movw	r22, r18
    5b8e:	48 e0       	ldi	r20, 0x08	; 8
    5b90:	50 e0       	ldi	r21, 0x00	; 0
    5b92:	0e 94 dd 31 	call	0x63ba	; 0x63ba <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    5b96:	29 81       	ldd	r18, Y+1	; 0x01
    5b98:	3a 81       	ldd	r19, Y+2	; 0x02
    5b9a:	84 e2       	ldi	r24, 0x24	; 36
    5b9c:	b9 01       	movw	r22, r18
    5b9e:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <chb_reg_write64>
}
    5ba2:	0f 90       	pop	r0
    5ba4:	0f 90       	pop	r0
    5ba6:	df 91       	pop	r29
    5ba8:	cf 91       	pop	r28
    5baa:	08 95       	ret

00005bac <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    5bac:	cf 93       	push	r28
    5bae:	df 93       	push	r29
    5bb0:	0f 92       	push	r0
    5bb2:	0f 92       	push	r0
    5bb4:	cd b7       	in	r28, 0x3d	; 61
    5bb6:	de b7       	in	r29, 0x3e	; 62
    5bb8:	89 83       	std	Y+1, r24	; 0x01
    5bba:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    5bbc:	29 81       	ldd	r18, Y+1	; 0x01
    5bbe:	3a 81       	ldd	r19, Y+2	; 0x02
    5bc0:	80 e0       	ldi	r24, 0x00	; 0
    5bc2:	90 e0       	ldi	r25, 0x00	; 0
    5bc4:	b9 01       	movw	r22, r18
    5bc6:	48 e0       	ldi	r20, 0x08	; 8
    5bc8:	50 e0       	ldi	r21, 0x00	; 0
    5bca:	0e 94 19 32 	call	0x6432	; 0x6432 <chb_eeprom_read>
}
    5bce:	0f 90       	pop	r0
    5bd0:	0f 90       	pop	r0
    5bd2:	df 91       	pop	r29
    5bd4:	cf 91       	pop	r28
    5bd6:	08 95       	ret

00005bd8 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    5bd8:	cf 93       	push	r28
    5bda:	df 93       	push	r29
    5bdc:	00 d0       	rcall	.+0      	; 0x5bde <chb_set_short_addr+0x6>
    5bde:	00 d0       	rcall	.+0      	; 0x5be0 <chb_set_short_addr+0x8>
    5be0:	cd b7       	in	r28, 0x3d	; 61
    5be2:	de b7       	in	r29, 0x3e	; 62
    5be4:	8d 83       	std	Y+5, r24	; 0x05
    5be6:	9e 83       	std	Y+6, r25	; 0x06
    U8 *addr_ptr = (U8 *)&addr;
    5be8:	ce 01       	movw	r24, r28
    5bea:	05 96       	adiw	r24, 0x05	; 5
    5bec:	89 83       	std	Y+1, r24	; 0x01
    5bee:	9a 83       	std	Y+2, r25	; 0x02
    pcb_t *pcb = chb_get_pcb();
    5bf0:	0e 94 95 20 	call	0x412a	; 0x412a <chb_get_pcb>
    5bf4:	8b 83       	std	Y+3, r24	; 0x03
    5bf6:	9c 83       	std	Y+4, r25	; 0x04

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    5bf8:	29 81       	ldd	r18, Y+1	; 0x01
    5bfa:	3a 81       	ldd	r19, Y+2	; 0x02
    5bfc:	89 e0       	ldi	r24, 0x09	; 9
    5bfe:	90 e0       	ldi	r25, 0x00	; 0
    5c00:	b9 01       	movw	r22, r18
    5c02:	42 e0       	ldi	r20, 0x02	; 2
    5c04:	50 e0       	ldi	r21, 0x00	; 0
    5c06:	0e 94 dd 31 	call	0x63ba	; 0x63ba <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    5c0a:	2d 81       	ldd	r18, Y+5	; 0x05
    5c0c:	3e 81       	ldd	r19, Y+6	; 0x06
    5c0e:	80 e2       	ldi	r24, 0x20	; 32
    5c10:	b9 01       	movw	r22, r18
    5c12:	0e 94 2e 26 	call	0x4c5c	; 0x4c5c <chb_reg_write16>
    pcb->src_addr = addr;
    5c16:	2d 81       	ldd	r18, Y+5	; 0x05
    5c18:	3e 81       	ldd	r19, Y+6	; 0x06
    5c1a:	8b 81       	ldd	r24, Y+3	; 0x03
    5c1c:	9c 81       	ldd	r25, Y+4	; 0x04
    5c1e:	fc 01       	movw	r30, r24
    5c20:	20 83       	st	Z, r18
    5c22:	31 83       	std	Z+1, r19	; 0x01
}
    5c24:	26 96       	adiw	r28, 0x06	; 6
    5c26:	cd bf       	out	0x3d, r28	; 61
    5c28:	de bf       	out	0x3e, r29	; 62
    5c2a:	df 91       	pop	r29
    5c2c:	cf 91       	pop	r28
    5c2e:	08 95       	ret

00005c30 <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    5c30:	cf 93       	push	r28
    5c32:	df 93       	push	r29
    5c34:	0f 92       	push	r0
    5c36:	0f 92       	push	r0
    5c38:	cd b7       	in	r28, 0x3d	; 61
    5c3a:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    5c3c:	89 e0       	ldi	r24, 0x09	; 9
    5c3e:	90 e0       	ldi	r25, 0x00	; 0
    5c40:	9e 01       	movw	r18, r28
    5c42:	2f 5f       	subi	r18, 0xFF	; 255
    5c44:	3f 4f       	sbci	r19, 0xFF	; 255
    5c46:	b9 01       	movw	r22, r18
    5c48:	42 e0       	ldi	r20, 0x02	; 2
    5c4a:	50 e0       	ldi	r21, 0x00	; 0
    5c4c:	0e 94 19 32 	call	0x6432	; 0x6432 <chb_eeprom_read>
    return *(U16 *)addr;
    5c50:	ce 01       	movw	r24, r28
    5c52:	01 96       	adiw	r24, 0x01	; 1
    5c54:	fc 01       	movw	r30, r24
    5c56:	80 81       	ld	r24, Z
    5c58:	91 81       	ldd	r25, Z+1	; 0x01
}
    5c5a:	0f 90       	pop	r0
    5c5c:	0f 90       	pop	r0
    5c5e:	df 91       	pop	r29
    5c60:	cf 91       	pop	r28
    5c62:	08 95       	ret

00005c64 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    5c64:	cf 93       	push	r28
    5c66:	df 93       	push	r29
    5c68:	cd b7       	in	r28, 0x3d	; 61
    5c6a:	de b7       	in	r29, 0x3e	; 62
    5c6c:	28 97       	sbiw	r28, 0x08	; 8
    5c6e:	cd bf       	out	0x3d, r28	; 61
    5c70:	de bf       	out	0x3e, r29	; 62
    5c72:	8c 83       	std	Y+4, r24	; 0x04
    5c74:	9d 83       	std	Y+5, r25	; 0x05
    5c76:	6e 83       	std	Y+6, r22	; 0x06
    5c78:	7f 83       	std	Y+7, r23	; 0x07
    5c7a:	48 87       	std	Y+8, r20	; 0x08
    U8 state = chb_get_state();
    5c7c:	0e 94 9e 23 	call	0x473c	; 0x473c <chb_get_state>
    5c80:	89 83       	std	Y+1, r24	; 0x01
    pcb_t *pcb = chb_get_pcb();
    5c82:	0e 94 95 20 	call	0x412a	; 0x412a <chb_get_pcb>
    5c86:	8a 83       	std	Y+2, r24	; 0x02
    5c88:	9b 83       	std	Y+3, r25	; 0x03

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    5c8a:	89 81       	ldd	r24, Y+1	; 0x01
    5c8c:	82 30       	cpi	r24, 0x02	; 2
    5c8e:	19 f0       	breq	.+6      	; 0x5c96 <chb_tx+0x32>
    5c90:	89 81       	ldd	r24, Y+1	; 0x01
    5c92:	82 31       	cpi	r24, 0x12	; 18
    5c94:	11 f4       	brne	.+4      	; 0x5c9a <chb_tx+0x36>
    {
        return RADIO_WRONG_STATE;
    5c96:	84 e4       	ldi	r24, 0x44	; 68
    5c98:	23 c0       	rjmp	.+70     	; 0x5ce0 <chb_tx+0x7c>
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    5c9a:	88 e0       	ldi	r24, 0x08	; 8
    5c9c:	0e 94 05 29 	call	0x520a	; 0x520a <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    5ca0:	89 e1       	ldi	r24, 0x19	; 25
    5ca2:	0e 94 05 29 	call	0x520a	; 0x520a <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    5ca6:	8c 81       	ldd	r24, Y+4	; 0x04
    5ca8:	9d 81       	ldd	r25, Y+5	; 0x05
    5caa:	2e 81       	ldd	r18, Y+6	; 0x06
    5cac:	3f 81       	ldd	r19, Y+7	; 0x07
    5cae:	6a e0       	ldi	r22, 0x0A	; 10
    5cb0:	a9 01       	movw	r20, r18
    5cb2:	28 85       	ldd	r18, Y+8	; 0x08
    5cb4:	0e 94 ac 26 	call	0x4d58	; 0x4d58 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    5cb8:	82 e0       	ldi	r24, 0x02	; 2
    5cba:	62 e0       	ldi	r22, 0x02	; 2
    5cbc:	4f e1       	ldi	r20, 0x1F	; 31
    5cbe:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    5cc2:	00 00       	nop
    5cc4:	8a 81       	ldd	r24, Y+2	; 0x02
    5cc6:	9b 81       	ldd	r25, Y+3	; 0x03
    5cc8:	fc 01       	movw	r30, r24
    5cca:	94 81       	ldd	r25, Z+4	; 0x04
    5ccc:	81 e0       	ldi	r24, 0x01	; 1
    5cce:	89 27       	eor	r24, r25
    5cd0:	88 23       	and	r24, r24
    5cd2:	c1 f7       	brne	.-16     	; 0x5cc4 <chb_tx+0x60>
    pcb->tx_end = false;
    5cd4:	8a 81       	ldd	r24, Y+2	; 0x02
    5cd6:	9b 81       	ldd	r25, Y+3	; 0x03
    5cd8:	fc 01       	movw	r30, r24
    5cda:	14 82       	std	Z+4, r1	; 0x04

    // check the status of the transmission
    return chb_get_status();
    5cdc:	0e 94 a9 23 	call	0x4752	; 0x4752 <chb_get_status>
}
    5ce0:	28 96       	adiw	r28, 0x08	; 8
    5ce2:	cd bf       	out	0x3d, r28	; 61
    5ce4:	de bf       	out	0x3e, r29	; 62
    5ce6:	df 91       	pop	r29
    5ce8:	cf 91       	pop	r28
    5cea:	08 95       	ret

00005cec <chb_sleep>:
/*!
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    5cec:	0f 93       	push	r16
    5cee:	1f 93       	push	r17
    5cf0:	cf 93       	push	r28
    5cf2:	df 93       	push	r29
    5cf4:	cd b7       	in	r28, 0x3d	; 61
    5cf6:	de b7       	in	r29, 0x3e	; 62
    5cf8:	69 97       	sbiw	r28, 0x19	; 25
    5cfa:	cd bf       	out	0x3d, r28	; 61
    5cfc:	de bf       	out	0x3e, r29	; 62
    5cfe:	89 8f       	std	Y+25, r24	; 0x19
    if (enb)
    5d00:	89 8d       	ldd	r24, Y+25	; 0x19
    5d02:	88 23       	and	r24, r24
    5d04:	69 f0       	breq	.+26     	; 0x5d20 <chb_sleep+0x34>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    5d06:	88 e0       	ldi	r24, 0x08	; 8
    5d08:	0e 94 05 29 	call	0x520a	; 0x520a <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    5d0c:	84 e6       	ldi	r24, 0x64	; 100
    5d0e:	96 e0       	ldi	r25, 0x06	; 6
    5d10:	24 e6       	ldi	r18, 0x64	; 100
    5d12:	36 e0       	ldi	r19, 0x06	; 6
    5d14:	f9 01       	movw	r30, r18
    5d16:	20 81       	ld	r18, Z
    5d18:	22 60       	ori	r18, 0x02	; 2
    5d1a:	fc 01       	movw	r30, r24
    5d1c:	20 83       	st	Z, r18
    5d1e:	e1 c0       	rjmp	.+450    	; 0x5ee2 <chb_sleep+0x1f6>
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    5d20:	84 e6       	ldi	r24, 0x64	; 100
    5d22:	96 e0       	ldi	r25, 0x06	; 6
    5d24:	24 e6       	ldi	r18, 0x64	; 100
    5d26:	36 e0       	ldi	r19, 0x06	; 6
    5d28:	f9 01       	movw	r30, r18
    5d2a:	20 81       	ld	r18, Z
    5d2c:	2d 7f       	andi	r18, 0xFD	; 253
    5d2e:	fc 01       	movw	r30, r24
    5d30:	20 83       	st	Z, r18
    5d32:	80 e0       	ldi	r24, 0x00	; 0
    5d34:	90 e0       	ldi	r25, 0x00	; 0
    5d36:	a0 e7       	ldi	r26, 0x70	; 112
    5d38:	b3 e4       	ldi	r27, 0x43	; 67
    5d3a:	89 83       	std	Y+1, r24	; 0x01
    5d3c:	9a 83       	std	Y+2, r25	; 0x02
    5d3e:	ab 83       	std	Y+3, r26	; 0x03
    5d40:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5d42:	69 81       	ldd	r22, Y+1	; 0x01
    5d44:	7a 81       	ldd	r23, Y+2	; 0x02
    5d46:	8b 81       	ldd	r24, Y+3	; 0x03
    5d48:	9c 81       	ldd	r25, Y+4	; 0x04
    5d4a:	2b ea       	ldi	r18, 0xAB	; 171
    5d4c:	3a ea       	ldi	r19, 0xAA	; 170
    5d4e:	4a ea       	ldi	r20, 0xAA	; 170
    5d50:	5e e3       	ldi	r21, 0x3E	; 62
    5d52:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    5d56:	dc 01       	movw	r26, r24
    5d58:	cb 01       	movw	r24, r22
    5d5a:	8d 83       	std	Y+5, r24	; 0x05
    5d5c:	9e 83       	std	Y+6, r25	; 0x06
    5d5e:	af 83       	std	Y+7, r26	; 0x07
    5d60:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    5d62:	11 e0       	ldi	r17, 0x01	; 1
    5d64:	6d 81       	ldd	r22, Y+5	; 0x05
    5d66:	7e 81       	ldd	r23, Y+6	; 0x06
    5d68:	8f 81       	ldd	r24, Y+7	; 0x07
    5d6a:	98 85       	ldd	r25, Y+8	; 0x08
    5d6c:	20 e0       	ldi	r18, 0x00	; 0
    5d6e:	30 e0       	ldi	r19, 0x00	; 0
    5d70:	40 e8       	ldi	r20, 0x80	; 128
    5d72:	5f e3       	ldi	r21, 0x3F	; 63
    5d74:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    5d78:	88 23       	and	r24, r24
    5d7a:	0c f0       	brlt	.+2      	; 0x5d7e <chb_sleep+0x92>
    5d7c:	10 e0       	ldi	r17, 0x00	; 0
    5d7e:	11 23       	and	r17, r17
    5d80:	19 f0       	breq	.+6      	; 0x5d88 <chb_sleep+0x9c>
		__ticks = 1;
    5d82:	81 e0       	ldi	r24, 0x01	; 1
    5d84:	89 87       	std	Y+9, r24	; 0x09
    5d86:	a3 c0       	rjmp	.+326    	; 0x5ece <chb_sleep+0x1e2>
	else if (__tmp > 255)
    5d88:	11 e0       	ldi	r17, 0x01	; 1
    5d8a:	6d 81       	ldd	r22, Y+5	; 0x05
    5d8c:	7e 81       	ldd	r23, Y+6	; 0x06
    5d8e:	8f 81       	ldd	r24, Y+7	; 0x07
    5d90:	98 85       	ldd	r25, Y+8	; 0x08
    5d92:	20 e0       	ldi	r18, 0x00	; 0
    5d94:	30 e0       	ldi	r19, 0x00	; 0
    5d96:	4f e7       	ldi	r20, 0x7F	; 127
    5d98:	53 e4       	ldi	r21, 0x43	; 67
    5d9a:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    5d9e:	18 16       	cp	r1, r24
    5da0:	0c f0       	brlt	.+2      	; 0x5da4 <chb_sleep+0xb8>
    5da2:	10 e0       	ldi	r17, 0x00	; 0
    5da4:	11 23       	and	r17, r17
    5da6:	09 f4       	brne	.+2      	; 0x5daa <chb_sleep+0xbe>
    5da8:	89 c0       	rjmp	.+274    	; 0x5ebc <chb_sleep+0x1d0>
	{
		_delay_ms(__us / 1000.0);
    5daa:	69 81       	ldd	r22, Y+1	; 0x01
    5dac:	7a 81       	ldd	r23, Y+2	; 0x02
    5dae:	8b 81       	ldd	r24, Y+3	; 0x03
    5db0:	9c 81       	ldd	r25, Y+4	; 0x04
    5db2:	20 e0       	ldi	r18, 0x00	; 0
    5db4:	30 e0       	ldi	r19, 0x00	; 0
    5db6:	4a e7       	ldi	r20, 0x7A	; 122
    5db8:	54 e4       	ldi	r21, 0x44	; 68
    5dba:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
    5dbe:	dc 01       	movw	r26, r24
    5dc0:	cb 01       	movw	r24, r22
    5dc2:	8a 87       	std	Y+10, r24	; 0x0a
    5dc4:	9b 87       	std	Y+11, r25	; 0x0b
    5dc6:	ac 87       	std	Y+12, r26	; 0x0c
    5dc8:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5dca:	6a 85       	ldd	r22, Y+10	; 0x0a
    5dcc:	7b 85       	ldd	r23, Y+11	; 0x0b
    5dce:	8c 85       	ldd	r24, Y+12	; 0x0c
    5dd0:	9d 85       	ldd	r25, Y+13	; 0x0d
    5dd2:	20 e0       	ldi	r18, 0x00	; 0
    5dd4:	30 e0       	ldi	r19, 0x00	; 0
    5dd6:	4a e7       	ldi	r20, 0x7A	; 122
    5dd8:	53 e4       	ldi	r21, 0x43	; 67
    5dda:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    5dde:	dc 01       	movw	r26, r24
    5de0:	cb 01       	movw	r24, r22
    5de2:	8e 87       	std	Y+14, r24	; 0x0e
    5de4:	9f 87       	std	Y+15, r25	; 0x0f
    5de6:	a8 8b       	std	Y+16, r26	; 0x10
    5de8:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    5dea:	11 e0       	ldi	r17, 0x01	; 1
    5dec:	6e 85       	ldd	r22, Y+14	; 0x0e
    5dee:	7f 85       	ldd	r23, Y+15	; 0x0f
    5df0:	88 89       	ldd	r24, Y+16	; 0x10
    5df2:	99 89       	ldd	r25, Y+17	; 0x11
    5df4:	20 e0       	ldi	r18, 0x00	; 0
    5df6:	30 e0       	ldi	r19, 0x00	; 0
    5df8:	40 e8       	ldi	r20, 0x80	; 128
    5dfa:	5f e3       	ldi	r21, 0x3F	; 63
    5dfc:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    5e00:	88 23       	and	r24, r24
    5e02:	0c f0       	brlt	.+2      	; 0x5e06 <chb_sleep+0x11a>
    5e04:	10 e0       	ldi	r17, 0x00	; 0
    5e06:	11 23       	and	r17, r17
    5e08:	29 f0       	breq	.+10     	; 0x5e14 <chb_sleep+0x128>
		__ticks = 1;
    5e0a:	81 e0       	ldi	r24, 0x01	; 1
    5e0c:	90 e0       	ldi	r25, 0x00	; 0
    5e0e:	8a 8b       	std	Y+18, r24	; 0x12
    5e10:	9b 8b       	std	Y+19, r25	; 0x13
    5e12:	46 c0       	rjmp	.+140    	; 0x5ea0 <chb_sleep+0x1b4>
	else if (__tmp > 65535)
    5e14:	11 e0       	ldi	r17, 0x01	; 1
    5e16:	6e 85       	ldd	r22, Y+14	; 0x0e
    5e18:	7f 85       	ldd	r23, Y+15	; 0x0f
    5e1a:	88 89       	ldd	r24, Y+16	; 0x10
    5e1c:	99 89       	ldd	r25, Y+17	; 0x11
    5e1e:	20 e0       	ldi	r18, 0x00	; 0
    5e20:	3f ef       	ldi	r19, 0xFF	; 255
    5e22:	4f e7       	ldi	r20, 0x7F	; 127
    5e24:	57 e4       	ldi	r21, 0x47	; 71
    5e26:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    5e2a:	18 16       	cp	r1, r24
    5e2c:	0c f0       	brlt	.+2      	; 0x5e30 <chb_sleep+0x144>
    5e2e:	10 e0       	ldi	r17, 0x00	; 0
    5e30:	11 23       	and	r17, r17
    5e32:	61 f1       	breq	.+88     	; 0x5e8c <chb_sleep+0x1a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5e34:	6a 85       	ldd	r22, Y+10	; 0x0a
    5e36:	7b 85       	ldd	r23, Y+11	; 0x0b
    5e38:	8c 85       	ldd	r24, Y+12	; 0x0c
    5e3a:	9d 85       	ldd	r25, Y+13	; 0x0d
    5e3c:	20 e0       	ldi	r18, 0x00	; 0
    5e3e:	30 e0       	ldi	r19, 0x00	; 0
    5e40:	40 e2       	ldi	r20, 0x20	; 32
    5e42:	51 e4       	ldi	r21, 0x41	; 65
    5e44:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    5e48:	dc 01       	movw	r26, r24
    5e4a:	cb 01       	movw	r24, r22
    5e4c:	bc 01       	movw	r22, r24
    5e4e:	cd 01       	movw	r24, r26
    5e50:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    5e54:	dc 01       	movw	r26, r24
    5e56:	cb 01       	movw	r24, r22
    5e58:	8a 8b       	std	Y+18, r24	; 0x12
    5e5a:	9b 8b       	std	Y+19, r25	; 0x13
    5e5c:	12 c0       	rjmp	.+36     	; 0x5e82 <chb_sleep+0x196>
    5e5e:	89 e1       	ldi	r24, 0x19	; 25
    5e60:	90 e0       	ldi	r25, 0x00	; 0
    5e62:	8c 8b       	std	Y+20, r24	; 0x14
    5e64:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5e66:	8c 89       	ldd	r24, Y+20	; 0x14
    5e68:	9d 89       	ldd	r25, Y+21	; 0x15
    5e6a:	8c 01       	movw	r16, r24
    5e6c:	c8 01       	movw	r24, r16
    5e6e:	01 97       	sbiw	r24, 0x01	; 1
    5e70:	f1 f7       	brne	.-4      	; 0x5e6e <chb_sleep+0x182>
    5e72:	8c 01       	movw	r16, r24
    5e74:	0c 8b       	std	Y+20, r16	; 0x14
    5e76:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5e78:	8a 89       	ldd	r24, Y+18	; 0x12
    5e7a:	9b 89       	ldd	r25, Y+19	; 0x13
    5e7c:	01 97       	sbiw	r24, 0x01	; 1
    5e7e:	8a 8b       	std	Y+18, r24	; 0x12
    5e80:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5e82:	8a 89       	ldd	r24, Y+18	; 0x12
    5e84:	9b 89       	ldd	r25, Y+19	; 0x13
    5e86:	00 97       	sbiw	r24, 0x00	; 0
    5e88:	51 f7       	brne	.-44     	; 0x5e5e <chb_sleep+0x172>
    5e8a:	28 c0       	rjmp	.+80     	; 0x5edc <chb_sleep+0x1f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5e8c:	6e 85       	ldd	r22, Y+14	; 0x0e
    5e8e:	7f 85       	ldd	r23, Y+15	; 0x0f
    5e90:	88 89       	ldd	r24, Y+16	; 0x10
    5e92:	99 89       	ldd	r25, Y+17	; 0x11
    5e94:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    5e98:	dc 01       	movw	r26, r24
    5e9a:	cb 01       	movw	r24, r22
    5e9c:	8a 8b       	std	Y+18, r24	; 0x12
    5e9e:	9b 8b       	std	Y+19, r25	; 0x13
    5ea0:	8a 89       	ldd	r24, Y+18	; 0x12
    5ea2:	9b 89       	ldd	r25, Y+19	; 0x13
    5ea4:	8e 8b       	std	Y+22, r24	; 0x16
    5ea6:	9f 8b       	std	Y+23, r25	; 0x17
    5ea8:	8e 89       	ldd	r24, Y+22	; 0x16
    5eaa:	9f 89       	ldd	r25, Y+23	; 0x17
    5eac:	8c 01       	movw	r16, r24
    5eae:	f8 01       	movw	r30, r16
    5eb0:	31 97       	sbiw	r30, 0x01	; 1
    5eb2:	f1 f7       	brne	.-4      	; 0x5eb0 <chb_sleep+0x1c4>
    5eb4:	8f 01       	movw	r16, r30
    5eb6:	0e 8b       	std	Y+22, r16	; 0x16
    5eb8:	1f 8b       	std	Y+23, r17	; 0x17
    5eba:	10 c0       	rjmp	.+32     	; 0x5edc <chb_sleep+0x1f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5ebc:	6d 81       	ldd	r22, Y+5	; 0x05
    5ebe:	7e 81       	ldd	r23, Y+6	; 0x06
    5ec0:	8f 81       	ldd	r24, Y+7	; 0x07
    5ec2:	98 85       	ldd	r25, Y+8	; 0x08
    5ec4:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    5ec8:	dc 01       	movw	r26, r24
    5eca:	cb 01       	movw	r24, r22
    5ecc:	89 87       	std	Y+9, r24	; 0x09
    5ece:	89 85       	ldd	r24, Y+9	; 0x09
    5ed0:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5ed2:	88 8d       	ldd	r24, Y+24	; 0x18
    5ed4:	18 2f       	mov	r17, r24
    5ed6:	1a 95       	dec	r17
    5ed8:	f1 f7       	brne	.-4      	; 0x5ed6 <chb_sleep+0x1ea>
    5eda:	18 8f       	std	Y+24, r17	; 0x18

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    5edc:	86 e1       	ldi	r24, 0x16	; 22
    5ede:	0e 94 05 29 	call	0x520a	; 0x520a <chb_set_state>
    }
}
    5ee2:	69 96       	adiw	r28, 0x19	; 25
    5ee4:	cd bf       	out	0x3d, r28	; 61
    5ee6:	de bf       	out	0x3e, r29	; 62
    5ee8:	df 91       	pop	r29
    5eea:	cf 91       	pop	r28
    5eec:	1f 91       	pop	r17
    5eee:	0f 91       	pop	r16
    5ef0:	08 95       	ret

00005ef2 <chb_radio_init>:
/*!

*/
/**************************************************************************/
static void chb_radio_init()
{
    5ef2:	cf 93       	push	r28
    5ef4:	df 93       	push	r29
    5ef6:	cd b7       	in	r28, 0x3d	; 61
    5ef8:	de b7       	in	r29, 0x3e	; 62
    5efa:	ea 97       	sbiw	r28, 0x3a	; 58
    5efc:	cd bf       	out	0x3d, r28	; 61
    5efe:	de bf       	out	0x3e, r29	; 62
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    5f00:	0e 94 b6 23 	call	0x476c	; 0x476c <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    5f04:	8e e0       	ldi	r24, 0x0E	; 14
    5f06:	60 e0       	ldi	r22, 0x00	; 0
    5f08:	0e 94 02 26 	call	0x4c04	; 0x4c04 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    5f0c:	82 e0       	ldi	r24, 0x02	; 2
    5f0e:	63 e0       	ldi	r22, 0x03	; 3
    5f10:	4f e1       	ldi	r20, 0x1F	; 31
    5f12:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    5f16:	00 00       	nop
    5f18:	81 e0       	ldi	r24, 0x01	; 1
    5f1a:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <chb_reg_read>
    5f1e:	88 2f       	mov	r24, r24
    5f20:	90 e0       	ldi	r25, 0x00	; 0
    5f22:	8f 71       	andi	r24, 0x1F	; 31
    5f24:	90 70       	andi	r25, 0x00	; 0
    5f26:	88 30       	cpi	r24, 0x08	; 8
    5f28:	91 05       	cpc	r25, r1
    5f2a:	b1 f7       	brne	.-20     	; 0x5f18 <chb_radio_init+0x26>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    5f2c:	8e e2       	ldi	r24, 0x2E	; 46
    5f2e:	60 e4       	ldi	r22, 0x40	; 64
    5f30:	40 ec       	ldi	r20, 0xC0	; 192
    5f32:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    5f36:	8e e0       	ldi	r24, 0x0E	; 14
    5f38:	6c e0       	ldi	r22, 0x0C	; 12
    5f3a:	0e 94 02 26 	call	0x4c04	; 0x4c04 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    5f3e:	84 e0       	ldi	r24, 0x04	; 4
    5f40:	60 e2       	ldi	r22, 0x20	; 32
    5f42:	40 e2       	ldi	r20, 0x20	; 32
    5f44:	0e 94 87 26 	call	0x4d0e	; 0x4d0e <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    5f48:	81 e0       	ldi	r24, 0x01	; 1
    5f4a:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    5f4e:	81 e0       	ldi	r24, 0x01	; 1
    5f50:	0e 94 f0 27 	call	0x4fe0	; 0x4fe0 <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    5f54:	86 e1       	ldi	r24, 0x16	; 22
    5f56:	0e 94 05 29 	call	0x520a	; 0x520a <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    5f5a:	82 e2       	ldi	r24, 0x22	; 34
    5f5c:	64 e3       	ldi	r22, 0x34	; 52
    5f5e:	72 e1       	ldi	r23, 0x12	; 18
    5f60:	0e 94 2e 26 	call	0x4c5c	; 0x4c5c <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    5f64:	0e 94 18 2e 	call	0x5c30	; 0x5c30 <chb_get_short_addr>
    5f68:	9c 01       	movw	r18, r24
    5f6a:	80 e2       	ldi	r24, 0x20	; 32
    5f6c:	b9 01       	movw	r22, r18
    5f6e:	0e 94 2e 26 	call	0x4c5c	; 0x4c5c <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    5f72:	ce 01       	movw	r24, r28
    5f74:	01 96       	adiw	r24, 0x01	; 1
    5f76:	0e 94 d6 2d 	call	0x5bac	; 0x5bac <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    5f7a:	84 e2       	ldi	r24, 0x24	; 36
    5f7c:	9e 01       	movw	r18, r28
    5f7e:	2f 5f       	subi	r18, 0xFF	; 255
    5f80:	3f 4f       	sbci	r19, 0xFF	; 255
    5f82:	b9 01       	movw	r22, r18
    5f84:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    5f88:	82 e7       	ldi	r24, 0x72	; 114
    5f8a:	96 e0       	ldi	r25, 0x06	; 6
    5f8c:	22 e7       	ldi	r18, 0x72	; 114
    5f8e:	36 e0       	ldi	r19, 0x06	; 6
    5f90:	f9 01       	movw	r30, r18
    5f92:	20 81       	ld	r18, Z
    5f94:	21 60       	ori	r18, 0x01	; 1
    5f96:	fc 01       	movw	r30, r24
    5f98:	20 83       	st	Z, r18
    5f9a:	89 e6       	ldi	r24, 0x69	; 105
    5f9c:	96 e0       	ldi	r25, 0x06	; 6
    5f9e:	29 e6       	ldi	r18, 0x69	; 105
    5fa0:	36 e0       	ldi	r19, 0x06	; 6
    5fa2:	f9 01       	movw	r30, r18
    5fa4:	20 81       	ld	r18, Z
    5fa6:	23 60       	ori	r18, 0x03	; 3
    5fa8:	fc 01       	movw	r30, r24
    5faa:	20 83       	st	Z, r18
    5fac:	8a e6       	ldi	r24, 0x6A	; 106
    5fae:	96 e0       	ldi	r25, 0x06	; 6
    5fb0:	2a e6       	ldi	r18, 0x6A	; 106
    5fb2:	36 e0       	ldi	r19, 0x06	; 6
    5fb4:	f9 01       	movw	r30, r18
    5fb6:	20 81       	ld	r18, Z
    5fb8:	24 60       	ori	r18, 0x04	; 4
    5fba:	fc 01       	movw	r30, r24
    5fbc:	20 83       	st	Z, r18
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    5fbe:	80 ea       	ldi	r24, 0xA0	; 160
    5fc0:	90 e0       	ldi	r25, 0x00	; 0
    5fc2:	20 ea       	ldi	r18, 0xA0	; 160
    5fc4:	30 e0       	ldi	r19, 0x00	; 0
    5fc6:	f9 01       	movw	r30, r18
    5fc8:	22 81       	ldd	r18, Z+2	; 0x02
    5fca:	27 60       	ori	r18, 0x07	; 7
    5fcc:	fc 01       	movw	r30, r24
    5fce:	22 83       	std	Z+2, r18	; 0x02

    if (chb_get_state() != RX_STATE)
    5fd0:	0e 94 9e 23 	call	0x473c	; 0x473c <chb_get_state>
    5fd4:	86 31       	cpi	r24, 0x16	; 22
    5fd6:	b1 f0       	breq	.+44     	; 0x6004 <__stack+0x5>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    5fd8:	ce 01       	movw	r24, r28
    5fda:	09 96       	adiw	r24, 0x09	; 9
    5fdc:	2c e0       	ldi	r18, 0x0C	; 12
    5fde:	32 e0       	ldi	r19, 0x02	; 2
    5fe0:	b9 01       	movw	r22, r18
    5fe2:	0e 94 4a 5f 	call	0xbe94	; 0xbe94 <strcpy_P>
        printf(buf);
    5fe6:	0f 92       	push	r0
    5fe8:	0f 92       	push	r0
    5fea:	8d b7       	in	r24, 0x3d	; 61
    5fec:	9e b7       	in	r25, 0x3e	; 62
    5fee:	01 96       	adiw	r24, 0x01	; 1
    5ff0:	9e 01       	movw	r18, r28
    5ff2:	27 5f       	subi	r18, 0xF7	; 247
    5ff4:	3f 4f       	sbci	r19, 0xFF	; 255
    5ff6:	fc 01       	movw	r30, r24
    5ff8:	20 83       	st	Z, r18
    5ffa:	31 83       	std	Z+1, r19	; 0x01
    5ffc:	0e 94 a6 5f 	call	0xbf4c	; 0xbf4c <printf>
    6000:	0f 90       	pop	r0
    6002:	0f 90       	pop	r0
    }
	StartOfFreeSpace = 0; //set location in FRAM Buffer at which to start storing radio messages to the start of the buffer
    6004:	10 92 c7 50 	sts	0x50C7, r1
    6008:	10 92 c8 50 	sts	0x50C8, r1
    600c:	10 92 c9 50 	sts	0x50C9, r1
    6010:	10 92 ca 50 	sts	0x50CA, r1
}
    6014:	ea 96       	adiw	r28, 0x3a	; 58
    6016:	cd bf       	out	0x3d, r28	; 61
    6018:	de bf       	out	0x3e, r29	; 62
    601a:	df 91       	pop	r29
    601c:	cf 91       	pop	r28
    601e:	08 95       	ret

00006020 <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    6020:	cf 93       	push	r28
    6022:	df 93       	push	r29
    6024:	cd b7       	in	r28, 0x3d	; 61
    6026:	de b7       	in	r29, 0x3e	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    6028:	0e 94 59 32 	call	0x64b2	; 0x64b2 <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    602c:	80 e6       	ldi	r24, 0x60	; 96
    602e:	96 e0       	ldi	r25, 0x06	; 6
    6030:	20 e6       	ldi	r18, 0x60	; 96
    6032:	36 e0       	ldi	r19, 0x06	; 6
    6034:	f9 01       	movw	r30, r18
    6036:	20 81       	ld	r18, Z
    6038:	22 60       	ori	r18, 0x02	; 2
    603a:	fc 01       	movw	r30, r24
    603c:	20 83       	st	Z, r18
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    603e:	80 e6       	ldi	r24, 0x60	; 96
    6040:	96 e0       	ldi	r25, 0x06	; 6
    6042:	20 e6       	ldi	r18, 0x60	; 96
    6044:	36 e0       	ldi	r19, 0x06	; 6
    6046:	f9 01       	movw	r30, r18
    6048:	20 81       	ld	r18, Z
    604a:	21 60       	ori	r18, 0x01	; 1
    604c:	fc 01       	movw	r30, r24
    604e:	20 83       	st	Z, r18

    // config radio
    chb_radio_init();
    6050:	0e 94 79 2f 	call	0x5ef2	; 0x5ef2 <chb_radio_init>
}
    6054:	df 91       	pop	r29
    6056:	cf 91       	pop	r28
    6058:	08 95       	ret

0000605a <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    605a:	1f 92       	push	r1
    605c:	0f 92       	push	r0
    605e:	0f b6       	in	r0, 0x3f	; 63
    6060:	0f 92       	push	r0
    6062:	00 90 3b 00 	lds	r0, 0x003B
    6066:	0f 92       	push	r0
    6068:	11 24       	eor	r1, r1
    606a:	2f 93       	push	r18
    606c:	3f 93       	push	r19
    606e:	4f 93       	push	r20
    6070:	5f 93       	push	r21
    6072:	6f 93       	push	r22
    6074:	7f 93       	push	r23
    6076:	8f 93       	push	r24
    6078:	9f 93       	push	r25
    607a:	af 93       	push	r26
    607c:	bf 93       	push	r27
    607e:	ef 93       	push	r30
    6080:	ff 93       	push	r31
    6082:	cf 93       	push	r28
    6084:	df 93       	push	r29
    6086:	cd b7       	in	r28, 0x3d	; 61
    6088:	de b7       	in	r29, 0x3e	; 62
    608a:	25 97       	sbiw	r28, 0x05	; 5
    608c:	cd bf       	out	0x3d, r28	; 61
    608e:	de bf       	out	0x3e, r29	; 62
    U8 dummy, state, intp_src = 0;
    6090:	19 82       	std	Y+1, r1	; 0x01
    pcb_t *pcb = chb_get_pcb();
    6092:	0e 94 95 20 	call	0x412a	; 0x412a <chb_get_pcb>
    6096:	8a 83       	std	Y+2, r24	; 0x02
    6098:	9b 83       	std	Y+3, r25	; 0x03

    CHB_ENTER_CRIT();
    609a:	8f e3       	ldi	r24, 0x3F	; 63
    609c:	90 e0       	ldi	r25, 0x00	; 0
    609e:	fc 01       	movw	r30, r24
    60a0:	80 81       	ld	r24, Z
    60a2:	80 93 57 40 	sts	0x4057, r24
    60a6:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    60a8:	81 e0       	ldi	r24, 0x01	; 1
    60aa:	0e 94 27 31 	call	0x624e	; 0x624e <RadioCS>

    /*Send Register address and read register content.*/
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    60ae:	8f e8       	ldi	r24, 0x8F	; 143
    60b0:	0e 94 84 32 	call	0x6508	; 0x6508 <SPID_write>
    60b4:	8c 83       	std	Y+4, r24	; 0x04
    intp_src = SPID_write(0);
    60b6:	80 e0       	ldi	r24, 0x00	; 0
    60b8:	0e 94 84 32 	call	0x6508	; 0x6508 <SPID_write>
    60bc:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    60be:	80 e0       	ldi	r24, 0x00	; 0
    60c0:	0e 94 27 31 	call	0x624e	; 0x624e <RadioCS>

    while (intp_src)
    60c4:	9d c0       	rjmp	.+314    	; 0x6200 <__vector_64+0x1a6>
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    60c6:	89 81       	ldd	r24, Y+1	; 0x01
    60c8:	88 2f       	mov	r24, r24
    60ca:	90 e0       	ldi	r25, 0x00	; 0
    60cc:	84 70       	andi	r24, 0x04	; 4
    60ce:	90 70       	andi	r25, 0x00	; 0
    60d0:	00 97       	sbiw	r24, 0x00	; 0
    60d2:	21 f0       	breq	.+8      	; 0x60dc <__vector_64+0x82>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    60d4:	89 81       	ldd	r24, Y+1	; 0x01
    60d6:	8b 7f       	andi	r24, 0xFB	; 251
    60d8:	89 83       	std	Y+1, r24	; 0x01
    60da:	92 c0       	rjmp	.+292    	; 0x6200 <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    60dc:	89 81       	ldd	r24, Y+1	; 0x01
    60de:	88 2f       	mov	r24, r24
    60e0:	90 e0       	ldi	r25, 0x00	; 0
    60e2:	88 70       	andi	r24, 0x08	; 8
    60e4:	90 70       	andi	r25, 0x00	; 0
    60e6:	00 97       	sbiw	r24, 0x00	; 0
    60e8:	09 f4       	brne	.+2      	; 0x60ec <__vector_64+0x92>
    60ea:	4c c0       	rjmp	.+152    	; 0x6184 <__vector_64+0x12a>
        {
            state = chb_get_state();
    60ec:	0e 94 9e 23 	call	0x473c	; 0x473c <chb_get_state>
    60f0:	8d 83       	std	Y+5, r24	; 0x05

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    60f2:	8d 81       	ldd	r24, Y+5	; 0x05
    60f4:	86 30       	cpi	r24, 0x06	; 6
    60f6:	31 f0       	breq	.+12     	; 0x6104 <__vector_64+0xaa>
    60f8:	8d 81       	ldd	r24, Y+5	; 0x05
    60fa:	86 31       	cpi	r24, 0x16	; 22
    60fc:	19 f0       	breq	.+6      	; 0x6104 <__vector_64+0xaa>
    60fe:	8d 81       	ldd	r24, Y+5	; 0x05
    6100:	81 31       	cpi	r24, 0x11	; 17
    6102:	89 f5       	brne	.+98     	; 0x6166 <__vector_64+0x10c>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    6104:	88 e0       	ldi	r24, 0x08	; 8
    6106:	0e 94 05 29 	call	0x520a	; 0x520a <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    610a:	87 e0       	ldi	r24, 0x07	; 7
    610c:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <chb_reg_read>
    6110:	28 2f       	mov	r18, r24
    6112:	8a 81       	ldd	r24, Y+2	; 0x02
    6114:	9b 81       	ldd	r25, Y+3	; 0x03
    6116:	fc 01       	movw	r30, r24
    6118:	22 8b       	std	Z+18, r18	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    611a:	86 e0       	ldi	r24, 0x06	; 6
    611c:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <chb_reg_read>
    6120:	28 2f       	mov	r18, r24
    6122:	22 1f       	adc	r18, r18
    6124:	22 27       	eor	r18, r18
    6126:	22 1f       	adc	r18, r18
    6128:	8a 81       	ldd	r24, Y+2	; 0x02
    612a:	9b 81       	ldd	r25, Y+3	; 0x03
    612c:	fc 01       	movw	r30, r24
    612e:	23 8b       	std	Z+19, r18	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    6130:	8a 81       	ldd	r24, Y+2	; 0x02
    6132:	9b 81       	ldd	r25, Y+3	; 0x03
    6134:	fc 01       	movw	r30, r24
    6136:	83 89       	ldd	r24, Z+19	; 0x13
    6138:	88 23       	and	r24, r24
    613a:	d1 f0       	breq	.+52     	; 0x6170 <__vector_64+0x116>
                    // get the data
                    chb_frame_read();
    613c:	0e 94 11 27 	call	0x4e22	; 0x4e22 <chb_frame_read>
                    pcb->rcvd_xfers++;
    6140:	8a 81       	ldd	r24, Y+2	; 0x02
    6142:	9b 81       	ldd	r25, Y+3	; 0x03
    6144:	fc 01       	movw	r30, r24
    6146:	85 81       	ldd	r24, Z+5	; 0x05
    6148:	96 81       	ldd	r25, Z+6	; 0x06
    614a:	9c 01       	movw	r18, r24
    614c:	2f 5f       	subi	r18, 0xFF	; 255
    614e:	3f 4f       	sbci	r19, 0xFF	; 255
    6150:	8a 81       	ldd	r24, Y+2	; 0x02
    6152:	9b 81       	ldd	r25, Y+3	; 0x03
    6154:	fc 01       	movw	r30, r24
    6156:	25 83       	std	Z+5, r18	; 0x05
    6158:	36 83       	std	Z+6, r19	; 0x06
                    pcb->data_rcv = true;
    615a:	8a 81       	ldd	r24, Y+2	; 0x02
    615c:	9b 81       	ldd	r25, Y+3	; 0x03
    615e:	21 e0       	ldi	r18, 0x01	; 1
    6160:	fc 01       	movw	r30, r24
    6162:	23 83       	std	Z+3, r18	; 0x03

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    6164:	05 c0       	rjmp	.+10     	; 0x6170 <__vector_64+0x116>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    6166:	8a 81       	ldd	r24, Y+2	; 0x02
    6168:	9b 81       	ldd	r25, Y+3	; 0x03
    616a:	21 e0       	ldi	r18, 0x01	; 1
    616c:	fc 01       	movw	r30, r24
    616e:	24 83       	std	Z+4, r18	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    6170:	89 81       	ldd	r24, Y+1	; 0x01
    6172:	87 7f       	andi	r24, 0xF7	; 247
    6174:	89 83       	std	Y+1, r24	; 0x01
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    6176:	00 00       	nop
    6178:	86 e1       	ldi	r24, 0x16	; 22
    617a:	0e 94 05 29 	call	0x520a	; 0x520a <chb_set_state>
    617e:	80 34       	cpi	r24, 0x40	; 64
    6180:	d9 f7       	brne	.-10     	; 0x6178 <__vector_64+0x11e>
    6182:	3e c0       	rjmp	.+124    	; 0x6200 <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    6184:	89 81       	ldd	r24, Y+1	; 0x01
    6186:	88 2f       	mov	r24, r24
    6188:	90 e0       	ldi	r25, 0x00	; 0
    618a:	80 74       	andi	r24, 0x40	; 64
    618c:	90 70       	andi	r25, 0x00	; 0
    618e:	00 97       	sbiw	r24, 0x00	; 0
    6190:	89 f0       	breq	.+34     	; 0x61b4 <__vector_64+0x15a>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    6192:	89 81       	ldd	r24, Y+1	; 0x01
    6194:	8f 7b       	andi	r24, 0xBF	; 191
    6196:	89 83       	std	Y+1, r24	; 0x01
            pcb->underrun++;
    6198:	8a 81       	ldd	r24, Y+2	; 0x02
    619a:	9b 81       	ldd	r25, Y+3	; 0x03
    619c:	fc 01       	movw	r30, r24
    619e:	87 85       	ldd	r24, Z+15	; 0x0f
    61a0:	90 89       	ldd	r25, Z+16	; 0x10
    61a2:	9c 01       	movw	r18, r24
    61a4:	2f 5f       	subi	r18, 0xFF	; 255
    61a6:	3f 4f       	sbci	r19, 0xFF	; 255
    61a8:	8a 81       	ldd	r24, Y+2	; 0x02
    61aa:	9b 81       	ldd	r25, Y+3	; 0x03
    61ac:	fc 01       	movw	r30, r24
    61ae:	27 87       	std	Z+15, r18	; 0x0f
    61b0:	30 8b       	std	Z+16, r19	; 0x10
    61b2:	26 c0       	rjmp	.+76     	; 0x6200 <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    61b4:	89 81       	ldd	r24, Y+1	; 0x01
    61b6:	88 2f       	mov	r24, r24
    61b8:	90 e0       	ldi	r25, 0x00	; 0
    61ba:	82 70       	andi	r24, 0x02	; 2
    61bc:	90 70       	andi	r25, 0x00	; 0
    61be:	00 97       	sbiw	r24, 0x00	; 0
    61c0:	21 f0       	breq	.+8      	; 0x61ca <__vector_64+0x170>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    61c2:	89 81       	ldd	r24, Y+1	; 0x01
    61c4:	8d 7f       	andi	r24, 0xFD	; 253
    61c6:	89 83       	std	Y+1, r24	; 0x01
    61c8:	1b c0       	rjmp	.+54     	; 0x6200 <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    61ca:	89 81       	ldd	r24, Y+1	; 0x01
    61cc:	88 2f       	mov	r24, r24
    61ce:	90 e0       	ldi	r25, 0x00	; 0
    61d0:	81 70       	andi	r24, 0x01	; 1
    61d2:	90 70       	andi	r25, 0x00	; 0
    61d4:	88 23       	and	r24, r24
    61d6:	21 f0       	breq	.+8      	; 0x61e0 <__vector_64+0x186>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    61d8:	89 81       	ldd	r24, Y+1	; 0x01
    61da:	8e 7f       	andi	r24, 0xFE	; 254
    61dc:	89 83       	std	Y+1, r24	; 0x01
    61de:	10 c0       	rjmp	.+32     	; 0x6200 <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    61e0:	89 81       	ldd	r24, Y+1	; 0x01
    61e2:	88 23       	and	r24, r24
    61e4:	6c f4       	brge	.+26     	; 0x6200 <__vector_64+0x1a6>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    61e6:	89 81       	ldd	r24, Y+1	; 0x01
    61e8:	8f 77       	andi	r24, 0x7F	; 127
    61ea:	89 83       	std	Y+1, r24	; 0x01
            pcb->battlow++;
    61ec:	8a 81       	ldd	r24, Y+2	; 0x02
    61ee:	9b 81       	ldd	r25, Y+3	; 0x03
    61f0:	fc 01       	movw	r30, r24
    61f2:	81 89       	ldd	r24, Z+17	; 0x11
    61f4:	28 2f       	mov	r18, r24
    61f6:	2f 5f       	subi	r18, 0xFF	; 255
    61f8:	8a 81       	ldd	r24, Y+2	; 0x02
    61fa:	9b 81       	ldd	r25, Y+3	; 0x03
    61fc:	fc 01       	movw	r30, r24
    61fe:	21 8b       	std	Z+17, r18	; 0x11
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    6200:	89 81       	ldd	r24, Y+1	; 0x01
    6202:	88 23       	and	r24, r24
    6204:	09 f0       	breq	.+2      	; 0x6208 <__vector_64+0x1ae>
    6206:	5f cf       	rjmp	.-322    	; 0x60c6 <__vector_64+0x6c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    6208:	8f e3       	ldi	r24, 0x3F	; 63
    620a:	90 e0       	ldi	r25, 0x00	; 0
    620c:	20 91 57 40 	lds	r18, 0x4057
    6210:	fc 01       	movw	r30, r24
    6212:	20 83       	st	Z, r18
    6214:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    6216:	8f e0       	ldi	r24, 0x0F	; 15
    6218:	0e 94 a2 25 	call	0x4b44	; 0x4b44 <chb_reg_read>
}
    621c:	25 96       	adiw	r28, 0x05	; 5
    621e:	cd bf       	out	0x3d, r28	; 61
    6220:	de bf       	out	0x3e, r29	; 62
    6222:	df 91       	pop	r29
    6224:	cf 91       	pop	r28
    6226:	ff 91       	pop	r31
    6228:	ef 91       	pop	r30
    622a:	bf 91       	pop	r27
    622c:	af 91       	pop	r26
    622e:	9f 91       	pop	r25
    6230:	8f 91       	pop	r24
    6232:	7f 91       	pop	r23
    6234:	6f 91       	pop	r22
    6236:	5f 91       	pop	r21
    6238:	4f 91       	pop	r20
    623a:	3f 91       	pop	r19
    623c:	2f 91       	pop	r18
    623e:	0f 90       	pop	r0
    6240:	00 92 3b 00 	sts	0x003B, r0
    6244:	0f 90       	pop	r0
    6246:	0f be       	out	0x3f, r0	; 63
    6248:	0f 90       	pop	r0
    624a:	1f 90       	pop	r1
    624c:	18 95       	reti

0000624e <RadioCS>:

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
    624e:	cf 93       	push	r28
    6250:	df 93       	push	r29
    6252:	0f 92       	push	r0
    6254:	cd b7       	in	r28, 0x3d	; 61
    6256:	de b7       	in	r29, 0x3e	; 62
    6258:	89 83       	std	Y+1, r24	; 0x01
	if (status) PORTD.OUTCLR = PIN4_bm;
    625a:	89 81       	ldd	r24, Y+1	; 0x01
    625c:	88 23       	and	r24, r24
    625e:	31 f0       	breq	.+12     	; 0x626c <RadioCS+0x1e>
    6260:	80 e6       	ldi	r24, 0x60	; 96
    6262:	96 e0       	ldi	r25, 0x06	; 6
    6264:	20 e1       	ldi	r18, 0x10	; 16
    6266:	fc 01       	movw	r30, r24
    6268:	26 83       	std	Z+6, r18	; 0x06
    626a:	05 c0       	rjmp	.+10     	; 0x6276 <RadioCS+0x28>
	else {
		PORTD.OUTSET = PIN4_bm;
    626c:	80 e6       	ldi	r24, 0x60	; 96
    626e:	96 e0       	ldi	r25, 0x06	; 6
    6270:	20 e1       	ldi	r18, 0x10	; 16
    6272:	fc 01       	movw	r30, r24
    6274:	25 83       	std	Z+5, r18	; 0x05
	}
    6276:	0f 90       	pop	r0
    6278:	df 91       	pop	r29
    627a:	cf 91       	pop	r28
    627c:	08 95       	ret

0000627e <chb_eep_write_byte>:
/*!

*/
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    627e:	cf 93       	push	r28
    6280:	df 93       	push	r29
    6282:	00 d0       	rcall	.+0      	; 0x6284 <chb_eep_write_byte+0x6>
    6284:	cd b7       	in	r28, 0x3d	; 61
    6286:	de b7       	in	r29, 0x3e	; 62
    6288:	89 83       	std	Y+1, r24	; 0x01
    628a:	9a 83       	std	Y+2, r25	; 0x02
    628c:	6b 83       	std	Y+3, r22	; 0x03
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    628e:	00 00       	nop
    6290:	80 ec       	ldi	r24, 0xC0	; 192
    6292:	91 e0       	ldi	r25, 0x01	; 1
    6294:	fc 01       	movw	r30, r24
    6296:	87 85       	ldd	r24, Z+15	; 0x0f
    6298:	88 23       	and	r24, r24
    629a:	d4 f3       	brlt	.-12     	; 0x6290 <chb_eep_write_byte+0x12>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    629c:	80 ec       	ldi	r24, 0xC0	; 192
    629e:	91 e0       	ldi	r25, 0x01	; 1
    62a0:	fc 01       	movw	r30, r24
    62a2:	87 85       	ldd	r24, Z+15	; 0x0f
    62a4:	88 2f       	mov	r24, r24
    62a6:	90 e0       	ldi	r25, 0x00	; 0
    62a8:	82 70       	andi	r24, 0x02	; 2
    62aa:	90 70       	andi	r25, 0x00	; 0
    62ac:	00 97       	sbiw	r24, 0x00	; 0
    62ae:	99 f0       	breq	.+38     	; 0x62d6 <chb_eep_write_byte+0x58>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    62b0:	80 ec       	ldi	r24, 0xC0	; 192
    62b2:	91 e0       	ldi	r25, 0x01	; 1
    62b4:	26 e3       	ldi	r18, 0x36	; 54
    62b6:	fc 01       	movw	r30, r24
    62b8:	22 87       	std	Z+10, r18	; 0x0a
        NVM_EXEC();
    62ba:	ef 93       	push	r30
    62bc:	ff 93       	push	r31
    62be:	0f 93       	push	r16
    62c0:	2f 93       	push	r18
    62c2:	eb ec       	ldi	r30, 0xCB	; 203
    62c4:	f1 e0       	ldi	r31, 0x01	; 1
    62c6:	08 ed       	ldi	r16, 0xD8	; 216
    62c8:	21 e0       	ldi	r18, 0x01	; 1
    62ca:	04 bf       	out	0x34, r16	; 52
    62cc:	20 83       	st	Z, r18
    62ce:	2f 91       	pop	r18
    62d0:	0f 91       	pop	r16
    62d2:	ff 91       	pop	r31
    62d4:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    62d6:	80 ec       	ldi	r24, 0xC0	; 192
    62d8:	91 e0       	ldi	r25, 0x01	; 1
    62da:	23 e3       	ldi	r18, 0x33	; 51
    62dc:	fc 01       	movw	r30, r24
    62de:	22 87       	std	Z+10, r18	; 0x0a

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    62e0:	80 ec       	ldi	r24, 0xC0	; 192
    62e2:	91 e0       	ldi	r25, 0x01	; 1
    62e4:	29 81       	ldd	r18, Y+1	; 0x01
    62e6:	fc 01       	movw	r30, r24
    62e8:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    62ea:	80 ec       	ldi	r24, 0xC0	; 192
    62ec:	91 e0       	ldi	r25, 0x01	; 1
    62ee:	29 81       	ldd	r18, Y+1	; 0x01
    62f0:	3a 81       	ldd	r19, Y+2	; 0x02
    62f2:	23 2f       	mov	r18, r19
    62f4:	33 27       	eor	r19, r19
    62f6:	2f 71       	andi	r18, 0x1F	; 31
    62f8:	fc 01       	movw	r30, r24
    62fa:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    62fc:	80 ec       	ldi	r24, 0xC0	; 192
    62fe:	91 e0       	ldi	r25, 0x01	; 1
    6300:	fc 01       	movw	r30, r24
    6302:	12 82       	std	Z+2, r1	; 0x02

    // load the data to write
    NVM.DATA0 = value;
    6304:	80 ec       	ldi	r24, 0xC0	; 192
    6306:	91 e0       	ldi	r25, 0x01	; 1
    6308:	2b 81       	ldd	r18, Y+3	; 0x03
    630a:	fc 01       	movw	r30, r24
    630c:	24 83       	std	Z+4, r18	; 0x04

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    630e:	80 ec       	ldi	r24, 0xC0	; 192
    6310:	91 e0       	ldi	r25, 0x01	; 1
    6312:	25 e3       	ldi	r18, 0x35	; 53
    6314:	fc 01       	movw	r30, r24
    6316:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    6318:	ef 93       	push	r30
    631a:	ff 93       	push	r31
    631c:	0f 93       	push	r16
    631e:	2f 93       	push	r18
    6320:	eb ec       	ldi	r30, 0xCB	; 203
    6322:	f1 e0       	ldi	r31, 0x01	; 1
    6324:	08 ed       	ldi	r16, 0xD8	; 216
    6326:	21 e0       	ldi	r18, 0x01	; 1
    6328:	04 bf       	out	0x34, r16	; 52
    632a:	20 83       	st	Z, r18
    632c:	2f 91       	pop	r18
    632e:	0f 91       	pop	r16
    6330:	ff 91       	pop	r31
    6332:	ef 91       	pop	r30
}
    6334:	23 96       	adiw	r28, 0x03	; 3
    6336:	cd bf       	out	0x3d, r28	; 61
    6338:	de bf       	out	0x3e, r29	; 62
    633a:	df 91       	pop	r29
    633c:	cf 91       	pop	r28
    633e:	08 95       	ret

00006340 <chb_eep_read_byte>:
/*!

*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    6340:	cf 93       	push	r28
    6342:	df 93       	push	r29
    6344:	0f 92       	push	r0
    6346:	0f 92       	push	r0
    6348:	cd b7       	in	r28, 0x3d	; 61
    634a:	de b7       	in	r29, 0x3e	; 62
    634c:	89 83       	std	Y+1, r24	; 0x01
    634e:	9a 83       	std	Y+2, r25	; 0x02
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    6350:	00 00       	nop
    6352:	80 ec       	ldi	r24, 0xC0	; 192
    6354:	91 e0       	ldi	r25, 0x01	; 1
    6356:	fc 01       	movw	r30, r24
    6358:	87 85       	ldd	r24, Z+15	; 0x0f
    635a:	88 23       	and	r24, r24
    635c:	d4 f3       	brlt	.-12     	; 0x6352 <chb_eep_read_byte+0x12>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    635e:	80 ec       	ldi	r24, 0xC0	; 192
    6360:	91 e0       	ldi	r25, 0x01	; 1
    6362:	29 81       	ldd	r18, Y+1	; 0x01
    6364:	fc 01       	movw	r30, r24
    6366:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    6368:	80 ec       	ldi	r24, 0xC0	; 192
    636a:	91 e0       	ldi	r25, 0x01	; 1
    636c:	29 81       	ldd	r18, Y+1	; 0x01
    636e:	3a 81       	ldd	r19, Y+2	; 0x02
    6370:	23 2f       	mov	r18, r19
    6372:	33 27       	eor	r19, r19
    6374:	2f 71       	andi	r18, 0x1F	; 31
    6376:	fc 01       	movw	r30, r24
    6378:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    637a:	80 ec       	ldi	r24, 0xC0	; 192
    637c:	91 e0       	ldi	r25, 0x01	; 1
    637e:	fc 01       	movw	r30, r24
    6380:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    6382:	80 ec       	ldi	r24, 0xC0	; 192
    6384:	91 e0       	ldi	r25, 0x01	; 1
    6386:	26 e0       	ldi	r18, 0x06	; 6
    6388:	fc 01       	movw	r30, r24
    638a:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    638c:	ef 93       	push	r30
    638e:	ff 93       	push	r31
    6390:	0f 93       	push	r16
    6392:	2f 93       	push	r18
    6394:	eb ec       	ldi	r30, 0xCB	; 203
    6396:	f1 e0       	ldi	r31, 0x01	; 1
    6398:	08 ed       	ldi	r16, 0xD8	; 216
    639a:	21 e0       	ldi	r18, 0x01	; 1
    639c:	04 bf       	out	0x34, r16	; 52
    639e:	20 83       	st	Z, r18
    63a0:	2f 91       	pop	r18
    63a2:	0f 91       	pop	r16
    63a4:	ff 91       	pop	r31
    63a6:	ef 91       	pop	r30

    return NVM.DATA0;
    63a8:	80 ec       	ldi	r24, 0xC0	; 192
    63aa:	91 e0       	ldi	r25, 0x01	; 1
    63ac:	fc 01       	movw	r30, r24
    63ae:	84 81       	ldd	r24, Z+4	; 0x04
}
    63b0:	0f 90       	pop	r0
    63b2:	0f 90       	pop	r0
    63b4:	df 91       	pop	r29
    63b6:	cf 91       	pop	r28
    63b8:	08 95       	ret

000063ba <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    63ba:	cf 93       	push	r28
    63bc:	df 93       	push	r29
    63be:	cd b7       	in	r28, 0x3d	; 61
    63c0:	de b7       	in	r29, 0x3e	; 62
    63c2:	27 97       	sbiw	r28, 0x07	; 7
    63c4:	cd bf       	out	0x3d, r28	; 61
    63c6:	de bf       	out	0x3e, r29	; 62
    63c8:	8a 83       	std	Y+2, r24	; 0x02
    63ca:	9b 83       	std	Y+3, r25	; 0x03
    63cc:	6c 83       	std	Y+4, r22	; 0x04
    63ce:	7d 83       	std	Y+5, r23	; 0x05
    63d0:	4e 83       	std	Y+6, r20	; 0x06
    63d2:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    63d4:	80 ec       	ldi	r24, 0xC0	; 192
    63d6:	91 e0       	ldi	r25, 0x01	; 1
    63d8:	20 ec       	ldi	r18, 0xC0	; 192
    63da:	31 e0       	ldi	r19, 0x01	; 1
    63dc:	f9 01       	movw	r30, r18
    63de:	24 85       	ldd	r18, Z+12	; 0x0c
    63e0:	27 7f       	andi	r18, 0xF7	; 247
    63e2:	fc 01       	movw	r30, r24
    63e4:	24 87       	std	Z+12, r18	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    63e6:	19 82       	std	Y+1, r1	; 0x01
    63e8:	16 c0       	rjmp	.+44     	; 0x6416 <chb_eeprom_write+0x5c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    63ea:	89 81       	ldd	r24, Y+1	; 0x01
    63ec:	28 2f       	mov	r18, r24
    63ee:	30 e0       	ldi	r19, 0x00	; 0
    63f0:	8a 81       	ldd	r24, Y+2	; 0x02
    63f2:	9b 81       	ldd	r25, Y+3	; 0x03
    63f4:	82 0f       	add	r24, r18
    63f6:	93 1f       	adc	r25, r19
    63f8:	29 81       	ldd	r18, Y+1	; 0x01
    63fa:	22 2f       	mov	r18, r18
    63fc:	30 e0       	ldi	r19, 0x00	; 0
    63fe:	4c 81       	ldd	r20, Y+4	; 0x04
    6400:	5d 81       	ldd	r21, Y+5	; 0x05
    6402:	24 0f       	add	r18, r20
    6404:	35 1f       	adc	r19, r21
    6406:	f9 01       	movw	r30, r18
    6408:	20 81       	ld	r18, Z
    640a:	62 2f       	mov	r22, r18
    640c:	0e 94 3f 31 	call	0x627e	; 0x627e <chb_eep_write_byte>
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    6410:	89 81       	ldd	r24, Y+1	; 0x01
    6412:	8f 5f       	subi	r24, 0xFF	; 255
    6414:	89 83       	std	Y+1, r24	; 0x01
    6416:	89 81       	ldd	r24, Y+1	; 0x01
    6418:	28 2f       	mov	r18, r24
    641a:	30 e0       	ldi	r19, 0x00	; 0
    641c:	8e 81       	ldd	r24, Y+6	; 0x06
    641e:	9f 81       	ldd	r25, Y+7	; 0x07
    6420:	28 17       	cp	r18, r24
    6422:	39 07       	cpc	r19, r25
    6424:	10 f3       	brcs	.-60     	; 0x63ea <chb_eeprom_write+0x30>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    6426:	27 96       	adiw	r28, 0x07	; 7
    6428:	cd bf       	out	0x3d, r28	; 61
    642a:	de bf       	out	0x3e, r29	; 62
    642c:	df 91       	pop	r29
    642e:	cf 91       	pop	r28
    6430:	08 95       	ret

00006432 <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    6432:	0f 93       	push	r16
    6434:	1f 93       	push	r17
    6436:	cf 93       	push	r28
    6438:	df 93       	push	r29
    643a:	cd b7       	in	r28, 0x3d	; 61
    643c:	de b7       	in	r29, 0x3e	; 62
    643e:	27 97       	sbiw	r28, 0x07	; 7
    6440:	cd bf       	out	0x3d, r28	; 61
    6442:	de bf       	out	0x3e, r29	; 62
    6444:	8a 83       	std	Y+2, r24	; 0x02
    6446:	9b 83       	std	Y+3, r25	; 0x03
    6448:	6c 83       	std	Y+4, r22	; 0x04
    644a:	7d 83       	std	Y+5, r23	; 0x05
    644c:	4e 83       	std	Y+6, r20	; 0x06
    644e:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    6450:	80 ec       	ldi	r24, 0xC0	; 192
    6452:	91 e0       	ldi	r25, 0x01	; 1
    6454:	20 ec       	ldi	r18, 0xC0	; 192
    6456:	31 e0       	ldi	r19, 0x01	; 1
    6458:	f9 01       	movw	r30, r18
    645a:	24 85       	ldd	r18, Z+12	; 0x0c
    645c:	27 7f       	andi	r18, 0xF7	; 247
    645e:	fc 01       	movw	r30, r24
    6460:	24 87       	std	Z+12, r18	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    6462:	19 82       	std	Y+1, r1	; 0x01
    6464:	16 c0       	rjmp	.+44     	; 0x6492 <chb_eeprom_read+0x60>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    6466:	89 81       	ldd	r24, Y+1	; 0x01
    6468:	88 2f       	mov	r24, r24
    646a:	90 e0       	ldi	r25, 0x00	; 0
    646c:	2c 81       	ldd	r18, Y+4	; 0x04
    646e:	3d 81       	ldd	r19, Y+5	; 0x05
    6470:	89 01       	movw	r16, r18
    6472:	08 0f       	add	r16, r24
    6474:	19 1f       	adc	r17, r25
    6476:	89 81       	ldd	r24, Y+1	; 0x01
    6478:	28 2f       	mov	r18, r24
    647a:	30 e0       	ldi	r19, 0x00	; 0
    647c:	8a 81       	ldd	r24, Y+2	; 0x02
    647e:	9b 81       	ldd	r25, Y+3	; 0x03
    6480:	82 0f       	add	r24, r18
    6482:	93 1f       	adc	r25, r19
    6484:	0e 94 a0 31 	call	0x6340	; 0x6340 <chb_eep_read_byte>
    6488:	f8 01       	movw	r30, r16
    648a:	80 83       	st	Z, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    648c:	89 81       	ldd	r24, Y+1	; 0x01
    648e:	8f 5f       	subi	r24, 0xFF	; 255
    6490:	89 83       	std	Y+1, r24	; 0x01
    6492:	89 81       	ldd	r24, Y+1	; 0x01
    6494:	28 2f       	mov	r18, r24
    6496:	30 e0       	ldi	r19, 0x00	; 0
    6498:	8e 81       	ldd	r24, Y+6	; 0x06
    649a:	9f 81       	ldd	r25, Y+7	; 0x07
    649c:	28 17       	cp	r18, r24
    649e:	39 07       	cpc	r19, r25
    64a0:	10 f3       	brcs	.-60     	; 0x6466 <chb_eeprom_read+0x34>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    64a2:	27 96       	adiw	r28, 0x07	; 7
    64a4:	cd bf       	out	0x3d, r28	; 61
    64a6:	de bf       	out	0x3e, r29	; 62
    64a8:	df 91       	pop	r29
    64aa:	cf 91       	pop	r28
    64ac:	1f 91       	pop	r17
    64ae:	0f 91       	pop	r16
    64b0:	08 95       	ret

000064b2 <chb_spi_init>:

*/
/**************************************************************************/

void chb_spi_init()
{
    64b2:	cf 93       	push	r28
    64b4:	df 93       	push	r29
    64b6:	cd b7       	in	r28, 0x3d	; 61
    64b8:	de b7       	in	r29, 0x3e	; 62
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    64ba:	80 e6       	ldi	r24, 0x60	; 96
    64bc:	96 e0       	ldi	r25, 0x06	; 6
    64be:	20 e6       	ldi	r18, 0x60	; 96
    64c0:	36 e0       	ldi	r19, 0x06	; 6
    64c2:	f9 01       	movw	r30, r18
    64c4:	20 81       	ld	r18, Z
    64c6:	20 6b       	ori	r18, 0xB0	; 176
    64c8:	fc 01       	movw	r30, r24
    64ca:	20 83       	st	Z, r18
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    64cc:	84 e6       	ldi	r24, 0x64	; 100
    64ce:	96 e0       	ldi	r25, 0x06	; 6
    64d0:	24 e6       	ldi	r18, 0x64	; 100
    64d2:	36 e0       	ldi	r19, 0x06	; 6
    64d4:	f9 01       	movw	r30, r18
    64d6:	20 81       	ld	r18, Z
    64d8:	20 61       	ori	r18, 0x10	; 16
    64da:	fc 01       	movw	r30, r24
    64dc:	20 83       	st	Z, r18

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    64de:	80 ec       	ldi	r24, 0xC0	; 192
    64e0:	99 e0       	ldi	r25, 0x09	; 9
    64e2:	20 ec       	ldi	r18, 0xC0	; 192
    64e4:	39 e0       	ldi	r19, 0x09	; 9
    64e6:	f9 01       	movw	r30, r18
    64e8:	20 81       	ld	r18, Z
    64ea:	21 65       	ori	r18, 0x51	; 81
    64ec:	fc 01       	movw	r30, r24
    64ee:	20 83       	st	Z, r18

    // set the slave select to idle
    CHB_SPI_DISABLE();
    64f0:	84 e6       	ldi	r24, 0x64	; 100
    64f2:	96 e0       	ldi	r25, 0x06	; 6
    64f4:	24 e6       	ldi	r18, 0x64	; 100
    64f6:	36 e0       	ldi	r19, 0x06	; 6
    64f8:	f9 01       	movw	r30, r18
    64fa:	20 81       	ld	r18, Z
    64fc:	20 61       	ori	r18, 0x10	; 16
    64fe:	fc 01       	movw	r30, r24
    6500:	20 83       	st	Z, r18
}
    6502:	df 91       	pop	r29
    6504:	cf 91       	pop	r28
    6506:	08 95       	ret

00006508 <SPID_write>:
    This function both reads and writes data. For write operations, include data
    to be written as argument. For read ops, use dummy data as arg. Returned
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
    6508:	cf 93       	push	r28
    650a:	df 93       	push	r29
    650c:	0f 92       	push	r0
    650e:	0f 92       	push	r0
    6510:	cd b7       	in	r28, 0x3d	; 61
    6512:	de b7       	in	r29, 0x3e	; 62
    6514:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPID.DATA = byteToSend;
    6516:	80 ec       	ldi	r24, 0xC0	; 192
    6518:	99 e0       	ldi	r25, 0x09	; 9
    651a:	2a 81       	ldd	r18, Y+2	; 0x02
    651c:	fc 01       	movw	r30, r24
    651e:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    6520:	00 00       	nop
    6522:	80 ec       	ldi	r24, 0xC0	; 192
    6524:	99 e0       	ldi	r25, 0x09	; 9
    6526:	fc 01       	movw	r30, r24
    6528:	82 81       	ldd	r24, Z+2	; 0x02
    652a:	88 23       	and	r24, r24
    652c:	d4 f7       	brge	.-12     	; 0x6522 <SPID_write+0x1a>
	data = SPID.DATA; //read SPI data register to reset status flag
    652e:	80 ec       	ldi	r24, 0xC0	; 192
    6530:	99 e0       	ldi	r25, 0x09	; 9
    6532:	fc 01       	movw	r30, r24
    6534:	83 81       	ldd	r24, Z+3	; 0x03
    6536:	89 83       	std	Y+1, r24	; 0x01
	return data;
    6538:	89 81       	ldd	r24, Y+1	; 0x01
    653a:	0f 90       	pop	r0
    653c:	0f 90       	pop	r0
    653e:	df 91       	pop	r29
    6540:	cf 91       	pop	r28
    6542:	08 95       	ret

00006544 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    6544:	0f 93       	push	r16
    6546:	cf 93       	push	r28
    6548:	df 93       	push	r29
    654a:	00 d0       	rcall	.+0      	; 0x654c <CCPWrite+0x8>
    654c:	00 d0       	rcall	.+0      	; 0x654e <CCPWrite+0xa>
    654e:	cd b7       	in	r28, 0x3d	; 61
    6550:	de b7       	in	r29, 0x3e	; 62
    6552:	8c 83       	std	Y+4, r24	; 0x04
    6554:	9d 83       	std	Y+5, r25	; 0x05
    6556:	6e 83       	std	Y+6, r22	; 0x06

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    6558:	8f e3       	ldi	r24, 0x3F	; 63
    655a:	90 e0       	ldi	r25, 0x00	; 0
    655c:	fc 01       	movw	r30, r24
    655e:	80 81       	ld	r24, Z
    6560:	8b 83       	std	Y+3, r24	; 0x03
    6562:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
    6564:	8c 81       	ldd	r24, Y+4	; 0x04
    6566:	9d 81       	ldd	r25, Y+5	; 0x05
    6568:	89 83       	std	Y+1, r24	; 0x01
    656a:	9a 83       	std	Y+2, r25	; 0x02
#ifdef RAMPZ
	RAMPZ = 0;
    656c:	8b e3       	ldi	r24, 0x3B	; 59
    656e:	90 e0       	ldi	r25, 0x00	; 0
    6570:	fc 01       	movw	r30, r24
    6572:	10 82       	st	Z, r1
#endif
	asm volatile(
    6574:	89 81       	ldd	r24, Y+1	; 0x01
    6576:	9a 81       	ldd	r25, Y+2	; 0x02
    6578:	2e 81       	ldd	r18, Y+6	; 0x06
    657a:	fc 01       	movw	r30, r24
    657c:	08 ed       	ldi	r16, 0xD8	; 216
    657e:	04 bf       	out	0x34, r16	; 52
    6580:	20 83       	st	Z, r18
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    6582:	8f e3       	ldi	r24, 0x3F	; 63
    6584:	90 e0       	ldi	r25, 0x00	; 0
    6586:	2b 81       	ldd	r18, Y+3	; 0x03
    6588:	fc 01       	movw	r30, r24
    658a:	20 83       	st	Z, r18
#endif
}
    658c:	26 96       	adiw	r28, 0x06	; 6
    658e:	cd bf       	out	0x3d, r28	; 61
    6590:	de bf       	out	0x3e, r29	; 62
    6592:	df 91       	pop	r29
    6594:	cf 91       	pop	r28
    6596:	0f 91       	pop	r16
    6598:	08 95       	ret

0000659a <CLKSYS_XOSC_Config>:
 *                             external clock) and startup times.
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
    659a:	cf 93       	push	r28
    659c:	df 93       	push	r29
    659e:	00 d0       	rcall	.+0      	; 0x65a0 <CLKSYS_XOSC_Config+0x6>
    65a0:	cd b7       	in	r28, 0x3d	; 61
    65a2:	de b7       	in	r29, 0x3e	; 62
    65a4:	89 83       	std	Y+1, r24	; 0x01
    65a6:	6a 83       	std	Y+2, r22	; 0x02
    65a8:	4b 83       	std	Y+3, r20	; 0x03
	OSC.XOSCCTRL = (uint8_t) freqRange |
    65aa:	80 e5       	ldi	r24, 0x50	; 80
    65ac:	90 e0       	ldi	r25, 0x00	; 0
    65ae:	2a 81       	ldd	r18, Y+2	; 0x02
    65b0:	22 23       	and	r18, r18
    65b2:	11 f0       	breq	.+4      	; 0x65b8 <CLKSYS_XOSC_Config+0x1e>
    65b4:	20 e2       	ldi	r18, 0x20	; 32
    65b6:	01 c0       	rjmp	.+2      	; 0x65ba <CLKSYS_XOSC_Config+0x20>
    65b8:	20 e0       	ldi	r18, 0x00	; 0
    65ba:	39 81       	ldd	r19, Y+1	; 0x01
    65bc:	32 2b       	or	r19, r18
    65be:	2b 81       	ldd	r18, Y+3	; 0x03
    65c0:	23 2b       	or	r18, r19
    65c2:	fc 01       	movw	r30, r24
    65c4:	22 83       	std	Z+2, r18	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    65c6:	23 96       	adiw	r28, 0x03	; 3
    65c8:	cd bf       	out	0x3d, r28	; 61
    65ca:	de bf       	out	0x3e, r29	; 62
    65cc:	df 91       	pop	r29
    65ce:	cf 91       	pop	r28
    65d0:	08 95       	ret

000065d2 <CLKSYS_PLL_Config>:
 *                      must be above 0.4MHz.
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
    65d2:	cf 93       	push	r28
    65d4:	df 93       	push	r29
    65d6:	0f 92       	push	r0
    65d8:	0f 92       	push	r0
    65da:	cd b7       	in	r28, 0x3d	; 61
    65dc:	de b7       	in	r29, 0x3e	; 62
    65de:	89 83       	std	Y+1, r24	; 0x01
    65e0:	6a 83       	std	Y+2, r22	; 0x02
	factor &= OSC_PLLFAC_gm;
    65e2:	8a 81       	ldd	r24, Y+2	; 0x02
    65e4:	8f 71       	andi	r24, 0x1F	; 31
    65e6:	8a 83       	std	Y+2, r24	; 0x02
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    65e8:	80 e5       	ldi	r24, 0x50	; 80
    65ea:	90 e0       	ldi	r25, 0x00	; 0
    65ec:	39 81       	ldd	r19, Y+1	; 0x01
    65ee:	2a 81       	ldd	r18, Y+2	; 0x02
    65f0:	23 2b       	or	r18, r19
    65f2:	fc 01       	movw	r30, r24
    65f4:	25 83       	std	Z+5, r18	; 0x05
}
    65f6:	0f 90       	pop	r0
    65f8:	0f 90       	pop	r0
    65fa:	df 91       	pop	r29
    65fc:	cf 91       	pop	r28
    65fe:	08 95       	ret

00006600 <CLKSYS_Disable>:
 *                 OSC_XOSCEN_bm, OSC_PLLEN_bm.
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
    6600:	cf 93       	push	r28
    6602:	df 93       	push	r29
    6604:	0f 92       	push	r0
    6606:	0f 92       	push	r0
    6608:	cd b7       	in	r28, 0x3d	; 61
    660a:	de b7       	in	r29, 0x3e	; 62
    660c:	8a 83       	std	Y+2, r24	; 0x02
	OSC.CTRL &= ~oscSel;
    660e:	80 e5       	ldi	r24, 0x50	; 80
    6610:	90 e0       	ldi	r25, 0x00	; 0
    6612:	20 e5       	ldi	r18, 0x50	; 80
    6614:	30 e0       	ldi	r19, 0x00	; 0
    6616:	f9 01       	movw	r30, r18
    6618:	20 81       	ld	r18, Z
    661a:	32 2f       	mov	r19, r18
    661c:	2a 81       	ldd	r18, Y+2	; 0x02
    661e:	20 95       	com	r18
    6620:	23 23       	and	r18, r19
    6622:	fc 01       	movw	r30, r24
    6624:	20 83       	st	Z, r18
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    6626:	80 e5       	ldi	r24, 0x50	; 80
    6628:	90 e0       	ldi	r25, 0x00	; 0
    662a:	fc 01       	movw	r30, r24
    662c:	90 81       	ld	r25, Z
    662e:	8a 81       	ldd	r24, Y+2	; 0x02
    6630:	89 23       	and	r24, r25
    6632:	89 83       	std	Y+1, r24	; 0x01
	return clkEnabled;
    6634:	89 81       	ldd	r24, Y+1	; 0x01
}
    6636:	0f 90       	pop	r0
    6638:	0f 90       	pop	r0
    663a:	df 91       	pop	r29
    663c:	cf 91       	pop	r28
    663e:	08 95       	ret

00006640 <CLKSYS_Prescalers_Config>:
 *  \param  PSBCfactor  Prescaler B and C division factor, in the combination
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
    6640:	cf 93       	push	r28
    6642:	df 93       	push	r29
    6644:	00 d0       	rcall	.+0      	; 0x6646 <CLKSYS_Prescalers_Config+0x6>
    6646:	cd b7       	in	r28, 0x3d	; 61
    6648:	de b7       	in	r29, 0x3e	; 62
    664a:	8a 83       	std	Y+2, r24	; 0x02
    664c:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    664e:	9a 81       	ldd	r25, Y+2	; 0x02
    6650:	8b 81       	ldd	r24, Y+3	; 0x03
    6652:	89 2b       	or	r24, r25
    6654:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.PSCTRL, PSconfig );
    6656:	81 e4       	ldi	r24, 0x41	; 65
    6658:	90 e0       	ldi	r25, 0x00	; 0
    665a:	69 81       	ldd	r22, Y+1	; 0x01
    665c:	0e 94 a2 32 	call	0x6544	; 0x6544 <CCPWrite>
}
    6660:	23 96       	adiw	r28, 0x03	; 3
    6662:	cd bf       	out	0x3d, r28	; 61
    6664:	de bf       	out	0x3e, r29	; 62
    6666:	df 91       	pop	r29
    6668:	cf 91       	pop	r28
    666a:	08 95       	ret

0000666c <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    666c:	cf 93       	push	r28
    666e:	df 93       	push	r29
    6670:	0f 92       	push	r0
    6672:	0f 92       	push	r0
    6674:	cd b7       	in	r28, 0x3d	; 61
    6676:	de b7       	in	r29, 0x3e	; 62
    6678:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    667a:	80 e4       	ldi	r24, 0x40	; 64
    667c:	90 e0       	ldi	r25, 0x00	; 0
    667e:	fc 01       	movw	r30, r24
    6680:	80 81       	ld	r24, Z
    6682:	98 2f       	mov	r25, r24
    6684:	98 7f       	andi	r25, 0xF8	; 248
    6686:	8a 81       	ldd	r24, Y+2	; 0x02
    6688:	89 2b       	or	r24, r25
    668a:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.CTRL, clkCtrl );
    668c:	80 e4       	ldi	r24, 0x40	; 64
    668e:	90 e0       	ldi	r25, 0x00	; 0
    6690:	69 81       	ldd	r22, Y+1	; 0x01
    6692:	0e 94 a2 32 	call	0x6544	; 0x6544 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    6696:	80 e4       	ldi	r24, 0x40	; 64
    6698:	90 e0       	ldi	r25, 0x00	; 0
    669a:	fc 01       	movw	r30, r24
    669c:	90 81       	ld	r25, Z
    669e:	8a 81       	ldd	r24, Y+2	; 0x02
    66a0:	89 23       	and	r24, r25
    66a2:	89 83       	std	Y+1, r24	; 0x01
	return clkCtrl;
    66a4:	89 81       	ldd	r24, Y+1	; 0x01
}
    66a6:	0f 90       	pop	r0
    66a8:	0f 90       	pop	r0
    66aa:	df 91       	pop	r29
    66ac:	cf 91       	pop	r28
    66ae:	08 95       	ret

000066b0 <CLKSYS_RTC_ClockSource_Enable>:
 *  and enables clock signal routing to the RTC module.
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
    66b0:	cf 93       	push	r28
    66b2:	df 93       	push	r29
    66b4:	0f 92       	push	r0
    66b6:	cd b7       	in	r28, 0x3d	; 61
    66b8:	de b7       	in	r29, 0x3e	; 62
    66ba:	89 83       	std	Y+1, r24	; 0x01
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    66bc:	80 e4       	ldi	r24, 0x40	; 64
    66be:	90 e0       	ldi	r25, 0x00	; 0
    66c0:	20 e4       	ldi	r18, 0x40	; 64
    66c2:	30 e0       	ldi	r19, 0x00	; 0
    66c4:	f9 01       	movw	r30, r18
    66c6:	23 81       	ldd	r18, Z+3	; 0x03
    66c8:	32 2f       	mov	r19, r18
    66ca:	31 7f       	andi	r19, 0xF1	; 241
    66cc:	29 81       	ldd	r18, Y+1	; 0x01
    66ce:	23 2b       	or	r18, r19
    66d0:	21 60       	ori	r18, 0x01	; 1
    66d2:	fc 01       	movw	r30, r24
    66d4:	23 83       	std	Z+3, r18	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    66d6:	0f 90       	pop	r0
    66d8:	df 91       	pop	r29
    66da:	cf 91       	pop	r28
    66dc:	08 95       	ret

000066de <CLKSYS_AutoCalibration_Enable>:
 *  \param  clkSource    Clock source to calibrate, either OSC_RC2MCREF_bm or
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
    66de:	cf 93       	push	r28
    66e0:	df 93       	push	r29
    66e2:	0f 92       	push	r0
    66e4:	0f 92       	push	r0
    66e6:	cd b7       	in	r28, 0x3d	; 61
    66e8:	de b7       	in	r29, 0x3e	; 62
    66ea:	89 83       	std	Y+1, r24	; 0x01
    66ec:	6a 83       	std	Y+2, r22	; 0x02
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    66ee:	80 e5       	ldi	r24, 0x50	; 80
    66f0:	90 e0       	ldi	r25, 0x00	; 0
    66f2:	20 e5       	ldi	r18, 0x50	; 80
    66f4:	30 e0       	ldi	r19, 0x00	; 0
    66f6:	f9 01       	movw	r30, r18
    66f8:	26 81       	ldd	r18, Z+6	; 0x06
    66fa:	32 2f       	mov	r19, r18
    66fc:	29 81       	ldd	r18, Y+1	; 0x01
    66fe:	20 95       	com	r18
    6700:	32 23       	and	r19, r18
    6702:	2a 81       	ldd	r18, Y+2	; 0x02
    6704:	22 23       	and	r18, r18
    6706:	11 f0       	breq	.+4      	; 0x670c <CLKSYS_AutoCalibration_Enable+0x2e>
    6708:	29 81       	ldd	r18, Y+1	; 0x01
    670a:	01 c0       	rjmp	.+2      	; 0x670e <CLKSYS_AutoCalibration_Enable+0x30>
    670c:	20 e0       	ldi	r18, 0x00	; 0
    670e:	23 2b       	or	r18, r19
    6710:	fc 01       	movw	r30, r24
    6712:	26 83       	std	Z+6, r18	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    6714:	89 81       	ldd	r24, Y+1	; 0x01
    6716:	81 30       	cpi	r24, 0x01	; 1
    6718:	51 f4       	brne	.+20     	; 0x672e <CLKSYS_AutoCalibration_Enable+0x50>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    671a:	88 e6       	ldi	r24, 0x68	; 104
    671c:	90 e0       	ldi	r25, 0x00	; 0
    671e:	28 e6       	ldi	r18, 0x68	; 104
    6720:	30 e0       	ldi	r19, 0x00	; 0
    6722:	f9 01       	movw	r30, r18
    6724:	20 81       	ld	r18, Z
    6726:	21 60       	ori	r18, 0x01	; 1
    6728:	fc 01       	movw	r30, r24
    672a:	20 83       	st	Z, r18
    672c:	0c c0       	rjmp	.+24     	; 0x6746 <CLKSYS_AutoCalibration_Enable+0x68>
	} else if (clkSource == OSC_RC32MCREF_bm) {
    672e:	89 81       	ldd	r24, Y+1	; 0x01
    6730:	82 30       	cpi	r24, 0x02	; 2
    6732:	49 f4       	brne	.+18     	; 0x6746 <CLKSYS_AutoCalibration_Enable+0x68>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    6734:	80 e6       	ldi	r24, 0x60	; 96
    6736:	90 e0       	ldi	r25, 0x00	; 0
    6738:	20 e6       	ldi	r18, 0x60	; 96
    673a:	30 e0       	ldi	r19, 0x00	; 0
    673c:	f9 01       	movw	r30, r18
    673e:	20 81       	ld	r18, Z
    6740:	21 60       	ori	r18, 0x01	; 1
    6742:	fc 01       	movw	r30, r24
    6744:	20 83       	st	Z, r18
	}
}
    6746:	0f 90       	pop	r0
    6748:	0f 90       	pop	r0
    674a:	df 91       	pop	r29
    674c:	cf 91       	pop	r28
    674e:	08 95       	ret

00006750 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  XOSCFD _will_ issue the XOSCF Non-maskable Interrupt (NMI) regardless of
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
    6750:	cf 93       	push	r28
    6752:	df 93       	push	r29
    6754:	cd b7       	in	r28, 0x3d	; 61
    6756:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    6758:	83 e5       	ldi	r24, 0x53	; 83
    675a:	90 e0       	ldi	r25, 0x00	; 0
    675c:	63 e0       	ldi	r22, 0x03	; 3
    675e:	0e 94 a2 32 	call	0x6544	; 0x6544 <CCPWrite>
}
    6762:	df 91       	pop	r29
    6764:	cf 91       	pop	r28
    6766:	08 95       	ret

00006768 <CLKSYS_Configuration_Lock>:
 *  This will lock the configuration until the next reset, or until the
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
    6768:	cf 93       	push	r28
    676a:	df 93       	push	r29
    676c:	cd b7       	in	r28, 0x3d	; 61
    676e:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    6770:	82 e4       	ldi	r24, 0x42	; 66
    6772:	90 e0       	ldi	r25, 0x00	; 0
    6774:	61 e0       	ldi	r22, 0x01	; 1
    6776:	0e 94 a2 32 	call	0x6544	; 0x6544 <CCPWrite>
}
    677a:	df 91       	pop	r29
    677c:	cf 91       	pop	r28
    677e:	08 95       	ret

00006780 <setXOSC_32MHz>:
// so this function will fail until the oscillator is installed.
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
    6780:	cf 93       	push	r28
    6782:	df 93       	push	r29
    6784:	cd b7       	in	r28, 0x3d	; 61
    6786:	de b7       	in	r29, 0x3e	; 62
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    6788:	80 ec       	ldi	r24, 0xC0	; 192
    678a:	60 e0       	ldi	r22, 0x00	; 0
    678c:	4b e0       	ldi	r20, 0x0B	; 11
    678e:	0e 94 cd 32 	call	0x659a	; 0x659a <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    6792:	80 e5       	ldi	r24, 0x50	; 80
    6794:	90 e0       	ldi	r25, 0x00	; 0
    6796:	20 e5       	ldi	r18, 0x50	; 80
    6798:	30 e0       	ldi	r19, 0x00	; 0
    679a:	f9 01       	movw	r30, r18
    679c:	20 81       	ld	r18, Z
    679e:	28 60       	ori	r18, 0x08	; 8
    67a0:	fc 01       	movw	r30, r24
    67a2:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    67a4:	80 e5       	ldi	r24, 0x50	; 80
    67a6:	90 e0       	ldi	r25, 0x00	; 0
    67a8:	fc 01       	movw	r30, r24
    67aa:	81 81       	ldd	r24, Z+1	; 0x01
    67ac:	88 2f       	mov	r24, r24
    67ae:	90 e0       	ldi	r25, 0x00	; 0
    67b0:	88 70       	andi	r24, 0x08	; 8
    67b2:	90 70       	andi	r25, 0x00	; 0
    67b4:	00 97       	sbiw	r24, 0x00	; 0
    67b6:	b1 f3       	breq	.-20     	; 0x67a4 <setXOSC_32MHz+0x24>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    67b8:	80 ec       	ldi	r24, 0xC0	; 192
    67ba:	62 e0       	ldi	r22, 0x02	; 2
    67bc:	0e 94 e9 32 	call	0x65d2	; 0x65d2 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    67c0:	80 e5       	ldi	r24, 0x50	; 80
    67c2:	90 e0       	ldi	r25, 0x00	; 0
    67c4:	20 e5       	ldi	r18, 0x50	; 80
    67c6:	30 e0       	ldi	r19, 0x00	; 0
    67c8:	f9 01       	movw	r30, r18
    67ca:	20 81       	ld	r18, Z
    67cc:	20 61       	ori	r18, 0x10	; 16
    67ce:	fc 01       	movw	r30, r24
    67d0:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    67d2:	80 e5       	ldi	r24, 0x50	; 80
    67d4:	90 e0       	ldi	r25, 0x00	; 0
    67d6:	fc 01       	movw	r30, r24
    67d8:	81 81       	ldd	r24, Z+1	; 0x01
    67da:	88 2f       	mov	r24, r24
    67dc:	90 e0       	ldi	r25, 0x00	; 0
    67de:	80 71       	andi	r24, 0x10	; 16
    67e0:	90 70       	andi	r25, 0x00	; 0
    67e2:	00 97       	sbiw	r24, 0x00	; 0
    67e4:	b1 f3       	breq	.-20     	; 0x67d2 <setXOSC_32MHz+0x52>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    67e6:	84 e0       	ldi	r24, 0x04	; 4
    67e8:	0e 94 36 33 	call	0x666c	; 0x666c <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    67ec:	81 e0       	ldi	r24, 0x01	; 1
    67ee:	0e 94 00 33 	call	0x6600	; 0x6600 <CLKSYS_Disable>
}
    67f2:	df 91       	pop	r29
    67f4:	cf 91       	pop	r28
    67f6:	08 95       	ret

000067f8 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
    67f8:	cf 93       	push	r28
    67fa:	df 93       	push	r29
    67fc:	cd b7       	in	r28, 0x3d	; 61
    67fe:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    6800:	80 e5       	ldi	r24, 0x50	; 80
    6802:	90 e0       	ldi	r25, 0x00	; 0
    6804:	20 e5       	ldi	r18, 0x50	; 80
    6806:	30 e0       	ldi	r19, 0x00	; 0
    6808:	f9 01       	movw	r30, r18
    680a:	20 81       	ld	r18, Z
    680c:	22 60       	ori	r18, 0x02	; 2
    680e:	fc 01       	movw	r30, r24
    6810:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    6812:	80 e0       	ldi	r24, 0x00	; 0
    6814:	61 e0       	ldi	r22, 0x01	; 1
    6816:	0e 94 20 33 	call	0x6640	; 0x6640 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    681a:	80 e5       	ldi	r24, 0x50	; 80
    681c:	90 e0       	ldi	r25, 0x00	; 0
    681e:	fc 01       	movw	r30, r24
    6820:	81 81       	ldd	r24, Z+1	; 0x01
    6822:	88 2f       	mov	r24, r24
    6824:	90 e0       	ldi	r25, 0x00	; 0
    6826:	82 70       	andi	r24, 0x02	; 2
    6828:	90 70       	andi	r25, 0x00	; 0
    682a:	00 97       	sbiw	r24, 0x00	; 0
    682c:	b1 f3       	breq	.-20     	; 0x681a <set_16MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    682e:	81 e0       	ldi	r24, 0x01	; 1
    6830:	0e 94 36 33 	call	0x666c	; 0x666c <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6834:	81 e0       	ldi	r24, 0x01	; 1
    6836:	0e 94 00 33 	call	0x6600	; 0x6600 <CLKSYS_Disable>
	
}
    683a:	df 91       	pop	r29
    683c:	cf 91       	pop	r28
    683e:	08 95       	ret

00006840 <set_32MHz>:


// produces consistent but inaccurate clock period.
void set_32MHz() {
    6840:	cf 93       	push	r28
    6842:	df 93       	push	r29
    6844:	cd b7       	in	r28, 0x3d	; 61
    6846:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    6848:	80 e5       	ldi	r24, 0x50	; 80
    684a:	90 e0       	ldi	r25, 0x00	; 0
    684c:	20 e5       	ldi	r18, 0x50	; 80
    684e:	30 e0       	ldi	r19, 0x00	; 0
    6850:	f9 01       	movw	r30, r18
    6852:	20 81       	ld	r18, Z
    6854:	22 60       	ori	r18, 0x02	; 2
    6856:	fc 01       	movw	r30, r24
    6858:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    685a:	80 e0       	ldi	r24, 0x00	; 0
    685c:	60 e0       	ldi	r22, 0x00	; 0
    685e:	0e 94 20 33 	call	0x6640	; 0x6640 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    6862:	80 e5       	ldi	r24, 0x50	; 80
    6864:	90 e0       	ldi	r25, 0x00	; 0
    6866:	fc 01       	movw	r30, r24
    6868:	81 81       	ldd	r24, Z+1	; 0x01
    686a:	88 2f       	mov	r24, r24
    686c:	90 e0       	ldi	r25, 0x00	; 0
    686e:	82 70       	andi	r24, 0x02	; 2
    6870:	90 70       	andi	r25, 0x00	; 0
    6872:	00 97       	sbiw	r24, 0x00	; 0
    6874:	b1 f3       	breq	.-20     	; 0x6862 <set_32MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    6876:	81 e0       	ldi	r24, 0x01	; 1
    6878:	0e 94 36 33 	call	0x666c	; 0x666c <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    687c:	81 e0       	ldi	r24, 0x01	; 1
    687e:	0e 94 00 33 	call	0x6600	; 0x6600 <CLKSYS_Disable>
	
}
    6882:	df 91       	pop	r29
    6884:	cf 91       	pop	r28
    6886:	08 95       	ret

00006888 <portExCS>:


void portExCS(uint8_t write) {
    6888:	0f 93       	push	r16
    688a:	1f 93       	push	r17
    688c:	cf 93       	push	r28
    688e:	df 93       	push	r29
    6890:	cd b7       	in	r28, 0x3d	; 61
    6892:	de b7       	in	r29, 0x3e	; 62
    6894:	69 97       	sbiw	r28, 0x19	; 25
    6896:	cd bf       	out	0x3d, r28	; 61
    6898:	de bf       	out	0x3e, r29	; 62
    689a:	89 8f       	std	Y+25, r24	; 0x19
	if (write) PORTA.OUTCLR = PIN3_bm;
    689c:	89 8d       	ldd	r24, Y+25	; 0x19
    689e:	88 23       	and	r24, r24
    68a0:	31 f0       	breq	.+12     	; 0x68ae <portExCS+0x26>
    68a2:	80 e0       	ldi	r24, 0x00	; 0
    68a4:	96 e0       	ldi	r25, 0x06	; 6
    68a6:	28 e0       	ldi	r18, 0x08	; 8
    68a8:	fc 01       	movw	r30, r24
    68aa:	26 83       	std	Z+6, r18	; 0x06
    68ac:	05 c0       	rjmp	.+10     	; 0x68b8 <portExCS+0x30>
	else {
		PORTA.OUTSET = PIN3_bm;
    68ae:	80 e0       	ldi	r24, 0x00	; 0
    68b0:	96 e0       	ldi	r25, 0x06	; 6
    68b2:	28 e0       	ldi	r18, 0x08	; 8
    68b4:	fc 01       	movw	r30, r24
    68b6:	25 83       	std	Z+5, r18	; 0x05
    68b8:	80 e0       	ldi	r24, 0x00	; 0
    68ba:	90 e0       	ldi	r25, 0x00	; 0
    68bc:	a0 e2       	ldi	r26, 0x20	; 32
    68be:	b1 e4       	ldi	r27, 0x41	; 65
    68c0:	89 83       	std	Y+1, r24	; 0x01
    68c2:	9a 83       	std	Y+2, r25	; 0x02
    68c4:	ab 83       	std	Y+3, r26	; 0x03
    68c6:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    68c8:	69 81       	ldd	r22, Y+1	; 0x01
    68ca:	7a 81       	ldd	r23, Y+2	; 0x02
    68cc:	8b 81       	ldd	r24, Y+3	; 0x03
    68ce:	9c 81       	ldd	r25, Y+4	; 0x04
    68d0:	2b ea       	ldi	r18, 0xAB	; 171
    68d2:	3a ea       	ldi	r19, 0xAA	; 170
    68d4:	4a e2       	ldi	r20, 0x2A	; 42
    68d6:	51 e4       	ldi	r21, 0x41	; 65
    68d8:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    68dc:	dc 01       	movw	r26, r24
    68de:	cb 01       	movw	r24, r22
    68e0:	8d 83       	std	Y+5, r24	; 0x05
    68e2:	9e 83       	std	Y+6, r25	; 0x06
    68e4:	af 83       	std	Y+7, r26	; 0x07
    68e6:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    68e8:	11 e0       	ldi	r17, 0x01	; 1
    68ea:	6d 81       	ldd	r22, Y+5	; 0x05
    68ec:	7e 81       	ldd	r23, Y+6	; 0x06
    68ee:	8f 81       	ldd	r24, Y+7	; 0x07
    68f0:	98 85       	ldd	r25, Y+8	; 0x08
    68f2:	20 e0       	ldi	r18, 0x00	; 0
    68f4:	30 e0       	ldi	r19, 0x00	; 0
    68f6:	40 e8       	ldi	r20, 0x80	; 128
    68f8:	5f e3       	ldi	r21, 0x3F	; 63
    68fa:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    68fe:	88 23       	and	r24, r24
    6900:	0c f0       	brlt	.+2      	; 0x6904 <portExCS+0x7c>
    6902:	10 e0       	ldi	r17, 0x00	; 0
    6904:	11 23       	and	r17, r17
    6906:	19 f0       	breq	.+6      	; 0x690e <portExCS+0x86>
		__ticks = 1;
    6908:	81 e0       	ldi	r24, 0x01	; 1
    690a:	89 87       	std	Y+9, r24	; 0x09
    690c:	a3 c0       	rjmp	.+326    	; 0x6a54 <portExCS+0x1cc>
	else if (__tmp > 255)
    690e:	11 e0       	ldi	r17, 0x01	; 1
    6910:	6d 81       	ldd	r22, Y+5	; 0x05
    6912:	7e 81       	ldd	r23, Y+6	; 0x06
    6914:	8f 81       	ldd	r24, Y+7	; 0x07
    6916:	98 85       	ldd	r25, Y+8	; 0x08
    6918:	20 e0       	ldi	r18, 0x00	; 0
    691a:	30 e0       	ldi	r19, 0x00	; 0
    691c:	4f e7       	ldi	r20, 0x7F	; 127
    691e:	53 e4       	ldi	r21, 0x43	; 67
    6920:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    6924:	18 16       	cp	r1, r24
    6926:	0c f0       	brlt	.+2      	; 0x692a <portExCS+0xa2>
    6928:	10 e0       	ldi	r17, 0x00	; 0
    692a:	11 23       	and	r17, r17
    692c:	09 f4       	brne	.+2      	; 0x6930 <portExCS+0xa8>
    692e:	89 c0       	rjmp	.+274    	; 0x6a42 <portExCS+0x1ba>
	{
		_delay_ms(__us / 1000.0);
    6930:	69 81       	ldd	r22, Y+1	; 0x01
    6932:	7a 81       	ldd	r23, Y+2	; 0x02
    6934:	8b 81       	ldd	r24, Y+3	; 0x03
    6936:	9c 81       	ldd	r25, Y+4	; 0x04
    6938:	20 e0       	ldi	r18, 0x00	; 0
    693a:	30 e0       	ldi	r19, 0x00	; 0
    693c:	4a e7       	ldi	r20, 0x7A	; 122
    693e:	54 e4       	ldi	r21, 0x44	; 68
    6940:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
    6944:	dc 01       	movw	r26, r24
    6946:	cb 01       	movw	r24, r22
    6948:	8a 87       	std	Y+10, r24	; 0x0a
    694a:	9b 87       	std	Y+11, r25	; 0x0b
    694c:	ac 87       	std	Y+12, r26	; 0x0c
    694e:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6950:	6a 85       	ldd	r22, Y+10	; 0x0a
    6952:	7b 85       	ldd	r23, Y+11	; 0x0b
    6954:	8c 85       	ldd	r24, Y+12	; 0x0c
    6956:	9d 85       	ldd	r25, Y+13	; 0x0d
    6958:	20 e0       	ldi	r18, 0x00	; 0
    695a:	30 e0       	ldi	r19, 0x00	; 0
    695c:	4a ef       	ldi	r20, 0xFA	; 250
    695e:	55 e4       	ldi	r21, 0x45	; 69
    6960:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    6964:	dc 01       	movw	r26, r24
    6966:	cb 01       	movw	r24, r22
    6968:	8e 87       	std	Y+14, r24	; 0x0e
    696a:	9f 87       	std	Y+15, r25	; 0x0f
    696c:	a8 8b       	std	Y+16, r26	; 0x10
    696e:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    6970:	11 e0       	ldi	r17, 0x01	; 1
    6972:	6e 85       	ldd	r22, Y+14	; 0x0e
    6974:	7f 85       	ldd	r23, Y+15	; 0x0f
    6976:	88 89       	ldd	r24, Y+16	; 0x10
    6978:	99 89       	ldd	r25, Y+17	; 0x11
    697a:	20 e0       	ldi	r18, 0x00	; 0
    697c:	30 e0       	ldi	r19, 0x00	; 0
    697e:	40 e8       	ldi	r20, 0x80	; 128
    6980:	5f e3       	ldi	r21, 0x3F	; 63
    6982:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    6986:	88 23       	and	r24, r24
    6988:	0c f0       	brlt	.+2      	; 0x698c <portExCS+0x104>
    698a:	10 e0       	ldi	r17, 0x00	; 0
    698c:	11 23       	and	r17, r17
    698e:	29 f0       	breq	.+10     	; 0x699a <portExCS+0x112>
		__ticks = 1;
    6990:	81 e0       	ldi	r24, 0x01	; 1
    6992:	90 e0       	ldi	r25, 0x00	; 0
    6994:	8a 8b       	std	Y+18, r24	; 0x12
    6996:	9b 8b       	std	Y+19, r25	; 0x13
    6998:	46 c0       	rjmp	.+140    	; 0x6a26 <portExCS+0x19e>
	else if (__tmp > 65535)
    699a:	11 e0       	ldi	r17, 0x01	; 1
    699c:	6e 85       	ldd	r22, Y+14	; 0x0e
    699e:	7f 85       	ldd	r23, Y+15	; 0x0f
    69a0:	88 89       	ldd	r24, Y+16	; 0x10
    69a2:	99 89       	ldd	r25, Y+17	; 0x11
    69a4:	20 e0       	ldi	r18, 0x00	; 0
    69a6:	3f ef       	ldi	r19, 0xFF	; 255
    69a8:	4f e7       	ldi	r20, 0x7F	; 127
    69aa:	57 e4       	ldi	r21, 0x47	; 71
    69ac:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    69b0:	18 16       	cp	r1, r24
    69b2:	0c f0       	brlt	.+2      	; 0x69b6 <portExCS+0x12e>
    69b4:	10 e0       	ldi	r17, 0x00	; 0
    69b6:	11 23       	and	r17, r17
    69b8:	61 f1       	breq	.+88     	; 0x6a12 <portExCS+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    69ba:	6a 85       	ldd	r22, Y+10	; 0x0a
    69bc:	7b 85       	ldd	r23, Y+11	; 0x0b
    69be:	8c 85       	ldd	r24, Y+12	; 0x0c
    69c0:	9d 85       	ldd	r25, Y+13	; 0x0d
    69c2:	20 e0       	ldi	r18, 0x00	; 0
    69c4:	30 e0       	ldi	r19, 0x00	; 0
    69c6:	40 e2       	ldi	r20, 0x20	; 32
    69c8:	51 e4       	ldi	r21, 0x41	; 65
    69ca:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    69ce:	dc 01       	movw	r26, r24
    69d0:	cb 01       	movw	r24, r22
    69d2:	bc 01       	movw	r22, r24
    69d4:	cd 01       	movw	r24, r26
    69d6:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    69da:	dc 01       	movw	r26, r24
    69dc:	cb 01       	movw	r24, r22
    69de:	8a 8b       	std	Y+18, r24	; 0x12
    69e0:	9b 8b       	std	Y+19, r25	; 0x13
    69e2:	12 c0       	rjmp	.+36     	; 0x6a08 <portExCS+0x180>
    69e4:	80 e2       	ldi	r24, 0x20	; 32
    69e6:	93 e0       	ldi	r25, 0x03	; 3
    69e8:	8c 8b       	std	Y+20, r24	; 0x14
    69ea:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    69ec:	8c 89       	ldd	r24, Y+20	; 0x14
    69ee:	9d 89       	ldd	r25, Y+21	; 0x15
    69f0:	8c 01       	movw	r16, r24
    69f2:	c8 01       	movw	r24, r16
    69f4:	01 97       	sbiw	r24, 0x01	; 1
    69f6:	f1 f7       	brne	.-4      	; 0x69f4 <portExCS+0x16c>
    69f8:	8c 01       	movw	r16, r24
    69fa:	0c 8b       	std	Y+20, r16	; 0x14
    69fc:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    69fe:	8a 89       	ldd	r24, Y+18	; 0x12
    6a00:	9b 89       	ldd	r25, Y+19	; 0x13
    6a02:	01 97       	sbiw	r24, 0x01	; 1
    6a04:	8a 8b       	std	Y+18, r24	; 0x12
    6a06:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6a08:	8a 89       	ldd	r24, Y+18	; 0x12
    6a0a:	9b 89       	ldd	r25, Y+19	; 0x13
    6a0c:	00 97       	sbiw	r24, 0x00	; 0
    6a0e:	51 f7       	brne	.-44     	; 0x69e4 <portExCS+0x15c>
    6a10:	28 c0       	rjmp	.+80     	; 0x6a62 <portExCS+0x1da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6a12:	6e 85       	ldd	r22, Y+14	; 0x0e
    6a14:	7f 85       	ldd	r23, Y+15	; 0x0f
    6a16:	88 89       	ldd	r24, Y+16	; 0x10
    6a18:	99 89       	ldd	r25, Y+17	; 0x11
    6a1a:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    6a1e:	dc 01       	movw	r26, r24
    6a20:	cb 01       	movw	r24, r22
    6a22:	8a 8b       	std	Y+18, r24	; 0x12
    6a24:	9b 8b       	std	Y+19, r25	; 0x13
    6a26:	8a 89       	ldd	r24, Y+18	; 0x12
    6a28:	9b 89       	ldd	r25, Y+19	; 0x13
    6a2a:	8e 8b       	std	Y+22, r24	; 0x16
    6a2c:	9f 8b       	std	Y+23, r25	; 0x17
    6a2e:	8e 89       	ldd	r24, Y+22	; 0x16
    6a30:	9f 89       	ldd	r25, Y+23	; 0x17
    6a32:	8c 01       	movw	r16, r24
    6a34:	f8 01       	movw	r30, r16
    6a36:	31 97       	sbiw	r30, 0x01	; 1
    6a38:	f1 f7       	brne	.-4      	; 0x6a36 <portExCS+0x1ae>
    6a3a:	8f 01       	movw	r16, r30
    6a3c:	0e 8b       	std	Y+22, r16	; 0x16
    6a3e:	1f 8b       	std	Y+23, r17	; 0x17
    6a40:	10 c0       	rjmp	.+32     	; 0x6a62 <portExCS+0x1da>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6a42:	6d 81       	ldd	r22, Y+5	; 0x05
    6a44:	7e 81       	ldd	r23, Y+6	; 0x06
    6a46:	8f 81       	ldd	r24, Y+7	; 0x07
    6a48:	98 85       	ldd	r25, Y+8	; 0x08
    6a4a:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    6a4e:	dc 01       	movw	r26, r24
    6a50:	cb 01       	movw	r24, r22
    6a52:	89 87       	std	Y+9, r24	; 0x09
    6a54:	89 85       	ldd	r24, Y+9	; 0x09
    6a56:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6a58:	88 8d       	ldd	r24, Y+24	; 0x18
    6a5a:	18 2f       	mov	r17, r24
    6a5c:	1a 95       	dec	r17
    6a5e:	f1 f7       	brne	.-4      	; 0x6a5c <portExCS+0x1d4>
    6a60:	18 8f       	std	Y+24, r17	; 0x18
	}
	_delay_us(10);
}
    6a62:	69 96       	adiw	r28, 0x19	; 25
    6a64:	cd bf       	out	0x3d, r28	; 61
    6a66:	de bf       	out	0x3e, r29	; 62
    6a68:	df 91       	pop	r29
    6a6a:	cf 91       	pop	r28
    6a6c:	1f 91       	pop	r17
    6a6e:	0f 91       	pop	r16
    6a70:	08 95       	ret

00006a72 <PortEx_DIRSET>:

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    6a72:	cf 93       	push	r28
    6a74:	df 93       	push	r29
    6a76:	00 d0       	rcall	.+0      	; 0x6a78 <PortEx_DIRSET+0x6>
    6a78:	cd b7       	in	r28, 0x3d	; 61
    6a7a:	de b7       	in	r29, 0x3e	; 62
    6a7c:	8a 83       	std	Y+2, r24	; 0x02
    6a7e:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6a80:	80 e0       	ldi	r24, 0x00	; 0
    6a82:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
	SPICS(TRUE);
    6a86:	81 e0       	ldi	r24, 0x01	; 1
    6a88:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	portExCS(TRUE);
    6a8c:	81 e0       	ldi	r24, 0x01	; 1
    6a8e:	0e 94 44 34 	call	0x6888	; 0x6888 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    6a92:	8b 81       	ldd	r24, Y+3	; 0x03
    6a94:	88 23       	and	r24, r24
    6a96:	39 f0       	breq	.+14     	; 0x6aa6 <PortEx_DIRSET+0x34>
    6a98:	90 91 77 50 	lds	r25, 0x5077
    6a9c:	8a 81       	ldd	r24, Y+2	; 0x02
    6a9e:	89 2b       	or	r24, r25
    6aa0:	80 93 77 50 	sts	0x5077, r24
    6aa4:	06 c0       	rjmp	.+12     	; 0x6ab2 <PortEx_DIRSET+0x40>
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    6aa6:	90 91 d2 50 	lds	r25, 0x50D2
    6aaa:	8a 81       	ldd	r24, Y+2	; 0x02
    6aac:	89 2b       	or	r24, r25
    6aae:	80 93 d2 50 	sts	0x50D2, r24
	
	SPIBuffer[0] = PS_WRITE;
    6ab2:	80 e4       	ldi	r24, 0x40	; 64
    6ab4:	80 93 66 50 	sts	0x5066, r24
	if(bank) {
    6ab8:	8b 81       	ldd	r24, Y+3	; 0x03
    6aba:	88 23       	and	r24, r24
    6abc:	41 f0       	breq	.+16     	; 0x6ace <PortEx_DIRSET+0x5c>
		SPIBuffer[1]=PS_IODIRA;
    6abe:	10 92 67 50 	sts	0x5067, r1
		SPIBuffer[2] = ~bankA_DIR; 
    6ac2:	80 91 77 50 	lds	r24, 0x5077
    6ac6:	80 95       	com	r24
    6ac8:	80 93 68 50 	sts	0x5068, r24
    6acc:	08 c0       	rjmp	.+16     	; 0x6ade <PortEx_DIRSET+0x6c>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    6ace:	81 e0       	ldi	r24, 0x01	; 1
    6ad0:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = ~bankB_DIR;
    6ad4:	80 91 d2 50 	lds	r24, 0x50D2
    6ad8:	80 95       	com	r24
    6ada:	80 93 68 50 	sts	0x5068, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6ade:	19 82       	std	Y+1, r1	; 0x01
    6ae0:	1b c0       	rjmp	.+54     	; 0x6b18 <PortEx_DIRSET+0xa6>
		SPIC.DATA = SPIBuffer[bufIndex];
    6ae2:	80 ec       	ldi	r24, 0xC0	; 192
    6ae4:	98 e0       	ldi	r25, 0x08	; 8
    6ae6:	29 81       	ldd	r18, Y+1	; 0x01
    6ae8:	22 2f       	mov	r18, r18
    6aea:	30 e0       	ldi	r19, 0x00	; 0
    6aec:	2a 59       	subi	r18, 0x9A	; 154
    6aee:	3f 4a       	sbci	r19, 0xAF	; 175
    6af0:	f9 01       	movw	r30, r18
    6af2:	20 81       	ld	r18, Z
    6af4:	fc 01       	movw	r30, r24
    6af6:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    6af8:	00 00       	nop
    6afa:	80 ec       	ldi	r24, 0xC0	; 192
    6afc:	98 e0       	ldi	r25, 0x08	; 8
    6afe:	fc 01       	movw	r30, r24
    6b00:	82 81       	ldd	r24, Z+2	; 0x02
    6b02:	88 23       	and	r24, r24
    6b04:	d4 f7       	brge	.-12     	; 0x6afa <PortEx_DIRSET+0x88>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    6b06:	80 ec       	ldi	r24, 0xC0	; 192
    6b08:	98 e0       	ldi	r25, 0x08	; 8
    6b0a:	fc 01       	movw	r30, r24
    6b0c:	83 81       	ldd	r24, Z+3	; 0x03
    6b0e:	80 93 72 50 	sts	0x5072, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6b12:	89 81       	ldd	r24, Y+1	; 0x01
    6b14:	8f 5f       	subi	r24, 0xFF	; 255
    6b16:	89 83       	std	Y+1, r24	; 0x01
    6b18:	89 81       	ldd	r24, Y+1	; 0x01
    6b1a:	83 30       	cpi	r24, 0x03	; 3
    6b1c:	10 f3       	brcs	.-60     	; 0x6ae2 <PortEx_DIRSET+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    6b1e:	80 e0       	ldi	r24, 0x00	; 0
    6b20:	0e 94 44 34 	call	0x6888	; 0x6888 <portExCS>
	SPICS(FALSE);
    6b24:	80 e0       	ldi	r24, 0x00	; 0
    6b26:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	SPIDisable();
    6b2a:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>


}
    6b2e:	23 96       	adiw	r28, 0x03	; 3
    6b30:	cd bf       	out	0x3d, r28	; 61
    6b32:	de bf       	out	0x3e, r29	; 62
    6b34:	df 91       	pop	r29
    6b36:	cf 91       	pop	r28
    6b38:	08 95       	ret

00006b3a <PortEx_DIRCLR>:

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    6b3a:	cf 93       	push	r28
    6b3c:	df 93       	push	r29
    6b3e:	00 d0       	rcall	.+0      	; 0x6b40 <PortEx_DIRCLR+0x6>
    6b40:	cd b7       	in	r28, 0x3d	; 61
    6b42:	de b7       	in	r29, 0x3e	; 62
    6b44:	8a 83       	std	Y+2, r24	; 0x02
    6b46:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6b48:	80 e0       	ldi	r24, 0x00	; 0
    6b4a:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
	SPICS(TRUE);
    6b4e:	81 e0       	ldi	r24, 0x01	; 1
    6b50:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	portExCS(TRUE);
    6b54:	81 e0       	ldi	r24, 0x01	; 1
    6b56:	0e 94 44 34 	call	0x6888	; 0x6888 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    6b5a:	8b 81       	ldd	r24, Y+3	; 0x03
    6b5c:	88 23       	and	r24, r24
    6b5e:	49 f0       	breq	.+18     	; 0x6b72 <PortEx_DIRCLR+0x38>
    6b60:	80 91 77 50 	lds	r24, 0x5077
    6b64:	98 2f       	mov	r25, r24
    6b66:	90 95       	com	r25
    6b68:	8a 81       	ldd	r24, Y+2	; 0x02
    6b6a:	89 23       	and	r24, r25
    6b6c:	80 93 77 50 	sts	0x5077, r24
    6b70:	08 c0       	rjmp	.+16     	; 0x6b82 <PortEx_DIRCLR+0x48>
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    6b72:	80 91 d2 50 	lds	r24, 0x50D2
    6b76:	98 2f       	mov	r25, r24
    6b78:	90 95       	com	r25
    6b7a:	8a 81       	ldd	r24, Y+2	; 0x02
    6b7c:	89 23       	and	r24, r25
    6b7e:	80 93 d2 50 	sts	0x50D2, r24
	
	SPIBuffer[0] = PS_WRITE;
    6b82:	80 e4       	ldi	r24, 0x40	; 64
    6b84:	80 93 66 50 	sts	0x5066, r24
	if(bank) {
    6b88:	8b 81       	ldd	r24, Y+3	; 0x03
    6b8a:	88 23       	and	r24, r24
    6b8c:	41 f0       	breq	.+16     	; 0x6b9e <PortEx_DIRCLR+0x64>
		SPIBuffer[1]=PS_IODIRA;
    6b8e:	10 92 67 50 	sts	0x5067, r1
		SPIBuffer[2] = ~bankA_DIR; 
    6b92:	80 91 77 50 	lds	r24, 0x5077
    6b96:	80 95       	com	r24
    6b98:	80 93 68 50 	sts	0x5068, r24
    6b9c:	08 c0       	rjmp	.+16     	; 0x6bae <PortEx_DIRCLR+0x74>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    6b9e:	81 e0       	ldi	r24, 0x01	; 1
    6ba0:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = ~bankB_DIR;
    6ba4:	80 91 d2 50 	lds	r24, 0x50D2
    6ba8:	80 95       	com	r24
    6baa:	80 93 68 50 	sts	0x5068, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6bae:	19 82       	std	Y+1, r1	; 0x01
    6bb0:	1b c0       	rjmp	.+54     	; 0x6be8 <PortEx_DIRCLR+0xae>
		SPIC.DATA = SPIBuffer[bufIndex];
    6bb2:	80 ec       	ldi	r24, 0xC0	; 192
    6bb4:	98 e0       	ldi	r25, 0x08	; 8
    6bb6:	29 81       	ldd	r18, Y+1	; 0x01
    6bb8:	22 2f       	mov	r18, r18
    6bba:	30 e0       	ldi	r19, 0x00	; 0
    6bbc:	2a 59       	subi	r18, 0x9A	; 154
    6bbe:	3f 4a       	sbci	r19, 0xAF	; 175
    6bc0:	f9 01       	movw	r30, r18
    6bc2:	20 81       	ld	r18, Z
    6bc4:	fc 01       	movw	r30, r24
    6bc6:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6bc8:	00 00       	nop
    6bca:	80 ec       	ldi	r24, 0xC0	; 192
    6bcc:	98 e0       	ldi	r25, 0x08	; 8
    6bce:	fc 01       	movw	r30, r24
    6bd0:	82 81       	ldd	r24, Z+2	; 0x02
    6bd2:	88 23       	and	r24, r24
    6bd4:	d4 f7       	brge	.-12     	; 0x6bca <PortEx_DIRCLR+0x90>
		SPIBuffer[12] = SPIC.DATA;
    6bd6:	80 ec       	ldi	r24, 0xC0	; 192
    6bd8:	98 e0       	ldi	r25, 0x08	; 8
    6bda:	fc 01       	movw	r30, r24
    6bdc:	83 81       	ldd	r24, Z+3	; 0x03
    6bde:	80 93 72 50 	sts	0x5072, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6be2:	89 81       	ldd	r24, Y+1	; 0x01
    6be4:	8f 5f       	subi	r24, 0xFF	; 255
    6be6:	89 83       	std	Y+1, r24	; 0x01
    6be8:	89 81       	ldd	r24, Y+1	; 0x01
    6bea:	83 30       	cpi	r24, 0x03	; 3
    6bec:	10 f3       	brcs	.-60     	; 0x6bb2 <PortEx_DIRCLR+0x78>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6bee:	80 e0       	ldi	r24, 0x00	; 0
    6bf0:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	portExCS(FALSE);
    6bf4:	80 e0       	ldi	r24, 0x00	; 0
    6bf6:	0e 94 44 34 	call	0x6888	; 0x6888 <portExCS>
	SPIDisable();
    6bfa:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>
}
    6bfe:	23 96       	adiw	r28, 0x03	; 3
    6c00:	cd bf       	out	0x3d, r28	; 61
    6c02:	de bf       	out	0x3e, r29	; 62
    6c04:	df 91       	pop	r29
    6c06:	cf 91       	pop	r28
    6c08:	08 95       	ret

00006c0a <PortEx_OUTSET>:

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    6c0a:	cf 93       	push	r28
    6c0c:	df 93       	push	r29
    6c0e:	00 d0       	rcall	.+0      	; 0x6c10 <PortEx_OUTSET+0x6>
    6c10:	cd b7       	in	r28, 0x3d	; 61
    6c12:	de b7       	in	r29, 0x3e	; 62
    6c14:	8a 83       	std	Y+2, r24	; 0x02
    6c16:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6c18:	80 e0       	ldi	r24, 0x00	; 0
    6c1a:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
	SPICS(TRUE);
    6c1e:	81 e0       	ldi	r24, 0x01	; 1
    6c20:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	portExCS(TRUE);
    6c24:	81 e0       	ldi	r24, 0x01	; 1
    6c26:	0e 94 44 34 	call	0x6888	; 0x6888 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    6c2a:	8b 81       	ldd	r24, Y+3	; 0x03
    6c2c:	88 23       	and	r24, r24
    6c2e:	39 f0       	breq	.+14     	; 0x6c3e <PortEx_OUTSET+0x34>
    6c30:	90 91 d7 23 	lds	r25, 0x23D7
    6c34:	8a 81       	ldd	r24, Y+2	; 0x02
    6c36:	89 2b       	or	r24, r25
    6c38:	80 93 d7 23 	sts	0x23D7, r24
    6c3c:	06 c0       	rjmp	.+12     	; 0x6c4a <PortEx_OUTSET+0x40>
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    6c3e:	90 91 7f 50 	lds	r25, 0x507F
    6c42:	8a 81       	ldd	r24, Y+2	; 0x02
    6c44:	89 2b       	or	r24, r25
    6c46:	80 93 7f 50 	sts	0x507F, r24
	
	SPIBuffer[0] = PS_WRITE;
    6c4a:	80 e4       	ldi	r24, 0x40	; 64
    6c4c:	80 93 66 50 	sts	0x5066, r24
	if(bank) {
    6c50:	8b 81       	ldd	r24, Y+3	; 0x03
    6c52:	88 23       	and	r24, r24
    6c54:	41 f0       	breq	.+16     	; 0x6c66 <PortEx_OUTSET+0x5c>
		SPIBuffer[1]=PS_OLATA;
    6c56:	84 e1       	ldi	r24, 0x14	; 20
    6c58:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = bankA_OUT;
    6c5c:	80 91 d7 23 	lds	r24, 0x23D7
    6c60:	80 93 68 50 	sts	0x5068, r24
    6c64:	07 c0       	rjmp	.+14     	; 0x6c74 <PortEx_OUTSET+0x6a>
	} else {
		SPIBuffer[1]=PS_OLATB;
    6c66:	85 e1       	ldi	r24, 0x15	; 21
    6c68:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = bankB_OUT; 
    6c6c:	80 91 7f 50 	lds	r24, 0x507F
    6c70:	80 93 68 50 	sts	0x5068, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6c74:	19 82       	std	Y+1, r1	; 0x01
    6c76:	1b c0       	rjmp	.+54     	; 0x6cae <PortEx_OUTSET+0xa4>
		SPIC.DATA = SPIBuffer[bufIndex];
    6c78:	80 ec       	ldi	r24, 0xC0	; 192
    6c7a:	98 e0       	ldi	r25, 0x08	; 8
    6c7c:	29 81       	ldd	r18, Y+1	; 0x01
    6c7e:	22 2f       	mov	r18, r18
    6c80:	30 e0       	ldi	r19, 0x00	; 0
    6c82:	2a 59       	subi	r18, 0x9A	; 154
    6c84:	3f 4a       	sbci	r19, 0xAF	; 175
    6c86:	f9 01       	movw	r30, r18
    6c88:	20 81       	ld	r18, Z
    6c8a:	fc 01       	movw	r30, r24
    6c8c:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6c8e:	00 00       	nop
    6c90:	80 ec       	ldi	r24, 0xC0	; 192
    6c92:	98 e0       	ldi	r25, 0x08	; 8
    6c94:	fc 01       	movw	r30, r24
    6c96:	82 81       	ldd	r24, Z+2	; 0x02
    6c98:	88 23       	and	r24, r24
    6c9a:	d4 f7       	brge	.-12     	; 0x6c90 <PortEx_OUTSET+0x86>
		SPIBuffer[12] = SPIC.DATA;
    6c9c:	80 ec       	ldi	r24, 0xC0	; 192
    6c9e:	98 e0       	ldi	r25, 0x08	; 8
    6ca0:	fc 01       	movw	r30, r24
    6ca2:	83 81       	ldd	r24, Z+3	; 0x03
    6ca4:	80 93 72 50 	sts	0x5072, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6ca8:	89 81       	ldd	r24, Y+1	; 0x01
    6caa:	8f 5f       	subi	r24, 0xFF	; 255
    6cac:	89 83       	std	Y+1, r24	; 0x01
    6cae:	89 81       	ldd	r24, Y+1	; 0x01
    6cb0:	83 30       	cpi	r24, 0x03	; 3
    6cb2:	10 f3       	brcs	.-60     	; 0x6c78 <PortEx_OUTSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6cb4:	80 e0       	ldi	r24, 0x00	; 0
    6cb6:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	portExCS(FALSE);
    6cba:	80 e0       	ldi	r24, 0x00	; 0
    6cbc:	0e 94 44 34 	call	0x6888	; 0x6888 <portExCS>
	SPIDisable();
    6cc0:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>
}
    6cc4:	23 96       	adiw	r28, 0x03	; 3
    6cc6:	cd bf       	out	0x3d, r28	; 61
    6cc8:	de bf       	out	0x3e, r29	; 62
    6cca:	df 91       	pop	r29
    6ccc:	cf 91       	pop	r28
    6cce:	08 95       	ret

00006cd0 <PortEx_OUTCLR>:


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    6cd0:	cf 93       	push	r28
    6cd2:	df 93       	push	r29
    6cd4:	00 d0       	rcall	.+0      	; 0x6cd6 <PortEx_OUTCLR+0x6>
    6cd6:	cd b7       	in	r28, 0x3d	; 61
    6cd8:	de b7       	in	r29, 0x3e	; 62
    6cda:	8a 83       	std	Y+2, r24	; 0x02
    6cdc:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6cde:	80 e0       	ldi	r24, 0x00	; 0
    6ce0:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
	SPICS(TRUE);
    6ce4:	81 e0       	ldi	r24, 0x01	; 1
    6ce6:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	portExCS(TRUE);
    6cea:	81 e0       	ldi	r24, 0x01	; 1
    6cec:	0e 94 44 34 	call	0x6888	; 0x6888 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    6cf0:	8b 81       	ldd	r24, Y+3	; 0x03
    6cf2:	88 23       	and	r24, r24
    6cf4:	49 f0       	breq	.+18     	; 0x6d08 <PortEx_OUTCLR+0x38>
    6cf6:	8a 81       	ldd	r24, Y+2	; 0x02
    6cf8:	98 2f       	mov	r25, r24
    6cfa:	90 95       	com	r25
    6cfc:	80 91 d7 23 	lds	r24, 0x23D7
    6d00:	89 23       	and	r24, r25
    6d02:	80 93 d7 23 	sts	0x23D7, r24
    6d06:	08 c0       	rjmp	.+16     	; 0x6d18 <PortEx_OUTCLR+0x48>
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    6d08:	8a 81       	ldd	r24, Y+2	; 0x02
    6d0a:	98 2f       	mov	r25, r24
    6d0c:	90 95       	com	r25
    6d0e:	80 91 7f 50 	lds	r24, 0x507F
    6d12:	89 23       	and	r24, r25
    6d14:	80 93 7f 50 	sts	0x507F, r24
	
	SPIBuffer[0] = PS_WRITE;
    6d18:	80 e4       	ldi	r24, 0x40	; 64
    6d1a:	80 93 66 50 	sts	0x5066, r24
	if(bank) {
    6d1e:	8b 81       	ldd	r24, Y+3	; 0x03
    6d20:	88 23       	and	r24, r24
    6d22:	41 f0       	breq	.+16     	; 0x6d34 <PortEx_OUTCLR+0x64>
		SPIBuffer[1]=PS_OLATA;
    6d24:	84 e1       	ldi	r24, 0x14	; 20
    6d26:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = bankA_OUT;
    6d2a:	80 91 d7 23 	lds	r24, 0x23D7
    6d2e:	80 93 68 50 	sts	0x5068, r24
    6d32:	07 c0       	rjmp	.+14     	; 0x6d42 <PortEx_OUTCLR+0x72>
	} else {
		SPIBuffer[1]=PS_OLATB;
    6d34:	85 e1       	ldi	r24, 0x15	; 21
    6d36:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = bankB_OUT; 
    6d3a:	80 91 7f 50 	lds	r24, 0x507F
    6d3e:	80 93 68 50 	sts	0x5068, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6d42:	19 82       	std	Y+1, r1	; 0x01
    6d44:	1b c0       	rjmp	.+54     	; 0x6d7c <PortEx_OUTCLR+0xac>
		SPIC.DATA = SPIBuffer[bufIndex];
    6d46:	80 ec       	ldi	r24, 0xC0	; 192
    6d48:	98 e0       	ldi	r25, 0x08	; 8
    6d4a:	29 81       	ldd	r18, Y+1	; 0x01
    6d4c:	22 2f       	mov	r18, r18
    6d4e:	30 e0       	ldi	r19, 0x00	; 0
    6d50:	2a 59       	subi	r18, 0x9A	; 154
    6d52:	3f 4a       	sbci	r19, 0xAF	; 175
    6d54:	f9 01       	movw	r30, r18
    6d56:	20 81       	ld	r18, Z
    6d58:	fc 01       	movw	r30, r24
    6d5a:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6d5c:	00 00       	nop
    6d5e:	80 ec       	ldi	r24, 0xC0	; 192
    6d60:	98 e0       	ldi	r25, 0x08	; 8
    6d62:	fc 01       	movw	r30, r24
    6d64:	82 81       	ldd	r24, Z+2	; 0x02
    6d66:	88 23       	and	r24, r24
    6d68:	d4 f7       	brge	.-12     	; 0x6d5e <PortEx_OUTCLR+0x8e>
		SPIBuffer[12] = SPIC.DATA;
    6d6a:	80 ec       	ldi	r24, 0xC0	; 192
    6d6c:	98 e0       	ldi	r25, 0x08	; 8
    6d6e:	fc 01       	movw	r30, r24
    6d70:	83 81       	ldd	r24, Z+3	; 0x03
    6d72:	80 93 72 50 	sts	0x5072, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6d76:	89 81       	ldd	r24, Y+1	; 0x01
    6d78:	8f 5f       	subi	r24, 0xFF	; 255
    6d7a:	89 83       	std	Y+1, r24	; 0x01
    6d7c:	89 81       	ldd	r24, Y+1	; 0x01
    6d7e:	83 30       	cpi	r24, 0x03	; 3
    6d80:	10 f3       	brcs	.-60     	; 0x6d46 <PortEx_OUTCLR+0x76>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6d82:	80 e0       	ldi	r24, 0x00	; 0
    6d84:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	portExCS(FALSE);
    6d88:	80 e0       	ldi	r24, 0x00	; 0
    6d8a:	0e 94 44 34 	call	0x6888	; 0x6888 <portExCS>
	SPIDisable();
    6d8e:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>
}
    6d92:	23 96       	adiw	r28, 0x03	; 3
    6d94:	cd bf       	out	0x3d, r28	; 61
    6d96:	de bf       	out	0x3e, r29	; 62
    6d98:	df 91       	pop	r29
    6d9a:	cf 91       	pop	r28
    6d9c:	08 95       	ret

00006d9e <Ext1Power>:
	SPIDisable();
}
*/


void Ext1Power(uint8_t on) {
    6d9e:	0f 93       	push	r16
    6da0:	1f 93       	push	r17
    6da2:	cf 93       	push	r28
    6da4:	df 93       	push	r29
    6da6:	cd b7       	in	r28, 0x3d	; 61
    6da8:	de b7       	in	r29, 0x3e	; 62
    6daa:	2f 97       	sbiw	r28, 0x0f	; 15
    6dac:	cd bf       	out	0x3d, r28	; 61
    6dae:	de bf       	out	0x3e, r29	; 62
    6db0:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    6db2:	8f 85       	ldd	r24, Y+15	; 0x0f
    6db4:	88 23       	and	r24, r24
    6db6:	09 f4       	brne	.+2      	; 0x6dba <Ext1Power+0x1c>
    6db8:	8b c0       	rjmp	.+278    	; 0x6ed0 <Ext1Power+0x132>
		PORTF.DIRSET = PIN5_bm;
    6dba:	80 ea       	ldi	r24, 0xA0	; 160
    6dbc:	96 e0       	ldi	r25, 0x06	; 6
    6dbe:	20 e2       	ldi	r18, 0x20	; 32
    6dc0:	fc 01       	movw	r30, r24
    6dc2:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN5_bm;
    6dc4:	80 ea       	ldi	r24, 0xA0	; 160
    6dc6:	96 e0       	ldi	r25, 0x06	; 6
    6dc8:	20 e2       	ldi	r18, 0x20	; 32
    6dca:	fc 01       	movw	r30, r24
    6dcc:	25 83       	std	Z+5, r18	; 0x05
    6dce:	80 e0       	ldi	r24, 0x00	; 0
    6dd0:	90 e0       	ldi	r25, 0x00	; 0
    6dd2:	a8 ec       	ldi	r26, 0xC8	; 200
    6dd4:	b2 e4       	ldi	r27, 0x42	; 66
    6dd6:	89 83       	std	Y+1, r24	; 0x01
    6dd8:	9a 83       	std	Y+2, r25	; 0x02
    6dda:	ab 83       	std	Y+3, r26	; 0x03
    6ddc:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6dde:	69 81       	ldd	r22, Y+1	; 0x01
    6de0:	7a 81       	ldd	r23, Y+2	; 0x02
    6de2:	8b 81       	ldd	r24, Y+3	; 0x03
    6de4:	9c 81       	ldd	r25, Y+4	; 0x04
    6de6:	20 e0       	ldi	r18, 0x00	; 0
    6de8:	30 e0       	ldi	r19, 0x00	; 0
    6dea:	4a ef       	ldi	r20, 0xFA	; 250
    6dec:	55 e4       	ldi	r21, 0x45	; 69
    6dee:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    6df2:	dc 01       	movw	r26, r24
    6df4:	cb 01       	movw	r24, r22
    6df6:	8d 83       	std	Y+5, r24	; 0x05
    6df8:	9e 83       	std	Y+6, r25	; 0x06
    6dfa:	af 83       	std	Y+7, r26	; 0x07
    6dfc:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6dfe:	11 e0       	ldi	r17, 0x01	; 1
    6e00:	6d 81       	ldd	r22, Y+5	; 0x05
    6e02:	7e 81       	ldd	r23, Y+6	; 0x06
    6e04:	8f 81       	ldd	r24, Y+7	; 0x07
    6e06:	98 85       	ldd	r25, Y+8	; 0x08
    6e08:	20 e0       	ldi	r18, 0x00	; 0
    6e0a:	30 e0       	ldi	r19, 0x00	; 0
    6e0c:	40 e8       	ldi	r20, 0x80	; 128
    6e0e:	5f e3       	ldi	r21, 0x3F	; 63
    6e10:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    6e14:	88 23       	and	r24, r24
    6e16:	0c f0       	brlt	.+2      	; 0x6e1a <Ext1Power+0x7c>
    6e18:	10 e0       	ldi	r17, 0x00	; 0
    6e1a:	11 23       	and	r17, r17
    6e1c:	29 f0       	breq	.+10     	; 0x6e28 <Ext1Power+0x8a>
		__ticks = 1;
    6e1e:	81 e0       	ldi	r24, 0x01	; 1
    6e20:	90 e0       	ldi	r25, 0x00	; 0
    6e22:	89 87       	std	Y+9, r24	; 0x09
    6e24:	9a 87       	std	Y+10, r25	; 0x0a
    6e26:	46 c0       	rjmp	.+140    	; 0x6eb4 <Ext1Power+0x116>
	else if (__tmp > 65535)
    6e28:	11 e0       	ldi	r17, 0x01	; 1
    6e2a:	6d 81       	ldd	r22, Y+5	; 0x05
    6e2c:	7e 81       	ldd	r23, Y+6	; 0x06
    6e2e:	8f 81       	ldd	r24, Y+7	; 0x07
    6e30:	98 85       	ldd	r25, Y+8	; 0x08
    6e32:	20 e0       	ldi	r18, 0x00	; 0
    6e34:	3f ef       	ldi	r19, 0xFF	; 255
    6e36:	4f e7       	ldi	r20, 0x7F	; 127
    6e38:	57 e4       	ldi	r21, 0x47	; 71
    6e3a:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    6e3e:	18 16       	cp	r1, r24
    6e40:	0c f0       	brlt	.+2      	; 0x6e44 <Ext1Power+0xa6>
    6e42:	10 e0       	ldi	r17, 0x00	; 0
    6e44:	11 23       	and	r17, r17
    6e46:	61 f1       	breq	.+88     	; 0x6ea0 <Ext1Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6e48:	69 81       	ldd	r22, Y+1	; 0x01
    6e4a:	7a 81       	ldd	r23, Y+2	; 0x02
    6e4c:	8b 81       	ldd	r24, Y+3	; 0x03
    6e4e:	9c 81       	ldd	r25, Y+4	; 0x04
    6e50:	20 e0       	ldi	r18, 0x00	; 0
    6e52:	30 e0       	ldi	r19, 0x00	; 0
    6e54:	40 e2       	ldi	r20, 0x20	; 32
    6e56:	51 e4       	ldi	r21, 0x41	; 65
    6e58:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    6e5c:	dc 01       	movw	r26, r24
    6e5e:	cb 01       	movw	r24, r22
    6e60:	bc 01       	movw	r22, r24
    6e62:	cd 01       	movw	r24, r26
    6e64:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    6e68:	dc 01       	movw	r26, r24
    6e6a:	cb 01       	movw	r24, r22
    6e6c:	89 87       	std	Y+9, r24	; 0x09
    6e6e:	9a 87       	std	Y+10, r25	; 0x0a
    6e70:	12 c0       	rjmp	.+36     	; 0x6e96 <Ext1Power+0xf8>
    6e72:	80 e2       	ldi	r24, 0x20	; 32
    6e74:	93 e0       	ldi	r25, 0x03	; 3
    6e76:	8b 87       	std	Y+11, r24	; 0x0b
    6e78:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6e7a:	8b 85       	ldd	r24, Y+11	; 0x0b
    6e7c:	9c 85       	ldd	r25, Y+12	; 0x0c
    6e7e:	8c 01       	movw	r16, r24
    6e80:	c8 01       	movw	r24, r16
    6e82:	01 97       	sbiw	r24, 0x01	; 1
    6e84:	f1 f7       	brne	.-4      	; 0x6e82 <Ext1Power+0xe4>
    6e86:	8c 01       	movw	r16, r24
    6e88:	0b 87       	std	Y+11, r16	; 0x0b
    6e8a:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6e8c:	89 85       	ldd	r24, Y+9	; 0x09
    6e8e:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e90:	01 97       	sbiw	r24, 0x01	; 1
    6e92:	89 87       	std	Y+9, r24	; 0x09
    6e94:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6e96:	89 85       	ldd	r24, Y+9	; 0x09
    6e98:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e9a:	00 97       	sbiw	r24, 0x00	; 0
    6e9c:	51 f7       	brne	.-44     	; 0x6e72 <Ext1Power+0xd4>
    6e9e:	22 c0       	rjmp	.+68     	; 0x6ee4 <Ext1Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6ea0:	6d 81       	ldd	r22, Y+5	; 0x05
    6ea2:	7e 81       	ldd	r23, Y+6	; 0x06
    6ea4:	8f 81       	ldd	r24, Y+7	; 0x07
    6ea6:	98 85       	ldd	r25, Y+8	; 0x08
    6ea8:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    6eac:	dc 01       	movw	r26, r24
    6eae:	cb 01       	movw	r24, r22
    6eb0:	89 87       	std	Y+9, r24	; 0x09
    6eb2:	9a 87       	std	Y+10, r25	; 0x0a
    6eb4:	89 85       	ldd	r24, Y+9	; 0x09
    6eb6:	9a 85       	ldd	r25, Y+10	; 0x0a
    6eb8:	8d 87       	std	Y+13, r24	; 0x0d
    6eba:	9e 87       	std	Y+14, r25	; 0x0e
    6ebc:	8d 85       	ldd	r24, Y+13	; 0x0d
    6ebe:	9e 85       	ldd	r25, Y+14	; 0x0e
    6ec0:	8c 01       	movw	r16, r24
    6ec2:	f8 01       	movw	r30, r16
    6ec4:	31 97       	sbiw	r30, 0x01	; 1
    6ec6:	f1 f7       	brne	.-4      	; 0x6ec4 <Ext1Power+0x126>
    6ec8:	8f 01       	movw	r16, r30
    6eca:	0d 87       	std	Y+13, r16	; 0x0d
    6ecc:	1e 87       	std	Y+14, r17	; 0x0e
    6ece:	0a c0       	rjmp	.+20     	; 0x6ee4 <Ext1Power+0x146>
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    6ed0:	80 ea       	ldi	r24, 0xA0	; 160
    6ed2:	96 e0       	ldi	r25, 0x06	; 6
    6ed4:	20 e2       	ldi	r18, 0x20	; 32
    6ed6:	fc 01       	movw	r30, r24
    6ed8:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    6eda:	80 ea       	ldi	r24, 0xA0	; 160
    6edc:	96 e0       	ldi	r25, 0x06	; 6
    6ede:	20 e2       	ldi	r18, 0x20	; 32
    6ee0:	fc 01       	movw	r30, r24
    6ee2:	22 83       	std	Z+2, r18	; 0x02
		//PortEx_OUTCLR(PIN3_bm, PS_BANKB);  //no need to write protect SDHC
	}
}
    6ee4:	2f 96       	adiw	r28, 0x0f	; 15
    6ee6:	cd bf       	out	0x3d, r28	; 61
    6ee8:	de bf       	out	0x3e, r29	; 62
    6eea:	df 91       	pop	r29
    6eec:	cf 91       	pop	r28
    6eee:	1f 91       	pop	r17
    6ef0:	0f 91       	pop	r16
    6ef2:	08 95       	ret

00006ef4 <Ext2Power>:

void Ext2Power(uint8_t on) {
    6ef4:	0f 93       	push	r16
    6ef6:	1f 93       	push	r17
    6ef8:	cf 93       	push	r28
    6efa:	df 93       	push	r29
    6efc:	cd b7       	in	r28, 0x3d	; 61
    6efe:	de b7       	in	r29, 0x3e	; 62
    6f00:	2f 97       	sbiw	r28, 0x0f	; 15
    6f02:	cd bf       	out	0x3d, r28	; 61
    6f04:	de bf       	out	0x3e, r29	; 62
    6f06:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    6f08:	8f 85       	ldd	r24, Y+15	; 0x0f
    6f0a:	88 23       	and	r24, r24
    6f0c:	09 f4       	brne	.+2      	; 0x6f10 <Ext2Power+0x1c>
    6f0e:	8b c0       	rjmp	.+278    	; 0x7026 <Ext2Power+0x132>
		PORTF.DIRSET = PIN6_bm;
    6f10:	80 ea       	ldi	r24, 0xA0	; 160
    6f12:	96 e0       	ldi	r25, 0x06	; 6
    6f14:	20 e4       	ldi	r18, 0x40	; 64
    6f16:	fc 01       	movw	r30, r24
    6f18:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN6_bm;
    6f1a:	80 ea       	ldi	r24, 0xA0	; 160
    6f1c:	96 e0       	ldi	r25, 0x06	; 6
    6f1e:	20 e4       	ldi	r18, 0x40	; 64
    6f20:	fc 01       	movw	r30, r24
    6f22:	25 83       	std	Z+5, r18	; 0x05
    6f24:	80 e0       	ldi	r24, 0x00	; 0
    6f26:	90 e0       	ldi	r25, 0x00	; 0
    6f28:	a8 ec       	ldi	r26, 0xC8	; 200
    6f2a:	b2 e4       	ldi	r27, 0x42	; 66
    6f2c:	89 83       	std	Y+1, r24	; 0x01
    6f2e:	9a 83       	std	Y+2, r25	; 0x02
    6f30:	ab 83       	std	Y+3, r26	; 0x03
    6f32:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6f34:	69 81       	ldd	r22, Y+1	; 0x01
    6f36:	7a 81       	ldd	r23, Y+2	; 0x02
    6f38:	8b 81       	ldd	r24, Y+3	; 0x03
    6f3a:	9c 81       	ldd	r25, Y+4	; 0x04
    6f3c:	20 e0       	ldi	r18, 0x00	; 0
    6f3e:	30 e0       	ldi	r19, 0x00	; 0
    6f40:	4a ef       	ldi	r20, 0xFA	; 250
    6f42:	55 e4       	ldi	r21, 0x45	; 69
    6f44:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    6f48:	dc 01       	movw	r26, r24
    6f4a:	cb 01       	movw	r24, r22
    6f4c:	8d 83       	std	Y+5, r24	; 0x05
    6f4e:	9e 83       	std	Y+6, r25	; 0x06
    6f50:	af 83       	std	Y+7, r26	; 0x07
    6f52:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6f54:	11 e0       	ldi	r17, 0x01	; 1
    6f56:	6d 81       	ldd	r22, Y+5	; 0x05
    6f58:	7e 81       	ldd	r23, Y+6	; 0x06
    6f5a:	8f 81       	ldd	r24, Y+7	; 0x07
    6f5c:	98 85       	ldd	r25, Y+8	; 0x08
    6f5e:	20 e0       	ldi	r18, 0x00	; 0
    6f60:	30 e0       	ldi	r19, 0x00	; 0
    6f62:	40 e8       	ldi	r20, 0x80	; 128
    6f64:	5f e3       	ldi	r21, 0x3F	; 63
    6f66:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    6f6a:	88 23       	and	r24, r24
    6f6c:	0c f0       	brlt	.+2      	; 0x6f70 <Ext2Power+0x7c>
    6f6e:	10 e0       	ldi	r17, 0x00	; 0
    6f70:	11 23       	and	r17, r17
    6f72:	29 f0       	breq	.+10     	; 0x6f7e <Ext2Power+0x8a>
		__ticks = 1;
    6f74:	81 e0       	ldi	r24, 0x01	; 1
    6f76:	90 e0       	ldi	r25, 0x00	; 0
    6f78:	89 87       	std	Y+9, r24	; 0x09
    6f7a:	9a 87       	std	Y+10, r25	; 0x0a
    6f7c:	46 c0       	rjmp	.+140    	; 0x700a <Ext2Power+0x116>
	else if (__tmp > 65535)
    6f7e:	11 e0       	ldi	r17, 0x01	; 1
    6f80:	6d 81       	ldd	r22, Y+5	; 0x05
    6f82:	7e 81       	ldd	r23, Y+6	; 0x06
    6f84:	8f 81       	ldd	r24, Y+7	; 0x07
    6f86:	98 85       	ldd	r25, Y+8	; 0x08
    6f88:	20 e0       	ldi	r18, 0x00	; 0
    6f8a:	3f ef       	ldi	r19, 0xFF	; 255
    6f8c:	4f e7       	ldi	r20, 0x7F	; 127
    6f8e:	57 e4       	ldi	r21, 0x47	; 71
    6f90:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    6f94:	18 16       	cp	r1, r24
    6f96:	0c f0       	brlt	.+2      	; 0x6f9a <Ext2Power+0xa6>
    6f98:	10 e0       	ldi	r17, 0x00	; 0
    6f9a:	11 23       	and	r17, r17
    6f9c:	61 f1       	breq	.+88     	; 0x6ff6 <Ext2Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6f9e:	69 81       	ldd	r22, Y+1	; 0x01
    6fa0:	7a 81       	ldd	r23, Y+2	; 0x02
    6fa2:	8b 81       	ldd	r24, Y+3	; 0x03
    6fa4:	9c 81       	ldd	r25, Y+4	; 0x04
    6fa6:	20 e0       	ldi	r18, 0x00	; 0
    6fa8:	30 e0       	ldi	r19, 0x00	; 0
    6faa:	40 e2       	ldi	r20, 0x20	; 32
    6fac:	51 e4       	ldi	r21, 0x41	; 65
    6fae:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    6fb2:	dc 01       	movw	r26, r24
    6fb4:	cb 01       	movw	r24, r22
    6fb6:	bc 01       	movw	r22, r24
    6fb8:	cd 01       	movw	r24, r26
    6fba:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    6fbe:	dc 01       	movw	r26, r24
    6fc0:	cb 01       	movw	r24, r22
    6fc2:	89 87       	std	Y+9, r24	; 0x09
    6fc4:	9a 87       	std	Y+10, r25	; 0x0a
    6fc6:	12 c0       	rjmp	.+36     	; 0x6fec <Ext2Power+0xf8>
    6fc8:	80 e2       	ldi	r24, 0x20	; 32
    6fca:	93 e0       	ldi	r25, 0x03	; 3
    6fcc:	8b 87       	std	Y+11, r24	; 0x0b
    6fce:	9c 87       	std	Y+12, r25	; 0x0c
    6fd0:	8b 85       	ldd	r24, Y+11	; 0x0b
    6fd2:	9c 85       	ldd	r25, Y+12	; 0x0c
    6fd4:	8c 01       	movw	r16, r24
    6fd6:	c8 01       	movw	r24, r16
    6fd8:	01 97       	sbiw	r24, 0x01	; 1
    6fda:	f1 f7       	brne	.-4      	; 0x6fd8 <Ext2Power+0xe4>
    6fdc:	8c 01       	movw	r16, r24
    6fde:	0b 87       	std	Y+11, r16	; 0x0b
    6fe0:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6fe2:	89 85       	ldd	r24, Y+9	; 0x09
    6fe4:	9a 85       	ldd	r25, Y+10	; 0x0a
    6fe6:	01 97       	sbiw	r24, 0x01	; 1
    6fe8:	89 87       	std	Y+9, r24	; 0x09
    6fea:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6fec:	89 85       	ldd	r24, Y+9	; 0x09
    6fee:	9a 85       	ldd	r25, Y+10	; 0x0a
    6ff0:	00 97       	sbiw	r24, 0x00	; 0
    6ff2:	51 f7       	brne	.-44     	; 0x6fc8 <Ext2Power+0xd4>
    6ff4:	22 c0       	rjmp	.+68     	; 0x703a <Ext2Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6ff6:	6d 81       	ldd	r22, Y+5	; 0x05
    6ff8:	7e 81       	ldd	r23, Y+6	; 0x06
    6ffa:	8f 81       	ldd	r24, Y+7	; 0x07
    6ffc:	98 85       	ldd	r25, Y+8	; 0x08
    6ffe:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7002:	dc 01       	movw	r26, r24
    7004:	cb 01       	movw	r24, r22
    7006:	89 87       	std	Y+9, r24	; 0x09
    7008:	9a 87       	std	Y+10, r25	; 0x0a
    700a:	89 85       	ldd	r24, Y+9	; 0x09
    700c:	9a 85       	ldd	r25, Y+10	; 0x0a
    700e:	8d 87       	std	Y+13, r24	; 0x0d
    7010:	9e 87       	std	Y+14, r25	; 0x0e
    7012:	8d 85       	ldd	r24, Y+13	; 0x0d
    7014:	9e 85       	ldd	r25, Y+14	; 0x0e
    7016:	8c 01       	movw	r16, r24
    7018:	f8 01       	movw	r30, r16
    701a:	31 97       	sbiw	r30, 0x01	; 1
    701c:	f1 f7       	brne	.-4      	; 0x701a <Ext2Power+0x126>
    701e:	8f 01       	movw	r16, r30
    7020:	0d 87       	std	Y+13, r16	; 0x0d
    7022:	1e 87       	std	Y+14, r17	; 0x0e
    7024:	0a c0       	rjmp	.+20     	; 0x703a <Ext2Power+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    7026:	80 ea       	ldi	r24, 0xA0	; 160
    7028:	96 e0       	ldi	r25, 0x06	; 6
    702a:	20 e4       	ldi	r18, 0x40	; 64
    702c:	fc 01       	movw	r30, r24
    702e:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    7030:	80 ea       	ldi	r24, 0xA0	; 160
    7032:	96 e0       	ldi	r25, 0x06	; 6
    7034:	20 e4       	ldi	r18, 0x40	; 64
    7036:	fc 01       	movw	r30, r24
    7038:	22 83       	std	Z+2, r18	; 0x02
	}
}
    703a:	2f 96       	adiw	r28, 0x0f	; 15
    703c:	cd bf       	out	0x3d, r28	; 61
    703e:	de bf       	out	0x3e, r29	; 62
    7040:	df 91       	pop	r29
    7042:	cf 91       	pop	r28
    7044:	1f 91       	pop	r17
    7046:	0f 91       	pop	r16
    7048:	08 95       	ret

0000704a <HVPower>:

void HVPower(uint8_t on) {
    704a:	0f 93       	push	r16
    704c:	1f 93       	push	r17
    704e:	cf 93       	push	r28
    7050:	df 93       	push	r29
    7052:	cd b7       	in	r28, 0x3d	; 61
    7054:	de b7       	in	r29, 0x3e	; 62
    7056:	a7 97       	sbiw	r28, 0x27	; 39
    7058:	cd bf       	out	0x3d, r28	; 61
    705a:	de bf       	out	0x3e, r29	; 62
    705c:	8f a3       	lds	r24, 0x5f
	if (on) {
    705e:	8f a1       	lds	r24, 0x4f
    7060:	88 23       	and	r24, r24
    7062:	09 f4       	brne	.+2      	; 0x7066 <HVPower+0x1c>
    7064:	8b c0       	rjmp	.+278    	; 0x717c <HVPower+0x132>
		PORTF.DIRSET = PIN7_bm;
    7066:	80 ea       	ldi	r24, 0xA0	; 160
    7068:	96 e0       	ldi	r25, 0x06	; 6
    706a:	20 e8       	ldi	r18, 0x80	; 128
    706c:	fc 01       	movw	r30, r24
    706e:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN7_bm;
    7070:	80 ea       	ldi	r24, 0xA0	; 160
    7072:	96 e0       	ldi	r25, 0x06	; 6
    7074:	20 e8       	ldi	r18, 0x80	; 128
    7076:	fc 01       	movw	r30, r24
    7078:	25 83       	std	Z+5, r18	; 0x05
    707a:	80 e0       	ldi	r24, 0x00	; 0
    707c:	90 e0       	ldi	r25, 0x00	; 0
    707e:	a8 ec       	ldi	r26, 0xC8	; 200
    7080:	b2 e4       	ldi	r27, 0x42	; 66
    7082:	89 83       	std	Y+1, r24	; 0x01
    7084:	9a 83       	std	Y+2, r25	; 0x02
    7086:	ab 83       	std	Y+3, r26	; 0x03
    7088:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    708a:	69 81       	ldd	r22, Y+1	; 0x01
    708c:	7a 81       	ldd	r23, Y+2	; 0x02
    708e:	8b 81       	ldd	r24, Y+3	; 0x03
    7090:	9c 81       	ldd	r25, Y+4	; 0x04
    7092:	20 e0       	ldi	r18, 0x00	; 0
    7094:	30 e0       	ldi	r19, 0x00	; 0
    7096:	4a ef       	ldi	r20, 0xFA	; 250
    7098:	55 e4       	ldi	r21, 0x45	; 69
    709a:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    709e:	dc 01       	movw	r26, r24
    70a0:	cb 01       	movw	r24, r22
    70a2:	8d 83       	std	Y+5, r24	; 0x05
    70a4:	9e 83       	std	Y+6, r25	; 0x06
    70a6:	af 83       	std	Y+7, r26	; 0x07
    70a8:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    70aa:	11 e0       	ldi	r17, 0x01	; 1
    70ac:	6d 81       	ldd	r22, Y+5	; 0x05
    70ae:	7e 81       	ldd	r23, Y+6	; 0x06
    70b0:	8f 81       	ldd	r24, Y+7	; 0x07
    70b2:	98 85       	ldd	r25, Y+8	; 0x08
    70b4:	20 e0       	ldi	r18, 0x00	; 0
    70b6:	30 e0       	ldi	r19, 0x00	; 0
    70b8:	40 e8       	ldi	r20, 0x80	; 128
    70ba:	5f e3       	ldi	r21, 0x3F	; 63
    70bc:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    70c0:	88 23       	and	r24, r24
    70c2:	0c f0       	brlt	.+2      	; 0x70c6 <HVPower+0x7c>
    70c4:	10 e0       	ldi	r17, 0x00	; 0
    70c6:	11 23       	and	r17, r17
    70c8:	29 f0       	breq	.+10     	; 0x70d4 <HVPower+0x8a>
		__ticks = 1;
    70ca:	81 e0       	ldi	r24, 0x01	; 1
    70cc:	90 e0       	ldi	r25, 0x00	; 0
    70ce:	89 87       	std	Y+9, r24	; 0x09
    70d0:	9a 87       	std	Y+10, r25	; 0x0a
    70d2:	46 c0       	rjmp	.+140    	; 0x7160 <HVPower+0x116>
	else if (__tmp > 65535)
    70d4:	11 e0       	ldi	r17, 0x01	; 1
    70d6:	6d 81       	ldd	r22, Y+5	; 0x05
    70d8:	7e 81       	ldd	r23, Y+6	; 0x06
    70da:	8f 81       	ldd	r24, Y+7	; 0x07
    70dc:	98 85       	ldd	r25, Y+8	; 0x08
    70de:	20 e0       	ldi	r18, 0x00	; 0
    70e0:	3f ef       	ldi	r19, 0xFF	; 255
    70e2:	4f e7       	ldi	r20, 0x7F	; 127
    70e4:	57 e4       	ldi	r21, 0x47	; 71
    70e6:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    70ea:	18 16       	cp	r1, r24
    70ec:	0c f0       	brlt	.+2      	; 0x70f0 <HVPower+0xa6>
    70ee:	10 e0       	ldi	r17, 0x00	; 0
    70f0:	11 23       	and	r17, r17
    70f2:	61 f1       	breq	.+88     	; 0x714c <HVPower+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    70f4:	69 81       	ldd	r22, Y+1	; 0x01
    70f6:	7a 81       	ldd	r23, Y+2	; 0x02
    70f8:	8b 81       	ldd	r24, Y+3	; 0x03
    70fa:	9c 81       	ldd	r25, Y+4	; 0x04
    70fc:	20 e0       	ldi	r18, 0x00	; 0
    70fe:	30 e0       	ldi	r19, 0x00	; 0
    7100:	40 e2       	ldi	r20, 0x20	; 32
    7102:	51 e4       	ldi	r21, 0x41	; 65
    7104:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    7108:	dc 01       	movw	r26, r24
    710a:	cb 01       	movw	r24, r22
    710c:	bc 01       	movw	r22, r24
    710e:	cd 01       	movw	r24, r26
    7110:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7114:	dc 01       	movw	r26, r24
    7116:	cb 01       	movw	r24, r22
    7118:	89 87       	std	Y+9, r24	; 0x09
    711a:	9a 87       	std	Y+10, r25	; 0x0a
    711c:	12 c0       	rjmp	.+36     	; 0x7142 <HVPower+0xf8>
    711e:	80 e2       	ldi	r24, 0x20	; 32
    7120:	93 e0       	ldi	r25, 0x03	; 3
    7122:	8b 87       	std	Y+11, r24	; 0x0b
    7124:	9c 87       	std	Y+12, r25	; 0x0c
    7126:	8b 85       	ldd	r24, Y+11	; 0x0b
    7128:	9c 85       	ldd	r25, Y+12	; 0x0c
    712a:	8c 01       	movw	r16, r24
    712c:	c8 01       	movw	r24, r16
    712e:	01 97       	sbiw	r24, 0x01	; 1
    7130:	f1 f7       	brne	.-4      	; 0x712e <HVPower+0xe4>
    7132:	8c 01       	movw	r16, r24
    7134:	0b 87       	std	Y+11, r16	; 0x0b
    7136:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7138:	89 85       	ldd	r24, Y+9	; 0x09
    713a:	9a 85       	ldd	r25, Y+10	; 0x0a
    713c:	01 97       	sbiw	r24, 0x01	; 1
    713e:	89 87       	std	Y+9, r24	; 0x09
    7140:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7142:	89 85       	ldd	r24, Y+9	; 0x09
    7144:	9a 85       	ldd	r25, Y+10	; 0x0a
    7146:	00 97       	sbiw	r24, 0x00	; 0
    7148:	51 f7       	brne	.-44     	; 0x711e <HVPower+0xd4>
    714a:	22 c0       	rjmp	.+68     	; 0x7190 <HVPower+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    714c:	6d 81       	ldd	r22, Y+5	; 0x05
    714e:	7e 81       	ldd	r23, Y+6	; 0x06
    7150:	8f 81       	ldd	r24, Y+7	; 0x07
    7152:	98 85       	ldd	r25, Y+8	; 0x08
    7154:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7158:	dc 01       	movw	r26, r24
    715a:	cb 01       	movw	r24, r22
    715c:	89 87       	std	Y+9, r24	; 0x09
    715e:	9a 87       	std	Y+10, r25	; 0x0a
    7160:	89 85       	ldd	r24, Y+9	; 0x09
    7162:	9a 85       	ldd	r25, Y+10	; 0x0a
    7164:	8d 87       	std	Y+13, r24	; 0x0d
    7166:	9e 87       	std	Y+14, r25	; 0x0e
    7168:	8d 85       	ldd	r24, Y+13	; 0x0d
    716a:	9e 85       	ldd	r25, Y+14	; 0x0e
    716c:	8c 01       	movw	r16, r24
    716e:	f8 01       	movw	r30, r16
    7170:	31 97       	sbiw	r30, 0x01	; 1
    7172:	f1 f7       	brne	.-4      	; 0x7170 <HVPower+0x126>
    7174:	8f 01       	movw	r16, r30
    7176:	0d 87       	std	Y+13, r16	; 0x0d
    7178:	1e 87       	std	Y+14, r17	; 0x0e
    717a:	0a c0       	rjmp	.+20     	; 0x7190 <HVPower+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    717c:	80 ea       	ldi	r24, 0xA0	; 160
    717e:	96 e0       	ldi	r25, 0x06	; 6
    7180:	20 e8       	ldi	r18, 0x80	; 128
    7182:	fc 01       	movw	r30, r24
    7184:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    7186:	80 ea       	ldi	r24, 0xA0	; 160
    7188:	96 e0       	ldi	r25, 0x06	; 6
    718a:	20 e8       	ldi	r18, 0x80	; 128
    718c:	fc 01       	movw	r30, r24
    718e:	22 83       	std	Z+2, r18	; 0x02
    7190:	80 e0       	ldi	r24, 0x00	; 0
    7192:	90 e0       	ldi	r25, 0x00	; 0
    7194:	aa e7       	ldi	r26, 0x7A	; 122
    7196:	b4 e4       	ldi	r27, 0x44	; 68
    7198:	8f 87       	std	Y+15, r24	; 0x0f
    719a:	98 8b       	std	Y+16, r25	; 0x10
    719c:	a9 8b       	std	Y+17, r26	; 0x11
    719e:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    71a0:	6f 85       	ldd	r22, Y+15	; 0x0f
    71a2:	78 89       	ldd	r23, Y+16	; 0x10
    71a4:	89 89       	ldd	r24, Y+17	; 0x11
    71a6:	9a 89       	ldd	r25, Y+18	; 0x12
    71a8:	2b ea       	ldi	r18, 0xAB	; 171
    71aa:	3a ea       	ldi	r19, 0xAA	; 170
    71ac:	4a e2       	ldi	r20, 0x2A	; 42
    71ae:	51 e4       	ldi	r21, 0x41	; 65
    71b0:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    71b4:	dc 01       	movw	r26, r24
    71b6:	cb 01       	movw	r24, r22
    71b8:	8b 8b       	std	Y+19, r24	; 0x13
    71ba:	9c 8b       	std	Y+20, r25	; 0x14
    71bc:	ad 8b       	std	Y+21, r26	; 0x15
    71be:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    71c0:	11 e0       	ldi	r17, 0x01	; 1
    71c2:	6b 89       	ldd	r22, Y+19	; 0x13
    71c4:	7c 89       	ldd	r23, Y+20	; 0x14
    71c6:	8d 89       	ldd	r24, Y+21	; 0x15
    71c8:	9e 89       	ldd	r25, Y+22	; 0x16
    71ca:	20 e0       	ldi	r18, 0x00	; 0
    71cc:	30 e0       	ldi	r19, 0x00	; 0
    71ce:	40 e8       	ldi	r20, 0x80	; 128
    71d0:	5f e3       	ldi	r21, 0x3F	; 63
    71d2:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    71d6:	88 23       	and	r24, r24
    71d8:	0c f0       	brlt	.+2      	; 0x71dc <HVPower+0x192>
    71da:	10 e0       	ldi	r17, 0x00	; 0
    71dc:	11 23       	and	r17, r17
    71de:	19 f0       	breq	.+6      	; 0x71e6 <HVPower+0x19c>
		__ticks = 1;
    71e0:	81 e0       	ldi	r24, 0x01	; 1
    71e2:	8f 8b       	std	Y+23, r24	; 0x17
    71e4:	a3 c0       	rjmp	.+326    	; 0x732c <HVPower+0x2e2>
	else if (__tmp > 255)
    71e6:	11 e0       	ldi	r17, 0x01	; 1
    71e8:	6b 89       	ldd	r22, Y+19	; 0x13
    71ea:	7c 89       	ldd	r23, Y+20	; 0x14
    71ec:	8d 89       	ldd	r24, Y+21	; 0x15
    71ee:	9e 89       	ldd	r25, Y+22	; 0x16
    71f0:	20 e0       	ldi	r18, 0x00	; 0
    71f2:	30 e0       	ldi	r19, 0x00	; 0
    71f4:	4f e7       	ldi	r20, 0x7F	; 127
    71f6:	53 e4       	ldi	r21, 0x43	; 67
    71f8:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    71fc:	18 16       	cp	r1, r24
    71fe:	0c f0       	brlt	.+2      	; 0x7202 <HVPower+0x1b8>
    7200:	10 e0       	ldi	r17, 0x00	; 0
    7202:	11 23       	and	r17, r17
    7204:	09 f4       	brne	.+2      	; 0x7208 <HVPower+0x1be>
    7206:	89 c0       	rjmp	.+274    	; 0x731a <HVPower+0x2d0>
	{
		_delay_ms(__us / 1000.0);
    7208:	6f 85       	ldd	r22, Y+15	; 0x0f
    720a:	78 89       	ldd	r23, Y+16	; 0x10
    720c:	89 89       	ldd	r24, Y+17	; 0x11
    720e:	9a 89       	ldd	r25, Y+18	; 0x12
    7210:	20 e0       	ldi	r18, 0x00	; 0
    7212:	30 e0       	ldi	r19, 0x00	; 0
    7214:	4a e7       	ldi	r20, 0x7A	; 122
    7216:	54 e4       	ldi	r21, 0x44	; 68
    7218:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
    721c:	dc 01       	movw	r26, r24
    721e:	cb 01       	movw	r24, r22
    7220:	88 8f       	std	Y+24, r24	; 0x18
    7222:	99 8f       	std	Y+25, r25	; 0x19
    7224:	aa 8f       	std	Y+26, r26	; 0x1a
    7226:	bb 8f       	std	Y+27, r27	; 0x1b
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7228:	68 8d       	ldd	r22, Y+24	; 0x18
    722a:	79 8d       	ldd	r23, Y+25	; 0x19
    722c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    722e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    7230:	20 e0       	ldi	r18, 0x00	; 0
    7232:	30 e0       	ldi	r19, 0x00	; 0
    7234:	4a ef       	ldi	r20, 0xFA	; 250
    7236:	55 e4       	ldi	r21, 0x45	; 69
    7238:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    723c:	dc 01       	movw	r26, r24
    723e:	cb 01       	movw	r24, r22
    7240:	8c 8f       	std	Y+28, r24	; 0x1c
    7242:	9d 8f       	std	Y+29, r25	; 0x1d
    7244:	ae 8f       	std	Y+30, r26	; 0x1e
    7246:	bf 8f       	std	Y+31, r27	; 0x1f
	if (__tmp < 1.0)
    7248:	11 e0       	ldi	r17, 0x01	; 1
    724a:	6c 8d       	ldd	r22, Y+28	; 0x1c
    724c:	7d 8d       	ldd	r23, Y+29	; 0x1d
    724e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    7250:	9f 8d       	ldd	r25, Y+31	; 0x1f
    7252:	20 e0       	ldi	r18, 0x00	; 0
    7254:	30 e0       	ldi	r19, 0x00	; 0
    7256:	40 e8       	ldi	r20, 0x80	; 128
    7258:	5f e3       	ldi	r21, 0x3F	; 63
    725a:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    725e:	88 23       	and	r24, r24
    7260:	0c f0       	brlt	.+2      	; 0x7264 <HVPower+0x21a>
    7262:	10 e0       	ldi	r17, 0x00	; 0
    7264:	11 23       	and	r17, r17
    7266:	29 f0       	breq	.+10     	; 0x7272 <HVPower+0x228>
		__ticks = 1;
    7268:	81 e0       	ldi	r24, 0x01	; 1
    726a:	90 e0       	ldi	r25, 0x00	; 0
    726c:	88 a3       	lds	r24, 0x58
    726e:	99 a3       	lds	r25, 0x59
    7270:	46 c0       	rjmp	.+140    	; 0x72fe <HVPower+0x2b4>
	else if (__tmp > 65535)
    7272:	11 e0       	ldi	r17, 0x01	; 1
    7274:	6c 8d       	ldd	r22, Y+28	; 0x1c
    7276:	7d 8d       	ldd	r23, Y+29	; 0x1d
    7278:	8e 8d       	ldd	r24, Y+30	; 0x1e
    727a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    727c:	20 e0       	ldi	r18, 0x00	; 0
    727e:	3f ef       	ldi	r19, 0xFF	; 255
    7280:	4f e7       	ldi	r20, 0x7F	; 127
    7282:	57 e4       	ldi	r21, 0x47	; 71
    7284:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    7288:	18 16       	cp	r1, r24
    728a:	0c f0       	brlt	.+2      	; 0x728e <HVPower+0x244>
    728c:	10 e0       	ldi	r17, 0x00	; 0
    728e:	11 23       	and	r17, r17
    7290:	61 f1       	breq	.+88     	; 0x72ea <HVPower+0x2a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7292:	68 8d       	ldd	r22, Y+24	; 0x18
    7294:	79 8d       	ldd	r23, Y+25	; 0x19
    7296:	8a 8d       	ldd	r24, Y+26	; 0x1a
    7298:	9b 8d       	ldd	r25, Y+27	; 0x1b
    729a:	20 e0       	ldi	r18, 0x00	; 0
    729c:	30 e0       	ldi	r19, 0x00	; 0
    729e:	40 e2       	ldi	r20, 0x20	; 32
    72a0:	51 e4       	ldi	r21, 0x41	; 65
    72a2:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    72a6:	dc 01       	movw	r26, r24
    72a8:	cb 01       	movw	r24, r22
    72aa:	bc 01       	movw	r22, r24
    72ac:	cd 01       	movw	r24, r26
    72ae:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    72b2:	dc 01       	movw	r26, r24
    72b4:	cb 01       	movw	r24, r22
    72b6:	88 a3       	lds	r24, 0x58
    72b8:	99 a3       	lds	r25, 0x59
    72ba:	12 c0       	rjmp	.+36     	; 0x72e0 <HVPower+0x296>
    72bc:	80 e2       	ldi	r24, 0x20	; 32
    72be:	93 e0       	ldi	r25, 0x03	; 3
    72c0:	8a a3       	lds	r24, 0x5a
    72c2:	9b a3       	lds	r25, 0x5b
    72c4:	8a a1       	lds	r24, 0x4a
    72c6:	9b a1       	lds	r25, 0x4b
    72c8:	8c 01       	movw	r16, r24
    72ca:	c8 01       	movw	r24, r16
    72cc:	01 97       	sbiw	r24, 0x01	; 1
    72ce:	f1 f7       	brne	.-4      	; 0x72cc <HVPower+0x282>
    72d0:	8c 01       	movw	r16, r24
    72d2:	0a a3       	lds	r16, 0x5a
    72d4:	1b a3       	lds	r17, 0x5b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    72d6:	88 a1       	lds	r24, 0x48
    72d8:	99 a1       	lds	r25, 0x49
    72da:	01 97       	sbiw	r24, 0x01	; 1
    72dc:	88 a3       	lds	r24, 0x58
    72de:	99 a3       	lds	r25, 0x59
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    72e0:	88 a1       	lds	r24, 0x48
    72e2:	99 a1       	lds	r25, 0x49
    72e4:	00 97       	sbiw	r24, 0x00	; 0
    72e6:	51 f7       	brne	.-44     	; 0x72bc <HVPower+0x272>
    72e8:	28 c0       	rjmp	.+80     	; 0x733a <HVPower+0x2f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    72ea:	6c 8d       	ldd	r22, Y+28	; 0x1c
    72ec:	7d 8d       	ldd	r23, Y+29	; 0x1d
    72ee:	8e 8d       	ldd	r24, Y+30	; 0x1e
    72f0:	9f 8d       	ldd	r25, Y+31	; 0x1f
    72f2:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    72f6:	dc 01       	movw	r26, r24
    72f8:	cb 01       	movw	r24, r22
    72fa:	88 a3       	lds	r24, 0x58
    72fc:	99 a3       	lds	r25, 0x59
    72fe:	88 a1       	lds	r24, 0x48
    7300:	99 a1       	lds	r25, 0x49
    7302:	8c a3       	lds	r24, 0x5c
    7304:	9d a3       	lds	r25, 0x5d
    7306:	8c a1       	lds	r24, 0x4c
    7308:	9d a1       	lds	r25, 0x4d
    730a:	8c 01       	movw	r16, r24
    730c:	f8 01       	movw	r30, r16
    730e:	31 97       	sbiw	r30, 0x01	; 1
    7310:	f1 f7       	brne	.-4      	; 0x730e <HVPower+0x2c4>
    7312:	8f 01       	movw	r16, r30
    7314:	0c a3       	lds	r16, 0x5c
    7316:	1d a3       	lds	r17, 0x5d
    7318:	10 c0       	rjmp	.+32     	; 0x733a <HVPower+0x2f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    731a:	6b 89       	ldd	r22, Y+19	; 0x13
    731c:	7c 89       	ldd	r23, Y+20	; 0x14
    731e:	8d 89       	ldd	r24, Y+21	; 0x15
    7320:	9e 89       	ldd	r25, Y+22	; 0x16
    7322:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7326:	dc 01       	movw	r26, r24
    7328:	cb 01       	movw	r24, r22
    732a:	8f 8b       	std	Y+23, r24	; 0x17
    732c:	8f 89       	ldd	r24, Y+23	; 0x17
    732e:	8e a3       	lds	r24, 0x5e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7330:	8e a1       	lds	r24, 0x4e
    7332:	18 2f       	mov	r17, r24
    7334:	1a 95       	dec	r17
    7336:	f1 f7       	brne	.-4      	; 0x7334 <HVPower+0x2ea>
    7338:	1e a3       	lds	r17, 0x5e
	}
	_delay_us(1000);
}
    733a:	a7 96       	adiw	r28, 0x27	; 39
    733c:	cd bf       	out	0x3d, r28	; 61
    733e:	de bf       	out	0x3e, r29	; 62
    7340:	df 91       	pop	r29
    7342:	cf 91       	pop	r28
    7344:	1f 91       	pop	r17
    7346:	0f 91       	pop	r16
    7348:	08 95       	ret

0000734a <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
    734a:	cf 93       	push	r28
    734c:	df 93       	push	r29
    734e:	0f 92       	push	r0
    7350:	cd b7       	in	r28, 0x3d	; 61
    7352:	de b7       	in	r29, 0x3e	; 62
    7354:	89 83       	std	Y+1, r24	; 0x01
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    7356:	89 81       	ldd	r24, Y+1	; 0x01
    7358:	88 23       	and	r24, r24
    735a:	31 f0       	breq	.+12     	; 0x7368 <lowerMuxCS+0x1e>
    735c:	80 e8       	ldi	r24, 0x80	; 128
    735e:	96 e0       	ldi	r25, 0x06	; 6
    7360:	20 e1       	ldi	r18, 0x10	; 16
    7362:	fc 01       	movw	r30, r24
    7364:	26 83       	std	Z+6, r18	; 0x06
    7366:	05 c0       	rjmp	.+10     	; 0x7372 <lowerMuxCS+0x28>
	else PORTE.OUTSET = PIN4_bm;
    7368:	80 e8       	ldi	r24, 0x80	; 128
    736a:	96 e0       	ldi	r25, 0x06	; 6
    736c:	20 e1       	ldi	r18, 0x10	; 16
    736e:	fc 01       	movw	r30, r24
    7370:	25 83       	std	Z+5, r18	; 0x05
}
    7372:	0f 90       	pop	r0
    7374:	df 91       	pop	r29
    7376:	cf 91       	pop	r28
    7378:	08 95       	ret

0000737a <upperMuxCS>:
void upperMuxCS(uint8_t write) {
    737a:	cf 93       	push	r28
    737c:	df 93       	push	r29
    737e:	0f 92       	push	r0
    7380:	cd b7       	in	r28, 0x3d	; 61
    7382:	de b7       	in	r29, 0x3e	; 62
    7384:	89 83       	std	Y+1, r24	; 0x01
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    7386:	89 81       	ldd	r24, Y+1	; 0x01
    7388:	88 23       	and	r24, r24
    738a:	31 f0       	breq	.+12     	; 0x7398 <upperMuxCS+0x1e>
    738c:	80 e4       	ldi	r24, 0x40	; 64
    738e:	96 e0       	ldi	r25, 0x06	; 6
    7390:	22 e0       	ldi	r18, 0x02	; 2
    7392:	fc 01       	movw	r30, r24
    7394:	26 83       	std	Z+6, r18	; 0x06
    7396:	05 c0       	rjmp	.+10     	; 0x73a2 <upperMuxCS+0x28>
	else PORTC.OUTSET = PIN1_bm;
    7398:	80 e4       	ldi	r24, 0x40	; 64
    739a:	96 e0       	ldi	r25, 0x06	; 6
    739c:	22 e0       	ldi	r18, 0x02	; 2
    739e:	fc 01       	movw	r30, r24
    73a0:	25 83       	std	Z+5, r18	; 0x05
}
    73a2:	0f 90       	pop	r0
    73a4:	df 91       	pop	r29
    73a6:	cf 91       	pop	r28
    73a8:	08 95       	ret

000073aa <SPIInit>:

void SPIInit(uint8_t mode) {
    73aa:	cf 93       	push	r28
    73ac:	df 93       	push	r29
    73ae:	0f 92       	push	r0
    73b0:	cd b7       	in	r28, 0x3d	; 61
    73b2:	de b7       	in	r29, 0x3e	; 62
    73b4:	89 83       	std	Y+1, r24	; 0x01
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    73b6:	80 e4       	ldi	r24, 0x40	; 64
    73b8:	96 e0       	ldi	r25, 0x06	; 6
    73ba:	20 e1       	ldi	r18, 0x10	; 16
    73bc:	fc 01       	movw	r30, r24
    73be:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    73c0:	80 e4       	ldi	r24, 0x40	; 64
    73c2:	96 e0       	ldi	r25, 0x06	; 6
    73c4:	28 e3       	ldi	r18, 0x38	; 56
    73c6:	fc 01       	movw	r30, r24
    73c8:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    73ca:	80 e4       	ldi	r24, 0x40	; 64
    73cc:	96 e0       	ldi	r25, 0x06	; 6
    73ce:	20 e1       	ldi	r18, 0x10	; 16
    73d0:	fc 01       	movw	r30, r24
    73d2:	25 83       	std	Z+5, r18	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    73d4:	80 ec       	ldi	r24, 0xC0	; 192
    73d6:	98 e0       	ldi	r25, 0x08	; 8
    73d8:	29 81       	ldd	r18, Y+1	; 0x01
    73da:	21 65       	ori	r18, 0x51	; 81
    73dc:	fc 01       	movw	r30, r24
    73de:	20 83       	st	Z, r18
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    73e0:	80 ec       	ldi	r24, 0xC0	; 192
    73e2:	98 e0       	ldi	r25, 0x08	; 8
    73e4:	fc 01       	movw	r30, r24
    73e6:	11 82       	std	Z+1, r1	; 0x01

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    73e8:	80 e4       	ldi	r24, 0x40	; 64
    73ea:	96 e0       	ldi	r25, 0x06	; 6
    73ec:	20 ea       	ldi	r18, 0xA0	; 160
    73ee:	fc 01       	movw	r30, r24
    73f0:	21 83       	std	Z+1, r18	; 0x01

	
}
    73f2:	0f 90       	pop	r0
    73f4:	df 91       	pop	r29
    73f6:	cf 91       	pop	r28
    73f8:	08 95       	ret

000073fa <SPIInit2>:
//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
    73fa:	cf 93       	push	r28
    73fc:	df 93       	push	r29
    73fe:	0f 92       	push	r0
    7400:	0f 92       	push	r0
    7402:	cd b7       	in	r28, 0x3d	; 61
    7404:	de b7       	in	r29, 0x3e	; 62
    7406:	89 83       	std	Y+1, r24	; 0x01
    7408:	6a 83       	std	Y+2, r22	; 0x02
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    740a:	80 e4       	ldi	r24, 0x40	; 64
    740c:	96 e0       	ldi	r25, 0x06	; 6
    740e:	20 e1       	ldi	r18, 0x10	; 16
    7410:	fc 01       	movw	r30, r24
    7412:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    7414:	80 e4       	ldi	r24, 0x40	; 64
    7416:	96 e0       	ldi	r25, 0x06	; 6
    7418:	28 e3       	ldi	r18, 0x38	; 56
    741a:	fc 01       	movw	r30, r24
    741c:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    741e:	80 e4       	ldi	r24, 0x40	; 64
    7420:	96 e0       	ldi	r25, 0x06	; 6
    7422:	20 e1       	ldi	r18, 0x10	; 16
    7424:	fc 01       	movw	r30, r24
    7426:	25 83       	std	Z+5, r18	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    7428:	80 ec       	ldi	r24, 0xC0	; 192
    742a:	98 e0       	ldi	r25, 0x08	; 8
    742c:	3a 81       	ldd	r19, Y+2	; 0x02
    742e:	29 81       	ldd	r18, Y+1	; 0x01
    7430:	23 2b       	or	r18, r19
    7432:	20 65       	ori	r18, 0x50	; 80
    7434:	fc 01       	movw	r30, r24
    7436:	20 83       	st	Z, r18
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    7438:	80 ec       	ldi	r24, 0xC0	; 192
    743a:	98 e0       	ldi	r25, 0x08	; 8
    743c:	fc 01       	movw	r30, r24
    743e:	11 82       	std	Z+1, r1	; 0x01

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    7440:	80 e4       	ldi	r24, 0x40	; 64
    7442:	96 e0       	ldi	r25, 0x06	; 6
    7444:	20 ea       	ldi	r18, 0xA0	; 160
    7446:	fc 01       	movw	r30, r24
    7448:	21 83       	std	Z+1, r18	; 0x01
}
    744a:	0f 90       	pop	r0
    744c:	0f 90       	pop	r0
    744e:	df 91       	pop	r29
    7450:	cf 91       	pop	r28
    7452:	08 95       	ret

00007454 <SPICS>:

void SPICS(uint8_t enable) {
    7454:	cf 93       	push	r28
    7456:	df 93       	push	r29
    7458:	0f 92       	push	r0
    745a:	cd b7       	in	r28, 0x3d	; 61
    745c:	de b7       	in	r29, 0x3e	; 62
    745e:	89 83       	std	Y+1, r24	; 0x01
	if (enable) PORTC.OUTCLR = PIN4_bm;
    7460:	89 81       	ldd	r24, Y+1	; 0x01
    7462:	88 23       	and	r24, r24
    7464:	31 f0       	breq	.+12     	; 0x7472 <SPICS+0x1e>
    7466:	80 e4       	ldi	r24, 0x40	; 64
    7468:	96 e0       	ldi	r25, 0x06	; 6
    746a:	20 e1       	ldi	r18, 0x10	; 16
    746c:	fc 01       	movw	r30, r24
    746e:	26 83       	std	Z+6, r18	; 0x06
    7470:	05 c0       	rjmp	.+10     	; 0x747c <SPICS+0x28>
	else {
		PORTC.OUTSET = PIN4_bm;
    7472:	80 e4       	ldi	r24, 0x40	; 64
    7474:	96 e0       	ldi	r25, 0x06	; 6
    7476:	20 e1       	ldi	r18, 0x10	; 16
    7478:	fc 01       	movw	r30, r24
    747a:	25 83       	std	Z+5, r18	; 0x05
	}	
}
    747c:	0f 90       	pop	r0
    747e:	df 91       	pop	r29
    7480:	cf 91       	pop	r28
    7482:	08 95       	ret

00007484 <SPIDisable>:

void SPIDisable() {
    7484:	cf 93       	push	r28
    7486:	df 93       	push	r29
    7488:	cd b7       	in	r28, 0x3d	; 61
    748a:	de b7       	in	r29, 0x3e	; 62
	PORTC.OUTSET = PIN4_bm;
    748c:	80 e4       	ldi	r24, 0x40	; 64
    748e:	96 e0       	ldi	r25, 0x06	; 6
    7490:	20 e1       	ldi	r18, 0x10	; 16
    7492:	fc 01       	movw	r30, r24
    7494:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = 0x00;
    7496:	80 ec       	ldi	r24, 0xC0	; 192
    7498:	98 e0       	ldi	r25, 0x08	; 8
    749a:	fc 01       	movw	r30, r24
    749c:	10 82       	st	Z, r1
	PORTC.OUTCLR = PIN4_bm;
    749e:	80 e4       	ldi	r24, 0x40	; 64
    74a0:	96 e0       	ldi	r25, 0x06	; 6
    74a2:	20 e1       	ldi	r18, 0x10	; 16
    74a4:	fc 01       	movw	r30, r24
    74a6:	26 83       	std	Z+6, r18	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    74a8:	80 e4       	ldi	r24, 0x40	; 64
    74aa:	96 e0       	ldi	r25, 0x06	; 6
    74ac:	20 eb       	ldi	r18, 0xB0	; 176
    74ae:	fc 01       	movw	r30, r24
    74b0:	22 83       	std	Z+2, r18	; 0x02

}
    74b2:	df 91       	pop	r29
    74b4:	cf 91       	pop	r28
    74b6:	08 95       	ret

000074b8 <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    74b8:	cf 93       	push	r28
    74ba:	df 93       	push	r29
    74bc:	00 d0       	rcall	.+0      	; 0x74be <readFRAM+0x6>
    74be:	0f 92       	push	r0
    74c0:	cd b7       	in	r28, 0x3d	; 61
    74c2:	de b7       	in	r29, 0x3e	; 62
    74c4:	8b 83       	std	Y+3, r24	; 0x03
    74c6:	9c 83       	std	Y+4, r25	; 0x04
	SPIInit(SPI_MODE_0_gc);
    74c8:	80 e0       	ldi	r24, 0x00	; 0
    74ca:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    74ce:	80 ec       	ldi	r24, 0xC0	; 192
    74d0:	98 e0       	ldi	r25, 0x08	; 8
    74d2:	20 ed       	ldi	r18, 0xD0	; 208
    74d4:	fc 01       	movw	r30, r24
    74d6:	20 83       	st	Z, r18
	SPICS(TRUE);
    74d8:	81 e0       	ldi	r24, 0x01	; 1
    74da:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    74de:	80 e2       	ldi	r24, 0x20	; 32
    74e0:	96 e0       	ldi	r25, 0x06	; 6
    74e2:	28 e0       	ldi	r18, 0x08	; 8
    74e4:	fc 01       	movw	r30, r24
    74e6:	26 83       	std	Z+6, r18	; 0x06
	nop();
    74e8:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    74ea:	80 ec       	ldi	r24, 0xC0	; 192
    74ec:	98 e0       	ldi	r25, 0x08	; 8
    74ee:	23 e0       	ldi	r18, 0x03	; 3
    74f0:	fc 01       	movw	r30, r24
    74f2:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    74f4:	00 00       	nop
    74f6:	80 ec       	ldi	r24, 0xC0	; 192
    74f8:	98 e0       	ldi	r25, 0x08	; 8
    74fa:	fc 01       	movw	r30, r24
    74fc:	82 81       	ldd	r24, Z+2	; 0x02
    74fe:	88 23       	and	r24, r24
    7500:	d4 f7       	brge	.-12     	; 0x74f6 <readFRAM+0x3e>
	SPIBuffer[12] = SPIC.DATA;
    7502:	80 ec       	ldi	r24, 0xC0	; 192
    7504:	98 e0       	ldi	r25, 0x08	; 8
    7506:	fc 01       	movw	r30, r24
    7508:	83 81       	ldd	r24, Z+3	; 0x03
    750a:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    750e:	80 ec       	ldi	r24, 0xC0	; 192
    7510:	98 e0       	ldi	r25, 0x08	; 8
    7512:	20 91 59 40 	lds	r18, 0x4059
    7516:	fc 01       	movw	r30, r24
    7518:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    751a:	00 00       	nop
    751c:	80 ec       	ldi	r24, 0xC0	; 192
    751e:	98 e0       	ldi	r25, 0x08	; 8
    7520:	fc 01       	movw	r30, r24
    7522:	82 81       	ldd	r24, Z+2	; 0x02
    7524:	88 23       	and	r24, r24
    7526:	d4 f7       	brge	.-12     	; 0x751c <readFRAM+0x64>
	SPIBuffer[12] = SPIC.DATA;
    7528:	80 ec       	ldi	r24, 0xC0	; 192
    752a:	98 e0       	ldi	r25, 0x08	; 8
    752c:	fc 01       	movw	r30, r24
    752e:	83 81       	ldd	r24, Z+3	; 0x03
    7530:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    7534:	80 ec       	ldi	r24, 0xC0	; 192
    7536:	98 e0       	ldi	r25, 0x08	; 8
    7538:	28 e5       	ldi	r18, 0x58	; 88
    753a:	30 e4       	ldi	r19, 0x40	; 64
    753c:	f9 01       	movw	r30, r18
    753e:	20 81       	ld	r18, Z
    7540:	fc 01       	movw	r30, r24
    7542:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    7544:	00 00       	nop
    7546:	80 ec       	ldi	r24, 0xC0	; 192
    7548:	98 e0       	ldi	r25, 0x08	; 8
    754a:	fc 01       	movw	r30, r24
    754c:	82 81       	ldd	r24, Z+2	; 0x02
    754e:	88 23       	and	r24, r24
    7550:	d4 f7       	brge	.-12     	; 0x7546 <readFRAM+0x8e>
	SPIBuffer[12] = SPIC.DATA;
    7552:	80 ec       	ldi	r24, 0xC0	; 192
    7554:	98 e0       	ldi	r25, 0x08	; 8
    7556:	fc 01       	movw	r30, r24
    7558:	83 81       	ldd	r24, Z+3	; 0x03
    755a:	80 93 72 50 	sts	0x5072, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    755e:	19 82       	std	Y+1, r1	; 0x01
    7560:	1a 82       	std	Y+2, r1	; 0x02
    7562:	1b c0       	rjmp	.+54     	; 0x759a <readFRAM+0xe2>
		SPIC.DATA = 0xAA;
    7564:	80 ec       	ldi	r24, 0xC0	; 192
    7566:	98 e0       	ldi	r25, 0x08	; 8
    7568:	2a ea       	ldi	r18, 0xAA	; 170
    756a:	fc 01       	movw	r30, r24
    756c:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    756e:	00 00       	nop
    7570:	80 ec       	ldi	r24, 0xC0	; 192
    7572:	98 e0       	ldi	r25, 0x08	; 8
    7574:	fc 01       	movw	r30, r24
    7576:	82 81       	ldd	r24, Z+2	; 0x02
    7578:	88 23       	and	r24, r24
    757a:	d4 f7       	brge	.-12     	; 0x7570 <readFRAM+0xb8>
		FRAMReadBuffer[i] = SPIC.DATA;
    757c:	80 ec       	ldi	r24, 0xC0	; 192
    757e:	98 e0       	ldi	r25, 0x08	; 8
    7580:	fc 01       	movw	r30, r24
    7582:	23 81       	ldd	r18, Z+3	; 0x03
    7584:	89 81       	ldd	r24, Y+1	; 0x01
    7586:	9a 81       	ldd	r25, Y+2	; 0x02
    7588:	80 52       	subi	r24, 0x20	; 32
    758a:	9c 4d       	sbci	r25, 0xDC	; 220
    758c:	fc 01       	movw	r30, r24
    758e:	20 83       	st	Z, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    7590:	89 81       	ldd	r24, Y+1	; 0x01
    7592:	9a 81       	ldd	r25, Y+2	; 0x02
    7594:	01 96       	adiw	r24, 0x01	; 1
    7596:	89 83       	std	Y+1, r24	; 0x01
    7598:	9a 83       	std	Y+2, r25	; 0x02
    759a:	29 81       	ldd	r18, Y+1	; 0x01
    759c:	3a 81       	ldd	r19, Y+2	; 0x02
    759e:	8b 81       	ldd	r24, Y+3	; 0x03
    75a0:	9c 81       	ldd	r25, Y+4	; 0x04
    75a2:	28 17       	cp	r18, r24
    75a4:	39 07       	cpc	r19, r25
    75a6:	f0 f2       	brcs	.-68     	; 0x7564 <readFRAM+0xac>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    75a8:	80 e2       	ldi	r24, 0x20	; 32
    75aa:	96 e0       	ldi	r25, 0x06	; 6
    75ac:	28 e0       	ldi	r18, 0x08	; 8
    75ae:	fc 01       	movw	r30, r24
    75b0:	25 83       	std	Z+5, r18	; 0x05
	SPICS(FALSE);
    75b2:	80 e0       	ldi	r24, 0x00	; 0
    75b4:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	SPIDisable();
    75b8:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>

}
    75bc:	24 96       	adiw	r28, 0x04	; 4
    75be:	cd bf       	out	0x3d, r28	; 61
    75c0:	de bf       	out	0x3e, r29	; 62
    75c2:	df 91       	pop	r29
    75c4:	cf 91       	pop	r28
    75c6:	08 95       	ret

000075c8 <FRAMTest3Channel>:

void FRAMTest3Channel(void) {
    75c8:	8f 92       	push	r8
    75ca:	9f 92       	push	r9
    75cc:	af 92       	push	r10
    75ce:	bf 92       	push	r11
    75d0:	cf 92       	push	r12
    75d2:	df 92       	push	r13
    75d4:	ef 92       	push	r14
    75d6:	ff 92       	push	r15
    75d8:	0f 93       	push	r16
    75da:	1f 93       	push	r17
    75dc:	cf 93       	push	r28
    75de:	df 93       	push	r29
    75e0:	cd b7       	in	r28, 0x3d	; 61
    75e2:	de b7       	in	r29, 0x3e	; 62
    75e4:	6b 97       	sbiw	r28, 0x1b	; 27
    75e6:	cd bf       	out	0x3d, r28	; 61
    75e8:	de bf       	out	0x3e, r29	; 62
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
    75ea:	19 8e       	std	Y+25, r1	; 0x19
    75ec:	1a 8e       	std	Y+26, r1	; 0x1a
    75ee:	1b 8e       	std	Y+27, r1	; 0x1b
			
	CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |
		FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
		gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
    75f0:	9e 01       	movw	r18, r28
    75f2:	27 5e       	subi	r18, 0xE7	; 231
    75f4:	3f 4f       	sbci	r19, 0xFF	; 255
}

void FRAMTest3Channel(void) {
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
			
	CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |
    75f6:	8e ec       	ldi	r24, 0xCE	; 206
    75f8:	b9 01       	movw	r22, r18
    75fa:	40 e0       	ldi	r20, 0x00	; 0
    75fc:	25 e1       	ldi	r18, 0x15	; 21
    75fe:	01 e0       	ldi	r16, 0x01	; 1
    7600:	0f 2e       	mov	r0, r31
    7602:	fd e0       	ldi	r31, 0x0D	; 13
    7604:	ef 2e       	mov	r14, r31
    7606:	ff 24       	eor	r15, r15
    7608:	f0 2d       	mov	r31, r0
    760a:	0f 2e       	mov	r0, r31
    760c:	fe e0       	ldi	r31, 0x0E	; 14
    760e:	cf 2e       	mov	r12, r31
    7610:	dd 24       	eor	r13, r13
    7612:	f0 2d       	mov	r31, r0
    7614:	0f 2e       	mov	r0, r31
    7616:	ff e0       	ldi	r31, 0x0F	; 15
    7618:	af 2e       	mov	r10, r31
    761a:	bb 24       	eor	r11, r11
    761c:	f0 2d       	mov	r31, r0
    761e:	88 24       	eor	r8, r8
    7620:	99 24       	eor	r9, r9
    7622:	68 94       	set
    7624:	84 f8       	bld	r8, 4
    7626:	0e 94 5d 11 	call	0x22ba	; 0x22ba <CO_collectSeismic3Channel>
		FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
		gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    762a:	81 e0       	ldi	r24, 0x01	; 1
    762c:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
    7630:	80 e0       	ldi	r24, 0x00	; 0
    7632:	90 e0       	ldi	r25, 0x00	; 0
    7634:	aa e7       	ldi	r26, 0x7A	; 122
    7636:	b3 e4       	ldi	r27, 0x43	; 67
    7638:	89 83       	std	Y+1, r24	; 0x01
    763a:	9a 83       	std	Y+2, r25	; 0x02
    763c:	ab 83       	std	Y+3, r26	; 0x03
    763e:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7640:	69 81       	ldd	r22, Y+1	; 0x01
    7642:	7a 81       	ldd	r23, Y+2	; 0x02
    7644:	8b 81       	ldd	r24, Y+3	; 0x03
    7646:	9c 81       	ldd	r25, Y+4	; 0x04
    7648:	2b ea       	ldi	r18, 0xAB	; 171
    764a:	3a ea       	ldi	r19, 0xAA	; 170
    764c:	4a e2       	ldi	r20, 0x2A	; 42
    764e:	51 e4       	ldi	r21, 0x41	; 65
    7650:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    7654:	dc 01       	movw	r26, r24
    7656:	cb 01       	movw	r24, r22
    7658:	8d 83       	std	Y+5, r24	; 0x05
    765a:	9e 83       	std	Y+6, r25	; 0x06
    765c:	af 83       	std	Y+7, r26	; 0x07
    765e:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7660:	11 e0       	ldi	r17, 0x01	; 1
    7662:	6d 81       	ldd	r22, Y+5	; 0x05
    7664:	7e 81       	ldd	r23, Y+6	; 0x06
    7666:	8f 81       	ldd	r24, Y+7	; 0x07
    7668:	98 85       	ldd	r25, Y+8	; 0x08
    766a:	20 e0       	ldi	r18, 0x00	; 0
    766c:	30 e0       	ldi	r19, 0x00	; 0
    766e:	40 e8       	ldi	r20, 0x80	; 128
    7670:	5f e3       	ldi	r21, 0x3F	; 63
    7672:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    7676:	88 23       	and	r24, r24
    7678:	0c f0       	brlt	.+2      	; 0x767c <FRAMTest3Channel+0xb4>
    767a:	10 e0       	ldi	r17, 0x00	; 0
    767c:	11 23       	and	r17, r17
    767e:	19 f0       	breq	.+6      	; 0x7686 <FRAMTest3Channel+0xbe>
		__ticks = 1;
    7680:	81 e0       	ldi	r24, 0x01	; 1
    7682:	89 87       	std	Y+9, r24	; 0x09
    7684:	a3 c0       	rjmp	.+326    	; 0x77cc <FRAMTest3Channel+0x204>
	else if (__tmp > 255)
    7686:	11 e0       	ldi	r17, 0x01	; 1
    7688:	6d 81       	ldd	r22, Y+5	; 0x05
    768a:	7e 81       	ldd	r23, Y+6	; 0x06
    768c:	8f 81       	ldd	r24, Y+7	; 0x07
    768e:	98 85       	ldd	r25, Y+8	; 0x08
    7690:	20 e0       	ldi	r18, 0x00	; 0
    7692:	30 e0       	ldi	r19, 0x00	; 0
    7694:	4f e7       	ldi	r20, 0x7F	; 127
    7696:	53 e4       	ldi	r21, 0x43	; 67
    7698:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    769c:	18 16       	cp	r1, r24
    769e:	0c f0       	brlt	.+2      	; 0x76a2 <FRAMTest3Channel+0xda>
    76a0:	10 e0       	ldi	r17, 0x00	; 0
    76a2:	11 23       	and	r17, r17
    76a4:	09 f4       	brne	.+2      	; 0x76a8 <FRAMTest3Channel+0xe0>
    76a6:	89 c0       	rjmp	.+274    	; 0x77ba <FRAMTest3Channel+0x1f2>
	{
		_delay_ms(__us / 1000.0);
    76a8:	69 81       	ldd	r22, Y+1	; 0x01
    76aa:	7a 81       	ldd	r23, Y+2	; 0x02
    76ac:	8b 81       	ldd	r24, Y+3	; 0x03
    76ae:	9c 81       	ldd	r25, Y+4	; 0x04
    76b0:	20 e0       	ldi	r18, 0x00	; 0
    76b2:	30 e0       	ldi	r19, 0x00	; 0
    76b4:	4a e7       	ldi	r20, 0x7A	; 122
    76b6:	54 e4       	ldi	r21, 0x44	; 68
    76b8:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
    76bc:	dc 01       	movw	r26, r24
    76be:	cb 01       	movw	r24, r22
    76c0:	8a 87       	std	Y+10, r24	; 0x0a
    76c2:	9b 87       	std	Y+11, r25	; 0x0b
    76c4:	ac 87       	std	Y+12, r26	; 0x0c
    76c6:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    76c8:	6a 85       	ldd	r22, Y+10	; 0x0a
    76ca:	7b 85       	ldd	r23, Y+11	; 0x0b
    76cc:	8c 85       	ldd	r24, Y+12	; 0x0c
    76ce:	9d 85       	ldd	r25, Y+13	; 0x0d
    76d0:	20 e0       	ldi	r18, 0x00	; 0
    76d2:	30 e0       	ldi	r19, 0x00	; 0
    76d4:	4a ef       	ldi	r20, 0xFA	; 250
    76d6:	55 e4       	ldi	r21, 0x45	; 69
    76d8:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    76dc:	dc 01       	movw	r26, r24
    76de:	cb 01       	movw	r24, r22
    76e0:	8e 87       	std	Y+14, r24	; 0x0e
    76e2:	9f 87       	std	Y+15, r25	; 0x0f
    76e4:	a8 8b       	std	Y+16, r26	; 0x10
    76e6:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    76e8:	11 e0       	ldi	r17, 0x01	; 1
    76ea:	6e 85       	ldd	r22, Y+14	; 0x0e
    76ec:	7f 85       	ldd	r23, Y+15	; 0x0f
    76ee:	88 89       	ldd	r24, Y+16	; 0x10
    76f0:	99 89       	ldd	r25, Y+17	; 0x11
    76f2:	20 e0       	ldi	r18, 0x00	; 0
    76f4:	30 e0       	ldi	r19, 0x00	; 0
    76f6:	40 e8       	ldi	r20, 0x80	; 128
    76f8:	5f e3       	ldi	r21, 0x3F	; 63
    76fa:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    76fe:	88 23       	and	r24, r24
    7700:	0c f0       	brlt	.+2      	; 0x7704 <FRAMTest3Channel+0x13c>
    7702:	10 e0       	ldi	r17, 0x00	; 0
    7704:	11 23       	and	r17, r17
    7706:	29 f0       	breq	.+10     	; 0x7712 <FRAMTest3Channel+0x14a>
		__ticks = 1;
    7708:	81 e0       	ldi	r24, 0x01	; 1
    770a:	90 e0       	ldi	r25, 0x00	; 0
    770c:	8a 8b       	std	Y+18, r24	; 0x12
    770e:	9b 8b       	std	Y+19, r25	; 0x13
    7710:	46 c0       	rjmp	.+140    	; 0x779e <FRAMTest3Channel+0x1d6>
	else if (__tmp > 65535)
    7712:	11 e0       	ldi	r17, 0x01	; 1
    7714:	6e 85       	ldd	r22, Y+14	; 0x0e
    7716:	7f 85       	ldd	r23, Y+15	; 0x0f
    7718:	88 89       	ldd	r24, Y+16	; 0x10
    771a:	99 89       	ldd	r25, Y+17	; 0x11
    771c:	20 e0       	ldi	r18, 0x00	; 0
    771e:	3f ef       	ldi	r19, 0xFF	; 255
    7720:	4f e7       	ldi	r20, 0x7F	; 127
    7722:	57 e4       	ldi	r21, 0x47	; 71
    7724:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    7728:	18 16       	cp	r1, r24
    772a:	0c f0       	brlt	.+2      	; 0x772e <FRAMTest3Channel+0x166>
    772c:	10 e0       	ldi	r17, 0x00	; 0
    772e:	11 23       	and	r17, r17
    7730:	61 f1       	breq	.+88     	; 0x778a <FRAMTest3Channel+0x1c2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7732:	6a 85       	ldd	r22, Y+10	; 0x0a
    7734:	7b 85       	ldd	r23, Y+11	; 0x0b
    7736:	8c 85       	ldd	r24, Y+12	; 0x0c
    7738:	9d 85       	ldd	r25, Y+13	; 0x0d
    773a:	20 e0       	ldi	r18, 0x00	; 0
    773c:	30 e0       	ldi	r19, 0x00	; 0
    773e:	40 e2       	ldi	r20, 0x20	; 32
    7740:	51 e4       	ldi	r21, 0x41	; 65
    7742:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    7746:	dc 01       	movw	r26, r24
    7748:	cb 01       	movw	r24, r22
    774a:	bc 01       	movw	r22, r24
    774c:	cd 01       	movw	r24, r26
    774e:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7752:	dc 01       	movw	r26, r24
    7754:	cb 01       	movw	r24, r22
    7756:	8a 8b       	std	Y+18, r24	; 0x12
    7758:	9b 8b       	std	Y+19, r25	; 0x13
    775a:	12 c0       	rjmp	.+36     	; 0x7780 <FRAMTest3Channel+0x1b8>
    775c:	80 e2       	ldi	r24, 0x20	; 32
    775e:	93 e0       	ldi	r25, 0x03	; 3
    7760:	8c 8b       	std	Y+20, r24	; 0x14
    7762:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7764:	8c 89       	ldd	r24, Y+20	; 0x14
    7766:	9d 89       	ldd	r25, Y+21	; 0x15
    7768:	8c 01       	movw	r16, r24
    776a:	c8 01       	movw	r24, r16
    776c:	01 97       	sbiw	r24, 0x01	; 1
    776e:	f1 f7       	brne	.-4      	; 0x776c <FRAMTest3Channel+0x1a4>
    7770:	8c 01       	movw	r16, r24
    7772:	0c 8b       	std	Y+20, r16	; 0x14
    7774:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7776:	8a 89       	ldd	r24, Y+18	; 0x12
    7778:	9b 89       	ldd	r25, Y+19	; 0x13
    777a:	01 97       	sbiw	r24, 0x01	; 1
    777c:	8a 8b       	std	Y+18, r24	; 0x12
    777e:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7780:	8a 89       	ldd	r24, Y+18	; 0x12
    7782:	9b 89       	ldd	r25, Y+19	; 0x13
    7784:	00 97       	sbiw	r24, 0x00	; 0
    7786:	51 f7       	brne	.-44     	; 0x775c <FRAMTest3Channel+0x194>
    7788:	28 c0       	rjmp	.+80     	; 0x77da <FRAMTest3Channel+0x212>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    778a:	6e 85       	ldd	r22, Y+14	; 0x0e
    778c:	7f 85       	ldd	r23, Y+15	; 0x0f
    778e:	88 89       	ldd	r24, Y+16	; 0x10
    7790:	99 89       	ldd	r25, Y+17	; 0x11
    7792:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7796:	dc 01       	movw	r26, r24
    7798:	cb 01       	movw	r24, r22
    779a:	8a 8b       	std	Y+18, r24	; 0x12
    779c:	9b 8b       	std	Y+19, r25	; 0x13
    779e:	8a 89       	ldd	r24, Y+18	; 0x12
    77a0:	9b 89       	ldd	r25, Y+19	; 0x13
    77a2:	8e 8b       	std	Y+22, r24	; 0x16
    77a4:	9f 8b       	std	Y+23, r25	; 0x17
    77a6:	8e 89       	ldd	r24, Y+22	; 0x16
    77a8:	9f 89       	ldd	r25, Y+23	; 0x17
    77aa:	8c 01       	movw	r16, r24
    77ac:	c8 01       	movw	r24, r16
    77ae:	01 97       	sbiw	r24, 0x01	; 1
    77b0:	f1 f7       	brne	.-4      	; 0x77ae <FRAMTest3Channel+0x1e6>
    77b2:	8c 01       	movw	r16, r24
    77b4:	0e 8b       	std	Y+22, r16	; 0x16
    77b6:	1f 8b       	std	Y+23, r17	; 0x17
    77b8:	10 c0       	rjmp	.+32     	; 0x77da <FRAMTest3Channel+0x212>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    77ba:	6d 81       	ldd	r22, Y+5	; 0x05
    77bc:	7e 81       	ldd	r23, Y+6	; 0x06
    77be:	8f 81       	ldd	r24, Y+7	; 0x07
    77c0:	98 85       	ldd	r25, Y+8	; 0x08
    77c2:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    77c6:	dc 01       	movw	r26, r24
    77c8:	cb 01       	movw	r24, r22
    77ca:	89 87       	std	Y+9, r24	; 0x09
    77cc:	89 85       	ldd	r24, Y+9	; 0x09
    77ce:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    77d0:	88 8d       	ldd	r24, Y+24	; 0x18
    77d2:	18 2f       	mov	r17, r24
    77d4:	1a 95       	dec	r17
    77d6:	f1 f7       	brne	.-4      	; 0x77d4 <FRAMTest3Channel+0x20c>
    77d8:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    77da:	0e 94 61 18 	call	0x30c2	; 0x30c2 <calcChecksumFRAM>

	ADCPower(FALSE);
    77de:	80 e0       	ldi	r24, 0x00	; 0
    77e0:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
	
}
    77e4:	6b 96       	adiw	r28, 0x1b	; 27
    77e6:	cd bf       	out	0x3d, r28	; 61
    77e8:	de bf       	out	0x3e, r29	; 62
    77ea:	df 91       	pop	r29
    77ec:	cf 91       	pop	r28
    77ee:	1f 91       	pop	r17
    77f0:	0f 91       	pop	r16
    77f2:	ff 90       	pop	r15
    77f4:	ef 90       	pop	r14
    77f6:	df 90       	pop	r13
    77f8:	cf 90       	pop	r12
    77fa:	bf 90       	pop	r11
    77fc:	af 90       	pop	r10
    77fe:	9f 90       	pop	r9
    7800:	8f 90       	pop	r8
    7802:	08 95       	ret

00007804 <FRAMTest1Channel>:

void FRAMTest1Channel(void) {
    7804:	8f 92       	push	r8
    7806:	9f 92       	push	r9
    7808:	af 92       	push	r10
    780a:	bf 92       	push	r11
    780c:	cf 92       	push	r12
    780e:	df 92       	push	r13
    7810:	ef 92       	push	r14
    7812:	0f 93       	push	r16
    7814:	1f 93       	push	r17
    7816:	cf 93       	push	r28
    7818:	df 93       	push	r29
    781a:	cd b7       	in	r28, 0x3d	; 61
    781c:	de b7       	in	r29, 0x3e	; 62
    781e:	68 97       	sbiw	r28, 0x18	; 24
    7820:	cd bf       	out	0x3d, r28	; 61
    7822:	de bf       	out	0x3e, r29	; 62

	CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
    7824:	0f 92       	push	r0
    7826:	0f 92       	push	r0
    7828:	8d b7       	in	r24, 0x3d	; 61
    782a:	9e b7       	in	r25, 0x3e	; 62
    782c:	01 96       	adiw	r24, 0x01	; 1
    782e:	20 e1       	ldi	r18, 0x10	; 16
    7830:	30 e0       	ldi	r19, 0x00	; 0
    7832:	fc 01       	movw	r30, r24
    7834:	20 83       	st	Z, r18
    7836:	31 83       	std	Z+1, r19	; 0x01
    7838:	87 e0       	ldi	r24, 0x07	; 7
    783a:	68 ec       	ldi	r22, 0xC8	; 200
    783c:	40 e0       	ldi	r20, 0x00	; 0
    783e:	20 e0       	ldi	r18, 0x00	; 0
    7840:	05 e1       	ldi	r16, 0x15	; 21
    7842:	ee 24       	eor	r14, r14
    7844:	e3 94       	inc	r14
    7846:	0f 2e       	mov	r0, r31
    7848:	fd e0       	ldi	r31, 0x0D	; 13
    784a:	cf 2e       	mov	r12, r31
    784c:	dd 24       	eor	r13, r13
    784e:	f0 2d       	mov	r31, r0
    7850:	0f 2e       	mov	r0, r31
    7852:	fe e0       	ldi	r31, 0x0E	; 14
    7854:	af 2e       	mov	r10, r31
    7856:	bb 24       	eor	r11, r11
    7858:	f0 2d       	mov	r31, r0
    785a:	0f 2e       	mov	r0, r31
    785c:	ff e0       	ldi	r31, 0x0F	; 15
    785e:	8f 2e       	mov	r8, r31
    7860:	99 24       	eor	r9, r9
    7862:	f0 2d       	mov	r31, r0
    7864:	0e 94 96 14 	call	0x292c	; 0x292c <CO_collectSeismic1Channel>
    7868:	0f 90       	pop	r0
    786a:	0f 90       	pop	r0
	GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    786c:	81 e0       	ldi	r24, 0x01	; 1
    786e:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
    7872:	80 e0       	ldi	r24, 0x00	; 0
    7874:	90 e0       	ldi	r25, 0x00	; 0
    7876:	aa e7       	ldi	r26, 0x7A	; 122
    7878:	b3 e4       	ldi	r27, 0x43	; 67
    787a:	89 83       	std	Y+1, r24	; 0x01
    787c:	9a 83       	std	Y+2, r25	; 0x02
    787e:	ab 83       	std	Y+3, r26	; 0x03
    7880:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7882:	69 81       	ldd	r22, Y+1	; 0x01
    7884:	7a 81       	ldd	r23, Y+2	; 0x02
    7886:	8b 81       	ldd	r24, Y+3	; 0x03
    7888:	9c 81       	ldd	r25, Y+4	; 0x04
    788a:	2b ea       	ldi	r18, 0xAB	; 171
    788c:	3a ea       	ldi	r19, 0xAA	; 170
    788e:	4a e2       	ldi	r20, 0x2A	; 42
    7890:	51 e4       	ldi	r21, 0x41	; 65
    7892:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    7896:	dc 01       	movw	r26, r24
    7898:	cb 01       	movw	r24, r22
    789a:	8d 83       	std	Y+5, r24	; 0x05
    789c:	9e 83       	std	Y+6, r25	; 0x06
    789e:	af 83       	std	Y+7, r26	; 0x07
    78a0:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    78a2:	11 e0       	ldi	r17, 0x01	; 1
    78a4:	6d 81       	ldd	r22, Y+5	; 0x05
    78a6:	7e 81       	ldd	r23, Y+6	; 0x06
    78a8:	8f 81       	ldd	r24, Y+7	; 0x07
    78aa:	98 85       	ldd	r25, Y+8	; 0x08
    78ac:	20 e0       	ldi	r18, 0x00	; 0
    78ae:	30 e0       	ldi	r19, 0x00	; 0
    78b0:	40 e8       	ldi	r20, 0x80	; 128
    78b2:	5f e3       	ldi	r21, 0x3F	; 63
    78b4:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    78b8:	88 23       	and	r24, r24
    78ba:	0c f0       	brlt	.+2      	; 0x78be <FRAMTest1Channel+0xba>
    78bc:	10 e0       	ldi	r17, 0x00	; 0
    78be:	11 23       	and	r17, r17
    78c0:	19 f0       	breq	.+6      	; 0x78c8 <FRAMTest1Channel+0xc4>
		__ticks = 1;
    78c2:	81 e0       	ldi	r24, 0x01	; 1
    78c4:	89 87       	std	Y+9, r24	; 0x09
    78c6:	a3 c0       	rjmp	.+326    	; 0x7a0e <FRAMTest1Channel+0x20a>
	else if (__tmp > 255)
    78c8:	11 e0       	ldi	r17, 0x01	; 1
    78ca:	6d 81       	ldd	r22, Y+5	; 0x05
    78cc:	7e 81       	ldd	r23, Y+6	; 0x06
    78ce:	8f 81       	ldd	r24, Y+7	; 0x07
    78d0:	98 85       	ldd	r25, Y+8	; 0x08
    78d2:	20 e0       	ldi	r18, 0x00	; 0
    78d4:	30 e0       	ldi	r19, 0x00	; 0
    78d6:	4f e7       	ldi	r20, 0x7F	; 127
    78d8:	53 e4       	ldi	r21, 0x43	; 67
    78da:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    78de:	18 16       	cp	r1, r24
    78e0:	0c f0       	brlt	.+2      	; 0x78e4 <FRAMTest1Channel+0xe0>
    78e2:	10 e0       	ldi	r17, 0x00	; 0
    78e4:	11 23       	and	r17, r17
    78e6:	09 f4       	brne	.+2      	; 0x78ea <FRAMTest1Channel+0xe6>
    78e8:	89 c0       	rjmp	.+274    	; 0x79fc <FRAMTest1Channel+0x1f8>
	{
		_delay_ms(__us / 1000.0);
    78ea:	69 81       	ldd	r22, Y+1	; 0x01
    78ec:	7a 81       	ldd	r23, Y+2	; 0x02
    78ee:	8b 81       	ldd	r24, Y+3	; 0x03
    78f0:	9c 81       	ldd	r25, Y+4	; 0x04
    78f2:	20 e0       	ldi	r18, 0x00	; 0
    78f4:	30 e0       	ldi	r19, 0x00	; 0
    78f6:	4a e7       	ldi	r20, 0x7A	; 122
    78f8:	54 e4       	ldi	r21, 0x44	; 68
    78fa:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
    78fe:	dc 01       	movw	r26, r24
    7900:	cb 01       	movw	r24, r22
    7902:	8a 87       	std	Y+10, r24	; 0x0a
    7904:	9b 87       	std	Y+11, r25	; 0x0b
    7906:	ac 87       	std	Y+12, r26	; 0x0c
    7908:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    790a:	6a 85       	ldd	r22, Y+10	; 0x0a
    790c:	7b 85       	ldd	r23, Y+11	; 0x0b
    790e:	8c 85       	ldd	r24, Y+12	; 0x0c
    7910:	9d 85       	ldd	r25, Y+13	; 0x0d
    7912:	20 e0       	ldi	r18, 0x00	; 0
    7914:	30 e0       	ldi	r19, 0x00	; 0
    7916:	4a ef       	ldi	r20, 0xFA	; 250
    7918:	55 e4       	ldi	r21, 0x45	; 69
    791a:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    791e:	dc 01       	movw	r26, r24
    7920:	cb 01       	movw	r24, r22
    7922:	8e 87       	std	Y+14, r24	; 0x0e
    7924:	9f 87       	std	Y+15, r25	; 0x0f
    7926:	a8 8b       	std	Y+16, r26	; 0x10
    7928:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    792a:	11 e0       	ldi	r17, 0x01	; 1
    792c:	6e 85       	ldd	r22, Y+14	; 0x0e
    792e:	7f 85       	ldd	r23, Y+15	; 0x0f
    7930:	88 89       	ldd	r24, Y+16	; 0x10
    7932:	99 89       	ldd	r25, Y+17	; 0x11
    7934:	20 e0       	ldi	r18, 0x00	; 0
    7936:	30 e0       	ldi	r19, 0x00	; 0
    7938:	40 e8       	ldi	r20, 0x80	; 128
    793a:	5f e3       	ldi	r21, 0x3F	; 63
    793c:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    7940:	88 23       	and	r24, r24
    7942:	0c f0       	brlt	.+2      	; 0x7946 <FRAMTest1Channel+0x142>
    7944:	10 e0       	ldi	r17, 0x00	; 0
    7946:	11 23       	and	r17, r17
    7948:	29 f0       	breq	.+10     	; 0x7954 <FRAMTest1Channel+0x150>
		__ticks = 1;
    794a:	81 e0       	ldi	r24, 0x01	; 1
    794c:	90 e0       	ldi	r25, 0x00	; 0
    794e:	8a 8b       	std	Y+18, r24	; 0x12
    7950:	9b 8b       	std	Y+19, r25	; 0x13
    7952:	46 c0       	rjmp	.+140    	; 0x79e0 <FRAMTest1Channel+0x1dc>
	else if (__tmp > 65535)
    7954:	11 e0       	ldi	r17, 0x01	; 1
    7956:	6e 85       	ldd	r22, Y+14	; 0x0e
    7958:	7f 85       	ldd	r23, Y+15	; 0x0f
    795a:	88 89       	ldd	r24, Y+16	; 0x10
    795c:	99 89       	ldd	r25, Y+17	; 0x11
    795e:	20 e0       	ldi	r18, 0x00	; 0
    7960:	3f ef       	ldi	r19, 0xFF	; 255
    7962:	4f e7       	ldi	r20, 0x7F	; 127
    7964:	57 e4       	ldi	r21, 0x47	; 71
    7966:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    796a:	18 16       	cp	r1, r24
    796c:	0c f0       	brlt	.+2      	; 0x7970 <FRAMTest1Channel+0x16c>
    796e:	10 e0       	ldi	r17, 0x00	; 0
    7970:	11 23       	and	r17, r17
    7972:	61 f1       	breq	.+88     	; 0x79cc <FRAMTest1Channel+0x1c8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7974:	6a 85       	ldd	r22, Y+10	; 0x0a
    7976:	7b 85       	ldd	r23, Y+11	; 0x0b
    7978:	8c 85       	ldd	r24, Y+12	; 0x0c
    797a:	9d 85       	ldd	r25, Y+13	; 0x0d
    797c:	20 e0       	ldi	r18, 0x00	; 0
    797e:	30 e0       	ldi	r19, 0x00	; 0
    7980:	40 e2       	ldi	r20, 0x20	; 32
    7982:	51 e4       	ldi	r21, 0x41	; 65
    7984:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    7988:	dc 01       	movw	r26, r24
    798a:	cb 01       	movw	r24, r22
    798c:	bc 01       	movw	r22, r24
    798e:	cd 01       	movw	r24, r26
    7990:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7994:	dc 01       	movw	r26, r24
    7996:	cb 01       	movw	r24, r22
    7998:	8a 8b       	std	Y+18, r24	; 0x12
    799a:	9b 8b       	std	Y+19, r25	; 0x13
    799c:	12 c0       	rjmp	.+36     	; 0x79c2 <FRAMTest1Channel+0x1be>
    799e:	80 e2       	ldi	r24, 0x20	; 32
    79a0:	93 e0       	ldi	r25, 0x03	; 3
    79a2:	8c 8b       	std	Y+20, r24	; 0x14
    79a4:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    79a6:	8c 89       	ldd	r24, Y+20	; 0x14
    79a8:	9d 89       	ldd	r25, Y+21	; 0x15
    79aa:	8c 01       	movw	r16, r24
    79ac:	c8 01       	movw	r24, r16
    79ae:	01 97       	sbiw	r24, 0x01	; 1
    79b0:	f1 f7       	brne	.-4      	; 0x79ae <FRAMTest1Channel+0x1aa>
    79b2:	8c 01       	movw	r16, r24
    79b4:	0c 8b       	std	Y+20, r16	; 0x14
    79b6:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    79b8:	8a 89       	ldd	r24, Y+18	; 0x12
    79ba:	9b 89       	ldd	r25, Y+19	; 0x13
    79bc:	01 97       	sbiw	r24, 0x01	; 1
    79be:	8a 8b       	std	Y+18, r24	; 0x12
    79c0:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    79c2:	8a 89       	ldd	r24, Y+18	; 0x12
    79c4:	9b 89       	ldd	r25, Y+19	; 0x13
    79c6:	00 97       	sbiw	r24, 0x00	; 0
    79c8:	51 f7       	brne	.-44     	; 0x799e <FRAMTest1Channel+0x19a>
    79ca:	28 c0       	rjmp	.+80     	; 0x7a1c <FRAMTest1Channel+0x218>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    79cc:	6e 85       	ldd	r22, Y+14	; 0x0e
    79ce:	7f 85       	ldd	r23, Y+15	; 0x0f
    79d0:	88 89       	ldd	r24, Y+16	; 0x10
    79d2:	99 89       	ldd	r25, Y+17	; 0x11
    79d4:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    79d8:	dc 01       	movw	r26, r24
    79da:	cb 01       	movw	r24, r22
    79dc:	8a 8b       	std	Y+18, r24	; 0x12
    79de:	9b 8b       	std	Y+19, r25	; 0x13
    79e0:	8a 89       	ldd	r24, Y+18	; 0x12
    79e2:	9b 89       	ldd	r25, Y+19	; 0x13
    79e4:	8e 8b       	std	Y+22, r24	; 0x16
    79e6:	9f 8b       	std	Y+23, r25	; 0x17
    79e8:	8e 89       	ldd	r24, Y+22	; 0x16
    79ea:	9f 89       	ldd	r25, Y+23	; 0x17
    79ec:	8c 01       	movw	r16, r24
    79ee:	f8 01       	movw	r30, r16
    79f0:	31 97       	sbiw	r30, 0x01	; 1
    79f2:	f1 f7       	brne	.-4      	; 0x79f0 <FRAMTest1Channel+0x1ec>
    79f4:	8f 01       	movw	r16, r30
    79f6:	0e 8b       	std	Y+22, r16	; 0x16
    79f8:	1f 8b       	std	Y+23, r17	; 0x17
    79fa:	10 c0       	rjmp	.+32     	; 0x7a1c <FRAMTest1Channel+0x218>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    79fc:	6d 81       	ldd	r22, Y+5	; 0x05
    79fe:	7e 81       	ldd	r23, Y+6	; 0x06
    7a00:	8f 81       	ldd	r24, Y+7	; 0x07
    7a02:	98 85       	ldd	r25, Y+8	; 0x08
    7a04:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7a08:	dc 01       	movw	r26, r24
    7a0a:	cb 01       	movw	r24, r22
    7a0c:	89 87       	std	Y+9, r24	; 0x09
    7a0e:	89 85       	ldd	r24, Y+9	; 0x09
    7a10:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7a12:	88 8d       	ldd	r24, Y+24	; 0x18
    7a14:	18 2f       	mov	r17, r24
    7a16:	1a 95       	dec	r17
    7a18:	f1 f7       	brne	.-4      	; 0x7a16 <FRAMTest1Channel+0x212>
    7a1a:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    7a1c:	0e 94 61 18 	call	0x30c2	; 0x30c2 <calcChecksumFRAM>

	ADCPower(FALSE);
    7a20:	80 e0       	ldi	r24, 0x00	; 0
    7a22:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>

}
    7a26:	68 96       	adiw	r28, 0x18	; 24
    7a28:	cd bf       	out	0x3d, r28	; 61
    7a2a:	de bf       	out	0x3e, r29	; 62
    7a2c:	df 91       	pop	r29
    7a2e:	cf 91       	pop	r28
    7a30:	1f 91       	pop	r17
    7a32:	0f 91       	pop	r16
    7a34:	ef 90       	pop	r14
    7a36:	df 90       	pop	r13
    7a38:	cf 90       	pop	r12
    7a3a:	bf 90       	pop	r11
    7a3c:	af 90       	pop	r10
    7a3e:	9f 90       	pop	r9
    7a40:	8f 90       	pop	r8
    7a42:	08 95       	ret

00007a44 <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
    7a44:	0f 93       	push	r16
    7a46:	1f 93       	push	r17
    7a48:	cf 93       	push	r28
    7a4a:	df 93       	push	r29
    7a4c:	cd b7       	in	r28, 0x3d	; 61
    7a4e:	de b7       	in	r29, 0x3e	; 62
    7a50:	68 97       	sbiw	r28, 0x18	; 24
    7a52:	cd bf       	out	0x3d, r28	; 61
    7a54:	de bf       	out	0x3e, r29	; 62
	FRAMWriteKnowns();
    7a56:	0e 94 69 1b 	call	0x36d2	; 0x36d2 <FRAMWriteKnowns>
	ADCPower(TRUE);
    7a5a:	81 e0       	ldi	r24, 0x01	; 1
    7a5c:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
    7a60:	80 e0       	ldi	r24, 0x00	; 0
    7a62:	90 e0       	ldi	r25, 0x00	; 0
    7a64:	aa e7       	ldi	r26, 0x7A	; 122
    7a66:	b3 e4       	ldi	r27, 0x43	; 67
    7a68:	89 83       	std	Y+1, r24	; 0x01
    7a6a:	9a 83       	std	Y+2, r25	; 0x02
    7a6c:	ab 83       	std	Y+3, r26	; 0x03
    7a6e:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7a70:	69 81       	ldd	r22, Y+1	; 0x01
    7a72:	7a 81       	ldd	r23, Y+2	; 0x02
    7a74:	8b 81       	ldd	r24, Y+3	; 0x03
    7a76:	9c 81       	ldd	r25, Y+4	; 0x04
    7a78:	2b ea       	ldi	r18, 0xAB	; 171
    7a7a:	3a ea       	ldi	r19, 0xAA	; 170
    7a7c:	4a e2       	ldi	r20, 0x2A	; 42
    7a7e:	51 e4       	ldi	r21, 0x41	; 65
    7a80:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    7a84:	dc 01       	movw	r26, r24
    7a86:	cb 01       	movw	r24, r22
    7a88:	8d 83       	std	Y+5, r24	; 0x05
    7a8a:	9e 83       	std	Y+6, r25	; 0x06
    7a8c:	af 83       	std	Y+7, r26	; 0x07
    7a8e:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7a90:	11 e0       	ldi	r17, 0x01	; 1
    7a92:	6d 81       	ldd	r22, Y+5	; 0x05
    7a94:	7e 81       	ldd	r23, Y+6	; 0x06
    7a96:	8f 81       	ldd	r24, Y+7	; 0x07
    7a98:	98 85       	ldd	r25, Y+8	; 0x08
    7a9a:	20 e0       	ldi	r18, 0x00	; 0
    7a9c:	30 e0       	ldi	r19, 0x00	; 0
    7a9e:	40 e8       	ldi	r20, 0x80	; 128
    7aa0:	5f e3       	ldi	r21, 0x3F	; 63
    7aa2:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    7aa6:	88 23       	and	r24, r24
    7aa8:	0c f0       	brlt	.+2      	; 0x7aac <FRAMWriteKnownsCheck+0x68>
    7aaa:	10 e0       	ldi	r17, 0x00	; 0
    7aac:	11 23       	and	r17, r17
    7aae:	19 f0       	breq	.+6      	; 0x7ab6 <FRAMWriteKnownsCheck+0x72>
		__ticks = 1;
    7ab0:	81 e0       	ldi	r24, 0x01	; 1
    7ab2:	89 87       	std	Y+9, r24	; 0x09
    7ab4:	a3 c0       	rjmp	.+326    	; 0x7bfc <FRAMWriteKnownsCheck+0x1b8>
	else if (__tmp > 255)
    7ab6:	11 e0       	ldi	r17, 0x01	; 1
    7ab8:	6d 81       	ldd	r22, Y+5	; 0x05
    7aba:	7e 81       	ldd	r23, Y+6	; 0x06
    7abc:	8f 81       	ldd	r24, Y+7	; 0x07
    7abe:	98 85       	ldd	r25, Y+8	; 0x08
    7ac0:	20 e0       	ldi	r18, 0x00	; 0
    7ac2:	30 e0       	ldi	r19, 0x00	; 0
    7ac4:	4f e7       	ldi	r20, 0x7F	; 127
    7ac6:	53 e4       	ldi	r21, 0x43	; 67
    7ac8:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    7acc:	18 16       	cp	r1, r24
    7ace:	0c f0       	brlt	.+2      	; 0x7ad2 <FRAMWriteKnownsCheck+0x8e>
    7ad0:	10 e0       	ldi	r17, 0x00	; 0
    7ad2:	11 23       	and	r17, r17
    7ad4:	09 f4       	brne	.+2      	; 0x7ad8 <FRAMWriteKnownsCheck+0x94>
    7ad6:	89 c0       	rjmp	.+274    	; 0x7bea <FRAMWriteKnownsCheck+0x1a6>
	{
		_delay_ms(__us / 1000.0);
    7ad8:	69 81       	ldd	r22, Y+1	; 0x01
    7ada:	7a 81       	ldd	r23, Y+2	; 0x02
    7adc:	8b 81       	ldd	r24, Y+3	; 0x03
    7ade:	9c 81       	ldd	r25, Y+4	; 0x04
    7ae0:	20 e0       	ldi	r18, 0x00	; 0
    7ae2:	30 e0       	ldi	r19, 0x00	; 0
    7ae4:	4a e7       	ldi	r20, 0x7A	; 122
    7ae6:	54 e4       	ldi	r21, 0x44	; 68
    7ae8:	0e 94 26 5d 	call	0xba4c	; 0xba4c <__divsf3>
    7aec:	dc 01       	movw	r26, r24
    7aee:	cb 01       	movw	r24, r22
    7af0:	8a 87       	std	Y+10, r24	; 0x0a
    7af2:	9b 87       	std	Y+11, r25	; 0x0b
    7af4:	ac 87       	std	Y+12, r26	; 0x0c
    7af6:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7af8:	6a 85       	ldd	r22, Y+10	; 0x0a
    7afa:	7b 85       	ldd	r23, Y+11	; 0x0b
    7afc:	8c 85       	ldd	r24, Y+12	; 0x0c
    7afe:	9d 85       	ldd	r25, Y+13	; 0x0d
    7b00:	20 e0       	ldi	r18, 0x00	; 0
    7b02:	30 e0       	ldi	r19, 0x00	; 0
    7b04:	4a ef       	ldi	r20, 0xFA	; 250
    7b06:	55 e4       	ldi	r21, 0x45	; 69
    7b08:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    7b0c:	dc 01       	movw	r26, r24
    7b0e:	cb 01       	movw	r24, r22
    7b10:	8e 87       	std	Y+14, r24	; 0x0e
    7b12:	9f 87       	std	Y+15, r25	; 0x0f
    7b14:	a8 8b       	std	Y+16, r26	; 0x10
    7b16:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    7b18:	11 e0       	ldi	r17, 0x01	; 1
    7b1a:	6e 85       	ldd	r22, Y+14	; 0x0e
    7b1c:	7f 85       	ldd	r23, Y+15	; 0x0f
    7b1e:	88 89       	ldd	r24, Y+16	; 0x10
    7b20:	99 89       	ldd	r25, Y+17	; 0x11
    7b22:	20 e0       	ldi	r18, 0x00	; 0
    7b24:	30 e0       	ldi	r19, 0x00	; 0
    7b26:	40 e8       	ldi	r20, 0x80	; 128
    7b28:	5f e3       	ldi	r21, 0x3F	; 63
    7b2a:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    7b2e:	88 23       	and	r24, r24
    7b30:	0c f0       	brlt	.+2      	; 0x7b34 <FRAMWriteKnownsCheck+0xf0>
    7b32:	10 e0       	ldi	r17, 0x00	; 0
    7b34:	11 23       	and	r17, r17
    7b36:	29 f0       	breq	.+10     	; 0x7b42 <FRAMWriteKnownsCheck+0xfe>
		__ticks = 1;
    7b38:	81 e0       	ldi	r24, 0x01	; 1
    7b3a:	90 e0       	ldi	r25, 0x00	; 0
    7b3c:	8a 8b       	std	Y+18, r24	; 0x12
    7b3e:	9b 8b       	std	Y+19, r25	; 0x13
    7b40:	46 c0       	rjmp	.+140    	; 0x7bce <FRAMWriteKnownsCheck+0x18a>
	else if (__tmp > 65535)
    7b42:	11 e0       	ldi	r17, 0x01	; 1
    7b44:	6e 85       	ldd	r22, Y+14	; 0x0e
    7b46:	7f 85       	ldd	r23, Y+15	; 0x0f
    7b48:	88 89       	ldd	r24, Y+16	; 0x10
    7b4a:	99 89       	ldd	r25, Y+17	; 0x11
    7b4c:	20 e0       	ldi	r18, 0x00	; 0
    7b4e:	3f ef       	ldi	r19, 0xFF	; 255
    7b50:	4f e7       	ldi	r20, 0x7F	; 127
    7b52:	57 e4       	ldi	r21, 0x47	; 71
    7b54:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    7b58:	18 16       	cp	r1, r24
    7b5a:	0c f0       	brlt	.+2      	; 0x7b5e <FRAMWriteKnownsCheck+0x11a>
    7b5c:	10 e0       	ldi	r17, 0x00	; 0
    7b5e:	11 23       	and	r17, r17
    7b60:	61 f1       	breq	.+88     	; 0x7bba <FRAMWriteKnownsCheck+0x176>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7b62:	6a 85       	ldd	r22, Y+10	; 0x0a
    7b64:	7b 85       	ldd	r23, Y+11	; 0x0b
    7b66:	8c 85       	ldd	r24, Y+12	; 0x0c
    7b68:	9d 85       	ldd	r25, Y+13	; 0x0d
    7b6a:	20 e0       	ldi	r18, 0x00	; 0
    7b6c:	30 e0       	ldi	r19, 0x00	; 0
    7b6e:	40 e2       	ldi	r20, 0x20	; 32
    7b70:	51 e4       	ldi	r21, 0x41	; 65
    7b72:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    7b76:	dc 01       	movw	r26, r24
    7b78:	cb 01       	movw	r24, r22
    7b7a:	bc 01       	movw	r22, r24
    7b7c:	cd 01       	movw	r24, r26
    7b7e:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7b82:	dc 01       	movw	r26, r24
    7b84:	cb 01       	movw	r24, r22
    7b86:	8a 8b       	std	Y+18, r24	; 0x12
    7b88:	9b 8b       	std	Y+19, r25	; 0x13
    7b8a:	12 c0       	rjmp	.+36     	; 0x7bb0 <FRAMWriteKnownsCheck+0x16c>
    7b8c:	80 e2       	ldi	r24, 0x20	; 32
    7b8e:	93 e0       	ldi	r25, 0x03	; 3
    7b90:	8c 8b       	std	Y+20, r24	; 0x14
    7b92:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7b94:	8c 89       	ldd	r24, Y+20	; 0x14
    7b96:	9d 89       	ldd	r25, Y+21	; 0x15
    7b98:	8c 01       	movw	r16, r24
    7b9a:	c8 01       	movw	r24, r16
    7b9c:	01 97       	sbiw	r24, 0x01	; 1
    7b9e:	f1 f7       	brne	.-4      	; 0x7b9c <FRAMWriteKnownsCheck+0x158>
    7ba0:	8c 01       	movw	r16, r24
    7ba2:	0c 8b       	std	Y+20, r16	; 0x14
    7ba4:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7ba6:	8a 89       	ldd	r24, Y+18	; 0x12
    7ba8:	9b 89       	ldd	r25, Y+19	; 0x13
    7baa:	01 97       	sbiw	r24, 0x01	; 1
    7bac:	8a 8b       	std	Y+18, r24	; 0x12
    7bae:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7bb0:	8a 89       	ldd	r24, Y+18	; 0x12
    7bb2:	9b 89       	ldd	r25, Y+19	; 0x13
    7bb4:	00 97       	sbiw	r24, 0x00	; 0
    7bb6:	51 f7       	brne	.-44     	; 0x7b8c <FRAMWriteKnownsCheck+0x148>
    7bb8:	28 c0       	rjmp	.+80     	; 0x7c0a <FRAMWriteKnownsCheck+0x1c6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7bba:	6e 85       	ldd	r22, Y+14	; 0x0e
    7bbc:	7f 85       	ldd	r23, Y+15	; 0x0f
    7bbe:	88 89       	ldd	r24, Y+16	; 0x10
    7bc0:	99 89       	ldd	r25, Y+17	; 0x11
    7bc2:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7bc6:	dc 01       	movw	r26, r24
    7bc8:	cb 01       	movw	r24, r22
    7bca:	8a 8b       	std	Y+18, r24	; 0x12
    7bcc:	9b 8b       	std	Y+19, r25	; 0x13
    7bce:	8a 89       	ldd	r24, Y+18	; 0x12
    7bd0:	9b 89       	ldd	r25, Y+19	; 0x13
    7bd2:	8e 8b       	std	Y+22, r24	; 0x16
    7bd4:	9f 8b       	std	Y+23, r25	; 0x17
    7bd6:	8e 89       	ldd	r24, Y+22	; 0x16
    7bd8:	9f 89       	ldd	r25, Y+23	; 0x17
    7bda:	8c 01       	movw	r16, r24
    7bdc:	c8 01       	movw	r24, r16
    7bde:	01 97       	sbiw	r24, 0x01	; 1
    7be0:	f1 f7       	brne	.-4      	; 0x7bde <FRAMWriteKnownsCheck+0x19a>
    7be2:	8c 01       	movw	r16, r24
    7be4:	0e 8b       	std	Y+22, r16	; 0x16
    7be6:	1f 8b       	std	Y+23, r17	; 0x17
    7be8:	10 c0       	rjmp	.+32     	; 0x7c0a <FRAMWriteKnownsCheck+0x1c6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7bea:	6d 81       	ldd	r22, Y+5	; 0x05
    7bec:	7e 81       	ldd	r23, Y+6	; 0x06
    7bee:	8f 81       	ldd	r24, Y+7	; 0x07
    7bf0:	98 85       	ldd	r25, Y+8	; 0x08
    7bf2:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7bf6:	dc 01       	movw	r26, r24
    7bf8:	cb 01       	movw	r24, r22
    7bfa:	89 87       	std	Y+9, r24	; 0x09
    7bfc:	89 85       	ldd	r24, Y+9	; 0x09
    7bfe:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7c00:	88 8d       	ldd	r24, Y+24	; 0x18
    7c02:	18 2f       	mov	r17, r24
    7c04:	1a 95       	dec	r17
    7c06:	f1 f7       	brne	.-4      	; 0x7c04 <FRAMWriteKnownsCheck+0x1c0>
    7c08:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(250);
	calcChecksumFRAM();
    7c0a:	0e 94 61 18 	call	0x30c2	; 0x30c2 <calcChecksumFRAM>

	ADCPower(FALSE);
    7c0e:	80 e0       	ldi	r24, 0x00	; 0
    7c10:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>

}
    7c14:	68 96       	adiw	r28, 0x18	; 24
    7c16:	cd bf       	out	0x3d, r28	; 61
    7c18:	de bf       	out	0x3e, r29	; 62
    7c1a:	df 91       	pop	r29
    7c1c:	cf 91       	pop	r28
    7c1e:	1f 91       	pop	r17
    7c20:	0f 91       	pop	r16
    7c22:	08 95       	ret

00007c24 <checkMote>:

//random function for testing stuff	
void checkMote(){
    7c24:	0f 93       	push	r16
    7c26:	1f 93       	push	r17
    7c28:	cf 93       	push	r28
    7c2a:	df 93       	push	r29
    7c2c:	cd b7       	in	r28, 0x3d	; 61
    7c2e:	de b7       	in	r29, 0x3e	; 62
    7c30:	aa 97       	sbiw	r28, 0x2a	; 42
    7c32:	cd bf       	out	0x3d, r28	; 61
    7c34:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);
    7c36:	81 e0       	ldi	r24, 0x01	; 1
    7c38:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
	Ext1Power(TRUE);
    7c3c:	81 e0       	ldi	r24, 0x01	; 1
    7c3e:	0e 94 cf 36 	call	0x6d9e	; 0x6d9e <Ext1Power>
    7c42:	80 e0       	ldi	r24, 0x00	; 0
    7c44:	90 e0       	ldi	r25, 0x00	; 0
    7c46:	a8 ec       	ldi	r26, 0xC8	; 200
    7c48:	b2 e4       	ldi	r27, 0x42	; 66
    7c4a:	89 83       	std	Y+1, r24	; 0x01
    7c4c:	9a 83       	std	Y+2, r25	; 0x02
    7c4e:	ab 83       	std	Y+3, r26	; 0x03
    7c50:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7c52:	69 81       	ldd	r22, Y+1	; 0x01
    7c54:	7a 81       	ldd	r23, Y+2	; 0x02
    7c56:	8b 81       	ldd	r24, Y+3	; 0x03
    7c58:	9c 81       	ldd	r25, Y+4	; 0x04
    7c5a:	20 e0       	ldi	r18, 0x00	; 0
    7c5c:	30 e0       	ldi	r19, 0x00	; 0
    7c5e:	4a ef       	ldi	r20, 0xFA	; 250
    7c60:	55 e4       	ldi	r21, 0x45	; 69
    7c62:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    7c66:	dc 01       	movw	r26, r24
    7c68:	cb 01       	movw	r24, r22
    7c6a:	8d 83       	std	Y+5, r24	; 0x05
    7c6c:	9e 83       	std	Y+6, r25	; 0x06
    7c6e:	af 83       	std	Y+7, r26	; 0x07
    7c70:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7c72:	11 e0       	ldi	r17, 0x01	; 1
    7c74:	6d 81       	ldd	r22, Y+5	; 0x05
    7c76:	7e 81       	ldd	r23, Y+6	; 0x06
    7c78:	8f 81       	ldd	r24, Y+7	; 0x07
    7c7a:	98 85       	ldd	r25, Y+8	; 0x08
    7c7c:	20 e0       	ldi	r18, 0x00	; 0
    7c7e:	30 e0       	ldi	r19, 0x00	; 0
    7c80:	40 e8       	ldi	r20, 0x80	; 128
    7c82:	5f e3       	ldi	r21, 0x3F	; 63
    7c84:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    7c88:	88 23       	and	r24, r24
    7c8a:	0c f0       	brlt	.+2      	; 0x7c8e <checkMote+0x6a>
    7c8c:	10 e0       	ldi	r17, 0x00	; 0
    7c8e:	11 23       	and	r17, r17
    7c90:	29 f0       	breq	.+10     	; 0x7c9c <checkMote+0x78>
		__ticks = 1;
    7c92:	81 e0       	ldi	r24, 0x01	; 1
    7c94:	90 e0       	ldi	r25, 0x00	; 0
    7c96:	89 87       	std	Y+9, r24	; 0x09
    7c98:	9a 87       	std	Y+10, r25	; 0x0a
    7c9a:	46 c0       	rjmp	.+140    	; 0x7d28 <checkMote+0x104>
	else if (__tmp > 65535)
    7c9c:	11 e0       	ldi	r17, 0x01	; 1
    7c9e:	6d 81       	ldd	r22, Y+5	; 0x05
    7ca0:	7e 81       	ldd	r23, Y+6	; 0x06
    7ca2:	8f 81       	ldd	r24, Y+7	; 0x07
    7ca4:	98 85       	ldd	r25, Y+8	; 0x08
    7ca6:	20 e0       	ldi	r18, 0x00	; 0
    7ca8:	3f ef       	ldi	r19, 0xFF	; 255
    7caa:	4f e7       	ldi	r20, 0x7F	; 127
    7cac:	57 e4       	ldi	r21, 0x47	; 71
    7cae:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    7cb2:	18 16       	cp	r1, r24
    7cb4:	0c f0       	brlt	.+2      	; 0x7cb8 <checkMote+0x94>
    7cb6:	10 e0       	ldi	r17, 0x00	; 0
    7cb8:	11 23       	and	r17, r17
    7cba:	61 f1       	breq	.+88     	; 0x7d14 <checkMote+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7cbc:	69 81       	ldd	r22, Y+1	; 0x01
    7cbe:	7a 81       	ldd	r23, Y+2	; 0x02
    7cc0:	8b 81       	ldd	r24, Y+3	; 0x03
    7cc2:	9c 81       	ldd	r25, Y+4	; 0x04
    7cc4:	20 e0       	ldi	r18, 0x00	; 0
    7cc6:	30 e0       	ldi	r19, 0x00	; 0
    7cc8:	40 e2       	ldi	r20, 0x20	; 32
    7cca:	51 e4       	ldi	r21, 0x41	; 65
    7ccc:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    7cd0:	dc 01       	movw	r26, r24
    7cd2:	cb 01       	movw	r24, r22
    7cd4:	bc 01       	movw	r22, r24
    7cd6:	cd 01       	movw	r24, r26
    7cd8:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7cdc:	dc 01       	movw	r26, r24
    7cde:	cb 01       	movw	r24, r22
    7ce0:	89 87       	std	Y+9, r24	; 0x09
    7ce2:	9a 87       	std	Y+10, r25	; 0x0a
    7ce4:	12 c0       	rjmp	.+36     	; 0x7d0a <checkMote+0xe6>
    7ce6:	80 e2       	ldi	r24, 0x20	; 32
    7ce8:	93 e0       	ldi	r25, 0x03	; 3
    7cea:	8b 87       	std	Y+11, r24	; 0x0b
    7cec:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7cee:	8b 85       	ldd	r24, Y+11	; 0x0b
    7cf0:	9c 85       	ldd	r25, Y+12	; 0x0c
    7cf2:	8c 01       	movw	r16, r24
    7cf4:	c8 01       	movw	r24, r16
    7cf6:	01 97       	sbiw	r24, 0x01	; 1
    7cf8:	f1 f7       	brne	.-4      	; 0x7cf6 <checkMote+0xd2>
    7cfa:	8c 01       	movw	r16, r24
    7cfc:	0b 87       	std	Y+11, r16	; 0x0b
    7cfe:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7d00:	89 85       	ldd	r24, Y+9	; 0x09
    7d02:	9a 85       	ldd	r25, Y+10	; 0x0a
    7d04:	01 97       	sbiw	r24, 0x01	; 1
    7d06:	89 87       	std	Y+9, r24	; 0x09
    7d08:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7d0a:	89 85       	ldd	r24, Y+9	; 0x09
    7d0c:	9a 85       	ldd	r25, Y+10	; 0x0a
    7d0e:	00 97       	sbiw	r24, 0x00	; 0
    7d10:	51 f7       	brne	.-44     	; 0x7ce6 <checkMote+0xc2>
    7d12:	17 c0       	rjmp	.+46     	; 0x7d42 <checkMote+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7d14:	6d 81       	ldd	r22, Y+5	; 0x05
    7d16:	7e 81       	ldd	r23, Y+6	; 0x06
    7d18:	8f 81       	ldd	r24, Y+7	; 0x07
    7d1a:	98 85       	ldd	r25, Y+8	; 0x08
    7d1c:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7d20:	dc 01       	movw	r26, r24
    7d22:	cb 01       	movw	r24, r22
    7d24:	89 87       	std	Y+9, r24	; 0x09
    7d26:	9a 87       	std	Y+10, r25	; 0x0a
    7d28:	89 85       	ldd	r24, Y+9	; 0x09
    7d2a:	9a 85       	ldd	r25, Y+10	; 0x0a
    7d2c:	8d 87       	std	Y+13, r24	; 0x0d
    7d2e:	9e 87       	std	Y+14, r25	; 0x0e
    7d30:	8d 85       	ldd	r24, Y+13	; 0x0d
    7d32:	9e 85       	ldd	r25, Y+14	; 0x0e
    7d34:	8c 01       	movw	r16, r24
    7d36:	c8 01       	movw	r24, r16
    7d38:	01 97       	sbiw	r24, 0x01	; 1
    7d3a:	f1 f7       	brne	.-4      	; 0x7d38 <checkMote+0x114>
    7d3c:	8c 01       	movw	r16, r24
    7d3e:	0d 87       	std	Y+13, r16	; 0x0d
    7d40:	1e 87       	std	Y+14, r17	; 0x0e
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    7d42:	88 e0       	ldi	r24, 0x08	; 8
    7d44:	60 e0       	ldi	r22, 0x00	; 0
    7d46:	0e 94 39 35 	call	0x6a72	; 0x6a72 <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    7d4a:	88 e0       	ldi	r24, 0x08	; 8
    7d4c:	60 e0       	ldi	r22, 0x00	; 0
    7d4e:	0e 94 05 36 	call	0x6c0a	; 0x6c0a <PortEx_OUTSET>
    7d52:	80 e0       	ldi	r24, 0x00	; 0
    7d54:	90 e4       	ldi	r25, 0x40	; 64
    7d56:	ac e9       	ldi	r26, 0x9C	; 156
    7d58:	b5 e4       	ldi	r27, 0x45	; 69
    7d5a:	8f 87       	std	Y+15, r24	; 0x0f
    7d5c:	98 8b       	std	Y+16, r25	; 0x10
    7d5e:	a9 8b       	std	Y+17, r26	; 0x11
    7d60:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7d62:	6f 85       	ldd	r22, Y+15	; 0x0f
    7d64:	78 89       	ldd	r23, Y+16	; 0x10
    7d66:	89 89       	ldd	r24, Y+17	; 0x11
    7d68:	9a 89       	ldd	r25, Y+18	; 0x12
    7d6a:	20 e0       	ldi	r18, 0x00	; 0
    7d6c:	30 e0       	ldi	r19, 0x00	; 0
    7d6e:	4a ef       	ldi	r20, 0xFA	; 250
    7d70:	55 e4       	ldi	r21, 0x45	; 69
    7d72:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    7d76:	dc 01       	movw	r26, r24
    7d78:	cb 01       	movw	r24, r22
    7d7a:	8b 8b       	std	Y+19, r24	; 0x13
    7d7c:	9c 8b       	std	Y+20, r25	; 0x14
    7d7e:	ad 8b       	std	Y+21, r26	; 0x15
    7d80:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    7d82:	11 e0       	ldi	r17, 0x01	; 1
    7d84:	6b 89       	ldd	r22, Y+19	; 0x13
    7d86:	7c 89       	ldd	r23, Y+20	; 0x14
    7d88:	8d 89       	ldd	r24, Y+21	; 0x15
    7d8a:	9e 89       	ldd	r25, Y+22	; 0x16
    7d8c:	20 e0       	ldi	r18, 0x00	; 0
    7d8e:	30 e0       	ldi	r19, 0x00	; 0
    7d90:	40 e8       	ldi	r20, 0x80	; 128
    7d92:	5f e3       	ldi	r21, 0x3F	; 63
    7d94:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    7d98:	88 23       	and	r24, r24
    7d9a:	0c f0       	brlt	.+2      	; 0x7d9e <checkMote+0x17a>
    7d9c:	10 e0       	ldi	r17, 0x00	; 0
    7d9e:	11 23       	and	r17, r17
    7da0:	29 f0       	breq	.+10     	; 0x7dac <checkMote+0x188>
		__ticks = 1;
    7da2:	81 e0       	ldi	r24, 0x01	; 1
    7da4:	90 e0       	ldi	r25, 0x00	; 0
    7da6:	8f 8b       	std	Y+23, r24	; 0x17
    7da8:	98 8f       	std	Y+24, r25	; 0x18
    7daa:	46 c0       	rjmp	.+140    	; 0x7e38 <checkMote+0x214>
	else if (__tmp > 65535)
    7dac:	11 e0       	ldi	r17, 0x01	; 1
    7dae:	6b 89       	ldd	r22, Y+19	; 0x13
    7db0:	7c 89       	ldd	r23, Y+20	; 0x14
    7db2:	8d 89       	ldd	r24, Y+21	; 0x15
    7db4:	9e 89       	ldd	r25, Y+22	; 0x16
    7db6:	20 e0       	ldi	r18, 0x00	; 0
    7db8:	3f ef       	ldi	r19, 0xFF	; 255
    7dba:	4f e7       	ldi	r20, 0x7F	; 127
    7dbc:	57 e4       	ldi	r21, 0x47	; 71
    7dbe:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    7dc2:	18 16       	cp	r1, r24
    7dc4:	0c f0       	brlt	.+2      	; 0x7dc8 <checkMote+0x1a4>
    7dc6:	10 e0       	ldi	r17, 0x00	; 0
    7dc8:	11 23       	and	r17, r17
    7dca:	61 f1       	breq	.+88     	; 0x7e24 <checkMote+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7dcc:	6f 85       	ldd	r22, Y+15	; 0x0f
    7dce:	78 89       	ldd	r23, Y+16	; 0x10
    7dd0:	89 89       	ldd	r24, Y+17	; 0x11
    7dd2:	9a 89       	ldd	r25, Y+18	; 0x12
    7dd4:	20 e0       	ldi	r18, 0x00	; 0
    7dd6:	30 e0       	ldi	r19, 0x00	; 0
    7dd8:	40 e2       	ldi	r20, 0x20	; 32
    7dda:	51 e4       	ldi	r21, 0x41	; 65
    7ddc:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    7de0:	dc 01       	movw	r26, r24
    7de2:	cb 01       	movw	r24, r22
    7de4:	bc 01       	movw	r22, r24
    7de6:	cd 01       	movw	r24, r26
    7de8:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7dec:	dc 01       	movw	r26, r24
    7dee:	cb 01       	movw	r24, r22
    7df0:	8f 8b       	std	Y+23, r24	; 0x17
    7df2:	98 8f       	std	Y+24, r25	; 0x18
    7df4:	12 c0       	rjmp	.+36     	; 0x7e1a <checkMote+0x1f6>
    7df6:	80 e2       	ldi	r24, 0x20	; 32
    7df8:	93 e0       	ldi	r25, 0x03	; 3
    7dfa:	89 8f       	std	Y+25, r24	; 0x19
    7dfc:	9a 8f       	std	Y+26, r25	; 0x1a
    7dfe:	89 8d       	ldd	r24, Y+25	; 0x19
    7e00:	9a 8d       	ldd	r25, Y+26	; 0x1a
    7e02:	8c 01       	movw	r16, r24
    7e04:	c8 01       	movw	r24, r16
    7e06:	01 97       	sbiw	r24, 0x01	; 1
    7e08:	f1 f7       	brne	.-4      	; 0x7e06 <checkMote+0x1e2>
    7e0a:	8c 01       	movw	r16, r24
    7e0c:	09 8f       	std	Y+25, r16	; 0x19
    7e0e:	1a 8f       	std	Y+26, r17	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7e10:	8f 89       	ldd	r24, Y+23	; 0x17
    7e12:	98 8d       	ldd	r25, Y+24	; 0x18
    7e14:	01 97       	sbiw	r24, 0x01	; 1
    7e16:	8f 8b       	std	Y+23, r24	; 0x17
    7e18:	98 8f       	std	Y+24, r25	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7e1a:	8f 89       	ldd	r24, Y+23	; 0x17
    7e1c:	98 8d       	ldd	r25, Y+24	; 0x18
    7e1e:	00 97       	sbiw	r24, 0x00	; 0
    7e20:	51 f7       	brne	.-44     	; 0x7df6 <checkMote+0x1d2>
    7e22:	17 c0       	rjmp	.+46     	; 0x7e52 <checkMote+0x22e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7e24:	6b 89       	ldd	r22, Y+19	; 0x13
    7e26:	7c 89       	ldd	r23, Y+20	; 0x14
    7e28:	8d 89       	ldd	r24, Y+21	; 0x15
    7e2a:	9e 89       	ldd	r25, Y+22	; 0x16
    7e2c:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7e30:	dc 01       	movw	r26, r24
    7e32:	cb 01       	movw	r24, r22
    7e34:	8f 8b       	std	Y+23, r24	; 0x17
    7e36:	98 8f       	std	Y+24, r25	; 0x18
    7e38:	8f 89       	ldd	r24, Y+23	; 0x17
    7e3a:	98 8d       	ldd	r25, Y+24	; 0x18
    7e3c:	8b 8f       	std	Y+27, r24	; 0x1b
    7e3e:	9c 8f       	std	Y+28, r25	; 0x1c
    7e40:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7e42:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7e44:	8c 01       	movw	r16, r24
    7e46:	c8 01       	movw	r24, r16
    7e48:	01 97       	sbiw	r24, 0x01	; 1
    7e4a:	f1 f7       	brne	.-4      	; 0x7e48 <checkMote+0x224>
    7e4c:	8c 01       	movw	r16, r24
    7e4e:	0b 8f       	std	Y+27, r16	; 0x1b
    7e50:	1c 8f       	std	Y+28, r17	; 0x1c
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    7e52:	88 e0       	ldi	r24, 0x08	; 8
    7e54:	60 e0       	ldi	r22, 0x00	; 0
    7e56:	0e 94 68 36 	call	0x6cd0	; 0x6cd0 <PortEx_OUTCLR>
    7e5a:	80 e0       	ldi	r24, 0x00	; 0
    7e5c:	90 e4       	ldi	r25, 0x40	; 64
    7e5e:	ac e9       	ldi	r26, 0x9C	; 156
    7e60:	b5 e4       	ldi	r27, 0x45	; 69
    7e62:	8d 8f       	std	Y+29, r24	; 0x1d
    7e64:	9e 8f       	std	Y+30, r25	; 0x1e
    7e66:	af 8f       	std	Y+31, r26	; 0x1f
    7e68:	b8 a3       	lds	r27, 0x58
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7e6a:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7e6c:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7e6e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7e70:	98 a1       	lds	r25, 0x48
    7e72:	20 e0       	ldi	r18, 0x00	; 0
    7e74:	30 e0       	ldi	r19, 0x00	; 0
    7e76:	4a ef       	ldi	r20, 0xFA	; 250
    7e78:	55 e4       	ldi	r21, 0x45	; 69
    7e7a:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    7e7e:	dc 01       	movw	r26, r24
    7e80:	cb 01       	movw	r24, r22
    7e82:	89 a3       	lds	r24, 0x59
    7e84:	9a a3       	lds	r25, 0x5a
    7e86:	ab a3       	lds	r26, 0x5b
    7e88:	bc a3       	lds	r27, 0x5c
	if (__tmp < 1.0)
    7e8a:	11 e0       	ldi	r17, 0x01	; 1
    7e8c:	69 a1       	lds	r22, 0x49
    7e8e:	7a a1       	lds	r23, 0x4a
    7e90:	8b a1       	lds	r24, 0x4b
    7e92:	9c a1       	lds	r25, 0x4c
    7e94:	20 e0       	ldi	r18, 0x00	; 0
    7e96:	30 e0       	ldi	r19, 0x00	; 0
    7e98:	40 e8       	ldi	r20, 0x80	; 128
    7e9a:	5f e3       	ldi	r21, 0x3F	; 63
    7e9c:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    7ea0:	88 23       	and	r24, r24
    7ea2:	0c f0       	brlt	.+2      	; 0x7ea6 <checkMote+0x282>
    7ea4:	10 e0       	ldi	r17, 0x00	; 0
    7ea6:	11 23       	and	r17, r17
    7ea8:	29 f0       	breq	.+10     	; 0x7eb4 <checkMote+0x290>
		__ticks = 1;
    7eaa:	81 e0       	ldi	r24, 0x01	; 1
    7eac:	90 e0       	ldi	r25, 0x00	; 0
    7eae:	8d a3       	lds	r24, 0x5d
    7eb0:	9e a3       	lds	r25, 0x5e
    7eb2:	46 c0       	rjmp	.+140    	; 0x7f40 <checkMote+0x31c>
	else if (__tmp > 65535)
    7eb4:	11 e0       	ldi	r17, 0x01	; 1
    7eb6:	69 a1       	lds	r22, 0x49
    7eb8:	7a a1       	lds	r23, 0x4a
    7eba:	8b a1       	lds	r24, 0x4b
    7ebc:	9c a1       	lds	r25, 0x4c
    7ebe:	20 e0       	ldi	r18, 0x00	; 0
    7ec0:	3f ef       	ldi	r19, 0xFF	; 255
    7ec2:	4f e7       	ldi	r20, 0x7F	; 127
    7ec4:	57 e4       	ldi	r21, 0x47	; 71
    7ec6:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    7eca:	18 16       	cp	r1, r24
    7ecc:	0c f0       	brlt	.+2      	; 0x7ed0 <checkMote+0x2ac>
    7ece:	10 e0       	ldi	r17, 0x00	; 0
    7ed0:	11 23       	and	r17, r17
    7ed2:	61 f1       	breq	.+88     	; 0x7f2c <checkMote+0x308>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7ed4:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7ed6:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7ed8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7eda:	98 a1       	lds	r25, 0x48
    7edc:	20 e0       	ldi	r18, 0x00	; 0
    7ede:	30 e0       	ldi	r19, 0x00	; 0
    7ee0:	40 e2       	ldi	r20, 0x20	; 32
    7ee2:	51 e4       	ldi	r21, 0x41	; 65
    7ee4:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    7ee8:	dc 01       	movw	r26, r24
    7eea:	cb 01       	movw	r24, r22
    7eec:	bc 01       	movw	r22, r24
    7eee:	cd 01       	movw	r24, r26
    7ef0:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7ef4:	dc 01       	movw	r26, r24
    7ef6:	cb 01       	movw	r24, r22
    7ef8:	8d a3       	lds	r24, 0x5d
    7efa:	9e a3       	lds	r25, 0x5e
    7efc:	12 c0       	rjmp	.+36     	; 0x7f22 <checkMote+0x2fe>
    7efe:	80 e2       	ldi	r24, 0x20	; 32
    7f00:	93 e0       	ldi	r25, 0x03	; 3
    7f02:	8f a3       	lds	r24, 0x5f
    7f04:	98 a7       	lds	r25, 0x78
    7f06:	8f a1       	lds	r24, 0x4f
    7f08:	98 a5       	lds	r25, 0x68
    7f0a:	8c 01       	movw	r16, r24
    7f0c:	c8 01       	movw	r24, r16
    7f0e:	01 97       	sbiw	r24, 0x01	; 1
    7f10:	f1 f7       	brne	.-4      	; 0x7f0e <checkMote+0x2ea>
    7f12:	8c 01       	movw	r16, r24
    7f14:	0f a3       	lds	r16, 0x5f
    7f16:	18 a7       	lds	r17, 0x78
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7f18:	8d a1       	lds	r24, 0x4d
    7f1a:	9e a1       	lds	r25, 0x4e
    7f1c:	01 97       	sbiw	r24, 0x01	; 1
    7f1e:	8d a3       	lds	r24, 0x5d
    7f20:	9e a3       	lds	r25, 0x5e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7f22:	8d a1       	lds	r24, 0x4d
    7f24:	9e a1       	lds	r25, 0x4e
    7f26:	00 97       	sbiw	r24, 0x00	; 0
    7f28:	51 f7       	brne	.-44     	; 0x7efe <checkMote+0x2da>
    7f2a:	18 c0       	rjmp	.+48     	; 0x7f5c <checkMote+0x338>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7f2c:	69 a1       	lds	r22, 0x49
    7f2e:	7a a1       	lds	r23, 0x4a
    7f30:	8b a1       	lds	r24, 0x4b
    7f32:	9c a1       	lds	r25, 0x4c
    7f34:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    7f38:	dc 01       	movw	r26, r24
    7f3a:	cb 01       	movw	r24, r22
    7f3c:	8d a3       	lds	r24, 0x5d
    7f3e:	9e a3       	lds	r25, 0x5e
    7f40:	8d a1       	lds	r24, 0x4d
    7f42:	9e a1       	lds	r25, 0x4e
    7f44:	89 a7       	lds	r24, 0x79
    7f46:	9a a7       	lds	r25, 0x7a
    7f48:	89 a5       	lds	r24, 0x69
    7f4a:	9a a5       	lds	r25, 0x6a
    7f4c:	8c 01       	movw	r16, r24
    7f4e:	c8 01       	movw	r24, r16
    7f50:	01 97       	sbiw	r24, 0x01	; 1
    7f52:	f1 f7       	brne	.-4      	; 0x7f50 <checkMote+0x32c>
    7f54:	8c 01       	movw	r16, r24
    7f56:	09 a7       	lds	r16, 0x79
    7f58:	1a a7       	lds	r17, 0x7a
		_delay_ms(5000);
	}
    7f5a:	f7 ce       	rjmp	.-530    	; 0x7d4a <checkMote+0x126>
    7f5c:	f6 ce       	rjmp	.-532    	; 0x7d4a <checkMote+0x126>

00007f5e <SD_write_and_read_knowns>:
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    7f5e:	cf 93       	push	r28
    7f60:	df 93       	push	r29
    7f62:	cd b7       	in	r28, 0x3d	; 61
    7f64:	de b7       	in	r29, 0x3e	; 62
    7f66:	28 97       	sbiw	r28, 0x08	; 8
    7f68:	cd bf       	out	0x3d, r28	; 61
    7f6a:	de bf       	out	0x3e, r29	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7f6c:	19 82       	std	Y+1, r1	; 0x01
    7f6e:	1a 82       	std	Y+2, r1	; 0x02
    7f70:	0c c0       	rjmp	.+24     	; 0x7f8a <SD_write_and_read_knowns+0x2c>
    7f72:	29 81       	ldd	r18, Y+1	; 0x01
    7f74:	89 81       	ldd	r24, Y+1	; 0x01
    7f76:	9a 81       	ldd	r25, Y+2	; 0x02
    7f78:	80 52       	subi	r24, 0x20	; 32
    7f7a:	9c 4d       	sbci	r25, 0xDC	; 220
    7f7c:	fc 01       	movw	r30, r24
    7f7e:	20 83       	st	Z, r18
    7f80:	89 81       	ldd	r24, Y+1	; 0x01
    7f82:	9a 81       	ldd	r25, Y+2	; 0x02
    7f84:	01 96       	adiw	r24, 0x01	; 1
    7f86:	89 83       	std	Y+1, r24	; 0x01
    7f88:	9a 83       	std	Y+2, r25	; 0x02
    7f8a:	89 81       	ldd	r24, Y+1	; 0x01
    7f8c:	9a 81       	ldd	r25, Y+2	; 0x02
    7f8e:	88 31       	cpi	r24, 0x18	; 24
    7f90:	91 05       	cpc	r25, r1
    7f92:	7c f3       	brlt	.-34     	; 0x7f72 <SD_write_and_read_knowns+0x14>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    7f94:	20 ee       	ldi	r18, 0xE0	; 224
    7f96:	33 e2       	ldi	r19, 0x23	; 35
    7f98:	64 e1       	ldi	r22, 0x14	; 20
    7f9a:	70 e0       	ldi	r23, 0x00	; 0
    7f9c:	80 e0       	ldi	r24, 0x00	; 0
    7f9e:	90 e0       	ldi	r25, 0x00	; 0
    7fa0:	a9 01       	movw	r20, r18
    7fa2:	28 e1       	ldi	r18, 0x18	; 24
    7fa4:	30 e0       	ldi	r19, 0x00	; 0
    7fa6:	0e 94 47 50 	call	0xa08e	; 0xa08e <SD_write_block>
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7faa:	1b 82       	std	Y+3, r1	; 0x03
    7fac:	1c 82       	std	Y+4, r1	; 0x04
    7fae:	0b c0       	rjmp	.+22     	; 0x7fc6 <SD_write_and_read_knowns+0x68>
    7fb0:	8b 81       	ldd	r24, Y+3	; 0x03
    7fb2:	9c 81       	ldd	r25, Y+4	; 0x04
    7fb4:	80 52       	subi	r24, 0x20	; 32
    7fb6:	9c 4d       	sbci	r25, 0xDC	; 220
    7fb8:	fc 01       	movw	r30, r24
    7fba:	10 82       	st	Z, r1
    7fbc:	8b 81       	ldd	r24, Y+3	; 0x03
    7fbe:	9c 81       	ldd	r25, Y+4	; 0x04
    7fc0:	01 96       	adiw	r24, 0x01	; 1
    7fc2:	8b 83       	std	Y+3, r24	; 0x03
    7fc4:	9c 83       	std	Y+4, r25	; 0x04
    7fc6:	8b 81       	ldd	r24, Y+3	; 0x03
    7fc8:	9c 81       	ldd	r25, Y+4	; 0x04
    7fca:	88 31       	cpi	r24, 0x18	; 24
    7fcc:	91 05       	cpc	r25, r1
    7fce:	84 f3       	brlt	.-32     	; 0x7fb0 <SD_write_and_read_knowns+0x52>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    7fd0:	20 ee       	ldi	r18, 0xE0	; 224
    7fd2:	33 e2       	ldi	r19, 0x23	; 35
    7fd4:	64 e1       	ldi	r22, 0x14	; 20
    7fd6:	70 e0       	ldi	r23, 0x00	; 0
    7fd8:	80 e0       	ldi	r24, 0x00	; 0
    7fda:	90 e0       	ldi	r25, 0x00	; 0
    7fdc:	a9 01       	movw	r20, r18
    7fde:	0e 94 15 51 	call	0xa22a	; 0xa22a <SD_read_block>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    7fe2:	1d 82       	std	Y+5, r1	; 0x05
    7fe4:	1e 82       	std	Y+6, r1	; 0x06
    7fe6:	13 c0       	rjmp	.+38     	; 0x800e <SD_write_and_read_knowns+0xb0>
    7fe8:	8d 81       	ldd	r24, Y+5	; 0x05
    7fea:	9e 81       	ldd	r25, Y+6	; 0x06
    7fec:	24 e6       	ldi	r18, 0x64	; 100
    7fee:	30 e0       	ldi	r19, 0x00	; 0
    7ff0:	b9 01       	movw	r22, r18
    7ff2:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__divmodhi4>
    7ff6:	28 2f       	mov	r18, r24
    7ff8:	8d 81       	ldd	r24, Y+5	; 0x05
    7ffa:	9e 81       	ldd	r25, Y+6	; 0x06
    7ffc:	80 52       	subi	r24, 0x20	; 32
    7ffe:	9c 4d       	sbci	r25, 0xDC	; 220
    8000:	fc 01       	movw	r30, r24
    8002:	20 83       	st	Z, r18
    8004:	8d 81       	ldd	r24, Y+5	; 0x05
    8006:	9e 81       	ldd	r25, Y+6	; 0x06
    8008:	01 96       	adiw	r24, 0x01	; 1
    800a:	8d 83       	std	Y+5, r24	; 0x05
    800c:	9e 83       	std	Y+6, r25	; 0x06
    800e:	8d 81       	ldd	r24, Y+5	; 0x05
    8010:	9e 81       	ldd	r25, Y+6	; 0x06
    8012:	f4 e0       	ldi	r31, 0x04	; 4
    8014:	82 3e       	cpi	r24, 0xE2	; 226
    8016:	9f 07       	cpc	r25, r31
    8018:	3c f3       	brlt	.-50     	; 0x7fe8 <SD_write_and_read_knowns+0x8a>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    801a:	20 ee       	ldi	r18, 0xE0	; 224
    801c:	33 e2       	ldi	r19, 0x23	; 35
    801e:	60 e5       	ldi	r22, 0x50	; 80
    8020:	70 e0       	ldi	r23, 0x00	; 0
    8022:	80 e0       	ldi	r24, 0x00	; 0
    8024:	90 e0       	ldi	r25, 0x00	; 0
    8026:	a9 01       	movw	r20, r18
    8028:	22 ee       	ldi	r18, 0xE2	; 226
    802a:	34 e0       	ldi	r19, 0x04	; 4
    802c:	0e 94 8b 51 	call	0xa316	; 0xa316 <SD_write_multiple_blocks>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    8030:	1f 82       	std	Y+7, r1	; 0x07
    8032:	18 86       	std	Y+8, r1	; 0x08
    8034:	0b c0       	rjmp	.+22     	; 0x804c <SD_write_and_read_knowns+0xee>
    8036:	8f 81       	ldd	r24, Y+7	; 0x07
    8038:	98 85       	ldd	r25, Y+8	; 0x08
    803a:	80 52       	subi	r24, 0x20	; 32
    803c:	9c 4d       	sbci	r25, 0xDC	; 220
    803e:	fc 01       	movw	r30, r24
    8040:	10 82       	st	Z, r1
    8042:	8f 81       	ldd	r24, Y+7	; 0x07
    8044:	98 85       	ldd	r25, Y+8	; 0x08
    8046:	01 96       	adiw	r24, 0x01	; 1
    8048:	8f 83       	std	Y+7, r24	; 0x07
    804a:	98 87       	std	Y+8, r25	; 0x08
    804c:	8f 81       	ldd	r24, Y+7	; 0x07
    804e:	98 85       	ldd	r25, Y+8	; 0x08
    8050:	f4 e0       	ldi	r31, 0x04	; 4
    8052:	82 3e       	cpi	r24, 0xE2	; 226
    8054:	9f 07       	cpc	r25, r31
    8056:	7c f3       	brlt	.-34     	; 0x8036 <SD_write_and_read_knowns+0xd8>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    8058:	20 ee       	ldi	r18, 0xE0	; 224
    805a:	33 e2       	ldi	r19, 0x23	; 35
    805c:	60 e5       	ldi	r22, 0x50	; 80
    805e:	70 e0       	ldi	r23, 0x00	; 0
    8060:	80 e0       	ldi	r24, 0x00	; 0
    8062:	90 e0       	ldi	r25, 0x00	; 0
    8064:	a9 01       	movw	r20, r18
    8066:	23 e0       	ldi	r18, 0x03	; 3
    8068:	30 e0       	ldi	r19, 0x00	; 0
    806a:	0e 94 e9 52 	call	0xa5d2	; 0xa5d2 <SD_read_multiple_blocks>
}
    806e:	28 96       	adiw	r28, 0x08	; 8
    8070:	cd bf       	out	0x3d, r28	; 61
    8072:	de bf       	out	0x3e, r29	; 62
    8074:	df 91       	pop	r29
    8076:	cf 91       	pop	r28
    8078:	08 95       	ret

0000807a <SD_write_and_read_knowns_FAT>:
//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    807a:	cf 93       	push	r28
    807c:	df 93       	push	r29
    807e:	00 d0       	rcall	.+0      	; 0x8080 <SD_write_and_read_knowns_FAT+0x6>
    8080:	0f 92       	push	r0
    8082:	cd b7       	in	r28, 0x3d	; 61
    8084:	de b7       	in	r29, 0x3e	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    8086:	19 82       	std	Y+1, r1	; 0x01
    8088:	1a 82       	std	Y+2, r1	; 0x02
    808a:	0c c0       	rjmp	.+24     	; 0x80a4 <SD_write_and_read_knowns_FAT+0x2a>
    808c:	29 81       	ldd	r18, Y+1	; 0x01
    808e:	89 81       	ldd	r24, Y+1	; 0x01
    8090:	9a 81       	ldd	r25, Y+2	; 0x02
    8092:	80 52       	subi	r24, 0x20	; 32
    8094:	9c 4d       	sbci	r25, 0xDC	; 220
    8096:	fc 01       	movw	r30, r24
    8098:	20 83       	st	Z, r18
    809a:	89 81       	ldd	r24, Y+1	; 0x01
    809c:	9a 81       	ldd	r25, Y+2	; 0x02
    809e:	01 96       	adiw	r24, 0x01	; 1
    80a0:	89 83       	std	Y+1, r24	; 0x01
    80a2:	9a 83       	std	Y+2, r25	; 0x02
    80a4:	89 81       	ldd	r24, Y+1	; 0x01
    80a6:	9a 81       	ldd	r25, Y+2	; 0x02
    80a8:	88 31       	cpi	r24, 0x18	; 24
    80aa:	91 05       	cpc	r25, r1
    80ac:	7c f3       	brlt	.-34     	; 0x808c <SD_write_and_read_knowns_FAT+0x12>
	error = writeFile("testing",FRAMReadBuffer,512);
    80ae:	8d e1       	ldi	r24, 0x1D	; 29
    80b0:	90 e2       	ldi	r25, 0x20	; 32
    80b2:	20 ee       	ldi	r18, 0xE0	; 224
    80b4:	33 e2       	ldi	r19, 0x23	; 35
    80b6:	b9 01       	movw	r22, r18
    80b8:	20 e0       	ldi	r18, 0x00	; 0
    80ba:	32 e0       	ldi	r19, 0x02	; 2
    80bc:	40 e0       	ldi	r20, 0x00	; 0
    80be:	50 e0       	ldi	r21, 0x00	; 0
    80c0:	0e 94 35 48 	call	0x906a	; 0x906a <writeFile>
    80c4:	80 93 a0 50 	sts	0x50A0, r24
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    80c8:	1b 82       	std	Y+3, r1	; 0x03
    80ca:	1c 82       	std	Y+4, r1	; 0x04
    80cc:	0b c0       	rjmp	.+22     	; 0x80e4 <SD_write_and_read_knowns_FAT+0x6a>
    80ce:	8b 81       	ldd	r24, Y+3	; 0x03
    80d0:	9c 81       	ldd	r25, Y+4	; 0x04
    80d2:	80 52       	subi	r24, 0x20	; 32
    80d4:	9c 4d       	sbci	r25, 0xDC	; 220
    80d6:	fc 01       	movw	r30, r24
    80d8:	10 82       	st	Z, r1
    80da:	8b 81       	ldd	r24, Y+3	; 0x03
    80dc:	9c 81       	ldd	r25, Y+4	; 0x04
    80de:	01 96       	adiw	r24, 0x01	; 1
    80e0:	8b 83       	std	Y+3, r24	; 0x03
    80e2:	9c 83       	std	Y+4, r25	; 0x04
    80e4:	8b 81       	ldd	r24, Y+3	; 0x03
    80e6:	9c 81       	ldd	r25, Y+4	; 0x04
    80e8:	88 31       	cpi	r24, 0x18	; 24
    80ea:	91 05       	cpc	r25, r1
    80ec:	84 f3       	brlt	.-32     	; 0x80ce <SD_write_and_read_knowns_FAT+0x54>
	error = readFile(READ,"testing");		//read the data into the buffer from file
    80ee:	2d e1       	ldi	r18, 0x1D	; 29
    80f0:	30 e2       	ldi	r19, 0x20	; 32
    80f2:	80 e0       	ldi	r24, 0x00	; 0
    80f4:	b9 01       	movw	r22, r18
    80f6:	0e 94 50 46 	call	0x8ca0	; 0x8ca0 <readFile>
    80fa:	80 93 a0 50 	sts	0x50A0, r24
}
    80fe:	24 96       	adiw	r28, 0x04	; 4
    8100:	cd bf       	out	0x3d, r28	; 61
    8102:	de bf       	out	0x3e, r29	; 62
    8104:	df 91       	pop	r29
    8106:	cf 91       	pop	r28
    8108:	08 95       	ret

0000810a <chibi_test_radio>:




//function for testing radio transmission
void chibi_test_radio(){
    810a:	cf 93       	push	r28
    810c:	df 93       	push	r29
    810e:	cd b7       	in	r28, 0x3d	; 61
    8110:	de b7       	in	r29, 0x3e	; 62
		
	chb_init();
    8112:	0e 94 52 20 	call	0x40a4	; 0x40a4 <chb_init>
	chb_set_short_addr(0x0002);
    8116:	82 e0       	ldi	r24, 0x02	; 2
    8118:	90 e0       	ldi	r25, 0x00	; 0
    811a:	0e 94 ec 2d 	call	0x5bd8	; 0x5bd8 <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    811e:	00 00       	nop
    8120:	fe cf       	rjmp	.-4      	; 0x811e <chibi_test_radio+0x14>

00008122 <TestCard>:
	for (int i=0;i<10;i++) FRAMReadBuffer[i] = 0;
	chb_read(FRAMReadBuffer);
	*/
}
//another testing function for sd card
void TestCard(){
    8122:	cf 93       	push	r28
    8124:	df 93       	push	r29
    8126:	0f 92       	push	r0
    8128:	0f 92       	push	r0
    812a:	cd b7       	in	r28, 0x3d	; 61
    812c:	de b7       	in	r29, 0x3e	; 62
	SD_init();
    812e:	0e 94 a0 4d 	call	0x9b40	; 0x9b40 <SD_init>
	getBootSectorData();
    8132:	0e 94 a0 41 	call	0x8340	; 0x8340 <getBootSectorData>
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    8136:	19 82       	std	Y+1, r1	; 0x01
    8138:	1a 82       	std	Y+2, r1	; 0x02
    813a:	13 c0       	rjmp	.+38     	; 0x8162 <TestCard+0x40>
    813c:	89 81       	ldd	r24, Y+1	; 0x01
    813e:	9a 81       	ldd	r25, Y+2	; 0x02
    8140:	29 e7       	ldi	r18, 0x79	; 121
    8142:	30 e0       	ldi	r19, 0x00	; 0
    8144:	b9 01       	movw	r22, r18
    8146:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__divmodhi4>
    814a:	28 2f       	mov	r18, r24
    814c:	89 81       	ldd	r24, Y+1	; 0x01
    814e:	9a 81       	ldd	r25, Y+2	; 0x02
    8150:	80 52       	subi	r24, 0x20	; 32
    8152:	9c 4d       	sbci	r25, 0xDC	; 220
    8154:	fc 01       	movw	r30, r24
    8156:	20 83       	st	Z, r18
    8158:	89 81       	ldd	r24, Y+1	; 0x01
    815a:	9a 81       	ldd	r25, Y+2	; 0x02
    815c:	01 96       	adiw	r24, 0x01	; 1
    815e:	89 83       	std	Y+1, r24	; 0x01
    8160:	9a 83       	std	Y+2, r25	; 0x02
    8162:	89 81       	ldd	r24, Y+1	; 0x01
    8164:	9a 81       	ldd	r25, Y+2	; 0x02
    8166:	f2 e0       	ldi	r31, 0x02	; 2
    8168:	80 30       	cpi	r24, 0x00	; 0
    816a:	9f 07       	cpc	r25, r31
    816c:	3c f3       	brlt	.-50     	; 0x813c <TestCard+0x1a>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile("testing",FRAMReadBuffer,512);//}
    816e:	8d e1       	ldi	r24, 0x1D	; 29
    8170:	90 e2       	ldi	r25, 0x20	; 32
    8172:	20 ee       	ldi	r18, 0xE0	; 224
    8174:	33 e2       	ldi	r19, 0x23	; 35
    8176:	b9 01       	movw	r22, r18
    8178:	20 e0       	ldi	r18, 0x00	; 0
    817a:	32 e0       	ldi	r19, 0x02	; 2
    817c:	40 e0       	ldi	r20, 0x00	; 0
    817e:	50 e0       	ldi	r21, 0x00	; 0
    8180:	0e 94 35 48 	call	0x906a	; 0x906a <writeFile>
	nop();
    8184:	00 00       	nop
}
    8186:	0f 90       	pop	r0
    8188:	0f 90       	pop	r0
    818a:	df 91       	pop	r29
    818c:	cf 91       	pop	r28
    818e:	08 95       	ret

00008190 <__vector_43>:

//interrupt service routine for handling received data over radio
ISR(PORTE_INT0_vect){
    8190:	1f 92       	push	r1
    8192:	0f 92       	push	r0
    8194:	0f b6       	in	r0, 0x3f	; 63
    8196:	0f 92       	push	r0
    8198:	00 90 3b 00 	lds	r0, 0x003B
    819c:	0f 92       	push	r0
    819e:	11 24       	eor	r1, r1
    81a0:	2f 93       	push	r18
    81a2:	3f 93       	push	r19
    81a4:	4f 93       	push	r20
    81a6:	5f 93       	push	r21
    81a8:	6f 93       	push	r22
    81aa:	7f 93       	push	r23
    81ac:	8f 93       	push	r24
    81ae:	9f 93       	push	r25
    81b0:	af 93       	push	r26
    81b2:	bf 93       	push	r27
    81b4:	ef 93       	push	r30
    81b6:	ff 93       	push	r31
    81b8:	cf 93       	push	r28
    81ba:	df 93       	push	r29
    81bc:	cd b7       	in	r28, 0x3d	; 61
    81be:	de b7       	in	r29, 0x3e	; 62
    81c0:	c4 58       	subi	r28, 0x84	; 132
    81c2:	d0 40       	sbci	r29, 0x00	; 0
    81c4:	cd bf       	out	0x3d, r28	; 61
    81c6:	de bf       	out	0x3e, r29	; 62
	char msg[128];
	switch (RadioMonitorMode) {
    81c8:	80 91 5f 40 	lds	r24, 0x405F
    81cc:	88 2f       	mov	r24, r24
    81ce:	90 e0       	ldi	r25, 0x00	; 0
    81d0:	81 30       	cpi	r24, 0x01	; 1
    81d2:	91 05       	cpc	r25, r1
    81d4:	29 f0       	breq	.+10     	; 0x81e0 <__vector_43+0x50>
    81d6:	82 30       	cpi	r24, 0x02	; 2
    81d8:	91 05       	cpc	r25, r1
    81da:	09 f4       	brne	.+2      	; 0x81de <__vector_43+0x4e>
    81dc:	73 c0       	rjmp	.+230    	; 0x82c4 <__vector_43+0x134>
    81de:	91 c0       	rjmp	.+290    	; 0x8302 <__vector_43+0x172>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    81e0:	ce 01       	movw	r24, r28
    81e2:	05 96       	adiw	r24, 0x05	; 5
    81e4:	0e 94 a4 22 	call	0x4548	; 0x4548 <chb_read>
			if(!strncmp(msg,"reset",5)){
    81e8:	ce 01       	movw	r24, r28
    81ea:	05 96       	adiw	r24, 0x05	; 5
    81ec:	25 e2       	ldi	r18, 0x25	; 37
    81ee:	30 e2       	ldi	r19, 0x20	; 32
    81f0:	b9 01       	movw	r22, r18
    81f2:	45 e0       	ldi	r20, 0x05	; 5
    81f4:	50 e0       	ldi	r21, 0x00	; 0
    81f6:	0e 94 77 5f 	call	0xbeee	; 0xbeee <strncmp>
    81fa:	00 97       	sbiw	r24, 0x00	; 0
    81fc:	51 f4       	brne	.+20     	; 0x8212 <__vector_43+0x82>
				MotesReadyToSynch++;
    81fe:	80 91 75 50 	lds	r24, 0x5075
    8202:	90 91 76 50 	lds	r25, 0x5076
    8206:	01 96       	adiw	r24, 0x01	; 1
    8208:	80 93 75 50 	sts	0x5075, r24
    820c:	90 93 76 50 	sts	0x5076, r25
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    8210:	7a c0       	rjmp	.+244    	; 0x8306 <__vector_43+0x176>
			if(!strncmp(msg,"reset",5)){
				MotesReadyToSynch++;
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
    8212:	19 82       	std	Y+1, r1	; 0x01
    8214:	1a 82       	std	Y+2, r1	; 0x02
    8216:	1b 82       	std	Y+3, r1	; 0x03
    8218:	1c 82       	std	Y+4, r1	; 0x04
    821a:	1a c0       	rjmp	.+52     	; 0x8250 <__vector_43+0xc0>
    821c:	9e 01       	movw	r18, r28
    821e:	2b 5f       	subi	r18, 0xFB	; 251
    8220:	3f 4f       	sbci	r19, 0xFF	; 255
    8222:	89 81       	ldd	r24, Y+1	; 0x01
    8224:	9a 81       	ldd	r25, Y+2	; 0x02
    8226:	82 0f       	add	r24, r18
    8228:	93 1f       	adc	r25, r19
    822a:	fc 01       	movw	r30, r24
    822c:	20 81       	ld	r18, Z
    822e:	89 81       	ldd	r24, Y+1	; 0x01
    8230:	9a 81       	ldd	r25, Y+2	; 0x02
    8232:	80 52       	subi	r24, 0x20	; 32
    8234:	9c 4d       	sbci	r25, 0xDC	; 220
    8236:	fc 01       	movw	r30, r24
    8238:	20 83       	st	Z, r18
    823a:	89 81       	ldd	r24, Y+1	; 0x01
    823c:	9a 81       	ldd	r25, Y+2	; 0x02
    823e:	ab 81       	ldd	r26, Y+3	; 0x03
    8240:	bc 81       	ldd	r27, Y+4	; 0x04
    8242:	01 96       	adiw	r24, 0x01	; 1
    8244:	a1 1d       	adc	r26, r1
    8246:	b1 1d       	adc	r27, r1
    8248:	89 83       	std	Y+1, r24	; 0x01
    824a:	9a 83       	std	Y+2, r25	; 0x02
    824c:	ab 83       	std	Y+3, r26	; 0x03
    824e:	bc 83       	std	Y+4, r27	; 0x04
    8250:	89 81       	ldd	r24, Y+1	; 0x01
    8252:	9a 81       	ldd	r25, Y+2	; 0x02
    8254:	ab 81       	ldd	r26, Y+3	; 0x03
    8256:	bc 81       	ldd	r27, Y+4	; 0x04
    8258:	80 38       	cpi	r24, 0x80	; 128
    825a:	91 05       	cpc	r25, r1
    825c:	a1 05       	cpc	r26, r1
    825e:	b1 05       	cpc	r27, r1
    8260:	e8 f2       	brcs	.-70     	; 0x821c <__vector_43+0x8c>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    8262:	80 91 c7 50 	lds	r24, 0x50C7
    8266:	90 91 c8 50 	lds	r25, 0x50C8
    826a:	a0 91 c9 50 	lds	r26, 0x50C9
    826e:	b0 91 ca 50 	lds	r27, 0x50CA
    8272:	80 58       	subi	r24, 0x80	; 128
    8274:	9f 4f       	sbci	r25, 0xFF	; 255
    8276:	af 4f       	sbci	r26, 0xFF	; 255
    8278:	bf 4f       	sbci	r27, 0xFF	; 255
    827a:	80 93 c7 50 	sts	0x50C7, r24
    827e:	90 93 c8 50 	sts	0x50C8, r25
    8282:	a0 93 c9 50 	sts	0x50C9, r26
    8286:	b0 93 ca 50 	sts	0x50CA, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    828a:	80 91 c7 50 	lds	r24, 0x50C7
    828e:	90 91 c8 50 	lds	r25, 0x50C8
    8292:	a0 91 c9 50 	lds	r26, 0x50C9
    8296:	b0 91 ca 50 	lds	r27, 0x50CA
    829a:	80 58       	subi	r24, 0x80	; 128
    829c:	9f 4f       	sbci	r25, 0xFF	; 255
    829e:	af 4f       	sbci	r26, 0xFF	; 255
    82a0:	bf 4f       	sbci	r27, 0xFF	; 255
    82a2:	81 37       	cpi	r24, 0x71	; 113
    82a4:	fc e1       	ldi	r31, 0x1C	; 28
    82a6:	9f 07       	cpc	r25, r31
    82a8:	f0 e0       	ldi	r31, 0x00	; 0
    82aa:	af 07       	cpc	r26, r31
    82ac:	f0 e0       	ldi	r31, 0x00	; 0
    82ae:	bf 07       	cpc	r27, r31
    82b0:	50 f1       	brcs	.+84     	; 0x8306 <__vector_43+0x176>
    82b2:	10 92 c7 50 	sts	0x50C7, r1
    82b6:	10 92 c8 50 	sts	0x50C8, r1
    82ba:	10 92 c9 50 	sts	0x50C9, r1
    82be:	10 92 ca 50 	sts	0x50CA, r1
			}			
			break;
    82c2:	21 c0       	rjmp	.+66     	; 0x8306 <__vector_43+0x176>
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    82c4:	ce 01       	movw	r24, r28
    82c6:	05 96       	adiw	r24, 0x05	; 5
    82c8:	0e 94 a4 22 	call	0x4548	; 0x4548 <chb_read>
			if(!strncmp(msg,"start sampling",14)){	//if basestation synch response message received, do the following
    82cc:	ce 01       	movw	r24, r28
    82ce:	05 96       	adiw	r24, 0x05	; 5
    82d0:	2b e2       	ldi	r18, 0x2B	; 43
    82d2:	30 e2       	ldi	r19, 0x20	; 32
    82d4:	b9 01       	movw	r22, r18
    82d6:	4e e0       	ldi	r20, 0x0E	; 14
    82d8:	50 e0       	ldi	r21, 0x00	; 0
    82da:	0e 94 77 5f 	call	0xbeee	; 0xbeee <strncmp>
    82de:	00 97       	sbiw	r24, 0x00	; 0
    82e0:	a1 f4       	brne	.+40     	; 0x830a <__vector_43+0x17a>
				RadioMonitorMode = SYNCHED;
    82e2:	83 e0       	ldi	r24, 0x03	; 3
    82e4:	80 93 5f 40 	sts	0x405F, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    82e8:	80 e4       	ldi	r24, 0x40	; 64
    82ea:	99 e0       	ldi	r25, 0x09	; 9
    82ec:	29 e0       	ldi	r18, 0x09	; 9
    82ee:	fc 01       	movw	r30, r24
    82f0:	20 83       	st	Z, r18
				TCC1.CTRLA = 0x01;  
    82f2:	80 e4       	ldi	r24, 0x40	; 64
    82f4:	98 e0       	ldi	r25, 0x08	; 8
    82f6:	21 e0       	ldi	r18, 0x01	; 1
    82f8:	fc 01       	movw	r30, r24
    82fa:	20 83       	st	Z, r18
				ADC_Resume_Sampling();	//resume sampling with the adc
    82fc:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <ADC_Resume_Sampling>
			}
			break;
    8300:	04 c0       	rjmp	.+8      	; 0x830a <__vector_43+0x17a>
		default:
			break;
    8302:	00 00       	nop
    8304:	03 c0       	rjmp	.+6      	; 0x830c <__vector_43+0x17c>
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    8306:	00 00       	nop
    8308:	01 c0       	rjmp	.+2      	; 0x830c <__vector_43+0x17c>
				RadioMonitorMode = SYNCHED;
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
				TCC1.CTRLA = 0x01;  
				ADC_Resume_Sampling();	//resume sampling with the adc
			}
			break;
    830a:	00 00       	nop
		default:
			break;
	}
    830c:	cc 57       	subi	r28, 0x7C	; 124
    830e:	df 4f       	sbci	r29, 0xFF	; 255
    8310:	cd bf       	out	0x3d, r28	; 61
    8312:	de bf       	out	0x3e, r29	; 62
    8314:	df 91       	pop	r29
    8316:	cf 91       	pop	r28
    8318:	ff 91       	pop	r31
    831a:	ef 91       	pop	r30
    831c:	bf 91       	pop	r27
    831e:	af 91       	pop	r26
    8320:	9f 91       	pop	r25
    8322:	8f 91       	pop	r24
    8324:	7f 91       	pop	r23
    8326:	6f 91       	pop	r22
    8328:	5f 91       	pop	r21
    832a:	4f 91       	pop	r20
    832c:	3f 91       	pop	r19
    832e:	2f 91       	pop	r18
    8330:	0f 90       	pop	r0
    8332:	00 92 3b 00 	sts	0x003B, r0
    8336:	0f 90       	pop	r0
    8338:	0f be       	out	0x3f, r0	; 63
    833a:	0f 90       	pop	r0
    833c:	1f 90       	pop	r1
    833e:	18 95       	reti

00008340 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    8340:	ef 92       	push	r14
    8342:	ff 92       	push	r15
    8344:	0f 93       	push	r16
    8346:	1f 93       	push	r17
    8348:	cf 93       	push	r28
    834a:	df 93       	push	r29
    834c:	cd b7       	in	r28, 0x3d	; 61
    834e:	de b7       	in	r29, 0x3e	; 62
    8350:	2a 97       	sbiw	r28, 0x0a	; 10
    8352:	cd bf       	out	0x3d, r28	; 61
    8354:	de bf       	out	0x3e, r29	; 62
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    8356:	10 92 7a 50 	sts	0x507A, r1
    835a:	10 92 7b 50 	sts	0x507B, r1
    835e:	10 92 7c 50 	sts	0x507C, r1
    8362:	10 92 7d 50 	sts	0x507D, r1

SD_read_block(0,SDBuffer);
    8366:	27 ed       	ldi	r18, 0xD7	; 215
    8368:	31 e2       	ldi	r19, 0x21	; 33
    836a:	60 e0       	ldi	r22, 0x00	; 0
    836c:	70 e0       	ldi	r23, 0x00	; 0
    836e:	cb 01       	movw	r24, r22
    8370:	a9 01       	movw	r20, r18
    8372:	0e 94 15 51 	call	0xa22a	; 0xa22a <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;
    8376:	87 ed       	ldi	r24, 0xD7	; 215
    8378:	91 e2       	ldi	r25, 0x21	; 33
    837a:	89 83       	std	Y+1, r24	; 0x01
    837c:	9a 83       	std	Y+2, r25	; 0x02

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    837e:	89 81       	ldd	r24, Y+1	; 0x01
    8380:	9a 81       	ldd	r25, Y+2	; 0x02
    8382:	fc 01       	movw	r30, r24
    8384:	80 81       	ld	r24, Z
    8386:	89 3e       	cpi	r24, 0xE9	; 233
    8388:	09 f4       	brne	.+2      	; 0x838c <getBootSectorData+0x4c>
    838a:	4d c0       	rjmp	.+154    	; 0x8426 <getBootSectorData+0xe6>
    838c:	89 81       	ldd	r24, Y+1	; 0x01
    838e:	9a 81       	ldd	r25, Y+2	; 0x02
    8390:	fc 01       	movw	r30, r24
    8392:	80 81       	ld	r24, Z
    8394:	8b 3e       	cpi	r24, 0xEB	; 235
    8396:	09 f4       	brne	.+2      	; 0x839a <getBootSectorData+0x5a>
    8398:	46 c0       	rjmp	.+140    	; 0x8426 <getBootSectorData+0xe6>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
    839a:	87 ed       	ldi	r24, 0xD7	; 215
    839c:	91 e2       	ldi	r25, 0x21	; 33
    839e:	8b 83       	std	Y+3, r24	; 0x03
    83a0:	9c 83       	std	Y+4, r25	; 0x04
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    83a2:	8b 81       	ldd	r24, Y+3	; 0x03
    83a4:	9c 81       	ldd	r25, Y+4	; 0x04
    83a6:	82 50       	subi	r24, 0x02	; 2
    83a8:	9e 4f       	sbci	r25, 0xFE	; 254
    83aa:	fc 01       	movw	r30, r24
    83ac:	80 81       	ld	r24, Z
    83ae:	91 81       	ldd	r25, Z+1	; 0x01
    83b0:	fa ea       	ldi	r31, 0xAA	; 170
    83b2:	85 35       	cpi	r24, 0x55	; 85
    83b4:	9f 07       	cpc	r25, r31
    83b6:	11 f0       	breq	.+4      	; 0x83bc <getBootSectorData+0x7c>
    83b8:	81 e0       	ldi	r24, 0x01	; 1
    83ba:	01 c1       	rjmp	.+514    	; 0x85be <getBootSectorData+0x27e>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
    83bc:	8b 81       	ldd	r24, Y+3	; 0x03
    83be:	9c 81       	ldd	r25, Y+4	; 0x04
    83c0:	82 54       	subi	r24, 0x42	; 66
    83c2:	9e 4f       	sbci	r25, 0xFE	; 254
    83c4:	8d 83       	std	Y+5, r24	; 0x05
    83c6:	9e 83       	std	Y+6, r25	; 0x06
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    83c8:	8d 81       	ldd	r24, Y+5	; 0x05
    83ca:	9e 81       	ldd	r25, Y+6	; 0x06
    83cc:	fc 01       	movw	r30, r24
    83ce:	80 85       	ldd	r24, Z+8	; 0x08
    83d0:	91 85       	ldd	r25, Z+9	; 0x09
    83d2:	a2 85       	ldd	r26, Z+10	; 0x0a
    83d4:	b3 85       	ldd	r27, Z+11	; 0x0b
    83d6:	80 93 7a 50 	sts	0x507A, r24
    83da:	90 93 7b 50 	sts	0x507B, r25
    83de:	a0 93 7c 50 	sts	0x507C, r26
    83e2:	b0 93 7d 50 	sts	0x507D, r27
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    83e6:	8d 81       	ldd	r24, Y+5	; 0x05
    83e8:	9e 81       	ldd	r25, Y+6	; 0x06
    83ea:	fc 01       	movw	r30, r24
    83ec:	80 85       	ldd	r24, Z+8	; 0x08
    83ee:	91 85       	ldd	r25, Z+9	; 0x09
    83f0:	a2 85       	ldd	r26, Z+10	; 0x0a
    83f2:	b3 85       	ldd	r27, Z+11	; 0x0b
    83f4:	27 ed       	ldi	r18, 0xD7	; 215
    83f6:	31 e2       	ldi	r19, 0x21	; 33
    83f8:	bc 01       	movw	r22, r24
    83fa:	cd 01       	movw	r24, r26
    83fc:	a9 01       	movw	r20, r18
    83fe:	0e 94 15 51 	call	0xa22a	; 0xa22a <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
    8402:	87 ed       	ldi	r24, 0xD7	; 215
    8404:	91 e2       	ldi	r25, 0x21	; 33
    8406:	89 83       	std	Y+1, r24	; 0x01
    8408:	9a 83       	std	Y+2, r25	; 0x02
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    840a:	89 81       	ldd	r24, Y+1	; 0x01
    840c:	9a 81       	ldd	r25, Y+2	; 0x02
    840e:	fc 01       	movw	r30, r24
    8410:	80 81       	ld	r24, Z
    8412:	89 3e       	cpi	r24, 0xE9	; 233
    8414:	41 f0       	breq	.+16     	; 0x8426 <getBootSectorData+0xe6>
    8416:	89 81       	ldd	r24, Y+1	; 0x01
    8418:	9a 81       	ldd	r25, Y+2	; 0x02
    841a:	fc 01       	movw	r30, r24
    841c:	80 81       	ld	r24, Z
    841e:	8b 3e       	cpi	r24, 0xEB	; 235
    8420:	11 f0       	breq	.+4      	; 0x8426 <getBootSectorData+0xe6>
    8422:	81 e0       	ldi	r24, 0x01	; 1
    8424:	cc c0       	rjmp	.+408    	; 0x85be <getBootSectorData+0x27e>
}

bytesPerSector = bpb->bytesPerSector;
    8426:	89 81       	ldd	r24, Y+1	; 0x01
    8428:	9a 81       	ldd	r25, Y+2	; 0x02
    842a:	fc 01       	movw	r30, r24
    842c:	83 85       	ldd	r24, Z+11	; 0x0b
    842e:	94 85       	ldd	r25, Z+12	; 0x0c
    8430:	80 93 55 40 	sts	0x4055, r24
    8434:	90 93 56 40 	sts	0x4056, r25
sectorPerCluster = bpb->sectorPerCluster;
    8438:	89 81       	ldd	r24, Y+1	; 0x01
    843a:	9a 81       	ldd	r25, Y+2	; 0x02
    843c:	fc 01       	movw	r30, r24
    843e:	85 85       	ldd	r24, Z+13	; 0x0d
    8440:	88 2f       	mov	r24, r24
    8442:	90 e0       	ldi	r25, 0x00	; 0
    8444:	80 93 78 50 	sts	0x5078, r24
    8448:	90 93 79 50 	sts	0x5079, r25
reservedSectorCount = bpb->reservedSectorCount;
    844c:	89 81       	ldd	r24, Y+1	; 0x01
    844e:	9a 81       	ldd	r25, Y+2	; 0x02
    8450:	fc 01       	movw	r30, r24
    8452:	86 85       	ldd	r24, Z+14	; 0x0e
    8454:	97 85       	ldd	r25, Z+15	; 0x0f
    8456:	80 93 80 50 	sts	0x5080, r24
    845a:	90 93 81 50 	sts	0x5081, r25
rootCluster = bpb->rootCluster;
    845e:	89 81       	ldd	r24, Y+1	; 0x01
    8460:	9a 81       	ldd	r25, Y+2	; 0x02
    8462:	fc 01       	movw	r30, r24
    8464:	84 a5       	lds	r24, 0x64
    8466:	95 a5       	lds	r25, 0x65
    8468:	a6 a5       	lds	r26, 0x66
    846a:	b7 a5       	lds	r27, 0x67
    846c:	80 93 60 40 	sts	0x4060, r24
    8470:	90 93 61 40 	sts	0x4061, r25
    8474:	a0 93 62 40 	sts	0x4062, r26
    8478:	b0 93 63 40 	sts	0x4063, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    847c:	89 81       	ldd	r24, Y+1	; 0x01
    847e:	9a 81       	ldd	r25, Y+2	; 0x02
    8480:	fc 01       	movw	r30, r24
    8482:	24 8d       	ldd	r18, Z+28	; 0x1c
    8484:	35 8d       	ldd	r19, Z+29	; 0x1d
    8486:	46 8d       	ldd	r20, Z+30	; 0x1e
    8488:	57 8d       	ldd	r21, Z+31	; 0x1f
    848a:	80 91 80 50 	lds	r24, 0x5080
    848e:	90 91 81 50 	lds	r25, 0x5081
    8492:	cc 01       	movw	r24, r24
    8494:	a0 e0       	ldi	r26, 0x00	; 0
    8496:	b0 e0       	ldi	r27, 0x00	; 0
    8498:	79 01       	movw	r14, r18
    849a:	8a 01       	movw	r16, r20
    849c:	e8 0e       	add	r14, r24
    849e:	f9 1e       	adc	r15, r25
    84a0:	0a 1f       	adc	r16, r26
    84a2:	1b 1f       	adc	r17, r27
    84a4:	89 81       	ldd	r24, Y+1	; 0x01
    84a6:	9a 81       	ldd	r25, Y+2	; 0x02
    84a8:	fc 01       	movw	r30, r24
    84aa:	80 89       	ldd	r24, Z+16	; 0x10
    84ac:	88 2f       	mov	r24, r24
    84ae:	90 e0       	ldi	r25, 0x00	; 0
    84b0:	a0 e0       	ldi	r26, 0x00	; 0
    84b2:	b0 e0       	ldi	r27, 0x00	; 0
    84b4:	29 81       	ldd	r18, Y+1	; 0x01
    84b6:	3a 81       	ldd	r19, Y+2	; 0x02
    84b8:	f9 01       	movw	r30, r18
    84ba:	24 a1       	lds	r18, 0x44
    84bc:	35 a1       	lds	r19, 0x45
    84be:	46 a1       	lds	r20, 0x46
    84c0:	57 a1       	lds	r21, 0x47
    84c2:	bc 01       	movw	r22, r24
    84c4:	cd 01       	movw	r24, r26
    84c6:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    84ca:	dc 01       	movw	r26, r24
    84cc:	cb 01       	movw	r24, r22
    84ce:	8e 0d       	add	r24, r14
    84d0:	9f 1d       	adc	r25, r15
    84d2:	a0 1f       	adc	r26, r16
    84d4:	b1 1f       	adc	r27, r17
    84d6:	80 93 dc 23 	sts	0x23DC, r24
    84da:	90 93 dd 23 	sts	0x23DD, r25
    84de:	a0 93 de 23 	sts	0x23DE, r26
    84e2:	b0 93 df 23 	sts	0x23DF, r27

dataSectors = bpb->totalSectors_F32
    84e6:	89 81       	ldd	r24, Y+1	; 0x01
    84e8:	9a 81       	ldd	r25, Y+2	; 0x02
    84ea:	fc 01       	movw	r30, r24
    84ec:	20 a1       	lds	r18, 0x40
    84ee:	31 a1       	lds	r19, 0x41
    84f0:	42 a1       	lds	r20, 0x42
    84f2:	53 a1       	lds	r21, 0x43
              - bpb->reservedSectorCount
    84f4:	89 81       	ldd	r24, Y+1	; 0x01
    84f6:	9a 81       	ldd	r25, Y+2	; 0x02
    84f8:	fc 01       	movw	r30, r24
    84fa:	86 85       	ldd	r24, Z+14	; 0x0e
    84fc:	97 85       	ldd	r25, Z+15	; 0x0f
    84fe:	cc 01       	movw	r24, r24
    8500:	a0 e0       	ldi	r26, 0x00	; 0
    8502:	b0 e0       	ldi	r27, 0x00	; 0
    8504:	79 01       	movw	r14, r18
    8506:	8a 01       	movw	r16, r20
    8508:	e8 1a       	sub	r14, r24
    850a:	f9 0a       	sbc	r15, r25
    850c:	0a 0b       	sbc	r16, r26
    850e:	1b 0b       	sbc	r17, r27
              - ( bpb->numberofFATs * bpb->FATsize_F32);
    8510:	89 81       	ldd	r24, Y+1	; 0x01
    8512:	9a 81       	ldd	r25, Y+2	; 0x02
    8514:	fc 01       	movw	r30, r24
    8516:	80 89       	ldd	r24, Z+16	; 0x10
    8518:	88 2f       	mov	r24, r24
    851a:	90 e0       	ldi	r25, 0x00	; 0
    851c:	a0 e0       	ldi	r26, 0x00	; 0
    851e:	b0 e0       	ldi	r27, 0x00	; 0
    8520:	29 81       	ldd	r18, Y+1	; 0x01
    8522:	3a 81       	ldd	r19, Y+2	; 0x02
    8524:	f9 01       	movw	r30, r18
    8526:	24 a1       	lds	r18, 0x44
    8528:	35 a1       	lds	r19, 0x45
    852a:	46 a1       	lds	r20, 0x46
    852c:	57 a1       	lds	r21, 0x47
    852e:	bc 01       	movw	r22, r24
    8530:	cd 01       	movw	r24, r26
    8532:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    8536:	dc 01       	movw	r26, r24
    8538:	cb 01       	movw	r24, r22
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    853a:	a8 01       	movw	r20, r16
    853c:	97 01       	movw	r18, r14
    853e:	28 1b       	sub	r18, r24
    8540:	39 0b       	sbc	r19, r25
    8542:	4a 0b       	sbc	r20, r26
    8544:	5b 0b       	sbc	r21, r27
    8546:	da 01       	movw	r26, r20
    8548:	c9 01       	movw	r24, r18
    854a:	8f 83       	std	Y+7, r24	; 0x07
    854c:	98 87       	std	Y+8, r25	; 0x08
    854e:	a9 87       	std	Y+9, r26	; 0x09
    8550:	ba 87       	std	Y+10, r27	; 0x0a
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    8552:	80 91 78 50 	lds	r24, 0x5078
    8556:	90 91 79 50 	lds	r25, 0x5079
    855a:	9c 01       	movw	r18, r24
    855c:	40 e0       	ldi	r20, 0x00	; 0
    855e:	50 e0       	ldi	r21, 0x00	; 0
    8560:	8f 81       	ldd	r24, Y+7	; 0x07
    8562:	98 85       	ldd	r25, Y+8	; 0x08
    8564:	a9 85       	ldd	r26, Y+9	; 0x09
    8566:	ba 85       	ldd	r27, Y+10	; 0x0a
    8568:	bc 01       	movw	r22, r24
    856a:	cd 01       	movw	r24, r26
    856c:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    8570:	da 01       	movw	r26, r20
    8572:	c9 01       	movw	r24, r18
    8574:	80 93 5a 40 	sts	0x405A, r24
    8578:	90 93 5b 40 	sts	0x405B, r25
    857c:	a0 93 5c 40 	sts	0x405C, r26
    8580:	b0 93 5d 40 	sts	0x405D, r27


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    8584:	81 e0       	ldi	r24, 0x01	; 1
    8586:	60 e0       	ldi	r22, 0x00	; 0
    8588:	20 e0       	ldi	r18, 0x00	; 0
    858a:	30 e0       	ldi	r19, 0x00	; 0
    858c:	a9 01       	movw	r20, r18
    858e:	0e 94 c5 43 	call	0x878a	; 0x878a <getSetFreeCluster>
    8592:	9b 01       	movw	r18, r22
    8594:	ac 01       	movw	r20, r24
    8596:	80 91 5a 40 	lds	r24, 0x405A
    859a:	90 91 5b 40 	lds	r25, 0x405B
    859e:	a0 91 5c 40 	lds	r26, 0x405C
    85a2:	b0 91 5d 40 	lds	r27, 0x405D
    85a6:	82 17       	cp	r24, r18
    85a8:	93 07       	cpc	r25, r19
    85aa:	a4 07       	cpc	r26, r20
    85ac:	b5 07       	cpc	r27, r21
    85ae:	18 f4       	brcc	.+6      	; 0x85b6 <getBootSectorData+0x276>
     freeClusterCountUpdated = 0;
    85b0:	10 92 cc 50 	sts	0x50CC, r1
    85b4:	03 c0       	rjmp	.+6      	; 0x85bc <getBootSectorData+0x27c>
else
	 freeClusterCountUpdated = 1;
    85b6:	81 e0       	ldi	r24, 0x01	; 1
    85b8:	80 93 cc 50 	sts	0x50CC, r24
return 0;
    85bc:	80 e0       	ldi	r24, 0x00	; 0
}
    85be:	2a 96       	adiw	r28, 0x0a	; 10
    85c0:	cd bf       	out	0x3d, r28	; 61
    85c2:	de bf       	out	0x3e, r29	; 62
    85c4:	df 91       	pop	r29
    85c6:	cf 91       	pop	r28
    85c8:	1f 91       	pop	r17
    85ca:	0f 91       	pop	r16
    85cc:	ff 90       	pop	r15
    85ce:	ef 90       	pop	r14
    85d0:	08 95       	ret

000085d2 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    85d2:	cf 93       	push	r28
    85d4:	df 93       	push	r29
    85d6:	00 d0       	rcall	.+0      	; 0x85d8 <getFirstSector+0x6>
    85d8:	0f 92       	push	r0
    85da:	cd b7       	in	r28, 0x3d	; 61
    85dc:	de b7       	in	r29, 0x3e	; 62
    85de:	69 83       	std	Y+1, r22	; 0x01
    85e0:	7a 83       	std	Y+2, r23	; 0x02
    85e2:	8b 83       	std	Y+3, r24	; 0x03
    85e4:	9c 83       	std	Y+4, r25	; 0x04
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    85e6:	89 81       	ldd	r24, Y+1	; 0x01
    85e8:	9a 81       	ldd	r25, Y+2	; 0x02
    85ea:	ab 81       	ldd	r26, Y+3	; 0x03
    85ec:	bc 81       	ldd	r27, Y+4	; 0x04
    85ee:	02 97       	sbiw	r24, 0x02	; 2
    85f0:	a1 09       	sbc	r26, r1
    85f2:	b1 09       	sbc	r27, r1
    85f4:	20 91 78 50 	lds	r18, 0x5078
    85f8:	30 91 79 50 	lds	r19, 0x5079
    85fc:	99 01       	movw	r18, r18
    85fe:	40 e0       	ldi	r20, 0x00	; 0
    8600:	50 e0       	ldi	r21, 0x00	; 0
    8602:	bc 01       	movw	r22, r24
    8604:	cd 01       	movw	r24, r26
    8606:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    860a:	9b 01       	movw	r18, r22
    860c:	ac 01       	movw	r20, r24
    860e:	80 91 dc 23 	lds	r24, 0x23DC
    8612:	90 91 dd 23 	lds	r25, 0x23DD
    8616:	a0 91 de 23 	lds	r26, 0x23DE
    861a:	b0 91 df 23 	lds	r27, 0x23DF
    861e:	82 0f       	add	r24, r18
    8620:	93 1f       	adc	r25, r19
    8622:	a4 1f       	adc	r26, r20
    8624:	b5 1f       	adc	r27, r21
}
    8626:	bc 01       	movw	r22, r24
    8628:	cd 01       	movw	r24, r26
    862a:	24 96       	adiw	r28, 0x04	; 4
    862c:	cd bf       	out	0x3d, r28	; 61
    862e:	de bf       	out	0x3e, r29	; 62
    8630:	df 91       	pop	r29
    8632:	cf 91       	pop	r28
    8634:	08 95       	ret

00008636 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    8636:	ef 92       	push	r14
    8638:	ff 92       	push	r15
    863a:	0f 93       	push	r16
    863c:	1f 93       	push	r17
    863e:	cf 93       	push	r28
    8640:	df 93       	push	r29
    8642:	cd b7       	in	r28, 0x3d	; 61
    8644:	de b7       	in	r29, 0x3e	; 62
    8646:	62 97       	sbiw	r28, 0x12	; 18
    8648:	cd bf       	out	0x3d, r28	; 61
    864a:	de bf       	out	0x3e, r29	; 62
    864c:	6a 87       	std	Y+10, r22	; 0x0a
    864e:	7b 87       	std	Y+11, r23	; 0x0b
    8650:	8c 87       	std	Y+12, r24	; 0x0c
    8652:	9d 87       	std	Y+13, r25	; 0x0d
    8654:	4e 87       	std	Y+14, r20	; 0x0e
    8656:	0f 87       	std	Y+15, r16	; 0x0f
    8658:	18 8b       	std	Y+16, r17	; 0x10
    865a:	29 8b       	std	Y+17, r18	; 0x11
    865c:	3a 8b       	std	Y+18, r19	; 0x12
unsigned int FATEntryOffset;
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
unsigned char retry = 0;
    865e:	19 82       	std	Y+1, r1	; 0x01

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    8660:	80 91 80 50 	lds	r24, 0x5080
    8664:	90 91 81 50 	lds	r25, 0x5081
    8668:	9c 01       	movw	r18, r24
    866a:	40 e0       	ldi	r20, 0x00	; 0
    866c:	50 e0       	ldi	r21, 0x00	; 0
    866e:	80 91 7a 50 	lds	r24, 0x507A
    8672:	90 91 7b 50 	lds	r25, 0x507B
    8676:	a0 91 7c 50 	lds	r26, 0x507C
    867a:	b0 91 7d 50 	lds	r27, 0x507D
    867e:	79 01       	movw	r14, r18
    8680:	8a 01       	movw	r16, r20
    8682:	e8 0e       	add	r14, r24
    8684:	f9 1e       	adc	r15, r25
    8686:	0a 1f       	adc	r16, r26
    8688:	1b 1f       	adc	r17, r27
    868a:	8a 85       	ldd	r24, Y+10	; 0x0a
    868c:	9b 85       	ldd	r25, Y+11	; 0x0b
    868e:	ac 85       	ldd	r26, Y+12	; 0x0c
    8690:	bd 85       	ldd	r27, Y+13	; 0x0d
    8692:	88 0f       	add	r24, r24
    8694:	99 1f       	adc	r25, r25
    8696:	aa 1f       	adc	r26, r26
    8698:	bb 1f       	adc	r27, r27
    869a:	88 0f       	add	r24, r24
    869c:	99 1f       	adc	r25, r25
    869e:	aa 1f       	adc	r26, r26
    86a0:	bb 1f       	adc	r27, r27
    86a2:	20 91 55 40 	lds	r18, 0x4055
    86a6:	30 91 56 40 	lds	r19, 0x4056
    86aa:	99 01       	movw	r18, r18
    86ac:	40 e0       	ldi	r20, 0x00	; 0
    86ae:	50 e0       	ldi	r21, 0x00	; 0
    86b0:	bc 01       	movw	r22, r24
    86b2:	cd 01       	movw	r24, r26
    86b4:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    86b8:	da 01       	movw	r26, r20
    86ba:	c9 01       	movw	r24, r18
    86bc:	8e 0d       	add	r24, r14
    86be:	9f 1d       	adc	r25, r15
    86c0:	a0 1f       	adc	r26, r16
    86c2:	b1 1f       	adc	r27, r17
    86c4:	8a 83       	std	Y+2, r24	; 0x02
    86c6:	9b 83       	std	Y+3, r25	; 0x03
    86c8:	ac 83       	std	Y+4, r26	; 0x04
    86ca:	bd 83       	std	Y+5, r27	; 0x05

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    86cc:	8a 85       	ldd	r24, Y+10	; 0x0a
    86ce:	9b 85       	ldd	r25, Y+11	; 0x0b
    86d0:	ac 85       	ldd	r26, Y+12	; 0x0c
    86d2:	bd 85       	ldd	r27, Y+13	; 0x0d
    86d4:	88 0f       	add	r24, r24
    86d6:	99 1f       	adc	r25, r25
    86d8:	aa 1f       	adc	r26, r26
    86da:	bb 1f       	adc	r27, r27
    86dc:	88 0f       	add	r24, r24
    86de:	99 1f       	adc	r25, r25
    86e0:	aa 1f       	adc	r26, r26
    86e2:	bb 1f       	adc	r27, r27
    86e4:	20 91 55 40 	lds	r18, 0x4055
    86e8:	30 91 56 40 	lds	r19, 0x4056
    86ec:	99 01       	movw	r18, r18
    86ee:	40 e0       	ldi	r20, 0x00	; 0
    86f0:	50 e0       	ldi	r21, 0x00	; 0
    86f2:	bc 01       	movw	r22, r24
    86f4:	cd 01       	movw	r24, r26
    86f6:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    86fa:	dc 01       	movw	r26, r24
    86fc:	cb 01       	movw	r24, r22
    86fe:	8e 83       	std	Y+6, r24	; 0x06
    8700:	9f 83       	std	Y+7, r25	; 0x07

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    8702:	8a 81       	ldd	r24, Y+2	; 0x02
    8704:	9b 81       	ldd	r25, Y+3	; 0x03
    8706:	ac 81       	ldd	r26, Y+4	; 0x04
    8708:	bd 81       	ldd	r27, Y+5	; 0x05
    870a:	27 ed       	ldi	r18, 0xD7	; 215
    870c:	31 e2       	ldi	r19, 0x21	; 33
    870e:	bc 01       	movw	r22, r24
    8710:	cd 01       	movw	r24, r26
    8712:	a9 01       	movw	r20, r18
    8714:	0e 94 15 51 	call	0xa22a	; 0xa22a <SD_read_block>

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    8718:	8e 81       	ldd	r24, Y+6	; 0x06
    871a:	9f 81       	ldd	r25, Y+7	; 0x07
    871c:	89 52       	subi	r24, 0x29	; 41
    871e:	9e 4d       	sbci	r25, 0xDE	; 222
    8720:	88 87       	std	Y+8, r24	; 0x08
    8722:	99 87       	std	Y+9, r25	; 0x09

if(get_set == GET)
    8724:	8e 85       	ldd	r24, Y+14	; 0x0e
    8726:	88 23       	and	r24, r24
    8728:	49 f4       	brne	.+18     	; 0x873c <getSetNextCluster+0x106>
  return ((*FATEntryValue) & 0x0fffffff);
    872a:	88 85       	ldd	r24, Y+8	; 0x08
    872c:	99 85       	ldd	r25, Y+9	; 0x09
    872e:	fc 01       	movw	r30, r24
    8730:	80 81       	ld	r24, Z
    8732:	91 81       	ldd	r25, Z+1	; 0x01
    8734:	a2 81       	ldd	r26, Z+2	; 0x02
    8736:	b3 81       	ldd	r27, Z+3	; 0x03
    8738:	bf 70       	andi	r27, 0x0F	; 15
    873a:	1b c0       	rjmp	.+54     	; 0x8772 <getSetNextCluster+0x13c>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    873c:	28 85       	ldd	r18, Y+8	; 0x08
    873e:	39 85       	ldd	r19, Y+9	; 0x09
    8740:	8f 85       	ldd	r24, Y+15	; 0x0f
    8742:	98 89       	ldd	r25, Y+16	; 0x10
    8744:	a9 89       	ldd	r26, Y+17	; 0x11
    8746:	ba 89       	ldd	r27, Y+18	; 0x12
    8748:	f9 01       	movw	r30, r18
    874a:	80 83       	st	Z, r24
    874c:	91 83       	std	Z+1, r25	; 0x01
    874e:	a2 83       	std	Z+2, r26	; 0x02
    8750:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    8752:	8a 81       	ldd	r24, Y+2	; 0x02
    8754:	9b 81       	ldd	r25, Y+3	; 0x03
    8756:	ac 81       	ldd	r26, Y+4	; 0x04
    8758:	bd 81       	ldd	r27, Y+5	; 0x05
    875a:	27 ed       	ldi	r18, 0xD7	; 215
    875c:	31 e2       	ldi	r19, 0x21	; 33
    875e:	bc 01       	movw	r22, r24
    8760:	cd 01       	movw	r24, r26
    8762:	a9 01       	movw	r20, r18
    8764:	20 e0       	ldi	r18, 0x00	; 0
    8766:	32 e0       	ldi	r19, 0x02	; 2
    8768:	0e 94 47 50 	call	0xa08e	; 0xa08e <SD_write_block>

return (0);
    876c:	80 e0       	ldi	r24, 0x00	; 0
    876e:	90 e0       	ldi	r25, 0x00	; 0
    8770:	dc 01       	movw	r26, r24
}
    8772:	bc 01       	movw	r22, r24
    8774:	cd 01       	movw	r24, r26
    8776:	62 96       	adiw	r28, 0x12	; 18
    8778:	cd bf       	out	0x3d, r28	; 61
    877a:	de bf       	out	0x3e, r29	; 62
    877c:	df 91       	pop	r29
    877e:	cf 91       	pop	r28
    8780:	1f 91       	pop	r17
    8782:	0f 91       	pop	r16
    8784:	ff 90       	pop	r15
    8786:	ef 90       	pop	r14
    8788:	08 95       	ret

0000878a <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    878a:	cf 93       	push	r28
    878c:	df 93       	push	r29
    878e:	cd b7       	in	r28, 0x3d	; 61
    8790:	de b7       	in	r29, 0x3e	; 62
    8792:	28 97       	sbiw	r28, 0x08	; 8
    8794:	cd bf       	out	0x3d, r28	; 61
    8796:	de bf       	out	0x3e, r29	; 62
    8798:	8b 83       	std	Y+3, r24	; 0x03
    879a:	6c 83       	std	Y+4, r22	; 0x04
    879c:	2d 83       	std	Y+5, r18	; 0x05
    879e:	3e 83       	std	Y+6, r19	; 0x06
    87a0:	4f 83       	std	Y+7, r20	; 0x07
    87a2:	58 87       	std	Y+8, r21	; 0x08
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;
    87a4:	87 ed       	ldi	r24, 0xD7	; 215
    87a6:	91 e2       	ldi	r25, 0x21	; 33
    87a8:	89 83       	std	Y+1, r24	; 0x01
    87aa:	9a 83       	std	Y+2, r25	; 0x02

SD_read_block(unusedSectors + 1,SDBuffer);
    87ac:	80 91 7a 50 	lds	r24, 0x507A
    87b0:	90 91 7b 50 	lds	r25, 0x507B
    87b4:	a0 91 7c 50 	lds	r26, 0x507C
    87b8:	b0 91 7d 50 	lds	r27, 0x507D
    87bc:	01 96       	adiw	r24, 0x01	; 1
    87be:	a1 1d       	adc	r26, r1
    87c0:	b1 1d       	adc	r27, r1
    87c2:	27 ed       	ldi	r18, 0xD7	; 215
    87c4:	31 e2       	ldi	r19, 0x21	; 33
    87c6:	bc 01       	movw	r22, r24
    87c8:	cd 01       	movw	r24, r26
    87ca:	a9 01       	movw	r20, r18
    87cc:	0e 94 15 51 	call	0xa22a	; 0xa22a <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    87d0:	89 81       	ldd	r24, Y+1	; 0x01
    87d2:	9a 81       	ldd	r25, Y+2	; 0x02
    87d4:	fc 01       	movw	r30, r24
    87d6:	80 81       	ld	r24, Z
    87d8:	91 81       	ldd	r25, Z+1	; 0x01
    87da:	a2 81       	ldd	r26, Z+2	; 0x02
    87dc:	b3 81       	ldd	r27, Z+3	; 0x03
    87de:	82 35       	cpi	r24, 0x52	; 82
    87e0:	f2 e5       	ldi	r31, 0x52	; 82
    87e2:	9f 07       	cpc	r25, r31
    87e4:	f1 e6       	ldi	r31, 0x61	; 97
    87e6:	af 07       	cpc	r26, r31
    87e8:	f1 e4       	ldi	r31, 0x41	; 65
    87ea:	bf 07       	cpc	r27, r31
    87ec:	11 f5       	brne	.+68     	; 0x8832 <getSetFreeCluster+0xa8>
    87ee:	89 81       	ldd	r24, Y+1	; 0x01
    87f0:	9a 81       	ldd	r25, Y+2	; 0x02
    87f2:	8c 51       	subi	r24, 0x1C	; 28
    87f4:	9e 4f       	sbci	r25, 0xFE	; 254
    87f6:	fc 01       	movw	r30, r24
    87f8:	80 81       	ld	r24, Z
    87fa:	91 81       	ldd	r25, Z+1	; 0x01
    87fc:	a2 81       	ldd	r26, Z+2	; 0x02
    87fe:	b3 81       	ldd	r27, Z+3	; 0x03
    8800:	82 37       	cpi	r24, 0x72	; 114
    8802:	f2 e7       	ldi	r31, 0x72	; 114
    8804:	9f 07       	cpc	r25, r31
    8806:	f1 e4       	ldi	r31, 0x41	; 65
    8808:	af 07       	cpc	r26, r31
    880a:	f1 e6       	ldi	r31, 0x61	; 97
    880c:	bf 07       	cpc	r27, r31
    880e:	89 f4       	brne	.+34     	; 0x8832 <getSetFreeCluster+0xa8>
    8810:	89 81       	ldd	r24, Y+1	; 0x01
    8812:	9a 81       	ldd	r25, Y+2	; 0x02
    8814:	84 50       	subi	r24, 0x04	; 4
    8816:	9e 4f       	sbci	r25, 0xFE	; 254
    8818:	fc 01       	movw	r30, r24
    881a:	80 81       	ld	r24, Z
    881c:	91 81       	ldd	r25, Z+1	; 0x01
    881e:	a2 81       	ldd	r26, Z+2	; 0x02
    8820:	b3 81       	ldd	r27, Z+3	; 0x03
    8822:	80 30       	cpi	r24, 0x00	; 0
    8824:	f0 e0       	ldi	r31, 0x00	; 0
    8826:	9f 07       	cpc	r25, r31
    8828:	f5 e5       	ldi	r31, 0x55	; 85
    882a:	af 07       	cpc	r26, r31
    882c:	fa ea       	ldi	r31, 0xAA	; 170
    882e:	bf 07       	cpc	r27, r31
    8830:	21 f0       	breq	.+8      	; 0x883a <getSetFreeCluster+0xb0>
  return 0xffffffff;
    8832:	8f ef       	ldi	r24, 0xFF	; 255
    8834:	9f ef       	ldi	r25, 0xFF	; 255
    8836:	dc 01       	movw	r26, r24
    8838:	51 c0       	rjmp	.+162    	; 0x88dc <getSetFreeCluster+0x152>

 if(get_set == GET)
    883a:	8c 81       	ldd	r24, Y+4	; 0x04
    883c:	88 23       	and	r24, r24
    883e:	b9 f4       	brne	.+46     	; 0x886e <getSetFreeCluster+0xe4>
 {
   if(totOrNext == TOTAL_FREE)
    8840:	8b 81       	ldd	r24, Y+3	; 0x03
    8842:	81 30       	cpi	r24, 0x01	; 1
    8844:	51 f4       	brne	.+20     	; 0x885a <getSetFreeCluster+0xd0>
      return(FS->freeClusterCount);
    8846:	89 81       	ldd	r24, Y+1	; 0x01
    8848:	9a 81       	ldd	r25, Y+2	; 0x02
    884a:	88 51       	subi	r24, 0x18	; 24
    884c:	9e 4f       	sbci	r25, 0xFE	; 254
    884e:	fc 01       	movw	r30, r24
    8850:	80 81       	ld	r24, Z
    8852:	91 81       	ldd	r25, Z+1	; 0x01
    8854:	a2 81       	ldd	r26, Z+2	; 0x02
    8856:	b3 81       	ldd	r27, Z+3	; 0x03
    8858:	41 c0       	rjmp	.+130    	; 0x88dc <getSetFreeCluster+0x152>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    885a:	89 81       	ldd	r24, Y+1	; 0x01
    885c:	9a 81       	ldd	r25, Y+2	; 0x02
    885e:	84 51       	subi	r24, 0x14	; 20
    8860:	9e 4f       	sbci	r25, 0xFE	; 254
    8862:	fc 01       	movw	r30, r24
    8864:	80 81       	ld	r24, Z
    8866:	91 81       	ldd	r25, Z+1	; 0x01
    8868:	a2 81       	ldd	r26, Z+2	; 0x02
    886a:	b3 81       	ldd	r27, Z+3	; 0x03
    886c:	37 c0       	rjmp	.+110    	; 0x88dc <getSetFreeCluster+0x152>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    886e:	8b 81       	ldd	r24, Y+3	; 0x03
    8870:	81 30       	cpi	r24, 0x01	; 1
    8872:	79 f4       	brne	.+30     	; 0x8892 <getSetFreeCluster+0x108>
      FS->freeClusterCount = FSEntry;
    8874:	89 81       	ldd	r24, Y+1	; 0x01
    8876:	9a 81       	ldd	r25, Y+2	; 0x02
    8878:	9c 01       	movw	r18, r24
    887a:	28 51       	subi	r18, 0x18	; 24
    887c:	3e 4f       	sbci	r19, 0xFE	; 254
    887e:	8d 81       	ldd	r24, Y+5	; 0x05
    8880:	9e 81       	ldd	r25, Y+6	; 0x06
    8882:	af 81       	ldd	r26, Y+7	; 0x07
    8884:	b8 85       	ldd	r27, Y+8	; 0x08
    8886:	f9 01       	movw	r30, r18
    8888:	80 83       	st	Z, r24
    888a:	91 83       	std	Z+1, r25	; 0x01
    888c:	a2 83       	std	Z+2, r26	; 0x02
    888e:	b3 83       	std	Z+3, r27	; 0x03
    8890:	0e c0       	rjmp	.+28     	; 0x88ae <getSetFreeCluster+0x124>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    8892:	89 81       	ldd	r24, Y+1	; 0x01
    8894:	9a 81       	ldd	r25, Y+2	; 0x02
    8896:	9c 01       	movw	r18, r24
    8898:	24 51       	subi	r18, 0x14	; 20
    889a:	3e 4f       	sbci	r19, 0xFE	; 254
    889c:	8d 81       	ldd	r24, Y+5	; 0x05
    889e:	9e 81       	ldd	r25, Y+6	; 0x06
    88a0:	af 81       	ldd	r26, Y+7	; 0x07
    88a2:	b8 85       	ldd	r27, Y+8	; 0x08
    88a4:	f9 01       	movw	r30, r18
    88a6:	80 83       	st	Z, r24
    88a8:	91 83       	std	Z+1, r25	; 0x01
    88aa:	a2 83       	std	Z+2, r26	; 0x02
    88ac:	b3 83       	std	Z+3, r27	; 0x03
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    88ae:	80 91 7a 50 	lds	r24, 0x507A
    88b2:	90 91 7b 50 	lds	r25, 0x507B
    88b6:	a0 91 7c 50 	lds	r26, 0x507C
    88ba:	b0 91 7d 50 	lds	r27, 0x507D
    88be:	01 96       	adiw	r24, 0x01	; 1
    88c0:	a1 1d       	adc	r26, r1
    88c2:	b1 1d       	adc	r27, r1
    88c4:	27 ed       	ldi	r18, 0xD7	; 215
    88c6:	31 e2       	ldi	r19, 0x21	; 33
    88c8:	bc 01       	movw	r22, r24
    88ca:	cd 01       	movw	r24, r26
    88cc:	a9 01       	movw	r20, r18
    88ce:	20 e0       	ldi	r18, 0x00	; 0
    88d0:	32 e0       	ldi	r19, 0x02	; 2
    88d2:	0e 94 47 50 	call	0xa08e	; 0xa08e <SD_write_block>
 }
 return 0xffffffff;
    88d6:	8f ef       	ldi	r24, 0xFF	; 255
    88d8:	9f ef       	ldi	r25, 0xFF	; 255
    88da:	dc 01       	movw	r26, r24
}
    88dc:	bc 01       	movw	r22, r24
    88de:	cd 01       	movw	r24, r26
    88e0:	28 96       	adiw	r28, 0x08	; 8
    88e2:	cd bf       	out	0x3d, r28	; 61
    88e4:	de bf       	out	0x3e, r29	; 62
    88e6:	df 91       	pop	r29
    88e8:	cf 91       	pop	r28
    88ea:	08 95       	ret

000088ec <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    88ec:	0f 93       	push	r16
    88ee:	1f 93       	push	r17
    88f0:	cf 93       	push	r28
    88f2:	df 93       	push	r29
    88f4:	cd b7       	in	r28, 0x3d	; 61
    88f6:	de b7       	in	r29, 0x3e	; 62
    88f8:	6c 97       	sbiw	r28, 0x1c	; 28
    88fa:	cd bf       	out	0x3d, r28	; 61
    88fc:	de bf       	out	0x3e, r29	; 62
    88fe:	8a 8f       	std	Y+26, r24	; 0x1a
    8900:	6b 8f       	std	Y+27, r22	; 0x1b
    8902:	7c 8f       	std	Y+28, r23	; 0x1c
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    8904:	80 91 60 40 	lds	r24, 0x4060
    8908:	90 91 61 40 	lds	r25, 0x4061
    890c:	a0 91 62 40 	lds	r26, 0x4062
    8910:	b0 91 63 40 	lds	r27, 0x4063
    8914:	89 83       	std	Y+1, r24	; 0x01
    8916:	9a 83       	std	Y+2, r25	; 0x02
    8918:	ab 83       	std	Y+3, r26	; 0x03
    891a:	bc 83       	std	Y+4, r27	; 0x04
    891c:	01 c0       	rjmp	.+2      	; 0x8920 <findFiles+0x34>
   if(cluster > 0x0ffffff6)
   	 return 0;
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
    891e:	00 00       	nop

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    8920:	89 81       	ldd	r24, Y+1	; 0x01
    8922:	9a 81       	ldd	r25, Y+2	; 0x02
    8924:	ab 81       	ldd	r26, Y+3	; 0x03
    8926:	bc 81       	ldd	r27, Y+4	; 0x04
    8928:	bc 01       	movw	r22, r24
    892a:	cd 01       	movw	r24, r26
    892c:	0e 94 e9 42 	call	0x85d2	; 0x85d2 <getFirstSector>
    8930:	dc 01       	movw	r26, r24
    8932:	cb 01       	movw	r24, r22
    8934:	88 8b       	std	Y+16, r24	; 0x10
    8936:	99 8b       	std	Y+17, r25	; 0x11
    8938:	aa 8b       	std	Y+18, r26	; 0x12
    893a:	bb 8b       	std	Y+19, r27	; 0x13

   for(sector = 0; sector < sectorPerCluster; sector++)
    893c:	1d 82       	std	Y+5, r1	; 0x05
    893e:	1e 82       	std	Y+6, r1	; 0x06
    8940:	1f 82       	std	Y+7, r1	; 0x07
    8942:	18 86       	std	Y+8, r1	; 0x08
    8944:	68 c1       	rjmp	.+720    	; 0x8c16 <findFiles+0x32a>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    8946:	28 89       	ldd	r18, Y+16	; 0x10
    8948:	39 89       	ldd	r19, Y+17	; 0x11
    894a:	4a 89       	ldd	r20, Y+18	; 0x12
    894c:	5b 89       	ldd	r21, Y+19	; 0x13
    894e:	8d 81       	ldd	r24, Y+5	; 0x05
    8950:	9e 81       	ldd	r25, Y+6	; 0x06
    8952:	af 81       	ldd	r26, Y+7	; 0x07
    8954:	b8 85       	ldd	r27, Y+8	; 0x08
    8956:	82 0f       	add	r24, r18
    8958:	93 1f       	adc	r25, r19
    895a:	a4 1f       	adc	r26, r20
    895c:	b5 1f       	adc	r27, r21
    895e:	27 ed       	ldi	r18, 0xD7	; 215
    8960:	31 e2       	ldi	r19, 0x21	; 33
    8962:	bc 01       	movw	r22, r24
    8964:	cd 01       	movw	r24, r26
    8966:	a9 01       	movw	r20, r18
    8968:	0e 94 15 51 	call	0xa22a	; 0xa22a <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    896c:	1d 86       	std	Y+13, r1	; 0x0d
    896e:	1e 86       	std	Y+14, r1	; 0x0e
    8970:	3d c1       	rjmp	.+634    	; 0x8bec <findFiles+0x300>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    8972:	8d 85       	ldd	r24, Y+13	; 0x0d
    8974:	9e 85       	ldd	r25, Y+14	; 0x0e
    8976:	89 52       	subi	r24, 0x29	; 41
    8978:	9e 4d       	sbci	r25, 0xDE	; 222
    897a:	8c 8b       	std	Y+20, r24	; 0x14
    897c:	9d 8b       	std	Y+21, r25	; 0x15

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    897e:	8c 89       	ldd	r24, Y+20	; 0x14
    8980:	9d 89       	ldd	r25, Y+21	; 0x15
    8982:	fc 01       	movw	r30, r24
    8984:	80 81       	ld	r24, Z
    8986:	88 23       	and	r24, r24
    8988:	19 f4       	brne	.+6      	; 0x8990 <findFiles+0xa4>
		{
		  return 0;   
    898a:	80 e0       	ldi	r24, 0x00	; 0
    898c:	90 e0       	ldi	r25, 0x00	; 0
    898e:	80 c1       	rjmp	.+768    	; 0x8c90 <findFiles+0x3a4>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    8990:	8c 89       	ldd	r24, Y+20	; 0x14
    8992:	9d 89       	ldd	r25, Y+21	; 0x15
    8994:	fc 01       	movw	r30, r24
    8996:	80 81       	ld	r24, Z
    8998:	85 3e       	cpi	r24, 0xE5	; 229
    899a:	09 f4       	brne	.+2      	; 0x899e <findFiles+0xb2>
    899c:	22 c1       	rjmp	.+580    	; 0x8be2 <findFiles+0x2f6>
    899e:	8c 89       	ldd	r24, Y+20	; 0x14
    89a0:	9d 89       	ldd	r25, Y+21	; 0x15
    89a2:	fc 01       	movw	r30, r24
    89a4:	83 85       	ldd	r24, Z+11	; 0x0b
    89a6:	8f 30       	cpi	r24, 0x0F	; 15
    89a8:	09 f4       	brne	.+2      	; 0x89ac <findFiles+0xc0>
    89aa:	1b c1       	rjmp	.+566    	; 0x8be2 <findFiles+0x2f6>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    89ac:	8a 8d       	ldd	r24, Y+26	; 0x1a
    89ae:	81 30       	cpi	r24, 0x01	; 1
    89b0:	21 f0       	breq	.+8      	; 0x89ba <findFiles+0xce>
    89b2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    89b4:	82 30       	cpi	r24, 0x02	; 2
    89b6:	09 f0       	breq	.+2      	; 0x89ba <findFiles+0xce>
    89b8:	11 c1       	rjmp	.+546    	; 0x8bdc <findFiles+0x2f0>
          {
            for(j=0; j<11; j++)
    89ba:	1f 86       	std	Y+15, r1	; 0x0f
    89bc:	17 c0       	rjmp	.+46     	; 0x89ec <findFiles+0x100>
            if(dir->name[j] != fileName[j]) break;
    89be:	8f 85       	ldd	r24, Y+15	; 0x0f
    89c0:	88 2f       	mov	r24, r24
    89c2:	90 e0       	ldi	r25, 0x00	; 0
    89c4:	2c 89       	ldd	r18, Y+20	; 0x14
    89c6:	3d 89       	ldd	r19, Y+21	; 0x15
    89c8:	82 0f       	add	r24, r18
    89ca:	93 1f       	adc	r25, r19
    89cc:	fc 01       	movw	r30, r24
    89ce:	40 81       	ld	r20, Z
    89d0:	8f 85       	ldd	r24, Y+15	; 0x0f
    89d2:	88 2f       	mov	r24, r24
    89d4:	90 e0       	ldi	r25, 0x00	; 0
    89d6:	2b 8d       	ldd	r18, Y+27	; 0x1b
    89d8:	3c 8d       	ldd	r19, Y+28	; 0x1c
    89da:	82 0f       	add	r24, r18
    89dc:	93 1f       	adc	r25, r19
    89de:	fc 01       	movw	r30, r24
    89e0:	80 81       	ld	r24, Z
    89e2:	48 17       	cp	r20, r24
    89e4:	39 f4       	brne	.+14     	; 0x89f4 <findFiles+0x108>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    89e6:	8f 85       	ldd	r24, Y+15	; 0x0f
    89e8:	8f 5f       	subi	r24, 0xFF	; 255
    89ea:	8f 87       	std	Y+15, r24	; 0x0f
    89ec:	8f 85       	ldd	r24, Y+15	; 0x0f
    89ee:	8b 30       	cpi	r24, 0x0B	; 11
    89f0:	30 f3       	brcs	.-52     	; 0x89be <findFiles+0xd2>
    89f2:	01 c0       	rjmp	.+2      	; 0x89f6 <findFiles+0x10a>
            if(dir->name[j] != fileName[j]) break;
    89f4:	00 00       	nop
            if(j == 11)
    89f6:	8f 85       	ldd	r24, Y+15	; 0x0f
    89f8:	8b 30       	cpi	r24, 0x0B	; 11
    89fa:	09 f0       	breq	.+2      	; 0x89fe <findFiles+0x112>
    89fc:	f2 c0       	rjmp	.+484    	; 0x8be2 <findFiles+0x2f6>
			{
			  if(flag == GET_FILE)
    89fe:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8a00:	81 30       	cpi	r24, 0x01	; 1
    8a02:	09 f0       	breq	.+2      	; 0x8a06 <findFiles+0x11a>
    8a04:	52 c0       	rjmp	.+164    	; 0x8aaa <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    8a06:	28 89       	ldd	r18, Y+16	; 0x10
    8a08:	39 89       	ldd	r19, Y+17	; 0x11
    8a0a:	4a 89       	ldd	r20, Y+18	; 0x12
    8a0c:	5b 89       	ldd	r21, Y+19	; 0x13
    8a0e:	8d 81       	ldd	r24, Y+5	; 0x05
    8a10:	9e 81       	ldd	r25, Y+6	; 0x06
    8a12:	af 81       	ldd	r26, Y+7	; 0x07
    8a14:	b8 85       	ldd	r27, Y+8	; 0x08
    8a16:	82 0f       	add	r24, r18
    8a18:	93 1f       	adc	r25, r19
    8a1a:	a4 1f       	adc	r26, r20
    8a1c:	b5 1f       	adc	r27, r21
    8a1e:	80 93 ce 50 	sts	0x50CE, r24
    8a22:	90 93 cf 50 	sts	0x50CF, r25
    8a26:	a0 93 d0 50 	sts	0x50D0, r26
    8a2a:	b0 93 d1 50 	sts	0x50D1, r27
				appendFileLocation = i;
    8a2e:	8d 85       	ldd	r24, Y+13	; 0x0d
    8a30:	9e 85       	ldd	r25, Y+14	; 0x0e
    8a32:	cc 01       	movw	r24, r24
    8a34:	a0 e0       	ldi	r26, 0x00	; 0
    8a36:	b0 e0       	ldi	r27, 0x00	; 0
    8a38:	80 93 d8 23 	sts	0x23D8, r24
    8a3c:	90 93 d9 23 	sts	0x23D9, r25
    8a40:	a0 93 da 23 	sts	0x23DA, r26
    8a44:	b0 93 db 23 	sts	0x23DB, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8a48:	8c 89       	ldd	r24, Y+20	; 0x14
    8a4a:	9d 89       	ldd	r25, Y+21	; 0x15
    8a4c:	fc 01       	movw	r30, r24
    8a4e:	84 89       	ldd	r24, Z+20	; 0x14
    8a50:	95 89       	ldd	r25, Z+21	; 0x15
    8a52:	cc 01       	movw	r24, r24
    8a54:	a0 e0       	ldi	r26, 0x00	; 0
    8a56:	b0 e0       	ldi	r27, 0x00	; 0
    8a58:	ac 01       	movw	r20, r24
    8a5a:	33 27       	eor	r19, r19
    8a5c:	22 27       	eor	r18, r18
    8a5e:	8c 89       	ldd	r24, Y+20	; 0x14
    8a60:	9d 89       	ldd	r25, Y+21	; 0x15
    8a62:	fc 01       	movw	r30, r24
    8a64:	82 8d       	ldd	r24, Z+26	; 0x1a
    8a66:	93 8d       	ldd	r25, Z+27	; 0x1b
    8a68:	cc 01       	movw	r24, r24
    8a6a:	a0 e0       	ldi	r26, 0x00	; 0
    8a6c:	b0 e0       	ldi	r27, 0x00	; 0
    8a6e:	82 2b       	or	r24, r18
    8a70:	93 2b       	or	r25, r19
    8a72:	a4 2b       	or	r26, r20
    8a74:	b5 2b       	or	r27, r21
    8a76:	80 93 84 50 	sts	0x5084, r24
    8a7a:	90 93 85 50 	sts	0x5085, r25
    8a7e:	a0 93 86 50 	sts	0x5086, r26
    8a82:	b0 93 87 50 	sts	0x5087, r27
				fileSize = dir->fileSize;
    8a86:	8c 89       	ldd	r24, Y+20	; 0x14
    8a88:	9d 89       	ldd	r25, Y+21	; 0x15
    8a8a:	fc 01       	movw	r30, r24
    8a8c:	84 8d       	ldd	r24, Z+28	; 0x1c
    8a8e:	95 8d       	ldd	r25, Z+29	; 0x1d
    8a90:	a6 8d       	ldd	r26, Z+30	; 0x1e
    8a92:	b7 8d       	ldd	r27, Z+31	; 0x1f
    8a94:	80 93 51 40 	sts	0x4051, r24
    8a98:	90 93 52 40 	sts	0x4052, r25
    8a9c:	a0 93 53 40 	sts	0x4053, r26
    8aa0:	b0 93 54 40 	sts	0x4054, r27
			    return (dir);
    8aa4:	8c 89       	ldd	r24, Y+20	; 0x14
    8aa6:	9d 89       	ldd	r25, Y+21	; 0x15
    8aa8:	f3 c0       	rjmp	.+486    	; 0x8c90 <findFiles+0x3a4>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8aaa:	8c 89       	ldd	r24, Y+20	; 0x14
    8aac:	9d 89       	ldd	r25, Y+21	; 0x15
    8aae:	fc 01       	movw	r30, r24
    8ab0:	84 89       	ldd	r24, Z+20	; 0x14
    8ab2:	95 89       	ldd	r25, Z+21	; 0x15
    8ab4:	cc 01       	movw	r24, r24
    8ab6:	a0 e0       	ldi	r26, 0x00	; 0
    8ab8:	b0 e0       	ldi	r27, 0x00	; 0
    8aba:	ac 01       	movw	r20, r24
    8abc:	33 27       	eor	r19, r19
    8abe:	22 27       	eor	r18, r18
    8ac0:	8c 89       	ldd	r24, Y+20	; 0x14
    8ac2:	9d 89       	ldd	r25, Y+21	; 0x15
    8ac4:	fc 01       	movw	r30, r24
    8ac6:	82 8d       	ldd	r24, Z+26	; 0x1a
    8ac8:	93 8d       	ldd	r25, Z+27	; 0x1b
    8aca:	cc 01       	movw	r24, r24
    8acc:	a0 e0       	ldi	r26, 0x00	; 0
    8ace:	b0 e0       	ldi	r27, 0x00	; 0
    8ad0:	82 2b       	or	r24, r18
    8ad2:	93 2b       	or	r25, r19
    8ad4:	a4 2b       	or	r26, r20
    8ad6:	b5 2b       	or	r27, r21
    8ad8:	89 87       	std	Y+9, r24	; 0x09
    8ada:	9a 87       	std	Y+10, r25	; 0x0a
    8adc:	ab 87       	std	Y+11, r26	; 0x0b
    8ade:	bc 87       	std	Y+12, r27	; 0x0c
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    8ae0:	8c 89       	ldd	r24, Y+20	; 0x14
    8ae2:	9d 89       	ldd	r25, Y+21	; 0x15
    8ae4:	25 ee       	ldi	r18, 0xE5	; 229
    8ae6:	fc 01       	movw	r30, r24
    8ae8:	20 83       	st	Z, r18
				 SD_write_block (firstSector+sector,SDBuffer,512);
    8aea:	28 89       	ldd	r18, Y+16	; 0x10
    8aec:	39 89       	ldd	r19, Y+17	; 0x11
    8aee:	4a 89       	ldd	r20, Y+18	; 0x12
    8af0:	5b 89       	ldd	r21, Y+19	; 0x13
    8af2:	8d 81       	ldd	r24, Y+5	; 0x05
    8af4:	9e 81       	ldd	r25, Y+6	; 0x06
    8af6:	af 81       	ldd	r26, Y+7	; 0x07
    8af8:	b8 85       	ldd	r27, Y+8	; 0x08
    8afa:	82 0f       	add	r24, r18
    8afc:	93 1f       	adc	r25, r19
    8afe:	a4 1f       	adc	r26, r20
    8b00:	b5 1f       	adc	r27, r21
    8b02:	27 ed       	ldi	r18, 0xD7	; 215
    8b04:	31 e2       	ldi	r19, 0x21	; 33
    8b06:	bc 01       	movw	r22, r24
    8b08:	cd 01       	movw	r24, r26
    8b0a:	a9 01       	movw	r20, r18
    8b0c:	20 e0       	ldi	r18, 0x00	; 0
    8b0e:	32 e0       	ldi	r19, 0x02	; 2
    8b10:	0e 94 47 50 	call	0xa08e	; 0xa08e <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    8b14:	8c 89       	ldd	r24, Y+20	; 0x14
    8b16:	9d 89       	ldd	r25, Y+21	; 0x15
    8b18:	fc 01       	movw	r30, r24
    8b1a:	24 8d       	ldd	r18, Z+28	; 0x1c
    8b1c:	35 8d       	ldd	r19, Z+29	; 0x1d
    8b1e:	46 8d       	ldd	r20, Z+30	; 0x1e
    8b20:	57 8d       	ldd	r21, Z+31	; 0x1f
    8b22:	80 e0       	ldi	r24, 0x00	; 0
    8b24:	ba 01       	movw	r22, r20
    8b26:	a9 01       	movw	r20, r18
    8b28:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    8b2c:	82 e0       	ldi	r24, 0x02	; 2
    8b2e:	60 e0       	ldi	r22, 0x00	; 0
    8b30:	20 e0       	ldi	r18, 0x00	; 0
    8b32:	30 e0       	ldi	r19, 0x00	; 0
    8b34:	a9 01       	movw	r20, r18
    8b36:	0e 94 c5 43 	call	0x878a	; 0x878a <getSetFreeCluster>
    8b3a:	dc 01       	movw	r26, r24
    8b3c:	cb 01       	movw	r24, r22
    8b3e:	89 83       	std	Y+1, r24	; 0x01
    8b40:	9a 83       	std	Y+2, r25	; 0x02
    8b42:	ab 83       	std	Y+3, r26	; 0x03
    8b44:	bc 83       	std	Y+4, r27	; 0x04
				 if(firstCluster < cluster)
    8b46:	29 85       	ldd	r18, Y+9	; 0x09
    8b48:	3a 85       	ldd	r19, Y+10	; 0x0a
    8b4a:	4b 85       	ldd	r20, Y+11	; 0x0b
    8b4c:	5c 85       	ldd	r21, Y+12	; 0x0c
    8b4e:	89 81       	ldd	r24, Y+1	; 0x01
    8b50:	9a 81       	ldd	r25, Y+2	; 0x02
    8b52:	ab 81       	ldd	r26, Y+3	; 0x03
    8b54:	bc 81       	ldd	r27, Y+4	; 0x04
    8b56:	28 17       	cp	r18, r24
    8b58:	39 07       	cpc	r19, r25
    8b5a:	4a 07       	cpc	r20, r26
    8b5c:	5b 07       	cpc	r21, r27
    8b5e:	40 f4       	brcc	.+16     	; 0x8b70 <findFiles+0x284>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    8b60:	29 85       	ldd	r18, Y+9	; 0x09
    8b62:	3a 85       	ldd	r19, Y+10	; 0x0a
    8b64:	4b 85       	ldd	r20, Y+11	; 0x0b
    8b66:	5c 85       	ldd	r21, Y+12	; 0x0c
    8b68:	82 e0       	ldi	r24, 0x02	; 2
    8b6a:	61 e0       	ldi	r22, 0x01	; 1
    8b6c:	0e 94 c5 43 	call	0x878a	; 0x878a <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    8b70:	89 85       	ldd	r24, Y+9	; 0x09
    8b72:	9a 85       	ldd	r25, Y+10	; 0x0a
    8b74:	ab 85       	ldd	r26, Y+11	; 0x0b
    8b76:	bc 85       	ldd	r27, Y+12	; 0x0c
    8b78:	bc 01       	movw	r22, r24
    8b7a:	cd 01       	movw	r24, r26
    8b7c:	40 e0       	ldi	r20, 0x00	; 0
    8b7e:	00 e0       	ldi	r16, 0x00	; 0
    8b80:	10 e0       	ldi	r17, 0x00	; 0
    8b82:	98 01       	movw	r18, r16
    8b84:	0e 94 1b 43 	call	0x8636	; 0x8636 <getSetNextCluster>
    8b88:	dc 01       	movw	r26, r24
    8b8a:	cb 01       	movw	r24, r22
    8b8c:	8e 8b       	std	Y+22, r24	; 0x16
    8b8e:	9f 8b       	std	Y+23, r25	; 0x17
    8b90:	a8 8f       	std	Y+24, r26	; 0x18
    8b92:	b9 8f       	std	Y+25, r27	; 0x19
					getSetNextCluster (firstCluster, SET, 0);
    8b94:	89 85       	ldd	r24, Y+9	; 0x09
    8b96:	9a 85       	ldd	r25, Y+10	; 0x0a
    8b98:	ab 85       	ldd	r26, Y+11	; 0x0b
    8b9a:	bc 85       	ldd	r27, Y+12	; 0x0c
    8b9c:	bc 01       	movw	r22, r24
    8b9e:	cd 01       	movw	r24, r26
    8ba0:	41 e0       	ldi	r20, 0x01	; 1
    8ba2:	00 e0       	ldi	r16, 0x00	; 0
    8ba4:	10 e0       	ldi	r17, 0x00	; 0
    8ba6:	98 01       	movw	r18, r16
    8ba8:	0e 94 1b 43 	call	0x8636	; 0x8636 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    8bac:	8e 89       	ldd	r24, Y+22	; 0x16
    8bae:	9f 89       	ldd	r25, Y+23	; 0x17
    8bb0:	a8 8d       	ldd	r26, Y+24	; 0x18
    8bb2:	b9 8d       	ldd	r27, Y+25	; 0x19
    8bb4:	87 3f       	cpi	r24, 0xF7	; 247
    8bb6:	ff ef       	ldi	r31, 0xFF	; 255
    8bb8:	9f 07       	cpc	r25, r31
    8bba:	ff ef       	ldi	r31, 0xFF	; 255
    8bbc:	af 07       	cpc	r26, r31
    8bbe:	ff e0       	ldi	r31, 0x0F	; 15
    8bc0:	bf 07       	cpc	r27, r31
    8bc2:	18 f0       	brcs	.+6      	; 0x8bca <findFiles+0x2de>
					   {//file deleted
						   return 0;}
    8bc4:	80 e0       	ldi	r24, 0x00	; 0
    8bc6:	90 e0       	ldi	r25, 0x00	; 0
    8bc8:	63 c0       	rjmp	.+198    	; 0x8c90 <findFiles+0x3a4>
					firstCluster = nextCluster;
    8bca:	8e 89       	ldd	r24, Y+22	; 0x16
    8bcc:	9f 89       	ldd	r25, Y+23	; 0x17
    8bce:	a8 8d       	ldd	r26, Y+24	; 0x18
    8bd0:	b9 8d       	ldd	r27, Y+25	; 0x19
    8bd2:	89 87       	std	Y+9, r24	; 0x09
    8bd4:	9a 87       	std	Y+10, r25	; 0x0a
    8bd6:	ab 87       	std	Y+11, r26	; 0x0b
    8bd8:	bc 87       	std	Y+12, r27	; 0x0c
			  	 } 
    8bda:	ca cf       	rjmp	.-108    	; 0x8b70 <findFiles+0x284>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    8bdc:	80 e0       	ldi	r24, 0x00	; 0
    8bde:	90 e0       	ldi	r25, 0x00	; 0
    8be0:	57 c0       	rjmp	.+174    	; 0x8c90 <findFiles+0x3a4>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    8be2:	8d 85       	ldd	r24, Y+13	; 0x0d
    8be4:	9e 85       	ldd	r25, Y+14	; 0x0e
    8be6:	80 96       	adiw	r24, 0x20	; 32
    8be8:	8d 87       	std	Y+13, r24	; 0x0d
    8bea:	9e 87       	std	Y+14, r25	; 0x0e
    8bec:	80 91 55 40 	lds	r24, 0x4055
    8bf0:	90 91 56 40 	lds	r25, 0x4056
    8bf4:	2d 85       	ldd	r18, Y+13	; 0x0d
    8bf6:	3e 85       	ldd	r19, Y+14	; 0x0e
    8bf8:	28 17       	cp	r18, r24
    8bfa:	39 07       	cpc	r19, r25
    8bfc:	08 f4       	brcc	.+2      	; 0x8c00 <findFiles+0x314>
    8bfe:	b9 ce       	rjmp	.-654    	; 0x8972 <findFiles+0x86>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    8c00:	8d 81       	ldd	r24, Y+5	; 0x05
    8c02:	9e 81       	ldd	r25, Y+6	; 0x06
    8c04:	af 81       	ldd	r26, Y+7	; 0x07
    8c06:	b8 85       	ldd	r27, Y+8	; 0x08
    8c08:	01 96       	adiw	r24, 0x01	; 1
    8c0a:	a1 1d       	adc	r26, r1
    8c0c:	b1 1d       	adc	r27, r1
    8c0e:	8d 83       	std	Y+5, r24	; 0x05
    8c10:	9e 83       	std	Y+6, r25	; 0x06
    8c12:	af 83       	std	Y+7, r26	; 0x07
    8c14:	b8 87       	std	Y+8, r27	; 0x08
    8c16:	80 91 78 50 	lds	r24, 0x5078
    8c1a:	90 91 79 50 	lds	r25, 0x5079
    8c1e:	9c 01       	movw	r18, r24
    8c20:	40 e0       	ldi	r20, 0x00	; 0
    8c22:	50 e0       	ldi	r21, 0x00	; 0
    8c24:	8d 81       	ldd	r24, Y+5	; 0x05
    8c26:	9e 81       	ldd	r25, Y+6	; 0x06
    8c28:	af 81       	ldd	r26, Y+7	; 0x07
    8c2a:	b8 85       	ldd	r27, Y+8	; 0x08
    8c2c:	82 17       	cp	r24, r18
    8c2e:	93 07       	cpc	r25, r19
    8c30:	a4 07       	cpc	r26, r20
    8c32:	b5 07       	cpc	r27, r21
    8c34:	08 f4       	brcc	.+2      	; 0x8c38 <findFiles+0x34c>
    8c36:	87 ce       	rjmp	.-754    	; 0x8946 <findFiles+0x5a>
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    8c38:	89 81       	ldd	r24, Y+1	; 0x01
    8c3a:	9a 81       	ldd	r25, Y+2	; 0x02
    8c3c:	ab 81       	ldd	r26, Y+3	; 0x03
    8c3e:	bc 81       	ldd	r27, Y+4	; 0x04
    8c40:	bc 01       	movw	r22, r24
    8c42:	cd 01       	movw	r24, r26
    8c44:	40 e0       	ldi	r20, 0x00	; 0
    8c46:	00 e0       	ldi	r16, 0x00	; 0
    8c48:	10 e0       	ldi	r17, 0x00	; 0
    8c4a:	98 01       	movw	r18, r16
    8c4c:	0e 94 1b 43 	call	0x8636	; 0x8636 <getSetNextCluster>
    8c50:	dc 01       	movw	r26, r24
    8c52:	cb 01       	movw	r24, r22
    8c54:	89 83       	std	Y+1, r24	; 0x01
    8c56:	9a 83       	std	Y+2, r25	; 0x02
    8c58:	ab 83       	std	Y+3, r26	; 0x03
    8c5a:	bc 83       	std	Y+4, r27	; 0x04

   if(cluster > 0x0ffffff6)
    8c5c:	89 81       	ldd	r24, Y+1	; 0x01
    8c5e:	9a 81       	ldd	r25, Y+2	; 0x02
    8c60:	ab 81       	ldd	r26, Y+3	; 0x03
    8c62:	bc 81       	ldd	r27, Y+4	; 0x04
    8c64:	87 3f       	cpi	r24, 0xF7	; 247
    8c66:	2f ef       	ldi	r18, 0xFF	; 255
    8c68:	92 07       	cpc	r25, r18
    8c6a:	2f ef       	ldi	r18, 0xFF	; 255
    8c6c:	a2 07       	cpc	r26, r18
    8c6e:	2f e0       	ldi	r18, 0x0F	; 15
    8c70:	b2 07       	cpc	r27, r18
    8c72:	18 f0       	brcs	.+6      	; 0x8c7a <findFiles+0x38e>
   	 return 0;
    8c74:	80 e0       	ldi	r24, 0x00	; 0
    8c76:	90 e0       	ldi	r25, 0x00	; 0
    8c78:	0b c0       	rjmp	.+22     	; 0x8c90 <findFiles+0x3a4>
   if(cluster == 0) 
    8c7a:	89 81       	ldd	r24, Y+1	; 0x01
    8c7c:	9a 81       	ldd	r25, Y+2	; 0x02
    8c7e:	ab 81       	ldd	r26, Y+3	; 0x03
    8c80:	bc 81       	ldd	r27, Y+4	; 0x04
    8c82:	00 97       	sbiw	r24, 0x00	; 0
    8c84:	a1 05       	cpc	r26, r1
    8c86:	b1 05       	cpc	r27, r1
    8c88:	09 f0       	breq	.+2      	; 0x8c8c <findFiles+0x3a0>
    8c8a:	49 ce       	rjmp	.-878    	; 0x891e <findFiles+0x32>
   {//error in getting cluster
	   return 0;}
    8c8c:	80 e0       	ldi	r24, 0x00	; 0
    8c8e:	90 e0       	ldi	r25, 0x00	; 0
 }
return 0;
}
    8c90:	6c 96       	adiw	r28, 0x1c	; 28
    8c92:	cd bf       	out	0x3d, r28	; 61
    8c94:	de bf       	out	0x3e, r29	; 62
    8c96:	df 91       	pop	r29
    8c98:	cf 91       	pop	r28
    8c9a:	1f 91       	pop	r17
    8c9c:	0f 91       	pop	r16
    8c9e:	08 95       	ret

00008ca0 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    8ca0:	0f 93       	push	r16
    8ca2:	1f 93       	push	r17
    8ca4:	cf 93       	push	r28
    8ca6:	df 93       	push	r29
    8ca8:	cd b7       	in	r28, 0x3d	; 61
    8caa:	de b7       	in	r29, 0x3e	; 62
    8cac:	67 97       	sbiw	r28, 0x17	; 23
    8cae:	cd bf       	out	0x3d, r28	; 61
    8cb0:	de bf       	out	0x3e, r29	; 62
    8cb2:	8d 8b       	std	Y+21, r24	; 0x15
    8cb4:	6e 8b       	std	Y+22, r22	; 0x16
    8cb6:	7f 8b       	std	Y+23, r23	; 0x17
struct dir_Structure *dir;
unsigned long cluster, byteCounter = 0, fileSize, firstSector;
    8cb8:	1e 82       	std	Y+6, r1	; 0x06
    8cba:	1f 82       	std	Y+7, r1	; 0x07
    8cbc:	18 86       	std	Y+8, r1	; 0x08
    8cbe:	19 86       	std	Y+9, r1	; 0x09
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    8cc0:	8e 89       	ldd	r24, Y+22	; 0x16
    8cc2:	9f 89       	ldd	r25, Y+23	; 0x17
    8cc4:	0e 94 ff 46 	call	0x8dfe	; 0x8dfe <convertFileName>
    8cc8:	8a 87       	std	Y+10, r24	; 0x0a
if(error) return 2;
    8cca:	8a 85       	ldd	r24, Y+10	; 0x0a
    8ccc:	88 23       	and	r24, r24
    8cce:	11 f0       	breq	.+4      	; 0x8cd4 <readFile+0x34>
    8cd0:	82 e0       	ldi	r24, 0x02	; 2
    8cd2:	8d c0       	rjmp	.+282    	; 0x8dee <readFile+0x14e>

dir = findFiles (GET_FILE, Filename); //get the file location
    8cd4:	28 eb       	ldi	r18, 0xB8	; 184
    8cd6:	30 e5       	ldi	r19, 0x50	; 80
    8cd8:	81 e0       	ldi	r24, 0x01	; 1
    8cda:	b9 01       	movw	r22, r18
    8cdc:	0e 94 76 44 	call	0x88ec	; 0x88ec <findFiles>
    8ce0:	8b 87       	std	Y+11, r24	; 0x0b
    8ce2:	9c 87       	std	Y+12, r25	; 0x0c
if(dir == 0) 
    8ce4:	8b 85       	ldd	r24, Y+11	; 0x0b
    8ce6:	9c 85       	ldd	r25, Y+12	; 0x0c
    8ce8:	00 97       	sbiw	r24, 0x00	; 0
    8cea:	39 f4       	brne	.+14     	; 0x8cfa <readFile+0x5a>
{
  if(flag == READ) return (1);
    8cec:	8d 89       	ldd	r24, Y+21	; 0x15
    8cee:	88 23       	and	r24, r24
    8cf0:	11 f4       	brne	.+4      	; 0x8cf6 <readFile+0x56>
    8cf2:	81 e0       	ldi	r24, 0x01	; 1
    8cf4:	7c c0       	rjmp	.+248    	; 0x8dee <readFile+0x14e>
  else return (0);
    8cf6:	80 e0       	ldi	r24, 0x00	; 0
    8cf8:	7a c0       	rjmp	.+244    	; 0x8dee <readFile+0x14e>
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    8cfa:	8d 89       	ldd	r24, Y+21	; 0x15
    8cfc:	81 30       	cpi	r24, 0x01	; 1
    8cfe:	11 f4       	brne	.+4      	; 0x8d04 <readFile+0x64>
    8d00:	81 e0       	ldi	r24, 0x01	; 1
    8d02:	75 c0       	rjmp	.+234    	; 0x8dee <readFile+0x14e>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8d04:	8b 85       	ldd	r24, Y+11	; 0x0b
    8d06:	9c 85       	ldd	r25, Y+12	; 0x0c
    8d08:	fc 01       	movw	r30, r24
    8d0a:	84 89       	ldd	r24, Z+20	; 0x14
    8d0c:	95 89       	ldd	r25, Z+21	; 0x15
    8d0e:	cc 01       	movw	r24, r24
    8d10:	a0 e0       	ldi	r26, 0x00	; 0
    8d12:	b0 e0       	ldi	r27, 0x00	; 0
    8d14:	ac 01       	movw	r20, r24
    8d16:	33 27       	eor	r19, r19
    8d18:	22 27       	eor	r18, r18
    8d1a:	8b 85       	ldd	r24, Y+11	; 0x0b
    8d1c:	9c 85       	ldd	r25, Y+12	; 0x0c
    8d1e:	fc 01       	movw	r30, r24
    8d20:	82 8d       	ldd	r24, Z+26	; 0x1a
    8d22:	93 8d       	ldd	r25, Z+27	; 0x1b
    8d24:	cc 01       	movw	r24, r24
    8d26:	a0 e0       	ldi	r26, 0x00	; 0
    8d28:	b0 e0       	ldi	r27, 0x00	; 0
    8d2a:	82 2b       	or	r24, r18
    8d2c:	93 2b       	or	r25, r19
    8d2e:	a4 2b       	or	r26, r20
    8d30:	b5 2b       	or	r27, r21
    8d32:	89 83       	std	Y+1, r24	; 0x01
    8d34:	9a 83       	std	Y+2, r25	; 0x02
    8d36:	ab 83       	std	Y+3, r26	; 0x03
    8d38:	bc 83       	std	Y+4, r27	; 0x04

fileSize = dir->fileSize;
    8d3a:	8b 85       	ldd	r24, Y+11	; 0x0b
    8d3c:	9c 85       	ldd	r25, Y+12	; 0x0c
    8d3e:	fc 01       	movw	r30, r24
    8d40:	84 8d       	ldd	r24, Z+28	; 0x1c
    8d42:	95 8d       	ldd	r25, Z+29	; 0x1d
    8d44:	a6 8d       	ldd	r26, Z+30	; 0x1e
    8d46:	b7 8d       	ldd	r27, Z+31	; 0x1f
    8d48:	8d 87       	std	Y+13, r24	; 0x0d
    8d4a:	9e 87       	std	Y+14, r25	; 0x0e
    8d4c:	af 87       	std	Y+15, r26	; 0x0f
    8d4e:	b8 8b       	std	Y+16, r27	; 0x10
    8d50:	01 c0       	rjmp	.+2      	; 0x8d54 <readFile+0xb4>
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
    8d52:	00 00       	nop
fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    8d54:	89 81       	ldd	r24, Y+1	; 0x01
    8d56:	9a 81       	ldd	r25, Y+2	; 0x02
    8d58:	ab 81       	ldd	r26, Y+3	; 0x03
    8d5a:	bc 81       	ldd	r27, Y+4	; 0x04
    8d5c:	bc 01       	movw	r22, r24
    8d5e:	cd 01       	movw	r24, r26
    8d60:	0e 94 e9 42 	call	0x85d2	; 0x85d2 <getFirstSector>
    8d64:	dc 01       	movw	r26, r24
    8d66:	cb 01       	movw	r24, r22
    8d68:	89 8b       	std	Y+17, r24	; 0x11
    8d6a:	9a 8b       	std	Y+18, r25	; 0x12
    8d6c:	ab 8b       	std	Y+19, r26	; 0x13
    8d6e:	bc 8b       	std	Y+20, r27	; 0x14

  for(j=0; j<sectorPerCluster; j++)
    8d70:	1d 82       	std	Y+5, r1	; 0x05
    8d72:	17 c0       	rjmp	.+46     	; 0x8da2 <readFile+0x102>
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    8d74:	8d 81       	ldd	r24, Y+5	; 0x05
    8d76:	28 2f       	mov	r18, r24
    8d78:	30 e0       	ldi	r19, 0x00	; 0
    8d7a:	40 e0       	ldi	r20, 0x00	; 0
    8d7c:	50 e0       	ldi	r21, 0x00	; 0
    8d7e:	89 89       	ldd	r24, Y+17	; 0x11
    8d80:	9a 89       	ldd	r25, Y+18	; 0x12
    8d82:	ab 89       	ldd	r26, Y+19	; 0x13
    8d84:	bc 89       	ldd	r27, Y+20	; 0x14
    8d86:	82 0f       	add	r24, r18
    8d88:	93 1f       	adc	r25, r19
    8d8a:	a4 1f       	adc	r26, r20
    8d8c:	b5 1f       	adc	r27, r21
    8d8e:	20 ee       	ldi	r18, 0xE0	; 224
    8d90:	33 e2       	ldi	r19, 0x23	; 35
    8d92:	bc 01       	movw	r22, r24
    8d94:	cd 01       	movw	r24, r26
    8d96:	a9 01       	movw	r20, r18
    8d98:	0e 94 15 51 	call	0xa22a	; 0xa22a <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    8d9c:	8d 81       	ldd	r24, Y+5	; 0x05
    8d9e:	8f 5f       	subi	r24, 0xFF	; 255
    8da0:	8d 83       	std	Y+5, r24	; 0x05
    8da2:	8d 81       	ldd	r24, Y+5	; 0x05
    8da4:	28 2f       	mov	r18, r24
    8da6:	30 e0       	ldi	r19, 0x00	; 0
    8da8:	80 91 78 50 	lds	r24, 0x5078
    8dac:	90 91 79 50 	lds	r25, 0x5079
    8db0:	28 17       	cp	r18, r24
    8db2:	39 07       	cpc	r19, r25
    8db4:	f8 f2       	brcs	.-66     	; 0x8d74 <readFile+0xd4>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    8db6:	89 81       	ldd	r24, Y+1	; 0x01
    8db8:	9a 81       	ldd	r25, Y+2	; 0x02
    8dba:	ab 81       	ldd	r26, Y+3	; 0x03
    8dbc:	bc 81       	ldd	r27, Y+4	; 0x04
    8dbe:	bc 01       	movw	r22, r24
    8dc0:	cd 01       	movw	r24, r26
    8dc2:	40 e0       	ldi	r20, 0x00	; 0
    8dc4:	00 e0       	ldi	r16, 0x00	; 0
    8dc6:	10 e0       	ldi	r17, 0x00	; 0
    8dc8:	98 01       	movw	r18, r16
    8dca:	0e 94 1b 43 	call	0x8636	; 0x8636 <getSetNextCluster>
    8dce:	dc 01       	movw	r26, r24
    8dd0:	cb 01       	movw	r24, r22
    8dd2:	89 83       	std	Y+1, r24	; 0x01
    8dd4:	9a 83       	std	Y+2, r25	; 0x02
    8dd6:	ab 83       	std	Y+3, r26	; 0x03
    8dd8:	bc 83       	std	Y+4, r27	; 0x04
  if(cluster == 0) {//Error in getting cluster
    8dda:	89 81       	ldd	r24, Y+1	; 0x01
    8ddc:	9a 81       	ldd	r25, Y+2	; 0x02
    8dde:	ab 81       	ldd	r26, Y+3	; 0x03
    8de0:	bc 81       	ldd	r27, Y+4	; 0x04
    8de2:	00 97       	sbiw	r24, 0x00	; 0
    8de4:	a1 05       	cpc	r26, r1
    8de6:	b1 05       	cpc	r27, r1
    8de8:	09 f0       	breq	.+2      	; 0x8dec <readFile+0x14c>
    8dea:	b3 cf       	rjmp	.-154    	; 0x8d52 <readFile+0xb2>
	  return 0;}
    8dec:	80 e0       	ldi	r24, 0x00	; 0
}
return 0;
}
    8dee:	67 96       	adiw	r28, 0x17	; 23
    8df0:	cd bf       	out	0x3d, r28	; 61
    8df2:	de bf       	out	0x3e, r29	; 62
    8df4:	df 91       	pop	r29
    8df6:	cf 91       	pop	r28
    8df8:	1f 91       	pop	r17
    8dfa:	0f 91       	pop	r16
    8dfc:	08 95       	ret

00008dfe <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    8dfe:	cf 93       	push	r28
    8e00:	df 93       	push	r29
    8e02:	cd b7       	in	r28, 0x3d	; 61
    8e04:	de b7       	in	r29, 0x3e	; 62
    8e06:	62 97       	sbiw	r28, 0x12	; 18
    8e08:	cd bf       	out	0x3d, r28	; 61
    8e0a:	de bf       	out	0x3e, r29	; 62
    8e0c:	89 8b       	std	Y+17, r24	; 0x11
    8e0e:	9a 8b       	std	Y+18, r25	; 0x12
bool NoExtension = FALSE;
    8e10:	19 82       	std	Y+1, r1	; 0x01
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
    8e12:	89 89       	ldd	r24, Y+17	; 0x11
    8e14:	9a 89       	ldd	r25, Y+18	; 0x12
    8e16:	9c 01       	movw	r18, r24
    8e18:	f9 01       	movw	r30, r18
    8e1a:	01 90       	ld	r0, Z+
    8e1c:	00 20       	and	r0, r0
    8e1e:	e9 f7       	brne	.-6      	; 0x8e1a <convertFileName+0x1c>
    8e20:	cf 01       	movw	r24, r30
    8e22:	01 97       	sbiw	r24, 0x01	; 1
    8e24:	82 1b       	sub	r24, r18
    8e26:	93 0b       	sbc	r25, r19
    8e28:	80 31       	cpi	r24, 0x10	; 16
    8e2a:	91 05       	cpc	r25, r1
    8e2c:	10 f0       	brcs	.+4      	; 0x8e32 <convertFileName+0x34>
    8e2e:	81 e0       	ldi	r24, 0x01	; 1
    8e30:	16 c1       	rjmp	.+556    	; 0x905e <convertFileName+0x260>
int i=0;
    8e32:	1c 82       	std	Y+4, r1	; 0x04
    8e34:	1d 82       	std	Y+5, r1	; 0x05
for(; i < strlen(fileName); i++){
    8e36:	13 c0       	rjmp	.+38     	; 0x8e5e <convertFileName+0x60>
	Filename[i] = fileName[i];
    8e38:	8c 81       	ldd	r24, Y+4	; 0x04
    8e3a:	9d 81       	ldd	r25, Y+5	; 0x05
    8e3c:	29 89       	ldd	r18, Y+17	; 0x11
    8e3e:	3a 89       	ldd	r19, Y+18	; 0x12
    8e40:	82 0f       	add	r24, r18
    8e42:	93 1f       	adc	r25, r19
    8e44:	fc 01       	movw	r30, r24
    8e46:	20 81       	ld	r18, Z
    8e48:	8c 81       	ldd	r24, Y+4	; 0x04
    8e4a:	9d 81       	ldd	r25, Y+5	; 0x05
    8e4c:	88 54       	subi	r24, 0x48	; 72
    8e4e:	9f 4a       	sbci	r25, 0xAF	; 175
    8e50:	fc 01       	movw	r30, r24
    8e52:	20 83       	st	Z, r18

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
int i=0;
for(; i < strlen(fileName); i++){
    8e54:	8c 81       	ldd	r24, Y+4	; 0x04
    8e56:	9d 81       	ldd	r25, Y+5	; 0x05
    8e58:	01 96       	adiw	r24, 0x01	; 1
    8e5a:	8c 83       	std	Y+4, r24	; 0x04
    8e5c:	9d 83       	std	Y+5, r25	; 0x05
    8e5e:	4c 81       	ldd	r20, Y+4	; 0x04
    8e60:	5d 81       	ldd	r21, Y+5	; 0x05
    8e62:	89 89       	ldd	r24, Y+17	; 0x11
    8e64:	9a 89       	ldd	r25, Y+18	; 0x12
    8e66:	9c 01       	movw	r18, r24
    8e68:	f9 01       	movw	r30, r18
    8e6a:	01 90       	ld	r0, Z+
    8e6c:	00 20       	and	r0, r0
    8e6e:	e9 f7       	brne	.-6      	; 0x8e6a <convertFileName+0x6c>
    8e70:	cf 01       	movw	r24, r30
    8e72:	01 97       	sbiw	r24, 0x01	; 1
    8e74:	82 1b       	sub	r24, r18
    8e76:	93 0b       	sbc	r25, r19
    8e78:	48 17       	cp	r20, r24
    8e7a:	59 07       	cpc	r21, r25
    8e7c:	e8 f2       	brcs	.-70     	; 0x8e38 <convertFileName+0x3a>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    8e7e:	0c c0       	rjmp	.+24     	; 0x8e98 <convertFileName+0x9a>
    8e80:	8c 81       	ldd	r24, Y+4	; 0x04
    8e82:	9d 81       	ldd	r25, Y+5	; 0x05
    8e84:	88 54       	subi	r24, 0x48	; 72
    8e86:	9f 4a       	sbci	r25, 0xAF	; 175
    8e88:	20 e2       	ldi	r18, 0x20	; 32
    8e8a:	fc 01       	movw	r30, r24
    8e8c:	20 83       	st	Z, r18
    8e8e:	8c 81       	ldd	r24, Y+4	; 0x04
    8e90:	9d 81       	ldd	r25, Y+5	; 0x05
    8e92:	01 96       	adiw	r24, 0x01	; 1
    8e94:	8c 83       	std	Y+4, r24	; 0x04
    8e96:	9d 83       	std	Y+5, r25	; 0x05
    8e98:	8c 81       	ldd	r24, Y+4	; 0x04
    8e9a:	9d 81       	ldd	r25, Y+5	; 0x05
    8e9c:	8f 30       	cpi	r24, 0x0F	; 15
    8e9e:	91 05       	cpc	r25, r1
    8ea0:	7c f3       	brlt	.-34     	; 0x8e80 <convertFileName+0x82>


for(j=0; j<12; j++)
    8ea2:	1a 82       	std	Y+2, r1	; 0x02
    8ea4:	0c c0       	rjmp	.+24     	; 0x8ebe <convertFileName+0xc0>
if(Filename[j] == '.') break;
    8ea6:	8a 81       	ldd	r24, Y+2	; 0x02
    8ea8:	88 2f       	mov	r24, r24
    8eaa:	90 e0       	ldi	r25, 0x00	; 0
    8eac:	88 54       	subi	r24, 0x48	; 72
    8eae:	9f 4a       	sbci	r25, 0xAF	; 175
    8eb0:	fc 01       	movw	r30, r24
    8eb2:	80 81       	ld	r24, Z
    8eb4:	8e 32       	cpi	r24, 0x2E	; 46
    8eb6:	39 f0       	breq	.+14     	; 0x8ec6 <convertFileName+0xc8>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    8eb8:	8a 81       	ldd	r24, Y+2	; 0x02
    8eba:	8f 5f       	subi	r24, 0xFF	; 255
    8ebc:	8a 83       	std	Y+2, r24	; 0x02
    8ebe:	8a 81       	ldd	r24, Y+2	; 0x02
    8ec0:	8c 30       	cpi	r24, 0x0C	; 12
    8ec2:	88 f3       	brcs	.-30     	; 0x8ea6 <convertFileName+0xa8>
    8ec4:	01 c0       	rjmp	.+2      	; 0x8ec8 <convertFileName+0xca>
if(Filename[j] == '.') break;
    8ec6:	00 00       	nop

if(j>8 && j<12) {//Invalid fileName
    8ec8:	8a 81       	ldd	r24, Y+2	; 0x02
    8eca:	89 30       	cpi	r24, 0x09	; 9
    8ecc:	28 f0       	brcs	.+10     	; 0x8ed8 <convertFileName+0xda>
    8ece:	8a 81       	ldd	r24, Y+2	; 0x02
    8ed0:	8c 30       	cpi	r24, 0x0C	; 12
    8ed2:	10 f4       	brcc	.+4      	; 0x8ed8 <convertFileName+0xda>
	return 1;}
    8ed4:	81 e0       	ldi	r24, 0x01	; 1
    8ed6:	c3 c0       	rjmp	.+390    	; 0x905e <convertFileName+0x260>
else if (j==12) NoExtension=TRUE;	
    8ed8:	8a 81       	ldd	r24, Y+2	; 0x02
    8eda:	8c 30       	cpi	r24, 0x0C	; 12
    8edc:	11 f4       	brne	.+4      	; 0x8ee2 <convertFileName+0xe4>
    8ede:	81 e0       	ldi	r24, 0x01	; 1
    8ee0:	89 83       	std	Y+1, r24	; 0x01

for(k=0; k<j; k++) //setting file name
    8ee2:	1b 82       	std	Y+3, r1	; 0x03
    8ee4:	14 c0       	rjmp	.+40     	; 0x8f0e <convertFileName+0x110>
  fileNameFAT[k] = Filename[k];
    8ee6:	8b 81       	ldd	r24, Y+3	; 0x03
    8ee8:	88 2f       	mov	r24, r24
    8eea:	90 e0       	ldi	r25, 0x00	; 0
    8eec:	2b 81       	ldd	r18, Y+3	; 0x03
    8eee:	22 2f       	mov	r18, r18
    8ef0:	30 e0       	ldi	r19, 0x00	; 0
    8ef2:	28 54       	subi	r18, 0x48	; 72
    8ef4:	3f 4a       	sbci	r19, 0xAF	; 175
    8ef6:	f9 01       	movw	r30, r18
    8ef8:	40 81       	ld	r20, Z
    8efa:	9e 01       	movw	r18, r28
    8efc:	2a 5f       	subi	r18, 0xFA	; 250
    8efe:	3f 4f       	sbci	r19, 0xFF	; 255
    8f00:	82 0f       	add	r24, r18
    8f02:	93 1f       	adc	r25, r19
    8f04:	fc 01       	movw	r30, r24
    8f06:	40 83       	st	Z, r20

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    8f08:	8b 81       	ldd	r24, Y+3	; 0x03
    8f0a:	8f 5f       	subi	r24, 0xFF	; 255
    8f0c:	8b 83       	std	Y+3, r24	; 0x03
    8f0e:	9b 81       	ldd	r25, Y+3	; 0x03
    8f10:	8a 81       	ldd	r24, Y+2	; 0x02
    8f12:	98 17       	cp	r25, r24
    8f14:	40 f3       	brcs	.-48     	; 0x8ee6 <convertFileName+0xe8>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8f16:	8a 81       	ldd	r24, Y+2	; 0x02
    8f18:	8b 83       	std	Y+3, r24	; 0x03
    8f1a:	0e c0       	rjmp	.+28     	; 0x8f38 <convertFileName+0x13a>
  fileNameFAT[k] = ' ';
    8f1c:	8b 81       	ldd	r24, Y+3	; 0x03
    8f1e:	88 2f       	mov	r24, r24
    8f20:	90 e0       	ldi	r25, 0x00	; 0
    8f22:	9e 01       	movw	r18, r28
    8f24:	2a 5f       	subi	r18, 0xFA	; 250
    8f26:	3f 4f       	sbci	r19, 0xFF	; 255
    8f28:	82 0f       	add	r24, r18
    8f2a:	93 1f       	adc	r25, r19
    8f2c:	20 e2       	ldi	r18, 0x20	; 32
    8f2e:	fc 01       	movw	r30, r24
    8f30:	20 83       	st	Z, r18
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8f32:	8b 81       	ldd	r24, Y+3	; 0x03
    8f34:	8f 5f       	subi	r24, 0xFF	; 255
    8f36:	8b 83       	std	Y+3, r24	; 0x03
    8f38:	8b 81       	ldd	r24, Y+3	; 0x03
    8f3a:	88 30       	cpi	r24, 0x08	; 8
    8f3c:	78 f3       	brcs	.-34     	; 0x8f1c <convertFileName+0x11e>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    8f3e:	99 81       	ldd	r25, Y+1	; 0x01
    8f40:	81 e0       	ldi	r24, 0x01	; 1
    8f42:	89 27       	eor	r24, r25
    8f44:	88 23       	and	r24, r24
    8f46:	19 f0       	breq	.+6      	; 0x8f4e <convertFileName+0x150>
    8f48:	8a 81       	ldd	r24, Y+2	; 0x02
    8f4a:	8f 5f       	subi	r24, 0xFF	; 255
    8f4c:	8a 83       	std	Y+2, r24	; 0x02
for(k=8; k<11; k++) //setting file extension
    8f4e:	88 e0       	ldi	r24, 0x08	; 8
    8f50:	8b 83       	std	Y+3, r24	; 0x03
    8f52:	32 c0       	rjmp	.+100    	; 0x8fb8 <convertFileName+0x1ba>
{
  if(Filename[j] != 0)
    8f54:	8a 81       	ldd	r24, Y+2	; 0x02
    8f56:	88 2f       	mov	r24, r24
    8f58:	90 e0       	ldi	r25, 0x00	; 0
    8f5a:	88 54       	subi	r24, 0x48	; 72
    8f5c:	9f 4a       	sbci	r25, 0xAF	; 175
    8f5e:	fc 01       	movw	r30, r24
    8f60:	80 81       	ld	r24, Z
    8f62:	88 23       	and	r24, r24
    8f64:	19 f1       	breq	.+70     	; 0x8fac <convertFileName+0x1ae>
    fileNameFAT[k] = Filename[j++];
    8f66:	8b 81       	ldd	r24, Y+3	; 0x03
    8f68:	88 2f       	mov	r24, r24
    8f6a:	90 e0       	ldi	r25, 0x00	; 0
    8f6c:	2a 81       	ldd	r18, Y+2	; 0x02
    8f6e:	22 2f       	mov	r18, r18
    8f70:	30 e0       	ldi	r19, 0x00	; 0
    8f72:	28 54       	subi	r18, 0x48	; 72
    8f74:	3f 4a       	sbci	r19, 0xAF	; 175
    8f76:	f9 01       	movw	r30, r18
    8f78:	40 81       	ld	r20, Z
    8f7a:	9e 01       	movw	r18, r28
    8f7c:	2a 5f       	subi	r18, 0xFA	; 250
    8f7e:	3f 4f       	sbci	r19, 0xFF	; 255
    8f80:	82 0f       	add	r24, r18
    8f82:	93 1f       	adc	r25, r19
    8f84:	fc 01       	movw	r30, r24
    8f86:	40 83       	st	Z, r20
    8f88:	8a 81       	ldd	r24, Y+2	; 0x02
    8f8a:	8f 5f       	subi	r24, 0xFF	; 255
    8f8c:	8a 83       	std	Y+2, r24	; 0x02
    8f8e:	11 c0       	rjmp	.+34     	; 0x8fb2 <convertFileName+0x1b4>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    8f90:	8b 81       	ldd	r24, Y+3	; 0x03
    8f92:	88 2f       	mov	r24, r24
    8f94:	90 e0       	ldi	r25, 0x00	; 0
    8f96:	9e 01       	movw	r18, r28
    8f98:	2a 5f       	subi	r18, 0xFA	; 250
    8f9a:	3f 4f       	sbci	r19, 0xFF	; 255
    8f9c:	82 0f       	add	r24, r18
    8f9e:	93 1f       	adc	r25, r19
    8fa0:	20 e2       	ldi	r18, 0x20	; 32
    8fa2:	fc 01       	movw	r30, r24
    8fa4:	20 83       	st	Z, r18
    8fa6:	8b 81       	ldd	r24, Y+3	; 0x03
    8fa8:	8f 5f       	subi	r24, 0xFF	; 255
    8faa:	8b 83       	std	Y+3, r24	; 0x03
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    8fac:	8b 81       	ldd	r24, Y+3	; 0x03
    8fae:	8b 30       	cpi	r24, 0x0B	; 11
    8fb0:	78 f3       	brcs	.-34     	; 0x8f90 <convertFileName+0x192>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    8fb2:	8b 81       	ldd	r24, Y+3	; 0x03
    8fb4:	8f 5f       	subi	r24, 0xFF	; 255
    8fb6:	8b 83       	std	Y+3, r24	; 0x03
    8fb8:	8b 81       	ldd	r24, Y+3	; 0x03
    8fba:	8b 30       	cpi	r24, 0x0B	; 11
    8fbc:	58 f2       	brcs	.-106    	; 0x8f54 <convertFileName+0x156>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8fbe:	1a 82       	std	Y+2, r1	; 0x02
    8fc0:	31 c0       	rjmp	.+98     	; 0x9024 <convertFileName+0x226>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    8fc2:	8a 81       	ldd	r24, Y+2	; 0x02
    8fc4:	88 2f       	mov	r24, r24
    8fc6:	90 e0       	ldi	r25, 0x00	; 0
    8fc8:	9e 01       	movw	r18, r28
    8fca:	2a 5f       	subi	r18, 0xFA	; 250
    8fcc:	3f 4f       	sbci	r19, 0xFF	; 255
    8fce:	82 0f       	add	r24, r18
    8fd0:	93 1f       	adc	r25, r19
    8fd2:	fc 01       	movw	r30, r24
    8fd4:	80 81       	ld	r24, Z
    8fd6:	81 36       	cpi	r24, 0x61	; 97
    8fd8:	10 f1       	brcs	.+68     	; 0x901e <convertFileName+0x220>
    8fda:	8a 81       	ldd	r24, Y+2	; 0x02
    8fdc:	88 2f       	mov	r24, r24
    8fde:	90 e0       	ldi	r25, 0x00	; 0
    8fe0:	9e 01       	movw	r18, r28
    8fe2:	2a 5f       	subi	r18, 0xFA	; 250
    8fe4:	3f 4f       	sbci	r19, 0xFF	; 255
    8fe6:	82 0f       	add	r24, r18
    8fe8:	93 1f       	adc	r25, r19
    8fea:	fc 01       	movw	r30, r24
    8fec:	80 81       	ld	r24, Z
    8fee:	8b 37       	cpi	r24, 0x7B	; 123
    8ff0:	b0 f4       	brcc	.+44     	; 0x901e <convertFileName+0x220>
    fileNameFAT[j] -= 0x20;
    8ff2:	8a 81       	ldd	r24, Y+2	; 0x02
    8ff4:	88 2f       	mov	r24, r24
    8ff6:	90 e0       	ldi	r25, 0x00	; 0
    8ff8:	2a 81       	ldd	r18, Y+2	; 0x02
    8ffa:	22 2f       	mov	r18, r18
    8ffc:	30 e0       	ldi	r19, 0x00	; 0
    8ffe:	ae 01       	movw	r20, r28
    9000:	4a 5f       	subi	r20, 0xFA	; 250
    9002:	5f 4f       	sbci	r21, 0xFF	; 255
    9004:	24 0f       	add	r18, r20
    9006:	35 1f       	adc	r19, r21
    9008:	f9 01       	movw	r30, r18
    900a:	20 81       	ld	r18, Z
    900c:	42 2f       	mov	r20, r18
    900e:	40 52       	subi	r20, 0x20	; 32
    9010:	9e 01       	movw	r18, r28
    9012:	2a 5f       	subi	r18, 0xFA	; 250
    9014:	3f 4f       	sbci	r19, 0xFF	; 255
    9016:	82 0f       	add	r24, r18
    9018:	93 1f       	adc	r25, r19
    901a:	fc 01       	movw	r30, r24
    901c:	40 83       	st	Z, r20
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    901e:	8a 81       	ldd	r24, Y+2	; 0x02
    9020:	8f 5f       	subi	r24, 0xFF	; 255
    9022:	8a 83       	std	Y+2, r24	; 0x02
    9024:	8a 81       	ldd	r24, Y+2	; 0x02
    9026:	8b 30       	cpi	r24, 0x0B	; 11
    9028:	60 f2       	brcs	.-104    	; 0x8fc2 <convertFileName+0x1c4>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    902a:	1a 82       	std	Y+2, r1	; 0x02
    902c:	14 c0       	rjmp	.+40     	; 0x9056 <convertFileName+0x258>
  Filename[j] = fileNameFAT[j];
    902e:	8a 81       	ldd	r24, Y+2	; 0x02
    9030:	88 2f       	mov	r24, r24
    9032:	90 e0       	ldi	r25, 0x00	; 0
    9034:	2a 81       	ldd	r18, Y+2	; 0x02
    9036:	22 2f       	mov	r18, r18
    9038:	30 e0       	ldi	r19, 0x00	; 0
    903a:	ae 01       	movw	r20, r28
    903c:	4a 5f       	subi	r20, 0xFA	; 250
    903e:	5f 4f       	sbci	r21, 0xFF	; 255
    9040:	24 0f       	add	r18, r20
    9042:	35 1f       	adc	r19, r21
    9044:	f9 01       	movw	r30, r18
    9046:	20 81       	ld	r18, Z
    9048:	88 54       	subi	r24, 0x48	; 72
    904a:	9f 4a       	sbci	r25, 0xAF	; 175
    904c:	fc 01       	movw	r30, r24
    904e:	20 83       	st	Z, r18

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    9050:	8a 81       	ldd	r24, Y+2	; 0x02
    9052:	8f 5f       	subi	r24, 0xFF	; 255
    9054:	8a 83       	std	Y+2, r24	; 0x02
    9056:	8a 81       	ldd	r24, Y+2	; 0x02
    9058:	8b 30       	cpi	r24, 0x0B	; 11
    905a:	48 f3       	brcs	.-46     	; 0x902e <convertFileName+0x230>
  Filename[j] = fileNameFAT[j];

return 0;
    905c:	80 e0       	ldi	r24, 0x00	; 0
}
    905e:	62 96       	adiw	r28, 0x12	; 18
    9060:	cd bf       	out	0x3d, r28	; 61
    9062:	de bf       	out	0x3e, r29	; 62
    9064:	df 91       	pop	r29
    9066:	cf 91       	pop	r28
    9068:	08 95       	ret

0000906a <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    906a:	ef 92       	push	r14
    906c:	ff 92       	push	r15
    906e:	0f 93       	push	r16
    9070:	1f 93       	push	r17
    9072:	cf 93       	push	r28
    9074:	df 93       	push	r29
    9076:	cd b7       	in	r28, 0x3d	; 61
    9078:	de b7       	in	r29, 0x3e	; 62
    907a:	e7 97       	sbiw	r28, 0x37	; 55
    907c:	cd bf       	out	0x3d, r28	; 61
    907e:	de bf       	out	0x3e, r29	; 62
    9080:	88 ab       	sts	0x58, r24
    9082:	99 ab       	sts	0x59, r25
    9084:	6a ab       	sts	0x5a, r22
    9086:	7b ab       	sts	0x5b, r23
    9088:	2c ab       	sts	0x5c, r18
    908a:	3d ab       	sts	0x5d, r19
    908c:	4e ab       	sts	0x5e, r20
    908e:	5f ab       	sts	0x5f, r21
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    9090:	1a 82       	std	Y+2, r1	; 0x02
    9092:	1b 82       	std	Y+3, r1	; 0x03
    9094:	1c 82       	std	Y+4, r1	; 0x04
    9096:	1d 82       	std	Y+5, r1	; 0x05
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    9098:	1e 82       	std	Y+6, r1	; 0x06
    909a:	1f 82       	std	Y+7, r1	; 0x07
    909c:	18 86       	std	Y+8, r1	; 0x08
    909e:	19 86       	std	Y+9, r1	; 0x09
    90a0:	1a 86       	std	Y+10, r1	; 0x0a
    90a2:	1b 86       	std	Y+11, r1	; 0x0b
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    90a4:	28 a9       	sts	0x48, r18
    90a6:	39 a9       	sts	0x49, r19
    90a8:	81 e0       	ldi	r24, 0x01	; 1
    90aa:	b9 01       	movw	r22, r18
    90ac:	0e 94 50 46 	call	0x8ca0	; 0x8ca0 <readFile>
    90b0:	89 83       	std	Y+1, r24	; 0x01

if(j == 1) 
    90b2:	89 81       	ldd	r24, Y+1	; 0x01
    90b4:	81 30       	cpi	r24, 0x01	; 1
    90b6:	09 f0       	breq	.+2      	; 0x90ba <writeFile+0x50>
    90b8:	84 c0       	rjmp	.+264    	; 0x91c2 <writeFile+0x158>
{
  //File already exists, appending data
  appendFile = 1;
    90ba:	81 e0       	ldi	r24, 0x01	; 1
    90bc:	8c 83       	std	Y+4, r24	; 0x04
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    90be:	80 91 84 50 	lds	r24, 0x5084
    90c2:	90 91 85 50 	lds	r25, 0x5085
    90c6:	a0 91 86 50 	lds	r26, 0x5086
    90ca:	b0 91 87 50 	lds	r27, 0x5087
    90ce:	8c 87       	std	Y+12, r24	; 0x0c
    90d0:	9d 87       	std	Y+13, r25	; 0x0d
    90d2:	ae 87       	std	Y+14, r26	; 0x0e
    90d4:	bf 87       	std	Y+15, r27	; 0x0f
  clusterCount=0;
    90d6:	1c 8a       	std	Y+20, r1	; 0x14
    90d8:	1d 8a       	std	Y+21, r1	; 0x15
    90da:	1e 8a       	std	Y+22, r1	; 0x16
    90dc:	1f 8a       	std	Y+23, r1	; 0x17
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    90de:	8c 85       	ldd	r24, Y+12	; 0x0c
    90e0:	9d 85       	ldd	r25, Y+13	; 0x0d
    90e2:	ae 85       	ldd	r26, Y+14	; 0x0e
    90e4:	bf 85       	ldd	r27, Y+15	; 0x0f
    90e6:	bc 01       	movw	r22, r24
    90e8:	cd 01       	movw	r24, r26
    90ea:	40 e0       	ldi	r20, 0x00	; 0
    90ec:	00 e0       	ldi	r16, 0x00	; 0
    90ee:	10 e0       	ldi	r17, 0x00	; 0
    90f0:	98 01       	movw	r18, r16
    90f2:	0e 94 1b 43 	call	0x8636	; 0x8636 <getSetNextCluster>
    90f6:	dc 01       	movw	r26, r24
    90f8:	cb 01       	movw	r24, r22
    90fa:	8a a3       	lds	r24, 0x5a
    90fc:	9b a3       	lds	r25, 0x5b
    90fe:	ac a3       	lds	r26, 0x5c
    9100:	bd a3       	lds	r27, 0x5d
    if(nextCluster == EOF) break;
    9102:	8a a1       	lds	r24, 0x4a
    9104:	9b a1       	lds	r25, 0x4b
    9106:	ac a1       	lds	r26, 0x4c
    9108:	bd a1       	lds	r27, 0x4d
    910a:	8f 3f       	cpi	r24, 0xFF	; 255
    910c:	0f ef       	ldi	r16, 0xFF	; 255
    910e:	90 07       	cpc	r25, r16
    9110:	0f ef       	ldi	r16, 0xFF	; 255
    9112:	a0 07       	cpc	r26, r16
    9114:	0f e0       	ldi	r16, 0x0F	; 15
    9116:	b0 07       	cpc	r27, r16
    9118:	a1 f0       	breq	.+40     	; 0x9142 <writeFile+0xd8>
	cluster = nextCluster;
    911a:	8a a1       	lds	r24, 0x4a
    911c:	9b a1       	lds	r25, 0x4b
    911e:	ac a1       	lds	r26, 0x4c
    9120:	bd a1       	lds	r27, 0x4d
    9122:	8c 87       	std	Y+12, r24	; 0x0c
    9124:	9d 87       	std	Y+13, r25	; 0x0d
    9126:	ae 87       	std	Y+14, r26	; 0x0e
    9128:	bf 87       	std	Y+15, r27	; 0x0f
	clusterCount++;
    912a:	8c 89       	ldd	r24, Y+20	; 0x14
    912c:	9d 89       	ldd	r25, Y+21	; 0x15
    912e:	ae 89       	ldd	r26, Y+22	; 0x16
    9130:	bf 89       	ldd	r27, Y+23	; 0x17
    9132:	01 96       	adiw	r24, 0x01	; 1
    9134:	a1 1d       	adc	r26, r1
    9136:	b1 1d       	adc	r27, r1
    9138:	8c 8b       	std	Y+20, r24	; 0x14
    913a:	9d 8b       	std	Y+21, r25	; 0x15
    913c:	ae 8b       	std	Y+22, r26	; 0x16
    913e:	bf 8b       	std	Y+23, r27	; 0x17
  }
    9140:	ce cf       	rjmp	.-100    	; 0x90de <writeFile+0x74>
  clusterCount=0;
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
    9142:	00 00       	nop
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    9144:	e0 90 51 40 	lds	r14, 0x4051
    9148:	f0 90 52 40 	lds	r15, 0x4052
    914c:	00 91 53 40 	lds	r16, 0x4053
    9150:	10 91 54 40 	lds	r17, 0x4054
    9154:	80 91 78 50 	lds	r24, 0x5078
    9158:	90 91 79 50 	lds	r25, 0x5079
    915c:	cc 01       	movw	r24, r24
    915e:	a0 e0       	ldi	r26, 0x00	; 0
    9160:	b0 e0       	ldi	r27, 0x00	; 0
    9162:	2c 89       	ldd	r18, Y+20	; 0x14
    9164:	3d 89       	ldd	r19, Y+21	; 0x15
    9166:	4e 89       	ldd	r20, Y+22	; 0x16
    9168:	5f 89       	ldd	r21, Y+23	; 0x17
    916a:	bc 01       	movw	r22, r24
    916c:	cd 01       	movw	r24, r26
    916e:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    9172:	dc 01       	movw	r26, r24
    9174:	cb 01       	movw	r24, r22
    9176:	20 91 55 40 	lds	r18, 0x4055
    917a:	30 91 56 40 	lds	r19, 0x4056
    917e:	99 01       	movw	r18, r18
    9180:	40 e0       	ldi	r20, 0x00	; 0
    9182:	50 e0       	ldi	r21, 0x00	; 0
    9184:	bc 01       	movw	r22, r24
    9186:	cd 01       	movw	r24, r26
    9188:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    918c:	dc 01       	movw	r26, r24
    918e:	cb 01       	movw	r24, r22
    9190:	a8 01       	movw	r20, r16
    9192:	97 01       	movw	r18, r14
    9194:	28 1b       	sub	r18, r24
    9196:	39 0b       	sbc	r19, r25
    9198:	4a 0b       	sbc	r20, r26
    919a:	5b 0b       	sbc	r21, r27
    919c:	da 01       	movw	r26, r20
    919e:	c9 01       	movw	r24, r18
    91a0:	20 91 55 40 	lds	r18, 0x4055
    91a4:	30 91 56 40 	lds	r19, 0x4056
    91a8:	99 01       	movw	r18, r18
    91aa:	40 e0       	ldi	r20, 0x00	; 0
    91ac:	50 e0       	ldi	r21, 0x00	; 0
    91ae:	bc 01       	movw	r22, r24
    91b0:	cd 01       	movw	r24, r26
    91b2:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    91b6:	da 01       	movw	r26, r20
    91b8:	c9 01       	movw	r24, r18
    91ba:	8d 83       	std	Y+5, r24	; 0x05
  start = 1;
    91bc:	81 e0       	ldi	r24, 0x01	; 1
    91be:	8b 83       	std	Y+3, r24	; 0x03
    91c0:	69 c0       	rjmp	.+210    	; 0x9294 <writeFile+0x22a>
}
else if(j == 2) 
    91c2:	89 81       	ldd	r24, Y+1	; 0x01
    91c4:	82 30       	cpi	r24, 0x02	; 2
    91c6:	11 f4       	brne	.+4      	; 0x91cc <writeFile+0x162>
   return 1; //invalid file name
    91c8:	81 e0       	ldi	r24, 0x01	; 1
    91ca:	1b c3       	rjmp	.+1590   	; 0x9802 <writeFile+0x798>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    91cc:	82 e0       	ldi	r24, 0x02	; 2
    91ce:	60 e0       	ldi	r22, 0x00	; 0
    91d0:	20 e0       	ldi	r18, 0x00	; 0
    91d2:	30 e0       	ldi	r19, 0x00	; 0
    91d4:	a9 01       	movw	r20, r18
    91d6:	0e 94 c5 43 	call	0x878a	; 0x878a <getSetFreeCluster>
    91da:	dc 01       	movw	r26, r24
    91dc:	cb 01       	movw	r24, r22
    91de:	8c 87       	std	Y+12, r24	; 0x0c
    91e0:	9d 87       	std	Y+13, r25	; 0x0d
    91e2:	ae 87       	std	Y+14, r26	; 0x0e
    91e4:	bf 87       	std	Y+15, r27	; 0x0f
  if(cluster > totalClusters)
    91e6:	80 91 5a 40 	lds	r24, 0x405A
    91ea:	90 91 5b 40 	lds	r25, 0x405B
    91ee:	a0 91 5c 40 	lds	r26, 0x405C
    91f2:	b0 91 5d 40 	lds	r27, 0x405D
    91f6:	2c 85       	ldd	r18, Y+12	; 0x0c
    91f8:	3d 85       	ldd	r19, Y+13	; 0x0d
    91fa:	4e 85       	ldd	r20, Y+14	; 0x0e
    91fc:	5f 85       	ldd	r21, Y+15	; 0x0f
    91fe:	82 17       	cp	r24, r18
    9200:	93 07       	cpc	r25, r19
    9202:	a4 07       	cpc	r26, r20
    9204:	b5 07       	cpc	r27, r21
    9206:	60 f4       	brcc	.+24     	; 0x9220 <writeFile+0x1b6>
     cluster = rootCluster;
    9208:	80 91 60 40 	lds	r24, 0x4060
    920c:	90 91 61 40 	lds	r25, 0x4061
    9210:	a0 91 62 40 	lds	r26, 0x4062
    9214:	b0 91 63 40 	lds	r27, 0x4063
    9218:	8c 87       	std	Y+12, r24	; 0x0c
    921a:	9d 87       	std	Y+13, r25	; 0x0d
    921c:	ae 87       	std	Y+14, r26	; 0x0e
    921e:	bf 87       	std	Y+15, r27	; 0x0f

  cluster = searchNextFreeCluster(cluster);
    9220:	8c 85       	ldd	r24, Y+12	; 0x0c
    9222:	9d 85       	ldd	r25, Y+13	; 0x0d
    9224:	ae 85       	ldd	r26, Y+14	; 0x0e
    9226:	bf 85       	ldd	r27, Y+15	; 0x0f
    9228:	bc 01       	movw	r22, r24
    922a:	cd 01       	movw	r24, r26
    922c:	0e 94 0b 4c 	call	0x9816	; 0x9816 <searchNextFreeCluster>
    9230:	dc 01       	movw	r26, r24
    9232:	cb 01       	movw	r24, r22
    9234:	8c 87       	std	Y+12, r24	; 0x0c
    9236:	9d 87       	std	Y+13, r25	; 0x0d
    9238:	ae 87       	std	Y+14, r26	; 0x0e
    923a:	bf 87       	std	Y+15, r27	; 0x0f
   if(cluster == 0)
    923c:	8c 85       	ldd	r24, Y+12	; 0x0c
    923e:	9d 85       	ldd	r25, Y+13	; 0x0d
    9240:	ae 85       	ldd	r26, Y+14	; 0x0e
    9242:	bf 85       	ldd	r27, Y+15	; 0x0f
    9244:	00 97       	sbiw	r24, 0x00	; 0
    9246:	a1 05       	cpc	r26, r1
    9248:	b1 05       	cpc	r27, r1
    924a:	11 f4       	brne	.+4      	; 0x9250 <writeFile+0x1e6>
   {
	   // No free cluster!
	  return 2;
    924c:	82 e0       	ldi	r24, 0x02	; 2
    924e:	d9 c2       	rjmp	.+1458   	; 0x9802 <writeFile+0x798>
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    9250:	8c 85       	ldd	r24, Y+12	; 0x0c
    9252:	9d 85       	ldd	r25, Y+13	; 0x0d
    9254:	ae 85       	ldd	r26, Y+14	; 0x0e
    9256:	bf 85       	ldd	r27, Y+15	; 0x0f
    9258:	bc 01       	movw	r22, r24
    925a:	cd 01       	movw	r24, r26
    925c:	41 e0       	ldi	r20, 0x01	; 1
    925e:	0f ef       	ldi	r16, 0xFF	; 255
    9260:	1f ef       	ldi	r17, 0xFF	; 255
    9262:	2f ef       	ldi	r18, 0xFF	; 255
    9264:	3f e0       	ldi	r19, 0x0F	; 15
    9266:	0e 94 1b 43 	call	0x8636	; 0x8636 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    926a:	8c 85       	ldd	r24, Y+12	; 0x0c
    926c:	9d 85       	ldd	r25, Y+13	; 0x0d
    926e:	ae 85       	ldd	r26, Y+14	; 0x0e
    9270:	bf 85       	ldd	r27, Y+15	; 0x0f
    9272:	cd 01       	movw	r24, r26
    9274:	aa 27       	eor	r26, r26
    9276:	bb 27       	eor	r27, r27
    9278:	8e 83       	std	Y+6, r24	; 0x06
    927a:	9f 83       	std	Y+7, r25	; 0x07
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    927c:	8c 85       	ldd	r24, Y+12	; 0x0c
    927e:	9d 85       	ldd	r25, Y+13	; 0x0d
    9280:	88 87       	std	Y+8, r24	; 0x08
    9282:	99 87       	std	Y+9, r25	; 0x09
  fileSize = 0;
    9284:	10 92 51 40 	sts	0x4051, r1
    9288:	10 92 52 40 	sts	0x4052, r1
    928c:	10 92 53 40 	sts	0x4053, r1
    9290:	10 92 54 40 	sts	0x4054, r1
}

//start writing data here

if(start){
    9294:	8b 81       	ldd	r24, Y+3	; 0x03
    9296:	88 23       	and	r24, r24
    9298:	11 f1       	breq	.+68     	; 0x92de <writeFile+0x274>
  start = 0;
    929a:	1b 82       	std	Y+3, r1	; 0x03
  startBlock = getFirstSector (cluster) + sector;
    929c:	8c 85       	ldd	r24, Y+12	; 0x0c
    929e:	9d 85       	ldd	r25, Y+13	; 0x0d
    92a0:	ae 85       	ldd	r26, Y+14	; 0x0e
    92a2:	bf 85       	ldd	r27, Y+15	; 0x0f
    92a4:	bc 01       	movw	r22, r24
    92a6:	cd 01       	movw	r24, r26
    92a8:	0e 94 e9 42 	call	0x85d2	; 0x85d2 <getFirstSector>
    92ac:	dc 01       	movw	r26, r24
    92ae:	cb 01       	movw	r24, r22
    92b0:	9c 01       	movw	r18, r24
    92b2:	8d 81       	ldd	r24, Y+5	; 0x05
    92b4:	88 2f       	mov	r24, r24
    92b6:	90 e0       	ldi	r25, 0x00	; 0
    92b8:	82 0f       	add	r24, r18
    92ba:	93 1f       	adc	r25, r19
    92bc:	8a 87       	std	Y+10, r24	; 0x0a
    92be:	9b 87       	std	Y+11, r25	; 0x0b
  SD_read_block (startBlock,SDBuffer);
    92c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    92c2:	9b 85       	ldd	r25, Y+11	; 0x0b
    92c4:	cc 01       	movw	r24, r24
    92c6:	a0 e0       	ldi	r26, 0x00	; 0
    92c8:	b0 e0       	ldi	r27, 0x00	; 0
    92ca:	27 ed       	ldi	r18, 0xD7	; 215
    92cc:	31 e2       	ldi	r19, 0x21	; 33
    92ce:	bc 01       	movw	r22, r24
    92d0:	cd 01       	movw	r24, r26
    92d2:	a9 01       	movw	r20, r18
    92d4:	0e 94 15 51 	call	0xa22a	; 0xa22a <SD_read_block>
  j = sector;
    92d8:	8d 81       	ldd	r24, Y+5	; 0x05
    92da:	89 83       	std	Y+1, r24	; 0x01
    92dc:	0d c0       	rjmp	.+26     	; 0x92f8 <writeFile+0x28e>
}
else{
  startBlock = getFirstSector (cluster);
    92de:	8c 85       	ldd	r24, Y+12	; 0x0c
    92e0:	9d 85       	ldd	r25, Y+13	; 0x0d
    92e2:	ae 85       	ldd	r26, Y+14	; 0x0e
    92e4:	bf 85       	ldd	r27, Y+15	; 0x0f
    92e6:	bc 01       	movw	r22, r24
    92e8:	cd 01       	movw	r24, r26
    92ea:	0e 94 e9 42 	call	0x85d2	; 0x85d2 <getFirstSector>
    92ee:	dc 01       	movw	r26, r24
    92f0:	cb 01       	movw	r24, r22
    92f2:	8a 87       	std	Y+10, r24	; 0x0a
    92f4:	9b 87       	std	Y+11, r25	; 0x0b
  j=0;
    92f6:	19 82       	std	Y+1, r1	; 0x01
}
uint32_t writtenData = 0;
    92f8:	18 8e       	std	Y+24, r1	; 0x18
    92fa:	19 8e       	std	Y+25, r1	; 0x19
    92fc:	1a 8e       	std	Y+26, r1	; 0x1a
    92fe:	1b 8e       	std	Y+27, r1	; 0x1b
uint32_t dataToWrite = 0;
    9300:	1c 8e       	std	Y+28, r1	; 0x1c
    9302:	1d 8e       	std	Y+29, r1	; 0x1d
    9304:	1e 8e       	std	Y+30, r1	; 0x1e
    9306:	1f 8e       	std	Y+31, r1	; 0x1f
while(lengthOfData!=0){
    9308:	cd c0       	rjmp	.+410    	; 0x94a4 <writeFile+0x43a>
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    930a:	8c a9       	sts	0x4c, r24
    930c:	9d a9       	sts	0x4d, r25
    930e:	ae a9       	sts	0x4e, r26
    9310:	bf a9       	sts	0x4f, r27
    9312:	80 30       	cpi	r24, 0x00	; 0
    9314:	32 e0       	ldi	r19, 0x02	; 2
    9316:	93 07       	cpc	r25, r19
    9318:	30 e0       	ldi	r19, 0x00	; 0
    931a:	a3 07       	cpc	r26, r19
    931c:	30 e0       	ldi	r19, 0x00	; 0
    931e:	b3 07       	cpc	r27, r19
    9320:	08 f1       	brcs	.+66     	; 0x9364 <writeFile+0x2fa>
		 writtenData += 512;
    9322:	88 8d       	ldd	r24, Y+24	; 0x18
    9324:	99 8d       	ldd	r25, Y+25	; 0x19
    9326:	aa 8d       	ldd	r26, Y+26	; 0x1a
    9328:	bb 8d       	ldd	r27, Y+27	; 0x1b
    932a:	80 50       	subi	r24, 0x00	; 0
    932c:	9e 4f       	sbci	r25, 0xFE	; 254
    932e:	af 4f       	sbci	r26, 0xFF	; 255
    9330:	bf 4f       	sbci	r27, 0xFF	; 255
    9332:	88 8f       	std	Y+24, r24	; 0x18
    9334:	99 8f       	std	Y+25, r25	; 0x19
    9336:	aa 8f       	std	Y+26, r26	; 0x1a
    9338:	bb 8f       	std	Y+27, r27	; 0x1b
		 dataToWrite = 512;
    933a:	80 e0       	ldi	r24, 0x00	; 0
    933c:	92 e0       	ldi	r25, 0x02	; 2
    933e:	a0 e0       	ldi	r26, 0x00	; 0
    9340:	b0 e0       	ldi	r27, 0x00	; 0
    9342:	8c 8f       	std	Y+28, r24	; 0x1c
    9344:	9d 8f       	std	Y+29, r25	; 0x1d
    9346:	ae 8f       	std	Y+30, r26	; 0x1e
    9348:	bf 8f       	std	Y+31, r27	; 0x1f
		 lengthOfData -= 512;
    934a:	8c a9       	sts	0x4c, r24
    934c:	9d a9       	sts	0x4d, r25
    934e:	ae a9       	sts	0x4e, r26
    9350:	bf a9       	sts	0x4f, r27
    9352:	80 50       	subi	r24, 0x00	; 0
    9354:	92 40       	sbci	r25, 0x02	; 2
    9356:	a0 40       	sbci	r26, 0x00	; 0
    9358:	b0 40       	sbci	r27, 0x00	; 0
    935a:	8c ab       	sts	0x5c, r24
    935c:	9d ab       	sts	0x5d, r25
    935e:	ae ab       	sts	0x5e, r26
    9360:	bf ab       	sts	0x5f, r27
    9362:	1f c0       	rjmp	.+62     	; 0x93a2 <writeFile+0x338>
	}
	else{
		writtenData += lengthOfData;
    9364:	28 8d       	ldd	r18, Y+24	; 0x18
    9366:	39 8d       	ldd	r19, Y+25	; 0x19
    9368:	4a 8d       	ldd	r20, Y+26	; 0x1a
    936a:	5b 8d       	ldd	r21, Y+27	; 0x1b
    936c:	8c a9       	sts	0x4c, r24
    936e:	9d a9       	sts	0x4d, r25
    9370:	ae a9       	sts	0x4e, r26
    9372:	bf a9       	sts	0x4f, r27
    9374:	82 0f       	add	r24, r18
    9376:	93 1f       	adc	r25, r19
    9378:	a4 1f       	adc	r26, r20
    937a:	b5 1f       	adc	r27, r21
    937c:	88 8f       	std	Y+24, r24	; 0x18
    937e:	99 8f       	std	Y+25, r25	; 0x19
    9380:	aa 8f       	std	Y+26, r26	; 0x1a
    9382:	bb 8f       	std	Y+27, r27	; 0x1b
		dataToWrite = lengthOfData%512;
    9384:	8c a9       	sts	0x4c, r24
    9386:	9d a9       	sts	0x4d, r25
    9388:	ae a9       	sts	0x4e, r26
    938a:	bf a9       	sts	0x4f, r27
    938c:	91 70       	andi	r25, 0x01	; 1
    938e:	a0 70       	andi	r26, 0x00	; 0
    9390:	b0 70       	andi	r27, 0x00	; 0
    9392:	8c 8f       	std	Y+28, r24	; 0x1c
    9394:	9d 8f       	std	Y+29, r25	; 0x1d
    9396:	ae 8f       	std	Y+30, r26	; 0x1e
    9398:	bf 8f       	std	Y+31, r27	; 0x1f
		lengthOfData = 0;
    939a:	1c aa       	sts	0x9c, r17
    939c:	1d aa       	sts	0x9d, r17
    939e:	1e aa       	sts	0x9e, r17
    93a0:	1f aa       	sts	0x9f, r17
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    93a2:	80 91 51 40 	lds	r24, 0x4051
    93a6:	90 91 52 40 	lds	r25, 0x4052
    93aa:	a0 91 53 40 	lds	r26, 0x4053
    93ae:	b0 91 54 40 	lds	r27, 0x4054
    93b2:	80 50       	subi	r24, 0x00	; 0
    93b4:	9e 4f       	sbci	r25, 0xFE	; 254
    93b6:	af 4f       	sbci	r26, 0xFF	; 255
    93b8:	bf 4f       	sbci	r27, 0xFF	; 255
    93ba:	80 93 51 40 	sts	0x4051, r24
    93be:	90 93 52 40 	sts	0x4052, r25
    93c2:	a0 93 53 40 	sts	0x4053, r26
    93c6:	b0 93 54 40 	sts	0x4054, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    93ca:	8a 85       	ldd	r24, Y+10	; 0x0a
    93cc:	9b 85       	ldd	r25, Y+11	; 0x0b
    93ce:	cc 01       	movw	r24, r24
    93d0:	a0 e0       	ldi	r26, 0x00	; 0
    93d2:	b0 e0       	ldi	r27, 0x00	; 0
    93d4:	48 8d       	ldd	r20, Y+24	; 0x18
    93d6:	59 8d       	ldd	r21, Y+25	; 0x19
    93d8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    93da:	3d 8d       	ldd	r19, Y+29	; 0x1d
    93dc:	ba 01       	movw	r22, r20
    93de:	62 1b       	sub	r22, r18
    93e0:	73 0b       	sbc	r23, r19
    93e2:	9b 01       	movw	r18, r22
    93e4:	4a a9       	sts	0x4a, r20
    93e6:	5b a9       	sts	0x4b, r21
    93e8:	42 0f       	add	r20, r18
    93ea:	53 1f       	adc	r21, r19
    93ec:	2c 8d       	ldd	r18, Y+28	; 0x1c
    93ee:	3d 8d       	ldd	r19, Y+29	; 0x1d
    93f0:	bc 01       	movw	r22, r24
    93f2:	cd 01       	movw	r24, r26
    93f4:	0e 94 47 50 	call	0xa08e	; 0xa08e <SD_write_block>
	j++;
    93f8:	89 81       	ldd	r24, Y+1	; 0x01
    93fa:	8f 5f       	subi	r24, 0xFF	; 255
    93fc:	89 83       	std	Y+1, r24	; 0x01
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    93fe:	89 81       	ldd	r24, Y+1	; 0x01
    9400:	28 2f       	mov	r18, r24
    9402:	30 e0       	ldi	r19, 0x00	; 0
    9404:	80 91 78 50 	lds	r24, 0x5078
    9408:	90 91 79 50 	lds	r25, 0x5079
    940c:	28 17       	cp	r18, r24
    940e:	39 07       	cpc	r19, r25
    9410:	e1 f5       	brne	.+120    	; 0x948a <writeFile+0x420>
		j = 0; 
    9412:	19 82       	std	Y+1, r1	; 0x01
 
		prevCluster = cluster;
    9414:	8c 85       	ldd	r24, Y+12	; 0x0c
    9416:	9d 85       	ldd	r25, Y+13	; 0x0d
    9418:	ae 85       	ldd	r26, Y+14	; 0x0e
    941a:	bf 85       	ldd	r27, Y+15	; 0x0f
    941c:	88 8b       	std	Y+16, r24	; 0x10
    941e:	99 8b       	std	Y+17, r25	; 0x11
    9420:	aa 8b       	std	Y+18, r26	; 0x12
    9422:	bb 8b       	std	Y+19, r27	; 0x13
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    9424:	88 89       	ldd	r24, Y+16	; 0x10
    9426:	99 89       	ldd	r25, Y+17	; 0x11
    9428:	aa 89       	ldd	r26, Y+18	; 0x12
    942a:	bb 89       	ldd	r27, Y+19	; 0x13
    942c:	bc 01       	movw	r22, r24
    942e:	cd 01       	movw	r24, r26
    9430:	0e 94 0b 4c 	call	0x9816	; 0x9816 <searchNextFreeCluster>
    9434:	dc 01       	movw	r26, r24
    9436:	cb 01       	movw	r24, r22
    9438:	8c 87       	std	Y+12, r24	; 0x0c
    943a:	9d 87       	std	Y+13, r25	; 0x0d
    943c:	ae 87       	std	Y+14, r26	; 0x0e
    943e:	bf 87       	std	Y+15, r27	; 0x0f
		if(cluster == 0){
    9440:	8c 85       	ldd	r24, Y+12	; 0x0c
    9442:	9d 85       	ldd	r25, Y+13	; 0x0d
    9444:	ae 85       	ldd	r26, Y+14	; 0x0e
    9446:	bf 85       	ldd	r27, Y+15	; 0x0f
    9448:	00 97       	sbiw	r24, 0x00	; 0
    944a:	a1 05       	cpc	r26, r1
    944c:	b1 05       	cpc	r27, r1
    944e:	11 f4       	brne	.+4      	; 0x9454 <writeFile+0x3ea>
		  //No free cluster!
		  return 2;
    9450:	82 e0       	ldi	r24, 0x02	; 2
    9452:	d7 c1       	rjmp	.+942    	; 0x9802 <writeFile+0x798>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    9454:	88 89       	ldd	r24, Y+16	; 0x10
    9456:	99 89       	ldd	r25, Y+17	; 0x11
    9458:	aa 89       	ldd	r26, Y+18	; 0x12
    945a:	bb 89       	ldd	r27, Y+19	; 0x13
    945c:	0c 85       	ldd	r16, Y+12	; 0x0c
    945e:	1d 85       	ldd	r17, Y+13	; 0x0d
    9460:	2e 85       	ldd	r18, Y+14	; 0x0e
    9462:	3f 85       	ldd	r19, Y+15	; 0x0f
    9464:	bc 01       	movw	r22, r24
    9466:	cd 01       	movw	r24, r26
    9468:	41 e0       	ldi	r20, 0x01	; 1
    946a:	0e 94 1b 43 	call	0x8636	; 0x8636 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    946e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9470:	9d 85       	ldd	r25, Y+13	; 0x0d
    9472:	ae 85       	ldd	r26, Y+14	; 0x0e
    9474:	bf 85       	ldd	r27, Y+15	; 0x0f
    9476:	bc 01       	movw	r22, r24
    9478:	cd 01       	movw	r24, r26
    947a:	41 e0       	ldi	r20, 0x01	; 1
    947c:	0f ef       	ldi	r16, 0xFF	; 255
    947e:	1f ef       	ldi	r17, 0xFF	; 255
    9480:	2f ef       	ldi	r18, 0xFF	; 255
    9482:	3f e0       	ldi	r19, 0x0F	; 15
    9484:	0e 94 1b 43 	call	0x8636	; 0x8636 <getSetNextCluster>
    9488:	05 c0       	rjmp	.+10     	; 0x9494 <writeFile+0x42a>
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    948a:	8a 85       	ldd	r24, Y+10	; 0x0a
    948c:	9b 85       	ldd	r25, Y+11	; 0x0b
    948e:	01 96       	adiw	r24, 0x01	; 1
    9490:	8a 87       	std	Y+10, r24	; 0x0a
    9492:	9b 87       	std	Y+11, r25	; 0x0b
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    9494:	2c 85       	ldd	r18, Y+12	; 0x0c
    9496:	3d 85       	ldd	r19, Y+13	; 0x0d
    9498:	4e 85       	ldd	r20, Y+14	; 0x0e
    949a:	5f 85       	ldd	r21, Y+15	; 0x0f
    949c:	82 e0       	ldi	r24, 0x02	; 2
    949e:	61 e0       	ldi	r22, 0x01	; 1
    94a0:	0e 94 c5 43 	call	0x878a	; 0x878a <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    94a4:	8c a9       	sts	0x4c, r24
    94a6:	9d a9       	sts	0x4d, r25
    94a8:	ae a9       	sts	0x4e, r26
    94aa:	bf a9       	sts	0x4f, r27
    94ac:	00 97       	sbiw	r24, 0x00	; 0
    94ae:	a1 05       	cpc	r26, r1
    94b0:	b1 05       	cpc	r27, r1
    94b2:	09 f0       	breq	.+2      	; 0x94b6 <writeFile+0x44c>
    94b4:	2a cf       	rjmp	.-428    	; 0x930a <writeFile+0x2a0>
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    94b6:	8c 81       	ldd	r24, Y+4	; 0x04
    94b8:	88 23       	and	r24, r24
    94ba:	09 f4       	brne	.+2      	; 0x94be <writeFile+0x454>
    94bc:	66 c0       	rjmp	.+204    	; 0x958a <writeFile+0x520>
{
  SD_read_block (appendFileSector,SDBuffer);    
    94be:	80 91 ce 50 	lds	r24, 0x50CE
    94c2:	90 91 cf 50 	lds	r25, 0x50CF
    94c6:	a0 91 d0 50 	lds	r26, 0x50D0
    94ca:	b0 91 d1 50 	lds	r27, 0x50D1
    94ce:	27 ed       	ldi	r18, 0xD7	; 215
    94d0:	31 e2       	ldi	r19, 0x21	; 33
    94d2:	bc 01       	movw	r22, r24
    94d4:	cd 01       	movw	r24, r26
    94d6:	a9 01       	movw	r20, r18
    94d8:	0e 94 15 51 	call	0xa22a	; 0xa22a <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    94dc:	80 91 d8 23 	lds	r24, 0x23D8
    94e0:	90 91 d9 23 	lds	r25, 0x23D9
    94e4:	a0 91 da 23 	lds	r26, 0x23DA
    94e8:	b0 91 db 23 	lds	r27, 0x23DB
    94ec:	89 52       	subi	r24, 0x29	; 41
    94ee:	9e 4d       	sbci	r25, 0xDE	; 222
    94f0:	8e a3       	lds	r24, 0x5e
    94f2:	9f a3       	lds	r25, 0x5f

  dir->lastAccessDate = 0;   //date of last access ignored
    94f4:	8e a1       	lds	r24, 0x4e
    94f6:	9f a1       	lds	r25, 0x4f
    94f8:	fc 01       	movw	r30, r24
    94fa:	12 8a       	std	Z+18, r1	; 0x12
    94fc:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    94fe:	20 91 51 40 	lds	r18, 0x4051
    9502:	30 91 52 40 	lds	r19, 0x4052
    9506:	40 91 53 40 	lds	r20, 0x4053
    950a:	50 91 54 40 	lds	r21, 0x4054
    950e:	8e a1       	lds	r24, 0x4e
    9510:	9f a1       	lds	r25, 0x4f
    9512:	fc 01       	movw	r30, r24
    9514:	84 8d       	ldd	r24, Z+28	; 0x1c
    9516:	95 8d       	ldd	r25, Z+29	; 0x1d
    9518:	a6 8d       	ldd	r26, Z+30	; 0x1e
    951a:	b7 8d       	ldd	r27, Z+31	; 0x1f
    951c:	79 01       	movw	r14, r18
    951e:	8a 01       	movw	r16, r20
    9520:	e8 1a       	sub	r14, r24
    9522:	f9 0a       	sbc	r15, r25
    9524:	0a 0b       	sbc	r16, r26
    9526:	1b 0b       	sbc	r17, r27
    9528:	d8 01       	movw	r26, r16
    952a:	c7 01       	movw	r24, r14
    952c:	88 a7       	lds	r24, 0x78
    952e:	99 a7       	lds	r25, 0x79
    9530:	aa a7       	lds	r26, 0x7a
    9532:	bb a7       	lds	r27, 0x7b
  dir->fileSize = fileSize;
    9534:	80 91 51 40 	lds	r24, 0x4051
    9538:	90 91 52 40 	lds	r25, 0x4052
    953c:	a0 91 53 40 	lds	r26, 0x4053
    9540:	b0 91 54 40 	lds	r27, 0x4054
    9544:	2e a1       	lds	r18, 0x4e
    9546:	3f a1       	lds	r19, 0x4f
    9548:	f9 01       	movw	r30, r18
    954a:	84 8f       	std	Z+28, r24	; 0x1c
    954c:	95 8f       	std	Z+29, r25	; 0x1d
    954e:	a6 8f       	std	Z+30, r26	; 0x1e
    9550:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    9552:	80 91 ce 50 	lds	r24, 0x50CE
    9556:	90 91 cf 50 	lds	r25, 0x50CF
    955a:	a0 91 d0 50 	lds	r26, 0x50D0
    955e:	b0 91 d1 50 	lds	r27, 0x50D1
    9562:	27 ed       	ldi	r18, 0xD7	; 215
    9564:	31 e2       	ldi	r19, 0x21	; 33
    9566:	bc 01       	movw	r22, r24
    9568:	cd 01       	movw	r24, r26
    956a:	a9 01       	movw	r20, r18
    956c:	20 e0       	ldi	r18, 0x00	; 0
    956e:	32 e0       	ldi	r19, 0x02	; 2
    9570:	0e 94 47 50 	call	0xa08e	; 0xa08e <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    9574:	28 a5       	lds	r18, 0x68
    9576:	39 a5       	lds	r19, 0x69
    9578:	4a a5       	lds	r20, 0x6a
    957a:	5b a5       	lds	r21, 0x6b
    957c:	81 e0       	ldi	r24, 0x01	; 1
    957e:	ba 01       	movw	r22, r20
    9580:	a9 01       	movw	r20, r18
    9582:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <freeMemoryUpdate>

 //File appended!
  return 0;
    9586:	80 e0       	ldi	r24, 0x00	; 0
    9588:	3c c1       	rjmp	.+632    	; 0x9802 <writeFile+0x798>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    958a:	80 91 60 40 	lds	r24, 0x4060
    958e:	90 91 61 40 	lds	r25, 0x4061
    9592:	a0 91 62 40 	lds	r26, 0x4062
    9596:	b0 91 63 40 	lds	r27, 0x4063
    959a:	88 8b       	std	Y+16, r24	; 0x10
    959c:	99 8b       	std	Y+17, r25	; 0x11
    959e:	aa 8b       	std	Y+18, r26	; 0x12
    95a0:	bb 8b       	std	Y+19, r27	; 0x13

while(1)
{
   firstSector = getFirstSector (prevCluster);
    95a2:	88 89       	ldd	r24, Y+16	; 0x10
    95a4:	99 89       	ldd	r25, Y+17	; 0x11
    95a6:	aa 89       	ldd	r26, Y+18	; 0x12
    95a8:	bb 89       	ldd	r27, Y+19	; 0x13
    95aa:	bc 01       	movw	r22, r24
    95ac:	cd 01       	movw	r24, r26
    95ae:	0e 94 e9 42 	call	0x85d2	; 0x85d2 <getFirstSector>
    95b2:	dc 01       	movw	r26, r24
    95b4:	cb 01       	movw	r24, r22
    95b6:	8c a7       	lds	r24, 0x7c
    95b8:	9d a7       	lds	r25, 0x7d
    95ba:	ae a7       	lds	r26, 0x7e
    95bc:	bf a7       	lds	r27, 0x7f

   for(sector = 0; sector < sectorPerCluster; sector++)
    95be:	1d 82       	std	Y+5, r1	; 0x05
    95c0:	ad c0       	rjmp	.+346    	; 0x971c <writeFile+0x6b2>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    95c2:	8d 81       	ldd	r24, Y+5	; 0x05
    95c4:	28 2f       	mov	r18, r24
    95c6:	30 e0       	ldi	r19, 0x00	; 0
    95c8:	40 e0       	ldi	r20, 0x00	; 0
    95ca:	50 e0       	ldi	r21, 0x00	; 0
    95cc:	8c a5       	lds	r24, 0x6c
    95ce:	9d a5       	lds	r25, 0x6d
    95d0:	ae a5       	lds	r26, 0x6e
    95d2:	bf a5       	lds	r27, 0x6f
    95d4:	82 0f       	add	r24, r18
    95d6:	93 1f       	adc	r25, r19
    95d8:	a4 1f       	adc	r26, r20
    95da:	b5 1f       	adc	r27, r21
    95dc:	27 ed       	ldi	r18, 0xD7	; 215
    95de:	31 e2       	ldi	r19, 0x21	; 33
    95e0:	bc 01       	movw	r22, r24
    95e2:	cd 01       	movw	r24, r26
    95e4:	a9 01       	movw	r20, r18
    95e6:	0e 94 15 51 	call	0xa22a	; 0xa22a <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    95ea:	18 a2       	lds	r17, 0x98
    95ec:	19 a2       	lds	r17, 0x99
    95ee:	89 c0       	rjmp	.+274    	; 0x9702 <writeFile+0x698>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    95f0:	88 a1       	lds	r24, 0x48
    95f2:	99 a1       	lds	r25, 0x49
    95f4:	89 52       	subi	r24, 0x29	; 41
    95f6:	9e 4d       	sbci	r25, 0xDE	; 222
    95f8:	8e a3       	lds	r24, 0x5e
    95fa:	9f a3       	lds	r25, 0x5f
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    95fc:	8a 81       	ldd	r24, Y+2	; 0x02
    95fe:	88 23       	and	r24, r24
    9600:	11 f0       	breq	.+4      	; 0x9606 <writeFile+0x59c>
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    9602:	80 e0       	ldi	r24, 0x00	; 0
    9604:	fe c0       	rjmp	.+508    	; 0x9802 <writeFile+0x798>
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    9606:	8e a1       	lds	r24, 0x4e
    9608:	9f a1       	lds	r25, 0x4f
    960a:	fc 01       	movw	r30, r24
    960c:	80 81       	ld	r24, Z
    960e:	88 23       	and	r24, r24
    9610:	39 f0       	breq	.+14     	; 0x9620 <writeFile+0x5b6>
    9612:	8e a1       	lds	r24, 0x4e
    9614:	9f a1       	lds	r25, 0x4f
    9616:	fc 01       	movw	r30, r24
    9618:	80 81       	ld	r24, Z
    961a:	85 3e       	cpi	r24, 0xE5	; 229
    961c:	09 f0       	breq	.+2      	; 0x9620 <writeFile+0x5b6>
    961e:	6c c0       	rjmp	.+216    	; 0x96f8 <writeFile+0x68e>
		{
		  for(j=0; j<11; j++)
    9620:	19 82       	std	Y+1, r1	; 0x01
    9622:	13 c0       	rjmp	.+38     	; 0x964a <writeFile+0x5e0>
  			dir->name[j] = Filename[j];
    9624:	89 81       	ldd	r24, Y+1	; 0x01
    9626:	88 2f       	mov	r24, r24
    9628:	90 e0       	ldi	r25, 0x00	; 0
    962a:	29 81       	ldd	r18, Y+1	; 0x01
    962c:	22 2f       	mov	r18, r18
    962e:	30 e0       	ldi	r19, 0x00	; 0
    9630:	28 54       	subi	r18, 0x48	; 72
    9632:	3f 4a       	sbci	r19, 0xAF	; 175
    9634:	f9 01       	movw	r30, r18
    9636:	40 81       	ld	r20, Z
    9638:	2e a1       	lds	r18, 0x4e
    963a:	3f a1       	lds	r19, 0x4f
    963c:	82 0f       	add	r24, r18
    963e:	93 1f       	adc	r25, r19
    9640:	fc 01       	movw	r30, r24
    9642:	40 83       	st	Z, r20
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    9644:	89 81       	ldd	r24, Y+1	; 0x01
    9646:	8f 5f       	subi	r24, 0xFF	; 255
    9648:	89 83       	std	Y+1, r24	; 0x01
    964a:	89 81       	ldd	r24, Y+1	; 0x01
    964c:	8b 30       	cpi	r24, 0x0B	; 11
    964e:	50 f3       	brcs	.-44     	; 0x9624 <writeFile+0x5ba>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    9650:	8e a1       	lds	r24, 0x4e
    9652:	9f a1       	lds	r25, 0x4f
    9654:	20 e2       	ldi	r18, 0x20	; 32
    9656:	fc 01       	movw	r30, r24
    9658:	23 87       	std	Z+11, r18	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    965a:	8e a1       	lds	r24, 0x4e
    965c:	9f a1       	lds	r25, 0x4f
    965e:	fc 01       	movw	r30, r24
    9660:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    9662:	8e a1       	lds	r24, 0x4e
    9664:	9f a1       	lds	r25, 0x4f
    9666:	fc 01       	movw	r30, r24
    9668:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    966a:	8e a1       	lds	r24, 0x4e
    966c:	9f a1       	lds	r25, 0x4f
    966e:	fc 01       	movw	r30, r24
    9670:	12 8a       	std	Z+18, r1	; 0x12
    9672:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    9674:	8e a1       	lds	r24, 0x4e
    9676:	9f a1       	lds	r25, 0x4f
    9678:	2e 81       	ldd	r18, Y+6	; 0x06
    967a:	3f 81       	ldd	r19, Y+7	; 0x07
    967c:	fc 01       	movw	r30, r24
    967e:	24 8b       	std	Z+20, r18	; 0x14
    9680:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    9682:	8e a1       	lds	r24, 0x4e
    9684:	9f a1       	lds	r25, 0x4f
    9686:	28 85       	ldd	r18, Y+8	; 0x08
    9688:	39 85       	ldd	r19, Y+9	; 0x09
    968a:	fc 01       	movw	r30, r24
    968c:	22 8f       	std	Z+26, r18	; 0x1a
    968e:	33 8f       	std	Z+27, r19	; 0x1b
		  dir->fileSize = fileSize;
    9690:	80 91 51 40 	lds	r24, 0x4051
    9694:	90 91 52 40 	lds	r25, 0x4052
    9698:	a0 91 53 40 	lds	r26, 0x4053
    969c:	b0 91 54 40 	lds	r27, 0x4054
    96a0:	2e a1       	lds	r18, 0x4e
    96a2:	3f a1       	lds	r19, 0x4f
    96a4:	f9 01       	movw	r30, r18
    96a6:	84 8f       	std	Z+28, r24	; 0x1c
    96a8:	95 8f       	std	Z+29, r25	; 0x1d
    96aa:	a6 8f       	std	Z+30, r26	; 0x1e
    96ac:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    96ae:	8d 81       	ldd	r24, Y+5	; 0x05
    96b0:	28 2f       	mov	r18, r24
    96b2:	30 e0       	ldi	r19, 0x00	; 0
    96b4:	40 e0       	ldi	r20, 0x00	; 0
    96b6:	50 e0       	ldi	r21, 0x00	; 0
    96b8:	8c a5       	lds	r24, 0x6c
    96ba:	9d a5       	lds	r25, 0x6d
    96bc:	ae a5       	lds	r26, 0x6e
    96be:	bf a5       	lds	r27, 0x6f
    96c0:	82 0f       	add	r24, r18
    96c2:	93 1f       	adc	r25, r19
    96c4:	a4 1f       	adc	r26, r20
    96c6:	b5 1f       	adc	r27, r21
    96c8:	27 ed       	ldi	r18, 0xD7	; 215
    96ca:	31 e2       	ldi	r19, 0x21	; 33
    96cc:	bc 01       	movw	r22, r24
    96ce:	cd 01       	movw	r24, r26
    96d0:	a9 01       	movw	r20, r18
    96d2:	20 e0       	ldi	r18, 0x00	; 0
    96d4:	32 e0       	ldi	r19, 0x02	; 2
    96d6:	0e 94 47 50 	call	0xa08e	; 0xa08e <SD_write_block>
		  fileCreatedFlag = 1;
    96da:	81 e0       	ldi	r24, 0x01	; 1
    96dc:	8a 83       	std	Y+2, r24	; 0x02

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    96de:	20 91 51 40 	lds	r18, 0x4051
    96e2:	30 91 52 40 	lds	r19, 0x4052
    96e6:	40 91 53 40 	lds	r20, 0x4053
    96ea:	50 91 54 40 	lds	r21, 0x4054
    96ee:	81 e0       	ldi	r24, 0x01	; 1
    96f0:	ba 01       	movw	r22, r20
    96f2:	a9 01       	movw	r20, r18
    96f4:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <freeMemoryUpdate>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    96f8:	88 a1       	lds	r24, 0x48
    96fa:	99 a1       	lds	r25, 0x49
    96fc:	80 96       	adiw	r24, 0x20	; 32
    96fe:	88 a3       	lds	r24, 0x58
    9700:	99 a3       	lds	r25, 0x59
    9702:	28 a1       	lds	r18, 0x48
    9704:	39 a1       	lds	r19, 0x49
    9706:	80 91 55 40 	lds	r24, 0x4055
    970a:	90 91 56 40 	lds	r25, 0x4056
    970e:	28 17       	cp	r18, r24
    9710:	39 07       	cpc	r19, r25
    9712:	08 f4       	brcc	.+2      	; 0x9716 <writeFile+0x6ac>
    9714:	6d cf       	rjmp	.-294    	; 0x95f0 <writeFile+0x586>

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    9716:	8d 81       	ldd	r24, Y+5	; 0x05
    9718:	8f 5f       	subi	r24, 0xFF	; 255
    971a:	8d 83       	std	Y+5, r24	; 0x05
    971c:	8d 81       	ldd	r24, Y+5	; 0x05
    971e:	28 2f       	mov	r18, r24
    9720:	30 e0       	ldi	r19, 0x00	; 0
    9722:	80 91 78 50 	lds	r24, 0x5078
    9726:	90 91 79 50 	lds	r25, 0x5079
    972a:	28 17       	cp	r18, r24
    972c:	39 07       	cpc	r19, r25
    972e:	08 f4       	brcc	.+2      	; 0x9732 <writeFile+0x6c8>
    9730:	48 cf       	rjmp	.-368    	; 0x95c2 <writeFile+0x558>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    9732:	88 89       	ldd	r24, Y+16	; 0x10
    9734:	99 89       	ldd	r25, Y+17	; 0x11
    9736:	aa 89       	ldd	r26, Y+18	; 0x12
    9738:	bb 89       	ldd	r27, Y+19	; 0x13
    973a:	bc 01       	movw	r22, r24
    973c:	cd 01       	movw	r24, r26
    973e:	40 e0       	ldi	r20, 0x00	; 0
    9740:	00 e0       	ldi	r16, 0x00	; 0
    9742:	10 e0       	ldi	r17, 0x00	; 0
    9744:	98 01       	movw	r18, r16
    9746:	0e 94 1b 43 	call	0x8636	; 0x8636 <getSetNextCluster>
    974a:	dc 01       	movw	r26, r24
    974c:	cb 01       	movw	r24, r22
    974e:	8c 87       	std	Y+12, r24	; 0x0c
    9750:	9d 87       	std	Y+13, r25	; 0x0d
    9752:	ae 87       	std	Y+14, r26	; 0x0e
    9754:	bf 87       	std	Y+15, r27	; 0x0f

   if(cluster > 0x0ffffff6)
    9756:	8c 85       	ldd	r24, Y+12	; 0x0c
    9758:	9d 85       	ldd	r25, Y+13	; 0x0d
    975a:	ae 85       	ldd	r26, Y+14	; 0x0e
    975c:	bf 85       	ldd	r27, Y+15	; 0x0f
    975e:	87 3f       	cpi	r24, 0xF7	; 247
    9760:	ff ef       	ldi	r31, 0xFF	; 255
    9762:	9f 07       	cpc	r25, r31
    9764:	ff ef       	ldi	r31, 0xFF	; 255
    9766:	af 07       	cpc	r26, r31
    9768:	ff e0       	ldi	r31, 0x0F	; 15
    976a:	bf 07       	cpc	r27, r31
    976c:	b8 f1       	brcs	.+110    	; 0x97dc <writeFile+0x772>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    976e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9770:	9d 85       	ldd	r25, Y+13	; 0x0d
    9772:	ae 85       	ldd	r26, Y+14	; 0x0e
    9774:	bf 85       	ldd	r27, Y+15	; 0x0f
    9776:	8f 3f       	cpi	r24, 0xFF	; 255
    9778:	0f ef       	ldi	r16, 0xFF	; 255
    977a:	90 07       	cpc	r25, r16
    977c:	0f ef       	ldi	r16, 0xFF	; 255
    977e:	a0 07       	cpc	r26, r16
    9780:	0f e0       	ldi	r16, 0x0F	; 15
    9782:	b0 07       	cpc	r27, r16
    9784:	49 f5       	brne	.+82     	; 0x97d8 <writeFile+0x76e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    9786:	88 89       	ldd	r24, Y+16	; 0x10
    9788:	99 89       	ldd	r25, Y+17	; 0x11
    978a:	aa 89       	ldd	r26, Y+18	; 0x12
    978c:	bb 89       	ldd	r27, Y+19	; 0x13
    978e:	bc 01       	movw	r22, r24
    9790:	cd 01       	movw	r24, r26
    9792:	0e 94 0b 4c 	call	0x9816	; 0x9816 <searchNextFreeCluster>
    9796:	dc 01       	movw	r26, r24
    9798:	cb 01       	movw	r24, r22
    979a:	8c 87       	std	Y+12, r24	; 0x0c
    979c:	9d 87       	std	Y+13, r25	; 0x0d
    979e:	ae 87       	std	Y+14, r26	; 0x0e
    97a0:	bf 87       	std	Y+15, r27	; 0x0f
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    97a2:	88 89       	ldd	r24, Y+16	; 0x10
    97a4:	99 89       	ldd	r25, Y+17	; 0x11
    97a6:	aa 89       	ldd	r26, Y+18	; 0x12
    97a8:	bb 89       	ldd	r27, Y+19	; 0x13
    97aa:	0c 85       	ldd	r16, Y+12	; 0x0c
    97ac:	1d 85       	ldd	r17, Y+13	; 0x0d
    97ae:	2e 85       	ldd	r18, Y+14	; 0x0e
    97b0:	3f 85       	ldd	r19, Y+15	; 0x0f
    97b2:	bc 01       	movw	r22, r24
    97b4:	cd 01       	movw	r24, r26
    97b6:	41 e0       	ldi	r20, 0x01	; 1
    97b8:	0e 94 1b 43 	call	0x8636	; 0x8636 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    97bc:	8c 85       	ldd	r24, Y+12	; 0x0c
    97be:	9d 85       	ldd	r25, Y+13	; 0x0d
    97c0:	ae 85       	ldd	r26, Y+14	; 0x0e
    97c2:	bf 85       	ldd	r27, Y+15	; 0x0f
    97c4:	bc 01       	movw	r22, r24
    97c6:	cd 01       	movw	r24, r26
    97c8:	41 e0       	ldi	r20, 0x01	; 1
    97ca:	0f ef       	ldi	r16, 0xFF	; 255
    97cc:	1f ef       	ldi	r17, 0xFF	; 255
    97ce:	2f ef       	ldi	r18, 0xFF	; 255
    97d0:	3f e0       	ldi	r19, 0x0F	; 15
    97d2:	0e 94 1b 43 	call	0x8636	; 0x8636 <getSetNextCluster>
    97d6:	02 c0       	rjmp	.+4      	; 0x97dc <writeFile+0x772>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    97d8:	83 e0       	ldi	r24, 0x03	; 3
    97da:	13 c0       	rjmp	.+38     	; 0x9802 <writeFile+0x798>
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    97dc:	8c 85       	ldd	r24, Y+12	; 0x0c
    97de:	9d 85       	ldd	r25, Y+13	; 0x0d
    97e0:	ae 85       	ldd	r26, Y+14	; 0x0e
    97e2:	bf 85       	ldd	r27, Y+15	; 0x0f
    97e4:	00 97       	sbiw	r24, 0x00	; 0
    97e6:	a1 05       	cpc	r26, r1
    97e8:	b1 05       	cpc	r27, r1
    97ea:	11 f4       	brne	.+4      	; 0x97f0 <writeFile+0x786>
	   return 4;
    97ec:	84 e0       	ldi	r24, 0x04	; 4
    97ee:	09 c0       	rjmp	.+18     	; 0x9802 <writeFile+0x798>
	}
   
   prevCluster = cluster;
    97f0:	8c 85       	ldd	r24, Y+12	; 0x0c
    97f2:	9d 85       	ldd	r25, Y+13	; 0x0d
    97f4:	ae 85       	ldd	r26, Y+14	; 0x0e
    97f6:	bf 85       	ldd	r27, Y+15	; 0x0f
    97f8:	88 8b       	std	Y+16, r24	; 0x10
    97fa:	99 8b       	std	Y+17, r25	; 0x11
    97fc:	aa 8b       	std	Y+18, r26	; 0x12
    97fe:	bb 8b       	std	Y+19, r27	; 0x13
 }
    9800:	d0 ce       	rjmp	.-608    	; 0x95a2 <writeFile+0x538>
 
 return 0;
}
    9802:	e7 96       	adiw	r28, 0x37	; 55
    9804:	cd bf       	out	0x3d, r28	; 61
    9806:	de bf       	out	0x3e, r29	; 62
    9808:	df 91       	pop	r29
    980a:	cf 91       	pop	r28
    980c:	1f 91       	pop	r17
    980e:	0f 91       	pop	r16
    9810:	ff 90       	pop	r15
    9812:	ef 90       	pop	r14
    9814:	08 95       	ret

00009816 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    9816:	ef 92       	push	r14
    9818:	ff 92       	push	r15
    981a:	0f 93       	push	r16
    981c:	1f 93       	push	r17
    981e:	cf 93       	push	r28
    9820:	df 93       	push	r29
    9822:	cd b7       	in	r28, 0x3d	; 61
    9824:	de b7       	in	r29, 0x3e	; 62
    9826:	2f 97       	sbiw	r28, 0x0f	; 15
    9828:	cd bf       	out	0x3d, r28	; 61
    982a:	de bf       	out	0x3e, r29	; 62
    982c:	6c 87       	std	Y+12, r22	; 0x0c
    982e:	7d 87       	std	Y+13, r23	; 0x0d
    9830:	8e 87       	std	Y+14, r24	; 0x0e
    9832:	9f 87       	std	Y+15, r25	; 0x0f
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    9834:	8c 85       	ldd	r24, Y+12	; 0x0c
    9836:	9d 85       	ldd	r25, Y+13	; 0x0d
    9838:	ae 85       	ldd	r26, Y+14	; 0x0e
    983a:	bf 85       	ldd	r27, Y+15	; 0x0f
    983c:	80 78       	andi	r24, 0x80	; 128
    983e:	8c 87       	std	Y+12, r24	; 0x0c
    9840:	9d 87       	std	Y+13, r25	; 0x0d
    9842:	ae 87       	std	Y+14, r26	; 0x0e
    9844:	bf 87       	std	Y+15, r27	; 0x0f
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    9846:	8c 85       	ldd	r24, Y+12	; 0x0c
    9848:	9d 85       	ldd	r25, Y+13	; 0x0d
    984a:	ae 85       	ldd	r26, Y+14	; 0x0e
    984c:	bf 85       	ldd	r27, Y+15	; 0x0f
    984e:	89 83       	std	Y+1, r24	; 0x01
    9850:	9a 83       	std	Y+2, r25	; 0x02
    9852:	ab 83       	std	Y+3, r26	; 0x03
    9854:	bc 83       	std	Y+4, r27	; 0x04
    9856:	7a c0       	rjmp	.+244    	; 0x994c <searchNextFreeCluster+0x136>
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    9858:	80 91 80 50 	lds	r24, 0x5080
    985c:	90 91 81 50 	lds	r25, 0x5081
    9860:	9c 01       	movw	r18, r24
    9862:	40 e0       	ldi	r20, 0x00	; 0
    9864:	50 e0       	ldi	r21, 0x00	; 0
    9866:	80 91 7a 50 	lds	r24, 0x507A
    986a:	90 91 7b 50 	lds	r25, 0x507B
    986e:	a0 91 7c 50 	lds	r26, 0x507C
    9872:	b0 91 7d 50 	lds	r27, 0x507D
    9876:	79 01       	movw	r14, r18
    9878:	8a 01       	movw	r16, r20
    987a:	e8 0e       	add	r14, r24
    987c:	f9 1e       	adc	r15, r25
    987e:	0a 1f       	adc	r16, r26
    9880:	1b 1f       	adc	r17, r27
    9882:	89 81       	ldd	r24, Y+1	; 0x01
    9884:	9a 81       	ldd	r25, Y+2	; 0x02
    9886:	ab 81       	ldd	r26, Y+3	; 0x03
    9888:	bc 81       	ldd	r27, Y+4	; 0x04
    988a:	88 0f       	add	r24, r24
    988c:	99 1f       	adc	r25, r25
    988e:	aa 1f       	adc	r26, r26
    9890:	bb 1f       	adc	r27, r27
    9892:	88 0f       	add	r24, r24
    9894:	99 1f       	adc	r25, r25
    9896:	aa 1f       	adc	r26, r26
    9898:	bb 1f       	adc	r27, r27
    989a:	20 91 55 40 	lds	r18, 0x4055
    989e:	30 91 56 40 	lds	r19, 0x4056
    98a2:	99 01       	movw	r18, r18
    98a4:	40 e0       	ldi	r20, 0x00	; 0
    98a6:	50 e0       	ldi	r21, 0x00	; 0
    98a8:	bc 01       	movw	r22, r24
    98aa:	cd 01       	movw	r24, r26
    98ac:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    98b0:	da 01       	movw	r26, r20
    98b2:	c9 01       	movw	r24, r18
    98b4:	8e 0d       	add	r24, r14
    98b6:	9f 1d       	adc	r25, r15
    98b8:	a0 1f       	adc	r26, r16
    98ba:	b1 1f       	adc	r27, r17
    98bc:	8e 83       	std	Y+6, r24	; 0x06
    98be:	9f 83       	std	Y+7, r25	; 0x07
    98c0:	a8 87       	std	Y+8, r26	; 0x08
    98c2:	b9 87       	std	Y+9, r27	; 0x09
      SD_read_block(sector,SDBuffer);
    98c4:	8e 81       	ldd	r24, Y+6	; 0x06
    98c6:	9f 81       	ldd	r25, Y+7	; 0x07
    98c8:	a8 85       	ldd	r26, Y+8	; 0x08
    98ca:	b9 85       	ldd	r27, Y+9	; 0x09
    98cc:	27 ed       	ldi	r18, 0xD7	; 215
    98ce:	31 e2       	ldi	r19, 0x21	; 33
    98d0:	bc 01       	movw	r22, r24
    98d2:	cd 01       	movw	r24, r26
    98d4:	a9 01       	movw	r20, r18
    98d6:	0e 94 15 51 	call	0xa22a	; 0xa22a <SD_read_block>
      for(i=0; i<128; i++)
    98da:	1d 82       	std	Y+5, r1	; 0x05
    98dc:	28 c0       	rjmp	.+80     	; 0x992e <searchNextFreeCluster+0x118>
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    98de:	8d 81       	ldd	r24, Y+5	; 0x05
    98e0:	88 2f       	mov	r24, r24
    98e2:	90 e0       	ldi	r25, 0x00	; 0
    98e4:	88 0f       	add	r24, r24
    98e6:	99 1f       	adc	r25, r25
    98e8:	88 0f       	add	r24, r24
    98ea:	99 1f       	adc	r25, r25
    98ec:	89 52       	subi	r24, 0x29	; 41
    98ee:	9e 4d       	sbci	r25, 0xDE	; 222
    98f0:	8a 87       	std	Y+10, r24	; 0x0a
    98f2:	9b 87       	std	Y+11, r25	; 0x0b
         if(((*value) & 0x0fffffff) == 0)
    98f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    98f6:	9b 85       	ldd	r25, Y+11	; 0x0b
    98f8:	fc 01       	movw	r30, r24
    98fa:	80 81       	ld	r24, Z
    98fc:	91 81       	ldd	r25, Z+1	; 0x01
    98fe:	a2 81       	ldd	r26, Z+2	; 0x02
    9900:	b3 81       	ldd	r27, Z+3	; 0x03
    9902:	bf 70       	andi	r27, 0x0F	; 15
    9904:	00 97       	sbiw	r24, 0x00	; 0
    9906:	a1 05       	cpc	r26, r1
    9908:	b1 05       	cpc	r27, r1
    990a:	71 f4       	brne	.+28     	; 0x9928 <searchNextFreeCluster+0x112>
            return(cluster+i);
    990c:	8d 81       	ldd	r24, Y+5	; 0x05
    990e:	28 2f       	mov	r18, r24
    9910:	30 e0       	ldi	r19, 0x00	; 0
    9912:	40 e0       	ldi	r20, 0x00	; 0
    9914:	50 e0       	ldi	r21, 0x00	; 0
    9916:	89 81       	ldd	r24, Y+1	; 0x01
    9918:	9a 81       	ldd	r25, Y+2	; 0x02
    991a:	ab 81       	ldd	r26, Y+3	; 0x03
    991c:	bc 81       	ldd	r27, Y+4	; 0x04
    991e:	82 0f       	add	r24, r18
    9920:	93 1f       	adc	r25, r19
    9922:	a4 1f       	adc	r26, r20
    9924:	b5 1f       	adc	r27, r21
    9926:	27 c0       	rjmp	.+78     	; 0x9976 <searchNextFreeCluster+0x160>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    9928:	8d 81       	ldd	r24, Y+5	; 0x05
    992a:	8f 5f       	subi	r24, 0xFF	; 255
    992c:	8d 83       	std	Y+5, r24	; 0x05
    992e:	8d 81       	ldd	r24, Y+5	; 0x05
    9930:	88 23       	and	r24, r24
    9932:	ac f6       	brge	.-86     	; 0x98de <searchNextFreeCluster+0xc8>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    9934:	89 81       	ldd	r24, Y+1	; 0x01
    9936:	9a 81       	ldd	r25, Y+2	; 0x02
    9938:	ab 81       	ldd	r26, Y+3	; 0x03
    993a:	bc 81       	ldd	r27, Y+4	; 0x04
    993c:	80 58       	subi	r24, 0x80	; 128
    993e:	9f 4f       	sbci	r25, 0xFF	; 255
    9940:	af 4f       	sbci	r26, 0xFF	; 255
    9942:	bf 4f       	sbci	r27, 0xFF	; 255
    9944:	89 83       	std	Y+1, r24	; 0x01
    9946:	9a 83       	std	Y+2, r25	; 0x02
    9948:	ab 83       	std	Y+3, r26	; 0x03
    994a:	bc 83       	std	Y+4, r27	; 0x04
    994c:	80 91 5a 40 	lds	r24, 0x405A
    9950:	90 91 5b 40 	lds	r25, 0x405B
    9954:	a0 91 5c 40 	lds	r26, 0x405C
    9958:	b0 91 5d 40 	lds	r27, 0x405D
    995c:	29 81       	ldd	r18, Y+1	; 0x01
    995e:	3a 81       	ldd	r19, Y+2	; 0x02
    9960:	4b 81       	ldd	r20, Y+3	; 0x03
    9962:	5c 81       	ldd	r21, Y+4	; 0x04
    9964:	28 17       	cp	r18, r24
    9966:	39 07       	cpc	r19, r25
    9968:	4a 07       	cpc	r20, r26
    996a:	5b 07       	cpc	r21, r27
    996c:	08 f4       	brcc	.+2      	; 0x9970 <searchNextFreeCluster+0x15a>
    996e:	74 cf       	rjmp	.-280    	; 0x9858 <searchNextFreeCluster+0x42>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    9970:	80 e0       	ldi	r24, 0x00	; 0
    9972:	90 e0       	ldi	r25, 0x00	; 0
    9974:	dc 01       	movw	r26, r24
}
    9976:	bc 01       	movw	r22, r24
    9978:	cd 01       	movw	r24, r26
    997a:	2f 96       	adiw	r28, 0x0f	; 15
    997c:	cd bf       	out	0x3d, r28	; 61
    997e:	de bf       	out	0x3e, r29	; 62
    9980:	df 91       	pop	r29
    9982:	cf 91       	pop	r28
    9984:	1f 91       	pop	r17
    9986:	0f 91       	pop	r16
    9988:	ff 90       	pop	r15
    998a:	ef 90       	pop	r14
    998c:	08 95       	ret

0000998e <deleteFile>:
//Function: to delete a specified file from the root directory
//Arguments: pointer to the file name
//return: none
//********************************************************************
void deleteFile (unsigned char *fileName)
{
    998e:	cf 93       	push	r28
    9990:	df 93       	push	r29
    9992:	00 d0       	rcall	.+0      	; 0x9994 <deleteFile+0x6>
    9994:	cd b7       	in	r28, 0x3d	; 61
    9996:	de b7       	in	r29, 0x3e	; 62
    9998:	8a 83       	std	Y+2, r24	; 0x02
    999a:	9b 83       	std	Y+3, r25	; 0x03
  unsigned char error;

  error = convertFileName (fileName);
    999c:	8a 81       	ldd	r24, Y+2	; 0x02
    999e:	9b 81       	ldd	r25, Y+3	; 0x03
    99a0:	0e 94 ff 46 	call	0x8dfe	; 0x8dfe <convertFileName>
    99a4:	89 83       	std	Y+1, r24	; 0x01
  if(error) return;
    99a6:	89 81       	ldd	r24, Y+1	; 0x01
    99a8:	88 23       	and	r24, r24
    99aa:	39 f4       	brne	.+14     	; 0x99ba <deleteFile+0x2c>

  findFiles (DELETE, Filename);
    99ac:	28 eb       	ldi	r18, 0xB8	; 184
    99ae:	30 e5       	ldi	r19, 0x50	; 80
    99b0:	82 e0       	ldi	r24, 0x02	; 2
    99b2:	b9 01       	movw	r22, r18
    99b4:	0e 94 76 44 	call	0x88ec	; 0x88ec <findFiles>
    99b8:	01 c0       	rjmp	.+2      	; 0x99bc <deleteFile+0x2e>
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
  if(error) return;
    99ba:	00 00       	nop

  findFiles (DELETE, Filename);
}
    99bc:	23 96       	adiw	r28, 0x03	; 3
    99be:	cd bf       	out	0x3d, r28	; 61
    99c0:	de bf       	out	0x3e, r29	; 62
    99c2:	df 91       	pop	r29
    99c4:	cf 91       	pop	r28
    99c6:	08 95       	ret

000099c8 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    99c8:	ef 92       	push	r14
    99ca:	ff 92       	push	r15
    99cc:	0f 93       	push	r16
    99ce:	1f 93       	push	r17
    99d0:	cf 93       	push	r28
    99d2:	df 93       	push	r29
    99d4:	cd b7       	in	r28, 0x3d	; 61
    99d6:	de b7       	in	r29, 0x3e	; 62
    99d8:	29 97       	sbiw	r28, 0x09	; 9
    99da:	cd bf       	out	0x3d, r28	; 61
    99dc:	de bf       	out	0x3e, r29	; 62
    99de:	8d 83       	std	Y+5, r24	; 0x05
    99e0:	4e 83       	std	Y+6, r20	; 0x06
    99e2:	5f 83       	std	Y+7, r21	; 0x07
    99e4:	68 87       	std	Y+8, r22	; 0x08
    99e6:	79 87       	std	Y+9, r23	; 0x09
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    99e8:	8e 81       	ldd	r24, Y+6	; 0x06
    99ea:	9f 81       	ldd	r25, Y+7	; 0x07
    99ec:	a8 85       	ldd	r26, Y+8	; 0x08
    99ee:	b9 85       	ldd	r27, Y+9	; 0x09
    99f0:	91 70       	andi	r25, 0x01	; 1
    99f2:	a0 70       	andi	r26, 0x00	; 0
    99f4:	b0 70       	andi	r27, 0x00	; 0
    99f6:	00 97       	sbiw	r24, 0x00	; 0
    99f8:	a1 05       	cpc	r26, r1
    99fa:	b1 05       	cpc	r27, r1
    99fc:	91 f4       	brne	.+36     	; 0x9a22 <freeMemoryUpdate+0x5a>
    99fe:	8e 81       	ldd	r24, Y+6	; 0x06
    9a00:	9f 81       	ldd	r25, Y+7	; 0x07
    9a02:	a8 85       	ldd	r26, Y+8	; 0x08
    9a04:	b9 85       	ldd	r27, Y+9	; 0x09
    9a06:	07 2e       	mov	r0, r23
    9a08:	79 e0       	ldi	r23, 0x09	; 9
    9a0a:	b6 95       	lsr	r27
    9a0c:	a7 95       	ror	r26
    9a0e:	97 95       	ror	r25
    9a10:	87 95       	ror	r24
    9a12:	7a 95       	dec	r23
    9a14:	d1 f7       	brne	.-12     	; 0x9a0a <freeMemoryUpdate+0x42>
    9a16:	70 2d       	mov	r23, r0
    9a18:	8e 83       	std	Y+6, r24	; 0x06
    9a1a:	9f 83       	std	Y+7, r25	; 0x07
    9a1c:	a8 87       	std	Y+8, r26	; 0x08
    9a1e:	b9 87       	std	Y+9, r27	; 0x09
    9a20:	14 c0       	rjmp	.+40     	; 0x9a4a <freeMemoryUpdate+0x82>
  else size = (size / 512) +1;
    9a22:	8e 81       	ldd	r24, Y+6	; 0x06
    9a24:	9f 81       	ldd	r25, Y+7	; 0x07
    9a26:	a8 85       	ldd	r26, Y+8	; 0x08
    9a28:	b9 85       	ldd	r27, Y+9	; 0x09
    9a2a:	07 2e       	mov	r0, r23
    9a2c:	79 e0       	ldi	r23, 0x09	; 9
    9a2e:	b6 95       	lsr	r27
    9a30:	a7 95       	ror	r26
    9a32:	97 95       	ror	r25
    9a34:	87 95       	ror	r24
    9a36:	7a 95       	dec	r23
    9a38:	d1 f7       	brne	.-12     	; 0x9a2e <freeMemoryUpdate+0x66>
    9a3a:	70 2d       	mov	r23, r0
    9a3c:	01 96       	adiw	r24, 0x01	; 1
    9a3e:	a1 1d       	adc	r26, r1
    9a40:	b1 1d       	adc	r27, r1
    9a42:	8e 83       	std	Y+6, r24	; 0x06
    9a44:	9f 83       	std	Y+7, r25	; 0x07
    9a46:	a8 87       	std	Y+8, r26	; 0x08
    9a48:	b9 87       	std	Y+9, r27	; 0x09
  if((size % 8) == 0) size = size / 8;
    9a4a:	8e 81       	ldd	r24, Y+6	; 0x06
    9a4c:	9f 81       	ldd	r25, Y+7	; 0x07
    9a4e:	a8 85       	ldd	r26, Y+8	; 0x08
    9a50:	b9 85       	ldd	r27, Y+9	; 0x09
    9a52:	87 70       	andi	r24, 0x07	; 7
    9a54:	90 70       	andi	r25, 0x00	; 0
    9a56:	a0 70       	andi	r26, 0x00	; 0
    9a58:	b0 70       	andi	r27, 0x00	; 0
    9a5a:	00 97       	sbiw	r24, 0x00	; 0
    9a5c:	a1 05       	cpc	r26, r1
    9a5e:	b1 05       	cpc	r27, r1
    9a60:	89 f4       	brne	.+34     	; 0x9a84 <freeMemoryUpdate+0xbc>
    9a62:	8e 81       	ldd	r24, Y+6	; 0x06
    9a64:	9f 81       	ldd	r25, Y+7	; 0x07
    9a66:	a8 85       	ldd	r26, Y+8	; 0x08
    9a68:	b9 85       	ldd	r27, Y+9	; 0x09
    9a6a:	68 94       	set
    9a6c:	12 f8       	bld	r1, 2
    9a6e:	b6 95       	lsr	r27
    9a70:	a7 95       	ror	r26
    9a72:	97 95       	ror	r25
    9a74:	87 95       	ror	r24
    9a76:	16 94       	lsr	r1
    9a78:	d1 f7       	brne	.-12     	; 0x9a6e <freeMemoryUpdate+0xa6>
    9a7a:	8e 83       	std	Y+6, r24	; 0x06
    9a7c:	9f 83       	std	Y+7, r25	; 0x07
    9a7e:	a8 87       	std	Y+8, r26	; 0x08
    9a80:	b9 87       	std	Y+9, r27	; 0x09
    9a82:	13 c0       	rjmp	.+38     	; 0x9aaa <freeMemoryUpdate+0xe2>
  else size = (size / 8) +1;
    9a84:	8e 81       	ldd	r24, Y+6	; 0x06
    9a86:	9f 81       	ldd	r25, Y+7	; 0x07
    9a88:	a8 85       	ldd	r26, Y+8	; 0x08
    9a8a:	b9 85       	ldd	r27, Y+9	; 0x09
    9a8c:	68 94       	set
    9a8e:	12 f8       	bld	r1, 2
    9a90:	b6 95       	lsr	r27
    9a92:	a7 95       	ror	r26
    9a94:	97 95       	ror	r25
    9a96:	87 95       	ror	r24
    9a98:	16 94       	lsr	r1
    9a9a:	d1 f7       	brne	.-12     	; 0x9a90 <freeMemoryUpdate+0xc8>
    9a9c:	01 96       	adiw	r24, 0x01	; 1
    9a9e:	a1 1d       	adc	r26, r1
    9aa0:	b1 1d       	adc	r27, r1
    9aa2:	8e 83       	std	Y+6, r24	; 0x06
    9aa4:	9f 83       	std	Y+7, r25	; 0x07
    9aa6:	a8 87       	std	Y+8, r26	; 0x08
    9aa8:	b9 87       	std	Y+9, r27	; 0x09

  if(freeClusterCountUpdated)
    9aaa:	80 91 cc 50 	lds	r24, 0x50CC
    9aae:	88 23       	and	r24, r24
    9ab0:	e9 f1       	breq	.+122    	; 0x9b2c <freeMemoryUpdate+0x164>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    9ab2:	81 e0       	ldi	r24, 0x01	; 1
    9ab4:	60 e0       	ldi	r22, 0x00	; 0
    9ab6:	20 e0       	ldi	r18, 0x00	; 0
    9ab8:	30 e0       	ldi	r19, 0x00	; 0
    9aba:	a9 01       	movw	r20, r18
    9abc:	0e 94 c5 43 	call	0x878a	; 0x878a <getSetFreeCluster>
    9ac0:	dc 01       	movw	r26, r24
    9ac2:	cb 01       	movw	r24, r22
    9ac4:	89 83       	std	Y+1, r24	; 0x01
    9ac6:	9a 83       	std	Y+2, r25	; 0x02
    9ac8:	ab 83       	std	Y+3, r26	; 0x03
    9aca:	bc 83       	std	Y+4, r27	; 0x04
	if(flag == ADD)
    9acc:	8d 81       	ldd	r24, Y+5	; 0x05
    9ace:	88 23       	and	r24, r24
    9ad0:	89 f4       	brne	.+34     	; 0x9af4 <freeMemoryUpdate+0x12c>
  	   freeClusters = freeClusters + size;
    9ad2:	29 81       	ldd	r18, Y+1	; 0x01
    9ad4:	3a 81       	ldd	r19, Y+2	; 0x02
    9ad6:	4b 81       	ldd	r20, Y+3	; 0x03
    9ad8:	5c 81       	ldd	r21, Y+4	; 0x04
    9ada:	8e 81       	ldd	r24, Y+6	; 0x06
    9adc:	9f 81       	ldd	r25, Y+7	; 0x07
    9ade:	a8 85       	ldd	r26, Y+8	; 0x08
    9ae0:	b9 85       	ldd	r27, Y+9	; 0x09
    9ae2:	82 0f       	add	r24, r18
    9ae4:	93 1f       	adc	r25, r19
    9ae6:	a4 1f       	adc	r26, r20
    9ae8:	b5 1f       	adc	r27, r21
    9aea:	89 83       	std	Y+1, r24	; 0x01
    9aec:	9a 83       	std	Y+2, r25	; 0x02
    9aee:	ab 83       	std	Y+3, r26	; 0x03
    9af0:	bc 83       	std	Y+4, r27	; 0x04
    9af2:	14 c0       	rjmp	.+40     	; 0x9b1c <freeMemoryUpdate+0x154>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    9af4:	29 81       	ldd	r18, Y+1	; 0x01
    9af6:	3a 81       	ldd	r19, Y+2	; 0x02
    9af8:	4b 81       	ldd	r20, Y+3	; 0x03
    9afa:	5c 81       	ldd	r21, Y+4	; 0x04
    9afc:	8e 81       	ldd	r24, Y+6	; 0x06
    9afe:	9f 81       	ldd	r25, Y+7	; 0x07
    9b00:	a8 85       	ldd	r26, Y+8	; 0x08
    9b02:	b9 85       	ldd	r27, Y+9	; 0x09
    9b04:	79 01       	movw	r14, r18
    9b06:	8a 01       	movw	r16, r20
    9b08:	e8 1a       	sub	r14, r24
    9b0a:	f9 0a       	sbc	r15, r25
    9b0c:	0a 0b       	sbc	r16, r26
    9b0e:	1b 0b       	sbc	r17, r27
    9b10:	d8 01       	movw	r26, r16
    9b12:	c7 01       	movw	r24, r14
    9b14:	89 83       	std	Y+1, r24	; 0x01
    9b16:	9a 83       	std	Y+2, r25	; 0x02
    9b18:	ab 83       	std	Y+3, r26	; 0x03
    9b1a:	bc 83       	std	Y+4, r27	; 0x04
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    9b1c:	29 81       	ldd	r18, Y+1	; 0x01
    9b1e:	3a 81       	ldd	r19, Y+2	; 0x02
    9b20:	4b 81       	ldd	r20, Y+3	; 0x03
    9b22:	5c 81       	ldd	r21, Y+4	; 0x04
    9b24:	81 e0       	ldi	r24, 0x01	; 1
    9b26:	61 e0       	ldi	r22, 0x01	; 1
    9b28:	0e 94 c5 43 	call	0x878a	; 0x878a <getSetFreeCluster>
  }
}
    9b2c:	29 96       	adiw	r28, 0x09	; 9
    9b2e:	cd bf       	out	0x3d, r28	; 61
    9b30:	de bf       	out	0x3e, r29	; 62
    9b32:	df 91       	pop	r29
    9b34:	cf 91       	pop	r28
    9b36:	1f 91       	pop	r17
    9b38:	0f 91       	pop	r16
    9b3a:	ff 90       	pop	r15
    9b3c:	ef 90       	pop	r14
    9b3e:	08 95       	ret

00009b40 <SD_init>:
# include "E-000001-000009_firmware_rev_1_0.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    9b40:	0f 93       	push	r16
    9b42:	1f 93       	push	r17
    9b44:	cf 93       	push	r28
    9b46:	df 93       	push	r29
    9b48:	cd b7       	in	r28, 0x3d	; 61
    9b4a:	de b7       	in	r29, 0x3e	; 62
    9b4c:	a9 97       	sbiw	r28, 0x29	; 41
    9b4e:	cd bf       	out	0x3d, r28	; 61
    9b50:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);				//power up portEX
    9b52:	81 e0       	ldi	r24, 0x01	; 1
    9b54:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    9b58:	81 e0       	ldi	r24, 0x01	; 1
    9b5a:	0e 94 cf 36 	call	0x6d9e	; 0x6d9e <Ext1Power>
    9b5e:	80 e0       	ldi	r24, 0x00	; 0
    9b60:	90 e0       	ldi	r25, 0x00	; 0
    9b62:	a8 ec       	ldi	r26, 0xC8	; 200
    9b64:	b2 e4       	ldi	r27, 0x42	; 66
    9b66:	8e 87       	std	Y+14, r24	; 0x0e
    9b68:	9f 87       	std	Y+15, r25	; 0x0f
    9b6a:	a8 8b       	std	Y+16, r26	; 0x10
    9b6c:	b9 8b       	std	Y+17, r27	; 0x11
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    9b6e:	6e 85       	ldd	r22, Y+14	; 0x0e
    9b70:	7f 85       	ldd	r23, Y+15	; 0x0f
    9b72:	88 89       	ldd	r24, Y+16	; 0x10
    9b74:	99 89       	ldd	r25, Y+17	; 0x11
    9b76:	20 e0       	ldi	r18, 0x00	; 0
    9b78:	30 e0       	ldi	r19, 0x00	; 0
    9b7a:	4a ef       	ldi	r20, 0xFA	; 250
    9b7c:	55 e4       	ldi	r21, 0x45	; 69
    9b7e:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    9b82:	dc 01       	movw	r26, r24
    9b84:	cb 01       	movw	r24, r22
    9b86:	8a 8b       	std	Y+18, r24	; 0x12
    9b88:	9b 8b       	std	Y+19, r25	; 0x13
    9b8a:	ac 8b       	std	Y+20, r26	; 0x14
    9b8c:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
    9b8e:	11 e0       	ldi	r17, 0x01	; 1
    9b90:	6a 89       	ldd	r22, Y+18	; 0x12
    9b92:	7b 89       	ldd	r23, Y+19	; 0x13
    9b94:	8c 89       	ldd	r24, Y+20	; 0x14
    9b96:	9d 89       	ldd	r25, Y+21	; 0x15
    9b98:	20 e0       	ldi	r18, 0x00	; 0
    9b9a:	30 e0       	ldi	r19, 0x00	; 0
    9b9c:	40 e8       	ldi	r20, 0x80	; 128
    9b9e:	5f e3       	ldi	r21, 0x3F	; 63
    9ba0:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    9ba4:	88 23       	and	r24, r24
    9ba6:	0c f0       	brlt	.+2      	; 0x9baa <SD_init+0x6a>
    9ba8:	10 e0       	ldi	r17, 0x00	; 0
    9baa:	11 23       	and	r17, r17
    9bac:	29 f0       	breq	.+10     	; 0x9bb8 <SD_init+0x78>
		__ticks = 1;
    9bae:	81 e0       	ldi	r24, 0x01	; 1
    9bb0:	90 e0       	ldi	r25, 0x00	; 0
    9bb2:	8e 8b       	std	Y+22, r24	; 0x16
    9bb4:	9f 8b       	std	Y+23, r25	; 0x17
    9bb6:	46 c0       	rjmp	.+140    	; 0x9c44 <SD_init+0x104>
	else if (__tmp > 65535)
    9bb8:	11 e0       	ldi	r17, 0x01	; 1
    9bba:	6a 89       	ldd	r22, Y+18	; 0x12
    9bbc:	7b 89       	ldd	r23, Y+19	; 0x13
    9bbe:	8c 89       	ldd	r24, Y+20	; 0x14
    9bc0:	9d 89       	ldd	r25, Y+21	; 0x15
    9bc2:	20 e0       	ldi	r18, 0x00	; 0
    9bc4:	3f ef       	ldi	r19, 0xFF	; 255
    9bc6:	4f e7       	ldi	r20, 0x7F	; 127
    9bc8:	57 e4       	ldi	r21, 0x47	; 71
    9bca:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    9bce:	18 16       	cp	r1, r24
    9bd0:	0c f0       	brlt	.+2      	; 0x9bd4 <SD_init+0x94>
    9bd2:	10 e0       	ldi	r17, 0x00	; 0
    9bd4:	11 23       	and	r17, r17
    9bd6:	61 f1       	breq	.+88     	; 0x9c30 <SD_init+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9bd8:	6e 85       	ldd	r22, Y+14	; 0x0e
    9bda:	7f 85       	ldd	r23, Y+15	; 0x0f
    9bdc:	88 89       	ldd	r24, Y+16	; 0x10
    9bde:	99 89       	ldd	r25, Y+17	; 0x11
    9be0:	20 e0       	ldi	r18, 0x00	; 0
    9be2:	30 e0       	ldi	r19, 0x00	; 0
    9be4:	40 e2       	ldi	r20, 0x20	; 32
    9be6:	51 e4       	ldi	r21, 0x41	; 65
    9be8:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    9bec:	dc 01       	movw	r26, r24
    9bee:	cb 01       	movw	r24, r22
    9bf0:	bc 01       	movw	r22, r24
    9bf2:	cd 01       	movw	r24, r26
    9bf4:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    9bf8:	dc 01       	movw	r26, r24
    9bfa:	cb 01       	movw	r24, r22
    9bfc:	8e 8b       	std	Y+22, r24	; 0x16
    9bfe:	9f 8b       	std	Y+23, r25	; 0x17
    9c00:	12 c0       	rjmp	.+36     	; 0x9c26 <SD_init+0xe6>
    9c02:	80 e2       	ldi	r24, 0x20	; 32
    9c04:	93 e0       	ldi	r25, 0x03	; 3
    9c06:	88 8f       	std	Y+24, r24	; 0x18
    9c08:	99 8f       	std	Y+25, r25	; 0x19
    9c0a:	88 8d       	ldd	r24, Y+24	; 0x18
    9c0c:	99 8d       	ldd	r25, Y+25	; 0x19
    9c0e:	8c 01       	movw	r16, r24
    9c10:	c8 01       	movw	r24, r16
    9c12:	01 97       	sbiw	r24, 0x01	; 1
    9c14:	f1 f7       	brne	.-4      	; 0x9c12 <SD_init+0xd2>
    9c16:	8c 01       	movw	r16, r24
    9c18:	08 8f       	std	Y+24, r16	; 0x18
    9c1a:	19 8f       	std	Y+25, r17	; 0x19
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9c1c:	8e 89       	ldd	r24, Y+22	; 0x16
    9c1e:	9f 89       	ldd	r25, Y+23	; 0x17
    9c20:	01 97       	sbiw	r24, 0x01	; 1
    9c22:	8e 8b       	std	Y+22, r24	; 0x16
    9c24:	9f 8b       	std	Y+23, r25	; 0x17
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9c26:	8e 89       	ldd	r24, Y+22	; 0x16
    9c28:	9f 89       	ldd	r25, Y+23	; 0x17
    9c2a:	00 97       	sbiw	r24, 0x00	; 0
    9c2c:	51 f7       	brne	.-44     	; 0x9c02 <SD_init+0xc2>
    9c2e:	17 c0       	rjmp	.+46     	; 0x9c5e <SD_init+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9c30:	6a 89       	ldd	r22, Y+18	; 0x12
    9c32:	7b 89       	ldd	r23, Y+19	; 0x13
    9c34:	8c 89       	ldd	r24, Y+20	; 0x14
    9c36:	9d 89       	ldd	r25, Y+21	; 0x15
    9c38:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    9c3c:	dc 01       	movw	r26, r24
    9c3e:	cb 01       	movw	r24, r22
    9c40:	8e 8b       	std	Y+22, r24	; 0x16
    9c42:	9f 8b       	std	Y+23, r25	; 0x17
    9c44:	8e 89       	ldd	r24, Y+22	; 0x16
    9c46:	9f 89       	ldd	r25, Y+23	; 0x17
    9c48:	8a 8f       	std	Y+26, r24	; 0x1a
    9c4a:	9b 8f       	std	Y+27, r25	; 0x1b
    9c4c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    9c4e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    9c50:	8c 01       	movw	r16, r24
    9c52:	f8 01       	movw	r30, r16
    9c54:	31 97       	sbiw	r30, 0x01	; 1
    9c56:	f1 f7       	brne	.-4      	; 0x9c54 <SD_init+0x114>
    9c58:	8f 01       	movw	r16, r30
    9c5a:	0a 8f       	std	Y+26, r16	; 0x1a
    9c5c:	1b 8f       	std	Y+27, r17	; 0x1b
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    9c5e:	19 82       	std	Y+1, r1	; 0x01

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    9c60:	88 e0       	ldi	r24, 0x08	; 8
    9c62:	60 e0       	ldi	r22, 0x00	; 0
    9c64:	0e 94 39 35 	call	0x6a72	; 0x6a72 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9c68:	88 e0       	ldi	r24, 0x08	; 8
    9c6a:	60 e0       	ldi	r22, 0x00	; 0
    9c6c:	0e 94 05 36 	call	0x6c0a	; 0x6c0a <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    9c70:	80 e0       	ldi	r24, 0x00	; 0
    9c72:	90 e0       	ldi	r25, 0x00	; 0
    9c74:	63 e0       	ldi	r22, 0x03	; 3
    9c76:	70 e0       	ldi	r23, 0x00	; 0
    9c78:	0e 94 fd 39 	call	0x73fa	; 0x73fa <SPIInit2>
	SPICS(TRUE);
    9c7c:	81 e0       	ldi	r24, 0x01	; 1
    9c7e:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9c82:	1a 82       	std	Y+2, r1	; 0x02
    9c84:	1b 82       	std	Y+3, r1	; 0x03
    9c86:	17 c0       	rjmp	.+46     	; 0x9cb6 <SD_init+0x176>
		SPIC.DATA=SDHC_DUMMY_BYTE;
    9c88:	80 ec       	ldi	r24, 0xC0	; 192
    9c8a:	98 e0       	ldi	r25, 0x08	; 8
    9c8c:	2f ef       	ldi	r18, 0xFF	; 255
    9c8e:	fc 01       	movw	r30, r24
    9c90:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9c92:	00 00       	nop
    9c94:	80 ec       	ldi	r24, 0xC0	; 192
    9c96:	98 e0       	ldi	r25, 0x08	; 8
    9c98:	fc 01       	movw	r30, r24
    9c9a:	82 81       	ldd	r24, Z+2	; 0x02
    9c9c:	88 23       	and	r24, r24
    9c9e:	d4 f7       	brge	.-12     	; 0x9c94 <SD_init+0x154>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    9ca0:	80 ec       	ldi	r24, 0xC0	; 192
    9ca2:	98 e0       	ldi	r25, 0x08	; 8
    9ca4:	fc 01       	movw	r30, r24
    9ca6:	83 81       	ldd	r24, Z+3	; 0x03
    9ca8:	80 93 b7 50 	sts	0x50B7, r24
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9cac:	8a 81       	ldd	r24, Y+2	; 0x02
    9cae:	9b 81       	ldd	r25, Y+3	; 0x03
    9cb0:	01 96       	adiw	r24, 0x01	; 1
    9cb2:	8a 83       	std	Y+2, r24	; 0x02
    9cb4:	9b 83       	std	Y+3, r25	; 0x03
    9cb6:	8a 81       	ldd	r24, Y+2	; 0x02
    9cb8:	9b 81       	ldd	r25, Y+3	; 0x03
    9cba:	8a 30       	cpi	r24, 0x0A	; 10
    9cbc:	91 05       	cpc	r25, r1
    9cbe:	24 f3       	brlt	.-56     	; 0x9c88 <SD_init+0x148>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    9cc0:	80 e0       	ldi	r24, 0x00	; 0
    9cc2:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	SPIDisable();
    9cc6:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9cca:	88 e0       	ldi	r24, 0x08	; 8
    9ccc:	60 e0       	ldi	r22, 0x00	; 0
    9cce:	0e 94 68 36 	call	0x6cd0	; 0x6cd0 <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    9cd2:	80 e0       	ldi	r24, 0x00	; 0
    9cd4:	90 e0       	ldi	r25, 0x00	; 0
    9cd6:	63 e0       	ldi	r22, 0x03	; 3
    9cd8:	70 e0       	ldi	r23, 0x00	; 0
    9cda:	0e 94 fd 39 	call	0x73fa	; 0x73fa <SPIInit2>
	SPICS(TRUE);
    9cde:	81 e0       	ldi	r24, 0x01	; 1
    9ce0:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9ce4:	1c 82       	std	Y+4, r1	; 0x04
    9ce6:	1d 82       	std	Y+5, r1	; 0x05
    9ce8:	0d c0       	rjmp	.+26     	; 0x9d04 <SD_init+0x1c4>
		if (i >= 10) {												//try command 10 times before timing out
    9cea:	8c 81       	ldd	r24, Y+4	; 0x04
    9cec:	9d 81       	ldd	r25, Y+5	; 0x05
    9cee:	8a 30       	cpi	r24, 0x0A	; 10
    9cf0:	91 05       	cpc	r25, r1
    9cf2:	1c f0       	brlt	.+6      	; 0x9cfa <SD_init+0x1ba>
			//there was no response to the first command
			errorCode = 1;
    9cf4:	81 e0       	ldi	r24, 0x01	; 1
    9cf6:	89 83       	std	Y+1, r24	; 0x01
			break;
    9cf8:	10 c0       	rjmp	.+32     	; 0x9d1a <SD_init+0x1da>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9cfa:	8c 81       	ldd	r24, Y+4	; 0x04
    9cfc:	9d 81       	ldd	r25, Y+5	; 0x05
    9cfe:	01 96       	adiw	r24, 0x01	; 1
    9d00:	8c 83       	std	Y+4, r24	; 0x04
    9d02:	9d 83       	std	Y+5, r25	; 0x05
    9d04:	80 e0       	ldi	r24, 0x00	; 0
    9d06:	40 e0       	ldi	r20, 0x00	; 0
    9d08:	50 e0       	ldi	r21, 0x00	; 0
    9d0a:	ba 01       	movw	r22, r20
    9d0c:	25 e9       	ldi	r18, 0x95	; 149
    9d0e:	08 e0       	ldi	r16, 0x08	; 8
    9d10:	10 e0       	ldi	r17, 0x00	; 0
    9d12:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <SD_command>
    9d16:	81 30       	cpi	r24, 0x01	; 1
    9d18:	41 f7       	brne	.-48     	; 0x9cea <SD_init+0x1aa>
    9d1a:	80 e0       	ldi	r24, 0x00	; 0
    9d1c:	90 e0       	ldi	r25, 0x00	; 0
    9d1e:	a8 ec       	ldi	r26, 0xC8	; 200
    9d20:	b2 e4       	ldi	r27, 0x42	; 66
    9d22:	8c 8f       	std	Y+28, r24	; 0x1c
    9d24:	9d 8f       	std	Y+29, r25	; 0x1d
    9d26:	ae 8f       	std	Y+30, r26	; 0x1e
    9d28:	bf 8f       	std	Y+31, r27	; 0x1f
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    9d2a:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9d2c:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9d2e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9d30:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9d32:	20 e0       	ldi	r18, 0x00	; 0
    9d34:	30 e0       	ldi	r19, 0x00	; 0
    9d36:	4a ef       	ldi	r20, 0xFA	; 250
    9d38:	55 e4       	ldi	r21, 0x45	; 69
    9d3a:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    9d3e:	dc 01       	movw	r26, r24
    9d40:	cb 01       	movw	r24, r22
    9d42:	88 a3       	lds	r24, 0x58
    9d44:	99 a3       	lds	r25, 0x59
    9d46:	aa a3       	lds	r26, 0x5a
    9d48:	bb a3       	lds	r27, 0x5b
	if (__tmp < 1.0)
    9d4a:	11 e0       	ldi	r17, 0x01	; 1
    9d4c:	68 a1       	lds	r22, 0x48
    9d4e:	79 a1       	lds	r23, 0x49
    9d50:	8a a1       	lds	r24, 0x4a
    9d52:	9b a1       	lds	r25, 0x4b
    9d54:	20 e0       	ldi	r18, 0x00	; 0
    9d56:	30 e0       	ldi	r19, 0x00	; 0
    9d58:	40 e8       	ldi	r20, 0x80	; 128
    9d5a:	5f e3       	ldi	r21, 0x3F	; 63
    9d5c:	0e 94 22 5d 	call	0xba44	; 0xba44 <__cmpsf2>
    9d60:	88 23       	and	r24, r24
    9d62:	0c f0       	brlt	.+2      	; 0x9d66 <SD_init+0x226>
    9d64:	10 e0       	ldi	r17, 0x00	; 0
    9d66:	11 23       	and	r17, r17
    9d68:	29 f0       	breq	.+10     	; 0x9d74 <SD_init+0x234>
		__ticks = 1;
    9d6a:	81 e0       	ldi	r24, 0x01	; 1
    9d6c:	90 e0       	ldi	r25, 0x00	; 0
    9d6e:	8c a3       	lds	r24, 0x5c
    9d70:	9d a3       	lds	r25, 0x5d
    9d72:	46 c0       	rjmp	.+140    	; 0x9e00 <SD_init+0x2c0>
	else if (__tmp > 65535)
    9d74:	11 e0       	ldi	r17, 0x01	; 1
    9d76:	68 a1       	lds	r22, 0x48
    9d78:	79 a1       	lds	r23, 0x49
    9d7a:	8a a1       	lds	r24, 0x4a
    9d7c:	9b a1       	lds	r25, 0x4b
    9d7e:	20 e0       	ldi	r18, 0x00	; 0
    9d80:	3f ef       	ldi	r19, 0xFF	; 255
    9d82:	4f e7       	ldi	r20, 0x7F	; 127
    9d84:	57 e4       	ldi	r21, 0x47	; 71
    9d86:	0e 94 2f 5e 	call	0xbc5e	; 0xbc5e <__gesf2>
    9d8a:	18 16       	cp	r1, r24
    9d8c:	0c f0       	brlt	.+2      	; 0x9d90 <SD_init+0x250>
    9d8e:	10 e0       	ldi	r17, 0x00	; 0
    9d90:	11 23       	and	r17, r17
    9d92:	61 f1       	breq	.+88     	; 0x9dec <SD_init+0x2ac>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9d94:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9d96:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9d98:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9d9a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9d9c:	20 e0       	ldi	r18, 0x00	; 0
    9d9e:	30 e0       	ldi	r19, 0x00	; 0
    9da0:	40 e2       	ldi	r20, 0x20	; 32
    9da2:	51 e4       	ldi	r21, 0x41	; 65
    9da4:	0e 94 33 5e 	call	0xbc66	; 0xbc66 <__mulsf3>
    9da8:	dc 01       	movw	r26, r24
    9daa:	cb 01       	movw	r24, r22
    9dac:	bc 01       	movw	r22, r24
    9dae:	cd 01       	movw	r24, r26
    9db0:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    9db4:	dc 01       	movw	r26, r24
    9db6:	cb 01       	movw	r24, r22
    9db8:	8c a3       	lds	r24, 0x5c
    9dba:	9d a3       	lds	r25, 0x5d
    9dbc:	12 c0       	rjmp	.+36     	; 0x9de2 <SD_init+0x2a2>
    9dbe:	80 e2       	ldi	r24, 0x20	; 32
    9dc0:	93 e0       	ldi	r25, 0x03	; 3
    9dc2:	8e a3       	lds	r24, 0x5e
    9dc4:	9f a3       	lds	r25, 0x5f
    9dc6:	8e a1       	lds	r24, 0x4e
    9dc8:	9f a1       	lds	r25, 0x4f
    9dca:	8c 01       	movw	r16, r24
    9dcc:	c8 01       	movw	r24, r16
    9dce:	01 97       	sbiw	r24, 0x01	; 1
    9dd0:	f1 f7       	brne	.-4      	; 0x9dce <SD_init+0x28e>
    9dd2:	8c 01       	movw	r16, r24
    9dd4:	0e a3       	lds	r16, 0x5e
    9dd6:	1f a3       	lds	r17, 0x5f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9dd8:	8c a1       	lds	r24, 0x4c
    9dda:	9d a1       	lds	r25, 0x4d
    9ddc:	01 97       	sbiw	r24, 0x01	; 1
    9dde:	8c a3       	lds	r24, 0x5c
    9de0:	9d a3       	lds	r25, 0x5d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9de2:	8c a1       	lds	r24, 0x4c
    9de4:	9d a1       	lds	r25, 0x4d
    9de6:	00 97       	sbiw	r24, 0x00	; 0
    9de8:	51 f7       	brne	.-44     	; 0x9dbe <SD_init+0x27e>
    9dea:	17 c0       	rjmp	.+46     	; 0x9e1a <SD_init+0x2da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9dec:	68 a1       	lds	r22, 0x48
    9dee:	79 a1       	lds	r23, 0x49
    9df0:	8a a1       	lds	r24, 0x4a
    9df2:	9b a1       	lds	r25, 0x4b
    9df4:	0e 94 8e 5d 	call	0xbb1c	; 0xbb1c <__fixunssfsi>
    9df8:	dc 01       	movw	r26, r24
    9dfa:	cb 01       	movw	r24, r22
    9dfc:	8c a3       	lds	r24, 0x5c
    9dfe:	9d a3       	lds	r25, 0x5d
    9e00:	8c a1       	lds	r24, 0x4c
    9e02:	9d a1       	lds	r25, 0x4d
    9e04:	88 a7       	lds	r24, 0x78
    9e06:	99 a7       	lds	r25, 0x79
    9e08:	88 a5       	lds	r24, 0x68
    9e0a:	99 a5       	lds	r25, 0x69
    9e0c:	8c 01       	movw	r16, r24
    9e0e:	f8 01       	movw	r30, r16
    9e10:	31 97       	sbiw	r30, 0x01	; 1
    9e12:	f1 f7       	brne	.-4      	; 0x9e10 <SD_init+0x2d0>
    9e14:	8f 01       	movw	r16, r30
    9e16:	08 a7       	lds	r16, 0x78
    9e18:	19 a7       	lds	r17, 0x79
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    9e1a:	1e 82       	std	Y+6, r1	; 0x06
    9e1c:	1f 82       	std	Y+7, r1	; 0x07
    9e1e:	0d c0       	rjmp	.+26     	; 0x9e3a <SD_init+0x2fa>
		if (i >= 10) {
    9e20:	8e 81       	ldd	r24, Y+6	; 0x06
    9e22:	9f 81       	ldd	r25, Y+7	; 0x07
    9e24:	8a 30       	cpi	r24, 0x0A	; 10
    9e26:	91 05       	cpc	r25, r1
    9e28:	1c f0       	brlt	.+6      	; 0x9e30 <SD_init+0x2f0>
			//there was no response to the command
			errorCode = 1;
    9e2a:	81 e0       	ldi	r24, 0x01	; 1
    9e2c:	89 83       	std	Y+1, r24	; 0x01
			break;
    9e2e:	11 c0       	rjmp	.+34     	; 0x9e52 <SD_init+0x312>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    9e30:	8e 81       	ldd	r24, Y+6	; 0x06
    9e32:	9f 81       	ldd	r25, Y+7	; 0x07
    9e34:	01 96       	adiw	r24, 0x01	; 1
    9e36:	8e 83       	std	Y+6, r24	; 0x06
    9e38:	9f 83       	std	Y+7, r25	; 0x07
    9e3a:	88 e0       	ldi	r24, 0x08	; 8
    9e3c:	4a ea       	ldi	r20, 0xAA	; 170
    9e3e:	51 e0       	ldi	r21, 0x01	; 1
    9e40:	60 e0       	ldi	r22, 0x00	; 0
    9e42:	70 e0       	ldi	r23, 0x00	; 0
    9e44:	27 e8       	ldi	r18, 0x87	; 135
    9e46:	08 e0       	ldi	r16, 0x08	; 8
    9e48:	10 e0       	ldi	r17, 0x00	; 0
    9e4a:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <SD_command>
    9e4e:	81 30       	cpi	r24, 0x01	; 1
    9e50:	39 f7       	brne	.-50     	; 0x9e20 <SD_init+0x2e0>
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9e52:	18 86       	std	Y+8, r1	; 0x08
    9e54:	19 86       	std	Y+9, r1	; 0x09
    9e56:	13 c0       	rjmp	.+38     	; 0x9e7e <SD_init+0x33e>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    9e58:	88 85       	ldd	r24, Y+8	; 0x08
    9e5a:	99 85       	ldd	r25, Y+9	; 0x09
    9e5c:	8c 01       	movw	r16, r24
    9e5e:	0e 5f       	subi	r16, 0xFE	; 254
    9e60:	1f 4f       	sbci	r17, 0xFF	; 255
    9e62:	8f ef       	ldi	r24, 0xFF	; 255
    9e64:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    9e68:	28 2f       	mov	r18, r24
    9e6a:	c8 01       	movw	r24, r16
    9e6c:	85 55       	subi	r24, 0x55	; 85
    9e6e:	9f 4a       	sbci	r25, 0xAF	; 175
    9e70:	fc 01       	movw	r30, r24
    9e72:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9e74:	88 85       	ldd	r24, Y+8	; 0x08
    9e76:	99 85       	ldd	r25, Y+9	; 0x09
    9e78:	01 96       	adiw	r24, 0x01	; 1
    9e7a:	88 87       	std	Y+8, r24	; 0x08
    9e7c:	99 87       	std	Y+9, r25	; 0x09
    9e7e:	88 85       	ldd	r24, Y+8	; 0x08
    9e80:	99 85       	ldd	r25, Y+9	; 0x09
    9e82:	84 30       	cpi	r24, 0x04	; 4
    9e84:	91 05       	cpc	r25, r1
    9e86:	44 f3       	brlt	.-48     	; 0x9e58 <SD_init+0x318>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    9e88:	80 91 af 50 	lds	r24, 0x50AF
    9e8c:	81 30       	cpi	r24, 0x01	; 1
    9e8e:	21 f4       	brne	.+8      	; 0x9e98 <SD_init+0x358>
    9e90:	80 91 b0 50 	lds	r24, 0x50B0
    9e94:	8a 3a       	cpi	r24, 0xAA	; 170
    9e96:	11 f0       	breq	.+4      	; 0x9e9c <SD_init+0x35c>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    9e98:	81 e0       	ldi	r24, 0x01	; 1
    9e9a:	89 83       	std	Y+1, r24	; 0x01
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    9e9c:	87 e3       	ldi	r24, 0x37	; 55
    9e9e:	40 e0       	ldi	r20, 0x00	; 0
    9ea0:	50 e0       	ldi	r21, 0x00	; 0
    9ea2:	ba 01       	movw	r22, r20
    9ea4:	2f ef       	ldi	r18, 0xFF	; 255
    9ea6:	08 e0       	ldi	r16, 0x08	; 8
    9ea8:	10 e0       	ldi	r17, 0x00	; 0
    9eaa:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    9eae:	81 e0       	ldi	r24, 0x01	; 1
    9eb0:	40 e0       	ldi	r20, 0x00	; 0
    9eb2:	50 e0       	ldi	r21, 0x00	; 0
    9eb4:	60 e0       	ldi	r22, 0x00	; 0
    9eb6:	70 e4       	ldi	r23, 0x40	; 64
    9eb8:	2f ef       	ldi	r18, 0xFF	; 255
    9eba:	08 e0       	ldi	r16, 0x08	; 8
    9ebc:	10 e0       	ldi	r17, 0x00	; 0
    9ebe:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <SD_command>
	} while(Buffer[1]!= 0x00);
    9ec2:	80 91 ac 50 	lds	r24, 0x50AC
    9ec6:	88 23       	and	r24, r24
    9ec8:	49 f7       	brne	.-46     	; 0x9e9c <SD_init+0x35c>
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9eca:	1a 86       	std	Y+10, r1	; 0x0a
    9ecc:	1b 86       	std	Y+11, r1	; 0x0b
    9ece:	0d c0       	rjmp	.+26     	; 0x9eea <SD_init+0x3aa>
		if (i >= 10) {
    9ed0:	8a 85       	ldd	r24, Y+10	; 0x0a
    9ed2:	9b 85       	ldd	r25, Y+11	; 0x0b
    9ed4:	8a 30       	cpi	r24, 0x0A	; 10
    9ed6:	91 05       	cpc	r25, r1
    9ed8:	1c f0       	brlt	.+6      	; 0x9ee0 <SD_init+0x3a0>
			//there was no response to the command
			errorCode = 1;
    9eda:	81 e0       	ldi	r24, 0x01	; 1
    9edc:	89 83       	std	Y+1, r24	; 0x01
			break;
    9ede:	10 c0       	rjmp	.+32     	; 0x9f00 <SD_init+0x3c0>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9ee0:	8a 85       	ldd	r24, Y+10	; 0x0a
    9ee2:	9b 85       	ldd	r25, Y+11	; 0x0b
    9ee4:	01 96       	adiw	r24, 0x01	; 1
    9ee6:	8a 87       	std	Y+10, r24	; 0x0a
    9ee8:	9b 87       	std	Y+11, r25	; 0x0b
    9eea:	8a e3       	ldi	r24, 0x3A	; 58
    9eec:	40 e0       	ldi	r20, 0x00	; 0
    9eee:	50 e0       	ldi	r21, 0x00	; 0
    9ef0:	ba 01       	movw	r22, r20
    9ef2:	2f ef       	ldi	r18, 0xFF	; 255
    9ef4:	08 e0       	ldi	r16, 0x08	; 8
    9ef6:	10 e0       	ldi	r17, 0x00	; 0
    9ef8:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <SD_command>
    9efc:	88 23       	and	r24, r24
    9efe:	41 f7       	brne	.-48     	; 0x9ed0 <SD_init+0x390>
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9f00:	1c 86       	std	Y+12, r1	; 0x0c
    9f02:	1d 86       	std	Y+13, r1	; 0x0d
    9f04:	0f c0       	rjmp	.+30     	; 0x9f24 <SD_init+0x3e4>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    9f06:	8f ef       	ldi	r24, 0xFF	; 255
    9f08:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    9f0c:	28 2f       	mov	r18, r24
    9f0e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9f10:	9d 85       	ldd	r25, Y+13	; 0x0d
    9f12:	85 55       	subi	r24, 0x55	; 85
    9f14:	9f 4a       	sbci	r25, 0xAF	; 175
    9f16:	fc 01       	movw	r30, r24
    9f18:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9f1a:	8c 85       	ldd	r24, Y+12	; 0x0c
    9f1c:	9d 85       	ldd	r25, Y+13	; 0x0d
    9f1e:	01 96       	adiw	r24, 0x01	; 1
    9f20:	8c 87       	std	Y+12, r24	; 0x0c
    9f22:	9d 87       	std	Y+13, r25	; 0x0d
    9f24:	8c 85       	ldd	r24, Y+12	; 0x0c
    9f26:	9d 85       	ldd	r25, Y+13	; 0x0d
    9f28:	84 30       	cpi	r24, 0x04	; 4
    9f2a:	91 05       	cpc	r25, r1
    9f2c:	64 f3       	brlt	.-40     	; 0x9f06 <SD_init+0x3c6>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    9f2e:	80 91 ab 50 	lds	r24, 0x50AB
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    9f32:	80 e0       	ldi	r24, 0x00	; 0
    9f34:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	SPIDisable();
    9f38:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9f3c:	88 e0       	ldi	r24, 0x08	; 8
    9f3e:	60 e0       	ldi	r22, 0x00	; 0
    9f40:	0e 94 05 36 	call	0x6c0a	; 0x6c0a <PortEx_OUTSET>
	return errorCode;	
    9f44:	89 81       	ldd	r24, Y+1	; 0x01
}	
    9f46:	a9 96       	adiw	r28, 0x29	; 41
    9f48:	cd bf       	out	0x3d, r28	; 61
    9f4a:	de bf       	out	0x3e, r29	; 62
    9f4c:	df 91       	pop	r29
    9f4e:	cf 91       	pop	r28
    9f50:	1f 91       	pop	r17
    9f52:	0f 91       	pop	r16
    9f54:	08 95       	ret

00009f56 <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
    9f56:	cf 93       	push	r28
    9f58:	df 93       	push	r29
    9f5a:	0f 92       	push	r0
    9f5c:	0f 92       	push	r0
    9f5e:	cd b7       	in	r28, 0x3d	; 61
    9f60:	de b7       	in	r29, 0x3e	; 62
    9f62:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPIC.DATA = byteToSend;
    9f64:	80 ec       	ldi	r24, 0xC0	; 192
    9f66:	98 e0       	ldi	r25, 0x08	; 8
    9f68:	2a 81       	ldd	r18, Y+2	; 0x02
    9f6a:	fc 01       	movw	r30, r24
    9f6c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9f6e:	00 00       	nop
    9f70:	80 ec       	ldi	r24, 0xC0	; 192
    9f72:	98 e0       	ldi	r25, 0x08	; 8
    9f74:	fc 01       	movw	r30, r24
    9f76:	82 81       	ldd	r24, Z+2	; 0x02
    9f78:	88 23       	and	r24, r24
    9f7a:	d4 f7       	brge	.-12     	; 0x9f70 <SPI_write+0x1a>
	data = SPIC.DATA; //read SPI data register to reset status flag
    9f7c:	80 ec       	ldi	r24, 0xC0	; 192
    9f7e:	98 e0       	ldi	r25, 0x08	; 8
    9f80:	fc 01       	movw	r30, r24
    9f82:	83 81       	ldd	r24, Z+3	; 0x03
    9f84:	89 83       	std	Y+1, r24	; 0x01
	return data;
    9f86:	89 81       	ldd	r24, Y+1	; 0x01
}
    9f88:	0f 90       	pop	r0
    9f8a:	0f 90       	pop	r0
    9f8c:	df 91       	pop	r29
    9f8e:	cf 91       	pop	r28
    9f90:	08 95       	ret

00009f92 <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    9f92:	0f 93       	push	r16
    9f94:	1f 93       	push	r17
    9f96:	cf 93       	push	r28
    9f98:	df 93       	push	r29
    9f9a:	cd b7       	in	r28, 0x3d	; 61
    9f9c:	de b7       	in	r29, 0x3e	; 62
    9f9e:	2a 97       	sbiw	r28, 0x0a	; 10
    9fa0:	cd bf       	out	0x3d, r28	; 61
    9fa2:	de bf       	out	0x3e, r29	; 62
    9fa4:	8b 83       	std	Y+3, r24	; 0x03
    9fa6:	4c 83       	std	Y+4, r20	; 0x04
    9fa8:	5d 83       	std	Y+5, r21	; 0x05
    9faa:	6e 83       	std	Y+6, r22	; 0x06
    9fac:	7f 83       	std	Y+7, r23	; 0x07
    9fae:	28 87       	std	Y+8, r18	; 0x08
    9fb0:	09 87       	std	Y+9, r16	; 0x09
    9fb2:	1a 87       	std	Y+10, r17	; 0x0a
	
	SPI_write(SDHC_COMMAND_START | cmd);
    9fb4:	8b 81       	ldd	r24, Y+3	; 0x03
    9fb6:	80 64       	ori	r24, 0x40	; 64
    9fb8:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    9fbc:	8c 81       	ldd	r24, Y+4	; 0x04
    9fbe:	9d 81       	ldd	r25, Y+5	; 0x05
    9fc0:	ae 81       	ldd	r26, Y+6	; 0x06
    9fc2:	bf 81       	ldd	r27, Y+7	; 0x07
    9fc4:	8b 2f       	mov	r24, r27
    9fc6:	99 27       	eor	r25, r25
    9fc8:	aa 27       	eor	r26, r26
    9fca:	bb 27       	eor	r27, r27
    9fcc:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    9fd0:	8c 81       	ldd	r24, Y+4	; 0x04
    9fd2:	9d 81       	ldd	r25, Y+5	; 0x05
    9fd4:	ae 81       	ldd	r26, Y+6	; 0x06
    9fd6:	bf 81       	ldd	r27, Y+7	; 0x07
    9fd8:	cd 01       	movw	r24, r26
    9fda:	aa 27       	eor	r26, r26
    9fdc:	bb 27       	eor	r27, r27
    9fde:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    9fe2:	8c 81       	ldd	r24, Y+4	; 0x04
    9fe4:	9d 81       	ldd	r25, Y+5	; 0x05
    9fe6:	ae 81       	ldd	r26, Y+6	; 0x06
    9fe8:	bf 81       	ldd	r27, Y+7	; 0x07
    9fea:	89 2f       	mov	r24, r25
    9fec:	9a 2f       	mov	r25, r26
    9fee:	ab 2f       	mov	r26, r27
    9ff0:	bb 27       	eor	r27, r27
    9ff2:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    9ff6:	8c 81       	ldd	r24, Y+4	; 0x04
    9ff8:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
	SPI_write(crc);
    9ffc:	88 85       	ldd	r24, Y+8	; 0x08
    9ffe:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
	
	for(int i=0; i<read; i++){
    a002:	19 82       	std	Y+1, r1	; 0x01
    a004:	1a 82       	std	Y+2, r1	; 0x02
    a006:	33 c0       	rjmp	.+102    	; 0xa06e <SD_command+0xdc>
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    a008:	89 81       	ldd	r24, Y+1	; 0x01
    a00a:	9a 81       	ldd	r25, Y+2	; 0x02
    a00c:	2d e0       	ldi	r18, 0x0D	; 13
    a00e:	30 e0       	ldi	r19, 0x00	; 0
    a010:	b9 01       	movw	r22, r18
    a012:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__divmodhi4>
    a016:	8c 01       	movw	r16, r24
    a018:	8f ef       	ldi	r24, 0xFF	; 255
    a01a:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a01e:	28 2f       	mov	r18, r24
    a020:	c8 01       	movw	r24, r16
    a022:	85 55       	subi	r24, 0x55	; 85
    a024:	9f 4a       	sbci	r25, 0xAF	; 175
    a026:	fc 01       	movw	r30, r24
    a028:	20 83       	st	Z, r18
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    a02a:	89 81       	ldd	r24, Y+1	; 0x01
    a02c:	9a 81       	ldd	r25, Y+2	; 0x02
    a02e:	2d e0       	ldi	r18, 0x0D	; 13
    a030:	30 e0       	ldi	r19, 0x00	; 0
    a032:	b9 01       	movw	r22, r18
    a034:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__divmodhi4>
    a038:	85 55       	subi	r24, 0x55	; 85
    a03a:	9f 4a       	sbci	r25, 0xAF	; 175
    a03c:	fc 01       	movw	r30, r24
    a03e:	80 81       	ld	r24, Z
    a040:	8f 3f       	cpi	r24, 0xFF	; 255
    a042:	81 f0       	breq	.+32     	; 0xa064 <SD_command+0xd2>
			Buffer[1] = Buffer[i%13];
    a044:	89 81       	ldd	r24, Y+1	; 0x01
    a046:	9a 81       	ldd	r25, Y+2	; 0x02
    a048:	2d e0       	ldi	r18, 0x0D	; 13
    a04a:	30 e0       	ldi	r19, 0x00	; 0
    a04c:	b9 01       	movw	r22, r18
    a04e:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__divmodhi4>
    a052:	85 55       	subi	r24, 0x55	; 85
    a054:	9f 4a       	sbci	r25, 0xAF	; 175
    a056:	fc 01       	movw	r30, r24
    a058:	80 81       	ld	r24, Z
    a05a:	80 93 ac 50 	sts	0x50AC, r24
			return Buffer[1];
    a05e:	80 91 ac 50 	lds	r24, 0x50AC
    a062:	0d c0       	rjmp	.+26     	; 0xa07e <SD_command+0xec>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    a064:	89 81       	ldd	r24, Y+1	; 0x01
    a066:	9a 81       	ldd	r25, Y+2	; 0x02
    a068:	01 96       	adiw	r24, 0x01	; 1
    a06a:	89 83       	std	Y+1, r24	; 0x01
    a06c:	9a 83       	std	Y+2, r25	; 0x02
    a06e:	29 81       	ldd	r18, Y+1	; 0x01
    a070:	3a 81       	ldd	r19, Y+2	; 0x02
    a072:	89 85       	ldd	r24, Y+9	; 0x09
    a074:	9a 85       	ldd	r25, Y+10	; 0x0a
    a076:	28 17       	cp	r18, r24
    a078:	39 07       	cpc	r19, r25
    a07a:	34 f2       	brlt	.-116    	; 0xa008 <SD_command+0x76>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    a07c:	8f ef       	ldi	r24, 0xFF	; 255
}
    a07e:	2a 96       	adiw	r28, 0x0a	; 10
    a080:	cd bf       	out	0x3d, r28	; 61
    a082:	de bf       	out	0x3e, r29	; 62
    a084:	df 91       	pop	r29
    a086:	cf 91       	pop	r28
    a088:	1f 91       	pop	r17
    a08a:	0f 91       	pop	r16
    a08c:	08 95       	ret

0000a08e <SD_write_block>:

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    a08e:	0f 93       	push	r16
    a090:	1f 93       	push	r17
    a092:	cf 93       	push	r28
    a094:	df 93       	push	r29
    a096:	cd b7       	in	r28, 0x3d	; 61
    a098:	de b7       	in	r29, 0x3e	; 62
    a09a:	62 97       	sbiw	r28, 0x12	; 18
    a09c:	cd bf       	out	0x3d, r28	; 61
    a09e:	de bf       	out	0x3e, r29	; 62
    a0a0:	6b 87       	std	Y+11, r22	; 0x0b
    a0a2:	7c 87       	std	Y+12, r23	; 0x0c
    a0a4:	8d 87       	std	Y+13, r24	; 0x0d
    a0a6:	9e 87       	std	Y+14, r25	; 0x0e
    a0a8:	4f 87       	std	Y+15, r20	; 0x0f
    a0aa:	58 8b       	std	Y+16, r21	; 0x10
    a0ac:	29 8b       	std	Y+17, r18	; 0x11
    a0ae:	3a 8b       	std	Y+18, r19	; 0x12
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a0b0:	88 e0       	ldi	r24, 0x08	; 8
    a0b2:	60 e0       	ldi	r22, 0x00	; 0
    a0b4:	0e 94 68 36 	call	0x6cd0	; 0x6cd0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a0b8:	80 e0       	ldi	r24, 0x00	; 0
    a0ba:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
	SPICS(TRUE);
    a0be:	81 e0       	ldi	r24, 0x01	; 1
    a0c0:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    a0c4:	20 e0       	ldi	r18, 0x00	; 0
    a0c6:	32 e0       	ldi	r19, 0x02	; 2
    a0c8:	89 89       	ldd	r24, Y+17	; 0x11
    a0ca:	9a 89       	ldd	r25, Y+18	; 0x12
    a0cc:	a9 01       	movw	r20, r18
    a0ce:	48 1b       	sub	r20, r24
    a0d0:	59 0b       	sbc	r21, r25
    a0d2:	ca 01       	movw	r24, r20
    a0d4:	89 83       	std	Y+1, r24	; 0x01
    a0d6:	9a 83       	std	Y+2, r25	; 0x02
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    a0d8:	89 81       	ldd	r24, Y+1	; 0x01
    a0da:	9a 81       	ldd	r25, Y+2	; 0x02
    a0dc:	52 e0       	ldi	r21, 0x02	; 2
    a0de:	80 30       	cpi	r24, 0x00	; 0
    a0e0:	95 07       	cpc	r25, r21
    a0e2:	11 f4       	brne	.+4      	; 0xa0e8 <SD_write_block+0x5a>
    a0e4:	19 82       	std	Y+1, r1	; 0x01
    a0e6:	1a 82       	std	Y+2, r1	; 0x02
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    a0e8:	1b 82       	std	Y+3, r1	; 0x03
    a0ea:	1c 82       	std	Y+4, r1	; 0x04
    a0ec:	0b c0       	rjmp	.+22     	; 0xa104 <SD_write_block+0x76>
	if (i >= 10) {
    a0ee:	8b 81       	ldd	r24, Y+3	; 0x03
    a0f0:	9c 81       	ldd	r25, Y+4	; 0x04
    a0f2:	8a 30       	cpi	r24, 0x0A	; 10
    a0f4:	91 05       	cpc	r25, r1
    a0f6:	0c f0       	brlt	.+2      	; 0xa0fa <SD_write_block+0x6c>
		//there was no response to the command
		while(1);
    a0f8:	ff cf       	rjmp	.-2      	; 0xa0f8 <SD_write_block+0x6a>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    a0fa:	8b 81       	ldd	r24, Y+3	; 0x03
    a0fc:	9c 81       	ldd	r25, Y+4	; 0x04
    a0fe:	01 96       	adiw	r24, 0x01	; 1
    a100:	8b 83       	std	Y+3, r24	; 0x03
    a102:	9c 83       	std	Y+4, r25	; 0x04
    a104:	2b 85       	ldd	r18, Y+11	; 0x0b
    a106:	3c 85       	ldd	r19, Y+12	; 0x0c
    a108:	4d 85       	ldd	r20, Y+13	; 0x0d
    a10a:	5e 85       	ldd	r21, Y+14	; 0x0e
    a10c:	88 e1       	ldi	r24, 0x18	; 24
    a10e:	ba 01       	movw	r22, r20
    a110:	a9 01       	movw	r20, r18
    a112:	2f ef       	ldi	r18, 0xFF	; 255
    a114:	08 e0       	ldi	r16, 0x08	; 8
    a116:	10 e0       	ldi	r17, 0x00	; 0
    a118:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <SD_command>
    a11c:	88 23       	and	r24, r24
    a11e:	39 f7       	brne	.-50     	; 0xa0ee <SD_write_block+0x60>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    a120:	8f ef       	ldi	r24, 0xFF	; 255
    a122:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a126:	80 93 ab 50 	sts	0x50AB, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    a12a:	8e ef       	ldi	r24, 0xFE	; 254
    a12c:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    a130:	1d 82       	std	Y+5, r1	; 0x05
    a132:	1e 82       	std	Y+6, r1	; 0x06
    a134:	1d c0       	rjmp	.+58     	; 0xa170 <SD_write_block+0xe2>
Buffer[i%13] = SPI_write(data[i]);
    a136:	8d 81       	ldd	r24, Y+5	; 0x05
    a138:	9e 81       	ldd	r25, Y+6	; 0x06
    a13a:	2d e0       	ldi	r18, 0x0D	; 13
    a13c:	30 e0       	ldi	r19, 0x00	; 0
    a13e:	b9 01       	movw	r22, r18
    a140:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__divmodhi4>
    a144:	8c 01       	movw	r16, r24
    a146:	8d 81       	ldd	r24, Y+5	; 0x05
    a148:	9e 81       	ldd	r25, Y+6	; 0x06
    a14a:	2f 85       	ldd	r18, Y+15	; 0x0f
    a14c:	38 89       	ldd	r19, Y+16	; 0x10
    a14e:	82 0f       	add	r24, r18
    a150:	93 1f       	adc	r25, r19
    a152:	fc 01       	movw	r30, r24
    a154:	80 81       	ld	r24, Z
    a156:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a15a:	28 2f       	mov	r18, r24
    a15c:	c8 01       	movw	r24, r16
    a15e:	85 55       	subi	r24, 0x55	; 85
    a160:	9f 4a       	sbci	r25, 0xAF	; 175
    a162:	fc 01       	movw	r30, r24
    a164:	20 83       	st	Z, r18
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    a166:	8d 81       	ldd	r24, Y+5	; 0x05
    a168:	9e 81       	ldd	r25, Y+6	; 0x06
    a16a:	01 96       	adiw	r24, 0x01	; 1
    a16c:	8d 83       	std	Y+5, r24	; 0x05
    a16e:	9e 83       	std	Y+6, r25	; 0x06
    a170:	2d 81       	ldd	r18, Y+5	; 0x05
    a172:	3e 81       	ldd	r19, Y+6	; 0x06
    a174:	89 89       	ldd	r24, Y+17	; 0x11
    a176:	9a 89       	ldd	r25, Y+18	; 0x12
    a178:	28 17       	cp	r18, r24
    a17a:	39 07       	cpc	r19, r25
    a17c:	e4 f2       	brlt	.-72     	; 0xa136 <SD_write_block+0xa8>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    a17e:	1f 82       	std	Y+7, r1	; 0x07
    a180:	18 86       	std	Y+8, r1	; 0x08
    a182:	16 c0       	rjmp	.+44     	; 0xa1b0 <SD_write_block+0x122>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    a184:	8f 81       	ldd	r24, Y+7	; 0x07
    a186:	98 85       	ldd	r25, Y+8	; 0x08
    a188:	2d e0       	ldi	r18, 0x0D	; 13
    a18a:	30 e0       	ldi	r19, 0x00	; 0
    a18c:	b9 01       	movw	r22, r18
    a18e:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__divmodhi4>
    a192:	8c 01       	movw	r16, r24
    a194:	80 e0       	ldi	r24, 0x00	; 0
    a196:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a19a:	28 2f       	mov	r18, r24
    a19c:	c8 01       	movw	r24, r16
    a19e:	85 55       	subi	r24, 0x55	; 85
    a1a0:	9f 4a       	sbci	r25, 0xAF	; 175
    a1a2:	fc 01       	movw	r30, r24
    a1a4:	20 83       	st	Z, r18
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    a1a6:	8f 81       	ldd	r24, Y+7	; 0x07
    a1a8:	98 85       	ldd	r25, Y+8	; 0x08
    a1aa:	01 96       	adiw	r24, 0x01	; 1
    a1ac:	8f 83       	std	Y+7, r24	; 0x07
    a1ae:	98 87       	std	Y+8, r25	; 0x08
    a1b0:	2f 81       	ldd	r18, Y+7	; 0x07
    a1b2:	38 85       	ldd	r19, Y+8	; 0x08
    a1b4:	89 81       	ldd	r24, Y+1	; 0x01
    a1b6:	9a 81       	ldd	r25, Y+2	; 0x02
    a1b8:	28 17       	cp	r18, r24
    a1ba:	39 07       	cpc	r19, r25
    a1bc:	1c f3       	brlt	.-58     	; 0xa184 <SD_write_block+0xf6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    a1be:	8f ef       	ldi	r24, 0xFF	; 255
    a1c0:	80 93 ab 50 	sts	0x50AB, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    a1c4:	19 86       	std	Y+9, r1	; 0x09
    a1c6:	1a 86       	std	Y+10, r1	; 0x0a
    a1c8:	0a c0       	rjmp	.+20     	; 0xa1de <SD_write_block+0x150>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    a1ca:	8f ef       	ldi	r24, 0xFF	; 255
    a1cc:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a1d0:	80 93 ab 50 	sts	0x50AB, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    a1d4:	89 85       	ldd	r24, Y+9	; 0x09
    a1d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    a1d8:	01 96       	adiw	r24, 0x01	; 1
    a1da:	89 87       	std	Y+9, r24	; 0x09
    a1dc:	9a 87       	std	Y+10, r25	; 0x0a
    a1de:	89 85       	ldd	r24, Y+9	; 0x09
    a1e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    a1e2:	82 30       	cpi	r24, 0x02	; 2
    a1e4:	91 05       	cpc	r25, r1
    a1e6:	8c f3       	brlt	.-30     	; 0xa1ca <SD_write_block+0x13c>
    a1e8:	80 91 ab 50 	lds	r24, 0x50AB
    a1ec:	8f 3f       	cpi	r24, 0xFF	; 255
    a1ee:	69 f3       	breq	.-38     	; 0xa1ca <SD_write_block+0x13c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    a1f0:	80 91 ab 50 	lds	r24, 0x50AB
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    a1f4:	05 c0       	rjmp	.+10     	; 0xa200 <SD_write_block+0x172>
    a1f6:	8f ef       	ldi	r24, 0xFF	; 255
    a1f8:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a1fc:	80 93 ab 50 	sts	0x50AB, r24
    a200:	80 91 ab 50 	lds	r24, 0x50AB
    a204:	8f 3f       	cpi	r24, 0xFF	; 255
    a206:	b9 f7       	brne	.-18     	; 0xa1f6 <SD_write_block+0x168>
	SPICS(FALSE);
    a208:	80 e0       	ldi	r24, 0x00	; 0
    a20a:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	SPIDisable();
    a20e:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    a212:	88 e0       	ldi	r24, 0x08	; 8
    a214:	60 e0       	ldi	r22, 0x00	; 0
    a216:	0e 94 05 36 	call	0x6c0a	; 0x6c0a <PortEx_OUTSET>
}
    a21a:	62 96       	adiw	r28, 0x12	; 18
    a21c:	cd bf       	out	0x3d, r28	; 61
    a21e:	de bf       	out	0x3e, r29	; 62
    a220:	df 91       	pop	r29
    a222:	cf 91       	pop	r28
    a224:	1f 91       	pop	r17
    a226:	0f 91       	pop	r16
    a228:	08 95       	ret

0000a22a <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    a22a:	0f 93       	push	r16
    a22c:	1f 93       	push	r17
    a22e:	cf 93       	push	r28
    a230:	df 93       	push	r29
    a232:	cd b7       	in	r28, 0x3d	; 61
    a234:	de b7       	in	r29, 0x3e	; 62
    a236:	2a 97       	sbiw	r28, 0x0a	; 10
    a238:	cd bf       	out	0x3d, r28	; 61
    a23a:	de bf       	out	0x3e, r29	; 62
    a23c:	6d 83       	std	Y+5, r22	; 0x05
    a23e:	7e 83       	std	Y+6, r23	; 0x06
    a240:	8f 83       	std	Y+7, r24	; 0x07
    a242:	98 87       	std	Y+8, r25	; 0x08
    a244:	49 87       	std	Y+9, r20	; 0x09
    a246:	5a 87       	std	Y+10, r21	; 0x0a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a248:	88 e0       	ldi	r24, 0x08	; 8
    a24a:	60 e0       	ldi	r22, 0x00	; 0
    a24c:	0e 94 68 36 	call	0x6cd0	; 0x6cd0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a250:	80 e0       	ldi	r24, 0x00	; 0
    a252:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
	SPICS(TRUE);
    a256:	81 e0       	ldi	r24, 0x01	; 1
    a258:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    a25c:	19 82       	std	Y+1, r1	; 0x01
    a25e:	1a 82       	std	Y+2, r1	; 0x02
    a260:	0b c0       	rjmp	.+22     	; 0xa278 <SD_read_block+0x4e>
		if (i >= 10) {
    a262:	89 81       	ldd	r24, Y+1	; 0x01
    a264:	9a 81       	ldd	r25, Y+2	; 0x02
    a266:	8a 30       	cpi	r24, 0x0A	; 10
    a268:	91 05       	cpc	r25, r1
    a26a:	0c f0       	brlt	.+2      	; 0xa26e <SD_read_block+0x44>
			//there was no response to the command
			while(1);
    a26c:	ff cf       	rjmp	.-2      	; 0xa26c <SD_read_block+0x42>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    a26e:	89 81       	ldd	r24, Y+1	; 0x01
    a270:	9a 81       	ldd	r25, Y+2	; 0x02
    a272:	01 96       	adiw	r24, 0x01	; 1
    a274:	89 83       	std	Y+1, r24	; 0x01
    a276:	9a 83       	std	Y+2, r25	; 0x02
    a278:	2d 81       	ldd	r18, Y+5	; 0x05
    a27a:	3e 81       	ldd	r19, Y+6	; 0x06
    a27c:	4f 81       	ldd	r20, Y+7	; 0x07
    a27e:	58 85       	ldd	r21, Y+8	; 0x08
    a280:	81 e1       	ldi	r24, 0x11	; 17
    a282:	ba 01       	movw	r22, r20
    a284:	a9 01       	movw	r20, r18
    a286:	2f ef       	ldi	r18, 0xFF	; 255
    a288:	08 e0       	ldi	r16, 0x08	; 8
    a28a:	10 e0       	ldi	r17, 0x00	; 0
    a28c:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <SD_command>
    a290:	88 23       	and	r24, r24
    a292:	39 f7       	brne	.-50     	; 0xa262 <SD_read_block+0x38>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    a294:	05 c0       	rjmp	.+10     	; 0xa2a0 <SD_read_block+0x76>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    a296:	8f ef       	ldi	r24, 0xFF	; 255
    a298:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a29c:	80 93 ab 50 	sts	0x50AB, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    a2a0:	80 91 ab 50 	lds	r24, 0x50AB
    a2a4:	8e 3f       	cpi	r24, 0xFE	; 254
    a2a6:	b9 f7       	brne	.-18     	; 0xa296 <SD_read_block+0x6c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a2a8:	1b 82       	std	Y+3, r1	; 0x03
    a2aa:	1c 82       	std	Y+4, r1	; 0x04
    a2ac:	11 c0       	rjmp	.+34     	; 0xa2d0 <SD_read_block+0xa6>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a2ae:	8b 81       	ldd	r24, Y+3	; 0x03
    a2b0:	9c 81       	ldd	r25, Y+4	; 0x04
    a2b2:	29 85       	ldd	r18, Y+9	; 0x09
    a2b4:	3a 85       	ldd	r19, Y+10	; 0x0a
    a2b6:	89 01       	movw	r16, r18
    a2b8:	08 0f       	add	r16, r24
    a2ba:	19 1f       	adc	r17, r25
    a2bc:	8f ef       	ldi	r24, 0xFF	; 255
    a2be:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a2c2:	f8 01       	movw	r30, r16
    a2c4:	80 83       	st	Z, r24
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a2c6:	8b 81       	ldd	r24, Y+3	; 0x03
    a2c8:	9c 81       	ldd	r25, Y+4	; 0x04
    a2ca:	01 96       	adiw	r24, 0x01	; 1
    a2cc:	8b 83       	std	Y+3, r24	; 0x03
    a2ce:	9c 83       	std	Y+4, r25	; 0x04
    a2d0:	8b 81       	ldd	r24, Y+3	; 0x03
    a2d2:	9c 81       	ldd	r25, Y+4	; 0x04
    a2d4:	f2 e0       	ldi	r31, 0x02	; 2
    a2d6:	80 30       	cpi	r24, 0x00	; 0
    a2d8:	9f 07       	cpc	r25, r31
    a2da:	4c f3       	brlt	.-46     	; 0xa2ae <SD_read_block+0x84>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    a2dc:	10 92 b7 50 	sts	0x50B7, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    a2e0:	05 c0       	rjmp	.+10     	; 0xa2ec <SD_read_block+0xc2>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    a2e2:	8f ef       	ldi	r24, 0xFF	; 255
    a2e4:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a2e8:	80 93 b7 50 	sts	0x50B7, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    a2ec:	80 91 b7 50 	lds	r24, 0x50B7
    a2f0:	8f 3f       	cpi	r24, 0xFF	; 255
    a2f2:	b9 f7       	brne	.-18     	; 0xa2e2 <SD_read_block+0xb8>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    a2f4:	80 e0       	ldi	r24, 0x00	; 0
    a2f6:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	SPIDisable();
    a2fa:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a2fe:	88 e0       	ldi	r24, 0x08	; 8
    a300:	60 e0       	ldi	r22, 0x00	; 0
    a302:	0e 94 05 36 	call	0x6c0a	; 0x6c0a <PortEx_OUTSET>
}
    a306:	2a 96       	adiw	r28, 0x0a	; 10
    a308:	cd bf       	out	0x3d, r28	; 61
    a30a:	de bf       	out	0x3e, r29	; 62
    a30c:	df 91       	pop	r29
    a30e:	cf 91       	pop	r28
    a310:	1f 91       	pop	r17
    a312:	0f 91       	pop	r16
    a314:	08 95       	ret

0000a316 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    a316:	0f 93       	push	r16
    a318:	1f 93       	push	r17
    a31a:	cf 93       	push	r28
    a31c:	df 93       	push	r29
    a31e:	cd b7       	in	r28, 0x3d	; 61
    a320:	de b7       	in	r29, 0x3e	; 62
    a322:	6a 97       	sbiw	r28, 0x1a	; 26
    a324:	cd bf       	out	0x3d, r28	; 61
    a326:	de bf       	out	0x3e, r29	; 62
    a328:	6b 8b       	std	Y+19, r22	; 0x13
    a32a:	7c 8b       	std	Y+20, r23	; 0x14
    a32c:	8d 8b       	std	Y+21, r24	; 0x15
    a32e:	9e 8b       	std	Y+22, r25	; 0x16
    a330:	4f 8b       	std	Y+23, r20	; 0x17
    a332:	58 8f       	std	Y+24, r21	; 0x18
    a334:	29 8f       	std	Y+25, r18	; 0x19
    a336:	3a 8f       	std	Y+26, r19	; 0x1a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a338:	88 e0       	ldi	r24, 0x08	; 8
    a33a:	60 e0       	ldi	r22, 0x00	; 0
    a33c:	0e 94 68 36 	call	0x6cd0	; 0x6cd0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a340:	80 e0       	ldi	r24, 0x00	; 0
    a342:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
	SPICS(TRUE);
    a346:	81 e0       	ldi	r24, 0x01	; 1
    a348:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    a34c:	89 8d       	ldd	r24, Y+25	; 0x19
    a34e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    a350:	99 23       	and	r25, r25
    a352:	14 f4       	brge	.+4      	; 0xa358 <SD_write_multiple_blocks+0x42>
    a354:	81 50       	subi	r24, 0x01	; 1
    a356:	9e 4f       	sbci	r25, 0xFE	; 254
    a358:	89 2f       	mov	r24, r25
    a35a:	99 0f       	add	r25, r25
    a35c:	99 0b       	sbc	r25, r25
    a35e:	85 95       	asr	r24
    a360:	89 83       	std	Y+1, r24	; 0x01
    a362:	9a 83       	std	Y+2, r25	; 0x02
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    a364:	89 8d       	ldd	r24, Y+25	; 0x19
    a366:	9a 8d       	ldd	r25, Y+26	; 0x1a
    a368:	20 e0       	ldi	r18, 0x00	; 0
    a36a:	32 e0       	ldi	r19, 0x02	; 2
    a36c:	b9 01       	movw	r22, r18
    a36e:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__divmodhi4>
    a372:	20 e0       	ldi	r18, 0x00	; 0
    a374:	32 e0       	ldi	r19, 0x02	; 2
    a376:	a9 01       	movw	r20, r18
    a378:	48 1b       	sub	r20, r24
    a37a:	59 0b       	sbc	r21, r25
    a37c:	ca 01       	movw	r24, r20
    a37e:	8b 83       	std	Y+3, r24	; 0x03
    a380:	9c 83       	std	Y+4, r25	; 0x04
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    a382:	8b 81       	ldd	r24, Y+3	; 0x03
    a384:	9c 81       	ldd	r25, Y+4	; 0x04
    a386:	52 e0       	ldi	r21, 0x02	; 2
    a388:	80 30       	cpi	r24, 0x00	; 0
    a38a:	95 07       	cpc	r25, r21
    a38c:	19 f4       	brne	.+6      	; 0xa394 <SD_write_multiple_blocks+0x7e>
    a38e:	1b 82       	std	Y+3, r1	; 0x03
    a390:	1c 82       	std	Y+4, r1	; 0x04
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    a392:	05 c0       	rjmp	.+10     	; 0xa39e <SD_write_multiple_blocks+0x88>
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
    a394:	89 81       	ldd	r24, Y+1	; 0x01
    a396:	9a 81       	ldd	r25, Y+2	; 0x02
    a398:	01 96       	adiw	r24, 0x01	; 1
    a39a:	89 83       	std	Y+1, r24	; 0x01
    a39c:	9a 83       	std	Y+2, r25	; 0x02
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    a39e:	00 00       	nop
    a3a0:	2b 89       	ldd	r18, Y+19	; 0x13
    a3a2:	3c 89       	ldd	r19, Y+20	; 0x14
    a3a4:	4d 89       	ldd	r20, Y+21	; 0x15
    a3a6:	5e 89       	ldd	r21, Y+22	; 0x16
    a3a8:	89 e1       	ldi	r24, 0x19	; 25
    a3aa:	ba 01       	movw	r22, r20
    a3ac:	a9 01       	movw	r20, r18
    a3ae:	2f ef       	ldi	r18, 0xFF	; 255
    a3b0:	08 e0       	ldi	r16, 0x08	; 8
    a3b2:	10 e0       	ldi	r17, 0x00	; 0
    a3b4:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <SD_command>
    a3b8:	88 23       	and	r24, r24
    a3ba:	91 f7       	brne	.-28     	; 0xa3a0 <SD_write_multiple_blocks+0x8a>
	for (int j=0;j<numSectors;j++){
    a3bc:	1d 82       	std	Y+5, r1	; 0x05
    a3be:	1e 82       	std	Y+6, r1	; 0x06
    a3c0:	ba c0       	rjmp	.+372    	; 0xa536 <SD_write_multiple_blocks+0x220>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    a3c2:	8f ef       	ldi	r24, 0xFF	; 255
    a3c4:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a3c8:	80 93 ac 50 	sts	0x50AC, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    a3cc:	8c ef       	ldi	r24, 0xFC	; 252
    a3ce:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a3d2:	80 93 ac 50 	sts	0x50AC, r24
		if(j == (numSectors-1)){
    a3d6:	89 81       	ldd	r24, Y+1	; 0x01
    a3d8:	9a 81       	ldd	r25, Y+2	; 0x02
    a3da:	9c 01       	movw	r18, r24
    a3dc:	21 50       	subi	r18, 0x01	; 1
    a3de:	30 40       	sbci	r19, 0x00	; 0
    a3e0:	8d 81       	ldd	r24, Y+5	; 0x05
    a3e2:	9e 81       	ldd	r25, Y+6	; 0x06
    a3e4:	28 17       	cp	r18, r24
    a3e6:	39 07       	cpc	r19, r25
    a3e8:	09 f0       	breq	.+2      	; 0xa3ec <SD_write_multiple_blocks+0xd6>
    a3ea:	54 c0       	rjmp	.+168    	; 0xa494 <SD_write_multiple_blocks+0x17e>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    a3ec:	1f 82       	std	Y+7, r1	; 0x07
    a3ee:	18 86       	std	Y+8, r1	; 0x08
    a3f0:	25 c0       	rjmp	.+74     	; 0xa43c <SD_write_multiple_blocks+0x126>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    a3f2:	8f 81       	ldd	r24, Y+7	; 0x07
    a3f4:	98 85       	ldd	r25, Y+8	; 0x08
    a3f6:	2c e0       	ldi	r18, 0x0C	; 12
    a3f8:	30 e0       	ldi	r19, 0x00	; 0
    a3fa:	b9 01       	movw	r22, r18
    a3fc:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__divmodhi4>
    a400:	8c 01       	movw	r16, r24
    a402:	8d 81       	ldd	r24, Y+5	; 0x05
    a404:	9e 81       	ldd	r25, Y+6	; 0x06
    a406:	9c 01       	movw	r18, r24
    a408:	32 2f       	mov	r19, r18
    a40a:	22 27       	eor	r18, r18
    a40c:	33 0f       	add	r19, r19
    a40e:	8f 81       	ldd	r24, Y+7	; 0x07
    a410:	98 85       	ldd	r25, Y+8	; 0x08
    a412:	82 0f       	add	r24, r18
    a414:	93 1f       	adc	r25, r19
    a416:	2f 89       	ldd	r18, Y+23	; 0x17
    a418:	38 8d       	ldd	r19, Y+24	; 0x18
    a41a:	82 0f       	add	r24, r18
    a41c:	93 1f       	adc	r25, r19
    a41e:	fc 01       	movw	r30, r24
    a420:	80 81       	ld	r24, Z
    a422:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a426:	28 2f       	mov	r18, r24
    a428:	c8 01       	movw	r24, r16
    a42a:	85 55       	subi	r24, 0x55	; 85
    a42c:	9f 4a       	sbci	r25, 0xAF	; 175
    a42e:	fc 01       	movw	r30, r24
    a430:	20 83       	st	Z, r18
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    a432:	8f 81       	ldd	r24, Y+7	; 0x07
    a434:	98 85       	ldd	r25, Y+8	; 0x08
    a436:	01 96       	adiw	r24, 0x01	; 1
    a438:	8f 83       	std	Y+7, r24	; 0x07
    a43a:	98 87       	std	Y+8, r25	; 0x08
    a43c:	20 e0       	ldi	r18, 0x00	; 0
    a43e:	32 e0       	ldi	r19, 0x02	; 2
    a440:	8b 81       	ldd	r24, Y+3	; 0x03
    a442:	9c 81       	ldd	r25, Y+4	; 0x04
    a444:	28 1b       	sub	r18, r24
    a446:	39 0b       	sbc	r19, r25
    a448:	8f 81       	ldd	r24, Y+7	; 0x07
    a44a:	98 85       	ldd	r25, Y+8	; 0x08
    a44c:	82 17       	cp	r24, r18
    a44e:	93 07       	cpc	r25, r19
    a450:	84 f2       	brlt	.-96     	; 0xa3f2 <SD_write_multiple_blocks+0xdc>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    a452:	19 86       	std	Y+9, r1	; 0x09
    a454:	1a 86       	std	Y+10, r1	; 0x0a
    a456:	16 c0       	rjmp	.+44     	; 0xa484 <SD_write_multiple_blocks+0x16e>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    a458:	89 85       	ldd	r24, Y+9	; 0x09
    a45a:	9a 85       	ldd	r25, Y+10	; 0x0a
    a45c:	2c e0       	ldi	r18, 0x0C	; 12
    a45e:	30 e0       	ldi	r19, 0x00	; 0
    a460:	b9 01       	movw	r22, r18
    a462:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__divmodhi4>
    a466:	8c 01       	movw	r16, r24
    a468:	80 e0       	ldi	r24, 0x00	; 0
    a46a:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a46e:	28 2f       	mov	r18, r24
    a470:	c8 01       	movw	r24, r16
    a472:	85 55       	subi	r24, 0x55	; 85
    a474:	9f 4a       	sbci	r25, 0xAF	; 175
    a476:	fc 01       	movw	r30, r24
    a478:	20 83       	st	Z, r18
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    a47a:	89 85       	ldd	r24, Y+9	; 0x09
    a47c:	9a 85       	ldd	r25, Y+10	; 0x0a
    a47e:	01 96       	adiw	r24, 0x01	; 1
    a480:	89 87       	std	Y+9, r24	; 0x09
    a482:	9a 87       	std	Y+10, r25	; 0x0a
    a484:	29 85       	ldd	r18, Y+9	; 0x09
    a486:	3a 85       	ldd	r19, Y+10	; 0x0a
    a488:	8b 81       	ldd	r24, Y+3	; 0x03
    a48a:	9c 81       	ldd	r25, Y+4	; 0x04
    a48c:	28 17       	cp	r18, r24
    a48e:	39 07       	cpc	r19, r25
    a490:	1c f3       	brlt	.-58     	; 0xa458 <SD_write_multiple_blocks+0x142>
    a492:	2e c0       	rjmp	.+92     	; 0xa4f0 <SD_write_multiple_blocks+0x1da>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a494:	1b 86       	std	Y+11, r1	; 0x0b
    a496:	1c 86       	std	Y+12, r1	; 0x0c
    a498:	25 c0       	rjmp	.+74     	; 0xa4e4 <SD_write_multiple_blocks+0x1ce>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    a49a:	8b 85       	ldd	r24, Y+11	; 0x0b
    a49c:	9c 85       	ldd	r25, Y+12	; 0x0c
    a49e:	2c e0       	ldi	r18, 0x0C	; 12
    a4a0:	30 e0       	ldi	r19, 0x00	; 0
    a4a2:	b9 01       	movw	r22, r18
    a4a4:	0e 94 c9 5e 	call	0xbd92	; 0xbd92 <__divmodhi4>
    a4a8:	8c 01       	movw	r16, r24
    a4aa:	8d 81       	ldd	r24, Y+5	; 0x05
    a4ac:	9e 81       	ldd	r25, Y+6	; 0x06
    a4ae:	9c 01       	movw	r18, r24
    a4b0:	32 2f       	mov	r19, r18
    a4b2:	22 27       	eor	r18, r18
    a4b4:	33 0f       	add	r19, r19
    a4b6:	8b 85       	ldd	r24, Y+11	; 0x0b
    a4b8:	9c 85       	ldd	r25, Y+12	; 0x0c
    a4ba:	82 0f       	add	r24, r18
    a4bc:	93 1f       	adc	r25, r19
    a4be:	2f 89       	ldd	r18, Y+23	; 0x17
    a4c0:	38 8d       	ldd	r19, Y+24	; 0x18
    a4c2:	82 0f       	add	r24, r18
    a4c4:	93 1f       	adc	r25, r19
    a4c6:	fc 01       	movw	r30, r24
    a4c8:	80 81       	ld	r24, Z
    a4ca:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a4ce:	28 2f       	mov	r18, r24
    a4d0:	c8 01       	movw	r24, r16
    a4d2:	85 55       	subi	r24, 0x55	; 85
    a4d4:	9f 4a       	sbci	r25, 0xAF	; 175
    a4d6:	fc 01       	movw	r30, r24
    a4d8:	20 83       	st	Z, r18
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a4da:	8b 85       	ldd	r24, Y+11	; 0x0b
    a4dc:	9c 85       	ldd	r25, Y+12	; 0x0c
    a4de:	01 96       	adiw	r24, 0x01	; 1
    a4e0:	8b 87       	std	Y+11, r24	; 0x0b
    a4e2:	9c 87       	std	Y+12, r25	; 0x0c
    a4e4:	8b 85       	ldd	r24, Y+11	; 0x0b
    a4e6:	9c 85       	ldd	r25, Y+12	; 0x0c
    a4e8:	f2 e0       	ldi	r31, 0x02	; 2
    a4ea:	80 30       	cpi	r24, 0x00	; 0
    a4ec:	9f 07       	cpc	r25, r31
    a4ee:	ac f2       	brlt	.-86     	; 0xa49a <SD_write_multiple_blocks+0x184>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    a4f0:	1d 86       	std	Y+13, r1	; 0x0d
    a4f2:	1e 86       	std	Y+14, r1	; 0x0e
    a4f4:	0a c0       	rjmp	.+20     	; 0xa50a <SD_write_multiple_blocks+0x1f4>
    a4f6:	8f ef       	ldi	r24, 0xFF	; 255
    a4f8:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a4fc:	80 93 ac 50 	sts	0x50AC, r24
    a500:	8d 85       	ldd	r24, Y+13	; 0x0d
    a502:	9e 85       	ldd	r25, Y+14	; 0x0e
    a504:	01 96       	adiw	r24, 0x01	; 1
    a506:	8d 87       	std	Y+13, r24	; 0x0d
    a508:	9e 87       	std	Y+14, r25	; 0x0e
    a50a:	8d 85       	ldd	r24, Y+13	; 0x0d
    a50c:	9e 85       	ldd	r25, Y+14	; 0x0e
    a50e:	82 30       	cpi	r24, 0x02	; 2
    a510:	91 05       	cpc	r25, r1
    a512:	8c f3       	brlt	.-30     	; 0xa4f6 <SD_write_multiple_blocks+0x1e0>
		Buffer[1] = FILLER_BYTE;
    a514:	10 92 ac 50 	sts	0x50AC, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    a518:	05 c0       	rjmp	.+10     	; 0xa524 <SD_write_multiple_blocks+0x20e>
    a51a:	8f ef       	ldi	r24, 0xFF	; 255
    a51c:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a520:	80 93 ac 50 	sts	0x50AC, r24
    a524:	80 91 ac 50 	lds	r24, 0x50AC
    a528:	8f 3f       	cpi	r24, 0xFF	; 255
    a52a:	b9 f7       	brne	.-18     	; 0xa51a <SD_write_multiple_blocks+0x204>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    a52c:	8d 81       	ldd	r24, Y+5	; 0x05
    a52e:	9e 81       	ldd	r25, Y+6	; 0x06
    a530:	01 96       	adiw	r24, 0x01	; 1
    a532:	8d 83       	std	Y+5, r24	; 0x05
    a534:	9e 83       	std	Y+6, r25	; 0x06
    a536:	2d 81       	ldd	r18, Y+5	; 0x05
    a538:	3e 81       	ldd	r19, Y+6	; 0x06
    a53a:	89 81       	ldd	r24, Y+1	; 0x01
    a53c:	9a 81       	ldd	r25, Y+2	; 0x02
    a53e:	28 17       	cp	r18, r24
    a540:	39 07       	cpc	r19, r25
    a542:	0c f4       	brge	.+2      	; 0xa546 <SD_write_multiple_blocks+0x230>
    a544:	3e cf       	rjmp	.-388    	; 0xa3c2 <SD_write_multiple_blocks+0xac>
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a546:	1f 86       	std	Y+15, r1	; 0x0f
    a548:	18 8a       	std	Y+16, r1	; 0x10
    a54a:	0a c0       	rjmp	.+20     	; 0xa560 <SD_write_multiple_blocks+0x24a>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a54c:	8f ef       	ldi	r24, 0xFF	; 255
    a54e:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a552:	80 93 ac 50 	sts	0x50AC, r24
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a556:	8f 85       	ldd	r24, Y+15	; 0x0f
    a558:	98 89       	ldd	r25, Y+16	; 0x10
    a55a:	01 96       	adiw	r24, 0x01	; 1
    a55c:	8f 87       	std	Y+15, r24	; 0x0f
    a55e:	98 8b       	std	Y+16, r25	; 0x10
    a560:	8f 85       	ldd	r24, Y+15	; 0x0f
    a562:	98 89       	ldd	r25, Y+16	; 0x10
    a564:	84 30       	cpi	r24, 0x04	; 4
    a566:	91 05       	cpc	r25, r1
    a568:	8c f3       	brlt	.-30     	; 0xa54c <SD_write_multiple_blocks+0x236>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    a56a:	8d ef       	ldi	r24, 0xFD	; 253
    a56c:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a570:	80 93 ac 50 	sts	0x50AC, r24
	for(int i=0;i<4;i++){
    a574:	19 8a       	std	Y+17, r1	; 0x11
    a576:	1a 8a       	std	Y+18, r1	; 0x12
    a578:	0a c0       	rjmp	.+20     	; 0xa58e <SD_write_multiple_blocks+0x278>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a57a:	8f ef       	ldi	r24, 0xFF	; 255
    a57c:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a580:	80 93 ac 50 	sts	0x50AC, r24
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    a584:	89 89       	ldd	r24, Y+17	; 0x11
    a586:	9a 89       	ldd	r25, Y+18	; 0x12
    a588:	01 96       	adiw	r24, 0x01	; 1
    a58a:	89 8b       	std	Y+17, r24	; 0x11
    a58c:	9a 8b       	std	Y+18, r25	; 0x12
    a58e:	89 89       	ldd	r24, Y+17	; 0x11
    a590:	9a 89       	ldd	r25, Y+18	; 0x12
    a592:	84 30       	cpi	r24, 0x04	; 4
    a594:	91 05       	cpc	r25, r1
    a596:	8c f3       	brlt	.-30     	; 0xa57a <SD_write_multiple_blocks+0x264>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    a598:	10 92 ac 50 	sts	0x50AC, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a59c:	05 c0       	rjmp	.+10     	; 0xa5a8 <SD_write_multiple_blocks+0x292>
    a59e:	8f ef       	ldi	r24, 0xFF	; 255
    a5a0:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a5a4:	80 93 ac 50 	sts	0x50AC, r24
    a5a8:	80 91 ac 50 	lds	r24, 0x50AC
    a5ac:	8f 3f       	cpi	r24, 0xFF	; 255
    a5ae:	b9 f7       	brne	.-18     	; 0xa59e <SD_write_multiple_blocks+0x288>
	SPICS(FALSE);
    a5b0:	80 e0       	ldi	r24, 0x00	; 0
    a5b2:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	SPIDisable();
    a5b6:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a5ba:	88 e0       	ldi	r24, 0x08	; 8
    a5bc:	60 e0       	ldi	r22, 0x00	; 0
    a5be:	0e 94 05 36 	call	0x6c0a	; 0x6c0a <PortEx_OUTSET>
}
    a5c2:	6a 96       	adiw	r28, 0x1a	; 26
    a5c4:	cd bf       	out	0x3d, r28	; 61
    a5c6:	de bf       	out	0x3e, r29	; 62
    a5c8:	df 91       	pop	r29
    a5ca:	cf 91       	pop	r28
    a5cc:	1f 91       	pop	r17
    a5ce:	0f 91       	pop	r16
    a5d0:	08 95       	ret

0000a5d2 <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    a5d2:	0f 93       	push	r16
    a5d4:	1f 93       	push	r17
    a5d6:	cf 93       	push	r28
    a5d8:	df 93       	push	r29
    a5da:	cd b7       	in	r28, 0x3d	; 61
    a5dc:	de b7       	in	r29, 0x3e	; 62
    a5de:	2e 97       	sbiw	r28, 0x0e	; 14
    a5e0:	cd bf       	out	0x3d, r28	; 61
    a5e2:	de bf       	out	0x3e, r29	; 62
    a5e4:	6f 83       	std	Y+7, r22	; 0x07
    a5e6:	78 87       	std	Y+8, r23	; 0x08
    a5e8:	89 87       	std	Y+9, r24	; 0x09
    a5ea:	9a 87       	std	Y+10, r25	; 0x0a
    a5ec:	4b 87       	std	Y+11, r20	; 0x0b
    a5ee:	5c 87       	std	Y+12, r21	; 0x0c
    a5f0:	2d 87       	std	Y+13, r18	; 0x0d
    a5f2:	3e 87       	std	Y+14, r19	; 0x0e
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a5f4:	88 e0       	ldi	r24, 0x08	; 8
    a5f6:	60 e0       	ldi	r22, 0x00	; 0
    a5f8:	0e 94 68 36 	call	0x6cd0	; 0x6cd0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a5fc:	80 e0       	ldi	r24, 0x00	; 0
    a5fe:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
	SPICS(TRUE);
    a602:	81 e0       	ldi	r24, 0x01	; 1
    a604:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    a608:	00 00       	nop
    a60a:	2f 81       	ldd	r18, Y+7	; 0x07
    a60c:	38 85       	ldd	r19, Y+8	; 0x08
    a60e:	49 85       	ldd	r20, Y+9	; 0x09
    a610:	5a 85       	ldd	r21, Y+10	; 0x0a
    a612:	82 e1       	ldi	r24, 0x12	; 18
    a614:	ba 01       	movw	r22, r20
    a616:	a9 01       	movw	r20, r18
    a618:	2f ef       	ldi	r18, 0xFF	; 255
    a61a:	08 e0       	ldi	r16, 0x08	; 8
    a61c:	10 e0       	ldi	r17, 0x00	; 0
    a61e:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <SD_command>
    a622:	88 23       	and	r24, r24
    a624:	91 f7       	brne	.-28     	; 0xa60a <SD_read_multiple_blocks+0x38>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a626:	19 82       	std	Y+1, r1	; 0x01
    a628:	1a 82       	std	Y+2, r1	; 0x02
    a62a:	4b c0       	rjmp	.+150    	; 0xa6c2 <SD_read_multiple_blocks+0xf0>
		Buffer[1]=SDHC_DUMMY_BYTE;
    a62c:	8f ef       	ldi	r24, 0xFF	; 255
    a62e:	80 93 ac 50 	sts	0x50AC, r24
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a632:	05 c0       	rjmp	.+10     	; 0xa63e <SD_read_multiple_blocks+0x6c>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    a634:	8f ef       	ldi	r24, 0xFF	; 255
    a636:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a63a:	80 93 ac 50 	sts	0x50AC, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a63e:	80 91 ac 50 	lds	r24, 0x50AC
    a642:	8e 3f       	cpi	r24, 0xFE	; 254
    a644:	b9 f7       	brne	.-18     	; 0xa634 <SD_read_multiple_blocks+0x62>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a646:	1b 82       	std	Y+3, r1	; 0x03
    a648:	1c 82       	std	Y+4, r1	; 0x04
    a64a:	19 c0       	rjmp	.+50     	; 0xa67e <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a64c:	89 81       	ldd	r24, Y+1	; 0x01
    a64e:	9a 81       	ldd	r25, Y+2	; 0x02
    a650:	9c 01       	movw	r18, r24
    a652:	32 2f       	mov	r19, r18
    a654:	22 27       	eor	r18, r18
    a656:	33 0f       	add	r19, r19
    a658:	8b 81       	ldd	r24, Y+3	; 0x03
    a65a:	9c 81       	ldd	r25, Y+4	; 0x04
    a65c:	82 0f       	add	r24, r18
    a65e:	93 1f       	adc	r25, r19
    a660:	2b 85       	ldd	r18, Y+11	; 0x0b
    a662:	3c 85       	ldd	r19, Y+12	; 0x0c
    a664:	89 01       	movw	r16, r18
    a666:	08 0f       	add	r16, r24
    a668:	19 1f       	adc	r17, r25
    a66a:	8f ef       	ldi	r24, 0xFF	; 255
    a66c:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a670:	f8 01       	movw	r30, r16
    a672:	80 83       	st	Z, r24
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a674:	8b 81       	ldd	r24, Y+3	; 0x03
    a676:	9c 81       	ldd	r25, Y+4	; 0x04
    a678:	01 96       	adiw	r24, 0x01	; 1
    a67a:	8b 83       	std	Y+3, r24	; 0x03
    a67c:	9c 83       	std	Y+4, r25	; 0x04
    a67e:	8b 81       	ldd	r24, Y+3	; 0x03
    a680:	9c 81       	ldd	r25, Y+4	; 0x04
    a682:	f2 e0       	ldi	r31, 0x02	; 2
    a684:	80 30       	cpi	r24, 0x00	; 0
    a686:	9f 07       	cpc	r25, r31
    a688:	0c f3       	brlt	.-62     	; 0xa64c <SD_read_multiple_blocks+0x7a>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a68a:	1d 82       	std	Y+5, r1	; 0x05
    a68c:	1e 82       	std	Y+6, r1	; 0x06
    a68e:	0f c0       	rjmp	.+30     	; 0xa6ae <SD_read_multiple_blocks+0xdc>
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    a690:	8f ef       	ldi	r24, 0xFF	; 255
    a692:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a696:	28 2f       	mov	r18, r24
    a698:	8d 81       	ldd	r24, Y+5	; 0x05
    a69a:	9e 81       	ldd	r25, Y+6	; 0x06
    a69c:	85 55       	subi	r24, 0x55	; 85
    a69e:	9f 4a       	sbci	r25, 0xAF	; 175
    a6a0:	fc 01       	movw	r30, r24
    a6a2:	20 83       	st	Z, r18
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a6a4:	8d 81       	ldd	r24, Y+5	; 0x05
    a6a6:	9e 81       	ldd	r25, Y+6	; 0x06
    a6a8:	01 96       	adiw	r24, 0x01	; 1
    a6aa:	8d 83       	std	Y+5, r24	; 0x05
    a6ac:	9e 83       	std	Y+6, r25	; 0x06
    a6ae:	8d 81       	ldd	r24, Y+5	; 0x05
    a6b0:	9e 81       	ldd	r25, Y+6	; 0x06
    a6b2:	82 30       	cpi	r24, 0x02	; 2
    a6b4:	91 05       	cpc	r25, r1
    a6b6:	64 f3       	brlt	.-40     	; 0xa690 <SD_read_multiple_blocks+0xbe>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a6b8:	89 81       	ldd	r24, Y+1	; 0x01
    a6ba:	9a 81       	ldd	r25, Y+2	; 0x02
    a6bc:	01 96       	adiw	r24, 0x01	; 1
    a6be:	89 83       	std	Y+1, r24	; 0x01
    a6c0:	9a 83       	std	Y+2, r25	; 0x02
    a6c2:	29 81       	ldd	r18, Y+1	; 0x01
    a6c4:	3a 81       	ldd	r19, Y+2	; 0x02
    a6c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    a6c8:	9e 85       	ldd	r25, Y+14	; 0x0e
    a6ca:	28 17       	cp	r18, r24
    a6cc:	39 07       	cpc	r19, r25
    a6ce:	0c f4       	brge	.+2      	; 0xa6d2 <SD_read_multiple_blocks+0x100>
    a6d0:	ad cf       	rjmp	.-166    	; 0xa62c <SD_read_multiple_blocks+0x5a>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    a6d2:	8c e0       	ldi	r24, 0x0C	; 12
    a6d4:	40 e0       	ldi	r20, 0x00	; 0
    a6d6:	50 e0       	ldi	r21, 0x00	; 0
    a6d8:	ba 01       	movw	r22, r20
    a6da:	2f ef       	ldi	r18, 0xFF	; 255
    a6dc:	08 e0       	ldi	r16, 0x08	; 8
    a6de:	10 e0       	ldi	r17, 0x00	; 0
    a6e0:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    a6e4:	8f ef       	ldi	r24, 0xFF	; 255
    a6e6:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a6ea:	80 93 ab 50 	sts	0x50AB, r24
	Buffer[1] = FILLER_BYTE;
    a6ee:	10 92 ac 50 	sts	0x50AC, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a6f2:	05 c0       	rjmp	.+10     	; 0xa6fe <SD_read_multiple_blocks+0x12c>
    a6f4:	8f ef       	ldi	r24, 0xFF	; 255
    a6f6:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
    a6fa:	80 93 ac 50 	sts	0x50AC, r24
    a6fe:	80 91 ac 50 	lds	r24, 0x50AC
    a702:	8f 3f       	cpi	r24, 0xFF	; 255
    a704:	b9 f7       	brne	.-18     	; 0xa6f4 <SD_read_multiple_blocks+0x122>
	SPICS(FALSE);
    a706:	80 e0       	ldi	r24, 0x00	; 0
    a708:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	SPIDisable();
    a70c:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a710:	88 e0       	ldi	r24, 0x08	; 8
    a712:	60 e0       	ldi	r22, 0x00	; 0
    a714:	0e 94 05 36 	call	0x6c0a	; 0x6c0a <PortEx_OUTSET>
}
    a718:	2e 96       	adiw	r28, 0x0e	; 14
    a71a:	cd bf       	out	0x3d, r28	; 61
    a71c:	de bf       	out	0x3e, r29	; 62
    a71e:	df 91       	pop	r29
    a720:	cf 91       	pop	r28
    a722:	1f 91       	pop	r17
    a724:	0f 91       	pop	r16
    a726:	08 95       	ret

0000a728 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
    a728:	cf 93       	push	r28
    a72a:	df 93       	push	r29
    a72c:	cd b7       	in	r28, 0x3d	; 61
    a72e:	de b7       	in	r29, 0x3e	; 62
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    a730:	88 e0       	ldi	r24, 0x08	; 8
    a732:	60 e0       	ldi	r22, 0x00	; 0
    a734:	0e 94 39 35 	call	0x6a72	; 0x6a72 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    a738:	88 e0       	ldi	r24, 0x08	; 8
    a73a:	60 e0       	ldi	r22, 0x00	; 0
    a73c:	0e 94 05 36 	call	0x6c0a	; 0x6c0a <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    a740:	80 e0       	ldi	r24, 0x00	; 0
    a742:	0e 94 d5 39 	call	0x73aa	; 0x73aa <SPIInit>
	SPICS(TRUE);
    a746:	81 e0       	ldi	r24, 0x01	; 1
    a748:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    a74c:	8f ef       	ldi	r24, 0xFF	; 255
    a74e:	0e 94 ab 4f 	call	0x9f56	; 0x9f56 <SPI_write>
	SPICS(FALSE);	//stop spi
    a752:	80 e0       	ldi	r24, 0x00	; 0
    a754:	0e 94 2a 3a 	call	0x7454	; 0x7454 <SPICS>
	SPIDisable();
    a758:	0e 94 42 3a 	call	0x7484	; 0x7484 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    a75c:	80 e0       	ldi	r24, 0x00	; 0
    a75e:	0e 94 0f 06 	call	0xc1e	; 0xc1e <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    a762:	80 e0       	ldi	r24, 0x00	; 0
    a764:	0e 94 cf 36 	call	0x6d9e	; 0x6d9e <Ext1Power>
}
    a768:	df 91       	pop	r29
    a76a:	cf 91       	pop	r28
    a76c:	08 95       	ret

0000a76e <__muldi3>:
    a76e:	a0 e3       	ldi	r26, 0x30	; 48
    a770:	b0 e0       	ldi	r27, 0x00	; 0
    a772:	ed eb       	ldi	r30, 0xBD	; 189
    a774:	f3 e5       	ldi	r31, 0x53	; 83
    a776:	0c 94 1b 5f 	jmp	0xbe36	; 0xbe36 <__prologue_saves__+0x4>
    a77a:	29 8f       	std	Y+25, r18	; 0x19
    a77c:	3a 8f       	std	Y+26, r19	; 0x1a
    a77e:	4b 8f       	std	Y+27, r20	; 0x1b
    a780:	5c 8f       	std	Y+28, r21	; 0x1c
    a782:	6d 8f       	std	Y+29, r22	; 0x1d
    a784:	7e 8f       	std	Y+30, r23	; 0x1e
    a786:	8f 8f       	std	Y+31, r24	; 0x1f
    a788:	98 a3       	lds	r25, 0x58
    a78a:	a9 8a       	std	Y+17, r10	; 0x11
    a78c:	ba 8a       	std	Y+18, r11	; 0x12
    a78e:	cb 8a       	std	Y+19, r12	; 0x13
    a790:	dc 8a       	std	Y+20, r13	; 0x14
    a792:	ed 8a       	std	Y+21, r14	; 0x15
    a794:	fe 8a       	std	Y+22, r15	; 0x16
    a796:	0f 8b       	std	Y+23, r16	; 0x17
    a798:	18 8f       	std	Y+24, r17	; 0x18
    a79a:	09 8d       	ldd	r16, Y+25	; 0x19
    a79c:	1a 8d       	ldd	r17, Y+26	; 0x1a
    a79e:	2b 8d       	ldd	r18, Y+27	; 0x1b
    a7a0:	3c 8d       	ldd	r19, Y+28	; 0x1c
    a7a2:	09 a3       	lds	r16, 0x59
    a7a4:	1a a3       	lds	r17, 0x5a
    a7a6:	2b a3       	lds	r18, 0x5b
    a7a8:	3c a3       	lds	r19, 0x5c
    a7aa:	68 01       	movw	r12, r16
    a7ac:	79 01       	movw	r14, r18
    a7ae:	8f ef       	ldi	r24, 0xFF	; 255
    a7b0:	9f ef       	ldi	r25, 0xFF	; 255
    a7b2:	a0 e0       	ldi	r26, 0x00	; 0
    a7b4:	b0 e0       	ldi	r27, 0x00	; 0
    a7b6:	c8 22       	and	r12, r24
    a7b8:	d9 22       	and	r13, r25
    a7ba:	ea 22       	and	r14, r26
    a7bc:	fb 22       	and	r15, r27
    a7be:	89 01       	movw	r16, r18
    a7c0:	22 27       	eor	r18, r18
    a7c2:	33 27       	eor	r19, r19
    a7c4:	09 a7       	lds	r16, 0x79
    a7c6:	1a a7       	lds	r17, 0x7a
    a7c8:	2b a7       	lds	r18, 0x7b
    a7ca:	3c a7       	lds	r19, 0x7c
    a7cc:	09 89       	ldd	r16, Y+17	; 0x11
    a7ce:	1a 89       	ldd	r17, Y+18	; 0x12
    a7d0:	2b 89       	ldd	r18, Y+19	; 0x13
    a7d2:	3c 89       	ldd	r19, Y+20	; 0x14
    a7d4:	0d a3       	lds	r16, 0x5d
    a7d6:	1e a3       	lds	r17, 0x5e
    a7d8:	2f a3       	lds	r18, 0x5f
    a7da:	38 a7       	lds	r19, 0x78
    a7dc:	48 01       	movw	r8, r16
    a7de:	59 01       	movw	r10, r18
    a7e0:	88 22       	and	r8, r24
    a7e2:	99 22       	and	r9, r25
    a7e4:	aa 22       	and	r10, r26
    a7e6:	bb 22       	and	r11, r27
    a7e8:	29 01       	movw	r4, r18
    a7ea:	66 24       	eor	r6, r6
    a7ec:	77 24       	eor	r7, r7
    a7ee:	c5 01       	movw	r24, r10
    a7f0:	b4 01       	movw	r22, r8
    a7f2:	a7 01       	movw	r20, r14
    a7f4:	96 01       	movw	r18, r12
    a7f6:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    a7fa:	6d a7       	lds	r22, 0x7d
    a7fc:	7e a7       	lds	r23, 0x7e
    a7fe:	8f a7       	lds	r24, 0x7f
    a800:	98 ab       	sts	0x58, r25
    a802:	c3 01       	movw	r24, r6
    a804:	b2 01       	movw	r22, r4
    a806:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    a80a:	6b 01       	movw	r12, r22
    a80c:	7c 01       	movw	r14, r24
    a80e:	c5 01       	movw	r24, r10
    a810:	b4 01       	movw	r22, r8
    a812:	29 a5       	lds	r18, 0x69
    a814:	3a a5       	lds	r19, 0x6a
    a816:	4b a5       	lds	r20, 0x6b
    a818:	5c a5       	lds	r21, 0x6c
    a81a:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    a81e:	4b 01       	movw	r8, r22
    a820:	5c 01       	movw	r10, r24
    a822:	c3 01       	movw	r24, r6
    a824:	b2 01       	movw	r22, r4
    a826:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    a82a:	ab 01       	movw	r20, r22
    a82c:	bc 01       	movw	r22, r24
    a82e:	c8 0c       	add	r12, r8
    a830:	d9 1c       	adc	r13, r9
    a832:	ea 1c       	adc	r14, r10
    a834:	fb 1c       	adc	r15, r11
    a836:	0d a5       	lds	r16, 0x6d
    a838:	1e a5       	lds	r17, 0x6e
    a83a:	2f a5       	lds	r18, 0x6f
    a83c:	38 a9       	sts	0x48, r19
    a83e:	c9 01       	movw	r24, r18
    a840:	aa 27       	eor	r26, r26
    a842:	bb 27       	eor	r27, r27
    a844:	c8 0e       	add	r12, r24
    a846:	d9 1e       	adc	r13, r25
    a848:	ea 1e       	adc	r14, r26
    a84a:	fb 1e       	adc	r15, r27
    a84c:	c8 14       	cp	r12, r8
    a84e:	d9 04       	cpc	r13, r9
    a850:	ea 04       	cpc	r14, r10
    a852:	fb 04       	cpc	r15, r11
    a854:	20 f4       	brcc	.+8      	; 0xa85e <__muldi3+0xf0>
    a856:	40 50       	subi	r20, 0x00	; 0
    a858:	50 40       	sbci	r21, 0x00	; 0
    a85a:	6f 4f       	sbci	r22, 0xFF	; 255
    a85c:	7f 4f       	sbci	r23, 0xFF	; 255
    a85e:	c7 01       	movw	r24, r14
    a860:	aa 27       	eor	r26, r26
    a862:	bb 27       	eor	r27, r27
    a864:	84 0f       	add	r24, r20
    a866:	95 1f       	adc	r25, r21
    a868:	a6 1f       	adc	r26, r22
    a86a:	b7 1f       	adc	r27, r23
    a86c:	8d 83       	std	Y+5, r24	; 0x05
    a86e:	9e 83       	std	Y+6, r25	; 0x06
    a870:	af 83       	std	Y+7, r26	; 0x07
    a872:	b8 87       	std	Y+8, r27	; 0x08
    a874:	76 01       	movw	r14, r12
    a876:	dd 24       	eor	r13, r13
    a878:	cc 24       	eor	r12, r12
    a87a:	4d a5       	lds	r20, 0x6d
    a87c:	5e a5       	lds	r21, 0x6e
    a87e:	6f a5       	lds	r22, 0x6f
    a880:	78 a9       	sts	0x48, r23
    a882:	60 70       	andi	r22, 0x00	; 0
    a884:	70 70       	andi	r23, 0x00	; 0
    a886:	c4 0e       	add	r12, r20
    a888:	d5 1e       	adc	r13, r21
    a88a:	e6 1e       	adc	r14, r22
    a88c:	f7 1e       	adc	r15, r23
    a88e:	c9 82       	std	Y+1, r12	; 0x01
    a890:	da 82       	std	Y+2, r13	; 0x02
    a892:	eb 82       	std	Y+3, r14	; 0x03
    a894:	fc 82       	std	Y+4, r15	; 0x04
    a896:	1c 2d       	mov	r17, r12
    a898:	0a 81       	ldd	r16, Y+2	; 0x02
    a89a:	8b 80       	ldd	r8, Y+3	; 0x03
    a89c:	4c 80       	ldd	r4, Y+4	; 0x04
    a89e:	8d 87       	std	Y+13, r24	; 0x0d
    a8a0:	8e 81       	ldd	r24, Y+6	; 0x06
    a8a2:	8e 87       	std	Y+14, r24	; 0x0e
    a8a4:	8f 81       	ldd	r24, Y+7	; 0x07
    a8a6:	8f 87       	std	Y+15, r24	; 0x0f
    a8a8:	88 85       	ldd	r24, Y+8	; 0x08
    a8aa:	88 8b       	std	Y+16, r24	; 0x10
    a8ac:	2d 89       	ldd	r18, Y+21	; 0x15
    a8ae:	3e 89       	ldd	r19, Y+22	; 0x16
    a8b0:	4f 89       	ldd	r20, Y+23	; 0x17
    a8b2:	58 8d       	ldd	r21, Y+24	; 0x18
    a8b4:	69 a1       	lds	r22, 0x49
    a8b6:	7a a1       	lds	r23, 0x4a
    a8b8:	8b a1       	lds	r24, 0x4b
    a8ba:	9c a1       	lds	r25, 0x4c
    a8bc:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    a8c0:	6b 01       	movw	r12, r22
    a8c2:	7c 01       	movw	r14, r24
    a8c4:	2d 8d       	ldd	r18, Y+29	; 0x1d
    a8c6:	3e 8d       	ldd	r19, Y+30	; 0x1e
    a8c8:	4f 8d       	ldd	r20, Y+31	; 0x1f
    a8ca:	58 a1       	lds	r21, 0x48
    a8cc:	6d a1       	lds	r22, 0x4d
    a8ce:	7e a1       	lds	r23, 0x4e
    a8d0:	8f a1       	lds	r24, 0x4f
    a8d2:	98 a5       	lds	r25, 0x68
    a8d4:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    a8d8:	dc 01       	movw	r26, r24
    a8da:	cb 01       	movw	r24, r22
    a8dc:	c8 0e       	add	r12, r24
    a8de:	d9 1e       	adc	r13, r25
    a8e0:	ea 1e       	adc	r14, r26
    a8e2:	fb 1e       	adc	r15, r27
    a8e4:	8d 85       	ldd	r24, Y+13	; 0x0d
    a8e6:	9e 85       	ldd	r25, Y+14	; 0x0e
    a8e8:	af 85       	ldd	r26, Y+15	; 0x0f
    a8ea:	b8 89       	ldd	r27, Y+16	; 0x10
    a8ec:	8c 0d       	add	r24, r12
    a8ee:	9d 1d       	adc	r25, r13
    a8f0:	ae 1d       	adc	r26, r14
    a8f2:	bf 1d       	adc	r27, r15
    a8f4:	8d 87       	std	Y+13, r24	; 0x0d
    a8f6:	9e 87       	std	Y+14, r25	; 0x0e
    a8f8:	af 87       	std	Y+15, r26	; 0x0f
    a8fa:	b8 8b       	std	Y+16, r27	; 0x10
    a8fc:	68 2f       	mov	r22, r24
    a8fe:	7e 85       	ldd	r23, Y+14	; 0x0e
    a900:	21 2f       	mov	r18, r17
    a902:	30 2f       	mov	r19, r16
    a904:	48 2d       	mov	r20, r8
    a906:	54 2d       	mov	r21, r4
    a908:	8f 85       	ldd	r24, Y+15	; 0x0f
    a90a:	98 89       	ldd	r25, Y+16	; 0x10
    a90c:	e0 96       	adiw	r28, 0x30	; 48
    a90e:	e0 e1       	ldi	r30, 0x10	; 16
    a910:	0c 94 34 5f 	jmp	0xbe68	; 0xbe68 <__epilogue_restores__+0x4>

0000a914 <__ashldi3>:
    a914:	cf 92       	push	r12
    a916:	df 92       	push	r13
    a918:	ef 92       	push	r14
    a91a:	ff 92       	push	r15
    a91c:	0f 93       	push	r16
    a91e:	cf 93       	push	r28
    a920:	df 93       	push	r29
    a922:	cd b7       	in	r28, 0x3d	; 61
    a924:	de b7       	in	r29, 0x3e	; 62
    a926:	60 97       	sbiw	r28, 0x10	; 16
    a928:	cd bf       	out	0x3d, r28	; 61
    a92a:	de bf       	out	0x3e, r29	; 62
    a92c:	00 23       	and	r16, r16
    a92e:	09 f4       	brne	.+2      	; 0xa932 <__ashldi3+0x1e>
    a930:	5a c0       	rjmp	.+180    	; 0xa9e6 <__ashldi3+0xd2>
    a932:	29 87       	std	Y+9, r18	; 0x09
    a934:	3a 87       	std	Y+10, r19	; 0x0a
    a936:	4b 87       	std	Y+11, r20	; 0x0b
    a938:	5c 87       	std	Y+12, r21	; 0x0c
    a93a:	6d 87       	std	Y+13, r22	; 0x0d
    a93c:	7e 87       	std	Y+14, r23	; 0x0e
    a93e:	8f 87       	std	Y+15, r24	; 0x0f
    a940:	98 8b       	std	Y+16, r25	; 0x10
    a942:	80 e2       	ldi	r24, 0x20	; 32
    a944:	80 1b       	sub	r24, r16
    a946:	49 85       	ldd	r20, Y+9	; 0x09
    a948:	5a 85       	ldd	r21, Y+10	; 0x0a
    a94a:	6b 85       	ldd	r22, Y+11	; 0x0b
    a94c:	7c 85       	ldd	r23, Y+12	; 0x0c
    a94e:	18 16       	cp	r1, r24
    a950:	b4 f0       	brlt	.+44     	; 0xa97e <__ashldi3+0x6a>
    a952:	19 82       	std	Y+1, r1	; 0x01
    a954:	1a 82       	std	Y+2, r1	; 0x02
    a956:	1b 82       	std	Y+3, r1	; 0x03
    a958:	1c 82       	std	Y+4, r1	; 0x04
    a95a:	99 27       	eor	r25, r25
    a95c:	87 fd       	sbrc	r24, 7
    a95e:	90 95       	com	r25
    a960:	90 95       	com	r25
    a962:	81 95       	neg	r24
    a964:	9f 4f       	sbci	r25, 0xFF	; 255
    a966:	04 c0       	rjmp	.+8      	; 0xa970 <__ashldi3+0x5c>
    a968:	44 0f       	add	r20, r20
    a96a:	55 1f       	adc	r21, r21
    a96c:	66 1f       	adc	r22, r22
    a96e:	77 1f       	adc	r23, r23
    a970:	8a 95       	dec	r24
    a972:	d2 f7       	brpl	.-12     	; 0xa968 <__ashldi3+0x54>
    a974:	4d 83       	std	Y+5, r20	; 0x05
    a976:	5e 83       	std	Y+6, r21	; 0x06
    a978:	6f 83       	std	Y+7, r22	; 0x07
    a97a:	78 87       	std	Y+8, r23	; 0x08
    a97c:	2c c0       	rjmp	.+88     	; 0xa9d6 <__ashldi3+0xc2>
    a97e:	6a 01       	movw	r12, r20
    a980:	7b 01       	movw	r14, r22
    a982:	00 2e       	mov	r0, r16
    a984:	04 c0       	rjmp	.+8      	; 0xa98e <__ashldi3+0x7a>
    a986:	cc 0c       	add	r12, r12
    a988:	dd 1c       	adc	r13, r13
    a98a:	ee 1c       	adc	r14, r14
    a98c:	ff 1c       	adc	r15, r15
    a98e:	0a 94       	dec	r0
    a990:	d2 f7       	brpl	.-12     	; 0xa986 <__ashldi3+0x72>
    a992:	c9 82       	std	Y+1, r12	; 0x01
    a994:	da 82       	std	Y+2, r13	; 0x02
    a996:	eb 82       	std	Y+3, r14	; 0x03
    a998:	fc 82       	std	Y+4, r15	; 0x04
    a99a:	6a 01       	movw	r12, r20
    a99c:	7b 01       	movw	r14, r22
    a99e:	04 c0       	rjmp	.+8      	; 0xa9a8 <__ashldi3+0x94>
    a9a0:	f6 94       	lsr	r15
    a9a2:	e7 94       	ror	r14
    a9a4:	d7 94       	ror	r13
    a9a6:	c7 94       	ror	r12
    a9a8:	8a 95       	dec	r24
    a9aa:	d2 f7       	brpl	.-12     	; 0xa9a0 <__ashldi3+0x8c>
    a9ac:	d7 01       	movw	r26, r14
    a9ae:	c6 01       	movw	r24, r12
    a9b0:	4d 85       	ldd	r20, Y+13	; 0x0d
    a9b2:	5e 85       	ldd	r21, Y+14	; 0x0e
    a9b4:	6f 85       	ldd	r22, Y+15	; 0x0f
    a9b6:	78 89       	ldd	r23, Y+16	; 0x10
    a9b8:	04 c0       	rjmp	.+8      	; 0xa9c2 <__ashldi3+0xae>
    a9ba:	44 0f       	add	r20, r20
    a9bc:	55 1f       	adc	r21, r21
    a9be:	66 1f       	adc	r22, r22
    a9c0:	77 1f       	adc	r23, r23
    a9c2:	0a 95       	dec	r16
    a9c4:	d2 f7       	brpl	.-12     	; 0xa9ba <__ashldi3+0xa6>
    a9c6:	84 2b       	or	r24, r20
    a9c8:	95 2b       	or	r25, r21
    a9ca:	a6 2b       	or	r26, r22
    a9cc:	b7 2b       	or	r27, r23
    a9ce:	8d 83       	std	Y+5, r24	; 0x05
    a9d0:	9e 83       	std	Y+6, r25	; 0x06
    a9d2:	af 83       	std	Y+7, r26	; 0x07
    a9d4:	b8 87       	std	Y+8, r27	; 0x08
    a9d6:	29 81       	ldd	r18, Y+1	; 0x01
    a9d8:	3a 81       	ldd	r19, Y+2	; 0x02
    a9da:	4b 81       	ldd	r20, Y+3	; 0x03
    a9dc:	5c 81       	ldd	r21, Y+4	; 0x04
    a9de:	6d 81       	ldd	r22, Y+5	; 0x05
    a9e0:	7e 81       	ldd	r23, Y+6	; 0x06
    a9e2:	8f 81       	ldd	r24, Y+7	; 0x07
    a9e4:	98 85       	ldd	r25, Y+8	; 0x08
    a9e6:	60 96       	adiw	r28, 0x10	; 16
    a9e8:	cd bf       	out	0x3d, r28	; 61
    a9ea:	de bf       	out	0x3e, r29	; 62
    a9ec:	df 91       	pop	r29
    a9ee:	cf 91       	pop	r28
    a9f0:	0f 91       	pop	r16
    a9f2:	ff 90       	pop	r15
    a9f4:	ef 90       	pop	r14
    a9f6:	df 90       	pop	r13
    a9f8:	cf 90       	pop	r12
    a9fa:	08 95       	ret

0000a9fc <__ashrdi3>:
    a9fc:	0f 93       	push	r16
    a9fe:	cf 93       	push	r28
    aa00:	df 93       	push	r29
    aa02:	cd b7       	in	r28, 0x3d	; 61
    aa04:	de b7       	in	r29, 0x3e	; 62
    aa06:	60 97       	sbiw	r28, 0x10	; 16
    aa08:	cd bf       	out	0x3d, r28	; 61
    aa0a:	de bf       	out	0x3e, r29	; 62
    aa0c:	00 23       	and	r16, r16
    aa0e:	09 f4       	brne	.+2      	; 0xaa12 <__ashrdi3+0x16>
    aa10:	56 c0       	rjmp	.+172    	; 0xaabe <__ashrdi3+0xc2>
    aa12:	29 87       	std	Y+9, r18	; 0x09
    aa14:	3a 87       	std	Y+10, r19	; 0x0a
    aa16:	4b 87       	std	Y+11, r20	; 0x0b
    aa18:	5c 87       	std	Y+12, r21	; 0x0c
    aa1a:	6d 87       	std	Y+13, r22	; 0x0d
    aa1c:	7e 87       	std	Y+14, r23	; 0x0e
    aa1e:	8f 87       	std	Y+15, r24	; 0x0f
    aa20:	98 8b       	std	Y+16, r25	; 0x10
    aa22:	20 e2       	ldi	r18, 0x20	; 32
    aa24:	20 1b       	sub	r18, r16
    aa26:	8d 85       	ldd	r24, Y+13	; 0x0d
    aa28:	9e 85       	ldd	r25, Y+14	; 0x0e
    aa2a:	af 85       	ldd	r26, Y+15	; 0x0f
    aa2c:	b8 89       	ldd	r27, Y+16	; 0x10
    aa2e:	ac 01       	movw	r20, r24
    aa30:	bd 01       	movw	r22, r26
    aa32:	12 16       	cp	r1, r18
    aa34:	b4 f0       	brlt	.+44     	; 0xaa62 <__ashrdi3+0x66>
    aa36:	77 0f       	add	r23, r23
    aa38:	44 0b       	sbc	r20, r20
    aa3a:	54 2f       	mov	r21, r20
    aa3c:	ba 01       	movw	r22, r20
    aa3e:	4d 83       	std	Y+5, r20	; 0x05
    aa40:	5e 83       	std	Y+6, r21	; 0x06
    aa42:	6f 83       	std	Y+7, r22	; 0x07
    aa44:	78 87       	std	Y+8, r23	; 0x08
    aa46:	33 27       	eor	r19, r19
    aa48:	27 fd       	sbrc	r18, 7
    aa4a:	30 95       	com	r19
    aa4c:	30 95       	com	r19
    aa4e:	21 95       	neg	r18
    aa50:	3f 4f       	sbci	r19, 0xFF	; 255
    aa52:	04 c0       	rjmp	.+8      	; 0xaa5c <__ashrdi3+0x60>
    aa54:	b5 95       	asr	r27
    aa56:	a7 95       	ror	r26
    aa58:	97 95       	ror	r25
    aa5a:	87 95       	ror	r24
    aa5c:	2a 95       	dec	r18
    aa5e:	d2 f7       	brpl	.-12     	; 0xaa54 <__ashrdi3+0x58>
    aa60:	22 c0       	rjmp	.+68     	; 0xaaa6 <__ashrdi3+0xaa>
    aa62:	00 2e       	mov	r0, r16
    aa64:	04 c0       	rjmp	.+8      	; 0xaa6e <__ashrdi3+0x72>
    aa66:	75 95       	asr	r23
    aa68:	67 95       	ror	r22
    aa6a:	57 95       	ror	r21
    aa6c:	47 95       	ror	r20
    aa6e:	0a 94       	dec	r0
    aa70:	d2 f7       	brpl	.-12     	; 0xaa66 <__ashrdi3+0x6a>
    aa72:	4d 83       	std	Y+5, r20	; 0x05
    aa74:	5e 83       	std	Y+6, r21	; 0x06
    aa76:	6f 83       	std	Y+7, r22	; 0x07
    aa78:	78 87       	std	Y+8, r23	; 0x08
    aa7a:	04 c0       	rjmp	.+8      	; 0xaa84 <__ashrdi3+0x88>
    aa7c:	88 0f       	add	r24, r24
    aa7e:	99 1f       	adc	r25, r25
    aa80:	aa 1f       	adc	r26, r26
    aa82:	bb 1f       	adc	r27, r27
    aa84:	2a 95       	dec	r18
    aa86:	d2 f7       	brpl	.-12     	; 0xaa7c <__ashrdi3+0x80>
    aa88:	49 85       	ldd	r20, Y+9	; 0x09
    aa8a:	5a 85       	ldd	r21, Y+10	; 0x0a
    aa8c:	6b 85       	ldd	r22, Y+11	; 0x0b
    aa8e:	7c 85       	ldd	r23, Y+12	; 0x0c
    aa90:	04 c0       	rjmp	.+8      	; 0xaa9a <__ashrdi3+0x9e>
    aa92:	76 95       	lsr	r23
    aa94:	67 95       	ror	r22
    aa96:	57 95       	ror	r21
    aa98:	47 95       	ror	r20
    aa9a:	0a 95       	dec	r16
    aa9c:	d2 f7       	brpl	.-12     	; 0xaa92 <__ashrdi3+0x96>
    aa9e:	84 2b       	or	r24, r20
    aaa0:	95 2b       	or	r25, r21
    aaa2:	a6 2b       	or	r26, r22
    aaa4:	b7 2b       	or	r27, r23
    aaa6:	89 83       	std	Y+1, r24	; 0x01
    aaa8:	9a 83       	std	Y+2, r25	; 0x02
    aaaa:	ab 83       	std	Y+3, r26	; 0x03
    aaac:	bc 83       	std	Y+4, r27	; 0x04
    aaae:	29 81       	ldd	r18, Y+1	; 0x01
    aab0:	3a 81       	ldd	r19, Y+2	; 0x02
    aab2:	4b 81       	ldd	r20, Y+3	; 0x03
    aab4:	5c 81       	ldd	r21, Y+4	; 0x04
    aab6:	6d 81       	ldd	r22, Y+5	; 0x05
    aab8:	7e 81       	ldd	r23, Y+6	; 0x06
    aaba:	8f 81       	ldd	r24, Y+7	; 0x07
    aabc:	98 85       	ldd	r25, Y+8	; 0x08
    aabe:	60 96       	adiw	r28, 0x10	; 16
    aac0:	cd bf       	out	0x3d, r28	; 61
    aac2:	de bf       	out	0x3e, r29	; 62
    aac4:	df 91       	pop	r29
    aac6:	cf 91       	pop	r28
    aac8:	0f 91       	pop	r16
    aaca:	08 95       	ret

0000aacc <__divdi3>:
    aacc:	a8 e4       	ldi	r26, 0x48	; 72
    aace:	b0 e0       	ldi	r27, 0x00	; 0
    aad0:	ec e6       	ldi	r30, 0x6C	; 108
    aad2:	f5 e5       	ldi	r31, 0x55	; 85
    aad4:	0c 94 1a 5f 	jmp	0xbe34	; 0xbe34 <__prologue_saves__+0x2>
    aad8:	f5 01       	movw	r30, r10
    aada:	29 a3       	lds	r18, 0x59
    aadc:	3a a3       	lds	r19, 0x5a
    aade:	4b a3       	lds	r20, 0x5b
    aae0:	5c a3       	lds	r21, 0x5c
    aae2:	6d a3       	lds	r22, 0x5d
    aae4:	7e a3       	lds	r23, 0x5e
    aae6:	8f a3       	lds	r24, 0x5f
    aae8:	98 a7       	lds	r25, 0x78
    aaea:	a9 8e       	std	Y+25, r10	; 0x19
    aaec:	fa 8f       	std	Y+26, r31	; 0x1a
    aaee:	cb 8e       	std	Y+27, r12	; 0x1b
    aaf0:	dc 8e       	std	Y+28, r13	; 0x1c
    aaf2:	ed 8e       	std	Y+29, r14	; 0x1d
    aaf4:	fe 8e       	std	Y+30, r15	; 0x1e
    aaf6:	0f 8f       	std	Y+31, r16	; 0x1f
    aaf8:	18 a3       	lds	r17, 0x58
    aafa:	8d a0       	lds	r24, 0x8d
    aafc:	9e a0       	lds	r25, 0x8e
    aafe:	af a0       	lds	r26, 0x8f
    ab00:	b8 a4       	lds	r27, 0xa8
    ab02:	b7 fe       	sbrs	r11, 7
    ab04:	67 c0       	rjmp	.+206    	; 0xabd4 <__divdi3+0x108>
    ab06:	21 95       	neg	r18
    ab08:	b1 e0       	ldi	r27, 0x01	; 1
    ab0a:	12 16       	cp	r1, r18
    ab0c:	08 f0       	brcs	.+2      	; 0xab10 <__divdi3+0x44>
    ab0e:	b0 e0       	ldi	r27, 0x00	; 0
    ab10:	31 95       	neg	r19
    ab12:	a1 e0       	ldi	r26, 0x01	; 1
    ab14:	13 16       	cp	r1, r19
    ab16:	08 f0       	brcs	.+2      	; 0xab1a <__divdi3+0x4e>
    ab18:	a0 e0       	ldi	r26, 0x00	; 0
    ab1a:	b3 2e       	mov	r11, r19
    ab1c:	bb 1a       	sub	r11, r27
    ab1e:	bb 2d       	mov	r27, r11
    ab20:	88 24       	eor	r8, r8
    ab22:	83 94       	inc	r8
    ab24:	3b 15       	cp	r19, r11
    ab26:	08 f0       	brcs	.+2      	; 0xab2a <__divdi3+0x5e>
    ab28:	88 24       	eor	r8, r8
    ab2a:	a8 29       	or	r26, r8
    ab2c:	41 95       	neg	r20
    ab2e:	31 e0       	ldi	r19, 0x01	; 1
    ab30:	14 16       	cp	r1, r20
    ab32:	08 f0       	brcs	.+2      	; 0xab36 <__divdi3+0x6a>
    ab34:	30 e0       	ldi	r19, 0x00	; 0
    ab36:	b4 2e       	mov	r11, r20
    ab38:	ba 1a       	sub	r11, r26
    ab3a:	ab 2d       	mov	r26, r11
    ab3c:	88 24       	eor	r8, r8
    ab3e:	83 94       	inc	r8
    ab40:	4b 15       	cp	r20, r11
    ab42:	08 f0       	brcs	.+2      	; 0xab46 <__divdi3+0x7a>
    ab44:	88 24       	eor	r8, r8
    ab46:	38 29       	or	r19, r8
    ab48:	51 95       	neg	r21
    ab4a:	41 e0       	ldi	r20, 0x01	; 1
    ab4c:	15 16       	cp	r1, r21
    ab4e:	08 f0       	brcs	.+2      	; 0xab52 <__divdi3+0x86>
    ab50:	40 e0       	ldi	r20, 0x00	; 0
    ab52:	45 2e       	mov	r4, r21
    ab54:	43 1a       	sub	r4, r19
    ab56:	31 e0       	ldi	r19, 0x01	; 1
    ab58:	54 15       	cp	r21, r4
    ab5a:	08 f0       	brcs	.+2      	; 0xab5e <__divdi3+0x92>
    ab5c:	30 e0       	ldi	r19, 0x00	; 0
    ab5e:	43 2b       	or	r20, r19
    ab60:	61 95       	neg	r22
    ab62:	31 e0       	ldi	r19, 0x01	; 1
    ab64:	16 16       	cp	r1, r22
    ab66:	08 f0       	brcs	.+2      	; 0xab6a <__divdi3+0x9e>
    ab68:	30 e0       	ldi	r19, 0x00	; 0
    ab6a:	86 2e       	mov	r8, r22
    ab6c:	84 1a       	sub	r8, r20
    ab6e:	41 e0       	ldi	r20, 0x01	; 1
    ab70:	68 15       	cp	r22, r8
    ab72:	08 f0       	brcs	.+2      	; 0xab76 <__divdi3+0xaa>
    ab74:	40 e0       	ldi	r20, 0x00	; 0
    ab76:	34 2b       	or	r19, r20
    ab78:	71 95       	neg	r23
    ab7a:	41 e0       	ldi	r20, 0x01	; 1
    ab7c:	17 16       	cp	r1, r23
    ab7e:	08 f0       	brcs	.+2      	; 0xab82 <__divdi3+0xb6>
    ab80:	40 e0       	ldi	r20, 0x00	; 0
    ab82:	57 2f       	mov	r21, r23
    ab84:	53 1b       	sub	r21, r19
    ab86:	31 e0       	ldi	r19, 0x01	; 1
    ab88:	75 17       	cp	r23, r21
    ab8a:	08 f0       	brcs	.+2      	; 0xab8e <__divdi3+0xc2>
    ab8c:	30 e0       	ldi	r19, 0x00	; 0
    ab8e:	43 2b       	or	r20, r19
    ab90:	81 95       	neg	r24
    ab92:	31 e0       	ldi	r19, 0x01	; 1
    ab94:	18 16       	cp	r1, r24
    ab96:	08 f0       	brcs	.+2      	; 0xab9a <__divdi3+0xce>
    ab98:	30 e0       	ldi	r19, 0x00	; 0
    ab9a:	68 2f       	mov	r22, r24
    ab9c:	64 1b       	sub	r22, r20
    ab9e:	46 2f       	mov	r20, r22
    aba0:	61 e0       	ldi	r22, 0x01	; 1
    aba2:	84 17       	cp	r24, r20
    aba4:	08 f0       	brcs	.+2      	; 0xaba8 <__divdi3+0xdc>
    aba6:	60 e0       	ldi	r22, 0x00	; 0
    aba8:	36 2b       	or	r19, r22
    abaa:	91 95       	neg	r25
    abac:	93 1b       	sub	r25, r19
    abae:	29 a3       	lds	r18, 0x59
    abb0:	ba a3       	lds	r27, 0x5a
    abb2:	ab a3       	lds	r26, 0x5b
    abb4:	4c a2       	lds	r20, 0x9c
    abb6:	8d a2       	lds	r24, 0x9d
    abb8:	5e a3       	lds	r21, 0x5e
    abba:	4f a3       	lds	r20, 0x5f
    abbc:	98 a7       	lds	r25, 0x78
    abbe:	8f ef       	ldi	r24, 0xFF	; 255
    abc0:	9f ef       	ldi	r25, 0xFF	; 255
    abc2:	af ef       	ldi	r26, 0xFF	; 255
    abc4:	bf ef       	ldi	r27, 0xFF	; 255
    abc6:	25 96       	adiw	r28, 0x05	; 5
    abc8:	8c af       	sts	0x7c, r24
    abca:	9d af       	sts	0x7d, r25
    abcc:	ae af       	sts	0x7e, r26
    abce:	bf af       	sts	0x7f, r27
    abd0:	25 97       	sbiw	r28, 0x05	; 5
    abd2:	06 c0       	rjmp	.+12     	; 0xabe0 <__divdi3+0x114>
    abd4:	25 96       	adiw	r28, 0x05	; 5
    abd6:	1c ae       	sts	0xbc, r17
    abd8:	1d ae       	sts	0xbd, r17
    abda:	1e ae       	sts	0xbe, r17
    abdc:	1f ae       	sts	0xbf, r17
    abde:	25 97       	sbiw	r28, 0x05	; 5
    abe0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    abe2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    abe4:	af 8d       	ldd	r26, Y+31	; 0x1f
    abe6:	b8 a1       	lds	r27, 0x48
    abe8:	b7 ff       	sbrs	r27, 7
    abea:	68 c0       	rjmp	.+208    	; 0xacbc <__divdi3+0x1f0>
    abec:	25 96       	adiw	r28, 0x05	; 5
    abee:	2c ad       	sts	0x6c, r18
    abf0:	3d ad       	sts	0x6d, r19
    abf2:	4e ad       	sts	0x6e, r20
    abf4:	5f ad       	sts	0x6f, r21
    abf6:	25 97       	sbiw	r28, 0x05	; 5
    abf8:	20 95       	com	r18
    abfa:	30 95       	com	r19
    abfc:	40 95       	com	r20
    abfe:	50 95       	com	r21
    ac00:	25 96       	adiw	r28, 0x05	; 5
    ac02:	2c af       	sts	0x7c, r18
    ac04:	3d af       	sts	0x7d, r19
    ac06:	4e af       	sts	0x7e, r20
    ac08:	5f af       	sts	0x7f, r21
    ac0a:	25 97       	sbiw	r28, 0x05	; 5
    ac0c:	e1 95       	neg	r30
    ac0e:	81 e0       	ldi	r24, 0x01	; 1
    ac10:	1e 16       	cp	r1, r30
    ac12:	08 f0       	brcs	.+2      	; 0xac16 <__divdi3+0x14a>
    ac14:	80 e0       	ldi	r24, 0x00	; 0
    ac16:	f1 95       	neg	r31
    ac18:	91 e0       	ldi	r25, 0x01	; 1
    ac1a:	1f 16       	cp	r1, r31
    ac1c:	08 f0       	brcs	.+2      	; 0xac20 <__divdi3+0x154>
    ac1e:	90 e0       	ldi	r25, 0x00	; 0
    ac20:	4f 2f       	mov	r20, r31
    ac22:	48 1b       	sub	r20, r24
    ac24:	81 e0       	ldi	r24, 0x01	; 1
    ac26:	f4 17       	cp	r31, r20
    ac28:	08 f0       	brcs	.+2      	; 0xac2c <__divdi3+0x160>
    ac2a:	80 e0       	ldi	r24, 0x00	; 0
    ac2c:	98 2b       	or	r25, r24
    ac2e:	c1 94       	neg	r12
    ac30:	81 e0       	ldi	r24, 0x01	; 1
    ac32:	1c 14       	cp	r1, r12
    ac34:	08 f0       	brcs	.+2      	; 0xac38 <__divdi3+0x16c>
    ac36:	80 e0       	ldi	r24, 0x00	; 0
    ac38:	6c 2d       	mov	r22, r12
    ac3a:	69 1b       	sub	r22, r25
    ac3c:	91 e0       	ldi	r25, 0x01	; 1
    ac3e:	c6 16       	cp	r12, r22
    ac40:	08 f0       	brcs	.+2      	; 0xac44 <__divdi3+0x178>
    ac42:	90 e0       	ldi	r25, 0x00	; 0
    ac44:	89 2b       	or	r24, r25
    ac46:	d1 94       	neg	r13
    ac48:	91 e0       	ldi	r25, 0x01	; 1
    ac4a:	1d 14       	cp	r1, r13
    ac4c:	08 f0       	brcs	.+2      	; 0xac50 <__divdi3+0x184>
    ac4e:	90 e0       	ldi	r25, 0x00	; 0
    ac50:	5d 2d       	mov	r21, r13
    ac52:	58 1b       	sub	r21, r24
    ac54:	81 e0       	ldi	r24, 0x01	; 1
    ac56:	d5 16       	cp	r13, r21
    ac58:	08 f0       	brcs	.+2      	; 0xac5c <__divdi3+0x190>
    ac5a:	80 e0       	ldi	r24, 0x00	; 0
    ac5c:	98 2b       	or	r25, r24
    ac5e:	e1 94       	neg	r14
    ac60:	81 e0       	ldi	r24, 0x01	; 1
    ac62:	1e 14       	cp	r1, r14
    ac64:	08 f0       	brcs	.+2      	; 0xac68 <__divdi3+0x19c>
    ac66:	80 e0       	ldi	r24, 0x00	; 0
    ac68:	3e 2d       	mov	r19, r14
    ac6a:	39 1b       	sub	r19, r25
    ac6c:	91 e0       	ldi	r25, 0x01	; 1
    ac6e:	e3 16       	cp	r14, r19
    ac70:	08 f0       	brcs	.+2      	; 0xac74 <__divdi3+0x1a8>
    ac72:	90 e0       	ldi	r25, 0x00	; 0
    ac74:	89 2b       	or	r24, r25
    ac76:	f1 94       	neg	r15
    ac78:	91 e0       	ldi	r25, 0x01	; 1
    ac7a:	1f 14       	cp	r1, r15
    ac7c:	08 f0       	brcs	.+2      	; 0xac80 <__divdi3+0x1b4>
    ac7e:	90 e0       	ldi	r25, 0x00	; 0
    ac80:	2f 2d       	mov	r18, r15
    ac82:	28 1b       	sub	r18, r24
    ac84:	81 e0       	ldi	r24, 0x01	; 1
    ac86:	f2 16       	cp	r15, r18
    ac88:	08 f0       	brcs	.+2      	; 0xac8c <__divdi3+0x1c0>
    ac8a:	80 e0       	ldi	r24, 0x00	; 0
    ac8c:	98 2b       	or	r25, r24
    ac8e:	01 95       	neg	r16
    ac90:	81 e0       	ldi	r24, 0x01	; 1
    ac92:	10 16       	cp	r1, r16
    ac94:	08 f0       	brcs	.+2      	; 0xac98 <__divdi3+0x1cc>
    ac96:	80 e0       	ldi	r24, 0x00	; 0
    ac98:	70 2f       	mov	r23, r16
    ac9a:	79 1b       	sub	r23, r25
    ac9c:	97 2f       	mov	r25, r23
    ac9e:	71 e0       	ldi	r23, 0x01	; 1
    aca0:	09 17       	cp	r16, r25
    aca2:	08 f0       	brcs	.+2      	; 0xaca6 <__divdi3+0x1da>
    aca4:	70 e0       	ldi	r23, 0x00	; 0
    aca6:	87 2b       	or	r24, r23
    aca8:	11 95       	neg	r17
    acaa:	18 1b       	sub	r17, r24
    acac:	e9 8f       	std	Y+25, r30	; 0x19
    acae:	4a 8f       	std	Y+26, r20	; 0x1a
    acb0:	6b 8f       	std	Y+27, r22	; 0x1b
    acb2:	5c 8f       	std	Y+28, r21	; 0x1c
    acb4:	3d 8f       	std	Y+29, r19	; 0x1d
    acb6:	2e 8f       	std	Y+30, r18	; 0x1e
    acb8:	9f 8f       	std	Y+31, r25	; 0x1f
    acba:	18 a3       	lds	r17, 0x58
    acbc:	79 8d       	ldd	r23, Y+25	; 0x19
    acbe:	6a 8d       	ldd	r22, Y+26	; 0x1a
    acc0:	5b 8d       	ldd	r21, Y+27	; 0x1b
    acc2:	4c 8d       	ldd	r20, Y+28	; 0x1c
    acc4:	3d 8d       	ldd	r19, Y+29	; 0x1d
    acc6:	2e 8d       	ldd	r18, Y+30	; 0x1e
    acc8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    acca:	88 a1       	lds	r24, 0x48
    accc:	e9 a1       	lds	r30, 0x49
    acce:	e9 8b       	std	Y+17, r30	; 0x11
    acd0:	ea a1       	lds	r30, 0x4a
    acd2:	ea 8b       	std	Y+18, r30	; 0x12
    acd4:	eb a1       	lds	r30, 0x4b
    acd6:	eb 8b       	std	Y+19, r30	; 0x13
    acd8:	ec a1       	lds	r30, 0x4c
    acda:	ec 8b       	std	Y+20, r30	; 0x14
    acdc:	ed a1       	lds	r30, 0x4d
    acde:	ed 8b       	std	Y+21, r30	; 0x15
    ace0:	ee a1       	lds	r30, 0x4e
    ace2:	ee 8b       	std	Y+22, r30	; 0x16
    ace4:	ef a1       	lds	r30, 0x4f
    ace6:	ef 8b       	std	Y+23, r30	; 0x17
    ace8:	e8 a5       	lds	r30, 0x68
    acea:	e8 8f       	std	Y+24, r30	; 0x18
    acec:	79 87       	std	Y+9, r23	; 0x09
    acee:	6a 87       	std	Y+10, r22	; 0x0a
    acf0:	5b 87       	std	Y+11, r21	; 0x0b
    acf2:	4c 87       	std	Y+12, r20	; 0x0c
    acf4:	3d 87       	std	Y+13, r19	; 0x0d
    acf6:	2e 87       	std	Y+14, r18	; 0x0e
    acf8:	9f 87       	std	Y+15, r25	; 0x0f
    acfa:	88 8b       	std	Y+16, r24	; 0x10
    acfc:	89 84       	ldd	r8, Y+9	; 0x09
    acfe:	9a 84       	ldd	r9, Y+10	; 0x0a
    ad00:	ab 84       	ldd	r10, Y+11	; 0x0b
    ad02:	bc 84       	ldd	r11, Y+12	; 0x0c
    ad04:	8d 85       	ldd	r24, Y+13	; 0x0d
    ad06:	9e 85       	ldd	r25, Y+14	; 0x0e
    ad08:	af 85       	ldd	r26, Y+15	; 0x0f
    ad0a:	b8 89       	ldd	r27, Y+16	; 0x10
    ad0c:	e9 88       	ldd	r14, Y+17	; 0x11
    ad0e:	fa 88       	ldd	r15, Y+18	; 0x12
    ad10:	0b 89       	ldd	r16, Y+19	; 0x13
    ad12:	1c 89       	ldd	r17, Y+20	; 0x14
    ad14:	ed aa       	sts	0x9d, r30
    ad16:	fe aa       	sts	0x9e, r31
    ad18:	0f ab       	sts	0x5f, r16
    ad1a:	18 af       	sts	0x78, r17
    ad1c:	cd 88       	ldd	r12, Y+21	; 0x15
    ad1e:	de 88       	ldd	r13, Y+22	; 0x16
    ad20:	ef 88       	ldd	r14, Y+23	; 0x17
    ad22:	f8 8c       	ldd	r15, Y+24	; 0x18
    ad24:	00 97       	sbiw	r24, 0x00	; 0
    ad26:	a1 05       	cpc	r26, r1
    ad28:	b1 05       	cpc	r27, r1
    ad2a:	09 f0       	breq	.+2      	; 0xad2e <__divdi3+0x262>
    ad2c:	bd c3       	rjmp	.+1914   	; 0xb4a8 <__divdi3+0x9dc>
    ad2e:	c8 14       	cp	r12, r8
    ad30:	d9 04       	cpc	r13, r9
    ad32:	ea 04       	cpc	r14, r10
    ad34:	fb 04       	cpc	r15, r11
    ad36:	08 f0       	brcs	.+2      	; 0xad3a <__divdi3+0x26e>
    ad38:	4d c1       	rjmp	.+666    	; 0xafd4 <__divdi3+0x508>
    ad3a:	00 e0       	ldi	r16, 0x00	; 0
    ad3c:	80 16       	cp	r8, r16
    ad3e:	00 e0       	ldi	r16, 0x00	; 0
    ad40:	90 06       	cpc	r9, r16
    ad42:	01 e0       	ldi	r16, 0x01	; 1
    ad44:	a0 06       	cpc	r10, r16
    ad46:	00 e0       	ldi	r16, 0x00	; 0
    ad48:	b0 06       	cpc	r11, r16
    ad4a:	58 f4       	brcc	.+22     	; 0xad62 <__divdi3+0x296>
    ad4c:	1f ef       	ldi	r17, 0xFF	; 255
    ad4e:	81 16       	cp	r8, r17
    ad50:	91 04       	cpc	r9, r1
    ad52:	a1 04       	cpc	r10, r1
    ad54:	b1 04       	cpc	r11, r1
    ad56:	09 f0       	breq	.+2      	; 0xad5a <__divdi3+0x28e>
    ad58:	90 f4       	brcc	.+36     	; 0xad7e <__divdi3+0x2b2>
    ad5a:	80 e0       	ldi	r24, 0x00	; 0
    ad5c:	90 e0       	ldi	r25, 0x00	; 0
    ad5e:	dc 01       	movw	r26, r24
    ad60:	17 c0       	rjmp	.+46     	; 0xad90 <__divdi3+0x2c4>
    ad62:	20 e0       	ldi	r18, 0x00	; 0
    ad64:	82 16       	cp	r8, r18
    ad66:	20 e0       	ldi	r18, 0x00	; 0
    ad68:	92 06       	cpc	r9, r18
    ad6a:	20 e0       	ldi	r18, 0x00	; 0
    ad6c:	a2 06       	cpc	r10, r18
    ad6e:	21 e0       	ldi	r18, 0x01	; 1
    ad70:	b2 06       	cpc	r11, r18
    ad72:	50 f4       	brcc	.+20     	; 0xad88 <__divdi3+0x2bc>
    ad74:	80 e1       	ldi	r24, 0x10	; 16
    ad76:	90 e0       	ldi	r25, 0x00	; 0
    ad78:	a0 e0       	ldi	r26, 0x00	; 0
    ad7a:	b0 e0       	ldi	r27, 0x00	; 0
    ad7c:	09 c0       	rjmp	.+18     	; 0xad90 <__divdi3+0x2c4>
    ad7e:	88 e0       	ldi	r24, 0x08	; 8
    ad80:	90 e0       	ldi	r25, 0x00	; 0
    ad82:	a0 e0       	ldi	r26, 0x00	; 0
    ad84:	b0 e0       	ldi	r27, 0x00	; 0
    ad86:	04 c0       	rjmp	.+8      	; 0xad90 <__divdi3+0x2c4>
    ad88:	88 e1       	ldi	r24, 0x18	; 24
    ad8a:	90 e0       	ldi	r25, 0x00	; 0
    ad8c:	a0 e0       	ldi	r26, 0x00	; 0
    ad8e:	b0 e0       	ldi	r27, 0x00	; 0
    ad90:	b5 01       	movw	r22, r10
    ad92:	a4 01       	movw	r20, r8
    ad94:	08 2e       	mov	r0, r24
    ad96:	04 c0       	rjmp	.+8      	; 0xada0 <__divdi3+0x2d4>
    ad98:	76 95       	lsr	r23
    ad9a:	67 95       	ror	r22
    ad9c:	57 95       	ror	r21
    ad9e:	47 95       	ror	r20
    ada0:	0a 94       	dec	r0
    ada2:	d2 f7       	brpl	.-12     	; 0xad98 <__divdi3+0x2cc>
    ada4:	fa 01       	movw	r30, r20
    ada6:	e6 5c       	subi	r30, 0xC6	; 198
    ada8:	ff 4d       	sbci	r31, 0xDF	; 223
    adaa:	20 81       	ld	r18, Z
    adac:	40 e2       	ldi	r20, 0x20	; 32
    adae:	50 e0       	ldi	r21, 0x00	; 0
    adb0:	60 e0       	ldi	r22, 0x00	; 0
    adb2:	70 e0       	ldi	r23, 0x00	; 0
    adb4:	48 1b       	sub	r20, r24
    adb6:	59 0b       	sbc	r21, r25
    adb8:	6a 0b       	sbc	r22, r26
    adba:	7b 0b       	sbc	r23, r27
    adbc:	42 1b       	sub	r20, r18
    adbe:	51 09       	sbc	r21, r1
    adc0:	61 09       	sbc	r22, r1
    adc2:	71 09       	sbc	r23, r1
    adc4:	41 15       	cp	r20, r1
    adc6:	51 05       	cpc	r21, r1
    adc8:	61 05       	cpc	r22, r1
    adca:	71 05       	cpc	r23, r1
    adcc:	a1 f1       	breq	.+104    	; 0xae36 <__divdi3+0x36a>
    adce:	04 2e       	mov	r0, r20
    add0:	04 c0       	rjmp	.+8      	; 0xadda <__divdi3+0x30e>
    add2:	88 0c       	add	r8, r8
    add4:	99 1c       	adc	r9, r9
    add6:	aa 1c       	adc	r10, r10
    add8:	bb 1c       	adc	r11, r11
    adda:	0a 94       	dec	r0
    addc:	d2 f7       	brpl	.-12     	; 0xadd2 <__divdi3+0x306>
    adde:	97 01       	movw	r18, r14
    ade0:	86 01       	movw	r16, r12
    ade2:	04 2e       	mov	r0, r20
    ade4:	04 c0       	rjmp	.+8      	; 0xadee <__divdi3+0x322>
    ade6:	00 0f       	add	r16, r16
    ade8:	11 1f       	adc	r17, r17
    adea:	22 1f       	adc	r18, r18
    adec:	33 1f       	adc	r19, r19
    adee:	0a 94       	dec	r0
    adf0:	d2 f7       	brpl	.-12     	; 0xade6 <__divdi3+0x31a>
    adf2:	80 e2       	ldi	r24, 0x20	; 32
    adf4:	90 e0       	ldi	r25, 0x00	; 0
    adf6:	84 1b       	sub	r24, r20
    adf8:	95 0b       	sbc	r25, r21
    adfa:	cd a8       	sts	0x8d, r28
    adfc:	de a8       	sts	0x8e, r29
    adfe:	ef a8       	sts	0x8f, r30
    ae00:	f8 ac       	sts	0xa8, r31
    ae02:	04 c0       	rjmp	.+8      	; 0xae0c <__divdi3+0x340>
    ae04:	f6 94       	lsr	r15
    ae06:	e7 94       	ror	r14
    ae08:	d7 94       	ror	r13
    ae0a:	c7 94       	ror	r12
    ae0c:	8a 95       	dec	r24
    ae0e:	d2 f7       	brpl	.-12     	; 0xae04 <__divdi3+0x338>
    ae10:	c0 2a       	or	r12, r16
    ae12:	d1 2a       	or	r13, r17
    ae14:	e2 2a       	or	r14, r18
    ae16:	f3 2a       	or	r15, r19
    ae18:	0d a9       	sts	0x4d, r16
    ae1a:	1e a9       	sts	0x4e, r17
    ae1c:	2f a9       	sts	0x4f, r18
    ae1e:	38 ad       	sts	0x68, r19
    ae20:	04 c0       	rjmp	.+8      	; 0xae2a <__divdi3+0x35e>
    ae22:	00 0f       	add	r16, r16
    ae24:	11 1f       	adc	r17, r17
    ae26:	22 1f       	adc	r18, r18
    ae28:	33 1f       	adc	r19, r19
    ae2a:	4a 95       	dec	r20
    ae2c:	d2 f7       	brpl	.-12     	; 0xae22 <__divdi3+0x356>
    ae2e:	0d ab       	sts	0x5d, r16
    ae30:	1e ab       	sts	0x5e, r17
    ae32:	2f ab       	sts	0x5f, r18
    ae34:	38 af       	sts	0x78, r19
    ae36:	25 01       	movw	r4, r10
    ae38:	66 24       	eor	r6, r6
    ae3a:	77 24       	eor	r7, r7
    ae3c:	95 01       	movw	r18, r10
    ae3e:	84 01       	movw	r16, r8
    ae40:	20 70       	andi	r18, 0x00	; 0
    ae42:	30 70       	andi	r19, 0x00	; 0
    ae44:	09 ab       	sts	0x59, r16
    ae46:	1a ab       	sts	0x5a, r17
    ae48:	2b ab       	sts	0x5b, r18
    ae4a:	3c ab       	sts	0x5c, r19
    ae4c:	c7 01       	movw	r24, r14
    ae4e:	b6 01       	movw	r22, r12
    ae50:	a3 01       	movw	r20, r6
    ae52:	92 01       	movw	r18, r4
    ae54:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    ae58:	2d a7       	lds	r18, 0x7d
    ae5a:	3e a7       	lds	r19, 0x7e
    ae5c:	4f a7       	lds	r20, 0x7f
    ae5e:	58 ab       	sts	0x58, r21
    ae60:	69 a7       	lds	r22, 0x79
    ae62:	7a a7       	lds	r23, 0x7a
    ae64:	8b a7       	lds	r24, 0x7b
    ae66:	9c a7       	lds	r25, 0x7c
    ae68:	c7 01       	movw	r24, r14
    ae6a:	b6 01       	movw	r22, r12
    ae6c:	a3 01       	movw	r20, r6
    ae6e:	92 01       	movw	r18, r4
    ae70:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    ae74:	ca 01       	movw	r24, r20
    ae76:	b9 01       	movw	r22, r18
    ae78:	29 a9       	sts	0x49, r18
    ae7a:	3a a9       	sts	0x4a, r19
    ae7c:	4b a9       	sts	0x4b, r20
    ae7e:	5c a9       	sts	0x4c, r21
    ae80:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    ae84:	ab 01       	movw	r20, r22
    ae86:	bc 01       	movw	r22, r24
    ae88:	09 a5       	lds	r16, 0x69
    ae8a:	1a a5       	lds	r17, 0x6a
    ae8c:	2b a5       	lds	r18, 0x6b
    ae8e:	3c a5       	lds	r19, 0x6c
    ae90:	78 01       	movw	r14, r16
    ae92:	dd 24       	eor	r13, r13
    ae94:	cc 24       	eor	r12, r12
    ae96:	0d a9       	sts	0x4d, r16
    ae98:	1e a9       	sts	0x4e, r17
    ae9a:	2f a9       	sts	0x4f, r18
    ae9c:	38 ad       	sts	0x68, r19
    ae9e:	c9 01       	movw	r24, r18
    aea0:	aa 27       	eor	r26, r26
    aea2:	bb 27       	eor	r27, r27
    aea4:	c8 2a       	or	r12, r24
    aea6:	d9 2a       	or	r13, r25
    aea8:	ea 2a       	or	r14, r26
    aeaa:	fb 2a       	or	r15, r27
    aeac:	0d a5       	lds	r16, 0x6d
    aeae:	1e a5       	lds	r17, 0x6e
    aeb0:	2f a5       	lds	r18, 0x6f
    aeb2:	38 a9       	sts	0x48, r19
    aeb4:	c4 16       	cp	r12, r20
    aeb6:	d5 06       	cpc	r13, r21
    aeb8:	e6 06       	cpc	r14, r22
    aeba:	f7 06       	cpc	r15, r23
    aebc:	38 f5       	brcc	.+78     	; 0xaf0c <__divdi3+0x440>
    aebe:	01 50       	subi	r16, 0x01	; 1
    aec0:	10 40       	sbci	r17, 0x00	; 0
    aec2:	20 40       	sbci	r18, 0x00	; 0
    aec4:	30 40       	sbci	r19, 0x00	; 0
    aec6:	09 a7       	lds	r16, 0x79
    aec8:	1a a7       	lds	r17, 0x7a
    aeca:	2b a7       	lds	r18, 0x7b
    aecc:	3c a7       	lds	r19, 0x7c
    aece:	c8 0c       	add	r12, r8
    aed0:	d9 1c       	adc	r13, r9
    aed2:	ea 1c       	adc	r14, r10
    aed4:	fb 1c       	adc	r15, r11
    aed6:	c8 14       	cp	r12, r8
    aed8:	d9 04       	cpc	r13, r9
    aeda:	ea 04       	cpc	r14, r10
    aedc:	fb 04       	cpc	r15, r11
    aede:	d0 f0       	brcs	.+52     	; 0xaf14 <__divdi3+0x448>
    aee0:	c4 16       	cp	r12, r20
    aee2:	d5 06       	cpc	r13, r21
    aee4:	e6 06       	cpc	r14, r22
    aee6:	f7 06       	cpc	r15, r23
    aee8:	a8 f4       	brcc	.+42     	; 0xaf14 <__divdi3+0x448>
    aeea:	0d a5       	lds	r16, 0x6d
    aeec:	1e a5       	lds	r17, 0x6e
    aeee:	2f a5       	lds	r18, 0x6f
    aef0:	38 a9       	sts	0x48, r19
    aef2:	02 50       	subi	r16, 0x02	; 2
    aef4:	10 40       	sbci	r17, 0x00	; 0
    aef6:	20 40       	sbci	r18, 0x00	; 0
    aef8:	30 40       	sbci	r19, 0x00	; 0
    aefa:	09 a7       	lds	r16, 0x79
    aefc:	1a a7       	lds	r17, 0x7a
    aefe:	2b a7       	lds	r18, 0x7b
    af00:	3c a7       	lds	r19, 0x7c
    af02:	c8 0c       	add	r12, r8
    af04:	d9 1c       	adc	r13, r9
    af06:	ea 1c       	adc	r14, r10
    af08:	fb 1c       	adc	r15, r11
    af0a:	04 c0       	rjmp	.+8      	; 0xaf14 <__divdi3+0x448>
    af0c:	09 a7       	lds	r16, 0x79
    af0e:	1a a7       	lds	r17, 0x7a
    af10:	2b a7       	lds	r18, 0x7b
    af12:	3c a7       	lds	r19, 0x7c
    af14:	c4 1a       	sub	r12, r20
    af16:	d5 0a       	sbc	r13, r21
    af18:	e6 0a       	sbc	r14, r22
    af1a:	f7 0a       	sbc	r15, r23
    af1c:	c7 01       	movw	r24, r14
    af1e:	b6 01       	movw	r22, r12
    af20:	a3 01       	movw	r20, r6
    af22:	92 01       	movw	r18, r4
    af24:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    af28:	2d a7       	lds	r18, 0x7d
    af2a:	3e a7       	lds	r19, 0x7e
    af2c:	4f a7       	lds	r20, 0x7f
    af2e:	58 ab       	sts	0x58, r21
    af30:	69 af       	sts	0x79, r22
    af32:	7a af       	sts	0x7a, r23
    af34:	8b af       	sts	0x7b, r24
    af36:	9c af       	sts	0x7c, r25
    af38:	c7 01       	movw	r24, r14
    af3a:	b6 01       	movw	r22, r12
    af3c:	a3 01       	movw	r20, r6
    af3e:	92 01       	movw	r18, r4
    af40:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    af44:	ca 01       	movw	r24, r20
    af46:	b9 01       	movw	r22, r18
    af48:	29 a9       	sts	0x49, r18
    af4a:	3a a9       	sts	0x4a, r19
    af4c:	4b a9       	sts	0x4b, r20
    af4e:	5c a9       	sts	0x4c, r21
    af50:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    af54:	6b 01       	movw	r12, r22
    af56:	7c 01       	movw	r14, r24
    af58:	49 ad       	sts	0x69, r20
    af5a:	5a ad       	sts	0x6a, r21
    af5c:	6b ad       	sts	0x6b, r22
    af5e:	7c ad       	sts	0x6c, r23
    af60:	9a 01       	movw	r18, r20
    af62:	11 27       	eor	r17, r17
    af64:	00 27       	eor	r16, r16
    af66:	4d a9       	sts	0x4d, r20
    af68:	5e a9       	sts	0x4e, r21
    af6a:	6f a9       	sts	0x4f, r22
    af6c:	78 ad       	sts	0x68, r23
    af6e:	60 70       	andi	r22, 0x00	; 0
    af70:	70 70       	andi	r23, 0x00	; 0
    af72:	04 2b       	or	r16, r20
    af74:	15 2b       	or	r17, r21
    af76:	26 2b       	or	r18, r22
    af78:	37 2b       	or	r19, r23
    af7a:	8d a5       	lds	r24, 0x6d
    af7c:	9e a5       	lds	r25, 0x6e
    af7e:	af a5       	lds	r26, 0x6f
    af80:	b8 a9       	sts	0x48, r27
    af82:	0c 15       	cp	r16, r12
    af84:	1d 05       	cpc	r17, r13
    af86:	2e 05       	cpc	r18, r14
    af88:	3f 05       	cpc	r19, r15
    af8a:	c0 f4       	brcc	.+48     	; 0xafbc <__divdi3+0x4f0>
    af8c:	01 97       	sbiw	r24, 0x01	; 1
    af8e:	a1 09       	sbc	r26, r1
    af90:	b1 09       	sbc	r27, r1
    af92:	08 0d       	add	r16, r8
    af94:	19 1d       	adc	r17, r9
    af96:	2a 1d       	adc	r18, r10
    af98:	3b 1d       	adc	r19, r11
    af9a:	08 15       	cp	r16, r8
    af9c:	19 05       	cpc	r17, r9
    af9e:	2a 05       	cpc	r18, r10
    afa0:	3b 05       	cpc	r19, r11
    afa2:	60 f0       	brcs	.+24     	; 0xafbc <__divdi3+0x4f0>
    afa4:	0c 15       	cp	r16, r12
    afa6:	1d 05       	cpc	r17, r13
    afa8:	2e 05       	cpc	r18, r14
    afaa:	3f 05       	cpc	r19, r15
    afac:	38 f4       	brcc	.+14     	; 0xafbc <__divdi3+0x4f0>
    afae:	8d a5       	lds	r24, 0x6d
    afb0:	9e a5       	lds	r25, 0x6e
    afb2:	af a5       	lds	r26, 0x6f
    afb4:	b8 a9       	sts	0x48, r27
    afb6:	02 97       	sbiw	r24, 0x02	; 2
    afb8:	a1 09       	sbc	r26, r1
    afba:	b1 09       	sbc	r27, r1
    afbc:	09 a5       	lds	r16, 0x69
    afbe:	1a a5       	lds	r17, 0x6a
    afc0:	2b a5       	lds	r18, 0x6b
    afc2:	3c a5       	lds	r19, 0x6c
    afc4:	78 01       	movw	r14, r16
    afc6:	dd 24       	eor	r13, r13
    afc8:	cc 24       	eor	r12, r12
    afca:	c8 2a       	or	r12, r24
    afcc:	d9 2a       	or	r13, r25
    afce:	ea 2a       	or	r14, r26
    afd0:	fb 2a       	or	r15, r27
    afd2:	b7 c4       	rjmp	.+2414   	; 0xb942 <__divdi3+0xe76>
    afd4:	81 14       	cp	r8, r1
    afd6:	91 04       	cpc	r9, r1
    afd8:	a1 04       	cpc	r10, r1
    afda:	b1 04       	cpc	r11, r1
    afdc:	51 f4       	brne	.+20     	; 0xaff2 <__divdi3+0x526>
    afde:	61 e0       	ldi	r22, 0x01	; 1
    afe0:	70 e0       	ldi	r23, 0x00	; 0
    afe2:	80 e0       	ldi	r24, 0x00	; 0
    afe4:	90 e0       	ldi	r25, 0x00	; 0
    afe6:	a5 01       	movw	r20, r10
    afe8:	94 01       	movw	r18, r8
    afea:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    afee:	49 01       	movw	r8, r18
    aff0:	5a 01       	movw	r10, r20
    aff2:	10 e0       	ldi	r17, 0x00	; 0
    aff4:	81 16       	cp	r8, r17
    aff6:	10 e0       	ldi	r17, 0x00	; 0
    aff8:	91 06       	cpc	r9, r17
    affa:	11 e0       	ldi	r17, 0x01	; 1
    affc:	a1 06       	cpc	r10, r17
    affe:	10 e0       	ldi	r17, 0x00	; 0
    b000:	b1 06       	cpc	r11, r17
    b002:	58 f4       	brcc	.+22     	; 0xb01a <__divdi3+0x54e>
    b004:	2f ef       	ldi	r18, 0xFF	; 255
    b006:	82 16       	cp	r8, r18
    b008:	91 04       	cpc	r9, r1
    b00a:	a1 04       	cpc	r10, r1
    b00c:	b1 04       	cpc	r11, r1
    b00e:	09 f0       	breq	.+2      	; 0xb012 <__divdi3+0x546>
    b010:	90 f4       	brcc	.+36     	; 0xb036 <__divdi3+0x56a>
    b012:	80 e0       	ldi	r24, 0x00	; 0
    b014:	90 e0       	ldi	r25, 0x00	; 0
    b016:	dc 01       	movw	r26, r24
    b018:	17 c0       	rjmp	.+46     	; 0xb048 <__divdi3+0x57c>
    b01a:	30 e0       	ldi	r19, 0x00	; 0
    b01c:	83 16       	cp	r8, r19
    b01e:	30 e0       	ldi	r19, 0x00	; 0
    b020:	93 06       	cpc	r9, r19
    b022:	30 e0       	ldi	r19, 0x00	; 0
    b024:	a3 06       	cpc	r10, r19
    b026:	31 e0       	ldi	r19, 0x01	; 1
    b028:	b3 06       	cpc	r11, r19
    b02a:	50 f4       	brcc	.+20     	; 0xb040 <__divdi3+0x574>
    b02c:	80 e1       	ldi	r24, 0x10	; 16
    b02e:	90 e0       	ldi	r25, 0x00	; 0
    b030:	a0 e0       	ldi	r26, 0x00	; 0
    b032:	b0 e0       	ldi	r27, 0x00	; 0
    b034:	09 c0       	rjmp	.+18     	; 0xb048 <__divdi3+0x57c>
    b036:	88 e0       	ldi	r24, 0x08	; 8
    b038:	90 e0       	ldi	r25, 0x00	; 0
    b03a:	a0 e0       	ldi	r26, 0x00	; 0
    b03c:	b0 e0       	ldi	r27, 0x00	; 0
    b03e:	04 c0       	rjmp	.+8      	; 0xb048 <__divdi3+0x57c>
    b040:	88 e1       	ldi	r24, 0x18	; 24
    b042:	90 e0       	ldi	r25, 0x00	; 0
    b044:	a0 e0       	ldi	r26, 0x00	; 0
    b046:	b0 e0       	ldi	r27, 0x00	; 0
    b048:	b5 01       	movw	r22, r10
    b04a:	a4 01       	movw	r20, r8
    b04c:	08 2e       	mov	r0, r24
    b04e:	04 c0       	rjmp	.+8      	; 0xb058 <__divdi3+0x58c>
    b050:	76 95       	lsr	r23
    b052:	67 95       	ror	r22
    b054:	57 95       	ror	r21
    b056:	47 95       	ror	r20
    b058:	0a 94       	dec	r0
    b05a:	d2 f7       	brpl	.-12     	; 0xb050 <__divdi3+0x584>
    b05c:	fa 01       	movw	r30, r20
    b05e:	e6 5c       	subi	r30, 0xC6	; 198
    b060:	ff 4d       	sbci	r31, 0xDF	; 223
    b062:	20 81       	ld	r18, Z
    b064:	ac 01       	movw	r20, r24
    b066:	bd 01       	movw	r22, r26
    b068:	42 0f       	add	r20, r18
    b06a:	51 1d       	adc	r21, r1
    b06c:	61 1d       	adc	r22, r1
    b06e:	71 1d       	adc	r23, r1
    b070:	80 e2       	ldi	r24, 0x20	; 32
    b072:	90 e0       	ldi	r25, 0x00	; 0
    b074:	a0 e0       	ldi	r26, 0x00	; 0
    b076:	b0 e0       	ldi	r27, 0x00	; 0
    b078:	84 1b       	sub	r24, r20
    b07a:	95 0b       	sbc	r25, r21
    b07c:	a6 0b       	sbc	r26, r22
    b07e:	b7 0b       	sbc	r27, r23
    b080:	51 f4       	brne	.+20     	; 0xb096 <__divdi3+0x5ca>
    b082:	c8 18       	sub	r12, r8
    b084:	d9 08       	sbc	r13, r9
    b086:	ea 08       	sbc	r14, r10
    b088:	fb 08       	sbc	r15, r11
    b08a:	f1 e0       	ldi	r31, 0x01	; 1
    b08c:	4f 2e       	mov	r4, r31
    b08e:	51 2c       	mov	r5, r1
    b090:	61 2c       	mov	r6, r1
    b092:	71 2c       	mov	r7, r1
    b094:	28 c1       	rjmp	.+592    	; 0xb2e6 <__divdi3+0x81a>
    b096:	08 2e       	mov	r0, r24
    b098:	04 c0       	rjmp	.+8      	; 0xb0a2 <__divdi3+0x5d6>
    b09a:	88 0c       	add	r8, r8
    b09c:	99 1c       	adc	r9, r9
    b09e:	aa 1c       	adc	r10, r10
    b0a0:	bb 1c       	adc	r11, r11
    b0a2:	0a 94       	dec	r0
    b0a4:	d2 f7       	brpl	.-12     	; 0xb09a <__divdi3+0x5ce>
    b0a6:	97 01       	movw	r18, r14
    b0a8:	86 01       	movw	r16, r12
    b0aa:	04 2e       	mov	r0, r20
    b0ac:	04 c0       	rjmp	.+8      	; 0xb0b6 <__divdi3+0x5ea>
    b0ae:	36 95       	lsr	r19
    b0b0:	27 95       	ror	r18
    b0b2:	17 95       	ror	r17
    b0b4:	07 95       	ror	r16
    b0b6:	0a 94       	dec	r0
    b0b8:	d2 f7       	brpl	.-12     	; 0xb0ae <__divdi3+0x5e2>
    b0ba:	09 ab       	sts	0x59, r16
    b0bc:	1a ab       	sts	0x5a, r17
    b0be:	2b ab       	sts	0x5b, r18
    b0c0:	3c ab       	sts	0x5c, r19
    b0c2:	97 01       	movw	r18, r14
    b0c4:	86 01       	movw	r16, r12
    b0c6:	08 2e       	mov	r0, r24
    b0c8:	04 c0       	rjmp	.+8      	; 0xb0d2 <__divdi3+0x606>
    b0ca:	00 0f       	add	r16, r16
    b0cc:	11 1f       	adc	r17, r17
    b0ce:	22 1f       	adc	r18, r18
    b0d0:	33 1f       	adc	r19, r19
    b0d2:	0a 94       	dec	r0
    b0d4:	d2 f7       	brpl	.-12     	; 0xb0ca <__divdi3+0x5fe>
    b0d6:	0d a7       	lds	r16, 0x7d
    b0d8:	1e a7       	lds	r17, 0x7e
    b0da:	2f a7       	lds	r18, 0x7f
    b0dc:	38 ab       	sts	0x58, r19
    b0de:	ed a8       	sts	0x8d, r30
    b0e0:	fe a8       	sts	0x8e, r31
    b0e2:	0f a9       	sts	0x4f, r16
    b0e4:	18 ad       	sts	0x68, r17
    b0e6:	04 c0       	rjmp	.+8      	; 0xb0f0 <__divdi3+0x624>
    b0e8:	16 95       	lsr	r17
    b0ea:	07 95       	ror	r16
    b0ec:	f7 94       	ror	r15
    b0ee:	e7 94       	ror	r14
    b0f0:	4a 95       	dec	r20
    b0f2:	d2 f7       	brpl	.-12     	; 0xb0e8 <__divdi3+0x61c>
    b0f4:	b8 01       	movw	r22, r16
    b0f6:	a7 01       	movw	r20, r14
    b0f8:	0d a5       	lds	r16, 0x6d
    b0fa:	1e a5       	lds	r17, 0x6e
    b0fc:	2f a5       	lds	r18, 0x6f
    b0fe:	38 a9       	sts	0x48, r19
    b100:	04 2b       	or	r16, r20
    b102:	15 2b       	or	r17, r21
    b104:	26 2b       	or	r18, r22
    b106:	37 2b       	or	r19, r23
    b108:	0d a7       	lds	r16, 0x7d
    b10a:	1e a7       	lds	r17, 0x7e
    b10c:	2f a7       	lds	r18, 0x7f
    b10e:	38 ab       	sts	0x58, r19
    b110:	ed a8       	sts	0x8d, r30
    b112:	fe a8       	sts	0x8e, r31
    b114:	0f a9       	sts	0x4f, r16
    b116:	18 ad       	sts	0x68, r17
    b118:	04 c0       	rjmp	.+8      	; 0xb122 <__divdi3+0x656>
    b11a:	ee 0c       	add	r14, r14
    b11c:	ff 1c       	adc	r15, r15
    b11e:	00 1f       	adc	r16, r16
    b120:	11 1f       	adc	r17, r17
    b122:	8a 95       	dec	r24
    b124:	d2 f7       	brpl	.-12     	; 0xb11a <__divdi3+0x64e>
    b126:	ed aa       	sts	0x9d, r30
    b128:	fe aa       	sts	0x9e, r31
    b12a:	0f ab       	sts	0x5f, r16
    b12c:	18 af       	sts	0x78, r17
    b12e:	25 01       	movw	r4, r10
    b130:	66 24       	eor	r6, r6
    b132:	77 24       	eor	r7, r7
    b134:	95 01       	movw	r18, r10
    b136:	84 01       	movw	r16, r8
    b138:	20 70       	andi	r18, 0x00	; 0
    b13a:	30 70       	andi	r19, 0x00	; 0
    b13c:	09 af       	sts	0x79, r16
    b13e:	1a af       	sts	0x7a, r17
    b140:	2b af       	sts	0x7b, r18
    b142:	3c af       	sts	0x7c, r19
    b144:	69 a9       	sts	0x49, r22
    b146:	7a a9       	sts	0x4a, r23
    b148:	8b a9       	sts	0x4b, r24
    b14a:	9c a9       	sts	0x4c, r25
    b14c:	a3 01       	movw	r20, r6
    b14e:	92 01       	movw	r18, r4
    b150:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    b154:	29 a7       	lds	r18, 0x79
    b156:	3a a7       	lds	r19, 0x7a
    b158:	4b a7       	lds	r20, 0x7b
    b15a:	5c a7       	lds	r21, 0x7c
    b15c:	6b 01       	movw	r12, r22
    b15e:	7c 01       	movw	r14, r24
    b160:	69 a9       	sts	0x49, r22
    b162:	7a a9       	sts	0x4a, r23
    b164:	8b a9       	sts	0x4b, r24
    b166:	9c a9       	sts	0x4c, r25
    b168:	a3 01       	movw	r20, r6
    b16a:	92 01       	movw	r18, r4
    b16c:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    b170:	ca 01       	movw	r24, r20
    b172:	b9 01       	movw	r22, r18
    b174:	29 ad       	sts	0x69, r18
    b176:	3a ad       	sts	0x6a, r19
    b178:	4b ad       	sts	0x6b, r20
    b17a:	5c ad       	sts	0x6c, r21
    b17c:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    b180:	ab 01       	movw	r20, r22
    b182:	bc 01       	movw	r22, r24
    b184:	76 01       	movw	r14, r12
    b186:	dd 24       	eor	r13, r13
    b188:	cc 24       	eor	r12, r12
    b18a:	0d a5       	lds	r16, 0x6d
    b18c:	1e a5       	lds	r17, 0x6e
    b18e:	2f a5       	lds	r18, 0x6f
    b190:	38 a9       	sts	0x48, r19
    b192:	c9 01       	movw	r24, r18
    b194:	aa 27       	eor	r26, r26
    b196:	bb 27       	eor	r27, r27
    b198:	c8 2a       	or	r12, r24
    b19a:	d9 2a       	or	r13, r25
    b19c:	ea 2a       	or	r14, r26
    b19e:	fb 2a       	or	r15, r27
    b1a0:	09 a5       	lds	r16, 0x69
    b1a2:	1a a5       	lds	r17, 0x6a
    b1a4:	2b a5       	lds	r18, 0x6b
    b1a6:	3c a5       	lds	r19, 0x6c
    b1a8:	c4 16       	cp	r12, r20
    b1aa:	d5 06       	cpc	r13, r21
    b1ac:	e6 06       	cpc	r14, r22
    b1ae:	f7 06       	cpc	r15, r23
    b1b0:	38 f5       	brcc	.+78     	; 0xb200 <__divdi3+0x734>
    b1b2:	01 50       	subi	r16, 0x01	; 1
    b1b4:	10 40       	sbci	r17, 0x00	; 0
    b1b6:	20 40       	sbci	r18, 0x00	; 0
    b1b8:	30 40       	sbci	r19, 0x00	; 0
    b1ba:	09 ab       	sts	0x59, r16
    b1bc:	1a ab       	sts	0x5a, r17
    b1be:	2b ab       	sts	0x5b, r18
    b1c0:	3c ab       	sts	0x5c, r19
    b1c2:	c8 0c       	add	r12, r8
    b1c4:	d9 1c       	adc	r13, r9
    b1c6:	ea 1c       	adc	r14, r10
    b1c8:	fb 1c       	adc	r15, r11
    b1ca:	c8 14       	cp	r12, r8
    b1cc:	d9 04       	cpc	r13, r9
    b1ce:	ea 04       	cpc	r14, r10
    b1d0:	fb 04       	cpc	r15, r11
    b1d2:	d0 f0       	brcs	.+52     	; 0xb208 <__divdi3+0x73c>
    b1d4:	c4 16       	cp	r12, r20
    b1d6:	d5 06       	cpc	r13, r21
    b1d8:	e6 06       	cpc	r14, r22
    b1da:	f7 06       	cpc	r15, r23
    b1dc:	a8 f4       	brcc	.+42     	; 0xb208 <__divdi3+0x73c>
    b1de:	09 a5       	lds	r16, 0x69
    b1e0:	1a a5       	lds	r17, 0x6a
    b1e2:	2b a5       	lds	r18, 0x6b
    b1e4:	3c a5       	lds	r19, 0x6c
    b1e6:	02 50       	subi	r16, 0x02	; 2
    b1e8:	10 40       	sbci	r17, 0x00	; 0
    b1ea:	20 40       	sbci	r18, 0x00	; 0
    b1ec:	30 40       	sbci	r19, 0x00	; 0
    b1ee:	09 ab       	sts	0x59, r16
    b1f0:	1a ab       	sts	0x5a, r17
    b1f2:	2b ab       	sts	0x5b, r18
    b1f4:	3c ab       	sts	0x5c, r19
    b1f6:	c8 0c       	add	r12, r8
    b1f8:	d9 1c       	adc	r13, r9
    b1fa:	ea 1c       	adc	r14, r10
    b1fc:	fb 1c       	adc	r15, r11
    b1fe:	04 c0       	rjmp	.+8      	; 0xb208 <__divdi3+0x73c>
    b200:	09 ab       	sts	0x59, r16
    b202:	1a ab       	sts	0x5a, r17
    b204:	2b ab       	sts	0x5b, r18
    b206:	3c ab       	sts	0x5c, r19
    b208:	c4 1a       	sub	r12, r20
    b20a:	d5 0a       	sbc	r13, r21
    b20c:	e6 0a       	sbc	r14, r22
    b20e:	f7 0a       	sbc	r15, r23
    b210:	c7 01       	movw	r24, r14
    b212:	b6 01       	movw	r22, r12
    b214:	a3 01       	movw	r20, r6
    b216:	92 01       	movw	r18, r4
    b218:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    b21c:	29 a7       	lds	r18, 0x79
    b21e:	3a a7       	lds	r19, 0x7a
    b220:	4b a7       	lds	r20, 0x7b
    b222:	5c a7       	lds	r21, 0x7c
    b224:	21 96       	adiw	r28, 0x01	; 1
    b226:	6c af       	sts	0x7c, r22
    b228:	7d af       	sts	0x7d, r23
    b22a:	8e af       	sts	0x7e, r24
    b22c:	9f af       	sts	0x7f, r25
    b22e:	21 97       	sbiw	r28, 0x01	; 1
    b230:	c7 01       	movw	r24, r14
    b232:	b6 01       	movw	r22, r12
    b234:	a3 01       	movw	r20, r6
    b236:	92 01       	movw	r18, r4
    b238:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    b23c:	ca 01       	movw	r24, r20
    b23e:	b9 01       	movw	r22, r18
    b240:	29 ad       	sts	0x69, r18
    b242:	3a ad       	sts	0x6a, r19
    b244:	4b ad       	sts	0x6b, r20
    b246:	5c ad       	sts	0x6c, r21
    b248:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    b24c:	8b 01       	movw	r16, r22
    b24e:	9c 01       	movw	r18, r24
    b250:	21 96       	adiw	r28, 0x01	; 1
    b252:	4c ad       	sts	0x6c, r20
    b254:	5d ad       	sts	0x6d, r21
    b256:	6e ad       	sts	0x6e, r22
    b258:	7f ad       	sts	0x6f, r23
    b25a:	21 97       	sbiw	r28, 0x01	; 1
    b25c:	da 01       	movw	r26, r20
    b25e:	99 27       	eor	r25, r25
    b260:	88 27       	eor	r24, r24
    b262:	4d a5       	lds	r20, 0x6d
    b264:	5e a5       	lds	r21, 0x6e
    b266:	6f a5       	lds	r22, 0x6f
    b268:	78 a9       	sts	0x48, r23
    b26a:	60 70       	andi	r22, 0x00	; 0
    b26c:	70 70       	andi	r23, 0x00	; 0
    b26e:	84 2b       	or	r24, r20
    b270:	95 2b       	or	r25, r21
    b272:	a6 2b       	or	r26, r22
    b274:	b7 2b       	or	r27, r23
    b276:	49 a5       	lds	r20, 0x69
    b278:	5a a5       	lds	r21, 0x6a
    b27a:	6b a5       	lds	r22, 0x6b
    b27c:	7c a5       	lds	r23, 0x6c
    b27e:	80 17       	cp	r24, r16
    b280:	91 07       	cpc	r25, r17
    b282:	a2 07       	cpc	r26, r18
    b284:	b3 07       	cpc	r27, r19
    b286:	f0 f4       	brcc	.+60     	; 0xb2c4 <__divdi3+0x7f8>
    b288:	41 50       	subi	r20, 0x01	; 1
    b28a:	50 40       	sbci	r21, 0x00	; 0
    b28c:	60 40       	sbci	r22, 0x00	; 0
    b28e:	70 40       	sbci	r23, 0x00	; 0
    b290:	88 0d       	add	r24, r8
    b292:	99 1d       	adc	r25, r9
    b294:	aa 1d       	adc	r26, r10
    b296:	bb 1d       	adc	r27, r11
    b298:	88 15       	cp	r24, r8
    b29a:	99 05       	cpc	r25, r9
    b29c:	aa 05       	cpc	r26, r10
    b29e:	bb 05       	cpc	r27, r11
    b2a0:	88 f0       	brcs	.+34     	; 0xb2c4 <__divdi3+0x7f8>
    b2a2:	80 17       	cp	r24, r16
    b2a4:	91 07       	cpc	r25, r17
    b2a6:	a2 07       	cpc	r26, r18
    b2a8:	b3 07       	cpc	r27, r19
    b2aa:	60 f4       	brcc	.+24     	; 0xb2c4 <__divdi3+0x7f8>
    b2ac:	49 a5       	lds	r20, 0x69
    b2ae:	5a a5       	lds	r21, 0x6a
    b2b0:	6b a5       	lds	r22, 0x6b
    b2b2:	7c a5       	lds	r23, 0x6c
    b2b4:	42 50       	subi	r20, 0x02	; 2
    b2b6:	50 40       	sbci	r21, 0x00	; 0
    b2b8:	60 40       	sbci	r22, 0x00	; 0
    b2ba:	70 40       	sbci	r23, 0x00	; 0
    b2bc:	88 0d       	add	r24, r8
    b2be:	99 1d       	adc	r25, r9
    b2c0:	aa 1d       	adc	r26, r10
    b2c2:	bb 1d       	adc	r27, r11
    b2c4:	6c 01       	movw	r12, r24
    b2c6:	7d 01       	movw	r14, r26
    b2c8:	c0 1a       	sub	r12, r16
    b2ca:	d1 0a       	sbc	r13, r17
    b2cc:	e2 0a       	sbc	r14, r18
    b2ce:	f3 0a       	sbc	r15, r19
    b2d0:	09 a9       	sts	0x49, r16
    b2d2:	1a a9       	sts	0x4a, r17
    b2d4:	2b a9       	sts	0x4b, r18
    b2d6:	3c a9       	sts	0x4c, r19
    b2d8:	38 01       	movw	r6, r16
    b2da:	55 24       	eor	r5, r5
    b2dc:	44 24       	eor	r4, r4
    b2de:	44 2a       	or	r4, r20
    b2e0:	55 2a       	or	r5, r21
    b2e2:	66 2a       	or	r6, r22
    b2e4:	77 2a       	or	r7, r23
    b2e6:	85 01       	movw	r16, r10
    b2e8:	22 27       	eor	r18, r18
    b2ea:	33 27       	eor	r19, r19
    b2ec:	0d a7       	lds	r16, 0x7d
    b2ee:	1e a7       	lds	r17, 0x7e
    b2f0:	2f a7       	lds	r18, 0x7f
    b2f2:	38 ab       	sts	0x58, r19
    b2f4:	95 01       	movw	r18, r10
    b2f6:	84 01       	movw	r16, r8
    b2f8:	20 70       	andi	r18, 0x00	; 0
    b2fa:	30 70       	andi	r19, 0x00	; 0
    b2fc:	09 af       	sts	0x79, r16
    b2fe:	1a af       	sts	0x7a, r17
    b300:	2b af       	sts	0x7b, r18
    b302:	3c af       	sts	0x7c, r19
    b304:	c7 01       	movw	r24, r14
    b306:	b6 01       	movw	r22, r12
    b308:	2d a5       	lds	r18, 0x6d
    b30a:	3e a5       	lds	r19, 0x6e
    b30c:	4f a5       	lds	r20, 0x6f
    b30e:	58 a9       	sts	0x48, r21
    b310:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    b314:	29 a7       	lds	r18, 0x79
    b316:	3a a7       	lds	r19, 0x7a
    b318:	4b a7       	lds	r20, 0x7b
    b31a:	5c a7       	lds	r21, 0x7c
    b31c:	69 ab       	sts	0x59, r22
    b31e:	7a ab       	sts	0x5a, r23
    b320:	8b ab       	sts	0x5b, r24
    b322:	9c ab       	sts	0x5c, r25
    b324:	c7 01       	movw	r24, r14
    b326:	b6 01       	movw	r22, r12
    b328:	2d a5       	lds	r18, 0x6d
    b32a:	3e a5       	lds	r19, 0x6e
    b32c:	4f a5       	lds	r20, 0x6f
    b32e:	58 a9       	sts	0x48, r21
    b330:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    b334:	ca 01       	movw	r24, r20
    b336:	b9 01       	movw	r22, r18
    b338:	29 ad       	sts	0x69, r18
    b33a:	3a ad       	sts	0x6a, r19
    b33c:	4b ad       	sts	0x6b, r20
    b33e:	5c ad       	sts	0x6c, r21
    b340:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    b344:	ab 01       	movw	r20, r22
    b346:	bc 01       	movw	r22, r24
    b348:	09 a9       	sts	0x49, r16
    b34a:	1a a9       	sts	0x4a, r17
    b34c:	2b a9       	sts	0x4b, r18
    b34e:	3c a9       	sts	0x4c, r19
    b350:	78 01       	movw	r14, r16
    b352:	dd 24       	eor	r13, r13
    b354:	cc 24       	eor	r12, r12
    b356:	0d a9       	sts	0x4d, r16
    b358:	1e a9       	sts	0x4e, r17
    b35a:	2f a9       	sts	0x4f, r18
    b35c:	38 ad       	sts	0x68, r19
    b35e:	c9 01       	movw	r24, r18
    b360:	aa 27       	eor	r26, r26
    b362:	bb 27       	eor	r27, r27
    b364:	c8 2a       	or	r12, r24
    b366:	d9 2a       	or	r13, r25
    b368:	ea 2a       	or	r14, r26
    b36a:	fb 2a       	or	r15, r27
    b36c:	09 a5       	lds	r16, 0x69
    b36e:	1a a5       	lds	r17, 0x6a
    b370:	2b a5       	lds	r18, 0x6b
    b372:	3c a5       	lds	r19, 0x6c
    b374:	c4 16       	cp	r12, r20
    b376:	d5 06       	cpc	r13, r21
    b378:	e6 06       	cpc	r14, r22
    b37a:	f7 06       	cpc	r15, r23
    b37c:	38 f5       	brcc	.+78     	; 0xb3cc <__divdi3+0x900>
    b37e:	01 50       	subi	r16, 0x01	; 1
    b380:	10 40       	sbci	r17, 0x00	; 0
    b382:	20 40       	sbci	r18, 0x00	; 0
    b384:	30 40       	sbci	r19, 0x00	; 0
    b386:	09 ab       	sts	0x59, r16
    b388:	1a ab       	sts	0x5a, r17
    b38a:	2b ab       	sts	0x5b, r18
    b38c:	3c ab       	sts	0x5c, r19
    b38e:	c8 0c       	add	r12, r8
    b390:	d9 1c       	adc	r13, r9
    b392:	ea 1c       	adc	r14, r10
    b394:	fb 1c       	adc	r15, r11
    b396:	c8 14       	cp	r12, r8
    b398:	d9 04       	cpc	r13, r9
    b39a:	ea 04       	cpc	r14, r10
    b39c:	fb 04       	cpc	r15, r11
    b39e:	d0 f0       	brcs	.+52     	; 0xb3d4 <__divdi3+0x908>
    b3a0:	c4 16       	cp	r12, r20
    b3a2:	d5 06       	cpc	r13, r21
    b3a4:	e6 06       	cpc	r14, r22
    b3a6:	f7 06       	cpc	r15, r23
    b3a8:	a8 f4       	brcc	.+42     	; 0xb3d4 <__divdi3+0x908>
    b3aa:	09 a5       	lds	r16, 0x69
    b3ac:	1a a5       	lds	r17, 0x6a
    b3ae:	2b a5       	lds	r18, 0x6b
    b3b0:	3c a5       	lds	r19, 0x6c
    b3b2:	02 50       	subi	r16, 0x02	; 2
    b3b4:	10 40       	sbci	r17, 0x00	; 0
    b3b6:	20 40       	sbci	r18, 0x00	; 0
    b3b8:	30 40       	sbci	r19, 0x00	; 0
    b3ba:	09 ab       	sts	0x59, r16
    b3bc:	1a ab       	sts	0x5a, r17
    b3be:	2b ab       	sts	0x5b, r18
    b3c0:	3c ab       	sts	0x5c, r19
    b3c2:	c8 0c       	add	r12, r8
    b3c4:	d9 1c       	adc	r13, r9
    b3c6:	ea 1c       	adc	r14, r10
    b3c8:	fb 1c       	adc	r15, r11
    b3ca:	04 c0       	rjmp	.+8      	; 0xb3d4 <__divdi3+0x908>
    b3cc:	09 ab       	sts	0x59, r16
    b3ce:	1a ab       	sts	0x5a, r17
    b3d0:	2b ab       	sts	0x5b, r18
    b3d2:	3c ab       	sts	0x5c, r19
    b3d4:	c4 1a       	sub	r12, r20
    b3d6:	d5 0a       	sbc	r13, r21
    b3d8:	e6 0a       	sbc	r14, r22
    b3da:	f7 0a       	sbc	r15, r23
    b3dc:	c7 01       	movw	r24, r14
    b3de:	b6 01       	movw	r22, r12
    b3e0:	2d a5       	lds	r18, 0x6d
    b3e2:	3e a5       	lds	r19, 0x6e
    b3e4:	4f a5       	lds	r20, 0x6f
    b3e6:	58 a9       	sts	0x48, r21
    b3e8:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    b3ec:	29 a7       	lds	r18, 0x79
    b3ee:	3a a7       	lds	r19, 0x7a
    b3f0:	4b a7       	lds	r20, 0x7b
    b3f2:	5c a7       	lds	r21, 0x7c
    b3f4:	21 96       	adiw	r28, 0x01	; 1
    b3f6:	6c af       	sts	0x7c, r22
    b3f8:	7d af       	sts	0x7d, r23
    b3fa:	8e af       	sts	0x7e, r24
    b3fc:	9f af       	sts	0x7f, r25
    b3fe:	21 97       	sbiw	r28, 0x01	; 1
    b400:	c7 01       	movw	r24, r14
    b402:	b6 01       	movw	r22, r12
    b404:	2d a5       	lds	r18, 0x6d
    b406:	3e a5       	lds	r19, 0x6e
    b408:	4f a5       	lds	r20, 0x6f
    b40a:	58 a9       	sts	0x48, r21
    b40c:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    b410:	ca 01       	movw	r24, r20
    b412:	b9 01       	movw	r22, r18
    b414:	29 ad       	sts	0x69, r18
    b416:	3a ad       	sts	0x6a, r19
    b418:	4b ad       	sts	0x6b, r20
    b41a:	5c ad       	sts	0x6c, r21
    b41c:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    b420:	8b 01       	movw	r16, r22
    b422:	9c 01       	movw	r18, r24
    b424:	21 96       	adiw	r28, 0x01	; 1
    b426:	4c ad       	sts	0x6c, r20
    b428:	5d ad       	sts	0x6d, r21
    b42a:	6e ad       	sts	0x6e, r22
    b42c:	7f ad       	sts	0x6f, r23
    b42e:	21 97       	sbiw	r28, 0x01	; 1
    b430:	da 01       	movw	r26, r20
    b432:	99 27       	eor	r25, r25
    b434:	88 27       	eor	r24, r24
    b436:	4d a9       	sts	0x4d, r20
    b438:	5e a9       	sts	0x4e, r21
    b43a:	6f a9       	sts	0x4f, r22
    b43c:	78 ad       	sts	0x68, r23
    b43e:	60 70       	andi	r22, 0x00	; 0
    b440:	70 70       	andi	r23, 0x00	; 0
    b442:	84 2b       	or	r24, r20
    b444:	95 2b       	or	r25, r21
    b446:	a6 2b       	or	r26, r22
    b448:	b7 2b       	or	r27, r23
    b44a:	49 a5       	lds	r20, 0x69
    b44c:	5a a5       	lds	r21, 0x6a
    b44e:	6b a5       	lds	r22, 0x6b
    b450:	7c a5       	lds	r23, 0x6c
    b452:	80 17       	cp	r24, r16
    b454:	91 07       	cpc	r25, r17
    b456:	a2 07       	cpc	r26, r18
    b458:	b3 07       	cpc	r27, r19
    b45a:	d0 f4       	brcc	.+52     	; 0xb490 <__divdi3+0x9c4>
    b45c:	41 50       	subi	r20, 0x01	; 1
    b45e:	50 40       	sbci	r21, 0x00	; 0
    b460:	60 40       	sbci	r22, 0x00	; 0
    b462:	70 40       	sbci	r23, 0x00	; 0
    b464:	88 0d       	add	r24, r8
    b466:	99 1d       	adc	r25, r9
    b468:	aa 1d       	adc	r26, r10
    b46a:	bb 1d       	adc	r27, r11
    b46c:	88 15       	cp	r24, r8
    b46e:	99 05       	cpc	r25, r9
    b470:	aa 05       	cpc	r26, r10
    b472:	bb 05       	cpc	r27, r11
    b474:	68 f0       	brcs	.+26     	; 0xb490 <__divdi3+0x9c4>
    b476:	80 17       	cp	r24, r16
    b478:	91 07       	cpc	r25, r17
    b47a:	a2 07       	cpc	r26, r18
    b47c:	b3 07       	cpc	r27, r19
    b47e:	40 f4       	brcc	.+16     	; 0xb490 <__divdi3+0x9c4>
    b480:	49 a5       	lds	r20, 0x69
    b482:	5a a5       	lds	r21, 0x6a
    b484:	6b a5       	lds	r22, 0x6b
    b486:	7c a5       	lds	r23, 0x6c
    b488:	42 50       	subi	r20, 0x02	; 2
    b48a:	50 40       	sbci	r21, 0x00	; 0
    b48c:	60 40       	sbci	r22, 0x00	; 0
    b48e:	70 40       	sbci	r23, 0x00	; 0
    b490:	09 a9       	sts	0x49, r16
    b492:	1a a9       	sts	0x4a, r17
    b494:	2b a9       	sts	0x4b, r18
    b496:	3c a9       	sts	0x4c, r19
    b498:	78 01       	movw	r14, r16
    b49a:	dd 24       	eor	r13, r13
    b49c:	cc 24       	eor	r12, r12
    b49e:	c4 2a       	or	r12, r20
    b4a0:	d5 2a       	or	r13, r21
    b4a2:	e6 2a       	or	r14, r22
    b4a4:	f7 2a       	or	r15, r23
    b4a6:	50 c2       	rjmp	.+1184   	; 0xb948 <__divdi3+0xe7c>
    b4a8:	c8 16       	cp	r12, r24
    b4aa:	d9 06       	cpc	r13, r25
    b4ac:	ea 06       	cpc	r14, r26
    b4ae:	fb 06       	cpc	r15, r27
    b4b0:	08 f4       	brcc	.+2      	; 0xb4b4 <__divdi3+0x9e8>
    b4b2:	37 c2       	rjmp	.+1134   	; 0xb922 <__divdi3+0xe56>
    b4b4:	80 30       	cpi	r24, 0x00	; 0
    b4b6:	10 e0       	ldi	r17, 0x00	; 0
    b4b8:	91 07       	cpc	r25, r17
    b4ba:	11 e0       	ldi	r17, 0x01	; 1
    b4bc:	a1 07       	cpc	r26, r17
    b4be:	10 e0       	ldi	r17, 0x00	; 0
    b4c0:	b1 07       	cpc	r27, r17
    b4c2:	50 f4       	brcc	.+20     	; 0xb4d8 <__divdi3+0xa0c>
    b4c4:	8f 3f       	cpi	r24, 0xFF	; 255
    b4c6:	91 05       	cpc	r25, r1
    b4c8:	a1 05       	cpc	r26, r1
    b4ca:	b1 05       	cpc	r27, r1
    b4cc:	09 f0       	breq	.+2      	; 0xb4d0 <__divdi3+0xa04>
    b4ce:	88 f4       	brcc	.+34     	; 0xb4f2 <__divdi3+0xa26>
    b4d0:	00 e0       	ldi	r16, 0x00	; 0
    b4d2:	10 e0       	ldi	r17, 0x00	; 0
    b4d4:	98 01       	movw	r18, r16
    b4d6:	16 c0       	rjmp	.+44     	; 0xb504 <__divdi3+0xa38>
    b4d8:	80 30       	cpi	r24, 0x00	; 0
    b4da:	20 e0       	ldi	r18, 0x00	; 0
    b4dc:	92 07       	cpc	r25, r18
    b4de:	20 e0       	ldi	r18, 0x00	; 0
    b4e0:	a2 07       	cpc	r26, r18
    b4e2:	21 e0       	ldi	r18, 0x01	; 1
    b4e4:	b2 07       	cpc	r27, r18
    b4e6:	50 f4       	brcc	.+20     	; 0xb4fc <__divdi3+0xa30>
    b4e8:	00 e1       	ldi	r16, 0x10	; 16
    b4ea:	10 e0       	ldi	r17, 0x00	; 0
    b4ec:	20 e0       	ldi	r18, 0x00	; 0
    b4ee:	30 e0       	ldi	r19, 0x00	; 0
    b4f0:	09 c0       	rjmp	.+18     	; 0xb504 <__divdi3+0xa38>
    b4f2:	08 e0       	ldi	r16, 0x08	; 8
    b4f4:	10 e0       	ldi	r17, 0x00	; 0
    b4f6:	20 e0       	ldi	r18, 0x00	; 0
    b4f8:	30 e0       	ldi	r19, 0x00	; 0
    b4fa:	04 c0       	rjmp	.+8      	; 0xb504 <__divdi3+0xa38>
    b4fc:	08 e1       	ldi	r16, 0x18	; 24
    b4fe:	10 e0       	ldi	r17, 0x00	; 0
    b500:	20 e0       	ldi	r18, 0x00	; 0
    b502:	30 e0       	ldi	r19, 0x00	; 0
    b504:	ac 01       	movw	r20, r24
    b506:	bd 01       	movw	r22, r26
    b508:	00 2e       	mov	r0, r16
    b50a:	04 c0       	rjmp	.+8      	; 0xb514 <__divdi3+0xa48>
    b50c:	76 95       	lsr	r23
    b50e:	67 95       	ror	r22
    b510:	57 95       	ror	r21
    b512:	47 95       	ror	r20
    b514:	0a 94       	dec	r0
    b516:	d2 f7       	brpl	.-12     	; 0xb50c <__divdi3+0xa40>
    b518:	fa 01       	movw	r30, r20
    b51a:	e6 5c       	subi	r30, 0xC6	; 198
    b51c:	ff 4d       	sbci	r31, 0xDF	; 223
    b51e:	40 81       	ld	r20, Z
    b520:	04 0f       	add	r16, r20
    b522:	11 1d       	adc	r17, r1
    b524:	21 1d       	adc	r18, r1
    b526:	31 1d       	adc	r19, r1
    b528:	40 e2       	ldi	r20, 0x20	; 32
    b52a:	50 e0       	ldi	r21, 0x00	; 0
    b52c:	60 e0       	ldi	r22, 0x00	; 0
    b52e:	70 e0       	ldi	r23, 0x00	; 0
    b530:	40 1b       	sub	r20, r16
    b532:	51 0b       	sbc	r21, r17
    b534:	62 0b       	sbc	r22, r18
    b536:	73 0b       	sbc	r23, r19
    b538:	a1 f4       	brne	.+40     	; 0xb562 <__divdi3+0xa96>
    b53a:	8c 15       	cp	r24, r12
    b53c:	9d 05       	cpc	r25, r13
    b53e:	ae 05       	cpc	r26, r14
    b540:	bf 05       	cpc	r27, r15
    b542:	08 f4       	brcc	.+2      	; 0xb546 <__divdi3+0xa7a>
    b544:	f5 c1       	rjmp	.+1002   	; 0xb930 <__divdi3+0xe64>
    b546:	ed a8       	sts	0x8d, r30
    b548:	fe a8       	sts	0x8e, r31
    b54a:	0f a9       	sts	0x4f, r16
    b54c:	18 ad       	sts	0x68, r17
    b54e:	44 24       	eor	r4, r4
    b550:	55 24       	eor	r5, r5
    b552:	32 01       	movw	r6, r4
    b554:	e8 14       	cp	r14, r8
    b556:	f9 04       	cpc	r15, r9
    b558:	0a 05       	cpc	r16, r10
    b55a:	1b 05       	cpc	r17, r11
    b55c:	08 f0       	brcs	.+2      	; 0xb560 <__divdi3+0xa94>
    b55e:	eb c1       	rjmp	.+982    	; 0xb936 <__divdi3+0xe6a>
    b560:	e3 c1       	rjmp	.+966    	; 0xb928 <__divdi3+0xe5c>
    b562:	34 2e       	mov	r3, r20
    b564:	2c 01       	movw	r4, r24
    b566:	3d 01       	movw	r6, r26
    b568:	04 c0       	rjmp	.+8      	; 0xb572 <__divdi3+0xaa6>
    b56a:	44 0c       	add	r4, r4
    b56c:	55 1c       	adc	r5, r5
    b56e:	66 1c       	adc	r6, r6
    b570:	77 1c       	adc	r7, r7
    b572:	4a 95       	dec	r20
    b574:	d2 f7       	brpl	.-12     	; 0xb56a <__divdi3+0xa9e>
    b576:	d5 01       	movw	r26, r10
    b578:	c4 01       	movw	r24, r8
    b57a:	00 2e       	mov	r0, r16
    b57c:	04 c0       	rjmp	.+8      	; 0xb586 <__divdi3+0xaba>
    b57e:	b6 95       	lsr	r27
    b580:	a7 95       	ror	r26
    b582:	97 95       	ror	r25
    b584:	87 95       	ror	r24
    b586:	0a 94       	dec	r0
    b588:	d2 f7       	brpl	.-12     	; 0xb57e <__divdi3+0xab2>
    b58a:	48 2a       	or	r4, r24
    b58c:	59 2a       	or	r5, r25
    b58e:	6a 2a       	or	r6, r26
    b590:	7b 2a       	or	r7, r27
    b592:	a5 01       	movw	r20, r10
    b594:	94 01       	movw	r18, r8
    b596:	03 2c       	mov	r0, r3
    b598:	04 c0       	rjmp	.+8      	; 0xb5a2 <__divdi3+0xad6>
    b59a:	22 0f       	add	r18, r18
    b59c:	33 1f       	adc	r19, r19
    b59e:	44 1f       	adc	r20, r20
    b5a0:	55 1f       	adc	r21, r21
    b5a2:	0a 94       	dec	r0
    b5a4:	d2 f7       	brpl	.-12     	; 0xb59a <__divdi3+0xace>
    b5a6:	29 af       	sts	0x79, r18
    b5a8:	3a af       	sts	0x7a, r19
    b5aa:	4b af       	sts	0x7b, r20
    b5ac:	5c af       	sts	0x7c, r21
    b5ae:	b7 01       	movw	r22, r14
    b5b0:	a6 01       	movw	r20, r12
    b5b2:	00 2e       	mov	r0, r16
    b5b4:	04 c0       	rjmp	.+8      	; 0xb5be <__divdi3+0xaf2>
    b5b6:	76 95       	lsr	r23
    b5b8:	67 95       	ror	r22
    b5ba:	57 95       	ror	r21
    b5bc:	47 95       	ror	r20
    b5be:	0a 94       	dec	r0
    b5c0:	d2 f7       	brpl	.-12     	; 0xb5b6 <__divdi3+0xaea>
    b5c2:	49 ab       	sts	0x59, r20
    b5c4:	5a ab       	sts	0x5a, r21
    b5c6:	6b ab       	sts	0x5b, r22
    b5c8:	7c ab       	sts	0x5c, r23
    b5ca:	c7 01       	movw	r24, r14
    b5cc:	b6 01       	movw	r22, r12
    b5ce:	03 2c       	mov	r0, r3
    b5d0:	04 c0       	rjmp	.+8      	; 0xb5da <__divdi3+0xb0e>
    b5d2:	66 0f       	add	r22, r22
    b5d4:	77 1f       	adc	r23, r23
    b5d6:	88 1f       	adc	r24, r24
    b5d8:	99 1f       	adc	r25, r25
    b5da:	0a 94       	dec	r0
    b5dc:	d2 f7       	brpl	.-12     	; 0xb5d2 <__divdi3+0xb06>
    b5de:	6d a7       	lds	r22, 0x7d
    b5e0:	7e a7       	lds	r23, 0x7e
    b5e2:	8f a7       	lds	r24, 0x7f
    b5e4:	98 ab       	sts	0x58, r25
    b5e6:	8d a9       	sts	0x4d, r24
    b5e8:	9e a9       	sts	0x4e, r25
    b5ea:	af a9       	sts	0x4f, r26
    b5ec:	b8 ad       	sts	0x68, r27
    b5ee:	04 c0       	rjmp	.+8      	; 0xb5f8 <__divdi3+0xb2c>
    b5f0:	b6 95       	lsr	r27
    b5f2:	a7 95       	ror	r26
    b5f4:	97 95       	ror	r25
    b5f6:	87 95       	ror	r24
    b5f8:	0a 95       	dec	r16
    b5fa:	d2 f7       	brpl	.-12     	; 0xb5f0 <__divdi3+0xb24>
    b5fc:	4d a5       	lds	r20, 0x6d
    b5fe:	5e a5       	lds	r21, 0x6e
    b600:	6f a5       	lds	r22, 0x6f
    b602:	78 a9       	sts	0x48, r23
    b604:	48 2b       	or	r20, r24
    b606:	59 2b       	or	r21, r25
    b608:	6a 2b       	or	r22, r26
    b60a:	7b 2b       	or	r23, r27
    b60c:	4d a7       	lds	r20, 0x7d
    b60e:	5e a7       	lds	r21, 0x7e
    b610:	6f a7       	lds	r22, 0x7f
    b612:	78 ab       	sts	0x58, r23
    b614:	43 01       	movw	r8, r6
    b616:	aa 24       	eor	r10, r10
    b618:	bb 24       	eor	r11, r11
    b61a:	93 01       	movw	r18, r6
    b61c:	82 01       	movw	r16, r4
    b61e:	20 70       	andi	r18, 0x00	; 0
    b620:	30 70       	andi	r19, 0x00	; 0
    b622:	21 96       	adiw	r28, 0x01	; 1
    b624:	0c af       	sts	0x7c, r16
    b626:	1d af       	sts	0x7d, r17
    b628:	2e af       	sts	0x7e, r18
    b62a:	3f af       	sts	0x7f, r19
    b62c:	21 97       	sbiw	r28, 0x01	; 1
    b62e:	69 a9       	sts	0x49, r22
    b630:	7a a9       	sts	0x4a, r23
    b632:	8b a9       	sts	0x4b, r24
    b634:	9c a9       	sts	0x4c, r25
    b636:	a5 01       	movw	r20, r10
    b638:	94 01       	movw	r18, r8
    b63a:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    b63e:	29 a7       	lds	r18, 0x79
    b640:	3a a7       	lds	r19, 0x7a
    b642:	4b a7       	lds	r20, 0x7b
    b644:	5c a7       	lds	r21, 0x7c
    b646:	6b 01       	movw	r12, r22
    b648:	7c 01       	movw	r14, r24
    b64a:	69 a9       	sts	0x49, r22
    b64c:	7a a9       	sts	0x4a, r23
    b64e:	8b a9       	sts	0x4b, r24
    b650:	9c a9       	sts	0x4c, r25
    b652:	a5 01       	movw	r20, r10
    b654:	94 01       	movw	r18, r8
    b656:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    b65a:	ca 01       	movw	r24, r20
    b65c:	b9 01       	movw	r22, r18
    b65e:	21 96       	adiw	r28, 0x01	; 1
    b660:	2c ad       	sts	0x6c, r18
    b662:	3d ad       	sts	0x6d, r19
    b664:	4e ad       	sts	0x6e, r20
    b666:	5f ad       	sts	0x6f, r21
    b668:	21 97       	sbiw	r28, 0x01	; 1
    b66a:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    b66e:	dc 01       	movw	r26, r24
    b670:	cb 01       	movw	r24, r22
    b672:	76 01       	movw	r14, r12
    b674:	dd 24       	eor	r13, r13
    b676:	cc 24       	eor	r12, r12
    b678:	0d a5       	lds	r16, 0x6d
    b67a:	1e a5       	lds	r17, 0x6e
    b67c:	2f a5       	lds	r18, 0x6f
    b67e:	38 a9       	sts	0x48, r19
    b680:	a9 01       	movw	r20, r18
    b682:	66 27       	eor	r22, r22
    b684:	77 27       	eor	r23, r23
    b686:	c4 2a       	or	r12, r20
    b688:	d5 2a       	or	r13, r21
    b68a:	e6 2a       	or	r14, r22
    b68c:	f7 2a       	or	r15, r23
    b68e:	09 a5       	lds	r16, 0x69
    b690:	1a a5       	lds	r17, 0x6a
    b692:	2b a5       	lds	r18, 0x6b
    b694:	3c a5       	lds	r19, 0x6c
    b696:	c8 16       	cp	r12, r24
    b698:	d9 06       	cpc	r13, r25
    b69a:	ea 06       	cpc	r14, r26
    b69c:	fb 06       	cpc	r15, r27
    b69e:	38 f5       	brcc	.+78     	; 0xb6ee <__divdi3+0xc22>
    b6a0:	01 50       	subi	r16, 0x01	; 1
    b6a2:	10 40       	sbci	r17, 0x00	; 0
    b6a4:	20 40       	sbci	r18, 0x00	; 0
    b6a6:	30 40       	sbci	r19, 0x00	; 0
    b6a8:	09 ab       	sts	0x59, r16
    b6aa:	1a ab       	sts	0x5a, r17
    b6ac:	2b ab       	sts	0x5b, r18
    b6ae:	3c ab       	sts	0x5c, r19
    b6b0:	c4 0c       	add	r12, r4
    b6b2:	d5 1c       	adc	r13, r5
    b6b4:	e6 1c       	adc	r14, r6
    b6b6:	f7 1c       	adc	r15, r7
    b6b8:	c4 14       	cp	r12, r4
    b6ba:	d5 04       	cpc	r13, r5
    b6bc:	e6 04       	cpc	r14, r6
    b6be:	f7 04       	cpc	r15, r7
    b6c0:	d0 f0       	brcs	.+52     	; 0xb6f6 <__divdi3+0xc2a>
    b6c2:	c8 16       	cp	r12, r24
    b6c4:	d9 06       	cpc	r13, r25
    b6c6:	ea 06       	cpc	r14, r26
    b6c8:	fb 06       	cpc	r15, r27
    b6ca:	a8 f4       	brcc	.+42     	; 0xb6f6 <__divdi3+0xc2a>
    b6cc:	09 a5       	lds	r16, 0x69
    b6ce:	1a a5       	lds	r17, 0x6a
    b6d0:	2b a5       	lds	r18, 0x6b
    b6d2:	3c a5       	lds	r19, 0x6c
    b6d4:	02 50       	subi	r16, 0x02	; 2
    b6d6:	10 40       	sbci	r17, 0x00	; 0
    b6d8:	20 40       	sbci	r18, 0x00	; 0
    b6da:	30 40       	sbci	r19, 0x00	; 0
    b6dc:	09 ab       	sts	0x59, r16
    b6de:	1a ab       	sts	0x5a, r17
    b6e0:	2b ab       	sts	0x5b, r18
    b6e2:	3c ab       	sts	0x5c, r19
    b6e4:	c4 0c       	add	r12, r4
    b6e6:	d5 1c       	adc	r13, r5
    b6e8:	e6 1c       	adc	r14, r6
    b6ea:	f7 1c       	adc	r15, r7
    b6ec:	04 c0       	rjmp	.+8      	; 0xb6f6 <__divdi3+0xc2a>
    b6ee:	09 ab       	sts	0x59, r16
    b6f0:	1a ab       	sts	0x5a, r17
    b6f2:	2b ab       	sts	0x5b, r18
    b6f4:	3c ab       	sts	0x5c, r19
    b6f6:	c8 1a       	sub	r12, r24
    b6f8:	d9 0a       	sbc	r13, r25
    b6fa:	ea 0a       	sbc	r14, r26
    b6fc:	fb 0a       	sbc	r15, r27
    b6fe:	c7 01       	movw	r24, r14
    b700:	b6 01       	movw	r22, r12
    b702:	a5 01       	movw	r20, r10
    b704:	94 01       	movw	r18, r8
    b706:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    b70a:	29 a7       	lds	r18, 0x79
    b70c:	3a a7       	lds	r19, 0x7a
    b70e:	4b a7       	lds	r20, 0x7b
    b710:	5c a7       	lds	r21, 0x7c
    b712:	29 96       	adiw	r28, 0x09	; 9
    b714:	6c af       	sts	0x7c, r22
    b716:	7d af       	sts	0x7d, r23
    b718:	8e af       	sts	0x7e, r24
    b71a:	9f af       	sts	0x7f, r25
    b71c:	29 97       	sbiw	r28, 0x09	; 9
    b71e:	c7 01       	movw	r24, r14
    b720:	b6 01       	movw	r22, r12
    b722:	a5 01       	movw	r20, r10
    b724:	94 01       	movw	r18, r8
    b726:	0e 94 dc 5e 	call	0xbdb8	; 0xbdb8 <__udivmodsi4>
    b72a:	ca 01       	movw	r24, r20
    b72c:	b9 01       	movw	r22, r18
    b72e:	21 96       	adiw	r28, 0x01	; 1
    b730:	2c ad       	sts	0x6c, r18
    b732:	3d ad       	sts	0x6d, r19
    b734:	4e ad       	sts	0x6e, r20
    b736:	5f ad       	sts	0x6f, r21
    b738:	21 97       	sbiw	r28, 0x01	; 1
    b73a:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    b73e:	4b 01       	movw	r8, r22
    b740:	5c 01       	movw	r10, r24
    b742:	29 96       	adiw	r28, 0x09	; 9
    b744:	4c ad       	sts	0x6c, r20
    b746:	5d ad       	sts	0x6d, r21
    b748:	6e ad       	sts	0x6e, r22
    b74a:	7f ad       	sts	0x6f, r23
    b74c:	29 97       	sbiw	r28, 0x09	; 9
    b74e:	9a 01       	movw	r18, r20
    b750:	11 27       	eor	r17, r17
    b752:	00 27       	eor	r16, r16
    b754:	8d a5       	lds	r24, 0x6d
    b756:	9e a5       	lds	r25, 0x6e
    b758:	af a5       	lds	r26, 0x6f
    b75a:	b8 a9       	sts	0x48, r27
    b75c:	a0 70       	andi	r26, 0x00	; 0
    b75e:	b0 70       	andi	r27, 0x00	; 0
    b760:	08 2b       	or	r16, r24
    b762:	19 2b       	or	r17, r25
    b764:	2a 2b       	or	r18, r26
    b766:	3b 2b       	or	r19, r27
    b768:	89 a5       	lds	r24, 0x69
    b76a:	9a a5       	lds	r25, 0x6a
    b76c:	ab a5       	lds	r26, 0x6b
    b76e:	bc a5       	lds	r27, 0x6c
    b770:	08 15       	cp	r16, r8
    b772:	19 05       	cpc	r17, r9
    b774:	2a 05       	cpc	r18, r10
    b776:	3b 05       	cpc	r19, r11
    b778:	e0 f4       	brcc	.+56     	; 0xb7b2 <__divdi3+0xce6>
    b77a:	01 97       	sbiw	r24, 0x01	; 1
    b77c:	a1 09       	sbc	r26, r1
    b77e:	b1 09       	sbc	r27, r1
    b780:	04 0d       	add	r16, r4
    b782:	15 1d       	adc	r17, r5
    b784:	26 1d       	adc	r18, r6
    b786:	37 1d       	adc	r19, r7
    b788:	04 15       	cp	r16, r4
    b78a:	15 05       	cpc	r17, r5
    b78c:	26 05       	cpc	r18, r6
    b78e:	37 05       	cpc	r19, r7
    b790:	80 f0       	brcs	.+32     	; 0xb7b2 <__divdi3+0xce6>
    b792:	08 15       	cp	r16, r8
    b794:	19 05       	cpc	r17, r9
    b796:	2a 05       	cpc	r18, r10
    b798:	3b 05       	cpc	r19, r11
    b79a:	58 f4       	brcc	.+22     	; 0xb7b2 <__divdi3+0xce6>
    b79c:	89 a5       	lds	r24, 0x69
    b79e:	9a a5       	lds	r25, 0x6a
    b7a0:	ab a5       	lds	r26, 0x6b
    b7a2:	bc a5       	lds	r27, 0x6c
    b7a4:	02 97       	sbiw	r24, 0x02	; 2
    b7a6:	a1 09       	sbc	r26, r1
    b7a8:	b1 09       	sbc	r27, r1
    b7aa:	04 0d       	add	r16, r4
    b7ac:	15 1d       	adc	r17, r5
    b7ae:	26 1d       	adc	r18, r6
    b7b0:	37 1d       	adc	r19, r7
    b7b2:	b9 01       	movw	r22, r18
    b7b4:	a8 01       	movw	r20, r16
    b7b6:	48 19       	sub	r20, r8
    b7b8:	59 09       	sbc	r21, r9
    b7ba:	6a 09       	sbc	r22, r10
    b7bc:	7b 09       	sbc	r23, r11
    b7be:	4d a7       	lds	r20, 0x7d
    b7c0:	5e a7       	lds	r21, 0x7e
    b7c2:	6f a7       	lds	r22, 0x7f
    b7c4:	78 ab       	sts	0x58, r23
    b7c6:	09 a9       	sts	0x49, r16
    b7c8:	1a a9       	sts	0x4a, r17
    b7ca:	2b a9       	sts	0x4b, r18
    b7cc:	3c a9       	sts	0x4c, r19
    b7ce:	78 01       	movw	r14, r16
    b7d0:	dd 24       	eor	r13, r13
    b7d2:	cc 24       	eor	r12, r12
    b7d4:	c8 2a       	or	r12, r24
    b7d6:	d9 2a       	or	r13, r25
    b7d8:	ea 2a       	or	r14, r26
    b7da:	fb 2a       	or	r15, r27
    b7dc:	ff ef       	ldi	r31, 0xFF	; 255
    b7de:	8f 2e       	mov	r8, r31
    b7e0:	ff ef       	ldi	r31, 0xFF	; 255
    b7e2:	9f 2e       	mov	r9, r31
    b7e4:	a1 2c       	mov	r10, r1
    b7e6:	b1 2c       	mov	r11, r1
    b7e8:	8c 20       	and	r8, r12
    b7ea:	9d 20       	and	r9, r13
    b7ec:	ae 20       	and	r10, r14
    b7ee:	bf 20       	and	r11, r15
    b7f0:	87 01       	movw	r16, r14
    b7f2:	22 27       	eor	r18, r18
    b7f4:	33 27       	eor	r19, r19
    b7f6:	09 a7       	lds	r16, 0x79
    b7f8:	1a a7       	lds	r17, 0x7a
    b7fa:	2b a7       	lds	r18, 0x7b
    b7fc:	3c a7       	lds	r19, 0x7c
    b7fe:	49 ac       	sts	0xa9, r20
    b800:	5a ac       	sts	0xaa, r21
    b802:	6b ac       	sts	0xab, r22
    b804:	7c ac       	sts	0xac, r23
    b806:	2f ef       	ldi	r18, 0xFF	; 255
    b808:	3f ef       	ldi	r19, 0xFF	; 255
    b80a:	40 e0       	ldi	r20, 0x00	; 0
    b80c:	50 e0       	ldi	r21, 0x00	; 0
    b80e:	42 22       	and	r4, r18
    b810:	53 22       	and	r5, r19
    b812:	64 22       	and	r6, r20
    b814:	75 22       	and	r7, r21
    b816:	29 ad       	sts	0x69, r18
    b818:	3a ad       	sts	0x6a, r19
    b81a:	4b ad       	sts	0x6b, r20
    b81c:	5c ad       	sts	0x6c, r21
    b81e:	8a 01       	movw	r16, r20
    b820:	22 27       	eor	r18, r18
    b822:	33 27       	eor	r19, r19
    b824:	09 ab       	sts	0x59, r16
    b826:	1a ab       	sts	0x5a, r17
    b828:	2b ab       	sts	0x5b, r18
    b82a:	3c ab       	sts	0x5c, r19
    b82c:	c5 01       	movw	r24, r10
    b82e:	b4 01       	movw	r22, r8
    b830:	a3 01       	movw	r20, r6
    b832:	92 01       	movw	r18, r4
    b834:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    b838:	69 af       	sts	0x79, r22
    b83a:	7a af       	sts	0x7a, r23
    b83c:	8b af       	sts	0x7b, r24
    b83e:	9c af       	sts	0x7c, r25
    b840:	c5 01       	movw	r24, r10
    b842:	b4 01       	movw	r22, r8
    b844:	29 a9       	sts	0x49, r18
    b846:	3a a9       	sts	0x4a, r19
    b848:	4b a9       	sts	0x4b, r20
    b84a:	5c a9       	sts	0x4c, r21
    b84c:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    b850:	4b 01       	movw	r8, r22
    b852:	5c 01       	movw	r10, r24
    b854:	69 a5       	lds	r22, 0x69
    b856:	7a a5       	lds	r23, 0x6a
    b858:	8b a5       	lds	r24, 0x6b
    b85a:	9c a5       	lds	r25, 0x6c
    b85c:	a3 01       	movw	r20, r6
    b85e:	92 01       	movw	r18, r4
    b860:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    b864:	2b 01       	movw	r4, r22
    b866:	3c 01       	movw	r6, r24
    b868:	69 a5       	lds	r22, 0x69
    b86a:	7a a5       	lds	r23, 0x6a
    b86c:	8b a5       	lds	r24, 0x6b
    b86e:	9c a5       	lds	r25, 0x6c
    b870:	29 a9       	sts	0x49, r18
    b872:	3a a9       	sts	0x4a, r19
    b874:	4b a9       	sts	0x4b, r20
    b876:	5c a9       	sts	0x4c, r21
    b878:	0e 94 96 5e 	call	0xbd2c	; 0xbd2c <__mulsi3>
    b87c:	ab 01       	movw	r20, r22
    b87e:	bc 01       	movw	r22, r24
    b880:	84 0c       	add	r8, r4
    b882:	95 1c       	adc	r9, r5
    b884:	a6 1c       	adc	r10, r6
    b886:	b7 1c       	adc	r11, r7
    b888:	09 ad       	sts	0x69, r16
    b88a:	1a ad       	sts	0x6a, r17
    b88c:	2b ad       	sts	0x6b, r18
    b88e:	3c ad       	sts	0x6c, r19
    b890:	c9 01       	movw	r24, r18
    b892:	aa 27       	eor	r26, r26
    b894:	bb 27       	eor	r27, r27
    b896:	88 0e       	add	r8, r24
    b898:	99 1e       	adc	r9, r25
    b89a:	aa 1e       	adc	r10, r26
    b89c:	bb 1e       	adc	r11, r27
    b89e:	84 14       	cp	r8, r4
    b8a0:	95 04       	cpc	r9, r5
    b8a2:	a6 04       	cpc	r10, r6
    b8a4:	b7 04       	cpc	r11, r7
    b8a6:	20 f4       	brcc	.+8      	; 0xb8b0 <__divdi3+0xde4>
    b8a8:	40 50       	subi	r20, 0x00	; 0
    b8aa:	50 40       	sbci	r21, 0x00	; 0
    b8ac:	6f 4f       	sbci	r22, 0xFF	; 255
    b8ae:	7f 4f       	sbci	r23, 0xFF	; 255
    b8b0:	c5 01       	movw	r24, r10
    b8b2:	aa 27       	eor	r26, r26
    b8b4:	bb 27       	eor	r27, r27
    b8b6:	84 0f       	add	r24, r20
    b8b8:	95 1f       	adc	r25, r21
    b8ba:	a6 1f       	adc	r26, r22
    b8bc:	b7 1f       	adc	r27, r23
    b8be:	0d a5       	lds	r16, 0x6d
    b8c0:	1e a5       	lds	r17, 0x6e
    b8c2:	2f a5       	lds	r18, 0x6f
    b8c4:	38 a9       	sts	0x48, r19
    b8c6:	08 17       	cp	r16, r24
    b8c8:	19 07       	cpc	r17, r25
    b8ca:	2a 07       	cpc	r18, r26
    b8cc:	3b 07       	cpc	r19, r27
    b8ce:	18 f1       	brcs	.+70     	; 0xb916 <__divdi3+0xe4a>
    b8d0:	80 17       	cp	r24, r16
    b8d2:	91 07       	cpc	r25, r17
    b8d4:	a2 07       	cpc	r26, r18
    b8d6:	b3 07       	cpc	r27, r19
    b8d8:	a1 f5       	brne	.+104    	; 0xb942 <__divdi3+0xe76>
    b8da:	54 01       	movw	r10, r8
    b8dc:	99 24       	eor	r9, r9
    b8de:	88 24       	eor	r8, r8
    b8e0:	89 ad       	sts	0x69, r24
    b8e2:	9a ad       	sts	0x6a, r25
    b8e4:	ab ad       	sts	0x6b, r26
    b8e6:	bc ad       	sts	0x6c, r27
    b8e8:	a0 70       	andi	r26, 0x00	; 0
    b8ea:	b0 70       	andi	r27, 0x00	; 0
    b8ec:	88 0e       	add	r8, r24
    b8ee:	99 1e       	adc	r9, r25
    b8f0:	aa 1e       	adc	r10, r26
    b8f2:	bb 1e       	adc	r11, r27
    b8f4:	4d a9       	sts	0x4d, r20
    b8f6:	5e a9       	sts	0x4e, r21
    b8f8:	6f a9       	sts	0x4f, r22
    b8fa:	78 ad       	sts	0x68, r23
    b8fc:	03 2c       	mov	r0, r3
    b8fe:	04 c0       	rjmp	.+8      	; 0xb908 <__divdi3+0xe3c>
    b900:	44 0f       	add	r20, r20
    b902:	55 1f       	adc	r21, r21
    b904:	66 1f       	adc	r22, r22
    b906:	77 1f       	adc	r23, r23
    b908:	0a 94       	dec	r0
    b90a:	d2 f7       	brpl	.-12     	; 0xb900 <__divdi3+0xe34>
    b90c:	48 15       	cp	r20, r8
    b90e:	59 05       	cpc	r21, r9
    b910:	6a 05       	cpc	r22, r10
    b912:	7b 05       	cpc	r23, r11
    b914:	b0 f4       	brcc	.+44     	; 0xb942 <__divdi3+0xe76>
    b916:	08 94       	sec
    b918:	c1 08       	sbc	r12, r1
    b91a:	d1 08       	sbc	r13, r1
    b91c:	e1 08       	sbc	r14, r1
    b91e:	f1 08       	sbc	r15, r1
    b920:	10 c0       	rjmp	.+32     	; 0xb942 <__divdi3+0xe76>
    b922:	44 24       	eor	r4, r4
    b924:	55 24       	eor	r5, r5
    b926:	32 01       	movw	r6, r4
    b928:	cc 24       	eor	r12, r12
    b92a:	dd 24       	eor	r13, r13
    b92c:	76 01       	movw	r14, r12
    b92e:	0c c0       	rjmp	.+24     	; 0xb948 <__divdi3+0xe7c>
    b930:	44 24       	eor	r4, r4
    b932:	55 24       	eor	r5, r5
    b934:	32 01       	movw	r6, r4
    b936:	81 e0       	ldi	r24, 0x01	; 1
    b938:	c8 2e       	mov	r12, r24
    b93a:	d1 2c       	mov	r13, r1
    b93c:	e1 2c       	mov	r14, r1
    b93e:	f1 2c       	mov	r15, r1
    b940:	03 c0       	rjmp	.+6      	; 0xb948 <__divdi3+0xe7c>
    b942:	44 24       	eor	r4, r4
    b944:	55 24       	eor	r5, r5
    b946:	32 01       	movw	r6, r4
    b948:	fe 01       	movw	r30, r28
    b94a:	31 96       	adiw	r30, 0x01	; 1
    b94c:	88 e0       	ldi	r24, 0x08	; 8
    b94e:	df 01       	movw	r26, r30
    b950:	1d 92       	st	X+, r1
    b952:	8a 95       	dec	r24
    b954:	e9 f7       	brne	.-6      	; 0xb950 <__divdi3+0xe84>
    b956:	c9 82       	std	Y+1, r12	; 0x01
    b958:	da 82       	std	Y+2, r13	; 0x02
    b95a:	eb 82       	std	Y+3, r14	; 0x03
    b95c:	fc 82       	std	Y+4, r15	; 0x04
    b95e:	4d 82       	std	Y+5, r4	; 0x05
    b960:	5e 82       	std	Y+6, r5	; 0x06
    b962:	6f 82       	std	Y+7, r6	; 0x07
    b964:	78 86       	std	Y+8, r7	; 0x08
    b966:	2c 2d       	mov	r18, r12
    b968:	3a 81       	ldd	r19, Y+2	; 0x02
    b96a:	4b 81       	ldd	r20, Y+3	; 0x03
    b96c:	5c 81       	ldd	r21, Y+4	; 0x04
    b96e:	64 2d       	mov	r22, r4
    b970:	7e 81       	ldd	r23, Y+6	; 0x06
    b972:	8f 81       	ldd	r24, Y+7	; 0x07
    b974:	98 85       	ldd	r25, Y+8	; 0x08
    b976:	25 96       	adiw	r28, 0x05	; 5
    b978:	ec ac       	sts	0xac, r30
    b97a:	fd ac       	sts	0xad, r31
    b97c:	0e ad       	sts	0x6e, r16
    b97e:	1f ad       	sts	0x6f, r17
    b980:	25 97       	sbiw	r28, 0x05	; 5
    b982:	e1 14       	cp	r14, r1
    b984:	f1 04       	cpc	r15, r1
    b986:	01 05       	cpc	r16, r1
    b988:	11 05       	cpc	r17, r1
    b98a:	09 f4       	brne	.+2      	; 0xb98e <__divdi3+0xec2>
    b98c:	56 c0       	rjmp	.+172    	; 0xba3a <__divdi3+0xf6e>
    b98e:	21 95       	neg	r18
    b990:	e1 e0       	ldi	r30, 0x01	; 1
    b992:	12 16       	cp	r1, r18
    b994:	08 f0       	brcs	.+2      	; 0xb998 <__divdi3+0xecc>
    b996:	e0 e0       	ldi	r30, 0x00	; 0
    b998:	31 95       	neg	r19
    b99a:	f1 e0       	ldi	r31, 0x01	; 1
    b99c:	13 16       	cp	r1, r19
    b99e:	08 f0       	brcs	.+2      	; 0xb9a2 <__divdi3+0xed6>
    b9a0:	f0 e0       	ldi	r31, 0x00	; 0
    b9a2:	03 2f       	mov	r16, r19
    b9a4:	0e 1b       	sub	r16, r30
    b9a6:	e1 e0       	ldi	r30, 0x01	; 1
    b9a8:	30 17       	cp	r19, r16
    b9aa:	08 f0       	brcs	.+2      	; 0xb9ae <__divdi3+0xee2>
    b9ac:	e0 e0       	ldi	r30, 0x00	; 0
    b9ae:	fe 2b       	or	r31, r30
    b9b0:	41 95       	neg	r20
    b9b2:	e1 e0       	ldi	r30, 0x01	; 1
    b9b4:	14 16       	cp	r1, r20
    b9b6:	08 f0       	brcs	.+2      	; 0xb9ba <__divdi3+0xeee>
    b9b8:	e0 e0       	ldi	r30, 0x00	; 0
    b9ba:	14 2f       	mov	r17, r20
    b9bc:	1f 1b       	sub	r17, r31
    b9be:	31 e0       	ldi	r19, 0x01	; 1
    b9c0:	41 17       	cp	r20, r17
    b9c2:	08 f0       	brcs	.+2      	; 0xb9c6 <__divdi3+0xefa>
    b9c4:	30 e0       	ldi	r19, 0x00	; 0
    b9c6:	e3 2b       	or	r30, r19
    b9c8:	51 95       	neg	r21
    b9ca:	f1 e0       	ldi	r31, 0x01	; 1
    b9cc:	15 16       	cp	r1, r21
    b9ce:	08 f0       	brcs	.+2      	; 0xb9d2 <__divdi3+0xf06>
    b9d0:	f0 e0       	ldi	r31, 0x00	; 0
    b9d2:	b5 2f       	mov	r27, r21
    b9d4:	be 1b       	sub	r27, r30
    b9d6:	31 e0       	ldi	r19, 0x01	; 1
    b9d8:	5b 17       	cp	r21, r27
    b9da:	08 f0       	brcs	.+2      	; 0xb9de <__divdi3+0xf12>
    b9dc:	30 e0       	ldi	r19, 0x00	; 0
    b9de:	f3 2b       	or	r31, r19
    b9e0:	61 95       	neg	r22
    b9e2:	e1 e0       	ldi	r30, 0x01	; 1
    b9e4:	16 16       	cp	r1, r22
    b9e6:	08 f0       	brcs	.+2      	; 0xb9ea <__divdi3+0xf1e>
    b9e8:	e0 e0       	ldi	r30, 0x00	; 0
    b9ea:	46 2e       	mov	r4, r22
    b9ec:	4f 1a       	sub	r4, r31
    b9ee:	31 e0       	ldi	r19, 0x01	; 1
    b9f0:	64 15       	cp	r22, r4
    b9f2:	08 f0       	brcs	.+2      	; 0xb9f6 <__divdi3+0xf2a>
    b9f4:	30 e0       	ldi	r19, 0x00	; 0
    b9f6:	e3 2b       	or	r30, r19
    b9f8:	71 95       	neg	r23
    b9fa:	f1 e0       	ldi	r31, 0x01	; 1
    b9fc:	17 16       	cp	r1, r23
    b9fe:	08 f0       	brcs	.+2      	; 0xba02 <__divdi3+0xf36>
    ba00:	f0 e0       	ldi	r31, 0x00	; 0
    ba02:	a7 2f       	mov	r26, r23
    ba04:	ae 1b       	sub	r26, r30
    ba06:	31 e0       	ldi	r19, 0x01	; 1
    ba08:	7a 17       	cp	r23, r26
    ba0a:	08 f0       	brcs	.+2      	; 0xba0e <__divdi3+0xf42>
    ba0c:	30 e0       	ldi	r19, 0x00	; 0
    ba0e:	f3 2b       	or	r31, r19
    ba10:	81 95       	neg	r24
    ba12:	e1 e0       	ldi	r30, 0x01	; 1
    ba14:	18 16       	cp	r1, r24
    ba16:	08 f0       	brcs	.+2      	; 0xba1a <__divdi3+0xf4e>
    ba18:	e0 e0       	ldi	r30, 0x00	; 0
    ba1a:	f8 2e       	mov	r15, r24
    ba1c:	ff 1a       	sub	r15, r31
    ba1e:	ff 2d       	mov	r31, r15
    ba20:	31 e0       	ldi	r19, 0x01	; 1
    ba22:	8f 15       	cp	r24, r15
    ba24:	08 f0       	brcs	.+2      	; 0xba28 <__divdi3+0xf5c>
    ba26:	30 e0       	ldi	r19, 0x00	; 0
    ba28:	e3 2b       	or	r30, r19
    ba2a:	91 95       	neg	r25
    ba2c:	30 2f       	mov	r19, r16
    ba2e:	41 2f       	mov	r20, r17
    ba30:	5b 2f       	mov	r21, r27
    ba32:	64 2d       	mov	r22, r4
    ba34:	7a 2f       	mov	r23, r26
    ba36:	8f 2f       	mov	r24, r31
    ba38:	9e 1b       	sub	r25, r30
    ba3a:	c8 5b       	subi	r28, 0xB8	; 184
    ba3c:	df 4f       	sbci	r29, 0xFF	; 255
    ba3e:	e1 e1       	ldi	r30, 0x11	; 17
    ba40:	0c 94 33 5f 	jmp	0xbe66	; 0xbe66 <__epilogue_restores__+0x2>

0000ba44 <__cmpsf2>:
    ba44:	97 d0       	rcall	.+302    	; 0xbb74 <__fp_cmp>
    ba46:	08 f4       	brcc	.+2      	; 0xba4a <__cmpsf2+0x6>
    ba48:	81 e0       	ldi	r24, 0x01	; 1
    ba4a:	08 95       	ret

0000ba4c <__divsf3>:
    ba4c:	0c d0       	rcall	.+24     	; 0xba66 <__divsf3x>
    ba4e:	cd c0       	rjmp	.+410    	; 0xbbea <__fp_round>
    ba50:	c5 d0       	rcall	.+394    	; 0xbbdc <__fp_pscB>
    ba52:	40 f0       	brcs	.+16     	; 0xba64 <__divsf3+0x18>
    ba54:	bc d0       	rcall	.+376    	; 0xbbce <__fp_pscA>
    ba56:	30 f0       	brcs	.+12     	; 0xba64 <__divsf3+0x18>
    ba58:	21 f4       	brne	.+8      	; 0xba62 <__divsf3+0x16>
    ba5a:	5f 3f       	cpi	r21, 0xFF	; 255
    ba5c:	19 f0       	breq	.+6      	; 0xba64 <__divsf3+0x18>
    ba5e:	ae c0       	rjmp	.+348    	; 0xbbbc <__fp_inf>
    ba60:	51 11       	cpse	r21, r1
    ba62:	f7 c0       	rjmp	.+494    	; 0xbc52 <__fp_szero>
    ba64:	b1 c0       	rjmp	.+354    	; 0xbbc8 <__fp_nan>

0000ba66 <__divsf3x>:
    ba66:	d2 d0       	rcall	.+420    	; 0xbc0c <__fp_split3>
    ba68:	98 f3       	brcs	.-26     	; 0xba50 <__divsf3+0x4>

0000ba6a <__divsf3_pse>:
    ba6a:	99 23       	and	r25, r25
    ba6c:	c9 f3       	breq	.-14     	; 0xba60 <__divsf3+0x14>
    ba6e:	55 23       	and	r21, r21
    ba70:	b1 f3       	breq	.-20     	; 0xba5e <__divsf3+0x12>
    ba72:	95 1b       	sub	r25, r21
    ba74:	55 0b       	sbc	r21, r21
    ba76:	bb 27       	eor	r27, r27
    ba78:	aa 27       	eor	r26, r26
    ba7a:	62 17       	cp	r22, r18
    ba7c:	73 07       	cpc	r23, r19
    ba7e:	84 07       	cpc	r24, r20
    ba80:	38 f0       	brcs	.+14     	; 0xba90 <__divsf3_pse+0x26>
    ba82:	9f 5f       	subi	r25, 0xFF	; 255
    ba84:	5f 4f       	sbci	r21, 0xFF	; 255
    ba86:	22 0f       	add	r18, r18
    ba88:	33 1f       	adc	r19, r19
    ba8a:	44 1f       	adc	r20, r20
    ba8c:	aa 1f       	adc	r26, r26
    ba8e:	a9 f3       	breq	.-22     	; 0xba7a <__divsf3_pse+0x10>
    ba90:	33 d0       	rcall	.+102    	; 0xbaf8 <__divsf3_pse+0x8e>
    ba92:	0e 2e       	mov	r0, r30
    ba94:	3a f0       	brmi	.+14     	; 0xbaa4 <__divsf3_pse+0x3a>
    ba96:	e0 e8       	ldi	r30, 0x80	; 128
    ba98:	30 d0       	rcall	.+96     	; 0xbafa <__divsf3_pse+0x90>
    ba9a:	91 50       	subi	r25, 0x01	; 1
    ba9c:	50 40       	sbci	r21, 0x00	; 0
    ba9e:	e6 95       	lsr	r30
    baa0:	00 1c       	adc	r0, r0
    baa2:	ca f7       	brpl	.-14     	; 0xba96 <__divsf3_pse+0x2c>
    baa4:	29 d0       	rcall	.+82     	; 0xbaf8 <__divsf3_pse+0x8e>
    baa6:	fe 2f       	mov	r31, r30
    baa8:	27 d0       	rcall	.+78     	; 0xbaf8 <__divsf3_pse+0x8e>
    baaa:	66 0f       	add	r22, r22
    baac:	77 1f       	adc	r23, r23
    baae:	88 1f       	adc	r24, r24
    bab0:	bb 1f       	adc	r27, r27
    bab2:	26 17       	cp	r18, r22
    bab4:	37 07       	cpc	r19, r23
    bab6:	48 07       	cpc	r20, r24
    bab8:	ab 07       	cpc	r26, r27
    baba:	b0 e8       	ldi	r27, 0x80	; 128
    babc:	09 f0       	breq	.+2      	; 0xbac0 <__divsf3_pse+0x56>
    babe:	bb 0b       	sbc	r27, r27
    bac0:	80 2d       	mov	r24, r0
    bac2:	bf 01       	movw	r22, r30
    bac4:	ff 27       	eor	r31, r31
    bac6:	93 58       	subi	r25, 0x83	; 131
    bac8:	5f 4f       	sbci	r21, 0xFF	; 255
    baca:	2a f0       	brmi	.+10     	; 0xbad6 <__divsf3_pse+0x6c>
    bacc:	9e 3f       	cpi	r25, 0xFE	; 254
    bace:	51 05       	cpc	r21, r1
    bad0:	68 f0       	brcs	.+26     	; 0xbaec <__divsf3_pse+0x82>
    bad2:	74 c0       	rjmp	.+232    	; 0xbbbc <__fp_inf>
    bad4:	be c0       	rjmp	.+380    	; 0xbc52 <__fp_szero>
    bad6:	5f 3f       	cpi	r21, 0xFF	; 255
    bad8:	ec f3       	brlt	.-6      	; 0xbad4 <__divsf3_pse+0x6a>
    bada:	98 3e       	cpi	r25, 0xE8	; 232
    badc:	dc f3       	brlt	.-10     	; 0xbad4 <__divsf3_pse+0x6a>
    bade:	86 95       	lsr	r24
    bae0:	77 95       	ror	r23
    bae2:	67 95       	ror	r22
    bae4:	b7 95       	ror	r27
    bae6:	f7 95       	ror	r31
    bae8:	9f 5f       	subi	r25, 0xFF	; 255
    baea:	c9 f7       	brne	.-14     	; 0xbade <__divsf3_pse+0x74>
    baec:	88 0f       	add	r24, r24
    baee:	91 1d       	adc	r25, r1
    baf0:	96 95       	lsr	r25
    baf2:	87 95       	ror	r24
    baf4:	97 f9       	bld	r25, 7
    baf6:	08 95       	ret
    baf8:	e1 e0       	ldi	r30, 0x01	; 1
    bafa:	66 0f       	add	r22, r22
    bafc:	77 1f       	adc	r23, r23
    bafe:	88 1f       	adc	r24, r24
    bb00:	bb 1f       	adc	r27, r27
    bb02:	62 17       	cp	r22, r18
    bb04:	73 07       	cpc	r23, r19
    bb06:	84 07       	cpc	r24, r20
    bb08:	ba 07       	cpc	r27, r26
    bb0a:	20 f0       	brcs	.+8      	; 0xbb14 <__divsf3_pse+0xaa>
    bb0c:	62 1b       	sub	r22, r18
    bb0e:	73 0b       	sbc	r23, r19
    bb10:	84 0b       	sbc	r24, r20
    bb12:	ba 0b       	sbc	r27, r26
    bb14:	ee 1f       	adc	r30, r30
    bb16:	88 f7       	brcc	.-30     	; 0xbafa <__divsf3_pse+0x90>
    bb18:	e0 95       	com	r30
    bb1a:	08 95       	ret

0000bb1c <__fixunssfsi>:
    bb1c:	7f d0       	rcall	.+254    	; 0xbc1c <__fp_splitA>
    bb1e:	88 f0       	brcs	.+34     	; 0xbb42 <__fixunssfsi+0x26>
    bb20:	9f 57       	subi	r25, 0x7F	; 127
    bb22:	90 f0       	brcs	.+36     	; 0xbb48 <__fixunssfsi+0x2c>
    bb24:	b9 2f       	mov	r27, r25
    bb26:	99 27       	eor	r25, r25
    bb28:	b7 51       	subi	r27, 0x17	; 23
    bb2a:	a0 f0       	brcs	.+40     	; 0xbb54 <__fixunssfsi+0x38>
    bb2c:	d1 f0       	breq	.+52     	; 0xbb62 <__fixunssfsi+0x46>
    bb2e:	66 0f       	add	r22, r22
    bb30:	77 1f       	adc	r23, r23
    bb32:	88 1f       	adc	r24, r24
    bb34:	99 1f       	adc	r25, r25
    bb36:	1a f0       	brmi	.+6      	; 0xbb3e <__fixunssfsi+0x22>
    bb38:	ba 95       	dec	r27
    bb3a:	c9 f7       	brne	.-14     	; 0xbb2e <__fixunssfsi+0x12>
    bb3c:	12 c0       	rjmp	.+36     	; 0xbb62 <__fixunssfsi+0x46>
    bb3e:	b1 30       	cpi	r27, 0x01	; 1
    bb40:	81 f0       	breq	.+32     	; 0xbb62 <__fixunssfsi+0x46>
    bb42:	86 d0       	rcall	.+268    	; 0xbc50 <__fp_zero>
    bb44:	b1 e0       	ldi	r27, 0x01	; 1
    bb46:	08 95       	ret
    bb48:	83 c0       	rjmp	.+262    	; 0xbc50 <__fp_zero>
    bb4a:	67 2f       	mov	r22, r23
    bb4c:	78 2f       	mov	r23, r24
    bb4e:	88 27       	eor	r24, r24
    bb50:	b8 5f       	subi	r27, 0xF8	; 248
    bb52:	39 f0       	breq	.+14     	; 0xbb62 <__fixunssfsi+0x46>
    bb54:	b9 3f       	cpi	r27, 0xF9	; 249
    bb56:	cc f3       	brlt	.-14     	; 0xbb4a <__fixunssfsi+0x2e>
    bb58:	86 95       	lsr	r24
    bb5a:	77 95       	ror	r23
    bb5c:	67 95       	ror	r22
    bb5e:	b3 95       	inc	r27
    bb60:	d9 f7       	brne	.-10     	; 0xbb58 <__fixunssfsi+0x3c>
    bb62:	3e f4       	brtc	.+14     	; 0xbb72 <__fixunssfsi+0x56>
    bb64:	90 95       	com	r25
    bb66:	80 95       	com	r24
    bb68:	70 95       	com	r23
    bb6a:	61 95       	neg	r22
    bb6c:	7f 4f       	sbci	r23, 0xFF	; 255
    bb6e:	8f 4f       	sbci	r24, 0xFF	; 255
    bb70:	9f 4f       	sbci	r25, 0xFF	; 255
    bb72:	08 95       	ret

0000bb74 <__fp_cmp>:
    bb74:	99 0f       	add	r25, r25
    bb76:	00 08       	sbc	r0, r0
    bb78:	55 0f       	add	r21, r21
    bb7a:	aa 0b       	sbc	r26, r26
    bb7c:	e0 e8       	ldi	r30, 0x80	; 128
    bb7e:	fe ef       	ldi	r31, 0xFE	; 254
    bb80:	16 16       	cp	r1, r22
    bb82:	17 06       	cpc	r1, r23
    bb84:	e8 07       	cpc	r30, r24
    bb86:	f9 07       	cpc	r31, r25
    bb88:	c0 f0       	brcs	.+48     	; 0xbbba <__fp_cmp+0x46>
    bb8a:	12 16       	cp	r1, r18
    bb8c:	13 06       	cpc	r1, r19
    bb8e:	e4 07       	cpc	r30, r20
    bb90:	f5 07       	cpc	r31, r21
    bb92:	98 f0       	brcs	.+38     	; 0xbbba <__fp_cmp+0x46>
    bb94:	62 1b       	sub	r22, r18
    bb96:	73 0b       	sbc	r23, r19
    bb98:	84 0b       	sbc	r24, r20
    bb9a:	95 0b       	sbc	r25, r21
    bb9c:	39 f4       	brne	.+14     	; 0xbbac <__fp_cmp+0x38>
    bb9e:	0a 26       	eor	r0, r26
    bba0:	61 f0       	breq	.+24     	; 0xbbba <__fp_cmp+0x46>
    bba2:	23 2b       	or	r18, r19
    bba4:	24 2b       	or	r18, r20
    bba6:	25 2b       	or	r18, r21
    bba8:	21 f4       	brne	.+8      	; 0xbbb2 <__fp_cmp+0x3e>
    bbaa:	08 95       	ret
    bbac:	0a 26       	eor	r0, r26
    bbae:	09 f4       	brne	.+2      	; 0xbbb2 <__fp_cmp+0x3e>
    bbb0:	a1 40       	sbci	r26, 0x01	; 1
    bbb2:	a6 95       	lsr	r26
    bbb4:	8f ef       	ldi	r24, 0xFF	; 255
    bbb6:	81 1d       	adc	r24, r1
    bbb8:	81 1d       	adc	r24, r1
    bbba:	08 95       	ret

0000bbbc <__fp_inf>:
    bbbc:	97 f9       	bld	r25, 7
    bbbe:	9f 67       	ori	r25, 0x7F	; 127
    bbc0:	80 e8       	ldi	r24, 0x80	; 128
    bbc2:	70 e0       	ldi	r23, 0x00	; 0
    bbc4:	60 e0       	ldi	r22, 0x00	; 0
    bbc6:	08 95       	ret

0000bbc8 <__fp_nan>:
    bbc8:	9f ef       	ldi	r25, 0xFF	; 255
    bbca:	80 ec       	ldi	r24, 0xC0	; 192
    bbcc:	08 95       	ret

0000bbce <__fp_pscA>:
    bbce:	00 24       	eor	r0, r0
    bbd0:	0a 94       	dec	r0
    bbd2:	16 16       	cp	r1, r22
    bbd4:	17 06       	cpc	r1, r23
    bbd6:	18 06       	cpc	r1, r24
    bbd8:	09 06       	cpc	r0, r25
    bbda:	08 95       	ret

0000bbdc <__fp_pscB>:
    bbdc:	00 24       	eor	r0, r0
    bbde:	0a 94       	dec	r0
    bbe0:	12 16       	cp	r1, r18
    bbe2:	13 06       	cpc	r1, r19
    bbe4:	14 06       	cpc	r1, r20
    bbe6:	05 06       	cpc	r0, r21
    bbe8:	08 95       	ret

0000bbea <__fp_round>:
    bbea:	09 2e       	mov	r0, r25
    bbec:	03 94       	inc	r0
    bbee:	00 0c       	add	r0, r0
    bbf0:	11 f4       	brne	.+4      	; 0xbbf6 <__fp_round+0xc>
    bbf2:	88 23       	and	r24, r24
    bbf4:	52 f0       	brmi	.+20     	; 0xbc0a <__fp_round+0x20>
    bbf6:	bb 0f       	add	r27, r27
    bbf8:	40 f4       	brcc	.+16     	; 0xbc0a <__fp_round+0x20>
    bbfa:	bf 2b       	or	r27, r31
    bbfc:	11 f4       	brne	.+4      	; 0xbc02 <__fp_round+0x18>
    bbfe:	60 ff       	sbrs	r22, 0
    bc00:	04 c0       	rjmp	.+8      	; 0xbc0a <__fp_round+0x20>
    bc02:	6f 5f       	subi	r22, 0xFF	; 255
    bc04:	7f 4f       	sbci	r23, 0xFF	; 255
    bc06:	8f 4f       	sbci	r24, 0xFF	; 255
    bc08:	9f 4f       	sbci	r25, 0xFF	; 255
    bc0a:	08 95       	ret

0000bc0c <__fp_split3>:
    bc0c:	57 fd       	sbrc	r21, 7
    bc0e:	90 58       	subi	r25, 0x80	; 128
    bc10:	44 0f       	add	r20, r20
    bc12:	55 1f       	adc	r21, r21
    bc14:	59 f0       	breq	.+22     	; 0xbc2c <__fp_splitA+0x10>
    bc16:	5f 3f       	cpi	r21, 0xFF	; 255
    bc18:	71 f0       	breq	.+28     	; 0xbc36 <__fp_splitA+0x1a>
    bc1a:	47 95       	ror	r20

0000bc1c <__fp_splitA>:
    bc1c:	88 0f       	add	r24, r24
    bc1e:	97 fb       	bst	r25, 7
    bc20:	99 1f       	adc	r25, r25
    bc22:	61 f0       	breq	.+24     	; 0xbc3c <__fp_splitA+0x20>
    bc24:	9f 3f       	cpi	r25, 0xFF	; 255
    bc26:	79 f0       	breq	.+30     	; 0xbc46 <__fp_splitA+0x2a>
    bc28:	87 95       	ror	r24
    bc2a:	08 95       	ret
    bc2c:	12 16       	cp	r1, r18
    bc2e:	13 06       	cpc	r1, r19
    bc30:	14 06       	cpc	r1, r20
    bc32:	55 1f       	adc	r21, r21
    bc34:	f2 cf       	rjmp	.-28     	; 0xbc1a <__fp_split3+0xe>
    bc36:	46 95       	lsr	r20
    bc38:	f1 df       	rcall	.-30     	; 0xbc1c <__fp_splitA>
    bc3a:	08 c0       	rjmp	.+16     	; 0xbc4c <__fp_splitA+0x30>
    bc3c:	16 16       	cp	r1, r22
    bc3e:	17 06       	cpc	r1, r23
    bc40:	18 06       	cpc	r1, r24
    bc42:	99 1f       	adc	r25, r25
    bc44:	f1 cf       	rjmp	.-30     	; 0xbc28 <__fp_splitA+0xc>
    bc46:	86 95       	lsr	r24
    bc48:	71 05       	cpc	r23, r1
    bc4a:	61 05       	cpc	r22, r1
    bc4c:	08 94       	sec
    bc4e:	08 95       	ret

0000bc50 <__fp_zero>:
    bc50:	e8 94       	clt

0000bc52 <__fp_szero>:
    bc52:	bb 27       	eor	r27, r27
    bc54:	66 27       	eor	r22, r22
    bc56:	77 27       	eor	r23, r23
    bc58:	cb 01       	movw	r24, r22
    bc5a:	97 f9       	bld	r25, 7
    bc5c:	08 95       	ret

0000bc5e <__gesf2>:
    bc5e:	8a df       	rcall	.-236    	; 0xbb74 <__fp_cmp>
    bc60:	08 f4       	brcc	.+2      	; 0xbc64 <__gesf2+0x6>
    bc62:	8f ef       	ldi	r24, 0xFF	; 255
    bc64:	08 95       	ret

0000bc66 <__mulsf3>:
    bc66:	0b d0       	rcall	.+22     	; 0xbc7e <__mulsf3x>
    bc68:	c0 cf       	rjmp	.-128    	; 0xbbea <__fp_round>
    bc6a:	b1 df       	rcall	.-158    	; 0xbbce <__fp_pscA>
    bc6c:	28 f0       	brcs	.+10     	; 0xbc78 <__mulsf3+0x12>
    bc6e:	b6 df       	rcall	.-148    	; 0xbbdc <__fp_pscB>
    bc70:	18 f0       	brcs	.+6      	; 0xbc78 <__mulsf3+0x12>
    bc72:	95 23       	and	r25, r21
    bc74:	09 f0       	breq	.+2      	; 0xbc78 <__mulsf3+0x12>
    bc76:	a2 cf       	rjmp	.-188    	; 0xbbbc <__fp_inf>
    bc78:	a7 cf       	rjmp	.-178    	; 0xbbc8 <__fp_nan>
    bc7a:	11 24       	eor	r1, r1
    bc7c:	ea cf       	rjmp	.-44     	; 0xbc52 <__fp_szero>

0000bc7e <__mulsf3x>:
    bc7e:	c6 df       	rcall	.-116    	; 0xbc0c <__fp_split3>
    bc80:	a0 f3       	brcs	.-24     	; 0xbc6a <__mulsf3+0x4>

0000bc82 <__mulsf3_pse>:
    bc82:	95 9f       	mul	r25, r21
    bc84:	d1 f3       	breq	.-12     	; 0xbc7a <__mulsf3+0x14>
    bc86:	95 0f       	add	r25, r21
    bc88:	50 e0       	ldi	r21, 0x00	; 0
    bc8a:	55 1f       	adc	r21, r21
    bc8c:	62 9f       	mul	r22, r18
    bc8e:	f0 01       	movw	r30, r0
    bc90:	72 9f       	mul	r23, r18
    bc92:	bb 27       	eor	r27, r27
    bc94:	f0 0d       	add	r31, r0
    bc96:	b1 1d       	adc	r27, r1
    bc98:	63 9f       	mul	r22, r19
    bc9a:	aa 27       	eor	r26, r26
    bc9c:	f0 0d       	add	r31, r0
    bc9e:	b1 1d       	adc	r27, r1
    bca0:	aa 1f       	adc	r26, r26
    bca2:	64 9f       	mul	r22, r20
    bca4:	66 27       	eor	r22, r22
    bca6:	b0 0d       	add	r27, r0
    bca8:	a1 1d       	adc	r26, r1
    bcaa:	66 1f       	adc	r22, r22
    bcac:	82 9f       	mul	r24, r18
    bcae:	22 27       	eor	r18, r18
    bcb0:	b0 0d       	add	r27, r0
    bcb2:	a1 1d       	adc	r26, r1
    bcb4:	62 1f       	adc	r22, r18
    bcb6:	73 9f       	mul	r23, r19
    bcb8:	b0 0d       	add	r27, r0
    bcba:	a1 1d       	adc	r26, r1
    bcbc:	62 1f       	adc	r22, r18
    bcbe:	83 9f       	mul	r24, r19
    bcc0:	a0 0d       	add	r26, r0
    bcc2:	61 1d       	adc	r22, r1
    bcc4:	22 1f       	adc	r18, r18
    bcc6:	74 9f       	mul	r23, r20
    bcc8:	33 27       	eor	r19, r19
    bcca:	a0 0d       	add	r26, r0
    bccc:	61 1d       	adc	r22, r1
    bcce:	23 1f       	adc	r18, r19
    bcd0:	84 9f       	mul	r24, r20
    bcd2:	60 0d       	add	r22, r0
    bcd4:	21 1d       	adc	r18, r1
    bcd6:	82 2f       	mov	r24, r18
    bcd8:	76 2f       	mov	r23, r22
    bcda:	6a 2f       	mov	r22, r26
    bcdc:	11 24       	eor	r1, r1
    bcde:	9f 57       	subi	r25, 0x7F	; 127
    bce0:	50 40       	sbci	r21, 0x00	; 0
    bce2:	8a f0       	brmi	.+34     	; 0xbd06 <__mulsf3_pse+0x84>
    bce4:	e1 f0       	breq	.+56     	; 0xbd1e <__mulsf3_pse+0x9c>
    bce6:	88 23       	and	r24, r24
    bce8:	4a f0       	brmi	.+18     	; 0xbcfc <__mulsf3_pse+0x7a>
    bcea:	ee 0f       	add	r30, r30
    bcec:	ff 1f       	adc	r31, r31
    bcee:	bb 1f       	adc	r27, r27
    bcf0:	66 1f       	adc	r22, r22
    bcf2:	77 1f       	adc	r23, r23
    bcf4:	88 1f       	adc	r24, r24
    bcf6:	91 50       	subi	r25, 0x01	; 1
    bcf8:	50 40       	sbci	r21, 0x00	; 0
    bcfa:	a9 f7       	brne	.-22     	; 0xbce6 <__mulsf3_pse+0x64>
    bcfc:	9e 3f       	cpi	r25, 0xFE	; 254
    bcfe:	51 05       	cpc	r21, r1
    bd00:	70 f0       	brcs	.+28     	; 0xbd1e <__mulsf3_pse+0x9c>
    bd02:	5c cf       	rjmp	.-328    	; 0xbbbc <__fp_inf>
    bd04:	a6 cf       	rjmp	.-180    	; 0xbc52 <__fp_szero>
    bd06:	5f 3f       	cpi	r21, 0xFF	; 255
    bd08:	ec f3       	brlt	.-6      	; 0xbd04 <__mulsf3_pse+0x82>
    bd0a:	98 3e       	cpi	r25, 0xE8	; 232
    bd0c:	dc f3       	brlt	.-10     	; 0xbd04 <__mulsf3_pse+0x82>
    bd0e:	86 95       	lsr	r24
    bd10:	77 95       	ror	r23
    bd12:	67 95       	ror	r22
    bd14:	b7 95       	ror	r27
    bd16:	f7 95       	ror	r31
    bd18:	e7 95       	ror	r30
    bd1a:	9f 5f       	subi	r25, 0xFF	; 255
    bd1c:	c1 f7       	brne	.-16     	; 0xbd0e <__mulsf3_pse+0x8c>
    bd1e:	fe 2b       	or	r31, r30
    bd20:	88 0f       	add	r24, r24
    bd22:	91 1d       	adc	r25, r1
    bd24:	96 95       	lsr	r25
    bd26:	87 95       	ror	r24
    bd28:	97 f9       	bld	r25, 7
    bd2a:	08 95       	ret

0000bd2c <__mulsi3>:
    bd2c:	62 9f       	mul	r22, r18
    bd2e:	d0 01       	movw	r26, r0
    bd30:	73 9f       	mul	r23, r19
    bd32:	f0 01       	movw	r30, r0
    bd34:	82 9f       	mul	r24, r18
    bd36:	e0 0d       	add	r30, r0
    bd38:	f1 1d       	adc	r31, r1
    bd3a:	64 9f       	mul	r22, r20
    bd3c:	e0 0d       	add	r30, r0
    bd3e:	f1 1d       	adc	r31, r1
    bd40:	92 9f       	mul	r25, r18
    bd42:	f0 0d       	add	r31, r0
    bd44:	83 9f       	mul	r24, r19
    bd46:	f0 0d       	add	r31, r0
    bd48:	74 9f       	mul	r23, r20
    bd4a:	f0 0d       	add	r31, r0
    bd4c:	65 9f       	mul	r22, r21
    bd4e:	f0 0d       	add	r31, r0
    bd50:	99 27       	eor	r25, r25
    bd52:	72 9f       	mul	r23, r18
    bd54:	b0 0d       	add	r27, r0
    bd56:	e1 1d       	adc	r30, r1
    bd58:	f9 1f       	adc	r31, r25
    bd5a:	63 9f       	mul	r22, r19
    bd5c:	b0 0d       	add	r27, r0
    bd5e:	e1 1d       	adc	r30, r1
    bd60:	f9 1f       	adc	r31, r25
    bd62:	bd 01       	movw	r22, r26
    bd64:	cf 01       	movw	r24, r30
    bd66:	11 24       	eor	r1, r1
    bd68:	08 95       	ret

0000bd6a <__udivmodhi4>:
    bd6a:	aa 1b       	sub	r26, r26
    bd6c:	bb 1b       	sub	r27, r27
    bd6e:	51 e1       	ldi	r21, 0x11	; 17
    bd70:	07 c0       	rjmp	.+14     	; 0xbd80 <__udivmodhi4_ep>

0000bd72 <__udivmodhi4_loop>:
    bd72:	aa 1f       	adc	r26, r26
    bd74:	bb 1f       	adc	r27, r27
    bd76:	a6 17       	cp	r26, r22
    bd78:	b7 07       	cpc	r27, r23
    bd7a:	10 f0       	brcs	.+4      	; 0xbd80 <__udivmodhi4_ep>
    bd7c:	a6 1b       	sub	r26, r22
    bd7e:	b7 0b       	sbc	r27, r23

0000bd80 <__udivmodhi4_ep>:
    bd80:	88 1f       	adc	r24, r24
    bd82:	99 1f       	adc	r25, r25
    bd84:	5a 95       	dec	r21
    bd86:	a9 f7       	brne	.-22     	; 0xbd72 <__udivmodhi4_loop>
    bd88:	80 95       	com	r24
    bd8a:	90 95       	com	r25
    bd8c:	bc 01       	movw	r22, r24
    bd8e:	cd 01       	movw	r24, r26
    bd90:	08 95       	ret

0000bd92 <__divmodhi4>:
    bd92:	97 fb       	bst	r25, 7
    bd94:	09 2e       	mov	r0, r25
    bd96:	07 26       	eor	r0, r23
    bd98:	0a d0       	rcall	.+20     	; 0xbdae <__divmodhi4_neg1>
    bd9a:	77 fd       	sbrc	r23, 7
    bd9c:	04 d0       	rcall	.+8      	; 0xbda6 <__divmodhi4_neg2>
    bd9e:	e5 df       	rcall	.-54     	; 0xbd6a <__udivmodhi4>
    bda0:	06 d0       	rcall	.+12     	; 0xbdae <__divmodhi4_neg1>
    bda2:	00 20       	and	r0, r0
    bda4:	1a f4       	brpl	.+6      	; 0xbdac <__divmodhi4_exit>

0000bda6 <__divmodhi4_neg2>:
    bda6:	70 95       	com	r23
    bda8:	61 95       	neg	r22
    bdaa:	7f 4f       	sbci	r23, 0xFF	; 255

0000bdac <__divmodhi4_exit>:
    bdac:	08 95       	ret

0000bdae <__divmodhi4_neg1>:
    bdae:	f6 f7       	brtc	.-4      	; 0xbdac <__divmodhi4_exit>
    bdb0:	90 95       	com	r25
    bdb2:	81 95       	neg	r24
    bdb4:	9f 4f       	sbci	r25, 0xFF	; 255
    bdb6:	08 95       	ret

0000bdb8 <__udivmodsi4>:
    bdb8:	a1 e2       	ldi	r26, 0x21	; 33
    bdba:	1a 2e       	mov	r1, r26
    bdbc:	aa 1b       	sub	r26, r26
    bdbe:	bb 1b       	sub	r27, r27
    bdc0:	fd 01       	movw	r30, r26
    bdc2:	0d c0       	rjmp	.+26     	; 0xbdde <__udivmodsi4_ep>

0000bdc4 <__udivmodsi4_loop>:
    bdc4:	aa 1f       	adc	r26, r26
    bdc6:	bb 1f       	adc	r27, r27
    bdc8:	ee 1f       	adc	r30, r30
    bdca:	ff 1f       	adc	r31, r31
    bdcc:	a2 17       	cp	r26, r18
    bdce:	b3 07       	cpc	r27, r19
    bdd0:	e4 07       	cpc	r30, r20
    bdd2:	f5 07       	cpc	r31, r21
    bdd4:	20 f0       	brcs	.+8      	; 0xbdde <__udivmodsi4_ep>
    bdd6:	a2 1b       	sub	r26, r18
    bdd8:	b3 0b       	sbc	r27, r19
    bdda:	e4 0b       	sbc	r30, r20
    bddc:	f5 0b       	sbc	r31, r21

0000bdde <__udivmodsi4_ep>:
    bdde:	66 1f       	adc	r22, r22
    bde0:	77 1f       	adc	r23, r23
    bde2:	88 1f       	adc	r24, r24
    bde4:	99 1f       	adc	r25, r25
    bde6:	1a 94       	dec	r1
    bde8:	69 f7       	brne	.-38     	; 0xbdc4 <__udivmodsi4_loop>
    bdea:	60 95       	com	r22
    bdec:	70 95       	com	r23
    bdee:	80 95       	com	r24
    bdf0:	90 95       	com	r25
    bdf2:	9b 01       	movw	r18, r22
    bdf4:	ac 01       	movw	r20, r24
    bdf6:	bd 01       	movw	r22, r26
    bdf8:	cf 01       	movw	r24, r30
    bdfa:	08 95       	ret

0000bdfc <__divmodsi4>:
    bdfc:	97 fb       	bst	r25, 7
    bdfe:	09 2e       	mov	r0, r25
    be00:	05 26       	eor	r0, r21
    be02:	0e d0       	rcall	.+28     	; 0xbe20 <__divmodsi4_neg1>
    be04:	57 fd       	sbrc	r21, 7
    be06:	04 d0       	rcall	.+8      	; 0xbe10 <__divmodsi4_neg2>
    be08:	d7 df       	rcall	.-82     	; 0xbdb8 <__udivmodsi4>
    be0a:	0a d0       	rcall	.+20     	; 0xbe20 <__divmodsi4_neg1>
    be0c:	00 1c       	adc	r0, r0
    be0e:	38 f4       	brcc	.+14     	; 0xbe1e <__divmodsi4_exit>

0000be10 <__divmodsi4_neg2>:
    be10:	50 95       	com	r21
    be12:	40 95       	com	r20
    be14:	30 95       	com	r19
    be16:	21 95       	neg	r18
    be18:	3f 4f       	sbci	r19, 0xFF	; 255
    be1a:	4f 4f       	sbci	r20, 0xFF	; 255
    be1c:	5f 4f       	sbci	r21, 0xFF	; 255

0000be1e <__divmodsi4_exit>:
    be1e:	08 95       	ret

0000be20 <__divmodsi4_neg1>:
    be20:	f6 f7       	brtc	.-4      	; 0xbe1e <__divmodsi4_exit>
    be22:	90 95       	com	r25
    be24:	80 95       	com	r24
    be26:	70 95       	com	r23
    be28:	61 95       	neg	r22
    be2a:	7f 4f       	sbci	r23, 0xFF	; 255
    be2c:	8f 4f       	sbci	r24, 0xFF	; 255
    be2e:	9f 4f       	sbci	r25, 0xFF	; 255
    be30:	08 95       	ret

0000be32 <__prologue_saves__>:
    be32:	2f 92       	push	r2
    be34:	3f 92       	push	r3
    be36:	4f 92       	push	r4
    be38:	5f 92       	push	r5
    be3a:	6f 92       	push	r6
    be3c:	7f 92       	push	r7
    be3e:	8f 92       	push	r8
    be40:	9f 92       	push	r9
    be42:	af 92       	push	r10
    be44:	bf 92       	push	r11
    be46:	cf 92       	push	r12
    be48:	df 92       	push	r13
    be4a:	ef 92       	push	r14
    be4c:	ff 92       	push	r15
    be4e:	0f 93       	push	r16
    be50:	1f 93       	push	r17
    be52:	cf 93       	push	r28
    be54:	df 93       	push	r29
    be56:	cd b7       	in	r28, 0x3d	; 61
    be58:	de b7       	in	r29, 0x3e	; 62
    be5a:	ca 1b       	sub	r28, r26
    be5c:	db 0b       	sbc	r29, r27
    be5e:	cd bf       	out	0x3d, r28	; 61
    be60:	de bf       	out	0x3e, r29	; 62
    be62:	19 94       	eijmp

0000be64 <__epilogue_restores__>:
    be64:	2a 88       	ldd	r2, Y+18	; 0x12
    be66:	39 88       	ldd	r3, Y+17	; 0x11
    be68:	48 88       	ldd	r4, Y+16	; 0x10
    be6a:	5f 84       	ldd	r5, Y+15	; 0x0f
    be6c:	6e 84       	ldd	r6, Y+14	; 0x0e
    be6e:	7d 84       	ldd	r7, Y+13	; 0x0d
    be70:	8c 84       	ldd	r8, Y+12	; 0x0c
    be72:	9b 84       	ldd	r9, Y+11	; 0x0b
    be74:	aa 84       	ldd	r10, Y+10	; 0x0a
    be76:	b9 84       	ldd	r11, Y+9	; 0x09
    be78:	c8 84       	ldd	r12, Y+8	; 0x08
    be7a:	df 80       	ldd	r13, Y+7	; 0x07
    be7c:	ee 80       	ldd	r14, Y+6	; 0x06
    be7e:	fd 80       	ldd	r15, Y+5	; 0x05
    be80:	0c 81       	ldd	r16, Y+4	; 0x04
    be82:	1b 81       	ldd	r17, Y+3	; 0x03
    be84:	aa 81       	ldd	r26, Y+2	; 0x02
    be86:	b9 81       	ldd	r27, Y+1	; 0x01
    be88:	ce 0f       	add	r28, r30
    be8a:	d1 1d       	adc	r29, r1
    be8c:	cd bf       	out	0x3d, r28	; 61
    be8e:	de bf       	out	0x3e, r29	; 62
    be90:	ed 01       	movw	r28, r26
    be92:	08 95       	ret

0000be94 <strcpy_P>:
    be94:	fb 01       	movw	r30, r22
    be96:	dc 01       	movw	r26, r24
    be98:	05 90       	lpm	r0, Z+
    be9a:	0d 92       	st	X+, r0
    be9c:	00 20       	and	r0, r0
    be9e:	e1 f7       	brne	.-8      	; 0xbe98 <strcpy_P+0x4>
    bea0:	08 95       	ret

0000bea2 <memcpy>:
    bea2:	fb 01       	movw	r30, r22
    bea4:	dc 01       	movw	r26, r24
    bea6:	02 c0       	rjmp	.+4      	; 0xbeac <memcpy+0xa>
    bea8:	01 90       	ld	r0, Z+
    beaa:	0d 92       	st	X+, r0
    beac:	41 50       	subi	r20, 0x01	; 1
    beae:	50 40       	sbci	r21, 0x00	; 0
    beb0:	d8 f7       	brcc	.-10     	; 0xbea8 <memcpy+0x6>
    beb2:	08 95       	ret

0000beb4 <memmove>:
    beb4:	68 17       	cp	r22, r24
    beb6:	79 07       	cpc	r23, r25
    beb8:	68 f4       	brcc	.+26     	; 0xbed4 <memmove+0x20>
    beba:	fb 01       	movw	r30, r22
    bebc:	dc 01       	movw	r26, r24
    bebe:	e4 0f       	add	r30, r20
    bec0:	f5 1f       	adc	r31, r21
    bec2:	a4 0f       	add	r26, r20
    bec4:	b5 1f       	adc	r27, r21
    bec6:	02 c0       	rjmp	.+4      	; 0xbecc <memmove+0x18>
    bec8:	02 90       	ld	r0, -Z
    beca:	0e 92       	st	-X, r0
    becc:	41 50       	subi	r20, 0x01	; 1
    bece:	50 40       	sbci	r21, 0x00	; 0
    bed0:	d8 f7       	brcc	.-10     	; 0xbec8 <memmove+0x14>
    bed2:	08 95       	ret
    bed4:	0c 94 51 5f 	jmp	0xbea2	; 0xbea2 <memcpy>

0000bed8 <strcat>:
    bed8:	fb 01       	movw	r30, r22
    beda:	dc 01       	movw	r26, r24
    bedc:	0d 90       	ld	r0, X+
    bede:	00 20       	and	r0, r0
    bee0:	e9 f7       	brne	.-6      	; 0xbedc <strcat+0x4>
    bee2:	11 97       	sbiw	r26, 0x01	; 1
    bee4:	01 90       	ld	r0, Z+
    bee6:	0d 92       	st	X+, r0
    bee8:	00 20       	and	r0, r0
    beea:	e1 f7       	brne	.-8      	; 0xbee4 <strcat+0xc>
    beec:	08 95       	ret

0000beee <strncmp>:
    beee:	fb 01       	movw	r30, r22
    bef0:	dc 01       	movw	r26, r24
    bef2:	41 50       	subi	r20, 0x01	; 1
    bef4:	50 40       	sbci	r21, 0x00	; 0
    bef6:	30 f0       	brcs	.+12     	; 0xbf04 <strncmp+0x16>
    bef8:	8d 91       	ld	r24, X+
    befa:	01 90       	ld	r0, Z+
    befc:	80 19       	sub	r24, r0
    befe:	19 f4       	brne	.+6      	; 0xbf06 <strncmp+0x18>
    bf00:	00 20       	and	r0, r0
    bf02:	b9 f7       	brne	.-18     	; 0xbef2 <strncmp+0x4>
    bf04:	88 1b       	sub	r24, r24
    bf06:	99 0b       	sbc	r25, r25
    bf08:	08 95       	ret

0000bf0a <itoa>:
    bf0a:	fb 01       	movw	r30, r22
    bf0c:	9f 01       	movw	r18, r30
    bf0e:	e8 94       	clt
    bf10:	42 30       	cpi	r20, 0x02	; 2
    bf12:	c4 f0       	brlt	.+48     	; 0xbf44 <itoa+0x3a>
    bf14:	45 32       	cpi	r20, 0x25	; 37
    bf16:	b4 f4       	brge	.+44     	; 0xbf44 <itoa+0x3a>
    bf18:	4a 30       	cpi	r20, 0x0A	; 10
    bf1a:	29 f4       	brne	.+10     	; 0xbf26 <itoa+0x1c>
    bf1c:	97 fb       	bst	r25, 7
    bf1e:	1e f4       	brtc	.+6      	; 0xbf26 <itoa+0x1c>
    bf20:	90 95       	com	r25
    bf22:	81 95       	neg	r24
    bf24:	9f 4f       	sbci	r25, 0xFF	; 255
    bf26:	64 2f       	mov	r22, r20
    bf28:	77 27       	eor	r23, r23
    bf2a:	0e 94 b5 5e 	call	0xbd6a	; 0xbd6a <__udivmodhi4>
    bf2e:	80 5d       	subi	r24, 0xD0	; 208
    bf30:	8a 33       	cpi	r24, 0x3A	; 58
    bf32:	0c f0       	brlt	.+2      	; 0xbf36 <itoa+0x2c>
    bf34:	89 5d       	subi	r24, 0xD9	; 217
    bf36:	81 93       	st	Z+, r24
    bf38:	cb 01       	movw	r24, r22
    bf3a:	00 97       	sbiw	r24, 0x00	; 0
    bf3c:	a1 f7       	brne	.-24     	; 0xbf26 <itoa+0x1c>
    bf3e:	16 f4       	brtc	.+4      	; 0xbf44 <itoa+0x3a>
    bf40:	5d e2       	ldi	r21, 0x2D	; 45
    bf42:	51 93       	st	Z+, r21
    bf44:	10 82       	st	Z, r1
    bf46:	c9 01       	movw	r24, r18
    bf48:	0c 94 cf 61 	jmp	0xc39e	; 0xc39e <strrev>

0000bf4c <printf>:
    bf4c:	cf 93       	push	r28
    bf4e:	df 93       	push	r29
    bf50:	cd b7       	in	r28, 0x3d	; 61
    bf52:	de b7       	in	r29, 0x3e	; 62
    bf54:	fe 01       	movw	r30, r28
    bf56:	36 96       	adiw	r30, 0x06	; 6
    bf58:	61 91       	ld	r22, Z+
    bf5a:	71 91       	ld	r23, Z+
    bf5c:	80 91 dd 50 	lds	r24, 0x50DD
    bf60:	90 91 de 50 	lds	r25, 0x50DE
    bf64:	af 01       	movw	r20, r30
    bf66:	0e 94 b8 5f 	call	0xbf70	; 0xbf70 <vfprintf>
    bf6a:	df 91       	pop	r29
    bf6c:	cf 91       	pop	r28
    bf6e:	08 95       	ret

0000bf70 <vfprintf>:
    bf70:	2f 92       	push	r2
    bf72:	3f 92       	push	r3
    bf74:	4f 92       	push	r4
    bf76:	5f 92       	push	r5
    bf78:	6f 92       	push	r6
    bf7a:	7f 92       	push	r7
    bf7c:	8f 92       	push	r8
    bf7e:	9f 92       	push	r9
    bf80:	af 92       	push	r10
    bf82:	bf 92       	push	r11
    bf84:	cf 92       	push	r12
    bf86:	df 92       	push	r13
    bf88:	ef 92       	push	r14
    bf8a:	ff 92       	push	r15
    bf8c:	0f 93       	push	r16
    bf8e:	1f 93       	push	r17
    bf90:	cf 93       	push	r28
    bf92:	df 93       	push	r29
    bf94:	cd b7       	in	r28, 0x3d	; 61
    bf96:	de b7       	in	r29, 0x3e	; 62
    bf98:	2d 97       	sbiw	r28, 0x0d	; 13
    bf9a:	cd bf       	out	0x3d, r28	; 61
    bf9c:	de bf       	out	0x3e, r29	; 62
    bf9e:	3c 01       	movw	r6, r24
    bfa0:	6c 87       	std	Y+12, r22	; 0x0c
    bfa2:	7d 87       	std	Y+13, r23	; 0x0d
    bfa4:	5a 01       	movw	r10, r20
    bfa6:	fc 01       	movw	r30, r24
    bfa8:	16 82       	std	Z+6, r1	; 0x06
    bfaa:	17 82       	std	Z+7, r1	; 0x07
    bfac:	83 81       	ldd	r24, Z+3	; 0x03
    bfae:	81 ff       	sbrs	r24, 1
    bfb0:	c8 c1       	rjmp	.+912    	; 0xc342 <vfprintf+0x3d2>
    bfb2:	2e 01       	movw	r4, r28
    bfb4:	08 94       	sec
    bfb6:	41 1c       	adc	r4, r1
    bfb8:	51 1c       	adc	r5, r1
    bfba:	f3 01       	movw	r30, r6
    bfbc:	93 81       	ldd	r25, Z+3	; 0x03
    bfbe:	ec 85       	ldd	r30, Y+12	; 0x0c
    bfc0:	fd 85       	ldd	r31, Y+13	; 0x0d
    bfc2:	93 fd       	sbrc	r25, 3
    bfc4:	85 91       	lpm	r24, Z+
    bfc6:	93 ff       	sbrs	r25, 3
    bfc8:	81 91       	ld	r24, Z+
    bfca:	ec 87       	std	Y+12, r30	; 0x0c
    bfcc:	fd 87       	std	Y+13, r31	; 0x0d
    bfce:	88 23       	and	r24, r24
    bfd0:	09 f4       	brne	.+2      	; 0xbfd4 <vfprintf+0x64>
    bfd2:	b3 c1       	rjmp	.+870    	; 0xc33a <vfprintf+0x3ca>
    bfd4:	85 32       	cpi	r24, 0x25	; 37
    bfd6:	41 f4       	brne	.+16     	; 0xbfe8 <vfprintf+0x78>
    bfd8:	93 fd       	sbrc	r25, 3
    bfda:	85 91       	lpm	r24, Z+
    bfdc:	93 ff       	sbrs	r25, 3
    bfde:	81 91       	ld	r24, Z+
    bfe0:	ec 87       	std	Y+12, r30	; 0x0c
    bfe2:	fd 87       	std	Y+13, r31	; 0x0d
    bfe4:	85 32       	cpi	r24, 0x25	; 37
    bfe6:	29 f4       	brne	.+10     	; 0xbff2 <vfprintf+0x82>
    bfe8:	90 e0       	ldi	r25, 0x00	; 0
    bfea:	b3 01       	movw	r22, r6
    bfec:	0e 94 df 61 	call	0xc3be	; 0xc3be <fputc>
    bff0:	e4 cf       	rjmp	.-56     	; 0xbfba <vfprintf+0x4a>
    bff2:	ff 24       	eor	r15, r15
    bff4:	ee 24       	eor	r14, r14
    bff6:	10 e0       	ldi	r17, 0x00	; 0
    bff8:	10 32       	cpi	r17, 0x20	; 32
    bffa:	b0 f4       	brcc	.+44     	; 0xc028 <vfprintf+0xb8>
    bffc:	8b 32       	cpi	r24, 0x2B	; 43
    bffe:	69 f0       	breq	.+26     	; 0xc01a <vfprintf+0xaa>
    c000:	8c 32       	cpi	r24, 0x2C	; 44
    c002:	28 f4       	brcc	.+10     	; 0xc00e <vfprintf+0x9e>
    c004:	80 32       	cpi	r24, 0x20	; 32
    c006:	51 f0       	breq	.+20     	; 0xc01c <vfprintf+0xac>
    c008:	83 32       	cpi	r24, 0x23	; 35
    c00a:	71 f4       	brne	.+28     	; 0xc028 <vfprintf+0xb8>
    c00c:	0b c0       	rjmp	.+22     	; 0xc024 <vfprintf+0xb4>
    c00e:	8d 32       	cpi	r24, 0x2D	; 45
    c010:	39 f0       	breq	.+14     	; 0xc020 <vfprintf+0xb0>
    c012:	80 33       	cpi	r24, 0x30	; 48
    c014:	49 f4       	brne	.+18     	; 0xc028 <vfprintf+0xb8>
    c016:	11 60       	ori	r17, 0x01	; 1
    c018:	2c c0       	rjmp	.+88     	; 0xc072 <vfprintf+0x102>
    c01a:	12 60       	ori	r17, 0x02	; 2
    c01c:	14 60       	ori	r17, 0x04	; 4
    c01e:	29 c0       	rjmp	.+82     	; 0xc072 <vfprintf+0x102>
    c020:	18 60       	ori	r17, 0x08	; 8
    c022:	27 c0       	rjmp	.+78     	; 0xc072 <vfprintf+0x102>
    c024:	10 61       	ori	r17, 0x10	; 16
    c026:	25 c0       	rjmp	.+74     	; 0xc072 <vfprintf+0x102>
    c028:	17 fd       	sbrc	r17, 7
    c02a:	2e c0       	rjmp	.+92     	; 0xc088 <vfprintf+0x118>
    c02c:	28 2f       	mov	r18, r24
    c02e:	20 53       	subi	r18, 0x30	; 48
    c030:	2a 30       	cpi	r18, 0x0A	; 10
    c032:	98 f4       	brcc	.+38     	; 0xc05a <vfprintf+0xea>
    c034:	16 ff       	sbrs	r17, 6
    c036:	08 c0       	rjmp	.+16     	; 0xc048 <vfprintf+0xd8>
    c038:	8f 2d       	mov	r24, r15
    c03a:	88 0f       	add	r24, r24
    c03c:	f8 2e       	mov	r15, r24
    c03e:	ff 0c       	add	r15, r15
    c040:	ff 0c       	add	r15, r15
    c042:	f8 0e       	add	r15, r24
    c044:	f2 0e       	add	r15, r18
    c046:	15 c0       	rjmp	.+42     	; 0xc072 <vfprintf+0x102>
    c048:	8e 2d       	mov	r24, r14
    c04a:	88 0f       	add	r24, r24
    c04c:	e8 2e       	mov	r14, r24
    c04e:	ee 0c       	add	r14, r14
    c050:	ee 0c       	add	r14, r14
    c052:	e8 0e       	add	r14, r24
    c054:	e2 0e       	add	r14, r18
    c056:	10 62       	ori	r17, 0x20	; 32
    c058:	0c c0       	rjmp	.+24     	; 0xc072 <vfprintf+0x102>
    c05a:	8e 32       	cpi	r24, 0x2E	; 46
    c05c:	21 f4       	brne	.+8      	; 0xc066 <vfprintf+0xf6>
    c05e:	16 fd       	sbrc	r17, 6
    c060:	6c c1       	rjmp	.+728    	; 0xc33a <vfprintf+0x3ca>
    c062:	10 64       	ori	r17, 0x40	; 64
    c064:	06 c0       	rjmp	.+12     	; 0xc072 <vfprintf+0x102>
    c066:	8c 36       	cpi	r24, 0x6C	; 108
    c068:	11 f4       	brne	.+4      	; 0xc06e <vfprintf+0xfe>
    c06a:	10 68       	ori	r17, 0x80	; 128
    c06c:	02 c0       	rjmp	.+4      	; 0xc072 <vfprintf+0x102>
    c06e:	88 36       	cpi	r24, 0x68	; 104
    c070:	59 f4       	brne	.+22     	; 0xc088 <vfprintf+0x118>
    c072:	ec 85       	ldd	r30, Y+12	; 0x0c
    c074:	fd 85       	ldd	r31, Y+13	; 0x0d
    c076:	93 fd       	sbrc	r25, 3
    c078:	85 91       	lpm	r24, Z+
    c07a:	93 ff       	sbrs	r25, 3
    c07c:	81 91       	ld	r24, Z+
    c07e:	ec 87       	std	Y+12, r30	; 0x0c
    c080:	fd 87       	std	Y+13, r31	; 0x0d
    c082:	88 23       	and	r24, r24
    c084:	09 f0       	breq	.+2      	; 0xc088 <vfprintf+0x118>
    c086:	b8 cf       	rjmp	.-144    	; 0xbff8 <vfprintf+0x88>
    c088:	98 2f       	mov	r25, r24
    c08a:	95 54       	subi	r25, 0x45	; 69
    c08c:	93 30       	cpi	r25, 0x03	; 3
    c08e:	18 f0       	brcs	.+6      	; 0xc096 <vfprintf+0x126>
    c090:	90 52       	subi	r25, 0x20	; 32
    c092:	93 30       	cpi	r25, 0x03	; 3
    c094:	38 f4       	brcc	.+14     	; 0xc0a4 <vfprintf+0x134>
    c096:	24 e0       	ldi	r18, 0x04	; 4
    c098:	30 e0       	ldi	r19, 0x00	; 0
    c09a:	a2 0e       	add	r10, r18
    c09c:	b3 1e       	adc	r11, r19
    c09e:	3f e3       	ldi	r19, 0x3F	; 63
    c0a0:	39 83       	std	Y+1, r19	; 0x01
    c0a2:	0f c0       	rjmp	.+30     	; 0xc0c2 <vfprintf+0x152>
    c0a4:	83 36       	cpi	r24, 0x63	; 99
    c0a6:	31 f0       	breq	.+12     	; 0xc0b4 <vfprintf+0x144>
    c0a8:	83 37       	cpi	r24, 0x73	; 115
    c0aa:	81 f0       	breq	.+32     	; 0xc0cc <vfprintf+0x15c>
    c0ac:	83 35       	cpi	r24, 0x53	; 83
    c0ae:	09 f0       	breq	.+2      	; 0xc0b2 <vfprintf+0x142>
    c0b0:	5a c0       	rjmp	.+180    	; 0xc166 <vfprintf+0x1f6>
    c0b2:	22 c0       	rjmp	.+68     	; 0xc0f8 <vfprintf+0x188>
    c0b4:	f5 01       	movw	r30, r10
    c0b6:	80 81       	ld	r24, Z
    c0b8:	89 83       	std	Y+1, r24	; 0x01
    c0ba:	22 e0       	ldi	r18, 0x02	; 2
    c0bc:	30 e0       	ldi	r19, 0x00	; 0
    c0be:	a2 0e       	add	r10, r18
    c0c0:	b3 1e       	adc	r11, r19
    c0c2:	21 e0       	ldi	r18, 0x01	; 1
    c0c4:	c2 2e       	mov	r12, r18
    c0c6:	d1 2c       	mov	r13, r1
    c0c8:	42 01       	movw	r8, r4
    c0ca:	14 c0       	rjmp	.+40     	; 0xc0f4 <vfprintf+0x184>
    c0cc:	92 e0       	ldi	r25, 0x02	; 2
    c0ce:	29 2e       	mov	r2, r25
    c0d0:	31 2c       	mov	r3, r1
    c0d2:	2a 0c       	add	r2, r10
    c0d4:	3b 1c       	adc	r3, r11
    c0d6:	f5 01       	movw	r30, r10
    c0d8:	80 80       	ld	r8, Z
    c0da:	91 80       	ldd	r9, Z+1	; 0x01
    c0dc:	16 ff       	sbrs	r17, 6
    c0de:	03 c0       	rjmp	.+6      	; 0xc0e6 <vfprintf+0x176>
    c0e0:	6f 2d       	mov	r22, r15
    c0e2:	70 e0       	ldi	r23, 0x00	; 0
    c0e4:	02 c0       	rjmp	.+4      	; 0xc0ea <vfprintf+0x17a>
    c0e6:	6f ef       	ldi	r22, 0xFF	; 255
    c0e8:	7f ef       	ldi	r23, 0xFF	; 255
    c0ea:	c4 01       	movw	r24, r8
    c0ec:	0e 94 c4 61 	call	0xc388	; 0xc388 <strnlen>
    c0f0:	6c 01       	movw	r12, r24
    c0f2:	51 01       	movw	r10, r2
    c0f4:	1f 77       	andi	r17, 0x7F	; 127
    c0f6:	15 c0       	rjmp	.+42     	; 0xc122 <vfprintf+0x1b2>
    c0f8:	82 e0       	ldi	r24, 0x02	; 2
    c0fa:	28 2e       	mov	r2, r24
    c0fc:	31 2c       	mov	r3, r1
    c0fe:	2a 0c       	add	r2, r10
    c100:	3b 1c       	adc	r3, r11
    c102:	f5 01       	movw	r30, r10
    c104:	80 80       	ld	r8, Z
    c106:	91 80       	ldd	r9, Z+1	; 0x01
    c108:	16 ff       	sbrs	r17, 6
    c10a:	03 c0       	rjmp	.+6      	; 0xc112 <vfprintf+0x1a2>
    c10c:	6f 2d       	mov	r22, r15
    c10e:	70 e0       	ldi	r23, 0x00	; 0
    c110:	02 c0       	rjmp	.+4      	; 0xc116 <vfprintf+0x1a6>
    c112:	6f ef       	ldi	r22, 0xFF	; 255
    c114:	7f ef       	ldi	r23, 0xFF	; 255
    c116:	c4 01       	movw	r24, r8
    c118:	0e 94 b9 61 	call	0xc372	; 0xc372 <strnlen_P>
    c11c:	6c 01       	movw	r12, r24
    c11e:	10 68       	ori	r17, 0x80	; 128
    c120:	51 01       	movw	r10, r2
    c122:	13 fd       	sbrc	r17, 3
    c124:	1c c0       	rjmp	.+56     	; 0xc15e <vfprintf+0x1ee>
    c126:	06 c0       	rjmp	.+12     	; 0xc134 <vfprintf+0x1c4>
    c128:	80 e2       	ldi	r24, 0x20	; 32
    c12a:	90 e0       	ldi	r25, 0x00	; 0
    c12c:	b3 01       	movw	r22, r6
    c12e:	0e 94 df 61 	call	0xc3be	; 0xc3be <fputc>
    c132:	ea 94       	dec	r14
    c134:	8e 2d       	mov	r24, r14
    c136:	90 e0       	ldi	r25, 0x00	; 0
    c138:	c8 16       	cp	r12, r24
    c13a:	d9 06       	cpc	r13, r25
    c13c:	a8 f3       	brcs	.-22     	; 0xc128 <vfprintf+0x1b8>
    c13e:	0f c0       	rjmp	.+30     	; 0xc15e <vfprintf+0x1ee>
    c140:	f4 01       	movw	r30, r8
    c142:	17 fd       	sbrc	r17, 7
    c144:	85 91       	lpm	r24, Z+
    c146:	17 ff       	sbrs	r17, 7
    c148:	81 91       	ld	r24, Z+
    c14a:	4f 01       	movw	r8, r30
    c14c:	90 e0       	ldi	r25, 0x00	; 0
    c14e:	b3 01       	movw	r22, r6
    c150:	0e 94 df 61 	call	0xc3be	; 0xc3be <fputc>
    c154:	e1 10       	cpse	r14, r1
    c156:	ea 94       	dec	r14
    c158:	08 94       	sec
    c15a:	c1 08       	sbc	r12, r1
    c15c:	d1 08       	sbc	r13, r1
    c15e:	c1 14       	cp	r12, r1
    c160:	d1 04       	cpc	r13, r1
    c162:	71 f7       	brne	.-36     	; 0xc140 <vfprintf+0x1d0>
    c164:	e7 c0       	rjmp	.+462    	; 0xc334 <vfprintf+0x3c4>
    c166:	84 36       	cpi	r24, 0x64	; 100
    c168:	11 f0       	breq	.+4      	; 0xc16e <vfprintf+0x1fe>
    c16a:	89 36       	cpi	r24, 0x69	; 105
    c16c:	51 f5       	brne	.+84     	; 0xc1c2 <vfprintf+0x252>
    c16e:	f5 01       	movw	r30, r10
    c170:	17 ff       	sbrs	r17, 7
    c172:	07 c0       	rjmp	.+14     	; 0xc182 <vfprintf+0x212>
    c174:	80 81       	ld	r24, Z
    c176:	91 81       	ldd	r25, Z+1	; 0x01
    c178:	a2 81       	ldd	r26, Z+2	; 0x02
    c17a:	b3 81       	ldd	r27, Z+3	; 0x03
    c17c:	24 e0       	ldi	r18, 0x04	; 4
    c17e:	30 e0       	ldi	r19, 0x00	; 0
    c180:	08 c0       	rjmp	.+16     	; 0xc192 <vfprintf+0x222>
    c182:	80 81       	ld	r24, Z
    c184:	91 81       	ldd	r25, Z+1	; 0x01
    c186:	aa 27       	eor	r26, r26
    c188:	97 fd       	sbrc	r25, 7
    c18a:	a0 95       	com	r26
    c18c:	ba 2f       	mov	r27, r26
    c18e:	22 e0       	ldi	r18, 0x02	; 2
    c190:	30 e0       	ldi	r19, 0x00	; 0
    c192:	a2 0e       	add	r10, r18
    c194:	b3 1e       	adc	r11, r19
    c196:	01 2f       	mov	r16, r17
    c198:	0f 76       	andi	r16, 0x6F	; 111
    c19a:	b7 ff       	sbrs	r27, 7
    c19c:	08 c0       	rjmp	.+16     	; 0xc1ae <vfprintf+0x23e>
    c19e:	b0 95       	com	r27
    c1a0:	a0 95       	com	r26
    c1a2:	90 95       	com	r25
    c1a4:	81 95       	neg	r24
    c1a6:	9f 4f       	sbci	r25, 0xFF	; 255
    c1a8:	af 4f       	sbci	r26, 0xFF	; 255
    c1aa:	bf 4f       	sbci	r27, 0xFF	; 255
    c1ac:	00 68       	ori	r16, 0x80	; 128
    c1ae:	bc 01       	movw	r22, r24
    c1b0:	cd 01       	movw	r24, r26
    c1b2:	a2 01       	movw	r20, r4
    c1b4:	2a e0       	ldi	r18, 0x0A	; 10
    c1b6:	30 e0       	ldi	r19, 0x00	; 0
    c1b8:	0e 94 0b 62 	call	0xc416	; 0xc416 <__ultoa_invert>
    c1bc:	d8 2e       	mov	r13, r24
    c1be:	d4 18       	sub	r13, r4
    c1c0:	3f c0       	rjmp	.+126    	; 0xc240 <vfprintf+0x2d0>
    c1c2:	85 37       	cpi	r24, 0x75	; 117
    c1c4:	21 f4       	brne	.+8      	; 0xc1ce <vfprintf+0x25e>
    c1c6:	1f 7e       	andi	r17, 0xEF	; 239
    c1c8:	2a e0       	ldi	r18, 0x0A	; 10
    c1ca:	30 e0       	ldi	r19, 0x00	; 0
    c1cc:	20 c0       	rjmp	.+64     	; 0xc20e <vfprintf+0x29e>
    c1ce:	19 7f       	andi	r17, 0xF9	; 249
    c1d0:	8f 36       	cpi	r24, 0x6F	; 111
    c1d2:	a9 f0       	breq	.+42     	; 0xc1fe <vfprintf+0x28e>
    c1d4:	80 37       	cpi	r24, 0x70	; 112
    c1d6:	20 f4       	brcc	.+8      	; 0xc1e0 <vfprintf+0x270>
    c1d8:	88 35       	cpi	r24, 0x58	; 88
    c1da:	09 f0       	breq	.+2      	; 0xc1de <vfprintf+0x26e>
    c1dc:	ae c0       	rjmp	.+348    	; 0xc33a <vfprintf+0x3ca>
    c1de:	0b c0       	rjmp	.+22     	; 0xc1f6 <vfprintf+0x286>
    c1e0:	80 37       	cpi	r24, 0x70	; 112
    c1e2:	21 f0       	breq	.+8      	; 0xc1ec <vfprintf+0x27c>
    c1e4:	88 37       	cpi	r24, 0x78	; 120
    c1e6:	09 f0       	breq	.+2      	; 0xc1ea <vfprintf+0x27a>
    c1e8:	a8 c0       	rjmp	.+336    	; 0xc33a <vfprintf+0x3ca>
    c1ea:	01 c0       	rjmp	.+2      	; 0xc1ee <vfprintf+0x27e>
    c1ec:	10 61       	ori	r17, 0x10	; 16
    c1ee:	14 ff       	sbrs	r17, 4
    c1f0:	09 c0       	rjmp	.+18     	; 0xc204 <vfprintf+0x294>
    c1f2:	14 60       	ori	r17, 0x04	; 4
    c1f4:	07 c0       	rjmp	.+14     	; 0xc204 <vfprintf+0x294>
    c1f6:	14 ff       	sbrs	r17, 4
    c1f8:	08 c0       	rjmp	.+16     	; 0xc20a <vfprintf+0x29a>
    c1fa:	16 60       	ori	r17, 0x06	; 6
    c1fc:	06 c0       	rjmp	.+12     	; 0xc20a <vfprintf+0x29a>
    c1fe:	28 e0       	ldi	r18, 0x08	; 8
    c200:	30 e0       	ldi	r19, 0x00	; 0
    c202:	05 c0       	rjmp	.+10     	; 0xc20e <vfprintf+0x29e>
    c204:	20 e1       	ldi	r18, 0x10	; 16
    c206:	30 e0       	ldi	r19, 0x00	; 0
    c208:	02 c0       	rjmp	.+4      	; 0xc20e <vfprintf+0x29e>
    c20a:	20 e1       	ldi	r18, 0x10	; 16
    c20c:	32 e0       	ldi	r19, 0x02	; 2
    c20e:	f5 01       	movw	r30, r10
    c210:	17 ff       	sbrs	r17, 7
    c212:	07 c0       	rjmp	.+14     	; 0xc222 <vfprintf+0x2b2>
    c214:	60 81       	ld	r22, Z
    c216:	71 81       	ldd	r23, Z+1	; 0x01
    c218:	82 81       	ldd	r24, Z+2	; 0x02
    c21a:	93 81       	ldd	r25, Z+3	; 0x03
    c21c:	44 e0       	ldi	r20, 0x04	; 4
    c21e:	50 e0       	ldi	r21, 0x00	; 0
    c220:	06 c0       	rjmp	.+12     	; 0xc22e <vfprintf+0x2be>
    c222:	60 81       	ld	r22, Z
    c224:	71 81       	ldd	r23, Z+1	; 0x01
    c226:	80 e0       	ldi	r24, 0x00	; 0
    c228:	90 e0       	ldi	r25, 0x00	; 0
    c22a:	42 e0       	ldi	r20, 0x02	; 2
    c22c:	50 e0       	ldi	r21, 0x00	; 0
    c22e:	a4 0e       	add	r10, r20
    c230:	b5 1e       	adc	r11, r21
    c232:	a2 01       	movw	r20, r4
    c234:	0e 94 0b 62 	call	0xc416	; 0xc416 <__ultoa_invert>
    c238:	d8 2e       	mov	r13, r24
    c23a:	d4 18       	sub	r13, r4
    c23c:	01 2f       	mov	r16, r17
    c23e:	0f 77       	andi	r16, 0x7F	; 127
    c240:	06 ff       	sbrs	r16, 6
    c242:	09 c0       	rjmp	.+18     	; 0xc256 <vfprintf+0x2e6>
    c244:	0e 7f       	andi	r16, 0xFE	; 254
    c246:	df 14       	cp	r13, r15
    c248:	30 f4       	brcc	.+12     	; 0xc256 <vfprintf+0x2e6>
    c24a:	04 ff       	sbrs	r16, 4
    c24c:	06 c0       	rjmp	.+12     	; 0xc25a <vfprintf+0x2ea>
    c24e:	02 fd       	sbrc	r16, 2
    c250:	04 c0       	rjmp	.+8      	; 0xc25a <vfprintf+0x2ea>
    c252:	0f 7e       	andi	r16, 0xEF	; 239
    c254:	02 c0       	rjmp	.+4      	; 0xc25a <vfprintf+0x2ea>
    c256:	1d 2d       	mov	r17, r13
    c258:	01 c0       	rjmp	.+2      	; 0xc25c <vfprintf+0x2ec>
    c25a:	1f 2d       	mov	r17, r15
    c25c:	80 2f       	mov	r24, r16
    c25e:	90 e0       	ldi	r25, 0x00	; 0
    c260:	04 ff       	sbrs	r16, 4
    c262:	0c c0       	rjmp	.+24     	; 0xc27c <vfprintf+0x30c>
    c264:	fe 01       	movw	r30, r28
    c266:	ed 0d       	add	r30, r13
    c268:	f1 1d       	adc	r31, r1
    c26a:	20 81       	ld	r18, Z
    c26c:	20 33       	cpi	r18, 0x30	; 48
    c26e:	11 f4       	brne	.+4      	; 0xc274 <vfprintf+0x304>
    c270:	09 7e       	andi	r16, 0xE9	; 233
    c272:	09 c0       	rjmp	.+18     	; 0xc286 <vfprintf+0x316>
    c274:	02 ff       	sbrs	r16, 2
    c276:	06 c0       	rjmp	.+12     	; 0xc284 <vfprintf+0x314>
    c278:	1e 5f       	subi	r17, 0xFE	; 254
    c27a:	05 c0       	rjmp	.+10     	; 0xc286 <vfprintf+0x316>
    c27c:	86 78       	andi	r24, 0x86	; 134
    c27e:	90 70       	andi	r25, 0x00	; 0
    c280:	00 97       	sbiw	r24, 0x00	; 0
    c282:	09 f0       	breq	.+2      	; 0xc286 <vfprintf+0x316>
    c284:	1f 5f       	subi	r17, 0xFF	; 255
    c286:	80 2e       	mov	r8, r16
    c288:	99 24       	eor	r9, r9
    c28a:	03 fd       	sbrc	r16, 3
    c28c:	12 c0       	rjmp	.+36     	; 0xc2b2 <vfprintf+0x342>
    c28e:	00 ff       	sbrs	r16, 0
    c290:	0d c0       	rjmp	.+26     	; 0xc2ac <vfprintf+0x33c>
    c292:	fd 2c       	mov	r15, r13
    c294:	1e 15       	cp	r17, r14
    c296:	50 f4       	brcc	.+20     	; 0xc2ac <vfprintf+0x33c>
    c298:	fe 0c       	add	r15, r14
    c29a:	f1 1a       	sub	r15, r17
    c29c:	1e 2d       	mov	r17, r14
    c29e:	06 c0       	rjmp	.+12     	; 0xc2ac <vfprintf+0x33c>
    c2a0:	80 e2       	ldi	r24, 0x20	; 32
    c2a2:	90 e0       	ldi	r25, 0x00	; 0
    c2a4:	b3 01       	movw	r22, r6
    c2a6:	0e 94 df 61 	call	0xc3be	; 0xc3be <fputc>
    c2aa:	1f 5f       	subi	r17, 0xFF	; 255
    c2ac:	1e 15       	cp	r17, r14
    c2ae:	c0 f3       	brcs	.-16     	; 0xc2a0 <vfprintf+0x330>
    c2b0:	04 c0       	rjmp	.+8      	; 0xc2ba <vfprintf+0x34a>
    c2b2:	1e 15       	cp	r17, r14
    c2b4:	10 f4       	brcc	.+4      	; 0xc2ba <vfprintf+0x34a>
    c2b6:	e1 1a       	sub	r14, r17
    c2b8:	01 c0       	rjmp	.+2      	; 0xc2bc <vfprintf+0x34c>
    c2ba:	ee 24       	eor	r14, r14
    c2bc:	84 fe       	sbrs	r8, 4
    c2be:	0f c0       	rjmp	.+30     	; 0xc2de <vfprintf+0x36e>
    c2c0:	80 e3       	ldi	r24, 0x30	; 48
    c2c2:	90 e0       	ldi	r25, 0x00	; 0
    c2c4:	b3 01       	movw	r22, r6
    c2c6:	0e 94 df 61 	call	0xc3be	; 0xc3be <fputc>
    c2ca:	82 fe       	sbrs	r8, 2
    c2cc:	1f c0       	rjmp	.+62     	; 0xc30c <vfprintf+0x39c>
    c2ce:	81 fe       	sbrs	r8, 1
    c2d0:	03 c0       	rjmp	.+6      	; 0xc2d8 <vfprintf+0x368>
    c2d2:	88 e5       	ldi	r24, 0x58	; 88
    c2d4:	90 e0       	ldi	r25, 0x00	; 0
    c2d6:	10 c0       	rjmp	.+32     	; 0xc2f8 <vfprintf+0x388>
    c2d8:	88 e7       	ldi	r24, 0x78	; 120
    c2da:	90 e0       	ldi	r25, 0x00	; 0
    c2dc:	0d c0       	rjmp	.+26     	; 0xc2f8 <vfprintf+0x388>
    c2de:	c4 01       	movw	r24, r8
    c2e0:	86 78       	andi	r24, 0x86	; 134
    c2e2:	90 70       	andi	r25, 0x00	; 0
    c2e4:	00 97       	sbiw	r24, 0x00	; 0
    c2e6:	91 f0       	breq	.+36     	; 0xc30c <vfprintf+0x39c>
    c2e8:	81 fc       	sbrc	r8, 1
    c2ea:	02 c0       	rjmp	.+4      	; 0xc2f0 <vfprintf+0x380>
    c2ec:	80 e2       	ldi	r24, 0x20	; 32
    c2ee:	01 c0       	rjmp	.+2      	; 0xc2f2 <vfprintf+0x382>
    c2f0:	8b e2       	ldi	r24, 0x2B	; 43
    c2f2:	07 fd       	sbrc	r16, 7
    c2f4:	8d e2       	ldi	r24, 0x2D	; 45
    c2f6:	90 e0       	ldi	r25, 0x00	; 0
    c2f8:	b3 01       	movw	r22, r6
    c2fa:	0e 94 df 61 	call	0xc3be	; 0xc3be <fputc>
    c2fe:	06 c0       	rjmp	.+12     	; 0xc30c <vfprintf+0x39c>
    c300:	80 e3       	ldi	r24, 0x30	; 48
    c302:	90 e0       	ldi	r25, 0x00	; 0
    c304:	b3 01       	movw	r22, r6
    c306:	0e 94 df 61 	call	0xc3be	; 0xc3be <fputc>
    c30a:	fa 94       	dec	r15
    c30c:	df 14       	cp	r13, r15
    c30e:	c0 f3       	brcs	.-16     	; 0xc300 <vfprintf+0x390>
    c310:	da 94       	dec	r13
    c312:	f2 01       	movw	r30, r4
    c314:	ed 0d       	add	r30, r13
    c316:	f1 1d       	adc	r31, r1
    c318:	80 81       	ld	r24, Z
    c31a:	90 e0       	ldi	r25, 0x00	; 0
    c31c:	b3 01       	movw	r22, r6
    c31e:	0e 94 df 61 	call	0xc3be	; 0xc3be <fputc>
    c322:	dd 20       	and	r13, r13
    c324:	a9 f7       	brne	.-22     	; 0xc310 <vfprintf+0x3a0>
    c326:	06 c0       	rjmp	.+12     	; 0xc334 <vfprintf+0x3c4>
    c328:	80 e2       	ldi	r24, 0x20	; 32
    c32a:	90 e0       	ldi	r25, 0x00	; 0
    c32c:	b3 01       	movw	r22, r6
    c32e:	0e 94 df 61 	call	0xc3be	; 0xc3be <fputc>
    c332:	ea 94       	dec	r14
    c334:	ee 20       	and	r14, r14
    c336:	c1 f7       	brne	.-16     	; 0xc328 <vfprintf+0x3b8>
    c338:	40 ce       	rjmp	.-896    	; 0xbfba <vfprintf+0x4a>
    c33a:	f3 01       	movw	r30, r6
    c33c:	86 81       	ldd	r24, Z+6	; 0x06
    c33e:	97 81       	ldd	r25, Z+7	; 0x07
    c340:	02 c0       	rjmp	.+4      	; 0xc346 <vfprintf+0x3d6>
    c342:	8f ef       	ldi	r24, 0xFF	; 255
    c344:	9f ef       	ldi	r25, 0xFF	; 255
    c346:	2d 96       	adiw	r28, 0x0d	; 13
    c348:	cd bf       	out	0x3d, r28	; 61
    c34a:	de bf       	out	0x3e, r29	; 62
    c34c:	df 91       	pop	r29
    c34e:	cf 91       	pop	r28
    c350:	1f 91       	pop	r17
    c352:	0f 91       	pop	r16
    c354:	ff 90       	pop	r15
    c356:	ef 90       	pop	r14
    c358:	df 90       	pop	r13
    c35a:	cf 90       	pop	r12
    c35c:	bf 90       	pop	r11
    c35e:	af 90       	pop	r10
    c360:	9f 90       	pop	r9
    c362:	8f 90       	pop	r8
    c364:	7f 90       	pop	r7
    c366:	6f 90       	pop	r6
    c368:	5f 90       	pop	r5
    c36a:	4f 90       	pop	r4
    c36c:	3f 90       	pop	r3
    c36e:	2f 90       	pop	r2
    c370:	08 95       	ret

0000c372 <strnlen_P>:
    c372:	fc 01       	movw	r30, r24
    c374:	05 90       	lpm	r0, Z+
    c376:	61 50       	subi	r22, 0x01	; 1
    c378:	70 40       	sbci	r23, 0x00	; 0
    c37a:	01 10       	cpse	r0, r1
    c37c:	d8 f7       	brcc	.-10     	; 0xc374 <strnlen_P+0x2>
    c37e:	80 95       	com	r24
    c380:	90 95       	com	r25
    c382:	8e 0f       	add	r24, r30
    c384:	9f 1f       	adc	r25, r31
    c386:	08 95       	ret

0000c388 <strnlen>:
    c388:	fc 01       	movw	r30, r24
    c38a:	61 50       	subi	r22, 0x01	; 1
    c38c:	70 40       	sbci	r23, 0x00	; 0
    c38e:	01 90       	ld	r0, Z+
    c390:	01 10       	cpse	r0, r1
    c392:	d8 f7       	brcc	.-10     	; 0xc38a <strnlen+0x2>
    c394:	80 95       	com	r24
    c396:	90 95       	com	r25
    c398:	8e 0f       	add	r24, r30
    c39a:	9f 1f       	adc	r25, r31
    c39c:	08 95       	ret

0000c39e <strrev>:
    c39e:	dc 01       	movw	r26, r24
    c3a0:	fc 01       	movw	r30, r24
    c3a2:	67 2f       	mov	r22, r23
    c3a4:	71 91       	ld	r23, Z+
    c3a6:	77 23       	and	r23, r23
    c3a8:	e1 f7       	brne	.-8      	; 0xc3a2 <strrev+0x4>
    c3aa:	32 97       	sbiw	r30, 0x02	; 2
    c3ac:	04 c0       	rjmp	.+8      	; 0xc3b6 <strrev+0x18>
    c3ae:	7c 91       	ld	r23, X
    c3b0:	6d 93       	st	X+, r22
    c3b2:	70 83       	st	Z, r23
    c3b4:	62 91       	ld	r22, -Z
    c3b6:	ae 17       	cp	r26, r30
    c3b8:	bf 07       	cpc	r27, r31
    c3ba:	c8 f3       	brcs	.-14     	; 0xc3ae <strrev+0x10>
    c3bc:	08 95       	ret

0000c3be <fputc>:
    c3be:	0f 93       	push	r16
    c3c0:	1f 93       	push	r17
    c3c2:	cf 93       	push	r28
    c3c4:	df 93       	push	r29
    c3c6:	8c 01       	movw	r16, r24
    c3c8:	eb 01       	movw	r28, r22
    c3ca:	8b 81       	ldd	r24, Y+3	; 0x03
    c3cc:	81 ff       	sbrs	r24, 1
    c3ce:	1b c0       	rjmp	.+54     	; 0xc406 <fputc+0x48>
    c3d0:	82 ff       	sbrs	r24, 2
    c3d2:	0d c0       	rjmp	.+26     	; 0xc3ee <fputc+0x30>
    c3d4:	2e 81       	ldd	r18, Y+6	; 0x06
    c3d6:	3f 81       	ldd	r19, Y+7	; 0x07
    c3d8:	8c 81       	ldd	r24, Y+4	; 0x04
    c3da:	9d 81       	ldd	r25, Y+5	; 0x05
    c3dc:	28 17       	cp	r18, r24
    c3de:	39 07       	cpc	r19, r25
    c3e0:	64 f4       	brge	.+24     	; 0xc3fa <fputc+0x3c>
    c3e2:	e8 81       	ld	r30, Y
    c3e4:	f9 81       	ldd	r31, Y+1	; 0x01
    c3e6:	01 93       	st	Z+, r16
    c3e8:	e8 83       	st	Y, r30
    c3ea:	f9 83       	std	Y+1, r31	; 0x01
    c3ec:	06 c0       	rjmp	.+12     	; 0xc3fa <fputc+0x3c>
    c3ee:	e8 85       	ldd	r30, Y+8	; 0x08
    c3f0:	f9 85       	ldd	r31, Y+9	; 0x09
    c3f2:	80 2f       	mov	r24, r16
    c3f4:	19 95       	eicall
    c3f6:	00 97       	sbiw	r24, 0x00	; 0
    c3f8:	31 f4       	brne	.+12     	; 0xc406 <fputc+0x48>
    c3fa:	8e 81       	ldd	r24, Y+6	; 0x06
    c3fc:	9f 81       	ldd	r25, Y+7	; 0x07
    c3fe:	01 96       	adiw	r24, 0x01	; 1
    c400:	8e 83       	std	Y+6, r24	; 0x06
    c402:	9f 83       	std	Y+7, r25	; 0x07
    c404:	02 c0       	rjmp	.+4      	; 0xc40a <fputc+0x4c>
    c406:	0f ef       	ldi	r16, 0xFF	; 255
    c408:	1f ef       	ldi	r17, 0xFF	; 255
    c40a:	c8 01       	movw	r24, r16
    c40c:	df 91       	pop	r29
    c40e:	cf 91       	pop	r28
    c410:	1f 91       	pop	r17
    c412:	0f 91       	pop	r16
    c414:	08 95       	ret

0000c416 <__ultoa_invert>:
    c416:	fa 01       	movw	r30, r20
    c418:	aa 27       	eor	r26, r26
    c41a:	28 30       	cpi	r18, 0x08	; 8
    c41c:	51 f1       	breq	.+84     	; 0xc472 <__ultoa_invert+0x5c>
    c41e:	20 31       	cpi	r18, 0x10	; 16
    c420:	81 f1       	breq	.+96     	; 0xc482 <__ultoa_invert+0x6c>
    c422:	e8 94       	clt
    c424:	6f 93       	push	r22
    c426:	6e 7f       	andi	r22, 0xFE	; 254
    c428:	6e 5f       	subi	r22, 0xFE	; 254
    c42a:	7f 4f       	sbci	r23, 0xFF	; 255
    c42c:	8f 4f       	sbci	r24, 0xFF	; 255
    c42e:	9f 4f       	sbci	r25, 0xFF	; 255
    c430:	af 4f       	sbci	r26, 0xFF	; 255
    c432:	b1 e0       	ldi	r27, 0x01	; 1
    c434:	3e d0       	rcall	.+124    	; 0xc4b2 <__ultoa_invert+0x9c>
    c436:	b4 e0       	ldi	r27, 0x04	; 4
    c438:	3c d0       	rcall	.+120    	; 0xc4b2 <__ultoa_invert+0x9c>
    c43a:	67 0f       	add	r22, r23
    c43c:	78 1f       	adc	r23, r24
    c43e:	89 1f       	adc	r24, r25
    c440:	9a 1f       	adc	r25, r26
    c442:	a1 1d       	adc	r26, r1
    c444:	68 0f       	add	r22, r24
    c446:	79 1f       	adc	r23, r25
    c448:	8a 1f       	adc	r24, r26
    c44a:	91 1d       	adc	r25, r1
    c44c:	a1 1d       	adc	r26, r1
    c44e:	6a 0f       	add	r22, r26
    c450:	71 1d       	adc	r23, r1
    c452:	81 1d       	adc	r24, r1
    c454:	91 1d       	adc	r25, r1
    c456:	a1 1d       	adc	r26, r1
    c458:	20 d0       	rcall	.+64     	; 0xc49a <__ultoa_invert+0x84>
    c45a:	09 f4       	brne	.+2      	; 0xc45e <__ultoa_invert+0x48>
    c45c:	68 94       	set
    c45e:	3f 91       	pop	r19
    c460:	2a e0       	ldi	r18, 0x0A	; 10
    c462:	26 9f       	mul	r18, r22
    c464:	11 24       	eor	r1, r1
    c466:	30 19       	sub	r19, r0
    c468:	30 5d       	subi	r19, 0xD0	; 208
    c46a:	31 93       	st	Z+, r19
    c46c:	de f6       	brtc	.-74     	; 0xc424 <__ultoa_invert+0xe>
    c46e:	cf 01       	movw	r24, r30
    c470:	08 95       	ret
    c472:	46 2f       	mov	r20, r22
    c474:	47 70       	andi	r20, 0x07	; 7
    c476:	40 5d       	subi	r20, 0xD0	; 208
    c478:	41 93       	st	Z+, r20
    c47a:	b3 e0       	ldi	r27, 0x03	; 3
    c47c:	0f d0       	rcall	.+30     	; 0xc49c <__ultoa_invert+0x86>
    c47e:	c9 f7       	brne	.-14     	; 0xc472 <__ultoa_invert+0x5c>
    c480:	f6 cf       	rjmp	.-20     	; 0xc46e <__ultoa_invert+0x58>
    c482:	46 2f       	mov	r20, r22
    c484:	4f 70       	andi	r20, 0x0F	; 15
    c486:	40 5d       	subi	r20, 0xD0	; 208
    c488:	4a 33       	cpi	r20, 0x3A	; 58
    c48a:	18 f0       	brcs	.+6      	; 0xc492 <__ultoa_invert+0x7c>
    c48c:	49 5d       	subi	r20, 0xD9	; 217
    c48e:	31 fd       	sbrc	r19, 1
    c490:	40 52       	subi	r20, 0x20	; 32
    c492:	41 93       	st	Z+, r20
    c494:	02 d0       	rcall	.+4      	; 0xc49a <__ultoa_invert+0x84>
    c496:	a9 f7       	brne	.-22     	; 0xc482 <__ultoa_invert+0x6c>
    c498:	ea cf       	rjmp	.-44     	; 0xc46e <__ultoa_invert+0x58>
    c49a:	b4 e0       	ldi	r27, 0x04	; 4
    c49c:	a6 95       	lsr	r26
    c49e:	97 95       	ror	r25
    c4a0:	87 95       	ror	r24
    c4a2:	77 95       	ror	r23
    c4a4:	67 95       	ror	r22
    c4a6:	ba 95       	dec	r27
    c4a8:	c9 f7       	brne	.-14     	; 0xc49c <__ultoa_invert+0x86>
    c4aa:	00 97       	sbiw	r24, 0x00	; 0
    c4ac:	61 05       	cpc	r22, r1
    c4ae:	71 05       	cpc	r23, r1
    c4b0:	08 95       	ret
    c4b2:	9b 01       	movw	r18, r22
    c4b4:	ac 01       	movw	r20, r24
    c4b6:	0a 2e       	mov	r0, r26
    c4b8:	06 94       	lsr	r0
    c4ba:	57 95       	ror	r21
    c4bc:	47 95       	ror	r20
    c4be:	37 95       	ror	r19
    c4c0:	27 95       	ror	r18
    c4c2:	ba 95       	dec	r27
    c4c4:	c9 f7       	brne	.-14     	; 0xc4b8 <__ultoa_invert+0xa2>
    c4c6:	62 0f       	add	r22, r18
    c4c8:	73 1f       	adc	r23, r19
    c4ca:	84 1f       	adc	r24, r20
    c4cc:	95 1f       	adc	r25, r21
    c4ce:	a0 1d       	adc	r26, r0
    c4d0:	08 95       	ret

0000c4d2 <_exit>:
    c4d2:	f8 94       	cli

0000c4d4 <__stop_program>:
    c4d4:	ff cf       	rjmp	.-2      	; 0xc4d4 <__stop_program>
