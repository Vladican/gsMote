
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007ae4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000010e  00802000  00007ae4  00007b78  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fae  0080210e  0080210e  00007c86  2**0
                  ALLOC
  3 .stab         000028f8  00000000  00000000  00007c88  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009ca  00000000  00000000  0000a580  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000420  00000000  00000000  0000af50  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000c21c  00000000  00000000  0000b370  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000270c  00000000  00000000  0001758c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005901  00000000  00000000  00019c98  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001be0  00000000  00000000  0001f59c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000046a8  00000000  00000000  0002117c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000828b  00000000  00000000  00025824  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0017fdaa  00000000  00000000  0002daaf  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000001c0  00000000  00000000  001ad859  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 a4 0e 	jmp	0x1d48	; 0x1d48 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 dc 13 	jmp	0x27b8	; 0x27b8 <__vector_16>
      44:	0c 94 b4 13 	jmp	0x2768	; 0x2768 <__vector_17>
      48:	0c 94 8c 13 	jmp	0x2718	; 0x2718 <__vector_18>
      4c:	0c 94 46 13 	jmp	0x268c	; 0x268c <__vector_19>
      50:	0c 94 c1 0c 	jmp	0x1982	; 0x1982 <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 7f 09 	jmp	0x12fe	; 0x12fe <__vector_47>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 b7 1e 	jmp	0x3d6e	; 0x3d6e <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 83 10 	jmp	0x2106	; 0x2106 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 1e 13 	jmp	0x263c	; 0x263c <__vector_79>
     140:	0c 94 f6 12 	jmp	0x25ec	; 0x25ec <__vector_80>
     144:	0c 94 ce 12 	jmp	0x259c	; 0x259c <__vector_81>
     148:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <__vector_82>
     14c:	0c 94 c6 09 	jmp	0x138c	; 0x138c <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 53 0d 	jmp	0x1aa6	; 0x1aa6 <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e4 ee       	ldi	r30, 0xE4	; 228
     244:	fa e7       	ldi	r31, 0x7A	; 122
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	ae 30       	cpi	r26, 0x0E	; 14
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	ae e0       	ldi	r26, 0x0E	; 14
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	ac 3b       	cpi	r26, 0xBC	; 188
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 01 07 	call	0xe02	; 0xe02 <main>
     26a:	0c 94 70 3d 	jmp	0x7ae0	; 0x7ae0 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <writeFRAM>:
 * Created: 3/8/2014 11:40:36 AM
 *  Author: VLAD
 */ 
#include "FRAM.h"

void writeFRAM(uint8_t* buffer, uint16_t length) {
     272:	af 92       	push	r10
     274:	bf 92       	push	r11
     276:	df 92       	push	r13
     278:	ef 92       	push	r14
     27a:	ff 92       	push	r15
     27c:	0f 93       	push	r16
     27e:	1f 93       	push	r17
     280:	cf 93       	push	r28
     282:	df 93       	push	r29
     284:	e8 2e       	mov	r14, r24
     286:	d9 2e       	mov	r13, r25
     288:	8b 01       	movw	r16, r22
	
	uint8_t prev_SPI_settings;
	ADCPower(TRUE);
     28a:	81 e0       	ldi	r24, 0x01	; 1
     28c:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <ADCPower>
	
	prev_SPI_settings = SPIC.CTRL;
     290:	c0 ec       	ldi	r28, 0xC0	; 192
     292:	d8 e0       	ldi	r29, 0x08	; 8
     294:	f8 80       	ld	r15, Y
	SPIInit(SPI_MODE_0_gc);
     296:	80 e0       	ldi	r24, 0x00	; 0
     298:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     29c:	80 ed       	ldi	r24, 0xD0	; 208
     29e:	88 83       	st	Y, r24
	SPICS(TRUE);
     2a0:	81 e0       	ldi	r24, 0x01	; 1
     2a2:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2a6:	88 e0       	ldi	r24, 0x08	; 8
     2a8:	e0 e2       	ldi	r30, 0x20	; 32
     2aa:	f6 e0       	ldi	r31, 0x06	; 6
     2ac:	86 83       	std	Z+6, r24	; 0x06
	nop();
     2ae:	00 00       	nop
	SPIC.DATA = FR_WREN;
     2b0:	86 e0       	ldi	r24, 0x06	; 6
     2b2:	8b 83       	std	Y+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2b4:	e0 ec       	ldi	r30, 0xC0	; 192
     2b6:	f8 e0       	ldi	r31, 0x08	; 8
     2b8:	82 81       	ldd	r24, Z+2	; 0x02
     2ba:	88 23       	and	r24, r24
     2bc:	ec f7       	brge	.-6      	; 0x2b8 <writeFRAM+0x46>
	SPIBuffer[12] = SPIC.DATA;
     2be:	e0 ec       	ldi	r30, 0xC0	; 192
     2c0:	f8 e0       	ldi	r31, 0x08	; 8
     2c2:	83 81       	ldd	r24, Z+3	; 0x03
     2c4:	80 93 31 3e 	sts	0x3E31, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
     2c8:	a0 e2       	ldi	r26, 0x20	; 32
     2ca:	b6 e0       	ldi	r27, 0x06	; 6
     2cc:	88 e0       	ldi	r24, 0x08	; 8
     2ce:	15 96       	adiw	r26, 0x05	; 5
     2d0:	8c 93       	st	X, r24
     2d2:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
     2d4:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2d6:	16 96       	adiw	r26, 0x06	; 6
     2d8:	8c 93       	st	X, r24
     2da:	16 97       	sbiw	r26, 0x06	; 6
	nop();
     2dc:	00 00       	nop
	SPIC.DATA = FR_WRITE;
     2de:	82 e0       	ldi	r24, 0x02	; 2
     2e0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2e2:	82 81       	ldd	r24, Z+2	; 0x02
     2e4:	88 23       	and	r24, r24
     2e6:	ec f7       	brge	.-6      	; 0x2e2 <writeFRAM+0x70>
	SPIBuffer[12] = SPIC.DATA;
     2e8:	e0 ec       	ldi	r30, 0xC0	; 192
     2ea:	f8 e0       	ldi	r31, 0x08	; 8
     2ec:	83 81       	ldd	r24, Z+3	; 0x03
     2ee:	80 93 31 3e 	sts	0x3E31, r24
	//send address at which to start writing data
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
     2f2:	80 91 23 3e 	lds	r24, 0x3E23
     2f6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2f8:	82 81       	ldd	r24, Z+2	; 0x02
     2fa:	88 23       	and	r24, r24
     2fc:	ec f7       	brge	.-6      	; 0x2f8 <writeFRAM+0x86>
	SPIBuffer[12] = SPIC.DATA;
     2fe:	e0 ec       	ldi	r30, 0xC0	; 192
     300:	f8 e0       	ldi	r31, 0x08	; 8
     302:	83 81       	ldd	r24, Z+3	; 0x03
     304:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
     308:	80 91 22 3e 	lds	r24, 0x3E22
     30c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     30e:	82 81       	ldd	r24, Z+2	; 0x02
     310:	88 23       	and	r24, r24
     312:	ec f7       	brge	.-6      	; 0x30e <writeFRAM+0x9c>
	SPIBuffer[12] = SPIC.DATA;
     314:	e0 ec       	ldi	r30, 0xC0	; 192
     316:	f8 e0       	ldi	r31, 0x08	; 8
     318:	83 81       	ldd	r24, Z+3	; 0x03
     31a:	80 93 31 3e 	sts	0x3E31, r24
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     31e:	a8 01       	movw	r20, r16
     320:	60 e0       	ldi	r22, 0x00	; 0
     322:	70 e0       	ldi	r23, 0x00	; 0
     324:	41 15       	cp	r20, r1
     326:	51 05       	cpc	r21, r1
     328:	61 05       	cpc	r22, r1
     32a:	71 05       	cpc	r23, r1
     32c:	c9 f0       	breq	.+50     	; 0x360 <writeFRAM+0xee>
     32e:	ae 2c       	mov	r10, r14
     330:	bd 2c       	mov	r11, r13
     332:	80 e0       	ldi	r24, 0x00	; 0
     334:	90 e0       	ldi	r25, 0x00	; 0
     336:	dc 01       	movw	r26, r24
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     338:	21 e3       	ldi	r18, 0x31	; 49
     33a:	3e e3       	ldi	r19, 0x3E	; 62
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
		SPIC.DATA = buffer[i];
     33c:	e5 01       	movw	r28, r10
     33e:	e9 90       	ld	r14, Y+
     340:	5e 01       	movw	r10, r28
     342:	e3 82       	std	Z+3, r14	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
     344:	e2 80       	ldd	r14, Z+2	; 0x02
     346:	ee 20       	and	r14, r14
     348:	ec f7       	brge	.-6      	; 0x344 <writeFRAM+0xd2>
		SPIBuffer[12] = SPIC.DATA;
     34a:	e3 80       	ldd	r14, Z+3	; 0x03
     34c:	e9 01       	movw	r28, r18
     34e:	e8 82       	st	Y, r14
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     350:	01 96       	adiw	r24, 0x01	; 1
     352:	a1 1d       	adc	r26, r1
     354:	b1 1d       	adc	r27, r1
     356:	84 17       	cp	r24, r20
     358:	95 07       	cpc	r25, r21
     35a:	a6 07       	cpc	r26, r22
     35c:	b7 07       	cpc	r27, r23
     35e:	70 f3       	brcs	.-36     	; 0x33c <writeFRAM+0xca>
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
     360:	88 e0       	ldi	r24, 0x08	; 8
     362:	e0 e2       	ldi	r30, 0x20	; 32
     364:	f6 e0       	ldi	r31, 0x06	; 6
     366:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     368:	80 e0       	ldi	r24, 0x00	; 0
     36a:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	SPIC.CTRL = prev_SPI_settings;
     36e:	f0 92 c0 08 	sts	0x08C0, r15
	//SPIC.CTRL = ADC_SPI_CONFIG_gc;
	//PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
	
	//increment address by the written length
	FRAMAddress +=length;
     372:	80 91 22 3e 	lds	r24, 0x3E22
     376:	90 91 23 3e 	lds	r25, 0x3E23
     37a:	08 0f       	add	r16, r24
     37c:	19 1f       	adc	r17, r25
     37e:	00 93 22 3e 	sts	0x3E22, r16
     382:	10 93 23 3e 	sts	0x3E23, r17
}
     386:	df 91       	pop	r29
     388:	cf 91       	pop	r28
     38a:	1f 91       	pop	r17
     38c:	0f 91       	pop	r16
     38e:	ff 90       	pop	r15
     390:	ef 90       	pop	r14
     392:	df 90       	pop	r13
     394:	bf 90       	pop	r11
     396:	af 90       	pop	r10
     398:	08 95       	ret

0000039a <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes, uint16_t startAddress) {
     39a:	df 92       	push	r13
     39c:	ef 92       	push	r14
     39e:	ff 92       	push	r15
     3a0:	0f 93       	push	r16
     3a2:	1f 93       	push	r17
     3a4:	cf 93       	push	r28
     3a6:	df 93       	push	r29
     3a8:	0f 92       	push	r0
     3aa:	0f 92       	push	r0
     3ac:	cd b7       	in	r28, 0x3d	; 61
     3ae:	de b7       	in	r29, 0x3e	; 62
     3b0:	7c 01       	movw	r14, r24
     3b2:	69 83       	std	Y+1, r22	; 0x01
     3b4:	7a 83       	std	Y+2, r23	; 0x02
	
	//save SPI registers
	uint8_t prev_SPI_settings;
	ADCPower(TRUE);
     3b6:	81 e0       	ldi	r24, 0x01	; 1
     3b8:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <ADCPower>
	
	prev_SPI_settings = SPIC.CTRL;
     3bc:	00 ec       	ldi	r16, 0xC0	; 192
     3be:	18 e0       	ldi	r17, 0x08	; 8
     3c0:	f8 01       	movw	r30, r16
     3c2:	d0 80       	ld	r13, Z
	SPIInit(SPI_MODE_0_gc);
     3c4:	80 e0       	ldi	r24, 0x00	; 0
     3c6:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     3ca:	80 ed       	ldi	r24, 0xD0	; 208
     3cc:	f8 01       	movw	r30, r16
     3ce:	80 83       	st	Z, r24
	SPICS(TRUE);
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     3d6:	88 e0       	ldi	r24, 0x08	; 8
     3d8:	e0 e2       	ldi	r30, 0x20	; 32
     3da:	f6 e0       	ldi	r31, 0x06	; 6
     3dc:	86 83       	std	Z+6, r24	; 0x06
	nop();
     3de:	00 00       	nop
	
	SPIC.DATA = FR_READ;
     3e0:	83 e0       	ldi	r24, 0x03	; 3
     3e2:	f8 01       	movw	r30, r16
     3e4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3e6:	82 81       	ldd	r24, Z+2	; 0x02
     3e8:	88 23       	and	r24, r24
     3ea:	ec f7       	brge	.-6      	; 0x3e6 <readFRAM+0x4c>
	SPIBuffer[12] = SPIC.DATA;
     3ec:	e0 ec       	ldi	r30, 0xC0	; 192
     3ee:	f8 e0       	ldi	r31, 0x08	; 8
     3f0:	83 81       	ldd	r24, Z+3	; 0x03
     3f2:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = *(((uint8_t*)&startAddress) + 1);;
     3f6:	8a 81       	ldd	r24, Y+2	; 0x02
     3f8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3fa:	82 81       	ldd	r24, Z+2	; 0x02
     3fc:	88 23       	and	r24, r24
     3fe:	ec f7       	brge	.-6      	; 0x3fa <readFRAM+0x60>
	SPIBuffer[12] = SPIC.DATA;
     400:	e0 ec       	ldi	r30, 0xC0	; 192
     402:	f8 e0       	ldi	r31, 0x08	; 8
     404:	83 81       	ldd	r24, Z+3	; 0x03
     406:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
     40a:	89 81       	ldd	r24, Y+1	; 0x01
     40c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     40e:	82 81       	ldd	r24, Z+2	; 0x02
     410:	88 23       	and	r24, r24
     412:	ec f7       	brge	.-6      	; 0x40e <readFRAM+0x74>
	SPIBuffer[12] = SPIC.DATA;
     414:	e0 ec       	ldi	r30, 0xC0	; 192
     416:	f8 e0       	ldi	r31, 0x08	; 8
     418:	83 81       	ldd	r24, Z+3	; 0x03
     41a:	80 93 31 3e 	sts	0x3E31, r24
	
	for(uint16_t i = 0; i < numBytes; i++) {
     41e:	e1 14       	cp	r14, r1
     420:	f1 04       	cpc	r15, r1
     422:	b9 f0       	breq	.+46     	; 0x452 <readFRAM+0xb8>
     424:	e1 eb       	ldi	r30, 0xB1	; 177
     426:	f1 e2       	ldi	r31, 0x21	; 33
	FRAMAddress +=length;
}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes, uint16_t startAddress) {
     428:	c7 01       	movw	r24, r14
     42a:	8e 0f       	add	r24, r30
     42c:	9f 1f       	adc	r25, r31
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
		SPIC.DATA = 0xAA;
     42e:	a0 ec       	ldi	r26, 0xC0	; 192
     430:	b8 e0       	ldi	r27, 0x08	; 8
     432:	3a ea       	ldi	r19, 0xAA	; 170
     434:	13 96       	adiw	r26, 0x03	; 3
     436:	3c 93       	st	X, r19
     438:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     43a:	12 96       	adiw	r26, 0x02	; 2
     43c:	2c 91       	ld	r18, X
     43e:	12 97       	sbiw	r26, 0x02	; 2
     440:	22 23       	and	r18, r18
     442:	dc f7       	brge	.-10     	; 0x43a <readFRAM+0xa0>
		FRAMReadBuffer[i] = SPIC.DATA;
     444:	13 96       	adiw	r26, 0x03	; 3
     446:	2c 91       	ld	r18, X
     448:	13 97       	sbiw	r26, 0x03	; 3
     44a:	21 93       	st	Z+, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
     44c:	e8 17       	cp	r30, r24
     44e:	f9 07       	cpc	r31, r25
     450:	89 f7       	brne	.-30     	; 0x434 <readFRAM+0x9a>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
     452:	88 e0       	ldi	r24, 0x08	; 8
     454:	e0 e2       	ldi	r30, 0x20	; 32
     456:	f6 e0       	ldi	r31, 0x06	; 6
     458:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     45a:	80 e0       	ldi	r24, 0x00	; 0
     45c:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	SPIC.CTRL = prev_SPI_settings;
     460:	d0 92 c0 08 	sts	0x08C0, r13

}
     464:	0f 90       	pop	r0
     466:	0f 90       	pop	r0
     468:	df 91       	pop	r29
     46a:	cf 91       	pop	r28
     46c:	1f 91       	pop	r17
     46e:	0f 91       	pop	r16
     470:	ff 90       	pop	r15
     472:	ef 90       	pop	r14
     474:	df 90       	pop	r13
     476:	08 95       	ret

00000478 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     478:	cf 92       	push	r12
     47a:	df 92       	push	r13
     47c:	ef 92       	push	r14
     47e:	ff 92       	push	r15
     480:	0f 93       	push	r16
     482:	1f 93       	push	r17
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
     488:	6b 01       	movw	r12, r22
     48a:	7c 01       	movw	r14, r24
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     48c:	dc 01       	movw	r26, r24
     48e:	cb 01       	movw	r24, r22
     490:	88 55       	subi	r24, 0x58	; 88
     492:	92 40       	sbci	r25, 0x02	; 2
     494:	a0 40       	sbci	r26, 0x00	; 0
     496:	b0 40       	sbci	r27, 0x00	; 0
     498:	89 3e       	cpi	r24, 0xE9	; 233
     49a:	2f e3       	ldi	r18, 0x3F	; 63
     49c:	92 07       	cpc	r25, r18
     49e:	2f e0       	ldi	r18, 0x0F	; 15
     4a0:	a2 07       	cpc	r26, r18
     4a2:	20 e0       	ldi	r18, 0x00	; 0
     4a4:	b2 07       	cpc	r27, r18
     4a6:	08 f0       	brcs	.+2      	; 0x4aa <StartSerial+0x32>
     4a8:	5c c0       	rjmp	.+184    	; 0x562 <StartSerial+0xea>
		//baud rate too fast or too slow
		return false;
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     4aa:	0e 94 62 03 	call	0x6c4	; 0x6c4 <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     4ae:	e0 e4       	ldi	r30, 0x40	; 64
     4b0:	f6 e0       	ldi	r31, 0x06	; 6
     4b2:	88 e0       	ldi	r24, 0x08	; 8
     4b4:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = PIN3_bm;
     4b6:	85 83       	std	Z+5, r24	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     4b8:	84 e0       	ldi	r24, 0x04	; 4
     4ba:	82 83       	std	Z+2, r24	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     4bc:	cc 0c       	add	r12, r12
     4be:	dd 1c       	adc	r13, r13
     4c0:	ee 1c       	adc	r14, r14
     4c2:	ff 1c       	adc	r15, r15
     4c4:	cc 0c       	add	r12, r12
     4c6:	dd 1c       	adc	r13, r13
     4c8:	ee 1c       	adc	r14, r14
     4ca:	ff 1c       	adc	r15, r15
     4cc:	c7 01       	movw	r24, r14
     4ce:	b6 01       	movw	r22, r12
     4d0:	66 0f       	add	r22, r22
     4d2:	77 1f       	adc	r23, r23
     4d4:	88 1f       	adc	r24, r24
     4d6:	99 1f       	adc	r25, r25
     4d8:	66 0f       	add	r22, r22
     4da:	77 1f       	adc	r23, r23
     4dc:	88 1f       	adc	r24, r24
     4de:	99 1f       	adc	r25, r25
     4e0:	0e 94 cc 38 	call	0x7198	; 0x7198 <__floatunsisf>
     4e4:	9b 01       	movw	r18, r22
     4e6:	ac 01       	movw	r20, r24
     4e8:	60 e0       	ldi	r22, 0x00	; 0
     4ea:	74 e2       	ldi	r23, 0x24	; 36
     4ec:	84 ef       	ldi	r24, 0xF4	; 244
     4ee:	9b e4       	ldi	r25, 0x4B	; 75
     4f0:	0e 94 38 38 	call	0x7070	; 0x7070 <__divsf3>
     4f4:	20 e0       	ldi	r18, 0x00	; 0
     4f6:	30 e0       	ldi	r19, 0x00	; 0
     4f8:	40 e8       	ldi	r20, 0x80	; 128
     4fa:	5f e3       	ldi	r21, 0x3F	; 63
     4fc:	0e 94 d3 37 	call	0x6fa6	; 0x6fa6 <__subsf3>
     500:	c6 2f       	mov	r28, r22
     502:	d7 2f       	mov	r29, r23
     504:	18 2f       	mov	r17, r24
     506:	09 2f       	mov	r16, r25
     508:	86 2f       	mov	r24, r22
     50a:	9d 2f       	mov	r25, r29
     50c:	a1 2f       	mov	r26, r17
     50e:	b0 2f       	mov	r27, r16
     510:	bc 01       	movw	r22, r24
     512:	cd 01       	movw	r24, r26
     514:	0e 94 a0 38 	call	0x7140	; 0x7140 <__fixunssfsi>
     518:	6b 01       	movw	r12, r22
     51a:	7c 01       	movw	r14, r24
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     51c:	80 e0       	ldi	r24, 0x00	; 0
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	0e 94 cc 38 	call	0x7198	; 0x7198 <__floatunsisf>
     524:	9b 01       	movw	r18, r22
     526:	ac 01       	movw	r20, r24
     528:	8c 2f       	mov	r24, r28
     52a:	9d 2f       	mov	r25, r29
     52c:	a1 2f       	mov	r26, r17
     52e:	b0 2f       	mov	r27, r16
     530:	bc 01       	movw	r22, r24
     532:	cd 01       	movw	r24, r26
     534:	0e 94 d3 37 	call	0x6fa6	; 0x6fa6 <__subsf3>
     538:	20 e0       	ldi	r18, 0x00	; 0
     53a:	30 e0       	ldi	r19, 0x00	; 0
     53c:	40 e0       	ldi	r20, 0x00	; 0
     53e:	5f e3       	ldi	r21, 0x3F	; 63
     540:	0e 94 5a 39 	call	0x72b4	; 0x72b4 <__gesf2>
     544:	88 23       	and	r24, r24
     546:	1c f0       	brlt	.+6      	; 0x54e <StartSerial+0xd6>
     548:	08 94       	sec
     54a:	c1 1c       	adc	r12, r1
     54c:	d1 1c       	adc	r13, r1
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     54e:	e0 ea       	ldi	r30, 0xA0	; 160
     550:	f8 e0       	ldi	r31, 0x08	; 8
     552:	c6 82       	std	Z+6, r12	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     554:	d7 82       	std	Z+7, r13	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     556:	83 e0       	ldi	r24, 0x03	; 3
     558:	85 83       	std	Z+5, r24	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     55a:	88 e1       	ldi	r24, 0x18	; 24
     55c:	84 83       	std	Z+4, r24	; 0x04
	return true;
     55e:	81 e0       	ldi	r24, 0x01	; 1
     560:	01 c0       	rjmp	.+2      	; 0x564 <StartSerial+0xec>

bool StartSerial(uint32_t BaudRate){
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
		//baud rate too fast or too slow
		return false;
     562:	80 e0       	ldi	r24, 0x00	; 0
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
	return true;
}
     564:	df 91       	pop	r29
     566:	cf 91       	pop	r28
     568:	1f 91       	pop	r17
     56a:	0f 91       	pop	r16
     56c:	ff 90       	pop	r15
     56e:	ef 90       	pop	r14
     570:	df 90       	pop	r13
     572:	cf 90       	pop	r12
     574:	08 95       	ret

00000576 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     576:	e0 ea       	ldi	r30, 0xA0	; 160
     578:	f8 e0       	ldi	r31, 0x08	; 8
     57a:	91 81       	ldd	r25, Z+1	; 0x01
     57c:	95 ff       	sbrs	r25, 5
     57e:	fd cf       	rjmp	.-6      	; 0x57a <SerialWriteByte+0x4>
		//wait
	}
	//send byte
	USARTC0.DATA = byte;
     580:	80 93 a0 08 	sts	0x08A0, r24
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     584:	08 95       	ret

00000586 <SerialReadByte>:

uint8_t SerialReadByte(){
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     586:	e0 ea       	ldi	r30, 0xA0	; 160
     588:	f8 e0       	ldi	r31, 0x08	; 8
     58a:	81 81       	ldd	r24, Z+1	; 0x01
     58c:	88 23       	and	r24, r24
     58e:	ec f7       	brge	.-6      	; 0x58a <SerialReadByte+0x4>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     590:	80 91 a0 08 	lds	r24, 0x08A0
	return byte;	
}
     594:	08 95       	ret

00000596 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     596:	8f 92       	push	r8
     598:	9f 92       	push	r9
     59a:	af 92       	push	r10
     59c:	bf 92       	push	r11
     59e:	cf 92       	push	r12
     5a0:	df 92       	push	r13
     5a2:	ef 92       	push	r14
     5a4:	ff 92       	push	r15
     5a6:	cf 93       	push	r28
     5a8:	df 93       	push	r29
     5aa:	6a 01       	movw	r12, r20
     5ac:	7b 01       	movw	r14, r22
	uint32_t i;
	for(i=0;i<length;i++){
     5ae:	41 15       	cp	r20, r1
     5b0:	51 05       	cpc	r21, r1
     5b2:	61 05       	cpc	r22, r1
     5b4:	71 05       	cpc	r23, r1
     5b6:	91 f0       	breq	.+36     	; 0x5dc <SerialWriteBuffer+0x46>
     5b8:	c8 2f       	mov	r28, r24
     5ba:	d9 2f       	mov	r29, r25
     5bc:	88 24       	eor	r8, r8
     5be:	99 24       	eor	r9, r9
     5c0:	54 01       	movw	r10, r8
		SerialWriteByte(buffer[i]);
     5c2:	89 91       	ld	r24, Y+
     5c4:	0e 94 bb 02 	call	0x576	; 0x576 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     5c8:	08 94       	sec
     5ca:	81 1c       	adc	r8, r1
     5cc:	91 1c       	adc	r9, r1
     5ce:	a1 1c       	adc	r10, r1
     5d0:	b1 1c       	adc	r11, r1
     5d2:	8c 14       	cp	r8, r12
     5d4:	9d 04       	cpc	r9, r13
     5d6:	ae 04       	cpc	r10, r14
     5d8:	bf 04       	cpc	r11, r15
     5da:	99 f7       	brne	.-26     	; 0x5c2 <SerialWriteBuffer+0x2c>
		SerialWriteByte(buffer[i]);
	}
}
     5dc:	df 91       	pop	r29
     5de:	cf 91       	pop	r28
     5e0:	ff 90       	pop	r15
     5e2:	ef 90       	pop	r14
     5e4:	df 90       	pop	r13
     5e6:	cf 90       	pop	r12
     5e8:	bf 90       	pop	r11
     5ea:	af 90       	pop	r10
     5ec:	9f 90       	pop	r9
     5ee:	8f 90       	pop	r8
     5f0:	08 95       	ret

000005f2 <StopSerial>:

void StopSerial(){
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     5f2:	e0 ea       	ldi	r30, 0xA0	; 160
     5f4:	f8 e0       	ldi	r31, 0x08	; 8
     5f6:	84 81       	ldd	r24, Z+4	; 0x04
     5f8:	87 7e       	andi	r24, 0xE7	; 231
     5fa:	84 83       	std	Z+4, r24	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     5fc:	e0 e4       	ldi	r30, 0x40	; 64
     5fe:	f6 e0       	ldi	r31, 0x06	; 6
     600:	88 e0       	ldi	r24, 0x08	; 8
     602:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     604:	82 83       	std	Z+2, r24	; 0x02
     606:	08 95       	ret

00000608 <init>:
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void init(){
	ADC_POWER_ON = 0;
     608:	10 92 37 3e 	sts	0x3E37, r1
}
     60c:	08 95       	ret

0000060e <setXOSC_32MHz>:

void setXOSC_32MHz() {
	// configure the crystal to match the chip
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
     60e:	80 ec       	ldi	r24, 0xC0	; 192
     610:	60 e0       	ldi	r22, 0x00	; 0
     612:	4b e0       	ldi	r20, 0x0B	; 11
     614:	0e 94 70 20 	call	0x40e0	; 0x40e0 <CLKSYS_XOSC_Config>
	false,
	OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
     618:	e0 e5       	ldi	r30, 0x50	; 80
     61a:	f0 e0       	ldi	r31, 0x00	; 0
     61c:	80 81       	ld	r24, Z
     61e:	88 60       	ori	r24, 0x08	; 8
     620:	80 83       	st	Z, r24
	// wait for signal to stabilize
do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
     622:	81 81       	ldd	r24, Z+1	; 0x01
     624:	83 ff       	sbrs	r24, 3
     626:	fd cf       	rjmp	.-6      	; 0x622 <setXOSC_32MHz+0x14>
// configure PLL to use the crystal and turn on
CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
     628:	80 ec       	ldi	r24, 0xC0	; 192
     62a:	62 e0       	ldi	r22, 0x02	; 2
     62c:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <CLKSYS_PLL_Config>
CLKSYS_Enable( OSC_PLLEN_bm );
     630:	e0 e5       	ldi	r30, 0x50	; 80
     632:	f0 e0       	ldi	r31, 0x00	; 0
     634:	80 81       	ld	r24, Z
     636:	80 61       	ori	r24, 0x10	; 16
     638:	80 83       	st	Z, r24
// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
     63a:	81 81       	ldd	r24, Z+1	; 0x01
     63c:	84 ff       	sbrs	r24, 4
     63e:	fd cf       	rjmp	.-6      	; 0x63a <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
     640:	84 e0       	ldi	r24, 0x04	; 4
     642:	0e 94 91 20 	call	0x4122	; 0x4122 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     646:	81 e0       	ldi	r24, 0x01	; 1
     648:	0e 94 81 20 	call	0x4102	; 0x4102 <CLKSYS_Disable>
}
     64c:	08 95       	ret

0000064e <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
     64e:	e0 e5       	ldi	r30, 0x50	; 80
     650:	f0 e0       	ldi	r31, 0x00	; 0
     652:	80 81       	ld	r24, Z
     654:	82 60       	ori	r24, 0x02	; 2
     656:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
     658:	80 e0       	ldi	r24, 0x00	; 0
     65a:	61 e0       	ldi	r22, 0x01	; 1
     65c:	0e 94 8b 20 	call	0x4116	; 0x4116 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     660:	e0 e5       	ldi	r30, 0x50	; 80
     662:	f0 e0       	ldi	r31, 0x00	; 0
     664:	81 81       	ldd	r24, Z+1	; 0x01
     666:	81 ff       	sbrs	r24, 1
     668:	fd cf       	rjmp	.-6      	; 0x664 <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     66a:	81 e0       	ldi	r24, 0x01	; 1
     66c:	0e 94 91 20 	call	0x4122	; 0x4122 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     670:	81 e0       	ldi	r24, 0x01	; 1
     672:	0e 94 81 20 	call	0x4102	; 0x4102 <CLKSYS_Disable>
	
}
     676:	08 95       	ret

00000678 <set_32MHz_Calibrated>:

void set_32MHz_Calibrated() {
	
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
     678:	e0 e5       	ldi	r30, 0x50	; 80
     67a:	f0 e0       	ldi	r31, 0x00	; 0
     67c:	80 81       	ld	r24, Z
     67e:	82 60       	ori	r24, 0x02	; 2
     680:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
     682:	80 e0       	ldi	r24, 0x00	; 0
     684:	60 e0       	ldi	r22, 0x00	; 0
     686:	0e 94 8b 20 	call	0x4116	; 0x4116 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     68a:	e0 e5       	ldi	r30, 0x50	; 80
     68c:	f0 e0       	ldi	r31, 0x00	; 0
     68e:	81 81       	ldd	r24, Z+1	; 0x01
     690:	81 ff       	sbrs	r24, 1
     692:	fd cf       	rjmp	.-6      	; 0x68e <set_32MHz_Calibrated+0x16>
	// Select 32kHz crystal and low power mode
	CLKSYS_XOSC_Config( 0, true, OSC_XOSCSEL_32KHz_gc );
     694:	80 e0       	ldi	r24, 0x00	; 0
     696:	61 e0       	ldi	r22, 0x01	; 1
     698:	42 e0       	ldi	r20, 0x02	; 2
     69a:	0e 94 70 20 	call	0x40e0	; 0x40e0 <CLKSYS_XOSC_Config>
	CLKSYS_Enable( OSC_XOSCEN_bm );
     69e:	e0 e5       	ldi	r30, 0x50	; 80
     6a0:	f0 e0       	ldi	r31, 0x00	; 0
     6a2:	80 81       	ld	r24, Z
     6a4:	88 60       	ori	r24, 0x08	; 8
     6a6:	80 83       	st	Z, r24
	//wait for the 32kHz crystal to stabilize
	do {} while (CLKSYS_IsReady(OSC_XOSCRDY_bm) == 0);
     6a8:	81 81       	ldd	r24, Z+1	; 0x01
     6aa:	83 ff       	sbrs	r24, 3
     6ac:	fd cf       	rjmp	.-6      	; 0x6a8 <set_32MHz_Calibrated+0x30>
	//set the 32kHz crystal to calibrate the 32MHz RC oscillator
	CLKSYS_AutoCalibration_Enable( OSC_RC32MCREF_bm, true );
     6ae:	82 e0       	ldi	r24, 0x02	; 2
     6b0:	61 e0       	ldi	r22, 0x01	; 1
     6b2:	0e 94 ac 20 	call	0x4158	; 0x4158 <CLKSYS_AutoCalibration_Enable>
	//set the calibrated 32MHz RC oscillator as system clock
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     6b6:	81 e0       	ldi	r24, 0x01	; 1
     6b8:	0e 94 91 20 	call	0x4122	; 0x4122 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     6bc:	81 e0       	ldi	r24, 0x01	; 1
     6be:	0e 94 81 20 	call	0x4102	; 0x4102 <CLKSYS_Disable>
}
     6c2:	08 95       	ret

000006c4 <set_32MHz>:

// produces consistent but inaccurate clock period.
void set_32MHz() {
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
     6c4:	e0 e5       	ldi	r30, 0x50	; 80
     6c6:	f0 e0       	ldi	r31, 0x00	; 0
     6c8:	80 81       	ld	r24, Z
     6ca:	82 60       	ori	r24, 0x02	; 2
     6cc:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
     6ce:	80 e0       	ldi	r24, 0x00	; 0
     6d0:	60 e0       	ldi	r22, 0x00	; 0
     6d2:	0e 94 8b 20 	call	0x4116	; 0x4116 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     6d6:	e0 e5       	ldi	r30, 0x50	; 80
     6d8:	f0 e0       	ldi	r31, 0x00	; 0
     6da:	81 81       	ldd	r24, Z+1	; 0x01
     6dc:	81 ff       	sbrs	r24, 1
     6de:	fd cf       	rjmp	.-6      	; 0x6da <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     6e0:	81 e0       	ldi	r24, 0x01	; 1
     6e2:	0e 94 91 20 	call	0x4122	; 0x4122 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     6e6:	81 e0       	ldi	r24, 0x01	; 1
     6e8:	0e 94 81 20 	call	0x4102	; 0x4102 <CLKSYS_Disable>
	
}
     6ec:	08 95       	ret

000006ee <portExCS>:


void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
     6ee:	88 23       	and	r24, r24
     6f0:	29 f0       	breq	.+10     	; 0x6fc <portExCS+0xe>
     6f2:	88 e0       	ldi	r24, 0x08	; 8
     6f4:	e0 e0       	ldi	r30, 0x00	; 0
     6f6:	f6 e0       	ldi	r31, 0x06	; 6
     6f8:	86 83       	std	Z+6, r24	; 0x06
     6fa:	04 c0       	rjmp	.+8      	; 0x704 <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
     6fc:	88 e0       	ldi	r24, 0x08	; 8
     6fe:	e0 e0       	ldi	r30, 0x00	; 0
     700:	f6 e0       	ldi	r31, 0x06	; 6
     702:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     704:	8a e6       	ldi	r24, 0x6A	; 106
     706:	8a 95       	dec	r24
     708:	f1 f7       	brne	.-4      	; 0x706 <portExCS+0x18>
     70a:	00 c0       	rjmp	.+0      	; 0x70c <portExCS+0x1e>
	}
	_delay_us(10);
}
     70c:	08 95       	ret

0000070e <Ext1Power>:
	SPIDisable();
}

void Ext1Power(uint8_t on) {
	
	if (on) {
     70e:	88 23       	and	r24, r24
     710:	79 f0       	breq	.+30     	; 0x730 <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
     712:	e0 ea       	ldi	r30, 0xA0	; 160
     714:	f6 e0       	ldi	r31, 0x06	; 6
     716:	80 e2       	ldi	r24, 0x20	; 32
     718:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
     71a:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     71c:	8f ef       	ldi	r24, 0xFF	; 255
     71e:	93 ec       	ldi	r25, 0xC3	; 195
     720:	a9 e0       	ldi	r26, 0x09	; 9
     722:	81 50       	subi	r24, 0x01	; 1
     724:	90 40       	sbci	r25, 0x00	; 0
     726:	a0 40       	sbci	r26, 0x00	; 0
     728:	e1 f7       	brne	.-8      	; 0x722 <Ext1Power+0x14>
     72a:	00 c0       	rjmp	.+0      	; 0x72c <Ext1Power+0x1e>
     72c:	00 00       	nop
     72e:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
     730:	e0 ea       	ldi	r30, 0xA0	; 160
     732:	f6 e0       	ldi	r31, 0x06	; 6
     734:	80 e2       	ldi	r24, 0x20	; 32
     736:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
     738:	82 83       	std	Z+2, r24	; 0x02
     73a:	08 95       	ret

0000073c <Ext2Power>:
	}
}

void Ext2Power(uint8_t on) {
	
	if (on) {
     73c:	88 23       	and	r24, r24
     73e:	79 f0       	breq	.+30     	; 0x75e <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
     740:	e0 ea       	ldi	r30, 0xA0	; 160
     742:	f6 e0       	ldi	r31, 0x06	; 6
     744:	80 e4       	ldi	r24, 0x40	; 64
     746:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
     748:	85 83       	std	Z+5, r24	; 0x05
     74a:	8f ef       	ldi	r24, 0xFF	; 255
     74c:	93 ec       	ldi	r25, 0xC3	; 195
     74e:	a9 e0       	ldi	r26, 0x09	; 9
     750:	81 50       	subi	r24, 0x01	; 1
     752:	90 40       	sbci	r25, 0x00	; 0
     754:	a0 40       	sbci	r26, 0x00	; 0
     756:	e1 f7       	brne	.-8      	; 0x750 <Ext2Power+0x14>
     758:	00 c0       	rjmp	.+0      	; 0x75a <Ext2Power+0x1e>
     75a:	00 00       	nop
     75c:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
     75e:	e0 ea       	ldi	r30, 0xA0	; 160
     760:	f6 e0       	ldi	r31, 0x06	; 6
     762:	80 e4       	ldi	r24, 0x40	; 64
     764:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
     766:	82 83       	std	Z+2, r24	; 0x02
     768:	08 95       	ret

0000076a <HVPower>:
	}
}

void HVPower(uint8_t on) {
	
	if (on) {
     76a:	88 23       	and	r24, r24
     76c:	79 f0       	breq	.+30     	; 0x78c <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
     76e:	e0 ea       	ldi	r30, 0xA0	; 160
     770:	f6 e0       	ldi	r31, 0x06	; 6
     772:	80 e8       	ldi	r24, 0x80	; 128
     774:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
     776:	85 83       	std	Z+5, r24	; 0x05
     778:	8f ef       	ldi	r24, 0xFF	; 255
     77a:	93 ec       	ldi	r25, 0xC3	; 195
     77c:	a9 e0       	ldi	r26, 0x09	; 9
     77e:	81 50       	subi	r24, 0x01	; 1
     780:	90 40       	sbci	r25, 0x00	; 0
     782:	a0 40       	sbci	r26, 0x00	; 0
     784:	e1 f7       	brne	.-8      	; 0x77e <HVPower+0x14>
     786:	00 c0       	rjmp	.+0      	; 0x788 <HVPower+0x1e>
     788:	00 00       	nop
     78a:	05 c0       	rjmp	.+10     	; 0x796 <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
     78c:	e0 ea       	ldi	r30, 0xA0	; 160
     78e:	f6 e0       	ldi	r31, 0x06	; 6
     790:	80 e8       	ldi	r24, 0x80	; 128
     792:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
     794:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     796:	af e3       	ldi	r26, 0x3F	; 63
     798:	bf e1       	ldi	r27, 0x1F	; 31
     79a:	11 97       	sbiw	r26, 0x01	; 1
     79c:	f1 f7       	brne	.-4      	; 0x79a <HVPower+0x30>
     79e:	00 c0       	rjmp	.+0      	; 0x7a0 <HVPower+0x36>
     7a0:	00 00       	nop
	}
	_delay_us(1000);
}
     7a2:	08 95       	ret

000007a4 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
     7a4:	88 23       	and	r24, r24
     7a6:	29 f0       	breq	.+10     	; 0x7b2 <lowerMuxCS+0xe>
     7a8:	80 e1       	ldi	r24, 0x10	; 16
     7aa:	e0 e8       	ldi	r30, 0x80	; 128
     7ac:	f6 e0       	ldi	r31, 0x06	; 6
     7ae:	86 83       	std	Z+6, r24	; 0x06
     7b0:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
     7b2:	80 e1       	ldi	r24, 0x10	; 16
     7b4:	e0 e8       	ldi	r30, 0x80	; 128
     7b6:	f6 e0       	ldi	r31, 0x06	; 6
     7b8:	85 83       	std	Z+5, r24	; 0x05
     7ba:	08 95       	ret

000007bc <upperMuxCS>:
}

void upperMuxCS(uint8_t write) {
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
     7bc:	88 23       	and	r24, r24
     7be:	29 f0       	breq	.+10     	; 0x7ca <upperMuxCS+0xe>
     7c0:	82 e0       	ldi	r24, 0x02	; 2
     7c2:	e0 e4       	ldi	r30, 0x40	; 64
     7c4:	f6 e0       	ldi	r31, 0x06	; 6
     7c6:	86 83       	std	Z+6, r24	; 0x06
     7c8:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
     7ca:	82 e0       	ldi	r24, 0x02	; 2
     7cc:	e0 e4       	ldi	r30, 0x40	; 64
     7ce:	f6 e0       	ldi	r31, 0x06	; 6
     7d0:	85 83       	std	Z+5, r24	; 0x05
     7d2:	08 95       	ret

000007d4 <SPIInit>:
}

void SPIInit(uint8_t mode) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     7d4:	e0 e4       	ldi	r30, 0x40	; 64
     7d6:	f6 e0       	ldi	r31, 0x06	; 6
     7d8:	90 e1       	ldi	r25, 0x10	; 16
     7da:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     7dc:	28 e3       	ldi	r18, 0x38	; 56
     7de:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     7e0:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
     7e2:	81 65       	ori	r24, 0x51	; 81
     7e4:	a0 ec       	ldi	r26, 0xC0	; 192
     7e6:	b8 e0       	ldi	r27, 0x08	; 8
     7e8:	8c 93       	st	X, r24
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     7ea:	11 96       	adiw	r26, 0x01	; 1
     7ec:	1c 92       	st	X, r1
     7ee:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     7f0:	80 ea       	ldi	r24, 0xA0	; 160
     7f2:	81 83       	std	Z+1, r24	; 0x01

	
}
     7f4:	08 95       	ret

000007f6 <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     7f6:	e0 e4       	ldi	r30, 0x40	; 64
     7f8:	f6 e0       	ldi	r31, 0x06	; 6
     7fa:	90 e1       	ldi	r25, 0x10	; 16
     7fc:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     7fe:	28 e3       	ldi	r18, 0x38	; 56
     800:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     802:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
     804:	80 65       	ori	r24, 0x50	; 80
     806:	68 2b       	or	r22, r24
     808:	a0 ec       	ldi	r26, 0xC0	; 192
     80a:	b8 e0       	ldi	r27, 0x08	; 8
     80c:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     80e:	11 96       	adiw	r26, 0x01	; 1
     810:	1c 92       	st	X, r1
     812:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     814:	80 ea       	ldi	r24, 0xA0	; 160
     816:	81 83       	std	Z+1, r24	; 0x01
}
     818:	08 95       	ret

0000081a <SPICS>:

void SPICS(uint8_t enable) {
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
     81a:	88 23       	and	r24, r24
     81c:	29 f0       	breq	.+10     	; 0x828 <SPICS+0xe>
     81e:	80 e1       	ldi	r24, 0x10	; 16
     820:	e0 e4       	ldi	r30, 0x40	; 64
     822:	f6 e0       	ldi	r31, 0x06	; 6
     824:	86 83       	std	Z+6, r24	; 0x06
     826:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
     828:	80 e1       	ldi	r24, 0x10	; 16
     82a:	e0 e4       	ldi	r30, 0x40	; 64
     82c:	f6 e0       	ldi	r31, 0x06	; 6
     82e:	85 83       	std	Z+5, r24	; 0x05
     830:	08 95       	ret

00000832 <SPIDisable>:
	}
}

void SPIDisable() {
	
	PORTC.OUTSET = PIN4_bm;
     832:	e0 e4       	ldi	r30, 0x40	; 64
     834:	f6 e0       	ldi	r31, 0x06	; 6
     836:	80 e1       	ldi	r24, 0x10	; 16
     838:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
     83a:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
     83e:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
     840:	80 eb       	ldi	r24, 0xB0	; 176
     842:	82 83       	std	Z+2, r24	; 0x02

}
     844:	08 95       	ret

00000846 <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     846:	cf 93       	push	r28
     848:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     84a:	c8 2f       	mov	r28, r24
     84c:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
     84e:	d8 2f       	mov	r29, r24
     850:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     852:	28 2f       	mov	r18, r24
     854:	30 e0       	ldi	r19, 0x00	; 0
     856:	a9 01       	movw	r20, r18
     858:	45 70       	andi	r20, 0x05	; 5
     85a:	50 70       	andi	r21, 0x00	; 0
     85c:	41 15       	cp	r20, r1
     85e:	51 05       	cpc	r21, r1
     860:	49 f0       	breq	.+18     	; 0x874 <set_filter+0x2e>
     862:	90 91 35 3e 	lds	r25, 0x3E35
     866:	48 2f       	mov	r20, r24
     868:	42 95       	swap	r20
     86a:	4f 70       	andi	r20, 0x0F	; 15
     86c:	90 7f       	andi	r25, 0xF0	; 240
     86e:	94 2b       	or	r25, r20
     870:	90 93 35 3e 	sts	0x3E35, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     874:	2a 70       	andi	r18, 0x0A	; 10
     876:	30 70       	andi	r19, 0x00	; 0
     878:	21 15       	cp	r18, r1
     87a:	31 05       	cpc	r19, r1
     87c:	39 f0       	breq	.+14     	; 0x88c <set_filter+0x46>
     87e:	90 91 35 3e 	lds	r25, 0x3E35
     882:	80 7f       	andi	r24, 0xF0	; 240
     884:	9f 70       	andi	r25, 0x0F	; 15
     886:	89 2b       	or	r24, r25
     888:	80 93 35 3e 	sts	0x3E35, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     88c:	84 e0       	ldi	r24, 0x04	; 4
     88e:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     892:	80 91 35 3e 	lds	r24, 0x3E35
     896:	80 93 25 3e 	sts	0x3E25, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     89a:	cc 23       	and	r28, r28
     89c:	19 f0       	breq	.+6      	; 0x8a4 <set_filter+0x5e>
     89e:	81 e0       	ldi	r24, 0x01	; 1
     8a0:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     8a4:	dd 23       	and	r29, r29
     8a6:	19 f0       	breq	.+6      	; 0x8ae <set_filter+0x68>
     8a8:	81 e0       	ldi	r24, 0x01	; 1
     8aa:	0e 94 de 03 	call	0x7bc	; 0x7bc <upperMuxCS>

	SPICS(TRUE);
     8ae:	81 e0       	ldi	r24, 0x01	; 1
     8b0:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     8b4:	8f ef       	ldi	r24, 0xFF	; 255
     8b6:	e0 ec       	ldi	r30, 0xC0	; 192
     8b8:	f8 e0       	ldi	r31, 0x08	; 8
     8ba:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     8bc:	82 81       	ldd	r24, Z+2	; 0x02
     8be:	88 23       	and	r24, r24
     8c0:	ec f7       	brge	.-6      	; 0x8bc <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
     8c2:	e0 ec       	ldi	r30, 0xC0	; 192
     8c4:	f8 e0       	ldi	r31, 0x08	; 8
     8c6:	83 81       	ldd	r24, Z+3	; 0x03
     8c8:	80 93 31 3e 	sts	0x3E31, r24

	nop();
     8cc:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     8ce:	a1 e3       	ldi	r26, 0x31	; 49
     8d0:	be e3       	ldi	r27, 0x3E	; 62
     8d2:	1c 97       	sbiw	r26, 0x0c	; 12
     8d4:	8c 91       	ld	r24, X
     8d6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     8d8:	82 81       	ldd	r24, Z+2	; 0x02
     8da:	88 23       	and	r24, r24
     8dc:	ec f7       	brge	.-6      	; 0x8d8 <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     8de:	e0 ec       	ldi	r30, 0xC0	; 192
     8e0:	f8 e0       	ldi	r31, 0x08	; 8
     8e2:	83 81       	ldd	r24, Z+3	; 0x03
     8e4:	80 93 31 3e 	sts	0x3E31, r24
	SPICS(FALSE);
     8e8:	80 e0       	ldi	r24, 0x00	; 0
     8ea:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     8ee:	cc 23       	and	r28, r28
     8f0:	19 f0       	breq	.+6      	; 0x8f8 <set_filter+0xb2>
     8f2:	80 e0       	ldi	r24, 0x00	; 0
     8f4:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     8f8:	dd 23       	and	r29, r29
     8fa:	19 f0       	breq	.+6      	; 0x902 <set_filter+0xbc>
     8fc:	80 e0       	ldi	r24, 0x00	; 0
     8fe:	0e 94 de 03 	call	0x7bc	; 0x7bc <upperMuxCS>
	SPIDisable();
     902:	0e 94 19 04 	call	0x832	; 0x832 <SPIDisable>
}
     906:	df 91       	pop	r29
     908:	cf 91       	pop	r28
     90a:	08 95       	ret

0000090c <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     90c:	cf 93       	push	r28
     90e:	df 93       	push	r29
     910:	c8 2f       	mov	r28, r24
     912:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     914:	80 e0       	ldi	r24, 0x00	; 0
     916:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPIInit>
	SPICS(TRUE);
     91a:	81 e0       	ldi	r24, 0x01	; 1
     91c:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	portExCS(TRUE);
     920:	81 e0       	ldi	r24, 0x01	; 1
     922:	0e 94 77 03 	call	0x6ee	; 0x6ee <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
     926:	dd 23       	and	r29, r29
     928:	89 f0       	breq	.+34     	; 0x94c <PortEx_OUTCLR+0x40>
     92a:	80 91 b0 21 	lds	r24, 0x21B0
     92e:	c0 95       	com	r28
     930:	c8 23       	and	r28, r24
     932:	c0 93 b0 21 	sts	0x21B0, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
     936:	80 e4       	ldi	r24, 0x40	; 64
     938:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     93c:	84 e1       	ldi	r24, 0x14	; 20
     93e:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = bankA_OUT;
     942:	80 91 b0 21 	lds	r24, 0x21B0
     946:	80 93 27 3e 	sts	0x3E27, r24
     94a:	10 c0       	rjmp	.+32     	; 0x96c <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
     94c:	80 91 36 3e 	lds	r24, 0x3E36
     950:	c0 95       	com	r28
     952:	c8 23       	and	r28, r24
     954:	c0 93 36 3e 	sts	0x3E36, r28
	
	SPIBuffer[0] = PS_WRITE;
     958:	80 e4       	ldi	r24, 0x40	; 64
     95a:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     95e:	85 e1       	ldi	r24, 0x15	; 21
     960:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = bankB_OUT; 
     964:	80 91 36 3e 	lds	r24, 0x3E36
     968:	80 93 27 3e 	sts	0x3E27, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     96c:	80 e0       	ldi	r24, 0x00	; 0
     96e:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     970:	25 e2       	ldi	r18, 0x25	; 37
     972:	3e e3       	ldi	r19, 0x3E	; 62
     974:	a0 ec       	ldi	r26, 0xC0	; 192
     976:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     978:	c1 e3       	ldi	r28, 0x31	; 49
     97a:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     97c:	f9 01       	movw	r30, r18
     97e:	e8 0f       	add	r30, r24
     980:	f9 1f       	adc	r31, r25
     982:	40 81       	ld	r20, Z
     984:	13 96       	adiw	r26, 0x03	; 3
     986:	4c 93       	st	X, r20
     988:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     98a:	12 96       	adiw	r26, 0x02	; 2
     98c:	4c 91       	ld	r20, X
     98e:	12 97       	sbiw	r26, 0x02	; 2
     990:	44 23       	and	r20, r20
     992:	dc f7       	brge	.-10     	; 0x98a <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
     994:	13 96       	adiw	r26, 0x03	; 3
     996:	4c 91       	ld	r20, X
     998:	13 97       	sbiw	r26, 0x03	; 3
     99a:	48 83       	st	Y, r20
     99c:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     99e:	83 30       	cpi	r24, 0x03	; 3
     9a0:	91 05       	cpc	r25, r1
     9a2:	61 f7       	brne	.-40     	; 0x97c <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     9a4:	80 e0       	ldi	r24, 0x00	; 0
     9a6:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	portExCS(FALSE);
     9aa:	80 e0       	ldi	r24, 0x00	; 0
     9ac:	0e 94 77 03 	call	0x6ee	; 0x6ee <portExCS>
	SPIDisable();
     9b0:	0e 94 19 04 	call	0x832	; 0x832 <SPIDisable>
}
     9b4:	df 91       	pop	r29
     9b6:	cf 91       	pop	r28
     9b8:	08 95       	ret

000009ba <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     9ba:	cf 93       	push	r28
     9bc:	df 93       	push	r29
     9be:	c8 2f       	mov	r28, r24
     9c0:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     9c2:	80 e0       	ldi	r24, 0x00	; 0
     9c4:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPIInit>
	SPICS(TRUE);
     9c8:	81 e0       	ldi	r24, 0x01	; 1
     9ca:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	portExCS(TRUE);
     9ce:	81 e0       	ldi	r24, 0x01	; 1
     9d0:	0e 94 77 03 	call	0x6ee	; 0x6ee <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
     9d4:	dd 23       	and	r29, r29
     9d6:	81 f0       	breq	.+32     	; 0x9f8 <PortEx_OUTSET+0x3e>
     9d8:	80 91 b0 21 	lds	r24, 0x21B0
     9dc:	c8 2b       	or	r28, r24
     9de:	c0 93 b0 21 	sts	0x21B0, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
     9e2:	80 e4       	ldi	r24, 0x40	; 64
     9e4:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     9e8:	84 e1       	ldi	r24, 0x14	; 20
     9ea:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = bankA_OUT;
     9ee:	80 91 b0 21 	lds	r24, 0x21B0
     9f2:	80 93 27 3e 	sts	0x3E27, r24
     9f6:	0f c0       	rjmp	.+30     	; 0xa16 <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
     9f8:	80 91 36 3e 	lds	r24, 0x3E36
     9fc:	c8 2b       	or	r28, r24
     9fe:	c0 93 36 3e 	sts	0x3E36, r28
	
	SPIBuffer[0] = PS_WRITE;
     a02:	80 e4       	ldi	r24, 0x40	; 64
     a04:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     a08:	85 e1       	ldi	r24, 0x15	; 21
     a0a:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = bankB_OUT; 
     a0e:	80 91 36 3e 	lds	r24, 0x3E36
     a12:	80 93 27 3e 	sts	0x3E27, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     a16:	80 e0       	ldi	r24, 0x00	; 0
     a18:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     a1a:	25 e2       	ldi	r18, 0x25	; 37
     a1c:	3e e3       	ldi	r19, 0x3E	; 62
     a1e:	a0 ec       	ldi	r26, 0xC0	; 192
     a20:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     a22:	c1 e3       	ldi	r28, 0x31	; 49
     a24:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     a26:	f9 01       	movw	r30, r18
     a28:	e8 0f       	add	r30, r24
     a2a:	f9 1f       	adc	r31, r25
     a2c:	40 81       	ld	r20, Z
     a2e:	13 96       	adiw	r26, 0x03	; 3
     a30:	4c 93       	st	X, r20
     a32:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     a34:	12 96       	adiw	r26, 0x02	; 2
     a36:	4c 91       	ld	r20, X
     a38:	12 97       	sbiw	r26, 0x02	; 2
     a3a:	44 23       	and	r20, r20
     a3c:	dc f7       	brge	.-10     	; 0xa34 <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
     a3e:	13 96       	adiw	r26, 0x03	; 3
     a40:	4c 91       	ld	r20, X
     a42:	13 97       	sbiw	r26, 0x03	; 3
     a44:	48 83       	st	Y, r20
     a46:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     a48:	83 30       	cpi	r24, 0x03	; 3
     a4a:	91 05       	cpc	r25, r1
     a4c:	61 f7       	brne	.-40     	; 0xa26 <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     a4e:	80 e0       	ldi	r24, 0x00	; 0
     a50:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	portExCS(FALSE);
     a54:	80 e0       	ldi	r24, 0x00	; 0
     a56:	0e 94 77 03 	call	0x6ee	; 0x6ee <portExCS>
	SPIDisable();
     a5a:	0e 94 19 04 	call	0x832	; 0x832 <SPIDisable>
}
     a5e:	df 91       	pop	r29
     a60:	cf 91       	pop	r28
     a62:	08 95       	ret

00000a64 <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     a64:	cf 93       	push	r28
     a66:	df 93       	push	r29
     a68:	c8 2f       	mov	r28, r24
     a6a:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     a6c:	80 e0       	ldi	r24, 0x00	; 0
     a6e:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPIInit>
	SPICS(TRUE);
     a72:	81 e0       	ldi	r24, 0x01	; 1
     a74:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	portExCS(TRUE);
     a78:	81 e0       	ldi	r24, 0x01	; 1
     a7a:	0e 94 77 03 	call	0x6ee	; 0x6ee <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
     a7e:	dd 23       	and	r29, r29
     a80:	89 f0       	breq	.+34     	; 0xaa4 <PortEx_DIRCLR+0x40>
     a82:	80 91 34 3e 	lds	r24, 0x3E34
     a86:	80 95       	com	r24
     a88:	c8 23       	and	r28, r24
     a8a:	c0 93 34 3e 	sts	0x3E34, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     a8e:	80 e4       	ldi	r24, 0x40	; 64
     a90:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     a94:	10 92 26 3e 	sts	0x3E26, r1
		SPIBuffer[2] = ~bankA_DIR; 
     a98:	80 91 34 3e 	lds	r24, 0x3E34
     a9c:	80 95       	com	r24
     a9e:	80 93 27 3e 	sts	0x3E27, r24
     aa2:	11 c0       	rjmp	.+34     	; 0xac6 <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
     aa4:	80 91 4b 3e 	lds	r24, 0x3E4B
     aa8:	80 95       	com	r24
     aaa:	c8 23       	and	r28, r24
     aac:	c0 93 4b 3e 	sts	0x3E4B, r28
	
	SPIBuffer[0] = PS_WRITE;
     ab0:	80 e4       	ldi	r24, 0x40	; 64
     ab2:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     ab6:	81 e0       	ldi	r24, 0x01	; 1
     ab8:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = ~bankB_DIR;
     abc:	80 91 4b 3e 	lds	r24, 0x3E4B
     ac0:	80 95       	com	r24
     ac2:	80 93 27 3e 	sts	0x3E27, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     ac6:	80 e0       	ldi	r24, 0x00	; 0
     ac8:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     aca:	25 e2       	ldi	r18, 0x25	; 37
     acc:	3e e3       	ldi	r19, 0x3E	; 62
     ace:	a0 ec       	ldi	r26, 0xC0	; 192
     ad0:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     ad2:	c1 e3       	ldi	r28, 0x31	; 49
     ad4:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     ad6:	f9 01       	movw	r30, r18
     ad8:	e8 0f       	add	r30, r24
     ada:	f9 1f       	adc	r31, r25
     adc:	40 81       	ld	r20, Z
     ade:	13 96       	adiw	r26, 0x03	; 3
     ae0:	4c 93       	st	X, r20
     ae2:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     ae4:	12 96       	adiw	r26, 0x02	; 2
     ae6:	4c 91       	ld	r20, X
     ae8:	12 97       	sbiw	r26, 0x02	; 2
     aea:	44 23       	and	r20, r20
     aec:	dc f7       	brge	.-10     	; 0xae4 <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
     aee:	13 96       	adiw	r26, 0x03	; 3
     af0:	4c 91       	ld	r20, X
     af2:	13 97       	sbiw	r26, 0x03	; 3
     af4:	48 83       	st	Y, r20
     af6:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     af8:	83 30       	cpi	r24, 0x03	; 3
     afa:	91 05       	cpc	r25, r1
     afc:	61 f7       	brne	.-40     	; 0xad6 <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	portExCS(FALSE);
     b04:	80 e0       	ldi	r24, 0x00	; 0
     b06:	0e 94 77 03 	call	0x6ee	; 0x6ee <portExCS>
	SPIDisable();
     b0a:	0e 94 19 04 	call	0x832	; 0x832 <SPIDisable>
}
     b0e:	df 91       	pop	r29
     b10:	cf 91       	pop	r28
     b12:	08 95       	ret

00000b14 <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     b14:	cf 93       	push	r28
     b16:	df 93       	push	r29
     b18:	c8 2f       	mov	r28, r24
     b1a:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
     b1c:	80 e0       	ldi	r24, 0x00	; 0
     b1e:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPIInit>
	SPICS(TRUE);
     b22:	81 e0       	ldi	r24, 0x01	; 1
     b24:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	portExCS(TRUE);
     b28:	81 e0       	ldi	r24, 0x01	; 1
     b2a:	0e 94 77 03 	call	0x6ee	; 0x6ee <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
     b2e:	dd 23       	and	r29, r29
     b30:	81 f0       	breq	.+32     	; 0xb52 <PortEx_DIRSET+0x3e>
     b32:	80 91 34 3e 	lds	r24, 0x3E34
     b36:	c8 2b       	or	r28, r24
     b38:	c0 93 34 3e 	sts	0x3E34, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     b3c:	80 e4       	ldi	r24, 0x40	; 64
     b3e:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     b42:	10 92 26 3e 	sts	0x3E26, r1
		SPIBuffer[2] = ~bankA_DIR; 
     b46:	80 91 34 3e 	lds	r24, 0x3E34
     b4a:	80 95       	com	r24
     b4c:	80 93 27 3e 	sts	0x3E27, r24
     b50:	10 c0       	rjmp	.+32     	; 0xb72 <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
     b52:	80 91 4b 3e 	lds	r24, 0x3E4B
     b56:	c8 2b       	or	r28, r24
     b58:	c0 93 4b 3e 	sts	0x3E4B, r28
	
	SPIBuffer[0] = PS_WRITE;
     b5c:	80 e4       	ldi	r24, 0x40	; 64
     b5e:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     b62:	81 e0       	ldi	r24, 0x01	; 1
     b64:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = ~bankB_DIR;
     b68:	80 91 4b 3e 	lds	r24, 0x3E4B
     b6c:	80 95       	com	r24
     b6e:	80 93 27 3e 	sts	0x3E27, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     b72:	80 e0       	ldi	r24, 0x00	; 0
     b74:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     b76:	25 e2       	ldi	r18, 0x25	; 37
     b78:	3e e3       	ldi	r19, 0x3E	; 62
     b7a:	a0 ec       	ldi	r26, 0xC0	; 192
     b7c:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     b7e:	c1 e3       	ldi	r28, 0x31	; 49
     b80:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     b82:	f9 01       	movw	r30, r18
     b84:	e8 0f       	add	r30, r24
     b86:	f9 1f       	adc	r31, r25
     b88:	40 81       	ld	r20, Z
     b8a:	13 96       	adiw	r26, 0x03	; 3
     b8c:	4c 93       	st	X, r20
     b8e:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
     b90:	12 96       	adiw	r26, 0x02	; 2
     b92:	4c 91       	ld	r20, X
     b94:	12 97       	sbiw	r26, 0x02	; 2
     b96:	44 23       	and	r20, r20
     b98:	dc f7       	brge	.-10     	; 0xb90 <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     b9a:	13 96       	adiw	r26, 0x03	; 3
     b9c:	4c 91       	ld	r20, X
     b9e:	13 97       	sbiw	r26, 0x03	; 3
     ba0:	48 83       	st	Y, r20
     ba2:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     ba4:	83 30       	cpi	r24, 0x03	; 3
     ba6:	91 05       	cpc	r25, r1
     ba8:	61 f7       	brne	.-40     	; 0xb82 <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
     baa:	80 e0       	ldi	r24, 0x00	; 0
     bac:	0e 94 77 03 	call	0x6ee	; 0x6ee <portExCS>
	SPICS(FALSE);
     bb0:	80 e0       	ldi	r24, 0x00	; 0
     bb2:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	SPIDisable();
     bb6:	0e 94 19 04 	call	0x832	; 0x832 <SPIDisable>


}
     bba:	df 91       	pop	r29
     bbc:	cf 91       	pop	r28
     bbe:	08 95       	ret

00000bc0 <ADCPower>:
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
	else PORTC.OUTSET = PIN1_bm;
}

void ADCPower(uint8_t on) {
     bc0:	0f 93       	push	r16
     bc2:	1f 93       	push	r17
     bc4:	cf 93       	push	r28
     bc6:	df 93       	push	r29
	
	if (on && !ADC_POWER_ON) {
     bc8:	88 23       	and	r24, r24
     bca:	09 f4       	brne	.+2      	; 0xbce <ADCPower+0xe>
     bcc:	4e c0       	rjmp	.+156    	; 0xc6a <ADCPower+0xaa>
     bce:	80 91 37 3e 	lds	r24, 0x3E37
     bd2:	88 23       	and	r24, r24
     bd4:	09 f0       	breq	.+2      	; 0xbd8 <ADCPower+0x18>
     bd6:	81 c0       	rjmp	.+258    	; 0xcda <ADCPower+0x11a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     bd8:	00 e0       	ldi	r16, 0x00	; 0
     bda:	16 e0       	ldi	r17, 0x06	; 6
     bdc:	8e ed       	ldi	r24, 0xDE	; 222
     bde:	d8 01       	movw	r26, r16
     be0:	11 96       	adiw	r26, 0x01	; 1
     be2:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     be4:	c0 e2       	ldi	r28, 0x20	; 32
     be6:	d6 e0       	ldi	r29, 0x06	; 6
     be8:	4e e0       	ldi	r20, 0x0E	; 14
     bea:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     bec:	e0 e4       	ldi	r30, 0x40	; 64
     bee:	f6 e0       	ldi	r31, 0x06	; 6
     bf0:	63 e0       	ldi	r22, 0x03	; 3
     bf2:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     bf4:	80 e8       	ldi	r24, 0x80	; 128
     bf6:	96 e0       	ldi	r25, 0x06	; 6
     bf8:	50 e1       	ldi	r21, 0x10	; 16
     bfa:	dc 01       	movw	r26, r24
     bfc:	11 96       	adiw	r26, 0x01	; 1
     bfe:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     c00:	20 ea       	ldi	r18, 0xA0	; 160
     c02:	36 e0       	ldi	r19, 0x06	; 6
     c04:	d9 01       	movw	r26, r18
     c06:	11 96       	adiw	r26, 0x01	; 1
     c08:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm; // portEx-CS
     c0a:	7e e9       	ldi	r23, 0x9E	; 158
     c0c:	d8 01       	movw	r26, r16
     c0e:	15 96       	adiw	r26, 0x05	; 5
     c10:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     c12:	78 e0       	ldi	r23, 0x08	; 8
     c14:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     c16:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     c18:	ec 01       	movw	r28, r24
     c1a:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     c1c:	d9 01       	movw	r26, r18
     c1e:	15 96       	adiw	r26, 0x05	; 5
     c20:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
     c22:	10 92 35 3e 	sts	0x3E35, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     c26:	8f ef       	ldi	r24, 0xFF	; 255
     c28:	93 ec       	ldi	r25, 0xC3	; 195
     c2a:	a9 e0       	ldi	r26, 0x09	; 9
     c2c:	81 50       	subi	r24, 0x01	; 1
     c2e:	90 40       	sbci	r25, 0x00	; 0
     c30:	a0 40       	sbci	r26, 0x00	; 0
     c32:	e1 f7       	brne	.-8      	; 0xc2c <ADCPower+0x6c>
     c34:	00 c0       	rjmp	.+0      	; 0xc36 <ADCPower+0x76>
     c36:	00 00       	nop
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     c38:	80 e4       	ldi	r24, 0x40	; 64
     c3a:	82 83       	std	Z+2, r24	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     c3c:	10 92 36 3e 	sts	0x3E36, r1
     c40:	10 92 4b 3e 	sts	0x3E4B, r1
     c44:	10 92 b0 21 	sts	0x21B0, r1
     c48:	10 92 34 3e 	sts	0x3E34, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
     c4c:	8f ef       	ldi	r24, 0xFF	; 255
     c4e:	61 e0       	ldi	r22, 0x01	; 1
     c50:	0e 94 8a 05 	call	0xb14	; 0xb14 <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     c54:	8f ef       	ldi	r24, 0xFF	; 255
     c56:	61 e0       	ldi	r22, 0x01	; 1
     c58:	0e 94 dd 04 	call	0x9ba	; 0x9ba <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     c5c:	8f ef       	ldi	r24, 0xFF	; 255
     c5e:	0e 94 23 04 	call	0x846	; 0x846 <set_filter>
		ADC_POWER_ON = TRUE;
     c62:	81 e0       	ldi	r24, 0x01	; 1
     c64:	80 93 37 3e 	sts	0x3E37, r24
     c68:	38 c0       	rjmp	.+112    	; 0xcda <ADCPower+0x11a>

	} else if(!on && ADC_POWER_ON) {
     c6a:	80 91 37 3e 	lds	r24, 0x3E37
     c6e:	88 23       	and	r24, r24
     c70:	a1 f1       	breq	.+104    	; 0xcda <ADCPower+0x11a>
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     c72:	00 e0       	ldi	r16, 0x00	; 0
     c74:	16 e0       	ldi	r17, 0x06	; 6
     c76:	7e ed       	ldi	r23, 0xDE	; 222
     c78:	d8 01       	movw	r26, r16
     c7a:	16 96       	adiw	r26, 0x06	; 6
     c7c:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     c7e:	a0 e2       	ldi	r26, 0x20	; 32
     c80:	b6 e0       	ldi	r27, 0x06	; 6
     c82:	4e e0       	ldi	r20, 0x0E	; 14
     c84:	16 96       	adiw	r26, 0x06	; 6
     c86:	4c 93       	st	X, r20
     c88:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     c8a:	20 e4       	ldi	r18, 0x40	; 64
     c8c:	36 e0       	ldi	r19, 0x06	; 6
     c8e:	63 e0       	ldi	r22, 0x03	; 3
     c90:	e9 01       	movw	r28, r18
     c92:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     c94:	c0 e8       	ldi	r28, 0x80	; 128
     c96:	d6 e0       	ldi	r29, 0x06	; 6
     c98:	50 e1       	ldi	r21, 0x10	; 16
     c9a:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     c9c:	80 ea       	ldi	r24, 0xA0	; 160
     c9e:	96 e0       	ldi	r25, 0x06	; 6
     ca0:	fc 01       	movw	r30, r24
     ca2:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     ca4:	f8 01       	movw	r30, r16
     ca6:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     ca8:	12 96       	adiw	r26, 0x02	; 2
     caa:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     cac:	d9 01       	movw	r26, r18
     cae:	12 96       	adiw	r26, 0x02	; 2
     cb0:	6c 93       	st	X, r22
     cb2:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
     cb4:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     cb6:	ec 01       	movw	r28, r24
     cb8:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     cba:	80 e4       	ldi	r24, 0x40	; 64
     cbc:	12 96       	adiw	r26, 0x02	; 2
     cbe:	8c 93       	st	X, r24
     cc0:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     cc2:	10 92 36 3e 	sts	0x3E36, r1
     cc6:	10 92 4b 3e 	sts	0x3E4B, r1
     cca:	10 92 b0 21 	sts	0x21B0, r1
     cce:	10 92 34 3e 	sts	0x3E34, r1
		channelStatus = 0x00;
     cd2:	10 92 35 3e 	sts	0x3E35, r1
		ADC_POWER_ON = FALSE;
     cd6:	10 92 37 3e 	sts	0x3E37, r1
	}
}
     cda:	df 91       	pop	r29
     cdc:	cf 91       	pop	r28
     cde:	1f 91       	pop	r17
     ce0:	0f 91       	pop	r16
     ce2:	08 95       	ret

00000ce4 <DeciToString>:
	PORTC.OUTCLR = PIN4_bm;
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;

}

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
     ce4:	2f 92       	push	r2
     ce6:	3f 92       	push	r3
     ce8:	4f 92       	push	r4
     cea:	5f 92       	push	r5
     cec:	6f 92       	push	r6
     cee:	7f 92       	push	r7
     cf0:	8f 92       	push	r8
     cf2:	9f 92       	push	r9
     cf4:	af 92       	push	r10
     cf6:	bf 92       	push	r11
     cf8:	cf 92       	push	r12
     cfa:	df 92       	push	r13
     cfc:	ef 92       	push	r14
     cfe:	ff 92       	push	r15
     d00:	0f 93       	push	r16
     d02:	1f 93       	push	r17
     d04:	cf 93       	push	r28
     d06:	df 93       	push	r29
     d08:	cd b7       	in	r28, 0x3d	; 61
     d0a:	de b7       	in	r29, 0x3e	; 62
     d0c:	64 97       	sbiw	r28, 0x14	; 20
     d0e:	cd bf       	out	0x3d, r28	; 61
     d10:	de bf       	out	0x3e, r29	; 62
     d12:	2a 01       	movw	r4, r20
     d14:	3b 01       	movw	r6, r22
     d16:	89 01       	movw	r16, r18
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
     d18:	f9 01       	movw	r30, r18
     d1a:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
     d1c:	41 15       	cp	r20, r1
     d1e:	51 05       	cpc	r21, r1
     d20:	61 05       	cpc	r22, r1
     d22:	71 05       	cpc	r23, r1
     d24:	09 f4       	brne	.+2      	; 0xd28 <DeciToString+0x44>
     d26:	4d c0       	rjmp	.+154    	; 0xdc2 <DeciToString+0xde>
     d28:	88 2e       	mov	r8, r24
     d2a:	99 2e       	mov	r9, r25
     d2c:	cc 24       	eor	r12, r12
     d2e:	dd 24       	eor	r13, r13
     d30:	76 01       	movw	r14, r12
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
     d32:	5e 01       	movw	r10, r28
     d34:	08 94       	sec
     d36:	a1 1c       	adc	r10, r1
     d38:	b1 1c       	adc	r11, r1
     d3a:	0f 2e       	mov	r0, r31
     d3c:	f0 e0       	ldi	r31, 0x00	; 0
     d3e:	2f 2e       	mov	r2, r31
     d40:	f0 e2       	ldi	r31, 0x20	; 32
     d42:	3f 2e       	mov	r3, r31
     d44:	f0 2d       	mov	r31, r0
     d46:	f4 01       	movw	r30, r8
     d48:	81 91       	ld	r24, Z+
     d4a:	91 91       	ld	r25, Z+
     d4c:	a1 91       	ld	r26, Z+
     d4e:	b1 91       	ld	r27, Z+
     d50:	4f 01       	movw	r8, r30
     d52:	2d b7       	in	r18, 0x3d	; 61
     d54:	3e b7       	in	r19, 0x3e	; 62
     d56:	28 50       	subi	r18, 0x08	; 8
     d58:	30 40       	sbci	r19, 0x00	; 0
     d5a:	2d bf       	out	0x3d, r18	; 61
     d5c:	3e bf       	out	0x3e, r19	; 62
     d5e:	2f 5f       	subi	r18, 0xFF	; 255
     d60:	3f 4f       	sbci	r19, 0xFF	; 255
     d62:	ed b7       	in	r30, 0x3d	; 61
     d64:	fe b7       	in	r31, 0x3e	; 62
     d66:	a1 82       	std	Z+1, r10	; 0x01
     d68:	b2 82       	std	Z+2, r11	; 0x02
     d6a:	f9 01       	movw	r30, r18
     d6c:	22 82       	std	Z+2, r2	; 0x02
     d6e:	33 82       	std	Z+3, r3	; 0x03
     d70:	84 83       	std	Z+4, r24	; 0x04
     d72:	95 83       	std	Z+5, r25	; 0x05
     d74:	a6 83       	std	Z+6, r26	; 0x06
     d76:	b7 83       	std	Z+7, r27	; 0x07
     d78:	0e 94 8d 3a 	call	0x751a	; 0x751a <sprintf>
		strcat(ReturnString,b);
     d7c:	2d b7       	in	r18, 0x3d	; 61
     d7e:	3e b7       	in	r19, 0x3e	; 62
     d80:	28 5f       	subi	r18, 0xF8	; 248
     d82:	3f 4f       	sbci	r19, 0xFF	; 255
     d84:	2d bf       	out	0x3d, r18	; 61
     d86:	3e bf       	out	0x3e, r19	; 62
     d88:	c8 01       	movw	r24, r16
     d8a:	b5 01       	movw	r22, r10
     d8c:	0e 94 4f 3a 	call	0x749e	; 0x749e <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
     d90:	a0 2f       	mov	r26, r16
     d92:	b1 2f       	mov	r27, r17
     d94:	fd 01       	movw	r30, r26
     d96:	01 90       	ld	r0, Z+
     d98:	00 20       	and	r0, r0
     d9a:	e9 f7       	brne	.-6      	; 0xd96 <DeciToString+0xb2>
     d9c:	31 97       	sbiw	r30, 0x01	; 1
     d9e:	ea 1b       	sub	r30, r26
     da0:	fb 0b       	sbc	r31, r27
     da2:	e0 0f       	add	r30, r16
     da4:	f1 1f       	adc	r31, r17
     da6:	8a e0       	ldi	r24, 0x0A	; 10
     da8:	90 e0       	ldi	r25, 0x00	; 0
     daa:	80 83       	st	Z, r24
     dac:	91 83       	std	Z+1, r25	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
     dae:	08 94       	sec
     db0:	c1 1c       	adc	r12, r1
     db2:	d1 1c       	adc	r13, r1
     db4:	e1 1c       	adc	r14, r1
     db6:	f1 1c       	adc	r15, r1
     db8:	c4 14       	cp	r12, r4
     dba:	d5 04       	cpc	r13, r5
     dbc:	e6 04       	cpc	r14, r6
     dbe:	f7 04       	cpc	r15, r7
     dc0:	11 f6       	brne	.-124    	; 0xd46 <DeciToString+0x62>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}
}
     dc2:	64 96       	adiw	r28, 0x14	; 20
     dc4:	cd bf       	out	0x3d, r28	; 61
     dc6:	de bf       	out	0x3e, r29	; 62
     dc8:	df 91       	pop	r29
     dca:	cf 91       	pop	r28
     dcc:	1f 91       	pop	r17
     dce:	0f 91       	pop	r16
     dd0:	ff 90       	pop	r15
     dd2:	ef 90       	pop	r14
     dd4:	df 90       	pop	r13
     dd6:	cf 90       	pop	r12
     dd8:	bf 90       	pop	r11
     dda:	af 90       	pop	r10
     ddc:	9f 90       	pop	r9
     dde:	8f 90       	pop	r8
     de0:	7f 90       	pop	r7
     de2:	6f 90       	pop	r6
     de4:	5f 90       	pop	r5
     de6:	4f 90       	pop	r4
     de8:	3f 90       	pop	r3
     dea:	2f 90       	pop	r2
     dec:	08 95       	ret

00000dee <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
     dee:	e0 ec       	ldi	r30, 0xC0	; 192
     df0:	f8 e0       	ldi	r31, 0x08	; 8
     df2:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
     df4:	82 81       	ldd	r24, Z+2	; 0x02
     df6:	88 23       	and	r24, r24
     df8:	ec f7       	brge	.-6      	; 0xdf4 <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
     dfa:	e0 ec       	ldi	r30, 0xC0	; 192
     dfc:	f8 e0       	ldi	r31, 0x08	; 8
     dfe:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
     e00:	08 95       	ret

00000e02 <main>:

#include "E-000001-000009_firmware_rev_1_0.h"

volatile uint8_t TimedOut = 0;

int main(){
     e02:	cf 93       	push	r28
     e04:	df 93       	push	r29
     e06:	cd b7       	in	r28, 0x3d	; 61
     e08:	de b7       	in	r29, 0x3e	; 62
     e0a:	6d 97       	sbiw	r28, 0x1d	; 29
     e0c:	cd bf       	out	0x3d, r28	; 61
     e0e:	de bf       	out	0x3e, r29	; 62
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t ack = 0;
     e10:	19 82       	std	Y+1, r1	; 0x01
     e12:	1a 82       	std	Y+2, r1	; 0x02
	volatile uint8_t RawGain;
	uint16_t freq = 2000;
	volatile uint32_t samples = 0;
     e14:	1c 82       	std	Y+4, r1	; 0x04
     e16:	1d 82       	std	Y+5, r1	; 0x05
     e18:	1e 82       	std	Y+6, r1	; 0x06
     e1a:	1f 82       	std	Y+7, r1	; 0x07
	DataAvailable = 0;
     e1c:	10 92 4c 3e 	sts	0x3E4C, r1
	ADC_Sampling_Finished = 1;
     e20:	11 e0       	ldi	r17, 0x01	; 1
     e22:	10 93 ab 50 	sts	0x50AB, r17
	uint8_t RadioMessageBuffer[20];
	unsigned char ofile[] = {'o','u','t','p','u','t'};
	set_32MHz_Calibrated();
     e26:	0e 94 3c 03 	call	0x678	; 0x678 <set_32MHz_Calibrated>
	chb_init();
     e2a:	0e 94 57 1a 	call	0x34ae	; 0x34ae <chb_init>
	chb_set_channel(1);
     e2e:	81 e0       	ldi	r24, 0x01	; 1
     e30:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <chb_set_channel>
	chb_set_short_addr(0x0001);
     e34:	81 e0       	ldi	r24, 0x01	; 1
     e36:	90 e0       	ldi	r25, 0x00	; 0
     e38:	0e 94 90 1c 	call	0x3920	; 0x3920 <chb_set_short_addr>
	chb_set_pwr(0);
     e3c:	80 e0       	ldi	r24, 0x00	; 0
     e3e:	0e 94 57 1c 	call	0x38ae	; 0x38ae <chb_set_pwr>
	pcb_t* pcb = chb_get_pcb();
     e42:	0e 94 78 1a 	call	0x34f0	; 0x34f0 <chb_get_pcb>
     e46:	3c 01       	movw	r6, r24
	//SD_init();
	//getBootSectorData();
	
	//setup timeout timer
	//approx 2 seconds to wait (using largest prescaler of 1024)
	TCE0.PER = 4000;
     e48:	e0 e0       	ldi	r30, 0x00	; 0
     e4a:	fa e0       	ldi	r31, 0x0A	; 10
     e4c:	80 ea       	ldi	r24, 0xA0	; 160
     e4e:	9f e0       	ldi	r25, 0x0F	; 15
     e50:	86 a3       	lds	r24, 0x56
     e52:	97 a3       	lds	r25, 0x57
	TCE0.CTRLFSET = 0x08;
     e54:	88 e0       	ldi	r24, 0x08	; 8
     e56:	81 87       	std	Z+9, r24	; 0x09
	TCE0.INTCTRLA = TC_OVFINTLVL_LO_gc;
     e58:	16 83       	std	Z+6, r17	; 0x06
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
     e5a:	e0 ea       	ldi	r30, 0xA0	; 160
     e5c:	f0 e0       	ldi	r31, 0x00	; 0
     e5e:	82 81       	ldd	r24, Z+2	; 0x02
     e60:	81 60       	ori	r24, 0x01	; 1
     e62:	82 83       	std	Z+2, r24	; 0x02
	sei();
     e64:	78 94       	sei
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t ack = 0;
	volatile uint8_t RawGain;
	uint16_t freq = 2000;
     e66:	0f 2e       	mov	r0, r31
     e68:	f0 ed       	ldi	r31, 0xD0	; 208
     e6a:	2f 2e       	mov	r2, r31
     e6c:	f7 e0       	ldi	r31, 0x07	; 7
     e6e:	3f 2e       	mov	r3, r31
     e70:	f0 2d       	mov	r31, r0
volatile uint8_t TimedOut = 0;

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
     e72:	44 24       	eor	r4, r4
									while(chb_write(0x0000,FRAMReadBuffer,100) != CHB_SUCCESS);
									i += 100;
								}
								else{
									readFRAM(samples*4 - i,(FRAMAddress-(samples*4))+i);
									while(chb_write(0x0000,FRAMReadBuffer,samples*4 - i) != CHB_SUCCESS);
     e74:	81 eb       	ldi	r24, 0xB1	; 177
     e76:	91 e2       	ldi	r25, 0x21	; 33
     e78:	18 2f       	mov	r17, r24
     e7a:	59 2e       	mov	r5, r25
	TCE0.INTCTRLA = TC_OVFINTLVL_LO_gc;
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
	sei();

	while(1){
		if(pcb->data_rcv){
     e7c:	d3 01       	movw	r26, r6
     e7e:	17 96       	adiw	r26, 0x07	; 7
     e80:	8c 91       	ld	r24, X
     e82:	17 97       	sbiw	r26, 0x07	; 7
     e84:	88 23       	and	r24, r24
     e86:	d1 f3       	breq	.-12     	; 0xe7c <main+0x7a>
			//read the data
			length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
     e88:	ce 01       	movw	r24, r28
     e8a:	08 96       	adiw	r24, 0x08	; 8
     e8c:	0e 94 29 1b 	call	0x3652	; 0x3652 <chb_read>
			//length should be >1 for setting gain/freq commands: the value is likely sent in a separate message
			//process received message if it is from the base station (node id 0)
			if(pcb->sender_addr == 0x0000){
     e90:	f3 01       	movw	r30, r6
     e92:	82 81       	ldd	r24, Z+2	; 0x02
     e94:	93 81       	ldd	r25, Z+3	; 0x03
     e96:	00 97       	sbiw	r24, 0x00	; 0
     e98:	89 f7       	brne	.-30     	; 0xe7c <main+0x7a>
				switch ( RadioMessageBuffer[0]){
     e9a:	88 85       	ldd	r24, Y+8	; 0x08
     e9c:	82 35       	cpi	r24, 0x52	; 82
     e9e:	71 f0       	breq	.+28     	; 0xebc <main+0xba>
     ea0:	83 35       	cpi	r24, 0x53	; 83
     ea2:	30 f4       	brcc	.+12     	; 0xeb0 <main+0xae>
     ea4:	86 34       	cpi	r24, 0x46	; 70
     ea6:	09 f4       	brne	.+2      	; 0xeaa <main+0xa8>
     ea8:	a7 c0       	rjmp	.+334    	; 0xff8 <main+0x1f6>
     eaa:	87 34       	cpi	r24, 0x47	; 71
     eac:	39 f7       	brne	.-50     	; 0xe7c <main+0x7a>
     eae:	54 c0       	rjmp	.+168    	; 0xf58 <main+0x156>
     eb0:	83 35       	cpi	r24, 0x53	; 83
     eb2:	09 f4       	brne	.+2      	; 0xeb6 <main+0xb4>
     eb4:	b7 c0       	rjmp	.+366    	; 0x1024 <main+0x222>
     eb6:	84 35       	cpi	r24, 0x54	; 84
     eb8:	09 f7       	brne	.-62     	; 0xe7c <main+0x7a>
     eba:	d0 c0       	rjmp	.+416    	; 0x105c <main+0x25a>
					
				case 'R':
					//collect data if the ADC is not collecting any data right now
					if(ADC_Sampling_Finished){
     ebc:	80 91 ab 50 	lds	r24, 0x50AB
     ec0:	88 23       	and	r24, r24
     ec2:	b1 f1       	breq	.+108    	; 0xf30 <main+0x12e>
						//CO_collectADC(ADC_CH_1_gc, gain, freq, 10000, (int32_t*)FRAMReadBuffer, FR_READ_BUFFER_SIZE/4, TRUE);
						CO_collectSeismic1Channel(ADC_CH_8_gc, gain, freq, 6, FALSE, 1, 2, 3, 4, 10000,(int32_t*)FRAMReadBuffer, FR_READ_BUFFER_SIZE/4, TRUE);
     ec4:	8d b7       	in	r24, 0x3d	; 61
     ec6:	9e b7       	in	r25, 0x3e	; 62
     ec8:	07 97       	sbiw	r24, 0x07	; 7
     eca:	8d bf       	out	0x3d, r24	; 61
     ecc:	9e bf       	out	0x3e, r25	; 62
     ece:	ed b7       	in	r30, 0x3d	; 61
     ed0:	fe b7       	in	r31, 0x3e	; 62
     ed2:	31 96       	adiw	r30, 0x01	; 1
     ed4:	80 e1       	ldi	r24, 0x10	; 16
     ed6:	97 e2       	ldi	r25, 0x27	; 39
     ed8:	ad b7       	in	r26, 0x3d	; 61
     eda:	be b7       	in	r27, 0x3e	; 62
     edc:	11 96       	adiw	r26, 0x01	; 1
     ede:	8d 93       	st	X+, r24
     ee0:	9c 93       	st	X, r25
     ee2:	12 97       	sbiw	r26, 0x02	; 2
     ee4:	a1 eb       	ldi	r26, 0xB1	; 177
     ee6:	b1 e2       	ldi	r27, 0x21	; 33
     ee8:	a2 83       	std	Z+2, r26	; 0x02
     eea:	b3 83       	std	Z+3, r27	; 0x03
     eec:	8c e1       	ldi	r24, 0x1C	; 28
     eee:	97 e0       	ldi	r25, 0x07	; 7
     ef0:	84 83       	std	Z+4, r24	; 0x04
     ef2:	95 83       	std	Z+5, r25	; 0x05
     ef4:	81 e0       	ldi	r24, 0x01	; 1
     ef6:	86 83       	std	Z+6, r24	; 0x06
     ef8:	87 e0       	ldi	r24, 0x07	; 7
     efa:	64 2d       	mov	r22, r4
     efc:	a1 01       	movw	r20, r2
     efe:	26 e0       	ldi	r18, 0x06	; 6
     f00:	00 e0       	ldi	r16, 0x00	; 0
     f02:	ee 24       	eor	r14, r14
     f04:	ff 24       	eor	r15, r15
     f06:	e3 94       	inc	r14
     f08:	cc 24       	eor	r12, r12
     f0a:	dd 24       	eor	r13, r13
     f0c:	68 94       	set
     f0e:	c1 f8       	bld	r12, 1
     f10:	0f 2e       	mov	r0, r31
     f12:	f3 e0       	ldi	r31, 0x03	; 3
     f14:	af 2e       	mov	r10, r31
     f16:	bb 24       	eor	r11, r11
     f18:	f0 2d       	mov	r31, r0
     f1a:	88 24       	eor	r8, r8
     f1c:	99 24       	eor	r9, r9
     f1e:	68 94       	set
     f20:	82 f8       	bld	r8, 2
     f22:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <CO_collectSeismic1Channel>
     f26:	ad b7       	in	r26, 0x3d	; 61
     f28:	be b7       	in	r27, 0x3e	; 62
     f2a:	17 96       	adiw	r26, 0x07	; 7
     f2c:	ad bf       	out	0x3d, r26	; 61
     f2e:	be bf       	out	0x3e, r27	; 62
					}
					//send acknowledgment if not a broadcast message
					if(pcb->destination_addr != 0xFFFF){
     f30:	f3 01       	movw	r30, r6
     f32:	84 81       	ldd	r24, Z+4	; 0x04
     f34:	95 81       	ldd	r25, Z+5	; 0x05
     f36:	ff ef       	ldi	r31, 0xFF	; 255
     f38:	8f 3f       	cpi	r24, 0xFF	; 255
     f3a:	9f 07       	cpc	r25, r31
     f3c:	09 f4       	brne	.+2      	; 0xf40 <main+0x13e>
     f3e:	9e cf       	rjmp	.-196    	; 0xe7c <main+0x7a>
						chb_write(0x0000,(uint8_t*)(&ack),2);
     f40:	80 e0       	ldi	r24, 0x00	; 0
     f42:	90 e0       	ldi	r25, 0x00	; 0
     f44:	be 01       	movw	r22, r28
     f46:	6f 5f       	subi	r22, 0xFF	; 255
     f48:	7f 4f       	sbci	r23, 0xFF	; 255
     f4a:	22 e0       	ldi	r18, 0x02	; 2
     f4c:	30 e0       	ldi	r19, 0x00	; 0
     f4e:	40 e0       	ldi	r20, 0x00	; 0
     f50:	50 e0       	ldi	r21, 0x00	; 0
     f52:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <chb_write>
     f56:	92 cf       	rjmp	.-220    	; 0xe7c <main+0x7a>
					
				case 'G':
					//while(!pcb->data_rcv);
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set gain to what is specified
					RawGain = (uint8_t)(*(int32_t*)(RadioMessageBuffer+1));
     f58:	89 85       	ldd	r24, Y+9	; 0x09
     f5a:	8b 83       	std	Y+3, r24	; 0x03
					switch(RawGain){
     f5c:	8b 81       	ldd	r24, Y+3	; 0x03
     f5e:	88 30       	cpi	r24, 0x08	; 8
     f60:	e1 f0       	breq	.+56     	; 0xf9a <main+0x198>
     f62:	89 30       	cpi	r24, 0x09	; 9
     f64:	38 f4       	brcc	.+14     	; 0xf74 <main+0x172>
     f66:	82 30       	cpi	r24, 0x02	; 2
     f68:	89 f0       	breq	.+34     	; 0xf8c <main+0x18a>
     f6a:	84 30       	cpi	r24, 0x04	; 4
     f6c:	91 f0       	breq	.+36     	; 0xf92 <main+0x190>
     f6e:	81 30       	cpi	r24, 0x01	; 1
     f70:	69 f5       	brne	.+90     	; 0xfcc <main+0x1ca>
     f72:	2b c0       	rjmp	.+86     	; 0xfca <main+0x1c8>
     f74:	80 32       	cpi	r24, 0x20	; 32
     f76:	d1 f0       	breq	.+52     	; 0xfac <main+0x1aa>
     f78:	81 32       	cpi	r24, 0x21	; 33
     f7a:	18 f4       	brcc	.+6      	; 0xf82 <main+0x180>
     f7c:	80 31       	cpi	r24, 0x10	; 16
     f7e:	31 f5       	brne	.+76     	; 0xfcc <main+0x1ca>
     f80:	11 c0       	rjmp	.+34     	; 0xfa4 <main+0x1a2>
     f82:	80 34       	cpi	r24, 0x40	; 64
     f84:	c1 f0       	breq	.+48     	; 0xfb6 <main+0x1b4>
     f86:	80 38       	cpi	r24, 0x80	; 128
     f88:	09 f5       	brne	.+66     	; 0xfcc <main+0x1ca>
     f8a:	1a c0       	rjmp	.+52     	; 0xfc0 <main+0x1be>
						case 1:
							gain = GAIN_1_gc;
							break;
						case 2:
							gain = GAIN_2_gc;
     f8c:	44 24       	eor	r4, r4
     f8e:	43 94       	inc	r4
							break;
     f90:	1d c0       	rjmp	.+58     	; 0xfcc <main+0x1ca>
						case 4:
							gain = GAIN_4_gc;
     f92:	44 24       	eor	r4, r4
     f94:	68 94       	set
     f96:	41 f8       	bld	r4, 1
							break;
     f98:	19 c0       	rjmp	.+50     	; 0xfcc <main+0x1ca>
						case 8:
							gain = GAIN_8_gc;
     f9a:	0f 2e       	mov	r0, r31
     f9c:	f3 e0       	ldi	r31, 0x03	; 3
     f9e:	4f 2e       	mov	r4, r31
     fa0:	f0 2d       	mov	r31, r0
							break;
     fa2:	14 c0       	rjmp	.+40     	; 0xfcc <main+0x1ca>
						case 16:
							gain = GAIN_16_gc;
     fa4:	44 24       	eor	r4, r4
     fa6:	68 94       	set
     fa8:	42 f8       	bld	r4, 2
							break;
     faa:	10 c0       	rjmp	.+32     	; 0xfcc <main+0x1ca>
						case 32:
							gain = GAIN_32_gc;
     fac:	0f 2e       	mov	r0, r31
     fae:	f5 e0       	ldi	r31, 0x05	; 5
     fb0:	4f 2e       	mov	r4, r31
     fb2:	f0 2d       	mov	r31, r0
							break;
     fb4:	0b c0       	rjmp	.+22     	; 0xfcc <main+0x1ca>
						case 64:
							gain = GAIN_64_gc;
     fb6:	0f 2e       	mov	r0, r31
     fb8:	f6 e0       	ldi	r31, 0x06	; 6
     fba:	4f 2e       	mov	r4, r31
     fbc:	f0 2d       	mov	r31, r0
							break;
     fbe:	06 c0       	rjmp	.+12     	; 0xfcc <main+0x1ca>
						case 128:
							gain = GAIN_128_gc;
     fc0:	0f 2e       	mov	r0, r31
     fc2:	f7 e0       	ldi	r31, 0x07	; 7
     fc4:	4f 2e       	mov	r4, r31
     fc6:	f0 2d       	mov	r31, r0
							break;
     fc8:	01 c0       	rjmp	.+2      	; 0xfcc <main+0x1ca>
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set gain to what is specified
					RawGain = (uint8_t)(*(int32_t*)(RadioMessageBuffer+1));
					switch(RawGain){
						case 1:
							gain = GAIN_1_gc;
     fca:	44 24       	eor	r4, r4
						default:
							//chb_write(0x0000,(uint8_t*)"invalid gain",strlen("invalid gain"));
							break;
					}
					//send acknowledgment if not a broadcast message
					if(pcb->destination_addr != 0xFFFF){
     fcc:	d3 01       	movw	r26, r6
     fce:	14 96       	adiw	r26, 0x04	; 4
     fd0:	8d 91       	ld	r24, X+
     fd2:	9c 91       	ld	r25, X
     fd4:	15 97       	sbiw	r26, 0x05	; 5
     fd6:	bf ef       	ldi	r27, 0xFF	; 255
     fd8:	8f 3f       	cpi	r24, 0xFF	; 255
     fda:	9b 07       	cpc	r25, r27
     fdc:	09 f4       	brne	.+2      	; 0xfe0 <main+0x1de>
     fde:	4e cf       	rjmp	.-356    	; 0xe7c <main+0x7a>
						chb_write(0x0000,(uint8_t*)(&ack),2);
     fe0:	80 e0       	ldi	r24, 0x00	; 0
     fe2:	90 e0       	ldi	r25, 0x00	; 0
     fe4:	be 01       	movw	r22, r28
     fe6:	6f 5f       	subi	r22, 0xFF	; 255
     fe8:	7f 4f       	sbci	r23, 0xFF	; 255
     fea:	22 e0       	ldi	r18, 0x02	; 2
     fec:	30 e0       	ldi	r19, 0x00	; 0
     fee:	40 e0       	ldi	r20, 0x00	; 0
     ff0:	50 e0       	ldi	r21, 0x00	; 0
     ff2:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <chb_write>
     ff6:	42 cf       	rjmp	.-380    	; 0xe7c <main+0x7a>
				case 'F':

					//while(!pcb->data_rcv);
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set sampling frequency to what is specified
					freq = (uint16_t)(*(int32_t*)(RadioMessageBuffer+1));
     ff8:	29 84       	ldd	r2, Y+9	; 0x09
     ffa:	3a 84       	ldd	r3, Y+10	; 0x0a
					//send acknowledgment if not a broadcast message
					if(pcb->destination_addr != 0xFFFF){
     ffc:	f3 01       	movw	r30, r6
     ffe:	84 81       	ldd	r24, Z+4	; 0x04
    1000:	95 81       	ldd	r25, Z+5	; 0x05
    1002:	ff ef       	ldi	r31, 0xFF	; 255
    1004:	8f 3f       	cpi	r24, 0xFF	; 255
    1006:	9f 07       	cpc	r25, r31
    1008:	09 f4       	brne	.+2      	; 0x100c <main+0x20a>
    100a:	38 cf       	rjmp	.-400    	; 0xe7c <main+0x7a>
						chb_write(0x0000,(uint8_t*)(&ack),2);
    100c:	80 e0       	ldi	r24, 0x00	; 0
    100e:	90 e0       	ldi	r25, 0x00	; 0
    1010:	be 01       	movw	r22, r28
    1012:	6f 5f       	subi	r22, 0xFF	; 255
    1014:	7f 4f       	sbci	r23, 0xFF	; 255
    1016:	22 e0       	ldi	r18, 0x02	; 2
    1018:	30 e0       	ldi	r19, 0x00	; 0
    101a:	40 e0       	ldi	r20, 0x00	; 0
    101c:	50 e0       	ldi	r21, 0x00	; 0
    101e:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <chb_write>
    1022:	2c cf       	rjmp	.-424    	; 0xe7c <main+0x7a>
					}
					break;
					
				case 'S':
					//stop the ADC if it is not already
					if(!ADC_Sampling_Finished){
    1024:	80 91 ab 50 	lds	r24, 0x50AB
    1028:	88 23       	and	r24, r24
    102a:	11 f4       	brne	.+4      	; 0x1030 <main+0x22e>
						ADC_Stop_Sampling();
    102c:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <ADC_Stop_Sampling>
					}
					//otherwise, the ADC has finished sampling on its own and the data is ready to be transmitted
					//send acknowledgment if not a broadcast message
					if(pcb->destination_addr != 0xFFFF){
    1030:	d3 01       	movw	r26, r6
    1032:	14 96       	adiw	r26, 0x04	; 4
    1034:	8d 91       	ld	r24, X+
    1036:	9c 91       	ld	r25, X
    1038:	15 97       	sbiw	r26, 0x05	; 5
    103a:	bf ef       	ldi	r27, 0xFF	; 255
    103c:	8f 3f       	cpi	r24, 0xFF	; 255
    103e:	9b 07       	cpc	r25, r27
    1040:	09 f4       	brne	.+2      	; 0x1044 <main+0x242>
    1042:	1c cf       	rjmp	.-456    	; 0xe7c <main+0x7a>
						chb_write(0x0000,(uint8_t*)(&ack),2);
    1044:	80 e0       	ldi	r24, 0x00	; 0
    1046:	90 e0       	ldi	r25, 0x00	; 0
    1048:	be 01       	movw	r22, r28
    104a:	6f 5f       	subi	r22, 0xFF	; 255
    104c:	7f 4f       	sbci	r23, 0xFF	; 255
    104e:	22 e0       	ldi	r18, 0x02	; 2
    1050:	30 e0       	ldi	r19, 0x00	; 0
    1052:	40 e0       	ldi	r20, 0x00	; 0
    1054:	50 e0       	ldi	r21, 0x00	; 0
    1056:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <chb_write>
    105a:	10 cf       	rjmp	.-480    	; 0xe7c <main+0x7a>
					}
					break;
					
				case 'T':
					if(ADC_Sampling_Finished && DataAvailable && pcb->destination_addr != 0xFFFF){
    105c:	80 91 ab 50 	lds	r24, 0x50AB
    1060:	88 23       	and	r24, r24
    1062:	09 f4       	brne	.+2      	; 0x1066 <main+0x264>
    1064:	0b cf       	rjmp	.-490    	; 0xe7c <main+0x7a>
    1066:	80 91 4c 3e 	lds	r24, 0x3E4C
    106a:	88 23       	and	r24, r24
    106c:	09 f4       	brne	.+2      	; 0x1070 <main+0x26e>
    106e:	06 cf       	rjmp	.-500    	; 0xe7c <main+0x7a>
    1070:	f3 01       	movw	r30, r6
    1072:	84 81       	ldd	r24, Z+4	; 0x04
    1074:	95 81       	ldd	r25, Z+5	; 0x05
    1076:	ff ef       	ldi	r31, 0xFF	; 255
    1078:	8f 3f       	cpi	r24, 0xFF	; 255
    107a:	9f 07       	cpc	r25, r31
    107c:	09 f4       	brne	.+2      	; 0x1080 <main+0x27e>
    107e:	fe ce       	rjmp	.-516    	; 0xe7c <main+0x7a>
						//get number of data points collected
						samples = ADC_Get_Num_Samples();
    1080:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <ADC_Get_Num_Samples>
    1084:	a0 e0       	ldi	r26, 0x00	; 0
    1086:	b0 e0       	ldi	r27, 0x00	; 0
    1088:	8c 83       	std	Y+4, r24	; 0x04
    108a:	9d 83       	std	Y+5, r25	; 0x05
    108c:	ae 83       	std	Y+6, r26	; 0x06
    108e:	bf 83       	std	Y+7, r27	; 0x07
						if(samples > 0){	
    1090:	8c 81       	ldd	r24, Y+4	; 0x04
    1092:	9d 81       	ldd	r25, Y+5	; 0x05
    1094:	ae 81       	ldd	r26, Y+6	; 0x06
    1096:	bf 81       	ldd	r27, Y+7	; 0x07
    1098:	00 97       	sbiw	r24, 0x00	; 0
    109a:	a1 05       	cpc	r26, r1
    109c:	b1 05       	cpc	r27, r1
    109e:	09 f4       	brne	.+2      	; 0x10a2 <main+0x2a0>
    10a0:	21 c1       	rjmp	.+578    	; 0x12e4 <main+0x4e2>
							uint16_t NumMessages = ((samples*4)/CHB_MAX_PAYLOAD);
    10a2:	8c 81       	ldd	r24, Y+4	; 0x04
    10a4:	9d 81       	ldd	r25, Y+5	; 0x05
    10a6:	ae 81       	ldd	r26, Y+6	; 0x06
    10a8:	bf 81       	ldd	r27, Y+7	; 0x07
    10aa:	bc 01       	movw	r22, r24
    10ac:	cd 01       	movw	r24, r26
    10ae:	66 0f       	add	r22, r22
    10b0:	77 1f       	adc	r23, r23
    10b2:	88 1f       	adc	r24, r24
    10b4:	99 1f       	adc	r25, r25
    10b6:	66 0f       	add	r22, r22
    10b8:	77 1f       	adc	r23, r23
    10ba:	88 1f       	adc	r24, r24
    10bc:	99 1f       	adc	r25, r25
    10be:	0f 2e       	mov	r0, r31
    10c0:	f4 e6       	ldi	r31, 0x64	; 100
    10c2:	cf 2e       	mov	r12, r31
    10c4:	f0 e0       	ldi	r31, 0x00	; 0
    10c6:	df 2e       	mov	r13, r31
    10c8:	f0 e0       	ldi	r31, 0x00	; 0
    10ca:	ef 2e       	mov	r14, r31
    10cc:	f0 e0       	ldi	r31, 0x00	; 0
    10ce:	ff 2e       	mov	r15, r31
    10d0:	f0 2d       	mov	r31, r0
    10d2:	a7 01       	movw	r20, r14
    10d4:	96 01       	movw	r18, r12
    10d6:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    10da:	59 01       	movw	r10, r18
    10dc:	2c 8f       	std	Y+28, r18	; 0x1c
    10de:	3d 8f       	std	Y+29, r19	; 0x1d
							if ((samples*4)%CHB_MAX_PAYLOAD > 0) NumMessages++;
    10e0:	8c 81       	ldd	r24, Y+4	; 0x04
    10e2:	9d 81       	ldd	r25, Y+5	; 0x05
    10e4:	ae 81       	ldd	r26, Y+6	; 0x06
    10e6:	bf 81       	ldd	r27, Y+7	; 0x07
    10e8:	bc 01       	movw	r22, r24
    10ea:	cd 01       	movw	r24, r26
    10ec:	66 0f       	add	r22, r22
    10ee:	77 1f       	adc	r23, r23
    10f0:	88 1f       	adc	r24, r24
    10f2:	99 1f       	adc	r25, r25
    10f4:	66 0f       	add	r22, r22
    10f6:	77 1f       	adc	r23, r23
    10f8:	88 1f       	adc	r24, r24
    10fa:	99 1f       	adc	r25, r25
    10fc:	a7 01       	movw	r20, r14
    10fe:	96 01       	movw	r18, r12
    1100:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    1104:	dc 01       	movw	r26, r24
    1106:	cb 01       	movw	r24, r22
    1108:	00 97       	sbiw	r24, 0x00	; 0
    110a:	a1 05       	cpc	r26, r1
    110c:	b1 05       	cpc	r27, r1
    110e:	21 f0       	breq	.+8      	; 0x1118 <main+0x316>
    1110:	c5 01       	movw	r24, r10
    1112:	01 96       	adiw	r24, 0x01	; 1
    1114:	8c 8f       	std	Y+28, r24	; 0x1c
    1116:	9d 8f       	std	Y+29, r25	; 0x1d
							//start timeout timer
							TCE0.CTRLA = 0x07;
    1118:	87 e0       	ldi	r24, 0x07	; 7
    111a:	a0 e0       	ldi	r26, 0x00	; 0
    111c:	ba e0       	ldi	r27, 0x0A	; 10
    111e:	8c 93       	st	X, r24
							TimedOut = 0;
    1120:	10 92 0e 21 	sts	0x210E, r1
							//send the number of messages the base station should expect after this message
							while(chb_write(0x0000,(uint8_t*)(&NumMessages),2) != CHB_SUCCESS){
    1124:	04 c0       	rjmp	.+8      	; 0x112e <main+0x32c>
								if(TimedOut) break;
    1126:	80 91 0e 21 	lds	r24, 0x210E
    112a:	88 23       	and	r24, r24
    112c:	69 f4       	brne	.+26     	; 0x1148 <main+0x346>
							if ((samples*4)%CHB_MAX_PAYLOAD > 0) NumMessages++;
							//start timeout timer
							TCE0.CTRLA = 0x07;
							TimedOut = 0;
							//send the number of messages the base station should expect after this message
							while(chb_write(0x0000,(uint8_t*)(&NumMessages),2) != CHB_SUCCESS){
    112e:	80 e0       	ldi	r24, 0x00	; 0
    1130:	90 e0       	ldi	r25, 0x00	; 0
    1132:	be 01       	movw	r22, r28
    1134:	64 5e       	subi	r22, 0xE4	; 228
    1136:	7f 4f       	sbci	r23, 0xFF	; 255
    1138:	22 e0       	ldi	r18, 0x02	; 2
    113a:	30 e0       	ldi	r19, 0x00	; 0
    113c:	40 e0       	ldi	r20, 0x00	; 0
    113e:	50 e0       	ldi	r21, 0x00	; 0
    1140:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <chb_write>
    1144:	88 23       	and	r24, r24
    1146:	79 f7       	brne	.-34     	; 0x1126 <main+0x324>
								if(TimedOut) break;
							}
							if(TimedOut){
    1148:	80 91 0e 21 	lds	r24, 0x210E
    114c:	88 23       	and	r24, r24
    114e:	31 f0       	breq	.+12     	; 0x115c <main+0x35a>
								//stop timeout counter and go back to waiting for command
								TimedOut = 0;
    1150:	10 92 0e 21 	sts	0x210E, r1
								TCE0.CTRLA = 0;
    1154:	e0 e0       	ldi	r30, 0x00	; 0
    1156:	fa e0       	ldi	r31, 0x0A	; 10
    1158:	10 82       	st	Z, r1
								break;
    115a:	90 ce       	rjmp	.-736    	; 0xe7c <main+0x7a>
							}
							//reset timeout timer
							TimedOut = 0;
    115c:	10 92 0e 21 	sts	0x210E, r1
							TCE0.CTRLFSET = 0x08;  
    1160:	f8 e0       	ldi	r31, 0x08	; 8
    1162:	f0 93 09 0a 	sts	0x0A09, r31
							//read the data from FRAM and send it
							for(uint16_t i =0; i<(samples*4);){	
    1166:	8c 81       	ldd	r24, Y+4	; 0x04
    1168:	9d 81       	ldd	r25, Y+5	; 0x05
    116a:	ae 81       	ldd	r26, Y+6	; 0x06
    116c:	bf 81       	ldd	r27, Y+7	; 0x07
    116e:	88 0f       	add	r24, r24
    1170:	99 1f       	adc	r25, r25
    1172:	aa 1f       	adc	r26, r26
    1174:	bb 1f       	adc	r27, r27
    1176:	88 0f       	add	r24, r24
    1178:	99 1f       	adc	r25, r25
    117a:	aa 1f       	adc	r26, r26
    117c:	bb 1f       	adc	r27, r27
    117e:	00 97       	sbiw	r24, 0x00	; 0
    1180:	a1 05       	cpc	r26, r1
    1182:	b1 05       	cpc	r27, r1
    1184:	09 f4       	brne	.+2      	; 0x1188 <main+0x386>
    1186:	ae c0       	rjmp	.+348    	; 0x12e4 <main+0x4e2>
    1188:	cc 24       	eor	r12, r12
    118a:	dd 24       	eor	r13, r13
    118c:	76 01       	movw	r14, r12
    118e:	aa 24       	eor	r10, r10
    1190:	bb 24       	eor	r11, r11
								if(samples*4 - i >= 100){
    1192:	8c 81       	ldd	r24, Y+4	; 0x04
    1194:	9d 81       	ldd	r25, Y+5	; 0x05
    1196:	ae 81       	ldd	r26, Y+6	; 0x06
    1198:	bf 81       	ldd	r27, Y+7	; 0x07
    119a:	88 0f       	add	r24, r24
    119c:	99 1f       	adc	r25, r25
    119e:	aa 1f       	adc	r26, r26
    11a0:	bb 1f       	adc	r27, r27
    11a2:	88 0f       	add	r24, r24
    11a4:	99 1f       	adc	r25, r25
    11a6:	aa 1f       	adc	r26, r26
    11a8:	bb 1f       	adc	r27, r27
    11aa:	8c 19       	sub	r24, r12
    11ac:	9d 09       	sbc	r25, r13
    11ae:	ae 09       	sbc	r26, r14
    11b0:	bf 09       	sbc	r27, r15
    11b2:	84 36       	cpi	r24, 0x64	; 100
    11b4:	91 05       	cpc	r25, r1
    11b6:	a1 05       	cpc	r26, r1
    11b8:	b1 05       	cpc	r27, r1
    11ba:	28 f1       	brcs	.+74     	; 0x1206 <main+0x404>
									readFRAM(100,(FRAMAddress-(samples*4))+i);						
    11bc:	60 91 22 3e 	lds	r22, 0x3E22
    11c0:	70 91 23 3e 	lds	r23, 0x3E23
    11c4:	8c 81       	ldd	r24, Y+4	; 0x04
    11c6:	9d 81       	ldd	r25, Y+5	; 0x05
    11c8:	ae 81       	ldd	r26, Y+6	; 0x06
    11ca:	bf 81       	ldd	r27, Y+7	; 0x07
    11cc:	88 0f       	add	r24, r24
    11ce:	99 1f       	adc	r25, r25
    11d0:	88 0f       	add	r24, r24
    11d2:	99 1f       	adc	r25, r25
    11d4:	68 1b       	sub	r22, r24
    11d6:	79 0b       	sbc	r23, r25
    11d8:	6a 0d       	add	r22, r10
    11da:	7b 1d       	adc	r23, r11
    11dc:	84 e6       	ldi	r24, 0x64	; 100
    11de:	90 e0       	ldi	r25, 0x00	; 0
    11e0:	0e 94 cd 01 	call	0x39a	; 0x39a <readFRAM>
									while(chb_write(0x0000,FRAMReadBuffer,100) != CHB_SUCCESS);
    11e4:	80 e0       	ldi	r24, 0x00	; 0
    11e6:	90 e0       	ldi	r25, 0x00	; 0
    11e8:	61 2f       	mov	r22, r17
    11ea:	75 2d       	mov	r23, r5
    11ec:	24 e6       	ldi	r18, 0x64	; 100
    11ee:	30 e0       	ldi	r19, 0x00	; 0
    11f0:	40 e0       	ldi	r20, 0x00	; 0
    11f2:	50 e0       	ldi	r21, 0x00	; 0
    11f4:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <chb_write>
    11f8:	88 23       	and	r24, r24
    11fa:	a1 f7       	brne	.-24     	; 0x11e4 <main+0x3e2>
									i += 100;
    11fc:	84 e6       	ldi	r24, 0x64	; 100
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	a8 0e       	add	r10, r24
    1202:	b9 1e       	adc	r11, r25
    1204:	43 c0       	rjmp	.+134    	; 0x128c <main+0x48a>
								}
								else{
									readFRAM(samples*4 - i,(FRAMAddress-(samples*4))+i);
    1206:	8c 81       	ldd	r24, Y+4	; 0x04
    1208:	9d 81       	ldd	r25, Y+5	; 0x05
    120a:	ae 81       	ldd	r26, Y+6	; 0x06
    120c:	bf 81       	ldd	r27, Y+7	; 0x07
    120e:	e0 91 22 3e 	lds	r30, 0x3E22
    1212:	f0 91 23 3e 	lds	r31, 0x3E23
    1216:	4c 81       	ldd	r20, Y+4	; 0x04
    1218:	5d 81       	ldd	r21, Y+5	; 0x05
    121a:	6e 81       	ldd	r22, Y+6	; 0x06
    121c:	7f 81       	ldd	r23, Y+7	; 0x07
    121e:	9c 01       	movw	r18, r24
    1220:	22 0f       	add	r18, r18
    1222:	33 1f       	adc	r19, r19
    1224:	22 0f       	add	r18, r18
    1226:	33 1f       	adc	r19, r19
    1228:	ca 01       	movw	r24, r20
    122a:	88 0f       	add	r24, r24
    122c:	99 1f       	adc	r25, r25
    122e:	88 0f       	add	r24, r24
    1230:	99 1f       	adc	r25, r25
    1232:	bf 01       	movw	r22, r30
    1234:	68 1b       	sub	r22, r24
    1236:	79 0b       	sbc	r23, r25
    1238:	6a 0d       	add	r22, r10
    123a:	7b 1d       	adc	r23, r11
    123c:	c9 01       	movw	r24, r18
    123e:	8a 19       	sub	r24, r10
    1240:	9b 09       	sbc	r25, r11
    1242:	0e 94 cd 01 	call	0x39a	; 0x39a <readFRAM>
									while(chb_write(0x0000,FRAMReadBuffer,samples*4 - i) != CHB_SUCCESS);
    1246:	8c 81       	ldd	r24, Y+4	; 0x04
    1248:	9d 81       	ldd	r25, Y+5	; 0x05
    124a:	ae 81       	ldd	r26, Y+6	; 0x06
    124c:	bf 81       	ldd	r27, Y+7	; 0x07
    124e:	88 0f       	add	r24, r24
    1250:	99 1f       	adc	r25, r25
    1252:	aa 1f       	adc	r26, r26
    1254:	bb 1f       	adc	r27, r27
    1256:	88 0f       	add	r24, r24
    1258:	99 1f       	adc	r25, r25
    125a:	aa 1f       	adc	r26, r26
    125c:	bb 1f       	adc	r27, r27
    125e:	9c 01       	movw	r18, r24
    1260:	ad 01       	movw	r20, r26
    1262:	2c 19       	sub	r18, r12
    1264:	3d 09       	sbc	r19, r13
    1266:	4e 09       	sbc	r20, r14
    1268:	5f 09       	sbc	r21, r15
    126a:	80 e0       	ldi	r24, 0x00	; 0
    126c:	90 e0       	ldi	r25, 0x00	; 0
    126e:	61 2f       	mov	r22, r17
    1270:	75 2d       	mov	r23, r5
    1272:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <chb_write>
    1276:	88 23       	and	r24, r24
    1278:	31 f7       	brne	.-52     	; 0x1246 <main+0x444>
									i += samples*4 - i;
    127a:	8c 81       	ldd	r24, Y+4	; 0x04
    127c:	9d 81       	ldd	r25, Y+5	; 0x05
    127e:	ae 81       	ldd	r26, Y+6	; 0x06
    1280:	bf 81       	ldd	r27, Y+7	; 0x07
    1282:	5c 01       	movw	r10, r24
    1284:	aa 0c       	add	r10, r10
    1286:	bb 1c       	adc	r11, r11
    1288:	aa 0c       	add	r10, r10
    128a:	bb 1c       	adc	r11, r11
								}
								//reset timeout timer
								TimedOut = 0;
    128c:	10 92 0e 21 	sts	0x210E, r1
								TCE0.CTRLFSET = 0x08;
    1290:	98 e0       	ldi	r25, 0x08	; 8
    1292:	90 93 09 0a 	sts	0x0A09, r25
    1296:	f3 01       	movw	r30, r6
								while(!pcb->data_rcv){
    1298:	04 c0       	rjmp	.+8      	; 0x12a2 <main+0x4a0>
									//break if timed out waiting for response
									if(TimedOut) break;
    129a:	80 91 0e 21 	lds	r24, 0x210E
    129e:	88 23       	and	r24, r24
    12a0:	19 f4       	brne	.+6      	; 0x12a8 <main+0x4a6>
									i += samples*4 - i;
								}
								//reset timeout timer
								TimedOut = 0;
								TCE0.CTRLFSET = 0x08;
								while(!pcb->data_rcv){
    12a2:	87 81       	ldd	r24, Z+7	; 0x07
    12a4:	88 23       	and	r24, r24
    12a6:	c9 f3       	breq	.-14     	; 0x129a <main+0x498>
    12a8:	3f 01       	movw	r6, r30
									//break if timed out waiting for response
									if(TimedOut) break;
								}
								if(TimedOut) break;		
    12aa:	80 91 0e 21 	lds	r24, 0x210E
    12ae:	88 23       	and	r24, r24
    12b0:	c9 f4       	brne	.+50     	; 0x12e4 <main+0x4e2>
								length = chb_read((chb_rx_data_t*)RadioMessageBuffer);							
    12b2:	ce 01       	movw	r24, r28
    12b4:	08 96       	adiw	r24, 0x08	; 8
    12b6:	0e 94 29 1b 	call	0x3652	; 0x3652 <chb_read>
							}
							//reset timeout timer
							TimedOut = 0;
							TCE0.CTRLFSET = 0x08;  
							//read the data from FRAM and send it
							for(uint16_t i =0; i<(samples*4);){	
    12ba:	65 01       	movw	r12, r10
    12bc:	ee 24       	eor	r14, r14
    12be:	ff 24       	eor	r15, r15
    12c0:	8c 81       	ldd	r24, Y+4	; 0x04
    12c2:	9d 81       	ldd	r25, Y+5	; 0x05
    12c4:	ae 81       	ldd	r26, Y+6	; 0x06
    12c6:	bf 81       	ldd	r27, Y+7	; 0x07
    12c8:	88 0f       	add	r24, r24
    12ca:	99 1f       	adc	r25, r25
    12cc:	aa 1f       	adc	r26, r26
    12ce:	bb 1f       	adc	r27, r27
    12d0:	88 0f       	add	r24, r24
    12d2:	99 1f       	adc	r25, r25
    12d4:	aa 1f       	adc	r26, r26
    12d6:	bb 1f       	adc	r27, r27
    12d8:	c8 16       	cp	r12, r24
    12da:	d9 06       	cpc	r13, r25
    12dc:	ea 06       	cpc	r14, r26
    12de:	fb 06       	cpc	r15, r27
    12e0:	08 f4       	brcc	.+2      	; 0x12e4 <main+0x4e2>
    12e2:	57 cf       	rjmp	.-338    	; 0x1192 <main+0x390>
							}
							//chb_write(0x0000,FRAMReadBuffer,samples*4);								
							//write the data to SD card for good measure (make sure transmitted and collected data is the same)	
							//writeFile(ofile, FRAMReadBuffer, samples*4);			
						}
						if(TimedOut){
    12e4:	80 91 0e 21 	lds	r24, 0x210E
    12e8:	88 23       	and	r24, r24
    12ea:	31 f0       	breq	.+12     	; 0x12f8 <main+0x4f6>
							//stop timeout counter and go back to waiting for command
							TimedOut = 0;
    12ec:	10 92 0e 21 	sts	0x210E, r1
							TCE0.CTRLA = 0; 
    12f0:	a0 e0       	ldi	r26, 0x00	; 0
    12f2:	ba e0       	ldi	r27, 0x0A	; 10
    12f4:	1c 92       	st	X, r1
							break;
    12f6:	c2 cd       	rjmp	.-1148   	; 0xe7c <main+0x7a>
						}														
						DataAvailable = 0;
    12f8:	10 92 4c 3e 	sts	0x3E4C, r1
    12fc:	bf cd       	rjmp	.-1154   	; 0xe7c <main+0x7a>

000012fe <__vector_47>:
			}					
		}		
	}	
}

ISR(TCE0_OVF_vect){
    12fe:	1f 92       	push	r1
    1300:	0f 92       	push	r0
    1302:	0f b6       	in	r0, 0x3f	; 63
    1304:	0f 92       	push	r0
    1306:	11 24       	eor	r1, r1
    1308:	8f 93       	push	r24
	TimedOut = 1;
    130a:	81 e0       	ldi	r24, 0x01	; 1
    130c:	80 93 0e 21 	sts	0x210E, r24
    1310:	8f 91       	pop	r24
    1312:	0f 90       	pop	r0
    1314:	0f be       	out	0x3f, r0	; 63
    1316:	0f 90       	pop	r0
    1318:	1f 90       	pop	r1
    131a:	18 95       	reti

0000131c <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
    131c:	0f 93       	push	r16
    131e:	1f 93       	push	r17
    1320:	cf 93       	push	r28
    1322:	8c 01       	movw	r16, r24
	moteID = 1;
    1324:	c1 e0       	ldi	r28, 0x01	; 1
    1326:	c0 93 4a 3e 	sts	0x3E4A, r28
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
    132a:	83 e0       	ldi	r24, 0x03	; 3
    132c:	80 93 24 3e 	sts	0x3E24, r24
	chb_init();
    1330:	0e 94 57 1a 	call	0x34ae	; 0x34ae <chb_init>
	chb_set_short_addr(moteID);
    1334:	80 91 4a 3e 	lds	r24, 0x3E4A
    1338:	90 e0       	ldi	r25, 0x00	; 0
    133a:	0e 94 90 1c 	call	0x3920	; 0x3920 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
    133e:	88 ec       	ldi	r24, 0xC8	; 200
    1340:	e0 e8       	ldi	r30, 0x80	; 128
    1342:	f1 e0       	ldi	r31, 0x01	; 1
    1344:	81 83       	std	Z+1, r24	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
    1346:	e0 e4       	ldi	r30, 0x40	; 64
    1348:	f9 e0       	ldi	r31, 0x09	; 9
    134a:	89 e0       	ldi	r24, 0x09	; 9
    134c:	80 83       	st	Z, r24
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
    134e:	82 e0       	ldi	r24, 0x02	; 2
    1350:	86 83       	std	Z+6, r24	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
    1352:	24 ef       	ldi	r18, 0xF4	; 244
    1354:	31 e0       	ldi	r19, 0x01	; 1
    1356:	02 9f       	mul	r16, r18
    1358:	c0 01       	movw	r24, r0
    135a:	03 9f       	mul	r16, r19
    135c:	90 0d       	add	r25, r0
    135e:	12 9f       	mul	r17, r18
    1360:	90 0d       	add	r25, r0
    1362:	11 24       	eor	r1, r1
    1364:	86 a3       	lds	r24, 0x56
    1366:	97 a3       	lds	r25, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
    1368:	e0 e4       	ldi	r30, 0x40	; 64
    136a:	f8 e0       	ldi	r31, 0x08	; 8
    136c:	80 e0       	ldi	r24, 0x00	; 0
    136e:	9a ef       	ldi	r25, 0xFA	; 250
    1370:	86 a3       	lds	r24, 0x56
    1372:	97 a3       	lds	r25, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
    1374:	c6 83       	std	Z+6, r28	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
    1376:	c0 83       	st	Z, r28
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
    1378:	e0 ea       	ldi	r30, 0xA0	; 160
    137a:	f0 e0       	ldi	r31, 0x00	; 0
    137c:	82 81       	ldd	r24, Z+2	; 0x02
    137e:	87 60       	ori	r24, 0x07	; 7
    1380:	82 83       	std	Z+2, r24	; 0x02
	sei(); //  Enable global interrupts
    1382:	78 94       	sei
}
    1384:	cf 91       	pop	r28
    1386:	1f 91       	pop	r17
    1388:	0f 91       	pop	r16
    138a:	08 95       	ret

0000138c <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
    138c:	78 94       	sei
    138e:	1f 92       	push	r1
    1390:	0f 92       	push	r0
    1392:	0f b6       	in	r0, 0x3f	; 63
    1394:	0f 92       	push	r0
    1396:	0b b6       	in	r0, 0x3b	; 59
    1398:	0f 92       	push	r0
    139a:	11 24       	eor	r1, r1
    139c:	ef 92       	push	r14
    139e:	ff 92       	push	r15
    13a0:	0f 93       	push	r16
    13a2:	1f 93       	push	r17
    13a4:	2f 93       	push	r18
    13a6:	3f 93       	push	r19
    13a8:	4f 93       	push	r20
    13aa:	5f 93       	push	r21
    13ac:	6f 93       	push	r22
    13ae:	7f 93       	push	r23
    13b0:	8f 93       	push	r24
    13b2:	9f 93       	push	r25
    13b4:	af 93       	push	r26
    13b6:	bf 93       	push	r27
    13b8:	ef 93       	push	r30
    13ba:	ff 93       	push	r31
    13bc:	cf 93       	push	r28
    13be:	df 93       	push	r29
    13c0:	cd b7       	in	r28, 0x3d	; 61
    13c2:	de b7       	in	r29, 0x3e	; 62
    13c4:	28 97       	sbiw	r28, 0x08	; 8
    13c6:	cd bf       	out	0x3d, r28	; 61
    13c8:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
    13ca:	10 92 40 08 	sts	0x0840, r1
	TCD1.CTRLA = 0x00;
    13ce:	10 92 40 09 	sts	0x0940, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
    13d2:	82 e0       	ldi	r24, 0x02	; 2
    13d4:	80 93 24 3e 	sts	0x3E24, r24
	char message[8];
	strcpy(message,"reset");
    13d8:	de 01       	movw	r26, r28
    13da:	11 96       	adiw	r26, 0x01	; 1
    13dc:	e4 e0       	ldi	r30, 0x04	; 4
    13de:	f0 e2       	ldi	r31, 0x20	; 32
    13e0:	86 e0       	ldi	r24, 0x06	; 6
    13e2:	01 90       	ld	r0, Z+
    13e4:	0d 92       	st	X+, r0
    13e6:	81 50       	subi	r24, 0x01	; 1
    13e8:	e1 f7       	brne	.-8      	; 0x13e2 <__vector_83+0x56>
	itoa((int)(moteID),buff,10);
    13ea:	0e ea       	ldi	r16, 0xAE	; 174
    13ec:	10 e5       	ldi	r17, 0x50	; 80
    13ee:	80 91 4a 3e 	lds	r24, 0x3E4A
    13f2:	90 e0       	ldi	r25, 0x00	; 0
    13f4:	b8 01       	movw	r22, r16
    13f6:	4a e0       	ldi	r20, 0x0A	; 10
    13f8:	50 e0       	ldi	r21, 0x00	; 0
    13fa:	0e 94 5a 3a 	call	0x74b4	; 0x74b4 <itoa>
	strcat(message,buff);
    13fe:	7e 01       	movw	r14, r28
    1400:	08 94       	sec
    1402:	e1 1c       	adc	r14, r1
    1404:	f1 1c       	adc	r15, r1
    1406:	c7 01       	movw	r24, r14
    1408:	b8 01       	movw	r22, r16
    140a:	0e 94 4f 3a 	call	0x749e	; 0x749e <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
    140e:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
    1412:	f7 01       	movw	r30, r14
    1414:	01 90       	ld	r0, Z+
    1416:	00 20       	and	r0, r0
    1418:	e9 f7       	brne	.-6      	; 0x1414 <__vector_83+0x88>
    141a:	31 97       	sbiw	r30, 0x01	; 1
    141c:	ee 19       	sub	r30, r14
    141e:	ff 09       	sbc	r31, r15
    1420:	9f 01       	movw	r18, r30
    1422:	40 e0       	ldi	r20, 0x00	; 0
    1424:	50 e0       	ldi	r21, 0x00	; 0
    1426:	80 e0       	ldi	r24, 0x00	; 0
    1428:	90 e0       	ldi	r25, 0x00	; 0
    142a:	b7 01       	movw	r22, r14
    142c:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <chb_write>
}	
    1430:	28 96       	adiw	r28, 0x08	; 8
    1432:	cd bf       	out	0x3d, r28	; 61
    1434:	de bf       	out	0x3e, r29	; 62
    1436:	df 91       	pop	r29
    1438:	cf 91       	pop	r28
    143a:	ff 91       	pop	r31
    143c:	ef 91       	pop	r30
    143e:	bf 91       	pop	r27
    1440:	af 91       	pop	r26
    1442:	9f 91       	pop	r25
    1444:	8f 91       	pop	r24
    1446:	7f 91       	pop	r23
    1448:	6f 91       	pop	r22
    144a:	5f 91       	pop	r21
    144c:	4f 91       	pop	r20
    144e:	3f 91       	pop	r19
    1450:	2f 91       	pop	r18
    1452:	1f 91       	pop	r17
    1454:	0f 91       	pop	r16
    1456:	ff 90       	pop	r15
    1458:	ef 90       	pop	r14
    145a:	0f 90       	pop	r0
    145c:	0b be       	out	0x3b, r0	; 59
    145e:	0f 90       	pop	r0
    1460:	0f be       	out	0x3f, r0	; 63
    1462:	0f 90       	pop	r0
    1464:	1f 90       	pop	r1
    1466:	18 95       	reti

00001468 <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    1468:	4f 92       	push	r4
    146a:	5f 92       	push	r5
    146c:	6f 92       	push	r6
    146e:	7f 92       	push	r7
    1470:	8f 92       	push	r8
    1472:	9f 92       	push	r9
    1474:	af 92       	push	r10
    1476:	bf 92       	push	r11
    1478:	ef 92       	push	r14
    147a:	ff 92       	push	r15
    147c:	0f 93       	push	r16
    147e:	1f 93       	push	r17
    1480:	cf 93       	push	r28
    1482:	df 93       	push	r29
    1484:	cd b7       	in	r28, 0x3d	; 61
    1486:	de b7       	in	r29, 0x3e	; 62
    1488:	2b 97       	sbiw	r28, 0x0b	; 11
    148a:	cd bf       	out	0x3d, r28	; 61
    148c:	de bf       	out	0x3e, r29	; 62
    148e:	8e 83       	std	Y+6, r24	; 0x06
    1490:	9f 83       	std	Y+7, r25	; 0x07
    1492:	68 87       	std	Y+8, r22	; 0x08
    1494:	79 87       	std	Y+9, r23	; 0x09
    1496:	4a 87       	std	Y+10, r20	; 0x0a
    1498:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    149a:	81 e0       	ldi	r24, 0x01	; 1
    149c:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
    14a0:	80 e0       	ldi	r24, 0x00	; 0
    14a2:	92 e0       	ldi	r25, 0x02	; 2
    14a4:	0e 94 3a 1a 	call	0x3474	; 0x3474 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    14a8:	00 e0       	ldi	r16, 0x00	; 0
    14aa:	12 e0       	ldi	r17, 0x02	; 2
    14ac:	d8 01       	movw	r26, r16
    14ae:	11 96       	adiw	r26, 0x01	; 1
    14b0:	8c 91       	ld	r24, X
    14b2:	11 97       	sbiw	r26, 0x01	; 1
    14b4:	89 7e       	andi	r24, 0xE9	; 233
    14b6:	11 96       	adiw	r26, 0x01	; 1
    14b8:	8c 93       	st	X, r24
    14ba:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
    14bc:	14 96       	adiw	r26, 0x04	; 4
    14be:	8c 91       	ld	r24, X
    14c0:	14 97       	sbiw	r26, 0x04	; 4
    14c2:	88 7f       	andi	r24, 0xF8	; 248
    14c4:	83 60       	ori	r24, 0x03	; 3
    14c6:	14 96       	adiw	r26, 0x04	; 4
    14c8:	8c 93       	st	X, r24
    14ca:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
    14cc:	12 96       	adiw	r26, 0x02	; 2
    14ce:	8c 91       	ld	r24, X
    14d0:	12 97       	sbiw	r26, 0x02	; 2
    14d2:	8f 7c       	andi	r24, 0xCF	; 207
    14d4:	12 96       	adiw	r26, 0x02	; 2
    14d6:	8c 93       	st	X, r24
    14d8:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
    14da:	0f 2e       	mov	r0, r31
    14dc:	f0 e2       	ldi	r31, 0x20	; 32
    14de:	ef 2e       	mov	r14, r31
    14e0:	f2 e0       	ldi	r31, 0x02	; 2
    14e2:	ff 2e       	mov	r15, r31
    14e4:	f0 2d       	mov	r31, r0
    14e6:	f7 01       	movw	r30, r14
    14e8:	80 81       	ld	r24, Z
    14ea:	80 7e       	andi	r24, 0xE0	; 224
    14ec:	81 60       	ori	r24, 0x01	; 1
    14ee:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    14f0:	89 e0       	ldi	r24, 0x09	; 9
    14f2:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
    14f4:	8c 91       	ld	r24, X
    14f6:	81 60       	ori	r24, 0x01	; 1
    14f8:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    14fa:	80 e0       	ldi	r24, 0x00	; 0
    14fc:	92 e0       	ldi	r25, 0x02	; 2
    14fe:	0e 94 bf 19 	call	0x337e	; 0x337e <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
    1502:	80 e0       	ldi	r24, 0x00	; 0
    1504:	92 e0       	ldi	r25, 0x02	; 2
    1506:	60 e2       	ldi	r22, 0x20	; 32
    1508:	72 e0       	ldi	r23, 0x02	; 2
    150a:	40 e0       	ldi	r20, 0x00	; 0
    150c:	0e 94 c9 19 	call	0x3392	; 0x3392 <ADC_Offset_Get_Unsigned>
    1510:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
    1512:	d8 01       	movw	r26, r16
    1514:	8c 91       	ld	r24, X
    1516:	8e 7f       	andi	r24, 0xFE	; 254
    1518:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    151a:	f7 01       	movw	r30, r14
    151c:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
    151e:	13 96       	adiw	r26, 0x03	; 3
    1520:	8c 91       	ld	r24, X
    1522:	13 97       	sbiw	r26, 0x03	; 3
    1524:	8f 73       	andi	r24, 0x3F	; 63
    1526:	13 96       	adiw	r26, 0x03	; 3
    1528:	8c 93       	st	X, r24
    152a:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
    152c:	8c 91       	ld	r24, X
    152e:	81 60       	ori	r24, 0x01	; 1
    1530:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    1532:	80 e0       	ldi	r24, 0x00	; 0
    1534:	92 e0       	ldi	r25, 0x02	; 2
    1536:	0e 94 bf 19 	call	0x337e	; 0x337e <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
    153a:	d8 01       	movw	r26, r16
    153c:	11 96       	adiw	r26, 0x01	; 1
    153e:	8c 91       	ld	r24, X
    1540:	11 97       	sbiw	r26, 0x01	; 1
    1542:	88 60       	ori	r24, 0x08	; 8
    1544:	11 96       	adiw	r26, 0x01	; 1
    1546:	8c 93       	st	X, r24
    1548:	ee 24       	eor	r14, r14
    154a:	ff 24       	eor	r15, r15
    154c:	68 94       	set
    154e:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    1550:	44 24       	eor	r4, r4
    1552:	55 24       	eor	r5, r5
    1554:	32 01       	movw	r6, r4
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
    1556:	20 e0       	ldi	r18, 0x00	; 0
    1558:	30 e1       	ldi	r19, 0x10	; 16
    155a:	40 e0       	ldi	r20, 0x00	; 0
    155c:	50 e0       	ldi	r21, 0x00	; 0
    155e:	2a 83       	std	Y+2, r18	; 0x02
    1560:	3b 83       	std	Y+3, r19	; 0x03
    1562:	4c 83       	std	Y+4, r20	; 0x04
    1564:	5d 83       	std	Y+5, r21	; 0x05
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    1566:	88 24       	eor	r8, r8
    1568:	99 24       	eor	r9, r9
    156a:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
    156c:	00 e2       	ldi	r16, 0x20	; 32
    156e:	12 e0       	ldi	r17, 0x02	; 2
    1570:	d8 01       	movw	r26, r16
    1572:	13 96       	adiw	r26, 0x03	; 3
    1574:	8c 91       	ld	r24, X
    1576:	13 97       	sbiw	r26, 0x03	; 3
    1578:	80 ff       	sbrs	r24, 0
    157a:	fa cf       	rjmp	.-12     	; 0x1570 <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
    157c:	69 81       	ldd	r22, Y+1	; 0x01
    157e:	c8 01       	movw	r24, r16
    1580:	0e 94 9b 19 	call	0x3336	; 0x3336 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
    1584:	a0 e0       	ldi	r26, 0x00	; 0
    1586:	b0 e0       	ldi	r27, 0x00	; 0
    1588:	88 0e       	add	r8, r24
    158a:	99 1e       	adc	r9, r25
    158c:	aa 1e       	adc	r10, r26
    158e:	bb 1e       	adc	r11, r27
    1590:	48 16       	cp	r4, r24
    1592:	59 06       	cpc	r5, r25
    1594:	6a 06       	cpc	r6, r26
    1596:	7b 06       	cpc	r7, r27
    1598:	10 f4       	brcc	.+4      	; 0x159e <CO_collectTemp+0x136>
    159a:	2c 01       	movw	r4, r24
    159c:	3d 01       	movw	r6, r26
    159e:	2a 81       	ldd	r18, Y+2	; 0x02
    15a0:	3b 81       	ldd	r19, Y+3	; 0x03
    15a2:	4c 81       	ldd	r20, Y+4	; 0x04
    15a4:	5d 81       	ldd	r21, Y+5	; 0x05
    15a6:	82 17       	cp	r24, r18
    15a8:	93 07       	cpc	r25, r19
    15aa:	a4 07       	cpc	r26, r20
    15ac:	b5 07       	cpc	r27, r21
    15ae:	20 f4       	brcc	.+8      	; 0x15b8 <CO_collectTemp+0x150>
    15b0:	8a 83       	std	Y+2, r24	; 0x02
    15b2:	9b 83       	std	Y+3, r25	; 0x03
    15b4:	ac 83       	std	Y+4, r26	; 0x04
    15b6:	bd 83       	std	Y+5, r27	; 0x05
    15b8:	08 94       	sec
    15ba:	e1 08       	sbc	r14, r1
    15bc:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    15be:	e1 14       	cp	r14, r1
    15c0:	f1 04       	cpc	r15, r1
    15c2:	b1 f6       	brne	.-84     	; 0x1570 <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
    15c4:	e0 e0       	ldi	r30, 0x00	; 0
    15c6:	f2 e0       	ldi	r31, 0x02	; 2
    15c8:	81 81       	ldd	r24, Z+1	; 0x01
    15ca:	87 7f       	andi	r24, 0xF7	; 247
    15cc:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
    15ce:	80 81       	ld	r24, Z
    15d0:	82 60       	ori	r24, 0x02	; 2
    15d2:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
    15d4:	80 81       	ld	r24, Z
    15d6:	8e 7f       	andi	r24, 0xFE	; 254
    15d8:	80 83       	st	Z, r24

	ADCPower(FALSE);
    15da:	80 e0       	ldi	r24, 0x00	; 0
    15dc:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <ADCPower>

	average = sum / NUM_SAMPLES;
    15e0:	c5 01       	movw	r24, r10
    15e2:	b4 01       	movw	r22, r8
    15e4:	05 2e       	mov	r0, r21
    15e6:	5a e0       	ldi	r21, 0x0A	; 10
    15e8:	96 95       	lsr	r25
    15ea:	87 95       	ror	r24
    15ec:	77 95       	ror	r23
    15ee:	67 95       	ror	r22
    15f0:	5a 95       	dec	r21
    15f2:	d1 f7       	brne	.-12     	; 0x15e8 <CO_collectTemp+0x180>
    15f4:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    15f6:	28 ee       	ldi	r18, 0xE8	; 232
    15f8:	33 e0       	ldi	r19, 0x03	; 3
    15fa:	40 e0       	ldi	r20, 0x00	; 0
    15fc:	50 e0       	ldi	r21, 0x00	; 0
    15fe:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    1602:	0f 2e       	mov	r0, r31
    1604:	ff ef       	ldi	r31, 0xFF	; 255
    1606:	8f 2e       	mov	r8, r31
    1608:	ff e0       	ldi	r31, 0x0F	; 15
    160a:	9f 2e       	mov	r9, r31
    160c:	f0 e0       	ldi	r31, 0x00	; 0
    160e:	af 2e       	mov	r10, r31
    1610:	f0 e0       	ldi	r31, 0x00	; 0
    1612:	bf 2e       	mov	r11, r31
    1614:	f0 2d       	mov	r31, r0
    1616:	a5 01       	movw	r20, r10
    1618:	94 01       	movw	r18, r8
    161a:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    161e:	c9 01       	movw	r24, r18
    1620:	c2 97       	sbiw	r24, 0x32	; 50
    1622:	ae 81       	ldd	r26, Y+6	; 0x06
    1624:	bf 81       	ldd	r27, Y+7	; 0x07
    1626:	8d 93       	st	X+, r24
    1628:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    162a:	c3 01       	movw	r24, r6
    162c:	b2 01       	movw	r22, r4
    162e:	28 ee       	ldi	r18, 0xE8	; 232
    1630:	33 e0       	ldi	r19, 0x03	; 3
    1632:	40 e0       	ldi	r20, 0x00	; 0
    1634:	50 e0       	ldi	r21, 0x00	; 0
    1636:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    163a:	a5 01       	movw	r20, r10
    163c:	94 01       	movw	r18, r8
    163e:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    1642:	c9 01       	movw	r24, r18
    1644:	c2 97       	sbiw	r24, 0x32	; 50
    1646:	ea 85       	ldd	r30, Y+10	; 0x0a
    1648:	fb 85       	ldd	r31, Y+11	; 0x0b
    164a:	80 83       	st	Z, r24
    164c:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    164e:	6a 81       	ldd	r22, Y+2	; 0x02
    1650:	7b 81       	ldd	r23, Y+3	; 0x03
    1652:	8c 81       	ldd	r24, Y+4	; 0x04
    1654:	9d 81       	ldd	r25, Y+5	; 0x05
    1656:	28 ee       	ldi	r18, 0xE8	; 232
    1658:	33 e0       	ldi	r19, 0x03	; 3
    165a:	40 e0       	ldi	r20, 0x00	; 0
    165c:	50 e0       	ldi	r21, 0x00	; 0
    165e:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    1662:	a5 01       	movw	r20, r10
    1664:	94 01       	movw	r18, r8
    1666:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    166a:	22 53       	subi	r18, 0x32	; 50
    166c:	30 40       	sbci	r19, 0x00	; 0
    166e:	a8 85       	ldd	r26, Y+8	; 0x08
    1670:	b9 85       	ldd	r27, Y+9	; 0x09
    1672:	2d 93       	st	X+, r18
    1674:	3c 93       	st	X, r19
    1676:	11 97       	sbiw	r26, 0x01	; 1
}
    1678:	2b 96       	adiw	r28, 0x0b	; 11
    167a:	cd bf       	out	0x3d, r28	; 61
    167c:	de bf       	out	0x3e, r29	; 62
    167e:	df 91       	pop	r29
    1680:	cf 91       	pop	r28
    1682:	1f 91       	pop	r17
    1684:	0f 91       	pop	r16
    1686:	ff 90       	pop	r15
    1688:	ef 90       	pop	r14
    168a:	bf 90       	pop	r11
    168c:	af 90       	pop	r10
    168e:	9f 90       	pop	r9
    1690:	8f 90       	pop	r8
    1692:	7f 90       	pop	r7
    1694:	6f 90       	pop	r6
    1696:	5f 90       	pop	r5
    1698:	4f 90       	pop	r4
    169a:	08 95       	ret

0000169c <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    169c:	4f 92       	push	r4
    169e:	5f 92       	push	r5
    16a0:	6f 92       	push	r6
    16a2:	7f 92       	push	r7
    16a4:	8f 92       	push	r8
    16a6:	9f 92       	push	r9
    16a8:	af 92       	push	r10
    16aa:	bf 92       	push	r11
    16ac:	ef 92       	push	r14
    16ae:	ff 92       	push	r15
    16b0:	0f 93       	push	r16
    16b2:	1f 93       	push	r17
    16b4:	cf 93       	push	r28
    16b6:	df 93       	push	r29
    16b8:	cd b7       	in	r28, 0x3d	; 61
    16ba:	de b7       	in	r29, 0x3e	; 62
    16bc:	2b 97       	sbiw	r28, 0x0b	; 11
    16be:	cd bf       	out	0x3d, r28	; 61
    16c0:	de bf       	out	0x3e, r29	; 62
    16c2:	8e 83       	std	Y+6, r24	; 0x06
    16c4:	9f 83       	std	Y+7, r25	; 0x07
    16c6:	68 87       	std	Y+8, r22	; 0x08
    16c8:	79 87       	std	Y+9, r23	; 0x09
    16ca:	4a 87       	std	Y+10, r20	; 0x0a
    16cc:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    16ce:	81 e0       	ldi	r24, 0x01	; 1
    16d0:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
    16d4:	84 e0       	ldi	r24, 0x04	; 4
    16d6:	60 e0       	ldi	r22, 0x00	; 0
    16d8:	0e 94 8a 05 	call	0xb14	; 0xb14 <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
    16dc:	84 e0       	ldi	r24, 0x04	; 4
    16de:	60 e0       	ldi	r22, 0x00	; 0
    16e0:	0e 94 dd 04 	call	0x9ba	; 0x9ba <PortEx_OUTSET>
    16e4:	2f ef       	ldi	r18, 0xFF	; 255
    16e6:	33 ec       	ldi	r19, 0xC3	; 195
    16e8:	49 e0       	ldi	r20, 0x09	; 9
    16ea:	21 50       	subi	r18, 0x01	; 1
    16ec:	30 40       	sbci	r19, 0x00	; 0
    16ee:	40 40       	sbci	r20, 0x00	; 0
    16f0:	e1 f7       	brne	.-8      	; 0x16ea <CO_collectBatt+0x4e>
    16f2:	00 c0       	rjmp	.+0      	; 0x16f4 <CO_collectBatt+0x58>
    16f4:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
    16f6:	80 e4       	ldi	r24, 0x40	; 64
    16f8:	92 e0       	ldi	r25, 0x02	; 2
    16fa:	0e 94 3a 1a 	call	0x3474	; 0x3474 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    16fe:	00 e4       	ldi	r16, 0x40	; 64
    1700:	12 e0       	ldi	r17, 0x02	; 2
    1702:	d8 01       	movw	r26, r16
    1704:	11 96       	adiw	r26, 0x01	; 1
    1706:	8c 91       	ld	r24, X
    1708:	11 97       	sbiw	r26, 0x01	; 1
    170a:	89 7e       	andi	r24, 0xE9	; 233
    170c:	11 96       	adiw	r26, 0x01	; 1
    170e:	8c 93       	st	X, r24
    1710:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
    1712:	14 96       	adiw	r26, 0x04	; 4
    1714:	8c 91       	ld	r24, X
    1716:	14 97       	sbiw	r26, 0x04	; 4
    1718:	88 7f       	andi	r24, 0xF8	; 248
    171a:	83 60       	ori	r24, 0x03	; 3
    171c:	14 96       	adiw	r26, 0x04	; 4
    171e:	8c 93       	st	X, r24
    1720:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
    1722:	12 96       	adiw	r26, 0x02	; 2
    1724:	8c 91       	ld	r24, X
    1726:	12 97       	sbiw	r26, 0x02	; 2
    1728:	8f 7c       	andi	r24, 0xCF	; 207
    172a:	12 96       	adiw	r26, 0x02	; 2
    172c:	8c 93       	st	X, r24
    172e:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
    1730:	0f 2e       	mov	r0, r31
    1732:	f0 e6       	ldi	r31, 0x60	; 96
    1734:	ef 2e       	mov	r14, r31
    1736:	f2 e0       	ldi	r31, 0x02	; 2
    1738:	ff 2e       	mov	r15, r31
    173a:	f0 2d       	mov	r31, r0
    173c:	f7 01       	movw	r30, r14
    173e:	80 81       	ld	r24, Z
    1740:	80 7e       	andi	r24, 0xE0	; 224
    1742:	81 60       	ori	r24, 0x01	; 1
    1744:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    1746:	89 e0       	ldi	r24, 0x09	; 9
    1748:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
    174a:	8c 91       	ld	r24, X
    174c:	81 60       	ori	r24, 0x01	; 1
    174e:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
    1750:	80 e4       	ldi	r24, 0x40	; 64
    1752:	92 e0       	ldi	r25, 0x02	; 2
    1754:	0e 94 bf 19 	call	0x337e	; 0x337e <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
    1758:	80 e4       	ldi	r24, 0x40	; 64
    175a:	92 e0       	ldi	r25, 0x02	; 2
    175c:	60 e6       	ldi	r22, 0x60	; 96
    175e:	72 e0       	ldi	r23, 0x02	; 2
    1760:	40 e0       	ldi	r20, 0x00	; 0
    1762:	0e 94 c9 19 	call	0x3392	; 0x3392 <ADC_Offset_Get_Unsigned>
    1766:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
    1768:	d8 01       	movw	r26, r16
    176a:	8c 91       	ld	r24, X
    176c:	8e 7f       	andi	r24, 0xFE	; 254
    176e:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    1770:	f7 01       	movw	r30, r14
    1772:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
    1774:	13 96       	adiw	r26, 0x03	; 3
    1776:	8c 91       	ld	r24, X
    1778:	13 97       	sbiw	r26, 0x03	; 3
    177a:	8f 73       	andi	r24, 0x3F	; 63
    177c:	13 96       	adiw	r26, 0x03	; 3
    177e:	8c 93       	st	X, r24
    1780:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
    1782:	8c 91       	ld	r24, X
    1784:	81 60       	ori	r24, 0x01	; 1
    1786:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
    1788:	80 e4       	ldi	r24, 0x40	; 64
    178a:	92 e0       	ldi	r25, 0x02	; 2
    178c:	0e 94 bf 19 	call	0x337e	; 0x337e <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
    1790:	d8 01       	movw	r26, r16
    1792:	11 96       	adiw	r26, 0x01	; 1
    1794:	8c 91       	ld	r24, X
    1796:	11 97       	sbiw	r26, 0x01	; 1
    1798:	88 60       	ori	r24, 0x08	; 8
    179a:	11 96       	adiw	r26, 0x01	; 1
    179c:	8c 93       	st	X, r24
    179e:	ee 24       	eor	r14, r14
    17a0:	ff 24       	eor	r15, r15
    17a2:	68 94       	set
    17a4:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    17a6:	44 24       	eor	r4, r4
    17a8:	55 24       	eor	r5, r5
    17aa:	32 01       	movw	r6, r4
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
    17ac:	20 e0       	ldi	r18, 0x00	; 0
    17ae:	30 e1       	ldi	r19, 0x10	; 16
    17b0:	40 e0       	ldi	r20, 0x00	; 0
    17b2:	50 e0       	ldi	r21, 0x00	; 0
    17b4:	2a 83       	std	Y+2, r18	; 0x02
    17b6:	3b 83       	std	Y+3, r19	; 0x03
    17b8:	4c 83       	std	Y+4, r20	; 0x04
    17ba:	5d 83       	std	Y+5, r21	; 0x05
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    17bc:	88 24       	eor	r8, r8
    17be:	99 24       	eor	r9, r9
    17c0:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
    17c2:	00 e6       	ldi	r16, 0x60	; 96
    17c4:	12 e0       	ldi	r17, 0x02	; 2
    17c6:	d8 01       	movw	r26, r16
    17c8:	13 96       	adiw	r26, 0x03	; 3
    17ca:	8c 91       	ld	r24, X
    17cc:	13 97       	sbiw	r26, 0x03	; 3
    17ce:	80 ff       	sbrs	r24, 0
    17d0:	fa cf       	rjmp	.-12     	; 0x17c6 <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
    17d2:	69 81       	ldd	r22, Y+1	; 0x01
    17d4:	c8 01       	movw	r24, r16
    17d6:	0e 94 9b 19 	call	0x3336	; 0x3336 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
    17da:	a0 e0       	ldi	r26, 0x00	; 0
    17dc:	b0 e0       	ldi	r27, 0x00	; 0
    17de:	88 0e       	add	r8, r24
    17e0:	99 1e       	adc	r9, r25
    17e2:	aa 1e       	adc	r10, r26
    17e4:	bb 1e       	adc	r11, r27
    17e6:	48 16       	cp	r4, r24
    17e8:	59 06       	cpc	r5, r25
    17ea:	6a 06       	cpc	r6, r26
    17ec:	7b 06       	cpc	r7, r27
    17ee:	10 f4       	brcc	.+4      	; 0x17f4 <CO_collectBatt+0x158>
    17f0:	2c 01       	movw	r4, r24
    17f2:	3d 01       	movw	r6, r26
    17f4:	2a 81       	ldd	r18, Y+2	; 0x02
    17f6:	3b 81       	ldd	r19, Y+3	; 0x03
    17f8:	4c 81       	ldd	r20, Y+4	; 0x04
    17fa:	5d 81       	ldd	r21, Y+5	; 0x05
    17fc:	82 17       	cp	r24, r18
    17fe:	93 07       	cpc	r25, r19
    1800:	a4 07       	cpc	r26, r20
    1802:	b5 07       	cpc	r27, r21
    1804:	20 f4       	brcc	.+8      	; 0x180e <CO_collectBatt+0x172>
    1806:	8a 83       	std	Y+2, r24	; 0x02
    1808:	9b 83       	std	Y+3, r25	; 0x03
    180a:	ac 83       	std	Y+4, r26	; 0x04
    180c:	bd 83       	std	Y+5, r27	; 0x05
    180e:	08 94       	sec
    1810:	e1 08       	sbc	r14, r1
    1812:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    1814:	e1 14       	cp	r14, r1
    1816:	f1 04       	cpc	r15, r1
    1818:	b1 f6       	brne	.-84     	; 0x17c6 <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
    181a:	e0 e4       	ldi	r30, 0x40	; 64
    181c:	f2 e0       	ldi	r31, 0x02	; 2
    181e:	81 81       	ldd	r24, Z+1	; 0x01
    1820:	87 7f       	andi	r24, 0xF7	; 247
    1822:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
    1824:	80 81       	ld	r24, Z
    1826:	8e 7f       	andi	r24, 0xFE	; 254
    1828:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
    182a:	84 e0       	ldi	r24, 0x04	; 4
    182c:	60 e0       	ldi	r22, 0x00	; 0
    182e:	0e 94 32 05 	call	0xa64	; 0xa64 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
    1832:	80 e0       	ldi	r24, 0x00	; 0
    1834:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
    1838:	c5 01       	movw	r24, r10
    183a:	b4 01       	movw	r22, r8
    183c:	05 2e       	mov	r0, r21
    183e:	5a e0       	ldi	r21, 0x0A	; 10
    1840:	96 95       	lsr	r25
    1842:	87 95       	ror	r24
    1844:	77 95       	ror	r23
    1846:	67 95       	ror	r22
    1848:	5a 95       	dec	r21
    184a:	d1 f7       	brne	.-12     	; 0x1840 <CO_collectBatt+0x1a4>
    184c:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    184e:	28 ee       	ldi	r18, 0xE8	; 232
    1850:	33 e0       	ldi	r19, 0x03	; 3
    1852:	40 e0       	ldi	r20, 0x00	; 0
    1854:	50 e0       	ldi	r21, 0x00	; 0
    1856:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    185a:	0f 2e       	mov	r0, r31
    185c:	ff ef       	ldi	r31, 0xFF	; 255
    185e:	8f 2e       	mov	r8, r31
    1860:	ff e0       	ldi	r31, 0x0F	; 15
    1862:	9f 2e       	mov	r9, r31
    1864:	f0 e0       	ldi	r31, 0x00	; 0
    1866:	af 2e       	mov	r10, r31
    1868:	f0 e0       	ldi	r31, 0x00	; 0
    186a:	bf 2e       	mov	r11, r31
    186c:	f0 2d       	mov	r31, r0
    186e:	a5 01       	movw	r20, r10
    1870:	94 01       	movw	r18, r8
    1872:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    1876:	c9 01       	movw	r24, r18
    1878:	c2 97       	sbiw	r24, 0x32	; 50
    187a:	ae 81       	ldd	r26, Y+6	; 0x06
    187c:	bf 81       	ldd	r27, Y+7	; 0x07
    187e:	8d 93       	st	X+, r24
    1880:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    1882:	c3 01       	movw	r24, r6
    1884:	b2 01       	movw	r22, r4
    1886:	28 ee       	ldi	r18, 0xE8	; 232
    1888:	33 e0       	ldi	r19, 0x03	; 3
    188a:	40 e0       	ldi	r20, 0x00	; 0
    188c:	50 e0       	ldi	r21, 0x00	; 0
    188e:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    1892:	a5 01       	movw	r20, r10
    1894:	94 01       	movw	r18, r8
    1896:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    189a:	c9 01       	movw	r24, r18
    189c:	c2 97       	sbiw	r24, 0x32	; 50
    189e:	ea 85       	ldd	r30, Y+10	; 0x0a
    18a0:	fb 85       	ldd	r31, Y+11	; 0x0b
    18a2:	80 83       	st	Z, r24
    18a4:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    18a6:	6a 81       	ldd	r22, Y+2	; 0x02
    18a8:	7b 81       	ldd	r23, Y+3	; 0x03
    18aa:	8c 81       	ldd	r24, Y+4	; 0x04
    18ac:	9d 81       	ldd	r25, Y+5	; 0x05
    18ae:	28 ee       	ldi	r18, 0xE8	; 232
    18b0:	33 e0       	ldi	r19, 0x03	; 3
    18b2:	40 e0       	ldi	r20, 0x00	; 0
    18b4:	50 e0       	ldi	r21, 0x00	; 0
    18b6:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    18ba:	a5 01       	movw	r20, r10
    18bc:	94 01       	movw	r18, r8
    18be:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    18c2:	22 53       	subi	r18, 0x32	; 50
    18c4:	30 40       	sbci	r19, 0x00	; 0
    18c6:	a8 85       	ldd	r26, Y+8	; 0x08
    18c8:	b9 85       	ldd	r27, Y+9	; 0x09
    18ca:	2d 93       	st	X+, r18
    18cc:	3c 93       	st	X, r19
    18ce:	11 97       	sbiw	r26, 0x01	; 1
}
    18d0:	2b 96       	adiw	r28, 0x0b	; 11
    18d2:	cd bf       	out	0x3d, r28	; 61
    18d4:	de bf       	out	0x3e, r29	; 62
    18d6:	df 91       	pop	r29
    18d8:	cf 91       	pop	r28
    18da:	1f 91       	pop	r17
    18dc:	0f 91       	pop	r16
    18de:	ff 90       	pop	r15
    18e0:	ef 90       	pop	r14
    18e2:	bf 90       	pop	r11
    18e4:	af 90       	pop	r10
    18e6:	9f 90       	pop	r9
    18e8:	8f 90       	pop	r8
    18ea:	7f 90       	pop	r7
    18ec:	6f 90       	pop	r6
    18ee:	5f 90       	pop	r5
    18f0:	4f 90       	pop	r4
    18f2:	08 95       	ret

000018f4 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
    18f4:	cf 93       	push	r28
    18f6:	c6 2f       	mov	r28, r22
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
    18f8:	21 e0       	ldi	r18, 0x01	; 1
    18fa:	30 e0       	ldi	r19, 0x00	; 0
    18fc:	a9 01       	movw	r20, r18
    18fe:	02 c0       	rjmp	.+4      	; 0x1904 <set_ampGain+0x10>
    1900:	44 0f       	add	r20, r20
    1902:	55 1f       	adc	r21, r21
    1904:	8a 95       	dec	r24
    1906:	e2 f7       	brpl	.-8      	; 0x1900 <set_ampGain+0xc>
    1908:	ca 01       	movw	r24, r20
    190a:	61 e0       	ldi	r22, 0x01	; 1
    190c:	0e 94 86 04 	call	0x90c	; 0x90c <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    1910:	c0 ff       	sbrs	r28, 0
    1912:	05 c0       	rjmp	.+10     	; 0x191e <set_ampGain+0x2a>
    1914:	80 e4       	ldi	r24, 0x40	; 64
    1916:	e0 e0       	ldi	r30, 0x00	; 0
    1918:	f6 e0       	ldi	r31, 0x06	; 6
    191a:	85 83       	std	Z+5, r24	; 0x05
    191c:	04 c0       	rjmp	.+8      	; 0x1926 <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
    191e:	80 e4       	ldi	r24, 0x40	; 64
    1920:	e0 e0       	ldi	r30, 0x00	; 0
    1922:	f6 e0       	ldi	r31, 0x06	; 6
    1924:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    1926:	c1 ff       	sbrs	r28, 1
    1928:	05 c0       	rjmp	.+10     	; 0x1934 <set_ampGain+0x40>
    192a:	82 e0       	ldi	r24, 0x02	; 2
    192c:	e0 e2       	ldi	r30, 0x20	; 32
    192e:	f6 e0       	ldi	r31, 0x06	; 6
    1930:	85 83       	std	Z+5, r24	; 0x05
    1932:	04 c0       	rjmp	.+8      	; 0x193c <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
    1934:	82 e0       	ldi	r24, 0x02	; 2
    1936:	e0 e2       	ldi	r30, 0x20	; 32
    1938:	f6 e0       	ldi	r31, 0x06	; 6
    193a:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    193c:	c2 ff       	sbrs	r28, 2
    193e:	05 c0       	rjmp	.+10     	; 0x194a <set_ampGain+0x56>
    1940:	84 e0       	ldi	r24, 0x04	; 4
    1942:	e0 e2       	ldi	r30, 0x20	; 32
    1944:	f6 e0       	ldi	r31, 0x06	; 6
    1946:	85 83       	std	Z+5, r24	; 0x05
    1948:	04 c0       	rjmp	.+8      	; 0x1952 <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
    194a:	84 e0       	ldi	r24, 0x04	; 4
    194c:	e0 e2       	ldi	r30, 0x20	; 32
    194e:	f6 e0       	ldi	r31, 0x06	; 6
    1950:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1952:	5a e0       	ldi	r21, 0x0A	; 10
    1954:	5a 95       	dec	r21
    1956:	f1 f7       	brne	.-4      	; 0x1954 <set_ampGain+0x60>
    1958:	00 c0       	rjmp	.+0      	; 0x195a <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    195a:	8f ef       	ldi	r24, 0xFF	; 255
    195c:	61 e0       	ldi	r22, 0x01	; 1
    195e:	0e 94 dd 04 	call	0x9ba	; 0x9ba <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    1962:	cf 91       	pop	r28
    1964:	08 95       	ret

00001966 <enableADCMUX>:

void enableADCMUX(uint8_t on) {
	
	if(on) {
    1966:	88 23       	and	r24, r24
    1968:	31 f0       	breq	.+12     	; 0x1976 <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
    196a:	e0 e0       	ldi	r30, 0x00	; 0
    196c:	f6 e0       	ldi	r31, 0x06	; 6
    196e:	80 e2       	ldi	r24, 0x20	; 32
    1970:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
    1972:	85 83       	std	Z+5, r24	; 0x05
    1974:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
    1976:	e0 e0       	ldi	r30, 0x00	; 0
    1978:	f6 e0       	ldi	r31, 0x06	; 6
    197a:	80 e2       	ldi	r24, 0x20	; 32
    197c:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    197e:	82 83       	std	Z+2, r24	; 0x02
    1980:	08 95       	ret

00001982 <__vector_20>:
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
    1982:	1f 92       	push	r1
    1984:	0f 92       	push	r0
    1986:	0f b6       	in	r0, 0x3f	; 63
    1988:	0f 92       	push	r0
    198a:	0b b6       	in	r0, 0x3b	; 59
    198c:	0f 92       	push	r0
    198e:	11 24       	eor	r1, r1
    1990:	2f 93       	push	r18
    1992:	3f 93       	push	r19
    1994:	4f 93       	push	r20
    1996:	5f 93       	push	r21
    1998:	6f 93       	push	r22
    199a:	7f 93       	push	r23
    199c:	8f 93       	push	r24
    199e:	9f 93       	push	r25
    19a0:	af 93       	push	r26
    19a2:	bf 93       	push	r27
    19a4:	ef 93       	push	r30
    19a6:	ff 93       	push	r31

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    19a8:	e0 e4       	ldi	r30, 0x40	; 64
    19aa:	fa e0       	ldi	r31, 0x0A	; 10
    19ac:	80 81       	ld	r24, Z
    19ae:	80 7f       	andi	r24, 0xF0	; 240
    19b0:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    19b2:	a0 e0       	ldi	r26, 0x00	; 0
    19b4:	b8 e0       	ldi	r27, 0x08	; 8
    19b6:	8c 91       	ld	r24, X
    19b8:	80 7f       	andi	r24, 0xF0	; 240
    19ba:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    19bc:	a0 e0       	ldi	r26, 0x00	; 0
    19be:	b9 e0       	ldi	r27, 0x09	; 9
    19c0:	8c 91       	ld	r24, X
    19c2:	80 7f       	andi	r24, 0xF0	; 240
    19c4:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    19c6:	80 81       	ld	r24, Z
    19c8:	80 7f       	andi	r24, 0xF0	; 240
    19ca:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    19ce:	80 e0       	ldi	r24, 0x00	; 0
    19d0:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	SPIDisable();
    19d4:	0e 94 19 04 	call	0x832	; 0x832 <SPIDisable>
	enableADCMUX(FALSE);
    19d8:	80 e0       	ldi	r24, 0x00	; 0
    19da:	0e 94 b3 0c 	call	0x1966	; 0x1966 <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
    19de:	81 e0       	ldi	r24, 0x01	; 1
    19e0:	80 93 ab 50 	sts	0x50AB, r24
	DataAvailable = 1;
    19e4:	80 93 4c 3e 	sts	0x3E4C, r24
}
    19e8:	ff 91       	pop	r31
    19ea:	ef 91       	pop	r30
    19ec:	bf 91       	pop	r27
    19ee:	af 91       	pop	r26
    19f0:	9f 91       	pop	r25
    19f2:	8f 91       	pop	r24
    19f4:	7f 91       	pop	r23
    19f6:	6f 91       	pop	r22
    19f8:	5f 91       	pop	r21
    19fa:	4f 91       	pop	r20
    19fc:	3f 91       	pop	r19
    19fe:	2f 91       	pop	r18
    1a00:	0f 90       	pop	r0
    1a02:	0b be       	out	0x3b, r0	; 59
    1a04:	0f 90       	pop	r0
    1a06:	0f be       	out	0x3f, r0	; 63
    1a08:	0f 90       	pop	r0
    1a0a:	1f 90       	pop	r1
    1a0c:	18 95       	reti

00001a0e <ADC_Stop_Sampling>:

//turns off ADC timers/counters and spi bus 
void ADC_Stop_Sampling(){
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1a0e:	e0 e4       	ldi	r30, 0x40	; 64
    1a10:	fa e0       	ldi	r31, 0x0A	; 10
    1a12:	80 81       	ld	r24, Z
    1a14:	80 7f       	andi	r24, 0xF0	; 240
    1a16:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1a18:	a0 e0       	ldi	r26, 0x00	; 0
    1a1a:	b8 e0       	ldi	r27, 0x08	; 8
    1a1c:	8c 91       	ld	r24, X
    1a1e:	80 7f       	andi	r24, 0xF0	; 240
    1a20:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1a22:	a0 e0       	ldi	r26, 0x00	; 0
    1a24:	b9 e0       	ldi	r27, 0x09	; 9
    1a26:	8c 91       	ld	r24, X
    1a28:	80 7f       	andi	r24, 0xF0	; 240
    1a2a:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1a2c:	80 81       	ld	r24, Z
    1a2e:	80 7f       	andi	r24, 0xF0	; 240
    1a30:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    1a34:	80 e0       	ldi	r24, 0x00	; 0
    1a36:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	SPIDisable();
    1a3a:	0e 94 19 04 	call	0x832	; 0x832 <SPIDisable>
	enableADCMUX(FALSE);
    1a3e:	80 e0       	ldi	r24, 0x00	; 0
    1a40:	0e 94 b3 0c 	call	0x1966	; 0x1966 <enableADCMUX>
	ADC_Sampling_Finished = 1;
    1a44:	81 e0       	ldi	r24, 0x01	; 1
    1a46:	80 93 ab 50 	sts	0x50AB, r24
	DataAvailable = 1;
    1a4a:	80 93 4c 3e 	sts	0x3E4C, r24
}
    1a4e:	08 95       	ret

00001a50 <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
    1a50:	cf 93       	push	r28
    1a52:	df 93       	push	r29
    1a54:	0f 92       	push	r0
    1a56:	0f 92       	push	r0
    1a58:	cd b7       	in	r28, 0x3d	; 61
    1a5a:	de b7       	in	r29, 0x3e	; 62
	
	if(ADC_Sampling_Finished){
    1a5c:	80 91 ab 50 	lds	r24, 0x50AB
    1a60:	88 23       	and	r24, r24
    1a62:	89 f0       	breq	.+34     	; 0x1a86 <ADC_Get_Num_Samples+0x36>
		volatile uint16_t count;
		count = TCC1.CNT;
    1a64:	e0 e4       	ldi	r30, 0x40	; 64
    1a66:	f8 e0       	ldi	r31, 0x08	; 8
    1a68:	80 a1       	lds	r24, 0x40
    1a6a:	91 a1       	lds	r25, 0x41
    1a6c:	89 83       	std	Y+1, r24	; 0x01
    1a6e:	9a 83       	std	Y+2, r25	; 0x02
		if(count == 0) count = TCC1.PER;
    1a70:	89 81       	ldd	r24, Y+1	; 0x01
    1a72:	9a 81       	ldd	r25, Y+2	; 0x02
    1a74:	00 97       	sbiw	r24, 0x00	; 0
    1a76:	21 f4       	brne	.+8      	; 0x1a80 <ADC_Get_Num_Samples+0x30>
    1a78:	86 a1       	lds	r24, 0x46
    1a7a:	97 a1       	lds	r25, 0x47
    1a7c:	89 83       	std	Y+1, r24	; 0x01
    1a7e:	9a 83       	std	Y+2, r25	; 0x02
		return count;
    1a80:	89 81       	ldd	r24, Y+1	; 0x01
    1a82:	9a 81       	ldd	r25, Y+2	; 0x02
    1a84:	02 c0       	rjmp	.+4      	; 0x1a8a <ADC_Get_Num_Samples+0x3a>
	}
	else return 0;		
    1a86:	80 e0       	ldi	r24, 0x00	; 0
    1a88:	90 e0       	ldi	r25, 0x00	; 0
}
    1a8a:	0f 90       	pop	r0
    1a8c:	0f 90       	pop	r0
    1a8e:	df 91       	pop	r29
    1a90:	cf 91       	pop	r28
    1a92:	08 95       	ret

00001a94 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    1a94:	e0 ea       	ldi	r30, 0xA0	; 160
    1a96:	f6 e0       	ldi	r31, 0x06	; 6
    1a98:	13 86       	std	Z+11, r1	; 0x0b
}
    1a9a:	08 95       	ret

00001a9c <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    1a9c:	81 e0       	ldi	r24, 0x01	; 1
    1a9e:	e0 ea       	ldi	r30, 0xA0	; 160
    1aa0:	f6 e0       	ldi	r31, 0x06	; 6
    1aa2:	83 87       	std	Z+11, r24	; 0x0b
}	
    1aa4:	08 95       	ret

00001aa6 <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    1aa6:	1f 92       	push	r1
    1aa8:	0f 92       	push	r0
    1aaa:	0f b6       	in	r0, 0x3f	; 63
    1aac:	0f 92       	push	r0
    1aae:	0b b6       	in	r0, 0x3b	; 59
    1ab0:	0f 92       	push	r0
    1ab2:	11 24       	eor	r1, r1
    1ab4:	6f 92       	push	r6
    1ab6:	7f 92       	push	r7
    1ab8:	8f 92       	push	r8
    1aba:	9f 92       	push	r9
    1abc:	af 92       	push	r10
    1abe:	bf 92       	push	r11
    1ac0:	cf 92       	push	r12
    1ac2:	df 92       	push	r13
    1ac4:	ef 92       	push	r14
    1ac6:	ff 92       	push	r15
    1ac8:	0f 93       	push	r16
    1aca:	1f 93       	push	r17
    1acc:	2f 93       	push	r18
    1ace:	3f 93       	push	r19
    1ad0:	4f 93       	push	r20
    1ad2:	5f 93       	push	r21
    1ad4:	6f 93       	push	r22
    1ad6:	7f 93       	push	r23
    1ad8:	8f 93       	push	r24
    1ada:	9f 93       	push	r25
    1adc:	af 93       	push	r26
    1ade:	bf 93       	push	r27
    1ae0:	ef 93       	push	r30
    1ae2:	ff 93       	push	r31
    1ae4:	cf 93       	push	r28
    1ae6:	df 93       	push	r29
    1ae8:	cd b7       	in	r28, 0x3d	; 61
    1aea:	de b7       	in	r29, 0x3e	; 62
    1aec:	2c 97       	sbiw	r28, 0x0c	; 12
    1aee:	cd bf       	out	0x3d, r28	; 61
    1af0:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	volatile int64_t var;
	if (discardCount < ADC_DISCARD) {
    1af2:	80 91 61 40 	lds	r24, 0x4061
    1af6:	88 23       	and	r24, r24
    1af8:	8c f0       	brlt	.+34     	; 0x1b1c <__vector_104+0x76>
		discardCount++;
    1afa:	80 91 61 40 	lds	r24, 0x4061
    1afe:	8f 5f       	subi	r24, 0xFF	; 255
    1b00:	80 93 61 40 	sts	0x4061, r24
		if(discardCount == ADC_DISCARD){
    1b04:	80 91 61 40 	lds	r24, 0x4061
    1b08:	80 38       	cpi	r24, 0x80	; 128
    1b0a:	09 f0       	breq	.+2      	; 0x1b0e <__vector_104+0x68>
    1b0c:	e9 c0       	rjmp	.+466    	; 0x1ce0 <__vector_104+0x23a>
			//set event system to update counter of number of samples every sample event from now on
			TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    1b0e:	e0 e4       	ldi	r30, 0x40	; 64
    1b10:	f8 e0       	ldi	r31, 0x08	; 8
    1b12:	80 81       	ld	r24, Z
    1b14:	80 7f       	andi	r24, 0xF0	; 240
    1b16:	89 60       	ori	r24, 0x09	; 9
    1b18:	80 83       	st	Z, r24
    1b1a:	e2 c0       	rjmp	.+452    	; 0x1ce0 <__vector_104+0x23a>
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    1b1c:	81 e0       	ldi	r24, 0x01	; 1
    1b1e:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1b22:	82 e0       	ldi	r24, 0x02	; 2
    1b24:	e0 ea       	ldi	r30, 0xA0	; 160
    1b26:	f6 e0       	ldi	r31, 0x06	; 6
    1b28:	86 83       	std	Z+6, r24	; 0x06
    1b2a:	80 e0       	ldi	r24, 0x00	; 0
    1b2c:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1b2e:	e0 ec       	ldi	r30, 0xC0	; 192
    1b30:	f8 e0       	ldi	r31, 0x08	; 8
    1b32:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
    1b34:	25 e2       	ldi	r18, 0x25	; 37
    1b36:	3e e3       	ldi	r19, 0x3E	; 62
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1b38:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1b3a:	42 81       	ldd	r20, Z+2	; 0x02
    1b3c:	44 23       	and	r20, r20
    1b3e:	ec f7       	brge	.-6      	; 0x1b3a <__vector_104+0x94>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1b40:	43 81       	ldd	r20, Z+3	; 0x03
    1b42:	d9 01       	movw	r26, r18
    1b44:	a8 0f       	add	r26, r24
    1b46:	b9 1f       	adc	r27, r25
    1b48:	4c 93       	st	X, r20
    1b4a:	01 96       	adiw	r24, 0x01	; 1
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1b4c:	83 30       	cpi	r24, 0x03	; 3
    1b4e:	91 05       	cpc	r25, r1
    1b50:	99 f7       	brne	.-26     	; 0x1b38 <__vector_104+0x92>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1b52:	82 e0       	ldi	r24, 0x02	; 2
    1b54:	e0 ea       	ldi	r30, 0xA0	; 160
    1b56:	f6 e0       	ldi	r31, 0x06	; 6
    1b58:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
    1b5a:	80 e0       	ldi	r24, 0x00	; 0
    1b5c:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1b60:	80 91 25 3e 	lds	r24, 0x3E25
    1b64:	88 23       	and	r24, r24
    1b66:	1c f4       	brge	.+6      	; 0x1b6e <__vector_104+0xc8>
    1b68:	8f ef       	ldi	r24, 0xFF	; 255
    1b6a:	8c 83       	std	Y+4, r24	; 0x04
    1b6c:	01 c0       	rjmp	.+2      	; 0x1b70 <__vector_104+0xca>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1b6e:	1c 82       	std	Y+4, r1	; 0x04
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    1b70:	80 91 25 3e 	lds	r24, 0x3E25
    1b74:	8b 83       	std	Y+3, r24	; 0x03
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    1b76:	80 91 26 3e 	lds	r24, 0x3E26
    1b7a:	8a 83       	std	Y+2, r24	; 0x02
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    1b7c:	80 91 27 3e 	lds	r24, 0x3E27
    1b80:	89 83       	std	Y+1, r24	; 0x01
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    1b82:	89 81       	ldd	r24, Y+1	; 0x01
    1b84:	9a 81       	ldd	r25, Y+2	; 0x02
    1b86:	ab 81       	ldd	r26, Y+3	; 0x03
    1b88:	bc 81       	ldd	r27, Y+4	; 0x04
    1b8a:	ac 01       	movw	r20, r24
    1b8c:	bd 01       	movw	r22, r26
    1b8e:	77 0f       	add	r23, r23
    1b90:	44 0b       	sbc	r20, r20
    1b92:	54 2f       	mov	r21, r20
    1b94:	ba 01       	movw	r22, r20
    1b96:	8d 83       	std	Y+5, r24	; 0x05
    1b98:	9e 83       	std	Y+6, r25	; 0x06
    1b9a:	af 83       	std	Y+7, r26	; 0x07
    1b9c:	b8 87       	std	Y+8, r27	; 0x08
    1b9e:	49 87       	std	Y+9, r20	; 0x09
    1ba0:	4a 87       	std	Y+10, r20	; 0x0a
    1ba2:	4b 87       	std	Y+11, r20	; 0x0b
    1ba4:	4c 87       	std	Y+12, r20	; 0x0c
		ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1ba6:	60 91 6a 50 	lds	r22, 0x506A
    1baa:	70 91 6b 50 	lds	r23, 0x506B
    1bae:	80 91 6c 50 	lds	r24, 0x506C
    1bb2:	90 91 6d 50 	lds	r25, 0x506D
    1bb6:	8d 80       	ldd	r8, Y+5	; 0x05
    1bb8:	1e 81       	ldd	r17, Y+6	; 0x06
    1bba:	0f 81       	ldd	r16, Y+7	; 0x07
    1bbc:	f8 84       	ldd	r15, Y+8	; 0x08
    1bbe:	e9 84       	ldd	r14, Y+9	; 0x09
    1bc0:	da 84       	ldd	r13, Y+10	; 0x0a
    1bc2:	cb 84       	ldd	r12, Y+11	; 0x0b
    1bc4:	bc 84       	ldd	r11, Y+12	; 0x0c
    1bc6:	20 91 ac 50 	lds	r18, 0x50AC
    1bca:	30 91 ad 50 	lds	r19, 0x50AD
    1bce:	40 e0       	ldi	r20, 0x00	; 0
    1bd0:	50 e0       	ldi	r21, 0x00	; 0
    1bd2:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    1bd6:	66 0f       	add	r22, r22
    1bd8:	77 1f       	adc	r23, r23
    1bda:	66 0f       	add	r22, r22
    1bdc:	77 1f       	adc	r23, r23
    1bde:	80 91 68 50 	lds	r24, 0x5068
    1be2:	90 91 69 50 	lds	r25, 0x5069
    1be6:	3c 01       	movw	r6, r24
    1be8:	66 0e       	add	r6, r22
    1bea:	77 1e       	adc	r7, r23
    1bec:	28 2d       	mov	r18, r8
    1bee:	31 2f       	mov	r19, r17
    1bf0:	40 2f       	mov	r20, r16
    1bf2:	5f 2d       	mov	r21, r15
    1bf4:	6e 2d       	mov	r22, r14
    1bf6:	7d 2d       	mov	r23, r13
    1bf8:	8c 2d       	mov	r24, r12
    1bfa:	9b 2d       	mov	r25, r11
    1bfc:	0f 2e       	mov	r0, r31
    1bfe:	f0 ea       	ldi	r31, 0xA0	; 160
    1c00:	af 2e       	mov	r10, r31
    1c02:	f0 2d       	mov	r31, r0
    1c04:	0f 2e       	mov	r0, r31
    1c06:	f5 e2       	ldi	r31, 0x25	; 37
    1c08:	bf 2e       	mov	r11, r31
    1c0a:	f0 2d       	mov	r31, r0
    1c0c:	0f 2e       	mov	r0, r31
    1c0e:	f6 e2       	ldi	r31, 0x26	; 38
    1c10:	cf 2e       	mov	r12, r31
    1c12:	f0 2d       	mov	r31, r0
    1c14:	dd 24       	eor	r13, r13
    1c16:	ee 24       	eor	r14, r14
    1c18:	ff 24       	eor	r15, r15
    1c1a:	00 e0       	ldi	r16, 0x00	; 0
    1c1c:	10 e0       	ldi	r17, 0x00	; 0
    1c1e:	0e 94 68 2e 	call	0x5cd0	; 0x5cd0 <__muldi3>
    1c22:	aa 24       	eor	r10, r10
    1c24:	aa 94       	dec	r10
    1c26:	bb 24       	eor	r11, r11
    1c28:	ba 94       	dec	r11
    1c2a:	0f 2e       	mov	r0, r31
    1c2c:	ff e7       	ldi	r31, 0x7F	; 127
    1c2e:	cf 2e       	mov	r12, r31
    1c30:	f0 2d       	mov	r31, r0
    1c32:	0e 94 17 30 	call	0x602e	; 0x602e <__divdi3>
    1c36:	01 e0       	ldi	r16, 0x01	; 1
    1c38:	0e 94 3b 2f 	call	0x5e76	; 0x5e76 <__ashldi3>
    1c3c:	0f 2e       	mov	r0, r31
    1c3e:	f3 e0       	ldi	r31, 0x03	; 3
    1c40:	af 2e       	mov	r10, r31
    1c42:	f0 2d       	mov	r31, r0
    1c44:	bb 24       	eor	r11, r11
    1c46:	cc 24       	eor	r12, r12
    1c48:	00 e0       	ldi	r16, 0x00	; 0
    1c4a:	0e 94 17 30 	call	0x602e	; 0x602e <__divdi3>
    1c4e:	82 2e       	mov	r8, r18
    1c50:	93 2e       	mov	r9, r19
    1c52:	a4 2e       	mov	r10, r20
    1c54:	b5 2e       	mov	r11, r21
    1c56:	b0 94       	com	r11
    1c58:	a0 94       	com	r10
    1c5a:	90 94       	com	r9
    1c5c:	80 94       	com	r8
    1c5e:	81 1c       	adc	r8, r1
    1c60:	91 1c       	adc	r9, r1
    1c62:	a1 1c       	adc	r10, r1
    1c64:	b1 1c       	adc	r11, r1
    1c66:	f3 01       	movw	r30, r6
    1c68:	80 82       	st	Z, r8
    1c6a:	91 82       	std	Z+1, r9	; 0x01
    1c6c:	a2 82       	std	Z+2, r10	; 0x02
    1c6e:	b3 82       	std	Z+3, r11	; 0x03
		if(write_to_FRAM){
    1c70:	80 91 4d 40 	lds	r24, 0x404D
    1c74:	88 23       	and	r24, r24
    1c76:	09 f1       	breq	.+66     	; 0x1cba <__vector_104+0x214>
			writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    1c78:	60 91 6a 50 	lds	r22, 0x506A
    1c7c:	70 91 6b 50 	lds	r23, 0x506B
    1c80:	80 91 6c 50 	lds	r24, 0x506C
    1c84:	90 91 6d 50 	lds	r25, 0x506D
    1c88:	20 91 ac 50 	lds	r18, 0x50AC
    1c8c:	30 91 ad 50 	lds	r19, 0x50AD
    1c90:	40 e0       	ldi	r20, 0x00	; 0
    1c92:	50 e0       	ldi	r21, 0x00	; 0
    1c94:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    1c98:	dc 01       	movw	r26, r24
    1c9a:	cb 01       	movw	r24, r22
    1c9c:	9c 01       	movw	r18, r24
    1c9e:	22 0f       	add	r18, r18
    1ca0:	33 1f       	adc	r19, r19
    1ca2:	22 0f       	add	r18, r18
    1ca4:	33 1f       	adc	r19, r19
    1ca6:	80 91 68 50 	lds	r24, 0x5068
    1caa:	90 91 69 50 	lds	r25, 0x5069
    1cae:	82 0f       	add	r24, r18
    1cb0:	93 1f       	adc	r25, r19
    1cb2:	64 e0       	ldi	r22, 0x04	; 4
    1cb4:	70 e0       	ldi	r23, 0x00	; 0
    1cb6:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
		}
		sampleCount++;
    1cba:	80 91 6a 50 	lds	r24, 0x506A
    1cbe:	90 91 6b 50 	lds	r25, 0x506B
    1cc2:	a0 91 6c 50 	lds	r26, 0x506C
    1cc6:	b0 91 6d 50 	lds	r27, 0x506D
    1cca:	01 96       	adiw	r24, 0x01	; 1
    1ccc:	a1 1d       	adc	r26, r1
    1cce:	b1 1d       	adc	r27, r1
    1cd0:	80 93 6a 50 	sts	0x506A, r24
    1cd4:	90 93 6b 50 	sts	0x506B, r25
    1cd8:	a0 93 6c 50 	sts	0x506C, r26
    1cdc:	b0 93 6d 50 	sts	0x506D, r27
	}
}
    1ce0:	2c 96       	adiw	r28, 0x0c	; 12
    1ce2:	cd bf       	out	0x3d, r28	; 61
    1ce4:	de bf       	out	0x3e, r29	; 62
    1ce6:	df 91       	pop	r29
    1ce8:	cf 91       	pop	r28
    1cea:	ff 91       	pop	r31
    1cec:	ef 91       	pop	r30
    1cee:	bf 91       	pop	r27
    1cf0:	af 91       	pop	r26
    1cf2:	9f 91       	pop	r25
    1cf4:	8f 91       	pop	r24
    1cf6:	7f 91       	pop	r23
    1cf8:	6f 91       	pop	r22
    1cfa:	5f 91       	pop	r21
    1cfc:	4f 91       	pop	r20
    1cfe:	3f 91       	pop	r19
    1d00:	2f 91       	pop	r18
    1d02:	1f 91       	pop	r17
    1d04:	0f 91       	pop	r16
    1d06:	ff 90       	pop	r15
    1d08:	ef 90       	pop	r14
    1d0a:	df 90       	pop	r13
    1d0c:	cf 90       	pop	r12
    1d0e:	bf 90       	pop	r11
    1d10:	af 90       	pop	r10
    1d12:	9f 90       	pop	r9
    1d14:	8f 90       	pop	r8
    1d16:	7f 90       	pop	r7
    1d18:	6f 90       	pop	r6
    1d1a:	0f 90       	pop	r0
    1d1c:	0b be       	out	0x3b, r0	; 59
    1d1e:	0f 90       	pop	r0
    1d20:	0f be       	out	0x3f, r0	; 63
    1d22:	0f 90       	pop	r0
    1d24:	1f 90       	pop	r1
    1d26:	18 95       	reti

00001d28 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
    1d28:	88 23       	and	r24, r24
    1d2a:	49 f0       	breq	.+18     	; 0x1d3e <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1d2c:	80 e2       	ldi	r24, 0x20	; 32
    1d2e:	60 e0       	ldi	r22, 0x00	; 0
    1d30:	0e 94 8a 05 	call	0xb14	; 0xb14 <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1d34:	80 e2       	ldi	r24, 0x20	; 32
    1d36:	60 e0       	ldi	r22, 0x00	; 0
    1d38:	0e 94 dd 04 	call	0x9ba	; 0x9ba <PortEx_OUTSET>
    1d3c:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1d3e:	80 e2       	ldi	r24, 0x20	; 32
    1d40:	60 e0       	ldi	r22, 0x00	; 0
    1d42:	0e 94 32 05 	call	0xa64	; 0xa64 <PortEx_DIRCLR>
    1d46:	08 95       	ret

00001d48 <__vector_14>:
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1d48:	1f 92       	push	r1
    1d4a:	0f 92       	push	r0
    1d4c:	0f b6       	in	r0, 0x3f	; 63
    1d4e:	0f 92       	push	r0
    1d50:	0b b6       	in	r0, 0x3b	; 59
    1d52:	0f 92       	push	r0
    1d54:	11 24       	eor	r1, r1
    1d56:	6f 92       	push	r6
    1d58:	7f 92       	push	r7
    1d5a:	8f 92       	push	r8
    1d5c:	9f 92       	push	r9
    1d5e:	af 92       	push	r10
    1d60:	bf 92       	push	r11
    1d62:	cf 92       	push	r12
    1d64:	df 92       	push	r13
    1d66:	ef 92       	push	r14
    1d68:	ff 92       	push	r15
    1d6a:	0f 93       	push	r16
    1d6c:	1f 93       	push	r17
    1d6e:	2f 93       	push	r18
    1d70:	3f 93       	push	r19
    1d72:	4f 93       	push	r20
    1d74:	5f 93       	push	r21
    1d76:	6f 93       	push	r22
    1d78:	7f 93       	push	r23
    1d7a:	8f 93       	push	r24
    1d7c:	9f 93       	push	r25
    1d7e:	af 93       	push	r26
    1d80:	bf 93       	push	r27
    1d82:	ef 93       	push	r30
    1d84:	ff 93       	push	r31
    1d86:	cf 93       	push	r28
    1d88:	df 93       	push	r29
    1d8a:	cd b7       	in	r28, 0x3d	; 61
    1d8c:	de b7       	in	r29, 0x3e	; 62
    1d8e:	2c 97       	sbiw	r28, 0x0c	; 12
    1d90:	cd bf       	out	0x3d, r28	; 61
    1d92:	de bf       	out	0x3e, r29	; 62
	volatile int64_t sum = 0;
    1d94:	19 82       	std	Y+1, r1	; 0x01
    1d96:	1a 82       	std	Y+2, r1	; 0x02
    1d98:	1b 82       	std	Y+3, r1	; 0x03
    1d9a:	1c 82       	std	Y+4, r1	; 0x04
    1d9c:	1d 82       	std	Y+5, r1	; 0x05
    1d9e:	1e 82       	std	Y+6, r1	; 0x06
    1da0:	1f 82       	std	Y+7, r1	; 0x07
    1da2:	18 86       	std	Y+8, r1	; 0x08
    1da4:	80 e0       	ldi	r24, 0x00	; 0
    1da6:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1da8:	25 e2       	ldi	r18, 0x25	; 37
    1daa:	3e e3       	ldi	r19, 0x3E	; 62
    1dac:	88 24       	eor	r8, r8
    1dae:	8a 94       	dec	r8
    1db0:	ac 01       	movw	r20, r24
    1db2:	f9 01       	movw	r30, r18
    1db4:	e8 0f       	add	r30, r24
    1db6:	f9 1f       	adc	r31, r25
    1db8:	60 81       	ld	r22, Z
    1dba:	66 23       	and	r22, r22
    1dbc:	14 f4       	brge	.+4      	; 0x1dc2 <__vector_14+0x7a>
    1dbe:	8c 86       	std	Y+12, r8	; 0x0c
    1dc0:	01 c0       	rjmp	.+2      	; 0x1dc4 <__vector_14+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1dc2:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1dc4:	42 0f       	add	r20, r18
    1dc6:	53 1f       	adc	r21, r19
    1dc8:	fa 01       	movw	r30, r20
    1dca:	40 81       	ld	r20, Z
    1dcc:	4b 87       	std	Y+11, r20	; 0x0b
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1dce:	fc 01       	movw	r30, r24
    1dd0:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1dd2:	e2 0f       	add	r30, r18
    1dd4:	f3 1f       	adc	r31, r19
    1dd6:	40 81       	ld	r20, Z
    1dd8:	4a 87       	std	Y+10, r20	; 0x0a
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1dda:	fc 01       	movw	r30, r24
    1ddc:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1dde:	e2 0f       	add	r30, r18
    1de0:	f3 1f       	adc	r31, r19
    1de2:	40 81       	ld	r20, Z
    1de4:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    1de6:	49 85       	ldd	r20, Y+9	; 0x09
    1de8:	5a 85       	ldd	r21, Y+10	; 0x0a
    1dea:	6b 85       	ldd	r22, Y+11	; 0x0b
    1dec:	7c 85       	ldd	r23, Y+12	; 0x0c
    1dee:	a9 80       	ldd	r10, Y+1	; 0x01
    1df0:	ba 80       	ldd	r11, Y+2	; 0x02
    1df2:	cb 80       	ldd	r12, Y+3	; 0x03
    1df4:	dc 80       	ldd	r13, Y+4	; 0x04
    1df6:	ed 80       	ldd	r14, Y+5	; 0x05
    1df8:	fe 80       	ldd	r15, Y+6	; 0x06
    1dfa:	0f 81       	ldd	r16, Y+7	; 0x07
    1dfc:	18 85       	ldd	r17, Y+8	; 0x08
    1dfe:	b4 2f       	mov	r27, r20
    1e00:	a5 2f       	mov	r26, r21
    1e02:	f6 2f       	mov	r31, r22
    1e04:	e7 2f       	mov	r30, r23
    1e06:	77 0f       	add	r23, r23
    1e08:	44 0b       	sbc	r20, r20
    1e0a:	54 2f       	mov	r21, r20
    1e0c:	ba 01       	movw	r22, r20
    1e0e:	64 2e       	mov	r6, r20
    1e10:	74 2e       	mov	r7, r20
    1e12:	94 2e       	mov	r9, r20
    1e14:	ab 0e       	add	r10, r27
    1e16:	61 e0       	ldi	r22, 0x01	; 1
    1e18:	ab 16       	cp	r10, r27
    1e1a:	08 f0       	brcs	.+2      	; 0x1e1e <__vector_14+0xd6>
    1e1c:	60 e0       	ldi	r22, 0x00	; 0
    1e1e:	ba 0e       	add	r11, r26
    1e20:	51 e0       	ldi	r21, 0x01	; 1
    1e22:	ba 16       	cp	r11, r26
    1e24:	08 f0       	brcs	.+2      	; 0x1e28 <__vector_14+0xe0>
    1e26:	50 e0       	ldi	r21, 0x00	; 0
    1e28:	a6 2f       	mov	r26, r22
    1e2a:	ab 0d       	add	r26, r11
    1e2c:	61 e0       	ldi	r22, 0x01	; 1
    1e2e:	ab 15       	cp	r26, r11
    1e30:	08 f0       	brcs	.+2      	; 0x1e34 <__vector_14+0xec>
    1e32:	60 e0       	ldi	r22, 0x00	; 0
    1e34:	56 2b       	or	r21, r22
    1e36:	cf 0e       	add	r12, r31
    1e38:	61 e0       	ldi	r22, 0x01	; 1
    1e3a:	cf 16       	cp	r12, r31
    1e3c:	08 f0       	brcs	.+2      	; 0x1e40 <__vector_14+0xf8>
    1e3e:	60 e0       	ldi	r22, 0x00	; 0
    1e40:	f5 2f       	mov	r31, r21
    1e42:	fc 0d       	add	r31, r12
    1e44:	51 e0       	ldi	r21, 0x01	; 1
    1e46:	fc 15       	cp	r31, r12
    1e48:	08 f0       	brcs	.+2      	; 0x1e4c <__vector_14+0x104>
    1e4a:	50 e0       	ldi	r21, 0x00	; 0
    1e4c:	65 2b       	or	r22, r21
    1e4e:	de 0e       	add	r13, r30
    1e50:	51 e0       	ldi	r21, 0x01	; 1
    1e52:	de 16       	cp	r13, r30
    1e54:	08 f0       	brcs	.+2      	; 0x1e58 <__vector_14+0x110>
    1e56:	50 e0       	ldi	r21, 0x00	; 0
    1e58:	e6 2f       	mov	r30, r22
    1e5a:	ed 0d       	add	r30, r13
    1e5c:	61 e0       	ldi	r22, 0x01	; 1
    1e5e:	ed 15       	cp	r30, r13
    1e60:	08 f0       	brcs	.+2      	; 0x1e64 <__vector_14+0x11c>
    1e62:	60 e0       	ldi	r22, 0x00	; 0
    1e64:	56 2b       	or	r21, r22
    1e66:	e6 0c       	add	r14, r6
    1e68:	71 e0       	ldi	r23, 0x01	; 1
    1e6a:	e6 14       	cp	r14, r6
    1e6c:	08 f0       	brcs	.+2      	; 0x1e70 <__vector_14+0x128>
    1e6e:	70 e0       	ldi	r23, 0x00	; 0
    1e70:	b5 2f       	mov	r27, r21
    1e72:	be 0d       	add	r27, r14
    1e74:	51 e0       	ldi	r21, 0x01	; 1
    1e76:	be 15       	cp	r27, r14
    1e78:	08 f0       	brcs	.+2      	; 0x1e7c <__vector_14+0x134>
    1e7a:	50 e0       	ldi	r21, 0x00	; 0
    1e7c:	75 2b       	or	r23, r21
    1e7e:	f7 0c       	add	r15, r7
    1e80:	61 e0       	ldi	r22, 0x01	; 1
    1e82:	f7 14       	cp	r15, r7
    1e84:	08 f0       	brcs	.+2      	; 0x1e88 <__vector_14+0x140>
    1e86:	60 e0       	ldi	r22, 0x00	; 0
    1e88:	7f 0d       	add	r23, r15
    1e8a:	51 e0       	ldi	r21, 0x01	; 1
    1e8c:	7f 15       	cp	r23, r15
    1e8e:	08 f0       	brcs	.+2      	; 0x1e92 <__vector_14+0x14a>
    1e90:	50 e0       	ldi	r21, 0x00	; 0
    1e92:	65 2b       	or	r22, r21
    1e94:	09 0d       	add	r16, r9
    1e96:	51 e0       	ldi	r21, 0x01	; 1
    1e98:	09 15       	cp	r16, r9
    1e9a:	08 f0       	brcs	.+2      	; 0x1e9e <__vector_14+0x156>
    1e9c:	50 e0       	ldi	r21, 0x00	; 0
    1e9e:	60 0f       	add	r22, r16
    1ea0:	ff 24       	eor	r15, r15
    1ea2:	f3 94       	inc	r15
    1ea4:	60 17       	cp	r22, r16
    1ea6:	08 f0       	brcs	.+2      	; 0x1eaa <__vector_14+0x162>
    1ea8:	ff 24       	eor	r15, r15
    1eaa:	5f 29       	or	r21, r15
    1eac:	41 0f       	add	r20, r17
    1eae:	54 0f       	add	r21, r20
    1eb0:	a9 82       	std	Y+1, r10	; 0x01
    1eb2:	aa 83       	std	Y+2, r26	; 0x02
    1eb4:	fb 83       	std	Y+3, r31	; 0x03
    1eb6:	ec 83       	std	Y+4, r30	; 0x04
    1eb8:	bd 83       	std	Y+5, r27	; 0x05
    1eba:	7e 83       	std	Y+6, r23	; 0x06
    1ebc:	6f 83       	std	Y+7, r22	; 0x07
    1ebe:	58 87       	std	Y+8, r21	; 0x08
    1ec0:	03 96       	adiw	r24, 0x03	; 3
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1ec2:	8c 30       	cpi	r24, 0x0C	; 12
    1ec4:	91 05       	cpc	r25, r1
    1ec6:	09 f0       	breq	.+2      	; 0x1eca <__vector_14+0x182>
    1ec8:	73 cf       	rjmp	.-282    	; 0x1db0 <__vector_14+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    1eca:	e9 80       	ldd	r14, Y+1	; 0x01
    1ecc:	fa 80       	ldd	r15, Y+2	; 0x02
    1ece:	0b 81       	ldd	r16, Y+3	; 0x03
    1ed0:	1c 81       	ldd	r17, Y+4	; 0x04
    1ed2:	bd 81       	ldd	r27, Y+5	; 0x05
    1ed4:	ae 81       	ldd	r26, Y+6	; 0x06
    1ed6:	ff 81       	ldd	r31, Y+7	; 0x07
    1ed8:	e8 85       	ldd	r30, Y+8	; 0x08
    1eda:	2e 2d       	mov	r18, r14
    1edc:	3f 2d       	mov	r19, r15
    1ede:	40 2f       	mov	r20, r16
    1ee0:	51 2f       	mov	r21, r17
    1ee2:	6b 2f       	mov	r22, r27
    1ee4:	7a 2f       	mov	r23, r26
    1ee6:	8f 2f       	mov	r24, r31
    1ee8:	9e 2f       	mov	r25, r30
    1eea:	ee 23       	and	r30, r30
    1eec:	0c f0       	brlt	.+2      	; 0x1ef0 <__vector_14+0x1a8>
    1eee:	4a c0       	rjmp	.+148    	; 0x1f84 <__vector_14+0x23c>
    1ef0:	93 e0       	ldi	r25, 0x03	; 3
    1ef2:	e9 0e       	add	r14, r25
    1ef4:	91 e0       	ldi	r25, 0x01	; 1
    1ef6:	e2 16       	cp	r14, r18
    1ef8:	08 f0       	brcs	.+2      	; 0x1efc <__vector_14+0x1b4>
    1efa:	90 e0       	ldi	r25, 0x00	; 0
    1efc:	21 e0       	ldi	r18, 0x01	; 1
    1efe:	f3 16       	cp	r15, r19
    1f00:	08 f0       	brcs	.+2      	; 0x1f04 <__vector_14+0x1bc>
    1f02:	20 e0       	ldi	r18, 0x00	; 0
    1f04:	39 2f       	mov	r19, r25
    1f06:	3f 0d       	add	r19, r15
    1f08:	91 e0       	ldi	r25, 0x01	; 1
    1f0a:	3f 15       	cp	r19, r15
    1f0c:	08 f0       	brcs	.+2      	; 0x1f10 <__vector_14+0x1c8>
    1f0e:	90 e0       	ldi	r25, 0x00	; 0
    1f10:	29 2b       	or	r18, r25
    1f12:	91 e0       	ldi	r25, 0x01	; 1
    1f14:	04 17       	cp	r16, r20
    1f16:	08 f0       	brcs	.+2      	; 0x1f1a <__vector_14+0x1d2>
    1f18:	90 e0       	ldi	r25, 0x00	; 0
    1f1a:	42 2f       	mov	r20, r18
    1f1c:	40 0f       	add	r20, r16
    1f1e:	21 e0       	ldi	r18, 0x01	; 1
    1f20:	40 17       	cp	r20, r16
    1f22:	08 f0       	brcs	.+2      	; 0x1f26 <__vector_14+0x1de>
    1f24:	20 e0       	ldi	r18, 0x00	; 0
    1f26:	92 2b       	or	r25, r18
    1f28:	21 e0       	ldi	r18, 0x01	; 1
    1f2a:	15 17       	cp	r17, r21
    1f2c:	08 f0       	brcs	.+2      	; 0x1f30 <__vector_14+0x1e8>
    1f2e:	20 e0       	ldi	r18, 0x00	; 0
    1f30:	59 2f       	mov	r21, r25
    1f32:	51 0f       	add	r21, r17
    1f34:	91 e0       	ldi	r25, 0x01	; 1
    1f36:	51 17       	cp	r21, r17
    1f38:	08 f0       	brcs	.+2      	; 0x1f3c <__vector_14+0x1f4>
    1f3a:	90 e0       	ldi	r25, 0x00	; 0
    1f3c:	29 2b       	or	r18, r25
    1f3e:	91 e0       	ldi	r25, 0x01	; 1
    1f40:	b6 17       	cp	r27, r22
    1f42:	08 f0       	brcs	.+2      	; 0x1f46 <__vector_14+0x1fe>
    1f44:	90 e0       	ldi	r25, 0x00	; 0
    1f46:	62 2f       	mov	r22, r18
    1f48:	6b 0f       	add	r22, r27
    1f4a:	21 e0       	ldi	r18, 0x01	; 1
    1f4c:	6b 17       	cp	r22, r27
    1f4e:	08 f0       	brcs	.+2      	; 0x1f52 <__vector_14+0x20a>
    1f50:	20 e0       	ldi	r18, 0x00	; 0
    1f52:	92 2b       	or	r25, r18
    1f54:	21 e0       	ldi	r18, 0x01	; 1
    1f56:	a7 17       	cp	r26, r23
    1f58:	08 f0       	brcs	.+2      	; 0x1f5c <__vector_14+0x214>
    1f5a:	20 e0       	ldi	r18, 0x00	; 0
    1f5c:	79 2f       	mov	r23, r25
    1f5e:	7a 0f       	add	r23, r26
    1f60:	91 e0       	ldi	r25, 0x01	; 1
    1f62:	7a 17       	cp	r23, r26
    1f64:	08 f0       	brcs	.+2      	; 0x1f68 <__vector_14+0x220>
    1f66:	90 e0       	ldi	r25, 0x00	; 0
    1f68:	29 2b       	or	r18, r25
    1f6a:	91 e0       	ldi	r25, 0x01	; 1
    1f6c:	f8 17       	cp	r31, r24
    1f6e:	08 f0       	brcs	.+2      	; 0x1f72 <__vector_14+0x22a>
    1f70:	90 e0       	ldi	r25, 0x00	; 0
    1f72:	82 2f       	mov	r24, r18
    1f74:	8f 0f       	add	r24, r31
    1f76:	21 e0       	ldi	r18, 0x01	; 1
    1f78:	8f 17       	cp	r24, r31
    1f7a:	08 f0       	brcs	.+2      	; 0x1f7e <__vector_14+0x236>
    1f7c:	20 e0       	ldi	r18, 0x00	; 0
    1f7e:	92 2b       	or	r25, r18
    1f80:	2e 2d       	mov	r18, r14
    1f82:	9e 0f       	add	r25, r30
    1f84:	02 e0       	ldi	r16, 0x02	; 2
    1f86:	0e 94 af 2f 	call	0x5f5e	; 0x5f5e <__ashrdi3>
    1f8a:	29 83       	std	Y+1, r18	; 0x01
    1f8c:	3a 83       	std	Y+2, r19	; 0x02
    1f8e:	4b 83       	std	Y+3, r20	; 0x03
    1f90:	5c 83       	std	Y+4, r21	; 0x04
    1f92:	6d 83       	std	Y+5, r22	; 0x05
    1f94:	7e 83       	std	Y+6, r23	; 0x06
    1f96:	8f 83       	std	Y+7, r24	; 0x07
    1f98:	98 87       	std	Y+8, r25	; 0x08
	ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1f9a:	60 91 6a 50 	lds	r22, 0x506A
    1f9e:	70 91 6b 50 	lds	r23, 0x506B
    1fa2:	80 91 6c 50 	lds	r24, 0x506C
    1fa6:	90 91 6d 50 	lds	r25, 0x506D
    1faa:	19 81       	ldd	r17, Y+1	; 0x01
    1fac:	0a 81       	ldd	r16, Y+2	; 0x02
    1fae:	fb 80       	ldd	r15, Y+3	; 0x03
    1fb0:	ec 80       	ldd	r14, Y+4	; 0x04
    1fb2:	dd 80       	ldd	r13, Y+5	; 0x05
    1fb4:	ce 80       	ldd	r12, Y+6	; 0x06
    1fb6:	bf 80       	ldd	r11, Y+7	; 0x07
    1fb8:	a8 84       	ldd	r10, Y+8	; 0x08
    1fba:	20 91 ac 50 	lds	r18, 0x50AC
    1fbe:	30 91 ad 50 	lds	r19, 0x50AD
    1fc2:	40 e0       	ldi	r20, 0x00	; 0
    1fc4:	50 e0       	ldi	r21, 0x00	; 0
    1fc6:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    1fca:	dc 01       	movw	r26, r24
    1fcc:	cb 01       	movw	r24, r22
    1fce:	88 0f       	add	r24, r24
    1fd0:	99 1f       	adc	r25, r25
    1fd2:	88 0f       	add	r24, r24
    1fd4:	99 1f       	adc	r25, r25
    1fd6:	80 90 68 50 	lds	r8, 0x5068
    1fda:	90 90 69 50 	lds	r9, 0x5069
    1fde:	88 0e       	add	r8, r24
    1fe0:	99 1e       	adc	r9, r25
    1fe2:	21 2f       	mov	r18, r17
    1fe4:	30 2f       	mov	r19, r16
    1fe6:	4f 2d       	mov	r20, r15
    1fe8:	5e 2d       	mov	r21, r14
    1fea:	6d 2d       	mov	r22, r13
    1fec:	7c 2d       	mov	r23, r12
    1fee:	8b 2d       	mov	r24, r11
    1ff0:	9a 2d       	mov	r25, r10
    1ff2:	0f 2e       	mov	r0, r31
    1ff4:	f0 ea       	ldi	r31, 0xA0	; 160
    1ff6:	af 2e       	mov	r10, r31
    1ff8:	f0 2d       	mov	r31, r0
    1ffa:	0f 2e       	mov	r0, r31
    1ffc:	f5 e2       	ldi	r31, 0x25	; 37
    1ffe:	bf 2e       	mov	r11, r31
    2000:	f0 2d       	mov	r31, r0
    2002:	0f 2e       	mov	r0, r31
    2004:	f6 e2       	ldi	r31, 0x26	; 38
    2006:	cf 2e       	mov	r12, r31
    2008:	f0 2d       	mov	r31, r0
    200a:	dd 24       	eor	r13, r13
    200c:	ee 24       	eor	r14, r14
    200e:	ff 24       	eor	r15, r15
    2010:	00 e0       	ldi	r16, 0x00	; 0
    2012:	10 e0       	ldi	r17, 0x00	; 0
    2014:	0e 94 68 2e 	call	0x5cd0	; 0x5cd0 <__muldi3>
    2018:	aa 24       	eor	r10, r10
    201a:	aa 94       	dec	r10
    201c:	bb 24       	eor	r11, r11
    201e:	ba 94       	dec	r11
    2020:	0f 2e       	mov	r0, r31
    2022:	ff e7       	ldi	r31, 0x7F	; 127
    2024:	cf 2e       	mov	r12, r31
    2026:	f0 2d       	mov	r31, r0
    2028:	0e 94 17 30 	call	0x602e	; 0x602e <__divdi3>
    202c:	01 e0       	ldi	r16, 0x01	; 1
    202e:	0e 94 3b 2f 	call	0x5e76	; 0x5e76 <__ashldi3>
    2032:	0f 2e       	mov	r0, r31
    2034:	f3 e0       	ldi	r31, 0x03	; 3
    2036:	af 2e       	mov	r10, r31
    2038:	f0 2d       	mov	r31, r0
    203a:	bb 24       	eor	r11, r11
    203c:	cc 24       	eor	r12, r12
    203e:	00 e0       	ldi	r16, 0x00	; 0
    2040:	0e 94 17 30 	call	0x602e	; 0x602e <__divdi3>
    2044:	f4 01       	movw	r30, r8
    2046:	20 83       	st	Z, r18
    2048:	31 83       	std	Z+1, r19	; 0x01
    204a:	42 83       	std	Z+2, r20	; 0x02
    204c:	53 83       	std	Z+3, r21	; 0x03
	if(write_to_FRAM){
    204e:	80 91 4d 40 	lds	r24, 0x404D
    2052:	88 23       	and	r24, r24
    2054:	09 f1       	breq	.+66     	; 0x2098 <__vector_14+0x350>
		writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    2056:	60 91 6a 50 	lds	r22, 0x506A
    205a:	70 91 6b 50 	lds	r23, 0x506B
    205e:	80 91 6c 50 	lds	r24, 0x506C
    2062:	90 91 6d 50 	lds	r25, 0x506D
    2066:	20 91 ac 50 	lds	r18, 0x50AC
    206a:	30 91 ad 50 	lds	r19, 0x50AD
    206e:	40 e0       	ldi	r20, 0x00	; 0
    2070:	50 e0       	ldi	r21, 0x00	; 0
    2072:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    2076:	dc 01       	movw	r26, r24
    2078:	cb 01       	movw	r24, r22
    207a:	9c 01       	movw	r18, r24
    207c:	22 0f       	add	r18, r18
    207e:	33 1f       	adc	r19, r19
    2080:	22 0f       	add	r18, r18
    2082:	33 1f       	adc	r19, r19
    2084:	80 91 68 50 	lds	r24, 0x5068
    2088:	90 91 69 50 	lds	r25, 0x5069
    208c:	82 0f       	add	r24, r18
    208e:	93 1f       	adc	r25, r19
    2090:	64 e0       	ldi	r22, 0x04	; 4
    2092:	70 e0       	ldi	r23, 0x00	; 0
    2094:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
	}
	sampleCount++;
    2098:	80 91 6a 50 	lds	r24, 0x506A
    209c:	90 91 6b 50 	lds	r25, 0x506B
    20a0:	a0 91 6c 50 	lds	r26, 0x506C
    20a4:	b0 91 6d 50 	lds	r27, 0x506D
    20a8:	01 96       	adiw	r24, 0x01	; 1
    20aa:	a1 1d       	adc	r26, r1
    20ac:	b1 1d       	adc	r27, r1
    20ae:	80 93 6a 50 	sts	0x506A, r24
    20b2:	90 93 6b 50 	sts	0x506B, r25
    20b6:	a0 93 6c 50 	sts	0x506C, r26
    20ba:	b0 93 6d 50 	sts	0x506D, r27

}
    20be:	2c 96       	adiw	r28, 0x0c	; 12
    20c0:	cd bf       	out	0x3d, r28	; 61
    20c2:	de bf       	out	0x3e, r29	; 62
    20c4:	df 91       	pop	r29
    20c6:	cf 91       	pop	r28
    20c8:	ff 91       	pop	r31
    20ca:	ef 91       	pop	r30
    20cc:	bf 91       	pop	r27
    20ce:	af 91       	pop	r26
    20d0:	9f 91       	pop	r25
    20d2:	8f 91       	pop	r24
    20d4:	7f 91       	pop	r23
    20d6:	6f 91       	pop	r22
    20d8:	5f 91       	pop	r21
    20da:	4f 91       	pop	r20
    20dc:	3f 91       	pop	r19
    20de:	2f 91       	pop	r18
    20e0:	1f 91       	pop	r17
    20e2:	0f 91       	pop	r16
    20e4:	ff 90       	pop	r15
    20e6:	ef 90       	pop	r14
    20e8:	df 90       	pop	r13
    20ea:	cf 90       	pop	r12
    20ec:	bf 90       	pop	r11
    20ee:	af 90       	pop	r10
    20f0:	9f 90       	pop	r9
    20f2:	8f 90       	pop	r8
    20f4:	7f 90       	pop	r7
    20f6:	6f 90       	pop	r6
    20f8:	0f 90       	pop	r0
    20fa:	0b be       	out	0x3b, r0	; 59
    20fc:	0f 90       	pop	r0
    20fe:	0f be       	out	0x3f, r0	; 63
    2100:	0f 90       	pop	r0
    2102:	1f 90       	pop	r1
    2104:	18 95       	reti

00002106 <__vector_77>:
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    2106:	1f 92       	push	r1
    2108:	0f 92       	push	r0
    210a:	0f b6       	in	r0, 0x3f	; 63
    210c:	0f 92       	push	r0
    210e:	0b b6       	in	r0, 0x3b	; 59
    2110:	0f 92       	push	r0
    2112:	11 24       	eor	r1, r1
    2114:	6f 92       	push	r6
    2116:	7f 92       	push	r7
    2118:	8f 92       	push	r8
    211a:	9f 92       	push	r9
    211c:	af 92       	push	r10
    211e:	bf 92       	push	r11
    2120:	cf 92       	push	r12
    2122:	df 92       	push	r13
    2124:	ef 92       	push	r14
    2126:	ff 92       	push	r15
    2128:	0f 93       	push	r16
    212a:	1f 93       	push	r17
    212c:	2f 93       	push	r18
    212e:	3f 93       	push	r19
    2130:	4f 93       	push	r20
    2132:	5f 93       	push	r21
    2134:	6f 93       	push	r22
    2136:	7f 93       	push	r23
    2138:	8f 93       	push	r24
    213a:	9f 93       	push	r25
    213c:	af 93       	push	r26
    213e:	bf 93       	push	r27
    2140:	ef 93       	push	r30
    2142:	ff 93       	push	r31
    2144:	cf 93       	push	r28
    2146:	df 93       	push	r29
    2148:	cd b7       	in	r28, 0x3d	; 61
    214a:	de b7       	in	r29, 0x3e	; 62
    214c:	2c 97       	sbiw	r28, 0x0c	; 12
    214e:	cd bf       	out	0x3d, r28	; 61
    2150:	de bf       	out	0x3e, r29	; 62

	volatile int64_t sum = 0;
    2152:	19 82       	std	Y+1, r1	; 0x01
    2154:	1a 82       	std	Y+2, r1	; 0x02
    2156:	1b 82       	std	Y+3, r1	; 0x03
    2158:	1c 82       	std	Y+4, r1	; 0x04
    215a:	1d 82       	std	Y+5, r1	; 0x05
    215c:	1e 82       	std	Y+6, r1	; 0x06
    215e:	1f 82       	std	Y+7, r1	; 0x07
    2160:	18 86       	std	Y+8, r1	; 0x08
    2162:	80 e0       	ldi	r24, 0x00	; 0
    2164:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2166:	25 e2       	ldi	r18, 0x25	; 37
    2168:	3e e3       	ldi	r19, 0x3E	; 62
    216a:	88 24       	eor	r8, r8
    216c:	8a 94       	dec	r8
    216e:	ac 01       	movw	r20, r24
    2170:	f9 01       	movw	r30, r18
    2172:	e8 0f       	add	r30, r24
    2174:	f9 1f       	adc	r31, r25
    2176:	60 81       	ld	r22, Z
    2178:	66 23       	and	r22, r22
    217a:	14 f4       	brge	.+4      	; 0x2180 <__vector_77+0x7a>
    217c:	8c 86       	std	Y+12, r8	; 0x0c
    217e:	01 c0       	rjmp	.+2      	; 0x2182 <__vector_77+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    2180:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2182:	42 0f       	add	r20, r18
    2184:	53 1f       	adc	r21, r19
    2186:	fa 01       	movw	r30, r20
    2188:	40 81       	ld	r20, Z
    218a:	4b 87       	std	Y+11, r20	; 0x0b
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    218c:	fc 01       	movw	r30, r24
    218e:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    2190:	e2 0f       	add	r30, r18
    2192:	f3 1f       	adc	r31, r19
    2194:	40 81       	ld	r20, Z
    2196:	4a 87       	std	Y+10, r20	; 0x0a
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    2198:	fc 01       	movw	r30, r24
    219a:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    219c:	e2 0f       	add	r30, r18
    219e:	f3 1f       	adc	r31, r19
    21a0:	40 81       	ld	r20, Z
    21a2:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    21a4:	49 85       	ldd	r20, Y+9	; 0x09
    21a6:	5a 85       	ldd	r21, Y+10	; 0x0a
    21a8:	6b 85       	ldd	r22, Y+11	; 0x0b
    21aa:	7c 85       	ldd	r23, Y+12	; 0x0c
    21ac:	a9 80       	ldd	r10, Y+1	; 0x01
    21ae:	ba 80       	ldd	r11, Y+2	; 0x02
    21b0:	cb 80       	ldd	r12, Y+3	; 0x03
    21b2:	dc 80       	ldd	r13, Y+4	; 0x04
    21b4:	ed 80       	ldd	r14, Y+5	; 0x05
    21b6:	fe 80       	ldd	r15, Y+6	; 0x06
    21b8:	0f 81       	ldd	r16, Y+7	; 0x07
    21ba:	18 85       	ldd	r17, Y+8	; 0x08
    21bc:	b4 2f       	mov	r27, r20
    21be:	a5 2f       	mov	r26, r21
    21c0:	f6 2f       	mov	r31, r22
    21c2:	e7 2f       	mov	r30, r23
    21c4:	77 0f       	add	r23, r23
    21c6:	44 0b       	sbc	r20, r20
    21c8:	54 2f       	mov	r21, r20
    21ca:	ba 01       	movw	r22, r20
    21cc:	64 2e       	mov	r6, r20
    21ce:	74 2e       	mov	r7, r20
    21d0:	94 2e       	mov	r9, r20
    21d2:	ab 0e       	add	r10, r27
    21d4:	61 e0       	ldi	r22, 0x01	; 1
    21d6:	ab 16       	cp	r10, r27
    21d8:	08 f0       	brcs	.+2      	; 0x21dc <__vector_77+0xd6>
    21da:	60 e0       	ldi	r22, 0x00	; 0
    21dc:	ba 0e       	add	r11, r26
    21de:	51 e0       	ldi	r21, 0x01	; 1
    21e0:	ba 16       	cp	r11, r26
    21e2:	08 f0       	brcs	.+2      	; 0x21e6 <__vector_77+0xe0>
    21e4:	50 e0       	ldi	r21, 0x00	; 0
    21e6:	a6 2f       	mov	r26, r22
    21e8:	ab 0d       	add	r26, r11
    21ea:	61 e0       	ldi	r22, 0x01	; 1
    21ec:	ab 15       	cp	r26, r11
    21ee:	08 f0       	brcs	.+2      	; 0x21f2 <__vector_77+0xec>
    21f0:	60 e0       	ldi	r22, 0x00	; 0
    21f2:	56 2b       	or	r21, r22
    21f4:	cf 0e       	add	r12, r31
    21f6:	61 e0       	ldi	r22, 0x01	; 1
    21f8:	cf 16       	cp	r12, r31
    21fa:	08 f0       	brcs	.+2      	; 0x21fe <__vector_77+0xf8>
    21fc:	60 e0       	ldi	r22, 0x00	; 0
    21fe:	f5 2f       	mov	r31, r21
    2200:	fc 0d       	add	r31, r12
    2202:	51 e0       	ldi	r21, 0x01	; 1
    2204:	fc 15       	cp	r31, r12
    2206:	08 f0       	brcs	.+2      	; 0x220a <__vector_77+0x104>
    2208:	50 e0       	ldi	r21, 0x00	; 0
    220a:	65 2b       	or	r22, r21
    220c:	de 0e       	add	r13, r30
    220e:	51 e0       	ldi	r21, 0x01	; 1
    2210:	de 16       	cp	r13, r30
    2212:	08 f0       	brcs	.+2      	; 0x2216 <__vector_77+0x110>
    2214:	50 e0       	ldi	r21, 0x00	; 0
    2216:	e6 2f       	mov	r30, r22
    2218:	ed 0d       	add	r30, r13
    221a:	61 e0       	ldi	r22, 0x01	; 1
    221c:	ed 15       	cp	r30, r13
    221e:	08 f0       	brcs	.+2      	; 0x2222 <__vector_77+0x11c>
    2220:	60 e0       	ldi	r22, 0x00	; 0
    2222:	56 2b       	or	r21, r22
    2224:	e6 0c       	add	r14, r6
    2226:	71 e0       	ldi	r23, 0x01	; 1
    2228:	e6 14       	cp	r14, r6
    222a:	08 f0       	brcs	.+2      	; 0x222e <__vector_77+0x128>
    222c:	70 e0       	ldi	r23, 0x00	; 0
    222e:	b5 2f       	mov	r27, r21
    2230:	be 0d       	add	r27, r14
    2232:	51 e0       	ldi	r21, 0x01	; 1
    2234:	be 15       	cp	r27, r14
    2236:	08 f0       	brcs	.+2      	; 0x223a <__vector_77+0x134>
    2238:	50 e0       	ldi	r21, 0x00	; 0
    223a:	75 2b       	or	r23, r21
    223c:	f7 0c       	add	r15, r7
    223e:	61 e0       	ldi	r22, 0x01	; 1
    2240:	f7 14       	cp	r15, r7
    2242:	08 f0       	brcs	.+2      	; 0x2246 <__vector_77+0x140>
    2244:	60 e0       	ldi	r22, 0x00	; 0
    2246:	7f 0d       	add	r23, r15
    2248:	51 e0       	ldi	r21, 0x01	; 1
    224a:	7f 15       	cp	r23, r15
    224c:	08 f0       	brcs	.+2      	; 0x2250 <__vector_77+0x14a>
    224e:	50 e0       	ldi	r21, 0x00	; 0
    2250:	65 2b       	or	r22, r21
    2252:	09 0d       	add	r16, r9
    2254:	51 e0       	ldi	r21, 0x01	; 1
    2256:	09 15       	cp	r16, r9
    2258:	08 f0       	brcs	.+2      	; 0x225c <__vector_77+0x156>
    225a:	50 e0       	ldi	r21, 0x00	; 0
    225c:	60 0f       	add	r22, r16
    225e:	ff 24       	eor	r15, r15
    2260:	f3 94       	inc	r15
    2262:	60 17       	cp	r22, r16
    2264:	08 f0       	brcs	.+2      	; 0x2268 <__vector_77+0x162>
    2266:	ff 24       	eor	r15, r15
    2268:	5f 29       	or	r21, r15
    226a:	41 0f       	add	r20, r17
    226c:	54 0f       	add	r21, r20
    226e:	a9 82       	std	Y+1, r10	; 0x01
    2270:	aa 83       	std	Y+2, r26	; 0x02
    2272:	fb 83       	std	Y+3, r31	; 0x03
    2274:	ec 83       	std	Y+4, r30	; 0x04
    2276:	bd 83       	std	Y+5, r27	; 0x05
    2278:	7e 83       	std	Y+6, r23	; 0x06
    227a:	6f 83       	std	Y+7, r22	; 0x07
    227c:	58 87       	std	Y+8, r21	; 0x08
    227e:	03 96       	adiw	r24, 0x03	; 3
ISR(TCD0_OVF_vect) {

	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2280:	8c 30       	cpi	r24, 0x0C	; 12
    2282:	91 05       	cpc	r25, r1
    2284:	09 f0       	breq	.+2      	; 0x2288 <__vector_77+0x182>
    2286:	73 cf       	rjmp	.-282    	; 0x216e <__vector_77+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    2288:	e9 80       	ldd	r14, Y+1	; 0x01
    228a:	fa 80       	ldd	r15, Y+2	; 0x02
    228c:	0b 81       	ldd	r16, Y+3	; 0x03
    228e:	1c 81       	ldd	r17, Y+4	; 0x04
    2290:	bd 81       	ldd	r27, Y+5	; 0x05
    2292:	ae 81       	ldd	r26, Y+6	; 0x06
    2294:	ff 81       	ldd	r31, Y+7	; 0x07
    2296:	e8 85       	ldd	r30, Y+8	; 0x08
    2298:	2e 2d       	mov	r18, r14
    229a:	3f 2d       	mov	r19, r15
    229c:	40 2f       	mov	r20, r16
    229e:	51 2f       	mov	r21, r17
    22a0:	6b 2f       	mov	r22, r27
    22a2:	7a 2f       	mov	r23, r26
    22a4:	8f 2f       	mov	r24, r31
    22a6:	9e 2f       	mov	r25, r30
    22a8:	ee 23       	and	r30, r30
    22aa:	0c f0       	brlt	.+2      	; 0x22ae <__vector_77+0x1a8>
    22ac:	4a c0       	rjmp	.+148    	; 0x2342 <__vector_77+0x23c>
    22ae:	93 e0       	ldi	r25, 0x03	; 3
    22b0:	e9 0e       	add	r14, r25
    22b2:	91 e0       	ldi	r25, 0x01	; 1
    22b4:	e2 16       	cp	r14, r18
    22b6:	08 f0       	brcs	.+2      	; 0x22ba <__vector_77+0x1b4>
    22b8:	90 e0       	ldi	r25, 0x00	; 0
    22ba:	21 e0       	ldi	r18, 0x01	; 1
    22bc:	f3 16       	cp	r15, r19
    22be:	08 f0       	brcs	.+2      	; 0x22c2 <__vector_77+0x1bc>
    22c0:	20 e0       	ldi	r18, 0x00	; 0
    22c2:	39 2f       	mov	r19, r25
    22c4:	3f 0d       	add	r19, r15
    22c6:	91 e0       	ldi	r25, 0x01	; 1
    22c8:	3f 15       	cp	r19, r15
    22ca:	08 f0       	brcs	.+2      	; 0x22ce <__vector_77+0x1c8>
    22cc:	90 e0       	ldi	r25, 0x00	; 0
    22ce:	29 2b       	or	r18, r25
    22d0:	91 e0       	ldi	r25, 0x01	; 1
    22d2:	04 17       	cp	r16, r20
    22d4:	08 f0       	brcs	.+2      	; 0x22d8 <__vector_77+0x1d2>
    22d6:	90 e0       	ldi	r25, 0x00	; 0
    22d8:	42 2f       	mov	r20, r18
    22da:	40 0f       	add	r20, r16
    22dc:	21 e0       	ldi	r18, 0x01	; 1
    22de:	40 17       	cp	r20, r16
    22e0:	08 f0       	brcs	.+2      	; 0x22e4 <__vector_77+0x1de>
    22e2:	20 e0       	ldi	r18, 0x00	; 0
    22e4:	92 2b       	or	r25, r18
    22e6:	21 e0       	ldi	r18, 0x01	; 1
    22e8:	15 17       	cp	r17, r21
    22ea:	08 f0       	brcs	.+2      	; 0x22ee <__vector_77+0x1e8>
    22ec:	20 e0       	ldi	r18, 0x00	; 0
    22ee:	59 2f       	mov	r21, r25
    22f0:	51 0f       	add	r21, r17
    22f2:	91 e0       	ldi	r25, 0x01	; 1
    22f4:	51 17       	cp	r21, r17
    22f6:	08 f0       	brcs	.+2      	; 0x22fa <__vector_77+0x1f4>
    22f8:	90 e0       	ldi	r25, 0x00	; 0
    22fa:	29 2b       	or	r18, r25
    22fc:	91 e0       	ldi	r25, 0x01	; 1
    22fe:	b6 17       	cp	r27, r22
    2300:	08 f0       	brcs	.+2      	; 0x2304 <__vector_77+0x1fe>
    2302:	90 e0       	ldi	r25, 0x00	; 0
    2304:	62 2f       	mov	r22, r18
    2306:	6b 0f       	add	r22, r27
    2308:	21 e0       	ldi	r18, 0x01	; 1
    230a:	6b 17       	cp	r22, r27
    230c:	08 f0       	brcs	.+2      	; 0x2310 <__vector_77+0x20a>
    230e:	20 e0       	ldi	r18, 0x00	; 0
    2310:	92 2b       	or	r25, r18
    2312:	21 e0       	ldi	r18, 0x01	; 1
    2314:	a7 17       	cp	r26, r23
    2316:	08 f0       	brcs	.+2      	; 0x231a <__vector_77+0x214>
    2318:	20 e0       	ldi	r18, 0x00	; 0
    231a:	79 2f       	mov	r23, r25
    231c:	7a 0f       	add	r23, r26
    231e:	91 e0       	ldi	r25, 0x01	; 1
    2320:	7a 17       	cp	r23, r26
    2322:	08 f0       	brcs	.+2      	; 0x2326 <__vector_77+0x220>
    2324:	90 e0       	ldi	r25, 0x00	; 0
    2326:	29 2b       	or	r18, r25
    2328:	91 e0       	ldi	r25, 0x01	; 1
    232a:	f8 17       	cp	r31, r24
    232c:	08 f0       	brcs	.+2      	; 0x2330 <__vector_77+0x22a>
    232e:	90 e0       	ldi	r25, 0x00	; 0
    2330:	82 2f       	mov	r24, r18
    2332:	8f 0f       	add	r24, r31
    2334:	21 e0       	ldi	r18, 0x01	; 1
    2336:	8f 17       	cp	r24, r31
    2338:	08 f0       	brcs	.+2      	; 0x233c <__vector_77+0x236>
    233a:	20 e0       	ldi	r18, 0x00	; 0
    233c:	92 2b       	or	r25, r18
    233e:	2e 2d       	mov	r18, r14
    2340:	9e 0f       	add	r25, r30
    2342:	02 e0       	ldi	r16, 0x02	; 2
    2344:	0e 94 af 2f 	call	0x5f5e	; 0x5f5e <__ashrdi3>
    2348:	29 83       	std	Y+1, r18	; 0x01
    234a:	3a 83       	std	Y+2, r19	; 0x02
    234c:	4b 83       	std	Y+3, r20	; 0x03
    234e:	5c 83       	std	Y+4, r21	; 0x04
    2350:	6d 83       	std	Y+5, r22	; 0x05
    2352:	7e 83       	std	Y+6, r23	; 0x06
    2354:	8f 83       	std	Y+7, r24	; 0x07
    2356:	98 87       	std	Y+8, r25	; 0x08
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    2358:	60 91 6a 50 	lds	r22, 0x506A
    235c:	70 91 6b 50 	lds	r23, 0x506B
    2360:	80 91 6c 50 	lds	r24, 0x506C
    2364:	90 91 6d 50 	lds	r25, 0x506D
    2368:	19 81       	ldd	r17, Y+1	; 0x01
    236a:	0a 81       	ldd	r16, Y+2	; 0x02
    236c:	fb 80       	ldd	r15, Y+3	; 0x03
    236e:	ec 80       	ldd	r14, Y+4	; 0x04
    2370:	dd 80       	ldd	r13, Y+5	; 0x05
    2372:	ce 80       	ldd	r12, Y+6	; 0x06
    2374:	bf 80       	ldd	r11, Y+7	; 0x07
    2376:	a8 84       	ldd	r10, Y+8	; 0x08
    2378:	20 91 ac 50 	lds	r18, 0x50AC
    237c:	30 91 ad 50 	lds	r19, 0x50AD
    2380:	40 e0       	ldi	r20, 0x00	; 0
    2382:	50 e0       	ldi	r21, 0x00	; 0
    2384:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    2388:	dc 01       	movw	r26, r24
    238a:	cb 01       	movw	r24, r22
    238c:	88 0f       	add	r24, r24
    238e:	99 1f       	adc	r25, r25
    2390:	88 0f       	add	r24, r24
    2392:	99 1f       	adc	r25, r25
    2394:	80 90 68 50 	lds	r8, 0x5068
    2398:	90 90 69 50 	lds	r9, 0x5069
    239c:	88 0e       	add	r8, r24
    239e:	99 1e       	adc	r9, r25
    23a0:	21 2f       	mov	r18, r17
    23a2:	30 2f       	mov	r19, r16
    23a4:	4f 2d       	mov	r20, r15
    23a6:	5e 2d       	mov	r21, r14
    23a8:	6d 2d       	mov	r22, r13
    23aa:	7c 2d       	mov	r23, r12
    23ac:	8b 2d       	mov	r24, r11
    23ae:	9a 2d       	mov	r25, r10
    23b0:	0f 2e       	mov	r0, r31
    23b2:	f0 ea       	ldi	r31, 0xA0	; 160
    23b4:	af 2e       	mov	r10, r31
    23b6:	f0 2d       	mov	r31, r0
    23b8:	0f 2e       	mov	r0, r31
    23ba:	f5 e2       	ldi	r31, 0x25	; 37
    23bc:	bf 2e       	mov	r11, r31
    23be:	f0 2d       	mov	r31, r0
    23c0:	0f 2e       	mov	r0, r31
    23c2:	f6 e2       	ldi	r31, 0x26	; 38
    23c4:	cf 2e       	mov	r12, r31
    23c6:	f0 2d       	mov	r31, r0
    23c8:	dd 24       	eor	r13, r13
    23ca:	ee 24       	eor	r14, r14
    23cc:	ff 24       	eor	r15, r15
    23ce:	00 e0       	ldi	r16, 0x00	; 0
    23d0:	10 e0       	ldi	r17, 0x00	; 0
    23d2:	0e 94 68 2e 	call	0x5cd0	; 0x5cd0 <__muldi3>
    23d6:	aa 24       	eor	r10, r10
    23d8:	aa 94       	dec	r10
    23da:	bb 24       	eor	r11, r11
    23dc:	ba 94       	dec	r11
    23de:	0f 2e       	mov	r0, r31
    23e0:	ff e7       	ldi	r31, 0x7F	; 127
    23e2:	cf 2e       	mov	r12, r31
    23e4:	f0 2d       	mov	r31, r0
    23e6:	0e 94 17 30 	call	0x602e	; 0x602e <__divdi3>
    23ea:	01 e0       	ldi	r16, 0x01	; 1
    23ec:	0e 94 3b 2f 	call	0x5e76	; 0x5e76 <__ashldi3>
    23f0:	0f 2e       	mov	r0, r31
    23f2:	f3 e0       	ldi	r31, 0x03	; 3
    23f4:	af 2e       	mov	r10, r31
    23f6:	f0 2d       	mov	r31, r0
    23f8:	bb 24       	eor	r11, r11
    23fa:	cc 24       	eor	r12, r12
    23fc:	00 e0       	ldi	r16, 0x00	; 0
    23fe:	0e 94 17 30 	call	0x602e	; 0x602e <__divdi3>
    2402:	f4 01       	movw	r30, r8
    2404:	20 83       	st	Z, r18
    2406:	31 83       	std	Z+1, r19	; 0x01
    2408:	42 83       	std	Z+2, r20	; 0x02
    240a:	53 83       	std	Z+3, r21	; 0x03
	if(write_to_FRAM){
    240c:	80 91 4d 40 	lds	r24, 0x404D
    2410:	88 23       	and	r24, r24
    2412:	09 f1       	breq	.+66     	; 0x2456 <__vector_77+0x350>
		writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    2414:	60 91 6a 50 	lds	r22, 0x506A
    2418:	70 91 6b 50 	lds	r23, 0x506B
    241c:	80 91 6c 50 	lds	r24, 0x506C
    2420:	90 91 6d 50 	lds	r25, 0x506D
    2424:	20 91 ac 50 	lds	r18, 0x50AC
    2428:	30 91 ad 50 	lds	r19, 0x50AD
    242c:	40 e0       	ldi	r20, 0x00	; 0
    242e:	50 e0       	ldi	r21, 0x00	; 0
    2430:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    2434:	dc 01       	movw	r26, r24
    2436:	cb 01       	movw	r24, r22
    2438:	9c 01       	movw	r18, r24
    243a:	22 0f       	add	r18, r18
    243c:	33 1f       	adc	r19, r19
    243e:	22 0f       	add	r18, r18
    2440:	33 1f       	adc	r19, r19
    2442:	80 91 68 50 	lds	r24, 0x5068
    2446:	90 91 69 50 	lds	r25, 0x5069
    244a:	82 0f       	add	r24, r18
    244c:	93 1f       	adc	r25, r19
    244e:	64 e0       	ldi	r22, 0x04	; 4
    2450:	70 e0       	ldi	r23, 0x00	; 0
    2452:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
	}
	sampleCount++;
    2456:	80 91 6a 50 	lds	r24, 0x506A
    245a:	90 91 6b 50 	lds	r25, 0x506B
    245e:	a0 91 6c 50 	lds	r26, 0x506C
    2462:	b0 91 6d 50 	lds	r27, 0x506D
    2466:	01 96       	adiw	r24, 0x01	; 1
    2468:	a1 1d       	adc	r26, r1
    246a:	b1 1d       	adc	r27, r1
    246c:	80 93 6a 50 	sts	0x506A, r24
    2470:	90 93 6b 50 	sts	0x506B, r25
    2474:	a0 93 6c 50 	sts	0x506C, r26
    2478:	b0 93 6d 50 	sts	0x506D, r27
}
    247c:	2c 96       	adiw	r28, 0x0c	; 12
    247e:	cd bf       	out	0x3d, r28	; 61
    2480:	de bf       	out	0x3e, r29	; 62
    2482:	df 91       	pop	r29
    2484:	cf 91       	pop	r28
    2486:	ff 91       	pop	r31
    2488:	ef 91       	pop	r30
    248a:	bf 91       	pop	r27
    248c:	af 91       	pop	r26
    248e:	9f 91       	pop	r25
    2490:	8f 91       	pop	r24
    2492:	7f 91       	pop	r23
    2494:	6f 91       	pop	r22
    2496:	5f 91       	pop	r21
    2498:	4f 91       	pop	r20
    249a:	3f 91       	pop	r19
    249c:	2f 91       	pop	r18
    249e:	1f 91       	pop	r17
    24a0:	0f 91       	pop	r16
    24a2:	ff 90       	pop	r15
    24a4:	ef 90       	pop	r14
    24a6:	df 90       	pop	r13
    24a8:	cf 90       	pop	r12
    24aa:	bf 90       	pop	r11
    24ac:	af 90       	pop	r10
    24ae:	9f 90       	pop	r9
    24b0:	8f 90       	pop	r8
    24b2:	7f 90       	pop	r7
    24b4:	6f 90       	pop	r6
    24b6:	0f 90       	pop	r0
    24b8:	0b be       	out	0x3b, r0	; 59
    24ba:	0f 90       	pop	r0
    24bc:	0f be       	out	0x3f, r0	; 63
    24be:	0f 90       	pop	r0
    24c0:	1f 90       	pop	r1
    24c2:	18 95       	reti

000024c4 <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
	
	SPICS(TRUE);
    24c4:	81 e0       	ldi	r24, 0x01	; 1
    24c6:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    24ca:	82 e0       	ldi	r24, 0x02	; 2
    24cc:	e0 ea       	ldi	r30, 0xA0	; 160
    24ce:	f6 e0       	ldi	r31, 0x06	; 6
    24d0:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    24d2:	8a ea       	ldi	r24, 0xAA	; 170
    24d4:	e0 ec       	ldi	r30, 0xC0	; 192
    24d6:	f8 e0       	ldi	r31, 0x08	; 8
    24d8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    24da:	82 81       	ldd	r24, Z+2	; 0x02
    24dc:	88 23       	and	r24, r24
    24de:	ec f7       	brge	.-6      	; 0x24da <sampleCurrentChannel+0x16>
	SPIBuffer[SPICount] = SPIC.DATA;
    24e0:	90 91 a5 50 	lds	r25, 0x50A5
    24e4:	e0 ec       	ldi	r30, 0xC0	; 192
    24e6:	f8 e0       	ldi	r31, 0x08	; 8
    24e8:	83 81       	ldd	r24, Z+3	; 0x03
    24ea:	a5 e2       	ldi	r26, 0x25	; 37
    24ec:	be e3       	ldi	r27, 0x3E	; 62
    24ee:	a9 0f       	add	r26, r25
    24f0:	b1 1d       	adc	r27, r1
    24f2:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    24f4:	8a ea       	ldi	r24, 0xAA	; 170
    24f6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    24f8:	82 81       	ldd	r24, Z+2	; 0x02
    24fa:	88 23       	and	r24, r24
    24fc:	ec f7       	brge	.-6      	; 0x24f8 <sampleCurrentChannel+0x34>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    24fe:	a0 91 a5 50 	lds	r26, 0x50A5
    2502:	b0 e0       	ldi	r27, 0x00	; 0
    2504:	e0 ec       	ldi	r30, 0xC0	; 192
    2506:	f8 e0       	ldi	r31, 0x08	; 8
    2508:	83 81       	ldd	r24, Z+3	; 0x03
    250a:	aa 5d       	subi	r26, 0xDA	; 218
    250c:	b1 4c       	sbci	r27, 0xC1	; 193
    250e:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2510:	8a ea       	ldi	r24, 0xAA	; 170
    2512:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2514:	82 81       	ldd	r24, Z+2	; 0x02
    2516:	88 23       	and	r24, r24
    2518:	ec f7       	brge	.-6      	; 0x2514 <sampleCurrentChannel+0x50>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    251a:	e0 91 a5 50 	lds	r30, 0x50A5
    251e:	f0 e0       	ldi	r31, 0x00	; 0
    2520:	a0 ec       	ldi	r26, 0xC0	; 192
    2522:	b8 e0       	ldi	r27, 0x08	; 8
    2524:	13 96       	adiw	r26, 0x03	; 3
    2526:	8c 91       	ld	r24, X
    2528:	e9 5d       	subi	r30, 0xD9	; 217
    252a:	f1 4c       	sbci	r31, 0xC1	; 193
    252c:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    252e:	82 e0       	ldi	r24, 0x02	; 2
    2530:	e0 ea       	ldi	r30, 0xA0	; 160
    2532:	f6 e0       	ldi	r31, 0x06	; 6
    2534:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
    2536:	80 91 a5 50 	lds	r24, 0x50A5
    253a:	8d 5f       	subi	r24, 0xFD	; 253
    253c:	80 93 a5 50 	sts	0x50A5, r24
	SPICS(FALSE);
    2540:	80 e0       	ldi	r24, 0x00	; 0
    2542:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
}
    2546:	08 95       	ret

00002548 <__vector_82>:
ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point
ISR(TCD0_CCD_vect) {
    2548:	1f 92       	push	r1
    254a:	0f 92       	push	r0
    254c:	0f b6       	in	r0, 0x3f	; 63
    254e:	0f 92       	push	r0
    2550:	0b b6       	in	r0, 0x3b	; 59
    2552:	0f 92       	push	r0
    2554:	11 24       	eor	r1, r1
    2556:	2f 93       	push	r18
    2558:	3f 93       	push	r19
    255a:	4f 93       	push	r20
    255c:	5f 93       	push	r21
    255e:	6f 93       	push	r22
    2560:	7f 93       	push	r23
    2562:	8f 93       	push	r24
    2564:	9f 93       	push	r25
    2566:	af 93       	push	r26
    2568:	bf 93       	push	r27
    256a:	ef 93       	push	r30
    256c:	ff 93       	push	r31
	sampleCurrentChannel();
    256e:	0e 94 62 12 	call	0x24c4	; 0x24c4 <sampleCurrentChannel>
	SPICount = 0;
    2572:	10 92 a5 50 	sts	0x50A5, r1
}
    2576:	ff 91       	pop	r31
    2578:	ef 91       	pop	r30
    257a:	bf 91       	pop	r27
    257c:	af 91       	pop	r26
    257e:	9f 91       	pop	r25
    2580:	8f 91       	pop	r24
    2582:	7f 91       	pop	r23
    2584:	6f 91       	pop	r22
    2586:	5f 91       	pop	r21
    2588:	4f 91       	pop	r20
    258a:	3f 91       	pop	r19
    258c:	2f 91       	pop	r18
    258e:	0f 90       	pop	r0
    2590:	0b be       	out	0x3b, r0	; 59
    2592:	0f 90       	pop	r0
    2594:	0f be       	out	0x3f, r0	; 63
    2596:	0f 90       	pop	r0
    2598:	1f 90       	pop	r1
    259a:	18 95       	reti

0000259c <__vector_81>:
ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCD0_CCC_vect) {
    259c:	1f 92       	push	r1
    259e:	0f 92       	push	r0
    25a0:	0f b6       	in	r0, 0x3f	; 63
    25a2:	0f 92       	push	r0
    25a4:	0b b6       	in	r0, 0x3b	; 59
    25a6:	0f 92       	push	r0
    25a8:	11 24       	eor	r1, r1
    25aa:	2f 93       	push	r18
    25ac:	3f 93       	push	r19
    25ae:	4f 93       	push	r20
    25b0:	5f 93       	push	r21
    25b2:	6f 93       	push	r22
    25b4:	7f 93       	push	r23
    25b6:	8f 93       	push	r24
    25b8:	9f 93       	push	r25
    25ba:	af 93       	push	r26
    25bc:	bf 93       	push	r27
    25be:	ef 93       	push	r30
    25c0:	ff 93       	push	r31
	sampleCurrentChannel();
    25c2:	0e 94 62 12 	call	0x24c4	; 0x24c4 <sampleCurrentChannel>
}
    25c6:	ff 91       	pop	r31
    25c8:	ef 91       	pop	r30
    25ca:	bf 91       	pop	r27
    25cc:	af 91       	pop	r26
    25ce:	9f 91       	pop	r25
    25d0:	8f 91       	pop	r24
    25d2:	7f 91       	pop	r23
    25d4:	6f 91       	pop	r22
    25d6:	5f 91       	pop	r21
    25d8:	4f 91       	pop	r20
    25da:	3f 91       	pop	r19
    25dc:	2f 91       	pop	r18
    25de:	0f 90       	pop	r0
    25e0:	0b be       	out	0x3b, r0	; 59
    25e2:	0f 90       	pop	r0
    25e4:	0f be       	out	0x3f, r0	; 63
    25e6:	0f 90       	pop	r0
    25e8:	1f 90       	pop	r1
    25ea:	18 95       	reti

000025ec <__vector_80>:
//first averaging point
ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}
//second averaging point
ISR(TCD0_CCB_vect) {
    25ec:	1f 92       	push	r1
    25ee:	0f 92       	push	r0
    25f0:	0f b6       	in	r0, 0x3f	; 63
    25f2:	0f 92       	push	r0
    25f4:	0b b6       	in	r0, 0x3b	; 59
    25f6:	0f 92       	push	r0
    25f8:	11 24       	eor	r1, r1
    25fa:	2f 93       	push	r18
    25fc:	3f 93       	push	r19
    25fe:	4f 93       	push	r20
    2600:	5f 93       	push	r21
    2602:	6f 93       	push	r22
    2604:	7f 93       	push	r23
    2606:	8f 93       	push	r24
    2608:	9f 93       	push	r25
    260a:	af 93       	push	r26
    260c:	bf 93       	push	r27
    260e:	ef 93       	push	r30
    2610:	ff 93       	push	r31
	sampleCurrentChannel();
    2612:	0e 94 62 12 	call	0x24c4	; 0x24c4 <sampleCurrentChannel>
}
    2616:	ff 91       	pop	r31
    2618:	ef 91       	pop	r30
    261a:	bf 91       	pop	r27
    261c:	af 91       	pop	r26
    261e:	9f 91       	pop	r25
    2620:	8f 91       	pop	r24
    2622:	7f 91       	pop	r23
    2624:	6f 91       	pop	r22
    2626:	5f 91       	pop	r21
    2628:	4f 91       	pop	r20
    262a:	3f 91       	pop	r19
    262c:	2f 91       	pop	r18
    262e:	0f 90       	pop	r0
    2630:	0b be       	out	0x3b, r0	; 59
    2632:	0f 90       	pop	r0
    2634:	0f be       	out	0x3f, r0	; 63
    2636:	0f 90       	pop	r0
    2638:	1f 90       	pop	r1
    263a:	18 95       	reti

0000263c <__vector_79>:
// 	enableADCMUX(FALSE);
	
}

//first averaging point
ISR(TCD0_CCA_vect) {
    263c:	1f 92       	push	r1
    263e:	0f 92       	push	r0
    2640:	0f b6       	in	r0, 0x3f	; 63
    2642:	0f 92       	push	r0
    2644:	0b b6       	in	r0, 0x3b	; 59
    2646:	0f 92       	push	r0
    2648:	11 24       	eor	r1, r1
    264a:	2f 93       	push	r18
    264c:	3f 93       	push	r19
    264e:	4f 93       	push	r20
    2650:	5f 93       	push	r21
    2652:	6f 93       	push	r22
    2654:	7f 93       	push	r23
    2656:	8f 93       	push	r24
    2658:	9f 93       	push	r25
    265a:	af 93       	push	r26
    265c:	bf 93       	push	r27
    265e:	ef 93       	push	r30
    2660:	ff 93       	push	r31
	sampleCurrentChannel();
    2662:	0e 94 62 12 	call	0x24c4	; 0x24c4 <sampleCurrentChannel>
}
    2666:	ff 91       	pop	r31
    2668:	ef 91       	pop	r30
    266a:	bf 91       	pop	r27
    266c:	af 91       	pop	r26
    266e:	9f 91       	pop	r25
    2670:	8f 91       	pop	r24
    2672:	7f 91       	pop	r23
    2674:	6f 91       	pop	r22
    2676:	5f 91       	pop	r21
    2678:	4f 91       	pop	r20
    267a:	3f 91       	pop	r19
    267c:	2f 91       	pop	r18
    267e:	0f 90       	pop	r0
    2680:	0b be       	out	0x3b, r0	; 59
    2682:	0f 90       	pop	r0
    2684:	0f be       	out	0x3f, r0	; 63
    2686:	0f 90       	pop	r0
    2688:	1f 90       	pop	r1
    268a:	18 95       	reti

0000268c <__vector_19>:
ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    268c:	1f 92       	push	r1
    268e:	0f 92       	push	r0
    2690:	0f b6       	in	r0, 0x3f	; 63
    2692:	0f 92       	push	r0
    2694:	0b b6       	in	r0, 0x3b	; 59
    2696:	0f 92       	push	r0
    2698:	11 24       	eor	r1, r1
    269a:	2f 93       	push	r18
    269c:	3f 93       	push	r19
    269e:	4f 93       	push	r20
    26a0:	5f 93       	push	r21
    26a2:	6f 93       	push	r22
    26a4:	7f 93       	push	r23
    26a6:	8f 93       	push	r24
    26a8:	9f 93       	push	r25
    26aa:	af 93       	push	r26
    26ac:	bf 93       	push	r27
    26ae:	ef 93       	push	r30
    26b0:	ff 93       	push	r31
	sampleCurrentChannel();
    26b2:	0e 94 62 12 	call	0x24c4	; 0x24c4 <sampleCurrentChannel>
	SPICount = 0;
    26b6:	10 92 a5 50 	sts	0x50A5, r1
	if(PORTB.OUT & PIN1_bm) {
    26ba:	e0 e2       	ldi	r30, 0x20	; 32
    26bc:	f6 e0       	ldi	r31, 0x06	; 6
    26be:	84 81       	ldd	r24, Z+4	; 0x04
    26c0:	81 ff       	sbrs	r24, 1
    26c2:	0f c0       	rjmp	.+30     	; 0x26e2 <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    26c4:	e0 e0       	ldi	r30, 0x00	; 0
    26c6:	f6 e0       	ldi	r31, 0x06	; 6
    26c8:	84 81       	ldd	r24, Z+4	; 0x04
    26ca:	86 ff       	sbrs	r24, 6
    26cc:	05 c0       	rjmp	.+10     	; 0x26d8 <__vector_19+0x4c>
    26ce:	82 e0       	ldi	r24, 0x02	; 2
    26d0:	e0 e2       	ldi	r30, 0x20	; 32
    26d2:	f6 e0       	ldi	r31, 0x06	; 6
    26d4:	87 83       	std	Z+7, r24	; 0x07
    26d6:	0d c0       	rjmp	.+26     	; 0x26f2 <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
    26d8:	80 e4       	ldi	r24, 0x40	; 64
    26da:	e0 e0       	ldi	r30, 0x00	; 0
    26dc:	f6 e0       	ldi	r31, 0x06	; 6
    26de:	87 83       	std	Z+7, r24	; 0x07
    26e0:	08 c0       	rjmp	.+16     	; 0x26f2 <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    26e2:	80 e4       	ldi	r24, 0x40	; 64
    26e4:	e0 e0       	ldi	r30, 0x00	; 0
    26e6:	f6 e0       	ldi	r31, 0x06	; 6
    26e8:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
    26ea:	82 e0       	ldi	r24, 0x02	; 2
    26ec:	e0 e2       	ldi	r30, 0x20	; 32
    26ee:	f6 e0       	ldi	r31, 0x06	; 6
    26f0:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
    26f2:	ff 91       	pop	r31
    26f4:	ef 91       	pop	r30
    26f6:	bf 91       	pop	r27
    26f8:	af 91       	pop	r26
    26fa:	9f 91       	pop	r25
    26fc:	8f 91       	pop	r24
    26fe:	7f 91       	pop	r23
    2700:	6f 91       	pop	r22
    2702:	5f 91       	pop	r21
    2704:	4f 91       	pop	r20
    2706:	3f 91       	pop	r19
    2708:	2f 91       	pop	r18
    270a:	0f 90       	pop	r0
    270c:	0b be       	out	0x3b, r0	; 59
    270e:	0f 90       	pop	r0
    2710:	0f be       	out	0x3f, r0	; 63
    2712:	0f 90       	pop	r0
    2714:	1f 90       	pop	r1
    2716:	18 95       	reti

00002718 <__vector_18>:
ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCC0_CCC_vect) {
    2718:	1f 92       	push	r1
    271a:	0f 92       	push	r0
    271c:	0f b6       	in	r0, 0x3f	; 63
    271e:	0f 92       	push	r0
    2720:	0b b6       	in	r0, 0x3b	; 59
    2722:	0f 92       	push	r0
    2724:	11 24       	eor	r1, r1
    2726:	2f 93       	push	r18
    2728:	3f 93       	push	r19
    272a:	4f 93       	push	r20
    272c:	5f 93       	push	r21
    272e:	6f 93       	push	r22
    2730:	7f 93       	push	r23
    2732:	8f 93       	push	r24
    2734:	9f 93       	push	r25
    2736:	af 93       	push	r26
    2738:	bf 93       	push	r27
    273a:	ef 93       	push	r30
    273c:	ff 93       	push	r31
	sampleCurrentChannel();
    273e:	0e 94 62 12 	call	0x24c4	; 0x24c4 <sampleCurrentChannel>
}
    2742:	ff 91       	pop	r31
    2744:	ef 91       	pop	r30
    2746:	bf 91       	pop	r27
    2748:	af 91       	pop	r26
    274a:	9f 91       	pop	r25
    274c:	8f 91       	pop	r24
    274e:	7f 91       	pop	r23
    2750:	6f 91       	pop	r22
    2752:	5f 91       	pop	r21
    2754:	4f 91       	pop	r20
    2756:	3f 91       	pop	r19
    2758:	2f 91       	pop	r18
    275a:	0f 90       	pop	r0
    275c:	0b be       	out	0x3b, r0	; 59
    275e:	0f 90       	pop	r0
    2760:	0f be       	out	0x3f, r0	; 63
    2762:	0f 90       	pop	r0
    2764:	1f 90       	pop	r1
    2766:	18 95       	reti

00002768 <__vector_17>:
ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

//second averaging point
ISR(TCC0_CCB_vect) {
    2768:	1f 92       	push	r1
    276a:	0f 92       	push	r0
    276c:	0f b6       	in	r0, 0x3f	; 63
    276e:	0f 92       	push	r0
    2770:	0b b6       	in	r0, 0x3b	; 59
    2772:	0f 92       	push	r0
    2774:	11 24       	eor	r1, r1
    2776:	2f 93       	push	r18
    2778:	3f 93       	push	r19
    277a:	4f 93       	push	r20
    277c:	5f 93       	push	r21
    277e:	6f 93       	push	r22
    2780:	7f 93       	push	r23
    2782:	8f 93       	push	r24
    2784:	9f 93       	push	r25
    2786:	af 93       	push	r26
    2788:	bf 93       	push	r27
    278a:	ef 93       	push	r30
    278c:	ff 93       	push	r31
	sampleCurrentChannel();
    278e:	0e 94 62 12 	call	0x24c4	; 0x24c4 <sampleCurrentChannel>
}
    2792:	ff 91       	pop	r31
    2794:	ef 91       	pop	r30
    2796:	bf 91       	pop	r27
    2798:	af 91       	pop	r26
    279a:	9f 91       	pop	r25
    279c:	8f 91       	pop	r24
    279e:	7f 91       	pop	r23
    27a0:	6f 91       	pop	r22
    27a2:	5f 91       	pop	r21
    27a4:	4f 91       	pop	r20
    27a6:	3f 91       	pop	r19
    27a8:	2f 91       	pop	r18
    27aa:	0f 90       	pop	r0
    27ac:	0b be       	out	0x3b, r0	; 59
    27ae:	0f 90       	pop	r0
    27b0:	0f be       	out	0x3f, r0	; 63
    27b2:	0f 90       	pop	r0
    27b4:	1f 90       	pop	r1
    27b6:	18 95       	reti

000027b8 <__vector_16>:
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//first averaging point
ISR(TCC0_CCA_vect) {
    27b8:	1f 92       	push	r1
    27ba:	0f 92       	push	r0
    27bc:	0f b6       	in	r0, 0x3f	; 63
    27be:	0f 92       	push	r0
    27c0:	0b b6       	in	r0, 0x3b	; 59
    27c2:	0f 92       	push	r0
    27c4:	11 24       	eor	r1, r1
    27c6:	2f 93       	push	r18
    27c8:	3f 93       	push	r19
    27ca:	4f 93       	push	r20
    27cc:	5f 93       	push	r21
    27ce:	6f 93       	push	r22
    27d0:	7f 93       	push	r23
    27d2:	8f 93       	push	r24
    27d4:	9f 93       	push	r25
    27d6:	af 93       	push	r26
    27d8:	bf 93       	push	r27
    27da:	ef 93       	push	r30
    27dc:	ff 93       	push	r31
	sampleCurrentChannel();
    27de:	0e 94 62 12 	call	0x24c4	; 0x24c4 <sampleCurrentChannel>
}
    27e2:	ff 91       	pop	r31
    27e4:	ef 91       	pop	r30
    27e6:	bf 91       	pop	r27
    27e8:	af 91       	pop	r26
    27ea:	9f 91       	pop	r25
    27ec:	8f 91       	pop	r24
    27ee:	7f 91       	pop	r23
    27f0:	6f 91       	pop	r22
    27f2:	5f 91       	pop	r21
    27f4:	4f 91       	pop	r20
    27f6:	3f 91       	pop	r19
    27f8:	2f 91       	pop	r18
    27fa:	0f 90       	pop	r0
    27fc:	0b be       	out	0x3b, r0	; 59
    27fe:	0f 90       	pop	r0
    2800:	0f be       	out	0x3f, r0	; 63
    2802:	0f 90       	pop	r0
    2804:	1f 90       	pop	r1
    2806:	18 95       	reti

00002808 <writeSE2FRAM>:
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    2808:	ff 92       	push	r15
    280a:	0f 93       	push	r16
    280c:	1f 93       	push	r17
    280e:	cf 93       	push	r28
    2810:	df 93       	push	r29
    2812:	cd b7       	in	r28, 0x3d	; 61
    2814:	de b7       	in	r29, 0x3e	; 62
    2816:	28 97       	sbiw	r28, 0x08	; 8
    2818:	cd bf       	out	0x3d, r28	; 61
    281a:	de bf       	out	0x3e, r29	; 62

	volatile int32_t sum = 0;
    281c:	19 82       	std	Y+1, r1	; 0x01
    281e:	1a 82       	std	Y+2, r1	; 0x02
    2820:	1b 82       	std	Y+3, r1	; 0x03
    2822:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    2824:	80 91 6a 50 	lds	r24, 0x506A
    2828:	90 91 6b 50 	lds	r25, 0x506B
    282c:	a0 91 6c 50 	lds	r26, 0x506C
    2830:	b0 91 6d 50 	lds	r27, 0x506D
    2834:	01 96       	adiw	r24, 0x01	; 1
    2836:	a1 1d       	adc	r26, r1
    2838:	b1 1d       	adc	r27, r1
    283a:	80 93 6a 50 	sts	0x506A, r24
    283e:	90 93 6b 50 	sts	0x506B, r25
    2842:	a0 93 6c 50 	sts	0x506C, r26
    2846:	b0 93 6d 50 	sts	0x506D, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    284a:	80 ed       	ldi	r24, 0xD0	; 208
    284c:	80 93 c0 08 	sts	0x08C0, r24
    2850:	20 e0       	ldi	r18, 0x00	; 0
    2852:	30 e0       	ldi	r19, 0x00	; 0
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2854:	05 e2       	ldi	r16, 0x25	; 37
    2856:	1e e3       	ldi	r17, 0x3E	; 62
    2858:	ff 24       	eor	r15, r15
    285a:	fa 94       	dec	r15
    285c:	c9 01       	movw	r24, r18
    285e:	f8 01       	movw	r30, r16
    2860:	e2 0f       	add	r30, r18
    2862:	f3 1f       	adc	r31, r19
    2864:	40 81       	ld	r20, Z
    2866:	44 23       	and	r20, r20
    2868:	14 f4       	brge	.+4      	; 0x286e <writeSE2FRAM+0x66>
    286a:	f8 86       	std	Y+8, r15	; 0x08
    286c:	01 c0       	rjmp	.+2      	; 0x2870 <writeSE2FRAM+0x68>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    286e:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2870:	80 0f       	add	r24, r16
    2872:	91 1f       	adc	r25, r17
    2874:	fc 01       	movw	r30, r24
    2876:	80 81       	ld	r24, Z
    2878:	8f 83       	std	Y+7, r24	; 0x07
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    287a:	f9 01       	movw	r30, r18
    287c:	31 96       	adiw	r30, 0x01	; 1
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    287e:	e0 0f       	add	r30, r16
    2880:	f1 1f       	adc	r31, r17
    2882:	80 81       	ld	r24, Z
    2884:	8e 83       	std	Y+6, r24	; 0x06
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    2886:	f9 01       	movw	r30, r18
    2888:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    288a:	e0 0f       	add	r30, r16
    288c:	f1 1f       	adc	r31, r17
    288e:	80 81       	ld	r24, Z
    2890:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    2892:	49 81       	ldd	r20, Y+1	; 0x01
    2894:	5a 81       	ldd	r21, Y+2	; 0x02
    2896:	6b 81       	ldd	r22, Y+3	; 0x03
    2898:	7c 81       	ldd	r23, Y+4	; 0x04
    289a:	8d 81       	ldd	r24, Y+5	; 0x05
    289c:	9e 81       	ldd	r25, Y+6	; 0x06
    289e:	af 81       	ldd	r26, Y+7	; 0x07
    28a0:	b8 85       	ldd	r27, Y+8	; 0x08
    28a2:	84 0f       	add	r24, r20
    28a4:	95 1f       	adc	r25, r21
    28a6:	a6 1f       	adc	r26, r22
    28a8:	b7 1f       	adc	r27, r23
    28aa:	89 83       	std	Y+1, r24	; 0x01
    28ac:	9a 83       	std	Y+2, r25	; 0x02
    28ae:	ab 83       	std	Y+3, r26	; 0x03
    28b0:	bc 83       	std	Y+4, r27	; 0x04
    28b2:	2d 5f       	subi	r18, 0xFD	; 253
    28b4:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    28b6:	2c 30       	cpi	r18, 0x0C	; 12
    28b8:	31 05       	cpc	r19, r1
    28ba:	81 f6       	brne	.-96     	; 0x285c <writeSE2FRAM+0x54>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    28bc:	69 81       	ldd	r22, Y+1	; 0x01
    28be:	7a 81       	ldd	r23, Y+2	; 0x02
    28c0:	8b 81       	ldd	r24, Y+3	; 0x03
    28c2:	9c 81       	ldd	r25, Y+4	; 0x04
    28c4:	24 e0       	ldi	r18, 0x04	; 4
    28c6:	30 e0       	ldi	r19, 0x00	; 0
    28c8:	40 e0       	ldi	r20, 0x00	; 0
    28ca:	50 e0       	ldi	r21, 0x00	; 0
    28cc:	0e 94 d6 39 	call	0x73ac	; 0x73ac <__divmodsi4>
    28d0:	29 83       	std	Y+1, r18	; 0x01
    28d2:	3a 83       	std	Y+2, r19	; 0x02
    28d4:	4b 83       	std	Y+3, r20	; 0x03
    28d6:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    28d8:	29 81       	ldd	r18, Y+1	; 0x01
    28da:	87 e2       	ldi	r24, 0x27	; 39
    28dc:	9e e3       	ldi	r25, 0x3E	; 62
    28de:	20 93 27 3e 	sts	0x3E27, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    28e2:	2a 81       	ldd	r18, Y+2	; 0x02
    28e4:	fc 01       	movw	r30, r24
    28e6:	31 97       	sbiw	r30, 0x01	; 1
    28e8:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    28ea:	2b 81       	ldd	r18, Y+3	; 0x03
    28ec:	02 97       	sbiw	r24, 0x02	; 2
    28ee:	fc 01       	movw	r30, r24
    28f0:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    28f2:	80 e1       	ldi	r24, 0x10	; 16
    28f4:	e0 e4       	ldi	r30, 0x40	; 64
    28f6:	f6 e0       	ldi	r31, 0x06	; 6
    28f8:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    28fa:	88 e0       	ldi	r24, 0x08	; 8
    28fc:	e0 e2       	ldi	r30, 0x20	; 32
    28fe:	f6 e0       	ldi	r31, 0x06	; 6
    2900:	86 83       	std	Z+6, r24	; 0x06
	nop();
    2902:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2904:	86 e0       	ldi	r24, 0x06	; 6
    2906:	e0 ec       	ldi	r30, 0xC0	; 192
    2908:	f8 e0       	ldi	r31, 0x08	; 8
    290a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    290c:	82 81       	ldd	r24, Z+2	; 0x02
    290e:	88 23       	and	r24, r24
    2910:	ec f7       	brge	.-6      	; 0x290c <writeSE2FRAM+0x104>
	SPIBuffer[12] = SPIC.DATA;
    2912:	e0 ec       	ldi	r30, 0xC0	; 192
    2914:	f8 e0       	ldi	r31, 0x08	; 8
    2916:	83 81       	ldd	r24, Z+3	; 0x03
    2918:	80 93 31 3e 	sts	0x3E31, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    291c:	a0 e2       	ldi	r26, 0x20	; 32
    291e:	b6 e0       	ldi	r27, 0x06	; 6
    2920:	88 e0       	ldi	r24, 0x08	; 8
    2922:	15 96       	adiw	r26, 0x05	; 5
    2924:	8c 93       	st	X, r24
    2926:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    2928:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    292a:	16 96       	adiw	r26, 0x06	; 6
    292c:	8c 93       	st	X, r24
    292e:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    2930:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2932:	82 e0       	ldi	r24, 0x02	; 2
    2934:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2936:	82 81       	ldd	r24, Z+2	; 0x02
    2938:	88 23       	and	r24, r24
    293a:	ec f7       	brge	.-6      	; 0x2936 <writeSE2FRAM+0x12e>
	SPIBuffer[12] = SPIC.DATA;
    293c:	e0 ec       	ldi	r30, 0xC0	; 192
    293e:	f8 e0       	ldi	r31, 0x08	; 8
    2940:	83 81       	ldd	r24, Z+3	; 0x03
    2942:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2946:	80 91 23 3e 	lds	r24, 0x3E23
    294a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    294c:	82 81       	ldd	r24, Z+2	; 0x02
    294e:	88 23       	and	r24, r24
    2950:	ec f7       	brge	.-6      	; 0x294c <writeSE2FRAM+0x144>
	SPIBuffer[12] = SPIC.DATA;
    2952:	e0 ec       	ldi	r30, 0xC0	; 192
    2954:	f8 e0       	ldi	r31, 0x08	; 8
    2956:	83 81       	ldd	r24, Z+3	; 0x03
    2958:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    295c:	80 91 22 3e 	lds	r24, 0x3E22
    2960:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2962:	82 81       	ldd	r24, Z+2	; 0x02
    2964:	88 23       	and	r24, r24
    2966:	ec f7       	brge	.-6      	; 0x2962 <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    2968:	e0 ec       	ldi	r30, 0xC0	; 192
    296a:	f8 e0       	ldi	r31, 0x08	; 8
    296c:	83 81       	ldd	r24, Z+3	; 0x03
    296e:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = SPIBuffer[0];
    2972:	80 91 25 3e 	lds	r24, 0x3E25
    2976:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2978:	82 81       	ldd	r24, Z+2	; 0x02
    297a:	88 23       	and	r24, r24
    297c:	ec f7       	brge	.-6      	; 0x2978 <writeSE2FRAM+0x170>
	SPIBuffer[12] = SPIC.DATA;
    297e:	e0 ec       	ldi	r30, 0xC0	; 192
    2980:	f8 e0       	ldi	r31, 0x08	; 8
    2982:	83 81       	ldd	r24, Z+3	; 0x03
    2984:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = SPIBuffer[1];
    2988:	80 91 26 3e 	lds	r24, 0x3E26
    298c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    298e:	82 81       	ldd	r24, Z+2	; 0x02
    2990:	88 23       	and	r24, r24
    2992:	ec f7       	brge	.-6      	; 0x298e <writeSE2FRAM+0x186>
	SPIBuffer[12] = SPIC.DATA;
    2994:	e0 ec       	ldi	r30, 0xC0	; 192
    2996:	f8 e0       	ldi	r31, 0x08	; 8
    2998:	83 81       	ldd	r24, Z+3	; 0x03
    299a:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = SPIBuffer[2];
    299e:	80 91 27 3e 	lds	r24, 0x3E27
    29a2:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    29a4:	82 81       	ldd	r24, Z+2	; 0x02
    29a6:	88 23       	and	r24, r24
    29a8:	ec f7       	brge	.-6      	; 0x29a4 <writeSE2FRAM+0x19c>
	SPIBuffer[12] = SPIC.DATA;
    29aa:	a0 ec       	ldi	r26, 0xC0	; 192
    29ac:	b8 e0       	ldi	r27, 0x08	; 8
    29ae:	13 96       	adiw	r26, 0x03	; 3
    29b0:	8c 91       	ld	r24, X
    29b2:	13 97       	sbiw	r26, 0x03	; 3
    29b4:	80 93 31 3e 	sts	0x3E31, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    29b8:	88 e0       	ldi	r24, 0x08	; 8
    29ba:	e0 e2       	ldi	r30, 0x20	; 32
    29bc:	f6 e0       	ldi	r31, 0x06	; 6
    29be:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    29c0:	e0 e4       	ldi	r30, 0x40	; 64
    29c2:	f6 e0       	ldi	r31, 0x06	; 6
    29c4:	80 e1       	ldi	r24, 0x10	; 16
    29c6:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    29c8:	94 e5       	ldi	r25, 0x54	; 84
    29ca:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    29cc:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    29ce:	80 91 22 3e 	lds	r24, 0x3E22
    29d2:	90 91 23 3e 	lds	r25, 0x3E23
    29d6:	03 96       	adiw	r24, 0x03	; 3
    29d8:	80 93 22 3e 	sts	0x3E22, r24
    29dc:	90 93 23 3e 	sts	0x3E23, r25
	checksumADC[0] += SPIBuffer[0];
    29e0:	80 91 12 21 	lds	r24, 0x2112
    29e4:	e5 e2       	ldi	r30, 0x25	; 37
    29e6:	fe e3       	ldi	r31, 0x3E	; 62
    29e8:	90 81       	ld	r25, Z
    29ea:	89 0f       	add	r24, r25
    29ec:	80 93 12 21 	sts	0x2112, r24
	checksumADC[1] += SPIBuffer[1];
    29f0:	80 91 13 21 	lds	r24, 0x2113
    29f4:	91 81       	ldd	r25, Z+1	; 0x01
    29f6:	89 0f       	add	r24, r25
    29f8:	80 93 13 21 	sts	0x2113, r24
	checksumADC[2] += SPIBuffer[2];
    29fc:	80 91 14 21 	lds	r24, 0x2114
    2a00:	92 81       	ldd	r25, Z+2	; 0x02
    2a02:	89 0f       	add	r24, r25
    2a04:	80 93 14 21 	sts	0x2114, r24
}
    2a08:	28 96       	adiw	r28, 0x08	; 8
    2a0a:	cd bf       	out	0x3d, r28	; 61
    2a0c:	de bf       	out	0x3e, r29	; 62
    2a0e:	df 91       	pop	r29
    2a10:	cf 91       	pop	r28
    2a12:	1f 91       	pop	r17
    2a14:	0f 91       	pop	r16
    2a16:	ff 90       	pop	r15
    2a18:	08 95       	ret

00002a1a <FRAMWriteKnowns>:
// 	}
// 	
// }

//test function for FRAM
void FRAMWriteKnowns() {
    2a1a:	2f 92       	push	r2
    2a1c:	3f 92       	push	r3
    2a1e:	4f 92       	push	r4
    2a20:	5f 92       	push	r5
    2a22:	6f 92       	push	r6
    2a24:	7f 92       	push	r7
    2a26:	8f 92       	push	r8
    2a28:	9f 92       	push	r9
    2a2a:	af 92       	push	r10
    2a2c:	bf 92       	push	r11
    2a2e:	cf 92       	push	r12
    2a30:	df 92       	push	r13
    2a32:	ef 92       	push	r14
    2a34:	ff 92       	push	r15
    2a36:	0f 93       	push	r16
    2a38:	1f 93       	push	r17
    2a3a:	cf 93       	push	r28
    2a3c:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    2a3e:	10 92 22 3e 	sts	0x3E22, r1
    2a42:	10 92 23 3e 	sts	0x3E23, r1
	sampleCount = 0;
    2a46:	10 92 6a 50 	sts	0x506A, r1
    2a4a:	10 92 6b 50 	sts	0x506B, r1
    2a4e:	10 92 6c 50 	sts	0x506C, r1
    2a52:	10 92 6d 50 	sts	0x506D, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2a56:	84 e1       	ldi	r24, 0x14	; 20
    2a58:	91 e2       	ldi	r25, 0x21	; 33
    2a5a:	10 92 14 21 	sts	0x2114, r1
    2a5e:	fc 01       	movw	r30, r24
    2a60:	31 97       	sbiw	r30, 0x01	; 1
    2a62:	10 82       	st	Z, r1
    2a64:	02 97       	sbiw	r24, 0x02	; 2
    2a66:	dc 01       	movw	r26, r24
    2a68:	1c 92       	st	X, r1
	
	ADCPower(TRUE);
    2a6a:	81 e0       	ldi	r24, 0x01	; 1
    2a6c:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    2a70:	84 e0       	ldi	r24, 0x04	; 4
    2a72:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2a76:	80 ed       	ldi	r24, 0xD0	; 208
    2a78:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    2a7c:	8d e0       	ldi	r24, 0x0D	; 13
    2a7e:	80 93 25 3e 	sts	0x3E25, r24
	SPIBuffer[1] = 0xF3;
    2a82:	83 ef       	ldi	r24, 0xF3	; 243
    2a84:	80 93 26 3e 	sts	0x3E26, r24
	SPIBuffer[2] = 0x57;
    2a88:	87 e5       	ldi	r24, 0x57	; 87
    2a8a:	80 93 27 3e 	sts	0x3E27, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    2a8e:	80 91 6a 50 	lds	r24, 0x506A
    2a92:	90 91 6b 50 	lds	r25, 0x506B
    2a96:	a0 91 6c 50 	lds	r26, 0x506C
    2a9a:	b0 91 6d 50 	lds	r27, 0x506D
    2a9e:	83 35       	cpi	r24, 0x53	; 83
    2aa0:	e5 e5       	ldi	r30, 0x55	; 85
    2aa2:	9e 07       	cpc	r25, r30
    2aa4:	e0 e0       	ldi	r30, 0x00	; 0
    2aa6:	ae 07       	cpc	r26, r30
    2aa8:	e0 e0       	ldi	r30, 0x00	; 0
    2aaa:	be 07       	cpc	r27, r30
    2aac:	08 f0       	brcs	.+2      	; 0x2ab0 <FRAMWriteKnowns+0x96>
    2aae:	cc c0       	rjmp	.+408    	; 0x2c48 <FRAMWriteKnowns+0x22e>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2ab0:	0f 2e       	mov	r0, r31
    2ab2:	f0 e4       	ldi	r31, 0x40	; 64
    2ab4:	ef 2e       	mov	r14, r31
    2ab6:	f6 e0       	ldi	r31, 0x06	; 6
    2ab8:	ff 2e       	mov	r15, r31
    2aba:	f0 2d       	mov	r31, r0
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2abc:	40 e2       	ldi	r20, 0x20	; 32
    2abe:	56 e0       	ldi	r21, 0x06	; 6
    2ac0:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    2ac2:	e0 ec       	ldi	r30, 0xC0	; 192
    2ac4:	f8 e0       	ldi	r31, 0x08	; 8
    2ac6:	0f 2e       	mov	r0, r31
    2ac8:	f6 e0       	ldi	r31, 0x06	; 6
    2aca:	7f 2e       	mov	r7, r31
    2acc:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    2ace:	c1 e3       	ldi	r28, 0x31	; 49
    2ad0:	de e3       	ldi	r29, 0x3E	; 62
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    2ad2:	66 24       	eor	r6, r6
    2ad4:	68 94       	set
    2ad6:	61 f8       	bld	r6, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2ad8:	0f 2e       	mov	r0, r31
    2ada:	f2 e2       	ldi	r31, 0x22	; 34
    2adc:	cf 2e       	mov	r12, r31
    2ade:	fe e3       	ldi	r31, 0x3E	; 62
    2ae0:	df 2e       	mov	r13, r31
    2ae2:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    2ae4:	8e 01       	movw	r16, r28
    2ae6:	0c 50       	subi	r16, 0x0C	; 12
    2ae8:	10 40       	sbci	r17, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    2aea:	0f 2e       	mov	r0, r31
    2aec:	f5 ef       	ldi	r31, 0xF5	; 245
    2aee:	4f 2e       	mov	r4, r31
    2af0:	ff ef       	ldi	r31, 0xFF	; 255
    2af2:	5f 2e       	mov	r5, r31
    2af4:	f0 2d       	mov	r31, r0
    2af6:	4c 0e       	add	r4, r28
    2af8:	5d 1e       	adc	r5, r29
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    2afa:	0f 2e       	mov	r0, r31
    2afc:	f6 ef       	ldi	r31, 0xF6	; 246
    2afe:	2f 2e       	mov	r2, r31
    2b00:	ff ef       	ldi	r31, 0xFF	; 255
    2b02:	3f 2e       	mov	r3, r31
    2b04:	f0 2d       	mov	r31, r0
    2b06:	2c 0e       	add	r2, r28
    2b08:	3d 1e       	adc	r3, r29
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    2b0a:	62 e1       	ldi	r22, 0x12	; 18
    2b0c:	71 e2       	ldi	r23, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    2b0e:	5b 01       	movw	r10, r22
    2b10:	08 94       	sec
    2b12:	a1 1c       	adc	r10, r1
    2b14:	b1 1c       	adc	r11, r1
		checksumADC[2] += SPIBuffer[2];
    2b16:	88 24       	eor	r8, r8
    2b18:	99 24       	eor	r9, r9
    2b1a:	68 94       	set
    2b1c:	81 f8       	bld	r8, 1
    2b1e:	86 0e       	add	r8, r22
    2b20:	97 1e       	adc	r9, r23
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2b22:	30 e1       	ldi	r19, 0x10	; 16
    2b24:	d7 01       	movw	r26, r14
    2b26:	16 96       	adiw	r26, 0x06	; 6
    2b28:	3c 93       	st	X, r19
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2b2a:	da 01       	movw	r26, r20
    2b2c:	16 96       	adiw	r26, 0x06	; 6
    2b2e:	2c 93       	st	X, r18
    2b30:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    2b32:	00 00       	nop
		SPIC.DATA = FR_WREN;
    2b34:	73 82       	std	Z+3, r7	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2b36:	82 81       	ldd	r24, Z+2	; 0x02
    2b38:	88 23       	and	r24, r24
    2b3a:	ec f7       	brge	.-6      	; 0x2b36 <FRAMWriteKnowns+0x11c>
		SPIBuffer[12] = SPIC.DATA;
    2b3c:	83 81       	ldd	r24, Z+3	; 0x03
    2b3e:	88 83       	st	Y, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    2b40:	da 01       	movw	r26, r20
    2b42:	15 96       	adiw	r26, 0x05	; 5
    2b44:	2c 93       	st	X, r18
    2b46:	15 97       	sbiw	r26, 0x05	; 5
		nop(); // time for CS_FRAM to accept high signal
    2b48:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2b4a:	16 96       	adiw	r26, 0x06	; 6
    2b4c:	2c 93       	st	X, r18
    2b4e:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    2b50:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    2b52:	63 82       	std	Z+3, r6	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2b54:	82 81       	ldd	r24, Z+2	; 0x02
    2b56:	88 23       	and	r24, r24
    2b58:	ec f7       	brge	.-6      	; 0x2b54 <FRAMWriteKnowns+0x13a>
		SPIBuffer[12] = SPIC.DATA;
    2b5a:	83 81       	ldd	r24, Z+3	; 0x03
    2b5c:	88 83       	st	Y, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2b5e:	d6 01       	movw	r26, r12
    2b60:	11 96       	adiw	r26, 0x01	; 1
    2b62:	8c 91       	ld	r24, X
    2b64:	11 97       	sbiw	r26, 0x01	; 1
    2b66:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2b68:	82 81       	ldd	r24, Z+2	; 0x02
    2b6a:	88 23       	and	r24, r24
    2b6c:	ec f7       	brge	.-6      	; 0x2b68 <FRAMWriteKnowns+0x14e>
		SPIBuffer[12] = SPIC.DATA;
    2b6e:	83 81       	ldd	r24, Z+3	; 0x03
    2b70:	88 83       	st	Y, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2b72:	d6 01       	movw	r26, r12
    2b74:	8c 91       	ld	r24, X
    2b76:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2b78:	82 81       	ldd	r24, Z+2	; 0x02
    2b7a:	88 23       	and	r24, r24
    2b7c:	ec f7       	brge	.-6      	; 0x2b78 <FRAMWriteKnowns+0x15e>
		SPIBuffer[12] = SPIC.DATA;
    2b7e:	83 81       	ldd	r24, Z+3	; 0x03
    2b80:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[0];
    2b82:	d8 01       	movw	r26, r16
    2b84:	8c 91       	ld	r24, X
    2b86:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2b88:	82 81       	ldd	r24, Z+2	; 0x02
    2b8a:	88 23       	and	r24, r24
    2b8c:	ec f7       	brge	.-6      	; 0x2b88 <FRAMWriteKnowns+0x16e>
		SPIBuffer[12] = SPIC.DATA;
    2b8e:	83 81       	ldd	r24, Z+3	; 0x03
    2b90:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[1];
    2b92:	d2 01       	movw	r26, r4
    2b94:	8c 91       	ld	r24, X
    2b96:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2b98:	82 81       	ldd	r24, Z+2	; 0x02
    2b9a:	88 23       	and	r24, r24
    2b9c:	ec f7       	brge	.-6      	; 0x2b98 <FRAMWriteKnowns+0x17e>
		SPIBuffer[12] = SPIC.DATA;
    2b9e:	83 81       	ldd	r24, Z+3	; 0x03
    2ba0:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[2];
    2ba2:	d1 01       	movw	r26, r2
    2ba4:	8c 91       	ld	r24, X
    2ba6:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2ba8:	82 81       	ldd	r24, Z+2	; 0x02
    2baa:	88 23       	and	r24, r24
    2bac:	ec f7       	brge	.-6      	; 0x2ba8 <FRAMWriteKnowns+0x18e>
		SPIBuffer[12] = SPIC.DATA;
    2bae:	83 81       	ldd	r24, Z+3	; 0x03
    2bb0:	88 83       	st	Y, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2bb2:	da 01       	movw	r26, r20
    2bb4:	15 96       	adiw	r26, 0x05	; 5
    2bb6:	2c 93       	st	X, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2bb8:	30 e1       	ldi	r19, 0x10	; 16
    2bba:	d7 01       	movw	r26, r14
    2bbc:	15 96       	adiw	r26, 0x05	; 5
    2bbe:	3c 93       	st	X, r19
		
		FRAMAddress +=3;
    2bc0:	80 91 22 3e 	lds	r24, 0x3E22
    2bc4:	90 91 23 3e 	lds	r25, 0x3E23
    2bc8:	03 96       	adiw	r24, 0x03	; 3
    2bca:	80 93 22 3e 	sts	0x3E22, r24
    2bce:	90 93 23 3e 	sts	0x3E23, r25
		checksumADC[0] += SPIBuffer[0];
    2bd2:	db 01       	movw	r26, r22
    2bd4:	8c 91       	ld	r24, X
    2bd6:	d8 01       	movw	r26, r16
    2bd8:	9c 91       	ld	r25, X
    2bda:	89 0f       	add	r24, r25
    2bdc:	db 01       	movw	r26, r22
    2bde:	8c 93       	st	X, r24
		checksumADC[1] += SPIBuffer[1];
    2be0:	d5 01       	movw	r26, r10
    2be2:	8c 91       	ld	r24, X
    2be4:	a6 e2       	ldi	r26, 0x26	; 38
    2be6:	be e3       	ldi	r27, 0x3E	; 62
    2be8:	9c 91       	ld	r25, X
    2bea:	89 0f       	add	r24, r25
    2bec:	d5 01       	movw	r26, r10
    2bee:	8c 93       	st	X, r24
		checksumADC[2] += SPIBuffer[2];
    2bf0:	d4 01       	movw	r26, r8
    2bf2:	8c 91       	ld	r24, X
    2bf4:	a7 e2       	ldi	r26, 0x27	; 39
    2bf6:	be e3       	ldi	r27, 0x3E	; 62
    2bf8:	9c 91       	ld	r25, X
    2bfa:	89 0f       	add	r24, r25
    2bfc:	d4 01       	movw	r26, r8
    2bfe:	8c 93       	st	X, r24
		
		sampleCount++;
    2c00:	80 91 6a 50 	lds	r24, 0x506A
    2c04:	90 91 6b 50 	lds	r25, 0x506B
    2c08:	a0 91 6c 50 	lds	r26, 0x506C
    2c0c:	b0 91 6d 50 	lds	r27, 0x506D
    2c10:	01 96       	adiw	r24, 0x01	; 1
    2c12:	a1 1d       	adc	r26, r1
    2c14:	b1 1d       	adc	r27, r1
    2c16:	80 93 6a 50 	sts	0x506A, r24
    2c1a:	90 93 6b 50 	sts	0x506B, r25
    2c1e:	a0 93 6c 50 	sts	0x506C, r26
    2c22:	b0 93 6d 50 	sts	0x506D, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    2c26:	80 91 6a 50 	lds	r24, 0x506A
    2c2a:	90 91 6b 50 	lds	r25, 0x506B
    2c2e:	a0 91 6c 50 	lds	r26, 0x506C
    2c32:	b0 91 6d 50 	lds	r27, 0x506D
    2c36:	83 35       	cpi	r24, 0x53	; 83
    2c38:	35 e5       	ldi	r19, 0x55	; 85
    2c3a:	93 07       	cpc	r25, r19
    2c3c:	30 e0       	ldi	r19, 0x00	; 0
    2c3e:	a3 07       	cpc	r26, r19
    2c40:	30 e0       	ldi	r19, 0x00	; 0
    2c42:	b3 07       	cpc	r27, r19
    2c44:	08 f4       	brcc	.+2      	; 0x2c48 <FRAMWriteKnowns+0x22e>
    2c46:	6d cf       	rjmp	.-294    	; 0x2b22 <FRAMWriteKnowns+0x108>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    2c48:	0e 94 19 04 	call	0x832	; 0x832 <SPIDisable>
	ADCPower(FALSE);
    2c4c:	80 e0       	ldi	r24, 0x00	; 0
    2c4e:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <ADCPower>
}
    2c52:	df 91       	pop	r29
    2c54:	cf 91       	pop	r28
    2c56:	1f 91       	pop	r17
    2c58:	0f 91       	pop	r16
    2c5a:	ff 90       	pop	r15
    2c5c:	ef 90       	pop	r14
    2c5e:	df 90       	pop	r13
    2c60:	cf 90       	pop	r12
    2c62:	bf 90       	pop	r11
    2c64:	af 90       	pop	r10
    2c66:	9f 90       	pop	r9
    2c68:	8f 90       	pop	r8
    2c6a:	7f 90       	pop	r7
    2c6c:	6f 90       	pop	r6
    2c6e:	5f 90       	pop	r5
    2c70:	4f 90       	pop	r4
    2c72:	3f 90       	pop	r3
    2c74:	2f 90       	pop	r2
    2c76:	08 95       	ret

00002c78 <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    2c78:	80 ff       	sbrs	r24, 0
    2c7a:	05 c0       	rjmp	.+10     	; 0x2c86 <setADCInput+0xe>
    2c7c:	20 e4       	ldi	r18, 0x40	; 64
    2c7e:	e0 e0       	ldi	r30, 0x00	; 0
    2c80:	f6 e0       	ldi	r31, 0x06	; 6
    2c82:	25 83       	std	Z+5, r18	; 0x05
    2c84:	04 c0       	rjmp	.+8      	; 0x2c8e <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    2c86:	20 e4       	ldi	r18, 0x40	; 64
    2c88:	e0 e0       	ldi	r30, 0x00	; 0
    2c8a:	f6 e0       	ldi	r31, 0x06	; 6
    2c8c:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    2c8e:	81 ff       	sbrs	r24, 1
    2c90:	05 c0       	rjmp	.+10     	; 0x2c9c <setADCInput+0x24>
    2c92:	22 e0       	ldi	r18, 0x02	; 2
    2c94:	e0 e2       	ldi	r30, 0x20	; 32
    2c96:	f6 e0       	ldi	r31, 0x06	; 6
    2c98:	25 83       	std	Z+5, r18	; 0x05
    2c9a:	04 c0       	rjmp	.+8      	; 0x2ca4 <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    2c9c:	22 e0       	ldi	r18, 0x02	; 2
    2c9e:	e0 e2       	ldi	r30, 0x20	; 32
    2ca0:	f6 e0       	ldi	r31, 0x06	; 6
    2ca2:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    2ca4:	82 ff       	sbrs	r24, 2
    2ca6:	05 c0       	rjmp	.+10     	; 0x2cb2 <setADCInput+0x3a>
    2ca8:	84 e0       	ldi	r24, 0x04	; 4
    2caa:	e0 e2       	ldi	r30, 0x20	; 32
    2cac:	f6 e0       	ldi	r31, 0x06	; 6
    2cae:	85 83       	std	Z+5, r24	; 0x05
    2cb0:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    2cb2:	84 e0       	ldi	r24, 0x04	; 4
    2cb4:	e0 e2       	ldi	r30, 0x20	; 32
    2cb6:	f6 e0       	ldi	r31, 0x06	; 6
    2cb8:	86 83       	std	Z+6, r24	; 0x06
    2cba:	08 95       	ret

00002cbc <CO_collectSeismic1Channel_ext>:
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2cbc:	2f 92       	push	r2
    2cbe:	3f 92       	push	r3
    2cc0:	4f 92       	push	r4
    2cc2:	5f 92       	push	r5
    2cc4:	7f 92       	push	r7
    2cc6:	8f 92       	push	r8
    2cc8:	9f 92       	push	r9
    2cca:	af 92       	push	r10
    2ccc:	bf 92       	push	r11
    2cce:	cf 92       	push	r12
    2cd0:	df 92       	push	r13
    2cd2:	ef 92       	push	r14
    2cd4:	ff 92       	push	r15
    2cd6:	0f 93       	push	r16
    2cd8:	1f 93       	push	r17
    2cda:	cf 93       	push	r28
    2cdc:	df 93       	push	r29
    2cde:	cd b7       	in	r28, 0x3d	; 61
    2ce0:	de b7       	in	r29, 0x3e	; 62
    2ce2:	18 2f       	mov	r17, r24
    2ce4:	76 2e       	mov	r7, r22
    2ce6:	f4 2e       	mov	r15, r20
    2ce8:	19 01       	movw	r2, r18
	
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	ADC_BUFFER=DataArray;
    2cea:	89 8d       	ldd	r24, Y+25	; 0x19
    2cec:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2cee:	80 93 68 50 	sts	0x5068, r24
    2cf2:	90 93 69 50 	sts	0x5069, r25
	ADC_Sampling_Finished = 0;
    2cf6:	10 92 ab 50 	sts	0x50AB, r1
	ADC_buffer_size = BufferSize;
    2cfa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2cfc:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2cfe:	80 93 ac 50 	sts	0x50AC, r24
    2d02:	90 93 ad 50 	sts	0x50AD, r25
	if(use_FRAM){
    2d06:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2d08:	88 23       	and	r24, r24
    2d0a:	21 f0       	breq	.+8      	; 0x2d14 <CO_collectSeismic1Channel_ext+0x58>
		write_to_FRAM = 1;
    2d0c:	81 e0       	ldi	r24, 0x01	; 1
    2d0e:	80 93 4d 40 	sts	0x404D, r24
    2d12:	02 c0       	rjmp	.+4      	; 0x2d18 <CO_collectSeismic1Channel_ext+0x5c>
	}
	else{
		write_to_FRAM = 0;
    2d14:	10 92 4d 40 	sts	0x404D, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2d18:	81 e0       	ldi	r24, 0x01	; 1
    2d1a:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2d1e:	81 2f       	mov	r24, r17
    2d20:	6f 2d       	mov	r22, r15
    2d22:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <set_ampGain>
	set_filter(filterConfig);
    2d26:	87 2d       	mov	r24, r7
    2d28:	0e 94 23 04 	call	0x846	; 0x846 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2d2c:	8e 2d       	mov	r24, r14
    2d2e:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2d32:	84 e0       	ldi	r24, 0x04	; 4
    2d34:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2d38:	84 e5       	ldi	r24, 0x54	; 84
    2d3a:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2d3e:	81 e0       	ldi	r24, 0x01	; 1
    2d40:	0e 94 b3 0c 	call	0x1966	; 0x1966 <enableADCMUX>
	setADCInput(channel);
    2d44:	81 2f       	mov	r24, r17
    2d46:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2d4a:	e0 ea       	ldi	r30, 0xA0	; 160
    2d4c:	f6 e0       	ldi	r31, 0x06	; 6
    2d4e:	22 e0       	ldi	r18, 0x02	; 2
    2d50:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2d52:	77 24       	eor	r7, r7
    2d54:	73 94       	inc	r7
    2d56:	72 82       	std	Z+2, r7	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2d58:	0f 2e       	mov	r0, r31
    2d5a:	f0 e8       	ldi	r31, 0x80	; 128
    2d5c:	4f 2e       	mov	r4, r31
    2d5e:	f1 e0       	ldi	r31, 0x01	; 1
    2d60:	5f 2e       	mov	r5, r31
    2d62:	f0 2d       	mov	r31, r0
    2d64:	88 e7       	ldi	r24, 0x78	; 120
    2d66:	d2 01       	movw	r26, r4
    2d68:	8c 93       	st	X, r24

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2d6a:	e0 e0       	ldi	r30, 0x00	; 0
    2d6c:	f9 e0       	ldi	r31, 0x09	; 9
    2d6e:	80 ef       	ldi	r24, 0xF0	; 240
    2d70:	81 83       	std	Z+1, r24	; 0x01
	TCD0.CCA = averagingPtA;
    2d72:	c0 a6       	lds	r28, 0xb0
    2d74:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    2d76:	a2 a6       	lds	r26, 0xb2
    2d78:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    2d7a:	84 a6       	lds	r24, 0xb4
    2d7c:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    2d7e:	8d 89       	ldd	r24, Y+21	; 0x15
    2d80:	9e 89       	ldd	r25, Y+22	; 0x16
    2d82:	86 a7       	lds	r24, 0x76
    2d84:	97 a7       	lds	r25, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    2d86:	80 2f       	mov	r24, r16
    2d88:	90 e0       	ldi	r25, 0x00	; 0
    2d8a:	01 97       	sbiw	r24, 0x01	; 1
    2d8c:	86 a3       	lds	r24, 0x56
    2d8e:	97 a3       	lds	r25, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2d90:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2d92:	8f ef       	ldi	r24, 0xFF	; 255
    2d94:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2d96:	80 81       	ld	r24, Z
    2d98:	80 7f       	andi	r24, 0xF0	; 240
    2d9a:	88 60       	ori	r24, 0x08	; 8
    2d9c:	80 83       	st	Z, r24

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    2d9e:	10 92 6a 50 	sts	0x506A, r1
    2da2:	10 92 6b 50 	sts	0x506B, r1
    2da6:	10 92 6c 50 	sts	0x506C, r1
    2daa:	10 92 6d 50 	sts	0x506D, r1
	SPICount = 0;
    2dae:	10 92 a5 50 	sts	0x50A5, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2db2:	80 e2       	ldi	r24, 0x20	; 32
    2db4:	e0 e8       	ldi	r30, 0x80	; 128
    2db6:	f6 e0       	ldi	r31, 0x06	; 6
    2db8:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2dba:	00 e4       	ldi	r16, 0x40	; 64
    2dbc:	1a e0       	ldi	r17, 0x0A	; 10
    2dbe:	83 e2       	ldi	r24, 0x23	; 35
    2dc0:	f8 01       	movw	r30, r16
    2dc2:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2dc4:	61 01       	movw	r12, r2
    2dc6:	ee 24       	eor	r14, r14
    2dc8:	ff 24       	eor	r15, r15
    2dca:	60 e8       	ldi	r22, 0x80	; 128
    2dcc:	74 e8       	ldi	r23, 0x84	; 132
    2dce:	8e e1       	ldi	r24, 0x1E	; 30
    2dd0:	90 e0       	ldi	r25, 0x00	; 0
    2dd2:	a7 01       	movw	r20, r14
    2dd4:	96 01       	movw	r18, r12
    2dd6:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    2dda:	d8 01       	movw	r26, r16
    2ddc:	96 96       	adiw	r26, 0x26	; 38
    2dde:	2d 93       	st	X+, r18
    2de0:	3c 93       	st	X, r19
    2de2:	97 97       	sbiw	r26, 0x27	; 39
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2de4:	60 e4       	ldi	r22, 0x40	; 64
    2de6:	72 e4       	ldi	r23, 0x42	; 66
    2de8:	8f e0       	ldi	r24, 0x0F	; 15
    2dea:	90 e0       	ldi	r25, 0x00	; 0
    2dec:	a7 01       	movw	r20, r14
    2dee:	96 01       	movw	r18, r12
    2df0:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    2df4:	f8 01       	movw	r30, r16
    2df6:	22 af       	sts	0x72, r18
    2df8:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2dfa:	e0 e4       	ldi	r30, 0x40	; 64
    2dfc:	f8 e0       	ldi	r31, 0x08	; 8
    2dfe:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;	
    2e00:	8c e0       	ldi	r24, 0x0C	; 12
    2e02:	81 87       	std	Z+9, r24	; 0x09
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2e04:	8f 89       	ldd	r24, Y+23	; 0x17
    2e06:	98 8d       	ldd	r25, Y+24	; 0x18
    2e08:	86 a3       	lds	r24, 0x56
    2e0a:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    2e0c:	80 ed       	ldi	r24, 0xD0	; 208
    2e0e:	d2 01       	movw	r26, r4
    2e10:	11 96       	adiw	r26, 0x01	; 1
    2e12:	8c 93       	st	X, r24
    2e14:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2e16:	76 82       	std	Z+6, r7	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2e18:	80 81       	ld	r24, Z
    2e1a:	80 7f       	andi	r24, 0xF0	; 240
    2e1c:	89 60       	ori	r24, 0x09	; 9
    2e1e:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2e20:	f8 01       	movw	r30, r16
    2e22:	80 81       	ld	r24, Z
    2e24:	80 7f       	andi	r24, 0xF0	; 240
    2e26:	81 60       	ori	r24, 0x01	; 1
    2e28:	80 83       	st	Z, r24
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm;
    2e2a:	e0 ea       	ldi	r30, 0xA0	; 160
    2e2c:	f0 e0       	ldi	r31, 0x00	; 0
    2e2e:	82 81       	ldd	r24, Z+2	; 0x02
    2e30:	87 60       	ori	r24, 0x07	; 7
    2e32:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2e34:	78 94       	sei
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    2e36:	df 91       	pop	r29
    2e38:	cf 91       	pop	r28
    2e3a:	1f 91       	pop	r17
    2e3c:	0f 91       	pop	r16
    2e3e:	ff 90       	pop	r15
    2e40:	ef 90       	pop	r14
    2e42:	df 90       	pop	r13
    2e44:	cf 90       	pop	r12
    2e46:	bf 90       	pop	r11
    2e48:	af 90       	pop	r10
    2e4a:	9f 90       	pop	r9
    2e4c:	8f 90       	pop	r8
    2e4e:	7f 90       	pop	r7
    2e50:	5f 90       	pop	r5
    2e52:	4f 90       	pop	r4
    2e54:	3f 90       	pop	r3
    2e56:	2f 90       	pop	r2
    2e58:	08 95       	ret

00002e5a <CO_collectSeismic1Channel>:
	sampleCount++;

}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2e5a:	2f 92       	push	r2
    2e5c:	3f 92       	push	r3
    2e5e:	4f 92       	push	r4
    2e60:	5f 92       	push	r5
    2e62:	6f 92       	push	r6
    2e64:	7f 92       	push	r7
    2e66:	8f 92       	push	r8
    2e68:	9f 92       	push	r9
    2e6a:	af 92       	push	r10
    2e6c:	bf 92       	push	r11
    2e6e:	cf 92       	push	r12
    2e70:	df 92       	push	r13
    2e72:	ef 92       	push	r14
    2e74:	ff 92       	push	r15
    2e76:	0f 93       	push	r16
    2e78:	cf 93       	push	r28
    2e7a:	df 93       	push	r29
    2e7c:	0f 92       	push	r0
    2e7e:	0f 92       	push	r0
    2e80:	cd b7       	in	r28, 0x3d	; 61
    2e82:	de b7       	in	r29, 0x3e	; 62
    2e84:	96 2f       	mov	r25, r22
    2e86:	49 83       	std	Y+1, r20	; 0x01
    2e88:	5a 83       	std	Y+2, r21	; 0x02
    2e8a:	52 2f       	mov	r21, r18
    2e8c:	70 2f       	mov	r23, r16
    2e8e:	37 01       	movw	r6, r14
    2e90:	26 01       	movw	r4, r12
    2e92:	15 01       	movw	r2, r10
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    2e94:	2d b7       	in	r18, 0x3d	; 61
    2e96:	3e b7       	in	r19, 0x3e	; 62
    2e98:	29 50       	subi	r18, 0x09	; 9
    2e9a:	30 40       	sbci	r19, 0x00	; 0
    2e9c:	2d bf       	out	0x3d, r18	; 61
    2e9e:	3e bf       	out	0x3e, r19	; 62
    2ea0:	ed b7       	in	r30, 0x3d	; 61
    2ea2:	fe b7       	in	r31, 0x3e	; 62
    2ea4:	31 96       	adiw	r30, 0x01	; 1
    2ea6:	ad b7       	in	r26, 0x3d	; 61
    2ea8:	be b7       	in	r27, 0x3e	; 62
    2eaa:	11 96       	adiw	r26, 0x01	; 1
    2eac:	8d 92       	st	X+, r8
    2eae:	9c 92       	st	X, r9
    2eb0:	12 97       	sbiw	r26, 0x02	; 2
    2eb2:	2f 89       	ldd	r18, Y+23	; 0x17
    2eb4:	38 8d       	ldd	r19, Y+24	; 0x18
    2eb6:	22 83       	std	Z+2, r18	; 0x02
    2eb8:	33 83       	std	Z+3, r19	; 0x03
    2eba:	29 8d       	ldd	r18, Y+25	; 0x19
    2ebc:	3a 8d       	ldd	r19, Y+26	; 0x1a
    2ebe:	24 83       	std	Z+4, r18	; 0x04
    2ec0:	35 83       	std	Z+5, r19	; 0x05
    2ec2:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2ec4:	3c 8d       	ldd	r19, Y+28	; 0x1c
    2ec6:	26 83       	std	Z+6, r18	; 0x06
    2ec8:	37 83       	std	Z+7, r19	; 0x07
    2eca:	2d 8d       	ldd	r18, Y+29	; 0x1d
    2ecc:	20 87       	std	Z+8, r18	; 0x08
    2ece:	64 ec       	ldi	r22, 0xC4	; 196
    2ed0:	49 2f       	mov	r20, r25
    2ed2:	29 81       	ldd	r18, Y+1	; 0x01
    2ed4:	3a 81       	ldd	r19, Y+2	; 0x02
    2ed6:	05 2f       	mov	r16, r21
    2ed8:	e7 2e       	mov	r14, r23
    2eda:	63 01       	movw	r12, r6
    2edc:	52 01       	movw	r10, r4
    2ede:	41 01       	movw	r8, r2
    2ee0:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <CO_collectSeismic1Channel_ext>
    2ee4:	2d b7       	in	r18, 0x3d	; 61
    2ee6:	3e b7       	in	r19, 0x3e	; 62
    2ee8:	27 5f       	subi	r18, 0xF7	; 247
    2eea:	3f 4f       	sbci	r19, 0xFF	; 255
    2eec:	2d bf       	out	0x3d, r18	; 61
    2eee:	3e bf       	out	0x3e, r19	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}
    2ef0:	0f 90       	pop	r0
    2ef2:	0f 90       	pop	r0
    2ef4:	df 91       	pop	r29
    2ef6:	cf 91       	pop	r28
    2ef8:	0f 91       	pop	r16
    2efa:	ff 90       	pop	r15
    2efc:	ef 90       	pop	r14
    2efe:	df 90       	pop	r13
    2f00:	cf 90       	pop	r12
    2f02:	bf 90       	pop	r11
    2f04:	af 90       	pop	r10
    2f06:	9f 90       	pop	r9
    2f08:	8f 90       	pop	r8
    2f0a:	7f 90       	pop	r7
    2f0c:	6f 90       	pop	r6
    2f0e:	5f 90       	pop	r5
    2f10:	4f 90       	pop	r4
    2f12:	3f 90       	pop	r3
    2f14:	2f 90       	pop	r2
    2f16:	08 95       	ret

00002f18 <CO_collectSeismic3Axises_ext>:
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}	
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2f18:	2f 92       	push	r2
    2f1a:	3f 92       	push	r3
    2f1c:	5f 92       	push	r5
    2f1e:	6f 92       	push	r6
    2f20:	7f 92       	push	r7
    2f22:	8f 92       	push	r8
    2f24:	9f 92       	push	r9
    2f26:	af 92       	push	r10
    2f28:	bf 92       	push	r11
    2f2a:	cf 92       	push	r12
    2f2c:	df 92       	push	r13
    2f2e:	ef 92       	push	r14
    2f30:	ff 92       	push	r15
    2f32:	0f 93       	push	r16
    2f34:	1f 93       	push	r17
    2f36:	cf 93       	push	r28
    2f38:	df 93       	push	r29
    2f3a:	0f 92       	push	r0
    2f3c:	0f 92       	push	r0
    2f3e:	cd b7       	in	r28, 0x3d	; 61
    2f40:	de b7       	in	r29, 0x3e	; 62
    2f42:	18 2f       	mov	r17, r24
    2f44:	3b 01       	movw	r6, r22
    2f46:	49 83       	std	Y+1, r20	; 0x01
    2f48:	5a 83       	std	Y+2, r21	; 0x02
    2f4a:	52 2e       	mov	r5, r18
	
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	ADC_BUFFER = DataArray;
    2f4c:	89 8d       	ldd	r24, Y+25	; 0x19
    2f4e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2f50:	80 93 68 50 	sts	0x5068, r24
    2f54:	90 93 69 50 	sts	0x5069, r25
	ADC_Sampling_Finished = 0;
    2f58:	10 92 ab 50 	sts	0x50AB, r1
	ADC_buffer_size = BufferSize;
    2f5c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2f5e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2f60:	80 93 ac 50 	sts	0x50AC, r24
    2f64:	90 93 ad 50 	sts	0x50AD, r25
	if(use_FRAM){
    2f68:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2f6a:	88 23       	and	r24, r24
    2f6c:	21 f0       	breq	.+8      	; 0x2f76 <CO_collectSeismic3Axises_ext+0x5e>
		write_to_FRAM = 1;
    2f6e:	81 e0       	ldi	r24, 0x01	; 1
    2f70:	80 93 4d 40 	sts	0x404D, r24
    2f74:	02 c0       	rjmp	.+4      	; 0x2f7a <CO_collectSeismic3Axises_ext+0x62>
	}
	else{
		write_to_FRAM = 0;
    2f76:	10 92 4d 40 	sts	0x404D, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2f7a:	81 e0       	ldi	r24, 0x01	; 1
    2f7c:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2f80:	85 e0       	ldi	r24, 0x05	; 5
    2f82:	d3 01       	movw	r26, r6
    2f84:	6c 91       	ld	r22, X
    2f86:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    2f8a:	86 e0       	ldi	r24, 0x06	; 6
    2f8c:	f3 01       	movw	r30, r6
    2f8e:	61 81       	ldd	r22, Z+1	; 0x01
    2f90:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2f94:	87 e0       	ldi	r24, 0x07	; 7
    2f96:	d3 01       	movw	r26, r6
    2f98:	12 96       	adiw	r26, 0x02	; 2
    2f9a:	6c 91       	ld	r22, X
    2f9c:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <set_ampGain>
	set_filter(filterConfig);
    2fa0:	81 2f       	mov	r24, r17
    2fa2:	0e 94 23 04 	call	0x846	; 0x846 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2fa6:	80 2f       	mov	r24, r16
    2fa8:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2fac:	84 e0       	ldi	r24, 0x04	; 4
    2fae:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2fb2:	84 e5       	ldi	r24, 0x54	; 84
    2fb4:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2fb8:	81 e0       	ldi	r24, 0x01	; 1
    2fba:	0e 94 b3 0c 	call	0x1966	; 0x1966 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    2fbe:	85 e0       	ldi	r24, 0x05	; 5
    2fc0:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2fc4:	e0 ea       	ldi	r30, 0xA0	; 160
    2fc6:	f6 e0       	ldi	r31, 0x06	; 6
    2fc8:	22 e0       	ldi	r18, 0x02	; 2
    2fca:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2fcc:	66 24       	eor	r6, r6
    2fce:	63 94       	inc	r6
    2fd0:	62 82       	std	Z+2, r6	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2fd2:	0f 2e       	mov	r0, r31
    2fd4:	f0 e8       	ldi	r31, 0x80	; 128
    2fd6:	2f 2e       	mov	r2, r31
    2fd8:	f1 e0       	ldi	r31, 0x01	; 1
    2fda:	3f 2e       	mov	r3, r31
    2fdc:	f0 2d       	mov	r31, r0
    2fde:	88 e7       	ldi	r24, 0x78	; 120
    2fe0:	f1 01       	movw	r30, r2
    2fe2:	80 83       	st	Z, r24

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2fe4:	e0 e0       	ldi	r30, 0x00	; 0
    2fe6:	f8 e0       	ldi	r31, 0x08	; 8
    2fe8:	80 ef       	ldi	r24, 0xF0	; 240
    2fea:	81 83       	std	Z+1, r24	; 0x01
	TCC0.CCA = averagingPtA;
    2fec:	e0 a6       	lds	r30, 0xb0
    2fee:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    2ff0:	c2 a6       	lds	r28, 0xb2
    2ff2:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    2ff4:	a4 a6       	lds	r26, 0xb4
    2ff6:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    2ff8:	86 a6       	lds	r24, 0xb6
    2ffa:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    2ffc:	85 2d       	mov	r24, r5
    2ffe:	90 e0       	ldi	r25, 0x00	; 0
    3000:	01 97       	sbiw	r24, 0x01	; 1
    3002:	86 a3       	lds	r24, 0x56
    3004:	97 a3       	lds	r25, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    3006:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    3008:	8f ef       	ldi	r24, 0xFF	; 255
    300a:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    300c:	80 81       	ld	r24, Z
    300e:	80 7f       	andi	r24, 0xF0	; 240
    3010:	88 60       	ori	r24, 0x08	; 8
    3012:	80 83       	st	Z, r24

	sampleCount = 0;
    3014:	10 92 6a 50 	sts	0x506A, r1
    3018:	10 92 6b 50 	sts	0x506B, r1
    301c:	10 92 6c 50 	sts	0x506C, r1
    3020:	10 92 6d 50 	sts	0x506D, r1
	SPICount = 0;
    3024:	10 92 a5 50 	sts	0x50A5, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    3028:	84 e1       	ldi	r24, 0x14	; 20
    302a:	91 e2       	ldi	r25, 0x21	; 33
    302c:	10 92 14 21 	sts	0x2114, r1
    3030:	fc 01       	movw	r30, r24
    3032:	31 97       	sbiw	r30, 0x01	; 1
    3034:	10 82       	st	Z, r1
    3036:	02 97       	sbiw	r24, 0x02	; 2
    3038:	dc 01       	movw	r26, r24
    303a:	1c 92       	st	X, r1

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    303c:	80 e2       	ldi	r24, 0x20	; 32
    303e:	e0 e8       	ldi	r30, 0x80	; 128
    3040:	f6 e0       	ldi	r31, 0x06	; 6
    3042:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    3044:	00 e4       	ldi	r16, 0x40	; 64
    3046:	1a e0       	ldi	r17, 0x0A	; 10
    3048:	83 e2       	ldi	r24, 0x23	; 35
    304a:	f8 01       	movw	r30, r16
    304c:	81 83       	std	Z+1, r24	; 0x01
	// set period of waveform generator and duty cycle (want duty cycle to be half the period to get clean clock signal)
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    304e:	89 81       	ldd	r24, Y+1	; 0x01
    3050:	9a 81       	ldd	r25, Y+2	; 0x02
    3052:	6c 01       	movw	r12, r24
    3054:	ee 24       	eor	r14, r14
    3056:	ff 24       	eor	r15, r15
    3058:	60 e8       	ldi	r22, 0x80	; 128
    305a:	74 e8       	ldi	r23, 0x84	; 132
    305c:	8e e1       	ldi	r24, 0x1E	; 30
    305e:	90 e0       	ldi	r25, 0x00	; 0
    3060:	a7 01       	movw	r20, r14
    3062:	96 01       	movw	r18, r12
    3064:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    3068:	d8 01       	movw	r26, r16
    306a:	96 96       	adiw	r26, 0x26	; 38
    306c:	2d 93       	st	X+, r18
    306e:	3c 93       	st	X, r19
    3070:	97 97       	sbiw	r26, 0x27	; 39
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    3072:	60 e4       	ldi	r22, 0x40	; 64
    3074:	72 e4       	ldi	r23, 0x42	; 66
    3076:	8f e0       	ldi	r24, 0x0F	; 15
    3078:	90 e0       	ldi	r25, 0x00	; 0
    307a:	a7 01       	movw	r20, r14
    307c:	96 01       	movw	r18, r12
    307e:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    3082:	f8 01       	movw	r30, r16
    3084:	22 af       	sts	0x72, r18
    3086:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	//reset count to zero
	TCC1.CTRLA = 0x00;
    3088:	e0 e4       	ldi	r30, 0x40	; 64
    308a:	f8 e0       	ldi	r31, 0x08	; 8
    308c:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;	
    308e:	8c e0       	ldi	r24, 0x0C	; 12
    3090:	81 87       	std	Z+9, r24	; 0x09
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    3092:	8f 89       	ldd	r24, Y+23	; 0x17
    3094:	98 8d       	ldd	r25, Y+24	; 0x18
    3096:	86 a3       	lds	r24, 0x56
    3098:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
    309a:	80 ec       	ldi	r24, 0xC0	; 192
    309c:	d1 01       	movw	r26, r2
    309e:	11 96       	adiw	r26, 0x01	; 1
    30a0:	8c 93       	st	X, r24
    30a2:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    30a4:	66 82       	std	Z+6, r6	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    30a6:	80 81       	ld	r24, Z
    30a8:	80 7f       	andi	r24, 0xF0	; 240
    30aa:	89 60       	ori	r24, 0x09	; 9
    30ac:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    30ae:	f8 01       	movw	r30, r16
    30b0:	80 81       	ld	r24, Z
    30b2:	80 7f       	andi	r24, 0xF0	; 240
    30b4:	81 60       	ori	r24, 0x01	; 1
    30b6:	80 83       	st	Z, r24
	
	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm);
    30b8:	e0 ea       	ldi	r30, 0xA0	; 160
    30ba:	f0 e0       	ldi	r31, 0x00	; 0
    30bc:	82 81       	ldd	r24, Z+2	; 0x02
    30be:	87 60       	ori	r24, 0x07	; 7
    30c0:	82 83       	std	Z+2, r24	; 0x02
	sei();
    30c2:	78 94       	sei
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    30c4:	0f 90       	pop	r0
    30c6:	0f 90       	pop	r0
    30c8:	df 91       	pop	r29
    30ca:	cf 91       	pop	r28
    30cc:	1f 91       	pop	r17
    30ce:	0f 91       	pop	r16
    30d0:	ff 90       	pop	r15
    30d2:	ef 90       	pop	r14
    30d4:	df 90       	pop	r13
    30d6:	cf 90       	pop	r12
    30d8:	bf 90       	pop	r11
    30da:	af 90       	pop	r10
    30dc:	9f 90       	pop	r9
    30de:	8f 90       	pop	r8
    30e0:	7f 90       	pop	r7
    30e2:	6f 90       	pop	r6
    30e4:	5f 90       	pop	r5
    30e6:	3f 90       	pop	r3
    30e8:	2f 90       	pop	r2
    30ea:	08 95       	ret

000030ec <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    30ec:	2f 92       	push	r2
    30ee:	3f 92       	push	r3
    30f0:	4f 92       	push	r4
    30f2:	5f 92       	push	r5
    30f4:	6f 92       	push	r6
    30f6:	7f 92       	push	r7
    30f8:	8f 92       	push	r8
    30fa:	9f 92       	push	r9
    30fc:	af 92       	push	r10
    30fe:	bf 92       	push	r11
    3100:	cf 92       	push	r12
    3102:	df 92       	push	r13
    3104:	ef 92       	push	r14
    3106:	ff 92       	push	r15
    3108:	0f 93       	push	r16
    310a:	1f 93       	push	r17
    310c:	cf 93       	push	r28
    310e:	df 93       	push	r29
    3110:	00 d0       	rcall	.+0      	; 0x3112 <CO_collectSeismic3Axises+0x26>
    3112:	0f 92       	push	r0
    3114:	cd b7       	in	r28, 0x3d	; 61
    3116:	de b7       	in	r29, 0x3e	; 62
    3118:	dc 01       	movw	r26, r24
    311a:	3b 01       	movw	r6, r22
    311c:	94 2f       	mov	r25, r20
    311e:	32 2f       	mov	r19, r18
    3120:	28 01       	movw	r4, r16
    3122:	17 01       	movw	r2, r14
    3124:	c9 82       	std	Y+1, r12	; 0x01
    3126:	da 82       	std	Y+2, r13	; 0x02
    3128:	ab 82       	std	Y+3, r10	; 0x03
    312a:	bc 82       	std	Y+4, r11	; 0x04
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    312c:	4d b7       	in	r20, 0x3d	; 61
    312e:	5e b7       	in	r21, 0x3e	; 62
    3130:	47 50       	subi	r20, 0x07	; 7
    3132:	50 40       	sbci	r21, 0x00	; 0
    3134:	4d bf       	out	0x3d, r20	; 61
    3136:	5e bf       	out	0x3e, r21	; 62
    3138:	6d b7       	in	r22, 0x3d	; 61
    313a:	7e b7       	in	r23, 0x3e	; 62
    313c:	6f 5f       	subi	r22, 0xFF	; 255
    313e:	7f 4f       	sbci	r23, 0xFF	; 255
    3140:	ed b7       	in	r30, 0x3d	; 61
    3142:	fe b7       	in	r31, 0x3e	; 62
    3144:	81 82       	std	Z+1, r8	; 0x01
    3146:	92 82       	std	Z+2, r9	; 0x02
    3148:	4a 8d       	ldd	r20, Y+26	; 0x1a
    314a:	5b 8d       	ldd	r21, Y+27	; 0x1b
    314c:	fb 01       	movw	r30, r22
    314e:	42 83       	std	Z+2, r20	; 0x02
    3150:	53 83       	std	Z+3, r21	; 0x03
    3152:	4c 8d       	ldd	r20, Y+28	; 0x1c
    3154:	5d 8d       	ldd	r21, Y+29	; 0x1d
    3156:	44 83       	std	Z+4, r20	; 0x04
    3158:	55 83       	std	Z+5, r21	; 0x05
    315a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    315c:	86 83       	std	Z+6, r24	; 0x06
    315e:	84 ec       	ldi	r24, 0xC4	; 196
    3160:	bd 01       	movw	r22, r26
    3162:	a3 01       	movw	r20, r6
    3164:	29 2f       	mov	r18, r25
    3166:	03 2f       	mov	r16, r19
    3168:	72 01       	movw	r14, r4
    316a:	61 01       	movw	r12, r2
    316c:	a9 80       	ldd	r10, Y+1	; 0x01
    316e:	ba 80       	ldd	r11, Y+2	; 0x02
    3170:	8b 80       	ldd	r8, Y+3	; 0x03
    3172:	9c 80       	ldd	r9, Y+4	; 0x04
    3174:	0e 94 8c 17 	call	0x2f18	; 0x2f18 <CO_collectSeismic3Axises_ext>
    3178:	4d b7       	in	r20, 0x3d	; 61
    317a:	5e b7       	in	r21, 0x3e	; 62
    317c:	49 5f       	subi	r20, 0xF9	; 249
    317e:	5f 4f       	sbci	r21, 0xFF	; 255
    3180:	4d bf       	out	0x3d, r20	; 61
    3182:	5e bf       	out	0x3e, r21	; 62
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}	
    3184:	24 96       	adiw	r28, 0x04	; 4
    3186:	cd bf       	out	0x3d, r28	; 61
    3188:	de bf       	out	0x3e, r29	; 62
    318a:	df 91       	pop	r29
    318c:	cf 91       	pop	r28
    318e:	1f 91       	pop	r17
    3190:	0f 91       	pop	r16
    3192:	ff 90       	pop	r15
    3194:	ef 90       	pop	r14
    3196:	df 90       	pop	r13
    3198:	cf 90       	pop	r12
    319a:	bf 90       	pop	r11
    319c:	af 90       	pop	r10
    319e:	9f 90       	pop	r9
    31a0:	8f 90       	pop	r8
    31a2:	7f 90       	pop	r7
    31a4:	6f 90       	pop	r6
    31a6:	5f 90       	pop	r5
    31a8:	4f 90       	pop	r4
    31aa:	3f 90       	pop	r3
    31ac:	2f 90       	pop	r2
    31ae:	08 95       	ret

000031b0 <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    31b0:	6f 92       	push	r6
    31b2:	7f 92       	push	r7
    31b4:	8f 92       	push	r8
    31b6:	9f 92       	push	r9
    31b8:	af 92       	push	r10
    31ba:	bf 92       	push	r11
    31bc:	cf 92       	push	r12
    31be:	df 92       	push	r13
    31c0:	ef 92       	push	r14
    31c2:	ff 92       	push	r15
    31c4:	0f 93       	push	r16
    31c6:	1f 93       	push	r17
    31c8:	cf 93       	push	r28
    31ca:	df 93       	push	r29
    31cc:	c8 2f       	mov	r28, r24
    31ce:	b6 2e       	mov	r11, r22
    31d0:	d4 2f       	mov	r29, r20
    31d2:	49 01       	movw	r8, r18
    31d4:	38 01       	movw	r6, r16
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	uint16_t period;
	ADC_BUFFER = DataArray;
    31d6:	e0 92 68 50 	sts	0x5068, r14
    31da:	f0 92 69 50 	sts	0x5069, r15
	ADC_Sampling_Finished = 0;
    31de:	10 92 ab 50 	sts	0x50AB, r1
	ADC_buffer_size = BufferSize;
    31e2:	c0 92 ac 50 	sts	0x50AC, r12
    31e6:	d0 92 ad 50 	sts	0x50AD, r13
	if(use_FRAM){
    31ea:	aa 20       	and	r10, r10
    31ec:	21 f0       	breq	.+8      	; 0x31f6 <CO_collectADC_ext+0x46>
		write_to_FRAM = 1;
    31ee:	81 e0       	ldi	r24, 0x01	; 1
    31f0:	80 93 4d 40 	sts	0x404D, r24
    31f4:	02 c0       	rjmp	.+4      	; 0x31fa <CO_collectADC_ext+0x4a>
	}
	else{
		write_to_FRAM = 0;
    31f6:	10 92 4d 40 	sts	0x404D, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    31fa:	81 e0       	ldi	r24, 0x01	; 1
    31fc:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    3200:	8c 2f       	mov	r24, r28
    3202:	6d 2f       	mov	r22, r29
    3204:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <set_ampGain>
	set_filter(filterConfig);
    3208:	8b 2d       	mov	r24, r11
    320a:	0e 94 23 04 	call	0x846	; 0x846 <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    320e:	8c 2f       	mov	r24, r28
    3210:	85 50       	subi	r24, 0x05	; 5
    3212:	83 30       	cpi	r24, 0x03	; 3
    3214:	18 f4       	brcc	.+6      	; 0x321c <CO_collectADC_ext+0x6c>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    3216:	81 e0       	ldi	r24, 0x01	; 1
    3218:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    321c:	81 e0       	ldi	r24, 0x01	; 1
    321e:	0e 94 b3 0c 	call	0x1966	; 0x1966 <enableADCMUX>
	setADCInput(channel);
    3222:	8c 2f       	mov	r24, r28
    3224:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    3228:	84 e0       	ldi	r24, 0x04	; 4
    322a:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    322e:	84 e5       	ldi	r24, 0x54	; 84
    3230:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    3234:	e0 ea       	ldi	r30, 0xA0	; 160
    3236:	f6 e0       	ldi	r31, 0x06	; 6
    3238:	ee 24       	eor	r14, r14
    323a:	e3 94       	inc	r14
    323c:	e2 82       	std	Z+2, r14	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    323e:	82 e0       	ldi	r24, 0x02	; 2
    3240:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    3242:	e2 86       	std	Z+10, r14	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_MED_gc;				
    3244:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    3246:	80 e2       	ldi	r24, 0x20	; 32
    3248:	e0 e8       	ldi	r30, 0x80	; 128
    324a:	f6 e0       	ldi	r31, 0x06	; 6
    324c:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    324e:	c0 e4       	ldi	r28, 0x40	; 64
    3250:	da e0       	ldi	r29, 0x0A	; 10
    3252:	83 e2       	ldi	r24, 0x23	; 35
    3254:	89 83       	std	Y+1, r24	; 0x01
	// set period of waveform generator and ccb as duty cycle (want half the period for duty cycle to have good clock signal)
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    3256:	94 01       	movw	r18, r8
    3258:	40 e0       	ldi	r20, 0x00	; 0
    325a:	50 e0       	ldi	r21, 0x00	; 0
    325c:	60 e8       	ldi	r22, 0x80	; 128
    325e:	74 e8       	ldi	r23, 0x84	; 132
    3260:	8e e1       	ldi	r24, 0x1E	; 30
    3262:	90 e0       	ldi	r25, 0x00	; 0
    3264:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    3268:	89 01       	movw	r16, r18
    326a:	9a 01       	movw	r18, r20
    326c:	c8 01       	movw	r24, r16
	TCE1.PER = period;
    326e:	0e a3       	lds	r16, 0x5e
    3270:	1f a3       	lds	r17, 0x5f
	TCE1.CCBBUF = period / 2;
    3272:	96 95       	lsr	r25
    3274:	87 95       	ror	r24
    3276:	8a af       	sts	0x7a, r24
    3278:	9b af       	sts	0x7b, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//reset count to zero
	TCC1.CTRLA = 0x00;
    327a:	e0 e4       	ldi	r30, 0x40	; 64
    327c:	f8 e0       	ldi	r31, 0x08	; 8
    327e:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;
    3280:	8c e0       	ldi	r24, 0x0C	; 12
    3282:	81 87       	std	Z+9, r24	; 0x09
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples;
    3284:	66 a2       	lds	r22, 0x96
    3286:	77 a2       	lds	r23, 0x97
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    3288:	88 e7       	ldi	r24, 0x78	; 120
    328a:	a0 e8       	ldi	r26, 0x80	; 128
    328c:	b1 e0       	ldi	r27, 0x01	; 1
    328e:	11 96       	adiw	r26, 0x01	; 1
    3290:	8c 93       	st	X, r24
    3292:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    3294:	e6 82       	std	Z+6, r14	; 0x06
	//TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    3296:	88 81       	ld	r24, Y
    3298:	80 7f       	andi	r24, 0xF0	; 240
    329a:	81 60       	ori	r24, 0x01	; 1
    329c:	88 83       	st	Y, r24
	
	sampleCount = 0;
    329e:	10 92 6a 50 	sts	0x506A, r1
    32a2:	10 92 6b 50 	sts	0x506B, r1
    32a6:	10 92 6c 50 	sts	0x506C, r1
    32aa:	10 92 6d 50 	sts	0x506D, r1
	discardCount = 0;
    32ae:	10 92 61 40 	sts	0x4061, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
    32b2:	e0 ea       	ldi	r30, 0xA0	; 160
    32b4:	f0 e0       	ldi	r31, 0x00	; 0
    32b6:	82 81       	ldd	r24, Z+2	; 0x02
    32b8:	83 60       	ori	r24, 0x03	; 3
    32ba:	82 83       	std	Z+2, r24	; 0x02
	sei();
    32bc:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    32be:	df 91       	pop	r29
    32c0:	cf 91       	pop	r28
    32c2:	1f 91       	pop	r17
    32c4:	0f 91       	pop	r16
    32c6:	ff 90       	pop	r15
    32c8:	ef 90       	pop	r14
    32ca:	df 90       	pop	r13
    32cc:	cf 90       	pop	r12
    32ce:	bf 90       	pop	r11
    32d0:	af 90       	pop	r10
    32d2:	9f 90       	pop	r9
    32d4:	8f 90       	pop	r8
    32d6:	7f 90       	pop	r7
    32d8:	6f 90       	pop	r6
    32da:	08 95       	ret

000032dc <CO_collectADC>:
		PORTA.OUTCLR = PIN5_bm;
		PORTA.DIRCLR = PIN5_bm;
	}
}

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    32dc:	8f 92       	push	r8
    32de:	9f 92       	push	r9
    32e0:	af 92       	push	r10
    32e2:	cf 92       	push	r12
    32e4:	df 92       	push	r13
    32e6:	ef 92       	push	r14
    32e8:	ff 92       	push	r15
    32ea:	0f 93       	push	r16
    32ec:	1f 93       	push	r17
    32ee:	cf 93       	push	r28
    32f0:	df 93       	push	r29
    32f2:	96 2f       	mov	r25, r22
    32f4:	fa 01       	movw	r30, r20
    32f6:	d9 01       	movw	r26, r18
    32f8:	e8 01       	movw	r28, r16
    32fa:	47 01       	movw	r8, r14
    32fc:	ac 2c       	mov	r10, r12
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_1AND5_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray, BufferSize, use_FRAM);
    32fe:	61 ec       	ldi	r22, 0xC1	; 193
    3300:	49 2f       	mov	r20, r25
    3302:	9f 01       	movw	r18, r30
    3304:	8d 01       	movw	r16, r26
    3306:	7e 01       	movw	r14, r28
    3308:	64 01       	movw	r12, r8
    330a:	0e 94 d8 18 	call	0x31b0	; 0x31b0 <CO_collectADC_ext>
}
    330e:	df 91       	pop	r29
    3310:	cf 91       	pop	r28
    3312:	1f 91       	pop	r17
    3314:	0f 91       	pop	r16
    3316:	ff 90       	pop	r15
    3318:	ef 90       	pop	r14
    331a:	df 90       	pop	r13
    331c:	cf 90       	pop	r12
    331e:	af 90       	pop	r10
    3320:	9f 90       	pop	r9
    3322:	8f 90       	pop	r8
    3324:	08 95       	ret

00003326 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    3326:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3328:	81 e0       	ldi	r24, 0x01	; 1
    332a:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    332c:	84 81       	ldd	r24, Z+4	; 0x04
    332e:	95 81       	ldd	r25, Z+5	; 0x05
    3330:	86 1b       	sub	r24, r22
    3332:	91 09       	sbc	r25, r1

	return answer;
}
    3334:	08 95       	ret

00003336 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    3336:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3338:	81 e0       	ldi	r24, 0x01	; 1
    333a:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    333c:	84 81       	ldd	r24, Z+4	; 0x04
    333e:	95 81       	ldd	r25, Z+5	; 0x05
    3340:	77 27       	eor	r23, r23
    3342:	67 fd       	sbrc	r22, 7
    3344:	70 95       	com	r23
    3346:	86 1b       	sub	r24, r22
    3348:	97 0b       	sbc	r25, r23

	return answer;
}
    334a:	08 95       	ret

0000334c <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    334c:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    334e:	81 e0       	ldi	r24, 0x01	; 1
    3350:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    3352:	84 81       	ldd	r24, Z+4	; 0x04
    3354:	95 81       	ldd	r25, Z+5	; 0x05
}
    3356:	08 95       	ret

00003358 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    3358:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    335a:	81 e0       	ldi	r24, 0x01	; 1
    335c:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    335e:	84 81       	ldd	r24, Z+4	; 0x04
}
    3360:	08 95       	ret

00003362 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    3362:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3364:	81 e0       	ldi	r24, 0x01	; 1
    3366:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    3368:	85 81       	ldd	r24, Z+5	; 0x05
}
    336a:	08 95       	ret

0000336c <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    336c:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    336e:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    3370:	14 82       	std	Z+4, r1	; 0x04
    3372:	9a e2       	ldi	r25, 0x2A	; 42
    3374:	9a 95       	dec	r25
    3376:	f1 f7       	brne	.-4      	; 0x3374 <ADC_Wait_8MHz+0x8>
    3378:	00 c0       	rjmp	.+0      	; 0x337a <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    337a:	84 83       	std	Z+4, r24	; 0x04
}
    337c:	08 95       	ret

0000337e <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    337e:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3380:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    3382:	91 e0       	ldi	r25, 0x01	; 1
    3384:	94 83       	std	Z+4, r25	; 0x04
    3386:	95 e5       	ldi	r25, 0x55	; 85
    3388:	9a 95       	dec	r25
    338a:	f1 f7       	brne	.-4      	; 0x3388 <ADC_Wait_32MHz+0xa>
    338c:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    338e:	84 83       	std	Z+4, r24	; 0x04
}
    3390:	08 95       	ret

00003392 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3392:	ef 92       	push	r14
    3394:	ff 92       	push	r15
    3396:	0f 93       	push	r16
    3398:	1f 93       	push	r17
    339a:	cf 93       	push	r28
    339c:	df 93       	push	r29
    339e:	eb 01       	movw	r28, r22
    if (oversampling)
    33a0:	44 23       	and	r20, r20
    33a2:	c9 f0       	breq	.+50     	; 0x33d6 <ADC_Offset_Get_Unsigned+0x44>
    33a4:	04 e0       	ldi	r16, 0x04	; 4
    33a6:	10 e0       	ldi	r17, 0x00	; 0
    33a8:	ee 24       	eor	r14, r14
    33aa:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    33ac:	88 81       	ld	r24, Y
    33ae:	80 68       	ori	r24, 0x80	; 128
    33b0:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    33b2:	8b 81       	ldd	r24, Y+3	; 0x03
    33b4:	80 ff       	sbrs	r24, 0
    33b6:	fd cf       	rjmp	.-6      	; 0x33b2 <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    33b8:	ce 01       	movw	r24, r28
    33ba:	60 e0       	ldi	r22, 0x00	; 0
    33bc:	0e 94 93 19 	call	0x3326	; 0x3326 <ADC_ResultCh_GetWord_Unsigned>
    33c0:	e8 0e       	add	r14, r24
    33c2:	f9 1e       	adc	r15, r25
    33c4:	01 50       	subi	r16, 0x01	; 1
    33c6:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    33c8:	89 f7       	brne	.-30     	; 0x33ac <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    33ca:	c7 01       	movw	r24, r14
    33cc:	96 95       	lsr	r25
    33ce:	87 95       	ror	r24
    33d0:	96 95       	lsr	r25
    33d2:	87 95       	ror	r24
    33d4:	09 c0       	rjmp	.+18     	; 0x33e8 <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    33d6:	88 81       	ld	r24, Y
    33d8:	80 68       	ori	r24, 0x80	; 128
    33da:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    33dc:	8b 81       	ldd	r24, Y+3	; 0x03
    33de:	80 ff       	sbrs	r24, 0
    33e0:	fd cf       	rjmp	.-6      	; 0x33dc <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    33e2:	ce 01       	movw	r24, r28
    33e4:	0e 94 a6 19 	call	0x334c	; 0x334c <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
    33e8:	df 91       	pop	r29
    33ea:	cf 91       	pop	r28
    33ec:	1f 91       	pop	r17
    33ee:	0f 91       	pop	r16
    33f0:	ff 90       	pop	r15
    33f2:	ef 90       	pop	r14
    33f4:	08 95       	ret

000033f6 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    33f6:	ef 92       	push	r14
    33f8:	ff 92       	push	r15
    33fa:	0f 93       	push	r16
    33fc:	1f 93       	push	r17
    33fe:	cf 93       	push	r28
    3400:	df 93       	push	r29
    3402:	eb 01       	movw	r28, r22
    if (oversampling)
    3404:	44 23       	and	r20, r20
    3406:	e1 f0       	breq	.+56     	; 0x3440 <ADC_Offset_Get_Signed+0x4a>
    3408:	04 e0       	ldi	r16, 0x04	; 4
    340a:	10 e0       	ldi	r17, 0x00	; 0
    340c:	ee 24       	eor	r14, r14
    340e:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3410:	88 81       	ld	r24, Y
    3412:	80 68       	ori	r24, 0x80	; 128
    3414:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3416:	8b 81       	ldd	r24, Y+3	; 0x03
    3418:	80 ff       	sbrs	r24, 0
    341a:	fd cf       	rjmp	.-6      	; 0x3416 <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    341c:	ce 01       	movw	r24, r28
    341e:	60 e0       	ldi	r22, 0x00	; 0
    3420:	0e 94 9b 19 	call	0x3336	; 0x3336 <ADC_ResultCh_GetWord_Signed>
    3424:	e8 0e       	add	r14, r24
    3426:	f9 1e       	adc	r15, r25
    3428:	01 50       	subi	r16, 0x01	; 1
    342a:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    342c:	89 f7       	brne	.-30     	; 0x3410 <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    342e:	c7 01       	movw	r24, r14
    3430:	99 23       	and	r25, r25
    3432:	0c f4       	brge	.+2      	; 0x3436 <ADC_Offset_Get_Signed+0x40>
    3434:	03 96       	adiw	r24, 0x03	; 3
    3436:	95 95       	asr	r25
    3438:	87 95       	ror	r24
    343a:	95 95       	asr	r25
    343c:	87 95       	ror	r24
    343e:	0a c0       	rjmp	.+20     	; 0x3454 <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3440:	88 81       	ld	r24, Y
    3442:	80 68       	ori	r24, 0x80	; 128
    3444:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3446:	8b 81       	ldd	r24, Y+3	; 0x03
    3448:	80 ff       	sbrs	r24, 0
    344a:	fd cf       	rjmp	.-6      	; 0x3446 <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    344c:	ce 01       	movw	r24, r28
    344e:	60 e0       	ldi	r22, 0x00	; 0
    3450:	0e 94 9b 19 	call	0x3336	; 0x3336 <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
    3454:	df 91       	pop	r29
    3456:	cf 91       	pop	r28
    3458:	1f 91       	pop	r17
    345a:	0f 91       	pop	r16
    345c:	ff 90       	pop	r15
    345e:	ef 90       	pop	r14
    3460:	08 95       	ret

00003462 <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    3462:	aa ec       	ldi	r26, 0xCA	; 202
    3464:	b1 e0       	ldi	r27, 0x01	; 1
    3466:	92 e0       	ldi	r25, 0x02	; 2
    3468:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
    346a:	e8 2f       	mov	r30, r24
    346c:	f0 e0       	ldi	r31, 0x00	; 0
    346e:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    3470:	1c 92       	st	X, r1

	return result;
}
    3472:	08 95       	ret

00003474 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    3474:	cf 93       	push	r28
    3476:	df 93       	push	r29
    3478:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
    347a:	82 e0       	ldi	r24, 0x02	; 2
    347c:	c0 30       	cpi	r28, 0x00	; 0
    347e:	d8 07       	cpc	r29, r24
    3480:	59 f4       	brne	.+22     	; 0x3498 <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    3482:	80 e2       	ldi	r24, 0x20	; 32
    3484:	0e 94 31 1a 	call	0x3462	; 0x3462 <SP_ReadCalibrationByte>
    3488:	c0 e0       	ldi	r28, 0x00	; 0
    348a:	d2 e0       	ldi	r29, 0x02	; 2
    348c:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    348e:	81 e2       	ldi	r24, 0x21	; 33
    3490:	0e 94 31 1a 	call	0x3462	; 0x3462 <SP_ReadCalibrationByte>
    3494:	8d 87       	std	Y+13, r24	; 0x0d
    3496:	08 c0       	rjmp	.+16     	; 0x34a8 <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    3498:	84 e2       	ldi	r24, 0x24	; 36
    349a:	0e 94 31 1a 	call	0x3462	; 0x3462 <SP_ReadCalibrationByte>
    349e:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    34a0:	85 e2       	ldi	r24, 0x25	; 37
    34a2:	0e 94 31 1a 	call	0x3462	; 0x3462 <SP_ReadCalibrationByte>
    34a6:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
    34a8:	df 91       	pop	r29
    34aa:	cf 91       	pop	r28
    34ac:	08 95       	ret

000034ae <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
    34ae:	88 e1       	ldi	r24, 0x18	; 24
    34b0:	e5 e1       	ldi	r30, 0x15	; 21
    34b2:	f1 e2       	ldi	r31, 0x21	; 33
    34b4:	df 01       	movw	r26, r30
    34b6:	1d 92       	st	X+, r1
    34b8:	8a 95       	dec	r24
    34ba:	e9 f7       	brne	.-6      	; 0x34b6 <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
    34bc:	0e 94 ce 1b 	call	0x379c	; 0x379c <chb_get_short_addr>
    34c0:	80 93 15 21 	sts	0x2115, r24
    34c4:	90 93 16 21 	sts	0x2116, r25
    chb_drvr_init();
    34c8:	0e 94 2c 1e 	call	0x3c58	; 0x3c58 <chb_drvr_init>
	//radio_msg_received_int_enable();
}
    34cc:	08 95       	ret

000034ce <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
	PORTE.DIRSET = PIN2_bm;
    34ce:	e0 e8       	ldi	r30, 0x80	; 128
    34d0:	f6 e0       	ldi	r31, 0x06	; 6
    34d2:	84 e0       	ldi	r24, 0x04	; 4
    34d4:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    34d6:	86 83       	std	Z+6, r24	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    34d8:	92 e0       	ldi	r25, 0x02	; 2
    34da:	90 8b       	std	Z+16, r25	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    34dc:	82 87       	std	Z+10, r24	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    34de:	83 e0       	ldi	r24, 0x03	; 3
    34e0:	81 87       	std	Z+9, r24	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    34e2:	e0 ea       	ldi	r30, 0xA0	; 160
    34e4:	f0 e0       	ldi	r31, 0x00	; 0
    34e6:	82 81       	ldd	r24, Z+2	; 0x02
    34e8:	84 60       	ori	r24, 0x04	; 4
    34ea:	82 83       	std	Z+2, r24	; 0x02
	sei();
    34ec:	78 94       	sei
}
    34ee:	08 95       	ret

000034f0 <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
    34f0:	85 e1       	ldi	r24, 0x15	; 21
    34f2:	91 e2       	ldi	r25, 0x21	; 33
    34f4:	08 95       	ret

000034f6 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    34f6:	2f 92       	push	r2
    34f8:	3f 92       	push	r3
    34fa:	4f 92       	push	r4
    34fc:	5f 92       	push	r5
    34fe:	6f 92       	push	r6
    3500:	7f 92       	push	r7
    3502:	8f 92       	push	r8
    3504:	9f 92       	push	r9
    3506:	af 92       	push	r10
    3508:	bf 92       	push	r11
    350a:	cf 92       	push	r12
    350c:	df 92       	push	r13
    350e:	ef 92       	push	r14
    3510:	ff 92       	push	r15
    3512:	0f 93       	push	r16
    3514:	1f 93       	push	r17
    3516:	cf 93       	push	r28
    3518:	df 93       	push	r29
    351a:	cd b7       	in	r28, 0x3d	; 61
    351c:	de b7       	in	r29, 0x3e	; 62
    351e:	2a 97       	sbiw	r28, 0x0a	; 10
    3520:	cd bf       	out	0x3d, r28	; 61
    3522:	de bf       	out	0x3e, r29	; 62
    3524:	2c 01       	movw	r4, r24
    3526:	1b 01       	movw	r2, r22
    3528:	69 01       	movw	r12, r18
    352a:	7a 01       	movw	r14, r20
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    352c:	21 15       	cp	r18, r1
    352e:	31 05       	cpc	r19, r1
    3530:	41 05       	cpc	r20, r1
    3532:	51 05       	cpc	r21, r1
    3534:	09 f4       	brne	.+2      	; 0x3538 <chb_write+0x42>
    3536:	76 c0       	rjmp	.+236    	; 0x3624 <chb_write+0x12e>
    U8 status, frm_len, hdr[CHB_HDR_SZ + 1];
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    3538:	88 24       	eor	r8, r8
    353a:	99 24       	eor	r9, r9
    353c:	54 01       	movw	r10, r8
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    353e:	08 e9       	ldi	r16, 0x98	; 152

    *hdr_ptr++ = pcb.seq++;
    3540:	0f 2e       	mov	r0, r31
    3542:	fb e1       	ldi	r31, 0x1B	; 27
    3544:	6f 2e       	mov	r6, r31
    3546:	f1 e2       	ldi	r31, 0x21	; 33
    3548:	7f 2e       	mov	r7, r31
    354a:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    354c:	1c 2d       	mov	r17, r12
    354e:	85 e6       	ldi	r24, 0x65	; 101
    3550:	c8 16       	cp	r12, r24
    3552:	d1 04       	cpc	r13, r1
    3554:	e1 04       	cpc	r14, r1
    3556:	f1 04       	cpc	r15, r1
    3558:	08 f0       	brcs	.+2      	; 0x355c <chb_write+0x66>
    355a:	14 e6       	ldi	r17, 0x64	; 100
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    355c:	81 2f       	mov	r24, r17
    355e:	85 5f       	subi	r24, 0xF5	; 245
    3560:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    3562:	9f ef       	ldi	r25, 0xFF	; 255
    3564:	49 16       	cp	r4, r25
    3566:	9f ef       	ldi	r25, 0xFF	; 255
    3568:	59 06       	cpc	r5, r25
    356a:	11 f0       	breq	.+4      	; 0x3570 <chb_write+0x7a>
    356c:	81 e6       	ldi	r24, 0x61	; 97
    356e:	01 c0       	rjmp	.+2      	; 0x3572 <chb_write+0x7c>
    3570:	81 e4       	ldi	r24, 0x41	; 65
    3572:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    3574:	0b 83       	std	Y+3, r16	; 0x03

    *hdr_ptr++ = pcb.seq++;
    3576:	f3 01       	movw	r30, r6
    3578:	80 81       	ld	r24, Z
    357a:	8c 83       	std	Y+4, r24	; 0x04
    357c:	8f 5f       	subi	r24, 0xFF	; 255
    357e:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    3580:	84 e3       	ldi	r24, 0x34	; 52
    3582:	92 e1       	ldi	r25, 0x12	; 18
    3584:	8d 83       	std	Y+5, r24	; 0x05
    3586:	9e 83       	std	Y+6, r25	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
    3588:	4f 82       	std	Y+7, r4	; 0x07
    358a:	58 86       	std	Y+8, r5	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
    358c:	e5 e1       	ldi	r30, 0x15	; 21
    358e:	f1 e2       	ldi	r31, 0x21	; 33
    3590:	80 81       	ld	r24, Z
    3592:	91 81       	ldd	r25, Z+1	; 0x01
    3594:	89 87       	std	Y+9, r24	; 0x09
    3596:	9a 87       	std	Y+10, r25	; 0x0a
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		//rtry = 0;
		//do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    3598:	b1 01       	movw	r22, r2
    359a:	68 0d       	add	r22, r8
    359c:	79 1d       	adc	r23, r9
    359e:	ce 01       	movw	r24, r28
    35a0:	01 96       	adiw	r24, 0x01	; 1
    35a2:	41 2f       	mov	r20, r17
    35a4:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <chb_tx>
		if (status != CHB_SUCCESS){
    35a8:	88 23       	and	r24, r24
    35aa:	69 f1       	breq	.+90     	; 0x3606 <chb_write+0x110>
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		//rtry = 0;
		//do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    35ac:	28 2f       	mov	r18, r24
		if (status != CHB_SUCCESS){
             switch (status)
    35ae:	83 30       	cpi	r24, 0x03	; 3
    35b0:	f9 f0       	breq	.+62     	; 0x35f0 <chb_write+0xfa>
    35b2:	84 30       	cpi	r24, 0x04	; 4
    35b4:	18 f4       	brcc	.+6      	; 0x35bc <chb_write+0xc6>
    35b6:	81 30       	cpi	r24, 0x01	; 1
    35b8:	b1 f5       	brne	.+108    	; 0x3626 <chb_write+0x130>
    35ba:	04 c0       	rjmp	.+8      	; 0x35c4 <chb_write+0xce>
    35bc:	85 30       	cpi	r24, 0x05	; 5
    35be:	69 f0       	breq	.+26     	; 0x35da <chb_write+0xe4>
    35c0:	80 34       	cpi	r24, 0x40	; 64
    35c2:	89 f5       	brne	.+98     	; 0x3626 <chb_write+0x130>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    35c4:	20 91 20 21 	lds	r18, 0x2120
    35c8:	30 91 21 21 	lds	r19, 0x2121
    35cc:	2f 5f       	subi	r18, 0xFF	; 255
    35ce:	3f 4f       	sbci	r19, 0xFF	; 255
    35d0:	20 93 20 21 	sts	0x2120, r18
    35d4:	30 93 21 21 	sts	0x2121, r19
                 break;
    35d8:	26 c0       	rjmp	.+76     	; 0x3626 <chb_write+0x130>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    35da:	80 91 22 21 	lds	r24, 0x2122
    35de:	90 91 23 21 	lds	r25, 0x2123
    35e2:	01 96       	adiw	r24, 0x01	; 1
    35e4:	80 93 22 21 	sts	0x2122, r24
    35e8:	90 93 23 21 	sts	0x2123, r25
                 break;
 
             default:
                 break;
             }
			 return status;
    35ec:	82 2f       	mov	r24, r18
                 break;
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
				 //rtry++;
                 break;
    35ee:	1b c0       	rjmp	.+54     	; 0x3626 <chb_write+0x130>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    35f0:	20 91 24 21 	lds	r18, 0x2124
    35f4:	30 91 25 21 	lds	r19, 0x2125
    35f8:	2f 5f       	subi	r18, 0xFF	; 255
    35fa:	3f 4f       	sbci	r19, 0xFF	; 255
    35fc:	20 93 24 21 	sts	0x2124, r18
    3600:	30 93 25 21 	sts	0x2125, r19
				 //rtry++;
                 break;
    3604:	10 c0       	rjmp	.+32     	; 0x3626 <chb_write+0x130>
		}			 
			//if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
			//if(rtry==20) return status;;		//after 20 tries give up on sending the message	
		//} while(status != CHB_SUCCESS);			
        // adjust len and restart
		frm_offset += frm_len;
    3606:	41 2f       	mov	r20, r17
    3608:	50 e0       	ldi	r21, 0x00	; 0
    360a:	60 e0       	ldi	r22, 0x00	; 0
    360c:	70 e0       	ldi	r23, 0x00	; 0
    360e:	84 0e       	add	r8, r20
    3610:	95 1e       	adc	r9, r21
    3612:	a6 1e       	adc	r10, r22
    3614:	b7 1e       	adc	r11, r23
		//if (len > CHB_MAX_PAYLOAD) _delay_ms(100);				//wait a little before sending next message
        len = len - frm_len;
    3616:	c4 1a       	sub	r12, r20
    3618:	d5 0a       	sbc	r13, r21
    361a:	e6 0a       	sbc	r14, r22
    361c:	f7 0a       	sbc	r15, r23
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    361e:	09 f0       	breq	.+2      	; 0x3622 <chb_write+0x12c>
    3620:	95 cf       	rjmp	.-214    	; 0x354c <chb_write+0x56>
    3622:	01 c0       	rjmp	.+2      	; 0x3626 <chb_write+0x130>
        // adjust len and restart
		frm_offset += frm_len;
		//if (len > CHB_MAX_PAYLOAD) _delay_ms(100);				//wait a little before sending next message
        len = len - frm_len;
    }
	return CHB_SUCCESS;
    3624:	80 e0       	ldi	r24, 0x00	; 0
}
    3626:	2a 96       	adiw	r28, 0x0a	; 10
    3628:	cd bf       	out	0x3d, r28	; 61
    362a:	de bf       	out	0x3e, r29	; 62
    362c:	df 91       	pop	r29
    362e:	cf 91       	pop	r28
    3630:	1f 91       	pop	r17
    3632:	0f 91       	pop	r16
    3634:	ff 90       	pop	r15
    3636:	ef 90       	pop	r14
    3638:	df 90       	pop	r13
    363a:	cf 90       	pop	r12
    363c:	bf 90       	pop	r11
    363e:	af 90       	pop	r10
    3640:	9f 90       	pop	r9
    3642:	8f 90       	pop	r8
    3644:	7f 90       	pop	r7
    3646:	6f 90       	pop	r6
    3648:	5f 90       	pop	r5
    364a:	4f 90       	pop	r4
    364c:	3f 90       	pop	r3
    364e:	2f 90       	pop	r2
    3650:	08 95       	ret

00003652 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    3652:	df 92       	push	r13
    3654:	ef 92       	push	r14
    3656:	ff 92       	push	r15
    3658:	0f 93       	push	r16
    365a:	1f 93       	push	r17
    365c:	cf 93       	push	r28
    365e:	df 93       	push	r29
    3660:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    3662:	0e 94 ac 1b 	call	0x3758	; 0x3758 <chb_buf_read>
    3666:	d8 2e       	mov	r13, r24
    3668:	88 23       	and	r24, r24
    366a:	0c f4       	brge	.+2      	; 0x366e <chb_read+0x1c>
    366c:	4e c0       	rjmp	.+156    	; 0x370a <chb_read+0xb8>
    {
        return 0;
    }
    *data_ptr++ = len;
    366e:	f7 01       	movw	r30, r14
    3670:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    3672:	88 23       	and	r24, r24
    3674:	71 f0       	breq	.+28     	; 0x3692 <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
    3676:	e7 01       	movw	r28, r14
    3678:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
    367a:	87 01       	movw	r16, r14
    367c:	09 5f       	subi	r16, 0xF9	; 249
    367e:	1f 4f       	sbci	r17, 0xFF	; 255
    3680:	81 50       	subi	r24, 0x01	; 1
    3682:	08 0f       	add	r16, r24
    3684:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
    3686:	0e 94 ac 1b 	call	0x3758	; 0x3758 <chb_buf_read>
    368a:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    368c:	c0 17       	cp	r28, r16
    368e:	d1 07       	cpc	r29, r17
    3690:	d1 f7       	brne	.-12     	; 0x3686 <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
    3692:	f7 01       	movw	r30, r14
    3694:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
    3696:	83 85       	ldd	r24, Z+11	; 0x0b
    3698:	94 85       	ldd	r25, Z+12	; 0x0c
    369a:	83 83       	std	Z+3, r24	; 0x03
    369c:	94 83       	std	Z+4, r25	; 0x04
	pcb.destination_addr = rx->dest_addr;
    369e:	80 93 19 21 	sts	0x2119, r24
    36a2:	90 93 1a 21 	sts	0x211A, r25
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
    36a6:	85 85       	ldd	r24, Z+13	; 0x0d
    36a8:	96 85       	ldd	r25, Z+14	; 0x0e
    36aa:	81 83       	std	Z+1, r24	; 0x01
    36ac:	92 83       	std	Z+2, r25	; 0x02
	pcb.sender_addr = rx->src_addr;
    36ae:	80 93 17 21 	sts	0x2117, r24
    36b2:	90 93 18 21 	sts	0x2118, r25
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    36b6:	0e 94 c3 1b 	call	0x3786	; 0x3786 <chb_buf_get_len>
    36ba:	88 23       	and	r24, r24
    36bc:	11 f4       	brne	.+4      	; 0x36c2 <chb_read+0x70>
    {
        pcb.data_rcv = false;
    36be:	10 92 1c 21 	sts	0x211C, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    36c2:	80 91 0a 20 	lds	r24, 0x200A
    36c6:	c8 17       	cp	r28, r24
    36c8:	51 f4       	brne	.+20     	; 0x36de <chb_read+0x8c>
    36ca:	f7 01       	movw	r30, r14
    36cc:	21 81       	ldd	r18, Z+1	; 0x01
    36ce:	32 81       	ldd	r19, Z+2	; 0x02
    36d0:	80 91 0b 20 	lds	r24, 0x200B
    36d4:	90 91 0c 20 	lds	r25, 0x200C
    36d8:	28 17       	cp	r18, r24
    36da:	39 07       	cpc	r19, r25
    36dc:	c1 f0       	breq	.+48     	; 0x370e <chb_read+0xbc>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
    36de:	c0 93 0a 20 	sts	0x200A, r28
        prev_src_addr = rx->src_addr;
    36e2:	f7 01       	movw	r30, r14
    36e4:	81 81       	ldd	r24, Z+1	; 0x01
    36e6:	92 81       	ldd	r25, Z+2	; 0x02
    36e8:	80 93 0b 20 	sts	0x200B, r24
    36ec:	90 93 0c 20 	sts	0x200C, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    36f0:	b7 01       	movw	r22, r14
    36f2:	61 5f       	subi	r22, 0xF1	; 241
    36f4:	7f 4f       	sbci	r23, 0xFF	; 255
    36f6:	4d 2d       	mov	r20, r13
    36f8:	50 e0       	ldi	r21, 0x00	; 0
    36fa:	49 50       	subi	r20, 0x09	; 9
    36fc:	50 40       	sbci	r21, 0x00	; 0
    36fe:	c7 01       	movw	r24, r14
    3700:	0e 94 3d 3a 	call	0x747a	; 0x747a <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    3704:	8d 2d       	mov	r24, r13
    3706:	8b 50       	subi	r24, 0x0B	; 11
    3708:	03 c0       	rjmp	.+6      	; 0x3710 <chb_read+0xbe>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    370a:	80 e0       	ldi	r24, 0x00	; 0
    370c:	01 c0       	rjmp	.+2      	; 0x3710 <chb_read+0xbe>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    370e:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
    3710:	df 91       	pop	r29
    3712:	cf 91       	pop	r28
    3714:	1f 91       	pop	r17
    3716:	0f 91       	pop	r16
    3718:	ff 90       	pop	r15
    371a:	ef 90       	pop	r14
    371c:	df 90       	pop	r13
    371e:	08 95       	ret

00003720 <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
    3720:	10 92 2d 21 	sts	0x212D, r1
    wr_ptr = 0;
    3724:	10 92 2e 21 	sts	0x212E, r1
    len = 0;
    3728:	10 92 2f 21 	sts	0x212F, r1
}
    372c:	08 95       	ret

0000372e <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
    372e:	20 91 2e 21 	lds	r18, 0x212E
    3732:	30 e0       	ldi	r19, 0x00	; 0
    3734:	f9 01       	movw	r30, r18
    3736:	e0 5d       	subi	r30, 0xD0	; 208
    3738:	fe 4d       	sbci	r31, 0xDE	; 222
    373a:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    373c:	c9 01       	movw	r24, r18
    373e:	01 96       	adiw	r24, 0x01	; 1
    3740:	60 e8       	ldi	r22, 0x80	; 128
    3742:	70 e0       	ldi	r23, 0x00	; 0
    3744:	0e 94 a1 39 	call	0x7342	; 0x7342 <__divmodhi4>
    3748:	80 93 2e 21 	sts	0x212E, r24
    len++;
    374c:	80 91 2f 21 	lds	r24, 0x212F
    3750:	8f 5f       	subi	r24, 0xFF	; 255
    3752:	80 93 2f 21 	sts	0x212F, r24
}
    3756:	08 95       	ret

00003758 <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
    3758:	20 91 2d 21 	lds	r18, 0x212D
    375c:	30 e0       	ldi	r19, 0x00	; 0
    375e:	f9 01       	movw	r30, r18
    3760:	e0 5d       	subi	r30, 0xD0	; 208
    3762:	fe 4d       	sbci	r31, 0xDE	; 222
    3764:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    3766:	2f 5f       	subi	r18, 0xFF	; 255
    3768:	3f 4f       	sbci	r19, 0xFF	; 255
    376a:	c9 01       	movw	r24, r18
    376c:	60 e8       	ldi	r22, 0x80	; 128
    376e:	70 e0       	ldi	r23, 0x00	; 0
    3770:	0e 94 a1 39 	call	0x7342	; 0x7342 <__divmodhi4>
    3774:	80 93 2d 21 	sts	0x212D, r24
    len--;
    3778:	80 91 2f 21 	lds	r24, 0x212F
    377c:	81 50       	subi	r24, 0x01	; 1
    377e:	80 93 2f 21 	sts	0x212F, r24
    return data;
}
    3782:	84 2f       	mov	r24, r20
    3784:	08 95       	ret

00003786 <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
    3786:	80 91 2f 21 	lds	r24, 0x212F
    378a:	08 95       	ret

0000378c <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    378c:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    378e:	80 e0       	ldi	r24, 0x00	; 0
    3790:	90 e0       	ldi	r25, 0x00	; 0
    3792:	48 e0       	ldi	r20, 0x08	; 8
    3794:	50 e0       	ldi	r21, 0x00	; 0
    3796:	0e 94 06 20 	call	0x400c	; 0x400c <chb_eeprom_read>
}
    379a:	08 95       	ret

0000379c <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    379c:	cf 93       	push	r28
    379e:	df 93       	push	r29
    37a0:	0f 92       	push	r0
    37a2:	0f 92       	push	r0
    37a4:	cd b7       	in	r28, 0x3d	; 61
    37a6:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    37a8:	89 e0       	ldi	r24, 0x09	; 9
    37aa:	90 e0       	ldi	r25, 0x00	; 0
    37ac:	be 01       	movw	r22, r28
    37ae:	6f 5f       	subi	r22, 0xFF	; 255
    37b0:	7f 4f       	sbci	r23, 0xFF	; 255
    37b2:	42 e0       	ldi	r20, 0x02	; 2
    37b4:	50 e0       	ldi	r21, 0x00	; 0
    37b6:	0e 94 06 20 	call	0x400c	; 0x400c <chb_eeprom_read>
    return *(U16 *)addr;
}
    37ba:	89 81       	ldd	r24, Y+1	; 0x01
    37bc:	9a 81       	ldd	r25, Y+2	; 0x02
    37be:	0f 90       	pop	r0
    37c0:	0f 90       	pop	r0
    37c2:	df 91       	pop	r29
    37c4:	cf 91       	pop	r28
    37c6:	08 95       	ret

000037c8 <RadioCS>:
    CHB_LEAVE_CRIT();
}

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    37c8:	88 23       	and	r24, r24
    37ca:	29 f0       	breq	.+10     	; 0x37d6 <RadioCS+0xe>
    37cc:	80 e1       	ldi	r24, 0x10	; 16
    37ce:	e0 e6       	ldi	r30, 0x60	; 96
    37d0:	f6 e0       	ldi	r31, 0x06	; 6
    37d2:	86 83       	std	Z+6, r24	; 0x06
    37d4:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    37d6:	80 e1       	ldi	r24, 0x10	; 16
    37d8:	e0 e6       	ldi	r30, 0x60	; 96
    37da:	f6 e0       	ldi	r31, 0x06	; 6
    37dc:	85 83       	std	Z+5, r24	; 0x05
    37de:	08 95       	ret

000037e0 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    37e0:	df 92       	push	r13
    37e2:	ef 92       	push	r14
    37e4:	ff 92       	push	r15
    37e6:	0f 93       	push	r16
    37e8:	1f 93       	push	r17
    37ea:	cf 93       	push	r28
    37ec:	df 93       	push	r29
    37ee:	8c 01       	movw	r16, r24
    37f0:	c6 2f       	mov	r28, r22
    37f2:	7a 01       	movw	r14, r20
    37f4:	d2 2e       	mov	r13, r18
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    37f6:	82 2f       	mov	r24, r18
    37f8:	90 e0       	ldi	r25, 0x00	; 0
    37fa:	86 0f       	add	r24, r22
    37fc:	91 1d       	adc	r25, r1
    37fe:	80 38       	cpi	r24, 0x80	; 128
    3800:	91 05       	cpc	r25, r1
    3802:	8c f5       	brge	.+98     	; 0x3866 <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    3804:	8f b7       	in	r24, 0x3f	; 63
    3806:	80 93 5c 40 	sts	0x405C, r24
    380a:	f8 94       	cli
    RadioCS(TRUE); 
    380c:	81 e0       	ldi	r24, 0x01	; 1
    380e:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    3812:	80 e6       	ldi	r24, 0x60	; 96
    3814:	0e 94 51 20 	call	0x40a2	; 0x40a2 <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    3818:	cc 23       	and	r28, r28
    381a:	79 f0       	breq	.+30     	; 0x383a <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    381c:	c8 01       	movw	r24, r16
    381e:	01 96       	adiw	r24, 0x01	; 1
    3820:	c1 50       	subi	r28, 0x01	; 1
    3822:	9c 01       	movw	r18, r24
    3824:	2c 0f       	add	r18, r28
    3826:	31 1d       	adc	r19, r1
    3828:	e9 01       	movw	r28, r18

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    382a:	f8 01       	movw	r30, r16
    382c:	81 91       	ld	r24, Z+
    382e:	8f 01       	movw	r16, r30
    3830:	0e 94 51 20 	call	0x40a2	; 0x40a2 <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    3834:	0c 17       	cp	r16, r28
    3836:	1d 07       	cpc	r17, r29
    3838:	c1 f7       	brne	.-16     	; 0x382a <chb_frame_write+0x4a>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    383a:	dd 20       	and	r13, r13
    383c:	69 f0       	breq	.+26     	; 0x3858 <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    383e:	e7 01       	movw	r28, r14
    3840:	21 96       	adiw	r28, 0x01	; 1
    3842:	da 94       	dec	r13
    3844:	cd 0d       	add	r28, r13
    3846:	d1 1d       	adc	r29, r1

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    3848:	f7 01       	movw	r30, r14
    384a:	81 91       	ld	r24, Z+
    384c:	7f 01       	movw	r14, r30
    384e:	0e 94 51 20 	call	0x40a2	; 0x40a2 <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    3852:	ec 16       	cp	r14, r28
    3854:	fd 06       	cpc	r15, r29
    3856:	c1 f7       	brne	.-16     	; 0x3848 <chb_frame_write+0x68>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    3858:	80 e0       	ldi	r24, 0x00	; 0
    385a:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <RadioCS>
    CHB_LEAVE_CRIT();
    385e:	80 91 5c 40 	lds	r24, 0x405C
    3862:	8f bf       	out	0x3f, r24	; 63
    3864:	78 94       	sei
}
    3866:	df 91       	pop	r29
    3868:	cf 91       	pop	r28
    386a:	1f 91       	pop	r17
    386c:	0f 91       	pop	r16
    386e:	ff 90       	pop	r15
    3870:	ef 90       	pop	r14
    3872:	df 90       	pop	r13
    3874:	08 95       	ret

00003876 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    3876:	cf 93       	push	r28
    3878:	df 93       	push	r29
    387a:	d8 2f       	mov	r29, r24
    387c:	c6 2f       	mov	r28, r22
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
    387e:	8f b7       	in	r24, 0x3f	; 63
    3880:	80 93 5c 40 	sts	0x405C, r24
    3884:	f8 94       	cli
    RadioCS(TRUE);
    3886:	81 e0       	ldi	r24, 0x01	; 1
    3888:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    388c:	8d 2f       	mov	r24, r29
    388e:	80 6c       	ori	r24, 0xC0	; 192
    3890:	0e 94 51 20 	call	0x40a2	; 0x40a2 <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    3894:	8c 2f       	mov	r24, r28
    3896:	0e 94 51 20 	call	0x40a2	; 0x40a2 <SPID_write>

    RadioCS(FALSE);
    389a:	80 e0       	ldi	r24, 0x00	; 0
    389c:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <RadioCS>
    CHB_LEAVE_CRIT();
    38a0:	80 91 5c 40 	lds	r24, 0x405C
    38a4:	8f bf       	out	0x3f, r24	; 63
    38a6:	78 94       	sei
}
    38a8:	df 91       	pop	r29
    38aa:	cf 91       	pop	r28
    38ac:	08 95       	ret

000038ae <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    38ae:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
    38b0:	85 e0       	ldi	r24, 0x05	; 5
    38b2:	0e 94 3b 1c 	call	0x3876	; 0x3876 <chb_reg_write>
}
    38b6:	08 95       	ret

000038b8 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    38b8:	0f 93       	push	r16
    38ba:	1f 93       	push	r17
    38bc:	cf 93       	push	r28
    38be:	df 93       	push	r29
    38c0:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
    38c2:	c6 2f       	mov	r28, r22
    38c4:	d7 2f       	mov	r29, r23
    38c6:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
    38c8:	69 91       	ld	r22, Y+
    38ca:	81 2f       	mov	r24, r17
    38cc:	80 0f       	add	r24, r16
    38ce:	0e 94 3b 1c 	call	0x3876	; 0x3876 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    38d2:	1f 5f       	subi	r17, 0xFF	; 255
    38d4:	18 30       	cpi	r17, 0x08	; 8
    38d6:	c1 f7       	brne	.-16     	; 0x38c8 <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    38d8:	df 91       	pop	r29
    38da:	cf 91       	pop	r28
    38dc:	1f 91       	pop	r17
    38de:	0f 91       	pop	r16
    38e0:	08 95       	ret

000038e2 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    38e2:	cf 93       	push	r28
    38e4:	df 93       	push	r29
    38e6:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    38e8:	80 e0       	ldi	r24, 0x00	; 0
    38ea:	90 e0       	ldi	r25, 0x00	; 0
    38ec:	be 01       	movw	r22, r28
    38ee:	48 e0       	ldi	r20, 0x08	; 8
    38f0:	50 e0       	ldi	r21, 0x00	; 0
    38f2:	0e 94 a3 1f 	call	0x3f46	; 0x3f46 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    38f6:	84 e2       	ldi	r24, 0x24	; 36
    38f8:	be 01       	movw	r22, r28
    38fa:	0e 94 5c 1c 	call	0x38b8	; 0x38b8 <chb_reg_write64>
}
    38fe:	df 91       	pop	r29
    3900:	cf 91       	pop	r28
    3902:	08 95       	ret

00003904 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    3904:	cf 93       	push	r28
    3906:	df 93       	push	r29
    3908:	c8 2f       	mov	r28, r24
    390a:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
    390c:	0e 94 3b 1c 	call	0x3876	; 0x3876 <chb_reg_write>
    3910:	8c 2f       	mov	r24, r28
    3912:	8f 5f       	subi	r24, 0xFF	; 255
    3914:	6d 2f       	mov	r22, r29
    3916:	0e 94 3b 1c 	call	0x3876	; 0x3876 <chb_reg_write>
    }
}
    391a:	df 91       	pop	r29
    391c:	cf 91       	pop	r28
    391e:	08 95       	ret

00003920 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    3920:	0f 93       	push	r16
    3922:	1f 93       	push	r17
    3924:	cf 93       	push	r28
    3926:	df 93       	push	r29
    3928:	0f 92       	push	r0
    392a:	0f 92       	push	r0
    392c:	cd b7       	in	r28, 0x3d	; 61
    392e:	de b7       	in	r29, 0x3e	; 62
    3930:	89 83       	std	Y+1, r24	; 0x01
    3932:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
    3934:	0e 94 78 1a 	call	0x34f0	; 0x34f0 <chb_get_pcb>
    3938:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    393a:	89 e0       	ldi	r24, 0x09	; 9
    393c:	90 e0       	ldi	r25, 0x00	; 0
    393e:	be 01       	movw	r22, r28
    3940:	6f 5f       	subi	r22, 0xFF	; 255
    3942:	7f 4f       	sbci	r23, 0xFF	; 255
    3944:	42 e0       	ldi	r20, 0x02	; 2
    3946:	50 e0       	ldi	r21, 0x00	; 0
    3948:	0e 94 a3 1f 	call	0x3f46	; 0x3f46 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    394c:	69 81       	ldd	r22, Y+1	; 0x01
    394e:	7a 81       	ldd	r23, Y+2	; 0x02
    3950:	80 e2       	ldi	r24, 0x20	; 32
    3952:	0e 94 82 1c 	call	0x3904	; 0x3904 <chb_reg_write16>
    pcb->src_addr = addr;
    3956:	89 81       	ldd	r24, Y+1	; 0x01
    3958:	9a 81       	ldd	r25, Y+2	; 0x02
    395a:	f8 01       	movw	r30, r16
    395c:	80 83       	st	Z, r24
    395e:	91 83       	std	Z+1, r25	; 0x01
}
    3960:	0f 90       	pop	r0
    3962:	0f 90       	pop	r0
    3964:	df 91       	pop	r29
    3966:	cf 91       	pop	r28
    3968:	1f 91       	pop	r17
    396a:	0f 91       	pop	r16
    396c:	08 95       	ret

0000396e <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    396e:	cf 93       	push	r28
    3970:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
    3972:	8f b7       	in	r24, 0x3f	; 63
    3974:	80 93 5c 40 	sts	0x405C, r24
    3978:	f8 94       	cli
    RadioCS(TRUE);
    397a:	81 e0       	ldi	r24, 0x01	; 1
    397c:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    3980:	8c 2f       	mov	r24, r28
    3982:	80 68       	ori	r24, 0x80	; 128
    3984:	0e 94 51 20 	call	0x40a2	; 0x40a2 <SPID_write>
    val = SPID_write(val);
    3988:	0e 94 51 20 	call	0x40a2	; 0x40a2 <SPID_write>
    398c:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    398e:	80 e0       	ldi	r24, 0x00	; 0
    3990:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <RadioCS>
    CHB_LEAVE_CRIT();
    3994:	80 91 5c 40 	lds	r24, 0x405C
    3998:	8f bf       	out	0x3f, r24	; 63
    399a:	78 94       	sei

    return val;
}
    399c:	8c 2f       	mov	r24, r28
    399e:	cf 91       	pop	r28
    39a0:	08 95       	ret

000039a2 <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
    39a2:	81 e0       	ldi	r24, 0x01	; 1
    39a4:	0e 94 b7 1c 	call	0x396e	; 0x396e <chb_reg_read>
}
    39a8:	8f 71       	andi	r24, 0x1F	; 31
    39aa:	08 95       	ret

000039ac <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    39ac:	1f 93       	push	r17
    39ae:	cf 93       	push	r28
    39b0:	df 93       	push	r29
    39b2:	c8 2f       	mov	r28, r24
    39b4:	16 2f       	mov	r17, r22
    39b6:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
    39b8:	0e 94 b7 1c 	call	0x396e	; 0x396e <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
    39bc:	6d 2f       	mov	r22, r29
    39be:	60 95       	com	r22
    39c0:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
    39c2:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
    39c4:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
    39c6:	8c 2f       	mov	r24, r28
    39c8:	0e 94 3b 1c 	call	0x3876	; 0x3876 <chb_reg_write>
}
    39cc:	df 91       	pop	r29
    39ce:	cf 91       	pop	r28
    39d0:	1f 91       	pop	r17
    39d2:	08 95       	ret

000039d4 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    39d4:	cf 93       	push	r28
    39d6:	df 93       	push	r29
    39d8:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    39da:	80 91 64 06 	lds	r24, 0x0664
    39de:	81 fd       	sbrc	r24, 1
    39e0:	53 c0       	rjmp	.+166    	; 0x3a88 <chb_set_state+0xb4>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    39e2:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <chb_get_state>
    39e6:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    39e8:	81 51       	subi	r24, 0x11	; 17
    39ea:	82 30       	cpi	r24, 0x02	; 2
    39ec:	20 f0       	brcs	.+8      	; 0x39f6 <chb_set_state+0x22>
    39ee:	c1 30       	cpi	r28, 0x01	; 1
    39f0:	11 f0       	breq	.+4      	; 0x39f6 <chb_set_state+0x22>
    39f2:	c2 30       	cpi	r28, 0x02	; 2
    39f4:	21 f4       	brne	.+8      	; 0x39fe <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
    39f6:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <chb_get_state>
    39fa:	8c 17       	cp	r24, r28
    39fc:	e1 f3       	breq	.-8      	; 0x39f6 <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    39fe:	d6 31       	cpi	r29, 0x16	; 22
    3a00:	f9 f0       	breq	.+62     	; 0x3a40 <chb_set_state+0x6c>
    3a02:	d9 31       	cpi	r29, 0x19	; 25
    3a04:	89 f0       	breq	.+34     	; 0x3a28 <chb_set_state+0x54>
    3a06:	d8 30       	cpi	r29, 0x08	; 8
    3a08:	39 f5       	brne	.+78     	; 0x3a58 <chb_set_state+0x84>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    3a0a:	e4 e6       	ldi	r30, 0x64	; 100
    3a0c:	f6 e0       	ldi	r31, 0x06	; 6
    3a0e:	80 81       	ld	r24, Z
    3a10:	8d 7f       	andi	r24, 0xFD	; 253
    3a12:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    3a14:	82 e0       	ldi	r24, 0x02	; 2
    3a16:	63 e0       	ldi	r22, 0x03	; 3
    3a18:	4f e1       	ldi	r20, 0x1F	; 31
    3a1a:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>
    3a1e:	8a e0       	ldi	r24, 0x0A	; 10
    3a20:	8a 95       	dec	r24
    3a22:	f1 f7       	brne	.-4      	; 0x3a20 <chb_set_state+0x4c>
    3a24:	00 c0       	rjmp	.+0      	; 0x3a26 <chb_set_state+0x52>
    3a26:	18 c0       	rjmp	.+48     	; 0x3a58 <chb_set_state+0x84>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    3a28:	c6 31       	cpi	r28, 0x16	; 22
    3a2a:	b1 f4       	brne	.+44     	; 0x3a58 <chb_set_state+0x84>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    3a2c:	82 e0       	ldi	r24, 0x02	; 2
    3a2e:	69 e0       	ldi	r22, 0x09	; 9
    3a30:	4f e1       	ldi	r20, 0x1F	; 31
    3a32:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>
    3a36:	9a e0       	ldi	r25, 0x0A	; 10
    3a38:	9a 95       	dec	r25
    3a3a:	f1 f7       	brne	.-4      	; 0x3a38 <chb_set_state+0x64>
    3a3c:	00 c0       	rjmp	.+0      	; 0x3a3e <chb_set_state+0x6a>
    3a3e:	2a c0       	rjmp	.+84     	; 0x3a94 <chb_set_state+0xc0>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    3a40:	c9 31       	cpi	r28, 0x19	; 25
    3a42:	51 f4       	brne	.+20     	; 0x3a58 <chb_set_state+0x84>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    3a44:	82 e0       	ldi	r24, 0x02	; 2
    3a46:	69 e0       	ldi	r22, 0x09	; 9
    3a48:	4f e1       	ldi	r20, 0x1F	; 31
    3a4a:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>
    3a4e:	8a e0       	ldi	r24, 0x0A	; 10
    3a50:	8a 95       	dec	r24
    3a52:	f1 f7       	brne	.-4      	; 0x3a50 <chb_set_state+0x7c>
    3a54:	00 c0       	rjmp	.+0      	; 0x3a56 <chb_set_state+0x82>
    3a56:	1e c0       	rjmp	.+60     	; 0x3a94 <chb_set_state+0xc0>
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    3a58:	82 e0       	ldi	r24, 0x02	; 2
    3a5a:	6d 2f       	mov	r22, r29
    3a5c:	4f e1       	ldi	r20, 0x1F	; 31
    3a5e:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
	if(curr_state == CHB_TRX_OFF){
    3a62:	c8 30       	cpi	r28, 0x08	; 8
    3a64:	39 f4       	brne	.+14     	; 0x3a74 <chb_set_state+0xa0>
    3a66:	8f e6       	ldi	r24, 0x6F	; 111
    3a68:	93 e0       	ldi	r25, 0x03	; 3
    3a6a:	01 97       	sbiw	r24, 0x01	; 1
    3a6c:	f1 f7       	brne	.-4      	; 0x3a6a <chb_set_state+0x96>
    3a6e:	00 c0       	rjmp	.+0      	; 0x3a70 <chb_set_state+0x9c>
    3a70:	00 00       	nop
    3a72:	04 c0       	rjmp	.+8      	; 0x3a7c <chb_set_state+0xa8>
    3a74:	9a e0       	ldi	r25, 0x0A	; 10
    3a76:	9a 95       	dec	r25
    3a78:	f1 f7       	brne	.-4      	; 0x3a76 <chb_set_state+0xa2>
    3a7a:	00 c0       	rjmp	.+0      	; 0x3a7c <chb_set_state+0xa8>
	}
	else{
		_delay_us(TIME_RX_ON_PLL_ON);
	}				

    if (chb_get_state() == state)
    3a7c:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <chb_get_state>
    3a80:	8d 17       	cp	r24, r29
    3a82:	21 f4       	brne	.+8      	; 0x3a8c <chb_set_state+0xb8>
    {
        return RADIO_SUCCESS;
    3a84:	80 e4       	ldi	r24, 0x40	; 64
    3a86:	03 c0       	rjmp	.+6      	; 0x3a8e <chb_set_state+0xba>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
    3a88:	84 e4       	ldi	r24, 0x44	; 68
    3a8a:	01 c0       	rjmp	.+2      	; 0x3a8e <chb_set_state+0xba>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
    3a8c:	83 e4       	ldi	r24, 0x43	; 67
}
    3a8e:	df 91       	pop	r29
    3a90:	cf 91       	pop	r28
    3a92:	08 95       	ret
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    3a94:	82 e0       	ldi	r24, 0x02	; 2
    3a96:	6d 2f       	mov	r22, r29
    3a98:	4f e1       	ldi	r20, 0x1F	; 31
    3a9a:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>
    3a9e:	ea cf       	rjmp	.-44     	; 0x3a74 <chb_set_state+0xa0>

00003aa0 <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
    3aa0:	88 23       	and	r24, r24
    3aa2:	49 f0       	breq	.+18     	; 0x3ab6 <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    3aa4:	88 e0       	ldi	r24, 0x08	; 8
    3aa6:	0e 94 ea 1c 	call	0x39d4	; 0x39d4 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    3aaa:	e4 e6       	ldi	r30, 0x64	; 100
    3aac:	f6 e0       	ldi	r31, 0x06	; 6
    3aae:	80 81       	ld	r24, Z
    3ab0:	82 60       	ori	r24, 0x02	; 2
    3ab2:	80 83       	st	Z, r24
    3ab4:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    3ab6:	e4 e6       	ldi	r30, 0x64	; 100
    3ab8:	f6 e0       	ldi	r31, 0x06	; 6
    3aba:	80 81       	ld	r24, Z
    3abc:	8d 7f       	andi	r24, 0xFD	; 253
    3abe:	80 83       	st	Z, r24
    3ac0:	8f e7       	ldi	r24, 0x7F	; 127
    3ac2:	97 e0       	ldi	r25, 0x07	; 7
    3ac4:	01 97       	sbiw	r24, 0x01	; 1
    3ac6:	f1 f7       	brne	.-4      	; 0x3ac4 <chb_sleep+0x24>
    3ac8:	00 c0       	rjmp	.+0      	; 0x3aca <chb_sleep+0x2a>
    3aca:	00 00       	nop

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    3acc:	86 e1       	ldi	r24, 0x16	; 22
    3ace:	0e 94 ea 1c 	call	0x39d4	; 0x39d4 <chb_set_state>
    3ad2:	08 95       	ret

00003ad4 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    3ad4:	cf 92       	push	r12
    3ad6:	df 92       	push	r13
    3ad8:	ef 92       	push	r14
    3ada:	ff 92       	push	r15
    3adc:	0f 93       	push	r16
    3ade:	1f 93       	push	r17
    3ae0:	cf 93       	push	r28
    3ae2:	df 93       	push	r29
    3ae4:	7c 01       	movw	r14, r24
    3ae6:	6b 01       	movw	r12, r22
    3ae8:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
    3aea:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <chb_get_state>
    3aee:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
    3af0:	0e 94 78 1a 	call	0x34f0	; 0x34f0 <chb_get_pcb>
    3af4:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    3af6:	12 30       	cpi	r17, 0x02	; 2
    3af8:	e1 f0       	breq	.+56     	; 0x3b32 <chb_tx+0x5e>
    3afa:	12 31       	cpi	r17, 0x12	; 18
    3afc:	e1 f0       	breq	.+56     	; 0x3b36 <chb_tx+0x62>
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    //chb_set_state(CHB_TRX_OFF);
    chb_set_state(CHB_TX_ARET_ON);
    3afe:	89 e1       	ldi	r24, 0x19	; 25
    3b00:	0e 94 ea 1c 	call	0x39d4	; 0x39d4 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    3b04:	c7 01       	movw	r24, r14
    3b06:	6a e0       	ldi	r22, 0x0A	; 10
    3b08:	a6 01       	movw	r20, r12
    3b0a:	20 2f       	mov	r18, r16
    3b0c:	0e 94 f0 1b 	call	0x37e0	; 0x37e0 <chb_frame_write>

    //Do frame transmission. 
	pcb->tx_end = false;
    3b10:	18 86       	std	Y+8, r1	; 0x08
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    3b12:	82 e0       	ldi	r24, 0x02	; 2
    3b14:	62 e0       	ldi	r22, 0x02	; 2
    3b16:	4f e1       	ldi	r20, 0x1F	; 31
    3b18:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    3b1c:	88 85       	ldd	r24, Y+8	; 0x08
    3b1e:	88 23       	and	r24, r24
    3b20:	e9 f3       	breq	.-6      	; 0x3b1c <chb_tx+0x48>
    pcb->tx_end = false;
    3b22:	18 86       	std	Y+8, r1	; 0x08

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    3b24:	82 e0       	ldi	r24, 0x02	; 2
    3b26:	0e 94 b7 1c 	call	0x396e	; 0x396e <chb_reg_read>
    3b2a:	82 95       	swap	r24
    3b2c:	86 95       	lsr	r24
    3b2e:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
    3b30:	03 c0       	rjmp	.+6      	; 0x3b38 <chb_tx+0x64>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
    3b32:	84 e4       	ldi	r24, 0x44	; 68
    3b34:	01 c0       	rjmp	.+2      	; 0x3b38 <chb_tx+0x64>
    3b36:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
    3b38:	df 91       	pop	r29
    3b3a:	cf 91       	pop	r28
    3b3c:	1f 91       	pop	r17
    3b3e:	0f 91       	pop	r16
    3b40:	ff 90       	pop	r15
    3b42:	ef 90       	pop	r14
    3b44:	df 90       	pop	r13
    3b46:	cf 90       	pop	r12
    3b48:	08 95       	ret

00003b4a <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
    3b4a:	81 30       	cpi	r24, 0x01	; 1
    3b4c:	91 f0       	breq	.+36     	; 0x3b72 <chb_set_mode+0x28>
    3b4e:	81 30       	cpi	r24, 0x01	; 1
    3b50:	28 f0       	brcs	.+10     	; 0x3b5c <chb_set_mode+0x12>
    3b52:	82 30       	cpi	r24, 0x02	; 2
    3b54:	c9 f0       	breq	.+50     	; 0x3b88 <chb_set_mode+0x3e>
    3b56:	83 30       	cpi	r24, 0x03	; 3
    3b58:	61 f5       	brne	.+88     	; 0x3bb2 <chb_set_mode+0x68>
    3b5a:	21 c0       	rjmp	.+66     	; 0x3b9e <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    3b5c:	8c e0       	ldi	r24, 0x0C	; 12
    3b5e:	68 e0       	ldi	r22, 0x08	; 8
    3b60:	4f e3       	ldi	r20, 0x3F	; 63
    3b62:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    3b66:	86 e1       	ldi	r24, 0x16	; 22
    3b68:	62 e0       	ldi	r22, 0x02	; 2
    3b6a:	43 e0       	ldi	r20, 0x03	; 3
    3b6c:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>
        break;
    3b70:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    3b72:	8c e0       	ldi	r24, 0x0C	; 12
    3b74:	6c e0       	ldi	r22, 0x0C	; 12
    3b76:	4f e3       	ldi	r20, 0x3F	; 63
    3b78:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    3b7c:	86 e1       	ldi	r24, 0x16	; 22
    3b7e:	62 e0       	ldi	r22, 0x02	; 2
    3b80:	43 e0       	ldi	r20, 0x03	; 3
    3b82:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>
        break;
    3b86:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    3b88:	8c e0       	ldi	r24, 0x0C	; 12
    3b8a:	6c e1       	ldi	r22, 0x1C	; 28
    3b8c:	4f e3       	ldi	r20, 0x3F	; 63
    3b8e:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    3b92:	86 e1       	ldi	r24, 0x16	; 22
    3b94:	62 e0       	ldi	r22, 0x02	; 2
    3b96:	43 e0       	ldi	r20, 0x03	; 3
    3b98:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>
        break;
    3b9c:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    3b9e:	8c e0       	ldi	r24, 0x0C	; 12
    3ba0:	60 e0       	ldi	r22, 0x00	; 0
    3ba2:	4f e3       	ldi	r20, 0x3F	; 63
    3ba4:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    3ba8:	86 e1       	ldi	r24, 0x16	; 22
    3baa:	63 e0       	ldi	r22, 0x03	; 3
    3bac:	43 e0       	ldi	r20, 0x03	; 3
    3bae:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>
    3bb2:	08 95       	ret

00003bb4 <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    3bb4:	cf 93       	push	r28
    3bb6:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    3bb8:	88 e0       	ldi	r24, 0x08	; 8
    3bba:	6c 2f       	mov	r22, r28
    3bbc:	4f e1       	ldi	r20, 0x1F	; 31
    3bbe:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    3bc2:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    3bc6:	86 30       	cpi	r24, 0x06	; 6
    3bc8:	11 f0       	breq	.+4      	; 0x3bce <chb_set_channel+0x1a>
    3bca:	89 30       	cpi	r24, 0x09	; 9
    3bcc:	31 f4       	brne	.+12     	; 0x3bda <chb_set_channel+0x26>
    3bce:	8f e6       	ldi	r24, 0x6F	; 111
    3bd0:	93 e0       	ldi	r25, 0x03	; 3
    3bd2:	01 97       	sbiw	r24, 0x01	; 1
    3bd4:	f1 f7       	brne	.-4      	; 0x3bd2 <chb_set_channel+0x1e>
    3bd6:	00 c0       	rjmp	.+0      	; 0x3bd8 <chb_set_channel+0x24>
    3bd8:	00 00       	nop
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    3bda:	88 e0       	ldi	r24, 0x08	; 8
    3bdc:	0e 94 b7 1c 	call	0x396e	; 0x396e <chb_reg_read>
    3be0:	90 e0       	ldi	r25, 0x00	; 0
    3be2:	8f 71       	andi	r24, 0x1F	; 31
    3be4:	90 70       	andi	r25, 0x00	; 0
    3be6:	6c 2f       	mov	r22, r28
    3be8:	70 e0       	ldi	r23, 0x00	; 0
    3bea:	86 17       	cp	r24, r22
    3bec:	97 07       	cpc	r25, r23
    3bee:	11 f4       	brne	.+4      	; 0x3bf4 <chb_set_channel+0x40>
    3bf0:	80 e4       	ldi	r24, 0x40	; 64
    3bf2:	01 c0       	rjmp	.+2      	; 0x3bf6 <chb_set_channel+0x42>
    3bf4:	83 e4       	ldi	r24, 0x43	; 67
}
    3bf6:	cf 91       	pop	r28
    3bf8:	08 95       	ret

00003bfa <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    3bfa:	cf 93       	push	r28
    3bfc:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    3bfe:	0e 94 b7 1c 	call	0x396e	; 0x396e <chb_reg_read>
    3c02:	8c 2b       	or	r24, r28
    3c04:	8f 5f       	subi	r24, 0xFF	; 255
    3c06:	0e 94 b7 1c 	call	0x396e	; 0x396e <chb_reg_read>
    }
    return val;
}
    3c0a:	80 e0       	ldi	r24, 0x00	; 0
    3c0c:	90 e0       	ldi	r25, 0x00	; 0
    3c0e:	cf 91       	pop	r28
    3c10:	08 95       	ret

00003c12 <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
    3c12:	e4 e6       	ldi	r30, 0x64	; 100
    3c14:	f6 e0       	ldi	r31, 0x06	; 6
    3c16:	80 81       	ld	r24, Z
    3c18:	81 60       	ori	r24, 0x01	; 1
    3c1a:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
    3c1c:	80 81       	ld	r24, Z
    3c1e:	8d 7f       	andi	r24, 0xFD	; 253
    3c20:	80 83       	st	Z, r24
    3c22:	8f ed       	ldi	r24, 0xDF	; 223
    3c24:	9b e0       	ldi	r25, 0x0B	; 11
    3c26:	01 97       	sbiw	r24, 0x01	; 1
    3c28:	f1 f7       	brne	.-4      	; 0x3c26 <chb_reset+0x14>
    3c2a:	00 c0       	rjmp	.+0      	; 0x3c2c <chb_reset+0x1a>
    3c2c:	00 00       	nop

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    3c2e:	80 81       	ld	r24, Z
    3c30:	8e 7f       	andi	r24, 0xFE	; 254
    3c32:	80 83       	st	Z, r24
    3c34:	9a e0       	ldi	r25, 0x0A	; 10
    3c36:	9a 95       	dec	r25
    3c38:	f1 f7       	brne	.-4      	; 0x3c36 <chb_reset+0x24>
    3c3a:	00 c0       	rjmp	.+0      	; 0x3c3c <chb_reset+0x2a>
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    3c3c:	80 81       	ld	r24, Z
    3c3e:	81 60       	ori	r24, 0x01	; 1
    3c40:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    3c42:	8d e1       	ldi	r24, 0x1D	; 29
    3c44:	0e 94 b7 1c 	call	0x396e	; 0x396e <chb_reg_read>
    3c48:	81 30       	cpi	r24, 0x01	; 1
    3c4a:	d9 f7       	brne	.-10     	; 0x3c42 <chb_reset+0x30>
    3c4c:	8c e1       	ldi	r24, 0x1C	; 28
    3c4e:	0e 94 b7 1c 	call	0x396e	; 0x396e <chb_reg_read>
    3c52:	87 30       	cpi	r24, 0x07	; 7
    3c54:	b1 f7       	brne	.-20     	; 0x3c42 <chb_reset+0x30>
            break;
        }
    }
	

}
    3c56:	08 95       	ret

00003c58 <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    3c58:	0f 93       	push	r16
    3c5a:	1f 93       	push	r17
    3c5c:	cf 93       	push	r28
    3c5e:	df 93       	push	r29
    3c60:	cd b7       	in	r28, 0x3d	; 61
    3c62:	de b7       	in	r29, 0x3e	; 62
    3c64:	ea 97       	sbiw	r28, 0x3a	; 58
    3c66:	cd bf       	out	0x3d, r28	; 61
    3c68:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    3c6a:	0e 94 3e 20 	call	0x407c	; 0x407c <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    3c6e:	e0 e6       	ldi	r30, 0x60	; 96
    3c70:	f6 e0       	ldi	r31, 0x06	; 6
    3c72:	80 81       	ld	r24, Z
    3c74:	82 60       	ori	r24, 0x02	; 2
    3c76:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    3c78:	80 81       	ld	r24, Z
    3c7a:	81 60       	ori	r24, 0x01	; 1
    3c7c:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    3c7e:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    3c82:	8e e0       	ldi	r24, 0x0E	; 14
    3c84:	60 e0       	ldi	r22, 0x00	; 0
    3c86:	0e 94 3b 1c 	call	0x3876	; 0x3876 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    3c8a:	82 e0       	ldi	r24, 0x02	; 2
    3c8c:	63 e0       	ldi	r22, 0x03	; 3
    3c8e:	4f e1       	ldi	r20, 0x1F	; 31
    3c90:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    3c94:	81 e0       	ldi	r24, 0x01	; 1
    3c96:	0e 94 b7 1c 	call	0x396e	; 0x396e <chb_reg_read>
    3c9a:	8f 71       	andi	r24, 0x1F	; 31
    3c9c:	88 30       	cpi	r24, 0x08	; 8
    3c9e:	d1 f7       	brne	.-12     	; 0x3c94 <chb_drvr_init+0x3c>

    // set radio cfg parameters
    // **note** uncomment if these will be set to something other than default
    chb_reg_read_mod_write(XAH_CTRL_0, CHB_MAX_FRAME_RETRIES << CHB_MAX_FRAME_RETRIES_POS, 0xF << CHB_MAX_FRAME_RETRIES_POS);
    3ca0:	8c e2       	ldi	r24, 0x2C	; 44
    3ca2:	60 e3       	ldi	r22, 0x30	; 48
    3ca4:	40 ef       	ldi	r20, 0xF0	; 240
    3ca6:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>
    //chb_reg_read_mod_write(XAH_CTRL_0, CHB_MAX_CSMA_RETRIES << CHB_MAX_CSMA_RETIRES_POS, 0x7 << CHB_MAX_CSMA_RETIRES_POS);
    //chb_reg_read_mod_write(CSMA_SEED_1, CHB_CSMA_SEED1 << CHB_CSMA_SEED1_POS, 0x7 << CHB_CSMA_SEED1_POS);
    chb_reg_write(CSMA_SEED_0, CHB_CSMA_SEED0);     
    3caa:	8d e2       	ldi	r24, 0x2D	; 45
    3cac:	60 e0       	ldi	r22, 0x00	; 0
    3cae:	0e 94 3b 1c 	call	0x3876	; 0x3876 <chb_reg_write>
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    3cb2:	8e e2       	ldi	r24, 0x2E	; 46
    3cb4:	60 e4       	ldi	r22, 0x40	; 64
    3cb6:	40 ec       	ldi	r20, 0xC0	; 192
    3cb8:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    3cbc:	8e e0       	ldi	r24, 0x0E	; 14
    3cbe:	6c e0       	ldi	r22, 0x0C	; 12
    3cc0:	0e 94 3b 1c 	call	0x3876	; 0x3876 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    3cc4:	84 e0       	ldi	r24, 0x04	; 4
    3cc6:	60 e2       	ldi	r22, 0x20	; 32
    3cc8:	40 e2       	ldi	r20, 0x20	; 32
    3cca:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    3cce:	81 e0       	ldi	r24, 0x01	; 1
    3cd0:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    3cd4:	81 e0       	ldi	r24, 0x01	; 1
    3cd6:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    3cda:	86 e1       	ldi	r24, 0x16	; 22
    3cdc:	0e 94 ea 1c 	call	0x39d4	; 0x39d4 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    3ce0:	82 e2       	ldi	r24, 0x22	; 34
    3ce2:	64 e3       	ldi	r22, 0x34	; 52
    3ce4:	72 e1       	ldi	r23, 0x12	; 18
    3ce6:	0e 94 82 1c 	call	0x3904	; 0x3904 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    3cea:	0e 94 ce 1b 	call	0x379c	; 0x379c <chb_get_short_addr>
    3cee:	bc 01       	movw	r22, r24
    3cf0:	80 e2       	ldi	r24, 0x20	; 32
    3cf2:	0e 94 82 1c 	call	0x3904	; 0x3904 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    3cf6:	ce 01       	movw	r24, r28
    3cf8:	01 96       	adiw	r24, 0x01	; 1
    3cfa:	0e 94 c6 1b 	call	0x378c	; 0x378c <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    3cfe:	84 e2       	ldi	r24, 0x24	; 36
    3d00:	be 01       	movw	r22, r28
    3d02:	6f 5f       	subi	r22, 0xFF	; 255
    3d04:	7f 4f       	sbci	r23, 0xFF	; 255
    3d06:	0e 94 5c 1c 	call	0x38b8	; 0x38b8 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    3d0a:	e2 e7       	ldi	r30, 0x72	; 114
    3d0c:	f6 e0       	ldi	r31, 0x06	; 6
    3d0e:	80 81       	ld	r24, Z
    3d10:	81 60       	ori	r24, 0x01	; 1
    3d12:	80 83       	st	Z, r24
    3d14:	e9 e6       	ldi	r30, 0x69	; 105
    3d16:	f6 e0       	ldi	r31, 0x06	; 6
    3d18:	80 81       	ld	r24, Z
    3d1a:	83 60       	ori	r24, 0x03	; 3
    3d1c:	80 83       	st	Z, r24
    3d1e:	ea e6       	ldi	r30, 0x6A	; 106
    3d20:	f6 e0       	ldi	r31, 0x06	; 6
    3d22:	80 81       	ld	r24, Z
    3d24:	84 60       	ori	r24, 0x04	; 4
    3d26:	80 83       	st	Z, r24
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    3d28:	e0 ea       	ldi	r30, 0xA0	; 160
    3d2a:	f0 e0       	ldi	r31, 0x00	; 0
    3d2c:	82 81       	ldd	r24, Z+2	; 0x02
    3d2e:	87 60       	ori	r24, 0x07	; 7
    3d30:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
    3d32:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <chb_get_state>
    3d36:	86 31       	cpi	r24, 0x16	; 22
    3d38:	91 f0       	breq	.+36     	; 0x3d5e <chb_drvr_init+0x106>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    3d3a:	8e 01       	movw	r16, r28
    3d3c:	07 5f       	subi	r16, 0xF7	; 247
    3d3e:	1f 4f       	sbci	r17, 0xFF	; 255
    3d40:	c8 01       	movw	r24, r16
    3d42:	68 ee       	ldi	r22, 0xE8	; 232
    3d44:	71 e0       	ldi	r23, 0x01	; 1
    3d46:	0e 94 36 3a 	call	0x746c	; 0x746c <strcpy_P>
        printf(buf);
    3d4a:	0f 92       	push	r0
    3d4c:	0f 92       	push	r0
    3d4e:	ed b7       	in	r30, 0x3d	; 61
    3d50:	fe b7       	in	r31, 0x3e	; 62
    3d52:	01 83       	std	Z+1, r16	; 0x01
    3d54:	12 83       	std	Z+2, r17	; 0x02
    3d56:	0e 94 7b 3a 	call	0x74f6	; 0x74f6 <printf>
    3d5a:	0f 90       	pop	r0
    3d5c:	0f 90       	pop	r0
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
    3d5e:	ea 96       	adiw	r28, 0x3a	; 58
    3d60:	cd bf       	out	0x3d, r28	; 61
    3d62:	de bf       	out	0x3e, r29	; 62
    3d64:	df 91       	pop	r29
    3d66:	cf 91       	pop	r28
    3d68:	1f 91       	pop	r17
    3d6a:	0f 91       	pop	r16
    3d6c:	08 95       	ret

00003d6e <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    3d6e:	1f 92       	push	r1
    3d70:	0f 92       	push	r0
    3d72:	0f b6       	in	r0, 0x3f	; 63
    3d74:	0f 92       	push	r0
    3d76:	0b b6       	in	r0, 0x3b	; 59
    3d78:	0f 92       	push	r0
    3d7a:	11 24       	eor	r1, r1
    3d7c:	af 92       	push	r10
    3d7e:	bf 92       	push	r11
    3d80:	cf 92       	push	r12
    3d82:	df 92       	push	r13
    3d84:	ef 92       	push	r14
    3d86:	ff 92       	push	r15
    3d88:	0f 93       	push	r16
    3d8a:	1f 93       	push	r17
    3d8c:	2f 93       	push	r18
    3d8e:	3f 93       	push	r19
    3d90:	4f 93       	push	r20
    3d92:	5f 93       	push	r21
    3d94:	6f 93       	push	r22
    3d96:	7f 93       	push	r23
    3d98:	8f 93       	push	r24
    3d9a:	9f 93       	push	r25
    3d9c:	af 93       	push	r26
    3d9e:	bf 93       	push	r27
    3da0:	cf 93       	push	r28
    3da2:	df 93       	push	r29
    3da4:	ef 93       	push	r30
    3da6:	ff 93       	push	r31
    U8 state, intp_src = 0;
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    3da8:	0e 94 78 1a 	call	0x34f0	; 0x34f0 <chb_get_pcb>
    3dac:	8c 01       	movw	r16, r24

    CHB_ENTER_CRIT();
    3dae:	8f b7       	in	r24, 0x3f	; 63
    3db0:	80 93 5c 40 	sts	0x405C, r24
    3db4:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    3db6:	81 e0       	ldi	r24, 0x01	; 1
    3db8:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    3dbc:	8f e8       	ldi	r24, 0x8F	; 143
    3dbe:	0e 94 51 20 	call	0x40a2	; 0x40a2 <SPID_write>
    intp_src = SPID_write(0);
    3dc2:	80 e0       	ldi	r24, 0x00	; 0
    3dc4:	0e 94 51 20 	call	0x40a2	; 0x40a2 <SPID_write>
    3dc8:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    3dca:	80 e0       	ldi	r24, 0x00	; 0
    3dcc:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <RadioCS>

    while (intp_src)
    3dd0:	cc 23       	and	r28, r28
    3dd2:	09 f4       	brne	.+2      	; 0x3dd6 <__vector_64+0x68>
    3dd4:	97 c0       	rjmp	.+302    	; 0x3f04 <__vector_64+0x196>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            //else{
                pcb->tx_end = true;
    3dd6:	ff 24       	eor	r15, r15
    3dd8:	f3 94       	inc	r15

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3dda:	cc 24       	eor	r12, r12
    3ddc:	dd 24       	eor	r13, r13
    3dde:	68 94       	set
    3de0:	c7 f8       	bld	r12, 7
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    3de2:	c2 ff       	sbrs	r28, 2
    3de4:	02 c0       	rjmp	.+4      	; 0x3dea <__vector_64+0x7c>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    3de6:	cb 7f       	andi	r28, 0xFB	; 251
    3de8:	8a c0       	rjmp	.+276    	; 0x3efe <__vector_64+0x190>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    3dea:	c3 ff       	sbrs	r28, 3
    3dec:	6f c0       	rjmp	.+222    	; 0x3ecc <__vector_64+0x15e>
        {
            state = chb_get_state();
    3dee:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    3df2:	86 30       	cpi	r24, 0x06	; 6
    3df4:	29 f0       	breq	.+10     	; 0x3e00 <__vector_64+0x92>
    3df6:	86 31       	cpi	r24, 0x16	; 22
    3df8:	19 f0       	breq	.+6      	; 0x3e00 <__vector_64+0x92>
    3dfa:	81 31       	cpi	r24, 0x11	; 17
    3dfc:	09 f0       	breq	.+2      	; 0x3e00 <__vector_64+0x92>
    3dfe:	5a c0       	rjmp	.+180    	; 0x3eb4 <__vector_64+0x146>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    3e00:	87 e0       	ldi	r24, 0x07	; 7
    3e02:	0e 94 b7 1c 	call	0x396e	; 0x396e <chb_reg_read>
    3e06:	f8 01       	movw	r30, r16
    3e08:	86 8b       	std	Z+22, r24	; 0x16

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    3e0a:	86 e0       	ldi	r24, 0x06	; 6
    3e0c:	0e 94 b7 1c 	call	0x396e	; 0x396e <chb_reg_read>
    3e10:	88 1f       	adc	r24, r24
    3e12:	88 27       	eor	r24, r24
    3e14:	88 1f       	adc	r24, r24
    3e16:	f8 01       	movw	r30, r16
    3e18:	87 8b       	std	Z+23, r24	; 0x17

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    3e1a:	88 23       	and	r24, r24
    3e1c:	09 f4       	brne	.+2      	; 0x3e20 <__vector_64+0xb2>
    3e1e:	4a c0       	rjmp	.+148    	; 0x3eb4 <__vector_64+0x146>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
    3e20:	8f b7       	in	r24, 0x3f	; 63
    3e22:	80 93 5c 40 	sts	0x405C, r24
    3e26:	f8 94       	cli
    RadioCS(TRUE);
    3e28:	8f 2d       	mov	r24, r15
    3e2a:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    3e2e:	80 e2       	ldi	r24, 0x20	; 32
    3e30:	0e 94 51 20 	call	0x40a2	; 0x40a2 <SPID_write>
    len = SPID_write(0);
    3e34:	80 e0       	ldi	r24, 0x00	; 0
    3e36:	0e 94 51 20 	call	0x40a2	; 0x40a2 <SPID_write>
    3e3a:	e8 2e       	mov	r14, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    3e3c:	83 50       	subi	r24, 0x03	; 3
    3e3e:	8d 37       	cpi	r24, 0x7D	; 125
    3e40:	58 f5       	brcc	.+86     	; 0x3e98 <__vector_64+0x12a>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3e42:	0e 94 c3 1b 	call	0x3786	; 0x3786 <chb_buf_get_len>
    3e46:	2e 2d       	mov	r18, r14
    3e48:	30 e0       	ldi	r19, 0x00	; 0
    3e4a:	a6 01       	movw	r20, r12
    3e4c:	48 1b       	sub	r20, r24
    3e4e:	51 09       	sbc	r21, r1
    3e50:	24 17       	cp	r18, r20
    3e52:	35 07       	cpc	r19, r21
    3e54:	7c f4       	brge	.+30     	; 0x3e74 <__vector_64+0x106>
        {
            chb_buf_write(len);
    3e56:	8e 2d       	mov	r24, r14
    3e58:	0e 94 97 1b 	call	0x372e	; 0x372e <chb_buf_write>
            
            for (i=0; i<len; i++)
    3e5c:	ee 20       	and	r14, r14
    3e5e:	e1 f0       	breq	.+56     	; 0x3e98 <__vector_64+0x12a>
    3e60:	d0 e0       	ldi	r29, 0x00	; 0
            {
                data = SPID_write(0);
    3e62:	80 e0       	ldi	r24, 0x00	; 0
    3e64:	0e 94 51 20 	call	0x40a2	; 0x40a2 <SPID_write>
                chb_buf_write(data);
    3e68:	0e 94 97 1b 	call	0x372e	; 0x372e <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    3e6c:	df 5f       	subi	r29, 0xFF	; 255
    3e6e:	de 15       	cp	r29, r14
    3e70:	c1 f7       	brne	.-16     	; 0x3e62 <__vector_64+0xf4>
    3e72:	12 c0       	rjmp	.+36     	; 0x3e98 <__vector_64+0x12a>
			//PORTE.OUTCLR = PIN2_bm;
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    3e74:	0e 94 78 1a 	call	0x34f0	; 0x34f0 <chb_get_pcb>
    3e78:	5c 01       	movw	r10, r24
            //char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3e7a:	ee 20       	and	r14, r14
    3e7c:	39 f0       	breq	.+14     	; 0x3e8c <__vector_64+0x11e>
    3e7e:	d0 e0       	ldi	r29, 0x00	; 0
            {
                data = SPID_write(0);
    3e80:	80 e0       	ldi	r24, 0x00	; 0
    3e82:	0e 94 51 20 	call	0x40a2	; 0x40a2 <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            //char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3e86:	df 5f       	subi	r29, 0xFF	; 255
    3e88:	de 15       	cp	r29, r14
    3e8a:	d1 f7       	brne	.-12     	; 0x3e80 <__vector_64+0x112>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    3e8c:	f5 01       	movw	r30, r10
    3e8e:	81 89       	ldd	r24, Z+17	; 0x11
    3e90:	92 89       	ldd	r25, Z+18	; 0x12
    3e92:	01 96       	adiw	r24, 0x01	; 1
    3e94:	81 8b       	std	Z+17, r24	; 0x11
    3e96:	92 8b       	std	Z+18, r25	; 0x12
            //strcpy_P(buf, chb_err_overflow);
            //printf(buf);
        }
    }

    RadioCS(FALSE);
    3e98:	80 e0       	ldi	r24, 0x00	; 0
    3e9a:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <RadioCS>
    CHB_LEAVE_CRIT();
    3e9e:	80 91 5c 40 	lds	r24, 0x405C
    3ea2:	8f bf       	out	0x3f, r24	; 63
    3ea4:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
    3ea6:	f8 01       	movw	r30, r16
    3ea8:	81 85       	ldd	r24, Z+9	; 0x09
    3eaa:	92 85       	ldd	r25, Z+10	; 0x0a
    3eac:	01 96       	adiw	r24, 0x01	; 1
    3eae:	81 87       	std	Z+9, r24	; 0x09
    3eb0:	92 87       	std	Z+10, r25	; 0x0a
                    pcb->data_rcv = true;
    3eb2:	f7 82       	std	Z+7, r15	; 0x07
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            //else{
                pcb->tx_end = true;
    3eb4:	f8 01       	movw	r30, r16
    3eb6:	f0 86       	std	Z+8, r15	; 0x08
            //}
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    3eb8:	c7 7f       	andi	r28, 0xF7	; 247
			//go to receive state
            while (chb_get_state() != RX_STATE){
    3eba:	03 c0       	rjmp	.+6      	; 0x3ec2 <__vector_64+0x154>
	            chb_set_state(RX_STATE);
    3ebc:	86 e1       	ldi	r24, 0x16	; 22
    3ebe:	0e 94 ea 1c 	call	0x39d4	; 0x39d4 <chb_set_state>
            //else{
                pcb->tx_end = true;
            //}
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
			//go to receive state
            while (chb_get_state() != RX_STATE){
    3ec2:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <chb_get_state>
    3ec6:	86 31       	cpi	r24, 0x16	; 22
    3ec8:	c9 f7       	brne	.-14     	; 0x3ebc <__vector_64+0x14e>
    3eca:	19 c0       	rjmp	.+50     	; 0x3efe <__vector_64+0x190>
	            chb_set_state(RX_STATE);
            }
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    3ecc:	c6 ff       	sbrs	r28, 6
    3ece:	08 c0       	rjmp	.+16     	; 0x3ee0 <__vector_64+0x172>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    3ed0:	cf 7b       	andi	r28, 0xBF	; 191
            pcb->underrun++;
    3ed2:	f8 01       	movw	r30, r16
    3ed4:	83 89       	ldd	r24, Z+19	; 0x13
    3ed6:	94 89       	ldd	r25, Z+20	; 0x14
    3ed8:	01 96       	adiw	r24, 0x01	; 1
    3eda:	83 8b       	std	Z+19, r24	; 0x13
    3edc:	94 8b       	std	Z+20, r25	; 0x14
    3ede:	0f c0       	rjmp	.+30     	; 0x3efe <__vector_64+0x190>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    3ee0:	c1 ff       	sbrs	r28, 1
    3ee2:	02 c0       	rjmp	.+4      	; 0x3ee8 <__vector_64+0x17a>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    3ee4:	cd 7f       	andi	r28, 0xFD	; 253
    3ee6:	0b c0       	rjmp	.+22     	; 0x3efe <__vector_64+0x190>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    3ee8:	c0 ff       	sbrs	r28, 0
    3eea:	02 c0       	rjmp	.+4      	; 0x3ef0 <__vector_64+0x182>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    3eec:	ce 7f       	andi	r28, 0xFE	; 254
    3eee:	07 c0       	rjmp	.+14     	; 0x3efe <__vector_64+0x190>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    3ef0:	cc 23       	and	r28, r28
    3ef2:	2c f4       	brge	.+10     	; 0x3efe <__vector_64+0x190>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    3ef4:	cf 77       	andi	r28, 0x7F	; 127
            pcb->battlow++;
    3ef6:	f8 01       	movw	r30, r16
    3ef8:	85 89       	ldd	r24, Z+21	; 0x15
    3efa:	8f 5f       	subi	r24, 0xFF	; 255
    3efc:	85 8b       	std	Z+21, r24	; 0x15
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    3efe:	cc 23       	and	r28, r28
    3f00:	09 f0       	breq	.+2      	; 0x3f04 <__vector_64+0x196>
    3f02:	6f cf       	rjmp	.-290    	; 0x3de2 <__vector_64+0x74>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    3f04:	80 91 5c 40 	lds	r24, 0x405C
    3f08:	8f bf       	out	0x3f, r24	; 63
    3f0a:	78 94       	sei
}
    3f0c:	ff 91       	pop	r31
    3f0e:	ef 91       	pop	r30
    3f10:	df 91       	pop	r29
    3f12:	cf 91       	pop	r28
    3f14:	bf 91       	pop	r27
    3f16:	af 91       	pop	r26
    3f18:	9f 91       	pop	r25
    3f1a:	8f 91       	pop	r24
    3f1c:	7f 91       	pop	r23
    3f1e:	6f 91       	pop	r22
    3f20:	5f 91       	pop	r21
    3f22:	4f 91       	pop	r20
    3f24:	3f 91       	pop	r19
    3f26:	2f 91       	pop	r18
    3f28:	1f 91       	pop	r17
    3f2a:	0f 91       	pop	r16
    3f2c:	ff 90       	pop	r15
    3f2e:	ef 90       	pop	r14
    3f30:	df 90       	pop	r13
    3f32:	cf 90       	pop	r12
    3f34:	bf 90       	pop	r11
    3f36:	af 90       	pop	r10
    3f38:	0f 90       	pop	r0
    3f3a:	0b be       	out	0x3b, r0	; 59
    3f3c:	0f 90       	pop	r0
    3f3e:	0f be       	out	0x3f, r0	; 63
    3f40:	0f 90       	pop	r0
    3f42:	1f 90       	pop	r1
    3f44:	18 95       	reti

00003f46 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    3f46:	0f 93       	push	r16
    3f48:	1f 93       	push	r17
    3f4a:	cf 93       	push	r28
    3f4c:	df 93       	push	r29
    3f4e:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3f50:	e0 ec       	ldi	r30, 0xC0	; 192
    3f52:	f1 e0       	ldi	r31, 0x01	; 1
    3f54:	84 85       	ldd	r24, Z+12	; 0x0c
    3f56:	87 7f       	andi	r24, 0xF7	; 247
    3f58:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    3f5a:	41 15       	cp	r20, r1
    3f5c:	51 05       	cpc	r21, r1
    3f5e:	09 f4       	brne	.+2      	; 0x3f62 <chb_eeprom_write+0x1c>
    3f60:	50 c0       	rjmp	.+160    	; 0x4002 <chb_eeprom_write+0xbc>
    3f62:	e0 e0       	ldi	r30, 0x00	; 0
    3f64:	f0 e0       	ldi	r31, 0x00	; 0
    3f66:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3f68:	a0 ec       	ldi	r26, 0xC0	; 192
    3f6a:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3f6c:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3f6e:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3f70:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
    3f72:	cf 01       	movw	r24, r30
    3f74:	80 0f       	add	r24, r16
    3f76:	91 1f       	adc	r25, r17
    3f78:	e6 0f       	add	r30, r22
    3f7a:	f7 1f       	adc	r31, r23
    3f7c:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3f7e:	1f 96       	adiw	r26, 0x0f	; 15
    3f80:	ec 91       	ld	r30, X
    3f82:	1f 97       	sbiw	r26, 0x0f	; 15
    3f84:	ee 23       	and	r30, r30
    3f86:	dc f3       	brlt	.-10     	; 0x3f7e <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    3f88:	1f 96       	adiw	r26, 0x0f	; 15
    3f8a:	ec 91       	ld	r30, X
    3f8c:	1f 97       	sbiw	r26, 0x0f	; 15
    3f8e:	e1 ff       	sbrs	r30, 1
    3f90:	11 c0       	rjmp	.+34     	; 0x3fb4 <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3f92:	1a 96       	adiw	r26, 0x0a	; 10
    3f94:	dc 93       	st	X, r29
    3f96:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
    3f98:	ef 93       	push	r30
    3f9a:	ff 93       	push	r31
    3f9c:	0f 93       	push	r16
    3f9e:	2f 93       	push	r18
    3fa0:	eb ec       	ldi	r30, 0xCB	; 203
    3fa2:	f1 e0       	ldi	r31, 0x01	; 1
    3fa4:	08 ed       	ldi	r16, 0xD8	; 216
    3fa6:	21 e0       	ldi	r18, 0x01	; 1
    3fa8:	04 bf       	out	0x34, r16	; 52
    3faa:	20 83       	st	Z, r18
    3fac:	2f 91       	pop	r18
    3fae:	0f 91       	pop	r16
    3fb0:	ff 91       	pop	r31
    3fb2:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3fb4:	1a 96       	adiw	r26, 0x0a	; 10
    3fb6:	cc 93       	st	X, r28
    3fb8:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    3fba:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3fbc:	89 2f       	mov	r24, r25
    3fbe:	8f 71       	andi	r24, 0x1F	; 31
    3fc0:	11 96       	adiw	r26, 0x01	; 1
    3fc2:	8c 93       	st	X, r24
    3fc4:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
    3fc6:	12 96       	adiw	r26, 0x02	; 2
    3fc8:	1c 92       	st	X, r1
    3fca:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
    3fcc:	14 96       	adiw	r26, 0x04	; 4
    3fce:	fc 93       	st	X, r31
    3fd0:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3fd2:	1a 96       	adiw	r26, 0x0a	; 10
    3fd4:	3c 93       	st	X, r19
    3fd6:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
    3fd8:	ef 93       	push	r30
    3fda:	ff 93       	push	r31
    3fdc:	0f 93       	push	r16
    3fde:	2f 93       	push	r18
    3fe0:	eb ec       	ldi	r30, 0xCB	; 203
    3fe2:	f1 e0       	ldi	r31, 0x01	; 1
    3fe4:	08 ed       	ldi	r16, 0xD8	; 216
    3fe6:	21 e0       	ldi	r18, 0x01	; 1
    3fe8:	04 bf       	out	0x34, r16	; 52
    3fea:	20 83       	st	Z, r18
    3fec:	2f 91       	pop	r18
    3fee:	0f 91       	pop	r16
    3ff0:	ff 91       	pop	r31
    3ff2:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    3ff4:	2f 5f       	subi	r18, 0xFF	; 255
    3ff6:	e2 2f       	mov	r30, r18
    3ff8:	f0 e0       	ldi	r31, 0x00	; 0
    3ffa:	e4 17       	cp	r30, r20
    3ffc:	f5 07       	cpc	r31, r21
    3ffe:	08 f4       	brcc	.+2      	; 0x4002 <chb_eeprom_write+0xbc>
    4000:	b8 cf       	rjmp	.-144    	; 0x3f72 <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    4002:	df 91       	pop	r29
    4004:	cf 91       	pop	r28
    4006:	1f 91       	pop	r17
    4008:	0f 91       	pop	r16
    400a:	08 95       	ret

0000400c <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    400c:	1f 93       	push	r17
    400e:	cf 93       	push	r28
    4010:	df 93       	push	r29
    4012:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    4014:	e0 ec       	ldi	r30, 0xC0	; 192
    4016:	f1 e0       	ldi	r31, 0x01	; 1
    4018:	84 85       	ldd	r24, Z+12	; 0x0c
    401a:	87 7f       	andi	r24, 0xF7	; 247
    401c:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    401e:	41 15       	cp	r20, r1
    4020:	51 05       	cpc	r21, r1
    4022:	41 f1       	breq	.+80     	; 0x4074 <chb_eeprom_read+0x68>
    4024:	80 e0       	ldi	r24, 0x00	; 0
    4026:	90 e0       	ldi	r25, 0x00	; 0
    4028:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    402a:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    402c:	db 01       	movw	r26, r22
    402e:	a8 0f       	add	r26, r24
    4030:	b9 1f       	adc	r27, r25
    4032:	82 0f       	add	r24, r18
    4034:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    4036:	17 85       	ldd	r17, Z+15	; 0x0f
    4038:	11 23       	and	r17, r17
    403a:	ec f3       	brlt	.-6      	; 0x4036 <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    403c:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    403e:	89 2f       	mov	r24, r25
    4040:	8f 71       	andi	r24, 0x1F	; 31
    4042:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
    4044:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    4046:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
    4048:	ef 93       	push	r30
    404a:	ff 93       	push	r31
    404c:	0f 93       	push	r16
    404e:	2f 93       	push	r18
    4050:	eb ec       	ldi	r30, 0xCB	; 203
    4052:	f1 e0       	ldi	r31, 0x01	; 1
    4054:	08 ed       	ldi	r16, 0xD8	; 216
    4056:	21 e0       	ldi	r18, 0x01	; 1
    4058:	04 bf       	out	0x34, r16	; 52
    405a:	20 83       	st	Z, r18
    405c:	2f 91       	pop	r18
    405e:	0f 91       	pop	r16
    4060:	ff 91       	pop	r31
    4062:	ef 91       	pop	r30

    return NVM.DATA0;
    4064:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    4066:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    4068:	cf 5f       	subi	r28, 0xFF	; 255
    406a:	8c 2f       	mov	r24, r28
    406c:	90 e0       	ldi	r25, 0x00	; 0
    406e:	84 17       	cp	r24, r20
    4070:	95 07       	cpc	r25, r21
    4072:	e0 f2       	brcs	.-72     	; 0x402c <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    4074:	df 91       	pop	r29
    4076:	cf 91       	pop	r28
    4078:	1f 91       	pop	r17
    407a:	08 95       	ret

0000407c <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    407c:	e0 e6       	ldi	r30, 0x60	; 96
    407e:	f6 e0       	ldi	r31, 0x06	; 6
    4080:	80 81       	ld	r24, Z
    4082:	80 6b       	ori	r24, 0xB0	; 176
    4084:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    4086:	e4 e6       	ldi	r30, 0x64	; 100
    4088:	f6 e0       	ldi	r31, 0x06	; 6
    408a:	80 81       	ld	r24, Z
    408c:	80 61       	ori	r24, 0x10	; 16
    408e:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    4090:	a0 ec       	ldi	r26, 0xC0	; 192
    4092:	b9 e0       	ldi	r27, 0x09	; 9
    4094:	8c 91       	ld	r24, X
    4096:	81 65       	ori	r24, 0x51	; 81
    4098:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    409a:	80 81       	ld	r24, Z
    409c:	80 61       	ori	r24, 0x10	; 16
    409e:	80 83       	st	Z, r24
}
    40a0:	08 95       	ret

000040a2 <SPID_write>:
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    40a2:	e0 ec       	ldi	r30, 0xC0	; 192
    40a4:	f9 e0       	ldi	r31, 0x09	; 9
    40a6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    40a8:	82 81       	ldd	r24, Z+2	; 0x02
    40aa:	88 23       	and	r24, r24
    40ac:	ec f7       	brge	.-6      	; 0x40a8 <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    40ae:	e0 ec       	ldi	r30, 0xC0	; 192
    40b0:	f9 e0       	ldi	r31, 0x09	; 9
    40b2:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    40b4:	08 95       	ret

000040b6 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    40b6:	0f 93       	push	r16
    40b8:	cf 93       	push	r28
    40ba:	df 93       	push	r29
    40bc:	0f 92       	push	r0
    40be:	cd b7       	in	r28, 0x3d	; 61
    40c0:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    40c2:	2f b7       	in	r18, 0x3f	; 63
    40c4:	29 83       	std	Y+1, r18	; 0x01
    40c6:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    40c8:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    40ca:	fc 01       	movw	r30, r24
    40cc:	08 ed       	ldi	r16, 0xD8	; 216
    40ce:	04 bf       	out	0x34, r16	; 52
    40d0:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    40d2:	89 81       	ldd	r24, Y+1	; 0x01
    40d4:	8f bf       	out	0x3f, r24	; 63
#endif
}
    40d6:	0f 90       	pop	r0
    40d8:	df 91       	pop	r29
    40da:	cf 91       	pop	r28
    40dc:	0f 91       	pop	r16
    40de:	08 95       	ret

000040e0 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    40e0:	66 23       	and	r22, r22
    40e2:	11 f0       	breq	.+4      	; 0x40e8 <CLKSYS_XOSC_Config+0x8>
    40e4:	90 e2       	ldi	r25, 0x20	; 32
    40e6:	01 c0       	rjmp	.+2      	; 0x40ea <CLKSYS_XOSC_Config+0xa>
    40e8:	90 e0       	ldi	r25, 0x00	; 0
    40ea:	84 2b       	or	r24, r20
    40ec:	89 2b       	or	r24, r25
    40ee:	e0 e5       	ldi	r30, 0x50	; 80
    40f0:	f0 e0       	ldi	r31, 0x00	; 0
    40f2:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    40f4:	08 95       	ret

000040f6 <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    40f6:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    40f8:	86 2b       	or	r24, r22
    40fa:	e0 e5       	ldi	r30, 0x50	; 80
    40fc:	f0 e0       	ldi	r31, 0x00	; 0
    40fe:	85 83       	std	Z+5, r24	; 0x05
}
    4100:	08 95       	ret

00004102 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    4102:	e0 e5       	ldi	r30, 0x50	; 80
    4104:	f0 e0       	ldi	r31, 0x00	; 0
    4106:	90 81       	ld	r25, Z
    4108:	28 2f       	mov	r18, r24
    410a:	20 95       	com	r18
    410c:	92 23       	and	r25, r18
    410e:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    4110:	90 81       	ld	r25, Z
	return clkEnabled;
}
    4112:	89 23       	and	r24, r25
    4114:	08 95       	ret

00004116 <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    4116:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    4118:	81 e4       	ldi	r24, 0x41	; 65
    411a:	90 e0       	ldi	r25, 0x00	; 0
    411c:	0e 94 5b 20 	call	0x40b6	; 0x40b6 <CCPWrite>
}
    4120:	08 95       	ret

00004122 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    4122:	1f 93       	push	r17
    4124:	cf 93       	push	r28
    4126:	df 93       	push	r29
    4128:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    412a:	c0 e4       	ldi	r28, 0x40	; 64
    412c:	d0 e0       	ldi	r29, 0x00	; 0
    412e:	68 81       	ld	r22, Y
    4130:	68 7f       	andi	r22, 0xF8	; 248
    4132:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    4134:	80 e4       	ldi	r24, 0x40	; 64
    4136:	90 e0       	ldi	r25, 0x00	; 0
    4138:	0e 94 5b 20 	call	0x40b6	; 0x40b6 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    413c:	88 81       	ld	r24, Y
	return clkCtrl;
}
    413e:	81 23       	and	r24, r17
    4140:	df 91       	pop	r29
    4142:	cf 91       	pop	r28
    4144:	1f 91       	pop	r17
    4146:	08 95       	ret

00004148 <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    4148:	e0 e4       	ldi	r30, 0x40	; 64
    414a:	f0 e0       	ldi	r31, 0x00	; 0
    414c:	93 81       	ldd	r25, Z+3	; 0x03
    414e:	91 7f       	andi	r25, 0xF1	; 241
    4150:	91 60       	ori	r25, 0x01	; 1
    4152:	89 2b       	or	r24, r25
    4154:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    4156:	08 95       	ret

00004158 <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    4158:	e0 e5       	ldi	r30, 0x50	; 80
    415a:	f0 e0       	ldi	r31, 0x00	; 0
    415c:	26 81       	ldd	r18, Z+6	; 0x06
    415e:	98 2f       	mov	r25, r24
    4160:	38 2f       	mov	r19, r24
    4162:	30 95       	com	r19
    4164:	23 23       	and	r18, r19
    4166:	66 23       	and	r22, r22
    4168:	09 f4       	brne	.+2      	; 0x416c <CLKSYS_AutoCalibration_Enable+0x14>
    416a:	90 e0       	ldi	r25, 0x00	; 0
    416c:	92 2b       	or	r25, r18
    416e:	e0 e5       	ldi	r30, 0x50	; 80
    4170:	f0 e0       	ldi	r31, 0x00	; 0
    4172:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    4174:	81 30       	cpi	r24, 0x01	; 1
    4176:	31 f4       	brne	.+12     	; 0x4184 <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    4178:	e8 e6       	ldi	r30, 0x68	; 104
    417a:	f0 e0       	ldi	r31, 0x00	; 0
    417c:	80 81       	ld	r24, Z
    417e:	81 60       	ori	r24, 0x01	; 1
    4180:	80 83       	st	Z, r24
    4182:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    4184:	82 30       	cpi	r24, 0x02	; 2
    4186:	29 f4       	brne	.+10     	; 0x4192 <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    4188:	e0 e6       	ldi	r30, 0x60	; 96
    418a:	f0 e0       	ldi	r31, 0x00	; 0
    418c:	80 81       	ld	r24, Z
    418e:	81 60       	ori	r24, 0x01	; 1
    4190:	80 83       	st	Z, r24
    4192:	08 95       	ret

00004194 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    4194:	83 e5       	ldi	r24, 0x53	; 83
    4196:	90 e0       	ldi	r25, 0x00	; 0
    4198:	63 e0       	ldi	r22, 0x03	; 3
    419a:	0e 94 5b 20 	call	0x40b6	; 0x40b6 <CCPWrite>
}
    419e:	08 95       	ret

000041a0 <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    41a0:	82 e4       	ldi	r24, 0x42	; 66
    41a2:	90 e0       	ldi	r25, 0x00	; 0
    41a4:	61 e0       	ldi	r22, 0x01	; 1
    41a6:	0e 94 5b 20 	call	0x40b6	; 0x40b6 <CCPWrite>
}
    41aa:	08 95       	ret

000041ac <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    41ac:	cf 92       	push	r12
    41ae:	df 92       	push	r13
    41b0:	ef 92       	push	r14
    41b2:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    41b4:	20 91 6e 50 	lds	r18, 0x506E
    41b8:	30 91 6f 50 	lds	r19, 0x506F
    41bc:	c0 90 52 40 	lds	r12, 0x4052
    41c0:	d0 90 53 40 	lds	r13, 0x4053
    41c4:	e0 90 54 40 	lds	r14, 0x4054
    41c8:	f0 90 55 40 	lds	r15, 0x4055
    41cc:	62 50       	subi	r22, 0x02	; 2
    41ce:	70 40       	sbci	r23, 0x00	; 0
    41d0:	80 40       	sbci	r24, 0x00	; 0
    41d2:	90 40       	sbci	r25, 0x00	; 0
    41d4:	40 e0       	ldi	r20, 0x00	; 0
    41d6:	50 e0       	ldi	r21, 0x00	; 0
    41d8:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    41dc:	dc 01       	movw	r26, r24
    41de:	cb 01       	movw	r24, r22
    41e0:	c8 0e       	add	r12, r24
    41e2:	d9 1e       	adc	r13, r25
    41e4:	ea 1e       	adc	r14, r26
    41e6:	fb 1e       	adc	r15, r27
}
    41e8:	6c 2d       	mov	r22, r12
    41ea:	7d 2d       	mov	r23, r13
    41ec:	8e 2d       	mov	r24, r14
    41ee:	9f 2d       	mov	r25, r15
    41f0:	ff 90       	pop	r15
    41f2:	ef 90       	pop	r14
    41f4:	df 90       	pop	r13
    41f6:	cf 90       	pop	r12
    41f8:	08 95       	ret

000041fa <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    41fa:	3f 92       	push	r3
    41fc:	4f 92       	push	r4
    41fe:	5f 92       	push	r5
    4200:	6f 92       	push	r6
    4202:	7f 92       	push	r7
    4204:	8f 92       	push	r8
    4206:	9f 92       	push	r9
    4208:	af 92       	push	r10
    420a:	bf 92       	push	r11
    420c:	cf 92       	push	r12
    420e:	df 92       	push	r13
    4210:	ef 92       	push	r14
    4212:	ff 92       	push	r15
    4214:	0f 93       	push	r16
    4216:	1f 93       	push	r17
    4218:	cf 93       	push	r28
    421a:	df 93       	push	r29
    421c:	00 d0       	rcall	.+0      	; 0x421e <getSetNextCluster+0x24>
    421e:	0f 92       	push	r0
    4220:	cd b7       	in	r28, 0x3d	; 61
    4222:	de b7       	in	r29, 0x3e	; 62
    4224:	dc 01       	movw	r26, r24
    4226:	cb 01       	movw	r24, r22
    4228:	34 2e       	mov	r3, r20
    422a:	09 83       	std	Y+1, r16	; 0x01
    422c:	1a 83       	std	Y+2, r17	; 0x02
    422e:	2b 83       	std	Y+3, r18	; 0x03
    4230:	3c 83       	std	Y+4, r19	; 0x04
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    4232:	80 90 74 50 	lds	r8, 0x5074
    4236:	90 90 75 50 	lds	r9, 0x5075
    423a:	2c 01       	movw	r4, r24
    423c:	3d 01       	movw	r6, r26
    423e:	44 0c       	add	r4, r4
    4240:	55 1c       	adc	r5, r5
    4242:	66 1c       	adc	r6, r6
    4244:	77 1c       	adc	r7, r7
    4246:	44 0c       	add	r4, r4
    4248:	55 1c       	adc	r5, r5
    424a:	66 1c       	adc	r6, r6
    424c:	77 1c       	adc	r7, r7
    424e:	20 91 5a 40 	lds	r18, 0x405A
    4252:	30 91 5b 40 	lds	r19, 0x405B
    4256:	aa 24       	eor	r10, r10
    4258:	bb 24       	eor	r11, r11
    425a:	80 91 70 50 	lds	r24, 0x5070
    425e:	90 91 71 50 	lds	r25, 0x5071
    4262:	a0 91 72 50 	lds	r26, 0x5072
    4266:	b0 91 73 50 	lds	r27, 0x5073
    426a:	88 0e       	add	r8, r24
    426c:	99 1e       	adc	r9, r25
    426e:	aa 1e       	adc	r10, r26
    4270:	bb 1e       	adc	r11, r27
    4272:	40 e0       	ldi	r20, 0x00	; 0
    4274:	50 e0       	ldi	r21, 0x00	; 0
    4276:	c3 01       	movw	r24, r6
    4278:	b2 01       	movw	r22, r4
    427a:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    427e:	69 01       	movw	r12, r18
    4280:	7a 01       	movw	r14, r20
    4282:	c8 0c       	add	r12, r8
    4284:	d9 1c       	adc	r13, r9
    4286:	ea 1c       	adc	r14, r10
    4288:	fb 1c       	adc	r15, r11

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    428a:	00 91 5a 40 	lds	r16, 0x405A
    428e:	10 91 5b 40 	lds	r17, 0x405B

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    4292:	c7 01       	movw	r24, r14
    4294:	b6 01       	movw	r22, r12
    4296:	4d e4       	ldi	r20, 0x4D	; 77
    4298:	5e e3       	ldi	r21, 0x3E	; 62
    429a:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <SD_read_block>

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    429e:	98 01       	movw	r18, r16
    42a0:	40 e0       	ldi	r20, 0x00	; 0
    42a2:	50 e0       	ldi	r21, 0x00	; 0
    42a4:	c3 01       	movw	r24, r6
    42a6:	b2 01       	movw	r22, r4
    42a8:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    42ac:	63 5b       	subi	r22, 0xB3	; 179
    42ae:	71 4c       	sbci	r23, 0xC1	; 193

if(get_set == GET)
    42b0:	33 20       	and	r3, r3
    42b2:	41 f4       	brne	.+16     	; 0x42c4 <getSetNextCluster+0xca>
  return ((*FATEntryValue) & 0x0fffffff);
    42b4:	db 01       	movw	r26, r22
    42b6:	0d 91       	ld	r16, X+
    42b8:	1d 91       	ld	r17, X+
    42ba:	2d 91       	ld	r18, X+
    42bc:	3c 91       	ld	r19, X
    42be:	13 97       	sbiw	r26, 0x03	; 3
    42c0:	3f 70       	andi	r19, 0x0F	; 15
    42c2:	14 c0       	rjmp	.+40     	; 0x42ec <getSetNextCluster+0xf2>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    42c4:	89 81       	ldd	r24, Y+1	; 0x01
    42c6:	9a 81       	ldd	r25, Y+2	; 0x02
    42c8:	ab 81       	ldd	r26, Y+3	; 0x03
    42ca:	bc 81       	ldd	r27, Y+4	; 0x04
    42cc:	fb 01       	movw	r30, r22
    42ce:	80 83       	st	Z, r24
    42d0:	91 83       	std	Z+1, r25	; 0x01
    42d2:	a2 83       	std	Z+2, r26	; 0x02
    42d4:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    42d6:	c7 01       	movw	r24, r14
    42d8:	b6 01       	movw	r22, r12
    42da:	4d e4       	ldi	r20, 0x4D	; 77
    42dc:	5e e3       	ldi	r21, 0x3E	; 62
    42de:	20 e0       	ldi	r18, 0x00	; 0
    42e0:	32 e0       	ldi	r19, 0x02	; 2
    42e2:	0e 94 27 2b 	call	0x564e	; 0x564e <SD_write_block>

return (0);
    42e6:	00 e0       	ldi	r16, 0x00	; 0
    42e8:	10 e0       	ldi	r17, 0x00	; 0
    42ea:	98 01       	movw	r18, r16
}
    42ec:	60 2f       	mov	r22, r16
    42ee:	71 2f       	mov	r23, r17
    42f0:	82 2f       	mov	r24, r18
    42f2:	93 2f       	mov	r25, r19
    42f4:	24 96       	adiw	r28, 0x04	; 4
    42f6:	cd bf       	out	0x3d, r28	; 61
    42f8:	de bf       	out	0x3e, r29	; 62
    42fa:	df 91       	pop	r29
    42fc:	cf 91       	pop	r28
    42fe:	1f 91       	pop	r17
    4300:	0f 91       	pop	r16
    4302:	ff 90       	pop	r15
    4304:	ef 90       	pop	r14
    4306:	df 90       	pop	r13
    4308:	cf 90       	pop	r12
    430a:	bf 90       	pop	r11
    430c:	af 90       	pop	r10
    430e:	9f 90       	pop	r9
    4310:	8f 90       	pop	r8
    4312:	7f 90       	pop	r7
    4314:	6f 90       	pop	r6
    4316:	5f 90       	pop	r5
    4318:	4f 90       	pop	r4
    431a:	3f 90       	pop	r3
    431c:	08 95       	ret

0000431e <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    431e:	cf 92       	push	r12
    4320:	df 92       	push	r13
    4322:	ef 92       	push	r14
    4324:	ff 92       	push	r15
    4326:	0f 93       	push	r16
    4328:	1f 93       	push	r17
    432a:	cf 93       	push	r28
    432c:	c8 2f       	mov	r28, r24
    432e:	06 2f       	mov	r16, r22
    4330:	69 01       	movw	r12, r18
    4332:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    4334:	80 91 70 50 	lds	r24, 0x5070
    4338:	90 91 71 50 	lds	r25, 0x5071
    433c:	a0 91 72 50 	lds	r26, 0x5072
    4340:	b0 91 73 50 	lds	r27, 0x5073
    4344:	bc 01       	movw	r22, r24
    4346:	cd 01       	movw	r24, r26
    4348:	6f 5f       	subi	r22, 0xFF	; 255
    434a:	7f 4f       	sbci	r23, 0xFF	; 255
    434c:	8f 4f       	sbci	r24, 0xFF	; 255
    434e:	9f 4f       	sbci	r25, 0xFF	; 255
    4350:	4d e4       	ldi	r20, 0x4D	; 77
    4352:	5e e3       	ldi	r21, 0x3E	; 62
    4354:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    4358:	80 91 4d 3e 	lds	r24, 0x3E4D
    435c:	90 91 4e 3e 	lds	r25, 0x3E4E
    4360:	a0 91 4f 3e 	lds	r26, 0x3E4F
    4364:	b0 91 50 3e 	lds	r27, 0x3E50
    4368:	82 35       	cpi	r24, 0x52	; 82
    436a:	22 e5       	ldi	r18, 0x52	; 82
    436c:	92 07       	cpc	r25, r18
    436e:	21 e6       	ldi	r18, 0x61	; 97
    4370:	a2 07       	cpc	r26, r18
    4372:	21 e4       	ldi	r18, 0x41	; 65
    4374:	b2 07       	cpc	r27, r18
    4376:	09 f0       	breq	.+2      	; 0x437a <getSetFreeCluster+0x5c>
    4378:	63 c0       	rjmp	.+198    	; 0x4440 <getSetFreeCluster+0x122>
    437a:	80 91 31 40 	lds	r24, 0x4031
    437e:	90 91 32 40 	lds	r25, 0x4032
    4382:	a0 91 33 40 	lds	r26, 0x4033
    4386:	b0 91 34 40 	lds	r27, 0x4034
    438a:	82 37       	cpi	r24, 0x72	; 114
    438c:	22 e7       	ldi	r18, 0x72	; 114
    438e:	92 07       	cpc	r25, r18
    4390:	21 e4       	ldi	r18, 0x41	; 65
    4392:	a2 07       	cpc	r26, r18
    4394:	21 e6       	ldi	r18, 0x61	; 97
    4396:	b2 07       	cpc	r27, r18
    4398:	09 f0       	breq	.+2      	; 0x439c <getSetFreeCluster+0x7e>
    439a:	56 c0       	rjmp	.+172    	; 0x4448 <getSetFreeCluster+0x12a>
    439c:	80 91 49 40 	lds	r24, 0x4049
    43a0:	90 91 4a 40 	lds	r25, 0x404A
    43a4:	a0 91 4b 40 	lds	r26, 0x404B
    43a8:	b0 91 4c 40 	lds	r27, 0x404C
    43ac:	80 30       	cpi	r24, 0x00	; 0
    43ae:	20 e0       	ldi	r18, 0x00	; 0
    43b0:	92 07       	cpc	r25, r18
    43b2:	25 e5       	ldi	r18, 0x55	; 85
    43b4:	a2 07       	cpc	r26, r18
    43b6:	2a ea       	ldi	r18, 0xAA	; 170
    43b8:	b2 07       	cpc	r27, r18
    43ba:	09 f0       	breq	.+2      	; 0x43be <getSetFreeCluster+0xa0>
    43bc:	49 c0       	rjmp	.+146    	; 0x4450 <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    43be:	00 23       	and	r16, r16
    43c0:	a1 f4       	brne	.+40     	; 0x43ea <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    43c2:	c1 30       	cpi	r28, 0x01	; 1
    43c4:	49 f4       	brne	.+18     	; 0x43d8 <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    43c6:	00 91 35 40 	lds	r16, 0x4035
    43ca:	10 91 36 40 	lds	r17, 0x4036
    43ce:	20 91 37 40 	lds	r18, 0x4037
    43d2:	30 91 38 40 	lds	r19, 0x4038
    43d6:	3f c0       	rjmp	.+126    	; 0x4456 <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    43d8:	00 91 39 40 	lds	r16, 0x4039
    43dc:	10 91 3a 40 	lds	r17, 0x403A
    43e0:	20 91 3b 40 	lds	r18, 0x403B
    43e4:	30 91 3c 40 	lds	r19, 0x403C
    43e8:	36 c0       	rjmp	.+108    	; 0x4456 <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    43ea:	c1 30       	cpi	r28, 0x01	; 1
    43ec:	49 f4       	brne	.+18     	; 0x4400 <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    43ee:	c0 92 35 40 	sts	0x4035, r12
    43f2:	d0 92 36 40 	sts	0x4036, r13
    43f6:	e0 92 37 40 	sts	0x4037, r14
    43fa:	f0 92 38 40 	sts	0x4038, r15
    43fe:	08 c0       	rjmp	.+16     	; 0x4410 <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    4400:	c0 92 39 40 	sts	0x4039, r12
    4404:	d0 92 3a 40 	sts	0x403A, r13
    4408:	e0 92 3b 40 	sts	0x403B, r14
    440c:	f0 92 3c 40 	sts	0x403C, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    4410:	80 91 70 50 	lds	r24, 0x5070
    4414:	90 91 71 50 	lds	r25, 0x5071
    4418:	a0 91 72 50 	lds	r26, 0x5072
    441c:	b0 91 73 50 	lds	r27, 0x5073
    4420:	bc 01       	movw	r22, r24
    4422:	cd 01       	movw	r24, r26
    4424:	6f 5f       	subi	r22, 0xFF	; 255
    4426:	7f 4f       	sbci	r23, 0xFF	; 255
    4428:	8f 4f       	sbci	r24, 0xFF	; 255
    442a:	9f 4f       	sbci	r25, 0xFF	; 255
    442c:	4d e4       	ldi	r20, 0x4D	; 77
    442e:	5e e3       	ldi	r21, 0x3E	; 62
    4430:	20 e0       	ldi	r18, 0x00	; 0
    4432:	32 e0       	ldi	r19, 0x02	; 2
    4434:	0e 94 27 2b 	call	0x564e	; 0x564e <SD_write_block>
 }
 return 0xffffffff;
    4438:	0f ef       	ldi	r16, 0xFF	; 255
    443a:	1f ef       	ldi	r17, 0xFF	; 255
    443c:	98 01       	movw	r18, r16
    443e:	0b c0       	rjmp	.+22     	; 0x4456 <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    4440:	0f ef       	ldi	r16, 0xFF	; 255
    4442:	1f ef       	ldi	r17, 0xFF	; 255
    4444:	98 01       	movw	r18, r16
    4446:	07 c0       	rjmp	.+14     	; 0x4456 <getSetFreeCluster+0x138>
    4448:	0f ef       	ldi	r16, 0xFF	; 255
    444a:	1f ef       	ldi	r17, 0xFF	; 255
    444c:	98 01       	movw	r18, r16
    444e:	03 c0       	rjmp	.+6      	; 0x4456 <getSetFreeCluster+0x138>
    4450:	0f ef       	ldi	r16, 0xFF	; 255
    4452:	1f ef       	ldi	r17, 0xFF	; 255
    4454:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    4456:	60 2f       	mov	r22, r16
    4458:	71 2f       	mov	r23, r17
    445a:	82 2f       	mov	r24, r18
    445c:	93 2f       	mov	r25, r19
    445e:	cf 91       	pop	r28
    4460:	1f 91       	pop	r17
    4462:	0f 91       	pop	r16
    4464:	ff 90       	pop	r15
    4466:	ef 90       	pop	r14
    4468:	df 90       	pop	r13
    446a:	cf 90       	pop	r12
    446c:	08 95       	ret

0000446e <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    446e:	ef 92       	push	r14
    4470:	ff 92       	push	r15
    4472:	0f 93       	push	r16
    4474:	1f 93       	push	r17
    4476:	cf 93       	push	r28
    4478:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    447a:	10 92 70 50 	sts	0x5070, r1
    447e:	10 92 71 50 	sts	0x5071, r1
    4482:	10 92 72 50 	sts	0x5072, r1
    4486:	10 92 73 50 	sts	0x5073, r1

SD_read_block(0,SDBuffer);
    448a:	60 e0       	ldi	r22, 0x00	; 0
    448c:	70 e0       	ldi	r23, 0x00	; 0
    448e:	cb 01       	movw	r24, r22
    4490:	4d e4       	ldi	r20, 0x4D	; 77
    4492:	5e e3       	ldi	r21, 0x3E	; 62
    4494:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    4498:	80 91 4d 3e 	lds	r24, 0x3E4D
    449c:	89 3e       	cpi	r24, 0xE9	; 233
    449e:	31 f1       	breq	.+76     	; 0x44ec <getBootSectorData+0x7e>
    44a0:	8b 3e       	cpi	r24, 0xEB	; 235
    44a2:	21 f1       	breq	.+72     	; 0x44ec <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    44a4:	80 91 4b 40 	lds	r24, 0x404B
    44a8:	90 91 4c 40 	lds	r25, 0x404C
    44ac:	2a ea       	ldi	r18, 0xAA	; 170
    44ae:	85 35       	cpi	r24, 0x55	; 85
    44b0:	92 07       	cpc	r25, r18
    44b2:	09 f0       	breq	.+2      	; 0x44b6 <getBootSectorData+0x48>
    44b4:	b7 c0       	rjmp	.+366    	; 0x4624 <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    44b6:	60 91 13 40 	lds	r22, 0x4013
    44ba:	70 91 14 40 	lds	r23, 0x4014
    44be:	80 91 15 40 	lds	r24, 0x4015
    44c2:	90 91 16 40 	lds	r25, 0x4016
    44c6:	60 93 70 50 	sts	0x5070, r22
    44ca:	70 93 71 50 	sts	0x5071, r23
    44ce:	80 93 72 50 	sts	0x5072, r24
    44d2:	90 93 73 50 	sts	0x5073, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    44d6:	4d e4       	ldi	r20, 0x4D	; 77
    44d8:	5e e3       	ldi	r21, 0x3E	; 62
    44da:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    44de:	80 91 4d 3e 	lds	r24, 0x3E4D
    44e2:	89 3e       	cpi	r24, 0xE9	; 233
    44e4:	19 f0       	breq	.+6      	; 0x44ec <getBootSectorData+0x7e>
    44e6:	8b 3e       	cpi	r24, 0xEB	; 235
    44e8:	09 f0       	breq	.+2      	; 0x44ec <getBootSectorData+0x7e>
    44ea:	9e c0       	rjmp	.+316    	; 0x4628 <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    44ec:	80 91 58 3e 	lds	r24, 0x3E58
    44f0:	90 91 59 3e 	lds	r25, 0x3E59
    44f4:	80 93 5a 40 	sts	0x405A, r24
    44f8:	90 93 5b 40 	sts	0x405B, r25
sectorPerCluster = bpb->sectorPerCluster;
    44fc:	80 91 5a 3e 	lds	r24, 0x3E5A
    4500:	90 e0       	ldi	r25, 0x00	; 0
    4502:	80 93 6e 50 	sts	0x506E, r24
    4506:	90 93 6f 50 	sts	0x506F, r25
reservedSectorCount = bpb->reservedSectorCount;
    450a:	e0 90 5b 3e 	lds	r14, 0x3E5B
    450e:	f0 90 5c 3e 	lds	r15, 0x3E5C
    4512:	e0 92 74 50 	sts	0x5074, r14
    4516:	f0 92 75 50 	sts	0x5075, r15
rootCluster = bpb->rootCluster;
    451a:	80 91 79 3e 	lds	r24, 0x3E79
    451e:	90 91 7a 3e 	lds	r25, 0x3E7A
    4522:	a0 91 7b 3e 	lds	r26, 0x3E7B
    4526:	b0 91 7c 3e 	lds	r27, 0x3E7C
    452a:	80 93 62 40 	sts	0x4062, r24
    452e:	90 93 63 40 	sts	0x4063, r25
    4532:	a0 93 64 40 	sts	0x4064, r26
    4536:	b0 93 65 40 	sts	0x4065, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    453a:	c0 91 74 50 	lds	r28, 0x5074
    453e:	d0 91 75 50 	lds	r29, 0x5075
    4542:	60 91 5d 3e 	lds	r22, 0x3E5D
    4546:	70 e0       	ldi	r23, 0x00	; 0
    4548:	80 e0       	ldi	r24, 0x00	; 0
    454a:	90 e0       	ldi	r25, 0x00	; 0
    454c:	20 91 71 3e 	lds	r18, 0x3E71
    4550:	30 91 72 3e 	lds	r19, 0x3E72
    4554:	40 91 73 3e 	lds	r20, 0x3E73
    4558:	50 91 74 3e 	lds	r21, 0x3E74
    455c:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    4560:	8b 01       	movw	r16, r22
    4562:	9c 01       	movw	r18, r24
    4564:	ae 01       	movw	r20, r28
    4566:	60 e0       	ldi	r22, 0x00	; 0
    4568:	70 e0       	ldi	r23, 0x00	; 0
    456a:	80 91 69 3e 	lds	r24, 0x3E69
    456e:	90 91 6a 3e 	lds	r25, 0x3E6A
    4572:	a0 91 6b 3e 	lds	r26, 0x3E6B
    4576:	b0 91 6c 3e 	lds	r27, 0x3E6C
    457a:	84 0f       	add	r24, r20
    457c:	95 1f       	adc	r25, r21
    457e:	a6 1f       	adc	r26, r22
    4580:	b7 1f       	adc	r27, r23
    4582:	80 0f       	add	r24, r16
    4584:	91 1f       	adc	r25, r17
    4586:	a2 1f       	adc	r26, r18
    4588:	b3 1f       	adc	r27, r19
    458a:	80 93 52 40 	sts	0x4052, r24
    458e:	90 93 53 40 	sts	0x4053, r25
    4592:	a0 93 54 40 	sts	0x4054, r26
    4596:	b0 93 55 40 	sts	0x4055, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    459a:	e0 91 6e 50 	lds	r30, 0x506E
    459e:	f0 91 6f 50 	lds	r31, 0x506F
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    45a2:	c7 01       	movw	r24, r14
    45a4:	a0 e0       	ldi	r26, 0x00	; 0
    45a6:	b0 e0       	ldi	r27, 0x00	; 0
    45a8:	40 91 6d 3e 	lds	r20, 0x3E6D
    45ac:	50 91 6e 3e 	lds	r21, 0x3E6E
    45b0:	60 91 6f 3e 	lds	r22, 0x3E6F
    45b4:	70 91 70 3e 	lds	r23, 0x3E70
    45b8:	48 1b       	sub	r20, r24
    45ba:	59 0b       	sbc	r21, r25
    45bc:	6a 0b       	sbc	r22, r26
    45be:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    45c0:	cb 01       	movw	r24, r22
    45c2:	ba 01       	movw	r22, r20
    45c4:	60 1b       	sub	r22, r16
    45c6:	71 0b       	sbc	r23, r17
    45c8:	82 0b       	sbc	r24, r18
    45ca:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    45cc:	9f 01       	movw	r18, r30
    45ce:	40 e0       	ldi	r20, 0x00	; 0
    45d0:	50 e0       	ldi	r21, 0x00	; 0
    45d2:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    45d6:	20 93 5d 40 	sts	0x405D, r18
    45da:	30 93 5e 40 	sts	0x405E, r19
    45de:	40 93 5f 40 	sts	0x405F, r20
    45e2:	50 93 60 40 	sts	0x4060, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    45e6:	81 e0       	ldi	r24, 0x01	; 1
    45e8:	60 e0       	ldi	r22, 0x00	; 0
    45ea:	20 e0       	ldi	r18, 0x00	; 0
    45ec:	30 e0       	ldi	r19, 0x00	; 0
    45ee:	a9 01       	movw	r20, r18
    45f0:	0e 94 8f 21 	call	0x431e	; 0x431e <getSetFreeCluster>
    45f4:	ab 01       	movw	r20, r22
    45f6:	bc 01       	movw	r22, r24
    45f8:	80 91 5d 40 	lds	r24, 0x405D
    45fc:	90 91 5e 40 	lds	r25, 0x405E
    4600:	a0 91 5f 40 	lds	r26, 0x405F
    4604:	b0 91 60 40 	lds	r27, 0x4060
    4608:	84 17       	cp	r24, r20
    460a:	95 07       	cpc	r25, r21
    460c:	a6 07       	cpc	r26, r22
    460e:	b7 07       	cpc	r27, r23
    4610:	20 f4       	brcc	.+8      	; 0x461a <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    4612:	10 92 a6 50 	sts	0x50A6, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    4616:	80 e0       	ldi	r24, 0x00	; 0
    4618:	08 c0       	rjmp	.+16     	; 0x462a <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    461a:	81 e0       	ldi	r24, 0x01	; 1
    461c:	80 93 a6 50 	sts	0x50A6, r24
return 0;
    4620:	80 e0       	ldi	r24, 0x00	; 0
    4622:	03 c0       	rjmp	.+6      	; 0x462a <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4624:	81 e0       	ldi	r24, 0x01	; 1
    4626:	01 c0       	rjmp	.+2      	; 0x462a <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4628:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    462a:	df 91       	pop	r29
    462c:	cf 91       	pop	r28
    462e:	1f 91       	pop	r17
    4630:	0f 91       	pop	r16
    4632:	ff 90       	pop	r15
    4634:	ef 90       	pop	r14
    4636:	08 95       	ret

00004638 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    4638:	0f 93       	push	r16
    463a:	1f 93       	push	r17
    463c:	cf 93       	push	r28
    463e:	df 93       	push	r29
    4640:	cd b7       	in	r28, 0x3d	; 61
    4642:	de b7       	in	r29, 0x3e	; 62
    4644:	2b 97       	sbiw	r28, 0x0b	; 11
    4646:	cd bf       	out	0x3d, r28	; 61
    4648:	de bf       	out	0x3e, r29	; 62
    464a:	78 2f       	mov	r23, r24
    464c:	69 2f       	mov	r22, r25
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    464e:	e8 2f       	mov	r30, r24
    4650:	f9 2f       	mov	r31, r25
    4652:	df 01       	movw	r26, r30
    4654:	0d 90       	ld	r0, X+
    4656:	00 20       	and	r0, r0
    4658:	e9 f7       	brne	.-6      	; 0x4654 <convertFileName+0x1c>
    465a:	11 97       	sbiw	r26, 0x01	; 1
    465c:	ae 1b       	sub	r26, r30
    465e:	bf 0b       	sbc	r27, r31
    4660:	a0 31       	cpi	r26, 0x10	; 16
    4662:	b1 05       	cpc	r27, r1
    4664:	08 f0       	brcs	.+2      	; 0x4668 <convertFileName+0x30>
    4666:	9c c0       	rjmp	.+312    	; 0x47a0 <convertFileName+0x168>
    4668:	28 2f       	mov	r18, r24
    466a:	39 2f       	mov	r19, r25
    466c:	06 e9       	ldi	r16, 0x96	; 150
    466e:	10 e5       	ldi	r17, 0x50	; 80
    4670:	a8 01       	movw	r20, r16
    4672:	80 e0       	ldi	r24, 0x00	; 0
    4674:	90 e0       	ldi	r25, 0x00	; 0
    4676:	07 c0       	rjmp	.+14     	; 0x4686 <convertFileName+0x4e>
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
    4678:	d9 01       	movw	r26, r18
    467a:	ed 91       	ld	r30, X+
    467c:	9d 01       	movw	r18, r26
    467e:	da 01       	movw	r26, r20
    4680:	ed 93       	st	X+, r30
    4682:	ad 01       	movw	r20, r26

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    4684:	01 96       	adiw	r24, 0x01	; 1
    4686:	a7 2f       	mov	r26, r23
    4688:	b6 2f       	mov	r27, r22
    468a:	fd 01       	movw	r30, r26
    468c:	01 90       	ld	r0, Z+
    468e:	00 20       	and	r0, r0
    4690:	e9 f7       	brne	.-6      	; 0x468c <convertFileName+0x54>
    4692:	31 97       	sbiw	r30, 0x01	; 1
    4694:	ea 1b       	sub	r30, r26
    4696:	fb 0b       	sbc	r31, r27
    4698:	8e 17       	cp	r24, r30
    469a:	9f 07       	cpc	r25, r31
    469c:	68 f3       	brcs	.-38     	; 0x4678 <convertFileName+0x40>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    469e:	8f 30       	cpi	r24, 0x0F	; 15
    46a0:	91 05       	cpc	r25, r1
    46a2:	54 f4       	brge	.+20     	; 0x46b8 <convertFileName+0x80>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    46a4:	fc 01       	movw	r30, r24
    46a6:	ea 56       	subi	r30, 0x6A	; 106
    46a8:	ff 4a       	sbci	r31, 0xAF	; 175
    46aa:	85 ea       	ldi	r24, 0xA5	; 165
    46ac:	90 e5       	ldi	r25, 0x50	; 80
if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    46ae:	20 e2       	ldi	r18, 0x20	; 32
    46b0:	21 93       	st	Z+, r18
    46b2:	e8 17       	cp	r30, r24
    46b4:	f9 07       	cpc	r31, r25
    46b6:	e1 f7       	brne	.-8      	; 0x46b0 <convertFileName+0x78>


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    46b8:	80 91 96 50 	lds	r24, 0x5096
    46bc:	8e 32       	cpi	r24, 0x2E	; 46
    46be:	91 f0       	breq	.+36     	; 0x46e4 <convertFileName+0xac>
    46c0:	e7 e9       	ldi	r30, 0x97	; 151
    46c2:	f0 e5       	ldi	r31, 0x50	; 80
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    46c4:	21 e0       	ldi	r18, 0x01	; 1
if(Filename[j] == '.') break;
    46c6:	81 91       	ld	r24, Z+
    46c8:	8e 32       	cpi	r24, 0x2E	; 46
    46ca:	21 f0       	breq	.+8      	; 0x46d4 <convertFileName+0x9c>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    46cc:	2f 5f       	subi	r18, 0xFF	; 255
    46ce:	2c 30       	cpi	r18, 0x0C	; 12
    46d0:	d1 f7       	brne	.-12     	; 0x46c6 <convertFileName+0x8e>
    46d2:	05 c0       	rjmp	.+10     	; 0x46de <convertFileName+0xa6>
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    46d4:	82 2f       	mov	r24, r18
    46d6:	89 50       	subi	r24, 0x09	; 9
    46d8:	83 30       	cpi	r24, 0x03	; 3
    46da:	08 f4       	brcc	.+2      	; 0x46de <convertFileName+0xa6>
    46dc:	63 c0       	rjmp	.+198    	; 0x47a4 <convertFileName+0x16c>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    46de:	22 23       	and	r18, r18
    46e0:	29 f4       	brne	.+10     	; 0x46ec <convertFileName+0xb4>
    46e2:	01 c0       	rjmp	.+2      	; 0x46e6 <convertFileName+0xae>
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    46e4:	20 e0       	ldi	r18, 0x00	; 0
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    46e6:	82 2f       	mov	r24, r18

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    46e8:	90 e2       	ldi	r25, 0x20	; 32
    46ea:	10 c0       	rjmp	.+32     	; 0x470c <convertFileName+0xd4>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    46ec:	de 01       	movw	r26, r28
    46ee:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    46f0:	82 2f       	mov	r24, r18
    46f2:	81 50       	subi	r24, 0x01	; 1
    46f4:	90 e0       	ldi	r25, 0x00	; 0
    46f6:	89 56       	subi	r24, 0x69	; 105
    46f8:	9f 4a       	sbci	r25, 0xAF	; 175
    46fa:	f8 01       	movw	r30, r16
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];
    46fc:	31 91       	ld	r19, Z+
    46fe:	3d 93       	st	X+, r19

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4700:	e8 17       	cp	r30, r24
    4702:	f9 07       	cpc	r31, r25
    4704:	d9 f7       	brne	.-10     	; 0x46fc <convertFileName+0xc4>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4706:	28 30       	cpi	r18, 0x08	; 8
    4708:	70 f3       	brcs	.-36     	; 0x46e6 <convertFileName+0xae>
    470a:	0a c0       	rjmp	.+20     	; 0x4720 <convertFileName+0xe8>
  fileNameFAT[k] = ' ';
    470c:	e1 e0       	ldi	r30, 0x01	; 1
    470e:	f0 e0       	ldi	r31, 0x00	; 0
    4710:	ec 0f       	add	r30, r28
    4712:	fd 1f       	adc	r31, r29
    4714:	e8 0f       	add	r30, r24
    4716:	f1 1d       	adc	r31, r1
    4718:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    471a:	8f 5f       	subi	r24, 0xFF	; 255
    471c:	88 30       	cpi	r24, 0x08	; 8
    471e:	b0 f3       	brcs	.-20     	; 0x470c <convertFileName+0xd4>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    4720:	2c 30       	cpi	r18, 0x0C	; 12
    4722:	09 f0       	breq	.+2      	; 0x4726 <convertFileName+0xee>
    4724:	2f 5f       	subi	r18, 0xFF	; 255
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4726:	38 e0       	ldi	r19, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    4728:	86 e9       	ldi	r24, 0x96	; 150
    472a:	90 e5       	ldi	r25, 0x50	; 80
    472c:	fc 01       	movw	r30, r24
    472e:	e2 0f       	add	r30, r18
    4730:	f1 1d       	adc	r31, r1
    4732:	40 81       	ld	r20, Z
    4734:	44 23       	and	r20, r20
    4736:	19 f4       	brne	.+6      	; 0x473e <convertFileName+0x106>
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    4738:	3b 30       	cpi	r19, 0x0B	; 11
    473a:	50 f0       	brcs	.+20     	; 0x4750 <convertFileName+0x118>
    473c:	15 c0       	rjmp	.+42     	; 0x4768 <convertFileName+0x130>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
    473e:	e1 e0       	ldi	r30, 0x01	; 1
    4740:	f0 e0       	ldi	r31, 0x00	; 0
    4742:	ec 0f       	add	r30, r28
    4744:	fd 1f       	adc	r31, r29
    4746:	e3 0f       	add	r30, r19
    4748:	f1 1d       	adc	r31, r1
    474a:	40 83       	st	Z, r20
    474c:	2f 5f       	subi	r18, 0xFF	; 255
    474e:	0c c0       	rjmp	.+24     	; 0x4768 <convertFileName+0x130>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    4750:	80 e2       	ldi	r24, 0x20	; 32
    4752:	e1 e0       	ldi	r30, 0x01	; 1
    4754:	f0 e0       	ldi	r31, 0x00	; 0
    4756:	ec 0f       	add	r30, r28
    4758:	fd 1f       	adc	r31, r29
    475a:	e3 0f       	add	r30, r19
    475c:	f1 1d       	adc	r31, r1
    475e:	80 83       	st	Z, r24
    4760:	3f 5f       	subi	r19, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    4762:	3b 30       	cpi	r19, 0x0B	; 11
    4764:	b1 f7       	brne	.-20     	; 0x4752 <convertFileName+0x11a>
    4766:	03 c0       	rjmp	.+6      	; 0x476e <convertFileName+0x136>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    4768:	3f 5f       	subi	r19, 0xFF	; 255
    476a:	3b 30       	cpi	r19, 0x0B	; 11
    476c:	f8 f2       	brcs	.-66     	; 0x472c <convertFileName+0xf4>
    476e:	de 01       	movw	r26, r28
    4770:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4772:	ce 01       	movw	r24, r28
    4774:	0c 96       	adiw	r24, 0x0c	; 12
    4776:	fd 01       	movw	r30, r26
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    4778:	20 81       	ld	r18, Z
    477a:	32 2f       	mov	r19, r18
    477c:	31 56       	subi	r19, 0x61	; 97
    477e:	3a 31       	cpi	r19, 0x1A	; 26
    4780:	10 f4       	brcc	.+4      	; 0x4786 <convertFileName+0x14e>
    fileNameFAT[j] -= 0x20;
    4782:	20 52       	subi	r18, 0x20	; 32
    4784:	20 83       	st	Z, r18
    4786:	31 96       	adiw	r30, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    4788:	e8 17       	cp	r30, r24
    478a:	f9 07       	cpc	r31, r25
    478c:	a9 f7       	brne	.-22     	; 0x4778 <convertFileName+0x140>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];
    478e:	2d 91       	ld	r18, X+
    4790:	f8 01       	movw	r30, r16
    4792:	21 93       	st	Z+, r18
    4794:	8f 01       	movw	r16, r30

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    4796:	a8 17       	cp	r26, r24
    4798:	b9 07       	cpc	r27, r25
    479a:	c9 f7       	brne	.-14     	; 0x478e <convertFileName+0x156>
  Filename[j] = fileNameFAT[j];

return 0;
    479c:	80 e0       	ldi	r24, 0x00	; 0
    479e:	03 c0       	rjmp	.+6      	; 0x47a6 <convertFileName+0x16e>
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    47a0:	81 e0       	ldi	r24, 0x01	; 1
    47a2:	01 c0       	rjmp	.+2      	; 0x47a6 <convertFileName+0x16e>

for(j=0; j<12; j++)
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    47a4:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];

return 0;
}
    47a6:	2b 96       	adiw	r28, 0x0b	; 11
    47a8:	cd bf       	out	0x3d, r28	; 61
    47aa:	de bf       	out	0x3e, r29	; 62
    47ac:	df 91       	pop	r29
    47ae:	cf 91       	pop	r28
    47b0:	1f 91       	pop	r17
    47b2:	0f 91       	pop	r16
    47b4:	08 95       	ret

000047b6 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    47b6:	4f 92       	push	r4
    47b8:	5f 92       	push	r5
    47ba:	6f 92       	push	r6
    47bc:	7f 92       	push	r7
    47be:	8f 92       	push	r8
    47c0:	9f 92       	push	r9
    47c2:	af 92       	push	r10
    47c4:	bf 92       	push	r11
    47c6:	cf 92       	push	r12
    47c8:	df 92       	push	r13
    47ca:	ef 92       	push	r14
    47cc:	ff 92       	push	r15
    47ce:	cf 93       	push	r28
    47d0:	df 93       	push	r29
    47d2:	2b 01       	movw	r4, r22
    47d4:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    47d6:	20 e8       	ldi	r18, 0x80	; 128
    47d8:	3f ef       	ldi	r19, 0xFF	; 255
    47da:	4f ef       	ldi	r20, 0xFF	; 255
    47dc:	5f ef       	ldi	r21, 0xFF	; 255
    47de:	42 22       	and	r4, r18
    47e0:	53 22       	and	r5, r19
    47e2:	64 22       	and	r6, r20
    47e4:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    47e6:	80 91 5d 40 	lds	r24, 0x405D
    47ea:	90 91 5e 40 	lds	r25, 0x405E
    47ee:	a0 91 5f 40 	lds	r26, 0x405F
    47f2:	b0 91 60 40 	lds	r27, 0x4060
    47f6:	48 16       	cp	r4, r24
    47f8:	59 06       	cpc	r5, r25
    47fa:	6a 06       	cpc	r6, r26
    47fc:	7b 06       	cpc	r7, r27
    47fe:	08 f0       	brcs	.+2      	; 0x4802 <searchNextFreeCluster+0x4c>
    4800:	77 c0       	rjmp	.+238    	; 0x48f0 <searchNextFreeCluster+0x13a>
    4802:	53 01       	movw	r10, r6
    4804:	42 01       	movw	r8, r4
    4806:	88 0c       	add	r8, r8
    4808:	99 1c       	adc	r9, r9
    480a:	aa 1c       	adc	r10, r10
    480c:	bb 1c       	adc	r11, r11
    480e:	88 0c       	add	r8, r8
    4810:	99 1c       	adc	r9, r9
    4812:	aa 1c       	adc	r10, r10
    4814:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    4816:	cd e4       	ldi	r28, 0x4D	; 77
    4818:	de e3       	ldi	r29, 0x3E	; 62
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    481a:	c0 90 74 50 	lds	r12, 0x5074
    481e:	d0 90 75 50 	lds	r13, 0x5075
    4822:	20 91 5a 40 	lds	r18, 0x405A
    4826:	30 91 5b 40 	lds	r19, 0x405B
    482a:	ee 24       	eor	r14, r14
    482c:	ff 24       	eor	r15, r15
    482e:	80 91 70 50 	lds	r24, 0x5070
    4832:	90 91 71 50 	lds	r25, 0x5071
    4836:	a0 91 72 50 	lds	r26, 0x5072
    483a:	b0 91 73 50 	lds	r27, 0x5073
    483e:	c8 0e       	add	r12, r24
    4840:	d9 1e       	adc	r13, r25
    4842:	ea 1e       	adc	r14, r26
    4844:	fb 1e       	adc	r15, r27
    4846:	40 e0       	ldi	r20, 0x00	; 0
    4848:	50 e0       	ldi	r21, 0x00	; 0
    484a:	c5 01       	movw	r24, r10
    484c:	b4 01       	movw	r22, r8
    484e:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    4852:	c7 01       	movw	r24, r14
    4854:	b6 01       	movw	r22, r12
    4856:	62 0f       	add	r22, r18
    4858:	73 1f       	adc	r23, r19
    485a:	84 1f       	adc	r24, r20
    485c:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    485e:	ae 01       	movw	r20, r28
    4860:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    4864:	88 81       	ld	r24, Y
    4866:	99 81       	ldd	r25, Y+1	; 0x01
    4868:	aa 81       	ldd	r26, Y+2	; 0x02
    486a:	bb 81       	ldd	r27, Y+3	; 0x03
    486c:	bf 70       	andi	r27, 0x0F	; 15
    486e:	00 97       	sbiw	r24, 0x00	; 0
    4870:	a1 05       	cpc	r26, r1
    4872:	b1 05       	cpc	r27, r1
    4874:	99 f0       	breq	.+38     	; 0x489c <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4876:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    4878:	e2 2f       	mov	r30, r18
    487a:	f0 e0       	ldi	r31, 0x00	; 0
    487c:	ee 0f       	add	r30, r30
    487e:	ff 1f       	adc	r31, r31
    4880:	ee 0f       	add	r30, r30
    4882:	ff 1f       	adc	r31, r31
         if(((*value) & 0x0fffffff) == 0)
    4884:	e3 5b       	subi	r30, 0xB3	; 179
    4886:	f1 4c       	sbci	r31, 0xC1	; 193
    4888:	80 81       	ld	r24, Z
    488a:	91 81       	ldd	r25, Z+1	; 0x01
    488c:	a2 81       	ldd	r26, Z+2	; 0x02
    488e:	b3 81       	ldd	r27, Z+3	; 0x03
    4890:	bf 70       	andi	r27, 0x0F	; 15
    4892:	00 97       	sbiw	r24, 0x00	; 0
    4894:	a1 05       	cpc	r26, r1
    4896:	b1 05       	cpc	r27, r1
    4898:	39 f4       	brne	.+14     	; 0x48a8 <searchNextFreeCluster+0xf2>
    489a:	01 c0       	rjmp	.+2      	; 0x489e <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    489c:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    489e:	42 0e       	add	r4, r18
    48a0:	51 1c       	adc	r5, r1
    48a2:	61 1c       	adc	r6, r1
    48a4:	71 1c       	adc	r7, r1
    48a6:	27 c0       	rjmp	.+78     	; 0x48f6 <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    48a8:	2f 5f       	subi	r18, 0xFF	; 255
    48aa:	32 f7       	brpl	.-52     	; 0x4878 <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    48ac:	80 e8       	ldi	r24, 0x80	; 128
    48ae:	90 e0       	ldi	r25, 0x00	; 0
    48b0:	a0 e0       	ldi	r26, 0x00	; 0
    48b2:	b0 e0       	ldi	r27, 0x00	; 0
    48b4:	48 0e       	add	r4, r24
    48b6:	59 1e       	adc	r5, r25
    48b8:	6a 1e       	adc	r6, r26
    48ba:	7b 1e       	adc	r7, r27
    48bc:	80 91 5d 40 	lds	r24, 0x405D
    48c0:	90 91 5e 40 	lds	r25, 0x405E
    48c4:	a0 91 5f 40 	lds	r26, 0x405F
    48c8:	b0 91 60 40 	lds	r27, 0x4060
    48cc:	20 e0       	ldi	r18, 0x00	; 0
    48ce:	32 e0       	ldi	r19, 0x02	; 2
    48d0:	40 e0       	ldi	r20, 0x00	; 0
    48d2:	50 e0       	ldi	r21, 0x00	; 0
    48d4:	82 0e       	add	r8, r18
    48d6:	93 1e       	adc	r9, r19
    48d8:	a4 1e       	adc	r10, r20
    48da:	b5 1e       	adc	r11, r21
    48dc:	48 16       	cp	r4, r24
    48de:	59 06       	cpc	r5, r25
    48e0:	6a 06       	cpc	r6, r26
    48e2:	7b 06       	cpc	r7, r27
    48e4:	08 f4       	brcc	.+2      	; 0x48e8 <searchNextFreeCluster+0x132>
    48e6:	99 cf       	rjmp	.-206    	; 0x481a <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    48e8:	44 24       	eor	r4, r4
    48ea:	55 24       	eor	r5, r5
    48ec:	32 01       	movw	r6, r4
    48ee:	03 c0       	rjmp	.+6      	; 0x48f6 <searchNextFreeCluster+0x140>
    48f0:	44 24       	eor	r4, r4
    48f2:	55 24       	eor	r5, r5
    48f4:	32 01       	movw	r6, r4
}
    48f6:	64 2d       	mov	r22, r4
    48f8:	75 2d       	mov	r23, r5
    48fa:	86 2d       	mov	r24, r6
    48fc:	97 2d       	mov	r25, r7
    48fe:	df 91       	pop	r29
    4900:	cf 91       	pop	r28
    4902:	ff 90       	pop	r15
    4904:	ef 90       	pop	r14
    4906:	df 90       	pop	r13
    4908:	cf 90       	pop	r12
    490a:	bf 90       	pop	r11
    490c:	af 90       	pop	r10
    490e:	9f 90       	pop	r9
    4910:	8f 90       	pop	r8
    4912:	7f 90       	pop	r7
    4914:	6f 90       	pop	r6
    4916:	5f 90       	pop	r5
    4918:	4f 90       	pop	r4
    491a:	08 95       	ret

0000491c <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    491c:	cf 92       	push	r12
    491e:	df 92       	push	r13
    4920:	ef 92       	push	r14
    4922:	ff 92       	push	r15
    4924:	cf 93       	push	r28
    4926:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    4928:	db 01       	movw	r26, r22
    492a:	ca 01       	movw	r24, r20
    492c:	91 70       	andi	r25, 0x01	; 1
    492e:	a0 70       	andi	r26, 0x00	; 0
    4930:	b0 70       	andi	r27, 0x00	; 0
    4932:	00 97       	sbiw	r24, 0x00	; 0
    4934:	a1 05       	cpc	r26, r1
    4936:	b1 05       	cpc	r27, r1
    4938:	51 f4       	brne	.+20     	; 0x494e <freeMemoryUpdate+0x32>
    493a:	03 2e       	mov	r0, r19
    493c:	39 e0       	ldi	r19, 0x09	; 9
    493e:	76 95       	lsr	r23
    4940:	67 95       	ror	r22
    4942:	57 95       	ror	r21
    4944:	47 95       	ror	r20
    4946:	3a 95       	dec	r19
    4948:	d1 f7       	brne	.-12     	; 0x493e <freeMemoryUpdate+0x22>
    494a:	30 2d       	mov	r19, r0
    494c:	0d c0       	rjmp	.+26     	; 0x4968 <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    494e:	03 2e       	mov	r0, r19
    4950:	39 e0       	ldi	r19, 0x09	; 9
    4952:	76 95       	lsr	r23
    4954:	67 95       	ror	r22
    4956:	57 95       	ror	r21
    4958:	47 95       	ror	r20
    495a:	3a 95       	dec	r19
    495c:	d1 f7       	brne	.-12     	; 0x4952 <freeMemoryUpdate+0x36>
    495e:	30 2d       	mov	r19, r0
    4960:	4f 5f       	subi	r20, 0xFF	; 255
    4962:	5f 4f       	sbci	r21, 0xFF	; 255
    4964:	6f 4f       	sbci	r22, 0xFF	; 255
    4966:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    4968:	db 01       	movw	r26, r22
    496a:	ca 01       	movw	r24, r20
    496c:	87 70       	andi	r24, 0x07	; 7
    496e:	90 70       	andi	r25, 0x00	; 0
    4970:	a0 70       	andi	r26, 0x00	; 0
    4972:	b0 70       	andi	r27, 0x00	; 0
    4974:	00 97       	sbiw	r24, 0x00	; 0
    4976:	a1 05       	cpc	r26, r1
    4978:	b1 05       	cpc	r27, r1
    497a:	59 f4       	brne	.+22     	; 0x4992 <freeMemoryUpdate+0x76>
    497c:	6a 01       	movw	r12, r20
    497e:	7b 01       	movw	r14, r22
    4980:	68 94       	set
    4982:	12 f8       	bld	r1, 2
    4984:	f6 94       	lsr	r15
    4986:	e7 94       	ror	r14
    4988:	d7 94       	ror	r13
    498a:	c7 94       	ror	r12
    498c:	16 94       	lsr	r1
    498e:	d1 f7       	brne	.-12     	; 0x4984 <freeMemoryUpdate+0x68>
    4990:	0f c0       	rjmp	.+30     	; 0x49b0 <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    4992:	6a 01       	movw	r12, r20
    4994:	7b 01       	movw	r14, r22
    4996:	68 94       	set
    4998:	12 f8       	bld	r1, 2
    499a:	f6 94       	lsr	r15
    499c:	e7 94       	ror	r14
    499e:	d7 94       	ror	r13
    49a0:	c7 94       	ror	r12
    49a2:	16 94       	lsr	r1
    49a4:	d1 f7       	brne	.-12     	; 0x499a <freeMemoryUpdate+0x7e>
    49a6:	08 94       	sec
    49a8:	c1 1c       	adc	r12, r1
    49aa:	d1 1c       	adc	r13, r1
    49ac:	e1 1c       	adc	r14, r1
    49ae:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    49b0:	80 91 a6 50 	lds	r24, 0x50A6
    49b4:	88 23       	and	r24, r24
    49b6:	d1 f0       	breq	.+52     	; 0x49ec <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    49b8:	81 e0       	ldi	r24, 0x01	; 1
    49ba:	60 e0       	ldi	r22, 0x00	; 0
    49bc:	20 e0       	ldi	r18, 0x00	; 0
    49be:	30 e0       	ldi	r19, 0x00	; 0
    49c0:	a9 01       	movw	r20, r18
    49c2:	0e 94 8f 21 	call	0x431e	; 0x431e <getSetFreeCluster>
	if(flag == ADD)
    49c6:	cc 23       	and	r28, r28
    49c8:	39 f4       	brne	.+14     	; 0x49d8 <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    49ca:	9b 01       	movw	r18, r22
    49cc:	ac 01       	movw	r20, r24
    49ce:	2c 0d       	add	r18, r12
    49d0:	3d 1d       	adc	r19, r13
    49d2:	4e 1d       	adc	r20, r14
    49d4:	5f 1d       	adc	r21, r15
    49d6:	06 c0       	rjmp	.+12     	; 0x49e4 <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    49d8:	9b 01       	movw	r18, r22
    49da:	ac 01       	movw	r20, r24
    49dc:	2c 19       	sub	r18, r12
    49de:	3d 09       	sbc	r19, r13
    49e0:	4e 09       	sbc	r20, r14
    49e2:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    49e4:	81 e0       	ldi	r24, 0x01	; 1
    49e6:	61 e0       	ldi	r22, 0x01	; 1
    49e8:	0e 94 8f 21 	call	0x431e	; 0x431e <getSetFreeCluster>
  }
}
    49ec:	cf 91       	pop	r28
    49ee:	ff 90       	pop	r15
    49f0:	ef 90       	pop	r14
    49f2:	df 90       	pop	r13
    49f4:	cf 90       	pop	r12
    49f6:	08 95       	ret

000049f8 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    49f8:	2f 92       	push	r2
    49fa:	3f 92       	push	r3
    49fc:	4f 92       	push	r4
    49fe:	5f 92       	push	r5
    4a00:	6f 92       	push	r6
    4a02:	7f 92       	push	r7
    4a04:	8f 92       	push	r8
    4a06:	9f 92       	push	r9
    4a08:	af 92       	push	r10
    4a0a:	bf 92       	push	r11
    4a0c:	cf 92       	push	r12
    4a0e:	df 92       	push	r13
    4a10:	ef 92       	push	r14
    4a12:	ff 92       	push	r15
    4a14:	0f 93       	push	r16
    4a16:	1f 93       	push	r17
    4a18:	cf 93       	push	r28
    4a1a:	df 93       	push	r29
    4a1c:	cd b7       	in	r28, 0x3d	; 61
    4a1e:	de b7       	in	r29, 0x3e	; 62
    4a20:	2c 97       	sbiw	r28, 0x0c	; 12
    4a22:	cd bf       	out	0x3d, r28	; 61
    4a24:	de bf       	out	0x3e, r29	; 62
    4a26:	88 2e       	mov	r8, r24
    4a28:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    4a2a:	80 91 62 40 	lds	r24, 0x4062
    4a2e:	90 91 63 40 	lds	r25, 0x4063
    4a32:	a0 91 64 40 	lds	r26, 0x4064
    4a36:	b0 91 65 40 	lds	r27, 0x4065
    4a3a:	89 87       	std	Y+9, r24	; 0x09
    4a3c:	9a 87       	std	Y+10, r25	; 0x0a
    4a3e:	ab 87       	std	Y+11, r26	; 0x0b
    4a40:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4a42:	0f 2e       	mov	r0, r31
    4a44:	fd e4       	ldi	r31, 0x4D	; 77
    4a46:	2f 2e       	mov	r2, r31
    4a48:	fe e3       	ldi	r31, 0x3E	; 62
    4a4a:	3f 2e       	mov	r3, r31
    4a4c:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4a4e:	c8 2c       	mov	r12, r8
    4a50:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4a52:	d2 2c       	mov	r13, r2
    4a54:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4a56:	5b 01       	movw	r10, r22
    4a58:	08 94       	sec
    4a5a:	a1 1c       	adc	r10, r1
    4a5c:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    4a5e:	69 85       	ldd	r22, Y+9	; 0x09
    4a60:	7a 85       	ldd	r23, Y+10	; 0x0a
    4a62:	8b 85       	ldd	r24, Y+11	; 0x0b
    4a64:	9c 85       	ldd	r25, Y+12	; 0x0c
    4a66:	0e 94 d6 20 	call	0x41ac	; 0x41ac <getFirstSector>
    4a6a:	6d 83       	std	Y+5, r22	; 0x05
    4a6c:	7e 83       	std	Y+6, r23	; 0x06
    4a6e:	8f 83       	std	Y+7, r24	; 0x07
    4a70:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    4a72:	80 91 6e 50 	lds	r24, 0x506E
    4a76:	90 91 6f 50 	lds	r25, 0x506F
    4a7a:	00 97       	sbiw	r24, 0x00	; 0
    4a7c:	09 f4       	brne	.+2      	; 0x4a80 <findFiles+0x88>
    4a7e:	13 c1       	rjmp	.+550    	; 0x4ca6 <findFiles+0x2ae>
    4a80:	44 24       	eor	r4, r4
    4a82:	55 24       	eor	r5, r5
    4a84:	32 01       	movw	r6, r4
    4a86:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4a88:	8d 81       	ldd	r24, Y+5	; 0x05
    4a8a:	9e 81       	ldd	r25, Y+6	; 0x06
    4a8c:	af 81       	ldd	r26, Y+7	; 0x07
    4a8e:	b8 85       	ldd	r27, Y+8	; 0x08
    4a90:	84 0d       	add	r24, r4
    4a92:	95 1d       	adc	r25, r5
    4a94:	a6 1d       	adc	r26, r6
    4a96:	b7 1d       	adc	r27, r7
    4a98:	89 83       	std	Y+1, r24	; 0x01
    4a9a:	9a 83       	std	Y+2, r25	; 0x02
    4a9c:	ab 83       	std	Y+3, r26	; 0x03
    4a9e:	bc 83       	std	Y+4, r27	; 0x04
    4aa0:	bc 01       	movw	r22, r24
    4aa2:	cd 01       	movw	r24, r26
    4aa4:	4d 2d       	mov	r20, r13
    4aa6:	59 2d       	mov	r21, r9
    4aa8:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    4aac:	80 91 5a 40 	lds	r24, 0x405A
    4ab0:	90 91 5b 40 	lds	r25, 0x405B
    4ab4:	00 97       	sbiw	r24, 0x00	; 0
    4ab6:	09 f4       	brne	.+2      	; 0x4aba <findFiles+0xc2>
    4ab8:	e4 c0       	rjmp	.+456    	; 0x4c82 <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4aba:	d1 01       	movw	r26, r2
    4abc:	8c 91       	ld	r24, X
    4abe:	88 23       	and	r24, r24
    4ac0:	09 f4       	brne	.+2      	; 0x4ac4 <findFiles+0xcc>
    4ac2:	10 c1       	rjmp	.+544    	; 0x4ce4 <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4ac4:	4d 2d       	mov	r20, r13
    4ac6:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4ac8:	20 e0       	ldi	r18, 0x00	; 0
    4aca:	30 e0       	ldi	r19, 0x00	; 0
    4acc:	08 c0       	rjmp	.+16     	; 0x4ade <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4ace:	a9 01       	movw	r20, r18
    4ad0:	43 5b       	subi	r20, 0xB3	; 179
    4ad2:	51 4c       	sbci	r21, 0xC1	; 193

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4ad4:	fa 01       	movw	r30, r20
    4ad6:	80 81       	ld	r24, Z
    4ad8:	88 23       	and	r24, r24
    4ada:	09 f4       	brne	.+2      	; 0x4ade <findFiles+0xe6>
    4adc:	06 c1       	rjmp	.+524    	; 0x4cea <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    4ade:	85 3e       	cpi	r24, 0xE5	; 229
    4ae0:	09 f4       	brne	.+2      	; 0x4ae4 <findFiles+0xec>
    4ae2:	c5 c0       	rjmp	.+394    	; 0x4c6e <findFiles+0x276>
    4ae4:	da 01       	movw	r26, r20
    4ae6:	1b 96       	adiw	r26, 0x0b	; 11
    4ae8:	8c 91       	ld	r24, X
    4aea:	1b 97       	sbiw	r26, 0x0b	; 11
    4aec:	8f 30       	cpi	r24, 0x0F	; 15
    4aee:	09 f4       	brne	.+2      	; 0x4af2 <findFiles+0xfa>
    4af0:	be c0       	rjmp	.+380    	; 0x4c6e <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4af2:	12 30       	cpi	r17, 0x02	; 2
    4af4:	08 f0       	brcs	.+2      	; 0x4af8 <findFiles+0x100>
    4af6:	fc c0       	rjmp	.+504    	; 0x4cf0 <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    4af8:	9c 91       	ld	r25, X
    4afa:	f7 01       	movw	r30, r14
    4afc:	80 81       	ld	r24, Z
    4afe:	98 17       	cp	r25, r24
    4b00:	09 f0       	breq	.+2      	; 0x4b04 <findFiles+0x10c>
    4b02:	b5 c0       	rjmp	.+362    	; 0x4c6e <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4b04:	fa 01       	movw	r30, r20
    4b06:	31 96       	adiw	r30, 0x01	; 1
    4b08:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4b0a:	81 e0       	ldi	r24, 0x01	; 1
    4b0c:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    4b0e:	41 91       	ld	r20, Z+
    4b10:	9d 91       	ld	r25, X+
    4b12:	49 17       	cp	r20, r25
    4b14:	31 f4       	brne	.+12     	; 0x4b22 <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4b16:	8f 5f       	subi	r24, 0xFF	; 255
    4b18:	8b 30       	cpi	r24, 0x0B	; 11
    4b1a:	c9 f7       	brne	.-14     	; 0x4b0e <findFiles+0x116>
    4b1c:	8b 01       	movw	r16, r22
    4b1e:	6b 01       	movw	r12, r22
    4b20:	05 c0       	rjmp	.+10     	; 0x4b2c <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    4b22:	8b 30       	cpi	r24, 0x0B	; 11
    4b24:	09 f0       	breq	.+2      	; 0x4b28 <findFiles+0x130>
    4b26:	a3 c0       	rjmp	.+326    	; 0x4c6e <findFiles+0x276>
    4b28:	8b 01       	movw	r16, r22
    4b2a:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    4b2c:	f1 e0       	ldi	r31, 0x01	; 1
    4b2e:	8f 16       	cp	r8, r31
    4b30:	09 f0       	breq	.+2      	; 0x4b34 <findFiles+0x13c>
    4b32:	41 c0       	rjmp	.+130    	; 0x4bb6 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    4b34:	89 81       	ldd	r24, Y+1	; 0x01
    4b36:	9a 81       	ldd	r25, Y+2	; 0x02
    4b38:	ab 81       	ldd	r26, Y+3	; 0x03
    4b3a:	bc 81       	ldd	r27, Y+4	; 0x04
    4b3c:	80 93 a7 50 	sts	0x50A7, r24
    4b40:	90 93 a8 50 	sts	0x50A8, r25
    4b44:	a0 93 a9 50 	sts	0x50A9, r26
    4b48:	b0 93 aa 50 	sts	0x50AA, r27
				appendFileLocation = i;
    4b4c:	c9 01       	movw	r24, r18
    4b4e:	a0 e0       	ldi	r26, 0x00	; 0
    4b50:	b0 e0       	ldi	r27, 0x00	; 0
    4b52:	80 93 4e 40 	sts	0x404E, r24
    4b56:	90 93 4f 40 	sts	0x404F, r25
    4b5a:	a0 93 50 40 	sts	0x4050, r26
    4b5e:	b0 93 51 40 	sts	0x4051, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4b62:	d6 01       	movw	r26, r12
    4b64:	54 96       	adiw	r26, 0x14	; 20
    4b66:	4d 91       	ld	r20, X+
    4b68:	5c 91       	ld	r21, X
    4b6a:	55 97       	sbiw	r26, 0x15	; 21
    4b6c:	60 e0       	ldi	r22, 0x00	; 0
    4b6e:	70 e0       	ldi	r23, 0x00	; 0
    4b70:	ba 01       	movw	r22, r20
    4b72:	55 27       	eor	r21, r21
    4b74:	44 27       	eor	r20, r20
    4b76:	5a 96       	adiw	r26, 0x1a	; 26
    4b78:	8d 91       	ld	r24, X+
    4b7a:	9c 91       	ld	r25, X
    4b7c:	5b 97       	sbiw	r26, 0x1b	; 27
    4b7e:	a0 e0       	ldi	r26, 0x00	; 0
    4b80:	b0 e0       	ldi	r27, 0x00	; 0
    4b82:	84 2b       	or	r24, r20
    4b84:	95 2b       	or	r25, r21
    4b86:	a6 2b       	or	r26, r22
    4b88:	b7 2b       	or	r27, r23
    4b8a:	80 93 78 50 	sts	0x5078, r24
    4b8e:	90 93 79 50 	sts	0x5079, r25
    4b92:	a0 93 7a 50 	sts	0x507A, r26
    4b96:	b0 93 7b 50 	sts	0x507B, r27
				fileSize = dir->fileSize;
    4b9a:	f6 01       	movw	r30, r12
    4b9c:	84 8d       	ldd	r24, Z+28	; 0x1c
    4b9e:	95 8d       	ldd	r25, Z+29	; 0x1d
    4ba0:	a6 8d       	ldd	r26, Z+30	; 0x1e
    4ba2:	b7 8d       	ldd	r27, Z+31	; 0x1f
    4ba4:	80 93 56 40 	sts	0x4056, r24
    4ba8:	90 93 57 40 	sts	0x4057, r25
    4bac:	a0 93 58 40 	sts	0x4058, r26
    4bb0:	b0 93 59 40 	sts	0x4059, r27
			    return (dir);
    4bb4:	a5 c0       	rjmp	.+330    	; 0x4d00 <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4bb6:	d6 01       	movw	r26, r12
    4bb8:	54 96       	adiw	r26, 0x14	; 20
    4bba:	8d 91       	ld	r24, X+
    4bbc:	9c 91       	ld	r25, X
    4bbe:	55 97       	sbiw	r26, 0x15	; 21
    4bc0:	a0 e0       	ldi	r26, 0x00	; 0
    4bc2:	b0 e0       	ldi	r27, 0x00	; 0
    4bc4:	3c 01       	movw	r6, r24
    4bc6:	55 24       	eor	r5, r5
    4bc8:	44 24       	eor	r4, r4
    4bca:	f6 01       	movw	r30, r12
    4bcc:	82 8d       	ldd	r24, Z+26	; 0x1a
    4bce:	93 8d       	ldd	r25, Z+27	; 0x1b
    4bd0:	a0 e0       	ldi	r26, 0x00	; 0
    4bd2:	b0 e0       	ldi	r27, 0x00	; 0
    4bd4:	48 2a       	or	r4, r24
    4bd6:	59 2a       	or	r5, r25
    4bd8:	6a 2a       	or	r6, r26
    4bda:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    4bdc:	85 ee       	ldi	r24, 0xE5	; 229
    4bde:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    4be0:	69 81       	ldd	r22, Y+1	; 0x01
    4be2:	7a 81       	ldd	r23, Y+2	; 0x02
    4be4:	8b 81       	ldd	r24, Y+3	; 0x03
    4be6:	9c 81       	ldd	r25, Y+4	; 0x04
    4be8:	4d e4       	ldi	r20, 0x4D	; 77
    4bea:	5e e3       	ldi	r21, 0x3E	; 62
    4bec:	20 e0       	ldi	r18, 0x00	; 0
    4bee:	32 e0       	ldi	r19, 0x02	; 2
    4bf0:	0e 94 27 2b 	call	0x564e	; 0x564e <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    4bf4:	d6 01       	movw	r26, r12
    4bf6:	5c 96       	adiw	r26, 0x1c	; 28
    4bf8:	4d 91       	ld	r20, X+
    4bfa:	5d 91       	ld	r21, X+
    4bfc:	6d 91       	ld	r22, X+
    4bfe:	7c 91       	ld	r23, X
    4c00:	5f 97       	sbiw	r26, 0x1f	; 31
    4c02:	80 e0       	ldi	r24, 0x00	; 0
    4c04:	0e 94 8e 24 	call	0x491c	; 0x491c <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    4c08:	82 e0       	ldi	r24, 0x02	; 2
    4c0a:	60 e0       	ldi	r22, 0x00	; 0
    4c0c:	20 e0       	ldi	r18, 0x00	; 0
    4c0e:	30 e0       	ldi	r19, 0x00	; 0
    4c10:	a9 01       	movw	r20, r18
    4c12:	0e 94 8f 21 	call	0x431e	; 0x431e <getSetFreeCluster>
    4c16:	dc 01       	movw	r26, r24
    4c18:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    4c1a:	48 16       	cp	r4, r24
    4c1c:	59 06       	cpc	r5, r25
    4c1e:	6a 06       	cpc	r6, r26
    4c20:	7b 06       	cpc	r7, r27
    4c22:	30 f4       	brcc	.+12     	; 0x4c30 <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    4c24:	82 e0       	ldi	r24, 0x02	; 2
    4c26:	61 e0       	ldi	r22, 0x01	; 1
    4c28:	a3 01       	movw	r20, r6
    4c2a:	92 01       	movw	r18, r4
    4c2c:	0e 94 8f 21 	call	0x431e	; 0x431e <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    4c30:	c3 01       	movw	r24, r6
    4c32:	b2 01       	movw	r22, r4
    4c34:	40 e0       	ldi	r20, 0x00	; 0
    4c36:	00 e0       	ldi	r16, 0x00	; 0
    4c38:	10 e0       	ldi	r17, 0x00	; 0
    4c3a:	98 01       	movw	r18, r16
    4c3c:	0e 94 fd 20 	call	0x41fa	; 0x41fa <getSetNextCluster>
    4c40:	6b 01       	movw	r12, r22
    4c42:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    4c44:	c3 01       	movw	r24, r6
    4c46:	b2 01       	movw	r22, r4
    4c48:	41 e0       	ldi	r20, 0x01	; 1
    4c4a:	00 e0       	ldi	r16, 0x00	; 0
    4c4c:	10 e0       	ldi	r17, 0x00	; 0
    4c4e:	98 01       	movw	r18, r16
    4c50:	0e 94 fd 20 	call	0x41fa	; 0x41fa <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    4c54:	b7 ef       	ldi	r27, 0xF7	; 247
    4c56:	cb 16       	cp	r12, r27
    4c58:	bf ef       	ldi	r27, 0xFF	; 255
    4c5a:	db 06       	cpc	r13, r27
    4c5c:	bf ef       	ldi	r27, 0xFF	; 255
    4c5e:	eb 06       	cpc	r14, r27
    4c60:	bf e0       	ldi	r27, 0x0F	; 15
    4c62:	fb 06       	cpc	r15, r27
    4c64:	08 f0       	brcs	.+2      	; 0x4c68 <findFiles+0x270>
    4c66:	47 c0       	rjmp	.+142    	; 0x4cf6 <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    4c68:	26 01       	movw	r4, r12
    4c6a:	37 01       	movw	r6, r14
    4c6c:	e1 cf       	rjmp	.-62     	; 0x4c30 <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4c6e:	20 5e       	subi	r18, 0xE0	; 224
    4c70:	3f 4f       	sbci	r19, 0xFF	; 255
    4c72:	80 91 5a 40 	lds	r24, 0x405A
    4c76:	90 91 5b 40 	lds	r25, 0x405B
    4c7a:	28 17       	cp	r18, r24
    4c7c:	39 07       	cpc	r19, r25
    4c7e:	08 f4       	brcc	.+2      	; 0x4c82 <findFiles+0x28a>
    4c80:	26 cf       	rjmp	.-436    	; 0x4ace <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    4c82:	08 94       	sec
    4c84:	41 1c       	adc	r4, r1
    4c86:	51 1c       	adc	r5, r1
    4c88:	61 1c       	adc	r6, r1
    4c8a:	71 1c       	adc	r7, r1
    4c8c:	80 91 6e 50 	lds	r24, 0x506E
    4c90:	90 91 6f 50 	lds	r25, 0x506F
    4c94:	a0 e0       	ldi	r26, 0x00	; 0
    4c96:	b0 e0       	ldi	r27, 0x00	; 0
    4c98:	48 16       	cp	r4, r24
    4c9a:	59 06       	cpc	r5, r25
    4c9c:	6a 06       	cpc	r6, r26
    4c9e:	7b 06       	cpc	r7, r27
    4ca0:	08 f4       	brcc	.+2      	; 0x4ca4 <findFiles+0x2ac>
    4ca2:	f2 ce       	rjmp	.-540    	; 0x4a88 <findFiles+0x90>
    4ca4:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    4ca6:	69 85       	ldd	r22, Y+9	; 0x09
    4ca8:	7a 85       	ldd	r23, Y+10	; 0x0a
    4caa:	8b 85       	ldd	r24, Y+11	; 0x0b
    4cac:	9c 85       	ldd	r25, Y+12	; 0x0c
    4cae:	40 e0       	ldi	r20, 0x00	; 0
    4cb0:	00 e0       	ldi	r16, 0x00	; 0
    4cb2:	10 e0       	ldi	r17, 0x00	; 0
    4cb4:	98 01       	movw	r18, r16
    4cb6:	0e 94 fd 20 	call	0x41fa	; 0x41fa <getSetNextCluster>
    4cba:	69 87       	std	Y+9, r22	; 0x09
    4cbc:	7a 87       	std	Y+10, r23	; 0x0a
    4cbe:	8b 87       	std	Y+11, r24	; 0x0b
    4cc0:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    4cc2:	67 3f       	cpi	r22, 0xF7	; 247
    4cc4:	ef ef       	ldi	r30, 0xFF	; 255
    4cc6:	7e 07       	cpc	r23, r30
    4cc8:	ef ef       	ldi	r30, 0xFF	; 255
    4cca:	8e 07       	cpc	r24, r30
    4ccc:	ef e0       	ldi	r30, 0x0F	; 15
    4cce:	9e 07       	cpc	r25, r30
    4cd0:	a8 f4       	brcc	.+42     	; 0x4cfc <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    4cd2:	61 15       	cp	r22, r1
    4cd4:	71 05       	cpc	r23, r1
    4cd6:	81 05       	cpc	r24, r1
    4cd8:	91 05       	cpc	r25, r1
    4cda:	09 f0       	breq	.+2      	; 0x4cde <findFiles+0x2e6>
    4cdc:	c0 ce       	rjmp	.-640    	; 0x4a5e <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    4cde:	00 e0       	ldi	r16, 0x00	; 0
    4ce0:	10 e0       	ldi	r17, 0x00	; 0
    4ce2:	0e c0       	rjmp	.+28     	; 0x4d00 <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    4ce4:	00 e0       	ldi	r16, 0x00	; 0
    4ce6:	10 e0       	ldi	r17, 0x00	; 0
    4ce8:	0b c0       	rjmp	.+22     	; 0x4d00 <findFiles+0x308>
    4cea:	00 e0       	ldi	r16, 0x00	; 0
    4cec:	10 e0       	ldi	r17, 0x00	; 0
    4cee:	08 c0       	rjmp	.+16     	; 0x4d00 <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    4cf0:	00 e0       	ldi	r16, 0x00	; 0
    4cf2:	10 e0       	ldi	r17, 0x00	; 0
    4cf4:	05 c0       	rjmp	.+10     	; 0x4d00 <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    4cf6:	00 e0       	ldi	r16, 0x00	; 0
    4cf8:	10 e0       	ldi	r17, 0x00	; 0
    4cfa:	02 c0       	rjmp	.+4      	; 0x4d00 <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    4cfc:	00 e0       	ldi	r16, 0x00	; 0
    4cfe:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    4d00:	80 2f       	mov	r24, r16
    4d02:	91 2f       	mov	r25, r17
    4d04:	2c 96       	adiw	r28, 0x0c	; 12
    4d06:	cd bf       	out	0x3d, r28	; 61
    4d08:	de bf       	out	0x3e, r29	; 62
    4d0a:	df 91       	pop	r29
    4d0c:	cf 91       	pop	r28
    4d0e:	1f 91       	pop	r17
    4d10:	0f 91       	pop	r16
    4d12:	ff 90       	pop	r15
    4d14:	ef 90       	pop	r14
    4d16:	df 90       	pop	r13
    4d18:	cf 90       	pop	r12
    4d1a:	bf 90       	pop	r11
    4d1c:	af 90       	pop	r10
    4d1e:	9f 90       	pop	r9
    4d20:	8f 90       	pop	r8
    4d22:	7f 90       	pop	r7
    4d24:	6f 90       	pop	r6
    4d26:	5f 90       	pop	r5
    4d28:	4f 90       	pop	r4
    4d2a:	3f 90       	pop	r3
    4d2c:	2f 90       	pop	r2
    4d2e:	08 95       	ret

00004d30 <deleteFile>:
//********************************************************************
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
    4d30:	0e 94 1c 23 	call	0x4638	; 0x4638 <convertFileName>
  if(error) return;
    4d34:	88 23       	and	r24, r24
    4d36:	29 f4       	brne	.+10     	; 0x4d42 <deleteFile+0x12>

  findFiles (DELETE, Filename);
    4d38:	82 e0       	ldi	r24, 0x02	; 2
    4d3a:	66 e9       	ldi	r22, 0x96	; 150
    4d3c:	70 e5       	ldi	r23, 0x50	; 80
    4d3e:	0e 94 fc 24 	call	0x49f8	; 0x49f8 <findFiles>
    4d42:	08 95       	ret

00004d44 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    4d44:	4f 92       	push	r4
    4d46:	5f 92       	push	r5
    4d48:	6f 92       	push	r6
    4d4a:	7f 92       	push	r7
    4d4c:	af 92       	push	r10
    4d4e:	bf 92       	push	r11
    4d50:	cf 92       	push	r12
    4d52:	df 92       	push	r13
    4d54:	ef 92       	push	r14
    4d56:	ff 92       	push	r15
    4d58:	0f 93       	push	r16
    4d5a:	1f 93       	push	r17
    4d5c:	cf 93       	push	r28
    4d5e:	c8 2f       	mov	r28, r24
    4d60:	cb 01       	movw	r24, r22
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    4d62:	0e 94 1c 23 	call	0x4638	; 0x4638 <convertFileName>
if(error) return 2;
    4d66:	88 23       	and	r24, r24
    4d68:	09 f0       	breq	.+2      	; 0x4d6c <readFile+0x28>
    4d6a:	57 c0       	rjmp	.+174    	; 0x4e1a <readFile+0xd6>

dir = findFiles (GET_FILE, Filename); //get the file location
    4d6c:	81 e0       	ldi	r24, 0x01	; 1
    4d6e:	66 e9       	ldi	r22, 0x96	; 150
    4d70:	70 e5       	ldi	r23, 0x50	; 80
    4d72:	0e 94 fc 24 	call	0x49f8	; 0x49f8 <findFiles>
    4d76:	fc 01       	movw	r30, r24
if(dir == 0) 
    4d78:	00 97       	sbiw	r24, 0x00	; 0
    4d7a:	31 f4       	brne	.+12     	; 0x4d88 <readFile+0x44>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4d7c:	81 e0       	ldi	r24, 0x01	; 1
    4d7e:	cc 23       	and	r28, r28
    4d80:	09 f4       	brne	.+2      	; 0x4d84 <readFile+0x40>
    4d82:	4e c0       	rjmp	.+156    	; 0x4e20 <readFile+0xdc>
    4d84:	80 e0       	ldi	r24, 0x00	; 0
    4d86:	4c c0       	rjmp	.+152    	; 0x4e20 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4d88:	c1 30       	cpi	r28, 0x01	; 1
    4d8a:	09 f4       	brne	.+2      	; 0x4d8e <readFile+0x4a>
    4d8c:	48 c0       	rjmp	.+144    	; 0x4e1e <readFile+0xda>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4d8e:	44 88       	ldd	r4, Z+20	; 0x14
    4d90:	55 88       	ldd	r5, Z+21	; 0x15
    4d92:	66 24       	eor	r6, r6
    4d94:	77 24       	eor	r7, r7
    4d96:	32 01       	movw	r6, r4
    4d98:	55 24       	eor	r5, r5
    4d9a:	44 24       	eor	r4, r4
    4d9c:	82 8d       	ldd	r24, Z+26	; 0x1a
    4d9e:	93 8d       	ldd	r25, Z+27	; 0x1b
    4da0:	a0 e0       	ldi	r26, 0x00	; 0
    4da2:	b0 e0       	ldi	r27, 0x00	; 0
    4da4:	48 2a       	or	r4, r24
    4da6:	59 2a       	or	r5, r25
    4da8:	6a 2a       	or	r6, r26
    4daa:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4dac:	0f 2e       	mov	r0, r31
    4dae:	f1 eb       	ldi	r31, 0xB1	; 177
    4db0:	af 2e       	mov	r10, r31
    4db2:	f1 e2       	ldi	r31, 0x21	; 33
    4db4:	bf 2e       	mov	r11, r31
    4db6:	f0 2d       	mov	r31, r0
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    4db8:	c3 01       	movw	r24, r6
    4dba:	b2 01       	movw	r22, r4
    4dbc:	0e 94 d6 20 	call	0x41ac	; 0x41ac <getFirstSector>
    4dc0:	6b 01       	movw	r12, r22
    4dc2:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    4dc4:	80 91 6e 50 	lds	r24, 0x506E
    4dc8:	90 91 6f 50 	lds	r25, 0x506F
    4dcc:	00 97       	sbiw	r24, 0x00	; 0
    4dce:	a1 f0       	breq	.+40     	; 0x4df8 <readFile+0xb4>
    4dd0:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4dd2:	c7 01       	movw	r24, r14
    4dd4:	b6 01       	movw	r22, r12
    4dd6:	6c 0f       	add	r22, r28
    4dd8:	71 1d       	adc	r23, r1
    4dda:	81 1d       	adc	r24, r1
    4ddc:	91 1d       	adc	r25, r1
    4dde:	a5 01       	movw	r20, r10
    4de0:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    4de4:	cf 5f       	subi	r28, 0xFF	; 255
    4de6:	80 91 6e 50 	lds	r24, 0x506E
    4dea:	90 91 6f 50 	lds	r25, 0x506F
    4dee:	2c 2f       	mov	r18, r28
    4df0:	30 e0       	ldi	r19, 0x00	; 0
    4df2:	28 17       	cp	r18, r24
    4df4:	39 07       	cpc	r19, r25
    4df6:	68 f3       	brcs	.-38     	; 0x4dd2 <readFile+0x8e>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    4df8:	c3 01       	movw	r24, r6
    4dfa:	b2 01       	movw	r22, r4
    4dfc:	40 e0       	ldi	r20, 0x00	; 0
    4dfe:	00 e0       	ldi	r16, 0x00	; 0
    4e00:	10 e0       	ldi	r17, 0x00	; 0
    4e02:	98 01       	movw	r18, r16
    4e04:	0e 94 fd 20 	call	0x41fa	; 0x41fa <getSetNextCluster>
    4e08:	2b 01       	movw	r4, r22
    4e0a:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    4e0c:	61 15       	cp	r22, r1
    4e0e:	71 05       	cpc	r23, r1
    4e10:	81 05       	cpc	r24, r1
    4e12:	91 05       	cpc	r25, r1
    4e14:	89 f6       	brne	.-94     	; 0x4db8 <readFile+0x74>
	  return 0;}
    4e16:	80 e0       	ldi	r24, 0x00	; 0
    4e18:	03 c0       	rjmp	.+6      	; 0x4e20 <readFile+0xdc>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4e1a:	82 e0       	ldi	r24, 0x02	; 2
    4e1c:	01 c0       	rjmp	.+2      	; 0x4e20 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4e1e:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    4e20:	cf 91       	pop	r28
    4e22:	1f 91       	pop	r17
    4e24:	0f 91       	pop	r16
    4e26:	ff 90       	pop	r15
    4e28:	ef 90       	pop	r14
    4e2a:	df 90       	pop	r13
    4e2c:	cf 90       	pop	r12
    4e2e:	bf 90       	pop	r11
    4e30:	af 90       	pop	r10
    4e32:	7f 90       	pop	r7
    4e34:	6f 90       	pop	r6
    4e36:	5f 90       	pop	r5
    4e38:	4f 90       	pop	r4
    4e3a:	08 95       	ret

00004e3c <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4e3c:	2f 92       	push	r2
    4e3e:	3f 92       	push	r3
    4e40:	4f 92       	push	r4
    4e42:	5f 92       	push	r5
    4e44:	6f 92       	push	r6
    4e46:	7f 92       	push	r7
    4e48:	8f 92       	push	r8
    4e4a:	9f 92       	push	r9
    4e4c:	af 92       	push	r10
    4e4e:	bf 92       	push	r11
    4e50:	cf 92       	push	r12
    4e52:	df 92       	push	r13
    4e54:	ef 92       	push	r14
    4e56:	ff 92       	push	r15
    4e58:	0f 93       	push	r16
    4e5a:	1f 93       	push	r17
    4e5c:	cf 93       	push	r28
    4e5e:	df 93       	push	r29
    4e60:	cd b7       	in	r28, 0x3d	; 61
    4e62:	de b7       	in	r29, 0x3e	; 62
    4e64:	60 97       	sbiw	r28, 0x10	; 16
    4e66:	cd bf       	out	0x3d, r28	; 61
    4e68:	de bf       	out	0x3e, r29	; 62
    4e6a:	fc 01       	movw	r30, r24
    4e6c:	6d 83       	std	Y+5, r22	; 0x05
    4e6e:	7e 83       	std	Y+6, r23	; 0x06
    4e70:	49 01       	movw	r8, r18
    4e72:	5a 01       	movw	r10, r20
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    4e74:	81 e0       	ldi	r24, 0x01	; 1
    4e76:	bf 01       	movw	r22, r30
    4e78:	0e 94 a2 26 	call	0x4d44	; 0x4d44 <readFile>

if(j == 1) 
    4e7c:	81 30       	cpi	r24, 0x01	; 1
    4e7e:	09 f0       	breq	.+2      	; 0x4e82 <writeFile+0x46>
    4e80:	7b c0       	rjmp	.+246    	; 0x4f78 <writeFile+0x13c>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    4e82:	00 91 78 50 	lds	r16, 0x5078
    4e86:	10 91 79 50 	lds	r17, 0x5079
    4e8a:	20 91 7a 50 	lds	r18, 0x507A
    4e8e:	30 91 7b 50 	lds	r19, 0x507B
    4e92:	09 83       	std	Y+1, r16	; 0x01
    4e94:	1a 83       	std	Y+2, r17	; 0x02
    4e96:	2b 83       	std	Y+3, r18	; 0x03
    4e98:	3c 83       	std	Y+4, r19	; 0x04
  clusterCount=0;
    4e9a:	cc 24       	eor	r12, r12
    4e9c:	dd 24       	eor	r13, r13
    4e9e:	76 01       	movw	r14, r12
    4ea0:	24 01       	movw	r4, r8
    4ea2:	35 01       	movw	r6, r10
    4ea4:	48 01       	movw	r8, r16
    4ea6:	59 01       	movw	r10, r18
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    4ea8:	c5 01       	movw	r24, r10
    4eaa:	b4 01       	movw	r22, r8
    4eac:	40 e0       	ldi	r20, 0x00	; 0
    4eae:	00 e0       	ldi	r16, 0x00	; 0
    4eb0:	10 e0       	ldi	r17, 0x00	; 0
    4eb2:	98 01       	movw	r18, r16
    4eb4:	0e 94 fd 20 	call	0x41fa	; 0x41fa <getSetNextCluster>
    4eb8:	dc 01       	movw	r26, r24
    4eba:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    4ebc:	8f 3f       	cpi	r24, 0xFF	; 255
    4ebe:	1f ef       	ldi	r17, 0xFF	; 255
    4ec0:	91 07       	cpc	r25, r17
    4ec2:	1f ef       	ldi	r17, 0xFF	; 255
    4ec4:	a1 07       	cpc	r26, r17
    4ec6:	1f ef       	ldi	r17, 0xFF	; 255
    4ec8:	b1 07       	cpc	r27, r17
    4eca:	41 f0       	breq	.+16     	; 0x4edc <writeFile+0xa0>
	cluster = nextCluster;
	clusterCount++;
    4ecc:	08 94       	sec
    4ece:	c1 1c       	adc	r12, r1
    4ed0:	d1 1c       	adc	r13, r1
    4ed2:	e1 1c       	adc	r14, r1
    4ed4:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    4ed6:	4c 01       	movw	r8, r24
    4ed8:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    4eda:	e6 cf       	rjmp	.-52     	; 0x4ea8 <writeFile+0x6c>
    4edc:	89 82       	std	Y+1, r8	; 0x01
    4ede:	9a 82       	std	Y+2, r9	; 0x02
    4ee0:	ab 82       	std	Y+3, r10	; 0x03
    4ee2:	bc 82       	std	Y+4, r11	; 0x04
    4ee4:	53 01       	movw	r10, r6
    4ee6:	42 01       	movw	r8, r4
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    4ee8:	20 91 6e 50 	lds	r18, 0x506E
    4eec:	30 91 6f 50 	lds	r19, 0x506F
    4ef0:	80 91 5a 40 	lds	r24, 0x405A
    4ef4:	90 91 5b 40 	lds	r25, 0x405B
    4ef8:	60 90 5a 40 	lds	r6, 0x405A
    4efc:	70 90 5b 40 	lds	r7, 0x405B
    4f00:	bc 01       	movw	r22, r24
    4f02:	80 e0       	ldi	r24, 0x00	; 0
    4f04:	90 e0       	ldi	r25, 0x00	; 0
    4f06:	40 e0       	ldi	r20, 0x00	; 0
    4f08:	50 e0       	ldi	r21, 0x00	; 0
    4f0a:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    4f0e:	a7 01       	movw	r20, r14
    4f10:	96 01       	movw	r18, r12
    4f12:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    4f16:	dc 01       	movw	r26, r24
    4f18:	cb 01       	movw	r24, r22
    4f1a:	40 91 56 40 	lds	r20, 0x4056
    4f1e:	50 91 57 40 	lds	r21, 0x4057
    4f22:	60 91 58 40 	lds	r22, 0x4058
    4f26:	70 91 59 40 	lds	r23, 0x4059
    4f2a:	8a 01       	movw	r16, r20
    4f2c:	9b 01       	movw	r18, r22
    4f2e:	08 1b       	sub	r16, r24
    4f30:	19 0b       	sbc	r17, r25
    4f32:	2a 0b       	sbc	r18, r26
    4f34:	3b 0b       	sbc	r19, r27
    4f36:	c9 01       	movw	r24, r18
    4f38:	b8 01       	movw	r22, r16
    4f3a:	93 01       	movw	r18, r6
    4f3c:	40 e0       	ldi	r20, 0x00	; 0
    4f3e:	50 e0       	ldi	r21, 0x00	; 0
    4f40:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    4f44:	02 2f       	mov	r16, r18

//start writing data here

if(start){
  start = 0;
  startBlock = getFirstSector (cluster) + sector;
    4f46:	69 81       	ldd	r22, Y+1	; 0x01
    4f48:	7a 81       	ldd	r23, Y+2	; 0x02
    4f4a:	8b 81       	ldd	r24, Y+3	; 0x03
    4f4c:	9c 81       	ldd	r25, Y+4	; 0x04
    4f4e:	0e 94 d6 20 	call	0x41ac	; 0x41ac <getFirstSector>
    4f52:	dc 01       	movw	r26, r24
    4f54:	cb 01       	movw	r24, r22
    4f56:	20 2e       	mov	r2, r16
    4f58:	33 24       	eor	r3, r3
    4f5a:	28 0e       	add	r2, r24
    4f5c:	39 1e       	adc	r3, r25
  SD_read_block (startBlock,SDBuffer);
    4f5e:	b1 01       	movw	r22, r2
    4f60:	80 e0       	ldi	r24, 0x00	; 0
    4f62:	90 e0       	ldi	r25, 0x00	; 0
    4f64:	4d e4       	ldi	r20, 0x4D	; 77
    4f66:	5e e3       	ldi	r21, 0x3E	; 62
    4f68:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <SD_read_block>
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    4f6c:	1f 86       	std	Y+15, r1	; 0x0f
    4f6e:	18 8a       	std	Y+16, r1	; 0x10
    4f70:	19 86       	std	Y+9, r1	; 0x09
    4f72:	1a 86       	std	Y+10, r1	; 0x0a
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    4f74:	11 e0       	ldi	r17, 0x01	; 1
    4f76:	4c c0       	rjmp	.+152    	; 0x5010 <writeFile+0x1d4>
}
else if(j == 2) 
    4f78:	82 30       	cpi	r24, 0x02	; 2
    4f7a:	09 f4       	brne	.+2      	; 0x4f7e <writeFile+0x142>
    4f7c:	0c c2       	rjmp	.+1048   	; 0x5396 <writeFile+0x55a>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    4f7e:	82 e0       	ldi	r24, 0x02	; 2
    4f80:	60 e0       	ldi	r22, 0x00	; 0
    4f82:	20 e0       	ldi	r18, 0x00	; 0
    4f84:	30 e0       	ldi	r19, 0x00	; 0
    4f86:	a9 01       	movw	r20, r18
    4f88:	0e 94 8f 21 	call	0x431e	; 0x431e <getSetFreeCluster>
  if(cluster > totalClusters)
    4f8c:	00 91 5d 40 	lds	r16, 0x405D
    4f90:	10 91 5e 40 	lds	r17, 0x405E
    4f94:	20 91 5f 40 	lds	r18, 0x405F
    4f98:	30 91 60 40 	lds	r19, 0x4060
    4f9c:	06 17       	cp	r16, r22
    4f9e:	17 07       	cpc	r17, r23
    4fa0:	28 07       	cpc	r18, r24
    4fa2:	39 07       	cpc	r19, r25
    4fa4:	40 f4       	brcc	.+16     	; 0x4fb6 <writeFile+0x17a>
     cluster = rootCluster;
    4fa6:	60 91 62 40 	lds	r22, 0x4062
    4faa:	70 91 63 40 	lds	r23, 0x4063
    4fae:	80 91 64 40 	lds	r24, 0x4064
    4fb2:	90 91 65 40 	lds	r25, 0x4065

  cluster = searchNextFreeCluster(cluster);
    4fb6:	0e 94 db 23 	call	0x47b6	; 0x47b6 <searchNextFreeCluster>
    4fba:	69 83       	std	Y+1, r22	; 0x01
    4fbc:	7a 83       	std	Y+2, r23	; 0x02
    4fbe:	8b 83       	std	Y+3, r24	; 0x03
    4fc0:	9c 83       	std	Y+4, r25	; 0x04
   if(cluster == 0)
    4fc2:	61 15       	cp	r22, r1
    4fc4:	71 05       	cpc	r23, r1
    4fc6:	81 05       	cpc	r24, r1
    4fc8:	91 05       	cpc	r25, r1
    4fca:	09 f4       	brne	.+2      	; 0x4fce <writeFile+0x192>
    4fcc:	e6 c1       	rjmp	.+972    	; 0x539a <writeFile+0x55e>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    4fce:	41 e0       	ldi	r20, 0x01	; 1
    4fd0:	0f ef       	ldi	r16, 0xFF	; 255
    4fd2:	1f ef       	ldi	r17, 0xFF	; 255
    4fd4:	98 01       	movw	r18, r16
    4fd6:	0e 94 fd 20 	call	0x41fa	; 0x41fa <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    4fda:	2b 81       	ldd	r18, Y+3	; 0x03
    4fdc:	3c 81       	ldd	r19, Y+4	; 0x04
    4fde:	29 87       	std	Y+9, r18	; 0x09
    4fe0:	3a 87       	std	Y+10, r19	; 0x0a
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    4fe2:	89 81       	ldd	r24, Y+1	; 0x01
    4fe4:	9a 81       	ldd	r25, Y+2	; 0x02
    4fe6:	8f 87       	std	Y+15, r24	; 0x0f
    4fe8:	98 8b       	std	Y+16, r25	; 0x10
  fileSize = 0;
    4fea:	10 92 56 40 	sts	0x4056, r1
    4fee:	10 92 57 40 	sts	0x4057, r1
    4ff2:	10 92 58 40 	sts	0x4058, r1
    4ff6:	10 92 59 40 	sts	0x4059, r1
  startBlock = getFirstSector (cluster) + sector;
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
    4ffa:	69 81       	ldd	r22, Y+1	; 0x01
    4ffc:	7a 81       	ldd	r23, Y+2	; 0x02
    4ffe:	8b 81       	ldd	r24, Y+3	; 0x03
    5000:	9c 81       	ldd	r25, Y+4	; 0x04
    5002:	0e 94 d6 20 	call	0x41ac	; 0x41ac <getFirstSector>
    5006:	dc 01       	movw	r26, r24
    5008:	cb 01       	movw	r24, r22
    500a:	1c 01       	movw	r2, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    500c:	10 e0       	ldi	r17, 0x00	; 0
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
  j=0;
    500e:	00 e0       	ldi	r16, 0x00	; 0
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    5010:	81 14       	cp	r8, r1
    5012:	91 04       	cpc	r9, r1
    5014:	a1 04       	cpc	r10, r1
    5016:	b1 04       	cpc	r11, r1
    5018:	09 f4       	brne	.+2      	; 0x501c <writeFile+0x1e0>
    501a:	8d c0       	rjmp	.+282    	; 0x5136 <writeFile+0x2fa>
    501c:	44 24       	eor	r4, r4
    501e:	55 24       	eor	r5, r5
    5020:	32 01       	movw	r6, r4
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
		 writtenData += 512;
		 dataToWrite = 512;
    5022:	c0 2e       	mov	r12, r16
    5024:	1b 87       	std	Y+11, r17	; 0x0b
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    5026:	90 e0       	ldi	r25, 0x00	; 0
    5028:	89 16       	cp	r8, r25
    502a:	92 e0       	ldi	r25, 0x02	; 2
    502c:	99 06       	cpc	r9, r25
    502e:	90 e0       	ldi	r25, 0x00	; 0
    5030:	a9 06       	cpc	r10, r25
    5032:	90 e0       	ldi	r25, 0x00	; 0
    5034:	b9 06       	cpc	r11, r25
    5036:	88 f0       	brcs	.+34     	; 0x505a <writeFile+0x21e>
		 writtenData += 512;
    5038:	00 e0       	ldi	r16, 0x00	; 0
    503a:	12 e0       	ldi	r17, 0x02	; 2
    503c:	20 e0       	ldi	r18, 0x00	; 0
    503e:	30 e0       	ldi	r19, 0x00	; 0
    5040:	40 0e       	add	r4, r16
    5042:	51 1e       	adc	r5, r17
    5044:	62 1e       	adc	r6, r18
    5046:	73 1e       	adc	r7, r19
		 dataToWrite = 512;
		 lengthOfData -= 512;
    5048:	80 e0       	ldi	r24, 0x00	; 0
    504a:	9e ef       	ldi	r25, 0xFE	; 254
    504c:	af ef       	ldi	r26, 0xFF	; 255
    504e:	bf ef       	ldi	r27, 0xFF	; 255
    5050:	88 0e       	add	r8, r24
    5052:	99 1e       	adc	r9, r25
    5054:	aa 1e       	adc	r10, r26
    5056:	bb 1e       	adc	r11, r27
    5058:	0c c0       	rjmp	.+24     	; 0x5072 <writeFile+0x236>
	}
	else{
		writtenData += lengthOfData;
    505a:	48 0c       	add	r4, r8
    505c:	59 1c       	adc	r5, r9
    505e:	6a 1c       	adc	r6, r10
    5060:	7b 1c       	adc	r7, r11
		dataToWrite = lengthOfData%512;
    5062:	95 01       	movw	r18, r10
    5064:	84 01       	movw	r16, r8
    5066:	11 70       	andi	r17, 0x01	; 1
    5068:	20 70       	andi	r18, 0x00	; 0
    506a:	30 70       	andi	r19, 0x00	; 0
		lengthOfData = 0;
    506c:	88 24       	eor	r8, r8
    506e:	99 24       	eor	r9, r9
    5070:	54 01       	movw	r10, r8
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    5072:	80 91 56 40 	lds	r24, 0x4056
    5076:	90 91 57 40 	lds	r25, 0x4057
    507a:	a0 91 58 40 	lds	r26, 0x4058
    507e:	b0 91 59 40 	lds	r27, 0x4059
    5082:	80 50       	subi	r24, 0x00	; 0
    5084:	9e 4f       	sbci	r25, 0xFE	; 254
    5086:	af 4f       	sbci	r26, 0xFF	; 255
    5088:	bf 4f       	sbci	r27, 0xFF	; 255
    508a:	80 93 56 40 	sts	0x4056, r24
    508e:	90 93 57 40 	sts	0x4057, r25
    5092:	a0 93 58 40 	sts	0x4058, r26
    5096:	b0 93 59 40 	sts	0x4059, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    509a:	b1 01       	movw	r22, r2
    509c:	80 e0       	ldi	r24, 0x00	; 0
    509e:	90 e0       	ldi	r25, 0x00	; 0
    50a0:	a2 01       	movw	r20, r4
    50a2:	40 1b       	sub	r20, r16
    50a4:	51 0b       	sbc	r21, r17
    50a6:	ad 81       	ldd	r26, Y+5	; 0x05
    50a8:	be 81       	ldd	r27, Y+6	; 0x06
    50aa:	4a 0f       	add	r20, r26
    50ac:	5b 1f       	adc	r21, r27
    50ae:	98 01       	movw	r18, r16
    50b0:	0e 94 27 2b 	call	0x564e	; 0x564e <SD_write_block>
	j++;
    50b4:	c3 94       	inc	r12
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    50b6:	20 91 6e 50 	lds	r18, 0x506E
    50ba:	30 91 6f 50 	lds	r19, 0x506F
    50be:	8c 2d       	mov	r24, r12
    50c0:	90 e0       	ldi	r25, 0x00	; 0
    50c2:	82 17       	cp	r24, r18
    50c4:	93 07       	cpc	r25, r19
    50c6:	29 f5       	brne	.+74     	; 0x5112 <writeFile+0x2d6>
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    50c8:	69 81       	ldd	r22, Y+1	; 0x01
    50ca:	7a 81       	ldd	r23, Y+2	; 0x02
    50cc:	8b 81       	ldd	r24, Y+3	; 0x03
    50ce:	9c 81       	ldd	r25, Y+4	; 0x04
    50d0:	0e 94 db 23 	call	0x47b6	; 0x47b6 <searchNextFreeCluster>
    50d4:	6b 01       	movw	r12, r22
    50d6:	7c 01       	movw	r14, r24
		if(cluster == 0){
    50d8:	61 15       	cp	r22, r1
    50da:	71 05       	cpc	r23, r1
    50dc:	81 05       	cpc	r24, r1
    50de:	91 05       	cpc	r25, r1
    50e0:	09 f4       	brne	.+2      	; 0x50e4 <writeFile+0x2a8>
    50e2:	5d c1       	rjmp	.+698    	; 0x539e <writeFile+0x562>
		  //No free cluster!
		  return 2;
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    50e4:	69 81       	ldd	r22, Y+1	; 0x01
    50e6:	7a 81       	ldd	r23, Y+2	; 0x02
    50e8:	8b 81       	ldd	r24, Y+3	; 0x03
    50ea:	9c 81       	ldd	r25, Y+4	; 0x04
    50ec:	41 e0       	ldi	r20, 0x01	; 1
    50ee:	97 01       	movw	r18, r14
    50f0:	86 01       	movw	r16, r12
    50f2:	0e 94 fd 20 	call	0x41fa	; 0x41fa <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    50f6:	c7 01       	movw	r24, r14
    50f8:	b6 01       	movw	r22, r12
    50fa:	41 e0       	ldi	r20, 0x01	; 1
    50fc:	0f ef       	ldi	r16, 0xFF	; 255
    50fe:	1f ef       	ldi	r17, 0xFF	; 255
    5100:	98 01       	movw	r18, r16
    5102:	0e 94 fd 20 	call	0x41fa	; 0x41fa <getSetNextCluster>
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    5106:	c9 82       	std	Y+1, r12	; 0x01
    5108:	da 82       	std	Y+2, r13	; 0x02
    510a:	eb 82       	std	Y+3, r14	; 0x03
    510c:	fc 82       	std	Y+4, r15	; 0x04
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
	j++;
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
    510e:	cc 24       	eor	r12, r12
    5110:	03 c0       	rjmp	.+6      	; 0x5118 <writeFile+0x2dc>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    5112:	08 94       	sec
    5114:	21 1c       	adc	r2, r1
    5116:	31 1c       	adc	r3, r1
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    5118:	82 e0       	ldi	r24, 0x02	; 2
    511a:	61 e0       	ldi	r22, 0x01	; 1
    511c:	29 81       	ldd	r18, Y+1	; 0x01
    511e:	3a 81       	ldd	r19, Y+2	; 0x02
    5120:	4b 81       	ldd	r20, Y+3	; 0x03
    5122:	5c 81       	ldd	r21, Y+4	; 0x04
    5124:	0e 94 8f 21 	call	0x431e	; 0x431e <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    5128:	81 14       	cp	r8, r1
    512a:	91 04       	cpc	r9, r1
    512c:	a1 04       	cpc	r10, r1
    512e:	b1 04       	cpc	r11, r1
    5130:	09 f0       	breq	.+2      	; 0x5134 <writeFile+0x2f8>
    5132:	79 cf       	rjmp	.-270    	; 0x5026 <writeFile+0x1ea>
    5134:	1b 85       	ldd	r17, Y+11	; 0x0b
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    5136:	11 23       	and	r17, r17
    5138:	09 f4       	brne	.+2      	; 0x513c <writeFile+0x300>
    513a:	3f c0       	rjmp	.+126    	; 0x51ba <writeFile+0x37e>
{
  SD_read_block (appendFileSector,SDBuffer);    
    513c:	60 91 a7 50 	lds	r22, 0x50A7
    5140:	70 91 a8 50 	lds	r23, 0x50A8
    5144:	80 91 a9 50 	lds	r24, 0x50A9
    5148:	90 91 aa 50 	lds	r25, 0x50AA
    514c:	0d e4       	ldi	r16, 0x4D	; 77
    514e:	1e e3       	ldi	r17, 0x3E	; 62
    5150:	a8 01       	movw	r20, r16
    5152:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    5156:	e0 91 4e 40 	lds	r30, 0x404E
    515a:	f0 91 4f 40 	lds	r31, 0x404F
    515e:	e0 0f       	add	r30, r16
    5160:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    5162:	12 8a       	std	Z+18, r1	; 0x12
    5164:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    5166:	80 91 56 40 	lds	r24, 0x4056
    516a:	90 91 57 40 	lds	r25, 0x4057
    516e:	a0 91 58 40 	lds	r26, 0x4058
    5172:	b0 91 59 40 	lds	r27, 0x4059
    5176:	44 8d       	ldd	r20, Z+28	; 0x1c
    5178:	55 8d       	ldd	r21, Z+29	; 0x1d
    517a:	66 8d       	ldd	r22, Z+30	; 0x1e
    517c:	77 8d       	ldd	r23, Z+31	; 0x1f
    517e:	6c 01       	movw	r12, r24
    5180:	7d 01       	movw	r14, r26
    5182:	c4 1a       	sub	r12, r20
    5184:	d5 0a       	sbc	r13, r21
    5186:	e6 0a       	sbc	r14, r22
    5188:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    518a:	84 8f       	std	Z+28, r24	; 0x1c
    518c:	95 8f       	std	Z+29, r25	; 0x1d
    518e:	a6 8f       	std	Z+30, r26	; 0x1e
    5190:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    5192:	60 91 a7 50 	lds	r22, 0x50A7
    5196:	70 91 a8 50 	lds	r23, 0x50A8
    519a:	80 91 a9 50 	lds	r24, 0x50A9
    519e:	90 91 aa 50 	lds	r25, 0x50AA
    51a2:	a8 01       	movw	r20, r16
    51a4:	20 e0       	ldi	r18, 0x00	; 0
    51a6:	32 e0       	ldi	r19, 0x02	; 2
    51a8:	0e 94 27 2b 	call	0x564e	; 0x564e <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    51ac:	81 e0       	ldi	r24, 0x01	; 1
    51ae:	b7 01       	movw	r22, r14
    51b0:	a6 01       	movw	r20, r12
    51b2:	0e 94 8e 24 	call	0x491c	; 0x491c <freeMemoryUpdate>

 //File appended!
  return 0;
    51b6:	80 e0       	ldi	r24, 0x00	; 0
    51b8:	f9 c0       	rjmp	.+498    	; 0x53ac <writeFile+0x570>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    51ba:	00 91 62 40 	lds	r16, 0x4062
    51be:	10 91 63 40 	lds	r17, 0x4063
    51c2:	20 91 64 40 	lds	r18, 0x4064
    51c6:	30 91 65 40 	lds	r19, 0x4065
    51ca:	0b 87       	std	Y+11, r16	; 0x0b
    51cc:	1c 87       	std	Y+12, r17	; 0x0c
    51ce:	2d 87       	std	Y+13, r18	; 0x0d
    51d0:	3e 87       	std	Y+14, r19	; 0x0e
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    51d2:	77 24       	eor	r7, r7
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    51d4:	86 e9       	ldi	r24, 0x96	; 150
    51d6:	90 e5       	ldi	r25, 0x50	; 80
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    51d8:	0f 2e       	mov	r0, r31
    51da:	fb e0       	ldi	r31, 0x0B	; 11
    51dc:	af 2e       	mov	r10, r31
    51de:	bb 24       	eor	r11, r11
    51e0:	f0 2d       	mov	r31, r0
    51e2:	a8 0e       	add	r10, r24
    51e4:	b9 1e       	adc	r11, r25

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    51e6:	88 24       	eor	r8, r8
    51e8:	68 94       	set
    51ea:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    51ec:	0f 2e       	mov	r0, r31
    51ee:	fd e4       	ldi	r31, 0x4D	; 77
    51f0:	4f 2e       	mov	r4, r31
    51f2:	fe e3       	ldi	r31, 0x3E	; 62
    51f4:	5f 2e       	mov	r5, r31
    51f6:	f0 2d       	mov	r31, r0
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    51f8:	28 2e       	mov	r2, r24
    51fa:	99 2e       	mov	r9, r25
    51fc:	37 2c       	mov	r3, r7
    51fe:	6f 84       	ldd	r6, Y+15	; 0x0f
    5200:	78 88       	ldd	r7, Y+16	; 0x10
    5202:	04 c0       	rjmp	.+8      	; 0x520c <writeFile+0x3d0>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    5204:	cb 86       	std	Y+11, r12	; 0x0b
    5206:	dc 86       	std	Y+12, r13	; 0x0c
    5208:	ed 86       	std	Y+13, r14	; 0x0d
    520a:	fe 86       	std	Y+14, r15	; 0x0e

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    520c:	6b 85       	ldd	r22, Y+11	; 0x0b
    520e:	7c 85       	ldd	r23, Y+12	; 0x0c
    5210:	8d 85       	ldd	r24, Y+13	; 0x0d
    5212:	9e 85       	ldd	r25, Y+14	; 0x0e
    5214:	0e 94 d6 20 	call	0x41ac	; 0x41ac <getFirstSector>
    5218:	6d 83       	std	Y+5, r22	; 0x05
    521a:	7e 83       	std	Y+6, r23	; 0x06
    521c:	8f 83       	std	Y+7, r24	; 0x07
    521e:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    5220:	80 91 6e 50 	lds	r24, 0x506E
    5224:	90 91 6f 50 	lds	r25, 0x506F
    5228:	00 97       	sbiw	r24, 0x00	; 0
    522a:	09 f4       	brne	.+2      	; 0x522e <writeFile+0x3f2>
    522c:	77 c0       	rjmp	.+238    	; 0x531c <writeFile+0x4e0>
    522e:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    5230:	cd 80       	ldd	r12, Y+5	; 0x05
    5232:	de 80       	ldd	r13, Y+6	; 0x06
    5234:	ef 80       	ldd	r14, Y+7	; 0x07
    5236:	f8 84       	ldd	r15, Y+8	; 0x08
    5238:	19 81       	ldd	r17, Y+1	; 0x01
    523a:	c1 0e       	add	r12, r17
    523c:	d1 1c       	adc	r13, r1
    523e:	e1 1c       	adc	r14, r1
    5240:	f1 1c       	adc	r15, r1
    5242:	c7 01       	movw	r24, r14
    5244:	b6 01       	movw	r22, r12
    5246:	a2 01       	movw	r20, r4
    5248:	0e 94 dc 2b 	call	0x57b8	; 0x57b8 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    524c:	80 91 5a 40 	lds	r24, 0x405A
    5250:	90 91 5b 40 	lds	r25, 0x405B
    5254:	00 97       	sbiw	r24, 0x00	; 0
    5256:	09 f4       	brne	.+2      	; 0x525a <writeFile+0x41e>
    5258:	54 c0       	rjmp	.+168    	; 0x5302 <writeFile+0x4c6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    525a:	33 20       	and	r3, r3
    525c:	09 f0       	breq	.+2      	; 0x5260 <writeFile+0x424>
    525e:	a1 c0       	rjmp	.+322    	; 0x53a2 <writeFile+0x566>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    5260:	a2 01       	movw	r20, r4
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    5262:	00 e0       	ldi	r16, 0x00	; 0
    5264:	10 e0       	ldi	r17, 0x00	; 0
    5266:	06 c0       	rjmp	.+12     	; 0x5274 <writeFile+0x438>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    5268:	a8 01       	movw	r20, r16
    526a:	43 5b       	subi	r20, 0xB3	; 179
    526c:	51 4c       	sbci	r21, 0xC1	; 193
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    526e:	22 23       	and	r18, r18
    5270:	09 f0       	breq	.+2      	; 0x5274 <writeFile+0x438>
    5272:	99 c0       	rjmp	.+306    	; 0x53a6 <writeFile+0x56a>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    5274:	da 01       	movw	r26, r20
    5276:	8c 91       	ld	r24, X
    5278:	88 23       	and	r24, r24
    527a:	21 f4       	brne	.+8      	; 0x5284 <writeFile+0x448>
    527c:	e2 2d       	mov	r30, r2
    527e:	f9 2d       	mov	r31, r9
    5280:	da 01       	movw	r26, r20
    5282:	04 c0       	rjmp	.+8      	; 0x528c <writeFile+0x450>
    5284:	85 3e       	cpi	r24, 0xE5	; 229
    5286:	d1 f3       	breq	.-12     	; 0x527c <writeFile+0x440>
    5288:	23 2d       	mov	r18, r3
    528a:	30 c0       	rjmp	.+96     	; 0x52ec <writeFile+0x4b0>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
    528c:	81 91       	ld	r24, Z+
    528e:	8d 93       	st	X+, r24
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    5290:	ea 15       	cp	r30, r10
    5292:	fb 05       	cpc	r31, r11
    5294:	d9 f7       	brne	.-10     	; 0x528c <writeFile+0x450>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    5296:	fa 01       	movw	r30, r20
    5298:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    529a:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    529c:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    529e:	12 8a       	std	Z+18, r1	; 0x12
    52a0:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    52a2:	29 85       	ldd	r18, Y+9	; 0x09
    52a4:	3a 85       	ldd	r19, Y+10	; 0x0a
    52a6:	24 8b       	std	Z+20, r18	; 0x14
    52a8:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    52aa:	62 8e       	std	Z+26, r6	; 0x1a
    52ac:	73 8e       	std	Z+27, r7	; 0x1b
		  dir->fileSize = fileSize;
    52ae:	80 91 56 40 	lds	r24, 0x4056
    52b2:	90 91 57 40 	lds	r25, 0x4057
    52b6:	a0 91 58 40 	lds	r26, 0x4058
    52ba:	b0 91 59 40 	lds	r27, 0x4059
    52be:	84 8f       	std	Z+28, r24	; 0x1c
    52c0:	95 8f       	std	Z+29, r25	; 0x1d
    52c2:	a6 8f       	std	Z+30, r26	; 0x1e
    52c4:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    52c6:	c7 01       	movw	r24, r14
    52c8:	b6 01       	movw	r22, r12
    52ca:	a2 01       	movw	r20, r4
    52cc:	20 e0       	ldi	r18, 0x00	; 0
    52ce:	32 e0       	ldi	r19, 0x02	; 2
    52d0:	0e 94 27 2b 	call	0x564e	; 0x564e <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    52d4:	40 91 56 40 	lds	r20, 0x4056
    52d8:	50 91 57 40 	lds	r21, 0x4057
    52dc:	60 91 58 40 	lds	r22, 0x4058
    52e0:	70 91 59 40 	lds	r23, 0x4059
    52e4:	81 e0       	ldi	r24, 0x01	; 1
    52e6:	0e 94 8e 24 	call	0x491c	; 0x491c <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    52ea:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    52ec:	00 5e       	subi	r16, 0xE0	; 224
    52ee:	1f 4f       	sbci	r17, 0xFF	; 255
    52f0:	80 91 5a 40 	lds	r24, 0x405A
    52f4:	90 91 5b 40 	lds	r25, 0x405B
    52f8:	08 17       	cp	r16, r24
    52fa:	19 07       	cpc	r17, r25
    52fc:	08 f4       	brcc	.+2      	; 0x5300 <writeFile+0x4c4>
    52fe:	b4 cf       	rjmp	.-152    	; 0x5268 <writeFile+0x42c>
    5300:	32 2e       	mov	r3, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    5302:	09 81       	ldd	r16, Y+1	; 0x01
    5304:	0f 5f       	subi	r16, 0xFF	; 255
    5306:	09 83       	std	Y+1, r16	; 0x01
    5308:	20 91 6e 50 	lds	r18, 0x506E
    530c:	30 91 6f 50 	lds	r19, 0x506F
    5310:	80 2f       	mov	r24, r16
    5312:	90 e0       	ldi	r25, 0x00	; 0
    5314:	82 17       	cp	r24, r18
    5316:	93 07       	cpc	r25, r19
    5318:	08 f4       	brcc	.+2      	; 0x531c <writeFile+0x4e0>
    531a:	8a cf       	rjmp	.-236    	; 0x5230 <writeFile+0x3f4>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    531c:	6b 85       	ldd	r22, Y+11	; 0x0b
    531e:	7c 85       	ldd	r23, Y+12	; 0x0c
    5320:	8d 85       	ldd	r24, Y+13	; 0x0d
    5322:	9e 85       	ldd	r25, Y+14	; 0x0e
    5324:	40 e0       	ldi	r20, 0x00	; 0
    5326:	00 e0       	ldi	r16, 0x00	; 0
    5328:	10 e0       	ldi	r17, 0x00	; 0
    532a:	98 01       	movw	r18, r16
    532c:	0e 94 fd 20 	call	0x41fa	; 0x41fa <getSetNextCluster>
    5330:	6b 01       	movw	r12, r22
    5332:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    5334:	67 3f       	cpi	r22, 0xF7	; 247
    5336:	1f ef       	ldi	r17, 0xFF	; 255
    5338:	71 07       	cpc	r23, r17
    533a:	1f ef       	ldi	r17, 0xFF	; 255
    533c:	81 07       	cpc	r24, r17
    533e:	1f e0       	ldi	r17, 0x0F	; 15
    5340:	91 07       	cpc	r25, r17
    5342:	08 f1       	brcs	.+66     	; 0x5386 <writeFile+0x54a>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    5344:	6f 3f       	cpi	r22, 0xFF	; 255
    5346:	2f ef       	ldi	r18, 0xFF	; 255
    5348:	72 07       	cpc	r23, r18
    534a:	2f ef       	ldi	r18, 0xFF	; 255
    534c:	82 07       	cpc	r24, r18
    534e:	2f ef       	ldi	r18, 0xFF	; 255
    5350:	92 07       	cpc	r25, r18
    5352:	59 f5       	brne	.+86     	; 0x53aa <writeFile+0x56e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    5354:	6b 85       	ldd	r22, Y+11	; 0x0b
    5356:	7c 85       	ldd	r23, Y+12	; 0x0c
    5358:	8d 85       	ldd	r24, Y+13	; 0x0d
    535a:	9e 85       	ldd	r25, Y+14	; 0x0e
    535c:	0e 94 db 23 	call	0x47b6	; 0x47b6 <searchNextFreeCluster>
    5360:	6b 01       	movw	r12, r22
    5362:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    5364:	6b 85       	ldd	r22, Y+11	; 0x0b
    5366:	7c 85       	ldd	r23, Y+12	; 0x0c
    5368:	8d 85       	ldd	r24, Y+13	; 0x0d
    536a:	9e 85       	ldd	r25, Y+14	; 0x0e
    536c:	41 e0       	ldi	r20, 0x01	; 1
    536e:	97 01       	movw	r18, r14
    5370:	86 01       	movw	r16, r12
    5372:	0e 94 fd 20 	call	0x41fa	; 0x41fa <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    5376:	c7 01       	movw	r24, r14
    5378:	b6 01       	movw	r22, r12
    537a:	41 e0       	ldi	r20, 0x01	; 1
    537c:	0f ef       	ldi	r16, 0xFF	; 255
    537e:	1f ef       	ldi	r17, 0xFF	; 255
    5380:	98 01       	movw	r18, r16
    5382:	0e 94 fd 20 	call	0x41fa	; 0x41fa <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    5386:	c1 14       	cp	r12, r1
    5388:	d1 04       	cpc	r13, r1
    538a:	e1 04       	cpc	r14, r1
    538c:	f1 04       	cpc	r15, r1
    538e:	09 f0       	breq	.+2      	; 0x5392 <writeFile+0x556>
    5390:	39 cf       	rjmp	.-398    	; 0x5204 <writeFile+0x3c8>
	   return 4;
    5392:	84 e0       	ldi	r24, 0x04	; 4
    5394:	0b c0       	rjmp	.+22     	; 0x53ac <writeFile+0x570>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    5396:	81 e0       	ldi	r24, 0x01	; 1
    5398:	09 c0       	rjmp	.+18     	; 0x53ac <writeFile+0x570>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    539a:	82 e0       	ldi	r24, 0x02	; 2
    539c:	07 c0       	rjmp	.+14     	; 0x53ac <writeFile+0x570>
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
		if(cluster == 0){
		  //No free cluster!
		  return 2;
    539e:	82 e0       	ldi	r24, 0x02	; 2
    53a0:	05 c0       	rjmp	.+10     	; 0x53ac <writeFile+0x570>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    53a2:	80 e0       	ldi	r24, 0x00	; 0
    53a4:	03 c0       	rjmp	.+6      	; 0x53ac <writeFile+0x570>
    53a6:	80 e0       	ldi	r24, 0x00	; 0
    53a8:	01 c0       	rjmp	.+2      	; 0x53ac <writeFile+0x570>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    53aa:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    53ac:	60 96       	adiw	r28, 0x10	; 16
    53ae:	cd bf       	out	0x3d, r28	; 61
    53b0:	de bf       	out	0x3e, r29	; 62
    53b2:	df 91       	pop	r29
    53b4:	cf 91       	pop	r28
    53b6:	1f 91       	pop	r17
    53b8:	0f 91       	pop	r16
    53ba:	ff 90       	pop	r15
    53bc:	ef 90       	pop	r14
    53be:	df 90       	pop	r13
    53c0:	cf 90       	pop	r12
    53c2:	bf 90       	pop	r11
    53c4:	af 90       	pop	r10
    53c6:	9f 90       	pop	r9
    53c8:	8f 90       	pop	r8
    53ca:	7f 90       	pop	r7
    53cc:	6f 90       	pop	r6
    53ce:	5f 90       	pop	r5
    53d0:	4f 90       	pop	r4
    53d2:	3f 90       	pop	r3
    53d4:	2f 90       	pop	r2
    53d6:	08 95       	ret

000053d8 <SD_command>:
// 	data = SPIC.DATA; //read SPI data register to reset status flag
// 	return data;
// }

//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    53d8:	8f 92       	push	r8
    53da:	9f 92       	push	r9
    53dc:	af 92       	push	r10
    53de:	bf 92       	push	r11
    53e0:	cf 92       	push	r12
    53e2:	df 92       	push	r13
    53e4:	ef 92       	push	r14
    53e6:	ff 92       	push	r15
    53e8:	0f 93       	push	r16
    53ea:	1f 93       	push	r17
    53ec:	cf 93       	push	r28
    53ee:	df 93       	push	r29
    53f0:	84 2e       	mov	r8, r20
    53f2:	a5 2e       	mov	r10, r21
    53f4:	c6 2e       	mov	r12, r22
    53f6:	c7 2f       	mov	r28, r23
    53f8:	d2 2f       	mov	r29, r18
    53fa:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    53fc:	80 64       	ori	r24, 0x40	; 64
    53fe:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    5402:	8c 2f       	mov	r24, r28
    5404:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    5408:	8c 2d       	mov	r24, r12
    540a:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    540e:	8a 2d       	mov	r24, r10
    5410:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    5414:	88 2d       	mov	r24, r8
    5416:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
	SPI_write(crc);
    541a:	8d 2f       	mov	r24, r29
    541c:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
	
	for(int i=0; i<read; i++){
    5420:	10 16       	cp	r1, r16
    5422:	11 06       	cpc	r1, r17
    5424:	64 f5       	brge	.+88     	; 0x547e <SD_command+0xa6>
    5426:	00 e0       	ldi	r16, 0x00	; 0
    5428:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    542a:	0f 2e       	mov	r0, r31
    542c:	fd e0       	ldi	r31, 0x0D	; 13
    542e:	cf 2e       	mov	r12, r31
    5430:	dd 24       	eor	r13, r13
    5432:	f0 2d       	mov	r31, r0
    5434:	0f 2e       	mov	r0, r31
    5436:	f9 e3       	ldi	r31, 0x39	; 57
    5438:	af 2e       	mov	r10, r31
    543a:	fe e3       	ldi	r31, 0x3E	; 62
    543c:	bf 2e       	mov	r11, r31
    543e:	f0 2d       	mov	r31, r0
    5440:	c8 01       	movw	r24, r16
    5442:	b6 01       	movw	r22, r12
    5444:	0e 94 a1 39 	call	0x7342	; 0x7342 <__divmodhi4>
    5448:	ec 01       	movw	r28, r24
    544a:	8f ef       	ldi	r24, 0xFF	; 255
    544c:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5450:	f5 01       	movw	r30, r10
    5452:	ec 0f       	add	r30, r28
    5454:	fd 1f       	adc	r31, r29
    5456:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    5458:	80 81       	ld	r24, Z
    545a:	8f 3f       	cpi	r24, 0xFF	; 255
    545c:	49 f0       	breq	.+18     	; 0x5470 <SD_command+0x98>
			Buffer[1] = Buffer[i%13];
    545e:	fe 01       	movw	r30, r28
    5460:	e7 5c       	subi	r30, 0xC7	; 199
    5462:	f1 4c       	sbci	r31, 0xC1	; 193
    5464:	80 81       	ld	r24, Z
    5466:	80 93 3a 3e 	sts	0x3E3A, r24
			return Buffer[1];
    546a:	80 91 3a 3e 	lds	r24, 0x3E3A
    546e:	08 c0       	rjmp	.+16     	; 0x5480 <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    5470:	0f 5f       	subi	r16, 0xFF	; 255
    5472:	1f 4f       	sbci	r17, 0xFF	; 255
    5474:	0e 15       	cp	r16, r14
    5476:	1f 05       	cpc	r17, r15
    5478:	19 f7       	brne	.-58     	; 0x5440 <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    547a:	8f ef       	ldi	r24, 0xFF	; 255
    547c:	01 c0       	rjmp	.+2      	; 0x5480 <SD_command+0xa8>
    547e:	8f ef       	ldi	r24, 0xFF	; 255
}
    5480:	df 91       	pop	r29
    5482:	cf 91       	pop	r28
    5484:	1f 91       	pop	r17
    5486:	0f 91       	pop	r16
    5488:	ff 90       	pop	r15
    548a:	ef 90       	pop	r14
    548c:	df 90       	pop	r13
    548e:	cf 90       	pop	r12
    5490:	bf 90       	pop	r11
    5492:	af 90       	pop	r10
    5494:	9f 90       	pop	r9
    5496:	8f 90       	pop	r8
    5498:	08 95       	ret

0000549a <SD_init>:
# include "SD_Card.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    549a:	ff 92       	push	r15
    549c:	0f 93       	push	r16
    549e:	1f 93       	push	r17
    54a0:	cf 93       	push	r28
    54a2:	df 93       	push	r29
	
	ADCPower(TRUE);				//power up portEX
    54a4:	81 e0       	ldi	r24, 0x01	; 1
    54a6:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    54aa:	81 e0       	ldi	r24, 0x01	; 1
    54ac:	0e 94 87 03 	call	0x70e	; 0x70e <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    54b0:	8f ef       	ldi	r24, 0xFF	; 255
    54b2:	93 ec       	ldi	r25, 0xC3	; 195
    54b4:	a9 e0       	ldi	r26, 0x09	; 9
    54b6:	81 50       	subi	r24, 0x01	; 1
    54b8:	90 40       	sbci	r25, 0x00	; 0
    54ba:	a0 40       	sbci	r26, 0x00	; 0
    54bc:	e1 f7       	brne	.-8      	; 0x54b6 <SD_init+0x1c>
    54be:	00 c0       	rjmp	.+0      	; 0x54c0 <SD_init+0x26>
    54c0:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
	
	PortEx_DIRSET(BIT3_bm, PS_BANKB); //SD card CS
    54c2:	88 e0       	ldi	r24, 0x08	; 8
    54c4:	60 e0       	ldi	r22, 0x00	; 0
    54c6:	0e 94 8a 05 	call	0xb14	; 0xb14 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB); //pull SD cs high
    54ca:	88 e0       	ldi	r24, 0x08	; 8
    54cc:	60 e0       	ldi	r22, 0x00	; 0
    54ce:	0e 94 dd 04 	call	0x9ba	; 0x9ba <PortEx_OUTSET>
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
    54d2:	80 e0       	ldi	r24, 0x00	; 0
    54d4:	63 e0       	ldi	r22, 0x03	; 3
    54d6:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <SPIInit2>
	SPICS(TRUE);
    54da:	81 e0       	ldi	r24, 0x01	; 1
    54dc:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
    54e0:	8a e0       	ldi	r24, 0x0A	; 10
    54e2:	90 e0       	ldi	r25, 0x00	; 0
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    54e4:	e0 ec       	ldi	r30, 0xC0	; 192
    54e6:	f8 e0       	ldi	r31, 0x08	; 8
    54e8:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
    54ea:	a5 e4       	ldi	r26, 0x45	; 69
    54ec:	be e3       	ldi	r27, 0x3E	; 62
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    54ee:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    54f0:	22 81       	ldd	r18, Z+2	; 0x02
    54f2:	22 23       	and	r18, r18
    54f4:	ec f7       	brge	.-6      	; 0x54f0 <SD_init+0x56>
		Buffer[12] = SPIC.DATA;
    54f6:	23 81       	ldd	r18, Z+3	; 0x03
    54f8:	2c 93       	st	X, r18
    54fa:	01 97       	sbiw	r24, 0x01	; 1
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
    54fc:	c1 f7       	brne	.-16     	; 0x54ee <SD_init+0x54>
		SPIC.DATA = SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
	}
	
	SPICS(FALSE);
    54fe:	80 e0       	ldi	r24, 0x00	; 0
    5500:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	SPIDisable();
    5504:	0e 94 19 04 	call	0x832	; 0x832 <SPIDisable>
	
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5508:	88 e0       	ldi	r24, 0x08	; 8
    550a:	60 e0       	ldi	r22, 0x00	; 0
    550c:	0e 94 86 04 	call	0x90c	; 0x90c <PortEx_OUTCLR>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5510:	80 e0       	ldi	r24, 0x00	; 0
    5512:	63 e0       	ldi	r22, 0x03	; 3
    5514:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <SPIInit2>
	SPICS(TRUE);
    5518:	81 e0       	ldi	r24, 0x01	; 1
    551a:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    551e:	cb e0       	ldi	r28, 0x0B	; 11
    5520:	d0 e0       	ldi	r29, 0x00	; 0
    5522:	02 c0       	rjmp	.+4      	; 0x5528 <SD_init+0x8e>
    5524:	21 97       	sbiw	r28, 0x01	; 1
		//try command 10 times before timing out
		if (i >= 10) {
    5526:	69 f0       	breq	.+26     	; 0x5542 <SD_init+0xa8>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    5528:	80 e0       	ldi	r24, 0x00	; 0
    552a:	40 e0       	ldi	r20, 0x00	; 0
    552c:	50 e0       	ldi	r21, 0x00	; 0
    552e:	ba 01       	movw	r22, r20
    5530:	25 e9       	ldi	r18, 0x95	; 149
    5532:	08 e0       	ldi	r16, 0x08	; 8
    5534:	10 e0       	ldi	r17, 0x00	; 0
    5536:	0e 94 ec 29 	call	0x53d8	; 0x53d8 <SD_command>
    553a:	81 30       	cpi	r24, 0x01	; 1
    553c:	99 f7       	brne	.-26     	; 0x5524 <SD_init+0x8a>
uint8_t SD_init(void){
	
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    553e:	ff 24       	eor	r15, r15
    5540:	02 c0       	rjmp	.+4      	; 0x5546 <SD_init+0xac>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
		//try command 10 times before timing out
		if (i >= 10) {
			//there was no response to the first command
			errorCode = 1;
    5542:	ff 24       	eor	r15, r15
    5544:	f3 94       	inc	r15
    5546:	8f ef       	ldi	r24, 0xFF	; 255
    5548:	93 ec       	ldi	r25, 0xC3	; 195
    554a:	a9 e0       	ldi	r26, 0x09	; 9
    554c:	81 50       	subi	r24, 0x01	; 1
    554e:	90 40       	sbci	r25, 0x00	; 0
    5550:	a0 40       	sbci	r26, 0x00	; 0
    5552:	e1 f7       	brne	.-8      	; 0x554c <SD_init+0xb2>
    5554:	00 c0       	rjmp	.+0      	; 0x5556 <SD_init+0xbc>
    5556:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    5558:	cb e0       	ldi	r28, 0x0B	; 11
    555a:	d0 e0       	ldi	r29, 0x00	; 0
    555c:	02 c0       	rjmp	.+4      	; 0x5562 <SD_init+0xc8>
    555e:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    5560:	69 f0       	breq	.+26     	; 0x557c <SD_init+0xe2>
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    5562:	88 e0       	ldi	r24, 0x08	; 8
    5564:	4a ea       	ldi	r20, 0xAA	; 170
    5566:	51 e0       	ldi	r21, 0x01	; 1
    5568:	60 e0       	ldi	r22, 0x00	; 0
    556a:	70 e0       	ldi	r23, 0x00	; 0
    556c:	27 e8       	ldi	r18, 0x87	; 135
    556e:	08 e0       	ldi	r16, 0x08	; 8
    5570:	10 e0       	ldi	r17, 0x00	; 0
    5572:	0e 94 ec 29 	call	0x53d8	; 0x53d8 <SD_command>
    5576:	81 30       	cpi	r24, 0x01	; 1
    5578:	91 f7       	brne	.-28     	; 0x555e <SD_init+0xc4>
    557a:	02 c0       	rjmp	.+4      	; 0x5580 <SD_init+0xe6>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    557c:	ff 24       	eor	r15, r15
    557e:	f3 94       	inc	r15
    5580:	c2 e0       	ldi	r28, 0x02	; 2
    5582:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}
	}
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    5584:	09 e3       	ldi	r16, 0x39	; 57
    5586:	1e e3       	ldi	r17, 0x3E	; 62
    5588:	8f ef       	ldi	r24, 0xFF	; 255
    558a:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    558e:	f8 01       	movw	r30, r16
    5590:	ec 0f       	add	r30, r28
    5592:	fd 1f       	adc	r31, r29
    5594:	80 83       	st	Z, r24
    5596:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}
	for(int i=0;i<4;i++){
    5598:	c6 30       	cpi	r28, 0x06	; 6
    559a:	d1 05       	cpc	r29, r1
    559c:	a9 f7       	brne	.-22     	; 0x5588 <SD_init+0xee>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	//check that the response is the same as the argument sent in
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){
    559e:	80 91 3d 3e 	lds	r24, 0x3E3D
    55a2:	81 30       	cpi	r24, 0x01	; 1
    55a4:	29 f4       	brne	.+10     	; 0x55b0 <SD_init+0x116>
    55a6:	80 91 3e 3e 	lds	r24, 0x3E3E
    55aa:	8a 3a       	cpi	r24, 0xAA	; 170
    55ac:	21 f4       	brne	.+8      	; 0x55b6 <SD_init+0x11c>
    55ae:	05 c0       	rjmp	.+10     	; 0x55ba <SD_init+0x120>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    55b0:	ff 24       	eor	r15, r15
    55b2:	f3 94       	inc	r15
    55b4:	02 c0       	rjmp	.+4      	; 0x55ba <SD_init+0x120>
    55b6:	ff 24       	eor	r15, r15
    55b8:	f3 94       	inc	r15
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
    55ba:	ca e3       	ldi	r28, 0x3A	; 58
    55bc:	de e3       	ldi	r29, 0x3E	; 62
		errorCode = 1;
	}
	//send second initialization command
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
    55be:	87 e3       	ldi	r24, 0x37	; 55
    55c0:	40 e0       	ldi	r20, 0x00	; 0
    55c2:	50 e0       	ldi	r21, 0x00	; 0
    55c4:	ba 01       	movw	r22, r20
    55c6:	2f ef       	ldi	r18, 0xFF	; 255
    55c8:	08 e0       	ldi	r16, 0x08	; 8
    55ca:	10 e0       	ldi	r17, 0x00	; 0
    55cc:	0e 94 ec 29 	call	0x53d8	; 0x53d8 <SD_command>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
    55d0:	81 e0       	ldi	r24, 0x01	; 1
    55d2:	40 e0       	ldi	r20, 0x00	; 0
    55d4:	50 e0       	ldi	r21, 0x00	; 0
    55d6:	60 e0       	ldi	r22, 0x00	; 0
    55d8:	70 e4       	ldi	r23, 0x40	; 64
    55da:	2f ef       	ldi	r18, 0xFF	; 255
    55dc:	0e 94 ec 29 	call	0x53d8	; 0x53d8 <SD_command>
	} while(Buffer[1]!= 0x00);	
    55e0:	88 81       	ld	r24, Y
    55e2:	88 23       	and	r24, r24
    55e4:	61 f7       	brne	.-40     	; 0x55be <SD_init+0x124>
    55e6:	cb e0       	ldi	r28, 0x0B	; 11
    55e8:	d0 e0       	ldi	r29, 0x00	; 0
    55ea:	02 c0       	rjmp	.+4      	; 0x55f0 <SD_init+0x156>
    55ec:	21 97       	sbiw	r28, 0x01	; 1
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
		if (i >= 10) {
    55ee:	61 f0       	breq	.+24     	; 0x5608 <SD_init+0x16e>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
    55f0:	8a e3       	ldi	r24, 0x3A	; 58
    55f2:	40 e0       	ldi	r20, 0x00	; 0
    55f4:	50 e0       	ldi	r21, 0x00	; 0
    55f6:	ba 01       	movw	r22, r20
    55f8:	2f ef       	ldi	r18, 0xFF	; 255
    55fa:	08 e0       	ldi	r16, 0x08	; 8
    55fc:	10 e0       	ldi	r17, 0x00	; 0
    55fe:	0e 94 ec 29 	call	0x53d8	; 0x53d8 <SD_command>
    5602:	88 23       	and	r24, r24
    5604:	99 f7       	brne	.-26     	; 0x55ec <SD_init+0x152>
    5606:	02 c0       	rjmp	.+4      	; 0x560c <SD_init+0x172>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    5608:	ff 24       	eor	r15, r15
    560a:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    560c:	c0 e0       	ldi	r28, 0x00	; 0
    560e:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    5610:	09 e3       	ldi	r16, 0x39	; 57
    5612:	1e e3       	ldi	r17, 0x3E	; 62
    5614:	8f ef       	ldi	r24, 0xFF	; 255
    5616:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    561a:	f8 01       	movw	r30, r16
    561c:	ec 0f       	add	r30, r28
    561e:	fd 1f       	adc	r31, r29
    5620:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5622:	21 96       	adiw	r28, 0x01	; 1
    5624:	c4 30       	cpi	r28, 0x04	; 4
    5626:	d1 05       	cpc	r29, r1
    5628:	a9 f7       	brne	.-22     	; 0x5614 <SD_init+0x17a>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    562a:	80 91 39 3e 	lds	r24, 0x3E39
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    562e:	80 e0       	ldi	r24, 0x00	; 0
    5630:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	SPIDisable();
    5634:	0e 94 19 04 	call	0x832	; 0x832 <SPIDisable>
	//pull SD cs high
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    5638:	88 e0       	ldi	r24, 0x08	; 8
    563a:	60 e0       	ldi	r22, 0x00	; 0
    563c:	0e 94 dd 04 	call	0x9ba	; 0x9ba <PortEx_OUTSET>
	
	return errorCode;					
}
    5640:	8f 2d       	mov	r24, r15
    5642:	df 91       	pop	r29
    5644:	cf 91       	pop	r28
    5646:	1f 91       	pop	r17
    5648:	0f 91       	pop	r16
    564a:	ff 90       	pop	r15
    564c:	08 95       	ret

0000564e <SD_write_block>:
	}
	return SDHC_DUMMY_BYTE;
}

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    564e:	6f 92       	push	r6
    5650:	7f 92       	push	r7
    5652:	8f 92       	push	r8
    5654:	9f 92       	push	r9
    5656:	af 92       	push	r10
    5658:	bf 92       	push	r11
    565a:	cf 92       	push	r12
    565c:	df 92       	push	r13
    565e:	ef 92       	push	r14
    5660:	ff 92       	push	r15
    5662:	0f 93       	push	r16
    5664:	1f 93       	push	r17
    5666:	cf 93       	push	r28
    5668:	df 93       	push	r29
    566a:	4b 01       	movw	r8, r22
    566c:	5c 01       	movw	r10, r24
    566e:	74 2e       	mov	r7, r20
    5670:	65 2e       	mov	r6, r21
    5672:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5674:	88 e0       	ldi	r24, 0x08	; 8
    5676:	60 e0       	ldi	r22, 0x00	; 0
    5678:	0e 94 86 04 	call	0x90c	; 0x90c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    567c:	80 e0       	ldi	r24, 0x00	; 0
    567e:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPIInit>
	SPICS(TRUE);
    5682:	81 e0       	ldi	r24, 0x01	; 1
    5684:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    5688:	80 e0       	ldi	r24, 0x00	; 0
    568a:	92 e0       	ldi	r25, 0x02	; 2
    568c:	7c 01       	movw	r14, r24
    568e:	ec 18       	sub	r14, r12
    5690:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5692:	80 e0       	ldi	r24, 0x00	; 0
    5694:	e8 16       	cp	r14, r24
    5696:	82 e0       	ldi	r24, 0x02	; 2
    5698:	f8 06       	cpc	r15, r24
    569a:	11 f4       	brne	.+4      	; 0x56a0 <SD_write_block+0x52>
    569c:	ee 24       	eor	r14, r14
    569e:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    56a0:	cb e0       	ldi	r28, 0x0B	; 11
    56a2:	d0 e0       	ldi	r29, 0x00	; 0
    56a4:	03 c0       	rjmp	.+6      	; 0x56ac <SD_write_block+0x5e>
    56a6:	21 97       	sbiw	r28, 0x01	; 1
	if (i >= 10) {
    56a8:	09 f4       	brne	.+2      	; 0x56ac <SD_write_block+0x5e>
    56aa:	ff cf       	rjmp	.-2      	; 0x56aa <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    56ac:	88 e1       	ldi	r24, 0x18	; 24
    56ae:	b5 01       	movw	r22, r10
    56b0:	a4 01       	movw	r20, r8
    56b2:	2f ef       	ldi	r18, 0xFF	; 255
    56b4:	08 e0       	ldi	r16, 0x08	; 8
    56b6:	10 e0       	ldi	r17, 0x00	; 0
    56b8:	0e 94 ec 29 	call	0x53d8	; 0x53d8 <SD_command>
    56bc:	88 23       	and	r24, r24
    56be:	99 f7       	brne	.-26     	; 0x56a6 <SD_write_block+0x58>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    56c0:	8f ef       	ldi	r24, 0xFF	; 255
    56c2:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    56c6:	80 93 39 3e 	sts	0x3E39, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    56ca:	8e ef       	ldi	r24, 0xFE	; 254
    56cc:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    56d0:	1c 14       	cp	r1, r12
    56d2:	1d 04       	cpc	r1, r13
    56d4:	bc f4       	brge	.+46     	; 0x5704 <SD_write_block+0xb6>
    56d6:	87 2c       	mov	r8, r7
    56d8:	96 2c       	mov	r9, r6
    56da:	00 e0       	ldi	r16, 0x00	; 0
    56dc:	10 e0       	ldi	r17, 0x00	; 0
Buffer[i%13] = SPI_write(data[i]);
    56de:	c8 01       	movw	r24, r16
    56e0:	6d e0       	ldi	r22, 0x0D	; 13
    56e2:	70 e0       	ldi	r23, 0x00	; 0
    56e4:	0e 94 a1 39 	call	0x7342	; 0x7342 <__divmodhi4>
    56e8:	ec 01       	movw	r28, r24
    56ea:	f4 01       	movw	r30, r8
    56ec:	81 91       	ld	r24, Z+
    56ee:	4f 01       	movw	r8, r30
    56f0:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    56f4:	c7 5c       	subi	r28, 0xC7	; 199
    56f6:	d1 4c       	sbci	r29, 0xC1	; 193
    56f8:	88 83       	st	Y, r24
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    56fa:	0f 5f       	subi	r16, 0xFF	; 255
    56fc:	1f 4f       	sbci	r17, 0xFF	; 255
    56fe:	0c 15       	cp	r16, r12
    5700:	1d 05       	cpc	r17, r13
    5702:	69 f7       	brne	.-38     	; 0x56de <SD_write_block+0x90>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5704:	1e 14       	cp	r1, r14
    5706:	1f 04       	cpc	r1, r15
    5708:	ec f4       	brge	.+58     	; 0x5744 <SD_write_block+0xf6>
    570a:	00 e0       	ldi	r16, 0x00	; 0
    570c:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    570e:	0f 2e       	mov	r0, r31
    5710:	fd e0       	ldi	r31, 0x0D	; 13
    5712:	cf 2e       	mov	r12, r31
    5714:	dd 24       	eor	r13, r13
    5716:	f0 2d       	mov	r31, r0
    5718:	0f 2e       	mov	r0, r31
    571a:	f9 e3       	ldi	r31, 0x39	; 57
    571c:	8f 2e       	mov	r8, r31
    571e:	fe e3       	ldi	r31, 0x3E	; 62
    5720:	9f 2e       	mov	r9, r31
    5722:	f0 2d       	mov	r31, r0
    5724:	c8 01       	movw	r24, r16
    5726:	b6 01       	movw	r22, r12
    5728:	0e 94 a1 39 	call	0x7342	; 0x7342 <__divmodhi4>
    572c:	ec 01       	movw	r28, r24
    572e:	80 e0       	ldi	r24, 0x00	; 0
    5730:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5734:	c8 0d       	add	r28, r8
    5736:	d9 1d       	adc	r29, r9
    5738:	88 83       	st	Y, r24
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    573a:	0f 5f       	subi	r16, 0xFF	; 255
    573c:	1f 4f       	sbci	r17, 0xFF	; 255
    573e:	0e 15       	cp	r16, r14
    5740:	1f 05       	cpc	r17, r15
    5742:	81 f7       	brne	.-32     	; 0x5724 <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    5744:	8f ef       	ldi	r24, 0xFF	; 255
    5746:	80 93 39 3e 	sts	0x3E39, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    574a:	c0 e0       	ldi	r28, 0x00	; 0
    574c:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    574e:	09 e3       	ldi	r16, 0x39	; 57
    5750:	1e e3       	ldi	r17, 0x3E	; 62
    5752:	8f ef       	ldi	r24, 0xFF	; 255
    5754:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5758:	f8 01       	movw	r30, r16
    575a:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    575c:	21 96       	adiw	r28, 0x01	; 1
    575e:	c2 30       	cpi	r28, 0x02	; 2
    5760:	d1 05       	cpc	r29, r1
    5762:	bc f3       	brlt	.-18     	; 0x5752 <SD_write_block+0x104>
    5764:	80 81       	ld	r24, Z
    5766:	8f 3f       	cpi	r24, 0xFF	; 255
    5768:	a1 f3       	breq	.-24     	; 0x5752 <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    576a:	80 91 39 3e 	lds	r24, 0x3E39
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    576e:	80 91 39 3e 	lds	r24, 0x3E39
    5772:	8f 3f       	cpi	r24, 0xFF	; 255
    5774:	49 f0       	breq	.+18     	; 0x5788 <SD_write_block+0x13a>
    5776:	c9 e3       	ldi	r28, 0x39	; 57
    5778:	de e3       	ldi	r29, 0x3E	; 62
    577a:	8f ef       	ldi	r24, 0xFF	; 255
    577c:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5780:	88 83       	st	Y, r24
    5782:	88 81       	ld	r24, Y
    5784:	8f 3f       	cpi	r24, 0xFF	; 255
    5786:	c9 f7       	brne	.-14     	; 0x577a <SD_write_block+0x12c>
	SPICS(FALSE);
    5788:	80 e0       	ldi	r24, 0x00	; 0
    578a:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	SPIDisable();
    578e:	0e 94 19 04 	call	0x832	; 0x832 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    5792:	88 e0       	ldi	r24, 0x08	; 8
    5794:	60 e0       	ldi	r22, 0x00	; 0
    5796:	0e 94 dd 04 	call	0x9ba	; 0x9ba <PortEx_OUTSET>
}
    579a:	df 91       	pop	r29
    579c:	cf 91       	pop	r28
    579e:	1f 91       	pop	r17
    57a0:	0f 91       	pop	r16
    57a2:	ff 90       	pop	r15
    57a4:	ef 90       	pop	r14
    57a6:	df 90       	pop	r13
    57a8:	cf 90       	pop	r12
    57aa:	bf 90       	pop	r11
    57ac:	af 90       	pop	r10
    57ae:	9f 90       	pop	r9
    57b0:	8f 90       	pop	r8
    57b2:	7f 90       	pop	r7
    57b4:	6f 90       	pop	r6
    57b6:	08 95       	ret

000057b8 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    57b8:	af 92       	push	r10
    57ba:	bf 92       	push	r11
    57bc:	cf 92       	push	r12
    57be:	df 92       	push	r13
    57c0:	ef 92       	push	r14
    57c2:	ff 92       	push	r15
    57c4:	0f 93       	push	r16
    57c6:	1f 93       	push	r17
    57c8:	cf 93       	push	r28
    57ca:	df 93       	push	r29
    57cc:	6b 01       	movw	r12, r22
    57ce:	7c 01       	movw	r14, r24
    57d0:	b4 2e       	mov	r11, r20
    57d2:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    57d4:	88 e0       	ldi	r24, 0x08	; 8
    57d6:	60 e0       	ldi	r22, 0x00	; 0
    57d8:	0e 94 86 04 	call	0x90c	; 0x90c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    57dc:	80 e0       	ldi	r24, 0x00	; 0
    57de:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPIInit>
	SPICS(TRUE);
    57e2:	81 e0       	ldi	r24, 0x01	; 1
    57e4:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    57e8:	cb e0       	ldi	r28, 0x0B	; 11
    57ea:	d0 e0       	ldi	r29, 0x00	; 0
    57ec:	03 c0       	rjmp	.+6      	; 0x57f4 <SD_read_block+0x3c>
    57ee:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    57f0:	09 f4       	brne	.+2      	; 0x57f4 <SD_read_block+0x3c>
    57f2:	ff cf       	rjmp	.-2      	; 0x57f2 <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    57f4:	81 e1       	ldi	r24, 0x11	; 17
    57f6:	b7 01       	movw	r22, r14
    57f8:	a6 01       	movw	r20, r12
    57fa:	2f ef       	ldi	r18, 0xFF	; 255
    57fc:	08 e0       	ldi	r16, 0x08	; 8
    57fe:	10 e0       	ldi	r17, 0x00	; 0
    5800:	0e 94 ec 29 	call	0x53d8	; 0x53d8 <SD_command>
    5804:	88 23       	and	r24, r24
    5806:	99 f7       	brne	.-26     	; 0x57ee <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    5808:	80 91 39 3e 	lds	r24, 0x3E39
    580c:	8e 3f       	cpi	r24, 0xFE	; 254
    580e:	49 f0       	breq	.+18     	; 0x5822 <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    5810:	c9 e3       	ldi	r28, 0x39	; 57
    5812:	de e3       	ldi	r29, 0x3E	; 62
    5814:	8f ef       	ldi	r24, 0xFF	; 255
    5816:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    581a:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    581c:	88 81       	ld	r24, Y
    581e:	8e 3f       	cpi	r24, 0xFE	; 254
    5820:	c9 f7       	brne	.-14     	; 0x5814 <SD_read_block+0x5c>
    5822:	0b 2d       	mov	r16, r11
    5824:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5826:	c0 e0       	ldi	r28, 0x00	; 0
    5828:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    582a:	8f ef       	ldi	r24, 0xFF	; 255
    582c:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5830:	f8 01       	movw	r30, r16
    5832:	81 93       	st	Z+, r24
    5834:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5836:	21 96       	adiw	r28, 0x01	; 1
    5838:	f2 e0       	ldi	r31, 0x02	; 2
    583a:	c0 30       	cpi	r28, 0x00	; 0
    583c:	df 07       	cpc	r29, r31
    583e:	a9 f7       	brne	.-22     	; 0x582a <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    5840:	10 92 45 3e 	sts	0x3E45, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    5844:	80 91 45 3e 	lds	r24, 0x3E45
    5848:	8f 3f       	cpi	r24, 0xFF	; 255
    584a:	49 f0       	breq	.+18     	; 0x585e <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    584c:	c5 e4       	ldi	r28, 0x45	; 69
    584e:	de e3       	ldi	r29, 0x3E	; 62
    5850:	8f ef       	ldi	r24, 0xFF	; 255
    5852:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5856:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    5858:	88 81       	ld	r24, Y
    585a:	8f 3f       	cpi	r24, 0xFF	; 255
    585c:	c9 f7       	brne	.-14     	; 0x5850 <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    585e:	80 e0       	ldi	r24, 0x00	; 0
    5860:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	SPIDisable();
    5864:	0e 94 19 04 	call	0x832	; 0x832 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5868:	88 e0       	ldi	r24, 0x08	; 8
    586a:	60 e0       	ldi	r22, 0x00	; 0
    586c:	0e 94 dd 04 	call	0x9ba	; 0x9ba <PortEx_OUTSET>
}
    5870:	df 91       	pop	r29
    5872:	cf 91       	pop	r28
    5874:	1f 91       	pop	r17
    5876:	0f 91       	pop	r16
    5878:	ff 90       	pop	r15
    587a:	ef 90       	pop	r14
    587c:	df 90       	pop	r13
    587e:	cf 90       	pop	r12
    5880:	bf 90       	pop	r11
    5882:	af 90       	pop	r10
    5884:	08 95       	ret

00005886 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5886:	2f 92       	push	r2
    5888:	3f 92       	push	r3
    588a:	4f 92       	push	r4
    588c:	5f 92       	push	r5
    588e:	6f 92       	push	r6
    5890:	7f 92       	push	r7
    5892:	8f 92       	push	r8
    5894:	9f 92       	push	r9
    5896:	af 92       	push	r10
    5898:	bf 92       	push	r11
    589a:	cf 92       	push	r12
    589c:	df 92       	push	r13
    589e:	ef 92       	push	r14
    58a0:	ff 92       	push	r15
    58a2:	0f 93       	push	r16
    58a4:	1f 93       	push	r17
    58a6:	cf 93       	push	r28
    58a8:	df 93       	push	r29
    58aa:	cd b7       	in	r28, 0x3d	; 61
    58ac:	de b7       	in	r29, 0x3e	; 62
    58ae:	2a 97       	sbiw	r28, 0x0a	; 10
    58b0:	cd bf       	out	0x3d, r28	; 61
    58b2:	de bf       	out	0x3e, r29	; 62
    58b4:	6b 01       	movw	r12, r22
    58b6:	7c 01       	movw	r14, r24
    58b8:	4f 83       	std	Y+7, r20	; 0x07
    58ba:	58 87       	std	Y+8, r21	; 0x08
    58bc:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    58be:	88 e0       	ldi	r24, 0x08	; 8
    58c0:	60 e0       	ldi	r22, 0x00	; 0
    58c2:	0e 94 86 04 	call	0x90c	; 0x90c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    58c6:	80 e0       	ldi	r24, 0x00	; 0
    58c8:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPIInit>
	SPICS(TRUE);
    58cc:	81 e0       	ldi	r24, 0x01	; 1
    58ce:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    58d2:	c8 01       	movw	r24, r16
    58d4:	11 23       	and	r17, r17
    58d6:	14 f4       	brge	.+4      	; 0x58dc <SD_write_multiple_blocks+0x56>
    58d8:	81 50       	subi	r24, 0x01	; 1
    58da:	9e 4f       	sbci	r25, 0xFE	; 254
    58dc:	9c 01       	movw	r18, r24
    58de:	23 2f       	mov	r18, r19
    58e0:	33 0f       	add	r19, r19
    58e2:	33 0b       	sbc	r19, r19
    58e4:	25 95       	asr	r18
    58e6:	2b 83       	std	Y+3, r18	; 0x03
    58e8:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    58ea:	20 e0       	ldi	r18, 0x00	; 0
    58ec:	32 e0       	ldi	r19, 0x02	; 2
    58ee:	c8 01       	movw	r24, r16
    58f0:	b9 01       	movw	r22, r18
    58f2:	0e 94 a1 39 	call	0x7342	; 0x7342 <__divmodhi4>
    58f6:	29 01       	movw	r4, r18
    58f8:	48 1a       	sub	r4, r24
    58fa:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    58fc:	30 e0       	ldi	r19, 0x00	; 0
    58fe:	43 16       	cp	r4, r19
    5900:	32 e0       	ldi	r19, 0x02	; 2
    5902:	53 06       	cpc	r5, r19
    5904:	31 f0       	breq	.+12     	; 0x5912 <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    5906:	8b 81       	ldd	r24, Y+3	; 0x03
    5908:	9c 81       	ldd	r25, Y+4	; 0x04
    590a:	01 96       	adiw	r24, 0x01	; 1
    590c:	8b 83       	std	Y+3, r24	; 0x03
    590e:	9c 83       	std	Y+4, r25	; 0x04
    5910:	02 c0       	rjmp	.+4      	; 0x5916 <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5912:	44 24       	eor	r4, r4
    5914:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    5916:	89 e1       	ldi	r24, 0x19	; 25
    5918:	b7 01       	movw	r22, r14
    591a:	a6 01       	movw	r20, r12
    591c:	2f ef       	ldi	r18, 0xFF	; 255
    591e:	08 e0       	ldi	r16, 0x08	; 8
    5920:	10 e0       	ldi	r17, 0x00	; 0
    5922:	0e 94 ec 29 	call	0x53d8	; 0x53d8 <SD_command>
    5926:	88 23       	and	r24, r24
    5928:	b1 f7       	brne	.-20     	; 0x5916 <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    592a:	eb 81       	ldd	r30, Y+3	; 0x03
    592c:	fc 81       	ldd	r31, Y+4	; 0x04
    592e:	1e 16       	cp	r1, r30
    5930:	1f 06       	cpc	r1, r31
    5932:	0c f0       	brlt	.+2      	; 0x5936 <SD_write_multiple_blocks+0xb0>
    5934:	ac c0       	rjmp	.+344    	; 0x5a8e <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5936:	31 97       	sbiw	r30, 0x01	; 1
    5938:	ed 83       	std	Y+5, r30	; 0x05
    593a:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    593c:	9f 01       	movw	r18, r30
    593e:	32 2f       	mov	r19, r18
    5940:	22 27       	eor	r18, r18
    5942:	33 0f       	add	r19, r19
    5944:	8f 81       	ldd	r24, Y+7	; 0x07
    5946:	98 85       	ldd	r25, Y+8	; 0x08
    5948:	89 83       	std	Y+1, r24	; 0x01
    594a:	9a 83       	std	Y+2, r25	; 0x02
    594c:	66 24       	eor	r6, r6
    594e:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    5950:	0f 2e       	mov	r0, r31
    5952:	fa e3       	ldi	r31, 0x3A	; 58
    5954:	8f 2e       	mov	r8, r31
    5956:	fe e3       	ldi	r31, 0x3E	; 62
    5958:	9f 2e       	mov	r9, r31
    595a:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    595c:	0f 2e       	mov	r0, r31
    595e:	fc e0       	ldi	r31, 0x0C	; 12
    5960:	cf 2e       	mov	r12, r31
    5962:	dd 24       	eor	r13, r13
    5964:	f0 2d       	mov	r31, r0
    5966:	0f 2e       	mov	r0, r31
    5968:	f9 e3       	ldi	r31, 0x39	; 57
    596a:	af 2e       	mov	r10, r31
    596c:	fe e3       	ldi	r31, 0x3E	; 62
    596e:	bf 2e       	mov	r11, r31
    5970:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5972:	80 e0       	ldi	r24, 0x00	; 0
    5974:	92 e0       	ldi	r25, 0x02	; 2
    5976:	1c 01       	movw	r2, r24
    5978:	24 18       	sub	r2, r4
    597a:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    597c:	ef 81       	ldd	r30, Y+7	; 0x07
    597e:	f8 85       	ldd	r31, Y+8	; 0x08
    5980:	e2 0f       	add	r30, r18
    5982:	f3 1f       	adc	r31, r19
    5984:	ef 83       	std	Y+7, r30	; 0x07
    5986:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    5988:	8f ef       	ldi	r24, 0xFF	; 255
    598a:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    598e:	f4 01       	movw	r30, r8
    5990:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    5992:	8c ef       	ldi	r24, 0xFC	; 252
    5994:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5998:	f4 01       	movw	r30, r8
    599a:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    599c:	2d 81       	ldd	r18, Y+5	; 0x05
    599e:	3e 81       	ldd	r19, Y+6	; 0x06
    59a0:	26 15       	cp	r18, r6
    59a2:	37 05       	cpc	r19, r7
    59a4:	09 f0       	breq	.+2      	; 0x59a8 <SD_write_multiple_blocks+0x122>
    59a6:	41 c0       	rjmp	.+130    	; 0x5a2a <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    59a8:	12 14       	cp	r1, r2
    59aa:	13 04       	cpc	r1, r3
    59ac:	cc f4       	brge	.+50     	; 0x59e0 <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    59ae:	ef 80       	ldd	r14, Y+7	; 0x07
    59b0:	f8 84       	ldd	r15, Y+8	; 0x08
    59b2:	00 e0       	ldi	r16, 0x00	; 0
    59b4:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    59b6:	c8 01       	movw	r24, r16
    59b8:	b6 01       	movw	r22, r12
    59ba:	0e 94 a1 39 	call	0x7342	; 0x7342 <__divmodhi4>
    59be:	89 87       	std	Y+9, r24	; 0x09
    59c0:	9a 87       	std	Y+10, r25	; 0x0a
    59c2:	f7 01       	movw	r30, r14
    59c4:	81 91       	ld	r24, Z+
    59c6:	7f 01       	movw	r14, r30
    59c8:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    59cc:	e9 85       	ldd	r30, Y+9	; 0x09
    59ce:	fa 85       	ldd	r31, Y+10	; 0x0a
    59d0:	ea 0d       	add	r30, r10
    59d2:	fb 1d       	adc	r31, r11
    59d4:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    59d6:	0f 5f       	subi	r16, 0xFF	; 255
    59d8:	1f 4f       	sbci	r17, 0xFF	; 255
    59da:	02 15       	cp	r16, r2
    59dc:	13 05       	cpc	r17, r3
    59de:	59 f7       	brne	.-42     	; 0x59b6 <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    59e0:	14 14       	cp	r1, r4
    59e2:	15 04       	cpc	r1, r5
    59e4:	9c f4       	brge	.+38     	; 0x5a0c <SD_write_multiple_blocks+0x186>
    59e6:	00 e0       	ldi	r16, 0x00	; 0
    59e8:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    59ea:	c8 01       	movw	r24, r16
    59ec:	b6 01       	movw	r22, r12
    59ee:	0e 94 a1 39 	call	0x7342	; 0x7342 <__divmodhi4>
    59f2:	7c 01       	movw	r14, r24
    59f4:	80 e0       	ldi	r24, 0x00	; 0
    59f6:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    59fa:	f5 01       	movw	r30, r10
    59fc:	ee 0d       	add	r30, r14
    59fe:	ff 1d       	adc	r31, r15
    5a00:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5a02:	0f 5f       	subi	r16, 0xFF	; 255
    5a04:	1f 4f       	sbci	r17, 0xFF	; 255
    5a06:	04 15       	cp	r16, r4
    5a08:	15 05       	cpc	r17, r5
    5a0a:	79 f7       	brne	.-34     	; 0x59ea <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    5a0c:	8f ef       	ldi	r24, 0xFF	; 255
    5a0e:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5a12:	f4 01       	movw	r30, r8
    5a14:	80 83       	st	Z, r24
    5a16:	8f ef       	ldi	r24, 0xFF	; 255
    5a18:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5a1c:	f4 01       	movw	r30, r8
    5a1e:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    5a20:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5a22:	80 81       	ld	r24, Z
    5a24:	8f 3f       	cpi	r24, 0xFF	; 255
    5a26:	e1 f4       	brne	.+56     	; 0x5a60 <SD_write_multiple_blocks+0x1da>
    5a28:	23 c0       	rjmp	.+70     	; 0x5a70 <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5a2a:	e9 80       	ldd	r14, Y+1	; 0x01
    5a2c:	fa 80       	ldd	r15, Y+2	; 0x02
    5a2e:	00 e0       	ldi	r16, 0x00	; 0
    5a30:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5a32:	c8 01       	movw	r24, r16
    5a34:	b6 01       	movw	r22, r12
    5a36:	0e 94 a1 39 	call	0x7342	; 0x7342 <__divmodhi4>
    5a3a:	89 87       	std	Y+9, r24	; 0x09
    5a3c:	9a 87       	std	Y+10, r25	; 0x0a
    5a3e:	f7 01       	movw	r30, r14
    5a40:	81 91       	ld	r24, Z+
    5a42:	7f 01       	movw	r14, r30
    5a44:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5a48:	e9 85       	ldd	r30, Y+9	; 0x09
    5a4a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a4c:	ea 0d       	add	r30, r10
    5a4e:	fb 1d       	adc	r31, r11
    5a50:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5a52:	0f 5f       	subi	r16, 0xFF	; 255
    5a54:	1f 4f       	sbci	r17, 0xFF	; 255
    5a56:	f2 e0       	ldi	r31, 0x02	; 2
    5a58:	00 30       	cpi	r16, 0x00	; 0
    5a5a:	1f 07       	cpc	r17, r31
    5a5c:	51 f7       	brne	.-44     	; 0x5a32 <SD_write_multiple_blocks+0x1ac>
    5a5e:	d6 cf       	rjmp	.-84     	; 0x5a0c <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5a60:	8f ef       	ldi	r24, 0xFF	; 255
    5a62:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5a66:	f4 01       	movw	r30, r8
    5a68:	80 83       	st	Z, r24
    5a6a:	80 81       	ld	r24, Z
    5a6c:	8f 3f       	cpi	r24, 0xFF	; 255
    5a6e:	c1 f7       	brne	.-16     	; 0x5a60 <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    5a70:	08 94       	sec
    5a72:	61 1c       	adc	r6, r1
    5a74:	71 1c       	adc	r7, r1
    5a76:	29 81       	ldd	r18, Y+1	; 0x01
    5a78:	3a 81       	ldd	r19, Y+2	; 0x02
    5a7a:	20 50       	subi	r18, 0x00	; 0
    5a7c:	3e 4f       	sbci	r19, 0xFE	; 254
    5a7e:	29 83       	std	Y+1, r18	; 0x01
    5a80:	3a 83       	std	Y+2, r19	; 0x02
    5a82:	8b 81       	ldd	r24, Y+3	; 0x03
    5a84:	9c 81       	ldd	r25, Y+4	; 0x04
    5a86:	68 16       	cp	r6, r24
    5a88:	79 06       	cpc	r7, r25
    5a8a:	09 f0       	breq	.+2      	; 0x5a8e <SD_write_multiple_blocks+0x208>
    5a8c:	7d cf       	rjmp	.-262    	; 0x5988 <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5a8e:	ee 24       	eor	r14, r14
    5a90:	ff 24       	eor	r15, r15
    5a92:	68 94       	set
    5a94:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5a96:	0a e3       	ldi	r16, 0x3A	; 58
    5a98:	1e e3       	ldi	r17, 0x3E	; 62
    5a9a:	8f ef       	ldi	r24, 0xFF	; 255
    5a9c:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5aa0:	f8 01       	movw	r30, r16
    5aa2:	80 83       	st	Z, r24
    5aa4:	08 94       	sec
    5aa6:	e1 08       	sbc	r14, r1
    5aa8:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    5aaa:	e1 14       	cp	r14, r1
    5aac:	f1 04       	cpc	r15, r1
    5aae:	a9 f7       	brne	.-22     	; 0x5a9a <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    5ab0:	8d ef       	ldi	r24, 0xFD	; 253
    5ab2:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5ab6:	80 93 3a 3e 	sts	0x3E3A, r24
    5aba:	ee 24       	eor	r14, r14
    5abc:	ff 24       	eor	r15, r15
    5abe:	68 94       	set
    5ac0:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5ac2:	0a e3       	ldi	r16, 0x3A	; 58
    5ac4:	1e e3       	ldi	r17, 0x3E	; 62
    5ac6:	8f ef       	ldi	r24, 0xFF	; 255
    5ac8:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5acc:	f8 01       	movw	r30, r16
    5ace:	80 83       	st	Z, r24
    5ad0:	08 94       	sec
    5ad2:	e1 08       	sbc	r14, r1
    5ad4:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    5ad6:	e1 14       	cp	r14, r1
    5ad8:	f1 04       	cpc	r15, r1
    5ada:	a9 f7       	brne	.-22     	; 0x5ac6 <SD_write_multiple_blocks+0x240>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    5adc:	10 92 3a 3e 	sts	0x3E3A, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5ae0:	80 91 3a 3e 	lds	r24, 0x3E3A
    5ae4:	8f 3f       	cpi	r24, 0xFF	; 255
    5ae6:	51 f0       	breq	.+20     	; 0x5afc <SD_write_multiple_blocks+0x276>
    5ae8:	0a e3       	ldi	r16, 0x3A	; 58
    5aea:	1e e3       	ldi	r17, 0x3E	; 62
    5aec:	8f ef       	ldi	r24, 0xFF	; 255
    5aee:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5af2:	f8 01       	movw	r30, r16
    5af4:	80 83       	st	Z, r24
    5af6:	80 81       	ld	r24, Z
    5af8:	8f 3f       	cpi	r24, 0xFF	; 255
    5afa:	c1 f7       	brne	.-16     	; 0x5aec <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    5afc:	80 e0       	ldi	r24, 0x00	; 0
    5afe:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	SPIDisable();
    5b02:	0e 94 19 04 	call	0x832	; 0x832 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5b06:	88 e0       	ldi	r24, 0x08	; 8
    5b08:	60 e0       	ldi	r22, 0x00	; 0
    5b0a:	0e 94 dd 04 	call	0x9ba	; 0x9ba <PortEx_OUTSET>
}
    5b0e:	2a 96       	adiw	r28, 0x0a	; 10
    5b10:	cd bf       	out	0x3d, r28	; 61
    5b12:	de bf       	out	0x3e, r29	; 62
    5b14:	df 91       	pop	r29
    5b16:	cf 91       	pop	r28
    5b18:	1f 91       	pop	r17
    5b1a:	0f 91       	pop	r16
    5b1c:	ff 90       	pop	r15
    5b1e:	ef 90       	pop	r14
    5b20:	df 90       	pop	r13
    5b22:	cf 90       	pop	r12
    5b24:	bf 90       	pop	r11
    5b26:	af 90       	pop	r10
    5b28:	9f 90       	pop	r9
    5b2a:	8f 90       	pop	r8
    5b2c:	7f 90       	pop	r7
    5b2e:	6f 90       	pop	r6
    5b30:	5f 90       	pop	r5
    5b32:	4f 90       	pop	r4
    5b34:	3f 90       	pop	r3
    5b36:	2f 90       	pop	r2
    5b38:	08 95       	ret

00005b3a <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    5b3a:	2f 92       	push	r2
    5b3c:	3f 92       	push	r3
    5b3e:	4f 92       	push	r4
    5b40:	5f 92       	push	r5
    5b42:	6f 92       	push	r6
    5b44:	7f 92       	push	r7
    5b46:	8f 92       	push	r8
    5b48:	9f 92       	push	r9
    5b4a:	af 92       	push	r10
    5b4c:	bf 92       	push	r11
    5b4e:	cf 92       	push	r12
    5b50:	df 92       	push	r13
    5b52:	ef 92       	push	r14
    5b54:	ff 92       	push	r15
    5b56:	0f 93       	push	r16
    5b58:	1f 93       	push	r17
    5b5a:	cf 93       	push	r28
    5b5c:	df 93       	push	r29
    5b5e:	6b 01       	movw	r12, r22
    5b60:	7c 01       	movw	r14, r24
    5b62:	c4 2f       	mov	r28, r20
    5b64:	85 2e       	mov	r8, r21
    5b66:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5b68:	88 e0       	ldi	r24, 0x08	; 8
    5b6a:	60 e0       	ldi	r22, 0x00	; 0
    5b6c:	0e 94 86 04 	call	0x90c	; 0x90c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5b70:	80 e0       	ldi	r24, 0x00	; 0
    5b72:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPIInit>
	SPICS(TRUE);
    5b76:	81 e0       	ldi	r24, 0x01	; 1
    5b78:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    5b7c:	82 e1       	ldi	r24, 0x12	; 18
    5b7e:	b7 01       	movw	r22, r14
    5b80:	a6 01       	movw	r20, r12
    5b82:	2f ef       	ldi	r18, 0xFF	; 255
    5b84:	08 e0       	ldi	r16, 0x08	; 8
    5b86:	10 e0       	ldi	r17, 0x00	; 0
    5b88:	0e 94 ec 29 	call	0x53d8	; 0x53d8 <SD_command>
    5b8c:	88 23       	and	r24, r24
    5b8e:	b1 f7       	brne	.-20     	; 0x5b7c <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5b90:	16 14       	cp	r1, r6
    5b92:	17 04       	cpc	r1, r7
    5b94:	0c f0       	brlt	.+2      	; 0x5b98 <SD_read_multiple_blocks+0x5e>
    5b96:	46 c0       	rjmp	.+140    	; 0x5c24 <SD_read_multiple_blocks+0xea>
    5b98:	ac 2e       	mov	r10, r28
    5b9a:	b8 2c       	mov	r11, r8
    5b9c:	88 24       	eor	r8, r8
    5b9e:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    5ba0:	0f 2e       	mov	r0, r31
    5ba2:	fa e3       	ldi	r31, 0x3A	; 58
    5ba4:	cf 2e       	mov	r12, r31
    5ba6:	fe e3       	ldi	r31, 0x3E	; 62
    5ba8:	df 2e       	mov	r13, r31
    5baa:	f0 2d       	mov	r31, r0
    5bac:	ff 24       	eor	r15, r15
    5bae:	fa 94       	dec	r15
    5bb0:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5bb2:	0f 2e       	mov	r0, r31
    5bb4:	f9 e3       	ldi	r31, 0x39	; 57
    5bb6:	4f 2e       	mov	r4, r31
    5bb8:	fe e3       	ldi	r31, 0x3E	; 62
    5bba:	5f 2e       	mov	r5, r31
    5bbc:	f0 2d       	mov	r31, r0
    5bbe:	12 01       	movw	r2, r4
    5bc0:	08 94       	sec
    5bc2:	21 1c       	adc	r2, r1
    5bc4:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    5bc6:	f6 01       	movw	r30, r12
    5bc8:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5bca:	80 81       	ld	r24, Z
    5bcc:	8e 3f       	cpi	r24, 0xFE	; 254
    5bce:	41 f0       	breq	.+16     	; 0x5be0 <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    5bd0:	8f 2d       	mov	r24, r15
    5bd2:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5bd6:	f6 01       	movw	r30, r12
    5bd8:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5bda:	80 81       	ld	r24, Z
    5bdc:	8e 3f       	cpi	r24, 0xFE	; 254
    5bde:	c1 f7       	brne	.-16     	; 0x5bd0 <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5be0:	85 01       	movw	r16, r10
    5be2:	c0 e0       	ldi	r28, 0x00	; 0
    5be4:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5be6:	8f 2d       	mov	r24, r15
    5be8:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5bec:	f8 01       	movw	r30, r16
    5bee:	81 93       	st	Z+, r24
    5bf0:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5bf2:	21 96       	adiw	r28, 0x01	; 1
    5bf4:	f2 e0       	ldi	r31, 0x02	; 2
    5bf6:	c0 30       	cpi	r28, 0x00	; 0
    5bf8:	df 07       	cpc	r29, r31
    5bfa:	a9 f7       	brne	.-22     	; 0x5be6 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5bfc:	8f 2d       	mov	r24, r15
    5bfe:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5c02:	f2 01       	movw	r30, r4
    5c04:	80 83       	st	Z, r24
    5c06:	8f 2d       	mov	r24, r15
    5c08:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5c0c:	f1 01       	movw	r30, r2
    5c0e:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5c10:	08 94       	sec
    5c12:	81 1c       	adc	r8, r1
    5c14:	91 1c       	adc	r9, r1
    5c16:	80 e0       	ldi	r24, 0x00	; 0
    5c18:	92 e0       	ldi	r25, 0x02	; 2
    5c1a:	a8 0e       	add	r10, r24
    5c1c:	b9 1e       	adc	r11, r25
    5c1e:	86 14       	cp	r8, r6
    5c20:	97 04       	cpc	r9, r7
    5c22:	89 f6       	brne	.-94     	; 0x5bc6 <SD_read_multiple_blocks+0x8c>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    5c24:	8c e0       	ldi	r24, 0x0C	; 12
    5c26:	40 e0       	ldi	r20, 0x00	; 0
    5c28:	50 e0       	ldi	r21, 0x00	; 0
    5c2a:	ba 01       	movw	r22, r20
    5c2c:	2f ef       	ldi	r18, 0xFF	; 255
    5c2e:	08 e0       	ldi	r16, 0x08	; 8
    5c30:	10 e0       	ldi	r17, 0x00	; 0
    5c32:	0e 94 ec 29 	call	0x53d8	; 0x53d8 <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    5c36:	8f ef       	ldi	r24, 0xFF	; 255
    5c38:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5c3c:	80 93 39 3e 	sts	0x3E39, r24
	Buffer[1] = FILLER_BYTE;
    5c40:	10 92 3a 3e 	sts	0x3E3A, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5c44:	80 91 3a 3e 	lds	r24, 0x3E3A
    5c48:	8f 3f       	cpi	r24, 0xFF	; 255
    5c4a:	49 f0       	breq	.+18     	; 0x5c5e <SD_read_multiple_blocks+0x124>
    5c4c:	ca e3       	ldi	r28, 0x3A	; 58
    5c4e:	de e3       	ldi	r29, 0x3E	; 62
    5c50:	8f ef       	ldi	r24, 0xFF	; 255
    5c52:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
    5c56:	88 83       	st	Y, r24
    5c58:	88 81       	ld	r24, Y
    5c5a:	8f 3f       	cpi	r24, 0xFF	; 255
    5c5c:	c9 f7       	brne	.-14     	; 0x5c50 <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    5c5e:	80 e0       	ldi	r24, 0x00	; 0
    5c60:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	SPIDisable();
    5c64:	0e 94 19 04 	call	0x832	; 0x832 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5c68:	88 e0       	ldi	r24, 0x08	; 8
    5c6a:	60 e0       	ldi	r22, 0x00	; 0
    5c6c:	0e 94 dd 04 	call	0x9ba	; 0x9ba <PortEx_OUTSET>
}
    5c70:	df 91       	pop	r29
    5c72:	cf 91       	pop	r28
    5c74:	1f 91       	pop	r17
    5c76:	0f 91       	pop	r16
    5c78:	ff 90       	pop	r15
    5c7a:	ef 90       	pop	r14
    5c7c:	df 90       	pop	r13
    5c7e:	cf 90       	pop	r12
    5c80:	bf 90       	pop	r11
    5c82:	af 90       	pop	r10
    5c84:	9f 90       	pop	r9
    5c86:	8f 90       	pop	r8
    5c88:	7f 90       	pop	r7
    5c8a:	6f 90       	pop	r6
    5c8c:	5f 90       	pop	r5
    5c8e:	4f 90       	pop	r4
    5c90:	3f 90       	pop	r3
    5c92:	2f 90       	pop	r2
    5c94:	08 95       	ret

00005c96 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    5c96:	88 e0       	ldi	r24, 0x08	; 8
    5c98:	60 e0       	ldi	r22, 0x00	; 0
    5c9a:	0e 94 8a 05 	call	0xb14	; 0xb14 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    5c9e:	88 e0       	ldi	r24, 0x08	; 8
    5ca0:	60 e0       	ldi	r22, 0x00	; 0
    5ca2:	0e 94 dd 04 	call	0x9ba	; 0x9ba <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    5ca6:	80 e0       	ldi	r24, 0x00	; 0
    5ca8:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <SPIInit>
	SPICS(TRUE);
    5cac:	81 e0       	ldi	r24, 0x01	; 1
    5cae:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    5cb2:	8f ef       	ldi	r24, 0xFF	; 255
    5cb4:	0e 94 f7 06 	call	0xdee	; 0xdee <SPI_write>
	SPICS(FALSE);	//stop spi
    5cb8:	80 e0       	ldi	r24, 0x00	; 0
    5cba:	0e 94 0d 04 	call	0x81a	; 0x81a <SPICS>
	SPIDisable();
    5cbe:	0e 94 19 04 	call	0x832	; 0x832 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    5cc2:	80 e0       	ldi	r24, 0x00	; 0
    5cc4:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    5cc8:	80 e0       	ldi	r24, 0x00	; 0
    5cca:	0e 94 87 03 	call	0x70e	; 0x70e <Ext1Power>
}
    5cce:	08 95       	ret

00005cd0 <__muldi3>:
    5cd0:	a0 e3       	ldi	r26, 0x30	; 48
    5cd2:	b0 e0       	ldi	r27, 0x00	; 0
    5cd4:	ee e6       	ldi	r30, 0x6E	; 110
    5cd6:	fe e2       	ldi	r31, 0x2E	; 46
    5cd8:	0c 94 07 3a 	jmp	0x740e	; 0x740e <__prologue_saves__+0x4>
    5cdc:	29 8f       	std	Y+25, r18	; 0x19
    5cde:	3a 8f       	std	Y+26, r19	; 0x1a
    5ce0:	4b 8f       	std	Y+27, r20	; 0x1b
    5ce2:	5c 8f       	std	Y+28, r21	; 0x1c
    5ce4:	6d 8f       	std	Y+29, r22	; 0x1d
    5ce6:	7e 8f       	std	Y+30, r23	; 0x1e
    5ce8:	8f 8f       	std	Y+31, r24	; 0x1f
    5cea:	98 a3       	lds	r25, 0x58
    5cec:	a9 8a       	std	Y+17, r10	; 0x11
    5cee:	ba 8a       	std	Y+18, r11	; 0x12
    5cf0:	cb 8a       	std	Y+19, r12	; 0x13
    5cf2:	dc 8a       	std	Y+20, r13	; 0x14
    5cf4:	ed 8a       	std	Y+21, r14	; 0x15
    5cf6:	fe 8a       	std	Y+22, r15	; 0x16
    5cf8:	0f 8b       	std	Y+23, r16	; 0x17
    5cfa:	18 8f       	std	Y+24, r17	; 0x18
    5cfc:	09 8d       	ldd	r16, Y+25	; 0x19
    5cfe:	1a 8d       	ldd	r17, Y+26	; 0x1a
    5d00:	2b 8d       	ldd	r18, Y+27	; 0x1b
    5d02:	3c 8d       	ldd	r19, Y+28	; 0x1c
    5d04:	09 a3       	lds	r16, 0x59
    5d06:	1a a3       	lds	r17, 0x5a
    5d08:	2b a3       	lds	r18, 0x5b
    5d0a:	3c a3       	lds	r19, 0x5c
    5d0c:	68 01       	movw	r12, r16
    5d0e:	79 01       	movw	r14, r18
    5d10:	8f ef       	ldi	r24, 0xFF	; 255
    5d12:	9f ef       	ldi	r25, 0xFF	; 255
    5d14:	a0 e0       	ldi	r26, 0x00	; 0
    5d16:	b0 e0       	ldi	r27, 0x00	; 0
    5d18:	c8 22       	and	r12, r24
    5d1a:	d9 22       	and	r13, r25
    5d1c:	ea 22       	and	r14, r26
    5d1e:	fb 22       	and	r15, r27
    5d20:	89 01       	movw	r16, r18
    5d22:	22 27       	eor	r18, r18
    5d24:	33 27       	eor	r19, r19
    5d26:	09 a7       	lds	r16, 0x79
    5d28:	1a a7       	lds	r17, 0x7a
    5d2a:	2b a7       	lds	r18, 0x7b
    5d2c:	3c a7       	lds	r19, 0x7c
    5d2e:	09 89       	ldd	r16, Y+17	; 0x11
    5d30:	1a 89       	ldd	r17, Y+18	; 0x12
    5d32:	2b 89       	ldd	r18, Y+19	; 0x13
    5d34:	3c 89       	ldd	r19, Y+20	; 0x14
    5d36:	0d a3       	lds	r16, 0x5d
    5d38:	1e a3       	lds	r17, 0x5e
    5d3a:	2f a3       	lds	r18, 0x5f
    5d3c:	38 a7       	lds	r19, 0x78
    5d3e:	48 01       	movw	r8, r16
    5d40:	59 01       	movw	r10, r18
    5d42:	88 22       	and	r8, r24
    5d44:	99 22       	and	r9, r25
    5d46:	aa 22       	and	r10, r26
    5d48:	bb 22       	and	r11, r27
    5d4a:	29 01       	movw	r4, r18
    5d4c:	66 24       	eor	r6, r6
    5d4e:	77 24       	eor	r7, r7
    5d50:	c5 01       	movw	r24, r10
    5d52:	b4 01       	movw	r22, r8
    5d54:	a7 01       	movw	r20, r14
    5d56:	96 01       	movw	r18, r12
    5d58:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    5d5c:	6d a7       	lds	r22, 0x7d
    5d5e:	7e a7       	lds	r23, 0x7e
    5d60:	8f a7       	lds	r24, 0x7f
    5d62:	98 ab       	sts	0x58, r25
    5d64:	c3 01       	movw	r24, r6
    5d66:	b2 01       	movw	r22, r4
    5d68:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    5d6c:	6b 01       	movw	r12, r22
    5d6e:	7c 01       	movw	r14, r24
    5d70:	c5 01       	movw	r24, r10
    5d72:	b4 01       	movw	r22, r8
    5d74:	29 a5       	lds	r18, 0x69
    5d76:	3a a5       	lds	r19, 0x6a
    5d78:	4b a5       	lds	r20, 0x6b
    5d7a:	5c a5       	lds	r21, 0x6c
    5d7c:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    5d80:	4b 01       	movw	r8, r22
    5d82:	5c 01       	movw	r10, r24
    5d84:	c3 01       	movw	r24, r6
    5d86:	b2 01       	movw	r22, r4
    5d88:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    5d8c:	ab 01       	movw	r20, r22
    5d8e:	bc 01       	movw	r22, r24
    5d90:	c8 0c       	add	r12, r8
    5d92:	d9 1c       	adc	r13, r9
    5d94:	ea 1c       	adc	r14, r10
    5d96:	fb 1c       	adc	r15, r11
    5d98:	0d a5       	lds	r16, 0x6d
    5d9a:	1e a5       	lds	r17, 0x6e
    5d9c:	2f a5       	lds	r18, 0x6f
    5d9e:	38 a9       	sts	0x48, r19
    5da0:	c9 01       	movw	r24, r18
    5da2:	aa 27       	eor	r26, r26
    5da4:	bb 27       	eor	r27, r27
    5da6:	c8 0e       	add	r12, r24
    5da8:	d9 1e       	adc	r13, r25
    5daa:	ea 1e       	adc	r14, r26
    5dac:	fb 1e       	adc	r15, r27
    5dae:	c8 14       	cp	r12, r8
    5db0:	d9 04       	cpc	r13, r9
    5db2:	ea 04       	cpc	r14, r10
    5db4:	fb 04       	cpc	r15, r11
    5db6:	20 f4       	brcc	.+8      	; 0x5dc0 <__muldi3+0xf0>
    5db8:	40 50       	subi	r20, 0x00	; 0
    5dba:	50 40       	sbci	r21, 0x00	; 0
    5dbc:	6f 4f       	sbci	r22, 0xFF	; 255
    5dbe:	7f 4f       	sbci	r23, 0xFF	; 255
    5dc0:	c7 01       	movw	r24, r14
    5dc2:	aa 27       	eor	r26, r26
    5dc4:	bb 27       	eor	r27, r27
    5dc6:	84 0f       	add	r24, r20
    5dc8:	95 1f       	adc	r25, r21
    5dca:	a6 1f       	adc	r26, r22
    5dcc:	b7 1f       	adc	r27, r23
    5dce:	8d 83       	std	Y+5, r24	; 0x05
    5dd0:	9e 83       	std	Y+6, r25	; 0x06
    5dd2:	af 83       	std	Y+7, r26	; 0x07
    5dd4:	b8 87       	std	Y+8, r27	; 0x08
    5dd6:	76 01       	movw	r14, r12
    5dd8:	dd 24       	eor	r13, r13
    5dda:	cc 24       	eor	r12, r12
    5ddc:	4d a5       	lds	r20, 0x6d
    5dde:	5e a5       	lds	r21, 0x6e
    5de0:	6f a5       	lds	r22, 0x6f
    5de2:	78 a9       	sts	0x48, r23
    5de4:	60 70       	andi	r22, 0x00	; 0
    5de6:	70 70       	andi	r23, 0x00	; 0
    5de8:	c4 0e       	add	r12, r20
    5dea:	d5 1e       	adc	r13, r21
    5dec:	e6 1e       	adc	r14, r22
    5dee:	f7 1e       	adc	r15, r23
    5df0:	c9 82       	std	Y+1, r12	; 0x01
    5df2:	da 82       	std	Y+2, r13	; 0x02
    5df4:	eb 82       	std	Y+3, r14	; 0x03
    5df6:	fc 82       	std	Y+4, r15	; 0x04
    5df8:	1c 2d       	mov	r17, r12
    5dfa:	0a 81       	ldd	r16, Y+2	; 0x02
    5dfc:	8b 80       	ldd	r8, Y+3	; 0x03
    5dfe:	4c 80       	ldd	r4, Y+4	; 0x04
    5e00:	8d 87       	std	Y+13, r24	; 0x0d
    5e02:	8e 81       	ldd	r24, Y+6	; 0x06
    5e04:	8e 87       	std	Y+14, r24	; 0x0e
    5e06:	8f 81       	ldd	r24, Y+7	; 0x07
    5e08:	8f 87       	std	Y+15, r24	; 0x0f
    5e0a:	88 85       	ldd	r24, Y+8	; 0x08
    5e0c:	88 8b       	std	Y+16, r24	; 0x10
    5e0e:	2d 89       	ldd	r18, Y+21	; 0x15
    5e10:	3e 89       	ldd	r19, Y+22	; 0x16
    5e12:	4f 89       	ldd	r20, Y+23	; 0x17
    5e14:	58 8d       	ldd	r21, Y+24	; 0x18
    5e16:	69 a1       	lds	r22, 0x49
    5e18:	7a a1       	lds	r23, 0x4a
    5e1a:	8b a1       	lds	r24, 0x4b
    5e1c:	9c a1       	lds	r25, 0x4c
    5e1e:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    5e22:	6b 01       	movw	r12, r22
    5e24:	7c 01       	movw	r14, r24
    5e26:	2d 8d       	ldd	r18, Y+29	; 0x1d
    5e28:	3e 8d       	ldd	r19, Y+30	; 0x1e
    5e2a:	4f 8d       	ldd	r20, Y+31	; 0x1f
    5e2c:	58 a1       	lds	r21, 0x48
    5e2e:	6d a1       	lds	r22, 0x4d
    5e30:	7e a1       	lds	r23, 0x4e
    5e32:	8f a1       	lds	r24, 0x4f
    5e34:	98 a5       	lds	r25, 0x68
    5e36:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    5e3a:	dc 01       	movw	r26, r24
    5e3c:	cb 01       	movw	r24, r22
    5e3e:	c8 0e       	add	r12, r24
    5e40:	d9 1e       	adc	r13, r25
    5e42:	ea 1e       	adc	r14, r26
    5e44:	fb 1e       	adc	r15, r27
    5e46:	8d 85       	ldd	r24, Y+13	; 0x0d
    5e48:	9e 85       	ldd	r25, Y+14	; 0x0e
    5e4a:	af 85       	ldd	r26, Y+15	; 0x0f
    5e4c:	b8 89       	ldd	r27, Y+16	; 0x10
    5e4e:	8c 0d       	add	r24, r12
    5e50:	9d 1d       	adc	r25, r13
    5e52:	ae 1d       	adc	r26, r14
    5e54:	bf 1d       	adc	r27, r15
    5e56:	8d 87       	std	Y+13, r24	; 0x0d
    5e58:	9e 87       	std	Y+14, r25	; 0x0e
    5e5a:	af 87       	std	Y+15, r26	; 0x0f
    5e5c:	b8 8b       	std	Y+16, r27	; 0x10
    5e5e:	68 2f       	mov	r22, r24
    5e60:	7e 85       	ldd	r23, Y+14	; 0x0e
    5e62:	21 2f       	mov	r18, r17
    5e64:	30 2f       	mov	r19, r16
    5e66:	48 2d       	mov	r20, r8
    5e68:	54 2d       	mov	r21, r4
    5e6a:	8f 85       	ldd	r24, Y+15	; 0x0f
    5e6c:	98 89       	ldd	r25, Y+16	; 0x10
    5e6e:	e0 96       	adiw	r28, 0x30	; 48
    5e70:	e0 e1       	ldi	r30, 0x10	; 16
    5e72:	0c 94 20 3a 	jmp	0x7440	; 0x7440 <__epilogue_restores__+0x4>

00005e76 <__ashldi3>:
    5e76:	cf 92       	push	r12
    5e78:	df 92       	push	r13
    5e7a:	ef 92       	push	r14
    5e7c:	ff 92       	push	r15
    5e7e:	0f 93       	push	r16
    5e80:	cf 93       	push	r28
    5e82:	df 93       	push	r29
    5e84:	cd b7       	in	r28, 0x3d	; 61
    5e86:	de b7       	in	r29, 0x3e	; 62
    5e88:	60 97       	sbiw	r28, 0x10	; 16
    5e8a:	cd bf       	out	0x3d, r28	; 61
    5e8c:	de bf       	out	0x3e, r29	; 62
    5e8e:	00 23       	and	r16, r16
    5e90:	09 f4       	brne	.+2      	; 0x5e94 <__ashldi3+0x1e>
    5e92:	5a c0       	rjmp	.+180    	; 0x5f48 <__ashldi3+0xd2>
    5e94:	29 87       	std	Y+9, r18	; 0x09
    5e96:	3a 87       	std	Y+10, r19	; 0x0a
    5e98:	4b 87       	std	Y+11, r20	; 0x0b
    5e9a:	5c 87       	std	Y+12, r21	; 0x0c
    5e9c:	6d 87       	std	Y+13, r22	; 0x0d
    5e9e:	7e 87       	std	Y+14, r23	; 0x0e
    5ea0:	8f 87       	std	Y+15, r24	; 0x0f
    5ea2:	98 8b       	std	Y+16, r25	; 0x10
    5ea4:	80 e2       	ldi	r24, 0x20	; 32
    5ea6:	80 1b       	sub	r24, r16
    5ea8:	49 85       	ldd	r20, Y+9	; 0x09
    5eaa:	5a 85       	ldd	r21, Y+10	; 0x0a
    5eac:	6b 85       	ldd	r22, Y+11	; 0x0b
    5eae:	7c 85       	ldd	r23, Y+12	; 0x0c
    5eb0:	18 16       	cp	r1, r24
    5eb2:	b4 f0       	brlt	.+44     	; 0x5ee0 <__ashldi3+0x6a>
    5eb4:	19 82       	std	Y+1, r1	; 0x01
    5eb6:	1a 82       	std	Y+2, r1	; 0x02
    5eb8:	1b 82       	std	Y+3, r1	; 0x03
    5eba:	1c 82       	std	Y+4, r1	; 0x04
    5ebc:	99 27       	eor	r25, r25
    5ebe:	87 fd       	sbrc	r24, 7
    5ec0:	90 95       	com	r25
    5ec2:	90 95       	com	r25
    5ec4:	81 95       	neg	r24
    5ec6:	9f 4f       	sbci	r25, 0xFF	; 255
    5ec8:	04 c0       	rjmp	.+8      	; 0x5ed2 <__ashldi3+0x5c>
    5eca:	44 0f       	add	r20, r20
    5ecc:	55 1f       	adc	r21, r21
    5ece:	66 1f       	adc	r22, r22
    5ed0:	77 1f       	adc	r23, r23
    5ed2:	8a 95       	dec	r24
    5ed4:	d2 f7       	brpl	.-12     	; 0x5eca <__ashldi3+0x54>
    5ed6:	4d 83       	std	Y+5, r20	; 0x05
    5ed8:	5e 83       	std	Y+6, r21	; 0x06
    5eda:	6f 83       	std	Y+7, r22	; 0x07
    5edc:	78 87       	std	Y+8, r23	; 0x08
    5ede:	2c c0       	rjmp	.+88     	; 0x5f38 <__ashldi3+0xc2>
    5ee0:	6a 01       	movw	r12, r20
    5ee2:	7b 01       	movw	r14, r22
    5ee4:	00 2e       	mov	r0, r16
    5ee6:	04 c0       	rjmp	.+8      	; 0x5ef0 <__ashldi3+0x7a>
    5ee8:	cc 0c       	add	r12, r12
    5eea:	dd 1c       	adc	r13, r13
    5eec:	ee 1c       	adc	r14, r14
    5eee:	ff 1c       	adc	r15, r15
    5ef0:	0a 94       	dec	r0
    5ef2:	d2 f7       	brpl	.-12     	; 0x5ee8 <__ashldi3+0x72>
    5ef4:	c9 82       	std	Y+1, r12	; 0x01
    5ef6:	da 82       	std	Y+2, r13	; 0x02
    5ef8:	eb 82       	std	Y+3, r14	; 0x03
    5efa:	fc 82       	std	Y+4, r15	; 0x04
    5efc:	6a 01       	movw	r12, r20
    5efe:	7b 01       	movw	r14, r22
    5f00:	04 c0       	rjmp	.+8      	; 0x5f0a <__ashldi3+0x94>
    5f02:	f6 94       	lsr	r15
    5f04:	e7 94       	ror	r14
    5f06:	d7 94       	ror	r13
    5f08:	c7 94       	ror	r12
    5f0a:	8a 95       	dec	r24
    5f0c:	d2 f7       	brpl	.-12     	; 0x5f02 <__ashldi3+0x8c>
    5f0e:	d7 01       	movw	r26, r14
    5f10:	c6 01       	movw	r24, r12
    5f12:	4d 85       	ldd	r20, Y+13	; 0x0d
    5f14:	5e 85       	ldd	r21, Y+14	; 0x0e
    5f16:	6f 85       	ldd	r22, Y+15	; 0x0f
    5f18:	78 89       	ldd	r23, Y+16	; 0x10
    5f1a:	04 c0       	rjmp	.+8      	; 0x5f24 <__ashldi3+0xae>
    5f1c:	44 0f       	add	r20, r20
    5f1e:	55 1f       	adc	r21, r21
    5f20:	66 1f       	adc	r22, r22
    5f22:	77 1f       	adc	r23, r23
    5f24:	0a 95       	dec	r16
    5f26:	d2 f7       	brpl	.-12     	; 0x5f1c <__ashldi3+0xa6>
    5f28:	84 2b       	or	r24, r20
    5f2a:	95 2b       	or	r25, r21
    5f2c:	a6 2b       	or	r26, r22
    5f2e:	b7 2b       	or	r27, r23
    5f30:	8d 83       	std	Y+5, r24	; 0x05
    5f32:	9e 83       	std	Y+6, r25	; 0x06
    5f34:	af 83       	std	Y+7, r26	; 0x07
    5f36:	b8 87       	std	Y+8, r27	; 0x08
    5f38:	29 81       	ldd	r18, Y+1	; 0x01
    5f3a:	3a 81       	ldd	r19, Y+2	; 0x02
    5f3c:	4b 81       	ldd	r20, Y+3	; 0x03
    5f3e:	5c 81       	ldd	r21, Y+4	; 0x04
    5f40:	6d 81       	ldd	r22, Y+5	; 0x05
    5f42:	7e 81       	ldd	r23, Y+6	; 0x06
    5f44:	8f 81       	ldd	r24, Y+7	; 0x07
    5f46:	98 85       	ldd	r25, Y+8	; 0x08
    5f48:	60 96       	adiw	r28, 0x10	; 16
    5f4a:	cd bf       	out	0x3d, r28	; 61
    5f4c:	de bf       	out	0x3e, r29	; 62
    5f4e:	df 91       	pop	r29
    5f50:	cf 91       	pop	r28
    5f52:	0f 91       	pop	r16
    5f54:	ff 90       	pop	r15
    5f56:	ef 90       	pop	r14
    5f58:	df 90       	pop	r13
    5f5a:	cf 90       	pop	r12
    5f5c:	08 95       	ret

00005f5e <__ashrdi3>:
    5f5e:	0f 93       	push	r16
    5f60:	cf 93       	push	r28
    5f62:	df 93       	push	r29
    5f64:	cd b7       	in	r28, 0x3d	; 61
    5f66:	de b7       	in	r29, 0x3e	; 62
    5f68:	60 97       	sbiw	r28, 0x10	; 16
    5f6a:	cd bf       	out	0x3d, r28	; 61
    5f6c:	de bf       	out	0x3e, r29	; 62
    5f6e:	00 23       	and	r16, r16
    5f70:	09 f4       	brne	.+2      	; 0x5f74 <__ashrdi3+0x16>
    5f72:	56 c0       	rjmp	.+172    	; 0x6020 <__stack+0x21>
    5f74:	29 87       	std	Y+9, r18	; 0x09
    5f76:	3a 87       	std	Y+10, r19	; 0x0a
    5f78:	4b 87       	std	Y+11, r20	; 0x0b
    5f7a:	5c 87       	std	Y+12, r21	; 0x0c
    5f7c:	6d 87       	std	Y+13, r22	; 0x0d
    5f7e:	7e 87       	std	Y+14, r23	; 0x0e
    5f80:	8f 87       	std	Y+15, r24	; 0x0f
    5f82:	98 8b       	std	Y+16, r25	; 0x10
    5f84:	20 e2       	ldi	r18, 0x20	; 32
    5f86:	20 1b       	sub	r18, r16
    5f88:	8d 85       	ldd	r24, Y+13	; 0x0d
    5f8a:	9e 85       	ldd	r25, Y+14	; 0x0e
    5f8c:	af 85       	ldd	r26, Y+15	; 0x0f
    5f8e:	b8 89       	ldd	r27, Y+16	; 0x10
    5f90:	ac 01       	movw	r20, r24
    5f92:	bd 01       	movw	r22, r26
    5f94:	12 16       	cp	r1, r18
    5f96:	b4 f0       	brlt	.+44     	; 0x5fc4 <__ashrdi3+0x66>
    5f98:	77 0f       	add	r23, r23
    5f9a:	44 0b       	sbc	r20, r20
    5f9c:	54 2f       	mov	r21, r20
    5f9e:	ba 01       	movw	r22, r20
    5fa0:	4d 83       	std	Y+5, r20	; 0x05
    5fa2:	5e 83       	std	Y+6, r21	; 0x06
    5fa4:	6f 83       	std	Y+7, r22	; 0x07
    5fa6:	78 87       	std	Y+8, r23	; 0x08
    5fa8:	33 27       	eor	r19, r19
    5faa:	27 fd       	sbrc	r18, 7
    5fac:	30 95       	com	r19
    5fae:	30 95       	com	r19
    5fb0:	21 95       	neg	r18
    5fb2:	3f 4f       	sbci	r19, 0xFF	; 255
    5fb4:	04 c0       	rjmp	.+8      	; 0x5fbe <__ashrdi3+0x60>
    5fb6:	b5 95       	asr	r27
    5fb8:	a7 95       	ror	r26
    5fba:	97 95       	ror	r25
    5fbc:	87 95       	ror	r24
    5fbe:	2a 95       	dec	r18
    5fc0:	d2 f7       	brpl	.-12     	; 0x5fb6 <__ashrdi3+0x58>
    5fc2:	22 c0       	rjmp	.+68     	; 0x6008 <__stack+0x9>
    5fc4:	00 2e       	mov	r0, r16
    5fc6:	04 c0       	rjmp	.+8      	; 0x5fd0 <__ashrdi3+0x72>
    5fc8:	75 95       	asr	r23
    5fca:	67 95       	ror	r22
    5fcc:	57 95       	ror	r21
    5fce:	47 95       	ror	r20
    5fd0:	0a 94       	dec	r0
    5fd2:	d2 f7       	brpl	.-12     	; 0x5fc8 <__ashrdi3+0x6a>
    5fd4:	4d 83       	std	Y+5, r20	; 0x05
    5fd6:	5e 83       	std	Y+6, r21	; 0x06
    5fd8:	6f 83       	std	Y+7, r22	; 0x07
    5fda:	78 87       	std	Y+8, r23	; 0x08
    5fdc:	04 c0       	rjmp	.+8      	; 0x5fe6 <__ashrdi3+0x88>
    5fde:	88 0f       	add	r24, r24
    5fe0:	99 1f       	adc	r25, r25
    5fe2:	aa 1f       	adc	r26, r26
    5fe4:	bb 1f       	adc	r27, r27
    5fe6:	2a 95       	dec	r18
    5fe8:	d2 f7       	brpl	.-12     	; 0x5fde <__ashrdi3+0x80>
    5fea:	49 85       	ldd	r20, Y+9	; 0x09
    5fec:	5a 85       	ldd	r21, Y+10	; 0x0a
    5fee:	6b 85       	ldd	r22, Y+11	; 0x0b
    5ff0:	7c 85       	ldd	r23, Y+12	; 0x0c
    5ff2:	04 c0       	rjmp	.+8      	; 0x5ffc <__ashrdi3+0x9e>
    5ff4:	76 95       	lsr	r23
    5ff6:	67 95       	ror	r22
    5ff8:	57 95       	ror	r21
    5ffa:	47 95       	ror	r20
    5ffc:	0a 95       	dec	r16
    5ffe:	d2 f7       	brpl	.-12     	; 0x5ff4 <__ashrdi3+0x96>
    6000:	84 2b       	or	r24, r20
    6002:	95 2b       	or	r25, r21
    6004:	a6 2b       	or	r26, r22
    6006:	b7 2b       	or	r27, r23
    6008:	89 83       	std	Y+1, r24	; 0x01
    600a:	9a 83       	std	Y+2, r25	; 0x02
    600c:	ab 83       	std	Y+3, r26	; 0x03
    600e:	bc 83       	std	Y+4, r27	; 0x04
    6010:	29 81       	ldd	r18, Y+1	; 0x01
    6012:	3a 81       	ldd	r19, Y+2	; 0x02
    6014:	4b 81       	ldd	r20, Y+3	; 0x03
    6016:	5c 81       	ldd	r21, Y+4	; 0x04
    6018:	6d 81       	ldd	r22, Y+5	; 0x05
    601a:	7e 81       	ldd	r23, Y+6	; 0x06
    601c:	8f 81       	ldd	r24, Y+7	; 0x07
    601e:	98 85       	ldd	r25, Y+8	; 0x08
    6020:	60 96       	adiw	r28, 0x10	; 16
    6022:	cd bf       	out	0x3d, r28	; 61
    6024:	de bf       	out	0x3e, r29	; 62
    6026:	df 91       	pop	r29
    6028:	cf 91       	pop	r28
    602a:	0f 91       	pop	r16
    602c:	08 95       	ret

0000602e <__divdi3>:
    602e:	a8 e4       	ldi	r26, 0x48	; 72
    6030:	b0 e0       	ldi	r27, 0x00	; 0
    6032:	ed e1       	ldi	r30, 0x1D	; 29
    6034:	f0 e3       	ldi	r31, 0x30	; 48
    6036:	0c 94 06 3a 	jmp	0x740c	; 0x740c <__prologue_saves__+0x2>
    603a:	f5 01       	movw	r30, r10
    603c:	29 a3       	lds	r18, 0x59
    603e:	3a a3       	lds	r19, 0x5a
    6040:	4b a3       	lds	r20, 0x5b
    6042:	5c a3       	lds	r21, 0x5c
    6044:	6d a3       	lds	r22, 0x5d
    6046:	7e a3       	lds	r23, 0x5e
    6048:	8f a3       	lds	r24, 0x5f
    604a:	98 a7       	lds	r25, 0x78
    604c:	a9 8e       	std	Y+25, r10	; 0x19
    604e:	fa 8f       	std	Y+26, r31	; 0x1a
    6050:	cb 8e       	std	Y+27, r12	; 0x1b
    6052:	dc 8e       	std	Y+28, r13	; 0x1c
    6054:	ed 8e       	std	Y+29, r14	; 0x1d
    6056:	fe 8e       	std	Y+30, r15	; 0x1e
    6058:	0f 8f       	std	Y+31, r16	; 0x1f
    605a:	18 a3       	lds	r17, 0x58
    605c:	8d a0       	lds	r24, 0x8d
    605e:	9e a0       	lds	r25, 0x8e
    6060:	af a0       	lds	r26, 0x8f
    6062:	b8 a4       	lds	r27, 0xa8
    6064:	b7 fe       	sbrs	r11, 7
    6066:	67 c0       	rjmp	.+206    	; 0x6136 <__divdi3+0x108>
    6068:	21 95       	neg	r18
    606a:	b1 e0       	ldi	r27, 0x01	; 1
    606c:	12 16       	cp	r1, r18
    606e:	08 f0       	brcs	.+2      	; 0x6072 <__divdi3+0x44>
    6070:	b0 e0       	ldi	r27, 0x00	; 0
    6072:	31 95       	neg	r19
    6074:	a1 e0       	ldi	r26, 0x01	; 1
    6076:	13 16       	cp	r1, r19
    6078:	08 f0       	brcs	.+2      	; 0x607c <__divdi3+0x4e>
    607a:	a0 e0       	ldi	r26, 0x00	; 0
    607c:	b3 2e       	mov	r11, r19
    607e:	bb 1a       	sub	r11, r27
    6080:	bb 2d       	mov	r27, r11
    6082:	88 24       	eor	r8, r8
    6084:	83 94       	inc	r8
    6086:	3b 15       	cp	r19, r11
    6088:	08 f0       	brcs	.+2      	; 0x608c <__divdi3+0x5e>
    608a:	88 24       	eor	r8, r8
    608c:	a8 29       	or	r26, r8
    608e:	41 95       	neg	r20
    6090:	31 e0       	ldi	r19, 0x01	; 1
    6092:	14 16       	cp	r1, r20
    6094:	08 f0       	brcs	.+2      	; 0x6098 <__divdi3+0x6a>
    6096:	30 e0       	ldi	r19, 0x00	; 0
    6098:	b4 2e       	mov	r11, r20
    609a:	ba 1a       	sub	r11, r26
    609c:	ab 2d       	mov	r26, r11
    609e:	88 24       	eor	r8, r8
    60a0:	83 94       	inc	r8
    60a2:	4b 15       	cp	r20, r11
    60a4:	08 f0       	brcs	.+2      	; 0x60a8 <__divdi3+0x7a>
    60a6:	88 24       	eor	r8, r8
    60a8:	38 29       	or	r19, r8
    60aa:	51 95       	neg	r21
    60ac:	41 e0       	ldi	r20, 0x01	; 1
    60ae:	15 16       	cp	r1, r21
    60b0:	08 f0       	brcs	.+2      	; 0x60b4 <__divdi3+0x86>
    60b2:	40 e0       	ldi	r20, 0x00	; 0
    60b4:	45 2e       	mov	r4, r21
    60b6:	43 1a       	sub	r4, r19
    60b8:	31 e0       	ldi	r19, 0x01	; 1
    60ba:	54 15       	cp	r21, r4
    60bc:	08 f0       	brcs	.+2      	; 0x60c0 <__divdi3+0x92>
    60be:	30 e0       	ldi	r19, 0x00	; 0
    60c0:	43 2b       	or	r20, r19
    60c2:	61 95       	neg	r22
    60c4:	31 e0       	ldi	r19, 0x01	; 1
    60c6:	16 16       	cp	r1, r22
    60c8:	08 f0       	brcs	.+2      	; 0x60cc <__divdi3+0x9e>
    60ca:	30 e0       	ldi	r19, 0x00	; 0
    60cc:	86 2e       	mov	r8, r22
    60ce:	84 1a       	sub	r8, r20
    60d0:	41 e0       	ldi	r20, 0x01	; 1
    60d2:	68 15       	cp	r22, r8
    60d4:	08 f0       	brcs	.+2      	; 0x60d8 <__divdi3+0xaa>
    60d6:	40 e0       	ldi	r20, 0x00	; 0
    60d8:	34 2b       	or	r19, r20
    60da:	71 95       	neg	r23
    60dc:	41 e0       	ldi	r20, 0x01	; 1
    60de:	17 16       	cp	r1, r23
    60e0:	08 f0       	brcs	.+2      	; 0x60e4 <__divdi3+0xb6>
    60e2:	40 e0       	ldi	r20, 0x00	; 0
    60e4:	57 2f       	mov	r21, r23
    60e6:	53 1b       	sub	r21, r19
    60e8:	31 e0       	ldi	r19, 0x01	; 1
    60ea:	75 17       	cp	r23, r21
    60ec:	08 f0       	brcs	.+2      	; 0x60f0 <__divdi3+0xc2>
    60ee:	30 e0       	ldi	r19, 0x00	; 0
    60f0:	43 2b       	or	r20, r19
    60f2:	81 95       	neg	r24
    60f4:	31 e0       	ldi	r19, 0x01	; 1
    60f6:	18 16       	cp	r1, r24
    60f8:	08 f0       	brcs	.+2      	; 0x60fc <__divdi3+0xce>
    60fa:	30 e0       	ldi	r19, 0x00	; 0
    60fc:	68 2f       	mov	r22, r24
    60fe:	64 1b       	sub	r22, r20
    6100:	46 2f       	mov	r20, r22
    6102:	61 e0       	ldi	r22, 0x01	; 1
    6104:	84 17       	cp	r24, r20
    6106:	08 f0       	brcs	.+2      	; 0x610a <__divdi3+0xdc>
    6108:	60 e0       	ldi	r22, 0x00	; 0
    610a:	36 2b       	or	r19, r22
    610c:	91 95       	neg	r25
    610e:	93 1b       	sub	r25, r19
    6110:	29 a3       	lds	r18, 0x59
    6112:	ba a3       	lds	r27, 0x5a
    6114:	ab a3       	lds	r26, 0x5b
    6116:	4c a2       	lds	r20, 0x9c
    6118:	8d a2       	lds	r24, 0x9d
    611a:	5e a3       	lds	r21, 0x5e
    611c:	4f a3       	lds	r20, 0x5f
    611e:	98 a7       	lds	r25, 0x78
    6120:	8f ef       	ldi	r24, 0xFF	; 255
    6122:	9f ef       	ldi	r25, 0xFF	; 255
    6124:	af ef       	ldi	r26, 0xFF	; 255
    6126:	bf ef       	ldi	r27, 0xFF	; 255
    6128:	25 96       	adiw	r28, 0x05	; 5
    612a:	8c af       	sts	0x7c, r24
    612c:	9d af       	sts	0x7d, r25
    612e:	ae af       	sts	0x7e, r26
    6130:	bf af       	sts	0x7f, r27
    6132:	25 97       	sbiw	r28, 0x05	; 5
    6134:	06 c0       	rjmp	.+12     	; 0x6142 <__divdi3+0x114>
    6136:	25 96       	adiw	r28, 0x05	; 5
    6138:	1c ae       	sts	0xbc, r17
    613a:	1d ae       	sts	0xbd, r17
    613c:	1e ae       	sts	0xbe, r17
    613e:	1f ae       	sts	0xbf, r17
    6140:	25 97       	sbiw	r28, 0x05	; 5
    6142:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6144:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6146:	af 8d       	ldd	r26, Y+31	; 0x1f
    6148:	b8 a1       	lds	r27, 0x48
    614a:	b7 ff       	sbrs	r27, 7
    614c:	68 c0       	rjmp	.+208    	; 0x621e <__divdi3+0x1f0>
    614e:	25 96       	adiw	r28, 0x05	; 5
    6150:	2c ad       	sts	0x6c, r18
    6152:	3d ad       	sts	0x6d, r19
    6154:	4e ad       	sts	0x6e, r20
    6156:	5f ad       	sts	0x6f, r21
    6158:	25 97       	sbiw	r28, 0x05	; 5
    615a:	20 95       	com	r18
    615c:	30 95       	com	r19
    615e:	40 95       	com	r20
    6160:	50 95       	com	r21
    6162:	25 96       	adiw	r28, 0x05	; 5
    6164:	2c af       	sts	0x7c, r18
    6166:	3d af       	sts	0x7d, r19
    6168:	4e af       	sts	0x7e, r20
    616a:	5f af       	sts	0x7f, r21
    616c:	25 97       	sbiw	r28, 0x05	; 5
    616e:	e1 95       	neg	r30
    6170:	81 e0       	ldi	r24, 0x01	; 1
    6172:	1e 16       	cp	r1, r30
    6174:	08 f0       	brcs	.+2      	; 0x6178 <__divdi3+0x14a>
    6176:	80 e0       	ldi	r24, 0x00	; 0
    6178:	f1 95       	neg	r31
    617a:	91 e0       	ldi	r25, 0x01	; 1
    617c:	1f 16       	cp	r1, r31
    617e:	08 f0       	brcs	.+2      	; 0x6182 <__divdi3+0x154>
    6180:	90 e0       	ldi	r25, 0x00	; 0
    6182:	4f 2f       	mov	r20, r31
    6184:	48 1b       	sub	r20, r24
    6186:	81 e0       	ldi	r24, 0x01	; 1
    6188:	f4 17       	cp	r31, r20
    618a:	08 f0       	brcs	.+2      	; 0x618e <__divdi3+0x160>
    618c:	80 e0       	ldi	r24, 0x00	; 0
    618e:	98 2b       	or	r25, r24
    6190:	c1 94       	neg	r12
    6192:	81 e0       	ldi	r24, 0x01	; 1
    6194:	1c 14       	cp	r1, r12
    6196:	08 f0       	brcs	.+2      	; 0x619a <__divdi3+0x16c>
    6198:	80 e0       	ldi	r24, 0x00	; 0
    619a:	6c 2d       	mov	r22, r12
    619c:	69 1b       	sub	r22, r25
    619e:	91 e0       	ldi	r25, 0x01	; 1
    61a0:	c6 16       	cp	r12, r22
    61a2:	08 f0       	brcs	.+2      	; 0x61a6 <__divdi3+0x178>
    61a4:	90 e0       	ldi	r25, 0x00	; 0
    61a6:	89 2b       	or	r24, r25
    61a8:	d1 94       	neg	r13
    61aa:	91 e0       	ldi	r25, 0x01	; 1
    61ac:	1d 14       	cp	r1, r13
    61ae:	08 f0       	brcs	.+2      	; 0x61b2 <__divdi3+0x184>
    61b0:	90 e0       	ldi	r25, 0x00	; 0
    61b2:	5d 2d       	mov	r21, r13
    61b4:	58 1b       	sub	r21, r24
    61b6:	81 e0       	ldi	r24, 0x01	; 1
    61b8:	d5 16       	cp	r13, r21
    61ba:	08 f0       	brcs	.+2      	; 0x61be <__divdi3+0x190>
    61bc:	80 e0       	ldi	r24, 0x00	; 0
    61be:	98 2b       	or	r25, r24
    61c0:	e1 94       	neg	r14
    61c2:	81 e0       	ldi	r24, 0x01	; 1
    61c4:	1e 14       	cp	r1, r14
    61c6:	08 f0       	brcs	.+2      	; 0x61ca <__divdi3+0x19c>
    61c8:	80 e0       	ldi	r24, 0x00	; 0
    61ca:	3e 2d       	mov	r19, r14
    61cc:	39 1b       	sub	r19, r25
    61ce:	91 e0       	ldi	r25, 0x01	; 1
    61d0:	e3 16       	cp	r14, r19
    61d2:	08 f0       	brcs	.+2      	; 0x61d6 <__divdi3+0x1a8>
    61d4:	90 e0       	ldi	r25, 0x00	; 0
    61d6:	89 2b       	or	r24, r25
    61d8:	f1 94       	neg	r15
    61da:	91 e0       	ldi	r25, 0x01	; 1
    61dc:	1f 14       	cp	r1, r15
    61de:	08 f0       	brcs	.+2      	; 0x61e2 <__divdi3+0x1b4>
    61e0:	90 e0       	ldi	r25, 0x00	; 0
    61e2:	2f 2d       	mov	r18, r15
    61e4:	28 1b       	sub	r18, r24
    61e6:	81 e0       	ldi	r24, 0x01	; 1
    61e8:	f2 16       	cp	r15, r18
    61ea:	08 f0       	brcs	.+2      	; 0x61ee <__divdi3+0x1c0>
    61ec:	80 e0       	ldi	r24, 0x00	; 0
    61ee:	98 2b       	or	r25, r24
    61f0:	01 95       	neg	r16
    61f2:	81 e0       	ldi	r24, 0x01	; 1
    61f4:	10 16       	cp	r1, r16
    61f6:	08 f0       	brcs	.+2      	; 0x61fa <__divdi3+0x1cc>
    61f8:	80 e0       	ldi	r24, 0x00	; 0
    61fa:	70 2f       	mov	r23, r16
    61fc:	79 1b       	sub	r23, r25
    61fe:	97 2f       	mov	r25, r23
    6200:	71 e0       	ldi	r23, 0x01	; 1
    6202:	09 17       	cp	r16, r25
    6204:	08 f0       	brcs	.+2      	; 0x6208 <__divdi3+0x1da>
    6206:	70 e0       	ldi	r23, 0x00	; 0
    6208:	87 2b       	or	r24, r23
    620a:	11 95       	neg	r17
    620c:	18 1b       	sub	r17, r24
    620e:	e9 8f       	std	Y+25, r30	; 0x19
    6210:	4a 8f       	std	Y+26, r20	; 0x1a
    6212:	6b 8f       	std	Y+27, r22	; 0x1b
    6214:	5c 8f       	std	Y+28, r21	; 0x1c
    6216:	3d 8f       	std	Y+29, r19	; 0x1d
    6218:	2e 8f       	std	Y+30, r18	; 0x1e
    621a:	9f 8f       	std	Y+31, r25	; 0x1f
    621c:	18 a3       	lds	r17, 0x58
    621e:	79 8d       	ldd	r23, Y+25	; 0x19
    6220:	6a 8d       	ldd	r22, Y+26	; 0x1a
    6222:	5b 8d       	ldd	r21, Y+27	; 0x1b
    6224:	4c 8d       	ldd	r20, Y+28	; 0x1c
    6226:	3d 8d       	ldd	r19, Y+29	; 0x1d
    6228:	2e 8d       	ldd	r18, Y+30	; 0x1e
    622a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    622c:	88 a1       	lds	r24, 0x48
    622e:	e9 a1       	lds	r30, 0x49
    6230:	e9 8b       	std	Y+17, r30	; 0x11
    6232:	ea a1       	lds	r30, 0x4a
    6234:	ea 8b       	std	Y+18, r30	; 0x12
    6236:	eb a1       	lds	r30, 0x4b
    6238:	eb 8b       	std	Y+19, r30	; 0x13
    623a:	ec a1       	lds	r30, 0x4c
    623c:	ec 8b       	std	Y+20, r30	; 0x14
    623e:	ed a1       	lds	r30, 0x4d
    6240:	ed 8b       	std	Y+21, r30	; 0x15
    6242:	ee a1       	lds	r30, 0x4e
    6244:	ee 8b       	std	Y+22, r30	; 0x16
    6246:	ef a1       	lds	r30, 0x4f
    6248:	ef 8b       	std	Y+23, r30	; 0x17
    624a:	e8 a5       	lds	r30, 0x68
    624c:	e8 8f       	std	Y+24, r30	; 0x18
    624e:	79 87       	std	Y+9, r23	; 0x09
    6250:	6a 87       	std	Y+10, r22	; 0x0a
    6252:	5b 87       	std	Y+11, r21	; 0x0b
    6254:	4c 87       	std	Y+12, r20	; 0x0c
    6256:	3d 87       	std	Y+13, r19	; 0x0d
    6258:	2e 87       	std	Y+14, r18	; 0x0e
    625a:	9f 87       	std	Y+15, r25	; 0x0f
    625c:	88 8b       	std	Y+16, r24	; 0x10
    625e:	89 84       	ldd	r8, Y+9	; 0x09
    6260:	9a 84       	ldd	r9, Y+10	; 0x0a
    6262:	ab 84       	ldd	r10, Y+11	; 0x0b
    6264:	bc 84       	ldd	r11, Y+12	; 0x0c
    6266:	8d 85       	ldd	r24, Y+13	; 0x0d
    6268:	9e 85       	ldd	r25, Y+14	; 0x0e
    626a:	af 85       	ldd	r26, Y+15	; 0x0f
    626c:	b8 89       	ldd	r27, Y+16	; 0x10
    626e:	e9 88       	ldd	r14, Y+17	; 0x11
    6270:	fa 88       	ldd	r15, Y+18	; 0x12
    6272:	0b 89       	ldd	r16, Y+19	; 0x13
    6274:	1c 89       	ldd	r17, Y+20	; 0x14
    6276:	ed aa       	sts	0x9d, r30
    6278:	fe aa       	sts	0x9e, r31
    627a:	0f ab       	sts	0x5f, r16
    627c:	18 af       	sts	0x78, r17
    627e:	cd 88       	ldd	r12, Y+21	; 0x15
    6280:	de 88       	ldd	r13, Y+22	; 0x16
    6282:	ef 88       	ldd	r14, Y+23	; 0x17
    6284:	f8 8c       	ldd	r15, Y+24	; 0x18
    6286:	00 97       	sbiw	r24, 0x00	; 0
    6288:	a1 05       	cpc	r26, r1
    628a:	b1 05       	cpc	r27, r1
    628c:	09 f0       	breq	.+2      	; 0x6290 <__divdi3+0x262>
    628e:	bd c3       	rjmp	.+1914   	; 0x6a0a <__divdi3+0x9dc>
    6290:	c8 14       	cp	r12, r8
    6292:	d9 04       	cpc	r13, r9
    6294:	ea 04       	cpc	r14, r10
    6296:	fb 04       	cpc	r15, r11
    6298:	08 f0       	brcs	.+2      	; 0x629c <__divdi3+0x26e>
    629a:	4d c1       	rjmp	.+666    	; 0x6536 <__divdi3+0x508>
    629c:	00 e0       	ldi	r16, 0x00	; 0
    629e:	80 16       	cp	r8, r16
    62a0:	00 e0       	ldi	r16, 0x00	; 0
    62a2:	90 06       	cpc	r9, r16
    62a4:	01 e0       	ldi	r16, 0x01	; 1
    62a6:	a0 06       	cpc	r10, r16
    62a8:	00 e0       	ldi	r16, 0x00	; 0
    62aa:	b0 06       	cpc	r11, r16
    62ac:	58 f4       	brcc	.+22     	; 0x62c4 <__divdi3+0x296>
    62ae:	1f ef       	ldi	r17, 0xFF	; 255
    62b0:	81 16       	cp	r8, r17
    62b2:	91 04       	cpc	r9, r1
    62b4:	a1 04       	cpc	r10, r1
    62b6:	b1 04       	cpc	r11, r1
    62b8:	09 f0       	breq	.+2      	; 0x62bc <__divdi3+0x28e>
    62ba:	90 f4       	brcc	.+36     	; 0x62e0 <__divdi3+0x2b2>
    62bc:	80 e0       	ldi	r24, 0x00	; 0
    62be:	90 e0       	ldi	r25, 0x00	; 0
    62c0:	dc 01       	movw	r26, r24
    62c2:	17 c0       	rjmp	.+46     	; 0x62f2 <__divdi3+0x2c4>
    62c4:	20 e0       	ldi	r18, 0x00	; 0
    62c6:	82 16       	cp	r8, r18
    62c8:	20 e0       	ldi	r18, 0x00	; 0
    62ca:	92 06       	cpc	r9, r18
    62cc:	20 e0       	ldi	r18, 0x00	; 0
    62ce:	a2 06       	cpc	r10, r18
    62d0:	21 e0       	ldi	r18, 0x01	; 1
    62d2:	b2 06       	cpc	r11, r18
    62d4:	50 f4       	brcc	.+20     	; 0x62ea <__divdi3+0x2bc>
    62d6:	80 e1       	ldi	r24, 0x10	; 16
    62d8:	90 e0       	ldi	r25, 0x00	; 0
    62da:	a0 e0       	ldi	r26, 0x00	; 0
    62dc:	b0 e0       	ldi	r27, 0x00	; 0
    62de:	09 c0       	rjmp	.+18     	; 0x62f2 <__divdi3+0x2c4>
    62e0:	88 e0       	ldi	r24, 0x08	; 8
    62e2:	90 e0       	ldi	r25, 0x00	; 0
    62e4:	a0 e0       	ldi	r26, 0x00	; 0
    62e6:	b0 e0       	ldi	r27, 0x00	; 0
    62e8:	04 c0       	rjmp	.+8      	; 0x62f2 <__divdi3+0x2c4>
    62ea:	88 e1       	ldi	r24, 0x18	; 24
    62ec:	90 e0       	ldi	r25, 0x00	; 0
    62ee:	a0 e0       	ldi	r26, 0x00	; 0
    62f0:	b0 e0       	ldi	r27, 0x00	; 0
    62f2:	b5 01       	movw	r22, r10
    62f4:	a4 01       	movw	r20, r8
    62f6:	08 2e       	mov	r0, r24
    62f8:	04 c0       	rjmp	.+8      	; 0x6302 <__divdi3+0x2d4>
    62fa:	76 95       	lsr	r23
    62fc:	67 95       	ror	r22
    62fe:	57 95       	ror	r21
    6300:	47 95       	ror	r20
    6302:	0a 94       	dec	r0
    6304:	d2 f7       	brpl	.-12     	; 0x62fa <__divdi3+0x2cc>
    6306:	fa 01       	movw	r30, r20
    6308:	e3 5f       	subi	r30, 0xF3	; 243
    630a:	ff 4d       	sbci	r31, 0xDF	; 223
    630c:	20 81       	ld	r18, Z
    630e:	40 e2       	ldi	r20, 0x20	; 32
    6310:	50 e0       	ldi	r21, 0x00	; 0
    6312:	60 e0       	ldi	r22, 0x00	; 0
    6314:	70 e0       	ldi	r23, 0x00	; 0
    6316:	48 1b       	sub	r20, r24
    6318:	59 0b       	sbc	r21, r25
    631a:	6a 0b       	sbc	r22, r26
    631c:	7b 0b       	sbc	r23, r27
    631e:	42 1b       	sub	r20, r18
    6320:	51 09       	sbc	r21, r1
    6322:	61 09       	sbc	r22, r1
    6324:	71 09       	sbc	r23, r1
    6326:	41 15       	cp	r20, r1
    6328:	51 05       	cpc	r21, r1
    632a:	61 05       	cpc	r22, r1
    632c:	71 05       	cpc	r23, r1
    632e:	a1 f1       	breq	.+104    	; 0x6398 <__divdi3+0x36a>
    6330:	04 2e       	mov	r0, r20
    6332:	04 c0       	rjmp	.+8      	; 0x633c <__divdi3+0x30e>
    6334:	88 0c       	add	r8, r8
    6336:	99 1c       	adc	r9, r9
    6338:	aa 1c       	adc	r10, r10
    633a:	bb 1c       	adc	r11, r11
    633c:	0a 94       	dec	r0
    633e:	d2 f7       	brpl	.-12     	; 0x6334 <__divdi3+0x306>
    6340:	97 01       	movw	r18, r14
    6342:	86 01       	movw	r16, r12
    6344:	04 2e       	mov	r0, r20
    6346:	04 c0       	rjmp	.+8      	; 0x6350 <__divdi3+0x322>
    6348:	00 0f       	add	r16, r16
    634a:	11 1f       	adc	r17, r17
    634c:	22 1f       	adc	r18, r18
    634e:	33 1f       	adc	r19, r19
    6350:	0a 94       	dec	r0
    6352:	d2 f7       	brpl	.-12     	; 0x6348 <__divdi3+0x31a>
    6354:	80 e2       	ldi	r24, 0x20	; 32
    6356:	90 e0       	ldi	r25, 0x00	; 0
    6358:	84 1b       	sub	r24, r20
    635a:	95 0b       	sbc	r25, r21
    635c:	cd a8       	sts	0x8d, r28
    635e:	de a8       	sts	0x8e, r29
    6360:	ef a8       	sts	0x8f, r30
    6362:	f8 ac       	sts	0xa8, r31
    6364:	04 c0       	rjmp	.+8      	; 0x636e <__divdi3+0x340>
    6366:	f6 94       	lsr	r15
    6368:	e7 94       	ror	r14
    636a:	d7 94       	ror	r13
    636c:	c7 94       	ror	r12
    636e:	8a 95       	dec	r24
    6370:	d2 f7       	brpl	.-12     	; 0x6366 <__divdi3+0x338>
    6372:	c0 2a       	or	r12, r16
    6374:	d1 2a       	or	r13, r17
    6376:	e2 2a       	or	r14, r18
    6378:	f3 2a       	or	r15, r19
    637a:	0d a9       	sts	0x4d, r16
    637c:	1e a9       	sts	0x4e, r17
    637e:	2f a9       	sts	0x4f, r18
    6380:	38 ad       	sts	0x68, r19
    6382:	04 c0       	rjmp	.+8      	; 0x638c <__divdi3+0x35e>
    6384:	00 0f       	add	r16, r16
    6386:	11 1f       	adc	r17, r17
    6388:	22 1f       	adc	r18, r18
    638a:	33 1f       	adc	r19, r19
    638c:	4a 95       	dec	r20
    638e:	d2 f7       	brpl	.-12     	; 0x6384 <__divdi3+0x356>
    6390:	0d ab       	sts	0x5d, r16
    6392:	1e ab       	sts	0x5e, r17
    6394:	2f ab       	sts	0x5f, r18
    6396:	38 af       	sts	0x78, r19
    6398:	25 01       	movw	r4, r10
    639a:	66 24       	eor	r6, r6
    639c:	77 24       	eor	r7, r7
    639e:	95 01       	movw	r18, r10
    63a0:	84 01       	movw	r16, r8
    63a2:	20 70       	andi	r18, 0x00	; 0
    63a4:	30 70       	andi	r19, 0x00	; 0
    63a6:	09 ab       	sts	0x59, r16
    63a8:	1a ab       	sts	0x5a, r17
    63aa:	2b ab       	sts	0x5b, r18
    63ac:	3c ab       	sts	0x5c, r19
    63ae:	c7 01       	movw	r24, r14
    63b0:	b6 01       	movw	r22, r12
    63b2:	a3 01       	movw	r20, r6
    63b4:	92 01       	movw	r18, r4
    63b6:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    63ba:	2d a7       	lds	r18, 0x7d
    63bc:	3e a7       	lds	r19, 0x7e
    63be:	4f a7       	lds	r20, 0x7f
    63c0:	58 ab       	sts	0x58, r21
    63c2:	69 a7       	lds	r22, 0x79
    63c4:	7a a7       	lds	r23, 0x7a
    63c6:	8b a7       	lds	r24, 0x7b
    63c8:	9c a7       	lds	r25, 0x7c
    63ca:	c7 01       	movw	r24, r14
    63cc:	b6 01       	movw	r22, r12
    63ce:	a3 01       	movw	r20, r6
    63d0:	92 01       	movw	r18, r4
    63d2:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    63d6:	ca 01       	movw	r24, r20
    63d8:	b9 01       	movw	r22, r18
    63da:	29 a9       	sts	0x49, r18
    63dc:	3a a9       	sts	0x4a, r19
    63de:	4b a9       	sts	0x4b, r20
    63e0:	5c a9       	sts	0x4c, r21
    63e2:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    63e6:	ab 01       	movw	r20, r22
    63e8:	bc 01       	movw	r22, r24
    63ea:	09 a5       	lds	r16, 0x69
    63ec:	1a a5       	lds	r17, 0x6a
    63ee:	2b a5       	lds	r18, 0x6b
    63f0:	3c a5       	lds	r19, 0x6c
    63f2:	78 01       	movw	r14, r16
    63f4:	dd 24       	eor	r13, r13
    63f6:	cc 24       	eor	r12, r12
    63f8:	0d a9       	sts	0x4d, r16
    63fa:	1e a9       	sts	0x4e, r17
    63fc:	2f a9       	sts	0x4f, r18
    63fe:	38 ad       	sts	0x68, r19
    6400:	c9 01       	movw	r24, r18
    6402:	aa 27       	eor	r26, r26
    6404:	bb 27       	eor	r27, r27
    6406:	c8 2a       	or	r12, r24
    6408:	d9 2a       	or	r13, r25
    640a:	ea 2a       	or	r14, r26
    640c:	fb 2a       	or	r15, r27
    640e:	0d a5       	lds	r16, 0x6d
    6410:	1e a5       	lds	r17, 0x6e
    6412:	2f a5       	lds	r18, 0x6f
    6414:	38 a9       	sts	0x48, r19
    6416:	c4 16       	cp	r12, r20
    6418:	d5 06       	cpc	r13, r21
    641a:	e6 06       	cpc	r14, r22
    641c:	f7 06       	cpc	r15, r23
    641e:	38 f5       	brcc	.+78     	; 0x646e <__divdi3+0x440>
    6420:	01 50       	subi	r16, 0x01	; 1
    6422:	10 40       	sbci	r17, 0x00	; 0
    6424:	20 40       	sbci	r18, 0x00	; 0
    6426:	30 40       	sbci	r19, 0x00	; 0
    6428:	09 a7       	lds	r16, 0x79
    642a:	1a a7       	lds	r17, 0x7a
    642c:	2b a7       	lds	r18, 0x7b
    642e:	3c a7       	lds	r19, 0x7c
    6430:	c8 0c       	add	r12, r8
    6432:	d9 1c       	adc	r13, r9
    6434:	ea 1c       	adc	r14, r10
    6436:	fb 1c       	adc	r15, r11
    6438:	c8 14       	cp	r12, r8
    643a:	d9 04       	cpc	r13, r9
    643c:	ea 04       	cpc	r14, r10
    643e:	fb 04       	cpc	r15, r11
    6440:	d0 f0       	brcs	.+52     	; 0x6476 <__divdi3+0x448>
    6442:	c4 16       	cp	r12, r20
    6444:	d5 06       	cpc	r13, r21
    6446:	e6 06       	cpc	r14, r22
    6448:	f7 06       	cpc	r15, r23
    644a:	a8 f4       	brcc	.+42     	; 0x6476 <__divdi3+0x448>
    644c:	0d a5       	lds	r16, 0x6d
    644e:	1e a5       	lds	r17, 0x6e
    6450:	2f a5       	lds	r18, 0x6f
    6452:	38 a9       	sts	0x48, r19
    6454:	02 50       	subi	r16, 0x02	; 2
    6456:	10 40       	sbci	r17, 0x00	; 0
    6458:	20 40       	sbci	r18, 0x00	; 0
    645a:	30 40       	sbci	r19, 0x00	; 0
    645c:	09 a7       	lds	r16, 0x79
    645e:	1a a7       	lds	r17, 0x7a
    6460:	2b a7       	lds	r18, 0x7b
    6462:	3c a7       	lds	r19, 0x7c
    6464:	c8 0c       	add	r12, r8
    6466:	d9 1c       	adc	r13, r9
    6468:	ea 1c       	adc	r14, r10
    646a:	fb 1c       	adc	r15, r11
    646c:	04 c0       	rjmp	.+8      	; 0x6476 <__divdi3+0x448>
    646e:	09 a7       	lds	r16, 0x79
    6470:	1a a7       	lds	r17, 0x7a
    6472:	2b a7       	lds	r18, 0x7b
    6474:	3c a7       	lds	r19, 0x7c
    6476:	c4 1a       	sub	r12, r20
    6478:	d5 0a       	sbc	r13, r21
    647a:	e6 0a       	sbc	r14, r22
    647c:	f7 0a       	sbc	r15, r23
    647e:	c7 01       	movw	r24, r14
    6480:	b6 01       	movw	r22, r12
    6482:	a3 01       	movw	r20, r6
    6484:	92 01       	movw	r18, r4
    6486:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    648a:	2d a7       	lds	r18, 0x7d
    648c:	3e a7       	lds	r19, 0x7e
    648e:	4f a7       	lds	r20, 0x7f
    6490:	58 ab       	sts	0x58, r21
    6492:	69 af       	sts	0x79, r22
    6494:	7a af       	sts	0x7a, r23
    6496:	8b af       	sts	0x7b, r24
    6498:	9c af       	sts	0x7c, r25
    649a:	c7 01       	movw	r24, r14
    649c:	b6 01       	movw	r22, r12
    649e:	a3 01       	movw	r20, r6
    64a0:	92 01       	movw	r18, r4
    64a2:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    64a6:	ca 01       	movw	r24, r20
    64a8:	b9 01       	movw	r22, r18
    64aa:	29 a9       	sts	0x49, r18
    64ac:	3a a9       	sts	0x4a, r19
    64ae:	4b a9       	sts	0x4b, r20
    64b0:	5c a9       	sts	0x4c, r21
    64b2:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    64b6:	6b 01       	movw	r12, r22
    64b8:	7c 01       	movw	r14, r24
    64ba:	49 ad       	sts	0x69, r20
    64bc:	5a ad       	sts	0x6a, r21
    64be:	6b ad       	sts	0x6b, r22
    64c0:	7c ad       	sts	0x6c, r23
    64c2:	9a 01       	movw	r18, r20
    64c4:	11 27       	eor	r17, r17
    64c6:	00 27       	eor	r16, r16
    64c8:	4d a9       	sts	0x4d, r20
    64ca:	5e a9       	sts	0x4e, r21
    64cc:	6f a9       	sts	0x4f, r22
    64ce:	78 ad       	sts	0x68, r23
    64d0:	60 70       	andi	r22, 0x00	; 0
    64d2:	70 70       	andi	r23, 0x00	; 0
    64d4:	04 2b       	or	r16, r20
    64d6:	15 2b       	or	r17, r21
    64d8:	26 2b       	or	r18, r22
    64da:	37 2b       	or	r19, r23
    64dc:	8d a5       	lds	r24, 0x6d
    64de:	9e a5       	lds	r25, 0x6e
    64e0:	af a5       	lds	r26, 0x6f
    64e2:	b8 a9       	sts	0x48, r27
    64e4:	0c 15       	cp	r16, r12
    64e6:	1d 05       	cpc	r17, r13
    64e8:	2e 05       	cpc	r18, r14
    64ea:	3f 05       	cpc	r19, r15
    64ec:	c0 f4       	brcc	.+48     	; 0x651e <__divdi3+0x4f0>
    64ee:	01 97       	sbiw	r24, 0x01	; 1
    64f0:	a1 09       	sbc	r26, r1
    64f2:	b1 09       	sbc	r27, r1
    64f4:	08 0d       	add	r16, r8
    64f6:	19 1d       	adc	r17, r9
    64f8:	2a 1d       	adc	r18, r10
    64fa:	3b 1d       	adc	r19, r11
    64fc:	08 15       	cp	r16, r8
    64fe:	19 05       	cpc	r17, r9
    6500:	2a 05       	cpc	r18, r10
    6502:	3b 05       	cpc	r19, r11
    6504:	60 f0       	brcs	.+24     	; 0x651e <__divdi3+0x4f0>
    6506:	0c 15       	cp	r16, r12
    6508:	1d 05       	cpc	r17, r13
    650a:	2e 05       	cpc	r18, r14
    650c:	3f 05       	cpc	r19, r15
    650e:	38 f4       	brcc	.+14     	; 0x651e <__divdi3+0x4f0>
    6510:	8d a5       	lds	r24, 0x6d
    6512:	9e a5       	lds	r25, 0x6e
    6514:	af a5       	lds	r26, 0x6f
    6516:	b8 a9       	sts	0x48, r27
    6518:	02 97       	sbiw	r24, 0x02	; 2
    651a:	a1 09       	sbc	r26, r1
    651c:	b1 09       	sbc	r27, r1
    651e:	09 a5       	lds	r16, 0x69
    6520:	1a a5       	lds	r17, 0x6a
    6522:	2b a5       	lds	r18, 0x6b
    6524:	3c a5       	lds	r19, 0x6c
    6526:	78 01       	movw	r14, r16
    6528:	dd 24       	eor	r13, r13
    652a:	cc 24       	eor	r12, r12
    652c:	c8 2a       	or	r12, r24
    652e:	d9 2a       	or	r13, r25
    6530:	ea 2a       	or	r14, r26
    6532:	fb 2a       	or	r15, r27
    6534:	b7 c4       	rjmp	.+2414   	; 0x6ea4 <__divdi3+0xe76>
    6536:	81 14       	cp	r8, r1
    6538:	91 04       	cpc	r9, r1
    653a:	a1 04       	cpc	r10, r1
    653c:	b1 04       	cpc	r11, r1
    653e:	51 f4       	brne	.+20     	; 0x6554 <__divdi3+0x526>
    6540:	61 e0       	ldi	r22, 0x01	; 1
    6542:	70 e0       	ldi	r23, 0x00	; 0
    6544:	80 e0       	ldi	r24, 0x00	; 0
    6546:	90 e0       	ldi	r25, 0x00	; 0
    6548:	a5 01       	movw	r20, r10
    654a:	94 01       	movw	r18, r8
    654c:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    6550:	49 01       	movw	r8, r18
    6552:	5a 01       	movw	r10, r20
    6554:	10 e0       	ldi	r17, 0x00	; 0
    6556:	81 16       	cp	r8, r17
    6558:	10 e0       	ldi	r17, 0x00	; 0
    655a:	91 06       	cpc	r9, r17
    655c:	11 e0       	ldi	r17, 0x01	; 1
    655e:	a1 06       	cpc	r10, r17
    6560:	10 e0       	ldi	r17, 0x00	; 0
    6562:	b1 06       	cpc	r11, r17
    6564:	58 f4       	brcc	.+22     	; 0x657c <__divdi3+0x54e>
    6566:	2f ef       	ldi	r18, 0xFF	; 255
    6568:	82 16       	cp	r8, r18
    656a:	91 04       	cpc	r9, r1
    656c:	a1 04       	cpc	r10, r1
    656e:	b1 04       	cpc	r11, r1
    6570:	09 f0       	breq	.+2      	; 0x6574 <__divdi3+0x546>
    6572:	90 f4       	brcc	.+36     	; 0x6598 <__divdi3+0x56a>
    6574:	80 e0       	ldi	r24, 0x00	; 0
    6576:	90 e0       	ldi	r25, 0x00	; 0
    6578:	dc 01       	movw	r26, r24
    657a:	17 c0       	rjmp	.+46     	; 0x65aa <__divdi3+0x57c>
    657c:	30 e0       	ldi	r19, 0x00	; 0
    657e:	83 16       	cp	r8, r19
    6580:	30 e0       	ldi	r19, 0x00	; 0
    6582:	93 06       	cpc	r9, r19
    6584:	30 e0       	ldi	r19, 0x00	; 0
    6586:	a3 06       	cpc	r10, r19
    6588:	31 e0       	ldi	r19, 0x01	; 1
    658a:	b3 06       	cpc	r11, r19
    658c:	50 f4       	brcc	.+20     	; 0x65a2 <__divdi3+0x574>
    658e:	80 e1       	ldi	r24, 0x10	; 16
    6590:	90 e0       	ldi	r25, 0x00	; 0
    6592:	a0 e0       	ldi	r26, 0x00	; 0
    6594:	b0 e0       	ldi	r27, 0x00	; 0
    6596:	09 c0       	rjmp	.+18     	; 0x65aa <__divdi3+0x57c>
    6598:	88 e0       	ldi	r24, 0x08	; 8
    659a:	90 e0       	ldi	r25, 0x00	; 0
    659c:	a0 e0       	ldi	r26, 0x00	; 0
    659e:	b0 e0       	ldi	r27, 0x00	; 0
    65a0:	04 c0       	rjmp	.+8      	; 0x65aa <__divdi3+0x57c>
    65a2:	88 e1       	ldi	r24, 0x18	; 24
    65a4:	90 e0       	ldi	r25, 0x00	; 0
    65a6:	a0 e0       	ldi	r26, 0x00	; 0
    65a8:	b0 e0       	ldi	r27, 0x00	; 0
    65aa:	b5 01       	movw	r22, r10
    65ac:	a4 01       	movw	r20, r8
    65ae:	08 2e       	mov	r0, r24
    65b0:	04 c0       	rjmp	.+8      	; 0x65ba <__divdi3+0x58c>
    65b2:	76 95       	lsr	r23
    65b4:	67 95       	ror	r22
    65b6:	57 95       	ror	r21
    65b8:	47 95       	ror	r20
    65ba:	0a 94       	dec	r0
    65bc:	d2 f7       	brpl	.-12     	; 0x65b2 <__divdi3+0x584>
    65be:	fa 01       	movw	r30, r20
    65c0:	e3 5f       	subi	r30, 0xF3	; 243
    65c2:	ff 4d       	sbci	r31, 0xDF	; 223
    65c4:	20 81       	ld	r18, Z
    65c6:	ac 01       	movw	r20, r24
    65c8:	bd 01       	movw	r22, r26
    65ca:	42 0f       	add	r20, r18
    65cc:	51 1d       	adc	r21, r1
    65ce:	61 1d       	adc	r22, r1
    65d0:	71 1d       	adc	r23, r1
    65d2:	80 e2       	ldi	r24, 0x20	; 32
    65d4:	90 e0       	ldi	r25, 0x00	; 0
    65d6:	a0 e0       	ldi	r26, 0x00	; 0
    65d8:	b0 e0       	ldi	r27, 0x00	; 0
    65da:	84 1b       	sub	r24, r20
    65dc:	95 0b       	sbc	r25, r21
    65de:	a6 0b       	sbc	r26, r22
    65e0:	b7 0b       	sbc	r27, r23
    65e2:	51 f4       	brne	.+20     	; 0x65f8 <__divdi3+0x5ca>
    65e4:	c8 18       	sub	r12, r8
    65e6:	d9 08       	sbc	r13, r9
    65e8:	ea 08       	sbc	r14, r10
    65ea:	fb 08       	sbc	r15, r11
    65ec:	f1 e0       	ldi	r31, 0x01	; 1
    65ee:	4f 2e       	mov	r4, r31
    65f0:	51 2c       	mov	r5, r1
    65f2:	61 2c       	mov	r6, r1
    65f4:	71 2c       	mov	r7, r1
    65f6:	28 c1       	rjmp	.+592    	; 0x6848 <__divdi3+0x81a>
    65f8:	08 2e       	mov	r0, r24
    65fa:	04 c0       	rjmp	.+8      	; 0x6604 <__divdi3+0x5d6>
    65fc:	88 0c       	add	r8, r8
    65fe:	99 1c       	adc	r9, r9
    6600:	aa 1c       	adc	r10, r10
    6602:	bb 1c       	adc	r11, r11
    6604:	0a 94       	dec	r0
    6606:	d2 f7       	brpl	.-12     	; 0x65fc <__divdi3+0x5ce>
    6608:	97 01       	movw	r18, r14
    660a:	86 01       	movw	r16, r12
    660c:	04 2e       	mov	r0, r20
    660e:	04 c0       	rjmp	.+8      	; 0x6618 <__divdi3+0x5ea>
    6610:	36 95       	lsr	r19
    6612:	27 95       	ror	r18
    6614:	17 95       	ror	r17
    6616:	07 95       	ror	r16
    6618:	0a 94       	dec	r0
    661a:	d2 f7       	brpl	.-12     	; 0x6610 <__divdi3+0x5e2>
    661c:	09 ab       	sts	0x59, r16
    661e:	1a ab       	sts	0x5a, r17
    6620:	2b ab       	sts	0x5b, r18
    6622:	3c ab       	sts	0x5c, r19
    6624:	97 01       	movw	r18, r14
    6626:	86 01       	movw	r16, r12
    6628:	08 2e       	mov	r0, r24
    662a:	04 c0       	rjmp	.+8      	; 0x6634 <__divdi3+0x606>
    662c:	00 0f       	add	r16, r16
    662e:	11 1f       	adc	r17, r17
    6630:	22 1f       	adc	r18, r18
    6632:	33 1f       	adc	r19, r19
    6634:	0a 94       	dec	r0
    6636:	d2 f7       	brpl	.-12     	; 0x662c <__divdi3+0x5fe>
    6638:	0d a7       	lds	r16, 0x7d
    663a:	1e a7       	lds	r17, 0x7e
    663c:	2f a7       	lds	r18, 0x7f
    663e:	38 ab       	sts	0x58, r19
    6640:	ed a8       	sts	0x8d, r30
    6642:	fe a8       	sts	0x8e, r31
    6644:	0f a9       	sts	0x4f, r16
    6646:	18 ad       	sts	0x68, r17
    6648:	04 c0       	rjmp	.+8      	; 0x6652 <__divdi3+0x624>
    664a:	16 95       	lsr	r17
    664c:	07 95       	ror	r16
    664e:	f7 94       	ror	r15
    6650:	e7 94       	ror	r14
    6652:	4a 95       	dec	r20
    6654:	d2 f7       	brpl	.-12     	; 0x664a <__divdi3+0x61c>
    6656:	b8 01       	movw	r22, r16
    6658:	a7 01       	movw	r20, r14
    665a:	0d a5       	lds	r16, 0x6d
    665c:	1e a5       	lds	r17, 0x6e
    665e:	2f a5       	lds	r18, 0x6f
    6660:	38 a9       	sts	0x48, r19
    6662:	04 2b       	or	r16, r20
    6664:	15 2b       	or	r17, r21
    6666:	26 2b       	or	r18, r22
    6668:	37 2b       	or	r19, r23
    666a:	0d a7       	lds	r16, 0x7d
    666c:	1e a7       	lds	r17, 0x7e
    666e:	2f a7       	lds	r18, 0x7f
    6670:	38 ab       	sts	0x58, r19
    6672:	ed a8       	sts	0x8d, r30
    6674:	fe a8       	sts	0x8e, r31
    6676:	0f a9       	sts	0x4f, r16
    6678:	18 ad       	sts	0x68, r17
    667a:	04 c0       	rjmp	.+8      	; 0x6684 <__divdi3+0x656>
    667c:	ee 0c       	add	r14, r14
    667e:	ff 1c       	adc	r15, r15
    6680:	00 1f       	adc	r16, r16
    6682:	11 1f       	adc	r17, r17
    6684:	8a 95       	dec	r24
    6686:	d2 f7       	brpl	.-12     	; 0x667c <__divdi3+0x64e>
    6688:	ed aa       	sts	0x9d, r30
    668a:	fe aa       	sts	0x9e, r31
    668c:	0f ab       	sts	0x5f, r16
    668e:	18 af       	sts	0x78, r17
    6690:	25 01       	movw	r4, r10
    6692:	66 24       	eor	r6, r6
    6694:	77 24       	eor	r7, r7
    6696:	95 01       	movw	r18, r10
    6698:	84 01       	movw	r16, r8
    669a:	20 70       	andi	r18, 0x00	; 0
    669c:	30 70       	andi	r19, 0x00	; 0
    669e:	09 af       	sts	0x79, r16
    66a0:	1a af       	sts	0x7a, r17
    66a2:	2b af       	sts	0x7b, r18
    66a4:	3c af       	sts	0x7c, r19
    66a6:	69 a9       	sts	0x49, r22
    66a8:	7a a9       	sts	0x4a, r23
    66aa:	8b a9       	sts	0x4b, r24
    66ac:	9c a9       	sts	0x4c, r25
    66ae:	a3 01       	movw	r20, r6
    66b0:	92 01       	movw	r18, r4
    66b2:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    66b6:	29 a7       	lds	r18, 0x79
    66b8:	3a a7       	lds	r19, 0x7a
    66ba:	4b a7       	lds	r20, 0x7b
    66bc:	5c a7       	lds	r21, 0x7c
    66be:	6b 01       	movw	r12, r22
    66c0:	7c 01       	movw	r14, r24
    66c2:	69 a9       	sts	0x49, r22
    66c4:	7a a9       	sts	0x4a, r23
    66c6:	8b a9       	sts	0x4b, r24
    66c8:	9c a9       	sts	0x4c, r25
    66ca:	a3 01       	movw	r20, r6
    66cc:	92 01       	movw	r18, r4
    66ce:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    66d2:	ca 01       	movw	r24, r20
    66d4:	b9 01       	movw	r22, r18
    66d6:	29 ad       	sts	0x69, r18
    66d8:	3a ad       	sts	0x6a, r19
    66da:	4b ad       	sts	0x6b, r20
    66dc:	5c ad       	sts	0x6c, r21
    66de:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    66e2:	ab 01       	movw	r20, r22
    66e4:	bc 01       	movw	r22, r24
    66e6:	76 01       	movw	r14, r12
    66e8:	dd 24       	eor	r13, r13
    66ea:	cc 24       	eor	r12, r12
    66ec:	0d a5       	lds	r16, 0x6d
    66ee:	1e a5       	lds	r17, 0x6e
    66f0:	2f a5       	lds	r18, 0x6f
    66f2:	38 a9       	sts	0x48, r19
    66f4:	c9 01       	movw	r24, r18
    66f6:	aa 27       	eor	r26, r26
    66f8:	bb 27       	eor	r27, r27
    66fa:	c8 2a       	or	r12, r24
    66fc:	d9 2a       	or	r13, r25
    66fe:	ea 2a       	or	r14, r26
    6700:	fb 2a       	or	r15, r27
    6702:	09 a5       	lds	r16, 0x69
    6704:	1a a5       	lds	r17, 0x6a
    6706:	2b a5       	lds	r18, 0x6b
    6708:	3c a5       	lds	r19, 0x6c
    670a:	c4 16       	cp	r12, r20
    670c:	d5 06       	cpc	r13, r21
    670e:	e6 06       	cpc	r14, r22
    6710:	f7 06       	cpc	r15, r23
    6712:	38 f5       	brcc	.+78     	; 0x6762 <__divdi3+0x734>
    6714:	01 50       	subi	r16, 0x01	; 1
    6716:	10 40       	sbci	r17, 0x00	; 0
    6718:	20 40       	sbci	r18, 0x00	; 0
    671a:	30 40       	sbci	r19, 0x00	; 0
    671c:	09 ab       	sts	0x59, r16
    671e:	1a ab       	sts	0x5a, r17
    6720:	2b ab       	sts	0x5b, r18
    6722:	3c ab       	sts	0x5c, r19
    6724:	c8 0c       	add	r12, r8
    6726:	d9 1c       	adc	r13, r9
    6728:	ea 1c       	adc	r14, r10
    672a:	fb 1c       	adc	r15, r11
    672c:	c8 14       	cp	r12, r8
    672e:	d9 04       	cpc	r13, r9
    6730:	ea 04       	cpc	r14, r10
    6732:	fb 04       	cpc	r15, r11
    6734:	d0 f0       	brcs	.+52     	; 0x676a <__divdi3+0x73c>
    6736:	c4 16       	cp	r12, r20
    6738:	d5 06       	cpc	r13, r21
    673a:	e6 06       	cpc	r14, r22
    673c:	f7 06       	cpc	r15, r23
    673e:	a8 f4       	brcc	.+42     	; 0x676a <__divdi3+0x73c>
    6740:	09 a5       	lds	r16, 0x69
    6742:	1a a5       	lds	r17, 0x6a
    6744:	2b a5       	lds	r18, 0x6b
    6746:	3c a5       	lds	r19, 0x6c
    6748:	02 50       	subi	r16, 0x02	; 2
    674a:	10 40       	sbci	r17, 0x00	; 0
    674c:	20 40       	sbci	r18, 0x00	; 0
    674e:	30 40       	sbci	r19, 0x00	; 0
    6750:	09 ab       	sts	0x59, r16
    6752:	1a ab       	sts	0x5a, r17
    6754:	2b ab       	sts	0x5b, r18
    6756:	3c ab       	sts	0x5c, r19
    6758:	c8 0c       	add	r12, r8
    675a:	d9 1c       	adc	r13, r9
    675c:	ea 1c       	adc	r14, r10
    675e:	fb 1c       	adc	r15, r11
    6760:	04 c0       	rjmp	.+8      	; 0x676a <__divdi3+0x73c>
    6762:	09 ab       	sts	0x59, r16
    6764:	1a ab       	sts	0x5a, r17
    6766:	2b ab       	sts	0x5b, r18
    6768:	3c ab       	sts	0x5c, r19
    676a:	c4 1a       	sub	r12, r20
    676c:	d5 0a       	sbc	r13, r21
    676e:	e6 0a       	sbc	r14, r22
    6770:	f7 0a       	sbc	r15, r23
    6772:	c7 01       	movw	r24, r14
    6774:	b6 01       	movw	r22, r12
    6776:	a3 01       	movw	r20, r6
    6778:	92 01       	movw	r18, r4
    677a:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    677e:	29 a7       	lds	r18, 0x79
    6780:	3a a7       	lds	r19, 0x7a
    6782:	4b a7       	lds	r20, 0x7b
    6784:	5c a7       	lds	r21, 0x7c
    6786:	21 96       	adiw	r28, 0x01	; 1
    6788:	6c af       	sts	0x7c, r22
    678a:	7d af       	sts	0x7d, r23
    678c:	8e af       	sts	0x7e, r24
    678e:	9f af       	sts	0x7f, r25
    6790:	21 97       	sbiw	r28, 0x01	; 1
    6792:	c7 01       	movw	r24, r14
    6794:	b6 01       	movw	r22, r12
    6796:	a3 01       	movw	r20, r6
    6798:	92 01       	movw	r18, r4
    679a:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    679e:	ca 01       	movw	r24, r20
    67a0:	b9 01       	movw	r22, r18
    67a2:	29 ad       	sts	0x69, r18
    67a4:	3a ad       	sts	0x6a, r19
    67a6:	4b ad       	sts	0x6b, r20
    67a8:	5c ad       	sts	0x6c, r21
    67aa:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    67ae:	8b 01       	movw	r16, r22
    67b0:	9c 01       	movw	r18, r24
    67b2:	21 96       	adiw	r28, 0x01	; 1
    67b4:	4c ad       	sts	0x6c, r20
    67b6:	5d ad       	sts	0x6d, r21
    67b8:	6e ad       	sts	0x6e, r22
    67ba:	7f ad       	sts	0x6f, r23
    67bc:	21 97       	sbiw	r28, 0x01	; 1
    67be:	da 01       	movw	r26, r20
    67c0:	99 27       	eor	r25, r25
    67c2:	88 27       	eor	r24, r24
    67c4:	4d a5       	lds	r20, 0x6d
    67c6:	5e a5       	lds	r21, 0x6e
    67c8:	6f a5       	lds	r22, 0x6f
    67ca:	78 a9       	sts	0x48, r23
    67cc:	60 70       	andi	r22, 0x00	; 0
    67ce:	70 70       	andi	r23, 0x00	; 0
    67d0:	84 2b       	or	r24, r20
    67d2:	95 2b       	or	r25, r21
    67d4:	a6 2b       	or	r26, r22
    67d6:	b7 2b       	or	r27, r23
    67d8:	49 a5       	lds	r20, 0x69
    67da:	5a a5       	lds	r21, 0x6a
    67dc:	6b a5       	lds	r22, 0x6b
    67de:	7c a5       	lds	r23, 0x6c
    67e0:	80 17       	cp	r24, r16
    67e2:	91 07       	cpc	r25, r17
    67e4:	a2 07       	cpc	r26, r18
    67e6:	b3 07       	cpc	r27, r19
    67e8:	f0 f4       	brcc	.+60     	; 0x6826 <__divdi3+0x7f8>
    67ea:	41 50       	subi	r20, 0x01	; 1
    67ec:	50 40       	sbci	r21, 0x00	; 0
    67ee:	60 40       	sbci	r22, 0x00	; 0
    67f0:	70 40       	sbci	r23, 0x00	; 0
    67f2:	88 0d       	add	r24, r8
    67f4:	99 1d       	adc	r25, r9
    67f6:	aa 1d       	adc	r26, r10
    67f8:	bb 1d       	adc	r27, r11
    67fa:	88 15       	cp	r24, r8
    67fc:	99 05       	cpc	r25, r9
    67fe:	aa 05       	cpc	r26, r10
    6800:	bb 05       	cpc	r27, r11
    6802:	88 f0       	brcs	.+34     	; 0x6826 <__divdi3+0x7f8>
    6804:	80 17       	cp	r24, r16
    6806:	91 07       	cpc	r25, r17
    6808:	a2 07       	cpc	r26, r18
    680a:	b3 07       	cpc	r27, r19
    680c:	60 f4       	brcc	.+24     	; 0x6826 <__divdi3+0x7f8>
    680e:	49 a5       	lds	r20, 0x69
    6810:	5a a5       	lds	r21, 0x6a
    6812:	6b a5       	lds	r22, 0x6b
    6814:	7c a5       	lds	r23, 0x6c
    6816:	42 50       	subi	r20, 0x02	; 2
    6818:	50 40       	sbci	r21, 0x00	; 0
    681a:	60 40       	sbci	r22, 0x00	; 0
    681c:	70 40       	sbci	r23, 0x00	; 0
    681e:	88 0d       	add	r24, r8
    6820:	99 1d       	adc	r25, r9
    6822:	aa 1d       	adc	r26, r10
    6824:	bb 1d       	adc	r27, r11
    6826:	6c 01       	movw	r12, r24
    6828:	7d 01       	movw	r14, r26
    682a:	c0 1a       	sub	r12, r16
    682c:	d1 0a       	sbc	r13, r17
    682e:	e2 0a       	sbc	r14, r18
    6830:	f3 0a       	sbc	r15, r19
    6832:	09 a9       	sts	0x49, r16
    6834:	1a a9       	sts	0x4a, r17
    6836:	2b a9       	sts	0x4b, r18
    6838:	3c a9       	sts	0x4c, r19
    683a:	38 01       	movw	r6, r16
    683c:	55 24       	eor	r5, r5
    683e:	44 24       	eor	r4, r4
    6840:	44 2a       	or	r4, r20
    6842:	55 2a       	or	r5, r21
    6844:	66 2a       	or	r6, r22
    6846:	77 2a       	or	r7, r23
    6848:	85 01       	movw	r16, r10
    684a:	22 27       	eor	r18, r18
    684c:	33 27       	eor	r19, r19
    684e:	0d a7       	lds	r16, 0x7d
    6850:	1e a7       	lds	r17, 0x7e
    6852:	2f a7       	lds	r18, 0x7f
    6854:	38 ab       	sts	0x58, r19
    6856:	95 01       	movw	r18, r10
    6858:	84 01       	movw	r16, r8
    685a:	20 70       	andi	r18, 0x00	; 0
    685c:	30 70       	andi	r19, 0x00	; 0
    685e:	09 af       	sts	0x79, r16
    6860:	1a af       	sts	0x7a, r17
    6862:	2b af       	sts	0x7b, r18
    6864:	3c af       	sts	0x7c, r19
    6866:	c7 01       	movw	r24, r14
    6868:	b6 01       	movw	r22, r12
    686a:	2d a5       	lds	r18, 0x6d
    686c:	3e a5       	lds	r19, 0x6e
    686e:	4f a5       	lds	r20, 0x6f
    6870:	58 a9       	sts	0x48, r21
    6872:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    6876:	29 a7       	lds	r18, 0x79
    6878:	3a a7       	lds	r19, 0x7a
    687a:	4b a7       	lds	r20, 0x7b
    687c:	5c a7       	lds	r21, 0x7c
    687e:	69 ab       	sts	0x59, r22
    6880:	7a ab       	sts	0x5a, r23
    6882:	8b ab       	sts	0x5b, r24
    6884:	9c ab       	sts	0x5c, r25
    6886:	c7 01       	movw	r24, r14
    6888:	b6 01       	movw	r22, r12
    688a:	2d a5       	lds	r18, 0x6d
    688c:	3e a5       	lds	r19, 0x6e
    688e:	4f a5       	lds	r20, 0x6f
    6890:	58 a9       	sts	0x48, r21
    6892:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    6896:	ca 01       	movw	r24, r20
    6898:	b9 01       	movw	r22, r18
    689a:	29 ad       	sts	0x69, r18
    689c:	3a ad       	sts	0x6a, r19
    689e:	4b ad       	sts	0x6b, r20
    68a0:	5c ad       	sts	0x6c, r21
    68a2:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    68a6:	ab 01       	movw	r20, r22
    68a8:	bc 01       	movw	r22, r24
    68aa:	09 a9       	sts	0x49, r16
    68ac:	1a a9       	sts	0x4a, r17
    68ae:	2b a9       	sts	0x4b, r18
    68b0:	3c a9       	sts	0x4c, r19
    68b2:	78 01       	movw	r14, r16
    68b4:	dd 24       	eor	r13, r13
    68b6:	cc 24       	eor	r12, r12
    68b8:	0d a9       	sts	0x4d, r16
    68ba:	1e a9       	sts	0x4e, r17
    68bc:	2f a9       	sts	0x4f, r18
    68be:	38 ad       	sts	0x68, r19
    68c0:	c9 01       	movw	r24, r18
    68c2:	aa 27       	eor	r26, r26
    68c4:	bb 27       	eor	r27, r27
    68c6:	c8 2a       	or	r12, r24
    68c8:	d9 2a       	or	r13, r25
    68ca:	ea 2a       	or	r14, r26
    68cc:	fb 2a       	or	r15, r27
    68ce:	09 a5       	lds	r16, 0x69
    68d0:	1a a5       	lds	r17, 0x6a
    68d2:	2b a5       	lds	r18, 0x6b
    68d4:	3c a5       	lds	r19, 0x6c
    68d6:	c4 16       	cp	r12, r20
    68d8:	d5 06       	cpc	r13, r21
    68da:	e6 06       	cpc	r14, r22
    68dc:	f7 06       	cpc	r15, r23
    68de:	38 f5       	brcc	.+78     	; 0x692e <__divdi3+0x900>
    68e0:	01 50       	subi	r16, 0x01	; 1
    68e2:	10 40       	sbci	r17, 0x00	; 0
    68e4:	20 40       	sbci	r18, 0x00	; 0
    68e6:	30 40       	sbci	r19, 0x00	; 0
    68e8:	09 ab       	sts	0x59, r16
    68ea:	1a ab       	sts	0x5a, r17
    68ec:	2b ab       	sts	0x5b, r18
    68ee:	3c ab       	sts	0x5c, r19
    68f0:	c8 0c       	add	r12, r8
    68f2:	d9 1c       	adc	r13, r9
    68f4:	ea 1c       	adc	r14, r10
    68f6:	fb 1c       	adc	r15, r11
    68f8:	c8 14       	cp	r12, r8
    68fa:	d9 04       	cpc	r13, r9
    68fc:	ea 04       	cpc	r14, r10
    68fe:	fb 04       	cpc	r15, r11
    6900:	d0 f0       	brcs	.+52     	; 0x6936 <__divdi3+0x908>
    6902:	c4 16       	cp	r12, r20
    6904:	d5 06       	cpc	r13, r21
    6906:	e6 06       	cpc	r14, r22
    6908:	f7 06       	cpc	r15, r23
    690a:	a8 f4       	brcc	.+42     	; 0x6936 <__divdi3+0x908>
    690c:	09 a5       	lds	r16, 0x69
    690e:	1a a5       	lds	r17, 0x6a
    6910:	2b a5       	lds	r18, 0x6b
    6912:	3c a5       	lds	r19, 0x6c
    6914:	02 50       	subi	r16, 0x02	; 2
    6916:	10 40       	sbci	r17, 0x00	; 0
    6918:	20 40       	sbci	r18, 0x00	; 0
    691a:	30 40       	sbci	r19, 0x00	; 0
    691c:	09 ab       	sts	0x59, r16
    691e:	1a ab       	sts	0x5a, r17
    6920:	2b ab       	sts	0x5b, r18
    6922:	3c ab       	sts	0x5c, r19
    6924:	c8 0c       	add	r12, r8
    6926:	d9 1c       	adc	r13, r9
    6928:	ea 1c       	adc	r14, r10
    692a:	fb 1c       	adc	r15, r11
    692c:	04 c0       	rjmp	.+8      	; 0x6936 <__divdi3+0x908>
    692e:	09 ab       	sts	0x59, r16
    6930:	1a ab       	sts	0x5a, r17
    6932:	2b ab       	sts	0x5b, r18
    6934:	3c ab       	sts	0x5c, r19
    6936:	c4 1a       	sub	r12, r20
    6938:	d5 0a       	sbc	r13, r21
    693a:	e6 0a       	sbc	r14, r22
    693c:	f7 0a       	sbc	r15, r23
    693e:	c7 01       	movw	r24, r14
    6940:	b6 01       	movw	r22, r12
    6942:	2d a5       	lds	r18, 0x6d
    6944:	3e a5       	lds	r19, 0x6e
    6946:	4f a5       	lds	r20, 0x6f
    6948:	58 a9       	sts	0x48, r21
    694a:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    694e:	29 a7       	lds	r18, 0x79
    6950:	3a a7       	lds	r19, 0x7a
    6952:	4b a7       	lds	r20, 0x7b
    6954:	5c a7       	lds	r21, 0x7c
    6956:	21 96       	adiw	r28, 0x01	; 1
    6958:	6c af       	sts	0x7c, r22
    695a:	7d af       	sts	0x7d, r23
    695c:	8e af       	sts	0x7e, r24
    695e:	9f af       	sts	0x7f, r25
    6960:	21 97       	sbiw	r28, 0x01	; 1
    6962:	c7 01       	movw	r24, r14
    6964:	b6 01       	movw	r22, r12
    6966:	2d a5       	lds	r18, 0x6d
    6968:	3e a5       	lds	r19, 0x6e
    696a:	4f a5       	lds	r20, 0x6f
    696c:	58 a9       	sts	0x48, r21
    696e:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    6972:	ca 01       	movw	r24, r20
    6974:	b9 01       	movw	r22, r18
    6976:	29 ad       	sts	0x69, r18
    6978:	3a ad       	sts	0x6a, r19
    697a:	4b ad       	sts	0x6b, r20
    697c:	5c ad       	sts	0x6c, r21
    697e:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    6982:	8b 01       	movw	r16, r22
    6984:	9c 01       	movw	r18, r24
    6986:	21 96       	adiw	r28, 0x01	; 1
    6988:	4c ad       	sts	0x6c, r20
    698a:	5d ad       	sts	0x6d, r21
    698c:	6e ad       	sts	0x6e, r22
    698e:	7f ad       	sts	0x6f, r23
    6990:	21 97       	sbiw	r28, 0x01	; 1
    6992:	da 01       	movw	r26, r20
    6994:	99 27       	eor	r25, r25
    6996:	88 27       	eor	r24, r24
    6998:	4d a9       	sts	0x4d, r20
    699a:	5e a9       	sts	0x4e, r21
    699c:	6f a9       	sts	0x4f, r22
    699e:	78 ad       	sts	0x68, r23
    69a0:	60 70       	andi	r22, 0x00	; 0
    69a2:	70 70       	andi	r23, 0x00	; 0
    69a4:	84 2b       	or	r24, r20
    69a6:	95 2b       	or	r25, r21
    69a8:	a6 2b       	or	r26, r22
    69aa:	b7 2b       	or	r27, r23
    69ac:	49 a5       	lds	r20, 0x69
    69ae:	5a a5       	lds	r21, 0x6a
    69b0:	6b a5       	lds	r22, 0x6b
    69b2:	7c a5       	lds	r23, 0x6c
    69b4:	80 17       	cp	r24, r16
    69b6:	91 07       	cpc	r25, r17
    69b8:	a2 07       	cpc	r26, r18
    69ba:	b3 07       	cpc	r27, r19
    69bc:	d0 f4       	brcc	.+52     	; 0x69f2 <__divdi3+0x9c4>
    69be:	41 50       	subi	r20, 0x01	; 1
    69c0:	50 40       	sbci	r21, 0x00	; 0
    69c2:	60 40       	sbci	r22, 0x00	; 0
    69c4:	70 40       	sbci	r23, 0x00	; 0
    69c6:	88 0d       	add	r24, r8
    69c8:	99 1d       	adc	r25, r9
    69ca:	aa 1d       	adc	r26, r10
    69cc:	bb 1d       	adc	r27, r11
    69ce:	88 15       	cp	r24, r8
    69d0:	99 05       	cpc	r25, r9
    69d2:	aa 05       	cpc	r26, r10
    69d4:	bb 05       	cpc	r27, r11
    69d6:	68 f0       	brcs	.+26     	; 0x69f2 <__divdi3+0x9c4>
    69d8:	80 17       	cp	r24, r16
    69da:	91 07       	cpc	r25, r17
    69dc:	a2 07       	cpc	r26, r18
    69de:	b3 07       	cpc	r27, r19
    69e0:	40 f4       	brcc	.+16     	; 0x69f2 <__divdi3+0x9c4>
    69e2:	49 a5       	lds	r20, 0x69
    69e4:	5a a5       	lds	r21, 0x6a
    69e6:	6b a5       	lds	r22, 0x6b
    69e8:	7c a5       	lds	r23, 0x6c
    69ea:	42 50       	subi	r20, 0x02	; 2
    69ec:	50 40       	sbci	r21, 0x00	; 0
    69ee:	60 40       	sbci	r22, 0x00	; 0
    69f0:	70 40       	sbci	r23, 0x00	; 0
    69f2:	09 a9       	sts	0x49, r16
    69f4:	1a a9       	sts	0x4a, r17
    69f6:	2b a9       	sts	0x4b, r18
    69f8:	3c a9       	sts	0x4c, r19
    69fa:	78 01       	movw	r14, r16
    69fc:	dd 24       	eor	r13, r13
    69fe:	cc 24       	eor	r12, r12
    6a00:	c4 2a       	or	r12, r20
    6a02:	d5 2a       	or	r13, r21
    6a04:	e6 2a       	or	r14, r22
    6a06:	f7 2a       	or	r15, r23
    6a08:	50 c2       	rjmp	.+1184   	; 0x6eaa <__divdi3+0xe7c>
    6a0a:	c8 16       	cp	r12, r24
    6a0c:	d9 06       	cpc	r13, r25
    6a0e:	ea 06       	cpc	r14, r26
    6a10:	fb 06       	cpc	r15, r27
    6a12:	08 f4       	brcc	.+2      	; 0x6a16 <__divdi3+0x9e8>
    6a14:	37 c2       	rjmp	.+1134   	; 0x6e84 <__divdi3+0xe56>
    6a16:	80 30       	cpi	r24, 0x00	; 0
    6a18:	10 e0       	ldi	r17, 0x00	; 0
    6a1a:	91 07       	cpc	r25, r17
    6a1c:	11 e0       	ldi	r17, 0x01	; 1
    6a1e:	a1 07       	cpc	r26, r17
    6a20:	10 e0       	ldi	r17, 0x00	; 0
    6a22:	b1 07       	cpc	r27, r17
    6a24:	50 f4       	brcc	.+20     	; 0x6a3a <__divdi3+0xa0c>
    6a26:	8f 3f       	cpi	r24, 0xFF	; 255
    6a28:	91 05       	cpc	r25, r1
    6a2a:	a1 05       	cpc	r26, r1
    6a2c:	b1 05       	cpc	r27, r1
    6a2e:	09 f0       	breq	.+2      	; 0x6a32 <__divdi3+0xa04>
    6a30:	88 f4       	brcc	.+34     	; 0x6a54 <__divdi3+0xa26>
    6a32:	00 e0       	ldi	r16, 0x00	; 0
    6a34:	10 e0       	ldi	r17, 0x00	; 0
    6a36:	98 01       	movw	r18, r16
    6a38:	16 c0       	rjmp	.+44     	; 0x6a66 <__divdi3+0xa38>
    6a3a:	80 30       	cpi	r24, 0x00	; 0
    6a3c:	20 e0       	ldi	r18, 0x00	; 0
    6a3e:	92 07       	cpc	r25, r18
    6a40:	20 e0       	ldi	r18, 0x00	; 0
    6a42:	a2 07       	cpc	r26, r18
    6a44:	21 e0       	ldi	r18, 0x01	; 1
    6a46:	b2 07       	cpc	r27, r18
    6a48:	50 f4       	brcc	.+20     	; 0x6a5e <__divdi3+0xa30>
    6a4a:	00 e1       	ldi	r16, 0x10	; 16
    6a4c:	10 e0       	ldi	r17, 0x00	; 0
    6a4e:	20 e0       	ldi	r18, 0x00	; 0
    6a50:	30 e0       	ldi	r19, 0x00	; 0
    6a52:	09 c0       	rjmp	.+18     	; 0x6a66 <__divdi3+0xa38>
    6a54:	08 e0       	ldi	r16, 0x08	; 8
    6a56:	10 e0       	ldi	r17, 0x00	; 0
    6a58:	20 e0       	ldi	r18, 0x00	; 0
    6a5a:	30 e0       	ldi	r19, 0x00	; 0
    6a5c:	04 c0       	rjmp	.+8      	; 0x6a66 <__divdi3+0xa38>
    6a5e:	08 e1       	ldi	r16, 0x18	; 24
    6a60:	10 e0       	ldi	r17, 0x00	; 0
    6a62:	20 e0       	ldi	r18, 0x00	; 0
    6a64:	30 e0       	ldi	r19, 0x00	; 0
    6a66:	ac 01       	movw	r20, r24
    6a68:	bd 01       	movw	r22, r26
    6a6a:	00 2e       	mov	r0, r16
    6a6c:	04 c0       	rjmp	.+8      	; 0x6a76 <__divdi3+0xa48>
    6a6e:	76 95       	lsr	r23
    6a70:	67 95       	ror	r22
    6a72:	57 95       	ror	r21
    6a74:	47 95       	ror	r20
    6a76:	0a 94       	dec	r0
    6a78:	d2 f7       	brpl	.-12     	; 0x6a6e <__divdi3+0xa40>
    6a7a:	fa 01       	movw	r30, r20
    6a7c:	e3 5f       	subi	r30, 0xF3	; 243
    6a7e:	ff 4d       	sbci	r31, 0xDF	; 223
    6a80:	40 81       	ld	r20, Z
    6a82:	04 0f       	add	r16, r20
    6a84:	11 1d       	adc	r17, r1
    6a86:	21 1d       	adc	r18, r1
    6a88:	31 1d       	adc	r19, r1
    6a8a:	40 e2       	ldi	r20, 0x20	; 32
    6a8c:	50 e0       	ldi	r21, 0x00	; 0
    6a8e:	60 e0       	ldi	r22, 0x00	; 0
    6a90:	70 e0       	ldi	r23, 0x00	; 0
    6a92:	40 1b       	sub	r20, r16
    6a94:	51 0b       	sbc	r21, r17
    6a96:	62 0b       	sbc	r22, r18
    6a98:	73 0b       	sbc	r23, r19
    6a9a:	a1 f4       	brne	.+40     	; 0x6ac4 <__divdi3+0xa96>
    6a9c:	8c 15       	cp	r24, r12
    6a9e:	9d 05       	cpc	r25, r13
    6aa0:	ae 05       	cpc	r26, r14
    6aa2:	bf 05       	cpc	r27, r15
    6aa4:	08 f4       	brcc	.+2      	; 0x6aa8 <__divdi3+0xa7a>
    6aa6:	f5 c1       	rjmp	.+1002   	; 0x6e92 <__divdi3+0xe64>
    6aa8:	ed a8       	sts	0x8d, r30
    6aaa:	fe a8       	sts	0x8e, r31
    6aac:	0f a9       	sts	0x4f, r16
    6aae:	18 ad       	sts	0x68, r17
    6ab0:	44 24       	eor	r4, r4
    6ab2:	55 24       	eor	r5, r5
    6ab4:	32 01       	movw	r6, r4
    6ab6:	e8 14       	cp	r14, r8
    6ab8:	f9 04       	cpc	r15, r9
    6aba:	0a 05       	cpc	r16, r10
    6abc:	1b 05       	cpc	r17, r11
    6abe:	08 f0       	brcs	.+2      	; 0x6ac2 <__divdi3+0xa94>
    6ac0:	eb c1       	rjmp	.+982    	; 0x6e98 <__divdi3+0xe6a>
    6ac2:	e3 c1       	rjmp	.+966    	; 0x6e8a <__divdi3+0xe5c>
    6ac4:	34 2e       	mov	r3, r20
    6ac6:	2c 01       	movw	r4, r24
    6ac8:	3d 01       	movw	r6, r26
    6aca:	04 c0       	rjmp	.+8      	; 0x6ad4 <__divdi3+0xaa6>
    6acc:	44 0c       	add	r4, r4
    6ace:	55 1c       	adc	r5, r5
    6ad0:	66 1c       	adc	r6, r6
    6ad2:	77 1c       	adc	r7, r7
    6ad4:	4a 95       	dec	r20
    6ad6:	d2 f7       	brpl	.-12     	; 0x6acc <__divdi3+0xa9e>
    6ad8:	d5 01       	movw	r26, r10
    6ada:	c4 01       	movw	r24, r8
    6adc:	00 2e       	mov	r0, r16
    6ade:	04 c0       	rjmp	.+8      	; 0x6ae8 <__divdi3+0xaba>
    6ae0:	b6 95       	lsr	r27
    6ae2:	a7 95       	ror	r26
    6ae4:	97 95       	ror	r25
    6ae6:	87 95       	ror	r24
    6ae8:	0a 94       	dec	r0
    6aea:	d2 f7       	brpl	.-12     	; 0x6ae0 <__divdi3+0xab2>
    6aec:	48 2a       	or	r4, r24
    6aee:	59 2a       	or	r5, r25
    6af0:	6a 2a       	or	r6, r26
    6af2:	7b 2a       	or	r7, r27
    6af4:	a5 01       	movw	r20, r10
    6af6:	94 01       	movw	r18, r8
    6af8:	03 2c       	mov	r0, r3
    6afa:	04 c0       	rjmp	.+8      	; 0x6b04 <__divdi3+0xad6>
    6afc:	22 0f       	add	r18, r18
    6afe:	33 1f       	adc	r19, r19
    6b00:	44 1f       	adc	r20, r20
    6b02:	55 1f       	adc	r21, r21
    6b04:	0a 94       	dec	r0
    6b06:	d2 f7       	brpl	.-12     	; 0x6afc <__divdi3+0xace>
    6b08:	29 af       	sts	0x79, r18
    6b0a:	3a af       	sts	0x7a, r19
    6b0c:	4b af       	sts	0x7b, r20
    6b0e:	5c af       	sts	0x7c, r21
    6b10:	b7 01       	movw	r22, r14
    6b12:	a6 01       	movw	r20, r12
    6b14:	00 2e       	mov	r0, r16
    6b16:	04 c0       	rjmp	.+8      	; 0x6b20 <__divdi3+0xaf2>
    6b18:	76 95       	lsr	r23
    6b1a:	67 95       	ror	r22
    6b1c:	57 95       	ror	r21
    6b1e:	47 95       	ror	r20
    6b20:	0a 94       	dec	r0
    6b22:	d2 f7       	brpl	.-12     	; 0x6b18 <__divdi3+0xaea>
    6b24:	49 ab       	sts	0x59, r20
    6b26:	5a ab       	sts	0x5a, r21
    6b28:	6b ab       	sts	0x5b, r22
    6b2a:	7c ab       	sts	0x5c, r23
    6b2c:	c7 01       	movw	r24, r14
    6b2e:	b6 01       	movw	r22, r12
    6b30:	03 2c       	mov	r0, r3
    6b32:	04 c0       	rjmp	.+8      	; 0x6b3c <__divdi3+0xb0e>
    6b34:	66 0f       	add	r22, r22
    6b36:	77 1f       	adc	r23, r23
    6b38:	88 1f       	adc	r24, r24
    6b3a:	99 1f       	adc	r25, r25
    6b3c:	0a 94       	dec	r0
    6b3e:	d2 f7       	brpl	.-12     	; 0x6b34 <__divdi3+0xb06>
    6b40:	6d a7       	lds	r22, 0x7d
    6b42:	7e a7       	lds	r23, 0x7e
    6b44:	8f a7       	lds	r24, 0x7f
    6b46:	98 ab       	sts	0x58, r25
    6b48:	8d a9       	sts	0x4d, r24
    6b4a:	9e a9       	sts	0x4e, r25
    6b4c:	af a9       	sts	0x4f, r26
    6b4e:	b8 ad       	sts	0x68, r27
    6b50:	04 c0       	rjmp	.+8      	; 0x6b5a <__divdi3+0xb2c>
    6b52:	b6 95       	lsr	r27
    6b54:	a7 95       	ror	r26
    6b56:	97 95       	ror	r25
    6b58:	87 95       	ror	r24
    6b5a:	0a 95       	dec	r16
    6b5c:	d2 f7       	brpl	.-12     	; 0x6b52 <__divdi3+0xb24>
    6b5e:	4d a5       	lds	r20, 0x6d
    6b60:	5e a5       	lds	r21, 0x6e
    6b62:	6f a5       	lds	r22, 0x6f
    6b64:	78 a9       	sts	0x48, r23
    6b66:	48 2b       	or	r20, r24
    6b68:	59 2b       	or	r21, r25
    6b6a:	6a 2b       	or	r22, r26
    6b6c:	7b 2b       	or	r23, r27
    6b6e:	4d a7       	lds	r20, 0x7d
    6b70:	5e a7       	lds	r21, 0x7e
    6b72:	6f a7       	lds	r22, 0x7f
    6b74:	78 ab       	sts	0x58, r23
    6b76:	43 01       	movw	r8, r6
    6b78:	aa 24       	eor	r10, r10
    6b7a:	bb 24       	eor	r11, r11
    6b7c:	93 01       	movw	r18, r6
    6b7e:	82 01       	movw	r16, r4
    6b80:	20 70       	andi	r18, 0x00	; 0
    6b82:	30 70       	andi	r19, 0x00	; 0
    6b84:	21 96       	adiw	r28, 0x01	; 1
    6b86:	0c af       	sts	0x7c, r16
    6b88:	1d af       	sts	0x7d, r17
    6b8a:	2e af       	sts	0x7e, r18
    6b8c:	3f af       	sts	0x7f, r19
    6b8e:	21 97       	sbiw	r28, 0x01	; 1
    6b90:	69 a9       	sts	0x49, r22
    6b92:	7a a9       	sts	0x4a, r23
    6b94:	8b a9       	sts	0x4b, r24
    6b96:	9c a9       	sts	0x4c, r25
    6b98:	a5 01       	movw	r20, r10
    6b9a:	94 01       	movw	r18, r8
    6b9c:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    6ba0:	29 a7       	lds	r18, 0x79
    6ba2:	3a a7       	lds	r19, 0x7a
    6ba4:	4b a7       	lds	r20, 0x7b
    6ba6:	5c a7       	lds	r21, 0x7c
    6ba8:	6b 01       	movw	r12, r22
    6baa:	7c 01       	movw	r14, r24
    6bac:	69 a9       	sts	0x49, r22
    6bae:	7a a9       	sts	0x4a, r23
    6bb0:	8b a9       	sts	0x4b, r24
    6bb2:	9c a9       	sts	0x4c, r25
    6bb4:	a5 01       	movw	r20, r10
    6bb6:	94 01       	movw	r18, r8
    6bb8:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    6bbc:	ca 01       	movw	r24, r20
    6bbe:	b9 01       	movw	r22, r18
    6bc0:	21 96       	adiw	r28, 0x01	; 1
    6bc2:	2c ad       	sts	0x6c, r18
    6bc4:	3d ad       	sts	0x6d, r19
    6bc6:	4e ad       	sts	0x6e, r20
    6bc8:	5f ad       	sts	0x6f, r21
    6bca:	21 97       	sbiw	r28, 0x01	; 1
    6bcc:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    6bd0:	dc 01       	movw	r26, r24
    6bd2:	cb 01       	movw	r24, r22
    6bd4:	76 01       	movw	r14, r12
    6bd6:	dd 24       	eor	r13, r13
    6bd8:	cc 24       	eor	r12, r12
    6bda:	0d a5       	lds	r16, 0x6d
    6bdc:	1e a5       	lds	r17, 0x6e
    6bde:	2f a5       	lds	r18, 0x6f
    6be0:	38 a9       	sts	0x48, r19
    6be2:	a9 01       	movw	r20, r18
    6be4:	66 27       	eor	r22, r22
    6be6:	77 27       	eor	r23, r23
    6be8:	c4 2a       	or	r12, r20
    6bea:	d5 2a       	or	r13, r21
    6bec:	e6 2a       	or	r14, r22
    6bee:	f7 2a       	or	r15, r23
    6bf0:	09 a5       	lds	r16, 0x69
    6bf2:	1a a5       	lds	r17, 0x6a
    6bf4:	2b a5       	lds	r18, 0x6b
    6bf6:	3c a5       	lds	r19, 0x6c
    6bf8:	c8 16       	cp	r12, r24
    6bfa:	d9 06       	cpc	r13, r25
    6bfc:	ea 06       	cpc	r14, r26
    6bfe:	fb 06       	cpc	r15, r27
    6c00:	38 f5       	brcc	.+78     	; 0x6c50 <__divdi3+0xc22>
    6c02:	01 50       	subi	r16, 0x01	; 1
    6c04:	10 40       	sbci	r17, 0x00	; 0
    6c06:	20 40       	sbci	r18, 0x00	; 0
    6c08:	30 40       	sbci	r19, 0x00	; 0
    6c0a:	09 ab       	sts	0x59, r16
    6c0c:	1a ab       	sts	0x5a, r17
    6c0e:	2b ab       	sts	0x5b, r18
    6c10:	3c ab       	sts	0x5c, r19
    6c12:	c4 0c       	add	r12, r4
    6c14:	d5 1c       	adc	r13, r5
    6c16:	e6 1c       	adc	r14, r6
    6c18:	f7 1c       	adc	r15, r7
    6c1a:	c4 14       	cp	r12, r4
    6c1c:	d5 04       	cpc	r13, r5
    6c1e:	e6 04       	cpc	r14, r6
    6c20:	f7 04       	cpc	r15, r7
    6c22:	d0 f0       	brcs	.+52     	; 0x6c58 <__divdi3+0xc2a>
    6c24:	c8 16       	cp	r12, r24
    6c26:	d9 06       	cpc	r13, r25
    6c28:	ea 06       	cpc	r14, r26
    6c2a:	fb 06       	cpc	r15, r27
    6c2c:	a8 f4       	brcc	.+42     	; 0x6c58 <__divdi3+0xc2a>
    6c2e:	09 a5       	lds	r16, 0x69
    6c30:	1a a5       	lds	r17, 0x6a
    6c32:	2b a5       	lds	r18, 0x6b
    6c34:	3c a5       	lds	r19, 0x6c
    6c36:	02 50       	subi	r16, 0x02	; 2
    6c38:	10 40       	sbci	r17, 0x00	; 0
    6c3a:	20 40       	sbci	r18, 0x00	; 0
    6c3c:	30 40       	sbci	r19, 0x00	; 0
    6c3e:	09 ab       	sts	0x59, r16
    6c40:	1a ab       	sts	0x5a, r17
    6c42:	2b ab       	sts	0x5b, r18
    6c44:	3c ab       	sts	0x5c, r19
    6c46:	c4 0c       	add	r12, r4
    6c48:	d5 1c       	adc	r13, r5
    6c4a:	e6 1c       	adc	r14, r6
    6c4c:	f7 1c       	adc	r15, r7
    6c4e:	04 c0       	rjmp	.+8      	; 0x6c58 <__divdi3+0xc2a>
    6c50:	09 ab       	sts	0x59, r16
    6c52:	1a ab       	sts	0x5a, r17
    6c54:	2b ab       	sts	0x5b, r18
    6c56:	3c ab       	sts	0x5c, r19
    6c58:	c8 1a       	sub	r12, r24
    6c5a:	d9 0a       	sbc	r13, r25
    6c5c:	ea 0a       	sbc	r14, r26
    6c5e:	fb 0a       	sbc	r15, r27
    6c60:	c7 01       	movw	r24, r14
    6c62:	b6 01       	movw	r22, r12
    6c64:	a5 01       	movw	r20, r10
    6c66:	94 01       	movw	r18, r8
    6c68:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    6c6c:	29 a7       	lds	r18, 0x79
    6c6e:	3a a7       	lds	r19, 0x7a
    6c70:	4b a7       	lds	r20, 0x7b
    6c72:	5c a7       	lds	r21, 0x7c
    6c74:	29 96       	adiw	r28, 0x09	; 9
    6c76:	6c af       	sts	0x7c, r22
    6c78:	7d af       	sts	0x7d, r23
    6c7a:	8e af       	sts	0x7e, r24
    6c7c:	9f af       	sts	0x7f, r25
    6c7e:	29 97       	sbiw	r28, 0x09	; 9
    6c80:	c7 01       	movw	r24, r14
    6c82:	b6 01       	movw	r22, r12
    6c84:	a5 01       	movw	r20, r10
    6c86:	94 01       	movw	r18, r8
    6c88:	0e 94 b4 39 	call	0x7368	; 0x7368 <__udivmodsi4>
    6c8c:	ca 01       	movw	r24, r20
    6c8e:	b9 01       	movw	r22, r18
    6c90:	21 96       	adiw	r28, 0x01	; 1
    6c92:	2c ad       	sts	0x6c, r18
    6c94:	3d ad       	sts	0x6d, r19
    6c96:	4e ad       	sts	0x6e, r20
    6c98:	5f ad       	sts	0x6f, r21
    6c9a:	21 97       	sbiw	r28, 0x01	; 1
    6c9c:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    6ca0:	4b 01       	movw	r8, r22
    6ca2:	5c 01       	movw	r10, r24
    6ca4:	29 96       	adiw	r28, 0x09	; 9
    6ca6:	4c ad       	sts	0x6c, r20
    6ca8:	5d ad       	sts	0x6d, r21
    6caa:	6e ad       	sts	0x6e, r22
    6cac:	7f ad       	sts	0x6f, r23
    6cae:	29 97       	sbiw	r28, 0x09	; 9
    6cb0:	9a 01       	movw	r18, r20
    6cb2:	11 27       	eor	r17, r17
    6cb4:	00 27       	eor	r16, r16
    6cb6:	8d a5       	lds	r24, 0x6d
    6cb8:	9e a5       	lds	r25, 0x6e
    6cba:	af a5       	lds	r26, 0x6f
    6cbc:	b8 a9       	sts	0x48, r27
    6cbe:	a0 70       	andi	r26, 0x00	; 0
    6cc0:	b0 70       	andi	r27, 0x00	; 0
    6cc2:	08 2b       	or	r16, r24
    6cc4:	19 2b       	or	r17, r25
    6cc6:	2a 2b       	or	r18, r26
    6cc8:	3b 2b       	or	r19, r27
    6cca:	89 a5       	lds	r24, 0x69
    6ccc:	9a a5       	lds	r25, 0x6a
    6cce:	ab a5       	lds	r26, 0x6b
    6cd0:	bc a5       	lds	r27, 0x6c
    6cd2:	08 15       	cp	r16, r8
    6cd4:	19 05       	cpc	r17, r9
    6cd6:	2a 05       	cpc	r18, r10
    6cd8:	3b 05       	cpc	r19, r11
    6cda:	e0 f4       	brcc	.+56     	; 0x6d14 <__divdi3+0xce6>
    6cdc:	01 97       	sbiw	r24, 0x01	; 1
    6cde:	a1 09       	sbc	r26, r1
    6ce0:	b1 09       	sbc	r27, r1
    6ce2:	04 0d       	add	r16, r4
    6ce4:	15 1d       	adc	r17, r5
    6ce6:	26 1d       	adc	r18, r6
    6ce8:	37 1d       	adc	r19, r7
    6cea:	04 15       	cp	r16, r4
    6cec:	15 05       	cpc	r17, r5
    6cee:	26 05       	cpc	r18, r6
    6cf0:	37 05       	cpc	r19, r7
    6cf2:	80 f0       	brcs	.+32     	; 0x6d14 <__divdi3+0xce6>
    6cf4:	08 15       	cp	r16, r8
    6cf6:	19 05       	cpc	r17, r9
    6cf8:	2a 05       	cpc	r18, r10
    6cfa:	3b 05       	cpc	r19, r11
    6cfc:	58 f4       	brcc	.+22     	; 0x6d14 <__divdi3+0xce6>
    6cfe:	89 a5       	lds	r24, 0x69
    6d00:	9a a5       	lds	r25, 0x6a
    6d02:	ab a5       	lds	r26, 0x6b
    6d04:	bc a5       	lds	r27, 0x6c
    6d06:	02 97       	sbiw	r24, 0x02	; 2
    6d08:	a1 09       	sbc	r26, r1
    6d0a:	b1 09       	sbc	r27, r1
    6d0c:	04 0d       	add	r16, r4
    6d0e:	15 1d       	adc	r17, r5
    6d10:	26 1d       	adc	r18, r6
    6d12:	37 1d       	adc	r19, r7
    6d14:	b9 01       	movw	r22, r18
    6d16:	a8 01       	movw	r20, r16
    6d18:	48 19       	sub	r20, r8
    6d1a:	59 09       	sbc	r21, r9
    6d1c:	6a 09       	sbc	r22, r10
    6d1e:	7b 09       	sbc	r23, r11
    6d20:	4d a7       	lds	r20, 0x7d
    6d22:	5e a7       	lds	r21, 0x7e
    6d24:	6f a7       	lds	r22, 0x7f
    6d26:	78 ab       	sts	0x58, r23
    6d28:	09 a9       	sts	0x49, r16
    6d2a:	1a a9       	sts	0x4a, r17
    6d2c:	2b a9       	sts	0x4b, r18
    6d2e:	3c a9       	sts	0x4c, r19
    6d30:	78 01       	movw	r14, r16
    6d32:	dd 24       	eor	r13, r13
    6d34:	cc 24       	eor	r12, r12
    6d36:	c8 2a       	or	r12, r24
    6d38:	d9 2a       	or	r13, r25
    6d3a:	ea 2a       	or	r14, r26
    6d3c:	fb 2a       	or	r15, r27
    6d3e:	ff ef       	ldi	r31, 0xFF	; 255
    6d40:	8f 2e       	mov	r8, r31
    6d42:	ff ef       	ldi	r31, 0xFF	; 255
    6d44:	9f 2e       	mov	r9, r31
    6d46:	a1 2c       	mov	r10, r1
    6d48:	b1 2c       	mov	r11, r1
    6d4a:	8c 20       	and	r8, r12
    6d4c:	9d 20       	and	r9, r13
    6d4e:	ae 20       	and	r10, r14
    6d50:	bf 20       	and	r11, r15
    6d52:	87 01       	movw	r16, r14
    6d54:	22 27       	eor	r18, r18
    6d56:	33 27       	eor	r19, r19
    6d58:	09 a7       	lds	r16, 0x79
    6d5a:	1a a7       	lds	r17, 0x7a
    6d5c:	2b a7       	lds	r18, 0x7b
    6d5e:	3c a7       	lds	r19, 0x7c
    6d60:	49 ac       	sts	0xa9, r20
    6d62:	5a ac       	sts	0xaa, r21
    6d64:	6b ac       	sts	0xab, r22
    6d66:	7c ac       	sts	0xac, r23
    6d68:	2f ef       	ldi	r18, 0xFF	; 255
    6d6a:	3f ef       	ldi	r19, 0xFF	; 255
    6d6c:	40 e0       	ldi	r20, 0x00	; 0
    6d6e:	50 e0       	ldi	r21, 0x00	; 0
    6d70:	42 22       	and	r4, r18
    6d72:	53 22       	and	r5, r19
    6d74:	64 22       	and	r6, r20
    6d76:	75 22       	and	r7, r21
    6d78:	29 ad       	sts	0x69, r18
    6d7a:	3a ad       	sts	0x6a, r19
    6d7c:	4b ad       	sts	0x6b, r20
    6d7e:	5c ad       	sts	0x6c, r21
    6d80:	8a 01       	movw	r16, r20
    6d82:	22 27       	eor	r18, r18
    6d84:	33 27       	eor	r19, r19
    6d86:	09 ab       	sts	0x59, r16
    6d88:	1a ab       	sts	0x5a, r17
    6d8a:	2b ab       	sts	0x5b, r18
    6d8c:	3c ab       	sts	0x5c, r19
    6d8e:	c5 01       	movw	r24, r10
    6d90:	b4 01       	movw	r22, r8
    6d92:	a3 01       	movw	r20, r6
    6d94:	92 01       	movw	r18, r4
    6d96:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    6d9a:	69 af       	sts	0x79, r22
    6d9c:	7a af       	sts	0x7a, r23
    6d9e:	8b af       	sts	0x7b, r24
    6da0:	9c af       	sts	0x7c, r25
    6da2:	c5 01       	movw	r24, r10
    6da4:	b4 01       	movw	r22, r8
    6da6:	29 a9       	sts	0x49, r18
    6da8:	3a a9       	sts	0x4a, r19
    6daa:	4b a9       	sts	0x4b, r20
    6dac:	5c a9       	sts	0x4c, r21
    6dae:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    6db2:	4b 01       	movw	r8, r22
    6db4:	5c 01       	movw	r10, r24
    6db6:	69 a5       	lds	r22, 0x69
    6db8:	7a a5       	lds	r23, 0x6a
    6dba:	8b a5       	lds	r24, 0x6b
    6dbc:	9c a5       	lds	r25, 0x6c
    6dbe:	a3 01       	movw	r20, r6
    6dc0:	92 01       	movw	r18, r4
    6dc2:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    6dc6:	2b 01       	movw	r4, r22
    6dc8:	3c 01       	movw	r6, r24
    6dca:	69 a5       	lds	r22, 0x69
    6dcc:	7a a5       	lds	r23, 0x6a
    6dce:	8b a5       	lds	r24, 0x6b
    6dd0:	9c a5       	lds	r25, 0x6c
    6dd2:	29 a9       	sts	0x49, r18
    6dd4:	3a a9       	sts	0x4a, r19
    6dd6:	4b a9       	sts	0x4b, r20
    6dd8:	5c a9       	sts	0x4c, r21
    6dda:	0e 94 82 39 	call	0x7304	; 0x7304 <__mulsi3>
    6dde:	ab 01       	movw	r20, r22
    6de0:	bc 01       	movw	r22, r24
    6de2:	84 0c       	add	r8, r4
    6de4:	95 1c       	adc	r9, r5
    6de6:	a6 1c       	adc	r10, r6
    6de8:	b7 1c       	adc	r11, r7
    6dea:	09 ad       	sts	0x69, r16
    6dec:	1a ad       	sts	0x6a, r17
    6dee:	2b ad       	sts	0x6b, r18
    6df0:	3c ad       	sts	0x6c, r19
    6df2:	c9 01       	movw	r24, r18
    6df4:	aa 27       	eor	r26, r26
    6df6:	bb 27       	eor	r27, r27
    6df8:	88 0e       	add	r8, r24
    6dfa:	99 1e       	adc	r9, r25
    6dfc:	aa 1e       	adc	r10, r26
    6dfe:	bb 1e       	adc	r11, r27
    6e00:	84 14       	cp	r8, r4
    6e02:	95 04       	cpc	r9, r5
    6e04:	a6 04       	cpc	r10, r6
    6e06:	b7 04       	cpc	r11, r7
    6e08:	20 f4       	brcc	.+8      	; 0x6e12 <__divdi3+0xde4>
    6e0a:	40 50       	subi	r20, 0x00	; 0
    6e0c:	50 40       	sbci	r21, 0x00	; 0
    6e0e:	6f 4f       	sbci	r22, 0xFF	; 255
    6e10:	7f 4f       	sbci	r23, 0xFF	; 255
    6e12:	c5 01       	movw	r24, r10
    6e14:	aa 27       	eor	r26, r26
    6e16:	bb 27       	eor	r27, r27
    6e18:	84 0f       	add	r24, r20
    6e1a:	95 1f       	adc	r25, r21
    6e1c:	a6 1f       	adc	r26, r22
    6e1e:	b7 1f       	adc	r27, r23
    6e20:	0d a5       	lds	r16, 0x6d
    6e22:	1e a5       	lds	r17, 0x6e
    6e24:	2f a5       	lds	r18, 0x6f
    6e26:	38 a9       	sts	0x48, r19
    6e28:	08 17       	cp	r16, r24
    6e2a:	19 07       	cpc	r17, r25
    6e2c:	2a 07       	cpc	r18, r26
    6e2e:	3b 07       	cpc	r19, r27
    6e30:	18 f1       	brcs	.+70     	; 0x6e78 <__divdi3+0xe4a>
    6e32:	80 17       	cp	r24, r16
    6e34:	91 07       	cpc	r25, r17
    6e36:	a2 07       	cpc	r26, r18
    6e38:	b3 07       	cpc	r27, r19
    6e3a:	a1 f5       	brne	.+104    	; 0x6ea4 <__divdi3+0xe76>
    6e3c:	54 01       	movw	r10, r8
    6e3e:	99 24       	eor	r9, r9
    6e40:	88 24       	eor	r8, r8
    6e42:	89 ad       	sts	0x69, r24
    6e44:	9a ad       	sts	0x6a, r25
    6e46:	ab ad       	sts	0x6b, r26
    6e48:	bc ad       	sts	0x6c, r27
    6e4a:	a0 70       	andi	r26, 0x00	; 0
    6e4c:	b0 70       	andi	r27, 0x00	; 0
    6e4e:	88 0e       	add	r8, r24
    6e50:	99 1e       	adc	r9, r25
    6e52:	aa 1e       	adc	r10, r26
    6e54:	bb 1e       	adc	r11, r27
    6e56:	4d a9       	sts	0x4d, r20
    6e58:	5e a9       	sts	0x4e, r21
    6e5a:	6f a9       	sts	0x4f, r22
    6e5c:	78 ad       	sts	0x68, r23
    6e5e:	03 2c       	mov	r0, r3
    6e60:	04 c0       	rjmp	.+8      	; 0x6e6a <__divdi3+0xe3c>
    6e62:	44 0f       	add	r20, r20
    6e64:	55 1f       	adc	r21, r21
    6e66:	66 1f       	adc	r22, r22
    6e68:	77 1f       	adc	r23, r23
    6e6a:	0a 94       	dec	r0
    6e6c:	d2 f7       	brpl	.-12     	; 0x6e62 <__divdi3+0xe34>
    6e6e:	48 15       	cp	r20, r8
    6e70:	59 05       	cpc	r21, r9
    6e72:	6a 05       	cpc	r22, r10
    6e74:	7b 05       	cpc	r23, r11
    6e76:	b0 f4       	brcc	.+44     	; 0x6ea4 <__divdi3+0xe76>
    6e78:	08 94       	sec
    6e7a:	c1 08       	sbc	r12, r1
    6e7c:	d1 08       	sbc	r13, r1
    6e7e:	e1 08       	sbc	r14, r1
    6e80:	f1 08       	sbc	r15, r1
    6e82:	10 c0       	rjmp	.+32     	; 0x6ea4 <__divdi3+0xe76>
    6e84:	44 24       	eor	r4, r4
    6e86:	55 24       	eor	r5, r5
    6e88:	32 01       	movw	r6, r4
    6e8a:	cc 24       	eor	r12, r12
    6e8c:	dd 24       	eor	r13, r13
    6e8e:	76 01       	movw	r14, r12
    6e90:	0c c0       	rjmp	.+24     	; 0x6eaa <__divdi3+0xe7c>
    6e92:	44 24       	eor	r4, r4
    6e94:	55 24       	eor	r5, r5
    6e96:	32 01       	movw	r6, r4
    6e98:	81 e0       	ldi	r24, 0x01	; 1
    6e9a:	c8 2e       	mov	r12, r24
    6e9c:	d1 2c       	mov	r13, r1
    6e9e:	e1 2c       	mov	r14, r1
    6ea0:	f1 2c       	mov	r15, r1
    6ea2:	03 c0       	rjmp	.+6      	; 0x6eaa <__divdi3+0xe7c>
    6ea4:	44 24       	eor	r4, r4
    6ea6:	55 24       	eor	r5, r5
    6ea8:	32 01       	movw	r6, r4
    6eaa:	fe 01       	movw	r30, r28
    6eac:	31 96       	adiw	r30, 0x01	; 1
    6eae:	88 e0       	ldi	r24, 0x08	; 8
    6eb0:	df 01       	movw	r26, r30
    6eb2:	1d 92       	st	X+, r1
    6eb4:	8a 95       	dec	r24
    6eb6:	e9 f7       	brne	.-6      	; 0x6eb2 <__divdi3+0xe84>
    6eb8:	c9 82       	std	Y+1, r12	; 0x01
    6eba:	da 82       	std	Y+2, r13	; 0x02
    6ebc:	eb 82       	std	Y+3, r14	; 0x03
    6ebe:	fc 82       	std	Y+4, r15	; 0x04
    6ec0:	4d 82       	std	Y+5, r4	; 0x05
    6ec2:	5e 82       	std	Y+6, r5	; 0x06
    6ec4:	6f 82       	std	Y+7, r6	; 0x07
    6ec6:	78 86       	std	Y+8, r7	; 0x08
    6ec8:	2c 2d       	mov	r18, r12
    6eca:	3a 81       	ldd	r19, Y+2	; 0x02
    6ecc:	4b 81       	ldd	r20, Y+3	; 0x03
    6ece:	5c 81       	ldd	r21, Y+4	; 0x04
    6ed0:	64 2d       	mov	r22, r4
    6ed2:	7e 81       	ldd	r23, Y+6	; 0x06
    6ed4:	8f 81       	ldd	r24, Y+7	; 0x07
    6ed6:	98 85       	ldd	r25, Y+8	; 0x08
    6ed8:	25 96       	adiw	r28, 0x05	; 5
    6eda:	ec ac       	sts	0xac, r30
    6edc:	fd ac       	sts	0xad, r31
    6ede:	0e ad       	sts	0x6e, r16
    6ee0:	1f ad       	sts	0x6f, r17
    6ee2:	25 97       	sbiw	r28, 0x05	; 5
    6ee4:	e1 14       	cp	r14, r1
    6ee6:	f1 04       	cpc	r15, r1
    6ee8:	01 05       	cpc	r16, r1
    6eea:	11 05       	cpc	r17, r1
    6eec:	09 f4       	brne	.+2      	; 0x6ef0 <__divdi3+0xec2>
    6eee:	56 c0       	rjmp	.+172    	; 0x6f9c <__divdi3+0xf6e>
    6ef0:	21 95       	neg	r18
    6ef2:	e1 e0       	ldi	r30, 0x01	; 1
    6ef4:	12 16       	cp	r1, r18
    6ef6:	08 f0       	brcs	.+2      	; 0x6efa <__divdi3+0xecc>
    6ef8:	e0 e0       	ldi	r30, 0x00	; 0
    6efa:	31 95       	neg	r19
    6efc:	f1 e0       	ldi	r31, 0x01	; 1
    6efe:	13 16       	cp	r1, r19
    6f00:	08 f0       	brcs	.+2      	; 0x6f04 <__divdi3+0xed6>
    6f02:	f0 e0       	ldi	r31, 0x00	; 0
    6f04:	03 2f       	mov	r16, r19
    6f06:	0e 1b       	sub	r16, r30
    6f08:	e1 e0       	ldi	r30, 0x01	; 1
    6f0a:	30 17       	cp	r19, r16
    6f0c:	08 f0       	brcs	.+2      	; 0x6f10 <__divdi3+0xee2>
    6f0e:	e0 e0       	ldi	r30, 0x00	; 0
    6f10:	fe 2b       	or	r31, r30
    6f12:	41 95       	neg	r20
    6f14:	e1 e0       	ldi	r30, 0x01	; 1
    6f16:	14 16       	cp	r1, r20
    6f18:	08 f0       	brcs	.+2      	; 0x6f1c <__divdi3+0xeee>
    6f1a:	e0 e0       	ldi	r30, 0x00	; 0
    6f1c:	14 2f       	mov	r17, r20
    6f1e:	1f 1b       	sub	r17, r31
    6f20:	31 e0       	ldi	r19, 0x01	; 1
    6f22:	41 17       	cp	r20, r17
    6f24:	08 f0       	brcs	.+2      	; 0x6f28 <__divdi3+0xefa>
    6f26:	30 e0       	ldi	r19, 0x00	; 0
    6f28:	e3 2b       	or	r30, r19
    6f2a:	51 95       	neg	r21
    6f2c:	f1 e0       	ldi	r31, 0x01	; 1
    6f2e:	15 16       	cp	r1, r21
    6f30:	08 f0       	brcs	.+2      	; 0x6f34 <__divdi3+0xf06>
    6f32:	f0 e0       	ldi	r31, 0x00	; 0
    6f34:	b5 2f       	mov	r27, r21
    6f36:	be 1b       	sub	r27, r30
    6f38:	31 e0       	ldi	r19, 0x01	; 1
    6f3a:	5b 17       	cp	r21, r27
    6f3c:	08 f0       	brcs	.+2      	; 0x6f40 <__divdi3+0xf12>
    6f3e:	30 e0       	ldi	r19, 0x00	; 0
    6f40:	f3 2b       	or	r31, r19
    6f42:	61 95       	neg	r22
    6f44:	e1 e0       	ldi	r30, 0x01	; 1
    6f46:	16 16       	cp	r1, r22
    6f48:	08 f0       	brcs	.+2      	; 0x6f4c <__divdi3+0xf1e>
    6f4a:	e0 e0       	ldi	r30, 0x00	; 0
    6f4c:	46 2e       	mov	r4, r22
    6f4e:	4f 1a       	sub	r4, r31
    6f50:	31 e0       	ldi	r19, 0x01	; 1
    6f52:	64 15       	cp	r22, r4
    6f54:	08 f0       	brcs	.+2      	; 0x6f58 <__divdi3+0xf2a>
    6f56:	30 e0       	ldi	r19, 0x00	; 0
    6f58:	e3 2b       	or	r30, r19
    6f5a:	71 95       	neg	r23
    6f5c:	f1 e0       	ldi	r31, 0x01	; 1
    6f5e:	17 16       	cp	r1, r23
    6f60:	08 f0       	brcs	.+2      	; 0x6f64 <__divdi3+0xf36>
    6f62:	f0 e0       	ldi	r31, 0x00	; 0
    6f64:	a7 2f       	mov	r26, r23
    6f66:	ae 1b       	sub	r26, r30
    6f68:	31 e0       	ldi	r19, 0x01	; 1
    6f6a:	7a 17       	cp	r23, r26
    6f6c:	08 f0       	brcs	.+2      	; 0x6f70 <__divdi3+0xf42>
    6f6e:	30 e0       	ldi	r19, 0x00	; 0
    6f70:	f3 2b       	or	r31, r19
    6f72:	81 95       	neg	r24
    6f74:	e1 e0       	ldi	r30, 0x01	; 1
    6f76:	18 16       	cp	r1, r24
    6f78:	08 f0       	brcs	.+2      	; 0x6f7c <__divdi3+0xf4e>
    6f7a:	e0 e0       	ldi	r30, 0x00	; 0
    6f7c:	f8 2e       	mov	r15, r24
    6f7e:	ff 1a       	sub	r15, r31
    6f80:	ff 2d       	mov	r31, r15
    6f82:	31 e0       	ldi	r19, 0x01	; 1
    6f84:	8f 15       	cp	r24, r15
    6f86:	08 f0       	brcs	.+2      	; 0x6f8a <__divdi3+0xf5c>
    6f88:	30 e0       	ldi	r19, 0x00	; 0
    6f8a:	e3 2b       	or	r30, r19
    6f8c:	91 95       	neg	r25
    6f8e:	30 2f       	mov	r19, r16
    6f90:	41 2f       	mov	r20, r17
    6f92:	5b 2f       	mov	r21, r27
    6f94:	64 2d       	mov	r22, r4
    6f96:	7a 2f       	mov	r23, r26
    6f98:	8f 2f       	mov	r24, r31
    6f9a:	9e 1b       	sub	r25, r30
    6f9c:	c8 5b       	subi	r28, 0xB8	; 184
    6f9e:	df 4f       	sbci	r29, 0xFF	; 255
    6fa0:	e1 e1       	ldi	r30, 0x11	; 17
    6fa2:	0c 94 1f 3a 	jmp	0x743e	; 0x743e <__epilogue_restores__+0x2>

00006fa6 <__subsf3>:
    6fa6:	50 58       	subi	r21, 0x80	; 128

00006fa8 <__addsf3>:
    6fa8:	bb 27       	eor	r27, r27
    6faa:	aa 27       	eor	r26, r26
    6fac:	0e d0       	rcall	.+28     	; 0x6fca <__addsf3x>
    6fae:	48 c1       	rjmp	.+656    	; 0x7240 <__fp_round>
    6fb0:	39 d1       	rcall	.+626    	; 0x7224 <__fp_pscA>
    6fb2:	30 f0       	brcs	.+12     	; 0x6fc0 <__addsf3+0x18>
    6fb4:	3e d1       	rcall	.+636    	; 0x7232 <__fp_pscB>
    6fb6:	20 f0       	brcs	.+8      	; 0x6fc0 <__addsf3+0x18>
    6fb8:	31 f4       	brne	.+12     	; 0x6fc6 <__addsf3+0x1e>
    6fba:	9f 3f       	cpi	r25, 0xFF	; 255
    6fbc:	11 f4       	brne	.+4      	; 0x6fc2 <__addsf3+0x1a>
    6fbe:	1e f4       	brtc	.+6      	; 0x6fc6 <__addsf3+0x1e>
    6fc0:	2e c1       	rjmp	.+604    	; 0x721e <__fp_nan>
    6fc2:	0e f4       	brtc	.+2      	; 0x6fc6 <__addsf3+0x1e>
    6fc4:	e0 95       	com	r30
    6fc6:	e7 fb       	bst	r30, 7
    6fc8:	24 c1       	rjmp	.+584    	; 0x7212 <__fp_inf>

00006fca <__addsf3x>:
    6fca:	e9 2f       	mov	r30, r25
    6fcc:	4a d1       	rcall	.+660    	; 0x7262 <__fp_split3>
    6fce:	80 f3       	brcs	.-32     	; 0x6fb0 <__addsf3+0x8>
    6fd0:	ba 17       	cp	r27, r26
    6fd2:	62 07       	cpc	r22, r18
    6fd4:	73 07       	cpc	r23, r19
    6fd6:	84 07       	cpc	r24, r20
    6fd8:	95 07       	cpc	r25, r21
    6fda:	18 f0       	brcs	.+6      	; 0x6fe2 <__addsf3x+0x18>
    6fdc:	71 f4       	brne	.+28     	; 0x6ffa <__addsf3x+0x30>
    6fde:	9e f5       	brtc	.+102    	; 0x7046 <__addsf3x+0x7c>
    6fe0:	62 c1       	rjmp	.+708    	; 0x72a6 <__fp_zero>
    6fe2:	0e f4       	brtc	.+2      	; 0x6fe6 <__addsf3x+0x1c>
    6fe4:	e0 95       	com	r30
    6fe6:	0b 2e       	mov	r0, r27
    6fe8:	ba 2f       	mov	r27, r26
    6fea:	a0 2d       	mov	r26, r0
    6fec:	0b 01       	movw	r0, r22
    6fee:	b9 01       	movw	r22, r18
    6ff0:	90 01       	movw	r18, r0
    6ff2:	0c 01       	movw	r0, r24
    6ff4:	ca 01       	movw	r24, r20
    6ff6:	a0 01       	movw	r20, r0
    6ff8:	11 24       	eor	r1, r1
    6ffa:	ff 27       	eor	r31, r31
    6ffc:	59 1b       	sub	r21, r25
    6ffe:	99 f0       	breq	.+38     	; 0x7026 <__addsf3x+0x5c>
    7000:	59 3f       	cpi	r21, 0xF9	; 249
    7002:	50 f4       	brcc	.+20     	; 0x7018 <__addsf3x+0x4e>
    7004:	50 3e       	cpi	r21, 0xE0	; 224
    7006:	68 f1       	brcs	.+90     	; 0x7062 <__addsf3x+0x98>
    7008:	1a 16       	cp	r1, r26
    700a:	f0 40       	sbci	r31, 0x00	; 0
    700c:	a2 2f       	mov	r26, r18
    700e:	23 2f       	mov	r18, r19
    7010:	34 2f       	mov	r19, r20
    7012:	44 27       	eor	r20, r20
    7014:	58 5f       	subi	r21, 0xF8	; 248
    7016:	f3 cf       	rjmp	.-26     	; 0x6ffe <__addsf3x+0x34>
    7018:	46 95       	lsr	r20
    701a:	37 95       	ror	r19
    701c:	27 95       	ror	r18
    701e:	a7 95       	ror	r26
    7020:	f0 40       	sbci	r31, 0x00	; 0
    7022:	53 95       	inc	r21
    7024:	c9 f7       	brne	.-14     	; 0x7018 <__addsf3x+0x4e>
    7026:	7e f4       	brtc	.+30     	; 0x7046 <__addsf3x+0x7c>
    7028:	1f 16       	cp	r1, r31
    702a:	ba 0b       	sbc	r27, r26
    702c:	62 0b       	sbc	r22, r18
    702e:	73 0b       	sbc	r23, r19
    7030:	84 0b       	sbc	r24, r20
    7032:	ba f0       	brmi	.+46     	; 0x7062 <__addsf3x+0x98>
    7034:	91 50       	subi	r25, 0x01	; 1
    7036:	a1 f0       	breq	.+40     	; 0x7060 <__addsf3x+0x96>
    7038:	ff 0f       	add	r31, r31
    703a:	bb 1f       	adc	r27, r27
    703c:	66 1f       	adc	r22, r22
    703e:	77 1f       	adc	r23, r23
    7040:	88 1f       	adc	r24, r24
    7042:	c2 f7       	brpl	.-16     	; 0x7034 <__addsf3x+0x6a>
    7044:	0e c0       	rjmp	.+28     	; 0x7062 <__addsf3x+0x98>
    7046:	ba 0f       	add	r27, r26
    7048:	62 1f       	adc	r22, r18
    704a:	73 1f       	adc	r23, r19
    704c:	84 1f       	adc	r24, r20
    704e:	48 f4       	brcc	.+18     	; 0x7062 <__addsf3x+0x98>
    7050:	87 95       	ror	r24
    7052:	77 95       	ror	r23
    7054:	67 95       	ror	r22
    7056:	b7 95       	ror	r27
    7058:	f7 95       	ror	r31
    705a:	9e 3f       	cpi	r25, 0xFE	; 254
    705c:	08 f0       	brcs	.+2      	; 0x7060 <__addsf3x+0x96>
    705e:	b3 cf       	rjmp	.-154    	; 0x6fc6 <__addsf3+0x1e>
    7060:	93 95       	inc	r25
    7062:	88 0f       	add	r24, r24
    7064:	08 f0       	brcs	.+2      	; 0x7068 <__addsf3x+0x9e>
    7066:	99 27       	eor	r25, r25
    7068:	ee 0f       	add	r30, r30
    706a:	97 95       	ror	r25
    706c:	87 95       	ror	r24
    706e:	08 95       	ret

00007070 <__divsf3>:
    7070:	0c d0       	rcall	.+24     	; 0x708a <__divsf3x>
    7072:	e6 c0       	rjmp	.+460    	; 0x7240 <__fp_round>
    7074:	de d0       	rcall	.+444    	; 0x7232 <__fp_pscB>
    7076:	40 f0       	brcs	.+16     	; 0x7088 <__divsf3+0x18>
    7078:	d5 d0       	rcall	.+426    	; 0x7224 <__fp_pscA>
    707a:	30 f0       	brcs	.+12     	; 0x7088 <__divsf3+0x18>
    707c:	21 f4       	brne	.+8      	; 0x7086 <__divsf3+0x16>
    707e:	5f 3f       	cpi	r21, 0xFF	; 255
    7080:	19 f0       	breq	.+6      	; 0x7088 <__divsf3+0x18>
    7082:	c7 c0       	rjmp	.+398    	; 0x7212 <__fp_inf>
    7084:	51 11       	cpse	r21, r1
    7086:	10 c1       	rjmp	.+544    	; 0x72a8 <__fp_szero>
    7088:	ca c0       	rjmp	.+404    	; 0x721e <__fp_nan>

0000708a <__divsf3x>:
    708a:	eb d0       	rcall	.+470    	; 0x7262 <__fp_split3>
    708c:	98 f3       	brcs	.-26     	; 0x7074 <__divsf3+0x4>

0000708e <__divsf3_pse>:
    708e:	99 23       	and	r25, r25
    7090:	c9 f3       	breq	.-14     	; 0x7084 <__divsf3+0x14>
    7092:	55 23       	and	r21, r21
    7094:	b1 f3       	breq	.-20     	; 0x7082 <__divsf3+0x12>
    7096:	95 1b       	sub	r25, r21
    7098:	55 0b       	sbc	r21, r21
    709a:	bb 27       	eor	r27, r27
    709c:	aa 27       	eor	r26, r26
    709e:	62 17       	cp	r22, r18
    70a0:	73 07       	cpc	r23, r19
    70a2:	84 07       	cpc	r24, r20
    70a4:	38 f0       	brcs	.+14     	; 0x70b4 <__divsf3_pse+0x26>
    70a6:	9f 5f       	subi	r25, 0xFF	; 255
    70a8:	5f 4f       	sbci	r21, 0xFF	; 255
    70aa:	22 0f       	add	r18, r18
    70ac:	33 1f       	adc	r19, r19
    70ae:	44 1f       	adc	r20, r20
    70b0:	aa 1f       	adc	r26, r26
    70b2:	a9 f3       	breq	.-22     	; 0x709e <__divsf3_pse+0x10>
    70b4:	33 d0       	rcall	.+102    	; 0x711c <__divsf3_pse+0x8e>
    70b6:	0e 2e       	mov	r0, r30
    70b8:	3a f0       	brmi	.+14     	; 0x70c8 <__divsf3_pse+0x3a>
    70ba:	e0 e8       	ldi	r30, 0x80	; 128
    70bc:	30 d0       	rcall	.+96     	; 0x711e <__divsf3_pse+0x90>
    70be:	91 50       	subi	r25, 0x01	; 1
    70c0:	50 40       	sbci	r21, 0x00	; 0
    70c2:	e6 95       	lsr	r30
    70c4:	00 1c       	adc	r0, r0
    70c6:	ca f7       	brpl	.-14     	; 0x70ba <__divsf3_pse+0x2c>
    70c8:	29 d0       	rcall	.+82     	; 0x711c <__divsf3_pse+0x8e>
    70ca:	fe 2f       	mov	r31, r30
    70cc:	27 d0       	rcall	.+78     	; 0x711c <__divsf3_pse+0x8e>
    70ce:	66 0f       	add	r22, r22
    70d0:	77 1f       	adc	r23, r23
    70d2:	88 1f       	adc	r24, r24
    70d4:	bb 1f       	adc	r27, r27
    70d6:	26 17       	cp	r18, r22
    70d8:	37 07       	cpc	r19, r23
    70da:	48 07       	cpc	r20, r24
    70dc:	ab 07       	cpc	r26, r27
    70de:	b0 e8       	ldi	r27, 0x80	; 128
    70e0:	09 f0       	breq	.+2      	; 0x70e4 <__divsf3_pse+0x56>
    70e2:	bb 0b       	sbc	r27, r27
    70e4:	80 2d       	mov	r24, r0
    70e6:	bf 01       	movw	r22, r30
    70e8:	ff 27       	eor	r31, r31
    70ea:	93 58       	subi	r25, 0x83	; 131
    70ec:	5f 4f       	sbci	r21, 0xFF	; 255
    70ee:	2a f0       	brmi	.+10     	; 0x70fa <__divsf3_pse+0x6c>
    70f0:	9e 3f       	cpi	r25, 0xFE	; 254
    70f2:	51 05       	cpc	r21, r1
    70f4:	68 f0       	brcs	.+26     	; 0x7110 <__divsf3_pse+0x82>
    70f6:	8d c0       	rjmp	.+282    	; 0x7212 <__fp_inf>
    70f8:	d7 c0       	rjmp	.+430    	; 0x72a8 <__fp_szero>
    70fa:	5f 3f       	cpi	r21, 0xFF	; 255
    70fc:	ec f3       	brlt	.-6      	; 0x70f8 <__divsf3_pse+0x6a>
    70fe:	98 3e       	cpi	r25, 0xE8	; 232
    7100:	dc f3       	brlt	.-10     	; 0x70f8 <__divsf3_pse+0x6a>
    7102:	86 95       	lsr	r24
    7104:	77 95       	ror	r23
    7106:	67 95       	ror	r22
    7108:	b7 95       	ror	r27
    710a:	f7 95       	ror	r31
    710c:	9f 5f       	subi	r25, 0xFF	; 255
    710e:	c9 f7       	brne	.-14     	; 0x7102 <__divsf3_pse+0x74>
    7110:	88 0f       	add	r24, r24
    7112:	91 1d       	adc	r25, r1
    7114:	96 95       	lsr	r25
    7116:	87 95       	ror	r24
    7118:	97 f9       	bld	r25, 7
    711a:	08 95       	ret
    711c:	e1 e0       	ldi	r30, 0x01	; 1
    711e:	66 0f       	add	r22, r22
    7120:	77 1f       	adc	r23, r23
    7122:	88 1f       	adc	r24, r24
    7124:	bb 1f       	adc	r27, r27
    7126:	62 17       	cp	r22, r18
    7128:	73 07       	cpc	r23, r19
    712a:	84 07       	cpc	r24, r20
    712c:	ba 07       	cpc	r27, r26
    712e:	20 f0       	brcs	.+8      	; 0x7138 <__divsf3_pse+0xaa>
    7130:	62 1b       	sub	r22, r18
    7132:	73 0b       	sbc	r23, r19
    7134:	84 0b       	sbc	r24, r20
    7136:	ba 0b       	sbc	r27, r26
    7138:	ee 1f       	adc	r30, r30
    713a:	88 f7       	brcc	.-30     	; 0x711e <__divsf3_pse+0x90>
    713c:	e0 95       	com	r30
    713e:	08 95       	ret

00007140 <__fixunssfsi>:
    7140:	98 d0       	rcall	.+304    	; 0x7272 <__fp_splitA>
    7142:	88 f0       	brcs	.+34     	; 0x7166 <__fixunssfsi+0x26>
    7144:	9f 57       	subi	r25, 0x7F	; 127
    7146:	90 f0       	brcs	.+36     	; 0x716c <__fixunssfsi+0x2c>
    7148:	b9 2f       	mov	r27, r25
    714a:	99 27       	eor	r25, r25
    714c:	b7 51       	subi	r27, 0x17	; 23
    714e:	a0 f0       	brcs	.+40     	; 0x7178 <__fixunssfsi+0x38>
    7150:	d1 f0       	breq	.+52     	; 0x7186 <__fixunssfsi+0x46>
    7152:	66 0f       	add	r22, r22
    7154:	77 1f       	adc	r23, r23
    7156:	88 1f       	adc	r24, r24
    7158:	99 1f       	adc	r25, r25
    715a:	1a f0       	brmi	.+6      	; 0x7162 <__fixunssfsi+0x22>
    715c:	ba 95       	dec	r27
    715e:	c9 f7       	brne	.-14     	; 0x7152 <__fixunssfsi+0x12>
    7160:	12 c0       	rjmp	.+36     	; 0x7186 <__fixunssfsi+0x46>
    7162:	b1 30       	cpi	r27, 0x01	; 1
    7164:	81 f0       	breq	.+32     	; 0x7186 <__fixunssfsi+0x46>
    7166:	9f d0       	rcall	.+318    	; 0x72a6 <__fp_zero>
    7168:	b1 e0       	ldi	r27, 0x01	; 1
    716a:	08 95       	ret
    716c:	9c c0       	rjmp	.+312    	; 0x72a6 <__fp_zero>
    716e:	67 2f       	mov	r22, r23
    7170:	78 2f       	mov	r23, r24
    7172:	88 27       	eor	r24, r24
    7174:	b8 5f       	subi	r27, 0xF8	; 248
    7176:	39 f0       	breq	.+14     	; 0x7186 <__fixunssfsi+0x46>
    7178:	b9 3f       	cpi	r27, 0xF9	; 249
    717a:	cc f3       	brlt	.-14     	; 0x716e <__fixunssfsi+0x2e>
    717c:	86 95       	lsr	r24
    717e:	77 95       	ror	r23
    7180:	67 95       	ror	r22
    7182:	b3 95       	inc	r27
    7184:	d9 f7       	brne	.-10     	; 0x717c <__fixunssfsi+0x3c>
    7186:	3e f4       	brtc	.+14     	; 0x7196 <__fixunssfsi+0x56>
    7188:	90 95       	com	r25
    718a:	80 95       	com	r24
    718c:	70 95       	com	r23
    718e:	61 95       	neg	r22
    7190:	7f 4f       	sbci	r23, 0xFF	; 255
    7192:	8f 4f       	sbci	r24, 0xFF	; 255
    7194:	9f 4f       	sbci	r25, 0xFF	; 255
    7196:	08 95       	ret

00007198 <__floatunsisf>:
    7198:	e8 94       	clt
    719a:	09 c0       	rjmp	.+18     	; 0x71ae <__floatsisf+0x12>

0000719c <__floatsisf>:
    719c:	97 fb       	bst	r25, 7
    719e:	3e f4       	brtc	.+14     	; 0x71ae <__floatsisf+0x12>
    71a0:	90 95       	com	r25
    71a2:	80 95       	com	r24
    71a4:	70 95       	com	r23
    71a6:	61 95       	neg	r22
    71a8:	7f 4f       	sbci	r23, 0xFF	; 255
    71aa:	8f 4f       	sbci	r24, 0xFF	; 255
    71ac:	9f 4f       	sbci	r25, 0xFF	; 255
    71ae:	99 23       	and	r25, r25
    71b0:	a9 f0       	breq	.+42     	; 0x71dc <__floatsisf+0x40>
    71b2:	f9 2f       	mov	r31, r25
    71b4:	96 e9       	ldi	r25, 0x96	; 150
    71b6:	bb 27       	eor	r27, r27
    71b8:	93 95       	inc	r25
    71ba:	f6 95       	lsr	r31
    71bc:	87 95       	ror	r24
    71be:	77 95       	ror	r23
    71c0:	67 95       	ror	r22
    71c2:	b7 95       	ror	r27
    71c4:	f1 11       	cpse	r31, r1
    71c6:	f8 cf       	rjmp	.-16     	; 0x71b8 <__floatsisf+0x1c>
    71c8:	fa f4       	brpl	.+62     	; 0x7208 <__floatsisf+0x6c>
    71ca:	bb 0f       	add	r27, r27
    71cc:	11 f4       	brne	.+4      	; 0x71d2 <__floatsisf+0x36>
    71ce:	60 ff       	sbrs	r22, 0
    71d0:	1b c0       	rjmp	.+54     	; 0x7208 <__floatsisf+0x6c>
    71d2:	6f 5f       	subi	r22, 0xFF	; 255
    71d4:	7f 4f       	sbci	r23, 0xFF	; 255
    71d6:	8f 4f       	sbci	r24, 0xFF	; 255
    71d8:	9f 4f       	sbci	r25, 0xFF	; 255
    71da:	16 c0       	rjmp	.+44     	; 0x7208 <__floatsisf+0x6c>
    71dc:	88 23       	and	r24, r24
    71de:	11 f0       	breq	.+4      	; 0x71e4 <__floatsisf+0x48>
    71e0:	96 e9       	ldi	r25, 0x96	; 150
    71e2:	11 c0       	rjmp	.+34     	; 0x7206 <__floatsisf+0x6a>
    71e4:	77 23       	and	r23, r23
    71e6:	21 f0       	breq	.+8      	; 0x71f0 <__floatsisf+0x54>
    71e8:	9e e8       	ldi	r25, 0x8E	; 142
    71ea:	87 2f       	mov	r24, r23
    71ec:	76 2f       	mov	r23, r22
    71ee:	05 c0       	rjmp	.+10     	; 0x71fa <__floatsisf+0x5e>
    71f0:	66 23       	and	r22, r22
    71f2:	71 f0       	breq	.+28     	; 0x7210 <__floatsisf+0x74>
    71f4:	96 e8       	ldi	r25, 0x86	; 134
    71f6:	86 2f       	mov	r24, r22
    71f8:	70 e0       	ldi	r23, 0x00	; 0
    71fa:	60 e0       	ldi	r22, 0x00	; 0
    71fc:	2a f0       	brmi	.+10     	; 0x7208 <__floatsisf+0x6c>
    71fe:	9a 95       	dec	r25
    7200:	66 0f       	add	r22, r22
    7202:	77 1f       	adc	r23, r23
    7204:	88 1f       	adc	r24, r24
    7206:	da f7       	brpl	.-10     	; 0x71fe <__floatsisf+0x62>
    7208:	88 0f       	add	r24, r24
    720a:	96 95       	lsr	r25
    720c:	87 95       	ror	r24
    720e:	97 f9       	bld	r25, 7
    7210:	08 95       	ret

00007212 <__fp_inf>:
    7212:	97 f9       	bld	r25, 7
    7214:	9f 67       	ori	r25, 0x7F	; 127
    7216:	80 e8       	ldi	r24, 0x80	; 128
    7218:	70 e0       	ldi	r23, 0x00	; 0
    721a:	60 e0       	ldi	r22, 0x00	; 0
    721c:	08 95       	ret

0000721e <__fp_nan>:
    721e:	9f ef       	ldi	r25, 0xFF	; 255
    7220:	80 ec       	ldi	r24, 0xC0	; 192
    7222:	08 95       	ret

00007224 <__fp_pscA>:
    7224:	00 24       	eor	r0, r0
    7226:	0a 94       	dec	r0
    7228:	16 16       	cp	r1, r22
    722a:	17 06       	cpc	r1, r23
    722c:	18 06       	cpc	r1, r24
    722e:	09 06       	cpc	r0, r25
    7230:	08 95       	ret

00007232 <__fp_pscB>:
    7232:	00 24       	eor	r0, r0
    7234:	0a 94       	dec	r0
    7236:	12 16       	cp	r1, r18
    7238:	13 06       	cpc	r1, r19
    723a:	14 06       	cpc	r1, r20
    723c:	05 06       	cpc	r0, r21
    723e:	08 95       	ret

00007240 <__fp_round>:
    7240:	09 2e       	mov	r0, r25
    7242:	03 94       	inc	r0
    7244:	00 0c       	add	r0, r0
    7246:	11 f4       	brne	.+4      	; 0x724c <__fp_round+0xc>
    7248:	88 23       	and	r24, r24
    724a:	52 f0       	brmi	.+20     	; 0x7260 <__fp_round+0x20>
    724c:	bb 0f       	add	r27, r27
    724e:	40 f4       	brcc	.+16     	; 0x7260 <__fp_round+0x20>
    7250:	bf 2b       	or	r27, r31
    7252:	11 f4       	brne	.+4      	; 0x7258 <__fp_round+0x18>
    7254:	60 ff       	sbrs	r22, 0
    7256:	04 c0       	rjmp	.+8      	; 0x7260 <__fp_round+0x20>
    7258:	6f 5f       	subi	r22, 0xFF	; 255
    725a:	7f 4f       	sbci	r23, 0xFF	; 255
    725c:	8f 4f       	sbci	r24, 0xFF	; 255
    725e:	9f 4f       	sbci	r25, 0xFF	; 255
    7260:	08 95       	ret

00007262 <__fp_split3>:
    7262:	57 fd       	sbrc	r21, 7
    7264:	90 58       	subi	r25, 0x80	; 128
    7266:	44 0f       	add	r20, r20
    7268:	55 1f       	adc	r21, r21
    726a:	59 f0       	breq	.+22     	; 0x7282 <__fp_splitA+0x10>
    726c:	5f 3f       	cpi	r21, 0xFF	; 255
    726e:	71 f0       	breq	.+28     	; 0x728c <__fp_splitA+0x1a>
    7270:	47 95       	ror	r20

00007272 <__fp_splitA>:
    7272:	88 0f       	add	r24, r24
    7274:	97 fb       	bst	r25, 7
    7276:	99 1f       	adc	r25, r25
    7278:	61 f0       	breq	.+24     	; 0x7292 <__fp_splitA+0x20>
    727a:	9f 3f       	cpi	r25, 0xFF	; 255
    727c:	79 f0       	breq	.+30     	; 0x729c <__fp_splitA+0x2a>
    727e:	87 95       	ror	r24
    7280:	08 95       	ret
    7282:	12 16       	cp	r1, r18
    7284:	13 06       	cpc	r1, r19
    7286:	14 06       	cpc	r1, r20
    7288:	55 1f       	adc	r21, r21
    728a:	f2 cf       	rjmp	.-28     	; 0x7270 <__fp_split3+0xe>
    728c:	46 95       	lsr	r20
    728e:	f1 df       	rcall	.-30     	; 0x7272 <__fp_splitA>
    7290:	08 c0       	rjmp	.+16     	; 0x72a2 <__fp_splitA+0x30>
    7292:	16 16       	cp	r1, r22
    7294:	17 06       	cpc	r1, r23
    7296:	18 06       	cpc	r1, r24
    7298:	99 1f       	adc	r25, r25
    729a:	f1 cf       	rjmp	.-30     	; 0x727e <__fp_splitA+0xc>
    729c:	86 95       	lsr	r24
    729e:	71 05       	cpc	r23, r1
    72a0:	61 05       	cpc	r22, r1
    72a2:	08 94       	sec
    72a4:	08 95       	ret

000072a6 <__fp_zero>:
    72a6:	e8 94       	clt

000072a8 <__fp_szero>:
    72a8:	bb 27       	eor	r27, r27
    72aa:	66 27       	eor	r22, r22
    72ac:	77 27       	eor	r23, r23
    72ae:	cb 01       	movw	r24, r22
    72b0:	97 f9       	bld	r25, 7
    72b2:	08 95       	ret

000072b4 <__gesf2>:
    72b4:	03 d0       	rcall	.+6      	; 0x72bc <__fp_cmp>
    72b6:	08 f4       	brcc	.+2      	; 0x72ba <__gesf2+0x6>
    72b8:	8f ef       	ldi	r24, 0xFF	; 255
    72ba:	08 95       	ret

000072bc <__fp_cmp>:
    72bc:	99 0f       	add	r25, r25
    72be:	00 08       	sbc	r0, r0
    72c0:	55 0f       	add	r21, r21
    72c2:	aa 0b       	sbc	r26, r26
    72c4:	e0 e8       	ldi	r30, 0x80	; 128
    72c6:	fe ef       	ldi	r31, 0xFE	; 254
    72c8:	16 16       	cp	r1, r22
    72ca:	17 06       	cpc	r1, r23
    72cc:	e8 07       	cpc	r30, r24
    72ce:	f9 07       	cpc	r31, r25
    72d0:	c0 f0       	brcs	.+48     	; 0x7302 <__fp_cmp+0x46>
    72d2:	12 16       	cp	r1, r18
    72d4:	13 06       	cpc	r1, r19
    72d6:	e4 07       	cpc	r30, r20
    72d8:	f5 07       	cpc	r31, r21
    72da:	98 f0       	brcs	.+38     	; 0x7302 <__fp_cmp+0x46>
    72dc:	62 1b       	sub	r22, r18
    72de:	73 0b       	sbc	r23, r19
    72e0:	84 0b       	sbc	r24, r20
    72e2:	95 0b       	sbc	r25, r21
    72e4:	39 f4       	brne	.+14     	; 0x72f4 <__fp_cmp+0x38>
    72e6:	0a 26       	eor	r0, r26
    72e8:	61 f0       	breq	.+24     	; 0x7302 <__fp_cmp+0x46>
    72ea:	23 2b       	or	r18, r19
    72ec:	24 2b       	or	r18, r20
    72ee:	25 2b       	or	r18, r21
    72f0:	21 f4       	brne	.+8      	; 0x72fa <__fp_cmp+0x3e>
    72f2:	08 95       	ret
    72f4:	0a 26       	eor	r0, r26
    72f6:	09 f4       	brne	.+2      	; 0x72fa <__fp_cmp+0x3e>
    72f8:	a1 40       	sbci	r26, 0x01	; 1
    72fa:	a6 95       	lsr	r26
    72fc:	8f ef       	ldi	r24, 0xFF	; 255
    72fe:	81 1d       	adc	r24, r1
    7300:	81 1d       	adc	r24, r1
    7302:	08 95       	ret

00007304 <__mulsi3>:
    7304:	62 9f       	mul	r22, r18
    7306:	d0 01       	movw	r26, r0
    7308:	73 9f       	mul	r23, r19
    730a:	f0 01       	movw	r30, r0
    730c:	82 9f       	mul	r24, r18
    730e:	e0 0d       	add	r30, r0
    7310:	f1 1d       	adc	r31, r1
    7312:	64 9f       	mul	r22, r20
    7314:	e0 0d       	add	r30, r0
    7316:	f1 1d       	adc	r31, r1
    7318:	92 9f       	mul	r25, r18
    731a:	f0 0d       	add	r31, r0
    731c:	83 9f       	mul	r24, r19
    731e:	f0 0d       	add	r31, r0
    7320:	74 9f       	mul	r23, r20
    7322:	f0 0d       	add	r31, r0
    7324:	65 9f       	mul	r22, r21
    7326:	f0 0d       	add	r31, r0
    7328:	99 27       	eor	r25, r25
    732a:	72 9f       	mul	r23, r18
    732c:	b0 0d       	add	r27, r0
    732e:	e1 1d       	adc	r30, r1
    7330:	f9 1f       	adc	r31, r25
    7332:	63 9f       	mul	r22, r19
    7334:	b0 0d       	add	r27, r0
    7336:	e1 1d       	adc	r30, r1
    7338:	f9 1f       	adc	r31, r25
    733a:	bd 01       	movw	r22, r26
    733c:	cf 01       	movw	r24, r30
    733e:	11 24       	eor	r1, r1
    7340:	08 95       	ret

00007342 <__divmodhi4>:
    7342:	97 fb       	bst	r25, 7
    7344:	09 2e       	mov	r0, r25
    7346:	07 26       	eor	r0, r23
    7348:	0a d0       	rcall	.+20     	; 0x735e <__divmodhi4_neg1>
    734a:	77 fd       	sbrc	r23, 7
    734c:	04 d0       	rcall	.+8      	; 0x7356 <__divmodhi4_neg2>
    734e:	49 d0       	rcall	.+146    	; 0x73e2 <__udivmodhi4>
    7350:	06 d0       	rcall	.+12     	; 0x735e <__divmodhi4_neg1>
    7352:	00 20       	and	r0, r0
    7354:	1a f4       	brpl	.+6      	; 0x735c <__divmodhi4_exit>

00007356 <__divmodhi4_neg2>:
    7356:	70 95       	com	r23
    7358:	61 95       	neg	r22
    735a:	7f 4f       	sbci	r23, 0xFF	; 255

0000735c <__divmodhi4_exit>:
    735c:	08 95       	ret

0000735e <__divmodhi4_neg1>:
    735e:	f6 f7       	brtc	.-4      	; 0x735c <__divmodhi4_exit>
    7360:	90 95       	com	r25
    7362:	81 95       	neg	r24
    7364:	9f 4f       	sbci	r25, 0xFF	; 255
    7366:	08 95       	ret

00007368 <__udivmodsi4>:
    7368:	a1 e2       	ldi	r26, 0x21	; 33
    736a:	1a 2e       	mov	r1, r26
    736c:	aa 1b       	sub	r26, r26
    736e:	bb 1b       	sub	r27, r27
    7370:	fd 01       	movw	r30, r26
    7372:	0d c0       	rjmp	.+26     	; 0x738e <__udivmodsi4_ep>

00007374 <__udivmodsi4_loop>:
    7374:	aa 1f       	adc	r26, r26
    7376:	bb 1f       	adc	r27, r27
    7378:	ee 1f       	adc	r30, r30
    737a:	ff 1f       	adc	r31, r31
    737c:	a2 17       	cp	r26, r18
    737e:	b3 07       	cpc	r27, r19
    7380:	e4 07       	cpc	r30, r20
    7382:	f5 07       	cpc	r31, r21
    7384:	20 f0       	brcs	.+8      	; 0x738e <__udivmodsi4_ep>
    7386:	a2 1b       	sub	r26, r18
    7388:	b3 0b       	sbc	r27, r19
    738a:	e4 0b       	sbc	r30, r20
    738c:	f5 0b       	sbc	r31, r21

0000738e <__udivmodsi4_ep>:
    738e:	66 1f       	adc	r22, r22
    7390:	77 1f       	adc	r23, r23
    7392:	88 1f       	adc	r24, r24
    7394:	99 1f       	adc	r25, r25
    7396:	1a 94       	dec	r1
    7398:	69 f7       	brne	.-38     	; 0x7374 <__udivmodsi4_loop>
    739a:	60 95       	com	r22
    739c:	70 95       	com	r23
    739e:	80 95       	com	r24
    73a0:	90 95       	com	r25
    73a2:	9b 01       	movw	r18, r22
    73a4:	ac 01       	movw	r20, r24
    73a6:	bd 01       	movw	r22, r26
    73a8:	cf 01       	movw	r24, r30
    73aa:	08 95       	ret

000073ac <__divmodsi4>:
    73ac:	97 fb       	bst	r25, 7
    73ae:	09 2e       	mov	r0, r25
    73b0:	05 26       	eor	r0, r21
    73b2:	0e d0       	rcall	.+28     	; 0x73d0 <__divmodsi4_neg1>
    73b4:	57 fd       	sbrc	r21, 7
    73b6:	04 d0       	rcall	.+8      	; 0x73c0 <__divmodsi4_neg2>
    73b8:	d7 df       	rcall	.-82     	; 0x7368 <__udivmodsi4>
    73ba:	0a d0       	rcall	.+20     	; 0x73d0 <__divmodsi4_neg1>
    73bc:	00 1c       	adc	r0, r0
    73be:	38 f4       	brcc	.+14     	; 0x73ce <__divmodsi4_exit>

000073c0 <__divmodsi4_neg2>:
    73c0:	50 95       	com	r21
    73c2:	40 95       	com	r20
    73c4:	30 95       	com	r19
    73c6:	21 95       	neg	r18
    73c8:	3f 4f       	sbci	r19, 0xFF	; 255
    73ca:	4f 4f       	sbci	r20, 0xFF	; 255
    73cc:	5f 4f       	sbci	r21, 0xFF	; 255

000073ce <__divmodsi4_exit>:
    73ce:	08 95       	ret

000073d0 <__divmodsi4_neg1>:
    73d0:	f6 f7       	brtc	.-4      	; 0x73ce <__divmodsi4_exit>
    73d2:	90 95       	com	r25
    73d4:	80 95       	com	r24
    73d6:	70 95       	com	r23
    73d8:	61 95       	neg	r22
    73da:	7f 4f       	sbci	r23, 0xFF	; 255
    73dc:	8f 4f       	sbci	r24, 0xFF	; 255
    73de:	9f 4f       	sbci	r25, 0xFF	; 255
    73e0:	08 95       	ret

000073e2 <__udivmodhi4>:
    73e2:	aa 1b       	sub	r26, r26
    73e4:	bb 1b       	sub	r27, r27
    73e6:	51 e1       	ldi	r21, 0x11	; 17
    73e8:	07 c0       	rjmp	.+14     	; 0x73f8 <__udivmodhi4_ep>

000073ea <__udivmodhi4_loop>:
    73ea:	aa 1f       	adc	r26, r26
    73ec:	bb 1f       	adc	r27, r27
    73ee:	a6 17       	cp	r26, r22
    73f0:	b7 07       	cpc	r27, r23
    73f2:	10 f0       	brcs	.+4      	; 0x73f8 <__udivmodhi4_ep>
    73f4:	a6 1b       	sub	r26, r22
    73f6:	b7 0b       	sbc	r27, r23

000073f8 <__udivmodhi4_ep>:
    73f8:	88 1f       	adc	r24, r24
    73fa:	99 1f       	adc	r25, r25
    73fc:	5a 95       	dec	r21
    73fe:	a9 f7       	brne	.-22     	; 0x73ea <__udivmodhi4_loop>
    7400:	80 95       	com	r24
    7402:	90 95       	com	r25
    7404:	bc 01       	movw	r22, r24
    7406:	cd 01       	movw	r24, r26
    7408:	08 95       	ret

0000740a <__prologue_saves__>:
    740a:	2f 92       	push	r2
    740c:	3f 92       	push	r3
    740e:	4f 92       	push	r4
    7410:	5f 92       	push	r5
    7412:	6f 92       	push	r6
    7414:	7f 92       	push	r7
    7416:	8f 92       	push	r8
    7418:	9f 92       	push	r9
    741a:	af 92       	push	r10
    741c:	bf 92       	push	r11
    741e:	cf 92       	push	r12
    7420:	df 92       	push	r13
    7422:	ef 92       	push	r14
    7424:	ff 92       	push	r15
    7426:	0f 93       	push	r16
    7428:	1f 93       	push	r17
    742a:	cf 93       	push	r28
    742c:	df 93       	push	r29
    742e:	cd b7       	in	r28, 0x3d	; 61
    7430:	de b7       	in	r29, 0x3e	; 62
    7432:	ca 1b       	sub	r28, r26
    7434:	db 0b       	sbc	r29, r27
    7436:	cd bf       	out	0x3d, r28	; 61
    7438:	de bf       	out	0x3e, r29	; 62
    743a:	19 94       	eijmp

0000743c <__epilogue_restores__>:
    743c:	2a 88       	ldd	r2, Y+18	; 0x12
    743e:	39 88       	ldd	r3, Y+17	; 0x11
    7440:	48 88       	ldd	r4, Y+16	; 0x10
    7442:	5f 84       	ldd	r5, Y+15	; 0x0f
    7444:	6e 84       	ldd	r6, Y+14	; 0x0e
    7446:	7d 84       	ldd	r7, Y+13	; 0x0d
    7448:	8c 84       	ldd	r8, Y+12	; 0x0c
    744a:	9b 84       	ldd	r9, Y+11	; 0x0b
    744c:	aa 84       	ldd	r10, Y+10	; 0x0a
    744e:	b9 84       	ldd	r11, Y+9	; 0x09
    7450:	c8 84       	ldd	r12, Y+8	; 0x08
    7452:	df 80       	ldd	r13, Y+7	; 0x07
    7454:	ee 80       	ldd	r14, Y+6	; 0x06
    7456:	fd 80       	ldd	r15, Y+5	; 0x05
    7458:	0c 81       	ldd	r16, Y+4	; 0x04
    745a:	1b 81       	ldd	r17, Y+3	; 0x03
    745c:	aa 81       	ldd	r26, Y+2	; 0x02
    745e:	b9 81       	ldd	r27, Y+1	; 0x01
    7460:	ce 0f       	add	r28, r30
    7462:	d1 1d       	adc	r29, r1
    7464:	cd bf       	out	0x3d, r28	; 61
    7466:	de bf       	out	0x3e, r29	; 62
    7468:	ed 01       	movw	r28, r26
    746a:	08 95       	ret

0000746c <strcpy_P>:
    746c:	fb 01       	movw	r30, r22
    746e:	dc 01       	movw	r26, r24
    7470:	05 90       	lpm	r0, Z+
    7472:	0d 92       	st	X+, r0
    7474:	00 20       	and	r0, r0
    7476:	e1 f7       	brne	.-8      	; 0x7470 <strcpy_P+0x4>
    7478:	08 95       	ret

0000747a <memmove>:
    747a:	68 17       	cp	r22, r24
    747c:	79 07       	cpc	r23, r25
    747e:	68 f4       	brcc	.+26     	; 0x749a <memmove+0x20>
    7480:	fb 01       	movw	r30, r22
    7482:	dc 01       	movw	r26, r24
    7484:	e4 0f       	add	r30, r20
    7486:	f5 1f       	adc	r31, r21
    7488:	a4 0f       	add	r26, r20
    748a:	b5 1f       	adc	r27, r21
    748c:	02 c0       	rjmp	.+4      	; 0x7492 <memmove+0x18>
    748e:	02 90       	ld	r0, -Z
    7490:	0e 92       	st	-X, r0
    7492:	41 50       	subi	r20, 0x01	; 1
    7494:	50 40       	sbci	r21, 0x00	; 0
    7496:	d8 f7       	brcc	.-10     	; 0x748e <memmove+0x14>
    7498:	08 95       	ret
    749a:	0c 94 c2 3c 	jmp	0x7984	; 0x7984 <memcpy>

0000749e <strcat>:
    749e:	fb 01       	movw	r30, r22
    74a0:	dc 01       	movw	r26, r24
    74a2:	0d 90       	ld	r0, X+
    74a4:	00 20       	and	r0, r0
    74a6:	e9 f7       	brne	.-6      	; 0x74a2 <strcat+0x4>
    74a8:	11 97       	sbiw	r26, 0x01	; 1
    74aa:	01 90       	ld	r0, Z+
    74ac:	0d 92       	st	X+, r0
    74ae:	00 20       	and	r0, r0
    74b0:	e1 f7       	brne	.-8      	; 0x74aa <strcat+0xc>
    74b2:	08 95       	ret

000074b4 <itoa>:
    74b4:	fb 01       	movw	r30, r22
    74b6:	9f 01       	movw	r18, r30
    74b8:	e8 94       	clt
    74ba:	42 30       	cpi	r20, 0x02	; 2
    74bc:	c4 f0       	brlt	.+48     	; 0x74ee <itoa+0x3a>
    74be:	45 32       	cpi	r20, 0x25	; 37
    74c0:	b4 f4       	brge	.+44     	; 0x74ee <itoa+0x3a>
    74c2:	4a 30       	cpi	r20, 0x0A	; 10
    74c4:	29 f4       	brne	.+10     	; 0x74d0 <itoa+0x1c>
    74c6:	97 fb       	bst	r25, 7
    74c8:	1e f4       	brtc	.+6      	; 0x74d0 <itoa+0x1c>
    74ca:	90 95       	com	r25
    74cc:	81 95       	neg	r24
    74ce:	9f 4f       	sbci	r25, 0xFF	; 255
    74d0:	64 2f       	mov	r22, r20
    74d2:	77 27       	eor	r23, r23
    74d4:	0e 94 f1 39 	call	0x73e2	; 0x73e2 <__udivmodhi4>
    74d8:	80 5d       	subi	r24, 0xD0	; 208
    74da:	8a 33       	cpi	r24, 0x3A	; 58
    74dc:	0c f0       	brlt	.+2      	; 0x74e0 <itoa+0x2c>
    74de:	89 5d       	subi	r24, 0xD9	; 217
    74e0:	81 93       	st	Z+, r24
    74e2:	cb 01       	movw	r24, r22
    74e4:	00 97       	sbiw	r24, 0x00	; 0
    74e6:	a1 f7       	brne	.-24     	; 0x74d0 <itoa+0x1c>
    74e8:	16 f4       	brtc	.+4      	; 0x74ee <itoa+0x3a>
    74ea:	5d e2       	ldi	r21, 0x2D	; 45
    74ec:	51 93       	st	Z+, r21
    74ee:	10 82       	st	Z, r1
    74f0:	c9 01       	movw	r24, r18
    74f2:	0c 94 d6 3c 	jmp	0x79ac	; 0x79ac <strrev>

000074f6 <printf>:
    74f6:	cf 93       	push	r28
    74f8:	df 93       	push	r29
    74fa:	cd b7       	in	r28, 0x3d	; 61
    74fc:	de b7       	in	r29, 0x3e	; 62
    74fe:	fe 01       	movw	r30, r28
    7500:	36 96       	adiw	r30, 0x06	; 6
    7502:	61 91       	ld	r22, Z+
    7504:	71 91       	ld	r23, Z+
    7506:	80 91 b8 50 	lds	r24, 0x50B8
    750a:	90 91 b9 50 	lds	r25, 0x50B9
    750e:	af 01       	movw	r20, r30
    7510:	0e 94 b6 3a 	call	0x756c	; 0x756c <vfprintf>
    7514:	df 91       	pop	r29
    7516:	cf 91       	pop	r28
    7518:	08 95       	ret

0000751a <sprintf>:
    751a:	0f 93       	push	r16
    751c:	1f 93       	push	r17
    751e:	cf 93       	push	r28
    7520:	df 93       	push	r29
    7522:	cd b7       	in	r28, 0x3d	; 61
    7524:	de b7       	in	r29, 0x3e	; 62
    7526:	2e 97       	sbiw	r28, 0x0e	; 14
    7528:	cd bf       	out	0x3d, r28	; 61
    752a:	de bf       	out	0x3e, r29	; 62
    752c:	0e 89       	ldd	r16, Y+22	; 0x16
    752e:	1f 89       	ldd	r17, Y+23	; 0x17
    7530:	86 e0       	ldi	r24, 0x06	; 6
    7532:	8c 83       	std	Y+4, r24	; 0x04
    7534:	09 83       	std	Y+1, r16	; 0x01
    7536:	1a 83       	std	Y+2, r17	; 0x02
    7538:	8f ef       	ldi	r24, 0xFF	; 255
    753a:	9f e7       	ldi	r25, 0x7F	; 127
    753c:	8d 83       	std	Y+5, r24	; 0x05
    753e:	9e 83       	std	Y+6, r25	; 0x06
    7540:	ae 01       	movw	r20, r28
    7542:	46 5e       	subi	r20, 0xE6	; 230
    7544:	5f 4f       	sbci	r21, 0xFF	; 255
    7546:	ce 01       	movw	r24, r28
    7548:	01 96       	adiw	r24, 0x01	; 1
    754a:	68 8d       	ldd	r22, Y+24	; 0x18
    754c:	79 8d       	ldd	r23, Y+25	; 0x19
    754e:	0e 94 b6 3a 	call	0x756c	; 0x756c <vfprintf>
    7552:	ef 81       	ldd	r30, Y+7	; 0x07
    7554:	f8 85       	ldd	r31, Y+8	; 0x08
    7556:	e0 0f       	add	r30, r16
    7558:	f1 1f       	adc	r31, r17
    755a:	10 82       	st	Z, r1
    755c:	2e 96       	adiw	r28, 0x0e	; 14
    755e:	cd bf       	out	0x3d, r28	; 61
    7560:	de bf       	out	0x3e, r29	; 62
    7562:	df 91       	pop	r29
    7564:	cf 91       	pop	r28
    7566:	1f 91       	pop	r17
    7568:	0f 91       	pop	r16
    756a:	08 95       	ret

0000756c <vfprintf>:
    756c:	2f 92       	push	r2
    756e:	3f 92       	push	r3
    7570:	4f 92       	push	r4
    7572:	5f 92       	push	r5
    7574:	6f 92       	push	r6
    7576:	7f 92       	push	r7
    7578:	8f 92       	push	r8
    757a:	9f 92       	push	r9
    757c:	af 92       	push	r10
    757e:	bf 92       	push	r11
    7580:	cf 92       	push	r12
    7582:	df 92       	push	r13
    7584:	ef 92       	push	r14
    7586:	ff 92       	push	r15
    7588:	0f 93       	push	r16
    758a:	1f 93       	push	r17
    758c:	cf 93       	push	r28
    758e:	df 93       	push	r29
    7590:	cd b7       	in	r28, 0x3d	; 61
    7592:	de b7       	in	r29, 0x3e	; 62
    7594:	2d 97       	sbiw	r28, 0x0d	; 13
    7596:	cd bf       	out	0x3d, r28	; 61
    7598:	de bf       	out	0x3e, r29	; 62
    759a:	3c 01       	movw	r6, r24
    759c:	6c 87       	std	Y+12, r22	; 0x0c
    759e:	7d 87       	std	Y+13, r23	; 0x0d
    75a0:	5a 01       	movw	r10, r20
    75a2:	fc 01       	movw	r30, r24
    75a4:	16 82       	std	Z+6, r1	; 0x06
    75a6:	17 82       	std	Z+7, r1	; 0x07
    75a8:	83 81       	ldd	r24, Z+3	; 0x03
    75aa:	81 ff       	sbrs	r24, 1
    75ac:	c8 c1       	rjmp	.+912    	; 0x793e <vfprintf+0x3d2>
    75ae:	2e 01       	movw	r4, r28
    75b0:	08 94       	sec
    75b2:	41 1c       	adc	r4, r1
    75b4:	51 1c       	adc	r5, r1
    75b6:	f3 01       	movw	r30, r6
    75b8:	93 81       	ldd	r25, Z+3	; 0x03
    75ba:	ec 85       	ldd	r30, Y+12	; 0x0c
    75bc:	fd 85       	ldd	r31, Y+13	; 0x0d
    75be:	93 fd       	sbrc	r25, 3
    75c0:	85 91       	lpm	r24, Z+
    75c2:	93 ff       	sbrs	r25, 3
    75c4:	81 91       	ld	r24, Z+
    75c6:	ec 87       	std	Y+12, r30	; 0x0c
    75c8:	fd 87       	std	Y+13, r31	; 0x0d
    75ca:	88 23       	and	r24, r24
    75cc:	09 f4       	brne	.+2      	; 0x75d0 <vfprintf+0x64>
    75ce:	b3 c1       	rjmp	.+870    	; 0x7936 <vfprintf+0x3ca>
    75d0:	85 32       	cpi	r24, 0x25	; 37
    75d2:	41 f4       	brne	.+16     	; 0x75e4 <vfprintf+0x78>
    75d4:	93 fd       	sbrc	r25, 3
    75d6:	85 91       	lpm	r24, Z+
    75d8:	93 ff       	sbrs	r25, 3
    75da:	81 91       	ld	r24, Z+
    75dc:	ec 87       	std	Y+12, r30	; 0x0c
    75de:	fd 87       	std	Y+13, r31	; 0x0d
    75e0:	85 32       	cpi	r24, 0x25	; 37
    75e2:	29 f4       	brne	.+10     	; 0x75ee <vfprintf+0x82>
    75e4:	90 e0       	ldi	r25, 0x00	; 0
    75e6:	b3 01       	movw	r22, r6
    75e8:	0e 94 e6 3c 	call	0x79cc	; 0x79cc <fputc>
    75ec:	e4 cf       	rjmp	.-56     	; 0x75b6 <vfprintf+0x4a>
    75ee:	ff 24       	eor	r15, r15
    75f0:	ee 24       	eor	r14, r14
    75f2:	10 e0       	ldi	r17, 0x00	; 0
    75f4:	10 32       	cpi	r17, 0x20	; 32
    75f6:	b0 f4       	brcc	.+44     	; 0x7624 <vfprintf+0xb8>
    75f8:	8b 32       	cpi	r24, 0x2B	; 43
    75fa:	69 f0       	breq	.+26     	; 0x7616 <vfprintf+0xaa>
    75fc:	8c 32       	cpi	r24, 0x2C	; 44
    75fe:	28 f4       	brcc	.+10     	; 0x760a <vfprintf+0x9e>
    7600:	80 32       	cpi	r24, 0x20	; 32
    7602:	51 f0       	breq	.+20     	; 0x7618 <vfprintf+0xac>
    7604:	83 32       	cpi	r24, 0x23	; 35
    7606:	71 f4       	brne	.+28     	; 0x7624 <vfprintf+0xb8>
    7608:	0b c0       	rjmp	.+22     	; 0x7620 <vfprintf+0xb4>
    760a:	8d 32       	cpi	r24, 0x2D	; 45
    760c:	39 f0       	breq	.+14     	; 0x761c <vfprintf+0xb0>
    760e:	80 33       	cpi	r24, 0x30	; 48
    7610:	49 f4       	brne	.+18     	; 0x7624 <vfprintf+0xb8>
    7612:	11 60       	ori	r17, 0x01	; 1
    7614:	2c c0       	rjmp	.+88     	; 0x766e <vfprintf+0x102>
    7616:	12 60       	ori	r17, 0x02	; 2
    7618:	14 60       	ori	r17, 0x04	; 4
    761a:	29 c0       	rjmp	.+82     	; 0x766e <vfprintf+0x102>
    761c:	18 60       	ori	r17, 0x08	; 8
    761e:	27 c0       	rjmp	.+78     	; 0x766e <vfprintf+0x102>
    7620:	10 61       	ori	r17, 0x10	; 16
    7622:	25 c0       	rjmp	.+74     	; 0x766e <vfprintf+0x102>
    7624:	17 fd       	sbrc	r17, 7
    7626:	2e c0       	rjmp	.+92     	; 0x7684 <vfprintf+0x118>
    7628:	28 2f       	mov	r18, r24
    762a:	20 53       	subi	r18, 0x30	; 48
    762c:	2a 30       	cpi	r18, 0x0A	; 10
    762e:	98 f4       	brcc	.+38     	; 0x7656 <vfprintf+0xea>
    7630:	16 ff       	sbrs	r17, 6
    7632:	08 c0       	rjmp	.+16     	; 0x7644 <vfprintf+0xd8>
    7634:	8f 2d       	mov	r24, r15
    7636:	88 0f       	add	r24, r24
    7638:	f8 2e       	mov	r15, r24
    763a:	ff 0c       	add	r15, r15
    763c:	ff 0c       	add	r15, r15
    763e:	f8 0e       	add	r15, r24
    7640:	f2 0e       	add	r15, r18
    7642:	15 c0       	rjmp	.+42     	; 0x766e <vfprintf+0x102>
    7644:	8e 2d       	mov	r24, r14
    7646:	88 0f       	add	r24, r24
    7648:	e8 2e       	mov	r14, r24
    764a:	ee 0c       	add	r14, r14
    764c:	ee 0c       	add	r14, r14
    764e:	e8 0e       	add	r14, r24
    7650:	e2 0e       	add	r14, r18
    7652:	10 62       	ori	r17, 0x20	; 32
    7654:	0c c0       	rjmp	.+24     	; 0x766e <vfprintf+0x102>
    7656:	8e 32       	cpi	r24, 0x2E	; 46
    7658:	21 f4       	brne	.+8      	; 0x7662 <vfprintf+0xf6>
    765a:	16 fd       	sbrc	r17, 6
    765c:	6c c1       	rjmp	.+728    	; 0x7936 <vfprintf+0x3ca>
    765e:	10 64       	ori	r17, 0x40	; 64
    7660:	06 c0       	rjmp	.+12     	; 0x766e <vfprintf+0x102>
    7662:	8c 36       	cpi	r24, 0x6C	; 108
    7664:	11 f4       	brne	.+4      	; 0x766a <vfprintf+0xfe>
    7666:	10 68       	ori	r17, 0x80	; 128
    7668:	02 c0       	rjmp	.+4      	; 0x766e <vfprintf+0x102>
    766a:	88 36       	cpi	r24, 0x68	; 104
    766c:	59 f4       	brne	.+22     	; 0x7684 <vfprintf+0x118>
    766e:	ec 85       	ldd	r30, Y+12	; 0x0c
    7670:	fd 85       	ldd	r31, Y+13	; 0x0d
    7672:	93 fd       	sbrc	r25, 3
    7674:	85 91       	lpm	r24, Z+
    7676:	93 ff       	sbrs	r25, 3
    7678:	81 91       	ld	r24, Z+
    767a:	ec 87       	std	Y+12, r30	; 0x0c
    767c:	fd 87       	std	Y+13, r31	; 0x0d
    767e:	88 23       	and	r24, r24
    7680:	09 f0       	breq	.+2      	; 0x7684 <vfprintf+0x118>
    7682:	b8 cf       	rjmp	.-144    	; 0x75f4 <vfprintf+0x88>
    7684:	98 2f       	mov	r25, r24
    7686:	95 54       	subi	r25, 0x45	; 69
    7688:	93 30       	cpi	r25, 0x03	; 3
    768a:	18 f0       	brcs	.+6      	; 0x7692 <vfprintf+0x126>
    768c:	90 52       	subi	r25, 0x20	; 32
    768e:	93 30       	cpi	r25, 0x03	; 3
    7690:	38 f4       	brcc	.+14     	; 0x76a0 <vfprintf+0x134>
    7692:	24 e0       	ldi	r18, 0x04	; 4
    7694:	30 e0       	ldi	r19, 0x00	; 0
    7696:	a2 0e       	add	r10, r18
    7698:	b3 1e       	adc	r11, r19
    769a:	3f e3       	ldi	r19, 0x3F	; 63
    769c:	39 83       	std	Y+1, r19	; 0x01
    769e:	0f c0       	rjmp	.+30     	; 0x76be <vfprintf+0x152>
    76a0:	83 36       	cpi	r24, 0x63	; 99
    76a2:	31 f0       	breq	.+12     	; 0x76b0 <vfprintf+0x144>
    76a4:	83 37       	cpi	r24, 0x73	; 115
    76a6:	81 f0       	breq	.+32     	; 0x76c8 <vfprintf+0x15c>
    76a8:	83 35       	cpi	r24, 0x53	; 83
    76aa:	09 f0       	breq	.+2      	; 0x76ae <vfprintf+0x142>
    76ac:	5a c0       	rjmp	.+180    	; 0x7762 <vfprintf+0x1f6>
    76ae:	22 c0       	rjmp	.+68     	; 0x76f4 <vfprintf+0x188>
    76b0:	f5 01       	movw	r30, r10
    76b2:	80 81       	ld	r24, Z
    76b4:	89 83       	std	Y+1, r24	; 0x01
    76b6:	22 e0       	ldi	r18, 0x02	; 2
    76b8:	30 e0       	ldi	r19, 0x00	; 0
    76ba:	a2 0e       	add	r10, r18
    76bc:	b3 1e       	adc	r11, r19
    76be:	21 e0       	ldi	r18, 0x01	; 1
    76c0:	c2 2e       	mov	r12, r18
    76c2:	d1 2c       	mov	r13, r1
    76c4:	42 01       	movw	r8, r4
    76c6:	14 c0       	rjmp	.+40     	; 0x76f0 <vfprintf+0x184>
    76c8:	92 e0       	ldi	r25, 0x02	; 2
    76ca:	29 2e       	mov	r2, r25
    76cc:	31 2c       	mov	r3, r1
    76ce:	2a 0c       	add	r2, r10
    76d0:	3b 1c       	adc	r3, r11
    76d2:	f5 01       	movw	r30, r10
    76d4:	80 80       	ld	r8, Z
    76d6:	91 80       	ldd	r9, Z+1	; 0x01
    76d8:	16 ff       	sbrs	r17, 6
    76da:	03 c0       	rjmp	.+6      	; 0x76e2 <vfprintf+0x176>
    76dc:	6f 2d       	mov	r22, r15
    76de:	70 e0       	ldi	r23, 0x00	; 0
    76e0:	02 c0       	rjmp	.+4      	; 0x76e6 <vfprintf+0x17a>
    76e2:	6f ef       	ldi	r22, 0xFF	; 255
    76e4:	7f ef       	ldi	r23, 0xFF	; 255
    76e6:	c4 01       	movw	r24, r8
    76e8:	0e 94 cb 3c 	call	0x7996	; 0x7996 <strnlen>
    76ec:	6c 01       	movw	r12, r24
    76ee:	51 01       	movw	r10, r2
    76f0:	1f 77       	andi	r17, 0x7F	; 127
    76f2:	15 c0       	rjmp	.+42     	; 0x771e <vfprintf+0x1b2>
    76f4:	82 e0       	ldi	r24, 0x02	; 2
    76f6:	28 2e       	mov	r2, r24
    76f8:	31 2c       	mov	r3, r1
    76fa:	2a 0c       	add	r2, r10
    76fc:	3b 1c       	adc	r3, r11
    76fe:	f5 01       	movw	r30, r10
    7700:	80 80       	ld	r8, Z
    7702:	91 80       	ldd	r9, Z+1	; 0x01
    7704:	16 ff       	sbrs	r17, 6
    7706:	03 c0       	rjmp	.+6      	; 0x770e <vfprintf+0x1a2>
    7708:	6f 2d       	mov	r22, r15
    770a:	70 e0       	ldi	r23, 0x00	; 0
    770c:	02 c0       	rjmp	.+4      	; 0x7712 <vfprintf+0x1a6>
    770e:	6f ef       	ldi	r22, 0xFF	; 255
    7710:	7f ef       	ldi	r23, 0xFF	; 255
    7712:	c4 01       	movw	r24, r8
    7714:	0e 94 b7 3c 	call	0x796e	; 0x796e <strnlen_P>
    7718:	6c 01       	movw	r12, r24
    771a:	10 68       	ori	r17, 0x80	; 128
    771c:	51 01       	movw	r10, r2
    771e:	13 fd       	sbrc	r17, 3
    7720:	1c c0       	rjmp	.+56     	; 0x775a <vfprintf+0x1ee>
    7722:	06 c0       	rjmp	.+12     	; 0x7730 <vfprintf+0x1c4>
    7724:	80 e2       	ldi	r24, 0x20	; 32
    7726:	90 e0       	ldi	r25, 0x00	; 0
    7728:	b3 01       	movw	r22, r6
    772a:	0e 94 e6 3c 	call	0x79cc	; 0x79cc <fputc>
    772e:	ea 94       	dec	r14
    7730:	8e 2d       	mov	r24, r14
    7732:	90 e0       	ldi	r25, 0x00	; 0
    7734:	c8 16       	cp	r12, r24
    7736:	d9 06       	cpc	r13, r25
    7738:	a8 f3       	brcs	.-22     	; 0x7724 <vfprintf+0x1b8>
    773a:	0f c0       	rjmp	.+30     	; 0x775a <vfprintf+0x1ee>
    773c:	f4 01       	movw	r30, r8
    773e:	17 fd       	sbrc	r17, 7
    7740:	85 91       	lpm	r24, Z+
    7742:	17 ff       	sbrs	r17, 7
    7744:	81 91       	ld	r24, Z+
    7746:	4f 01       	movw	r8, r30
    7748:	90 e0       	ldi	r25, 0x00	; 0
    774a:	b3 01       	movw	r22, r6
    774c:	0e 94 e6 3c 	call	0x79cc	; 0x79cc <fputc>
    7750:	e1 10       	cpse	r14, r1
    7752:	ea 94       	dec	r14
    7754:	08 94       	sec
    7756:	c1 08       	sbc	r12, r1
    7758:	d1 08       	sbc	r13, r1
    775a:	c1 14       	cp	r12, r1
    775c:	d1 04       	cpc	r13, r1
    775e:	71 f7       	brne	.-36     	; 0x773c <vfprintf+0x1d0>
    7760:	e7 c0       	rjmp	.+462    	; 0x7930 <vfprintf+0x3c4>
    7762:	84 36       	cpi	r24, 0x64	; 100
    7764:	11 f0       	breq	.+4      	; 0x776a <vfprintf+0x1fe>
    7766:	89 36       	cpi	r24, 0x69	; 105
    7768:	51 f5       	brne	.+84     	; 0x77be <vfprintf+0x252>
    776a:	f5 01       	movw	r30, r10
    776c:	17 ff       	sbrs	r17, 7
    776e:	07 c0       	rjmp	.+14     	; 0x777e <vfprintf+0x212>
    7770:	80 81       	ld	r24, Z
    7772:	91 81       	ldd	r25, Z+1	; 0x01
    7774:	a2 81       	ldd	r26, Z+2	; 0x02
    7776:	b3 81       	ldd	r27, Z+3	; 0x03
    7778:	24 e0       	ldi	r18, 0x04	; 4
    777a:	30 e0       	ldi	r19, 0x00	; 0
    777c:	08 c0       	rjmp	.+16     	; 0x778e <vfprintf+0x222>
    777e:	80 81       	ld	r24, Z
    7780:	91 81       	ldd	r25, Z+1	; 0x01
    7782:	aa 27       	eor	r26, r26
    7784:	97 fd       	sbrc	r25, 7
    7786:	a0 95       	com	r26
    7788:	ba 2f       	mov	r27, r26
    778a:	22 e0       	ldi	r18, 0x02	; 2
    778c:	30 e0       	ldi	r19, 0x00	; 0
    778e:	a2 0e       	add	r10, r18
    7790:	b3 1e       	adc	r11, r19
    7792:	01 2f       	mov	r16, r17
    7794:	0f 76       	andi	r16, 0x6F	; 111
    7796:	b7 ff       	sbrs	r27, 7
    7798:	08 c0       	rjmp	.+16     	; 0x77aa <vfprintf+0x23e>
    779a:	b0 95       	com	r27
    779c:	a0 95       	com	r26
    779e:	90 95       	com	r25
    77a0:	81 95       	neg	r24
    77a2:	9f 4f       	sbci	r25, 0xFF	; 255
    77a4:	af 4f       	sbci	r26, 0xFF	; 255
    77a6:	bf 4f       	sbci	r27, 0xFF	; 255
    77a8:	00 68       	ori	r16, 0x80	; 128
    77aa:	bc 01       	movw	r22, r24
    77ac:	cd 01       	movw	r24, r26
    77ae:	a2 01       	movw	r20, r4
    77b0:	2a e0       	ldi	r18, 0x0A	; 10
    77b2:	30 e0       	ldi	r19, 0x00	; 0
    77b4:	0e 94 12 3d 	call	0x7a24	; 0x7a24 <__ultoa_invert>
    77b8:	d8 2e       	mov	r13, r24
    77ba:	d4 18       	sub	r13, r4
    77bc:	3f c0       	rjmp	.+126    	; 0x783c <vfprintf+0x2d0>
    77be:	85 37       	cpi	r24, 0x75	; 117
    77c0:	21 f4       	brne	.+8      	; 0x77ca <vfprintf+0x25e>
    77c2:	1f 7e       	andi	r17, 0xEF	; 239
    77c4:	2a e0       	ldi	r18, 0x0A	; 10
    77c6:	30 e0       	ldi	r19, 0x00	; 0
    77c8:	20 c0       	rjmp	.+64     	; 0x780a <vfprintf+0x29e>
    77ca:	19 7f       	andi	r17, 0xF9	; 249
    77cc:	8f 36       	cpi	r24, 0x6F	; 111
    77ce:	a9 f0       	breq	.+42     	; 0x77fa <vfprintf+0x28e>
    77d0:	80 37       	cpi	r24, 0x70	; 112
    77d2:	20 f4       	brcc	.+8      	; 0x77dc <vfprintf+0x270>
    77d4:	88 35       	cpi	r24, 0x58	; 88
    77d6:	09 f0       	breq	.+2      	; 0x77da <vfprintf+0x26e>
    77d8:	ae c0       	rjmp	.+348    	; 0x7936 <vfprintf+0x3ca>
    77da:	0b c0       	rjmp	.+22     	; 0x77f2 <vfprintf+0x286>
    77dc:	80 37       	cpi	r24, 0x70	; 112
    77de:	21 f0       	breq	.+8      	; 0x77e8 <vfprintf+0x27c>
    77e0:	88 37       	cpi	r24, 0x78	; 120
    77e2:	09 f0       	breq	.+2      	; 0x77e6 <vfprintf+0x27a>
    77e4:	a8 c0       	rjmp	.+336    	; 0x7936 <vfprintf+0x3ca>
    77e6:	01 c0       	rjmp	.+2      	; 0x77ea <vfprintf+0x27e>
    77e8:	10 61       	ori	r17, 0x10	; 16
    77ea:	14 ff       	sbrs	r17, 4
    77ec:	09 c0       	rjmp	.+18     	; 0x7800 <vfprintf+0x294>
    77ee:	14 60       	ori	r17, 0x04	; 4
    77f0:	07 c0       	rjmp	.+14     	; 0x7800 <vfprintf+0x294>
    77f2:	14 ff       	sbrs	r17, 4
    77f4:	08 c0       	rjmp	.+16     	; 0x7806 <vfprintf+0x29a>
    77f6:	16 60       	ori	r17, 0x06	; 6
    77f8:	06 c0       	rjmp	.+12     	; 0x7806 <vfprintf+0x29a>
    77fa:	28 e0       	ldi	r18, 0x08	; 8
    77fc:	30 e0       	ldi	r19, 0x00	; 0
    77fe:	05 c0       	rjmp	.+10     	; 0x780a <vfprintf+0x29e>
    7800:	20 e1       	ldi	r18, 0x10	; 16
    7802:	30 e0       	ldi	r19, 0x00	; 0
    7804:	02 c0       	rjmp	.+4      	; 0x780a <vfprintf+0x29e>
    7806:	20 e1       	ldi	r18, 0x10	; 16
    7808:	32 e0       	ldi	r19, 0x02	; 2
    780a:	f5 01       	movw	r30, r10
    780c:	17 ff       	sbrs	r17, 7
    780e:	07 c0       	rjmp	.+14     	; 0x781e <vfprintf+0x2b2>
    7810:	60 81       	ld	r22, Z
    7812:	71 81       	ldd	r23, Z+1	; 0x01
    7814:	82 81       	ldd	r24, Z+2	; 0x02
    7816:	93 81       	ldd	r25, Z+3	; 0x03
    7818:	44 e0       	ldi	r20, 0x04	; 4
    781a:	50 e0       	ldi	r21, 0x00	; 0
    781c:	06 c0       	rjmp	.+12     	; 0x782a <vfprintf+0x2be>
    781e:	60 81       	ld	r22, Z
    7820:	71 81       	ldd	r23, Z+1	; 0x01
    7822:	80 e0       	ldi	r24, 0x00	; 0
    7824:	90 e0       	ldi	r25, 0x00	; 0
    7826:	42 e0       	ldi	r20, 0x02	; 2
    7828:	50 e0       	ldi	r21, 0x00	; 0
    782a:	a4 0e       	add	r10, r20
    782c:	b5 1e       	adc	r11, r21
    782e:	a2 01       	movw	r20, r4
    7830:	0e 94 12 3d 	call	0x7a24	; 0x7a24 <__ultoa_invert>
    7834:	d8 2e       	mov	r13, r24
    7836:	d4 18       	sub	r13, r4
    7838:	01 2f       	mov	r16, r17
    783a:	0f 77       	andi	r16, 0x7F	; 127
    783c:	06 ff       	sbrs	r16, 6
    783e:	09 c0       	rjmp	.+18     	; 0x7852 <vfprintf+0x2e6>
    7840:	0e 7f       	andi	r16, 0xFE	; 254
    7842:	df 14       	cp	r13, r15
    7844:	30 f4       	brcc	.+12     	; 0x7852 <vfprintf+0x2e6>
    7846:	04 ff       	sbrs	r16, 4
    7848:	06 c0       	rjmp	.+12     	; 0x7856 <vfprintf+0x2ea>
    784a:	02 fd       	sbrc	r16, 2
    784c:	04 c0       	rjmp	.+8      	; 0x7856 <vfprintf+0x2ea>
    784e:	0f 7e       	andi	r16, 0xEF	; 239
    7850:	02 c0       	rjmp	.+4      	; 0x7856 <vfprintf+0x2ea>
    7852:	1d 2d       	mov	r17, r13
    7854:	01 c0       	rjmp	.+2      	; 0x7858 <vfprintf+0x2ec>
    7856:	1f 2d       	mov	r17, r15
    7858:	80 2f       	mov	r24, r16
    785a:	90 e0       	ldi	r25, 0x00	; 0
    785c:	04 ff       	sbrs	r16, 4
    785e:	0c c0       	rjmp	.+24     	; 0x7878 <vfprintf+0x30c>
    7860:	fe 01       	movw	r30, r28
    7862:	ed 0d       	add	r30, r13
    7864:	f1 1d       	adc	r31, r1
    7866:	20 81       	ld	r18, Z
    7868:	20 33       	cpi	r18, 0x30	; 48
    786a:	11 f4       	brne	.+4      	; 0x7870 <vfprintf+0x304>
    786c:	09 7e       	andi	r16, 0xE9	; 233
    786e:	09 c0       	rjmp	.+18     	; 0x7882 <vfprintf+0x316>
    7870:	02 ff       	sbrs	r16, 2
    7872:	06 c0       	rjmp	.+12     	; 0x7880 <vfprintf+0x314>
    7874:	1e 5f       	subi	r17, 0xFE	; 254
    7876:	05 c0       	rjmp	.+10     	; 0x7882 <vfprintf+0x316>
    7878:	86 78       	andi	r24, 0x86	; 134
    787a:	90 70       	andi	r25, 0x00	; 0
    787c:	00 97       	sbiw	r24, 0x00	; 0
    787e:	09 f0       	breq	.+2      	; 0x7882 <vfprintf+0x316>
    7880:	1f 5f       	subi	r17, 0xFF	; 255
    7882:	80 2e       	mov	r8, r16
    7884:	99 24       	eor	r9, r9
    7886:	03 fd       	sbrc	r16, 3
    7888:	12 c0       	rjmp	.+36     	; 0x78ae <vfprintf+0x342>
    788a:	00 ff       	sbrs	r16, 0
    788c:	0d c0       	rjmp	.+26     	; 0x78a8 <vfprintf+0x33c>
    788e:	fd 2c       	mov	r15, r13
    7890:	1e 15       	cp	r17, r14
    7892:	50 f4       	brcc	.+20     	; 0x78a8 <vfprintf+0x33c>
    7894:	fe 0c       	add	r15, r14
    7896:	f1 1a       	sub	r15, r17
    7898:	1e 2d       	mov	r17, r14
    789a:	06 c0       	rjmp	.+12     	; 0x78a8 <vfprintf+0x33c>
    789c:	80 e2       	ldi	r24, 0x20	; 32
    789e:	90 e0       	ldi	r25, 0x00	; 0
    78a0:	b3 01       	movw	r22, r6
    78a2:	0e 94 e6 3c 	call	0x79cc	; 0x79cc <fputc>
    78a6:	1f 5f       	subi	r17, 0xFF	; 255
    78a8:	1e 15       	cp	r17, r14
    78aa:	c0 f3       	brcs	.-16     	; 0x789c <vfprintf+0x330>
    78ac:	04 c0       	rjmp	.+8      	; 0x78b6 <vfprintf+0x34a>
    78ae:	1e 15       	cp	r17, r14
    78b0:	10 f4       	brcc	.+4      	; 0x78b6 <vfprintf+0x34a>
    78b2:	e1 1a       	sub	r14, r17
    78b4:	01 c0       	rjmp	.+2      	; 0x78b8 <vfprintf+0x34c>
    78b6:	ee 24       	eor	r14, r14
    78b8:	84 fe       	sbrs	r8, 4
    78ba:	0f c0       	rjmp	.+30     	; 0x78da <vfprintf+0x36e>
    78bc:	80 e3       	ldi	r24, 0x30	; 48
    78be:	90 e0       	ldi	r25, 0x00	; 0
    78c0:	b3 01       	movw	r22, r6
    78c2:	0e 94 e6 3c 	call	0x79cc	; 0x79cc <fputc>
    78c6:	82 fe       	sbrs	r8, 2
    78c8:	1f c0       	rjmp	.+62     	; 0x7908 <vfprintf+0x39c>
    78ca:	81 fe       	sbrs	r8, 1
    78cc:	03 c0       	rjmp	.+6      	; 0x78d4 <vfprintf+0x368>
    78ce:	88 e5       	ldi	r24, 0x58	; 88
    78d0:	90 e0       	ldi	r25, 0x00	; 0
    78d2:	10 c0       	rjmp	.+32     	; 0x78f4 <vfprintf+0x388>
    78d4:	88 e7       	ldi	r24, 0x78	; 120
    78d6:	90 e0       	ldi	r25, 0x00	; 0
    78d8:	0d c0       	rjmp	.+26     	; 0x78f4 <vfprintf+0x388>
    78da:	c4 01       	movw	r24, r8
    78dc:	86 78       	andi	r24, 0x86	; 134
    78de:	90 70       	andi	r25, 0x00	; 0
    78e0:	00 97       	sbiw	r24, 0x00	; 0
    78e2:	91 f0       	breq	.+36     	; 0x7908 <vfprintf+0x39c>
    78e4:	81 fc       	sbrc	r8, 1
    78e6:	02 c0       	rjmp	.+4      	; 0x78ec <vfprintf+0x380>
    78e8:	80 e2       	ldi	r24, 0x20	; 32
    78ea:	01 c0       	rjmp	.+2      	; 0x78ee <vfprintf+0x382>
    78ec:	8b e2       	ldi	r24, 0x2B	; 43
    78ee:	07 fd       	sbrc	r16, 7
    78f0:	8d e2       	ldi	r24, 0x2D	; 45
    78f2:	90 e0       	ldi	r25, 0x00	; 0
    78f4:	b3 01       	movw	r22, r6
    78f6:	0e 94 e6 3c 	call	0x79cc	; 0x79cc <fputc>
    78fa:	06 c0       	rjmp	.+12     	; 0x7908 <vfprintf+0x39c>
    78fc:	80 e3       	ldi	r24, 0x30	; 48
    78fe:	90 e0       	ldi	r25, 0x00	; 0
    7900:	b3 01       	movw	r22, r6
    7902:	0e 94 e6 3c 	call	0x79cc	; 0x79cc <fputc>
    7906:	fa 94       	dec	r15
    7908:	df 14       	cp	r13, r15
    790a:	c0 f3       	brcs	.-16     	; 0x78fc <vfprintf+0x390>
    790c:	da 94       	dec	r13
    790e:	f2 01       	movw	r30, r4
    7910:	ed 0d       	add	r30, r13
    7912:	f1 1d       	adc	r31, r1
    7914:	80 81       	ld	r24, Z
    7916:	90 e0       	ldi	r25, 0x00	; 0
    7918:	b3 01       	movw	r22, r6
    791a:	0e 94 e6 3c 	call	0x79cc	; 0x79cc <fputc>
    791e:	dd 20       	and	r13, r13
    7920:	a9 f7       	brne	.-22     	; 0x790c <vfprintf+0x3a0>
    7922:	06 c0       	rjmp	.+12     	; 0x7930 <vfprintf+0x3c4>
    7924:	80 e2       	ldi	r24, 0x20	; 32
    7926:	90 e0       	ldi	r25, 0x00	; 0
    7928:	b3 01       	movw	r22, r6
    792a:	0e 94 e6 3c 	call	0x79cc	; 0x79cc <fputc>
    792e:	ea 94       	dec	r14
    7930:	ee 20       	and	r14, r14
    7932:	c1 f7       	brne	.-16     	; 0x7924 <vfprintf+0x3b8>
    7934:	40 ce       	rjmp	.-896    	; 0x75b6 <vfprintf+0x4a>
    7936:	f3 01       	movw	r30, r6
    7938:	86 81       	ldd	r24, Z+6	; 0x06
    793a:	97 81       	ldd	r25, Z+7	; 0x07
    793c:	02 c0       	rjmp	.+4      	; 0x7942 <vfprintf+0x3d6>
    793e:	8f ef       	ldi	r24, 0xFF	; 255
    7940:	9f ef       	ldi	r25, 0xFF	; 255
    7942:	2d 96       	adiw	r28, 0x0d	; 13
    7944:	cd bf       	out	0x3d, r28	; 61
    7946:	de bf       	out	0x3e, r29	; 62
    7948:	df 91       	pop	r29
    794a:	cf 91       	pop	r28
    794c:	1f 91       	pop	r17
    794e:	0f 91       	pop	r16
    7950:	ff 90       	pop	r15
    7952:	ef 90       	pop	r14
    7954:	df 90       	pop	r13
    7956:	cf 90       	pop	r12
    7958:	bf 90       	pop	r11
    795a:	af 90       	pop	r10
    795c:	9f 90       	pop	r9
    795e:	8f 90       	pop	r8
    7960:	7f 90       	pop	r7
    7962:	6f 90       	pop	r6
    7964:	5f 90       	pop	r5
    7966:	4f 90       	pop	r4
    7968:	3f 90       	pop	r3
    796a:	2f 90       	pop	r2
    796c:	08 95       	ret

0000796e <strnlen_P>:
    796e:	fc 01       	movw	r30, r24
    7970:	05 90       	lpm	r0, Z+
    7972:	61 50       	subi	r22, 0x01	; 1
    7974:	70 40       	sbci	r23, 0x00	; 0
    7976:	01 10       	cpse	r0, r1
    7978:	d8 f7       	brcc	.-10     	; 0x7970 <strnlen_P+0x2>
    797a:	80 95       	com	r24
    797c:	90 95       	com	r25
    797e:	8e 0f       	add	r24, r30
    7980:	9f 1f       	adc	r25, r31
    7982:	08 95       	ret

00007984 <memcpy>:
    7984:	fb 01       	movw	r30, r22
    7986:	dc 01       	movw	r26, r24
    7988:	02 c0       	rjmp	.+4      	; 0x798e <memcpy+0xa>
    798a:	01 90       	ld	r0, Z+
    798c:	0d 92       	st	X+, r0
    798e:	41 50       	subi	r20, 0x01	; 1
    7990:	50 40       	sbci	r21, 0x00	; 0
    7992:	d8 f7       	brcc	.-10     	; 0x798a <memcpy+0x6>
    7994:	08 95       	ret

00007996 <strnlen>:
    7996:	fc 01       	movw	r30, r24
    7998:	61 50       	subi	r22, 0x01	; 1
    799a:	70 40       	sbci	r23, 0x00	; 0
    799c:	01 90       	ld	r0, Z+
    799e:	01 10       	cpse	r0, r1
    79a0:	d8 f7       	brcc	.-10     	; 0x7998 <strnlen+0x2>
    79a2:	80 95       	com	r24
    79a4:	90 95       	com	r25
    79a6:	8e 0f       	add	r24, r30
    79a8:	9f 1f       	adc	r25, r31
    79aa:	08 95       	ret

000079ac <strrev>:
    79ac:	dc 01       	movw	r26, r24
    79ae:	fc 01       	movw	r30, r24
    79b0:	67 2f       	mov	r22, r23
    79b2:	71 91       	ld	r23, Z+
    79b4:	77 23       	and	r23, r23
    79b6:	e1 f7       	brne	.-8      	; 0x79b0 <strrev+0x4>
    79b8:	32 97       	sbiw	r30, 0x02	; 2
    79ba:	04 c0       	rjmp	.+8      	; 0x79c4 <strrev+0x18>
    79bc:	7c 91       	ld	r23, X
    79be:	6d 93       	st	X+, r22
    79c0:	70 83       	st	Z, r23
    79c2:	62 91       	ld	r22, -Z
    79c4:	ae 17       	cp	r26, r30
    79c6:	bf 07       	cpc	r27, r31
    79c8:	c8 f3       	brcs	.-14     	; 0x79bc <strrev+0x10>
    79ca:	08 95       	ret

000079cc <fputc>:
    79cc:	0f 93       	push	r16
    79ce:	1f 93       	push	r17
    79d0:	cf 93       	push	r28
    79d2:	df 93       	push	r29
    79d4:	8c 01       	movw	r16, r24
    79d6:	eb 01       	movw	r28, r22
    79d8:	8b 81       	ldd	r24, Y+3	; 0x03
    79da:	81 ff       	sbrs	r24, 1
    79dc:	1b c0       	rjmp	.+54     	; 0x7a14 <fputc+0x48>
    79de:	82 ff       	sbrs	r24, 2
    79e0:	0d c0       	rjmp	.+26     	; 0x79fc <fputc+0x30>
    79e2:	2e 81       	ldd	r18, Y+6	; 0x06
    79e4:	3f 81       	ldd	r19, Y+7	; 0x07
    79e6:	8c 81       	ldd	r24, Y+4	; 0x04
    79e8:	9d 81       	ldd	r25, Y+5	; 0x05
    79ea:	28 17       	cp	r18, r24
    79ec:	39 07       	cpc	r19, r25
    79ee:	64 f4       	brge	.+24     	; 0x7a08 <fputc+0x3c>
    79f0:	e8 81       	ld	r30, Y
    79f2:	f9 81       	ldd	r31, Y+1	; 0x01
    79f4:	01 93       	st	Z+, r16
    79f6:	e8 83       	st	Y, r30
    79f8:	f9 83       	std	Y+1, r31	; 0x01
    79fa:	06 c0       	rjmp	.+12     	; 0x7a08 <fputc+0x3c>
    79fc:	e8 85       	ldd	r30, Y+8	; 0x08
    79fe:	f9 85       	ldd	r31, Y+9	; 0x09
    7a00:	80 2f       	mov	r24, r16
    7a02:	19 95       	eicall
    7a04:	00 97       	sbiw	r24, 0x00	; 0
    7a06:	31 f4       	brne	.+12     	; 0x7a14 <fputc+0x48>
    7a08:	8e 81       	ldd	r24, Y+6	; 0x06
    7a0a:	9f 81       	ldd	r25, Y+7	; 0x07
    7a0c:	01 96       	adiw	r24, 0x01	; 1
    7a0e:	8e 83       	std	Y+6, r24	; 0x06
    7a10:	9f 83       	std	Y+7, r25	; 0x07
    7a12:	02 c0       	rjmp	.+4      	; 0x7a18 <fputc+0x4c>
    7a14:	0f ef       	ldi	r16, 0xFF	; 255
    7a16:	1f ef       	ldi	r17, 0xFF	; 255
    7a18:	c8 01       	movw	r24, r16
    7a1a:	df 91       	pop	r29
    7a1c:	cf 91       	pop	r28
    7a1e:	1f 91       	pop	r17
    7a20:	0f 91       	pop	r16
    7a22:	08 95       	ret

00007a24 <__ultoa_invert>:
    7a24:	fa 01       	movw	r30, r20
    7a26:	aa 27       	eor	r26, r26
    7a28:	28 30       	cpi	r18, 0x08	; 8
    7a2a:	51 f1       	breq	.+84     	; 0x7a80 <__ultoa_invert+0x5c>
    7a2c:	20 31       	cpi	r18, 0x10	; 16
    7a2e:	81 f1       	breq	.+96     	; 0x7a90 <__ultoa_invert+0x6c>
    7a30:	e8 94       	clt
    7a32:	6f 93       	push	r22
    7a34:	6e 7f       	andi	r22, 0xFE	; 254
    7a36:	6e 5f       	subi	r22, 0xFE	; 254
    7a38:	7f 4f       	sbci	r23, 0xFF	; 255
    7a3a:	8f 4f       	sbci	r24, 0xFF	; 255
    7a3c:	9f 4f       	sbci	r25, 0xFF	; 255
    7a3e:	af 4f       	sbci	r26, 0xFF	; 255
    7a40:	b1 e0       	ldi	r27, 0x01	; 1
    7a42:	3e d0       	rcall	.+124    	; 0x7ac0 <__ultoa_invert+0x9c>
    7a44:	b4 e0       	ldi	r27, 0x04	; 4
    7a46:	3c d0       	rcall	.+120    	; 0x7ac0 <__ultoa_invert+0x9c>
    7a48:	67 0f       	add	r22, r23
    7a4a:	78 1f       	adc	r23, r24
    7a4c:	89 1f       	adc	r24, r25
    7a4e:	9a 1f       	adc	r25, r26
    7a50:	a1 1d       	adc	r26, r1
    7a52:	68 0f       	add	r22, r24
    7a54:	79 1f       	adc	r23, r25
    7a56:	8a 1f       	adc	r24, r26
    7a58:	91 1d       	adc	r25, r1
    7a5a:	a1 1d       	adc	r26, r1
    7a5c:	6a 0f       	add	r22, r26
    7a5e:	71 1d       	adc	r23, r1
    7a60:	81 1d       	adc	r24, r1
    7a62:	91 1d       	adc	r25, r1
    7a64:	a1 1d       	adc	r26, r1
    7a66:	20 d0       	rcall	.+64     	; 0x7aa8 <__ultoa_invert+0x84>
    7a68:	09 f4       	brne	.+2      	; 0x7a6c <__ultoa_invert+0x48>
    7a6a:	68 94       	set
    7a6c:	3f 91       	pop	r19
    7a6e:	2a e0       	ldi	r18, 0x0A	; 10
    7a70:	26 9f       	mul	r18, r22
    7a72:	11 24       	eor	r1, r1
    7a74:	30 19       	sub	r19, r0
    7a76:	30 5d       	subi	r19, 0xD0	; 208
    7a78:	31 93       	st	Z+, r19
    7a7a:	de f6       	brtc	.-74     	; 0x7a32 <__ultoa_invert+0xe>
    7a7c:	cf 01       	movw	r24, r30
    7a7e:	08 95       	ret
    7a80:	46 2f       	mov	r20, r22
    7a82:	47 70       	andi	r20, 0x07	; 7
    7a84:	40 5d       	subi	r20, 0xD0	; 208
    7a86:	41 93       	st	Z+, r20
    7a88:	b3 e0       	ldi	r27, 0x03	; 3
    7a8a:	0f d0       	rcall	.+30     	; 0x7aaa <__ultoa_invert+0x86>
    7a8c:	c9 f7       	brne	.-14     	; 0x7a80 <__ultoa_invert+0x5c>
    7a8e:	f6 cf       	rjmp	.-20     	; 0x7a7c <__ultoa_invert+0x58>
    7a90:	46 2f       	mov	r20, r22
    7a92:	4f 70       	andi	r20, 0x0F	; 15
    7a94:	40 5d       	subi	r20, 0xD0	; 208
    7a96:	4a 33       	cpi	r20, 0x3A	; 58
    7a98:	18 f0       	brcs	.+6      	; 0x7aa0 <__ultoa_invert+0x7c>
    7a9a:	49 5d       	subi	r20, 0xD9	; 217
    7a9c:	31 fd       	sbrc	r19, 1
    7a9e:	40 52       	subi	r20, 0x20	; 32
    7aa0:	41 93       	st	Z+, r20
    7aa2:	02 d0       	rcall	.+4      	; 0x7aa8 <__ultoa_invert+0x84>
    7aa4:	a9 f7       	brne	.-22     	; 0x7a90 <__ultoa_invert+0x6c>
    7aa6:	ea cf       	rjmp	.-44     	; 0x7a7c <__ultoa_invert+0x58>
    7aa8:	b4 e0       	ldi	r27, 0x04	; 4
    7aaa:	a6 95       	lsr	r26
    7aac:	97 95       	ror	r25
    7aae:	87 95       	ror	r24
    7ab0:	77 95       	ror	r23
    7ab2:	67 95       	ror	r22
    7ab4:	ba 95       	dec	r27
    7ab6:	c9 f7       	brne	.-14     	; 0x7aaa <__ultoa_invert+0x86>
    7ab8:	00 97       	sbiw	r24, 0x00	; 0
    7aba:	61 05       	cpc	r22, r1
    7abc:	71 05       	cpc	r23, r1
    7abe:	08 95       	ret
    7ac0:	9b 01       	movw	r18, r22
    7ac2:	ac 01       	movw	r20, r24
    7ac4:	0a 2e       	mov	r0, r26
    7ac6:	06 94       	lsr	r0
    7ac8:	57 95       	ror	r21
    7aca:	47 95       	ror	r20
    7acc:	37 95       	ror	r19
    7ace:	27 95       	ror	r18
    7ad0:	ba 95       	dec	r27
    7ad2:	c9 f7       	brne	.-14     	; 0x7ac6 <__ultoa_invert+0xa2>
    7ad4:	62 0f       	add	r22, r18
    7ad6:	73 1f       	adc	r23, r19
    7ad8:	84 1f       	adc	r24, r20
    7ada:	95 1f       	adc	r25, r21
    7adc:	a0 1d       	adc	r26, r0
    7ade:	08 95       	ret

00007ae0 <_exit>:
    7ae0:	f8 94       	cli

00007ae2 <__stop_program>:
    7ae2:	ff cf       	rjmp	.-2      	; 0x7ae2 <__stop_program>
