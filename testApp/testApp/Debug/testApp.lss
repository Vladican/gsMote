
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007a42  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000010e  00802000  00007a42  00007ad6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002faa  0080210e  0080210e  00007be4  2**0
                  ALLOC
  3 .stab         000028f8  00000000  00000000  00007be4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009ca  00000000  00000000  0000a4dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000420  00000000  00000000  0000aea8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000c1d1  00000000  00000000  0000b2c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000270c  00000000  00000000  00017499  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000058e1  00000000  00000000  00019ba5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001bec  00000000  00000000  0001f488  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004676  00000000  00000000  00021074  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000082c0  00000000  00000000  000256ea  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0017fd97  00000000  00000000  0002d9aa  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000001d8  00000000  00000000  001ad741  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 83 13 	jmp	0x2706	; 0x2706 <__vector_16>
      44:	0c 94 5b 13 	jmp	0x26b6	; 0x26b6 <__vector_17>
      48:	0c 94 33 13 	jmp	0x2666	; 0x2666 <__vector_18>
      4c:	0c 94 ed 12 	jmp	0x25da	; 0x25da <__vector_19>
      50:	0c 94 68 0c 	jmp	0x18d0	; 0x18d0 <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 26 09 	jmp	0x124c	; 0x124c <__vector_47>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 41 1e 	jmp	0x3c82	; 0x3c82 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 2a 10 	jmp	0x2054	; 0x2054 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 c5 12 	jmp	0x258a	; 0x258a <__vector_79>
     140:	0c 94 9d 12 	jmp	0x253a	; 0x253a <__vector_80>
     144:	0c 94 75 12 	jmp	0x24ea	; 0x24ea <__vector_81>
     148:	0c 94 4b 12 	jmp	0x2496	; 0x2496 <__vector_82>
     14c:	0c 94 6d 09 	jmp	0x12da	; 0x12da <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 fa 0c 	jmp	0x19f4	; 0x19f4 <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e2 e4       	ldi	r30, 0x42	; 66
     244:	fa e7       	ldi	r31, 0x7A	; 122
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	ae 30       	cpi	r26, 0x0E	; 14
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	ae e0       	ldi	r26, 0x0E	; 14
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a8 3b       	cpi	r26, 0xB8	; 184
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 db 06 	call	0xdb6	; 0xdb6 <main>
     26a:	0c 94 1f 3d 	jmp	0x7a3e	; 0x7a3e <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <writeFRAM>:
 * Created: 3/8/2014 11:40:36 AM
 *  Author: VLAD
 */ 
#include "FRAM.h"

void writeFRAM(uint8_t* buffer, uint16_t length) {
     272:	af 92       	push	r10
     274:	bf 92       	push	r11
     276:	df 92       	push	r13
     278:	ef 92       	push	r14
     27a:	ff 92       	push	r15
     27c:	0f 93       	push	r16
     27e:	1f 93       	push	r17
     280:	cf 93       	push	r28
     282:	df 93       	push	r29
     284:	e8 2e       	mov	r14, r24
     286:	d9 2e       	mov	r13, r25
     288:	8b 01       	movw	r16, r22
	
	uint8_t prev_SPI_settings;
	ADCPower(TRUE);
     28a:	81 e0       	ldi	r24, 0x01	; 1
     28c:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	prev_SPI_settings = SPIC.CTRL;
     290:	c0 ec       	ldi	r28, 0xC0	; 192
     292:	d8 e0       	ldi	r29, 0x08	; 8
     294:	f8 80       	ld	r15, Y
	SPIInit(SPI_MODE_0_gc);
     296:	80 e0       	ldi	r24, 0x00	; 0
     298:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     29c:	80 ed       	ldi	r24, 0xD0	; 208
     29e:	88 83       	st	Y, r24
	SPICS(TRUE);
     2a0:	81 e0       	ldi	r24, 0x01	; 1
     2a2:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2a6:	88 e0       	ldi	r24, 0x08	; 8
     2a8:	e0 e2       	ldi	r30, 0x20	; 32
     2aa:	f6 e0       	ldi	r31, 0x06	; 6
     2ac:	86 83       	std	Z+6, r24	; 0x06
	nop();
     2ae:	00 00       	nop
	SPIC.DATA = FR_WREN;
     2b0:	86 e0       	ldi	r24, 0x06	; 6
     2b2:	8b 83       	std	Y+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2b4:	e0 ec       	ldi	r30, 0xC0	; 192
     2b6:	f8 e0       	ldi	r31, 0x08	; 8
     2b8:	82 81       	ldd	r24, Z+2	; 0x02
     2ba:	88 23       	and	r24, r24
     2bc:	ec f7       	brge	.-6      	; 0x2b8 <writeFRAM+0x46>
	SPIBuffer[12] = SPIC.DATA;
     2be:	e0 ec       	ldi	r30, 0xC0	; 192
     2c0:	f8 e0       	ldi	r31, 0x08	; 8
     2c2:	83 81       	ldd	r24, Z+3	; 0x03
     2c4:	80 93 2d 3e 	sts	0x3E2D, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
     2c8:	a0 e2       	ldi	r26, 0x20	; 32
     2ca:	b6 e0       	ldi	r27, 0x06	; 6
     2cc:	88 e0       	ldi	r24, 0x08	; 8
     2ce:	15 96       	adiw	r26, 0x05	; 5
     2d0:	8c 93       	st	X, r24
     2d2:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
     2d4:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2d6:	16 96       	adiw	r26, 0x06	; 6
     2d8:	8c 93       	st	X, r24
     2da:	16 97       	sbiw	r26, 0x06	; 6
	nop();
     2dc:	00 00       	nop
	SPIC.DATA = FR_WRITE;
     2de:	82 e0       	ldi	r24, 0x02	; 2
     2e0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2e2:	82 81       	ldd	r24, Z+2	; 0x02
     2e4:	88 23       	and	r24, r24
     2e6:	ec f7       	brge	.-6      	; 0x2e2 <writeFRAM+0x70>
	SPIBuffer[12] = SPIC.DATA;
     2e8:	e0 ec       	ldi	r30, 0xC0	; 192
     2ea:	f8 e0       	ldi	r31, 0x08	; 8
     2ec:	83 81       	ldd	r24, Z+3	; 0x03
     2ee:	80 93 2d 3e 	sts	0x3E2D, r24
	//send address at which to start writing data
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
     2f2:	80 91 1f 3e 	lds	r24, 0x3E1F
     2f6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2f8:	82 81       	ldd	r24, Z+2	; 0x02
     2fa:	88 23       	and	r24, r24
     2fc:	ec f7       	brge	.-6      	; 0x2f8 <writeFRAM+0x86>
	SPIBuffer[12] = SPIC.DATA;
     2fe:	e0 ec       	ldi	r30, 0xC0	; 192
     300:	f8 e0       	ldi	r31, 0x08	; 8
     302:	83 81       	ldd	r24, Z+3	; 0x03
     304:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
     308:	80 91 1e 3e 	lds	r24, 0x3E1E
     30c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     30e:	82 81       	ldd	r24, Z+2	; 0x02
     310:	88 23       	and	r24, r24
     312:	ec f7       	brge	.-6      	; 0x30e <writeFRAM+0x9c>
	SPIBuffer[12] = SPIC.DATA;
     314:	e0 ec       	ldi	r30, 0xC0	; 192
     316:	f8 e0       	ldi	r31, 0x08	; 8
     318:	83 81       	ldd	r24, Z+3	; 0x03
     31a:	80 93 2d 3e 	sts	0x3E2D, r24
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     31e:	a8 01       	movw	r20, r16
     320:	60 e0       	ldi	r22, 0x00	; 0
     322:	70 e0       	ldi	r23, 0x00	; 0
     324:	41 15       	cp	r20, r1
     326:	51 05       	cpc	r21, r1
     328:	61 05       	cpc	r22, r1
     32a:	71 05       	cpc	r23, r1
     32c:	c9 f0       	breq	.+50     	; 0x360 <writeFRAM+0xee>
     32e:	ae 2c       	mov	r10, r14
     330:	bd 2c       	mov	r11, r13
     332:	80 e0       	ldi	r24, 0x00	; 0
     334:	90 e0       	ldi	r25, 0x00	; 0
     336:	dc 01       	movw	r26, r24
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     338:	2d e2       	ldi	r18, 0x2D	; 45
     33a:	3e e3       	ldi	r19, 0x3E	; 62
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
		SPIC.DATA = buffer[i];
     33c:	e5 01       	movw	r28, r10
     33e:	e9 90       	ld	r14, Y+
     340:	5e 01       	movw	r10, r28
     342:	e3 82       	std	Z+3, r14	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
     344:	e2 80       	ldd	r14, Z+2	; 0x02
     346:	ee 20       	and	r14, r14
     348:	ec f7       	brge	.-6      	; 0x344 <writeFRAM+0xd2>
		SPIBuffer[12] = SPIC.DATA;
     34a:	e3 80       	ldd	r14, Z+3	; 0x03
     34c:	e9 01       	movw	r28, r18
     34e:	e8 82       	st	Y, r14
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     350:	01 96       	adiw	r24, 0x01	; 1
     352:	a1 1d       	adc	r26, r1
     354:	b1 1d       	adc	r27, r1
     356:	84 17       	cp	r24, r20
     358:	95 07       	cpc	r25, r21
     35a:	a6 07       	cpc	r26, r22
     35c:	b7 07       	cpc	r27, r23
     35e:	70 f3       	brcs	.-36     	; 0x33c <writeFRAM+0xca>
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
     360:	88 e0       	ldi	r24, 0x08	; 8
     362:	e0 e2       	ldi	r30, 0x20	; 32
     364:	f6 e0       	ldi	r31, 0x06	; 6
     366:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     368:	80 e0       	ldi	r24, 0x00	; 0
     36a:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIC.CTRL = prev_SPI_settings;
     36e:	f0 92 c0 08 	sts	0x08C0, r15
	//SPIC.CTRL = ADC_SPI_CONFIG_gc;
	//PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
	
	//increment address by the written length
	FRAMAddress +=length;
     372:	80 91 1e 3e 	lds	r24, 0x3E1E
     376:	90 91 1f 3e 	lds	r25, 0x3E1F
     37a:	08 0f       	add	r16, r24
     37c:	19 1f       	adc	r17, r25
     37e:	00 93 1e 3e 	sts	0x3E1E, r16
     382:	10 93 1f 3e 	sts	0x3E1F, r17
}
     386:	df 91       	pop	r29
     388:	cf 91       	pop	r28
     38a:	1f 91       	pop	r17
     38c:	0f 91       	pop	r16
     38e:	ff 90       	pop	r15
     390:	ef 90       	pop	r14
     392:	df 90       	pop	r13
     394:	bf 90       	pop	r11
     396:	af 90       	pop	r10
     398:	08 95       	ret

0000039a <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes, uint16_t startAddress) {
     39a:	df 92       	push	r13
     39c:	ef 92       	push	r14
     39e:	ff 92       	push	r15
     3a0:	0f 93       	push	r16
     3a2:	1f 93       	push	r17
     3a4:	cf 93       	push	r28
     3a6:	df 93       	push	r29
     3a8:	0f 92       	push	r0
     3aa:	0f 92       	push	r0
     3ac:	cd b7       	in	r28, 0x3d	; 61
     3ae:	de b7       	in	r29, 0x3e	; 62
     3b0:	7c 01       	movw	r14, r24
     3b2:	69 83       	std	Y+1, r22	; 0x01
     3b4:	7a 83       	std	Y+2, r23	; 0x02
	
	//save SPI registers
	uint8_t prev_SPI_settings;
	ADCPower(TRUE);
     3b6:	81 e0       	ldi	r24, 0x01	; 1
     3b8:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	prev_SPI_settings = SPIC.CTRL;
     3bc:	00 ec       	ldi	r16, 0xC0	; 192
     3be:	18 e0       	ldi	r17, 0x08	; 8
     3c0:	f8 01       	movw	r30, r16
     3c2:	d0 80       	ld	r13, Z
	SPIInit(SPI_MODE_0_gc);
     3c4:	80 e0       	ldi	r24, 0x00	; 0
     3c6:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     3ca:	80 ed       	ldi	r24, 0xD0	; 208
     3cc:	f8 01       	movw	r30, r16
     3ce:	80 83       	st	Z, r24
	SPICS(TRUE);
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     3d6:	88 e0       	ldi	r24, 0x08	; 8
     3d8:	e0 e2       	ldi	r30, 0x20	; 32
     3da:	f6 e0       	ldi	r31, 0x06	; 6
     3dc:	86 83       	std	Z+6, r24	; 0x06
	nop();
     3de:	00 00       	nop
	
	SPIC.DATA = FR_READ;
     3e0:	83 e0       	ldi	r24, 0x03	; 3
     3e2:	f8 01       	movw	r30, r16
     3e4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3e6:	82 81       	ldd	r24, Z+2	; 0x02
     3e8:	88 23       	and	r24, r24
     3ea:	ec f7       	brge	.-6      	; 0x3e6 <readFRAM+0x4c>
	SPIBuffer[12] = SPIC.DATA;
     3ec:	e0 ec       	ldi	r30, 0xC0	; 192
     3ee:	f8 e0       	ldi	r31, 0x08	; 8
     3f0:	83 81       	ldd	r24, Z+3	; 0x03
     3f2:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = *(((uint8_t*)&startAddress) + 1);;
     3f6:	8a 81       	ldd	r24, Y+2	; 0x02
     3f8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3fa:	82 81       	ldd	r24, Z+2	; 0x02
     3fc:	88 23       	and	r24, r24
     3fe:	ec f7       	brge	.-6      	; 0x3fa <readFRAM+0x60>
	SPIBuffer[12] = SPIC.DATA;
     400:	e0 ec       	ldi	r30, 0xC0	; 192
     402:	f8 e0       	ldi	r31, 0x08	; 8
     404:	83 81       	ldd	r24, Z+3	; 0x03
     406:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
     40a:	89 81       	ldd	r24, Y+1	; 0x01
     40c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     40e:	82 81       	ldd	r24, Z+2	; 0x02
     410:	88 23       	and	r24, r24
     412:	ec f7       	brge	.-6      	; 0x40e <readFRAM+0x74>
	SPIBuffer[12] = SPIC.DATA;
     414:	e0 ec       	ldi	r30, 0xC0	; 192
     416:	f8 e0       	ldi	r31, 0x08	; 8
     418:	83 81       	ldd	r24, Z+3	; 0x03
     41a:	80 93 2d 3e 	sts	0x3E2D, r24
	
	for(uint16_t i = 0; i < numBytes; i++) {
     41e:	e1 14       	cp	r14, r1
     420:	f1 04       	cpc	r15, r1
     422:	b9 f0       	breq	.+46     	; 0x452 <readFRAM+0xb8>
     424:	ed ea       	ldi	r30, 0xAD	; 173
     426:	f1 e2       	ldi	r31, 0x21	; 33
	FRAMAddress +=length;
}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes, uint16_t startAddress) {
     428:	c7 01       	movw	r24, r14
     42a:	8e 0f       	add	r24, r30
     42c:	9f 1f       	adc	r25, r31
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
		SPIC.DATA = 0xAA;
     42e:	a0 ec       	ldi	r26, 0xC0	; 192
     430:	b8 e0       	ldi	r27, 0x08	; 8
     432:	3a ea       	ldi	r19, 0xAA	; 170
     434:	13 96       	adiw	r26, 0x03	; 3
     436:	3c 93       	st	X, r19
     438:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     43a:	12 96       	adiw	r26, 0x02	; 2
     43c:	2c 91       	ld	r18, X
     43e:	12 97       	sbiw	r26, 0x02	; 2
     440:	22 23       	and	r18, r18
     442:	dc f7       	brge	.-10     	; 0x43a <readFRAM+0xa0>
		FRAMReadBuffer[i] = SPIC.DATA;
     444:	13 96       	adiw	r26, 0x03	; 3
     446:	2c 91       	ld	r18, X
     448:	13 97       	sbiw	r26, 0x03	; 3
     44a:	21 93       	st	Z+, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
     44c:	e8 17       	cp	r30, r24
     44e:	f9 07       	cpc	r31, r25
     450:	89 f7       	brne	.-30     	; 0x434 <readFRAM+0x9a>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
     452:	88 e0       	ldi	r24, 0x08	; 8
     454:	e0 e2       	ldi	r30, 0x20	; 32
     456:	f6 e0       	ldi	r31, 0x06	; 6
     458:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     45a:	80 e0       	ldi	r24, 0x00	; 0
     45c:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIC.CTRL = prev_SPI_settings;
     460:	d0 92 c0 08 	sts	0x08C0, r13

}
     464:	0f 90       	pop	r0
     466:	0f 90       	pop	r0
     468:	df 91       	pop	r29
     46a:	cf 91       	pop	r28
     46c:	1f 91       	pop	r17
     46e:	0f 91       	pop	r16
     470:	ff 90       	pop	r15
     472:	ef 90       	pop	r14
     474:	df 90       	pop	r13
     476:	08 95       	ret

00000478 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     478:	cf 92       	push	r12
     47a:	df 92       	push	r13
     47c:	ef 92       	push	r14
     47e:	ff 92       	push	r15
     480:	0f 93       	push	r16
     482:	1f 93       	push	r17
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
     488:	6b 01       	movw	r12, r22
     48a:	7c 01       	movw	r14, r24
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     48c:	dc 01       	movw	r26, r24
     48e:	cb 01       	movw	r24, r22
     490:	88 55       	subi	r24, 0x58	; 88
     492:	92 40       	sbci	r25, 0x02	; 2
     494:	a0 40       	sbci	r26, 0x00	; 0
     496:	b0 40       	sbci	r27, 0x00	; 0
     498:	89 3e       	cpi	r24, 0xE9	; 233
     49a:	2f e3       	ldi	r18, 0x3F	; 63
     49c:	92 07       	cpc	r25, r18
     49e:	2f e0       	ldi	r18, 0x0F	; 15
     4a0:	a2 07       	cpc	r26, r18
     4a2:	20 e0       	ldi	r18, 0x00	; 0
     4a4:	b2 07       	cpc	r27, r18
     4a6:	08 f0       	brcs	.+2      	; 0x4aa <StartSerial+0x32>
     4a8:	5c c0       	rjmp	.+184    	; 0x562 <StartSerial+0xea>
		//baud rate too fast or too slow
		return false;
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     4aa:	0e 94 3c 03 	call	0x678	; 0x678 <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     4ae:	e0 e4       	ldi	r30, 0x40	; 64
     4b0:	f6 e0       	ldi	r31, 0x06	; 6
     4b2:	88 e0       	ldi	r24, 0x08	; 8
     4b4:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = PIN3_bm;
     4b6:	85 83       	std	Z+5, r24	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     4b8:	84 e0       	ldi	r24, 0x04	; 4
     4ba:	82 83       	std	Z+2, r24	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     4bc:	cc 0c       	add	r12, r12
     4be:	dd 1c       	adc	r13, r13
     4c0:	ee 1c       	adc	r14, r14
     4c2:	ff 1c       	adc	r15, r15
     4c4:	cc 0c       	add	r12, r12
     4c6:	dd 1c       	adc	r13, r13
     4c8:	ee 1c       	adc	r14, r14
     4ca:	ff 1c       	adc	r15, r15
     4cc:	c7 01       	movw	r24, r14
     4ce:	b6 01       	movw	r22, r12
     4d0:	66 0f       	add	r22, r22
     4d2:	77 1f       	adc	r23, r23
     4d4:	88 1f       	adc	r24, r24
     4d6:	99 1f       	adc	r25, r25
     4d8:	66 0f       	add	r22, r22
     4da:	77 1f       	adc	r23, r23
     4dc:	88 1f       	adc	r24, r24
     4de:	99 1f       	adc	r25, r25
     4e0:	0e 94 7b 38 	call	0x70f6	; 0x70f6 <__floatunsisf>
     4e4:	9b 01       	movw	r18, r22
     4e6:	ac 01       	movw	r20, r24
     4e8:	60 e0       	ldi	r22, 0x00	; 0
     4ea:	74 e2       	ldi	r23, 0x24	; 36
     4ec:	84 ef       	ldi	r24, 0xF4	; 244
     4ee:	9b e4       	ldi	r25, 0x4B	; 75
     4f0:	0e 94 e7 37 	call	0x6fce	; 0x6fce <__divsf3>
     4f4:	20 e0       	ldi	r18, 0x00	; 0
     4f6:	30 e0       	ldi	r19, 0x00	; 0
     4f8:	40 e8       	ldi	r20, 0x80	; 128
     4fa:	5f e3       	ldi	r21, 0x3F	; 63
     4fc:	0e 94 82 37 	call	0x6f04	; 0x6f04 <__subsf3>
     500:	c6 2f       	mov	r28, r22
     502:	d7 2f       	mov	r29, r23
     504:	18 2f       	mov	r17, r24
     506:	09 2f       	mov	r16, r25
     508:	86 2f       	mov	r24, r22
     50a:	9d 2f       	mov	r25, r29
     50c:	a1 2f       	mov	r26, r17
     50e:	b0 2f       	mov	r27, r16
     510:	bc 01       	movw	r22, r24
     512:	cd 01       	movw	r24, r26
     514:	0e 94 4f 38 	call	0x709e	; 0x709e <__fixunssfsi>
     518:	6b 01       	movw	r12, r22
     51a:	7c 01       	movw	r14, r24
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     51c:	80 e0       	ldi	r24, 0x00	; 0
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	0e 94 7b 38 	call	0x70f6	; 0x70f6 <__floatunsisf>
     524:	9b 01       	movw	r18, r22
     526:	ac 01       	movw	r20, r24
     528:	8c 2f       	mov	r24, r28
     52a:	9d 2f       	mov	r25, r29
     52c:	a1 2f       	mov	r26, r17
     52e:	b0 2f       	mov	r27, r16
     530:	bc 01       	movw	r22, r24
     532:	cd 01       	movw	r24, r26
     534:	0e 94 82 37 	call	0x6f04	; 0x6f04 <__subsf3>
     538:	20 e0       	ldi	r18, 0x00	; 0
     53a:	30 e0       	ldi	r19, 0x00	; 0
     53c:	40 e0       	ldi	r20, 0x00	; 0
     53e:	5f e3       	ldi	r21, 0x3F	; 63
     540:	0e 94 09 39 	call	0x7212	; 0x7212 <__gesf2>
     544:	88 23       	and	r24, r24
     546:	1c f0       	brlt	.+6      	; 0x54e <StartSerial+0xd6>
     548:	08 94       	sec
     54a:	c1 1c       	adc	r12, r1
     54c:	d1 1c       	adc	r13, r1
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     54e:	e0 ea       	ldi	r30, 0xA0	; 160
     550:	f8 e0       	ldi	r31, 0x08	; 8
     552:	c6 82       	std	Z+6, r12	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     554:	d7 82       	std	Z+7, r13	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     556:	83 e0       	ldi	r24, 0x03	; 3
     558:	85 83       	std	Z+5, r24	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     55a:	88 e1       	ldi	r24, 0x18	; 24
     55c:	84 83       	std	Z+4, r24	; 0x04
	return true;
     55e:	81 e0       	ldi	r24, 0x01	; 1
     560:	01 c0       	rjmp	.+2      	; 0x564 <StartSerial+0xec>

bool StartSerial(uint32_t BaudRate){
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
		//baud rate too fast or too slow
		return false;
     562:	80 e0       	ldi	r24, 0x00	; 0
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
	return true;
}
     564:	df 91       	pop	r29
     566:	cf 91       	pop	r28
     568:	1f 91       	pop	r17
     56a:	0f 91       	pop	r16
     56c:	ff 90       	pop	r15
     56e:	ef 90       	pop	r14
     570:	df 90       	pop	r13
     572:	cf 90       	pop	r12
     574:	08 95       	ret

00000576 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     576:	e0 ea       	ldi	r30, 0xA0	; 160
     578:	f8 e0       	ldi	r31, 0x08	; 8
     57a:	91 81       	ldd	r25, Z+1	; 0x01
     57c:	95 ff       	sbrs	r25, 5
     57e:	fd cf       	rjmp	.-6      	; 0x57a <SerialWriteByte+0x4>
		//wait
	}
	//send byte
	USARTC0.DATA = byte;
     580:	80 93 a0 08 	sts	0x08A0, r24
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     584:	08 95       	ret

00000586 <SerialReadByte>:

uint8_t SerialReadByte(){
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     586:	e0 ea       	ldi	r30, 0xA0	; 160
     588:	f8 e0       	ldi	r31, 0x08	; 8
     58a:	81 81       	ldd	r24, Z+1	; 0x01
     58c:	88 23       	and	r24, r24
     58e:	ec f7       	brge	.-6      	; 0x58a <SerialReadByte+0x4>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     590:	80 91 a0 08 	lds	r24, 0x08A0
	return byte;	
}
     594:	08 95       	ret

00000596 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     596:	8f 92       	push	r8
     598:	9f 92       	push	r9
     59a:	af 92       	push	r10
     59c:	bf 92       	push	r11
     59e:	cf 92       	push	r12
     5a0:	df 92       	push	r13
     5a2:	ef 92       	push	r14
     5a4:	ff 92       	push	r15
     5a6:	cf 93       	push	r28
     5a8:	df 93       	push	r29
     5aa:	6a 01       	movw	r12, r20
     5ac:	7b 01       	movw	r14, r22
	uint32_t i;
	for(i=0;i<length;i++){
     5ae:	41 15       	cp	r20, r1
     5b0:	51 05       	cpc	r21, r1
     5b2:	61 05       	cpc	r22, r1
     5b4:	71 05       	cpc	r23, r1
     5b6:	91 f0       	breq	.+36     	; 0x5dc <SerialWriteBuffer+0x46>
     5b8:	c8 2f       	mov	r28, r24
     5ba:	d9 2f       	mov	r29, r25
     5bc:	88 24       	eor	r8, r8
     5be:	99 24       	eor	r9, r9
     5c0:	54 01       	movw	r10, r8
		SerialWriteByte(buffer[i]);
     5c2:	89 91       	ld	r24, Y+
     5c4:	0e 94 bb 02 	call	0x576	; 0x576 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     5c8:	08 94       	sec
     5ca:	81 1c       	adc	r8, r1
     5cc:	91 1c       	adc	r9, r1
     5ce:	a1 1c       	adc	r10, r1
     5d0:	b1 1c       	adc	r11, r1
     5d2:	8c 14       	cp	r8, r12
     5d4:	9d 04       	cpc	r9, r13
     5d6:	ae 04       	cpc	r10, r14
     5d8:	bf 04       	cpc	r11, r15
     5da:	99 f7       	brne	.-26     	; 0x5c2 <SerialWriteBuffer+0x2c>
		SerialWriteByte(buffer[i]);
	}
}
     5dc:	df 91       	pop	r29
     5de:	cf 91       	pop	r28
     5e0:	ff 90       	pop	r15
     5e2:	ef 90       	pop	r14
     5e4:	df 90       	pop	r13
     5e6:	cf 90       	pop	r12
     5e8:	bf 90       	pop	r11
     5ea:	af 90       	pop	r10
     5ec:	9f 90       	pop	r9
     5ee:	8f 90       	pop	r8
     5f0:	08 95       	ret

000005f2 <StopSerial>:

void StopSerial(){
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     5f2:	e0 ea       	ldi	r30, 0xA0	; 160
     5f4:	f8 e0       	ldi	r31, 0x08	; 8
     5f6:	84 81       	ldd	r24, Z+4	; 0x04
     5f8:	87 7e       	andi	r24, 0xE7	; 231
     5fa:	84 83       	std	Z+4, r24	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     5fc:	e0 e4       	ldi	r30, 0x40	; 64
     5fe:	f6 e0       	ldi	r31, 0x06	; 6
     600:	88 e0       	ldi	r24, 0x08	; 8
     602:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     604:	82 83       	std	Z+2, r24	; 0x02
     606:	08 95       	ret

00000608 <init>:
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void init(){
	ADC_POWER_ON = 0;
     608:	10 92 33 3e 	sts	0x3E33, r1
}
     60c:	08 95       	ret

0000060e <setXOSC_32MHz>:

void setXOSC_32MHz() {
	// configure the crystal to match the chip
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
     60e:	80 ec       	ldi	r24, 0xC0	; 192
     610:	60 e0       	ldi	r22, 0x00	; 0
     612:	4b e0       	ldi	r20, 0x0B	; 11
     614:	0e 94 1f 20 	call	0x403e	; 0x403e <CLKSYS_XOSC_Config>
	false,
	OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
     618:	e0 e5       	ldi	r30, 0x50	; 80
     61a:	f0 e0       	ldi	r31, 0x00	; 0
     61c:	80 81       	ld	r24, Z
     61e:	88 60       	ori	r24, 0x08	; 8
     620:	80 83       	st	Z, r24
	// wait for signal to stabilize
do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
     622:	81 81       	ldd	r24, Z+1	; 0x01
     624:	83 ff       	sbrs	r24, 3
     626:	fd cf       	rjmp	.-6      	; 0x622 <setXOSC_32MHz+0x14>
// configure PLL to use the crystal and turn on
CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
     628:	80 ec       	ldi	r24, 0xC0	; 192
     62a:	62 e0       	ldi	r22, 0x02	; 2
     62c:	0e 94 2a 20 	call	0x4054	; 0x4054 <CLKSYS_PLL_Config>
CLKSYS_Enable( OSC_PLLEN_bm );
     630:	e0 e5       	ldi	r30, 0x50	; 80
     632:	f0 e0       	ldi	r31, 0x00	; 0
     634:	80 81       	ld	r24, Z
     636:	80 61       	ori	r24, 0x10	; 16
     638:	80 83       	st	Z, r24
// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
     63a:	81 81       	ldd	r24, Z+1	; 0x01
     63c:	84 ff       	sbrs	r24, 4
     63e:	fd cf       	rjmp	.-6      	; 0x63a <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
     640:	84 e0       	ldi	r24, 0x04	; 4
     642:	0e 94 40 20 	call	0x4080	; 0x4080 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     646:	81 e0       	ldi	r24, 0x01	; 1
     648:	0e 94 30 20 	call	0x4060	; 0x4060 <CLKSYS_Disable>
}
     64c:	08 95       	ret

0000064e <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
     64e:	e0 e5       	ldi	r30, 0x50	; 80
     650:	f0 e0       	ldi	r31, 0x00	; 0
     652:	80 81       	ld	r24, Z
     654:	82 60       	ori	r24, 0x02	; 2
     656:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
     658:	80 e0       	ldi	r24, 0x00	; 0
     65a:	61 e0       	ldi	r22, 0x01	; 1
     65c:	0e 94 3a 20 	call	0x4074	; 0x4074 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     660:	e0 e5       	ldi	r30, 0x50	; 80
     662:	f0 e0       	ldi	r31, 0x00	; 0
     664:	81 81       	ldd	r24, Z+1	; 0x01
     666:	81 ff       	sbrs	r24, 1
     668:	fd cf       	rjmp	.-6      	; 0x664 <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     66a:	81 e0       	ldi	r24, 0x01	; 1
     66c:	0e 94 40 20 	call	0x4080	; 0x4080 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     670:	81 e0       	ldi	r24, 0x01	; 1
     672:	0e 94 30 20 	call	0x4060	; 0x4060 <CLKSYS_Disable>
	
}
     676:	08 95       	ret

00000678 <set_32MHz>:

// produces consistent but inaccurate clock period.
void set_32MHz() {
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
     678:	e0 e5       	ldi	r30, 0x50	; 80
     67a:	f0 e0       	ldi	r31, 0x00	; 0
     67c:	80 81       	ld	r24, Z
     67e:	82 60       	ori	r24, 0x02	; 2
     680:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
     682:	80 e0       	ldi	r24, 0x00	; 0
     684:	60 e0       	ldi	r22, 0x00	; 0
     686:	0e 94 3a 20 	call	0x4074	; 0x4074 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     68a:	e0 e5       	ldi	r30, 0x50	; 80
     68c:	f0 e0       	ldi	r31, 0x00	; 0
     68e:	81 81       	ldd	r24, Z+1	; 0x01
     690:	81 ff       	sbrs	r24, 1
     692:	fd cf       	rjmp	.-6      	; 0x68e <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     694:	81 e0       	ldi	r24, 0x01	; 1
     696:	0e 94 40 20 	call	0x4080	; 0x4080 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     69a:	81 e0       	ldi	r24, 0x01	; 1
     69c:	0e 94 30 20 	call	0x4060	; 0x4060 <CLKSYS_Disable>
	
}
     6a0:	08 95       	ret

000006a2 <portExCS>:


void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
     6a2:	88 23       	and	r24, r24
     6a4:	29 f0       	breq	.+10     	; 0x6b0 <portExCS+0xe>
     6a6:	88 e0       	ldi	r24, 0x08	; 8
     6a8:	e0 e0       	ldi	r30, 0x00	; 0
     6aa:	f6 e0       	ldi	r31, 0x06	; 6
     6ac:	86 83       	std	Z+6, r24	; 0x06
     6ae:	04 c0       	rjmp	.+8      	; 0x6b8 <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
     6b0:	88 e0       	ldi	r24, 0x08	; 8
     6b2:	e0 e0       	ldi	r30, 0x00	; 0
     6b4:	f6 e0       	ldi	r31, 0x06	; 6
     6b6:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6b8:	8a e6       	ldi	r24, 0x6A	; 106
     6ba:	8a 95       	dec	r24
     6bc:	f1 f7       	brne	.-4      	; 0x6ba <portExCS+0x18>
     6be:	00 c0       	rjmp	.+0      	; 0x6c0 <portExCS+0x1e>
	}
	_delay_us(10);
}
     6c0:	08 95       	ret

000006c2 <Ext1Power>:
	SPIDisable();
}

void Ext1Power(uint8_t on) {
	
	if (on) {
     6c2:	88 23       	and	r24, r24
     6c4:	79 f0       	breq	.+30     	; 0x6e4 <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
     6c6:	e0 ea       	ldi	r30, 0xA0	; 160
     6c8:	f6 e0       	ldi	r31, 0x06	; 6
     6ca:	80 e2       	ldi	r24, 0x20	; 32
     6cc:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
     6ce:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6d0:	8f ef       	ldi	r24, 0xFF	; 255
     6d2:	93 ec       	ldi	r25, 0xC3	; 195
     6d4:	a9 e0       	ldi	r26, 0x09	; 9
     6d6:	81 50       	subi	r24, 0x01	; 1
     6d8:	90 40       	sbci	r25, 0x00	; 0
     6da:	a0 40       	sbci	r26, 0x00	; 0
     6dc:	e1 f7       	brne	.-8      	; 0x6d6 <Ext1Power+0x14>
     6de:	00 c0       	rjmp	.+0      	; 0x6e0 <Ext1Power+0x1e>
     6e0:	00 00       	nop
     6e2:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
     6e4:	e0 ea       	ldi	r30, 0xA0	; 160
     6e6:	f6 e0       	ldi	r31, 0x06	; 6
     6e8:	80 e2       	ldi	r24, 0x20	; 32
     6ea:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
     6ec:	82 83       	std	Z+2, r24	; 0x02
     6ee:	08 95       	ret

000006f0 <Ext2Power>:
	}
}

void Ext2Power(uint8_t on) {
	
	if (on) {
     6f0:	88 23       	and	r24, r24
     6f2:	79 f0       	breq	.+30     	; 0x712 <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
     6f4:	e0 ea       	ldi	r30, 0xA0	; 160
     6f6:	f6 e0       	ldi	r31, 0x06	; 6
     6f8:	80 e4       	ldi	r24, 0x40	; 64
     6fa:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
     6fc:	85 83       	std	Z+5, r24	; 0x05
     6fe:	8f ef       	ldi	r24, 0xFF	; 255
     700:	93 ec       	ldi	r25, 0xC3	; 195
     702:	a9 e0       	ldi	r26, 0x09	; 9
     704:	81 50       	subi	r24, 0x01	; 1
     706:	90 40       	sbci	r25, 0x00	; 0
     708:	a0 40       	sbci	r26, 0x00	; 0
     70a:	e1 f7       	brne	.-8      	; 0x704 <Ext2Power+0x14>
     70c:	00 c0       	rjmp	.+0      	; 0x70e <Ext2Power+0x1e>
     70e:	00 00       	nop
     710:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
     712:	e0 ea       	ldi	r30, 0xA0	; 160
     714:	f6 e0       	ldi	r31, 0x06	; 6
     716:	80 e4       	ldi	r24, 0x40	; 64
     718:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
     71a:	82 83       	std	Z+2, r24	; 0x02
     71c:	08 95       	ret

0000071e <HVPower>:
	}
}

void HVPower(uint8_t on) {
	
	if (on) {
     71e:	88 23       	and	r24, r24
     720:	79 f0       	breq	.+30     	; 0x740 <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
     722:	e0 ea       	ldi	r30, 0xA0	; 160
     724:	f6 e0       	ldi	r31, 0x06	; 6
     726:	80 e8       	ldi	r24, 0x80	; 128
     728:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
     72a:	85 83       	std	Z+5, r24	; 0x05
     72c:	8f ef       	ldi	r24, 0xFF	; 255
     72e:	93 ec       	ldi	r25, 0xC3	; 195
     730:	a9 e0       	ldi	r26, 0x09	; 9
     732:	81 50       	subi	r24, 0x01	; 1
     734:	90 40       	sbci	r25, 0x00	; 0
     736:	a0 40       	sbci	r26, 0x00	; 0
     738:	e1 f7       	brne	.-8      	; 0x732 <HVPower+0x14>
     73a:	00 c0       	rjmp	.+0      	; 0x73c <HVPower+0x1e>
     73c:	00 00       	nop
     73e:	05 c0       	rjmp	.+10     	; 0x74a <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
     740:	e0 ea       	ldi	r30, 0xA0	; 160
     742:	f6 e0       	ldi	r31, 0x06	; 6
     744:	80 e8       	ldi	r24, 0x80	; 128
     746:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
     748:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     74a:	af e3       	ldi	r26, 0x3F	; 63
     74c:	bf e1       	ldi	r27, 0x1F	; 31
     74e:	11 97       	sbiw	r26, 0x01	; 1
     750:	f1 f7       	brne	.-4      	; 0x74e <HVPower+0x30>
     752:	00 c0       	rjmp	.+0      	; 0x754 <HVPower+0x36>
     754:	00 00       	nop
	}
	_delay_us(1000);
}
     756:	08 95       	ret

00000758 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
     758:	88 23       	and	r24, r24
     75a:	29 f0       	breq	.+10     	; 0x766 <lowerMuxCS+0xe>
     75c:	80 e1       	ldi	r24, 0x10	; 16
     75e:	e0 e8       	ldi	r30, 0x80	; 128
     760:	f6 e0       	ldi	r31, 0x06	; 6
     762:	86 83       	std	Z+6, r24	; 0x06
     764:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
     766:	80 e1       	ldi	r24, 0x10	; 16
     768:	e0 e8       	ldi	r30, 0x80	; 128
     76a:	f6 e0       	ldi	r31, 0x06	; 6
     76c:	85 83       	std	Z+5, r24	; 0x05
     76e:	08 95       	ret

00000770 <upperMuxCS>:
}

void upperMuxCS(uint8_t write) {
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
     770:	88 23       	and	r24, r24
     772:	29 f0       	breq	.+10     	; 0x77e <upperMuxCS+0xe>
     774:	82 e0       	ldi	r24, 0x02	; 2
     776:	e0 e4       	ldi	r30, 0x40	; 64
     778:	f6 e0       	ldi	r31, 0x06	; 6
     77a:	86 83       	std	Z+6, r24	; 0x06
     77c:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
     77e:	82 e0       	ldi	r24, 0x02	; 2
     780:	e0 e4       	ldi	r30, 0x40	; 64
     782:	f6 e0       	ldi	r31, 0x06	; 6
     784:	85 83       	std	Z+5, r24	; 0x05
     786:	08 95       	ret

00000788 <SPIInit>:
}

void SPIInit(uint8_t mode) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     788:	e0 e4       	ldi	r30, 0x40	; 64
     78a:	f6 e0       	ldi	r31, 0x06	; 6
     78c:	90 e1       	ldi	r25, 0x10	; 16
     78e:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     790:	28 e3       	ldi	r18, 0x38	; 56
     792:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     794:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
     796:	81 65       	ori	r24, 0x51	; 81
     798:	a0 ec       	ldi	r26, 0xC0	; 192
     79a:	b8 e0       	ldi	r27, 0x08	; 8
     79c:	8c 93       	st	X, r24
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     79e:	11 96       	adiw	r26, 0x01	; 1
     7a0:	1c 92       	st	X, r1
     7a2:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     7a4:	80 ea       	ldi	r24, 0xA0	; 160
     7a6:	81 83       	std	Z+1, r24	; 0x01

	
}
     7a8:	08 95       	ret

000007aa <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     7aa:	e0 e4       	ldi	r30, 0x40	; 64
     7ac:	f6 e0       	ldi	r31, 0x06	; 6
     7ae:	90 e1       	ldi	r25, 0x10	; 16
     7b0:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     7b2:	28 e3       	ldi	r18, 0x38	; 56
     7b4:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     7b6:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
     7b8:	80 65       	ori	r24, 0x50	; 80
     7ba:	68 2b       	or	r22, r24
     7bc:	a0 ec       	ldi	r26, 0xC0	; 192
     7be:	b8 e0       	ldi	r27, 0x08	; 8
     7c0:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     7c2:	11 96       	adiw	r26, 0x01	; 1
     7c4:	1c 92       	st	X, r1
     7c6:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     7c8:	80 ea       	ldi	r24, 0xA0	; 160
     7ca:	81 83       	std	Z+1, r24	; 0x01
}
     7cc:	08 95       	ret

000007ce <SPICS>:

void SPICS(uint8_t enable) {
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
     7ce:	88 23       	and	r24, r24
     7d0:	29 f0       	breq	.+10     	; 0x7dc <SPICS+0xe>
     7d2:	80 e1       	ldi	r24, 0x10	; 16
     7d4:	e0 e4       	ldi	r30, 0x40	; 64
     7d6:	f6 e0       	ldi	r31, 0x06	; 6
     7d8:	86 83       	std	Z+6, r24	; 0x06
     7da:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
     7dc:	80 e1       	ldi	r24, 0x10	; 16
     7de:	e0 e4       	ldi	r30, 0x40	; 64
     7e0:	f6 e0       	ldi	r31, 0x06	; 6
     7e2:	85 83       	std	Z+5, r24	; 0x05
     7e4:	08 95       	ret

000007e6 <SPIDisable>:
	}
}

void SPIDisable() {
	
	PORTC.OUTSET = PIN4_bm;
     7e6:	e0 e4       	ldi	r30, 0x40	; 64
     7e8:	f6 e0       	ldi	r31, 0x06	; 6
     7ea:	80 e1       	ldi	r24, 0x10	; 16
     7ec:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
     7ee:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
     7f2:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
     7f4:	80 eb       	ldi	r24, 0xB0	; 176
     7f6:	82 83       	std	Z+2, r24	; 0x02

}
     7f8:	08 95       	ret

000007fa <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     7fa:	cf 93       	push	r28
     7fc:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     7fe:	c8 2f       	mov	r28, r24
     800:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
     802:	d8 2f       	mov	r29, r24
     804:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     806:	28 2f       	mov	r18, r24
     808:	30 e0       	ldi	r19, 0x00	; 0
     80a:	a9 01       	movw	r20, r18
     80c:	45 70       	andi	r20, 0x05	; 5
     80e:	50 70       	andi	r21, 0x00	; 0
     810:	41 15       	cp	r20, r1
     812:	51 05       	cpc	r21, r1
     814:	49 f0       	breq	.+18     	; 0x828 <set_filter+0x2e>
     816:	90 91 31 3e 	lds	r25, 0x3E31
     81a:	48 2f       	mov	r20, r24
     81c:	42 95       	swap	r20
     81e:	4f 70       	andi	r20, 0x0F	; 15
     820:	90 7f       	andi	r25, 0xF0	; 240
     822:	94 2b       	or	r25, r20
     824:	90 93 31 3e 	sts	0x3E31, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     828:	2a 70       	andi	r18, 0x0A	; 10
     82a:	30 70       	andi	r19, 0x00	; 0
     82c:	21 15       	cp	r18, r1
     82e:	31 05       	cpc	r19, r1
     830:	39 f0       	breq	.+14     	; 0x840 <set_filter+0x46>
     832:	90 91 31 3e 	lds	r25, 0x3E31
     836:	80 7f       	andi	r24, 0xF0	; 240
     838:	9f 70       	andi	r25, 0x0F	; 15
     83a:	89 2b       	or	r24, r25
     83c:	80 93 31 3e 	sts	0x3E31, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     840:	84 e0       	ldi	r24, 0x04	; 4
     842:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     846:	80 91 31 3e 	lds	r24, 0x3E31
     84a:	80 93 21 3e 	sts	0x3E21, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     84e:	cc 23       	and	r28, r28
     850:	19 f0       	breq	.+6      	; 0x858 <set_filter+0x5e>
     852:	81 e0       	ldi	r24, 0x01	; 1
     854:	0e 94 ac 03 	call	0x758	; 0x758 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     858:	dd 23       	and	r29, r29
     85a:	19 f0       	breq	.+6      	; 0x862 <set_filter+0x68>
     85c:	81 e0       	ldi	r24, 0x01	; 1
     85e:	0e 94 b8 03 	call	0x770	; 0x770 <upperMuxCS>

	SPICS(TRUE);
     862:	81 e0       	ldi	r24, 0x01	; 1
     864:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     868:	8f ef       	ldi	r24, 0xFF	; 255
     86a:	e0 ec       	ldi	r30, 0xC0	; 192
     86c:	f8 e0       	ldi	r31, 0x08	; 8
     86e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     870:	82 81       	ldd	r24, Z+2	; 0x02
     872:	88 23       	and	r24, r24
     874:	ec f7       	brge	.-6      	; 0x870 <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
     876:	e0 ec       	ldi	r30, 0xC0	; 192
     878:	f8 e0       	ldi	r31, 0x08	; 8
     87a:	83 81       	ldd	r24, Z+3	; 0x03
     87c:	80 93 2d 3e 	sts	0x3E2D, r24

	nop();
     880:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     882:	ad e2       	ldi	r26, 0x2D	; 45
     884:	be e3       	ldi	r27, 0x3E	; 62
     886:	1c 97       	sbiw	r26, 0x0c	; 12
     888:	8c 91       	ld	r24, X
     88a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     88c:	82 81       	ldd	r24, Z+2	; 0x02
     88e:	88 23       	and	r24, r24
     890:	ec f7       	brge	.-6      	; 0x88c <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     892:	e0 ec       	ldi	r30, 0xC0	; 192
     894:	f8 e0       	ldi	r31, 0x08	; 8
     896:	83 81       	ldd	r24, Z+3	; 0x03
     898:	80 93 2d 3e 	sts	0x3E2D, r24
	SPICS(FALSE);
     89c:	80 e0       	ldi	r24, 0x00	; 0
     89e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     8a2:	cc 23       	and	r28, r28
     8a4:	19 f0       	breq	.+6      	; 0x8ac <set_filter+0xb2>
     8a6:	80 e0       	ldi	r24, 0x00	; 0
     8a8:	0e 94 ac 03 	call	0x758	; 0x758 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     8ac:	dd 23       	and	r29, r29
     8ae:	19 f0       	breq	.+6      	; 0x8b6 <set_filter+0xbc>
     8b0:	80 e0       	ldi	r24, 0x00	; 0
     8b2:	0e 94 b8 03 	call	0x770	; 0x770 <upperMuxCS>
	SPIDisable();
     8b6:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
}
     8ba:	df 91       	pop	r29
     8bc:	cf 91       	pop	r28
     8be:	08 95       	ret

000008c0 <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     8c0:	cf 93       	push	r28
     8c2:	df 93       	push	r29
     8c4:	c8 2f       	mov	r28, r24
     8c6:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     8c8:	80 e0       	ldi	r24, 0x00	; 0
     8ca:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
     8ce:	81 e0       	ldi	r24, 0x01	; 1
     8d0:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(TRUE);
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
     8da:	dd 23       	and	r29, r29
     8dc:	89 f0       	breq	.+34     	; 0x900 <PortEx_OUTCLR+0x40>
     8de:	80 91 ac 21 	lds	r24, 0x21AC
     8e2:	c0 95       	com	r28
     8e4:	c8 23       	and	r28, r24
     8e6:	c0 93 ac 21 	sts	0x21AC, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
     8ea:	80 e4       	ldi	r24, 0x40	; 64
     8ec:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     8f0:	84 e1       	ldi	r24, 0x14	; 20
     8f2:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = bankA_OUT;
     8f6:	80 91 ac 21 	lds	r24, 0x21AC
     8fa:	80 93 23 3e 	sts	0x3E23, r24
     8fe:	10 c0       	rjmp	.+32     	; 0x920 <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
     900:	80 91 32 3e 	lds	r24, 0x3E32
     904:	c0 95       	com	r28
     906:	c8 23       	and	r28, r24
     908:	c0 93 32 3e 	sts	0x3E32, r28
	
	SPIBuffer[0] = PS_WRITE;
     90c:	80 e4       	ldi	r24, 0x40	; 64
     90e:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     912:	85 e1       	ldi	r24, 0x15	; 21
     914:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = bankB_OUT; 
     918:	80 91 32 3e 	lds	r24, 0x3E32
     91c:	80 93 23 3e 	sts	0x3E23, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     920:	80 e0       	ldi	r24, 0x00	; 0
     922:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     924:	21 e2       	ldi	r18, 0x21	; 33
     926:	3e e3       	ldi	r19, 0x3E	; 62
     928:	a0 ec       	ldi	r26, 0xC0	; 192
     92a:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     92c:	cd e2       	ldi	r28, 0x2D	; 45
     92e:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     930:	f9 01       	movw	r30, r18
     932:	e8 0f       	add	r30, r24
     934:	f9 1f       	adc	r31, r25
     936:	40 81       	ld	r20, Z
     938:	13 96       	adiw	r26, 0x03	; 3
     93a:	4c 93       	st	X, r20
     93c:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     93e:	12 96       	adiw	r26, 0x02	; 2
     940:	4c 91       	ld	r20, X
     942:	12 97       	sbiw	r26, 0x02	; 2
     944:	44 23       	and	r20, r20
     946:	dc f7       	brge	.-10     	; 0x93e <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
     948:	13 96       	adiw	r26, 0x03	; 3
     94a:	4c 91       	ld	r20, X
     94c:	13 97       	sbiw	r26, 0x03	; 3
     94e:	48 83       	st	Y, r20
     950:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     952:	83 30       	cpi	r24, 0x03	; 3
     954:	91 05       	cpc	r25, r1
     956:	61 f7       	brne	.-40     	; 0x930 <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     958:	80 e0       	ldi	r24, 0x00	; 0
     95a:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(FALSE);
     95e:	80 e0       	ldi	r24, 0x00	; 0
     960:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	SPIDisable();
     964:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
}
     968:	df 91       	pop	r29
     96a:	cf 91       	pop	r28
     96c:	08 95       	ret

0000096e <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     96e:	cf 93       	push	r28
     970:	df 93       	push	r29
     972:	c8 2f       	mov	r28, r24
     974:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     976:	80 e0       	ldi	r24, 0x00	; 0
     978:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
     97c:	81 e0       	ldi	r24, 0x01	; 1
     97e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(TRUE);
     982:	81 e0       	ldi	r24, 0x01	; 1
     984:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
     988:	dd 23       	and	r29, r29
     98a:	81 f0       	breq	.+32     	; 0x9ac <PortEx_OUTSET+0x3e>
     98c:	80 91 ac 21 	lds	r24, 0x21AC
     990:	c8 2b       	or	r28, r24
     992:	c0 93 ac 21 	sts	0x21AC, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
     996:	80 e4       	ldi	r24, 0x40	; 64
     998:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     99c:	84 e1       	ldi	r24, 0x14	; 20
     99e:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = bankA_OUT;
     9a2:	80 91 ac 21 	lds	r24, 0x21AC
     9a6:	80 93 23 3e 	sts	0x3E23, r24
     9aa:	0f c0       	rjmp	.+30     	; 0x9ca <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
     9ac:	80 91 32 3e 	lds	r24, 0x3E32
     9b0:	c8 2b       	or	r28, r24
     9b2:	c0 93 32 3e 	sts	0x3E32, r28
	
	SPIBuffer[0] = PS_WRITE;
     9b6:	80 e4       	ldi	r24, 0x40	; 64
     9b8:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     9bc:	85 e1       	ldi	r24, 0x15	; 21
     9be:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = bankB_OUT; 
     9c2:	80 91 32 3e 	lds	r24, 0x3E32
     9c6:	80 93 23 3e 	sts	0x3E23, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     9ca:	80 e0       	ldi	r24, 0x00	; 0
     9cc:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     9ce:	21 e2       	ldi	r18, 0x21	; 33
     9d0:	3e e3       	ldi	r19, 0x3E	; 62
     9d2:	a0 ec       	ldi	r26, 0xC0	; 192
     9d4:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     9d6:	cd e2       	ldi	r28, 0x2D	; 45
     9d8:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     9da:	f9 01       	movw	r30, r18
     9dc:	e8 0f       	add	r30, r24
     9de:	f9 1f       	adc	r31, r25
     9e0:	40 81       	ld	r20, Z
     9e2:	13 96       	adiw	r26, 0x03	; 3
     9e4:	4c 93       	st	X, r20
     9e6:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     9e8:	12 96       	adiw	r26, 0x02	; 2
     9ea:	4c 91       	ld	r20, X
     9ec:	12 97       	sbiw	r26, 0x02	; 2
     9ee:	44 23       	and	r20, r20
     9f0:	dc f7       	brge	.-10     	; 0x9e8 <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
     9f2:	13 96       	adiw	r26, 0x03	; 3
     9f4:	4c 91       	ld	r20, X
     9f6:	13 97       	sbiw	r26, 0x03	; 3
     9f8:	48 83       	st	Y, r20
     9fa:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     9fc:	83 30       	cpi	r24, 0x03	; 3
     9fe:	91 05       	cpc	r25, r1
     a00:	61 f7       	brne	.-40     	; 0x9da <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     a02:	80 e0       	ldi	r24, 0x00	; 0
     a04:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(FALSE);
     a08:	80 e0       	ldi	r24, 0x00	; 0
     a0a:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	SPIDisable();
     a0e:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
}
     a12:	df 91       	pop	r29
     a14:	cf 91       	pop	r28
     a16:	08 95       	ret

00000a18 <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     a18:	cf 93       	push	r28
     a1a:	df 93       	push	r29
     a1c:	c8 2f       	mov	r28, r24
     a1e:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     a20:	80 e0       	ldi	r24, 0x00	; 0
     a22:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
     a26:	81 e0       	ldi	r24, 0x01	; 1
     a28:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(TRUE);
     a2c:	81 e0       	ldi	r24, 0x01	; 1
     a2e:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
     a32:	dd 23       	and	r29, r29
     a34:	89 f0       	breq	.+34     	; 0xa58 <PortEx_DIRCLR+0x40>
     a36:	80 91 30 3e 	lds	r24, 0x3E30
     a3a:	80 95       	com	r24
     a3c:	c8 23       	and	r28, r24
     a3e:	c0 93 30 3e 	sts	0x3E30, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     a42:	80 e4       	ldi	r24, 0x40	; 64
     a44:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     a48:	10 92 22 3e 	sts	0x3E22, r1
		SPIBuffer[2] = ~bankA_DIR; 
     a4c:	80 91 30 3e 	lds	r24, 0x3E30
     a50:	80 95       	com	r24
     a52:	80 93 23 3e 	sts	0x3E23, r24
     a56:	11 c0       	rjmp	.+34     	; 0xa7a <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
     a58:	80 91 47 3e 	lds	r24, 0x3E47
     a5c:	80 95       	com	r24
     a5e:	c8 23       	and	r28, r24
     a60:	c0 93 47 3e 	sts	0x3E47, r28
	
	SPIBuffer[0] = PS_WRITE;
     a64:	80 e4       	ldi	r24, 0x40	; 64
     a66:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     a6a:	81 e0       	ldi	r24, 0x01	; 1
     a6c:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = ~bankB_DIR;
     a70:	80 91 47 3e 	lds	r24, 0x3E47
     a74:	80 95       	com	r24
     a76:	80 93 23 3e 	sts	0x3E23, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     a7e:	21 e2       	ldi	r18, 0x21	; 33
     a80:	3e e3       	ldi	r19, 0x3E	; 62
     a82:	a0 ec       	ldi	r26, 0xC0	; 192
     a84:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     a86:	cd e2       	ldi	r28, 0x2D	; 45
     a88:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     a8a:	f9 01       	movw	r30, r18
     a8c:	e8 0f       	add	r30, r24
     a8e:	f9 1f       	adc	r31, r25
     a90:	40 81       	ld	r20, Z
     a92:	13 96       	adiw	r26, 0x03	; 3
     a94:	4c 93       	st	X, r20
     a96:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     a98:	12 96       	adiw	r26, 0x02	; 2
     a9a:	4c 91       	ld	r20, X
     a9c:	12 97       	sbiw	r26, 0x02	; 2
     a9e:	44 23       	and	r20, r20
     aa0:	dc f7       	brge	.-10     	; 0xa98 <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
     aa2:	13 96       	adiw	r26, 0x03	; 3
     aa4:	4c 91       	ld	r20, X
     aa6:	13 97       	sbiw	r26, 0x03	; 3
     aa8:	48 83       	st	Y, r20
     aaa:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     aac:	83 30       	cpi	r24, 0x03	; 3
     aae:	91 05       	cpc	r25, r1
     ab0:	61 f7       	brne	.-40     	; 0xa8a <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     ab2:	80 e0       	ldi	r24, 0x00	; 0
     ab4:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(FALSE);
     ab8:	80 e0       	ldi	r24, 0x00	; 0
     aba:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	SPIDisable();
     abe:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
}
     ac2:	df 91       	pop	r29
     ac4:	cf 91       	pop	r28
     ac6:	08 95       	ret

00000ac8 <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     ac8:	cf 93       	push	r28
     aca:	df 93       	push	r29
     acc:	c8 2f       	mov	r28, r24
     ace:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
     ad0:	80 e0       	ldi	r24, 0x00	; 0
     ad2:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
     ad6:	81 e0       	ldi	r24, 0x01	; 1
     ad8:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(TRUE);
     adc:	81 e0       	ldi	r24, 0x01	; 1
     ade:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
     ae2:	dd 23       	and	r29, r29
     ae4:	81 f0       	breq	.+32     	; 0xb06 <PortEx_DIRSET+0x3e>
     ae6:	80 91 30 3e 	lds	r24, 0x3E30
     aea:	c8 2b       	or	r28, r24
     aec:	c0 93 30 3e 	sts	0x3E30, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     af0:	80 e4       	ldi	r24, 0x40	; 64
     af2:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     af6:	10 92 22 3e 	sts	0x3E22, r1
		SPIBuffer[2] = ~bankA_DIR; 
     afa:	80 91 30 3e 	lds	r24, 0x3E30
     afe:	80 95       	com	r24
     b00:	80 93 23 3e 	sts	0x3E23, r24
     b04:	10 c0       	rjmp	.+32     	; 0xb26 <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
     b06:	80 91 47 3e 	lds	r24, 0x3E47
     b0a:	c8 2b       	or	r28, r24
     b0c:	c0 93 47 3e 	sts	0x3E47, r28
	
	SPIBuffer[0] = PS_WRITE;
     b10:	80 e4       	ldi	r24, 0x40	; 64
     b12:	80 93 21 3e 	sts	0x3E21, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     b16:	81 e0       	ldi	r24, 0x01	; 1
     b18:	80 93 22 3e 	sts	0x3E22, r24
		SPIBuffer[2] = ~bankB_DIR;
     b1c:	80 91 47 3e 	lds	r24, 0x3E47
     b20:	80 95       	com	r24
     b22:	80 93 23 3e 	sts	0x3E23, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     b26:	80 e0       	ldi	r24, 0x00	; 0
     b28:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     b2a:	21 e2       	ldi	r18, 0x21	; 33
     b2c:	3e e3       	ldi	r19, 0x3E	; 62
     b2e:	a0 ec       	ldi	r26, 0xC0	; 192
     b30:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     b32:	cd e2       	ldi	r28, 0x2D	; 45
     b34:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     b36:	f9 01       	movw	r30, r18
     b38:	e8 0f       	add	r30, r24
     b3a:	f9 1f       	adc	r31, r25
     b3c:	40 81       	ld	r20, Z
     b3e:	13 96       	adiw	r26, 0x03	; 3
     b40:	4c 93       	st	X, r20
     b42:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
     b44:	12 96       	adiw	r26, 0x02	; 2
     b46:	4c 91       	ld	r20, X
     b48:	12 97       	sbiw	r26, 0x02	; 2
     b4a:	44 23       	and	r20, r20
     b4c:	dc f7       	brge	.-10     	; 0xb44 <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     b4e:	13 96       	adiw	r26, 0x03	; 3
     b50:	4c 91       	ld	r20, X
     b52:	13 97       	sbiw	r26, 0x03	; 3
     b54:	48 83       	st	Y, r20
     b56:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     b58:	83 30       	cpi	r24, 0x03	; 3
     b5a:	91 05       	cpc	r25, r1
     b5c:	61 f7       	brne	.-40     	; 0xb36 <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
     b5e:	80 e0       	ldi	r24, 0x00	; 0
     b60:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	SPICS(FALSE);
     b64:	80 e0       	ldi	r24, 0x00	; 0
     b66:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
     b6a:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>


}
     b6e:	df 91       	pop	r29
     b70:	cf 91       	pop	r28
     b72:	08 95       	ret

00000b74 <ADCPower>:
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
	else PORTC.OUTSET = PIN1_bm;
}

void ADCPower(uint8_t on) {
     b74:	0f 93       	push	r16
     b76:	1f 93       	push	r17
     b78:	cf 93       	push	r28
     b7a:	df 93       	push	r29
	
	if (on && !ADC_POWER_ON) {
     b7c:	88 23       	and	r24, r24
     b7e:	09 f4       	brne	.+2      	; 0xb82 <ADCPower+0xe>
     b80:	4e c0       	rjmp	.+156    	; 0xc1e <ADCPower+0xaa>
     b82:	80 91 33 3e 	lds	r24, 0x3E33
     b86:	88 23       	and	r24, r24
     b88:	09 f0       	breq	.+2      	; 0xb8c <ADCPower+0x18>
     b8a:	81 c0       	rjmp	.+258    	; 0xc8e <ADCPower+0x11a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     b8c:	00 e0       	ldi	r16, 0x00	; 0
     b8e:	16 e0       	ldi	r17, 0x06	; 6
     b90:	8e ed       	ldi	r24, 0xDE	; 222
     b92:	d8 01       	movw	r26, r16
     b94:	11 96       	adiw	r26, 0x01	; 1
     b96:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     b98:	c0 e2       	ldi	r28, 0x20	; 32
     b9a:	d6 e0       	ldi	r29, 0x06	; 6
     b9c:	4e e0       	ldi	r20, 0x0E	; 14
     b9e:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     ba0:	e0 e4       	ldi	r30, 0x40	; 64
     ba2:	f6 e0       	ldi	r31, 0x06	; 6
     ba4:	63 e0       	ldi	r22, 0x03	; 3
     ba6:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     ba8:	80 e8       	ldi	r24, 0x80	; 128
     baa:	96 e0       	ldi	r25, 0x06	; 6
     bac:	50 e1       	ldi	r21, 0x10	; 16
     bae:	dc 01       	movw	r26, r24
     bb0:	11 96       	adiw	r26, 0x01	; 1
     bb2:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     bb4:	20 ea       	ldi	r18, 0xA0	; 160
     bb6:	36 e0       	ldi	r19, 0x06	; 6
     bb8:	d9 01       	movw	r26, r18
     bba:	11 96       	adiw	r26, 0x01	; 1
     bbc:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm; // portEx-CS
     bbe:	7e e9       	ldi	r23, 0x9E	; 158
     bc0:	d8 01       	movw	r26, r16
     bc2:	15 96       	adiw	r26, 0x05	; 5
     bc4:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     bc6:	78 e0       	ldi	r23, 0x08	; 8
     bc8:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     bca:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     bcc:	ec 01       	movw	r28, r24
     bce:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     bd0:	d9 01       	movw	r26, r18
     bd2:	15 96       	adiw	r26, 0x05	; 5
     bd4:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
     bd6:	10 92 31 3e 	sts	0x3E31, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     bda:	8f ef       	ldi	r24, 0xFF	; 255
     bdc:	93 ec       	ldi	r25, 0xC3	; 195
     bde:	a9 e0       	ldi	r26, 0x09	; 9
     be0:	81 50       	subi	r24, 0x01	; 1
     be2:	90 40       	sbci	r25, 0x00	; 0
     be4:	a0 40       	sbci	r26, 0x00	; 0
     be6:	e1 f7       	brne	.-8      	; 0xbe0 <ADCPower+0x6c>
     be8:	00 c0       	rjmp	.+0      	; 0xbea <ADCPower+0x76>
     bea:	00 00       	nop
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     bec:	80 e4       	ldi	r24, 0x40	; 64
     bee:	82 83       	std	Z+2, r24	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     bf0:	10 92 32 3e 	sts	0x3E32, r1
     bf4:	10 92 47 3e 	sts	0x3E47, r1
     bf8:	10 92 ac 21 	sts	0x21AC, r1
     bfc:	10 92 30 3e 	sts	0x3E30, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
     c00:	8f ef       	ldi	r24, 0xFF	; 255
     c02:	61 e0       	ldi	r22, 0x01	; 1
     c04:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     c08:	8f ef       	ldi	r24, 0xFF	; 255
     c0a:	61 e0       	ldi	r22, 0x01	; 1
     c0c:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     c10:	8f ef       	ldi	r24, 0xFF	; 255
     c12:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>
		ADC_POWER_ON = TRUE;
     c16:	81 e0       	ldi	r24, 0x01	; 1
     c18:	80 93 33 3e 	sts	0x3E33, r24
     c1c:	38 c0       	rjmp	.+112    	; 0xc8e <ADCPower+0x11a>

	} else if(!on && ADC_POWER_ON) {
     c1e:	80 91 33 3e 	lds	r24, 0x3E33
     c22:	88 23       	and	r24, r24
     c24:	a1 f1       	breq	.+104    	; 0xc8e <ADCPower+0x11a>
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     c26:	00 e0       	ldi	r16, 0x00	; 0
     c28:	16 e0       	ldi	r17, 0x06	; 6
     c2a:	7e ed       	ldi	r23, 0xDE	; 222
     c2c:	d8 01       	movw	r26, r16
     c2e:	16 96       	adiw	r26, 0x06	; 6
     c30:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     c32:	a0 e2       	ldi	r26, 0x20	; 32
     c34:	b6 e0       	ldi	r27, 0x06	; 6
     c36:	4e e0       	ldi	r20, 0x0E	; 14
     c38:	16 96       	adiw	r26, 0x06	; 6
     c3a:	4c 93       	st	X, r20
     c3c:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     c3e:	20 e4       	ldi	r18, 0x40	; 64
     c40:	36 e0       	ldi	r19, 0x06	; 6
     c42:	63 e0       	ldi	r22, 0x03	; 3
     c44:	e9 01       	movw	r28, r18
     c46:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     c48:	c0 e8       	ldi	r28, 0x80	; 128
     c4a:	d6 e0       	ldi	r29, 0x06	; 6
     c4c:	50 e1       	ldi	r21, 0x10	; 16
     c4e:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     c50:	80 ea       	ldi	r24, 0xA0	; 160
     c52:	96 e0       	ldi	r25, 0x06	; 6
     c54:	fc 01       	movw	r30, r24
     c56:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     c58:	f8 01       	movw	r30, r16
     c5a:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     c5c:	12 96       	adiw	r26, 0x02	; 2
     c5e:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     c60:	d9 01       	movw	r26, r18
     c62:	12 96       	adiw	r26, 0x02	; 2
     c64:	6c 93       	st	X, r22
     c66:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
     c68:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     c6a:	ec 01       	movw	r28, r24
     c6c:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     c6e:	80 e4       	ldi	r24, 0x40	; 64
     c70:	12 96       	adiw	r26, 0x02	; 2
     c72:	8c 93       	st	X, r24
     c74:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     c76:	10 92 32 3e 	sts	0x3E32, r1
     c7a:	10 92 47 3e 	sts	0x3E47, r1
     c7e:	10 92 ac 21 	sts	0x21AC, r1
     c82:	10 92 30 3e 	sts	0x3E30, r1
		channelStatus = 0x00;
     c86:	10 92 31 3e 	sts	0x3E31, r1
		ADC_POWER_ON = FALSE;
     c8a:	10 92 33 3e 	sts	0x3E33, r1
	}
}
     c8e:	df 91       	pop	r29
     c90:	cf 91       	pop	r28
     c92:	1f 91       	pop	r17
     c94:	0f 91       	pop	r16
     c96:	08 95       	ret

00000c98 <DeciToString>:
	PORTC.OUTCLR = PIN4_bm;
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;

}

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
     c98:	2f 92       	push	r2
     c9a:	3f 92       	push	r3
     c9c:	4f 92       	push	r4
     c9e:	5f 92       	push	r5
     ca0:	6f 92       	push	r6
     ca2:	7f 92       	push	r7
     ca4:	8f 92       	push	r8
     ca6:	9f 92       	push	r9
     ca8:	af 92       	push	r10
     caa:	bf 92       	push	r11
     cac:	cf 92       	push	r12
     cae:	df 92       	push	r13
     cb0:	ef 92       	push	r14
     cb2:	ff 92       	push	r15
     cb4:	0f 93       	push	r16
     cb6:	1f 93       	push	r17
     cb8:	cf 93       	push	r28
     cba:	df 93       	push	r29
     cbc:	cd b7       	in	r28, 0x3d	; 61
     cbe:	de b7       	in	r29, 0x3e	; 62
     cc0:	64 97       	sbiw	r28, 0x14	; 20
     cc2:	cd bf       	out	0x3d, r28	; 61
     cc4:	de bf       	out	0x3e, r29	; 62
     cc6:	2a 01       	movw	r4, r20
     cc8:	3b 01       	movw	r6, r22
     cca:	89 01       	movw	r16, r18
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
     ccc:	f9 01       	movw	r30, r18
     cce:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
     cd0:	41 15       	cp	r20, r1
     cd2:	51 05       	cpc	r21, r1
     cd4:	61 05       	cpc	r22, r1
     cd6:	71 05       	cpc	r23, r1
     cd8:	09 f4       	brne	.+2      	; 0xcdc <DeciToString+0x44>
     cda:	4d c0       	rjmp	.+154    	; 0xd76 <DeciToString+0xde>
     cdc:	88 2e       	mov	r8, r24
     cde:	99 2e       	mov	r9, r25
     ce0:	cc 24       	eor	r12, r12
     ce2:	dd 24       	eor	r13, r13
     ce4:	76 01       	movw	r14, r12
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
     ce6:	5e 01       	movw	r10, r28
     ce8:	08 94       	sec
     cea:	a1 1c       	adc	r10, r1
     cec:	b1 1c       	adc	r11, r1
     cee:	0f 2e       	mov	r0, r31
     cf0:	f0 e0       	ldi	r31, 0x00	; 0
     cf2:	2f 2e       	mov	r2, r31
     cf4:	f0 e2       	ldi	r31, 0x20	; 32
     cf6:	3f 2e       	mov	r3, r31
     cf8:	f0 2d       	mov	r31, r0
     cfa:	f4 01       	movw	r30, r8
     cfc:	81 91       	ld	r24, Z+
     cfe:	91 91       	ld	r25, Z+
     d00:	a1 91       	ld	r26, Z+
     d02:	b1 91       	ld	r27, Z+
     d04:	4f 01       	movw	r8, r30
     d06:	2d b7       	in	r18, 0x3d	; 61
     d08:	3e b7       	in	r19, 0x3e	; 62
     d0a:	28 50       	subi	r18, 0x08	; 8
     d0c:	30 40       	sbci	r19, 0x00	; 0
     d0e:	2d bf       	out	0x3d, r18	; 61
     d10:	3e bf       	out	0x3e, r19	; 62
     d12:	2f 5f       	subi	r18, 0xFF	; 255
     d14:	3f 4f       	sbci	r19, 0xFF	; 255
     d16:	ed b7       	in	r30, 0x3d	; 61
     d18:	fe b7       	in	r31, 0x3e	; 62
     d1a:	a1 82       	std	Z+1, r10	; 0x01
     d1c:	b2 82       	std	Z+2, r11	; 0x02
     d1e:	f9 01       	movw	r30, r18
     d20:	22 82       	std	Z+2, r2	; 0x02
     d22:	33 82       	std	Z+3, r3	; 0x03
     d24:	84 83       	std	Z+4, r24	; 0x04
     d26:	95 83       	std	Z+5, r25	; 0x05
     d28:	a6 83       	std	Z+6, r26	; 0x06
     d2a:	b7 83       	std	Z+7, r27	; 0x07
     d2c:	0e 94 3c 3a 	call	0x7478	; 0x7478 <sprintf>
		strcat(ReturnString,b);
     d30:	2d b7       	in	r18, 0x3d	; 61
     d32:	3e b7       	in	r19, 0x3e	; 62
     d34:	28 5f       	subi	r18, 0xF8	; 248
     d36:	3f 4f       	sbci	r19, 0xFF	; 255
     d38:	2d bf       	out	0x3d, r18	; 61
     d3a:	3e bf       	out	0x3e, r19	; 62
     d3c:	c8 01       	movw	r24, r16
     d3e:	b5 01       	movw	r22, r10
     d40:	0e 94 fe 39 	call	0x73fc	; 0x73fc <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
     d44:	a0 2f       	mov	r26, r16
     d46:	b1 2f       	mov	r27, r17
     d48:	fd 01       	movw	r30, r26
     d4a:	01 90       	ld	r0, Z+
     d4c:	00 20       	and	r0, r0
     d4e:	e9 f7       	brne	.-6      	; 0xd4a <DeciToString+0xb2>
     d50:	31 97       	sbiw	r30, 0x01	; 1
     d52:	ea 1b       	sub	r30, r26
     d54:	fb 0b       	sbc	r31, r27
     d56:	e0 0f       	add	r30, r16
     d58:	f1 1f       	adc	r31, r17
     d5a:	8a e0       	ldi	r24, 0x0A	; 10
     d5c:	90 e0       	ldi	r25, 0x00	; 0
     d5e:	80 83       	st	Z, r24
     d60:	91 83       	std	Z+1, r25	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
     d62:	08 94       	sec
     d64:	c1 1c       	adc	r12, r1
     d66:	d1 1c       	adc	r13, r1
     d68:	e1 1c       	adc	r14, r1
     d6a:	f1 1c       	adc	r15, r1
     d6c:	c4 14       	cp	r12, r4
     d6e:	d5 04       	cpc	r13, r5
     d70:	e6 04       	cpc	r14, r6
     d72:	f7 04       	cpc	r15, r7
     d74:	11 f6       	brne	.-124    	; 0xcfa <DeciToString+0x62>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}
}
     d76:	64 96       	adiw	r28, 0x14	; 20
     d78:	cd bf       	out	0x3d, r28	; 61
     d7a:	de bf       	out	0x3e, r29	; 62
     d7c:	df 91       	pop	r29
     d7e:	cf 91       	pop	r28
     d80:	1f 91       	pop	r17
     d82:	0f 91       	pop	r16
     d84:	ff 90       	pop	r15
     d86:	ef 90       	pop	r14
     d88:	df 90       	pop	r13
     d8a:	cf 90       	pop	r12
     d8c:	bf 90       	pop	r11
     d8e:	af 90       	pop	r10
     d90:	9f 90       	pop	r9
     d92:	8f 90       	pop	r8
     d94:	7f 90       	pop	r7
     d96:	6f 90       	pop	r6
     d98:	5f 90       	pop	r5
     d9a:	4f 90       	pop	r4
     d9c:	3f 90       	pop	r3
     d9e:	2f 90       	pop	r2
     da0:	08 95       	ret

00000da2 <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
     da2:	e0 ec       	ldi	r30, 0xC0	; 192
     da4:	f8 e0       	ldi	r31, 0x08	; 8
     da6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
     da8:	82 81       	ldd	r24, Z+2	; 0x02
     daa:	88 23       	and	r24, r24
     dac:	ec f7       	brge	.-6      	; 0xda8 <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
     dae:	e0 ec       	ldi	r30, 0xC0	; 192
     db0:	f8 e0       	ldi	r31, 0x08	; 8
     db2:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
     db4:	08 95       	ret

00000db6 <main>:

#include "E-000001-000009_firmware_rev_1_0.h"

volatile uint8_t TimedOut = 0;

int main(){
     db6:	cf 93       	push	r28
     db8:	df 93       	push	r29
     dba:	cd b7       	in	r28, 0x3d	; 61
     dbc:	de b7       	in	r29, 0x3e	; 62
     dbe:	6e 97       	sbiw	r28, 0x1e	; 30
     dc0:	cd bf       	out	0x3d, r28	; 61
     dc2:	de bf       	out	0x3e, r29	; 62
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t ack = 0;
     dc4:	19 82       	std	Y+1, r1	; 0x01
     dc6:	1a 82       	std	Y+2, r1	; 0x02
	volatile uint8_t RawGain;
	uint16_t freq = 2000;
	volatile uint32_t samples = 0;
     dc8:	1c 82       	std	Y+4, r1	; 0x04
     dca:	1d 82       	std	Y+5, r1	; 0x05
     dcc:	1e 82       	std	Y+6, r1	; 0x06
     dce:	1f 82       	std	Y+7, r1	; 0x07
	DataAvailable = 0;
     dd0:	10 92 48 3e 	sts	0x3E48, r1
	ADC_Sampling_Finished = 1;
     dd4:	01 e0       	ldi	r16, 0x01	; 1
     dd6:	00 93 a7 50 	sts	0x50A7, r16
	uint8_t RadioMessageBuffer[20];
	unsigned char ofile[] = {'o','u','t','p','u','t'};
	set_32MHz();
     dda:	0e 94 3c 03 	call	0x678	; 0x678 <set_32MHz>
	chb_init();
     dde:	0e 94 fe 19 	call	0x33fc	; 0x33fc <chb_init>
	chb_set_channel(1);
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	0e 94 6d 1d 	call	0x3ada	; 0x3ada <chb_set_channel>
	chb_set_short_addr(0x0001);
     de8:	81 e0       	ldi	r24, 0x01	; 1
     dea:	90 e0       	ldi	r25, 0x00	; 0
     dec:	0e 94 21 1c 	call	0x3842	; 0x3842 <chb_set_short_addr>
	pcb_t* pcb = chb_get_pcb();
     df0:	0e 94 1f 1a 	call	0x343e	; 0x343e <chb_get_pcb>
     df4:	3c 01       	movw	r6, r24
	//SD_init();
	//getBootSectorData();
	
	//setup timeout timer
	//approx 2 seconds to wait (using largest prescaler of 1024)
	TCE0.PER = 4000;
     df6:	e0 e0       	ldi	r30, 0x00	; 0
     df8:	fa e0       	ldi	r31, 0x0A	; 10
     dfa:	80 ea       	ldi	r24, 0xA0	; 160
     dfc:	9f e0       	ldi	r25, 0x0F	; 15
     dfe:	86 a3       	lds	r24, 0x56
     e00:	97 a3       	lds	r25, 0x57
	TCE0.CTRLFSET = 0x08;
     e02:	88 e0       	ldi	r24, 0x08	; 8
     e04:	81 87       	std	Z+9, r24	; 0x09
	TCE0.INTCTRLA = TC_OVFINTLVL_LO_gc;
     e06:	06 83       	std	Z+6, r16	; 0x06
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
     e08:	e0 ea       	ldi	r30, 0xA0	; 160
     e0a:	f0 e0       	ldi	r31, 0x00	; 0
     e0c:	82 81       	ldd	r24, Z+2	; 0x02
     e0e:	81 60       	ori	r24, 0x01	; 1
     e10:	82 83       	std	Z+2, r24	; 0x02
	sei();
     e12:	78 94       	sei
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t ack = 0;
	volatile uint8_t RawGain;
	uint16_t freq = 2000;
     e14:	0f 2e       	mov	r0, r31
     e16:	f0 ed       	ldi	r31, 0xD0	; 208
     e18:	2f 2e       	mov	r2, r31
     e1a:	f7 e0       	ldi	r31, 0x07	; 7
     e1c:	3f 2e       	mov	r3, r31
     e1e:	f0 2d       	mov	r31, r0
volatile uint8_t TimedOut = 0;

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
     e20:	1e 8e       	std	Y+30, r1	; 0x1e
									while(chb_write(0x0000,FRAMReadBuffer,100) != CHB_SUCCESS);
									i += 100;
								}
								else{
									readFRAM(samples*4 - i,(FRAMAddress-(samples*4))+i);
									while(chb_write(0x0000,FRAMReadBuffer,samples*4 - i) != CHB_SUCCESS);
     e22:	8d ea       	ldi	r24, 0xAD	; 173
     e24:	91 e2       	ldi	r25, 0x21	; 33
     e26:	58 2e       	mov	r5, r24
     e28:	49 2e       	mov	r4, r25
	TCE0.INTCTRLA = TC_OVFINTLVL_LO_gc;
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
	sei();

	while(1){
		if(pcb->data_rcv){
     e2a:	d3 01       	movw	r26, r6
     e2c:	13 96       	adiw	r26, 0x03	; 3
     e2e:	8c 91       	ld	r24, X
     e30:	13 97       	sbiw	r26, 0x03	; 3
     e32:	88 23       	and	r24, r24
     e34:	d1 f3       	breq	.-12     	; 0xe2a <main+0x74>
			//read the data
			length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
     e36:	ce 01       	movw	r24, r28
     e38:	08 96       	adiw	r24, 0x08	; 8
     e3a:	0e 94 c2 1a 	call	0x3584	; 0x3584 <chb_read>
			//length should be >1 for setting gain/freq commands: the value is likely sent in a separate message
				switch ( RadioMessageBuffer[0])
     e3e:	88 85       	ldd	r24, Y+8	; 0x08
     e40:	82 35       	cpi	r24, 0x52	; 82
     e42:	71 f0       	breq	.+28     	; 0xe60 <main+0xaa>
     e44:	83 35       	cpi	r24, 0x53	; 83
     e46:	30 f4       	brcc	.+12     	; 0xe54 <main+0x9e>
     e48:	86 34       	cpi	r24, 0x46	; 70
     e4a:	09 f4       	brne	.+2      	; 0xe4e <main+0x98>
     e4c:	89 c0       	rjmp	.+274    	; 0xf60 <main+0x1aa>
     e4e:	87 34       	cpi	r24, 0x47	; 71
     e50:	61 f7       	brne	.-40     	; 0xe2a <main+0x74>
     e52:	4a c0       	rjmp	.+148    	; 0xee8 <main+0x132>
     e54:	83 35       	cpi	r24, 0x53	; 83
     e56:	09 f4       	brne	.+2      	; 0xe5a <main+0xa4>
     e58:	91 c0       	rjmp	.+290    	; 0xf7c <main+0x1c6>
     e5a:	84 35       	cpi	r24, 0x54	; 84
     e5c:	31 f7       	brne	.-52     	; 0xe2a <main+0x74>
     e5e:	a0 c0       	rjmp	.+320    	; 0xfa0 <main+0x1ea>
				{
				case 'R':
					//collect data if the ADC is not collecting any data right now
					if(ADC_Sampling_Finished){
     e60:	80 91 a7 50 	lds	r24, 0x50A7
     e64:	88 23       	and	r24, r24
     e66:	a1 f1       	breq	.+104    	; 0xed0 <main+0x11a>
						//CO_collectADC(ADC_CH_1_gc, gain, freq, 10000, (int32_t*)FRAMReadBuffer, FR_READ_BUFFER_SIZE/4, TRUE);
						CO_collectSeismic1Channel(ADC_CH_8_gc, gain, freq, 6, FALSE, 1, 2, 3, 4, 10000,(int32_t*)FRAMReadBuffer, FR_READ_BUFFER_SIZE/4, TRUE);
     e68:	ed b7       	in	r30, 0x3d	; 61
     e6a:	fe b7       	in	r31, 0x3e	; 62
     e6c:	37 97       	sbiw	r30, 0x07	; 7
     e6e:	ed bf       	out	0x3d, r30	; 61
     e70:	fe bf       	out	0x3e, r31	; 62
     e72:	31 96       	adiw	r30, 0x01	; 1
     e74:	80 e1       	ldi	r24, 0x10	; 16
     e76:	97 e2       	ldi	r25, 0x27	; 39
     e78:	ad b7       	in	r26, 0x3d	; 61
     e7a:	be b7       	in	r27, 0x3e	; 62
     e7c:	11 96       	adiw	r26, 0x01	; 1
     e7e:	8d 93       	st	X+, r24
     e80:	9c 93       	st	X, r25
     e82:	12 97       	sbiw	r26, 0x02	; 2
     e84:	ad ea       	ldi	r26, 0xAD	; 173
     e86:	b1 e2       	ldi	r27, 0x21	; 33
     e88:	a2 83       	std	Z+2, r26	; 0x02
     e8a:	b3 83       	std	Z+3, r27	; 0x03
     e8c:	8c e1       	ldi	r24, 0x1C	; 28
     e8e:	97 e0       	ldi	r25, 0x07	; 7
     e90:	84 83       	std	Z+4, r24	; 0x04
     e92:	95 83       	std	Z+5, r25	; 0x05
     e94:	81 e0       	ldi	r24, 0x01	; 1
     e96:	86 83       	std	Z+6, r24	; 0x06
     e98:	87 e0       	ldi	r24, 0x07	; 7
     e9a:	6e 8d       	ldd	r22, Y+30	; 0x1e
     e9c:	a1 01       	movw	r20, r2
     e9e:	26 e0       	ldi	r18, 0x06	; 6
     ea0:	00 e0       	ldi	r16, 0x00	; 0
     ea2:	ee 24       	eor	r14, r14
     ea4:	ff 24       	eor	r15, r15
     ea6:	e3 94       	inc	r14
     ea8:	cc 24       	eor	r12, r12
     eaa:	dd 24       	eor	r13, r13
     eac:	68 94       	set
     eae:	c1 f8       	bld	r12, 1
     eb0:	0f 2e       	mov	r0, r31
     eb2:	f3 e0       	ldi	r31, 0x03	; 3
     eb4:	af 2e       	mov	r10, r31
     eb6:	bb 24       	eor	r11, r11
     eb8:	f0 2d       	mov	r31, r0
     eba:	88 24       	eor	r8, r8
     ebc:	99 24       	eor	r9, r9
     ebe:	68 94       	set
     ec0:	82 f8       	bld	r8, 2
     ec2:	0e 94 d4 16 	call	0x2da8	; 0x2da8 <CO_collectSeismic1Channel>
     ec6:	ad b7       	in	r26, 0x3d	; 61
     ec8:	be b7       	in	r27, 0x3e	; 62
     eca:	17 96       	adiw	r26, 0x07	; 7
     ecc:	ad bf       	out	0x3d, r26	; 61
     ece:	be bf       	out	0x3e, r27	; 62
					}
					//send acknowledgment
					chb_write(0x0000,(uint8_t*)(&ack),2);						
     ed0:	80 e0       	ldi	r24, 0x00	; 0
     ed2:	90 e0       	ldi	r25, 0x00	; 0
     ed4:	be 01       	movw	r22, r28
     ed6:	6f 5f       	subi	r22, 0xFF	; 255
     ed8:	7f 4f       	sbci	r23, 0xFF	; 255
     eda:	22 e0       	ldi	r18, 0x02	; 2
     edc:	30 e0       	ldi	r19, 0x00	; 0
     ede:	40 e0       	ldi	r20, 0x00	; 0
     ee0:	50 e0       	ldi	r21, 0x00	; 0
     ee2:	0e 94 22 1a 	call	0x3444	; 0x3444 <chb_write>
					break;
     ee6:	a1 cf       	rjmp	.-190    	; 0xe2a <main+0x74>
				case 'G':
					//while(!pcb->data_rcv);
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set gain to what is specified
					RawGain = (uint8_t)(*(int32_t*)(RadioMessageBuffer+1));
     ee8:	89 85       	ldd	r24, Y+9	; 0x09
     eea:	8b 83       	std	Y+3, r24	; 0x03
					switch(RawGain){
     eec:	8b 81       	ldd	r24, Y+3	; 0x03
     eee:	88 30       	cpi	r24, 0x08	; 8
     ef0:	d9 f0       	breq	.+54     	; 0xf28 <main+0x172>
     ef2:	89 30       	cpi	r24, 0x09	; 9
     ef4:	38 f4       	brcc	.+14     	; 0xf04 <main+0x14e>
     ef6:	82 30       	cpi	r24, 0x02	; 2
     ef8:	89 f0       	breq	.+34     	; 0xf1c <main+0x166>
     efa:	84 30       	cpi	r24, 0x04	; 4
     efc:	91 f0       	breq	.+36     	; 0xf22 <main+0x16c>
     efe:	81 30       	cpi	r24, 0x01	; 1
     f00:	19 f5       	brne	.+70     	; 0xf48 <main+0x192>
     f02:	21 c0       	rjmp	.+66     	; 0xf46 <main+0x190>
     f04:	80 32       	cpi	r24, 0x20	; 32
     f06:	b1 f0       	breq	.+44     	; 0xf34 <main+0x17e>
     f08:	81 32       	cpi	r24, 0x21	; 33
     f0a:	18 f4       	brcc	.+6      	; 0xf12 <main+0x15c>
     f0c:	80 31       	cpi	r24, 0x10	; 16
     f0e:	e1 f4       	brne	.+56     	; 0xf48 <main+0x192>
     f10:	0e c0       	rjmp	.+28     	; 0xf2e <main+0x178>
     f12:	80 34       	cpi	r24, 0x40	; 64
     f14:	91 f0       	breq	.+36     	; 0xf3a <main+0x184>
     f16:	80 38       	cpi	r24, 0x80	; 128
     f18:	b9 f4       	brne	.+46     	; 0xf48 <main+0x192>
     f1a:	12 c0       	rjmp	.+36     	; 0xf40 <main+0x18a>
						case 1:
							gain = GAIN_1_gc;
							break;
						case 2:
							gain = GAIN_2_gc;
     f1c:	b1 e0       	ldi	r27, 0x01	; 1
     f1e:	be 8f       	std	Y+30, r27	; 0x1e
							break;
     f20:	13 c0       	rjmp	.+38     	; 0xf48 <main+0x192>
						case 4:
							gain = GAIN_4_gc;
     f22:	e2 e0       	ldi	r30, 0x02	; 2
     f24:	ee 8f       	std	Y+30, r30	; 0x1e
							break;
     f26:	10 c0       	rjmp	.+32     	; 0xf48 <main+0x192>
						case 8:
							gain = GAIN_8_gc;
     f28:	f3 e0       	ldi	r31, 0x03	; 3
     f2a:	fe 8f       	std	Y+30, r31	; 0x1e
							break;
     f2c:	0d c0       	rjmp	.+26     	; 0xf48 <main+0x192>
						case 16:
							gain = GAIN_16_gc;
     f2e:	84 e0       	ldi	r24, 0x04	; 4
     f30:	8e 8f       	std	Y+30, r24	; 0x1e
							break;
     f32:	0a c0       	rjmp	.+20     	; 0xf48 <main+0x192>
						case 32:
							gain = GAIN_32_gc;
     f34:	95 e0       	ldi	r25, 0x05	; 5
     f36:	9e 8f       	std	Y+30, r25	; 0x1e
							break;
     f38:	07 c0       	rjmp	.+14     	; 0xf48 <main+0x192>
						case 64:
							gain = GAIN_64_gc;
     f3a:	a6 e0       	ldi	r26, 0x06	; 6
     f3c:	ae 8f       	std	Y+30, r26	; 0x1e
							break;
     f3e:	04 c0       	rjmp	.+8      	; 0xf48 <main+0x192>
						case 128:
							gain = GAIN_128_gc;
     f40:	b7 e0       	ldi	r27, 0x07	; 7
     f42:	be 8f       	std	Y+30, r27	; 0x1e
							break;
     f44:	01 c0       	rjmp	.+2      	; 0xf48 <main+0x192>
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set gain to what is specified
					RawGain = (uint8_t)(*(int32_t*)(RadioMessageBuffer+1));
					switch(RawGain){
						case 1:
							gain = GAIN_1_gc;
     f46:	1e 8e       	std	Y+30, r1	; 0x1e
						default:
							//chb_write(0x0000,(uint8_t*)"invalid gain",strlen("invalid gain"));
							break;
					}
					//send acknowledgment
					chb_write(0x0000,(uint8_t*)(&ack),2);					
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	90 e0       	ldi	r25, 0x00	; 0
     f4c:	be 01       	movw	r22, r28
     f4e:	6f 5f       	subi	r22, 0xFF	; 255
     f50:	7f 4f       	sbci	r23, 0xFF	; 255
     f52:	22 e0       	ldi	r18, 0x02	; 2
     f54:	30 e0       	ldi	r19, 0x00	; 0
     f56:	40 e0       	ldi	r20, 0x00	; 0
     f58:	50 e0       	ldi	r21, 0x00	; 0
     f5a:	0e 94 22 1a 	call	0x3444	; 0x3444 <chb_write>
					break;
     f5e:	65 cf       	rjmp	.-310    	; 0xe2a <main+0x74>
				case 'F':

					//while(!pcb->data_rcv);
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set sampling frequency to what is specified
					freq = (uint16_t)(*(int32_t*)(RadioMessageBuffer+1));
     f60:	29 84       	ldd	r2, Y+9	; 0x09
     f62:	3a 84       	ldd	r3, Y+10	; 0x0a
					//send acknowledgment
					chb_write(0x0000,(uint8_t*)(&ack),2);
     f64:	80 e0       	ldi	r24, 0x00	; 0
     f66:	90 e0       	ldi	r25, 0x00	; 0
     f68:	be 01       	movw	r22, r28
     f6a:	6f 5f       	subi	r22, 0xFF	; 255
     f6c:	7f 4f       	sbci	r23, 0xFF	; 255
     f6e:	22 e0       	ldi	r18, 0x02	; 2
     f70:	30 e0       	ldi	r19, 0x00	; 0
     f72:	40 e0       	ldi	r20, 0x00	; 0
     f74:	50 e0       	ldi	r21, 0x00	; 0
     f76:	0e 94 22 1a 	call	0x3444	; 0x3444 <chb_write>
					break;
     f7a:	57 cf       	rjmp	.-338    	; 0xe2a <main+0x74>
				case 'S':
					//stop the ADC if it is not already
					if(!ADC_Sampling_Finished){
     f7c:	80 91 a7 50 	lds	r24, 0x50A7
     f80:	88 23       	and	r24, r24
     f82:	11 f4       	brne	.+4      	; 0xf88 <main+0x1d2>
						ADC_Stop_Sampling();
     f84:	0e 94 ae 0c 	call	0x195c	; 0x195c <ADC_Stop_Sampling>
					}
					//otherwise, the ADC has finished sampling on its own and the data is ready to be transmitted
					//send acknowledgment
					chb_write(0x0000,(uint8_t*)(&ack),2);
     f88:	80 e0       	ldi	r24, 0x00	; 0
     f8a:	90 e0       	ldi	r25, 0x00	; 0
     f8c:	be 01       	movw	r22, r28
     f8e:	6f 5f       	subi	r22, 0xFF	; 255
     f90:	7f 4f       	sbci	r23, 0xFF	; 255
     f92:	22 e0       	ldi	r18, 0x02	; 2
     f94:	30 e0       	ldi	r19, 0x00	; 0
     f96:	40 e0       	ldi	r20, 0x00	; 0
     f98:	50 e0       	ldi	r21, 0x00	; 0
     f9a:	0e 94 22 1a 	call	0x3444	; 0x3444 <chb_write>
					break;
     f9e:	45 cf       	rjmp	.-374    	; 0xe2a <main+0x74>
				case 'T':
					if(ADC_Sampling_Finished && DataAvailable){
     fa0:	80 91 a7 50 	lds	r24, 0x50A7
     fa4:	88 23       	and	r24, r24
     fa6:	09 f4       	brne	.+2      	; 0xfaa <main+0x1f4>
     fa8:	43 c1       	rjmp	.+646    	; 0x1230 <main+0x47a>
     faa:	80 91 48 3e 	lds	r24, 0x3E48
     fae:	88 23       	and	r24, r24
     fb0:	09 f4       	brne	.+2      	; 0xfb4 <main+0x1fe>
     fb2:	3e c1       	rjmp	.+636    	; 0x1230 <main+0x47a>
						//get number of data points collected
						samples = ADC_Get_Num_Samples();
     fb4:	0e 94 cf 0c 	call	0x199e	; 0x199e <ADC_Get_Num_Samples>
     fb8:	a0 e0       	ldi	r26, 0x00	; 0
     fba:	b0 e0       	ldi	r27, 0x00	; 0
     fbc:	8c 83       	std	Y+4, r24	; 0x04
     fbe:	9d 83       	std	Y+5, r25	; 0x05
     fc0:	ae 83       	std	Y+6, r26	; 0x06
     fc2:	bf 83       	std	Y+7, r27	; 0x07
						if(samples > 0){	
     fc4:	8c 81       	ldd	r24, Y+4	; 0x04
     fc6:	9d 81       	ldd	r25, Y+5	; 0x05
     fc8:	ae 81       	ldd	r26, Y+6	; 0x06
     fca:	bf 81       	ldd	r27, Y+7	; 0x07
     fcc:	00 97       	sbiw	r24, 0x00	; 0
     fce:	a1 05       	cpc	r26, r1
     fd0:	b1 05       	cpc	r27, r1
     fd2:	09 f4       	brne	.+2      	; 0xfd6 <main+0x220>
     fd4:	20 c1       	rjmp	.+576    	; 0x1216 <main+0x460>
							uint16_t NumMessages = ((samples*4)/CHB_MAX_PAYLOAD);
     fd6:	8c 81       	ldd	r24, Y+4	; 0x04
     fd8:	9d 81       	ldd	r25, Y+5	; 0x05
     fda:	ae 81       	ldd	r26, Y+6	; 0x06
     fdc:	bf 81       	ldd	r27, Y+7	; 0x07
     fde:	bc 01       	movw	r22, r24
     fe0:	cd 01       	movw	r24, r26
     fe2:	66 0f       	add	r22, r22
     fe4:	77 1f       	adc	r23, r23
     fe6:	88 1f       	adc	r24, r24
     fe8:	99 1f       	adc	r25, r25
     fea:	66 0f       	add	r22, r22
     fec:	77 1f       	adc	r23, r23
     fee:	88 1f       	adc	r24, r24
     ff0:	99 1f       	adc	r25, r25
     ff2:	0f 2e       	mov	r0, r31
     ff4:	f4 e6       	ldi	r31, 0x64	; 100
     ff6:	cf 2e       	mov	r12, r31
     ff8:	f0 e0       	ldi	r31, 0x00	; 0
     ffa:	df 2e       	mov	r13, r31
     ffc:	f0 e0       	ldi	r31, 0x00	; 0
     ffe:	ef 2e       	mov	r14, r31
    1000:	f0 e0       	ldi	r31, 0x00	; 0
    1002:	ff 2e       	mov	r15, r31
    1004:	f0 2d       	mov	r31, r0
    1006:	a7 01       	movw	r20, r14
    1008:	96 01       	movw	r18, r12
    100a:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    100e:	89 01       	movw	r16, r18
    1010:	9a 01       	movw	r18, r20
    1012:	58 01       	movw	r10, r16
    1014:	0c 8f       	std	Y+28, r16	; 0x1c
    1016:	1d 8f       	std	Y+29, r17	; 0x1d
							if ((samples*4)%CHB_MAX_PAYLOAD > 0) NumMessages++;
    1018:	8c 81       	ldd	r24, Y+4	; 0x04
    101a:	9d 81       	ldd	r25, Y+5	; 0x05
    101c:	ae 81       	ldd	r26, Y+6	; 0x06
    101e:	bf 81       	ldd	r27, Y+7	; 0x07
    1020:	bc 01       	movw	r22, r24
    1022:	cd 01       	movw	r24, r26
    1024:	66 0f       	add	r22, r22
    1026:	77 1f       	adc	r23, r23
    1028:	88 1f       	adc	r24, r24
    102a:	99 1f       	adc	r25, r25
    102c:	66 0f       	add	r22, r22
    102e:	77 1f       	adc	r23, r23
    1030:	88 1f       	adc	r24, r24
    1032:	99 1f       	adc	r25, r25
    1034:	a7 01       	movw	r20, r14
    1036:	96 01       	movw	r18, r12
    1038:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    103c:	dc 01       	movw	r26, r24
    103e:	cb 01       	movw	r24, r22
    1040:	00 97       	sbiw	r24, 0x00	; 0
    1042:	a1 05       	cpc	r26, r1
    1044:	b1 05       	cpc	r27, r1
    1046:	21 f0       	breq	.+8      	; 0x1050 <main+0x29a>
    1048:	c5 01       	movw	r24, r10
    104a:	01 96       	adiw	r24, 0x01	; 1
    104c:	8c 8f       	std	Y+28, r24	; 0x1c
    104e:	9d 8f       	std	Y+29, r25	; 0x1d
							//start timeout timer
							TCE0.CTRLA = 0x07;
    1050:	87 e0       	ldi	r24, 0x07	; 7
    1052:	e0 e0       	ldi	r30, 0x00	; 0
    1054:	fa e0       	ldi	r31, 0x0A	; 10
    1056:	80 83       	st	Z, r24
							TimedOut = 0;
    1058:	10 92 0e 21 	sts	0x210E, r1
							//send the number of messages the base station should expect after this message
							while(chb_write(0x0000,(uint8_t*)(&NumMessages),2) != CHB_SUCCESS){
    105c:	04 c0       	rjmp	.+8      	; 0x1066 <main+0x2b0>
								if(TimedOut) break;
    105e:	80 91 0e 21 	lds	r24, 0x210E
    1062:	88 23       	and	r24, r24
    1064:	69 f4       	brne	.+26     	; 0x1080 <main+0x2ca>
							if ((samples*4)%CHB_MAX_PAYLOAD > 0) NumMessages++;
							//start timeout timer
							TCE0.CTRLA = 0x07;
							TimedOut = 0;
							//send the number of messages the base station should expect after this message
							while(chb_write(0x0000,(uint8_t*)(&NumMessages),2) != CHB_SUCCESS){
    1066:	80 e0       	ldi	r24, 0x00	; 0
    1068:	90 e0       	ldi	r25, 0x00	; 0
    106a:	be 01       	movw	r22, r28
    106c:	64 5e       	subi	r22, 0xE4	; 228
    106e:	7f 4f       	sbci	r23, 0xFF	; 255
    1070:	22 e0       	ldi	r18, 0x02	; 2
    1072:	30 e0       	ldi	r19, 0x00	; 0
    1074:	40 e0       	ldi	r20, 0x00	; 0
    1076:	50 e0       	ldi	r21, 0x00	; 0
    1078:	0e 94 22 1a 	call	0x3444	; 0x3444 <chb_write>
    107c:	88 23       	and	r24, r24
    107e:	79 f7       	brne	.-34     	; 0x105e <main+0x2a8>
								if(TimedOut) break;
							}
							if(TimedOut){
    1080:	80 91 0e 21 	lds	r24, 0x210E
    1084:	88 23       	and	r24, r24
    1086:	31 f0       	breq	.+12     	; 0x1094 <main+0x2de>
								//stop timeout counter and go back to waiting for command
								TimedOut = 0;
    1088:	10 92 0e 21 	sts	0x210E, r1
								TCE0.CTRLA = 0;
    108c:	a0 e0       	ldi	r26, 0x00	; 0
    108e:	ba e0       	ldi	r27, 0x0A	; 10
    1090:	1c 92       	st	X, r1
								break;
    1092:	cb ce       	rjmp	.-618    	; 0xe2a <main+0x74>
							}
							//reset timeout timer
							TimedOut = 0;
    1094:	10 92 0e 21 	sts	0x210E, r1
							TCE0.CTRLFSET = 0x08;  
    1098:	b8 e0       	ldi	r27, 0x08	; 8
    109a:	b0 93 09 0a 	sts	0x0A09, r27
							//read the data from FRAM and send it
							for(uint16_t i =0; i<(samples*4);){	
    109e:	8c 81       	ldd	r24, Y+4	; 0x04
    10a0:	9d 81       	ldd	r25, Y+5	; 0x05
    10a2:	ae 81       	ldd	r26, Y+6	; 0x06
    10a4:	bf 81       	ldd	r27, Y+7	; 0x07
    10a6:	88 0f       	add	r24, r24
    10a8:	99 1f       	adc	r25, r25
    10aa:	aa 1f       	adc	r26, r26
    10ac:	bb 1f       	adc	r27, r27
    10ae:	88 0f       	add	r24, r24
    10b0:	99 1f       	adc	r25, r25
    10b2:	aa 1f       	adc	r26, r26
    10b4:	bb 1f       	adc	r27, r27
    10b6:	00 97       	sbiw	r24, 0x00	; 0
    10b8:	a1 05       	cpc	r26, r1
    10ba:	b1 05       	cpc	r27, r1
    10bc:	09 f4       	brne	.+2      	; 0x10c0 <main+0x30a>
    10be:	ab c0       	rjmp	.+342    	; 0x1216 <main+0x460>
    10c0:	cc 24       	eor	r12, r12
    10c2:	dd 24       	eor	r13, r13
    10c4:	76 01       	movw	r14, r12
    10c6:	00 e0       	ldi	r16, 0x00	; 0
    10c8:	10 e0       	ldi	r17, 0x00	; 0
								if(samples*4 - i >= 100){
    10ca:	8c 81       	ldd	r24, Y+4	; 0x04
    10cc:	9d 81       	ldd	r25, Y+5	; 0x05
    10ce:	ae 81       	ldd	r26, Y+6	; 0x06
    10d0:	bf 81       	ldd	r27, Y+7	; 0x07
    10d2:	88 0f       	add	r24, r24
    10d4:	99 1f       	adc	r25, r25
    10d6:	aa 1f       	adc	r26, r26
    10d8:	bb 1f       	adc	r27, r27
    10da:	88 0f       	add	r24, r24
    10dc:	99 1f       	adc	r25, r25
    10de:	aa 1f       	adc	r26, r26
    10e0:	bb 1f       	adc	r27, r27
    10e2:	8c 19       	sub	r24, r12
    10e4:	9d 09       	sbc	r25, r13
    10e6:	ae 09       	sbc	r26, r14
    10e8:	bf 09       	sbc	r27, r15
    10ea:	84 36       	cpi	r24, 0x64	; 100
    10ec:	91 05       	cpc	r25, r1
    10ee:	a1 05       	cpc	r26, r1
    10f0:	b1 05       	cpc	r27, r1
    10f2:	18 f1       	brcs	.+70     	; 0x113a <main+0x384>
									readFRAM(100,(FRAMAddress-(samples*4))+i);						
    10f4:	60 91 1e 3e 	lds	r22, 0x3E1E
    10f8:	70 91 1f 3e 	lds	r23, 0x3E1F
    10fc:	8c 81       	ldd	r24, Y+4	; 0x04
    10fe:	9d 81       	ldd	r25, Y+5	; 0x05
    1100:	ae 81       	ldd	r26, Y+6	; 0x06
    1102:	bf 81       	ldd	r27, Y+7	; 0x07
    1104:	88 0f       	add	r24, r24
    1106:	99 1f       	adc	r25, r25
    1108:	88 0f       	add	r24, r24
    110a:	99 1f       	adc	r25, r25
    110c:	68 1b       	sub	r22, r24
    110e:	79 0b       	sbc	r23, r25
    1110:	60 0f       	add	r22, r16
    1112:	71 1f       	adc	r23, r17
    1114:	84 e6       	ldi	r24, 0x64	; 100
    1116:	90 e0       	ldi	r25, 0x00	; 0
    1118:	0e 94 cd 01 	call	0x39a	; 0x39a <readFRAM>
									while(chb_write(0x0000,FRAMReadBuffer,100) != CHB_SUCCESS);
    111c:	80 e0       	ldi	r24, 0x00	; 0
    111e:	90 e0       	ldi	r25, 0x00	; 0
    1120:	65 2d       	mov	r22, r5
    1122:	74 2d       	mov	r23, r4
    1124:	24 e6       	ldi	r18, 0x64	; 100
    1126:	30 e0       	ldi	r19, 0x00	; 0
    1128:	40 e0       	ldi	r20, 0x00	; 0
    112a:	50 e0       	ldi	r21, 0x00	; 0
    112c:	0e 94 22 1a 	call	0x3444	; 0x3444 <chb_write>
    1130:	88 23       	and	r24, r24
    1132:	a1 f7       	brne	.-24     	; 0x111c <main+0x366>
									i += 100;
    1134:	0c 59       	subi	r16, 0x9C	; 156
    1136:	1f 4f       	sbci	r17, 0xFF	; 255
    1138:	42 c0       	rjmp	.+132    	; 0x11be <main+0x408>
								}
								else{
									readFRAM(samples*4 - i,(FRAMAddress-(samples*4))+i);
    113a:	8c 81       	ldd	r24, Y+4	; 0x04
    113c:	9d 81       	ldd	r25, Y+5	; 0x05
    113e:	ae 81       	ldd	r26, Y+6	; 0x06
    1140:	bf 81       	ldd	r27, Y+7	; 0x07
    1142:	e0 91 1e 3e 	lds	r30, 0x3E1E
    1146:	f0 91 1f 3e 	lds	r31, 0x3E1F
    114a:	4c 81       	ldd	r20, Y+4	; 0x04
    114c:	5d 81       	ldd	r21, Y+5	; 0x05
    114e:	6e 81       	ldd	r22, Y+6	; 0x06
    1150:	7f 81       	ldd	r23, Y+7	; 0x07
    1152:	9c 01       	movw	r18, r24
    1154:	22 0f       	add	r18, r18
    1156:	33 1f       	adc	r19, r19
    1158:	22 0f       	add	r18, r18
    115a:	33 1f       	adc	r19, r19
    115c:	ca 01       	movw	r24, r20
    115e:	88 0f       	add	r24, r24
    1160:	99 1f       	adc	r25, r25
    1162:	88 0f       	add	r24, r24
    1164:	99 1f       	adc	r25, r25
    1166:	bf 01       	movw	r22, r30
    1168:	68 1b       	sub	r22, r24
    116a:	79 0b       	sbc	r23, r25
    116c:	60 0f       	add	r22, r16
    116e:	71 1f       	adc	r23, r17
    1170:	c9 01       	movw	r24, r18
    1172:	80 1b       	sub	r24, r16
    1174:	91 0b       	sbc	r25, r17
    1176:	0e 94 cd 01 	call	0x39a	; 0x39a <readFRAM>
									while(chb_write(0x0000,FRAMReadBuffer,samples*4 - i) != CHB_SUCCESS);
    117a:	8c 81       	ldd	r24, Y+4	; 0x04
    117c:	9d 81       	ldd	r25, Y+5	; 0x05
    117e:	ae 81       	ldd	r26, Y+6	; 0x06
    1180:	bf 81       	ldd	r27, Y+7	; 0x07
    1182:	88 0f       	add	r24, r24
    1184:	99 1f       	adc	r25, r25
    1186:	aa 1f       	adc	r26, r26
    1188:	bb 1f       	adc	r27, r27
    118a:	88 0f       	add	r24, r24
    118c:	99 1f       	adc	r25, r25
    118e:	aa 1f       	adc	r26, r26
    1190:	bb 1f       	adc	r27, r27
    1192:	9c 01       	movw	r18, r24
    1194:	ad 01       	movw	r20, r26
    1196:	2c 19       	sub	r18, r12
    1198:	3d 09       	sbc	r19, r13
    119a:	4e 09       	sbc	r20, r14
    119c:	5f 09       	sbc	r21, r15
    119e:	80 e0       	ldi	r24, 0x00	; 0
    11a0:	90 e0       	ldi	r25, 0x00	; 0
    11a2:	65 2d       	mov	r22, r5
    11a4:	74 2d       	mov	r23, r4
    11a6:	0e 94 22 1a 	call	0x3444	; 0x3444 <chb_write>
    11aa:	88 23       	and	r24, r24
    11ac:	31 f7       	brne	.-52     	; 0x117a <main+0x3c4>
									i += samples*4 - i;
    11ae:	0c 81       	ldd	r16, Y+4	; 0x04
    11b0:	1d 81       	ldd	r17, Y+5	; 0x05
    11b2:	2e 81       	ldd	r18, Y+6	; 0x06
    11b4:	3f 81       	ldd	r19, Y+7	; 0x07
    11b6:	00 0f       	add	r16, r16
    11b8:	11 1f       	adc	r17, r17
    11ba:	00 0f       	add	r16, r16
    11bc:	11 1f       	adc	r17, r17
								}
								//reset timeout timer
								TimedOut = 0;
    11be:	10 92 0e 21 	sts	0x210E, r1
								TCE0.CTRLFSET = 0x08;
    11c2:	e8 e0       	ldi	r30, 0x08	; 8
    11c4:	e0 93 09 0a 	sts	0x0A09, r30
    11c8:	f3 01       	movw	r30, r6
								while(!pcb->data_rcv){
    11ca:	04 c0       	rjmp	.+8      	; 0x11d4 <main+0x41e>
									//break if timed out waiting for response
									if(TimedOut) break;
    11cc:	80 91 0e 21 	lds	r24, 0x210E
    11d0:	88 23       	and	r24, r24
    11d2:	19 f4       	brne	.+6      	; 0x11da <main+0x424>
									i += samples*4 - i;
								}
								//reset timeout timer
								TimedOut = 0;
								TCE0.CTRLFSET = 0x08;
								while(!pcb->data_rcv){
    11d4:	83 81       	ldd	r24, Z+3	; 0x03
    11d6:	88 23       	and	r24, r24
    11d8:	c9 f3       	breq	.-14     	; 0x11cc <main+0x416>
    11da:	3f 01       	movw	r6, r30
									//break if timed out waiting for response
									if(TimedOut) break;
								}
								if(TimedOut) break;		
    11dc:	80 91 0e 21 	lds	r24, 0x210E
    11e0:	88 23       	and	r24, r24
    11e2:	c9 f4       	brne	.+50     	; 0x1216 <main+0x460>
								length = chb_read((chb_rx_data_t*)RadioMessageBuffer);							
    11e4:	ce 01       	movw	r24, r28
    11e6:	08 96       	adiw	r24, 0x08	; 8
    11e8:	0e 94 c2 1a 	call	0x3584	; 0x3584 <chb_read>
							}
							//reset timeout timer
							TimedOut = 0;
							TCE0.CTRLFSET = 0x08;  
							//read the data from FRAM and send it
							for(uint16_t i =0; i<(samples*4);){	
    11ec:	68 01       	movw	r12, r16
    11ee:	ee 24       	eor	r14, r14
    11f0:	ff 24       	eor	r15, r15
    11f2:	8c 81       	ldd	r24, Y+4	; 0x04
    11f4:	9d 81       	ldd	r25, Y+5	; 0x05
    11f6:	ae 81       	ldd	r26, Y+6	; 0x06
    11f8:	bf 81       	ldd	r27, Y+7	; 0x07
    11fa:	88 0f       	add	r24, r24
    11fc:	99 1f       	adc	r25, r25
    11fe:	aa 1f       	adc	r26, r26
    1200:	bb 1f       	adc	r27, r27
    1202:	88 0f       	add	r24, r24
    1204:	99 1f       	adc	r25, r25
    1206:	aa 1f       	adc	r26, r26
    1208:	bb 1f       	adc	r27, r27
    120a:	c8 16       	cp	r12, r24
    120c:	d9 06       	cpc	r13, r25
    120e:	ea 06       	cpc	r14, r26
    1210:	fb 06       	cpc	r15, r27
    1212:	08 f4       	brcc	.+2      	; 0x1216 <main+0x460>
    1214:	5a cf       	rjmp	.-332    	; 0x10ca <main+0x314>
							}
							//chb_write(0x0000,FRAMReadBuffer,samples*4);								
							//write the data to SD card for good measure (make sure transmitted and collected data is the same)	
							//writeFile(ofile, FRAMReadBuffer, samples*4);			
						}
						if(TimedOut){
    1216:	80 91 0e 21 	lds	r24, 0x210E
    121a:	88 23       	and	r24, r24
    121c:	31 f0       	breq	.+12     	; 0x122a <main+0x474>
							//stop timeout counter and go back to waiting for command
							TimedOut = 0;
    121e:	10 92 0e 21 	sts	0x210E, r1
							TCE0.CTRLA = 0; 
    1222:	a0 e0       	ldi	r26, 0x00	; 0
    1224:	ba e0       	ldi	r27, 0x0A	; 10
    1226:	1c 92       	st	X, r1
							break;
    1228:	00 ce       	rjmp	.-1024   	; 0xe2a <main+0x74>
						}														
						DataAvailable = 0;
    122a:	10 92 48 3e 	sts	0x3E48, r1
    122e:	fd cd       	rjmp	.-1030   	; 0xe2a <main+0x74>
					}
					else {
						while(chb_write(0x0000,(uint8_t*)(&ack),2) != CHB_SUCCESS);
    1230:	80 e0       	ldi	r24, 0x00	; 0
    1232:	90 e0       	ldi	r25, 0x00	; 0
    1234:	be 01       	movw	r22, r28
    1236:	6f 5f       	subi	r22, 0xFF	; 255
    1238:	7f 4f       	sbci	r23, 0xFF	; 255
    123a:	22 e0       	ldi	r18, 0x02	; 2
    123c:	30 e0       	ldi	r19, 0x00	; 0
    123e:	40 e0       	ldi	r20, 0x00	; 0
    1240:	50 e0       	ldi	r21, 0x00	; 0
    1242:	0e 94 22 1a 	call	0x3444	; 0x3444 <chb_write>
    1246:	88 23       	and	r24, r24
    1248:	99 f7       	brne	.-26     	; 0x1230 <main+0x47a>
    124a:	ef cd       	rjmp	.-1058   	; 0xe2a <main+0x74>

0000124c <__vector_47>:
				}		
		}		
	}	
}

ISR(TCE0_OVF_vect){
    124c:	1f 92       	push	r1
    124e:	0f 92       	push	r0
    1250:	0f b6       	in	r0, 0x3f	; 63
    1252:	0f 92       	push	r0
    1254:	11 24       	eor	r1, r1
    1256:	8f 93       	push	r24
	TimedOut = 1;
    1258:	81 e0       	ldi	r24, 0x01	; 1
    125a:	80 93 0e 21 	sts	0x210E, r24
    125e:	8f 91       	pop	r24
    1260:	0f 90       	pop	r0
    1262:	0f be       	out	0x3f, r0	; 63
    1264:	0f 90       	pop	r0
    1266:	1f 90       	pop	r1
    1268:	18 95       	reti

0000126a <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
    126a:	0f 93       	push	r16
    126c:	1f 93       	push	r17
    126e:	cf 93       	push	r28
    1270:	8c 01       	movw	r16, r24
	moteID = 1;
    1272:	c1 e0       	ldi	r28, 0x01	; 1
    1274:	c0 93 46 3e 	sts	0x3E46, r28
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
    1278:	83 e0       	ldi	r24, 0x03	; 3
    127a:	80 93 20 3e 	sts	0x3E20, r24
	chb_init();
    127e:	0e 94 fe 19 	call	0x33fc	; 0x33fc <chb_init>
	chb_set_short_addr(moteID);
    1282:	80 91 46 3e 	lds	r24, 0x3E46
    1286:	90 e0       	ldi	r25, 0x00	; 0
    1288:	0e 94 21 1c 	call	0x3842	; 0x3842 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
    128c:	88 ec       	ldi	r24, 0xC8	; 200
    128e:	e0 e8       	ldi	r30, 0x80	; 128
    1290:	f1 e0       	ldi	r31, 0x01	; 1
    1292:	81 83       	std	Z+1, r24	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
    1294:	e0 e4       	ldi	r30, 0x40	; 64
    1296:	f9 e0       	ldi	r31, 0x09	; 9
    1298:	89 e0       	ldi	r24, 0x09	; 9
    129a:	80 83       	st	Z, r24
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
    129c:	82 e0       	ldi	r24, 0x02	; 2
    129e:	86 83       	std	Z+6, r24	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
    12a0:	24 ef       	ldi	r18, 0xF4	; 244
    12a2:	31 e0       	ldi	r19, 0x01	; 1
    12a4:	02 9f       	mul	r16, r18
    12a6:	c0 01       	movw	r24, r0
    12a8:	03 9f       	mul	r16, r19
    12aa:	90 0d       	add	r25, r0
    12ac:	12 9f       	mul	r17, r18
    12ae:	90 0d       	add	r25, r0
    12b0:	11 24       	eor	r1, r1
    12b2:	86 a3       	lds	r24, 0x56
    12b4:	97 a3       	lds	r25, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
    12b6:	e0 e4       	ldi	r30, 0x40	; 64
    12b8:	f8 e0       	ldi	r31, 0x08	; 8
    12ba:	80 e0       	ldi	r24, 0x00	; 0
    12bc:	9a ef       	ldi	r25, 0xFA	; 250
    12be:	86 a3       	lds	r24, 0x56
    12c0:	97 a3       	lds	r25, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
    12c2:	c6 83       	std	Z+6, r28	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
    12c4:	c0 83       	st	Z, r28
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
    12c6:	e0 ea       	ldi	r30, 0xA0	; 160
    12c8:	f0 e0       	ldi	r31, 0x00	; 0
    12ca:	82 81       	ldd	r24, Z+2	; 0x02
    12cc:	87 60       	ori	r24, 0x07	; 7
    12ce:	82 83       	std	Z+2, r24	; 0x02
	sei(); //  Enable global interrupts
    12d0:	78 94       	sei
}
    12d2:	cf 91       	pop	r28
    12d4:	1f 91       	pop	r17
    12d6:	0f 91       	pop	r16
    12d8:	08 95       	ret

000012da <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
    12da:	78 94       	sei
    12dc:	1f 92       	push	r1
    12de:	0f 92       	push	r0
    12e0:	0f b6       	in	r0, 0x3f	; 63
    12e2:	0f 92       	push	r0
    12e4:	0b b6       	in	r0, 0x3b	; 59
    12e6:	0f 92       	push	r0
    12e8:	11 24       	eor	r1, r1
    12ea:	ef 92       	push	r14
    12ec:	ff 92       	push	r15
    12ee:	0f 93       	push	r16
    12f0:	1f 93       	push	r17
    12f2:	2f 93       	push	r18
    12f4:	3f 93       	push	r19
    12f6:	4f 93       	push	r20
    12f8:	5f 93       	push	r21
    12fa:	6f 93       	push	r22
    12fc:	7f 93       	push	r23
    12fe:	8f 93       	push	r24
    1300:	9f 93       	push	r25
    1302:	af 93       	push	r26
    1304:	bf 93       	push	r27
    1306:	ef 93       	push	r30
    1308:	ff 93       	push	r31
    130a:	cf 93       	push	r28
    130c:	df 93       	push	r29
    130e:	cd b7       	in	r28, 0x3d	; 61
    1310:	de b7       	in	r29, 0x3e	; 62
    1312:	28 97       	sbiw	r28, 0x08	; 8
    1314:	cd bf       	out	0x3d, r28	; 61
    1316:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
    1318:	10 92 40 08 	sts	0x0840, r1
	TCD1.CTRLA = 0x00;
    131c:	10 92 40 09 	sts	0x0940, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
    1320:	82 e0       	ldi	r24, 0x02	; 2
    1322:	80 93 20 3e 	sts	0x3E20, r24
	char message[8];
	strcpy(message,"reset");
    1326:	de 01       	movw	r26, r28
    1328:	11 96       	adiw	r26, 0x01	; 1
    132a:	e4 e0       	ldi	r30, 0x04	; 4
    132c:	f0 e2       	ldi	r31, 0x20	; 32
    132e:	86 e0       	ldi	r24, 0x06	; 6
    1330:	01 90       	ld	r0, Z+
    1332:	0d 92       	st	X+, r0
    1334:	81 50       	subi	r24, 0x01	; 1
    1336:	e1 f7       	brne	.-8      	; 0x1330 <__vector_83+0x56>
	itoa((int)(moteID),buff,10);
    1338:	0a ea       	ldi	r16, 0xAA	; 170
    133a:	10 e5       	ldi	r17, 0x50	; 80
    133c:	80 91 46 3e 	lds	r24, 0x3E46
    1340:	90 e0       	ldi	r25, 0x00	; 0
    1342:	b8 01       	movw	r22, r16
    1344:	4a e0       	ldi	r20, 0x0A	; 10
    1346:	50 e0       	ldi	r21, 0x00	; 0
    1348:	0e 94 09 3a 	call	0x7412	; 0x7412 <itoa>
	strcat(message,buff);
    134c:	7e 01       	movw	r14, r28
    134e:	08 94       	sec
    1350:	e1 1c       	adc	r14, r1
    1352:	f1 1c       	adc	r15, r1
    1354:	c7 01       	movw	r24, r14
    1356:	b8 01       	movw	r22, r16
    1358:	0e 94 fe 39 	call	0x73fc	; 0x73fc <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
    135c:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
    1360:	f7 01       	movw	r30, r14
    1362:	01 90       	ld	r0, Z+
    1364:	00 20       	and	r0, r0
    1366:	e9 f7       	brne	.-6      	; 0x1362 <__vector_83+0x88>
    1368:	31 97       	sbiw	r30, 0x01	; 1
    136a:	ee 19       	sub	r30, r14
    136c:	ff 09       	sbc	r31, r15
    136e:	9f 01       	movw	r18, r30
    1370:	40 e0       	ldi	r20, 0x00	; 0
    1372:	50 e0       	ldi	r21, 0x00	; 0
    1374:	80 e0       	ldi	r24, 0x00	; 0
    1376:	90 e0       	ldi	r25, 0x00	; 0
    1378:	b7 01       	movw	r22, r14
    137a:	0e 94 22 1a 	call	0x3444	; 0x3444 <chb_write>
}	
    137e:	28 96       	adiw	r28, 0x08	; 8
    1380:	cd bf       	out	0x3d, r28	; 61
    1382:	de bf       	out	0x3e, r29	; 62
    1384:	df 91       	pop	r29
    1386:	cf 91       	pop	r28
    1388:	ff 91       	pop	r31
    138a:	ef 91       	pop	r30
    138c:	bf 91       	pop	r27
    138e:	af 91       	pop	r26
    1390:	9f 91       	pop	r25
    1392:	8f 91       	pop	r24
    1394:	7f 91       	pop	r23
    1396:	6f 91       	pop	r22
    1398:	5f 91       	pop	r21
    139a:	4f 91       	pop	r20
    139c:	3f 91       	pop	r19
    139e:	2f 91       	pop	r18
    13a0:	1f 91       	pop	r17
    13a2:	0f 91       	pop	r16
    13a4:	ff 90       	pop	r15
    13a6:	ef 90       	pop	r14
    13a8:	0f 90       	pop	r0
    13aa:	0b be       	out	0x3b, r0	; 59
    13ac:	0f 90       	pop	r0
    13ae:	0f be       	out	0x3f, r0	; 63
    13b0:	0f 90       	pop	r0
    13b2:	1f 90       	pop	r1
    13b4:	18 95       	reti

000013b6 <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    13b6:	4f 92       	push	r4
    13b8:	5f 92       	push	r5
    13ba:	6f 92       	push	r6
    13bc:	7f 92       	push	r7
    13be:	8f 92       	push	r8
    13c0:	9f 92       	push	r9
    13c2:	af 92       	push	r10
    13c4:	bf 92       	push	r11
    13c6:	ef 92       	push	r14
    13c8:	ff 92       	push	r15
    13ca:	0f 93       	push	r16
    13cc:	1f 93       	push	r17
    13ce:	cf 93       	push	r28
    13d0:	df 93       	push	r29
    13d2:	cd b7       	in	r28, 0x3d	; 61
    13d4:	de b7       	in	r29, 0x3e	; 62
    13d6:	2b 97       	sbiw	r28, 0x0b	; 11
    13d8:	cd bf       	out	0x3d, r28	; 61
    13da:	de bf       	out	0x3e, r29	; 62
    13dc:	8e 83       	std	Y+6, r24	; 0x06
    13de:	9f 83       	std	Y+7, r25	; 0x07
    13e0:	68 87       	std	Y+8, r22	; 0x08
    13e2:	79 87       	std	Y+9, r23	; 0x09
    13e4:	4a 87       	std	Y+10, r20	; 0x0a
    13e6:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    13e8:	81 e0       	ldi	r24, 0x01	; 1
    13ea:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
    13ee:	80 e0       	ldi	r24, 0x00	; 0
    13f0:	92 e0       	ldi	r25, 0x02	; 2
    13f2:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    13f6:	00 e0       	ldi	r16, 0x00	; 0
    13f8:	12 e0       	ldi	r17, 0x02	; 2
    13fa:	d8 01       	movw	r26, r16
    13fc:	11 96       	adiw	r26, 0x01	; 1
    13fe:	8c 91       	ld	r24, X
    1400:	11 97       	sbiw	r26, 0x01	; 1
    1402:	89 7e       	andi	r24, 0xE9	; 233
    1404:	11 96       	adiw	r26, 0x01	; 1
    1406:	8c 93       	st	X, r24
    1408:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
    140a:	14 96       	adiw	r26, 0x04	; 4
    140c:	8c 91       	ld	r24, X
    140e:	14 97       	sbiw	r26, 0x04	; 4
    1410:	88 7f       	andi	r24, 0xF8	; 248
    1412:	83 60       	ori	r24, 0x03	; 3
    1414:	14 96       	adiw	r26, 0x04	; 4
    1416:	8c 93       	st	X, r24
    1418:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
    141a:	12 96       	adiw	r26, 0x02	; 2
    141c:	8c 91       	ld	r24, X
    141e:	12 97       	sbiw	r26, 0x02	; 2
    1420:	8f 7c       	andi	r24, 0xCF	; 207
    1422:	12 96       	adiw	r26, 0x02	; 2
    1424:	8c 93       	st	X, r24
    1426:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
    1428:	0f 2e       	mov	r0, r31
    142a:	f0 e2       	ldi	r31, 0x20	; 32
    142c:	ef 2e       	mov	r14, r31
    142e:	f2 e0       	ldi	r31, 0x02	; 2
    1430:	ff 2e       	mov	r15, r31
    1432:	f0 2d       	mov	r31, r0
    1434:	f7 01       	movw	r30, r14
    1436:	80 81       	ld	r24, Z
    1438:	80 7e       	andi	r24, 0xE0	; 224
    143a:	81 60       	ori	r24, 0x01	; 1
    143c:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    143e:	89 e0       	ldi	r24, 0x09	; 9
    1440:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
    1442:	8c 91       	ld	r24, X
    1444:	81 60       	ori	r24, 0x01	; 1
    1446:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    1448:	80 e0       	ldi	r24, 0x00	; 0
    144a:	92 e0       	ldi	r25, 0x02	; 2
    144c:	0e 94 66 19 	call	0x32cc	; 0x32cc <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
    1450:	80 e0       	ldi	r24, 0x00	; 0
    1452:	92 e0       	ldi	r25, 0x02	; 2
    1454:	60 e2       	ldi	r22, 0x20	; 32
    1456:	72 e0       	ldi	r23, 0x02	; 2
    1458:	40 e0       	ldi	r20, 0x00	; 0
    145a:	0e 94 70 19 	call	0x32e0	; 0x32e0 <ADC_Offset_Get_Unsigned>
    145e:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
    1460:	d8 01       	movw	r26, r16
    1462:	8c 91       	ld	r24, X
    1464:	8e 7f       	andi	r24, 0xFE	; 254
    1466:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    1468:	f7 01       	movw	r30, r14
    146a:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
    146c:	13 96       	adiw	r26, 0x03	; 3
    146e:	8c 91       	ld	r24, X
    1470:	13 97       	sbiw	r26, 0x03	; 3
    1472:	8f 73       	andi	r24, 0x3F	; 63
    1474:	13 96       	adiw	r26, 0x03	; 3
    1476:	8c 93       	st	X, r24
    1478:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
    147a:	8c 91       	ld	r24, X
    147c:	81 60       	ori	r24, 0x01	; 1
    147e:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    1480:	80 e0       	ldi	r24, 0x00	; 0
    1482:	92 e0       	ldi	r25, 0x02	; 2
    1484:	0e 94 66 19 	call	0x32cc	; 0x32cc <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
    1488:	d8 01       	movw	r26, r16
    148a:	11 96       	adiw	r26, 0x01	; 1
    148c:	8c 91       	ld	r24, X
    148e:	11 97       	sbiw	r26, 0x01	; 1
    1490:	88 60       	ori	r24, 0x08	; 8
    1492:	11 96       	adiw	r26, 0x01	; 1
    1494:	8c 93       	st	X, r24
    1496:	ee 24       	eor	r14, r14
    1498:	ff 24       	eor	r15, r15
    149a:	68 94       	set
    149c:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    149e:	44 24       	eor	r4, r4
    14a0:	55 24       	eor	r5, r5
    14a2:	32 01       	movw	r6, r4
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
    14a4:	20 e0       	ldi	r18, 0x00	; 0
    14a6:	30 e1       	ldi	r19, 0x10	; 16
    14a8:	40 e0       	ldi	r20, 0x00	; 0
    14aa:	50 e0       	ldi	r21, 0x00	; 0
    14ac:	2a 83       	std	Y+2, r18	; 0x02
    14ae:	3b 83       	std	Y+3, r19	; 0x03
    14b0:	4c 83       	std	Y+4, r20	; 0x04
    14b2:	5d 83       	std	Y+5, r21	; 0x05
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    14b4:	88 24       	eor	r8, r8
    14b6:	99 24       	eor	r9, r9
    14b8:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
    14ba:	00 e2       	ldi	r16, 0x20	; 32
    14bc:	12 e0       	ldi	r17, 0x02	; 2
    14be:	d8 01       	movw	r26, r16
    14c0:	13 96       	adiw	r26, 0x03	; 3
    14c2:	8c 91       	ld	r24, X
    14c4:	13 97       	sbiw	r26, 0x03	; 3
    14c6:	80 ff       	sbrs	r24, 0
    14c8:	fa cf       	rjmp	.-12     	; 0x14be <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
    14ca:	69 81       	ldd	r22, Y+1	; 0x01
    14cc:	c8 01       	movw	r24, r16
    14ce:	0e 94 42 19 	call	0x3284	; 0x3284 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
    14d2:	a0 e0       	ldi	r26, 0x00	; 0
    14d4:	b0 e0       	ldi	r27, 0x00	; 0
    14d6:	88 0e       	add	r8, r24
    14d8:	99 1e       	adc	r9, r25
    14da:	aa 1e       	adc	r10, r26
    14dc:	bb 1e       	adc	r11, r27
    14de:	48 16       	cp	r4, r24
    14e0:	59 06       	cpc	r5, r25
    14e2:	6a 06       	cpc	r6, r26
    14e4:	7b 06       	cpc	r7, r27
    14e6:	10 f4       	brcc	.+4      	; 0x14ec <CO_collectTemp+0x136>
    14e8:	2c 01       	movw	r4, r24
    14ea:	3d 01       	movw	r6, r26
    14ec:	2a 81       	ldd	r18, Y+2	; 0x02
    14ee:	3b 81       	ldd	r19, Y+3	; 0x03
    14f0:	4c 81       	ldd	r20, Y+4	; 0x04
    14f2:	5d 81       	ldd	r21, Y+5	; 0x05
    14f4:	82 17       	cp	r24, r18
    14f6:	93 07       	cpc	r25, r19
    14f8:	a4 07       	cpc	r26, r20
    14fa:	b5 07       	cpc	r27, r21
    14fc:	20 f4       	brcc	.+8      	; 0x1506 <CO_collectTemp+0x150>
    14fe:	8a 83       	std	Y+2, r24	; 0x02
    1500:	9b 83       	std	Y+3, r25	; 0x03
    1502:	ac 83       	std	Y+4, r26	; 0x04
    1504:	bd 83       	std	Y+5, r27	; 0x05
    1506:	08 94       	sec
    1508:	e1 08       	sbc	r14, r1
    150a:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    150c:	e1 14       	cp	r14, r1
    150e:	f1 04       	cpc	r15, r1
    1510:	b1 f6       	brne	.-84     	; 0x14be <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
    1512:	e0 e0       	ldi	r30, 0x00	; 0
    1514:	f2 e0       	ldi	r31, 0x02	; 2
    1516:	81 81       	ldd	r24, Z+1	; 0x01
    1518:	87 7f       	andi	r24, 0xF7	; 247
    151a:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
    151c:	80 81       	ld	r24, Z
    151e:	82 60       	ori	r24, 0x02	; 2
    1520:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
    1522:	80 81       	ld	r24, Z
    1524:	8e 7f       	andi	r24, 0xFE	; 254
    1526:	80 83       	st	Z, r24

	ADCPower(FALSE);
    1528:	80 e0       	ldi	r24, 0x00	; 0
    152a:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>

	average = sum / NUM_SAMPLES;
    152e:	c5 01       	movw	r24, r10
    1530:	b4 01       	movw	r22, r8
    1532:	05 2e       	mov	r0, r21
    1534:	5a e0       	ldi	r21, 0x0A	; 10
    1536:	96 95       	lsr	r25
    1538:	87 95       	ror	r24
    153a:	77 95       	ror	r23
    153c:	67 95       	ror	r22
    153e:	5a 95       	dec	r21
    1540:	d1 f7       	brne	.-12     	; 0x1536 <CO_collectTemp+0x180>
    1542:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    1544:	28 ee       	ldi	r18, 0xE8	; 232
    1546:	33 e0       	ldi	r19, 0x03	; 3
    1548:	40 e0       	ldi	r20, 0x00	; 0
    154a:	50 e0       	ldi	r21, 0x00	; 0
    154c:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    1550:	0f 2e       	mov	r0, r31
    1552:	ff ef       	ldi	r31, 0xFF	; 255
    1554:	8f 2e       	mov	r8, r31
    1556:	ff e0       	ldi	r31, 0x0F	; 15
    1558:	9f 2e       	mov	r9, r31
    155a:	f0 e0       	ldi	r31, 0x00	; 0
    155c:	af 2e       	mov	r10, r31
    155e:	f0 e0       	ldi	r31, 0x00	; 0
    1560:	bf 2e       	mov	r11, r31
    1562:	f0 2d       	mov	r31, r0
    1564:	a5 01       	movw	r20, r10
    1566:	94 01       	movw	r18, r8
    1568:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    156c:	c9 01       	movw	r24, r18
    156e:	c2 97       	sbiw	r24, 0x32	; 50
    1570:	ae 81       	ldd	r26, Y+6	; 0x06
    1572:	bf 81       	ldd	r27, Y+7	; 0x07
    1574:	8d 93       	st	X+, r24
    1576:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    1578:	c3 01       	movw	r24, r6
    157a:	b2 01       	movw	r22, r4
    157c:	28 ee       	ldi	r18, 0xE8	; 232
    157e:	33 e0       	ldi	r19, 0x03	; 3
    1580:	40 e0       	ldi	r20, 0x00	; 0
    1582:	50 e0       	ldi	r21, 0x00	; 0
    1584:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    1588:	a5 01       	movw	r20, r10
    158a:	94 01       	movw	r18, r8
    158c:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    1590:	c9 01       	movw	r24, r18
    1592:	c2 97       	sbiw	r24, 0x32	; 50
    1594:	ea 85       	ldd	r30, Y+10	; 0x0a
    1596:	fb 85       	ldd	r31, Y+11	; 0x0b
    1598:	80 83       	st	Z, r24
    159a:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    159c:	6a 81       	ldd	r22, Y+2	; 0x02
    159e:	7b 81       	ldd	r23, Y+3	; 0x03
    15a0:	8c 81       	ldd	r24, Y+4	; 0x04
    15a2:	9d 81       	ldd	r25, Y+5	; 0x05
    15a4:	28 ee       	ldi	r18, 0xE8	; 232
    15a6:	33 e0       	ldi	r19, 0x03	; 3
    15a8:	40 e0       	ldi	r20, 0x00	; 0
    15aa:	50 e0       	ldi	r21, 0x00	; 0
    15ac:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    15b0:	a5 01       	movw	r20, r10
    15b2:	94 01       	movw	r18, r8
    15b4:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    15b8:	22 53       	subi	r18, 0x32	; 50
    15ba:	30 40       	sbci	r19, 0x00	; 0
    15bc:	a8 85       	ldd	r26, Y+8	; 0x08
    15be:	b9 85       	ldd	r27, Y+9	; 0x09
    15c0:	2d 93       	st	X+, r18
    15c2:	3c 93       	st	X, r19
    15c4:	11 97       	sbiw	r26, 0x01	; 1
}
    15c6:	2b 96       	adiw	r28, 0x0b	; 11
    15c8:	cd bf       	out	0x3d, r28	; 61
    15ca:	de bf       	out	0x3e, r29	; 62
    15cc:	df 91       	pop	r29
    15ce:	cf 91       	pop	r28
    15d0:	1f 91       	pop	r17
    15d2:	0f 91       	pop	r16
    15d4:	ff 90       	pop	r15
    15d6:	ef 90       	pop	r14
    15d8:	bf 90       	pop	r11
    15da:	af 90       	pop	r10
    15dc:	9f 90       	pop	r9
    15de:	8f 90       	pop	r8
    15e0:	7f 90       	pop	r7
    15e2:	6f 90       	pop	r6
    15e4:	5f 90       	pop	r5
    15e6:	4f 90       	pop	r4
    15e8:	08 95       	ret

000015ea <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    15ea:	4f 92       	push	r4
    15ec:	5f 92       	push	r5
    15ee:	6f 92       	push	r6
    15f0:	7f 92       	push	r7
    15f2:	8f 92       	push	r8
    15f4:	9f 92       	push	r9
    15f6:	af 92       	push	r10
    15f8:	bf 92       	push	r11
    15fa:	ef 92       	push	r14
    15fc:	ff 92       	push	r15
    15fe:	0f 93       	push	r16
    1600:	1f 93       	push	r17
    1602:	cf 93       	push	r28
    1604:	df 93       	push	r29
    1606:	cd b7       	in	r28, 0x3d	; 61
    1608:	de b7       	in	r29, 0x3e	; 62
    160a:	2b 97       	sbiw	r28, 0x0b	; 11
    160c:	cd bf       	out	0x3d, r28	; 61
    160e:	de bf       	out	0x3e, r29	; 62
    1610:	8e 83       	std	Y+6, r24	; 0x06
    1612:	9f 83       	std	Y+7, r25	; 0x07
    1614:	68 87       	std	Y+8, r22	; 0x08
    1616:	79 87       	std	Y+9, r23	; 0x09
    1618:	4a 87       	std	Y+10, r20	; 0x0a
    161a:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    161c:	81 e0       	ldi	r24, 0x01	; 1
    161e:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
    1622:	84 e0       	ldi	r24, 0x04	; 4
    1624:	60 e0       	ldi	r22, 0x00	; 0
    1626:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
    162a:	84 e0       	ldi	r24, 0x04	; 4
    162c:	60 e0       	ldi	r22, 0x00	; 0
    162e:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
    1632:	2f ef       	ldi	r18, 0xFF	; 255
    1634:	33 ec       	ldi	r19, 0xC3	; 195
    1636:	49 e0       	ldi	r20, 0x09	; 9
    1638:	21 50       	subi	r18, 0x01	; 1
    163a:	30 40       	sbci	r19, 0x00	; 0
    163c:	40 40       	sbci	r20, 0x00	; 0
    163e:	e1 f7       	brne	.-8      	; 0x1638 <CO_collectBatt+0x4e>
    1640:	00 c0       	rjmp	.+0      	; 0x1642 <CO_collectBatt+0x58>
    1642:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
    1644:	80 e4       	ldi	r24, 0x40	; 64
    1646:	92 e0       	ldi	r25, 0x02	; 2
    1648:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    164c:	00 e4       	ldi	r16, 0x40	; 64
    164e:	12 e0       	ldi	r17, 0x02	; 2
    1650:	d8 01       	movw	r26, r16
    1652:	11 96       	adiw	r26, 0x01	; 1
    1654:	8c 91       	ld	r24, X
    1656:	11 97       	sbiw	r26, 0x01	; 1
    1658:	89 7e       	andi	r24, 0xE9	; 233
    165a:	11 96       	adiw	r26, 0x01	; 1
    165c:	8c 93       	st	X, r24
    165e:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
    1660:	14 96       	adiw	r26, 0x04	; 4
    1662:	8c 91       	ld	r24, X
    1664:	14 97       	sbiw	r26, 0x04	; 4
    1666:	88 7f       	andi	r24, 0xF8	; 248
    1668:	83 60       	ori	r24, 0x03	; 3
    166a:	14 96       	adiw	r26, 0x04	; 4
    166c:	8c 93       	st	X, r24
    166e:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
    1670:	12 96       	adiw	r26, 0x02	; 2
    1672:	8c 91       	ld	r24, X
    1674:	12 97       	sbiw	r26, 0x02	; 2
    1676:	8f 7c       	andi	r24, 0xCF	; 207
    1678:	12 96       	adiw	r26, 0x02	; 2
    167a:	8c 93       	st	X, r24
    167c:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
    167e:	0f 2e       	mov	r0, r31
    1680:	f0 e6       	ldi	r31, 0x60	; 96
    1682:	ef 2e       	mov	r14, r31
    1684:	f2 e0       	ldi	r31, 0x02	; 2
    1686:	ff 2e       	mov	r15, r31
    1688:	f0 2d       	mov	r31, r0
    168a:	f7 01       	movw	r30, r14
    168c:	80 81       	ld	r24, Z
    168e:	80 7e       	andi	r24, 0xE0	; 224
    1690:	81 60       	ori	r24, 0x01	; 1
    1692:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    1694:	89 e0       	ldi	r24, 0x09	; 9
    1696:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
    1698:	8c 91       	ld	r24, X
    169a:	81 60       	ori	r24, 0x01	; 1
    169c:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
    169e:	80 e4       	ldi	r24, 0x40	; 64
    16a0:	92 e0       	ldi	r25, 0x02	; 2
    16a2:	0e 94 66 19 	call	0x32cc	; 0x32cc <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
    16a6:	80 e4       	ldi	r24, 0x40	; 64
    16a8:	92 e0       	ldi	r25, 0x02	; 2
    16aa:	60 e6       	ldi	r22, 0x60	; 96
    16ac:	72 e0       	ldi	r23, 0x02	; 2
    16ae:	40 e0       	ldi	r20, 0x00	; 0
    16b0:	0e 94 70 19 	call	0x32e0	; 0x32e0 <ADC_Offset_Get_Unsigned>
    16b4:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
    16b6:	d8 01       	movw	r26, r16
    16b8:	8c 91       	ld	r24, X
    16ba:	8e 7f       	andi	r24, 0xFE	; 254
    16bc:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    16be:	f7 01       	movw	r30, r14
    16c0:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
    16c2:	13 96       	adiw	r26, 0x03	; 3
    16c4:	8c 91       	ld	r24, X
    16c6:	13 97       	sbiw	r26, 0x03	; 3
    16c8:	8f 73       	andi	r24, 0x3F	; 63
    16ca:	13 96       	adiw	r26, 0x03	; 3
    16cc:	8c 93       	st	X, r24
    16ce:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
    16d0:	8c 91       	ld	r24, X
    16d2:	81 60       	ori	r24, 0x01	; 1
    16d4:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
    16d6:	80 e4       	ldi	r24, 0x40	; 64
    16d8:	92 e0       	ldi	r25, 0x02	; 2
    16da:	0e 94 66 19 	call	0x32cc	; 0x32cc <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
    16de:	d8 01       	movw	r26, r16
    16e0:	11 96       	adiw	r26, 0x01	; 1
    16e2:	8c 91       	ld	r24, X
    16e4:	11 97       	sbiw	r26, 0x01	; 1
    16e6:	88 60       	ori	r24, 0x08	; 8
    16e8:	11 96       	adiw	r26, 0x01	; 1
    16ea:	8c 93       	st	X, r24
    16ec:	ee 24       	eor	r14, r14
    16ee:	ff 24       	eor	r15, r15
    16f0:	68 94       	set
    16f2:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    16f4:	44 24       	eor	r4, r4
    16f6:	55 24       	eor	r5, r5
    16f8:	32 01       	movw	r6, r4
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
    16fa:	20 e0       	ldi	r18, 0x00	; 0
    16fc:	30 e1       	ldi	r19, 0x10	; 16
    16fe:	40 e0       	ldi	r20, 0x00	; 0
    1700:	50 e0       	ldi	r21, 0x00	; 0
    1702:	2a 83       	std	Y+2, r18	; 0x02
    1704:	3b 83       	std	Y+3, r19	; 0x03
    1706:	4c 83       	std	Y+4, r20	; 0x04
    1708:	5d 83       	std	Y+5, r21	; 0x05
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    170a:	88 24       	eor	r8, r8
    170c:	99 24       	eor	r9, r9
    170e:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
    1710:	00 e6       	ldi	r16, 0x60	; 96
    1712:	12 e0       	ldi	r17, 0x02	; 2
    1714:	d8 01       	movw	r26, r16
    1716:	13 96       	adiw	r26, 0x03	; 3
    1718:	8c 91       	ld	r24, X
    171a:	13 97       	sbiw	r26, 0x03	; 3
    171c:	80 ff       	sbrs	r24, 0
    171e:	fa cf       	rjmp	.-12     	; 0x1714 <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
    1720:	69 81       	ldd	r22, Y+1	; 0x01
    1722:	c8 01       	movw	r24, r16
    1724:	0e 94 42 19 	call	0x3284	; 0x3284 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
    1728:	a0 e0       	ldi	r26, 0x00	; 0
    172a:	b0 e0       	ldi	r27, 0x00	; 0
    172c:	88 0e       	add	r8, r24
    172e:	99 1e       	adc	r9, r25
    1730:	aa 1e       	adc	r10, r26
    1732:	bb 1e       	adc	r11, r27
    1734:	48 16       	cp	r4, r24
    1736:	59 06       	cpc	r5, r25
    1738:	6a 06       	cpc	r6, r26
    173a:	7b 06       	cpc	r7, r27
    173c:	10 f4       	brcc	.+4      	; 0x1742 <CO_collectBatt+0x158>
    173e:	2c 01       	movw	r4, r24
    1740:	3d 01       	movw	r6, r26
    1742:	2a 81       	ldd	r18, Y+2	; 0x02
    1744:	3b 81       	ldd	r19, Y+3	; 0x03
    1746:	4c 81       	ldd	r20, Y+4	; 0x04
    1748:	5d 81       	ldd	r21, Y+5	; 0x05
    174a:	82 17       	cp	r24, r18
    174c:	93 07       	cpc	r25, r19
    174e:	a4 07       	cpc	r26, r20
    1750:	b5 07       	cpc	r27, r21
    1752:	20 f4       	brcc	.+8      	; 0x175c <CO_collectBatt+0x172>
    1754:	8a 83       	std	Y+2, r24	; 0x02
    1756:	9b 83       	std	Y+3, r25	; 0x03
    1758:	ac 83       	std	Y+4, r26	; 0x04
    175a:	bd 83       	std	Y+5, r27	; 0x05
    175c:	08 94       	sec
    175e:	e1 08       	sbc	r14, r1
    1760:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    1762:	e1 14       	cp	r14, r1
    1764:	f1 04       	cpc	r15, r1
    1766:	b1 f6       	brne	.-84     	; 0x1714 <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
    1768:	e0 e4       	ldi	r30, 0x40	; 64
    176a:	f2 e0       	ldi	r31, 0x02	; 2
    176c:	81 81       	ldd	r24, Z+1	; 0x01
    176e:	87 7f       	andi	r24, 0xF7	; 247
    1770:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
    1772:	80 81       	ld	r24, Z
    1774:	8e 7f       	andi	r24, 0xFE	; 254
    1776:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
    1778:	84 e0       	ldi	r24, 0x04	; 4
    177a:	60 e0       	ldi	r22, 0x00	; 0
    177c:	0e 94 0c 05 	call	0xa18	; 0xa18 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
    1780:	80 e0       	ldi	r24, 0x00	; 0
    1782:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
    1786:	c5 01       	movw	r24, r10
    1788:	b4 01       	movw	r22, r8
    178a:	05 2e       	mov	r0, r21
    178c:	5a e0       	ldi	r21, 0x0A	; 10
    178e:	96 95       	lsr	r25
    1790:	87 95       	ror	r24
    1792:	77 95       	ror	r23
    1794:	67 95       	ror	r22
    1796:	5a 95       	dec	r21
    1798:	d1 f7       	brne	.-12     	; 0x178e <CO_collectBatt+0x1a4>
    179a:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    179c:	28 ee       	ldi	r18, 0xE8	; 232
    179e:	33 e0       	ldi	r19, 0x03	; 3
    17a0:	40 e0       	ldi	r20, 0x00	; 0
    17a2:	50 e0       	ldi	r21, 0x00	; 0
    17a4:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    17a8:	0f 2e       	mov	r0, r31
    17aa:	ff ef       	ldi	r31, 0xFF	; 255
    17ac:	8f 2e       	mov	r8, r31
    17ae:	ff e0       	ldi	r31, 0x0F	; 15
    17b0:	9f 2e       	mov	r9, r31
    17b2:	f0 e0       	ldi	r31, 0x00	; 0
    17b4:	af 2e       	mov	r10, r31
    17b6:	f0 e0       	ldi	r31, 0x00	; 0
    17b8:	bf 2e       	mov	r11, r31
    17ba:	f0 2d       	mov	r31, r0
    17bc:	a5 01       	movw	r20, r10
    17be:	94 01       	movw	r18, r8
    17c0:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    17c4:	c9 01       	movw	r24, r18
    17c6:	c2 97       	sbiw	r24, 0x32	; 50
    17c8:	ae 81       	ldd	r26, Y+6	; 0x06
    17ca:	bf 81       	ldd	r27, Y+7	; 0x07
    17cc:	8d 93       	st	X+, r24
    17ce:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    17d0:	c3 01       	movw	r24, r6
    17d2:	b2 01       	movw	r22, r4
    17d4:	28 ee       	ldi	r18, 0xE8	; 232
    17d6:	33 e0       	ldi	r19, 0x03	; 3
    17d8:	40 e0       	ldi	r20, 0x00	; 0
    17da:	50 e0       	ldi	r21, 0x00	; 0
    17dc:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    17e0:	a5 01       	movw	r20, r10
    17e2:	94 01       	movw	r18, r8
    17e4:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    17e8:	c9 01       	movw	r24, r18
    17ea:	c2 97       	sbiw	r24, 0x32	; 50
    17ec:	ea 85       	ldd	r30, Y+10	; 0x0a
    17ee:	fb 85       	ldd	r31, Y+11	; 0x0b
    17f0:	80 83       	st	Z, r24
    17f2:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    17f4:	6a 81       	ldd	r22, Y+2	; 0x02
    17f6:	7b 81       	ldd	r23, Y+3	; 0x03
    17f8:	8c 81       	ldd	r24, Y+4	; 0x04
    17fa:	9d 81       	ldd	r25, Y+5	; 0x05
    17fc:	28 ee       	ldi	r18, 0xE8	; 232
    17fe:	33 e0       	ldi	r19, 0x03	; 3
    1800:	40 e0       	ldi	r20, 0x00	; 0
    1802:	50 e0       	ldi	r21, 0x00	; 0
    1804:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    1808:	a5 01       	movw	r20, r10
    180a:	94 01       	movw	r18, r8
    180c:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    1810:	22 53       	subi	r18, 0x32	; 50
    1812:	30 40       	sbci	r19, 0x00	; 0
    1814:	a8 85       	ldd	r26, Y+8	; 0x08
    1816:	b9 85       	ldd	r27, Y+9	; 0x09
    1818:	2d 93       	st	X+, r18
    181a:	3c 93       	st	X, r19
    181c:	11 97       	sbiw	r26, 0x01	; 1
}
    181e:	2b 96       	adiw	r28, 0x0b	; 11
    1820:	cd bf       	out	0x3d, r28	; 61
    1822:	de bf       	out	0x3e, r29	; 62
    1824:	df 91       	pop	r29
    1826:	cf 91       	pop	r28
    1828:	1f 91       	pop	r17
    182a:	0f 91       	pop	r16
    182c:	ff 90       	pop	r15
    182e:	ef 90       	pop	r14
    1830:	bf 90       	pop	r11
    1832:	af 90       	pop	r10
    1834:	9f 90       	pop	r9
    1836:	8f 90       	pop	r8
    1838:	7f 90       	pop	r7
    183a:	6f 90       	pop	r6
    183c:	5f 90       	pop	r5
    183e:	4f 90       	pop	r4
    1840:	08 95       	ret

00001842 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
    1842:	cf 93       	push	r28
    1844:	c6 2f       	mov	r28, r22
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
    1846:	21 e0       	ldi	r18, 0x01	; 1
    1848:	30 e0       	ldi	r19, 0x00	; 0
    184a:	a9 01       	movw	r20, r18
    184c:	02 c0       	rjmp	.+4      	; 0x1852 <set_ampGain+0x10>
    184e:	44 0f       	add	r20, r20
    1850:	55 1f       	adc	r21, r21
    1852:	8a 95       	dec	r24
    1854:	e2 f7       	brpl	.-8      	; 0x184e <set_ampGain+0xc>
    1856:	ca 01       	movw	r24, r20
    1858:	61 e0       	ldi	r22, 0x01	; 1
    185a:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    185e:	c0 ff       	sbrs	r28, 0
    1860:	05 c0       	rjmp	.+10     	; 0x186c <set_ampGain+0x2a>
    1862:	80 e4       	ldi	r24, 0x40	; 64
    1864:	e0 e0       	ldi	r30, 0x00	; 0
    1866:	f6 e0       	ldi	r31, 0x06	; 6
    1868:	85 83       	std	Z+5, r24	; 0x05
    186a:	04 c0       	rjmp	.+8      	; 0x1874 <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
    186c:	80 e4       	ldi	r24, 0x40	; 64
    186e:	e0 e0       	ldi	r30, 0x00	; 0
    1870:	f6 e0       	ldi	r31, 0x06	; 6
    1872:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    1874:	c1 ff       	sbrs	r28, 1
    1876:	05 c0       	rjmp	.+10     	; 0x1882 <set_ampGain+0x40>
    1878:	82 e0       	ldi	r24, 0x02	; 2
    187a:	e0 e2       	ldi	r30, 0x20	; 32
    187c:	f6 e0       	ldi	r31, 0x06	; 6
    187e:	85 83       	std	Z+5, r24	; 0x05
    1880:	04 c0       	rjmp	.+8      	; 0x188a <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
    1882:	82 e0       	ldi	r24, 0x02	; 2
    1884:	e0 e2       	ldi	r30, 0x20	; 32
    1886:	f6 e0       	ldi	r31, 0x06	; 6
    1888:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    188a:	c2 ff       	sbrs	r28, 2
    188c:	05 c0       	rjmp	.+10     	; 0x1898 <set_ampGain+0x56>
    188e:	84 e0       	ldi	r24, 0x04	; 4
    1890:	e0 e2       	ldi	r30, 0x20	; 32
    1892:	f6 e0       	ldi	r31, 0x06	; 6
    1894:	85 83       	std	Z+5, r24	; 0x05
    1896:	04 c0       	rjmp	.+8      	; 0x18a0 <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
    1898:	84 e0       	ldi	r24, 0x04	; 4
    189a:	e0 e2       	ldi	r30, 0x20	; 32
    189c:	f6 e0       	ldi	r31, 0x06	; 6
    189e:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    18a0:	5a e0       	ldi	r21, 0x0A	; 10
    18a2:	5a 95       	dec	r21
    18a4:	f1 f7       	brne	.-4      	; 0x18a2 <set_ampGain+0x60>
    18a6:	00 c0       	rjmp	.+0      	; 0x18a8 <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    18a8:	8f ef       	ldi	r24, 0xFF	; 255
    18aa:	61 e0       	ldi	r22, 0x01	; 1
    18ac:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    18b0:	cf 91       	pop	r28
    18b2:	08 95       	ret

000018b4 <enableADCMUX>:

void enableADCMUX(uint8_t on) {
	
	if(on) {
    18b4:	88 23       	and	r24, r24
    18b6:	31 f0       	breq	.+12     	; 0x18c4 <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
    18b8:	e0 e0       	ldi	r30, 0x00	; 0
    18ba:	f6 e0       	ldi	r31, 0x06	; 6
    18bc:	80 e2       	ldi	r24, 0x20	; 32
    18be:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
    18c0:	85 83       	std	Z+5, r24	; 0x05
    18c2:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
    18c4:	e0 e0       	ldi	r30, 0x00	; 0
    18c6:	f6 e0       	ldi	r31, 0x06	; 6
    18c8:	80 e2       	ldi	r24, 0x20	; 32
    18ca:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    18cc:	82 83       	std	Z+2, r24	; 0x02
    18ce:	08 95       	ret

000018d0 <__vector_20>:
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
    18d0:	1f 92       	push	r1
    18d2:	0f 92       	push	r0
    18d4:	0f b6       	in	r0, 0x3f	; 63
    18d6:	0f 92       	push	r0
    18d8:	0b b6       	in	r0, 0x3b	; 59
    18da:	0f 92       	push	r0
    18dc:	11 24       	eor	r1, r1
    18de:	2f 93       	push	r18
    18e0:	3f 93       	push	r19
    18e2:	4f 93       	push	r20
    18e4:	5f 93       	push	r21
    18e6:	6f 93       	push	r22
    18e8:	7f 93       	push	r23
    18ea:	8f 93       	push	r24
    18ec:	9f 93       	push	r25
    18ee:	af 93       	push	r26
    18f0:	bf 93       	push	r27
    18f2:	ef 93       	push	r30
    18f4:	ff 93       	push	r31

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    18f6:	e0 e4       	ldi	r30, 0x40	; 64
    18f8:	fa e0       	ldi	r31, 0x0A	; 10
    18fa:	80 81       	ld	r24, Z
    18fc:	80 7f       	andi	r24, 0xF0	; 240
    18fe:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1900:	a0 e0       	ldi	r26, 0x00	; 0
    1902:	b8 e0       	ldi	r27, 0x08	; 8
    1904:	8c 91       	ld	r24, X
    1906:	80 7f       	andi	r24, 0xF0	; 240
    1908:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    190a:	a0 e0       	ldi	r26, 0x00	; 0
    190c:	b9 e0       	ldi	r27, 0x09	; 9
    190e:	8c 91       	ld	r24, X
    1910:	80 7f       	andi	r24, 0xF0	; 240
    1912:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1914:	80 81       	ld	r24, Z
    1916:	80 7f       	andi	r24, 0xF0	; 240
    1918:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    191c:	80 e0       	ldi	r24, 0x00	; 0
    191e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    1922:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	enableADCMUX(FALSE);
    1926:	80 e0       	ldi	r24, 0x00	; 0
    1928:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
    192c:	81 e0       	ldi	r24, 0x01	; 1
    192e:	80 93 a7 50 	sts	0x50A7, r24
	DataAvailable = 1;
    1932:	80 93 48 3e 	sts	0x3E48, r24
}
    1936:	ff 91       	pop	r31
    1938:	ef 91       	pop	r30
    193a:	bf 91       	pop	r27
    193c:	af 91       	pop	r26
    193e:	9f 91       	pop	r25
    1940:	8f 91       	pop	r24
    1942:	7f 91       	pop	r23
    1944:	6f 91       	pop	r22
    1946:	5f 91       	pop	r21
    1948:	4f 91       	pop	r20
    194a:	3f 91       	pop	r19
    194c:	2f 91       	pop	r18
    194e:	0f 90       	pop	r0
    1950:	0b be       	out	0x3b, r0	; 59
    1952:	0f 90       	pop	r0
    1954:	0f be       	out	0x3f, r0	; 63
    1956:	0f 90       	pop	r0
    1958:	1f 90       	pop	r1
    195a:	18 95       	reti

0000195c <ADC_Stop_Sampling>:

//turns off ADC timers/counters and spi bus 
void ADC_Stop_Sampling(){
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    195c:	e0 e4       	ldi	r30, 0x40	; 64
    195e:	fa e0       	ldi	r31, 0x0A	; 10
    1960:	80 81       	ld	r24, Z
    1962:	80 7f       	andi	r24, 0xF0	; 240
    1964:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1966:	a0 e0       	ldi	r26, 0x00	; 0
    1968:	b8 e0       	ldi	r27, 0x08	; 8
    196a:	8c 91       	ld	r24, X
    196c:	80 7f       	andi	r24, 0xF0	; 240
    196e:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1970:	a0 e0       	ldi	r26, 0x00	; 0
    1972:	b9 e0       	ldi	r27, 0x09	; 9
    1974:	8c 91       	ld	r24, X
    1976:	80 7f       	andi	r24, 0xF0	; 240
    1978:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    197a:	80 81       	ld	r24, Z
    197c:	80 7f       	andi	r24, 0xF0	; 240
    197e:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    1982:	80 e0       	ldi	r24, 0x00	; 0
    1984:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    1988:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	enableADCMUX(FALSE);
    198c:	80 e0       	ldi	r24, 0x00	; 0
    198e:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <enableADCMUX>
	ADC_Sampling_Finished = 1;
    1992:	81 e0       	ldi	r24, 0x01	; 1
    1994:	80 93 a7 50 	sts	0x50A7, r24
	DataAvailable = 1;
    1998:	80 93 48 3e 	sts	0x3E48, r24
}
    199c:	08 95       	ret

0000199e <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
    199e:	cf 93       	push	r28
    19a0:	df 93       	push	r29
    19a2:	0f 92       	push	r0
    19a4:	0f 92       	push	r0
    19a6:	cd b7       	in	r28, 0x3d	; 61
    19a8:	de b7       	in	r29, 0x3e	; 62
	
	if(ADC_Sampling_Finished){
    19aa:	80 91 a7 50 	lds	r24, 0x50A7
    19ae:	88 23       	and	r24, r24
    19b0:	89 f0       	breq	.+34     	; 0x19d4 <ADC_Get_Num_Samples+0x36>
		volatile uint16_t count;
		count = TCC1.CNT;
    19b2:	e0 e4       	ldi	r30, 0x40	; 64
    19b4:	f8 e0       	ldi	r31, 0x08	; 8
    19b6:	80 a1       	lds	r24, 0x40
    19b8:	91 a1       	lds	r25, 0x41
    19ba:	89 83       	std	Y+1, r24	; 0x01
    19bc:	9a 83       	std	Y+2, r25	; 0x02
		if(count == 0) count = TCC1.PER;
    19be:	89 81       	ldd	r24, Y+1	; 0x01
    19c0:	9a 81       	ldd	r25, Y+2	; 0x02
    19c2:	00 97       	sbiw	r24, 0x00	; 0
    19c4:	21 f4       	brne	.+8      	; 0x19ce <ADC_Get_Num_Samples+0x30>
    19c6:	86 a1       	lds	r24, 0x46
    19c8:	97 a1       	lds	r25, 0x47
    19ca:	89 83       	std	Y+1, r24	; 0x01
    19cc:	9a 83       	std	Y+2, r25	; 0x02
		return count;
    19ce:	89 81       	ldd	r24, Y+1	; 0x01
    19d0:	9a 81       	ldd	r25, Y+2	; 0x02
    19d2:	02 c0       	rjmp	.+4      	; 0x19d8 <ADC_Get_Num_Samples+0x3a>
	}
	else return 0;		
    19d4:	80 e0       	ldi	r24, 0x00	; 0
    19d6:	90 e0       	ldi	r25, 0x00	; 0
}
    19d8:	0f 90       	pop	r0
    19da:	0f 90       	pop	r0
    19dc:	df 91       	pop	r29
    19de:	cf 91       	pop	r28
    19e0:	08 95       	ret

000019e2 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    19e2:	e0 ea       	ldi	r30, 0xA0	; 160
    19e4:	f6 e0       	ldi	r31, 0x06	; 6
    19e6:	13 86       	std	Z+11, r1	; 0x0b
}
    19e8:	08 95       	ret

000019ea <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    19ea:	81 e0       	ldi	r24, 0x01	; 1
    19ec:	e0 ea       	ldi	r30, 0xA0	; 160
    19ee:	f6 e0       	ldi	r31, 0x06	; 6
    19f0:	83 87       	std	Z+11, r24	; 0x0b
}	
    19f2:	08 95       	ret

000019f4 <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    19f4:	1f 92       	push	r1
    19f6:	0f 92       	push	r0
    19f8:	0f b6       	in	r0, 0x3f	; 63
    19fa:	0f 92       	push	r0
    19fc:	0b b6       	in	r0, 0x3b	; 59
    19fe:	0f 92       	push	r0
    1a00:	11 24       	eor	r1, r1
    1a02:	6f 92       	push	r6
    1a04:	7f 92       	push	r7
    1a06:	8f 92       	push	r8
    1a08:	9f 92       	push	r9
    1a0a:	af 92       	push	r10
    1a0c:	bf 92       	push	r11
    1a0e:	cf 92       	push	r12
    1a10:	df 92       	push	r13
    1a12:	ef 92       	push	r14
    1a14:	ff 92       	push	r15
    1a16:	0f 93       	push	r16
    1a18:	1f 93       	push	r17
    1a1a:	2f 93       	push	r18
    1a1c:	3f 93       	push	r19
    1a1e:	4f 93       	push	r20
    1a20:	5f 93       	push	r21
    1a22:	6f 93       	push	r22
    1a24:	7f 93       	push	r23
    1a26:	8f 93       	push	r24
    1a28:	9f 93       	push	r25
    1a2a:	af 93       	push	r26
    1a2c:	bf 93       	push	r27
    1a2e:	ef 93       	push	r30
    1a30:	ff 93       	push	r31
    1a32:	cf 93       	push	r28
    1a34:	df 93       	push	r29
    1a36:	cd b7       	in	r28, 0x3d	; 61
    1a38:	de b7       	in	r29, 0x3e	; 62
    1a3a:	2c 97       	sbiw	r28, 0x0c	; 12
    1a3c:	cd bf       	out	0x3d, r28	; 61
    1a3e:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	volatile int64_t var;
	if (discardCount < ADC_DISCARD) {
    1a40:	80 91 5d 40 	lds	r24, 0x405D
    1a44:	88 23       	and	r24, r24
    1a46:	8c f0       	brlt	.+34     	; 0x1a6a <__vector_104+0x76>
		discardCount++;
    1a48:	80 91 5d 40 	lds	r24, 0x405D
    1a4c:	8f 5f       	subi	r24, 0xFF	; 255
    1a4e:	80 93 5d 40 	sts	0x405D, r24
		if(discardCount == ADC_DISCARD){
    1a52:	80 91 5d 40 	lds	r24, 0x405D
    1a56:	80 38       	cpi	r24, 0x80	; 128
    1a58:	09 f0       	breq	.+2      	; 0x1a5c <__vector_104+0x68>
    1a5a:	e9 c0       	rjmp	.+466    	; 0x1c2e <__vector_104+0x23a>
			//set event system to update counter of number of samples every sample event from now on
			TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    1a5c:	e0 e4       	ldi	r30, 0x40	; 64
    1a5e:	f8 e0       	ldi	r31, 0x08	; 8
    1a60:	80 81       	ld	r24, Z
    1a62:	80 7f       	andi	r24, 0xF0	; 240
    1a64:	89 60       	ori	r24, 0x09	; 9
    1a66:	80 83       	st	Z, r24
    1a68:	e2 c0       	rjmp	.+452    	; 0x1c2e <__vector_104+0x23a>
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    1a6a:	81 e0       	ldi	r24, 0x01	; 1
    1a6c:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1a70:	82 e0       	ldi	r24, 0x02	; 2
    1a72:	e0 ea       	ldi	r30, 0xA0	; 160
    1a74:	f6 e0       	ldi	r31, 0x06	; 6
    1a76:	86 83       	std	Z+6, r24	; 0x06
    1a78:	80 e0       	ldi	r24, 0x00	; 0
    1a7a:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1a7c:	e0 ec       	ldi	r30, 0xC0	; 192
    1a7e:	f8 e0       	ldi	r31, 0x08	; 8
    1a80:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
    1a82:	21 e2       	ldi	r18, 0x21	; 33
    1a84:	3e e3       	ldi	r19, 0x3E	; 62
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1a86:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1a88:	42 81       	ldd	r20, Z+2	; 0x02
    1a8a:	44 23       	and	r20, r20
    1a8c:	ec f7       	brge	.-6      	; 0x1a88 <__vector_104+0x94>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1a8e:	43 81       	ldd	r20, Z+3	; 0x03
    1a90:	d9 01       	movw	r26, r18
    1a92:	a8 0f       	add	r26, r24
    1a94:	b9 1f       	adc	r27, r25
    1a96:	4c 93       	st	X, r20
    1a98:	01 96       	adiw	r24, 0x01	; 1
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1a9a:	83 30       	cpi	r24, 0x03	; 3
    1a9c:	91 05       	cpc	r25, r1
    1a9e:	99 f7       	brne	.-26     	; 0x1a86 <__vector_104+0x92>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1aa0:	82 e0       	ldi	r24, 0x02	; 2
    1aa2:	e0 ea       	ldi	r30, 0xA0	; 160
    1aa4:	f6 e0       	ldi	r31, 0x06	; 6
    1aa6:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
    1aa8:	80 e0       	ldi	r24, 0x00	; 0
    1aaa:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1aae:	80 91 21 3e 	lds	r24, 0x3E21
    1ab2:	88 23       	and	r24, r24
    1ab4:	1c f4       	brge	.+6      	; 0x1abc <__vector_104+0xc8>
    1ab6:	8f ef       	ldi	r24, 0xFF	; 255
    1ab8:	8c 83       	std	Y+4, r24	; 0x04
    1aba:	01 c0       	rjmp	.+2      	; 0x1abe <__vector_104+0xca>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1abc:	1c 82       	std	Y+4, r1	; 0x04
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    1abe:	80 91 21 3e 	lds	r24, 0x3E21
    1ac2:	8b 83       	std	Y+3, r24	; 0x03
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    1ac4:	80 91 22 3e 	lds	r24, 0x3E22
    1ac8:	8a 83       	std	Y+2, r24	; 0x02
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    1aca:	80 91 23 3e 	lds	r24, 0x3E23
    1ace:	89 83       	std	Y+1, r24	; 0x01
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    1ad0:	89 81       	ldd	r24, Y+1	; 0x01
    1ad2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ad4:	ab 81       	ldd	r26, Y+3	; 0x03
    1ad6:	bc 81       	ldd	r27, Y+4	; 0x04
    1ad8:	ac 01       	movw	r20, r24
    1ada:	bd 01       	movw	r22, r26
    1adc:	77 0f       	add	r23, r23
    1ade:	44 0b       	sbc	r20, r20
    1ae0:	54 2f       	mov	r21, r20
    1ae2:	ba 01       	movw	r22, r20
    1ae4:	8d 83       	std	Y+5, r24	; 0x05
    1ae6:	9e 83       	std	Y+6, r25	; 0x06
    1ae8:	af 83       	std	Y+7, r26	; 0x07
    1aea:	b8 87       	std	Y+8, r27	; 0x08
    1aec:	49 87       	std	Y+9, r20	; 0x09
    1aee:	4a 87       	std	Y+10, r20	; 0x0a
    1af0:	4b 87       	std	Y+11, r20	; 0x0b
    1af2:	4c 87       	std	Y+12, r20	; 0x0c
		ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1af4:	60 91 66 50 	lds	r22, 0x5066
    1af8:	70 91 67 50 	lds	r23, 0x5067
    1afc:	80 91 68 50 	lds	r24, 0x5068
    1b00:	90 91 69 50 	lds	r25, 0x5069
    1b04:	8d 80       	ldd	r8, Y+5	; 0x05
    1b06:	1e 81       	ldd	r17, Y+6	; 0x06
    1b08:	0f 81       	ldd	r16, Y+7	; 0x07
    1b0a:	f8 84       	ldd	r15, Y+8	; 0x08
    1b0c:	e9 84       	ldd	r14, Y+9	; 0x09
    1b0e:	da 84       	ldd	r13, Y+10	; 0x0a
    1b10:	cb 84       	ldd	r12, Y+11	; 0x0b
    1b12:	bc 84       	ldd	r11, Y+12	; 0x0c
    1b14:	20 91 a8 50 	lds	r18, 0x50A8
    1b18:	30 91 a9 50 	lds	r19, 0x50A9
    1b1c:	40 e0       	ldi	r20, 0x00	; 0
    1b1e:	50 e0       	ldi	r21, 0x00	; 0
    1b20:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    1b24:	66 0f       	add	r22, r22
    1b26:	77 1f       	adc	r23, r23
    1b28:	66 0f       	add	r22, r22
    1b2a:	77 1f       	adc	r23, r23
    1b2c:	80 91 64 50 	lds	r24, 0x5064
    1b30:	90 91 65 50 	lds	r25, 0x5065
    1b34:	3c 01       	movw	r6, r24
    1b36:	66 0e       	add	r6, r22
    1b38:	77 1e       	adc	r7, r23
    1b3a:	28 2d       	mov	r18, r8
    1b3c:	31 2f       	mov	r19, r17
    1b3e:	40 2f       	mov	r20, r16
    1b40:	5f 2d       	mov	r21, r15
    1b42:	6e 2d       	mov	r22, r14
    1b44:	7d 2d       	mov	r23, r13
    1b46:	8c 2d       	mov	r24, r12
    1b48:	9b 2d       	mov	r25, r11
    1b4a:	0f 2e       	mov	r0, r31
    1b4c:	f0 ea       	ldi	r31, 0xA0	; 160
    1b4e:	af 2e       	mov	r10, r31
    1b50:	f0 2d       	mov	r31, r0
    1b52:	0f 2e       	mov	r0, r31
    1b54:	f5 e2       	ldi	r31, 0x25	; 37
    1b56:	bf 2e       	mov	r11, r31
    1b58:	f0 2d       	mov	r31, r0
    1b5a:	0f 2e       	mov	r0, r31
    1b5c:	f6 e2       	ldi	r31, 0x26	; 38
    1b5e:	cf 2e       	mov	r12, r31
    1b60:	f0 2d       	mov	r31, r0
    1b62:	dd 24       	eor	r13, r13
    1b64:	ee 24       	eor	r14, r14
    1b66:	ff 24       	eor	r15, r15
    1b68:	00 e0       	ldi	r16, 0x00	; 0
    1b6a:	10 e0       	ldi	r17, 0x00	; 0
    1b6c:	0e 94 17 2e 	call	0x5c2e	; 0x5c2e <__muldi3>
    1b70:	aa 24       	eor	r10, r10
    1b72:	aa 94       	dec	r10
    1b74:	bb 24       	eor	r11, r11
    1b76:	ba 94       	dec	r11
    1b78:	0f 2e       	mov	r0, r31
    1b7a:	ff e7       	ldi	r31, 0x7F	; 127
    1b7c:	cf 2e       	mov	r12, r31
    1b7e:	f0 2d       	mov	r31, r0
    1b80:	0e 94 c6 2f 	call	0x5f8c	; 0x5f8c <__divdi3>
    1b84:	01 e0       	ldi	r16, 0x01	; 1
    1b86:	0e 94 ea 2e 	call	0x5dd4	; 0x5dd4 <__ashldi3>
    1b8a:	0f 2e       	mov	r0, r31
    1b8c:	f3 e0       	ldi	r31, 0x03	; 3
    1b8e:	af 2e       	mov	r10, r31
    1b90:	f0 2d       	mov	r31, r0
    1b92:	bb 24       	eor	r11, r11
    1b94:	cc 24       	eor	r12, r12
    1b96:	00 e0       	ldi	r16, 0x00	; 0
    1b98:	0e 94 c6 2f 	call	0x5f8c	; 0x5f8c <__divdi3>
    1b9c:	82 2e       	mov	r8, r18
    1b9e:	93 2e       	mov	r9, r19
    1ba0:	a4 2e       	mov	r10, r20
    1ba2:	b5 2e       	mov	r11, r21
    1ba4:	b0 94       	com	r11
    1ba6:	a0 94       	com	r10
    1ba8:	90 94       	com	r9
    1baa:	80 94       	com	r8
    1bac:	81 1c       	adc	r8, r1
    1bae:	91 1c       	adc	r9, r1
    1bb0:	a1 1c       	adc	r10, r1
    1bb2:	b1 1c       	adc	r11, r1
    1bb4:	f3 01       	movw	r30, r6
    1bb6:	80 82       	st	Z, r8
    1bb8:	91 82       	std	Z+1, r9	; 0x01
    1bba:	a2 82       	std	Z+2, r10	; 0x02
    1bbc:	b3 82       	std	Z+3, r11	; 0x03
		if(write_to_FRAM){
    1bbe:	80 91 49 40 	lds	r24, 0x4049
    1bc2:	88 23       	and	r24, r24
    1bc4:	09 f1       	breq	.+66     	; 0x1c08 <__vector_104+0x214>
			writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    1bc6:	60 91 66 50 	lds	r22, 0x5066
    1bca:	70 91 67 50 	lds	r23, 0x5067
    1bce:	80 91 68 50 	lds	r24, 0x5068
    1bd2:	90 91 69 50 	lds	r25, 0x5069
    1bd6:	20 91 a8 50 	lds	r18, 0x50A8
    1bda:	30 91 a9 50 	lds	r19, 0x50A9
    1bde:	40 e0       	ldi	r20, 0x00	; 0
    1be0:	50 e0       	ldi	r21, 0x00	; 0
    1be2:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    1be6:	dc 01       	movw	r26, r24
    1be8:	cb 01       	movw	r24, r22
    1bea:	9c 01       	movw	r18, r24
    1bec:	22 0f       	add	r18, r18
    1bee:	33 1f       	adc	r19, r19
    1bf0:	22 0f       	add	r18, r18
    1bf2:	33 1f       	adc	r19, r19
    1bf4:	80 91 64 50 	lds	r24, 0x5064
    1bf8:	90 91 65 50 	lds	r25, 0x5065
    1bfc:	82 0f       	add	r24, r18
    1bfe:	93 1f       	adc	r25, r19
    1c00:	64 e0       	ldi	r22, 0x04	; 4
    1c02:	70 e0       	ldi	r23, 0x00	; 0
    1c04:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
		}
		sampleCount++;
    1c08:	80 91 66 50 	lds	r24, 0x5066
    1c0c:	90 91 67 50 	lds	r25, 0x5067
    1c10:	a0 91 68 50 	lds	r26, 0x5068
    1c14:	b0 91 69 50 	lds	r27, 0x5069
    1c18:	01 96       	adiw	r24, 0x01	; 1
    1c1a:	a1 1d       	adc	r26, r1
    1c1c:	b1 1d       	adc	r27, r1
    1c1e:	80 93 66 50 	sts	0x5066, r24
    1c22:	90 93 67 50 	sts	0x5067, r25
    1c26:	a0 93 68 50 	sts	0x5068, r26
    1c2a:	b0 93 69 50 	sts	0x5069, r27
	}
}
    1c2e:	2c 96       	adiw	r28, 0x0c	; 12
    1c30:	cd bf       	out	0x3d, r28	; 61
    1c32:	de bf       	out	0x3e, r29	; 62
    1c34:	df 91       	pop	r29
    1c36:	cf 91       	pop	r28
    1c38:	ff 91       	pop	r31
    1c3a:	ef 91       	pop	r30
    1c3c:	bf 91       	pop	r27
    1c3e:	af 91       	pop	r26
    1c40:	9f 91       	pop	r25
    1c42:	8f 91       	pop	r24
    1c44:	7f 91       	pop	r23
    1c46:	6f 91       	pop	r22
    1c48:	5f 91       	pop	r21
    1c4a:	4f 91       	pop	r20
    1c4c:	3f 91       	pop	r19
    1c4e:	2f 91       	pop	r18
    1c50:	1f 91       	pop	r17
    1c52:	0f 91       	pop	r16
    1c54:	ff 90       	pop	r15
    1c56:	ef 90       	pop	r14
    1c58:	df 90       	pop	r13
    1c5a:	cf 90       	pop	r12
    1c5c:	bf 90       	pop	r11
    1c5e:	af 90       	pop	r10
    1c60:	9f 90       	pop	r9
    1c62:	8f 90       	pop	r8
    1c64:	7f 90       	pop	r7
    1c66:	6f 90       	pop	r6
    1c68:	0f 90       	pop	r0
    1c6a:	0b be       	out	0x3b, r0	; 59
    1c6c:	0f 90       	pop	r0
    1c6e:	0f be       	out	0x3f, r0	; 63
    1c70:	0f 90       	pop	r0
    1c72:	1f 90       	pop	r1
    1c74:	18 95       	reti

00001c76 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
    1c76:	88 23       	and	r24, r24
    1c78:	49 f0       	breq	.+18     	; 0x1c8c <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1c7a:	80 e2       	ldi	r24, 0x20	; 32
    1c7c:	60 e0       	ldi	r22, 0x00	; 0
    1c7e:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1c82:	80 e2       	ldi	r24, 0x20	; 32
    1c84:	60 e0       	ldi	r22, 0x00	; 0
    1c86:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
    1c8a:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1c8c:	80 e2       	ldi	r24, 0x20	; 32
    1c8e:	60 e0       	ldi	r22, 0x00	; 0
    1c90:	0e 94 0c 05 	call	0xa18	; 0xa18 <PortEx_DIRCLR>
    1c94:	08 95       	ret

00001c96 <__vector_14>:
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1c96:	1f 92       	push	r1
    1c98:	0f 92       	push	r0
    1c9a:	0f b6       	in	r0, 0x3f	; 63
    1c9c:	0f 92       	push	r0
    1c9e:	0b b6       	in	r0, 0x3b	; 59
    1ca0:	0f 92       	push	r0
    1ca2:	11 24       	eor	r1, r1
    1ca4:	6f 92       	push	r6
    1ca6:	7f 92       	push	r7
    1ca8:	8f 92       	push	r8
    1caa:	9f 92       	push	r9
    1cac:	af 92       	push	r10
    1cae:	bf 92       	push	r11
    1cb0:	cf 92       	push	r12
    1cb2:	df 92       	push	r13
    1cb4:	ef 92       	push	r14
    1cb6:	ff 92       	push	r15
    1cb8:	0f 93       	push	r16
    1cba:	1f 93       	push	r17
    1cbc:	2f 93       	push	r18
    1cbe:	3f 93       	push	r19
    1cc0:	4f 93       	push	r20
    1cc2:	5f 93       	push	r21
    1cc4:	6f 93       	push	r22
    1cc6:	7f 93       	push	r23
    1cc8:	8f 93       	push	r24
    1cca:	9f 93       	push	r25
    1ccc:	af 93       	push	r26
    1cce:	bf 93       	push	r27
    1cd0:	ef 93       	push	r30
    1cd2:	ff 93       	push	r31
    1cd4:	cf 93       	push	r28
    1cd6:	df 93       	push	r29
    1cd8:	cd b7       	in	r28, 0x3d	; 61
    1cda:	de b7       	in	r29, 0x3e	; 62
    1cdc:	2c 97       	sbiw	r28, 0x0c	; 12
    1cde:	cd bf       	out	0x3d, r28	; 61
    1ce0:	de bf       	out	0x3e, r29	; 62
	volatile int64_t sum = 0;
    1ce2:	19 82       	std	Y+1, r1	; 0x01
    1ce4:	1a 82       	std	Y+2, r1	; 0x02
    1ce6:	1b 82       	std	Y+3, r1	; 0x03
    1ce8:	1c 82       	std	Y+4, r1	; 0x04
    1cea:	1d 82       	std	Y+5, r1	; 0x05
    1cec:	1e 82       	std	Y+6, r1	; 0x06
    1cee:	1f 82       	std	Y+7, r1	; 0x07
    1cf0:	18 86       	std	Y+8, r1	; 0x08
    1cf2:	80 e0       	ldi	r24, 0x00	; 0
    1cf4:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1cf6:	21 e2       	ldi	r18, 0x21	; 33
    1cf8:	3e e3       	ldi	r19, 0x3E	; 62
    1cfa:	88 24       	eor	r8, r8
    1cfc:	8a 94       	dec	r8
    1cfe:	ac 01       	movw	r20, r24
    1d00:	f9 01       	movw	r30, r18
    1d02:	e8 0f       	add	r30, r24
    1d04:	f9 1f       	adc	r31, r25
    1d06:	60 81       	ld	r22, Z
    1d08:	66 23       	and	r22, r22
    1d0a:	14 f4       	brge	.+4      	; 0x1d10 <__vector_14+0x7a>
    1d0c:	8c 86       	std	Y+12, r8	; 0x0c
    1d0e:	01 c0       	rjmp	.+2      	; 0x1d12 <__vector_14+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1d10:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1d12:	42 0f       	add	r20, r18
    1d14:	53 1f       	adc	r21, r19
    1d16:	fa 01       	movw	r30, r20
    1d18:	40 81       	ld	r20, Z
    1d1a:	4b 87       	std	Y+11, r20	; 0x0b
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1d1c:	fc 01       	movw	r30, r24
    1d1e:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1d20:	e2 0f       	add	r30, r18
    1d22:	f3 1f       	adc	r31, r19
    1d24:	40 81       	ld	r20, Z
    1d26:	4a 87       	std	Y+10, r20	; 0x0a
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1d28:	fc 01       	movw	r30, r24
    1d2a:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1d2c:	e2 0f       	add	r30, r18
    1d2e:	f3 1f       	adc	r31, r19
    1d30:	40 81       	ld	r20, Z
    1d32:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    1d34:	49 85       	ldd	r20, Y+9	; 0x09
    1d36:	5a 85       	ldd	r21, Y+10	; 0x0a
    1d38:	6b 85       	ldd	r22, Y+11	; 0x0b
    1d3a:	7c 85       	ldd	r23, Y+12	; 0x0c
    1d3c:	a9 80       	ldd	r10, Y+1	; 0x01
    1d3e:	ba 80       	ldd	r11, Y+2	; 0x02
    1d40:	cb 80       	ldd	r12, Y+3	; 0x03
    1d42:	dc 80       	ldd	r13, Y+4	; 0x04
    1d44:	ed 80       	ldd	r14, Y+5	; 0x05
    1d46:	fe 80       	ldd	r15, Y+6	; 0x06
    1d48:	0f 81       	ldd	r16, Y+7	; 0x07
    1d4a:	18 85       	ldd	r17, Y+8	; 0x08
    1d4c:	b4 2f       	mov	r27, r20
    1d4e:	a5 2f       	mov	r26, r21
    1d50:	f6 2f       	mov	r31, r22
    1d52:	e7 2f       	mov	r30, r23
    1d54:	77 0f       	add	r23, r23
    1d56:	44 0b       	sbc	r20, r20
    1d58:	54 2f       	mov	r21, r20
    1d5a:	ba 01       	movw	r22, r20
    1d5c:	64 2e       	mov	r6, r20
    1d5e:	74 2e       	mov	r7, r20
    1d60:	94 2e       	mov	r9, r20
    1d62:	ab 0e       	add	r10, r27
    1d64:	61 e0       	ldi	r22, 0x01	; 1
    1d66:	ab 16       	cp	r10, r27
    1d68:	08 f0       	brcs	.+2      	; 0x1d6c <__vector_14+0xd6>
    1d6a:	60 e0       	ldi	r22, 0x00	; 0
    1d6c:	ba 0e       	add	r11, r26
    1d6e:	51 e0       	ldi	r21, 0x01	; 1
    1d70:	ba 16       	cp	r11, r26
    1d72:	08 f0       	brcs	.+2      	; 0x1d76 <__vector_14+0xe0>
    1d74:	50 e0       	ldi	r21, 0x00	; 0
    1d76:	a6 2f       	mov	r26, r22
    1d78:	ab 0d       	add	r26, r11
    1d7a:	61 e0       	ldi	r22, 0x01	; 1
    1d7c:	ab 15       	cp	r26, r11
    1d7e:	08 f0       	brcs	.+2      	; 0x1d82 <__vector_14+0xec>
    1d80:	60 e0       	ldi	r22, 0x00	; 0
    1d82:	56 2b       	or	r21, r22
    1d84:	cf 0e       	add	r12, r31
    1d86:	61 e0       	ldi	r22, 0x01	; 1
    1d88:	cf 16       	cp	r12, r31
    1d8a:	08 f0       	brcs	.+2      	; 0x1d8e <__vector_14+0xf8>
    1d8c:	60 e0       	ldi	r22, 0x00	; 0
    1d8e:	f5 2f       	mov	r31, r21
    1d90:	fc 0d       	add	r31, r12
    1d92:	51 e0       	ldi	r21, 0x01	; 1
    1d94:	fc 15       	cp	r31, r12
    1d96:	08 f0       	brcs	.+2      	; 0x1d9a <__vector_14+0x104>
    1d98:	50 e0       	ldi	r21, 0x00	; 0
    1d9a:	65 2b       	or	r22, r21
    1d9c:	de 0e       	add	r13, r30
    1d9e:	51 e0       	ldi	r21, 0x01	; 1
    1da0:	de 16       	cp	r13, r30
    1da2:	08 f0       	brcs	.+2      	; 0x1da6 <__vector_14+0x110>
    1da4:	50 e0       	ldi	r21, 0x00	; 0
    1da6:	e6 2f       	mov	r30, r22
    1da8:	ed 0d       	add	r30, r13
    1daa:	61 e0       	ldi	r22, 0x01	; 1
    1dac:	ed 15       	cp	r30, r13
    1dae:	08 f0       	brcs	.+2      	; 0x1db2 <__vector_14+0x11c>
    1db0:	60 e0       	ldi	r22, 0x00	; 0
    1db2:	56 2b       	or	r21, r22
    1db4:	e6 0c       	add	r14, r6
    1db6:	71 e0       	ldi	r23, 0x01	; 1
    1db8:	e6 14       	cp	r14, r6
    1dba:	08 f0       	brcs	.+2      	; 0x1dbe <__vector_14+0x128>
    1dbc:	70 e0       	ldi	r23, 0x00	; 0
    1dbe:	b5 2f       	mov	r27, r21
    1dc0:	be 0d       	add	r27, r14
    1dc2:	51 e0       	ldi	r21, 0x01	; 1
    1dc4:	be 15       	cp	r27, r14
    1dc6:	08 f0       	brcs	.+2      	; 0x1dca <__vector_14+0x134>
    1dc8:	50 e0       	ldi	r21, 0x00	; 0
    1dca:	75 2b       	or	r23, r21
    1dcc:	f7 0c       	add	r15, r7
    1dce:	61 e0       	ldi	r22, 0x01	; 1
    1dd0:	f7 14       	cp	r15, r7
    1dd2:	08 f0       	brcs	.+2      	; 0x1dd6 <__vector_14+0x140>
    1dd4:	60 e0       	ldi	r22, 0x00	; 0
    1dd6:	7f 0d       	add	r23, r15
    1dd8:	51 e0       	ldi	r21, 0x01	; 1
    1dda:	7f 15       	cp	r23, r15
    1ddc:	08 f0       	brcs	.+2      	; 0x1de0 <__vector_14+0x14a>
    1dde:	50 e0       	ldi	r21, 0x00	; 0
    1de0:	65 2b       	or	r22, r21
    1de2:	09 0d       	add	r16, r9
    1de4:	51 e0       	ldi	r21, 0x01	; 1
    1de6:	09 15       	cp	r16, r9
    1de8:	08 f0       	brcs	.+2      	; 0x1dec <__vector_14+0x156>
    1dea:	50 e0       	ldi	r21, 0x00	; 0
    1dec:	60 0f       	add	r22, r16
    1dee:	ff 24       	eor	r15, r15
    1df0:	f3 94       	inc	r15
    1df2:	60 17       	cp	r22, r16
    1df4:	08 f0       	brcs	.+2      	; 0x1df8 <__vector_14+0x162>
    1df6:	ff 24       	eor	r15, r15
    1df8:	5f 29       	or	r21, r15
    1dfa:	41 0f       	add	r20, r17
    1dfc:	54 0f       	add	r21, r20
    1dfe:	a9 82       	std	Y+1, r10	; 0x01
    1e00:	aa 83       	std	Y+2, r26	; 0x02
    1e02:	fb 83       	std	Y+3, r31	; 0x03
    1e04:	ec 83       	std	Y+4, r30	; 0x04
    1e06:	bd 83       	std	Y+5, r27	; 0x05
    1e08:	7e 83       	std	Y+6, r23	; 0x06
    1e0a:	6f 83       	std	Y+7, r22	; 0x07
    1e0c:	58 87       	std	Y+8, r21	; 0x08
    1e0e:	03 96       	adiw	r24, 0x03	; 3
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1e10:	8c 30       	cpi	r24, 0x0C	; 12
    1e12:	91 05       	cpc	r25, r1
    1e14:	09 f0       	breq	.+2      	; 0x1e18 <__vector_14+0x182>
    1e16:	73 cf       	rjmp	.-282    	; 0x1cfe <__vector_14+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    1e18:	e9 80       	ldd	r14, Y+1	; 0x01
    1e1a:	fa 80       	ldd	r15, Y+2	; 0x02
    1e1c:	0b 81       	ldd	r16, Y+3	; 0x03
    1e1e:	1c 81       	ldd	r17, Y+4	; 0x04
    1e20:	bd 81       	ldd	r27, Y+5	; 0x05
    1e22:	ae 81       	ldd	r26, Y+6	; 0x06
    1e24:	ff 81       	ldd	r31, Y+7	; 0x07
    1e26:	e8 85       	ldd	r30, Y+8	; 0x08
    1e28:	2e 2d       	mov	r18, r14
    1e2a:	3f 2d       	mov	r19, r15
    1e2c:	40 2f       	mov	r20, r16
    1e2e:	51 2f       	mov	r21, r17
    1e30:	6b 2f       	mov	r22, r27
    1e32:	7a 2f       	mov	r23, r26
    1e34:	8f 2f       	mov	r24, r31
    1e36:	9e 2f       	mov	r25, r30
    1e38:	ee 23       	and	r30, r30
    1e3a:	0c f0       	brlt	.+2      	; 0x1e3e <__vector_14+0x1a8>
    1e3c:	4a c0       	rjmp	.+148    	; 0x1ed2 <__vector_14+0x23c>
    1e3e:	93 e0       	ldi	r25, 0x03	; 3
    1e40:	e9 0e       	add	r14, r25
    1e42:	91 e0       	ldi	r25, 0x01	; 1
    1e44:	e2 16       	cp	r14, r18
    1e46:	08 f0       	brcs	.+2      	; 0x1e4a <__vector_14+0x1b4>
    1e48:	90 e0       	ldi	r25, 0x00	; 0
    1e4a:	21 e0       	ldi	r18, 0x01	; 1
    1e4c:	f3 16       	cp	r15, r19
    1e4e:	08 f0       	brcs	.+2      	; 0x1e52 <__vector_14+0x1bc>
    1e50:	20 e0       	ldi	r18, 0x00	; 0
    1e52:	39 2f       	mov	r19, r25
    1e54:	3f 0d       	add	r19, r15
    1e56:	91 e0       	ldi	r25, 0x01	; 1
    1e58:	3f 15       	cp	r19, r15
    1e5a:	08 f0       	brcs	.+2      	; 0x1e5e <__vector_14+0x1c8>
    1e5c:	90 e0       	ldi	r25, 0x00	; 0
    1e5e:	29 2b       	or	r18, r25
    1e60:	91 e0       	ldi	r25, 0x01	; 1
    1e62:	04 17       	cp	r16, r20
    1e64:	08 f0       	brcs	.+2      	; 0x1e68 <__vector_14+0x1d2>
    1e66:	90 e0       	ldi	r25, 0x00	; 0
    1e68:	42 2f       	mov	r20, r18
    1e6a:	40 0f       	add	r20, r16
    1e6c:	21 e0       	ldi	r18, 0x01	; 1
    1e6e:	40 17       	cp	r20, r16
    1e70:	08 f0       	brcs	.+2      	; 0x1e74 <__vector_14+0x1de>
    1e72:	20 e0       	ldi	r18, 0x00	; 0
    1e74:	92 2b       	or	r25, r18
    1e76:	21 e0       	ldi	r18, 0x01	; 1
    1e78:	15 17       	cp	r17, r21
    1e7a:	08 f0       	brcs	.+2      	; 0x1e7e <__vector_14+0x1e8>
    1e7c:	20 e0       	ldi	r18, 0x00	; 0
    1e7e:	59 2f       	mov	r21, r25
    1e80:	51 0f       	add	r21, r17
    1e82:	91 e0       	ldi	r25, 0x01	; 1
    1e84:	51 17       	cp	r21, r17
    1e86:	08 f0       	brcs	.+2      	; 0x1e8a <__vector_14+0x1f4>
    1e88:	90 e0       	ldi	r25, 0x00	; 0
    1e8a:	29 2b       	or	r18, r25
    1e8c:	91 e0       	ldi	r25, 0x01	; 1
    1e8e:	b6 17       	cp	r27, r22
    1e90:	08 f0       	brcs	.+2      	; 0x1e94 <__vector_14+0x1fe>
    1e92:	90 e0       	ldi	r25, 0x00	; 0
    1e94:	62 2f       	mov	r22, r18
    1e96:	6b 0f       	add	r22, r27
    1e98:	21 e0       	ldi	r18, 0x01	; 1
    1e9a:	6b 17       	cp	r22, r27
    1e9c:	08 f0       	brcs	.+2      	; 0x1ea0 <__vector_14+0x20a>
    1e9e:	20 e0       	ldi	r18, 0x00	; 0
    1ea0:	92 2b       	or	r25, r18
    1ea2:	21 e0       	ldi	r18, 0x01	; 1
    1ea4:	a7 17       	cp	r26, r23
    1ea6:	08 f0       	brcs	.+2      	; 0x1eaa <__vector_14+0x214>
    1ea8:	20 e0       	ldi	r18, 0x00	; 0
    1eaa:	79 2f       	mov	r23, r25
    1eac:	7a 0f       	add	r23, r26
    1eae:	91 e0       	ldi	r25, 0x01	; 1
    1eb0:	7a 17       	cp	r23, r26
    1eb2:	08 f0       	brcs	.+2      	; 0x1eb6 <__vector_14+0x220>
    1eb4:	90 e0       	ldi	r25, 0x00	; 0
    1eb6:	29 2b       	or	r18, r25
    1eb8:	91 e0       	ldi	r25, 0x01	; 1
    1eba:	f8 17       	cp	r31, r24
    1ebc:	08 f0       	brcs	.+2      	; 0x1ec0 <__vector_14+0x22a>
    1ebe:	90 e0       	ldi	r25, 0x00	; 0
    1ec0:	82 2f       	mov	r24, r18
    1ec2:	8f 0f       	add	r24, r31
    1ec4:	21 e0       	ldi	r18, 0x01	; 1
    1ec6:	8f 17       	cp	r24, r31
    1ec8:	08 f0       	brcs	.+2      	; 0x1ecc <__vector_14+0x236>
    1eca:	20 e0       	ldi	r18, 0x00	; 0
    1ecc:	92 2b       	or	r25, r18
    1ece:	2e 2d       	mov	r18, r14
    1ed0:	9e 0f       	add	r25, r30
    1ed2:	02 e0       	ldi	r16, 0x02	; 2
    1ed4:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__ashrdi3>
    1ed8:	29 83       	std	Y+1, r18	; 0x01
    1eda:	3a 83       	std	Y+2, r19	; 0x02
    1edc:	4b 83       	std	Y+3, r20	; 0x03
    1ede:	5c 83       	std	Y+4, r21	; 0x04
    1ee0:	6d 83       	std	Y+5, r22	; 0x05
    1ee2:	7e 83       	std	Y+6, r23	; 0x06
    1ee4:	8f 83       	std	Y+7, r24	; 0x07
    1ee6:	98 87       	std	Y+8, r25	; 0x08
	ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1ee8:	60 91 66 50 	lds	r22, 0x5066
    1eec:	70 91 67 50 	lds	r23, 0x5067
    1ef0:	80 91 68 50 	lds	r24, 0x5068
    1ef4:	90 91 69 50 	lds	r25, 0x5069
    1ef8:	19 81       	ldd	r17, Y+1	; 0x01
    1efa:	0a 81       	ldd	r16, Y+2	; 0x02
    1efc:	fb 80       	ldd	r15, Y+3	; 0x03
    1efe:	ec 80       	ldd	r14, Y+4	; 0x04
    1f00:	dd 80       	ldd	r13, Y+5	; 0x05
    1f02:	ce 80       	ldd	r12, Y+6	; 0x06
    1f04:	bf 80       	ldd	r11, Y+7	; 0x07
    1f06:	a8 84       	ldd	r10, Y+8	; 0x08
    1f08:	20 91 a8 50 	lds	r18, 0x50A8
    1f0c:	30 91 a9 50 	lds	r19, 0x50A9
    1f10:	40 e0       	ldi	r20, 0x00	; 0
    1f12:	50 e0       	ldi	r21, 0x00	; 0
    1f14:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    1f18:	dc 01       	movw	r26, r24
    1f1a:	cb 01       	movw	r24, r22
    1f1c:	88 0f       	add	r24, r24
    1f1e:	99 1f       	adc	r25, r25
    1f20:	88 0f       	add	r24, r24
    1f22:	99 1f       	adc	r25, r25
    1f24:	80 90 64 50 	lds	r8, 0x5064
    1f28:	90 90 65 50 	lds	r9, 0x5065
    1f2c:	88 0e       	add	r8, r24
    1f2e:	99 1e       	adc	r9, r25
    1f30:	21 2f       	mov	r18, r17
    1f32:	30 2f       	mov	r19, r16
    1f34:	4f 2d       	mov	r20, r15
    1f36:	5e 2d       	mov	r21, r14
    1f38:	6d 2d       	mov	r22, r13
    1f3a:	7c 2d       	mov	r23, r12
    1f3c:	8b 2d       	mov	r24, r11
    1f3e:	9a 2d       	mov	r25, r10
    1f40:	0f 2e       	mov	r0, r31
    1f42:	f0 ea       	ldi	r31, 0xA0	; 160
    1f44:	af 2e       	mov	r10, r31
    1f46:	f0 2d       	mov	r31, r0
    1f48:	0f 2e       	mov	r0, r31
    1f4a:	f5 e2       	ldi	r31, 0x25	; 37
    1f4c:	bf 2e       	mov	r11, r31
    1f4e:	f0 2d       	mov	r31, r0
    1f50:	0f 2e       	mov	r0, r31
    1f52:	f6 e2       	ldi	r31, 0x26	; 38
    1f54:	cf 2e       	mov	r12, r31
    1f56:	f0 2d       	mov	r31, r0
    1f58:	dd 24       	eor	r13, r13
    1f5a:	ee 24       	eor	r14, r14
    1f5c:	ff 24       	eor	r15, r15
    1f5e:	00 e0       	ldi	r16, 0x00	; 0
    1f60:	10 e0       	ldi	r17, 0x00	; 0
    1f62:	0e 94 17 2e 	call	0x5c2e	; 0x5c2e <__muldi3>
    1f66:	aa 24       	eor	r10, r10
    1f68:	aa 94       	dec	r10
    1f6a:	bb 24       	eor	r11, r11
    1f6c:	ba 94       	dec	r11
    1f6e:	0f 2e       	mov	r0, r31
    1f70:	ff e7       	ldi	r31, 0x7F	; 127
    1f72:	cf 2e       	mov	r12, r31
    1f74:	f0 2d       	mov	r31, r0
    1f76:	0e 94 c6 2f 	call	0x5f8c	; 0x5f8c <__divdi3>
    1f7a:	01 e0       	ldi	r16, 0x01	; 1
    1f7c:	0e 94 ea 2e 	call	0x5dd4	; 0x5dd4 <__ashldi3>
    1f80:	0f 2e       	mov	r0, r31
    1f82:	f3 e0       	ldi	r31, 0x03	; 3
    1f84:	af 2e       	mov	r10, r31
    1f86:	f0 2d       	mov	r31, r0
    1f88:	bb 24       	eor	r11, r11
    1f8a:	cc 24       	eor	r12, r12
    1f8c:	00 e0       	ldi	r16, 0x00	; 0
    1f8e:	0e 94 c6 2f 	call	0x5f8c	; 0x5f8c <__divdi3>
    1f92:	f4 01       	movw	r30, r8
    1f94:	20 83       	st	Z, r18
    1f96:	31 83       	std	Z+1, r19	; 0x01
    1f98:	42 83       	std	Z+2, r20	; 0x02
    1f9a:	53 83       	std	Z+3, r21	; 0x03
	if(write_to_FRAM){
    1f9c:	80 91 49 40 	lds	r24, 0x4049
    1fa0:	88 23       	and	r24, r24
    1fa2:	09 f1       	breq	.+66     	; 0x1fe6 <__vector_14+0x350>
		writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    1fa4:	60 91 66 50 	lds	r22, 0x5066
    1fa8:	70 91 67 50 	lds	r23, 0x5067
    1fac:	80 91 68 50 	lds	r24, 0x5068
    1fb0:	90 91 69 50 	lds	r25, 0x5069
    1fb4:	20 91 a8 50 	lds	r18, 0x50A8
    1fb8:	30 91 a9 50 	lds	r19, 0x50A9
    1fbc:	40 e0       	ldi	r20, 0x00	; 0
    1fbe:	50 e0       	ldi	r21, 0x00	; 0
    1fc0:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    1fc4:	dc 01       	movw	r26, r24
    1fc6:	cb 01       	movw	r24, r22
    1fc8:	9c 01       	movw	r18, r24
    1fca:	22 0f       	add	r18, r18
    1fcc:	33 1f       	adc	r19, r19
    1fce:	22 0f       	add	r18, r18
    1fd0:	33 1f       	adc	r19, r19
    1fd2:	80 91 64 50 	lds	r24, 0x5064
    1fd6:	90 91 65 50 	lds	r25, 0x5065
    1fda:	82 0f       	add	r24, r18
    1fdc:	93 1f       	adc	r25, r19
    1fde:	64 e0       	ldi	r22, 0x04	; 4
    1fe0:	70 e0       	ldi	r23, 0x00	; 0
    1fe2:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
	}
	sampleCount++;
    1fe6:	80 91 66 50 	lds	r24, 0x5066
    1fea:	90 91 67 50 	lds	r25, 0x5067
    1fee:	a0 91 68 50 	lds	r26, 0x5068
    1ff2:	b0 91 69 50 	lds	r27, 0x5069
    1ff6:	01 96       	adiw	r24, 0x01	; 1
    1ff8:	a1 1d       	adc	r26, r1
    1ffa:	b1 1d       	adc	r27, r1
    1ffc:	80 93 66 50 	sts	0x5066, r24
    2000:	90 93 67 50 	sts	0x5067, r25
    2004:	a0 93 68 50 	sts	0x5068, r26
    2008:	b0 93 69 50 	sts	0x5069, r27

}
    200c:	2c 96       	adiw	r28, 0x0c	; 12
    200e:	cd bf       	out	0x3d, r28	; 61
    2010:	de bf       	out	0x3e, r29	; 62
    2012:	df 91       	pop	r29
    2014:	cf 91       	pop	r28
    2016:	ff 91       	pop	r31
    2018:	ef 91       	pop	r30
    201a:	bf 91       	pop	r27
    201c:	af 91       	pop	r26
    201e:	9f 91       	pop	r25
    2020:	8f 91       	pop	r24
    2022:	7f 91       	pop	r23
    2024:	6f 91       	pop	r22
    2026:	5f 91       	pop	r21
    2028:	4f 91       	pop	r20
    202a:	3f 91       	pop	r19
    202c:	2f 91       	pop	r18
    202e:	1f 91       	pop	r17
    2030:	0f 91       	pop	r16
    2032:	ff 90       	pop	r15
    2034:	ef 90       	pop	r14
    2036:	df 90       	pop	r13
    2038:	cf 90       	pop	r12
    203a:	bf 90       	pop	r11
    203c:	af 90       	pop	r10
    203e:	9f 90       	pop	r9
    2040:	8f 90       	pop	r8
    2042:	7f 90       	pop	r7
    2044:	6f 90       	pop	r6
    2046:	0f 90       	pop	r0
    2048:	0b be       	out	0x3b, r0	; 59
    204a:	0f 90       	pop	r0
    204c:	0f be       	out	0x3f, r0	; 63
    204e:	0f 90       	pop	r0
    2050:	1f 90       	pop	r1
    2052:	18 95       	reti

00002054 <__vector_77>:
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    2054:	1f 92       	push	r1
    2056:	0f 92       	push	r0
    2058:	0f b6       	in	r0, 0x3f	; 63
    205a:	0f 92       	push	r0
    205c:	0b b6       	in	r0, 0x3b	; 59
    205e:	0f 92       	push	r0
    2060:	11 24       	eor	r1, r1
    2062:	6f 92       	push	r6
    2064:	7f 92       	push	r7
    2066:	8f 92       	push	r8
    2068:	9f 92       	push	r9
    206a:	af 92       	push	r10
    206c:	bf 92       	push	r11
    206e:	cf 92       	push	r12
    2070:	df 92       	push	r13
    2072:	ef 92       	push	r14
    2074:	ff 92       	push	r15
    2076:	0f 93       	push	r16
    2078:	1f 93       	push	r17
    207a:	2f 93       	push	r18
    207c:	3f 93       	push	r19
    207e:	4f 93       	push	r20
    2080:	5f 93       	push	r21
    2082:	6f 93       	push	r22
    2084:	7f 93       	push	r23
    2086:	8f 93       	push	r24
    2088:	9f 93       	push	r25
    208a:	af 93       	push	r26
    208c:	bf 93       	push	r27
    208e:	ef 93       	push	r30
    2090:	ff 93       	push	r31
    2092:	cf 93       	push	r28
    2094:	df 93       	push	r29
    2096:	cd b7       	in	r28, 0x3d	; 61
    2098:	de b7       	in	r29, 0x3e	; 62
    209a:	2c 97       	sbiw	r28, 0x0c	; 12
    209c:	cd bf       	out	0x3d, r28	; 61
    209e:	de bf       	out	0x3e, r29	; 62

	volatile int64_t sum = 0;
    20a0:	19 82       	std	Y+1, r1	; 0x01
    20a2:	1a 82       	std	Y+2, r1	; 0x02
    20a4:	1b 82       	std	Y+3, r1	; 0x03
    20a6:	1c 82       	std	Y+4, r1	; 0x04
    20a8:	1d 82       	std	Y+5, r1	; 0x05
    20aa:	1e 82       	std	Y+6, r1	; 0x06
    20ac:	1f 82       	std	Y+7, r1	; 0x07
    20ae:	18 86       	std	Y+8, r1	; 0x08
    20b0:	80 e0       	ldi	r24, 0x00	; 0
    20b2:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    20b4:	21 e2       	ldi	r18, 0x21	; 33
    20b6:	3e e3       	ldi	r19, 0x3E	; 62
    20b8:	88 24       	eor	r8, r8
    20ba:	8a 94       	dec	r8
    20bc:	ac 01       	movw	r20, r24
    20be:	f9 01       	movw	r30, r18
    20c0:	e8 0f       	add	r30, r24
    20c2:	f9 1f       	adc	r31, r25
    20c4:	60 81       	ld	r22, Z
    20c6:	66 23       	and	r22, r22
    20c8:	14 f4       	brge	.+4      	; 0x20ce <__vector_77+0x7a>
    20ca:	8c 86       	std	Y+12, r8	; 0x0c
    20cc:	01 c0       	rjmp	.+2      	; 0x20d0 <__vector_77+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    20ce:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    20d0:	42 0f       	add	r20, r18
    20d2:	53 1f       	adc	r21, r19
    20d4:	fa 01       	movw	r30, r20
    20d6:	40 81       	ld	r20, Z
    20d8:	4b 87       	std	Y+11, r20	; 0x0b
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    20da:	fc 01       	movw	r30, r24
    20dc:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    20de:	e2 0f       	add	r30, r18
    20e0:	f3 1f       	adc	r31, r19
    20e2:	40 81       	ld	r20, Z
    20e4:	4a 87       	std	Y+10, r20	; 0x0a
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    20e6:	fc 01       	movw	r30, r24
    20e8:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    20ea:	e2 0f       	add	r30, r18
    20ec:	f3 1f       	adc	r31, r19
    20ee:	40 81       	ld	r20, Z
    20f0:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    20f2:	49 85       	ldd	r20, Y+9	; 0x09
    20f4:	5a 85       	ldd	r21, Y+10	; 0x0a
    20f6:	6b 85       	ldd	r22, Y+11	; 0x0b
    20f8:	7c 85       	ldd	r23, Y+12	; 0x0c
    20fa:	a9 80       	ldd	r10, Y+1	; 0x01
    20fc:	ba 80       	ldd	r11, Y+2	; 0x02
    20fe:	cb 80       	ldd	r12, Y+3	; 0x03
    2100:	dc 80       	ldd	r13, Y+4	; 0x04
    2102:	ed 80       	ldd	r14, Y+5	; 0x05
    2104:	fe 80       	ldd	r15, Y+6	; 0x06
    2106:	0f 81       	ldd	r16, Y+7	; 0x07
    2108:	18 85       	ldd	r17, Y+8	; 0x08
    210a:	b4 2f       	mov	r27, r20
    210c:	a5 2f       	mov	r26, r21
    210e:	f6 2f       	mov	r31, r22
    2110:	e7 2f       	mov	r30, r23
    2112:	77 0f       	add	r23, r23
    2114:	44 0b       	sbc	r20, r20
    2116:	54 2f       	mov	r21, r20
    2118:	ba 01       	movw	r22, r20
    211a:	64 2e       	mov	r6, r20
    211c:	74 2e       	mov	r7, r20
    211e:	94 2e       	mov	r9, r20
    2120:	ab 0e       	add	r10, r27
    2122:	61 e0       	ldi	r22, 0x01	; 1
    2124:	ab 16       	cp	r10, r27
    2126:	08 f0       	brcs	.+2      	; 0x212a <__vector_77+0xd6>
    2128:	60 e0       	ldi	r22, 0x00	; 0
    212a:	ba 0e       	add	r11, r26
    212c:	51 e0       	ldi	r21, 0x01	; 1
    212e:	ba 16       	cp	r11, r26
    2130:	08 f0       	brcs	.+2      	; 0x2134 <__vector_77+0xe0>
    2132:	50 e0       	ldi	r21, 0x00	; 0
    2134:	a6 2f       	mov	r26, r22
    2136:	ab 0d       	add	r26, r11
    2138:	61 e0       	ldi	r22, 0x01	; 1
    213a:	ab 15       	cp	r26, r11
    213c:	08 f0       	brcs	.+2      	; 0x2140 <__vector_77+0xec>
    213e:	60 e0       	ldi	r22, 0x00	; 0
    2140:	56 2b       	or	r21, r22
    2142:	cf 0e       	add	r12, r31
    2144:	61 e0       	ldi	r22, 0x01	; 1
    2146:	cf 16       	cp	r12, r31
    2148:	08 f0       	brcs	.+2      	; 0x214c <__vector_77+0xf8>
    214a:	60 e0       	ldi	r22, 0x00	; 0
    214c:	f5 2f       	mov	r31, r21
    214e:	fc 0d       	add	r31, r12
    2150:	51 e0       	ldi	r21, 0x01	; 1
    2152:	fc 15       	cp	r31, r12
    2154:	08 f0       	brcs	.+2      	; 0x2158 <__vector_77+0x104>
    2156:	50 e0       	ldi	r21, 0x00	; 0
    2158:	65 2b       	or	r22, r21
    215a:	de 0e       	add	r13, r30
    215c:	51 e0       	ldi	r21, 0x01	; 1
    215e:	de 16       	cp	r13, r30
    2160:	08 f0       	brcs	.+2      	; 0x2164 <__vector_77+0x110>
    2162:	50 e0       	ldi	r21, 0x00	; 0
    2164:	e6 2f       	mov	r30, r22
    2166:	ed 0d       	add	r30, r13
    2168:	61 e0       	ldi	r22, 0x01	; 1
    216a:	ed 15       	cp	r30, r13
    216c:	08 f0       	brcs	.+2      	; 0x2170 <__vector_77+0x11c>
    216e:	60 e0       	ldi	r22, 0x00	; 0
    2170:	56 2b       	or	r21, r22
    2172:	e6 0c       	add	r14, r6
    2174:	71 e0       	ldi	r23, 0x01	; 1
    2176:	e6 14       	cp	r14, r6
    2178:	08 f0       	brcs	.+2      	; 0x217c <__vector_77+0x128>
    217a:	70 e0       	ldi	r23, 0x00	; 0
    217c:	b5 2f       	mov	r27, r21
    217e:	be 0d       	add	r27, r14
    2180:	51 e0       	ldi	r21, 0x01	; 1
    2182:	be 15       	cp	r27, r14
    2184:	08 f0       	brcs	.+2      	; 0x2188 <__vector_77+0x134>
    2186:	50 e0       	ldi	r21, 0x00	; 0
    2188:	75 2b       	or	r23, r21
    218a:	f7 0c       	add	r15, r7
    218c:	61 e0       	ldi	r22, 0x01	; 1
    218e:	f7 14       	cp	r15, r7
    2190:	08 f0       	brcs	.+2      	; 0x2194 <__vector_77+0x140>
    2192:	60 e0       	ldi	r22, 0x00	; 0
    2194:	7f 0d       	add	r23, r15
    2196:	51 e0       	ldi	r21, 0x01	; 1
    2198:	7f 15       	cp	r23, r15
    219a:	08 f0       	brcs	.+2      	; 0x219e <__vector_77+0x14a>
    219c:	50 e0       	ldi	r21, 0x00	; 0
    219e:	65 2b       	or	r22, r21
    21a0:	09 0d       	add	r16, r9
    21a2:	51 e0       	ldi	r21, 0x01	; 1
    21a4:	09 15       	cp	r16, r9
    21a6:	08 f0       	brcs	.+2      	; 0x21aa <__vector_77+0x156>
    21a8:	50 e0       	ldi	r21, 0x00	; 0
    21aa:	60 0f       	add	r22, r16
    21ac:	ff 24       	eor	r15, r15
    21ae:	f3 94       	inc	r15
    21b0:	60 17       	cp	r22, r16
    21b2:	08 f0       	brcs	.+2      	; 0x21b6 <__vector_77+0x162>
    21b4:	ff 24       	eor	r15, r15
    21b6:	5f 29       	or	r21, r15
    21b8:	41 0f       	add	r20, r17
    21ba:	54 0f       	add	r21, r20
    21bc:	a9 82       	std	Y+1, r10	; 0x01
    21be:	aa 83       	std	Y+2, r26	; 0x02
    21c0:	fb 83       	std	Y+3, r31	; 0x03
    21c2:	ec 83       	std	Y+4, r30	; 0x04
    21c4:	bd 83       	std	Y+5, r27	; 0x05
    21c6:	7e 83       	std	Y+6, r23	; 0x06
    21c8:	6f 83       	std	Y+7, r22	; 0x07
    21ca:	58 87       	std	Y+8, r21	; 0x08
    21cc:	03 96       	adiw	r24, 0x03	; 3
ISR(TCD0_OVF_vect) {

	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    21ce:	8c 30       	cpi	r24, 0x0C	; 12
    21d0:	91 05       	cpc	r25, r1
    21d2:	09 f0       	breq	.+2      	; 0x21d6 <__vector_77+0x182>
    21d4:	73 cf       	rjmp	.-282    	; 0x20bc <__vector_77+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    21d6:	e9 80       	ldd	r14, Y+1	; 0x01
    21d8:	fa 80       	ldd	r15, Y+2	; 0x02
    21da:	0b 81       	ldd	r16, Y+3	; 0x03
    21dc:	1c 81       	ldd	r17, Y+4	; 0x04
    21de:	bd 81       	ldd	r27, Y+5	; 0x05
    21e0:	ae 81       	ldd	r26, Y+6	; 0x06
    21e2:	ff 81       	ldd	r31, Y+7	; 0x07
    21e4:	e8 85       	ldd	r30, Y+8	; 0x08
    21e6:	2e 2d       	mov	r18, r14
    21e8:	3f 2d       	mov	r19, r15
    21ea:	40 2f       	mov	r20, r16
    21ec:	51 2f       	mov	r21, r17
    21ee:	6b 2f       	mov	r22, r27
    21f0:	7a 2f       	mov	r23, r26
    21f2:	8f 2f       	mov	r24, r31
    21f4:	9e 2f       	mov	r25, r30
    21f6:	ee 23       	and	r30, r30
    21f8:	0c f0       	brlt	.+2      	; 0x21fc <__vector_77+0x1a8>
    21fa:	4a c0       	rjmp	.+148    	; 0x2290 <__vector_77+0x23c>
    21fc:	93 e0       	ldi	r25, 0x03	; 3
    21fe:	e9 0e       	add	r14, r25
    2200:	91 e0       	ldi	r25, 0x01	; 1
    2202:	e2 16       	cp	r14, r18
    2204:	08 f0       	brcs	.+2      	; 0x2208 <__vector_77+0x1b4>
    2206:	90 e0       	ldi	r25, 0x00	; 0
    2208:	21 e0       	ldi	r18, 0x01	; 1
    220a:	f3 16       	cp	r15, r19
    220c:	08 f0       	brcs	.+2      	; 0x2210 <__vector_77+0x1bc>
    220e:	20 e0       	ldi	r18, 0x00	; 0
    2210:	39 2f       	mov	r19, r25
    2212:	3f 0d       	add	r19, r15
    2214:	91 e0       	ldi	r25, 0x01	; 1
    2216:	3f 15       	cp	r19, r15
    2218:	08 f0       	brcs	.+2      	; 0x221c <__vector_77+0x1c8>
    221a:	90 e0       	ldi	r25, 0x00	; 0
    221c:	29 2b       	or	r18, r25
    221e:	91 e0       	ldi	r25, 0x01	; 1
    2220:	04 17       	cp	r16, r20
    2222:	08 f0       	brcs	.+2      	; 0x2226 <__vector_77+0x1d2>
    2224:	90 e0       	ldi	r25, 0x00	; 0
    2226:	42 2f       	mov	r20, r18
    2228:	40 0f       	add	r20, r16
    222a:	21 e0       	ldi	r18, 0x01	; 1
    222c:	40 17       	cp	r20, r16
    222e:	08 f0       	brcs	.+2      	; 0x2232 <__vector_77+0x1de>
    2230:	20 e0       	ldi	r18, 0x00	; 0
    2232:	92 2b       	or	r25, r18
    2234:	21 e0       	ldi	r18, 0x01	; 1
    2236:	15 17       	cp	r17, r21
    2238:	08 f0       	brcs	.+2      	; 0x223c <__vector_77+0x1e8>
    223a:	20 e0       	ldi	r18, 0x00	; 0
    223c:	59 2f       	mov	r21, r25
    223e:	51 0f       	add	r21, r17
    2240:	91 e0       	ldi	r25, 0x01	; 1
    2242:	51 17       	cp	r21, r17
    2244:	08 f0       	brcs	.+2      	; 0x2248 <__vector_77+0x1f4>
    2246:	90 e0       	ldi	r25, 0x00	; 0
    2248:	29 2b       	or	r18, r25
    224a:	91 e0       	ldi	r25, 0x01	; 1
    224c:	b6 17       	cp	r27, r22
    224e:	08 f0       	brcs	.+2      	; 0x2252 <__vector_77+0x1fe>
    2250:	90 e0       	ldi	r25, 0x00	; 0
    2252:	62 2f       	mov	r22, r18
    2254:	6b 0f       	add	r22, r27
    2256:	21 e0       	ldi	r18, 0x01	; 1
    2258:	6b 17       	cp	r22, r27
    225a:	08 f0       	brcs	.+2      	; 0x225e <__vector_77+0x20a>
    225c:	20 e0       	ldi	r18, 0x00	; 0
    225e:	92 2b       	or	r25, r18
    2260:	21 e0       	ldi	r18, 0x01	; 1
    2262:	a7 17       	cp	r26, r23
    2264:	08 f0       	brcs	.+2      	; 0x2268 <__vector_77+0x214>
    2266:	20 e0       	ldi	r18, 0x00	; 0
    2268:	79 2f       	mov	r23, r25
    226a:	7a 0f       	add	r23, r26
    226c:	91 e0       	ldi	r25, 0x01	; 1
    226e:	7a 17       	cp	r23, r26
    2270:	08 f0       	brcs	.+2      	; 0x2274 <__vector_77+0x220>
    2272:	90 e0       	ldi	r25, 0x00	; 0
    2274:	29 2b       	or	r18, r25
    2276:	91 e0       	ldi	r25, 0x01	; 1
    2278:	f8 17       	cp	r31, r24
    227a:	08 f0       	brcs	.+2      	; 0x227e <__vector_77+0x22a>
    227c:	90 e0       	ldi	r25, 0x00	; 0
    227e:	82 2f       	mov	r24, r18
    2280:	8f 0f       	add	r24, r31
    2282:	21 e0       	ldi	r18, 0x01	; 1
    2284:	8f 17       	cp	r24, r31
    2286:	08 f0       	brcs	.+2      	; 0x228a <__vector_77+0x236>
    2288:	20 e0       	ldi	r18, 0x00	; 0
    228a:	92 2b       	or	r25, r18
    228c:	2e 2d       	mov	r18, r14
    228e:	9e 0f       	add	r25, r30
    2290:	02 e0       	ldi	r16, 0x02	; 2
    2292:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__ashrdi3>
    2296:	29 83       	std	Y+1, r18	; 0x01
    2298:	3a 83       	std	Y+2, r19	; 0x02
    229a:	4b 83       	std	Y+3, r20	; 0x03
    229c:	5c 83       	std	Y+4, r21	; 0x04
    229e:	6d 83       	std	Y+5, r22	; 0x05
    22a0:	7e 83       	std	Y+6, r23	; 0x06
    22a2:	8f 83       	std	Y+7, r24	; 0x07
    22a4:	98 87       	std	Y+8, r25	; 0x08
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    22a6:	60 91 66 50 	lds	r22, 0x5066
    22aa:	70 91 67 50 	lds	r23, 0x5067
    22ae:	80 91 68 50 	lds	r24, 0x5068
    22b2:	90 91 69 50 	lds	r25, 0x5069
    22b6:	19 81       	ldd	r17, Y+1	; 0x01
    22b8:	0a 81       	ldd	r16, Y+2	; 0x02
    22ba:	fb 80       	ldd	r15, Y+3	; 0x03
    22bc:	ec 80       	ldd	r14, Y+4	; 0x04
    22be:	dd 80       	ldd	r13, Y+5	; 0x05
    22c0:	ce 80       	ldd	r12, Y+6	; 0x06
    22c2:	bf 80       	ldd	r11, Y+7	; 0x07
    22c4:	a8 84       	ldd	r10, Y+8	; 0x08
    22c6:	20 91 a8 50 	lds	r18, 0x50A8
    22ca:	30 91 a9 50 	lds	r19, 0x50A9
    22ce:	40 e0       	ldi	r20, 0x00	; 0
    22d0:	50 e0       	ldi	r21, 0x00	; 0
    22d2:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    22d6:	dc 01       	movw	r26, r24
    22d8:	cb 01       	movw	r24, r22
    22da:	88 0f       	add	r24, r24
    22dc:	99 1f       	adc	r25, r25
    22de:	88 0f       	add	r24, r24
    22e0:	99 1f       	adc	r25, r25
    22e2:	80 90 64 50 	lds	r8, 0x5064
    22e6:	90 90 65 50 	lds	r9, 0x5065
    22ea:	88 0e       	add	r8, r24
    22ec:	99 1e       	adc	r9, r25
    22ee:	21 2f       	mov	r18, r17
    22f0:	30 2f       	mov	r19, r16
    22f2:	4f 2d       	mov	r20, r15
    22f4:	5e 2d       	mov	r21, r14
    22f6:	6d 2d       	mov	r22, r13
    22f8:	7c 2d       	mov	r23, r12
    22fa:	8b 2d       	mov	r24, r11
    22fc:	9a 2d       	mov	r25, r10
    22fe:	0f 2e       	mov	r0, r31
    2300:	f0 ea       	ldi	r31, 0xA0	; 160
    2302:	af 2e       	mov	r10, r31
    2304:	f0 2d       	mov	r31, r0
    2306:	0f 2e       	mov	r0, r31
    2308:	f5 e2       	ldi	r31, 0x25	; 37
    230a:	bf 2e       	mov	r11, r31
    230c:	f0 2d       	mov	r31, r0
    230e:	0f 2e       	mov	r0, r31
    2310:	f6 e2       	ldi	r31, 0x26	; 38
    2312:	cf 2e       	mov	r12, r31
    2314:	f0 2d       	mov	r31, r0
    2316:	dd 24       	eor	r13, r13
    2318:	ee 24       	eor	r14, r14
    231a:	ff 24       	eor	r15, r15
    231c:	00 e0       	ldi	r16, 0x00	; 0
    231e:	10 e0       	ldi	r17, 0x00	; 0
    2320:	0e 94 17 2e 	call	0x5c2e	; 0x5c2e <__muldi3>
    2324:	aa 24       	eor	r10, r10
    2326:	aa 94       	dec	r10
    2328:	bb 24       	eor	r11, r11
    232a:	ba 94       	dec	r11
    232c:	0f 2e       	mov	r0, r31
    232e:	ff e7       	ldi	r31, 0x7F	; 127
    2330:	cf 2e       	mov	r12, r31
    2332:	f0 2d       	mov	r31, r0
    2334:	0e 94 c6 2f 	call	0x5f8c	; 0x5f8c <__divdi3>
    2338:	01 e0       	ldi	r16, 0x01	; 1
    233a:	0e 94 ea 2e 	call	0x5dd4	; 0x5dd4 <__ashldi3>
    233e:	0f 2e       	mov	r0, r31
    2340:	f3 e0       	ldi	r31, 0x03	; 3
    2342:	af 2e       	mov	r10, r31
    2344:	f0 2d       	mov	r31, r0
    2346:	bb 24       	eor	r11, r11
    2348:	cc 24       	eor	r12, r12
    234a:	00 e0       	ldi	r16, 0x00	; 0
    234c:	0e 94 c6 2f 	call	0x5f8c	; 0x5f8c <__divdi3>
    2350:	f4 01       	movw	r30, r8
    2352:	20 83       	st	Z, r18
    2354:	31 83       	std	Z+1, r19	; 0x01
    2356:	42 83       	std	Z+2, r20	; 0x02
    2358:	53 83       	std	Z+3, r21	; 0x03
	if(write_to_FRAM){
    235a:	80 91 49 40 	lds	r24, 0x4049
    235e:	88 23       	and	r24, r24
    2360:	09 f1       	breq	.+66     	; 0x23a4 <__vector_77+0x350>
		writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    2362:	60 91 66 50 	lds	r22, 0x5066
    2366:	70 91 67 50 	lds	r23, 0x5067
    236a:	80 91 68 50 	lds	r24, 0x5068
    236e:	90 91 69 50 	lds	r25, 0x5069
    2372:	20 91 a8 50 	lds	r18, 0x50A8
    2376:	30 91 a9 50 	lds	r19, 0x50A9
    237a:	40 e0       	ldi	r20, 0x00	; 0
    237c:	50 e0       	ldi	r21, 0x00	; 0
    237e:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    2382:	dc 01       	movw	r26, r24
    2384:	cb 01       	movw	r24, r22
    2386:	9c 01       	movw	r18, r24
    2388:	22 0f       	add	r18, r18
    238a:	33 1f       	adc	r19, r19
    238c:	22 0f       	add	r18, r18
    238e:	33 1f       	adc	r19, r19
    2390:	80 91 64 50 	lds	r24, 0x5064
    2394:	90 91 65 50 	lds	r25, 0x5065
    2398:	82 0f       	add	r24, r18
    239a:	93 1f       	adc	r25, r19
    239c:	64 e0       	ldi	r22, 0x04	; 4
    239e:	70 e0       	ldi	r23, 0x00	; 0
    23a0:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
	}
	sampleCount++;
    23a4:	80 91 66 50 	lds	r24, 0x5066
    23a8:	90 91 67 50 	lds	r25, 0x5067
    23ac:	a0 91 68 50 	lds	r26, 0x5068
    23b0:	b0 91 69 50 	lds	r27, 0x5069
    23b4:	01 96       	adiw	r24, 0x01	; 1
    23b6:	a1 1d       	adc	r26, r1
    23b8:	b1 1d       	adc	r27, r1
    23ba:	80 93 66 50 	sts	0x5066, r24
    23be:	90 93 67 50 	sts	0x5067, r25
    23c2:	a0 93 68 50 	sts	0x5068, r26
    23c6:	b0 93 69 50 	sts	0x5069, r27
}
    23ca:	2c 96       	adiw	r28, 0x0c	; 12
    23cc:	cd bf       	out	0x3d, r28	; 61
    23ce:	de bf       	out	0x3e, r29	; 62
    23d0:	df 91       	pop	r29
    23d2:	cf 91       	pop	r28
    23d4:	ff 91       	pop	r31
    23d6:	ef 91       	pop	r30
    23d8:	bf 91       	pop	r27
    23da:	af 91       	pop	r26
    23dc:	9f 91       	pop	r25
    23de:	8f 91       	pop	r24
    23e0:	7f 91       	pop	r23
    23e2:	6f 91       	pop	r22
    23e4:	5f 91       	pop	r21
    23e6:	4f 91       	pop	r20
    23e8:	3f 91       	pop	r19
    23ea:	2f 91       	pop	r18
    23ec:	1f 91       	pop	r17
    23ee:	0f 91       	pop	r16
    23f0:	ff 90       	pop	r15
    23f2:	ef 90       	pop	r14
    23f4:	df 90       	pop	r13
    23f6:	cf 90       	pop	r12
    23f8:	bf 90       	pop	r11
    23fa:	af 90       	pop	r10
    23fc:	9f 90       	pop	r9
    23fe:	8f 90       	pop	r8
    2400:	7f 90       	pop	r7
    2402:	6f 90       	pop	r6
    2404:	0f 90       	pop	r0
    2406:	0b be       	out	0x3b, r0	; 59
    2408:	0f 90       	pop	r0
    240a:	0f be       	out	0x3f, r0	; 63
    240c:	0f 90       	pop	r0
    240e:	1f 90       	pop	r1
    2410:	18 95       	reti

00002412 <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
	
	SPICS(TRUE);
    2412:	81 e0       	ldi	r24, 0x01	; 1
    2414:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    2418:	82 e0       	ldi	r24, 0x02	; 2
    241a:	e0 ea       	ldi	r30, 0xA0	; 160
    241c:	f6 e0       	ldi	r31, 0x06	; 6
    241e:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2420:	8a ea       	ldi	r24, 0xAA	; 170
    2422:	e0 ec       	ldi	r30, 0xC0	; 192
    2424:	f8 e0       	ldi	r31, 0x08	; 8
    2426:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2428:	82 81       	ldd	r24, Z+2	; 0x02
    242a:	88 23       	and	r24, r24
    242c:	ec f7       	brge	.-6      	; 0x2428 <sampleCurrentChannel+0x16>
	SPIBuffer[SPICount] = SPIC.DATA;
    242e:	90 91 a1 50 	lds	r25, 0x50A1
    2432:	e0 ec       	ldi	r30, 0xC0	; 192
    2434:	f8 e0       	ldi	r31, 0x08	; 8
    2436:	83 81       	ldd	r24, Z+3	; 0x03
    2438:	a1 e2       	ldi	r26, 0x21	; 33
    243a:	be e3       	ldi	r27, 0x3E	; 62
    243c:	a9 0f       	add	r26, r25
    243e:	b1 1d       	adc	r27, r1
    2440:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2442:	8a ea       	ldi	r24, 0xAA	; 170
    2444:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2446:	82 81       	ldd	r24, Z+2	; 0x02
    2448:	88 23       	and	r24, r24
    244a:	ec f7       	brge	.-6      	; 0x2446 <sampleCurrentChannel+0x34>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    244c:	a0 91 a1 50 	lds	r26, 0x50A1
    2450:	b0 e0       	ldi	r27, 0x00	; 0
    2452:	e0 ec       	ldi	r30, 0xC0	; 192
    2454:	f8 e0       	ldi	r31, 0x08	; 8
    2456:	83 81       	ldd	r24, Z+3	; 0x03
    2458:	ae 5d       	subi	r26, 0xDE	; 222
    245a:	b1 4c       	sbci	r27, 0xC1	; 193
    245c:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    245e:	8a ea       	ldi	r24, 0xAA	; 170
    2460:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2462:	82 81       	ldd	r24, Z+2	; 0x02
    2464:	88 23       	and	r24, r24
    2466:	ec f7       	brge	.-6      	; 0x2462 <sampleCurrentChannel+0x50>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    2468:	e0 91 a1 50 	lds	r30, 0x50A1
    246c:	f0 e0       	ldi	r31, 0x00	; 0
    246e:	a0 ec       	ldi	r26, 0xC0	; 192
    2470:	b8 e0       	ldi	r27, 0x08	; 8
    2472:	13 96       	adiw	r26, 0x03	; 3
    2474:	8c 91       	ld	r24, X
    2476:	ed 5d       	subi	r30, 0xDD	; 221
    2478:	f1 4c       	sbci	r31, 0xC1	; 193
    247a:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    247c:	82 e0       	ldi	r24, 0x02	; 2
    247e:	e0 ea       	ldi	r30, 0xA0	; 160
    2480:	f6 e0       	ldi	r31, 0x06	; 6
    2482:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
    2484:	80 91 a1 50 	lds	r24, 0x50A1
    2488:	8d 5f       	subi	r24, 0xFD	; 253
    248a:	80 93 a1 50 	sts	0x50A1, r24
	SPICS(FALSE);
    248e:	80 e0       	ldi	r24, 0x00	; 0
    2490:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
}
    2494:	08 95       	ret

00002496 <__vector_82>:
ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point
ISR(TCD0_CCD_vect) {
    2496:	1f 92       	push	r1
    2498:	0f 92       	push	r0
    249a:	0f b6       	in	r0, 0x3f	; 63
    249c:	0f 92       	push	r0
    249e:	0b b6       	in	r0, 0x3b	; 59
    24a0:	0f 92       	push	r0
    24a2:	11 24       	eor	r1, r1
    24a4:	2f 93       	push	r18
    24a6:	3f 93       	push	r19
    24a8:	4f 93       	push	r20
    24aa:	5f 93       	push	r21
    24ac:	6f 93       	push	r22
    24ae:	7f 93       	push	r23
    24b0:	8f 93       	push	r24
    24b2:	9f 93       	push	r25
    24b4:	af 93       	push	r26
    24b6:	bf 93       	push	r27
    24b8:	ef 93       	push	r30
    24ba:	ff 93       	push	r31
	sampleCurrentChannel();
    24bc:	0e 94 09 12 	call	0x2412	; 0x2412 <sampleCurrentChannel>
	SPICount = 0;
    24c0:	10 92 a1 50 	sts	0x50A1, r1
}
    24c4:	ff 91       	pop	r31
    24c6:	ef 91       	pop	r30
    24c8:	bf 91       	pop	r27
    24ca:	af 91       	pop	r26
    24cc:	9f 91       	pop	r25
    24ce:	8f 91       	pop	r24
    24d0:	7f 91       	pop	r23
    24d2:	6f 91       	pop	r22
    24d4:	5f 91       	pop	r21
    24d6:	4f 91       	pop	r20
    24d8:	3f 91       	pop	r19
    24da:	2f 91       	pop	r18
    24dc:	0f 90       	pop	r0
    24de:	0b be       	out	0x3b, r0	; 59
    24e0:	0f 90       	pop	r0
    24e2:	0f be       	out	0x3f, r0	; 63
    24e4:	0f 90       	pop	r0
    24e6:	1f 90       	pop	r1
    24e8:	18 95       	reti

000024ea <__vector_81>:
ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCD0_CCC_vect) {
    24ea:	1f 92       	push	r1
    24ec:	0f 92       	push	r0
    24ee:	0f b6       	in	r0, 0x3f	; 63
    24f0:	0f 92       	push	r0
    24f2:	0b b6       	in	r0, 0x3b	; 59
    24f4:	0f 92       	push	r0
    24f6:	11 24       	eor	r1, r1
    24f8:	2f 93       	push	r18
    24fa:	3f 93       	push	r19
    24fc:	4f 93       	push	r20
    24fe:	5f 93       	push	r21
    2500:	6f 93       	push	r22
    2502:	7f 93       	push	r23
    2504:	8f 93       	push	r24
    2506:	9f 93       	push	r25
    2508:	af 93       	push	r26
    250a:	bf 93       	push	r27
    250c:	ef 93       	push	r30
    250e:	ff 93       	push	r31
	sampleCurrentChannel();
    2510:	0e 94 09 12 	call	0x2412	; 0x2412 <sampleCurrentChannel>
}
    2514:	ff 91       	pop	r31
    2516:	ef 91       	pop	r30
    2518:	bf 91       	pop	r27
    251a:	af 91       	pop	r26
    251c:	9f 91       	pop	r25
    251e:	8f 91       	pop	r24
    2520:	7f 91       	pop	r23
    2522:	6f 91       	pop	r22
    2524:	5f 91       	pop	r21
    2526:	4f 91       	pop	r20
    2528:	3f 91       	pop	r19
    252a:	2f 91       	pop	r18
    252c:	0f 90       	pop	r0
    252e:	0b be       	out	0x3b, r0	; 59
    2530:	0f 90       	pop	r0
    2532:	0f be       	out	0x3f, r0	; 63
    2534:	0f 90       	pop	r0
    2536:	1f 90       	pop	r1
    2538:	18 95       	reti

0000253a <__vector_80>:
//first averaging point
ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}
//second averaging point
ISR(TCD0_CCB_vect) {
    253a:	1f 92       	push	r1
    253c:	0f 92       	push	r0
    253e:	0f b6       	in	r0, 0x3f	; 63
    2540:	0f 92       	push	r0
    2542:	0b b6       	in	r0, 0x3b	; 59
    2544:	0f 92       	push	r0
    2546:	11 24       	eor	r1, r1
    2548:	2f 93       	push	r18
    254a:	3f 93       	push	r19
    254c:	4f 93       	push	r20
    254e:	5f 93       	push	r21
    2550:	6f 93       	push	r22
    2552:	7f 93       	push	r23
    2554:	8f 93       	push	r24
    2556:	9f 93       	push	r25
    2558:	af 93       	push	r26
    255a:	bf 93       	push	r27
    255c:	ef 93       	push	r30
    255e:	ff 93       	push	r31
	sampleCurrentChannel();
    2560:	0e 94 09 12 	call	0x2412	; 0x2412 <sampleCurrentChannel>
}
    2564:	ff 91       	pop	r31
    2566:	ef 91       	pop	r30
    2568:	bf 91       	pop	r27
    256a:	af 91       	pop	r26
    256c:	9f 91       	pop	r25
    256e:	8f 91       	pop	r24
    2570:	7f 91       	pop	r23
    2572:	6f 91       	pop	r22
    2574:	5f 91       	pop	r21
    2576:	4f 91       	pop	r20
    2578:	3f 91       	pop	r19
    257a:	2f 91       	pop	r18
    257c:	0f 90       	pop	r0
    257e:	0b be       	out	0x3b, r0	; 59
    2580:	0f 90       	pop	r0
    2582:	0f be       	out	0x3f, r0	; 63
    2584:	0f 90       	pop	r0
    2586:	1f 90       	pop	r1
    2588:	18 95       	reti

0000258a <__vector_79>:
// 	enableADCMUX(FALSE);
	
}

//first averaging point
ISR(TCD0_CCA_vect) {
    258a:	1f 92       	push	r1
    258c:	0f 92       	push	r0
    258e:	0f b6       	in	r0, 0x3f	; 63
    2590:	0f 92       	push	r0
    2592:	0b b6       	in	r0, 0x3b	; 59
    2594:	0f 92       	push	r0
    2596:	11 24       	eor	r1, r1
    2598:	2f 93       	push	r18
    259a:	3f 93       	push	r19
    259c:	4f 93       	push	r20
    259e:	5f 93       	push	r21
    25a0:	6f 93       	push	r22
    25a2:	7f 93       	push	r23
    25a4:	8f 93       	push	r24
    25a6:	9f 93       	push	r25
    25a8:	af 93       	push	r26
    25aa:	bf 93       	push	r27
    25ac:	ef 93       	push	r30
    25ae:	ff 93       	push	r31
	sampleCurrentChannel();
    25b0:	0e 94 09 12 	call	0x2412	; 0x2412 <sampleCurrentChannel>
}
    25b4:	ff 91       	pop	r31
    25b6:	ef 91       	pop	r30
    25b8:	bf 91       	pop	r27
    25ba:	af 91       	pop	r26
    25bc:	9f 91       	pop	r25
    25be:	8f 91       	pop	r24
    25c0:	7f 91       	pop	r23
    25c2:	6f 91       	pop	r22
    25c4:	5f 91       	pop	r21
    25c6:	4f 91       	pop	r20
    25c8:	3f 91       	pop	r19
    25ca:	2f 91       	pop	r18
    25cc:	0f 90       	pop	r0
    25ce:	0b be       	out	0x3b, r0	; 59
    25d0:	0f 90       	pop	r0
    25d2:	0f be       	out	0x3f, r0	; 63
    25d4:	0f 90       	pop	r0
    25d6:	1f 90       	pop	r1
    25d8:	18 95       	reti

000025da <__vector_19>:
ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    25da:	1f 92       	push	r1
    25dc:	0f 92       	push	r0
    25de:	0f b6       	in	r0, 0x3f	; 63
    25e0:	0f 92       	push	r0
    25e2:	0b b6       	in	r0, 0x3b	; 59
    25e4:	0f 92       	push	r0
    25e6:	11 24       	eor	r1, r1
    25e8:	2f 93       	push	r18
    25ea:	3f 93       	push	r19
    25ec:	4f 93       	push	r20
    25ee:	5f 93       	push	r21
    25f0:	6f 93       	push	r22
    25f2:	7f 93       	push	r23
    25f4:	8f 93       	push	r24
    25f6:	9f 93       	push	r25
    25f8:	af 93       	push	r26
    25fa:	bf 93       	push	r27
    25fc:	ef 93       	push	r30
    25fe:	ff 93       	push	r31
	sampleCurrentChannel();
    2600:	0e 94 09 12 	call	0x2412	; 0x2412 <sampleCurrentChannel>
	SPICount = 0;
    2604:	10 92 a1 50 	sts	0x50A1, r1
	if(PORTB.OUT & PIN1_bm) {
    2608:	e0 e2       	ldi	r30, 0x20	; 32
    260a:	f6 e0       	ldi	r31, 0x06	; 6
    260c:	84 81       	ldd	r24, Z+4	; 0x04
    260e:	81 ff       	sbrs	r24, 1
    2610:	0f c0       	rjmp	.+30     	; 0x2630 <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    2612:	e0 e0       	ldi	r30, 0x00	; 0
    2614:	f6 e0       	ldi	r31, 0x06	; 6
    2616:	84 81       	ldd	r24, Z+4	; 0x04
    2618:	86 ff       	sbrs	r24, 6
    261a:	05 c0       	rjmp	.+10     	; 0x2626 <__vector_19+0x4c>
    261c:	82 e0       	ldi	r24, 0x02	; 2
    261e:	e0 e2       	ldi	r30, 0x20	; 32
    2620:	f6 e0       	ldi	r31, 0x06	; 6
    2622:	87 83       	std	Z+7, r24	; 0x07
    2624:	0d c0       	rjmp	.+26     	; 0x2640 <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
    2626:	80 e4       	ldi	r24, 0x40	; 64
    2628:	e0 e0       	ldi	r30, 0x00	; 0
    262a:	f6 e0       	ldi	r31, 0x06	; 6
    262c:	87 83       	std	Z+7, r24	; 0x07
    262e:	08 c0       	rjmp	.+16     	; 0x2640 <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    2630:	80 e4       	ldi	r24, 0x40	; 64
    2632:	e0 e0       	ldi	r30, 0x00	; 0
    2634:	f6 e0       	ldi	r31, 0x06	; 6
    2636:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
    2638:	82 e0       	ldi	r24, 0x02	; 2
    263a:	e0 e2       	ldi	r30, 0x20	; 32
    263c:	f6 e0       	ldi	r31, 0x06	; 6
    263e:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
    2640:	ff 91       	pop	r31
    2642:	ef 91       	pop	r30
    2644:	bf 91       	pop	r27
    2646:	af 91       	pop	r26
    2648:	9f 91       	pop	r25
    264a:	8f 91       	pop	r24
    264c:	7f 91       	pop	r23
    264e:	6f 91       	pop	r22
    2650:	5f 91       	pop	r21
    2652:	4f 91       	pop	r20
    2654:	3f 91       	pop	r19
    2656:	2f 91       	pop	r18
    2658:	0f 90       	pop	r0
    265a:	0b be       	out	0x3b, r0	; 59
    265c:	0f 90       	pop	r0
    265e:	0f be       	out	0x3f, r0	; 63
    2660:	0f 90       	pop	r0
    2662:	1f 90       	pop	r1
    2664:	18 95       	reti

00002666 <__vector_18>:
ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCC0_CCC_vect) {
    2666:	1f 92       	push	r1
    2668:	0f 92       	push	r0
    266a:	0f b6       	in	r0, 0x3f	; 63
    266c:	0f 92       	push	r0
    266e:	0b b6       	in	r0, 0x3b	; 59
    2670:	0f 92       	push	r0
    2672:	11 24       	eor	r1, r1
    2674:	2f 93       	push	r18
    2676:	3f 93       	push	r19
    2678:	4f 93       	push	r20
    267a:	5f 93       	push	r21
    267c:	6f 93       	push	r22
    267e:	7f 93       	push	r23
    2680:	8f 93       	push	r24
    2682:	9f 93       	push	r25
    2684:	af 93       	push	r26
    2686:	bf 93       	push	r27
    2688:	ef 93       	push	r30
    268a:	ff 93       	push	r31
	sampleCurrentChannel();
    268c:	0e 94 09 12 	call	0x2412	; 0x2412 <sampleCurrentChannel>
}
    2690:	ff 91       	pop	r31
    2692:	ef 91       	pop	r30
    2694:	bf 91       	pop	r27
    2696:	af 91       	pop	r26
    2698:	9f 91       	pop	r25
    269a:	8f 91       	pop	r24
    269c:	7f 91       	pop	r23
    269e:	6f 91       	pop	r22
    26a0:	5f 91       	pop	r21
    26a2:	4f 91       	pop	r20
    26a4:	3f 91       	pop	r19
    26a6:	2f 91       	pop	r18
    26a8:	0f 90       	pop	r0
    26aa:	0b be       	out	0x3b, r0	; 59
    26ac:	0f 90       	pop	r0
    26ae:	0f be       	out	0x3f, r0	; 63
    26b0:	0f 90       	pop	r0
    26b2:	1f 90       	pop	r1
    26b4:	18 95       	reti

000026b6 <__vector_17>:
ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

//second averaging point
ISR(TCC0_CCB_vect) {
    26b6:	1f 92       	push	r1
    26b8:	0f 92       	push	r0
    26ba:	0f b6       	in	r0, 0x3f	; 63
    26bc:	0f 92       	push	r0
    26be:	0b b6       	in	r0, 0x3b	; 59
    26c0:	0f 92       	push	r0
    26c2:	11 24       	eor	r1, r1
    26c4:	2f 93       	push	r18
    26c6:	3f 93       	push	r19
    26c8:	4f 93       	push	r20
    26ca:	5f 93       	push	r21
    26cc:	6f 93       	push	r22
    26ce:	7f 93       	push	r23
    26d0:	8f 93       	push	r24
    26d2:	9f 93       	push	r25
    26d4:	af 93       	push	r26
    26d6:	bf 93       	push	r27
    26d8:	ef 93       	push	r30
    26da:	ff 93       	push	r31
	sampleCurrentChannel();
    26dc:	0e 94 09 12 	call	0x2412	; 0x2412 <sampleCurrentChannel>
}
    26e0:	ff 91       	pop	r31
    26e2:	ef 91       	pop	r30
    26e4:	bf 91       	pop	r27
    26e6:	af 91       	pop	r26
    26e8:	9f 91       	pop	r25
    26ea:	8f 91       	pop	r24
    26ec:	7f 91       	pop	r23
    26ee:	6f 91       	pop	r22
    26f0:	5f 91       	pop	r21
    26f2:	4f 91       	pop	r20
    26f4:	3f 91       	pop	r19
    26f6:	2f 91       	pop	r18
    26f8:	0f 90       	pop	r0
    26fa:	0b be       	out	0x3b, r0	; 59
    26fc:	0f 90       	pop	r0
    26fe:	0f be       	out	0x3f, r0	; 63
    2700:	0f 90       	pop	r0
    2702:	1f 90       	pop	r1
    2704:	18 95       	reti

00002706 <__vector_16>:
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//first averaging point
ISR(TCC0_CCA_vect) {
    2706:	1f 92       	push	r1
    2708:	0f 92       	push	r0
    270a:	0f b6       	in	r0, 0x3f	; 63
    270c:	0f 92       	push	r0
    270e:	0b b6       	in	r0, 0x3b	; 59
    2710:	0f 92       	push	r0
    2712:	11 24       	eor	r1, r1
    2714:	2f 93       	push	r18
    2716:	3f 93       	push	r19
    2718:	4f 93       	push	r20
    271a:	5f 93       	push	r21
    271c:	6f 93       	push	r22
    271e:	7f 93       	push	r23
    2720:	8f 93       	push	r24
    2722:	9f 93       	push	r25
    2724:	af 93       	push	r26
    2726:	bf 93       	push	r27
    2728:	ef 93       	push	r30
    272a:	ff 93       	push	r31
	sampleCurrentChannel();
    272c:	0e 94 09 12 	call	0x2412	; 0x2412 <sampleCurrentChannel>
}
    2730:	ff 91       	pop	r31
    2732:	ef 91       	pop	r30
    2734:	bf 91       	pop	r27
    2736:	af 91       	pop	r26
    2738:	9f 91       	pop	r25
    273a:	8f 91       	pop	r24
    273c:	7f 91       	pop	r23
    273e:	6f 91       	pop	r22
    2740:	5f 91       	pop	r21
    2742:	4f 91       	pop	r20
    2744:	3f 91       	pop	r19
    2746:	2f 91       	pop	r18
    2748:	0f 90       	pop	r0
    274a:	0b be       	out	0x3b, r0	; 59
    274c:	0f 90       	pop	r0
    274e:	0f be       	out	0x3f, r0	; 63
    2750:	0f 90       	pop	r0
    2752:	1f 90       	pop	r1
    2754:	18 95       	reti

00002756 <writeSE2FRAM>:
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    2756:	ff 92       	push	r15
    2758:	0f 93       	push	r16
    275a:	1f 93       	push	r17
    275c:	cf 93       	push	r28
    275e:	df 93       	push	r29
    2760:	cd b7       	in	r28, 0x3d	; 61
    2762:	de b7       	in	r29, 0x3e	; 62
    2764:	28 97       	sbiw	r28, 0x08	; 8
    2766:	cd bf       	out	0x3d, r28	; 61
    2768:	de bf       	out	0x3e, r29	; 62

	volatile int32_t sum = 0;
    276a:	19 82       	std	Y+1, r1	; 0x01
    276c:	1a 82       	std	Y+2, r1	; 0x02
    276e:	1b 82       	std	Y+3, r1	; 0x03
    2770:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    2772:	80 91 66 50 	lds	r24, 0x5066
    2776:	90 91 67 50 	lds	r25, 0x5067
    277a:	a0 91 68 50 	lds	r26, 0x5068
    277e:	b0 91 69 50 	lds	r27, 0x5069
    2782:	01 96       	adiw	r24, 0x01	; 1
    2784:	a1 1d       	adc	r26, r1
    2786:	b1 1d       	adc	r27, r1
    2788:	80 93 66 50 	sts	0x5066, r24
    278c:	90 93 67 50 	sts	0x5067, r25
    2790:	a0 93 68 50 	sts	0x5068, r26
    2794:	b0 93 69 50 	sts	0x5069, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2798:	80 ed       	ldi	r24, 0xD0	; 208
    279a:	80 93 c0 08 	sts	0x08C0, r24
    279e:	20 e0       	ldi	r18, 0x00	; 0
    27a0:	30 e0       	ldi	r19, 0x00	; 0
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    27a2:	01 e2       	ldi	r16, 0x21	; 33
    27a4:	1e e3       	ldi	r17, 0x3E	; 62
    27a6:	ff 24       	eor	r15, r15
    27a8:	fa 94       	dec	r15
    27aa:	c9 01       	movw	r24, r18
    27ac:	f8 01       	movw	r30, r16
    27ae:	e2 0f       	add	r30, r18
    27b0:	f3 1f       	adc	r31, r19
    27b2:	40 81       	ld	r20, Z
    27b4:	44 23       	and	r20, r20
    27b6:	14 f4       	brge	.+4      	; 0x27bc <writeSE2FRAM+0x66>
    27b8:	f8 86       	std	Y+8, r15	; 0x08
    27ba:	01 c0       	rjmp	.+2      	; 0x27be <writeSE2FRAM+0x68>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    27bc:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    27be:	80 0f       	add	r24, r16
    27c0:	91 1f       	adc	r25, r17
    27c2:	fc 01       	movw	r30, r24
    27c4:	80 81       	ld	r24, Z
    27c6:	8f 83       	std	Y+7, r24	; 0x07
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    27c8:	f9 01       	movw	r30, r18
    27ca:	31 96       	adiw	r30, 0x01	; 1
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    27cc:	e0 0f       	add	r30, r16
    27ce:	f1 1f       	adc	r31, r17
    27d0:	80 81       	ld	r24, Z
    27d2:	8e 83       	std	Y+6, r24	; 0x06
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    27d4:	f9 01       	movw	r30, r18
    27d6:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    27d8:	e0 0f       	add	r30, r16
    27da:	f1 1f       	adc	r31, r17
    27dc:	80 81       	ld	r24, Z
    27de:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    27e0:	49 81       	ldd	r20, Y+1	; 0x01
    27e2:	5a 81       	ldd	r21, Y+2	; 0x02
    27e4:	6b 81       	ldd	r22, Y+3	; 0x03
    27e6:	7c 81       	ldd	r23, Y+4	; 0x04
    27e8:	8d 81       	ldd	r24, Y+5	; 0x05
    27ea:	9e 81       	ldd	r25, Y+6	; 0x06
    27ec:	af 81       	ldd	r26, Y+7	; 0x07
    27ee:	b8 85       	ldd	r27, Y+8	; 0x08
    27f0:	84 0f       	add	r24, r20
    27f2:	95 1f       	adc	r25, r21
    27f4:	a6 1f       	adc	r26, r22
    27f6:	b7 1f       	adc	r27, r23
    27f8:	89 83       	std	Y+1, r24	; 0x01
    27fa:	9a 83       	std	Y+2, r25	; 0x02
    27fc:	ab 83       	std	Y+3, r26	; 0x03
    27fe:	bc 83       	std	Y+4, r27	; 0x04
    2800:	2d 5f       	subi	r18, 0xFD	; 253
    2802:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2804:	2c 30       	cpi	r18, 0x0C	; 12
    2806:	31 05       	cpc	r19, r1
    2808:	81 f6       	brne	.-96     	; 0x27aa <writeSE2FRAM+0x54>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    280a:	69 81       	ldd	r22, Y+1	; 0x01
    280c:	7a 81       	ldd	r23, Y+2	; 0x02
    280e:	8b 81       	ldd	r24, Y+3	; 0x03
    2810:	9c 81       	ldd	r25, Y+4	; 0x04
    2812:	24 e0       	ldi	r18, 0x04	; 4
    2814:	30 e0       	ldi	r19, 0x00	; 0
    2816:	40 e0       	ldi	r20, 0x00	; 0
    2818:	50 e0       	ldi	r21, 0x00	; 0
    281a:	0e 94 85 39 	call	0x730a	; 0x730a <__divmodsi4>
    281e:	29 83       	std	Y+1, r18	; 0x01
    2820:	3a 83       	std	Y+2, r19	; 0x02
    2822:	4b 83       	std	Y+3, r20	; 0x03
    2824:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2826:	29 81       	ldd	r18, Y+1	; 0x01
    2828:	83 e2       	ldi	r24, 0x23	; 35
    282a:	9e e3       	ldi	r25, 0x3E	; 62
    282c:	20 93 23 3e 	sts	0x3E23, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2830:	2a 81       	ldd	r18, Y+2	; 0x02
    2832:	fc 01       	movw	r30, r24
    2834:	31 97       	sbiw	r30, 0x01	; 1
    2836:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    2838:	2b 81       	ldd	r18, Y+3	; 0x03
    283a:	02 97       	sbiw	r24, 0x02	; 2
    283c:	fc 01       	movw	r30, r24
    283e:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2840:	80 e1       	ldi	r24, 0x10	; 16
    2842:	e0 e4       	ldi	r30, 0x40	; 64
    2844:	f6 e0       	ldi	r31, 0x06	; 6
    2846:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2848:	88 e0       	ldi	r24, 0x08	; 8
    284a:	e0 e2       	ldi	r30, 0x20	; 32
    284c:	f6 e0       	ldi	r31, 0x06	; 6
    284e:	86 83       	std	Z+6, r24	; 0x06
	nop();
    2850:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2852:	86 e0       	ldi	r24, 0x06	; 6
    2854:	e0 ec       	ldi	r30, 0xC0	; 192
    2856:	f8 e0       	ldi	r31, 0x08	; 8
    2858:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    285a:	82 81       	ldd	r24, Z+2	; 0x02
    285c:	88 23       	and	r24, r24
    285e:	ec f7       	brge	.-6      	; 0x285a <writeSE2FRAM+0x104>
	SPIBuffer[12] = SPIC.DATA;
    2860:	e0 ec       	ldi	r30, 0xC0	; 192
    2862:	f8 e0       	ldi	r31, 0x08	; 8
    2864:	83 81       	ldd	r24, Z+3	; 0x03
    2866:	80 93 2d 3e 	sts	0x3E2D, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    286a:	a0 e2       	ldi	r26, 0x20	; 32
    286c:	b6 e0       	ldi	r27, 0x06	; 6
    286e:	88 e0       	ldi	r24, 0x08	; 8
    2870:	15 96       	adiw	r26, 0x05	; 5
    2872:	8c 93       	st	X, r24
    2874:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    2876:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2878:	16 96       	adiw	r26, 0x06	; 6
    287a:	8c 93       	st	X, r24
    287c:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    287e:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2880:	82 e0       	ldi	r24, 0x02	; 2
    2882:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2884:	82 81       	ldd	r24, Z+2	; 0x02
    2886:	88 23       	and	r24, r24
    2888:	ec f7       	brge	.-6      	; 0x2884 <writeSE2FRAM+0x12e>
	SPIBuffer[12] = SPIC.DATA;
    288a:	e0 ec       	ldi	r30, 0xC0	; 192
    288c:	f8 e0       	ldi	r31, 0x08	; 8
    288e:	83 81       	ldd	r24, Z+3	; 0x03
    2890:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2894:	80 91 1f 3e 	lds	r24, 0x3E1F
    2898:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    289a:	82 81       	ldd	r24, Z+2	; 0x02
    289c:	88 23       	and	r24, r24
    289e:	ec f7       	brge	.-6      	; 0x289a <writeSE2FRAM+0x144>
	SPIBuffer[12] = SPIC.DATA;
    28a0:	e0 ec       	ldi	r30, 0xC0	; 192
    28a2:	f8 e0       	ldi	r31, 0x08	; 8
    28a4:	83 81       	ldd	r24, Z+3	; 0x03
    28a6:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    28aa:	80 91 1e 3e 	lds	r24, 0x3E1E
    28ae:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    28b0:	82 81       	ldd	r24, Z+2	; 0x02
    28b2:	88 23       	and	r24, r24
    28b4:	ec f7       	brge	.-6      	; 0x28b0 <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    28b6:	e0 ec       	ldi	r30, 0xC0	; 192
    28b8:	f8 e0       	ldi	r31, 0x08	; 8
    28ba:	83 81       	ldd	r24, Z+3	; 0x03
    28bc:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = SPIBuffer[0];
    28c0:	80 91 21 3e 	lds	r24, 0x3E21
    28c4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    28c6:	82 81       	ldd	r24, Z+2	; 0x02
    28c8:	88 23       	and	r24, r24
    28ca:	ec f7       	brge	.-6      	; 0x28c6 <writeSE2FRAM+0x170>
	SPIBuffer[12] = SPIC.DATA;
    28cc:	e0 ec       	ldi	r30, 0xC0	; 192
    28ce:	f8 e0       	ldi	r31, 0x08	; 8
    28d0:	83 81       	ldd	r24, Z+3	; 0x03
    28d2:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = SPIBuffer[1];
    28d6:	80 91 22 3e 	lds	r24, 0x3E22
    28da:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    28dc:	82 81       	ldd	r24, Z+2	; 0x02
    28de:	88 23       	and	r24, r24
    28e0:	ec f7       	brge	.-6      	; 0x28dc <writeSE2FRAM+0x186>
	SPIBuffer[12] = SPIC.DATA;
    28e2:	e0 ec       	ldi	r30, 0xC0	; 192
    28e4:	f8 e0       	ldi	r31, 0x08	; 8
    28e6:	83 81       	ldd	r24, Z+3	; 0x03
    28e8:	80 93 2d 3e 	sts	0x3E2D, r24
	SPIC.DATA = SPIBuffer[2];
    28ec:	80 91 23 3e 	lds	r24, 0x3E23
    28f0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    28f2:	82 81       	ldd	r24, Z+2	; 0x02
    28f4:	88 23       	and	r24, r24
    28f6:	ec f7       	brge	.-6      	; 0x28f2 <writeSE2FRAM+0x19c>
	SPIBuffer[12] = SPIC.DATA;
    28f8:	a0 ec       	ldi	r26, 0xC0	; 192
    28fa:	b8 e0       	ldi	r27, 0x08	; 8
    28fc:	13 96       	adiw	r26, 0x03	; 3
    28fe:	8c 91       	ld	r24, X
    2900:	13 97       	sbiw	r26, 0x03	; 3
    2902:	80 93 2d 3e 	sts	0x3E2D, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2906:	88 e0       	ldi	r24, 0x08	; 8
    2908:	e0 e2       	ldi	r30, 0x20	; 32
    290a:	f6 e0       	ldi	r31, 0x06	; 6
    290c:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    290e:	e0 e4       	ldi	r30, 0x40	; 64
    2910:	f6 e0       	ldi	r31, 0x06	; 6
    2912:	80 e1       	ldi	r24, 0x10	; 16
    2914:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2916:	94 e5       	ldi	r25, 0x54	; 84
    2918:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    291a:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    291c:	80 91 1e 3e 	lds	r24, 0x3E1E
    2920:	90 91 1f 3e 	lds	r25, 0x3E1F
    2924:	03 96       	adiw	r24, 0x03	; 3
    2926:	80 93 1e 3e 	sts	0x3E1E, r24
    292a:	90 93 1f 3e 	sts	0x3E1F, r25
	checksumADC[0] += SPIBuffer[0];
    292e:	80 91 12 21 	lds	r24, 0x2112
    2932:	e1 e2       	ldi	r30, 0x21	; 33
    2934:	fe e3       	ldi	r31, 0x3E	; 62
    2936:	90 81       	ld	r25, Z
    2938:	89 0f       	add	r24, r25
    293a:	80 93 12 21 	sts	0x2112, r24
	checksumADC[1] += SPIBuffer[1];
    293e:	80 91 13 21 	lds	r24, 0x2113
    2942:	91 81       	ldd	r25, Z+1	; 0x01
    2944:	89 0f       	add	r24, r25
    2946:	80 93 13 21 	sts	0x2113, r24
	checksumADC[2] += SPIBuffer[2];
    294a:	80 91 14 21 	lds	r24, 0x2114
    294e:	92 81       	ldd	r25, Z+2	; 0x02
    2950:	89 0f       	add	r24, r25
    2952:	80 93 14 21 	sts	0x2114, r24
}
    2956:	28 96       	adiw	r28, 0x08	; 8
    2958:	cd bf       	out	0x3d, r28	; 61
    295a:	de bf       	out	0x3e, r29	; 62
    295c:	df 91       	pop	r29
    295e:	cf 91       	pop	r28
    2960:	1f 91       	pop	r17
    2962:	0f 91       	pop	r16
    2964:	ff 90       	pop	r15
    2966:	08 95       	ret

00002968 <FRAMWriteKnowns>:
// 	}
// 	
// }

//test function for FRAM
void FRAMWriteKnowns() {
    2968:	2f 92       	push	r2
    296a:	3f 92       	push	r3
    296c:	4f 92       	push	r4
    296e:	5f 92       	push	r5
    2970:	6f 92       	push	r6
    2972:	7f 92       	push	r7
    2974:	8f 92       	push	r8
    2976:	9f 92       	push	r9
    2978:	af 92       	push	r10
    297a:	bf 92       	push	r11
    297c:	cf 92       	push	r12
    297e:	df 92       	push	r13
    2980:	ef 92       	push	r14
    2982:	ff 92       	push	r15
    2984:	0f 93       	push	r16
    2986:	1f 93       	push	r17
    2988:	cf 93       	push	r28
    298a:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    298c:	10 92 1e 3e 	sts	0x3E1E, r1
    2990:	10 92 1f 3e 	sts	0x3E1F, r1
	sampleCount = 0;
    2994:	10 92 66 50 	sts	0x5066, r1
    2998:	10 92 67 50 	sts	0x5067, r1
    299c:	10 92 68 50 	sts	0x5068, r1
    29a0:	10 92 69 50 	sts	0x5069, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    29a4:	84 e1       	ldi	r24, 0x14	; 20
    29a6:	91 e2       	ldi	r25, 0x21	; 33
    29a8:	10 92 14 21 	sts	0x2114, r1
    29ac:	fc 01       	movw	r30, r24
    29ae:	31 97       	sbiw	r30, 0x01	; 1
    29b0:	10 82       	st	Z, r1
    29b2:	02 97       	sbiw	r24, 0x02	; 2
    29b4:	dc 01       	movw	r26, r24
    29b6:	1c 92       	st	X, r1
	
	ADCPower(TRUE);
    29b8:	81 e0       	ldi	r24, 0x01	; 1
    29ba:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    29be:	84 e0       	ldi	r24, 0x04	; 4
    29c0:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    29c4:	80 ed       	ldi	r24, 0xD0	; 208
    29c6:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    29ca:	8d e0       	ldi	r24, 0x0D	; 13
    29cc:	80 93 21 3e 	sts	0x3E21, r24
	SPIBuffer[1] = 0xF3;
    29d0:	83 ef       	ldi	r24, 0xF3	; 243
    29d2:	80 93 22 3e 	sts	0x3E22, r24
	SPIBuffer[2] = 0x57;
    29d6:	87 e5       	ldi	r24, 0x57	; 87
    29d8:	80 93 23 3e 	sts	0x3E23, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    29dc:	80 91 66 50 	lds	r24, 0x5066
    29e0:	90 91 67 50 	lds	r25, 0x5067
    29e4:	a0 91 68 50 	lds	r26, 0x5068
    29e8:	b0 91 69 50 	lds	r27, 0x5069
    29ec:	83 35       	cpi	r24, 0x53	; 83
    29ee:	e5 e5       	ldi	r30, 0x55	; 85
    29f0:	9e 07       	cpc	r25, r30
    29f2:	e0 e0       	ldi	r30, 0x00	; 0
    29f4:	ae 07       	cpc	r26, r30
    29f6:	e0 e0       	ldi	r30, 0x00	; 0
    29f8:	be 07       	cpc	r27, r30
    29fa:	08 f0       	brcs	.+2      	; 0x29fe <FRAMWriteKnowns+0x96>
    29fc:	cc c0       	rjmp	.+408    	; 0x2b96 <FRAMWriteKnowns+0x22e>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    29fe:	0f 2e       	mov	r0, r31
    2a00:	f0 e4       	ldi	r31, 0x40	; 64
    2a02:	ef 2e       	mov	r14, r31
    2a04:	f6 e0       	ldi	r31, 0x06	; 6
    2a06:	ff 2e       	mov	r15, r31
    2a08:	f0 2d       	mov	r31, r0
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2a0a:	40 e2       	ldi	r20, 0x20	; 32
    2a0c:	56 e0       	ldi	r21, 0x06	; 6
    2a0e:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    2a10:	e0 ec       	ldi	r30, 0xC0	; 192
    2a12:	f8 e0       	ldi	r31, 0x08	; 8
    2a14:	0f 2e       	mov	r0, r31
    2a16:	f6 e0       	ldi	r31, 0x06	; 6
    2a18:	7f 2e       	mov	r7, r31
    2a1a:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    2a1c:	cd e2       	ldi	r28, 0x2D	; 45
    2a1e:	de e3       	ldi	r29, 0x3E	; 62
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    2a20:	66 24       	eor	r6, r6
    2a22:	68 94       	set
    2a24:	61 f8       	bld	r6, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2a26:	0f 2e       	mov	r0, r31
    2a28:	fe e1       	ldi	r31, 0x1E	; 30
    2a2a:	cf 2e       	mov	r12, r31
    2a2c:	fe e3       	ldi	r31, 0x3E	; 62
    2a2e:	df 2e       	mov	r13, r31
    2a30:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    2a32:	8e 01       	movw	r16, r28
    2a34:	0c 50       	subi	r16, 0x0C	; 12
    2a36:	10 40       	sbci	r17, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    2a38:	0f 2e       	mov	r0, r31
    2a3a:	f5 ef       	ldi	r31, 0xF5	; 245
    2a3c:	4f 2e       	mov	r4, r31
    2a3e:	ff ef       	ldi	r31, 0xFF	; 255
    2a40:	5f 2e       	mov	r5, r31
    2a42:	f0 2d       	mov	r31, r0
    2a44:	4c 0e       	add	r4, r28
    2a46:	5d 1e       	adc	r5, r29
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    2a48:	0f 2e       	mov	r0, r31
    2a4a:	f6 ef       	ldi	r31, 0xF6	; 246
    2a4c:	2f 2e       	mov	r2, r31
    2a4e:	ff ef       	ldi	r31, 0xFF	; 255
    2a50:	3f 2e       	mov	r3, r31
    2a52:	f0 2d       	mov	r31, r0
    2a54:	2c 0e       	add	r2, r28
    2a56:	3d 1e       	adc	r3, r29
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    2a58:	62 e1       	ldi	r22, 0x12	; 18
    2a5a:	71 e2       	ldi	r23, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    2a5c:	5b 01       	movw	r10, r22
    2a5e:	08 94       	sec
    2a60:	a1 1c       	adc	r10, r1
    2a62:	b1 1c       	adc	r11, r1
		checksumADC[2] += SPIBuffer[2];
    2a64:	88 24       	eor	r8, r8
    2a66:	99 24       	eor	r9, r9
    2a68:	68 94       	set
    2a6a:	81 f8       	bld	r8, 1
    2a6c:	86 0e       	add	r8, r22
    2a6e:	97 1e       	adc	r9, r23
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2a70:	30 e1       	ldi	r19, 0x10	; 16
    2a72:	d7 01       	movw	r26, r14
    2a74:	16 96       	adiw	r26, 0x06	; 6
    2a76:	3c 93       	st	X, r19
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2a78:	da 01       	movw	r26, r20
    2a7a:	16 96       	adiw	r26, 0x06	; 6
    2a7c:	2c 93       	st	X, r18
    2a7e:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    2a80:	00 00       	nop
		SPIC.DATA = FR_WREN;
    2a82:	73 82       	std	Z+3, r7	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2a84:	82 81       	ldd	r24, Z+2	; 0x02
    2a86:	88 23       	and	r24, r24
    2a88:	ec f7       	brge	.-6      	; 0x2a84 <FRAMWriteKnowns+0x11c>
		SPIBuffer[12] = SPIC.DATA;
    2a8a:	83 81       	ldd	r24, Z+3	; 0x03
    2a8c:	88 83       	st	Y, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    2a8e:	da 01       	movw	r26, r20
    2a90:	15 96       	adiw	r26, 0x05	; 5
    2a92:	2c 93       	st	X, r18
    2a94:	15 97       	sbiw	r26, 0x05	; 5
		nop(); // time for CS_FRAM to accept high signal
    2a96:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2a98:	16 96       	adiw	r26, 0x06	; 6
    2a9a:	2c 93       	st	X, r18
    2a9c:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    2a9e:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    2aa0:	63 82       	std	Z+3, r6	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2aa2:	82 81       	ldd	r24, Z+2	; 0x02
    2aa4:	88 23       	and	r24, r24
    2aa6:	ec f7       	brge	.-6      	; 0x2aa2 <FRAMWriteKnowns+0x13a>
		SPIBuffer[12] = SPIC.DATA;
    2aa8:	83 81       	ldd	r24, Z+3	; 0x03
    2aaa:	88 83       	st	Y, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2aac:	d6 01       	movw	r26, r12
    2aae:	11 96       	adiw	r26, 0x01	; 1
    2ab0:	8c 91       	ld	r24, X
    2ab2:	11 97       	sbiw	r26, 0x01	; 1
    2ab4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2ab6:	82 81       	ldd	r24, Z+2	; 0x02
    2ab8:	88 23       	and	r24, r24
    2aba:	ec f7       	brge	.-6      	; 0x2ab6 <FRAMWriteKnowns+0x14e>
		SPIBuffer[12] = SPIC.DATA;
    2abc:	83 81       	ldd	r24, Z+3	; 0x03
    2abe:	88 83       	st	Y, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2ac0:	d6 01       	movw	r26, r12
    2ac2:	8c 91       	ld	r24, X
    2ac4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2ac6:	82 81       	ldd	r24, Z+2	; 0x02
    2ac8:	88 23       	and	r24, r24
    2aca:	ec f7       	brge	.-6      	; 0x2ac6 <FRAMWriteKnowns+0x15e>
		SPIBuffer[12] = SPIC.DATA;
    2acc:	83 81       	ldd	r24, Z+3	; 0x03
    2ace:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[0];
    2ad0:	d8 01       	movw	r26, r16
    2ad2:	8c 91       	ld	r24, X
    2ad4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2ad6:	82 81       	ldd	r24, Z+2	; 0x02
    2ad8:	88 23       	and	r24, r24
    2ada:	ec f7       	brge	.-6      	; 0x2ad6 <FRAMWriteKnowns+0x16e>
		SPIBuffer[12] = SPIC.DATA;
    2adc:	83 81       	ldd	r24, Z+3	; 0x03
    2ade:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[1];
    2ae0:	d2 01       	movw	r26, r4
    2ae2:	8c 91       	ld	r24, X
    2ae4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2ae6:	82 81       	ldd	r24, Z+2	; 0x02
    2ae8:	88 23       	and	r24, r24
    2aea:	ec f7       	brge	.-6      	; 0x2ae6 <FRAMWriteKnowns+0x17e>
		SPIBuffer[12] = SPIC.DATA;
    2aec:	83 81       	ldd	r24, Z+3	; 0x03
    2aee:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[2];
    2af0:	d1 01       	movw	r26, r2
    2af2:	8c 91       	ld	r24, X
    2af4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2af6:	82 81       	ldd	r24, Z+2	; 0x02
    2af8:	88 23       	and	r24, r24
    2afa:	ec f7       	brge	.-6      	; 0x2af6 <FRAMWriteKnowns+0x18e>
		SPIBuffer[12] = SPIC.DATA;
    2afc:	83 81       	ldd	r24, Z+3	; 0x03
    2afe:	88 83       	st	Y, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2b00:	da 01       	movw	r26, r20
    2b02:	15 96       	adiw	r26, 0x05	; 5
    2b04:	2c 93       	st	X, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2b06:	30 e1       	ldi	r19, 0x10	; 16
    2b08:	d7 01       	movw	r26, r14
    2b0a:	15 96       	adiw	r26, 0x05	; 5
    2b0c:	3c 93       	st	X, r19
		
		FRAMAddress +=3;
    2b0e:	80 91 1e 3e 	lds	r24, 0x3E1E
    2b12:	90 91 1f 3e 	lds	r25, 0x3E1F
    2b16:	03 96       	adiw	r24, 0x03	; 3
    2b18:	80 93 1e 3e 	sts	0x3E1E, r24
    2b1c:	90 93 1f 3e 	sts	0x3E1F, r25
		checksumADC[0] += SPIBuffer[0];
    2b20:	db 01       	movw	r26, r22
    2b22:	8c 91       	ld	r24, X
    2b24:	d8 01       	movw	r26, r16
    2b26:	9c 91       	ld	r25, X
    2b28:	89 0f       	add	r24, r25
    2b2a:	db 01       	movw	r26, r22
    2b2c:	8c 93       	st	X, r24
		checksumADC[1] += SPIBuffer[1];
    2b2e:	d5 01       	movw	r26, r10
    2b30:	8c 91       	ld	r24, X
    2b32:	a2 e2       	ldi	r26, 0x22	; 34
    2b34:	be e3       	ldi	r27, 0x3E	; 62
    2b36:	9c 91       	ld	r25, X
    2b38:	89 0f       	add	r24, r25
    2b3a:	d5 01       	movw	r26, r10
    2b3c:	8c 93       	st	X, r24
		checksumADC[2] += SPIBuffer[2];
    2b3e:	d4 01       	movw	r26, r8
    2b40:	8c 91       	ld	r24, X
    2b42:	a3 e2       	ldi	r26, 0x23	; 35
    2b44:	be e3       	ldi	r27, 0x3E	; 62
    2b46:	9c 91       	ld	r25, X
    2b48:	89 0f       	add	r24, r25
    2b4a:	d4 01       	movw	r26, r8
    2b4c:	8c 93       	st	X, r24
		
		sampleCount++;
    2b4e:	80 91 66 50 	lds	r24, 0x5066
    2b52:	90 91 67 50 	lds	r25, 0x5067
    2b56:	a0 91 68 50 	lds	r26, 0x5068
    2b5a:	b0 91 69 50 	lds	r27, 0x5069
    2b5e:	01 96       	adiw	r24, 0x01	; 1
    2b60:	a1 1d       	adc	r26, r1
    2b62:	b1 1d       	adc	r27, r1
    2b64:	80 93 66 50 	sts	0x5066, r24
    2b68:	90 93 67 50 	sts	0x5067, r25
    2b6c:	a0 93 68 50 	sts	0x5068, r26
    2b70:	b0 93 69 50 	sts	0x5069, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    2b74:	80 91 66 50 	lds	r24, 0x5066
    2b78:	90 91 67 50 	lds	r25, 0x5067
    2b7c:	a0 91 68 50 	lds	r26, 0x5068
    2b80:	b0 91 69 50 	lds	r27, 0x5069
    2b84:	83 35       	cpi	r24, 0x53	; 83
    2b86:	35 e5       	ldi	r19, 0x55	; 85
    2b88:	93 07       	cpc	r25, r19
    2b8a:	30 e0       	ldi	r19, 0x00	; 0
    2b8c:	a3 07       	cpc	r26, r19
    2b8e:	30 e0       	ldi	r19, 0x00	; 0
    2b90:	b3 07       	cpc	r27, r19
    2b92:	08 f4       	brcc	.+2      	; 0x2b96 <FRAMWriteKnowns+0x22e>
    2b94:	6d cf       	rjmp	.-294    	; 0x2a70 <FRAMWriteKnowns+0x108>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    2b96:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	ADCPower(FALSE);
    2b9a:	80 e0       	ldi	r24, 0x00	; 0
    2b9c:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
}
    2ba0:	df 91       	pop	r29
    2ba2:	cf 91       	pop	r28
    2ba4:	1f 91       	pop	r17
    2ba6:	0f 91       	pop	r16
    2ba8:	ff 90       	pop	r15
    2baa:	ef 90       	pop	r14
    2bac:	df 90       	pop	r13
    2bae:	cf 90       	pop	r12
    2bb0:	bf 90       	pop	r11
    2bb2:	af 90       	pop	r10
    2bb4:	9f 90       	pop	r9
    2bb6:	8f 90       	pop	r8
    2bb8:	7f 90       	pop	r7
    2bba:	6f 90       	pop	r6
    2bbc:	5f 90       	pop	r5
    2bbe:	4f 90       	pop	r4
    2bc0:	3f 90       	pop	r3
    2bc2:	2f 90       	pop	r2
    2bc4:	08 95       	ret

00002bc6 <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    2bc6:	80 ff       	sbrs	r24, 0
    2bc8:	05 c0       	rjmp	.+10     	; 0x2bd4 <setADCInput+0xe>
    2bca:	20 e4       	ldi	r18, 0x40	; 64
    2bcc:	e0 e0       	ldi	r30, 0x00	; 0
    2bce:	f6 e0       	ldi	r31, 0x06	; 6
    2bd0:	25 83       	std	Z+5, r18	; 0x05
    2bd2:	04 c0       	rjmp	.+8      	; 0x2bdc <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    2bd4:	20 e4       	ldi	r18, 0x40	; 64
    2bd6:	e0 e0       	ldi	r30, 0x00	; 0
    2bd8:	f6 e0       	ldi	r31, 0x06	; 6
    2bda:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    2bdc:	81 ff       	sbrs	r24, 1
    2bde:	05 c0       	rjmp	.+10     	; 0x2bea <setADCInput+0x24>
    2be0:	22 e0       	ldi	r18, 0x02	; 2
    2be2:	e0 e2       	ldi	r30, 0x20	; 32
    2be4:	f6 e0       	ldi	r31, 0x06	; 6
    2be6:	25 83       	std	Z+5, r18	; 0x05
    2be8:	04 c0       	rjmp	.+8      	; 0x2bf2 <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    2bea:	22 e0       	ldi	r18, 0x02	; 2
    2bec:	e0 e2       	ldi	r30, 0x20	; 32
    2bee:	f6 e0       	ldi	r31, 0x06	; 6
    2bf0:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    2bf2:	82 ff       	sbrs	r24, 2
    2bf4:	05 c0       	rjmp	.+10     	; 0x2c00 <setADCInput+0x3a>
    2bf6:	84 e0       	ldi	r24, 0x04	; 4
    2bf8:	e0 e2       	ldi	r30, 0x20	; 32
    2bfa:	f6 e0       	ldi	r31, 0x06	; 6
    2bfc:	85 83       	std	Z+5, r24	; 0x05
    2bfe:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    2c00:	84 e0       	ldi	r24, 0x04	; 4
    2c02:	e0 e2       	ldi	r30, 0x20	; 32
    2c04:	f6 e0       	ldi	r31, 0x06	; 6
    2c06:	86 83       	std	Z+6, r24	; 0x06
    2c08:	08 95       	ret

00002c0a <CO_collectSeismic1Channel_ext>:
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2c0a:	2f 92       	push	r2
    2c0c:	3f 92       	push	r3
    2c0e:	4f 92       	push	r4
    2c10:	5f 92       	push	r5
    2c12:	7f 92       	push	r7
    2c14:	8f 92       	push	r8
    2c16:	9f 92       	push	r9
    2c18:	af 92       	push	r10
    2c1a:	bf 92       	push	r11
    2c1c:	cf 92       	push	r12
    2c1e:	df 92       	push	r13
    2c20:	ef 92       	push	r14
    2c22:	ff 92       	push	r15
    2c24:	0f 93       	push	r16
    2c26:	1f 93       	push	r17
    2c28:	cf 93       	push	r28
    2c2a:	df 93       	push	r29
    2c2c:	cd b7       	in	r28, 0x3d	; 61
    2c2e:	de b7       	in	r29, 0x3e	; 62
    2c30:	18 2f       	mov	r17, r24
    2c32:	76 2e       	mov	r7, r22
    2c34:	f4 2e       	mov	r15, r20
    2c36:	19 01       	movw	r2, r18
	
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	ADC_BUFFER=DataArray;
    2c38:	89 8d       	ldd	r24, Y+25	; 0x19
    2c3a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2c3c:	80 93 64 50 	sts	0x5064, r24
    2c40:	90 93 65 50 	sts	0x5065, r25
	ADC_Sampling_Finished = 0;
    2c44:	10 92 a7 50 	sts	0x50A7, r1
	ADC_buffer_size = BufferSize;
    2c48:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2c4a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2c4c:	80 93 a8 50 	sts	0x50A8, r24
    2c50:	90 93 a9 50 	sts	0x50A9, r25
	if(use_FRAM){
    2c54:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2c56:	88 23       	and	r24, r24
    2c58:	21 f0       	breq	.+8      	; 0x2c62 <CO_collectSeismic1Channel_ext+0x58>
		write_to_FRAM = 1;
    2c5a:	81 e0       	ldi	r24, 0x01	; 1
    2c5c:	80 93 49 40 	sts	0x4049, r24
    2c60:	02 c0       	rjmp	.+4      	; 0x2c66 <CO_collectSeismic1Channel_ext+0x5c>
	}
	else{
		write_to_FRAM = 0;
    2c62:	10 92 49 40 	sts	0x4049, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2c66:	81 e0       	ldi	r24, 0x01	; 1
    2c68:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2c6c:	81 2f       	mov	r24, r17
    2c6e:	6f 2d       	mov	r22, r15
    2c70:	0e 94 21 0c 	call	0x1842	; 0x1842 <set_ampGain>
	set_filter(filterConfig);
    2c74:	87 2d       	mov	r24, r7
    2c76:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2c7a:	8e 2d       	mov	r24, r14
    2c7c:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2c80:	84 e0       	ldi	r24, 0x04	; 4
    2c82:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2c86:	84 e5       	ldi	r24, 0x54	; 84
    2c88:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2c8c:	81 e0       	ldi	r24, 0x01	; 1
    2c8e:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <enableADCMUX>
	setADCInput(channel);
    2c92:	81 2f       	mov	r24, r17
    2c94:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2c98:	e0 ea       	ldi	r30, 0xA0	; 160
    2c9a:	f6 e0       	ldi	r31, 0x06	; 6
    2c9c:	22 e0       	ldi	r18, 0x02	; 2
    2c9e:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2ca0:	77 24       	eor	r7, r7
    2ca2:	73 94       	inc	r7
    2ca4:	72 82       	std	Z+2, r7	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2ca6:	0f 2e       	mov	r0, r31
    2ca8:	f0 e8       	ldi	r31, 0x80	; 128
    2caa:	4f 2e       	mov	r4, r31
    2cac:	f1 e0       	ldi	r31, 0x01	; 1
    2cae:	5f 2e       	mov	r5, r31
    2cb0:	f0 2d       	mov	r31, r0
    2cb2:	88 e7       	ldi	r24, 0x78	; 120
    2cb4:	d2 01       	movw	r26, r4
    2cb6:	8c 93       	st	X, r24

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2cb8:	e0 e0       	ldi	r30, 0x00	; 0
    2cba:	f9 e0       	ldi	r31, 0x09	; 9
    2cbc:	80 ef       	ldi	r24, 0xF0	; 240
    2cbe:	81 83       	std	Z+1, r24	; 0x01
	TCD0.CCA = averagingPtA;
    2cc0:	c0 a6       	lds	r28, 0xb0
    2cc2:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    2cc4:	a2 a6       	lds	r26, 0xb2
    2cc6:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    2cc8:	84 a6       	lds	r24, 0xb4
    2cca:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    2ccc:	8d 89       	ldd	r24, Y+21	; 0x15
    2cce:	9e 89       	ldd	r25, Y+22	; 0x16
    2cd0:	86 a7       	lds	r24, 0x76
    2cd2:	97 a7       	lds	r25, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    2cd4:	80 2f       	mov	r24, r16
    2cd6:	90 e0       	ldi	r25, 0x00	; 0
    2cd8:	01 97       	sbiw	r24, 0x01	; 1
    2cda:	86 a3       	lds	r24, 0x56
    2cdc:	97 a3       	lds	r25, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2cde:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2ce0:	8f ef       	ldi	r24, 0xFF	; 255
    2ce2:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2ce4:	80 81       	ld	r24, Z
    2ce6:	80 7f       	andi	r24, 0xF0	; 240
    2ce8:	88 60       	ori	r24, 0x08	; 8
    2cea:	80 83       	st	Z, r24

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    2cec:	10 92 66 50 	sts	0x5066, r1
    2cf0:	10 92 67 50 	sts	0x5067, r1
    2cf4:	10 92 68 50 	sts	0x5068, r1
    2cf8:	10 92 69 50 	sts	0x5069, r1
	SPICount = 0;
    2cfc:	10 92 a1 50 	sts	0x50A1, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2d00:	80 e2       	ldi	r24, 0x20	; 32
    2d02:	e0 e8       	ldi	r30, 0x80	; 128
    2d04:	f6 e0       	ldi	r31, 0x06	; 6
    2d06:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2d08:	00 e4       	ldi	r16, 0x40	; 64
    2d0a:	1a e0       	ldi	r17, 0x0A	; 10
    2d0c:	83 e2       	ldi	r24, 0x23	; 35
    2d0e:	f8 01       	movw	r30, r16
    2d10:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2d12:	61 01       	movw	r12, r2
    2d14:	ee 24       	eor	r14, r14
    2d16:	ff 24       	eor	r15, r15
    2d18:	60 e8       	ldi	r22, 0x80	; 128
    2d1a:	74 e8       	ldi	r23, 0x84	; 132
    2d1c:	8e e1       	ldi	r24, 0x1E	; 30
    2d1e:	90 e0       	ldi	r25, 0x00	; 0
    2d20:	a7 01       	movw	r20, r14
    2d22:	96 01       	movw	r18, r12
    2d24:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    2d28:	d8 01       	movw	r26, r16
    2d2a:	96 96       	adiw	r26, 0x26	; 38
    2d2c:	2d 93       	st	X+, r18
    2d2e:	3c 93       	st	X, r19
    2d30:	97 97       	sbiw	r26, 0x27	; 39
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2d32:	60 e4       	ldi	r22, 0x40	; 64
    2d34:	72 e4       	ldi	r23, 0x42	; 66
    2d36:	8f e0       	ldi	r24, 0x0F	; 15
    2d38:	90 e0       	ldi	r25, 0x00	; 0
    2d3a:	a7 01       	movw	r20, r14
    2d3c:	96 01       	movw	r18, r12
    2d3e:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    2d42:	f8 01       	movw	r30, r16
    2d44:	22 af       	sts	0x72, r18
    2d46:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2d48:	e0 e4       	ldi	r30, 0x40	; 64
    2d4a:	f8 e0       	ldi	r31, 0x08	; 8
    2d4c:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;	
    2d4e:	8c e0       	ldi	r24, 0x0C	; 12
    2d50:	81 87       	std	Z+9, r24	; 0x09
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2d52:	8f 89       	ldd	r24, Y+23	; 0x17
    2d54:	98 8d       	ldd	r25, Y+24	; 0x18
    2d56:	86 a3       	lds	r24, 0x56
    2d58:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    2d5a:	80 ed       	ldi	r24, 0xD0	; 208
    2d5c:	d2 01       	movw	r26, r4
    2d5e:	11 96       	adiw	r26, 0x01	; 1
    2d60:	8c 93       	st	X, r24
    2d62:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2d64:	76 82       	std	Z+6, r7	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2d66:	80 81       	ld	r24, Z
    2d68:	80 7f       	andi	r24, 0xF0	; 240
    2d6a:	89 60       	ori	r24, 0x09	; 9
    2d6c:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2d6e:	f8 01       	movw	r30, r16
    2d70:	80 81       	ld	r24, Z
    2d72:	80 7f       	andi	r24, 0xF0	; 240
    2d74:	81 60       	ori	r24, 0x01	; 1
    2d76:	80 83       	st	Z, r24
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm;
    2d78:	e0 ea       	ldi	r30, 0xA0	; 160
    2d7a:	f0 e0       	ldi	r31, 0x00	; 0
    2d7c:	82 81       	ldd	r24, Z+2	; 0x02
    2d7e:	87 60       	ori	r24, 0x07	; 7
    2d80:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2d82:	78 94       	sei
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    2d84:	df 91       	pop	r29
    2d86:	cf 91       	pop	r28
    2d88:	1f 91       	pop	r17
    2d8a:	0f 91       	pop	r16
    2d8c:	ff 90       	pop	r15
    2d8e:	ef 90       	pop	r14
    2d90:	df 90       	pop	r13
    2d92:	cf 90       	pop	r12
    2d94:	bf 90       	pop	r11
    2d96:	af 90       	pop	r10
    2d98:	9f 90       	pop	r9
    2d9a:	8f 90       	pop	r8
    2d9c:	7f 90       	pop	r7
    2d9e:	5f 90       	pop	r5
    2da0:	4f 90       	pop	r4
    2da2:	3f 90       	pop	r3
    2da4:	2f 90       	pop	r2
    2da6:	08 95       	ret

00002da8 <CO_collectSeismic1Channel>:
	sampleCount++;

}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2da8:	2f 92       	push	r2
    2daa:	3f 92       	push	r3
    2dac:	4f 92       	push	r4
    2dae:	5f 92       	push	r5
    2db0:	6f 92       	push	r6
    2db2:	7f 92       	push	r7
    2db4:	8f 92       	push	r8
    2db6:	9f 92       	push	r9
    2db8:	af 92       	push	r10
    2dba:	bf 92       	push	r11
    2dbc:	cf 92       	push	r12
    2dbe:	df 92       	push	r13
    2dc0:	ef 92       	push	r14
    2dc2:	ff 92       	push	r15
    2dc4:	0f 93       	push	r16
    2dc6:	cf 93       	push	r28
    2dc8:	df 93       	push	r29
    2dca:	0f 92       	push	r0
    2dcc:	0f 92       	push	r0
    2dce:	cd b7       	in	r28, 0x3d	; 61
    2dd0:	de b7       	in	r29, 0x3e	; 62
    2dd2:	96 2f       	mov	r25, r22
    2dd4:	49 83       	std	Y+1, r20	; 0x01
    2dd6:	5a 83       	std	Y+2, r21	; 0x02
    2dd8:	52 2f       	mov	r21, r18
    2dda:	70 2f       	mov	r23, r16
    2ddc:	37 01       	movw	r6, r14
    2dde:	26 01       	movw	r4, r12
    2de0:	15 01       	movw	r2, r10
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    2de2:	2d b7       	in	r18, 0x3d	; 61
    2de4:	3e b7       	in	r19, 0x3e	; 62
    2de6:	29 50       	subi	r18, 0x09	; 9
    2de8:	30 40       	sbci	r19, 0x00	; 0
    2dea:	2d bf       	out	0x3d, r18	; 61
    2dec:	3e bf       	out	0x3e, r19	; 62
    2dee:	ed b7       	in	r30, 0x3d	; 61
    2df0:	fe b7       	in	r31, 0x3e	; 62
    2df2:	31 96       	adiw	r30, 0x01	; 1
    2df4:	ad b7       	in	r26, 0x3d	; 61
    2df6:	be b7       	in	r27, 0x3e	; 62
    2df8:	11 96       	adiw	r26, 0x01	; 1
    2dfa:	8d 92       	st	X+, r8
    2dfc:	9c 92       	st	X, r9
    2dfe:	12 97       	sbiw	r26, 0x02	; 2
    2e00:	2f 89       	ldd	r18, Y+23	; 0x17
    2e02:	38 8d       	ldd	r19, Y+24	; 0x18
    2e04:	22 83       	std	Z+2, r18	; 0x02
    2e06:	33 83       	std	Z+3, r19	; 0x03
    2e08:	29 8d       	ldd	r18, Y+25	; 0x19
    2e0a:	3a 8d       	ldd	r19, Y+26	; 0x1a
    2e0c:	24 83       	std	Z+4, r18	; 0x04
    2e0e:	35 83       	std	Z+5, r19	; 0x05
    2e10:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2e12:	3c 8d       	ldd	r19, Y+28	; 0x1c
    2e14:	26 83       	std	Z+6, r18	; 0x06
    2e16:	37 83       	std	Z+7, r19	; 0x07
    2e18:	2d 8d       	ldd	r18, Y+29	; 0x1d
    2e1a:	20 87       	std	Z+8, r18	; 0x08
    2e1c:	64 ec       	ldi	r22, 0xC4	; 196
    2e1e:	49 2f       	mov	r20, r25
    2e20:	29 81       	ldd	r18, Y+1	; 0x01
    2e22:	3a 81       	ldd	r19, Y+2	; 0x02
    2e24:	05 2f       	mov	r16, r21
    2e26:	e7 2e       	mov	r14, r23
    2e28:	63 01       	movw	r12, r6
    2e2a:	52 01       	movw	r10, r4
    2e2c:	41 01       	movw	r8, r2
    2e2e:	0e 94 05 16 	call	0x2c0a	; 0x2c0a <CO_collectSeismic1Channel_ext>
    2e32:	2d b7       	in	r18, 0x3d	; 61
    2e34:	3e b7       	in	r19, 0x3e	; 62
    2e36:	27 5f       	subi	r18, 0xF7	; 247
    2e38:	3f 4f       	sbci	r19, 0xFF	; 255
    2e3a:	2d bf       	out	0x3d, r18	; 61
    2e3c:	3e bf       	out	0x3e, r19	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}
    2e3e:	0f 90       	pop	r0
    2e40:	0f 90       	pop	r0
    2e42:	df 91       	pop	r29
    2e44:	cf 91       	pop	r28
    2e46:	0f 91       	pop	r16
    2e48:	ff 90       	pop	r15
    2e4a:	ef 90       	pop	r14
    2e4c:	df 90       	pop	r13
    2e4e:	cf 90       	pop	r12
    2e50:	bf 90       	pop	r11
    2e52:	af 90       	pop	r10
    2e54:	9f 90       	pop	r9
    2e56:	8f 90       	pop	r8
    2e58:	7f 90       	pop	r7
    2e5a:	6f 90       	pop	r6
    2e5c:	5f 90       	pop	r5
    2e5e:	4f 90       	pop	r4
    2e60:	3f 90       	pop	r3
    2e62:	2f 90       	pop	r2
    2e64:	08 95       	ret

00002e66 <CO_collectSeismic3Axises_ext>:
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}	
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2e66:	2f 92       	push	r2
    2e68:	3f 92       	push	r3
    2e6a:	5f 92       	push	r5
    2e6c:	6f 92       	push	r6
    2e6e:	7f 92       	push	r7
    2e70:	8f 92       	push	r8
    2e72:	9f 92       	push	r9
    2e74:	af 92       	push	r10
    2e76:	bf 92       	push	r11
    2e78:	cf 92       	push	r12
    2e7a:	df 92       	push	r13
    2e7c:	ef 92       	push	r14
    2e7e:	ff 92       	push	r15
    2e80:	0f 93       	push	r16
    2e82:	1f 93       	push	r17
    2e84:	cf 93       	push	r28
    2e86:	df 93       	push	r29
    2e88:	0f 92       	push	r0
    2e8a:	0f 92       	push	r0
    2e8c:	cd b7       	in	r28, 0x3d	; 61
    2e8e:	de b7       	in	r29, 0x3e	; 62
    2e90:	18 2f       	mov	r17, r24
    2e92:	3b 01       	movw	r6, r22
    2e94:	49 83       	std	Y+1, r20	; 0x01
    2e96:	5a 83       	std	Y+2, r21	; 0x02
    2e98:	52 2e       	mov	r5, r18
	
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	ADC_BUFFER = DataArray;
    2e9a:	89 8d       	ldd	r24, Y+25	; 0x19
    2e9c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2e9e:	80 93 64 50 	sts	0x5064, r24
    2ea2:	90 93 65 50 	sts	0x5065, r25
	ADC_Sampling_Finished = 0;
    2ea6:	10 92 a7 50 	sts	0x50A7, r1
	ADC_buffer_size = BufferSize;
    2eaa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2eac:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2eae:	80 93 a8 50 	sts	0x50A8, r24
    2eb2:	90 93 a9 50 	sts	0x50A9, r25
	if(use_FRAM){
    2eb6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2eb8:	88 23       	and	r24, r24
    2eba:	21 f0       	breq	.+8      	; 0x2ec4 <CO_collectSeismic3Axises_ext+0x5e>
		write_to_FRAM = 1;
    2ebc:	81 e0       	ldi	r24, 0x01	; 1
    2ebe:	80 93 49 40 	sts	0x4049, r24
    2ec2:	02 c0       	rjmp	.+4      	; 0x2ec8 <CO_collectSeismic3Axises_ext+0x62>
	}
	else{
		write_to_FRAM = 0;
    2ec4:	10 92 49 40 	sts	0x4049, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2ec8:	81 e0       	ldi	r24, 0x01	; 1
    2eca:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2ece:	85 e0       	ldi	r24, 0x05	; 5
    2ed0:	d3 01       	movw	r26, r6
    2ed2:	6c 91       	ld	r22, X
    2ed4:	0e 94 21 0c 	call	0x1842	; 0x1842 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    2ed8:	86 e0       	ldi	r24, 0x06	; 6
    2eda:	f3 01       	movw	r30, r6
    2edc:	61 81       	ldd	r22, Z+1	; 0x01
    2ede:	0e 94 21 0c 	call	0x1842	; 0x1842 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2ee2:	87 e0       	ldi	r24, 0x07	; 7
    2ee4:	d3 01       	movw	r26, r6
    2ee6:	12 96       	adiw	r26, 0x02	; 2
    2ee8:	6c 91       	ld	r22, X
    2eea:	0e 94 21 0c 	call	0x1842	; 0x1842 <set_ampGain>
	set_filter(filterConfig);
    2eee:	81 2f       	mov	r24, r17
    2ef0:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2ef4:	80 2f       	mov	r24, r16
    2ef6:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2efa:	84 e0       	ldi	r24, 0x04	; 4
    2efc:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2f00:	84 e5       	ldi	r24, 0x54	; 84
    2f02:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2f06:	81 e0       	ldi	r24, 0x01	; 1
    2f08:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    2f0c:	85 e0       	ldi	r24, 0x05	; 5
    2f0e:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2f12:	e0 ea       	ldi	r30, 0xA0	; 160
    2f14:	f6 e0       	ldi	r31, 0x06	; 6
    2f16:	22 e0       	ldi	r18, 0x02	; 2
    2f18:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2f1a:	66 24       	eor	r6, r6
    2f1c:	63 94       	inc	r6
    2f1e:	62 82       	std	Z+2, r6	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2f20:	0f 2e       	mov	r0, r31
    2f22:	f0 e8       	ldi	r31, 0x80	; 128
    2f24:	2f 2e       	mov	r2, r31
    2f26:	f1 e0       	ldi	r31, 0x01	; 1
    2f28:	3f 2e       	mov	r3, r31
    2f2a:	f0 2d       	mov	r31, r0
    2f2c:	88 e7       	ldi	r24, 0x78	; 120
    2f2e:	f1 01       	movw	r30, r2
    2f30:	80 83       	st	Z, r24

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2f32:	e0 e0       	ldi	r30, 0x00	; 0
    2f34:	f8 e0       	ldi	r31, 0x08	; 8
    2f36:	80 ef       	ldi	r24, 0xF0	; 240
    2f38:	81 83       	std	Z+1, r24	; 0x01
	TCC0.CCA = averagingPtA;
    2f3a:	e0 a6       	lds	r30, 0xb0
    2f3c:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    2f3e:	c2 a6       	lds	r28, 0xb2
    2f40:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    2f42:	a4 a6       	lds	r26, 0xb4
    2f44:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    2f46:	86 a6       	lds	r24, 0xb6
    2f48:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    2f4a:	85 2d       	mov	r24, r5
    2f4c:	90 e0       	ldi	r25, 0x00	; 0
    2f4e:	01 97       	sbiw	r24, 0x01	; 1
    2f50:	86 a3       	lds	r24, 0x56
    2f52:	97 a3       	lds	r25, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2f54:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2f56:	8f ef       	ldi	r24, 0xFF	; 255
    2f58:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2f5a:	80 81       	ld	r24, Z
    2f5c:	80 7f       	andi	r24, 0xF0	; 240
    2f5e:	88 60       	ori	r24, 0x08	; 8
    2f60:	80 83       	st	Z, r24

	sampleCount = 0;
    2f62:	10 92 66 50 	sts	0x5066, r1
    2f66:	10 92 67 50 	sts	0x5067, r1
    2f6a:	10 92 68 50 	sts	0x5068, r1
    2f6e:	10 92 69 50 	sts	0x5069, r1
	SPICount = 0;
    2f72:	10 92 a1 50 	sts	0x50A1, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2f76:	84 e1       	ldi	r24, 0x14	; 20
    2f78:	91 e2       	ldi	r25, 0x21	; 33
    2f7a:	10 92 14 21 	sts	0x2114, r1
    2f7e:	fc 01       	movw	r30, r24
    2f80:	31 97       	sbiw	r30, 0x01	; 1
    2f82:	10 82       	st	Z, r1
    2f84:	02 97       	sbiw	r24, 0x02	; 2
    2f86:	dc 01       	movw	r26, r24
    2f88:	1c 92       	st	X, r1

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2f8a:	80 e2       	ldi	r24, 0x20	; 32
    2f8c:	e0 e8       	ldi	r30, 0x80	; 128
    2f8e:	f6 e0       	ldi	r31, 0x06	; 6
    2f90:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2f92:	00 e4       	ldi	r16, 0x40	; 64
    2f94:	1a e0       	ldi	r17, 0x0A	; 10
    2f96:	83 e2       	ldi	r24, 0x23	; 35
    2f98:	f8 01       	movw	r30, r16
    2f9a:	81 83       	std	Z+1, r24	; 0x01
	// set period of waveform generator and duty cycle (want duty cycle to be half the period to get clean clock signal)
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2f9c:	89 81       	ldd	r24, Y+1	; 0x01
    2f9e:	9a 81       	ldd	r25, Y+2	; 0x02
    2fa0:	6c 01       	movw	r12, r24
    2fa2:	ee 24       	eor	r14, r14
    2fa4:	ff 24       	eor	r15, r15
    2fa6:	60 e8       	ldi	r22, 0x80	; 128
    2fa8:	74 e8       	ldi	r23, 0x84	; 132
    2faa:	8e e1       	ldi	r24, 0x1E	; 30
    2fac:	90 e0       	ldi	r25, 0x00	; 0
    2fae:	a7 01       	movw	r20, r14
    2fb0:	96 01       	movw	r18, r12
    2fb2:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    2fb6:	d8 01       	movw	r26, r16
    2fb8:	96 96       	adiw	r26, 0x26	; 38
    2fba:	2d 93       	st	X+, r18
    2fbc:	3c 93       	st	X, r19
    2fbe:	97 97       	sbiw	r26, 0x27	; 39
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2fc0:	60 e4       	ldi	r22, 0x40	; 64
    2fc2:	72 e4       	ldi	r23, 0x42	; 66
    2fc4:	8f e0       	ldi	r24, 0x0F	; 15
    2fc6:	90 e0       	ldi	r25, 0x00	; 0
    2fc8:	a7 01       	movw	r20, r14
    2fca:	96 01       	movw	r18, r12
    2fcc:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    2fd0:	f8 01       	movw	r30, r16
    2fd2:	22 af       	sts	0x72, r18
    2fd4:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2fd6:	e0 e4       	ldi	r30, 0x40	; 64
    2fd8:	f8 e0       	ldi	r31, 0x08	; 8
    2fda:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;	
    2fdc:	8c e0       	ldi	r24, 0x0C	; 12
    2fde:	81 87       	std	Z+9, r24	; 0x09
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2fe0:	8f 89       	ldd	r24, Y+23	; 0x17
    2fe2:	98 8d       	ldd	r25, Y+24	; 0x18
    2fe4:	86 a3       	lds	r24, 0x56
    2fe6:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
    2fe8:	80 ec       	ldi	r24, 0xC0	; 192
    2fea:	d1 01       	movw	r26, r2
    2fec:	11 96       	adiw	r26, 0x01	; 1
    2fee:	8c 93       	st	X, r24
    2ff0:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2ff2:	66 82       	std	Z+6, r6	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2ff4:	80 81       	ld	r24, Z
    2ff6:	80 7f       	andi	r24, 0xF0	; 240
    2ff8:	89 60       	ori	r24, 0x09	; 9
    2ffa:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2ffc:	f8 01       	movw	r30, r16
    2ffe:	80 81       	ld	r24, Z
    3000:	80 7f       	andi	r24, 0xF0	; 240
    3002:	81 60       	ori	r24, 0x01	; 1
    3004:	80 83       	st	Z, r24
	
	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm);
    3006:	e0 ea       	ldi	r30, 0xA0	; 160
    3008:	f0 e0       	ldi	r31, 0x00	; 0
    300a:	82 81       	ldd	r24, Z+2	; 0x02
    300c:	87 60       	ori	r24, 0x07	; 7
    300e:	82 83       	std	Z+2, r24	; 0x02
	sei();
    3010:	78 94       	sei
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    3012:	0f 90       	pop	r0
    3014:	0f 90       	pop	r0
    3016:	df 91       	pop	r29
    3018:	cf 91       	pop	r28
    301a:	1f 91       	pop	r17
    301c:	0f 91       	pop	r16
    301e:	ff 90       	pop	r15
    3020:	ef 90       	pop	r14
    3022:	df 90       	pop	r13
    3024:	cf 90       	pop	r12
    3026:	bf 90       	pop	r11
    3028:	af 90       	pop	r10
    302a:	9f 90       	pop	r9
    302c:	8f 90       	pop	r8
    302e:	7f 90       	pop	r7
    3030:	6f 90       	pop	r6
    3032:	5f 90       	pop	r5
    3034:	3f 90       	pop	r3
    3036:	2f 90       	pop	r2
    3038:	08 95       	ret

0000303a <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    303a:	2f 92       	push	r2
    303c:	3f 92       	push	r3
    303e:	4f 92       	push	r4
    3040:	5f 92       	push	r5
    3042:	6f 92       	push	r6
    3044:	7f 92       	push	r7
    3046:	8f 92       	push	r8
    3048:	9f 92       	push	r9
    304a:	af 92       	push	r10
    304c:	bf 92       	push	r11
    304e:	cf 92       	push	r12
    3050:	df 92       	push	r13
    3052:	ef 92       	push	r14
    3054:	ff 92       	push	r15
    3056:	0f 93       	push	r16
    3058:	1f 93       	push	r17
    305a:	cf 93       	push	r28
    305c:	df 93       	push	r29
    305e:	00 d0       	rcall	.+0      	; 0x3060 <CO_collectSeismic3Axises+0x26>
    3060:	0f 92       	push	r0
    3062:	cd b7       	in	r28, 0x3d	; 61
    3064:	de b7       	in	r29, 0x3e	; 62
    3066:	dc 01       	movw	r26, r24
    3068:	3b 01       	movw	r6, r22
    306a:	94 2f       	mov	r25, r20
    306c:	32 2f       	mov	r19, r18
    306e:	28 01       	movw	r4, r16
    3070:	17 01       	movw	r2, r14
    3072:	c9 82       	std	Y+1, r12	; 0x01
    3074:	da 82       	std	Y+2, r13	; 0x02
    3076:	ab 82       	std	Y+3, r10	; 0x03
    3078:	bc 82       	std	Y+4, r11	; 0x04
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    307a:	4d b7       	in	r20, 0x3d	; 61
    307c:	5e b7       	in	r21, 0x3e	; 62
    307e:	47 50       	subi	r20, 0x07	; 7
    3080:	50 40       	sbci	r21, 0x00	; 0
    3082:	4d bf       	out	0x3d, r20	; 61
    3084:	5e bf       	out	0x3e, r21	; 62
    3086:	6d b7       	in	r22, 0x3d	; 61
    3088:	7e b7       	in	r23, 0x3e	; 62
    308a:	6f 5f       	subi	r22, 0xFF	; 255
    308c:	7f 4f       	sbci	r23, 0xFF	; 255
    308e:	ed b7       	in	r30, 0x3d	; 61
    3090:	fe b7       	in	r31, 0x3e	; 62
    3092:	81 82       	std	Z+1, r8	; 0x01
    3094:	92 82       	std	Z+2, r9	; 0x02
    3096:	4a 8d       	ldd	r20, Y+26	; 0x1a
    3098:	5b 8d       	ldd	r21, Y+27	; 0x1b
    309a:	fb 01       	movw	r30, r22
    309c:	42 83       	std	Z+2, r20	; 0x02
    309e:	53 83       	std	Z+3, r21	; 0x03
    30a0:	4c 8d       	ldd	r20, Y+28	; 0x1c
    30a2:	5d 8d       	ldd	r21, Y+29	; 0x1d
    30a4:	44 83       	std	Z+4, r20	; 0x04
    30a6:	55 83       	std	Z+5, r21	; 0x05
    30a8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    30aa:	86 83       	std	Z+6, r24	; 0x06
    30ac:	84 ec       	ldi	r24, 0xC4	; 196
    30ae:	bd 01       	movw	r22, r26
    30b0:	a3 01       	movw	r20, r6
    30b2:	29 2f       	mov	r18, r25
    30b4:	03 2f       	mov	r16, r19
    30b6:	72 01       	movw	r14, r4
    30b8:	61 01       	movw	r12, r2
    30ba:	a9 80       	ldd	r10, Y+1	; 0x01
    30bc:	ba 80       	ldd	r11, Y+2	; 0x02
    30be:	8b 80       	ldd	r8, Y+3	; 0x03
    30c0:	9c 80       	ldd	r9, Y+4	; 0x04
    30c2:	0e 94 33 17 	call	0x2e66	; 0x2e66 <CO_collectSeismic3Axises_ext>
    30c6:	4d b7       	in	r20, 0x3d	; 61
    30c8:	5e b7       	in	r21, 0x3e	; 62
    30ca:	49 5f       	subi	r20, 0xF9	; 249
    30cc:	5f 4f       	sbci	r21, 0xFF	; 255
    30ce:	4d bf       	out	0x3d, r20	; 61
    30d0:	5e bf       	out	0x3e, r21	; 62
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}	
    30d2:	24 96       	adiw	r28, 0x04	; 4
    30d4:	cd bf       	out	0x3d, r28	; 61
    30d6:	de bf       	out	0x3e, r29	; 62
    30d8:	df 91       	pop	r29
    30da:	cf 91       	pop	r28
    30dc:	1f 91       	pop	r17
    30de:	0f 91       	pop	r16
    30e0:	ff 90       	pop	r15
    30e2:	ef 90       	pop	r14
    30e4:	df 90       	pop	r13
    30e6:	cf 90       	pop	r12
    30e8:	bf 90       	pop	r11
    30ea:	af 90       	pop	r10
    30ec:	9f 90       	pop	r9
    30ee:	8f 90       	pop	r8
    30f0:	7f 90       	pop	r7
    30f2:	6f 90       	pop	r6
    30f4:	5f 90       	pop	r5
    30f6:	4f 90       	pop	r4
    30f8:	3f 90       	pop	r3
    30fa:	2f 90       	pop	r2
    30fc:	08 95       	ret

000030fe <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    30fe:	6f 92       	push	r6
    3100:	7f 92       	push	r7
    3102:	8f 92       	push	r8
    3104:	9f 92       	push	r9
    3106:	af 92       	push	r10
    3108:	bf 92       	push	r11
    310a:	cf 92       	push	r12
    310c:	df 92       	push	r13
    310e:	ef 92       	push	r14
    3110:	ff 92       	push	r15
    3112:	0f 93       	push	r16
    3114:	1f 93       	push	r17
    3116:	cf 93       	push	r28
    3118:	df 93       	push	r29
    311a:	c8 2f       	mov	r28, r24
    311c:	b6 2e       	mov	r11, r22
    311e:	d4 2f       	mov	r29, r20
    3120:	49 01       	movw	r8, r18
    3122:	38 01       	movw	r6, r16
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	uint16_t period;
	ADC_BUFFER = DataArray;
    3124:	e0 92 64 50 	sts	0x5064, r14
    3128:	f0 92 65 50 	sts	0x5065, r15
	ADC_Sampling_Finished = 0;
    312c:	10 92 a7 50 	sts	0x50A7, r1
	ADC_buffer_size = BufferSize;
    3130:	c0 92 a8 50 	sts	0x50A8, r12
    3134:	d0 92 a9 50 	sts	0x50A9, r13
	if(use_FRAM){
    3138:	aa 20       	and	r10, r10
    313a:	21 f0       	breq	.+8      	; 0x3144 <CO_collectADC_ext+0x46>
		write_to_FRAM = 1;
    313c:	81 e0       	ldi	r24, 0x01	; 1
    313e:	80 93 49 40 	sts	0x4049, r24
    3142:	02 c0       	rjmp	.+4      	; 0x3148 <CO_collectADC_ext+0x4a>
	}
	else{
		write_to_FRAM = 0;
    3144:	10 92 49 40 	sts	0x4049, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    3148:	81 e0       	ldi	r24, 0x01	; 1
    314a:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    314e:	8c 2f       	mov	r24, r28
    3150:	6d 2f       	mov	r22, r29
    3152:	0e 94 21 0c 	call	0x1842	; 0x1842 <set_ampGain>
	set_filter(filterConfig);
    3156:	8b 2d       	mov	r24, r11
    3158:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    315c:	8c 2f       	mov	r24, r28
    315e:	85 50       	subi	r24, 0x05	; 5
    3160:	83 30       	cpi	r24, 0x03	; 3
    3162:	18 f4       	brcc	.+6      	; 0x316a <CO_collectADC_ext+0x6c>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    3164:	81 e0       	ldi	r24, 0x01	; 1
    3166:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    316a:	81 e0       	ldi	r24, 0x01	; 1
    316c:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <enableADCMUX>
	setADCInput(channel);
    3170:	8c 2f       	mov	r24, r28
    3172:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    3176:	84 e0       	ldi	r24, 0x04	; 4
    3178:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    317c:	84 e5       	ldi	r24, 0x54	; 84
    317e:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    3182:	e0 ea       	ldi	r30, 0xA0	; 160
    3184:	f6 e0       	ldi	r31, 0x06	; 6
    3186:	ee 24       	eor	r14, r14
    3188:	e3 94       	inc	r14
    318a:	e2 82       	std	Z+2, r14	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    318c:	82 e0       	ldi	r24, 0x02	; 2
    318e:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    3190:	e2 86       	std	Z+10, r14	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_MED_gc;				
    3192:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    3194:	80 e2       	ldi	r24, 0x20	; 32
    3196:	e0 e8       	ldi	r30, 0x80	; 128
    3198:	f6 e0       	ldi	r31, 0x06	; 6
    319a:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    319c:	c0 e4       	ldi	r28, 0x40	; 64
    319e:	da e0       	ldi	r29, 0x0A	; 10
    31a0:	83 e2       	ldi	r24, 0x23	; 35
    31a2:	89 83       	std	Y+1, r24	; 0x01
	// set period of waveform generator and ccb as duty cycle (want half the period for duty cycle to have good clock signal)
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    31a4:	94 01       	movw	r18, r8
    31a6:	40 e0       	ldi	r20, 0x00	; 0
    31a8:	50 e0       	ldi	r21, 0x00	; 0
    31aa:	60 e8       	ldi	r22, 0x80	; 128
    31ac:	74 e8       	ldi	r23, 0x84	; 132
    31ae:	8e e1       	ldi	r24, 0x1E	; 30
    31b0:	90 e0       	ldi	r25, 0x00	; 0
    31b2:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    31b6:	89 01       	movw	r16, r18
    31b8:	9a 01       	movw	r18, r20
    31ba:	c8 01       	movw	r24, r16
	TCE1.PER = period;
    31bc:	0e a3       	lds	r16, 0x5e
    31be:	1f a3       	lds	r17, 0x5f
	TCE1.CCBBUF = period / 2;
    31c0:	96 95       	lsr	r25
    31c2:	87 95       	ror	r24
    31c4:	8a af       	sts	0x7a, r24
    31c6:	9b af       	sts	0x7b, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//reset count to zero
	TCC1.CTRLA = 0x00;
    31c8:	e0 e4       	ldi	r30, 0x40	; 64
    31ca:	f8 e0       	ldi	r31, 0x08	; 8
    31cc:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;
    31ce:	8c e0       	ldi	r24, 0x0C	; 12
    31d0:	81 87       	std	Z+9, r24	; 0x09
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples;
    31d2:	66 a2       	lds	r22, 0x96
    31d4:	77 a2       	lds	r23, 0x97
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    31d6:	88 e7       	ldi	r24, 0x78	; 120
    31d8:	a0 e8       	ldi	r26, 0x80	; 128
    31da:	b1 e0       	ldi	r27, 0x01	; 1
    31dc:	11 96       	adiw	r26, 0x01	; 1
    31de:	8c 93       	st	X, r24
    31e0:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    31e2:	e6 82       	std	Z+6, r14	; 0x06
	//TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    31e4:	88 81       	ld	r24, Y
    31e6:	80 7f       	andi	r24, 0xF0	; 240
    31e8:	81 60       	ori	r24, 0x01	; 1
    31ea:	88 83       	st	Y, r24
	
	sampleCount = 0;
    31ec:	10 92 66 50 	sts	0x5066, r1
    31f0:	10 92 67 50 	sts	0x5067, r1
    31f4:	10 92 68 50 	sts	0x5068, r1
    31f8:	10 92 69 50 	sts	0x5069, r1
	discardCount = 0;
    31fc:	10 92 5d 40 	sts	0x405D, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
    3200:	e0 ea       	ldi	r30, 0xA0	; 160
    3202:	f0 e0       	ldi	r31, 0x00	; 0
    3204:	82 81       	ldd	r24, Z+2	; 0x02
    3206:	83 60       	ori	r24, 0x03	; 3
    3208:	82 83       	std	Z+2, r24	; 0x02
	sei();
    320a:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    320c:	df 91       	pop	r29
    320e:	cf 91       	pop	r28
    3210:	1f 91       	pop	r17
    3212:	0f 91       	pop	r16
    3214:	ff 90       	pop	r15
    3216:	ef 90       	pop	r14
    3218:	df 90       	pop	r13
    321a:	cf 90       	pop	r12
    321c:	bf 90       	pop	r11
    321e:	af 90       	pop	r10
    3220:	9f 90       	pop	r9
    3222:	8f 90       	pop	r8
    3224:	7f 90       	pop	r7
    3226:	6f 90       	pop	r6
    3228:	08 95       	ret

0000322a <CO_collectADC>:
		PORTA.OUTCLR = PIN5_bm;
		PORTA.DIRCLR = PIN5_bm;
	}
}

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    322a:	8f 92       	push	r8
    322c:	9f 92       	push	r9
    322e:	af 92       	push	r10
    3230:	cf 92       	push	r12
    3232:	df 92       	push	r13
    3234:	ef 92       	push	r14
    3236:	ff 92       	push	r15
    3238:	0f 93       	push	r16
    323a:	1f 93       	push	r17
    323c:	cf 93       	push	r28
    323e:	df 93       	push	r29
    3240:	96 2f       	mov	r25, r22
    3242:	fa 01       	movw	r30, r20
    3244:	d9 01       	movw	r26, r18
    3246:	e8 01       	movw	r28, r16
    3248:	47 01       	movw	r8, r14
    324a:	ac 2c       	mov	r10, r12
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_1AND5_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray, BufferSize, use_FRAM);
    324c:	61 ec       	ldi	r22, 0xC1	; 193
    324e:	49 2f       	mov	r20, r25
    3250:	9f 01       	movw	r18, r30
    3252:	8d 01       	movw	r16, r26
    3254:	7e 01       	movw	r14, r28
    3256:	64 01       	movw	r12, r8
    3258:	0e 94 7f 18 	call	0x30fe	; 0x30fe <CO_collectADC_ext>
}
    325c:	df 91       	pop	r29
    325e:	cf 91       	pop	r28
    3260:	1f 91       	pop	r17
    3262:	0f 91       	pop	r16
    3264:	ff 90       	pop	r15
    3266:	ef 90       	pop	r14
    3268:	df 90       	pop	r13
    326a:	cf 90       	pop	r12
    326c:	af 90       	pop	r10
    326e:	9f 90       	pop	r9
    3270:	8f 90       	pop	r8
    3272:	08 95       	ret

00003274 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    3274:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3276:	81 e0       	ldi	r24, 0x01	; 1
    3278:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    327a:	84 81       	ldd	r24, Z+4	; 0x04
    327c:	95 81       	ldd	r25, Z+5	; 0x05
    327e:	86 1b       	sub	r24, r22
    3280:	91 09       	sbc	r25, r1

	return answer;
}
    3282:	08 95       	ret

00003284 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    3284:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3286:	81 e0       	ldi	r24, 0x01	; 1
    3288:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    328a:	84 81       	ldd	r24, Z+4	; 0x04
    328c:	95 81       	ldd	r25, Z+5	; 0x05
    328e:	77 27       	eor	r23, r23
    3290:	67 fd       	sbrc	r22, 7
    3292:	70 95       	com	r23
    3294:	86 1b       	sub	r24, r22
    3296:	97 0b       	sbc	r25, r23

	return answer;
}
    3298:	08 95       	ret

0000329a <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    329a:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    329c:	81 e0       	ldi	r24, 0x01	; 1
    329e:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    32a0:	84 81       	ldd	r24, Z+4	; 0x04
    32a2:	95 81       	ldd	r25, Z+5	; 0x05
}
    32a4:	08 95       	ret

000032a6 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    32a6:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    32a8:	81 e0       	ldi	r24, 0x01	; 1
    32aa:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    32ac:	84 81       	ldd	r24, Z+4	; 0x04
}
    32ae:	08 95       	ret

000032b0 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    32b0:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    32b2:	81 e0       	ldi	r24, 0x01	; 1
    32b4:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    32b6:	85 81       	ldd	r24, Z+5	; 0x05
}
    32b8:	08 95       	ret

000032ba <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    32ba:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    32bc:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    32be:	14 82       	std	Z+4, r1	; 0x04
    32c0:	9a e2       	ldi	r25, 0x2A	; 42
    32c2:	9a 95       	dec	r25
    32c4:	f1 f7       	brne	.-4      	; 0x32c2 <ADC_Wait_8MHz+0x8>
    32c6:	00 c0       	rjmp	.+0      	; 0x32c8 <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    32c8:	84 83       	std	Z+4, r24	; 0x04
}
    32ca:	08 95       	ret

000032cc <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    32cc:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    32ce:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    32d0:	91 e0       	ldi	r25, 0x01	; 1
    32d2:	94 83       	std	Z+4, r25	; 0x04
    32d4:	95 e5       	ldi	r25, 0x55	; 85
    32d6:	9a 95       	dec	r25
    32d8:	f1 f7       	brne	.-4      	; 0x32d6 <ADC_Wait_32MHz+0xa>
    32da:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    32dc:	84 83       	std	Z+4, r24	; 0x04
}
    32de:	08 95       	ret

000032e0 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    32e0:	ef 92       	push	r14
    32e2:	ff 92       	push	r15
    32e4:	0f 93       	push	r16
    32e6:	1f 93       	push	r17
    32e8:	cf 93       	push	r28
    32ea:	df 93       	push	r29
    32ec:	eb 01       	movw	r28, r22
    if (oversampling)
    32ee:	44 23       	and	r20, r20
    32f0:	c9 f0       	breq	.+50     	; 0x3324 <ADC_Offset_Get_Unsigned+0x44>
    32f2:	04 e0       	ldi	r16, 0x04	; 4
    32f4:	10 e0       	ldi	r17, 0x00	; 0
    32f6:	ee 24       	eor	r14, r14
    32f8:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    32fa:	88 81       	ld	r24, Y
    32fc:	80 68       	ori	r24, 0x80	; 128
    32fe:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3300:	8b 81       	ldd	r24, Y+3	; 0x03
    3302:	80 ff       	sbrs	r24, 0
    3304:	fd cf       	rjmp	.-6      	; 0x3300 <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    3306:	ce 01       	movw	r24, r28
    3308:	60 e0       	ldi	r22, 0x00	; 0
    330a:	0e 94 3a 19 	call	0x3274	; 0x3274 <ADC_ResultCh_GetWord_Unsigned>
    330e:	e8 0e       	add	r14, r24
    3310:	f9 1e       	adc	r15, r25
    3312:	01 50       	subi	r16, 0x01	; 1
    3314:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    3316:	89 f7       	brne	.-30     	; 0x32fa <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    3318:	c7 01       	movw	r24, r14
    331a:	96 95       	lsr	r25
    331c:	87 95       	ror	r24
    331e:	96 95       	lsr	r25
    3320:	87 95       	ror	r24
    3322:	09 c0       	rjmp	.+18     	; 0x3336 <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3324:	88 81       	ld	r24, Y
    3326:	80 68       	ori	r24, 0x80	; 128
    3328:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    332a:	8b 81       	ldd	r24, Y+3	; 0x03
    332c:	80 ff       	sbrs	r24, 0
    332e:	fd cf       	rjmp	.-6      	; 0x332a <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    3330:	ce 01       	movw	r24, r28
    3332:	0e 94 4d 19 	call	0x329a	; 0x329a <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
    3336:	df 91       	pop	r29
    3338:	cf 91       	pop	r28
    333a:	1f 91       	pop	r17
    333c:	0f 91       	pop	r16
    333e:	ff 90       	pop	r15
    3340:	ef 90       	pop	r14
    3342:	08 95       	ret

00003344 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3344:	ef 92       	push	r14
    3346:	ff 92       	push	r15
    3348:	0f 93       	push	r16
    334a:	1f 93       	push	r17
    334c:	cf 93       	push	r28
    334e:	df 93       	push	r29
    3350:	eb 01       	movw	r28, r22
    if (oversampling)
    3352:	44 23       	and	r20, r20
    3354:	e1 f0       	breq	.+56     	; 0x338e <ADC_Offset_Get_Signed+0x4a>
    3356:	04 e0       	ldi	r16, 0x04	; 4
    3358:	10 e0       	ldi	r17, 0x00	; 0
    335a:	ee 24       	eor	r14, r14
    335c:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    335e:	88 81       	ld	r24, Y
    3360:	80 68       	ori	r24, 0x80	; 128
    3362:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3364:	8b 81       	ldd	r24, Y+3	; 0x03
    3366:	80 ff       	sbrs	r24, 0
    3368:	fd cf       	rjmp	.-6      	; 0x3364 <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    336a:	ce 01       	movw	r24, r28
    336c:	60 e0       	ldi	r22, 0x00	; 0
    336e:	0e 94 42 19 	call	0x3284	; 0x3284 <ADC_ResultCh_GetWord_Signed>
    3372:	e8 0e       	add	r14, r24
    3374:	f9 1e       	adc	r15, r25
    3376:	01 50       	subi	r16, 0x01	; 1
    3378:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    337a:	89 f7       	brne	.-30     	; 0x335e <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    337c:	c7 01       	movw	r24, r14
    337e:	99 23       	and	r25, r25
    3380:	0c f4       	brge	.+2      	; 0x3384 <ADC_Offset_Get_Signed+0x40>
    3382:	03 96       	adiw	r24, 0x03	; 3
    3384:	95 95       	asr	r25
    3386:	87 95       	ror	r24
    3388:	95 95       	asr	r25
    338a:	87 95       	ror	r24
    338c:	0a c0       	rjmp	.+20     	; 0x33a2 <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    338e:	88 81       	ld	r24, Y
    3390:	80 68       	ori	r24, 0x80	; 128
    3392:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3394:	8b 81       	ldd	r24, Y+3	; 0x03
    3396:	80 ff       	sbrs	r24, 0
    3398:	fd cf       	rjmp	.-6      	; 0x3394 <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    339a:	ce 01       	movw	r24, r28
    339c:	60 e0       	ldi	r22, 0x00	; 0
    339e:	0e 94 42 19 	call	0x3284	; 0x3284 <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
    33a2:	df 91       	pop	r29
    33a4:	cf 91       	pop	r28
    33a6:	1f 91       	pop	r17
    33a8:	0f 91       	pop	r16
    33aa:	ff 90       	pop	r15
    33ac:	ef 90       	pop	r14
    33ae:	08 95       	ret

000033b0 <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    33b0:	aa ec       	ldi	r26, 0xCA	; 202
    33b2:	b1 e0       	ldi	r27, 0x01	; 1
    33b4:	92 e0       	ldi	r25, 0x02	; 2
    33b6:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
    33b8:	e8 2f       	mov	r30, r24
    33ba:	f0 e0       	ldi	r31, 0x00	; 0
    33bc:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    33be:	1c 92       	st	X, r1

	return result;
}
    33c0:	08 95       	ret

000033c2 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    33c2:	cf 93       	push	r28
    33c4:	df 93       	push	r29
    33c6:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
    33c8:	82 e0       	ldi	r24, 0x02	; 2
    33ca:	c0 30       	cpi	r28, 0x00	; 0
    33cc:	d8 07       	cpc	r29, r24
    33ce:	59 f4       	brne	.+22     	; 0x33e6 <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    33d0:	80 e2       	ldi	r24, 0x20	; 32
    33d2:	0e 94 d8 19 	call	0x33b0	; 0x33b0 <SP_ReadCalibrationByte>
    33d6:	c0 e0       	ldi	r28, 0x00	; 0
    33d8:	d2 e0       	ldi	r29, 0x02	; 2
    33da:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    33dc:	81 e2       	ldi	r24, 0x21	; 33
    33de:	0e 94 d8 19 	call	0x33b0	; 0x33b0 <SP_ReadCalibrationByte>
    33e2:	8d 87       	std	Y+13, r24	; 0x0d
    33e4:	08 c0       	rjmp	.+16     	; 0x33f6 <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    33e6:	84 e2       	ldi	r24, 0x24	; 36
    33e8:	0e 94 d8 19 	call	0x33b0	; 0x33b0 <SP_ReadCalibrationByte>
    33ec:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    33ee:	85 e2       	ldi	r24, 0x25	; 37
    33f0:	0e 94 d8 19 	call	0x33b0	; 0x33b0 <SP_ReadCalibrationByte>
    33f4:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
    33f6:	df 91       	pop	r29
    33f8:	cf 91       	pop	r28
    33fa:	08 95       	ret

000033fc <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
    33fc:	84 e1       	ldi	r24, 0x14	; 20
    33fe:	e5 e1       	ldi	r30, 0x15	; 21
    3400:	f1 e2       	ldi	r31, 0x21	; 33
    3402:	df 01       	movw	r26, r30
    3404:	1d 92       	st	X+, r1
    3406:	8a 95       	dec	r24
    3408:	e9 f7       	brne	.-6      	; 0x3404 <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
    340a:	0e 94 5f 1b 	call	0x36be	; 0x36be <chb_get_short_addr>
    340e:	80 93 15 21 	sts	0x2115, r24
    3412:	90 93 16 21 	sts	0x2116, r25
    chb_drvr_init();
    3416:	0e 94 bf 1d 	call	0x3b7e	; 0x3b7e <chb_drvr_init>
	//radio_msg_received_int_enable();
}
    341a:	08 95       	ret

0000341c <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
	PORTE.DIRSET = PIN2_bm;
    341c:	e0 e8       	ldi	r30, 0x80	; 128
    341e:	f6 e0       	ldi	r31, 0x06	; 6
    3420:	84 e0       	ldi	r24, 0x04	; 4
    3422:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    3424:	86 83       	std	Z+6, r24	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    3426:	92 e0       	ldi	r25, 0x02	; 2
    3428:	90 8b       	std	Z+16, r25	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    342a:	82 87       	std	Z+10, r24	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    342c:	83 e0       	ldi	r24, 0x03	; 3
    342e:	81 87       	std	Z+9, r24	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    3430:	e0 ea       	ldi	r30, 0xA0	; 160
    3432:	f0 e0       	ldi	r31, 0x00	; 0
    3434:	82 81       	ldd	r24, Z+2	; 0x02
    3436:	84 60       	ori	r24, 0x04	; 4
    3438:	82 83       	std	Z+2, r24	; 0x02
	sei();
    343a:	78 94       	sei
}
    343c:	08 95       	ret

0000343e <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
    343e:	85 e1       	ldi	r24, 0x15	; 21
    3440:	91 e2       	ldi	r25, 0x21	; 33
    3442:	08 95       	ret

00003444 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    3444:	2f 92       	push	r2
    3446:	3f 92       	push	r3
    3448:	4f 92       	push	r4
    344a:	5f 92       	push	r5
    344c:	6f 92       	push	r6
    344e:	7f 92       	push	r7
    3450:	8f 92       	push	r8
    3452:	9f 92       	push	r9
    3454:	af 92       	push	r10
    3456:	bf 92       	push	r11
    3458:	cf 92       	push	r12
    345a:	df 92       	push	r13
    345c:	ef 92       	push	r14
    345e:	ff 92       	push	r15
    3460:	0f 93       	push	r16
    3462:	1f 93       	push	r17
    3464:	cf 93       	push	r28
    3466:	df 93       	push	r29
    3468:	cd b7       	in	r28, 0x3d	; 61
    346a:	de b7       	in	r29, 0x3e	; 62
    346c:	2a 97       	sbiw	r28, 0x0a	; 10
    346e:	cd bf       	out	0x3d, r28	; 61
    3470:	de bf       	out	0x3e, r29	; 62
    3472:	2c 01       	movw	r4, r24
    3474:	1b 01       	movw	r2, r22
    3476:	69 01       	movw	r12, r18
    3478:	7a 01       	movw	r14, r20
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    347a:	21 15       	cp	r18, r1
    347c:	31 05       	cpc	r19, r1
    347e:	41 05       	cpc	r20, r1
    3480:	51 05       	cpc	r21, r1
    3482:	09 f4       	brne	.+2      	; 0x3486 <chb_write+0x42>
    3484:	68 c0       	rjmp	.+208    	; 0x3556 <chb_write+0x112>
    U8 status, frm_len, hdr[CHB_HDR_SZ + 1];
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    3486:	88 24       	eor	r8, r8
    3488:	99 24       	eor	r9, r9
    348a:	54 01       	movw	r10, r8
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    348c:	08 e9       	ldi	r16, 0x98	; 152

    *hdr_ptr++ = pcb.seq++;
    348e:	0f 2e       	mov	r0, r31
    3490:	f7 e1       	ldi	r31, 0x17	; 23
    3492:	6f 2e       	mov	r6, r31
    3494:	f1 e2       	ldi	r31, 0x21	; 33
    3496:	7f 2e       	mov	r7, r31
    3498:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    349a:	1c 2d       	mov	r17, r12
    349c:	85 e6       	ldi	r24, 0x65	; 101
    349e:	c8 16       	cp	r12, r24
    34a0:	d1 04       	cpc	r13, r1
    34a2:	e1 04       	cpc	r14, r1
    34a4:	f1 04       	cpc	r15, r1
    34a6:	08 f0       	brcs	.+2      	; 0x34aa <chb_write+0x66>
    34a8:	14 e6       	ldi	r17, 0x64	; 100
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    34aa:	81 2f       	mov	r24, r17
    34ac:	85 5f       	subi	r24, 0xF5	; 245
    34ae:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    34b0:	9f ef       	ldi	r25, 0xFF	; 255
    34b2:	49 16       	cp	r4, r25
    34b4:	9f ef       	ldi	r25, 0xFF	; 255
    34b6:	59 06       	cpc	r5, r25
    34b8:	11 f0       	breq	.+4      	; 0x34be <chb_write+0x7a>
    34ba:	81 e6       	ldi	r24, 0x61	; 97
    34bc:	01 c0       	rjmp	.+2      	; 0x34c0 <chb_write+0x7c>
    34be:	81 e4       	ldi	r24, 0x41	; 65
    34c0:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    34c2:	0b 83       	std	Y+3, r16	; 0x03

    *hdr_ptr++ = pcb.seq++;
    34c4:	f3 01       	movw	r30, r6
    34c6:	80 81       	ld	r24, Z
    34c8:	8c 83       	std	Y+4, r24	; 0x04
    34ca:	8f 5f       	subi	r24, 0xFF	; 255
    34cc:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    34ce:	84 e3       	ldi	r24, 0x34	; 52
    34d0:	92 e1       	ldi	r25, 0x12	; 18
    34d2:	8d 83       	std	Y+5, r24	; 0x05
    34d4:	9e 83       	std	Y+6, r25	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
    34d6:	4f 82       	std	Y+7, r4	; 0x07
    34d8:	58 86       	std	Y+8, r5	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
    34da:	e5 e1       	ldi	r30, 0x15	; 21
    34dc:	f1 e2       	ldi	r31, 0x21	; 33
    34de:	80 81       	ld	r24, Z
    34e0:	91 81       	ldd	r25, Z+1	; 0x01
    34e2:	89 87       	std	Y+9, r24	; 0x09
    34e4:	9a 87       	std	Y+10, r25	; 0x0a
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		//rtry = 0;
		//do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    34e6:	b1 01       	movw	r22, r2
    34e8:	68 0d       	add	r22, r8
    34ea:	79 1d       	adc	r23, r9
    34ec:	ce 01       	movw	r24, r28
    34ee:	01 96       	adiw	r24, 0x01	; 1
    34f0:	41 2f       	mov	r20, r17
    34f2:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <chb_tx>

             switch (status)
    34f6:	83 30       	cpi	r24, 0x03	; 3
    34f8:	c9 f0       	breq	.+50     	; 0x352c <chb_write+0xe8>
    34fa:	84 30       	cpi	r24, 0x04	; 4
    34fc:	18 f4       	brcc	.+6      	; 0x3504 <chb_write+0xc0>
    34fe:	81 30       	cpi	r24, 0x01	; 1
    3500:	e1 f4       	brne	.+56     	; 0x353a <chb_write+0xf6>
    3502:	04 c0       	rjmp	.+8      	; 0x350c <chb_write+0xc8>
    3504:	85 30       	cpi	r24, 0x05	; 5
    3506:	51 f0       	breq	.+20     	; 0x351c <chb_write+0xd8>
    3508:	80 34       	cpi	r24, 0x40	; 64
    350a:	b9 f4       	brne	.+46     	; 0x353a <chb_write+0xf6>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    350c:	ec e1       	ldi	r30, 0x1C	; 28
    350e:	f1 e2       	ldi	r31, 0x21	; 33
    3510:	80 81       	ld	r24, Z
    3512:	91 81       	ldd	r25, Z+1	; 0x01
    3514:	01 96       	adiw	r24, 0x01	; 1
    3516:	80 83       	st	Z, r24
    3518:	91 83       	std	Z+1, r25	; 0x01
                 break;
    351a:	0f c0       	rjmp	.+30     	; 0x353a <chb_write+0xf6>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    351c:	ee e1       	ldi	r30, 0x1E	; 30
    351e:	f1 e2       	ldi	r31, 0x21	; 33
    3520:	80 81       	ld	r24, Z
    3522:	91 81       	ldd	r25, Z+1	; 0x01
    3524:	01 96       	adiw	r24, 0x01	; 1
    3526:	80 83       	st	Z, r24
    3528:	91 83       	std	Z+1, r25	; 0x01
				 //rtry++;
                 break;
    352a:	07 c0       	rjmp	.+14     	; 0x353a <chb_write+0xf6>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    352c:	e0 e2       	ldi	r30, 0x20	; 32
    352e:	f1 e2       	ldi	r31, 0x21	; 33
    3530:	80 81       	ld	r24, Z
    3532:	91 81       	ldd	r25, Z+1	; 0x01
    3534:	01 96       	adiw	r24, 0x01	; 1
    3536:	80 83       	st	Z, r24
    3538:	91 83       	std	Z+1, r25	; 0x01
             }
			//if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
			//if(rtry==20) return status;;		//after 20 tries give up on sending the message	
		//} while(status != CHB_SUCCESS);			
        // adjust len and restart
		frm_offset += frm_len;
    353a:	81 2f       	mov	r24, r17
    353c:	90 e0       	ldi	r25, 0x00	; 0
    353e:	a0 e0       	ldi	r26, 0x00	; 0
    3540:	b0 e0       	ldi	r27, 0x00	; 0
    3542:	88 0e       	add	r8, r24
    3544:	99 1e       	adc	r9, r25
    3546:	aa 1e       	adc	r10, r26
    3548:	bb 1e       	adc	r11, r27
		//if (len > CHB_MAX_PAYLOAD) _delay_ms(100);				//wait a little before sending next message
        len = len - frm_len;
    354a:	c8 1a       	sub	r12, r24
    354c:	d9 0a       	sbc	r13, r25
    354e:	ea 0a       	sbc	r14, r26
    3550:	fb 0a       	sbc	r15, r27
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    3552:	09 f0       	breq	.+2      	; 0x3556 <chb_write+0x112>
    3554:	a2 cf       	rjmp	.-188    	; 0x349a <chb_write+0x56>
		//if (len > CHB_MAX_PAYLOAD) _delay_ms(100);				//wait a little before sending next message
        len = len - frm_len;
    }
	if(status == CHB_SUCCESS || CHB_SUCCESS_DATA_PENDING) return CHB_SUCCESS;
	else return 1;
}
    3556:	80 e0       	ldi	r24, 0x00	; 0
    3558:	2a 96       	adiw	r28, 0x0a	; 10
    355a:	cd bf       	out	0x3d, r28	; 61
    355c:	de bf       	out	0x3e, r29	; 62
    355e:	df 91       	pop	r29
    3560:	cf 91       	pop	r28
    3562:	1f 91       	pop	r17
    3564:	0f 91       	pop	r16
    3566:	ff 90       	pop	r15
    3568:	ef 90       	pop	r14
    356a:	df 90       	pop	r13
    356c:	cf 90       	pop	r12
    356e:	bf 90       	pop	r11
    3570:	af 90       	pop	r10
    3572:	9f 90       	pop	r9
    3574:	8f 90       	pop	r8
    3576:	7f 90       	pop	r7
    3578:	6f 90       	pop	r6
    357a:	5f 90       	pop	r5
    357c:	4f 90       	pop	r4
    357e:	3f 90       	pop	r3
    3580:	2f 90       	pop	r2
    3582:	08 95       	ret

00003584 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    3584:	df 92       	push	r13
    3586:	ef 92       	push	r14
    3588:	ff 92       	push	r15
    358a:	0f 93       	push	r16
    358c:	1f 93       	push	r17
    358e:	cf 93       	push	r28
    3590:	df 93       	push	r29
    3592:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    3594:	0e 94 3d 1b 	call	0x367a	; 0x367a <chb_buf_read>
    3598:	d8 2e       	mov	r13, r24
    359a:	88 23       	and	r24, r24
    359c:	0c f4       	brge	.+2      	; 0x35a0 <chb_read+0x1c>
    359e:	46 c0       	rjmp	.+140    	; 0x362c <chb_read+0xa8>
    {
        return 0;
    }
    *data_ptr++ = len;
    35a0:	f7 01       	movw	r30, r14
    35a2:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    35a4:	88 23       	and	r24, r24
    35a6:	71 f0       	breq	.+28     	; 0x35c4 <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
    35a8:	e7 01       	movw	r28, r14
    35aa:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
    35ac:	87 01       	movw	r16, r14
    35ae:	09 5f       	subi	r16, 0xF9	; 249
    35b0:	1f 4f       	sbci	r17, 0xFF	; 255
    35b2:	81 50       	subi	r24, 0x01	; 1
    35b4:	08 0f       	add	r16, r24
    35b6:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
    35b8:	0e 94 3d 1b 	call	0x367a	; 0x367a <chb_buf_read>
    35bc:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    35be:	c0 17       	cp	r28, r16
    35c0:	d1 07       	cpc	r29, r17
    35c2:	d1 f7       	brne	.-12     	; 0x35b8 <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
    35c4:	f7 01       	movw	r30, r14
    35c6:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
    35c8:	83 85       	ldd	r24, Z+11	; 0x0b
    35ca:	94 85       	ldd	r25, Z+12	; 0x0c
    35cc:	83 83       	std	Z+3, r24	; 0x03
    35ce:	94 83       	std	Z+4, r25	; 0x04
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
    35d0:	85 85       	ldd	r24, Z+13	; 0x0d
    35d2:	96 85       	ldd	r25, Z+14	; 0x0e
    35d4:	81 83       	std	Z+1, r24	; 0x01
    35d6:	92 83       	std	Z+2, r25	; 0x02
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    35d8:	0e 94 54 1b 	call	0x36a8	; 0x36a8 <chb_buf_get_len>
    35dc:	88 23       	and	r24, r24
    35de:	11 f4       	brne	.+4      	; 0x35e4 <chb_read+0x60>
    {
        pcb.data_rcv = false;
    35e0:	10 92 18 21 	sts	0x2118, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    35e4:	80 91 0a 20 	lds	r24, 0x200A
    35e8:	c8 17       	cp	r28, r24
    35ea:	51 f4       	brne	.+20     	; 0x3600 <chb_read+0x7c>
    35ec:	f7 01       	movw	r30, r14
    35ee:	21 81       	ldd	r18, Z+1	; 0x01
    35f0:	32 81       	ldd	r19, Z+2	; 0x02
    35f2:	80 91 0b 20 	lds	r24, 0x200B
    35f6:	90 91 0c 20 	lds	r25, 0x200C
    35fa:	28 17       	cp	r18, r24
    35fc:	39 07       	cpc	r19, r25
    35fe:	c1 f0       	breq	.+48     	; 0x3630 <chb_read+0xac>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
    3600:	c0 93 0a 20 	sts	0x200A, r28
        prev_src_addr = rx->src_addr;
    3604:	f7 01       	movw	r30, r14
    3606:	81 81       	ldd	r24, Z+1	; 0x01
    3608:	92 81       	ldd	r25, Z+2	; 0x02
    360a:	80 93 0b 20 	sts	0x200B, r24
    360e:	90 93 0c 20 	sts	0x200C, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    3612:	b7 01       	movw	r22, r14
    3614:	61 5f       	subi	r22, 0xF1	; 241
    3616:	7f 4f       	sbci	r23, 0xFF	; 255
    3618:	4d 2d       	mov	r20, r13
    361a:	50 e0       	ldi	r21, 0x00	; 0
    361c:	49 50       	subi	r20, 0x09	; 9
    361e:	50 40       	sbci	r21, 0x00	; 0
    3620:	c7 01       	movw	r24, r14
    3622:	0e 94 ec 39 	call	0x73d8	; 0x73d8 <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    3626:	8d 2d       	mov	r24, r13
    3628:	8b 50       	subi	r24, 0x0B	; 11
    362a:	03 c0       	rjmp	.+6      	; 0x3632 <chb_read+0xae>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    362c:	80 e0       	ldi	r24, 0x00	; 0
    362e:	01 c0       	rjmp	.+2      	; 0x3632 <chb_read+0xae>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    3630:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
    3632:	df 91       	pop	r29
    3634:	cf 91       	pop	r28
    3636:	1f 91       	pop	r17
    3638:	0f 91       	pop	r16
    363a:	ff 90       	pop	r15
    363c:	ef 90       	pop	r14
    363e:	df 90       	pop	r13
    3640:	08 95       	ret

00003642 <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
    3642:	10 92 29 21 	sts	0x2129, r1
    wr_ptr = 0;
    3646:	10 92 2a 21 	sts	0x212A, r1
    len = 0;
    364a:	10 92 2b 21 	sts	0x212B, r1
}
    364e:	08 95       	ret

00003650 <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
    3650:	20 91 2a 21 	lds	r18, 0x212A
    3654:	30 e0       	ldi	r19, 0x00	; 0
    3656:	f9 01       	movw	r30, r18
    3658:	e4 5d       	subi	r30, 0xD4	; 212
    365a:	fe 4d       	sbci	r31, 0xDE	; 222
    365c:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    365e:	c9 01       	movw	r24, r18
    3660:	01 96       	adiw	r24, 0x01	; 1
    3662:	60 e8       	ldi	r22, 0x80	; 128
    3664:	70 e0       	ldi	r23, 0x00	; 0
    3666:	0e 94 50 39 	call	0x72a0	; 0x72a0 <__divmodhi4>
    366a:	80 93 2a 21 	sts	0x212A, r24
    len++;
    366e:	80 91 2b 21 	lds	r24, 0x212B
    3672:	8f 5f       	subi	r24, 0xFF	; 255
    3674:	80 93 2b 21 	sts	0x212B, r24
}
    3678:	08 95       	ret

0000367a <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
    367a:	20 91 29 21 	lds	r18, 0x2129
    367e:	30 e0       	ldi	r19, 0x00	; 0
    3680:	f9 01       	movw	r30, r18
    3682:	e4 5d       	subi	r30, 0xD4	; 212
    3684:	fe 4d       	sbci	r31, 0xDE	; 222
    3686:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    3688:	2f 5f       	subi	r18, 0xFF	; 255
    368a:	3f 4f       	sbci	r19, 0xFF	; 255
    368c:	c9 01       	movw	r24, r18
    368e:	60 e8       	ldi	r22, 0x80	; 128
    3690:	70 e0       	ldi	r23, 0x00	; 0
    3692:	0e 94 50 39 	call	0x72a0	; 0x72a0 <__divmodhi4>
    3696:	80 93 29 21 	sts	0x2129, r24
    len--;
    369a:	80 91 2b 21 	lds	r24, 0x212B
    369e:	81 50       	subi	r24, 0x01	; 1
    36a0:	80 93 2b 21 	sts	0x212B, r24
    return data;
}
    36a4:	84 2f       	mov	r24, r20
    36a6:	08 95       	ret

000036a8 <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
    36a8:	80 91 2b 21 	lds	r24, 0x212B
    36ac:	08 95       	ret

000036ae <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    36ae:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    36b0:	80 e0       	ldi	r24, 0x00	; 0
    36b2:	90 e0       	ldi	r25, 0x00	; 0
    36b4:	48 e0       	ldi	r20, 0x08	; 8
    36b6:	50 e0       	ldi	r21, 0x00	; 0
    36b8:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <chb_eeprom_read>
}
    36bc:	08 95       	ret

000036be <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    36be:	cf 93       	push	r28
    36c0:	df 93       	push	r29
    36c2:	0f 92       	push	r0
    36c4:	0f 92       	push	r0
    36c6:	cd b7       	in	r28, 0x3d	; 61
    36c8:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    36ca:	89 e0       	ldi	r24, 0x09	; 9
    36cc:	90 e0       	ldi	r25, 0x00	; 0
    36ce:	be 01       	movw	r22, r28
    36d0:	6f 5f       	subi	r22, 0xFF	; 255
    36d2:	7f 4f       	sbci	r23, 0xFF	; 255
    36d4:	42 e0       	ldi	r20, 0x02	; 2
    36d6:	50 e0       	ldi	r21, 0x00	; 0
    36d8:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <chb_eeprom_read>
    return *(U16 *)addr;
}
    36dc:	89 81       	ldd	r24, Y+1	; 0x01
    36de:	9a 81       	ldd	r25, Y+2	; 0x02
    36e0:	0f 90       	pop	r0
    36e2:	0f 90       	pop	r0
    36e4:	df 91       	pop	r29
    36e6:	cf 91       	pop	r28
    36e8:	08 95       	ret

000036ea <RadioCS>:
    CHB_LEAVE_CRIT();
}

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    36ea:	88 23       	and	r24, r24
    36ec:	29 f0       	breq	.+10     	; 0x36f8 <RadioCS+0xe>
    36ee:	80 e1       	ldi	r24, 0x10	; 16
    36f0:	e0 e6       	ldi	r30, 0x60	; 96
    36f2:	f6 e0       	ldi	r31, 0x06	; 6
    36f4:	86 83       	std	Z+6, r24	; 0x06
    36f6:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    36f8:	80 e1       	ldi	r24, 0x10	; 16
    36fa:	e0 e6       	ldi	r30, 0x60	; 96
    36fc:	f6 e0       	ldi	r31, 0x06	; 6
    36fe:	85 83       	std	Z+5, r24	; 0x05
    3700:	08 95       	ret

00003702 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    3702:	df 92       	push	r13
    3704:	ef 92       	push	r14
    3706:	ff 92       	push	r15
    3708:	0f 93       	push	r16
    370a:	1f 93       	push	r17
    370c:	cf 93       	push	r28
    370e:	df 93       	push	r29
    3710:	8c 01       	movw	r16, r24
    3712:	c6 2f       	mov	r28, r22
    3714:	7a 01       	movw	r14, r20
    3716:	d2 2e       	mov	r13, r18
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    3718:	82 2f       	mov	r24, r18
    371a:	90 e0       	ldi	r25, 0x00	; 0
    371c:	86 0f       	add	r24, r22
    371e:	91 1d       	adc	r25, r1
    3720:	80 38       	cpi	r24, 0x80	; 128
    3722:	91 05       	cpc	r25, r1
    3724:	8c f5       	brge	.+98     	; 0x3788 <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    3726:	8f b7       	in	r24, 0x3f	; 63
    3728:	80 93 58 40 	sts	0x4058, r24
    372c:	f8 94       	cli
    RadioCS(TRUE); 
    372e:	81 e0       	ldi	r24, 0x01	; 1
    3730:	0e 94 75 1b 	call	0x36ea	; 0x36ea <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    3734:	80 e6       	ldi	r24, 0x60	; 96
    3736:	0e 94 00 20 	call	0x4000	; 0x4000 <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    373a:	cc 23       	and	r28, r28
    373c:	79 f0       	breq	.+30     	; 0x375c <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    373e:	c8 01       	movw	r24, r16
    3740:	01 96       	adiw	r24, 0x01	; 1
    3742:	c1 50       	subi	r28, 0x01	; 1
    3744:	9c 01       	movw	r18, r24
    3746:	2c 0f       	add	r18, r28
    3748:	31 1d       	adc	r19, r1
    374a:	e9 01       	movw	r28, r18

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    374c:	f8 01       	movw	r30, r16
    374e:	81 91       	ld	r24, Z+
    3750:	8f 01       	movw	r16, r30
    3752:	0e 94 00 20 	call	0x4000	; 0x4000 <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    3756:	0c 17       	cp	r16, r28
    3758:	1d 07       	cpc	r17, r29
    375a:	c1 f7       	brne	.-16     	; 0x374c <chb_frame_write+0x4a>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    375c:	dd 20       	and	r13, r13
    375e:	69 f0       	breq	.+26     	; 0x377a <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    3760:	e7 01       	movw	r28, r14
    3762:	21 96       	adiw	r28, 0x01	; 1
    3764:	da 94       	dec	r13
    3766:	cd 0d       	add	r28, r13
    3768:	d1 1d       	adc	r29, r1

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    376a:	f7 01       	movw	r30, r14
    376c:	81 91       	ld	r24, Z+
    376e:	7f 01       	movw	r14, r30
    3770:	0e 94 00 20 	call	0x4000	; 0x4000 <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    3774:	ec 16       	cp	r14, r28
    3776:	fd 06       	cpc	r15, r29
    3778:	c1 f7       	brne	.-16     	; 0x376a <chb_frame_write+0x68>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    377a:	80 e0       	ldi	r24, 0x00	; 0
    377c:	0e 94 75 1b 	call	0x36ea	; 0x36ea <RadioCS>
    CHB_LEAVE_CRIT();
    3780:	80 91 58 40 	lds	r24, 0x4058
    3784:	8f bf       	out	0x3f, r24	; 63
    3786:	78 94       	sei
}
    3788:	df 91       	pop	r29
    378a:	cf 91       	pop	r28
    378c:	1f 91       	pop	r17
    378e:	0f 91       	pop	r16
    3790:	ff 90       	pop	r15
    3792:	ef 90       	pop	r14
    3794:	df 90       	pop	r13
    3796:	08 95       	ret

00003798 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    3798:	cf 93       	push	r28
    379a:	df 93       	push	r29
    379c:	d8 2f       	mov	r29, r24
    379e:	c6 2f       	mov	r28, r22
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
    37a0:	8f b7       	in	r24, 0x3f	; 63
    37a2:	80 93 58 40 	sts	0x4058, r24
    37a6:	f8 94       	cli
    RadioCS(TRUE);
    37a8:	81 e0       	ldi	r24, 0x01	; 1
    37aa:	0e 94 75 1b 	call	0x36ea	; 0x36ea <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    37ae:	8d 2f       	mov	r24, r29
    37b0:	80 6c       	ori	r24, 0xC0	; 192
    37b2:	0e 94 00 20 	call	0x4000	; 0x4000 <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    37b6:	8c 2f       	mov	r24, r28
    37b8:	0e 94 00 20 	call	0x4000	; 0x4000 <SPID_write>

    RadioCS(FALSE);
    37bc:	80 e0       	ldi	r24, 0x00	; 0
    37be:	0e 94 75 1b 	call	0x36ea	; 0x36ea <RadioCS>
    CHB_LEAVE_CRIT();
    37c2:	80 91 58 40 	lds	r24, 0x4058
    37c6:	8f bf       	out	0x3f, r24	; 63
    37c8:	78 94       	sei
}
    37ca:	df 91       	pop	r29
    37cc:	cf 91       	pop	r28
    37ce:	08 95       	ret

000037d0 <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    37d0:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
    37d2:	85 e0       	ldi	r24, 0x05	; 5
    37d4:	0e 94 cc 1b 	call	0x3798	; 0x3798 <chb_reg_write>
}
    37d8:	08 95       	ret

000037da <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    37da:	0f 93       	push	r16
    37dc:	1f 93       	push	r17
    37de:	cf 93       	push	r28
    37e0:	df 93       	push	r29
    37e2:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
    37e4:	c6 2f       	mov	r28, r22
    37e6:	d7 2f       	mov	r29, r23
    37e8:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
    37ea:	69 91       	ld	r22, Y+
    37ec:	81 2f       	mov	r24, r17
    37ee:	80 0f       	add	r24, r16
    37f0:	0e 94 cc 1b 	call	0x3798	; 0x3798 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    37f4:	1f 5f       	subi	r17, 0xFF	; 255
    37f6:	18 30       	cpi	r17, 0x08	; 8
    37f8:	c1 f7       	brne	.-16     	; 0x37ea <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    37fa:	df 91       	pop	r29
    37fc:	cf 91       	pop	r28
    37fe:	1f 91       	pop	r17
    3800:	0f 91       	pop	r16
    3802:	08 95       	ret

00003804 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    3804:	cf 93       	push	r28
    3806:	df 93       	push	r29
    3808:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    380a:	80 e0       	ldi	r24, 0x00	; 0
    380c:	90 e0       	ldi	r25, 0x00	; 0
    380e:	be 01       	movw	r22, r28
    3810:	48 e0       	ldi	r20, 0x08	; 8
    3812:	50 e0       	ldi	r21, 0x00	; 0
    3814:	0e 94 52 1f 	call	0x3ea4	; 0x3ea4 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    3818:	84 e2       	ldi	r24, 0x24	; 36
    381a:	be 01       	movw	r22, r28
    381c:	0e 94 ed 1b 	call	0x37da	; 0x37da <chb_reg_write64>
}
    3820:	df 91       	pop	r29
    3822:	cf 91       	pop	r28
    3824:	08 95       	ret

00003826 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    3826:	cf 93       	push	r28
    3828:	df 93       	push	r29
    382a:	c8 2f       	mov	r28, r24
    382c:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
    382e:	0e 94 cc 1b 	call	0x3798	; 0x3798 <chb_reg_write>
    3832:	8c 2f       	mov	r24, r28
    3834:	8f 5f       	subi	r24, 0xFF	; 255
    3836:	6d 2f       	mov	r22, r29
    3838:	0e 94 cc 1b 	call	0x3798	; 0x3798 <chb_reg_write>
    }
}
    383c:	df 91       	pop	r29
    383e:	cf 91       	pop	r28
    3840:	08 95       	ret

00003842 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    3842:	0f 93       	push	r16
    3844:	1f 93       	push	r17
    3846:	cf 93       	push	r28
    3848:	df 93       	push	r29
    384a:	0f 92       	push	r0
    384c:	0f 92       	push	r0
    384e:	cd b7       	in	r28, 0x3d	; 61
    3850:	de b7       	in	r29, 0x3e	; 62
    3852:	89 83       	std	Y+1, r24	; 0x01
    3854:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
    3856:	0e 94 1f 1a 	call	0x343e	; 0x343e <chb_get_pcb>
    385a:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    385c:	89 e0       	ldi	r24, 0x09	; 9
    385e:	90 e0       	ldi	r25, 0x00	; 0
    3860:	be 01       	movw	r22, r28
    3862:	6f 5f       	subi	r22, 0xFF	; 255
    3864:	7f 4f       	sbci	r23, 0xFF	; 255
    3866:	42 e0       	ldi	r20, 0x02	; 2
    3868:	50 e0       	ldi	r21, 0x00	; 0
    386a:	0e 94 52 1f 	call	0x3ea4	; 0x3ea4 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    386e:	69 81       	ldd	r22, Y+1	; 0x01
    3870:	7a 81       	ldd	r23, Y+2	; 0x02
    3872:	80 e2       	ldi	r24, 0x20	; 32
    3874:	0e 94 13 1c 	call	0x3826	; 0x3826 <chb_reg_write16>
    pcb->src_addr = addr;
    3878:	89 81       	ldd	r24, Y+1	; 0x01
    387a:	9a 81       	ldd	r25, Y+2	; 0x02
    387c:	f8 01       	movw	r30, r16
    387e:	80 83       	st	Z, r24
    3880:	91 83       	std	Z+1, r25	; 0x01
}
    3882:	0f 90       	pop	r0
    3884:	0f 90       	pop	r0
    3886:	df 91       	pop	r29
    3888:	cf 91       	pop	r28
    388a:	1f 91       	pop	r17
    388c:	0f 91       	pop	r16
    388e:	08 95       	ret

00003890 <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    3890:	cf 93       	push	r28
    3892:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
    3894:	8f b7       	in	r24, 0x3f	; 63
    3896:	80 93 58 40 	sts	0x4058, r24
    389a:	f8 94       	cli
    RadioCS(TRUE);
    389c:	81 e0       	ldi	r24, 0x01	; 1
    389e:	0e 94 75 1b 	call	0x36ea	; 0x36ea <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    38a2:	8c 2f       	mov	r24, r28
    38a4:	80 68       	ori	r24, 0x80	; 128
    38a6:	0e 94 00 20 	call	0x4000	; 0x4000 <SPID_write>
    val = SPID_write(val);
    38aa:	0e 94 00 20 	call	0x4000	; 0x4000 <SPID_write>
    38ae:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    38b0:	80 e0       	ldi	r24, 0x00	; 0
    38b2:	0e 94 75 1b 	call	0x36ea	; 0x36ea <RadioCS>
    CHB_LEAVE_CRIT();
    38b6:	80 91 58 40 	lds	r24, 0x4058
    38ba:	8f bf       	out	0x3f, r24	; 63
    38bc:	78 94       	sei

    return val;
}
    38be:	8c 2f       	mov	r24, r28
    38c0:	cf 91       	pop	r28
    38c2:	08 95       	ret

000038c4 <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
    38c4:	81 e0       	ldi	r24, 0x01	; 1
    38c6:	0e 94 48 1c 	call	0x3890	; 0x3890 <chb_reg_read>
}
    38ca:	8f 71       	andi	r24, 0x1F	; 31
    38cc:	08 95       	ret

000038ce <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    38ce:	1f 93       	push	r17
    38d0:	cf 93       	push	r28
    38d2:	df 93       	push	r29
    38d4:	c8 2f       	mov	r28, r24
    38d6:	16 2f       	mov	r17, r22
    38d8:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
    38da:	0e 94 48 1c 	call	0x3890	; 0x3890 <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
    38de:	6d 2f       	mov	r22, r29
    38e0:	60 95       	com	r22
    38e2:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
    38e4:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
    38e6:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
    38e8:	8c 2f       	mov	r24, r28
    38ea:	0e 94 cc 1b 	call	0x3798	; 0x3798 <chb_reg_write>
}
    38ee:	df 91       	pop	r29
    38f0:	cf 91       	pop	r28
    38f2:	1f 91       	pop	r17
    38f4:	08 95       	ret

000038f6 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    38f6:	cf 93       	push	r28
    38f8:	df 93       	push	r29
    38fa:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    38fc:	80 91 64 06 	lds	r24, 0x0664
    3900:	81 fd       	sbrc	r24, 1
    3902:	53 c0       	rjmp	.+166    	; 0x39aa <chb_set_state+0xb4>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    3904:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <chb_get_state>
    3908:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    390a:	81 51       	subi	r24, 0x11	; 17
    390c:	82 30       	cpi	r24, 0x02	; 2
    390e:	20 f0       	brcs	.+8      	; 0x3918 <chb_set_state+0x22>
    3910:	c1 30       	cpi	r28, 0x01	; 1
    3912:	11 f0       	breq	.+4      	; 0x3918 <chb_set_state+0x22>
    3914:	c2 30       	cpi	r28, 0x02	; 2
    3916:	21 f4       	brne	.+8      	; 0x3920 <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
    3918:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <chb_get_state>
    391c:	8c 17       	cp	r24, r28
    391e:	e1 f3       	breq	.-8      	; 0x3918 <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    3920:	d6 31       	cpi	r29, 0x16	; 22
    3922:	f9 f0       	breq	.+62     	; 0x3962 <chb_set_state+0x6c>
    3924:	d9 31       	cpi	r29, 0x19	; 25
    3926:	89 f0       	breq	.+34     	; 0x394a <chb_set_state+0x54>
    3928:	d8 30       	cpi	r29, 0x08	; 8
    392a:	39 f5       	brne	.+78     	; 0x397a <chb_set_state+0x84>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    392c:	e4 e6       	ldi	r30, 0x64	; 100
    392e:	f6 e0       	ldi	r31, 0x06	; 6
    3930:	80 81       	ld	r24, Z
    3932:	8d 7f       	andi	r24, 0xFD	; 253
    3934:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    3936:	82 e0       	ldi	r24, 0x02	; 2
    3938:	63 e0       	ldi	r22, 0x03	; 3
    393a:	4f e1       	ldi	r20, 0x1F	; 31
    393c:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>
    3940:	8a e0       	ldi	r24, 0x0A	; 10
    3942:	8a 95       	dec	r24
    3944:	f1 f7       	brne	.-4      	; 0x3942 <chb_set_state+0x4c>
    3946:	00 c0       	rjmp	.+0      	; 0x3948 <chb_set_state+0x52>
    3948:	18 c0       	rjmp	.+48     	; 0x397a <chb_set_state+0x84>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    394a:	c6 31       	cpi	r28, 0x16	; 22
    394c:	b1 f4       	brne	.+44     	; 0x397a <chb_set_state+0x84>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    394e:	82 e0       	ldi	r24, 0x02	; 2
    3950:	69 e0       	ldi	r22, 0x09	; 9
    3952:	4f e1       	ldi	r20, 0x1F	; 31
    3954:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>
    3958:	9a e0       	ldi	r25, 0x0A	; 10
    395a:	9a 95       	dec	r25
    395c:	f1 f7       	brne	.-4      	; 0x395a <chb_set_state+0x64>
    395e:	00 c0       	rjmp	.+0      	; 0x3960 <chb_set_state+0x6a>
    3960:	2a c0       	rjmp	.+84     	; 0x39b6 <chb_set_state+0xc0>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    3962:	c9 31       	cpi	r28, 0x19	; 25
    3964:	51 f4       	brne	.+20     	; 0x397a <chb_set_state+0x84>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    3966:	82 e0       	ldi	r24, 0x02	; 2
    3968:	69 e0       	ldi	r22, 0x09	; 9
    396a:	4f e1       	ldi	r20, 0x1F	; 31
    396c:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>
    3970:	8a e0       	ldi	r24, 0x0A	; 10
    3972:	8a 95       	dec	r24
    3974:	f1 f7       	brne	.-4      	; 0x3972 <chb_set_state+0x7c>
    3976:	00 c0       	rjmp	.+0      	; 0x3978 <chb_set_state+0x82>
    3978:	1e c0       	rjmp	.+60     	; 0x39b6 <chb_set_state+0xc0>
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    397a:	82 e0       	ldi	r24, 0x02	; 2
    397c:	6d 2f       	mov	r22, r29
    397e:	4f e1       	ldi	r20, 0x1F	; 31
    3980:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
	if(curr_state == CHB_TRX_OFF){
    3984:	c8 30       	cpi	r28, 0x08	; 8
    3986:	39 f4       	brne	.+14     	; 0x3996 <chb_set_state+0xa0>
    3988:	8f e6       	ldi	r24, 0x6F	; 111
    398a:	93 e0       	ldi	r25, 0x03	; 3
    398c:	01 97       	sbiw	r24, 0x01	; 1
    398e:	f1 f7       	brne	.-4      	; 0x398c <chb_set_state+0x96>
    3990:	00 c0       	rjmp	.+0      	; 0x3992 <chb_set_state+0x9c>
    3992:	00 00       	nop
    3994:	04 c0       	rjmp	.+8      	; 0x399e <chb_set_state+0xa8>
    3996:	9a e0       	ldi	r25, 0x0A	; 10
    3998:	9a 95       	dec	r25
    399a:	f1 f7       	brne	.-4      	; 0x3998 <chb_set_state+0xa2>
    399c:	00 c0       	rjmp	.+0      	; 0x399e <chb_set_state+0xa8>
	}
	else{
		_delay_us(TIME_RX_ON_PLL_ON);
	}				

    if (chb_get_state() == state)
    399e:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <chb_get_state>
    39a2:	8d 17       	cp	r24, r29
    39a4:	21 f4       	brne	.+8      	; 0x39ae <chb_set_state+0xb8>
    {
        return RADIO_SUCCESS;
    39a6:	80 e4       	ldi	r24, 0x40	; 64
    39a8:	03 c0       	rjmp	.+6      	; 0x39b0 <chb_set_state+0xba>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
    39aa:	84 e4       	ldi	r24, 0x44	; 68
    39ac:	01 c0       	rjmp	.+2      	; 0x39b0 <chb_set_state+0xba>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
    39ae:	83 e4       	ldi	r24, 0x43	; 67
}
    39b0:	df 91       	pop	r29
    39b2:	cf 91       	pop	r28
    39b4:	08 95       	ret
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    39b6:	82 e0       	ldi	r24, 0x02	; 2
    39b8:	6d 2f       	mov	r22, r29
    39ba:	4f e1       	ldi	r20, 0x1F	; 31
    39bc:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>
    39c0:	ea cf       	rjmp	.-44     	; 0x3996 <chb_set_state+0xa0>

000039c2 <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
    39c2:	88 23       	and	r24, r24
    39c4:	49 f0       	breq	.+18     	; 0x39d8 <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    39c6:	88 e0       	ldi	r24, 0x08	; 8
    39c8:	0e 94 7b 1c 	call	0x38f6	; 0x38f6 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    39cc:	e4 e6       	ldi	r30, 0x64	; 100
    39ce:	f6 e0       	ldi	r31, 0x06	; 6
    39d0:	80 81       	ld	r24, Z
    39d2:	82 60       	ori	r24, 0x02	; 2
    39d4:	80 83       	st	Z, r24
    39d6:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    39d8:	e4 e6       	ldi	r30, 0x64	; 100
    39da:	f6 e0       	ldi	r31, 0x06	; 6
    39dc:	80 81       	ld	r24, Z
    39de:	8d 7f       	andi	r24, 0xFD	; 253
    39e0:	80 83       	st	Z, r24
    39e2:	8f e7       	ldi	r24, 0x7F	; 127
    39e4:	97 e0       	ldi	r25, 0x07	; 7
    39e6:	01 97       	sbiw	r24, 0x01	; 1
    39e8:	f1 f7       	brne	.-4      	; 0x39e6 <chb_sleep+0x24>
    39ea:	00 c0       	rjmp	.+0      	; 0x39ec <chb_sleep+0x2a>
    39ec:	00 00       	nop

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    39ee:	86 e1       	ldi	r24, 0x16	; 22
    39f0:	0e 94 7b 1c 	call	0x38f6	; 0x38f6 <chb_set_state>
    39f4:	08 95       	ret

000039f6 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    39f6:	cf 92       	push	r12
    39f8:	df 92       	push	r13
    39fa:	ef 92       	push	r14
    39fc:	ff 92       	push	r15
    39fe:	0f 93       	push	r16
    3a00:	1f 93       	push	r17
    3a02:	cf 93       	push	r28
    3a04:	df 93       	push	r29
    3a06:	7c 01       	movw	r14, r24
    3a08:	6b 01       	movw	r12, r22
    3a0a:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
    3a0c:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <chb_get_state>
    3a10:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
    3a12:	0e 94 1f 1a 	call	0x343e	; 0x343e <chb_get_pcb>
    3a16:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    3a18:	12 30       	cpi	r17, 0x02	; 2
    3a1a:	f1 f0       	breq	.+60     	; 0x3a58 <chb_tx+0x62>
    3a1c:	12 31       	cpi	r17, 0x12	; 18
    3a1e:	f1 f0       	breq	.+60     	; 0x3a5c <chb_tx+0x66>
    {
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    3a20:	88 e0       	ldi	r24, 0x08	; 8
    3a22:	0e 94 7b 1c 	call	0x38f6	; 0x38f6 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    3a26:	89 e1       	ldi	r24, 0x19	; 25
    3a28:	0e 94 7b 1c 	call	0x38f6	; 0x38f6 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    3a2c:	c7 01       	movw	r24, r14
    3a2e:	6a e0       	ldi	r22, 0x0A	; 10
    3a30:	a6 01       	movw	r20, r12
    3a32:	20 2f       	mov	r18, r16
    3a34:	0e 94 81 1b 	call	0x3702	; 0x3702 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    3a38:	82 e0       	ldi	r24, 0x02	; 2
    3a3a:	62 e0       	ldi	r22, 0x02	; 2
    3a3c:	4f e1       	ldi	r20, 0x1F	; 31
    3a3e:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    3a42:	8c 81       	ldd	r24, Y+4	; 0x04
    3a44:	88 23       	and	r24, r24
    3a46:	e9 f3       	breq	.-6      	; 0x3a42 <chb_tx+0x4c>
    pcb->tx_end = false;
    3a48:	1c 82       	std	Y+4, r1	; 0x04

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    3a4a:	82 e0       	ldi	r24, 0x02	; 2
    3a4c:	0e 94 48 1c 	call	0x3890	; 0x3890 <chb_reg_read>
    3a50:	82 95       	swap	r24
    3a52:	86 95       	lsr	r24
    3a54:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
    3a56:	03 c0       	rjmp	.+6      	; 0x3a5e <chb_tx+0x68>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
    3a58:	84 e4       	ldi	r24, 0x44	; 68
    3a5a:	01 c0       	rjmp	.+2      	; 0x3a5e <chb_tx+0x68>
    3a5c:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
    3a5e:	df 91       	pop	r29
    3a60:	cf 91       	pop	r28
    3a62:	1f 91       	pop	r17
    3a64:	0f 91       	pop	r16
    3a66:	ff 90       	pop	r15
    3a68:	ef 90       	pop	r14
    3a6a:	df 90       	pop	r13
    3a6c:	cf 90       	pop	r12
    3a6e:	08 95       	ret

00003a70 <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
    3a70:	81 30       	cpi	r24, 0x01	; 1
    3a72:	91 f0       	breq	.+36     	; 0x3a98 <chb_set_mode+0x28>
    3a74:	81 30       	cpi	r24, 0x01	; 1
    3a76:	28 f0       	brcs	.+10     	; 0x3a82 <chb_set_mode+0x12>
    3a78:	82 30       	cpi	r24, 0x02	; 2
    3a7a:	c9 f0       	breq	.+50     	; 0x3aae <chb_set_mode+0x3e>
    3a7c:	83 30       	cpi	r24, 0x03	; 3
    3a7e:	61 f5       	brne	.+88     	; 0x3ad8 <chb_set_mode+0x68>
    3a80:	21 c0       	rjmp	.+66     	; 0x3ac4 <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    3a82:	8c e0       	ldi	r24, 0x0C	; 12
    3a84:	68 e0       	ldi	r22, 0x08	; 8
    3a86:	4f e3       	ldi	r20, 0x3F	; 63
    3a88:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    3a8c:	86 e1       	ldi	r24, 0x16	; 22
    3a8e:	62 e0       	ldi	r22, 0x02	; 2
    3a90:	43 e0       	ldi	r20, 0x03	; 3
    3a92:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>
        break;
    3a96:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    3a98:	8c e0       	ldi	r24, 0x0C	; 12
    3a9a:	6c e0       	ldi	r22, 0x0C	; 12
    3a9c:	4f e3       	ldi	r20, 0x3F	; 63
    3a9e:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    3aa2:	86 e1       	ldi	r24, 0x16	; 22
    3aa4:	62 e0       	ldi	r22, 0x02	; 2
    3aa6:	43 e0       	ldi	r20, 0x03	; 3
    3aa8:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>
        break;
    3aac:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    3aae:	8c e0       	ldi	r24, 0x0C	; 12
    3ab0:	6c e1       	ldi	r22, 0x1C	; 28
    3ab2:	4f e3       	ldi	r20, 0x3F	; 63
    3ab4:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    3ab8:	86 e1       	ldi	r24, 0x16	; 22
    3aba:	62 e0       	ldi	r22, 0x02	; 2
    3abc:	43 e0       	ldi	r20, 0x03	; 3
    3abe:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>
        break;
    3ac2:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    3ac4:	8c e0       	ldi	r24, 0x0C	; 12
    3ac6:	60 e0       	ldi	r22, 0x00	; 0
    3ac8:	4f e3       	ldi	r20, 0x3F	; 63
    3aca:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    3ace:	86 e1       	ldi	r24, 0x16	; 22
    3ad0:	63 e0       	ldi	r22, 0x03	; 3
    3ad2:	43 e0       	ldi	r20, 0x03	; 3
    3ad4:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>
    3ad8:	08 95       	ret

00003ada <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    3ada:	cf 93       	push	r28
    3adc:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    3ade:	88 e0       	ldi	r24, 0x08	; 8
    3ae0:	6c 2f       	mov	r22, r28
    3ae2:	4f e1       	ldi	r20, 0x1F	; 31
    3ae4:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    3ae8:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    3aec:	86 30       	cpi	r24, 0x06	; 6
    3aee:	11 f0       	breq	.+4      	; 0x3af4 <chb_set_channel+0x1a>
    3af0:	89 30       	cpi	r24, 0x09	; 9
    3af2:	31 f4       	brne	.+12     	; 0x3b00 <chb_set_channel+0x26>
    3af4:	8f e6       	ldi	r24, 0x6F	; 111
    3af6:	93 e0       	ldi	r25, 0x03	; 3
    3af8:	01 97       	sbiw	r24, 0x01	; 1
    3afa:	f1 f7       	brne	.-4      	; 0x3af8 <chb_set_channel+0x1e>
    3afc:	00 c0       	rjmp	.+0      	; 0x3afe <chb_set_channel+0x24>
    3afe:	00 00       	nop
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    3b00:	88 e0       	ldi	r24, 0x08	; 8
    3b02:	0e 94 48 1c 	call	0x3890	; 0x3890 <chb_reg_read>
    3b06:	90 e0       	ldi	r25, 0x00	; 0
    3b08:	8f 71       	andi	r24, 0x1F	; 31
    3b0a:	90 70       	andi	r25, 0x00	; 0
    3b0c:	6c 2f       	mov	r22, r28
    3b0e:	70 e0       	ldi	r23, 0x00	; 0
    3b10:	86 17       	cp	r24, r22
    3b12:	97 07       	cpc	r25, r23
    3b14:	11 f4       	brne	.+4      	; 0x3b1a <chb_set_channel+0x40>
    3b16:	80 e4       	ldi	r24, 0x40	; 64
    3b18:	01 c0       	rjmp	.+2      	; 0x3b1c <chb_set_channel+0x42>
    3b1a:	83 e4       	ldi	r24, 0x43	; 67
}
    3b1c:	cf 91       	pop	r28
    3b1e:	08 95       	ret

00003b20 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    3b20:	cf 93       	push	r28
    3b22:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    3b24:	0e 94 48 1c 	call	0x3890	; 0x3890 <chb_reg_read>
    3b28:	8c 2b       	or	r24, r28
    3b2a:	8f 5f       	subi	r24, 0xFF	; 255
    3b2c:	0e 94 48 1c 	call	0x3890	; 0x3890 <chb_reg_read>
    }
    return val;
}
    3b30:	80 e0       	ldi	r24, 0x00	; 0
    3b32:	90 e0       	ldi	r25, 0x00	; 0
    3b34:	cf 91       	pop	r28
    3b36:	08 95       	ret

00003b38 <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
    3b38:	e4 e6       	ldi	r30, 0x64	; 100
    3b3a:	f6 e0       	ldi	r31, 0x06	; 6
    3b3c:	80 81       	ld	r24, Z
    3b3e:	81 60       	ori	r24, 0x01	; 1
    3b40:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
    3b42:	80 81       	ld	r24, Z
    3b44:	8d 7f       	andi	r24, 0xFD	; 253
    3b46:	80 83       	st	Z, r24
    3b48:	8f ed       	ldi	r24, 0xDF	; 223
    3b4a:	9b e0       	ldi	r25, 0x0B	; 11
    3b4c:	01 97       	sbiw	r24, 0x01	; 1
    3b4e:	f1 f7       	brne	.-4      	; 0x3b4c <chb_reset+0x14>
    3b50:	00 c0       	rjmp	.+0      	; 0x3b52 <chb_reset+0x1a>
    3b52:	00 00       	nop

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    3b54:	80 81       	ld	r24, Z
    3b56:	8e 7f       	andi	r24, 0xFE	; 254
    3b58:	80 83       	st	Z, r24
    3b5a:	9a e0       	ldi	r25, 0x0A	; 10
    3b5c:	9a 95       	dec	r25
    3b5e:	f1 f7       	brne	.-4      	; 0x3b5c <chb_reset+0x24>
    3b60:	00 c0       	rjmp	.+0      	; 0x3b62 <chb_reset+0x2a>
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    3b62:	80 81       	ld	r24, Z
    3b64:	81 60       	ori	r24, 0x01	; 1
    3b66:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    3b68:	8d e1       	ldi	r24, 0x1D	; 29
    3b6a:	0e 94 48 1c 	call	0x3890	; 0x3890 <chb_reg_read>
    3b6e:	81 30       	cpi	r24, 0x01	; 1
    3b70:	d9 f7       	brne	.-10     	; 0x3b68 <chb_reset+0x30>
    3b72:	8c e1       	ldi	r24, 0x1C	; 28
    3b74:	0e 94 48 1c 	call	0x3890	; 0x3890 <chb_reg_read>
    3b78:	87 30       	cpi	r24, 0x07	; 7
    3b7a:	b1 f7       	brne	.-20     	; 0x3b68 <chb_reset+0x30>
            break;
        }
    }
	

}
    3b7c:	08 95       	ret

00003b7e <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    3b7e:	0f 93       	push	r16
    3b80:	1f 93       	push	r17
    3b82:	cf 93       	push	r28
    3b84:	df 93       	push	r29
    3b86:	cd b7       	in	r28, 0x3d	; 61
    3b88:	de b7       	in	r29, 0x3e	; 62
    3b8a:	ea 97       	sbiw	r28, 0x3a	; 58
    3b8c:	cd bf       	out	0x3d, r28	; 61
    3b8e:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    3b90:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    3b94:	e0 e6       	ldi	r30, 0x60	; 96
    3b96:	f6 e0       	ldi	r31, 0x06	; 6
    3b98:	80 81       	ld	r24, Z
    3b9a:	82 60       	ori	r24, 0x02	; 2
    3b9c:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    3b9e:	80 81       	ld	r24, Z
    3ba0:	81 60       	ori	r24, 0x01	; 1
    3ba2:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    3ba4:	0e 94 9c 1d 	call	0x3b38	; 0x3b38 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    3ba8:	8e e0       	ldi	r24, 0x0E	; 14
    3baa:	60 e0       	ldi	r22, 0x00	; 0
    3bac:	0e 94 cc 1b 	call	0x3798	; 0x3798 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    3bb0:	82 e0       	ldi	r24, 0x02	; 2
    3bb2:	63 e0       	ldi	r22, 0x03	; 3
    3bb4:	4f e1       	ldi	r20, 0x1F	; 31
    3bb6:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    3bba:	81 e0       	ldi	r24, 0x01	; 1
    3bbc:	0e 94 48 1c 	call	0x3890	; 0x3890 <chb_reg_read>
    3bc0:	8f 71       	andi	r24, 0x1F	; 31
    3bc2:	88 30       	cpi	r24, 0x08	; 8
    3bc4:	d1 f7       	brne	.-12     	; 0x3bba <chb_drvr_init+0x3c>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    3bc6:	8e e2       	ldi	r24, 0x2E	; 46
    3bc8:	60 e4       	ldi	r22, 0x40	; 64
    3bca:	40 ec       	ldi	r20, 0xC0	; 192
    3bcc:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    3bd0:	8e e0       	ldi	r24, 0x0E	; 14
    3bd2:	6c e0       	ldi	r22, 0x0C	; 12
    3bd4:	0e 94 cc 1b 	call	0x3798	; 0x3798 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    3bd8:	84 e0       	ldi	r24, 0x04	; 4
    3bda:	60 e2       	ldi	r22, 0x20	; 32
    3bdc:	40 e2       	ldi	r20, 0x20	; 32
    3bde:	0e 94 67 1c 	call	0x38ce	; 0x38ce <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    3be2:	81 e0       	ldi	r24, 0x01	; 1
    3be4:	0e 94 38 1d 	call	0x3a70	; 0x3a70 <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    3be8:	81 e0       	ldi	r24, 0x01	; 1
    3bea:	0e 94 6d 1d 	call	0x3ada	; 0x3ada <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    3bee:	86 e1       	ldi	r24, 0x16	; 22
    3bf0:	0e 94 7b 1c 	call	0x38f6	; 0x38f6 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    3bf4:	82 e2       	ldi	r24, 0x22	; 34
    3bf6:	64 e3       	ldi	r22, 0x34	; 52
    3bf8:	72 e1       	ldi	r23, 0x12	; 18
    3bfa:	0e 94 13 1c 	call	0x3826	; 0x3826 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    3bfe:	0e 94 5f 1b 	call	0x36be	; 0x36be <chb_get_short_addr>
    3c02:	bc 01       	movw	r22, r24
    3c04:	80 e2       	ldi	r24, 0x20	; 32
    3c06:	0e 94 13 1c 	call	0x3826	; 0x3826 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    3c0a:	ce 01       	movw	r24, r28
    3c0c:	01 96       	adiw	r24, 0x01	; 1
    3c0e:	0e 94 57 1b 	call	0x36ae	; 0x36ae <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    3c12:	84 e2       	ldi	r24, 0x24	; 36
    3c14:	be 01       	movw	r22, r28
    3c16:	6f 5f       	subi	r22, 0xFF	; 255
    3c18:	7f 4f       	sbci	r23, 0xFF	; 255
    3c1a:	0e 94 ed 1b 	call	0x37da	; 0x37da <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    3c1e:	e2 e7       	ldi	r30, 0x72	; 114
    3c20:	f6 e0       	ldi	r31, 0x06	; 6
    3c22:	80 81       	ld	r24, Z
    3c24:	81 60       	ori	r24, 0x01	; 1
    3c26:	80 83       	st	Z, r24
    3c28:	e9 e6       	ldi	r30, 0x69	; 105
    3c2a:	f6 e0       	ldi	r31, 0x06	; 6
    3c2c:	80 81       	ld	r24, Z
    3c2e:	83 60       	ori	r24, 0x03	; 3
    3c30:	80 83       	st	Z, r24
    3c32:	ea e6       	ldi	r30, 0x6A	; 106
    3c34:	f6 e0       	ldi	r31, 0x06	; 6
    3c36:	80 81       	ld	r24, Z
    3c38:	84 60       	ori	r24, 0x04	; 4
    3c3a:	80 83       	st	Z, r24
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    3c3c:	e0 ea       	ldi	r30, 0xA0	; 160
    3c3e:	f0 e0       	ldi	r31, 0x00	; 0
    3c40:	82 81       	ldd	r24, Z+2	; 0x02
    3c42:	87 60       	ori	r24, 0x07	; 7
    3c44:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
    3c46:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <chb_get_state>
    3c4a:	86 31       	cpi	r24, 0x16	; 22
    3c4c:	91 f0       	breq	.+36     	; 0x3c72 <chb_drvr_init+0xf4>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    3c4e:	8e 01       	movw	r16, r28
    3c50:	07 5f       	subi	r16, 0xF7	; 247
    3c52:	1f 4f       	sbci	r17, 0xFF	; 255
    3c54:	c8 01       	movw	r24, r16
    3c56:	68 ee       	ldi	r22, 0xE8	; 232
    3c58:	71 e0       	ldi	r23, 0x01	; 1
    3c5a:	0e 94 e5 39 	call	0x73ca	; 0x73ca <strcpy_P>
        printf(buf);
    3c5e:	0f 92       	push	r0
    3c60:	0f 92       	push	r0
    3c62:	ed b7       	in	r30, 0x3d	; 61
    3c64:	fe b7       	in	r31, 0x3e	; 62
    3c66:	01 83       	std	Z+1, r16	; 0x01
    3c68:	12 83       	std	Z+2, r17	; 0x02
    3c6a:	0e 94 2a 3a 	call	0x7454	; 0x7454 <printf>
    3c6e:	0f 90       	pop	r0
    3c70:	0f 90       	pop	r0
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
    3c72:	ea 96       	adiw	r28, 0x3a	; 58
    3c74:	cd bf       	out	0x3d, r28	; 61
    3c76:	de bf       	out	0x3e, r29	; 62
    3c78:	df 91       	pop	r29
    3c7a:	cf 91       	pop	r28
    3c7c:	1f 91       	pop	r17
    3c7e:	0f 91       	pop	r16
    3c80:	08 95       	ret

00003c82 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    3c82:	1f 92       	push	r1
    3c84:	0f 92       	push	r0
    3c86:	0f b6       	in	r0, 0x3f	; 63
    3c88:	0f 92       	push	r0
    3c8a:	0b b6       	in	r0, 0x3b	; 59
    3c8c:	0f 92       	push	r0
    3c8e:	11 24       	eor	r1, r1
    3c90:	6f 92       	push	r6
    3c92:	7f 92       	push	r7
    3c94:	8f 92       	push	r8
    3c96:	9f 92       	push	r9
    3c98:	af 92       	push	r10
    3c9a:	bf 92       	push	r11
    3c9c:	df 92       	push	r13
    3c9e:	ef 92       	push	r14
    3ca0:	ff 92       	push	r15
    3ca2:	0f 93       	push	r16
    3ca4:	1f 93       	push	r17
    3ca6:	2f 93       	push	r18
    3ca8:	3f 93       	push	r19
    3caa:	4f 93       	push	r20
    3cac:	5f 93       	push	r21
    3cae:	6f 93       	push	r22
    3cb0:	7f 93       	push	r23
    3cb2:	8f 93       	push	r24
    3cb4:	9f 93       	push	r25
    3cb6:	af 93       	push	r26
    3cb8:	bf 93       	push	r27
    3cba:	ef 93       	push	r30
    3cbc:	ff 93       	push	r31
    3cbe:	cf 93       	push	r28
    3cc0:	df 93       	push	r29
    3cc2:	cd b7       	in	r28, 0x3d	; 61
    3cc4:	de b7       	in	r29, 0x3e	; 62
    3cc6:	e2 97       	sbiw	r28, 0x32	; 50
    3cc8:	cd bf       	out	0x3d, r28	; 61
    3cca:	de bf       	out	0x3e, r29	; 62
    U8 state, intp_src = 0;
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    3ccc:	0e 94 1f 1a 	call	0x343e	; 0x343e <chb_get_pcb>
    3cd0:	7c 01       	movw	r14, r24

    CHB_ENTER_CRIT();
    3cd2:	8f b7       	in	r24, 0x3f	; 63
    3cd4:	80 93 58 40 	sts	0x4058, r24
    3cd8:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    3cda:	81 e0       	ldi	r24, 0x01	; 1
    3cdc:	0e 94 75 1b 	call	0x36ea	; 0x36ea <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    3ce0:	8f e8       	ldi	r24, 0x8F	; 143
    3ce2:	0e 94 00 20 	call	0x4000	; 0x4000 <SPID_write>
    intp_src = SPID_write(0);
    3ce6:	80 e0       	ldi	r24, 0x00	; 0
    3ce8:	0e 94 00 20 	call	0x4000	; 0x4000 <SPID_write>
    3cec:	18 2f       	mov	r17, r24

    RadioCS(FALSE);
    3cee:	80 e0       	ldi	r24, 0x00	; 0
    3cf0:	0e 94 75 1b 	call	0x36ea	; 0x36ea <RadioCS>

    while (intp_src)
    3cf4:	11 23       	and	r17, r17
    3cf6:	09 f4       	brne	.+2      	; 0x3cfa <__vector_64+0x78>
    3cf8:	ae c0       	rjmp	.+348    	; 0x3e56 <__vector_64+0x1d4>

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3cfa:	aa 24       	eor	r10, r10
    3cfc:	bb 24       	eor	r11, r11
    3cfe:	68 94       	set
    3d00:	a7 f8       	bld	r10, 7

            // Increment the overflow stat
            pcb->overflow++;

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    3d02:	0f 2e       	mov	r0, r31
    3d04:	f8 e0       	ldi	r31, 0x08	; 8
    3d06:	8f 2e       	mov	r8, r31
    3d08:	f2 e0       	ldi	r31, 0x02	; 2
    3d0a:	9f 2e       	mov	r9, r31
    3d0c:	f0 2d       	mov	r31, r0
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    3d0e:	12 ff       	sbrs	r17, 2
    3d10:	02 c0       	rjmp	.+4      	; 0x3d16 <__vector_64+0x94>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    3d12:	1b 7f       	andi	r17, 0xFB	; 251
    3d14:	9d c0       	rjmp	.+314    	; 0x3e50 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    3d16:	13 ff       	sbrs	r17, 3
    3d18:	82 c0       	rjmp	.+260    	; 0x3e1e <__vector_64+0x19c>
        {
            state = chb_get_state();
    3d1a:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK))
    3d1e:	86 30       	cpi	r24, 0x06	; 6
    3d20:	29 f0       	breq	.+10     	; 0x3d2c <__vector_64+0xaa>
    3d22:	86 31       	cpi	r24, 0x16	; 22
    3d24:	19 f0       	breq	.+6      	; 0x3d2c <__vector_64+0xaa>
    3d26:	81 31       	cpi	r24, 0x11	; 17
    3d28:	09 f0       	breq	.+2      	; 0x3d2c <__vector_64+0xaa>
    3d2a:	6f c0       	rjmp	.+222    	; 0x3e0a <__vector_64+0x188>
            {
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    3d2c:	87 e0       	ldi	r24, 0x07	; 7
    3d2e:	0e 94 48 1c 	call	0x3890	; 0x3890 <chb_reg_read>
    3d32:	f7 01       	movw	r30, r14
    3d34:	82 8b       	std	Z+18, r24	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    3d36:	86 e0       	ldi	r24, 0x06	; 6
    3d38:	0e 94 48 1c 	call	0x3890	; 0x3890 <chb_reg_read>
    3d3c:	88 1f       	adc	r24, r24
    3d3e:	88 27       	eor	r24, r24
    3d40:	88 1f       	adc	r24, r24
    3d42:	f7 01       	movw	r30, r14
    3d44:	83 8b       	std	Z+19, r24	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    3d46:	88 23       	and	r24, r24
    3d48:	09 f4       	brne	.+2      	; 0x3d4c <__vector_64+0xca>
    3d4a:	62 c0       	rjmp	.+196    	; 0x3e10 <__vector_64+0x18e>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
    3d4c:	8f b7       	in	r24, 0x3f	; 63
    3d4e:	80 93 58 40 	sts	0x4058, r24
    3d52:	f8 94       	cli
    RadioCS(TRUE);
    3d54:	81 e0       	ldi	r24, 0x01	; 1
    3d56:	0e 94 75 1b 	call	0x36ea	; 0x36ea <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    3d5a:	80 e2       	ldi	r24, 0x20	; 32
    3d5c:	0e 94 00 20 	call	0x4000	; 0x4000 <SPID_write>
    len = SPID_write(0);
    3d60:	80 e0       	ldi	r24, 0x00	; 0
    3d62:	0e 94 00 20 	call	0x4000	; 0x4000 <SPID_write>
    3d66:	d8 2e       	mov	r13, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    3d68:	83 50       	subi	r24, 0x03	; 3
    3d6a:	8d 37       	cpi	r24, 0x7D	; 125
    3d6c:	f0 f5       	brcc	.+124    	; 0x3dea <__vector_64+0x168>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3d6e:	0e 94 54 1b 	call	0x36a8	; 0x36a8 <chb_buf_get_len>
    3d72:	2d 2d       	mov	r18, r13
    3d74:	30 e0       	ldi	r19, 0x00	; 0
    3d76:	a5 01       	movw	r20, r10
    3d78:	48 1b       	sub	r20, r24
    3d7a:	51 09       	sbc	r21, r1
    3d7c:	24 17       	cp	r18, r20
    3d7e:	35 07       	cpc	r19, r21
    3d80:	7c f4       	brge	.+30     	; 0x3da0 <__vector_64+0x11e>
        {
            chb_buf_write(len);
    3d82:	8d 2d       	mov	r24, r13
    3d84:	0e 94 28 1b 	call	0x3650	; 0x3650 <chb_buf_write>
            
            for (i=0; i<len; i++)
    3d88:	dd 20       	and	r13, r13
    3d8a:	79 f1       	breq	.+94     	; 0x3dea <__vector_64+0x168>
    3d8c:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    3d8e:	80 e0       	ldi	r24, 0x00	; 0
    3d90:	0e 94 00 20 	call	0x4000	; 0x4000 <SPID_write>
                chb_buf_write(data);
    3d94:	0e 94 28 1b 	call	0x3650	; 0x3650 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    3d98:	0f 5f       	subi	r16, 0xFF	; 255
    3d9a:	0d 15       	cp	r16, r13
    3d9c:	c1 f7       	brne	.-16     	; 0x3d8e <__vector_64+0x10c>
    3d9e:	25 c0       	rjmp	.+74     	; 0x3dea <__vector_64+0x168>
			//PORTE.OUTCLR = PIN2_bm;
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    3da0:	0e 94 1f 1a 	call	0x343e	; 0x343e <chb_get_pcb>
    3da4:	3c 01       	movw	r6, r24
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3da6:	dd 20       	and	r13, r13
    3da8:	39 f0       	breq	.+14     	; 0x3db8 <__vector_64+0x136>
    3daa:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    3dac:	80 e0       	ldi	r24, 0x00	; 0
    3dae:	0e 94 00 20 	call	0x4000	; 0x4000 <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3db2:	0f 5f       	subi	r16, 0xFF	; 255
    3db4:	0d 15       	cp	r16, r13
    3db6:	d1 f7       	brne	.-12     	; 0x3dac <__vector_64+0x12a>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    3db8:	f3 01       	movw	r30, r6
    3dba:	85 85       	ldd	r24, Z+13	; 0x0d
    3dbc:	96 85       	ldd	r25, Z+14	; 0x0e
    3dbe:	01 96       	adiw	r24, 0x01	; 1
    3dc0:	85 87       	std	Z+13, r24	; 0x0d
    3dc2:	96 87       	std	Z+14, r25	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    3dc4:	ce 01       	movw	r24, r28
    3dc6:	01 96       	adiw	r24, 0x01	; 1
    3dc8:	b4 01       	movw	r22, r8
    3dca:	0e 94 e5 39 	call	0x73ca	; 0x73ca <strcpy_P>
            printf(buf);
    3dce:	0f 92       	push	r0
    3dd0:	0f 92       	push	r0
    3dd2:	41 e0       	ldi	r20, 0x01	; 1
    3dd4:	50 e0       	ldi	r21, 0x00	; 0
    3dd6:	4c 0f       	add	r20, r28
    3dd8:	5d 1f       	adc	r21, r29
    3dda:	ed b7       	in	r30, 0x3d	; 61
    3ddc:	fe b7       	in	r31, 0x3e	; 62
    3dde:	41 83       	std	Z+1, r20	; 0x01
    3de0:	52 83       	std	Z+2, r21	; 0x02
    3de2:	0e 94 2a 3a 	call	0x7454	; 0x7454 <printf>
    3de6:	0f 90       	pop	r0
    3de8:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    3dea:	80 e0       	ldi	r24, 0x00	; 0
    3dec:	0e 94 75 1b 	call	0x36ea	; 0x36ea <RadioCS>
    CHB_LEAVE_CRIT();
    3df0:	80 91 58 40 	lds	r24, 0x4058
    3df4:	8f bf       	out	0x3f, r24	; 63
    3df6:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
    3df8:	f7 01       	movw	r30, r14
    3dfa:	85 81       	ldd	r24, Z+5	; 0x05
    3dfc:	96 81       	ldd	r25, Z+6	; 0x06
    3dfe:	01 96       	adiw	r24, 0x01	; 1
    3e00:	85 83       	std	Z+5, r24	; 0x05
    3e02:	96 83       	std	Z+6, r25	; 0x06
                    pcb->data_rcv = true;
    3e04:	81 e0       	ldi	r24, 0x01	; 1
    3e06:	83 83       	std	Z+3, r24	; 0x03
    3e08:	03 c0       	rjmp	.+6      	; 0x3e10 <__vector_64+0x18e>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    3e0a:	81 e0       	ldi	r24, 0x01	; 1
    3e0c:	f7 01       	movw	r30, r14
    3e0e:	84 83       	std	Z+4, r24	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    3e10:	17 7f       	andi	r17, 0xF7	; 247
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    3e12:	86 e1       	ldi	r24, 0x16	; 22
    3e14:	0e 94 7b 1c 	call	0x38f6	; 0x38f6 <chb_set_state>
    3e18:	80 34       	cpi	r24, 0x40	; 64
    3e1a:	d9 f7       	brne	.-10     	; 0x3e12 <__vector_64+0x190>
    3e1c:	19 c0       	rjmp	.+50     	; 0x3e50 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    3e1e:	16 ff       	sbrs	r17, 6
    3e20:	08 c0       	rjmp	.+16     	; 0x3e32 <__vector_64+0x1b0>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    3e22:	1f 7b       	andi	r17, 0xBF	; 191
            pcb->underrun++;
    3e24:	f7 01       	movw	r30, r14
    3e26:	87 85       	ldd	r24, Z+15	; 0x0f
    3e28:	90 89       	ldd	r25, Z+16	; 0x10
    3e2a:	01 96       	adiw	r24, 0x01	; 1
    3e2c:	87 87       	std	Z+15, r24	; 0x0f
    3e2e:	90 8b       	std	Z+16, r25	; 0x10
    3e30:	0f c0       	rjmp	.+30     	; 0x3e50 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    3e32:	11 ff       	sbrs	r17, 1
    3e34:	02 c0       	rjmp	.+4      	; 0x3e3a <__vector_64+0x1b8>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    3e36:	1d 7f       	andi	r17, 0xFD	; 253
    3e38:	0b c0       	rjmp	.+22     	; 0x3e50 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    3e3a:	10 ff       	sbrs	r17, 0
    3e3c:	02 c0       	rjmp	.+4      	; 0x3e42 <__vector_64+0x1c0>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    3e3e:	1e 7f       	andi	r17, 0xFE	; 254
    3e40:	07 c0       	rjmp	.+14     	; 0x3e50 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    3e42:	11 23       	and	r17, r17
    3e44:	2c f4       	brge	.+10     	; 0x3e50 <__vector_64+0x1ce>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    3e46:	1f 77       	andi	r17, 0x7F	; 127
            pcb->battlow++;
    3e48:	f7 01       	movw	r30, r14
    3e4a:	81 89       	ldd	r24, Z+17	; 0x11
    3e4c:	8f 5f       	subi	r24, 0xFF	; 255
    3e4e:	81 8b       	std	Z+17, r24	; 0x11
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    3e50:	11 23       	and	r17, r17
    3e52:	09 f0       	breq	.+2      	; 0x3e56 <__vector_64+0x1d4>
    3e54:	5c cf       	rjmp	.-328    	; 0x3d0e <__vector_64+0x8c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    3e56:	80 91 58 40 	lds	r24, 0x4058
    3e5a:	8f bf       	out	0x3f, r24	; 63
    3e5c:	78 94       	sei
}
    3e5e:	e2 96       	adiw	r28, 0x32	; 50
    3e60:	cd bf       	out	0x3d, r28	; 61
    3e62:	de bf       	out	0x3e, r29	; 62
    3e64:	df 91       	pop	r29
    3e66:	cf 91       	pop	r28
    3e68:	ff 91       	pop	r31
    3e6a:	ef 91       	pop	r30
    3e6c:	bf 91       	pop	r27
    3e6e:	af 91       	pop	r26
    3e70:	9f 91       	pop	r25
    3e72:	8f 91       	pop	r24
    3e74:	7f 91       	pop	r23
    3e76:	6f 91       	pop	r22
    3e78:	5f 91       	pop	r21
    3e7a:	4f 91       	pop	r20
    3e7c:	3f 91       	pop	r19
    3e7e:	2f 91       	pop	r18
    3e80:	1f 91       	pop	r17
    3e82:	0f 91       	pop	r16
    3e84:	ff 90       	pop	r15
    3e86:	ef 90       	pop	r14
    3e88:	df 90       	pop	r13
    3e8a:	bf 90       	pop	r11
    3e8c:	af 90       	pop	r10
    3e8e:	9f 90       	pop	r9
    3e90:	8f 90       	pop	r8
    3e92:	7f 90       	pop	r7
    3e94:	6f 90       	pop	r6
    3e96:	0f 90       	pop	r0
    3e98:	0b be       	out	0x3b, r0	; 59
    3e9a:	0f 90       	pop	r0
    3e9c:	0f be       	out	0x3f, r0	; 63
    3e9e:	0f 90       	pop	r0
    3ea0:	1f 90       	pop	r1
    3ea2:	18 95       	reti

00003ea4 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    3ea4:	0f 93       	push	r16
    3ea6:	1f 93       	push	r17
    3ea8:	cf 93       	push	r28
    3eaa:	df 93       	push	r29
    3eac:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3eae:	e0 ec       	ldi	r30, 0xC0	; 192
    3eb0:	f1 e0       	ldi	r31, 0x01	; 1
    3eb2:	84 85       	ldd	r24, Z+12	; 0x0c
    3eb4:	87 7f       	andi	r24, 0xF7	; 247
    3eb6:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    3eb8:	41 15       	cp	r20, r1
    3eba:	51 05       	cpc	r21, r1
    3ebc:	09 f4       	brne	.+2      	; 0x3ec0 <chb_eeprom_write+0x1c>
    3ebe:	50 c0       	rjmp	.+160    	; 0x3f60 <chb_eeprom_write+0xbc>
    3ec0:	e0 e0       	ldi	r30, 0x00	; 0
    3ec2:	f0 e0       	ldi	r31, 0x00	; 0
    3ec4:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3ec6:	a0 ec       	ldi	r26, 0xC0	; 192
    3ec8:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3eca:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3ecc:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3ece:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
    3ed0:	cf 01       	movw	r24, r30
    3ed2:	80 0f       	add	r24, r16
    3ed4:	91 1f       	adc	r25, r17
    3ed6:	e6 0f       	add	r30, r22
    3ed8:	f7 1f       	adc	r31, r23
    3eda:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3edc:	1f 96       	adiw	r26, 0x0f	; 15
    3ede:	ec 91       	ld	r30, X
    3ee0:	1f 97       	sbiw	r26, 0x0f	; 15
    3ee2:	ee 23       	and	r30, r30
    3ee4:	dc f3       	brlt	.-10     	; 0x3edc <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    3ee6:	1f 96       	adiw	r26, 0x0f	; 15
    3ee8:	ec 91       	ld	r30, X
    3eea:	1f 97       	sbiw	r26, 0x0f	; 15
    3eec:	e1 ff       	sbrs	r30, 1
    3eee:	11 c0       	rjmp	.+34     	; 0x3f12 <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3ef0:	1a 96       	adiw	r26, 0x0a	; 10
    3ef2:	dc 93       	st	X, r29
    3ef4:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
    3ef6:	ef 93       	push	r30
    3ef8:	ff 93       	push	r31
    3efa:	0f 93       	push	r16
    3efc:	2f 93       	push	r18
    3efe:	eb ec       	ldi	r30, 0xCB	; 203
    3f00:	f1 e0       	ldi	r31, 0x01	; 1
    3f02:	08 ed       	ldi	r16, 0xD8	; 216
    3f04:	21 e0       	ldi	r18, 0x01	; 1
    3f06:	04 bf       	out	0x34, r16	; 52
    3f08:	20 83       	st	Z, r18
    3f0a:	2f 91       	pop	r18
    3f0c:	0f 91       	pop	r16
    3f0e:	ff 91       	pop	r31
    3f10:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3f12:	1a 96       	adiw	r26, 0x0a	; 10
    3f14:	cc 93       	st	X, r28
    3f16:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    3f18:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3f1a:	89 2f       	mov	r24, r25
    3f1c:	8f 71       	andi	r24, 0x1F	; 31
    3f1e:	11 96       	adiw	r26, 0x01	; 1
    3f20:	8c 93       	st	X, r24
    3f22:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
    3f24:	12 96       	adiw	r26, 0x02	; 2
    3f26:	1c 92       	st	X, r1
    3f28:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
    3f2a:	14 96       	adiw	r26, 0x04	; 4
    3f2c:	fc 93       	st	X, r31
    3f2e:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3f30:	1a 96       	adiw	r26, 0x0a	; 10
    3f32:	3c 93       	st	X, r19
    3f34:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
    3f36:	ef 93       	push	r30
    3f38:	ff 93       	push	r31
    3f3a:	0f 93       	push	r16
    3f3c:	2f 93       	push	r18
    3f3e:	eb ec       	ldi	r30, 0xCB	; 203
    3f40:	f1 e0       	ldi	r31, 0x01	; 1
    3f42:	08 ed       	ldi	r16, 0xD8	; 216
    3f44:	21 e0       	ldi	r18, 0x01	; 1
    3f46:	04 bf       	out	0x34, r16	; 52
    3f48:	20 83       	st	Z, r18
    3f4a:	2f 91       	pop	r18
    3f4c:	0f 91       	pop	r16
    3f4e:	ff 91       	pop	r31
    3f50:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    3f52:	2f 5f       	subi	r18, 0xFF	; 255
    3f54:	e2 2f       	mov	r30, r18
    3f56:	f0 e0       	ldi	r31, 0x00	; 0
    3f58:	e4 17       	cp	r30, r20
    3f5a:	f5 07       	cpc	r31, r21
    3f5c:	08 f4       	brcc	.+2      	; 0x3f60 <chb_eeprom_write+0xbc>
    3f5e:	b8 cf       	rjmp	.-144    	; 0x3ed0 <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    3f60:	df 91       	pop	r29
    3f62:	cf 91       	pop	r28
    3f64:	1f 91       	pop	r17
    3f66:	0f 91       	pop	r16
    3f68:	08 95       	ret

00003f6a <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    3f6a:	1f 93       	push	r17
    3f6c:	cf 93       	push	r28
    3f6e:	df 93       	push	r29
    3f70:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3f72:	e0 ec       	ldi	r30, 0xC0	; 192
    3f74:	f1 e0       	ldi	r31, 0x01	; 1
    3f76:	84 85       	ldd	r24, Z+12	; 0x0c
    3f78:	87 7f       	andi	r24, 0xF7	; 247
    3f7a:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3f7c:	41 15       	cp	r20, r1
    3f7e:	51 05       	cpc	r21, r1
    3f80:	41 f1       	breq	.+80     	; 0x3fd2 <chb_eeprom_read+0x68>
    3f82:	80 e0       	ldi	r24, 0x00	; 0
    3f84:	90 e0       	ldi	r25, 0x00	; 0
    3f86:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3f88:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3f8a:	db 01       	movw	r26, r22
    3f8c:	a8 0f       	add	r26, r24
    3f8e:	b9 1f       	adc	r27, r25
    3f90:	82 0f       	add	r24, r18
    3f92:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3f94:	17 85       	ldd	r17, Z+15	; 0x0f
    3f96:	11 23       	and	r17, r17
    3f98:	ec f3       	brlt	.-6      	; 0x3f94 <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    3f9a:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3f9c:	89 2f       	mov	r24, r25
    3f9e:	8f 71       	andi	r24, 0x1F	; 31
    3fa0:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
    3fa2:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3fa4:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
    3fa6:	ef 93       	push	r30
    3fa8:	ff 93       	push	r31
    3faa:	0f 93       	push	r16
    3fac:	2f 93       	push	r18
    3fae:	eb ec       	ldi	r30, 0xCB	; 203
    3fb0:	f1 e0       	ldi	r31, 0x01	; 1
    3fb2:	08 ed       	ldi	r16, 0xD8	; 216
    3fb4:	21 e0       	ldi	r18, 0x01	; 1
    3fb6:	04 bf       	out	0x34, r16	; 52
    3fb8:	20 83       	st	Z, r18
    3fba:	2f 91       	pop	r18
    3fbc:	0f 91       	pop	r16
    3fbe:	ff 91       	pop	r31
    3fc0:	ef 91       	pop	r30

    return NVM.DATA0;
    3fc2:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3fc4:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3fc6:	cf 5f       	subi	r28, 0xFF	; 255
    3fc8:	8c 2f       	mov	r24, r28
    3fca:	90 e0       	ldi	r25, 0x00	; 0
    3fcc:	84 17       	cp	r24, r20
    3fce:	95 07       	cpc	r25, r21
    3fd0:	e0 f2       	brcs	.-72     	; 0x3f8a <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    3fd2:	df 91       	pop	r29
    3fd4:	cf 91       	pop	r28
    3fd6:	1f 91       	pop	r17
    3fd8:	08 95       	ret

00003fda <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    3fda:	e0 e6       	ldi	r30, 0x60	; 96
    3fdc:	f6 e0       	ldi	r31, 0x06	; 6
    3fde:	80 81       	ld	r24, Z
    3fe0:	80 6b       	ori	r24, 0xB0	; 176
    3fe2:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    3fe4:	e4 e6       	ldi	r30, 0x64	; 100
    3fe6:	f6 e0       	ldi	r31, 0x06	; 6
    3fe8:	80 81       	ld	r24, Z
    3fea:	80 61       	ori	r24, 0x10	; 16
    3fec:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    3fee:	a0 ec       	ldi	r26, 0xC0	; 192
    3ff0:	b9 e0       	ldi	r27, 0x09	; 9
    3ff2:	8c 91       	ld	r24, X
    3ff4:	81 65       	ori	r24, 0x51	; 81
    3ff6:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    3ff8:	80 81       	ld	r24, Z
    3ffa:	80 61       	ori	r24, 0x10	; 16
    3ffc:	80 83       	st	Z, r24
}
    3ffe:	08 95       	ret

00004000 <SPID_write>:
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    4000:	e0 ec       	ldi	r30, 0xC0	; 192
    4002:	f9 e0       	ldi	r31, 0x09	; 9
    4004:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    4006:	82 81       	ldd	r24, Z+2	; 0x02
    4008:	88 23       	and	r24, r24
    400a:	ec f7       	brge	.-6      	; 0x4006 <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    400c:	e0 ec       	ldi	r30, 0xC0	; 192
    400e:	f9 e0       	ldi	r31, 0x09	; 9
    4010:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    4012:	08 95       	ret

00004014 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    4014:	0f 93       	push	r16
    4016:	cf 93       	push	r28
    4018:	df 93       	push	r29
    401a:	0f 92       	push	r0
    401c:	cd b7       	in	r28, 0x3d	; 61
    401e:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    4020:	2f b7       	in	r18, 0x3f	; 63
    4022:	29 83       	std	Y+1, r18	; 0x01
    4024:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    4026:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    4028:	fc 01       	movw	r30, r24
    402a:	08 ed       	ldi	r16, 0xD8	; 216
    402c:	04 bf       	out	0x34, r16	; 52
    402e:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    4030:	89 81       	ldd	r24, Y+1	; 0x01
    4032:	8f bf       	out	0x3f, r24	; 63
#endif
}
    4034:	0f 90       	pop	r0
    4036:	df 91       	pop	r29
    4038:	cf 91       	pop	r28
    403a:	0f 91       	pop	r16
    403c:	08 95       	ret

0000403e <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    403e:	66 23       	and	r22, r22
    4040:	11 f0       	breq	.+4      	; 0x4046 <CLKSYS_XOSC_Config+0x8>
    4042:	90 e2       	ldi	r25, 0x20	; 32
    4044:	01 c0       	rjmp	.+2      	; 0x4048 <CLKSYS_XOSC_Config+0xa>
    4046:	90 e0       	ldi	r25, 0x00	; 0
    4048:	84 2b       	or	r24, r20
    404a:	89 2b       	or	r24, r25
    404c:	e0 e5       	ldi	r30, 0x50	; 80
    404e:	f0 e0       	ldi	r31, 0x00	; 0
    4050:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    4052:	08 95       	ret

00004054 <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    4054:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    4056:	86 2b       	or	r24, r22
    4058:	e0 e5       	ldi	r30, 0x50	; 80
    405a:	f0 e0       	ldi	r31, 0x00	; 0
    405c:	85 83       	std	Z+5, r24	; 0x05
}
    405e:	08 95       	ret

00004060 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    4060:	e0 e5       	ldi	r30, 0x50	; 80
    4062:	f0 e0       	ldi	r31, 0x00	; 0
    4064:	90 81       	ld	r25, Z
    4066:	28 2f       	mov	r18, r24
    4068:	20 95       	com	r18
    406a:	92 23       	and	r25, r18
    406c:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    406e:	90 81       	ld	r25, Z
	return clkEnabled;
}
    4070:	89 23       	and	r24, r25
    4072:	08 95       	ret

00004074 <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    4074:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    4076:	81 e4       	ldi	r24, 0x41	; 65
    4078:	90 e0       	ldi	r25, 0x00	; 0
    407a:	0e 94 0a 20 	call	0x4014	; 0x4014 <CCPWrite>
}
    407e:	08 95       	ret

00004080 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    4080:	1f 93       	push	r17
    4082:	cf 93       	push	r28
    4084:	df 93       	push	r29
    4086:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    4088:	c0 e4       	ldi	r28, 0x40	; 64
    408a:	d0 e0       	ldi	r29, 0x00	; 0
    408c:	68 81       	ld	r22, Y
    408e:	68 7f       	andi	r22, 0xF8	; 248
    4090:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    4092:	80 e4       	ldi	r24, 0x40	; 64
    4094:	90 e0       	ldi	r25, 0x00	; 0
    4096:	0e 94 0a 20 	call	0x4014	; 0x4014 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    409a:	88 81       	ld	r24, Y
	return clkCtrl;
}
    409c:	81 23       	and	r24, r17
    409e:	df 91       	pop	r29
    40a0:	cf 91       	pop	r28
    40a2:	1f 91       	pop	r17
    40a4:	08 95       	ret

000040a6 <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    40a6:	e0 e4       	ldi	r30, 0x40	; 64
    40a8:	f0 e0       	ldi	r31, 0x00	; 0
    40aa:	93 81       	ldd	r25, Z+3	; 0x03
    40ac:	91 7f       	andi	r25, 0xF1	; 241
    40ae:	91 60       	ori	r25, 0x01	; 1
    40b0:	89 2b       	or	r24, r25
    40b2:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    40b4:	08 95       	ret

000040b6 <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    40b6:	e0 e5       	ldi	r30, 0x50	; 80
    40b8:	f0 e0       	ldi	r31, 0x00	; 0
    40ba:	26 81       	ldd	r18, Z+6	; 0x06
    40bc:	98 2f       	mov	r25, r24
    40be:	38 2f       	mov	r19, r24
    40c0:	30 95       	com	r19
    40c2:	23 23       	and	r18, r19
    40c4:	66 23       	and	r22, r22
    40c6:	09 f4       	brne	.+2      	; 0x40ca <CLKSYS_AutoCalibration_Enable+0x14>
    40c8:	90 e0       	ldi	r25, 0x00	; 0
    40ca:	92 2b       	or	r25, r18
    40cc:	e0 e5       	ldi	r30, 0x50	; 80
    40ce:	f0 e0       	ldi	r31, 0x00	; 0
    40d0:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    40d2:	81 30       	cpi	r24, 0x01	; 1
    40d4:	31 f4       	brne	.+12     	; 0x40e2 <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    40d6:	e8 e6       	ldi	r30, 0x68	; 104
    40d8:	f0 e0       	ldi	r31, 0x00	; 0
    40da:	80 81       	ld	r24, Z
    40dc:	81 60       	ori	r24, 0x01	; 1
    40de:	80 83       	st	Z, r24
    40e0:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    40e2:	82 30       	cpi	r24, 0x02	; 2
    40e4:	29 f4       	brne	.+10     	; 0x40f0 <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    40e6:	e0 e6       	ldi	r30, 0x60	; 96
    40e8:	f0 e0       	ldi	r31, 0x00	; 0
    40ea:	80 81       	ld	r24, Z
    40ec:	81 60       	ori	r24, 0x01	; 1
    40ee:	80 83       	st	Z, r24
    40f0:	08 95       	ret

000040f2 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    40f2:	83 e5       	ldi	r24, 0x53	; 83
    40f4:	90 e0       	ldi	r25, 0x00	; 0
    40f6:	63 e0       	ldi	r22, 0x03	; 3
    40f8:	0e 94 0a 20 	call	0x4014	; 0x4014 <CCPWrite>
}
    40fc:	08 95       	ret

000040fe <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    40fe:	82 e4       	ldi	r24, 0x42	; 66
    4100:	90 e0       	ldi	r25, 0x00	; 0
    4102:	61 e0       	ldi	r22, 0x01	; 1
    4104:	0e 94 0a 20 	call	0x4014	; 0x4014 <CCPWrite>
}
    4108:	08 95       	ret

0000410a <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    410a:	cf 92       	push	r12
    410c:	df 92       	push	r13
    410e:	ef 92       	push	r14
    4110:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    4112:	20 91 6a 50 	lds	r18, 0x506A
    4116:	30 91 6b 50 	lds	r19, 0x506B
    411a:	c0 90 4e 40 	lds	r12, 0x404E
    411e:	d0 90 4f 40 	lds	r13, 0x404F
    4122:	e0 90 50 40 	lds	r14, 0x4050
    4126:	f0 90 51 40 	lds	r15, 0x4051
    412a:	62 50       	subi	r22, 0x02	; 2
    412c:	70 40       	sbci	r23, 0x00	; 0
    412e:	80 40       	sbci	r24, 0x00	; 0
    4130:	90 40       	sbci	r25, 0x00	; 0
    4132:	40 e0       	ldi	r20, 0x00	; 0
    4134:	50 e0       	ldi	r21, 0x00	; 0
    4136:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    413a:	dc 01       	movw	r26, r24
    413c:	cb 01       	movw	r24, r22
    413e:	c8 0e       	add	r12, r24
    4140:	d9 1e       	adc	r13, r25
    4142:	ea 1e       	adc	r14, r26
    4144:	fb 1e       	adc	r15, r27
}
    4146:	6c 2d       	mov	r22, r12
    4148:	7d 2d       	mov	r23, r13
    414a:	8e 2d       	mov	r24, r14
    414c:	9f 2d       	mov	r25, r15
    414e:	ff 90       	pop	r15
    4150:	ef 90       	pop	r14
    4152:	df 90       	pop	r13
    4154:	cf 90       	pop	r12
    4156:	08 95       	ret

00004158 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    4158:	3f 92       	push	r3
    415a:	4f 92       	push	r4
    415c:	5f 92       	push	r5
    415e:	6f 92       	push	r6
    4160:	7f 92       	push	r7
    4162:	8f 92       	push	r8
    4164:	9f 92       	push	r9
    4166:	af 92       	push	r10
    4168:	bf 92       	push	r11
    416a:	cf 92       	push	r12
    416c:	df 92       	push	r13
    416e:	ef 92       	push	r14
    4170:	ff 92       	push	r15
    4172:	0f 93       	push	r16
    4174:	1f 93       	push	r17
    4176:	cf 93       	push	r28
    4178:	df 93       	push	r29
    417a:	00 d0       	rcall	.+0      	; 0x417c <getSetNextCluster+0x24>
    417c:	0f 92       	push	r0
    417e:	cd b7       	in	r28, 0x3d	; 61
    4180:	de b7       	in	r29, 0x3e	; 62
    4182:	dc 01       	movw	r26, r24
    4184:	cb 01       	movw	r24, r22
    4186:	34 2e       	mov	r3, r20
    4188:	09 83       	std	Y+1, r16	; 0x01
    418a:	1a 83       	std	Y+2, r17	; 0x02
    418c:	2b 83       	std	Y+3, r18	; 0x03
    418e:	3c 83       	std	Y+4, r19	; 0x04
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    4190:	80 90 70 50 	lds	r8, 0x5070
    4194:	90 90 71 50 	lds	r9, 0x5071
    4198:	2c 01       	movw	r4, r24
    419a:	3d 01       	movw	r6, r26
    419c:	44 0c       	add	r4, r4
    419e:	55 1c       	adc	r5, r5
    41a0:	66 1c       	adc	r6, r6
    41a2:	77 1c       	adc	r7, r7
    41a4:	44 0c       	add	r4, r4
    41a6:	55 1c       	adc	r5, r5
    41a8:	66 1c       	adc	r6, r6
    41aa:	77 1c       	adc	r7, r7
    41ac:	20 91 56 40 	lds	r18, 0x4056
    41b0:	30 91 57 40 	lds	r19, 0x4057
    41b4:	aa 24       	eor	r10, r10
    41b6:	bb 24       	eor	r11, r11
    41b8:	80 91 6c 50 	lds	r24, 0x506C
    41bc:	90 91 6d 50 	lds	r25, 0x506D
    41c0:	a0 91 6e 50 	lds	r26, 0x506E
    41c4:	b0 91 6f 50 	lds	r27, 0x506F
    41c8:	88 0e       	add	r8, r24
    41ca:	99 1e       	adc	r9, r25
    41cc:	aa 1e       	adc	r10, r26
    41ce:	bb 1e       	adc	r11, r27
    41d0:	40 e0       	ldi	r20, 0x00	; 0
    41d2:	50 e0       	ldi	r21, 0x00	; 0
    41d4:	c3 01       	movw	r24, r6
    41d6:	b2 01       	movw	r22, r4
    41d8:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    41dc:	69 01       	movw	r12, r18
    41de:	7a 01       	movw	r14, r20
    41e0:	c8 0c       	add	r12, r8
    41e2:	d9 1c       	adc	r13, r9
    41e4:	ea 1c       	adc	r14, r10
    41e6:	fb 1c       	adc	r15, r11

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    41e8:	00 91 56 40 	lds	r16, 0x4056
    41ec:	10 91 57 40 	lds	r17, 0x4057

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    41f0:	c7 01       	movw	r24, r14
    41f2:	b6 01       	movw	r22, r12
    41f4:	49 e4       	ldi	r20, 0x49	; 73
    41f6:	5e e3       	ldi	r21, 0x3E	; 62
    41f8:	0e 94 8b 2b 	call	0x5716	; 0x5716 <SD_read_block>

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    41fc:	98 01       	movw	r18, r16
    41fe:	40 e0       	ldi	r20, 0x00	; 0
    4200:	50 e0       	ldi	r21, 0x00	; 0
    4202:	c3 01       	movw	r24, r6
    4204:	b2 01       	movw	r22, r4
    4206:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    420a:	67 5b       	subi	r22, 0xB7	; 183
    420c:	71 4c       	sbci	r23, 0xC1	; 193

if(get_set == GET)
    420e:	33 20       	and	r3, r3
    4210:	41 f4       	brne	.+16     	; 0x4222 <getSetNextCluster+0xca>
  return ((*FATEntryValue) & 0x0fffffff);
    4212:	db 01       	movw	r26, r22
    4214:	0d 91       	ld	r16, X+
    4216:	1d 91       	ld	r17, X+
    4218:	2d 91       	ld	r18, X+
    421a:	3c 91       	ld	r19, X
    421c:	13 97       	sbiw	r26, 0x03	; 3
    421e:	3f 70       	andi	r19, 0x0F	; 15
    4220:	14 c0       	rjmp	.+40     	; 0x424a <getSetNextCluster+0xf2>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    4222:	89 81       	ldd	r24, Y+1	; 0x01
    4224:	9a 81       	ldd	r25, Y+2	; 0x02
    4226:	ab 81       	ldd	r26, Y+3	; 0x03
    4228:	bc 81       	ldd	r27, Y+4	; 0x04
    422a:	fb 01       	movw	r30, r22
    422c:	80 83       	st	Z, r24
    422e:	91 83       	std	Z+1, r25	; 0x01
    4230:	a2 83       	std	Z+2, r26	; 0x02
    4232:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    4234:	c7 01       	movw	r24, r14
    4236:	b6 01       	movw	r22, r12
    4238:	49 e4       	ldi	r20, 0x49	; 73
    423a:	5e e3       	ldi	r21, 0x3E	; 62
    423c:	20 e0       	ldi	r18, 0x00	; 0
    423e:	32 e0       	ldi	r19, 0x02	; 2
    4240:	0e 94 d6 2a 	call	0x55ac	; 0x55ac <SD_write_block>

return (0);
    4244:	00 e0       	ldi	r16, 0x00	; 0
    4246:	10 e0       	ldi	r17, 0x00	; 0
    4248:	98 01       	movw	r18, r16
}
    424a:	60 2f       	mov	r22, r16
    424c:	71 2f       	mov	r23, r17
    424e:	82 2f       	mov	r24, r18
    4250:	93 2f       	mov	r25, r19
    4252:	24 96       	adiw	r28, 0x04	; 4
    4254:	cd bf       	out	0x3d, r28	; 61
    4256:	de bf       	out	0x3e, r29	; 62
    4258:	df 91       	pop	r29
    425a:	cf 91       	pop	r28
    425c:	1f 91       	pop	r17
    425e:	0f 91       	pop	r16
    4260:	ff 90       	pop	r15
    4262:	ef 90       	pop	r14
    4264:	df 90       	pop	r13
    4266:	cf 90       	pop	r12
    4268:	bf 90       	pop	r11
    426a:	af 90       	pop	r10
    426c:	9f 90       	pop	r9
    426e:	8f 90       	pop	r8
    4270:	7f 90       	pop	r7
    4272:	6f 90       	pop	r6
    4274:	5f 90       	pop	r5
    4276:	4f 90       	pop	r4
    4278:	3f 90       	pop	r3
    427a:	08 95       	ret

0000427c <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    427c:	cf 92       	push	r12
    427e:	df 92       	push	r13
    4280:	ef 92       	push	r14
    4282:	ff 92       	push	r15
    4284:	0f 93       	push	r16
    4286:	1f 93       	push	r17
    4288:	cf 93       	push	r28
    428a:	c8 2f       	mov	r28, r24
    428c:	06 2f       	mov	r16, r22
    428e:	69 01       	movw	r12, r18
    4290:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    4292:	80 91 6c 50 	lds	r24, 0x506C
    4296:	90 91 6d 50 	lds	r25, 0x506D
    429a:	a0 91 6e 50 	lds	r26, 0x506E
    429e:	b0 91 6f 50 	lds	r27, 0x506F
    42a2:	bc 01       	movw	r22, r24
    42a4:	cd 01       	movw	r24, r26
    42a6:	6f 5f       	subi	r22, 0xFF	; 255
    42a8:	7f 4f       	sbci	r23, 0xFF	; 255
    42aa:	8f 4f       	sbci	r24, 0xFF	; 255
    42ac:	9f 4f       	sbci	r25, 0xFF	; 255
    42ae:	49 e4       	ldi	r20, 0x49	; 73
    42b0:	5e e3       	ldi	r21, 0x3E	; 62
    42b2:	0e 94 8b 2b 	call	0x5716	; 0x5716 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    42b6:	80 91 49 3e 	lds	r24, 0x3E49
    42ba:	90 91 4a 3e 	lds	r25, 0x3E4A
    42be:	a0 91 4b 3e 	lds	r26, 0x3E4B
    42c2:	b0 91 4c 3e 	lds	r27, 0x3E4C
    42c6:	82 35       	cpi	r24, 0x52	; 82
    42c8:	22 e5       	ldi	r18, 0x52	; 82
    42ca:	92 07       	cpc	r25, r18
    42cc:	21 e6       	ldi	r18, 0x61	; 97
    42ce:	a2 07       	cpc	r26, r18
    42d0:	21 e4       	ldi	r18, 0x41	; 65
    42d2:	b2 07       	cpc	r27, r18
    42d4:	09 f0       	breq	.+2      	; 0x42d8 <getSetFreeCluster+0x5c>
    42d6:	63 c0       	rjmp	.+198    	; 0x439e <getSetFreeCluster+0x122>
    42d8:	80 91 2d 40 	lds	r24, 0x402D
    42dc:	90 91 2e 40 	lds	r25, 0x402E
    42e0:	a0 91 2f 40 	lds	r26, 0x402F
    42e4:	b0 91 30 40 	lds	r27, 0x4030
    42e8:	82 37       	cpi	r24, 0x72	; 114
    42ea:	22 e7       	ldi	r18, 0x72	; 114
    42ec:	92 07       	cpc	r25, r18
    42ee:	21 e4       	ldi	r18, 0x41	; 65
    42f0:	a2 07       	cpc	r26, r18
    42f2:	21 e6       	ldi	r18, 0x61	; 97
    42f4:	b2 07       	cpc	r27, r18
    42f6:	09 f0       	breq	.+2      	; 0x42fa <getSetFreeCluster+0x7e>
    42f8:	56 c0       	rjmp	.+172    	; 0x43a6 <getSetFreeCluster+0x12a>
    42fa:	80 91 45 40 	lds	r24, 0x4045
    42fe:	90 91 46 40 	lds	r25, 0x4046
    4302:	a0 91 47 40 	lds	r26, 0x4047
    4306:	b0 91 48 40 	lds	r27, 0x4048
    430a:	80 30       	cpi	r24, 0x00	; 0
    430c:	20 e0       	ldi	r18, 0x00	; 0
    430e:	92 07       	cpc	r25, r18
    4310:	25 e5       	ldi	r18, 0x55	; 85
    4312:	a2 07       	cpc	r26, r18
    4314:	2a ea       	ldi	r18, 0xAA	; 170
    4316:	b2 07       	cpc	r27, r18
    4318:	09 f0       	breq	.+2      	; 0x431c <getSetFreeCluster+0xa0>
    431a:	49 c0       	rjmp	.+146    	; 0x43ae <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    431c:	00 23       	and	r16, r16
    431e:	a1 f4       	brne	.+40     	; 0x4348 <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    4320:	c1 30       	cpi	r28, 0x01	; 1
    4322:	49 f4       	brne	.+18     	; 0x4336 <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    4324:	00 91 31 40 	lds	r16, 0x4031
    4328:	10 91 32 40 	lds	r17, 0x4032
    432c:	20 91 33 40 	lds	r18, 0x4033
    4330:	30 91 34 40 	lds	r19, 0x4034
    4334:	3f c0       	rjmp	.+126    	; 0x43b4 <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    4336:	00 91 35 40 	lds	r16, 0x4035
    433a:	10 91 36 40 	lds	r17, 0x4036
    433e:	20 91 37 40 	lds	r18, 0x4037
    4342:	30 91 38 40 	lds	r19, 0x4038
    4346:	36 c0       	rjmp	.+108    	; 0x43b4 <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    4348:	c1 30       	cpi	r28, 0x01	; 1
    434a:	49 f4       	brne	.+18     	; 0x435e <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    434c:	c0 92 31 40 	sts	0x4031, r12
    4350:	d0 92 32 40 	sts	0x4032, r13
    4354:	e0 92 33 40 	sts	0x4033, r14
    4358:	f0 92 34 40 	sts	0x4034, r15
    435c:	08 c0       	rjmp	.+16     	; 0x436e <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    435e:	c0 92 35 40 	sts	0x4035, r12
    4362:	d0 92 36 40 	sts	0x4036, r13
    4366:	e0 92 37 40 	sts	0x4037, r14
    436a:	f0 92 38 40 	sts	0x4038, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    436e:	80 91 6c 50 	lds	r24, 0x506C
    4372:	90 91 6d 50 	lds	r25, 0x506D
    4376:	a0 91 6e 50 	lds	r26, 0x506E
    437a:	b0 91 6f 50 	lds	r27, 0x506F
    437e:	bc 01       	movw	r22, r24
    4380:	cd 01       	movw	r24, r26
    4382:	6f 5f       	subi	r22, 0xFF	; 255
    4384:	7f 4f       	sbci	r23, 0xFF	; 255
    4386:	8f 4f       	sbci	r24, 0xFF	; 255
    4388:	9f 4f       	sbci	r25, 0xFF	; 255
    438a:	49 e4       	ldi	r20, 0x49	; 73
    438c:	5e e3       	ldi	r21, 0x3E	; 62
    438e:	20 e0       	ldi	r18, 0x00	; 0
    4390:	32 e0       	ldi	r19, 0x02	; 2
    4392:	0e 94 d6 2a 	call	0x55ac	; 0x55ac <SD_write_block>
 }
 return 0xffffffff;
    4396:	0f ef       	ldi	r16, 0xFF	; 255
    4398:	1f ef       	ldi	r17, 0xFF	; 255
    439a:	98 01       	movw	r18, r16
    439c:	0b c0       	rjmp	.+22     	; 0x43b4 <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    439e:	0f ef       	ldi	r16, 0xFF	; 255
    43a0:	1f ef       	ldi	r17, 0xFF	; 255
    43a2:	98 01       	movw	r18, r16
    43a4:	07 c0       	rjmp	.+14     	; 0x43b4 <getSetFreeCluster+0x138>
    43a6:	0f ef       	ldi	r16, 0xFF	; 255
    43a8:	1f ef       	ldi	r17, 0xFF	; 255
    43aa:	98 01       	movw	r18, r16
    43ac:	03 c0       	rjmp	.+6      	; 0x43b4 <getSetFreeCluster+0x138>
    43ae:	0f ef       	ldi	r16, 0xFF	; 255
    43b0:	1f ef       	ldi	r17, 0xFF	; 255
    43b2:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    43b4:	60 2f       	mov	r22, r16
    43b6:	71 2f       	mov	r23, r17
    43b8:	82 2f       	mov	r24, r18
    43ba:	93 2f       	mov	r25, r19
    43bc:	cf 91       	pop	r28
    43be:	1f 91       	pop	r17
    43c0:	0f 91       	pop	r16
    43c2:	ff 90       	pop	r15
    43c4:	ef 90       	pop	r14
    43c6:	df 90       	pop	r13
    43c8:	cf 90       	pop	r12
    43ca:	08 95       	ret

000043cc <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    43cc:	ef 92       	push	r14
    43ce:	ff 92       	push	r15
    43d0:	0f 93       	push	r16
    43d2:	1f 93       	push	r17
    43d4:	cf 93       	push	r28
    43d6:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    43d8:	10 92 6c 50 	sts	0x506C, r1
    43dc:	10 92 6d 50 	sts	0x506D, r1
    43e0:	10 92 6e 50 	sts	0x506E, r1
    43e4:	10 92 6f 50 	sts	0x506F, r1

SD_read_block(0,SDBuffer);
    43e8:	60 e0       	ldi	r22, 0x00	; 0
    43ea:	70 e0       	ldi	r23, 0x00	; 0
    43ec:	cb 01       	movw	r24, r22
    43ee:	49 e4       	ldi	r20, 0x49	; 73
    43f0:	5e e3       	ldi	r21, 0x3E	; 62
    43f2:	0e 94 8b 2b 	call	0x5716	; 0x5716 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    43f6:	80 91 49 3e 	lds	r24, 0x3E49
    43fa:	89 3e       	cpi	r24, 0xE9	; 233
    43fc:	31 f1       	breq	.+76     	; 0x444a <getBootSectorData+0x7e>
    43fe:	8b 3e       	cpi	r24, 0xEB	; 235
    4400:	21 f1       	breq	.+72     	; 0x444a <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4402:	80 91 47 40 	lds	r24, 0x4047
    4406:	90 91 48 40 	lds	r25, 0x4048
    440a:	2a ea       	ldi	r18, 0xAA	; 170
    440c:	85 35       	cpi	r24, 0x55	; 85
    440e:	92 07       	cpc	r25, r18
    4410:	09 f0       	breq	.+2      	; 0x4414 <getBootSectorData+0x48>
    4412:	b7 c0       	rjmp	.+366    	; 0x4582 <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    4414:	60 91 0f 40 	lds	r22, 0x400F
    4418:	70 91 10 40 	lds	r23, 0x4010
    441c:	80 91 11 40 	lds	r24, 0x4011
    4420:	90 91 12 40 	lds	r25, 0x4012
    4424:	60 93 6c 50 	sts	0x506C, r22
    4428:	70 93 6d 50 	sts	0x506D, r23
    442c:	80 93 6e 50 	sts	0x506E, r24
    4430:	90 93 6f 50 	sts	0x506F, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    4434:	49 e4       	ldi	r20, 0x49	; 73
    4436:	5e e3       	ldi	r21, 0x3E	; 62
    4438:	0e 94 8b 2b 	call	0x5716	; 0x5716 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    443c:	80 91 49 3e 	lds	r24, 0x3E49
    4440:	89 3e       	cpi	r24, 0xE9	; 233
    4442:	19 f0       	breq	.+6      	; 0x444a <getBootSectorData+0x7e>
    4444:	8b 3e       	cpi	r24, 0xEB	; 235
    4446:	09 f0       	breq	.+2      	; 0x444a <getBootSectorData+0x7e>
    4448:	9e c0       	rjmp	.+316    	; 0x4586 <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    444a:	80 91 54 3e 	lds	r24, 0x3E54
    444e:	90 91 55 3e 	lds	r25, 0x3E55
    4452:	80 93 56 40 	sts	0x4056, r24
    4456:	90 93 57 40 	sts	0x4057, r25
sectorPerCluster = bpb->sectorPerCluster;
    445a:	80 91 56 3e 	lds	r24, 0x3E56
    445e:	90 e0       	ldi	r25, 0x00	; 0
    4460:	80 93 6a 50 	sts	0x506A, r24
    4464:	90 93 6b 50 	sts	0x506B, r25
reservedSectorCount = bpb->reservedSectorCount;
    4468:	e0 90 57 3e 	lds	r14, 0x3E57
    446c:	f0 90 58 3e 	lds	r15, 0x3E58
    4470:	e0 92 70 50 	sts	0x5070, r14
    4474:	f0 92 71 50 	sts	0x5071, r15
rootCluster = bpb->rootCluster;
    4478:	80 91 75 3e 	lds	r24, 0x3E75
    447c:	90 91 76 3e 	lds	r25, 0x3E76
    4480:	a0 91 77 3e 	lds	r26, 0x3E77
    4484:	b0 91 78 3e 	lds	r27, 0x3E78
    4488:	80 93 5e 40 	sts	0x405E, r24
    448c:	90 93 5f 40 	sts	0x405F, r25
    4490:	a0 93 60 40 	sts	0x4060, r26
    4494:	b0 93 61 40 	sts	0x4061, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    4498:	c0 91 70 50 	lds	r28, 0x5070
    449c:	d0 91 71 50 	lds	r29, 0x5071
    44a0:	60 91 59 3e 	lds	r22, 0x3E59
    44a4:	70 e0       	ldi	r23, 0x00	; 0
    44a6:	80 e0       	ldi	r24, 0x00	; 0
    44a8:	90 e0       	ldi	r25, 0x00	; 0
    44aa:	20 91 6d 3e 	lds	r18, 0x3E6D
    44ae:	30 91 6e 3e 	lds	r19, 0x3E6E
    44b2:	40 91 6f 3e 	lds	r20, 0x3E6F
    44b6:	50 91 70 3e 	lds	r21, 0x3E70
    44ba:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    44be:	8b 01       	movw	r16, r22
    44c0:	9c 01       	movw	r18, r24
    44c2:	ae 01       	movw	r20, r28
    44c4:	60 e0       	ldi	r22, 0x00	; 0
    44c6:	70 e0       	ldi	r23, 0x00	; 0
    44c8:	80 91 65 3e 	lds	r24, 0x3E65
    44cc:	90 91 66 3e 	lds	r25, 0x3E66
    44d0:	a0 91 67 3e 	lds	r26, 0x3E67
    44d4:	b0 91 68 3e 	lds	r27, 0x3E68
    44d8:	84 0f       	add	r24, r20
    44da:	95 1f       	adc	r25, r21
    44dc:	a6 1f       	adc	r26, r22
    44de:	b7 1f       	adc	r27, r23
    44e0:	80 0f       	add	r24, r16
    44e2:	91 1f       	adc	r25, r17
    44e4:	a2 1f       	adc	r26, r18
    44e6:	b3 1f       	adc	r27, r19
    44e8:	80 93 4e 40 	sts	0x404E, r24
    44ec:	90 93 4f 40 	sts	0x404F, r25
    44f0:	a0 93 50 40 	sts	0x4050, r26
    44f4:	b0 93 51 40 	sts	0x4051, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    44f8:	e0 91 6a 50 	lds	r30, 0x506A
    44fc:	f0 91 6b 50 	lds	r31, 0x506B
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    4500:	c7 01       	movw	r24, r14
    4502:	a0 e0       	ldi	r26, 0x00	; 0
    4504:	b0 e0       	ldi	r27, 0x00	; 0
    4506:	40 91 69 3e 	lds	r20, 0x3E69
    450a:	50 91 6a 3e 	lds	r21, 0x3E6A
    450e:	60 91 6b 3e 	lds	r22, 0x3E6B
    4512:	70 91 6c 3e 	lds	r23, 0x3E6C
    4516:	48 1b       	sub	r20, r24
    4518:	59 0b       	sbc	r21, r25
    451a:	6a 0b       	sbc	r22, r26
    451c:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    451e:	cb 01       	movw	r24, r22
    4520:	ba 01       	movw	r22, r20
    4522:	60 1b       	sub	r22, r16
    4524:	71 0b       	sbc	r23, r17
    4526:	82 0b       	sbc	r24, r18
    4528:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    452a:	9f 01       	movw	r18, r30
    452c:	40 e0       	ldi	r20, 0x00	; 0
    452e:	50 e0       	ldi	r21, 0x00	; 0
    4530:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    4534:	20 93 59 40 	sts	0x4059, r18
    4538:	30 93 5a 40 	sts	0x405A, r19
    453c:	40 93 5b 40 	sts	0x405B, r20
    4540:	50 93 5c 40 	sts	0x405C, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    4544:	81 e0       	ldi	r24, 0x01	; 1
    4546:	60 e0       	ldi	r22, 0x00	; 0
    4548:	20 e0       	ldi	r18, 0x00	; 0
    454a:	30 e0       	ldi	r19, 0x00	; 0
    454c:	a9 01       	movw	r20, r18
    454e:	0e 94 3e 21 	call	0x427c	; 0x427c <getSetFreeCluster>
    4552:	ab 01       	movw	r20, r22
    4554:	bc 01       	movw	r22, r24
    4556:	80 91 59 40 	lds	r24, 0x4059
    455a:	90 91 5a 40 	lds	r25, 0x405A
    455e:	a0 91 5b 40 	lds	r26, 0x405B
    4562:	b0 91 5c 40 	lds	r27, 0x405C
    4566:	84 17       	cp	r24, r20
    4568:	95 07       	cpc	r25, r21
    456a:	a6 07       	cpc	r26, r22
    456c:	b7 07       	cpc	r27, r23
    456e:	20 f4       	brcc	.+8      	; 0x4578 <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    4570:	10 92 a2 50 	sts	0x50A2, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    4574:	80 e0       	ldi	r24, 0x00	; 0
    4576:	08 c0       	rjmp	.+16     	; 0x4588 <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    4578:	81 e0       	ldi	r24, 0x01	; 1
    457a:	80 93 a2 50 	sts	0x50A2, r24
return 0;
    457e:	80 e0       	ldi	r24, 0x00	; 0
    4580:	03 c0       	rjmp	.+6      	; 0x4588 <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4582:	81 e0       	ldi	r24, 0x01	; 1
    4584:	01 c0       	rjmp	.+2      	; 0x4588 <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4586:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    4588:	df 91       	pop	r29
    458a:	cf 91       	pop	r28
    458c:	1f 91       	pop	r17
    458e:	0f 91       	pop	r16
    4590:	ff 90       	pop	r15
    4592:	ef 90       	pop	r14
    4594:	08 95       	ret

00004596 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    4596:	0f 93       	push	r16
    4598:	1f 93       	push	r17
    459a:	cf 93       	push	r28
    459c:	df 93       	push	r29
    459e:	cd b7       	in	r28, 0x3d	; 61
    45a0:	de b7       	in	r29, 0x3e	; 62
    45a2:	2b 97       	sbiw	r28, 0x0b	; 11
    45a4:	cd bf       	out	0x3d, r28	; 61
    45a6:	de bf       	out	0x3e, r29	; 62
    45a8:	78 2f       	mov	r23, r24
    45aa:	69 2f       	mov	r22, r25
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    45ac:	e8 2f       	mov	r30, r24
    45ae:	f9 2f       	mov	r31, r25
    45b0:	df 01       	movw	r26, r30
    45b2:	0d 90       	ld	r0, X+
    45b4:	00 20       	and	r0, r0
    45b6:	e9 f7       	brne	.-6      	; 0x45b2 <convertFileName+0x1c>
    45b8:	11 97       	sbiw	r26, 0x01	; 1
    45ba:	ae 1b       	sub	r26, r30
    45bc:	bf 0b       	sbc	r27, r31
    45be:	a0 31       	cpi	r26, 0x10	; 16
    45c0:	b1 05       	cpc	r27, r1
    45c2:	08 f0       	brcs	.+2      	; 0x45c6 <convertFileName+0x30>
    45c4:	9c c0       	rjmp	.+312    	; 0x46fe <convertFileName+0x168>
    45c6:	28 2f       	mov	r18, r24
    45c8:	39 2f       	mov	r19, r25
    45ca:	02 e9       	ldi	r16, 0x92	; 146
    45cc:	10 e5       	ldi	r17, 0x50	; 80
    45ce:	a8 01       	movw	r20, r16
    45d0:	80 e0       	ldi	r24, 0x00	; 0
    45d2:	90 e0       	ldi	r25, 0x00	; 0
    45d4:	07 c0       	rjmp	.+14     	; 0x45e4 <convertFileName+0x4e>
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
    45d6:	d9 01       	movw	r26, r18
    45d8:	ed 91       	ld	r30, X+
    45da:	9d 01       	movw	r18, r26
    45dc:	da 01       	movw	r26, r20
    45de:	ed 93       	st	X+, r30
    45e0:	ad 01       	movw	r20, r26

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    45e2:	01 96       	adiw	r24, 0x01	; 1
    45e4:	a7 2f       	mov	r26, r23
    45e6:	b6 2f       	mov	r27, r22
    45e8:	fd 01       	movw	r30, r26
    45ea:	01 90       	ld	r0, Z+
    45ec:	00 20       	and	r0, r0
    45ee:	e9 f7       	brne	.-6      	; 0x45ea <convertFileName+0x54>
    45f0:	31 97       	sbiw	r30, 0x01	; 1
    45f2:	ea 1b       	sub	r30, r26
    45f4:	fb 0b       	sbc	r31, r27
    45f6:	8e 17       	cp	r24, r30
    45f8:	9f 07       	cpc	r25, r31
    45fa:	68 f3       	brcs	.-38     	; 0x45d6 <convertFileName+0x40>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    45fc:	8f 30       	cpi	r24, 0x0F	; 15
    45fe:	91 05       	cpc	r25, r1
    4600:	54 f4       	brge	.+20     	; 0x4616 <convertFileName+0x80>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4602:	fc 01       	movw	r30, r24
    4604:	ee 56       	subi	r30, 0x6E	; 110
    4606:	ff 4a       	sbci	r31, 0xAF	; 175
    4608:	81 ea       	ldi	r24, 0xA1	; 161
    460a:	90 e5       	ldi	r25, 0x50	; 80
if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    460c:	20 e2       	ldi	r18, 0x20	; 32
    460e:	21 93       	st	Z+, r18
    4610:	e8 17       	cp	r30, r24
    4612:	f9 07       	cpc	r31, r25
    4614:	e1 f7       	brne	.-8      	; 0x460e <convertFileName+0x78>


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    4616:	80 91 92 50 	lds	r24, 0x5092
    461a:	8e 32       	cpi	r24, 0x2E	; 46
    461c:	91 f0       	breq	.+36     	; 0x4642 <convertFileName+0xac>
    461e:	e3 e9       	ldi	r30, 0x93	; 147
    4620:	f0 e5       	ldi	r31, 0x50	; 80
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    4622:	21 e0       	ldi	r18, 0x01	; 1
if(Filename[j] == '.') break;
    4624:	81 91       	ld	r24, Z+
    4626:	8e 32       	cpi	r24, 0x2E	; 46
    4628:	21 f0       	breq	.+8      	; 0x4632 <convertFileName+0x9c>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    462a:	2f 5f       	subi	r18, 0xFF	; 255
    462c:	2c 30       	cpi	r18, 0x0C	; 12
    462e:	d1 f7       	brne	.-12     	; 0x4624 <convertFileName+0x8e>
    4630:	05 c0       	rjmp	.+10     	; 0x463c <convertFileName+0xa6>
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    4632:	82 2f       	mov	r24, r18
    4634:	89 50       	subi	r24, 0x09	; 9
    4636:	83 30       	cpi	r24, 0x03	; 3
    4638:	08 f4       	brcc	.+2      	; 0x463c <convertFileName+0xa6>
    463a:	63 c0       	rjmp	.+198    	; 0x4702 <convertFileName+0x16c>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    463c:	22 23       	and	r18, r18
    463e:	29 f4       	brne	.+10     	; 0x464a <convertFileName+0xb4>
    4640:	01 c0       	rjmp	.+2      	; 0x4644 <convertFileName+0xae>
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    4642:	20 e0       	ldi	r18, 0x00	; 0
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4644:	82 2f       	mov	r24, r18

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    4646:	90 e2       	ldi	r25, 0x20	; 32
    4648:	10 c0       	rjmp	.+32     	; 0x466a <convertFileName+0xd4>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    464a:	de 01       	movw	r26, r28
    464c:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    464e:	82 2f       	mov	r24, r18
    4650:	81 50       	subi	r24, 0x01	; 1
    4652:	90 e0       	ldi	r25, 0x00	; 0
    4654:	8d 56       	subi	r24, 0x6D	; 109
    4656:	9f 4a       	sbci	r25, 0xAF	; 175
    4658:	f8 01       	movw	r30, r16
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];
    465a:	31 91       	ld	r19, Z+
    465c:	3d 93       	st	X+, r19

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    465e:	e8 17       	cp	r30, r24
    4660:	f9 07       	cpc	r31, r25
    4662:	d9 f7       	brne	.-10     	; 0x465a <convertFileName+0xc4>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4664:	28 30       	cpi	r18, 0x08	; 8
    4666:	70 f3       	brcs	.-36     	; 0x4644 <convertFileName+0xae>
    4668:	0a c0       	rjmp	.+20     	; 0x467e <convertFileName+0xe8>
  fileNameFAT[k] = ' ';
    466a:	e1 e0       	ldi	r30, 0x01	; 1
    466c:	f0 e0       	ldi	r31, 0x00	; 0
    466e:	ec 0f       	add	r30, r28
    4670:	fd 1f       	adc	r31, r29
    4672:	e8 0f       	add	r30, r24
    4674:	f1 1d       	adc	r31, r1
    4676:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4678:	8f 5f       	subi	r24, 0xFF	; 255
    467a:	88 30       	cpi	r24, 0x08	; 8
    467c:	b0 f3       	brcs	.-20     	; 0x466a <convertFileName+0xd4>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    467e:	2c 30       	cpi	r18, 0x0C	; 12
    4680:	09 f0       	breq	.+2      	; 0x4684 <convertFileName+0xee>
    4682:	2f 5f       	subi	r18, 0xFF	; 255
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4684:	38 e0       	ldi	r19, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    4686:	82 e9       	ldi	r24, 0x92	; 146
    4688:	90 e5       	ldi	r25, 0x50	; 80
    468a:	fc 01       	movw	r30, r24
    468c:	e2 0f       	add	r30, r18
    468e:	f1 1d       	adc	r31, r1
    4690:	40 81       	ld	r20, Z
    4692:	44 23       	and	r20, r20
    4694:	19 f4       	brne	.+6      	; 0x469c <convertFileName+0x106>
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    4696:	3b 30       	cpi	r19, 0x0B	; 11
    4698:	50 f0       	brcs	.+20     	; 0x46ae <convertFileName+0x118>
    469a:	15 c0       	rjmp	.+42     	; 0x46c6 <convertFileName+0x130>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
    469c:	e1 e0       	ldi	r30, 0x01	; 1
    469e:	f0 e0       	ldi	r31, 0x00	; 0
    46a0:	ec 0f       	add	r30, r28
    46a2:	fd 1f       	adc	r31, r29
    46a4:	e3 0f       	add	r30, r19
    46a6:	f1 1d       	adc	r31, r1
    46a8:	40 83       	st	Z, r20
    46aa:	2f 5f       	subi	r18, 0xFF	; 255
    46ac:	0c c0       	rjmp	.+24     	; 0x46c6 <convertFileName+0x130>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    46ae:	80 e2       	ldi	r24, 0x20	; 32
    46b0:	e1 e0       	ldi	r30, 0x01	; 1
    46b2:	f0 e0       	ldi	r31, 0x00	; 0
    46b4:	ec 0f       	add	r30, r28
    46b6:	fd 1f       	adc	r31, r29
    46b8:	e3 0f       	add	r30, r19
    46ba:	f1 1d       	adc	r31, r1
    46bc:	80 83       	st	Z, r24
    46be:	3f 5f       	subi	r19, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    46c0:	3b 30       	cpi	r19, 0x0B	; 11
    46c2:	b1 f7       	brne	.-20     	; 0x46b0 <convertFileName+0x11a>
    46c4:	03 c0       	rjmp	.+6      	; 0x46cc <convertFileName+0x136>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    46c6:	3f 5f       	subi	r19, 0xFF	; 255
    46c8:	3b 30       	cpi	r19, 0x0B	; 11
    46ca:	f8 f2       	brcs	.-66     	; 0x468a <convertFileName+0xf4>
    46cc:	de 01       	movw	r26, r28
    46ce:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    46d0:	ce 01       	movw	r24, r28
    46d2:	0c 96       	adiw	r24, 0x0c	; 12
    46d4:	fd 01       	movw	r30, r26
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    46d6:	20 81       	ld	r18, Z
    46d8:	32 2f       	mov	r19, r18
    46da:	31 56       	subi	r19, 0x61	; 97
    46dc:	3a 31       	cpi	r19, 0x1A	; 26
    46de:	10 f4       	brcc	.+4      	; 0x46e4 <convertFileName+0x14e>
    fileNameFAT[j] -= 0x20;
    46e0:	20 52       	subi	r18, 0x20	; 32
    46e2:	20 83       	st	Z, r18
    46e4:	31 96       	adiw	r30, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    46e6:	e8 17       	cp	r30, r24
    46e8:	f9 07       	cpc	r31, r25
    46ea:	a9 f7       	brne	.-22     	; 0x46d6 <convertFileName+0x140>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];
    46ec:	2d 91       	ld	r18, X+
    46ee:	f8 01       	movw	r30, r16
    46f0:	21 93       	st	Z+, r18
    46f2:	8f 01       	movw	r16, r30

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    46f4:	a8 17       	cp	r26, r24
    46f6:	b9 07       	cpc	r27, r25
    46f8:	c9 f7       	brne	.-14     	; 0x46ec <convertFileName+0x156>
  Filename[j] = fileNameFAT[j];

return 0;
    46fa:	80 e0       	ldi	r24, 0x00	; 0
    46fc:	03 c0       	rjmp	.+6      	; 0x4704 <convertFileName+0x16e>
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    46fe:	81 e0       	ldi	r24, 0x01	; 1
    4700:	01 c0       	rjmp	.+2      	; 0x4704 <convertFileName+0x16e>

for(j=0; j<12; j++)
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    4702:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];

return 0;
}
    4704:	2b 96       	adiw	r28, 0x0b	; 11
    4706:	cd bf       	out	0x3d, r28	; 61
    4708:	de bf       	out	0x3e, r29	; 62
    470a:	df 91       	pop	r29
    470c:	cf 91       	pop	r28
    470e:	1f 91       	pop	r17
    4710:	0f 91       	pop	r16
    4712:	08 95       	ret

00004714 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    4714:	4f 92       	push	r4
    4716:	5f 92       	push	r5
    4718:	6f 92       	push	r6
    471a:	7f 92       	push	r7
    471c:	8f 92       	push	r8
    471e:	9f 92       	push	r9
    4720:	af 92       	push	r10
    4722:	bf 92       	push	r11
    4724:	cf 92       	push	r12
    4726:	df 92       	push	r13
    4728:	ef 92       	push	r14
    472a:	ff 92       	push	r15
    472c:	cf 93       	push	r28
    472e:	df 93       	push	r29
    4730:	2b 01       	movw	r4, r22
    4732:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    4734:	20 e8       	ldi	r18, 0x80	; 128
    4736:	3f ef       	ldi	r19, 0xFF	; 255
    4738:	4f ef       	ldi	r20, 0xFF	; 255
    473a:	5f ef       	ldi	r21, 0xFF	; 255
    473c:	42 22       	and	r4, r18
    473e:	53 22       	and	r5, r19
    4740:	64 22       	and	r6, r20
    4742:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    4744:	80 91 59 40 	lds	r24, 0x4059
    4748:	90 91 5a 40 	lds	r25, 0x405A
    474c:	a0 91 5b 40 	lds	r26, 0x405B
    4750:	b0 91 5c 40 	lds	r27, 0x405C
    4754:	48 16       	cp	r4, r24
    4756:	59 06       	cpc	r5, r25
    4758:	6a 06       	cpc	r6, r26
    475a:	7b 06       	cpc	r7, r27
    475c:	08 f0       	brcs	.+2      	; 0x4760 <searchNextFreeCluster+0x4c>
    475e:	77 c0       	rjmp	.+238    	; 0x484e <searchNextFreeCluster+0x13a>
    4760:	53 01       	movw	r10, r6
    4762:	42 01       	movw	r8, r4
    4764:	88 0c       	add	r8, r8
    4766:	99 1c       	adc	r9, r9
    4768:	aa 1c       	adc	r10, r10
    476a:	bb 1c       	adc	r11, r11
    476c:	88 0c       	add	r8, r8
    476e:	99 1c       	adc	r9, r9
    4770:	aa 1c       	adc	r10, r10
    4772:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    4774:	c9 e4       	ldi	r28, 0x49	; 73
    4776:	de e3       	ldi	r29, 0x3E	; 62
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    4778:	c0 90 70 50 	lds	r12, 0x5070
    477c:	d0 90 71 50 	lds	r13, 0x5071
    4780:	20 91 56 40 	lds	r18, 0x4056
    4784:	30 91 57 40 	lds	r19, 0x4057
    4788:	ee 24       	eor	r14, r14
    478a:	ff 24       	eor	r15, r15
    478c:	80 91 6c 50 	lds	r24, 0x506C
    4790:	90 91 6d 50 	lds	r25, 0x506D
    4794:	a0 91 6e 50 	lds	r26, 0x506E
    4798:	b0 91 6f 50 	lds	r27, 0x506F
    479c:	c8 0e       	add	r12, r24
    479e:	d9 1e       	adc	r13, r25
    47a0:	ea 1e       	adc	r14, r26
    47a2:	fb 1e       	adc	r15, r27
    47a4:	40 e0       	ldi	r20, 0x00	; 0
    47a6:	50 e0       	ldi	r21, 0x00	; 0
    47a8:	c5 01       	movw	r24, r10
    47aa:	b4 01       	movw	r22, r8
    47ac:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    47b0:	c7 01       	movw	r24, r14
    47b2:	b6 01       	movw	r22, r12
    47b4:	62 0f       	add	r22, r18
    47b6:	73 1f       	adc	r23, r19
    47b8:	84 1f       	adc	r24, r20
    47ba:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    47bc:	ae 01       	movw	r20, r28
    47be:	0e 94 8b 2b 	call	0x5716	; 0x5716 <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    47c2:	88 81       	ld	r24, Y
    47c4:	99 81       	ldd	r25, Y+1	; 0x01
    47c6:	aa 81       	ldd	r26, Y+2	; 0x02
    47c8:	bb 81       	ldd	r27, Y+3	; 0x03
    47ca:	bf 70       	andi	r27, 0x0F	; 15
    47cc:	00 97       	sbiw	r24, 0x00	; 0
    47ce:	a1 05       	cpc	r26, r1
    47d0:	b1 05       	cpc	r27, r1
    47d2:	99 f0       	breq	.+38     	; 0x47fa <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    47d4:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    47d6:	e2 2f       	mov	r30, r18
    47d8:	f0 e0       	ldi	r31, 0x00	; 0
    47da:	ee 0f       	add	r30, r30
    47dc:	ff 1f       	adc	r31, r31
    47de:	ee 0f       	add	r30, r30
    47e0:	ff 1f       	adc	r31, r31
         if(((*value) & 0x0fffffff) == 0)
    47e2:	e7 5b       	subi	r30, 0xB7	; 183
    47e4:	f1 4c       	sbci	r31, 0xC1	; 193
    47e6:	80 81       	ld	r24, Z
    47e8:	91 81       	ldd	r25, Z+1	; 0x01
    47ea:	a2 81       	ldd	r26, Z+2	; 0x02
    47ec:	b3 81       	ldd	r27, Z+3	; 0x03
    47ee:	bf 70       	andi	r27, 0x0F	; 15
    47f0:	00 97       	sbiw	r24, 0x00	; 0
    47f2:	a1 05       	cpc	r26, r1
    47f4:	b1 05       	cpc	r27, r1
    47f6:	39 f4       	brne	.+14     	; 0x4806 <searchNextFreeCluster+0xf2>
    47f8:	01 c0       	rjmp	.+2      	; 0x47fc <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    47fa:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    47fc:	42 0e       	add	r4, r18
    47fe:	51 1c       	adc	r5, r1
    4800:	61 1c       	adc	r6, r1
    4802:	71 1c       	adc	r7, r1
    4804:	27 c0       	rjmp	.+78     	; 0x4854 <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4806:	2f 5f       	subi	r18, 0xFF	; 255
    4808:	32 f7       	brpl	.-52     	; 0x47d6 <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    480a:	80 e8       	ldi	r24, 0x80	; 128
    480c:	90 e0       	ldi	r25, 0x00	; 0
    480e:	a0 e0       	ldi	r26, 0x00	; 0
    4810:	b0 e0       	ldi	r27, 0x00	; 0
    4812:	48 0e       	add	r4, r24
    4814:	59 1e       	adc	r5, r25
    4816:	6a 1e       	adc	r6, r26
    4818:	7b 1e       	adc	r7, r27
    481a:	80 91 59 40 	lds	r24, 0x4059
    481e:	90 91 5a 40 	lds	r25, 0x405A
    4822:	a0 91 5b 40 	lds	r26, 0x405B
    4826:	b0 91 5c 40 	lds	r27, 0x405C
    482a:	20 e0       	ldi	r18, 0x00	; 0
    482c:	32 e0       	ldi	r19, 0x02	; 2
    482e:	40 e0       	ldi	r20, 0x00	; 0
    4830:	50 e0       	ldi	r21, 0x00	; 0
    4832:	82 0e       	add	r8, r18
    4834:	93 1e       	adc	r9, r19
    4836:	a4 1e       	adc	r10, r20
    4838:	b5 1e       	adc	r11, r21
    483a:	48 16       	cp	r4, r24
    483c:	59 06       	cpc	r5, r25
    483e:	6a 06       	cpc	r6, r26
    4840:	7b 06       	cpc	r7, r27
    4842:	08 f4       	brcc	.+2      	; 0x4846 <searchNextFreeCluster+0x132>
    4844:	99 cf       	rjmp	.-206    	; 0x4778 <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    4846:	44 24       	eor	r4, r4
    4848:	55 24       	eor	r5, r5
    484a:	32 01       	movw	r6, r4
    484c:	03 c0       	rjmp	.+6      	; 0x4854 <searchNextFreeCluster+0x140>
    484e:	44 24       	eor	r4, r4
    4850:	55 24       	eor	r5, r5
    4852:	32 01       	movw	r6, r4
}
    4854:	64 2d       	mov	r22, r4
    4856:	75 2d       	mov	r23, r5
    4858:	86 2d       	mov	r24, r6
    485a:	97 2d       	mov	r25, r7
    485c:	df 91       	pop	r29
    485e:	cf 91       	pop	r28
    4860:	ff 90       	pop	r15
    4862:	ef 90       	pop	r14
    4864:	df 90       	pop	r13
    4866:	cf 90       	pop	r12
    4868:	bf 90       	pop	r11
    486a:	af 90       	pop	r10
    486c:	9f 90       	pop	r9
    486e:	8f 90       	pop	r8
    4870:	7f 90       	pop	r7
    4872:	6f 90       	pop	r6
    4874:	5f 90       	pop	r5
    4876:	4f 90       	pop	r4
    4878:	08 95       	ret

0000487a <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    487a:	cf 92       	push	r12
    487c:	df 92       	push	r13
    487e:	ef 92       	push	r14
    4880:	ff 92       	push	r15
    4882:	cf 93       	push	r28
    4884:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    4886:	db 01       	movw	r26, r22
    4888:	ca 01       	movw	r24, r20
    488a:	91 70       	andi	r25, 0x01	; 1
    488c:	a0 70       	andi	r26, 0x00	; 0
    488e:	b0 70       	andi	r27, 0x00	; 0
    4890:	00 97       	sbiw	r24, 0x00	; 0
    4892:	a1 05       	cpc	r26, r1
    4894:	b1 05       	cpc	r27, r1
    4896:	51 f4       	brne	.+20     	; 0x48ac <freeMemoryUpdate+0x32>
    4898:	03 2e       	mov	r0, r19
    489a:	39 e0       	ldi	r19, 0x09	; 9
    489c:	76 95       	lsr	r23
    489e:	67 95       	ror	r22
    48a0:	57 95       	ror	r21
    48a2:	47 95       	ror	r20
    48a4:	3a 95       	dec	r19
    48a6:	d1 f7       	brne	.-12     	; 0x489c <freeMemoryUpdate+0x22>
    48a8:	30 2d       	mov	r19, r0
    48aa:	0d c0       	rjmp	.+26     	; 0x48c6 <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    48ac:	03 2e       	mov	r0, r19
    48ae:	39 e0       	ldi	r19, 0x09	; 9
    48b0:	76 95       	lsr	r23
    48b2:	67 95       	ror	r22
    48b4:	57 95       	ror	r21
    48b6:	47 95       	ror	r20
    48b8:	3a 95       	dec	r19
    48ba:	d1 f7       	brne	.-12     	; 0x48b0 <freeMemoryUpdate+0x36>
    48bc:	30 2d       	mov	r19, r0
    48be:	4f 5f       	subi	r20, 0xFF	; 255
    48c0:	5f 4f       	sbci	r21, 0xFF	; 255
    48c2:	6f 4f       	sbci	r22, 0xFF	; 255
    48c4:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    48c6:	db 01       	movw	r26, r22
    48c8:	ca 01       	movw	r24, r20
    48ca:	87 70       	andi	r24, 0x07	; 7
    48cc:	90 70       	andi	r25, 0x00	; 0
    48ce:	a0 70       	andi	r26, 0x00	; 0
    48d0:	b0 70       	andi	r27, 0x00	; 0
    48d2:	00 97       	sbiw	r24, 0x00	; 0
    48d4:	a1 05       	cpc	r26, r1
    48d6:	b1 05       	cpc	r27, r1
    48d8:	59 f4       	brne	.+22     	; 0x48f0 <freeMemoryUpdate+0x76>
    48da:	6a 01       	movw	r12, r20
    48dc:	7b 01       	movw	r14, r22
    48de:	68 94       	set
    48e0:	12 f8       	bld	r1, 2
    48e2:	f6 94       	lsr	r15
    48e4:	e7 94       	ror	r14
    48e6:	d7 94       	ror	r13
    48e8:	c7 94       	ror	r12
    48ea:	16 94       	lsr	r1
    48ec:	d1 f7       	brne	.-12     	; 0x48e2 <freeMemoryUpdate+0x68>
    48ee:	0f c0       	rjmp	.+30     	; 0x490e <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    48f0:	6a 01       	movw	r12, r20
    48f2:	7b 01       	movw	r14, r22
    48f4:	68 94       	set
    48f6:	12 f8       	bld	r1, 2
    48f8:	f6 94       	lsr	r15
    48fa:	e7 94       	ror	r14
    48fc:	d7 94       	ror	r13
    48fe:	c7 94       	ror	r12
    4900:	16 94       	lsr	r1
    4902:	d1 f7       	brne	.-12     	; 0x48f8 <freeMemoryUpdate+0x7e>
    4904:	08 94       	sec
    4906:	c1 1c       	adc	r12, r1
    4908:	d1 1c       	adc	r13, r1
    490a:	e1 1c       	adc	r14, r1
    490c:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    490e:	80 91 a2 50 	lds	r24, 0x50A2
    4912:	88 23       	and	r24, r24
    4914:	d1 f0       	breq	.+52     	; 0x494a <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    4916:	81 e0       	ldi	r24, 0x01	; 1
    4918:	60 e0       	ldi	r22, 0x00	; 0
    491a:	20 e0       	ldi	r18, 0x00	; 0
    491c:	30 e0       	ldi	r19, 0x00	; 0
    491e:	a9 01       	movw	r20, r18
    4920:	0e 94 3e 21 	call	0x427c	; 0x427c <getSetFreeCluster>
	if(flag == ADD)
    4924:	cc 23       	and	r28, r28
    4926:	39 f4       	brne	.+14     	; 0x4936 <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    4928:	9b 01       	movw	r18, r22
    492a:	ac 01       	movw	r20, r24
    492c:	2c 0d       	add	r18, r12
    492e:	3d 1d       	adc	r19, r13
    4930:	4e 1d       	adc	r20, r14
    4932:	5f 1d       	adc	r21, r15
    4934:	06 c0       	rjmp	.+12     	; 0x4942 <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    4936:	9b 01       	movw	r18, r22
    4938:	ac 01       	movw	r20, r24
    493a:	2c 19       	sub	r18, r12
    493c:	3d 09       	sbc	r19, r13
    493e:	4e 09       	sbc	r20, r14
    4940:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    4942:	81 e0       	ldi	r24, 0x01	; 1
    4944:	61 e0       	ldi	r22, 0x01	; 1
    4946:	0e 94 3e 21 	call	0x427c	; 0x427c <getSetFreeCluster>
  }
}
    494a:	cf 91       	pop	r28
    494c:	ff 90       	pop	r15
    494e:	ef 90       	pop	r14
    4950:	df 90       	pop	r13
    4952:	cf 90       	pop	r12
    4954:	08 95       	ret

00004956 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    4956:	2f 92       	push	r2
    4958:	3f 92       	push	r3
    495a:	4f 92       	push	r4
    495c:	5f 92       	push	r5
    495e:	6f 92       	push	r6
    4960:	7f 92       	push	r7
    4962:	8f 92       	push	r8
    4964:	9f 92       	push	r9
    4966:	af 92       	push	r10
    4968:	bf 92       	push	r11
    496a:	cf 92       	push	r12
    496c:	df 92       	push	r13
    496e:	ef 92       	push	r14
    4970:	ff 92       	push	r15
    4972:	0f 93       	push	r16
    4974:	1f 93       	push	r17
    4976:	cf 93       	push	r28
    4978:	df 93       	push	r29
    497a:	cd b7       	in	r28, 0x3d	; 61
    497c:	de b7       	in	r29, 0x3e	; 62
    497e:	2c 97       	sbiw	r28, 0x0c	; 12
    4980:	cd bf       	out	0x3d, r28	; 61
    4982:	de bf       	out	0x3e, r29	; 62
    4984:	88 2e       	mov	r8, r24
    4986:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    4988:	80 91 5e 40 	lds	r24, 0x405E
    498c:	90 91 5f 40 	lds	r25, 0x405F
    4990:	a0 91 60 40 	lds	r26, 0x4060
    4994:	b0 91 61 40 	lds	r27, 0x4061
    4998:	89 87       	std	Y+9, r24	; 0x09
    499a:	9a 87       	std	Y+10, r25	; 0x0a
    499c:	ab 87       	std	Y+11, r26	; 0x0b
    499e:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    49a0:	0f 2e       	mov	r0, r31
    49a2:	f9 e4       	ldi	r31, 0x49	; 73
    49a4:	2f 2e       	mov	r2, r31
    49a6:	fe e3       	ldi	r31, 0x3E	; 62
    49a8:	3f 2e       	mov	r3, r31
    49aa:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    49ac:	c8 2c       	mov	r12, r8
    49ae:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    49b0:	d2 2c       	mov	r13, r2
    49b2:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    49b4:	5b 01       	movw	r10, r22
    49b6:	08 94       	sec
    49b8:	a1 1c       	adc	r10, r1
    49ba:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    49bc:	69 85       	ldd	r22, Y+9	; 0x09
    49be:	7a 85       	ldd	r23, Y+10	; 0x0a
    49c0:	8b 85       	ldd	r24, Y+11	; 0x0b
    49c2:	9c 85       	ldd	r25, Y+12	; 0x0c
    49c4:	0e 94 85 20 	call	0x410a	; 0x410a <getFirstSector>
    49c8:	6d 83       	std	Y+5, r22	; 0x05
    49ca:	7e 83       	std	Y+6, r23	; 0x06
    49cc:	8f 83       	std	Y+7, r24	; 0x07
    49ce:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    49d0:	80 91 6a 50 	lds	r24, 0x506A
    49d4:	90 91 6b 50 	lds	r25, 0x506B
    49d8:	00 97       	sbiw	r24, 0x00	; 0
    49da:	09 f4       	brne	.+2      	; 0x49de <findFiles+0x88>
    49dc:	13 c1       	rjmp	.+550    	; 0x4c04 <findFiles+0x2ae>
    49de:	44 24       	eor	r4, r4
    49e0:	55 24       	eor	r5, r5
    49e2:	32 01       	movw	r6, r4
    49e4:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    49e6:	8d 81       	ldd	r24, Y+5	; 0x05
    49e8:	9e 81       	ldd	r25, Y+6	; 0x06
    49ea:	af 81       	ldd	r26, Y+7	; 0x07
    49ec:	b8 85       	ldd	r27, Y+8	; 0x08
    49ee:	84 0d       	add	r24, r4
    49f0:	95 1d       	adc	r25, r5
    49f2:	a6 1d       	adc	r26, r6
    49f4:	b7 1d       	adc	r27, r7
    49f6:	89 83       	std	Y+1, r24	; 0x01
    49f8:	9a 83       	std	Y+2, r25	; 0x02
    49fa:	ab 83       	std	Y+3, r26	; 0x03
    49fc:	bc 83       	std	Y+4, r27	; 0x04
    49fe:	bc 01       	movw	r22, r24
    4a00:	cd 01       	movw	r24, r26
    4a02:	4d 2d       	mov	r20, r13
    4a04:	59 2d       	mov	r21, r9
    4a06:	0e 94 8b 2b 	call	0x5716	; 0x5716 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    4a0a:	80 91 56 40 	lds	r24, 0x4056
    4a0e:	90 91 57 40 	lds	r25, 0x4057
    4a12:	00 97       	sbiw	r24, 0x00	; 0
    4a14:	09 f4       	brne	.+2      	; 0x4a18 <findFiles+0xc2>
    4a16:	e4 c0       	rjmp	.+456    	; 0x4be0 <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4a18:	d1 01       	movw	r26, r2
    4a1a:	8c 91       	ld	r24, X
    4a1c:	88 23       	and	r24, r24
    4a1e:	09 f4       	brne	.+2      	; 0x4a22 <findFiles+0xcc>
    4a20:	10 c1       	rjmp	.+544    	; 0x4c42 <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4a22:	4d 2d       	mov	r20, r13
    4a24:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4a26:	20 e0       	ldi	r18, 0x00	; 0
    4a28:	30 e0       	ldi	r19, 0x00	; 0
    4a2a:	08 c0       	rjmp	.+16     	; 0x4a3c <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4a2c:	a9 01       	movw	r20, r18
    4a2e:	47 5b       	subi	r20, 0xB7	; 183
    4a30:	51 4c       	sbci	r21, 0xC1	; 193

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4a32:	fa 01       	movw	r30, r20
    4a34:	80 81       	ld	r24, Z
    4a36:	88 23       	and	r24, r24
    4a38:	09 f4       	brne	.+2      	; 0x4a3c <findFiles+0xe6>
    4a3a:	06 c1       	rjmp	.+524    	; 0x4c48 <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    4a3c:	85 3e       	cpi	r24, 0xE5	; 229
    4a3e:	09 f4       	brne	.+2      	; 0x4a42 <findFiles+0xec>
    4a40:	c5 c0       	rjmp	.+394    	; 0x4bcc <findFiles+0x276>
    4a42:	da 01       	movw	r26, r20
    4a44:	1b 96       	adiw	r26, 0x0b	; 11
    4a46:	8c 91       	ld	r24, X
    4a48:	1b 97       	sbiw	r26, 0x0b	; 11
    4a4a:	8f 30       	cpi	r24, 0x0F	; 15
    4a4c:	09 f4       	brne	.+2      	; 0x4a50 <findFiles+0xfa>
    4a4e:	be c0       	rjmp	.+380    	; 0x4bcc <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4a50:	12 30       	cpi	r17, 0x02	; 2
    4a52:	08 f0       	brcs	.+2      	; 0x4a56 <findFiles+0x100>
    4a54:	fc c0       	rjmp	.+504    	; 0x4c4e <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    4a56:	9c 91       	ld	r25, X
    4a58:	f7 01       	movw	r30, r14
    4a5a:	80 81       	ld	r24, Z
    4a5c:	98 17       	cp	r25, r24
    4a5e:	09 f0       	breq	.+2      	; 0x4a62 <findFiles+0x10c>
    4a60:	b5 c0       	rjmp	.+362    	; 0x4bcc <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4a62:	fa 01       	movw	r30, r20
    4a64:	31 96       	adiw	r30, 0x01	; 1
    4a66:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4a68:	81 e0       	ldi	r24, 0x01	; 1
    4a6a:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    4a6c:	41 91       	ld	r20, Z+
    4a6e:	9d 91       	ld	r25, X+
    4a70:	49 17       	cp	r20, r25
    4a72:	31 f4       	brne	.+12     	; 0x4a80 <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4a74:	8f 5f       	subi	r24, 0xFF	; 255
    4a76:	8b 30       	cpi	r24, 0x0B	; 11
    4a78:	c9 f7       	brne	.-14     	; 0x4a6c <findFiles+0x116>
    4a7a:	8b 01       	movw	r16, r22
    4a7c:	6b 01       	movw	r12, r22
    4a7e:	05 c0       	rjmp	.+10     	; 0x4a8a <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    4a80:	8b 30       	cpi	r24, 0x0B	; 11
    4a82:	09 f0       	breq	.+2      	; 0x4a86 <findFiles+0x130>
    4a84:	a3 c0       	rjmp	.+326    	; 0x4bcc <findFiles+0x276>
    4a86:	8b 01       	movw	r16, r22
    4a88:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    4a8a:	f1 e0       	ldi	r31, 0x01	; 1
    4a8c:	8f 16       	cp	r8, r31
    4a8e:	09 f0       	breq	.+2      	; 0x4a92 <findFiles+0x13c>
    4a90:	41 c0       	rjmp	.+130    	; 0x4b14 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    4a92:	89 81       	ldd	r24, Y+1	; 0x01
    4a94:	9a 81       	ldd	r25, Y+2	; 0x02
    4a96:	ab 81       	ldd	r26, Y+3	; 0x03
    4a98:	bc 81       	ldd	r27, Y+4	; 0x04
    4a9a:	80 93 a3 50 	sts	0x50A3, r24
    4a9e:	90 93 a4 50 	sts	0x50A4, r25
    4aa2:	a0 93 a5 50 	sts	0x50A5, r26
    4aa6:	b0 93 a6 50 	sts	0x50A6, r27
				appendFileLocation = i;
    4aaa:	c9 01       	movw	r24, r18
    4aac:	a0 e0       	ldi	r26, 0x00	; 0
    4aae:	b0 e0       	ldi	r27, 0x00	; 0
    4ab0:	80 93 4a 40 	sts	0x404A, r24
    4ab4:	90 93 4b 40 	sts	0x404B, r25
    4ab8:	a0 93 4c 40 	sts	0x404C, r26
    4abc:	b0 93 4d 40 	sts	0x404D, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4ac0:	d6 01       	movw	r26, r12
    4ac2:	54 96       	adiw	r26, 0x14	; 20
    4ac4:	4d 91       	ld	r20, X+
    4ac6:	5c 91       	ld	r21, X
    4ac8:	55 97       	sbiw	r26, 0x15	; 21
    4aca:	60 e0       	ldi	r22, 0x00	; 0
    4acc:	70 e0       	ldi	r23, 0x00	; 0
    4ace:	ba 01       	movw	r22, r20
    4ad0:	55 27       	eor	r21, r21
    4ad2:	44 27       	eor	r20, r20
    4ad4:	5a 96       	adiw	r26, 0x1a	; 26
    4ad6:	8d 91       	ld	r24, X+
    4ad8:	9c 91       	ld	r25, X
    4ada:	5b 97       	sbiw	r26, 0x1b	; 27
    4adc:	a0 e0       	ldi	r26, 0x00	; 0
    4ade:	b0 e0       	ldi	r27, 0x00	; 0
    4ae0:	84 2b       	or	r24, r20
    4ae2:	95 2b       	or	r25, r21
    4ae4:	a6 2b       	or	r26, r22
    4ae6:	b7 2b       	or	r27, r23
    4ae8:	80 93 74 50 	sts	0x5074, r24
    4aec:	90 93 75 50 	sts	0x5075, r25
    4af0:	a0 93 76 50 	sts	0x5076, r26
    4af4:	b0 93 77 50 	sts	0x5077, r27
				fileSize = dir->fileSize;
    4af8:	f6 01       	movw	r30, r12
    4afa:	84 8d       	ldd	r24, Z+28	; 0x1c
    4afc:	95 8d       	ldd	r25, Z+29	; 0x1d
    4afe:	a6 8d       	ldd	r26, Z+30	; 0x1e
    4b00:	b7 8d       	ldd	r27, Z+31	; 0x1f
    4b02:	80 93 52 40 	sts	0x4052, r24
    4b06:	90 93 53 40 	sts	0x4053, r25
    4b0a:	a0 93 54 40 	sts	0x4054, r26
    4b0e:	b0 93 55 40 	sts	0x4055, r27
			    return (dir);
    4b12:	a5 c0       	rjmp	.+330    	; 0x4c5e <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4b14:	d6 01       	movw	r26, r12
    4b16:	54 96       	adiw	r26, 0x14	; 20
    4b18:	8d 91       	ld	r24, X+
    4b1a:	9c 91       	ld	r25, X
    4b1c:	55 97       	sbiw	r26, 0x15	; 21
    4b1e:	a0 e0       	ldi	r26, 0x00	; 0
    4b20:	b0 e0       	ldi	r27, 0x00	; 0
    4b22:	3c 01       	movw	r6, r24
    4b24:	55 24       	eor	r5, r5
    4b26:	44 24       	eor	r4, r4
    4b28:	f6 01       	movw	r30, r12
    4b2a:	82 8d       	ldd	r24, Z+26	; 0x1a
    4b2c:	93 8d       	ldd	r25, Z+27	; 0x1b
    4b2e:	a0 e0       	ldi	r26, 0x00	; 0
    4b30:	b0 e0       	ldi	r27, 0x00	; 0
    4b32:	48 2a       	or	r4, r24
    4b34:	59 2a       	or	r5, r25
    4b36:	6a 2a       	or	r6, r26
    4b38:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    4b3a:	85 ee       	ldi	r24, 0xE5	; 229
    4b3c:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    4b3e:	69 81       	ldd	r22, Y+1	; 0x01
    4b40:	7a 81       	ldd	r23, Y+2	; 0x02
    4b42:	8b 81       	ldd	r24, Y+3	; 0x03
    4b44:	9c 81       	ldd	r25, Y+4	; 0x04
    4b46:	49 e4       	ldi	r20, 0x49	; 73
    4b48:	5e e3       	ldi	r21, 0x3E	; 62
    4b4a:	20 e0       	ldi	r18, 0x00	; 0
    4b4c:	32 e0       	ldi	r19, 0x02	; 2
    4b4e:	0e 94 d6 2a 	call	0x55ac	; 0x55ac <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    4b52:	d6 01       	movw	r26, r12
    4b54:	5c 96       	adiw	r26, 0x1c	; 28
    4b56:	4d 91       	ld	r20, X+
    4b58:	5d 91       	ld	r21, X+
    4b5a:	6d 91       	ld	r22, X+
    4b5c:	7c 91       	ld	r23, X
    4b5e:	5f 97       	sbiw	r26, 0x1f	; 31
    4b60:	80 e0       	ldi	r24, 0x00	; 0
    4b62:	0e 94 3d 24 	call	0x487a	; 0x487a <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    4b66:	82 e0       	ldi	r24, 0x02	; 2
    4b68:	60 e0       	ldi	r22, 0x00	; 0
    4b6a:	20 e0       	ldi	r18, 0x00	; 0
    4b6c:	30 e0       	ldi	r19, 0x00	; 0
    4b6e:	a9 01       	movw	r20, r18
    4b70:	0e 94 3e 21 	call	0x427c	; 0x427c <getSetFreeCluster>
    4b74:	dc 01       	movw	r26, r24
    4b76:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    4b78:	48 16       	cp	r4, r24
    4b7a:	59 06       	cpc	r5, r25
    4b7c:	6a 06       	cpc	r6, r26
    4b7e:	7b 06       	cpc	r7, r27
    4b80:	30 f4       	brcc	.+12     	; 0x4b8e <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    4b82:	82 e0       	ldi	r24, 0x02	; 2
    4b84:	61 e0       	ldi	r22, 0x01	; 1
    4b86:	a3 01       	movw	r20, r6
    4b88:	92 01       	movw	r18, r4
    4b8a:	0e 94 3e 21 	call	0x427c	; 0x427c <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    4b8e:	c3 01       	movw	r24, r6
    4b90:	b2 01       	movw	r22, r4
    4b92:	40 e0       	ldi	r20, 0x00	; 0
    4b94:	00 e0       	ldi	r16, 0x00	; 0
    4b96:	10 e0       	ldi	r17, 0x00	; 0
    4b98:	98 01       	movw	r18, r16
    4b9a:	0e 94 ac 20 	call	0x4158	; 0x4158 <getSetNextCluster>
    4b9e:	6b 01       	movw	r12, r22
    4ba0:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    4ba2:	c3 01       	movw	r24, r6
    4ba4:	b2 01       	movw	r22, r4
    4ba6:	41 e0       	ldi	r20, 0x01	; 1
    4ba8:	00 e0       	ldi	r16, 0x00	; 0
    4baa:	10 e0       	ldi	r17, 0x00	; 0
    4bac:	98 01       	movw	r18, r16
    4bae:	0e 94 ac 20 	call	0x4158	; 0x4158 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    4bb2:	b7 ef       	ldi	r27, 0xF7	; 247
    4bb4:	cb 16       	cp	r12, r27
    4bb6:	bf ef       	ldi	r27, 0xFF	; 255
    4bb8:	db 06       	cpc	r13, r27
    4bba:	bf ef       	ldi	r27, 0xFF	; 255
    4bbc:	eb 06       	cpc	r14, r27
    4bbe:	bf e0       	ldi	r27, 0x0F	; 15
    4bc0:	fb 06       	cpc	r15, r27
    4bc2:	08 f0       	brcs	.+2      	; 0x4bc6 <findFiles+0x270>
    4bc4:	47 c0       	rjmp	.+142    	; 0x4c54 <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    4bc6:	26 01       	movw	r4, r12
    4bc8:	37 01       	movw	r6, r14
    4bca:	e1 cf       	rjmp	.-62     	; 0x4b8e <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4bcc:	20 5e       	subi	r18, 0xE0	; 224
    4bce:	3f 4f       	sbci	r19, 0xFF	; 255
    4bd0:	80 91 56 40 	lds	r24, 0x4056
    4bd4:	90 91 57 40 	lds	r25, 0x4057
    4bd8:	28 17       	cp	r18, r24
    4bda:	39 07       	cpc	r19, r25
    4bdc:	08 f4       	brcc	.+2      	; 0x4be0 <findFiles+0x28a>
    4bde:	26 cf       	rjmp	.-436    	; 0x4a2c <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    4be0:	08 94       	sec
    4be2:	41 1c       	adc	r4, r1
    4be4:	51 1c       	adc	r5, r1
    4be6:	61 1c       	adc	r6, r1
    4be8:	71 1c       	adc	r7, r1
    4bea:	80 91 6a 50 	lds	r24, 0x506A
    4bee:	90 91 6b 50 	lds	r25, 0x506B
    4bf2:	a0 e0       	ldi	r26, 0x00	; 0
    4bf4:	b0 e0       	ldi	r27, 0x00	; 0
    4bf6:	48 16       	cp	r4, r24
    4bf8:	59 06       	cpc	r5, r25
    4bfa:	6a 06       	cpc	r6, r26
    4bfc:	7b 06       	cpc	r7, r27
    4bfe:	08 f4       	brcc	.+2      	; 0x4c02 <findFiles+0x2ac>
    4c00:	f2 ce       	rjmp	.-540    	; 0x49e6 <findFiles+0x90>
    4c02:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    4c04:	69 85       	ldd	r22, Y+9	; 0x09
    4c06:	7a 85       	ldd	r23, Y+10	; 0x0a
    4c08:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c0a:	9c 85       	ldd	r25, Y+12	; 0x0c
    4c0c:	40 e0       	ldi	r20, 0x00	; 0
    4c0e:	00 e0       	ldi	r16, 0x00	; 0
    4c10:	10 e0       	ldi	r17, 0x00	; 0
    4c12:	98 01       	movw	r18, r16
    4c14:	0e 94 ac 20 	call	0x4158	; 0x4158 <getSetNextCluster>
    4c18:	69 87       	std	Y+9, r22	; 0x09
    4c1a:	7a 87       	std	Y+10, r23	; 0x0a
    4c1c:	8b 87       	std	Y+11, r24	; 0x0b
    4c1e:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    4c20:	67 3f       	cpi	r22, 0xF7	; 247
    4c22:	ef ef       	ldi	r30, 0xFF	; 255
    4c24:	7e 07       	cpc	r23, r30
    4c26:	ef ef       	ldi	r30, 0xFF	; 255
    4c28:	8e 07       	cpc	r24, r30
    4c2a:	ef e0       	ldi	r30, 0x0F	; 15
    4c2c:	9e 07       	cpc	r25, r30
    4c2e:	a8 f4       	brcc	.+42     	; 0x4c5a <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    4c30:	61 15       	cp	r22, r1
    4c32:	71 05       	cpc	r23, r1
    4c34:	81 05       	cpc	r24, r1
    4c36:	91 05       	cpc	r25, r1
    4c38:	09 f0       	breq	.+2      	; 0x4c3c <findFiles+0x2e6>
    4c3a:	c0 ce       	rjmp	.-640    	; 0x49bc <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    4c3c:	00 e0       	ldi	r16, 0x00	; 0
    4c3e:	10 e0       	ldi	r17, 0x00	; 0
    4c40:	0e c0       	rjmp	.+28     	; 0x4c5e <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    4c42:	00 e0       	ldi	r16, 0x00	; 0
    4c44:	10 e0       	ldi	r17, 0x00	; 0
    4c46:	0b c0       	rjmp	.+22     	; 0x4c5e <findFiles+0x308>
    4c48:	00 e0       	ldi	r16, 0x00	; 0
    4c4a:	10 e0       	ldi	r17, 0x00	; 0
    4c4c:	08 c0       	rjmp	.+16     	; 0x4c5e <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    4c4e:	00 e0       	ldi	r16, 0x00	; 0
    4c50:	10 e0       	ldi	r17, 0x00	; 0
    4c52:	05 c0       	rjmp	.+10     	; 0x4c5e <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    4c54:	00 e0       	ldi	r16, 0x00	; 0
    4c56:	10 e0       	ldi	r17, 0x00	; 0
    4c58:	02 c0       	rjmp	.+4      	; 0x4c5e <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    4c5a:	00 e0       	ldi	r16, 0x00	; 0
    4c5c:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    4c5e:	80 2f       	mov	r24, r16
    4c60:	91 2f       	mov	r25, r17
    4c62:	2c 96       	adiw	r28, 0x0c	; 12
    4c64:	cd bf       	out	0x3d, r28	; 61
    4c66:	de bf       	out	0x3e, r29	; 62
    4c68:	df 91       	pop	r29
    4c6a:	cf 91       	pop	r28
    4c6c:	1f 91       	pop	r17
    4c6e:	0f 91       	pop	r16
    4c70:	ff 90       	pop	r15
    4c72:	ef 90       	pop	r14
    4c74:	df 90       	pop	r13
    4c76:	cf 90       	pop	r12
    4c78:	bf 90       	pop	r11
    4c7a:	af 90       	pop	r10
    4c7c:	9f 90       	pop	r9
    4c7e:	8f 90       	pop	r8
    4c80:	7f 90       	pop	r7
    4c82:	6f 90       	pop	r6
    4c84:	5f 90       	pop	r5
    4c86:	4f 90       	pop	r4
    4c88:	3f 90       	pop	r3
    4c8a:	2f 90       	pop	r2
    4c8c:	08 95       	ret

00004c8e <deleteFile>:
//********************************************************************
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
    4c8e:	0e 94 cb 22 	call	0x4596	; 0x4596 <convertFileName>
  if(error) return;
    4c92:	88 23       	and	r24, r24
    4c94:	29 f4       	brne	.+10     	; 0x4ca0 <deleteFile+0x12>

  findFiles (DELETE, Filename);
    4c96:	82 e0       	ldi	r24, 0x02	; 2
    4c98:	62 e9       	ldi	r22, 0x92	; 146
    4c9a:	70 e5       	ldi	r23, 0x50	; 80
    4c9c:	0e 94 ab 24 	call	0x4956	; 0x4956 <findFiles>
    4ca0:	08 95       	ret

00004ca2 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    4ca2:	4f 92       	push	r4
    4ca4:	5f 92       	push	r5
    4ca6:	6f 92       	push	r6
    4ca8:	7f 92       	push	r7
    4caa:	af 92       	push	r10
    4cac:	bf 92       	push	r11
    4cae:	cf 92       	push	r12
    4cb0:	df 92       	push	r13
    4cb2:	ef 92       	push	r14
    4cb4:	ff 92       	push	r15
    4cb6:	0f 93       	push	r16
    4cb8:	1f 93       	push	r17
    4cba:	cf 93       	push	r28
    4cbc:	c8 2f       	mov	r28, r24
    4cbe:	cb 01       	movw	r24, r22
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    4cc0:	0e 94 cb 22 	call	0x4596	; 0x4596 <convertFileName>
if(error) return 2;
    4cc4:	88 23       	and	r24, r24
    4cc6:	09 f0       	breq	.+2      	; 0x4cca <readFile+0x28>
    4cc8:	57 c0       	rjmp	.+174    	; 0x4d78 <readFile+0xd6>

dir = findFiles (GET_FILE, Filename); //get the file location
    4cca:	81 e0       	ldi	r24, 0x01	; 1
    4ccc:	62 e9       	ldi	r22, 0x92	; 146
    4cce:	70 e5       	ldi	r23, 0x50	; 80
    4cd0:	0e 94 ab 24 	call	0x4956	; 0x4956 <findFiles>
    4cd4:	fc 01       	movw	r30, r24
if(dir == 0) 
    4cd6:	00 97       	sbiw	r24, 0x00	; 0
    4cd8:	31 f4       	brne	.+12     	; 0x4ce6 <readFile+0x44>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4cda:	81 e0       	ldi	r24, 0x01	; 1
    4cdc:	cc 23       	and	r28, r28
    4cde:	09 f4       	brne	.+2      	; 0x4ce2 <readFile+0x40>
    4ce0:	4e c0       	rjmp	.+156    	; 0x4d7e <readFile+0xdc>
    4ce2:	80 e0       	ldi	r24, 0x00	; 0
    4ce4:	4c c0       	rjmp	.+152    	; 0x4d7e <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4ce6:	c1 30       	cpi	r28, 0x01	; 1
    4ce8:	09 f4       	brne	.+2      	; 0x4cec <readFile+0x4a>
    4cea:	48 c0       	rjmp	.+144    	; 0x4d7c <readFile+0xda>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4cec:	44 88       	ldd	r4, Z+20	; 0x14
    4cee:	55 88       	ldd	r5, Z+21	; 0x15
    4cf0:	66 24       	eor	r6, r6
    4cf2:	77 24       	eor	r7, r7
    4cf4:	32 01       	movw	r6, r4
    4cf6:	55 24       	eor	r5, r5
    4cf8:	44 24       	eor	r4, r4
    4cfa:	82 8d       	ldd	r24, Z+26	; 0x1a
    4cfc:	93 8d       	ldd	r25, Z+27	; 0x1b
    4cfe:	a0 e0       	ldi	r26, 0x00	; 0
    4d00:	b0 e0       	ldi	r27, 0x00	; 0
    4d02:	48 2a       	or	r4, r24
    4d04:	59 2a       	or	r5, r25
    4d06:	6a 2a       	or	r6, r26
    4d08:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4d0a:	0f 2e       	mov	r0, r31
    4d0c:	fd ea       	ldi	r31, 0xAD	; 173
    4d0e:	af 2e       	mov	r10, r31
    4d10:	f1 e2       	ldi	r31, 0x21	; 33
    4d12:	bf 2e       	mov	r11, r31
    4d14:	f0 2d       	mov	r31, r0
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    4d16:	c3 01       	movw	r24, r6
    4d18:	b2 01       	movw	r22, r4
    4d1a:	0e 94 85 20 	call	0x410a	; 0x410a <getFirstSector>
    4d1e:	6b 01       	movw	r12, r22
    4d20:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    4d22:	80 91 6a 50 	lds	r24, 0x506A
    4d26:	90 91 6b 50 	lds	r25, 0x506B
    4d2a:	00 97       	sbiw	r24, 0x00	; 0
    4d2c:	a1 f0       	breq	.+40     	; 0x4d56 <readFile+0xb4>
    4d2e:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4d30:	c7 01       	movw	r24, r14
    4d32:	b6 01       	movw	r22, r12
    4d34:	6c 0f       	add	r22, r28
    4d36:	71 1d       	adc	r23, r1
    4d38:	81 1d       	adc	r24, r1
    4d3a:	91 1d       	adc	r25, r1
    4d3c:	a5 01       	movw	r20, r10
    4d3e:	0e 94 8b 2b 	call	0x5716	; 0x5716 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    4d42:	cf 5f       	subi	r28, 0xFF	; 255
    4d44:	80 91 6a 50 	lds	r24, 0x506A
    4d48:	90 91 6b 50 	lds	r25, 0x506B
    4d4c:	2c 2f       	mov	r18, r28
    4d4e:	30 e0       	ldi	r19, 0x00	; 0
    4d50:	28 17       	cp	r18, r24
    4d52:	39 07       	cpc	r19, r25
    4d54:	68 f3       	brcs	.-38     	; 0x4d30 <readFile+0x8e>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    4d56:	c3 01       	movw	r24, r6
    4d58:	b2 01       	movw	r22, r4
    4d5a:	40 e0       	ldi	r20, 0x00	; 0
    4d5c:	00 e0       	ldi	r16, 0x00	; 0
    4d5e:	10 e0       	ldi	r17, 0x00	; 0
    4d60:	98 01       	movw	r18, r16
    4d62:	0e 94 ac 20 	call	0x4158	; 0x4158 <getSetNextCluster>
    4d66:	2b 01       	movw	r4, r22
    4d68:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    4d6a:	61 15       	cp	r22, r1
    4d6c:	71 05       	cpc	r23, r1
    4d6e:	81 05       	cpc	r24, r1
    4d70:	91 05       	cpc	r25, r1
    4d72:	89 f6       	brne	.-94     	; 0x4d16 <readFile+0x74>
	  return 0;}
    4d74:	80 e0       	ldi	r24, 0x00	; 0
    4d76:	03 c0       	rjmp	.+6      	; 0x4d7e <readFile+0xdc>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4d78:	82 e0       	ldi	r24, 0x02	; 2
    4d7a:	01 c0       	rjmp	.+2      	; 0x4d7e <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4d7c:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    4d7e:	cf 91       	pop	r28
    4d80:	1f 91       	pop	r17
    4d82:	0f 91       	pop	r16
    4d84:	ff 90       	pop	r15
    4d86:	ef 90       	pop	r14
    4d88:	df 90       	pop	r13
    4d8a:	cf 90       	pop	r12
    4d8c:	bf 90       	pop	r11
    4d8e:	af 90       	pop	r10
    4d90:	7f 90       	pop	r7
    4d92:	6f 90       	pop	r6
    4d94:	5f 90       	pop	r5
    4d96:	4f 90       	pop	r4
    4d98:	08 95       	ret

00004d9a <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4d9a:	2f 92       	push	r2
    4d9c:	3f 92       	push	r3
    4d9e:	4f 92       	push	r4
    4da0:	5f 92       	push	r5
    4da2:	6f 92       	push	r6
    4da4:	7f 92       	push	r7
    4da6:	8f 92       	push	r8
    4da8:	9f 92       	push	r9
    4daa:	af 92       	push	r10
    4dac:	bf 92       	push	r11
    4dae:	cf 92       	push	r12
    4db0:	df 92       	push	r13
    4db2:	ef 92       	push	r14
    4db4:	ff 92       	push	r15
    4db6:	0f 93       	push	r16
    4db8:	1f 93       	push	r17
    4dba:	cf 93       	push	r28
    4dbc:	df 93       	push	r29
    4dbe:	cd b7       	in	r28, 0x3d	; 61
    4dc0:	de b7       	in	r29, 0x3e	; 62
    4dc2:	60 97       	sbiw	r28, 0x10	; 16
    4dc4:	cd bf       	out	0x3d, r28	; 61
    4dc6:	de bf       	out	0x3e, r29	; 62
    4dc8:	fc 01       	movw	r30, r24
    4dca:	6d 83       	std	Y+5, r22	; 0x05
    4dcc:	7e 83       	std	Y+6, r23	; 0x06
    4dce:	49 01       	movw	r8, r18
    4dd0:	5a 01       	movw	r10, r20
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    4dd2:	81 e0       	ldi	r24, 0x01	; 1
    4dd4:	bf 01       	movw	r22, r30
    4dd6:	0e 94 51 26 	call	0x4ca2	; 0x4ca2 <readFile>

if(j == 1) 
    4dda:	81 30       	cpi	r24, 0x01	; 1
    4ddc:	09 f0       	breq	.+2      	; 0x4de0 <writeFile+0x46>
    4dde:	7b c0       	rjmp	.+246    	; 0x4ed6 <writeFile+0x13c>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    4de0:	00 91 74 50 	lds	r16, 0x5074
    4de4:	10 91 75 50 	lds	r17, 0x5075
    4de8:	20 91 76 50 	lds	r18, 0x5076
    4dec:	30 91 77 50 	lds	r19, 0x5077
    4df0:	09 83       	std	Y+1, r16	; 0x01
    4df2:	1a 83       	std	Y+2, r17	; 0x02
    4df4:	2b 83       	std	Y+3, r18	; 0x03
    4df6:	3c 83       	std	Y+4, r19	; 0x04
  clusterCount=0;
    4df8:	cc 24       	eor	r12, r12
    4dfa:	dd 24       	eor	r13, r13
    4dfc:	76 01       	movw	r14, r12
    4dfe:	24 01       	movw	r4, r8
    4e00:	35 01       	movw	r6, r10
    4e02:	48 01       	movw	r8, r16
    4e04:	59 01       	movw	r10, r18
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    4e06:	c5 01       	movw	r24, r10
    4e08:	b4 01       	movw	r22, r8
    4e0a:	40 e0       	ldi	r20, 0x00	; 0
    4e0c:	00 e0       	ldi	r16, 0x00	; 0
    4e0e:	10 e0       	ldi	r17, 0x00	; 0
    4e10:	98 01       	movw	r18, r16
    4e12:	0e 94 ac 20 	call	0x4158	; 0x4158 <getSetNextCluster>
    4e16:	dc 01       	movw	r26, r24
    4e18:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    4e1a:	8f 3f       	cpi	r24, 0xFF	; 255
    4e1c:	1f ef       	ldi	r17, 0xFF	; 255
    4e1e:	91 07       	cpc	r25, r17
    4e20:	1f ef       	ldi	r17, 0xFF	; 255
    4e22:	a1 07       	cpc	r26, r17
    4e24:	1f ef       	ldi	r17, 0xFF	; 255
    4e26:	b1 07       	cpc	r27, r17
    4e28:	41 f0       	breq	.+16     	; 0x4e3a <writeFile+0xa0>
	cluster = nextCluster;
	clusterCount++;
    4e2a:	08 94       	sec
    4e2c:	c1 1c       	adc	r12, r1
    4e2e:	d1 1c       	adc	r13, r1
    4e30:	e1 1c       	adc	r14, r1
    4e32:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    4e34:	4c 01       	movw	r8, r24
    4e36:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    4e38:	e6 cf       	rjmp	.-52     	; 0x4e06 <writeFile+0x6c>
    4e3a:	89 82       	std	Y+1, r8	; 0x01
    4e3c:	9a 82       	std	Y+2, r9	; 0x02
    4e3e:	ab 82       	std	Y+3, r10	; 0x03
    4e40:	bc 82       	std	Y+4, r11	; 0x04
    4e42:	53 01       	movw	r10, r6
    4e44:	42 01       	movw	r8, r4
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    4e46:	20 91 6a 50 	lds	r18, 0x506A
    4e4a:	30 91 6b 50 	lds	r19, 0x506B
    4e4e:	80 91 56 40 	lds	r24, 0x4056
    4e52:	90 91 57 40 	lds	r25, 0x4057
    4e56:	60 90 56 40 	lds	r6, 0x4056
    4e5a:	70 90 57 40 	lds	r7, 0x4057
    4e5e:	bc 01       	movw	r22, r24
    4e60:	80 e0       	ldi	r24, 0x00	; 0
    4e62:	90 e0       	ldi	r25, 0x00	; 0
    4e64:	40 e0       	ldi	r20, 0x00	; 0
    4e66:	50 e0       	ldi	r21, 0x00	; 0
    4e68:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    4e6c:	a7 01       	movw	r20, r14
    4e6e:	96 01       	movw	r18, r12
    4e70:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    4e74:	dc 01       	movw	r26, r24
    4e76:	cb 01       	movw	r24, r22
    4e78:	40 91 52 40 	lds	r20, 0x4052
    4e7c:	50 91 53 40 	lds	r21, 0x4053
    4e80:	60 91 54 40 	lds	r22, 0x4054
    4e84:	70 91 55 40 	lds	r23, 0x4055
    4e88:	8a 01       	movw	r16, r20
    4e8a:	9b 01       	movw	r18, r22
    4e8c:	08 1b       	sub	r16, r24
    4e8e:	19 0b       	sbc	r17, r25
    4e90:	2a 0b       	sbc	r18, r26
    4e92:	3b 0b       	sbc	r19, r27
    4e94:	c9 01       	movw	r24, r18
    4e96:	b8 01       	movw	r22, r16
    4e98:	93 01       	movw	r18, r6
    4e9a:	40 e0       	ldi	r20, 0x00	; 0
    4e9c:	50 e0       	ldi	r21, 0x00	; 0
    4e9e:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    4ea2:	02 2f       	mov	r16, r18

//start writing data here

if(start){
  start = 0;
  startBlock = getFirstSector (cluster) + sector;
    4ea4:	69 81       	ldd	r22, Y+1	; 0x01
    4ea6:	7a 81       	ldd	r23, Y+2	; 0x02
    4ea8:	8b 81       	ldd	r24, Y+3	; 0x03
    4eaa:	9c 81       	ldd	r25, Y+4	; 0x04
    4eac:	0e 94 85 20 	call	0x410a	; 0x410a <getFirstSector>
    4eb0:	dc 01       	movw	r26, r24
    4eb2:	cb 01       	movw	r24, r22
    4eb4:	20 2e       	mov	r2, r16
    4eb6:	33 24       	eor	r3, r3
    4eb8:	28 0e       	add	r2, r24
    4eba:	39 1e       	adc	r3, r25
  SD_read_block (startBlock,SDBuffer);
    4ebc:	b1 01       	movw	r22, r2
    4ebe:	80 e0       	ldi	r24, 0x00	; 0
    4ec0:	90 e0       	ldi	r25, 0x00	; 0
    4ec2:	49 e4       	ldi	r20, 0x49	; 73
    4ec4:	5e e3       	ldi	r21, 0x3E	; 62
    4ec6:	0e 94 8b 2b 	call	0x5716	; 0x5716 <SD_read_block>
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    4eca:	1f 86       	std	Y+15, r1	; 0x0f
    4ecc:	18 8a       	std	Y+16, r1	; 0x10
    4ece:	19 86       	std	Y+9, r1	; 0x09
    4ed0:	1a 86       	std	Y+10, r1	; 0x0a
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    4ed2:	11 e0       	ldi	r17, 0x01	; 1
    4ed4:	4c c0       	rjmp	.+152    	; 0x4f6e <writeFile+0x1d4>
}
else if(j == 2) 
    4ed6:	82 30       	cpi	r24, 0x02	; 2
    4ed8:	09 f4       	brne	.+2      	; 0x4edc <writeFile+0x142>
    4eda:	0c c2       	rjmp	.+1048   	; 0x52f4 <writeFile+0x55a>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    4edc:	82 e0       	ldi	r24, 0x02	; 2
    4ede:	60 e0       	ldi	r22, 0x00	; 0
    4ee0:	20 e0       	ldi	r18, 0x00	; 0
    4ee2:	30 e0       	ldi	r19, 0x00	; 0
    4ee4:	a9 01       	movw	r20, r18
    4ee6:	0e 94 3e 21 	call	0x427c	; 0x427c <getSetFreeCluster>
  if(cluster > totalClusters)
    4eea:	00 91 59 40 	lds	r16, 0x4059
    4eee:	10 91 5a 40 	lds	r17, 0x405A
    4ef2:	20 91 5b 40 	lds	r18, 0x405B
    4ef6:	30 91 5c 40 	lds	r19, 0x405C
    4efa:	06 17       	cp	r16, r22
    4efc:	17 07       	cpc	r17, r23
    4efe:	28 07       	cpc	r18, r24
    4f00:	39 07       	cpc	r19, r25
    4f02:	40 f4       	brcc	.+16     	; 0x4f14 <writeFile+0x17a>
     cluster = rootCluster;
    4f04:	60 91 5e 40 	lds	r22, 0x405E
    4f08:	70 91 5f 40 	lds	r23, 0x405F
    4f0c:	80 91 60 40 	lds	r24, 0x4060
    4f10:	90 91 61 40 	lds	r25, 0x4061

  cluster = searchNextFreeCluster(cluster);
    4f14:	0e 94 8a 23 	call	0x4714	; 0x4714 <searchNextFreeCluster>
    4f18:	69 83       	std	Y+1, r22	; 0x01
    4f1a:	7a 83       	std	Y+2, r23	; 0x02
    4f1c:	8b 83       	std	Y+3, r24	; 0x03
    4f1e:	9c 83       	std	Y+4, r25	; 0x04
   if(cluster == 0)
    4f20:	61 15       	cp	r22, r1
    4f22:	71 05       	cpc	r23, r1
    4f24:	81 05       	cpc	r24, r1
    4f26:	91 05       	cpc	r25, r1
    4f28:	09 f4       	brne	.+2      	; 0x4f2c <writeFile+0x192>
    4f2a:	e6 c1       	rjmp	.+972    	; 0x52f8 <writeFile+0x55e>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    4f2c:	41 e0       	ldi	r20, 0x01	; 1
    4f2e:	0f ef       	ldi	r16, 0xFF	; 255
    4f30:	1f ef       	ldi	r17, 0xFF	; 255
    4f32:	98 01       	movw	r18, r16
    4f34:	0e 94 ac 20 	call	0x4158	; 0x4158 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    4f38:	2b 81       	ldd	r18, Y+3	; 0x03
    4f3a:	3c 81       	ldd	r19, Y+4	; 0x04
    4f3c:	29 87       	std	Y+9, r18	; 0x09
    4f3e:	3a 87       	std	Y+10, r19	; 0x0a
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    4f40:	89 81       	ldd	r24, Y+1	; 0x01
    4f42:	9a 81       	ldd	r25, Y+2	; 0x02
    4f44:	8f 87       	std	Y+15, r24	; 0x0f
    4f46:	98 8b       	std	Y+16, r25	; 0x10
  fileSize = 0;
    4f48:	10 92 52 40 	sts	0x4052, r1
    4f4c:	10 92 53 40 	sts	0x4053, r1
    4f50:	10 92 54 40 	sts	0x4054, r1
    4f54:	10 92 55 40 	sts	0x4055, r1
  startBlock = getFirstSector (cluster) + sector;
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
    4f58:	69 81       	ldd	r22, Y+1	; 0x01
    4f5a:	7a 81       	ldd	r23, Y+2	; 0x02
    4f5c:	8b 81       	ldd	r24, Y+3	; 0x03
    4f5e:	9c 81       	ldd	r25, Y+4	; 0x04
    4f60:	0e 94 85 20 	call	0x410a	; 0x410a <getFirstSector>
    4f64:	dc 01       	movw	r26, r24
    4f66:	cb 01       	movw	r24, r22
    4f68:	1c 01       	movw	r2, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4f6a:	10 e0       	ldi	r17, 0x00	; 0
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
  j=0;
    4f6c:	00 e0       	ldi	r16, 0x00	; 0
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    4f6e:	81 14       	cp	r8, r1
    4f70:	91 04       	cpc	r9, r1
    4f72:	a1 04       	cpc	r10, r1
    4f74:	b1 04       	cpc	r11, r1
    4f76:	09 f4       	brne	.+2      	; 0x4f7a <writeFile+0x1e0>
    4f78:	8d c0       	rjmp	.+282    	; 0x5094 <writeFile+0x2fa>
    4f7a:	44 24       	eor	r4, r4
    4f7c:	55 24       	eor	r5, r5
    4f7e:	32 01       	movw	r6, r4
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
		 writtenData += 512;
		 dataToWrite = 512;
    4f80:	c0 2e       	mov	r12, r16
    4f82:	1b 87       	std	Y+11, r17	; 0x0b
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    4f84:	90 e0       	ldi	r25, 0x00	; 0
    4f86:	89 16       	cp	r8, r25
    4f88:	92 e0       	ldi	r25, 0x02	; 2
    4f8a:	99 06       	cpc	r9, r25
    4f8c:	90 e0       	ldi	r25, 0x00	; 0
    4f8e:	a9 06       	cpc	r10, r25
    4f90:	90 e0       	ldi	r25, 0x00	; 0
    4f92:	b9 06       	cpc	r11, r25
    4f94:	88 f0       	brcs	.+34     	; 0x4fb8 <writeFile+0x21e>
		 writtenData += 512;
    4f96:	00 e0       	ldi	r16, 0x00	; 0
    4f98:	12 e0       	ldi	r17, 0x02	; 2
    4f9a:	20 e0       	ldi	r18, 0x00	; 0
    4f9c:	30 e0       	ldi	r19, 0x00	; 0
    4f9e:	40 0e       	add	r4, r16
    4fa0:	51 1e       	adc	r5, r17
    4fa2:	62 1e       	adc	r6, r18
    4fa4:	73 1e       	adc	r7, r19
		 dataToWrite = 512;
		 lengthOfData -= 512;
    4fa6:	80 e0       	ldi	r24, 0x00	; 0
    4fa8:	9e ef       	ldi	r25, 0xFE	; 254
    4faa:	af ef       	ldi	r26, 0xFF	; 255
    4fac:	bf ef       	ldi	r27, 0xFF	; 255
    4fae:	88 0e       	add	r8, r24
    4fb0:	99 1e       	adc	r9, r25
    4fb2:	aa 1e       	adc	r10, r26
    4fb4:	bb 1e       	adc	r11, r27
    4fb6:	0c c0       	rjmp	.+24     	; 0x4fd0 <writeFile+0x236>
	}
	else{
		writtenData += lengthOfData;
    4fb8:	48 0c       	add	r4, r8
    4fba:	59 1c       	adc	r5, r9
    4fbc:	6a 1c       	adc	r6, r10
    4fbe:	7b 1c       	adc	r7, r11
		dataToWrite = lengthOfData%512;
    4fc0:	95 01       	movw	r18, r10
    4fc2:	84 01       	movw	r16, r8
    4fc4:	11 70       	andi	r17, 0x01	; 1
    4fc6:	20 70       	andi	r18, 0x00	; 0
    4fc8:	30 70       	andi	r19, 0x00	; 0
		lengthOfData = 0;
    4fca:	88 24       	eor	r8, r8
    4fcc:	99 24       	eor	r9, r9
    4fce:	54 01       	movw	r10, r8
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    4fd0:	80 91 52 40 	lds	r24, 0x4052
    4fd4:	90 91 53 40 	lds	r25, 0x4053
    4fd8:	a0 91 54 40 	lds	r26, 0x4054
    4fdc:	b0 91 55 40 	lds	r27, 0x4055
    4fe0:	80 50       	subi	r24, 0x00	; 0
    4fe2:	9e 4f       	sbci	r25, 0xFE	; 254
    4fe4:	af 4f       	sbci	r26, 0xFF	; 255
    4fe6:	bf 4f       	sbci	r27, 0xFF	; 255
    4fe8:	80 93 52 40 	sts	0x4052, r24
    4fec:	90 93 53 40 	sts	0x4053, r25
    4ff0:	a0 93 54 40 	sts	0x4054, r26
    4ff4:	b0 93 55 40 	sts	0x4055, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    4ff8:	b1 01       	movw	r22, r2
    4ffa:	80 e0       	ldi	r24, 0x00	; 0
    4ffc:	90 e0       	ldi	r25, 0x00	; 0
    4ffe:	a2 01       	movw	r20, r4
    5000:	40 1b       	sub	r20, r16
    5002:	51 0b       	sbc	r21, r17
    5004:	ad 81       	ldd	r26, Y+5	; 0x05
    5006:	be 81       	ldd	r27, Y+6	; 0x06
    5008:	4a 0f       	add	r20, r26
    500a:	5b 1f       	adc	r21, r27
    500c:	98 01       	movw	r18, r16
    500e:	0e 94 d6 2a 	call	0x55ac	; 0x55ac <SD_write_block>
	j++;
    5012:	c3 94       	inc	r12
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    5014:	20 91 6a 50 	lds	r18, 0x506A
    5018:	30 91 6b 50 	lds	r19, 0x506B
    501c:	8c 2d       	mov	r24, r12
    501e:	90 e0       	ldi	r25, 0x00	; 0
    5020:	82 17       	cp	r24, r18
    5022:	93 07       	cpc	r25, r19
    5024:	29 f5       	brne	.+74     	; 0x5070 <writeFile+0x2d6>
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    5026:	69 81       	ldd	r22, Y+1	; 0x01
    5028:	7a 81       	ldd	r23, Y+2	; 0x02
    502a:	8b 81       	ldd	r24, Y+3	; 0x03
    502c:	9c 81       	ldd	r25, Y+4	; 0x04
    502e:	0e 94 8a 23 	call	0x4714	; 0x4714 <searchNextFreeCluster>
    5032:	6b 01       	movw	r12, r22
    5034:	7c 01       	movw	r14, r24
		if(cluster == 0){
    5036:	61 15       	cp	r22, r1
    5038:	71 05       	cpc	r23, r1
    503a:	81 05       	cpc	r24, r1
    503c:	91 05       	cpc	r25, r1
    503e:	09 f4       	brne	.+2      	; 0x5042 <writeFile+0x2a8>
    5040:	5d c1       	rjmp	.+698    	; 0x52fc <writeFile+0x562>
		  //No free cluster!
		  return 2;
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    5042:	69 81       	ldd	r22, Y+1	; 0x01
    5044:	7a 81       	ldd	r23, Y+2	; 0x02
    5046:	8b 81       	ldd	r24, Y+3	; 0x03
    5048:	9c 81       	ldd	r25, Y+4	; 0x04
    504a:	41 e0       	ldi	r20, 0x01	; 1
    504c:	97 01       	movw	r18, r14
    504e:	86 01       	movw	r16, r12
    5050:	0e 94 ac 20 	call	0x4158	; 0x4158 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    5054:	c7 01       	movw	r24, r14
    5056:	b6 01       	movw	r22, r12
    5058:	41 e0       	ldi	r20, 0x01	; 1
    505a:	0f ef       	ldi	r16, 0xFF	; 255
    505c:	1f ef       	ldi	r17, 0xFF	; 255
    505e:	98 01       	movw	r18, r16
    5060:	0e 94 ac 20 	call	0x4158	; 0x4158 <getSetNextCluster>
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    5064:	c9 82       	std	Y+1, r12	; 0x01
    5066:	da 82       	std	Y+2, r13	; 0x02
    5068:	eb 82       	std	Y+3, r14	; 0x03
    506a:	fc 82       	std	Y+4, r15	; 0x04
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
	j++;
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
    506c:	cc 24       	eor	r12, r12
    506e:	03 c0       	rjmp	.+6      	; 0x5076 <writeFile+0x2dc>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    5070:	08 94       	sec
    5072:	21 1c       	adc	r2, r1
    5074:	31 1c       	adc	r3, r1
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    5076:	82 e0       	ldi	r24, 0x02	; 2
    5078:	61 e0       	ldi	r22, 0x01	; 1
    507a:	29 81       	ldd	r18, Y+1	; 0x01
    507c:	3a 81       	ldd	r19, Y+2	; 0x02
    507e:	4b 81       	ldd	r20, Y+3	; 0x03
    5080:	5c 81       	ldd	r21, Y+4	; 0x04
    5082:	0e 94 3e 21 	call	0x427c	; 0x427c <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    5086:	81 14       	cp	r8, r1
    5088:	91 04       	cpc	r9, r1
    508a:	a1 04       	cpc	r10, r1
    508c:	b1 04       	cpc	r11, r1
    508e:	09 f0       	breq	.+2      	; 0x5092 <writeFile+0x2f8>
    5090:	79 cf       	rjmp	.-270    	; 0x4f84 <writeFile+0x1ea>
    5092:	1b 85       	ldd	r17, Y+11	; 0x0b
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    5094:	11 23       	and	r17, r17
    5096:	09 f4       	brne	.+2      	; 0x509a <writeFile+0x300>
    5098:	3f c0       	rjmp	.+126    	; 0x5118 <writeFile+0x37e>
{
  SD_read_block (appendFileSector,SDBuffer);    
    509a:	60 91 a3 50 	lds	r22, 0x50A3
    509e:	70 91 a4 50 	lds	r23, 0x50A4
    50a2:	80 91 a5 50 	lds	r24, 0x50A5
    50a6:	90 91 a6 50 	lds	r25, 0x50A6
    50aa:	09 e4       	ldi	r16, 0x49	; 73
    50ac:	1e e3       	ldi	r17, 0x3E	; 62
    50ae:	a8 01       	movw	r20, r16
    50b0:	0e 94 8b 2b 	call	0x5716	; 0x5716 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    50b4:	e0 91 4a 40 	lds	r30, 0x404A
    50b8:	f0 91 4b 40 	lds	r31, 0x404B
    50bc:	e0 0f       	add	r30, r16
    50be:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    50c0:	12 8a       	std	Z+18, r1	; 0x12
    50c2:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    50c4:	80 91 52 40 	lds	r24, 0x4052
    50c8:	90 91 53 40 	lds	r25, 0x4053
    50cc:	a0 91 54 40 	lds	r26, 0x4054
    50d0:	b0 91 55 40 	lds	r27, 0x4055
    50d4:	44 8d       	ldd	r20, Z+28	; 0x1c
    50d6:	55 8d       	ldd	r21, Z+29	; 0x1d
    50d8:	66 8d       	ldd	r22, Z+30	; 0x1e
    50da:	77 8d       	ldd	r23, Z+31	; 0x1f
    50dc:	6c 01       	movw	r12, r24
    50de:	7d 01       	movw	r14, r26
    50e0:	c4 1a       	sub	r12, r20
    50e2:	d5 0a       	sbc	r13, r21
    50e4:	e6 0a       	sbc	r14, r22
    50e6:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    50e8:	84 8f       	std	Z+28, r24	; 0x1c
    50ea:	95 8f       	std	Z+29, r25	; 0x1d
    50ec:	a6 8f       	std	Z+30, r26	; 0x1e
    50ee:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    50f0:	60 91 a3 50 	lds	r22, 0x50A3
    50f4:	70 91 a4 50 	lds	r23, 0x50A4
    50f8:	80 91 a5 50 	lds	r24, 0x50A5
    50fc:	90 91 a6 50 	lds	r25, 0x50A6
    5100:	a8 01       	movw	r20, r16
    5102:	20 e0       	ldi	r18, 0x00	; 0
    5104:	32 e0       	ldi	r19, 0x02	; 2
    5106:	0e 94 d6 2a 	call	0x55ac	; 0x55ac <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    510a:	81 e0       	ldi	r24, 0x01	; 1
    510c:	b7 01       	movw	r22, r14
    510e:	a6 01       	movw	r20, r12
    5110:	0e 94 3d 24 	call	0x487a	; 0x487a <freeMemoryUpdate>

 //File appended!
  return 0;
    5114:	80 e0       	ldi	r24, 0x00	; 0
    5116:	f9 c0       	rjmp	.+498    	; 0x530a <writeFile+0x570>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    5118:	00 91 5e 40 	lds	r16, 0x405E
    511c:	10 91 5f 40 	lds	r17, 0x405F
    5120:	20 91 60 40 	lds	r18, 0x4060
    5124:	30 91 61 40 	lds	r19, 0x4061
    5128:	0b 87       	std	Y+11, r16	; 0x0b
    512a:	1c 87       	std	Y+12, r17	; 0x0c
    512c:	2d 87       	std	Y+13, r18	; 0x0d
    512e:	3e 87       	std	Y+14, r19	; 0x0e
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    5130:	77 24       	eor	r7, r7
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    5132:	82 e9       	ldi	r24, 0x92	; 146
    5134:	90 e5       	ldi	r25, 0x50	; 80
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    5136:	0f 2e       	mov	r0, r31
    5138:	fb e0       	ldi	r31, 0x0B	; 11
    513a:	af 2e       	mov	r10, r31
    513c:	bb 24       	eor	r11, r11
    513e:	f0 2d       	mov	r31, r0
    5140:	a8 0e       	add	r10, r24
    5142:	b9 1e       	adc	r11, r25

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    5144:	88 24       	eor	r8, r8
    5146:	68 94       	set
    5148:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    514a:	0f 2e       	mov	r0, r31
    514c:	f9 e4       	ldi	r31, 0x49	; 73
    514e:	4f 2e       	mov	r4, r31
    5150:	fe e3       	ldi	r31, 0x3E	; 62
    5152:	5f 2e       	mov	r5, r31
    5154:	f0 2d       	mov	r31, r0
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    5156:	28 2e       	mov	r2, r24
    5158:	99 2e       	mov	r9, r25
    515a:	37 2c       	mov	r3, r7
    515c:	6f 84       	ldd	r6, Y+15	; 0x0f
    515e:	78 88       	ldd	r7, Y+16	; 0x10
    5160:	04 c0       	rjmp	.+8      	; 0x516a <writeFile+0x3d0>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    5162:	cb 86       	std	Y+11, r12	; 0x0b
    5164:	dc 86       	std	Y+12, r13	; 0x0c
    5166:	ed 86       	std	Y+13, r14	; 0x0d
    5168:	fe 86       	std	Y+14, r15	; 0x0e

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    516a:	6b 85       	ldd	r22, Y+11	; 0x0b
    516c:	7c 85       	ldd	r23, Y+12	; 0x0c
    516e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5170:	9e 85       	ldd	r25, Y+14	; 0x0e
    5172:	0e 94 85 20 	call	0x410a	; 0x410a <getFirstSector>
    5176:	6d 83       	std	Y+5, r22	; 0x05
    5178:	7e 83       	std	Y+6, r23	; 0x06
    517a:	8f 83       	std	Y+7, r24	; 0x07
    517c:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    517e:	80 91 6a 50 	lds	r24, 0x506A
    5182:	90 91 6b 50 	lds	r25, 0x506B
    5186:	00 97       	sbiw	r24, 0x00	; 0
    5188:	09 f4       	brne	.+2      	; 0x518c <writeFile+0x3f2>
    518a:	77 c0       	rjmp	.+238    	; 0x527a <writeFile+0x4e0>
    518c:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    518e:	cd 80       	ldd	r12, Y+5	; 0x05
    5190:	de 80       	ldd	r13, Y+6	; 0x06
    5192:	ef 80       	ldd	r14, Y+7	; 0x07
    5194:	f8 84       	ldd	r15, Y+8	; 0x08
    5196:	19 81       	ldd	r17, Y+1	; 0x01
    5198:	c1 0e       	add	r12, r17
    519a:	d1 1c       	adc	r13, r1
    519c:	e1 1c       	adc	r14, r1
    519e:	f1 1c       	adc	r15, r1
    51a0:	c7 01       	movw	r24, r14
    51a2:	b6 01       	movw	r22, r12
    51a4:	a2 01       	movw	r20, r4
    51a6:	0e 94 8b 2b 	call	0x5716	; 0x5716 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    51aa:	80 91 56 40 	lds	r24, 0x4056
    51ae:	90 91 57 40 	lds	r25, 0x4057
    51b2:	00 97       	sbiw	r24, 0x00	; 0
    51b4:	09 f4       	brne	.+2      	; 0x51b8 <writeFile+0x41e>
    51b6:	54 c0       	rjmp	.+168    	; 0x5260 <writeFile+0x4c6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    51b8:	33 20       	and	r3, r3
    51ba:	09 f0       	breq	.+2      	; 0x51be <writeFile+0x424>
    51bc:	a1 c0       	rjmp	.+322    	; 0x5300 <writeFile+0x566>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    51be:	a2 01       	movw	r20, r4
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    51c0:	00 e0       	ldi	r16, 0x00	; 0
    51c2:	10 e0       	ldi	r17, 0x00	; 0
    51c4:	06 c0       	rjmp	.+12     	; 0x51d2 <writeFile+0x438>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    51c6:	a8 01       	movw	r20, r16
    51c8:	47 5b       	subi	r20, 0xB7	; 183
    51ca:	51 4c       	sbci	r21, 0xC1	; 193
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    51cc:	22 23       	and	r18, r18
    51ce:	09 f0       	breq	.+2      	; 0x51d2 <writeFile+0x438>
    51d0:	99 c0       	rjmp	.+306    	; 0x5304 <writeFile+0x56a>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    51d2:	da 01       	movw	r26, r20
    51d4:	8c 91       	ld	r24, X
    51d6:	88 23       	and	r24, r24
    51d8:	21 f4       	brne	.+8      	; 0x51e2 <writeFile+0x448>
    51da:	e2 2d       	mov	r30, r2
    51dc:	f9 2d       	mov	r31, r9
    51de:	da 01       	movw	r26, r20
    51e0:	04 c0       	rjmp	.+8      	; 0x51ea <writeFile+0x450>
    51e2:	85 3e       	cpi	r24, 0xE5	; 229
    51e4:	d1 f3       	breq	.-12     	; 0x51da <writeFile+0x440>
    51e6:	23 2d       	mov	r18, r3
    51e8:	30 c0       	rjmp	.+96     	; 0x524a <writeFile+0x4b0>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
    51ea:	81 91       	ld	r24, Z+
    51ec:	8d 93       	st	X+, r24
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    51ee:	ea 15       	cp	r30, r10
    51f0:	fb 05       	cpc	r31, r11
    51f2:	d9 f7       	brne	.-10     	; 0x51ea <writeFile+0x450>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    51f4:	fa 01       	movw	r30, r20
    51f6:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    51f8:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    51fa:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    51fc:	12 8a       	std	Z+18, r1	; 0x12
    51fe:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    5200:	29 85       	ldd	r18, Y+9	; 0x09
    5202:	3a 85       	ldd	r19, Y+10	; 0x0a
    5204:	24 8b       	std	Z+20, r18	; 0x14
    5206:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    5208:	62 8e       	std	Z+26, r6	; 0x1a
    520a:	73 8e       	std	Z+27, r7	; 0x1b
		  dir->fileSize = fileSize;
    520c:	80 91 52 40 	lds	r24, 0x4052
    5210:	90 91 53 40 	lds	r25, 0x4053
    5214:	a0 91 54 40 	lds	r26, 0x4054
    5218:	b0 91 55 40 	lds	r27, 0x4055
    521c:	84 8f       	std	Z+28, r24	; 0x1c
    521e:	95 8f       	std	Z+29, r25	; 0x1d
    5220:	a6 8f       	std	Z+30, r26	; 0x1e
    5222:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    5224:	c7 01       	movw	r24, r14
    5226:	b6 01       	movw	r22, r12
    5228:	a2 01       	movw	r20, r4
    522a:	20 e0       	ldi	r18, 0x00	; 0
    522c:	32 e0       	ldi	r19, 0x02	; 2
    522e:	0e 94 d6 2a 	call	0x55ac	; 0x55ac <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    5232:	40 91 52 40 	lds	r20, 0x4052
    5236:	50 91 53 40 	lds	r21, 0x4053
    523a:	60 91 54 40 	lds	r22, 0x4054
    523e:	70 91 55 40 	lds	r23, 0x4055
    5242:	81 e0       	ldi	r24, 0x01	; 1
    5244:	0e 94 3d 24 	call	0x487a	; 0x487a <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    5248:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    524a:	00 5e       	subi	r16, 0xE0	; 224
    524c:	1f 4f       	sbci	r17, 0xFF	; 255
    524e:	80 91 56 40 	lds	r24, 0x4056
    5252:	90 91 57 40 	lds	r25, 0x4057
    5256:	08 17       	cp	r16, r24
    5258:	19 07       	cpc	r17, r25
    525a:	08 f4       	brcc	.+2      	; 0x525e <writeFile+0x4c4>
    525c:	b4 cf       	rjmp	.-152    	; 0x51c6 <writeFile+0x42c>
    525e:	32 2e       	mov	r3, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    5260:	09 81       	ldd	r16, Y+1	; 0x01
    5262:	0f 5f       	subi	r16, 0xFF	; 255
    5264:	09 83       	std	Y+1, r16	; 0x01
    5266:	20 91 6a 50 	lds	r18, 0x506A
    526a:	30 91 6b 50 	lds	r19, 0x506B
    526e:	80 2f       	mov	r24, r16
    5270:	90 e0       	ldi	r25, 0x00	; 0
    5272:	82 17       	cp	r24, r18
    5274:	93 07       	cpc	r25, r19
    5276:	08 f4       	brcc	.+2      	; 0x527a <writeFile+0x4e0>
    5278:	8a cf       	rjmp	.-236    	; 0x518e <writeFile+0x3f4>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    527a:	6b 85       	ldd	r22, Y+11	; 0x0b
    527c:	7c 85       	ldd	r23, Y+12	; 0x0c
    527e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5280:	9e 85       	ldd	r25, Y+14	; 0x0e
    5282:	40 e0       	ldi	r20, 0x00	; 0
    5284:	00 e0       	ldi	r16, 0x00	; 0
    5286:	10 e0       	ldi	r17, 0x00	; 0
    5288:	98 01       	movw	r18, r16
    528a:	0e 94 ac 20 	call	0x4158	; 0x4158 <getSetNextCluster>
    528e:	6b 01       	movw	r12, r22
    5290:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    5292:	67 3f       	cpi	r22, 0xF7	; 247
    5294:	1f ef       	ldi	r17, 0xFF	; 255
    5296:	71 07       	cpc	r23, r17
    5298:	1f ef       	ldi	r17, 0xFF	; 255
    529a:	81 07       	cpc	r24, r17
    529c:	1f e0       	ldi	r17, 0x0F	; 15
    529e:	91 07       	cpc	r25, r17
    52a0:	08 f1       	brcs	.+66     	; 0x52e4 <writeFile+0x54a>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    52a2:	6f 3f       	cpi	r22, 0xFF	; 255
    52a4:	2f ef       	ldi	r18, 0xFF	; 255
    52a6:	72 07       	cpc	r23, r18
    52a8:	2f ef       	ldi	r18, 0xFF	; 255
    52aa:	82 07       	cpc	r24, r18
    52ac:	2f ef       	ldi	r18, 0xFF	; 255
    52ae:	92 07       	cpc	r25, r18
    52b0:	59 f5       	brne	.+86     	; 0x5308 <writeFile+0x56e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    52b2:	6b 85       	ldd	r22, Y+11	; 0x0b
    52b4:	7c 85       	ldd	r23, Y+12	; 0x0c
    52b6:	8d 85       	ldd	r24, Y+13	; 0x0d
    52b8:	9e 85       	ldd	r25, Y+14	; 0x0e
    52ba:	0e 94 8a 23 	call	0x4714	; 0x4714 <searchNextFreeCluster>
    52be:	6b 01       	movw	r12, r22
    52c0:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    52c2:	6b 85       	ldd	r22, Y+11	; 0x0b
    52c4:	7c 85       	ldd	r23, Y+12	; 0x0c
    52c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    52c8:	9e 85       	ldd	r25, Y+14	; 0x0e
    52ca:	41 e0       	ldi	r20, 0x01	; 1
    52cc:	97 01       	movw	r18, r14
    52ce:	86 01       	movw	r16, r12
    52d0:	0e 94 ac 20 	call	0x4158	; 0x4158 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    52d4:	c7 01       	movw	r24, r14
    52d6:	b6 01       	movw	r22, r12
    52d8:	41 e0       	ldi	r20, 0x01	; 1
    52da:	0f ef       	ldi	r16, 0xFF	; 255
    52dc:	1f ef       	ldi	r17, 0xFF	; 255
    52de:	98 01       	movw	r18, r16
    52e0:	0e 94 ac 20 	call	0x4158	; 0x4158 <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    52e4:	c1 14       	cp	r12, r1
    52e6:	d1 04       	cpc	r13, r1
    52e8:	e1 04       	cpc	r14, r1
    52ea:	f1 04       	cpc	r15, r1
    52ec:	09 f0       	breq	.+2      	; 0x52f0 <writeFile+0x556>
    52ee:	39 cf       	rjmp	.-398    	; 0x5162 <writeFile+0x3c8>
	   return 4;
    52f0:	84 e0       	ldi	r24, 0x04	; 4
    52f2:	0b c0       	rjmp	.+22     	; 0x530a <writeFile+0x570>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    52f4:	81 e0       	ldi	r24, 0x01	; 1
    52f6:	09 c0       	rjmp	.+18     	; 0x530a <writeFile+0x570>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    52f8:	82 e0       	ldi	r24, 0x02	; 2
    52fa:	07 c0       	rjmp	.+14     	; 0x530a <writeFile+0x570>
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
		if(cluster == 0){
		  //No free cluster!
		  return 2;
    52fc:	82 e0       	ldi	r24, 0x02	; 2
    52fe:	05 c0       	rjmp	.+10     	; 0x530a <writeFile+0x570>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    5300:	80 e0       	ldi	r24, 0x00	; 0
    5302:	03 c0       	rjmp	.+6      	; 0x530a <writeFile+0x570>
    5304:	80 e0       	ldi	r24, 0x00	; 0
    5306:	01 c0       	rjmp	.+2      	; 0x530a <writeFile+0x570>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    5308:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    530a:	60 96       	adiw	r28, 0x10	; 16
    530c:	cd bf       	out	0x3d, r28	; 61
    530e:	de bf       	out	0x3e, r29	; 62
    5310:	df 91       	pop	r29
    5312:	cf 91       	pop	r28
    5314:	1f 91       	pop	r17
    5316:	0f 91       	pop	r16
    5318:	ff 90       	pop	r15
    531a:	ef 90       	pop	r14
    531c:	df 90       	pop	r13
    531e:	cf 90       	pop	r12
    5320:	bf 90       	pop	r11
    5322:	af 90       	pop	r10
    5324:	9f 90       	pop	r9
    5326:	8f 90       	pop	r8
    5328:	7f 90       	pop	r7
    532a:	6f 90       	pop	r6
    532c:	5f 90       	pop	r5
    532e:	4f 90       	pop	r4
    5330:	3f 90       	pop	r3
    5332:	2f 90       	pop	r2
    5334:	08 95       	ret

00005336 <SD_command>:
// 	data = SPIC.DATA; //read SPI data register to reset status flag
// 	return data;
// }

//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    5336:	8f 92       	push	r8
    5338:	9f 92       	push	r9
    533a:	af 92       	push	r10
    533c:	bf 92       	push	r11
    533e:	cf 92       	push	r12
    5340:	df 92       	push	r13
    5342:	ef 92       	push	r14
    5344:	ff 92       	push	r15
    5346:	0f 93       	push	r16
    5348:	1f 93       	push	r17
    534a:	cf 93       	push	r28
    534c:	df 93       	push	r29
    534e:	84 2e       	mov	r8, r20
    5350:	a5 2e       	mov	r10, r21
    5352:	c6 2e       	mov	r12, r22
    5354:	c7 2f       	mov	r28, r23
    5356:	d2 2f       	mov	r29, r18
    5358:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    535a:	80 64       	ori	r24, 0x40	; 64
    535c:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    5360:	8c 2f       	mov	r24, r28
    5362:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    5366:	8c 2d       	mov	r24, r12
    5368:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    536c:	8a 2d       	mov	r24, r10
    536e:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    5372:	88 2d       	mov	r24, r8
    5374:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(crc);
    5378:	8d 2f       	mov	r24, r29
    537a:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	
	for(int i=0; i<read; i++){
    537e:	10 16       	cp	r1, r16
    5380:	11 06       	cpc	r1, r17
    5382:	64 f5       	brge	.+88     	; 0x53dc <SD_command+0xa6>
    5384:	00 e0       	ldi	r16, 0x00	; 0
    5386:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    5388:	0f 2e       	mov	r0, r31
    538a:	fd e0       	ldi	r31, 0x0D	; 13
    538c:	cf 2e       	mov	r12, r31
    538e:	dd 24       	eor	r13, r13
    5390:	f0 2d       	mov	r31, r0
    5392:	0f 2e       	mov	r0, r31
    5394:	f5 e3       	ldi	r31, 0x35	; 53
    5396:	af 2e       	mov	r10, r31
    5398:	fe e3       	ldi	r31, 0x3E	; 62
    539a:	bf 2e       	mov	r11, r31
    539c:	f0 2d       	mov	r31, r0
    539e:	c8 01       	movw	r24, r16
    53a0:	b6 01       	movw	r22, r12
    53a2:	0e 94 50 39 	call	0x72a0	; 0x72a0 <__divmodhi4>
    53a6:	ec 01       	movw	r28, r24
    53a8:	8f ef       	ldi	r24, 0xFF	; 255
    53aa:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    53ae:	f5 01       	movw	r30, r10
    53b0:	ec 0f       	add	r30, r28
    53b2:	fd 1f       	adc	r31, r29
    53b4:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    53b6:	80 81       	ld	r24, Z
    53b8:	8f 3f       	cpi	r24, 0xFF	; 255
    53ba:	49 f0       	breq	.+18     	; 0x53ce <SD_command+0x98>
			Buffer[1] = Buffer[i%13];
    53bc:	fe 01       	movw	r30, r28
    53be:	eb 5c       	subi	r30, 0xCB	; 203
    53c0:	f1 4c       	sbci	r31, 0xC1	; 193
    53c2:	80 81       	ld	r24, Z
    53c4:	80 93 36 3e 	sts	0x3E36, r24
			return Buffer[1];
    53c8:	80 91 36 3e 	lds	r24, 0x3E36
    53cc:	08 c0       	rjmp	.+16     	; 0x53de <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    53ce:	0f 5f       	subi	r16, 0xFF	; 255
    53d0:	1f 4f       	sbci	r17, 0xFF	; 255
    53d2:	0e 15       	cp	r16, r14
    53d4:	1f 05       	cpc	r17, r15
    53d6:	19 f7       	brne	.-58     	; 0x539e <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    53d8:	8f ef       	ldi	r24, 0xFF	; 255
    53da:	01 c0       	rjmp	.+2      	; 0x53de <SD_command+0xa8>
    53dc:	8f ef       	ldi	r24, 0xFF	; 255
}
    53de:	df 91       	pop	r29
    53e0:	cf 91       	pop	r28
    53e2:	1f 91       	pop	r17
    53e4:	0f 91       	pop	r16
    53e6:	ff 90       	pop	r15
    53e8:	ef 90       	pop	r14
    53ea:	df 90       	pop	r13
    53ec:	cf 90       	pop	r12
    53ee:	bf 90       	pop	r11
    53f0:	af 90       	pop	r10
    53f2:	9f 90       	pop	r9
    53f4:	8f 90       	pop	r8
    53f6:	08 95       	ret

000053f8 <SD_init>:
# include "SD_Card.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    53f8:	ff 92       	push	r15
    53fa:	0f 93       	push	r16
    53fc:	1f 93       	push	r17
    53fe:	cf 93       	push	r28
    5400:	df 93       	push	r29
	
	ADCPower(TRUE);				//power up portEX
    5402:	81 e0       	ldi	r24, 0x01	; 1
    5404:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    5408:	81 e0       	ldi	r24, 0x01	; 1
    540a:	0e 94 61 03 	call	0x6c2	; 0x6c2 <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    540e:	8f ef       	ldi	r24, 0xFF	; 255
    5410:	93 ec       	ldi	r25, 0xC3	; 195
    5412:	a9 e0       	ldi	r26, 0x09	; 9
    5414:	81 50       	subi	r24, 0x01	; 1
    5416:	90 40       	sbci	r25, 0x00	; 0
    5418:	a0 40       	sbci	r26, 0x00	; 0
    541a:	e1 f7       	brne	.-8      	; 0x5414 <SD_init+0x1c>
    541c:	00 c0       	rjmp	.+0      	; 0x541e <SD_init+0x26>
    541e:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
	
	PortEx_DIRSET(BIT3_bm, PS_BANKB); //SD card CS
    5420:	88 e0       	ldi	r24, 0x08	; 8
    5422:	60 e0       	ldi	r22, 0x00	; 0
    5424:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB); //pull SD cs high
    5428:	88 e0       	ldi	r24, 0x08	; 8
    542a:	60 e0       	ldi	r22, 0x00	; 0
    542c:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5430:	80 e0       	ldi	r24, 0x00	; 0
    5432:	63 e0       	ldi	r22, 0x03	; 3
    5434:	0e 94 d5 03 	call	0x7aa	; 0x7aa <SPIInit2>
	SPICS(TRUE);
    5438:	81 e0       	ldi	r24, 0x01	; 1
    543a:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
    543e:	8a e0       	ldi	r24, 0x0A	; 10
    5440:	90 e0       	ldi	r25, 0x00	; 0
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    5442:	e0 ec       	ldi	r30, 0xC0	; 192
    5444:	f8 e0       	ldi	r31, 0x08	; 8
    5446:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
    5448:	a1 e4       	ldi	r26, 0x41	; 65
    544a:	be e3       	ldi	r27, 0x3E	; 62
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    544c:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    544e:	22 81       	ldd	r18, Z+2	; 0x02
    5450:	22 23       	and	r18, r18
    5452:	ec f7       	brge	.-6      	; 0x544e <SD_init+0x56>
		Buffer[12] = SPIC.DATA;
    5454:	23 81       	ldd	r18, Z+3	; 0x03
    5456:	2c 93       	st	X, r18
    5458:	01 97       	sbiw	r24, 0x01	; 1
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
    545a:	c1 f7       	brne	.-16     	; 0x544c <SD_init+0x54>
		SPIC.DATA = SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
	}
	
	SPICS(FALSE);
    545c:	80 e0       	ldi	r24, 0x00	; 0
    545e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5462:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5466:	88 e0       	ldi	r24, 0x08	; 8
    5468:	60 e0       	ldi	r22, 0x00	; 0
    546a:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    546e:	80 e0       	ldi	r24, 0x00	; 0
    5470:	63 e0       	ldi	r22, 0x03	; 3
    5472:	0e 94 d5 03 	call	0x7aa	; 0x7aa <SPIInit2>
	SPICS(TRUE);
    5476:	81 e0       	ldi	r24, 0x01	; 1
    5478:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    547c:	cb e0       	ldi	r28, 0x0B	; 11
    547e:	d0 e0       	ldi	r29, 0x00	; 0
    5480:	02 c0       	rjmp	.+4      	; 0x5486 <SD_init+0x8e>
    5482:	21 97       	sbiw	r28, 0x01	; 1
		//try command 10 times before timing out
		if (i >= 10) {
    5484:	69 f0       	breq	.+26     	; 0x54a0 <SD_init+0xa8>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    5486:	80 e0       	ldi	r24, 0x00	; 0
    5488:	40 e0       	ldi	r20, 0x00	; 0
    548a:	50 e0       	ldi	r21, 0x00	; 0
    548c:	ba 01       	movw	r22, r20
    548e:	25 e9       	ldi	r18, 0x95	; 149
    5490:	08 e0       	ldi	r16, 0x08	; 8
    5492:	10 e0       	ldi	r17, 0x00	; 0
    5494:	0e 94 9b 29 	call	0x5336	; 0x5336 <SD_command>
    5498:	81 30       	cpi	r24, 0x01	; 1
    549a:	99 f7       	brne	.-26     	; 0x5482 <SD_init+0x8a>
uint8_t SD_init(void){
	
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    549c:	ff 24       	eor	r15, r15
    549e:	02 c0       	rjmp	.+4      	; 0x54a4 <SD_init+0xac>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
		//try command 10 times before timing out
		if (i >= 10) {
			//there was no response to the first command
			errorCode = 1;
    54a0:	ff 24       	eor	r15, r15
    54a2:	f3 94       	inc	r15
    54a4:	8f ef       	ldi	r24, 0xFF	; 255
    54a6:	93 ec       	ldi	r25, 0xC3	; 195
    54a8:	a9 e0       	ldi	r26, 0x09	; 9
    54aa:	81 50       	subi	r24, 0x01	; 1
    54ac:	90 40       	sbci	r25, 0x00	; 0
    54ae:	a0 40       	sbci	r26, 0x00	; 0
    54b0:	e1 f7       	brne	.-8      	; 0x54aa <SD_init+0xb2>
    54b2:	00 c0       	rjmp	.+0      	; 0x54b4 <SD_init+0xbc>
    54b4:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    54b6:	cb e0       	ldi	r28, 0x0B	; 11
    54b8:	d0 e0       	ldi	r29, 0x00	; 0
    54ba:	02 c0       	rjmp	.+4      	; 0x54c0 <SD_init+0xc8>
    54bc:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    54be:	69 f0       	breq	.+26     	; 0x54da <SD_init+0xe2>
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    54c0:	88 e0       	ldi	r24, 0x08	; 8
    54c2:	4a ea       	ldi	r20, 0xAA	; 170
    54c4:	51 e0       	ldi	r21, 0x01	; 1
    54c6:	60 e0       	ldi	r22, 0x00	; 0
    54c8:	70 e0       	ldi	r23, 0x00	; 0
    54ca:	27 e8       	ldi	r18, 0x87	; 135
    54cc:	08 e0       	ldi	r16, 0x08	; 8
    54ce:	10 e0       	ldi	r17, 0x00	; 0
    54d0:	0e 94 9b 29 	call	0x5336	; 0x5336 <SD_command>
    54d4:	81 30       	cpi	r24, 0x01	; 1
    54d6:	91 f7       	brne	.-28     	; 0x54bc <SD_init+0xc4>
    54d8:	02 c0       	rjmp	.+4      	; 0x54de <SD_init+0xe6>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    54da:	ff 24       	eor	r15, r15
    54dc:	f3 94       	inc	r15
    54de:	c2 e0       	ldi	r28, 0x02	; 2
    54e0:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}
	}
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    54e2:	05 e3       	ldi	r16, 0x35	; 53
    54e4:	1e e3       	ldi	r17, 0x3E	; 62
    54e6:	8f ef       	ldi	r24, 0xFF	; 255
    54e8:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    54ec:	f8 01       	movw	r30, r16
    54ee:	ec 0f       	add	r30, r28
    54f0:	fd 1f       	adc	r31, r29
    54f2:	80 83       	st	Z, r24
    54f4:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}
	for(int i=0;i<4;i++){
    54f6:	c6 30       	cpi	r28, 0x06	; 6
    54f8:	d1 05       	cpc	r29, r1
    54fa:	a9 f7       	brne	.-22     	; 0x54e6 <SD_init+0xee>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	//check that the response is the same as the argument sent in
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){
    54fc:	80 91 39 3e 	lds	r24, 0x3E39
    5500:	81 30       	cpi	r24, 0x01	; 1
    5502:	29 f4       	brne	.+10     	; 0x550e <SD_init+0x116>
    5504:	80 91 3a 3e 	lds	r24, 0x3E3A
    5508:	8a 3a       	cpi	r24, 0xAA	; 170
    550a:	21 f4       	brne	.+8      	; 0x5514 <SD_init+0x11c>
    550c:	05 c0       	rjmp	.+10     	; 0x5518 <SD_init+0x120>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    550e:	ff 24       	eor	r15, r15
    5510:	f3 94       	inc	r15
    5512:	02 c0       	rjmp	.+4      	; 0x5518 <SD_init+0x120>
    5514:	ff 24       	eor	r15, r15
    5516:	f3 94       	inc	r15
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
    5518:	c6 e3       	ldi	r28, 0x36	; 54
    551a:	de e3       	ldi	r29, 0x3E	; 62
		errorCode = 1;
	}
	//send second initialization command
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
    551c:	87 e3       	ldi	r24, 0x37	; 55
    551e:	40 e0       	ldi	r20, 0x00	; 0
    5520:	50 e0       	ldi	r21, 0x00	; 0
    5522:	ba 01       	movw	r22, r20
    5524:	2f ef       	ldi	r18, 0xFF	; 255
    5526:	08 e0       	ldi	r16, 0x08	; 8
    5528:	10 e0       	ldi	r17, 0x00	; 0
    552a:	0e 94 9b 29 	call	0x5336	; 0x5336 <SD_command>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
    552e:	81 e0       	ldi	r24, 0x01	; 1
    5530:	40 e0       	ldi	r20, 0x00	; 0
    5532:	50 e0       	ldi	r21, 0x00	; 0
    5534:	60 e0       	ldi	r22, 0x00	; 0
    5536:	70 e4       	ldi	r23, 0x40	; 64
    5538:	2f ef       	ldi	r18, 0xFF	; 255
    553a:	0e 94 9b 29 	call	0x5336	; 0x5336 <SD_command>
	} while(Buffer[1]!= 0x00);	
    553e:	88 81       	ld	r24, Y
    5540:	88 23       	and	r24, r24
    5542:	61 f7       	brne	.-40     	; 0x551c <SD_init+0x124>
    5544:	cb e0       	ldi	r28, 0x0B	; 11
    5546:	d0 e0       	ldi	r29, 0x00	; 0
    5548:	02 c0       	rjmp	.+4      	; 0x554e <SD_init+0x156>
    554a:	21 97       	sbiw	r28, 0x01	; 1
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
		if (i >= 10) {
    554c:	61 f0       	breq	.+24     	; 0x5566 <SD_init+0x16e>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
    554e:	8a e3       	ldi	r24, 0x3A	; 58
    5550:	40 e0       	ldi	r20, 0x00	; 0
    5552:	50 e0       	ldi	r21, 0x00	; 0
    5554:	ba 01       	movw	r22, r20
    5556:	2f ef       	ldi	r18, 0xFF	; 255
    5558:	08 e0       	ldi	r16, 0x08	; 8
    555a:	10 e0       	ldi	r17, 0x00	; 0
    555c:	0e 94 9b 29 	call	0x5336	; 0x5336 <SD_command>
    5560:	88 23       	and	r24, r24
    5562:	99 f7       	brne	.-26     	; 0x554a <SD_init+0x152>
    5564:	02 c0       	rjmp	.+4      	; 0x556a <SD_init+0x172>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    5566:	ff 24       	eor	r15, r15
    5568:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    556a:	c0 e0       	ldi	r28, 0x00	; 0
    556c:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    556e:	05 e3       	ldi	r16, 0x35	; 53
    5570:	1e e3       	ldi	r17, 0x3E	; 62
    5572:	8f ef       	ldi	r24, 0xFF	; 255
    5574:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5578:	f8 01       	movw	r30, r16
    557a:	ec 0f       	add	r30, r28
    557c:	fd 1f       	adc	r31, r29
    557e:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5580:	21 96       	adiw	r28, 0x01	; 1
    5582:	c4 30       	cpi	r28, 0x04	; 4
    5584:	d1 05       	cpc	r29, r1
    5586:	a9 f7       	brne	.-22     	; 0x5572 <SD_init+0x17a>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    5588:	80 91 35 3e 	lds	r24, 0x3E35
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    558c:	80 e0       	ldi	r24, 0x00	; 0
    558e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5592:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	//pull SD cs high
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    5596:	88 e0       	ldi	r24, 0x08	; 8
    5598:	60 e0       	ldi	r22, 0x00	; 0
    559a:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
	
	return errorCode;					
}
    559e:	8f 2d       	mov	r24, r15
    55a0:	df 91       	pop	r29
    55a2:	cf 91       	pop	r28
    55a4:	1f 91       	pop	r17
    55a6:	0f 91       	pop	r16
    55a8:	ff 90       	pop	r15
    55aa:	08 95       	ret

000055ac <SD_write_block>:
	}
	return SDHC_DUMMY_BYTE;
}

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    55ac:	6f 92       	push	r6
    55ae:	7f 92       	push	r7
    55b0:	8f 92       	push	r8
    55b2:	9f 92       	push	r9
    55b4:	af 92       	push	r10
    55b6:	bf 92       	push	r11
    55b8:	cf 92       	push	r12
    55ba:	df 92       	push	r13
    55bc:	ef 92       	push	r14
    55be:	ff 92       	push	r15
    55c0:	0f 93       	push	r16
    55c2:	1f 93       	push	r17
    55c4:	cf 93       	push	r28
    55c6:	df 93       	push	r29
    55c8:	4b 01       	movw	r8, r22
    55ca:	5c 01       	movw	r10, r24
    55cc:	74 2e       	mov	r7, r20
    55ce:	65 2e       	mov	r6, r21
    55d0:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    55d2:	88 e0       	ldi	r24, 0x08	; 8
    55d4:	60 e0       	ldi	r22, 0x00	; 0
    55d6:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    55da:	80 e0       	ldi	r24, 0x00	; 0
    55dc:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    55e0:	81 e0       	ldi	r24, 0x01	; 1
    55e2:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    55e6:	80 e0       	ldi	r24, 0x00	; 0
    55e8:	92 e0       	ldi	r25, 0x02	; 2
    55ea:	7c 01       	movw	r14, r24
    55ec:	ec 18       	sub	r14, r12
    55ee:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    55f0:	80 e0       	ldi	r24, 0x00	; 0
    55f2:	e8 16       	cp	r14, r24
    55f4:	82 e0       	ldi	r24, 0x02	; 2
    55f6:	f8 06       	cpc	r15, r24
    55f8:	11 f4       	brne	.+4      	; 0x55fe <SD_write_block+0x52>
    55fa:	ee 24       	eor	r14, r14
    55fc:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    55fe:	cb e0       	ldi	r28, 0x0B	; 11
    5600:	d0 e0       	ldi	r29, 0x00	; 0
    5602:	03 c0       	rjmp	.+6      	; 0x560a <SD_write_block+0x5e>
    5604:	21 97       	sbiw	r28, 0x01	; 1
	if (i >= 10) {
    5606:	09 f4       	brne	.+2      	; 0x560a <SD_write_block+0x5e>
    5608:	ff cf       	rjmp	.-2      	; 0x5608 <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    560a:	88 e1       	ldi	r24, 0x18	; 24
    560c:	b5 01       	movw	r22, r10
    560e:	a4 01       	movw	r20, r8
    5610:	2f ef       	ldi	r18, 0xFF	; 255
    5612:	08 e0       	ldi	r16, 0x08	; 8
    5614:	10 e0       	ldi	r17, 0x00	; 0
    5616:	0e 94 9b 29 	call	0x5336	; 0x5336 <SD_command>
    561a:	88 23       	and	r24, r24
    561c:	99 f7       	brne	.-26     	; 0x5604 <SD_write_block+0x58>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    561e:	8f ef       	ldi	r24, 0xFF	; 255
    5620:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5624:	80 93 35 3e 	sts	0x3E35, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    5628:	8e ef       	ldi	r24, 0xFE	; 254
    562a:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    562e:	1c 14       	cp	r1, r12
    5630:	1d 04       	cpc	r1, r13
    5632:	bc f4       	brge	.+46     	; 0x5662 <SD_write_block+0xb6>
    5634:	87 2c       	mov	r8, r7
    5636:	96 2c       	mov	r9, r6
    5638:	00 e0       	ldi	r16, 0x00	; 0
    563a:	10 e0       	ldi	r17, 0x00	; 0
Buffer[i%13] = SPI_write(data[i]);
    563c:	c8 01       	movw	r24, r16
    563e:	6d e0       	ldi	r22, 0x0D	; 13
    5640:	70 e0       	ldi	r23, 0x00	; 0
    5642:	0e 94 50 39 	call	0x72a0	; 0x72a0 <__divmodhi4>
    5646:	ec 01       	movw	r28, r24
    5648:	f4 01       	movw	r30, r8
    564a:	81 91       	ld	r24, Z+
    564c:	4f 01       	movw	r8, r30
    564e:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5652:	cb 5c       	subi	r28, 0xCB	; 203
    5654:	d1 4c       	sbci	r29, 0xC1	; 193
    5656:	88 83       	st	Y, r24
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    5658:	0f 5f       	subi	r16, 0xFF	; 255
    565a:	1f 4f       	sbci	r17, 0xFF	; 255
    565c:	0c 15       	cp	r16, r12
    565e:	1d 05       	cpc	r17, r13
    5660:	69 f7       	brne	.-38     	; 0x563c <SD_write_block+0x90>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5662:	1e 14       	cp	r1, r14
    5664:	1f 04       	cpc	r1, r15
    5666:	ec f4       	brge	.+58     	; 0x56a2 <SD_write_block+0xf6>
    5668:	00 e0       	ldi	r16, 0x00	; 0
    566a:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    566c:	0f 2e       	mov	r0, r31
    566e:	fd e0       	ldi	r31, 0x0D	; 13
    5670:	cf 2e       	mov	r12, r31
    5672:	dd 24       	eor	r13, r13
    5674:	f0 2d       	mov	r31, r0
    5676:	0f 2e       	mov	r0, r31
    5678:	f5 e3       	ldi	r31, 0x35	; 53
    567a:	8f 2e       	mov	r8, r31
    567c:	fe e3       	ldi	r31, 0x3E	; 62
    567e:	9f 2e       	mov	r9, r31
    5680:	f0 2d       	mov	r31, r0
    5682:	c8 01       	movw	r24, r16
    5684:	b6 01       	movw	r22, r12
    5686:	0e 94 50 39 	call	0x72a0	; 0x72a0 <__divmodhi4>
    568a:	ec 01       	movw	r28, r24
    568c:	80 e0       	ldi	r24, 0x00	; 0
    568e:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5692:	c8 0d       	add	r28, r8
    5694:	d9 1d       	adc	r29, r9
    5696:	88 83       	st	Y, r24
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5698:	0f 5f       	subi	r16, 0xFF	; 255
    569a:	1f 4f       	sbci	r17, 0xFF	; 255
    569c:	0e 15       	cp	r16, r14
    569e:	1f 05       	cpc	r17, r15
    56a0:	81 f7       	brne	.-32     	; 0x5682 <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    56a2:	8f ef       	ldi	r24, 0xFF	; 255
    56a4:	80 93 35 3e 	sts	0x3E35, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    56a8:	c0 e0       	ldi	r28, 0x00	; 0
    56aa:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    56ac:	05 e3       	ldi	r16, 0x35	; 53
    56ae:	1e e3       	ldi	r17, 0x3E	; 62
    56b0:	8f ef       	ldi	r24, 0xFF	; 255
    56b2:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    56b6:	f8 01       	movw	r30, r16
    56b8:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    56ba:	21 96       	adiw	r28, 0x01	; 1
    56bc:	c2 30       	cpi	r28, 0x02	; 2
    56be:	d1 05       	cpc	r29, r1
    56c0:	bc f3       	brlt	.-18     	; 0x56b0 <SD_write_block+0x104>
    56c2:	80 81       	ld	r24, Z
    56c4:	8f 3f       	cpi	r24, 0xFF	; 255
    56c6:	a1 f3       	breq	.-24     	; 0x56b0 <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    56c8:	80 91 35 3e 	lds	r24, 0x3E35
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    56cc:	80 91 35 3e 	lds	r24, 0x3E35
    56d0:	8f 3f       	cpi	r24, 0xFF	; 255
    56d2:	49 f0       	breq	.+18     	; 0x56e6 <SD_write_block+0x13a>
    56d4:	c5 e3       	ldi	r28, 0x35	; 53
    56d6:	de e3       	ldi	r29, 0x3E	; 62
    56d8:	8f ef       	ldi	r24, 0xFF	; 255
    56da:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    56de:	88 83       	st	Y, r24
    56e0:	88 81       	ld	r24, Y
    56e2:	8f 3f       	cpi	r24, 0xFF	; 255
    56e4:	c9 f7       	brne	.-14     	; 0x56d8 <SD_write_block+0x12c>
	SPICS(FALSE);
    56e6:	80 e0       	ldi	r24, 0x00	; 0
    56e8:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    56ec:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    56f0:	88 e0       	ldi	r24, 0x08	; 8
    56f2:	60 e0       	ldi	r22, 0x00	; 0
    56f4:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
}
    56f8:	df 91       	pop	r29
    56fa:	cf 91       	pop	r28
    56fc:	1f 91       	pop	r17
    56fe:	0f 91       	pop	r16
    5700:	ff 90       	pop	r15
    5702:	ef 90       	pop	r14
    5704:	df 90       	pop	r13
    5706:	cf 90       	pop	r12
    5708:	bf 90       	pop	r11
    570a:	af 90       	pop	r10
    570c:	9f 90       	pop	r9
    570e:	8f 90       	pop	r8
    5710:	7f 90       	pop	r7
    5712:	6f 90       	pop	r6
    5714:	08 95       	ret

00005716 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    5716:	af 92       	push	r10
    5718:	bf 92       	push	r11
    571a:	cf 92       	push	r12
    571c:	df 92       	push	r13
    571e:	ef 92       	push	r14
    5720:	ff 92       	push	r15
    5722:	0f 93       	push	r16
    5724:	1f 93       	push	r17
    5726:	cf 93       	push	r28
    5728:	df 93       	push	r29
    572a:	6b 01       	movw	r12, r22
    572c:	7c 01       	movw	r14, r24
    572e:	b4 2e       	mov	r11, r20
    5730:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5732:	88 e0       	ldi	r24, 0x08	; 8
    5734:	60 e0       	ldi	r22, 0x00	; 0
    5736:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    573a:	80 e0       	ldi	r24, 0x00	; 0
    573c:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    5740:	81 e0       	ldi	r24, 0x01	; 1
    5742:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5746:	cb e0       	ldi	r28, 0x0B	; 11
    5748:	d0 e0       	ldi	r29, 0x00	; 0
    574a:	03 c0       	rjmp	.+6      	; 0x5752 <SD_read_block+0x3c>
    574c:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    574e:	09 f4       	brne	.+2      	; 0x5752 <SD_read_block+0x3c>
    5750:	ff cf       	rjmp	.-2      	; 0x5750 <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5752:	81 e1       	ldi	r24, 0x11	; 17
    5754:	b7 01       	movw	r22, r14
    5756:	a6 01       	movw	r20, r12
    5758:	2f ef       	ldi	r18, 0xFF	; 255
    575a:	08 e0       	ldi	r16, 0x08	; 8
    575c:	10 e0       	ldi	r17, 0x00	; 0
    575e:	0e 94 9b 29 	call	0x5336	; 0x5336 <SD_command>
    5762:	88 23       	and	r24, r24
    5764:	99 f7       	brne	.-26     	; 0x574c <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    5766:	80 91 35 3e 	lds	r24, 0x3E35
    576a:	8e 3f       	cpi	r24, 0xFE	; 254
    576c:	49 f0       	breq	.+18     	; 0x5780 <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    576e:	c5 e3       	ldi	r28, 0x35	; 53
    5770:	de e3       	ldi	r29, 0x3E	; 62
    5772:	8f ef       	ldi	r24, 0xFF	; 255
    5774:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5778:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    577a:	88 81       	ld	r24, Y
    577c:	8e 3f       	cpi	r24, 0xFE	; 254
    577e:	c9 f7       	brne	.-14     	; 0x5772 <SD_read_block+0x5c>
    5780:	0b 2d       	mov	r16, r11
    5782:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5784:	c0 e0       	ldi	r28, 0x00	; 0
    5786:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5788:	8f ef       	ldi	r24, 0xFF	; 255
    578a:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    578e:	f8 01       	movw	r30, r16
    5790:	81 93       	st	Z+, r24
    5792:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5794:	21 96       	adiw	r28, 0x01	; 1
    5796:	f2 e0       	ldi	r31, 0x02	; 2
    5798:	c0 30       	cpi	r28, 0x00	; 0
    579a:	df 07       	cpc	r29, r31
    579c:	a9 f7       	brne	.-22     	; 0x5788 <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    579e:	10 92 41 3e 	sts	0x3E41, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    57a2:	80 91 41 3e 	lds	r24, 0x3E41
    57a6:	8f 3f       	cpi	r24, 0xFF	; 255
    57a8:	49 f0       	breq	.+18     	; 0x57bc <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    57aa:	c1 e4       	ldi	r28, 0x41	; 65
    57ac:	de e3       	ldi	r29, 0x3E	; 62
    57ae:	8f ef       	ldi	r24, 0xFF	; 255
    57b0:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    57b4:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    57b6:	88 81       	ld	r24, Y
    57b8:	8f 3f       	cpi	r24, 0xFF	; 255
    57ba:	c9 f7       	brne	.-14     	; 0x57ae <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    57bc:	80 e0       	ldi	r24, 0x00	; 0
    57be:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    57c2:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    57c6:	88 e0       	ldi	r24, 0x08	; 8
    57c8:	60 e0       	ldi	r22, 0x00	; 0
    57ca:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
}
    57ce:	df 91       	pop	r29
    57d0:	cf 91       	pop	r28
    57d2:	1f 91       	pop	r17
    57d4:	0f 91       	pop	r16
    57d6:	ff 90       	pop	r15
    57d8:	ef 90       	pop	r14
    57da:	df 90       	pop	r13
    57dc:	cf 90       	pop	r12
    57de:	bf 90       	pop	r11
    57e0:	af 90       	pop	r10
    57e2:	08 95       	ret

000057e4 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    57e4:	2f 92       	push	r2
    57e6:	3f 92       	push	r3
    57e8:	4f 92       	push	r4
    57ea:	5f 92       	push	r5
    57ec:	6f 92       	push	r6
    57ee:	7f 92       	push	r7
    57f0:	8f 92       	push	r8
    57f2:	9f 92       	push	r9
    57f4:	af 92       	push	r10
    57f6:	bf 92       	push	r11
    57f8:	cf 92       	push	r12
    57fa:	df 92       	push	r13
    57fc:	ef 92       	push	r14
    57fe:	ff 92       	push	r15
    5800:	0f 93       	push	r16
    5802:	1f 93       	push	r17
    5804:	cf 93       	push	r28
    5806:	df 93       	push	r29
    5808:	cd b7       	in	r28, 0x3d	; 61
    580a:	de b7       	in	r29, 0x3e	; 62
    580c:	2a 97       	sbiw	r28, 0x0a	; 10
    580e:	cd bf       	out	0x3d, r28	; 61
    5810:	de bf       	out	0x3e, r29	; 62
    5812:	6b 01       	movw	r12, r22
    5814:	7c 01       	movw	r14, r24
    5816:	4f 83       	std	Y+7, r20	; 0x07
    5818:	58 87       	std	Y+8, r21	; 0x08
    581a:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    581c:	88 e0       	ldi	r24, 0x08	; 8
    581e:	60 e0       	ldi	r22, 0x00	; 0
    5820:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5824:	80 e0       	ldi	r24, 0x00	; 0
    5826:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    582a:	81 e0       	ldi	r24, 0x01	; 1
    582c:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    5830:	c8 01       	movw	r24, r16
    5832:	11 23       	and	r17, r17
    5834:	14 f4       	brge	.+4      	; 0x583a <SD_write_multiple_blocks+0x56>
    5836:	81 50       	subi	r24, 0x01	; 1
    5838:	9e 4f       	sbci	r25, 0xFE	; 254
    583a:	9c 01       	movw	r18, r24
    583c:	23 2f       	mov	r18, r19
    583e:	33 0f       	add	r19, r19
    5840:	33 0b       	sbc	r19, r19
    5842:	25 95       	asr	r18
    5844:	2b 83       	std	Y+3, r18	; 0x03
    5846:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    5848:	20 e0       	ldi	r18, 0x00	; 0
    584a:	32 e0       	ldi	r19, 0x02	; 2
    584c:	c8 01       	movw	r24, r16
    584e:	b9 01       	movw	r22, r18
    5850:	0e 94 50 39 	call	0x72a0	; 0x72a0 <__divmodhi4>
    5854:	29 01       	movw	r4, r18
    5856:	48 1a       	sub	r4, r24
    5858:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    585a:	30 e0       	ldi	r19, 0x00	; 0
    585c:	43 16       	cp	r4, r19
    585e:	32 e0       	ldi	r19, 0x02	; 2
    5860:	53 06       	cpc	r5, r19
    5862:	31 f0       	breq	.+12     	; 0x5870 <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    5864:	8b 81       	ldd	r24, Y+3	; 0x03
    5866:	9c 81       	ldd	r25, Y+4	; 0x04
    5868:	01 96       	adiw	r24, 0x01	; 1
    586a:	8b 83       	std	Y+3, r24	; 0x03
    586c:	9c 83       	std	Y+4, r25	; 0x04
    586e:	02 c0       	rjmp	.+4      	; 0x5874 <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5870:	44 24       	eor	r4, r4
    5872:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    5874:	89 e1       	ldi	r24, 0x19	; 25
    5876:	b7 01       	movw	r22, r14
    5878:	a6 01       	movw	r20, r12
    587a:	2f ef       	ldi	r18, 0xFF	; 255
    587c:	08 e0       	ldi	r16, 0x08	; 8
    587e:	10 e0       	ldi	r17, 0x00	; 0
    5880:	0e 94 9b 29 	call	0x5336	; 0x5336 <SD_command>
    5884:	88 23       	and	r24, r24
    5886:	b1 f7       	brne	.-20     	; 0x5874 <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    5888:	eb 81       	ldd	r30, Y+3	; 0x03
    588a:	fc 81       	ldd	r31, Y+4	; 0x04
    588c:	1e 16       	cp	r1, r30
    588e:	1f 06       	cpc	r1, r31
    5890:	0c f0       	brlt	.+2      	; 0x5894 <SD_write_multiple_blocks+0xb0>
    5892:	ac c0       	rjmp	.+344    	; 0x59ec <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5894:	31 97       	sbiw	r30, 0x01	; 1
    5896:	ed 83       	std	Y+5, r30	; 0x05
    5898:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    589a:	9f 01       	movw	r18, r30
    589c:	32 2f       	mov	r19, r18
    589e:	22 27       	eor	r18, r18
    58a0:	33 0f       	add	r19, r19
    58a2:	8f 81       	ldd	r24, Y+7	; 0x07
    58a4:	98 85       	ldd	r25, Y+8	; 0x08
    58a6:	89 83       	std	Y+1, r24	; 0x01
    58a8:	9a 83       	std	Y+2, r25	; 0x02
    58aa:	66 24       	eor	r6, r6
    58ac:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    58ae:	0f 2e       	mov	r0, r31
    58b0:	f6 e3       	ldi	r31, 0x36	; 54
    58b2:	8f 2e       	mov	r8, r31
    58b4:	fe e3       	ldi	r31, 0x3E	; 62
    58b6:	9f 2e       	mov	r9, r31
    58b8:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    58ba:	0f 2e       	mov	r0, r31
    58bc:	fc e0       	ldi	r31, 0x0C	; 12
    58be:	cf 2e       	mov	r12, r31
    58c0:	dd 24       	eor	r13, r13
    58c2:	f0 2d       	mov	r31, r0
    58c4:	0f 2e       	mov	r0, r31
    58c6:	f5 e3       	ldi	r31, 0x35	; 53
    58c8:	af 2e       	mov	r10, r31
    58ca:	fe e3       	ldi	r31, 0x3E	; 62
    58cc:	bf 2e       	mov	r11, r31
    58ce:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    58d0:	80 e0       	ldi	r24, 0x00	; 0
    58d2:	92 e0       	ldi	r25, 0x02	; 2
    58d4:	1c 01       	movw	r2, r24
    58d6:	24 18       	sub	r2, r4
    58d8:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    58da:	ef 81       	ldd	r30, Y+7	; 0x07
    58dc:	f8 85       	ldd	r31, Y+8	; 0x08
    58de:	e2 0f       	add	r30, r18
    58e0:	f3 1f       	adc	r31, r19
    58e2:	ef 83       	std	Y+7, r30	; 0x07
    58e4:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    58e6:	8f ef       	ldi	r24, 0xFF	; 255
    58e8:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    58ec:	f4 01       	movw	r30, r8
    58ee:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    58f0:	8c ef       	ldi	r24, 0xFC	; 252
    58f2:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    58f6:	f4 01       	movw	r30, r8
    58f8:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    58fa:	2d 81       	ldd	r18, Y+5	; 0x05
    58fc:	3e 81       	ldd	r19, Y+6	; 0x06
    58fe:	26 15       	cp	r18, r6
    5900:	37 05       	cpc	r19, r7
    5902:	09 f0       	breq	.+2      	; 0x5906 <SD_write_multiple_blocks+0x122>
    5904:	41 c0       	rjmp	.+130    	; 0x5988 <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5906:	12 14       	cp	r1, r2
    5908:	13 04       	cpc	r1, r3
    590a:	cc f4       	brge	.+50     	; 0x593e <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    590c:	ef 80       	ldd	r14, Y+7	; 0x07
    590e:	f8 84       	ldd	r15, Y+8	; 0x08
    5910:	00 e0       	ldi	r16, 0x00	; 0
    5912:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5914:	c8 01       	movw	r24, r16
    5916:	b6 01       	movw	r22, r12
    5918:	0e 94 50 39 	call	0x72a0	; 0x72a0 <__divmodhi4>
    591c:	89 87       	std	Y+9, r24	; 0x09
    591e:	9a 87       	std	Y+10, r25	; 0x0a
    5920:	f7 01       	movw	r30, r14
    5922:	81 91       	ld	r24, Z+
    5924:	7f 01       	movw	r14, r30
    5926:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    592a:	e9 85       	ldd	r30, Y+9	; 0x09
    592c:	fa 85       	ldd	r31, Y+10	; 0x0a
    592e:	ea 0d       	add	r30, r10
    5930:	fb 1d       	adc	r31, r11
    5932:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5934:	0f 5f       	subi	r16, 0xFF	; 255
    5936:	1f 4f       	sbci	r17, 0xFF	; 255
    5938:	02 15       	cp	r16, r2
    593a:	13 05       	cpc	r17, r3
    593c:	59 f7       	brne	.-42     	; 0x5914 <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    593e:	14 14       	cp	r1, r4
    5940:	15 04       	cpc	r1, r5
    5942:	9c f4       	brge	.+38     	; 0x596a <SD_write_multiple_blocks+0x186>
    5944:	00 e0       	ldi	r16, 0x00	; 0
    5946:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    5948:	c8 01       	movw	r24, r16
    594a:	b6 01       	movw	r22, r12
    594c:	0e 94 50 39 	call	0x72a0	; 0x72a0 <__divmodhi4>
    5950:	7c 01       	movw	r14, r24
    5952:	80 e0       	ldi	r24, 0x00	; 0
    5954:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5958:	f5 01       	movw	r30, r10
    595a:	ee 0d       	add	r30, r14
    595c:	ff 1d       	adc	r31, r15
    595e:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5960:	0f 5f       	subi	r16, 0xFF	; 255
    5962:	1f 4f       	sbci	r17, 0xFF	; 255
    5964:	04 15       	cp	r16, r4
    5966:	15 05       	cpc	r17, r5
    5968:	79 f7       	brne	.-34     	; 0x5948 <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    596a:	8f ef       	ldi	r24, 0xFF	; 255
    596c:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5970:	f4 01       	movw	r30, r8
    5972:	80 83       	st	Z, r24
    5974:	8f ef       	ldi	r24, 0xFF	; 255
    5976:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    597a:	f4 01       	movw	r30, r8
    597c:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    597e:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5980:	80 81       	ld	r24, Z
    5982:	8f 3f       	cpi	r24, 0xFF	; 255
    5984:	e1 f4       	brne	.+56     	; 0x59be <SD_write_multiple_blocks+0x1da>
    5986:	23 c0       	rjmp	.+70     	; 0x59ce <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5988:	e9 80       	ldd	r14, Y+1	; 0x01
    598a:	fa 80       	ldd	r15, Y+2	; 0x02
    598c:	00 e0       	ldi	r16, 0x00	; 0
    598e:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5990:	c8 01       	movw	r24, r16
    5992:	b6 01       	movw	r22, r12
    5994:	0e 94 50 39 	call	0x72a0	; 0x72a0 <__divmodhi4>
    5998:	89 87       	std	Y+9, r24	; 0x09
    599a:	9a 87       	std	Y+10, r25	; 0x0a
    599c:	f7 01       	movw	r30, r14
    599e:	81 91       	ld	r24, Z+
    59a0:	7f 01       	movw	r14, r30
    59a2:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    59a6:	e9 85       	ldd	r30, Y+9	; 0x09
    59a8:	fa 85       	ldd	r31, Y+10	; 0x0a
    59aa:	ea 0d       	add	r30, r10
    59ac:	fb 1d       	adc	r31, r11
    59ae:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    59b0:	0f 5f       	subi	r16, 0xFF	; 255
    59b2:	1f 4f       	sbci	r17, 0xFF	; 255
    59b4:	f2 e0       	ldi	r31, 0x02	; 2
    59b6:	00 30       	cpi	r16, 0x00	; 0
    59b8:	1f 07       	cpc	r17, r31
    59ba:	51 f7       	brne	.-44     	; 0x5990 <SD_write_multiple_blocks+0x1ac>
    59bc:	d6 cf       	rjmp	.-84     	; 0x596a <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    59be:	8f ef       	ldi	r24, 0xFF	; 255
    59c0:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    59c4:	f4 01       	movw	r30, r8
    59c6:	80 83       	st	Z, r24
    59c8:	80 81       	ld	r24, Z
    59ca:	8f 3f       	cpi	r24, 0xFF	; 255
    59cc:	c1 f7       	brne	.-16     	; 0x59be <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    59ce:	08 94       	sec
    59d0:	61 1c       	adc	r6, r1
    59d2:	71 1c       	adc	r7, r1
    59d4:	29 81       	ldd	r18, Y+1	; 0x01
    59d6:	3a 81       	ldd	r19, Y+2	; 0x02
    59d8:	20 50       	subi	r18, 0x00	; 0
    59da:	3e 4f       	sbci	r19, 0xFE	; 254
    59dc:	29 83       	std	Y+1, r18	; 0x01
    59de:	3a 83       	std	Y+2, r19	; 0x02
    59e0:	8b 81       	ldd	r24, Y+3	; 0x03
    59e2:	9c 81       	ldd	r25, Y+4	; 0x04
    59e4:	68 16       	cp	r6, r24
    59e6:	79 06       	cpc	r7, r25
    59e8:	09 f0       	breq	.+2      	; 0x59ec <SD_write_multiple_blocks+0x208>
    59ea:	7d cf       	rjmp	.-262    	; 0x58e6 <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    59ec:	ee 24       	eor	r14, r14
    59ee:	ff 24       	eor	r15, r15
    59f0:	68 94       	set
    59f2:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    59f4:	06 e3       	ldi	r16, 0x36	; 54
    59f6:	1e e3       	ldi	r17, 0x3E	; 62
    59f8:	8f ef       	ldi	r24, 0xFF	; 255
    59fa:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    59fe:	f8 01       	movw	r30, r16
    5a00:	80 83       	st	Z, r24
    5a02:	08 94       	sec
    5a04:	e1 08       	sbc	r14, r1
    5a06:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    5a08:	e1 14       	cp	r14, r1
    5a0a:	f1 04       	cpc	r15, r1
    5a0c:	a9 f7       	brne	.-22     	; 0x59f8 <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    5a0e:	8d ef       	ldi	r24, 0xFD	; 253
    5a10:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5a14:	80 93 36 3e 	sts	0x3E36, r24
    5a18:	ee 24       	eor	r14, r14
    5a1a:	ff 24       	eor	r15, r15
    5a1c:	68 94       	set
    5a1e:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5a20:	06 e3       	ldi	r16, 0x36	; 54
    5a22:	1e e3       	ldi	r17, 0x3E	; 62
    5a24:	8f ef       	ldi	r24, 0xFF	; 255
    5a26:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5a2a:	f8 01       	movw	r30, r16
    5a2c:	80 83       	st	Z, r24
    5a2e:	08 94       	sec
    5a30:	e1 08       	sbc	r14, r1
    5a32:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    5a34:	e1 14       	cp	r14, r1
    5a36:	f1 04       	cpc	r15, r1
    5a38:	a9 f7       	brne	.-22     	; 0x5a24 <SD_write_multiple_blocks+0x240>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    5a3a:	10 92 36 3e 	sts	0x3E36, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5a3e:	80 91 36 3e 	lds	r24, 0x3E36
    5a42:	8f 3f       	cpi	r24, 0xFF	; 255
    5a44:	51 f0       	breq	.+20     	; 0x5a5a <SD_write_multiple_blocks+0x276>
    5a46:	06 e3       	ldi	r16, 0x36	; 54
    5a48:	1e e3       	ldi	r17, 0x3E	; 62
    5a4a:	8f ef       	ldi	r24, 0xFF	; 255
    5a4c:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5a50:	f8 01       	movw	r30, r16
    5a52:	80 83       	st	Z, r24
    5a54:	80 81       	ld	r24, Z
    5a56:	8f 3f       	cpi	r24, 0xFF	; 255
    5a58:	c1 f7       	brne	.-16     	; 0x5a4a <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    5a5a:	80 e0       	ldi	r24, 0x00	; 0
    5a5c:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5a60:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5a64:	88 e0       	ldi	r24, 0x08	; 8
    5a66:	60 e0       	ldi	r22, 0x00	; 0
    5a68:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
}
    5a6c:	2a 96       	adiw	r28, 0x0a	; 10
    5a6e:	cd bf       	out	0x3d, r28	; 61
    5a70:	de bf       	out	0x3e, r29	; 62
    5a72:	df 91       	pop	r29
    5a74:	cf 91       	pop	r28
    5a76:	1f 91       	pop	r17
    5a78:	0f 91       	pop	r16
    5a7a:	ff 90       	pop	r15
    5a7c:	ef 90       	pop	r14
    5a7e:	df 90       	pop	r13
    5a80:	cf 90       	pop	r12
    5a82:	bf 90       	pop	r11
    5a84:	af 90       	pop	r10
    5a86:	9f 90       	pop	r9
    5a88:	8f 90       	pop	r8
    5a8a:	7f 90       	pop	r7
    5a8c:	6f 90       	pop	r6
    5a8e:	5f 90       	pop	r5
    5a90:	4f 90       	pop	r4
    5a92:	3f 90       	pop	r3
    5a94:	2f 90       	pop	r2
    5a96:	08 95       	ret

00005a98 <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    5a98:	2f 92       	push	r2
    5a9a:	3f 92       	push	r3
    5a9c:	4f 92       	push	r4
    5a9e:	5f 92       	push	r5
    5aa0:	6f 92       	push	r6
    5aa2:	7f 92       	push	r7
    5aa4:	8f 92       	push	r8
    5aa6:	9f 92       	push	r9
    5aa8:	af 92       	push	r10
    5aaa:	bf 92       	push	r11
    5aac:	cf 92       	push	r12
    5aae:	df 92       	push	r13
    5ab0:	ef 92       	push	r14
    5ab2:	ff 92       	push	r15
    5ab4:	0f 93       	push	r16
    5ab6:	1f 93       	push	r17
    5ab8:	cf 93       	push	r28
    5aba:	df 93       	push	r29
    5abc:	6b 01       	movw	r12, r22
    5abe:	7c 01       	movw	r14, r24
    5ac0:	c4 2f       	mov	r28, r20
    5ac2:	85 2e       	mov	r8, r21
    5ac4:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5ac6:	88 e0       	ldi	r24, 0x08	; 8
    5ac8:	60 e0       	ldi	r22, 0x00	; 0
    5aca:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5ace:	80 e0       	ldi	r24, 0x00	; 0
    5ad0:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    5ad4:	81 e0       	ldi	r24, 0x01	; 1
    5ad6:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    5ada:	82 e1       	ldi	r24, 0x12	; 18
    5adc:	b7 01       	movw	r22, r14
    5ade:	a6 01       	movw	r20, r12
    5ae0:	2f ef       	ldi	r18, 0xFF	; 255
    5ae2:	08 e0       	ldi	r16, 0x08	; 8
    5ae4:	10 e0       	ldi	r17, 0x00	; 0
    5ae6:	0e 94 9b 29 	call	0x5336	; 0x5336 <SD_command>
    5aea:	88 23       	and	r24, r24
    5aec:	b1 f7       	brne	.-20     	; 0x5ada <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5aee:	16 14       	cp	r1, r6
    5af0:	17 04       	cpc	r1, r7
    5af2:	0c f0       	brlt	.+2      	; 0x5af6 <SD_read_multiple_blocks+0x5e>
    5af4:	46 c0       	rjmp	.+140    	; 0x5b82 <SD_read_multiple_blocks+0xea>
    5af6:	ac 2e       	mov	r10, r28
    5af8:	b8 2c       	mov	r11, r8
    5afa:	88 24       	eor	r8, r8
    5afc:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    5afe:	0f 2e       	mov	r0, r31
    5b00:	f6 e3       	ldi	r31, 0x36	; 54
    5b02:	cf 2e       	mov	r12, r31
    5b04:	fe e3       	ldi	r31, 0x3E	; 62
    5b06:	df 2e       	mov	r13, r31
    5b08:	f0 2d       	mov	r31, r0
    5b0a:	ff 24       	eor	r15, r15
    5b0c:	fa 94       	dec	r15
    5b0e:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5b10:	0f 2e       	mov	r0, r31
    5b12:	f5 e3       	ldi	r31, 0x35	; 53
    5b14:	4f 2e       	mov	r4, r31
    5b16:	fe e3       	ldi	r31, 0x3E	; 62
    5b18:	5f 2e       	mov	r5, r31
    5b1a:	f0 2d       	mov	r31, r0
    5b1c:	12 01       	movw	r2, r4
    5b1e:	08 94       	sec
    5b20:	21 1c       	adc	r2, r1
    5b22:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    5b24:	f6 01       	movw	r30, r12
    5b26:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5b28:	80 81       	ld	r24, Z
    5b2a:	8e 3f       	cpi	r24, 0xFE	; 254
    5b2c:	41 f0       	breq	.+16     	; 0x5b3e <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    5b2e:	8f 2d       	mov	r24, r15
    5b30:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5b34:	f6 01       	movw	r30, r12
    5b36:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5b38:	80 81       	ld	r24, Z
    5b3a:	8e 3f       	cpi	r24, 0xFE	; 254
    5b3c:	c1 f7       	brne	.-16     	; 0x5b2e <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5b3e:	85 01       	movw	r16, r10
    5b40:	c0 e0       	ldi	r28, 0x00	; 0
    5b42:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5b44:	8f 2d       	mov	r24, r15
    5b46:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5b4a:	f8 01       	movw	r30, r16
    5b4c:	81 93       	st	Z+, r24
    5b4e:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5b50:	21 96       	adiw	r28, 0x01	; 1
    5b52:	f2 e0       	ldi	r31, 0x02	; 2
    5b54:	c0 30       	cpi	r28, 0x00	; 0
    5b56:	df 07       	cpc	r29, r31
    5b58:	a9 f7       	brne	.-22     	; 0x5b44 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5b5a:	8f 2d       	mov	r24, r15
    5b5c:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5b60:	f2 01       	movw	r30, r4
    5b62:	80 83       	st	Z, r24
    5b64:	8f 2d       	mov	r24, r15
    5b66:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5b6a:	f1 01       	movw	r30, r2
    5b6c:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5b6e:	08 94       	sec
    5b70:	81 1c       	adc	r8, r1
    5b72:	91 1c       	adc	r9, r1
    5b74:	80 e0       	ldi	r24, 0x00	; 0
    5b76:	92 e0       	ldi	r25, 0x02	; 2
    5b78:	a8 0e       	add	r10, r24
    5b7a:	b9 1e       	adc	r11, r25
    5b7c:	86 14       	cp	r8, r6
    5b7e:	97 04       	cpc	r9, r7
    5b80:	89 f6       	brne	.-94     	; 0x5b24 <SD_read_multiple_blocks+0x8c>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    5b82:	8c e0       	ldi	r24, 0x0C	; 12
    5b84:	40 e0       	ldi	r20, 0x00	; 0
    5b86:	50 e0       	ldi	r21, 0x00	; 0
    5b88:	ba 01       	movw	r22, r20
    5b8a:	2f ef       	ldi	r18, 0xFF	; 255
    5b8c:	08 e0       	ldi	r16, 0x08	; 8
    5b8e:	10 e0       	ldi	r17, 0x00	; 0
    5b90:	0e 94 9b 29 	call	0x5336	; 0x5336 <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    5b94:	8f ef       	ldi	r24, 0xFF	; 255
    5b96:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5b9a:	80 93 35 3e 	sts	0x3E35, r24
	Buffer[1] = FILLER_BYTE;
    5b9e:	10 92 36 3e 	sts	0x3E36, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5ba2:	80 91 36 3e 	lds	r24, 0x3E36
    5ba6:	8f 3f       	cpi	r24, 0xFF	; 255
    5ba8:	49 f0       	breq	.+18     	; 0x5bbc <SD_read_multiple_blocks+0x124>
    5baa:	c6 e3       	ldi	r28, 0x36	; 54
    5bac:	de e3       	ldi	r29, 0x3E	; 62
    5bae:	8f ef       	ldi	r24, 0xFF	; 255
    5bb0:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5bb4:	88 83       	st	Y, r24
    5bb6:	88 81       	ld	r24, Y
    5bb8:	8f 3f       	cpi	r24, 0xFF	; 255
    5bba:	c9 f7       	brne	.-14     	; 0x5bae <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    5bbc:	80 e0       	ldi	r24, 0x00	; 0
    5bbe:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5bc2:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5bc6:	88 e0       	ldi	r24, 0x08	; 8
    5bc8:	60 e0       	ldi	r22, 0x00	; 0
    5bca:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
}
    5bce:	df 91       	pop	r29
    5bd0:	cf 91       	pop	r28
    5bd2:	1f 91       	pop	r17
    5bd4:	0f 91       	pop	r16
    5bd6:	ff 90       	pop	r15
    5bd8:	ef 90       	pop	r14
    5bda:	df 90       	pop	r13
    5bdc:	cf 90       	pop	r12
    5bde:	bf 90       	pop	r11
    5be0:	af 90       	pop	r10
    5be2:	9f 90       	pop	r9
    5be4:	8f 90       	pop	r8
    5be6:	7f 90       	pop	r7
    5be8:	6f 90       	pop	r6
    5bea:	5f 90       	pop	r5
    5bec:	4f 90       	pop	r4
    5bee:	3f 90       	pop	r3
    5bf0:	2f 90       	pop	r2
    5bf2:	08 95       	ret

00005bf4 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    5bf4:	88 e0       	ldi	r24, 0x08	; 8
    5bf6:	60 e0       	ldi	r22, 0x00	; 0
    5bf8:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    5bfc:	88 e0       	ldi	r24, 0x08	; 8
    5bfe:	60 e0       	ldi	r22, 0x00	; 0
    5c00:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    5c04:	80 e0       	ldi	r24, 0x00	; 0
    5c06:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    5c0a:	81 e0       	ldi	r24, 0x01	; 1
    5c0c:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    5c10:	8f ef       	ldi	r24, 0xFF	; 255
    5c12:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPICS(FALSE);	//stop spi
    5c16:	80 e0       	ldi	r24, 0x00	; 0
    5c18:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5c1c:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    5c20:	80 e0       	ldi	r24, 0x00	; 0
    5c22:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    5c26:	80 e0       	ldi	r24, 0x00	; 0
    5c28:	0e 94 61 03 	call	0x6c2	; 0x6c2 <Ext1Power>
}
    5c2c:	08 95       	ret

00005c2e <__muldi3>:
    5c2e:	a0 e3       	ldi	r26, 0x30	; 48
    5c30:	b0 e0       	ldi	r27, 0x00	; 0
    5c32:	ed e1       	ldi	r30, 0x1D	; 29
    5c34:	fe e2       	ldi	r31, 0x2E	; 46
    5c36:	0c 94 b6 39 	jmp	0x736c	; 0x736c <__prologue_saves__+0x4>
    5c3a:	29 8f       	std	Y+25, r18	; 0x19
    5c3c:	3a 8f       	std	Y+26, r19	; 0x1a
    5c3e:	4b 8f       	std	Y+27, r20	; 0x1b
    5c40:	5c 8f       	std	Y+28, r21	; 0x1c
    5c42:	6d 8f       	std	Y+29, r22	; 0x1d
    5c44:	7e 8f       	std	Y+30, r23	; 0x1e
    5c46:	8f 8f       	std	Y+31, r24	; 0x1f
    5c48:	98 a3       	lds	r25, 0x58
    5c4a:	a9 8a       	std	Y+17, r10	; 0x11
    5c4c:	ba 8a       	std	Y+18, r11	; 0x12
    5c4e:	cb 8a       	std	Y+19, r12	; 0x13
    5c50:	dc 8a       	std	Y+20, r13	; 0x14
    5c52:	ed 8a       	std	Y+21, r14	; 0x15
    5c54:	fe 8a       	std	Y+22, r15	; 0x16
    5c56:	0f 8b       	std	Y+23, r16	; 0x17
    5c58:	18 8f       	std	Y+24, r17	; 0x18
    5c5a:	09 8d       	ldd	r16, Y+25	; 0x19
    5c5c:	1a 8d       	ldd	r17, Y+26	; 0x1a
    5c5e:	2b 8d       	ldd	r18, Y+27	; 0x1b
    5c60:	3c 8d       	ldd	r19, Y+28	; 0x1c
    5c62:	09 a3       	lds	r16, 0x59
    5c64:	1a a3       	lds	r17, 0x5a
    5c66:	2b a3       	lds	r18, 0x5b
    5c68:	3c a3       	lds	r19, 0x5c
    5c6a:	68 01       	movw	r12, r16
    5c6c:	79 01       	movw	r14, r18
    5c6e:	8f ef       	ldi	r24, 0xFF	; 255
    5c70:	9f ef       	ldi	r25, 0xFF	; 255
    5c72:	a0 e0       	ldi	r26, 0x00	; 0
    5c74:	b0 e0       	ldi	r27, 0x00	; 0
    5c76:	c8 22       	and	r12, r24
    5c78:	d9 22       	and	r13, r25
    5c7a:	ea 22       	and	r14, r26
    5c7c:	fb 22       	and	r15, r27
    5c7e:	89 01       	movw	r16, r18
    5c80:	22 27       	eor	r18, r18
    5c82:	33 27       	eor	r19, r19
    5c84:	09 a7       	lds	r16, 0x79
    5c86:	1a a7       	lds	r17, 0x7a
    5c88:	2b a7       	lds	r18, 0x7b
    5c8a:	3c a7       	lds	r19, 0x7c
    5c8c:	09 89       	ldd	r16, Y+17	; 0x11
    5c8e:	1a 89       	ldd	r17, Y+18	; 0x12
    5c90:	2b 89       	ldd	r18, Y+19	; 0x13
    5c92:	3c 89       	ldd	r19, Y+20	; 0x14
    5c94:	0d a3       	lds	r16, 0x5d
    5c96:	1e a3       	lds	r17, 0x5e
    5c98:	2f a3       	lds	r18, 0x5f
    5c9a:	38 a7       	lds	r19, 0x78
    5c9c:	48 01       	movw	r8, r16
    5c9e:	59 01       	movw	r10, r18
    5ca0:	88 22       	and	r8, r24
    5ca2:	99 22       	and	r9, r25
    5ca4:	aa 22       	and	r10, r26
    5ca6:	bb 22       	and	r11, r27
    5ca8:	29 01       	movw	r4, r18
    5caa:	66 24       	eor	r6, r6
    5cac:	77 24       	eor	r7, r7
    5cae:	c5 01       	movw	r24, r10
    5cb0:	b4 01       	movw	r22, r8
    5cb2:	a7 01       	movw	r20, r14
    5cb4:	96 01       	movw	r18, r12
    5cb6:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    5cba:	6d a7       	lds	r22, 0x7d
    5cbc:	7e a7       	lds	r23, 0x7e
    5cbe:	8f a7       	lds	r24, 0x7f
    5cc0:	98 ab       	sts	0x58, r25
    5cc2:	c3 01       	movw	r24, r6
    5cc4:	b2 01       	movw	r22, r4
    5cc6:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    5cca:	6b 01       	movw	r12, r22
    5ccc:	7c 01       	movw	r14, r24
    5cce:	c5 01       	movw	r24, r10
    5cd0:	b4 01       	movw	r22, r8
    5cd2:	29 a5       	lds	r18, 0x69
    5cd4:	3a a5       	lds	r19, 0x6a
    5cd6:	4b a5       	lds	r20, 0x6b
    5cd8:	5c a5       	lds	r21, 0x6c
    5cda:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    5cde:	4b 01       	movw	r8, r22
    5ce0:	5c 01       	movw	r10, r24
    5ce2:	c3 01       	movw	r24, r6
    5ce4:	b2 01       	movw	r22, r4
    5ce6:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    5cea:	ab 01       	movw	r20, r22
    5cec:	bc 01       	movw	r22, r24
    5cee:	c8 0c       	add	r12, r8
    5cf0:	d9 1c       	adc	r13, r9
    5cf2:	ea 1c       	adc	r14, r10
    5cf4:	fb 1c       	adc	r15, r11
    5cf6:	0d a5       	lds	r16, 0x6d
    5cf8:	1e a5       	lds	r17, 0x6e
    5cfa:	2f a5       	lds	r18, 0x6f
    5cfc:	38 a9       	sts	0x48, r19
    5cfe:	c9 01       	movw	r24, r18
    5d00:	aa 27       	eor	r26, r26
    5d02:	bb 27       	eor	r27, r27
    5d04:	c8 0e       	add	r12, r24
    5d06:	d9 1e       	adc	r13, r25
    5d08:	ea 1e       	adc	r14, r26
    5d0a:	fb 1e       	adc	r15, r27
    5d0c:	c8 14       	cp	r12, r8
    5d0e:	d9 04       	cpc	r13, r9
    5d10:	ea 04       	cpc	r14, r10
    5d12:	fb 04       	cpc	r15, r11
    5d14:	20 f4       	brcc	.+8      	; 0x5d1e <__muldi3+0xf0>
    5d16:	40 50       	subi	r20, 0x00	; 0
    5d18:	50 40       	sbci	r21, 0x00	; 0
    5d1a:	6f 4f       	sbci	r22, 0xFF	; 255
    5d1c:	7f 4f       	sbci	r23, 0xFF	; 255
    5d1e:	c7 01       	movw	r24, r14
    5d20:	aa 27       	eor	r26, r26
    5d22:	bb 27       	eor	r27, r27
    5d24:	84 0f       	add	r24, r20
    5d26:	95 1f       	adc	r25, r21
    5d28:	a6 1f       	adc	r26, r22
    5d2a:	b7 1f       	adc	r27, r23
    5d2c:	8d 83       	std	Y+5, r24	; 0x05
    5d2e:	9e 83       	std	Y+6, r25	; 0x06
    5d30:	af 83       	std	Y+7, r26	; 0x07
    5d32:	b8 87       	std	Y+8, r27	; 0x08
    5d34:	76 01       	movw	r14, r12
    5d36:	dd 24       	eor	r13, r13
    5d38:	cc 24       	eor	r12, r12
    5d3a:	4d a5       	lds	r20, 0x6d
    5d3c:	5e a5       	lds	r21, 0x6e
    5d3e:	6f a5       	lds	r22, 0x6f
    5d40:	78 a9       	sts	0x48, r23
    5d42:	60 70       	andi	r22, 0x00	; 0
    5d44:	70 70       	andi	r23, 0x00	; 0
    5d46:	c4 0e       	add	r12, r20
    5d48:	d5 1e       	adc	r13, r21
    5d4a:	e6 1e       	adc	r14, r22
    5d4c:	f7 1e       	adc	r15, r23
    5d4e:	c9 82       	std	Y+1, r12	; 0x01
    5d50:	da 82       	std	Y+2, r13	; 0x02
    5d52:	eb 82       	std	Y+3, r14	; 0x03
    5d54:	fc 82       	std	Y+4, r15	; 0x04
    5d56:	1c 2d       	mov	r17, r12
    5d58:	0a 81       	ldd	r16, Y+2	; 0x02
    5d5a:	8b 80       	ldd	r8, Y+3	; 0x03
    5d5c:	4c 80       	ldd	r4, Y+4	; 0x04
    5d5e:	8d 87       	std	Y+13, r24	; 0x0d
    5d60:	8e 81       	ldd	r24, Y+6	; 0x06
    5d62:	8e 87       	std	Y+14, r24	; 0x0e
    5d64:	8f 81       	ldd	r24, Y+7	; 0x07
    5d66:	8f 87       	std	Y+15, r24	; 0x0f
    5d68:	88 85       	ldd	r24, Y+8	; 0x08
    5d6a:	88 8b       	std	Y+16, r24	; 0x10
    5d6c:	2d 89       	ldd	r18, Y+21	; 0x15
    5d6e:	3e 89       	ldd	r19, Y+22	; 0x16
    5d70:	4f 89       	ldd	r20, Y+23	; 0x17
    5d72:	58 8d       	ldd	r21, Y+24	; 0x18
    5d74:	69 a1       	lds	r22, 0x49
    5d76:	7a a1       	lds	r23, 0x4a
    5d78:	8b a1       	lds	r24, 0x4b
    5d7a:	9c a1       	lds	r25, 0x4c
    5d7c:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    5d80:	6b 01       	movw	r12, r22
    5d82:	7c 01       	movw	r14, r24
    5d84:	2d 8d       	ldd	r18, Y+29	; 0x1d
    5d86:	3e 8d       	ldd	r19, Y+30	; 0x1e
    5d88:	4f 8d       	ldd	r20, Y+31	; 0x1f
    5d8a:	58 a1       	lds	r21, 0x48
    5d8c:	6d a1       	lds	r22, 0x4d
    5d8e:	7e a1       	lds	r23, 0x4e
    5d90:	8f a1       	lds	r24, 0x4f
    5d92:	98 a5       	lds	r25, 0x68
    5d94:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    5d98:	dc 01       	movw	r26, r24
    5d9a:	cb 01       	movw	r24, r22
    5d9c:	c8 0e       	add	r12, r24
    5d9e:	d9 1e       	adc	r13, r25
    5da0:	ea 1e       	adc	r14, r26
    5da2:	fb 1e       	adc	r15, r27
    5da4:	8d 85       	ldd	r24, Y+13	; 0x0d
    5da6:	9e 85       	ldd	r25, Y+14	; 0x0e
    5da8:	af 85       	ldd	r26, Y+15	; 0x0f
    5daa:	b8 89       	ldd	r27, Y+16	; 0x10
    5dac:	8c 0d       	add	r24, r12
    5dae:	9d 1d       	adc	r25, r13
    5db0:	ae 1d       	adc	r26, r14
    5db2:	bf 1d       	adc	r27, r15
    5db4:	8d 87       	std	Y+13, r24	; 0x0d
    5db6:	9e 87       	std	Y+14, r25	; 0x0e
    5db8:	af 87       	std	Y+15, r26	; 0x0f
    5dba:	b8 8b       	std	Y+16, r27	; 0x10
    5dbc:	68 2f       	mov	r22, r24
    5dbe:	7e 85       	ldd	r23, Y+14	; 0x0e
    5dc0:	21 2f       	mov	r18, r17
    5dc2:	30 2f       	mov	r19, r16
    5dc4:	48 2d       	mov	r20, r8
    5dc6:	54 2d       	mov	r21, r4
    5dc8:	8f 85       	ldd	r24, Y+15	; 0x0f
    5dca:	98 89       	ldd	r25, Y+16	; 0x10
    5dcc:	e0 96       	adiw	r28, 0x30	; 48
    5dce:	e0 e1       	ldi	r30, 0x10	; 16
    5dd0:	0c 94 cf 39 	jmp	0x739e	; 0x739e <__epilogue_restores__+0x4>

00005dd4 <__ashldi3>:
    5dd4:	cf 92       	push	r12
    5dd6:	df 92       	push	r13
    5dd8:	ef 92       	push	r14
    5dda:	ff 92       	push	r15
    5ddc:	0f 93       	push	r16
    5dde:	cf 93       	push	r28
    5de0:	df 93       	push	r29
    5de2:	cd b7       	in	r28, 0x3d	; 61
    5de4:	de b7       	in	r29, 0x3e	; 62
    5de6:	60 97       	sbiw	r28, 0x10	; 16
    5de8:	cd bf       	out	0x3d, r28	; 61
    5dea:	de bf       	out	0x3e, r29	; 62
    5dec:	00 23       	and	r16, r16
    5dee:	09 f4       	brne	.+2      	; 0x5df2 <__ashldi3+0x1e>
    5df0:	5a c0       	rjmp	.+180    	; 0x5ea6 <__ashldi3+0xd2>
    5df2:	29 87       	std	Y+9, r18	; 0x09
    5df4:	3a 87       	std	Y+10, r19	; 0x0a
    5df6:	4b 87       	std	Y+11, r20	; 0x0b
    5df8:	5c 87       	std	Y+12, r21	; 0x0c
    5dfa:	6d 87       	std	Y+13, r22	; 0x0d
    5dfc:	7e 87       	std	Y+14, r23	; 0x0e
    5dfe:	8f 87       	std	Y+15, r24	; 0x0f
    5e00:	98 8b       	std	Y+16, r25	; 0x10
    5e02:	80 e2       	ldi	r24, 0x20	; 32
    5e04:	80 1b       	sub	r24, r16
    5e06:	49 85       	ldd	r20, Y+9	; 0x09
    5e08:	5a 85       	ldd	r21, Y+10	; 0x0a
    5e0a:	6b 85       	ldd	r22, Y+11	; 0x0b
    5e0c:	7c 85       	ldd	r23, Y+12	; 0x0c
    5e0e:	18 16       	cp	r1, r24
    5e10:	b4 f0       	brlt	.+44     	; 0x5e3e <__ashldi3+0x6a>
    5e12:	19 82       	std	Y+1, r1	; 0x01
    5e14:	1a 82       	std	Y+2, r1	; 0x02
    5e16:	1b 82       	std	Y+3, r1	; 0x03
    5e18:	1c 82       	std	Y+4, r1	; 0x04
    5e1a:	99 27       	eor	r25, r25
    5e1c:	87 fd       	sbrc	r24, 7
    5e1e:	90 95       	com	r25
    5e20:	90 95       	com	r25
    5e22:	81 95       	neg	r24
    5e24:	9f 4f       	sbci	r25, 0xFF	; 255
    5e26:	04 c0       	rjmp	.+8      	; 0x5e30 <__ashldi3+0x5c>
    5e28:	44 0f       	add	r20, r20
    5e2a:	55 1f       	adc	r21, r21
    5e2c:	66 1f       	adc	r22, r22
    5e2e:	77 1f       	adc	r23, r23
    5e30:	8a 95       	dec	r24
    5e32:	d2 f7       	brpl	.-12     	; 0x5e28 <__ashldi3+0x54>
    5e34:	4d 83       	std	Y+5, r20	; 0x05
    5e36:	5e 83       	std	Y+6, r21	; 0x06
    5e38:	6f 83       	std	Y+7, r22	; 0x07
    5e3a:	78 87       	std	Y+8, r23	; 0x08
    5e3c:	2c c0       	rjmp	.+88     	; 0x5e96 <__ashldi3+0xc2>
    5e3e:	6a 01       	movw	r12, r20
    5e40:	7b 01       	movw	r14, r22
    5e42:	00 2e       	mov	r0, r16
    5e44:	04 c0       	rjmp	.+8      	; 0x5e4e <__ashldi3+0x7a>
    5e46:	cc 0c       	add	r12, r12
    5e48:	dd 1c       	adc	r13, r13
    5e4a:	ee 1c       	adc	r14, r14
    5e4c:	ff 1c       	adc	r15, r15
    5e4e:	0a 94       	dec	r0
    5e50:	d2 f7       	brpl	.-12     	; 0x5e46 <__ashldi3+0x72>
    5e52:	c9 82       	std	Y+1, r12	; 0x01
    5e54:	da 82       	std	Y+2, r13	; 0x02
    5e56:	eb 82       	std	Y+3, r14	; 0x03
    5e58:	fc 82       	std	Y+4, r15	; 0x04
    5e5a:	6a 01       	movw	r12, r20
    5e5c:	7b 01       	movw	r14, r22
    5e5e:	04 c0       	rjmp	.+8      	; 0x5e68 <__ashldi3+0x94>
    5e60:	f6 94       	lsr	r15
    5e62:	e7 94       	ror	r14
    5e64:	d7 94       	ror	r13
    5e66:	c7 94       	ror	r12
    5e68:	8a 95       	dec	r24
    5e6a:	d2 f7       	brpl	.-12     	; 0x5e60 <__ashldi3+0x8c>
    5e6c:	d7 01       	movw	r26, r14
    5e6e:	c6 01       	movw	r24, r12
    5e70:	4d 85       	ldd	r20, Y+13	; 0x0d
    5e72:	5e 85       	ldd	r21, Y+14	; 0x0e
    5e74:	6f 85       	ldd	r22, Y+15	; 0x0f
    5e76:	78 89       	ldd	r23, Y+16	; 0x10
    5e78:	04 c0       	rjmp	.+8      	; 0x5e82 <__ashldi3+0xae>
    5e7a:	44 0f       	add	r20, r20
    5e7c:	55 1f       	adc	r21, r21
    5e7e:	66 1f       	adc	r22, r22
    5e80:	77 1f       	adc	r23, r23
    5e82:	0a 95       	dec	r16
    5e84:	d2 f7       	brpl	.-12     	; 0x5e7a <__ashldi3+0xa6>
    5e86:	84 2b       	or	r24, r20
    5e88:	95 2b       	or	r25, r21
    5e8a:	a6 2b       	or	r26, r22
    5e8c:	b7 2b       	or	r27, r23
    5e8e:	8d 83       	std	Y+5, r24	; 0x05
    5e90:	9e 83       	std	Y+6, r25	; 0x06
    5e92:	af 83       	std	Y+7, r26	; 0x07
    5e94:	b8 87       	std	Y+8, r27	; 0x08
    5e96:	29 81       	ldd	r18, Y+1	; 0x01
    5e98:	3a 81       	ldd	r19, Y+2	; 0x02
    5e9a:	4b 81       	ldd	r20, Y+3	; 0x03
    5e9c:	5c 81       	ldd	r21, Y+4	; 0x04
    5e9e:	6d 81       	ldd	r22, Y+5	; 0x05
    5ea0:	7e 81       	ldd	r23, Y+6	; 0x06
    5ea2:	8f 81       	ldd	r24, Y+7	; 0x07
    5ea4:	98 85       	ldd	r25, Y+8	; 0x08
    5ea6:	60 96       	adiw	r28, 0x10	; 16
    5ea8:	cd bf       	out	0x3d, r28	; 61
    5eaa:	de bf       	out	0x3e, r29	; 62
    5eac:	df 91       	pop	r29
    5eae:	cf 91       	pop	r28
    5eb0:	0f 91       	pop	r16
    5eb2:	ff 90       	pop	r15
    5eb4:	ef 90       	pop	r14
    5eb6:	df 90       	pop	r13
    5eb8:	cf 90       	pop	r12
    5eba:	08 95       	ret

00005ebc <__ashrdi3>:
    5ebc:	0f 93       	push	r16
    5ebe:	cf 93       	push	r28
    5ec0:	df 93       	push	r29
    5ec2:	cd b7       	in	r28, 0x3d	; 61
    5ec4:	de b7       	in	r29, 0x3e	; 62
    5ec6:	60 97       	sbiw	r28, 0x10	; 16
    5ec8:	cd bf       	out	0x3d, r28	; 61
    5eca:	de bf       	out	0x3e, r29	; 62
    5ecc:	00 23       	and	r16, r16
    5ece:	09 f4       	brne	.+2      	; 0x5ed2 <__ashrdi3+0x16>
    5ed0:	56 c0       	rjmp	.+172    	; 0x5f7e <__ashrdi3+0xc2>
    5ed2:	29 87       	std	Y+9, r18	; 0x09
    5ed4:	3a 87       	std	Y+10, r19	; 0x0a
    5ed6:	4b 87       	std	Y+11, r20	; 0x0b
    5ed8:	5c 87       	std	Y+12, r21	; 0x0c
    5eda:	6d 87       	std	Y+13, r22	; 0x0d
    5edc:	7e 87       	std	Y+14, r23	; 0x0e
    5ede:	8f 87       	std	Y+15, r24	; 0x0f
    5ee0:	98 8b       	std	Y+16, r25	; 0x10
    5ee2:	20 e2       	ldi	r18, 0x20	; 32
    5ee4:	20 1b       	sub	r18, r16
    5ee6:	8d 85       	ldd	r24, Y+13	; 0x0d
    5ee8:	9e 85       	ldd	r25, Y+14	; 0x0e
    5eea:	af 85       	ldd	r26, Y+15	; 0x0f
    5eec:	b8 89       	ldd	r27, Y+16	; 0x10
    5eee:	ac 01       	movw	r20, r24
    5ef0:	bd 01       	movw	r22, r26
    5ef2:	12 16       	cp	r1, r18
    5ef4:	b4 f0       	brlt	.+44     	; 0x5f22 <__ashrdi3+0x66>
    5ef6:	77 0f       	add	r23, r23
    5ef8:	44 0b       	sbc	r20, r20
    5efa:	54 2f       	mov	r21, r20
    5efc:	ba 01       	movw	r22, r20
    5efe:	4d 83       	std	Y+5, r20	; 0x05
    5f00:	5e 83       	std	Y+6, r21	; 0x06
    5f02:	6f 83       	std	Y+7, r22	; 0x07
    5f04:	78 87       	std	Y+8, r23	; 0x08
    5f06:	33 27       	eor	r19, r19
    5f08:	27 fd       	sbrc	r18, 7
    5f0a:	30 95       	com	r19
    5f0c:	30 95       	com	r19
    5f0e:	21 95       	neg	r18
    5f10:	3f 4f       	sbci	r19, 0xFF	; 255
    5f12:	04 c0       	rjmp	.+8      	; 0x5f1c <__ashrdi3+0x60>
    5f14:	b5 95       	asr	r27
    5f16:	a7 95       	ror	r26
    5f18:	97 95       	ror	r25
    5f1a:	87 95       	ror	r24
    5f1c:	2a 95       	dec	r18
    5f1e:	d2 f7       	brpl	.-12     	; 0x5f14 <__ashrdi3+0x58>
    5f20:	22 c0       	rjmp	.+68     	; 0x5f66 <__ashrdi3+0xaa>
    5f22:	00 2e       	mov	r0, r16
    5f24:	04 c0       	rjmp	.+8      	; 0x5f2e <__ashrdi3+0x72>
    5f26:	75 95       	asr	r23
    5f28:	67 95       	ror	r22
    5f2a:	57 95       	ror	r21
    5f2c:	47 95       	ror	r20
    5f2e:	0a 94       	dec	r0
    5f30:	d2 f7       	brpl	.-12     	; 0x5f26 <__ashrdi3+0x6a>
    5f32:	4d 83       	std	Y+5, r20	; 0x05
    5f34:	5e 83       	std	Y+6, r21	; 0x06
    5f36:	6f 83       	std	Y+7, r22	; 0x07
    5f38:	78 87       	std	Y+8, r23	; 0x08
    5f3a:	04 c0       	rjmp	.+8      	; 0x5f44 <__ashrdi3+0x88>
    5f3c:	88 0f       	add	r24, r24
    5f3e:	99 1f       	adc	r25, r25
    5f40:	aa 1f       	adc	r26, r26
    5f42:	bb 1f       	adc	r27, r27
    5f44:	2a 95       	dec	r18
    5f46:	d2 f7       	brpl	.-12     	; 0x5f3c <__ashrdi3+0x80>
    5f48:	49 85       	ldd	r20, Y+9	; 0x09
    5f4a:	5a 85       	ldd	r21, Y+10	; 0x0a
    5f4c:	6b 85       	ldd	r22, Y+11	; 0x0b
    5f4e:	7c 85       	ldd	r23, Y+12	; 0x0c
    5f50:	04 c0       	rjmp	.+8      	; 0x5f5a <__ashrdi3+0x9e>
    5f52:	76 95       	lsr	r23
    5f54:	67 95       	ror	r22
    5f56:	57 95       	ror	r21
    5f58:	47 95       	ror	r20
    5f5a:	0a 95       	dec	r16
    5f5c:	d2 f7       	brpl	.-12     	; 0x5f52 <__ashrdi3+0x96>
    5f5e:	84 2b       	or	r24, r20
    5f60:	95 2b       	or	r25, r21
    5f62:	a6 2b       	or	r26, r22
    5f64:	b7 2b       	or	r27, r23
    5f66:	89 83       	std	Y+1, r24	; 0x01
    5f68:	9a 83       	std	Y+2, r25	; 0x02
    5f6a:	ab 83       	std	Y+3, r26	; 0x03
    5f6c:	bc 83       	std	Y+4, r27	; 0x04
    5f6e:	29 81       	ldd	r18, Y+1	; 0x01
    5f70:	3a 81       	ldd	r19, Y+2	; 0x02
    5f72:	4b 81       	ldd	r20, Y+3	; 0x03
    5f74:	5c 81       	ldd	r21, Y+4	; 0x04
    5f76:	6d 81       	ldd	r22, Y+5	; 0x05
    5f78:	7e 81       	ldd	r23, Y+6	; 0x06
    5f7a:	8f 81       	ldd	r24, Y+7	; 0x07
    5f7c:	98 85       	ldd	r25, Y+8	; 0x08
    5f7e:	60 96       	adiw	r28, 0x10	; 16
    5f80:	cd bf       	out	0x3d, r28	; 61
    5f82:	de bf       	out	0x3e, r29	; 62
    5f84:	df 91       	pop	r29
    5f86:	cf 91       	pop	r28
    5f88:	0f 91       	pop	r16
    5f8a:	08 95       	ret

00005f8c <__divdi3>:
    5f8c:	a8 e4       	ldi	r26, 0x48	; 72
    5f8e:	b0 e0       	ldi	r27, 0x00	; 0
    5f90:	ec ec       	ldi	r30, 0xCC	; 204
    5f92:	ff e2       	ldi	r31, 0x2F	; 47
    5f94:	0c 94 b5 39 	jmp	0x736a	; 0x736a <__prologue_saves__+0x2>
    5f98:	f5 01       	movw	r30, r10
    5f9a:	29 a3       	lds	r18, 0x59
    5f9c:	3a a3       	lds	r19, 0x5a
    5f9e:	4b a3       	lds	r20, 0x5b
    5fa0:	5c a3       	lds	r21, 0x5c
    5fa2:	6d a3       	lds	r22, 0x5d
    5fa4:	7e a3       	lds	r23, 0x5e
    5fa6:	8f a3       	lds	r24, 0x5f
    5fa8:	98 a7       	lds	r25, 0x78
    5faa:	a9 8e       	std	Y+25, r10	; 0x19
    5fac:	fa 8f       	std	Y+26, r31	; 0x1a
    5fae:	cb 8e       	std	Y+27, r12	; 0x1b
    5fb0:	dc 8e       	std	Y+28, r13	; 0x1c
    5fb2:	ed 8e       	std	Y+29, r14	; 0x1d
    5fb4:	fe 8e       	std	Y+30, r15	; 0x1e
    5fb6:	0f 8f       	std	Y+31, r16	; 0x1f
    5fb8:	18 a3       	lds	r17, 0x58
    5fba:	8d a0       	lds	r24, 0x8d
    5fbc:	9e a0       	lds	r25, 0x8e
    5fbe:	af a0       	lds	r26, 0x8f
    5fc0:	b8 a4       	lds	r27, 0xa8
    5fc2:	b7 fe       	sbrs	r11, 7
    5fc4:	67 c0       	rjmp	.+206    	; 0x6094 <__stack+0x95>
    5fc6:	21 95       	neg	r18
    5fc8:	b1 e0       	ldi	r27, 0x01	; 1
    5fca:	12 16       	cp	r1, r18
    5fcc:	08 f0       	brcs	.+2      	; 0x5fd0 <__divdi3+0x44>
    5fce:	b0 e0       	ldi	r27, 0x00	; 0
    5fd0:	31 95       	neg	r19
    5fd2:	a1 e0       	ldi	r26, 0x01	; 1
    5fd4:	13 16       	cp	r1, r19
    5fd6:	08 f0       	brcs	.+2      	; 0x5fda <__divdi3+0x4e>
    5fd8:	a0 e0       	ldi	r26, 0x00	; 0
    5fda:	b3 2e       	mov	r11, r19
    5fdc:	bb 1a       	sub	r11, r27
    5fde:	bb 2d       	mov	r27, r11
    5fe0:	88 24       	eor	r8, r8
    5fe2:	83 94       	inc	r8
    5fe4:	3b 15       	cp	r19, r11
    5fe6:	08 f0       	brcs	.+2      	; 0x5fea <__divdi3+0x5e>
    5fe8:	88 24       	eor	r8, r8
    5fea:	a8 29       	or	r26, r8
    5fec:	41 95       	neg	r20
    5fee:	31 e0       	ldi	r19, 0x01	; 1
    5ff0:	14 16       	cp	r1, r20
    5ff2:	08 f0       	brcs	.+2      	; 0x5ff6 <__divdi3+0x6a>
    5ff4:	30 e0       	ldi	r19, 0x00	; 0
    5ff6:	b4 2e       	mov	r11, r20
    5ff8:	ba 1a       	sub	r11, r26
    5ffa:	ab 2d       	mov	r26, r11
    5ffc:	88 24       	eor	r8, r8
    5ffe:	83 94       	inc	r8
    6000:	4b 15       	cp	r20, r11
    6002:	08 f0       	brcs	.+2      	; 0x6006 <__stack+0x7>
    6004:	88 24       	eor	r8, r8
    6006:	38 29       	or	r19, r8
    6008:	51 95       	neg	r21
    600a:	41 e0       	ldi	r20, 0x01	; 1
    600c:	15 16       	cp	r1, r21
    600e:	08 f0       	brcs	.+2      	; 0x6012 <__stack+0x13>
    6010:	40 e0       	ldi	r20, 0x00	; 0
    6012:	45 2e       	mov	r4, r21
    6014:	43 1a       	sub	r4, r19
    6016:	31 e0       	ldi	r19, 0x01	; 1
    6018:	54 15       	cp	r21, r4
    601a:	08 f0       	brcs	.+2      	; 0x601e <__stack+0x1f>
    601c:	30 e0       	ldi	r19, 0x00	; 0
    601e:	43 2b       	or	r20, r19
    6020:	61 95       	neg	r22
    6022:	31 e0       	ldi	r19, 0x01	; 1
    6024:	16 16       	cp	r1, r22
    6026:	08 f0       	brcs	.+2      	; 0x602a <__stack+0x2b>
    6028:	30 e0       	ldi	r19, 0x00	; 0
    602a:	86 2e       	mov	r8, r22
    602c:	84 1a       	sub	r8, r20
    602e:	41 e0       	ldi	r20, 0x01	; 1
    6030:	68 15       	cp	r22, r8
    6032:	08 f0       	brcs	.+2      	; 0x6036 <__stack+0x37>
    6034:	40 e0       	ldi	r20, 0x00	; 0
    6036:	34 2b       	or	r19, r20
    6038:	71 95       	neg	r23
    603a:	41 e0       	ldi	r20, 0x01	; 1
    603c:	17 16       	cp	r1, r23
    603e:	08 f0       	brcs	.+2      	; 0x6042 <__stack+0x43>
    6040:	40 e0       	ldi	r20, 0x00	; 0
    6042:	57 2f       	mov	r21, r23
    6044:	53 1b       	sub	r21, r19
    6046:	31 e0       	ldi	r19, 0x01	; 1
    6048:	75 17       	cp	r23, r21
    604a:	08 f0       	brcs	.+2      	; 0x604e <__stack+0x4f>
    604c:	30 e0       	ldi	r19, 0x00	; 0
    604e:	43 2b       	or	r20, r19
    6050:	81 95       	neg	r24
    6052:	31 e0       	ldi	r19, 0x01	; 1
    6054:	18 16       	cp	r1, r24
    6056:	08 f0       	brcs	.+2      	; 0x605a <__stack+0x5b>
    6058:	30 e0       	ldi	r19, 0x00	; 0
    605a:	68 2f       	mov	r22, r24
    605c:	64 1b       	sub	r22, r20
    605e:	46 2f       	mov	r20, r22
    6060:	61 e0       	ldi	r22, 0x01	; 1
    6062:	84 17       	cp	r24, r20
    6064:	08 f0       	brcs	.+2      	; 0x6068 <__stack+0x69>
    6066:	60 e0       	ldi	r22, 0x00	; 0
    6068:	36 2b       	or	r19, r22
    606a:	91 95       	neg	r25
    606c:	93 1b       	sub	r25, r19
    606e:	29 a3       	lds	r18, 0x59
    6070:	ba a3       	lds	r27, 0x5a
    6072:	ab a3       	lds	r26, 0x5b
    6074:	4c a2       	lds	r20, 0x9c
    6076:	8d a2       	lds	r24, 0x9d
    6078:	5e a3       	lds	r21, 0x5e
    607a:	4f a3       	lds	r20, 0x5f
    607c:	98 a7       	lds	r25, 0x78
    607e:	8f ef       	ldi	r24, 0xFF	; 255
    6080:	9f ef       	ldi	r25, 0xFF	; 255
    6082:	af ef       	ldi	r26, 0xFF	; 255
    6084:	bf ef       	ldi	r27, 0xFF	; 255
    6086:	25 96       	adiw	r28, 0x05	; 5
    6088:	8c af       	sts	0x7c, r24
    608a:	9d af       	sts	0x7d, r25
    608c:	ae af       	sts	0x7e, r26
    608e:	bf af       	sts	0x7f, r27
    6090:	25 97       	sbiw	r28, 0x05	; 5
    6092:	06 c0       	rjmp	.+12     	; 0x60a0 <__stack+0xa1>
    6094:	25 96       	adiw	r28, 0x05	; 5
    6096:	1c ae       	sts	0xbc, r17
    6098:	1d ae       	sts	0xbd, r17
    609a:	1e ae       	sts	0xbe, r17
    609c:	1f ae       	sts	0xbf, r17
    609e:	25 97       	sbiw	r28, 0x05	; 5
    60a0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    60a2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    60a4:	af 8d       	ldd	r26, Y+31	; 0x1f
    60a6:	b8 a1       	lds	r27, 0x48
    60a8:	b7 ff       	sbrs	r27, 7
    60aa:	68 c0       	rjmp	.+208    	; 0x617c <__stack+0x17d>
    60ac:	25 96       	adiw	r28, 0x05	; 5
    60ae:	2c ad       	sts	0x6c, r18
    60b0:	3d ad       	sts	0x6d, r19
    60b2:	4e ad       	sts	0x6e, r20
    60b4:	5f ad       	sts	0x6f, r21
    60b6:	25 97       	sbiw	r28, 0x05	; 5
    60b8:	20 95       	com	r18
    60ba:	30 95       	com	r19
    60bc:	40 95       	com	r20
    60be:	50 95       	com	r21
    60c0:	25 96       	adiw	r28, 0x05	; 5
    60c2:	2c af       	sts	0x7c, r18
    60c4:	3d af       	sts	0x7d, r19
    60c6:	4e af       	sts	0x7e, r20
    60c8:	5f af       	sts	0x7f, r21
    60ca:	25 97       	sbiw	r28, 0x05	; 5
    60cc:	e1 95       	neg	r30
    60ce:	81 e0       	ldi	r24, 0x01	; 1
    60d0:	1e 16       	cp	r1, r30
    60d2:	08 f0       	brcs	.+2      	; 0x60d6 <__stack+0xd7>
    60d4:	80 e0       	ldi	r24, 0x00	; 0
    60d6:	f1 95       	neg	r31
    60d8:	91 e0       	ldi	r25, 0x01	; 1
    60da:	1f 16       	cp	r1, r31
    60dc:	08 f0       	brcs	.+2      	; 0x60e0 <__stack+0xe1>
    60de:	90 e0       	ldi	r25, 0x00	; 0
    60e0:	4f 2f       	mov	r20, r31
    60e2:	48 1b       	sub	r20, r24
    60e4:	81 e0       	ldi	r24, 0x01	; 1
    60e6:	f4 17       	cp	r31, r20
    60e8:	08 f0       	brcs	.+2      	; 0x60ec <__stack+0xed>
    60ea:	80 e0       	ldi	r24, 0x00	; 0
    60ec:	98 2b       	or	r25, r24
    60ee:	c1 94       	neg	r12
    60f0:	81 e0       	ldi	r24, 0x01	; 1
    60f2:	1c 14       	cp	r1, r12
    60f4:	08 f0       	brcs	.+2      	; 0x60f8 <__stack+0xf9>
    60f6:	80 e0       	ldi	r24, 0x00	; 0
    60f8:	6c 2d       	mov	r22, r12
    60fa:	69 1b       	sub	r22, r25
    60fc:	91 e0       	ldi	r25, 0x01	; 1
    60fe:	c6 16       	cp	r12, r22
    6100:	08 f0       	brcs	.+2      	; 0x6104 <__stack+0x105>
    6102:	90 e0       	ldi	r25, 0x00	; 0
    6104:	89 2b       	or	r24, r25
    6106:	d1 94       	neg	r13
    6108:	91 e0       	ldi	r25, 0x01	; 1
    610a:	1d 14       	cp	r1, r13
    610c:	08 f0       	brcs	.+2      	; 0x6110 <__stack+0x111>
    610e:	90 e0       	ldi	r25, 0x00	; 0
    6110:	5d 2d       	mov	r21, r13
    6112:	58 1b       	sub	r21, r24
    6114:	81 e0       	ldi	r24, 0x01	; 1
    6116:	d5 16       	cp	r13, r21
    6118:	08 f0       	brcs	.+2      	; 0x611c <__stack+0x11d>
    611a:	80 e0       	ldi	r24, 0x00	; 0
    611c:	98 2b       	or	r25, r24
    611e:	e1 94       	neg	r14
    6120:	81 e0       	ldi	r24, 0x01	; 1
    6122:	1e 14       	cp	r1, r14
    6124:	08 f0       	brcs	.+2      	; 0x6128 <__stack+0x129>
    6126:	80 e0       	ldi	r24, 0x00	; 0
    6128:	3e 2d       	mov	r19, r14
    612a:	39 1b       	sub	r19, r25
    612c:	91 e0       	ldi	r25, 0x01	; 1
    612e:	e3 16       	cp	r14, r19
    6130:	08 f0       	brcs	.+2      	; 0x6134 <__stack+0x135>
    6132:	90 e0       	ldi	r25, 0x00	; 0
    6134:	89 2b       	or	r24, r25
    6136:	f1 94       	neg	r15
    6138:	91 e0       	ldi	r25, 0x01	; 1
    613a:	1f 14       	cp	r1, r15
    613c:	08 f0       	brcs	.+2      	; 0x6140 <__stack+0x141>
    613e:	90 e0       	ldi	r25, 0x00	; 0
    6140:	2f 2d       	mov	r18, r15
    6142:	28 1b       	sub	r18, r24
    6144:	81 e0       	ldi	r24, 0x01	; 1
    6146:	f2 16       	cp	r15, r18
    6148:	08 f0       	brcs	.+2      	; 0x614c <__stack+0x14d>
    614a:	80 e0       	ldi	r24, 0x00	; 0
    614c:	98 2b       	or	r25, r24
    614e:	01 95       	neg	r16
    6150:	81 e0       	ldi	r24, 0x01	; 1
    6152:	10 16       	cp	r1, r16
    6154:	08 f0       	brcs	.+2      	; 0x6158 <__stack+0x159>
    6156:	80 e0       	ldi	r24, 0x00	; 0
    6158:	70 2f       	mov	r23, r16
    615a:	79 1b       	sub	r23, r25
    615c:	97 2f       	mov	r25, r23
    615e:	71 e0       	ldi	r23, 0x01	; 1
    6160:	09 17       	cp	r16, r25
    6162:	08 f0       	brcs	.+2      	; 0x6166 <__stack+0x167>
    6164:	70 e0       	ldi	r23, 0x00	; 0
    6166:	87 2b       	or	r24, r23
    6168:	11 95       	neg	r17
    616a:	18 1b       	sub	r17, r24
    616c:	e9 8f       	std	Y+25, r30	; 0x19
    616e:	4a 8f       	std	Y+26, r20	; 0x1a
    6170:	6b 8f       	std	Y+27, r22	; 0x1b
    6172:	5c 8f       	std	Y+28, r21	; 0x1c
    6174:	3d 8f       	std	Y+29, r19	; 0x1d
    6176:	2e 8f       	std	Y+30, r18	; 0x1e
    6178:	9f 8f       	std	Y+31, r25	; 0x1f
    617a:	18 a3       	lds	r17, 0x58
    617c:	79 8d       	ldd	r23, Y+25	; 0x19
    617e:	6a 8d       	ldd	r22, Y+26	; 0x1a
    6180:	5b 8d       	ldd	r21, Y+27	; 0x1b
    6182:	4c 8d       	ldd	r20, Y+28	; 0x1c
    6184:	3d 8d       	ldd	r19, Y+29	; 0x1d
    6186:	2e 8d       	ldd	r18, Y+30	; 0x1e
    6188:	9f 8d       	ldd	r25, Y+31	; 0x1f
    618a:	88 a1       	lds	r24, 0x48
    618c:	e9 a1       	lds	r30, 0x49
    618e:	e9 8b       	std	Y+17, r30	; 0x11
    6190:	ea a1       	lds	r30, 0x4a
    6192:	ea 8b       	std	Y+18, r30	; 0x12
    6194:	eb a1       	lds	r30, 0x4b
    6196:	eb 8b       	std	Y+19, r30	; 0x13
    6198:	ec a1       	lds	r30, 0x4c
    619a:	ec 8b       	std	Y+20, r30	; 0x14
    619c:	ed a1       	lds	r30, 0x4d
    619e:	ed 8b       	std	Y+21, r30	; 0x15
    61a0:	ee a1       	lds	r30, 0x4e
    61a2:	ee 8b       	std	Y+22, r30	; 0x16
    61a4:	ef a1       	lds	r30, 0x4f
    61a6:	ef 8b       	std	Y+23, r30	; 0x17
    61a8:	e8 a5       	lds	r30, 0x68
    61aa:	e8 8f       	std	Y+24, r30	; 0x18
    61ac:	79 87       	std	Y+9, r23	; 0x09
    61ae:	6a 87       	std	Y+10, r22	; 0x0a
    61b0:	5b 87       	std	Y+11, r21	; 0x0b
    61b2:	4c 87       	std	Y+12, r20	; 0x0c
    61b4:	3d 87       	std	Y+13, r19	; 0x0d
    61b6:	2e 87       	std	Y+14, r18	; 0x0e
    61b8:	9f 87       	std	Y+15, r25	; 0x0f
    61ba:	88 8b       	std	Y+16, r24	; 0x10
    61bc:	89 84       	ldd	r8, Y+9	; 0x09
    61be:	9a 84       	ldd	r9, Y+10	; 0x0a
    61c0:	ab 84       	ldd	r10, Y+11	; 0x0b
    61c2:	bc 84       	ldd	r11, Y+12	; 0x0c
    61c4:	8d 85       	ldd	r24, Y+13	; 0x0d
    61c6:	9e 85       	ldd	r25, Y+14	; 0x0e
    61c8:	af 85       	ldd	r26, Y+15	; 0x0f
    61ca:	b8 89       	ldd	r27, Y+16	; 0x10
    61cc:	e9 88       	ldd	r14, Y+17	; 0x11
    61ce:	fa 88       	ldd	r15, Y+18	; 0x12
    61d0:	0b 89       	ldd	r16, Y+19	; 0x13
    61d2:	1c 89       	ldd	r17, Y+20	; 0x14
    61d4:	ed aa       	sts	0x9d, r30
    61d6:	fe aa       	sts	0x9e, r31
    61d8:	0f ab       	sts	0x5f, r16
    61da:	18 af       	sts	0x78, r17
    61dc:	cd 88       	ldd	r12, Y+21	; 0x15
    61de:	de 88       	ldd	r13, Y+22	; 0x16
    61e0:	ef 88       	ldd	r14, Y+23	; 0x17
    61e2:	f8 8c       	ldd	r15, Y+24	; 0x18
    61e4:	00 97       	sbiw	r24, 0x00	; 0
    61e6:	a1 05       	cpc	r26, r1
    61e8:	b1 05       	cpc	r27, r1
    61ea:	09 f0       	breq	.+2      	; 0x61ee <__stack+0x1ef>
    61ec:	bd c3       	rjmp	.+1914   	; 0x6968 <__stack+0x969>
    61ee:	c8 14       	cp	r12, r8
    61f0:	d9 04       	cpc	r13, r9
    61f2:	ea 04       	cpc	r14, r10
    61f4:	fb 04       	cpc	r15, r11
    61f6:	08 f0       	brcs	.+2      	; 0x61fa <__stack+0x1fb>
    61f8:	4d c1       	rjmp	.+666    	; 0x6494 <__stack+0x495>
    61fa:	00 e0       	ldi	r16, 0x00	; 0
    61fc:	80 16       	cp	r8, r16
    61fe:	00 e0       	ldi	r16, 0x00	; 0
    6200:	90 06       	cpc	r9, r16
    6202:	01 e0       	ldi	r16, 0x01	; 1
    6204:	a0 06       	cpc	r10, r16
    6206:	00 e0       	ldi	r16, 0x00	; 0
    6208:	b0 06       	cpc	r11, r16
    620a:	58 f4       	brcc	.+22     	; 0x6222 <__stack+0x223>
    620c:	1f ef       	ldi	r17, 0xFF	; 255
    620e:	81 16       	cp	r8, r17
    6210:	91 04       	cpc	r9, r1
    6212:	a1 04       	cpc	r10, r1
    6214:	b1 04       	cpc	r11, r1
    6216:	09 f0       	breq	.+2      	; 0x621a <__stack+0x21b>
    6218:	90 f4       	brcc	.+36     	; 0x623e <__stack+0x23f>
    621a:	80 e0       	ldi	r24, 0x00	; 0
    621c:	90 e0       	ldi	r25, 0x00	; 0
    621e:	dc 01       	movw	r26, r24
    6220:	17 c0       	rjmp	.+46     	; 0x6250 <__stack+0x251>
    6222:	20 e0       	ldi	r18, 0x00	; 0
    6224:	82 16       	cp	r8, r18
    6226:	20 e0       	ldi	r18, 0x00	; 0
    6228:	92 06       	cpc	r9, r18
    622a:	20 e0       	ldi	r18, 0x00	; 0
    622c:	a2 06       	cpc	r10, r18
    622e:	21 e0       	ldi	r18, 0x01	; 1
    6230:	b2 06       	cpc	r11, r18
    6232:	50 f4       	brcc	.+20     	; 0x6248 <__stack+0x249>
    6234:	80 e1       	ldi	r24, 0x10	; 16
    6236:	90 e0       	ldi	r25, 0x00	; 0
    6238:	a0 e0       	ldi	r26, 0x00	; 0
    623a:	b0 e0       	ldi	r27, 0x00	; 0
    623c:	09 c0       	rjmp	.+18     	; 0x6250 <__stack+0x251>
    623e:	88 e0       	ldi	r24, 0x08	; 8
    6240:	90 e0       	ldi	r25, 0x00	; 0
    6242:	a0 e0       	ldi	r26, 0x00	; 0
    6244:	b0 e0       	ldi	r27, 0x00	; 0
    6246:	04 c0       	rjmp	.+8      	; 0x6250 <__stack+0x251>
    6248:	88 e1       	ldi	r24, 0x18	; 24
    624a:	90 e0       	ldi	r25, 0x00	; 0
    624c:	a0 e0       	ldi	r26, 0x00	; 0
    624e:	b0 e0       	ldi	r27, 0x00	; 0
    6250:	b5 01       	movw	r22, r10
    6252:	a4 01       	movw	r20, r8
    6254:	08 2e       	mov	r0, r24
    6256:	04 c0       	rjmp	.+8      	; 0x6260 <__stack+0x261>
    6258:	76 95       	lsr	r23
    625a:	67 95       	ror	r22
    625c:	57 95       	ror	r21
    625e:	47 95       	ror	r20
    6260:	0a 94       	dec	r0
    6262:	d2 f7       	brpl	.-12     	; 0x6258 <__stack+0x259>
    6264:	fa 01       	movw	r30, r20
    6266:	e3 5f       	subi	r30, 0xF3	; 243
    6268:	ff 4d       	sbci	r31, 0xDF	; 223
    626a:	20 81       	ld	r18, Z
    626c:	40 e2       	ldi	r20, 0x20	; 32
    626e:	50 e0       	ldi	r21, 0x00	; 0
    6270:	60 e0       	ldi	r22, 0x00	; 0
    6272:	70 e0       	ldi	r23, 0x00	; 0
    6274:	48 1b       	sub	r20, r24
    6276:	59 0b       	sbc	r21, r25
    6278:	6a 0b       	sbc	r22, r26
    627a:	7b 0b       	sbc	r23, r27
    627c:	42 1b       	sub	r20, r18
    627e:	51 09       	sbc	r21, r1
    6280:	61 09       	sbc	r22, r1
    6282:	71 09       	sbc	r23, r1
    6284:	41 15       	cp	r20, r1
    6286:	51 05       	cpc	r21, r1
    6288:	61 05       	cpc	r22, r1
    628a:	71 05       	cpc	r23, r1
    628c:	a1 f1       	breq	.+104    	; 0x62f6 <__stack+0x2f7>
    628e:	04 2e       	mov	r0, r20
    6290:	04 c0       	rjmp	.+8      	; 0x629a <__stack+0x29b>
    6292:	88 0c       	add	r8, r8
    6294:	99 1c       	adc	r9, r9
    6296:	aa 1c       	adc	r10, r10
    6298:	bb 1c       	adc	r11, r11
    629a:	0a 94       	dec	r0
    629c:	d2 f7       	brpl	.-12     	; 0x6292 <__stack+0x293>
    629e:	97 01       	movw	r18, r14
    62a0:	86 01       	movw	r16, r12
    62a2:	04 2e       	mov	r0, r20
    62a4:	04 c0       	rjmp	.+8      	; 0x62ae <__stack+0x2af>
    62a6:	00 0f       	add	r16, r16
    62a8:	11 1f       	adc	r17, r17
    62aa:	22 1f       	adc	r18, r18
    62ac:	33 1f       	adc	r19, r19
    62ae:	0a 94       	dec	r0
    62b0:	d2 f7       	brpl	.-12     	; 0x62a6 <__stack+0x2a7>
    62b2:	80 e2       	ldi	r24, 0x20	; 32
    62b4:	90 e0       	ldi	r25, 0x00	; 0
    62b6:	84 1b       	sub	r24, r20
    62b8:	95 0b       	sbc	r25, r21
    62ba:	cd a8       	sts	0x8d, r28
    62bc:	de a8       	sts	0x8e, r29
    62be:	ef a8       	sts	0x8f, r30
    62c0:	f8 ac       	sts	0xa8, r31
    62c2:	04 c0       	rjmp	.+8      	; 0x62cc <__stack+0x2cd>
    62c4:	f6 94       	lsr	r15
    62c6:	e7 94       	ror	r14
    62c8:	d7 94       	ror	r13
    62ca:	c7 94       	ror	r12
    62cc:	8a 95       	dec	r24
    62ce:	d2 f7       	brpl	.-12     	; 0x62c4 <__stack+0x2c5>
    62d0:	c0 2a       	or	r12, r16
    62d2:	d1 2a       	or	r13, r17
    62d4:	e2 2a       	or	r14, r18
    62d6:	f3 2a       	or	r15, r19
    62d8:	0d a9       	sts	0x4d, r16
    62da:	1e a9       	sts	0x4e, r17
    62dc:	2f a9       	sts	0x4f, r18
    62de:	38 ad       	sts	0x68, r19
    62e0:	04 c0       	rjmp	.+8      	; 0x62ea <__stack+0x2eb>
    62e2:	00 0f       	add	r16, r16
    62e4:	11 1f       	adc	r17, r17
    62e6:	22 1f       	adc	r18, r18
    62e8:	33 1f       	adc	r19, r19
    62ea:	4a 95       	dec	r20
    62ec:	d2 f7       	brpl	.-12     	; 0x62e2 <__stack+0x2e3>
    62ee:	0d ab       	sts	0x5d, r16
    62f0:	1e ab       	sts	0x5e, r17
    62f2:	2f ab       	sts	0x5f, r18
    62f4:	38 af       	sts	0x78, r19
    62f6:	25 01       	movw	r4, r10
    62f8:	66 24       	eor	r6, r6
    62fa:	77 24       	eor	r7, r7
    62fc:	95 01       	movw	r18, r10
    62fe:	84 01       	movw	r16, r8
    6300:	20 70       	andi	r18, 0x00	; 0
    6302:	30 70       	andi	r19, 0x00	; 0
    6304:	09 ab       	sts	0x59, r16
    6306:	1a ab       	sts	0x5a, r17
    6308:	2b ab       	sts	0x5b, r18
    630a:	3c ab       	sts	0x5c, r19
    630c:	c7 01       	movw	r24, r14
    630e:	b6 01       	movw	r22, r12
    6310:	a3 01       	movw	r20, r6
    6312:	92 01       	movw	r18, r4
    6314:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    6318:	2d a7       	lds	r18, 0x7d
    631a:	3e a7       	lds	r19, 0x7e
    631c:	4f a7       	lds	r20, 0x7f
    631e:	58 ab       	sts	0x58, r21
    6320:	69 a7       	lds	r22, 0x79
    6322:	7a a7       	lds	r23, 0x7a
    6324:	8b a7       	lds	r24, 0x7b
    6326:	9c a7       	lds	r25, 0x7c
    6328:	c7 01       	movw	r24, r14
    632a:	b6 01       	movw	r22, r12
    632c:	a3 01       	movw	r20, r6
    632e:	92 01       	movw	r18, r4
    6330:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    6334:	ca 01       	movw	r24, r20
    6336:	b9 01       	movw	r22, r18
    6338:	29 a9       	sts	0x49, r18
    633a:	3a a9       	sts	0x4a, r19
    633c:	4b a9       	sts	0x4b, r20
    633e:	5c a9       	sts	0x4c, r21
    6340:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    6344:	ab 01       	movw	r20, r22
    6346:	bc 01       	movw	r22, r24
    6348:	09 a5       	lds	r16, 0x69
    634a:	1a a5       	lds	r17, 0x6a
    634c:	2b a5       	lds	r18, 0x6b
    634e:	3c a5       	lds	r19, 0x6c
    6350:	78 01       	movw	r14, r16
    6352:	dd 24       	eor	r13, r13
    6354:	cc 24       	eor	r12, r12
    6356:	0d a9       	sts	0x4d, r16
    6358:	1e a9       	sts	0x4e, r17
    635a:	2f a9       	sts	0x4f, r18
    635c:	38 ad       	sts	0x68, r19
    635e:	c9 01       	movw	r24, r18
    6360:	aa 27       	eor	r26, r26
    6362:	bb 27       	eor	r27, r27
    6364:	c8 2a       	or	r12, r24
    6366:	d9 2a       	or	r13, r25
    6368:	ea 2a       	or	r14, r26
    636a:	fb 2a       	or	r15, r27
    636c:	0d a5       	lds	r16, 0x6d
    636e:	1e a5       	lds	r17, 0x6e
    6370:	2f a5       	lds	r18, 0x6f
    6372:	38 a9       	sts	0x48, r19
    6374:	c4 16       	cp	r12, r20
    6376:	d5 06       	cpc	r13, r21
    6378:	e6 06       	cpc	r14, r22
    637a:	f7 06       	cpc	r15, r23
    637c:	38 f5       	brcc	.+78     	; 0x63cc <__stack+0x3cd>
    637e:	01 50       	subi	r16, 0x01	; 1
    6380:	10 40       	sbci	r17, 0x00	; 0
    6382:	20 40       	sbci	r18, 0x00	; 0
    6384:	30 40       	sbci	r19, 0x00	; 0
    6386:	09 a7       	lds	r16, 0x79
    6388:	1a a7       	lds	r17, 0x7a
    638a:	2b a7       	lds	r18, 0x7b
    638c:	3c a7       	lds	r19, 0x7c
    638e:	c8 0c       	add	r12, r8
    6390:	d9 1c       	adc	r13, r9
    6392:	ea 1c       	adc	r14, r10
    6394:	fb 1c       	adc	r15, r11
    6396:	c8 14       	cp	r12, r8
    6398:	d9 04       	cpc	r13, r9
    639a:	ea 04       	cpc	r14, r10
    639c:	fb 04       	cpc	r15, r11
    639e:	d0 f0       	brcs	.+52     	; 0x63d4 <__stack+0x3d5>
    63a0:	c4 16       	cp	r12, r20
    63a2:	d5 06       	cpc	r13, r21
    63a4:	e6 06       	cpc	r14, r22
    63a6:	f7 06       	cpc	r15, r23
    63a8:	a8 f4       	brcc	.+42     	; 0x63d4 <__stack+0x3d5>
    63aa:	0d a5       	lds	r16, 0x6d
    63ac:	1e a5       	lds	r17, 0x6e
    63ae:	2f a5       	lds	r18, 0x6f
    63b0:	38 a9       	sts	0x48, r19
    63b2:	02 50       	subi	r16, 0x02	; 2
    63b4:	10 40       	sbci	r17, 0x00	; 0
    63b6:	20 40       	sbci	r18, 0x00	; 0
    63b8:	30 40       	sbci	r19, 0x00	; 0
    63ba:	09 a7       	lds	r16, 0x79
    63bc:	1a a7       	lds	r17, 0x7a
    63be:	2b a7       	lds	r18, 0x7b
    63c0:	3c a7       	lds	r19, 0x7c
    63c2:	c8 0c       	add	r12, r8
    63c4:	d9 1c       	adc	r13, r9
    63c6:	ea 1c       	adc	r14, r10
    63c8:	fb 1c       	adc	r15, r11
    63ca:	04 c0       	rjmp	.+8      	; 0x63d4 <__stack+0x3d5>
    63cc:	09 a7       	lds	r16, 0x79
    63ce:	1a a7       	lds	r17, 0x7a
    63d0:	2b a7       	lds	r18, 0x7b
    63d2:	3c a7       	lds	r19, 0x7c
    63d4:	c4 1a       	sub	r12, r20
    63d6:	d5 0a       	sbc	r13, r21
    63d8:	e6 0a       	sbc	r14, r22
    63da:	f7 0a       	sbc	r15, r23
    63dc:	c7 01       	movw	r24, r14
    63de:	b6 01       	movw	r22, r12
    63e0:	a3 01       	movw	r20, r6
    63e2:	92 01       	movw	r18, r4
    63e4:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    63e8:	2d a7       	lds	r18, 0x7d
    63ea:	3e a7       	lds	r19, 0x7e
    63ec:	4f a7       	lds	r20, 0x7f
    63ee:	58 ab       	sts	0x58, r21
    63f0:	69 af       	sts	0x79, r22
    63f2:	7a af       	sts	0x7a, r23
    63f4:	8b af       	sts	0x7b, r24
    63f6:	9c af       	sts	0x7c, r25
    63f8:	c7 01       	movw	r24, r14
    63fa:	b6 01       	movw	r22, r12
    63fc:	a3 01       	movw	r20, r6
    63fe:	92 01       	movw	r18, r4
    6400:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    6404:	ca 01       	movw	r24, r20
    6406:	b9 01       	movw	r22, r18
    6408:	29 a9       	sts	0x49, r18
    640a:	3a a9       	sts	0x4a, r19
    640c:	4b a9       	sts	0x4b, r20
    640e:	5c a9       	sts	0x4c, r21
    6410:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    6414:	6b 01       	movw	r12, r22
    6416:	7c 01       	movw	r14, r24
    6418:	49 ad       	sts	0x69, r20
    641a:	5a ad       	sts	0x6a, r21
    641c:	6b ad       	sts	0x6b, r22
    641e:	7c ad       	sts	0x6c, r23
    6420:	9a 01       	movw	r18, r20
    6422:	11 27       	eor	r17, r17
    6424:	00 27       	eor	r16, r16
    6426:	4d a9       	sts	0x4d, r20
    6428:	5e a9       	sts	0x4e, r21
    642a:	6f a9       	sts	0x4f, r22
    642c:	78 ad       	sts	0x68, r23
    642e:	60 70       	andi	r22, 0x00	; 0
    6430:	70 70       	andi	r23, 0x00	; 0
    6432:	04 2b       	or	r16, r20
    6434:	15 2b       	or	r17, r21
    6436:	26 2b       	or	r18, r22
    6438:	37 2b       	or	r19, r23
    643a:	8d a5       	lds	r24, 0x6d
    643c:	9e a5       	lds	r25, 0x6e
    643e:	af a5       	lds	r26, 0x6f
    6440:	b8 a9       	sts	0x48, r27
    6442:	0c 15       	cp	r16, r12
    6444:	1d 05       	cpc	r17, r13
    6446:	2e 05       	cpc	r18, r14
    6448:	3f 05       	cpc	r19, r15
    644a:	c0 f4       	brcc	.+48     	; 0x647c <__stack+0x47d>
    644c:	01 97       	sbiw	r24, 0x01	; 1
    644e:	a1 09       	sbc	r26, r1
    6450:	b1 09       	sbc	r27, r1
    6452:	08 0d       	add	r16, r8
    6454:	19 1d       	adc	r17, r9
    6456:	2a 1d       	adc	r18, r10
    6458:	3b 1d       	adc	r19, r11
    645a:	08 15       	cp	r16, r8
    645c:	19 05       	cpc	r17, r9
    645e:	2a 05       	cpc	r18, r10
    6460:	3b 05       	cpc	r19, r11
    6462:	60 f0       	brcs	.+24     	; 0x647c <__stack+0x47d>
    6464:	0c 15       	cp	r16, r12
    6466:	1d 05       	cpc	r17, r13
    6468:	2e 05       	cpc	r18, r14
    646a:	3f 05       	cpc	r19, r15
    646c:	38 f4       	brcc	.+14     	; 0x647c <__stack+0x47d>
    646e:	8d a5       	lds	r24, 0x6d
    6470:	9e a5       	lds	r25, 0x6e
    6472:	af a5       	lds	r26, 0x6f
    6474:	b8 a9       	sts	0x48, r27
    6476:	02 97       	sbiw	r24, 0x02	; 2
    6478:	a1 09       	sbc	r26, r1
    647a:	b1 09       	sbc	r27, r1
    647c:	09 a5       	lds	r16, 0x69
    647e:	1a a5       	lds	r17, 0x6a
    6480:	2b a5       	lds	r18, 0x6b
    6482:	3c a5       	lds	r19, 0x6c
    6484:	78 01       	movw	r14, r16
    6486:	dd 24       	eor	r13, r13
    6488:	cc 24       	eor	r12, r12
    648a:	c8 2a       	or	r12, r24
    648c:	d9 2a       	or	r13, r25
    648e:	ea 2a       	or	r14, r26
    6490:	fb 2a       	or	r15, r27
    6492:	b7 c4       	rjmp	.+2414   	; 0x6e02 <__stack+0xe03>
    6494:	81 14       	cp	r8, r1
    6496:	91 04       	cpc	r9, r1
    6498:	a1 04       	cpc	r10, r1
    649a:	b1 04       	cpc	r11, r1
    649c:	51 f4       	brne	.+20     	; 0x64b2 <__stack+0x4b3>
    649e:	61 e0       	ldi	r22, 0x01	; 1
    64a0:	70 e0       	ldi	r23, 0x00	; 0
    64a2:	80 e0       	ldi	r24, 0x00	; 0
    64a4:	90 e0       	ldi	r25, 0x00	; 0
    64a6:	a5 01       	movw	r20, r10
    64a8:	94 01       	movw	r18, r8
    64aa:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    64ae:	49 01       	movw	r8, r18
    64b0:	5a 01       	movw	r10, r20
    64b2:	10 e0       	ldi	r17, 0x00	; 0
    64b4:	81 16       	cp	r8, r17
    64b6:	10 e0       	ldi	r17, 0x00	; 0
    64b8:	91 06       	cpc	r9, r17
    64ba:	11 e0       	ldi	r17, 0x01	; 1
    64bc:	a1 06       	cpc	r10, r17
    64be:	10 e0       	ldi	r17, 0x00	; 0
    64c0:	b1 06       	cpc	r11, r17
    64c2:	58 f4       	brcc	.+22     	; 0x64da <__stack+0x4db>
    64c4:	2f ef       	ldi	r18, 0xFF	; 255
    64c6:	82 16       	cp	r8, r18
    64c8:	91 04       	cpc	r9, r1
    64ca:	a1 04       	cpc	r10, r1
    64cc:	b1 04       	cpc	r11, r1
    64ce:	09 f0       	breq	.+2      	; 0x64d2 <__stack+0x4d3>
    64d0:	90 f4       	brcc	.+36     	; 0x64f6 <__stack+0x4f7>
    64d2:	80 e0       	ldi	r24, 0x00	; 0
    64d4:	90 e0       	ldi	r25, 0x00	; 0
    64d6:	dc 01       	movw	r26, r24
    64d8:	17 c0       	rjmp	.+46     	; 0x6508 <__stack+0x509>
    64da:	30 e0       	ldi	r19, 0x00	; 0
    64dc:	83 16       	cp	r8, r19
    64de:	30 e0       	ldi	r19, 0x00	; 0
    64e0:	93 06       	cpc	r9, r19
    64e2:	30 e0       	ldi	r19, 0x00	; 0
    64e4:	a3 06       	cpc	r10, r19
    64e6:	31 e0       	ldi	r19, 0x01	; 1
    64e8:	b3 06       	cpc	r11, r19
    64ea:	50 f4       	brcc	.+20     	; 0x6500 <__stack+0x501>
    64ec:	80 e1       	ldi	r24, 0x10	; 16
    64ee:	90 e0       	ldi	r25, 0x00	; 0
    64f0:	a0 e0       	ldi	r26, 0x00	; 0
    64f2:	b0 e0       	ldi	r27, 0x00	; 0
    64f4:	09 c0       	rjmp	.+18     	; 0x6508 <__stack+0x509>
    64f6:	88 e0       	ldi	r24, 0x08	; 8
    64f8:	90 e0       	ldi	r25, 0x00	; 0
    64fa:	a0 e0       	ldi	r26, 0x00	; 0
    64fc:	b0 e0       	ldi	r27, 0x00	; 0
    64fe:	04 c0       	rjmp	.+8      	; 0x6508 <__stack+0x509>
    6500:	88 e1       	ldi	r24, 0x18	; 24
    6502:	90 e0       	ldi	r25, 0x00	; 0
    6504:	a0 e0       	ldi	r26, 0x00	; 0
    6506:	b0 e0       	ldi	r27, 0x00	; 0
    6508:	b5 01       	movw	r22, r10
    650a:	a4 01       	movw	r20, r8
    650c:	08 2e       	mov	r0, r24
    650e:	04 c0       	rjmp	.+8      	; 0x6518 <__stack+0x519>
    6510:	76 95       	lsr	r23
    6512:	67 95       	ror	r22
    6514:	57 95       	ror	r21
    6516:	47 95       	ror	r20
    6518:	0a 94       	dec	r0
    651a:	d2 f7       	brpl	.-12     	; 0x6510 <__stack+0x511>
    651c:	fa 01       	movw	r30, r20
    651e:	e3 5f       	subi	r30, 0xF3	; 243
    6520:	ff 4d       	sbci	r31, 0xDF	; 223
    6522:	20 81       	ld	r18, Z
    6524:	ac 01       	movw	r20, r24
    6526:	bd 01       	movw	r22, r26
    6528:	42 0f       	add	r20, r18
    652a:	51 1d       	adc	r21, r1
    652c:	61 1d       	adc	r22, r1
    652e:	71 1d       	adc	r23, r1
    6530:	80 e2       	ldi	r24, 0x20	; 32
    6532:	90 e0       	ldi	r25, 0x00	; 0
    6534:	a0 e0       	ldi	r26, 0x00	; 0
    6536:	b0 e0       	ldi	r27, 0x00	; 0
    6538:	84 1b       	sub	r24, r20
    653a:	95 0b       	sbc	r25, r21
    653c:	a6 0b       	sbc	r26, r22
    653e:	b7 0b       	sbc	r27, r23
    6540:	51 f4       	brne	.+20     	; 0x6556 <__stack+0x557>
    6542:	c8 18       	sub	r12, r8
    6544:	d9 08       	sbc	r13, r9
    6546:	ea 08       	sbc	r14, r10
    6548:	fb 08       	sbc	r15, r11
    654a:	f1 e0       	ldi	r31, 0x01	; 1
    654c:	4f 2e       	mov	r4, r31
    654e:	51 2c       	mov	r5, r1
    6550:	61 2c       	mov	r6, r1
    6552:	71 2c       	mov	r7, r1
    6554:	28 c1       	rjmp	.+592    	; 0x67a6 <__stack+0x7a7>
    6556:	08 2e       	mov	r0, r24
    6558:	04 c0       	rjmp	.+8      	; 0x6562 <__stack+0x563>
    655a:	88 0c       	add	r8, r8
    655c:	99 1c       	adc	r9, r9
    655e:	aa 1c       	adc	r10, r10
    6560:	bb 1c       	adc	r11, r11
    6562:	0a 94       	dec	r0
    6564:	d2 f7       	brpl	.-12     	; 0x655a <__stack+0x55b>
    6566:	97 01       	movw	r18, r14
    6568:	86 01       	movw	r16, r12
    656a:	04 2e       	mov	r0, r20
    656c:	04 c0       	rjmp	.+8      	; 0x6576 <__stack+0x577>
    656e:	36 95       	lsr	r19
    6570:	27 95       	ror	r18
    6572:	17 95       	ror	r17
    6574:	07 95       	ror	r16
    6576:	0a 94       	dec	r0
    6578:	d2 f7       	brpl	.-12     	; 0x656e <__stack+0x56f>
    657a:	09 ab       	sts	0x59, r16
    657c:	1a ab       	sts	0x5a, r17
    657e:	2b ab       	sts	0x5b, r18
    6580:	3c ab       	sts	0x5c, r19
    6582:	97 01       	movw	r18, r14
    6584:	86 01       	movw	r16, r12
    6586:	08 2e       	mov	r0, r24
    6588:	04 c0       	rjmp	.+8      	; 0x6592 <__stack+0x593>
    658a:	00 0f       	add	r16, r16
    658c:	11 1f       	adc	r17, r17
    658e:	22 1f       	adc	r18, r18
    6590:	33 1f       	adc	r19, r19
    6592:	0a 94       	dec	r0
    6594:	d2 f7       	brpl	.-12     	; 0x658a <__stack+0x58b>
    6596:	0d a7       	lds	r16, 0x7d
    6598:	1e a7       	lds	r17, 0x7e
    659a:	2f a7       	lds	r18, 0x7f
    659c:	38 ab       	sts	0x58, r19
    659e:	ed a8       	sts	0x8d, r30
    65a0:	fe a8       	sts	0x8e, r31
    65a2:	0f a9       	sts	0x4f, r16
    65a4:	18 ad       	sts	0x68, r17
    65a6:	04 c0       	rjmp	.+8      	; 0x65b0 <__stack+0x5b1>
    65a8:	16 95       	lsr	r17
    65aa:	07 95       	ror	r16
    65ac:	f7 94       	ror	r15
    65ae:	e7 94       	ror	r14
    65b0:	4a 95       	dec	r20
    65b2:	d2 f7       	brpl	.-12     	; 0x65a8 <__stack+0x5a9>
    65b4:	b8 01       	movw	r22, r16
    65b6:	a7 01       	movw	r20, r14
    65b8:	0d a5       	lds	r16, 0x6d
    65ba:	1e a5       	lds	r17, 0x6e
    65bc:	2f a5       	lds	r18, 0x6f
    65be:	38 a9       	sts	0x48, r19
    65c0:	04 2b       	or	r16, r20
    65c2:	15 2b       	or	r17, r21
    65c4:	26 2b       	or	r18, r22
    65c6:	37 2b       	or	r19, r23
    65c8:	0d a7       	lds	r16, 0x7d
    65ca:	1e a7       	lds	r17, 0x7e
    65cc:	2f a7       	lds	r18, 0x7f
    65ce:	38 ab       	sts	0x58, r19
    65d0:	ed a8       	sts	0x8d, r30
    65d2:	fe a8       	sts	0x8e, r31
    65d4:	0f a9       	sts	0x4f, r16
    65d6:	18 ad       	sts	0x68, r17
    65d8:	04 c0       	rjmp	.+8      	; 0x65e2 <__stack+0x5e3>
    65da:	ee 0c       	add	r14, r14
    65dc:	ff 1c       	adc	r15, r15
    65de:	00 1f       	adc	r16, r16
    65e0:	11 1f       	adc	r17, r17
    65e2:	8a 95       	dec	r24
    65e4:	d2 f7       	brpl	.-12     	; 0x65da <__stack+0x5db>
    65e6:	ed aa       	sts	0x9d, r30
    65e8:	fe aa       	sts	0x9e, r31
    65ea:	0f ab       	sts	0x5f, r16
    65ec:	18 af       	sts	0x78, r17
    65ee:	25 01       	movw	r4, r10
    65f0:	66 24       	eor	r6, r6
    65f2:	77 24       	eor	r7, r7
    65f4:	95 01       	movw	r18, r10
    65f6:	84 01       	movw	r16, r8
    65f8:	20 70       	andi	r18, 0x00	; 0
    65fa:	30 70       	andi	r19, 0x00	; 0
    65fc:	09 af       	sts	0x79, r16
    65fe:	1a af       	sts	0x7a, r17
    6600:	2b af       	sts	0x7b, r18
    6602:	3c af       	sts	0x7c, r19
    6604:	69 a9       	sts	0x49, r22
    6606:	7a a9       	sts	0x4a, r23
    6608:	8b a9       	sts	0x4b, r24
    660a:	9c a9       	sts	0x4c, r25
    660c:	a3 01       	movw	r20, r6
    660e:	92 01       	movw	r18, r4
    6610:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    6614:	29 a7       	lds	r18, 0x79
    6616:	3a a7       	lds	r19, 0x7a
    6618:	4b a7       	lds	r20, 0x7b
    661a:	5c a7       	lds	r21, 0x7c
    661c:	6b 01       	movw	r12, r22
    661e:	7c 01       	movw	r14, r24
    6620:	69 a9       	sts	0x49, r22
    6622:	7a a9       	sts	0x4a, r23
    6624:	8b a9       	sts	0x4b, r24
    6626:	9c a9       	sts	0x4c, r25
    6628:	a3 01       	movw	r20, r6
    662a:	92 01       	movw	r18, r4
    662c:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    6630:	ca 01       	movw	r24, r20
    6632:	b9 01       	movw	r22, r18
    6634:	29 ad       	sts	0x69, r18
    6636:	3a ad       	sts	0x6a, r19
    6638:	4b ad       	sts	0x6b, r20
    663a:	5c ad       	sts	0x6c, r21
    663c:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    6640:	ab 01       	movw	r20, r22
    6642:	bc 01       	movw	r22, r24
    6644:	76 01       	movw	r14, r12
    6646:	dd 24       	eor	r13, r13
    6648:	cc 24       	eor	r12, r12
    664a:	0d a5       	lds	r16, 0x6d
    664c:	1e a5       	lds	r17, 0x6e
    664e:	2f a5       	lds	r18, 0x6f
    6650:	38 a9       	sts	0x48, r19
    6652:	c9 01       	movw	r24, r18
    6654:	aa 27       	eor	r26, r26
    6656:	bb 27       	eor	r27, r27
    6658:	c8 2a       	or	r12, r24
    665a:	d9 2a       	or	r13, r25
    665c:	ea 2a       	or	r14, r26
    665e:	fb 2a       	or	r15, r27
    6660:	09 a5       	lds	r16, 0x69
    6662:	1a a5       	lds	r17, 0x6a
    6664:	2b a5       	lds	r18, 0x6b
    6666:	3c a5       	lds	r19, 0x6c
    6668:	c4 16       	cp	r12, r20
    666a:	d5 06       	cpc	r13, r21
    666c:	e6 06       	cpc	r14, r22
    666e:	f7 06       	cpc	r15, r23
    6670:	38 f5       	brcc	.+78     	; 0x66c0 <__stack+0x6c1>
    6672:	01 50       	subi	r16, 0x01	; 1
    6674:	10 40       	sbci	r17, 0x00	; 0
    6676:	20 40       	sbci	r18, 0x00	; 0
    6678:	30 40       	sbci	r19, 0x00	; 0
    667a:	09 ab       	sts	0x59, r16
    667c:	1a ab       	sts	0x5a, r17
    667e:	2b ab       	sts	0x5b, r18
    6680:	3c ab       	sts	0x5c, r19
    6682:	c8 0c       	add	r12, r8
    6684:	d9 1c       	adc	r13, r9
    6686:	ea 1c       	adc	r14, r10
    6688:	fb 1c       	adc	r15, r11
    668a:	c8 14       	cp	r12, r8
    668c:	d9 04       	cpc	r13, r9
    668e:	ea 04       	cpc	r14, r10
    6690:	fb 04       	cpc	r15, r11
    6692:	d0 f0       	brcs	.+52     	; 0x66c8 <__stack+0x6c9>
    6694:	c4 16       	cp	r12, r20
    6696:	d5 06       	cpc	r13, r21
    6698:	e6 06       	cpc	r14, r22
    669a:	f7 06       	cpc	r15, r23
    669c:	a8 f4       	brcc	.+42     	; 0x66c8 <__stack+0x6c9>
    669e:	09 a5       	lds	r16, 0x69
    66a0:	1a a5       	lds	r17, 0x6a
    66a2:	2b a5       	lds	r18, 0x6b
    66a4:	3c a5       	lds	r19, 0x6c
    66a6:	02 50       	subi	r16, 0x02	; 2
    66a8:	10 40       	sbci	r17, 0x00	; 0
    66aa:	20 40       	sbci	r18, 0x00	; 0
    66ac:	30 40       	sbci	r19, 0x00	; 0
    66ae:	09 ab       	sts	0x59, r16
    66b0:	1a ab       	sts	0x5a, r17
    66b2:	2b ab       	sts	0x5b, r18
    66b4:	3c ab       	sts	0x5c, r19
    66b6:	c8 0c       	add	r12, r8
    66b8:	d9 1c       	adc	r13, r9
    66ba:	ea 1c       	adc	r14, r10
    66bc:	fb 1c       	adc	r15, r11
    66be:	04 c0       	rjmp	.+8      	; 0x66c8 <__stack+0x6c9>
    66c0:	09 ab       	sts	0x59, r16
    66c2:	1a ab       	sts	0x5a, r17
    66c4:	2b ab       	sts	0x5b, r18
    66c6:	3c ab       	sts	0x5c, r19
    66c8:	c4 1a       	sub	r12, r20
    66ca:	d5 0a       	sbc	r13, r21
    66cc:	e6 0a       	sbc	r14, r22
    66ce:	f7 0a       	sbc	r15, r23
    66d0:	c7 01       	movw	r24, r14
    66d2:	b6 01       	movw	r22, r12
    66d4:	a3 01       	movw	r20, r6
    66d6:	92 01       	movw	r18, r4
    66d8:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    66dc:	29 a7       	lds	r18, 0x79
    66de:	3a a7       	lds	r19, 0x7a
    66e0:	4b a7       	lds	r20, 0x7b
    66e2:	5c a7       	lds	r21, 0x7c
    66e4:	21 96       	adiw	r28, 0x01	; 1
    66e6:	6c af       	sts	0x7c, r22
    66e8:	7d af       	sts	0x7d, r23
    66ea:	8e af       	sts	0x7e, r24
    66ec:	9f af       	sts	0x7f, r25
    66ee:	21 97       	sbiw	r28, 0x01	; 1
    66f0:	c7 01       	movw	r24, r14
    66f2:	b6 01       	movw	r22, r12
    66f4:	a3 01       	movw	r20, r6
    66f6:	92 01       	movw	r18, r4
    66f8:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    66fc:	ca 01       	movw	r24, r20
    66fe:	b9 01       	movw	r22, r18
    6700:	29 ad       	sts	0x69, r18
    6702:	3a ad       	sts	0x6a, r19
    6704:	4b ad       	sts	0x6b, r20
    6706:	5c ad       	sts	0x6c, r21
    6708:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    670c:	8b 01       	movw	r16, r22
    670e:	9c 01       	movw	r18, r24
    6710:	21 96       	adiw	r28, 0x01	; 1
    6712:	4c ad       	sts	0x6c, r20
    6714:	5d ad       	sts	0x6d, r21
    6716:	6e ad       	sts	0x6e, r22
    6718:	7f ad       	sts	0x6f, r23
    671a:	21 97       	sbiw	r28, 0x01	; 1
    671c:	da 01       	movw	r26, r20
    671e:	99 27       	eor	r25, r25
    6720:	88 27       	eor	r24, r24
    6722:	4d a5       	lds	r20, 0x6d
    6724:	5e a5       	lds	r21, 0x6e
    6726:	6f a5       	lds	r22, 0x6f
    6728:	78 a9       	sts	0x48, r23
    672a:	60 70       	andi	r22, 0x00	; 0
    672c:	70 70       	andi	r23, 0x00	; 0
    672e:	84 2b       	or	r24, r20
    6730:	95 2b       	or	r25, r21
    6732:	a6 2b       	or	r26, r22
    6734:	b7 2b       	or	r27, r23
    6736:	49 a5       	lds	r20, 0x69
    6738:	5a a5       	lds	r21, 0x6a
    673a:	6b a5       	lds	r22, 0x6b
    673c:	7c a5       	lds	r23, 0x6c
    673e:	80 17       	cp	r24, r16
    6740:	91 07       	cpc	r25, r17
    6742:	a2 07       	cpc	r26, r18
    6744:	b3 07       	cpc	r27, r19
    6746:	f0 f4       	brcc	.+60     	; 0x6784 <__stack+0x785>
    6748:	41 50       	subi	r20, 0x01	; 1
    674a:	50 40       	sbci	r21, 0x00	; 0
    674c:	60 40       	sbci	r22, 0x00	; 0
    674e:	70 40       	sbci	r23, 0x00	; 0
    6750:	88 0d       	add	r24, r8
    6752:	99 1d       	adc	r25, r9
    6754:	aa 1d       	adc	r26, r10
    6756:	bb 1d       	adc	r27, r11
    6758:	88 15       	cp	r24, r8
    675a:	99 05       	cpc	r25, r9
    675c:	aa 05       	cpc	r26, r10
    675e:	bb 05       	cpc	r27, r11
    6760:	88 f0       	brcs	.+34     	; 0x6784 <__stack+0x785>
    6762:	80 17       	cp	r24, r16
    6764:	91 07       	cpc	r25, r17
    6766:	a2 07       	cpc	r26, r18
    6768:	b3 07       	cpc	r27, r19
    676a:	60 f4       	brcc	.+24     	; 0x6784 <__stack+0x785>
    676c:	49 a5       	lds	r20, 0x69
    676e:	5a a5       	lds	r21, 0x6a
    6770:	6b a5       	lds	r22, 0x6b
    6772:	7c a5       	lds	r23, 0x6c
    6774:	42 50       	subi	r20, 0x02	; 2
    6776:	50 40       	sbci	r21, 0x00	; 0
    6778:	60 40       	sbci	r22, 0x00	; 0
    677a:	70 40       	sbci	r23, 0x00	; 0
    677c:	88 0d       	add	r24, r8
    677e:	99 1d       	adc	r25, r9
    6780:	aa 1d       	adc	r26, r10
    6782:	bb 1d       	adc	r27, r11
    6784:	6c 01       	movw	r12, r24
    6786:	7d 01       	movw	r14, r26
    6788:	c0 1a       	sub	r12, r16
    678a:	d1 0a       	sbc	r13, r17
    678c:	e2 0a       	sbc	r14, r18
    678e:	f3 0a       	sbc	r15, r19
    6790:	09 a9       	sts	0x49, r16
    6792:	1a a9       	sts	0x4a, r17
    6794:	2b a9       	sts	0x4b, r18
    6796:	3c a9       	sts	0x4c, r19
    6798:	38 01       	movw	r6, r16
    679a:	55 24       	eor	r5, r5
    679c:	44 24       	eor	r4, r4
    679e:	44 2a       	or	r4, r20
    67a0:	55 2a       	or	r5, r21
    67a2:	66 2a       	or	r6, r22
    67a4:	77 2a       	or	r7, r23
    67a6:	85 01       	movw	r16, r10
    67a8:	22 27       	eor	r18, r18
    67aa:	33 27       	eor	r19, r19
    67ac:	0d a7       	lds	r16, 0x7d
    67ae:	1e a7       	lds	r17, 0x7e
    67b0:	2f a7       	lds	r18, 0x7f
    67b2:	38 ab       	sts	0x58, r19
    67b4:	95 01       	movw	r18, r10
    67b6:	84 01       	movw	r16, r8
    67b8:	20 70       	andi	r18, 0x00	; 0
    67ba:	30 70       	andi	r19, 0x00	; 0
    67bc:	09 af       	sts	0x79, r16
    67be:	1a af       	sts	0x7a, r17
    67c0:	2b af       	sts	0x7b, r18
    67c2:	3c af       	sts	0x7c, r19
    67c4:	c7 01       	movw	r24, r14
    67c6:	b6 01       	movw	r22, r12
    67c8:	2d a5       	lds	r18, 0x6d
    67ca:	3e a5       	lds	r19, 0x6e
    67cc:	4f a5       	lds	r20, 0x6f
    67ce:	58 a9       	sts	0x48, r21
    67d0:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    67d4:	29 a7       	lds	r18, 0x79
    67d6:	3a a7       	lds	r19, 0x7a
    67d8:	4b a7       	lds	r20, 0x7b
    67da:	5c a7       	lds	r21, 0x7c
    67dc:	69 ab       	sts	0x59, r22
    67de:	7a ab       	sts	0x5a, r23
    67e0:	8b ab       	sts	0x5b, r24
    67e2:	9c ab       	sts	0x5c, r25
    67e4:	c7 01       	movw	r24, r14
    67e6:	b6 01       	movw	r22, r12
    67e8:	2d a5       	lds	r18, 0x6d
    67ea:	3e a5       	lds	r19, 0x6e
    67ec:	4f a5       	lds	r20, 0x6f
    67ee:	58 a9       	sts	0x48, r21
    67f0:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    67f4:	ca 01       	movw	r24, r20
    67f6:	b9 01       	movw	r22, r18
    67f8:	29 ad       	sts	0x69, r18
    67fa:	3a ad       	sts	0x6a, r19
    67fc:	4b ad       	sts	0x6b, r20
    67fe:	5c ad       	sts	0x6c, r21
    6800:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    6804:	ab 01       	movw	r20, r22
    6806:	bc 01       	movw	r22, r24
    6808:	09 a9       	sts	0x49, r16
    680a:	1a a9       	sts	0x4a, r17
    680c:	2b a9       	sts	0x4b, r18
    680e:	3c a9       	sts	0x4c, r19
    6810:	78 01       	movw	r14, r16
    6812:	dd 24       	eor	r13, r13
    6814:	cc 24       	eor	r12, r12
    6816:	0d a9       	sts	0x4d, r16
    6818:	1e a9       	sts	0x4e, r17
    681a:	2f a9       	sts	0x4f, r18
    681c:	38 ad       	sts	0x68, r19
    681e:	c9 01       	movw	r24, r18
    6820:	aa 27       	eor	r26, r26
    6822:	bb 27       	eor	r27, r27
    6824:	c8 2a       	or	r12, r24
    6826:	d9 2a       	or	r13, r25
    6828:	ea 2a       	or	r14, r26
    682a:	fb 2a       	or	r15, r27
    682c:	09 a5       	lds	r16, 0x69
    682e:	1a a5       	lds	r17, 0x6a
    6830:	2b a5       	lds	r18, 0x6b
    6832:	3c a5       	lds	r19, 0x6c
    6834:	c4 16       	cp	r12, r20
    6836:	d5 06       	cpc	r13, r21
    6838:	e6 06       	cpc	r14, r22
    683a:	f7 06       	cpc	r15, r23
    683c:	38 f5       	brcc	.+78     	; 0x688c <__stack+0x88d>
    683e:	01 50       	subi	r16, 0x01	; 1
    6840:	10 40       	sbci	r17, 0x00	; 0
    6842:	20 40       	sbci	r18, 0x00	; 0
    6844:	30 40       	sbci	r19, 0x00	; 0
    6846:	09 ab       	sts	0x59, r16
    6848:	1a ab       	sts	0x5a, r17
    684a:	2b ab       	sts	0x5b, r18
    684c:	3c ab       	sts	0x5c, r19
    684e:	c8 0c       	add	r12, r8
    6850:	d9 1c       	adc	r13, r9
    6852:	ea 1c       	adc	r14, r10
    6854:	fb 1c       	adc	r15, r11
    6856:	c8 14       	cp	r12, r8
    6858:	d9 04       	cpc	r13, r9
    685a:	ea 04       	cpc	r14, r10
    685c:	fb 04       	cpc	r15, r11
    685e:	d0 f0       	brcs	.+52     	; 0x6894 <__stack+0x895>
    6860:	c4 16       	cp	r12, r20
    6862:	d5 06       	cpc	r13, r21
    6864:	e6 06       	cpc	r14, r22
    6866:	f7 06       	cpc	r15, r23
    6868:	a8 f4       	brcc	.+42     	; 0x6894 <__stack+0x895>
    686a:	09 a5       	lds	r16, 0x69
    686c:	1a a5       	lds	r17, 0x6a
    686e:	2b a5       	lds	r18, 0x6b
    6870:	3c a5       	lds	r19, 0x6c
    6872:	02 50       	subi	r16, 0x02	; 2
    6874:	10 40       	sbci	r17, 0x00	; 0
    6876:	20 40       	sbci	r18, 0x00	; 0
    6878:	30 40       	sbci	r19, 0x00	; 0
    687a:	09 ab       	sts	0x59, r16
    687c:	1a ab       	sts	0x5a, r17
    687e:	2b ab       	sts	0x5b, r18
    6880:	3c ab       	sts	0x5c, r19
    6882:	c8 0c       	add	r12, r8
    6884:	d9 1c       	adc	r13, r9
    6886:	ea 1c       	adc	r14, r10
    6888:	fb 1c       	adc	r15, r11
    688a:	04 c0       	rjmp	.+8      	; 0x6894 <__stack+0x895>
    688c:	09 ab       	sts	0x59, r16
    688e:	1a ab       	sts	0x5a, r17
    6890:	2b ab       	sts	0x5b, r18
    6892:	3c ab       	sts	0x5c, r19
    6894:	c4 1a       	sub	r12, r20
    6896:	d5 0a       	sbc	r13, r21
    6898:	e6 0a       	sbc	r14, r22
    689a:	f7 0a       	sbc	r15, r23
    689c:	c7 01       	movw	r24, r14
    689e:	b6 01       	movw	r22, r12
    68a0:	2d a5       	lds	r18, 0x6d
    68a2:	3e a5       	lds	r19, 0x6e
    68a4:	4f a5       	lds	r20, 0x6f
    68a6:	58 a9       	sts	0x48, r21
    68a8:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    68ac:	29 a7       	lds	r18, 0x79
    68ae:	3a a7       	lds	r19, 0x7a
    68b0:	4b a7       	lds	r20, 0x7b
    68b2:	5c a7       	lds	r21, 0x7c
    68b4:	21 96       	adiw	r28, 0x01	; 1
    68b6:	6c af       	sts	0x7c, r22
    68b8:	7d af       	sts	0x7d, r23
    68ba:	8e af       	sts	0x7e, r24
    68bc:	9f af       	sts	0x7f, r25
    68be:	21 97       	sbiw	r28, 0x01	; 1
    68c0:	c7 01       	movw	r24, r14
    68c2:	b6 01       	movw	r22, r12
    68c4:	2d a5       	lds	r18, 0x6d
    68c6:	3e a5       	lds	r19, 0x6e
    68c8:	4f a5       	lds	r20, 0x6f
    68ca:	58 a9       	sts	0x48, r21
    68cc:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    68d0:	ca 01       	movw	r24, r20
    68d2:	b9 01       	movw	r22, r18
    68d4:	29 ad       	sts	0x69, r18
    68d6:	3a ad       	sts	0x6a, r19
    68d8:	4b ad       	sts	0x6b, r20
    68da:	5c ad       	sts	0x6c, r21
    68dc:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    68e0:	8b 01       	movw	r16, r22
    68e2:	9c 01       	movw	r18, r24
    68e4:	21 96       	adiw	r28, 0x01	; 1
    68e6:	4c ad       	sts	0x6c, r20
    68e8:	5d ad       	sts	0x6d, r21
    68ea:	6e ad       	sts	0x6e, r22
    68ec:	7f ad       	sts	0x6f, r23
    68ee:	21 97       	sbiw	r28, 0x01	; 1
    68f0:	da 01       	movw	r26, r20
    68f2:	99 27       	eor	r25, r25
    68f4:	88 27       	eor	r24, r24
    68f6:	4d a9       	sts	0x4d, r20
    68f8:	5e a9       	sts	0x4e, r21
    68fa:	6f a9       	sts	0x4f, r22
    68fc:	78 ad       	sts	0x68, r23
    68fe:	60 70       	andi	r22, 0x00	; 0
    6900:	70 70       	andi	r23, 0x00	; 0
    6902:	84 2b       	or	r24, r20
    6904:	95 2b       	or	r25, r21
    6906:	a6 2b       	or	r26, r22
    6908:	b7 2b       	or	r27, r23
    690a:	49 a5       	lds	r20, 0x69
    690c:	5a a5       	lds	r21, 0x6a
    690e:	6b a5       	lds	r22, 0x6b
    6910:	7c a5       	lds	r23, 0x6c
    6912:	80 17       	cp	r24, r16
    6914:	91 07       	cpc	r25, r17
    6916:	a2 07       	cpc	r26, r18
    6918:	b3 07       	cpc	r27, r19
    691a:	d0 f4       	brcc	.+52     	; 0x6950 <__stack+0x951>
    691c:	41 50       	subi	r20, 0x01	; 1
    691e:	50 40       	sbci	r21, 0x00	; 0
    6920:	60 40       	sbci	r22, 0x00	; 0
    6922:	70 40       	sbci	r23, 0x00	; 0
    6924:	88 0d       	add	r24, r8
    6926:	99 1d       	adc	r25, r9
    6928:	aa 1d       	adc	r26, r10
    692a:	bb 1d       	adc	r27, r11
    692c:	88 15       	cp	r24, r8
    692e:	99 05       	cpc	r25, r9
    6930:	aa 05       	cpc	r26, r10
    6932:	bb 05       	cpc	r27, r11
    6934:	68 f0       	brcs	.+26     	; 0x6950 <__stack+0x951>
    6936:	80 17       	cp	r24, r16
    6938:	91 07       	cpc	r25, r17
    693a:	a2 07       	cpc	r26, r18
    693c:	b3 07       	cpc	r27, r19
    693e:	40 f4       	brcc	.+16     	; 0x6950 <__stack+0x951>
    6940:	49 a5       	lds	r20, 0x69
    6942:	5a a5       	lds	r21, 0x6a
    6944:	6b a5       	lds	r22, 0x6b
    6946:	7c a5       	lds	r23, 0x6c
    6948:	42 50       	subi	r20, 0x02	; 2
    694a:	50 40       	sbci	r21, 0x00	; 0
    694c:	60 40       	sbci	r22, 0x00	; 0
    694e:	70 40       	sbci	r23, 0x00	; 0
    6950:	09 a9       	sts	0x49, r16
    6952:	1a a9       	sts	0x4a, r17
    6954:	2b a9       	sts	0x4b, r18
    6956:	3c a9       	sts	0x4c, r19
    6958:	78 01       	movw	r14, r16
    695a:	dd 24       	eor	r13, r13
    695c:	cc 24       	eor	r12, r12
    695e:	c4 2a       	or	r12, r20
    6960:	d5 2a       	or	r13, r21
    6962:	e6 2a       	or	r14, r22
    6964:	f7 2a       	or	r15, r23
    6966:	50 c2       	rjmp	.+1184   	; 0x6e08 <__stack+0xe09>
    6968:	c8 16       	cp	r12, r24
    696a:	d9 06       	cpc	r13, r25
    696c:	ea 06       	cpc	r14, r26
    696e:	fb 06       	cpc	r15, r27
    6970:	08 f4       	brcc	.+2      	; 0x6974 <__stack+0x975>
    6972:	37 c2       	rjmp	.+1134   	; 0x6de2 <__stack+0xde3>
    6974:	80 30       	cpi	r24, 0x00	; 0
    6976:	10 e0       	ldi	r17, 0x00	; 0
    6978:	91 07       	cpc	r25, r17
    697a:	11 e0       	ldi	r17, 0x01	; 1
    697c:	a1 07       	cpc	r26, r17
    697e:	10 e0       	ldi	r17, 0x00	; 0
    6980:	b1 07       	cpc	r27, r17
    6982:	50 f4       	brcc	.+20     	; 0x6998 <__stack+0x999>
    6984:	8f 3f       	cpi	r24, 0xFF	; 255
    6986:	91 05       	cpc	r25, r1
    6988:	a1 05       	cpc	r26, r1
    698a:	b1 05       	cpc	r27, r1
    698c:	09 f0       	breq	.+2      	; 0x6990 <__stack+0x991>
    698e:	88 f4       	brcc	.+34     	; 0x69b2 <__stack+0x9b3>
    6990:	00 e0       	ldi	r16, 0x00	; 0
    6992:	10 e0       	ldi	r17, 0x00	; 0
    6994:	98 01       	movw	r18, r16
    6996:	16 c0       	rjmp	.+44     	; 0x69c4 <__stack+0x9c5>
    6998:	80 30       	cpi	r24, 0x00	; 0
    699a:	20 e0       	ldi	r18, 0x00	; 0
    699c:	92 07       	cpc	r25, r18
    699e:	20 e0       	ldi	r18, 0x00	; 0
    69a0:	a2 07       	cpc	r26, r18
    69a2:	21 e0       	ldi	r18, 0x01	; 1
    69a4:	b2 07       	cpc	r27, r18
    69a6:	50 f4       	brcc	.+20     	; 0x69bc <__stack+0x9bd>
    69a8:	00 e1       	ldi	r16, 0x10	; 16
    69aa:	10 e0       	ldi	r17, 0x00	; 0
    69ac:	20 e0       	ldi	r18, 0x00	; 0
    69ae:	30 e0       	ldi	r19, 0x00	; 0
    69b0:	09 c0       	rjmp	.+18     	; 0x69c4 <__stack+0x9c5>
    69b2:	08 e0       	ldi	r16, 0x08	; 8
    69b4:	10 e0       	ldi	r17, 0x00	; 0
    69b6:	20 e0       	ldi	r18, 0x00	; 0
    69b8:	30 e0       	ldi	r19, 0x00	; 0
    69ba:	04 c0       	rjmp	.+8      	; 0x69c4 <__stack+0x9c5>
    69bc:	08 e1       	ldi	r16, 0x18	; 24
    69be:	10 e0       	ldi	r17, 0x00	; 0
    69c0:	20 e0       	ldi	r18, 0x00	; 0
    69c2:	30 e0       	ldi	r19, 0x00	; 0
    69c4:	ac 01       	movw	r20, r24
    69c6:	bd 01       	movw	r22, r26
    69c8:	00 2e       	mov	r0, r16
    69ca:	04 c0       	rjmp	.+8      	; 0x69d4 <__stack+0x9d5>
    69cc:	76 95       	lsr	r23
    69ce:	67 95       	ror	r22
    69d0:	57 95       	ror	r21
    69d2:	47 95       	ror	r20
    69d4:	0a 94       	dec	r0
    69d6:	d2 f7       	brpl	.-12     	; 0x69cc <__stack+0x9cd>
    69d8:	fa 01       	movw	r30, r20
    69da:	e3 5f       	subi	r30, 0xF3	; 243
    69dc:	ff 4d       	sbci	r31, 0xDF	; 223
    69de:	40 81       	ld	r20, Z
    69e0:	04 0f       	add	r16, r20
    69e2:	11 1d       	adc	r17, r1
    69e4:	21 1d       	adc	r18, r1
    69e6:	31 1d       	adc	r19, r1
    69e8:	40 e2       	ldi	r20, 0x20	; 32
    69ea:	50 e0       	ldi	r21, 0x00	; 0
    69ec:	60 e0       	ldi	r22, 0x00	; 0
    69ee:	70 e0       	ldi	r23, 0x00	; 0
    69f0:	40 1b       	sub	r20, r16
    69f2:	51 0b       	sbc	r21, r17
    69f4:	62 0b       	sbc	r22, r18
    69f6:	73 0b       	sbc	r23, r19
    69f8:	a1 f4       	brne	.+40     	; 0x6a22 <__stack+0xa23>
    69fa:	8c 15       	cp	r24, r12
    69fc:	9d 05       	cpc	r25, r13
    69fe:	ae 05       	cpc	r26, r14
    6a00:	bf 05       	cpc	r27, r15
    6a02:	08 f4       	brcc	.+2      	; 0x6a06 <__stack+0xa07>
    6a04:	f5 c1       	rjmp	.+1002   	; 0x6df0 <__stack+0xdf1>
    6a06:	ed a8       	sts	0x8d, r30
    6a08:	fe a8       	sts	0x8e, r31
    6a0a:	0f a9       	sts	0x4f, r16
    6a0c:	18 ad       	sts	0x68, r17
    6a0e:	44 24       	eor	r4, r4
    6a10:	55 24       	eor	r5, r5
    6a12:	32 01       	movw	r6, r4
    6a14:	e8 14       	cp	r14, r8
    6a16:	f9 04       	cpc	r15, r9
    6a18:	0a 05       	cpc	r16, r10
    6a1a:	1b 05       	cpc	r17, r11
    6a1c:	08 f0       	brcs	.+2      	; 0x6a20 <__stack+0xa21>
    6a1e:	eb c1       	rjmp	.+982    	; 0x6df6 <__stack+0xdf7>
    6a20:	e3 c1       	rjmp	.+966    	; 0x6de8 <__stack+0xde9>
    6a22:	34 2e       	mov	r3, r20
    6a24:	2c 01       	movw	r4, r24
    6a26:	3d 01       	movw	r6, r26
    6a28:	04 c0       	rjmp	.+8      	; 0x6a32 <__stack+0xa33>
    6a2a:	44 0c       	add	r4, r4
    6a2c:	55 1c       	adc	r5, r5
    6a2e:	66 1c       	adc	r6, r6
    6a30:	77 1c       	adc	r7, r7
    6a32:	4a 95       	dec	r20
    6a34:	d2 f7       	brpl	.-12     	; 0x6a2a <__stack+0xa2b>
    6a36:	d5 01       	movw	r26, r10
    6a38:	c4 01       	movw	r24, r8
    6a3a:	00 2e       	mov	r0, r16
    6a3c:	04 c0       	rjmp	.+8      	; 0x6a46 <__stack+0xa47>
    6a3e:	b6 95       	lsr	r27
    6a40:	a7 95       	ror	r26
    6a42:	97 95       	ror	r25
    6a44:	87 95       	ror	r24
    6a46:	0a 94       	dec	r0
    6a48:	d2 f7       	brpl	.-12     	; 0x6a3e <__stack+0xa3f>
    6a4a:	48 2a       	or	r4, r24
    6a4c:	59 2a       	or	r5, r25
    6a4e:	6a 2a       	or	r6, r26
    6a50:	7b 2a       	or	r7, r27
    6a52:	a5 01       	movw	r20, r10
    6a54:	94 01       	movw	r18, r8
    6a56:	03 2c       	mov	r0, r3
    6a58:	04 c0       	rjmp	.+8      	; 0x6a62 <__stack+0xa63>
    6a5a:	22 0f       	add	r18, r18
    6a5c:	33 1f       	adc	r19, r19
    6a5e:	44 1f       	adc	r20, r20
    6a60:	55 1f       	adc	r21, r21
    6a62:	0a 94       	dec	r0
    6a64:	d2 f7       	brpl	.-12     	; 0x6a5a <__stack+0xa5b>
    6a66:	29 af       	sts	0x79, r18
    6a68:	3a af       	sts	0x7a, r19
    6a6a:	4b af       	sts	0x7b, r20
    6a6c:	5c af       	sts	0x7c, r21
    6a6e:	b7 01       	movw	r22, r14
    6a70:	a6 01       	movw	r20, r12
    6a72:	00 2e       	mov	r0, r16
    6a74:	04 c0       	rjmp	.+8      	; 0x6a7e <__stack+0xa7f>
    6a76:	76 95       	lsr	r23
    6a78:	67 95       	ror	r22
    6a7a:	57 95       	ror	r21
    6a7c:	47 95       	ror	r20
    6a7e:	0a 94       	dec	r0
    6a80:	d2 f7       	brpl	.-12     	; 0x6a76 <__stack+0xa77>
    6a82:	49 ab       	sts	0x59, r20
    6a84:	5a ab       	sts	0x5a, r21
    6a86:	6b ab       	sts	0x5b, r22
    6a88:	7c ab       	sts	0x5c, r23
    6a8a:	c7 01       	movw	r24, r14
    6a8c:	b6 01       	movw	r22, r12
    6a8e:	03 2c       	mov	r0, r3
    6a90:	04 c0       	rjmp	.+8      	; 0x6a9a <__stack+0xa9b>
    6a92:	66 0f       	add	r22, r22
    6a94:	77 1f       	adc	r23, r23
    6a96:	88 1f       	adc	r24, r24
    6a98:	99 1f       	adc	r25, r25
    6a9a:	0a 94       	dec	r0
    6a9c:	d2 f7       	brpl	.-12     	; 0x6a92 <__stack+0xa93>
    6a9e:	6d a7       	lds	r22, 0x7d
    6aa0:	7e a7       	lds	r23, 0x7e
    6aa2:	8f a7       	lds	r24, 0x7f
    6aa4:	98 ab       	sts	0x58, r25
    6aa6:	8d a9       	sts	0x4d, r24
    6aa8:	9e a9       	sts	0x4e, r25
    6aaa:	af a9       	sts	0x4f, r26
    6aac:	b8 ad       	sts	0x68, r27
    6aae:	04 c0       	rjmp	.+8      	; 0x6ab8 <__stack+0xab9>
    6ab0:	b6 95       	lsr	r27
    6ab2:	a7 95       	ror	r26
    6ab4:	97 95       	ror	r25
    6ab6:	87 95       	ror	r24
    6ab8:	0a 95       	dec	r16
    6aba:	d2 f7       	brpl	.-12     	; 0x6ab0 <__stack+0xab1>
    6abc:	4d a5       	lds	r20, 0x6d
    6abe:	5e a5       	lds	r21, 0x6e
    6ac0:	6f a5       	lds	r22, 0x6f
    6ac2:	78 a9       	sts	0x48, r23
    6ac4:	48 2b       	or	r20, r24
    6ac6:	59 2b       	or	r21, r25
    6ac8:	6a 2b       	or	r22, r26
    6aca:	7b 2b       	or	r23, r27
    6acc:	4d a7       	lds	r20, 0x7d
    6ace:	5e a7       	lds	r21, 0x7e
    6ad0:	6f a7       	lds	r22, 0x7f
    6ad2:	78 ab       	sts	0x58, r23
    6ad4:	43 01       	movw	r8, r6
    6ad6:	aa 24       	eor	r10, r10
    6ad8:	bb 24       	eor	r11, r11
    6ada:	93 01       	movw	r18, r6
    6adc:	82 01       	movw	r16, r4
    6ade:	20 70       	andi	r18, 0x00	; 0
    6ae0:	30 70       	andi	r19, 0x00	; 0
    6ae2:	21 96       	adiw	r28, 0x01	; 1
    6ae4:	0c af       	sts	0x7c, r16
    6ae6:	1d af       	sts	0x7d, r17
    6ae8:	2e af       	sts	0x7e, r18
    6aea:	3f af       	sts	0x7f, r19
    6aec:	21 97       	sbiw	r28, 0x01	; 1
    6aee:	69 a9       	sts	0x49, r22
    6af0:	7a a9       	sts	0x4a, r23
    6af2:	8b a9       	sts	0x4b, r24
    6af4:	9c a9       	sts	0x4c, r25
    6af6:	a5 01       	movw	r20, r10
    6af8:	94 01       	movw	r18, r8
    6afa:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    6afe:	29 a7       	lds	r18, 0x79
    6b00:	3a a7       	lds	r19, 0x7a
    6b02:	4b a7       	lds	r20, 0x7b
    6b04:	5c a7       	lds	r21, 0x7c
    6b06:	6b 01       	movw	r12, r22
    6b08:	7c 01       	movw	r14, r24
    6b0a:	69 a9       	sts	0x49, r22
    6b0c:	7a a9       	sts	0x4a, r23
    6b0e:	8b a9       	sts	0x4b, r24
    6b10:	9c a9       	sts	0x4c, r25
    6b12:	a5 01       	movw	r20, r10
    6b14:	94 01       	movw	r18, r8
    6b16:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    6b1a:	ca 01       	movw	r24, r20
    6b1c:	b9 01       	movw	r22, r18
    6b1e:	21 96       	adiw	r28, 0x01	; 1
    6b20:	2c ad       	sts	0x6c, r18
    6b22:	3d ad       	sts	0x6d, r19
    6b24:	4e ad       	sts	0x6e, r20
    6b26:	5f ad       	sts	0x6f, r21
    6b28:	21 97       	sbiw	r28, 0x01	; 1
    6b2a:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    6b2e:	dc 01       	movw	r26, r24
    6b30:	cb 01       	movw	r24, r22
    6b32:	76 01       	movw	r14, r12
    6b34:	dd 24       	eor	r13, r13
    6b36:	cc 24       	eor	r12, r12
    6b38:	0d a5       	lds	r16, 0x6d
    6b3a:	1e a5       	lds	r17, 0x6e
    6b3c:	2f a5       	lds	r18, 0x6f
    6b3e:	38 a9       	sts	0x48, r19
    6b40:	a9 01       	movw	r20, r18
    6b42:	66 27       	eor	r22, r22
    6b44:	77 27       	eor	r23, r23
    6b46:	c4 2a       	or	r12, r20
    6b48:	d5 2a       	or	r13, r21
    6b4a:	e6 2a       	or	r14, r22
    6b4c:	f7 2a       	or	r15, r23
    6b4e:	09 a5       	lds	r16, 0x69
    6b50:	1a a5       	lds	r17, 0x6a
    6b52:	2b a5       	lds	r18, 0x6b
    6b54:	3c a5       	lds	r19, 0x6c
    6b56:	c8 16       	cp	r12, r24
    6b58:	d9 06       	cpc	r13, r25
    6b5a:	ea 06       	cpc	r14, r26
    6b5c:	fb 06       	cpc	r15, r27
    6b5e:	38 f5       	brcc	.+78     	; 0x6bae <__stack+0xbaf>
    6b60:	01 50       	subi	r16, 0x01	; 1
    6b62:	10 40       	sbci	r17, 0x00	; 0
    6b64:	20 40       	sbci	r18, 0x00	; 0
    6b66:	30 40       	sbci	r19, 0x00	; 0
    6b68:	09 ab       	sts	0x59, r16
    6b6a:	1a ab       	sts	0x5a, r17
    6b6c:	2b ab       	sts	0x5b, r18
    6b6e:	3c ab       	sts	0x5c, r19
    6b70:	c4 0c       	add	r12, r4
    6b72:	d5 1c       	adc	r13, r5
    6b74:	e6 1c       	adc	r14, r6
    6b76:	f7 1c       	adc	r15, r7
    6b78:	c4 14       	cp	r12, r4
    6b7a:	d5 04       	cpc	r13, r5
    6b7c:	e6 04       	cpc	r14, r6
    6b7e:	f7 04       	cpc	r15, r7
    6b80:	d0 f0       	brcs	.+52     	; 0x6bb6 <__stack+0xbb7>
    6b82:	c8 16       	cp	r12, r24
    6b84:	d9 06       	cpc	r13, r25
    6b86:	ea 06       	cpc	r14, r26
    6b88:	fb 06       	cpc	r15, r27
    6b8a:	a8 f4       	brcc	.+42     	; 0x6bb6 <__stack+0xbb7>
    6b8c:	09 a5       	lds	r16, 0x69
    6b8e:	1a a5       	lds	r17, 0x6a
    6b90:	2b a5       	lds	r18, 0x6b
    6b92:	3c a5       	lds	r19, 0x6c
    6b94:	02 50       	subi	r16, 0x02	; 2
    6b96:	10 40       	sbci	r17, 0x00	; 0
    6b98:	20 40       	sbci	r18, 0x00	; 0
    6b9a:	30 40       	sbci	r19, 0x00	; 0
    6b9c:	09 ab       	sts	0x59, r16
    6b9e:	1a ab       	sts	0x5a, r17
    6ba0:	2b ab       	sts	0x5b, r18
    6ba2:	3c ab       	sts	0x5c, r19
    6ba4:	c4 0c       	add	r12, r4
    6ba6:	d5 1c       	adc	r13, r5
    6ba8:	e6 1c       	adc	r14, r6
    6baa:	f7 1c       	adc	r15, r7
    6bac:	04 c0       	rjmp	.+8      	; 0x6bb6 <__stack+0xbb7>
    6bae:	09 ab       	sts	0x59, r16
    6bb0:	1a ab       	sts	0x5a, r17
    6bb2:	2b ab       	sts	0x5b, r18
    6bb4:	3c ab       	sts	0x5c, r19
    6bb6:	c8 1a       	sub	r12, r24
    6bb8:	d9 0a       	sbc	r13, r25
    6bba:	ea 0a       	sbc	r14, r26
    6bbc:	fb 0a       	sbc	r15, r27
    6bbe:	c7 01       	movw	r24, r14
    6bc0:	b6 01       	movw	r22, r12
    6bc2:	a5 01       	movw	r20, r10
    6bc4:	94 01       	movw	r18, r8
    6bc6:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    6bca:	29 a7       	lds	r18, 0x79
    6bcc:	3a a7       	lds	r19, 0x7a
    6bce:	4b a7       	lds	r20, 0x7b
    6bd0:	5c a7       	lds	r21, 0x7c
    6bd2:	29 96       	adiw	r28, 0x09	; 9
    6bd4:	6c af       	sts	0x7c, r22
    6bd6:	7d af       	sts	0x7d, r23
    6bd8:	8e af       	sts	0x7e, r24
    6bda:	9f af       	sts	0x7f, r25
    6bdc:	29 97       	sbiw	r28, 0x09	; 9
    6bde:	c7 01       	movw	r24, r14
    6be0:	b6 01       	movw	r22, r12
    6be2:	a5 01       	movw	r20, r10
    6be4:	94 01       	movw	r18, r8
    6be6:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__udivmodsi4>
    6bea:	ca 01       	movw	r24, r20
    6bec:	b9 01       	movw	r22, r18
    6bee:	21 96       	adiw	r28, 0x01	; 1
    6bf0:	2c ad       	sts	0x6c, r18
    6bf2:	3d ad       	sts	0x6d, r19
    6bf4:	4e ad       	sts	0x6e, r20
    6bf6:	5f ad       	sts	0x6f, r21
    6bf8:	21 97       	sbiw	r28, 0x01	; 1
    6bfa:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    6bfe:	4b 01       	movw	r8, r22
    6c00:	5c 01       	movw	r10, r24
    6c02:	29 96       	adiw	r28, 0x09	; 9
    6c04:	4c ad       	sts	0x6c, r20
    6c06:	5d ad       	sts	0x6d, r21
    6c08:	6e ad       	sts	0x6e, r22
    6c0a:	7f ad       	sts	0x6f, r23
    6c0c:	29 97       	sbiw	r28, 0x09	; 9
    6c0e:	9a 01       	movw	r18, r20
    6c10:	11 27       	eor	r17, r17
    6c12:	00 27       	eor	r16, r16
    6c14:	8d a5       	lds	r24, 0x6d
    6c16:	9e a5       	lds	r25, 0x6e
    6c18:	af a5       	lds	r26, 0x6f
    6c1a:	b8 a9       	sts	0x48, r27
    6c1c:	a0 70       	andi	r26, 0x00	; 0
    6c1e:	b0 70       	andi	r27, 0x00	; 0
    6c20:	08 2b       	or	r16, r24
    6c22:	19 2b       	or	r17, r25
    6c24:	2a 2b       	or	r18, r26
    6c26:	3b 2b       	or	r19, r27
    6c28:	89 a5       	lds	r24, 0x69
    6c2a:	9a a5       	lds	r25, 0x6a
    6c2c:	ab a5       	lds	r26, 0x6b
    6c2e:	bc a5       	lds	r27, 0x6c
    6c30:	08 15       	cp	r16, r8
    6c32:	19 05       	cpc	r17, r9
    6c34:	2a 05       	cpc	r18, r10
    6c36:	3b 05       	cpc	r19, r11
    6c38:	e0 f4       	brcc	.+56     	; 0x6c72 <__stack+0xc73>
    6c3a:	01 97       	sbiw	r24, 0x01	; 1
    6c3c:	a1 09       	sbc	r26, r1
    6c3e:	b1 09       	sbc	r27, r1
    6c40:	04 0d       	add	r16, r4
    6c42:	15 1d       	adc	r17, r5
    6c44:	26 1d       	adc	r18, r6
    6c46:	37 1d       	adc	r19, r7
    6c48:	04 15       	cp	r16, r4
    6c4a:	15 05       	cpc	r17, r5
    6c4c:	26 05       	cpc	r18, r6
    6c4e:	37 05       	cpc	r19, r7
    6c50:	80 f0       	brcs	.+32     	; 0x6c72 <__stack+0xc73>
    6c52:	08 15       	cp	r16, r8
    6c54:	19 05       	cpc	r17, r9
    6c56:	2a 05       	cpc	r18, r10
    6c58:	3b 05       	cpc	r19, r11
    6c5a:	58 f4       	brcc	.+22     	; 0x6c72 <__stack+0xc73>
    6c5c:	89 a5       	lds	r24, 0x69
    6c5e:	9a a5       	lds	r25, 0x6a
    6c60:	ab a5       	lds	r26, 0x6b
    6c62:	bc a5       	lds	r27, 0x6c
    6c64:	02 97       	sbiw	r24, 0x02	; 2
    6c66:	a1 09       	sbc	r26, r1
    6c68:	b1 09       	sbc	r27, r1
    6c6a:	04 0d       	add	r16, r4
    6c6c:	15 1d       	adc	r17, r5
    6c6e:	26 1d       	adc	r18, r6
    6c70:	37 1d       	adc	r19, r7
    6c72:	b9 01       	movw	r22, r18
    6c74:	a8 01       	movw	r20, r16
    6c76:	48 19       	sub	r20, r8
    6c78:	59 09       	sbc	r21, r9
    6c7a:	6a 09       	sbc	r22, r10
    6c7c:	7b 09       	sbc	r23, r11
    6c7e:	4d a7       	lds	r20, 0x7d
    6c80:	5e a7       	lds	r21, 0x7e
    6c82:	6f a7       	lds	r22, 0x7f
    6c84:	78 ab       	sts	0x58, r23
    6c86:	09 a9       	sts	0x49, r16
    6c88:	1a a9       	sts	0x4a, r17
    6c8a:	2b a9       	sts	0x4b, r18
    6c8c:	3c a9       	sts	0x4c, r19
    6c8e:	78 01       	movw	r14, r16
    6c90:	dd 24       	eor	r13, r13
    6c92:	cc 24       	eor	r12, r12
    6c94:	c8 2a       	or	r12, r24
    6c96:	d9 2a       	or	r13, r25
    6c98:	ea 2a       	or	r14, r26
    6c9a:	fb 2a       	or	r15, r27
    6c9c:	ff ef       	ldi	r31, 0xFF	; 255
    6c9e:	8f 2e       	mov	r8, r31
    6ca0:	ff ef       	ldi	r31, 0xFF	; 255
    6ca2:	9f 2e       	mov	r9, r31
    6ca4:	a1 2c       	mov	r10, r1
    6ca6:	b1 2c       	mov	r11, r1
    6ca8:	8c 20       	and	r8, r12
    6caa:	9d 20       	and	r9, r13
    6cac:	ae 20       	and	r10, r14
    6cae:	bf 20       	and	r11, r15
    6cb0:	87 01       	movw	r16, r14
    6cb2:	22 27       	eor	r18, r18
    6cb4:	33 27       	eor	r19, r19
    6cb6:	09 a7       	lds	r16, 0x79
    6cb8:	1a a7       	lds	r17, 0x7a
    6cba:	2b a7       	lds	r18, 0x7b
    6cbc:	3c a7       	lds	r19, 0x7c
    6cbe:	49 ac       	sts	0xa9, r20
    6cc0:	5a ac       	sts	0xaa, r21
    6cc2:	6b ac       	sts	0xab, r22
    6cc4:	7c ac       	sts	0xac, r23
    6cc6:	2f ef       	ldi	r18, 0xFF	; 255
    6cc8:	3f ef       	ldi	r19, 0xFF	; 255
    6cca:	40 e0       	ldi	r20, 0x00	; 0
    6ccc:	50 e0       	ldi	r21, 0x00	; 0
    6cce:	42 22       	and	r4, r18
    6cd0:	53 22       	and	r5, r19
    6cd2:	64 22       	and	r6, r20
    6cd4:	75 22       	and	r7, r21
    6cd6:	29 ad       	sts	0x69, r18
    6cd8:	3a ad       	sts	0x6a, r19
    6cda:	4b ad       	sts	0x6b, r20
    6cdc:	5c ad       	sts	0x6c, r21
    6cde:	8a 01       	movw	r16, r20
    6ce0:	22 27       	eor	r18, r18
    6ce2:	33 27       	eor	r19, r19
    6ce4:	09 ab       	sts	0x59, r16
    6ce6:	1a ab       	sts	0x5a, r17
    6ce8:	2b ab       	sts	0x5b, r18
    6cea:	3c ab       	sts	0x5c, r19
    6cec:	c5 01       	movw	r24, r10
    6cee:	b4 01       	movw	r22, r8
    6cf0:	a3 01       	movw	r20, r6
    6cf2:	92 01       	movw	r18, r4
    6cf4:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    6cf8:	69 af       	sts	0x79, r22
    6cfa:	7a af       	sts	0x7a, r23
    6cfc:	8b af       	sts	0x7b, r24
    6cfe:	9c af       	sts	0x7c, r25
    6d00:	c5 01       	movw	r24, r10
    6d02:	b4 01       	movw	r22, r8
    6d04:	29 a9       	sts	0x49, r18
    6d06:	3a a9       	sts	0x4a, r19
    6d08:	4b a9       	sts	0x4b, r20
    6d0a:	5c a9       	sts	0x4c, r21
    6d0c:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    6d10:	4b 01       	movw	r8, r22
    6d12:	5c 01       	movw	r10, r24
    6d14:	69 a5       	lds	r22, 0x69
    6d16:	7a a5       	lds	r23, 0x6a
    6d18:	8b a5       	lds	r24, 0x6b
    6d1a:	9c a5       	lds	r25, 0x6c
    6d1c:	a3 01       	movw	r20, r6
    6d1e:	92 01       	movw	r18, r4
    6d20:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    6d24:	2b 01       	movw	r4, r22
    6d26:	3c 01       	movw	r6, r24
    6d28:	69 a5       	lds	r22, 0x69
    6d2a:	7a a5       	lds	r23, 0x6a
    6d2c:	8b a5       	lds	r24, 0x6b
    6d2e:	9c a5       	lds	r25, 0x6c
    6d30:	29 a9       	sts	0x49, r18
    6d32:	3a a9       	sts	0x4a, r19
    6d34:	4b a9       	sts	0x4b, r20
    6d36:	5c a9       	sts	0x4c, r21
    6d38:	0e 94 31 39 	call	0x7262	; 0x7262 <__mulsi3>
    6d3c:	ab 01       	movw	r20, r22
    6d3e:	bc 01       	movw	r22, r24
    6d40:	84 0c       	add	r8, r4
    6d42:	95 1c       	adc	r9, r5
    6d44:	a6 1c       	adc	r10, r6
    6d46:	b7 1c       	adc	r11, r7
    6d48:	09 ad       	sts	0x69, r16
    6d4a:	1a ad       	sts	0x6a, r17
    6d4c:	2b ad       	sts	0x6b, r18
    6d4e:	3c ad       	sts	0x6c, r19
    6d50:	c9 01       	movw	r24, r18
    6d52:	aa 27       	eor	r26, r26
    6d54:	bb 27       	eor	r27, r27
    6d56:	88 0e       	add	r8, r24
    6d58:	99 1e       	adc	r9, r25
    6d5a:	aa 1e       	adc	r10, r26
    6d5c:	bb 1e       	adc	r11, r27
    6d5e:	84 14       	cp	r8, r4
    6d60:	95 04       	cpc	r9, r5
    6d62:	a6 04       	cpc	r10, r6
    6d64:	b7 04       	cpc	r11, r7
    6d66:	20 f4       	brcc	.+8      	; 0x6d70 <__stack+0xd71>
    6d68:	40 50       	subi	r20, 0x00	; 0
    6d6a:	50 40       	sbci	r21, 0x00	; 0
    6d6c:	6f 4f       	sbci	r22, 0xFF	; 255
    6d6e:	7f 4f       	sbci	r23, 0xFF	; 255
    6d70:	c5 01       	movw	r24, r10
    6d72:	aa 27       	eor	r26, r26
    6d74:	bb 27       	eor	r27, r27
    6d76:	84 0f       	add	r24, r20
    6d78:	95 1f       	adc	r25, r21
    6d7a:	a6 1f       	adc	r26, r22
    6d7c:	b7 1f       	adc	r27, r23
    6d7e:	0d a5       	lds	r16, 0x6d
    6d80:	1e a5       	lds	r17, 0x6e
    6d82:	2f a5       	lds	r18, 0x6f
    6d84:	38 a9       	sts	0x48, r19
    6d86:	08 17       	cp	r16, r24
    6d88:	19 07       	cpc	r17, r25
    6d8a:	2a 07       	cpc	r18, r26
    6d8c:	3b 07       	cpc	r19, r27
    6d8e:	18 f1       	brcs	.+70     	; 0x6dd6 <__stack+0xdd7>
    6d90:	80 17       	cp	r24, r16
    6d92:	91 07       	cpc	r25, r17
    6d94:	a2 07       	cpc	r26, r18
    6d96:	b3 07       	cpc	r27, r19
    6d98:	a1 f5       	brne	.+104    	; 0x6e02 <__stack+0xe03>
    6d9a:	54 01       	movw	r10, r8
    6d9c:	99 24       	eor	r9, r9
    6d9e:	88 24       	eor	r8, r8
    6da0:	89 ad       	sts	0x69, r24
    6da2:	9a ad       	sts	0x6a, r25
    6da4:	ab ad       	sts	0x6b, r26
    6da6:	bc ad       	sts	0x6c, r27
    6da8:	a0 70       	andi	r26, 0x00	; 0
    6daa:	b0 70       	andi	r27, 0x00	; 0
    6dac:	88 0e       	add	r8, r24
    6dae:	99 1e       	adc	r9, r25
    6db0:	aa 1e       	adc	r10, r26
    6db2:	bb 1e       	adc	r11, r27
    6db4:	4d a9       	sts	0x4d, r20
    6db6:	5e a9       	sts	0x4e, r21
    6db8:	6f a9       	sts	0x4f, r22
    6dba:	78 ad       	sts	0x68, r23
    6dbc:	03 2c       	mov	r0, r3
    6dbe:	04 c0       	rjmp	.+8      	; 0x6dc8 <__stack+0xdc9>
    6dc0:	44 0f       	add	r20, r20
    6dc2:	55 1f       	adc	r21, r21
    6dc4:	66 1f       	adc	r22, r22
    6dc6:	77 1f       	adc	r23, r23
    6dc8:	0a 94       	dec	r0
    6dca:	d2 f7       	brpl	.-12     	; 0x6dc0 <__stack+0xdc1>
    6dcc:	48 15       	cp	r20, r8
    6dce:	59 05       	cpc	r21, r9
    6dd0:	6a 05       	cpc	r22, r10
    6dd2:	7b 05       	cpc	r23, r11
    6dd4:	b0 f4       	brcc	.+44     	; 0x6e02 <__stack+0xe03>
    6dd6:	08 94       	sec
    6dd8:	c1 08       	sbc	r12, r1
    6dda:	d1 08       	sbc	r13, r1
    6ddc:	e1 08       	sbc	r14, r1
    6dde:	f1 08       	sbc	r15, r1
    6de0:	10 c0       	rjmp	.+32     	; 0x6e02 <__stack+0xe03>
    6de2:	44 24       	eor	r4, r4
    6de4:	55 24       	eor	r5, r5
    6de6:	32 01       	movw	r6, r4
    6de8:	cc 24       	eor	r12, r12
    6dea:	dd 24       	eor	r13, r13
    6dec:	76 01       	movw	r14, r12
    6dee:	0c c0       	rjmp	.+24     	; 0x6e08 <__stack+0xe09>
    6df0:	44 24       	eor	r4, r4
    6df2:	55 24       	eor	r5, r5
    6df4:	32 01       	movw	r6, r4
    6df6:	81 e0       	ldi	r24, 0x01	; 1
    6df8:	c8 2e       	mov	r12, r24
    6dfa:	d1 2c       	mov	r13, r1
    6dfc:	e1 2c       	mov	r14, r1
    6dfe:	f1 2c       	mov	r15, r1
    6e00:	03 c0       	rjmp	.+6      	; 0x6e08 <__stack+0xe09>
    6e02:	44 24       	eor	r4, r4
    6e04:	55 24       	eor	r5, r5
    6e06:	32 01       	movw	r6, r4
    6e08:	fe 01       	movw	r30, r28
    6e0a:	31 96       	adiw	r30, 0x01	; 1
    6e0c:	88 e0       	ldi	r24, 0x08	; 8
    6e0e:	df 01       	movw	r26, r30
    6e10:	1d 92       	st	X+, r1
    6e12:	8a 95       	dec	r24
    6e14:	e9 f7       	brne	.-6      	; 0x6e10 <__stack+0xe11>
    6e16:	c9 82       	std	Y+1, r12	; 0x01
    6e18:	da 82       	std	Y+2, r13	; 0x02
    6e1a:	eb 82       	std	Y+3, r14	; 0x03
    6e1c:	fc 82       	std	Y+4, r15	; 0x04
    6e1e:	4d 82       	std	Y+5, r4	; 0x05
    6e20:	5e 82       	std	Y+6, r5	; 0x06
    6e22:	6f 82       	std	Y+7, r6	; 0x07
    6e24:	78 86       	std	Y+8, r7	; 0x08
    6e26:	2c 2d       	mov	r18, r12
    6e28:	3a 81       	ldd	r19, Y+2	; 0x02
    6e2a:	4b 81       	ldd	r20, Y+3	; 0x03
    6e2c:	5c 81       	ldd	r21, Y+4	; 0x04
    6e2e:	64 2d       	mov	r22, r4
    6e30:	7e 81       	ldd	r23, Y+6	; 0x06
    6e32:	8f 81       	ldd	r24, Y+7	; 0x07
    6e34:	98 85       	ldd	r25, Y+8	; 0x08
    6e36:	25 96       	adiw	r28, 0x05	; 5
    6e38:	ec ac       	sts	0xac, r30
    6e3a:	fd ac       	sts	0xad, r31
    6e3c:	0e ad       	sts	0x6e, r16
    6e3e:	1f ad       	sts	0x6f, r17
    6e40:	25 97       	sbiw	r28, 0x05	; 5
    6e42:	e1 14       	cp	r14, r1
    6e44:	f1 04       	cpc	r15, r1
    6e46:	01 05       	cpc	r16, r1
    6e48:	11 05       	cpc	r17, r1
    6e4a:	09 f4       	brne	.+2      	; 0x6e4e <__stack+0xe4f>
    6e4c:	56 c0       	rjmp	.+172    	; 0x6efa <__stack+0xefb>
    6e4e:	21 95       	neg	r18
    6e50:	e1 e0       	ldi	r30, 0x01	; 1
    6e52:	12 16       	cp	r1, r18
    6e54:	08 f0       	brcs	.+2      	; 0x6e58 <__stack+0xe59>
    6e56:	e0 e0       	ldi	r30, 0x00	; 0
    6e58:	31 95       	neg	r19
    6e5a:	f1 e0       	ldi	r31, 0x01	; 1
    6e5c:	13 16       	cp	r1, r19
    6e5e:	08 f0       	brcs	.+2      	; 0x6e62 <__stack+0xe63>
    6e60:	f0 e0       	ldi	r31, 0x00	; 0
    6e62:	03 2f       	mov	r16, r19
    6e64:	0e 1b       	sub	r16, r30
    6e66:	e1 e0       	ldi	r30, 0x01	; 1
    6e68:	30 17       	cp	r19, r16
    6e6a:	08 f0       	brcs	.+2      	; 0x6e6e <__stack+0xe6f>
    6e6c:	e0 e0       	ldi	r30, 0x00	; 0
    6e6e:	fe 2b       	or	r31, r30
    6e70:	41 95       	neg	r20
    6e72:	e1 e0       	ldi	r30, 0x01	; 1
    6e74:	14 16       	cp	r1, r20
    6e76:	08 f0       	brcs	.+2      	; 0x6e7a <__stack+0xe7b>
    6e78:	e0 e0       	ldi	r30, 0x00	; 0
    6e7a:	14 2f       	mov	r17, r20
    6e7c:	1f 1b       	sub	r17, r31
    6e7e:	31 e0       	ldi	r19, 0x01	; 1
    6e80:	41 17       	cp	r20, r17
    6e82:	08 f0       	brcs	.+2      	; 0x6e86 <__stack+0xe87>
    6e84:	30 e0       	ldi	r19, 0x00	; 0
    6e86:	e3 2b       	or	r30, r19
    6e88:	51 95       	neg	r21
    6e8a:	f1 e0       	ldi	r31, 0x01	; 1
    6e8c:	15 16       	cp	r1, r21
    6e8e:	08 f0       	brcs	.+2      	; 0x6e92 <__stack+0xe93>
    6e90:	f0 e0       	ldi	r31, 0x00	; 0
    6e92:	b5 2f       	mov	r27, r21
    6e94:	be 1b       	sub	r27, r30
    6e96:	31 e0       	ldi	r19, 0x01	; 1
    6e98:	5b 17       	cp	r21, r27
    6e9a:	08 f0       	brcs	.+2      	; 0x6e9e <__stack+0xe9f>
    6e9c:	30 e0       	ldi	r19, 0x00	; 0
    6e9e:	f3 2b       	or	r31, r19
    6ea0:	61 95       	neg	r22
    6ea2:	e1 e0       	ldi	r30, 0x01	; 1
    6ea4:	16 16       	cp	r1, r22
    6ea6:	08 f0       	brcs	.+2      	; 0x6eaa <__stack+0xeab>
    6ea8:	e0 e0       	ldi	r30, 0x00	; 0
    6eaa:	46 2e       	mov	r4, r22
    6eac:	4f 1a       	sub	r4, r31
    6eae:	31 e0       	ldi	r19, 0x01	; 1
    6eb0:	64 15       	cp	r22, r4
    6eb2:	08 f0       	brcs	.+2      	; 0x6eb6 <__stack+0xeb7>
    6eb4:	30 e0       	ldi	r19, 0x00	; 0
    6eb6:	e3 2b       	or	r30, r19
    6eb8:	71 95       	neg	r23
    6eba:	f1 e0       	ldi	r31, 0x01	; 1
    6ebc:	17 16       	cp	r1, r23
    6ebe:	08 f0       	brcs	.+2      	; 0x6ec2 <__stack+0xec3>
    6ec0:	f0 e0       	ldi	r31, 0x00	; 0
    6ec2:	a7 2f       	mov	r26, r23
    6ec4:	ae 1b       	sub	r26, r30
    6ec6:	31 e0       	ldi	r19, 0x01	; 1
    6ec8:	7a 17       	cp	r23, r26
    6eca:	08 f0       	brcs	.+2      	; 0x6ece <__stack+0xecf>
    6ecc:	30 e0       	ldi	r19, 0x00	; 0
    6ece:	f3 2b       	or	r31, r19
    6ed0:	81 95       	neg	r24
    6ed2:	e1 e0       	ldi	r30, 0x01	; 1
    6ed4:	18 16       	cp	r1, r24
    6ed6:	08 f0       	brcs	.+2      	; 0x6eda <__stack+0xedb>
    6ed8:	e0 e0       	ldi	r30, 0x00	; 0
    6eda:	f8 2e       	mov	r15, r24
    6edc:	ff 1a       	sub	r15, r31
    6ede:	ff 2d       	mov	r31, r15
    6ee0:	31 e0       	ldi	r19, 0x01	; 1
    6ee2:	8f 15       	cp	r24, r15
    6ee4:	08 f0       	brcs	.+2      	; 0x6ee8 <__stack+0xee9>
    6ee6:	30 e0       	ldi	r19, 0x00	; 0
    6ee8:	e3 2b       	or	r30, r19
    6eea:	91 95       	neg	r25
    6eec:	30 2f       	mov	r19, r16
    6eee:	41 2f       	mov	r20, r17
    6ef0:	5b 2f       	mov	r21, r27
    6ef2:	64 2d       	mov	r22, r4
    6ef4:	7a 2f       	mov	r23, r26
    6ef6:	8f 2f       	mov	r24, r31
    6ef8:	9e 1b       	sub	r25, r30
    6efa:	c8 5b       	subi	r28, 0xB8	; 184
    6efc:	df 4f       	sbci	r29, 0xFF	; 255
    6efe:	e1 e1       	ldi	r30, 0x11	; 17
    6f00:	0c 94 ce 39 	jmp	0x739c	; 0x739c <__epilogue_restores__+0x2>

00006f04 <__subsf3>:
    6f04:	50 58       	subi	r21, 0x80	; 128

00006f06 <__addsf3>:
    6f06:	bb 27       	eor	r27, r27
    6f08:	aa 27       	eor	r26, r26
    6f0a:	0e d0       	rcall	.+28     	; 0x6f28 <__addsf3x>
    6f0c:	48 c1       	rjmp	.+656    	; 0x719e <__fp_round>
    6f0e:	39 d1       	rcall	.+626    	; 0x7182 <__fp_pscA>
    6f10:	30 f0       	brcs	.+12     	; 0x6f1e <__addsf3+0x18>
    6f12:	3e d1       	rcall	.+636    	; 0x7190 <__fp_pscB>
    6f14:	20 f0       	brcs	.+8      	; 0x6f1e <__addsf3+0x18>
    6f16:	31 f4       	brne	.+12     	; 0x6f24 <__addsf3+0x1e>
    6f18:	9f 3f       	cpi	r25, 0xFF	; 255
    6f1a:	11 f4       	brne	.+4      	; 0x6f20 <__addsf3+0x1a>
    6f1c:	1e f4       	brtc	.+6      	; 0x6f24 <__addsf3+0x1e>
    6f1e:	2e c1       	rjmp	.+604    	; 0x717c <__fp_nan>
    6f20:	0e f4       	brtc	.+2      	; 0x6f24 <__addsf3+0x1e>
    6f22:	e0 95       	com	r30
    6f24:	e7 fb       	bst	r30, 7
    6f26:	24 c1       	rjmp	.+584    	; 0x7170 <__fp_inf>

00006f28 <__addsf3x>:
    6f28:	e9 2f       	mov	r30, r25
    6f2a:	4a d1       	rcall	.+660    	; 0x71c0 <__fp_split3>
    6f2c:	80 f3       	brcs	.-32     	; 0x6f0e <__addsf3+0x8>
    6f2e:	ba 17       	cp	r27, r26
    6f30:	62 07       	cpc	r22, r18
    6f32:	73 07       	cpc	r23, r19
    6f34:	84 07       	cpc	r24, r20
    6f36:	95 07       	cpc	r25, r21
    6f38:	18 f0       	brcs	.+6      	; 0x6f40 <__addsf3x+0x18>
    6f3a:	71 f4       	brne	.+28     	; 0x6f58 <__addsf3x+0x30>
    6f3c:	9e f5       	brtc	.+102    	; 0x6fa4 <__addsf3x+0x7c>
    6f3e:	62 c1       	rjmp	.+708    	; 0x7204 <__fp_zero>
    6f40:	0e f4       	brtc	.+2      	; 0x6f44 <__addsf3x+0x1c>
    6f42:	e0 95       	com	r30
    6f44:	0b 2e       	mov	r0, r27
    6f46:	ba 2f       	mov	r27, r26
    6f48:	a0 2d       	mov	r26, r0
    6f4a:	0b 01       	movw	r0, r22
    6f4c:	b9 01       	movw	r22, r18
    6f4e:	90 01       	movw	r18, r0
    6f50:	0c 01       	movw	r0, r24
    6f52:	ca 01       	movw	r24, r20
    6f54:	a0 01       	movw	r20, r0
    6f56:	11 24       	eor	r1, r1
    6f58:	ff 27       	eor	r31, r31
    6f5a:	59 1b       	sub	r21, r25
    6f5c:	99 f0       	breq	.+38     	; 0x6f84 <__addsf3x+0x5c>
    6f5e:	59 3f       	cpi	r21, 0xF9	; 249
    6f60:	50 f4       	brcc	.+20     	; 0x6f76 <__addsf3x+0x4e>
    6f62:	50 3e       	cpi	r21, 0xE0	; 224
    6f64:	68 f1       	brcs	.+90     	; 0x6fc0 <__addsf3x+0x98>
    6f66:	1a 16       	cp	r1, r26
    6f68:	f0 40       	sbci	r31, 0x00	; 0
    6f6a:	a2 2f       	mov	r26, r18
    6f6c:	23 2f       	mov	r18, r19
    6f6e:	34 2f       	mov	r19, r20
    6f70:	44 27       	eor	r20, r20
    6f72:	58 5f       	subi	r21, 0xF8	; 248
    6f74:	f3 cf       	rjmp	.-26     	; 0x6f5c <__addsf3x+0x34>
    6f76:	46 95       	lsr	r20
    6f78:	37 95       	ror	r19
    6f7a:	27 95       	ror	r18
    6f7c:	a7 95       	ror	r26
    6f7e:	f0 40       	sbci	r31, 0x00	; 0
    6f80:	53 95       	inc	r21
    6f82:	c9 f7       	brne	.-14     	; 0x6f76 <__addsf3x+0x4e>
    6f84:	7e f4       	brtc	.+30     	; 0x6fa4 <__addsf3x+0x7c>
    6f86:	1f 16       	cp	r1, r31
    6f88:	ba 0b       	sbc	r27, r26
    6f8a:	62 0b       	sbc	r22, r18
    6f8c:	73 0b       	sbc	r23, r19
    6f8e:	84 0b       	sbc	r24, r20
    6f90:	ba f0       	brmi	.+46     	; 0x6fc0 <__addsf3x+0x98>
    6f92:	91 50       	subi	r25, 0x01	; 1
    6f94:	a1 f0       	breq	.+40     	; 0x6fbe <__addsf3x+0x96>
    6f96:	ff 0f       	add	r31, r31
    6f98:	bb 1f       	adc	r27, r27
    6f9a:	66 1f       	adc	r22, r22
    6f9c:	77 1f       	adc	r23, r23
    6f9e:	88 1f       	adc	r24, r24
    6fa0:	c2 f7       	brpl	.-16     	; 0x6f92 <__addsf3x+0x6a>
    6fa2:	0e c0       	rjmp	.+28     	; 0x6fc0 <__addsf3x+0x98>
    6fa4:	ba 0f       	add	r27, r26
    6fa6:	62 1f       	adc	r22, r18
    6fa8:	73 1f       	adc	r23, r19
    6faa:	84 1f       	adc	r24, r20
    6fac:	48 f4       	brcc	.+18     	; 0x6fc0 <__addsf3x+0x98>
    6fae:	87 95       	ror	r24
    6fb0:	77 95       	ror	r23
    6fb2:	67 95       	ror	r22
    6fb4:	b7 95       	ror	r27
    6fb6:	f7 95       	ror	r31
    6fb8:	9e 3f       	cpi	r25, 0xFE	; 254
    6fba:	08 f0       	brcs	.+2      	; 0x6fbe <__addsf3x+0x96>
    6fbc:	b3 cf       	rjmp	.-154    	; 0x6f24 <__addsf3+0x1e>
    6fbe:	93 95       	inc	r25
    6fc0:	88 0f       	add	r24, r24
    6fc2:	08 f0       	brcs	.+2      	; 0x6fc6 <__addsf3x+0x9e>
    6fc4:	99 27       	eor	r25, r25
    6fc6:	ee 0f       	add	r30, r30
    6fc8:	97 95       	ror	r25
    6fca:	87 95       	ror	r24
    6fcc:	08 95       	ret

00006fce <__divsf3>:
    6fce:	0c d0       	rcall	.+24     	; 0x6fe8 <__divsf3x>
    6fd0:	e6 c0       	rjmp	.+460    	; 0x719e <__fp_round>
    6fd2:	de d0       	rcall	.+444    	; 0x7190 <__fp_pscB>
    6fd4:	40 f0       	brcs	.+16     	; 0x6fe6 <__divsf3+0x18>
    6fd6:	d5 d0       	rcall	.+426    	; 0x7182 <__fp_pscA>
    6fd8:	30 f0       	brcs	.+12     	; 0x6fe6 <__divsf3+0x18>
    6fda:	21 f4       	brne	.+8      	; 0x6fe4 <__divsf3+0x16>
    6fdc:	5f 3f       	cpi	r21, 0xFF	; 255
    6fde:	19 f0       	breq	.+6      	; 0x6fe6 <__divsf3+0x18>
    6fe0:	c7 c0       	rjmp	.+398    	; 0x7170 <__fp_inf>
    6fe2:	51 11       	cpse	r21, r1
    6fe4:	10 c1       	rjmp	.+544    	; 0x7206 <__fp_szero>
    6fe6:	ca c0       	rjmp	.+404    	; 0x717c <__fp_nan>

00006fe8 <__divsf3x>:
    6fe8:	eb d0       	rcall	.+470    	; 0x71c0 <__fp_split3>
    6fea:	98 f3       	brcs	.-26     	; 0x6fd2 <__divsf3+0x4>

00006fec <__divsf3_pse>:
    6fec:	99 23       	and	r25, r25
    6fee:	c9 f3       	breq	.-14     	; 0x6fe2 <__divsf3+0x14>
    6ff0:	55 23       	and	r21, r21
    6ff2:	b1 f3       	breq	.-20     	; 0x6fe0 <__divsf3+0x12>
    6ff4:	95 1b       	sub	r25, r21
    6ff6:	55 0b       	sbc	r21, r21
    6ff8:	bb 27       	eor	r27, r27
    6ffa:	aa 27       	eor	r26, r26
    6ffc:	62 17       	cp	r22, r18
    6ffe:	73 07       	cpc	r23, r19
    7000:	84 07       	cpc	r24, r20
    7002:	38 f0       	brcs	.+14     	; 0x7012 <__divsf3_pse+0x26>
    7004:	9f 5f       	subi	r25, 0xFF	; 255
    7006:	5f 4f       	sbci	r21, 0xFF	; 255
    7008:	22 0f       	add	r18, r18
    700a:	33 1f       	adc	r19, r19
    700c:	44 1f       	adc	r20, r20
    700e:	aa 1f       	adc	r26, r26
    7010:	a9 f3       	breq	.-22     	; 0x6ffc <__divsf3_pse+0x10>
    7012:	33 d0       	rcall	.+102    	; 0x707a <__divsf3_pse+0x8e>
    7014:	0e 2e       	mov	r0, r30
    7016:	3a f0       	brmi	.+14     	; 0x7026 <__divsf3_pse+0x3a>
    7018:	e0 e8       	ldi	r30, 0x80	; 128
    701a:	30 d0       	rcall	.+96     	; 0x707c <__divsf3_pse+0x90>
    701c:	91 50       	subi	r25, 0x01	; 1
    701e:	50 40       	sbci	r21, 0x00	; 0
    7020:	e6 95       	lsr	r30
    7022:	00 1c       	adc	r0, r0
    7024:	ca f7       	brpl	.-14     	; 0x7018 <__divsf3_pse+0x2c>
    7026:	29 d0       	rcall	.+82     	; 0x707a <__divsf3_pse+0x8e>
    7028:	fe 2f       	mov	r31, r30
    702a:	27 d0       	rcall	.+78     	; 0x707a <__divsf3_pse+0x8e>
    702c:	66 0f       	add	r22, r22
    702e:	77 1f       	adc	r23, r23
    7030:	88 1f       	adc	r24, r24
    7032:	bb 1f       	adc	r27, r27
    7034:	26 17       	cp	r18, r22
    7036:	37 07       	cpc	r19, r23
    7038:	48 07       	cpc	r20, r24
    703a:	ab 07       	cpc	r26, r27
    703c:	b0 e8       	ldi	r27, 0x80	; 128
    703e:	09 f0       	breq	.+2      	; 0x7042 <__divsf3_pse+0x56>
    7040:	bb 0b       	sbc	r27, r27
    7042:	80 2d       	mov	r24, r0
    7044:	bf 01       	movw	r22, r30
    7046:	ff 27       	eor	r31, r31
    7048:	93 58       	subi	r25, 0x83	; 131
    704a:	5f 4f       	sbci	r21, 0xFF	; 255
    704c:	2a f0       	brmi	.+10     	; 0x7058 <__divsf3_pse+0x6c>
    704e:	9e 3f       	cpi	r25, 0xFE	; 254
    7050:	51 05       	cpc	r21, r1
    7052:	68 f0       	brcs	.+26     	; 0x706e <__divsf3_pse+0x82>
    7054:	8d c0       	rjmp	.+282    	; 0x7170 <__fp_inf>
    7056:	d7 c0       	rjmp	.+430    	; 0x7206 <__fp_szero>
    7058:	5f 3f       	cpi	r21, 0xFF	; 255
    705a:	ec f3       	brlt	.-6      	; 0x7056 <__divsf3_pse+0x6a>
    705c:	98 3e       	cpi	r25, 0xE8	; 232
    705e:	dc f3       	brlt	.-10     	; 0x7056 <__divsf3_pse+0x6a>
    7060:	86 95       	lsr	r24
    7062:	77 95       	ror	r23
    7064:	67 95       	ror	r22
    7066:	b7 95       	ror	r27
    7068:	f7 95       	ror	r31
    706a:	9f 5f       	subi	r25, 0xFF	; 255
    706c:	c9 f7       	brne	.-14     	; 0x7060 <__divsf3_pse+0x74>
    706e:	88 0f       	add	r24, r24
    7070:	91 1d       	adc	r25, r1
    7072:	96 95       	lsr	r25
    7074:	87 95       	ror	r24
    7076:	97 f9       	bld	r25, 7
    7078:	08 95       	ret
    707a:	e1 e0       	ldi	r30, 0x01	; 1
    707c:	66 0f       	add	r22, r22
    707e:	77 1f       	adc	r23, r23
    7080:	88 1f       	adc	r24, r24
    7082:	bb 1f       	adc	r27, r27
    7084:	62 17       	cp	r22, r18
    7086:	73 07       	cpc	r23, r19
    7088:	84 07       	cpc	r24, r20
    708a:	ba 07       	cpc	r27, r26
    708c:	20 f0       	brcs	.+8      	; 0x7096 <__divsf3_pse+0xaa>
    708e:	62 1b       	sub	r22, r18
    7090:	73 0b       	sbc	r23, r19
    7092:	84 0b       	sbc	r24, r20
    7094:	ba 0b       	sbc	r27, r26
    7096:	ee 1f       	adc	r30, r30
    7098:	88 f7       	brcc	.-30     	; 0x707c <__divsf3_pse+0x90>
    709a:	e0 95       	com	r30
    709c:	08 95       	ret

0000709e <__fixunssfsi>:
    709e:	98 d0       	rcall	.+304    	; 0x71d0 <__fp_splitA>
    70a0:	88 f0       	brcs	.+34     	; 0x70c4 <__fixunssfsi+0x26>
    70a2:	9f 57       	subi	r25, 0x7F	; 127
    70a4:	90 f0       	brcs	.+36     	; 0x70ca <__fixunssfsi+0x2c>
    70a6:	b9 2f       	mov	r27, r25
    70a8:	99 27       	eor	r25, r25
    70aa:	b7 51       	subi	r27, 0x17	; 23
    70ac:	a0 f0       	brcs	.+40     	; 0x70d6 <__fixunssfsi+0x38>
    70ae:	d1 f0       	breq	.+52     	; 0x70e4 <__fixunssfsi+0x46>
    70b0:	66 0f       	add	r22, r22
    70b2:	77 1f       	adc	r23, r23
    70b4:	88 1f       	adc	r24, r24
    70b6:	99 1f       	adc	r25, r25
    70b8:	1a f0       	brmi	.+6      	; 0x70c0 <__fixunssfsi+0x22>
    70ba:	ba 95       	dec	r27
    70bc:	c9 f7       	brne	.-14     	; 0x70b0 <__fixunssfsi+0x12>
    70be:	12 c0       	rjmp	.+36     	; 0x70e4 <__fixunssfsi+0x46>
    70c0:	b1 30       	cpi	r27, 0x01	; 1
    70c2:	81 f0       	breq	.+32     	; 0x70e4 <__fixunssfsi+0x46>
    70c4:	9f d0       	rcall	.+318    	; 0x7204 <__fp_zero>
    70c6:	b1 e0       	ldi	r27, 0x01	; 1
    70c8:	08 95       	ret
    70ca:	9c c0       	rjmp	.+312    	; 0x7204 <__fp_zero>
    70cc:	67 2f       	mov	r22, r23
    70ce:	78 2f       	mov	r23, r24
    70d0:	88 27       	eor	r24, r24
    70d2:	b8 5f       	subi	r27, 0xF8	; 248
    70d4:	39 f0       	breq	.+14     	; 0x70e4 <__fixunssfsi+0x46>
    70d6:	b9 3f       	cpi	r27, 0xF9	; 249
    70d8:	cc f3       	brlt	.-14     	; 0x70cc <__fixunssfsi+0x2e>
    70da:	86 95       	lsr	r24
    70dc:	77 95       	ror	r23
    70de:	67 95       	ror	r22
    70e0:	b3 95       	inc	r27
    70e2:	d9 f7       	brne	.-10     	; 0x70da <__fixunssfsi+0x3c>
    70e4:	3e f4       	brtc	.+14     	; 0x70f4 <__fixunssfsi+0x56>
    70e6:	90 95       	com	r25
    70e8:	80 95       	com	r24
    70ea:	70 95       	com	r23
    70ec:	61 95       	neg	r22
    70ee:	7f 4f       	sbci	r23, 0xFF	; 255
    70f0:	8f 4f       	sbci	r24, 0xFF	; 255
    70f2:	9f 4f       	sbci	r25, 0xFF	; 255
    70f4:	08 95       	ret

000070f6 <__floatunsisf>:
    70f6:	e8 94       	clt
    70f8:	09 c0       	rjmp	.+18     	; 0x710c <__floatsisf+0x12>

000070fa <__floatsisf>:
    70fa:	97 fb       	bst	r25, 7
    70fc:	3e f4       	brtc	.+14     	; 0x710c <__floatsisf+0x12>
    70fe:	90 95       	com	r25
    7100:	80 95       	com	r24
    7102:	70 95       	com	r23
    7104:	61 95       	neg	r22
    7106:	7f 4f       	sbci	r23, 0xFF	; 255
    7108:	8f 4f       	sbci	r24, 0xFF	; 255
    710a:	9f 4f       	sbci	r25, 0xFF	; 255
    710c:	99 23       	and	r25, r25
    710e:	a9 f0       	breq	.+42     	; 0x713a <__floatsisf+0x40>
    7110:	f9 2f       	mov	r31, r25
    7112:	96 e9       	ldi	r25, 0x96	; 150
    7114:	bb 27       	eor	r27, r27
    7116:	93 95       	inc	r25
    7118:	f6 95       	lsr	r31
    711a:	87 95       	ror	r24
    711c:	77 95       	ror	r23
    711e:	67 95       	ror	r22
    7120:	b7 95       	ror	r27
    7122:	f1 11       	cpse	r31, r1
    7124:	f8 cf       	rjmp	.-16     	; 0x7116 <__floatsisf+0x1c>
    7126:	fa f4       	brpl	.+62     	; 0x7166 <__floatsisf+0x6c>
    7128:	bb 0f       	add	r27, r27
    712a:	11 f4       	brne	.+4      	; 0x7130 <__floatsisf+0x36>
    712c:	60 ff       	sbrs	r22, 0
    712e:	1b c0       	rjmp	.+54     	; 0x7166 <__floatsisf+0x6c>
    7130:	6f 5f       	subi	r22, 0xFF	; 255
    7132:	7f 4f       	sbci	r23, 0xFF	; 255
    7134:	8f 4f       	sbci	r24, 0xFF	; 255
    7136:	9f 4f       	sbci	r25, 0xFF	; 255
    7138:	16 c0       	rjmp	.+44     	; 0x7166 <__floatsisf+0x6c>
    713a:	88 23       	and	r24, r24
    713c:	11 f0       	breq	.+4      	; 0x7142 <__floatsisf+0x48>
    713e:	96 e9       	ldi	r25, 0x96	; 150
    7140:	11 c0       	rjmp	.+34     	; 0x7164 <__floatsisf+0x6a>
    7142:	77 23       	and	r23, r23
    7144:	21 f0       	breq	.+8      	; 0x714e <__floatsisf+0x54>
    7146:	9e e8       	ldi	r25, 0x8E	; 142
    7148:	87 2f       	mov	r24, r23
    714a:	76 2f       	mov	r23, r22
    714c:	05 c0       	rjmp	.+10     	; 0x7158 <__floatsisf+0x5e>
    714e:	66 23       	and	r22, r22
    7150:	71 f0       	breq	.+28     	; 0x716e <__floatsisf+0x74>
    7152:	96 e8       	ldi	r25, 0x86	; 134
    7154:	86 2f       	mov	r24, r22
    7156:	70 e0       	ldi	r23, 0x00	; 0
    7158:	60 e0       	ldi	r22, 0x00	; 0
    715a:	2a f0       	brmi	.+10     	; 0x7166 <__floatsisf+0x6c>
    715c:	9a 95       	dec	r25
    715e:	66 0f       	add	r22, r22
    7160:	77 1f       	adc	r23, r23
    7162:	88 1f       	adc	r24, r24
    7164:	da f7       	brpl	.-10     	; 0x715c <__floatsisf+0x62>
    7166:	88 0f       	add	r24, r24
    7168:	96 95       	lsr	r25
    716a:	87 95       	ror	r24
    716c:	97 f9       	bld	r25, 7
    716e:	08 95       	ret

00007170 <__fp_inf>:
    7170:	97 f9       	bld	r25, 7
    7172:	9f 67       	ori	r25, 0x7F	; 127
    7174:	80 e8       	ldi	r24, 0x80	; 128
    7176:	70 e0       	ldi	r23, 0x00	; 0
    7178:	60 e0       	ldi	r22, 0x00	; 0
    717a:	08 95       	ret

0000717c <__fp_nan>:
    717c:	9f ef       	ldi	r25, 0xFF	; 255
    717e:	80 ec       	ldi	r24, 0xC0	; 192
    7180:	08 95       	ret

00007182 <__fp_pscA>:
    7182:	00 24       	eor	r0, r0
    7184:	0a 94       	dec	r0
    7186:	16 16       	cp	r1, r22
    7188:	17 06       	cpc	r1, r23
    718a:	18 06       	cpc	r1, r24
    718c:	09 06       	cpc	r0, r25
    718e:	08 95       	ret

00007190 <__fp_pscB>:
    7190:	00 24       	eor	r0, r0
    7192:	0a 94       	dec	r0
    7194:	12 16       	cp	r1, r18
    7196:	13 06       	cpc	r1, r19
    7198:	14 06       	cpc	r1, r20
    719a:	05 06       	cpc	r0, r21
    719c:	08 95       	ret

0000719e <__fp_round>:
    719e:	09 2e       	mov	r0, r25
    71a0:	03 94       	inc	r0
    71a2:	00 0c       	add	r0, r0
    71a4:	11 f4       	brne	.+4      	; 0x71aa <__fp_round+0xc>
    71a6:	88 23       	and	r24, r24
    71a8:	52 f0       	brmi	.+20     	; 0x71be <__fp_round+0x20>
    71aa:	bb 0f       	add	r27, r27
    71ac:	40 f4       	brcc	.+16     	; 0x71be <__fp_round+0x20>
    71ae:	bf 2b       	or	r27, r31
    71b0:	11 f4       	brne	.+4      	; 0x71b6 <__fp_round+0x18>
    71b2:	60 ff       	sbrs	r22, 0
    71b4:	04 c0       	rjmp	.+8      	; 0x71be <__fp_round+0x20>
    71b6:	6f 5f       	subi	r22, 0xFF	; 255
    71b8:	7f 4f       	sbci	r23, 0xFF	; 255
    71ba:	8f 4f       	sbci	r24, 0xFF	; 255
    71bc:	9f 4f       	sbci	r25, 0xFF	; 255
    71be:	08 95       	ret

000071c0 <__fp_split3>:
    71c0:	57 fd       	sbrc	r21, 7
    71c2:	90 58       	subi	r25, 0x80	; 128
    71c4:	44 0f       	add	r20, r20
    71c6:	55 1f       	adc	r21, r21
    71c8:	59 f0       	breq	.+22     	; 0x71e0 <__fp_splitA+0x10>
    71ca:	5f 3f       	cpi	r21, 0xFF	; 255
    71cc:	71 f0       	breq	.+28     	; 0x71ea <__fp_splitA+0x1a>
    71ce:	47 95       	ror	r20

000071d0 <__fp_splitA>:
    71d0:	88 0f       	add	r24, r24
    71d2:	97 fb       	bst	r25, 7
    71d4:	99 1f       	adc	r25, r25
    71d6:	61 f0       	breq	.+24     	; 0x71f0 <__fp_splitA+0x20>
    71d8:	9f 3f       	cpi	r25, 0xFF	; 255
    71da:	79 f0       	breq	.+30     	; 0x71fa <__fp_splitA+0x2a>
    71dc:	87 95       	ror	r24
    71de:	08 95       	ret
    71e0:	12 16       	cp	r1, r18
    71e2:	13 06       	cpc	r1, r19
    71e4:	14 06       	cpc	r1, r20
    71e6:	55 1f       	adc	r21, r21
    71e8:	f2 cf       	rjmp	.-28     	; 0x71ce <__fp_split3+0xe>
    71ea:	46 95       	lsr	r20
    71ec:	f1 df       	rcall	.-30     	; 0x71d0 <__fp_splitA>
    71ee:	08 c0       	rjmp	.+16     	; 0x7200 <__fp_splitA+0x30>
    71f0:	16 16       	cp	r1, r22
    71f2:	17 06       	cpc	r1, r23
    71f4:	18 06       	cpc	r1, r24
    71f6:	99 1f       	adc	r25, r25
    71f8:	f1 cf       	rjmp	.-30     	; 0x71dc <__fp_splitA+0xc>
    71fa:	86 95       	lsr	r24
    71fc:	71 05       	cpc	r23, r1
    71fe:	61 05       	cpc	r22, r1
    7200:	08 94       	sec
    7202:	08 95       	ret

00007204 <__fp_zero>:
    7204:	e8 94       	clt

00007206 <__fp_szero>:
    7206:	bb 27       	eor	r27, r27
    7208:	66 27       	eor	r22, r22
    720a:	77 27       	eor	r23, r23
    720c:	cb 01       	movw	r24, r22
    720e:	97 f9       	bld	r25, 7
    7210:	08 95       	ret

00007212 <__gesf2>:
    7212:	03 d0       	rcall	.+6      	; 0x721a <__fp_cmp>
    7214:	08 f4       	brcc	.+2      	; 0x7218 <__gesf2+0x6>
    7216:	8f ef       	ldi	r24, 0xFF	; 255
    7218:	08 95       	ret

0000721a <__fp_cmp>:
    721a:	99 0f       	add	r25, r25
    721c:	00 08       	sbc	r0, r0
    721e:	55 0f       	add	r21, r21
    7220:	aa 0b       	sbc	r26, r26
    7222:	e0 e8       	ldi	r30, 0x80	; 128
    7224:	fe ef       	ldi	r31, 0xFE	; 254
    7226:	16 16       	cp	r1, r22
    7228:	17 06       	cpc	r1, r23
    722a:	e8 07       	cpc	r30, r24
    722c:	f9 07       	cpc	r31, r25
    722e:	c0 f0       	brcs	.+48     	; 0x7260 <__fp_cmp+0x46>
    7230:	12 16       	cp	r1, r18
    7232:	13 06       	cpc	r1, r19
    7234:	e4 07       	cpc	r30, r20
    7236:	f5 07       	cpc	r31, r21
    7238:	98 f0       	brcs	.+38     	; 0x7260 <__fp_cmp+0x46>
    723a:	62 1b       	sub	r22, r18
    723c:	73 0b       	sbc	r23, r19
    723e:	84 0b       	sbc	r24, r20
    7240:	95 0b       	sbc	r25, r21
    7242:	39 f4       	brne	.+14     	; 0x7252 <__fp_cmp+0x38>
    7244:	0a 26       	eor	r0, r26
    7246:	61 f0       	breq	.+24     	; 0x7260 <__fp_cmp+0x46>
    7248:	23 2b       	or	r18, r19
    724a:	24 2b       	or	r18, r20
    724c:	25 2b       	or	r18, r21
    724e:	21 f4       	brne	.+8      	; 0x7258 <__fp_cmp+0x3e>
    7250:	08 95       	ret
    7252:	0a 26       	eor	r0, r26
    7254:	09 f4       	brne	.+2      	; 0x7258 <__fp_cmp+0x3e>
    7256:	a1 40       	sbci	r26, 0x01	; 1
    7258:	a6 95       	lsr	r26
    725a:	8f ef       	ldi	r24, 0xFF	; 255
    725c:	81 1d       	adc	r24, r1
    725e:	81 1d       	adc	r24, r1
    7260:	08 95       	ret

00007262 <__mulsi3>:
    7262:	62 9f       	mul	r22, r18
    7264:	d0 01       	movw	r26, r0
    7266:	73 9f       	mul	r23, r19
    7268:	f0 01       	movw	r30, r0
    726a:	82 9f       	mul	r24, r18
    726c:	e0 0d       	add	r30, r0
    726e:	f1 1d       	adc	r31, r1
    7270:	64 9f       	mul	r22, r20
    7272:	e0 0d       	add	r30, r0
    7274:	f1 1d       	adc	r31, r1
    7276:	92 9f       	mul	r25, r18
    7278:	f0 0d       	add	r31, r0
    727a:	83 9f       	mul	r24, r19
    727c:	f0 0d       	add	r31, r0
    727e:	74 9f       	mul	r23, r20
    7280:	f0 0d       	add	r31, r0
    7282:	65 9f       	mul	r22, r21
    7284:	f0 0d       	add	r31, r0
    7286:	99 27       	eor	r25, r25
    7288:	72 9f       	mul	r23, r18
    728a:	b0 0d       	add	r27, r0
    728c:	e1 1d       	adc	r30, r1
    728e:	f9 1f       	adc	r31, r25
    7290:	63 9f       	mul	r22, r19
    7292:	b0 0d       	add	r27, r0
    7294:	e1 1d       	adc	r30, r1
    7296:	f9 1f       	adc	r31, r25
    7298:	bd 01       	movw	r22, r26
    729a:	cf 01       	movw	r24, r30
    729c:	11 24       	eor	r1, r1
    729e:	08 95       	ret

000072a0 <__divmodhi4>:
    72a0:	97 fb       	bst	r25, 7
    72a2:	09 2e       	mov	r0, r25
    72a4:	07 26       	eor	r0, r23
    72a6:	0a d0       	rcall	.+20     	; 0x72bc <__divmodhi4_neg1>
    72a8:	77 fd       	sbrc	r23, 7
    72aa:	04 d0       	rcall	.+8      	; 0x72b4 <__divmodhi4_neg2>
    72ac:	49 d0       	rcall	.+146    	; 0x7340 <__udivmodhi4>
    72ae:	06 d0       	rcall	.+12     	; 0x72bc <__divmodhi4_neg1>
    72b0:	00 20       	and	r0, r0
    72b2:	1a f4       	brpl	.+6      	; 0x72ba <__divmodhi4_exit>

000072b4 <__divmodhi4_neg2>:
    72b4:	70 95       	com	r23
    72b6:	61 95       	neg	r22
    72b8:	7f 4f       	sbci	r23, 0xFF	; 255

000072ba <__divmodhi4_exit>:
    72ba:	08 95       	ret

000072bc <__divmodhi4_neg1>:
    72bc:	f6 f7       	brtc	.-4      	; 0x72ba <__divmodhi4_exit>
    72be:	90 95       	com	r25
    72c0:	81 95       	neg	r24
    72c2:	9f 4f       	sbci	r25, 0xFF	; 255
    72c4:	08 95       	ret

000072c6 <__udivmodsi4>:
    72c6:	a1 e2       	ldi	r26, 0x21	; 33
    72c8:	1a 2e       	mov	r1, r26
    72ca:	aa 1b       	sub	r26, r26
    72cc:	bb 1b       	sub	r27, r27
    72ce:	fd 01       	movw	r30, r26
    72d0:	0d c0       	rjmp	.+26     	; 0x72ec <__udivmodsi4_ep>

000072d2 <__udivmodsi4_loop>:
    72d2:	aa 1f       	adc	r26, r26
    72d4:	bb 1f       	adc	r27, r27
    72d6:	ee 1f       	adc	r30, r30
    72d8:	ff 1f       	adc	r31, r31
    72da:	a2 17       	cp	r26, r18
    72dc:	b3 07       	cpc	r27, r19
    72de:	e4 07       	cpc	r30, r20
    72e0:	f5 07       	cpc	r31, r21
    72e2:	20 f0       	brcs	.+8      	; 0x72ec <__udivmodsi4_ep>
    72e4:	a2 1b       	sub	r26, r18
    72e6:	b3 0b       	sbc	r27, r19
    72e8:	e4 0b       	sbc	r30, r20
    72ea:	f5 0b       	sbc	r31, r21

000072ec <__udivmodsi4_ep>:
    72ec:	66 1f       	adc	r22, r22
    72ee:	77 1f       	adc	r23, r23
    72f0:	88 1f       	adc	r24, r24
    72f2:	99 1f       	adc	r25, r25
    72f4:	1a 94       	dec	r1
    72f6:	69 f7       	brne	.-38     	; 0x72d2 <__udivmodsi4_loop>
    72f8:	60 95       	com	r22
    72fa:	70 95       	com	r23
    72fc:	80 95       	com	r24
    72fe:	90 95       	com	r25
    7300:	9b 01       	movw	r18, r22
    7302:	ac 01       	movw	r20, r24
    7304:	bd 01       	movw	r22, r26
    7306:	cf 01       	movw	r24, r30
    7308:	08 95       	ret

0000730a <__divmodsi4>:
    730a:	97 fb       	bst	r25, 7
    730c:	09 2e       	mov	r0, r25
    730e:	05 26       	eor	r0, r21
    7310:	0e d0       	rcall	.+28     	; 0x732e <__divmodsi4_neg1>
    7312:	57 fd       	sbrc	r21, 7
    7314:	04 d0       	rcall	.+8      	; 0x731e <__divmodsi4_neg2>
    7316:	d7 df       	rcall	.-82     	; 0x72c6 <__udivmodsi4>
    7318:	0a d0       	rcall	.+20     	; 0x732e <__divmodsi4_neg1>
    731a:	00 1c       	adc	r0, r0
    731c:	38 f4       	brcc	.+14     	; 0x732c <__divmodsi4_exit>

0000731e <__divmodsi4_neg2>:
    731e:	50 95       	com	r21
    7320:	40 95       	com	r20
    7322:	30 95       	com	r19
    7324:	21 95       	neg	r18
    7326:	3f 4f       	sbci	r19, 0xFF	; 255
    7328:	4f 4f       	sbci	r20, 0xFF	; 255
    732a:	5f 4f       	sbci	r21, 0xFF	; 255

0000732c <__divmodsi4_exit>:
    732c:	08 95       	ret

0000732e <__divmodsi4_neg1>:
    732e:	f6 f7       	brtc	.-4      	; 0x732c <__divmodsi4_exit>
    7330:	90 95       	com	r25
    7332:	80 95       	com	r24
    7334:	70 95       	com	r23
    7336:	61 95       	neg	r22
    7338:	7f 4f       	sbci	r23, 0xFF	; 255
    733a:	8f 4f       	sbci	r24, 0xFF	; 255
    733c:	9f 4f       	sbci	r25, 0xFF	; 255
    733e:	08 95       	ret

00007340 <__udivmodhi4>:
    7340:	aa 1b       	sub	r26, r26
    7342:	bb 1b       	sub	r27, r27
    7344:	51 e1       	ldi	r21, 0x11	; 17
    7346:	07 c0       	rjmp	.+14     	; 0x7356 <__udivmodhi4_ep>

00007348 <__udivmodhi4_loop>:
    7348:	aa 1f       	adc	r26, r26
    734a:	bb 1f       	adc	r27, r27
    734c:	a6 17       	cp	r26, r22
    734e:	b7 07       	cpc	r27, r23
    7350:	10 f0       	brcs	.+4      	; 0x7356 <__udivmodhi4_ep>
    7352:	a6 1b       	sub	r26, r22
    7354:	b7 0b       	sbc	r27, r23

00007356 <__udivmodhi4_ep>:
    7356:	88 1f       	adc	r24, r24
    7358:	99 1f       	adc	r25, r25
    735a:	5a 95       	dec	r21
    735c:	a9 f7       	brne	.-22     	; 0x7348 <__udivmodhi4_loop>
    735e:	80 95       	com	r24
    7360:	90 95       	com	r25
    7362:	bc 01       	movw	r22, r24
    7364:	cd 01       	movw	r24, r26
    7366:	08 95       	ret

00007368 <__prologue_saves__>:
    7368:	2f 92       	push	r2
    736a:	3f 92       	push	r3
    736c:	4f 92       	push	r4
    736e:	5f 92       	push	r5
    7370:	6f 92       	push	r6
    7372:	7f 92       	push	r7
    7374:	8f 92       	push	r8
    7376:	9f 92       	push	r9
    7378:	af 92       	push	r10
    737a:	bf 92       	push	r11
    737c:	cf 92       	push	r12
    737e:	df 92       	push	r13
    7380:	ef 92       	push	r14
    7382:	ff 92       	push	r15
    7384:	0f 93       	push	r16
    7386:	1f 93       	push	r17
    7388:	cf 93       	push	r28
    738a:	df 93       	push	r29
    738c:	cd b7       	in	r28, 0x3d	; 61
    738e:	de b7       	in	r29, 0x3e	; 62
    7390:	ca 1b       	sub	r28, r26
    7392:	db 0b       	sbc	r29, r27
    7394:	cd bf       	out	0x3d, r28	; 61
    7396:	de bf       	out	0x3e, r29	; 62
    7398:	19 94       	eijmp

0000739a <__epilogue_restores__>:
    739a:	2a 88       	ldd	r2, Y+18	; 0x12
    739c:	39 88       	ldd	r3, Y+17	; 0x11
    739e:	48 88       	ldd	r4, Y+16	; 0x10
    73a0:	5f 84       	ldd	r5, Y+15	; 0x0f
    73a2:	6e 84       	ldd	r6, Y+14	; 0x0e
    73a4:	7d 84       	ldd	r7, Y+13	; 0x0d
    73a6:	8c 84       	ldd	r8, Y+12	; 0x0c
    73a8:	9b 84       	ldd	r9, Y+11	; 0x0b
    73aa:	aa 84       	ldd	r10, Y+10	; 0x0a
    73ac:	b9 84       	ldd	r11, Y+9	; 0x09
    73ae:	c8 84       	ldd	r12, Y+8	; 0x08
    73b0:	df 80       	ldd	r13, Y+7	; 0x07
    73b2:	ee 80       	ldd	r14, Y+6	; 0x06
    73b4:	fd 80       	ldd	r15, Y+5	; 0x05
    73b6:	0c 81       	ldd	r16, Y+4	; 0x04
    73b8:	1b 81       	ldd	r17, Y+3	; 0x03
    73ba:	aa 81       	ldd	r26, Y+2	; 0x02
    73bc:	b9 81       	ldd	r27, Y+1	; 0x01
    73be:	ce 0f       	add	r28, r30
    73c0:	d1 1d       	adc	r29, r1
    73c2:	cd bf       	out	0x3d, r28	; 61
    73c4:	de bf       	out	0x3e, r29	; 62
    73c6:	ed 01       	movw	r28, r26
    73c8:	08 95       	ret

000073ca <strcpy_P>:
    73ca:	fb 01       	movw	r30, r22
    73cc:	dc 01       	movw	r26, r24
    73ce:	05 90       	lpm	r0, Z+
    73d0:	0d 92       	st	X+, r0
    73d2:	00 20       	and	r0, r0
    73d4:	e1 f7       	brne	.-8      	; 0x73ce <strcpy_P+0x4>
    73d6:	08 95       	ret

000073d8 <memmove>:
    73d8:	68 17       	cp	r22, r24
    73da:	79 07       	cpc	r23, r25
    73dc:	68 f4       	brcc	.+26     	; 0x73f8 <memmove+0x20>
    73de:	fb 01       	movw	r30, r22
    73e0:	dc 01       	movw	r26, r24
    73e2:	e4 0f       	add	r30, r20
    73e4:	f5 1f       	adc	r31, r21
    73e6:	a4 0f       	add	r26, r20
    73e8:	b5 1f       	adc	r27, r21
    73ea:	02 c0       	rjmp	.+4      	; 0x73f0 <memmove+0x18>
    73ec:	02 90       	ld	r0, -Z
    73ee:	0e 92       	st	-X, r0
    73f0:	41 50       	subi	r20, 0x01	; 1
    73f2:	50 40       	sbci	r21, 0x00	; 0
    73f4:	d8 f7       	brcc	.-10     	; 0x73ec <memmove+0x14>
    73f6:	08 95       	ret
    73f8:	0c 94 71 3c 	jmp	0x78e2	; 0x78e2 <memcpy>

000073fc <strcat>:
    73fc:	fb 01       	movw	r30, r22
    73fe:	dc 01       	movw	r26, r24
    7400:	0d 90       	ld	r0, X+
    7402:	00 20       	and	r0, r0
    7404:	e9 f7       	brne	.-6      	; 0x7400 <strcat+0x4>
    7406:	11 97       	sbiw	r26, 0x01	; 1
    7408:	01 90       	ld	r0, Z+
    740a:	0d 92       	st	X+, r0
    740c:	00 20       	and	r0, r0
    740e:	e1 f7       	brne	.-8      	; 0x7408 <strcat+0xc>
    7410:	08 95       	ret

00007412 <itoa>:
    7412:	fb 01       	movw	r30, r22
    7414:	9f 01       	movw	r18, r30
    7416:	e8 94       	clt
    7418:	42 30       	cpi	r20, 0x02	; 2
    741a:	c4 f0       	brlt	.+48     	; 0x744c <itoa+0x3a>
    741c:	45 32       	cpi	r20, 0x25	; 37
    741e:	b4 f4       	brge	.+44     	; 0x744c <itoa+0x3a>
    7420:	4a 30       	cpi	r20, 0x0A	; 10
    7422:	29 f4       	brne	.+10     	; 0x742e <itoa+0x1c>
    7424:	97 fb       	bst	r25, 7
    7426:	1e f4       	brtc	.+6      	; 0x742e <itoa+0x1c>
    7428:	90 95       	com	r25
    742a:	81 95       	neg	r24
    742c:	9f 4f       	sbci	r25, 0xFF	; 255
    742e:	64 2f       	mov	r22, r20
    7430:	77 27       	eor	r23, r23
    7432:	0e 94 a0 39 	call	0x7340	; 0x7340 <__udivmodhi4>
    7436:	80 5d       	subi	r24, 0xD0	; 208
    7438:	8a 33       	cpi	r24, 0x3A	; 58
    743a:	0c f0       	brlt	.+2      	; 0x743e <itoa+0x2c>
    743c:	89 5d       	subi	r24, 0xD9	; 217
    743e:	81 93       	st	Z+, r24
    7440:	cb 01       	movw	r24, r22
    7442:	00 97       	sbiw	r24, 0x00	; 0
    7444:	a1 f7       	brne	.-24     	; 0x742e <itoa+0x1c>
    7446:	16 f4       	brtc	.+4      	; 0x744c <itoa+0x3a>
    7448:	5d e2       	ldi	r21, 0x2D	; 45
    744a:	51 93       	st	Z+, r21
    744c:	10 82       	st	Z, r1
    744e:	c9 01       	movw	r24, r18
    7450:	0c 94 85 3c 	jmp	0x790a	; 0x790a <strrev>

00007454 <printf>:
    7454:	cf 93       	push	r28
    7456:	df 93       	push	r29
    7458:	cd b7       	in	r28, 0x3d	; 61
    745a:	de b7       	in	r29, 0x3e	; 62
    745c:	fe 01       	movw	r30, r28
    745e:	36 96       	adiw	r30, 0x06	; 6
    7460:	61 91       	ld	r22, Z+
    7462:	71 91       	ld	r23, Z+
    7464:	80 91 b4 50 	lds	r24, 0x50B4
    7468:	90 91 b5 50 	lds	r25, 0x50B5
    746c:	af 01       	movw	r20, r30
    746e:	0e 94 65 3a 	call	0x74ca	; 0x74ca <vfprintf>
    7472:	df 91       	pop	r29
    7474:	cf 91       	pop	r28
    7476:	08 95       	ret

00007478 <sprintf>:
    7478:	0f 93       	push	r16
    747a:	1f 93       	push	r17
    747c:	cf 93       	push	r28
    747e:	df 93       	push	r29
    7480:	cd b7       	in	r28, 0x3d	; 61
    7482:	de b7       	in	r29, 0x3e	; 62
    7484:	2e 97       	sbiw	r28, 0x0e	; 14
    7486:	cd bf       	out	0x3d, r28	; 61
    7488:	de bf       	out	0x3e, r29	; 62
    748a:	0e 89       	ldd	r16, Y+22	; 0x16
    748c:	1f 89       	ldd	r17, Y+23	; 0x17
    748e:	86 e0       	ldi	r24, 0x06	; 6
    7490:	8c 83       	std	Y+4, r24	; 0x04
    7492:	09 83       	std	Y+1, r16	; 0x01
    7494:	1a 83       	std	Y+2, r17	; 0x02
    7496:	8f ef       	ldi	r24, 0xFF	; 255
    7498:	9f e7       	ldi	r25, 0x7F	; 127
    749a:	8d 83       	std	Y+5, r24	; 0x05
    749c:	9e 83       	std	Y+6, r25	; 0x06
    749e:	ae 01       	movw	r20, r28
    74a0:	46 5e       	subi	r20, 0xE6	; 230
    74a2:	5f 4f       	sbci	r21, 0xFF	; 255
    74a4:	ce 01       	movw	r24, r28
    74a6:	01 96       	adiw	r24, 0x01	; 1
    74a8:	68 8d       	ldd	r22, Y+24	; 0x18
    74aa:	79 8d       	ldd	r23, Y+25	; 0x19
    74ac:	0e 94 65 3a 	call	0x74ca	; 0x74ca <vfprintf>
    74b0:	ef 81       	ldd	r30, Y+7	; 0x07
    74b2:	f8 85       	ldd	r31, Y+8	; 0x08
    74b4:	e0 0f       	add	r30, r16
    74b6:	f1 1f       	adc	r31, r17
    74b8:	10 82       	st	Z, r1
    74ba:	2e 96       	adiw	r28, 0x0e	; 14
    74bc:	cd bf       	out	0x3d, r28	; 61
    74be:	de bf       	out	0x3e, r29	; 62
    74c0:	df 91       	pop	r29
    74c2:	cf 91       	pop	r28
    74c4:	1f 91       	pop	r17
    74c6:	0f 91       	pop	r16
    74c8:	08 95       	ret

000074ca <vfprintf>:
    74ca:	2f 92       	push	r2
    74cc:	3f 92       	push	r3
    74ce:	4f 92       	push	r4
    74d0:	5f 92       	push	r5
    74d2:	6f 92       	push	r6
    74d4:	7f 92       	push	r7
    74d6:	8f 92       	push	r8
    74d8:	9f 92       	push	r9
    74da:	af 92       	push	r10
    74dc:	bf 92       	push	r11
    74de:	cf 92       	push	r12
    74e0:	df 92       	push	r13
    74e2:	ef 92       	push	r14
    74e4:	ff 92       	push	r15
    74e6:	0f 93       	push	r16
    74e8:	1f 93       	push	r17
    74ea:	cf 93       	push	r28
    74ec:	df 93       	push	r29
    74ee:	cd b7       	in	r28, 0x3d	; 61
    74f0:	de b7       	in	r29, 0x3e	; 62
    74f2:	2d 97       	sbiw	r28, 0x0d	; 13
    74f4:	cd bf       	out	0x3d, r28	; 61
    74f6:	de bf       	out	0x3e, r29	; 62
    74f8:	3c 01       	movw	r6, r24
    74fa:	6c 87       	std	Y+12, r22	; 0x0c
    74fc:	7d 87       	std	Y+13, r23	; 0x0d
    74fe:	5a 01       	movw	r10, r20
    7500:	fc 01       	movw	r30, r24
    7502:	16 82       	std	Z+6, r1	; 0x06
    7504:	17 82       	std	Z+7, r1	; 0x07
    7506:	83 81       	ldd	r24, Z+3	; 0x03
    7508:	81 ff       	sbrs	r24, 1
    750a:	c8 c1       	rjmp	.+912    	; 0x789c <vfprintf+0x3d2>
    750c:	2e 01       	movw	r4, r28
    750e:	08 94       	sec
    7510:	41 1c       	adc	r4, r1
    7512:	51 1c       	adc	r5, r1
    7514:	f3 01       	movw	r30, r6
    7516:	93 81       	ldd	r25, Z+3	; 0x03
    7518:	ec 85       	ldd	r30, Y+12	; 0x0c
    751a:	fd 85       	ldd	r31, Y+13	; 0x0d
    751c:	93 fd       	sbrc	r25, 3
    751e:	85 91       	lpm	r24, Z+
    7520:	93 ff       	sbrs	r25, 3
    7522:	81 91       	ld	r24, Z+
    7524:	ec 87       	std	Y+12, r30	; 0x0c
    7526:	fd 87       	std	Y+13, r31	; 0x0d
    7528:	88 23       	and	r24, r24
    752a:	09 f4       	brne	.+2      	; 0x752e <vfprintf+0x64>
    752c:	b3 c1       	rjmp	.+870    	; 0x7894 <vfprintf+0x3ca>
    752e:	85 32       	cpi	r24, 0x25	; 37
    7530:	41 f4       	brne	.+16     	; 0x7542 <vfprintf+0x78>
    7532:	93 fd       	sbrc	r25, 3
    7534:	85 91       	lpm	r24, Z+
    7536:	93 ff       	sbrs	r25, 3
    7538:	81 91       	ld	r24, Z+
    753a:	ec 87       	std	Y+12, r30	; 0x0c
    753c:	fd 87       	std	Y+13, r31	; 0x0d
    753e:	85 32       	cpi	r24, 0x25	; 37
    7540:	29 f4       	brne	.+10     	; 0x754c <vfprintf+0x82>
    7542:	90 e0       	ldi	r25, 0x00	; 0
    7544:	b3 01       	movw	r22, r6
    7546:	0e 94 95 3c 	call	0x792a	; 0x792a <fputc>
    754a:	e4 cf       	rjmp	.-56     	; 0x7514 <vfprintf+0x4a>
    754c:	ff 24       	eor	r15, r15
    754e:	ee 24       	eor	r14, r14
    7550:	10 e0       	ldi	r17, 0x00	; 0
    7552:	10 32       	cpi	r17, 0x20	; 32
    7554:	b0 f4       	brcc	.+44     	; 0x7582 <vfprintf+0xb8>
    7556:	8b 32       	cpi	r24, 0x2B	; 43
    7558:	69 f0       	breq	.+26     	; 0x7574 <vfprintf+0xaa>
    755a:	8c 32       	cpi	r24, 0x2C	; 44
    755c:	28 f4       	brcc	.+10     	; 0x7568 <vfprintf+0x9e>
    755e:	80 32       	cpi	r24, 0x20	; 32
    7560:	51 f0       	breq	.+20     	; 0x7576 <vfprintf+0xac>
    7562:	83 32       	cpi	r24, 0x23	; 35
    7564:	71 f4       	brne	.+28     	; 0x7582 <vfprintf+0xb8>
    7566:	0b c0       	rjmp	.+22     	; 0x757e <vfprintf+0xb4>
    7568:	8d 32       	cpi	r24, 0x2D	; 45
    756a:	39 f0       	breq	.+14     	; 0x757a <vfprintf+0xb0>
    756c:	80 33       	cpi	r24, 0x30	; 48
    756e:	49 f4       	brne	.+18     	; 0x7582 <vfprintf+0xb8>
    7570:	11 60       	ori	r17, 0x01	; 1
    7572:	2c c0       	rjmp	.+88     	; 0x75cc <vfprintf+0x102>
    7574:	12 60       	ori	r17, 0x02	; 2
    7576:	14 60       	ori	r17, 0x04	; 4
    7578:	29 c0       	rjmp	.+82     	; 0x75cc <vfprintf+0x102>
    757a:	18 60       	ori	r17, 0x08	; 8
    757c:	27 c0       	rjmp	.+78     	; 0x75cc <vfprintf+0x102>
    757e:	10 61       	ori	r17, 0x10	; 16
    7580:	25 c0       	rjmp	.+74     	; 0x75cc <vfprintf+0x102>
    7582:	17 fd       	sbrc	r17, 7
    7584:	2e c0       	rjmp	.+92     	; 0x75e2 <vfprintf+0x118>
    7586:	28 2f       	mov	r18, r24
    7588:	20 53       	subi	r18, 0x30	; 48
    758a:	2a 30       	cpi	r18, 0x0A	; 10
    758c:	98 f4       	brcc	.+38     	; 0x75b4 <vfprintf+0xea>
    758e:	16 ff       	sbrs	r17, 6
    7590:	08 c0       	rjmp	.+16     	; 0x75a2 <vfprintf+0xd8>
    7592:	8f 2d       	mov	r24, r15
    7594:	88 0f       	add	r24, r24
    7596:	f8 2e       	mov	r15, r24
    7598:	ff 0c       	add	r15, r15
    759a:	ff 0c       	add	r15, r15
    759c:	f8 0e       	add	r15, r24
    759e:	f2 0e       	add	r15, r18
    75a0:	15 c0       	rjmp	.+42     	; 0x75cc <vfprintf+0x102>
    75a2:	8e 2d       	mov	r24, r14
    75a4:	88 0f       	add	r24, r24
    75a6:	e8 2e       	mov	r14, r24
    75a8:	ee 0c       	add	r14, r14
    75aa:	ee 0c       	add	r14, r14
    75ac:	e8 0e       	add	r14, r24
    75ae:	e2 0e       	add	r14, r18
    75b0:	10 62       	ori	r17, 0x20	; 32
    75b2:	0c c0       	rjmp	.+24     	; 0x75cc <vfprintf+0x102>
    75b4:	8e 32       	cpi	r24, 0x2E	; 46
    75b6:	21 f4       	brne	.+8      	; 0x75c0 <vfprintf+0xf6>
    75b8:	16 fd       	sbrc	r17, 6
    75ba:	6c c1       	rjmp	.+728    	; 0x7894 <vfprintf+0x3ca>
    75bc:	10 64       	ori	r17, 0x40	; 64
    75be:	06 c0       	rjmp	.+12     	; 0x75cc <vfprintf+0x102>
    75c0:	8c 36       	cpi	r24, 0x6C	; 108
    75c2:	11 f4       	brne	.+4      	; 0x75c8 <vfprintf+0xfe>
    75c4:	10 68       	ori	r17, 0x80	; 128
    75c6:	02 c0       	rjmp	.+4      	; 0x75cc <vfprintf+0x102>
    75c8:	88 36       	cpi	r24, 0x68	; 104
    75ca:	59 f4       	brne	.+22     	; 0x75e2 <vfprintf+0x118>
    75cc:	ec 85       	ldd	r30, Y+12	; 0x0c
    75ce:	fd 85       	ldd	r31, Y+13	; 0x0d
    75d0:	93 fd       	sbrc	r25, 3
    75d2:	85 91       	lpm	r24, Z+
    75d4:	93 ff       	sbrs	r25, 3
    75d6:	81 91       	ld	r24, Z+
    75d8:	ec 87       	std	Y+12, r30	; 0x0c
    75da:	fd 87       	std	Y+13, r31	; 0x0d
    75dc:	88 23       	and	r24, r24
    75de:	09 f0       	breq	.+2      	; 0x75e2 <vfprintf+0x118>
    75e0:	b8 cf       	rjmp	.-144    	; 0x7552 <vfprintf+0x88>
    75e2:	98 2f       	mov	r25, r24
    75e4:	95 54       	subi	r25, 0x45	; 69
    75e6:	93 30       	cpi	r25, 0x03	; 3
    75e8:	18 f0       	brcs	.+6      	; 0x75f0 <vfprintf+0x126>
    75ea:	90 52       	subi	r25, 0x20	; 32
    75ec:	93 30       	cpi	r25, 0x03	; 3
    75ee:	38 f4       	brcc	.+14     	; 0x75fe <vfprintf+0x134>
    75f0:	24 e0       	ldi	r18, 0x04	; 4
    75f2:	30 e0       	ldi	r19, 0x00	; 0
    75f4:	a2 0e       	add	r10, r18
    75f6:	b3 1e       	adc	r11, r19
    75f8:	3f e3       	ldi	r19, 0x3F	; 63
    75fa:	39 83       	std	Y+1, r19	; 0x01
    75fc:	0f c0       	rjmp	.+30     	; 0x761c <vfprintf+0x152>
    75fe:	83 36       	cpi	r24, 0x63	; 99
    7600:	31 f0       	breq	.+12     	; 0x760e <vfprintf+0x144>
    7602:	83 37       	cpi	r24, 0x73	; 115
    7604:	81 f0       	breq	.+32     	; 0x7626 <vfprintf+0x15c>
    7606:	83 35       	cpi	r24, 0x53	; 83
    7608:	09 f0       	breq	.+2      	; 0x760c <vfprintf+0x142>
    760a:	5a c0       	rjmp	.+180    	; 0x76c0 <vfprintf+0x1f6>
    760c:	22 c0       	rjmp	.+68     	; 0x7652 <vfprintf+0x188>
    760e:	f5 01       	movw	r30, r10
    7610:	80 81       	ld	r24, Z
    7612:	89 83       	std	Y+1, r24	; 0x01
    7614:	22 e0       	ldi	r18, 0x02	; 2
    7616:	30 e0       	ldi	r19, 0x00	; 0
    7618:	a2 0e       	add	r10, r18
    761a:	b3 1e       	adc	r11, r19
    761c:	21 e0       	ldi	r18, 0x01	; 1
    761e:	c2 2e       	mov	r12, r18
    7620:	d1 2c       	mov	r13, r1
    7622:	42 01       	movw	r8, r4
    7624:	14 c0       	rjmp	.+40     	; 0x764e <vfprintf+0x184>
    7626:	92 e0       	ldi	r25, 0x02	; 2
    7628:	29 2e       	mov	r2, r25
    762a:	31 2c       	mov	r3, r1
    762c:	2a 0c       	add	r2, r10
    762e:	3b 1c       	adc	r3, r11
    7630:	f5 01       	movw	r30, r10
    7632:	80 80       	ld	r8, Z
    7634:	91 80       	ldd	r9, Z+1	; 0x01
    7636:	16 ff       	sbrs	r17, 6
    7638:	03 c0       	rjmp	.+6      	; 0x7640 <vfprintf+0x176>
    763a:	6f 2d       	mov	r22, r15
    763c:	70 e0       	ldi	r23, 0x00	; 0
    763e:	02 c0       	rjmp	.+4      	; 0x7644 <vfprintf+0x17a>
    7640:	6f ef       	ldi	r22, 0xFF	; 255
    7642:	7f ef       	ldi	r23, 0xFF	; 255
    7644:	c4 01       	movw	r24, r8
    7646:	0e 94 7a 3c 	call	0x78f4	; 0x78f4 <strnlen>
    764a:	6c 01       	movw	r12, r24
    764c:	51 01       	movw	r10, r2
    764e:	1f 77       	andi	r17, 0x7F	; 127
    7650:	15 c0       	rjmp	.+42     	; 0x767c <vfprintf+0x1b2>
    7652:	82 e0       	ldi	r24, 0x02	; 2
    7654:	28 2e       	mov	r2, r24
    7656:	31 2c       	mov	r3, r1
    7658:	2a 0c       	add	r2, r10
    765a:	3b 1c       	adc	r3, r11
    765c:	f5 01       	movw	r30, r10
    765e:	80 80       	ld	r8, Z
    7660:	91 80       	ldd	r9, Z+1	; 0x01
    7662:	16 ff       	sbrs	r17, 6
    7664:	03 c0       	rjmp	.+6      	; 0x766c <vfprintf+0x1a2>
    7666:	6f 2d       	mov	r22, r15
    7668:	70 e0       	ldi	r23, 0x00	; 0
    766a:	02 c0       	rjmp	.+4      	; 0x7670 <vfprintf+0x1a6>
    766c:	6f ef       	ldi	r22, 0xFF	; 255
    766e:	7f ef       	ldi	r23, 0xFF	; 255
    7670:	c4 01       	movw	r24, r8
    7672:	0e 94 66 3c 	call	0x78cc	; 0x78cc <strnlen_P>
    7676:	6c 01       	movw	r12, r24
    7678:	10 68       	ori	r17, 0x80	; 128
    767a:	51 01       	movw	r10, r2
    767c:	13 fd       	sbrc	r17, 3
    767e:	1c c0       	rjmp	.+56     	; 0x76b8 <vfprintf+0x1ee>
    7680:	06 c0       	rjmp	.+12     	; 0x768e <vfprintf+0x1c4>
    7682:	80 e2       	ldi	r24, 0x20	; 32
    7684:	90 e0       	ldi	r25, 0x00	; 0
    7686:	b3 01       	movw	r22, r6
    7688:	0e 94 95 3c 	call	0x792a	; 0x792a <fputc>
    768c:	ea 94       	dec	r14
    768e:	8e 2d       	mov	r24, r14
    7690:	90 e0       	ldi	r25, 0x00	; 0
    7692:	c8 16       	cp	r12, r24
    7694:	d9 06       	cpc	r13, r25
    7696:	a8 f3       	brcs	.-22     	; 0x7682 <vfprintf+0x1b8>
    7698:	0f c0       	rjmp	.+30     	; 0x76b8 <vfprintf+0x1ee>
    769a:	f4 01       	movw	r30, r8
    769c:	17 fd       	sbrc	r17, 7
    769e:	85 91       	lpm	r24, Z+
    76a0:	17 ff       	sbrs	r17, 7
    76a2:	81 91       	ld	r24, Z+
    76a4:	4f 01       	movw	r8, r30
    76a6:	90 e0       	ldi	r25, 0x00	; 0
    76a8:	b3 01       	movw	r22, r6
    76aa:	0e 94 95 3c 	call	0x792a	; 0x792a <fputc>
    76ae:	e1 10       	cpse	r14, r1
    76b0:	ea 94       	dec	r14
    76b2:	08 94       	sec
    76b4:	c1 08       	sbc	r12, r1
    76b6:	d1 08       	sbc	r13, r1
    76b8:	c1 14       	cp	r12, r1
    76ba:	d1 04       	cpc	r13, r1
    76bc:	71 f7       	brne	.-36     	; 0x769a <vfprintf+0x1d0>
    76be:	e7 c0       	rjmp	.+462    	; 0x788e <vfprintf+0x3c4>
    76c0:	84 36       	cpi	r24, 0x64	; 100
    76c2:	11 f0       	breq	.+4      	; 0x76c8 <vfprintf+0x1fe>
    76c4:	89 36       	cpi	r24, 0x69	; 105
    76c6:	51 f5       	brne	.+84     	; 0x771c <vfprintf+0x252>
    76c8:	f5 01       	movw	r30, r10
    76ca:	17 ff       	sbrs	r17, 7
    76cc:	07 c0       	rjmp	.+14     	; 0x76dc <vfprintf+0x212>
    76ce:	80 81       	ld	r24, Z
    76d0:	91 81       	ldd	r25, Z+1	; 0x01
    76d2:	a2 81       	ldd	r26, Z+2	; 0x02
    76d4:	b3 81       	ldd	r27, Z+3	; 0x03
    76d6:	24 e0       	ldi	r18, 0x04	; 4
    76d8:	30 e0       	ldi	r19, 0x00	; 0
    76da:	08 c0       	rjmp	.+16     	; 0x76ec <vfprintf+0x222>
    76dc:	80 81       	ld	r24, Z
    76de:	91 81       	ldd	r25, Z+1	; 0x01
    76e0:	aa 27       	eor	r26, r26
    76e2:	97 fd       	sbrc	r25, 7
    76e4:	a0 95       	com	r26
    76e6:	ba 2f       	mov	r27, r26
    76e8:	22 e0       	ldi	r18, 0x02	; 2
    76ea:	30 e0       	ldi	r19, 0x00	; 0
    76ec:	a2 0e       	add	r10, r18
    76ee:	b3 1e       	adc	r11, r19
    76f0:	01 2f       	mov	r16, r17
    76f2:	0f 76       	andi	r16, 0x6F	; 111
    76f4:	b7 ff       	sbrs	r27, 7
    76f6:	08 c0       	rjmp	.+16     	; 0x7708 <vfprintf+0x23e>
    76f8:	b0 95       	com	r27
    76fa:	a0 95       	com	r26
    76fc:	90 95       	com	r25
    76fe:	81 95       	neg	r24
    7700:	9f 4f       	sbci	r25, 0xFF	; 255
    7702:	af 4f       	sbci	r26, 0xFF	; 255
    7704:	bf 4f       	sbci	r27, 0xFF	; 255
    7706:	00 68       	ori	r16, 0x80	; 128
    7708:	bc 01       	movw	r22, r24
    770a:	cd 01       	movw	r24, r26
    770c:	a2 01       	movw	r20, r4
    770e:	2a e0       	ldi	r18, 0x0A	; 10
    7710:	30 e0       	ldi	r19, 0x00	; 0
    7712:	0e 94 c1 3c 	call	0x7982	; 0x7982 <__ultoa_invert>
    7716:	d8 2e       	mov	r13, r24
    7718:	d4 18       	sub	r13, r4
    771a:	3f c0       	rjmp	.+126    	; 0x779a <vfprintf+0x2d0>
    771c:	85 37       	cpi	r24, 0x75	; 117
    771e:	21 f4       	brne	.+8      	; 0x7728 <vfprintf+0x25e>
    7720:	1f 7e       	andi	r17, 0xEF	; 239
    7722:	2a e0       	ldi	r18, 0x0A	; 10
    7724:	30 e0       	ldi	r19, 0x00	; 0
    7726:	20 c0       	rjmp	.+64     	; 0x7768 <vfprintf+0x29e>
    7728:	19 7f       	andi	r17, 0xF9	; 249
    772a:	8f 36       	cpi	r24, 0x6F	; 111
    772c:	a9 f0       	breq	.+42     	; 0x7758 <vfprintf+0x28e>
    772e:	80 37       	cpi	r24, 0x70	; 112
    7730:	20 f4       	brcc	.+8      	; 0x773a <vfprintf+0x270>
    7732:	88 35       	cpi	r24, 0x58	; 88
    7734:	09 f0       	breq	.+2      	; 0x7738 <vfprintf+0x26e>
    7736:	ae c0       	rjmp	.+348    	; 0x7894 <vfprintf+0x3ca>
    7738:	0b c0       	rjmp	.+22     	; 0x7750 <vfprintf+0x286>
    773a:	80 37       	cpi	r24, 0x70	; 112
    773c:	21 f0       	breq	.+8      	; 0x7746 <vfprintf+0x27c>
    773e:	88 37       	cpi	r24, 0x78	; 120
    7740:	09 f0       	breq	.+2      	; 0x7744 <vfprintf+0x27a>
    7742:	a8 c0       	rjmp	.+336    	; 0x7894 <vfprintf+0x3ca>
    7744:	01 c0       	rjmp	.+2      	; 0x7748 <vfprintf+0x27e>
    7746:	10 61       	ori	r17, 0x10	; 16
    7748:	14 ff       	sbrs	r17, 4
    774a:	09 c0       	rjmp	.+18     	; 0x775e <vfprintf+0x294>
    774c:	14 60       	ori	r17, 0x04	; 4
    774e:	07 c0       	rjmp	.+14     	; 0x775e <vfprintf+0x294>
    7750:	14 ff       	sbrs	r17, 4
    7752:	08 c0       	rjmp	.+16     	; 0x7764 <vfprintf+0x29a>
    7754:	16 60       	ori	r17, 0x06	; 6
    7756:	06 c0       	rjmp	.+12     	; 0x7764 <vfprintf+0x29a>
    7758:	28 e0       	ldi	r18, 0x08	; 8
    775a:	30 e0       	ldi	r19, 0x00	; 0
    775c:	05 c0       	rjmp	.+10     	; 0x7768 <vfprintf+0x29e>
    775e:	20 e1       	ldi	r18, 0x10	; 16
    7760:	30 e0       	ldi	r19, 0x00	; 0
    7762:	02 c0       	rjmp	.+4      	; 0x7768 <vfprintf+0x29e>
    7764:	20 e1       	ldi	r18, 0x10	; 16
    7766:	32 e0       	ldi	r19, 0x02	; 2
    7768:	f5 01       	movw	r30, r10
    776a:	17 ff       	sbrs	r17, 7
    776c:	07 c0       	rjmp	.+14     	; 0x777c <vfprintf+0x2b2>
    776e:	60 81       	ld	r22, Z
    7770:	71 81       	ldd	r23, Z+1	; 0x01
    7772:	82 81       	ldd	r24, Z+2	; 0x02
    7774:	93 81       	ldd	r25, Z+3	; 0x03
    7776:	44 e0       	ldi	r20, 0x04	; 4
    7778:	50 e0       	ldi	r21, 0x00	; 0
    777a:	06 c0       	rjmp	.+12     	; 0x7788 <vfprintf+0x2be>
    777c:	60 81       	ld	r22, Z
    777e:	71 81       	ldd	r23, Z+1	; 0x01
    7780:	80 e0       	ldi	r24, 0x00	; 0
    7782:	90 e0       	ldi	r25, 0x00	; 0
    7784:	42 e0       	ldi	r20, 0x02	; 2
    7786:	50 e0       	ldi	r21, 0x00	; 0
    7788:	a4 0e       	add	r10, r20
    778a:	b5 1e       	adc	r11, r21
    778c:	a2 01       	movw	r20, r4
    778e:	0e 94 c1 3c 	call	0x7982	; 0x7982 <__ultoa_invert>
    7792:	d8 2e       	mov	r13, r24
    7794:	d4 18       	sub	r13, r4
    7796:	01 2f       	mov	r16, r17
    7798:	0f 77       	andi	r16, 0x7F	; 127
    779a:	06 ff       	sbrs	r16, 6
    779c:	09 c0       	rjmp	.+18     	; 0x77b0 <vfprintf+0x2e6>
    779e:	0e 7f       	andi	r16, 0xFE	; 254
    77a0:	df 14       	cp	r13, r15
    77a2:	30 f4       	brcc	.+12     	; 0x77b0 <vfprintf+0x2e6>
    77a4:	04 ff       	sbrs	r16, 4
    77a6:	06 c0       	rjmp	.+12     	; 0x77b4 <vfprintf+0x2ea>
    77a8:	02 fd       	sbrc	r16, 2
    77aa:	04 c0       	rjmp	.+8      	; 0x77b4 <vfprintf+0x2ea>
    77ac:	0f 7e       	andi	r16, 0xEF	; 239
    77ae:	02 c0       	rjmp	.+4      	; 0x77b4 <vfprintf+0x2ea>
    77b0:	1d 2d       	mov	r17, r13
    77b2:	01 c0       	rjmp	.+2      	; 0x77b6 <vfprintf+0x2ec>
    77b4:	1f 2d       	mov	r17, r15
    77b6:	80 2f       	mov	r24, r16
    77b8:	90 e0       	ldi	r25, 0x00	; 0
    77ba:	04 ff       	sbrs	r16, 4
    77bc:	0c c0       	rjmp	.+24     	; 0x77d6 <vfprintf+0x30c>
    77be:	fe 01       	movw	r30, r28
    77c0:	ed 0d       	add	r30, r13
    77c2:	f1 1d       	adc	r31, r1
    77c4:	20 81       	ld	r18, Z
    77c6:	20 33       	cpi	r18, 0x30	; 48
    77c8:	11 f4       	brne	.+4      	; 0x77ce <vfprintf+0x304>
    77ca:	09 7e       	andi	r16, 0xE9	; 233
    77cc:	09 c0       	rjmp	.+18     	; 0x77e0 <vfprintf+0x316>
    77ce:	02 ff       	sbrs	r16, 2
    77d0:	06 c0       	rjmp	.+12     	; 0x77de <vfprintf+0x314>
    77d2:	1e 5f       	subi	r17, 0xFE	; 254
    77d4:	05 c0       	rjmp	.+10     	; 0x77e0 <vfprintf+0x316>
    77d6:	86 78       	andi	r24, 0x86	; 134
    77d8:	90 70       	andi	r25, 0x00	; 0
    77da:	00 97       	sbiw	r24, 0x00	; 0
    77dc:	09 f0       	breq	.+2      	; 0x77e0 <vfprintf+0x316>
    77de:	1f 5f       	subi	r17, 0xFF	; 255
    77e0:	80 2e       	mov	r8, r16
    77e2:	99 24       	eor	r9, r9
    77e4:	03 fd       	sbrc	r16, 3
    77e6:	12 c0       	rjmp	.+36     	; 0x780c <vfprintf+0x342>
    77e8:	00 ff       	sbrs	r16, 0
    77ea:	0d c0       	rjmp	.+26     	; 0x7806 <vfprintf+0x33c>
    77ec:	fd 2c       	mov	r15, r13
    77ee:	1e 15       	cp	r17, r14
    77f0:	50 f4       	brcc	.+20     	; 0x7806 <vfprintf+0x33c>
    77f2:	fe 0c       	add	r15, r14
    77f4:	f1 1a       	sub	r15, r17
    77f6:	1e 2d       	mov	r17, r14
    77f8:	06 c0       	rjmp	.+12     	; 0x7806 <vfprintf+0x33c>
    77fa:	80 e2       	ldi	r24, 0x20	; 32
    77fc:	90 e0       	ldi	r25, 0x00	; 0
    77fe:	b3 01       	movw	r22, r6
    7800:	0e 94 95 3c 	call	0x792a	; 0x792a <fputc>
    7804:	1f 5f       	subi	r17, 0xFF	; 255
    7806:	1e 15       	cp	r17, r14
    7808:	c0 f3       	brcs	.-16     	; 0x77fa <vfprintf+0x330>
    780a:	04 c0       	rjmp	.+8      	; 0x7814 <vfprintf+0x34a>
    780c:	1e 15       	cp	r17, r14
    780e:	10 f4       	brcc	.+4      	; 0x7814 <vfprintf+0x34a>
    7810:	e1 1a       	sub	r14, r17
    7812:	01 c0       	rjmp	.+2      	; 0x7816 <vfprintf+0x34c>
    7814:	ee 24       	eor	r14, r14
    7816:	84 fe       	sbrs	r8, 4
    7818:	0f c0       	rjmp	.+30     	; 0x7838 <vfprintf+0x36e>
    781a:	80 e3       	ldi	r24, 0x30	; 48
    781c:	90 e0       	ldi	r25, 0x00	; 0
    781e:	b3 01       	movw	r22, r6
    7820:	0e 94 95 3c 	call	0x792a	; 0x792a <fputc>
    7824:	82 fe       	sbrs	r8, 2
    7826:	1f c0       	rjmp	.+62     	; 0x7866 <vfprintf+0x39c>
    7828:	81 fe       	sbrs	r8, 1
    782a:	03 c0       	rjmp	.+6      	; 0x7832 <vfprintf+0x368>
    782c:	88 e5       	ldi	r24, 0x58	; 88
    782e:	90 e0       	ldi	r25, 0x00	; 0
    7830:	10 c0       	rjmp	.+32     	; 0x7852 <vfprintf+0x388>
    7832:	88 e7       	ldi	r24, 0x78	; 120
    7834:	90 e0       	ldi	r25, 0x00	; 0
    7836:	0d c0       	rjmp	.+26     	; 0x7852 <vfprintf+0x388>
    7838:	c4 01       	movw	r24, r8
    783a:	86 78       	andi	r24, 0x86	; 134
    783c:	90 70       	andi	r25, 0x00	; 0
    783e:	00 97       	sbiw	r24, 0x00	; 0
    7840:	91 f0       	breq	.+36     	; 0x7866 <vfprintf+0x39c>
    7842:	81 fc       	sbrc	r8, 1
    7844:	02 c0       	rjmp	.+4      	; 0x784a <vfprintf+0x380>
    7846:	80 e2       	ldi	r24, 0x20	; 32
    7848:	01 c0       	rjmp	.+2      	; 0x784c <vfprintf+0x382>
    784a:	8b e2       	ldi	r24, 0x2B	; 43
    784c:	07 fd       	sbrc	r16, 7
    784e:	8d e2       	ldi	r24, 0x2D	; 45
    7850:	90 e0       	ldi	r25, 0x00	; 0
    7852:	b3 01       	movw	r22, r6
    7854:	0e 94 95 3c 	call	0x792a	; 0x792a <fputc>
    7858:	06 c0       	rjmp	.+12     	; 0x7866 <vfprintf+0x39c>
    785a:	80 e3       	ldi	r24, 0x30	; 48
    785c:	90 e0       	ldi	r25, 0x00	; 0
    785e:	b3 01       	movw	r22, r6
    7860:	0e 94 95 3c 	call	0x792a	; 0x792a <fputc>
    7864:	fa 94       	dec	r15
    7866:	df 14       	cp	r13, r15
    7868:	c0 f3       	brcs	.-16     	; 0x785a <vfprintf+0x390>
    786a:	da 94       	dec	r13
    786c:	f2 01       	movw	r30, r4
    786e:	ed 0d       	add	r30, r13
    7870:	f1 1d       	adc	r31, r1
    7872:	80 81       	ld	r24, Z
    7874:	90 e0       	ldi	r25, 0x00	; 0
    7876:	b3 01       	movw	r22, r6
    7878:	0e 94 95 3c 	call	0x792a	; 0x792a <fputc>
    787c:	dd 20       	and	r13, r13
    787e:	a9 f7       	brne	.-22     	; 0x786a <vfprintf+0x3a0>
    7880:	06 c0       	rjmp	.+12     	; 0x788e <vfprintf+0x3c4>
    7882:	80 e2       	ldi	r24, 0x20	; 32
    7884:	90 e0       	ldi	r25, 0x00	; 0
    7886:	b3 01       	movw	r22, r6
    7888:	0e 94 95 3c 	call	0x792a	; 0x792a <fputc>
    788c:	ea 94       	dec	r14
    788e:	ee 20       	and	r14, r14
    7890:	c1 f7       	brne	.-16     	; 0x7882 <vfprintf+0x3b8>
    7892:	40 ce       	rjmp	.-896    	; 0x7514 <vfprintf+0x4a>
    7894:	f3 01       	movw	r30, r6
    7896:	86 81       	ldd	r24, Z+6	; 0x06
    7898:	97 81       	ldd	r25, Z+7	; 0x07
    789a:	02 c0       	rjmp	.+4      	; 0x78a0 <vfprintf+0x3d6>
    789c:	8f ef       	ldi	r24, 0xFF	; 255
    789e:	9f ef       	ldi	r25, 0xFF	; 255
    78a0:	2d 96       	adiw	r28, 0x0d	; 13
    78a2:	cd bf       	out	0x3d, r28	; 61
    78a4:	de bf       	out	0x3e, r29	; 62
    78a6:	df 91       	pop	r29
    78a8:	cf 91       	pop	r28
    78aa:	1f 91       	pop	r17
    78ac:	0f 91       	pop	r16
    78ae:	ff 90       	pop	r15
    78b0:	ef 90       	pop	r14
    78b2:	df 90       	pop	r13
    78b4:	cf 90       	pop	r12
    78b6:	bf 90       	pop	r11
    78b8:	af 90       	pop	r10
    78ba:	9f 90       	pop	r9
    78bc:	8f 90       	pop	r8
    78be:	7f 90       	pop	r7
    78c0:	6f 90       	pop	r6
    78c2:	5f 90       	pop	r5
    78c4:	4f 90       	pop	r4
    78c6:	3f 90       	pop	r3
    78c8:	2f 90       	pop	r2
    78ca:	08 95       	ret

000078cc <strnlen_P>:
    78cc:	fc 01       	movw	r30, r24
    78ce:	05 90       	lpm	r0, Z+
    78d0:	61 50       	subi	r22, 0x01	; 1
    78d2:	70 40       	sbci	r23, 0x00	; 0
    78d4:	01 10       	cpse	r0, r1
    78d6:	d8 f7       	brcc	.-10     	; 0x78ce <strnlen_P+0x2>
    78d8:	80 95       	com	r24
    78da:	90 95       	com	r25
    78dc:	8e 0f       	add	r24, r30
    78de:	9f 1f       	adc	r25, r31
    78e0:	08 95       	ret

000078e2 <memcpy>:
    78e2:	fb 01       	movw	r30, r22
    78e4:	dc 01       	movw	r26, r24
    78e6:	02 c0       	rjmp	.+4      	; 0x78ec <memcpy+0xa>
    78e8:	01 90       	ld	r0, Z+
    78ea:	0d 92       	st	X+, r0
    78ec:	41 50       	subi	r20, 0x01	; 1
    78ee:	50 40       	sbci	r21, 0x00	; 0
    78f0:	d8 f7       	brcc	.-10     	; 0x78e8 <memcpy+0x6>
    78f2:	08 95       	ret

000078f4 <strnlen>:
    78f4:	fc 01       	movw	r30, r24
    78f6:	61 50       	subi	r22, 0x01	; 1
    78f8:	70 40       	sbci	r23, 0x00	; 0
    78fa:	01 90       	ld	r0, Z+
    78fc:	01 10       	cpse	r0, r1
    78fe:	d8 f7       	brcc	.-10     	; 0x78f6 <strnlen+0x2>
    7900:	80 95       	com	r24
    7902:	90 95       	com	r25
    7904:	8e 0f       	add	r24, r30
    7906:	9f 1f       	adc	r25, r31
    7908:	08 95       	ret

0000790a <strrev>:
    790a:	dc 01       	movw	r26, r24
    790c:	fc 01       	movw	r30, r24
    790e:	67 2f       	mov	r22, r23
    7910:	71 91       	ld	r23, Z+
    7912:	77 23       	and	r23, r23
    7914:	e1 f7       	brne	.-8      	; 0x790e <strrev+0x4>
    7916:	32 97       	sbiw	r30, 0x02	; 2
    7918:	04 c0       	rjmp	.+8      	; 0x7922 <strrev+0x18>
    791a:	7c 91       	ld	r23, X
    791c:	6d 93       	st	X+, r22
    791e:	70 83       	st	Z, r23
    7920:	62 91       	ld	r22, -Z
    7922:	ae 17       	cp	r26, r30
    7924:	bf 07       	cpc	r27, r31
    7926:	c8 f3       	brcs	.-14     	; 0x791a <strrev+0x10>
    7928:	08 95       	ret

0000792a <fputc>:
    792a:	0f 93       	push	r16
    792c:	1f 93       	push	r17
    792e:	cf 93       	push	r28
    7930:	df 93       	push	r29
    7932:	8c 01       	movw	r16, r24
    7934:	eb 01       	movw	r28, r22
    7936:	8b 81       	ldd	r24, Y+3	; 0x03
    7938:	81 ff       	sbrs	r24, 1
    793a:	1b c0       	rjmp	.+54     	; 0x7972 <fputc+0x48>
    793c:	82 ff       	sbrs	r24, 2
    793e:	0d c0       	rjmp	.+26     	; 0x795a <fputc+0x30>
    7940:	2e 81       	ldd	r18, Y+6	; 0x06
    7942:	3f 81       	ldd	r19, Y+7	; 0x07
    7944:	8c 81       	ldd	r24, Y+4	; 0x04
    7946:	9d 81       	ldd	r25, Y+5	; 0x05
    7948:	28 17       	cp	r18, r24
    794a:	39 07       	cpc	r19, r25
    794c:	64 f4       	brge	.+24     	; 0x7966 <fputc+0x3c>
    794e:	e8 81       	ld	r30, Y
    7950:	f9 81       	ldd	r31, Y+1	; 0x01
    7952:	01 93       	st	Z+, r16
    7954:	e8 83       	st	Y, r30
    7956:	f9 83       	std	Y+1, r31	; 0x01
    7958:	06 c0       	rjmp	.+12     	; 0x7966 <fputc+0x3c>
    795a:	e8 85       	ldd	r30, Y+8	; 0x08
    795c:	f9 85       	ldd	r31, Y+9	; 0x09
    795e:	80 2f       	mov	r24, r16
    7960:	19 95       	eicall
    7962:	00 97       	sbiw	r24, 0x00	; 0
    7964:	31 f4       	brne	.+12     	; 0x7972 <fputc+0x48>
    7966:	8e 81       	ldd	r24, Y+6	; 0x06
    7968:	9f 81       	ldd	r25, Y+7	; 0x07
    796a:	01 96       	adiw	r24, 0x01	; 1
    796c:	8e 83       	std	Y+6, r24	; 0x06
    796e:	9f 83       	std	Y+7, r25	; 0x07
    7970:	02 c0       	rjmp	.+4      	; 0x7976 <fputc+0x4c>
    7972:	0f ef       	ldi	r16, 0xFF	; 255
    7974:	1f ef       	ldi	r17, 0xFF	; 255
    7976:	c8 01       	movw	r24, r16
    7978:	df 91       	pop	r29
    797a:	cf 91       	pop	r28
    797c:	1f 91       	pop	r17
    797e:	0f 91       	pop	r16
    7980:	08 95       	ret

00007982 <__ultoa_invert>:
    7982:	fa 01       	movw	r30, r20
    7984:	aa 27       	eor	r26, r26
    7986:	28 30       	cpi	r18, 0x08	; 8
    7988:	51 f1       	breq	.+84     	; 0x79de <__ultoa_invert+0x5c>
    798a:	20 31       	cpi	r18, 0x10	; 16
    798c:	81 f1       	breq	.+96     	; 0x79ee <__ultoa_invert+0x6c>
    798e:	e8 94       	clt
    7990:	6f 93       	push	r22
    7992:	6e 7f       	andi	r22, 0xFE	; 254
    7994:	6e 5f       	subi	r22, 0xFE	; 254
    7996:	7f 4f       	sbci	r23, 0xFF	; 255
    7998:	8f 4f       	sbci	r24, 0xFF	; 255
    799a:	9f 4f       	sbci	r25, 0xFF	; 255
    799c:	af 4f       	sbci	r26, 0xFF	; 255
    799e:	b1 e0       	ldi	r27, 0x01	; 1
    79a0:	3e d0       	rcall	.+124    	; 0x7a1e <__ultoa_invert+0x9c>
    79a2:	b4 e0       	ldi	r27, 0x04	; 4
    79a4:	3c d0       	rcall	.+120    	; 0x7a1e <__ultoa_invert+0x9c>
    79a6:	67 0f       	add	r22, r23
    79a8:	78 1f       	adc	r23, r24
    79aa:	89 1f       	adc	r24, r25
    79ac:	9a 1f       	adc	r25, r26
    79ae:	a1 1d       	adc	r26, r1
    79b0:	68 0f       	add	r22, r24
    79b2:	79 1f       	adc	r23, r25
    79b4:	8a 1f       	adc	r24, r26
    79b6:	91 1d       	adc	r25, r1
    79b8:	a1 1d       	adc	r26, r1
    79ba:	6a 0f       	add	r22, r26
    79bc:	71 1d       	adc	r23, r1
    79be:	81 1d       	adc	r24, r1
    79c0:	91 1d       	adc	r25, r1
    79c2:	a1 1d       	adc	r26, r1
    79c4:	20 d0       	rcall	.+64     	; 0x7a06 <__ultoa_invert+0x84>
    79c6:	09 f4       	brne	.+2      	; 0x79ca <__ultoa_invert+0x48>
    79c8:	68 94       	set
    79ca:	3f 91       	pop	r19
    79cc:	2a e0       	ldi	r18, 0x0A	; 10
    79ce:	26 9f       	mul	r18, r22
    79d0:	11 24       	eor	r1, r1
    79d2:	30 19       	sub	r19, r0
    79d4:	30 5d       	subi	r19, 0xD0	; 208
    79d6:	31 93       	st	Z+, r19
    79d8:	de f6       	brtc	.-74     	; 0x7990 <__ultoa_invert+0xe>
    79da:	cf 01       	movw	r24, r30
    79dc:	08 95       	ret
    79de:	46 2f       	mov	r20, r22
    79e0:	47 70       	andi	r20, 0x07	; 7
    79e2:	40 5d       	subi	r20, 0xD0	; 208
    79e4:	41 93       	st	Z+, r20
    79e6:	b3 e0       	ldi	r27, 0x03	; 3
    79e8:	0f d0       	rcall	.+30     	; 0x7a08 <__ultoa_invert+0x86>
    79ea:	c9 f7       	brne	.-14     	; 0x79de <__ultoa_invert+0x5c>
    79ec:	f6 cf       	rjmp	.-20     	; 0x79da <__ultoa_invert+0x58>
    79ee:	46 2f       	mov	r20, r22
    79f0:	4f 70       	andi	r20, 0x0F	; 15
    79f2:	40 5d       	subi	r20, 0xD0	; 208
    79f4:	4a 33       	cpi	r20, 0x3A	; 58
    79f6:	18 f0       	brcs	.+6      	; 0x79fe <__ultoa_invert+0x7c>
    79f8:	49 5d       	subi	r20, 0xD9	; 217
    79fa:	31 fd       	sbrc	r19, 1
    79fc:	40 52       	subi	r20, 0x20	; 32
    79fe:	41 93       	st	Z+, r20
    7a00:	02 d0       	rcall	.+4      	; 0x7a06 <__ultoa_invert+0x84>
    7a02:	a9 f7       	brne	.-22     	; 0x79ee <__ultoa_invert+0x6c>
    7a04:	ea cf       	rjmp	.-44     	; 0x79da <__ultoa_invert+0x58>
    7a06:	b4 e0       	ldi	r27, 0x04	; 4
    7a08:	a6 95       	lsr	r26
    7a0a:	97 95       	ror	r25
    7a0c:	87 95       	ror	r24
    7a0e:	77 95       	ror	r23
    7a10:	67 95       	ror	r22
    7a12:	ba 95       	dec	r27
    7a14:	c9 f7       	brne	.-14     	; 0x7a08 <__ultoa_invert+0x86>
    7a16:	00 97       	sbiw	r24, 0x00	; 0
    7a18:	61 05       	cpc	r22, r1
    7a1a:	71 05       	cpc	r23, r1
    7a1c:	08 95       	ret
    7a1e:	9b 01       	movw	r18, r22
    7a20:	ac 01       	movw	r20, r24
    7a22:	0a 2e       	mov	r0, r26
    7a24:	06 94       	lsr	r0
    7a26:	57 95       	ror	r21
    7a28:	47 95       	ror	r20
    7a2a:	37 95       	ror	r19
    7a2c:	27 95       	ror	r18
    7a2e:	ba 95       	dec	r27
    7a30:	c9 f7       	brne	.-14     	; 0x7a24 <__ultoa_invert+0xa2>
    7a32:	62 0f       	add	r22, r18
    7a34:	73 1f       	adc	r23, r19
    7a36:	84 1f       	adc	r24, r20
    7a38:	95 1f       	adc	r25, r21
    7a3a:	a0 1d       	adc	r26, r0
    7a3c:	08 95       	ret

00007a3e <_exit>:
    7a3e:	f8 94       	cli

00007a40 <__stop_program>:
    7a40:	ff cf       	rjmp	.-2      	; 0x7a40 <__stop_program>
