
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000cdbc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000126  00802000  0000cdbc  0000ce50  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00003205  00802126  00802126  0000cf76  2**0
                  ALLOC
  3 .stab         00002718  00000000  00000000  0000cf78  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a2a  00000000  00000000  0000f690  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000003c0  00000000  00000000  000100c0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000cb67  00000000  00000000  00010480  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000021d6  00000000  00000000  0001cfe7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003ec8  00000000  00000000  0001f1bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001c34  00000000  00000000  00023088  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004579  00000000  00000000  00024cbc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006227  00000000  00000000  00029235  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000138  00000000  00000000  0002f45c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 74 11 	jmp	0x22e8	; 0x22e8 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 88 10 	jmp	0x2110	; 0x2110 <__vector_16>
      44:	0c 94 b8 10 	jmp	0x2170	; 0x2170 <__vector_17>
      48:	0c 94 e8 10 	jmp	0x21d0	; 0x21d0 <__vector_18>
      4c:	0c 94 18 11 	jmp	0x2230	; 0x2230 <__vector_19>
      50:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 05 3f 	jmp	0x7e0a	; 0x7e0a <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 9c 2e 	jmp	0x5d38	; 0x5d38 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 1d 14 	jmp	0x283a	; 0x283a <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 5b 13 	jmp	0x26b6	; 0x26b6 <__vector_79>
     140:	0c 94 8b 13 	jmp	0x2716	; 0x2716 <__vector_80>
     144:	0c 94 bb 13 	jmp	0x2776	; 0x2776 <__vector_81>
     148:	0c 94 eb 13 	jmp	0x27d6	; 0x27d6 <__vector_82>
     14c:	0c 94 8e 01 	jmp	0x31c	; 0x31c <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 25 0c 	jmp	0x184a	; 0x184a <__vector_104>
     1a4:	0c 94 1a 0a 	jmp	0x1434	; 0x1434 <__vector_105>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_overflow>:
     1e8:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     1f8:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     208:	54 41 0a 00                                         TA..

0000020c <chb_err_init>:
     20c:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     21c:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	ec eb       	ldi	r30, 0xBC	; 188
     244:	fd ec       	ldi	r31, 0xCD	; 205
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	a6 32       	cpi	r26, 0x26	; 38
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	13 e5       	ldi	r17, 0x53	; 83
     258:	a6 e2       	ldi	r26, 0x26	; 38
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	ab 32       	cpi	r26, 0x2B	; 43
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 f4 51 	call	0xa3e8	; 0xa3e8 <main>
     26a:	0c 94 dc 66 	jmp	0xcdb8	; 0xcdb8 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     272:	cf 93       	push	r28
     274:	df 93       	push	r29
     276:	0f 92       	push	r0
     278:	0f 92       	push	r0
     27a:	cd b7       	in	r28, 0x3d	; 61
     27c:	de b7       	in	r29, 0x3e	; 62
     27e:	89 83       	std	Y+1, r24	; 0x01
     280:	9a 83       	std	Y+2, r25	; 0x02
	moteID = 1;
     282:	81 e0       	ldi	r24, 0x01	; 1
     284:	80 93 c5 50 	sts	0x50C5, r24
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     288:	83 e0       	ldi	r24, 0x03	; 3
     28a:	80 93 53 40 	sts	0x4053, r24
	chb_init();
     28e:	0e 94 c1 1e 	call	0x3d82	; 0x3d82 <chb_init>
	chb_set_short_addr(moteID);
     292:	80 91 c5 50 	lds	r24, 0x50C5
     296:	88 2f       	mov	r24, r24
     298:	90 e0       	ldi	r25, 0x00	; 0
     29a:	0e 94 5b 2c 	call	0x58b6	; 0x58b6 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     29e:	80 e8       	ldi	r24, 0x80	; 128
     2a0:	91 e0       	ldi	r25, 0x01	; 1
     2a2:	28 ec       	ldi	r18, 0xC8	; 200
     2a4:	fc 01       	movw	r30, r24
     2a6:	21 83       	std	Z+1, r18	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     2a8:	80 e4       	ldi	r24, 0x40	; 64
     2aa:	99 e0       	ldi	r25, 0x09	; 9
     2ac:	29 e0       	ldi	r18, 0x09	; 9
     2ae:	fc 01       	movw	r30, r24
     2b0:	20 83       	st	Z, r18
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     2b2:	80 e4       	ldi	r24, 0x40	; 64
     2b4:	99 e0       	ldi	r25, 0x09	; 9
     2b6:	22 e0       	ldi	r18, 0x02	; 2
     2b8:	fc 01       	movw	r30, r24
     2ba:	26 83       	std	Z+6, r18	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     2bc:	80 e4       	ldi	r24, 0x40	; 64
     2be:	99 e0       	ldi	r25, 0x09	; 9
     2c0:	69 81       	ldd	r22, Y+1	; 0x01
     2c2:	7a 81       	ldd	r23, Y+2	; 0x02
     2c4:	44 ef       	ldi	r20, 0xF4	; 244
     2c6:	51 e0       	ldi	r21, 0x01	; 1
     2c8:	64 9f       	mul	r22, r20
     2ca:	90 01       	movw	r18, r0
     2cc:	65 9f       	mul	r22, r21
     2ce:	30 0d       	add	r19, r0
     2d0:	74 9f       	mul	r23, r20
     2d2:	30 0d       	add	r19, r0
     2d4:	11 24       	eor	r1, r1
     2d6:	fc 01       	movw	r30, r24
     2d8:	26 a3       	lds	r18, 0x56
     2da:	37 a3       	lds	r19, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     2dc:	80 e4       	ldi	r24, 0x40	; 64
     2de:	98 e0       	ldi	r25, 0x08	; 8
     2e0:	20 e0       	ldi	r18, 0x00	; 0
     2e2:	3a ef       	ldi	r19, 0xFA	; 250
     2e4:	fc 01       	movw	r30, r24
     2e6:	26 a3       	lds	r18, 0x56
     2e8:	37 a3       	lds	r19, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     2ea:	80 e4       	ldi	r24, 0x40	; 64
     2ec:	98 e0       	ldi	r25, 0x08	; 8
     2ee:	21 e0       	ldi	r18, 0x01	; 1
     2f0:	fc 01       	movw	r30, r24
     2f2:	26 83       	std	Z+6, r18	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     2f4:	80 e4       	ldi	r24, 0x40	; 64
     2f6:	98 e0       	ldi	r25, 0x08	; 8
     2f8:	21 e0       	ldi	r18, 0x01	; 1
     2fa:	fc 01       	movw	r30, r24
     2fc:	20 83       	st	Z, r18
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     2fe:	80 ea       	ldi	r24, 0xA0	; 160
     300:	90 e0       	ldi	r25, 0x00	; 0
     302:	20 ea       	ldi	r18, 0xA0	; 160
     304:	30 e0       	ldi	r19, 0x00	; 0
     306:	f9 01       	movw	r30, r18
     308:	22 81       	ldd	r18, Z+2	; 0x02
     30a:	27 60       	ori	r18, 0x07	; 7
     30c:	fc 01       	movw	r30, r24
     30e:	22 83       	std	Z+2, r18	; 0x02
	sei(); //  Enable global interrupts
     310:	78 94       	sei
}
     312:	0f 90       	pop	r0
     314:	0f 90       	pop	r0
     316:	df 91       	pop	r29
     318:	cf 91       	pop	r28
     31a:	08 95       	ret

0000031c <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     31c:	78 94       	sei
     31e:	1f 92       	push	r1
     320:	0f 92       	push	r0
     322:	0f b6       	in	r0, 0x3f	; 63
     324:	0f 92       	push	r0
     326:	00 90 3b 00 	lds	r0, 0x003B
     32a:	0f 92       	push	r0
     32c:	11 24       	eor	r1, r1
     32e:	2f 93       	push	r18
     330:	3f 93       	push	r19
     332:	4f 93       	push	r20
     334:	5f 93       	push	r21
     336:	6f 93       	push	r22
     338:	7f 93       	push	r23
     33a:	8f 93       	push	r24
     33c:	9f 93       	push	r25
     33e:	af 93       	push	r26
     340:	bf 93       	push	r27
     342:	ef 93       	push	r30
     344:	ff 93       	push	r31
     346:	cf 93       	push	r28
     348:	df 93       	push	r29
     34a:	cd b7       	in	r28, 0x3d	; 61
     34c:	de b7       	in	r29, 0x3e	; 62
     34e:	28 97       	sbiw	r28, 0x08	; 8
     350:	cd bf       	out	0x3d, r28	; 61
     352:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     354:	80 e4       	ldi	r24, 0x40	; 64
     356:	98 e0       	ldi	r25, 0x08	; 8
     358:	fc 01       	movw	r30, r24
     35a:	10 82       	st	Z, r1
	TCD1.CTRLA = 0x00;
     35c:	80 e4       	ldi	r24, 0x40	; 64
     35e:	99 e0       	ldi	r25, 0x09	; 9
     360:	fc 01       	movw	r30, r24
     362:	10 82       	st	Z, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
     364:	82 e0       	ldi	r24, 0x02	; 2
     366:	80 93 53 40 	sts	0x4053, r24
	unsigned char message[8];
	strcpy(message,"reset");
     36a:	ce 01       	movw	r24, r28
     36c:	01 96       	adiw	r24, 0x01	; 1
     36e:	20 e0       	ldi	r18, 0x00	; 0
     370:	30 e2       	ldi	r19, 0x20	; 32
     372:	46 e0       	ldi	r20, 0x06	; 6
     374:	f9 01       	movw	r30, r18
     376:	00 80       	ld	r0, Z
     378:	2f 5f       	subi	r18, 0xFF	; 255
     37a:	3f 4f       	sbci	r19, 0xFF	; 255
     37c:	fc 01       	movw	r30, r24
     37e:	00 82       	st	Z, r0
     380:	01 96       	adiw	r24, 0x01	; 1
     382:	41 50       	subi	r20, 0x01	; 1
     384:	44 23       	and	r20, r20
     386:	b1 f7       	brne	.-20     	; 0x374 <__vector_83+0x58>
	itoa((int)(moteID),buff,10);
     388:	80 91 c5 50 	lds	r24, 0x50C5
     38c:	88 2f       	mov	r24, r24
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	26 e4       	ldi	r18, 0x46	; 70
     392:	30 e4       	ldi	r19, 0x40	; 64
     394:	b9 01       	movw	r22, r18
     396:	4a e0       	ldi	r20, 0x0A	; 10
     398:	50 e0       	ldi	r21, 0x00	; 0
     39a:	0e 94 f8 63 	call	0xc7f0	; 0xc7f0 <itoa>
	strcat(message,buff);
     39e:	26 e4       	ldi	r18, 0x46	; 70
     3a0:	30 e4       	ldi	r19, 0x40	; 64
     3a2:	ce 01       	movw	r24, r28
     3a4:	01 96       	adiw	r24, 0x01	; 1
     3a6:	b9 01       	movw	r22, r18
     3a8:	0e 94 df 63 	call	0xc7be	; 0xc7be <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
     3ac:	0e 94 03 0a 	call	0x1406	; 0x1406 <ADC_Pause_Sampling>
	chb_write(0x0000,message,strlen(message));
     3b0:	ce 01       	movw	r24, r28
     3b2:	01 96       	adiw	r24, 0x01	; 1
     3b4:	9c 01       	movw	r18, r24
     3b6:	f9 01       	movw	r30, r18
     3b8:	01 90       	ld	r0, Z+
     3ba:	00 20       	and	r0, r0
     3bc:	e9 f7       	brne	.-6      	; 0x3b8 <__vector_83+0x9c>
     3be:	cf 01       	movw	r24, r30
     3c0:	01 97       	sbiw	r24, 0x01	; 1
     3c2:	82 1b       	sub	r24, r18
     3c4:	93 0b       	sbc	r25, r19
     3c6:	9c 01       	movw	r18, r24
     3c8:	40 e0       	ldi	r20, 0x00	; 0
     3ca:	50 e0       	ldi	r21, 0x00	; 0
     3cc:	80 e0       	ldi	r24, 0x00	; 0
     3ce:	90 e0       	ldi	r25, 0x00	; 0
     3d0:	be 01       	movw	r22, r28
     3d2:	6f 5f       	subi	r22, 0xFF	; 255
     3d4:	7f 4f       	sbci	r23, 0xFF	; 255
     3d6:	0e 94 88 1f 	call	0x3f10	; 0x3f10 <chb_write>
}	
     3da:	28 96       	adiw	r28, 0x08	; 8
     3dc:	cd bf       	out	0x3d, r28	; 61
     3de:	de bf       	out	0x3e, r29	; 62
     3e0:	df 91       	pop	r29
     3e2:	cf 91       	pop	r28
     3e4:	ff 91       	pop	r31
     3e6:	ef 91       	pop	r30
     3e8:	bf 91       	pop	r27
     3ea:	af 91       	pop	r26
     3ec:	9f 91       	pop	r25
     3ee:	8f 91       	pop	r24
     3f0:	7f 91       	pop	r23
     3f2:	6f 91       	pop	r22
     3f4:	5f 91       	pop	r21
     3f6:	4f 91       	pop	r20
     3f8:	3f 91       	pop	r19
     3fa:	2f 91       	pop	r18
     3fc:	0f 90       	pop	r0
     3fe:	00 92 3b 00 	sts	0x003B, r0
     402:	0f 90       	pop	r0
     404:	0f be       	out	0x3f, r0	; 63
     406:	0f 90       	pop	r0
     408:	1f 90       	pop	r1
     40a:	18 95       	reti

0000040c <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     40c:	cf 93       	push	r28
     40e:	df 93       	push	r29
     410:	cd b7       	in	r28, 0x3d	; 61
     412:	de b7       	in	r29, 0x3e	; 62
     414:	6b 97       	sbiw	r28, 0x1b	; 27
     416:	cd bf       	out	0x3d, r28	; 61
     418:	de bf       	out	0x3e, r29	; 62
     41a:	8e 8b       	std	Y+22, r24	; 0x16
     41c:	9f 8b       	std	Y+23, r25	; 0x17
     41e:	68 8f       	std	Y+24, r22	; 0x18
     420:	79 8f       	std	Y+25, r23	; 0x19
     422:	4a 8f       	std	Y+26, r20	; 0x1a
     424:	5b 8f       	std	Y+27, r21	; 0x1b
	uint32_t sum = 0;
     426:	19 82       	std	Y+1, r1	; 0x01
     428:	1a 82       	std	Y+2, r1	; 0x02
     42a:	1b 82       	std	Y+3, r1	; 0x03
     42c:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     42e:	80 e0       	ldi	r24, 0x00	; 0
     430:	90 e1       	ldi	r25, 0x10	; 16
     432:	a0 e0       	ldi	r26, 0x00	; 0
     434:	b0 e0       	ldi	r27, 0x00	; 0
     436:	8d 83       	std	Y+5, r24	; 0x05
     438:	9e 83       	std	Y+6, r25	; 0x06
     43a:	af 83       	std	Y+7, r26	; 0x07
     43c:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     43e:	19 86       	std	Y+9, r1	; 0x09
     440:	1a 86       	std	Y+10, r1	; 0x0a
     442:	1b 86       	std	Y+11, r1	; 0x0b
     444:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     446:	81 e0       	ldi	r24, 0x01	; 1
     448:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     44c:	80 e0       	ldi	r24, 0x00	; 0
     44e:	92 e0       	ldi	r25, 0x02	; 2
     450:	0e 94 1e 1b 	call	0x363c	; 0x363c <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     454:	80 e0       	ldi	r24, 0x00	; 0
     456:	92 e0       	ldi	r25, 0x02	; 2
     458:	20 e0       	ldi	r18, 0x00	; 0
     45a:	32 e0       	ldi	r19, 0x02	; 2
     45c:	f9 01       	movw	r30, r18
     45e:	21 81       	ldd	r18, Z+1	; 0x01
     460:	29 7e       	andi	r18, 0xE9	; 233
     462:	fc 01       	movw	r30, r24
     464:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     466:	80 e0       	ldi	r24, 0x00	; 0
     468:	92 e0       	ldi	r25, 0x02	; 2
     46a:	20 e0       	ldi	r18, 0x00	; 0
     46c:	32 e0       	ldi	r19, 0x02	; 2
     46e:	f9 01       	movw	r30, r18
     470:	24 81       	ldd	r18, Z+4	; 0x04
     472:	28 7f       	andi	r18, 0xF8	; 248
     474:	23 60       	ori	r18, 0x03	; 3
     476:	fc 01       	movw	r30, r24
     478:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     47a:	80 e0       	ldi	r24, 0x00	; 0
     47c:	92 e0       	ldi	r25, 0x02	; 2
     47e:	20 e0       	ldi	r18, 0x00	; 0
     480:	32 e0       	ldi	r19, 0x02	; 2
     482:	f9 01       	movw	r30, r18
     484:	22 81       	ldd	r18, Z+2	; 0x02
     486:	2f 7c       	andi	r18, 0xCF	; 207
     488:	fc 01       	movw	r30, r24
     48a:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     48c:	80 e2       	ldi	r24, 0x20	; 32
     48e:	92 e0       	ldi	r25, 0x02	; 2
     490:	20 e2       	ldi	r18, 0x20	; 32
     492:	32 e0       	ldi	r19, 0x02	; 2
     494:	f9 01       	movw	r30, r18
     496:	20 81       	ld	r18, Z
     498:	20 7e       	andi	r18, 0xE0	; 224
     49a:	21 60       	ori	r18, 0x01	; 1
     49c:	fc 01       	movw	r30, r24
     49e:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     4a0:	80 e2       	ldi	r24, 0x20	; 32
     4a2:	92 e0       	ldi	r25, 0x02	; 2
     4a4:	29 e0       	ldi	r18, 0x09	; 9
     4a6:	fc 01       	movw	r30, r24
     4a8:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCA);
     4aa:	80 e0       	ldi	r24, 0x00	; 0
     4ac:	92 e0       	ldi	r25, 0x02	; 2
     4ae:	20 e0       	ldi	r18, 0x00	; 0
     4b0:	32 e0       	ldi	r19, 0x02	; 2
     4b2:	f9 01       	movw	r30, r18
     4b4:	20 81       	ld	r18, Z
     4b6:	21 60       	ori	r18, 0x01	; 1
     4b8:	fc 01       	movw	r30, r24
     4ba:	20 83       	st	Z, r18
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     4bc:	80 e0       	ldi	r24, 0x00	; 0
     4be:	92 e0       	ldi	r25, 0x02	; 2
     4c0:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     4c4:	80 e0       	ldi	r24, 0x00	; 0
     4c6:	92 e0       	ldi	r25, 0x02	; 2
     4c8:	60 e2       	ldi	r22, 0x20	; 32
     4ca:	72 e0       	ldi	r23, 0x02	; 2
     4cc:	40 e0       	ldi	r20, 0x00	; 0
     4ce:	0e 94 cd 1d 	call	0x3b9a	; 0x3b9a <ADC_Offset_Get_Unsigned>
     4d2:	8d 8b       	std	Y+21, r24	; 0x15
    ADC_Disable(&ADCA);
     4d4:	80 e0       	ldi	r24, 0x00	; 0
     4d6:	92 e0       	ldi	r25, 0x02	; 2
     4d8:	20 e0       	ldi	r18, 0x00	; 0
     4da:	32 e0       	ldi	r19, 0x02	; 2
     4dc:	f9 01       	movw	r30, r18
     4de:	20 81       	ld	r18, Z
     4e0:	2e 7f       	andi	r18, 0xFE	; 254
     4e2:	fc 01       	movw	r30, r24
     4e4:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     4e6:	80 e2       	ldi	r24, 0x20	; 32
     4e8:	92 e0       	ldi	r25, 0x02	; 2
     4ea:	fc 01       	movw	r30, r24
     4ec:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     4ee:	80 e0       	ldi	r24, 0x00	; 0
     4f0:	92 e0       	ldi	r25, 0x02	; 2
     4f2:	20 e0       	ldi	r18, 0x00	; 0
     4f4:	32 e0       	ldi	r19, 0x02	; 2
     4f6:	f9 01       	movw	r30, r18
     4f8:	23 81       	ldd	r18, Z+3	; 0x03
     4fa:	2f 73       	andi	r18, 0x3F	; 63
     4fc:	fc 01       	movw	r30, r24
     4fe:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     500:	80 e0       	ldi	r24, 0x00	; 0
     502:	92 e0       	ldi	r25, 0x02	; 2
     504:	20 e0       	ldi	r18, 0x00	; 0
     506:	32 e0       	ldi	r19, 0x02	; 2
     508:	f9 01       	movw	r30, r18
     50a:	20 81       	ld	r18, Z
     50c:	21 60       	ori	r18, 0x01	; 1
     50e:	fc 01       	movw	r30, r24
     510:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     512:	80 e0       	ldi	r24, 0x00	; 0
     514:	92 e0       	ldi	r25, 0x02	; 2
     516:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     51a:	80 e0       	ldi	r24, 0x00	; 0
     51c:	92 e0       	ldi	r25, 0x02	; 2
     51e:	20 e0       	ldi	r18, 0x00	; 0
     520:	32 e0       	ldi	r19, 0x02	; 2
     522:	f9 01       	movw	r30, r18
     524:	21 81       	ldd	r18, Z+1	; 0x01
     526:	28 60       	ori	r18, 0x08	; 8
     528:	fc 01       	movw	r30, r24
     52a:	21 83       	std	Z+1, r18	; 0x01

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     52c:	1d 86       	std	Y+13, r1	; 0x0d
     52e:	1e 86       	std	Y+14, r1	; 0x0e
     530:	56 c0       	rjmp	.+172    	; 0x5de <CO_collectTemp+0x1d2>

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     532:	80 e2       	ldi	r24, 0x20	; 32
     534:	92 e0       	ldi	r25, 0x02	; 2
     536:	fc 01       	movw	r30, r24
     538:	83 81       	ldd	r24, Z+3	; 0x03
     53a:	88 2f       	mov	r24, r24
     53c:	90 e0       	ldi	r25, 0x00	; 0
     53e:	81 70       	andi	r24, 0x01	; 1
     540:	90 70       	andi	r25, 0x00	; 0
     542:	00 97       	sbiw	r24, 0x00	; 0
     544:	b1 f3       	breq	.-20     	; 0x532 <CO_collectTemp+0x126>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     546:	2d 89       	ldd	r18, Y+21	; 0x15
     548:	80 e2       	ldi	r24, 0x20	; 32
     54a:	92 e0       	ldi	r25, 0x02	; 2
     54c:	62 2f       	mov	r22, r18
     54e:	0e 94 77 1b 	call	0x36ee	; 0x36ee <ADC_ResultCh_GetWord_Signed>
     552:	8f 87       	std	Y+15, r24	; 0x0f
     554:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResult;
     556:	8f 85       	ldd	r24, Y+15	; 0x0f
     558:	98 89       	ldd	r25, Y+16	; 0x10
     55a:	cc 01       	movw	r24, r24
     55c:	a0 e0       	ldi	r26, 0x00	; 0
     55e:	b0 e0       	ldi	r27, 0x00	; 0
     560:	29 81       	ldd	r18, Y+1	; 0x01
     562:	3a 81       	ldd	r19, Y+2	; 0x02
     564:	4b 81       	ldd	r20, Y+3	; 0x03
     566:	5c 81       	ldd	r21, Y+4	; 0x04
     568:	82 0f       	add	r24, r18
     56a:	93 1f       	adc	r25, r19
     56c:	a4 1f       	adc	r26, r20
     56e:	b5 1f       	adc	r27, r21
     570:	89 83       	std	Y+1, r24	; 0x01
     572:	9a 83       	std	Y+2, r25	; 0x02
     574:	ab 83       	std	Y+3, r26	; 0x03
     576:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResult) { max = tempResult;}
     578:	8f 85       	ldd	r24, Y+15	; 0x0f
     57a:	98 89       	ldd	r25, Y+16	; 0x10
     57c:	9c 01       	movw	r18, r24
     57e:	40 e0       	ldi	r20, 0x00	; 0
     580:	50 e0       	ldi	r21, 0x00	; 0
     582:	89 85       	ldd	r24, Y+9	; 0x09
     584:	9a 85       	ldd	r25, Y+10	; 0x0a
     586:	ab 85       	ldd	r26, Y+11	; 0x0b
     588:	bc 85       	ldd	r27, Y+12	; 0x0c
     58a:	82 17       	cp	r24, r18
     58c:	93 07       	cpc	r25, r19
     58e:	a4 07       	cpc	r26, r20
     590:	b5 07       	cpc	r27, r21
     592:	48 f4       	brcc	.+18     	; 0x5a6 <CO_collectTemp+0x19a>
     594:	8f 85       	ldd	r24, Y+15	; 0x0f
     596:	98 89       	ldd	r25, Y+16	; 0x10
     598:	cc 01       	movw	r24, r24
     59a:	a0 e0       	ldi	r26, 0x00	; 0
     59c:	b0 e0       	ldi	r27, 0x00	; 0
     59e:	89 87       	std	Y+9, r24	; 0x09
     5a0:	9a 87       	std	Y+10, r25	; 0x0a
     5a2:	ab 87       	std	Y+11, r26	; 0x0b
     5a4:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResult) { min = tempResult;}
     5a6:	8f 85       	ldd	r24, Y+15	; 0x0f
     5a8:	98 89       	ldd	r25, Y+16	; 0x10
     5aa:	9c 01       	movw	r18, r24
     5ac:	40 e0       	ldi	r20, 0x00	; 0
     5ae:	50 e0       	ldi	r21, 0x00	; 0
     5b0:	8d 81       	ldd	r24, Y+5	; 0x05
     5b2:	9e 81       	ldd	r25, Y+6	; 0x06
     5b4:	af 81       	ldd	r26, Y+7	; 0x07
     5b6:	b8 85       	ldd	r27, Y+8	; 0x08
     5b8:	28 17       	cp	r18, r24
     5ba:	39 07       	cpc	r19, r25
     5bc:	4a 07       	cpc	r20, r26
     5be:	5b 07       	cpc	r21, r27
     5c0:	48 f4       	brcc	.+18     	; 0x5d4 <CO_collectTemp+0x1c8>
     5c2:	8f 85       	ldd	r24, Y+15	; 0x0f
     5c4:	98 89       	ldd	r25, Y+16	; 0x10
     5c6:	cc 01       	movw	r24, r24
     5c8:	a0 e0       	ldi	r26, 0x00	; 0
     5ca:	b0 e0       	ldi	r27, 0x00	; 0
     5cc:	8d 83       	std	Y+5, r24	; 0x05
     5ce:	9e 83       	std	Y+6, r25	; 0x06
     5d0:	af 83       	std	Y+7, r26	; 0x07
     5d2:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     5d4:	8d 85       	ldd	r24, Y+13	; 0x0d
     5d6:	9e 85       	ldd	r25, Y+14	; 0x0e
     5d8:	01 96       	adiw	r24, 0x01	; 1
     5da:	8d 87       	std	Y+13, r24	; 0x0d
     5dc:	9e 87       	std	Y+14, r25	; 0x0e
     5de:	8d 85       	ldd	r24, Y+13	; 0x0d
     5e0:	9e 85       	ldd	r25, Y+14	; 0x0e
     5e2:	f4 e0       	ldi	r31, 0x04	; 4
     5e4:	80 30       	cpi	r24, 0x00	; 0
     5e6:	9f 07       	cpc	r25, r31
     5e8:	08 f4       	brcc	.+2      	; 0x5ec <CO_collectTemp+0x1e0>
     5ea:	a3 cf       	rjmp	.-186    	; 0x532 <CO_collectTemp+0x126>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     5ec:	80 e0       	ldi	r24, 0x00	; 0
     5ee:	92 e0       	ldi	r25, 0x02	; 2
     5f0:	20 e0       	ldi	r18, 0x00	; 0
     5f2:	32 e0       	ldi	r19, 0x02	; 2
     5f4:	f9 01       	movw	r30, r18
     5f6:	21 81       	ldd	r18, Z+1	; 0x01
     5f8:	27 7f       	andi	r18, 0xF7	; 247
     5fa:	fc 01       	movw	r30, r24
     5fc:	21 83       	std	Z+1, r18	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     5fe:	80 e0       	ldi	r24, 0x00	; 0
     600:	92 e0       	ldi	r25, 0x02	; 2
     602:	20 e0       	ldi	r18, 0x00	; 0
     604:	32 e0       	ldi	r19, 0x02	; 2
     606:	f9 01       	movw	r30, r18
     608:	20 81       	ld	r18, Z
     60a:	22 60       	ori	r18, 0x02	; 2
     60c:	fc 01       	movw	r30, r24
     60e:	20 83       	st	Z, r18
	ADC_Disable(&ADCA);
     610:	80 e0       	ldi	r24, 0x00	; 0
     612:	92 e0       	ldi	r25, 0x02	; 2
     614:	20 e0       	ldi	r18, 0x00	; 0
     616:	32 e0       	ldi	r19, 0x02	; 2
     618:	f9 01       	movw	r30, r18
     61a:	20 81       	ld	r18, Z
     61c:	2e 7f       	andi	r18, 0xFE	; 254
     61e:	fc 01       	movw	r30, r24
     620:	20 83       	st	Z, r18

	ADCPower(FALSE);
     622:	80 e0       	ldi	r24, 0x00	; 0
     624:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>

	average = sum / NUM_SAMPLES;
     628:	89 81       	ldd	r24, Y+1	; 0x01
     62a:	9a 81       	ldd	r25, Y+2	; 0x02
     62c:	ab 81       	ldd	r26, Y+3	; 0x03
     62e:	bc 81       	ldd	r27, Y+4	; 0x04
     630:	07 2e       	mov	r0, r23
     632:	7a e0       	ldi	r23, 0x0A	; 10
     634:	b6 95       	lsr	r27
     636:	a7 95       	ror	r26
     638:	97 95       	ror	r25
     63a:	87 95       	ror	r24
     63c:	7a 95       	dec	r23
     63e:	d1 f7       	brne	.-12     	; 0x634 <CO_collectTemp+0x228>
     640:	70 2d       	mov	r23, r0
     642:	89 8b       	std	Y+17, r24	; 0x11
     644:	9a 8b       	std	Y+18, r25	; 0x12
     646:	ab 8b       	std	Y+19, r26	; 0x13
     648:	bc 8b       	std	Y+20, r27	; 0x14

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     64a:	89 89       	ldd	r24, Y+17	; 0x11
     64c:	9a 89       	ldd	r25, Y+18	; 0x12
     64e:	ab 89       	ldd	r26, Y+19	; 0x13
     650:	bc 89       	ldd	r27, Y+20	; 0x14
     652:	28 ee       	ldi	r18, 0xE8	; 232
     654:	33 e0       	ldi	r19, 0x03	; 3
     656:	40 e0       	ldi	r20, 0x00	; 0
     658:	50 e0       	ldi	r21, 0x00	; 0
     65a:	bc 01       	movw	r22, r24
     65c:	cd 01       	movw	r24, r26
     65e:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
     662:	dc 01       	movw	r26, r24
     664:	cb 01       	movw	r24, r22
     666:	2f ef       	ldi	r18, 0xFF	; 255
     668:	3f e0       	ldi	r19, 0x0F	; 15
     66a:	40 e0       	ldi	r20, 0x00	; 0
     66c:	50 e0       	ldi	r21, 0x00	; 0
     66e:	bc 01       	movw	r22, r24
     670:	cd 01       	movw	r24, r26
     672:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
     676:	da 01       	movw	r26, r20
     678:	c9 01       	movw	r24, r18
     67a:	9c 01       	movw	r18, r24
     67c:	22 53       	subi	r18, 0x32	; 50
     67e:	30 40       	sbci	r19, 0x00	; 0
     680:	8e 89       	ldd	r24, Y+22	; 0x16
     682:	9f 89       	ldd	r25, Y+23	; 0x17
     684:	fc 01       	movw	r30, r24
     686:	20 83       	st	Z, r18
     688:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     68a:	89 85       	ldd	r24, Y+9	; 0x09
     68c:	9a 85       	ldd	r25, Y+10	; 0x0a
     68e:	ab 85       	ldd	r26, Y+11	; 0x0b
     690:	bc 85       	ldd	r27, Y+12	; 0x0c
     692:	28 ee       	ldi	r18, 0xE8	; 232
     694:	33 e0       	ldi	r19, 0x03	; 3
     696:	40 e0       	ldi	r20, 0x00	; 0
     698:	50 e0       	ldi	r21, 0x00	; 0
     69a:	bc 01       	movw	r22, r24
     69c:	cd 01       	movw	r24, r26
     69e:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
     6a2:	dc 01       	movw	r26, r24
     6a4:	cb 01       	movw	r24, r22
     6a6:	2f ef       	ldi	r18, 0xFF	; 255
     6a8:	3f e0       	ldi	r19, 0x0F	; 15
     6aa:	40 e0       	ldi	r20, 0x00	; 0
     6ac:	50 e0       	ldi	r21, 0x00	; 0
     6ae:	bc 01       	movw	r22, r24
     6b0:	cd 01       	movw	r24, r26
     6b2:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
     6b6:	da 01       	movw	r26, r20
     6b8:	c9 01       	movw	r24, r18
     6ba:	9c 01       	movw	r18, r24
     6bc:	22 53       	subi	r18, 0x32	; 50
     6be:	30 40       	sbci	r19, 0x00	; 0
     6c0:	8a 8d       	ldd	r24, Y+26	; 0x1a
     6c2:	9b 8d       	ldd	r25, Y+27	; 0x1b
     6c4:	fc 01       	movw	r30, r24
     6c6:	20 83       	st	Z, r18
     6c8:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     6ca:	8d 81       	ldd	r24, Y+5	; 0x05
     6cc:	9e 81       	ldd	r25, Y+6	; 0x06
     6ce:	af 81       	ldd	r26, Y+7	; 0x07
     6d0:	b8 85       	ldd	r27, Y+8	; 0x08
     6d2:	28 ee       	ldi	r18, 0xE8	; 232
     6d4:	33 e0       	ldi	r19, 0x03	; 3
     6d6:	40 e0       	ldi	r20, 0x00	; 0
     6d8:	50 e0       	ldi	r21, 0x00	; 0
     6da:	bc 01       	movw	r22, r24
     6dc:	cd 01       	movw	r24, r26
     6de:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
     6e2:	dc 01       	movw	r26, r24
     6e4:	cb 01       	movw	r24, r22
     6e6:	2f ef       	ldi	r18, 0xFF	; 255
     6e8:	3f e0       	ldi	r19, 0x0F	; 15
     6ea:	40 e0       	ldi	r20, 0x00	; 0
     6ec:	50 e0       	ldi	r21, 0x00	; 0
     6ee:	bc 01       	movw	r22, r24
     6f0:	cd 01       	movw	r24, r26
     6f2:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
     6f6:	da 01       	movw	r26, r20
     6f8:	c9 01       	movw	r24, r18
     6fa:	9c 01       	movw	r18, r24
     6fc:	22 53       	subi	r18, 0x32	; 50
     6fe:	30 40       	sbci	r19, 0x00	; 0
     700:	88 8d       	ldd	r24, Y+24	; 0x18
     702:	99 8d       	ldd	r25, Y+25	; 0x19
     704:	fc 01       	movw	r30, r24
     706:	20 83       	st	Z, r18
     708:	31 83       	std	Z+1, r19	; 0x01
}
     70a:	6b 96       	adiw	r28, 0x1b	; 27
     70c:	cd bf       	out	0x3d, r28	; 61
     70e:	de bf       	out	0x3e, r29	; 62
     710:	df 91       	pop	r29
     712:	cf 91       	pop	r28
     714:	08 95       	ret

00000716 <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     716:	0f 93       	push	r16
     718:	1f 93       	push	r17
     71a:	cf 93       	push	r28
     71c:	df 93       	push	r29
     71e:	cd b7       	in	r28, 0x3d	; 61
     720:	de b7       	in	r29, 0x3e	; 62
     722:	a9 97       	sbiw	r28, 0x29	; 41
     724:	cd bf       	out	0x3d, r28	; 61
     726:	de bf       	out	0x3e, r29	; 62
     728:	8c a3       	lds	r24, 0x5c
     72a:	9d a3       	lds	r25, 0x5d
     72c:	6e a3       	lds	r22, 0x5e
     72e:	7f a3       	lds	r23, 0x5f
     730:	48 a7       	lds	r20, 0x78
     732:	59 a7       	lds	r21, 0x79
	uint32_t sum = 0;
     734:	19 82       	std	Y+1, r1	; 0x01
     736:	1a 82       	std	Y+2, r1	; 0x02
     738:	1b 82       	std	Y+3, r1	; 0x03
     73a:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     73c:	80 e0       	ldi	r24, 0x00	; 0
     73e:	90 e1       	ldi	r25, 0x10	; 16
     740:	a0 e0       	ldi	r26, 0x00	; 0
     742:	b0 e0       	ldi	r27, 0x00	; 0
     744:	8d 83       	std	Y+5, r24	; 0x05
     746:	9e 83       	std	Y+6, r25	; 0x06
     748:	af 83       	std	Y+7, r26	; 0x07
     74a:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     74c:	19 86       	std	Y+9, r1	; 0x09
     74e:	1a 86       	std	Y+10, r1	; 0x0a
     750:	1b 86       	std	Y+11, r1	; 0x0b
     752:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     754:	81 e0       	ldi	r24, 0x01	; 1
     756:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     75a:	84 e0       	ldi	r24, 0x04	; 4
     75c:	60 e0       	ldi	r22, 0x00	; 0
     75e:	0e 94 a8 33 	call	0x6750	; 0x6750 <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     762:	84 e0       	ldi	r24, 0x04	; 4
     764:	60 e0       	ldi	r22, 0x00	; 0
     766:	0e 94 74 34 	call	0x68e8	; 0x68e8 <PortEx_OUTSET>
     76a:	80 e0       	ldi	r24, 0x00	; 0
     76c:	90 e0       	ldi	r25, 0x00	; 0
     76e:	a8 ec       	ldi	r26, 0xC8	; 200
     770:	b2 e4       	ldi	r27, 0x42	; 66
     772:	8d 8b       	std	Y+21, r24	; 0x15
     774:	9e 8b       	std	Y+22, r25	; 0x16
     776:	af 8b       	std	Y+23, r26	; 0x17
     778:	b8 8f       	std	Y+24, r27	; 0x18
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     77a:	6d 89       	ldd	r22, Y+21	; 0x15
     77c:	7e 89       	ldd	r23, Y+22	; 0x16
     77e:	8f 89       	ldd	r24, Y+23	; 0x17
     780:	98 8d       	ldd	r25, Y+24	; 0x18
     782:	20 e0       	ldi	r18, 0x00	; 0
     784:	30 e0       	ldi	r19, 0x00	; 0
     786:	4a ef       	ldi	r20, 0xFA	; 250
     788:	55 e4       	ldi	r21, 0x45	; 69
     78a:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
     78e:	dc 01       	movw	r26, r24
     790:	cb 01       	movw	r24, r22
     792:	89 8f       	std	Y+25, r24	; 0x19
     794:	9a 8f       	std	Y+26, r25	; 0x1a
     796:	ab 8f       	std	Y+27, r26	; 0x1b
     798:	bc 8f       	std	Y+28, r27	; 0x1c
	if (__tmp < 1.0)
     79a:	11 e0       	ldi	r17, 0x01	; 1
     79c:	69 8d       	ldd	r22, Y+25	; 0x19
     79e:	7a 8d       	ldd	r23, Y+26	; 0x1a
     7a0:	8b 8d       	ldd	r24, Y+27	; 0x1b
     7a2:	9c 8d       	ldd	r25, Y+28	; 0x1c
     7a4:	20 e0       	ldi	r18, 0x00	; 0
     7a6:	30 e0       	ldi	r19, 0x00	; 0
     7a8:	40 e8       	ldi	r20, 0x80	; 128
     7aa:	5f e3       	ldi	r21, 0x3F	; 63
     7ac:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
     7b0:	88 23       	and	r24, r24
     7b2:	0c f0       	brlt	.+2      	; 0x7b6 <CO_collectBatt+0xa0>
     7b4:	10 e0       	ldi	r17, 0x00	; 0
     7b6:	11 23       	and	r17, r17
     7b8:	29 f0       	breq	.+10     	; 0x7c4 <CO_collectBatt+0xae>
		__ticks = 1;
     7ba:	81 e0       	ldi	r24, 0x01	; 1
     7bc:	90 e0       	ldi	r25, 0x00	; 0
     7be:	8d 8f       	std	Y+29, r24	; 0x1d
     7c0:	9e 8f       	std	Y+30, r25	; 0x1e
     7c2:	46 c0       	rjmp	.+140    	; 0x850 <CO_collectBatt+0x13a>
	else if (__tmp > 65535)
     7c4:	11 e0       	ldi	r17, 0x01	; 1
     7c6:	69 8d       	ldd	r22, Y+25	; 0x19
     7c8:	7a 8d       	ldd	r23, Y+26	; 0x1a
     7ca:	8b 8d       	ldd	r24, Y+27	; 0x1b
     7cc:	9c 8d       	ldd	r25, Y+28	; 0x1c
     7ce:	20 e0       	ldi	r18, 0x00	; 0
     7d0:	3f ef       	ldi	r19, 0xFF	; 255
     7d2:	4f e7       	ldi	r20, 0x7F	; 127
     7d4:	57 e4       	ldi	r21, 0x47	; 71
     7d6:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
     7da:	18 16       	cp	r1, r24
     7dc:	0c f0       	brlt	.+2      	; 0x7e0 <CO_collectBatt+0xca>
     7de:	10 e0       	ldi	r17, 0x00	; 0
     7e0:	11 23       	and	r17, r17
     7e2:	61 f1       	breq	.+88     	; 0x83c <CO_collectBatt+0x126>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     7e4:	6d 89       	ldd	r22, Y+21	; 0x15
     7e6:	7e 89       	ldd	r23, Y+22	; 0x16
     7e8:	8f 89       	ldd	r24, Y+23	; 0x17
     7ea:	98 8d       	ldd	r25, Y+24	; 0x18
     7ec:	20 e0       	ldi	r18, 0x00	; 0
     7ee:	30 e0       	ldi	r19, 0x00	; 0
     7f0:	40 e2       	ldi	r20, 0x20	; 32
     7f2:	51 e4       	ldi	r21, 0x41	; 65
     7f4:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
     7f8:	dc 01       	movw	r26, r24
     7fa:	cb 01       	movw	r24, r22
     7fc:	bc 01       	movw	r22, r24
     7fe:	cd 01       	movw	r24, r26
     800:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
     804:	dc 01       	movw	r26, r24
     806:	cb 01       	movw	r24, r22
     808:	8d 8f       	std	Y+29, r24	; 0x1d
     80a:	9e 8f       	std	Y+30, r25	; 0x1e
     80c:	12 c0       	rjmp	.+36     	; 0x832 <CO_collectBatt+0x11c>
     80e:	80 e2       	ldi	r24, 0x20	; 32
     810:	93 e0       	ldi	r25, 0x03	; 3
     812:	8f 8f       	std	Y+31, r24	; 0x1f
     814:	98 a3       	lds	r25, 0x58
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     816:	8f 8d       	ldd	r24, Y+31	; 0x1f
     818:	98 a1       	lds	r25, 0x48
     81a:	8c 01       	movw	r16, r24
     81c:	c8 01       	movw	r24, r16
     81e:	01 97       	sbiw	r24, 0x01	; 1
     820:	f1 f7       	brne	.-4      	; 0x81e <CO_collectBatt+0x108>
     822:	8c 01       	movw	r16, r24
     824:	0f 8f       	std	Y+31, r16	; 0x1f
     826:	18 a3       	lds	r17, 0x58
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     828:	8d 8d       	ldd	r24, Y+29	; 0x1d
     82a:	9e 8d       	ldd	r25, Y+30	; 0x1e
     82c:	01 97       	sbiw	r24, 0x01	; 1
     82e:	8d 8f       	std	Y+29, r24	; 0x1d
     830:	9e 8f       	std	Y+30, r25	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     832:	8d 8d       	ldd	r24, Y+29	; 0x1d
     834:	9e 8d       	ldd	r25, Y+30	; 0x1e
     836:	00 97       	sbiw	r24, 0x00	; 0
     838:	51 f7       	brne	.-44     	; 0x80e <CO_collectBatt+0xf8>
     83a:	17 c0       	rjmp	.+46     	; 0x86a <CO_collectBatt+0x154>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     83c:	69 8d       	ldd	r22, Y+25	; 0x19
     83e:	7a 8d       	ldd	r23, Y+26	; 0x1a
     840:	8b 8d       	ldd	r24, Y+27	; 0x1b
     842:	9c 8d       	ldd	r25, Y+28	; 0x1c
     844:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
     848:	dc 01       	movw	r26, r24
     84a:	cb 01       	movw	r24, r22
     84c:	8d 8f       	std	Y+29, r24	; 0x1d
     84e:	9e 8f       	std	Y+30, r25	; 0x1e
     850:	8d 8d       	ldd	r24, Y+29	; 0x1d
     852:	9e 8d       	ldd	r25, Y+30	; 0x1e
     854:	89 a3       	lds	r24, 0x59
     856:	9a a3       	lds	r25, 0x5a
     858:	89 a1       	lds	r24, 0x49
     85a:	9a a1       	lds	r25, 0x4a
     85c:	8c 01       	movw	r16, r24
     85e:	f8 01       	movw	r30, r16
     860:	31 97       	sbiw	r30, 0x01	; 1
     862:	f1 f7       	brne	.-4      	; 0x860 <CO_collectBatt+0x14a>
     864:	8f 01       	movw	r16, r30
     866:	09 a3       	lds	r16, 0x59
     868:	1a a3       	lds	r17, 0x5a
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     86a:	80 e4       	ldi	r24, 0x40	; 64
     86c:	92 e0       	ldi	r25, 0x02	; 2
     86e:	0e 94 1e 1b 	call	0x363c	; 0x363c <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     872:	80 e4       	ldi	r24, 0x40	; 64
     874:	92 e0       	ldi	r25, 0x02	; 2
     876:	20 e4       	ldi	r18, 0x40	; 64
     878:	32 e0       	ldi	r19, 0x02	; 2
     87a:	f9 01       	movw	r30, r18
     87c:	21 81       	ldd	r18, Z+1	; 0x01
     87e:	29 7e       	andi	r18, 0xE9	; 233
     880:	fc 01       	movw	r30, r24
     882:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     884:	80 e4       	ldi	r24, 0x40	; 64
     886:	92 e0       	ldi	r25, 0x02	; 2
     888:	20 e4       	ldi	r18, 0x40	; 64
     88a:	32 e0       	ldi	r19, 0x02	; 2
     88c:	f9 01       	movw	r30, r18
     88e:	24 81       	ldd	r18, Z+4	; 0x04
     890:	28 7f       	andi	r18, 0xF8	; 248
     892:	23 60       	ori	r18, 0x03	; 3
     894:	fc 01       	movw	r30, r24
     896:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     898:	80 e4       	ldi	r24, 0x40	; 64
     89a:	92 e0       	ldi	r25, 0x02	; 2
     89c:	20 e4       	ldi	r18, 0x40	; 64
     89e:	32 e0       	ldi	r19, 0x02	; 2
     8a0:	f9 01       	movw	r30, r18
     8a2:	22 81       	ldd	r18, Z+2	; 0x02
     8a4:	2f 7c       	andi	r18, 0xCF	; 207
     8a6:	fc 01       	movw	r30, r24
     8a8:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     8aa:	80 e6       	ldi	r24, 0x60	; 96
     8ac:	92 e0       	ldi	r25, 0x02	; 2
     8ae:	20 e6       	ldi	r18, 0x60	; 96
     8b0:	32 e0       	ldi	r19, 0x02	; 2
     8b2:	f9 01       	movw	r30, r18
     8b4:	20 81       	ld	r18, Z
     8b6:	20 7e       	andi	r18, 0xE0	; 224
     8b8:	21 60       	ori	r18, 0x01	; 1
     8ba:	fc 01       	movw	r30, r24
     8bc:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     8be:	80 e6       	ldi	r24, 0x60	; 96
     8c0:	92 e0       	ldi	r25, 0x02	; 2
     8c2:	29 e0       	ldi	r18, 0x09	; 9
     8c4:	fc 01       	movw	r30, r24
     8c6:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCB);
     8c8:	80 e4       	ldi	r24, 0x40	; 64
     8ca:	92 e0       	ldi	r25, 0x02	; 2
     8cc:	20 e4       	ldi	r18, 0x40	; 64
     8ce:	32 e0       	ldi	r19, 0x02	; 2
     8d0:	f9 01       	movw	r30, r18
     8d2:	20 81       	ld	r18, Z
     8d4:	21 60       	ori	r18, 0x01	; 1
     8d6:	fc 01       	movw	r30, r24
     8d8:	20 83       	st	Z, r18
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     8da:	80 e4       	ldi	r24, 0x40	; 64
     8dc:	92 e0       	ldi	r25, 0x02	; 2
     8de:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     8e2:	80 e4       	ldi	r24, 0x40	; 64
     8e4:	92 e0       	ldi	r25, 0x02	; 2
     8e6:	60 e6       	ldi	r22, 0x60	; 96
     8e8:	72 e0       	ldi	r23, 0x02	; 2
     8ea:	40 e0       	ldi	r20, 0x00	; 0
     8ec:	0e 94 cd 1d 	call	0x3b9a	; 0x3b9a <ADC_Offset_Get_Unsigned>
     8f0:	8b a3       	lds	r24, 0x5b
    ADC_Disable(&ADCB);
     8f2:	80 e4       	ldi	r24, 0x40	; 64
     8f4:	92 e0       	ldi	r25, 0x02	; 2
     8f6:	20 e4       	ldi	r18, 0x40	; 64
     8f8:	32 e0       	ldi	r19, 0x02	; 2
     8fa:	f9 01       	movw	r30, r18
     8fc:	20 81       	ld	r18, Z
     8fe:	2e 7f       	andi	r18, 0xFE	; 254
     900:	fc 01       	movw	r30, r24
     902:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     904:	80 e6       	ldi	r24, 0x60	; 96
     906:	92 e0       	ldi	r25, 0x02	; 2
     908:	fc 01       	movw	r30, r24
     90a:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     90c:	80 e4       	ldi	r24, 0x40	; 64
     90e:	92 e0       	ldi	r25, 0x02	; 2
     910:	20 e4       	ldi	r18, 0x40	; 64
     912:	32 e0       	ldi	r19, 0x02	; 2
     914:	f9 01       	movw	r30, r18
     916:	23 81       	ldd	r18, Z+3	; 0x03
     918:	2f 73       	andi	r18, 0x3F	; 63
     91a:	fc 01       	movw	r30, r24
     91c:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     91e:	80 e4       	ldi	r24, 0x40	; 64
     920:	92 e0       	ldi	r25, 0x02	; 2
     922:	20 e4       	ldi	r18, 0x40	; 64
     924:	32 e0       	ldi	r19, 0x02	; 2
     926:	f9 01       	movw	r30, r18
     928:	20 81       	ld	r18, Z
     92a:	21 60       	ori	r18, 0x01	; 1
     92c:	fc 01       	movw	r30, r24
     92e:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     930:	80 e4       	ldi	r24, 0x40	; 64
     932:	92 e0       	ldi	r25, 0x02	; 2
     934:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     938:	80 e4       	ldi	r24, 0x40	; 64
     93a:	92 e0       	ldi	r25, 0x02	; 2
     93c:	20 e4       	ldi	r18, 0x40	; 64
     93e:	32 e0       	ldi	r19, 0x02	; 2
     940:	f9 01       	movw	r30, r18
     942:	21 81       	ldd	r18, Z+1	; 0x01
     944:	28 60       	ori	r18, 0x08	; 8
     946:	fc 01       	movw	r30, r24
     948:	21 83       	std	Z+1, r18	; 0x01

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     94a:	1d 86       	std	Y+13, r1	; 0x0d
     94c:	1e 86       	std	Y+14, r1	; 0x0e
     94e:	56 c0       	rjmp	.+172    	; 0x9fc <CO_collectBatt+0x2e6>

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     950:	80 e6       	ldi	r24, 0x60	; 96
     952:	92 e0       	ldi	r25, 0x02	; 2
     954:	fc 01       	movw	r30, r24
     956:	83 81       	ldd	r24, Z+3	; 0x03
     958:	88 2f       	mov	r24, r24
     95a:	90 e0       	ldi	r25, 0x00	; 0
     95c:	81 70       	andi	r24, 0x01	; 1
     95e:	90 70       	andi	r25, 0x00	; 0
     960:	00 97       	sbiw	r24, 0x00	; 0
     962:	b1 f3       	breq	.-20     	; 0x950 <CO_collectBatt+0x23a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     964:	2b a1       	lds	r18, 0x4b
     966:	80 e6       	ldi	r24, 0x60	; 96
     968:	92 e0       	ldi	r25, 0x02	; 2
     96a:	62 2f       	mov	r22, r18
     96c:	0e 94 77 1b 	call	0x36ee	; 0x36ee <ADC_ResultCh_GetWord_Signed>
     970:	8f 87       	std	Y+15, r24	; 0x0f
     972:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResultB;
     974:	8f 85       	ldd	r24, Y+15	; 0x0f
     976:	98 89       	ldd	r25, Y+16	; 0x10
     978:	cc 01       	movw	r24, r24
     97a:	a0 e0       	ldi	r26, 0x00	; 0
     97c:	b0 e0       	ldi	r27, 0x00	; 0
     97e:	29 81       	ldd	r18, Y+1	; 0x01
     980:	3a 81       	ldd	r19, Y+2	; 0x02
     982:	4b 81       	ldd	r20, Y+3	; 0x03
     984:	5c 81       	ldd	r21, Y+4	; 0x04
     986:	82 0f       	add	r24, r18
     988:	93 1f       	adc	r25, r19
     98a:	a4 1f       	adc	r26, r20
     98c:	b5 1f       	adc	r27, r21
     98e:	89 83       	std	Y+1, r24	; 0x01
     990:	9a 83       	std	Y+2, r25	; 0x02
     992:	ab 83       	std	Y+3, r26	; 0x03
     994:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResultB) { max = tempResultB;}
     996:	8f 85       	ldd	r24, Y+15	; 0x0f
     998:	98 89       	ldd	r25, Y+16	; 0x10
     99a:	9c 01       	movw	r18, r24
     99c:	40 e0       	ldi	r20, 0x00	; 0
     99e:	50 e0       	ldi	r21, 0x00	; 0
     9a0:	89 85       	ldd	r24, Y+9	; 0x09
     9a2:	9a 85       	ldd	r25, Y+10	; 0x0a
     9a4:	ab 85       	ldd	r26, Y+11	; 0x0b
     9a6:	bc 85       	ldd	r27, Y+12	; 0x0c
     9a8:	82 17       	cp	r24, r18
     9aa:	93 07       	cpc	r25, r19
     9ac:	a4 07       	cpc	r26, r20
     9ae:	b5 07       	cpc	r27, r21
     9b0:	48 f4       	brcc	.+18     	; 0x9c4 <CO_collectBatt+0x2ae>
     9b2:	8f 85       	ldd	r24, Y+15	; 0x0f
     9b4:	98 89       	ldd	r25, Y+16	; 0x10
     9b6:	cc 01       	movw	r24, r24
     9b8:	a0 e0       	ldi	r26, 0x00	; 0
     9ba:	b0 e0       	ldi	r27, 0x00	; 0
     9bc:	89 87       	std	Y+9, r24	; 0x09
     9be:	9a 87       	std	Y+10, r25	; 0x0a
     9c0:	ab 87       	std	Y+11, r26	; 0x0b
     9c2:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResultB) { min = tempResultB;}
     9c4:	8f 85       	ldd	r24, Y+15	; 0x0f
     9c6:	98 89       	ldd	r25, Y+16	; 0x10
     9c8:	9c 01       	movw	r18, r24
     9ca:	40 e0       	ldi	r20, 0x00	; 0
     9cc:	50 e0       	ldi	r21, 0x00	; 0
     9ce:	8d 81       	ldd	r24, Y+5	; 0x05
     9d0:	9e 81       	ldd	r25, Y+6	; 0x06
     9d2:	af 81       	ldd	r26, Y+7	; 0x07
     9d4:	b8 85       	ldd	r27, Y+8	; 0x08
     9d6:	28 17       	cp	r18, r24
     9d8:	39 07       	cpc	r19, r25
     9da:	4a 07       	cpc	r20, r26
     9dc:	5b 07       	cpc	r21, r27
     9de:	48 f4       	brcc	.+18     	; 0x9f2 <CO_collectBatt+0x2dc>
     9e0:	8f 85       	ldd	r24, Y+15	; 0x0f
     9e2:	98 89       	ldd	r25, Y+16	; 0x10
     9e4:	cc 01       	movw	r24, r24
     9e6:	a0 e0       	ldi	r26, 0x00	; 0
     9e8:	b0 e0       	ldi	r27, 0x00	; 0
     9ea:	8d 83       	std	Y+5, r24	; 0x05
     9ec:	9e 83       	std	Y+6, r25	; 0x06
     9ee:	af 83       	std	Y+7, r26	; 0x07
     9f0:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     9f2:	8d 85       	ldd	r24, Y+13	; 0x0d
     9f4:	9e 85       	ldd	r25, Y+14	; 0x0e
     9f6:	01 96       	adiw	r24, 0x01	; 1
     9f8:	8d 87       	std	Y+13, r24	; 0x0d
     9fa:	9e 87       	std	Y+14, r25	; 0x0e
     9fc:	8d 85       	ldd	r24, Y+13	; 0x0d
     9fe:	9e 85       	ldd	r25, Y+14	; 0x0e
     a00:	f4 e0       	ldi	r31, 0x04	; 4
     a02:	80 30       	cpi	r24, 0x00	; 0
     a04:	9f 07       	cpc	r25, r31
     a06:	08 f4       	brcc	.+2      	; 0xa0a <CO_collectBatt+0x2f4>
     a08:	a3 cf       	rjmp	.-186    	; 0x950 <CO_collectBatt+0x23a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     a0a:	80 e4       	ldi	r24, 0x40	; 64
     a0c:	92 e0       	ldi	r25, 0x02	; 2
     a0e:	20 e4       	ldi	r18, 0x40	; 64
     a10:	32 e0       	ldi	r19, 0x02	; 2
     a12:	f9 01       	movw	r30, r18
     a14:	21 81       	ldd	r18, Z+1	; 0x01
     a16:	27 7f       	andi	r18, 0xF7	; 247
     a18:	fc 01       	movw	r30, r24
     a1a:	21 83       	std	Z+1, r18	; 0x01
	ADC_Disable(&ADCB);
     a1c:	80 e4       	ldi	r24, 0x40	; 64
     a1e:	92 e0       	ldi	r25, 0x02	; 2
     a20:	20 e4       	ldi	r18, 0x40	; 64
     a22:	32 e0       	ldi	r19, 0x02	; 2
     a24:	f9 01       	movw	r30, r18
     a26:	20 81       	ld	r18, Z
     a28:	2e 7f       	andi	r18, 0xFE	; 254
     a2a:	fc 01       	movw	r30, r24
     a2c:	20 83       	st	Z, r18

	average = sum / NUM_SAMPLES;
     a2e:	89 81       	ldd	r24, Y+1	; 0x01
     a30:	9a 81       	ldd	r25, Y+2	; 0x02
     a32:	ab 81       	ldd	r26, Y+3	; 0x03
     a34:	bc 81       	ldd	r27, Y+4	; 0x04
     a36:	07 2e       	mov	r0, r23
     a38:	7a e0       	ldi	r23, 0x0A	; 10
     a3a:	b6 95       	lsr	r27
     a3c:	a7 95       	ror	r26
     a3e:	97 95       	ror	r25
     a40:	87 95       	ror	r24
     a42:	7a 95       	dec	r23
     a44:	d1 f7       	brne	.-12     	; 0xa3a <CO_collectBatt+0x324>
     a46:	70 2d       	mov	r23, r0
     a48:	89 8b       	std	Y+17, r24	; 0x11
     a4a:	9a 8b       	std	Y+18, r25	; 0x12
     a4c:	ab 8b       	std	Y+19, r26	; 0x13
     a4e:	bc 8b       	std	Y+20, r27	; 0x14
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     a50:	84 e0       	ldi	r24, 0x04	; 4
     a52:	60 e0       	ldi	r22, 0x00	; 0
     a54:	0e 94 0c 34 	call	0x6818	; 0x6818 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     a58:	80 e0       	ldi	r24, 0x00	; 0
     a5a:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     a5e:	89 89       	ldd	r24, Y+17	; 0x11
     a60:	9a 89       	ldd	r25, Y+18	; 0x12
     a62:	ab 89       	ldd	r26, Y+19	; 0x13
     a64:	bc 89       	ldd	r27, Y+20	; 0x14
     a66:	28 ee       	ldi	r18, 0xE8	; 232
     a68:	33 e0       	ldi	r19, 0x03	; 3
     a6a:	40 e0       	ldi	r20, 0x00	; 0
     a6c:	50 e0       	ldi	r21, 0x00	; 0
     a6e:	bc 01       	movw	r22, r24
     a70:	cd 01       	movw	r24, r26
     a72:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
     a76:	dc 01       	movw	r26, r24
     a78:	cb 01       	movw	r24, r22
     a7a:	2f ef       	ldi	r18, 0xFF	; 255
     a7c:	3f e0       	ldi	r19, 0x0F	; 15
     a7e:	40 e0       	ldi	r20, 0x00	; 0
     a80:	50 e0       	ldi	r21, 0x00	; 0
     a82:	bc 01       	movw	r22, r24
     a84:	cd 01       	movw	r24, r26
     a86:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
     a8a:	da 01       	movw	r26, r20
     a8c:	c9 01       	movw	r24, r18
     a8e:	9c 01       	movw	r18, r24
     a90:	22 53       	subi	r18, 0x32	; 50
     a92:	30 40       	sbci	r19, 0x00	; 0
     a94:	8c a1       	lds	r24, 0x4c
     a96:	9d a1       	lds	r25, 0x4d
     a98:	fc 01       	movw	r30, r24
     a9a:	20 83       	st	Z, r18
     a9c:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     a9e:	89 85       	ldd	r24, Y+9	; 0x09
     aa0:	9a 85       	ldd	r25, Y+10	; 0x0a
     aa2:	ab 85       	ldd	r26, Y+11	; 0x0b
     aa4:	bc 85       	ldd	r27, Y+12	; 0x0c
     aa6:	28 ee       	ldi	r18, 0xE8	; 232
     aa8:	33 e0       	ldi	r19, 0x03	; 3
     aaa:	40 e0       	ldi	r20, 0x00	; 0
     aac:	50 e0       	ldi	r21, 0x00	; 0
     aae:	bc 01       	movw	r22, r24
     ab0:	cd 01       	movw	r24, r26
     ab2:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
     ab6:	dc 01       	movw	r26, r24
     ab8:	cb 01       	movw	r24, r22
     aba:	2f ef       	ldi	r18, 0xFF	; 255
     abc:	3f e0       	ldi	r19, 0x0F	; 15
     abe:	40 e0       	ldi	r20, 0x00	; 0
     ac0:	50 e0       	ldi	r21, 0x00	; 0
     ac2:	bc 01       	movw	r22, r24
     ac4:	cd 01       	movw	r24, r26
     ac6:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
     aca:	da 01       	movw	r26, r20
     acc:	c9 01       	movw	r24, r18
     ace:	9c 01       	movw	r18, r24
     ad0:	22 53       	subi	r18, 0x32	; 50
     ad2:	30 40       	sbci	r19, 0x00	; 0
     ad4:	88 a5       	lds	r24, 0x68
     ad6:	99 a5       	lds	r25, 0x69
     ad8:	fc 01       	movw	r30, r24
     ada:	20 83       	st	Z, r18
     adc:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     ade:	8d 81       	ldd	r24, Y+5	; 0x05
     ae0:	9e 81       	ldd	r25, Y+6	; 0x06
     ae2:	af 81       	ldd	r26, Y+7	; 0x07
     ae4:	b8 85       	ldd	r27, Y+8	; 0x08
     ae6:	28 ee       	ldi	r18, 0xE8	; 232
     ae8:	33 e0       	ldi	r19, 0x03	; 3
     aea:	40 e0       	ldi	r20, 0x00	; 0
     aec:	50 e0       	ldi	r21, 0x00	; 0
     aee:	bc 01       	movw	r22, r24
     af0:	cd 01       	movw	r24, r26
     af2:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
     af6:	dc 01       	movw	r26, r24
     af8:	cb 01       	movw	r24, r22
     afa:	2f ef       	ldi	r18, 0xFF	; 255
     afc:	3f e0       	ldi	r19, 0x0F	; 15
     afe:	40 e0       	ldi	r20, 0x00	; 0
     b00:	50 e0       	ldi	r21, 0x00	; 0
     b02:	bc 01       	movw	r22, r24
     b04:	cd 01       	movw	r24, r26
     b06:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
     b0a:	da 01       	movw	r26, r20
     b0c:	c9 01       	movw	r24, r18
     b0e:	9c 01       	movw	r18, r24
     b10:	22 53       	subi	r18, 0x32	; 50
     b12:	30 40       	sbci	r19, 0x00	; 0
     b14:	8e a1       	lds	r24, 0x4e
     b16:	9f a1       	lds	r25, 0x4f
     b18:	fc 01       	movw	r30, r24
     b1a:	20 83       	st	Z, r18
     b1c:	31 83       	std	Z+1, r19	; 0x01
}
     b1e:	a9 96       	adiw	r28, 0x29	; 41
     b20:	cd bf       	out	0x3d, r28	; 61
     b22:	de bf       	out	0x3e, r29	; 62
     b24:	df 91       	pop	r29
     b26:	cf 91       	pop	r28
     b28:	1f 91       	pop	r17
     b2a:	0f 91       	pop	r16
     b2c:	08 95       	ret

00000b2e <ADCPower>:

void ADCPower(uint8_t on) {
     b2e:	0f 93       	push	r16
     b30:	1f 93       	push	r17
     b32:	cf 93       	push	r28
     b34:	df 93       	push	r29
     b36:	cd b7       	in	r28, 0x3d	; 61
     b38:	de b7       	in	r29, 0x3e	; 62
     b3a:	2f 97       	sbiw	r28, 0x0f	; 15
     b3c:	cd bf       	out	0x3d, r28	; 61
     b3e:	de bf       	out	0x3e, r29	; 62
     b40:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
     b42:	8f 85       	ldd	r24, Y+15	; 0x0f
     b44:	88 23       	and	r24, r24
     b46:	09 f4       	brne	.+2      	; 0xb4a <ADCPower+0x1c>
     b48:	ce c0       	rjmp	.+412    	; 0xce6 <ADCPower+0x1b8>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     b4a:	80 e0       	ldi	r24, 0x00	; 0
     b4c:	96 e0       	ldi	r25, 0x06	; 6
     b4e:	2e ed       	ldi	r18, 0xDE	; 222
     b50:	fc 01       	movw	r30, r24
     b52:	21 83       	std	Z+1, r18	; 0x01
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     b54:	80 e2       	ldi	r24, 0x20	; 32
     b56:	96 e0       	ldi	r25, 0x06	; 6
     b58:	2e e0       	ldi	r18, 0x0E	; 14
     b5a:	fc 01       	movw	r30, r24
     b5c:	21 83       	std	Z+1, r18	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     b5e:	80 e4       	ldi	r24, 0x40	; 64
     b60:	96 e0       	ldi	r25, 0x06	; 6
     b62:	23 e0       	ldi	r18, 0x03	; 3
     b64:	fc 01       	movw	r30, r24
     b66:	21 83       	std	Z+1, r18	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     b68:	80 e8       	ldi	r24, 0x80	; 128
     b6a:	96 e0       	ldi	r25, 0x06	; 6
     b6c:	20 e1       	ldi	r18, 0x10	; 16
     b6e:	fc 01       	movw	r30, r24
     b70:	21 83       	std	Z+1, r18	; 0x01
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     b72:	80 ea       	ldi	r24, 0xA0	; 160
     b74:	96 e0       	ldi	r25, 0x06	; 6
     b76:	2e e0       	ldi	r18, 0x0E	; 14
     b78:	fc 01       	movw	r30, r24
     b7a:	21 83       	std	Z+1, r18	; 0x01

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     b7c:	80 e0       	ldi	r24, 0x00	; 0
     b7e:	96 e0       	ldi	r25, 0x06	; 6
     b80:	2e e9       	ldi	r18, 0x9E	; 158
     b82:	fc 01       	movw	r30, r24
     b84:	25 83       	std	Z+5, r18	; 0x05
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     b86:	80 e2       	ldi	r24, 0x20	; 32
     b88:	96 e0       	ldi	r25, 0x06	; 6
     b8a:	28 e0       	ldi	r18, 0x08	; 8
     b8c:	fc 01       	movw	r30, r24
     b8e:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     b90:	80 e4       	ldi	r24, 0x40	; 64
     b92:	96 e0       	ldi	r25, 0x06	; 6
     b94:	23 e0       	ldi	r18, 0x03	; 3
     b96:	fc 01       	movw	r30, r24
     b98:	25 83       	std	Z+5, r18	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     b9a:	80 e8       	ldi	r24, 0x80	; 128
     b9c:	96 e0       	ldi	r25, 0x06	; 6
     b9e:	20 e1       	ldi	r18, 0x10	; 16
     ba0:	fc 01       	movw	r30, r24
     ba2:	25 83       	std	Z+5, r18	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     ba4:	80 ea       	ldi	r24, 0xA0	; 160
     ba6:	96 e0       	ldi	r25, 0x06	; 6
     ba8:	2e e0       	ldi	r18, 0x0E	; 14
     baa:	fc 01       	movw	r30, r24
     bac:	25 83       	std	Z+5, r18	; 0x05
		channelStatus = 0x00; // POR to zeros
     bae:	10 92 76 50 	sts	0x5076, r1
     bb2:	80 e0       	ldi	r24, 0x00	; 0
     bb4:	90 e0       	ldi	r25, 0x00	; 0
     bb6:	a8 ec       	ldi	r26, 0xC8	; 200
     bb8:	b2 e4       	ldi	r27, 0x42	; 66
     bba:	89 83       	std	Y+1, r24	; 0x01
     bbc:	9a 83       	std	Y+2, r25	; 0x02
     bbe:	ab 83       	std	Y+3, r26	; 0x03
     bc0:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     bc2:	69 81       	ldd	r22, Y+1	; 0x01
     bc4:	7a 81       	ldd	r23, Y+2	; 0x02
     bc6:	8b 81       	ldd	r24, Y+3	; 0x03
     bc8:	9c 81       	ldd	r25, Y+4	; 0x04
     bca:	20 e0       	ldi	r18, 0x00	; 0
     bcc:	30 e0       	ldi	r19, 0x00	; 0
     bce:	4a ef       	ldi	r20, 0xFA	; 250
     bd0:	55 e4       	ldi	r21, 0x45	; 69
     bd2:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
     bd6:	dc 01       	movw	r26, r24
     bd8:	cb 01       	movw	r24, r22
     bda:	8d 83       	std	Y+5, r24	; 0x05
     bdc:	9e 83       	std	Y+6, r25	; 0x06
     bde:	af 83       	std	Y+7, r26	; 0x07
     be0:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     be2:	11 e0       	ldi	r17, 0x01	; 1
     be4:	6d 81       	ldd	r22, Y+5	; 0x05
     be6:	7e 81       	ldd	r23, Y+6	; 0x06
     be8:	8f 81       	ldd	r24, Y+7	; 0x07
     bea:	98 85       	ldd	r25, Y+8	; 0x08
     bec:	20 e0       	ldi	r18, 0x00	; 0
     bee:	30 e0       	ldi	r19, 0x00	; 0
     bf0:	40 e8       	ldi	r20, 0x80	; 128
     bf2:	5f e3       	ldi	r21, 0x3F	; 63
     bf4:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
     bf8:	88 23       	and	r24, r24
     bfa:	0c f0       	brlt	.+2      	; 0xbfe <ADCPower+0xd0>
     bfc:	10 e0       	ldi	r17, 0x00	; 0
     bfe:	11 23       	and	r17, r17
     c00:	29 f0       	breq	.+10     	; 0xc0c <ADCPower+0xde>
		__ticks = 1;
     c02:	81 e0       	ldi	r24, 0x01	; 1
     c04:	90 e0       	ldi	r25, 0x00	; 0
     c06:	89 87       	std	Y+9, r24	; 0x09
     c08:	9a 87       	std	Y+10, r25	; 0x0a
     c0a:	46 c0       	rjmp	.+140    	; 0xc98 <ADCPower+0x16a>
	else if (__tmp > 65535)
     c0c:	11 e0       	ldi	r17, 0x01	; 1
     c0e:	6d 81       	ldd	r22, Y+5	; 0x05
     c10:	7e 81       	ldd	r23, Y+6	; 0x06
     c12:	8f 81       	ldd	r24, Y+7	; 0x07
     c14:	98 85       	ldd	r25, Y+8	; 0x08
     c16:	20 e0       	ldi	r18, 0x00	; 0
     c18:	3f ef       	ldi	r19, 0xFF	; 255
     c1a:	4f e7       	ldi	r20, 0x7F	; 127
     c1c:	57 e4       	ldi	r21, 0x47	; 71
     c1e:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
     c22:	18 16       	cp	r1, r24
     c24:	0c f0       	brlt	.+2      	; 0xc28 <ADCPower+0xfa>
     c26:	10 e0       	ldi	r17, 0x00	; 0
     c28:	11 23       	and	r17, r17
     c2a:	61 f1       	breq	.+88     	; 0xc84 <ADCPower+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     c2c:	69 81       	ldd	r22, Y+1	; 0x01
     c2e:	7a 81       	ldd	r23, Y+2	; 0x02
     c30:	8b 81       	ldd	r24, Y+3	; 0x03
     c32:	9c 81       	ldd	r25, Y+4	; 0x04
     c34:	20 e0       	ldi	r18, 0x00	; 0
     c36:	30 e0       	ldi	r19, 0x00	; 0
     c38:	40 e2       	ldi	r20, 0x20	; 32
     c3a:	51 e4       	ldi	r21, 0x41	; 65
     c3c:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
     c40:	dc 01       	movw	r26, r24
     c42:	cb 01       	movw	r24, r22
     c44:	bc 01       	movw	r22, r24
     c46:	cd 01       	movw	r24, r26
     c48:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
     c4c:	dc 01       	movw	r26, r24
     c4e:	cb 01       	movw	r24, r22
     c50:	89 87       	std	Y+9, r24	; 0x09
     c52:	9a 87       	std	Y+10, r25	; 0x0a
     c54:	12 c0       	rjmp	.+36     	; 0xc7a <ADCPower+0x14c>
     c56:	80 e2       	ldi	r24, 0x20	; 32
     c58:	93 e0       	ldi	r25, 0x03	; 3
     c5a:	8b 87       	std	Y+11, r24	; 0x0b
     c5c:	9c 87       	std	Y+12, r25	; 0x0c
     c5e:	8b 85       	ldd	r24, Y+11	; 0x0b
     c60:	9c 85       	ldd	r25, Y+12	; 0x0c
     c62:	8c 01       	movw	r16, r24
     c64:	c8 01       	movw	r24, r16
     c66:	01 97       	sbiw	r24, 0x01	; 1
     c68:	f1 f7       	brne	.-4      	; 0xc66 <ADCPower+0x138>
     c6a:	8c 01       	movw	r16, r24
     c6c:	0b 87       	std	Y+11, r16	; 0x0b
     c6e:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     c70:	89 85       	ldd	r24, Y+9	; 0x09
     c72:	9a 85       	ldd	r25, Y+10	; 0x0a
     c74:	01 97       	sbiw	r24, 0x01	; 1
     c76:	89 87       	std	Y+9, r24	; 0x09
     c78:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     c7a:	89 85       	ldd	r24, Y+9	; 0x09
     c7c:	9a 85       	ldd	r25, Y+10	; 0x0a
     c7e:	00 97       	sbiw	r24, 0x00	; 0
     c80:	51 f7       	brne	.-44     	; 0xc56 <ADCPower+0x128>
     c82:	17 c0       	rjmp	.+46     	; 0xcb2 <ADCPower+0x184>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     c84:	6d 81       	ldd	r22, Y+5	; 0x05
     c86:	7e 81       	ldd	r23, Y+6	; 0x06
     c88:	8f 81       	ldd	r24, Y+7	; 0x07
     c8a:	98 85       	ldd	r25, Y+8	; 0x08
     c8c:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
     c90:	dc 01       	movw	r26, r24
     c92:	cb 01       	movw	r24, r22
     c94:	89 87       	std	Y+9, r24	; 0x09
     c96:	9a 87       	std	Y+10, r25	; 0x0a
     c98:	89 85       	ldd	r24, Y+9	; 0x09
     c9a:	9a 85       	ldd	r25, Y+10	; 0x0a
     c9c:	8d 87       	std	Y+13, r24	; 0x0d
     c9e:	9e 87       	std	Y+14, r25	; 0x0e
     ca0:	8d 85       	ldd	r24, Y+13	; 0x0d
     ca2:	9e 85       	ldd	r25, Y+14	; 0x0e
     ca4:	8c 01       	movw	r16, r24
     ca6:	f8 01       	movw	r30, r16
     ca8:	31 97       	sbiw	r30, 0x01	; 1
     caa:	f1 f7       	brne	.-4      	; 0xca8 <ADCPower+0x17a>
     cac:	8f 01       	movw	r16, r30
     cae:	0d 87       	std	Y+13, r16	; 0x0d
     cb0:	1e 87       	std	Y+14, r17	; 0x0e
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     cb2:	80 e4       	ldi	r24, 0x40	; 64
     cb4:	96 e0       	ldi	r25, 0x06	; 6
     cb6:	20 e4       	ldi	r18, 0x40	; 64
     cb8:	fc 01       	movw	r30, r24
     cba:	22 83       	std	Z+2, r18	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     cbc:	80 e0       	ldi	r24, 0x00	; 0
     cbe:	80 93 77 50 	sts	0x5077, r24
     cc2:	80 93 ca 50 	sts	0x50CA, r24
     cc6:	80 93 c3 23 	sts	0x23C3, r24
     cca:	80 93 6f 50 	sts	0x506F, r24
		PortEx_DIRSET(0xFF, PS_BANKA);
     cce:	8f ef       	ldi	r24, 0xFF	; 255
     cd0:	61 e0       	ldi	r22, 0x01	; 1
     cd2:	0e 94 a8 33 	call	0x6750	; 0x6750 <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     cd6:	8f ef       	ldi	r24, 0xFF	; 255
     cd8:	61 e0       	ldi	r22, 0x01	; 1
     cda:	0e 94 74 34 	call	0x68e8	; 0x68e8 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     cde:	8f ef       	ldi	r24, 0xFF	; 255
     ce0:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <set_filter>
     ce4:	42 c0       	rjmp	.+132    	; 0xd6a <ADCPower+0x23c>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     ce6:	80 e0       	ldi	r24, 0x00	; 0
     ce8:	96 e0       	ldi	r25, 0x06	; 6
     cea:	2e ed       	ldi	r18, 0xDE	; 222
     cec:	fc 01       	movw	r30, r24
     cee:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     cf0:	80 e2       	ldi	r24, 0x20	; 32
     cf2:	96 e0       	ldi	r25, 0x06	; 6
     cf4:	2e e0       	ldi	r18, 0x0E	; 14
     cf6:	fc 01       	movw	r30, r24
     cf8:	26 83       	std	Z+6, r18	; 0x06
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     cfa:	80 e4       	ldi	r24, 0x40	; 64
     cfc:	96 e0       	ldi	r25, 0x06	; 6
     cfe:	23 e0       	ldi	r18, 0x03	; 3
     d00:	fc 01       	movw	r30, r24
     d02:	26 83       	std	Z+6, r18	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     d04:	80 e8       	ldi	r24, 0x80	; 128
     d06:	96 e0       	ldi	r25, 0x06	; 6
     d08:	20 e1       	ldi	r18, 0x10	; 16
     d0a:	fc 01       	movw	r30, r24
     d0c:	26 83       	std	Z+6, r18	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     d0e:	80 ea       	ldi	r24, 0xA0	; 160
     d10:	96 e0       	ldi	r25, 0x06	; 6
     d12:	2e e0       	ldi	r18, 0x0E	; 14
     d14:	fc 01       	movw	r30, r24
     d16:	26 83       	std	Z+6, r18	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     d18:	80 e0       	ldi	r24, 0x00	; 0
     d1a:	96 e0       	ldi	r25, 0x06	; 6
     d1c:	2e ed       	ldi	r18, 0xDE	; 222
     d1e:	fc 01       	movw	r30, r24
     d20:	22 83       	std	Z+2, r18	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     d22:	80 e2       	ldi	r24, 0x20	; 32
     d24:	96 e0       	ldi	r25, 0x06	; 6
     d26:	2e e0       	ldi	r18, 0x0E	; 14
     d28:	fc 01       	movw	r30, r24
     d2a:	22 83       	std	Z+2, r18	; 0x02
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     d2c:	80 e4       	ldi	r24, 0x40	; 64
     d2e:	96 e0       	ldi	r25, 0x06	; 6
     d30:	23 e0       	ldi	r18, 0x03	; 3
     d32:	fc 01       	movw	r30, r24
     d34:	22 83       	std	Z+2, r18	; 0x02
		PORTE.DIRCLR = PIN4_bm;
     d36:	80 e8       	ldi	r24, 0x80	; 128
     d38:	96 e0       	ldi	r25, 0x06	; 6
     d3a:	20 e1       	ldi	r18, 0x10	; 16
     d3c:	fc 01       	movw	r30, r24
     d3e:	22 83       	std	Z+2, r18	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     d40:	80 ea       	ldi	r24, 0xA0	; 160
     d42:	96 e0       	ldi	r25, 0x06	; 6
     d44:	2e e0       	ldi	r18, 0x0E	; 14
     d46:	fc 01       	movw	r30, r24
     d48:	22 83       	std	Z+2, r18	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     d4a:	80 e4       	ldi	r24, 0x40	; 64
     d4c:	96 e0       	ldi	r25, 0x06	; 6
     d4e:	20 e4       	ldi	r18, 0x40	; 64
     d50:	fc 01       	movw	r30, r24
     d52:	22 83       	std	Z+2, r18	; 0x02
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     d54:	80 e0       	ldi	r24, 0x00	; 0
     d56:	80 93 77 50 	sts	0x5077, r24
     d5a:	80 93 ca 50 	sts	0x50CA, r24
     d5e:	80 93 c3 23 	sts	0x23C3, r24
     d62:	80 93 6f 50 	sts	0x506F, r24
		channelStatus = 0x00;
     d66:	10 92 76 50 	sts	0x5076, r1
		
	}
}
     d6a:	2f 96       	adiw	r28, 0x0f	; 15
     d6c:	cd bf       	out	0x3d, r28	; 61
     d6e:	de bf       	out	0x3e, r29	; 62
     d70:	df 91       	pop	r29
     d72:	cf 91       	pop	r28
     d74:	1f 91       	pop	r17
     d76:	0f 91       	pop	r16
     d78:	08 95       	ret

00000d7a <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     d7a:	0f 93       	push	r16
     d7c:	1f 93       	push	r17
     d7e:	cf 93       	push	r28
     d80:	df 93       	push	r29
     d82:	cd b7       	in	r28, 0x3d	; 61
     d84:	de b7       	in	r29, 0x3e	; 62
     d86:	6a 97       	sbiw	r28, 0x1a	; 26
     d88:	cd bf       	out	0x3d, r28	; 61
     d8a:	de bf       	out	0x3e, r29	; 62
     d8c:	89 8f       	std	Y+25, r24	; 0x19
     d8e:	6a 8f       	std	Y+26, r22	; 0x1a
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     d90:	89 8d       	ldd	r24, Y+25	; 0x19
     d92:	28 2f       	mov	r18, r24
     d94:	30 e0       	ldi	r19, 0x00	; 0
     d96:	81 e0       	ldi	r24, 0x01	; 1
     d98:	90 e0       	ldi	r25, 0x00	; 0
     d9a:	02 c0       	rjmp	.+4      	; 0xda0 <set_ampGain+0x26>
     d9c:	88 0f       	add	r24, r24
     d9e:	99 1f       	adc	r25, r25
     da0:	2a 95       	dec	r18
     da2:	e2 f7       	brpl	.-8      	; 0xd9c <set_ampGain+0x22>
     da4:	61 e0       	ldi	r22, 0x01	; 1
     da6:	0e 94 d7 34 	call	0x69ae	; 0x69ae <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     daa:	8a 8d       	ldd	r24, Y+26	; 0x1a
     dac:	88 2f       	mov	r24, r24
     dae:	90 e0       	ldi	r25, 0x00	; 0
     db0:	81 70       	andi	r24, 0x01	; 1
     db2:	90 70       	andi	r25, 0x00	; 0
     db4:	88 23       	and	r24, r24
     db6:	31 f0       	breq	.+12     	; 0xdc4 <set_ampGain+0x4a>
     db8:	80 e0       	ldi	r24, 0x00	; 0
     dba:	96 e0       	ldi	r25, 0x06	; 6
     dbc:	20 e4       	ldi	r18, 0x40	; 64
     dbe:	fc 01       	movw	r30, r24
     dc0:	25 83       	std	Z+5, r18	; 0x05
     dc2:	05 c0       	rjmp	.+10     	; 0xdce <set_ampGain+0x54>
	else {PORTA.OUTCLR = PIN6_bm;}
     dc4:	80 e0       	ldi	r24, 0x00	; 0
     dc6:	96 e0       	ldi	r25, 0x06	; 6
     dc8:	20 e4       	ldi	r18, 0x40	; 64
     dca:	fc 01       	movw	r30, r24
     dcc:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     dce:	8a 8d       	ldd	r24, Y+26	; 0x1a
     dd0:	88 2f       	mov	r24, r24
     dd2:	90 e0       	ldi	r25, 0x00	; 0
     dd4:	82 70       	andi	r24, 0x02	; 2
     dd6:	90 70       	andi	r25, 0x00	; 0
     dd8:	00 97       	sbiw	r24, 0x00	; 0
     dda:	31 f0       	breq	.+12     	; 0xde8 <set_ampGain+0x6e>
     ddc:	80 e2       	ldi	r24, 0x20	; 32
     dde:	96 e0       	ldi	r25, 0x06	; 6
     de0:	22 e0       	ldi	r18, 0x02	; 2
     de2:	fc 01       	movw	r30, r24
     de4:	25 83       	std	Z+5, r18	; 0x05
     de6:	05 c0       	rjmp	.+10     	; 0xdf2 <set_ampGain+0x78>
	else {PORTB.OUTCLR = PIN1_bm;}
     de8:	80 e2       	ldi	r24, 0x20	; 32
     dea:	96 e0       	ldi	r25, 0x06	; 6
     dec:	22 e0       	ldi	r18, 0x02	; 2
     dee:	fc 01       	movw	r30, r24
     df0:	26 83       	std	Z+6, r18	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     df2:	8a 8d       	ldd	r24, Y+26	; 0x1a
     df4:	88 2f       	mov	r24, r24
     df6:	90 e0       	ldi	r25, 0x00	; 0
     df8:	84 70       	andi	r24, 0x04	; 4
     dfa:	90 70       	andi	r25, 0x00	; 0
     dfc:	00 97       	sbiw	r24, 0x00	; 0
     dfe:	31 f0       	breq	.+12     	; 0xe0c <set_ampGain+0x92>
     e00:	80 e2       	ldi	r24, 0x20	; 32
     e02:	96 e0       	ldi	r25, 0x06	; 6
     e04:	24 e0       	ldi	r18, 0x04	; 4
     e06:	fc 01       	movw	r30, r24
     e08:	25 83       	std	Z+5, r18	; 0x05
     e0a:	05 c0       	rjmp	.+10     	; 0xe16 <set_ampGain+0x9c>
	else {PORTB.OUTCLR = PIN2_bm;}
     e0c:	80 e2       	ldi	r24, 0x20	; 32
     e0e:	96 e0       	ldi	r25, 0x06	; 6
     e10:	24 e0       	ldi	r18, 0x04	; 4
     e12:	fc 01       	movw	r30, r24
     e14:	26 83       	std	Z+6, r18	; 0x06
     e16:	80 e0       	ldi	r24, 0x00	; 0
     e18:	90 e0       	ldi	r25, 0x00	; 0
     e1a:	a0 e8       	ldi	r26, 0x80	; 128
     e1c:	bf e3       	ldi	r27, 0x3F	; 63
     e1e:	89 83       	std	Y+1, r24	; 0x01
     e20:	9a 83       	std	Y+2, r25	; 0x02
     e22:	ab 83       	std	Y+3, r26	; 0x03
     e24:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
     e26:	69 81       	ldd	r22, Y+1	; 0x01
     e28:	7a 81       	ldd	r23, Y+2	; 0x02
     e2a:	8b 81       	ldd	r24, Y+3	; 0x03
     e2c:	9c 81       	ldd	r25, Y+4	; 0x04
     e2e:	2b ea       	ldi	r18, 0xAB	; 171
     e30:	3a ea       	ldi	r19, 0xAA	; 170
     e32:	4a e2       	ldi	r20, 0x2A	; 42
     e34:	51 e4       	ldi	r21, 0x41	; 65
     e36:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
     e3a:	dc 01       	movw	r26, r24
     e3c:	cb 01       	movw	r24, r22
     e3e:	8d 83       	std	Y+5, r24	; 0x05
     e40:	9e 83       	std	Y+6, r25	; 0x06
     e42:	af 83       	std	Y+7, r26	; 0x07
     e44:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     e46:	11 e0       	ldi	r17, 0x01	; 1
     e48:	6d 81       	ldd	r22, Y+5	; 0x05
     e4a:	7e 81       	ldd	r23, Y+6	; 0x06
     e4c:	8f 81       	ldd	r24, Y+7	; 0x07
     e4e:	98 85       	ldd	r25, Y+8	; 0x08
     e50:	20 e0       	ldi	r18, 0x00	; 0
     e52:	30 e0       	ldi	r19, 0x00	; 0
     e54:	40 e8       	ldi	r20, 0x80	; 128
     e56:	5f e3       	ldi	r21, 0x3F	; 63
     e58:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
     e5c:	88 23       	and	r24, r24
     e5e:	0c f0       	brlt	.+2      	; 0xe62 <set_ampGain+0xe8>
     e60:	10 e0       	ldi	r17, 0x00	; 0
     e62:	11 23       	and	r17, r17
     e64:	19 f0       	breq	.+6      	; 0xe6c <set_ampGain+0xf2>
		__ticks = 1;
     e66:	81 e0       	ldi	r24, 0x01	; 1
     e68:	89 87       	std	Y+9, r24	; 0x09
     e6a:	a3 c0       	rjmp	.+326    	; 0xfb2 <set_ampGain+0x238>
	else if (__tmp > 255)
     e6c:	11 e0       	ldi	r17, 0x01	; 1
     e6e:	6d 81       	ldd	r22, Y+5	; 0x05
     e70:	7e 81       	ldd	r23, Y+6	; 0x06
     e72:	8f 81       	ldd	r24, Y+7	; 0x07
     e74:	98 85       	ldd	r25, Y+8	; 0x08
     e76:	20 e0       	ldi	r18, 0x00	; 0
     e78:	30 e0       	ldi	r19, 0x00	; 0
     e7a:	4f e7       	ldi	r20, 0x7F	; 127
     e7c:	53 e4       	ldi	r21, 0x43	; 67
     e7e:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
     e82:	18 16       	cp	r1, r24
     e84:	0c f0       	brlt	.+2      	; 0xe88 <set_ampGain+0x10e>
     e86:	10 e0       	ldi	r17, 0x00	; 0
     e88:	11 23       	and	r17, r17
     e8a:	09 f4       	brne	.+2      	; 0xe8e <set_ampGain+0x114>
     e8c:	89 c0       	rjmp	.+274    	; 0xfa0 <set_ampGain+0x226>
	{
		_delay_ms(__us / 1000.0);
     e8e:	69 81       	ldd	r22, Y+1	; 0x01
     e90:	7a 81       	ldd	r23, Y+2	; 0x02
     e92:	8b 81       	ldd	r24, Y+3	; 0x03
     e94:	9c 81       	ldd	r25, Y+4	; 0x04
     e96:	20 e0       	ldi	r18, 0x00	; 0
     e98:	30 e0       	ldi	r19, 0x00	; 0
     e9a:	4a e7       	ldi	r20, 0x7A	; 122
     e9c:	54 e4       	ldi	r21, 0x44	; 68
     e9e:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
     ea2:	dc 01       	movw	r26, r24
     ea4:	cb 01       	movw	r24, r22
     ea6:	8a 87       	std	Y+10, r24	; 0x0a
     ea8:	9b 87       	std	Y+11, r25	; 0x0b
     eaa:	ac 87       	std	Y+12, r26	; 0x0c
     eac:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     eae:	6a 85       	ldd	r22, Y+10	; 0x0a
     eb0:	7b 85       	ldd	r23, Y+11	; 0x0b
     eb2:	8c 85       	ldd	r24, Y+12	; 0x0c
     eb4:	9d 85       	ldd	r25, Y+13	; 0x0d
     eb6:	20 e0       	ldi	r18, 0x00	; 0
     eb8:	30 e0       	ldi	r19, 0x00	; 0
     eba:	4a ef       	ldi	r20, 0xFA	; 250
     ebc:	55 e4       	ldi	r21, 0x45	; 69
     ebe:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
     ec2:	dc 01       	movw	r26, r24
     ec4:	cb 01       	movw	r24, r22
     ec6:	8e 87       	std	Y+14, r24	; 0x0e
     ec8:	9f 87       	std	Y+15, r25	; 0x0f
     eca:	a8 8b       	std	Y+16, r26	; 0x10
     ecc:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
     ece:	11 e0       	ldi	r17, 0x01	; 1
     ed0:	6e 85       	ldd	r22, Y+14	; 0x0e
     ed2:	7f 85       	ldd	r23, Y+15	; 0x0f
     ed4:	88 89       	ldd	r24, Y+16	; 0x10
     ed6:	99 89       	ldd	r25, Y+17	; 0x11
     ed8:	20 e0       	ldi	r18, 0x00	; 0
     eda:	30 e0       	ldi	r19, 0x00	; 0
     edc:	40 e8       	ldi	r20, 0x80	; 128
     ede:	5f e3       	ldi	r21, 0x3F	; 63
     ee0:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
     ee4:	88 23       	and	r24, r24
     ee6:	0c f0       	brlt	.+2      	; 0xeea <set_ampGain+0x170>
     ee8:	10 e0       	ldi	r17, 0x00	; 0
     eea:	11 23       	and	r17, r17
     eec:	29 f0       	breq	.+10     	; 0xef8 <set_ampGain+0x17e>
		__ticks = 1;
     eee:	81 e0       	ldi	r24, 0x01	; 1
     ef0:	90 e0       	ldi	r25, 0x00	; 0
     ef2:	8a 8b       	std	Y+18, r24	; 0x12
     ef4:	9b 8b       	std	Y+19, r25	; 0x13
     ef6:	46 c0       	rjmp	.+140    	; 0xf84 <set_ampGain+0x20a>
	else if (__tmp > 65535)
     ef8:	11 e0       	ldi	r17, 0x01	; 1
     efa:	6e 85       	ldd	r22, Y+14	; 0x0e
     efc:	7f 85       	ldd	r23, Y+15	; 0x0f
     efe:	88 89       	ldd	r24, Y+16	; 0x10
     f00:	99 89       	ldd	r25, Y+17	; 0x11
     f02:	20 e0       	ldi	r18, 0x00	; 0
     f04:	3f ef       	ldi	r19, 0xFF	; 255
     f06:	4f e7       	ldi	r20, 0x7F	; 127
     f08:	57 e4       	ldi	r21, 0x47	; 71
     f0a:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
     f0e:	18 16       	cp	r1, r24
     f10:	0c f0       	brlt	.+2      	; 0xf14 <set_ampGain+0x19a>
     f12:	10 e0       	ldi	r17, 0x00	; 0
     f14:	11 23       	and	r17, r17
     f16:	61 f1       	breq	.+88     	; 0xf70 <set_ampGain+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     f18:	6a 85       	ldd	r22, Y+10	; 0x0a
     f1a:	7b 85       	ldd	r23, Y+11	; 0x0b
     f1c:	8c 85       	ldd	r24, Y+12	; 0x0c
     f1e:	9d 85       	ldd	r25, Y+13	; 0x0d
     f20:	20 e0       	ldi	r18, 0x00	; 0
     f22:	30 e0       	ldi	r19, 0x00	; 0
     f24:	40 e2       	ldi	r20, 0x20	; 32
     f26:	51 e4       	ldi	r21, 0x41	; 65
     f28:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
     f2c:	dc 01       	movw	r26, r24
     f2e:	cb 01       	movw	r24, r22
     f30:	bc 01       	movw	r22, r24
     f32:	cd 01       	movw	r24, r26
     f34:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
     f38:	dc 01       	movw	r26, r24
     f3a:	cb 01       	movw	r24, r22
     f3c:	8a 8b       	std	Y+18, r24	; 0x12
     f3e:	9b 8b       	std	Y+19, r25	; 0x13
     f40:	12 c0       	rjmp	.+36     	; 0xf66 <set_ampGain+0x1ec>
     f42:	80 e2       	ldi	r24, 0x20	; 32
     f44:	93 e0       	ldi	r25, 0x03	; 3
     f46:	8c 8b       	std	Y+20, r24	; 0x14
     f48:	9d 8b       	std	Y+21, r25	; 0x15
     f4a:	8c 89       	ldd	r24, Y+20	; 0x14
     f4c:	9d 89       	ldd	r25, Y+21	; 0x15
     f4e:	8c 01       	movw	r16, r24
     f50:	c8 01       	movw	r24, r16
     f52:	01 97       	sbiw	r24, 0x01	; 1
     f54:	f1 f7       	brne	.-4      	; 0xf52 <set_ampGain+0x1d8>
     f56:	8c 01       	movw	r16, r24
     f58:	0c 8b       	std	Y+20, r16	; 0x14
     f5a:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f5c:	8a 89       	ldd	r24, Y+18	; 0x12
     f5e:	9b 89       	ldd	r25, Y+19	; 0x13
     f60:	01 97       	sbiw	r24, 0x01	; 1
     f62:	8a 8b       	std	Y+18, r24	; 0x12
     f64:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f66:	8a 89       	ldd	r24, Y+18	; 0x12
     f68:	9b 89       	ldd	r25, Y+19	; 0x13
     f6a:	00 97       	sbiw	r24, 0x00	; 0
     f6c:	51 f7       	brne	.-44     	; 0xf42 <set_ampGain+0x1c8>
     f6e:	28 c0       	rjmp	.+80     	; 0xfc0 <set_ampGain+0x246>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     f70:	6e 85       	ldd	r22, Y+14	; 0x0e
     f72:	7f 85       	ldd	r23, Y+15	; 0x0f
     f74:	88 89       	ldd	r24, Y+16	; 0x10
     f76:	99 89       	ldd	r25, Y+17	; 0x11
     f78:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
     f7c:	dc 01       	movw	r26, r24
     f7e:	cb 01       	movw	r24, r22
     f80:	8a 8b       	std	Y+18, r24	; 0x12
     f82:	9b 8b       	std	Y+19, r25	; 0x13
     f84:	8a 89       	ldd	r24, Y+18	; 0x12
     f86:	9b 89       	ldd	r25, Y+19	; 0x13
     f88:	8e 8b       	std	Y+22, r24	; 0x16
     f8a:	9f 8b       	std	Y+23, r25	; 0x17
     f8c:	8e 89       	ldd	r24, Y+22	; 0x16
     f8e:	9f 89       	ldd	r25, Y+23	; 0x17
     f90:	8c 01       	movw	r16, r24
     f92:	f8 01       	movw	r30, r16
     f94:	31 97       	sbiw	r30, 0x01	; 1
     f96:	f1 f7       	brne	.-4      	; 0xf94 <set_ampGain+0x21a>
     f98:	8f 01       	movw	r16, r30
     f9a:	0e 8b       	std	Y+22, r16	; 0x16
     f9c:	1f 8b       	std	Y+23, r17	; 0x17
     f9e:	10 c0       	rjmp	.+32     	; 0xfc0 <set_ampGain+0x246>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
     fa0:	6d 81       	ldd	r22, Y+5	; 0x05
     fa2:	7e 81       	ldd	r23, Y+6	; 0x06
     fa4:	8f 81       	ldd	r24, Y+7	; 0x07
     fa6:	98 85       	ldd	r25, Y+8	; 0x08
     fa8:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
     fac:	dc 01       	movw	r26, r24
     fae:	cb 01       	movw	r24, r22
     fb0:	89 87       	std	Y+9, r24	; 0x09
     fb2:	89 85       	ldd	r24, Y+9	; 0x09
     fb4:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     fb6:	88 8d       	ldd	r24, Y+24	; 0x18
     fb8:	18 2f       	mov	r17, r24
     fba:	1a 95       	dec	r17
     fbc:	f1 f7       	brne	.-4      	; 0xfba <set_ampGain+0x240>
     fbe:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
     fc0:	8f ef       	ldi	r24, 0xFF	; 255
     fc2:	61 e0       	ldi	r22, 0x01	; 1
     fc4:	0e 94 74 34 	call	0x68e8	; 0x68e8 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
     fc8:	6a 96       	adiw	r28, 0x1a	; 26
     fca:	cd bf       	out	0x3d, r28	; 61
     fcc:	de bf       	out	0x3e, r29	; 62
     fce:	df 91       	pop	r29
     fd0:	cf 91       	pop	r28
     fd2:	1f 91       	pop	r17
     fd4:	0f 91       	pop	r16
     fd6:	08 95       	ret

00000fd8 <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     fd8:	cf 93       	push	r28
     fda:	df 93       	push	r29
     fdc:	00 d0       	rcall	.+0      	; 0xfde <set_filter+0x6>
     fde:	cd b7       	in	r28, 0x3d	; 61
     fe0:	de b7       	in	r29, 0x3e	; 62
     fe2:	8b 83       	std	Y+3, r24	; 0x03
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     fe4:	8b 81       	ldd	r24, Y+3	; 0x03
     fe6:	83 70       	andi	r24, 0x03	; 3
     fe8:	89 83       	std	Y+1, r24	; 0x01
	uint8_t upperCS = filterConfig & 0x0C;
     fea:	8b 81       	ldd	r24, Y+3	; 0x03
     fec:	8c 70       	andi	r24, 0x0C	; 12
     fee:	8a 83       	std	Y+2, r24	; 0x02

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     ff0:	8b 81       	ldd	r24, Y+3	; 0x03
     ff2:	88 2f       	mov	r24, r24
     ff4:	90 e0       	ldi	r25, 0x00	; 0
     ff6:	85 70       	andi	r24, 0x05	; 5
     ff8:	90 70       	andi	r25, 0x00	; 0
     ffa:	00 97       	sbiw	r24, 0x00	; 0
     ffc:	51 f0       	breq	.+20     	; 0x1012 <set_filter+0x3a>
     ffe:	80 91 76 50 	lds	r24, 0x5076
    1002:	98 2f       	mov	r25, r24
    1004:	90 7f       	andi	r25, 0xF0	; 240
    1006:	8b 81       	ldd	r24, Y+3	; 0x03
    1008:	82 95       	swap	r24
    100a:	8f 70       	andi	r24, 0x0F	; 15
    100c:	89 2b       	or	r24, r25
    100e:	80 93 76 50 	sts	0x5076, r24
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
    1012:	8b 81       	ldd	r24, Y+3	; 0x03
    1014:	88 2f       	mov	r24, r24
    1016:	90 e0       	ldi	r25, 0x00	; 0
    1018:	8a 70       	andi	r24, 0x0A	; 10
    101a:	90 70       	andi	r25, 0x00	; 0
    101c:	00 97       	sbiw	r24, 0x00	; 0
    101e:	49 f0       	breq	.+18     	; 0x1032 <set_filter+0x5a>
    1020:	8b 81       	ldd	r24, Y+3	; 0x03
    1022:	98 2f       	mov	r25, r24
    1024:	90 7f       	andi	r25, 0xF0	; 240
    1026:	80 91 76 50 	lds	r24, 0x5076
    102a:	8f 70       	andi	r24, 0x0F	; 15
    102c:	89 2b       	or	r24, r25
    102e:	80 93 76 50 	sts	0x5076, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
    1032:	84 e0       	ldi	r24, 0x04	; 4
    1034:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
    1038:	80 91 76 50 	lds	r24, 0x5076
    103c:	80 93 5a 50 	sts	0x505A, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
    1040:	89 81       	ldd	r24, Y+1	; 0x01
    1042:	88 23       	and	r24, r24
    1044:	19 f0       	breq	.+6      	; 0x104c <set_filter+0x74>
    1046:	81 e0       	ldi	r24, 0x01	; 1
    1048:	0e 94 14 38 	call	0x7028	; 0x7028 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
    104c:	8a 81       	ldd	r24, Y+2	; 0x02
    104e:	88 23       	and	r24, r24
    1050:	19 f0       	breq	.+6      	; 0x1058 <set_filter+0x80>
    1052:	81 e0       	ldi	r24, 0x01	; 1
    1054:	0e 94 2c 38 	call	0x7058	; 0x7058 <upperMuxCS>

	SPICS(TRUE);
    1058:	81 e0       	ldi	r24, 0x01	; 1
    105a:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
    105e:	80 ec       	ldi	r24, 0xC0	; 192
    1060:	98 e0       	ldi	r25, 0x08	; 8
    1062:	2f ef       	ldi	r18, 0xFF	; 255
    1064:	fc 01       	movw	r30, r24
    1066:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1068:	00 00       	nop
    106a:	80 ec       	ldi	r24, 0xC0	; 192
    106c:	98 e0       	ldi	r25, 0x08	; 8
    106e:	fc 01       	movw	r30, r24
    1070:	82 81       	ldd	r24, Z+2	; 0x02
    1072:	88 23       	and	r24, r24
    1074:	d4 f7       	brge	.-12     	; 0x106a <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
    1076:	80 ec       	ldi	r24, 0xC0	; 192
    1078:	98 e0       	ldi	r25, 0x08	; 8
    107a:	fc 01       	movw	r30, r24
    107c:	83 81       	ldd	r24, Z+3	; 0x03
    107e:	80 93 66 50 	sts	0x5066, r24

	nop();
    1082:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
    1084:	80 ec       	ldi	r24, 0xC0	; 192
    1086:	98 e0       	ldi	r25, 0x08	; 8
    1088:	20 91 5a 50 	lds	r18, 0x505A
    108c:	fc 01       	movw	r30, r24
    108e:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1090:	00 00       	nop
    1092:	80 ec       	ldi	r24, 0xC0	; 192
    1094:	98 e0       	ldi	r25, 0x08	; 8
    1096:	fc 01       	movw	r30, r24
    1098:	82 81       	ldd	r24, Z+2	; 0x02
    109a:	88 23       	and	r24, r24
    109c:	d4 f7       	brge	.-12     	; 0x1092 <set_filter+0xba>
	SPIBuffer[12] = SPIC.DATA;
    109e:	80 ec       	ldi	r24, 0xC0	; 192
    10a0:	98 e0       	ldi	r25, 0x08	; 8
    10a2:	fc 01       	movw	r30, r24
    10a4:	83 81       	ldd	r24, Z+3	; 0x03
    10a6:	80 93 66 50 	sts	0x5066, r24
	SPICS(FALSE);
    10aa:	80 e0       	ldi	r24, 0x00	; 0
    10ac:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
    10b0:	89 81       	ldd	r24, Y+1	; 0x01
    10b2:	88 23       	and	r24, r24
    10b4:	19 f0       	breq	.+6      	; 0x10bc <set_filter+0xe4>
    10b6:	80 e0       	ldi	r24, 0x00	; 0
    10b8:	0e 94 14 38 	call	0x7028	; 0x7028 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
    10bc:	8a 81       	ldd	r24, Y+2	; 0x02
    10be:	88 23       	and	r24, r24
    10c0:	19 f0       	breq	.+6      	; 0x10c8 <set_filter+0xf0>
    10c2:	80 e0       	ldi	r24, 0x00	; 0
    10c4:	0e 94 2c 38 	call	0x7058	; 0x7058 <upperMuxCS>
	SPIDisable();
    10c8:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>
}
    10cc:	23 96       	adiw	r28, 0x03	; 3
    10ce:	cd bf       	out	0x3d, r28	; 61
    10d0:	de bf       	out	0x3e, r29	; 62
    10d2:	df 91       	pop	r29
    10d4:	cf 91       	pop	r28
    10d6:	08 95       	ret

000010d8 <enableADCMUX>:

void enableADCMUX(uint8_t on) {
    10d8:	cf 93       	push	r28
    10da:	df 93       	push	r29
    10dc:	0f 92       	push	r0
    10de:	cd b7       	in	r28, 0x3d	; 61
    10e0:	de b7       	in	r29, 0x3e	; 62
    10e2:	89 83       	std	Y+1, r24	; 0x01
	if(on) {
    10e4:	89 81       	ldd	r24, Y+1	; 0x01
    10e6:	88 23       	and	r24, r24
    10e8:	59 f0       	breq	.+22     	; 0x1100 <enableADCMUX+0x28>
		PORTA.DIRSET = PIN5_bm;
    10ea:	80 e0       	ldi	r24, 0x00	; 0
    10ec:	96 e0       	ldi	r25, 0x06	; 6
    10ee:	20 e2       	ldi	r18, 0x20	; 32
    10f0:	fc 01       	movw	r30, r24
    10f2:	21 83       	std	Z+1, r18	; 0x01
		PORTA.OUTSET = PIN5_bm;
    10f4:	80 e0       	ldi	r24, 0x00	; 0
    10f6:	96 e0       	ldi	r25, 0x06	; 6
    10f8:	20 e2       	ldi	r18, 0x20	; 32
    10fa:	fc 01       	movw	r30, r24
    10fc:	25 83       	std	Z+5, r18	; 0x05
    10fe:	0a c0       	rjmp	.+20     	; 0x1114 <enableADCMUX+0x3c>
	} else {
		PORTA.OUTCLR = PIN5_bm;
    1100:	80 e0       	ldi	r24, 0x00	; 0
    1102:	96 e0       	ldi	r25, 0x06	; 6
    1104:	20 e2       	ldi	r18, 0x20	; 32
    1106:	fc 01       	movw	r30, r24
    1108:	26 83       	std	Z+6, r18	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    110a:	80 e0       	ldi	r24, 0x00	; 0
    110c:	96 e0       	ldi	r25, 0x06	; 6
    110e:	20 e2       	ldi	r18, 0x20	; 32
    1110:	fc 01       	movw	r30, r24
    1112:	22 83       	std	Z+2, r18	; 0x02
	}
}
    1114:	0f 90       	pop	r0
    1116:	df 91       	pop	r29
    1118:	cf 91       	pop	r28
    111a:	08 95       	ret

0000111c <CO_collectADC>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent, uint32_t numOfSamples, int32_t* DataArray) {
    111c:	cf 92       	push	r12
    111e:	df 92       	push	r13
    1120:	ef 92       	push	r14
    1122:	ff 92       	push	r15
    1124:	0f 93       	push	r16
    1126:	1f 93       	push	r17
    1128:	cf 93       	push	r28
    112a:	df 93       	push	r29
    112c:	cd b7       	in	r28, 0x3d	; 61
    112e:	de b7       	in	r29, 0x3e	; 62
    1130:	2c 97       	sbiw	r28, 0x0c	; 12
    1132:	cd bf       	out	0x3d, r28	; 61
    1134:	de bf       	out	0x3e, r29	; 62
    1136:	8b 83       	std	Y+3, r24	; 0x03
    1138:	6c 83       	std	Y+4, r22	; 0x04
    113a:	4d 83       	std	Y+5, r20	; 0x05
    113c:	2e 83       	std	Y+6, r18	; 0x06
    113e:	ef 82       	std	Y+7, r14	; 0x07
    1140:	f8 86       	std	Y+8, r15	; 0x08
    1142:	09 87       	std	Y+9, r16	; 0x09
    1144:	1a 87       	std	Y+10, r17	; 0x0a
    1146:	cb 86       	std	Y+11, r12	; 0x0b
    1148:	dc 86       	std	Y+12, r13	; 0x0c


	uint16_t period;
	ADC_BUFFER = DataArray;
    114a:	8b 85       	ldd	r24, Y+11	; 0x0b
    114c:	9c 85       	ldd	r25, Y+12	; 0x0c
    114e:	80 93 67 50 	sts	0x5067, r24
    1152:	90 93 68 50 	sts	0x5068, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1156:	81 e0       	ldi	r24, 0x01	; 1
    1158:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    115c:	8b 81       	ldd	r24, Y+3	; 0x03
    115e:	6d 81       	ldd	r22, Y+5	; 0x05
    1160:	0e 94 bd 06 	call	0xd7a	; 0xd7a <set_ampGain>
	set_filter(filterConfig);
    1164:	8c 81       	ldd	r24, Y+4	; 0x04
    1166:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    116a:	8b 81       	ldd	r24, Y+3	; 0x03
    116c:	85 30       	cpi	r24, 0x05	; 5
    116e:	31 f0       	breq	.+12     	; 0x117c <CO_collectADC+0x60>
    1170:	8b 81       	ldd	r24, Y+3	; 0x03
    1172:	86 30       	cpi	r24, 0x06	; 6
    1174:	19 f0       	breq	.+6      	; 0x117c <CO_collectADC+0x60>
    1176:	8b 81       	ldd	r24, Y+3	; 0x03
    1178:	87 30       	cpi	r24, 0x07	; 7
    117a:	19 f4       	brne	.+6      	; 0x1182 <CO_collectADC+0x66>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    117c:	81 e0       	ldi	r24, 0x01	; 1
    117e:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    1182:	81 e0       	ldi	r24, 0x01	; 1
    1184:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <enableADCMUX>
	setADCInput(channel);
    1188:	8b 81       	ldd	r24, Y+3	; 0x03
    118a:	0e 94 de 1a 	call	0x35bc	; 0x35bc <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    118e:	84 e0       	ldi	r24, 0x04	; 4
    1190:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1194:	80 ec       	ldi	r24, 0xC0	; 192
    1196:	98 e0       	ldi	r25, 0x08	; 8
    1198:	24 e5       	ldi	r18, 0x54	; 84
    119a:	fc 01       	movw	r30, r24
    119c:	20 83       	st	Z, r18
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    119e:	80 ea       	ldi	r24, 0xA0	; 160
    11a0:	96 e0       	ldi	r25, 0x06	; 6
    11a2:	21 e0       	ldi	r18, 0x01	; 1
    11a4:	fc 01       	movw	r30, r24
    11a6:	22 83       	std	Z+2, r18	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    11a8:	80 ea       	ldi	r24, 0xA0	; 160
    11aa:	96 e0       	ldi	r25, 0x06	; 6
    11ac:	22 e0       	ldi	r18, 0x02	; 2
    11ae:	fc 01       	movw	r30, r24
    11b0:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    11b2:	80 ea       	ldi	r24, 0xA0	; 160
    11b4:	96 e0       	ldi	r25, 0x06	; 6
    11b6:	21 e0       	ldi	r18, 0x01	; 1
    11b8:	fc 01       	movw	r30, r24
    11ba:	22 87       	std	Z+10, r18	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_LO_gc;				
    11bc:	80 ea       	ldi	r24, 0xA0	; 160
    11be:	96 e0       	ldi	r25, 0x06	; 6
    11c0:	21 e0       	ldi	r18, 0x01	; 1
    11c2:	fc 01       	movw	r30, r24
    11c4:	21 87       	std	Z+9, r18	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    11c6:	80 e8       	ldi	r24, 0x80	; 128
    11c8:	96 e0       	ldi	r25, 0x06	; 6
    11ca:	20 e2       	ldi	r18, 0x20	; 32
    11cc:	fc 01       	movw	r30, r24
    11ce:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    11d0:	80 e4       	ldi	r24, 0x40	; 64
    11d2:	9a e0       	ldi	r25, 0x0A	; 10
    11d4:	23 e2       	ldi	r18, 0x23	; 35
    11d6:	fc 01       	movw	r30, r24
    11d8:	21 83       	std	Z+1, r18	; 0x01
	// set period
	period = (1 << (21 - spsExponent)) - 1;
    11da:	8e 81       	ldd	r24, Y+6	; 0x06
    11dc:	88 2f       	mov	r24, r24
    11de:	90 e0       	ldi	r25, 0x00	; 0
    11e0:	25 e1       	ldi	r18, 0x15	; 21
    11e2:	30 e0       	ldi	r19, 0x00	; 0
    11e4:	28 1b       	sub	r18, r24
    11e6:	39 0b       	sbc	r19, r25
    11e8:	81 e0       	ldi	r24, 0x01	; 1
    11ea:	90 e0       	ldi	r25, 0x00	; 0
    11ec:	02 c0       	rjmp	.+4      	; 0x11f2 <CO_collectADC+0xd6>
    11ee:	88 0f       	add	r24, r24
    11f0:	99 1f       	adc	r25, r25
    11f2:	2a 95       	dec	r18
    11f4:	e2 f7       	brpl	.-8      	; 0x11ee <CO_collectADC+0xd2>
    11f6:	01 97       	sbiw	r24, 0x01	; 1
    11f8:	89 83       	std	Y+1, r24	; 0x01
    11fa:	9a 83       	std	Y+2, r25	; 0x02
	TCE1.PER = period;
    11fc:	80 e4       	ldi	r24, 0x40	; 64
    11fe:	9a e0       	ldi	r25, 0x0A	; 10
    1200:	29 81       	ldd	r18, Y+1	; 0x01
    1202:	3a 81       	ldd	r19, Y+2	; 0x02
    1204:	fc 01       	movw	r30, r24
    1206:	26 a3       	lds	r18, 0x56
    1208:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = period / 2;
    120a:	80 e4       	ldi	r24, 0x40	; 64
    120c:	9a e0       	ldi	r25, 0x0A	; 10
    120e:	29 81       	ldd	r18, Y+1	; 0x01
    1210:	3a 81       	ldd	r19, Y+2	; 0x02
    1212:	36 95       	lsr	r19
    1214:	27 95       	ror	r18
    1216:	fc 01       	movw	r30, r24
    1218:	22 af       	sts	0x72, r18
    121a:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    121c:	80 e4       	ldi	r24, 0x40	; 64
    121e:	9a e0       	ldi	r25, 0x0A	; 10
    1220:	20 e4       	ldi	r18, 0x40	; 64
    1222:	3a e0       	ldi	r19, 0x0A	; 10
    1224:	f9 01       	movw	r30, r18
    1226:	20 81       	ld	r18, Z
    1228:	20 7f       	andi	r18, 0xF0	; 240
    122a:	21 60       	ori	r18, 0x01	; 1
    122c:	fc 01       	movw	r30, r24
    122e:	20 83       	st	Z, r18
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1230:	80 ea       	ldi	r24, 0xA0	; 160
    1232:	90 e0       	ldi	r25, 0x00	; 0
    1234:	20 ea       	ldi	r18, 0xA0	; 160
    1236:	30 e0       	ldi	r19, 0x00	; 0
    1238:	f9 01       	movw	r30, r18
    123a:	22 81       	ldd	r18, Z+2	; 0x02
    123c:	21 60       	ori	r18, 0x01	; 1
    123e:	fc 01       	movw	r30, r24
    1240:	22 83       	std	Z+2, r18	; 0x02
	sei();
    1242:	78 94       	sei

	sampleCount = 0;
    1244:	10 92 69 50 	sts	0x5069, r1
    1248:	10 92 6a 50 	sts	0x506A, r1
    124c:	10 92 6b 50 	sts	0x506B, r1
    1250:	10 92 6c 50 	sts	0x506C, r1
	discardCount = 0;
    1254:	10 92 52 40 	sts	0x4052, r1
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    1258:	00 00       	nop
    125a:	20 91 69 50 	lds	r18, 0x5069
    125e:	30 91 6a 50 	lds	r19, 0x506A
    1262:	40 91 6b 50 	lds	r20, 0x506B
    1266:	50 91 6c 50 	lds	r21, 0x506C
    126a:	8f 81       	ldd	r24, Y+7	; 0x07
    126c:	98 85       	ldd	r25, Y+8	; 0x08
    126e:	a9 85       	ldd	r26, Y+9	; 0x09
    1270:	ba 85       	ldd	r27, Y+10	; 0x0a
    1272:	28 17       	cp	r18, r24
    1274:	39 07       	cpc	r19, r25
    1276:	4a 07       	cpc	r20, r26
    1278:	5b 07       	cpc	r21, r27
    127a:	78 f3       	brcs	.-34     	; 0x125a <CO_collectADC+0x13e>

	// turn off timer and interupts
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    127c:	80 e4       	ldi	r24, 0x40	; 64
    127e:	9a e0       	ldi	r25, 0x0A	; 10
    1280:	20 e4       	ldi	r18, 0x40	; 64
    1282:	3a e0       	ldi	r19, 0x0A	; 10
    1284:	f9 01       	movw	r30, r18
    1286:	20 81       	ld	r18, Z
    1288:	20 7f       	andi	r18, 0xF0	; 240
    128a:	fc 01       	movw	r30, r24
    128c:	20 83       	st	Z, r18
	PMIC.CTRL &= ~PMIC_LOLVLEN_bm;	
    128e:	80 ea       	ldi	r24, 0xA0	; 160
    1290:	90 e0       	ldi	r25, 0x00	; 0
    1292:	20 ea       	ldi	r18, 0xA0	; 160
    1294:	30 e0       	ldi	r19, 0x00	; 0
    1296:	f9 01       	movw	r30, r18
    1298:	22 81       	ldd	r18, Z+2	; 0x02
    129a:	2e 7f       	andi	r18, 0xFE	; 254
    129c:	fc 01       	movw	r30, r24
    129e:	22 83       	std	Z+2, r18	; 0x02
	cli();
    12a0:	f8 94       	cli

	SPIDisable();	
    12a2:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>
	enableADCMUX(FALSE);
    12a6:	80 e0       	ldi	r24, 0x00	; 0
    12a8:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <enableADCMUX>
	ADCPower(FALSE);
    12ac:	80 e0       	ldi	r24, 0x00	; 0
    12ae:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
}
    12b2:	2c 96       	adiw	r28, 0x0c	; 12
    12b4:	cd bf       	out	0x3d, r28	; 61
    12b6:	de bf       	out	0x3e, r29	; 62
    12b8:	df 91       	pop	r29
    12ba:	cf 91       	pop	r28
    12bc:	1f 91       	pop	r17
    12be:	0f 91       	pop	r16
    12c0:	ff 90       	pop	r15
    12c2:	ef 90       	pop	r14
    12c4:	df 90       	pop	r13
    12c6:	cf 90       	pop	r12
    12c8:	08 95       	ret

000012ca <CO_collectADC_cont>:

void CO_collectADC_cont(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent) {
    12ca:	cf 93       	push	r28
    12cc:	df 93       	push	r29
    12ce:	00 d0       	rcall	.+0      	; 0x12d0 <CO_collectADC_cont+0x6>
    12d0:	00 d0       	rcall	.+0      	; 0x12d2 <CO_collectADC_cont+0x8>
    12d2:	cd b7       	in	r28, 0x3d	; 61
    12d4:	de b7       	in	r29, 0x3e	; 62
    12d6:	8b 83       	std	Y+3, r24	; 0x03
    12d8:	6c 83       	std	Y+4, r22	; 0x04
    12da:	4d 83       	std	Y+5, r20	; 0x05
    12dc:	2e 83       	std	Y+6, r18	; 0x06

uint16_t period;

// Turn on power to ADC and PortEx
ADCPower(TRUE);
    12de:	81 e0       	ldi	r24, 0x01	; 1
    12e0:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
//get data to write files to SD card
//getBootSectorData();
// set gain, filters, and ADC input for appropriate VIN
set_ampGain(channel, gainExponent);
    12e4:	8b 81       	ldd	r24, Y+3	; 0x03
    12e6:	6d 81       	ldd	r22, Y+5	; 0x05
    12e8:	0e 94 bd 06 	call	0xd7a	; 0xd7a <set_ampGain>
set_filter(filterConfig);
    12ec:	8c 81       	ldd	r24, Y+4	; 0x04
    12ee:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <set_filter>

// if acc channel then enable DC Pass
// it is assumed that if not using high frequency acc specific function then
// DC Pass is wanted.
if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) ||
    12f2:	8b 81       	ldd	r24, Y+3	; 0x03
    12f4:	85 30       	cpi	r24, 0x05	; 5
    12f6:	31 f0       	breq	.+12     	; 0x1304 <CO_collectADC_cont+0x3a>
    12f8:	8b 81       	ldd	r24, Y+3	; 0x03
    12fa:	86 30       	cpi	r24, 0x06	; 6
    12fc:	19 f0       	breq	.+6      	; 0x1304 <CO_collectADC_cont+0x3a>
    12fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1300:	87 30       	cpi	r24, 0x07	; 7
    1302:	19 f4       	brne	.+6      	; 0x130a <CO_collectADC_cont+0x40>
(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    1304:	81 e0       	ldi	r24, 0x01	; 1
    1306:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <ACC_DCPassEnable>

enableADCMUX(TRUE);
    130a:	81 e0       	ldi	r24, 0x01	; 1
    130c:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <enableADCMUX>
setADCInput(channel);
    1310:	8b 81       	ldd	r24, Y+3	; 0x03
    1312:	0e 94 de 1a 	call	0x35bc	; 0x35bc <setADCInput>
SPIInit(SPI_MODE_1_gc);
    1316:	84 e0       	ldi	r24, 0x04	; 4
    1318:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
SPIC.CTRL = ADC_SPI_CONFIG_gc;
    131c:	80 ec       	ldi	r24, 0xC0	; 192
    131e:	98 e0       	ldi	r25, 0x08	; 8
    1320:	24 e5       	ldi	r18, 0x54	; 84
    1322:	fc 01       	movw	r30, r24
    1324:	20 83       	st	Z, r18

// Configure IO13 (PF0) to capture ADC DRDY signal
PORTF.DIRCLR = PIN0_bm;
    1326:	80 ea       	ldi	r24, 0xA0	; 160
    1328:	96 e0       	ldi	r25, 0x06	; 6
    132a:	21 e0       	ldi	r18, 0x01	; 1
    132c:	fc 01       	movw	r30, r24
    132e:	22 83       	std	Z+2, r18	; 0x02
PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    1330:	80 ea       	ldi	r24, 0xA0	; 160
    1332:	96 e0       	ldi	r25, 0x06	; 6
    1334:	22 e0       	ldi	r18, 0x02	; 2
    1336:	fc 01       	movw	r30, r24
    1338:	20 8b       	std	Z+16, r18	; 0x10
//PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_PULLUP_gc;
PORTF.INT1MASK = PIN0_bm;
    133a:	80 ea       	ldi	r24, 0xA0	; 160
    133c:	96 e0       	ldi	r25, 0x06	; 6
    133e:	21 e0       	ldi	r18, 0x01	; 1
    1340:	fc 01       	movw	r30, r24
    1342:	23 87       	std	Z+11, r18	; 0x0b
PORTF.INTCTRL = PORT_INT1LVL_MED_gc;
    1344:	80 ea       	ldi	r24, 0xA0	; 160
    1346:	96 e0       	ldi	r25, 0x06	; 6
    1348:	28 e0       	ldi	r18, 0x08	; 8
    134a:	fc 01       	movw	r30, r24
    134c:	21 87       	std	Z+9, r18	; 0x09
//f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
//the TCE1 counter increments every pulse of the system clock and once it reaches a certain value it 
//toggles pin 5 (clock input to ADC). This effectively divides the system clock into a desired clock rate for 
//the ADC. 
// Set IO14 (PE5) to output
PORTE.DIRSET = PIN5_bm;
    134e:	80 e8       	ldi	r24, 0x80	; 128
    1350:	96 e0       	ldi	r25, 0x06	; 6
    1352:	20 e2       	ldi	r18, 0x20	; 32
    1354:	fc 01       	movw	r30, r24
    1356:	21 83       	std	Z+1, r18	; 0x01
// Set Waveform generator mode(single slope) and enable the CCx output to IO14 (PE5)
TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1358:	80 e4       	ldi	r24, 0x40	; 64
    135a:	9a e0       	ldi	r25, 0x0A	; 10
    135c:	23 e2       	ldi	r18, 0x23	; 35
    135e:	fc 01       	movw	r30, r24
    1360:	21 83       	std	Z+1, r18	; 0x01
// set period
period = (1 << (21 - spsExponent)) - 1;
    1362:	8e 81       	ldd	r24, Y+6	; 0x06
    1364:	88 2f       	mov	r24, r24
    1366:	90 e0       	ldi	r25, 0x00	; 0
    1368:	25 e1       	ldi	r18, 0x15	; 21
    136a:	30 e0       	ldi	r19, 0x00	; 0
    136c:	28 1b       	sub	r18, r24
    136e:	39 0b       	sbc	r19, r25
    1370:	81 e0       	ldi	r24, 0x01	; 1
    1372:	90 e0       	ldi	r25, 0x00	; 0
    1374:	02 c0       	rjmp	.+4      	; 0x137a <CO_collectADC_cont+0xb0>
    1376:	88 0f       	add	r24, r24
    1378:	99 1f       	adc	r25, r25
    137a:	2a 95       	dec	r18
    137c:	e2 f7       	brpl	.-8      	; 0x1376 <CO_collectADC_cont+0xac>
    137e:	01 97       	sbiw	r24, 0x01	; 1
    1380:	89 83       	std	Y+1, r24	; 0x01
    1382:	9a 83       	std	Y+2, r25	; 0x02
TCE1.PER = period;
    1384:	80 e4       	ldi	r24, 0x40	; 64
    1386:	9a e0       	ldi	r25, 0x0A	; 10
    1388:	29 81       	ldd	r18, Y+1	; 0x01
    138a:	3a 81       	ldd	r19, Y+2	; 0x02
    138c:	fc 01       	movw	r30, r24
    138e:	26 a3       	lds	r18, 0x56
    1390:	37 a3       	lds	r19, 0x57
TCE1.CCBBUF = period / 2;
    1392:	80 e4       	ldi	r24, 0x40	; 64
    1394:	9a e0       	ldi	r25, 0x0A	; 10
    1396:	29 81       	ldd	r18, Y+1	; 0x01
    1398:	3a 81       	ldd	r19, Y+2	; 0x02
    139a:	36 95       	lsr	r19
    139c:	27 95       	ror	r18
    139e:	fc 01       	movw	r30, r24
    13a0:	22 af       	sts	0x72, r18
    13a2:	33 af       	sts	0x73, r19
// Set oscillator source and frequency and start
TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    13a4:	80 e4       	ldi	r24, 0x40	; 64
    13a6:	9a e0       	ldi	r25, 0x0A	; 10
    13a8:	20 e4       	ldi	r18, 0x40	; 64
    13aa:	3a e0       	ldi	r19, 0x0A	; 10
    13ac:	f9 01       	movw	r30, r18
    13ae:	20 81       	ld	r18, Z
    13b0:	20 7f       	andi	r18, 0xF0	; 240
    13b2:	21 60       	ori	r18, 0x01	; 1
    13b4:	fc 01       	movw	r30, r24
    13b6:	20 83       	st	Z, r18

// Enable interrupts.
PMIC.CTRL |= PMIC_MEDLVLEN_bm;
    13b8:	80 ea       	ldi	r24, 0xA0	; 160
    13ba:	90 e0       	ldi	r25, 0x00	; 0
    13bc:	20 ea       	ldi	r18, 0xA0	; 160
    13be:	30 e0       	ldi	r19, 0x00	; 0
    13c0:	f9 01       	movw	r30, r18
    13c2:	22 81       	ldd	r18, Z+2	; 0x02
    13c4:	22 60       	ori	r18, 0x02	; 2
    13c6:	fc 01       	movw	r30, r24
    13c8:	22 83       	std	Z+2, r18	; 0x02
//enable RR of lowlvl interrupts
PMIC.CTRL |= PMIC_RREN_bm; 
    13ca:	80 ea       	ldi	r24, 0xA0	; 160
    13cc:	90 e0       	ldi	r25, 0x00	; 0
    13ce:	20 ea       	ldi	r18, 0xA0	; 160
    13d0:	30 e0       	ldi	r19, 0x00	; 0
    13d2:	f9 01       	movw	r30, r18
    13d4:	22 81       	ldd	r18, Z+2	; 0x02
    13d6:	20 68       	ori	r18, 0x80	; 128
    13d8:	fc 01       	movw	r30, r24
    13da:	22 83       	std	Z+2, r18	; 0x02
//perhaps next two lines are redundant...
// chb_init();
// chb_set_short_addr(moteID);

sampleCount = 0;
    13dc:	10 92 69 50 	sts	0x5069, r1
    13e0:	10 92 6a 50 	sts	0x506A, r1
    13e4:	10 92 6b 50 	sts	0x506B, r1
    13e8:	10 92 6c 50 	sts	0x506C, r1
TotalSampleCount = 0;
    13ec:	10 92 99 50 	sts	0x5099, r1
    13f0:	10 92 9a 50 	sts	0x509A, r1
discardCount = 0;
    13f4:	10 92 52 40 	sts	0x4052, r1
sei();
    13f8:	78 94       	sei
}
    13fa:	26 96       	adiw	r28, 0x06	; 6
    13fc:	cd bf       	out	0x3d, r28	; 61
    13fe:	de bf       	out	0x3e, r29	; 62
    1400:	df 91       	pop	r29
    1402:	cf 91       	pop	r28
    1404:	08 95       	ret

00001406 <ADC_Pause_Sampling>:


void ADC_Pause_Sampling(){
    1406:	cf 93       	push	r28
    1408:	df 93       	push	r29
    140a:	cd b7       	in	r28, 0x3d	; 61
    140c:	de b7       	in	r29, 0x3e	; 62
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    140e:	80 ea       	ldi	r24, 0xA0	; 160
    1410:	96 e0       	ldi	r25, 0x06	; 6
    1412:	fc 01       	movw	r30, r24
    1414:	13 86       	std	Z+11, r1	; 0x0b
}
    1416:	df 91       	pop	r29
    1418:	cf 91       	pop	r28
    141a:	08 95       	ret

0000141c <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
    141c:	cf 93       	push	r28
    141e:	df 93       	push	r29
    1420:	cd b7       	in	r28, 0x3d	; 61
    1422:	de b7       	in	r29, 0x3e	; 62
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    1424:	80 ea       	ldi	r24, 0xA0	; 160
    1426:	96 e0       	ldi	r25, 0x06	; 6
    1428:	21 e0       	ldi	r18, 0x01	; 1
    142a:	fc 01       	movw	r30, r24
    142c:	23 87       	std	Z+11, r18	; 0x0b
}	
    142e:	df 91       	pop	r29
    1430:	cf 91       	pop	r28
    1432:	08 95       	ret

00001434 <__vector_105>:
ISR(PORTF_INT1_vect) {
    1434:	1f 92       	push	r1
    1436:	0f 92       	push	r0
    1438:	0f b6       	in	r0, 0x3f	; 63
    143a:	0f 92       	push	r0
    143c:	00 90 3b 00 	lds	r0, 0x003B
    1440:	0f 92       	push	r0
    1442:	11 24       	eor	r1, r1
    1444:	2f 92       	push	r2
    1446:	3f 92       	push	r3
    1448:	4f 92       	push	r4
    144a:	5f 92       	push	r5
    144c:	6f 92       	push	r6
    144e:	7f 92       	push	r7
    1450:	8f 92       	push	r8
    1452:	9f 92       	push	r9
    1454:	af 92       	push	r10
    1456:	bf 92       	push	r11
    1458:	cf 92       	push	r12
    145a:	df 92       	push	r13
    145c:	ef 92       	push	r14
    145e:	ff 92       	push	r15
    1460:	0f 93       	push	r16
    1462:	1f 93       	push	r17
    1464:	2f 93       	push	r18
    1466:	3f 93       	push	r19
    1468:	4f 93       	push	r20
    146a:	5f 93       	push	r21
    146c:	6f 93       	push	r22
    146e:	7f 93       	push	r23
    1470:	8f 93       	push	r24
    1472:	9f 93       	push	r25
    1474:	af 93       	push	r26
    1476:	bf 93       	push	r27
    1478:	ef 93       	push	r30
    147a:	ff 93       	push	r31
    147c:	cf 93       	push	r28
    147e:	df 93       	push	r29
    1480:	00 d0       	rcall	.+0      	; 0x1482 <__vector_105+0x4e>
    1482:	cd b7       	in	r28, 0x3d	; 61
    1484:	de b7       	in	r29, 0x3e	; 62
			nop();
		}		
	}
	*/		
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    1486:	80 91 52 40 	lds	r24, 0x4052
    148a:	88 23       	and	r24, r24
    148c:	34 f0       	brlt	.+12     	; 0x149a <__vector_105+0x66>
		discardCount++;
    148e:	80 91 52 40 	lds	r24, 0x4052
    1492:	8f 5f       	subi	r24, 0xFF	; 255
    1494:	80 93 52 40 	sts	0x4052, r24
    1498:	af c1       	rjmp	.+862    	; 0x17f8 <__vector_105+0x3c4>
	}		
	else {
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
    149a:	84 e0       	ldi	r24, 0x04	; 4
    149c:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
    14a0:	80 ec       	ldi	r24, 0xC0	; 192
    14a2:	98 e0       	ldi	r25, 0x08	; 8
    14a4:	24 e5       	ldi	r18, 0x54	; 84
    14a6:	fc 01       	movw	r30, r24
    14a8:	20 83       	st	Z, r18
		SPICS(TRUE); // CS SPI-SS
    14aa:	81 e0       	ldi	r24, 0x01	; 1
    14ac:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    14b0:	80 ea       	ldi	r24, 0xA0	; 160
    14b2:	96 e0       	ldi	r25, 0x06	; 6
    14b4:	22 e0       	ldi	r18, 0x02	; 2
    14b6:	fc 01       	movw	r30, r24
    14b8:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    14ba:	19 82       	std	Y+1, r1	; 0x01
    14bc:	1a c0       	rjmp	.+52     	; 0x14f2 <__vector_105+0xbe>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    14be:	80 ec       	ldi	r24, 0xC0	; 192
    14c0:	98 e0       	ldi	r25, 0x08	; 8
    14c2:	2a ea       	ldi	r18, 0xAA	; 170
    14c4:	fc 01       	movw	r30, r24
    14c6:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    14c8:	00 00       	nop
    14ca:	80 ec       	ldi	r24, 0xC0	; 192
    14cc:	98 e0       	ldi	r25, 0x08	; 8
    14ce:	fc 01       	movw	r30, r24
    14d0:	82 81       	ldd	r24, Z+2	; 0x02
    14d2:	88 23       	and	r24, r24
    14d4:	d4 f7       	brge	.-12     	; 0x14ca <__vector_105+0x96>
			SPIBuffer[bufIndex] = SPIC.DATA;
    14d6:	89 81       	ldd	r24, Y+1	; 0x01
    14d8:	88 2f       	mov	r24, r24
    14da:	90 e0       	ldi	r25, 0x00	; 0
    14dc:	20 ec       	ldi	r18, 0xC0	; 192
    14de:	38 e0       	ldi	r19, 0x08	; 8
    14e0:	f9 01       	movw	r30, r18
    14e2:	23 81       	ldd	r18, Z+3	; 0x03
    14e4:	86 5a       	subi	r24, 0xA6	; 166
    14e6:	9f 4a       	sbci	r25, 0xAF	; 175
    14e8:	fc 01       	movw	r30, r24
    14ea:	20 83       	st	Z, r18
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    14ec:	89 81       	ldd	r24, Y+1	; 0x01
    14ee:	8f 5f       	subi	r24, 0xFF	; 255
    14f0:	89 83       	std	Y+1, r24	; 0x01
    14f2:	89 81       	ldd	r24, Y+1	; 0x01
    14f4:	83 30       	cpi	r24, 0x03	; 3
    14f6:	18 f3       	brcs	.-58     	; 0x14be <__vector_105+0x8a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    14f8:	80 ea       	ldi	r24, 0xA0	; 160
    14fa:	96 e0       	ldi	r25, 0x06	; 6
    14fc:	22 e0       	ldi	r18, 0x02	; 2
    14fe:	fc 01       	movw	r30, r24
    1500:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1502:	80 e0       	ldi	r24, 0x00	; 0
    1504:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>

		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[0]) + 3) = 0xFF; // sign extension if negative
    1508:	80 91 5a 50 	lds	r24, 0x505A
    150c:	88 23       	and	r24, r24
    150e:	34 f4       	brge	.+12     	; 0x151c <__vector_105+0xe8>
    1510:	8b e5       	ldi	r24, 0x5B	; 91
    1512:	90 e4       	ldi	r25, 0x40	; 64
    1514:	2f ef       	ldi	r18, 0xFF	; 255
    1516:	fc 01       	movw	r30, r24
    1518:	20 83       	st	Z, r18
    151a:	04 c0       	rjmp	.+8      	; 0x1524 <__vector_105+0xf0>
		else *(((uint8_t*)&data24Bit[0]) + 3) = 0x00;				
    151c:	8b e5       	ldi	r24, 0x5B	; 91
    151e:	90 e4       	ldi	r25, 0x40	; 64
    1520:	fc 01       	movw	r30, r24
    1522:	10 82       	st	Z, r1
		*(((uint8_t*)&data24Bit[0]) + 2) = SPIBuffer[0];
    1524:	8a e5       	ldi	r24, 0x5A	; 90
    1526:	90 e4       	ldi	r25, 0x40	; 64
    1528:	20 91 5a 50 	lds	r18, 0x505A
    152c:	fc 01       	movw	r30, r24
    152e:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 1) = SPIBuffer[1];
    1530:	89 e5       	ldi	r24, 0x59	; 89
    1532:	90 e4       	ldi	r25, 0x40	; 64
    1534:	20 91 5b 50 	lds	r18, 0x505B
    1538:	fc 01       	movw	r30, r24
    153a:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 0) = SPIBuffer[2];
    153c:	88 e5       	ldi	r24, 0x58	; 88
    153e:	90 e4       	ldi	r25, 0x40	; 64
    1540:	20 91 5c 50 	lds	r18, 0x505C
    1544:	fc 01       	movw	r30, r24
    1546:	20 83       	st	Z, r18
		
		//convert ADC reading to voltage here (in uV)
		var = data24Bit[0];
    1548:	80 91 58 40 	lds	r24, 0x4058
    154c:	90 91 59 40 	lds	r25, 0x4059
    1550:	a0 91 5a 40 	lds	r26, 0x405A
    1554:	b0 91 5b 40 	lds	r27, 0x405B
    1558:	5c 01       	movw	r10, r24
    155a:	6d 01       	movw	r12, r26
    155c:	bb 0f       	add	r27, r27
    155e:	88 0b       	sbc	r24, r24
    1560:	98 2f       	mov	r25, r24
    1562:	dc 01       	movw	r26, r24
    1564:	e8 2e       	mov	r14, r24
    1566:	f8 2e       	mov	r15, r24
    1568:	08 2f       	mov	r16, r24
    156a:	18 2f       	mov	r17, r24
    156c:	a0 92 9b 50 	sts	0x509B, r10
    1570:	b0 92 9c 50 	sts	0x509C, r11
    1574:	c0 92 9d 50 	sts	0x509D, r12
    1578:	d0 92 9e 50 	sts	0x509E, r13
    157c:	e0 92 9f 50 	sts	0x509F, r14
    1580:	f0 92 a0 50 	sts	0x50A0, r15
    1584:	00 93 a1 50 	sts	0x50A1, r16
    1588:	10 93 a2 50 	sts	0x50A2, r17
		*((int32_t*)&FRAMReadBuffer[sampleCount*4]) = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    158c:	80 91 69 50 	lds	r24, 0x5069
    1590:	90 91 6a 50 	lds	r25, 0x506A
    1594:	a0 91 6b 50 	lds	r26, 0x506B
    1598:	b0 91 6c 50 	lds	r27, 0x506C
    159c:	88 0f       	add	r24, r24
    159e:	99 1f       	adc	r25, r25
    15a0:	88 0f       	add	r24, r24
    15a2:	99 1f       	adc	r25, r25
    15a4:	9c 01       	movw	r18, r24
    15a6:	24 53       	subi	r18, 0x34	; 52
    15a8:	3c 4d       	sbci	r19, 0xDC	; 220
    15aa:	2a 83       	std	Y+2, r18	; 0x02
    15ac:	3b 83       	std	Y+3, r19	; 0x03
    15ae:	a0 90 9b 50 	lds	r10, 0x509B
    15b2:	b0 90 9c 50 	lds	r11, 0x509C
    15b6:	c0 90 9d 50 	lds	r12, 0x509D
    15ba:	d0 90 9e 50 	lds	r13, 0x509E
    15be:	e0 90 9f 50 	lds	r14, 0x509F
    15c2:	f0 90 a0 50 	lds	r15, 0x50A0
    15c6:	00 91 a1 50 	lds	r16, 0x50A1
    15ca:	10 91 a2 50 	lds	r17, 0x50A2
    15ce:	2a 2d       	mov	r18, r10
    15d0:	3b 2d       	mov	r19, r11
    15d2:	4c 2d       	mov	r20, r12
    15d4:	5d 2d       	mov	r21, r13
    15d6:	6e 2d       	mov	r22, r14
    15d8:	7f 2d       	mov	r23, r15
    15da:	80 2f       	mov	r24, r16
    15dc:	91 2f       	mov	r25, r17
    15de:	0f 2e       	mov	r0, r31
    15e0:	f0 ea       	ldi	r31, 0xA0	; 160
    15e2:	af 2e       	mov	r10, r31
    15e4:	f0 2d       	mov	r31, r0
    15e6:	0f 2e       	mov	r0, r31
    15e8:	f5 e2       	ldi	r31, 0x25	; 37
    15ea:	bf 2e       	mov	r11, r31
    15ec:	f0 2d       	mov	r31, r0
    15ee:	0f 2e       	mov	r0, r31
    15f0:	f6 e2       	ldi	r31, 0x26	; 38
    15f2:	cf 2e       	mov	r12, r31
    15f4:	f0 2d       	mov	r31, r0
    15f6:	dd 24       	eor	r13, r13
    15f8:	ee 24       	eor	r14, r14
    15fa:	ff 24       	eor	r15, r15
    15fc:	00 e0       	ldi	r16, 0x00	; 0
    15fe:	10 e0       	ldi	r17, 0x00	; 0
    1600:	0e 94 4d 52 	call	0xa49a	; 0xa49a <__muldi3>
    1604:	22 2e       	mov	r2, r18
    1606:	33 2e       	mov	r3, r19
    1608:	44 2e       	mov	r4, r20
    160a:	55 2e       	mov	r5, r21
    160c:	66 2e       	mov	r6, r22
    160e:	77 2e       	mov	r7, r23
    1610:	88 2e       	mov	r8, r24
    1612:	99 2e       	mov	r9, r25
    1614:	a2 2c       	mov	r10, r2
    1616:	b3 2c       	mov	r11, r3
    1618:	c4 2c       	mov	r12, r4
    161a:	d5 2c       	mov	r13, r5
    161c:	e6 2c       	mov	r14, r6
    161e:	f7 2c       	mov	r15, r7
    1620:	08 2d       	mov	r16, r8
    1622:	19 2d       	mov	r17, r9
    1624:	2a 2d       	mov	r18, r10
    1626:	3b 2d       	mov	r19, r11
    1628:	4c 2d       	mov	r20, r12
    162a:	5d 2d       	mov	r21, r13
    162c:	6e 2d       	mov	r22, r14
    162e:	7f 2d       	mov	r23, r15
    1630:	80 2f       	mov	r24, r16
    1632:	91 2f       	mov	r25, r17
    1634:	aa 24       	eor	r10, r10
    1636:	aa 94       	dec	r10
    1638:	bb 24       	eor	r11, r11
    163a:	ba 94       	dec	r11
    163c:	0f 2e       	mov	r0, r31
    163e:	ff e7       	ldi	r31, 0x7F	; 127
    1640:	cf 2e       	mov	r12, r31
    1642:	f0 2d       	mov	r31, r0
    1644:	dd 24       	eor	r13, r13
    1646:	ee 24       	eor	r14, r14
    1648:	ff 24       	eor	r15, r15
    164a:	00 e0       	ldi	r16, 0x00	; 0
    164c:	10 e0       	ldi	r17, 0x00	; 0
    164e:	0e 94 94 53 	call	0xa728	; 0xa728 <__divdi3>
    1652:	22 2e       	mov	r2, r18
    1654:	33 2e       	mov	r3, r19
    1656:	44 2e       	mov	r4, r20
    1658:	55 2e       	mov	r5, r21
    165a:	66 2e       	mov	r6, r22
    165c:	77 2e       	mov	r7, r23
    165e:	88 2e       	mov	r8, r24
    1660:	99 2e       	mov	r9, r25
    1662:	a2 2c       	mov	r10, r2
    1664:	b3 2c       	mov	r11, r3
    1666:	c4 2c       	mov	r12, r4
    1668:	d5 2c       	mov	r13, r5
    166a:	e6 2c       	mov	r14, r6
    166c:	f7 2c       	mov	r15, r7
    166e:	08 2d       	mov	r16, r8
    1670:	19 2d       	mov	r17, r9
    1672:	2a 2d       	mov	r18, r10
    1674:	3b 2d       	mov	r19, r11
    1676:	4c 2d       	mov	r20, r12
    1678:	5d 2d       	mov	r21, r13
    167a:	6e 2d       	mov	r22, r14
    167c:	7f 2d       	mov	r23, r15
    167e:	80 2f       	mov	r24, r16
    1680:	91 2f       	mov	r25, r17
    1682:	01 e0       	ldi	r16, 0x01	; 1
    1684:	0e 94 20 53 	call	0xa640	; 0xa640 <__ashldi3>
    1688:	22 2e       	mov	r2, r18
    168a:	33 2e       	mov	r3, r19
    168c:	44 2e       	mov	r4, r20
    168e:	55 2e       	mov	r5, r21
    1690:	66 2e       	mov	r6, r22
    1692:	77 2e       	mov	r7, r23
    1694:	88 2e       	mov	r8, r24
    1696:	99 2e       	mov	r9, r25
    1698:	a2 2c       	mov	r10, r2
    169a:	b3 2c       	mov	r11, r3
    169c:	c4 2c       	mov	r12, r4
    169e:	d5 2c       	mov	r13, r5
    16a0:	e6 2c       	mov	r14, r6
    16a2:	f7 2c       	mov	r15, r7
    16a4:	08 2d       	mov	r16, r8
    16a6:	19 2d       	mov	r17, r9
    16a8:	2a 2d       	mov	r18, r10
    16aa:	3b 2d       	mov	r19, r11
    16ac:	4c 2d       	mov	r20, r12
    16ae:	5d 2d       	mov	r21, r13
    16b0:	6e 2d       	mov	r22, r14
    16b2:	7f 2d       	mov	r23, r15
    16b4:	80 2f       	mov	r24, r16
    16b6:	91 2f       	mov	r25, r17
    16b8:	0f 2e       	mov	r0, r31
    16ba:	f3 e0       	ldi	r31, 0x03	; 3
    16bc:	af 2e       	mov	r10, r31
    16be:	f0 2d       	mov	r31, r0
    16c0:	bb 24       	eor	r11, r11
    16c2:	cc 24       	eor	r12, r12
    16c4:	dd 24       	eor	r13, r13
    16c6:	ee 24       	eor	r14, r14
    16c8:	ff 24       	eor	r15, r15
    16ca:	00 e0       	ldi	r16, 0x00	; 0
    16cc:	10 e0       	ldi	r17, 0x00	; 0
    16ce:	0e 94 94 53 	call	0xa728	; 0xa728 <__divdi3>
    16d2:	a2 2e       	mov	r10, r18
    16d4:	b3 2e       	mov	r11, r19
    16d6:	c4 2e       	mov	r12, r20
    16d8:	d5 2e       	mov	r13, r21
    16da:	e6 2e       	mov	r14, r22
    16dc:	f7 2e       	mov	r15, r23
    16de:	08 2f       	mov	r16, r24
    16e0:	19 2f       	mov	r17, r25
    16e2:	2a 2d       	mov	r18, r10
    16e4:	3b 2d       	mov	r19, r11
    16e6:	4c 2d       	mov	r20, r12
    16e8:	5d 2d       	mov	r21, r13
    16ea:	6e 2d       	mov	r22, r14
    16ec:	7f 2d       	mov	r23, r15
    16ee:	80 2f       	mov	r24, r16
    16f0:	91 2f       	mov	r25, r17
    16f2:	da 01       	movw	r26, r20
    16f4:	c9 01       	movw	r24, r18
    16f6:	b0 95       	com	r27
    16f8:	a0 95       	com	r26
    16fa:	90 95       	com	r25
    16fc:	81 95       	neg	r24
    16fe:	9f 4f       	sbci	r25, 0xFF	; 255
    1700:	af 4f       	sbci	r26, 0xFF	; 255
    1702:	bf 4f       	sbci	r27, 0xFF	; 255
    1704:	ea 81       	ldd	r30, Y+2	; 0x02
    1706:	fb 81       	ldd	r31, Y+3	; 0x03
    1708:	80 83       	st	Z, r24
    170a:	91 83       	std	Z+1, r25	; 0x01
    170c:	a2 83       	std	Z+2, r26	; 0x02
    170e:	b3 83       	std	Z+3, r27	; 0x03
		
		sampleCount++;
    1710:	80 91 69 50 	lds	r24, 0x5069
    1714:	90 91 6a 50 	lds	r25, 0x506A
    1718:	a0 91 6b 50 	lds	r26, 0x506B
    171c:	b0 91 6c 50 	lds	r27, 0x506C
    1720:	01 96       	adiw	r24, 0x01	; 1
    1722:	a1 1d       	adc	r26, r1
    1724:	b1 1d       	adc	r27, r1
    1726:	80 93 69 50 	sts	0x5069, r24
    172a:	90 93 6a 50 	sts	0x506A, r25
    172e:	a0 93 6b 50 	sts	0x506B, r26
    1732:	b0 93 6c 50 	sts	0x506C, r27
	//after 128 samples, store the data into sd card and reset sample buffer
	//after 30 samples, send the data over the radio
	if (sampleCount >= 30) { 
    1736:	80 91 69 50 	lds	r24, 0x5069
    173a:	90 91 6a 50 	lds	r25, 0x506A
    173e:	a0 91 6b 50 	lds	r26, 0x506B
    1742:	b0 91 6c 50 	lds	r27, 0x506C
    1746:	8e 31       	cpi	r24, 0x1E	; 30
    1748:	91 05       	cpc	r25, r1
    174a:	a1 05       	cpc	r26, r1
    174c:	b1 05       	cpc	r27, r1
    174e:	08 f4       	brcc	.+2      	; 0x1752 <__vector_105+0x31e>
    1750:	53 c0       	rjmp	.+166    	; 0x17f8 <__vector_105+0x3c4>
		/*
		SD_write_block(10,FRAMReadBuffer,512);
		for (int i=0;i<512;i++) FRAMReadBuffer[i] = 0;
		SD_read_block(10,FRAMReadBuffer);
		*/
		sampleCount=0;
    1752:	10 92 69 50 	sts	0x5069, r1
    1756:	10 92 6a 50 	sts	0x506A, r1
    175a:	10 92 6b 50 	sts	0x506B, r1
    175e:	10 92 6c 50 	sts	0x506C, r1
		TotalSampleCount++;
    1762:	80 91 99 50 	lds	r24, 0x5099
    1766:	90 91 9a 50 	lds	r25, 0x509A
    176a:	01 96       	adiw	r24, 0x01	; 1
    176c:	80 93 99 50 	sts	0x5099, r24
    1770:	90 93 9a 50 	sts	0x509A, r25
		discardCount = ADC_DISCARD -1; //discard the next sample after pausing the sampling to send/store data since the sample ready flag will be outdated and the value might be bad
    1774:	8f e7       	ldi	r24, 0x7F	; 127
    1776:	80 93 52 40 	sts	0x4052, r24
		//PORTF.OUTSET = PIN1_bm; //re-enable ADC for further sampling
		
		//write code to send the data over radio instead. Include some identifying info (like mote number) with the data.
		memmove(FRAMReadBuffer+2,FRAMReadBuffer,sampleCount*4); //move the data in the FRAM buffer up by 1 byte to make room for metadata
    177a:	80 91 69 50 	lds	r24, 0x5069
    177e:	90 91 6a 50 	lds	r25, 0x506A
    1782:	a0 91 6b 50 	lds	r26, 0x506B
    1786:	b0 91 6c 50 	lds	r27, 0x506C
    178a:	9c 01       	movw	r18, r24
    178c:	22 0f       	add	r18, r18
    178e:	33 1f       	adc	r19, r19
    1790:	22 0f       	add	r18, r18
    1792:	33 1f       	adc	r19, r19
    1794:	8e ec       	ldi	r24, 0xCE	; 206
    1796:	93 e2       	ldi	r25, 0x23	; 35
    1798:	4c ec       	ldi	r20, 0xCC	; 204
    179a:	53 e2       	ldi	r21, 0x23	; 35
    179c:	ba 01       	movw	r22, r20
    179e:	a9 01       	movw	r20, r18
    17a0:	0e 94 c4 63 	call	0xc788	; 0xc788 <memcpy>
		FRAMReadBuffer[0] = moteID;		//send moteID of the mote that gathered the data
    17a4:	80 91 c5 50 	lds	r24, 0x50C5
    17a8:	80 93 cc 23 	sts	0x23CC, r24
		FRAMReadBuffer[1] = (uint8_t)sampleCount;	//send the number of data samples gathered cast as a byte since no more than 30/31 samples should be send at a time
    17ac:	80 91 69 50 	lds	r24, 0x5069
    17b0:	90 91 6a 50 	lds	r25, 0x506A
    17b4:	a0 91 6b 50 	lds	r26, 0x506B
    17b8:	b0 91 6c 50 	lds	r27, 0x506C
    17bc:	80 93 cd 23 	sts	0x23CD, r24
		chb_write(0x0000,FRAMReadBuffer,sampleCount*4+2);	//send the samples and the metadata (for now just 1 byte containing moteID) to the base station
    17c0:	80 91 69 50 	lds	r24, 0x5069
    17c4:	90 91 6a 50 	lds	r25, 0x506A
    17c8:	a0 91 6b 50 	lds	r26, 0x506B
    17cc:	b0 91 6c 50 	lds	r27, 0x506C
    17d0:	88 0f       	add	r24, r24
    17d2:	99 1f       	adc	r25, r25
    17d4:	aa 1f       	adc	r26, r26
    17d6:	bb 1f       	adc	r27, r27
    17d8:	88 0f       	add	r24, r24
    17da:	99 1f       	adc	r25, r25
    17dc:	aa 1f       	adc	r26, r26
    17de:	bb 1f       	adc	r27, r27
    17e0:	9c 01       	movw	r18, r24
    17e2:	ad 01       	movw	r20, r26
    17e4:	2e 5f       	subi	r18, 0xFE	; 254
    17e6:	3f 4f       	sbci	r19, 0xFF	; 255
    17e8:	4f 4f       	sbci	r20, 0xFF	; 255
    17ea:	5f 4f       	sbci	r21, 0xFF	; 255
    17ec:	6c ec       	ldi	r22, 0xCC	; 204
    17ee:	73 e2       	ldi	r23, 0x23	; 35
    17f0:	80 e0       	ldi	r24, 0x00	; 0
    17f2:	90 e0       	ldi	r25, 0x00	; 0
    17f4:	0e 94 88 1f 	call	0x3f10	; 0x3f10 <chb_write>
	}	
	}	
}
    17f8:	23 96       	adiw	r28, 0x03	; 3
    17fa:	cd bf       	out	0x3d, r28	; 61
    17fc:	de bf       	out	0x3e, r29	; 62
    17fe:	df 91       	pop	r29
    1800:	cf 91       	pop	r28
    1802:	ff 91       	pop	r31
    1804:	ef 91       	pop	r30
    1806:	bf 91       	pop	r27
    1808:	af 91       	pop	r26
    180a:	9f 91       	pop	r25
    180c:	8f 91       	pop	r24
    180e:	7f 91       	pop	r23
    1810:	6f 91       	pop	r22
    1812:	5f 91       	pop	r21
    1814:	4f 91       	pop	r20
    1816:	3f 91       	pop	r19
    1818:	2f 91       	pop	r18
    181a:	1f 91       	pop	r17
    181c:	0f 91       	pop	r16
    181e:	ff 90       	pop	r15
    1820:	ef 90       	pop	r14
    1822:	df 90       	pop	r13
    1824:	cf 90       	pop	r12
    1826:	bf 90       	pop	r11
    1828:	af 90       	pop	r10
    182a:	9f 90       	pop	r9
    182c:	8f 90       	pop	r8
    182e:	7f 90       	pop	r7
    1830:	6f 90       	pop	r6
    1832:	5f 90       	pop	r5
    1834:	4f 90       	pop	r4
    1836:	3f 90       	pop	r3
    1838:	2f 90       	pop	r2
    183a:	0f 90       	pop	r0
    183c:	00 92 3b 00 	sts	0x003B, r0
    1840:	0f 90       	pop	r0
    1842:	0f be       	out	0x3f, r0	; 63
    1844:	0f 90       	pop	r0
    1846:	1f 90       	pop	r1
    1848:	18 95       	reti

0000184a <__vector_104>:

ISR(PORTF_INT0_vect) {
    184a:	1f 92       	push	r1
    184c:	0f 92       	push	r0
    184e:	0f b6       	in	r0, 0x3f	; 63
    1850:	0f 92       	push	r0
    1852:	00 90 3b 00 	lds	r0, 0x003B
    1856:	0f 92       	push	r0
    1858:	11 24       	eor	r1, r1
    185a:	2f 92       	push	r2
    185c:	3f 92       	push	r3
    185e:	4f 92       	push	r4
    1860:	5f 92       	push	r5
    1862:	6f 92       	push	r6
    1864:	7f 92       	push	r7
    1866:	8f 92       	push	r8
    1868:	9f 92       	push	r9
    186a:	af 92       	push	r10
    186c:	bf 92       	push	r11
    186e:	cf 92       	push	r12
    1870:	df 92       	push	r13
    1872:	ef 92       	push	r14
    1874:	ff 92       	push	r15
    1876:	0f 93       	push	r16
    1878:	1f 93       	push	r17
    187a:	2f 93       	push	r18
    187c:	3f 93       	push	r19
    187e:	4f 93       	push	r20
    1880:	5f 93       	push	r21
    1882:	6f 93       	push	r22
    1884:	7f 93       	push	r23
    1886:	8f 93       	push	r24
    1888:	9f 93       	push	r25
    188a:	af 93       	push	r26
    188c:	bf 93       	push	r27
    188e:	ef 93       	push	r30
    1890:	ff 93       	push	r31
    1892:	cf 93       	push	r28
    1894:	df 93       	push	r29
    1896:	00 d0       	rcall	.+0      	; 0x1898 <__vector_104+0x4e>
    1898:	cd b7       	in	r28, 0x3d	; 61
    189a:	de b7       	in	r29, 0x3e	; 62
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    189c:	80 91 52 40 	lds	r24, 0x4052
    18a0:	88 23       	and	r24, r24
    18a2:	34 f0       	brlt	.+12     	; 0x18b0 <__vector_104+0x66>
		discardCount++;
    18a4:	80 91 52 40 	lds	r24, 0x4052
    18a8:	8f 5f       	subi	r24, 0xFF	; 255
    18aa:	80 93 52 40 	sts	0x4052, r24
    18ae:	75 c1       	rjmp	.+746    	; 0x1b9a <__vector_104+0x350>
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    18b0:	81 e0       	ldi	r24, 0x01	; 1
    18b2:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    18b6:	80 ea       	ldi	r24, 0xA0	; 160
    18b8:	96 e0       	ldi	r25, 0x06	; 6
    18ba:	22 e0       	ldi	r18, 0x02	; 2
    18bc:	fc 01       	movw	r30, r24
    18be:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    18c0:	19 82       	std	Y+1, r1	; 0x01
    18c2:	1a c0       	rjmp	.+52     	; 0x18f8 <__vector_104+0xae>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    18c4:	80 ec       	ldi	r24, 0xC0	; 192
    18c6:	98 e0       	ldi	r25, 0x08	; 8
    18c8:	2a ea       	ldi	r18, 0xAA	; 170
    18ca:	fc 01       	movw	r30, r24
    18cc:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    18ce:	00 00       	nop
    18d0:	80 ec       	ldi	r24, 0xC0	; 192
    18d2:	98 e0       	ldi	r25, 0x08	; 8
    18d4:	fc 01       	movw	r30, r24
    18d6:	82 81       	ldd	r24, Z+2	; 0x02
    18d8:	88 23       	and	r24, r24
    18da:	d4 f7       	brge	.-12     	; 0x18d0 <__vector_104+0x86>
			SPIBuffer[bufIndex] = SPIC.DATA;
    18dc:	89 81       	ldd	r24, Y+1	; 0x01
    18de:	88 2f       	mov	r24, r24
    18e0:	90 e0       	ldi	r25, 0x00	; 0
    18e2:	20 ec       	ldi	r18, 0xC0	; 192
    18e4:	38 e0       	ldi	r19, 0x08	; 8
    18e6:	f9 01       	movw	r30, r18
    18e8:	23 81       	ldd	r18, Z+3	; 0x03
    18ea:	86 5a       	subi	r24, 0xA6	; 166
    18ec:	9f 4a       	sbci	r25, 0xAF	; 175
    18ee:	fc 01       	movw	r30, r24
    18f0:	20 83       	st	Z, r18
		discardCount++;
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    18f2:	89 81       	ldd	r24, Y+1	; 0x01
    18f4:	8f 5f       	subi	r24, 0xFF	; 255
    18f6:	89 83       	std	Y+1, r24	; 0x01
    18f8:	89 81       	ldd	r24, Y+1	; 0x01
    18fa:	83 30       	cpi	r24, 0x03	; 3
    18fc:	18 f3       	brcs	.-58     	; 0x18c4 <__vector_104+0x7a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    18fe:	80 ea       	ldi	r24, 0xA0	; 160
    1900:	96 e0       	ldi	r25, 0x06	; 6
    1902:	22 e0       	ldi	r18, 0x02	; 2
    1904:	fc 01       	movw	r30, r24
    1906:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1908:	80 e0       	ldi	r24, 0x00	; 0
    190a:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0xFF; // sign extension if negative
    190e:	80 91 5a 50 	lds	r24, 0x505A
    1912:	88 23       	and	r24, r24
    1914:	9c f4       	brge	.+38     	; 0x193c <__vector_104+0xf2>
    1916:	80 91 69 50 	lds	r24, 0x5069
    191a:	90 91 6a 50 	lds	r25, 0x506A
    191e:	a0 91 6b 50 	lds	r26, 0x506B
    1922:	b0 91 6c 50 	lds	r27, 0x506C
    1926:	88 0f       	add	r24, r24
    1928:	99 1f       	adc	r25, r25
    192a:	88 0f       	add	r24, r24
    192c:	99 1f       	adc	r25, r25
    192e:	03 96       	adiw	r24, 0x03	; 3
    1930:	88 5a       	subi	r24, 0xA8	; 168
    1932:	9f 4b       	sbci	r25, 0xBF	; 191
    1934:	2f ef       	ldi	r18, 0xFF	; 255
    1936:	fc 01       	movw	r30, r24
    1938:	20 83       	st	Z, r18
    193a:	11 c0       	rjmp	.+34     	; 0x195e <__vector_104+0x114>
		else *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0x00;
    193c:	80 91 69 50 	lds	r24, 0x5069
    1940:	90 91 6a 50 	lds	r25, 0x506A
    1944:	a0 91 6b 50 	lds	r26, 0x506B
    1948:	b0 91 6c 50 	lds	r27, 0x506C
    194c:	88 0f       	add	r24, r24
    194e:	99 1f       	adc	r25, r25
    1950:	88 0f       	add	r24, r24
    1952:	99 1f       	adc	r25, r25
    1954:	03 96       	adiw	r24, 0x03	; 3
    1956:	88 5a       	subi	r24, 0xA8	; 168
    1958:	9f 4b       	sbci	r25, 0xBF	; 191
    195a:	fc 01       	movw	r30, r24
    195c:	10 82       	st	Z, r1
	
		*(((uint8_t*)&data24Bit[sampleCount]) + 2) = SPIBuffer[0];
    195e:	80 91 69 50 	lds	r24, 0x5069
    1962:	90 91 6a 50 	lds	r25, 0x506A
    1966:	a0 91 6b 50 	lds	r26, 0x506B
    196a:	b0 91 6c 50 	lds	r27, 0x506C
    196e:	88 0f       	add	r24, r24
    1970:	99 1f       	adc	r25, r25
    1972:	88 0f       	add	r24, r24
    1974:	99 1f       	adc	r25, r25
    1976:	02 96       	adiw	r24, 0x02	; 2
    1978:	88 5a       	subi	r24, 0xA8	; 168
    197a:	9f 4b       	sbci	r25, 0xBF	; 191
    197c:	20 91 5a 50 	lds	r18, 0x505A
    1980:	fc 01       	movw	r30, r24
    1982:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[sampleCount]) + 1) = SPIBuffer[1];
    1984:	80 91 69 50 	lds	r24, 0x5069
    1988:	90 91 6a 50 	lds	r25, 0x506A
    198c:	a0 91 6b 50 	lds	r26, 0x506B
    1990:	b0 91 6c 50 	lds	r27, 0x506C
    1994:	88 0f       	add	r24, r24
    1996:	99 1f       	adc	r25, r25
    1998:	88 0f       	add	r24, r24
    199a:	99 1f       	adc	r25, r25
    199c:	01 96       	adiw	r24, 0x01	; 1
    199e:	88 5a       	subi	r24, 0xA8	; 168
    19a0:	9f 4b       	sbci	r25, 0xBF	; 191
    19a2:	20 91 5b 50 	lds	r18, 0x505B
    19a6:	fc 01       	movw	r30, r24
    19a8:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[sampleCount]) + 0) = SPIBuffer[2];
    19aa:	80 91 69 50 	lds	r24, 0x5069
    19ae:	90 91 6a 50 	lds	r25, 0x506A
    19b2:	a0 91 6b 50 	lds	r26, 0x506B
    19b6:	b0 91 6c 50 	lds	r27, 0x506C
    19ba:	88 0f       	add	r24, r24
    19bc:	99 1f       	adc	r25, r25
    19be:	88 0f       	add	r24, r24
    19c0:	99 1f       	adc	r25, r25
    19c2:	88 5a       	subi	r24, 0xA8	; 168
    19c4:	9f 4b       	sbci	r25, 0xBF	; 191
    19c6:	20 91 5c 50 	lds	r18, 0x505C
    19ca:	fc 01       	movw	r30, r24
    19cc:	20 83       	st	Z, r18
		
		ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)data24Bit[sampleCount] * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    19ce:	20 91 67 50 	lds	r18, 0x5067
    19d2:	30 91 68 50 	lds	r19, 0x5068
    19d6:	80 91 69 50 	lds	r24, 0x5069
    19da:	90 91 6a 50 	lds	r25, 0x506A
    19de:	a0 91 6b 50 	lds	r26, 0x506B
    19e2:	b0 91 6c 50 	lds	r27, 0x506C
    19e6:	88 0f       	add	r24, r24
    19e8:	99 1f       	adc	r25, r25
    19ea:	88 0f       	add	r24, r24
    19ec:	99 1f       	adc	r25, r25
    19ee:	a9 01       	movw	r20, r18
    19f0:	48 0f       	add	r20, r24
    19f2:	59 1f       	adc	r21, r25
    19f4:	4a 83       	std	Y+2, r20	; 0x02
    19f6:	5b 83       	std	Y+3, r21	; 0x03
    19f8:	80 91 69 50 	lds	r24, 0x5069
    19fc:	90 91 6a 50 	lds	r25, 0x506A
    1a00:	a0 91 6b 50 	lds	r26, 0x506B
    1a04:	b0 91 6c 50 	lds	r27, 0x506C
    1a08:	88 0f       	add	r24, r24
    1a0a:	99 1f       	adc	r25, r25
    1a0c:	88 0f       	add	r24, r24
    1a0e:	99 1f       	adc	r25, r25
    1a10:	88 5a       	subi	r24, 0xA8	; 168
    1a12:	9f 4b       	sbci	r25, 0xBF	; 191
    1a14:	fc 01       	movw	r30, r24
    1a16:	80 81       	ld	r24, Z
    1a18:	91 81       	ldd	r25, Z+1	; 0x01
    1a1a:	a2 81       	ldd	r26, Z+2	; 0x02
    1a1c:	b3 81       	ldd	r27, Z+3	; 0x03
    1a1e:	5c 01       	movw	r10, r24
    1a20:	6d 01       	movw	r12, r26
    1a22:	bb 0f       	add	r27, r27
    1a24:	88 0b       	sbc	r24, r24
    1a26:	98 2f       	mov	r25, r24
    1a28:	dc 01       	movw	r26, r24
    1a2a:	e8 2e       	mov	r14, r24
    1a2c:	f8 2e       	mov	r15, r24
    1a2e:	08 2f       	mov	r16, r24
    1a30:	18 2f       	mov	r17, r24
    1a32:	2a 2d       	mov	r18, r10
    1a34:	3b 2d       	mov	r19, r11
    1a36:	4c 2d       	mov	r20, r12
    1a38:	5d 2d       	mov	r21, r13
    1a3a:	6e 2d       	mov	r22, r14
    1a3c:	7f 2d       	mov	r23, r15
    1a3e:	80 2f       	mov	r24, r16
    1a40:	91 2f       	mov	r25, r17
    1a42:	0f 2e       	mov	r0, r31
    1a44:	f0 ea       	ldi	r31, 0xA0	; 160
    1a46:	af 2e       	mov	r10, r31
    1a48:	f0 2d       	mov	r31, r0
    1a4a:	0f 2e       	mov	r0, r31
    1a4c:	f5 e2       	ldi	r31, 0x25	; 37
    1a4e:	bf 2e       	mov	r11, r31
    1a50:	f0 2d       	mov	r31, r0
    1a52:	0f 2e       	mov	r0, r31
    1a54:	f6 e2       	ldi	r31, 0x26	; 38
    1a56:	cf 2e       	mov	r12, r31
    1a58:	f0 2d       	mov	r31, r0
    1a5a:	dd 24       	eor	r13, r13
    1a5c:	ee 24       	eor	r14, r14
    1a5e:	ff 24       	eor	r15, r15
    1a60:	00 e0       	ldi	r16, 0x00	; 0
    1a62:	10 e0       	ldi	r17, 0x00	; 0
    1a64:	0e 94 4d 52 	call	0xa49a	; 0xa49a <__muldi3>
    1a68:	22 2e       	mov	r2, r18
    1a6a:	33 2e       	mov	r3, r19
    1a6c:	44 2e       	mov	r4, r20
    1a6e:	55 2e       	mov	r5, r21
    1a70:	66 2e       	mov	r6, r22
    1a72:	77 2e       	mov	r7, r23
    1a74:	88 2e       	mov	r8, r24
    1a76:	99 2e       	mov	r9, r25
    1a78:	a2 2c       	mov	r10, r2
    1a7a:	b3 2c       	mov	r11, r3
    1a7c:	c4 2c       	mov	r12, r4
    1a7e:	d5 2c       	mov	r13, r5
    1a80:	e6 2c       	mov	r14, r6
    1a82:	f7 2c       	mov	r15, r7
    1a84:	08 2d       	mov	r16, r8
    1a86:	19 2d       	mov	r17, r9
    1a88:	2a 2d       	mov	r18, r10
    1a8a:	3b 2d       	mov	r19, r11
    1a8c:	4c 2d       	mov	r20, r12
    1a8e:	5d 2d       	mov	r21, r13
    1a90:	6e 2d       	mov	r22, r14
    1a92:	7f 2d       	mov	r23, r15
    1a94:	80 2f       	mov	r24, r16
    1a96:	91 2f       	mov	r25, r17
    1a98:	aa 24       	eor	r10, r10
    1a9a:	aa 94       	dec	r10
    1a9c:	bb 24       	eor	r11, r11
    1a9e:	ba 94       	dec	r11
    1aa0:	0f 2e       	mov	r0, r31
    1aa2:	ff e7       	ldi	r31, 0x7F	; 127
    1aa4:	cf 2e       	mov	r12, r31
    1aa6:	f0 2d       	mov	r31, r0
    1aa8:	dd 24       	eor	r13, r13
    1aaa:	ee 24       	eor	r14, r14
    1aac:	ff 24       	eor	r15, r15
    1aae:	00 e0       	ldi	r16, 0x00	; 0
    1ab0:	10 e0       	ldi	r17, 0x00	; 0
    1ab2:	0e 94 50 5b 	call	0xb6a0	; 0xb6a0 <__udivdi3>
    1ab6:	22 2e       	mov	r2, r18
    1ab8:	33 2e       	mov	r3, r19
    1aba:	44 2e       	mov	r4, r20
    1abc:	55 2e       	mov	r5, r21
    1abe:	66 2e       	mov	r6, r22
    1ac0:	77 2e       	mov	r7, r23
    1ac2:	88 2e       	mov	r8, r24
    1ac4:	99 2e       	mov	r9, r25
    1ac6:	a2 2c       	mov	r10, r2
    1ac8:	b3 2c       	mov	r11, r3
    1aca:	c4 2c       	mov	r12, r4
    1acc:	d5 2c       	mov	r13, r5
    1ace:	e6 2c       	mov	r14, r6
    1ad0:	f7 2c       	mov	r15, r7
    1ad2:	08 2d       	mov	r16, r8
    1ad4:	19 2d       	mov	r17, r9
    1ad6:	2a 2d       	mov	r18, r10
    1ad8:	3b 2d       	mov	r19, r11
    1ada:	4c 2d       	mov	r20, r12
    1adc:	5d 2d       	mov	r21, r13
    1ade:	6e 2d       	mov	r22, r14
    1ae0:	7f 2d       	mov	r23, r15
    1ae2:	80 2f       	mov	r24, r16
    1ae4:	91 2f       	mov	r25, r17
    1ae6:	01 e0       	ldi	r16, 0x01	; 1
    1ae8:	0e 94 20 53 	call	0xa640	; 0xa640 <__ashldi3>
    1aec:	22 2e       	mov	r2, r18
    1aee:	33 2e       	mov	r3, r19
    1af0:	44 2e       	mov	r4, r20
    1af2:	55 2e       	mov	r5, r21
    1af4:	66 2e       	mov	r6, r22
    1af6:	77 2e       	mov	r7, r23
    1af8:	88 2e       	mov	r8, r24
    1afa:	99 2e       	mov	r9, r25
    1afc:	a2 2c       	mov	r10, r2
    1afe:	b3 2c       	mov	r11, r3
    1b00:	c4 2c       	mov	r12, r4
    1b02:	d5 2c       	mov	r13, r5
    1b04:	e6 2c       	mov	r14, r6
    1b06:	f7 2c       	mov	r15, r7
    1b08:	08 2d       	mov	r16, r8
    1b0a:	19 2d       	mov	r17, r9
    1b0c:	2a 2d       	mov	r18, r10
    1b0e:	3b 2d       	mov	r19, r11
    1b10:	4c 2d       	mov	r20, r12
    1b12:	5d 2d       	mov	r21, r13
    1b14:	6e 2d       	mov	r22, r14
    1b16:	7f 2d       	mov	r23, r15
    1b18:	80 2f       	mov	r24, r16
    1b1a:	91 2f       	mov	r25, r17
    1b1c:	0f 2e       	mov	r0, r31
    1b1e:	f3 e0       	ldi	r31, 0x03	; 3
    1b20:	af 2e       	mov	r10, r31
    1b22:	f0 2d       	mov	r31, r0
    1b24:	bb 24       	eor	r11, r11
    1b26:	cc 24       	eor	r12, r12
    1b28:	dd 24       	eor	r13, r13
    1b2a:	ee 24       	eor	r14, r14
    1b2c:	ff 24       	eor	r15, r15
    1b2e:	00 e0       	ldi	r16, 0x00	; 0
    1b30:	10 e0       	ldi	r17, 0x00	; 0
    1b32:	0e 94 50 5b 	call	0xb6a0	; 0xb6a0 <__udivdi3>
    1b36:	a2 2e       	mov	r10, r18
    1b38:	b3 2e       	mov	r11, r19
    1b3a:	c4 2e       	mov	r12, r20
    1b3c:	d5 2e       	mov	r13, r21
    1b3e:	e6 2e       	mov	r14, r22
    1b40:	f7 2e       	mov	r15, r23
    1b42:	08 2f       	mov	r16, r24
    1b44:	19 2f       	mov	r17, r25
    1b46:	2a 2d       	mov	r18, r10
    1b48:	3b 2d       	mov	r19, r11
    1b4a:	4c 2d       	mov	r20, r12
    1b4c:	5d 2d       	mov	r21, r13
    1b4e:	6e 2d       	mov	r22, r14
    1b50:	7f 2d       	mov	r23, r15
    1b52:	80 2f       	mov	r24, r16
    1b54:	91 2f       	mov	r25, r17
    1b56:	da 01       	movw	r26, r20
    1b58:	c9 01       	movw	r24, r18
    1b5a:	b0 95       	com	r27
    1b5c:	a0 95       	com	r26
    1b5e:	90 95       	com	r25
    1b60:	81 95       	neg	r24
    1b62:	9f 4f       	sbci	r25, 0xFF	; 255
    1b64:	af 4f       	sbci	r26, 0xFF	; 255
    1b66:	bf 4f       	sbci	r27, 0xFF	; 255
    1b68:	ea 81       	ldd	r30, Y+2	; 0x02
    1b6a:	fb 81       	ldd	r31, Y+3	; 0x03
    1b6c:	80 83       	st	Z, r24
    1b6e:	91 83       	std	Z+1, r25	; 0x01
    1b70:	a2 83       	std	Z+2, r26	; 0x02
    1b72:	b3 83       	std	Z+3, r27	; 0x03

		sampleCount++;
    1b74:	80 91 69 50 	lds	r24, 0x5069
    1b78:	90 91 6a 50 	lds	r25, 0x506A
    1b7c:	a0 91 6b 50 	lds	r26, 0x506B
    1b80:	b0 91 6c 50 	lds	r27, 0x506C
    1b84:	01 96       	adiw	r24, 0x01	; 1
    1b86:	a1 1d       	adc	r26, r1
    1b88:	b1 1d       	adc	r27, r1
    1b8a:	80 93 69 50 	sts	0x5069, r24
    1b8e:	90 93 6a 50 	sts	0x506A, r25
    1b92:	a0 93 6b 50 	sts	0x506B, r26
    1b96:	b0 93 6c 50 	sts	0x506C, r27
	}
}
    1b9a:	23 96       	adiw	r28, 0x03	; 3
    1b9c:	cd bf       	out	0x3d, r28	; 61
    1b9e:	de bf       	out	0x3e, r29	; 62
    1ba0:	df 91       	pop	r29
    1ba2:	cf 91       	pop	r28
    1ba4:	ff 91       	pop	r31
    1ba6:	ef 91       	pop	r30
    1ba8:	bf 91       	pop	r27
    1baa:	af 91       	pop	r26
    1bac:	9f 91       	pop	r25
    1bae:	8f 91       	pop	r24
    1bb0:	7f 91       	pop	r23
    1bb2:	6f 91       	pop	r22
    1bb4:	5f 91       	pop	r21
    1bb6:	4f 91       	pop	r20
    1bb8:	3f 91       	pop	r19
    1bba:	2f 91       	pop	r18
    1bbc:	1f 91       	pop	r17
    1bbe:	0f 91       	pop	r16
    1bc0:	ff 90       	pop	r15
    1bc2:	ef 90       	pop	r14
    1bc4:	df 90       	pop	r13
    1bc6:	cf 90       	pop	r12
    1bc8:	bf 90       	pop	r11
    1bca:	af 90       	pop	r10
    1bcc:	9f 90       	pop	r9
    1bce:	8f 90       	pop	r8
    1bd0:	7f 90       	pop	r7
    1bd2:	6f 90       	pop	r6
    1bd4:	5f 90       	pop	r5
    1bd6:	4f 90       	pop	r4
    1bd8:	3f 90       	pop	r3
    1bda:	2f 90       	pop	r2
    1bdc:	0f 90       	pop	r0
    1bde:	00 92 3b 00 	sts	0x003B, r0
    1be2:	0f 90       	pop	r0
    1be4:	0f be       	out	0x3f, r0	; 63
    1be6:	0f 90       	pop	r0
    1be8:	1f 90       	pop	r1
    1bea:	18 95       	reti

00001bec <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
    1bec:	cf 93       	push	r28
    1bee:	df 93       	push	r29
    1bf0:	0f 92       	push	r0
    1bf2:	cd b7       	in	r28, 0x3d	; 61
    1bf4:	de b7       	in	r29, 0x3e	; 62
    1bf6:	89 83       	std	Y+1, r24	; 0x01
	if (enable) {
    1bf8:	89 81       	ldd	r24, Y+1	; 0x01
    1bfa:	88 23       	and	r24, r24
    1bfc:	49 f0       	breq	.+18     	; 0x1c10 <ACC_DCPassEnable+0x24>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1bfe:	80 e2       	ldi	r24, 0x20	; 32
    1c00:	60 e0       	ldi	r22, 0x00	; 0
    1c02:	0e 94 a8 33 	call	0x6750	; 0x6750 <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1c06:	80 e2       	ldi	r24, 0x20	; 32
    1c08:	60 e0       	ldi	r22, 0x00	; 0
    1c0a:	0e 94 74 34 	call	0x68e8	; 0x68e8 <PortEx_OUTSET>
    1c0e:	04 c0       	rjmp	.+8      	; 0x1c18 <ACC_DCPassEnable+0x2c>
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1c10:	80 e2       	ldi	r24, 0x20	; 32
    1c12:	60 e0       	ldi	r22, 0x00	; 0
    1c14:	0e 94 0c 34 	call	0x6818	; 0x6818 <PortEx_DIRCLR>
		//setPortEx(0x00, PS_BANKB);
	}
}
    1c18:	0f 90       	pop	r0
    1c1a:	df 91       	pop	r29
    1c1c:	cf 91       	pop	r28
    1c1e:	08 95       	ret

00001c20 <CO_collectSeismic3Channel>:

void CO_collectSeismic3Channel(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD) {
    1c20:	8f 92       	push	r8
    1c22:	9f 92       	push	r9
    1c24:	af 92       	push	r10
    1c26:	bf 92       	push	r11
    1c28:	cf 92       	push	r12
    1c2a:	df 92       	push	r13
    1c2c:	ef 92       	push	r14
    1c2e:	ff 92       	push	r15
    1c30:	0f 93       	push	r16
    1c32:	cf 93       	push	r28
    1c34:	df 93       	push	r29
    1c36:	cd b7       	in	r28, 0x3d	; 61
    1c38:	de b7       	in	r29, 0x3e	; 62
    1c3a:	2e 97       	sbiw	r28, 0x0e	; 14
    1c3c:	cd bf       	out	0x3d, r28	; 61
    1c3e:	de bf       	out	0x3e, r29	; 62
    1c40:	89 83       	std	Y+1, r24	; 0x01
    1c42:	6a 83       	std	Y+2, r22	; 0x02
    1c44:	7b 83       	std	Y+3, r23	; 0x03
    1c46:	4c 83       	std	Y+4, r20	; 0x04
    1c48:	2d 83       	std	Y+5, r18	; 0x05
    1c4a:	0e 83       	std	Y+6, r16	; 0x06
    1c4c:	ef 82       	std	Y+7, r14	; 0x07
    1c4e:	f8 86       	std	Y+8, r15	; 0x08
    1c50:	c9 86       	std	Y+9, r12	; 0x09
    1c52:	da 86       	std	Y+10, r13	; 0x0a
    1c54:	ab 86       	std	Y+11, r10	; 0x0b
    1c56:	bc 86       	std	Y+12, r11	; 0x0c
    1c58:	8d 86       	std	Y+13, r8	; 0x0d
    1c5a:	9e 86       	std	Y+14, r9	; 0x0e
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1c5c:	81 e0       	ldi	r24, 0x01	; 1
    1c5e:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    1c62:	8a 81       	ldd	r24, Y+2	; 0x02
    1c64:	9b 81       	ldd	r25, Y+3	; 0x03
    1c66:	fc 01       	movw	r30, r24
    1c68:	90 81       	ld	r25, Z
    1c6a:	85 e0       	ldi	r24, 0x05	; 5
    1c6c:	69 2f       	mov	r22, r25
    1c6e:	0e 94 bd 06 	call	0xd7a	; 0xd7a <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    1c72:	8a 81       	ldd	r24, Y+2	; 0x02
    1c74:	9b 81       	ldd	r25, Y+3	; 0x03
    1c76:	01 96       	adiw	r24, 0x01	; 1
    1c78:	fc 01       	movw	r30, r24
    1c7a:	90 81       	ld	r25, Z
    1c7c:	86 e0       	ldi	r24, 0x06	; 6
    1c7e:	69 2f       	mov	r22, r25
    1c80:	0e 94 bd 06 	call	0xd7a	; 0xd7a <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    1c84:	8a 81       	ldd	r24, Y+2	; 0x02
    1c86:	9b 81       	ldd	r25, Y+3	; 0x03
    1c88:	02 96       	adiw	r24, 0x02	; 2
    1c8a:	fc 01       	movw	r30, r24
    1c8c:	90 81       	ld	r25, Z
    1c8e:	87 e0       	ldi	r24, 0x07	; 7
    1c90:	69 2f       	mov	r22, r25
    1c92:	0e 94 bd 06 	call	0xd7a	; 0xd7a <set_ampGain>
	set_filter(filterConfig);
    1c96:	89 81       	ldd	r24, Y+1	; 0x01
    1c98:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    1c9c:	8e 81       	ldd	r24, Y+6	; 0x06
    1c9e:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    1ca2:	84 e0       	ldi	r24, 0x04	; 4
    1ca4:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1ca8:	80 ec       	ldi	r24, 0xC0	; 192
    1caa:	98 e0       	ldi	r25, 0x08	; 8
    1cac:	24 e5       	ldi	r18, 0x54	; 84
    1cae:	fc 01       	movw	r30, r24
    1cb0:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    1cb2:	81 e0       	ldi	r24, 0x01	; 1
    1cb4:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    1cb8:	85 e0       	ldi	r24, 0x05	; 5
    1cba:	0e 94 de 1a 	call	0x35bc	; 0x35bc <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    1cbe:	80 ea       	ldi	r24, 0xA0	; 160
    1cc0:	96 e0       	ldi	r25, 0x06	; 6
    1cc2:	22 e0       	ldi	r18, 0x02	; 2
    1cc4:	fc 01       	movw	r30, r24
    1cc6:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    1cc8:	80 ea       	ldi	r24, 0xA0	; 160
    1cca:	96 e0       	ldi	r25, 0x06	; 6
    1ccc:	21 e0       	ldi	r18, 0x01	; 1
    1cce:	fc 01       	movw	r30, r24
    1cd0:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    1cd2:	80 e8       	ldi	r24, 0x80	; 128
    1cd4:	91 e0       	ldi	r25, 0x01	; 1
    1cd6:	28 e7       	ldi	r18, 0x78	; 120
    1cd8:	fc 01       	movw	r30, r24
    1cda:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    1cdc:	80 e0       	ldi	r24, 0x00	; 0
    1cde:	98 e0       	ldi	r25, 0x08	; 8
    1ce0:	20 ef       	ldi	r18, 0xF0	; 240
    1ce2:	fc 01       	movw	r30, r24
    1ce4:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    1ce6:	80 e0       	ldi	r24, 0x00	; 0
    1ce8:	98 e0       	ldi	r25, 0x08	; 8
    1cea:	2f 81       	ldd	r18, Y+7	; 0x07
    1cec:	38 85       	ldd	r19, Y+8	; 0x08
    1cee:	fc 01       	movw	r30, r24
    1cf0:	20 a7       	lds	r18, 0x70
    1cf2:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    1cf4:	80 e0       	ldi	r24, 0x00	; 0
    1cf6:	98 e0       	ldi	r25, 0x08	; 8
    1cf8:	29 85       	ldd	r18, Y+9	; 0x09
    1cfa:	3a 85       	ldd	r19, Y+10	; 0x0a
    1cfc:	fc 01       	movw	r30, r24
    1cfe:	22 a7       	lds	r18, 0x72
    1d00:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    1d02:	80 e0       	ldi	r24, 0x00	; 0
    1d04:	98 e0       	ldi	r25, 0x08	; 8
    1d06:	2b 85       	ldd	r18, Y+11	; 0x0b
    1d08:	3c 85       	ldd	r19, Y+12	; 0x0c
    1d0a:	fc 01       	movw	r30, r24
    1d0c:	24 a7       	lds	r18, 0x74
    1d0e:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    1d10:	80 e0       	ldi	r24, 0x00	; 0
    1d12:	98 e0       	ldi	r25, 0x08	; 8
    1d14:	2d 85       	ldd	r18, Y+13	; 0x0d
    1d16:	3e 85       	ldd	r19, Y+14	; 0x0e
    1d18:	fc 01       	movw	r30, r24
    1d1a:	26 a7       	lds	r18, 0x76
    1d1c:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    1d1e:	80 e0       	ldi	r24, 0x00	; 0
    1d20:	98 e0       	ldi	r25, 0x08	; 8
    1d22:	2d 81       	ldd	r18, Y+5	; 0x05
    1d24:	22 2f       	mov	r18, r18
    1d26:	30 e0       	ldi	r19, 0x00	; 0
    1d28:	21 50       	subi	r18, 0x01	; 1
    1d2a:	30 40       	sbci	r19, 0x00	; 0
    1d2c:	fc 01       	movw	r30, r24
    1d2e:	26 a3       	lds	r18, 0x56
    1d30:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    1d32:	80 e0       	ldi	r24, 0x00	; 0
    1d34:	98 e0       	ldi	r25, 0x08	; 8
    1d36:	22 e0       	ldi	r18, 0x02	; 2
    1d38:	fc 01       	movw	r30, r24
    1d3a:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    1d3c:	80 e0       	ldi	r24, 0x00	; 0
    1d3e:	98 e0       	ldi	r25, 0x08	; 8
    1d40:	2f ef       	ldi	r18, 0xFF	; 255
    1d42:	fc 01       	movw	r30, r24
    1d44:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    1d46:	80 e0       	ldi	r24, 0x00	; 0
    1d48:	98 e0       	ldi	r25, 0x08	; 8
    1d4a:	20 e0       	ldi	r18, 0x00	; 0
    1d4c:	38 e0       	ldi	r19, 0x08	; 8
    1d4e:	f9 01       	movw	r30, r18
    1d50:	20 81       	ld	r18, Z
    1d52:	20 7f       	andi	r18, 0xF0	; 240
    1d54:	28 60       	ori	r18, 0x08	; 8
    1d56:	fc 01       	movw	r30, r24
    1d58:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    1d5a:	10 92 44 40 	sts	0x4044, r1
    1d5e:	10 92 45 40 	sts	0x4045, r1
	sampleCount = 0;
    1d62:	10 92 69 50 	sts	0x5069, r1
    1d66:	10 92 6a 50 	sts	0x506A, r1
    1d6a:	10 92 6b 50 	sts	0x506B, r1
    1d6e:	10 92 6c 50 	sts	0x506C, r1
	SPICount = 0;
    1d72:	10 92 c3 50 	sts	0x50C3, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    1d76:	80 e0       	ldi	r24, 0x00	; 0
    1d78:	80 93 28 21 	sts	0x2128, r24
    1d7c:	80 93 27 21 	sts	0x2127, r24
    1d80:	80 93 26 21 	sts	0x2126, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    1d84:	80 ea       	ldi	r24, 0xA0	; 160
    1d86:	90 e0       	ldi	r25, 0x00	; 0
    1d88:	20 ea       	ldi	r18, 0xA0	; 160
    1d8a:	30 e0       	ldi	r19, 0x00	; 0
    1d8c:	f9 01       	movw	r30, r18
    1d8e:	22 81       	ldd	r18, Z+2	; 0x02
    1d90:	26 60       	ori	r18, 0x06	; 6
    1d92:	fc 01       	movw	r30, r24
    1d94:	22 83       	std	Z+2, r18	; 0x02
	sei();
    1d96:	78 94       	sei

	SPICS(TRUE);
    1d98:	81 e0       	ldi	r24, 0x01	; 1
    1d9a:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    1d9e:	80 e8       	ldi	r24, 0x80	; 128
    1da0:	96 e0       	ldi	r25, 0x06	; 6
    1da2:	20 e2       	ldi	r18, 0x20	; 32
    1da4:	fc 01       	movw	r30, r24
    1da6:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1da8:	80 e4       	ldi	r24, 0x40	; 64
    1daa:	9a e0       	ldi	r25, 0x0A	; 10
    1dac:	23 e2       	ldi	r18, 0x23	; 35
    1dae:	fc 01       	movw	r30, r24
    1db0:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    1db2:	80 e4       	ldi	r24, 0x40	; 64
    1db4:	9a e0       	ldi	r25, 0x0A	; 10
    1db6:	2c 81       	ldd	r18, Y+4	; 0x04
    1db8:	42 2f       	mov	r20, r18
    1dba:	50 e0       	ldi	r21, 0x00	; 0
    1dbc:	20 e2       	ldi	r18, 0x20	; 32
    1dbe:	30 e0       	ldi	r19, 0x00	; 0
    1dc0:	02 c0       	rjmp	.+4      	; 0x1dc6 <CO_collectSeismic3Channel+0x1a6>
    1dc2:	22 0f       	add	r18, r18
    1dc4:	33 1f       	adc	r19, r19
    1dc6:	4a 95       	dec	r20
    1dc8:	e2 f7       	brpl	.-8      	; 0x1dc2 <CO_collectSeismic3Channel+0x1a2>
    1dca:	fc 01       	movw	r30, r24
    1dcc:	26 a3       	lds	r18, 0x56
    1dce:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    1dd0:	80 e4       	ldi	r24, 0x40	; 64
    1dd2:	9a e0       	ldi	r25, 0x0A	; 10
    1dd4:	2c 81       	ldd	r18, Y+4	; 0x04
    1dd6:	42 2f       	mov	r20, r18
    1dd8:	50 e0       	ldi	r21, 0x00	; 0
    1dda:	20 e1       	ldi	r18, 0x10	; 16
    1ddc:	30 e0       	ldi	r19, 0x00	; 0
    1dde:	04 2e       	mov	r0, r20
    1de0:	02 c0       	rjmp	.+4      	; 0x1de6 <CO_collectSeismic3Channel+0x1c6>
    1de2:	22 0f       	add	r18, r18
    1de4:	33 1f       	adc	r19, r19
    1de6:	0a 94       	dec	r0
    1de8:	e2 f7       	brpl	.-8      	; 0x1de2 <CO_collectSeismic3Channel+0x1c2>
    1dea:	fc 01       	movw	r30, r24
    1dec:	22 af       	sts	0x72, r18
    1dee:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1df0:	80 e4       	ldi	r24, 0x40	; 64
    1df2:	9a e0       	ldi	r25, 0x0A	; 10
    1df4:	20 e4       	ldi	r18, 0x40	; 64
    1df6:	3a e0       	ldi	r19, 0x0A	; 10
    1df8:	f9 01       	movw	r30, r18
    1dfa:	20 81       	ld	r18, Z
    1dfc:	20 7f       	andi	r18, 0xF0	; 240
    1dfe:	21 60       	ori	r18, 0x01	; 1
    1e00:	fc 01       	movw	r30, r24
    1e02:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES);
    1e04:	00 00       	nop
    1e06:	80 91 69 50 	lds	r24, 0x5069
    1e0a:	90 91 6a 50 	lds	r25, 0x506A
    1e0e:	a0 91 6b 50 	lds	r26, 0x506B
    1e12:	b0 91 6c 50 	lds	r27, 0x506C
    1e16:	83 35       	cpi	r24, 0x53	; 83
    1e18:	f5 e5       	ldi	r31, 0x55	; 85
    1e1a:	9f 07       	cpc	r25, r31
    1e1c:	f0 e0       	ldi	r31, 0x00	; 0
    1e1e:	af 07       	cpc	r26, r31
    1e20:	f0 e0       	ldi	r31, 0x00	; 0
    1e22:	bf 07       	cpc	r27, r31
    1e24:	80 f3       	brcs	.-32     	; 0x1e06 <CO_collectSeismic3Channel+0x1e6>

	// turn off timer and interrupts
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1e26:	80 e0       	ldi	r24, 0x00	; 0
    1e28:	98 e0       	ldi	r25, 0x08	; 8
    1e2a:	20 e0       	ldi	r18, 0x00	; 0
    1e2c:	38 e0       	ldi	r19, 0x08	; 8
    1e2e:	f9 01       	movw	r30, r18
    1e30:	20 81       	ld	r18, Z
    1e32:	20 7f       	andi	r18, 0xF0	; 240
    1e34:	fc 01       	movw	r30, r24
    1e36:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1e38:	80 e4       	ldi	r24, 0x40	; 64
    1e3a:	9a e0       	ldi	r25, 0x0A	; 10
    1e3c:	20 e4       	ldi	r18, 0x40	; 64
    1e3e:	3a e0       	ldi	r19, 0x0A	; 10
    1e40:	f9 01       	movw	r30, r18
    1e42:	20 81       	ld	r18, Z
    1e44:	20 7f       	andi	r18, 0xF0	; 240
    1e46:	fc 01       	movw	r30, r24
    1e48:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    1e4a:	80 ea       	ldi	r24, 0xA0	; 160
    1e4c:	90 e0       	ldi	r25, 0x00	; 0
    1e4e:	20 ea       	ldi	r18, 0xA0	; 160
    1e50:	30 e0       	ldi	r19, 0x00	; 0
    1e52:	f9 01       	movw	r30, r18
    1e54:	22 81       	ldd	r18, Z+2	; 0x02
    1e56:	29 7f       	andi	r18, 0xF9	; 249
    1e58:	fc 01       	movw	r30, r24
    1e5a:	22 83       	std	Z+2, r18	; 0x02
	cli();
    1e5c:	f8 94       	cli

	SPICS(FALSE);
    1e5e:	80 e0       	ldi	r24, 0x00	; 0
    1e60:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	SPIDisable();
    1e64:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>
	enableADCMUX(FALSE);
    1e68:	80 e0       	ldi	r24, 0x00	; 0
    1e6a:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <enableADCMUX>
	ADCPower(FALSE);
    1e6e:	80 e0       	ldi	r24, 0x00	; 0
    1e70:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	
}
    1e74:	2e 96       	adiw	r28, 0x0e	; 14
    1e76:	cd bf       	out	0x3d, r28	; 61
    1e78:	de bf       	out	0x3e, r29	; 62
    1e7a:	df 91       	pop	r29
    1e7c:	cf 91       	pop	r28
    1e7e:	0f 91       	pop	r16
    1e80:	ff 90       	pop	r15
    1e82:	ef 90       	pop	r14
    1e84:	df 90       	pop	r13
    1e86:	cf 90       	pop	r12
    1e88:	bf 90       	pop	r11
    1e8a:	af 90       	pop	r10
    1e8c:	9f 90       	pop	r9
    1e8e:	8f 90       	pop	r8
    1e90:	08 95       	ret

00001e92 <CO_collectSeismic3Channel_2>:

void CO_collectSeismic3Channel_2(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint32_t numOfSamples, uint32_t* DataArray) {
    1e92:	8f 92       	push	r8
    1e94:	9f 92       	push	r9
    1e96:	af 92       	push	r10
    1e98:	bf 92       	push	r11
    1e9a:	cf 92       	push	r12
    1e9c:	df 92       	push	r13
    1e9e:	ef 92       	push	r14
    1ea0:	ff 92       	push	r15
    1ea2:	0f 93       	push	r16
    1ea4:	cf 93       	push	r28
    1ea6:	df 93       	push	r29
    1ea8:	cd b7       	in	r28, 0x3d	; 61
    1eaa:	de b7       	in	r29, 0x3e	; 62
    1eac:	2e 97       	sbiw	r28, 0x0e	; 14
    1eae:	cd bf       	out	0x3d, r28	; 61
    1eb0:	de bf       	out	0x3e, r29	; 62
    1eb2:	89 83       	std	Y+1, r24	; 0x01
    1eb4:	6a 83       	std	Y+2, r22	; 0x02
    1eb6:	7b 83       	std	Y+3, r23	; 0x03
    1eb8:	4c 83       	std	Y+4, r20	; 0x04
    1eba:	2d 83       	std	Y+5, r18	; 0x05
    1ebc:	0e 83       	std	Y+6, r16	; 0x06
    1ebe:	ef 82       	std	Y+7, r14	; 0x07
    1ec0:	f8 86       	std	Y+8, r15	; 0x08
    1ec2:	c9 86       	std	Y+9, r12	; 0x09
    1ec4:	da 86       	std	Y+10, r13	; 0x0a
    1ec6:	ab 86       	std	Y+11, r10	; 0x0b
    1ec8:	bc 86       	std	Y+12, r11	; 0x0c
    1eca:	8d 86       	std	Y+13, r8	; 0x0d
    1ecc:	9e 86       	std	Y+14, r9	; 0x0e
	
	ADC_BUFFER = DataArray;
    1ece:	89 a1       	lds	r24, 0x49
    1ed0:	9a a1       	lds	r25, 0x4a
    1ed2:	80 93 67 50 	sts	0x5067, r24
    1ed6:	90 93 68 50 	sts	0x5068, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1eda:	81 e0       	ldi	r24, 0x01	; 1
    1edc:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    1ee0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ee2:	9b 81       	ldd	r25, Y+3	; 0x03
    1ee4:	fc 01       	movw	r30, r24
    1ee6:	90 81       	ld	r25, Z
    1ee8:	85 e0       	ldi	r24, 0x05	; 5
    1eea:	69 2f       	mov	r22, r25
    1eec:	0e 94 bd 06 	call	0xd7a	; 0xd7a <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    1ef0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ef2:	9b 81       	ldd	r25, Y+3	; 0x03
    1ef4:	01 96       	adiw	r24, 0x01	; 1
    1ef6:	fc 01       	movw	r30, r24
    1ef8:	90 81       	ld	r25, Z
    1efa:	86 e0       	ldi	r24, 0x06	; 6
    1efc:	69 2f       	mov	r22, r25
    1efe:	0e 94 bd 06 	call	0xd7a	; 0xd7a <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    1f02:	8a 81       	ldd	r24, Y+2	; 0x02
    1f04:	9b 81       	ldd	r25, Y+3	; 0x03
    1f06:	02 96       	adiw	r24, 0x02	; 2
    1f08:	fc 01       	movw	r30, r24
    1f0a:	90 81       	ld	r25, Z
    1f0c:	87 e0       	ldi	r24, 0x07	; 7
    1f0e:	69 2f       	mov	r22, r25
    1f10:	0e 94 bd 06 	call	0xd7a	; 0xd7a <set_ampGain>
	set_filter(filterConfig);
    1f14:	89 81       	ldd	r24, Y+1	; 0x01
    1f16:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    1f1a:	8e 81       	ldd	r24, Y+6	; 0x06
    1f1c:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    1f20:	84 e0       	ldi	r24, 0x04	; 4
    1f22:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1f26:	80 ec       	ldi	r24, 0xC0	; 192
    1f28:	98 e0       	ldi	r25, 0x08	; 8
    1f2a:	24 e5       	ldi	r18, 0x54	; 84
    1f2c:	fc 01       	movw	r30, r24
    1f2e:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    1f30:	81 e0       	ldi	r24, 0x01	; 1
    1f32:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    1f36:	85 e0       	ldi	r24, 0x05	; 5
    1f38:	0e 94 de 1a 	call	0x35bc	; 0x35bc <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    1f3c:	80 ea       	ldi	r24, 0xA0	; 160
    1f3e:	96 e0       	ldi	r25, 0x06	; 6
    1f40:	22 e0       	ldi	r18, 0x02	; 2
    1f42:	fc 01       	movw	r30, r24
    1f44:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    1f46:	80 ea       	ldi	r24, 0xA0	; 160
    1f48:	96 e0       	ldi	r25, 0x06	; 6
    1f4a:	21 e0       	ldi	r18, 0x01	; 1
    1f4c:	fc 01       	movw	r30, r24
    1f4e:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    1f50:	80 e8       	ldi	r24, 0x80	; 128
    1f52:	91 e0       	ldi	r25, 0x01	; 1
    1f54:	28 e7       	ldi	r18, 0x78	; 120
    1f56:	fc 01       	movw	r30, r24
    1f58:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    1f5a:	80 e0       	ldi	r24, 0x00	; 0
    1f5c:	98 e0       	ldi	r25, 0x08	; 8
    1f5e:	20 ef       	ldi	r18, 0xF0	; 240
    1f60:	fc 01       	movw	r30, r24
    1f62:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    1f64:	80 e0       	ldi	r24, 0x00	; 0
    1f66:	98 e0       	ldi	r25, 0x08	; 8
    1f68:	2f 81       	ldd	r18, Y+7	; 0x07
    1f6a:	38 85       	ldd	r19, Y+8	; 0x08
    1f6c:	fc 01       	movw	r30, r24
    1f6e:	20 a7       	lds	r18, 0x70
    1f70:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    1f72:	80 e0       	ldi	r24, 0x00	; 0
    1f74:	98 e0       	ldi	r25, 0x08	; 8
    1f76:	29 85       	ldd	r18, Y+9	; 0x09
    1f78:	3a 85       	ldd	r19, Y+10	; 0x0a
    1f7a:	fc 01       	movw	r30, r24
    1f7c:	22 a7       	lds	r18, 0x72
    1f7e:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    1f80:	80 e0       	ldi	r24, 0x00	; 0
    1f82:	98 e0       	ldi	r25, 0x08	; 8
    1f84:	2b 85       	ldd	r18, Y+11	; 0x0b
    1f86:	3c 85       	ldd	r19, Y+12	; 0x0c
    1f88:	fc 01       	movw	r30, r24
    1f8a:	24 a7       	lds	r18, 0x74
    1f8c:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    1f8e:	80 e0       	ldi	r24, 0x00	; 0
    1f90:	98 e0       	ldi	r25, 0x08	; 8
    1f92:	2d 85       	ldd	r18, Y+13	; 0x0d
    1f94:	3e 85       	ldd	r19, Y+14	; 0x0e
    1f96:	fc 01       	movw	r30, r24
    1f98:	26 a7       	lds	r18, 0x76
    1f9a:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    1f9c:	80 e0       	ldi	r24, 0x00	; 0
    1f9e:	98 e0       	ldi	r25, 0x08	; 8
    1fa0:	2d 81       	ldd	r18, Y+5	; 0x05
    1fa2:	22 2f       	mov	r18, r18
    1fa4:	30 e0       	ldi	r19, 0x00	; 0
    1fa6:	21 50       	subi	r18, 0x01	; 1
    1fa8:	30 40       	sbci	r19, 0x00	; 0
    1faa:	fc 01       	movw	r30, r24
    1fac:	26 a3       	lds	r18, 0x56
    1fae:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    1fb0:	80 e0       	ldi	r24, 0x00	; 0
    1fb2:	98 e0       	ldi	r25, 0x08	; 8
    1fb4:	22 e0       	ldi	r18, 0x02	; 2
    1fb6:	fc 01       	movw	r30, r24
    1fb8:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    1fba:	80 e0       	ldi	r24, 0x00	; 0
    1fbc:	98 e0       	ldi	r25, 0x08	; 8
    1fbe:	2f ef       	ldi	r18, 0xFF	; 255
    1fc0:	fc 01       	movw	r30, r24
    1fc2:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    1fc4:	80 e0       	ldi	r24, 0x00	; 0
    1fc6:	98 e0       	ldi	r25, 0x08	; 8
    1fc8:	20 e0       	ldi	r18, 0x00	; 0
    1fca:	38 e0       	ldi	r19, 0x08	; 8
    1fcc:	f9 01       	movw	r30, r18
    1fce:	20 81       	ld	r18, Z
    1fd0:	20 7f       	andi	r18, 0xF0	; 240
    1fd2:	28 60       	ori	r18, 0x08	; 8
    1fd4:	fc 01       	movw	r30, r24
    1fd6:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    1fd8:	10 92 44 40 	sts	0x4044, r1
    1fdc:	10 92 45 40 	sts	0x4045, r1
	sampleCount = 0;
    1fe0:	10 92 69 50 	sts	0x5069, r1
    1fe4:	10 92 6a 50 	sts	0x506A, r1
    1fe8:	10 92 6b 50 	sts	0x506B, r1
    1fec:	10 92 6c 50 	sts	0x506C, r1
	SPICount = 0;
    1ff0:	10 92 c3 50 	sts	0x50C3, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    1ff4:	80 e0       	ldi	r24, 0x00	; 0
    1ff6:	80 93 28 21 	sts	0x2128, r24
    1ffa:	80 93 27 21 	sts	0x2127, r24
    1ffe:	80 93 26 21 	sts	0x2126, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    2002:	80 ea       	ldi	r24, 0xA0	; 160
    2004:	90 e0       	ldi	r25, 0x00	; 0
    2006:	20 ea       	ldi	r18, 0xA0	; 160
    2008:	30 e0       	ldi	r19, 0x00	; 0
    200a:	f9 01       	movw	r30, r18
    200c:	22 81       	ldd	r18, Z+2	; 0x02
    200e:	26 60       	ori	r18, 0x06	; 6
    2010:	fc 01       	movw	r30, r24
    2012:	22 83       	std	Z+2, r18	; 0x02
	sei();
    2014:	78 94       	sei

	SPICS(TRUE);
    2016:	81 e0       	ldi	r24, 0x01	; 1
    2018:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    201c:	80 e8       	ldi	r24, 0x80	; 128
    201e:	96 e0       	ldi	r25, 0x06	; 6
    2020:	20 e2       	ldi	r18, 0x20	; 32
    2022:	fc 01       	movw	r30, r24
    2024:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2026:	80 e4       	ldi	r24, 0x40	; 64
    2028:	9a e0       	ldi	r25, 0x0A	; 10
    202a:	23 e2       	ldi	r18, 0x23	; 35
    202c:	fc 01       	movw	r30, r24
    202e:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    2030:	80 e4       	ldi	r24, 0x40	; 64
    2032:	9a e0       	ldi	r25, 0x0A	; 10
    2034:	2c 81       	ldd	r18, Y+4	; 0x04
    2036:	42 2f       	mov	r20, r18
    2038:	50 e0       	ldi	r21, 0x00	; 0
    203a:	20 e2       	ldi	r18, 0x20	; 32
    203c:	30 e0       	ldi	r19, 0x00	; 0
    203e:	02 c0       	rjmp	.+4      	; 0x2044 <CO_collectSeismic3Channel_2+0x1b2>
    2040:	22 0f       	add	r18, r18
    2042:	33 1f       	adc	r19, r19
    2044:	4a 95       	dec	r20
    2046:	e2 f7       	brpl	.-8      	; 0x2040 <CO_collectSeismic3Channel_2+0x1ae>
    2048:	fc 01       	movw	r30, r24
    204a:	26 a3       	lds	r18, 0x56
    204c:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    204e:	80 e4       	ldi	r24, 0x40	; 64
    2050:	9a e0       	ldi	r25, 0x0A	; 10
    2052:	2c 81       	ldd	r18, Y+4	; 0x04
    2054:	42 2f       	mov	r20, r18
    2056:	50 e0       	ldi	r21, 0x00	; 0
    2058:	20 e1       	ldi	r18, 0x10	; 16
    205a:	30 e0       	ldi	r19, 0x00	; 0
    205c:	02 c0       	rjmp	.+4      	; 0x2062 <CO_collectSeismic3Channel_2+0x1d0>
    205e:	22 0f       	add	r18, r18
    2060:	33 1f       	adc	r19, r19
    2062:	4a 95       	dec	r20
    2064:	e2 f7       	brpl	.-8      	; 0x205e <CO_collectSeismic3Channel_2+0x1cc>
    2066:	fc 01       	movw	r30, r24
    2068:	22 af       	sts	0x72, r18
    206a:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    206c:	80 e4       	ldi	r24, 0x40	; 64
    206e:	9a e0       	ldi	r25, 0x0A	; 10
    2070:	20 e4       	ldi	r18, 0x40	; 64
    2072:	3a e0       	ldi	r19, 0x0A	; 10
    2074:	f9 01       	movw	r30, r18
    2076:	20 81       	ld	r18, Z
    2078:	20 7f       	andi	r18, 0xF0	; 240
    207a:	21 60       	ori	r18, 0x01	; 1
    207c:	fc 01       	movw	r30, r24
    207e:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    2080:	00 00       	nop
    2082:	20 91 69 50 	lds	r18, 0x5069
    2086:	30 91 6a 50 	lds	r19, 0x506A
    208a:	40 91 6b 50 	lds	r20, 0x506B
    208e:	50 91 6c 50 	lds	r21, 0x506C
    2092:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2094:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2096:	af 8d       	ldd	r26, Y+31	; 0x1f
    2098:	b8 a1       	lds	r27, 0x48
    209a:	28 17       	cp	r18, r24
    209c:	39 07       	cpc	r19, r25
    209e:	4a 07       	cpc	r20, r26
    20a0:	5b 07       	cpc	r21, r27
    20a2:	78 f3       	brcs	.-34     	; 0x2082 <CO_collectSeismic3Channel_2+0x1f0>

	// turn off timer and interrupts
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    20a4:	80 e0       	ldi	r24, 0x00	; 0
    20a6:	98 e0       	ldi	r25, 0x08	; 8
    20a8:	20 e0       	ldi	r18, 0x00	; 0
    20aa:	38 e0       	ldi	r19, 0x08	; 8
    20ac:	f9 01       	movw	r30, r18
    20ae:	20 81       	ld	r18, Z
    20b0:	20 7f       	andi	r18, 0xF0	; 240
    20b2:	fc 01       	movw	r30, r24
    20b4:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    20b6:	80 e4       	ldi	r24, 0x40	; 64
    20b8:	9a e0       	ldi	r25, 0x0A	; 10
    20ba:	20 e4       	ldi	r18, 0x40	; 64
    20bc:	3a e0       	ldi	r19, 0x0A	; 10
    20be:	f9 01       	movw	r30, r18
    20c0:	20 81       	ld	r18, Z
    20c2:	20 7f       	andi	r18, 0xF0	; 240
    20c4:	fc 01       	movw	r30, r24
    20c6:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    20c8:	80 ea       	ldi	r24, 0xA0	; 160
    20ca:	90 e0       	ldi	r25, 0x00	; 0
    20cc:	20 ea       	ldi	r18, 0xA0	; 160
    20ce:	30 e0       	ldi	r19, 0x00	; 0
    20d0:	f9 01       	movw	r30, r18
    20d2:	22 81       	ldd	r18, Z+2	; 0x02
    20d4:	29 7f       	andi	r18, 0xF9	; 249
    20d6:	fc 01       	movw	r30, r24
    20d8:	22 83       	std	Z+2, r18	; 0x02
	cli();
    20da:	f8 94       	cli

	SPICS(FALSE);
    20dc:	80 e0       	ldi	r24, 0x00	; 0
    20de:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	SPIDisable();
    20e2:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>
	enableADCMUX(FALSE);
    20e6:	80 e0       	ldi	r24, 0x00	; 0
    20e8:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <enableADCMUX>
	ADCPower(FALSE);
    20ec:	80 e0       	ldi	r24, 0x00	; 0
    20ee:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
}
    20f2:	2e 96       	adiw	r28, 0x0e	; 14
    20f4:	cd bf       	out	0x3d, r28	; 61
    20f6:	de bf       	out	0x3e, r29	; 62
    20f8:	df 91       	pop	r29
    20fa:	cf 91       	pop	r28
    20fc:	0f 91       	pop	r16
    20fe:	ff 90       	pop	r15
    2100:	ef 90       	pop	r14
    2102:	df 90       	pop	r13
    2104:	cf 90       	pop	r12
    2106:	bf 90       	pop	r11
    2108:	af 90       	pop	r10
    210a:	9f 90       	pop	r9
    210c:	8f 90       	pop	r8
    210e:	08 95       	ret

00002110 <__vector_16>:


ISR(TCC0_CCA_vect) {
    2110:	1f 92       	push	r1
    2112:	0f 92       	push	r0
    2114:	0f b6       	in	r0, 0x3f	; 63
    2116:	0f 92       	push	r0
    2118:	00 90 3b 00 	lds	r0, 0x003B
    211c:	0f 92       	push	r0
    211e:	11 24       	eor	r1, r1
    2120:	2f 93       	push	r18
    2122:	3f 93       	push	r19
    2124:	4f 93       	push	r20
    2126:	5f 93       	push	r21
    2128:	6f 93       	push	r22
    212a:	7f 93       	push	r23
    212c:	8f 93       	push	r24
    212e:	9f 93       	push	r25
    2130:	af 93       	push	r26
    2132:	bf 93       	push	r27
    2134:	ef 93       	push	r30
    2136:	ff 93       	push	r31
    2138:	cf 93       	push	r28
    213a:	df 93       	push	r29
    213c:	cd b7       	in	r28, 0x3d	; 61
    213e:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2140:	0e 94 ea 14 	call	0x29d4	; 0x29d4 <sampleCurrentChannel>
}
    2144:	df 91       	pop	r29
    2146:	cf 91       	pop	r28
    2148:	ff 91       	pop	r31
    214a:	ef 91       	pop	r30
    214c:	bf 91       	pop	r27
    214e:	af 91       	pop	r26
    2150:	9f 91       	pop	r25
    2152:	8f 91       	pop	r24
    2154:	7f 91       	pop	r23
    2156:	6f 91       	pop	r22
    2158:	5f 91       	pop	r21
    215a:	4f 91       	pop	r20
    215c:	3f 91       	pop	r19
    215e:	2f 91       	pop	r18
    2160:	0f 90       	pop	r0
    2162:	00 92 3b 00 	sts	0x003B, r0
    2166:	0f 90       	pop	r0
    2168:	0f be       	out	0x3f, r0	; 63
    216a:	0f 90       	pop	r0
    216c:	1f 90       	pop	r1
    216e:	18 95       	reti

00002170 <__vector_17>:

ISR(TCC0_CCB_vect) {
    2170:	1f 92       	push	r1
    2172:	0f 92       	push	r0
    2174:	0f b6       	in	r0, 0x3f	; 63
    2176:	0f 92       	push	r0
    2178:	00 90 3b 00 	lds	r0, 0x003B
    217c:	0f 92       	push	r0
    217e:	11 24       	eor	r1, r1
    2180:	2f 93       	push	r18
    2182:	3f 93       	push	r19
    2184:	4f 93       	push	r20
    2186:	5f 93       	push	r21
    2188:	6f 93       	push	r22
    218a:	7f 93       	push	r23
    218c:	8f 93       	push	r24
    218e:	9f 93       	push	r25
    2190:	af 93       	push	r26
    2192:	bf 93       	push	r27
    2194:	ef 93       	push	r30
    2196:	ff 93       	push	r31
    2198:	cf 93       	push	r28
    219a:	df 93       	push	r29
    219c:	cd b7       	in	r28, 0x3d	; 61
    219e:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    21a0:	0e 94 ea 14 	call	0x29d4	; 0x29d4 <sampleCurrentChannel>
}
    21a4:	df 91       	pop	r29
    21a6:	cf 91       	pop	r28
    21a8:	ff 91       	pop	r31
    21aa:	ef 91       	pop	r30
    21ac:	bf 91       	pop	r27
    21ae:	af 91       	pop	r26
    21b0:	9f 91       	pop	r25
    21b2:	8f 91       	pop	r24
    21b4:	7f 91       	pop	r23
    21b6:	6f 91       	pop	r22
    21b8:	5f 91       	pop	r21
    21ba:	4f 91       	pop	r20
    21bc:	3f 91       	pop	r19
    21be:	2f 91       	pop	r18
    21c0:	0f 90       	pop	r0
    21c2:	00 92 3b 00 	sts	0x003B, r0
    21c6:	0f 90       	pop	r0
    21c8:	0f be       	out	0x3f, r0	; 63
    21ca:	0f 90       	pop	r0
    21cc:	1f 90       	pop	r1
    21ce:	18 95       	reti

000021d0 <__vector_18>:

ISR(TCC0_CCC_vect) {
    21d0:	1f 92       	push	r1
    21d2:	0f 92       	push	r0
    21d4:	0f b6       	in	r0, 0x3f	; 63
    21d6:	0f 92       	push	r0
    21d8:	00 90 3b 00 	lds	r0, 0x003B
    21dc:	0f 92       	push	r0
    21de:	11 24       	eor	r1, r1
    21e0:	2f 93       	push	r18
    21e2:	3f 93       	push	r19
    21e4:	4f 93       	push	r20
    21e6:	5f 93       	push	r21
    21e8:	6f 93       	push	r22
    21ea:	7f 93       	push	r23
    21ec:	8f 93       	push	r24
    21ee:	9f 93       	push	r25
    21f0:	af 93       	push	r26
    21f2:	bf 93       	push	r27
    21f4:	ef 93       	push	r30
    21f6:	ff 93       	push	r31
    21f8:	cf 93       	push	r28
    21fa:	df 93       	push	r29
    21fc:	cd b7       	in	r28, 0x3d	; 61
    21fe:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2200:	0e 94 ea 14 	call	0x29d4	; 0x29d4 <sampleCurrentChannel>
}
    2204:	df 91       	pop	r29
    2206:	cf 91       	pop	r28
    2208:	ff 91       	pop	r31
    220a:	ef 91       	pop	r30
    220c:	bf 91       	pop	r27
    220e:	af 91       	pop	r26
    2210:	9f 91       	pop	r25
    2212:	8f 91       	pop	r24
    2214:	7f 91       	pop	r23
    2216:	6f 91       	pop	r22
    2218:	5f 91       	pop	r21
    221a:	4f 91       	pop	r20
    221c:	3f 91       	pop	r19
    221e:	2f 91       	pop	r18
    2220:	0f 90       	pop	r0
    2222:	00 92 3b 00 	sts	0x003B, r0
    2226:	0f 90       	pop	r0
    2228:	0f be       	out	0x3f, r0	; 63
    222a:	0f 90       	pop	r0
    222c:	1f 90       	pop	r1
    222e:	18 95       	reti

00002230 <__vector_19>:

ISR(TCC0_CCD_vect) {
    2230:	1f 92       	push	r1
    2232:	0f 92       	push	r0
    2234:	0f b6       	in	r0, 0x3f	; 63
    2236:	0f 92       	push	r0
    2238:	00 90 3b 00 	lds	r0, 0x003B
    223c:	0f 92       	push	r0
    223e:	11 24       	eor	r1, r1
    2240:	2f 93       	push	r18
    2242:	3f 93       	push	r19
    2244:	4f 93       	push	r20
    2246:	5f 93       	push	r21
    2248:	6f 93       	push	r22
    224a:	7f 93       	push	r23
    224c:	8f 93       	push	r24
    224e:	9f 93       	push	r25
    2250:	af 93       	push	r26
    2252:	bf 93       	push	r27
    2254:	ef 93       	push	r30
    2256:	ff 93       	push	r31
    2258:	cf 93       	push	r28
    225a:	df 93       	push	r29
    225c:	cd b7       	in	r28, 0x3d	; 61
    225e:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2260:	0e 94 ea 14 	call	0x29d4	; 0x29d4 <sampleCurrentChannel>
	SPICount = 0;
    2264:	10 92 c3 50 	sts	0x50C3, r1
	if(PORTB.OUT & PIN1_bm) {
    2268:	80 e2       	ldi	r24, 0x20	; 32
    226a:	96 e0       	ldi	r25, 0x06	; 6
    226c:	fc 01       	movw	r30, r24
    226e:	84 81       	ldd	r24, Z+4	; 0x04
    2270:	88 2f       	mov	r24, r24
    2272:	90 e0       	ldi	r25, 0x00	; 0
    2274:	82 70       	andi	r24, 0x02	; 2
    2276:	90 70       	andi	r25, 0x00	; 0
    2278:	00 97       	sbiw	r24, 0x00	; 0
    227a:	b1 f0       	breq	.+44     	; 0x22a8 <__vector_19+0x78>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    227c:	80 e0       	ldi	r24, 0x00	; 0
    227e:	96 e0       	ldi	r25, 0x06	; 6
    2280:	fc 01       	movw	r30, r24
    2282:	84 81       	ldd	r24, Z+4	; 0x04
    2284:	88 2f       	mov	r24, r24
    2286:	90 e0       	ldi	r25, 0x00	; 0
    2288:	80 74       	andi	r24, 0x40	; 64
    228a:	90 70       	andi	r25, 0x00	; 0
    228c:	00 97       	sbiw	r24, 0x00	; 0
    228e:	31 f0       	breq	.+12     	; 0x229c <__vector_19+0x6c>
    2290:	80 e2       	ldi	r24, 0x20	; 32
    2292:	96 e0       	ldi	r25, 0x06	; 6
    2294:	22 e0       	ldi	r18, 0x02	; 2
    2296:	fc 01       	movw	r30, r24
    2298:	27 83       	std	Z+7, r18	; 0x07
    229a:	10 c0       	rjmp	.+32     	; 0x22bc <__vector_19+0x8c>
		else PORTA.OUTTGL = PIN6_bm;
    229c:	80 e0       	ldi	r24, 0x00	; 0
    229e:	96 e0       	ldi	r25, 0x06	; 6
    22a0:	20 e4       	ldi	r18, 0x40	; 64
    22a2:	fc 01       	movw	r30, r24
    22a4:	27 83       	std	Z+7, r18	; 0x07
    22a6:	0a c0       	rjmp	.+20     	; 0x22bc <__vector_19+0x8c>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    22a8:	80 e0       	ldi	r24, 0x00	; 0
    22aa:	96 e0       	ldi	r25, 0x06	; 6
    22ac:	20 e4       	ldi	r18, 0x40	; 64
    22ae:	fc 01       	movw	r30, r24
    22b0:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTSET = PIN1_bm;
    22b2:	80 e2       	ldi	r24, 0x20	; 32
    22b4:	96 e0       	ldi	r25, 0x06	; 6
    22b6:	22 e0       	ldi	r18, 0x02	; 2
    22b8:	fc 01       	movw	r30, r24
    22ba:	25 83       	std	Z+5, r18	; 0x05
	}
	
}
    22bc:	df 91       	pop	r29
    22be:	cf 91       	pop	r28
    22c0:	ff 91       	pop	r31
    22c2:	ef 91       	pop	r30
    22c4:	bf 91       	pop	r27
    22c6:	af 91       	pop	r26
    22c8:	9f 91       	pop	r25
    22ca:	8f 91       	pop	r24
    22cc:	7f 91       	pop	r23
    22ce:	6f 91       	pop	r22
    22d0:	5f 91       	pop	r21
    22d2:	4f 91       	pop	r20
    22d4:	3f 91       	pop	r19
    22d6:	2f 91       	pop	r18
    22d8:	0f 90       	pop	r0
    22da:	00 92 3b 00 	sts	0x003B, r0
    22de:	0f 90       	pop	r0
    22e0:	0f be       	out	0x3f, r0	; 63
    22e2:	0f 90       	pop	r0
    22e4:	1f 90       	pop	r1
    22e6:	18 95       	reti

000022e8 <__vector_14>:

ISR(TCC0_OVF_vect) {
    22e8:	1f 92       	push	r1
    22ea:	0f 92       	push	r0
    22ec:	0f b6       	in	r0, 0x3f	; 63
    22ee:	0f 92       	push	r0
    22f0:	00 90 3b 00 	lds	r0, 0x003B
    22f4:	0f 92       	push	r0
    22f6:	11 24       	eor	r1, r1
    22f8:	2f 93       	push	r18
    22fa:	3f 93       	push	r19
    22fc:	4f 93       	push	r20
    22fe:	5f 93       	push	r21
    2300:	6f 93       	push	r22
    2302:	7f 93       	push	r23
    2304:	8f 93       	push	r24
    2306:	9f 93       	push	r25
    2308:	af 93       	push	r26
    230a:	bf 93       	push	r27
    230c:	ef 93       	push	r30
    230e:	ff 93       	push	r31
    2310:	cf 93       	push	r28
    2312:	df 93       	push	r29
    2314:	cd b7       	in	r28, 0x3d	; 61
    2316:	de b7       	in	r29, 0x3e	; 62
    2318:	29 97       	sbiw	r28, 0x09	; 9
    231a:	cd bf       	out	0x3d, r28	; 61
    231c:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    231e:	1a 82       	std	Y+2, r1	; 0x02
    2320:	1b 82       	std	Y+3, r1	; 0x03
    2322:	1c 82       	std	Y+4, r1	; 0x04
    2324:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	//sampleCount++;
		
	//SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2326:	19 82       	std	Y+1, r1	; 0x01
    2328:	4f c0       	rjmp	.+158    	; 0x23c8 <__vector_14+0xe0>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    232a:	89 81       	ldd	r24, Y+1	; 0x01
    232c:	88 2f       	mov	r24, r24
    232e:	90 e0       	ldi	r25, 0x00	; 0
    2330:	86 5a       	subi	r24, 0xA6	; 166
    2332:	9f 4a       	sbci	r25, 0xAF	; 175
    2334:	fc 01       	movw	r30, r24
    2336:	80 81       	ld	r24, Z
    2338:	88 23       	and	r24, r24
    233a:	3c f4       	brge	.+14     	; 0x234a <__vector_14+0x62>
    233c:	ce 01       	movw	r24, r28
    233e:	06 96       	adiw	r24, 0x06	; 6
    2340:	03 96       	adiw	r24, 0x03	; 3
    2342:	2f ef       	ldi	r18, 0xFF	; 255
    2344:	fc 01       	movw	r30, r24
    2346:	20 83       	st	Z, r18
    2348:	05 c0       	rjmp	.+10     	; 0x2354 <__vector_14+0x6c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    234a:	ce 01       	movw	r24, r28
    234c:	06 96       	adiw	r24, 0x06	; 6
    234e:	03 96       	adiw	r24, 0x03	; 3
    2350:	fc 01       	movw	r30, r24
    2352:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2354:	ce 01       	movw	r24, r28
    2356:	06 96       	adiw	r24, 0x06	; 6
    2358:	02 96       	adiw	r24, 0x02	; 2
    235a:	29 81       	ldd	r18, Y+1	; 0x01
    235c:	22 2f       	mov	r18, r18
    235e:	30 e0       	ldi	r19, 0x00	; 0
    2360:	26 5a       	subi	r18, 0xA6	; 166
    2362:	3f 4a       	sbci	r19, 0xAF	; 175
    2364:	f9 01       	movw	r30, r18
    2366:	20 81       	ld	r18, Z
    2368:	fc 01       	movw	r30, r24
    236a:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    236c:	ce 01       	movw	r24, r28
    236e:	06 96       	adiw	r24, 0x06	; 6
    2370:	01 96       	adiw	r24, 0x01	; 1
    2372:	29 81       	ldd	r18, Y+1	; 0x01
    2374:	22 2f       	mov	r18, r18
    2376:	30 e0       	ldi	r19, 0x00	; 0
    2378:	2f 5f       	subi	r18, 0xFF	; 255
    237a:	3f 4f       	sbci	r19, 0xFF	; 255
    237c:	26 5a       	subi	r18, 0xA6	; 166
    237e:	3f 4a       	sbci	r19, 0xAF	; 175
    2380:	f9 01       	movw	r30, r18
    2382:	20 81       	ld	r18, Z
    2384:	fc 01       	movw	r30, r24
    2386:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2388:	ce 01       	movw	r24, r28
    238a:	06 96       	adiw	r24, 0x06	; 6
    238c:	29 81       	ldd	r18, Y+1	; 0x01
    238e:	22 2f       	mov	r18, r18
    2390:	30 e0       	ldi	r19, 0x00	; 0
    2392:	2e 5f       	subi	r18, 0xFE	; 254
    2394:	3f 4f       	sbci	r19, 0xFF	; 255
    2396:	26 5a       	subi	r18, 0xA6	; 166
    2398:	3f 4a       	sbci	r19, 0xAF	; 175
    239a:	f9 01       	movw	r30, r18
    239c:	20 81       	ld	r18, Z
    239e:	fc 01       	movw	r30, r24
    23a0:	20 83       	st	Z, r18
		sum += currentSample;
    23a2:	2a 81       	ldd	r18, Y+2	; 0x02
    23a4:	3b 81       	ldd	r19, Y+3	; 0x03
    23a6:	4c 81       	ldd	r20, Y+4	; 0x04
    23a8:	5d 81       	ldd	r21, Y+5	; 0x05
    23aa:	8e 81       	ldd	r24, Y+6	; 0x06
    23ac:	9f 81       	ldd	r25, Y+7	; 0x07
    23ae:	a8 85       	ldd	r26, Y+8	; 0x08
    23b0:	b9 85       	ldd	r27, Y+9	; 0x09
    23b2:	82 0f       	add	r24, r18
    23b4:	93 1f       	adc	r25, r19
    23b6:	a4 1f       	adc	r26, r20
    23b8:	b5 1f       	adc	r27, r21
    23ba:	8a 83       	std	Y+2, r24	; 0x02
    23bc:	9b 83       	std	Y+3, r25	; 0x03
    23be:	ac 83       	std	Y+4, r26	; 0x04
    23c0:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	//sampleCount++;
		
	//SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    23c2:	89 81       	ldd	r24, Y+1	; 0x01
    23c4:	8d 5f       	subi	r24, 0xFD	; 253
    23c6:	89 83       	std	Y+1, r24	; 0x01
    23c8:	89 81       	ldd	r24, Y+1	; 0x01
    23ca:	8c 30       	cpi	r24, 0x0C	; 12
    23cc:	08 f4       	brcc	.+2      	; 0x23d0 <__vector_14+0xe8>
    23ce:	ad cf       	rjmp	.-166    	; 0x232a <__vector_14+0x42>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    23d0:	8a 81       	ldd	r24, Y+2	; 0x02
    23d2:	9b 81       	ldd	r25, Y+3	; 0x03
    23d4:	ac 81       	ldd	r26, Y+4	; 0x04
    23d6:	bd 81       	ldd	r27, Y+5	; 0x05
    23d8:	24 e0       	ldi	r18, 0x04	; 4
    23da:	30 e0       	ldi	r19, 0x00	; 0
    23dc:	40 e0       	ldi	r20, 0x00	; 0
    23de:	50 e0       	ldi	r21, 0x00	; 0
    23e0:	bc 01       	movw	r22, r24
    23e2:	cd 01       	movw	r24, r26
    23e4:	0e 94 71 63 	call	0xc6e2	; 0xc6e2 <__divmodsi4>
    23e8:	da 01       	movw	r26, r20
    23ea:	c9 01       	movw	r24, r18
    23ec:	8a 83       	std	Y+2, r24	; 0x02
    23ee:	9b 83       	std	Y+3, r25	; 0x03
    23f0:	ac 83       	std	Y+4, r26	; 0x04
    23f2:	bd 83       	std	Y+5, r27	; 0x05
	ADC_BUFFER[sampleCount] = currentSample;
    23f4:	20 91 67 50 	lds	r18, 0x5067
    23f8:	30 91 68 50 	lds	r19, 0x5068
    23fc:	80 91 69 50 	lds	r24, 0x5069
    2400:	90 91 6a 50 	lds	r25, 0x506A
    2404:	a0 91 6b 50 	lds	r26, 0x506B
    2408:	b0 91 6c 50 	lds	r27, 0x506C
    240c:	88 0f       	add	r24, r24
    240e:	99 1f       	adc	r25, r25
    2410:	88 0f       	add	r24, r24
    2412:	99 1f       	adc	r25, r25
    2414:	28 0f       	add	r18, r24
    2416:	39 1f       	adc	r19, r25
    2418:	8e 81       	ldd	r24, Y+6	; 0x06
    241a:	9f 81       	ldd	r25, Y+7	; 0x07
    241c:	a8 85       	ldd	r26, Y+8	; 0x08
    241e:	b9 85       	ldd	r27, Y+9	; 0x09
    2420:	f9 01       	movw	r30, r18
    2422:	80 83       	st	Z, r24
    2424:	91 83       	std	Z+1, r25	; 0x01
    2426:	a2 83       	std	Z+2, r26	; 0x02
    2428:	b3 83       	std	Z+3, r27	; 0x03
	sampleCount++;
    242a:	80 91 69 50 	lds	r24, 0x5069
    242e:	90 91 6a 50 	lds	r25, 0x506A
    2432:	a0 91 6b 50 	lds	r26, 0x506B
    2436:	b0 91 6c 50 	lds	r27, 0x506C
    243a:	01 96       	adiw	r24, 0x01	; 1
    243c:	a1 1d       	adc	r26, r1
    243e:	b1 1d       	adc	r27, r1
    2440:	80 93 69 50 	sts	0x5069, r24
    2444:	90 93 6a 50 	sts	0x506A, r25
    2448:	a0 93 6b 50 	sts	0x506B, r26
    244c:	b0 93 6c 50 	sts	0x506C, r27

}
    2450:	29 96       	adiw	r28, 0x09	; 9
    2452:	cd bf       	out	0x3d, r28	; 61
    2454:	de bf       	out	0x3e, r29	; 62
    2456:	df 91       	pop	r29
    2458:	cf 91       	pop	r28
    245a:	ff 91       	pop	r31
    245c:	ef 91       	pop	r30
    245e:	bf 91       	pop	r27
    2460:	af 91       	pop	r26
    2462:	9f 91       	pop	r25
    2464:	8f 91       	pop	r24
    2466:	7f 91       	pop	r23
    2468:	6f 91       	pop	r22
    246a:	5f 91       	pop	r21
    246c:	4f 91       	pop	r20
    246e:	3f 91       	pop	r19
    2470:	2f 91       	pop	r18
    2472:	0f 90       	pop	r0
    2474:	00 92 3b 00 	sts	0x003B, r0
    2478:	0f 90       	pop	r0
    247a:	0f be       	out	0x3f, r0	; 63
    247c:	0f 90       	pop	r0
    247e:	1f 90       	pop	r1
    2480:	18 95       	reti

00002482 <CO_collectSeismic1Channel>:

void CO_collectSeismic1Channel(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint8_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint32_t numOfSamples, int32_t* DataArray) {
    2482:	8f 92       	push	r8
    2484:	9f 92       	push	r9
    2486:	af 92       	push	r10
    2488:	bf 92       	push	r11
    248a:	cf 92       	push	r12
    248c:	df 92       	push	r13
    248e:	ef 92       	push	r14
    2490:	0f 93       	push	r16
    2492:	cf 93       	push	r28
    2494:	df 93       	push	r29
    2496:	cd b7       	in	r28, 0x3d	; 61
    2498:	de b7       	in	r29, 0x3e	; 62
    249a:	2c 97       	sbiw	r28, 0x0c	; 12
    249c:	cd bf       	out	0x3d, r28	; 61
    249e:	de bf       	out	0x3e, r29	; 62
    24a0:	89 83       	std	Y+1, r24	; 0x01
    24a2:	6a 83       	std	Y+2, r22	; 0x02
    24a4:	4b 83       	std	Y+3, r20	; 0x03
    24a6:	2c 83       	std	Y+4, r18	; 0x04
    24a8:	0d 83       	std	Y+5, r16	; 0x05
    24aa:	ee 82       	std	Y+6, r14	; 0x06
    24ac:	cf 82       	std	Y+7, r12	; 0x07
    24ae:	d8 86       	std	Y+8, r13	; 0x08
    24b0:	a9 86       	std	Y+9, r10	; 0x09
    24b2:	ba 86       	std	Y+10, r11	; 0x0a
    24b4:	8b 86       	std	Y+11, r8	; 0x0b
    24b6:	9c 86       	std	Y+12, r9	; 0x0c
	
	uint16_t period;
	ADC_BUFFER=DataArray;
    24b8:	88 a1       	lds	r24, 0x48
    24ba:	99 a1       	lds	r25, 0x49
    24bc:	80 93 67 50 	sts	0x5067, r24
    24c0:	90 93 68 50 	sts	0x5068, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    24c4:	81 e0       	ldi	r24, 0x01	; 1
    24c6:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    24ca:	89 81       	ldd	r24, Y+1	; 0x01
    24cc:	6b 81       	ldd	r22, Y+3	; 0x03
    24ce:	0e 94 bd 06 	call	0xd7a	; 0xd7a <set_ampGain>
	set_filter(filterConfig);
    24d2:	8a 81       	ldd	r24, Y+2	; 0x02
    24d4:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    24d8:	8e 81       	ldd	r24, Y+6	; 0x06
    24da:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    24de:	84 e0       	ldi	r24, 0x04	; 4
    24e0:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    24e4:	80 ec       	ldi	r24, 0xC0	; 192
    24e6:	98 e0       	ldi	r25, 0x08	; 8
    24e8:	24 e5       	ldi	r18, 0x54	; 84
    24ea:	fc 01       	movw	r30, r24
    24ec:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    24ee:	81 e0       	ldi	r24, 0x01	; 1
    24f0:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <enableADCMUX>
	setADCInput(channel);
    24f4:	89 81       	ldd	r24, Y+1	; 0x01
    24f6:	0e 94 de 1a 	call	0x35bc	; 0x35bc <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    24fa:	80 ea       	ldi	r24, 0xA0	; 160
    24fc:	96 e0       	ldi	r25, 0x06	; 6
    24fe:	22 e0       	ldi	r18, 0x02	; 2
    2500:	fc 01       	movw	r30, r24
    2502:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2504:	80 ea       	ldi	r24, 0xA0	; 160
    2506:	96 e0       	ldi	r25, 0x06	; 6
    2508:	21 e0       	ldi	r18, 0x01	; 1
    250a:	fc 01       	movw	r30, r24
    250c:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    250e:	80 e8       	ldi	r24, 0x80	; 128
    2510:	91 e0       	ldi	r25, 0x01	; 1
    2512:	28 e7       	ldi	r18, 0x78	; 120
    2514:	fc 01       	movw	r30, r24
    2516:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2518:	80 e0       	ldi	r24, 0x00	; 0
    251a:	99 e0       	ldi	r25, 0x09	; 9
    251c:	20 ef       	ldi	r18, 0xF0	; 240
    251e:	fc 01       	movw	r30, r24
    2520:	21 83       	std	Z+1, r18	; 0x01
	TCD0.CCA = averagingPtA;
    2522:	80 e0       	ldi	r24, 0x00	; 0
    2524:	99 e0       	ldi	r25, 0x09	; 9
    2526:	2f 81       	ldd	r18, Y+7	; 0x07
    2528:	38 85       	ldd	r19, Y+8	; 0x08
    252a:	fc 01       	movw	r30, r24
    252c:	20 a7       	lds	r18, 0x70
    252e:	31 a7       	lds	r19, 0x71
	TCD0.CCB = averagingPtB;
    2530:	80 e0       	ldi	r24, 0x00	; 0
    2532:	99 e0       	ldi	r25, 0x09	; 9
    2534:	29 85       	ldd	r18, Y+9	; 0x09
    2536:	3a 85       	ldd	r19, Y+10	; 0x0a
    2538:	fc 01       	movw	r30, r24
    253a:	22 a7       	lds	r18, 0x72
    253c:	33 a7       	lds	r19, 0x73
	TCD0.CCC = averagingPtC;
    253e:	80 e0       	ldi	r24, 0x00	; 0
    2540:	99 e0       	ldi	r25, 0x09	; 9
    2542:	2b 85       	ldd	r18, Y+11	; 0x0b
    2544:	3c 85       	ldd	r19, Y+12	; 0x0c
    2546:	fc 01       	movw	r30, r24
    2548:	24 a7       	lds	r18, 0x74
    254a:	35 a7       	lds	r19, 0x75
	TCD0.CCD = averagingPtD;
    254c:	80 e0       	ldi	r24, 0x00	; 0
    254e:	99 e0       	ldi	r25, 0x09	; 9
    2550:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2552:	3b 8d       	ldd	r19, Y+27	; 0x1b
    2554:	fc 01       	movw	r30, r24
    2556:	26 a7       	lds	r18, 0x76
    2558:	37 a7       	lds	r19, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    255a:	80 e0       	ldi	r24, 0x00	; 0
    255c:	99 e0       	ldi	r25, 0x09	; 9
    255e:	2d 81       	ldd	r18, Y+5	; 0x05
    2560:	22 2f       	mov	r18, r18
    2562:	30 e0       	ldi	r19, 0x00	; 0
    2564:	21 50       	subi	r18, 0x01	; 1
    2566:	30 40       	sbci	r19, 0x00	; 0
    2568:	fc 01       	movw	r30, r24
    256a:	26 a3       	lds	r18, 0x56
    256c:	37 a3       	lds	r19, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    256e:	80 e0       	ldi	r24, 0x00	; 0
    2570:	99 e0       	ldi	r25, 0x09	; 9
    2572:	22 e0       	ldi	r18, 0x02	; 2
    2574:	fc 01       	movw	r30, r24
    2576:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2578:	80 e0       	ldi	r24, 0x00	; 0
    257a:	99 e0       	ldi	r25, 0x09	; 9
    257c:	2f ef       	ldi	r18, 0xFF	; 255
    257e:	fc 01       	movw	r30, r24
    2580:	27 83       	std	Z+7, r18	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2582:	80 e0       	ldi	r24, 0x00	; 0
    2584:	99 e0       	ldi	r25, 0x09	; 9
    2586:	20 e0       	ldi	r18, 0x00	; 0
    2588:	39 e0       	ldi	r19, 0x09	; 9
    258a:	f9 01       	movw	r30, r18
    258c:	20 81       	ld	r18, Z
    258e:	20 7f       	andi	r18, 0xF0	; 240
    2590:	28 60       	ori	r18, 0x08	; 8
    2592:	fc 01       	movw	r30, r24
    2594:	20 83       	st	Z, r18

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    2596:	10 92 69 50 	sts	0x5069, r1
    259a:	10 92 6a 50 	sts	0x506A, r1
    259e:	10 92 6b 50 	sts	0x506B, r1
    25a2:	10 92 6c 50 	sts	0x506C, r1
	SPICount = 0;
    25a6:	10 92 c3 50 	sts	0x50C3, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm;
    25aa:	80 ea       	ldi	r24, 0xA0	; 160
    25ac:	90 e0       	ldi	r25, 0x00	; 0
    25ae:	20 ea       	ldi	r18, 0xA0	; 160
    25b0:	30 e0       	ldi	r19, 0x00	; 0
    25b2:	f9 01       	movw	r30, r18
    25b4:	22 81       	ldd	r18, Z+2	; 0x02
    25b6:	26 60       	ori	r18, 0x06	; 6
    25b8:	fc 01       	movw	r30, r24
    25ba:	22 83       	std	Z+2, r18	; 0x02
	sei();
    25bc:	78 94       	sei

	SPICS(TRUE);
    25be:	81 e0       	ldi	r24, 0x01	; 1
    25c0:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    25c4:	80 e8       	ldi	r24, 0x80	; 128
    25c6:	96 e0       	ldi	r25, 0x06	; 6
    25c8:	20 e2       	ldi	r18, 0x20	; 32
    25ca:	fc 01       	movw	r30, r24
    25cc:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    25ce:	80 e4       	ldi	r24, 0x40	; 64
    25d0:	9a e0       	ldi	r25, 0x0A	; 10
    25d2:	23 e2       	ldi	r18, 0x23	; 35
    25d4:	fc 01       	movw	r30, r24
    25d6:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    25d8:	80 e4       	ldi	r24, 0x40	; 64
    25da:	9a e0       	ldi	r25, 0x0A	; 10
    25dc:	2c 81       	ldd	r18, Y+4	; 0x04
    25de:	42 2f       	mov	r20, r18
    25e0:	50 e0       	ldi	r21, 0x00	; 0
    25e2:	20 e2       	ldi	r18, 0x20	; 32
    25e4:	30 e0       	ldi	r19, 0x00	; 0
    25e6:	02 c0       	rjmp	.+4      	; 0x25ec <CO_collectSeismic1Channel+0x16a>
    25e8:	22 0f       	add	r18, r18
    25ea:	33 1f       	adc	r19, r19
    25ec:	4a 95       	dec	r20
    25ee:	e2 f7       	brpl	.-8      	; 0x25e8 <CO_collectSeismic1Channel+0x166>
    25f0:	fc 01       	movw	r30, r24
    25f2:	26 a3       	lds	r18, 0x56
    25f4:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    25f6:	80 e4       	ldi	r24, 0x40	; 64
    25f8:	9a e0       	ldi	r25, 0x0A	; 10
    25fa:	2c 81       	ldd	r18, Y+4	; 0x04
    25fc:	42 2f       	mov	r20, r18
    25fe:	50 e0       	ldi	r21, 0x00	; 0
    2600:	20 e1       	ldi	r18, 0x10	; 16
    2602:	30 e0       	ldi	r19, 0x00	; 0
    2604:	02 c0       	rjmp	.+4      	; 0x260a <CO_collectSeismic1Channel+0x188>
    2606:	22 0f       	add	r18, r18
    2608:	33 1f       	adc	r19, r19
    260a:	4a 95       	dec	r20
    260c:	e2 f7       	brpl	.-8      	; 0x2606 <CO_collectSeismic1Channel+0x184>
    260e:	fc 01       	movw	r30, r24
    2610:	22 af       	sts	0x72, r18
    2612:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2614:	80 e4       	ldi	r24, 0x40	; 64
    2616:	9a e0       	ldi	r25, 0x0A	; 10
    2618:	20 e4       	ldi	r18, 0x40	; 64
    261a:	3a e0       	ldi	r19, 0x0A	; 10
    261c:	f9 01       	movw	r30, r18
    261e:	20 81       	ld	r18, Z
    2620:	20 7f       	andi	r18, 0xF0	; 240
    2622:	21 60       	ori	r18, 0x01	; 1
    2624:	fc 01       	movw	r30, r24
    2626:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    2628:	00 00       	nop
    262a:	20 91 69 50 	lds	r18, 0x5069
    262e:	30 91 6a 50 	lds	r19, 0x506A
    2632:	40 91 6b 50 	lds	r20, 0x506B
    2636:	50 91 6c 50 	lds	r21, 0x506C
    263a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    263c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    263e:	ae 8d       	ldd	r26, Y+30	; 0x1e
    2640:	bf 8d       	ldd	r27, Y+31	; 0x1f
    2642:	28 17       	cp	r18, r24
    2644:	39 07       	cpc	r19, r25
    2646:	4a 07       	cpc	r20, r26
    2648:	5b 07       	cpc	r21, r27
    264a:	78 f3       	brcs	.-34     	; 0x262a <CO_collectSeismic1Channel+0x1a8>

	// turn off timer and interrupts
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    264c:	80 e0       	ldi	r24, 0x00	; 0
    264e:	99 e0       	ldi	r25, 0x09	; 9
    2650:	20 e0       	ldi	r18, 0x00	; 0
    2652:	39 e0       	ldi	r19, 0x09	; 9
    2654:	f9 01       	movw	r30, r18
    2656:	20 81       	ld	r18, Z
    2658:	20 7f       	andi	r18, 0xF0	; 240
    265a:	fc 01       	movw	r30, r24
    265c:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    265e:	80 e4       	ldi	r24, 0x40	; 64
    2660:	9a e0       	ldi	r25, 0x0A	; 10
    2662:	20 e4       	ldi	r18, 0x40	; 64
    2664:	3a e0       	ldi	r19, 0x0A	; 10
    2666:	f9 01       	movw	r30, r18
    2668:	20 81       	ld	r18, Z
    266a:	20 7f       	andi	r18, 0xF0	; 240
    266c:	fc 01       	movw	r30, r24
    266e:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    2670:	80 ea       	ldi	r24, 0xA0	; 160
    2672:	90 e0       	ldi	r25, 0x00	; 0
    2674:	20 ea       	ldi	r18, 0xA0	; 160
    2676:	30 e0       	ldi	r19, 0x00	; 0
    2678:	f9 01       	movw	r30, r18
    267a:	22 81       	ldd	r18, Z+2	; 0x02
    267c:	29 7f       	andi	r18, 0xF9	; 249
    267e:	fc 01       	movw	r30, r24
    2680:	22 83       	std	Z+2, r18	; 0x02
	cli();
    2682:	f8 94       	cli

	SPICS(FALSE);
    2684:	80 e0       	ldi	r24, 0x00	; 0
    2686:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	SPIDisable();
    268a:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>
	enableADCMUX(FALSE);
    268e:	80 e0       	ldi	r24, 0x00	; 0
    2690:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <enableADCMUX>
	ADCPower(FALSE);
    2694:	80 e0       	ldi	r24, 0x00	; 0
    2696:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	
}
    269a:	2c 96       	adiw	r28, 0x0c	; 12
    269c:	cd bf       	out	0x3d, r28	; 61
    269e:	de bf       	out	0x3e, r29	; 62
    26a0:	df 91       	pop	r29
    26a2:	cf 91       	pop	r28
    26a4:	0f 91       	pop	r16
    26a6:	ef 90       	pop	r14
    26a8:	df 90       	pop	r13
    26aa:	cf 90       	pop	r12
    26ac:	bf 90       	pop	r11
    26ae:	af 90       	pop	r10
    26b0:	9f 90       	pop	r9
    26b2:	8f 90       	pop	r8
    26b4:	08 95       	ret

000026b6 <__vector_79>:

ISR(TCD0_CCA_vect) {
    26b6:	1f 92       	push	r1
    26b8:	0f 92       	push	r0
    26ba:	0f b6       	in	r0, 0x3f	; 63
    26bc:	0f 92       	push	r0
    26be:	00 90 3b 00 	lds	r0, 0x003B
    26c2:	0f 92       	push	r0
    26c4:	11 24       	eor	r1, r1
    26c6:	2f 93       	push	r18
    26c8:	3f 93       	push	r19
    26ca:	4f 93       	push	r20
    26cc:	5f 93       	push	r21
    26ce:	6f 93       	push	r22
    26d0:	7f 93       	push	r23
    26d2:	8f 93       	push	r24
    26d4:	9f 93       	push	r25
    26d6:	af 93       	push	r26
    26d8:	bf 93       	push	r27
    26da:	ef 93       	push	r30
    26dc:	ff 93       	push	r31
    26de:	cf 93       	push	r28
    26e0:	df 93       	push	r29
    26e2:	cd b7       	in	r28, 0x3d	; 61
    26e4:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    26e6:	0e 94 ea 14 	call	0x29d4	; 0x29d4 <sampleCurrentChannel>
}
    26ea:	df 91       	pop	r29
    26ec:	cf 91       	pop	r28
    26ee:	ff 91       	pop	r31
    26f0:	ef 91       	pop	r30
    26f2:	bf 91       	pop	r27
    26f4:	af 91       	pop	r26
    26f6:	9f 91       	pop	r25
    26f8:	8f 91       	pop	r24
    26fa:	7f 91       	pop	r23
    26fc:	6f 91       	pop	r22
    26fe:	5f 91       	pop	r21
    2700:	4f 91       	pop	r20
    2702:	3f 91       	pop	r19
    2704:	2f 91       	pop	r18
    2706:	0f 90       	pop	r0
    2708:	00 92 3b 00 	sts	0x003B, r0
    270c:	0f 90       	pop	r0
    270e:	0f be       	out	0x3f, r0	; 63
    2710:	0f 90       	pop	r0
    2712:	1f 90       	pop	r1
    2714:	18 95       	reti

00002716 <__vector_80>:

ISR(TCD0_CCB_vect) {
    2716:	1f 92       	push	r1
    2718:	0f 92       	push	r0
    271a:	0f b6       	in	r0, 0x3f	; 63
    271c:	0f 92       	push	r0
    271e:	00 90 3b 00 	lds	r0, 0x003B
    2722:	0f 92       	push	r0
    2724:	11 24       	eor	r1, r1
    2726:	2f 93       	push	r18
    2728:	3f 93       	push	r19
    272a:	4f 93       	push	r20
    272c:	5f 93       	push	r21
    272e:	6f 93       	push	r22
    2730:	7f 93       	push	r23
    2732:	8f 93       	push	r24
    2734:	9f 93       	push	r25
    2736:	af 93       	push	r26
    2738:	bf 93       	push	r27
    273a:	ef 93       	push	r30
    273c:	ff 93       	push	r31
    273e:	cf 93       	push	r28
    2740:	df 93       	push	r29
    2742:	cd b7       	in	r28, 0x3d	; 61
    2744:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2746:	0e 94 ea 14 	call	0x29d4	; 0x29d4 <sampleCurrentChannel>
}
    274a:	df 91       	pop	r29
    274c:	cf 91       	pop	r28
    274e:	ff 91       	pop	r31
    2750:	ef 91       	pop	r30
    2752:	bf 91       	pop	r27
    2754:	af 91       	pop	r26
    2756:	9f 91       	pop	r25
    2758:	8f 91       	pop	r24
    275a:	7f 91       	pop	r23
    275c:	6f 91       	pop	r22
    275e:	5f 91       	pop	r21
    2760:	4f 91       	pop	r20
    2762:	3f 91       	pop	r19
    2764:	2f 91       	pop	r18
    2766:	0f 90       	pop	r0
    2768:	00 92 3b 00 	sts	0x003B, r0
    276c:	0f 90       	pop	r0
    276e:	0f be       	out	0x3f, r0	; 63
    2770:	0f 90       	pop	r0
    2772:	1f 90       	pop	r1
    2774:	18 95       	reti

00002776 <__vector_81>:

ISR(TCD0_CCC_vect) {
    2776:	1f 92       	push	r1
    2778:	0f 92       	push	r0
    277a:	0f b6       	in	r0, 0x3f	; 63
    277c:	0f 92       	push	r0
    277e:	00 90 3b 00 	lds	r0, 0x003B
    2782:	0f 92       	push	r0
    2784:	11 24       	eor	r1, r1
    2786:	2f 93       	push	r18
    2788:	3f 93       	push	r19
    278a:	4f 93       	push	r20
    278c:	5f 93       	push	r21
    278e:	6f 93       	push	r22
    2790:	7f 93       	push	r23
    2792:	8f 93       	push	r24
    2794:	9f 93       	push	r25
    2796:	af 93       	push	r26
    2798:	bf 93       	push	r27
    279a:	ef 93       	push	r30
    279c:	ff 93       	push	r31
    279e:	cf 93       	push	r28
    27a0:	df 93       	push	r29
    27a2:	cd b7       	in	r28, 0x3d	; 61
    27a4:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    27a6:	0e 94 ea 14 	call	0x29d4	; 0x29d4 <sampleCurrentChannel>
}
    27aa:	df 91       	pop	r29
    27ac:	cf 91       	pop	r28
    27ae:	ff 91       	pop	r31
    27b0:	ef 91       	pop	r30
    27b2:	bf 91       	pop	r27
    27b4:	af 91       	pop	r26
    27b6:	9f 91       	pop	r25
    27b8:	8f 91       	pop	r24
    27ba:	7f 91       	pop	r23
    27bc:	6f 91       	pop	r22
    27be:	5f 91       	pop	r21
    27c0:	4f 91       	pop	r20
    27c2:	3f 91       	pop	r19
    27c4:	2f 91       	pop	r18
    27c6:	0f 90       	pop	r0
    27c8:	00 92 3b 00 	sts	0x003B, r0
    27cc:	0f 90       	pop	r0
    27ce:	0f be       	out	0x3f, r0	; 63
    27d0:	0f 90       	pop	r0
    27d2:	1f 90       	pop	r1
    27d4:	18 95       	reti

000027d6 <__vector_82>:

ISR(TCD0_CCD_vect) {
    27d6:	1f 92       	push	r1
    27d8:	0f 92       	push	r0
    27da:	0f b6       	in	r0, 0x3f	; 63
    27dc:	0f 92       	push	r0
    27de:	00 90 3b 00 	lds	r0, 0x003B
    27e2:	0f 92       	push	r0
    27e4:	11 24       	eor	r1, r1
    27e6:	2f 93       	push	r18
    27e8:	3f 93       	push	r19
    27ea:	4f 93       	push	r20
    27ec:	5f 93       	push	r21
    27ee:	6f 93       	push	r22
    27f0:	7f 93       	push	r23
    27f2:	8f 93       	push	r24
    27f4:	9f 93       	push	r25
    27f6:	af 93       	push	r26
    27f8:	bf 93       	push	r27
    27fa:	ef 93       	push	r30
    27fc:	ff 93       	push	r31
    27fe:	cf 93       	push	r28
    2800:	df 93       	push	r29
    2802:	cd b7       	in	r28, 0x3d	; 61
    2804:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2806:	0e 94 ea 14 	call	0x29d4	; 0x29d4 <sampleCurrentChannel>
	SPICount = 0;
    280a:	10 92 c3 50 	sts	0x50C3, r1
}
    280e:	df 91       	pop	r29
    2810:	cf 91       	pop	r28
    2812:	ff 91       	pop	r31
    2814:	ef 91       	pop	r30
    2816:	bf 91       	pop	r27
    2818:	af 91       	pop	r26
    281a:	9f 91       	pop	r25
    281c:	8f 91       	pop	r24
    281e:	7f 91       	pop	r23
    2820:	6f 91       	pop	r22
    2822:	5f 91       	pop	r21
    2824:	4f 91       	pop	r20
    2826:	3f 91       	pop	r19
    2828:	2f 91       	pop	r18
    282a:	0f 90       	pop	r0
    282c:	00 92 3b 00 	sts	0x003B, r0
    2830:	0f 90       	pop	r0
    2832:	0f be       	out	0x3f, r0	; 63
    2834:	0f 90       	pop	r0
    2836:	1f 90       	pop	r1
    2838:	18 95       	reti

0000283a <__vector_77>:

ISR(TCD0_OVF_vect) {
    283a:	1f 92       	push	r1
    283c:	0f 92       	push	r0
    283e:	0f b6       	in	r0, 0x3f	; 63
    2840:	0f 92       	push	r0
    2842:	00 90 3b 00 	lds	r0, 0x003B
    2846:	0f 92       	push	r0
    2848:	11 24       	eor	r1, r1
    284a:	2f 93       	push	r18
    284c:	3f 93       	push	r19
    284e:	4f 93       	push	r20
    2850:	5f 93       	push	r21
    2852:	6f 93       	push	r22
    2854:	7f 93       	push	r23
    2856:	8f 93       	push	r24
    2858:	9f 93       	push	r25
    285a:	af 93       	push	r26
    285c:	bf 93       	push	r27
    285e:	ef 93       	push	r30
    2860:	ff 93       	push	r31
    2862:	cf 93       	push	r28
    2864:	df 93       	push	r29
    2866:	cd b7       	in	r28, 0x3d	; 61
    2868:	de b7       	in	r29, 0x3e	; 62
    286a:	29 97       	sbiw	r28, 0x09	; 9
    286c:	cd bf       	out	0x3d, r28	; 61
    286e:	de bf       	out	0x3e, r29	; 62
	//writeSE2FRAM();
	volatile int32_t sum = 0;
    2870:	1a 82       	std	Y+2, r1	; 0x02
    2872:	1b 82       	std	Y+3, r1	; 0x03
    2874:	1c 82       	std	Y+4, r1	; 0x04
    2876:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
		
	//SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2878:	19 82       	std	Y+1, r1	; 0x01
    287a:	4f c0       	rjmp	.+158    	; 0x291a <__vector_77+0xe0>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    287c:	89 81       	ldd	r24, Y+1	; 0x01
    287e:	88 2f       	mov	r24, r24
    2880:	90 e0       	ldi	r25, 0x00	; 0
    2882:	86 5a       	subi	r24, 0xA6	; 166
    2884:	9f 4a       	sbci	r25, 0xAF	; 175
    2886:	fc 01       	movw	r30, r24
    2888:	80 81       	ld	r24, Z
    288a:	88 23       	and	r24, r24
    288c:	3c f4       	brge	.+14     	; 0x289c <__vector_77+0x62>
    288e:	ce 01       	movw	r24, r28
    2890:	06 96       	adiw	r24, 0x06	; 6
    2892:	03 96       	adiw	r24, 0x03	; 3
    2894:	2f ef       	ldi	r18, 0xFF	; 255
    2896:	fc 01       	movw	r30, r24
    2898:	20 83       	st	Z, r18
    289a:	05 c0       	rjmp	.+10     	; 0x28a6 <__vector_77+0x6c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    289c:	ce 01       	movw	r24, r28
    289e:	06 96       	adiw	r24, 0x06	; 6
    28a0:	03 96       	adiw	r24, 0x03	; 3
    28a2:	fc 01       	movw	r30, r24
    28a4:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    28a6:	ce 01       	movw	r24, r28
    28a8:	06 96       	adiw	r24, 0x06	; 6
    28aa:	02 96       	adiw	r24, 0x02	; 2
    28ac:	29 81       	ldd	r18, Y+1	; 0x01
    28ae:	22 2f       	mov	r18, r18
    28b0:	30 e0       	ldi	r19, 0x00	; 0
    28b2:	26 5a       	subi	r18, 0xA6	; 166
    28b4:	3f 4a       	sbci	r19, 0xAF	; 175
    28b6:	f9 01       	movw	r30, r18
    28b8:	20 81       	ld	r18, Z
    28ba:	fc 01       	movw	r30, r24
    28bc:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    28be:	ce 01       	movw	r24, r28
    28c0:	06 96       	adiw	r24, 0x06	; 6
    28c2:	01 96       	adiw	r24, 0x01	; 1
    28c4:	29 81       	ldd	r18, Y+1	; 0x01
    28c6:	22 2f       	mov	r18, r18
    28c8:	30 e0       	ldi	r19, 0x00	; 0
    28ca:	2f 5f       	subi	r18, 0xFF	; 255
    28cc:	3f 4f       	sbci	r19, 0xFF	; 255
    28ce:	26 5a       	subi	r18, 0xA6	; 166
    28d0:	3f 4a       	sbci	r19, 0xAF	; 175
    28d2:	f9 01       	movw	r30, r18
    28d4:	20 81       	ld	r18, Z
    28d6:	fc 01       	movw	r30, r24
    28d8:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    28da:	ce 01       	movw	r24, r28
    28dc:	06 96       	adiw	r24, 0x06	; 6
    28de:	29 81       	ldd	r18, Y+1	; 0x01
    28e0:	22 2f       	mov	r18, r18
    28e2:	30 e0       	ldi	r19, 0x00	; 0
    28e4:	2e 5f       	subi	r18, 0xFE	; 254
    28e6:	3f 4f       	sbci	r19, 0xFF	; 255
    28e8:	26 5a       	subi	r18, 0xA6	; 166
    28ea:	3f 4a       	sbci	r19, 0xAF	; 175
    28ec:	f9 01       	movw	r30, r18
    28ee:	20 81       	ld	r18, Z
    28f0:	fc 01       	movw	r30, r24
    28f2:	20 83       	st	Z, r18
		sum += currentSample;
    28f4:	2a 81       	ldd	r18, Y+2	; 0x02
    28f6:	3b 81       	ldd	r19, Y+3	; 0x03
    28f8:	4c 81       	ldd	r20, Y+4	; 0x04
    28fa:	5d 81       	ldd	r21, Y+5	; 0x05
    28fc:	8e 81       	ldd	r24, Y+6	; 0x06
    28fe:	9f 81       	ldd	r25, Y+7	; 0x07
    2900:	a8 85       	ldd	r26, Y+8	; 0x08
    2902:	b9 85       	ldd	r27, Y+9	; 0x09
    2904:	82 0f       	add	r24, r18
    2906:	93 1f       	adc	r25, r19
    2908:	a4 1f       	adc	r26, r20
    290a:	b5 1f       	adc	r27, r21
    290c:	8a 83       	std	Y+2, r24	; 0x02
    290e:	9b 83       	std	Y+3, r25	; 0x03
    2910:	ac 83       	std	Y+4, r26	; 0x04
    2912:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t sum = 0;
	volatile int32_t currentSample;
		
	//SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2914:	89 81       	ldd	r24, Y+1	; 0x01
    2916:	8d 5f       	subi	r24, 0xFD	; 253
    2918:	89 83       	std	Y+1, r24	; 0x01
    291a:	89 81       	ldd	r24, Y+1	; 0x01
    291c:	8c 30       	cpi	r24, 0x0C	; 12
    291e:	08 f4       	brcc	.+2      	; 0x2922 <__vector_77+0xe8>
    2920:	ad cf       	rjmp	.-166    	; 0x287c <__vector_77+0x42>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    2922:	8a 81       	ldd	r24, Y+2	; 0x02
    2924:	9b 81       	ldd	r25, Y+3	; 0x03
    2926:	ac 81       	ldd	r26, Y+4	; 0x04
    2928:	bd 81       	ldd	r27, Y+5	; 0x05
    292a:	24 e0       	ldi	r18, 0x04	; 4
    292c:	30 e0       	ldi	r19, 0x00	; 0
    292e:	40 e0       	ldi	r20, 0x00	; 0
    2930:	50 e0       	ldi	r21, 0x00	; 0
    2932:	bc 01       	movw	r22, r24
    2934:	cd 01       	movw	r24, r26
    2936:	0e 94 71 63 	call	0xc6e2	; 0xc6e2 <__divmodsi4>
    293a:	da 01       	movw	r26, r20
    293c:	c9 01       	movw	r24, r18
    293e:	8a 83       	std	Y+2, r24	; 0x02
    2940:	9b 83       	std	Y+3, r25	; 0x03
    2942:	ac 83       	std	Y+4, r26	; 0x04
    2944:	bd 83       	std	Y+5, r27	; 0x05
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount] = sum;
    2946:	20 91 67 50 	lds	r18, 0x5067
    294a:	30 91 68 50 	lds	r19, 0x5068
    294e:	80 91 69 50 	lds	r24, 0x5069
    2952:	90 91 6a 50 	lds	r25, 0x506A
    2956:	a0 91 6b 50 	lds	r26, 0x506B
    295a:	b0 91 6c 50 	lds	r27, 0x506C
    295e:	88 0f       	add	r24, r24
    2960:	99 1f       	adc	r25, r25
    2962:	88 0f       	add	r24, r24
    2964:	99 1f       	adc	r25, r25
    2966:	28 0f       	add	r18, r24
    2968:	39 1f       	adc	r19, r25
    296a:	8a 81       	ldd	r24, Y+2	; 0x02
    296c:	9b 81       	ldd	r25, Y+3	; 0x03
    296e:	ac 81       	ldd	r26, Y+4	; 0x04
    2970:	bd 81       	ldd	r27, Y+5	; 0x05
    2972:	f9 01       	movw	r30, r18
    2974:	80 83       	st	Z, r24
    2976:	91 83       	std	Z+1, r25	; 0x01
    2978:	a2 83       	std	Z+2, r26	; 0x02
    297a:	b3 83       	std	Z+3, r27	; 0x03
	sampleCount++;
    297c:	80 91 69 50 	lds	r24, 0x5069
    2980:	90 91 6a 50 	lds	r25, 0x506A
    2984:	a0 91 6b 50 	lds	r26, 0x506B
    2988:	b0 91 6c 50 	lds	r27, 0x506C
    298c:	01 96       	adiw	r24, 0x01	; 1
    298e:	a1 1d       	adc	r26, r1
    2990:	b1 1d       	adc	r27, r1
    2992:	80 93 69 50 	sts	0x5069, r24
    2996:	90 93 6a 50 	sts	0x506A, r25
    299a:	a0 93 6b 50 	sts	0x506B, r26
    299e:	b0 93 6c 50 	sts	0x506C, r27
}
    29a2:	29 96       	adiw	r28, 0x09	; 9
    29a4:	cd bf       	out	0x3d, r28	; 61
    29a6:	de bf       	out	0x3e, r29	; 62
    29a8:	df 91       	pop	r29
    29aa:	cf 91       	pop	r28
    29ac:	ff 91       	pop	r31
    29ae:	ef 91       	pop	r30
    29b0:	bf 91       	pop	r27
    29b2:	af 91       	pop	r26
    29b4:	9f 91       	pop	r25
    29b6:	8f 91       	pop	r24
    29b8:	7f 91       	pop	r23
    29ba:	6f 91       	pop	r22
    29bc:	5f 91       	pop	r21
    29be:	4f 91       	pop	r20
    29c0:	3f 91       	pop	r19
    29c2:	2f 91       	pop	r18
    29c4:	0f 90       	pop	r0
    29c6:	00 92 3b 00 	sts	0x003B, r0
    29ca:	0f 90       	pop	r0
    29cc:	0f be       	out	0x3f, r0	; 63
    29ce:	0f 90       	pop	r0
    29d0:	1f 90       	pop	r1
    29d2:	18 95       	reti

000029d4 <sampleCurrentChannel>:

void sampleCurrentChannel() {
    29d4:	cf 93       	push	r28
    29d6:	df 93       	push	r29
    29d8:	cd b7       	in	r28, 0x3d	; 61
    29da:	de b7       	in	r29, 0x3e	; 62
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    29dc:	80 ea       	ldi	r24, 0xA0	; 160
    29de:	96 e0       	ldi	r25, 0x06	; 6
    29e0:	22 e0       	ldi	r18, 0x02	; 2
    29e2:	fc 01       	movw	r30, r24
    29e4:	26 83       	std	Z+6, r18	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    29e6:	80 ec       	ldi	r24, 0xC0	; 192
    29e8:	98 e0       	ldi	r25, 0x08	; 8
    29ea:	2a ea       	ldi	r18, 0xAA	; 170
    29ec:	fc 01       	movw	r30, r24
    29ee:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    29f0:	00 00       	nop
    29f2:	80 ec       	ldi	r24, 0xC0	; 192
    29f4:	98 e0       	ldi	r25, 0x08	; 8
    29f6:	fc 01       	movw	r30, r24
    29f8:	82 81       	ldd	r24, Z+2	; 0x02
    29fa:	88 23       	and	r24, r24
    29fc:	d4 f7       	brge	.-12     	; 0x29f2 <sampleCurrentChannel+0x1e>
	SPIBuffer[SPICount] = SPIC.DATA;
    29fe:	80 91 c3 50 	lds	r24, 0x50C3
    2a02:	88 2f       	mov	r24, r24
    2a04:	90 e0       	ldi	r25, 0x00	; 0
    2a06:	20 ec       	ldi	r18, 0xC0	; 192
    2a08:	38 e0       	ldi	r19, 0x08	; 8
    2a0a:	f9 01       	movw	r30, r18
    2a0c:	23 81       	ldd	r18, Z+3	; 0x03
    2a0e:	86 5a       	subi	r24, 0xA6	; 166
    2a10:	9f 4a       	sbci	r25, 0xAF	; 175
    2a12:	fc 01       	movw	r30, r24
    2a14:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2a16:	80 ec       	ldi	r24, 0xC0	; 192
    2a18:	98 e0       	ldi	r25, 0x08	; 8
    2a1a:	2a ea       	ldi	r18, 0xAA	; 170
    2a1c:	fc 01       	movw	r30, r24
    2a1e:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a20:	00 00       	nop
    2a22:	80 ec       	ldi	r24, 0xC0	; 192
    2a24:	98 e0       	ldi	r25, 0x08	; 8
    2a26:	fc 01       	movw	r30, r24
    2a28:	82 81       	ldd	r24, Z+2	; 0x02
    2a2a:	88 23       	and	r24, r24
    2a2c:	d4 f7       	brge	.-12     	; 0x2a22 <sampleCurrentChannel+0x4e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    2a2e:	80 91 c3 50 	lds	r24, 0x50C3
    2a32:	88 2f       	mov	r24, r24
    2a34:	90 e0       	ldi	r25, 0x00	; 0
    2a36:	01 96       	adiw	r24, 0x01	; 1
    2a38:	20 ec       	ldi	r18, 0xC0	; 192
    2a3a:	38 e0       	ldi	r19, 0x08	; 8
    2a3c:	f9 01       	movw	r30, r18
    2a3e:	23 81       	ldd	r18, Z+3	; 0x03
    2a40:	86 5a       	subi	r24, 0xA6	; 166
    2a42:	9f 4a       	sbci	r25, 0xAF	; 175
    2a44:	fc 01       	movw	r30, r24
    2a46:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2a48:	80 ec       	ldi	r24, 0xC0	; 192
    2a4a:	98 e0       	ldi	r25, 0x08	; 8
    2a4c:	2a ea       	ldi	r18, 0xAA	; 170
    2a4e:	fc 01       	movw	r30, r24
    2a50:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a52:	00 00       	nop
    2a54:	80 ec       	ldi	r24, 0xC0	; 192
    2a56:	98 e0       	ldi	r25, 0x08	; 8
    2a58:	fc 01       	movw	r30, r24
    2a5a:	82 81       	ldd	r24, Z+2	; 0x02
    2a5c:	88 23       	and	r24, r24
    2a5e:	d4 f7       	brge	.-12     	; 0x2a54 <sampleCurrentChannel+0x80>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    2a60:	80 91 c3 50 	lds	r24, 0x50C3
    2a64:	88 2f       	mov	r24, r24
    2a66:	90 e0       	ldi	r25, 0x00	; 0
    2a68:	02 96       	adiw	r24, 0x02	; 2
    2a6a:	20 ec       	ldi	r18, 0xC0	; 192
    2a6c:	38 e0       	ldi	r19, 0x08	; 8
    2a6e:	f9 01       	movw	r30, r18
    2a70:	23 81       	ldd	r18, Z+3	; 0x03
    2a72:	86 5a       	subi	r24, 0xA6	; 166
    2a74:	9f 4a       	sbci	r25, 0xAF	; 175
    2a76:	fc 01       	movw	r30, r24
    2a78:	20 83       	st	Z, r18
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2a7a:	80 ea       	ldi	r24, 0xA0	; 160
    2a7c:	96 e0       	ldi	r25, 0x06	; 6
    2a7e:	22 e0       	ldi	r18, 0x02	; 2
    2a80:	fc 01       	movw	r30, r24
    2a82:	25 83       	std	Z+5, r18	; 0x05
	SPICount +=3;
    2a84:	80 91 c3 50 	lds	r24, 0x50C3
    2a88:	8d 5f       	subi	r24, 0xFD	; 253
    2a8a:	80 93 c3 50 	sts	0x50C3, r24
}
    2a8e:	df 91       	pop	r29
    2a90:	cf 91       	pop	r28
    2a92:	08 95       	ret

00002a94 <writeSE2FRAM>:

void writeSE2FRAM() {
    2a94:	cf 93       	push	r28
    2a96:	df 93       	push	r29
    2a98:	cd b7       	in	r28, 0x3d	; 61
    2a9a:	de b7       	in	r29, 0x3e	; 62
    2a9c:	29 97       	sbiw	r28, 0x09	; 9
    2a9e:	cd bf       	out	0x3d, r28	; 61
    2aa0:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    2aa2:	1a 82       	std	Y+2, r1	; 0x02
    2aa4:	1b 82       	std	Y+3, r1	; 0x03
    2aa6:	1c 82       	std	Y+4, r1	; 0x04
    2aa8:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
    2aaa:	80 91 69 50 	lds	r24, 0x5069
    2aae:	90 91 6a 50 	lds	r25, 0x506A
    2ab2:	a0 91 6b 50 	lds	r26, 0x506B
    2ab6:	b0 91 6c 50 	lds	r27, 0x506C
    2aba:	01 96       	adiw	r24, 0x01	; 1
    2abc:	a1 1d       	adc	r26, r1
    2abe:	b1 1d       	adc	r27, r1
    2ac0:	80 93 69 50 	sts	0x5069, r24
    2ac4:	90 93 6a 50 	sts	0x506A, r25
    2ac8:	a0 93 6b 50 	sts	0x506B, r26
    2acc:	b0 93 6c 50 	sts	0x506C, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2ad0:	80 ec       	ldi	r24, 0xC0	; 192
    2ad2:	98 e0       	ldi	r25, 0x08	; 8
    2ad4:	20 ed       	ldi	r18, 0xD0	; 208
    2ad6:	fc 01       	movw	r30, r24
    2ad8:	20 83       	st	Z, r18
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2ada:	19 82       	std	Y+1, r1	; 0x01
    2adc:	4f c0       	rjmp	.+158    	; 0x2b7c <writeSE2FRAM+0xe8>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2ade:	89 81       	ldd	r24, Y+1	; 0x01
    2ae0:	88 2f       	mov	r24, r24
    2ae2:	90 e0       	ldi	r25, 0x00	; 0
    2ae4:	86 5a       	subi	r24, 0xA6	; 166
    2ae6:	9f 4a       	sbci	r25, 0xAF	; 175
    2ae8:	fc 01       	movw	r30, r24
    2aea:	80 81       	ld	r24, Z
    2aec:	88 23       	and	r24, r24
    2aee:	3c f4       	brge	.+14     	; 0x2afe <writeSE2FRAM+0x6a>
    2af0:	ce 01       	movw	r24, r28
    2af2:	06 96       	adiw	r24, 0x06	; 6
    2af4:	03 96       	adiw	r24, 0x03	; 3
    2af6:	2f ef       	ldi	r18, 0xFF	; 255
    2af8:	fc 01       	movw	r30, r24
    2afa:	20 83       	st	Z, r18
    2afc:	05 c0       	rjmp	.+10     	; 0x2b08 <writeSE2FRAM+0x74>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    2afe:	ce 01       	movw	r24, r28
    2b00:	06 96       	adiw	r24, 0x06	; 6
    2b02:	03 96       	adiw	r24, 0x03	; 3
    2b04:	fc 01       	movw	r30, r24
    2b06:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2b08:	ce 01       	movw	r24, r28
    2b0a:	06 96       	adiw	r24, 0x06	; 6
    2b0c:	02 96       	adiw	r24, 0x02	; 2
    2b0e:	29 81       	ldd	r18, Y+1	; 0x01
    2b10:	22 2f       	mov	r18, r18
    2b12:	30 e0       	ldi	r19, 0x00	; 0
    2b14:	26 5a       	subi	r18, 0xA6	; 166
    2b16:	3f 4a       	sbci	r19, 0xAF	; 175
    2b18:	f9 01       	movw	r30, r18
    2b1a:	20 81       	ld	r18, Z
    2b1c:	fc 01       	movw	r30, r24
    2b1e:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    2b20:	ce 01       	movw	r24, r28
    2b22:	06 96       	adiw	r24, 0x06	; 6
    2b24:	01 96       	adiw	r24, 0x01	; 1
    2b26:	29 81       	ldd	r18, Y+1	; 0x01
    2b28:	22 2f       	mov	r18, r18
    2b2a:	30 e0       	ldi	r19, 0x00	; 0
    2b2c:	2f 5f       	subi	r18, 0xFF	; 255
    2b2e:	3f 4f       	sbci	r19, 0xFF	; 255
    2b30:	26 5a       	subi	r18, 0xA6	; 166
    2b32:	3f 4a       	sbci	r19, 0xAF	; 175
    2b34:	f9 01       	movw	r30, r18
    2b36:	20 81       	ld	r18, Z
    2b38:	fc 01       	movw	r30, r24
    2b3a:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2b3c:	ce 01       	movw	r24, r28
    2b3e:	06 96       	adiw	r24, 0x06	; 6
    2b40:	29 81       	ldd	r18, Y+1	; 0x01
    2b42:	22 2f       	mov	r18, r18
    2b44:	30 e0       	ldi	r19, 0x00	; 0
    2b46:	2e 5f       	subi	r18, 0xFE	; 254
    2b48:	3f 4f       	sbci	r19, 0xFF	; 255
    2b4a:	26 5a       	subi	r18, 0xA6	; 166
    2b4c:	3f 4a       	sbci	r19, 0xAF	; 175
    2b4e:	f9 01       	movw	r30, r18
    2b50:	20 81       	ld	r18, Z
    2b52:	fc 01       	movw	r30, r24
    2b54:	20 83       	st	Z, r18
		sum += currentSample;
    2b56:	2a 81       	ldd	r18, Y+2	; 0x02
    2b58:	3b 81       	ldd	r19, Y+3	; 0x03
    2b5a:	4c 81       	ldd	r20, Y+4	; 0x04
    2b5c:	5d 81       	ldd	r21, Y+5	; 0x05
    2b5e:	8e 81       	ldd	r24, Y+6	; 0x06
    2b60:	9f 81       	ldd	r25, Y+7	; 0x07
    2b62:	a8 85       	ldd	r26, Y+8	; 0x08
    2b64:	b9 85       	ldd	r27, Y+9	; 0x09
    2b66:	82 0f       	add	r24, r18
    2b68:	93 1f       	adc	r25, r19
    2b6a:	a4 1f       	adc	r26, r20
    2b6c:	b5 1f       	adc	r27, r21
    2b6e:	8a 83       	std	Y+2, r24	; 0x02
    2b70:	9b 83       	std	Y+3, r25	; 0x03
    2b72:	ac 83       	std	Y+4, r26	; 0x04
    2b74:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2b76:	89 81       	ldd	r24, Y+1	; 0x01
    2b78:	8d 5f       	subi	r24, 0xFD	; 253
    2b7a:	89 83       	std	Y+1, r24	; 0x01
    2b7c:	89 81       	ldd	r24, Y+1	; 0x01
    2b7e:	8c 30       	cpi	r24, 0x0C	; 12
    2b80:	08 f4       	brcc	.+2      	; 0x2b84 <writeSE2FRAM+0xf0>
    2b82:	ad cf       	rjmp	.-166    	; 0x2ade <writeSE2FRAM+0x4a>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    2b84:	8a 81       	ldd	r24, Y+2	; 0x02
    2b86:	9b 81       	ldd	r25, Y+3	; 0x03
    2b88:	ac 81       	ldd	r26, Y+4	; 0x04
    2b8a:	bd 81       	ldd	r27, Y+5	; 0x05
    2b8c:	24 e0       	ldi	r18, 0x04	; 4
    2b8e:	30 e0       	ldi	r19, 0x00	; 0
    2b90:	40 e0       	ldi	r20, 0x00	; 0
    2b92:	50 e0       	ldi	r21, 0x00	; 0
    2b94:	bc 01       	movw	r22, r24
    2b96:	cd 01       	movw	r24, r26
    2b98:	0e 94 71 63 	call	0xc6e2	; 0xc6e2 <__divmodsi4>
    2b9c:	da 01       	movw	r26, r20
    2b9e:	c9 01       	movw	r24, r18
    2ba0:	8a 83       	std	Y+2, r24	; 0x02
    2ba2:	9b 83       	std	Y+3, r25	; 0x03
    2ba4:	ac 83       	std	Y+4, r26	; 0x04
    2ba6:	bd 83       	std	Y+5, r27	; 0x05
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2ba8:	ce 01       	movw	r24, r28
    2baa:	02 96       	adiw	r24, 0x02	; 2
    2bac:	fc 01       	movw	r30, r24
    2bae:	80 81       	ld	r24, Z
    2bb0:	80 93 5c 50 	sts	0x505C, r24
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2bb4:	ce 01       	movw	r24, r28
    2bb6:	02 96       	adiw	r24, 0x02	; 2
    2bb8:	fc 01       	movw	r30, r24
    2bba:	81 81       	ldd	r24, Z+1	; 0x01
    2bbc:	80 93 5b 50 	sts	0x505B, r24
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    2bc0:	ce 01       	movw	r24, r28
    2bc2:	02 96       	adiw	r24, 0x02	; 2
    2bc4:	fc 01       	movw	r30, r24
    2bc6:	82 81       	ldd	r24, Z+2	; 0x02
    2bc8:	80 93 5a 50 	sts	0x505A, r24


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2bcc:	80 e4       	ldi	r24, 0x40	; 64
    2bce:	96 e0       	ldi	r25, 0x06	; 6
    2bd0:	20 e1       	ldi	r18, 0x10	; 16
    2bd2:	fc 01       	movw	r30, r24
    2bd4:	26 83       	std	Z+6, r18	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2bd6:	80 e2       	ldi	r24, 0x20	; 32
    2bd8:	96 e0       	ldi	r25, 0x06	; 6
    2bda:	28 e0       	ldi	r18, 0x08	; 8
    2bdc:	fc 01       	movw	r30, r24
    2bde:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2be0:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2be2:	80 ec       	ldi	r24, 0xC0	; 192
    2be4:	98 e0       	ldi	r25, 0x08	; 8
    2be6:	26 e0       	ldi	r18, 0x06	; 6
    2be8:	fc 01       	movw	r30, r24
    2bea:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2bec:	00 00       	nop
    2bee:	80 ec       	ldi	r24, 0xC0	; 192
    2bf0:	98 e0       	ldi	r25, 0x08	; 8
    2bf2:	fc 01       	movw	r30, r24
    2bf4:	82 81       	ldd	r24, Z+2	; 0x02
    2bf6:	88 23       	and	r24, r24
    2bf8:	d4 f7       	brge	.-12     	; 0x2bee <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    2bfa:	80 ec       	ldi	r24, 0xC0	; 192
    2bfc:	98 e0       	ldi	r25, 0x08	; 8
    2bfe:	fc 01       	movw	r30, r24
    2c00:	83 81       	ldd	r24, Z+3	; 0x03
    2c02:	80 93 66 50 	sts	0x5066, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    2c06:	80 e2       	ldi	r24, 0x20	; 32
    2c08:	96 e0       	ldi	r25, 0x06	; 6
    2c0a:	28 e0       	ldi	r18, 0x08	; 8
    2c0c:	fc 01       	movw	r30, r24
    2c0e:	25 83       	std	Z+5, r18	; 0x05
	nop(); // time for CS_FRAM to accept high signal
    2c10:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2c12:	80 e2       	ldi	r24, 0x20	; 32
    2c14:	96 e0       	ldi	r25, 0x06	; 6
    2c16:	28 e0       	ldi	r18, 0x08	; 8
    2c18:	fc 01       	movw	r30, r24
    2c1a:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2c1c:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2c1e:	80 ec       	ldi	r24, 0xC0	; 192
    2c20:	98 e0       	ldi	r25, 0x08	; 8
    2c22:	22 e0       	ldi	r18, 0x02	; 2
    2c24:	fc 01       	movw	r30, r24
    2c26:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2c28:	00 00       	nop
    2c2a:	80 ec       	ldi	r24, 0xC0	; 192
    2c2c:	98 e0       	ldi	r25, 0x08	; 8
    2c2e:	fc 01       	movw	r30, r24
    2c30:	82 81       	ldd	r24, Z+2	; 0x02
    2c32:	88 23       	and	r24, r24
    2c34:	d4 f7       	brge	.-12     	; 0x2c2a <writeSE2FRAM+0x196>
	SPIBuffer[12] = SPIC.DATA;
    2c36:	80 ec       	ldi	r24, 0xC0	; 192
    2c38:	98 e0       	ldi	r25, 0x08	; 8
    2c3a:	fc 01       	movw	r30, r24
    2c3c:	83 81       	ldd	r24, Z+3	; 0x03
    2c3e:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2c42:	80 ec       	ldi	r24, 0xC0	; 192
    2c44:	98 e0       	ldi	r25, 0x08	; 8
    2c46:	20 91 45 40 	lds	r18, 0x4045
    2c4a:	fc 01       	movw	r30, r24
    2c4c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2c4e:	00 00       	nop
    2c50:	80 ec       	ldi	r24, 0xC0	; 192
    2c52:	98 e0       	ldi	r25, 0x08	; 8
    2c54:	fc 01       	movw	r30, r24
    2c56:	82 81       	ldd	r24, Z+2	; 0x02
    2c58:	88 23       	and	r24, r24
    2c5a:	d4 f7       	brge	.-12     	; 0x2c50 <writeSE2FRAM+0x1bc>
	SPIBuffer[12] = SPIC.DATA;
    2c5c:	80 ec       	ldi	r24, 0xC0	; 192
    2c5e:	98 e0       	ldi	r25, 0x08	; 8
    2c60:	fc 01       	movw	r30, r24
    2c62:	83 81       	ldd	r24, Z+3	; 0x03
    2c64:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2c68:	80 ec       	ldi	r24, 0xC0	; 192
    2c6a:	98 e0       	ldi	r25, 0x08	; 8
    2c6c:	24 e4       	ldi	r18, 0x44	; 68
    2c6e:	30 e4       	ldi	r19, 0x40	; 64
    2c70:	f9 01       	movw	r30, r18
    2c72:	20 81       	ld	r18, Z
    2c74:	fc 01       	movw	r30, r24
    2c76:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2c78:	00 00       	nop
    2c7a:	80 ec       	ldi	r24, 0xC0	; 192
    2c7c:	98 e0       	ldi	r25, 0x08	; 8
    2c7e:	fc 01       	movw	r30, r24
    2c80:	82 81       	ldd	r24, Z+2	; 0x02
    2c82:	88 23       	and	r24, r24
    2c84:	d4 f7       	brge	.-12     	; 0x2c7a <writeSE2FRAM+0x1e6>
	SPIBuffer[12] = SPIC.DATA;
    2c86:	80 ec       	ldi	r24, 0xC0	; 192
    2c88:	98 e0       	ldi	r25, 0x08	; 8
    2c8a:	fc 01       	movw	r30, r24
    2c8c:	83 81       	ldd	r24, Z+3	; 0x03
    2c8e:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = SPIBuffer[0];
    2c92:	80 ec       	ldi	r24, 0xC0	; 192
    2c94:	98 e0       	ldi	r25, 0x08	; 8
    2c96:	20 91 5a 50 	lds	r18, 0x505A
    2c9a:	fc 01       	movw	r30, r24
    2c9c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2c9e:	00 00       	nop
    2ca0:	80 ec       	ldi	r24, 0xC0	; 192
    2ca2:	98 e0       	ldi	r25, 0x08	; 8
    2ca4:	fc 01       	movw	r30, r24
    2ca6:	82 81       	ldd	r24, Z+2	; 0x02
    2ca8:	88 23       	and	r24, r24
    2caa:	d4 f7       	brge	.-12     	; 0x2ca0 <writeSE2FRAM+0x20c>
	SPIBuffer[12] = SPIC.DATA;
    2cac:	80 ec       	ldi	r24, 0xC0	; 192
    2cae:	98 e0       	ldi	r25, 0x08	; 8
    2cb0:	fc 01       	movw	r30, r24
    2cb2:	83 81       	ldd	r24, Z+3	; 0x03
    2cb4:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = SPIBuffer[1];
    2cb8:	80 ec       	ldi	r24, 0xC0	; 192
    2cba:	98 e0       	ldi	r25, 0x08	; 8
    2cbc:	20 91 5b 50 	lds	r18, 0x505B
    2cc0:	fc 01       	movw	r30, r24
    2cc2:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2cc4:	00 00       	nop
    2cc6:	80 ec       	ldi	r24, 0xC0	; 192
    2cc8:	98 e0       	ldi	r25, 0x08	; 8
    2cca:	fc 01       	movw	r30, r24
    2ccc:	82 81       	ldd	r24, Z+2	; 0x02
    2cce:	88 23       	and	r24, r24
    2cd0:	d4 f7       	brge	.-12     	; 0x2cc6 <writeSE2FRAM+0x232>
	SPIBuffer[12] = SPIC.DATA;
    2cd2:	80 ec       	ldi	r24, 0xC0	; 192
    2cd4:	98 e0       	ldi	r25, 0x08	; 8
    2cd6:	fc 01       	movw	r30, r24
    2cd8:	83 81       	ldd	r24, Z+3	; 0x03
    2cda:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = SPIBuffer[2];
    2cde:	80 ec       	ldi	r24, 0xC0	; 192
    2ce0:	98 e0       	ldi	r25, 0x08	; 8
    2ce2:	20 91 5c 50 	lds	r18, 0x505C
    2ce6:	fc 01       	movw	r30, r24
    2ce8:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2cea:	00 00       	nop
    2cec:	80 ec       	ldi	r24, 0xC0	; 192
    2cee:	98 e0       	ldi	r25, 0x08	; 8
    2cf0:	fc 01       	movw	r30, r24
    2cf2:	82 81       	ldd	r24, Z+2	; 0x02
    2cf4:	88 23       	and	r24, r24
    2cf6:	d4 f7       	brge	.-12     	; 0x2cec <writeSE2FRAM+0x258>
	SPIBuffer[12] = SPIC.DATA;
    2cf8:	80 ec       	ldi	r24, 0xC0	; 192
    2cfa:	98 e0       	ldi	r25, 0x08	; 8
    2cfc:	fc 01       	movw	r30, r24
    2cfe:	83 81       	ldd	r24, Z+3	; 0x03
    2d00:	80 93 66 50 	sts	0x5066, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2d04:	80 e2       	ldi	r24, 0x20	; 32
    2d06:	96 e0       	ldi	r25, 0x06	; 6
    2d08:	28 e0       	ldi	r18, 0x08	; 8
    2d0a:	fc 01       	movw	r30, r24
    2d0c:	25 83       	std	Z+5, r18	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2d0e:	80 e4       	ldi	r24, 0x40	; 64
    2d10:	96 e0       	ldi	r25, 0x06	; 6
    2d12:	20 e1       	ldi	r18, 0x10	; 16
    2d14:	fc 01       	movw	r30, r24
    2d16:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2d18:	80 ec       	ldi	r24, 0xC0	; 192
    2d1a:	98 e0       	ldi	r25, 0x08	; 8
    2d1c:	24 e5       	ldi	r18, 0x54	; 84
    2d1e:	fc 01       	movw	r30, r24
    2d20:	20 83       	st	Z, r18
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2d22:	80 e4       	ldi	r24, 0x40	; 64
    2d24:	96 e0       	ldi	r25, 0x06	; 6
    2d26:	20 e1       	ldi	r18, 0x10	; 16
    2d28:	fc 01       	movw	r30, r24
    2d2a:	26 83       	std	Z+6, r18	; 0x06
	
	FRAMAddress +=3;
    2d2c:	80 91 44 40 	lds	r24, 0x4044
    2d30:	90 91 45 40 	lds	r25, 0x4045
    2d34:	03 96       	adiw	r24, 0x03	; 3
    2d36:	80 93 44 40 	sts	0x4044, r24
    2d3a:	90 93 45 40 	sts	0x4045, r25
	checksumADC[0] += SPIBuffer[0];
    2d3e:	90 91 26 21 	lds	r25, 0x2126
    2d42:	80 91 5a 50 	lds	r24, 0x505A
    2d46:	89 0f       	add	r24, r25
    2d48:	80 93 26 21 	sts	0x2126, r24
	checksumADC[1] += SPIBuffer[1];
    2d4c:	90 91 27 21 	lds	r25, 0x2127
    2d50:	80 91 5b 50 	lds	r24, 0x505B
    2d54:	89 0f       	add	r24, r25
    2d56:	80 93 27 21 	sts	0x2127, r24
	checksumADC[2] += SPIBuffer[2];
    2d5a:	90 91 28 21 	lds	r25, 0x2128
    2d5e:	80 91 5c 50 	lds	r24, 0x505C
    2d62:	89 0f       	add	r24, r25
    2d64:	80 93 28 21 	sts	0x2128, r24
}
    2d68:	29 96       	adiw	r28, 0x09	; 9
    2d6a:	cd bf       	out	0x3d, r28	; 61
    2d6c:	de bf       	out	0x3e, r29	; 62
    2d6e:	df 91       	pop	r29
    2d70:	cf 91       	pop	r28
    2d72:	08 95       	ret

00002d74 <calcChecksumFRAM>:


void calcChecksumFRAM() {
    2d74:	2f 92       	push	r2
    2d76:	3f 92       	push	r3
    2d78:	4f 92       	push	r4
    2d7a:	5f 92       	push	r5
    2d7c:	6f 92       	push	r6
    2d7e:	7f 92       	push	r7
    2d80:	8f 92       	push	r8
    2d82:	9f 92       	push	r9
    2d84:	af 92       	push	r10
    2d86:	bf 92       	push	r11
    2d88:	cf 92       	push	r12
    2d8a:	df 92       	push	r13
    2d8c:	ef 92       	push	r14
    2d8e:	ff 92       	push	r15
    2d90:	0f 93       	push	r16
    2d92:	1f 93       	push	r17
    2d94:	cf 93       	push	r28
    2d96:	df 93       	push	r29
    2d98:	00 d0       	rcall	.+0      	; 0x2d9a <calcChecksumFRAM+0x26>
    2d9a:	0f 92       	push	r0
    2d9c:	cd b7       	in	r28, 0x3d	; 61
    2d9e:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    2da0:	aa 24       	eor	r10, r10
    2da2:	bb 24       	eor	r11, r11
    2da4:	cc 24       	eor	r12, r12
    2da6:	dd 24       	eor	r13, r13
    2da8:	ee 24       	eor	r14, r14
    2daa:	ff 24       	eor	r15, r15
    2dac:	00 e0       	ldi	r16, 0x00	; 0
    2dae:	10 e0       	ldi	r17, 0x00	; 0
    2db0:	a0 92 90 50 	sts	0x5090, r10
    2db4:	b0 92 91 50 	sts	0x5091, r11
    2db8:	c0 92 92 50 	sts	0x5092, r12
    2dbc:	d0 92 93 50 	sts	0x5093, r13
    2dc0:	e0 92 94 50 	sts	0x5094, r14
    2dc4:	f0 92 95 50 	sts	0x5095, r15
    2dc8:	00 93 96 50 	sts	0x5096, r16
    2dcc:	10 93 97 50 	sts	0x5097, r17
    2dd0:	2a 2d       	mov	r18, r10
    2dd2:	3b 2d       	mov	r19, r11
    2dd4:	4c 2d       	mov	r20, r12
    2dd6:	5d 2d       	mov	r21, r13
    2dd8:	6e 2d       	mov	r22, r14
    2dda:	7f 2d       	mov	r23, r15
    2ddc:	80 2f       	mov	r24, r16
    2dde:	91 2f       	mov	r25, r17
    2de0:	20 93 88 50 	sts	0x5088, r18
    2de4:	30 93 89 50 	sts	0x5089, r19
    2de8:	40 93 8a 50 	sts	0x508A, r20
    2dec:	50 93 8b 50 	sts	0x508B, r21
    2df0:	60 93 8c 50 	sts	0x508C, r22
    2df4:	70 93 8d 50 	sts	0x508D, r23
    2df8:	80 93 8e 50 	sts	0x508E, r24
    2dfc:	90 93 8f 50 	sts	0x508F, r25
    2e00:	20 93 80 50 	sts	0x5080, r18
    2e04:	30 93 81 50 	sts	0x5081, r19
    2e08:	40 93 82 50 	sts	0x5082, r20
    2e0c:	50 93 83 50 	sts	0x5083, r21
    2e10:	60 93 84 50 	sts	0x5084, r22
    2e14:	70 93 85 50 	sts	0x5085, r23
    2e18:	80 93 86 50 	sts	0x5086, r24
    2e1c:	90 93 87 50 	sts	0x5087, r25
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    2e20:	80 e0       	ldi	r24, 0x00	; 0
    2e22:	80 93 2b 21 	sts	0x212B, r24
    2e26:	80 93 2a 21 	sts	0x212A, r24
    2e2a:	80 93 29 21 	sts	0x2129, r24
	FRAMAddress = FR_BASEADD;
    2e2e:	10 92 44 40 	sts	0x4044, r1
    2e32:	10 92 45 40 	sts	0x4045, r1
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    2e36:	19 82       	std	Y+1, r1	; 0x01
    2e38:	1a 82       	std	Y+2, r1	; 0x02
    2e3a:	88 c2       	rjmp	.+1296   	; 0x334c <calcChecksumFRAM+0x5d8>
		readFRAM(FR_READ_BUFFER_SIZE);
    2e3c:	81 e7       	ldi	r24, 0x71	; 113
    2e3e:	9c e1       	ldi	r25, 0x1C	; 28
    2e40:	0e 94 cb 38 	call	0x7196	; 0x7196 <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    2e44:	80 91 44 40 	lds	r24, 0x4044
    2e48:	90 91 45 40 	lds	r25, 0x4045
    2e4c:	8f 58       	subi	r24, 0x8F	; 143
    2e4e:	93 4e       	sbci	r25, 0xE3	; 227
    2e50:	80 93 44 40 	sts	0x4044, r24
    2e54:	90 93 45 40 	sts	0x4045, r25
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    2e58:	1b 82       	std	Y+3, r1	; 0x03
    2e5a:	1c 82       	std	Y+4, r1	; 0x04
    2e5c:	6b c2       	rjmp	.+1238   	; 0x3334 <calcChecksumFRAM+0x5c0>
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    2e5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e60:	9c 81       	ldd	r25, Y+4	; 0x04
    2e62:	23 e0       	ldi	r18, 0x03	; 3
    2e64:	30 e0       	ldi	r19, 0x00	; 0
    2e66:	b9 01       	movw	r22, r18
    2e68:	0e 94 28 63 	call	0xc650	; 0xc650 <__udivmodhi4>
    2e6c:	9c 01       	movw	r18, r24
    2e6e:	27 5d       	subi	r18, 0xD7	; 215
    2e70:	3e 4d       	sbci	r19, 0xDE	; 222
    2e72:	f9 01       	movw	r30, r18
    2e74:	40 81       	ld	r20, Z
    2e76:	2b 81       	ldd	r18, Y+3	; 0x03
    2e78:	3c 81       	ldd	r19, Y+4	; 0x04
    2e7a:	24 53       	subi	r18, 0x34	; 52
    2e7c:	3c 4d       	sbci	r19, 0xDC	; 220
    2e7e:	f9 01       	movw	r30, r18
    2e80:	20 81       	ld	r18, Z
    2e82:	24 0f       	add	r18, r20
    2e84:	87 5d       	subi	r24, 0xD7	; 215
    2e86:	9e 4d       	sbci	r25, 0xDE	; 222
    2e88:	fc 01       	movw	r30, r24
    2e8a:	20 83       	st	Z, r18
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    2e8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e8e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e90:	23 e0       	ldi	r18, 0x03	; 3
    2e92:	30 e0       	ldi	r19, 0x00	; 0
    2e94:	b9 01       	movw	r22, r18
    2e96:	0e 94 28 63 	call	0xc650	; 0xc650 <__udivmodhi4>
    2e9a:	00 97       	sbiw	r24, 0x00	; 0
    2e9c:	09 f0       	breq	.+2      	; 0x2ea0 <calcChecksumFRAM+0x12c>
    2e9e:	44 c0       	rjmp	.+136    	; 0x2f28 <calcChecksumFRAM+0x1b4>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    2ea0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ea4:	84 53       	subi	r24, 0x34	; 52
    2ea6:	9c 4d       	sbci	r25, 0xDC	; 220
    2ea8:	fc 01       	movw	r30, r24
    2eaa:	80 81       	ld	r24, Z
    2eac:	88 23       	and	r24, r24
    2eae:	d4 f4       	brge	.+52     	; 0x2ee4 <calcChecksumFRAM+0x170>
    2eb0:	80 91 58 50 	lds	r24, 0x5058
    2eb4:	90 91 59 50 	lds	r25, 0x5059
    2eb8:	fc 01       	movw	r30, r24
    2eba:	10 82       	st	Z, r1
    2ebc:	fc 01       	movw	r30, r24
    2ebe:	11 82       	std	Z+1, r1	; 0x01
    2ec0:	fc 01       	movw	r30, r24
    2ec2:	12 82       	std	Z+2, r1	; 0x02
    2ec4:	2f ef       	ldi	r18, 0xFF	; 255
    2ec6:	fc 01       	movw	r30, r24
    2ec8:	23 83       	std	Z+3, r18	; 0x03
    2eca:	2f ef       	ldi	r18, 0xFF	; 255
    2ecc:	fc 01       	movw	r30, r24
    2ece:	24 83       	std	Z+4, r18	; 0x04
    2ed0:	2f ef       	ldi	r18, 0xFF	; 255
    2ed2:	fc 01       	movw	r30, r24
    2ed4:	25 83       	std	Z+5, r18	; 0x05
    2ed6:	2f ef       	ldi	r18, 0xFF	; 255
    2ed8:	fc 01       	movw	r30, r24
    2eda:	26 83       	std	Z+6, r18	; 0x06
    2edc:	2f ef       	ldi	r18, 0xFF	; 255
    2ede:	fc 01       	movw	r30, r24
    2ee0:	27 83       	std	Z+7, r18	; 0x07
    2ee2:	14 c0       	rjmp	.+40     	; 0x2f0c <calcChecksumFRAM+0x198>
				else *temp64 = 0x0000000000000000;
    2ee4:	80 91 58 50 	lds	r24, 0x5058
    2ee8:	90 91 59 50 	lds	r25, 0x5059
    2eec:	fc 01       	movw	r30, r24
    2eee:	10 82       	st	Z, r1
    2ef0:	fc 01       	movw	r30, r24
    2ef2:	11 82       	std	Z+1, r1	; 0x01
    2ef4:	fc 01       	movw	r30, r24
    2ef6:	12 82       	std	Z+2, r1	; 0x02
    2ef8:	fc 01       	movw	r30, r24
    2efa:	13 82       	std	Z+3, r1	; 0x03
    2efc:	fc 01       	movw	r30, r24
    2efe:	14 82       	std	Z+4, r1	; 0x04
    2f00:	fc 01       	movw	r30, r24
    2f02:	15 82       	std	Z+5, r1	; 0x05
    2f04:	fc 01       	movw	r30, r24
    2f06:	16 82       	std	Z+6, r1	; 0x06
    2f08:	fc 01       	movw	r30, r24
    2f0a:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    2f0c:	80 91 58 50 	lds	r24, 0x5058
    2f10:	90 91 59 50 	lds	r25, 0x5059
    2f14:	02 96       	adiw	r24, 0x02	; 2
    2f16:	2b 81       	ldd	r18, Y+3	; 0x03
    2f18:	3c 81       	ldd	r19, Y+4	; 0x04
    2f1a:	24 53       	subi	r18, 0x34	; 52
    2f1c:	3c 4d       	sbci	r19, 0xDC	; 220
    2f1e:	f9 01       	movw	r30, r18
    2f20:	20 81       	ld	r18, Z
    2f22:	fc 01       	movw	r30, r24
    2f24:	20 83       	st	Z, r18
    2f26:	24 c0       	rjmp	.+72     	; 0x2f70 <calcChecksumFRAM+0x1fc>
			} else if(k%3 == 1) {
    2f28:	8b 81       	ldd	r24, Y+3	; 0x03
    2f2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f2c:	23 e0       	ldi	r18, 0x03	; 3
    2f2e:	30 e0       	ldi	r19, 0x00	; 0
    2f30:	b9 01       	movw	r22, r18
    2f32:	0e 94 28 63 	call	0xc650	; 0xc650 <__udivmodhi4>
    2f36:	81 30       	cpi	r24, 0x01	; 1
    2f38:	91 05       	cpc	r25, r1
    2f3a:	71 f4       	brne	.+28     	; 0x2f58 <calcChecksumFRAM+0x1e4>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    2f3c:	80 91 58 50 	lds	r24, 0x5058
    2f40:	90 91 59 50 	lds	r25, 0x5059
    2f44:	01 96       	adiw	r24, 0x01	; 1
    2f46:	2b 81       	ldd	r18, Y+3	; 0x03
    2f48:	3c 81       	ldd	r19, Y+4	; 0x04
    2f4a:	24 53       	subi	r18, 0x34	; 52
    2f4c:	3c 4d       	sbci	r19, 0xDC	; 220
    2f4e:	f9 01       	movw	r30, r18
    2f50:	20 81       	ld	r18, Z
    2f52:	fc 01       	movw	r30, r24
    2f54:	20 83       	st	Z, r18
    2f56:	0c c0       	rjmp	.+24     	; 0x2f70 <calcChecksumFRAM+0x1fc>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    2f58:	80 91 58 50 	lds	r24, 0x5058
    2f5c:	90 91 59 50 	lds	r25, 0x5059
    2f60:	2b 81       	ldd	r18, Y+3	; 0x03
    2f62:	3c 81       	ldd	r19, Y+4	; 0x04
    2f64:	24 53       	subi	r18, 0x34	; 52
    2f66:	3c 4d       	sbci	r19, 0xDC	; 220
    2f68:	f9 01       	movw	r30, r18
    2f6a:	20 81       	ld	r18, Z
    2f6c:	fc 01       	movw	r30, r24
    2f6e:	20 83       	st	Z, r18
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    2f70:	8b 81       	ldd	r24, Y+3	; 0x03
    2f72:	9c 81       	ldd	r25, Y+4	; 0x04
    2f74:	29 e0       	ldi	r18, 0x09	; 9
    2f76:	30 e0       	ldi	r19, 0x00	; 0
    2f78:	b9 01       	movw	r22, r18
    2f7a:	0e 94 28 63 	call	0xc650	; 0xc650 <__udivmodhi4>
    2f7e:	82 30       	cpi	r24, 0x02	; 2
    2f80:	91 05       	cpc	r25, r1
    2f82:	09 f0       	breq	.+2      	; 0x2f86 <calcChecksumFRAM+0x212>
    2f84:	94 c0       	rjmp	.+296    	; 0x30ae <calcChecksumFRAM+0x33a>
    2f86:	a0 90 80 50 	lds	r10, 0x5080
    2f8a:	b0 90 81 50 	lds	r11, 0x5081
    2f8e:	c0 90 82 50 	lds	r12, 0x5082
    2f92:	d0 90 83 50 	lds	r13, 0x5083
    2f96:	e0 90 84 50 	lds	r14, 0x5084
    2f9a:	f0 90 85 50 	lds	r15, 0x5085
    2f9e:	00 91 86 50 	lds	r16, 0x5086
    2fa2:	10 91 87 50 	lds	r17, 0x5087
    2fa6:	80 91 58 50 	lds	r24, 0x5058
    2faa:	90 91 59 50 	lds	r25, 0x5059
    2fae:	fc 01       	movw	r30, r24
    2fb0:	20 80       	ld	r2, Z
    2fb2:	fc 01       	movw	r30, r24
    2fb4:	31 80       	ldd	r3, Z+1	; 0x01
    2fb6:	fc 01       	movw	r30, r24
    2fb8:	42 80       	ldd	r4, Z+2	; 0x02
    2fba:	fc 01       	movw	r30, r24
    2fbc:	53 80       	ldd	r5, Z+3	; 0x03
    2fbe:	fc 01       	movw	r30, r24
    2fc0:	64 80       	ldd	r6, Z+4	; 0x04
    2fc2:	fc 01       	movw	r30, r24
    2fc4:	75 80       	ldd	r7, Z+5	; 0x05
    2fc6:	fc 01       	movw	r30, r24
    2fc8:	86 80       	ldd	r8, Z+6	; 0x06
    2fca:	fc 01       	movw	r30, r24
    2fcc:	97 80       	ldd	r9, Z+7	; 0x07
    2fce:	2a 2d       	mov	r18, r10
    2fd0:	22 0d       	add	r18, r2
    2fd2:	e1 e0       	ldi	r30, 0x01	; 1
    2fd4:	2a 15       	cp	r18, r10
    2fd6:	08 f0       	brcs	.+2      	; 0x2fda <calcChecksumFRAM+0x266>
    2fd8:	e0 e0       	ldi	r30, 0x00	; 0
    2fda:	3b 2d       	mov	r19, r11
    2fdc:	33 0d       	add	r19, r3
    2fde:	f1 e0       	ldi	r31, 0x01	; 1
    2fe0:	3b 15       	cp	r19, r11
    2fe2:	08 f0       	brcs	.+2      	; 0x2fe6 <calcChecksumFRAM+0x272>
    2fe4:	f0 e0       	ldi	r31, 0x00	; 0
    2fe6:	e3 0f       	add	r30, r19
    2fe8:	a1 e0       	ldi	r26, 0x01	; 1
    2fea:	e3 17       	cp	r30, r19
    2fec:	08 f0       	brcs	.+2      	; 0x2ff0 <calcChecksumFRAM+0x27c>
    2fee:	a0 e0       	ldi	r26, 0x00	; 0
    2ff0:	fa 2b       	or	r31, r26
    2ff2:	3e 2f       	mov	r19, r30
    2ff4:	4c 2d       	mov	r20, r12
    2ff6:	44 0d       	add	r20, r4
    2ff8:	e1 e0       	ldi	r30, 0x01	; 1
    2ffa:	4c 15       	cp	r20, r12
    2ffc:	08 f0       	brcs	.+2      	; 0x3000 <calcChecksumFRAM+0x28c>
    2ffe:	e0 e0       	ldi	r30, 0x00	; 0
    3000:	f4 0f       	add	r31, r20
    3002:	a1 e0       	ldi	r26, 0x01	; 1
    3004:	f4 17       	cp	r31, r20
    3006:	08 f0       	brcs	.+2      	; 0x300a <calcChecksumFRAM+0x296>
    3008:	a0 e0       	ldi	r26, 0x00	; 0
    300a:	ea 2b       	or	r30, r26
    300c:	4f 2f       	mov	r20, r31
    300e:	5d 2d       	mov	r21, r13
    3010:	55 0d       	add	r21, r5
    3012:	f1 e0       	ldi	r31, 0x01	; 1
    3014:	5d 15       	cp	r21, r13
    3016:	08 f0       	brcs	.+2      	; 0x301a <calcChecksumFRAM+0x2a6>
    3018:	f0 e0       	ldi	r31, 0x00	; 0
    301a:	e5 0f       	add	r30, r21
    301c:	a1 e0       	ldi	r26, 0x01	; 1
    301e:	e5 17       	cp	r30, r21
    3020:	08 f0       	brcs	.+2      	; 0x3024 <calcChecksumFRAM+0x2b0>
    3022:	a0 e0       	ldi	r26, 0x00	; 0
    3024:	fa 2b       	or	r31, r26
    3026:	5e 2f       	mov	r21, r30
    3028:	6e 2d       	mov	r22, r14
    302a:	66 0d       	add	r22, r6
    302c:	e1 e0       	ldi	r30, 0x01	; 1
    302e:	6e 15       	cp	r22, r14
    3030:	08 f0       	brcs	.+2      	; 0x3034 <calcChecksumFRAM+0x2c0>
    3032:	e0 e0       	ldi	r30, 0x00	; 0
    3034:	f6 0f       	add	r31, r22
    3036:	a1 e0       	ldi	r26, 0x01	; 1
    3038:	f6 17       	cp	r31, r22
    303a:	08 f0       	brcs	.+2      	; 0x303e <calcChecksumFRAM+0x2ca>
    303c:	a0 e0       	ldi	r26, 0x00	; 0
    303e:	ea 2b       	or	r30, r26
    3040:	6f 2f       	mov	r22, r31
    3042:	7f 2d       	mov	r23, r15
    3044:	77 0d       	add	r23, r7
    3046:	f1 e0       	ldi	r31, 0x01	; 1
    3048:	7f 15       	cp	r23, r15
    304a:	08 f0       	brcs	.+2      	; 0x304e <calcChecksumFRAM+0x2da>
    304c:	f0 e0       	ldi	r31, 0x00	; 0
    304e:	e7 0f       	add	r30, r23
    3050:	a1 e0       	ldi	r26, 0x01	; 1
    3052:	e7 17       	cp	r30, r23
    3054:	08 f0       	brcs	.+2      	; 0x3058 <calcChecksumFRAM+0x2e4>
    3056:	a0 e0       	ldi	r26, 0x00	; 0
    3058:	fa 2b       	or	r31, r26
    305a:	7e 2f       	mov	r23, r30
    305c:	80 2f       	mov	r24, r16
    305e:	88 0d       	add	r24, r8
    3060:	e1 e0       	ldi	r30, 0x01	; 1
    3062:	80 17       	cp	r24, r16
    3064:	08 f0       	brcs	.+2      	; 0x3068 <calcChecksumFRAM+0x2f4>
    3066:	e0 e0       	ldi	r30, 0x00	; 0
    3068:	f8 0f       	add	r31, r24
    306a:	a1 e0       	ldi	r26, 0x01	; 1
    306c:	f8 17       	cp	r31, r24
    306e:	08 f0       	brcs	.+2      	; 0x3072 <calcChecksumFRAM+0x2fe>
    3070:	a0 e0       	ldi	r26, 0x00	; 0
    3072:	ea 2b       	or	r30, r26
    3074:	8f 2f       	mov	r24, r31
    3076:	91 2f       	mov	r25, r17
    3078:	99 0d       	add	r25, r9
    307a:	e9 0f       	add	r30, r25
    307c:	9e 2f       	mov	r25, r30
    307e:	a2 2e       	mov	r10, r18
    3080:	b3 2e       	mov	r11, r19
    3082:	c4 2e       	mov	r12, r20
    3084:	d5 2e       	mov	r13, r21
    3086:	e6 2e       	mov	r14, r22
    3088:	f7 2e       	mov	r15, r23
    308a:	08 2f       	mov	r16, r24
    308c:	19 2f       	mov	r17, r25
    308e:	a0 92 80 50 	sts	0x5080, r10
    3092:	b0 92 81 50 	sts	0x5081, r11
    3096:	c0 92 82 50 	sts	0x5082, r12
    309a:	d0 92 83 50 	sts	0x5083, r13
    309e:	e0 92 84 50 	sts	0x5084, r14
    30a2:	f0 92 85 50 	sts	0x5085, r15
    30a6:	00 93 86 50 	sts	0x5086, r16
    30aa:	10 93 87 50 	sts	0x5087, r17
			if(k%9 == 5) sumFRAM[1] += *temp64;
    30ae:	8b 81       	ldd	r24, Y+3	; 0x03
    30b0:	9c 81       	ldd	r25, Y+4	; 0x04
    30b2:	29 e0       	ldi	r18, 0x09	; 9
    30b4:	30 e0       	ldi	r19, 0x00	; 0
    30b6:	b9 01       	movw	r22, r18
    30b8:	0e 94 28 63 	call	0xc650	; 0xc650 <__udivmodhi4>
    30bc:	85 30       	cpi	r24, 0x05	; 5
    30be:	91 05       	cpc	r25, r1
    30c0:	09 f0       	breq	.+2      	; 0x30c4 <calcChecksumFRAM+0x350>
    30c2:	94 c0       	rjmp	.+296    	; 0x31ec <calcChecksumFRAM+0x478>
    30c4:	a0 90 88 50 	lds	r10, 0x5088
    30c8:	b0 90 89 50 	lds	r11, 0x5089
    30cc:	c0 90 8a 50 	lds	r12, 0x508A
    30d0:	d0 90 8b 50 	lds	r13, 0x508B
    30d4:	e0 90 8c 50 	lds	r14, 0x508C
    30d8:	f0 90 8d 50 	lds	r15, 0x508D
    30dc:	00 91 8e 50 	lds	r16, 0x508E
    30e0:	10 91 8f 50 	lds	r17, 0x508F
    30e4:	80 91 58 50 	lds	r24, 0x5058
    30e8:	90 91 59 50 	lds	r25, 0x5059
    30ec:	fc 01       	movw	r30, r24
    30ee:	20 80       	ld	r2, Z
    30f0:	fc 01       	movw	r30, r24
    30f2:	31 80       	ldd	r3, Z+1	; 0x01
    30f4:	fc 01       	movw	r30, r24
    30f6:	42 80       	ldd	r4, Z+2	; 0x02
    30f8:	fc 01       	movw	r30, r24
    30fa:	53 80       	ldd	r5, Z+3	; 0x03
    30fc:	fc 01       	movw	r30, r24
    30fe:	64 80       	ldd	r6, Z+4	; 0x04
    3100:	fc 01       	movw	r30, r24
    3102:	75 80       	ldd	r7, Z+5	; 0x05
    3104:	fc 01       	movw	r30, r24
    3106:	86 80       	ldd	r8, Z+6	; 0x06
    3108:	fc 01       	movw	r30, r24
    310a:	97 80       	ldd	r9, Z+7	; 0x07
    310c:	2a 2d       	mov	r18, r10
    310e:	22 0d       	add	r18, r2
    3110:	e1 e0       	ldi	r30, 0x01	; 1
    3112:	2a 15       	cp	r18, r10
    3114:	08 f0       	brcs	.+2      	; 0x3118 <calcChecksumFRAM+0x3a4>
    3116:	e0 e0       	ldi	r30, 0x00	; 0
    3118:	3b 2d       	mov	r19, r11
    311a:	33 0d       	add	r19, r3
    311c:	f1 e0       	ldi	r31, 0x01	; 1
    311e:	3b 15       	cp	r19, r11
    3120:	08 f0       	brcs	.+2      	; 0x3124 <calcChecksumFRAM+0x3b0>
    3122:	f0 e0       	ldi	r31, 0x00	; 0
    3124:	e3 0f       	add	r30, r19
    3126:	a1 e0       	ldi	r26, 0x01	; 1
    3128:	e3 17       	cp	r30, r19
    312a:	08 f0       	brcs	.+2      	; 0x312e <calcChecksumFRAM+0x3ba>
    312c:	a0 e0       	ldi	r26, 0x00	; 0
    312e:	fa 2b       	or	r31, r26
    3130:	3e 2f       	mov	r19, r30
    3132:	4c 2d       	mov	r20, r12
    3134:	44 0d       	add	r20, r4
    3136:	e1 e0       	ldi	r30, 0x01	; 1
    3138:	4c 15       	cp	r20, r12
    313a:	08 f0       	brcs	.+2      	; 0x313e <calcChecksumFRAM+0x3ca>
    313c:	e0 e0       	ldi	r30, 0x00	; 0
    313e:	f4 0f       	add	r31, r20
    3140:	a1 e0       	ldi	r26, 0x01	; 1
    3142:	f4 17       	cp	r31, r20
    3144:	08 f0       	brcs	.+2      	; 0x3148 <calcChecksumFRAM+0x3d4>
    3146:	a0 e0       	ldi	r26, 0x00	; 0
    3148:	ea 2b       	or	r30, r26
    314a:	4f 2f       	mov	r20, r31
    314c:	5d 2d       	mov	r21, r13
    314e:	55 0d       	add	r21, r5
    3150:	f1 e0       	ldi	r31, 0x01	; 1
    3152:	5d 15       	cp	r21, r13
    3154:	08 f0       	brcs	.+2      	; 0x3158 <calcChecksumFRAM+0x3e4>
    3156:	f0 e0       	ldi	r31, 0x00	; 0
    3158:	e5 0f       	add	r30, r21
    315a:	a1 e0       	ldi	r26, 0x01	; 1
    315c:	e5 17       	cp	r30, r21
    315e:	08 f0       	brcs	.+2      	; 0x3162 <calcChecksumFRAM+0x3ee>
    3160:	a0 e0       	ldi	r26, 0x00	; 0
    3162:	fa 2b       	or	r31, r26
    3164:	5e 2f       	mov	r21, r30
    3166:	6e 2d       	mov	r22, r14
    3168:	66 0d       	add	r22, r6
    316a:	e1 e0       	ldi	r30, 0x01	; 1
    316c:	6e 15       	cp	r22, r14
    316e:	08 f0       	brcs	.+2      	; 0x3172 <calcChecksumFRAM+0x3fe>
    3170:	e0 e0       	ldi	r30, 0x00	; 0
    3172:	f6 0f       	add	r31, r22
    3174:	a1 e0       	ldi	r26, 0x01	; 1
    3176:	f6 17       	cp	r31, r22
    3178:	08 f0       	brcs	.+2      	; 0x317c <calcChecksumFRAM+0x408>
    317a:	a0 e0       	ldi	r26, 0x00	; 0
    317c:	ea 2b       	or	r30, r26
    317e:	6f 2f       	mov	r22, r31
    3180:	7f 2d       	mov	r23, r15
    3182:	77 0d       	add	r23, r7
    3184:	f1 e0       	ldi	r31, 0x01	; 1
    3186:	7f 15       	cp	r23, r15
    3188:	08 f0       	brcs	.+2      	; 0x318c <calcChecksumFRAM+0x418>
    318a:	f0 e0       	ldi	r31, 0x00	; 0
    318c:	e7 0f       	add	r30, r23
    318e:	a1 e0       	ldi	r26, 0x01	; 1
    3190:	e7 17       	cp	r30, r23
    3192:	08 f0       	brcs	.+2      	; 0x3196 <calcChecksumFRAM+0x422>
    3194:	a0 e0       	ldi	r26, 0x00	; 0
    3196:	fa 2b       	or	r31, r26
    3198:	7e 2f       	mov	r23, r30
    319a:	80 2f       	mov	r24, r16
    319c:	88 0d       	add	r24, r8
    319e:	e1 e0       	ldi	r30, 0x01	; 1
    31a0:	80 17       	cp	r24, r16
    31a2:	08 f0       	brcs	.+2      	; 0x31a6 <calcChecksumFRAM+0x432>
    31a4:	e0 e0       	ldi	r30, 0x00	; 0
    31a6:	f8 0f       	add	r31, r24
    31a8:	a1 e0       	ldi	r26, 0x01	; 1
    31aa:	f8 17       	cp	r31, r24
    31ac:	08 f0       	brcs	.+2      	; 0x31b0 <calcChecksumFRAM+0x43c>
    31ae:	a0 e0       	ldi	r26, 0x00	; 0
    31b0:	ea 2b       	or	r30, r26
    31b2:	8f 2f       	mov	r24, r31
    31b4:	91 2f       	mov	r25, r17
    31b6:	99 0d       	add	r25, r9
    31b8:	e9 0f       	add	r30, r25
    31ba:	9e 2f       	mov	r25, r30
    31bc:	a2 2e       	mov	r10, r18
    31be:	b3 2e       	mov	r11, r19
    31c0:	c4 2e       	mov	r12, r20
    31c2:	d5 2e       	mov	r13, r21
    31c4:	e6 2e       	mov	r14, r22
    31c6:	f7 2e       	mov	r15, r23
    31c8:	08 2f       	mov	r16, r24
    31ca:	19 2f       	mov	r17, r25
    31cc:	a0 92 88 50 	sts	0x5088, r10
    31d0:	b0 92 89 50 	sts	0x5089, r11
    31d4:	c0 92 8a 50 	sts	0x508A, r12
    31d8:	d0 92 8b 50 	sts	0x508B, r13
    31dc:	e0 92 8c 50 	sts	0x508C, r14
    31e0:	f0 92 8d 50 	sts	0x508D, r15
    31e4:	00 93 8e 50 	sts	0x508E, r16
    31e8:	10 93 8f 50 	sts	0x508F, r17
			if(k%9 == 8) sumFRAM[2] += *temp64;
    31ec:	8b 81       	ldd	r24, Y+3	; 0x03
    31ee:	9c 81       	ldd	r25, Y+4	; 0x04
    31f0:	29 e0       	ldi	r18, 0x09	; 9
    31f2:	30 e0       	ldi	r19, 0x00	; 0
    31f4:	b9 01       	movw	r22, r18
    31f6:	0e 94 28 63 	call	0xc650	; 0xc650 <__udivmodhi4>
    31fa:	88 30       	cpi	r24, 0x08	; 8
    31fc:	91 05       	cpc	r25, r1
    31fe:	09 f0       	breq	.+2      	; 0x3202 <calcChecksumFRAM+0x48e>
    3200:	94 c0       	rjmp	.+296    	; 0x332a <calcChecksumFRAM+0x5b6>
    3202:	a0 90 90 50 	lds	r10, 0x5090
    3206:	b0 90 91 50 	lds	r11, 0x5091
    320a:	c0 90 92 50 	lds	r12, 0x5092
    320e:	d0 90 93 50 	lds	r13, 0x5093
    3212:	e0 90 94 50 	lds	r14, 0x5094
    3216:	f0 90 95 50 	lds	r15, 0x5095
    321a:	00 91 96 50 	lds	r16, 0x5096
    321e:	10 91 97 50 	lds	r17, 0x5097
    3222:	80 91 58 50 	lds	r24, 0x5058
    3226:	90 91 59 50 	lds	r25, 0x5059
    322a:	fc 01       	movw	r30, r24
    322c:	20 80       	ld	r2, Z
    322e:	fc 01       	movw	r30, r24
    3230:	31 80       	ldd	r3, Z+1	; 0x01
    3232:	fc 01       	movw	r30, r24
    3234:	42 80       	ldd	r4, Z+2	; 0x02
    3236:	fc 01       	movw	r30, r24
    3238:	53 80       	ldd	r5, Z+3	; 0x03
    323a:	fc 01       	movw	r30, r24
    323c:	64 80       	ldd	r6, Z+4	; 0x04
    323e:	fc 01       	movw	r30, r24
    3240:	75 80       	ldd	r7, Z+5	; 0x05
    3242:	fc 01       	movw	r30, r24
    3244:	86 80       	ldd	r8, Z+6	; 0x06
    3246:	fc 01       	movw	r30, r24
    3248:	97 80       	ldd	r9, Z+7	; 0x07
    324a:	2a 2d       	mov	r18, r10
    324c:	22 0d       	add	r18, r2
    324e:	e1 e0       	ldi	r30, 0x01	; 1
    3250:	2a 15       	cp	r18, r10
    3252:	08 f0       	brcs	.+2      	; 0x3256 <calcChecksumFRAM+0x4e2>
    3254:	e0 e0       	ldi	r30, 0x00	; 0
    3256:	3b 2d       	mov	r19, r11
    3258:	33 0d       	add	r19, r3
    325a:	f1 e0       	ldi	r31, 0x01	; 1
    325c:	3b 15       	cp	r19, r11
    325e:	08 f0       	brcs	.+2      	; 0x3262 <calcChecksumFRAM+0x4ee>
    3260:	f0 e0       	ldi	r31, 0x00	; 0
    3262:	e3 0f       	add	r30, r19
    3264:	a1 e0       	ldi	r26, 0x01	; 1
    3266:	e3 17       	cp	r30, r19
    3268:	08 f0       	brcs	.+2      	; 0x326c <calcChecksumFRAM+0x4f8>
    326a:	a0 e0       	ldi	r26, 0x00	; 0
    326c:	fa 2b       	or	r31, r26
    326e:	3e 2f       	mov	r19, r30
    3270:	4c 2d       	mov	r20, r12
    3272:	44 0d       	add	r20, r4
    3274:	e1 e0       	ldi	r30, 0x01	; 1
    3276:	4c 15       	cp	r20, r12
    3278:	08 f0       	brcs	.+2      	; 0x327c <calcChecksumFRAM+0x508>
    327a:	e0 e0       	ldi	r30, 0x00	; 0
    327c:	f4 0f       	add	r31, r20
    327e:	a1 e0       	ldi	r26, 0x01	; 1
    3280:	f4 17       	cp	r31, r20
    3282:	08 f0       	brcs	.+2      	; 0x3286 <calcChecksumFRAM+0x512>
    3284:	a0 e0       	ldi	r26, 0x00	; 0
    3286:	ea 2b       	or	r30, r26
    3288:	4f 2f       	mov	r20, r31
    328a:	5d 2d       	mov	r21, r13
    328c:	55 0d       	add	r21, r5
    328e:	f1 e0       	ldi	r31, 0x01	; 1
    3290:	5d 15       	cp	r21, r13
    3292:	08 f0       	brcs	.+2      	; 0x3296 <calcChecksumFRAM+0x522>
    3294:	f0 e0       	ldi	r31, 0x00	; 0
    3296:	e5 0f       	add	r30, r21
    3298:	a1 e0       	ldi	r26, 0x01	; 1
    329a:	e5 17       	cp	r30, r21
    329c:	08 f0       	brcs	.+2      	; 0x32a0 <calcChecksumFRAM+0x52c>
    329e:	a0 e0       	ldi	r26, 0x00	; 0
    32a0:	fa 2b       	or	r31, r26
    32a2:	5e 2f       	mov	r21, r30
    32a4:	6e 2d       	mov	r22, r14
    32a6:	66 0d       	add	r22, r6
    32a8:	e1 e0       	ldi	r30, 0x01	; 1
    32aa:	6e 15       	cp	r22, r14
    32ac:	08 f0       	brcs	.+2      	; 0x32b0 <calcChecksumFRAM+0x53c>
    32ae:	e0 e0       	ldi	r30, 0x00	; 0
    32b0:	f6 0f       	add	r31, r22
    32b2:	a1 e0       	ldi	r26, 0x01	; 1
    32b4:	f6 17       	cp	r31, r22
    32b6:	08 f0       	brcs	.+2      	; 0x32ba <calcChecksumFRAM+0x546>
    32b8:	a0 e0       	ldi	r26, 0x00	; 0
    32ba:	ea 2b       	or	r30, r26
    32bc:	6f 2f       	mov	r22, r31
    32be:	7f 2d       	mov	r23, r15
    32c0:	77 0d       	add	r23, r7
    32c2:	f1 e0       	ldi	r31, 0x01	; 1
    32c4:	7f 15       	cp	r23, r15
    32c6:	08 f0       	brcs	.+2      	; 0x32ca <calcChecksumFRAM+0x556>
    32c8:	f0 e0       	ldi	r31, 0x00	; 0
    32ca:	e7 0f       	add	r30, r23
    32cc:	a1 e0       	ldi	r26, 0x01	; 1
    32ce:	e7 17       	cp	r30, r23
    32d0:	08 f0       	brcs	.+2      	; 0x32d4 <calcChecksumFRAM+0x560>
    32d2:	a0 e0       	ldi	r26, 0x00	; 0
    32d4:	fa 2b       	or	r31, r26
    32d6:	7e 2f       	mov	r23, r30
    32d8:	80 2f       	mov	r24, r16
    32da:	88 0d       	add	r24, r8
    32dc:	e1 e0       	ldi	r30, 0x01	; 1
    32de:	80 17       	cp	r24, r16
    32e0:	08 f0       	brcs	.+2      	; 0x32e4 <calcChecksumFRAM+0x570>
    32e2:	e0 e0       	ldi	r30, 0x00	; 0
    32e4:	f8 0f       	add	r31, r24
    32e6:	a1 e0       	ldi	r26, 0x01	; 1
    32e8:	f8 17       	cp	r31, r24
    32ea:	08 f0       	brcs	.+2      	; 0x32ee <calcChecksumFRAM+0x57a>
    32ec:	a0 e0       	ldi	r26, 0x00	; 0
    32ee:	ea 2b       	or	r30, r26
    32f0:	8f 2f       	mov	r24, r31
    32f2:	91 2f       	mov	r25, r17
    32f4:	99 0d       	add	r25, r9
    32f6:	e9 0f       	add	r30, r25
    32f8:	9e 2f       	mov	r25, r30
    32fa:	a2 2e       	mov	r10, r18
    32fc:	b3 2e       	mov	r11, r19
    32fe:	c4 2e       	mov	r12, r20
    3300:	d5 2e       	mov	r13, r21
    3302:	e6 2e       	mov	r14, r22
    3304:	f7 2e       	mov	r15, r23
    3306:	08 2f       	mov	r16, r24
    3308:	19 2f       	mov	r17, r25
    330a:	a0 92 90 50 	sts	0x5090, r10
    330e:	b0 92 91 50 	sts	0x5091, r11
    3312:	c0 92 92 50 	sts	0x5092, r12
    3316:	d0 92 93 50 	sts	0x5093, r13
    331a:	e0 92 94 50 	sts	0x5094, r14
    331e:	f0 92 95 50 	sts	0x5095, r15
    3322:	00 93 96 50 	sts	0x5096, r16
    3326:	10 93 97 50 	sts	0x5097, r17
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    332a:	8b 81       	ldd	r24, Y+3	; 0x03
    332c:	9c 81       	ldd	r25, Y+4	; 0x04
    332e:	01 96       	adiw	r24, 0x01	; 1
    3330:	8b 83       	std	Y+3, r24	; 0x03
    3332:	9c 83       	std	Y+4, r25	; 0x04
    3334:	8b 81       	ldd	r24, Y+3	; 0x03
    3336:	9c 81       	ldd	r25, Y+4	; 0x04
    3338:	fc e1       	ldi	r31, 0x1C	; 28
    333a:	81 37       	cpi	r24, 0x71	; 113
    333c:	9f 07       	cpc	r25, r31
    333e:	08 f4       	brcc	.+2      	; 0x3342 <calcChecksumFRAM+0x5ce>
    3340:	8e cd       	rjmp	.-1252   	; 0x2e5e <calcChecksumFRAM+0xea>

void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    3342:	89 81       	ldd	r24, Y+1	; 0x01
    3344:	9a 81       	ldd	r25, Y+2	; 0x02
    3346:	01 96       	adiw	r24, 0x01	; 1
    3348:	89 83       	std	Y+1, r24	; 0x01
    334a:	9a 83       	std	Y+2, r25	; 0x02
    334c:	89 81       	ldd	r24, Y+1	; 0x01
    334e:	9a 81       	ldd	r25, Y+2	; 0x02
    3350:	89 30       	cpi	r24, 0x09	; 9
    3352:	91 05       	cpc	r25, r1
    3354:	08 f4       	brcc	.+2      	; 0x3358 <calcChecksumFRAM+0x5e4>
    3356:	72 cd       	rjmp	.-1308   	; 0x2e3c <calcChecksumFRAM+0xc8>
			
		}
		
	}
	
}
    3358:	24 96       	adiw	r28, 0x04	; 4
    335a:	cd bf       	out	0x3d, r28	; 61
    335c:	de bf       	out	0x3e, r29	; 62
    335e:	df 91       	pop	r29
    3360:	cf 91       	pop	r28
    3362:	1f 91       	pop	r17
    3364:	0f 91       	pop	r16
    3366:	ff 90       	pop	r15
    3368:	ef 90       	pop	r14
    336a:	df 90       	pop	r13
    336c:	cf 90       	pop	r12
    336e:	bf 90       	pop	r11
    3370:	af 90       	pop	r10
    3372:	9f 90       	pop	r9
    3374:	8f 90       	pop	r8
    3376:	7f 90       	pop	r7
    3378:	6f 90       	pop	r6
    337a:	5f 90       	pop	r5
    337c:	4f 90       	pop	r4
    337e:	3f 90       	pop	r3
    3380:	2f 90       	pop	r2
    3382:	08 95       	ret

00003384 <FRAMWriteKnowns>:


void FRAMWriteKnowns() {
    3384:	cf 93       	push	r28
    3386:	df 93       	push	r29
    3388:	cd b7       	in	r28, 0x3d	; 61
    338a:	de b7       	in	r29, 0x3e	; 62
	FRAMAddress = FR_BASEADD;
    338c:	10 92 44 40 	sts	0x4044, r1
    3390:	10 92 45 40 	sts	0x4045, r1
	sampleCount = 0;
    3394:	10 92 69 50 	sts	0x5069, r1
    3398:	10 92 6a 50 	sts	0x506A, r1
    339c:	10 92 6b 50 	sts	0x506B, r1
    33a0:	10 92 6c 50 	sts	0x506C, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    33a4:	80 e0       	ldi	r24, 0x00	; 0
    33a6:	80 93 28 21 	sts	0x2128, r24
    33aa:	80 93 27 21 	sts	0x2127, r24
    33ae:	80 93 26 21 	sts	0x2126, r24
	
	ADCPower(TRUE);
    33b2:	81 e0       	ldi	r24, 0x01	; 1
    33b4:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    33b8:	84 e0       	ldi	r24, 0x04	; 4
    33ba:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    33be:	80 ec       	ldi	r24, 0xC0	; 192
    33c0:	98 e0       	ldi	r25, 0x08	; 8
    33c2:	20 ed       	ldi	r18, 0xD0	; 208
    33c4:	fc 01       	movw	r30, r24
    33c6:	20 83       	st	Z, r18
	SPIBuffer[0] = 0x0D;
    33c8:	8d e0       	ldi	r24, 0x0D	; 13
    33ca:	80 93 5a 50 	sts	0x505A, r24
	SPIBuffer[1] = 0xF3;
    33ce:	83 ef       	ldi	r24, 0xF3	; 243
    33d0:	80 93 5b 50 	sts	0x505B, r24
	SPIBuffer[2] = 0x57;
    33d4:	87 e5       	ldi	r24, 0x57	; 87
    33d6:	80 93 5c 50 	sts	0x505C, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    33da:	d7 c0       	rjmp	.+430    	; 0x358a <FRAMWriteKnowns+0x206>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    33dc:	80 e4       	ldi	r24, 0x40	; 64
    33de:	96 e0       	ldi	r25, 0x06	; 6
    33e0:	20 e1       	ldi	r18, 0x10	; 16
    33e2:	fc 01       	movw	r30, r24
    33e4:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    33e6:	80 e2       	ldi	r24, 0x20	; 32
    33e8:	96 e0       	ldi	r25, 0x06	; 6
    33ea:	28 e0       	ldi	r18, 0x08	; 8
    33ec:	fc 01       	movw	r30, r24
    33ee:	26 83       	std	Z+6, r18	; 0x06
		nop();
    33f0:	00 00       	nop
		SPIC.DATA = FR_WREN;
    33f2:	80 ec       	ldi	r24, 0xC0	; 192
    33f4:	98 e0       	ldi	r25, 0x08	; 8
    33f6:	26 e0       	ldi	r18, 0x06	; 6
    33f8:	fc 01       	movw	r30, r24
    33fa:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    33fc:	00 00       	nop
    33fe:	80 ec       	ldi	r24, 0xC0	; 192
    3400:	98 e0       	ldi	r25, 0x08	; 8
    3402:	fc 01       	movw	r30, r24
    3404:	82 81       	ldd	r24, Z+2	; 0x02
    3406:	88 23       	and	r24, r24
    3408:	d4 f7       	brge	.-12     	; 0x33fe <FRAMWriteKnowns+0x7a>
		SPIBuffer[12] = SPIC.DATA;
    340a:	80 ec       	ldi	r24, 0xC0	; 192
    340c:	98 e0       	ldi	r25, 0x08	; 8
    340e:	fc 01       	movw	r30, r24
    3410:	83 81       	ldd	r24, Z+3	; 0x03
    3412:	80 93 66 50 	sts	0x5066, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    3416:	80 e2       	ldi	r24, 0x20	; 32
    3418:	96 e0       	ldi	r25, 0x06	; 6
    341a:	28 e0       	ldi	r18, 0x08	; 8
    341c:	fc 01       	movw	r30, r24
    341e:	25 83       	std	Z+5, r18	; 0x05
		nop(); // time for CS_FRAM to accept high signal
    3420:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3422:	80 e2       	ldi	r24, 0x20	; 32
    3424:	96 e0       	ldi	r25, 0x06	; 6
    3426:	28 e0       	ldi	r18, 0x08	; 8
    3428:	fc 01       	movw	r30, r24
    342a:	26 83       	std	Z+6, r18	; 0x06
		nop();
    342c:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    342e:	80 ec       	ldi	r24, 0xC0	; 192
    3430:	98 e0       	ldi	r25, 0x08	; 8
    3432:	22 e0       	ldi	r18, 0x02	; 2
    3434:	fc 01       	movw	r30, r24
    3436:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3438:	00 00       	nop
    343a:	80 ec       	ldi	r24, 0xC0	; 192
    343c:	98 e0       	ldi	r25, 0x08	; 8
    343e:	fc 01       	movw	r30, r24
    3440:	82 81       	ldd	r24, Z+2	; 0x02
    3442:	88 23       	and	r24, r24
    3444:	d4 f7       	brge	.-12     	; 0x343a <FRAMWriteKnowns+0xb6>
		SPIBuffer[12] = SPIC.DATA;
    3446:	80 ec       	ldi	r24, 0xC0	; 192
    3448:	98 e0       	ldi	r25, 0x08	; 8
    344a:	fc 01       	movw	r30, r24
    344c:	83 81       	ldd	r24, Z+3	; 0x03
    344e:	80 93 66 50 	sts	0x5066, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    3452:	80 ec       	ldi	r24, 0xC0	; 192
    3454:	98 e0       	ldi	r25, 0x08	; 8
    3456:	20 91 45 40 	lds	r18, 0x4045
    345a:	fc 01       	movw	r30, r24
    345c:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    345e:	00 00       	nop
    3460:	80 ec       	ldi	r24, 0xC0	; 192
    3462:	98 e0       	ldi	r25, 0x08	; 8
    3464:	fc 01       	movw	r30, r24
    3466:	82 81       	ldd	r24, Z+2	; 0x02
    3468:	88 23       	and	r24, r24
    346a:	d4 f7       	brge	.-12     	; 0x3460 <FRAMWriteKnowns+0xdc>
		SPIBuffer[12] = SPIC.DATA;
    346c:	80 ec       	ldi	r24, 0xC0	; 192
    346e:	98 e0       	ldi	r25, 0x08	; 8
    3470:	fc 01       	movw	r30, r24
    3472:	83 81       	ldd	r24, Z+3	; 0x03
    3474:	80 93 66 50 	sts	0x5066, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    3478:	80 ec       	ldi	r24, 0xC0	; 192
    347a:	98 e0       	ldi	r25, 0x08	; 8
    347c:	24 e4       	ldi	r18, 0x44	; 68
    347e:	30 e4       	ldi	r19, 0x40	; 64
    3480:	f9 01       	movw	r30, r18
    3482:	20 81       	ld	r18, Z
    3484:	fc 01       	movw	r30, r24
    3486:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3488:	00 00       	nop
    348a:	80 ec       	ldi	r24, 0xC0	; 192
    348c:	98 e0       	ldi	r25, 0x08	; 8
    348e:	fc 01       	movw	r30, r24
    3490:	82 81       	ldd	r24, Z+2	; 0x02
    3492:	88 23       	and	r24, r24
    3494:	d4 f7       	brge	.-12     	; 0x348a <FRAMWriteKnowns+0x106>
		SPIBuffer[12] = SPIC.DATA;
    3496:	80 ec       	ldi	r24, 0xC0	; 192
    3498:	98 e0       	ldi	r25, 0x08	; 8
    349a:	fc 01       	movw	r30, r24
    349c:	83 81       	ldd	r24, Z+3	; 0x03
    349e:	80 93 66 50 	sts	0x5066, r24
		SPIC.DATA = SPIBuffer[0];
    34a2:	80 ec       	ldi	r24, 0xC0	; 192
    34a4:	98 e0       	ldi	r25, 0x08	; 8
    34a6:	20 91 5a 50 	lds	r18, 0x505A
    34aa:	fc 01       	movw	r30, r24
    34ac:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    34ae:	00 00       	nop
    34b0:	80 ec       	ldi	r24, 0xC0	; 192
    34b2:	98 e0       	ldi	r25, 0x08	; 8
    34b4:	fc 01       	movw	r30, r24
    34b6:	82 81       	ldd	r24, Z+2	; 0x02
    34b8:	88 23       	and	r24, r24
    34ba:	d4 f7       	brge	.-12     	; 0x34b0 <FRAMWriteKnowns+0x12c>
		SPIBuffer[12] = SPIC.DATA;
    34bc:	80 ec       	ldi	r24, 0xC0	; 192
    34be:	98 e0       	ldi	r25, 0x08	; 8
    34c0:	fc 01       	movw	r30, r24
    34c2:	83 81       	ldd	r24, Z+3	; 0x03
    34c4:	80 93 66 50 	sts	0x5066, r24
		SPIC.DATA = SPIBuffer[1];
    34c8:	80 ec       	ldi	r24, 0xC0	; 192
    34ca:	98 e0       	ldi	r25, 0x08	; 8
    34cc:	20 91 5b 50 	lds	r18, 0x505B
    34d0:	fc 01       	movw	r30, r24
    34d2:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    34d4:	00 00       	nop
    34d6:	80 ec       	ldi	r24, 0xC0	; 192
    34d8:	98 e0       	ldi	r25, 0x08	; 8
    34da:	fc 01       	movw	r30, r24
    34dc:	82 81       	ldd	r24, Z+2	; 0x02
    34de:	88 23       	and	r24, r24
    34e0:	d4 f7       	brge	.-12     	; 0x34d6 <FRAMWriteKnowns+0x152>
		SPIBuffer[12] = SPIC.DATA;
    34e2:	80 ec       	ldi	r24, 0xC0	; 192
    34e4:	98 e0       	ldi	r25, 0x08	; 8
    34e6:	fc 01       	movw	r30, r24
    34e8:	83 81       	ldd	r24, Z+3	; 0x03
    34ea:	80 93 66 50 	sts	0x5066, r24
		SPIC.DATA = SPIBuffer[2];
    34ee:	80 ec       	ldi	r24, 0xC0	; 192
    34f0:	98 e0       	ldi	r25, 0x08	; 8
    34f2:	20 91 5c 50 	lds	r18, 0x505C
    34f6:	fc 01       	movw	r30, r24
    34f8:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    34fa:	00 00       	nop
    34fc:	80 ec       	ldi	r24, 0xC0	; 192
    34fe:	98 e0       	ldi	r25, 0x08	; 8
    3500:	fc 01       	movw	r30, r24
    3502:	82 81       	ldd	r24, Z+2	; 0x02
    3504:	88 23       	and	r24, r24
    3506:	d4 f7       	brge	.-12     	; 0x34fc <FRAMWriteKnowns+0x178>
		SPIBuffer[12] = SPIC.DATA;
    3508:	80 ec       	ldi	r24, 0xC0	; 192
    350a:	98 e0       	ldi	r25, 0x08	; 8
    350c:	fc 01       	movw	r30, r24
    350e:	83 81       	ldd	r24, Z+3	; 0x03
    3510:	80 93 66 50 	sts	0x5066, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    3514:	80 e2       	ldi	r24, 0x20	; 32
    3516:	96 e0       	ldi	r25, 0x06	; 6
    3518:	28 e0       	ldi	r18, 0x08	; 8
    351a:	fc 01       	movw	r30, r24
    351c:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    351e:	80 e4       	ldi	r24, 0x40	; 64
    3520:	96 e0       	ldi	r25, 0x06	; 6
    3522:	20 e1       	ldi	r18, 0x10	; 16
    3524:	fc 01       	movw	r30, r24
    3526:	25 83       	std	Z+5, r18	; 0x05
		
		FRAMAddress +=3;
    3528:	80 91 44 40 	lds	r24, 0x4044
    352c:	90 91 45 40 	lds	r25, 0x4045
    3530:	03 96       	adiw	r24, 0x03	; 3
    3532:	80 93 44 40 	sts	0x4044, r24
    3536:	90 93 45 40 	sts	0x4045, r25
		checksumADC[0] += SPIBuffer[0];
    353a:	90 91 26 21 	lds	r25, 0x2126
    353e:	80 91 5a 50 	lds	r24, 0x505A
    3542:	89 0f       	add	r24, r25
    3544:	80 93 26 21 	sts	0x2126, r24
		checksumADC[1] += SPIBuffer[1];
    3548:	90 91 27 21 	lds	r25, 0x2127
    354c:	80 91 5b 50 	lds	r24, 0x505B
    3550:	89 0f       	add	r24, r25
    3552:	80 93 27 21 	sts	0x2127, r24
		checksumADC[2] += SPIBuffer[2];
    3556:	90 91 28 21 	lds	r25, 0x2128
    355a:	80 91 5c 50 	lds	r24, 0x505C
    355e:	89 0f       	add	r24, r25
    3560:	80 93 28 21 	sts	0x2128, r24
		
		sampleCount++;
    3564:	80 91 69 50 	lds	r24, 0x5069
    3568:	90 91 6a 50 	lds	r25, 0x506A
    356c:	a0 91 6b 50 	lds	r26, 0x506B
    3570:	b0 91 6c 50 	lds	r27, 0x506C
    3574:	01 96       	adiw	r24, 0x01	; 1
    3576:	a1 1d       	adc	r26, r1
    3578:	b1 1d       	adc	r27, r1
    357a:	80 93 69 50 	sts	0x5069, r24
    357e:	90 93 6a 50 	sts	0x506A, r25
    3582:	a0 93 6b 50 	sts	0x506B, r26
    3586:	b0 93 6c 50 	sts	0x506C, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    358a:	80 91 69 50 	lds	r24, 0x5069
    358e:	90 91 6a 50 	lds	r25, 0x506A
    3592:	a0 91 6b 50 	lds	r26, 0x506B
    3596:	b0 91 6c 50 	lds	r27, 0x506C
    359a:	83 35       	cpi	r24, 0x53	; 83
    359c:	f5 e5       	ldi	r31, 0x55	; 85
    359e:	9f 07       	cpc	r25, r31
    35a0:	f0 e0       	ldi	r31, 0x00	; 0
    35a2:	af 07       	cpc	r26, r31
    35a4:	f0 e0       	ldi	r31, 0x00	; 0
    35a6:	bf 07       	cpc	r27, r31
    35a8:	08 f4       	brcc	.+2      	; 0x35ac <FRAMWriteKnowns+0x228>
    35aa:	18 cf       	rjmp	.-464    	; 0x33dc <FRAMWriteKnowns+0x58>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    35ac:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>
	ADCPower(FALSE);
    35b0:	80 e0       	ldi	r24, 0x00	; 0
    35b2:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
}
    35b6:	df 91       	pop	r29
    35b8:	cf 91       	pop	r28
    35ba:	08 95       	ret

000035bc <setADCInput>:



/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
    35bc:	cf 93       	push	r28
    35be:	df 93       	push	r29
    35c0:	0f 92       	push	r0
    35c2:	cd b7       	in	r28, 0x3d	; 61
    35c4:	de b7       	in	r29, 0x3e	; 62
    35c6:	89 83       	std	Y+1, r24	; 0x01
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    35c8:	89 81       	ldd	r24, Y+1	; 0x01
    35ca:	88 2f       	mov	r24, r24
    35cc:	90 e0       	ldi	r25, 0x00	; 0
    35ce:	81 70       	andi	r24, 0x01	; 1
    35d0:	90 70       	andi	r25, 0x00	; 0
    35d2:	88 23       	and	r24, r24
    35d4:	31 f0       	breq	.+12     	; 0x35e2 <setADCInput+0x26>
    35d6:	80 e0       	ldi	r24, 0x00	; 0
    35d8:	96 e0       	ldi	r25, 0x06	; 6
    35da:	20 e4       	ldi	r18, 0x40	; 64
    35dc:	fc 01       	movw	r30, r24
    35de:	25 83       	std	Z+5, r18	; 0x05
    35e0:	05 c0       	rjmp	.+10     	; 0x35ec <setADCInput+0x30>
	else {PORTA.OUTCLR = PIN6_bm;}
    35e2:	80 e0       	ldi	r24, 0x00	; 0
    35e4:	96 e0       	ldi	r25, 0x06	; 6
    35e6:	20 e4       	ldi	r18, 0x40	; 64
    35e8:	fc 01       	movw	r30, r24
    35ea:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    35ec:	89 81       	ldd	r24, Y+1	; 0x01
    35ee:	88 2f       	mov	r24, r24
    35f0:	90 e0       	ldi	r25, 0x00	; 0
    35f2:	82 70       	andi	r24, 0x02	; 2
    35f4:	90 70       	andi	r25, 0x00	; 0
    35f6:	00 97       	sbiw	r24, 0x00	; 0
    35f8:	31 f0       	breq	.+12     	; 0x3606 <setADCInput+0x4a>
    35fa:	80 e2       	ldi	r24, 0x20	; 32
    35fc:	96 e0       	ldi	r25, 0x06	; 6
    35fe:	22 e0       	ldi	r18, 0x02	; 2
    3600:	fc 01       	movw	r30, r24
    3602:	25 83       	std	Z+5, r18	; 0x05
    3604:	05 c0       	rjmp	.+10     	; 0x3610 <setADCInput+0x54>
	else {PORTB.OUTCLR = PIN1_bm;}
    3606:	80 e2       	ldi	r24, 0x20	; 32
    3608:	96 e0       	ldi	r25, 0x06	; 6
    360a:	22 e0       	ldi	r18, 0x02	; 2
    360c:	fc 01       	movw	r30, r24
    360e:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    3610:	89 81       	ldd	r24, Y+1	; 0x01
    3612:	88 2f       	mov	r24, r24
    3614:	90 e0       	ldi	r25, 0x00	; 0
    3616:	84 70       	andi	r24, 0x04	; 4
    3618:	90 70       	andi	r25, 0x00	; 0
    361a:	00 97       	sbiw	r24, 0x00	; 0
    361c:	31 f0       	breq	.+12     	; 0x362a <setADCInput+0x6e>
    361e:	80 e2       	ldi	r24, 0x20	; 32
    3620:	96 e0       	ldi	r25, 0x06	; 6
    3622:	24 e0       	ldi	r18, 0x04	; 4
    3624:	fc 01       	movw	r30, r24
    3626:	25 83       	std	Z+5, r18	; 0x05
    3628:	05 c0       	rjmp	.+10     	; 0x3634 <setADCInput+0x78>
	else {PORTB.OUTCLR = PIN2_bm;}
    362a:	80 e2       	ldi	r24, 0x20	; 32
    362c:	96 e0       	ldi	r25, 0x06	; 6
    362e:	24 e0       	ldi	r18, 0x04	; 4
    3630:	fc 01       	movw	r30, r24
    3632:	26 83       	std	Z+6, r18	; 0x06

}
    3634:	0f 90       	pop	r0
    3636:	df 91       	pop	r29
    3638:	cf 91       	pop	r28
    363a:	08 95       	ret

0000363c <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    363c:	cf 93       	push	r28
    363e:	df 93       	push	r29
    3640:	0f 92       	push	r0
    3642:	0f 92       	push	r0
    3644:	cd b7       	in	r28, 0x3d	; 61
    3646:	de b7       	in	r29, 0x3e	; 62
    3648:	89 83       	std	Y+1, r24	; 0x01
    364a:	9a 83       	std	Y+2, r25	; 0x02
	if(&ADCA == adc){
    364c:	89 81       	ldd	r24, Y+1	; 0x01
    364e:	9a 81       	ldd	r25, Y+2	; 0x02
    3650:	22 e0       	ldi	r18, 0x02	; 2
    3652:	80 30       	cpi	r24, 0x00	; 0
    3654:	92 07       	cpc	r25, r18
    3656:	89 f4       	brne	.+34     	; 0x367a <ADC_CalibrationValues_Load+0x3e>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    3658:	80 e2       	ldi	r24, 0x20	; 32
    365a:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <SP_ReadCalibrationByte>
    365e:	28 2f       	mov	r18, r24
    3660:	89 81       	ldd	r24, Y+1	; 0x01
    3662:	9a 81       	ldd	r25, Y+2	; 0x02
    3664:	fc 01       	movw	r30, r24
    3666:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    3668:	81 e2       	ldi	r24, 0x21	; 33
    366a:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <SP_ReadCalibrationByte>
    366e:	28 2f       	mov	r18, r24
    3670:	89 81       	ldd	r24, Y+1	; 0x01
    3672:	9a 81       	ldd	r25, Y+2	; 0x02
    3674:	fc 01       	movw	r30, r24
    3676:	25 87       	std	Z+13, r18	; 0x0d
    3678:	10 c0       	rjmp	.+32     	; 0x369a <ADC_CalibrationValues_Load+0x5e>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    367a:	84 e2       	ldi	r24, 0x24	; 36
    367c:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <SP_ReadCalibrationByte>
    3680:	28 2f       	mov	r18, r24
    3682:	89 81       	ldd	r24, Y+1	; 0x01
    3684:	9a 81       	ldd	r25, Y+2	; 0x02
    3686:	fc 01       	movw	r30, r24
    3688:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    368a:	85 e2       	ldi	r24, 0x25	; 37
    368c:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <SP_ReadCalibrationByte>
    3690:	28 2f       	mov	r18, r24
    3692:	89 81       	ldd	r24, Y+1	; 0x01
    3694:	9a 81       	ldd	r25, Y+2	; 0x02
    3696:	fc 01       	movw	r30, r24
    3698:	25 87       	std	Z+13, r18	; 0x0d
	}
}
    369a:	0f 90       	pop	r0
    369c:	0f 90       	pop	r0
    369e:	df 91       	pop	r29
    36a0:	cf 91       	pop	r28
    36a2:	08 95       	ret

000036a4 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    36a4:	cf 93       	push	r28
    36a6:	df 93       	push	r29
    36a8:	cd b7       	in	r28, 0x3d	; 61
    36aa:	de b7       	in	r29, 0x3e	; 62
    36ac:	25 97       	sbiw	r28, 0x05	; 5
    36ae:	cd bf       	out	0x3d, r28	; 61
    36b0:	de bf       	out	0x3e, r29	; 62
    36b2:	8b 83       	std	Y+3, r24	; 0x03
    36b4:	9c 83       	std	Y+4, r25	; 0x04
    36b6:	6d 83       	std	Y+5, r22	; 0x05
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    36b8:	8b 81       	ldd	r24, Y+3	; 0x03
    36ba:	9c 81       	ldd	r25, Y+4	; 0x04
    36bc:	21 e0       	ldi	r18, 0x01	; 1
    36be:	fc 01       	movw	r30, r24
    36c0:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    36c2:	8b 81       	ldd	r24, Y+3	; 0x03
    36c4:	9c 81       	ldd	r25, Y+4	; 0x04
    36c6:	fc 01       	movw	r30, r24
    36c8:	24 81       	ldd	r18, Z+4	; 0x04
    36ca:	35 81       	ldd	r19, Z+5	; 0x05
    36cc:	8d 81       	ldd	r24, Y+5	; 0x05
    36ce:	88 2f       	mov	r24, r24
    36d0:	90 e0       	ldi	r25, 0x00	; 0
    36d2:	a9 01       	movw	r20, r18
    36d4:	48 1b       	sub	r20, r24
    36d6:	59 0b       	sbc	r21, r25
    36d8:	ca 01       	movw	r24, r20
    36da:	89 83       	std	Y+1, r24	; 0x01
    36dc:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    36de:	89 81       	ldd	r24, Y+1	; 0x01
    36e0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    36e2:	25 96       	adiw	r28, 0x05	; 5
    36e4:	cd bf       	out	0x3d, r28	; 61
    36e6:	de bf       	out	0x3e, r29	; 62
    36e8:	df 91       	pop	r29
    36ea:	cf 91       	pop	r28
    36ec:	08 95       	ret

000036ee <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    36ee:	cf 93       	push	r28
    36f0:	df 93       	push	r29
    36f2:	cd b7       	in	r28, 0x3d	; 61
    36f4:	de b7       	in	r29, 0x3e	; 62
    36f6:	25 97       	sbiw	r28, 0x05	; 5
    36f8:	cd bf       	out	0x3d, r28	; 61
    36fa:	de bf       	out	0x3e, r29	; 62
    36fc:	8b 83       	std	Y+3, r24	; 0x03
    36fe:	9c 83       	std	Y+4, r25	; 0x04
    3700:	6d 83       	std	Y+5, r22	; 0x05
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3702:	8b 81       	ldd	r24, Y+3	; 0x03
    3704:	9c 81       	ldd	r25, Y+4	; 0x04
    3706:	21 e0       	ldi	r18, 0x01	; 1
    3708:	fc 01       	movw	r30, r24
    370a:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    370c:	8b 81       	ldd	r24, Y+3	; 0x03
    370e:	9c 81       	ldd	r25, Y+4	; 0x04
    3710:	fc 01       	movw	r30, r24
    3712:	24 81       	ldd	r18, Z+4	; 0x04
    3714:	35 81       	ldd	r19, Z+5	; 0x05
    3716:	8d 81       	ldd	r24, Y+5	; 0x05
    3718:	99 27       	eor	r25, r25
    371a:	87 fd       	sbrc	r24, 7
    371c:	90 95       	com	r25
    371e:	a9 01       	movw	r20, r18
    3720:	48 1b       	sub	r20, r24
    3722:	59 0b       	sbc	r21, r25
    3724:	ca 01       	movw	r24, r20
    3726:	89 83       	std	Y+1, r24	; 0x01
    3728:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    372a:	89 81       	ldd	r24, Y+1	; 0x01
    372c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    372e:	25 96       	adiw	r28, 0x05	; 5
    3730:	cd bf       	out	0x3d, r28	; 61
    3732:	de bf       	out	0x3e, r29	; 62
    3734:	df 91       	pop	r29
    3736:	cf 91       	pop	r28
    3738:	08 95       	ret

0000373a <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    373a:	cf 93       	push	r28
    373c:	df 93       	push	r29
    373e:	0f 92       	push	r0
    3740:	0f 92       	push	r0
    3742:	cd b7       	in	r28, 0x3d	; 61
    3744:	de b7       	in	r29, 0x3e	; 62
    3746:	89 83       	std	Y+1, r24	; 0x01
    3748:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    374a:	89 81       	ldd	r24, Y+1	; 0x01
    374c:	9a 81       	ldd	r25, Y+2	; 0x02
    374e:	21 e0       	ldi	r18, 0x01	; 1
    3750:	fc 01       	movw	r30, r24
    3752:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    3754:	89 81       	ldd	r24, Y+1	; 0x01
    3756:	9a 81       	ldd	r25, Y+2	; 0x02
    3758:	fc 01       	movw	r30, r24
    375a:	84 81       	ldd	r24, Z+4	; 0x04
    375c:	95 81       	ldd	r25, Z+5	; 0x05
}
    375e:	0f 90       	pop	r0
    3760:	0f 90       	pop	r0
    3762:	df 91       	pop	r29
    3764:	cf 91       	pop	r28
    3766:	08 95       	ret

00003768 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    3768:	cf 93       	push	r28
    376a:	df 93       	push	r29
    376c:	0f 92       	push	r0
    376e:	0f 92       	push	r0
    3770:	cd b7       	in	r28, 0x3d	; 61
    3772:	de b7       	in	r29, 0x3e	; 62
    3774:	89 83       	std	Y+1, r24	; 0x01
    3776:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3778:	89 81       	ldd	r24, Y+1	; 0x01
    377a:	9a 81       	ldd	r25, Y+2	; 0x02
    377c:	21 e0       	ldi	r18, 0x01	; 1
    377e:	fc 01       	movw	r30, r24
    3780:	23 83       	std	Z+3, r18	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    3782:	89 81       	ldd	r24, Y+1	; 0x01
    3784:	9a 81       	ldd	r25, Y+2	; 0x02
    3786:	fc 01       	movw	r30, r24
    3788:	84 81       	ldd	r24, Z+4	; 0x04
}
    378a:	0f 90       	pop	r0
    378c:	0f 90       	pop	r0
    378e:	df 91       	pop	r29
    3790:	cf 91       	pop	r28
    3792:	08 95       	ret

00003794 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    3794:	cf 93       	push	r28
    3796:	df 93       	push	r29
    3798:	0f 92       	push	r0
    379a:	0f 92       	push	r0
    379c:	cd b7       	in	r28, 0x3d	; 61
    379e:	de b7       	in	r29, 0x3e	; 62
    37a0:	89 83       	std	Y+1, r24	; 0x01
    37a2:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    37a4:	89 81       	ldd	r24, Y+1	; 0x01
    37a6:	9a 81       	ldd	r25, Y+2	; 0x02
    37a8:	21 e0       	ldi	r18, 0x01	; 1
    37aa:	fc 01       	movw	r30, r24
    37ac:	23 83       	std	Z+3, r18	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    37ae:	89 81       	ldd	r24, Y+1	; 0x01
    37b0:	9a 81       	ldd	r25, Y+2	; 0x02
    37b2:	fc 01       	movw	r30, r24
    37b4:	85 81       	ldd	r24, Z+5	; 0x05
}
    37b6:	0f 90       	pop	r0
    37b8:	0f 90       	pop	r0
    37ba:	df 91       	pop	r29
    37bc:	cf 91       	pop	r28
    37be:	08 95       	ret

000037c0 <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    37c0:	0f 93       	push	r16
    37c2:	1f 93       	push	r17
    37c4:	cf 93       	push	r28
    37c6:	df 93       	push	r29
    37c8:	cd b7       	in	r28, 0x3d	; 61
    37ca:	de b7       	in	r29, 0x3e	; 62
    37cc:	6b 97       	sbiw	r28, 0x1b	; 27
    37ce:	cd bf       	out	0x3d, r28	; 61
    37d0:	de bf       	out	0x3e, r29	; 62
    37d2:	8a 8f       	std	Y+26, r24	; 0x1a
    37d4:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    37d6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    37d8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    37da:	fc 01       	movw	r30, r24
    37dc:	84 81       	ldd	r24, Z+4	; 0x04
    37de:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    37e0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    37e2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    37e4:	fc 01       	movw	r30, r24
    37e6:	14 82       	std	Z+4, r1	; 0x04
    37e8:	80 e0       	ldi	r24, 0x00	; 0
    37ea:	90 e0       	ldi	r25, 0x00	; 0
    37ec:	a0 e8       	ldi	r26, 0x80	; 128
    37ee:	b2 e4       	ldi	r27, 0x42	; 66
    37f0:	8a 83       	std	Y+2, r24	; 0x02
    37f2:	9b 83       	std	Y+3, r25	; 0x03
    37f4:	ac 83       	std	Y+4, r26	; 0x04
    37f6:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    37f8:	6a 81       	ldd	r22, Y+2	; 0x02
    37fa:	7b 81       	ldd	r23, Y+3	; 0x03
    37fc:	8c 81       	ldd	r24, Y+4	; 0x04
    37fe:	9d 81       	ldd	r25, Y+5	; 0x05
    3800:	2b ea       	ldi	r18, 0xAB	; 171
    3802:	3a ea       	ldi	r19, 0xAA	; 170
    3804:	4a e2       	ldi	r20, 0x2A	; 42
    3806:	5f e3       	ldi	r21, 0x3F	; 63
    3808:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    380c:	dc 01       	movw	r26, r24
    380e:	cb 01       	movw	r24, r22
    3810:	8e 83       	std	Y+6, r24	; 0x06
    3812:	9f 83       	std	Y+7, r25	; 0x07
    3814:	a8 87       	std	Y+8, r26	; 0x08
    3816:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3818:	11 e0       	ldi	r17, 0x01	; 1
    381a:	6e 81       	ldd	r22, Y+6	; 0x06
    381c:	7f 81       	ldd	r23, Y+7	; 0x07
    381e:	88 85       	ldd	r24, Y+8	; 0x08
    3820:	99 85       	ldd	r25, Y+9	; 0x09
    3822:	20 e0       	ldi	r18, 0x00	; 0
    3824:	30 e0       	ldi	r19, 0x00	; 0
    3826:	40 e8       	ldi	r20, 0x80	; 128
    3828:	5f e3       	ldi	r21, 0x3F	; 63
    382a:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    382e:	88 23       	and	r24, r24
    3830:	0c f0       	brlt	.+2      	; 0x3834 <ADC_Wait_8MHz+0x74>
    3832:	10 e0       	ldi	r17, 0x00	; 0
    3834:	11 23       	and	r17, r17
    3836:	19 f0       	breq	.+6      	; 0x383e <ADC_Wait_8MHz+0x7e>
		__ticks = 1;
    3838:	81 e0       	ldi	r24, 0x01	; 1
    383a:	8a 87       	std	Y+10, r24	; 0x0a
    383c:	a3 c0       	rjmp	.+326    	; 0x3984 <ADC_Wait_8MHz+0x1c4>
	else if (__tmp > 255)
    383e:	11 e0       	ldi	r17, 0x01	; 1
    3840:	6e 81       	ldd	r22, Y+6	; 0x06
    3842:	7f 81       	ldd	r23, Y+7	; 0x07
    3844:	88 85       	ldd	r24, Y+8	; 0x08
    3846:	99 85       	ldd	r25, Y+9	; 0x09
    3848:	20 e0       	ldi	r18, 0x00	; 0
    384a:	30 e0       	ldi	r19, 0x00	; 0
    384c:	4f e7       	ldi	r20, 0x7F	; 127
    384e:	53 e4       	ldi	r21, 0x43	; 67
    3850:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    3854:	18 16       	cp	r1, r24
    3856:	0c f0       	brlt	.+2      	; 0x385a <ADC_Wait_8MHz+0x9a>
    3858:	10 e0       	ldi	r17, 0x00	; 0
    385a:	11 23       	and	r17, r17
    385c:	09 f4       	brne	.+2      	; 0x3860 <ADC_Wait_8MHz+0xa0>
    385e:	89 c0       	rjmp	.+274    	; 0x3972 <ADC_Wait_8MHz+0x1b2>
	{
		_delay_ms(__us / 1000.0);
    3860:	6a 81       	ldd	r22, Y+2	; 0x02
    3862:	7b 81       	ldd	r23, Y+3	; 0x03
    3864:	8c 81       	ldd	r24, Y+4	; 0x04
    3866:	9d 81       	ldd	r25, Y+5	; 0x05
    3868:	20 e0       	ldi	r18, 0x00	; 0
    386a:	30 e0       	ldi	r19, 0x00	; 0
    386c:	4a e7       	ldi	r20, 0x7A	; 122
    386e:	54 e4       	ldi	r21, 0x44	; 68
    3870:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
    3874:	dc 01       	movw	r26, r24
    3876:	cb 01       	movw	r24, r22
    3878:	8b 87       	std	Y+11, r24	; 0x0b
    387a:	9c 87       	std	Y+12, r25	; 0x0c
    387c:	ad 87       	std	Y+13, r26	; 0x0d
    387e:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3880:	6b 85       	ldd	r22, Y+11	; 0x0b
    3882:	7c 85       	ldd	r23, Y+12	; 0x0c
    3884:	8d 85       	ldd	r24, Y+13	; 0x0d
    3886:	9e 85       	ldd	r25, Y+14	; 0x0e
    3888:	20 e0       	ldi	r18, 0x00	; 0
    388a:	30 e0       	ldi	r19, 0x00	; 0
    388c:	4a ef       	ldi	r20, 0xFA	; 250
    388e:	53 e4       	ldi	r21, 0x43	; 67
    3890:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    3894:	dc 01       	movw	r26, r24
    3896:	cb 01       	movw	r24, r22
    3898:	8f 87       	std	Y+15, r24	; 0x0f
    389a:	98 8b       	std	Y+16, r25	; 0x10
    389c:	a9 8b       	std	Y+17, r26	; 0x11
    389e:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    38a0:	11 e0       	ldi	r17, 0x01	; 1
    38a2:	6f 85       	ldd	r22, Y+15	; 0x0f
    38a4:	78 89       	ldd	r23, Y+16	; 0x10
    38a6:	89 89       	ldd	r24, Y+17	; 0x11
    38a8:	9a 89       	ldd	r25, Y+18	; 0x12
    38aa:	20 e0       	ldi	r18, 0x00	; 0
    38ac:	30 e0       	ldi	r19, 0x00	; 0
    38ae:	40 e8       	ldi	r20, 0x80	; 128
    38b0:	5f e3       	ldi	r21, 0x3F	; 63
    38b2:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    38b6:	88 23       	and	r24, r24
    38b8:	0c f0       	brlt	.+2      	; 0x38bc <ADC_Wait_8MHz+0xfc>
    38ba:	10 e0       	ldi	r17, 0x00	; 0
    38bc:	11 23       	and	r17, r17
    38be:	29 f0       	breq	.+10     	; 0x38ca <ADC_Wait_8MHz+0x10a>
		__ticks = 1;
    38c0:	81 e0       	ldi	r24, 0x01	; 1
    38c2:	90 e0       	ldi	r25, 0x00	; 0
    38c4:	8b 8b       	std	Y+19, r24	; 0x13
    38c6:	9c 8b       	std	Y+20, r25	; 0x14
    38c8:	46 c0       	rjmp	.+140    	; 0x3956 <ADC_Wait_8MHz+0x196>
	else if (__tmp > 65535)
    38ca:	11 e0       	ldi	r17, 0x01	; 1
    38cc:	6f 85       	ldd	r22, Y+15	; 0x0f
    38ce:	78 89       	ldd	r23, Y+16	; 0x10
    38d0:	89 89       	ldd	r24, Y+17	; 0x11
    38d2:	9a 89       	ldd	r25, Y+18	; 0x12
    38d4:	20 e0       	ldi	r18, 0x00	; 0
    38d6:	3f ef       	ldi	r19, 0xFF	; 255
    38d8:	4f e7       	ldi	r20, 0x7F	; 127
    38da:	57 e4       	ldi	r21, 0x47	; 71
    38dc:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    38e0:	18 16       	cp	r1, r24
    38e2:	0c f0       	brlt	.+2      	; 0x38e6 <ADC_Wait_8MHz+0x126>
    38e4:	10 e0       	ldi	r17, 0x00	; 0
    38e6:	11 23       	and	r17, r17
    38e8:	61 f1       	breq	.+88     	; 0x3942 <ADC_Wait_8MHz+0x182>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    38ea:	6b 85       	ldd	r22, Y+11	; 0x0b
    38ec:	7c 85       	ldd	r23, Y+12	; 0x0c
    38ee:	8d 85       	ldd	r24, Y+13	; 0x0d
    38f0:	9e 85       	ldd	r25, Y+14	; 0x0e
    38f2:	20 e0       	ldi	r18, 0x00	; 0
    38f4:	30 e0       	ldi	r19, 0x00	; 0
    38f6:	40 e2       	ldi	r20, 0x20	; 32
    38f8:	51 e4       	ldi	r21, 0x41	; 65
    38fa:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    38fe:	dc 01       	movw	r26, r24
    3900:	cb 01       	movw	r24, r22
    3902:	bc 01       	movw	r22, r24
    3904:	cd 01       	movw	r24, r26
    3906:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    390a:	dc 01       	movw	r26, r24
    390c:	cb 01       	movw	r24, r22
    390e:	8b 8b       	std	Y+19, r24	; 0x13
    3910:	9c 8b       	std	Y+20, r25	; 0x14
    3912:	12 c0       	rjmp	.+36     	; 0x3938 <ADC_Wait_8MHz+0x178>
    3914:	82 e3       	ldi	r24, 0x32	; 50
    3916:	90 e0       	ldi	r25, 0x00	; 0
    3918:	8d 8b       	std	Y+21, r24	; 0x15
    391a:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    391c:	8d 89       	ldd	r24, Y+21	; 0x15
    391e:	9e 89       	ldd	r25, Y+22	; 0x16
    3920:	8c 01       	movw	r16, r24
    3922:	c8 01       	movw	r24, r16
    3924:	01 97       	sbiw	r24, 0x01	; 1
    3926:	f1 f7       	brne	.-4      	; 0x3924 <ADC_Wait_8MHz+0x164>
    3928:	8c 01       	movw	r16, r24
    392a:	0d 8b       	std	Y+21, r16	; 0x15
    392c:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    392e:	8b 89       	ldd	r24, Y+19	; 0x13
    3930:	9c 89       	ldd	r25, Y+20	; 0x14
    3932:	01 97       	sbiw	r24, 0x01	; 1
    3934:	8b 8b       	std	Y+19, r24	; 0x13
    3936:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3938:	8b 89       	ldd	r24, Y+19	; 0x13
    393a:	9c 89       	ldd	r25, Y+20	; 0x14
    393c:	00 97       	sbiw	r24, 0x00	; 0
    393e:	51 f7       	brne	.-44     	; 0x3914 <ADC_Wait_8MHz+0x154>
    3940:	28 c0       	rjmp	.+80     	; 0x3992 <ADC_Wait_8MHz+0x1d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3942:	6f 85       	ldd	r22, Y+15	; 0x0f
    3944:	78 89       	ldd	r23, Y+16	; 0x10
    3946:	89 89       	ldd	r24, Y+17	; 0x11
    3948:	9a 89       	ldd	r25, Y+18	; 0x12
    394a:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    394e:	dc 01       	movw	r26, r24
    3950:	cb 01       	movw	r24, r22
    3952:	8b 8b       	std	Y+19, r24	; 0x13
    3954:	9c 8b       	std	Y+20, r25	; 0x14
    3956:	8b 89       	ldd	r24, Y+19	; 0x13
    3958:	9c 89       	ldd	r25, Y+20	; 0x14
    395a:	8f 8b       	std	Y+23, r24	; 0x17
    395c:	98 8f       	std	Y+24, r25	; 0x18
    395e:	8f 89       	ldd	r24, Y+23	; 0x17
    3960:	98 8d       	ldd	r25, Y+24	; 0x18
    3962:	8c 01       	movw	r16, r24
    3964:	f8 01       	movw	r30, r16
    3966:	31 97       	sbiw	r30, 0x01	; 1
    3968:	f1 f7       	brne	.-4      	; 0x3966 <ADC_Wait_8MHz+0x1a6>
    396a:	8f 01       	movw	r16, r30
    396c:	0f 8b       	std	Y+23, r16	; 0x17
    396e:	18 8f       	std	Y+24, r17	; 0x18
    3970:	10 c0       	rjmp	.+32     	; 0x3992 <ADC_Wait_8MHz+0x1d2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3972:	6e 81       	ldd	r22, Y+6	; 0x06
    3974:	7f 81       	ldd	r23, Y+7	; 0x07
    3976:	88 85       	ldd	r24, Y+8	; 0x08
    3978:	99 85       	ldd	r25, Y+9	; 0x09
    397a:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    397e:	dc 01       	movw	r26, r24
    3980:	cb 01       	movw	r24, r22
    3982:	8a 87       	std	Y+10, r24	; 0x0a
    3984:	8a 85       	ldd	r24, Y+10	; 0x0a
    3986:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3988:	89 8d       	ldd	r24, Y+25	; 0x19
    398a:	18 2f       	mov	r17, r24
    398c:	1a 95       	dec	r17
    398e:	f1 f7       	brne	.-4      	; 0x398c <ADC_Wait_8MHz+0x1cc>
    3990:	19 8f       	std	Y+25, r17	; 0x19

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3992:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3994:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3996:	29 81       	ldd	r18, Y+1	; 0x01
    3998:	fc 01       	movw	r30, r24
    399a:	24 83       	std	Z+4, r18	; 0x04
}
    399c:	6b 96       	adiw	r28, 0x1b	; 27
    399e:	cd bf       	out	0x3d, r28	; 61
    39a0:	de bf       	out	0x3e, r29	; 62
    39a2:	df 91       	pop	r29
    39a4:	cf 91       	pop	r28
    39a6:	1f 91       	pop	r17
    39a8:	0f 91       	pop	r16
    39aa:	08 95       	ret

000039ac <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    39ac:	0f 93       	push	r16
    39ae:	1f 93       	push	r17
    39b0:	cf 93       	push	r28
    39b2:	df 93       	push	r29
    39b4:	cd b7       	in	r28, 0x3d	; 61
    39b6:	de b7       	in	r29, 0x3e	; 62
    39b8:	6b 97       	sbiw	r28, 0x1b	; 27
    39ba:	cd bf       	out	0x3d, r28	; 61
    39bc:	de bf       	out	0x3e, r29	; 62
    39be:	8a 8f       	std	Y+26, r24	; 0x1a
    39c0:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    39c2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    39c4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    39c6:	fc 01       	movw	r30, r24
    39c8:	84 81       	ldd	r24, Z+4	; 0x04
    39ca:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    39cc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    39ce:	9b 8d       	ldd	r25, Y+27	; 0x1b
    39d0:	21 e0       	ldi	r18, 0x01	; 1
    39d2:	fc 01       	movw	r30, r24
    39d4:	24 83       	std	Z+4, r18	; 0x04
    39d6:	80 e0       	ldi	r24, 0x00	; 0
    39d8:	90 e0       	ldi	r25, 0x00	; 0
    39da:	a0 e0       	ldi	r26, 0x00	; 0
    39dc:	b3 e4       	ldi	r27, 0x43	; 67
    39de:	8a 83       	std	Y+2, r24	; 0x02
    39e0:	9b 83       	std	Y+3, r25	; 0x03
    39e2:	ac 83       	std	Y+4, r26	; 0x04
    39e4:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    39e6:	6a 81       	ldd	r22, Y+2	; 0x02
    39e8:	7b 81       	ldd	r23, Y+3	; 0x03
    39ea:	8c 81       	ldd	r24, Y+4	; 0x04
    39ec:	9d 81       	ldd	r25, Y+5	; 0x05
    39ee:	2b ea       	ldi	r18, 0xAB	; 171
    39f0:	3a ea       	ldi	r19, 0xAA	; 170
    39f2:	4a e2       	ldi	r20, 0x2A	; 42
    39f4:	5f e3       	ldi	r21, 0x3F	; 63
    39f6:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    39fa:	dc 01       	movw	r26, r24
    39fc:	cb 01       	movw	r24, r22
    39fe:	8e 83       	std	Y+6, r24	; 0x06
    3a00:	9f 83       	std	Y+7, r25	; 0x07
    3a02:	a8 87       	std	Y+8, r26	; 0x08
    3a04:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3a06:	11 e0       	ldi	r17, 0x01	; 1
    3a08:	6e 81       	ldd	r22, Y+6	; 0x06
    3a0a:	7f 81       	ldd	r23, Y+7	; 0x07
    3a0c:	88 85       	ldd	r24, Y+8	; 0x08
    3a0e:	99 85       	ldd	r25, Y+9	; 0x09
    3a10:	20 e0       	ldi	r18, 0x00	; 0
    3a12:	30 e0       	ldi	r19, 0x00	; 0
    3a14:	40 e8       	ldi	r20, 0x80	; 128
    3a16:	5f e3       	ldi	r21, 0x3F	; 63
    3a18:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    3a1c:	88 23       	and	r24, r24
    3a1e:	0c f0       	brlt	.+2      	; 0x3a22 <ADC_Wait_32MHz+0x76>
    3a20:	10 e0       	ldi	r17, 0x00	; 0
    3a22:	11 23       	and	r17, r17
    3a24:	19 f0       	breq	.+6      	; 0x3a2c <ADC_Wait_32MHz+0x80>
		__ticks = 1;
    3a26:	81 e0       	ldi	r24, 0x01	; 1
    3a28:	8a 87       	std	Y+10, r24	; 0x0a
    3a2a:	a3 c0       	rjmp	.+326    	; 0x3b72 <ADC_Wait_32MHz+0x1c6>
	else if (__tmp > 255)
    3a2c:	11 e0       	ldi	r17, 0x01	; 1
    3a2e:	6e 81       	ldd	r22, Y+6	; 0x06
    3a30:	7f 81       	ldd	r23, Y+7	; 0x07
    3a32:	88 85       	ldd	r24, Y+8	; 0x08
    3a34:	99 85       	ldd	r25, Y+9	; 0x09
    3a36:	20 e0       	ldi	r18, 0x00	; 0
    3a38:	30 e0       	ldi	r19, 0x00	; 0
    3a3a:	4f e7       	ldi	r20, 0x7F	; 127
    3a3c:	53 e4       	ldi	r21, 0x43	; 67
    3a3e:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    3a42:	18 16       	cp	r1, r24
    3a44:	0c f0       	brlt	.+2      	; 0x3a48 <ADC_Wait_32MHz+0x9c>
    3a46:	10 e0       	ldi	r17, 0x00	; 0
    3a48:	11 23       	and	r17, r17
    3a4a:	09 f4       	brne	.+2      	; 0x3a4e <ADC_Wait_32MHz+0xa2>
    3a4c:	89 c0       	rjmp	.+274    	; 0x3b60 <ADC_Wait_32MHz+0x1b4>
	{
		_delay_ms(__us / 1000.0);
    3a4e:	6a 81       	ldd	r22, Y+2	; 0x02
    3a50:	7b 81       	ldd	r23, Y+3	; 0x03
    3a52:	8c 81       	ldd	r24, Y+4	; 0x04
    3a54:	9d 81       	ldd	r25, Y+5	; 0x05
    3a56:	20 e0       	ldi	r18, 0x00	; 0
    3a58:	30 e0       	ldi	r19, 0x00	; 0
    3a5a:	4a e7       	ldi	r20, 0x7A	; 122
    3a5c:	54 e4       	ldi	r21, 0x44	; 68
    3a5e:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
    3a62:	dc 01       	movw	r26, r24
    3a64:	cb 01       	movw	r24, r22
    3a66:	8b 87       	std	Y+11, r24	; 0x0b
    3a68:	9c 87       	std	Y+12, r25	; 0x0c
    3a6a:	ad 87       	std	Y+13, r26	; 0x0d
    3a6c:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3a6e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3a70:	7c 85       	ldd	r23, Y+12	; 0x0c
    3a72:	8d 85       	ldd	r24, Y+13	; 0x0d
    3a74:	9e 85       	ldd	r25, Y+14	; 0x0e
    3a76:	20 e0       	ldi	r18, 0x00	; 0
    3a78:	30 e0       	ldi	r19, 0x00	; 0
    3a7a:	4a ef       	ldi	r20, 0xFA	; 250
    3a7c:	53 e4       	ldi	r21, 0x43	; 67
    3a7e:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    3a82:	dc 01       	movw	r26, r24
    3a84:	cb 01       	movw	r24, r22
    3a86:	8f 87       	std	Y+15, r24	; 0x0f
    3a88:	98 8b       	std	Y+16, r25	; 0x10
    3a8a:	a9 8b       	std	Y+17, r26	; 0x11
    3a8c:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    3a8e:	11 e0       	ldi	r17, 0x01	; 1
    3a90:	6f 85       	ldd	r22, Y+15	; 0x0f
    3a92:	78 89       	ldd	r23, Y+16	; 0x10
    3a94:	89 89       	ldd	r24, Y+17	; 0x11
    3a96:	9a 89       	ldd	r25, Y+18	; 0x12
    3a98:	20 e0       	ldi	r18, 0x00	; 0
    3a9a:	30 e0       	ldi	r19, 0x00	; 0
    3a9c:	40 e8       	ldi	r20, 0x80	; 128
    3a9e:	5f e3       	ldi	r21, 0x3F	; 63
    3aa0:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    3aa4:	88 23       	and	r24, r24
    3aa6:	0c f0       	brlt	.+2      	; 0x3aaa <ADC_Wait_32MHz+0xfe>
    3aa8:	10 e0       	ldi	r17, 0x00	; 0
    3aaa:	11 23       	and	r17, r17
    3aac:	29 f0       	breq	.+10     	; 0x3ab8 <ADC_Wait_32MHz+0x10c>
		__ticks = 1;
    3aae:	81 e0       	ldi	r24, 0x01	; 1
    3ab0:	90 e0       	ldi	r25, 0x00	; 0
    3ab2:	8b 8b       	std	Y+19, r24	; 0x13
    3ab4:	9c 8b       	std	Y+20, r25	; 0x14
    3ab6:	46 c0       	rjmp	.+140    	; 0x3b44 <ADC_Wait_32MHz+0x198>
	else if (__tmp > 65535)
    3ab8:	11 e0       	ldi	r17, 0x01	; 1
    3aba:	6f 85       	ldd	r22, Y+15	; 0x0f
    3abc:	78 89       	ldd	r23, Y+16	; 0x10
    3abe:	89 89       	ldd	r24, Y+17	; 0x11
    3ac0:	9a 89       	ldd	r25, Y+18	; 0x12
    3ac2:	20 e0       	ldi	r18, 0x00	; 0
    3ac4:	3f ef       	ldi	r19, 0xFF	; 255
    3ac6:	4f e7       	ldi	r20, 0x7F	; 127
    3ac8:	57 e4       	ldi	r21, 0x47	; 71
    3aca:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    3ace:	18 16       	cp	r1, r24
    3ad0:	0c f0       	brlt	.+2      	; 0x3ad4 <ADC_Wait_32MHz+0x128>
    3ad2:	10 e0       	ldi	r17, 0x00	; 0
    3ad4:	11 23       	and	r17, r17
    3ad6:	61 f1       	breq	.+88     	; 0x3b30 <ADC_Wait_32MHz+0x184>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3ad8:	6b 85       	ldd	r22, Y+11	; 0x0b
    3ada:	7c 85       	ldd	r23, Y+12	; 0x0c
    3adc:	8d 85       	ldd	r24, Y+13	; 0x0d
    3ade:	9e 85       	ldd	r25, Y+14	; 0x0e
    3ae0:	20 e0       	ldi	r18, 0x00	; 0
    3ae2:	30 e0       	ldi	r19, 0x00	; 0
    3ae4:	40 e2       	ldi	r20, 0x20	; 32
    3ae6:	51 e4       	ldi	r21, 0x41	; 65
    3ae8:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    3aec:	dc 01       	movw	r26, r24
    3aee:	cb 01       	movw	r24, r22
    3af0:	bc 01       	movw	r22, r24
    3af2:	cd 01       	movw	r24, r26
    3af4:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    3af8:	dc 01       	movw	r26, r24
    3afa:	cb 01       	movw	r24, r22
    3afc:	8b 8b       	std	Y+19, r24	; 0x13
    3afe:	9c 8b       	std	Y+20, r25	; 0x14
    3b00:	12 c0       	rjmp	.+36     	; 0x3b26 <ADC_Wait_32MHz+0x17a>
    3b02:	82 e3       	ldi	r24, 0x32	; 50
    3b04:	90 e0       	ldi	r25, 0x00	; 0
    3b06:	8d 8b       	std	Y+21, r24	; 0x15
    3b08:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3b0a:	8d 89       	ldd	r24, Y+21	; 0x15
    3b0c:	9e 89       	ldd	r25, Y+22	; 0x16
    3b0e:	8c 01       	movw	r16, r24
    3b10:	c8 01       	movw	r24, r16
    3b12:	01 97       	sbiw	r24, 0x01	; 1
    3b14:	f1 f7       	brne	.-4      	; 0x3b12 <ADC_Wait_32MHz+0x166>
    3b16:	8c 01       	movw	r16, r24
    3b18:	0d 8b       	std	Y+21, r16	; 0x15
    3b1a:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3b1c:	8b 89       	ldd	r24, Y+19	; 0x13
    3b1e:	9c 89       	ldd	r25, Y+20	; 0x14
    3b20:	01 97       	sbiw	r24, 0x01	; 1
    3b22:	8b 8b       	std	Y+19, r24	; 0x13
    3b24:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3b26:	8b 89       	ldd	r24, Y+19	; 0x13
    3b28:	9c 89       	ldd	r25, Y+20	; 0x14
    3b2a:	00 97       	sbiw	r24, 0x00	; 0
    3b2c:	51 f7       	brne	.-44     	; 0x3b02 <ADC_Wait_32MHz+0x156>
    3b2e:	28 c0       	rjmp	.+80     	; 0x3b80 <ADC_Wait_32MHz+0x1d4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3b30:	6f 85       	ldd	r22, Y+15	; 0x0f
    3b32:	78 89       	ldd	r23, Y+16	; 0x10
    3b34:	89 89       	ldd	r24, Y+17	; 0x11
    3b36:	9a 89       	ldd	r25, Y+18	; 0x12
    3b38:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    3b3c:	dc 01       	movw	r26, r24
    3b3e:	cb 01       	movw	r24, r22
    3b40:	8b 8b       	std	Y+19, r24	; 0x13
    3b42:	9c 8b       	std	Y+20, r25	; 0x14
    3b44:	8b 89       	ldd	r24, Y+19	; 0x13
    3b46:	9c 89       	ldd	r25, Y+20	; 0x14
    3b48:	8f 8b       	std	Y+23, r24	; 0x17
    3b4a:	98 8f       	std	Y+24, r25	; 0x18
    3b4c:	8f 89       	ldd	r24, Y+23	; 0x17
    3b4e:	98 8d       	ldd	r25, Y+24	; 0x18
    3b50:	8c 01       	movw	r16, r24
    3b52:	f8 01       	movw	r30, r16
    3b54:	31 97       	sbiw	r30, 0x01	; 1
    3b56:	f1 f7       	brne	.-4      	; 0x3b54 <ADC_Wait_32MHz+0x1a8>
    3b58:	8f 01       	movw	r16, r30
    3b5a:	0f 8b       	std	Y+23, r16	; 0x17
    3b5c:	18 8f       	std	Y+24, r17	; 0x18
    3b5e:	10 c0       	rjmp	.+32     	; 0x3b80 <ADC_Wait_32MHz+0x1d4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3b60:	6e 81       	ldd	r22, Y+6	; 0x06
    3b62:	7f 81       	ldd	r23, Y+7	; 0x07
    3b64:	88 85       	ldd	r24, Y+8	; 0x08
    3b66:	99 85       	ldd	r25, Y+9	; 0x09
    3b68:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    3b6c:	dc 01       	movw	r26, r24
    3b6e:	cb 01       	movw	r24, r22
    3b70:	8a 87       	std	Y+10, r24	; 0x0a
    3b72:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b74:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3b76:	89 8d       	ldd	r24, Y+25	; 0x19
    3b78:	18 2f       	mov	r17, r24
    3b7a:	1a 95       	dec	r17
    3b7c:	f1 f7       	brne	.-4      	; 0x3b7a <ADC_Wait_32MHz+0x1ce>
    3b7e:	19 8f       	std	Y+25, r17	; 0x19

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3b80:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3b82:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3b84:	29 81       	ldd	r18, Y+1	; 0x01
    3b86:	fc 01       	movw	r30, r24
    3b88:	24 83       	std	Z+4, r18	; 0x04
}
    3b8a:	6b 96       	adiw	r28, 0x1b	; 27
    3b8c:	cd bf       	out	0x3d, r28	; 61
    3b8e:	de bf       	out	0x3e, r29	; 62
    3b90:	df 91       	pop	r29
    3b92:	cf 91       	pop	r28
    3b94:	1f 91       	pop	r17
    3b96:	0f 91       	pop	r16
    3b98:	08 95       	ret

00003b9a <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3b9a:	cf 93       	push	r28
    3b9c:	df 93       	push	r29
    3b9e:	cd b7       	in	r28, 0x3d	; 61
    3ba0:	de b7       	in	r29, 0x3e	; 62
    3ba2:	2a 97       	sbiw	r28, 0x0a	; 10
    3ba4:	cd bf       	out	0x3d, r28	; 61
    3ba6:	de bf       	out	0x3e, r29	; 62
    3ba8:	8e 83       	std	Y+6, r24	; 0x06
    3baa:	9f 83       	std	Y+7, r25	; 0x07
    3bac:	68 87       	std	Y+8, r22	; 0x08
    3bae:	79 87       	std	Y+9, r23	; 0x09
    3bb0:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3bb2:	8a 85       	ldd	r24, Y+10	; 0x0a
    3bb4:	88 23       	and	r24, r24
    3bb6:	a9 f1       	breq	.+106    	; 0x3c22 <ADC_Offset_Get_Unsigned+0x88>
    {
      uint16_t offset=0;
    3bb8:	19 82       	std	Y+1, r1	; 0x01
    3bba:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3bbc:	1b 82       	std	Y+3, r1	; 0x03
    3bbe:	1c 82       	std	Y+4, r1	; 0x04
    3bc0:	24 c0       	rjmp	.+72     	; 0x3c0a <ADC_Offset_Get_Unsigned+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3bc2:	88 85       	ldd	r24, Y+8	; 0x08
    3bc4:	99 85       	ldd	r25, Y+9	; 0x09
    3bc6:	fc 01       	movw	r30, r24
    3bc8:	80 81       	ld	r24, Z
    3bca:	28 2f       	mov	r18, r24
    3bcc:	20 68       	ori	r18, 0x80	; 128
    3bce:	88 85       	ldd	r24, Y+8	; 0x08
    3bd0:	99 85       	ldd	r25, Y+9	; 0x09
    3bd2:	fc 01       	movw	r30, r24
    3bd4:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3bd6:	88 85       	ldd	r24, Y+8	; 0x08
    3bd8:	99 85       	ldd	r25, Y+9	; 0x09
    3bda:	fc 01       	movw	r30, r24
    3bdc:	83 81       	ldd	r24, Z+3	; 0x03
    3bde:	88 2f       	mov	r24, r24
    3be0:	90 e0       	ldi	r25, 0x00	; 0
    3be2:	81 70       	andi	r24, 0x01	; 1
    3be4:	90 70       	andi	r25, 0x00	; 0
    3be6:	00 97       	sbiw	r24, 0x00	; 0
    3be8:	b1 f3       	breq	.-20     	; 0x3bd6 <ADC_Offset_Get_Unsigned+0x3c>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    3bea:	88 85       	ldd	r24, Y+8	; 0x08
    3bec:	99 85       	ldd	r25, Y+9	; 0x09
    3bee:	60 e0       	ldi	r22, 0x00	; 0
    3bf0:	0e 94 52 1b 	call	0x36a4	; 0x36a4 <ADC_ResultCh_GetWord_Unsigned>
    3bf4:	29 81       	ldd	r18, Y+1	; 0x01
    3bf6:	3a 81       	ldd	r19, Y+2	; 0x02
    3bf8:	82 0f       	add	r24, r18
    3bfa:	93 1f       	adc	r25, r19
    3bfc:	89 83       	std	Y+1, r24	; 0x01
    3bfe:	9a 83       	std	Y+2, r25	; 0x02
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    3c00:	8b 81       	ldd	r24, Y+3	; 0x03
    3c02:	9c 81       	ldd	r25, Y+4	; 0x04
    3c04:	01 96       	adiw	r24, 0x01	; 1
    3c06:	8b 83       	std	Y+3, r24	; 0x03
    3c08:	9c 83       	std	Y+4, r25	; 0x04
    3c0a:	8b 81       	ldd	r24, Y+3	; 0x03
    3c0c:	9c 81       	ldd	r25, Y+4	; 0x04
    3c0e:	84 30       	cpi	r24, 0x04	; 4
    3c10:	91 05       	cpc	r25, r1
    3c12:	bc f2       	brlt	.-82     	; 0x3bc2 <ADC_Offset_Get_Unsigned+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    3c14:	89 81       	ldd	r24, Y+1	; 0x01
    3c16:	9a 81       	ldd	r25, Y+2	; 0x02
    3c18:	96 95       	lsr	r25
    3c1a:	87 95       	ror	r24
    3c1c:	96 95       	lsr	r25
    3c1e:	87 95       	ror	r24
    3c20:	1b c0       	rjmp	.+54     	; 0x3c58 <ADC_Offset_Get_Unsigned+0xbe>
    }
    else
    {        
      uint8_t offset=0;
    3c22:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3c24:	88 85       	ldd	r24, Y+8	; 0x08
    3c26:	99 85       	ldd	r25, Y+9	; 0x09
    3c28:	fc 01       	movw	r30, r24
    3c2a:	80 81       	ld	r24, Z
    3c2c:	28 2f       	mov	r18, r24
    3c2e:	20 68       	ori	r18, 0x80	; 128
    3c30:	88 85       	ldd	r24, Y+8	; 0x08
    3c32:	99 85       	ldd	r25, Y+9	; 0x09
    3c34:	fc 01       	movw	r30, r24
    3c36:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3c38:	88 85       	ldd	r24, Y+8	; 0x08
    3c3a:	99 85       	ldd	r25, Y+9	; 0x09
    3c3c:	fc 01       	movw	r30, r24
    3c3e:	83 81       	ldd	r24, Z+3	; 0x03
    3c40:	88 2f       	mov	r24, r24
    3c42:	90 e0       	ldi	r25, 0x00	; 0
    3c44:	81 70       	andi	r24, 0x01	; 1
    3c46:	90 70       	andi	r25, 0x00	; 0
    3c48:	00 97       	sbiw	r24, 0x00	; 0
    3c4a:	b1 f3       	breq	.-20     	; 0x3c38 <ADC_Offset_Get_Unsigned+0x9e>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    3c4c:	88 85       	ldd	r24, Y+8	; 0x08
    3c4e:	99 85       	ldd	r25, Y+9	; 0x09
    3c50:	0e 94 9d 1b 	call	0x373a	; 0x373a <ADC_ResultCh_GetWord>
    3c54:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3c56:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3c58:	2a 96       	adiw	r28, 0x0a	; 10
    3c5a:	cd bf       	out	0x3d, r28	; 61
    3c5c:	de bf       	out	0x3e, r29	; 62
    3c5e:	df 91       	pop	r29
    3c60:	cf 91       	pop	r28
    3c62:	08 95       	ret

00003c64 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3c64:	cf 93       	push	r28
    3c66:	df 93       	push	r29
    3c68:	cd b7       	in	r28, 0x3d	; 61
    3c6a:	de b7       	in	r29, 0x3e	; 62
    3c6c:	2a 97       	sbiw	r28, 0x0a	; 10
    3c6e:	cd bf       	out	0x3d, r28	; 61
    3c70:	de bf       	out	0x3e, r29	; 62
    3c72:	8e 83       	std	Y+6, r24	; 0x06
    3c74:	9f 83       	std	Y+7, r25	; 0x07
    3c76:	68 87       	std	Y+8, r22	; 0x08
    3c78:	79 87       	std	Y+9, r23	; 0x09
    3c7a:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3c7c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3c7e:	88 23       	and	r24, r24
    3c80:	c1 f1       	breq	.+112    	; 0x3cf2 <ADC_Offset_Get_Signed+0x8e>
    {
      int16_t offset=0;
    3c82:	19 82       	std	Y+1, r1	; 0x01
    3c84:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3c86:	1b 82       	std	Y+3, r1	; 0x03
    3c88:	1c 82       	std	Y+4, r1	; 0x04
    3c8a:	24 c0       	rjmp	.+72     	; 0x3cd4 <ADC_Offset_Get_Signed+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3c8c:	88 85       	ldd	r24, Y+8	; 0x08
    3c8e:	99 85       	ldd	r25, Y+9	; 0x09
    3c90:	fc 01       	movw	r30, r24
    3c92:	80 81       	ld	r24, Z
    3c94:	28 2f       	mov	r18, r24
    3c96:	20 68       	ori	r18, 0x80	; 128
    3c98:	88 85       	ldd	r24, Y+8	; 0x08
    3c9a:	99 85       	ldd	r25, Y+9	; 0x09
    3c9c:	fc 01       	movw	r30, r24
    3c9e:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3ca0:	88 85       	ldd	r24, Y+8	; 0x08
    3ca2:	99 85       	ldd	r25, Y+9	; 0x09
    3ca4:	fc 01       	movw	r30, r24
    3ca6:	83 81       	ldd	r24, Z+3	; 0x03
    3ca8:	88 2f       	mov	r24, r24
    3caa:	90 e0       	ldi	r25, 0x00	; 0
    3cac:	81 70       	andi	r24, 0x01	; 1
    3cae:	90 70       	andi	r25, 0x00	; 0
    3cb0:	00 97       	sbiw	r24, 0x00	; 0
    3cb2:	b1 f3       	breq	.-20     	; 0x3ca0 <ADC_Offset_Get_Signed+0x3c>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3cb4:	88 85       	ldd	r24, Y+8	; 0x08
    3cb6:	99 85       	ldd	r25, Y+9	; 0x09
    3cb8:	60 e0       	ldi	r22, 0x00	; 0
    3cba:	0e 94 77 1b 	call	0x36ee	; 0x36ee <ADC_ResultCh_GetWord_Signed>
    3cbe:	29 81       	ldd	r18, Y+1	; 0x01
    3cc0:	3a 81       	ldd	r19, Y+2	; 0x02
    3cc2:	82 0f       	add	r24, r18
    3cc4:	93 1f       	adc	r25, r19
    3cc6:	89 83       	std	Y+1, r24	; 0x01
    3cc8:	9a 83       	std	Y+2, r25	; 0x02
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    3cca:	8b 81       	ldd	r24, Y+3	; 0x03
    3ccc:	9c 81       	ldd	r25, Y+4	; 0x04
    3cce:	01 96       	adiw	r24, 0x01	; 1
    3cd0:	8b 83       	std	Y+3, r24	; 0x03
    3cd2:	9c 83       	std	Y+4, r25	; 0x04
    3cd4:	8b 81       	ldd	r24, Y+3	; 0x03
    3cd6:	9c 81       	ldd	r25, Y+4	; 0x04
    3cd8:	84 30       	cpi	r24, 0x04	; 4
    3cda:	91 05       	cpc	r25, r1
    3cdc:	bc f2       	brlt	.-82     	; 0x3c8c <ADC_Offset_Get_Signed+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    3cde:	89 81       	ldd	r24, Y+1	; 0x01
    3ce0:	9a 81       	ldd	r25, Y+2	; 0x02
    3ce2:	99 23       	and	r25, r25
    3ce4:	0c f4       	brge	.+2      	; 0x3ce8 <ADC_Offset_Get_Signed+0x84>
    3ce6:	03 96       	adiw	r24, 0x03	; 3
    3ce8:	95 95       	asr	r25
    3cea:	87 95       	ror	r24
    3cec:	95 95       	asr	r25
    3cee:	87 95       	ror	r24
    3cf0:	1c c0       	rjmp	.+56     	; 0x3d2a <ADC_Offset_Get_Signed+0xc6>
    }
    else
    {        
      int8_t offset=0;
    3cf2:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3cf4:	88 85       	ldd	r24, Y+8	; 0x08
    3cf6:	99 85       	ldd	r25, Y+9	; 0x09
    3cf8:	fc 01       	movw	r30, r24
    3cfa:	80 81       	ld	r24, Z
    3cfc:	28 2f       	mov	r18, r24
    3cfe:	20 68       	ori	r18, 0x80	; 128
    3d00:	88 85       	ldd	r24, Y+8	; 0x08
    3d02:	99 85       	ldd	r25, Y+9	; 0x09
    3d04:	fc 01       	movw	r30, r24
    3d06:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3d08:	88 85       	ldd	r24, Y+8	; 0x08
    3d0a:	99 85       	ldd	r25, Y+9	; 0x09
    3d0c:	fc 01       	movw	r30, r24
    3d0e:	83 81       	ldd	r24, Z+3	; 0x03
    3d10:	88 2f       	mov	r24, r24
    3d12:	90 e0       	ldi	r25, 0x00	; 0
    3d14:	81 70       	andi	r24, 0x01	; 1
    3d16:	90 70       	andi	r25, 0x00	; 0
    3d18:	00 97       	sbiw	r24, 0x00	; 0
    3d1a:	b1 f3       	breq	.-20     	; 0x3d08 <ADC_Offset_Get_Signed+0xa4>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3d1c:	88 85       	ldd	r24, Y+8	; 0x08
    3d1e:	99 85       	ldd	r25, Y+9	; 0x09
    3d20:	60 e0       	ldi	r22, 0x00	; 0
    3d22:	0e 94 77 1b 	call	0x36ee	; 0x36ee <ADC_ResultCh_GetWord_Signed>
    3d26:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3d28:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3d2a:	2a 96       	adiw	r28, 0x0a	; 10
    3d2c:	cd bf       	out	0x3d, r28	; 61
    3d2e:	de bf       	out	0x3e, r29	; 62
    3d30:	df 91       	pop	r29
    3d32:	cf 91       	pop	r28
    3d34:	08 95       	ret

00003d36 <SP_ReadCalibrationByte>:
 *  \param index The index to the calibration byte.
 *
 *  \return Calibration byte.
 */
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
    3d36:	1f 93       	push	r17
    3d38:	cf 93       	push	r28
    3d3a:	df 93       	push	r29
    3d3c:	cd b7       	in	r28, 0x3d	; 61
    3d3e:	de b7       	in	r29, 0x3e	; 62
    3d40:	25 97       	sbiw	r28, 0x05	; 5
    3d42:	cd bf       	out	0x3d, r28	; 61
    3d44:	de bf       	out	0x3e, r29	; 62
    3d46:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    3d48:	8a ec       	ldi	r24, 0xCA	; 202
    3d4a:	91 e0       	ldi	r25, 0x01	; 1
    3d4c:	22 e0       	ldi	r18, 0x02	; 2
    3d4e:	fc 01       	movw	r30, r24
    3d50:	20 83       	st	Z, r18
 	result = pgm_read_byte(index);
    3d52:	8d 81       	ldd	r24, Y+5	; 0x05
    3d54:	88 2f       	mov	r24, r24
    3d56:	90 e0       	ldi	r25, 0x00	; 0
    3d58:	89 83       	std	Y+1, r24	; 0x01
    3d5a:	9a 83       	std	Y+2, r25	; 0x02
    3d5c:	89 81       	ldd	r24, Y+1	; 0x01
    3d5e:	9a 81       	ldd	r25, Y+2	; 0x02
    3d60:	fc 01       	movw	r30, r24
    3d62:	14 91       	lpm	r17, Z
    3d64:	1b 83       	std	Y+3, r17	; 0x03
    3d66:	8b 81       	ldd	r24, Y+3	; 0x03
    3d68:	8c 83       	std	Y+4, r24	; 0x04

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    3d6a:	8a ec       	ldi	r24, 0xCA	; 202
    3d6c:	91 e0       	ldi	r25, 0x01	; 1
    3d6e:	fc 01       	movw	r30, r24
    3d70:	10 82       	st	Z, r1

	return result;
    3d72:	8c 81       	ldd	r24, Y+4	; 0x04
}
    3d74:	25 96       	adiw	r28, 0x05	; 5
    3d76:	cd bf       	out	0x3d, r28	; 61
    3d78:	de bf       	out	0x3e, r29	; 62
    3d7a:	df 91       	pop	r29
    3d7c:	cf 91       	pop	r28
    3d7e:	1f 91       	pop	r17
    3d80:	08 95       	ret

00003d82 <chb_init>:
/*!

*/
/**************************************************************************/
void chb_init()
{
    3d82:	cf 93       	push	r28
    3d84:	df 93       	push	r29
    3d86:	cd b7       	in	r28, 0x3d	; 61
    3d88:	de b7       	in	r29, 0x3e	; 62
    memset(&pcb, 0, sizeof(pcb_t));
    3d8a:	24 e1       	ldi	r18, 0x14	; 20
    3d8c:	8c e2       	ldi	r24, 0x2C	; 44
    3d8e:	91 e2       	ldi	r25, 0x21	; 33
    3d90:	fc 01       	movw	r30, r24
    3d92:	32 2f       	mov	r19, r18
    3d94:	11 92       	st	Z+, r1
    3d96:	3a 95       	dec	r19
    3d98:	e9 f7       	brne	.-6      	; 0x3d94 <chb_init+0x12>
    pcb.src_addr = chb_get_short_addr();
    3d9a:	0e 94 87 2c 	call	0x590e	; 0x590e <chb_get_short_addr>
    3d9e:	80 93 2c 21 	sts	0x212C, r24
    3da2:	90 93 2d 21 	sts	0x212D, r25
    chb_drvr_init();
    3da6:	0e 94 7f 2e 	call	0x5cfe	; 0x5cfe <chb_drvr_init>
	radio_msg_received_int_enable();
    3daa:	0e 94 da 1e 	call	0x3db4	; 0x3db4 <radio_msg_received_int_enable>
}
    3dae:	df 91       	pop	r29
    3db0:	cf 91       	pop	r28
    3db2:	08 95       	ret

00003db4 <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
    3db4:	cf 93       	push	r28
    3db6:	df 93       	push	r29
    3db8:	cd b7       	in	r28, 0x3d	; 61
    3dba:	de b7       	in	r29, 0x3e	; 62
	PORTE.DIRSET = PIN2_bm;
    3dbc:	80 e8       	ldi	r24, 0x80	; 128
    3dbe:	96 e0       	ldi	r25, 0x06	; 6
    3dc0:	24 e0       	ldi	r18, 0x04	; 4
    3dc2:	fc 01       	movw	r30, r24
    3dc4:	21 83       	std	Z+1, r18	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    3dc6:	80 e8       	ldi	r24, 0x80	; 128
    3dc8:	96 e0       	ldi	r25, 0x06	; 6
    3dca:	24 e0       	ldi	r18, 0x04	; 4
    3dcc:	fc 01       	movw	r30, r24
    3dce:	26 83       	std	Z+6, r18	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    3dd0:	80 e8       	ldi	r24, 0x80	; 128
    3dd2:	96 e0       	ldi	r25, 0x06	; 6
    3dd4:	22 e0       	ldi	r18, 0x02	; 2
    3dd6:	fc 01       	movw	r30, r24
    3dd8:	20 8b       	std	Z+16, r18	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    3dda:	80 e8       	ldi	r24, 0x80	; 128
    3ddc:	96 e0       	ldi	r25, 0x06	; 6
    3dde:	24 e0       	ldi	r18, 0x04	; 4
    3de0:	fc 01       	movw	r30, r24
    3de2:	22 87       	std	Z+10, r18	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    3de4:	80 e8       	ldi	r24, 0x80	; 128
    3de6:	96 e0       	ldi	r25, 0x06	; 6
    3de8:	23 e0       	ldi	r18, 0x03	; 3
    3dea:	fc 01       	movw	r30, r24
    3dec:	21 87       	std	Z+9, r18	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    3dee:	80 ea       	ldi	r24, 0xA0	; 160
    3df0:	90 e0       	ldi	r25, 0x00	; 0
    3df2:	20 ea       	ldi	r18, 0xA0	; 160
    3df4:	30 e0       	ldi	r19, 0x00	; 0
    3df6:	f9 01       	movw	r30, r18
    3df8:	22 81       	ldd	r18, Z+2	; 0x02
    3dfa:	24 60       	ori	r18, 0x04	; 4
    3dfc:	fc 01       	movw	r30, r24
    3dfe:	22 83       	std	Z+2, r18	; 0x02
	sei();
    3e00:	78 94       	sei
}
    3e02:	df 91       	pop	r29
    3e04:	cf 91       	pop	r28
    3e06:	08 95       	ret

00003e08 <chb_get_pcb>:
/*!

*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    3e08:	cf 93       	push	r28
    3e0a:	df 93       	push	r29
    3e0c:	cd b7       	in	r28, 0x3d	; 61
    3e0e:	de b7       	in	r29, 0x3e	; 62
    return &pcb;
    3e10:	8c e2       	ldi	r24, 0x2C	; 44
    3e12:	91 e2       	ldi	r25, 0x21	; 33
}
    3e14:	df 91       	pop	r29
    3e16:	cf 91       	pop	r28
    3e18:	08 95       	ret

00003e1a <chb_gen_hdr>:
    Requires the dest addr, location to store data, and len of payload.
    Returns the length of the hdr. 
*/
/**************************************************************************/
static U8 chb_gen_hdr(U8 *hdr, U16 addr, U8 len)
{
    3e1a:	cf 93       	push	r28
    3e1c:	df 93       	push	r29
    3e1e:	cd b7       	in	r28, 0x3d	; 61
    3e20:	de b7       	in	r29, 0x3e	; 62
    3e22:	27 97       	sbiw	r28, 0x07	; 7
    3e24:	cd bf       	out	0x3d, r28	; 61
    3e26:	de bf       	out	0x3e, r29	; 62
    3e28:	8b 83       	std	Y+3, r24	; 0x03
    3e2a:	9c 83       	std	Y+4, r25	; 0x04
    3e2c:	6d 83       	std	Y+5, r22	; 0x05
    3e2e:	7e 83       	std	Y+6, r23	; 0x06
    3e30:	4f 83       	std	Y+7, r20	; 0x07
    U8 *hdr_ptr = hdr;
    3e32:	8b 81       	ldd	r24, Y+3	; 0x03
    3e34:	9c 81       	ldd	r25, Y+4	; 0x04
    3e36:	89 83       	std	Y+1, r24	; 0x01
    3e38:	9a 83       	std	Y+2, r25	; 0x02

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    3e3a:	8f 81       	ldd	r24, Y+7	; 0x07
    3e3c:	28 2f       	mov	r18, r24
    3e3e:	25 5f       	subi	r18, 0xF5	; 245
    3e40:	89 81       	ldd	r24, Y+1	; 0x01
    3e42:	9a 81       	ldd	r25, Y+2	; 0x02
    3e44:	fc 01       	movw	r30, r24
    3e46:	20 83       	st	Z, r18
    3e48:	89 81       	ldd	r24, Y+1	; 0x01
    3e4a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e4c:	01 96       	adiw	r24, 0x01	; 1
    3e4e:	89 83       	std	Y+1, r24	; 0x01
    3e50:	9a 83       	std	Y+2, r25	; 0x02

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    3e52:	8d 81       	ldd	r24, Y+5	; 0x05
    3e54:	9e 81       	ldd	r25, Y+6	; 0x06
    3e56:	ff ef       	ldi	r31, 0xFF	; 255
    3e58:	8f 3f       	cpi	r24, 0xFF	; 255
    3e5a:	9f 07       	cpc	r25, r31
    3e5c:	11 f0       	breq	.+4      	; 0x3e62 <chb_gen_hdr+0x48>
    3e5e:	21 e6       	ldi	r18, 0x61	; 97
    3e60:	01 c0       	rjmp	.+2      	; 0x3e64 <chb_gen_hdr+0x4a>
    3e62:	21 e4       	ldi	r18, 0x41	; 65
    3e64:	89 81       	ldd	r24, Y+1	; 0x01
    3e66:	9a 81       	ldd	r25, Y+2	; 0x02
    3e68:	fc 01       	movw	r30, r24
    3e6a:	20 83       	st	Z, r18
    3e6c:	89 81       	ldd	r24, Y+1	; 0x01
    3e6e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e70:	01 96       	adiw	r24, 0x01	; 1
    3e72:	89 83       	std	Y+1, r24	; 0x01
    3e74:	9a 83       	std	Y+2, r25	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    3e76:	89 81       	ldd	r24, Y+1	; 0x01
    3e78:	9a 81       	ldd	r25, Y+2	; 0x02
    3e7a:	28 e9       	ldi	r18, 0x98	; 152
    3e7c:	fc 01       	movw	r30, r24
    3e7e:	20 83       	st	Z, r18
    3e80:	89 81       	ldd	r24, Y+1	; 0x01
    3e82:	9a 81       	ldd	r25, Y+2	; 0x02
    3e84:	01 96       	adiw	r24, 0x01	; 1
    3e86:	89 83       	std	Y+1, r24	; 0x01
    3e88:	9a 83       	std	Y+2, r25	; 0x02

    *hdr_ptr++ = pcb.seq++;
    3e8a:	20 91 2e 21 	lds	r18, 0x212E
    3e8e:	89 81       	ldd	r24, Y+1	; 0x01
    3e90:	9a 81       	ldd	r25, Y+2	; 0x02
    3e92:	fc 01       	movw	r30, r24
    3e94:	20 83       	st	Z, r18
    3e96:	89 81       	ldd	r24, Y+1	; 0x01
    3e98:	9a 81       	ldd	r25, Y+2	; 0x02
    3e9a:	01 96       	adiw	r24, 0x01	; 1
    3e9c:	89 83       	std	Y+1, r24	; 0x01
    3e9e:	9a 83       	std	Y+2, r25	; 0x02
    3ea0:	82 2f       	mov	r24, r18
    3ea2:	8f 5f       	subi	r24, 0xFF	; 255
    3ea4:	80 93 2e 21 	sts	0x212E, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    3ea8:	89 81       	ldd	r24, Y+1	; 0x01
    3eaa:	9a 81       	ldd	r25, Y+2	; 0x02
    3eac:	24 e3       	ldi	r18, 0x34	; 52
    3eae:	32 e1       	ldi	r19, 0x12	; 18
    3eb0:	fc 01       	movw	r30, r24
    3eb2:	20 83       	st	Z, r18
    3eb4:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3eb6:	89 81       	ldd	r24, Y+1	; 0x01
    3eb8:	9a 81       	ldd	r25, Y+2	; 0x02
    3eba:	02 96       	adiw	r24, 0x02	; 2
    3ebc:	89 83       	std	Y+1, r24	; 0x01
    3ebe:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = addr;
    3ec0:	89 81       	ldd	r24, Y+1	; 0x01
    3ec2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ec4:	2d 81       	ldd	r18, Y+5	; 0x05
    3ec6:	3e 81       	ldd	r19, Y+6	; 0x06
    3ec8:	fc 01       	movw	r30, r24
    3eca:	20 83       	st	Z, r18
    3ecc:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3ece:	89 81       	ldd	r24, Y+1	; 0x01
    3ed0:	9a 81       	ldd	r25, Y+2	; 0x02
    3ed2:	02 96       	adiw	r24, 0x02	; 2
    3ed4:	89 83       	std	Y+1, r24	; 0x01
    3ed6:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = pcb.src_addr;
    3ed8:	20 91 2c 21 	lds	r18, 0x212C
    3edc:	30 91 2d 21 	lds	r19, 0x212D
    3ee0:	89 81       	ldd	r24, Y+1	; 0x01
    3ee2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ee4:	fc 01       	movw	r30, r24
    3ee6:	20 83       	st	Z, r18
    3ee8:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3eea:	89 81       	ldd	r24, Y+1	; 0x01
    3eec:	9a 81       	ldd	r25, Y+2	; 0x02
    3eee:	02 96       	adiw	r24, 0x02	; 2
    3ef0:	89 83       	std	Y+1, r24	; 0x01
    3ef2:	9a 83       	std	Y+2, r25	; 0x02
    
    // return the len of the header
    return hdr_ptr - hdr;
    3ef4:	29 81       	ldd	r18, Y+1	; 0x01
    3ef6:	3a 81       	ldd	r19, Y+2	; 0x02
    3ef8:	8b 81       	ldd	r24, Y+3	; 0x03
    3efa:	9c 81       	ldd	r25, Y+4	; 0x04
    3efc:	a9 01       	movw	r20, r18
    3efe:	48 1b       	sub	r20, r24
    3f00:	59 0b       	sbc	r21, r25
    3f02:	ca 01       	movw	r24, r20
}
    3f04:	27 96       	adiw	r28, 0x07	; 7
    3f06:	cd bf       	out	0x3d, r28	; 61
    3f08:	de bf       	out	0x3e, r29	; 62
    3f0a:	df 91       	pop	r29
    3f0c:	cf 91       	pop	r28
    3f0e:	08 95       	ret

00003f10 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    3f10:	ef 92       	push	r14
    3f12:	ff 92       	push	r15
    3f14:	0f 93       	push	r16
    3f16:	1f 93       	push	r17
    3f18:	cf 93       	push	r28
    3f1a:	df 93       	push	r29
    3f1c:	cd b7       	in	r28, 0x3d	; 61
    3f1e:	de b7       	in	r29, 0x3e	; 62
    3f20:	e0 97       	sbiw	r28, 0x30	; 48
    3f22:	cd bf       	out	0x3d, r28	; 61
    3f24:	de bf       	out	0x3e, r29	; 62
    3f26:	89 a7       	lds	r24, 0x79
    3f28:	9a a7       	lds	r25, 0x7a
    3f2a:	6b a7       	lds	r22, 0x7b
    3f2c:	7c a7       	lds	r23, 0x7c
    3f2e:	2d a7       	lds	r18, 0x7d
    3f30:	3e a7       	lds	r19, 0x7e
    3f32:	4f a7       	lds	r20, 0x7f
    3f34:	58 ab       	sts	0x58, r21
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    3f36:	19 82       	std	Y+1, r1	; 0x01
    while (len > 0)
    3f38:	62 c1       	rjmp	.+708    	; 0x41fe <chb_write+0x2ee>
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    3f3a:	8d a5       	lds	r24, 0x6d
    3f3c:	9e a5       	lds	r25, 0x6e
    3f3e:	af a5       	lds	r26, 0x6f
    3f40:	b8 a9       	sts	0x48, r27
    3f42:	85 36       	cpi	r24, 0x65	; 101
    3f44:	91 05       	cpc	r25, r1
    3f46:	a1 05       	cpc	r26, r1
    3f48:	b1 05       	cpc	r27, r1
    3f4a:	20 f0       	brcs	.+8      	; 0x3f54 <chb_write+0x44>
    3f4c:	84 e6       	ldi	r24, 0x64	; 100
    3f4e:	90 e0       	ldi	r25, 0x00	; 0
    3f50:	a0 e0       	ldi	r26, 0x00	; 0
    3f52:	b0 e0       	ldi	r27, 0x00	; 0
    3f54:	8c 83       	std	Y+4, r24	; 0x04

        // gen frame header
        hdr_len = chb_gen_hdr(hdr, addr, frm_len);
    3f56:	ce 01       	movw	r24, r28
    3f58:	4f 96       	adiw	r24, 0x1f	; 31
    3f5a:	29 a5       	lds	r18, 0x69
    3f5c:	3a a5       	lds	r19, 0x6a
    3f5e:	b9 01       	movw	r22, r18
    3f60:	4c 81       	ldd	r20, Y+4	; 0x04
    3f62:	0e 94 0d 1f 	call	0x3e1a	; 0x3e1a <chb_gen_hdr>
    3f66:	8d 83       	std	Y+5, r24	; 0x05

        // send data to chip
		rtry = 0;
    3f68:	1a 82       	std	Y+2, r1	; 0x02
    3f6a:	1b 82       	std	Y+3, r1	; 0x03
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    3f6c:	89 81       	ldd	r24, Y+1	; 0x01
    3f6e:	88 2f       	mov	r24, r24
    3f70:	90 e0       	ldi	r25, 0x00	; 0
    3f72:	2b a5       	lds	r18, 0x6b
    3f74:	3c a5       	lds	r19, 0x6c
    3f76:	28 0f       	add	r18, r24
    3f78:	39 1f       	adc	r19, r25
    3f7a:	ce 01       	movw	r24, r28
    3f7c:	4f 96       	adiw	r24, 0x1f	; 31
    3f7e:	b9 01       	movw	r22, r18
    3f80:	4c 81       	ldd	r20, Y+4	; 0x04
    3f82:	0e 94 a1 2c 	call	0x5942	; 0x5942 <chb_tx>
    3f86:	8e 83       	std	Y+6, r24	; 0x06

             switch (status)
    3f88:	8e 81       	ldd	r24, Y+6	; 0x06
    3f8a:	88 2f       	mov	r24, r24
    3f8c:	90 e0       	ldi	r25, 0x00	; 0
    3f8e:	83 30       	cpi	r24, 0x03	; 3
    3f90:	91 05       	cpc	r25, r1
    3f92:	31 f1       	breq	.+76     	; 0x3fe0 <chb_write+0xd0>
    3f94:	84 30       	cpi	r24, 0x04	; 4
    3f96:	91 05       	cpc	r25, r1
    3f98:	24 f4       	brge	.+8      	; 0x3fa2 <chb_write+0x92>
    3f9a:	81 30       	cpi	r24, 0x01	; 1
    3f9c:	91 05       	cpc	r25, r1
    3f9e:	39 f0       	breq	.+14     	; 0x3fae <chb_write+0x9e>
    3fa0:	2e c0       	rjmp	.+92     	; 0x3ffe <chb_write+0xee>
    3fa2:	85 30       	cpi	r24, 0x05	; 5
    3fa4:	91 05       	cpc	r25, r1
    3fa6:	69 f0       	breq	.+26     	; 0x3fc2 <chb_write+0xb2>
    3fa8:	80 34       	cpi	r24, 0x40	; 64
    3faa:	91 05       	cpc	r25, r1
    3fac:	41 f5       	brne	.+80     	; 0x3ffe <chb_write+0xee>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    3fae:	80 91 33 21 	lds	r24, 0x2133
    3fb2:	90 91 34 21 	lds	r25, 0x2134
    3fb6:	01 96       	adiw	r24, 0x01	; 1
    3fb8:	80 93 33 21 	sts	0x2133, r24
    3fbc:	90 93 34 21 	sts	0x2134, r25
                 break;
    3fc0:	1f c0       	rjmp	.+62     	; 0x4000 <chb_write+0xf0>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    3fc2:	80 91 35 21 	lds	r24, 0x2135
    3fc6:	90 91 36 21 	lds	r25, 0x2136
    3fca:	01 96       	adiw	r24, 0x01	; 1
    3fcc:	80 93 35 21 	sts	0x2135, r24
    3fd0:	90 93 36 21 	sts	0x2136, r25
				 rtry++;
    3fd4:	8a 81       	ldd	r24, Y+2	; 0x02
    3fd6:	9b 81       	ldd	r25, Y+3	; 0x03
    3fd8:	01 96       	adiw	r24, 0x01	; 1
    3fda:	8a 83       	std	Y+2, r24	; 0x02
    3fdc:	9b 83       	std	Y+3, r25	; 0x03
                 break;
    3fde:	10 c0       	rjmp	.+32     	; 0x4000 <chb_write+0xf0>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    3fe0:	80 91 37 21 	lds	r24, 0x2137
    3fe4:	90 91 38 21 	lds	r25, 0x2138
    3fe8:	01 96       	adiw	r24, 0x01	; 1
    3fea:	80 93 37 21 	sts	0x2137, r24
    3fee:	90 93 38 21 	sts	0x2138, r25
				 rtry++;
    3ff2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ff4:	9b 81       	ldd	r25, Y+3	; 0x03
    3ff6:	01 96       	adiw	r24, 0x01	; 1
    3ff8:	8a 83       	std	Y+2, r24	; 0x02
    3ffa:	9b 83       	std	Y+3, r25	; 0x03
                 break;
    3ffc:	01 c0       	rjmp	.+2      	; 0x4000 <chb_write+0xf0>
 
             default:
                 break;
    3ffe:	00 00       	nop
             }
			if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
    4000:	8a 81       	ldd	r24, Y+2	; 0x02
    4002:	9b 81       	ldd	r25, Y+3	; 0x03
    4004:	18 16       	cp	r1, r24
    4006:	19 06       	cpc	r1, r25
    4008:	0c f0       	brlt	.+2      	; 0x400c <chb_write+0xfc>
    400a:	d5 c0       	rjmp	.+426    	; 0x41b6 <chb_write+0x2a6>
    400c:	80 e0       	ldi	r24, 0x00	; 0
    400e:	90 e0       	ldi	r25, 0x00	; 0
    4010:	a0 e2       	ldi	r26, 0x20	; 32
    4012:	b1 e4       	ldi	r27, 0x41	; 65
    4014:	8f 83       	std	Y+7, r24	; 0x07
    4016:	98 87       	std	Y+8, r25	; 0x08
    4018:	a9 87       	std	Y+9, r26	; 0x09
    401a:	ba 87       	std	Y+10, r27	; 0x0a
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    401c:	6f 81       	ldd	r22, Y+7	; 0x07
    401e:	78 85       	ldd	r23, Y+8	; 0x08
    4020:	89 85       	ldd	r24, Y+9	; 0x09
    4022:	9a 85       	ldd	r25, Y+10	; 0x0a
    4024:	2b ea       	ldi	r18, 0xAB	; 171
    4026:	3a ea       	ldi	r19, 0xAA	; 170
    4028:	4a ea       	ldi	r20, 0xAA	; 170
    402a:	5e e3       	ldi	r21, 0x3E	; 62
    402c:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    4030:	dc 01       	movw	r26, r24
    4032:	cb 01       	movw	r24, r22
    4034:	8b 87       	std	Y+11, r24	; 0x0b
    4036:	9c 87       	std	Y+12, r25	; 0x0c
    4038:	ad 87       	std	Y+13, r26	; 0x0d
    403a:	be 87       	std	Y+14, r27	; 0x0e
	if (__tmp < 1.0)
    403c:	11 e0       	ldi	r17, 0x01	; 1
    403e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4040:	7c 85       	ldd	r23, Y+12	; 0x0c
    4042:	8d 85       	ldd	r24, Y+13	; 0x0d
    4044:	9e 85       	ldd	r25, Y+14	; 0x0e
    4046:	20 e0       	ldi	r18, 0x00	; 0
    4048:	30 e0       	ldi	r19, 0x00	; 0
    404a:	40 e8       	ldi	r20, 0x80	; 128
    404c:	5f e3       	ldi	r21, 0x3F	; 63
    404e:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    4052:	88 23       	and	r24, r24
    4054:	0c f0       	brlt	.+2      	; 0x4058 <chb_write+0x148>
    4056:	10 e0       	ldi	r17, 0x00	; 0
    4058:	11 23       	and	r17, r17
    405a:	19 f0       	breq	.+6      	; 0x4062 <chb_write+0x152>
		__ticks = 1;
    405c:	81 e0       	ldi	r24, 0x01	; 1
    405e:	8f 87       	std	Y+15, r24	; 0x0f
    4060:	a3 c0       	rjmp	.+326    	; 0x41a8 <chb_write+0x298>
	else if (__tmp > 255)
    4062:	11 e0       	ldi	r17, 0x01	; 1
    4064:	6b 85       	ldd	r22, Y+11	; 0x0b
    4066:	7c 85       	ldd	r23, Y+12	; 0x0c
    4068:	8d 85       	ldd	r24, Y+13	; 0x0d
    406a:	9e 85       	ldd	r25, Y+14	; 0x0e
    406c:	20 e0       	ldi	r18, 0x00	; 0
    406e:	30 e0       	ldi	r19, 0x00	; 0
    4070:	4f e7       	ldi	r20, 0x7F	; 127
    4072:	53 e4       	ldi	r21, 0x43	; 67
    4074:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    4078:	18 16       	cp	r1, r24
    407a:	0c f0       	brlt	.+2      	; 0x407e <chb_write+0x16e>
    407c:	10 e0       	ldi	r17, 0x00	; 0
    407e:	11 23       	and	r17, r17
    4080:	09 f4       	brne	.+2      	; 0x4084 <chb_write+0x174>
    4082:	89 c0       	rjmp	.+274    	; 0x4196 <chb_write+0x286>
	{
		_delay_ms(__us / 1000.0);
    4084:	6f 81       	ldd	r22, Y+7	; 0x07
    4086:	78 85       	ldd	r23, Y+8	; 0x08
    4088:	89 85       	ldd	r24, Y+9	; 0x09
    408a:	9a 85       	ldd	r25, Y+10	; 0x0a
    408c:	20 e0       	ldi	r18, 0x00	; 0
    408e:	30 e0       	ldi	r19, 0x00	; 0
    4090:	4a e7       	ldi	r20, 0x7A	; 122
    4092:	54 e4       	ldi	r21, 0x44	; 68
    4094:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
    4098:	dc 01       	movw	r26, r24
    409a:	cb 01       	movw	r24, r22
    409c:	88 8b       	std	Y+16, r24	; 0x10
    409e:	99 8b       	std	Y+17, r25	; 0x11
    40a0:	aa 8b       	std	Y+18, r26	; 0x12
    40a2:	bb 8b       	std	Y+19, r27	; 0x13
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    40a4:	68 89       	ldd	r22, Y+16	; 0x10
    40a6:	79 89       	ldd	r23, Y+17	; 0x11
    40a8:	8a 89       	ldd	r24, Y+18	; 0x12
    40aa:	9b 89       	ldd	r25, Y+19	; 0x13
    40ac:	20 e0       	ldi	r18, 0x00	; 0
    40ae:	30 e0       	ldi	r19, 0x00	; 0
    40b0:	4a e7       	ldi	r20, 0x7A	; 122
    40b2:	53 e4       	ldi	r21, 0x43	; 67
    40b4:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    40b8:	dc 01       	movw	r26, r24
    40ba:	cb 01       	movw	r24, r22
    40bc:	8c 8b       	std	Y+20, r24	; 0x14
    40be:	9d 8b       	std	Y+21, r25	; 0x15
    40c0:	ae 8b       	std	Y+22, r26	; 0x16
    40c2:	bf 8b       	std	Y+23, r27	; 0x17
	if (__tmp < 1.0)
    40c4:	11 e0       	ldi	r17, 0x01	; 1
    40c6:	6c 89       	ldd	r22, Y+20	; 0x14
    40c8:	7d 89       	ldd	r23, Y+21	; 0x15
    40ca:	8e 89       	ldd	r24, Y+22	; 0x16
    40cc:	9f 89       	ldd	r25, Y+23	; 0x17
    40ce:	20 e0       	ldi	r18, 0x00	; 0
    40d0:	30 e0       	ldi	r19, 0x00	; 0
    40d2:	40 e8       	ldi	r20, 0x80	; 128
    40d4:	5f e3       	ldi	r21, 0x3F	; 63
    40d6:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    40da:	88 23       	and	r24, r24
    40dc:	0c f0       	brlt	.+2      	; 0x40e0 <chb_write+0x1d0>
    40de:	10 e0       	ldi	r17, 0x00	; 0
    40e0:	11 23       	and	r17, r17
    40e2:	29 f0       	breq	.+10     	; 0x40ee <chb_write+0x1de>
		__ticks = 1;
    40e4:	81 e0       	ldi	r24, 0x01	; 1
    40e6:	90 e0       	ldi	r25, 0x00	; 0
    40e8:	88 8f       	std	Y+24, r24	; 0x18
    40ea:	99 8f       	std	Y+25, r25	; 0x19
    40ec:	46 c0       	rjmp	.+140    	; 0x417a <chb_write+0x26a>
	else if (__tmp > 65535)
    40ee:	11 e0       	ldi	r17, 0x01	; 1
    40f0:	6c 89       	ldd	r22, Y+20	; 0x14
    40f2:	7d 89       	ldd	r23, Y+21	; 0x15
    40f4:	8e 89       	ldd	r24, Y+22	; 0x16
    40f6:	9f 89       	ldd	r25, Y+23	; 0x17
    40f8:	20 e0       	ldi	r18, 0x00	; 0
    40fa:	3f ef       	ldi	r19, 0xFF	; 255
    40fc:	4f e7       	ldi	r20, 0x7F	; 127
    40fe:	57 e4       	ldi	r21, 0x47	; 71
    4100:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    4104:	18 16       	cp	r1, r24
    4106:	0c f0       	brlt	.+2      	; 0x410a <chb_write+0x1fa>
    4108:	10 e0       	ldi	r17, 0x00	; 0
    410a:	11 23       	and	r17, r17
    410c:	61 f1       	breq	.+88     	; 0x4166 <chb_write+0x256>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    410e:	68 89       	ldd	r22, Y+16	; 0x10
    4110:	79 89       	ldd	r23, Y+17	; 0x11
    4112:	8a 89       	ldd	r24, Y+18	; 0x12
    4114:	9b 89       	ldd	r25, Y+19	; 0x13
    4116:	20 e0       	ldi	r18, 0x00	; 0
    4118:	30 e0       	ldi	r19, 0x00	; 0
    411a:	40 e2       	ldi	r20, 0x20	; 32
    411c:	51 e4       	ldi	r21, 0x41	; 65
    411e:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    4122:	dc 01       	movw	r26, r24
    4124:	cb 01       	movw	r24, r22
    4126:	bc 01       	movw	r22, r24
    4128:	cd 01       	movw	r24, r26
    412a:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    412e:	dc 01       	movw	r26, r24
    4130:	cb 01       	movw	r24, r22
    4132:	88 8f       	std	Y+24, r24	; 0x18
    4134:	99 8f       	std	Y+25, r25	; 0x19
    4136:	12 c0       	rjmp	.+36     	; 0x415c <chb_write+0x24c>
    4138:	89 e1       	ldi	r24, 0x19	; 25
    413a:	90 e0       	ldi	r25, 0x00	; 0
    413c:	8a 8f       	std	Y+26, r24	; 0x1a
    413e:	9b 8f       	std	Y+27, r25	; 0x1b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4140:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4142:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4144:	8c 01       	movw	r16, r24
    4146:	c8 01       	movw	r24, r16
    4148:	01 97       	sbiw	r24, 0x01	; 1
    414a:	f1 f7       	brne	.-4      	; 0x4148 <chb_write+0x238>
    414c:	8c 01       	movw	r16, r24
    414e:	0a 8f       	std	Y+26, r16	; 0x1a
    4150:	1b 8f       	std	Y+27, r17	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4152:	88 8d       	ldd	r24, Y+24	; 0x18
    4154:	99 8d       	ldd	r25, Y+25	; 0x19
    4156:	01 97       	sbiw	r24, 0x01	; 1
    4158:	88 8f       	std	Y+24, r24	; 0x18
    415a:	99 8f       	std	Y+25, r25	; 0x19
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    415c:	88 8d       	ldd	r24, Y+24	; 0x18
    415e:	99 8d       	ldd	r25, Y+25	; 0x19
    4160:	00 97       	sbiw	r24, 0x00	; 0
    4162:	51 f7       	brne	.-44     	; 0x4138 <chb_write+0x228>
    4164:	28 c0       	rjmp	.+80     	; 0x41b6 <chb_write+0x2a6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4166:	6c 89       	ldd	r22, Y+20	; 0x14
    4168:	7d 89       	ldd	r23, Y+21	; 0x15
    416a:	8e 89       	ldd	r24, Y+22	; 0x16
    416c:	9f 89       	ldd	r25, Y+23	; 0x17
    416e:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    4172:	dc 01       	movw	r26, r24
    4174:	cb 01       	movw	r24, r22
    4176:	88 8f       	std	Y+24, r24	; 0x18
    4178:	99 8f       	std	Y+25, r25	; 0x19
    417a:	88 8d       	ldd	r24, Y+24	; 0x18
    417c:	99 8d       	ldd	r25, Y+25	; 0x19
    417e:	8c 8f       	std	Y+28, r24	; 0x1c
    4180:	9d 8f       	std	Y+29, r25	; 0x1d
    4182:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4184:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4186:	8c 01       	movw	r16, r24
    4188:	c8 01       	movw	r24, r16
    418a:	01 97       	sbiw	r24, 0x01	; 1
    418c:	f1 f7       	brne	.-4      	; 0x418a <chb_write+0x27a>
    418e:	8c 01       	movw	r16, r24
    4190:	0c 8f       	std	Y+28, r16	; 0x1c
    4192:	1d 8f       	std	Y+29, r17	; 0x1d
    4194:	10 c0       	rjmp	.+32     	; 0x41b6 <chb_write+0x2a6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4196:	6b 85       	ldd	r22, Y+11	; 0x0b
    4198:	7c 85       	ldd	r23, Y+12	; 0x0c
    419a:	8d 85       	ldd	r24, Y+13	; 0x0d
    419c:	9e 85       	ldd	r25, Y+14	; 0x0e
    419e:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    41a2:	dc 01       	movw	r26, r24
    41a4:	cb 01       	movw	r24, r22
    41a6:	8f 87       	std	Y+15, r24	; 0x0f
    41a8:	8f 85       	ldd	r24, Y+15	; 0x0f
    41aa:	8e 8f       	std	Y+30, r24	; 0x1e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    41ac:	8e 8d       	ldd	r24, Y+30	; 0x1e
    41ae:	18 2f       	mov	r17, r24
    41b0:	1a 95       	dec	r17
    41b2:	f1 f7       	brne	.-4      	; 0x41b0 <chb_write+0x2a0>
    41b4:	1e 8f       	std	Y+30, r17	; 0x1e
			if(rtry==20) return status;;		//after 20 tries give up on sending the message	
    41b6:	8a 81       	ldd	r24, Y+2	; 0x02
    41b8:	9b 81       	ldd	r25, Y+3	; 0x03
    41ba:	84 31       	cpi	r24, 0x14	; 20
    41bc:	91 05       	cpc	r25, r1
    41be:	11 f4       	brne	.+4      	; 0x41c4 <chb_write+0x2b4>
    41c0:	8e 81       	ldd	r24, Y+6	; 0x06
    41c2:	27 c0       	rjmp	.+78     	; 0x4212 <chb_write+0x302>
		} while(status != CHB_SUCCESS);			
    41c4:	8e 81       	ldd	r24, Y+6	; 0x06
    41c6:	88 23       	and	r24, r24
    41c8:	09 f0       	breq	.+2      	; 0x41cc <chb_write+0x2bc>
    41ca:	d0 ce       	rjmp	.-608    	; 0x3f6c <chb_write+0x5c>
        // adjust len and restart
		frm_offset += frm_len;
    41cc:	99 81       	ldd	r25, Y+1	; 0x01
    41ce:	8c 81       	ldd	r24, Y+4	; 0x04
    41d0:	89 0f       	add	r24, r25
    41d2:	89 83       	std	Y+1, r24	; 0x01
        len = len - frm_len;
    41d4:	8c 81       	ldd	r24, Y+4	; 0x04
    41d6:	88 2f       	mov	r24, r24
    41d8:	90 e0       	ldi	r25, 0x00	; 0
    41da:	a0 e0       	ldi	r26, 0x00	; 0
    41dc:	b0 e0       	ldi	r27, 0x00	; 0
    41de:	2d a5       	lds	r18, 0x6d
    41e0:	3e a5       	lds	r19, 0x6e
    41e2:	4f a5       	lds	r20, 0x6f
    41e4:	58 a9       	sts	0x48, r21
    41e6:	79 01       	movw	r14, r18
    41e8:	8a 01       	movw	r16, r20
    41ea:	e8 1a       	sub	r14, r24
    41ec:	f9 0a       	sbc	r15, r25
    41ee:	0a 0b       	sbc	r16, r26
    41f0:	1b 0b       	sbc	r17, r27
    41f2:	d8 01       	movw	r26, r16
    41f4:	c7 01       	movw	r24, r14
    41f6:	8d a7       	lds	r24, 0x7d
    41f8:	9e a7       	lds	r25, 0x7e
    41fa:	af a7       	lds	r26, 0x7f
    41fc:	b8 ab       	sts	0x58, r27
{
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    41fe:	8d a5       	lds	r24, 0x6d
    4200:	9e a5       	lds	r25, 0x6e
    4202:	af a5       	lds	r26, 0x6f
    4204:	b8 a9       	sts	0x48, r27
    4206:	00 97       	sbiw	r24, 0x00	; 0
    4208:	a1 05       	cpc	r26, r1
    420a:	b1 05       	cpc	r27, r1
    420c:	09 f0       	breq	.+2      	; 0x4210 <chb_write+0x300>
    420e:	95 ce       	rjmp	.-726    	; 0x3f3a <chb_write+0x2a>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    4210:	80 e0       	ldi	r24, 0x00	; 0
}
    4212:	e0 96       	adiw	r28, 0x30	; 48
    4214:	cd bf       	out	0x3d, r28	; 61
    4216:	de bf       	out	0x3e, r29	; 62
    4218:	df 91       	pop	r29
    421a:	cf 91       	pop	r28
    421c:	1f 91       	pop	r17
    421e:	0f 91       	pop	r16
    4220:	ff 90       	pop	r15
    4222:	ef 90       	pop	r14
    4224:	08 95       	ret

00004226 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    4226:	cf 93       	push	r28
    4228:	df 93       	push	r29
    422a:	cd b7       	in	r28, 0x3d	; 61
    422c:	de b7       	in	r29, 0x3e	; 62
    422e:	27 97       	sbiw	r28, 0x07	; 7
    4230:	cd bf       	out	0x3d, r28	; 61
    4232:	de bf       	out	0x3e, r29	; 62
    4234:	8e 83       	std	Y+6, r24	; 0x06
    4236:	9f 83       	std	Y+7, r25	; 0x07
    U8 i, len, seq, *data_ptr;

    data_ptr = rx->data;
    4238:	8e 81       	ldd	r24, Y+6	; 0x06
    423a:	9f 81       	ldd	r25, Y+7	; 0x07
    423c:	05 96       	adiw	r24, 0x05	; 5
    423e:	8a 83       	std	Y+2, r24	; 0x02
    4240:	9b 83       	std	Y+3, r25	; 0x03

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    4242:	0e 94 e0 21 	call	0x43c0	; 0x43c0 <chb_buf_read>
    4246:	8c 83       	std	Y+4, r24	; 0x04
    4248:	8c 81       	ldd	r24, Y+4	; 0x04
    424a:	88 23       	and	r24, r24
    424c:	14 f4       	brge	.+4      	; 0x4252 <chb_read+0x2c>
    {
        return 0;
    424e:	80 e0       	ldi	r24, 0x00	; 0
    4250:	80 c0       	rjmp	.+256    	; 0x4352 <chb_read+0x12c>
    }
    *data_ptr++ = len;
    4252:	8a 81       	ldd	r24, Y+2	; 0x02
    4254:	9b 81       	ldd	r25, Y+3	; 0x03
    4256:	2c 81       	ldd	r18, Y+4	; 0x04
    4258:	fc 01       	movw	r30, r24
    425a:	20 83       	st	Z, r18
    425c:	8a 81       	ldd	r24, Y+2	; 0x02
    425e:	9b 81       	ldd	r25, Y+3	; 0x03
    4260:	01 96       	adiw	r24, 0x01	; 1
    4262:	8a 83       	std	Y+2, r24	; 0x02
    4264:	9b 83       	std	Y+3, r25	; 0x03

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    4266:	19 82       	std	Y+1, r1	; 0x01
    4268:	0f c0       	rjmp	.+30     	; 0x4288 <chb_read+0x62>
    {
        *data_ptr++ = chb_buf_read();
    426a:	0e 94 e0 21 	call	0x43c0	; 0x43c0 <chb_buf_read>
    426e:	28 2f       	mov	r18, r24
    4270:	8a 81       	ldd	r24, Y+2	; 0x02
    4272:	9b 81       	ldd	r25, Y+3	; 0x03
    4274:	fc 01       	movw	r30, r24
    4276:	20 83       	st	Z, r18
    4278:	8a 81       	ldd	r24, Y+2	; 0x02
    427a:	9b 81       	ldd	r25, Y+3	; 0x03
    427c:	01 96       	adiw	r24, 0x01	; 1
    427e:	8a 83       	std	Y+2, r24	; 0x02
    4280:	9b 83       	std	Y+3, r25	; 0x03
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    4282:	89 81       	ldd	r24, Y+1	; 0x01
    4284:	8f 5f       	subi	r24, 0xFF	; 255
    4286:	89 83       	std	Y+1, r24	; 0x01
    4288:	99 81       	ldd	r25, Y+1	; 0x01
    428a:	8c 81       	ldd	r24, Y+4	; 0x04
    428c:	98 17       	cp	r25, r24
    428e:	68 f3       	brcs	.-38     	; 0x426a <chb_read+0x44>
    // buffer as well to save resources.
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    4290:	8e 81       	ldd	r24, Y+6	; 0x06
    4292:	9f 81       	ldd	r25, Y+7	; 0x07
    4294:	08 96       	adiw	r24, 0x08	; 8
    4296:	8a 83       	std	Y+2, r24	; 0x02
    4298:	9b 83       	std	Y+3, r25	; 0x03
    seq = *data_ptr;
    429a:	8a 81       	ldd	r24, Y+2	; 0x02
    429c:	9b 81       	ldd	r25, Y+3	; 0x03
    429e:	fc 01       	movw	r30, r24
    42a0:	80 81       	ld	r24, Z
    42a2:	8d 83       	std	Y+5, r24	; 0x05

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    42a4:	8e 81       	ldd	r24, Y+6	; 0x06
    42a6:	9f 81       	ldd	r25, Y+7	; 0x07
    42a8:	0b 96       	adiw	r24, 0x0b	; 11
    42aa:	8a 83       	std	Y+2, r24	; 0x02
    42ac:	9b 83       	std	Y+3, r25	; 0x03
    rx->dest_addr = *(U16 *)data_ptr;
    42ae:	8a 81       	ldd	r24, Y+2	; 0x02
    42b0:	9b 81       	ldd	r25, Y+3	; 0x03
    42b2:	fc 01       	movw	r30, r24
    42b4:	20 81       	ld	r18, Z
    42b6:	31 81       	ldd	r19, Z+1	; 0x01
    42b8:	8e 81       	ldd	r24, Y+6	; 0x06
    42ba:	9f 81       	ldd	r25, Y+7	; 0x07
    42bc:	fc 01       	movw	r30, r24
    42be:	23 83       	std	Z+3, r18	; 0x03
    42c0:	34 83       	std	Z+4, r19	; 0x04
    data_ptr += sizeof(U16);
    42c2:	8a 81       	ldd	r24, Y+2	; 0x02
    42c4:	9b 81       	ldd	r25, Y+3	; 0x03
    42c6:	02 96       	adiw	r24, 0x02	; 2
    42c8:	8a 83       	std	Y+2, r24	; 0x02
    42ca:	9b 83       	std	Y+3, r25	; 0x03
    rx->src_addr = *(U16 *)data_ptr;
    42cc:	8a 81       	ldd	r24, Y+2	; 0x02
    42ce:	9b 81       	ldd	r25, Y+3	; 0x03
    42d0:	fc 01       	movw	r30, r24
    42d2:	20 81       	ld	r18, Z
    42d4:	31 81       	ldd	r19, Z+1	; 0x01
    42d6:	8e 81       	ldd	r24, Y+6	; 0x06
    42d8:	9f 81       	ldd	r25, Y+7	; 0x07
    42da:	fc 01       	movw	r30, r24
    42dc:	21 83       	std	Z+1, r18	; 0x01
    42de:	32 83       	std	Z+2, r19	; 0x02
    data_ptr += sizeof(U16);
    42e0:	8a 81       	ldd	r24, Y+2	; 0x02
    42e2:	9b 81       	ldd	r25, Y+3	; 0x03
    42e4:	02 96       	adiw	r24, 0x02	; 2
    42e6:	8a 83       	std	Y+2, r24	; 0x02
    42e8:	9b 83       	std	Y+3, r25	; 0x03

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    42ea:	0e 94 04 22 	call	0x4408	; 0x4408 <chb_buf_get_len>
    42ee:	88 23       	and	r24, r24
    42f0:	11 f4       	brne	.+4      	; 0x42f6 <chb_read+0xd0>
    {
        pcb.data_rcv = false;
    42f2:	10 92 2f 21 	sts	0x212F, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    42f6:	80 91 06 20 	lds	r24, 0x2006
    42fa:	9d 81       	ldd	r25, Y+5	; 0x05
    42fc:	98 17       	cp	r25, r24
    42fe:	71 f4       	brne	.+28     	; 0x431c <chb_read+0xf6>
    4300:	8e 81       	ldd	r24, Y+6	; 0x06
    4302:	9f 81       	ldd	r25, Y+7	; 0x07
    4304:	fc 01       	movw	r30, r24
    4306:	21 81       	ldd	r18, Z+1	; 0x01
    4308:	32 81       	ldd	r19, Z+2	; 0x02
    430a:	80 91 07 20 	lds	r24, 0x2007
    430e:	90 91 08 20 	lds	r25, 0x2008
    4312:	28 17       	cp	r18, r24
    4314:	39 07       	cpc	r19, r25
    4316:	11 f4       	brne	.+4      	; 0x431c <chb_read+0xf6>
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    4318:	80 e0       	ldi	r24, 0x00	; 0
    431a:	1b c0       	rjmp	.+54     	; 0x4352 <chb_read+0x12c>
    }
    else
    {
        prev_seq = seq;
    431c:	8d 81       	ldd	r24, Y+5	; 0x05
    431e:	80 93 06 20 	sts	0x2006, r24
        prev_src_addr = rx->src_addr;
    4322:	8e 81       	ldd	r24, Y+6	; 0x06
    4324:	9f 81       	ldd	r25, Y+7	; 0x07
    4326:	fc 01       	movw	r30, r24
    4328:	81 81       	ldd	r24, Z+1	; 0x01
    432a:	92 81       	ldd	r25, Z+2	; 0x02
    432c:	80 93 07 20 	sts	0x2007, r24
    4330:	90 93 08 20 	sts	0x2008, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    4334:	8c 81       	ldd	r24, Y+4	; 0x04
    4336:	88 2f       	mov	r24, r24
    4338:	90 e0       	ldi	r25, 0x00	; 0
    433a:	09 97       	sbiw	r24, 0x09	; 9
    433c:	9c 01       	movw	r18, r24
    433e:	8e 81       	ldd	r24, Y+6	; 0x06
    4340:	9f 81       	ldd	r25, Y+7	; 0x07
    4342:	4a 81       	ldd	r20, Y+2	; 0x02
    4344:	5b 81       	ldd	r21, Y+3	; 0x03
    4346:	ba 01       	movw	r22, r20
    4348:	a9 01       	movw	r20, r18
    434a:	0e 94 cd 63 	call	0xc79a	; 0xc79a <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    434e:	8c 81       	ldd	r24, Y+4	; 0x04
    4350:	8b 50       	subi	r24, 0x0B	; 11
#endif
}
    4352:	27 96       	adiw	r28, 0x07	; 7
    4354:	cd bf       	out	0x3d, r28	; 61
    4356:	de bf       	out	0x3e, r29	; 62
    4358:	df 91       	pop	r29
    435a:	cf 91       	pop	r28
    435c:	08 95       	ret

0000435e <chb_buf_init>:
/*!

*/
/**************************************************************************/
void chb_buf_init()
{
    435e:	cf 93       	push	r28
    4360:	df 93       	push	r29
    4362:	cd b7       	in	r28, 0x3d	; 61
    4364:	de b7       	in	r29, 0x3e	; 62
    rd_ptr = 0;
    4366:	10 92 c0 21 	sts	0x21C0, r1
    wr_ptr = 0;
    436a:	10 92 c1 21 	sts	0x21C1, r1
    len = 0;
    436e:	10 92 c2 21 	sts	0x21C2, r1
}
    4372:	df 91       	pop	r29
    4374:	cf 91       	pop	r28
    4376:	08 95       	ret

00004378 <chb_buf_write>:
/*!

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    4378:	cf 93       	push	r28
    437a:	df 93       	push	r29
    437c:	0f 92       	push	r0
    437e:	cd b7       	in	r28, 0x3d	; 61
    4380:	de b7       	in	r29, 0x3e	; 62
    4382:	89 83       	std	Y+1, r24	; 0x01
    chb_buf[wr_ptr] = data;
    4384:	80 91 c1 21 	lds	r24, 0x21C1
    4388:	88 2f       	mov	r24, r24
    438a:	90 e0       	ldi	r25, 0x00	; 0
    438c:	80 5c       	subi	r24, 0xC0	; 192
    438e:	9e 4d       	sbci	r25, 0xDE	; 222
    4390:	29 81       	ldd	r18, Y+1	; 0x01
    4392:	fc 01       	movw	r30, r24
    4394:	20 83       	st	Z, r18
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    4396:	80 91 c1 21 	lds	r24, 0x21C1
    439a:	88 2f       	mov	r24, r24
    439c:	90 e0       	ldi	r25, 0x00	; 0
    439e:	01 96       	adiw	r24, 0x01	; 1
    43a0:	20 e8       	ldi	r18, 0x80	; 128
    43a2:	30 e0       	ldi	r19, 0x00	; 0
    43a4:	b9 01       	movw	r22, r18
    43a6:	0e 94 3c 63 	call	0xc678	; 0xc678 <__divmodhi4>
    43aa:	80 93 c1 21 	sts	0x21C1, r24
    len++;
    43ae:	80 91 c2 21 	lds	r24, 0x21C2
    43b2:	8f 5f       	subi	r24, 0xFF	; 255
    43b4:	80 93 c2 21 	sts	0x21C2, r24
}
    43b8:	0f 90       	pop	r0
    43ba:	df 91       	pop	r29
    43bc:	cf 91       	pop	r28
    43be:	08 95       	ret

000043c0 <chb_buf_read>:
/*!

*/
/**************************************************************************/
U8 chb_buf_read()
{
    43c0:	cf 93       	push	r28
    43c2:	df 93       	push	r29
    43c4:	0f 92       	push	r0
    43c6:	cd b7       	in	r28, 0x3d	; 61
    43c8:	de b7       	in	r29, 0x3e	; 62
    U8 data;

    data = chb_buf[rd_ptr];
    43ca:	80 91 c0 21 	lds	r24, 0x21C0
    43ce:	88 2f       	mov	r24, r24
    43d0:	90 e0       	ldi	r25, 0x00	; 0
    43d2:	80 5c       	subi	r24, 0xC0	; 192
    43d4:	9e 4d       	sbci	r25, 0xDE	; 222
    43d6:	fc 01       	movw	r30, r24
    43d8:	80 81       	ld	r24, Z
    43da:	89 83       	std	Y+1, r24	; 0x01
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    43dc:	80 91 c0 21 	lds	r24, 0x21C0
    43e0:	88 2f       	mov	r24, r24
    43e2:	90 e0       	ldi	r25, 0x00	; 0
    43e4:	01 96       	adiw	r24, 0x01	; 1
    43e6:	20 e8       	ldi	r18, 0x80	; 128
    43e8:	30 e0       	ldi	r19, 0x00	; 0
    43ea:	b9 01       	movw	r22, r18
    43ec:	0e 94 3c 63 	call	0xc678	; 0xc678 <__divmodhi4>
    43f0:	80 93 c0 21 	sts	0x21C0, r24
    len--;
    43f4:	80 91 c2 21 	lds	r24, 0x21C2
    43f8:	81 50       	subi	r24, 0x01	; 1
    43fa:	80 93 c2 21 	sts	0x21C2, r24
    return data;
    43fe:	89 81       	ldd	r24, Y+1	; 0x01
}
    4400:	0f 90       	pop	r0
    4402:	df 91       	pop	r29
    4404:	cf 91       	pop	r28
    4406:	08 95       	ret

00004408 <chb_buf_get_len>:
/*!

*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    4408:	cf 93       	push	r28
    440a:	df 93       	push	r29
    440c:	cd b7       	in	r28, 0x3d	; 61
    440e:	de b7       	in	r29, 0x3e	; 62
    return len;
    4410:	80 91 c2 21 	lds	r24, 0x21C2
}
    4414:	df 91       	pop	r29
    4416:	cf 91       	pop	r28
    4418:	08 95       	ret

0000441a <chb_get_state>:
/*!

*/
/**************************************************************************/
static U8 chb_get_state()
{
    441a:	cf 93       	push	r28
    441c:	df 93       	push	r29
    441e:	cd b7       	in	r28, 0x3d	; 61
    4420:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATUS) & 0x1f;
    4422:	81 e0       	ldi	r24, 0x01	; 1
    4424:	0e 94 11 24 	call	0x4822	; 0x4822 <chb_reg_read>
    4428:	8f 71       	andi	r24, 0x1F	; 31
}
    442a:	df 91       	pop	r29
    442c:	cf 91       	pop	r28
    442e:	08 95       	ret

00004430 <chb_get_status>:
/*!

*/
/**************************************************************************/
static U8 chb_get_status()
{
    4430:	cf 93       	push	r28
    4432:	df 93       	push	r29
    4434:	cd b7       	in	r28, 0x3d	; 61
    4436:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    4438:	82 e0       	ldi	r24, 0x02	; 2
    443a:	0e 94 11 24 	call	0x4822	; 0x4822 <chb_reg_read>
    443e:	82 95       	swap	r24
    4440:	86 95       	lsr	r24
    4442:	87 70       	andi	r24, 0x07	; 7
}
    4444:	df 91       	pop	r29
    4446:	cf 91       	pop	r28
    4448:	08 95       	ret

0000444a <chb_reset>:
/*!

*/
/**************************************************************************/
void chb_reset()
{
    444a:	0f 93       	push	r16
    444c:	1f 93       	push	r17
    444e:	cf 93       	push	r28
    4450:	df 93       	push	r29
    4452:	cd b7       	in	r28, 0x3d	; 61
    4454:	de b7       	in	r29, 0x3e	; 62
    4456:	e0 97       	sbiw	r28, 0x30	; 48
    4458:	cd bf       	out	0x3d, r28	; 61
    445a:	de bf       	out	0x3e, r29	; 62
    CHB_RST_DISABLE();
    445c:	84 e6       	ldi	r24, 0x64	; 100
    445e:	96 e0       	ldi	r25, 0x06	; 6
    4460:	24 e6       	ldi	r18, 0x64	; 100
    4462:	36 e0       	ldi	r19, 0x06	; 6
    4464:	f9 01       	movw	r30, r18
    4466:	20 81       	ld	r18, Z
    4468:	21 60       	ori	r18, 0x01	; 1
    446a:	fc 01       	movw	r30, r24
    446c:	20 83       	st	Z, r18
    CHB_SLPTR_DISABLE();
    446e:	84 e6       	ldi	r24, 0x64	; 100
    4470:	96 e0       	ldi	r25, 0x06	; 6
    4472:	24 e6       	ldi	r18, 0x64	; 100
    4474:	36 e0       	ldi	r19, 0x06	; 6
    4476:	f9 01       	movw	r30, r18
    4478:	20 81       	ld	r18, Z
    447a:	2d 7f       	andi	r18, 0xFD	; 253
    447c:	fc 01       	movw	r30, r24
    447e:	20 83       	st	Z, r18
    4480:	80 e0       	ldi	r24, 0x00	; 0
    4482:	90 e0       	ldi	r25, 0x00	; 0
    4484:	ae eb       	ldi	r26, 0xBE	; 190
    4486:	b3 e4       	ldi	r27, 0x43	; 67
    4488:	89 83       	std	Y+1, r24	; 0x01
    448a:	9a 83       	std	Y+2, r25	; 0x02
    448c:	ab 83       	std	Y+3, r26	; 0x03
    448e:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4490:	69 81       	ldd	r22, Y+1	; 0x01
    4492:	7a 81       	ldd	r23, Y+2	; 0x02
    4494:	8b 81       	ldd	r24, Y+3	; 0x03
    4496:	9c 81       	ldd	r25, Y+4	; 0x04
    4498:	2b ea       	ldi	r18, 0xAB	; 171
    449a:	3a ea       	ldi	r19, 0xAA	; 170
    449c:	4a ea       	ldi	r20, 0xAA	; 170
    449e:	5e e3       	ldi	r21, 0x3E	; 62
    44a0:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    44a4:	dc 01       	movw	r26, r24
    44a6:	cb 01       	movw	r24, r22
    44a8:	8d 83       	std	Y+5, r24	; 0x05
    44aa:	9e 83       	std	Y+6, r25	; 0x06
    44ac:	af 83       	std	Y+7, r26	; 0x07
    44ae:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    44b0:	11 e0       	ldi	r17, 0x01	; 1
    44b2:	6d 81       	ldd	r22, Y+5	; 0x05
    44b4:	7e 81       	ldd	r23, Y+6	; 0x06
    44b6:	8f 81       	ldd	r24, Y+7	; 0x07
    44b8:	98 85       	ldd	r25, Y+8	; 0x08
    44ba:	20 e0       	ldi	r18, 0x00	; 0
    44bc:	30 e0       	ldi	r19, 0x00	; 0
    44be:	40 e8       	ldi	r20, 0x80	; 128
    44c0:	5f e3       	ldi	r21, 0x3F	; 63
    44c2:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    44c6:	88 23       	and	r24, r24
    44c8:	0c f0       	brlt	.+2      	; 0x44cc <chb_reset+0x82>
    44ca:	10 e0       	ldi	r17, 0x00	; 0
    44cc:	11 23       	and	r17, r17
    44ce:	19 f0       	breq	.+6      	; 0x44d6 <chb_reset+0x8c>
		__ticks = 1;
    44d0:	81 e0       	ldi	r24, 0x01	; 1
    44d2:	89 87       	std	Y+9, r24	; 0x09
    44d4:	a3 c0       	rjmp	.+326    	; 0x461c <chb_reset+0x1d2>
	else if (__tmp > 255)
    44d6:	11 e0       	ldi	r17, 0x01	; 1
    44d8:	6d 81       	ldd	r22, Y+5	; 0x05
    44da:	7e 81       	ldd	r23, Y+6	; 0x06
    44dc:	8f 81       	ldd	r24, Y+7	; 0x07
    44de:	98 85       	ldd	r25, Y+8	; 0x08
    44e0:	20 e0       	ldi	r18, 0x00	; 0
    44e2:	30 e0       	ldi	r19, 0x00	; 0
    44e4:	4f e7       	ldi	r20, 0x7F	; 127
    44e6:	53 e4       	ldi	r21, 0x43	; 67
    44e8:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    44ec:	18 16       	cp	r1, r24
    44ee:	0c f0       	brlt	.+2      	; 0x44f2 <chb_reset+0xa8>
    44f0:	10 e0       	ldi	r17, 0x00	; 0
    44f2:	11 23       	and	r17, r17
    44f4:	09 f4       	brne	.+2      	; 0x44f8 <chb_reset+0xae>
    44f6:	89 c0       	rjmp	.+274    	; 0x460a <chb_reset+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    44f8:	69 81       	ldd	r22, Y+1	; 0x01
    44fa:	7a 81       	ldd	r23, Y+2	; 0x02
    44fc:	8b 81       	ldd	r24, Y+3	; 0x03
    44fe:	9c 81       	ldd	r25, Y+4	; 0x04
    4500:	20 e0       	ldi	r18, 0x00	; 0
    4502:	30 e0       	ldi	r19, 0x00	; 0
    4504:	4a e7       	ldi	r20, 0x7A	; 122
    4506:	54 e4       	ldi	r21, 0x44	; 68
    4508:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
    450c:	dc 01       	movw	r26, r24
    450e:	cb 01       	movw	r24, r22
    4510:	8a 87       	std	Y+10, r24	; 0x0a
    4512:	9b 87       	std	Y+11, r25	; 0x0b
    4514:	ac 87       	std	Y+12, r26	; 0x0c
    4516:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4518:	6a 85       	ldd	r22, Y+10	; 0x0a
    451a:	7b 85       	ldd	r23, Y+11	; 0x0b
    451c:	8c 85       	ldd	r24, Y+12	; 0x0c
    451e:	9d 85       	ldd	r25, Y+13	; 0x0d
    4520:	20 e0       	ldi	r18, 0x00	; 0
    4522:	30 e0       	ldi	r19, 0x00	; 0
    4524:	4a e7       	ldi	r20, 0x7A	; 122
    4526:	53 e4       	ldi	r21, 0x43	; 67
    4528:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    452c:	dc 01       	movw	r26, r24
    452e:	cb 01       	movw	r24, r22
    4530:	8e 87       	std	Y+14, r24	; 0x0e
    4532:	9f 87       	std	Y+15, r25	; 0x0f
    4534:	a8 8b       	std	Y+16, r26	; 0x10
    4536:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    4538:	11 e0       	ldi	r17, 0x01	; 1
    453a:	6e 85       	ldd	r22, Y+14	; 0x0e
    453c:	7f 85       	ldd	r23, Y+15	; 0x0f
    453e:	88 89       	ldd	r24, Y+16	; 0x10
    4540:	99 89       	ldd	r25, Y+17	; 0x11
    4542:	20 e0       	ldi	r18, 0x00	; 0
    4544:	30 e0       	ldi	r19, 0x00	; 0
    4546:	40 e8       	ldi	r20, 0x80	; 128
    4548:	5f e3       	ldi	r21, 0x3F	; 63
    454a:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    454e:	88 23       	and	r24, r24
    4550:	0c f0       	brlt	.+2      	; 0x4554 <chb_reset+0x10a>
    4552:	10 e0       	ldi	r17, 0x00	; 0
    4554:	11 23       	and	r17, r17
    4556:	29 f0       	breq	.+10     	; 0x4562 <chb_reset+0x118>
		__ticks = 1;
    4558:	81 e0       	ldi	r24, 0x01	; 1
    455a:	90 e0       	ldi	r25, 0x00	; 0
    455c:	8a 8b       	std	Y+18, r24	; 0x12
    455e:	9b 8b       	std	Y+19, r25	; 0x13
    4560:	46 c0       	rjmp	.+140    	; 0x45ee <chb_reset+0x1a4>
	else if (__tmp > 65535)
    4562:	11 e0       	ldi	r17, 0x01	; 1
    4564:	6e 85       	ldd	r22, Y+14	; 0x0e
    4566:	7f 85       	ldd	r23, Y+15	; 0x0f
    4568:	88 89       	ldd	r24, Y+16	; 0x10
    456a:	99 89       	ldd	r25, Y+17	; 0x11
    456c:	20 e0       	ldi	r18, 0x00	; 0
    456e:	3f ef       	ldi	r19, 0xFF	; 255
    4570:	4f e7       	ldi	r20, 0x7F	; 127
    4572:	57 e4       	ldi	r21, 0x47	; 71
    4574:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    4578:	18 16       	cp	r1, r24
    457a:	0c f0       	brlt	.+2      	; 0x457e <chb_reset+0x134>
    457c:	10 e0       	ldi	r17, 0x00	; 0
    457e:	11 23       	and	r17, r17
    4580:	61 f1       	breq	.+88     	; 0x45da <chb_reset+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4582:	6a 85       	ldd	r22, Y+10	; 0x0a
    4584:	7b 85       	ldd	r23, Y+11	; 0x0b
    4586:	8c 85       	ldd	r24, Y+12	; 0x0c
    4588:	9d 85       	ldd	r25, Y+13	; 0x0d
    458a:	20 e0       	ldi	r18, 0x00	; 0
    458c:	30 e0       	ldi	r19, 0x00	; 0
    458e:	40 e2       	ldi	r20, 0x20	; 32
    4590:	51 e4       	ldi	r21, 0x41	; 65
    4592:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    4596:	dc 01       	movw	r26, r24
    4598:	cb 01       	movw	r24, r22
    459a:	bc 01       	movw	r22, r24
    459c:	cd 01       	movw	r24, r26
    459e:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    45a2:	dc 01       	movw	r26, r24
    45a4:	cb 01       	movw	r24, r22
    45a6:	8a 8b       	std	Y+18, r24	; 0x12
    45a8:	9b 8b       	std	Y+19, r25	; 0x13
    45aa:	12 c0       	rjmp	.+36     	; 0x45d0 <chb_reset+0x186>
    45ac:	89 e1       	ldi	r24, 0x19	; 25
    45ae:	90 e0       	ldi	r25, 0x00	; 0
    45b0:	8c 8b       	std	Y+20, r24	; 0x14
    45b2:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    45b4:	8c 89       	ldd	r24, Y+20	; 0x14
    45b6:	9d 89       	ldd	r25, Y+21	; 0x15
    45b8:	8c 01       	movw	r16, r24
    45ba:	c8 01       	movw	r24, r16
    45bc:	01 97       	sbiw	r24, 0x01	; 1
    45be:	f1 f7       	brne	.-4      	; 0x45bc <chb_reset+0x172>
    45c0:	8c 01       	movw	r16, r24
    45c2:	0c 8b       	std	Y+20, r16	; 0x14
    45c4:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    45c6:	8a 89       	ldd	r24, Y+18	; 0x12
    45c8:	9b 89       	ldd	r25, Y+19	; 0x13
    45ca:	01 97       	sbiw	r24, 0x01	; 1
    45cc:	8a 8b       	std	Y+18, r24	; 0x12
    45ce:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    45d0:	8a 89       	ldd	r24, Y+18	; 0x12
    45d2:	9b 89       	ldd	r25, Y+19	; 0x13
    45d4:	00 97       	sbiw	r24, 0x00	; 0
    45d6:	51 f7       	brne	.-44     	; 0x45ac <chb_reset+0x162>
    45d8:	28 c0       	rjmp	.+80     	; 0x462a <chb_reset+0x1e0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    45da:	6e 85       	ldd	r22, Y+14	; 0x0e
    45dc:	7f 85       	ldd	r23, Y+15	; 0x0f
    45de:	88 89       	ldd	r24, Y+16	; 0x10
    45e0:	99 89       	ldd	r25, Y+17	; 0x11
    45e2:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    45e6:	dc 01       	movw	r26, r24
    45e8:	cb 01       	movw	r24, r22
    45ea:	8a 8b       	std	Y+18, r24	; 0x12
    45ec:	9b 8b       	std	Y+19, r25	; 0x13
    45ee:	8a 89       	ldd	r24, Y+18	; 0x12
    45f0:	9b 89       	ldd	r25, Y+19	; 0x13
    45f2:	8e 8b       	std	Y+22, r24	; 0x16
    45f4:	9f 8b       	std	Y+23, r25	; 0x17
    45f6:	8e 89       	ldd	r24, Y+22	; 0x16
    45f8:	9f 89       	ldd	r25, Y+23	; 0x17
    45fa:	8c 01       	movw	r16, r24
    45fc:	f8 01       	movw	r30, r16
    45fe:	31 97       	sbiw	r30, 0x01	; 1
    4600:	f1 f7       	brne	.-4      	; 0x45fe <chb_reset+0x1b4>
    4602:	8f 01       	movw	r16, r30
    4604:	0e 8b       	std	Y+22, r16	; 0x16
    4606:	1f 8b       	std	Y+23, r17	; 0x17
    4608:	10 c0       	rjmp	.+32     	; 0x462a <chb_reset+0x1e0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    460a:	6d 81       	ldd	r22, Y+5	; 0x05
    460c:	7e 81       	ldd	r23, Y+6	; 0x06
    460e:	8f 81       	ldd	r24, Y+7	; 0x07
    4610:	98 85       	ldd	r25, Y+8	; 0x08
    4612:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    4616:	dc 01       	movw	r26, r24
    4618:	cb 01       	movw	r24, r22
    461a:	89 87       	std	Y+9, r24	; 0x09
    461c:	89 85       	ldd	r24, Y+9	; 0x09
    461e:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4620:	88 8d       	ldd	r24, Y+24	; 0x18
    4622:	18 2f       	mov	r17, r24
    4624:	1a 95       	dec	r17
    4626:	f1 f7       	brne	.-4      	; 0x4624 <chb_reset+0x1da>
    4628:	18 8f       	std	Y+24, r17	; 0x18

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    462a:	84 e6       	ldi	r24, 0x64	; 100
    462c:	96 e0       	ldi	r25, 0x06	; 6
    462e:	24 e6       	ldi	r18, 0x64	; 100
    4630:	36 e0       	ldi	r19, 0x06	; 6
    4632:	f9 01       	movw	r30, r18
    4634:	20 81       	ld	r18, Z
    4636:	2e 7f       	andi	r18, 0xFE	; 254
    4638:	fc 01       	movw	r30, r24
    463a:	20 83       	st	Z, r18
    463c:	80 e0       	ldi	r24, 0x00	; 0
    463e:	90 e0       	ldi	r25, 0x00	; 0
    4640:	a0 e8       	ldi	r26, 0x80	; 128
    4642:	bf e3       	ldi	r27, 0x3F	; 63
    4644:	89 8f       	std	Y+25, r24	; 0x19
    4646:	9a 8f       	std	Y+26, r25	; 0x1a
    4648:	ab 8f       	std	Y+27, r26	; 0x1b
    464a:	bc 8f       	std	Y+28, r27	; 0x1c
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    464c:	69 8d       	ldd	r22, Y+25	; 0x19
    464e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4650:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4652:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4654:	2b ea       	ldi	r18, 0xAB	; 171
    4656:	3a ea       	ldi	r19, 0xAA	; 170
    4658:	4a ea       	ldi	r20, 0xAA	; 170
    465a:	5e e3       	ldi	r21, 0x3E	; 62
    465c:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    4660:	dc 01       	movw	r26, r24
    4662:	cb 01       	movw	r24, r22
    4664:	8d 8f       	std	Y+29, r24	; 0x1d
    4666:	9e 8f       	std	Y+30, r25	; 0x1e
    4668:	af 8f       	std	Y+31, r26	; 0x1f
    466a:	b8 a3       	lds	r27, 0x58
	if (__tmp < 1.0)
    466c:	11 e0       	ldi	r17, 0x01	; 1
    466e:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4670:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4672:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4674:	98 a1       	lds	r25, 0x48
    4676:	20 e0       	ldi	r18, 0x00	; 0
    4678:	30 e0       	ldi	r19, 0x00	; 0
    467a:	40 e8       	ldi	r20, 0x80	; 128
    467c:	5f e3       	ldi	r21, 0x3F	; 63
    467e:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    4682:	88 23       	and	r24, r24
    4684:	0c f0       	brlt	.+2      	; 0x4688 <chb_reset+0x23e>
    4686:	10 e0       	ldi	r17, 0x00	; 0
    4688:	11 23       	and	r17, r17
    468a:	19 f0       	breq	.+6      	; 0x4692 <chb_reset+0x248>
		__ticks = 1;
    468c:	81 e0       	ldi	r24, 0x01	; 1
    468e:	89 a3       	lds	r24, 0x59
    4690:	a3 c0       	rjmp	.+326    	; 0x47d8 <chb_reset+0x38e>
	else if (__tmp > 255)
    4692:	11 e0       	ldi	r17, 0x01	; 1
    4694:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4696:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4698:	8f 8d       	ldd	r24, Y+31	; 0x1f
    469a:	98 a1       	lds	r25, 0x48
    469c:	20 e0       	ldi	r18, 0x00	; 0
    469e:	30 e0       	ldi	r19, 0x00	; 0
    46a0:	4f e7       	ldi	r20, 0x7F	; 127
    46a2:	53 e4       	ldi	r21, 0x43	; 67
    46a4:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    46a8:	18 16       	cp	r1, r24
    46aa:	0c f0       	brlt	.+2      	; 0x46ae <chb_reset+0x264>
    46ac:	10 e0       	ldi	r17, 0x00	; 0
    46ae:	11 23       	and	r17, r17
    46b0:	09 f4       	brne	.+2      	; 0x46b4 <chb_reset+0x26a>
    46b2:	89 c0       	rjmp	.+274    	; 0x47c6 <chb_reset+0x37c>
	{
		_delay_ms(__us / 1000.0);
    46b4:	69 8d       	ldd	r22, Y+25	; 0x19
    46b6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    46b8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    46ba:	9c 8d       	ldd	r25, Y+28	; 0x1c
    46bc:	20 e0       	ldi	r18, 0x00	; 0
    46be:	30 e0       	ldi	r19, 0x00	; 0
    46c0:	4a e7       	ldi	r20, 0x7A	; 122
    46c2:	54 e4       	ldi	r21, 0x44	; 68
    46c4:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
    46c8:	dc 01       	movw	r26, r24
    46ca:	cb 01       	movw	r24, r22
    46cc:	8a a3       	lds	r24, 0x5a
    46ce:	9b a3       	lds	r25, 0x5b
    46d0:	ac a3       	lds	r26, 0x5c
    46d2:	bd a3       	lds	r27, 0x5d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    46d4:	6a a1       	lds	r22, 0x4a
    46d6:	7b a1       	lds	r23, 0x4b
    46d8:	8c a1       	lds	r24, 0x4c
    46da:	9d a1       	lds	r25, 0x4d
    46dc:	20 e0       	ldi	r18, 0x00	; 0
    46de:	30 e0       	ldi	r19, 0x00	; 0
    46e0:	4a e7       	ldi	r20, 0x7A	; 122
    46e2:	53 e4       	ldi	r21, 0x43	; 67
    46e4:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    46e8:	dc 01       	movw	r26, r24
    46ea:	cb 01       	movw	r24, r22
    46ec:	8e a3       	lds	r24, 0x5e
    46ee:	9f a3       	lds	r25, 0x5f
    46f0:	a8 a7       	lds	r26, 0x78
    46f2:	b9 a7       	lds	r27, 0x79
	if (__tmp < 1.0)
    46f4:	11 e0       	ldi	r17, 0x01	; 1
    46f6:	6e a1       	lds	r22, 0x4e
    46f8:	7f a1       	lds	r23, 0x4f
    46fa:	88 a5       	lds	r24, 0x68
    46fc:	99 a5       	lds	r25, 0x69
    46fe:	20 e0       	ldi	r18, 0x00	; 0
    4700:	30 e0       	ldi	r19, 0x00	; 0
    4702:	40 e8       	ldi	r20, 0x80	; 128
    4704:	5f e3       	ldi	r21, 0x3F	; 63
    4706:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    470a:	88 23       	and	r24, r24
    470c:	0c f0       	brlt	.+2      	; 0x4710 <chb_reset+0x2c6>
    470e:	10 e0       	ldi	r17, 0x00	; 0
    4710:	11 23       	and	r17, r17
    4712:	29 f0       	breq	.+10     	; 0x471e <chb_reset+0x2d4>
		__ticks = 1;
    4714:	81 e0       	ldi	r24, 0x01	; 1
    4716:	90 e0       	ldi	r25, 0x00	; 0
    4718:	8a a7       	lds	r24, 0x7a
    471a:	9b a7       	lds	r25, 0x7b
    471c:	46 c0       	rjmp	.+140    	; 0x47aa <chb_reset+0x360>
	else if (__tmp > 65535)
    471e:	11 e0       	ldi	r17, 0x01	; 1
    4720:	6e a1       	lds	r22, 0x4e
    4722:	7f a1       	lds	r23, 0x4f
    4724:	88 a5       	lds	r24, 0x68
    4726:	99 a5       	lds	r25, 0x69
    4728:	20 e0       	ldi	r18, 0x00	; 0
    472a:	3f ef       	ldi	r19, 0xFF	; 255
    472c:	4f e7       	ldi	r20, 0x7F	; 127
    472e:	57 e4       	ldi	r21, 0x47	; 71
    4730:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    4734:	18 16       	cp	r1, r24
    4736:	0c f0       	brlt	.+2      	; 0x473a <chb_reset+0x2f0>
    4738:	10 e0       	ldi	r17, 0x00	; 0
    473a:	11 23       	and	r17, r17
    473c:	61 f1       	breq	.+88     	; 0x4796 <chb_reset+0x34c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    473e:	6a a1       	lds	r22, 0x4a
    4740:	7b a1       	lds	r23, 0x4b
    4742:	8c a1       	lds	r24, 0x4c
    4744:	9d a1       	lds	r25, 0x4d
    4746:	20 e0       	ldi	r18, 0x00	; 0
    4748:	30 e0       	ldi	r19, 0x00	; 0
    474a:	40 e2       	ldi	r20, 0x20	; 32
    474c:	51 e4       	ldi	r21, 0x41	; 65
    474e:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    4752:	dc 01       	movw	r26, r24
    4754:	cb 01       	movw	r24, r22
    4756:	bc 01       	movw	r22, r24
    4758:	cd 01       	movw	r24, r26
    475a:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    475e:	dc 01       	movw	r26, r24
    4760:	cb 01       	movw	r24, r22
    4762:	8a a7       	lds	r24, 0x7a
    4764:	9b a7       	lds	r25, 0x7b
    4766:	12 c0       	rjmp	.+36     	; 0x478c <chb_reset+0x342>
    4768:	89 e1       	ldi	r24, 0x19	; 25
    476a:	90 e0       	ldi	r25, 0x00	; 0
    476c:	8c a7       	lds	r24, 0x7c
    476e:	9d a7       	lds	r25, 0x7d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4770:	8c a5       	lds	r24, 0x6c
    4772:	9d a5       	lds	r25, 0x6d
    4774:	8c 01       	movw	r16, r24
    4776:	c8 01       	movw	r24, r16
    4778:	01 97       	sbiw	r24, 0x01	; 1
    477a:	f1 f7       	brne	.-4      	; 0x4778 <chb_reset+0x32e>
    477c:	8c 01       	movw	r16, r24
    477e:	0c a7       	lds	r16, 0x7c
    4780:	1d a7       	lds	r17, 0x7d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4782:	8a a5       	lds	r24, 0x6a
    4784:	9b a5       	lds	r25, 0x6b
    4786:	01 97       	sbiw	r24, 0x01	; 1
    4788:	8a a7       	lds	r24, 0x7a
    478a:	9b a7       	lds	r25, 0x7b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    478c:	8a a5       	lds	r24, 0x6a
    478e:	9b a5       	lds	r25, 0x6b
    4790:	00 97       	sbiw	r24, 0x00	; 0
    4792:	51 f7       	brne	.-44     	; 0x4768 <chb_reset+0x31e>
    4794:	28 c0       	rjmp	.+80     	; 0x47e6 <chb_reset+0x39c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4796:	6e a1       	lds	r22, 0x4e
    4798:	7f a1       	lds	r23, 0x4f
    479a:	88 a5       	lds	r24, 0x68
    479c:	99 a5       	lds	r25, 0x69
    479e:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    47a2:	dc 01       	movw	r26, r24
    47a4:	cb 01       	movw	r24, r22
    47a6:	8a a7       	lds	r24, 0x7a
    47a8:	9b a7       	lds	r25, 0x7b
    47aa:	8a a5       	lds	r24, 0x6a
    47ac:	9b a5       	lds	r25, 0x6b
    47ae:	8e a7       	lds	r24, 0x7e
    47b0:	9f a7       	lds	r25, 0x7f
    47b2:	8e a5       	lds	r24, 0x6e
    47b4:	9f a5       	lds	r25, 0x6f
    47b6:	8c 01       	movw	r16, r24
    47b8:	f8 01       	movw	r30, r16
    47ba:	31 97       	sbiw	r30, 0x01	; 1
    47bc:	f1 f7       	brne	.-4      	; 0x47ba <chb_reset+0x370>
    47be:	8f 01       	movw	r16, r30
    47c0:	0e a7       	lds	r16, 0x7e
    47c2:	1f a7       	lds	r17, 0x7f
    47c4:	10 c0       	rjmp	.+32     	; 0x47e6 <chb_reset+0x39c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    47c6:	6d 8d       	ldd	r22, Y+29	; 0x1d
    47c8:	7e 8d       	ldd	r23, Y+30	; 0x1e
    47ca:	8f 8d       	ldd	r24, Y+31	; 0x1f
    47cc:	98 a1       	lds	r25, 0x48
    47ce:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    47d2:	dc 01       	movw	r26, r24
    47d4:	cb 01       	movw	r24, r22
    47d6:	89 a3       	lds	r24, 0x59
    47d8:	89 a1       	lds	r24, 0x49
    47da:	88 ab       	sts	0x58, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    47dc:	88 a9       	sts	0x48, r24
    47de:	18 2f       	mov	r17, r24
    47e0:	1a 95       	dec	r17
    47e2:	f1 f7       	brne	.-4      	; 0x47e0 <chb_reset+0x396>
    47e4:	18 ab       	sts	0x58, r17
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    47e6:	84 e6       	ldi	r24, 0x64	; 100
    47e8:	96 e0       	ldi	r25, 0x06	; 6
    47ea:	24 e6       	ldi	r18, 0x64	; 100
    47ec:	36 e0       	ldi	r19, 0x06	; 6
    47ee:	f9 01       	movw	r30, r18
    47f0:	20 81       	ld	r18, Z
    47f2:	21 60       	ori	r18, 0x01	; 1
    47f4:	fc 01       	movw	r30, r24
    47f6:	20 83       	st	Z, r18
    47f8:	01 c0       	rjmp	.+2      	; 0x47fc <chb_reset+0x3b2>
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
        {
            break;
        }
    }
    47fa:	00 00       	nop
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    47fc:	8d e1       	ldi	r24, 0x1D	; 29
    47fe:	0e 94 11 24 	call	0x4822	; 0x4822 <chb_reg_read>
    4802:	81 30       	cpi	r24, 0x01	; 1
    4804:	d1 f7       	brne	.-12     	; 0x47fa <chb_reset+0x3b0>
    4806:	8c e1       	ldi	r24, 0x1C	; 28
    4808:	0e 94 11 24 	call	0x4822	; 0x4822 <chb_reg_read>
    480c:	87 30       	cpi	r24, 0x07	; 7
    480e:	a9 f7       	brne	.-22     	; 0x47fa <chb_reset+0x3b0>
        {
            break;
    4810:	00 00       	nop
        }
    }
	

}
    4812:	e0 96       	adiw	r28, 0x30	; 48
    4814:	cd bf       	out	0x3d, r28	; 61
    4816:	de bf       	out	0x3e, r29	; 62
    4818:	df 91       	pop	r29
    481a:	cf 91       	pop	r28
    481c:	1f 91       	pop	r17
    481e:	0f 91       	pop	r16
    4820:	08 95       	ret

00004822 <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    4822:	cf 93       	push	r28
    4824:	df 93       	push	r29
    4826:	0f 92       	push	r0
    4828:	0f 92       	push	r0
    482a:	cd b7       	in	r28, 0x3d	; 61
    482c:	de b7       	in	r29, 0x3e	; 62
    482e:	8a 83       	std	Y+2, r24	; 0x02
    U8 val = 0;
    4830:	19 82       	std	Y+1, r1	; 0x01

    /* Add the register read command to the register address. */
    addr |= 0x80;
    4832:	8a 81       	ldd	r24, Y+2	; 0x02
    4834:	80 68       	ori	r24, 0x80	; 128
    4836:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    4838:	8f e3       	ldi	r24, 0x3F	; 63
    483a:	90 e0       	ldi	r25, 0x00	; 0
    483c:	fc 01       	movw	r30, r24
    483e:	80 81       	ld	r24, Z
    4840:	80 93 43 40 	sts	0x4043, r24
    4844:	f8 94       	cli
    RadioCS(TRUE);
    4846:	81 e0       	ldi	r24, 0x01	; 1
    4848:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    484c:	8a 81       	ldd	r24, Y+2	; 0x02
    484e:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <SPID_write>
    4852:	89 83       	std	Y+1, r24	; 0x01
    val = SPID_write(val);
    4854:	89 81       	ldd	r24, Y+1	; 0x01
    4856:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <SPID_write>
    485a:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    485c:	80 e0       	ldi	r24, 0x00	; 0
    485e:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <RadioCS>
    CHB_LEAVE_CRIT();
    4862:	8f e3       	ldi	r24, 0x3F	; 63
    4864:	90 e0       	ldi	r25, 0x00	; 0
    4866:	20 91 43 40 	lds	r18, 0x4043
    486a:	fc 01       	movw	r30, r24
    486c:	20 83       	st	Z, r18
    486e:	78 94       	sei

    return val;
    4870:	89 81       	ldd	r24, Y+1	; 0x01
}
    4872:	0f 90       	pop	r0
    4874:	0f 90       	pop	r0
    4876:	df 91       	pop	r29
    4878:	cf 91       	pop	r28
    487a:	08 95       	ret

0000487c <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    487c:	cf 93       	push	r28
    487e:	df 93       	push	r29
    4880:	00 d0       	rcall	.+0      	; 0x4882 <chb_reg_read16+0x6>
    4882:	0f 92       	push	r0
    4884:	cd b7       	in	r28, 0x3d	; 61
    4886:	de b7       	in	r29, 0x3e	; 62
    4888:	8c 83       	std	Y+4, r24	; 0x04
    U8 i;
    U16 val = 0;
    488a:	1a 82       	std	Y+2, r1	; 0x02
    488c:	1b 82       	std	Y+3, r1	; 0x03

    for (i=0; i<2; i++)
    488e:	19 82       	std	Y+1, r1	; 0x01
    4890:	1d c0       	rjmp	.+58     	; 0x48cc <chb_reg_read16+0x50>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    4892:	9c 81       	ldd	r25, Y+4	; 0x04
    4894:	89 81       	ldd	r24, Y+1	; 0x01
    4896:	89 0f       	add	r24, r25
    4898:	0e 94 11 24 	call	0x4822	; 0x4822 <chb_reg_read>
    489c:	88 2f       	mov	r24, r24
    489e:	90 e0       	ldi	r25, 0x00	; 0
    48a0:	29 81       	ldd	r18, Y+1	; 0x01
    48a2:	22 2f       	mov	r18, r18
    48a4:	30 e0       	ldi	r19, 0x00	; 0
    48a6:	22 0f       	add	r18, r18
    48a8:	33 1f       	adc	r19, r19
    48aa:	22 0f       	add	r18, r18
    48ac:	33 1f       	adc	r19, r19
    48ae:	22 0f       	add	r18, r18
    48b0:	33 1f       	adc	r19, r19
    48b2:	02 2e       	mov	r0, r18
    48b4:	02 c0       	rjmp	.+4      	; 0x48ba <chb_reg_read16+0x3e>
    48b6:	88 0f       	add	r24, r24
    48b8:	99 1f       	adc	r25, r25
    48ba:	0a 94       	dec	r0
    48bc:	e2 f7       	brpl	.-8      	; 0x48b6 <chb_reg_read16+0x3a>
    48be:	98 2f       	mov	r25, r24
    48c0:	8c 81       	ldd	r24, Y+4	; 0x04
    48c2:	89 2b       	or	r24, r25
    48c4:	8c 83       	std	Y+4, r24	; 0x04
U16 chb_reg_read16(U8 addr)
{
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    48c6:	89 81       	ldd	r24, Y+1	; 0x01
    48c8:	8f 5f       	subi	r24, 0xFF	; 255
    48ca:	89 83       	std	Y+1, r24	; 0x01
    48cc:	89 81       	ldd	r24, Y+1	; 0x01
    48ce:	82 30       	cpi	r24, 0x02	; 2
    48d0:	00 f3       	brcs	.-64     	; 0x4892 <chb_reg_read16+0x16>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    }
    return val;
    48d2:	8a 81       	ldd	r24, Y+2	; 0x02
    48d4:	9b 81       	ldd	r25, Y+3	; 0x03
}
    48d6:	24 96       	adiw	r28, 0x04	; 4
    48d8:	cd bf       	out	0x3d, r28	; 61
    48da:	de bf       	out	0x3e, r29	; 62
    48dc:	df 91       	pop	r29
    48de:	cf 91       	pop	r28
    48e0:	08 95       	ret

000048e2 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    48e2:	cf 93       	push	r28
    48e4:	df 93       	push	r29
    48e6:	00 d0       	rcall	.+0      	; 0x48e8 <chb_reg_write+0x6>
    48e8:	cd b7       	in	r28, 0x3d	; 61
    48ea:	de b7       	in	r29, 0x3e	; 62
    48ec:	8a 83       	std	Y+2, r24	; 0x02
    48ee:	6b 83       	std	Y+3, r22	; 0x03
    U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;
    48f0:	8a 81       	ldd	r24, Y+2	; 0x02
    48f2:	80 6c       	ori	r24, 0xC0	; 192
    48f4:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    48f6:	8f e3       	ldi	r24, 0x3F	; 63
    48f8:	90 e0       	ldi	r25, 0x00	; 0
    48fa:	fc 01       	movw	r30, r24
    48fc:	80 81       	ld	r24, Z
    48fe:	80 93 43 40 	sts	0x4043, r24
    4902:	f8 94       	cli
    RadioCS(TRUE);
    4904:	81 e0       	ldi	r24, 0x01	; 1
    4906:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <RadioCS>

    /*Send Register address and write register content.*/
    dummy = SPID_write(addr);
    490a:	8a 81       	ldd	r24, Y+2	; 0x02
    490c:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <SPID_write>
    4910:	89 83       	std	Y+1, r24	; 0x01
    dummy = SPID_write(val);
    4912:	8b 81       	ldd	r24, Y+3	; 0x03
    4914:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <SPID_write>
    4918:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    491a:	80 e0       	ldi	r24, 0x00	; 0
    491c:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <RadioCS>
    CHB_LEAVE_CRIT();
    4920:	8f e3       	ldi	r24, 0x3F	; 63
    4922:	90 e0       	ldi	r25, 0x00	; 0
    4924:	20 91 43 40 	lds	r18, 0x4043
    4928:	fc 01       	movw	r30, r24
    492a:	20 83       	st	Z, r18
    492c:	78 94       	sei
}
    492e:	23 96       	adiw	r28, 0x03	; 3
    4930:	cd bf       	out	0x3d, r28	; 61
    4932:	de bf       	out	0x3e, r29	; 62
    4934:	df 91       	pop	r29
    4936:	cf 91       	pop	r28
    4938:	08 95       	ret

0000493a <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    493a:	cf 93       	push	r28
    493c:	df 93       	push	r29
    493e:	00 d0       	rcall	.+0      	; 0x4940 <chb_reg_write16+0x6>
    4940:	0f 92       	push	r0
    4942:	cd b7       	in	r28, 0x3d	; 61
    4944:	de b7       	in	r29, 0x3e	; 62
    4946:	8a 83       	std	Y+2, r24	; 0x02
    4948:	6b 83       	std	Y+3, r22	; 0x03
    494a:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<2; i++)
    494c:	19 82       	std	Y+1, r1	; 0x01
    494e:	1d c0       	rjmp	.+58     	; 0x498a <chb_reg_write16+0x50>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    4950:	9a 81       	ldd	r25, Y+2	; 0x02
    4952:	89 81       	ldd	r24, Y+1	; 0x01
    4954:	49 2f       	mov	r20, r25
    4956:	48 0f       	add	r20, r24
    4958:	89 81       	ldd	r24, Y+1	; 0x01
    495a:	88 2f       	mov	r24, r24
    495c:	90 e0       	ldi	r25, 0x00	; 0
    495e:	9c 01       	movw	r18, r24
    4960:	22 0f       	add	r18, r18
    4962:	33 1f       	adc	r19, r19
    4964:	22 0f       	add	r18, r18
    4966:	33 1f       	adc	r19, r19
    4968:	22 0f       	add	r18, r18
    496a:	33 1f       	adc	r19, r19
    496c:	8b 81       	ldd	r24, Y+3	; 0x03
    496e:	9c 81       	ldd	r25, Y+4	; 0x04
    4970:	02 c0       	rjmp	.+4      	; 0x4976 <chb_reg_write16+0x3c>
    4972:	96 95       	lsr	r25
    4974:	87 95       	ror	r24
    4976:	2a 95       	dec	r18
    4978:	e2 f7       	brpl	.-8      	; 0x4972 <chb_reg_write16+0x38>
    497a:	98 2f       	mov	r25, r24
    497c:	84 2f       	mov	r24, r20
    497e:	69 2f       	mov	r22, r25
    4980:	0e 94 71 24 	call	0x48e2	; 0x48e2 <chb_reg_write>
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    U8 i;

    for (i=0; i<2; i++)
    4984:	89 81       	ldd	r24, Y+1	; 0x01
    4986:	8f 5f       	subi	r24, 0xFF	; 255
    4988:	89 83       	std	Y+1, r24	; 0x01
    498a:	89 81       	ldd	r24, Y+1	; 0x01
    498c:	82 30       	cpi	r24, 0x02	; 2
    498e:	00 f3       	brcs	.-64     	; 0x4950 <chb_reg_write16+0x16>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    }
}
    4990:	24 96       	adiw	r28, 0x04	; 4
    4992:	cd bf       	out	0x3d, r28	; 61
    4994:	de bf       	out	0x3e, r29	; 62
    4996:	df 91       	pop	r29
    4998:	cf 91       	pop	r28
    499a:	08 95       	ret

0000499c <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    499c:	cf 93       	push	r28
    499e:	df 93       	push	r29
    49a0:	00 d0       	rcall	.+0      	; 0x49a2 <chb_reg_write64+0x6>
    49a2:	0f 92       	push	r0
    49a4:	cd b7       	in	r28, 0x3d	; 61
    49a6:	de b7       	in	r29, 0x3e	; 62
    49a8:	8a 83       	std	Y+2, r24	; 0x02
    49aa:	6b 83       	std	Y+3, r22	; 0x03
    49ac:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<8; i++)
    49ae:	19 82       	std	Y+1, r1	; 0x01
    49b0:	14 c0       	rjmp	.+40     	; 0x49da <chb_reg_write64+0x3e>
    {
        chb_reg_write(addr + i, *(val + i));
    49b2:	9a 81       	ldd	r25, Y+2	; 0x02
    49b4:	89 81       	ldd	r24, Y+1	; 0x01
    49b6:	49 2f       	mov	r20, r25
    49b8:	48 0f       	add	r20, r24
    49ba:	89 81       	ldd	r24, Y+1	; 0x01
    49bc:	88 2f       	mov	r24, r24
    49be:	90 e0       	ldi	r25, 0x00	; 0
    49c0:	2b 81       	ldd	r18, Y+3	; 0x03
    49c2:	3c 81       	ldd	r19, Y+4	; 0x04
    49c4:	82 0f       	add	r24, r18
    49c6:	93 1f       	adc	r25, r19
    49c8:	fc 01       	movw	r30, r24
    49ca:	90 81       	ld	r25, Z
    49cc:	84 2f       	mov	r24, r20
    49ce:	69 2f       	mov	r22, r25
    49d0:	0e 94 71 24 	call	0x48e2	; 0x48e2 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    49d4:	89 81       	ldd	r24, Y+1	; 0x01
    49d6:	8f 5f       	subi	r24, 0xFF	; 255
    49d8:	89 83       	std	Y+1, r24	; 0x01
    49da:	89 81       	ldd	r24, Y+1	; 0x01
    49dc:	88 30       	cpi	r24, 0x08	; 8
    49de:	48 f3       	brcs	.-46     	; 0x49b2 <chb_reg_write64+0x16>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    49e0:	24 96       	adiw	r28, 0x04	; 4
    49e2:	cd bf       	out	0x3d, r28	; 61
    49e4:	de bf       	out	0x3e, r29	; 62
    49e6:	df 91       	pop	r29
    49e8:	cf 91       	pop	r28
    49ea:	08 95       	ret

000049ec <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    49ec:	cf 93       	push	r28
    49ee:	df 93       	push	r29
    49f0:	00 d0       	rcall	.+0      	; 0x49f2 <chb_reg_read_mod_write+0x6>
    49f2:	0f 92       	push	r0
    49f4:	cd b7       	in	r28, 0x3d	; 61
    49f6:	de b7       	in	r29, 0x3e	; 62
    49f8:	8a 83       	std	Y+2, r24	; 0x02
    49fa:	6b 83       	std	Y+3, r22	; 0x03
    49fc:	4c 83       	std	Y+4, r20	; 0x04
    U8 tmp;

    tmp = chb_reg_read(addr);
    49fe:	8a 81       	ldd	r24, Y+2	; 0x02
    4a00:	0e 94 11 24 	call	0x4822	; 0x4822 <chb_reg_read>
    4a04:	89 83       	std	Y+1, r24	; 0x01
    val &= mask;                // mask off stray bits from val
    4a06:	9b 81       	ldd	r25, Y+3	; 0x03
    4a08:	8c 81       	ldd	r24, Y+4	; 0x04
    4a0a:	89 23       	and	r24, r25
    4a0c:	8b 83       	std	Y+3, r24	; 0x03
    tmp &= ~mask;               // mask off bits in reg val
    4a0e:	8c 81       	ldd	r24, Y+4	; 0x04
    4a10:	98 2f       	mov	r25, r24
    4a12:	90 95       	com	r25
    4a14:	89 81       	ldd	r24, Y+1	; 0x01
    4a16:	89 23       	and	r24, r25
    4a18:	89 83       	std	Y+1, r24	; 0x01
    tmp |= val;                 // copy val into reg val
    4a1a:	99 81       	ldd	r25, Y+1	; 0x01
    4a1c:	8b 81       	ldd	r24, Y+3	; 0x03
    4a1e:	89 2b       	or	r24, r25
    4a20:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(addr, tmp);   // write back to reg
    4a22:	8a 81       	ldd	r24, Y+2	; 0x02
    4a24:	69 81       	ldd	r22, Y+1	; 0x01
    4a26:	0e 94 71 24 	call	0x48e2	; 0x48e2 <chb_reg_write>
}
    4a2a:	24 96       	adiw	r28, 0x04	; 4
    4a2c:	cd bf       	out	0x3d, r28	; 61
    4a2e:	de bf       	out	0x3e, r29	; 62
    4a30:	df 91       	pop	r29
    4a32:	cf 91       	pop	r28
    4a34:	08 95       	ret

00004a36 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    4a36:	cf 93       	push	r28
    4a38:	df 93       	push	r29
    4a3a:	cd b7       	in	r28, 0x3d	; 61
    4a3c:	de b7       	in	r29, 0x3e	; 62
    4a3e:	28 97       	sbiw	r28, 0x08	; 8
    4a40:	cd bf       	out	0x3d, r28	; 61
    4a42:	de bf       	out	0x3e, r29	; 62
    4a44:	8b 83       	std	Y+3, r24	; 0x03
    4a46:	9c 83       	std	Y+4, r25	; 0x04
    4a48:	6d 83       	std	Y+5, r22	; 0x05
    4a4a:	4e 83       	std	Y+6, r20	; 0x06
    4a4c:	5f 83       	std	Y+7, r21	; 0x07
    4a4e:	28 87       	std	Y+8, r18	; 0x08
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    4a50:	8d 81       	ldd	r24, Y+5	; 0x05
    4a52:	28 2f       	mov	r18, r24
    4a54:	30 e0       	ldi	r19, 0x00	; 0
    4a56:	88 85       	ldd	r24, Y+8	; 0x08
    4a58:	88 2f       	mov	r24, r24
    4a5a:	90 e0       	ldi	r25, 0x00	; 0
    4a5c:	82 0f       	add	r24, r18
    4a5e:	93 1f       	adc	r25, r19
    4a60:	80 38       	cpi	r24, 0x80	; 128
    4a62:	91 05       	cpc	r25, r1
    4a64:	0c f0       	brlt	.+2      	; 0x4a68 <chb_frame_write+0x32>
    4a66:	45 c0       	rjmp	.+138    	; 0x4af2 <chb_frame_write+0xbc>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    4a68:	8f e3       	ldi	r24, 0x3F	; 63
    4a6a:	90 e0       	ldi	r25, 0x00	; 0
    4a6c:	fc 01       	movw	r30, r24
    4a6e:	80 81       	ld	r24, Z
    4a70:	80 93 43 40 	sts	0x4043, r24
    4a74:	f8 94       	cli
    RadioCS(TRUE); 
    4a76:	81 e0       	ldi	r24, 0x01	; 1
    4a78:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <RadioCS>

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);
    4a7c:	80 e6       	ldi	r24, 0x60	; 96
    4a7e:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <SPID_write>
    4a82:	8a 83       	std	Y+2, r24	; 0x02

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4a84:	19 82       	std	Y+1, r1	; 0x01
    4a86:	10 c0       	rjmp	.+32     	; 0x4aa8 <chb_frame_write+0x72>
    {
        dummy = SPID_write(*hdr++);
    4a88:	8b 81       	ldd	r24, Y+3	; 0x03
    4a8a:	9c 81       	ldd	r25, Y+4	; 0x04
    4a8c:	fc 01       	movw	r30, r24
    4a8e:	20 81       	ld	r18, Z
    4a90:	8b 81       	ldd	r24, Y+3	; 0x03
    4a92:	9c 81       	ldd	r25, Y+4	; 0x04
    4a94:	01 96       	adiw	r24, 0x01	; 1
    4a96:	8b 83       	std	Y+3, r24	; 0x03
    4a98:	9c 83       	std	Y+4, r25	; 0x04
    4a9a:	82 2f       	mov	r24, r18
    4a9c:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <SPID_write>
    4aa0:	8a 83       	std	Y+2, r24	; 0x02

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4aa2:	89 81       	ldd	r24, Y+1	; 0x01
    4aa4:	8f 5f       	subi	r24, 0xFF	; 255
    4aa6:	89 83       	std	Y+1, r24	; 0x01
    4aa8:	99 81       	ldd	r25, Y+1	; 0x01
    4aaa:	8d 81       	ldd	r24, Y+5	; 0x05
    4aac:	98 17       	cp	r25, r24
    4aae:	60 f3       	brcs	.-40     	; 0x4a88 <chb_frame_write+0x52>
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    4ab0:	19 82       	std	Y+1, r1	; 0x01
    4ab2:	10 c0       	rjmp	.+32     	; 0x4ad4 <chb_frame_write+0x9e>
    {
        dummy = SPID_write(*data++);
    4ab4:	8e 81       	ldd	r24, Y+6	; 0x06
    4ab6:	9f 81       	ldd	r25, Y+7	; 0x07
    4ab8:	fc 01       	movw	r30, r24
    4aba:	20 81       	ld	r18, Z
    4abc:	8e 81       	ldd	r24, Y+6	; 0x06
    4abe:	9f 81       	ldd	r25, Y+7	; 0x07
    4ac0:	01 96       	adiw	r24, 0x01	; 1
    4ac2:	8e 83       	std	Y+6, r24	; 0x06
    4ac4:	9f 83       	std	Y+7, r25	; 0x07
    4ac6:	82 2f       	mov	r24, r18
    4ac8:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <SPID_write>
    4acc:	8a 83       	std	Y+2, r24	; 0x02
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    4ace:	89 81       	ldd	r24, Y+1	; 0x01
    4ad0:	8f 5f       	subi	r24, 0xFF	; 255
    4ad2:	89 83       	std	Y+1, r24	; 0x01
    4ad4:	99 81       	ldd	r25, Y+1	; 0x01
    4ad6:	88 85       	ldd	r24, Y+8	; 0x08
    4ad8:	98 17       	cp	r25, r24
    4ada:	60 f3       	brcs	.-40     	; 0x4ab4 <chb_frame_write+0x7e>
    {
        dummy = SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    4adc:	80 e0       	ldi	r24, 0x00	; 0
    4ade:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <RadioCS>
    CHB_LEAVE_CRIT();
    4ae2:	8f e3       	ldi	r24, 0x3F	; 63
    4ae4:	90 e0       	ldi	r25, 0x00	; 0
    4ae6:	20 91 43 40 	lds	r18, 0x4043
    4aea:	fc 01       	movw	r30, r24
    4aec:	20 83       	st	Z, r18
    4aee:	78 94       	sei
    4af0:	01 c0       	rjmp	.+2      	; 0x4af4 <chb_frame_write+0xbe>
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    {
        return;
    4af2:	00 00       	nop
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    CHB_LEAVE_CRIT();
}
    4af4:	28 96       	adiw	r28, 0x08	; 8
    4af6:	cd bf       	out	0x3d, r28	; 61
    4af8:	de bf       	out	0x3e, r29	; 62
    4afa:	df 91       	pop	r29
    4afc:	cf 91       	pop	r28
    4afe:	08 95       	ret

00004b00 <chb_frame_read>:
/*!

*/
/**************************************************************************/
static void chb_frame_read()
{
    4b00:	0f 93       	push	r16
    4b02:	1f 93       	push	r17
    4b04:	cf 93       	push	r28
    4b06:	df 93       	push	r29
    4b08:	cd b7       	in	r28, 0x3d	; 61
    4b0a:	de b7       	in	r29, 0x3e	; 62
    4b0c:	e7 97       	sbiw	r28, 0x37	; 55
    4b0e:	cd bf       	out	0x3d, r28	; 61
    4b10:	de bf       	out	0x3e, r29	; 62
    U8 i, len, data;

    CHB_ENTER_CRIT();
    4b12:	8f e3       	ldi	r24, 0x3F	; 63
    4b14:	90 e0       	ldi	r25, 0x00	; 0
    4b16:	fc 01       	movw	r30, r24
    4b18:	80 81       	ld	r24, Z
    4b1a:	80 93 43 40 	sts	0x4043, r24
    4b1e:	f8 94       	cli
    RadioCS(TRUE);
    4b20:	81 e0       	ldi	r24, 0x01	; 1
    4b22:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    4b26:	80 e2       	ldi	r24, 0x20	; 32
    4b28:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <SPID_write>
    len = SPID_write(0);
    4b2c:	80 e0       	ldi	r24, 0x00	; 0
    4b2e:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <SPID_write>
    4b32:	8a 83       	std	Y+2, r24	; 0x02

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    4b34:	8a 81       	ldd	r24, Y+2	; 0x02
    4b36:	83 30       	cpi	r24, 0x03	; 3
    4b38:	08 f4       	brcc	.+2      	; 0x4b3c <chb_frame_read+0x3c>
    4b3a:	66 c0       	rjmp	.+204    	; 0x4c08 <chb_frame_read+0x108>
    4b3c:	8a 81       	ldd	r24, Y+2	; 0x02
    4b3e:	88 23       	and	r24, r24
    4b40:	0c f4       	brge	.+2      	; 0x4b44 <chb_frame_read+0x44>
    4b42:	62 c0       	rjmp	.+196    	; 0x4c08 <chb_frame_read+0x108>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    4b44:	8a 81       	ldd	r24, Y+2	; 0x02
    4b46:	08 2f       	mov	r16, r24
    4b48:	10 e0       	ldi	r17, 0x00	; 0
    4b4a:	0e 94 04 22 	call	0x4408	; 0x4408 <chb_buf_get_len>
    4b4e:	88 2f       	mov	r24, r24
    4b50:	90 e0       	ldi	r25, 0x00	; 0
    4b52:	20 e8       	ldi	r18, 0x80	; 128
    4b54:	30 e0       	ldi	r19, 0x00	; 0
    4b56:	a9 01       	movw	r20, r18
    4b58:	48 1b       	sub	r20, r24
    4b5a:	59 0b       	sbc	r21, r25
    4b5c:	ca 01       	movw	r24, r20
    4b5e:	08 17       	cp	r16, r24
    4b60:	19 07       	cpc	r17, r25
    4b62:	f4 f4       	brge	.+60     	; 0x4ba0 <chb_frame_read+0xa0>
        {
            chb_buf_write(len);
    4b64:	8a 81       	ldd	r24, Y+2	; 0x02
    4b66:	0e 94 bc 21 	call	0x4378	; 0x4378 <chb_buf_write>
            
            for (i=0; i<len; i++)
    4b6a:	19 82       	std	Y+1, r1	; 0x01
    4b6c:	0a c0       	rjmp	.+20     	; 0x4b82 <chb_frame_read+0x82>
            {
                data = SPID_write(0);
    4b6e:	80 e0       	ldi	r24, 0x00	; 0
    4b70:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <SPID_write>
    4b74:	8b 83       	std	Y+3, r24	; 0x03
                chb_buf_write(data);
    4b76:	8b 81       	ldd	r24, Y+3	; 0x03
    4b78:	0e 94 bc 21 	call	0x4378	; 0x4378 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    4b7c:	89 81       	ldd	r24, Y+1	; 0x01
    4b7e:	8f 5f       	subi	r24, 0xFF	; 255
    4b80:	89 83       	std	Y+1, r24	; 0x01
    4b82:	99 81       	ldd	r25, Y+1	; 0x01
    4b84:	8a 81       	ldd	r24, Y+2	; 0x02
    4b86:	98 17       	cp	r25, r24
    4b88:	90 f3       	brcs	.-28     	; 0x4b6e <chb_frame_read+0x6e>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    4b8a:	80 e8       	ldi	r24, 0x80	; 128
    4b8c:	96 e0       	ldi	r25, 0x06	; 6
    4b8e:	24 e0       	ldi	r18, 0x04	; 4
    4b90:	fc 01       	movw	r30, r24
    4b92:	25 83       	std	Z+5, r18	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    4b94:	80 e8       	ldi	r24, 0x80	; 128
    4b96:	96 e0       	ldi	r25, 0x06	; 6
    4b98:	24 e0       	ldi	r18, 0x04	; 4
    4b9a:	fc 01       	movw	r30, r24
    4b9c:	26 83       	std	Z+6, r18	; 0x06
    4b9e:	34 c0       	rjmp	.+104    	; 0x4c08 <chb_frame_read+0x108>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    4ba0:	0e 94 04 1f 	call	0x3e08	; 0x3e08 <chb_get_pcb>
    4ba4:	8c 83       	std	Y+4, r24	; 0x04
    4ba6:	9d 83       	std	Y+5, r25	; 0x05
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4ba8:	19 82       	std	Y+1, r1	; 0x01
    4baa:	07 c0       	rjmp	.+14     	; 0x4bba <chb_frame_read+0xba>
            {
                data = SPID_write(0);
    4bac:	80 e0       	ldi	r24, 0x00	; 0
    4bae:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <SPID_write>
    4bb2:	8b 83       	std	Y+3, r24	; 0x03
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4bb4:	89 81       	ldd	r24, Y+1	; 0x01
    4bb6:	8f 5f       	subi	r24, 0xFF	; 255
    4bb8:	89 83       	std	Y+1, r24	; 0x01
    4bba:	99 81       	ldd	r25, Y+1	; 0x01
    4bbc:	8a 81       	ldd	r24, Y+2	; 0x02
    4bbe:	98 17       	cp	r25, r24
    4bc0:	a8 f3       	brcs	.-22     	; 0x4bac <chb_frame_read+0xac>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    4bc2:	8c 81       	ldd	r24, Y+4	; 0x04
    4bc4:	9d 81       	ldd	r25, Y+5	; 0x05
    4bc6:	fc 01       	movw	r30, r24
    4bc8:	85 85       	ldd	r24, Z+13	; 0x0d
    4bca:	96 85       	ldd	r25, Z+14	; 0x0e
    4bcc:	9c 01       	movw	r18, r24
    4bce:	2f 5f       	subi	r18, 0xFF	; 255
    4bd0:	3f 4f       	sbci	r19, 0xFF	; 255
    4bd2:	8c 81       	ldd	r24, Y+4	; 0x04
    4bd4:	9d 81       	ldd	r25, Y+5	; 0x05
    4bd6:	fc 01       	movw	r30, r24
    4bd8:	25 87       	std	Z+13, r18	; 0x0d
    4bda:	36 87       	std	Z+14, r19	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    4bdc:	ce 01       	movw	r24, r28
    4bde:	06 96       	adiw	r24, 0x06	; 6
    4be0:	28 ee       	ldi	r18, 0xE8	; 232
    4be2:	31 e0       	ldi	r19, 0x01	; 1
    4be4:	b9 01       	movw	r22, r18
    4be6:	0e 94 bd 63 	call	0xc77a	; 0xc77a <strcpy_P>
            printf(buf);
    4bea:	0f 92       	push	r0
    4bec:	0f 92       	push	r0
    4bee:	8d b7       	in	r24, 0x3d	; 61
    4bf0:	9e b7       	in	r25, 0x3e	; 62
    4bf2:	01 96       	adiw	r24, 0x01	; 1
    4bf4:	9e 01       	movw	r18, r28
    4bf6:	2a 5f       	subi	r18, 0xFA	; 250
    4bf8:	3f 4f       	sbci	r19, 0xFF	; 255
    4bfa:	fc 01       	movw	r30, r24
    4bfc:	20 83       	st	Z, r18
    4bfe:	31 83       	std	Z+1, r19	; 0x01
    4c00:	0e 94 19 64 	call	0xc832	; 0xc832 <printf>
    4c04:	0f 90       	pop	r0
    4c06:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    4c08:	80 e0       	ldi	r24, 0x00	; 0
    4c0a:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <RadioCS>
    CHB_LEAVE_CRIT();
    4c0e:	8f e3       	ldi	r24, 0x3F	; 63
    4c10:	90 e0       	ldi	r25, 0x00	; 0
    4c12:	20 91 43 40 	lds	r18, 0x4043
    4c16:	fc 01       	movw	r30, r24
    4c18:	20 83       	st	Z, r18
    4c1a:	78 94       	sei
}
    4c1c:	e7 96       	adiw	r28, 0x37	; 55
    4c1e:	cd bf       	out	0x3d, r28	; 61
    4c20:	de bf       	out	0x3e, r29	; 62
    4c22:	df 91       	pop	r29
    4c24:	cf 91       	pop	r28
    4c26:	1f 91       	pop	r17
    4c28:	0f 91       	pop	r16
    4c2a:	08 95       	ret

00004c2c <chb_set_mode>:
/*!
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    4c2c:	cf 93       	push	r28
    4c2e:	df 93       	push	r29
    4c30:	0f 92       	push	r0
    4c32:	cd b7       	in	r28, 0x3d	; 61
    4c34:	de b7       	in	r29, 0x3e	; 62
    4c36:	89 83       	std	Y+1, r24	; 0x01
    switch (mode)
    4c38:	89 81       	ldd	r24, Y+1	; 0x01
    4c3a:	88 2f       	mov	r24, r24
    4c3c:	90 e0       	ldi	r25, 0x00	; 0
    4c3e:	81 30       	cpi	r24, 0x01	; 1
    4c40:	91 05       	cpc	r25, r1
    4c42:	c1 f0       	breq	.+48     	; 0x4c74 <chb_set_mode+0x48>
    4c44:	82 30       	cpi	r24, 0x02	; 2
    4c46:	91 05       	cpc	r25, r1
    4c48:	1c f4       	brge	.+6      	; 0x4c50 <chb_set_mode+0x24>
    4c4a:	00 97       	sbiw	r24, 0x00	; 0
    4c4c:	41 f0       	breq	.+16     	; 0x4c5e <chb_set_mode+0x32>
    4c4e:	33 c0       	rjmp	.+102    	; 0x4cb6 <chb_set_mode+0x8a>
    4c50:	82 30       	cpi	r24, 0x02	; 2
    4c52:	91 05       	cpc	r25, r1
    4c54:	d1 f0       	breq	.+52     	; 0x4c8a <chb_set_mode+0x5e>
    4c56:	83 30       	cpi	r24, 0x03	; 3
    4c58:	91 05       	cpc	r25, r1
    4c5a:	11 f1       	breq	.+68     	; 0x4ca0 <chb_set_mode+0x74>
    4c5c:	2c c0       	rjmp	.+88     	; 0x4cb6 <chb_set_mode+0x8a>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    4c5e:	8c e0       	ldi	r24, 0x0C	; 12
    4c60:	68 e0       	ldi	r22, 0x08	; 8
    4c62:	4f e3       	ldi	r20, 0x3F	; 63
    4c64:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4c68:	86 e1       	ldi	r24, 0x16	; 22
    4c6a:	62 e0       	ldi	r22, 0x02	; 2
    4c6c:	43 e0       	ldi	r20, 0x03	; 3
    4c6e:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>
        break;
    4c72:	21 c0       	rjmp	.+66     	; 0x4cb6 <chb_set_mode+0x8a>
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    4c74:	8c e0       	ldi	r24, 0x0C	; 12
    4c76:	6c e0       	ldi	r22, 0x0C	; 12
    4c78:	4f e3       	ldi	r20, 0x3F	; 63
    4c7a:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4c7e:	86 e1       	ldi	r24, 0x16	; 22
    4c80:	62 e0       	ldi	r22, 0x02	; 2
    4c82:	43 e0       	ldi	r20, 0x03	; 3
    4c84:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>
        break;
    4c88:	16 c0       	rjmp	.+44     	; 0x4cb6 <chb_set_mode+0x8a>
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    4c8a:	8c e0       	ldi	r24, 0x0C	; 12
    4c8c:	6c e1       	ldi	r22, 0x1C	; 28
    4c8e:	4f e3       	ldi	r20, 0x3F	; 63
    4c90:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4c94:	86 e1       	ldi	r24, 0x16	; 22
    4c96:	62 e0       	ldi	r22, 0x02	; 2
    4c98:	43 e0       	ldi	r20, 0x03	; 3
    4c9a:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>
        break;
    4c9e:	0b c0       	rjmp	.+22     	; 0x4cb6 <chb_set_mode+0x8a>
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    4ca0:	8c e0       	ldi	r24, 0x0C	; 12
    4ca2:	60 e0       	ldi	r22, 0x00	; 0
    4ca4:	4f e3       	ldi	r20, 0x3F	; 63
    4ca6:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    4caa:	86 e1       	ldi	r24, 0x16	; 22
    4cac:	63 e0       	ldi	r22, 0x03	; 3
    4cae:	43 e0       	ldi	r20, 0x03	; 3
    4cb0:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>
        break;
    4cb4:	00 00       	nop
    }
}
    4cb6:	0f 90       	pop	r0
    4cb8:	df 91       	pop	r29
    4cba:	cf 91       	pop	r28
    4cbc:	08 95       	ret

00004cbe <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    4cbe:	0f 93       	push	r16
    4cc0:	1f 93       	push	r17
    4cc2:	cf 93       	push	r28
    4cc4:	df 93       	push	r29
    4cc6:	cd b7       	in	r28, 0x3d	; 61
    4cc8:	de b7       	in	r29, 0x3e	; 62
    4cca:	6a 97       	sbiw	r28, 0x1a	; 26
    4ccc:	cd bf       	out	0x3d, r28	; 61
    4cce:	de bf       	out	0x3e, r29	; 62
    4cd0:	8a 8f       	std	Y+26, r24	; 0x1a
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    4cd2:	88 e0       	ldi	r24, 0x08	; 8
    4cd4:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4cd6:	4f e1       	ldi	r20, 0x1F	; 31
    4cd8:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    4cdc:	0e 94 0d 22 	call	0x441a	; 0x441a <chb_get_state>
    4ce0:	89 83       	std	Y+1, r24	; 0x01
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    4ce2:	89 81       	ldd	r24, Y+1	; 0x01
    4ce4:	86 30       	cpi	r24, 0x06	; 6
    4ce6:	21 f0       	breq	.+8      	; 0x4cf0 <chb_set_channel+0x32>
    4ce8:	89 81       	ldd	r24, Y+1	; 0x01
    4cea:	89 30       	cpi	r24, 0x09	; 9
    4cec:	09 f0       	breq	.+2      	; 0x4cf0 <chb_set_channel+0x32>
    4cee:	d5 c0       	rjmp	.+426    	; 0x4e9a <chb_set_channel+0x1dc>
    4cf0:	80 e0       	ldi	r24, 0x00	; 0
    4cf2:	90 e0       	ldi	r25, 0x00	; 0
    4cf4:	ac ed       	ldi	r26, 0xDC	; 220
    4cf6:	b2 e4       	ldi	r27, 0x42	; 66
    4cf8:	8a 83       	std	Y+2, r24	; 0x02
    4cfa:	9b 83       	std	Y+3, r25	; 0x03
    4cfc:	ac 83       	std	Y+4, r26	; 0x04
    4cfe:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4d00:	6a 81       	ldd	r22, Y+2	; 0x02
    4d02:	7b 81       	ldd	r23, Y+3	; 0x03
    4d04:	8c 81       	ldd	r24, Y+4	; 0x04
    4d06:	9d 81       	ldd	r25, Y+5	; 0x05
    4d08:	2b ea       	ldi	r18, 0xAB	; 171
    4d0a:	3a ea       	ldi	r19, 0xAA	; 170
    4d0c:	4a ea       	ldi	r20, 0xAA	; 170
    4d0e:	5e e3       	ldi	r21, 0x3E	; 62
    4d10:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    4d14:	dc 01       	movw	r26, r24
    4d16:	cb 01       	movw	r24, r22
    4d18:	8e 83       	std	Y+6, r24	; 0x06
    4d1a:	9f 83       	std	Y+7, r25	; 0x07
    4d1c:	a8 87       	std	Y+8, r26	; 0x08
    4d1e:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    4d20:	11 e0       	ldi	r17, 0x01	; 1
    4d22:	6e 81       	ldd	r22, Y+6	; 0x06
    4d24:	7f 81       	ldd	r23, Y+7	; 0x07
    4d26:	88 85       	ldd	r24, Y+8	; 0x08
    4d28:	99 85       	ldd	r25, Y+9	; 0x09
    4d2a:	20 e0       	ldi	r18, 0x00	; 0
    4d2c:	30 e0       	ldi	r19, 0x00	; 0
    4d2e:	40 e8       	ldi	r20, 0x80	; 128
    4d30:	5f e3       	ldi	r21, 0x3F	; 63
    4d32:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    4d36:	88 23       	and	r24, r24
    4d38:	0c f0       	brlt	.+2      	; 0x4d3c <chb_set_channel+0x7e>
    4d3a:	10 e0       	ldi	r17, 0x00	; 0
    4d3c:	11 23       	and	r17, r17
    4d3e:	19 f0       	breq	.+6      	; 0x4d46 <chb_set_channel+0x88>
		__ticks = 1;
    4d40:	81 e0       	ldi	r24, 0x01	; 1
    4d42:	8a 87       	std	Y+10, r24	; 0x0a
    4d44:	a3 c0       	rjmp	.+326    	; 0x4e8c <chb_set_channel+0x1ce>
	else if (__tmp > 255)
    4d46:	11 e0       	ldi	r17, 0x01	; 1
    4d48:	6e 81       	ldd	r22, Y+6	; 0x06
    4d4a:	7f 81       	ldd	r23, Y+7	; 0x07
    4d4c:	88 85       	ldd	r24, Y+8	; 0x08
    4d4e:	99 85       	ldd	r25, Y+9	; 0x09
    4d50:	20 e0       	ldi	r18, 0x00	; 0
    4d52:	30 e0       	ldi	r19, 0x00	; 0
    4d54:	4f e7       	ldi	r20, 0x7F	; 127
    4d56:	53 e4       	ldi	r21, 0x43	; 67
    4d58:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    4d5c:	18 16       	cp	r1, r24
    4d5e:	0c f0       	brlt	.+2      	; 0x4d62 <chb_set_channel+0xa4>
    4d60:	10 e0       	ldi	r17, 0x00	; 0
    4d62:	11 23       	and	r17, r17
    4d64:	09 f4       	brne	.+2      	; 0x4d68 <chb_set_channel+0xaa>
    4d66:	89 c0       	rjmp	.+274    	; 0x4e7a <chb_set_channel+0x1bc>
	{
		_delay_ms(__us / 1000.0);
    4d68:	6a 81       	ldd	r22, Y+2	; 0x02
    4d6a:	7b 81       	ldd	r23, Y+3	; 0x03
    4d6c:	8c 81       	ldd	r24, Y+4	; 0x04
    4d6e:	9d 81       	ldd	r25, Y+5	; 0x05
    4d70:	20 e0       	ldi	r18, 0x00	; 0
    4d72:	30 e0       	ldi	r19, 0x00	; 0
    4d74:	4a e7       	ldi	r20, 0x7A	; 122
    4d76:	54 e4       	ldi	r21, 0x44	; 68
    4d78:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
    4d7c:	dc 01       	movw	r26, r24
    4d7e:	cb 01       	movw	r24, r22
    4d80:	8b 87       	std	Y+11, r24	; 0x0b
    4d82:	9c 87       	std	Y+12, r25	; 0x0c
    4d84:	ad 87       	std	Y+13, r26	; 0x0d
    4d86:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4d88:	6b 85       	ldd	r22, Y+11	; 0x0b
    4d8a:	7c 85       	ldd	r23, Y+12	; 0x0c
    4d8c:	8d 85       	ldd	r24, Y+13	; 0x0d
    4d8e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4d90:	20 e0       	ldi	r18, 0x00	; 0
    4d92:	30 e0       	ldi	r19, 0x00	; 0
    4d94:	4a e7       	ldi	r20, 0x7A	; 122
    4d96:	53 e4       	ldi	r21, 0x43	; 67
    4d98:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    4d9c:	dc 01       	movw	r26, r24
    4d9e:	cb 01       	movw	r24, r22
    4da0:	8f 87       	std	Y+15, r24	; 0x0f
    4da2:	98 8b       	std	Y+16, r25	; 0x10
    4da4:	a9 8b       	std	Y+17, r26	; 0x11
    4da6:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    4da8:	11 e0       	ldi	r17, 0x01	; 1
    4daa:	6f 85       	ldd	r22, Y+15	; 0x0f
    4dac:	78 89       	ldd	r23, Y+16	; 0x10
    4dae:	89 89       	ldd	r24, Y+17	; 0x11
    4db0:	9a 89       	ldd	r25, Y+18	; 0x12
    4db2:	20 e0       	ldi	r18, 0x00	; 0
    4db4:	30 e0       	ldi	r19, 0x00	; 0
    4db6:	40 e8       	ldi	r20, 0x80	; 128
    4db8:	5f e3       	ldi	r21, 0x3F	; 63
    4dba:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    4dbe:	88 23       	and	r24, r24
    4dc0:	0c f0       	brlt	.+2      	; 0x4dc4 <chb_set_channel+0x106>
    4dc2:	10 e0       	ldi	r17, 0x00	; 0
    4dc4:	11 23       	and	r17, r17
    4dc6:	29 f0       	breq	.+10     	; 0x4dd2 <chb_set_channel+0x114>
		__ticks = 1;
    4dc8:	81 e0       	ldi	r24, 0x01	; 1
    4dca:	90 e0       	ldi	r25, 0x00	; 0
    4dcc:	8b 8b       	std	Y+19, r24	; 0x13
    4dce:	9c 8b       	std	Y+20, r25	; 0x14
    4dd0:	46 c0       	rjmp	.+140    	; 0x4e5e <chb_set_channel+0x1a0>
	else if (__tmp > 65535)
    4dd2:	11 e0       	ldi	r17, 0x01	; 1
    4dd4:	6f 85       	ldd	r22, Y+15	; 0x0f
    4dd6:	78 89       	ldd	r23, Y+16	; 0x10
    4dd8:	89 89       	ldd	r24, Y+17	; 0x11
    4dda:	9a 89       	ldd	r25, Y+18	; 0x12
    4ddc:	20 e0       	ldi	r18, 0x00	; 0
    4dde:	3f ef       	ldi	r19, 0xFF	; 255
    4de0:	4f e7       	ldi	r20, 0x7F	; 127
    4de2:	57 e4       	ldi	r21, 0x47	; 71
    4de4:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    4de8:	18 16       	cp	r1, r24
    4dea:	0c f0       	brlt	.+2      	; 0x4dee <chb_set_channel+0x130>
    4dec:	10 e0       	ldi	r17, 0x00	; 0
    4dee:	11 23       	and	r17, r17
    4df0:	61 f1       	breq	.+88     	; 0x4e4a <chb_set_channel+0x18c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4df2:	6b 85       	ldd	r22, Y+11	; 0x0b
    4df4:	7c 85       	ldd	r23, Y+12	; 0x0c
    4df6:	8d 85       	ldd	r24, Y+13	; 0x0d
    4df8:	9e 85       	ldd	r25, Y+14	; 0x0e
    4dfa:	20 e0       	ldi	r18, 0x00	; 0
    4dfc:	30 e0       	ldi	r19, 0x00	; 0
    4dfe:	40 e2       	ldi	r20, 0x20	; 32
    4e00:	51 e4       	ldi	r21, 0x41	; 65
    4e02:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    4e06:	dc 01       	movw	r26, r24
    4e08:	cb 01       	movw	r24, r22
    4e0a:	bc 01       	movw	r22, r24
    4e0c:	cd 01       	movw	r24, r26
    4e0e:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    4e12:	dc 01       	movw	r26, r24
    4e14:	cb 01       	movw	r24, r22
    4e16:	8b 8b       	std	Y+19, r24	; 0x13
    4e18:	9c 8b       	std	Y+20, r25	; 0x14
    4e1a:	12 c0       	rjmp	.+36     	; 0x4e40 <chb_set_channel+0x182>
    4e1c:	89 e1       	ldi	r24, 0x19	; 25
    4e1e:	90 e0       	ldi	r25, 0x00	; 0
    4e20:	8d 8b       	std	Y+21, r24	; 0x15
    4e22:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4e24:	8d 89       	ldd	r24, Y+21	; 0x15
    4e26:	9e 89       	ldd	r25, Y+22	; 0x16
    4e28:	8c 01       	movw	r16, r24
    4e2a:	c8 01       	movw	r24, r16
    4e2c:	01 97       	sbiw	r24, 0x01	; 1
    4e2e:	f1 f7       	brne	.-4      	; 0x4e2c <chb_set_channel+0x16e>
    4e30:	8c 01       	movw	r16, r24
    4e32:	0d 8b       	std	Y+21, r16	; 0x15
    4e34:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4e36:	8b 89       	ldd	r24, Y+19	; 0x13
    4e38:	9c 89       	ldd	r25, Y+20	; 0x14
    4e3a:	01 97       	sbiw	r24, 0x01	; 1
    4e3c:	8b 8b       	std	Y+19, r24	; 0x13
    4e3e:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4e40:	8b 89       	ldd	r24, Y+19	; 0x13
    4e42:	9c 89       	ldd	r25, Y+20	; 0x14
    4e44:	00 97       	sbiw	r24, 0x00	; 0
    4e46:	51 f7       	brne	.-44     	; 0x4e1c <chb_set_channel+0x15e>
    4e48:	28 c0       	rjmp	.+80     	; 0x4e9a <chb_set_channel+0x1dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4e4a:	6f 85       	ldd	r22, Y+15	; 0x0f
    4e4c:	78 89       	ldd	r23, Y+16	; 0x10
    4e4e:	89 89       	ldd	r24, Y+17	; 0x11
    4e50:	9a 89       	ldd	r25, Y+18	; 0x12
    4e52:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    4e56:	dc 01       	movw	r26, r24
    4e58:	cb 01       	movw	r24, r22
    4e5a:	8b 8b       	std	Y+19, r24	; 0x13
    4e5c:	9c 8b       	std	Y+20, r25	; 0x14
    4e5e:	8b 89       	ldd	r24, Y+19	; 0x13
    4e60:	9c 89       	ldd	r25, Y+20	; 0x14
    4e62:	8f 8b       	std	Y+23, r24	; 0x17
    4e64:	98 8f       	std	Y+24, r25	; 0x18
    4e66:	8f 89       	ldd	r24, Y+23	; 0x17
    4e68:	98 8d       	ldd	r25, Y+24	; 0x18
    4e6a:	8c 01       	movw	r16, r24
    4e6c:	c8 01       	movw	r24, r16
    4e6e:	01 97       	sbiw	r24, 0x01	; 1
    4e70:	f1 f7       	brne	.-4      	; 0x4e6e <chb_set_channel+0x1b0>
    4e72:	8c 01       	movw	r16, r24
    4e74:	0f 8b       	std	Y+23, r16	; 0x17
    4e76:	18 8f       	std	Y+24, r17	; 0x18
    4e78:	10 c0       	rjmp	.+32     	; 0x4e9a <chb_set_channel+0x1dc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4e7a:	6e 81       	ldd	r22, Y+6	; 0x06
    4e7c:	7f 81       	ldd	r23, Y+7	; 0x07
    4e7e:	88 85       	ldd	r24, Y+8	; 0x08
    4e80:	99 85       	ldd	r25, Y+9	; 0x09
    4e82:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    4e86:	dc 01       	movw	r26, r24
    4e88:	cb 01       	movw	r24, r22
    4e8a:	8a 87       	std	Y+10, r24	; 0x0a
    4e8c:	8a 85       	ldd	r24, Y+10	; 0x0a
    4e8e:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4e90:	89 8d       	ldd	r24, Y+25	; 0x19
    4e92:	18 2f       	mov	r17, r24
    4e94:	1a 95       	dec	r17
    4e96:	f1 f7       	brne	.-4      	; 0x4e94 <chb_set_channel+0x1d6>
    4e98:	19 8f       	std	Y+25, r17	; 0x19
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    4e9a:	88 e0       	ldi	r24, 0x08	; 8
    4e9c:	0e 94 11 24 	call	0x4822	; 0x4822 <chb_reg_read>
    4ea0:	88 2f       	mov	r24, r24
    4ea2:	90 e0       	ldi	r25, 0x00	; 0
    4ea4:	9c 01       	movw	r18, r24
    4ea6:	2f 71       	andi	r18, 0x1F	; 31
    4ea8:	30 70       	andi	r19, 0x00	; 0
    4eaa:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4eac:	88 2f       	mov	r24, r24
    4eae:	90 e0       	ldi	r25, 0x00	; 0
    4eb0:	28 17       	cp	r18, r24
    4eb2:	39 07       	cpc	r19, r25
    4eb4:	11 f4       	brne	.+4      	; 0x4eba <chb_set_channel+0x1fc>
    4eb6:	80 e4       	ldi	r24, 0x40	; 64
    4eb8:	01 c0       	rjmp	.+2      	; 0x4ebc <chb_set_channel+0x1fe>
    4eba:	83 e4       	ldi	r24, 0x43	; 67
}
    4ebc:	6a 96       	adiw	r28, 0x1a	; 26
    4ebe:	cd bf       	out	0x3d, r28	; 61
    4ec0:	de bf       	out	0x3e, r29	; 62
    4ec2:	df 91       	pop	r29
    4ec4:	cf 91       	pop	r28
    4ec6:	1f 91       	pop	r17
    4ec8:	0f 91       	pop	r16
    4eca:	08 95       	ret

00004ecc <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    4ecc:	cf 93       	push	r28
    4ece:	df 93       	push	r29
    4ed0:	0f 92       	push	r0
    4ed2:	cd b7       	in	r28, 0x3d	; 61
    4ed4:	de b7       	in	r29, 0x3e	; 62
    4ed6:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(PHY_TX_PWR, val);
    4ed8:	85 e0       	ldi	r24, 0x05	; 5
    4eda:	69 81       	ldd	r22, Y+1	; 0x01
    4edc:	0e 94 71 24 	call	0x48e2	; 0x48e2 <chb_reg_write>
}
    4ee0:	0f 90       	pop	r0
    4ee2:	df 91       	pop	r29
    4ee4:	cf 91       	pop	r28
    4ee6:	08 95       	ret

00004ee8 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    4ee8:	0f 93       	push	r16
    4eea:	1f 93       	push	r17
    4eec:	cf 93       	push	r28
    4eee:	df 93       	push	r29
    4ef0:	cd b7       	in	r28, 0x3d	; 61
    4ef2:	de b7       	in	r29, 0x3e	; 62
    4ef4:	c2 56       	subi	r28, 0x62	; 98
    4ef6:	d0 40       	sbci	r29, 0x00	; 0
    4ef8:	cd bf       	out	0x3d, r28	; 61
    4efa:	de bf       	out	0x3e, r29	; 62
    4efc:	9e 01       	movw	r18, r28
    4efe:	2e 59       	subi	r18, 0x9E	; 158
    4f00:	3f 4f       	sbci	r19, 0xFF	; 255
    4f02:	f9 01       	movw	r30, r18
    4f04:	80 83       	st	Z, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    4f06:	84 e6       	ldi	r24, 0x64	; 100
    4f08:	96 e0       	ldi	r25, 0x06	; 6
    4f0a:	fc 01       	movw	r30, r24
    4f0c:	80 81       	ld	r24, Z
    4f0e:	88 2f       	mov	r24, r24
    4f10:	90 e0       	ldi	r25, 0x00	; 0
    4f12:	82 70       	andi	r24, 0x02	; 2
    4f14:	90 70       	andi	r25, 0x00	; 0
    4f16:	00 97       	sbiw	r24, 0x00	; 0
    4f18:	11 f0       	breq	.+4      	; 0x4f1e <chb_set_state+0x36>
    {
        return RADIO_WRONG_STATE;
    4f1a:	84 e4       	ldi	r24, 0x44	; 68
    4f1c:	91 c4       	rjmp	.+2338   	; 0x5840 <chb_set_state+0x958>
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    4f1e:	0e 94 0d 22 	call	0x441a	; 0x441a <chb_get_state>
    4f22:	89 83       	std	Y+1, r24	; 0x01
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    4f24:	89 81       	ldd	r24, Y+1	; 0x01
    4f26:	82 31       	cpi	r24, 0x12	; 18
    4f28:	49 f0       	breq	.+18     	; 0x4f3c <chb_set_state+0x54>
    4f2a:	89 81       	ldd	r24, Y+1	; 0x01
    4f2c:	81 31       	cpi	r24, 0x11	; 17
    4f2e:	31 f0       	breq	.+12     	; 0x4f3c <chb_set_state+0x54>
    4f30:	89 81       	ldd	r24, Y+1	; 0x01
    4f32:	81 30       	cpi	r24, 0x01	; 1
    4f34:	19 f0       	breq	.+6      	; 0x4f3c <chb_set_state+0x54>
    4f36:	89 81       	ldd	r24, Y+1	; 0x01
    4f38:	82 30       	cpi	r24, 0x02	; 2
    4f3a:	39 f4       	brne	.+14     	; 0x4f4a <chb_set_state+0x62>
    {
        while (chb_get_state() == curr_state);
    4f3c:	00 00       	nop
    4f3e:	0e 94 0d 22 	call	0x441a	; 0x441a <chb_get_state>
    4f42:	98 2f       	mov	r25, r24
    4f44:	89 81       	ldd	r24, Y+1	; 0x01
    4f46:	98 17       	cp	r25, r24
    4f48:	d1 f3       	breq	.-12     	; 0x4f3e <chb_set_state+0x56>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    4f4a:	ce 01       	movw	r24, r28
    4f4c:	8e 59       	subi	r24, 0x9E	; 158
    4f4e:	9f 4f       	sbci	r25, 0xFF	; 255
    4f50:	fc 01       	movw	r30, r24
    4f52:	80 81       	ld	r24, Z
    4f54:	88 2f       	mov	r24, r24
    4f56:	90 e0       	ldi	r25, 0x00	; 0
    4f58:	86 31       	cpi	r24, 0x16	; 22
    4f5a:	91 05       	cpc	r25, r1
    4f5c:	09 f4       	brne	.+2      	; 0x4f60 <chb_set_state+0x78>
    4f5e:	cd c1       	rjmp	.+922    	; 0x52fa <chb_set_state+0x412>
    4f60:	89 31       	cpi	r24, 0x19	; 25
    4f62:	91 05       	cpc	r25, r1
    4f64:	09 f4       	brne	.+2      	; 0x4f68 <chb_set_state+0x80>
    4f66:	e9 c0       	rjmp	.+466    	; 0x513a <chb_set_state+0x252>
    4f68:	88 30       	cpi	r24, 0x08	; 8
    4f6a:	91 05       	cpc	r25, r1
    4f6c:	09 f0       	breq	.+2      	; 0x4f70 <chb_set_state+0x88>
    4f6e:	f7 c2       	rjmp	.+1518   	; 0x555e <chb_set_state+0x676>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    4f70:	84 e6       	ldi	r24, 0x64	; 100
    4f72:	96 e0       	ldi	r25, 0x06	; 6
    4f74:	24 e6       	ldi	r18, 0x64	; 100
    4f76:	36 e0       	ldi	r19, 0x06	; 6
    4f78:	f9 01       	movw	r30, r18
    4f7a:	20 81       	ld	r18, Z
    4f7c:	2d 7f       	andi	r18, 0xFD	; 253
    4f7e:	fc 01       	movw	r30, r24
    4f80:	20 83       	st	Z, r18
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    4f82:	82 e0       	ldi	r24, 0x02	; 2
    4f84:	63 e0       	ldi	r22, 0x03	; 3
    4f86:	4f e1       	ldi	r20, 0x1F	; 31
    4f88:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>
    4f8c:	80 e0       	ldi	r24, 0x00	; 0
    4f8e:	90 e0       	ldi	r25, 0x00	; 0
    4f90:	a0 e8       	ldi	r26, 0x80	; 128
    4f92:	bf e3       	ldi	r27, 0x3F	; 63
    4f94:	8a 83       	std	Y+2, r24	; 0x02
    4f96:	9b 83       	std	Y+3, r25	; 0x03
    4f98:	ac 83       	std	Y+4, r26	; 0x04
    4f9a:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4f9c:	6a 81       	ldd	r22, Y+2	; 0x02
    4f9e:	7b 81       	ldd	r23, Y+3	; 0x03
    4fa0:	8c 81       	ldd	r24, Y+4	; 0x04
    4fa2:	9d 81       	ldd	r25, Y+5	; 0x05
    4fa4:	2b ea       	ldi	r18, 0xAB	; 171
    4fa6:	3a ea       	ldi	r19, 0xAA	; 170
    4fa8:	4a ea       	ldi	r20, 0xAA	; 170
    4faa:	5e e3       	ldi	r21, 0x3E	; 62
    4fac:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    4fb0:	dc 01       	movw	r26, r24
    4fb2:	cb 01       	movw	r24, r22
    4fb4:	8e 83       	std	Y+6, r24	; 0x06
    4fb6:	9f 83       	std	Y+7, r25	; 0x07
    4fb8:	a8 87       	std	Y+8, r26	; 0x08
    4fba:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    4fbc:	11 e0       	ldi	r17, 0x01	; 1
    4fbe:	6e 81       	ldd	r22, Y+6	; 0x06
    4fc0:	7f 81       	ldd	r23, Y+7	; 0x07
    4fc2:	88 85       	ldd	r24, Y+8	; 0x08
    4fc4:	99 85       	ldd	r25, Y+9	; 0x09
    4fc6:	20 e0       	ldi	r18, 0x00	; 0
    4fc8:	30 e0       	ldi	r19, 0x00	; 0
    4fca:	40 e8       	ldi	r20, 0x80	; 128
    4fcc:	5f e3       	ldi	r21, 0x3F	; 63
    4fce:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    4fd2:	88 23       	and	r24, r24
    4fd4:	0c f0       	brlt	.+2      	; 0x4fd8 <chb_set_state+0xf0>
    4fd6:	10 e0       	ldi	r17, 0x00	; 0
    4fd8:	11 23       	and	r17, r17
    4fda:	19 f0       	breq	.+6      	; 0x4fe2 <chb_set_state+0xfa>
		__ticks = 1;
    4fdc:	81 e0       	ldi	r24, 0x01	; 1
    4fde:	8a 87       	std	Y+10, r24	; 0x0a
    4fe0:	a3 c0       	rjmp	.+326    	; 0x5128 <chb_set_state+0x240>
	else if (__tmp > 255)
    4fe2:	11 e0       	ldi	r17, 0x01	; 1
    4fe4:	6e 81       	ldd	r22, Y+6	; 0x06
    4fe6:	7f 81       	ldd	r23, Y+7	; 0x07
    4fe8:	88 85       	ldd	r24, Y+8	; 0x08
    4fea:	99 85       	ldd	r25, Y+9	; 0x09
    4fec:	20 e0       	ldi	r18, 0x00	; 0
    4fee:	30 e0       	ldi	r19, 0x00	; 0
    4ff0:	4f e7       	ldi	r20, 0x7F	; 127
    4ff2:	53 e4       	ldi	r21, 0x43	; 67
    4ff4:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    4ff8:	18 16       	cp	r1, r24
    4ffa:	0c f0       	brlt	.+2      	; 0x4ffe <chb_set_state+0x116>
    4ffc:	10 e0       	ldi	r17, 0x00	; 0
    4ffe:	11 23       	and	r17, r17
    5000:	09 f4       	brne	.+2      	; 0x5004 <chb_set_state+0x11c>
    5002:	89 c0       	rjmp	.+274    	; 0x5116 <chb_set_state+0x22e>
	{
		_delay_ms(__us / 1000.0);
    5004:	6a 81       	ldd	r22, Y+2	; 0x02
    5006:	7b 81       	ldd	r23, Y+3	; 0x03
    5008:	8c 81       	ldd	r24, Y+4	; 0x04
    500a:	9d 81       	ldd	r25, Y+5	; 0x05
    500c:	20 e0       	ldi	r18, 0x00	; 0
    500e:	30 e0       	ldi	r19, 0x00	; 0
    5010:	4a e7       	ldi	r20, 0x7A	; 122
    5012:	54 e4       	ldi	r21, 0x44	; 68
    5014:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
    5018:	dc 01       	movw	r26, r24
    501a:	cb 01       	movw	r24, r22
    501c:	8b 87       	std	Y+11, r24	; 0x0b
    501e:	9c 87       	std	Y+12, r25	; 0x0c
    5020:	ad 87       	std	Y+13, r26	; 0x0d
    5022:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5024:	6b 85       	ldd	r22, Y+11	; 0x0b
    5026:	7c 85       	ldd	r23, Y+12	; 0x0c
    5028:	8d 85       	ldd	r24, Y+13	; 0x0d
    502a:	9e 85       	ldd	r25, Y+14	; 0x0e
    502c:	20 e0       	ldi	r18, 0x00	; 0
    502e:	30 e0       	ldi	r19, 0x00	; 0
    5030:	4a e7       	ldi	r20, 0x7A	; 122
    5032:	53 e4       	ldi	r21, 0x43	; 67
    5034:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    5038:	dc 01       	movw	r26, r24
    503a:	cb 01       	movw	r24, r22
    503c:	8f 87       	std	Y+15, r24	; 0x0f
    503e:	98 8b       	std	Y+16, r25	; 0x10
    5040:	a9 8b       	std	Y+17, r26	; 0x11
    5042:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    5044:	11 e0       	ldi	r17, 0x01	; 1
    5046:	6f 85       	ldd	r22, Y+15	; 0x0f
    5048:	78 89       	ldd	r23, Y+16	; 0x10
    504a:	89 89       	ldd	r24, Y+17	; 0x11
    504c:	9a 89       	ldd	r25, Y+18	; 0x12
    504e:	20 e0       	ldi	r18, 0x00	; 0
    5050:	30 e0       	ldi	r19, 0x00	; 0
    5052:	40 e8       	ldi	r20, 0x80	; 128
    5054:	5f e3       	ldi	r21, 0x3F	; 63
    5056:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    505a:	88 23       	and	r24, r24
    505c:	0c f0       	brlt	.+2      	; 0x5060 <chb_set_state+0x178>
    505e:	10 e0       	ldi	r17, 0x00	; 0
    5060:	11 23       	and	r17, r17
    5062:	29 f0       	breq	.+10     	; 0x506e <chb_set_state+0x186>
		__ticks = 1;
    5064:	81 e0       	ldi	r24, 0x01	; 1
    5066:	90 e0       	ldi	r25, 0x00	; 0
    5068:	8b 8b       	std	Y+19, r24	; 0x13
    506a:	9c 8b       	std	Y+20, r25	; 0x14
    506c:	46 c0       	rjmp	.+140    	; 0x50fa <chb_set_state+0x212>
	else if (__tmp > 65535)
    506e:	11 e0       	ldi	r17, 0x01	; 1
    5070:	6f 85       	ldd	r22, Y+15	; 0x0f
    5072:	78 89       	ldd	r23, Y+16	; 0x10
    5074:	89 89       	ldd	r24, Y+17	; 0x11
    5076:	9a 89       	ldd	r25, Y+18	; 0x12
    5078:	20 e0       	ldi	r18, 0x00	; 0
    507a:	3f ef       	ldi	r19, 0xFF	; 255
    507c:	4f e7       	ldi	r20, 0x7F	; 127
    507e:	57 e4       	ldi	r21, 0x47	; 71
    5080:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    5084:	18 16       	cp	r1, r24
    5086:	0c f0       	brlt	.+2      	; 0x508a <chb_set_state+0x1a2>
    5088:	10 e0       	ldi	r17, 0x00	; 0
    508a:	11 23       	and	r17, r17
    508c:	61 f1       	breq	.+88     	; 0x50e6 <chb_set_state+0x1fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    508e:	6b 85       	ldd	r22, Y+11	; 0x0b
    5090:	7c 85       	ldd	r23, Y+12	; 0x0c
    5092:	8d 85       	ldd	r24, Y+13	; 0x0d
    5094:	9e 85       	ldd	r25, Y+14	; 0x0e
    5096:	20 e0       	ldi	r18, 0x00	; 0
    5098:	30 e0       	ldi	r19, 0x00	; 0
    509a:	40 e2       	ldi	r20, 0x20	; 32
    509c:	51 e4       	ldi	r21, 0x41	; 65
    509e:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    50a2:	dc 01       	movw	r26, r24
    50a4:	cb 01       	movw	r24, r22
    50a6:	bc 01       	movw	r22, r24
    50a8:	cd 01       	movw	r24, r26
    50aa:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    50ae:	dc 01       	movw	r26, r24
    50b0:	cb 01       	movw	r24, r22
    50b2:	8b 8b       	std	Y+19, r24	; 0x13
    50b4:	9c 8b       	std	Y+20, r25	; 0x14
    50b6:	12 c0       	rjmp	.+36     	; 0x50dc <chb_set_state+0x1f4>
    50b8:	89 e1       	ldi	r24, 0x19	; 25
    50ba:	90 e0       	ldi	r25, 0x00	; 0
    50bc:	8d 8b       	std	Y+21, r24	; 0x15
    50be:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    50c0:	8d 89       	ldd	r24, Y+21	; 0x15
    50c2:	9e 89       	ldd	r25, Y+22	; 0x16
    50c4:	8c 01       	movw	r16, r24
    50c6:	c8 01       	movw	r24, r16
    50c8:	01 97       	sbiw	r24, 0x01	; 1
    50ca:	f1 f7       	brne	.-4      	; 0x50c8 <chb_set_state+0x1e0>
    50cc:	8c 01       	movw	r16, r24
    50ce:	0d 8b       	std	Y+21, r16	; 0x15
    50d0:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    50d2:	8b 89       	ldd	r24, Y+19	; 0x13
    50d4:	9c 89       	ldd	r25, Y+20	; 0x14
    50d6:	01 97       	sbiw	r24, 0x01	; 1
    50d8:	8b 8b       	std	Y+19, r24	; 0x13
    50da:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    50dc:	8b 89       	ldd	r24, Y+19	; 0x13
    50de:	9c 89       	ldd	r25, Y+20	; 0x14
    50e0:	00 97       	sbiw	r24, 0x00	; 0
    50e2:	51 f7       	brne	.-44     	; 0x50b8 <chb_set_state+0x1d0>
    50e4:	29 c0       	rjmp	.+82     	; 0x5138 <chb_set_state+0x250>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    50e6:	6f 85       	ldd	r22, Y+15	; 0x0f
    50e8:	78 89       	ldd	r23, Y+16	; 0x10
    50ea:	89 89       	ldd	r24, Y+17	; 0x11
    50ec:	9a 89       	ldd	r25, Y+18	; 0x12
    50ee:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    50f2:	dc 01       	movw	r26, r24
    50f4:	cb 01       	movw	r24, r22
    50f6:	8b 8b       	std	Y+19, r24	; 0x13
    50f8:	9c 8b       	std	Y+20, r25	; 0x14
    50fa:	8b 89       	ldd	r24, Y+19	; 0x13
    50fc:	9c 89       	ldd	r25, Y+20	; 0x14
    50fe:	8f 8b       	std	Y+23, r24	; 0x17
    5100:	98 8f       	std	Y+24, r25	; 0x18
    5102:	8f 89       	ldd	r24, Y+23	; 0x17
    5104:	98 8d       	ldd	r25, Y+24	; 0x18
    5106:	8c 01       	movw	r16, r24
    5108:	f8 01       	movw	r30, r16
    510a:	31 97       	sbiw	r30, 0x01	; 1
    510c:	f1 f7       	brne	.-4      	; 0x510a <chb_set_state+0x222>
    510e:	8f 01       	movw	r16, r30
    5110:	0f 8b       	std	Y+23, r16	; 0x17
    5112:	18 8f       	std	Y+24, r17	; 0x18
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;
    5114:	24 c2       	rjmp	.+1096   	; 0x555e <chb_set_state+0x676>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5116:	6e 81       	ldd	r22, Y+6	; 0x06
    5118:	7f 81       	ldd	r23, Y+7	; 0x07
    511a:	88 85       	ldd	r24, Y+8	; 0x08
    511c:	99 85       	ldd	r25, Y+9	; 0x09
    511e:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    5122:	dc 01       	movw	r26, r24
    5124:	cb 01       	movw	r24, r22
    5126:	8a 87       	std	Y+10, r24	; 0x0a
    5128:	8a 85       	ldd	r24, Y+10	; 0x0a
    512a:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    512c:	89 8d       	ldd	r24, Y+25	; 0x19
    512e:	18 2f       	mov	r17, r24
    5130:	1a 95       	dec	r17
    5132:	f1 f7       	brne	.-4      	; 0x5130 <chb_set_state+0x248>
    5134:	19 8f       	std	Y+25, r17	; 0x19
    5136:	13 c2       	rjmp	.+1062   	; 0x555e <chb_set_state+0x676>
    5138:	12 c2       	rjmp	.+1060   	; 0x555e <chb_set_state+0x676>

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    513a:	89 81       	ldd	r24, Y+1	; 0x01
    513c:	86 31       	cpi	r24, 0x16	; 22
    513e:	09 f0       	breq	.+2      	; 0x5142 <chb_set_state+0x25a>
    5140:	0b c2       	rjmp	.+1046   	; 0x5558 <chb_set_state+0x670>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    5142:	82 e0       	ldi	r24, 0x02	; 2
    5144:	69 e0       	ldi	r22, 0x09	; 9
    5146:	4f e1       	ldi	r20, 0x1F	; 31
    5148:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>
    514c:	80 e0       	ldi	r24, 0x00	; 0
    514e:	90 e0       	ldi	r25, 0x00	; 0
    5150:	a0 e8       	ldi	r26, 0x80	; 128
    5152:	bf e3       	ldi	r27, 0x3F	; 63
    5154:	8a 8f       	std	Y+26, r24	; 0x1a
    5156:	9b 8f       	std	Y+27, r25	; 0x1b
    5158:	ac 8f       	std	Y+28, r26	; 0x1c
    515a:	bd 8f       	std	Y+29, r27	; 0x1d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    515c:	6a 8d       	ldd	r22, Y+26	; 0x1a
    515e:	7b 8d       	ldd	r23, Y+27	; 0x1b
    5160:	8c 8d       	ldd	r24, Y+28	; 0x1c
    5162:	9d 8d       	ldd	r25, Y+29	; 0x1d
    5164:	2b ea       	ldi	r18, 0xAB	; 171
    5166:	3a ea       	ldi	r19, 0xAA	; 170
    5168:	4a ea       	ldi	r20, 0xAA	; 170
    516a:	5e e3       	ldi	r21, 0x3E	; 62
    516c:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    5170:	dc 01       	movw	r26, r24
    5172:	cb 01       	movw	r24, r22
    5174:	8e 8f       	std	Y+30, r24	; 0x1e
    5176:	9f 8f       	std	Y+31, r25	; 0x1f
    5178:	a8 a3       	lds	r26, 0x58
    517a:	b9 a3       	lds	r27, 0x59
	if (__tmp < 1.0)
    517c:	11 e0       	ldi	r17, 0x01	; 1
    517e:	6e 8d       	ldd	r22, Y+30	; 0x1e
    5180:	7f 8d       	ldd	r23, Y+31	; 0x1f
    5182:	88 a1       	lds	r24, 0x48
    5184:	99 a1       	lds	r25, 0x49
    5186:	20 e0       	ldi	r18, 0x00	; 0
    5188:	30 e0       	ldi	r19, 0x00	; 0
    518a:	40 e8       	ldi	r20, 0x80	; 128
    518c:	5f e3       	ldi	r21, 0x3F	; 63
    518e:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    5192:	88 23       	and	r24, r24
    5194:	0c f0       	brlt	.+2      	; 0x5198 <chb_set_state+0x2b0>
    5196:	10 e0       	ldi	r17, 0x00	; 0
    5198:	11 23       	and	r17, r17
    519a:	19 f0       	breq	.+6      	; 0x51a2 <chb_set_state+0x2ba>
		__ticks = 1;
    519c:	81 e0       	ldi	r24, 0x01	; 1
    519e:	8a a3       	lds	r24, 0x5a
    51a0:	a3 c0       	rjmp	.+326    	; 0x52e8 <chb_set_state+0x400>
	else if (__tmp > 255)
    51a2:	11 e0       	ldi	r17, 0x01	; 1
    51a4:	6e 8d       	ldd	r22, Y+30	; 0x1e
    51a6:	7f 8d       	ldd	r23, Y+31	; 0x1f
    51a8:	88 a1       	lds	r24, 0x48
    51aa:	99 a1       	lds	r25, 0x49
    51ac:	20 e0       	ldi	r18, 0x00	; 0
    51ae:	30 e0       	ldi	r19, 0x00	; 0
    51b0:	4f e7       	ldi	r20, 0x7F	; 127
    51b2:	53 e4       	ldi	r21, 0x43	; 67
    51b4:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    51b8:	18 16       	cp	r1, r24
    51ba:	0c f0       	brlt	.+2      	; 0x51be <chb_set_state+0x2d6>
    51bc:	10 e0       	ldi	r17, 0x00	; 0
    51be:	11 23       	and	r17, r17
    51c0:	09 f4       	brne	.+2      	; 0x51c4 <chb_set_state+0x2dc>
    51c2:	89 c0       	rjmp	.+274    	; 0x52d6 <chb_set_state+0x3ee>
	{
		_delay_ms(__us / 1000.0);
    51c4:	6a 8d       	ldd	r22, Y+26	; 0x1a
    51c6:	7b 8d       	ldd	r23, Y+27	; 0x1b
    51c8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    51ca:	9d 8d       	ldd	r25, Y+29	; 0x1d
    51cc:	20 e0       	ldi	r18, 0x00	; 0
    51ce:	30 e0       	ldi	r19, 0x00	; 0
    51d0:	4a e7       	ldi	r20, 0x7A	; 122
    51d2:	54 e4       	ldi	r21, 0x44	; 68
    51d4:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
    51d8:	dc 01       	movw	r26, r24
    51da:	cb 01       	movw	r24, r22
    51dc:	8b a3       	lds	r24, 0x5b
    51de:	9c a3       	lds	r25, 0x5c
    51e0:	ad a3       	lds	r26, 0x5d
    51e2:	be a3       	lds	r27, 0x5e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    51e4:	6b a1       	lds	r22, 0x4b
    51e6:	7c a1       	lds	r23, 0x4c
    51e8:	8d a1       	lds	r24, 0x4d
    51ea:	9e a1       	lds	r25, 0x4e
    51ec:	20 e0       	ldi	r18, 0x00	; 0
    51ee:	30 e0       	ldi	r19, 0x00	; 0
    51f0:	4a e7       	ldi	r20, 0x7A	; 122
    51f2:	53 e4       	ldi	r21, 0x43	; 67
    51f4:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    51f8:	dc 01       	movw	r26, r24
    51fa:	cb 01       	movw	r24, r22
    51fc:	8f a3       	lds	r24, 0x5f
    51fe:	98 a7       	lds	r25, 0x78
    5200:	a9 a7       	lds	r26, 0x79
    5202:	ba a7       	lds	r27, 0x7a
	if (__tmp < 1.0)
    5204:	11 e0       	ldi	r17, 0x01	; 1
    5206:	6f a1       	lds	r22, 0x4f
    5208:	78 a5       	lds	r23, 0x68
    520a:	89 a5       	lds	r24, 0x69
    520c:	9a a5       	lds	r25, 0x6a
    520e:	20 e0       	ldi	r18, 0x00	; 0
    5210:	30 e0       	ldi	r19, 0x00	; 0
    5212:	40 e8       	ldi	r20, 0x80	; 128
    5214:	5f e3       	ldi	r21, 0x3F	; 63
    5216:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    521a:	88 23       	and	r24, r24
    521c:	0c f0       	brlt	.+2      	; 0x5220 <chb_set_state+0x338>
    521e:	10 e0       	ldi	r17, 0x00	; 0
    5220:	11 23       	and	r17, r17
    5222:	29 f0       	breq	.+10     	; 0x522e <chb_set_state+0x346>
		__ticks = 1;
    5224:	81 e0       	ldi	r24, 0x01	; 1
    5226:	90 e0       	ldi	r25, 0x00	; 0
    5228:	8b a7       	lds	r24, 0x7b
    522a:	9c a7       	lds	r25, 0x7c
    522c:	46 c0       	rjmp	.+140    	; 0x52ba <chb_set_state+0x3d2>
	else if (__tmp > 65535)
    522e:	11 e0       	ldi	r17, 0x01	; 1
    5230:	6f a1       	lds	r22, 0x4f
    5232:	78 a5       	lds	r23, 0x68
    5234:	89 a5       	lds	r24, 0x69
    5236:	9a a5       	lds	r25, 0x6a
    5238:	20 e0       	ldi	r18, 0x00	; 0
    523a:	3f ef       	ldi	r19, 0xFF	; 255
    523c:	4f e7       	ldi	r20, 0x7F	; 127
    523e:	57 e4       	ldi	r21, 0x47	; 71
    5240:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    5244:	18 16       	cp	r1, r24
    5246:	0c f0       	brlt	.+2      	; 0x524a <chb_set_state+0x362>
    5248:	10 e0       	ldi	r17, 0x00	; 0
    524a:	11 23       	and	r17, r17
    524c:	61 f1       	breq	.+88     	; 0x52a6 <chb_set_state+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    524e:	6b a1       	lds	r22, 0x4b
    5250:	7c a1       	lds	r23, 0x4c
    5252:	8d a1       	lds	r24, 0x4d
    5254:	9e a1       	lds	r25, 0x4e
    5256:	20 e0       	ldi	r18, 0x00	; 0
    5258:	30 e0       	ldi	r19, 0x00	; 0
    525a:	40 e2       	ldi	r20, 0x20	; 32
    525c:	51 e4       	ldi	r21, 0x41	; 65
    525e:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    5262:	dc 01       	movw	r26, r24
    5264:	cb 01       	movw	r24, r22
    5266:	bc 01       	movw	r22, r24
    5268:	cd 01       	movw	r24, r26
    526a:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    526e:	dc 01       	movw	r26, r24
    5270:	cb 01       	movw	r24, r22
    5272:	8b a7       	lds	r24, 0x7b
    5274:	9c a7       	lds	r25, 0x7c
    5276:	12 c0       	rjmp	.+36     	; 0x529c <chb_set_state+0x3b4>
    5278:	89 e1       	ldi	r24, 0x19	; 25
    527a:	90 e0       	ldi	r25, 0x00	; 0
    527c:	8d a7       	lds	r24, 0x7d
    527e:	9e a7       	lds	r25, 0x7e
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5280:	8d a5       	lds	r24, 0x6d
    5282:	9e a5       	lds	r25, 0x6e
    5284:	8c 01       	movw	r16, r24
    5286:	c8 01       	movw	r24, r16
    5288:	01 97       	sbiw	r24, 0x01	; 1
    528a:	f1 f7       	brne	.-4      	; 0x5288 <chb_set_state+0x3a0>
    528c:	8c 01       	movw	r16, r24
    528e:	0d a7       	lds	r16, 0x7d
    5290:	1e a7       	lds	r17, 0x7e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5292:	8b a5       	lds	r24, 0x6b
    5294:	9c a5       	lds	r25, 0x6c
    5296:	01 97       	sbiw	r24, 0x01	; 1
    5298:	8b a7       	lds	r24, 0x7b
    529a:	9c a7       	lds	r25, 0x7c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    529c:	8b a5       	lds	r24, 0x6b
    529e:	9c a5       	lds	r25, 0x6c
    52a0:	00 97       	sbiw	r24, 0x00	; 0
    52a2:	51 f7       	brne	.-44     	; 0x5278 <chb_set_state+0x390>
    52a4:	29 c0       	rjmp	.+82     	; 0x52f8 <chb_set_state+0x410>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    52a6:	6f a1       	lds	r22, 0x4f
    52a8:	78 a5       	lds	r23, 0x68
    52aa:	89 a5       	lds	r24, 0x69
    52ac:	9a a5       	lds	r25, 0x6a
    52ae:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    52b2:	dc 01       	movw	r26, r24
    52b4:	cb 01       	movw	r24, r22
    52b6:	8b a7       	lds	r24, 0x7b
    52b8:	9c a7       	lds	r25, 0x7c
    52ba:	8b a5       	lds	r24, 0x6b
    52bc:	9c a5       	lds	r25, 0x6c
    52be:	8f a7       	lds	r24, 0x7f
    52c0:	98 ab       	sts	0x58, r25
    52c2:	8f a5       	lds	r24, 0x6f
    52c4:	98 a9       	sts	0x48, r25
    52c6:	8c 01       	movw	r16, r24
    52c8:	f8 01       	movw	r30, r16
    52ca:	31 97       	sbiw	r30, 0x01	; 1
    52cc:	f1 f7       	brne	.-4      	; 0x52ca <chb_set_state+0x3e2>
    52ce:	8f 01       	movw	r16, r30
    52d0:	0f a7       	lds	r16, 0x7f
    52d2:	18 ab       	sts	0x58, r17
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    52d4:	41 c1       	rjmp	.+642    	; 0x5558 <chb_set_state+0x670>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    52d6:	6e 8d       	ldd	r22, Y+30	; 0x1e
    52d8:	7f 8d       	ldd	r23, Y+31	; 0x1f
    52da:	88 a1       	lds	r24, 0x48
    52dc:	99 a1       	lds	r25, 0x49
    52de:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    52e2:	dc 01       	movw	r26, r24
    52e4:	cb 01       	movw	r24, r22
    52e6:	8a a3       	lds	r24, 0x5a
    52e8:	8a a1       	lds	r24, 0x4a
    52ea:	89 ab       	sts	0x59, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    52ec:	89 a9       	sts	0x49, r24
    52ee:	18 2f       	mov	r17, r24
    52f0:	1a 95       	dec	r17
    52f2:	f1 f7       	brne	.-4      	; 0x52f0 <chb_set_state+0x408>
    52f4:	19 ab       	sts	0x59, r17
    52f6:	30 c1       	rjmp	.+608    	; 0x5558 <chb_set_state+0x670>
    52f8:	2f c1       	rjmp	.+606    	; 0x5558 <chb_set_state+0x670>

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    52fa:	89 81       	ldd	r24, Y+1	; 0x01
    52fc:	89 31       	cpi	r24, 0x19	; 25
    52fe:	09 f0       	breq	.+2      	; 0x5302 <chb_set_state+0x41a>
    5300:	2d c1       	rjmp	.+602    	; 0x555c <chb_set_state+0x674>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    5302:	82 e0       	ldi	r24, 0x02	; 2
    5304:	69 e0       	ldi	r22, 0x09	; 9
    5306:	4f e1       	ldi	r20, 0x1F	; 31
    5308:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>
    530c:	80 e0       	ldi	r24, 0x00	; 0
    530e:	90 e0       	ldi	r25, 0x00	; 0
    5310:	a0 e8       	ldi	r26, 0x80	; 128
    5312:	bf e3       	ldi	r27, 0x3F	; 63
    5314:	8a ab       	sts	0x5a, r24
    5316:	9b ab       	sts	0x5b, r25
    5318:	ac ab       	sts	0x5c, r26
    531a:	bd ab       	sts	0x5d, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    531c:	6a a9       	sts	0x4a, r22
    531e:	7b a9       	sts	0x4b, r23
    5320:	8c a9       	sts	0x4c, r24
    5322:	9d a9       	sts	0x4d, r25
    5324:	2b ea       	ldi	r18, 0xAB	; 171
    5326:	3a ea       	ldi	r19, 0xAA	; 170
    5328:	4a ea       	ldi	r20, 0xAA	; 170
    532a:	5e e3       	ldi	r21, 0x3E	; 62
    532c:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    5330:	dc 01       	movw	r26, r24
    5332:	cb 01       	movw	r24, r22
    5334:	8e ab       	sts	0x5e, r24
    5336:	9f ab       	sts	0x5f, r25
    5338:	a8 af       	sts	0x78, r26
    533a:	b9 af       	sts	0x79, r27
	if (__tmp < 1.0)
    533c:	11 e0       	ldi	r17, 0x01	; 1
    533e:	6e a9       	sts	0x4e, r22
    5340:	7f a9       	sts	0x4f, r23
    5342:	88 ad       	sts	0x68, r24
    5344:	99 ad       	sts	0x69, r25
    5346:	20 e0       	ldi	r18, 0x00	; 0
    5348:	30 e0       	ldi	r19, 0x00	; 0
    534a:	40 e8       	ldi	r20, 0x80	; 128
    534c:	5f e3       	ldi	r21, 0x3F	; 63
    534e:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    5352:	88 23       	and	r24, r24
    5354:	0c f0       	brlt	.+2      	; 0x5358 <chb_set_state+0x470>
    5356:	10 e0       	ldi	r17, 0x00	; 0
    5358:	11 23       	and	r17, r17
    535a:	19 f0       	breq	.+6      	; 0x5362 <chb_set_state+0x47a>
		__ticks = 1;
    535c:	81 e0       	ldi	r24, 0x01	; 1
    535e:	8a af       	sts	0x7a, r24
    5360:	e6 c0       	rjmp	.+460    	; 0x552e <chb_set_state+0x646>
	else if (__tmp > 255)
    5362:	11 e0       	ldi	r17, 0x01	; 1
    5364:	6e a9       	sts	0x4e, r22
    5366:	7f a9       	sts	0x4f, r23
    5368:	88 ad       	sts	0x68, r24
    536a:	99 ad       	sts	0x69, r25
    536c:	20 e0       	ldi	r18, 0x00	; 0
    536e:	30 e0       	ldi	r19, 0x00	; 0
    5370:	4f e7       	ldi	r20, 0x7F	; 127
    5372:	53 e4       	ldi	r21, 0x43	; 67
    5374:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    5378:	18 16       	cp	r1, r24
    537a:	0c f0       	brlt	.+2      	; 0x537e <chb_set_state+0x496>
    537c:	10 e0       	ldi	r17, 0x00	; 0
    537e:	11 23       	and	r17, r17
    5380:	09 f4       	brne	.+2      	; 0x5384 <chb_set_state+0x49c>
    5382:	cc c0       	rjmp	.+408    	; 0x551c <chb_set_state+0x634>
	{
		_delay_ms(__us / 1000.0);
    5384:	6a a9       	sts	0x4a, r22
    5386:	7b a9       	sts	0x4b, r23
    5388:	8c a9       	sts	0x4c, r24
    538a:	9d a9       	sts	0x4d, r25
    538c:	20 e0       	ldi	r18, 0x00	; 0
    538e:	30 e0       	ldi	r19, 0x00	; 0
    5390:	4a e7       	ldi	r20, 0x7A	; 122
    5392:	54 e4       	ldi	r21, 0x44	; 68
    5394:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
    5398:	dc 01       	movw	r26, r24
    539a:	cb 01       	movw	r24, r22
    539c:	8b af       	sts	0x7b, r24
    539e:	9c af       	sts	0x7c, r25
    53a0:	ad af       	sts	0x7d, r26
    53a2:	be af       	sts	0x7e, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    53a4:	8e 01       	movw	r16, r28
    53a6:	01 5c       	subi	r16, 0xC1	; 193
    53a8:	1f 4f       	sbci	r17, 0xFF	; 255
    53aa:	6b ad       	sts	0x6b, r22
    53ac:	7c ad       	sts	0x6c, r23
    53ae:	8d ad       	sts	0x6d, r24
    53b0:	9e ad       	sts	0x6e, r25
    53b2:	20 e0       	ldi	r18, 0x00	; 0
    53b4:	30 e0       	ldi	r19, 0x00	; 0
    53b6:	4a e7       	ldi	r20, 0x7A	; 122
    53b8:	53 e4       	ldi	r21, 0x43	; 67
    53ba:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    53be:	dc 01       	movw	r26, r24
    53c0:	cb 01       	movw	r24, r22
    53c2:	f8 01       	movw	r30, r16
    53c4:	80 83       	st	Z, r24
    53c6:	91 83       	std	Z+1, r25	; 0x01
    53c8:	a2 83       	std	Z+2, r26	; 0x02
    53ca:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    53cc:	ce 01       	movw	r24, r28
    53ce:	cf 96       	adiw	r24, 0x3f	; 63
    53d0:	11 e0       	ldi	r17, 0x01	; 1
    53d2:	fc 01       	movw	r30, r24
    53d4:	60 81       	ld	r22, Z
    53d6:	71 81       	ldd	r23, Z+1	; 0x01
    53d8:	82 81       	ldd	r24, Z+2	; 0x02
    53da:	93 81       	ldd	r25, Z+3	; 0x03
    53dc:	20 e0       	ldi	r18, 0x00	; 0
    53de:	30 e0       	ldi	r19, 0x00	; 0
    53e0:	40 e8       	ldi	r20, 0x80	; 128
    53e2:	5f e3       	ldi	r21, 0x3F	; 63
    53e4:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    53e8:	88 23       	and	r24, r24
    53ea:	0c f0       	brlt	.+2      	; 0x53ee <chb_set_state+0x506>
    53ec:	10 e0       	ldi	r17, 0x00	; 0
    53ee:	11 23       	and	r17, r17
    53f0:	49 f0       	breq	.+18     	; 0x5404 <chb_set_state+0x51c>
		__ticks = 1;
    53f2:	ce 01       	movw	r24, r28
    53f4:	8d 5b       	subi	r24, 0xBD	; 189
    53f6:	9f 4f       	sbci	r25, 0xFF	; 255
    53f8:	21 e0       	ldi	r18, 0x01	; 1
    53fa:	30 e0       	ldi	r19, 0x00	; 0
    53fc:	fc 01       	movw	r30, r24
    53fe:	20 83       	st	Z, r18
    5400:	31 83       	std	Z+1, r19	; 0x01
    5402:	6e c0       	rjmp	.+220    	; 0x54e0 <chb_set_state+0x5f8>
	else if (__tmp > 65535)
    5404:	ce 01       	movw	r24, r28
    5406:	cf 96       	adiw	r24, 0x3f	; 63
    5408:	11 e0       	ldi	r17, 0x01	; 1
    540a:	fc 01       	movw	r30, r24
    540c:	60 81       	ld	r22, Z
    540e:	71 81       	ldd	r23, Z+1	; 0x01
    5410:	82 81       	ldd	r24, Z+2	; 0x02
    5412:	93 81       	ldd	r25, Z+3	; 0x03
    5414:	20 e0       	ldi	r18, 0x00	; 0
    5416:	3f ef       	ldi	r19, 0xFF	; 255
    5418:	4f e7       	ldi	r20, 0x7F	; 127
    541a:	57 e4       	ldi	r21, 0x47	; 71
    541c:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    5420:	18 16       	cp	r1, r24
    5422:	0c f0       	brlt	.+2      	; 0x5426 <chb_set_state+0x53e>
    5424:	10 e0       	ldi	r17, 0x00	; 0
    5426:	11 23       	and	r17, r17
    5428:	09 f4       	brne	.+2      	; 0x542c <chb_set_state+0x544>
    542a:	49 c0       	rjmp	.+146    	; 0x54be <chb_set_state+0x5d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    542c:	6b ad       	sts	0x6b, r22
    542e:	7c ad       	sts	0x6c, r23
    5430:	8d ad       	sts	0x6d, r24
    5432:	9e ad       	sts	0x6e, r25
    5434:	20 e0       	ldi	r18, 0x00	; 0
    5436:	30 e0       	ldi	r19, 0x00	; 0
    5438:	40 e2       	ldi	r20, 0x20	; 32
    543a:	51 e4       	ldi	r21, 0x41	; 65
    543c:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    5440:	dc 01       	movw	r26, r24
    5442:	cb 01       	movw	r24, r22
    5444:	8e 01       	movw	r16, r28
    5446:	0d 5b       	subi	r16, 0xBD	; 189
    5448:	1f 4f       	sbci	r17, 0xFF	; 255
    544a:	bc 01       	movw	r22, r24
    544c:	cd 01       	movw	r24, r26
    544e:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    5452:	dc 01       	movw	r26, r24
    5454:	cb 01       	movw	r24, r22
    5456:	f8 01       	movw	r30, r16
    5458:	80 83       	st	Z, r24
    545a:	91 83       	std	Z+1, r25	; 0x01
    545c:	27 c0       	rjmp	.+78     	; 0x54ac <chb_set_state+0x5c4>
    545e:	ce 01       	movw	r24, r28
    5460:	8b 5b       	subi	r24, 0xBB	; 187
    5462:	9f 4f       	sbci	r25, 0xFF	; 255
    5464:	29 e1       	ldi	r18, 0x19	; 25
    5466:	30 e0       	ldi	r19, 0x00	; 0
    5468:	fc 01       	movw	r30, r24
    546a:	20 83       	st	Z, r18
    546c:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    546e:	ce 01       	movw	r24, r28
    5470:	8b 5b       	subi	r24, 0xBB	; 187
    5472:	9f 4f       	sbci	r25, 0xFF	; 255
    5474:	fc 01       	movw	r30, r24
    5476:	80 81       	ld	r24, Z
    5478:	91 81       	ldd	r25, Z+1	; 0x01
    547a:	8c 01       	movw	r16, r24
    547c:	c8 01       	movw	r24, r16
    547e:	01 97       	sbiw	r24, 0x01	; 1
    5480:	f1 f7       	brne	.-4      	; 0x547e <chb_set_state+0x596>
    5482:	8c 01       	movw	r16, r24
    5484:	ce 01       	movw	r24, r28
    5486:	8b 5b       	subi	r24, 0xBB	; 187
    5488:	9f 4f       	sbci	r25, 0xFF	; 255
    548a:	fc 01       	movw	r30, r24
    548c:	00 83       	st	Z, r16
    548e:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5490:	ce 01       	movw	r24, r28
    5492:	8d 5b       	subi	r24, 0xBD	; 189
    5494:	9f 4f       	sbci	r25, 0xFF	; 255
    5496:	9e 01       	movw	r18, r28
    5498:	2d 5b       	subi	r18, 0xBD	; 189
    549a:	3f 4f       	sbci	r19, 0xFF	; 255
    549c:	f9 01       	movw	r30, r18
    549e:	20 81       	ld	r18, Z
    54a0:	31 81       	ldd	r19, Z+1	; 0x01
    54a2:	21 50       	subi	r18, 0x01	; 1
    54a4:	30 40       	sbci	r19, 0x00	; 0
    54a6:	fc 01       	movw	r30, r24
    54a8:	20 83       	st	Z, r18
    54aa:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    54ac:	ce 01       	movw	r24, r28
    54ae:	8d 5b       	subi	r24, 0xBD	; 189
    54b0:	9f 4f       	sbci	r25, 0xFF	; 255
    54b2:	fc 01       	movw	r30, r24
    54b4:	80 81       	ld	r24, Z
    54b6:	91 81       	ldd	r25, Z+1	; 0x01
    54b8:	00 97       	sbiw	r24, 0x00	; 0
    54ba:	89 f6       	brne	.-94     	; 0x545e <chb_set_state+0x576>
    54bc:	4c c0       	rjmp	.+152    	; 0x5556 <chb_set_state+0x66e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    54be:	8e 01       	movw	r16, r28
    54c0:	0d 5b       	subi	r16, 0xBD	; 189
    54c2:	1f 4f       	sbci	r17, 0xFF	; 255
    54c4:	ce 01       	movw	r24, r28
    54c6:	cf 96       	adiw	r24, 0x3f	; 63
    54c8:	fc 01       	movw	r30, r24
    54ca:	60 81       	ld	r22, Z
    54cc:	71 81       	ldd	r23, Z+1	; 0x01
    54ce:	82 81       	ldd	r24, Z+2	; 0x02
    54d0:	93 81       	ldd	r25, Z+3	; 0x03
    54d2:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    54d6:	dc 01       	movw	r26, r24
    54d8:	cb 01       	movw	r24, r22
    54da:	f8 01       	movw	r30, r16
    54dc:	80 83       	st	Z, r24
    54de:	91 83       	std	Z+1, r25	; 0x01
    54e0:	ce 01       	movw	r24, r28
    54e2:	89 5b       	subi	r24, 0xB9	; 185
    54e4:	9f 4f       	sbci	r25, 0xFF	; 255
    54e6:	9e 01       	movw	r18, r28
    54e8:	2d 5b       	subi	r18, 0xBD	; 189
    54ea:	3f 4f       	sbci	r19, 0xFF	; 255
    54ec:	f9 01       	movw	r30, r18
    54ee:	20 81       	ld	r18, Z
    54f0:	31 81       	ldd	r19, Z+1	; 0x01
    54f2:	fc 01       	movw	r30, r24
    54f4:	20 83       	st	Z, r18
    54f6:	31 83       	std	Z+1, r19	; 0x01
    54f8:	ce 01       	movw	r24, r28
    54fa:	89 5b       	subi	r24, 0xB9	; 185
    54fc:	9f 4f       	sbci	r25, 0xFF	; 255
    54fe:	fc 01       	movw	r30, r24
    5500:	80 81       	ld	r24, Z
    5502:	91 81       	ldd	r25, Z+1	; 0x01
    5504:	8c 01       	movw	r16, r24
    5506:	c8 01       	movw	r24, r16
    5508:	01 97       	sbiw	r24, 0x01	; 1
    550a:	f1 f7       	brne	.-4      	; 0x5508 <chb_set_state+0x620>
    550c:	8c 01       	movw	r16, r24
    550e:	ce 01       	movw	r24, r28
    5510:	89 5b       	subi	r24, 0xB9	; 185
    5512:	9f 4f       	sbci	r25, 0xFF	; 255
    5514:	fc 01       	movw	r30, r24
    5516:	00 83       	st	Z, r16
    5518:	11 83       	std	Z+1, r17	; 0x01
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    551a:	20 c0       	rjmp	.+64     	; 0x555c <chb_set_state+0x674>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    551c:	6e a9       	sts	0x4e, r22
    551e:	7f a9       	sts	0x4f, r23
    5520:	88 ad       	sts	0x68, r24
    5522:	99 ad       	sts	0x69, r25
    5524:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    5528:	dc 01       	movw	r26, r24
    552a:	cb 01       	movw	r24, r22
    552c:	8a af       	sts	0x7a, r24
    552e:	ce 01       	movw	r24, r28
    5530:	87 5b       	subi	r24, 0xB7	; 183
    5532:	9f 4f       	sbci	r25, 0xFF	; 255
    5534:	2a ad       	sts	0x6a, r18
    5536:	fc 01       	movw	r30, r24
    5538:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    553a:	ce 01       	movw	r24, r28
    553c:	87 5b       	subi	r24, 0xB7	; 183
    553e:	9f 4f       	sbci	r25, 0xFF	; 255
    5540:	fc 01       	movw	r30, r24
    5542:	80 81       	ld	r24, Z
    5544:	18 2f       	mov	r17, r24
    5546:	1a 95       	dec	r17
    5548:	f1 f7       	brne	.-4      	; 0x5546 <chb_set_state+0x65e>
    554a:	ce 01       	movw	r24, r28
    554c:	87 5b       	subi	r24, 0xB7	; 183
    554e:	9f 4f       	sbci	r25, 0xFF	; 255
    5550:	fc 01       	movw	r30, r24
    5552:	10 83       	st	Z, r17
    5554:	03 c0       	rjmp	.+6      	; 0x555c <chb_set_state+0x674>
    5556:	02 c0       	rjmp	.+4      	; 0x555c <chb_set_state+0x674>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5558:	00 00       	nop
    555a:	01 c0       	rjmp	.+2      	; 0x555e <chb_set_state+0x676>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    555c:	00 00       	nop
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    555e:	9e 01       	movw	r18, r28
    5560:	2e 59       	subi	r18, 0x9E	; 158
    5562:	3f 4f       	sbci	r19, 0xFF	; 255
    5564:	82 e0       	ldi	r24, 0x02	; 2
    5566:	f9 01       	movw	r30, r18
    5568:	60 81       	ld	r22, Z
    556a:	4f e1       	ldi	r20, 0x1F	; 31
    556c:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>
    5570:	9e 01       	movw	r18, r28
    5572:	26 5b       	subi	r18, 0xB6	; 182
    5574:	3f 4f       	sbci	r19, 0xFF	; 255
    5576:	80 e0       	ldi	r24, 0x00	; 0
    5578:	90 e0       	ldi	r25, 0x00	; 0
    557a:	ac ed       	ldi	r26, 0xDC	; 220
    557c:	b2 e4       	ldi	r27, 0x42	; 66
    557e:	f9 01       	movw	r30, r18
    5580:	80 83       	st	Z, r24
    5582:	91 83       	std	Z+1, r25	; 0x01
    5584:	a2 83       	std	Z+2, r26	; 0x02
    5586:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5588:	8e 01       	movw	r16, r28
    558a:	02 5b       	subi	r16, 0xB2	; 178
    558c:	1f 4f       	sbci	r17, 0xFF	; 255
    558e:	ce 01       	movw	r24, r28
    5590:	86 5b       	subi	r24, 0xB6	; 182
    5592:	9f 4f       	sbci	r25, 0xFF	; 255
    5594:	fc 01       	movw	r30, r24
    5596:	60 81       	ld	r22, Z
    5598:	71 81       	ldd	r23, Z+1	; 0x01
    559a:	82 81       	ldd	r24, Z+2	; 0x02
    559c:	93 81       	ldd	r25, Z+3	; 0x03
    559e:	2b ea       	ldi	r18, 0xAB	; 171
    55a0:	3a ea       	ldi	r19, 0xAA	; 170
    55a2:	4a ea       	ldi	r20, 0xAA	; 170
    55a4:	5e e3       	ldi	r21, 0x3E	; 62
    55a6:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    55aa:	dc 01       	movw	r26, r24
    55ac:	cb 01       	movw	r24, r22
    55ae:	f8 01       	movw	r30, r16
    55b0:	80 83       	st	Z, r24
    55b2:	91 83       	std	Z+1, r25	; 0x01
    55b4:	a2 83       	std	Z+2, r26	; 0x02
    55b6:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    55b8:	ce 01       	movw	r24, r28
    55ba:	82 5b       	subi	r24, 0xB2	; 178
    55bc:	9f 4f       	sbci	r25, 0xFF	; 255
    55be:	11 e0       	ldi	r17, 0x01	; 1
    55c0:	fc 01       	movw	r30, r24
    55c2:	60 81       	ld	r22, Z
    55c4:	71 81       	ldd	r23, Z+1	; 0x01
    55c6:	82 81       	ldd	r24, Z+2	; 0x02
    55c8:	93 81       	ldd	r25, Z+3	; 0x03
    55ca:	20 e0       	ldi	r18, 0x00	; 0
    55cc:	30 e0       	ldi	r19, 0x00	; 0
    55ce:	40 e8       	ldi	r20, 0x80	; 128
    55d0:	5f e3       	ldi	r21, 0x3F	; 63
    55d2:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    55d6:	88 23       	and	r24, r24
    55d8:	0c f0       	brlt	.+2      	; 0x55dc <chb_set_state+0x6f4>
    55da:	10 e0       	ldi	r17, 0x00	; 0
    55dc:	11 23       	and	r17, r17
    55de:	39 f0       	breq	.+14     	; 0x55ee <chb_set_state+0x706>
		__ticks = 1;
    55e0:	ce 01       	movw	r24, r28
    55e2:	8e 5a       	subi	r24, 0xAE	; 174
    55e4:	9f 4f       	sbci	r25, 0xFF	; 255
    55e6:	21 e0       	ldi	r18, 0x01	; 1
    55e8:	fc 01       	movw	r30, r24
    55ea:	20 83       	st	Z, r18
    55ec:	05 c1       	rjmp	.+522    	; 0x57f8 <chb_set_state+0x910>
	else if (__tmp > 255)
    55ee:	ce 01       	movw	r24, r28
    55f0:	82 5b       	subi	r24, 0xB2	; 178
    55f2:	9f 4f       	sbci	r25, 0xFF	; 255
    55f4:	11 e0       	ldi	r17, 0x01	; 1
    55f6:	fc 01       	movw	r30, r24
    55f8:	60 81       	ld	r22, Z
    55fa:	71 81       	ldd	r23, Z+1	; 0x01
    55fc:	82 81       	ldd	r24, Z+2	; 0x02
    55fe:	93 81       	ldd	r25, Z+3	; 0x03
    5600:	20 e0       	ldi	r18, 0x00	; 0
    5602:	30 e0       	ldi	r19, 0x00	; 0
    5604:	4f e7       	ldi	r20, 0x7F	; 127
    5606:	53 e4       	ldi	r21, 0x43	; 67
    5608:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    560c:	18 16       	cp	r1, r24
    560e:	0c f0       	brlt	.+2      	; 0x5612 <chb_set_state+0x72a>
    5610:	10 e0       	ldi	r17, 0x00	; 0
    5612:	11 23       	and	r17, r17
    5614:	09 f4       	brne	.+2      	; 0x5618 <chb_set_state+0x730>
    5616:	df c0       	rjmp	.+446    	; 0x57d6 <chb_set_state+0x8ee>
	{
		_delay_ms(__us / 1000.0);
    5618:	ce 01       	movw	r24, r28
    561a:	86 5b       	subi	r24, 0xB6	; 182
    561c:	9f 4f       	sbci	r25, 0xFF	; 255
    561e:	fc 01       	movw	r30, r24
    5620:	60 81       	ld	r22, Z
    5622:	71 81       	ldd	r23, Z+1	; 0x01
    5624:	82 81       	ldd	r24, Z+2	; 0x02
    5626:	93 81       	ldd	r25, Z+3	; 0x03
    5628:	20 e0       	ldi	r18, 0x00	; 0
    562a:	30 e0       	ldi	r19, 0x00	; 0
    562c:	4a e7       	ldi	r20, 0x7A	; 122
    562e:	54 e4       	ldi	r21, 0x44	; 68
    5630:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
    5634:	dc 01       	movw	r26, r24
    5636:	cb 01       	movw	r24, r22
    5638:	9e 01       	movw	r18, r28
    563a:	2d 5a       	subi	r18, 0xAD	; 173
    563c:	3f 4f       	sbci	r19, 0xFF	; 255
    563e:	f9 01       	movw	r30, r18
    5640:	80 83       	st	Z, r24
    5642:	91 83       	std	Z+1, r25	; 0x01
    5644:	a2 83       	std	Z+2, r26	; 0x02
    5646:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5648:	8e 01       	movw	r16, r28
    564a:	09 5a       	subi	r16, 0xA9	; 169
    564c:	1f 4f       	sbci	r17, 0xFF	; 255
    564e:	ce 01       	movw	r24, r28
    5650:	8d 5a       	subi	r24, 0xAD	; 173
    5652:	9f 4f       	sbci	r25, 0xFF	; 255
    5654:	fc 01       	movw	r30, r24
    5656:	60 81       	ld	r22, Z
    5658:	71 81       	ldd	r23, Z+1	; 0x01
    565a:	82 81       	ldd	r24, Z+2	; 0x02
    565c:	93 81       	ldd	r25, Z+3	; 0x03
    565e:	20 e0       	ldi	r18, 0x00	; 0
    5660:	30 e0       	ldi	r19, 0x00	; 0
    5662:	4a e7       	ldi	r20, 0x7A	; 122
    5664:	53 e4       	ldi	r21, 0x43	; 67
    5666:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    566a:	dc 01       	movw	r26, r24
    566c:	cb 01       	movw	r24, r22
    566e:	f8 01       	movw	r30, r16
    5670:	80 83       	st	Z, r24
    5672:	91 83       	std	Z+1, r25	; 0x01
    5674:	a2 83       	std	Z+2, r26	; 0x02
    5676:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    5678:	ce 01       	movw	r24, r28
    567a:	89 5a       	subi	r24, 0xA9	; 169
    567c:	9f 4f       	sbci	r25, 0xFF	; 255
    567e:	11 e0       	ldi	r17, 0x01	; 1
    5680:	fc 01       	movw	r30, r24
    5682:	60 81       	ld	r22, Z
    5684:	71 81       	ldd	r23, Z+1	; 0x01
    5686:	82 81       	ldd	r24, Z+2	; 0x02
    5688:	93 81       	ldd	r25, Z+3	; 0x03
    568a:	20 e0       	ldi	r18, 0x00	; 0
    568c:	30 e0       	ldi	r19, 0x00	; 0
    568e:	40 e8       	ldi	r20, 0x80	; 128
    5690:	5f e3       	ldi	r21, 0x3F	; 63
    5692:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    5696:	88 23       	and	r24, r24
    5698:	0c f0       	brlt	.+2      	; 0x569c <chb_set_state+0x7b4>
    569a:	10 e0       	ldi	r17, 0x00	; 0
    569c:	11 23       	and	r17, r17
    569e:	49 f0       	breq	.+18     	; 0x56b2 <chb_set_state+0x7ca>
		__ticks = 1;
    56a0:	ce 01       	movw	r24, r28
    56a2:	85 5a       	subi	r24, 0xA5	; 165
    56a4:	9f 4f       	sbci	r25, 0xFF	; 255
    56a6:	21 e0       	ldi	r18, 0x01	; 1
    56a8:	30 e0       	ldi	r19, 0x00	; 0
    56aa:	fc 01       	movw	r30, r24
    56ac:	20 83       	st	Z, r18
    56ae:	31 83       	std	Z+1, r19	; 0x01
    56b0:	74 c0       	rjmp	.+232    	; 0x579a <chb_set_state+0x8b2>
	else if (__tmp > 65535)
    56b2:	ce 01       	movw	r24, r28
    56b4:	89 5a       	subi	r24, 0xA9	; 169
    56b6:	9f 4f       	sbci	r25, 0xFF	; 255
    56b8:	11 e0       	ldi	r17, 0x01	; 1
    56ba:	fc 01       	movw	r30, r24
    56bc:	60 81       	ld	r22, Z
    56be:	71 81       	ldd	r23, Z+1	; 0x01
    56c0:	82 81       	ldd	r24, Z+2	; 0x02
    56c2:	93 81       	ldd	r25, Z+3	; 0x03
    56c4:	20 e0       	ldi	r18, 0x00	; 0
    56c6:	3f ef       	ldi	r19, 0xFF	; 255
    56c8:	4f e7       	ldi	r20, 0x7F	; 127
    56ca:	57 e4       	ldi	r21, 0x47	; 71
    56cc:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    56d0:	18 16       	cp	r1, r24
    56d2:	0c f0       	brlt	.+2      	; 0x56d6 <chb_set_state+0x7ee>
    56d4:	10 e0       	ldi	r17, 0x00	; 0
    56d6:	11 23       	and	r17, r17
    56d8:	09 f4       	brne	.+2      	; 0x56dc <chb_set_state+0x7f4>
    56da:	4d c0       	rjmp	.+154    	; 0x5776 <chb_set_state+0x88e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    56dc:	ce 01       	movw	r24, r28
    56de:	8d 5a       	subi	r24, 0xAD	; 173
    56e0:	9f 4f       	sbci	r25, 0xFF	; 255
    56e2:	fc 01       	movw	r30, r24
    56e4:	60 81       	ld	r22, Z
    56e6:	71 81       	ldd	r23, Z+1	; 0x01
    56e8:	82 81       	ldd	r24, Z+2	; 0x02
    56ea:	93 81       	ldd	r25, Z+3	; 0x03
    56ec:	20 e0       	ldi	r18, 0x00	; 0
    56ee:	30 e0       	ldi	r19, 0x00	; 0
    56f0:	40 e2       	ldi	r20, 0x20	; 32
    56f2:	51 e4       	ldi	r21, 0x41	; 65
    56f4:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    56f8:	dc 01       	movw	r26, r24
    56fa:	cb 01       	movw	r24, r22
    56fc:	8e 01       	movw	r16, r28
    56fe:	05 5a       	subi	r16, 0xA5	; 165
    5700:	1f 4f       	sbci	r17, 0xFF	; 255
    5702:	bc 01       	movw	r22, r24
    5704:	cd 01       	movw	r24, r26
    5706:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    570a:	dc 01       	movw	r26, r24
    570c:	cb 01       	movw	r24, r22
    570e:	f8 01       	movw	r30, r16
    5710:	80 83       	st	Z, r24
    5712:	91 83       	std	Z+1, r25	; 0x01
    5714:	27 c0       	rjmp	.+78     	; 0x5764 <chb_set_state+0x87c>
    5716:	ce 01       	movw	r24, r28
    5718:	83 5a       	subi	r24, 0xA3	; 163
    571a:	9f 4f       	sbci	r25, 0xFF	; 255
    571c:	29 e1       	ldi	r18, 0x19	; 25
    571e:	30 e0       	ldi	r19, 0x00	; 0
    5720:	fc 01       	movw	r30, r24
    5722:	20 83       	st	Z, r18
    5724:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5726:	ce 01       	movw	r24, r28
    5728:	83 5a       	subi	r24, 0xA3	; 163
    572a:	9f 4f       	sbci	r25, 0xFF	; 255
    572c:	fc 01       	movw	r30, r24
    572e:	80 81       	ld	r24, Z
    5730:	91 81       	ldd	r25, Z+1	; 0x01
    5732:	8c 01       	movw	r16, r24
    5734:	c8 01       	movw	r24, r16
    5736:	01 97       	sbiw	r24, 0x01	; 1
    5738:	f1 f7       	brne	.-4      	; 0x5736 <chb_set_state+0x84e>
    573a:	8c 01       	movw	r16, r24
    573c:	ce 01       	movw	r24, r28
    573e:	83 5a       	subi	r24, 0xA3	; 163
    5740:	9f 4f       	sbci	r25, 0xFF	; 255
    5742:	fc 01       	movw	r30, r24
    5744:	00 83       	st	Z, r16
    5746:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5748:	ce 01       	movw	r24, r28
    574a:	85 5a       	subi	r24, 0xA5	; 165
    574c:	9f 4f       	sbci	r25, 0xFF	; 255
    574e:	9e 01       	movw	r18, r28
    5750:	25 5a       	subi	r18, 0xA5	; 165
    5752:	3f 4f       	sbci	r19, 0xFF	; 255
    5754:	f9 01       	movw	r30, r18
    5756:	20 81       	ld	r18, Z
    5758:	31 81       	ldd	r19, Z+1	; 0x01
    575a:	21 50       	subi	r18, 0x01	; 1
    575c:	30 40       	sbci	r19, 0x00	; 0
    575e:	fc 01       	movw	r30, r24
    5760:	20 83       	st	Z, r18
    5762:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5764:	ce 01       	movw	r24, r28
    5766:	85 5a       	subi	r24, 0xA5	; 165
    5768:	9f 4f       	sbci	r25, 0xFF	; 255
    576a:	fc 01       	movw	r30, r24
    576c:	80 81       	ld	r24, Z
    576e:	91 81       	ldd	r25, Z+1	; 0x01
    5770:	00 97       	sbiw	r24, 0x00	; 0
    5772:	89 f6       	brne	.-94     	; 0x5716 <chb_set_state+0x82e>
    5774:	58 c0       	rjmp	.+176    	; 0x5826 <chb_set_state+0x93e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5776:	8e 01       	movw	r16, r28
    5778:	05 5a       	subi	r16, 0xA5	; 165
    577a:	1f 4f       	sbci	r17, 0xFF	; 255
    577c:	ce 01       	movw	r24, r28
    577e:	89 5a       	subi	r24, 0xA9	; 169
    5780:	9f 4f       	sbci	r25, 0xFF	; 255
    5782:	fc 01       	movw	r30, r24
    5784:	60 81       	ld	r22, Z
    5786:	71 81       	ldd	r23, Z+1	; 0x01
    5788:	82 81       	ldd	r24, Z+2	; 0x02
    578a:	93 81       	ldd	r25, Z+3	; 0x03
    578c:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    5790:	dc 01       	movw	r26, r24
    5792:	cb 01       	movw	r24, r22
    5794:	f8 01       	movw	r30, r16
    5796:	80 83       	st	Z, r24
    5798:	91 83       	std	Z+1, r25	; 0x01
    579a:	ce 01       	movw	r24, r28
    579c:	81 5a       	subi	r24, 0xA1	; 161
    579e:	9f 4f       	sbci	r25, 0xFF	; 255
    57a0:	9e 01       	movw	r18, r28
    57a2:	25 5a       	subi	r18, 0xA5	; 165
    57a4:	3f 4f       	sbci	r19, 0xFF	; 255
    57a6:	f9 01       	movw	r30, r18
    57a8:	20 81       	ld	r18, Z
    57aa:	31 81       	ldd	r19, Z+1	; 0x01
    57ac:	fc 01       	movw	r30, r24
    57ae:	20 83       	st	Z, r18
    57b0:	31 83       	std	Z+1, r19	; 0x01
    57b2:	ce 01       	movw	r24, r28
    57b4:	81 5a       	subi	r24, 0xA1	; 161
    57b6:	9f 4f       	sbci	r25, 0xFF	; 255
    57b8:	fc 01       	movw	r30, r24
    57ba:	80 81       	ld	r24, Z
    57bc:	91 81       	ldd	r25, Z+1	; 0x01
    57be:	8c 01       	movw	r16, r24
    57c0:	c8 01       	movw	r24, r16
    57c2:	01 97       	sbiw	r24, 0x01	; 1
    57c4:	f1 f7       	brne	.-4      	; 0x57c2 <chb_set_state+0x8da>
    57c6:	8c 01       	movw	r16, r24
    57c8:	ce 01       	movw	r24, r28
    57ca:	81 5a       	subi	r24, 0xA1	; 161
    57cc:	9f 4f       	sbci	r25, 0xFF	; 255
    57ce:	fc 01       	movw	r30, r24
    57d0:	00 83       	st	Z, r16
    57d2:	11 83       	std	Z+1, r17	; 0x01
    57d4:	28 c0       	rjmp	.+80     	; 0x5826 <chb_set_state+0x93e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    57d6:	8e 01       	movw	r16, r28
    57d8:	0e 5a       	subi	r16, 0xAE	; 174
    57da:	1f 4f       	sbci	r17, 0xFF	; 255
    57dc:	ce 01       	movw	r24, r28
    57de:	82 5b       	subi	r24, 0xB2	; 178
    57e0:	9f 4f       	sbci	r25, 0xFF	; 255
    57e2:	fc 01       	movw	r30, r24
    57e4:	60 81       	ld	r22, Z
    57e6:	71 81       	ldd	r23, Z+1	; 0x01
    57e8:	82 81       	ldd	r24, Z+2	; 0x02
    57ea:	93 81       	ldd	r25, Z+3	; 0x03
    57ec:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    57f0:	dc 01       	movw	r26, r24
    57f2:	cb 01       	movw	r24, r22
    57f4:	f8 01       	movw	r30, r16
    57f6:	80 83       	st	Z, r24
    57f8:	ce 01       	movw	r24, r28
    57fa:	8f 59       	subi	r24, 0x9F	; 159
    57fc:	9f 4f       	sbci	r25, 0xFF	; 255
    57fe:	9e 01       	movw	r18, r28
    5800:	2e 5a       	subi	r18, 0xAE	; 174
    5802:	3f 4f       	sbci	r19, 0xFF	; 255
    5804:	f9 01       	movw	r30, r18
    5806:	20 81       	ld	r18, Z
    5808:	fc 01       	movw	r30, r24
    580a:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    580c:	ce 01       	movw	r24, r28
    580e:	8f 59       	subi	r24, 0x9F	; 159
    5810:	9f 4f       	sbci	r25, 0xFF	; 255
    5812:	fc 01       	movw	r30, r24
    5814:	80 81       	ld	r24, Z
    5816:	18 2f       	mov	r17, r24
    5818:	1a 95       	dec	r17
    581a:	f1 f7       	brne	.-4      	; 0x5818 <chb_set_state+0x930>
    581c:	ce 01       	movw	r24, r28
    581e:	8f 59       	subi	r24, 0x9F	; 159
    5820:	9f 4f       	sbci	r25, 0xFF	; 255
    5822:	fc 01       	movw	r30, r24
    5824:	10 83       	st	Z, r17

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    5826:	0e 94 0d 22 	call	0x441a	; 0x441a <chb_get_state>
    582a:	28 2f       	mov	r18, r24
    582c:	ce 01       	movw	r24, r28
    582e:	8e 59       	subi	r24, 0x9E	; 158
    5830:	9f 4f       	sbci	r25, 0xFF	; 255
    5832:	fc 01       	movw	r30, r24
    5834:	80 81       	ld	r24, Z
    5836:	28 17       	cp	r18, r24
    5838:	11 f4       	brne	.+4      	; 0x583e <chb_set_state+0x956>
    {
        return RADIO_SUCCESS;
    583a:	80 e4       	ldi	r24, 0x40	; 64
    583c:	01 c0       	rjmp	.+2      	; 0x5840 <chb_set_state+0x958>
    }
    return RADIO_TIMED_OUT;
    583e:	83 e4       	ldi	r24, 0x43	; 67
}
    5840:	ce 59       	subi	r28, 0x9E	; 158
    5842:	df 4f       	sbci	r29, 0xFF	; 255
    5844:	cd bf       	out	0x3d, r28	; 61
    5846:	de bf       	out	0x3e, r29	; 62
    5848:	df 91       	pop	r29
    584a:	cf 91       	pop	r28
    584c:	1f 91       	pop	r17
    584e:	0f 91       	pop	r16
    5850:	08 95       	ret

00005852 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    5852:	cf 93       	push	r28
    5854:	df 93       	push	r29
    5856:	0f 92       	push	r0
    5858:	0f 92       	push	r0
    585a:	cd b7       	in	r28, 0x3d	; 61
    585c:	de b7       	in	r29, 0x3e	; 62
    585e:	89 83       	std	Y+1, r24	; 0x01
    5860:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    5862:	29 81       	ldd	r18, Y+1	; 0x01
    5864:	3a 81       	ldd	r19, Y+2	; 0x02
    5866:	80 e0       	ldi	r24, 0x00	; 0
    5868:	90 e0       	ldi	r25, 0x00	; 0
    586a:	b9 01       	movw	r22, r18
    586c:	48 e0       	ldi	r20, 0x08	; 8
    586e:	50 e0       	ldi	r21, 0x00	; 0
    5870:	0e 94 4c 30 	call	0x6098	; 0x6098 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    5874:	29 81       	ldd	r18, Y+1	; 0x01
    5876:	3a 81       	ldd	r19, Y+2	; 0x02
    5878:	84 e2       	ldi	r24, 0x24	; 36
    587a:	b9 01       	movw	r22, r18
    587c:	0e 94 ce 24 	call	0x499c	; 0x499c <chb_reg_write64>
}
    5880:	0f 90       	pop	r0
    5882:	0f 90       	pop	r0
    5884:	df 91       	pop	r29
    5886:	cf 91       	pop	r28
    5888:	08 95       	ret

0000588a <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    588a:	cf 93       	push	r28
    588c:	df 93       	push	r29
    588e:	0f 92       	push	r0
    5890:	0f 92       	push	r0
    5892:	cd b7       	in	r28, 0x3d	; 61
    5894:	de b7       	in	r29, 0x3e	; 62
    5896:	89 83       	std	Y+1, r24	; 0x01
    5898:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    589a:	29 81       	ldd	r18, Y+1	; 0x01
    589c:	3a 81       	ldd	r19, Y+2	; 0x02
    589e:	80 e0       	ldi	r24, 0x00	; 0
    58a0:	90 e0       	ldi	r25, 0x00	; 0
    58a2:	b9 01       	movw	r22, r18
    58a4:	48 e0       	ldi	r20, 0x08	; 8
    58a6:	50 e0       	ldi	r21, 0x00	; 0
    58a8:	0e 94 88 30 	call	0x6110	; 0x6110 <chb_eeprom_read>
}
    58ac:	0f 90       	pop	r0
    58ae:	0f 90       	pop	r0
    58b0:	df 91       	pop	r29
    58b2:	cf 91       	pop	r28
    58b4:	08 95       	ret

000058b6 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    58b6:	cf 93       	push	r28
    58b8:	df 93       	push	r29
    58ba:	00 d0       	rcall	.+0      	; 0x58bc <chb_set_short_addr+0x6>
    58bc:	00 d0       	rcall	.+0      	; 0x58be <chb_set_short_addr+0x8>
    58be:	cd b7       	in	r28, 0x3d	; 61
    58c0:	de b7       	in	r29, 0x3e	; 62
    58c2:	8d 83       	std	Y+5, r24	; 0x05
    58c4:	9e 83       	std	Y+6, r25	; 0x06
    U8 *addr_ptr = (U8 *)&addr;
    58c6:	ce 01       	movw	r24, r28
    58c8:	05 96       	adiw	r24, 0x05	; 5
    58ca:	89 83       	std	Y+1, r24	; 0x01
    58cc:	9a 83       	std	Y+2, r25	; 0x02
    pcb_t *pcb = chb_get_pcb();
    58ce:	0e 94 04 1f 	call	0x3e08	; 0x3e08 <chb_get_pcb>
    58d2:	8b 83       	std	Y+3, r24	; 0x03
    58d4:	9c 83       	std	Y+4, r25	; 0x04

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    58d6:	29 81       	ldd	r18, Y+1	; 0x01
    58d8:	3a 81       	ldd	r19, Y+2	; 0x02
    58da:	89 e0       	ldi	r24, 0x09	; 9
    58dc:	90 e0       	ldi	r25, 0x00	; 0
    58de:	b9 01       	movw	r22, r18
    58e0:	42 e0       	ldi	r20, 0x02	; 2
    58e2:	50 e0       	ldi	r21, 0x00	; 0
    58e4:	0e 94 4c 30 	call	0x6098	; 0x6098 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    58e8:	2d 81       	ldd	r18, Y+5	; 0x05
    58ea:	3e 81       	ldd	r19, Y+6	; 0x06
    58ec:	80 e2       	ldi	r24, 0x20	; 32
    58ee:	b9 01       	movw	r22, r18
    58f0:	0e 94 9d 24 	call	0x493a	; 0x493a <chb_reg_write16>
    pcb->src_addr = addr;
    58f4:	2d 81       	ldd	r18, Y+5	; 0x05
    58f6:	3e 81       	ldd	r19, Y+6	; 0x06
    58f8:	8b 81       	ldd	r24, Y+3	; 0x03
    58fa:	9c 81       	ldd	r25, Y+4	; 0x04
    58fc:	fc 01       	movw	r30, r24
    58fe:	20 83       	st	Z, r18
    5900:	31 83       	std	Z+1, r19	; 0x01
}
    5902:	26 96       	adiw	r28, 0x06	; 6
    5904:	cd bf       	out	0x3d, r28	; 61
    5906:	de bf       	out	0x3e, r29	; 62
    5908:	df 91       	pop	r29
    590a:	cf 91       	pop	r28
    590c:	08 95       	ret

0000590e <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    590e:	cf 93       	push	r28
    5910:	df 93       	push	r29
    5912:	0f 92       	push	r0
    5914:	0f 92       	push	r0
    5916:	cd b7       	in	r28, 0x3d	; 61
    5918:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    591a:	89 e0       	ldi	r24, 0x09	; 9
    591c:	90 e0       	ldi	r25, 0x00	; 0
    591e:	9e 01       	movw	r18, r28
    5920:	2f 5f       	subi	r18, 0xFF	; 255
    5922:	3f 4f       	sbci	r19, 0xFF	; 255
    5924:	b9 01       	movw	r22, r18
    5926:	42 e0       	ldi	r20, 0x02	; 2
    5928:	50 e0       	ldi	r21, 0x00	; 0
    592a:	0e 94 88 30 	call	0x6110	; 0x6110 <chb_eeprom_read>
    return *(U16 *)addr;
    592e:	ce 01       	movw	r24, r28
    5930:	01 96       	adiw	r24, 0x01	; 1
    5932:	fc 01       	movw	r30, r24
    5934:	80 81       	ld	r24, Z
    5936:	91 81       	ldd	r25, Z+1	; 0x01
}
    5938:	0f 90       	pop	r0
    593a:	0f 90       	pop	r0
    593c:	df 91       	pop	r29
    593e:	cf 91       	pop	r28
    5940:	08 95       	ret

00005942 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    5942:	cf 93       	push	r28
    5944:	df 93       	push	r29
    5946:	cd b7       	in	r28, 0x3d	; 61
    5948:	de b7       	in	r29, 0x3e	; 62
    594a:	28 97       	sbiw	r28, 0x08	; 8
    594c:	cd bf       	out	0x3d, r28	; 61
    594e:	de bf       	out	0x3e, r29	; 62
    5950:	8c 83       	std	Y+4, r24	; 0x04
    5952:	9d 83       	std	Y+5, r25	; 0x05
    5954:	6e 83       	std	Y+6, r22	; 0x06
    5956:	7f 83       	std	Y+7, r23	; 0x07
    5958:	48 87       	std	Y+8, r20	; 0x08
    U8 state = chb_get_state();
    595a:	0e 94 0d 22 	call	0x441a	; 0x441a <chb_get_state>
    595e:	89 83       	std	Y+1, r24	; 0x01
    pcb_t *pcb = chb_get_pcb();
    5960:	0e 94 04 1f 	call	0x3e08	; 0x3e08 <chb_get_pcb>
    5964:	8a 83       	std	Y+2, r24	; 0x02
    5966:	9b 83       	std	Y+3, r25	; 0x03

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    5968:	89 81       	ldd	r24, Y+1	; 0x01
    596a:	82 30       	cpi	r24, 0x02	; 2
    596c:	19 f0       	breq	.+6      	; 0x5974 <chb_tx+0x32>
    596e:	89 81       	ldd	r24, Y+1	; 0x01
    5970:	82 31       	cpi	r24, 0x12	; 18
    5972:	11 f4       	brne	.+4      	; 0x5978 <chb_tx+0x36>
    {
        return RADIO_WRONG_STATE;
    5974:	84 e4       	ldi	r24, 0x44	; 68
    5976:	23 c0       	rjmp	.+70     	; 0x59be <chb_tx+0x7c>
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    5978:	88 e0       	ldi	r24, 0x08	; 8
    597a:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    597e:	89 e1       	ldi	r24, 0x19	; 25
    5980:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    5984:	8c 81       	ldd	r24, Y+4	; 0x04
    5986:	9d 81       	ldd	r25, Y+5	; 0x05
    5988:	2e 81       	ldd	r18, Y+6	; 0x06
    598a:	3f 81       	ldd	r19, Y+7	; 0x07
    598c:	6a e0       	ldi	r22, 0x0A	; 10
    598e:	a9 01       	movw	r20, r18
    5990:	28 85       	ldd	r18, Y+8	; 0x08
    5992:	0e 94 1b 25 	call	0x4a36	; 0x4a36 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    5996:	82 e0       	ldi	r24, 0x02	; 2
    5998:	62 e0       	ldi	r22, 0x02	; 2
    599a:	4f e1       	ldi	r20, 0x1F	; 31
    599c:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    59a0:	00 00       	nop
    59a2:	8a 81       	ldd	r24, Y+2	; 0x02
    59a4:	9b 81       	ldd	r25, Y+3	; 0x03
    59a6:	fc 01       	movw	r30, r24
    59a8:	94 81       	ldd	r25, Z+4	; 0x04
    59aa:	81 e0       	ldi	r24, 0x01	; 1
    59ac:	89 27       	eor	r24, r25
    59ae:	88 23       	and	r24, r24
    59b0:	c1 f7       	brne	.-16     	; 0x59a2 <chb_tx+0x60>
    pcb->tx_end = false;
    59b2:	8a 81       	ldd	r24, Y+2	; 0x02
    59b4:	9b 81       	ldd	r25, Y+3	; 0x03
    59b6:	fc 01       	movw	r30, r24
    59b8:	14 82       	std	Z+4, r1	; 0x04

    // check the status of the transmission
    return chb_get_status();
    59ba:	0e 94 18 22 	call	0x4430	; 0x4430 <chb_get_status>
}
    59be:	28 96       	adiw	r28, 0x08	; 8
    59c0:	cd bf       	out	0x3d, r28	; 61
    59c2:	de bf       	out	0x3e, r29	; 62
    59c4:	df 91       	pop	r29
    59c6:	cf 91       	pop	r28
    59c8:	08 95       	ret

000059ca <chb_sleep>:
/*!
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    59ca:	0f 93       	push	r16
    59cc:	1f 93       	push	r17
    59ce:	cf 93       	push	r28
    59d0:	df 93       	push	r29
    59d2:	cd b7       	in	r28, 0x3d	; 61
    59d4:	de b7       	in	r29, 0x3e	; 62
    59d6:	69 97       	sbiw	r28, 0x19	; 25
    59d8:	cd bf       	out	0x3d, r28	; 61
    59da:	de bf       	out	0x3e, r29	; 62
    59dc:	89 8f       	std	Y+25, r24	; 0x19
    if (enb)
    59de:	89 8d       	ldd	r24, Y+25	; 0x19
    59e0:	88 23       	and	r24, r24
    59e2:	69 f0       	breq	.+26     	; 0x59fe <chb_sleep+0x34>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    59e4:	88 e0       	ldi	r24, 0x08	; 8
    59e6:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    59ea:	84 e6       	ldi	r24, 0x64	; 100
    59ec:	96 e0       	ldi	r25, 0x06	; 6
    59ee:	24 e6       	ldi	r18, 0x64	; 100
    59f0:	36 e0       	ldi	r19, 0x06	; 6
    59f2:	f9 01       	movw	r30, r18
    59f4:	20 81       	ld	r18, Z
    59f6:	22 60       	ori	r18, 0x02	; 2
    59f8:	fc 01       	movw	r30, r24
    59fa:	20 83       	st	Z, r18
    59fc:	e1 c0       	rjmp	.+450    	; 0x5bc0 <chb_sleep+0x1f6>
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    59fe:	84 e6       	ldi	r24, 0x64	; 100
    5a00:	96 e0       	ldi	r25, 0x06	; 6
    5a02:	24 e6       	ldi	r18, 0x64	; 100
    5a04:	36 e0       	ldi	r19, 0x06	; 6
    5a06:	f9 01       	movw	r30, r18
    5a08:	20 81       	ld	r18, Z
    5a0a:	2d 7f       	andi	r18, 0xFD	; 253
    5a0c:	fc 01       	movw	r30, r24
    5a0e:	20 83       	st	Z, r18
    5a10:	80 e0       	ldi	r24, 0x00	; 0
    5a12:	90 e0       	ldi	r25, 0x00	; 0
    5a14:	a0 e7       	ldi	r26, 0x70	; 112
    5a16:	b3 e4       	ldi	r27, 0x43	; 67
    5a18:	89 83       	std	Y+1, r24	; 0x01
    5a1a:	9a 83       	std	Y+2, r25	; 0x02
    5a1c:	ab 83       	std	Y+3, r26	; 0x03
    5a1e:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5a20:	69 81       	ldd	r22, Y+1	; 0x01
    5a22:	7a 81       	ldd	r23, Y+2	; 0x02
    5a24:	8b 81       	ldd	r24, Y+3	; 0x03
    5a26:	9c 81       	ldd	r25, Y+4	; 0x04
    5a28:	2b ea       	ldi	r18, 0xAB	; 171
    5a2a:	3a ea       	ldi	r19, 0xAA	; 170
    5a2c:	4a ea       	ldi	r20, 0xAA	; 170
    5a2e:	5e e3       	ldi	r21, 0x3E	; 62
    5a30:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    5a34:	dc 01       	movw	r26, r24
    5a36:	cb 01       	movw	r24, r22
    5a38:	8d 83       	std	Y+5, r24	; 0x05
    5a3a:	9e 83       	std	Y+6, r25	; 0x06
    5a3c:	af 83       	std	Y+7, r26	; 0x07
    5a3e:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    5a40:	11 e0       	ldi	r17, 0x01	; 1
    5a42:	6d 81       	ldd	r22, Y+5	; 0x05
    5a44:	7e 81       	ldd	r23, Y+6	; 0x06
    5a46:	8f 81       	ldd	r24, Y+7	; 0x07
    5a48:	98 85       	ldd	r25, Y+8	; 0x08
    5a4a:	20 e0       	ldi	r18, 0x00	; 0
    5a4c:	30 e0       	ldi	r19, 0x00	; 0
    5a4e:	40 e8       	ldi	r20, 0x80	; 128
    5a50:	5f e3       	ldi	r21, 0x3F	; 63
    5a52:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    5a56:	88 23       	and	r24, r24
    5a58:	0c f0       	brlt	.+2      	; 0x5a5c <chb_sleep+0x92>
    5a5a:	10 e0       	ldi	r17, 0x00	; 0
    5a5c:	11 23       	and	r17, r17
    5a5e:	19 f0       	breq	.+6      	; 0x5a66 <chb_sleep+0x9c>
		__ticks = 1;
    5a60:	81 e0       	ldi	r24, 0x01	; 1
    5a62:	89 87       	std	Y+9, r24	; 0x09
    5a64:	a3 c0       	rjmp	.+326    	; 0x5bac <chb_sleep+0x1e2>
	else if (__tmp > 255)
    5a66:	11 e0       	ldi	r17, 0x01	; 1
    5a68:	6d 81       	ldd	r22, Y+5	; 0x05
    5a6a:	7e 81       	ldd	r23, Y+6	; 0x06
    5a6c:	8f 81       	ldd	r24, Y+7	; 0x07
    5a6e:	98 85       	ldd	r25, Y+8	; 0x08
    5a70:	20 e0       	ldi	r18, 0x00	; 0
    5a72:	30 e0       	ldi	r19, 0x00	; 0
    5a74:	4f e7       	ldi	r20, 0x7F	; 127
    5a76:	53 e4       	ldi	r21, 0x43	; 67
    5a78:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    5a7c:	18 16       	cp	r1, r24
    5a7e:	0c f0       	brlt	.+2      	; 0x5a82 <chb_sleep+0xb8>
    5a80:	10 e0       	ldi	r17, 0x00	; 0
    5a82:	11 23       	and	r17, r17
    5a84:	09 f4       	brne	.+2      	; 0x5a88 <chb_sleep+0xbe>
    5a86:	89 c0       	rjmp	.+274    	; 0x5b9a <chb_sleep+0x1d0>
	{
		_delay_ms(__us / 1000.0);
    5a88:	69 81       	ldd	r22, Y+1	; 0x01
    5a8a:	7a 81       	ldd	r23, Y+2	; 0x02
    5a8c:	8b 81       	ldd	r24, Y+3	; 0x03
    5a8e:	9c 81       	ldd	r25, Y+4	; 0x04
    5a90:	20 e0       	ldi	r18, 0x00	; 0
    5a92:	30 e0       	ldi	r19, 0x00	; 0
    5a94:	4a e7       	ldi	r20, 0x7A	; 122
    5a96:	54 e4       	ldi	r21, 0x44	; 68
    5a98:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
    5a9c:	dc 01       	movw	r26, r24
    5a9e:	cb 01       	movw	r24, r22
    5aa0:	8a 87       	std	Y+10, r24	; 0x0a
    5aa2:	9b 87       	std	Y+11, r25	; 0x0b
    5aa4:	ac 87       	std	Y+12, r26	; 0x0c
    5aa6:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5aa8:	6a 85       	ldd	r22, Y+10	; 0x0a
    5aaa:	7b 85       	ldd	r23, Y+11	; 0x0b
    5aac:	8c 85       	ldd	r24, Y+12	; 0x0c
    5aae:	9d 85       	ldd	r25, Y+13	; 0x0d
    5ab0:	20 e0       	ldi	r18, 0x00	; 0
    5ab2:	30 e0       	ldi	r19, 0x00	; 0
    5ab4:	4a e7       	ldi	r20, 0x7A	; 122
    5ab6:	53 e4       	ldi	r21, 0x43	; 67
    5ab8:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    5abc:	dc 01       	movw	r26, r24
    5abe:	cb 01       	movw	r24, r22
    5ac0:	8e 87       	std	Y+14, r24	; 0x0e
    5ac2:	9f 87       	std	Y+15, r25	; 0x0f
    5ac4:	a8 8b       	std	Y+16, r26	; 0x10
    5ac6:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    5ac8:	11 e0       	ldi	r17, 0x01	; 1
    5aca:	6e 85       	ldd	r22, Y+14	; 0x0e
    5acc:	7f 85       	ldd	r23, Y+15	; 0x0f
    5ace:	88 89       	ldd	r24, Y+16	; 0x10
    5ad0:	99 89       	ldd	r25, Y+17	; 0x11
    5ad2:	20 e0       	ldi	r18, 0x00	; 0
    5ad4:	30 e0       	ldi	r19, 0x00	; 0
    5ad6:	40 e8       	ldi	r20, 0x80	; 128
    5ad8:	5f e3       	ldi	r21, 0x3F	; 63
    5ada:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    5ade:	88 23       	and	r24, r24
    5ae0:	0c f0       	brlt	.+2      	; 0x5ae4 <chb_sleep+0x11a>
    5ae2:	10 e0       	ldi	r17, 0x00	; 0
    5ae4:	11 23       	and	r17, r17
    5ae6:	29 f0       	breq	.+10     	; 0x5af2 <chb_sleep+0x128>
		__ticks = 1;
    5ae8:	81 e0       	ldi	r24, 0x01	; 1
    5aea:	90 e0       	ldi	r25, 0x00	; 0
    5aec:	8a 8b       	std	Y+18, r24	; 0x12
    5aee:	9b 8b       	std	Y+19, r25	; 0x13
    5af0:	46 c0       	rjmp	.+140    	; 0x5b7e <chb_sleep+0x1b4>
	else if (__tmp > 65535)
    5af2:	11 e0       	ldi	r17, 0x01	; 1
    5af4:	6e 85       	ldd	r22, Y+14	; 0x0e
    5af6:	7f 85       	ldd	r23, Y+15	; 0x0f
    5af8:	88 89       	ldd	r24, Y+16	; 0x10
    5afa:	99 89       	ldd	r25, Y+17	; 0x11
    5afc:	20 e0       	ldi	r18, 0x00	; 0
    5afe:	3f ef       	ldi	r19, 0xFF	; 255
    5b00:	4f e7       	ldi	r20, 0x7F	; 127
    5b02:	57 e4       	ldi	r21, 0x47	; 71
    5b04:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    5b08:	18 16       	cp	r1, r24
    5b0a:	0c f0       	brlt	.+2      	; 0x5b0e <chb_sleep+0x144>
    5b0c:	10 e0       	ldi	r17, 0x00	; 0
    5b0e:	11 23       	and	r17, r17
    5b10:	61 f1       	breq	.+88     	; 0x5b6a <chb_sleep+0x1a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5b12:	6a 85       	ldd	r22, Y+10	; 0x0a
    5b14:	7b 85       	ldd	r23, Y+11	; 0x0b
    5b16:	8c 85       	ldd	r24, Y+12	; 0x0c
    5b18:	9d 85       	ldd	r25, Y+13	; 0x0d
    5b1a:	20 e0       	ldi	r18, 0x00	; 0
    5b1c:	30 e0       	ldi	r19, 0x00	; 0
    5b1e:	40 e2       	ldi	r20, 0x20	; 32
    5b20:	51 e4       	ldi	r21, 0x41	; 65
    5b22:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    5b26:	dc 01       	movw	r26, r24
    5b28:	cb 01       	movw	r24, r22
    5b2a:	bc 01       	movw	r22, r24
    5b2c:	cd 01       	movw	r24, r26
    5b2e:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    5b32:	dc 01       	movw	r26, r24
    5b34:	cb 01       	movw	r24, r22
    5b36:	8a 8b       	std	Y+18, r24	; 0x12
    5b38:	9b 8b       	std	Y+19, r25	; 0x13
    5b3a:	12 c0       	rjmp	.+36     	; 0x5b60 <chb_sleep+0x196>
    5b3c:	89 e1       	ldi	r24, 0x19	; 25
    5b3e:	90 e0       	ldi	r25, 0x00	; 0
    5b40:	8c 8b       	std	Y+20, r24	; 0x14
    5b42:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5b44:	8c 89       	ldd	r24, Y+20	; 0x14
    5b46:	9d 89       	ldd	r25, Y+21	; 0x15
    5b48:	8c 01       	movw	r16, r24
    5b4a:	c8 01       	movw	r24, r16
    5b4c:	01 97       	sbiw	r24, 0x01	; 1
    5b4e:	f1 f7       	brne	.-4      	; 0x5b4c <chb_sleep+0x182>
    5b50:	8c 01       	movw	r16, r24
    5b52:	0c 8b       	std	Y+20, r16	; 0x14
    5b54:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5b56:	8a 89       	ldd	r24, Y+18	; 0x12
    5b58:	9b 89       	ldd	r25, Y+19	; 0x13
    5b5a:	01 97       	sbiw	r24, 0x01	; 1
    5b5c:	8a 8b       	std	Y+18, r24	; 0x12
    5b5e:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5b60:	8a 89       	ldd	r24, Y+18	; 0x12
    5b62:	9b 89       	ldd	r25, Y+19	; 0x13
    5b64:	00 97       	sbiw	r24, 0x00	; 0
    5b66:	51 f7       	brne	.-44     	; 0x5b3c <chb_sleep+0x172>
    5b68:	28 c0       	rjmp	.+80     	; 0x5bba <chb_sleep+0x1f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5b6a:	6e 85       	ldd	r22, Y+14	; 0x0e
    5b6c:	7f 85       	ldd	r23, Y+15	; 0x0f
    5b6e:	88 89       	ldd	r24, Y+16	; 0x10
    5b70:	99 89       	ldd	r25, Y+17	; 0x11
    5b72:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    5b76:	dc 01       	movw	r26, r24
    5b78:	cb 01       	movw	r24, r22
    5b7a:	8a 8b       	std	Y+18, r24	; 0x12
    5b7c:	9b 8b       	std	Y+19, r25	; 0x13
    5b7e:	8a 89       	ldd	r24, Y+18	; 0x12
    5b80:	9b 89       	ldd	r25, Y+19	; 0x13
    5b82:	8e 8b       	std	Y+22, r24	; 0x16
    5b84:	9f 8b       	std	Y+23, r25	; 0x17
    5b86:	8e 89       	ldd	r24, Y+22	; 0x16
    5b88:	9f 89       	ldd	r25, Y+23	; 0x17
    5b8a:	8c 01       	movw	r16, r24
    5b8c:	f8 01       	movw	r30, r16
    5b8e:	31 97       	sbiw	r30, 0x01	; 1
    5b90:	f1 f7       	brne	.-4      	; 0x5b8e <chb_sleep+0x1c4>
    5b92:	8f 01       	movw	r16, r30
    5b94:	0e 8b       	std	Y+22, r16	; 0x16
    5b96:	1f 8b       	std	Y+23, r17	; 0x17
    5b98:	10 c0       	rjmp	.+32     	; 0x5bba <chb_sleep+0x1f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5b9a:	6d 81       	ldd	r22, Y+5	; 0x05
    5b9c:	7e 81       	ldd	r23, Y+6	; 0x06
    5b9e:	8f 81       	ldd	r24, Y+7	; 0x07
    5ba0:	98 85       	ldd	r25, Y+8	; 0x08
    5ba2:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    5ba6:	dc 01       	movw	r26, r24
    5ba8:	cb 01       	movw	r24, r22
    5baa:	89 87       	std	Y+9, r24	; 0x09
    5bac:	89 85       	ldd	r24, Y+9	; 0x09
    5bae:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5bb0:	88 8d       	ldd	r24, Y+24	; 0x18
    5bb2:	18 2f       	mov	r17, r24
    5bb4:	1a 95       	dec	r17
    5bb6:	f1 f7       	brne	.-4      	; 0x5bb4 <chb_sleep+0x1ea>
    5bb8:	18 8f       	std	Y+24, r17	; 0x18

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    5bba:	86 e1       	ldi	r24, 0x16	; 22
    5bbc:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <chb_set_state>
    }
}
    5bc0:	69 96       	adiw	r28, 0x19	; 25
    5bc2:	cd bf       	out	0x3d, r28	; 61
    5bc4:	de bf       	out	0x3e, r29	; 62
    5bc6:	df 91       	pop	r29
    5bc8:	cf 91       	pop	r28
    5bca:	1f 91       	pop	r17
    5bcc:	0f 91       	pop	r16
    5bce:	08 95       	ret

00005bd0 <chb_radio_init>:
/*!

*/
/**************************************************************************/
static void chb_radio_init()
{
    5bd0:	cf 93       	push	r28
    5bd2:	df 93       	push	r29
    5bd4:	cd b7       	in	r28, 0x3d	; 61
    5bd6:	de b7       	in	r29, 0x3e	; 62
    5bd8:	ea 97       	sbiw	r28, 0x3a	; 58
    5bda:	cd bf       	out	0x3d, r28	; 61
    5bdc:	de bf       	out	0x3e, r29	; 62
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    5bde:	0e 94 25 22 	call	0x444a	; 0x444a <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    5be2:	8e e0       	ldi	r24, 0x0E	; 14
    5be4:	60 e0       	ldi	r22, 0x00	; 0
    5be6:	0e 94 71 24 	call	0x48e2	; 0x48e2 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    5bea:	82 e0       	ldi	r24, 0x02	; 2
    5bec:	63 e0       	ldi	r22, 0x03	; 3
    5bee:	4f e1       	ldi	r20, 0x1F	; 31
    5bf0:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    5bf4:	00 00       	nop
    5bf6:	81 e0       	ldi	r24, 0x01	; 1
    5bf8:	0e 94 11 24 	call	0x4822	; 0x4822 <chb_reg_read>
    5bfc:	88 2f       	mov	r24, r24
    5bfe:	90 e0       	ldi	r25, 0x00	; 0
    5c00:	8f 71       	andi	r24, 0x1F	; 31
    5c02:	90 70       	andi	r25, 0x00	; 0
    5c04:	88 30       	cpi	r24, 0x08	; 8
    5c06:	91 05       	cpc	r25, r1
    5c08:	b1 f7       	brne	.-20     	; 0x5bf6 <chb_radio_init+0x26>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    5c0a:	8e e2       	ldi	r24, 0x2E	; 46
    5c0c:	60 e4       	ldi	r22, 0x40	; 64
    5c0e:	40 ec       	ldi	r20, 0xC0	; 192
    5c10:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    5c14:	8e e0       	ldi	r24, 0x0E	; 14
    5c16:	6c e0       	ldi	r22, 0x0C	; 12
    5c18:	0e 94 71 24 	call	0x48e2	; 0x48e2 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    5c1c:	84 e0       	ldi	r24, 0x04	; 4
    5c1e:	60 e2       	ldi	r22, 0x20	; 32
    5c20:	40 e2       	ldi	r20, 0x20	; 32
    5c22:	0e 94 f6 24 	call	0x49ec	; 0x49ec <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    5c26:	81 e0       	ldi	r24, 0x01	; 1
    5c28:	0e 94 16 26 	call	0x4c2c	; 0x4c2c <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    5c2c:	81 e0       	ldi	r24, 0x01	; 1
    5c2e:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    5c32:	86 e1       	ldi	r24, 0x16	; 22
    5c34:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    5c38:	82 e2       	ldi	r24, 0x22	; 34
    5c3a:	64 e3       	ldi	r22, 0x34	; 52
    5c3c:	72 e1       	ldi	r23, 0x12	; 18
    5c3e:	0e 94 9d 24 	call	0x493a	; 0x493a <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    5c42:	0e 94 87 2c 	call	0x590e	; 0x590e <chb_get_short_addr>
    5c46:	9c 01       	movw	r18, r24
    5c48:	80 e2       	ldi	r24, 0x20	; 32
    5c4a:	b9 01       	movw	r22, r18
    5c4c:	0e 94 9d 24 	call	0x493a	; 0x493a <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    5c50:	ce 01       	movw	r24, r28
    5c52:	01 96       	adiw	r24, 0x01	; 1
    5c54:	0e 94 45 2c 	call	0x588a	; 0x588a <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    5c58:	84 e2       	ldi	r24, 0x24	; 36
    5c5a:	9e 01       	movw	r18, r28
    5c5c:	2f 5f       	subi	r18, 0xFF	; 255
    5c5e:	3f 4f       	sbci	r19, 0xFF	; 255
    5c60:	b9 01       	movw	r22, r18
    5c62:	0e 94 ce 24 	call	0x499c	; 0x499c <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    5c66:	82 e7       	ldi	r24, 0x72	; 114
    5c68:	96 e0       	ldi	r25, 0x06	; 6
    5c6a:	22 e7       	ldi	r18, 0x72	; 114
    5c6c:	36 e0       	ldi	r19, 0x06	; 6
    5c6e:	f9 01       	movw	r30, r18
    5c70:	20 81       	ld	r18, Z
    5c72:	21 60       	ori	r18, 0x01	; 1
    5c74:	fc 01       	movw	r30, r24
    5c76:	20 83       	st	Z, r18
    5c78:	89 e6       	ldi	r24, 0x69	; 105
    5c7a:	96 e0       	ldi	r25, 0x06	; 6
    5c7c:	29 e6       	ldi	r18, 0x69	; 105
    5c7e:	36 e0       	ldi	r19, 0x06	; 6
    5c80:	f9 01       	movw	r30, r18
    5c82:	20 81       	ld	r18, Z
    5c84:	23 60       	ori	r18, 0x03	; 3
    5c86:	fc 01       	movw	r30, r24
    5c88:	20 83       	st	Z, r18
    5c8a:	8a e6       	ldi	r24, 0x6A	; 106
    5c8c:	96 e0       	ldi	r25, 0x06	; 6
    5c8e:	2a e6       	ldi	r18, 0x6A	; 106
    5c90:	36 e0       	ldi	r19, 0x06	; 6
    5c92:	f9 01       	movw	r30, r18
    5c94:	20 81       	ld	r18, Z
    5c96:	24 60       	ori	r18, 0x04	; 4
    5c98:	fc 01       	movw	r30, r24
    5c9a:	20 83       	st	Z, r18
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    5c9c:	80 ea       	ldi	r24, 0xA0	; 160
    5c9e:	90 e0       	ldi	r25, 0x00	; 0
    5ca0:	20 ea       	ldi	r18, 0xA0	; 160
    5ca2:	30 e0       	ldi	r19, 0x00	; 0
    5ca4:	f9 01       	movw	r30, r18
    5ca6:	22 81       	ldd	r18, Z+2	; 0x02
    5ca8:	27 60       	ori	r18, 0x07	; 7
    5caa:	fc 01       	movw	r30, r24
    5cac:	22 83       	std	Z+2, r18	; 0x02

    if (chb_get_state() != RX_STATE)
    5cae:	0e 94 0d 22 	call	0x441a	; 0x441a <chb_get_state>
    5cb2:	86 31       	cpi	r24, 0x16	; 22
    5cb4:	b1 f0       	breq	.+44     	; 0x5ce2 <chb_radio_init+0x112>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    5cb6:	ce 01       	movw	r24, r28
    5cb8:	09 96       	adiw	r24, 0x09	; 9
    5cba:	2c e0       	ldi	r18, 0x0C	; 12
    5cbc:	32 e0       	ldi	r19, 0x02	; 2
    5cbe:	b9 01       	movw	r22, r18
    5cc0:	0e 94 bd 63 	call	0xc77a	; 0xc77a <strcpy_P>
        printf(buf);
    5cc4:	0f 92       	push	r0
    5cc6:	0f 92       	push	r0
    5cc8:	8d b7       	in	r24, 0x3d	; 61
    5cca:	9e b7       	in	r25, 0x3e	; 62
    5ccc:	01 96       	adiw	r24, 0x01	; 1
    5cce:	9e 01       	movw	r18, r28
    5cd0:	27 5f       	subi	r18, 0xF7	; 247
    5cd2:	3f 4f       	sbci	r19, 0xFF	; 255
    5cd4:	fc 01       	movw	r30, r24
    5cd6:	20 83       	st	Z, r18
    5cd8:	31 83       	std	Z+1, r19	; 0x01
    5cda:	0e 94 19 64 	call	0xc832	; 0xc832 <printf>
    5cde:	0f 90       	pop	r0
    5ce0:	0f 90       	pop	r0
    }
	StartOfFreeSpace = 0; //set location in FRAM Buffer at which to start storing radio messages to the start of the buffer
    5ce2:	10 92 bf 50 	sts	0x50BF, r1
    5ce6:	10 92 c0 50 	sts	0x50C0, r1
    5cea:	10 92 c1 50 	sts	0x50C1, r1
    5cee:	10 92 c2 50 	sts	0x50C2, r1
}
    5cf2:	ea 96       	adiw	r28, 0x3a	; 58
    5cf4:	cd bf       	out	0x3d, r28	; 61
    5cf6:	de bf       	out	0x3e, r29	; 62
    5cf8:	df 91       	pop	r29
    5cfa:	cf 91       	pop	r28
    5cfc:	08 95       	ret

00005cfe <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    5cfe:	cf 93       	push	r28
    5d00:	df 93       	push	r29
    5d02:	cd b7       	in	r28, 0x3d	; 61
    5d04:	de b7       	in	r29, 0x3e	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    5d06:	0e 94 c8 30 	call	0x6190	; 0x6190 <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    5d0a:	80 e6       	ldi	r24, 0x60	; 96
    5d0c:	96 e0       	ldi	r25, 0x06	; 6
    5d0e:	20 e6       	ldi	r18, 0x60	; 96
    5d10:	36 e0       	ldi	r19, 0x06	; 6
    5d12:	f9 01       	movw	r30, r18
    5d14:	20 81       	ld	r18, Z
    5d16:	22 60       	ori	r18, 0x02	; 2
    5d18:	fc 01       	movw	r30, r24
    5d1a:	20 83       	st	Z, r18
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    5d1c:	80 e6       	ldi	r24, 0x60	; 96
    5d1e:	96 e0       	ldi	r25, 0x06	; 6
    5d20:	20 e6       	ldi	r18, 0x60	; 96
    5d22:	36 e0       	ldi	r19, 0x06	; 6
    5d24:	f9 01       	movw	r30, r18
    5d26:	20 81       	ld	r18, Z
    5d28:	21 60       	ori	r18, 0x01	; 1
    5d2a:	fc 01       	movw	r30, r24
    5d2c:	20 83       	st	Z, r18

    // config radio
    chb_radio_init();
    5d2e:	0e 94 e8 2d 	call	0x5bd0	; 0x5bd0 <chb_radio_init>
}
    5d32:	df 91       	pop	r29
    5d34:	cf 91       	pop	r28
    5d36:	08 95       	ret

00005d38 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    5d38:	1f 92       	push	r1
    5d3a:	0f 92       	push	r0
    5d3c:	0f b6       	in	r0, 0x3f	; 63
    5d3e:	0f 92       	push	r0
    5d40:	00 90 3b 00 	lds	r0, 0x003B
    5d44:	0f 92       	push	r0
    5d46:	11 24       	eor	r1, r1
    5d48:	2f 93       	push	r18
    5d4a:	3f 93       	push	r19
    5d4c:	4f 93       	push	r20
    5d4e:	5f 93       	push	r21
    5d50:	6f 93       	push	r22
    5d52:	7f 93       	push	r23
    5d54:	8f 93       	push	r24
    5d56:	9f 93       	push	r25
    5d58:	af 93       	push	r26
    5d5a:	bf 93       	push	r27
    5d5c:	ef 93       	push	r30
    5d5e:	ff 93       	push	r31
    5d60:	cf 93       	push	r28
    5d62:	df 93       	push	r29
    5d64:	cd b7       	in	r28, 0x3d	; 61
    5d66:	de b7       	in	r29, 0x3e	; 62
    5d68:	25 97       	sbiw	r28, 0x05	; 5
    5d6a:	cd bf       	out	0x3d, r28	; 61
    5d6c:	de bf       	out	0x3e, r29	; 62
    U8 dummy, state, intp_src = 0;
    5d6e:	19 82       	std	Y+1, r1	; 0x01
    pcb_t *pcb = chb_get_pcb();
    5d70:	0e 94 04 1f 	call	0x3e08	; 0x3e08 <chb_get_pcb>
    5d74:	8a 83       	std	Y+2, r24	; 0x02
    5d76:	9b 83       	std	Y+3, r25	; 0x03

    CHB_ENTER_CRIT();
    5d78:	8f e3       	ldi	r24, 0x3F	; 63
    5d7a:	90 e0       	ldi	r25, 0x00	; 0
    5d7c:	fc 01       	movw	r30, r24
    5d7e:	80 81       	ld	r24, Z
    5d80:	80 93 43 40 	sts	0x4043, r24
    5d84:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    5d86:	81 e0       	ldi	r24, 0x01	; 1
    5d88:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <RadioCS>

    /*Send Register address and read register content.*/
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    5d8c:	8f e8       	ldi	r24, 0x8F	; 143
    5d8e:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <SPID_write>
    5d92:	8c 83       	std	Y+4, r24	; 0x04
    intp_src = SPID_write(0);
    5d94:	80 e0       	ldi	r24, 0x00	; 0
    5d96:	0e 94 f3 30 	call	0x61e6	; 0x61e6 <SPID_write>
    5d9a:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    5d9c:	80 e0       	ldi	r24, 0x00	; 0
    5d9e:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <RadioCS>

    while (intp_src)
    5da2:	9d c0       	rjmp	.+314    	; 0x5ede <__vector_64+0x1a6>
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    5da4:	89 81       	ldd	r24, Y+1	; 0x01
    5da6:	88 2f       	mov	r24, r24
    5da8:	90 e0       	ldi	r25, 0x00	; 0
    5daa:	84 70       	andi	r24, 0x04	; 4
    5dac:	90 70       	andi	r25, 0x00	; 0
    5dae:	00 97       	sbiw	r24, 0x00	; 0
    5db0:	21 f0       	breq	.+8      	; 0x5dba <__vector_64+0x82>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    5db2:	89 81       	ldd	r24, Y+1	; 0x01
    5db4:	8b 7f       	andi	r24, 0xFB	; 251
    5db6:	89 83       	std	Y+1, r24	; 0x01
    5db8:	92 c0       	rjmp	.+292    	; 0x5ede <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    5dba:	89 81       	ldd	r24, Y+1	; 0x01
    5dbc:	88 2f       	mov	r24, r24
    5dbe:	90 e0       	ldi	r25, 0x00	; 0
    5dc0:	88 70       	andi	r24, 0x08	; 8
    5dc2:	90 70       	andi	r25, 0x00	; 0
    5dc4:	00 97       	sbiw	r24, 0x00	; 0
    5dc6:	09 f4       	brne	.+2      	; 0x5dca <__vector_64+0x92>
    5dc8:	4c c0       	rjmp	.+152    	; 0x5e62 <__vector_64+0x12a>
        {
            state = chb_get_state();
    5dca:	0e 94 0d 22 	call	0x441a	; 0x441a <chb_get_state>
    5dce:	8d 83       	std	Y+5, r24	; 0x05

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    5dd0:	8d 81       	ldd	r24, Y+5	; 0x05
    5dd2:	86 30       	cpi	r24, 0x06	; 6
    5dd4:	31 f0       	breq	.+12     	; 0x5de2 <__vector_64+0xaa>
    5dd6:	8d 81       	ldd	r24, Y+5	; 0x05
    5dd8:	86 31       	cpi	r24, 0x16	; 22
    5dda:	19 f0       	breq	.+6      	; 0x5de2 <__vector_64+0xaa>
    5ddc:	8d 81       	ldd	r24, Y+5	; 0x05
    5dde:	81 31       	cpi	r24, 0x11	; 17
    5de0:	89 f5       	brne	.+98     	; 0x5e44 <__vector_64+0x10c>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    5de2:	88 e0       	ldi	r24, 0x08	; 8
    5de4:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    5de8:	87 e0       	ldi	r24, 0x07	; 7
    5dea:	0e 94 11 24 	call	0x4822	; 0x4822 <chb_reg_read>
    5dee:	28 2f       	mov	r18, r24
    5df0:	8a 81       	ldd	r24, Y+2	; 0x02
    5df2:	9b 81       	ldd	r25, Y+3	; 0x03
    5df4:	fc 01       	movw	r30, r24
    5df6:	22 8b       	std	Z+18, r18	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    5df8:	86 e0       	ldi	r24, 0x06	; 6
    5dfa:	0e 94 11 24 	call	0x4822	; 0x4822 <chb_reg_read>
    5dfe:	28 2f       	mov	r18, r24
    5e00:	22 1f       	adc	r18, r18
    5e02:	22 27       	eor	r18, r18
    5e04:	22 1f       	adc	r18, r18
    5e06:	8a 81       	ldd	r24, Y+2	; 0x02
    5e08:	9b 81       	ldd	r25, Y+3	; 0x03
    5e0a:	fc 01       	movw	r30, r24
    5e0c:	23 8b       	std	Z+19, r18	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5e0e:	8a 81       	ldd	r24, Y+2	; 0x02
    5e10:	9b 81       	ldd	r25, Y+3	; 0x03
    5e12:	fc 01       	movw	r30, r24
    5e14:	83 89       	ldd	r24, Z+19	; 0x13
    5e16:	88 23       	and	r24, r24
    5e18:	d1 f0       	breq	.+52     	; 0x5e4e <__vector_64+0x116>
                    // get the data
                    chb_frame_read();
    5e1a:	0e 94 80 25 	call	0x4b00	; 0x4b00 <chb_frame_read>
                    pcb->rcvd_xfers++;
    5e1e:	8a 81       	ldd	r24, Y+2	; 0x02
    5e20:	9b 81       	ldd	r25, Y+3	; 0x03
    5e22:	fc 01       	movw	r30, r24
    5e24:	85 81       	ldd	r24, Z+5	; 0x05
    5e26:	96 81       	ldd	r25, Z+6	; 0x06
    5e28:	9c 01       	movw	r18, r24
    5e2a:	2f 5f       	subi	r18, 0xFF	; 255
    5e2c:	3f 4f       	sbci	r19, 0xFF	; 255
    5e2e:	8a 81       	ldd	r24, Y+2	; 0x02
    5e30:	9b 81       	ldd	r25, Y+3	; 0x03
    5e32:	fc 01       	movw	r30, r24
    5e34:	25 83       	std	Z+5, r18	; 0x05
    5e36:	36 83       	std	Z+6, r19	; 0x06
                    pcb->data_rcv = true;
    5e38:	8a 81       	ldd	r24, Y+2	; 0x02
    5e3a:	9b 81       	ldd	r25, Y+3	; 0x03
    5e3c:	21 e0       	ldi	r18, 0x01	; 1
    5e3e:	fc 01       	movw	r30, r24
    5e40:	23 83       	std	Z+3, r18	; 0x03

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5e42:	05 c0       	rjmp	.+10     	; 0x5e4e <__vector_64+0x116>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    5e44:	8a 81       	ldd	r24, Y+2	; 0x02
    5e46:	9b 81       	ldd	r25, Y+3	; 0x03
    5e48:	21 e0       	ldi	r18, 0x01	; 1
    5e4a:	fc 01       	movw	r30, r24
    5e4c:	24 83       	std	Z+4, r18	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    5e4e:	89 81       	ldd	r24, Y+1	; 0x01
    5e50:	87 7f       	andi	r24, 0xF7	; 247
    5e52:	89 83       	std	Y+1, r24	; 0x01
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    5e54:	00 00       	nop
    5e56:	86 e1       	ldi	r24, 0x16	; 22
    5e58:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <chb_set_state>
    5e5c:	80 34       	cpi	r24, 0x40	; 64
    5e5e:	d9 f7       	brne	.-10     	; 0x5e56 <__vector_64+0x11e>
    5e60:	3e c0       	rjmp	.+124    	; 0x5ede <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    5e62:	89 81       	ldd	r24, Y+1	; 0x01
    5e64:	88 2f       	mov	r24, r24
    5e66:	90 e0       	ldi	r25, 0x00	; 0
    5e68:	80 74       	andi	r24, 0x40	; 64
    5e6a:	90 70       	andi	r25, 0x00	; 0
    5e6c:	00 97       	sbiw	r24, 0x00	; 0
    5e6e:	89 f0       	breq	.+34     	; 0x5e92 <__vector_64+0x15a>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    5e70:	89 81       	ldd	r24, Y+1	; 0x01
    5e72:	8f 7b       	andi	r24, 0xBF	; 191
    5e74:	89 83       	std	Y+1, r24	; 0x01
            pcb->underrun++;
    5e76:	8a 81       	ldd	r24, Y+2	; 0x02
    5e78:	9b 81       	ldd	r25, Y+3	; 0x03
    5e7a:	fc 01       	movw	r30, r24
    5e7c:	87 85       	ldd	r24, Z+15	; 0x0f
    5e7e:	90 89       	ldd	r25, Z+16	; 0x10
    5e80:	9c 01       	movw	r18, r24
    5e82:	2f 5f       	subi	r18, 0xFF	; 255
    5e84:	3f 4f       	sbci	r19, 0xFF	; 255
    5e86:	8a 81       	ldd	r24, Y+2	; 0x02
    5e88:	9b 81       	ldd	r25, Y+3	; 0x03
    5e8a:	fc 01       	movw	r30, r24
    5e8c:	27 87       	std	Z+15, r18	; 0x0f
    5e8e:	30 8b       	std	Z+16, r19	; 0x10
    5e90:	26 c0       	rjmp	.+76     	; 0x5ede <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    5e92:	89 81       	ldd	r24, Y+1	; 0x01
    5e94:	88 2f       	mov	r24, r24
    5e96:	90 e0       	ldi	r25, 0x00	; 0
    5e98:	82 70       	andi	r24, 0x02	; 2
    5e9a:	90 70       	andi	r25, 0x00	; 0
    5e9c:	00 97       	sbiw	r24, 0x00	; 0
    5e9e:	21 f0       	breq	.+8      	; 0x5ea8 <__vector_64+0x170>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    5ea0:	89 81       	ldd	r24, Y+1	; 0x01
    5ea2:	8d 7f       	andi	r24, 0xFD	; 253
    5ea4:	89 83       	std	Y+1, r24	; 0x01
    5ea6:	1b c0       	rjmp	.+54     	; 0x5ede <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    5ea8:	89 81       	ldd	r24, Y+1	; 0x01
    5eaa:	88 2f       	mov	r24, r24
    5eac:	90 e0       	ldi	r25, 0x00	; 0
    5eae:	81 70       	andi	r24, 0x01	; 1
    5eb0:	90 70       	andi	r25, 0x00	; 0
    5eb2:	88 23       	and	r24, r24
    5eb4:	21 f0       	breq	.+8      	; 0x5ebe <__vector_64+0x186>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    5eb6:	89 81       	ldd	r24, Y+1	; 0x01
    5eb8:	8e 7f       	andi	r24, 0xFE	; 254
    5eba:	89 83       	std	Y+1, r24	; 0x01
    5ebc:	10 c0       	rjmp	.+32     	; 0x5ede <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    5ebe:	89 81       	ldd	r24, Y+1	; 0x01
    5ec0:	88 23       	and	r24, r24
    5ec2:	6c f4       	brge	.+26     	; 0x5ede <__vector_64+0x1a6>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    5ec4:	89 81       	ldd	r24, Y+1	; 0x01
    5ec6:	8f 77       	andi	r24, 0x7F	; 127
    5ec8:	89 83       	std	Y+1, r24	; 0x01
            pcb->battlow++;
    5eca:	8a 81       	ldd	r24, Y+2	; 0x02
    5ecc:	9b 81       	ldd	r25, Y+3	; 0x03
    5ece:	fc 01       	movw	r30, r24
    5ed0:	81 89       	ldd	r24, Z+17	; 0x11
    5ed2:	28 2f       	mov	r18, r24
    5ed4:	2f 5f       	subi	r18, 0xFF	; 255
    5ed6:	8a 81       	ldd	r24, Y+2	; 0x02
    5ed8:	9b 81       	ldd	r25, Y+3	; 0x03
    5eda:	fc 01       	movw	r30, r24
    5edc:	21 8b       	std	Z+17, r18	; 0x11
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    5ede:	89 81       	ldd	r24, Y+1	; 0x01
    5ee0:	88 23       	and	r24, r24
    5ee2:	09 f0       	breq	.+2      	; 0x5ee6 <__vector_64+0x1ae>
    5ee4:	5f cf       	rjmp	.-322    	; 0x5da4 <__vector_64+0x6c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    5ee6:	8f e3       	ldi	r24, 0x3F	; 63
    5ee8:	90 e0       	ldi	r25, 0x00	; 0
    5eea:	20 91 43 40 	lds	r18, 0x4043
    5eee:	fc 01       	movw	r30, r24
    5ef0:	20 83       	st	Z, r18
    5ef2:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    5ef4:	8f e0       	ldi	r24, 0x0F	; 15
    5ef6:	0e 94 11 24 	call	0x4822	; 0x4822 <chb_reg_read>
}
    5efa:	25 96       	adiw	r28, 0x05	; 5
    5efc:	cd bf       	out	0x3d, r28	; 61
    5efe:	de bf       	out	0x3e, r29	; 62
    5f00:	df 91       	pop	r29
    5f02:	cf 91       	pop	r28
    5f04:	ff 91       	pop	r31
    5f06:	ef 91       	pop	r30
    5f08:	bf 91       	pop	r27
    5f0a:	af 91       	pop	r26
    5f0c:	9f 91       	pop	r25
    5f0e:	8f 91       	pop	r24
    5f10:	7f 91       	pop	r23
    5f12:	6f 91       	pop	r22
    5f14:	5f 91       	pop	r21
    5f16:	4f 91       	pop	r20
    5f18:	3f 91       	pop	r19
    5f1a:	2f 91       	pop	r18
    5f1c:	0f 90       	pop	r0
    5f1e:	00 92 3b 00 	sts	0x003B, r0
    5f22:	0f 90       	pop	r0
    5f24:	0f be       	out	0x3f, r0	; 63
    5f26:	0f 90       	pop	r0
    5f28:	1f 90       	pop	r1
    5f2a:	18 95       	reti

00005f2c <RadioCS>:

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
    5f2c:	cf 93       	push	r28
    5f2e:	df 93       	push	r29
    5f30:	0f 92       	push	r0
    5f32:	cd b7       	in	r28, 0x3d	; 61
    5f34:	de b7       	in	r29, 0x3e	; 62
    5f36:	89 83       	std	Y+1, r24	; 0x01
	if (status) PORTD.OUTCLR = PIN4_bm;
    5f38:	89 81       	ldd	r24, Y+1	; 0x01
    5f3a:	88 23       	and	r24, r24
    5f3c:	31 f0       	breq	.+12     	; 0x5f4a <RadioCS+0x1e>
    5f3e:	80 e6       	ldi	r24, 0x60	; 96
    5f40:	96 e0       	ldi	r25, 0x06	; 6
    5f42:	20 e1       	ldi	r18, 0x10	; 16
    5f44:	fc 01       	movw	r30, r24
    5f46:	26 83       	std	Z+6, r18	; 0x06
    5f48:	05 c0       	rjmp	.+10     	; 0x5f54 <RadioCS+0x28>
	else {
		PORTD.OUTSET = PIN4_bm;
    5f4a:	80 e6       	ldi	r24, 0x60	; 96
    5f4c:	96 e0       	ldi	r25, 0x06	; 6
    5f4e:	20 e1       	ldi	r18, 0x10	; 16
    5f50:	fc 01       	movw	r30, r24
    5f52:	25 83       	std	Z+5, r18	; 0x05
	}
    5f54:	0f 90       	pop	r0
    5f56:	df 91       	pop	r29
    5f58:	cf 91       	pop	r28
    5f5a:	08 95       	ret

00005f5c <chb_eep_write_byte>:
/*!

*/
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    5f5c:	cf 93       	push	r28
    5f5e:	df 93       	push	r29
    5f60:	00 d0       	rcall	.+0      	; 0x5f62 <chb_eep_write_byte+0x6>
    5f62:	cd b7       	in	r28, 0x3d	; 61
    5f64:	de b7       	in	r29, 0x3e	; 62
    5f66:	89 83       	std	Y+1, r24	; 0x01
    5f68:	9a 83       	std	Y+2, r25	; 0x02
    5f6a:	6b 83       	std	Y+3, r22	; 0x03
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    5f6c:	00 00       	nop
    5f6e:	80 ec       	ldi	r24, 0xC0	; 192
    5f70:	91 e0       	ldi	r25, 0x01	; 1
    5f72:	fc 01       	movw	r30, r24
    5f74:	87 85       	ldd	r24, Z+15	; 0x0f
    5f76:	88 23       	and	r24, r24
    5f78:	d4 f3       	brlt	.-12     	; 0x5f6e <chb_eep_write_byte+0x12>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    5f7a:	80 ec       	ldi	r24, 0xC0	; 192
    5f7c:	91 e0       	ldi	r25, 0x01	; 1
    5f7e:	fc 01       	movw	r30, r24
    5f80:	87 85       	ldd	r24, Z+15	; 0x0f
    5f82:	88 2f       	mov	r24, r24
    5f84:	90 e0       	ldi	r25, 0x00	; 0
    5f86:	82 70       	andi	r24, 0x02	; 2
    5f88:	90 70       	andi	r25, 0x00	; 0
    5f8a:	00 97       	sbiw	r24, 0x00	; 0
    5f8c:	99 f0       	breq	.+38     	; 0x5fb4 <chb_eep_write_byte+0x58>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    5f8e:	80 ec       	ldi	r24, 0xC0	; 192
    5f90:	91 e0       	ldi	r25, 0x01	; 1
    5f92:	26 e3       	ldi	r18, 0x36	; 54
    5f94:	fc 01       	movw	r30, r24
    5f96:	22 87       	std	Z+10, r18	; 0x0a
        NVM_EXEC();
    5f98:	ef 93       	push	r30
    5f9a:	ff 93       	push	r31
    5f9c:	0f 93       	push	r16
    5f9e:	2f 93       	push	r18
    5fa0:	eb ec       	ldi	r30, 0xCB	; 203
    5fa2:	f1 e0       	ldi	r31, 0x01	; 1
    5fa4:	08 ed       	ldi	r16, 0xD8	; 216
    5fa6:	21 e0       	ldi	r18, 0x01	; 1
    5fa8:	04 bf       	out	0x34, r16	; 52
    5faa:	20 83       	st	Z, r18
    5fac:	2f 91       	pop	r18
    5fae:	0f 91       	pop	r16
    5fb0:	ff 91       	pop	r31
    5fb2:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    5fb4:	80 ec       	ldi	r24, 0xC0	; 192
    5fb6:	91 e0       	ldi	r25, 0x01	; 1
    5fb8:	23 e3       	ldi	r18, 0x33	; 51
    5fba:	fc 01       	movw	r30, r24
    5fbc:	22 87       	std	Z+10, r18	; 0x0a

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    5fbe:	80 ec       	ldi	r24, 0xC0	; 192
    5fc0:	91 e0       	ldi	r25, 0x01	; 1
    5fc2:	29 81       	ldd	r18, Y+1	; 0x01
    5fc4:	fc 01       	movw	r30, r24
    5fc6:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    5fc8:	80 ec       	ldi	r24, 0xC0	; 192
    5fca:	91 e0       	ldi	r25, 0x01	; 1
    5fcc:	29 81       	ldd	r18, Y+1	; 0x01
    5fce:	3a 81       	ldd	r19, Y+2	; 0x02
    5fd0:	23 2f       	mov	r18, r19
    5fd2:	33 27       	eor	r19, r19
    5fd4:	2f 71       	andi	r18, 0x1F	; 31
    5fd6:	fc 01       	movw	r30, r24
    5fd8:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    5fda:	80 ec       	ldi	r24, 0xC0	; 192
    5fdc:	91 e0       	ldi	r25, 0x01	; 1
    5fde:	fc 01       	movw	r30, r24
    5fe0:	12 82       	std	Z+2, r1	; 0x02

    // load the data to write
    NVM.DATA0 = value;
    5fe2:	80 ec       	ldi	r24, 0xC0	; 192
    5fe4:	91 e0       	ldi	r25, 0x01	; 1
    5fe6:	2b 81       	ldd	r18, Y+3	; 0x03
    5fe8:	fc 01       	movw	r30, r24
    5fea:	24 83       	std	Z+4, r18	; 0x04

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    5fec:	80 ec       	ldi	r24, 0xC0	; 192
    5fee:	91 e0       	ldi	r25, 0x01	; 1
    5ff0:	25 e3       	ldi	r18, 0x35	; 53
    5ff2:	fc 01       	movw	r30, r24
    5ff4:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    5ff6:	ef 93       	push	r30
    5ff8:	ff 93       	push	r31
    5ffa:	0f 93       	push	r16
    5ffc:	2f 93       	push	r18
    5ffe:	eb ec       	ldi	r30, 0xCB	; 203
    6000:	f1 e0       	ldi	r31, 0x01	; 1
    6002:	08 ed       	ldi	r16, 0xD8	; 216
    6004:	21 e0       	ldi	r18, 0x01	; 1
    6006:	04 bf       	out	0x34, r16	; 52
    6008:	20 83       	st	Z, r18
    600a:	2f 91       	pop	r18
    600c:	0f 91       	pop	r16
    600e:	ff 91       	pop	r31
    6010:	ef 91       	pop	r30
}
    6012:	23 96       	adiw	r28, 0x03	; 3
    6014:	cd bf       	out	0x3d, r28	; 61
    6016:	de bf       	out	0x3e, r29	; 62
    6018:	df 91       	pop	r29
    601a:	cf 91       	pop	r28
    601c:	08 95       	ret

0000601e <chb_eep_read_byte>:
/*!

*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    601e:	cf 93       	push	r28
    6020:	df 93       	push	r29
    6022:	0f 92       	push	r0
    6024:	0f 92       	push	r0
    6026:	cd b7       	in	r28, 0x3d	; 61
    6028:	de b7       	in	r29, 0x3e	; 62
    602a:	89 83       	std	Y+1, r24	; 0x01
    602c:	9a 83       	std	Y+2, r25	; 0x02
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    602e:	00 00       	nop
    6030:	80 ec       	ldi	r24, 0xC0	; 192
    6032:	91 e0       	ldi	r25, 0x01	; 1
    6034:	fc 01       	movw	r30, r24
    6036:	87 85       	ldd	r24, Z+15	; 0x0f
    6038:	88 23       	and	r24, r24
    603a:	d4 f3       	brlt	.-12     	; 0x6030 <chb_eep_read_byte+0x12>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    603c:	80 ec       	ldi	r24, 0xC0	; 192
    603e:	91 e0       	ldi	r25, 0x01	; 1
    6040:	29 81       	ldd	r18, Y+1	; 0x01
    6042:	fc 01       	movw	r30, r24
    6044:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    6046:	80 ec       	ldi	r24, 0xC0	; 192
    6048:	91 e0       	ldi	r25, 0x01	; 1
    604a:	29 81       	ldd	r18, Y+1	; 0x01
    604c:	3a 81       	ldd	r19, Y+2	; 0x02
    604e:	23 2f       	mov	r18, r19
    6050:	33 27       	eor	r19, r19
    6052:	2f 71       	andi	r18, 0x1F	; 31
    6054:	fc 01       	movw	r30, r24
    6056:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    6058:	80 ec       	ldi	r24, 0xC0	; 192
    605a:	91 e0       	ldi	r25, 0x01	; 1
    605c:	fc 01       	movw	r30, r24
    605e:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    6060:	80 ec       	ldi	r24, 0xC0	; 192
    6062:	91 e0       	ldi	r25, 0x01	; 1
    6064:	26 e0       	ldi	r18, 0x06	; 6
    6066:	fc 01       	movw	r30, r24
    6068:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    606a:	ef 93       	push	r30
    606c:	ff 93       	push	r31
    606e:	0f 93       	push	r16
    6070:	2f 93       	push	r18
    6072:	eb ec       	ldi	r30, 0xCB	; 203
    6074:	f1 e0       	ldi	r31, 0x01	; 1
    6076:	08 ed       	ldi	r16, 0xD8	; 216
    6078:	21 e0       	ldi	r18, 0x01	; 1
    607a:	04 bf       	out	0x34, r16	; 52
    607c:	20 83       	st	Z, r18
    607e:	2f 91       	pop	r18
    6080:	0f 91       	pop	r16
    6082:	ff 91       	pop	r31
    6084:	ef 91       	pop	r30

    return NVM.DATA0;
    6086:	80 ec       	ldi	r24, 0xC0	; 192
    6088:	91 e0       	ldi	r25, 0x01	; 1
    608a:	fc 01       	movw	r30, r24
    608c:	84 81       	ldd	r24, Z+4	; 0x04
}
    608e:	0f 90       	pop	r0
    6090:	0f 90       	pop	r0
    6092:	df 91       	pop	r29
    6094:	cf 91       	pop	r28
    6096:	08 95       	ret

00006098 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    6098:	cf 93       	push	r28
    609a:	df 93       	push	r29
    609c:	cd b7       	in	r28, 0x3d	; 61
    609e:	de b7       	in	r29, 0x3e	; 62
    60a0:	27 97       	sbiw	r28, 0x07	; 7
    60a2:	cd bf       	out	0x3d, r28	; 61
    60a4:	de bf       	out	0x3e, r29	; 62
    60a6:	8a 83       	std	Y+2, r24	; 0x02
    60a8:	9b 83       	std	Y+3, r25	; 0x03
    60aa:	6c 83       	std	Y+4, r22	; 0x04
    60ac:	7d 83       	std	Y+5, r23	; 0x05
    60ae:	4e 83       	std	Y+6, r20	; 0x06
    60b0:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    60b2:	80 ec       	ldi	r24, 0xC0	; 192
    60b4:	91 e0       	ldi	r25, 0x01	; 1
    60b6:	20 ec       	ldi	r18, 0xC0	; 192
    60b8:	31 e0       	ldi	r19, 0x01	; 1
    60ba:	f9 01       	movw	r30, r18
    60bc:	24 85       	ldd	r18, Z+12	; 0x0c
    60be:	27 7f       	andi	r18, 0xF7	; 247
    60c0:	fc 01       	movw	r30, r24
    60c2:	24 87       	std	Z+12, r18	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    60c4:	19 82       	std	Y+1, r1	; 0x01
    60c6:	16 c0       	rjmp	.+44     	; 0x60f4 <chb_eeprom_write+0x5c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    60c8:	89 81       	ldd	r24, Y+1	; 0x01
    60ca:	28 2f       	mov	r18, r24
    60cc:	30 e0       	ldi	r19, 0x00	; 0
    60ce:	8a 81       	ldd	r24, Y+2	; 0x02
    60d0:	9b 81       	ldd	r25, Y+3	; 0x03
    60d2:	82 0f       	add	r24, r18
    60d4:	93 1f       	adc	r25, r19
    60d6:	29 81       	ldd	r18, Y+1	; 0x01
    60d8:	22 2f       	mov	r18, r18
    60da:	30 e0       	ldi	r19, 0x00	; 0
    60dc:	4c 81       	ldd	r20, Y+4	; 0x04
    60de:	5d 81       	ldd	r21, Y+5	; 0x05
    60e0:	24 0f       	add	r18, r20
    60e2:	35 1f       	adc	r19, r21
    60e4:	f9 01       	movw	r30, r18
    60e6:	20 81       	ld	r18, Z
    60e8:	62 2f       	mov	r22, r18
    60ea:	0e 94 ae 2f 	call	0x5f5c	; 0x5f5c <chb_eep_write_byte>
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    60ee:	89 81       	ldd	r24, Y+1	; 0x01
    60f0:	8f 5f       	subi	r24, 0xFF	; 255
    60f2:	89 83       	std	Y+1, r24	; 0x01
    60f4:	89 81       	ldd	r24, Y+1	; 0x01
    60f6:	28 2f       	mov	r18, r24
    60f8:	30 e0       	ldi	r19, 0x00	; 0
    60fa:	8e 81       	ldd	r24, Y+6	; 0x06
    60fc:	9f 81       	ldd	r25, Y+7	; 0x07
    60fe:	28 17       	cp	r18, r24
    6100:	39 07       	cpc	r19, r25
    6102:	10 f3       	brcs	.-60     	; 0x60c8 <chb_eeprom_write+0x30>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    6104:	27 96       	adiw	r28, 0x07	; 7
    6106:	cd bf       	out	0x3d, r28	; 61
    6108:	de bf       	out	0x3e, r29	; 62
    610a:	df 91       	pop	r29
    610c:	cf 91       	pop	r28
    610e:	08 95       	ret

00006110 <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    6110:	0f 93       	push	r16
    6112:	1f 93       	push	r17
    6114:	cf 93       	push	r28
    6116:	df 93       	push	r29
    6118:	cd b7       	in	r28, 0x3d	; 61
    611a:	de b7       	in	r29, 0x3e	; 62
    611c:	27 97       	sbiw	r28, 0x07	; 7
    611e:	cd bf       	out	0x3d, r28	; 61
    6120:	de bf       	out	0x3e, r29	; 62
    6122:	8a 83       	std	Y+2, r24	; 0x02
    6124:	9b 83       	std	Y+3, r25	; 0x03
    6126:	6c 83       	std	Y+4, r22	; 0x04
    6128:	7d 83       	std	Y+5, r23	; 0x05
    612a:	4e 83       	std	Y+6, r20	; 0x06
    612c:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    612e:	80 ec       	ldi	r24, 0xC0	; 192
    6130:	91 e0       	ldi	r25, 0x01	; 1
    6132:	20 ec       	ldi	r18, 0xC0	; 192
    6134:	31 e0       	ldi	r19, 0x01	; 1
    6136:	f9 01       	movw	r30, r18
    6138:	24 85       	ldd	r18, Z+12	; 0x0c
    613a:	27 7f       	andi	r18, 0xF7	; 247
    613c:	fc 01       	movw	r30, r24
    613e:	24 87       	std	Z+12, r18	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    6140:	19 82       	std	Y+1, r1	; 0x01
    6142:	16 c0       	rjmp	.+44     	; 0x6170 <chb_eeprom_read+0x60>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    6144:	89 81       	ldd	r24, Y+1	; 0x01
    6146:	88 2f       	mov	r24, r24
    6148:	90 e0       	ldi	r25, 0x00	; 0
    614a:	2c 81       	ldd	r18, Y+4	; 0x04
    614c:	3d 81       	ldd	r19, Y+5	; 0x05
    614e:	89 01       	movw	r16, r18
    6150:	08 0f       	add	r16, r24
    6152:	19 1f       	adc	r17, r25
    6154:	89 81       	ldd	r24, Y+1	; 0x01
    6156:	28 2f       	mov	r18, r24
    6158:	30 e0       	ldi	r19, 0x00	; 0
    615a:	8a 81       	ldd	r24, Y+2	; 0x02
    615c:	9b 81       	ldd	r25, Y+3	; 0x03
    615e:	82 0f       	add	r24, r18
    6160:	93 1f       	adc	r25, r19
    6162:	0e 94 0f 30 	call	0x601e	; 0x601e <chb_eep_read_byte>
    6166:	f8 01       	movw	r30, r16
    6168:	80 83       	st	Z, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    616a:	89 81       	ldd	r24, Y+1	; 0x01
    616c:	8f 5f       	subi	r24, 0xFF	; 255
    616e:	89 83       	std	Y+1, r24	; 0x01
    6170:	89 81       	ldd	r24, Y+1	; 0x01
    6172:	28 2f       	mov	r18, r24
    6174:	30 e0       	ldi	r19, 0x00	; 0
    6176:	8e 81       	ldd	r24, Y+6	; 0x06
    6178:	9f 81       	ldd	r25, Y+7	; 0x07
    617a:	28 17       	cp	r18, r24
    617c:	39 07       	cpc	r19, r25
    617e:	10 f3       	brcs	.-60     	; 0x6144 <chb_eeprom_read+0x34>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    6180:	27 96       	adiw	r28, 0x07	; 7
    6182:	cd bf       	out	0x3d, r28	; 61
    6184:	de bf       	out	0x3e, r29	; 62
    6186:	df 91       	pop	r29
    6188:	cf 91       	pop	r28
    618a:	1f 91       	pop	r17
    618c:	0f 91       	pop	r16
    618e:	08 95       	ret

00006190 <chb_spi_init>:

*/
/**************************************************************************/

void chb_spi_init()
{
    6190:	cf 93       	push	r28
    6192:	df 93       	push	r29
    6194:	cd b7       	in	r28, 0x3d	; 61
    6196:	de b7       	in	r29, 0x3e	; 62
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    6198:	80 e6       	ldi	r24, 0x60	; 96
    619a:	96 e0       	ldi	r25, 0x06	; 6
    619c:	20 e6       	ldi	r18, 0x60	; 96
    619e:	36 e0       	ldi	r19, 0x06	; 6
    61a0:	f9 01       	movw	r30, r18
    61a2:	20 81       	ld	r18, Z
    61a4:	20 6b       	ori	r18, 0xB0	; 176
    61a6:	fc 01       	movw	r30, r24
    61a8:	20 83       	st	Z, r18
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    61aa:	84 e6       	ldi	r24, 0x64	; 100
    61ac:	96 e0       	ldi	r25, 0x06	; 6
    61ae:	24 e6       	ldi	r18, 0x64	; 100
    61b0:	36 e0       	ldi	r19, 0x06	; 6
    61b2:	f9 01       	movw	r30, r18
    61b4:	20 81       	ld	r18, Z
    61b6:	20 61       	ori	r18, 0x10	; 16
    61b8:	fc 01       	movw	r30, r24
    61ba:	20 83       	st	Z, r18

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    61bc:	80 ec       	ldi	r24, 0xC0	; 192
    61be:	99 e0       	ldi	r25, 0x09	; 9
    61c0:	20 ec       	ldi	r18, 0xC0	; 192
    61c2:	39 e0       	ldi	r19, 0x09	; 9
    61c4:	f9 01       	movw	r30, r18
    61c6:	20 81       	ld	r18, Z
    61c8:	21 65       	ori	r18, 0x51	; 81
    61ca:	fc 01       	movw	r30, r24
    61cc:	20 83       	st	Z, r18

    // set the slave select to idle
    CHB_SPI_DISABLE();
    61ce:	84 e6       	ldi	r24, 0x64	; 100
    61d0:	96 e0       	ldi	r25, 0x06	; 6
    61d2:	24 e6       	ldi	r18, 0x64	; 100
    61d4:	36 e0       	ldi	r19, 0x06	; 6
    61d6:	f9 01       	movw	r30, r18
    61d8:	20 81       	ld	r18, Z
    61da:	20 61       	ori	r18, 0x10	; 16
    61dc:	fc 01       	movw	r30, r24
    61de:	20 83       	st	Z, r18
}
    61e0:	df 91       	pop	r29
    61e2:	cf 91       	pop	r28
    61e4:	08 95       	ret

000061e6 <SPID_write>:
    This function both reads and writes data. For write operations, include data
    to be written as argument. For read ops, use dummy data as arg. Returned
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
    61e6:	cf 93       	push	r28
    61e8:	df 93       	push	r29
    61ea:	0f 92       	push	r0
    61ec:	0f 92       	push	r0
    61ee:	cd b7       	in	r28, 0x3d	; 61
    61f0:	de b7       	in	r29, 0x3e	; 62
    61f2:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPID.DATA = byteToSend;
    61f4:	80 ec       	ldi	r24, 0xC0	; 192
    61f6:	99 e0       	ldi	r25, 0x09	; 9
    61f8:	2a 81       	ldd	r18, Y+2	; 0x02
    61fa:	fc 01       	movw	r30, r24
    61fc:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    61fe:	00 00       	nop
    6200:	80 ec       	ldi	r24, 0xC0	; 192
    6202:	99 e0       	ldi	r25, 0x09	; 9
    6204:	fc 01       	movw	r30, r24
    6206:	82 81       	ldd	r24, Z+2	; 0x02
    6208:	88 23       	and	r24, r24
    620a:	d4 f7       	brge	.-12     	; 0x6200 <SPID_write+0x1a>
	data = SPID.DATA; //read SPI data register to reset status flag
    620c:	80 ec       	ldi	r24, 0xC0	; 192
    620e:	99 e0       	ldi	r25, 0x09	; 9
    6210:	fc 01       	movw	r30, r24
    6212:	83 81       	ldd	r24, Z+3	; 0x03
    6214:	89 83       	std	Y+1, r24	; 0x01
	return data;
    6216:	89 81       	ldd	r24, Y+1	; 0x01
    6218:	0f 90       	pop	r0
    621a:	0f 90       	pop	r0
    621c:	df 91       	pop	r29
    621e:	cf 91       	pop	r28
    6220:	08 95       	ret

00006222 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    6222:	0f 93       	push	r16
    6224:	cf 93       	push	r28
    6226:	df 93       	push	r29
    6228:	00 d0       	rcall	.+0      	; 0x622a <CCPWrite+0x8>
    622a:	00 d0       	rcall	.+0      	; 0x622c <CCPWrite+0xa>
    622c:	cd b7       	in	r28, 0x3d	; 61
    622e:	de b7       	in	r29, 0x3e	; 62
    6230:	8c 83       	std	Y+4, r24	; 0x04
    6232:	9d 83       	std	Y+5, r25	; 0x05
    6234:	6e 83       	std	Y+6, r22	; 0x06

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    6236:	8f e3       	ldi	r24, 0x3F	; 63
    6238:	90 e0       	ldi	r25, 0x00	; 0
    623a:	fc 01       	movw	r30, r24
    623c:	80 81       	ld	r24, Z
    623e:	8b 83       	std	Y+3, r24	; 0x03
    6240:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
    6242:	8c 81       	ldd	r24, Y+4	; 0x04
    6244:	9d 81       	ldd	r25, Y+5	; 0x05
    6246:	89 83       	std	Y+1, r24	; 0x01
    6248:	9a 83       	std	Y+2, r25	; 0x02
#ifdef RAMPZ
	RAMPZ = 0;
    624a:	8b e3       	ldi	r24, 0x3B	; 59
    624c:	90 e0       	ldi	r25, 0x00	; 0
    624e:	fc 01       	movw	r30, r24
    6250:	10 82       	st	Z, r1
#endif
	asm volatile(
    6252:	89 81       	ldd	r24, Y+1	; 0x01
    6254:	9a 81       	ldd	r25, Y+2	; 0x02
    6256:	2e 81       	ldd	r18, Y+6	; 0x06
    6258:	fc 01       	movw	r30, r24
    625a:	08 ed       	ldi	r16, 0xD8	; 216
    625c:	04 bf       	out	0x34, r16	; 52
    625e:	20 83       	st	Z, r18
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    6260:	8f e3       	ldi	r24, 0x3F	; 63
    6262:	90 e0       	ldi	r25, 0x00	; 0
    6264:	2b 81       	ldd	r18, Y+3	; 0x03
    6266:	fc 01       	movw	r30, r24
    6268:	20 83       	st	Z, r18
#endif
}
    626a:	26 96       	adiw	r28, 0x06	; 6
    626c:	cd bf       	out	0x3d, r28	; 61
    626e:	de bf       	out	0x3e, r29	; 62
    6270:	df 91       	pop	r29
    6272:	cf 91       	pop	r28
    6274:	0f 91       	pop	r16
    6276:	08 95       	ret

00006278 <CLKSYS_XOSC_Config>:
 *                             external clock) and startup times.
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
    6278:	cf 93       	push	r28
    627a:	df 93       	push	r29
    627c:	00 d0       	rcall	.+0      	; 0x627e <CLKSYS_XOSC_Config+0x6>
    627e:	cd b7       	in	r28, 0x3d	; 61
    6280:	de b7       	in	r29, 0x3e	; 62
    6282:	89 83       	std	Y+1, r24	; 0x01
    6284:	6a 83       	std	Y+2, r22	; 0x02
    6286:	4b 83       	std	Y+3, r20	; 0x03
	OSC.XOSCCTRL = (uint8_t) freqRange |
    6288:	80 e5       	ldi	r24, 0x50	; 80
    628a:	90 e0       	ldi	r25, 0x00	; 0
    628c:	2a 81       	ldd	r18, Y+2	; 0x02
    628e:	22 23       	and	r18, r18
    6290:	11 f0       	breq	.+4      	; 0x6296 <CLKSYS_XOSC_Config+0x1e>
    6292:	20 e2       	ldi	r18, 0x20	; 32
    6294:	01 c0       	rjmp	.+2      	; 0x6298 <CLKSYS_XOSC_Config+0x20>
    6296:	20 e0       	ldi	r18, 0x00	; 0
    6298:	39 81       	ldd	r19, Y+1	; 0x01
    629a:	32 2b       	or	r19, r18
    629c:	2b 81       	ldd	r18, Y+3	; 0x03
    629e:	23 2b       	or	r18, r19
    62a0:	fc 01       	movw	r30, r24
    62a2:	22 83       	std	Z+2, r18	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    62a4:	23 96       	adiw	r28, 0x03	; 3
    62a6:	cd bf       	out	0x3d, r28	; 61
    62a8:	de bf       	out	0x3e, r29	; 62
    62aa:	df 91       	pop	r29
    62ac:	cf 91       	pop	r28
    62ae:	08 95       	ret

000062b0 <CLKSYS_PLL_Config>:
 *                      must be above 0.4MHz.
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
    62b0:	cf 93       	push	r28
    62b2:	df 93       	push	r29
    62b4:	0f 92       	push	r0
    62b6:	0f 92       	push	r0
    62b8:	cd b7       	in	r28, 0x3d	; 61
    62ba:	de b7       	in	r29, 0x3e	; 62
    62bc:	89 83       	std	Y+1, r24	; 0x01
    62be:	6a 83       	std	Y+2, r22	; 0x02
	factor &= OSC_PLLFAC_gm;
    62c0:	8a 81       	ldd	r24, Y+2	; 0x02
    62c2:	8f 71       	andi	r24, 0x1F	; 31
    62c4:	8a 83       	std	Y+2, r24	; 0x02
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    62c6:	80 e5       	ldi	r24, 0x50	; 80
    62c8:	90 e0       	ldi	r25, 0x00	; 0
    62ca:	39 81       	ldd	r19, Y+1	; 0x01
    62cc:	2a 81       	ldd	r18, Y+2	; 0x02
    62ce:	23 2b       	or	r18, r19
    62d0:	fc 01       	movw	r30, r24
    62d2:	25 83       	std	Z+5, r18	; 0x05
}
    62d4:	0f 90       	pop	r0
    62d6:	0f 90       	pop	r0
    62d8:	df 91       	pop	r29
    62da:	cf 91       	pop	r28
    62dc:	08 95       	ret

000062de <CLKSYS_Disable>:
 *                 OSC_XOSCEN_bm, OSC_PLLEN_bm.
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
    62de:	cf 93       	push	r28
    62e0:	df 93       	push	r29
    62e2:	0f 92       	push	r0
    62e4:	0f 92       	push	r0
    62e6:	cd b7       	in	r28, 0x3d	; 61
    62e8:	de b7       	in	r29, 0x3e	; 62
    62ea:	8a 83       	std	Y+2, r24	; 0x02
	OSC.CTRL &= ~oscSel;
    62ec:	80 e5       	ldi	r24, 0x50	; 80
    62ee:	90 e0       	ldi	r25, 0x00	; 0
    62f0:	20 e5       	ldi	r18, 0x50	; 80
    62f2:	30 e0       	ldi	r19, 0x00	; 0
    62f4:	f9 01       	movw	r30, r18
    62f6:	20 81       	ld	r18, Z
    62f8:	32 2f       	mov	r19, r18
    62fa:	2a 81       	ldd	r18, Y+2	; 0x02
    62fc:	20 95       	com	r18
    62fe:	23 23       	and	r18, r19
    6300:	fc 01       	movw	r30, r24
    6302:	20 83       	st	Z, r18
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    6304:	80 e5       	ldi	r24, 0x50	; 80
    6306:	90 e0       	ldi	r25, 0x00	; 0
    6308:	fc 01       	movw	r30, r24
    630a:	90 81       	ld	r25, Z
    630c:	8a 81       	ldd	r24, Y+2	; 0x02
    630e:	89 23       	and	r24, r25
    6310:	89 83       	std	Y+1, r24	; 0x01
	return clkEnabled;
    6312:	89 81       	ldd	r24, Y+1	; 0x01
}
    6314:	0f 90       	pop	r0
    6316:	0f 90       	pop	r0
    6318:	df 91       	pop	r29
    631a:	cf 91       	pop	r28
    631c:	08 95       	ret

0000631e <CLKSYS_Prescalers_Config>:
 *  \param  PSBCfactor  Prescaler B and C division factor, in the combination
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
    631e:	cf 93       	push	r28
    6320:	df 93       	push	r29
    6322:	00 d0       	rcall	.+0      	; 0x6324 <CLKSYS_Prescalers_Config+0x6>
    6324:	cd b7       	in	r28, 0x3d	; 61
    6326:	de b7       	in	r29, 0x3e	; 62
    6328:	8a 83       	std	Y+2, r24	; 0x02
    632a:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    632c:	9a 81       	ldd	r25, Y+2	; 0x02
    632e:	8b 81       	ldd	r24, Y+3	; 0x03
    6330:	89 2b       	or	r24, r25
    6332:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.PSCTRL, PSconfig );
    6334:	81 e4       	ldi	r24, 0x41	; 65
    6336:	90 e0       	ldi	r25, 0x00	; 0
    6338:	69 81       	ldd	r22, Y+1	; 0x01
    633a:	0e 94 11 31 	call	0x6222	; 0x6222 <CCPWrite>
}
    633e:	23 96       	adiw	r28, 0x03	; 3
    6340:	cd bf       	out	0x3d, r28	; 61
    6342:	de bf       	out	0x3e, r29	; 62
    6344:	df 91       	pop	r29
    6346:	cf 91       	pop	r28
    6348:	08 95       	ret

0000634a <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    634a:	cf 93       	push	r28
    634c:	df 93       	push	r29
    634e:	0f 92       	push	r0
    6350:	0f 92       	push	r0
    6352:	cd b7       	in	r28, 0x3d	; 61
    6354:	de b7       	in	r29, 0x3e	; 62
    6356:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    6358:	80 e4       	ldi	r24, 0x40	; 64
    635a:	90 e0       	ldi	r25, 0x00	; 0
    635c:	fc 01       	movw	r30, r24
    635e:	80 81       	ld	r24, Z
    6360:	98 2f       	mov	r25, r24
    6362:	98 7f       	andi	r25, 0xF8	; 248
    6364:	8a 81       	ldd	r24, Y+2	; 0x02
    6366:	89 2b       	or	r24, r25
    6368:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.CTRL, clkCtrl );
    636a:	80 e4       	ldi	r24, 0x40	; 64
    636c:	90 e0       	ldi	r25, 0x00	; 0
    636e:	69 81       	ldd	r22, Y+1	; 0x01
    6370:	0e 94 11 31 	call	0x6222	; 0x6222 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    6374:	80 e4       	ldi	r24, 0x40	; 64
    6376:	90 e0       	ldi	r25, 0x00	; 0
    6378:	fc 01       	movw	r30, r24
    637a:	90 81       	ld	r25, Z
    637c:	8a 81       	ldd	r24, Y+2	; 0x02
    637e:	89 23       	and	r24, r25
    6380:	89 83       	std	Y+1, r24	; 0x01
	return clkCtrl;
    6382:	89 81       	ldd	r24, Y+1	; 0x01
}
    6384:	0f 90       	pop	r0
    6386:	0f 90       	pop	r0
    6388:	df 91       	pop	r29
    638a:	cf 91       	pop	r28
    638c:	08 95       	ret

0000638e <CLKSYS_RTC_ClockSource_Enable>:
 *  and enables clock signal routing to the RTC module.
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
    638e:	cf 93       	push	r28
    6390:	df 93       	push	r29
    6392:	0f 92       	push	r0
    6394:	cd b7       	in	r28, 0x3d	; 61
    6396:	de b7       	in	r29, 0x3e	; 62
    6398:	89 83       	std	Y+1, r24	; 0x01
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    639a:	80 e4       	ldi	r24, 0x40	; 64
    639c:	90 e0       	ldi	r25, 0x00	; 0
    639e:	20 e4       	ldi	r18, 0x40	; 64
    63a0:	30 e0       	ldi	r19, 0x00	; 0
    63a2:	f9 01       	movw	r30, r18
    63a4:	23 81       	ldd	r18, Z+3	; 0x03
    63a6:	32 2f       	mov	r19, r18
    63a8:	31 7f       	andi	r19, 0xF1	; 241
    63aa:	29 81       	ldd	r18, Y+1	; 0x01
    63ac:	23 2b       	or	r18, r19
    63ae:	21 60       	ori	r18, 0x01	; 1
    63b0:	fc 01       	movw	r30, r24
    63b2:	23 83       	std	Z+3, r18	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    63b4:	0f 90       	pop	r0
    63b6:	df 91       	pop	r29
    63b8:	cf 91       	pop	r28
    63ba:	08 95       	ret

000063bc <CLKSYS_AutoCalibration_Enable>:
 *  \param  clkSource    Clock source to calibrate, either OSC_RC2MCREF_bm or
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
    63bc:	cf 93       	push	r28
    63be:	df 93       	push	r29
    63c0:	0f 92       	push	r0
    63c2:	0f 92       	push	r0
    63c4:	cd b7       	in	r28, 0x3d	; 61
    63c6:	de b7       	in	r29, 0x3e	; 62
    63c8:	89 83       	std	Y+1, r24	; 0x01
    63ca:	6a 83       	std	Y+2, r22	; 0x02
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    63cc:	80 e5       	ldi	r24, 0x50	; 80
    63ce:	90 e0       	ldi	r25, 0x00	; 0
    63d0:	20 e5       	ldi	r18, 0x50	; 80
    63d2:	30 e0       	ldi	r19, 0x00	; 0
    63d4:	f9 01       	movw	r30, r18
    63d6:	26 81       	ldd	r18, Z+6	; 0x06
    63d8:	32 2f       	mov	r19, r18
    63da:	29 81       	ldd	r18, Y+1	; 0x01
    63dc:	20 95       	com	r18
    63de:	32 23       	and	r19, r18
    63e0:	2a 81       	ldd	r18, Y+2	; 0x02
    63e2:	22 23       	and	r18, r18
    63e4:	11 f0       	breq	.+4      	; 0x63ea <CLKSYS_AutoCalibration_Enable+0x2e>
    63e6:	29 81       	ldd	r18, Y+1	; 0x01
    63e8:	01 c0       	rjmp	.+2      	; 0x63ec <CLKSYS_AutoCalibration_Enable+0x30>
    63ea:	20 e0       	ldi	r18, 0x00	; 0
    63ec:	23 2b       	or	r18, r19
    63ee:	fc 01       	movw	r30, r24
    63f0:	26 83       	std	Z+6, r18	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    63f2:	89 81       	ldd	r24, Y+1	; 0x01
    63f4:	81 30       	cpi	r24, 0x01	; 1
    63f6:	51 f4       	brne	.+20     	; 0x640c <CLKSYS_AutoCalibration_Enable+0x50>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    63f8:	88 e6       	ldi	r24, 0x68	; 104
    63fa:	90 e0       	ldi	r25, 0x00	; 0
    63fc:	28 e6       	ldi	r18, 0x68	; 104
    63fe:	30 e0       	ldi	r19, 0x00	; 0
    6400:	f9 01       	movw	r30, r18
    6402:	20 81       	ld	r18, Z
    6404:	21 60       	ori	r18, 0x01	; 1
    6406:	fc 01       	movw	r30, r24
    6408:	20 83       	st	Z, r18
    640a:	0c c0       	rjmp	.+24     	; 0x6424 <CLKSYS_AutoCalibration_Enable+0x68>
	} else if (clkSource == OSC_RC32MCREF_bm) {
    640c:	89 81       	ldd	r24, Y+1	; 0x01
    640e:	82 30       	cpi	r24, 0x02	; 2
    6410:	49 f4       	brne	.+18     	; 0x6424 <CLKSYS_AutoCalibration_Enable+0x68>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    6412:	80 e6       	ldi	r24, 0x60	; 96
    6414:	90 e0       	ldi	r25, 0x00	; 0
    6416:	20 e6       	ldi	r18, 0x60	; 96
    6418:	30 e0       	ldi	r19, 0x00	; 0
    641a:	f9 01       	movw	r30, r18
    641c:	20 81       	ld	r18, Z
    641e:	21 60       	ori	r18, 0x01	; 1
    6420:	fc 01       	movw	r30, r24
    6422:	20 83       	st	Z, r18
	}
}
    6424:	0f 90       	pop	r0
    6426:	0f 90       	pop	r0
    6428:	df 91       	pop	r29
    642a:	cf 91       	pop	r28
    642c:	08 95       	ret

0000642e <CLKSYS_XOSC_FailureDetection_Enable>:
 *  XOSCFD _will_ issue the XOSCF Non-maskable Interrupt (NMI) regardless of
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
    642e:	cf 93       	push	r28
    6430:	df 93       	push	r29
    6432:	cd b7       	in	r28, 0x3d	; 61
    6434:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    6436:	83 e5       	ldi	r24, 0x53	; 83
    6438:	90 e0       	ldi	r25, 0x00	; 0
    643a:	63 e0       	ldi	r22, 0x03	; 3
    643c:	0e 94 11 31 	call	0x6222	; 0x6222 <CCPWrite>
}
    6440:	df 91       	pop	r29
    6442:	cf 91       	pop	r28
    6444:	08 95       	ret

00006446 <CLKSYS_Configuration_Lock>:
 *  This will lock the configuration until the next reset, or until the
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
    6446:	cf 93       	push	r28
    6448:	df 93       	push	r29
    644a:	cd b7       	in	r28, 0x3d	; 61
    644c:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    644e:	82 e4       	ldi	r24, 0x42	; 66
    6450:	90 e0       	ldi	r25, 0x00	; 0
    6452:	61 e0       	ldi	r22, 0x01	; 1
    6454:	0e 94 11 31 	call	0x6222	; 0x6222 <CCPWrite>
}
    6458:	df 91       	pop	r29
    645a:	cf 91       	pop	r28
    645c:	08 95       	ret

0000645e <setXOSC_32MHz>:
// so this function will fail until the oscillator is installed.
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
    645e:	cf 93       	push	r28
    6460:	df 93       	push	r29
    6462:	cd b7       	in	r28, 0x3d	; 61
    6464:	de b7       	in	r29, 0x3e	; 62
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    6466:	80 ec       	ldi	r24, 0xC0	; 192
    6468:	60 e0       	ldi	r22, 0x00	; 0
    646a:	4b e0       	ldi	r20, 0x0B	; 11
    646c:	0e 94 3c 31 	call	0x6278	; 0x6278 <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    6470:	80 e5       	ldi	r24, 0x50	; 80
    6472:	90 e0       	ldi	r25, 0x00	; 0
    6474:	20 e5       	ldi	r18, 0x50	; 80
    6476:	30 e0       	ldi	r19, 0x00	; 0
    6478:	f9 01       	movw	r30, r18
    647a:	20 81       	ld	r18, Z
    647c:	28 60       	ori	r18, 0x08	; 8
    647e:	fc 01       	movw	r30, r24
    6480:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    6482:	80 e5       	ldi	r24, 0x50	; 80
    6484:	90 e0       	ldi	r25, 0x00	; 0
    6486:	fc 01       	movw	r30, r24
    6488:	81 81       	ldd	r24, Z+1	; 0x01
    648a:	88 2f       	mov	r24, r24
    648c:	90 e0       	ldi	r25, 0x00	; 0
    648e:	88 70       	andi	r24, 0x08	; 8
    6490:	90 70       	andi	r25, 0x00	; 0
    6492:	00 97       	sbiw	r24, 0x00	; 0
    6494:	b1 f3       	breq	.-20     	; 0x6482 <setXOSC_32MHz+0x24>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    6496:	80 ec       	ldi	r24, 0xC0	; 192
    6498:	62 e0       	ldi	r22, 0x02	; 2
    649a:	0e 94 58 31 	call	0x62b0	; 0x62b0 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    649e:	80 e5       	ldi	r24, 0x50	; 80
    64a0:	90 e0       	ldi	r25, 0x00	; 0
    64a2:	20 e5       	ldi	r18, 0x50	; 80
    64a4:	30 e0       	ldi	r19, 0x00	; 0
    64a6:	f9 01       	movw	r30, r18
    64a8:	20 81       	ld	r18, Z
    64aa:	20 61       	ori	r18, 0x10	; 16
    64ac:	fc 01       	movw	r30, r24
    64ae:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    64b0:	80 e5       	ldi	r24, 0x50	; 80
    64b2:	90 e0       	ldi	r25, 0x00	; 0
    64b4:	fc 01       	movw	r30, r24
    64b6:	81 81       	ldd	r24, Z+1	; 0x01
    64b8:	88 2f       	mov	r24, r24
    64ba:	90 e0       	ldi	r25, 0x00	; 0
    64bc:	80 71       	andi	r24, 0x10	; 16
    64be:	90 70       	andi	r25, 0x00	; 0
    64c0:	00 97       	sbiw	r24, 0x00	; 0
    64c2:	b1 f3       	breq	.-20     	; 0x64b0 <setXOSC_32MHz+0x52>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    64c4:	84 e0       	ldi	r24, 0x04	; 4
    64c6:	0e 94 a5 31 	call	0x634a	; 0x634a <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    64ca:	81 e0       	ldi	r24, 0x01	; 1
    64cc:	0e 94 6f 31 	call	0x62de	; 0x62de <CLKSYS_Disable>
}
    64d0:	df 91       	pop	r29
    64d2:	cf 91       	pop	r28
    64d4:	08 95       	ret

000064d6 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
    64d6:	cf 93       	push	r28
    64d8:	df 93       	push	r29
    64da:	cd b7       	in	r28, 0x3d	; 61
    64dc:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    64de:	80 e5       	ldi	r24, 0x50	; 80
    64e0:	90 e0       	ldi	r25, 0x00	; 0
    64e2:	20 e5       	ldi	r18, 0x50	; 80
    64e4:	30 e0       	ldi	r19, 0x00	; 0
    64e6:	f9 01       	movw	r30, r18
    64e8:	20 81       	ld	r18, Z
    64ea:	22 60       	ori	r18, 0x02	; 2
    64ec:	fc 01       	movw	r30, r24
    64ee:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    64f0:	80 e0       	ldi	r24, 0x00	; 0
    64f2:	61 e0       	ldi	r22, 0x01	; 1
    64f4:	0e 94 8f 31 	call	0x631e	; 0x631e <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    64f8:	80 e5       	ldi	r24, 0x50	; 80
    64fa:	90 e0       	ldi	r25, 0x00	; 0
    64fc:	fc 01       	movw	r30, r24
    64fe:	81 81       	ldd	r24, Z+1	; 0x01
    6500:	88 2f       	mov	r24, r24
    6502:	90 e0       	ldi	r25, 0x00	; 0
    6504:	82 70       	andi	r24, 0x02	; 2
    6506:	90 70       	andi	r25, 0x00	; 0
    6508:	00 97       	sbiw	r24, 0x00	; 0
    650a:	b1 f3       	breq	.-20     	; 0x64f8 <set_16MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    650c:	81 e0       	ldi	r24, 0x01	; 1
    650e:	0e 94 a5 31 	call	0x634a	; 0x634a <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6512:	81 e0       	ldi	r24, 0x01	; 1
    6514:	0e 94 6f 31 	call	0x62de	; 0x62de <CLKSYS_Disable>
	
}
    6518:	df 91       	pop	r29
    651a:	cf 91       	pop	r28
    651c:	08 95       	ret

0000651e <set_32MHz>:


// produces consistent but inaccurate clock period.
void set_32MHz() {
    651e:	cf 93       	push	r28
    6520:	df 93       	push	r29
    6522:	cd b7       	in	r28, 0x3d	; 61
    6524:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    6526:	80 e5       	ldi	r24, 0x50	; 80
    6528:	90 e0       	ldi	r25, 0x00	; 0
    652a:	20 e5       	ldi	r18, 0x50	; 80
    652c:	30 e0       	ldi	r19, 0x00	; 0
    652e:	f9 01       	movw	r30, r18
    6530:	20 81       	ld	r18, Z
    6532:	22 60       	ori	r18, 0x02	; 2
    6534:	fc 01       	movw	r30, r24
    6536:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    6538:	80 e0       	ldi	r24, 0x00	; 0
    653a:	60 e0       	ldi	r22, 0x00	; 0
    653c:	0e 94 8f 31 	call	0x631e	; 0x631e <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    6540:	80 e5       	ldi	r24, 0x50	; 80
    6542:	90 e0       	ldi	r25, 0x00	; 0
    6544:	fc 01       	movw	r30, r24
    6546:	81 81       	ldd	r24, Z+1	; 0x01
    6548:	88 2f       	mov	r24, r24
    654a:	90 e0       	ldi	r25, 0x00	; 0
    654c:	82 70       	andi	r24, 0x02	; 2
    654e:	90 70       	andi	r25, 0x00	; 0
    6550:	00 97       	sbiw	r24, 0x00	; 0
    6552:	b1 f3       	breq	.-20     	; 0x6540 <set_32MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    6554:	81 e0       	ldi	r24, 0x01	; 1
    6556:	0e 94 a5 31 	call	0x634a	; 0x634a <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    655a:	81 e0       	ldi	r24, 0x01	; 1
    655c:	0e 94 6f 31 	call	0x62de	; 0x62de <CLKSYS_Disable>
	
}
    6560:	df 91       	pop	r29
    6562:	cf 91       	pop	r28
    6564:	08 95       	ret

00006566 <portExCS>:


void portExCS(uint8_t write) {
    6566:	0f 93       	push	r16
    6568:	1f 93       	push	r17
    656a:	cf 93       	push	r28
    656c:	df 93       	push	r29
    656e:	cd b7       	in	r28, 0x3d	; 61
    6570:	de b7       	in	r29, 0x3e	; 62
    6572:	69 97       	sbiw	r28, 0x19	; 25
    6574:	cd bf       	out	0x3d, r28	; 61
    6576:	de bf       	out	0x3e, r29	; 62
    6578:	89 8f       	std	Y+25, r24	; 0x19
	if (write) PORTA.OUTCLR = PIN3_bm;
    657a:	89 8d       	ldd	r24, Y+25	; 0x19
    657c:	88 23       	and	r24, r24
    657e:	31 f0       	breq	.+12     	; 0x658c <portExCS+0x26>
    6580:	80 e0       	ldi	r24, 0x00	; 0
    6582:	96 e0       	ldi	r25, 0x06	; 6
    6584:	28 e0       	ldi	r18, 0x08	; 8
    6586:	fc 01       	movw	r30, r24
    6588:	26 83       	std	Z+6, r18	; 0x06
    658a:	05 c0       	rjmp	.+10     	; 0x6596 <portExCS+0x30>
	else {
		PORTA.OUTSET = PIN3_bm;
    658c:	80 e0       	ldi	r24, 0x00	; 0
    658e:	96 e0       	ldi	r25, 0x06	; 6
    6590:	28 e0       	ldi	r18, 0x08	; 8
    6592:	fc 01       	movw	r30, r24
    6594:	25 83       	std	Z+5, r18	; 0x05
    6596:	80 e0       	ldi	r24, 0x00	; 0
    6598:	90 e0       	ldi	r25, 0x00	; 0
    659a:	a0 e2       	ldi	r26, 0x20	; 32
    659c:	b1 e4       	ldi	r27, 0x41	; 65
    659e:	89 83       	std	Y+1, r24	; 0x01
    65a0:	9a 83       	std	Y+2, r25	; 0x02
    65a2:	ab 83       	std	Y+3, r26	; 0x03
    65a4:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    65a6:	69 81       	ldd	r22, Y+1	; 0x01
    65a8:	7a 81       	ldd	r23, Y+2	; 0x02
    65aa:	8b 81       	ldd	r24, Y+3	; 0x03
    65ac:	9c 81       	ldd	r25, Y+4	; 0x04
    65ae:	2b ea       	ldi	r18, 0xAB	; 171
    65b0:	3a ea       	ldi	r19, 0xAA	; 170
    65b2:	4a e2       	ldi	r20, 0x2A	; 42
    65b4:	51 e4       	ldi	r21, 0x41	; 65
    65b6:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    65ba:	dc 01       	movw	r26, r24
    65bc:	cb 01       	movw	r24, r22
    65be:	8d 83       	std	Y+5, r24	; 0x05
    65c0:	9e 83       	std	Y+6, r25	; 0x06
    65c2:	af 83       	std	Y+7, r26	; 0x07
    65c4:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    65c6:	11 e0       	ldi	r17, 0x01	; 1
    65c8:	6d 81       	ldd	r22, Y+5	; 0x05
    65ca:	7e 81       	ldd	r23, Y+6	; 0x06
    65cc:	8f 81       	ldd	r24, Y+7	; 0x07
    65ce:	98 85       	ldd	r25, Y+8	; 0x08
    65d0:	20 e0       	ldi	r18, 0x00	; 0
    65d2:	30 e0       	ldi	r19, 0x00	; 0
    65d4:	40 e8       	ldi	r20, 0x80	; 128
    65d6:	5f e3       	ldi	r21, 0x3F	; 63
    65d8:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    65dc:	88 23       	and	r24, r24
    65de:	0c f0       	brlt	.+2      	; 0x65e2 <portExCS+0x7c>
    65e0:	10 e0       	ldi	r17, 0x00	; 0
    65e2:	11 23       	and	r17, r17
    65e4:	19 f0       	breq	.+6      	; 0x65ec <portExCS+0x86>
		__ticks = 1;
    65e6:	81 e0       	ldi	r24, 0x01	; 1
    65e8:	89 87       	std	Y+9, r24	; 0x09
    65ea:	a3 c0       	rjmp	.+326    	; 0x6732 <portExCS+0x1cc>
	else if (__tmp > 255)
    65ec:	11 e0       	ldi	r17, 0x01	; 1
    65ee:	6d 81       	ldd	r22, Y+5	; 0x05
    65f0:	7e 81       	ldd	r23, Y+6	; 0x06
    65f2:	8f 81       	ldd	r24, Y+7	; 0x07
    65f4:	98 85       	ldd	r25, Y+8	; 0x08
    65f6:	20 e0       	ldi	r18, 0x00	; 0
    65f8:	30 e0       	ldi	r19, 0x00	; 0
    65fa:	4f e7       	ldi	r20, 0x7F	; 127
    65fc:	53 e4       	ldi	r21, 0x43	; 67
    65fe:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    6602:	18 16       	cp	r1, r24
    6604:	0c f0       	brlt	.+2      	; 0x6608 <portExCS+0xa2>
    6606:	10 e0       	ldi	r17, 0x00	; 0
    6608:	11 23       	and	r17, r17
    660a:	09 f4       	brne	.+2      	; 0x660e <portExCS+0xa8>
    660c:	89 c0       	rjmp	.+274    	; 0x6720 <portExCS+0x1ba>
	{
		_delay_ms(__us / 1000.0);
    660e:	69 81       	ldd	r22, Y+1	; 0x01
    6610:	7a 81       	ldd	r23, Y+2	; 0x02
    6612:	8b 81       	ldd	r24, Y+3	; 0x03
    6614:	9c 81       	ldd	r25, Y+4	; 0x04
    6616:	20 e0       	ldi	r18, 0x00	; 0
    6618:	30 e0       	ldi	r19, 0x00	; 0
    661a:	4a e7       	ldi	r20, 0x7A	; 122
    661c:	54 e4       	ldi	r21, 0x44	; 68
    661e:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
    6622:	dc 01       	movw	r26, r24
    6624:	cb 01       	movw	r24, r22
    6626:	8a 87       	std	Y+10, r24	; 0x0a
    6628:	9b 87       	std	Y+11, r25	; 0x0b
    662a:	ac 87       	std	Y+12, r26	; 0x0c
    662c:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    662e:	6a 85       	ldd	r22, Y+10	; 0x0a
    6630:	7b 85       	ldd	r23, Y+11	; 0x0b
    6632:	8c 85       	ldd	r24, Y+12	; 0x0c
    6634:	9d 85       	ldd	r25, Y+13	; 0x0d
    6636:	20 e0       	ldi	r18, 0x00	; 0
    6638:	30 e0       	ldi	r19, 0x00	; 0
    663a:	4a ef       	ldi	r20, 0xFA	; 250
    663c:	55 e4       	ldi	r21, 0x45	; 69
    663e:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    6642:	dc 01       	movw	r26, r24
    6644:	cb 01       	movw	r24, r22
    6646:	8e 87       	std	Y+14, r24	; 0x0e
    6648:	9f 87       	std	Y+15, r25	; 0x0f
    664a:	a8 8b       	std	Y+16, r26	; 0x10
    664c:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    664e:	11 e0       	ldi	r17, 0x01	; 1
    6650:	6e 85       	ldd	r22, Y+14	; 0x0e
    6652:	7f 85       	ldd	r23, Y+15	; 0x0f
    6654:	88 89       	ldd	r24, Y+16	; 0x10
    6656:	99 89       	ldd	r25, Y+17	; 0x11
    6658:	20 e0       	ldi	r18, 0x00	; 0
    665a:	30 e0       	ldi	r19, 0x00	; 0
    665c:	40 e8       	ldi	r20, 0x80	; 128
    665e:	5f e3       	ldi	r21, 0x3F	; 63
    6660:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    6664:	88 23       	and	r24, r24
    6666:	0c f0       	brlt	.+2      	; 0x666a <portExCS+0x104>
    6668:	10 e0       	ldi	r17, 0x00	; 0
    666a:	11 23       	and	r17, r17
    666c:	29 f0       	breq	.+10     	; 0x6678 <portExCS+0x112>
		__ticks = 1;
    666e:	81 e0       	ldi	r24, 0x01	; 1
    6670:	90 e0       	ldi	r25, 0x00	; 0
    6672:	8a 8b       	std	Y+18, r24	; 0x12
    6674:	9b 8b       	std	Y+19, r25	; 0x13
    6676:	46 c0       	rjmp	.+140    	; 0x6704 <portExCS+0x19e>
	else if (__tmp > 65535)
    6678:	11 e0       	ldi	r17, 0x01	; 1
    667a:	6e 85       	ldd	r22, Y+14	; 0x0e
    667c:	7f 85       	ldd	r23, Y+15	; 0x0f
    667e:	88 89       	ldd	r24, Y+16	; 0x10
    6680:	99 89       	ldd	r25, Y+17	; 0x11
    6682:	20 e0       	ldi	r18, 0x00	; 0
    6684:	3f ef       	ldi	r19, 0xFF	; 255
    6686:	4f e7       	ldi	r20, 0x7F	; 127
    6688:	57 e4       	ldi	r21, 0x47	; 71
    668a:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    668e:	18 16       	cp	r1, r24
    6690:	0c f0       	brlt	.+2      	; 0x6694 <portExCS+0x12e>
    6692:	10 e0       	ldi	r17, 0x00	; 0
    6694:	11 23       	and	r17, r17
    6696:	61 f1       	breq	.+88     	; 0x66f0 <portExCS+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6698:	6a 85       	ldd	r22, Y+10	; 0x0a
    669a:	7b 85       	ldd	r23, Y+11	; 0x0b
    669c:	8c 85       	ldd	r24, Y+12	; 0x0c
    669e:	9d 85       	ldd	r25, Y+13	; 0x0d
    66a0:	20 e0       	ldi	r18, 0x00	; 0
    66a2:	30 e0       	ldi	r19, 0x00	; 0
    66a4:	40 e2       	ldi	r20, 0x20	; 32
    66a6:	51 e4       	ldi	r21, 0x41	; 65
    66a8:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    66ac:	dc 01       	movw	r26, r24
    66ae:	cb 01       	movw	r24, r22
    66b0:	bc 01       	movw	r22, r24
    66b2:	cd 01       	movw	r24, r26
    66b4:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    66b8:	dc 01       	movw	r26, r24
    66ba:	cb 01       	movw	r24, r22
    66bc:	8a 8b       	std	Y+18, r24	; 0x12
    66be:	9b 8b       	std	Y+19, r25	; 0x13
    66c0:	12 c0       	rjmp	.+36     	; 0x66e6 <portExCS+0x180>
    66c2:	80 e2       	ldi	r24, 0x20	; 32
    66c4:	93 e0       	ldi	r25, 0x03	; 3
    66c6:	8c 8b       	std	Y+20, r24	; 0x14
    66c8:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    66ca:	8c 89       	ldd	r24, Y+20	; 0x14
    66cc:	9d 89       	ldd	r25, Y+21	; 0x15
    66ce:	8c 01       	movw	r16, r24
    66d0:	c8 01       	movw	r24, r16
    66d2:	01 97       	sbiw	r24, 0x01	; 1
    66d4:	f1 f7       	brne	.-4      	; 0x66d2 <portExCS+0x16c>
    66d6:	8c 01       	movw	r16, r24
    66d8:	0c 8b       	std	Y+20, r16	; 0x14
    66da:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    66dc:	8a 89       	ldd	r24, Y+18	; 0x12
    66de:	9b 89       	ldd	r25, Y+19	; 0x13
    66e0:	01 97       	sbiw	r24, 0x01	; 1
    66e2:	8a 8b       	std	Y+18, r24	; 0x12
    66e4:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    66e6:	8a 89       	ldd	r24, Y+18	; 0x12
    66e8:	9b 89       	ldd	r25, Y+19	; 0x13
    66ea:	00 97       	sbiw	r24, 0x00	; 0
    66ec:	51 f7       	brne	.-44     	; 0x66c2 <portExCS+0x15c>
    66ee:	28 c0       	rjmp	.+80     	; 0x6740 <portExCS+0x1da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    66f0:	6e 85       	ldd	r22, Y+14	; 0x0e
    66f2:	7f 85       	ldd	r23, Y+15	; 0x0f
    66f4:	88 89       	ldd	r24, Y+16	; 0x10
    66f6:	99 89       	ldd	r25, Y+17	; 0x11
    66f8:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    66fc:	dc 01       	movw	r26, r24
    66fe:	cb 01       	movw	r24, r22
    6700:	8a 8b       	std	Y+18, r24	; 0x12
    6702:	9b 8b       	std	Y+19, r25	; 0x13
    6704:	8a 89       	ldd	r24, Y+18	; 0x12
    6706:	9b 89       	ldd	r25, Y+19	; 0x13
    6708:	8e 8b       	std	Y+22, r24	; 0x16
    670a:	9f 8b       	std	Y+23, r25	; 0x17
    670c:	8e 89       	ldd	r24, Y+22	; 0x16
    670e:	9f 89       	ldd	r25, Y+23	; 0x17
    6710:	8c 01       	movw	r16, r24
    6712:	f8 01       	movw	r30, r16
    6714:	31 97       	sbiw	r30, 0x01	; 1
    6716:	f1 f7       	brne	.-4      	; 0x6714 <portExCS+0x1ae>
    6718:	8f 01       	movw	r16, r30
    671a:	0e 8b       	std	Y+22, r16	; 0x16
    671c:	1f 8b       	std	Y+23, r17	; 0x17
    671e:	10 c0       	rjmp	.+32     	; 0x6740 <portExCS+0x1da>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6720:	6d 81       	ldd	r22, Y+5	; 0x05
    6722:	7e 81       	ldd	r23, Y+6	; 0x06
    6724:	8f 81       	ldd	r24, Y+7	; 0x07
    6726:	98 85       	ldd	r25, Y+8	; 0x08
    6728:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    672c:	dc 01       	movw	r26, r24
    672e:	cb 01       	movw	r24, r22
    6730:	89 87       	std	Y+9, r24	; 0x09
    6732:	89 85       	ldd	r24, Y+9	; 0x09
    6734:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6736:	88 8d       	ldd	r24, Y+24	; 0x18
    6738:	18 2f       	mov	r17, r24
    673a:	1a 95       	dec	r17
    673c:	f1 f7       	brne	.-4      	; 0x673a <portExCS+0x1d4>
    673e:	18 8f       	std	Y+24, r17	; 0x18
	}
	_delay_us(10);
}
    6740:	69 96       	adiw	r28, 0x19	; 25
    6742:	cd bf       	out	0x3d, r28	; 61
    6744:	de bf       	out	0x3e, r29	; 62
    6746:	df 91       	pop	r29
    6748:	cf 91       	pop	r28
    674a:	1f 91       	pop	r17
    674c:	0f 91       	pop	r16
    674e:	08 95       	ret

00006750 <PortEx_DIRSET>:

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    6750:	cf 93       	push	r28
    6752:	df 93       	push	r29
    6754:	00 d0       	rcall	.+0      	; 0x6756 <PortEx_DIRSET+0x6>
    6756:	cd b7       	in	r28, 0x3d	; 61
    6758:	de b7       	in	r29, 0x3e	; 62
    675a:	8a 83       	std	Y+2, r24	; 0x02
    675c:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    675e:	80 e0       	ldi	r24, 0x00	; 0
    6760:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
	SPICS(TRUE);
    6764:	81 e0       	ldi	r24, 0x01	; 1
    6766:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	portExCS(TRUE);
    676a:	81 e0       	ldi	r24, 0x01	; 1
    676c:	0e 94 b3 32 	call	0x6566	; 0x6566 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    6770:	8b 81       	ldd	r24, Y+3	; 0x03
    6772:	88 23       	and	r24, r24
    6774:	39 f0       	breq	.+14     	; 0x6784 <PortEx_DIRSET+0x34>
    6776:	90 91 6f 50 	lds	r25, 0x506F
    677a:	8a 81       	ldd	r24, Y+2	; 0x02
    677c:	89 2b       	or	r24, r25
    677e:	80 93 6f 50 	sts	0x506F, r24
    6782:	06 c0       	rjmp	.+12     	; 0x6790 <PortEx_DIRSET+0x40>
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    6784:	90 91 ca 50 	lds	r25, 0x50CA
    6788:	8a 81       	ldd	r24, Y+2	; 0x02
    678a:	89 2b       	or	r24, r25
    678c:	80 93 ca 50 	sts	0x50CA, r24
	
	SPIBuffer[0] = PS_WRITE;
    6790:	80 e4       	ldi	r24, 0x40	; 64
    6792:	80 93 5a 50 	sts	0x505A, r24
	if(bank) {
    6796:	8b 81       	ldd	r24, Y+3	; 0x03
    6798:	88 23       	and	r24, r24
    679a:	41 f0       	breq	.+16     	; 0x67ac <PortEx_DIRSET+0x5c>
		SPIBuffer[1]=PS_IODIRA;
    679c:	10 92 5b 50 	sts	0x505B, r1
		SPIBuffer[2] = ~bankA_DIR; 
    67a0:	80 91 6f 50 	lds	r24, 0x506F
    67a4:	80 95       	com	r24
    67a6:	80 93 5c 50 	sts	0x505C, r24
    67aa:	08 c0       	rjmp	.+16     	; 0x67bc <PortEx_DIRSET+0x6c>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    67ac:	81 e0       	ldi	r24, 0x01	; 1
    67ae:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = ~bankB_DIR;
    67b2:	80 91 ca 50 	lds	r24, 0x50CA
    67b6:	80 95       	com	r24
    67b8:	80 93 5c 50 	sts	0x505C, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    67bc:	19 82       	std	Y+1, r1	; 0x01
    67be:	1b c0       	rjmp	.+54     	; 0x67f6 <PortEx_DIRSET+0xa6>
		SPIC.DATA = SPIBuffer[bufIndex];
    67c0:	80 ec       	ldi	r24, 0xC0	; 192
    67c2:	98 e0       	ldi	r25, 0x08	; 8
    67c4:	29 81       	ldd	r18, Y+1	; 0x01
    67c6:	22 2f       	mov	r18, r18
    67c8:	30 e0       	ldi	r19, 0x00	; 0
    67ca:	26 5a       	subi	r18, 0xA6	; 166
    67cc:	3f 4a       	sbci	r19, 0xAF	; 175
    67ce:	f9 01       	movw	r30, r18
    67d0:	20 81       	ld	r18, Z
    67d2:	fc 01       	movw	r30, r24
    67d4:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    67d6:	00 00       	nop
    67d8:	80 ec       	ldi	r24, 0xC0	; 192
    67da:	98 e0       	ldi	r25, 0x08	; 8
    67dc:	fc 01       	movw	r30, r24
    67de:	82 81       	ldd	r24, Z+2	; 0x02
    67e0:	88 23       	and	r24, r24
    67e2:	d4 f7       	brge	.-12     	; 0x67d8 <PortEx_DIRSET+0x88>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    67e4:	80 ec       	ldi	r24, 0xC0	; 192
    67e6:	98 e0       	ldi	r25, 0x08	; 8
    67e8:	fc 01       	movw	r30, r24
    67ea:	83 81       	ldd	r24, Z+3	; 0x03
    67ec:	80 93 66 50 	sts	0x5066, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    67f0:	89 81       	ldd	r24, Y+1	; 0x01
    67f2:	8f 5f       	subi	r24, 0xFF	; 255
    67f4:	89 83       	std	Y+1, r24	; 0x01
    67f6:	89 81       	ldd	r24, Y+1	; 0x01
    67f8:	83 30       	cpi	r24, 0x03	; 3
    67fa:	10 f3       	brcs	.-60     	; 0x67c0 <PortEx_DIRSET+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    67fc:	80 e0       	ldi	r24, 0x00	; 0
    67fe:	0e 94 b3 32 	call	0x6566	; 0x6566 <portExCS>
	SPICS(FALSE);
    6802:	80 e0       	ldi	r24, 0x00	; 0
    6804:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	SPIDisable();
    6808:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>


}
    680c:	23 96       	adiw	r28, 0x03	; 3
    680e:	cd bf       	out	0x3d, r28	; 61
    6810:	de bf       	out	0x3e, r29	; 62
    6812:	df 91       	pop	r29
    6814:	cf 91       	pop	r28
    6816:	08 95       	ret

00006818 <PortEx_DIRCLR>:

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    6818:	cf 93       	push	r28
    681a:	df 93       	push	r29
    681c:	00 d0       	rcall	.+0      	; 0x681e <PortEx_DIRCLR+0x6>
    681e:	cd b7       	in	r28, 0x3d	; 61
    6820:	de b7       	in	r29, 0x3e	; 62
    6822:	8a 83       	std	Y+2, r24	; 0x02
    6824:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6826:	80 e0       	ldi	r24, 0x00	; 0
    6828:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
	SPICS(TRUE);
    682c:	81 e0       	ldi	r24, 0x01	; 1
    682e:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	portExCS(TRUE);
    6832:	81 e0       	ldi	r24, 0x01	; 1
    6834:	0e 94 b3 32 	call	0x6566	; 0x6566 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    6838:	8b 81       	ldd	r24, Y+3	; 0x03
    683a:	88 23       	and	r24, r24
    683c:	49 f0       	breq	.+18     	; 0x6850 <PortEx_DIRCLR+0x38>
    683e:	80 91 6f 50 	lds	r24, 0x506F
    6842:	98 2f       	mov	r25, r24
    6844:	90 95       	com	r25
    6846:	8a 81       	ldd	r24, Y+2	; 0x02
    6848:	89 23       	and	r24, r25
    684a:	80 93 6f 50 	sts	0x506F, r24
    684e:	08 c0       	rjmp	.+16     	; 0x6860 <PortEx_DIRCLR+0x48>
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    6850:	80 91 ca 50 	lds	r24, 0x50CA
    6854:	98 2f       	mov	r25, r24
    6856:	90 95       	com	r25
    6858:	8a 81       	ldd	r24, Y+2	; 0x02
    685a:	89 23       	and	r24, r25
    685c:	80 93 ca 50 	sts	0x50CA, r24
	
	SPIBuffer[0] = PS_WRITE;
    6860:	80 e4       	ldi	r24, 0x40	; 64
    6862:	80 93 5a 50 	sts	0x505A, r24
	if(bank) {
    6866:	8b 81       	ldd	r24, Y+3	; 0x03
    6868:	88 23       	and	r24, r24
    686a:	41 f0       	breq	.+16     	; 0x687c <PortEx_DIRCLR+0x64>
		SPIBuffer[1]=PS_IODIRA;
    686c:	10 92 5b 50 	sts	0x505B, r1
		SPIBuffer[2] = ~bankA_DIR; 
    6870:	80 91 6f 50 	lds	r24, 0x506F
    6874:	80 95       	com	r24
    6876:	80 93 5c 50 	sts	0x505C, r24
    687a:	08 c0       	rjmp	.+16     	; 0x688c <PortEx_DIRCLR+0x74>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    687c:	81 e0       	ldi	r24, 0x01	; 1
    687e:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = ~bankB_DIR;
    6882:	80 91 ca 50 	lds	r24, 0x50CA
    6886:	80 95       	com	r24
    6888:	80 93 5c 50 	sts	0x505C, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    688c:	19 82       	std	Y+1, r1	; 0x01
    688e:	1b c0       	rjmp	.+54     	; 0x68c6 <PortEx_DIRCLR+0xae>
		SPIC.DATA = SPIBuffer[bufIndex];
    6890:	80 ec       	ldi	r24, 0xC0	; 192
    6892:	98 e0       	ldi	r25, 0x08	; 8
    6894:	29 81       	ldd	r18, Y+1	; 0x01
    6896:	22 2f       	mov	r18, r18
    6898:	30 e0       	ldi	r19, 0x00	; 0
    689a:	26 5a       	subi	r18, 0xA6	; 166
    689c:	3f 4a       	sbci	r19, 0xAF	; 175
    689e:	f9 01       	movw	r30, r18
    68a0:	20 81       	ld	r18, Z
    68a2:	fc 01       	movw	r30, r24
    68a4:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    68a6:	00 00       	nop
    68a8:	80 ec       	ldi	r24, 0xC0	; 192
    68aa:	98 e0       	ldi	r25, 0x08	; 8
    68ac:	fc 01       	movw	r30, r24
    68ae:	82 81       	ldd	r24, Z+2	; 0x02
    68b0:	88 23       	and	r24, r24
    68b2:	d4 f7       	brge	.-12     	; 0x68a8 <PortEx_DIRCLR+0x90>
		SPIBuffer[12] = SPIC.DATA;
    68b4:	80 ec       	ldi	r24, 0xC0	; 192
    68b6:	98 e0       	ldi	r25, 0x08	; 8
    68b8:	fc 01       	movw	r30, r24
    68ba:	83 81       	ldd	r24, Z+3	; 0x03
    68bc:	80 93 66 50 	sts	0x5066, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    68c0:	89 81       	ldd	r24, Y+1	; 0x01
    68c2:	8f 5f       	subi	r24, 0xFF	; 255
    68c4:	89 83       	std	Y+1, r24	; 0x01
    68c6:	89 81       	ldd	r24, Y+1	; 0x01
    68c8:	83 30       	cpi	r24, 0x03	; 3
    68ca:	10 f3       	brcs	.-60     	; 0x6890 <PortEx_DIRCLR+0x78>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    68cc:	80 e0       	ldi	r24, 0x00	; 0
    68ce:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	portExCS(FALSE);
    68d2:	80 e0       	ldi	r24, 0x00	; 0
    68d4:	0e 94 b3 32 	call	0x6566	; 0x6566 <portExCS>
	SPIDisable();
    68d8:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>
}
    68dc:	23 96       	adiw	r28, 0x03	; 3
    68de:	cd bf       	out	0x3d, r28	; 61
    68e0:	de bf       	out	0x3e, r29	; 62
    68e2:	df 91       	pop	r29
    68e4:	cf 91       	pop	r28
    68e6:	08 95       	ret

000068e8 <PortEx_OUTSET>:

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    68e8:	cf 93       	push	r28
    68ea:	df 93       	push	r29
    68ec:	00 d0       	rcall	.+0      	; 0x68ee <PortEx_OUTSET+0x6>
    68ee:	cd b7       	in	r28, 0x3d	; 61
    68f0:	de b7       	in	r29, 0x3e	; 62
    68f2:	8a 83       	std	Y+2, r24	; 0x02
    68f4:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    68f6:	80 e0       	ldi	r24, 0x00	; 0
    68f8:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
	SPICS(TRUE);
    68fc:	81 e0       	ldi	r24, 0x01	; 1
    68fe:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	portExCS(TRUE);
    6902:	81 e0       	ldi	r24, 0x01	; 1
    6904:	0e 94 b3 32 	call	0x6566	; 0x6566 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    6908:	8b 81       	ldd	r24, Y+3	; 0x03
    690a:	88 23       	and	r24, r24
    690c:	39 f0       	breq	.+14     	; 0x691c <PortEx_OUTSET+0x34>
    690e:	90 91 c3 23 	lds	r25, 0x23C3
    6912:	8a 81       	ldd	r24, Y+2	; 0x02
    6914:	89 2b       	or	r24, r25
    6916:	80 93 c3 23 	sts	0x23C3, r24
    691a:	06 c0       	rjmp	.+12     	; 0x6928 <PortEx_OUTSET+0x40>
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    691c:	90 91 77 50 	lds	r25, 0x5077
    6920:	8a 81       	ldd	r24, Y+2	; 0x02
    6922:	89 2b       	or	r24, r25
    6924:	80 93 77 50 	sts	0x5077, r24
	
	SPIBuffer[0] = PS_WRITE;
    6928:	80 e4       	ldi	r24, 0x40	; 64
    692a:	80 93 5a 50 	sts	0x505A, r24
	if(bank) {
    692e:	8b 81       	ldd	r24, Y+3	; 0x03
    6930:	88 23       	and	r24, r24
    6932:	41 f0       	breq	.+16     	; 0x6944 <PortEx_OUTSET+0x5c>
		SPIBuffer[1]=PS_OLATA;
    6934:	84 e1       	ldi	r24, 0x14	; 20
    6936:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = bankA_OUT;
    693a:	80 91 c3 23 	lds	r24, 0x23C3
    693e:	80 93 5c 50 	sts	0x505C, r24
    6942:	07 c0       	rjmp	.+14     	; 0x6952 <PortEx_OUTSET+0x6a>
	} else {
		SPIBuffer[1]=PS_OLATB;
    6944:	85 e1       	ldi	r24, 0x15	; 21
    6946:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = bankB_OUT; 
    694a:	80 91 77 50 	lds	r24, 0x5077
    694e:	80 93 5c 50 	sts	0x505C, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6952:	19 82       	std	Y+1, r1	; 0x01
    6954:	1b c0       	rjmp	.+54     	; 0x698c <PortEx_OUTSET+0xa4>
		SPIC.DATA = SPIBuffer[bufIndex];
    6956:	80 ec       	ldi	r24, 0xC0	; 192
    6958:	98 e0       	ldi	r25, 0x08	; 8
    695a:	29 81       	ldd	r18, Y+1	; 0x01
    695c:	22 2f       	mov	r18, r18
    695e:	30 e0       	ldi	r19, 0x00	; 0
    6960:	26 5a       	subi	r18, 0xA6	; 166
    6962:	3f 4a       	sbci	r19, 0xAF	; 175
    6964:	f9 01       	movw	r30, r18
    6966:	20 81       	ld	r18, Z
    6968:	fc 01       	movw	r30, r24
    696a:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    696c:	00 00       	nop
    696e:	80 ec       	ldi	r24, 0xC0	; 192
    6970:	98 e0       	ldi	r25, 0x08	; 8
    6972:	fc 01       	movw	r30, r24
    6974:	82 81       	ldd	r24, Z+2	; 0x02
    6976:	88 23       	and	r24, r24
    6978:	d4 f7       	brge	.-12     	; 0x696e <PortEx_OUTSET+0x86>
		SPIBuffer[12] = SPIC.DATA;
    697a:	80 ec       	ldi	r24, 0xC0	; 192
    697c:	98 e0       	ldi	r25, 0x08	; 8
    697e:	fc 01       	movw	r30, r24
    6980:	83 81       	ldd	r24, Z+3	; 0x03
    6982:	80 93 66 50 	sts	0x5066, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6986:	89 81       	ldd	r24, Y+1	; 0x01
    6988:	8f 5f       	subi	r24, 0xFF	; 255
    698a:	89 83       	std	Y+1, r24	; 0x01
    698c:	89 81       	ldd	r24, Y+1	; 0x01
    698e:	83 30       	cpi	r24, 0x03	; 3
    6990:	10 f3       	brcs	.-60     	; 0x6956 <PortEx_OUTSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6992:	80 e0       	ldi	r24, 0x00	; 0
    6994:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	portExCS(FALSE);
    6998:	80 e0       	ldi	r24, 0x00	; 0
    699a:	0e 94 b3 32 	call	0x6566	; 0x6566 <portExCS>
	SPIDisable();
    699e:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>
}
    69a2:	23 96       	adiw	r28, 0x03	; 3
    69a4:	cd bf       	out	0x3d, r28	; 61
    69a6:	de bf       	out	0x3e, r29	; 62
    69a8:	df 91       	pop	r29
    69aa:	cf 91       	pop	r28
    69ac:	08 95       	ret

000069ae <PortEx_OUTCLR>:


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    69ae:	cf 93       	push	r28
    69b0:	df 93       	push	r29
    69b2:	00 d0       	rcall	.+0      	; 0x69b4 <PortEx_OUTCLR+0x6>
    69b4:	cd b7       	in	r28, 0x3d	; 61
    69b6:	de b7       	in	r29, 0x3e	; 62
    69b8:	8a 83       	std	Y+2, r24	; 0x02
    69ba:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    69bc:	80 e0       	ldi	r24, 0x00	; 0
    69be:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
	SPICS(TRUE);
    69c2:	81 e0       	ldi	r24, 0x01	; 1
    69c4:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	portExCS(TRUE);
    69c8:	81 e0       	ldi	r24, 0x01	; 1
    69ca:	0e 94 b3 32 	call	0x6566	; 0x6566 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    69ce:	8b 81       	ldd	r24, Y+3	; 0x03
    69d0:	88 23       	and	r24, r24
    69d2:	49 f0       	breq	.+18     	; 0x69e6 <PortEx_OUTCLR+0x38>
    69d4:	8a 81       	ldd	r24, Y+2	; 0x02
    69d6:	98 2f       	mov	r25, r24
    69d8:	90 95       	com	r25
    69da:	80 91 c3 23 	lds	r24, 0x23C3
    69de:	89 23       	and	r24, r25
    69e0:	80 93 c3 23 	sts	0x23C3, r24
    69e4:	08 c0       	rjmp	.+16     	; 0x69f6 <PortEx_OUTCLR+0x48>
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    69e6:	8a 81       	ldd	r24, Y+2	; 0x02
    69e8:	98 2f       	mov	r25, r24
    69ea:	90 95       	com	r25
    69ec:	80 91 77 50 	lds	r24, 0x5077
    69f0:	89 23       	and	r24, r25
    69f2:	80 93 77 50 	sts	0x5077, r24
	
	SPIBuffer[0] = PS_WRITE;
    69f6:	80 e4       	ldi	r24, 0x40	; 64
    69f8:	80 93 5a 50 	sts	0x505A, r24
	if(bank) {
    69fc:	8b 81       	ldd	r24, Y+3	; 0x03
    69fe:	88 23       	and	r24, r24
    6a00:	41 f0       	breq	.+16     	; 0x6a12 <PortEx_OUTCLR+0x64>
		SPIBuffer[1]=PS_OLATA;
    6a02:	84 e1       	ldi	r24, 0x14	; 20
    6a04:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = bankA_OUT;
    6a08:	80 91 c3 23 	lds	r24, 0x23C3
    6a0c:	80 93 5c 50 	sts	0x505C, r24
    6a10:	07 c0       	rjmp	.+14     	; 0x6a20 <PortEx_OUTCLR+0x72>
	} else {
		SPIBuffer[1]=PS_OLATB;
    6a12:	85 e1       	ldi	r24, 0x15	; 21
    6a14:	80 93 5b 50 	sts	0x505B, r24
		SPIBuffer[2] = bankB_OUT; 
    6a18:	80 91 77 50 	lds	r24, 0x5077
    6a1c:	80 93 5c 50 	sts	0x505C, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6a20:	19 82       	std	Y+1, r1	; 0x01
    6a22:	1b c0       	rjmp	.+54     	; 0x6a5a <PortEx_OUTCLR+0xac>
		SPIC.DATA = SPIBuffer[bufIndex];
    6a24:	80 ec       	ldi	r24, 0xC0	; 192
    6a26:	98 e0       	ldi	r25, 0x08	; 8
    6a28:	29 81       	ldd	r18, Y+1	; 0x01
    6a2a:	22 2f       	mov	r18, r18
    6a2c:	30 e0       	ldi	r19, 0x00	; 0
    6a2e:	26 5a       	subi	r18, 0xA6	; 166
    6a30:	3f 4a       	sbci	r19, 0xAF	; 175
    6a32:	f9 01       	movw	r30, r18
    6a34:	20 81       	ld	r18, Z
    6a36:	fc 01       	movw	r30, r24
    6a38:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6a3a:	00 00       	nop
    6a3c:	80 ec       	ldi	r24, 0xC0	; 192
    6a3e:	98 e0       	ldi	r25, 0x08	; 8
    6a40:	fc 01       	movw	r30, r24
    6a42:	82 81       	ldd	r24, Z+2	; 0x02
    6a44:	88 23       	and	r24, r24
    6a46:	d4 f7       	brge	.-12     	; 0x6a3c <PortEx_OUTCLR+0x8e>
		SPIBuffer[12] = SPIC.DATA;
    6a48:	80 ec       	ldi	r24, 0xC0	; 192
    6a4a:	98 e0       	ldi	r25, 0x08	; 8
    6a4c:	fc 01       	movw	r30, r24
    6a4e:	83 81       	ldd	r24, Z+3	; 0x03
    6a50:	80 93 66 50 	sts	0x5066, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6a54:	89 81       	ldd	r24, Y+1	; 0x01
    6a56:	8f 5f       	subi	r24, 0xFF	; 255
    6a58:	89 83       	std	Y+1, r24	; 0x01
    6a5a:	89 81       	ldd	r24, Y+1	; 0x01
    6a5c:	83 30       	cpi	r24, 0x03	; 3
    6a5e:	10 f3       	brcs	.-60     	; 0x6a24 <PortEx_OUTCLR+0x76>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6a60:	80 e0       	ldi	r24, 0x00	; 0
    6a62:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	portExCS(FALSE);
    6a66:	80 e0       	ldi	r24, 0x00	; 0
    6a68:	0e 94 b3 32 	call	0x6566	; 0x6566 <portExCS>
	SPIDisable();
    6a6c:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>
}
    6a70:	23 96       	adiw	r28, 0x03	; 3
    6a72:	cd bf       	out	0x3d, r28	; 61
    6a74:	de bf       	out	0x3e, r29	; 62
    6a76:	df 91       	pop	r29
    6a78:	cf 91       	pop	r28
    6a7a:	08 95       	ret

00006a7c <Ext1Power>:
	SPIDisable();
}
*/


void Ext1Power(uint8_t on) {
    6a7c:	0f 93       	push	r16
    6a7e:	1f 93       	push	r17
    6a80:	cf 93       	push	r28
    6a82:	df 93       	push	r29
    6a84:	cd b7       	in	r28, 0x3d	; 61
    6a86:	de b7       	in	r29, 0x3e	; 62
    6a88:	2f 97       	sbiw	r28, 0x0f	; 15
    6a8a:	cd bf       	out	0x3d, r28	; 61
    6a8c:	de bf       	out	0x3e, r29	; 62
    6a8e:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    6a90:	8f 85       	ldd	r24, Y+15	; 0x0f
    6a92:	88 23       	and	r24, r24
    6a94:	09 f4       	brne	.+2      	; 0x6a98 <Ext1Power+0x1c>
    6a96:	8b c0       	rjmp	.+278    	; 0x6bae <Ext1Power+0x132>
		PORTF.DIRSET = PIN5_bm;
    6a98:	80 ea       	ldi	r24, 0xA0	; 160
    6a9a:	96 e0       	ldi	r25, 0x06	; 6
    6a9c:	20 e2       	ldi	r18, 0x20	; 32
    6a9e:	fc 01       	movw	r30, r24
    6aa0:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN5_bm;
    6aa2:	80 ea       	ldi	r24, 0xA0	; 160
    6aa4:	96 e0       	ldi	r25, 0x06	; 6
    6aa6:	20 e2       	ldi	r18, 0x20	; 32
    6aa8:	fc 01       	movw	r30, r24
    6aaa:	25 83       	std	Z+5, r18	; 0x05
    6aac:	80 e0       	ldi	r24, 0x00	; 0
    6aae:	90 e0       	ldi	r25, 0x00	; 0
    6ab0:	a8 ec       	ldi	r26, 0xC8	; 200
    6ab2:	b2 e4       	ldi	r27, 0x42	; 66
    6ab4:	89 83       	std	Y+1, r24	; 0x01
    6ab6:	9a 83       	std	Y+2, r25	; 0x02
    6ab8:	ab 83       	std	Y+3, r26	; 0x03
    6aba:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6abc:	69 81       	ldd	r22, Y+1	; 0x01
    6abe:	7a 81       	ldd	r23, Y+2	; 0x02
    6ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    6ac2:	9c 81       	ldd	r25, Y+4	; 0x04
    6ac4:	20 e0       	ldi	r18, 0x00	; 0
    6ac6:	30 e0       	ldi	r19, 0x00	; 0
    6ac8:	4a ef       	ldi	r20, 0xFA	; 250
    6aca:	55 e4       	ldi	r21, 0x45	; 69
    6acc:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    6ad0:	dc 01       	movw	r26, r24
    6ad2:	cb 01       	movw	r24, r22
    6ad4:	8d 83       	std	Y+5, r24	; 0x05
    6ad6:	9e 83       	std	Y+6, r25	; 0x06
    6ad8:	af 83       	std	Y+7, r26	; 0x07
    6ada:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6adc:	11 e0       	ldi	r17, 0x01	; 1
    6ade:	6d 81       	ldd	r22, Y+5	; 0x05
    6ae0:	7e 81       	ldd	r23, Y+6	; 0x06
    6ae2:	8f 81       	ldd	r24, Y+7	; 0x07
    6ae4:	98 85       	ldd	r25, Y+8	; 0x08
    6ae6:	20 e0       	ldi	r18, 0x00	; 0
    6ae8:	30 e0       	ldi	r19, 0x00	; 0
    6aea:	40 e8       	ldi	r20, 0x80	; 128
    6aec:	5f e3       	ldi	r21, 0x3F	; 63
    6aee:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    6af2:	88 23       	and	r24, r24
    6af4:	0c f0       	brlt	.+2      	; 0x6af8 <Ext1Power+0x7c>
    6af6:	10 e0       	ldi	r17, 0x00	; 0
    6af8:	11 23       	and	r17, r17
    6afa:	29 f0       	breq	.+10     	; 0x6b06 <Ext1Power+0x8a>
		__ticks = 1;
    6afc:	81 e0       	ldi	r24, 0x01	; 1
    6afe:	90 e0       	ldi	r25, 0x00	; 0
    6b00:	89 87       	std	Y+9, r24	; 0x09
    6b02:	9a 87       	std	Y+10, r25	; 0x0a
    6b04:	46 c0       	rjmp	.+140    	; 0x6b92 <Ext1Power+0x116>
	else if (__tmp > 65535)
    6b06:	11 e0       	ldi	r17, 0x01	; 1
    6b08:	6d 81       	ldd	r22, Y+5	; 0x05
    6b0a:	7e 81       	ldd	r23, Y+6	; 0x06
    6b0c:	8f 81       	ldd	r24, Y+7	; 0x07
    6b0e:	98 85       	ldd	r25, Y+8	; 0x08
    6b10:	20 e0       	ldi	r18, 0x00	; 0
    6b12:	3f ef       	ldi	r19, 0xFF	; 255
    6b14:	4f e7       	ldi	r20, 0x7F	; 127
    6b16:	57 e4       	ldi	r21, 0x47	; 71
    6b18:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    6b1c:	18 16       	cp	r1, r24
    6b1e:	0c f0       	brlt	.+2      	; 0x6b22 <Ext1Power+0xa6>
    6b20:	10 e0       	ldi	r17, 0x00	; 0
    6b22:	11 23       	and	r17, r17
    6b24:	61 f1       	breq	.+88     	; 0x6b7e <Ext1Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6b26:	69 81       	ldd	r22, Y+1	; 0x01
    6b28:	7a 81       	ldd	r23, Y+2	; 0x02
    6b2a:	8b 81       	ldd	r24, Y+3	; 0x03
    6b2c:	9c 81       	ldd	r25, Y+4	; 0x04
    6b2e:	20 e0       	ldi	r18, 0x00	; 0
    6b30:	30 e0       	ldi	r19, 0x00	; 0
    6b32:	40 e2       	ldi	r20, 0x20	; 32
    6b34:	51 e4       	ldi	r21, 0x41	; 65
    6b36:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    6b3a:	dc 01       	movw	r26, r24
    6b3c:	cb 01       	movw	r24, r22
    6b3e:	bc 01       	movw	r22, r24
    6b40:	cd 01       	movw	r24, r26
    6b42:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    6b46:	dc 01       	movw	r26, r24
    6b48:	cb 01       	movw	r24, r22
    6b4a:	89 87       	std	Y+9, r24	; 0x09
    6b4c:	9a 87       	std	Y+10, r25	; 0x0a
    6b4e:	12 c0       	rjmp	.+36     	; 0x6b74 <Ext1Power+0xf8>
    6b50:	80 e2       	ldi	r24, 0x20	; 32
    6b52:	93 e0       	ldi	r25, 0x03	; 3
    6b54:	8b 87       	std	Y+11, r24	; 0x0b
    6b56:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6b58:	8b 85       	ldd	r24, Y+11	; 0x0b
    6b5a:	9c 85       	ldd	r25, Y+12	; 0x0c
    6b5c:	8c 01       	movw	r16, r24
    6b5e:	c8 01       	movw	r24, r16
    6b60:	01 97       	sbiw	r24, 0x01	; 1
    6b62:	f1 f7       	brne	.-4      	; 0x6b60 <Ext1Power+0xe4>
    6b64:	8c 01       	movw	r16, r24
    6b66:	0b 87       	std	Y+11, r16	; 0x0b
    6b68:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6b6a:	89 85       	ldd	r24, Y+9	; 0x09
    6b6c:	9a 85       	ldd	r25, Y+10	; 0x0a
    6b6e:	01 97       	sbiw	r24, 0x01	; 1
    6b70:	89 87       	std	Y+9, r24	; 0x09
    6b72:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6b74:	89 85       	ldd	r24, Y+9	; 0x09
    6b76:	9a 85       	ldd	r25, Y+10	; 0x0a
    6b78:	00 97       	sbiw	r24, 0x00	; 0
    6b7a:	51 f7       	brne	.-44     	; 0x6b50 <Ext1Power+0xd4>
    6b7c:	22 c0       	rjmp	.+68     	; 0x6bc2 <Ext1Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6b7e:	6d 81       	ldd	r22, Y+5	; 0x05
    6b80:	7e 81       	ldd	r23, Y+6	; 0x06
    6b82:	8f 81       	ldd	r24, Y+7	; 0x07
    6b84:	98 85       	ldd	r25, Y+8	; 0x08
    6b86:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    6b8a:	dc 01       	movw	r26, r24
    6b8c:	cb 01       	movw	r24, r22
    6b8e:	89 87       	std	Y+9, r24	; 0x09
    6b90:	9a 87       	std	Y+10, r25	; 0x0a
    6b92:	89 85       	ldd	r24, Y+9	; 0x09
    6b94:	9a 85       	ldd	r25, Y+10	; 0x0a
    6b96:	8d 87       	std	Y+13, r24	; 0x0d
    6b98:	9e 87       	std	Y+14, r25	; 0x0e
    6b9a:	8d 85       	ldd	r24, Y+13	; 0x0d
    6b9c:	9e 85       	ldd	r25, Y+14	; 0x0e
    6b9e:	8c 01       	movw	r16, r24
    6ba0:	f8 01       	movw	r30, r16
    6ba2:	31 97       	sbiw	r30, 0x01	; 1
    6ba4:	f1 f7       	brne	.-4      	; 0x6ba2 <Ext1Power+0x126>
    6ba6:	8f 01       	movw	r16, r30
    6ba8:	0d 87       	std	Y+13, r16	; 0x0d
    6baa:	1e 87       	std	Y+14, r17	; 0x0e
    6bac:	0a c0       	rjmp	.+20     	; 0x6bc2 <Ext1Power+0x146>
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    6bae:	80 ea       	ldi	r24, 0xA0	; 160
    6bb0:	96 e0       	ldi	r25, 0x06	; 6
    6bb2:	20 e2       	ldi	r18, 0x20	; 32
    6bb4:	fc 01       	movw	r30, r24
    6bb6:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    6bb8:	80 ea       	ldi	r24, 0xA0	; 160
    6bba:	96 e0       	ldi	r25, 0x06	; 6
    6bbc:	20 e2       	ldi	r18, 0x20	; 32
    6bbe:	fc 01       	movw	r30, r24
    6bc0:	22 83       	std	Z+2, r18	; 0x02
		//PortEx_OUTCLR(PIN3_bm, PS_BANKB);  //no need to write protect SDHC
	}
}
    6bc2:	2f 96       	adiw	r28, 0x0f	; 15
    6bc4:	cd bf       	out	0x3d, r28	; 61
    6bc6:	de bf       	out	0x3e, r29	; 62
    6bc8:	df 91       	pop	r29
    6bca:	cf 91       	pop	r28
    6bcc:	1f 91       	pop	r17
    6bce:	0f 91       	pop	r16
    6bd0:	08 95       	ret

00006bd2 <Ext2Power>:

void Ext2Power(uint8_t on) {
    6bd2:	0f 93       	push	r16
    6bd4:	1f 93       	push	r17
    6bd6:	cf 93       	push	r28
    6bd8:	df 93       	push	r29
    6bda:	cd b7       	in	r28, 0x3d	; 61
    6bdc:	de b7       	in	r29, 0x3e	; 62
    6bde:	2f 97       	sbiw	r28, 0x0f	; 15
    6be0:	cd bf       	out	0x3d, r28	; 61
    6be2:	de bf       	out	0x3e, r29	; 62
    6be4:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    6be6:	8f 85       	ldd	r24, Y+15	; 0x0f
    6be8:	88 23       	and	r24, r24
    6bea:	09 f4       	brne	.+2      	; 0x6bee <Ext2Power+0x1c>
    6bec:	8b c0       	rjmp	.+278    	; 0x6d04 <Ext2Power+0x132>
		PORTF.DIRSET = PIN6_bm;
    6bee:	80 ea       	ldi	r24, 0xA0	; 160
    6bf0:	96 e0       	ldi	r25, 0x06	; 6
    6bf2:	20 e4       	ldi	r18, 0x40	; 64
    6bf4:	fc 01       	movw	r30, r24
    6bf6:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN6_bm;
    6bf8:	80 ea       	ldi	r24, 0xA0	; 160
    6bfa:	96 e0       	ldi	r25, 0x06	; 6
    6bfc:	20 e4       	ldi	r18, 0x40	; 64
    6bfe:	fc 01       	movw	r30, r24
    6c00:	25 83       	std	Z+5, r18	; 0x05
    6c02:	80 e0       	ldi	r24, 0x00	; 0
    6c04:	90 e0       	ldi	r25, 0x00	; 0
    6c06:	a8 ec       	ldi	r26, 0xC8	; 200
    6c08:	b2 e4       	ldi	r27, 0x42	; 66
    6c0a:	89 83       	std	Y+1, r24	; 0x01
    6c0c:	9a 83       	std	Y+2, r25	; 0x02
    6c0e:	ab 83       	std	Y+3, r26	; 0x03
    6c10:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6c12:	69 81       	ldd	r22, Y+1	; 0x01
    6c14:	7a 81       	ldd	r23, Y+2	; 0x02
    6c16:	8b 81       	ldd	r24, Y+3	; 0x03
    6c18:	9c 81       	ldd	r25, Y+4	; 0x04
    6c1a:	20 e0       	ldi	r18, 0x00	; 0
    6c1c:	30 e0       	ldi	r19, 0x00	; 0
    6c1e:	4a ef       	ldi	r20, 0xFA	; 250
    6c20:	55 e4       	ldi	r21, 0x45	; 69
    6c22:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    6c26:	dc 01       	movw	r26, r24
    6c28:	cb 01       	movw	r24, r22
    6c2a:	8d 83       	std	Y+5, r24	; 0x05
    6c2c:	9e 83       	std	Y+6, r25	; 0x06
    6c2e:	af 83       	std	Y+7, r26	; 0x07
    6c30:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6c32:	11 e0       	ldi	r17, 0x01	; 1
    6c34:	6d 81       	ldd	r22, Y+5	; 0x05
    6c36:	7e 81       	ldd	r23, Y+6	; 0x06
    6c38:	8f 81       	ldd	r24, Y+7	; 0x07
    6c3a:	98 85       	ldd	r25, Y+8	; 0x08
    6c3c:	20 e0       	ldi	r18, 0x00	; 0
    6c3e:	30 e0       	ldi	r19, 0x00	; 0
    6c40:	40 e8       	ldi	r20, 0x80	; 128
    6c42:	5f e3       	ldi	r21, 0x3F	; 63
    6c44:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    6c48:	88 23       	and	r24, r24
    6c4a:	0c f0       	brlt	.+2      	; 0x6c4e <Ext2Power+0x7c>
    6c4c:	10 e0       	ldi	r17, 0x00	; 0
    6c4e:	11 23       	and	r17, r17
    6c50:	29 f0       	breq	.+10     	; 0x6c5c <Ext2Power+0x8a>
		__ticks = 1;
    6c52:	81 e0       	ldi	r24, 0x01	; 1
    6c54:	90 e0       	ldi	r25, 0x00	; 0
    6c56:	89 87       	std	Y+9, r24	; 0x09
    6c58:	9a 87       	std	Y+10, r25	; 0x0a
    6c5a:	46 c0       	rjmp	.+140    	; 0x6ce8 <Ext2Power+0x116>
	else if (__tmp > 65535)
    6c5c:	11 e0       	ldi	r17, 0x01	; 1
    6c5e:	6d 81       	ldd	r22, Y+5	; 0x05
    6c60:	7e 81       	ldd	r23, Y+6	; 0x06
    6c62:	8f 81       	ldd	r24, Y+7	; 0x07
    6c64:	98 85       	ldd	r25, Y+8	; 0x08
    6c66:	20 e0       	ldi	r18, 0x00	; 0
    6c68:	3f ef       	ldi	r19, 0xFF	; 255
    6c6a:	4f e7       	ldi	r20, 0x7F	; 127
    6c6c:	57 e4       	ldi	r21, 0x47	; 71
    6c6e:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    6c72:	18 16       	cp	r1, r24
    6c74:	0c f0       	brlt	.+2      	; 0x6c78 <Ext2Power+0xa6>
    6c76:	10 e0       	ldi	r17, 0x00	; 0
    6c78:	11 23       	and	r17, r17
    6c7a:	61 f1       	breq	.+88     	; 0x6cd4 <Ext2Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6c7c:	69 81       	ldd	r22, Y+1	; 0x01
    6c7e:	7a 81       	ldd	r23, Y+2	; 0x02
    6c80:	8b 81       	ldd	r24, Y+3	; 0x03
    6c82:	9c 81       	ldd	r25, Y+4	; 0x04
    6c84:	20 e0       	ldi	r18, 0x00	; 0
    6c86:	30 e0       	ldi	r19, 0x00	; 0
    6c88:	40 e2       	ldi	r20, 0x20	; 32
    6c8a:	51 e4       	ldi	r21, 0x41	; 65
    6c8c:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    6c90:	dc 01       	movw	r26, r24
    6c92:	cb 01       	movw	r24, r22
    6c94:	bc 01       	movw	r22, r24
    6c96:	cd 01       	movw	r24, r26
    6c98:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    6c9c:	dc 01       	movw	r26, r24
    6c9e:	cb 01       	movw	r24, r22
    6ca0:	89 87       	std	Y+9, r24	; 0x09
    6ca2:	9a 87       	std	Y+10, r25	; 0x0a
    6ca4:	12 c0       	rjmp	.+36     	; 0x6cca <Ext2Power+0xf8>
    6ca6:	80 e2       	ldi	r24, 0x20	; 32
    6ca8:	93 e0       	ldi	r25, 0x03	; 3
    6caa:	8b 87       	std	Y+11, r24	; 0x0b
    6cac:	9c 87       	std	Y+12, r25	; 0x0c
    6cae:	8b 85       	ldd	r24, Y+11	; 0x0b
    6cb0:	9c 85       	ldd	r25, Y+12	; 0x0c
    6cb2:	8c 01       	movw	r16, r24
    6cb4:	c8 01       	movw	r24, r16
    6cb6:	01 97       	sbiw	r24, 0x01	; 1
    6cb8:	f1 f7       	brne	.-4      	; 0x6cb6 <Ext2Power+0xe4>
    6cba:	8c 01       	movw	r16, r24
    6cbc:	0b 87       	std	Y+11, r16	; 0x0b
    6cbe:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6cc0:	89 85       	ldd	r24, Y+9	; 0x09
    6cc2:	9a 85       	ldd	r25, Y+10	; 0x0a
    6cc4:	01 97       	sbiw	r24, 0x01	; 1
    6cc6:	89 87       	std	Y+9, r24	; 0x09
    6cc8:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6cca:	89 85       	ldd	r24, Y+9	; 0x09
    6ccc:	9a 85       	ldd	r25, Y+10	; 0x0a
    6cce:	00 97       	sbiw	r24, 0x00	; 0
    6cd0:	51 f7       	brne	.-44     	; 0x6ca6 <Ext2Power+0xd4>
    6cd2:	22 c0       	rjmp	.+68     	; 0x6d18 <Ext2Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6cd4:	6d 81       	ldd	r22, Y+5	; 0x05
    6cd6:	7e 81       	ldd	r23, Y+6	; 0x06
    6cd8:	8f 81       	ldd	r24, Y+7	; 0x07
    6cda:	98 85       	ldd	r25, Y+8	; 0x08
    6cdc:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    6ce0:	dc 01       	movw	r26, r24
    6ce2:	cb 01       	movw	r24, r22
    6ce4:	89 87       	std	Y+9, r24	; 0x09
    6ce6:	9a 87       	std	Y+10, r25	; 0x0a
    6ce8:	89 85       	ldd	r24, Y+9	; 0x09
    6cea:	9a 85       	ldd	r25, Y+10	; 0x0a
    6cec:	8d 87       	std	Y+13, r24	; 0x0d
    6cee:	9e 87       	std	Y+14, r25	; 0x0e
    6cf0:	8d 85       	ldd	r24, Y+13	; 0x0d
    6cf2:	9e 85       	ldd	r25, Y+14	; 0x0e
    6cf4:	8c 01       	movw	r16, r24
    6cf6:	f8 01       	movw	r30, r16
    6cf8:	31 97       	sbiw	r30, 0x01	; 1
    6cfa:	f1 f7       	brne	.-4      	; 0x6cf8 <Ext2Power+0x126>
    6cfc:	8f 01       	movw	r16, r30
    6cfe:	0d 87       	std	Y+13, r16	; 0x0d
    6d00:	1e 87       	std	Y+14, r17	; 0x0e
    6d02:	0a c0       	rjmp	.+20     	; 0x6d18 <Ext2Power+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    6d04:	80 ea       	ldi	r24, 0xA0	; 160
    6d06:	96 e0       	ldi	r25, 0x06	; 6
    6d08:	20 e4       	ldi	r18, 0x40	; 64
    6d0a:	fc 01       	movw	r30, r24
    6d0c:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    6d0e:	80 ea       	ldi	r24, 0xA0	; 160
    6d10:	96 e0       	ldi	r25, 0x06	; 6
    6d12:	20 e4       	ldi	r18, 0x40	; 64
    6d14:	fc 01       	movw	r30, r24
    6d16:	22 83       	std	Z+2, r18	; 0x02
	}
}
    6d18:	2f 96       	adiw	r28, 0x0f	; 15
    6d1a:	cd bf       	out	0x3d, r28	; 61
    6d1c:	de bf       	out	0x3e, r29	; 62
    6d1e:	df 91       	pop	r29
    6d20:	cf 91       	pop	r28
    6d22:	1f 91       	pop	r17
    6d24:	0f 91       	pop	r16
    6d26:	08 95       	ret

00006d28 <HVPower>:

void HVPower(uint8_t on) {
    6d28:	0f 93       	push	r16
    6d2a:	1f 93       	push	r17
    6d2c:	cf 93       	push	r28
    6d2e:	df 93       	push	r29
    6d30:	cd b7       	in	r28, 0x3d	; 61
    6d32:	de b7       	in	r29, 0x3e	; 62
    6d34:	a7 97       	sbiw	r28, 0x27	; 39
    6d36:	cd bf       	out	0x3d, r28	; 61
    6d38:	de bf       	out	0x3e, r29	; 62
    6d3a:	8f a3       	lds	r24, 0x5f
	if (on) {
    6d3c:	8f a1       	lds	r24, 0x4f
    6d3e:	88 23       	and	r24, r24
    6d40:	09 f4       	brne	.+2      	; 0x6d44 <HVPower+0x1c>
    6d42:	8b c0       	rjmp	.+278    	; 0x6e5a <HVPower+0x132>
		PORTF.DIRSET = PIN7_bm;
    6d44:	80 ea       	ldi	r24, 0xA0	; 160
    6d46:	96 e0       	ldi	r25, 0x06	; 6
    6d48:	20 e8       	ldi	r18, 0x80	; 128
    6d4a:	fc 01       	movw	r30, r24
    6d4c:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN7_bm;
    6d4e:	80 ea       	ldi	r24, 0xA0	; 160
    6d50:	96 e0       	ldi	r25, 0x06	; 6
    6d52:	20 e8       	ldi	r18, 0x80	; 128
    6d54:	fc 01       	movw	r30, r24
    6d56:	25 83       	std	Z+5, r18	; 0x05
    6d58:	80 e0       	ldi	r24, 0x00	; 0
    6d5a:	90 e0       	ldi	r25, 0x00	; 0
    6d5c:	a8 ec       	ldi	r26, 0xC8	; 200
    6d5e:	b2 e4       	ldi	r27, 0x42	; 66
    6d60:	89 83       	std	Y+1, r24	; 0x01
    6d62:	9a 83       	std	Y+2, r25	; 0x02
    6d64:	ab 83       	std	Y+3, r26	; 0x03
    6d66:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6d68:	69 81       	ldd	r22, Y+1	; 0x01
    6d6a:	7a 81       	ldd	r23, Y+2	; 0x02
    6d6c:	8b 81       	ldd	r24, Y+3	; 0x03
    6d6e:	9c 81       	ldd	r25, Y+4	; 0x04
    6d70:	20 e0       	ldi	r18, 0x00	; 0
    6d72:	30 e0       	ldi	r19, 0x00	; 0
    6d74:	4a ef       	ldi	r20, 0xFA	; 250
    6d76:	55 e4       	ldi	r21, 0x45	; 69
    6d78:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    6d7c:	dc 01       	movw	r26, r24
    6d7e:	cb 01       	movw	r24, r22
    6d80:	8d 83       	std	Y+5, r24	; 0x05
    6d82:	9e 83       	std	Y+6, r25	; 0x06
    6d84:	af 83       	std	Y+7, r26	; 0x07
    6d86:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6d88:	11 e0       	ldi	r17, 0x01	; 1
    6d8a:	6d 81       	ldd	r22, Y+5	; 0x05
    6d8c:	7e 81       	ldd	r23, Y+6	; 0x06
    6d8e:	8f 81       	ldd	r24, Y+7	; 0x07
    6d90:	98 85       	ldd	r25, Y+8	; 0x08
    6d92:	20 e0       	ldi	r18, 0x00	; 0
    6d94:	30 e0       	ldi	r19, 0x00	; 0
    6d96:	40 e8       	ldi	r20, 0x80	; 128
    6d98:	5f e3       	ldi	r21, 0x3F	; 63
    6d9a:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    6d9e:	88 23       	and	r24, r24
    6da0:	0c f0       	brlt	.+2      	; 0x6da4 <HVPower+0x7c>
    6da2:	10 e0       	ldi	r17, 0x00	; 0
    6da4:	11 23       	and	r17, r17
    6da6:	29 f0       	breq	.+10     	; 0x6db2 <HVPower+0x8a>
		__ticks = 1;
    6da8:	81 e0       	ldi	r24, 0x01	; 1
    6daa:	90 e0       	ldi	r25, 0x00	; 0
    6dac:	89 87       	std	Y+9, r24	; 0x09
    6dae:	9a 87       	std	Y+10, r25	; 0x0a
    6db0:	46 c0       	rjmp	.+140    	; 0x6e3e <HVPower+0x116>
	else if (__tmp > 65535)
    6db2:	11 e0       	ldi	r17, 0x01	; 1
    6db4:	6d 81       	ldd	r22, Y+5	; 0x05
    6db6:	7e 81       	ldd	r23, Y+6	; 0x06
    6db8:	8f 81       	ldd	r24, Y+7	; 0x07
    6dba:	98 85       	ldd	r25, Y+8	; 0x08
    6dbc:	20 e0       	ldi	r18, 0x00	; 0
    6dbe:	3f ef       	ldi	r19, 0xFF	; 255
    6dc0:	4f e7       	ldi	r20, 0x7F	; 127
    6dc2:	57 e4       	ldi	r21, 0x47	; 71
    6dc4:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    6dc8:	18 16       	cp	r1, r24
    6dca:	0c f0       	brlt	.+2      	; 0x6dce <HVPower+0xa6>
    6dcc:	10 e0       	ldi	r17, 0x00	; 0
    6dce:	11 23       	and	r17, r17
    6dd0:	61 f1       	breq	.+88     	; 0x6e2a <HVPower+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6dd2:	69 81       	ldd	r22, Y+1	; 0x01
    6dd4:	7a 81       	ldd	r23, Y+2	; 0x02
    6dd6:	8b 81       	ldd	r24, Y+3	; 0x03
    6dd8:	9c 81       	ldd	r25, Y+4	; 0x04
    6dda:	20 e0       	ldi	r18, 0x00	; 0
    6ddc:	30 e0       	ldi	r19, 0x00	; 0
    6dde:	40 e2       	ldi	r20, 0x20	; 32
    6de0:	51 e4       	ldi	r21, 0x41	; 65
    6de2:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    6de6:	dc 01       	movw	r26, r24
    6de8:	cb 01       	movw	r24, r22
    6dea:	bc 01       	movw	r22, r24
    6dec:	cd 01       	movw	r24, r26
    6dee:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    6df2:	dc 01       	movw	r26, r24
    6df4:	cb 01       	movw	r24, r22
    6df6:	89 87       	std	Y+9, r24	; 0x09
    6df8:	9a 87       	std	Y+10, r25	; 0x0a
    6dfa:	12 c0       	rjmp	.+36     	; 0x6e20 <HVPower+0xf8>
    6dfc:	80 e2       	ldi	r24, 0x20	; 32
    6dfe:	93 e0       	ldi	r25, 0x03	; 3
    6e00:	8b 87       	std	Y+11, r24	; 0x0b
    6e02:	9c 87       	std	Y+12, r25	; 0x0c
    6e04:	8b 85       	ldd	r24, Y+11	; 0x0b
    6e06:	9c 85       	ldd	r25, Y+12	; 0x0c
    6e08:	8c 01       	movw	r16, r24
    6e0a:	c8 01       	movw	r24, r16
    6e0c:	01 97       	sbiw	r24, 0x01	; 1
    6e0e:	f1 f7       	brne	.-4      	; 0x6e0c <HVPower+0xe4>
    6e10:	8c 01       	movw	r16, r24
    6e12:	0b 87       	std	Y+11, r16	; 0x0b
    6e14:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6e16:	89 85       	ldd	r24, Y+9	; 0x09
    6e18:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e1a:	01 97       	sbiw	r24, 0x01	; 1
    6e1c:	89 87       	std	Y+9, r24	; 0x09
    6e1e:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6e20:	89 85       	ldd	r24, Y+9	; 0x09
    6e22:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e24:	00 97       	sbiw	r24, 0x00	; 0
    6e26:	51 f7       	brne	.-44     	; 0x6dfc <HVPower+0xd4>
    6e28:	22 c0       	rjmp	.+68     	; 0x6e6e <HVPower+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6e2a:	6d 81       	ldd	r22, Y+5	; 0x05
    6e2c:	7e 81       	ldd	r23, Y+6	; 0x06
    6e2e:	8f 81       	ldd	r24, Y+7	; 0x07
    6e30:	98 85       	ldd	r25, Y+8	; 0x08
    6e32:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    6e36:	dc 01       	movw	r26, r24
    6e38:	cb 01       	movw	r24, r22
    6e3a:	89 87       	std	Y+9, r24	; 0x09
    6e3c:	9a 87       	std	Y+10, r25	; 0x0a
    6e3e:	89 85       	ldd	r24, Y+9	; 0x09
    6e40:	9a 85       	ldd	r25, Y+10	; 0x0a
    6e42:	8d 87       	std	Y+13, r24	; 0x0d
    6e44:	9e 87       	std	Y+14, r25	; 0x0e
    6e46:	8d 85       	ldd	r24, Y+13	; 0x0d
    6e48:	9e 85       	ldd	r25, Y+14	; 0x0e
    6e4a:	8c 01       	movw	r16, r24
    6e4c:	f8 01       	movw	r30, r16
    6e4e:	31 97       	sbiw	r30, 0x01	; 1
    6e50:	f1 f7       	brne	.-4      	; 0x6e4e <HVPower+0x126>
    6e52:	8f 01       	movw	r16, r30
    6e54:	0d 87       	std	Y+13, r16	; 0x0d
    6e56:	1e 87       	std	Y+14, r17	; 0x0e
    6e58:	0a c0       	rjmp	.+20     	; 0x6e6e <HVPower+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    6e5a:	80 ea       	ldi	r24, 0xA0	; 160
    6e5c:	96 e0       	ldi	r25, 0x06	; 6
    6e5e:	20 e8       	ldi	r18, 0x80	; 128
    6e60:	fc 01       	movw	r30, r24
    6e62:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    6e64:	80 ea       	ldi	r24, 0xA0	; 160
    6e66:	96 e0       	ldi	r25, 0x06	; 6
    6e68:	20 e8       	ldi	r18, 0x80	; 128
    6e6a:	fc 01       	movw	r30, r24
    6e6c:	22 83       	std	Z+2, r18	; 0x02
    6e6e:	80 e0       	ldi	r24, 0x00	; 0
    6e70:	90 e0       	ldi	r25, 0x00	; 0
    6e72:	aa e7       	ldi	r26, 0x7A	; 122
    6e74:	b4 e4       	ldi	r27, 0x44	; 68
    6e76:	8f 87       	std	Y+15, r24	; 0x0f
    6e78:	98 8b       	std	Y+16, r25	; 0x10
    6e7a:	a9 8b       	std	Y+17, r26	; 0x11
    6e7c:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    6e7e:	6f 85       	ldd	r22, Y+15	; 0x0f
    6e80:	78 89       	ldd	r23, Y+16	; 0x10
    6e82:	89 89       	ldd	r24, Y+17	; 0x11
    6e84:	9a 89       	ldd	r25, Y+18	; 0x12
    6e86:	2b ea       	ldi	r18, 0xAB	; 171
    6e88:	3a ea       	ldi	r19, 0xAA	; 170
    6e8a:	4a e2       	ldi	r20, 0x2A	; 42
    6e8c:	51 e4       	ldi	r21, 0x41	; 65
    6e8e:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    6e92:	dc 01       	movw	r26, r24
    6e94:	cb 01       	movw	r24, r22
    6e96:	8b 8b       	std	Y+19, r24	; 0x13
    6e98:	9c 8b       	std	Y+20, r25	; 0x14
    6e9a:	ad 8b       	std	Y+21, r26	; 0x15
    6e9c:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    6e9e:	11 e0       	ldi	r17, 0x01	; 1
    6ea0:	6b 89       	ldd	r22, Y+19	; 0x13
    6ea2:	7c 89       	ldd	r23, Y+20	; 0x14
    6ea4:	8d 89       	ldd	r24, Y+21	; 0x15
    6ea6:	9e 89       	ldd	r25, Y+22	; 0x16
    6ea8:	20 e0       	ldi	r18, 0x00	; 0
    6eaa:	30 e0       	ldi	r19, 0x00	; 0
    6eac:	40 e8       	ldi	r20, 0x80	; 128
    6eae:	5f e3       	ldi	r21, 0x3F	; 63
    6eb0:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    6eb4:	88 23       	and	r24, r24
    6eb6:	0c f0       	brlt	.+2      	; 0x6eba <HVPower+0x192>
    6eb8:	10 e0       	ldi	r17, 0x00	; 0
    6eba:	11 23       	and	r17, r17
    6ebc:	19 f0       	breq	.+6      	; 0x6ec4 <HVPower+0x19c>
		__ticks = 1;
    6ebe:	81 e0       	ldi	r24, 0x01	; 1
    6ec0:	8f 8b       	std	Y+23, r24	; 0x17
    6ec2:	a3 c0       	rjmp	.+326    	; 0x700a <HVPower+0x2e2>
	else if (__tmp > 255)
    6ec4:	11 e0       	ldi	r17, 0x01	; 1
    6ec6:	6b 89       	ldd	r22, Y+19	; 0x13
    6ec8:	7c 89       	ldd	r23, Y+20	; 0x14
    6eca:	8d 89       	ldd	r24, Y+21	; 0x15
    6ecc:	9e 89       	ldd	r25, Y+22	; 0x16
    6ece:	20 e0       	ldi	r18, 0x00	; 0
    6ed0:	30 e0       	ldi	r19, 0x00	; 0
    6ed2:	4f e7       	ldi	r20, 0x7F	; 127
    6ed4:	53 e4       	ldi	r21, 0x43	; 67
    6ed6:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    6eda:	18 16       	cp	r1, r24
    6edc:	0c f0       	brlt	.+2      	; 0x6ee0 <HVPower+0x1b8>
    6ede:	10 e0       	ldi	r17, 0x00	; 0
    6ee0:	11 23       	and	r17, r17
    6ee2:	09 f4       	brne	.+2      	; 0x6ee6 <HVPower+0x1be>
    6ee4:	89 c0       	rjmp	.+274    	; 0x6ff8 <HVPower+0x2d0>
	{
		_delay_ms(__us / 1000.0);
    6ee6:	6f 85       	ldd	r22, Y+15	; 0x0f
    6ee8:	78 89       	ldd	r23, Y+16	; 0x10
    6eea:	89 89       	ldd	r24, Y+17	; 0x11
    6eec:	9a 89       	ldd	r25, Y+18	; 0x12
    6eee:	20 e0       	ldi	r18, 0x00	; 0
    6ef0:	30 e0       	ldi	r19, 0x00	; 0
    6ef2:	4a e7       	ldi	r20, 0x7A	; 122
    6ef4:	54 e4       	ldi	r21, 0x44	; 68
    6ef6:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
    6efa:	dc 01       	movw	r26, r24
    6efc:	cb 01       	movw	r24, r22
    6efe:	88 8f       	std	Y+24, r24	; 0x18
    6f00:	99 8f       	std	Y+25, r25	; 0x19
    6f02:	aa 8f       	std	Y+26, r26	; 0x1a
    6f04:	bb 8f       	std	Y+27, r27	; 0x1b
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6f06:	68 8d       	ldd	r22, Y+24	; 0x18
    6f08:	79 8d       	ldd	r23, Y+25	; 0x19
    6f0a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6f0c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6f0e:	20 e0       	ldi	r18, 0x00	; 0
    6f10:	30 e0       	ldi	r19, 0x00	; 0
    6f12:	4a ef       	ldi	r20, 0xFA	; 250
    6f14:	55 e4       	ldi	r21, 0x45	; 69
    6f16:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    6f1a:	dc 01       	movw	r26, r24
    6f1c:	cb 01       	movw	r24, r22
    6f1e:	8c 8f       	std	Y+28, r24	; 0x1c
    6f20:	9d 8f       	std	Y+29, r25	; 0x1d
    6f22:	ae 8f       	std	Y+30, r26	; 0x1e
    6f24:	bf 8f       	std	Y+31, r27	; 0x1f
	if (__tmp < 1.0)
    6f26:	11 e0       	ldi	r17, 0x01	; 1
    6f28:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6f2a:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6f2c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6f2e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6f30:	20 e0       	ldi	r18, 0x00	; 0
    6f32:	30 e0       	ldi	r19, 0x00	; 0
    6f34:	40 e8       	ldi	r20, 0x80	; 128
    6f36:	5f e3       	ldi	r21, 0x3F	; 63
    6f38:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    6f3c:	88 23       	and	r24, r24
    6f3e:	0c f0       	brlt	.+2      	; 0x6f42 <HVPower+0x21a>
    6f40:	10 e0       	ldi	r17, 0x00	; 0
    6f42:	11 23       	and	r17, r17
    6f44:	29 f0       	breq	.+10     	; 0x6f50 <HVPower+0x228>
		__ticks = 1;
    6f46:	81 e0       	ldi	r24, 0x01	; 1
    6f48:	90 e0       	ldi	r25, 0x00	; 0
    6f4a:	88 a3       	lds	r24, 0x58
    6f4c:	99 a3       	lds	r25, 0x59
    6f4e:	46 c0       	rjmp	.+140    	; 0x6fdc <HVPower+0x2b4>
	else if (__tmp > 65535)
    6f50:	11 e0       	ldi	r17, 0x01	; 1
    6f52:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6f54:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6f56:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6f58:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6f5a:	20 e0       	ldi	r18, 0x00	; 0
    6f5c:	3f ef       	ldi	r19, 0xFF	; 255
    6f5e:	4f e7       	ldi	r20, 0x7F	; 127
    6f60:	57 e4       	ldi	r21, 0x47	; 71
    6f62:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    6f66:	18 16       	cp	r1, r24
    6f68:	0c f0       	brlt	.+2      	; 0x6f6c <HVPower+0x244>
    6f6a:	10 e0       	ldi	r17, 0x00	; 0
    6f6c:	11 23       	and	r17, r17
    6f6e:	61 f1       	breq	.+88     	; 0x6fc8 <HVPower+0x2a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6f70:	68 8d       	ldd	r22, Y+24	; 0x18
    6f72:	79 8d       	ldd	r23, Y+25	; 0x19
    6f74:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6f76:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6f78:	20 e0       	ldi	r18, 0x00	; 0
    6f7a:	30 e0       	ldi	r19, 0x00	; 0
    6f7c:	40 e2       	ldi	r20, 0x20	; 32
    6f7e:	51 e4       	ldi	r21, 0x41	; 65
    6f80:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    6f84:	dc 01       	movw	r26, r24
    6f86:	cb 01       	movw	r24, r22
    6f88:	bc 01       	movw	r22, r24
    6f8a:	cd 01       	movw	r24, r26
    6f8c:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    6f90:	dc 01       	movw	r26, r24
    6f92:	cb 01       	movw	r24, r22
    6f94:	88 a3       	lds	r24, 0x58
    6f96:	99 a3       	lds	r25, 0x59
    6f98:	12 c0       	rjmp	.+36     	; 0x6fbe <HVPower+0x296>
    6f9a:	80 e2       	ldi	r24, 0x20	; 32
    6f9c:	93 e0       	ldi	r25, 0x03	; 3
    6f9e:	8a a3       	lds	r24, 0x5a
    6fa0:	9b a3       	lds	r25, 0x5b
    6fa2:	8a a1       	lds	r24, 0x4a
    6fa4:	9b a1       	lds	r25, 0x4b
    6fa6:	8c 01       	movw	r16, r24
    6fa8:	c8 01       	movw	r24, r16
    6faa:	01 97       	sbiw	r24, 0x01	; 1
    6fac:	f1 f7       	brne	.-4      	; 0x6faa <HVPower+0x282>
    6fae:	8c 01       	movw	r16, r24
    6fb0:	0a a3       	lds	r16, 0x5a
    6fb2:	1b a3       	lds	r17, 0x5b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6fb4:	88 a1       	lds	r24, 0x48
    6fb6:	99 a1       	lds	r25, 0x49
    6fb8:	01 97       	sbiw	r24, 0x01	; 1
    6fba:	88 a3       	lds	r24, 0x58
    6fbc:	99 a3       	lds	r25, 0x59
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6fbe:	88 a1       	lds	r24, 0x48
    6fc0:	99 a1       	lds	r25, 0x49
    6fc2:	00 97       	sbiw	r24, 0x00	; 0
    6fc4:	51 f7       	brne	.-44     	; 0x6f9a <HVPower+0x272>
    6fc6:	28 c0       	rjmp	.+80     	; 0x7018 <HVPower+0x2f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6fc8:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6fca:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6fcc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6fce:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6fd0:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    6fd4:	dc 01       	movw	r26, r24
    6fd6:	cb 01       	movw	r24, r22
    6fd8:	88 a3       	lds	r24, 0x58
    6fda:	99 a3       	lds	r25, 0x59
    6fdc:	88 a1       	lds	r24, 0x48
    6fde:	99 a1       	lds	r25, 0x49
    6fe0:	8c a3       	lds	r24, 0x5c
    6fe2:	9d a3       	lds	r25, 0x5d
    6fe4:	8c a1       	lds	r24, 0x4c
    6fe6:	9d a1       	lds	r25, 0x4d
    6fe8:	8c 01       	movw	r16, r24
    6fea:	f8 01       	movw	r30, r16
    6fec:	31 97       	sbiw	r30, 0x01	; 1
    6fee:	f1 f7       	brne	.-4      	; 0x6fec <HVPower+0x2c4>
    6ff0:	8f 01       	movw	r16, r30
    6ff2:	0c a3       	lds	r16, 0x5c
    6ff4:	1d a3       	lds	r17, 0x5d
    6ff6:	10 c0       	rjmp	.+32     	; 0x7018 <HVPower+0x2f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6ff8:	6b 89       	ldd	r22, Y+19	; 0x13
    6ffa:	7c 89       	ldd	r23, Y+20	; 0x14
    6ffc:	8d 89       	ldd	r24, Y+21	; 0x15
    6ffe:	9e 89       	ldd	r25, Y+22	; 0x16
    7000:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    7004:	dc 01       	movw	r26, r24
    7006:	cb 01       	movw	r24, r22
    7008:	8f 8b       	std	Y+23, r24	; 0x17
    700a:	8f 89       	ldd	r24, Y+23	; 0x17
    700c:	8e a3       	lds	r24, 0x5e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    700e:	8e a1       	lds	r24, 0x4e
    7010:	18 2f       	mov	r17, r24
    7012:	1a 95       	dec	r17
    7014:	f1 f7       	brne	.-4      	; 0x7012 <HVPower+0x2ea>
    7016:	1e a3       	lds	r17, 0x5e
	}
	_delay_us(1000);
}
    7018:	a7 96       	adiw	r28, 0x27	; 39
    701a:	cd bf       	out	0x3d, r28	; 61
    701c:	de bf       	out	0x3e, r29	; 62
    701e:	df 91       	pop	r29
    7020:	cf 91       	pop	r28
    7022:	1f 91       	pop	r17
    7024:	0f 91       	pop	r16
    7026:	08 95       	ret

00007028 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
    7028:	cf 93       	push	r28
    702a:	df 93       	push	r29
    702c:	0f 92       	push	r0
    702e:	cd b7       	in	r28, 0x3d	; 61
    7030:	de b7       	in	r29, 0x3e	; 62
    7032:	89 83       	std	Y+1, r24	; 0x01
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    7034:	89 81       	ldd	r24, Y+1	; 0x01
    7036:	88 23       	and	r24, r24
    7038:	31 f0       	breq	.+12     	; 0x7046 <lowerMuxCS+0x1e>
    703a:	80 e8       	ldi	r24, 0x80	; 128
    703c:	96 e0       	ldi	r25, 0x06	; 6
    703e:	20 e1       	ldi	r18, 0x10	; 16
    7040:	fc 01       	movw	r30, r24
    7042:	26 83       	std	Z+6, r18	; 0x06
    7044:	05 c0       	rjmp	.+10     	; 0x7050 <lowerMuxCS+0x28>
	else PORTE.OUTSET = PIN4_bm;
    7046:	80 e8       	ldi	r24, 0x80	; 128
    7048:	96 e0       	ldi	r25, 0x06	; 6
    704a:	20 e1       	ldi	r18, 0x10	; 16
    704c:	fc 01       	movw	r30, r24
    704e:	25 83       	std	Z+5, r18	; 0x05
}
    7050:	0f 90       	pop	r0
    7052:	df 91       	pop	r29
    7054:	cf 91       	pop	r28
    7056:	08 95       	ret

00007058 <upperMuxCS>:
void upperMuxCS(uint8_t write) {
    7058:	cf 93       	push	r28
    705a:	df 93       	push	r29
    705c:	0f 92       	push	r0
    705e:	cd b7       	in	r28, 0x3d	; 61
    7060:	de b7       	in	r29, 0x3e	; 62
    7062:	89 83       	std	Y+1, r24	; 0x01
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    7064:	89 81       	ldd	r24, Y+1	; 0x01
    7066:	88 23       	and	r24, r24
    7068:	31 f0       	breq	.+12     	; 0x7076 <upperMuxCS+0x1e>
    706a:	80 e4       	ldi	r24, 0x40	; 64
    706c:	96 e0       	ldi	r25, 0x06	; 6
    706e:	22 e0       	ldi	r18, 0x02	; 2
    7070:	fc 01       	movw	r30, r24
    7072:	26 83       	std	Z+6, r18	; 0x06
    7074:	05 c0       	rjmp	.+10     	; 0x7080 <upperMuxCS+0x28>
	else PORTC.OUTSET = PIN1_bm;
    7076:	80 e4       	ldi	r24, 0x40	; 64
    7078:	96 e0       	ldi	r25, 0x06	; 6
    707a:	22 e0       	ldi	r18, 0x02	; 2
    707c:	fc 01       	movw	r30, r24
    707e:	25 83       	std	Z+5, r18	; 0x05
}
    7080:	0f 90       	pop	r0
    7082:	df 91       	pop	r29
    7084:	cf 91       	pop	r28
    7086:	08 95       	ret

00007088 <SPIInit>:

void SPIInit(uint8_t mode) {
    7088:	cf 93       	push	r28
    708a:	df 93       	push	r29
    708c:	0f 92       	push	r0
    708e:	cd b7       	in	r28, 0x3d	; 61
    7090:	de b7       	in	r29, 0x3e	; 62
    7092:	89 83       	std	Y+1, r24	; 0x01
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    7094:	80 e4       	ldi	r24, 0x40	; 64
    7096:	96 e0       	ldi	r25, 0x06	; 6
    7098:	20 e1       	ldi	r18, 0x10	; 16
    709a:	fc 01       	movw	r30, r24
    709c:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    709e:	80 e4       	ldi	r24, 0x40	; 64
    70a0:	96 e0       	ldi	r25, 0x06	; 6
    70a2:	28 e3       	ldi	r18, 0x38	; 56
    70a4:	fc 01       	movw	r30, r24
    70a6:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    70a8:	80 e4       	ldi	r24, 0x40	; 64
    70aa:	96 e0       	ldi	r25, 0x06	; 6
    70ac:	20 e1       	ldi	r18, 0x10	; 16
    70ae:	fc 01       	movw	r30, r24
    70b0:	25 83       	std	Z+5, r18	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    70b2:	80 ec       	ldi	r24, 0xC0	; 192
    70b4:	98 e0       	ldi	r25, 0x08	; 8
    70b6:	29 81       	ldd	r18, Y+1	; 0x01
    70b8:	21 65       	ori	r18, 0x51	; 81
    70ba:	fc 01       	movw	r30, r24
    70bc:	20 83       	st	Z, r18
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    70be:	80 ec       	ldi	r24, 0xC0	; 192
    70c0:	98 e0       	ldi	r25, 0x08	; 8
    70c2:	fc 01       	movw	r30, r24
    70c4:	11 82       	std	Z+1, r1	; 0x01

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    70c6:	80 e4       	ldi	r24, 0x40	; 64
    70c8:	96 e0       	ldi	r25, 0x06	; 6
    70ca:	20 ea       	ldi	r18, 0xA0	; 160
    70cc:	fc 01       	movw	r30, r24
    70ce:	21 83       	std	Z+1, r18	; 0x01

	
}
    70d0:	0f 90       	pop	r0
    70d2:	df 91       	pop	r29
    70d4:	cf 91       	pop	r28
    70d6:	08 95       	ret

000070d8 <SPIInit2>:
//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
    70d8:	cf 93       	push	r28
    70da:	df 93       	push	r29
    70dc:	0f 92       	push	r0
    70de:	0f 92       	push	r0
    70e0:	cd b7       	in	r28, 0x3d	; 61
    70e2:	de b7       	in	r29, 0x3e	; 62
    70e4:	89 83       	std	Y+1, r24	; 0x01
    70e6:	6a 83       	std	Y+2, r22	; 0x02
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    70e8:	80 e4       	ldi	r24, 0x40	; 64
    70ea:	96 e0       	ldi	r25, 0x06	; 6
    70ec:	20 e1       	ldi	r18, 0x10	; 16
    70ee:	fc 01       	movw	r30, r24
    70f0:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    70f2:	80 e4       	ldi	r24, 0x40	; 64
    70f4:	96 e0       	ldi	r25, 0x06	; 6
    70f6:	28 e3       	ldi	r18, 0x38	; 56
    70f8:	fc 01       	movw	r30, r24
    70fa:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    70fc:	80 e4       	ldi	r24, 0x40	; 64
    70fe:	96 e0       	ldi	r25, 0x06	; 6
    7100:	20 e1       	ldi	r18, 0x10	; 16
    7102:	fc 01       	movw	r30, r24
    7104:	25 83       	std	Z+5, r18	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    7106:	80 ec       	ldi	r24, 0xC0	; 192
    7108:	98 e0       	ldi	r25, 0x08	; 8
    710a:	3a 81       	ldd	r19, Y+2	; 0x02
    710c:	29 81       	ldd	r18, Y+1	; 0x01
    710e:	23 2b       	or	r18, r19
    7110:	20 65       	ori	r18, 0x50	; 80
    7112:	fc 01       	movw	r30, r24
    7114:	20 83       	st	Z, r18
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    7116:	80 ec       	ldi	r24, 0xC0	; 192
    7118:	98 e0       	ldi	r25, 0x08	; 8
    711a:	fc 01       	movw	r30, r24
    711c:	11 82       	std	Z+1, r1	; 0x01

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    711e:	80 e4       	ldi	r24, 0x40	; 64
    7120:	96 e0       	ldi	r25, 0x06	; 6
    7122:	20 ea       	ldi	r18, 0xA0	; 160
    7124:	fc 01       	movw	r30, r24
    7126:	21 83       	std	Z+1, r18	; 0x01
}
    7128:	0f 90       	pop	r0
    712a:	0f 90       	pop	r0
    712c:	df 91       	pop	r29
    712e:	cf 91       	pop	r28
    7130:	08 95       	ret

00007132 <SPICS>:

void SPICS(uint8_t enable) {
    7132:	cf 93       	push	r28
    7134:	df 93       	push	r29
    7136:	0f 92       	push	r0
    7138:	cd b7       	in	r28, 0x3d	; 61
    713a:	de b7       	in	r29, 0x3e	; 62
    713c:	89 83       	std	Y+1, r24	; 0x01
	if (enable) PORTC.OUTCLR = PIN4_bm;
    713e:	89 81       	ldd	r24, Y+1	; 0x01
    7140:	88 23       	and	r24, r24
    7142:	31 f0       	breq	.+12     	; 0x7150 <SPICS+0x1e>
    7144:	80 e4       	ldi	r24, 0x40	; 64
    7146:	96 e0       	ldi	r25, 0x06	; 6
    7148:	20 e1       	ldi	r18, 0x10	; 16
    714a:	fc 01       	movw	r30, r24
    714c:	26 83       	std	Z+6, r18	; 0x06
    714e:	05 c0       	rjmp	.+10     	; 0x715a <SPICS+0x28>
	else {
		PORTC.OUTSET = PIN4_bm;
    7150:	80 e4       	ldi	r24, 0x40	; 64
    7152:	96 e0       	ldi	r25, 0x06	; 6
    7154:	20 e1       	ldi	r18, 0x10	; 16
    7156:	fc 01       	movw	r30, r24
    7158:	25 83       	std	Z+5, r18	; 0x05
	}	
}
    715a:	0f 90       	pop	r0
    715c:	df 91       	pop	r29
    715e:	cf 91       	pop	r28
    7160:	08 95       	ret

00007162 <SPIDisable>:

void SPIDisable() {
    7162:	cf 93       	push	r28
    7164:	df 93       	push	r29
    7166:	cd b7       	in	r28, 0x3d	; 61
    7168:	de b7       	in	r29, 0x3e	; 62
	PORTC.OUTSET = PIN4_bm;
    716a:	80 e4       	ldi	r24, 0x40	; 64
    716c:	96 e0       	ldi	r25, 0x06	; 6
    716e:	20 e1       	ldi	r18, 0x10	; 16
    7170:	fc 01       	movw	r30, r24
    7172:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = 0x00;
    7174:	80 ec       	ldi	r24, 0xC0	; 192
    7176:	98 e0       	ldi	r25, 0x08	; 8
    7178:	fc 01       	movw	r30, r24
    717a:	10 82       	st	Z, r1
	PORTC.OUTCLR = PIN4_bm;
    717c:	80 e4       	ldi	r24, 0x40	; 64
    717e:	96 e0       	ldi	r25, 0x06	; 6
    7180:	20 e1       	ldi	r18, 0x10	; 16
    7182:	fc 01       	movw	r30, r24
    7184:	26 83       	std	Z+6, r18	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    7186:	80 e4       	ldi	r24, 0x40	; 64
    7188:	96 e0       	ldi	r25, 0x06	; 6
    718a:	20 eb       	ldi	r18, 0xB0	; 176
    718c:	fc 01       	movw	r30, r24
    718e:	22 83       	std	Z+2, r18	; 0x02

}
    7190:	df 91       	pop	r29
    7192:	cf 91       	pop	r28
    7194:	08 95       	ret

00007196 <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    7196:	cf 93       	push	r28
    7198:	df 93       	push	r29
    719a:	00 d0       	rcall	.+0      	; 0x719c <readFRAM+0x6>
    719c:	0f 92       	push	r0
    719e:	cd b7       	in	r28, 0x3d	; 61
    71a0:	de b7       	in	r29, 0x3e	; 62
    71a2:	8b 83       	std	Y+3, r24	; 0x03
    71a4:	9c 83       	std	Y+4, r25	; 0x04
	SPIInit(SPI_MODE_0_gc);
    71a6:	80 e0       	ldi	r24, 0x00	; 0
    71a8:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    71ac:	80 ec       	ldi	r24, 0xC0	; 192
    71ae:	98 e0       	ldi	r25, 0x08	; 8
    71b0:	20 ed       	ldi	r18, 0xD0	; 208
    71b2:	fc 01       	movw	r30, r24
    71b4:	20 83       	st	Z, r18
	SPICS(TRUE);
    71b6:	81 e0       	ldi	r24, 0x01	; 1
    71b8:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    71bc:	80 e2       	ldi	r24, 0x20	; 32
    71be:	96 e0       	ldi	r25, 0x06	; 6
    71c0:	28 e0       	ldi	r18, 0x08	; 8
    71c2:	fc 01       	movw	r30, r24
    71c4:	26 83       	std	Z+6, r18	; 0x06
	nop();
    71c6:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    71c8:	80 ec       	ldi	r24, 0xC0	; 192
    71ca:	98 e0       	ldi	r25, 0x08	; 8
    71cc:	23 e0       	ldi	r18, 0x03	; 3
    71ce:	fc 01       	movw	r30, r24
    71d0:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    71d2:	00 00       	nop
    71d4:	80 ec       	ldi	r24, 0xC0	; 192
    71d6:	98 e0       	ldi	r25, 0x08	; 8
    71d8:	fc 01       	movw	r30, r24
    71da:	82 81       	ldd	r24, Z+2	; 0x02
    71dc:	88 23       	and	r24, r24
    71de:	d4 f7       	brge	.-12     	; 0x71d4 <readFRAM+0x3e>
	SPIBuffer[12] = SPIC.DATA;
    71e0:	80 ec       	ldi	r24, 0xC0	; 192
    71e2:	98 e0       	ldi	r25, 0x08	; 8
    71e4:	fc 01       	movw	r30, r24
    71e6:	83 81       	ldd	r24, Z+3	; 0x03
    71e8:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    71ec:	80 ec       	ldi	r24, 0xC0	; 192
    71ee:	98 e0       	ldi	r25, 0x08	; 8
    71f0:	20 91 45 40 	lds	r18, 0x4045
    71f4:	fc 01       	movw	r30, r24
    71f6:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    71f8:	00 00       	nop
    71fa:	80 ec       	ldi	r24, 0xC0	; 192
    71fc:	98 e0       	ldi	r25, 0x08	; 8
    71fe:	fc 01       	movw	r30, r24
    7200:	82 81       	ldd	r24, Z+2	; 0x02
    7202:	88 23       	and	r24, r24
    7204:	d4 f7       	brge	.-12     	; 0x71fa <readFRAM+0x64>
	SPIBuffer[12] = SPIC.DATA;
    7206:	80 ec       	ldi	r24, 0xC0	; 192
    7208:	98 e0       	ldi	r25, 0x08	; 8
    720a:	fc 01       	movw	r30, r24
    720c:	83 81       	ldd	r24, Z+3	; 0x03
    720e:	80 93 66 50 	sts	0x5066, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    7212:	80 ec       	ldi	r24, 0xC0	; 192
    7214:	98 e0       	ldi	r25, 0x08	; 8
    7216:	24 e4       	ldi	r18, 0x44	; 68
    7218:	30 e4       	ldi	r19, 0x40	; 64
    721a:	f9 01       	movw	r30, r18
    721c:	20 81       	ld	r18, Z
    721e:	fc 01       	movw	r30, r24
    7220:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    7222:	00 00       	nop
    7224:	80 ec       	ldi	r24, 0xC0	; 192
    7226:	98 e0       	ldi	r25, 0x08	; 8
    7228:	fc 01       	movw	r30, r24
    722a:	82 81       	ldd	r24, Z+2	; 0x02
    722c:	88 23       	and	r24, r24
    722e:	d4 f7       	brge	.-12     	; 0x7224 <readFRAM+0x8e>
	SPIBuffer[12] = SPIC.DATA;
    7230:	80 ec       	ldi	r24, 0xC0	; 192
    7232:	98 e0       	ldi	r25, 0x08	; 8
    7234:	fc 01       	movw	r30, r24
    7236:	83 81       	ldd	r24, Z+3	; 0x03
    7238:	80 93 66 50 	sts	0x5066, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    723c:	19 82       	std	Y+1, r1	; 0x01
    723e:	1a 82       	std	Y+2, r1	; 0x02
    7240:	1b c0       	rjmp	.+54     	; 0x7278 <readFRAM+0xe2>
		SPIC.DATA = 0xAA;
    7242:	80 ec       	ldi	r24, 0xC0	; 192
    7244:	98 e0       	ldi	r25, 0x08	; 8
    7246:	2a ea       	ldi	r18, 0xAA	; 170
    7248:	fc 01       	movw	r30, r24
    724a:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    724c:	00 00       	nop
    724e:	80 ec       	ldi	r24, 0xC0	; 192
    7250:	98 e0       	ldi	r25, 0x08	; 8
    7252:	fc 01       	movw	r30, r24
    7254:	82 81       	ldd	r24, Z+2	; 0x02
    7256:	88 23       	and	r24, r24
    7258:	d4 f7       	brge	.-12     	; 0x724e <readFRAM+0xb8>
		FRAMReadBuffer[i] = SPIC.DATA;
    725a:	80 ec       	ldi	r24, 0xC0	; 192
    725c:	98 e0       	ldi	r25, 0x08	; 8
    725e:	fc 01       	movw	r30, r24
    7260:	23 81       	ldd	r18, Z+3	; 0x03
    7262:	89 81       	ldd	r24, Y+1	; 0x01
    7264:	9a 81       	ldd	r25, Y+2	; 0x02
    7266:	84 53       	subi	r24, 0x34	; 52
    7268:	9c 4d       	sbci	r25, 0xDC	; 220
    726a:	fc 01       	movw	r30, r24
    726c:	20 83       	st	Z, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    726e:	89 81       	ldd	r24, Y+1	; 0x01
    7270:	9a 81       	ldd	r25, Y+2	; 0x02
    7272:	01 96       	adiw	r24, 0x01	; 1
    7274:	89 83       	std	Y+1, r24	; 0x01
    7276:	9a 83       	std	Y+2, r25	; 0x02
    7278:	29 81       	ldd	r18, Y+1	; 0x01
    727a:	3a 81       	ldd	r19, Y+2	; 0x02
    727c:	8b 81       	ldd	r24, Y+3	; 0x03
    727e:	9c 81       	ldd	r25, Y+4	; 0x04
    7280:	28 17       	cp	r18, r24
    7282:	39 07       	cpc	r19, r25
    7284:	f0 f2       	brcs	.-68     	; 0x7242 <readFRAM+0xac>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    7286:	80 e2       	ldi	r24, 0x20	; 32
    7288:	96 e0       	ldi	r25, 0x06	; 6
    728a:	28 e0       	ldi	r18, 0x08	; 8
    728c:	fc 01       	movw	r30, r24
    728e:	25 83       	std	Z+5, r18	; 0x05
	SPICS(FALSE);
    7290:	80 e0       	ldi	r24, 0x00	; 0
    7292:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	SPIDisable();
    7296:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>

}
    729a:	24 96       	adiw	r28, 0x04	; 4
    729c:	cd bf       	out	0x3d, r28	; 61
    729e:	de bf       	out	0x3e, r29	; 62
    72a0:	df 91       	pop	r29
    72a2:	cf 91       	pop	r28
    72a4:	08 95       	ret

000072a6 <FRAMTest3Channel>:

void FRAMTest3Channel(void) {
    72a6:	8f 92       	push	r8
    72a8:	9f 92       	push	r9
    72aa:	af 92       	push	r10
    72ac:	bf 92       	push	r11
    72ae:	cf 92       	push	r12
    72b0:	df 92       	push	r13
    72b2:	ef 92       	push	r14
    72b4:	ff 92       	push	r15
    72b6:	0f 93       	push	r16
    72b8:	1f 93       	push	r17
    72ba:	cf 93       	push	r28
    72bc:	df 93       	push	r29
    72be:	cd b7       	in	r28, 0x3d	; 61
    72c0:	de b7       	in	r29, 0x3e	; 62
    72c2:	6b 97       	sbiw	r28, 0x1b	; 27
    72c4:	cd bf       	out	0x3d, r28	; 61
    72c6:	de bf       	out	0x3e, r29	; 62
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
    72c8:	19 8e       	std	Y+25, r1	; 0x19
    72ca:	1a 8e       	std	Y+26, r1	; 0x1a
    72cc:	1b 8e       	std	Y+27, r1	; 0x1b
			
	CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |
		FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
		gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
    72ce:	9e 01       	movw	r18, r28
    72d0:	27 5e       	subi	r18, 0xE7	; 231
    72d2:	3f 4f       	sbci	r19, 0xFF	; 255
}

void FRAMTest3Channel(void) {
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
			
	CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |
    72d4:	8e ec       	ldi	r24, 0xCE	; 206
    72d6:	b9 01       	movw	r22, r18
    72d8:	40 e0       	ldi	r20, 0x00	; 0
    72da:	25 e1       	ldi	r18, 0x15	; 21
    72dc:	01 e0       	ldi	r16, 0x01	; 1
    72de:	0f 2e       	mov	r0, r31
    72e0:	fd e0       	ldi	r31, 0x0D	; 13
    72e2:	ef 2e       	mov	r14, r31
    72e4:	ff 24       	eor	r15, r15
    72e6:	f0 2d       	mov	r31, r0
    72e8:	0f 2e       	mov	r0, r31
    72ea:	fe e0       	ldi	r31, 0x0E	; 14
    72ec:	cf 2e       	mov	r12, r31
    72ee:	dd 24       	eor	r13, r13
    72f0:	f0 2d       	mov	r31, r0
    72f2:	0f 2e       	mov	r0, r31
    72f4:	ff e0       	ldi	r31, 0x0F	; 15
    72f6:	af 2e       	mov	r10, r31
    72f8:	bb 24       	eor	r11, r11
    72fa:	f0 2d       	mov	r31, r0
    72fc:	88 24       	eor	r8, r8
    72fe:	99 24       	eor	r9, r9
    7300:	68 94       	set
    7302:	84 f8       	bld	r8, 4
    7304:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <CO_collectSeismic3Channel>
		FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
		gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    7308:	81 e0       	ldi	r24, 0x01	; 1
    730a:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
    730e:	80 e0       	ldi	r24, 0x00	; 0
    7310:	90 e0       	ldi	r25, 0x00	; 0
    7312:	aa e7       	ldi	r26, 0x7A	; 122
    7314:	b3 e4       	ldi	r27, 0x43	; 67
    7316:	89 83       	std	Y+1, r24	; 0x01
    7318:	9a 83       	std	Y+2, r25	; 0x02
    731a:	ab 83       	std	Y+3, r26	; 0x03
    731c:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    731e:	69 81       	ldd	r22, Y+1	; 0x01
    7320:	7a 81       	ldd	r23, Y+2	; 0x02
    7322:	8b 81       	ldd	r24, Y+3	; 0x03
    7324:	9c 81       	ldd	r25, Y+4	; 0x04
    7326:	2b ea       	ldi	r18, 0xAB	; 171
    7328:	3a ea       	ldi	r19, 0xAA	; 170
    732a:	4a e2       	ldi	r20, 0x2A	; 42
    732c:	51 e4       	ldi	r21, 0x41	; 65
    732e:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    7332:	dc 01       	movw	r26, r24
    7334:	cb 01       	movw	r24, r22
    7336:	8d 83       	std	Y+5, r24	; 0x05
    7338:	9e 83       	std	Y+6, r25	; 0x06
    733a:	af 83       	std	Y+7, r26	; 0x07
    733c:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    733e:	11 e0       	ldi	r17, 0x01	; 1
    7340:	6d 81       	ldd	r22, Y+5	; 0x05
    7342:	7e 81       	ldd	r23, Y+6	; 0x06
    7344:	8f 81       	ldd	r24, Y+7	; 0x07
    7346:	98 85       	ldd	r25, Y+8	; 0x08
    7348:	20 e0       	ldi	r18, 0x00	; 0
    734a:	30 e0       	ldi	r19, 0x00	; 0
    734c:	40 e8       	ldi	r20, 0x80	; 128
    734e:	5f e3       	ldi	r21, 0x3F	; 63
    7350:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    7354:	88 23       	and	r24, r24
    7356:	0c f0       	brlt	.+2      	; 0x735a <FRAMTest3Channel+0xb4>
    7358:	10 e0       	ldi	r17, 0x00	; 0
    735a:	11 23       	and	r17, r17
    735c:	19 f0       	breq	.+6      	; 0x7364 <FRAMTest3Channel+0xbe>
		__ticks = 1;
    735e:	81 e0       	ldi	r24, 0x01	; 1
    7360:	89 87       	std	Y+9, r24	; 0x09
    7362:	a3 c0       	rjmp	.+326    	; 0x74aa <FRAMTest3Channel+0x204>
	else if (__tmp > 255)
    7364:	11 e0       	ldi	r17, 0x01	; 1
    7366:	6d 81       	ldd	r22, Y+5	; 0x05
    7368:	7e 81       	ldd	r23, Y+6	; 0x06
    736a:	8f 81       	ldd	r24, Y+7	; 0x07
    736c:	98 85       	ldd	r25, Y+8	; 0x08
    736e:	20 e0       	ldi	r18, 0x00	; 0
    7370:	30 e0       	ldi	r19, 0x00	; 0
    7372:	4f e7       	ldi	r20, 0x7F	; 127
    7374:	53 e4       	ldi	r21, 0x43	; 67
    7376:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    737a:	18 16       	cp	r1, r24
    737c:	0c f0       	brlt	.+2      	; 0x7380 <FRAMTest3Channel+0xda>
    737e:	10 e0       	ldi	r17, 0x00	; 0
    7380:	11 23       	and	r17, r17
    7382:	09 f4       	brne	.+2      	; 0x7386 <FRAMTest3Channel+0xe0>
    7384:	89 c0       	rjmp	.+274    	; 0x7498 <FRAMTest3Channel+0x1f2>
	{
		_delay_ms(__us / 1000.0);
    7386:	69 81       	ldd	r22, Y+1	; 0x01
    7388:	7a 81       	ldd	r23, Y+2	; 0x02
    738a:	8b 81       	ldd	r24, Y+3	; 0x03
    738c:	9c 81       	ldd	r25, Y+4	; 0x04
    738e:	20 e0       	ldi	r18, 0x00	; 0
    7390:	30 e0       	ldi	r19, 0x00	; 0
    7392:	4a e7       	ldi	r20, 0x7A	; 122
    7394:	54 e4       	ldi	r21, 0x44	; 68
    7396:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
    739a:	dc 01       	movw	r26, r24
    739c:	cb 01       	movw	r24, r22
    739e:	8a 87       	std	Y+10, r24	; 0x0a
    73a0:	9b 87       	std	Y+11, r25	; 0x0b
    73a2:	ac 87       	std	Y+12, r26	; 0x0c
    73a4:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    73a6:	6a 85       	ldd	r22, Y+10	; 0x0a
    73a8:	7b 85       	ldd	r23, Y+11	; 0x0b
    73aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    73ac:	9d 85       	ldd	r25, Y+13	; 0x0d
    73ae:	20 e0       	ldi	r18, 0x00	; 0
    73b0:	30 e0       	ldi	r19, 0x00	; 0
    73b2:	4a ef       	ldi	r20, 0xFA	; 250
    73b4:	55 e4       	ldi	r21, 0x45	; 69
    73b6:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    73ba:	dc 01       	movw	r26, r24
    73bc:	cb 01       	movw	r24, r22
    73be:	8e 87       	std	Y+14, r24	; 0x0e
    73c0:	9f 87       	std	Y+15, r25	; 0x0f
    73c2:	a8 8b       	std	Y+16, r26	; 0x10
    73c4:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    73c6:	11 e0       	ldi	r17, 0x01	; 1
    73c8:	6e 85       	ldd	r22, Y+14	; 0x0e
    73ca:	7f 85       	ldd	r23, Y+15	; 0x0f
    73cc:	88 89       	ldd	r24, Y+16	; 0x10
    73ce:	99 89       	ldd	r25, Y+17	; 0x11
    73d0:	20 e0       	ldi	r18, 0x00	; 0
    73d2:	30 e0       	ldi	r19, 0x00	; 0
    73d4:	40 e8       	ldi	r20, 0x80	; 128
    73d6:	5f e3       	ldi	r21, 0x3F	; 63
    73d8:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    73dc:	88 23       	and	r24, r24
    73de:	0c f0       	brlt	.+2      	; 0x73e2 <FRAMTest3Channel+0x13c>
    73e0:	10 e0       	ldi	r17, 0x00	; 0
    73e2:	11 23       	and	r17, r17
    73e4:	29 f0       	breq	.+10     	; 0x73f0 <FRAMTest3Channel+0x14a>
		__ticks = 1;
    73e6:	81 e0       	ldi	r24, 0x01	; 1
    73e8:	90 e0       	ldi	r25, 0x00	; 0
    73ea:	8a 8b       	std	Y+18, r24	; 0x12
    73ec:	9b 8b       	std	Y+19, r25	; 0x13
    73ee:	46 c0       	rjmp	.+140    	; 0x747c <FRAMTest3Channel+0x1d6>
	else if (__tmp > 65535)
    73f0:	11 e0       	ldi	r17, 0x01	; 1
    73f2:	6e 85       	ldd	r22, Y+14	; 0x0e
    73f4:	7f 85       	ldd	r23, Y+15	; 0x0f
    73f6:	88 89       	ldd	r24, Y+16	; 0x10
    73f8:	99 89       	ldd	r25, Y+17	; 0x11
    73fa:	20 e0       	ldi	r18, 0x00	; 0
    73fc:	3f ef       	ldi	r19, 0xFF	; 255
    73fe:	4f e7       	ldi	r20, 0x7F	; 127
    7400:	57 e4       	ldi	r21, 0x47	; 71
    7402:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    7406:	18 16       	cp	r1, r24
    7408:	0c f0       	brlt	.+2      	; 0x740c <FRAMTest3Channel+0x166>
    740a:	10 e0       	ldi	r17, 0x00	; 0
    740c:	11 23       	and	r17, r17
    740e:	61 f1       	breq	.+88     	; 0x7468 <FRAMTest3Channel+0x1c2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7410:	6a 85       	ldd	r22, Y+10	; 0x0a
    7412:	7b 85       	ldd	r23, Y+11	; 0x0b
    7414:	8c 85       	ldd	r24, Y+12	; 0x0c
    7416:	9d 85       	ldd	r25, Y+13	; 0x0d
    7418:	20 e0       	ldi	r18, 0x00	; 0
    741a:	30 e0       	ldi	r19, 0x00	; 0
    741c:	40 e2       	ldi	r20, 0x20	; 32
    741e:	51 e4       	ldi	r21, 0x41	; 65
    7420:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    7424:	dc 01       	movw	r26, r24
    7426:	cb 01       	movw	r24, r22
    7428:	bc 01       	movw	r22, r24
    742a:	cd 01       	movw	r24, r26
    742c:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    7430:	dc 01       	movw	r26, r24
    7432:	cb 01       	movw	r24, r22
    7434:	8a 8b       	std	Y+18, r24	; 0x12
    7436:	9b 8b       	std	Y+19, r25	; 0x13
    7438:	12 c0       	rjmp	.+36     	; 0x745e <FRAMTest3Channel+0x1b8>
    743a:	80 e2       	ldi	r24, 0x20	; 32
    743c:	93 e0       	ldi	r25, 0x03	; 3
    743e:	8c 8b       	std	Y+20, r24	; 0x14
    7440:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7442:	8c 89       	ldd	r24, Y+20	; 0x14
    7444:	9d 89       	ldd	r25, Y+21	; 0x15
    7446:	8c 01       	movw	r16, r24
    7448:	c8 01       	movw	r24, r16
    744a:	01 97       	sbiw	r24, 0x01	; 1
    744c:	f1 f7       	brne	.-4      	; 0x744a <FRAMTest3Channel+0x1a4>
    744e:	8c 01       	movw	r16, r24
    7450:	0c 8b       	std	Y+20, r16	; 0x14
    7452:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7454:	8a 89       	ldd	r24, Y+18	; 0x12
    7456:	9b 89       	ldd	r25, Y+19	; 0x13
    7458:	01 97       	sbiw	r24, 0x01	; 1
    745a:	8a 8b       	std	Y+18, r24	; 0x12
    745c:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    745e:	8a 89       	ldd	r24, Y+18	; 0x12
    7460:	9b 89       	ldd	r25, Y+19	; 0x13
    7462:	00 97       	sbiw	r24, 0x00	; 0
    7464:	51 f7       	brne	.-44     	; 0x743a <FRAMTest3Channel+0x194>
    7466:	28 c0       	rjmp	.+80     	; 0x74b8 <FRAMTest3Channel+0x212>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7468:	6e 85       	ldd	r22, Y+14	; 0x0e
    746a:	7f 85       	ldd	r23, Y+15	; 0x0f
    746c:	88 89       	ldd	r24, Y+16	; 0x10
    746e:	99 89       	ldd	r25, Y+17	; 0x11
    7470:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    7474:	dc 01       	movw	r26, r24
    7476:	cb 01       	movw	r24, r22
    7478:	8a 8b       	std	Y+18, r24	; 0x12
    747a:	9b 8b       	std	Y+19, r25	; 0x13
    747c:	8a 89       	ldd	r24, Y+18	; 0x12
    747e:	9b 89       	ldd	r25, Y+19	; 0x13
    7480:	8e 8b       	std	Y+22, r24	; 0x16
    7482:	9f 8b       	std	Y+23, r25	; 0x17
    7484:	8e 89       	ldd	r24, Y+22	; 0x16
    7486:	9f 89       	ldd	r25, Y+23	; 0x17
    7488:	8c 01       	movw	r16, r24
    748a:	c8 01       	movw	r24, r16
    748c:	01 97       	sbiw	r24, 0x01	; 1
    748e:	f1 f7       	brne	.-4      	; 0x748c <FRAMTest3Channel+0x1e6>
    7490:	8c 01       	movw	r16, r24
    7492:	0e 8b       	std	Y+22, r16	; 0x16
    7494:	1f 8b       	std	Y+23, r17	; 0x17
    7496:	10 c0       	rjmp	.+32     	; 0x74b8 <FRAMTest3Channel+0x212>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7498:	6d 81       	ldd	r22, Y+5	; 0x05
    749a:	7e 81       	ldd	r23, Y+6	; 0x06
    749c:	8f 81       	ldd	r24, Y+7	; 0x07
    749e:	98 85       	ldd	r25, Y+8	; 0x08
    74a0:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    74a4:	dc 01       	movw	r26, r24
    74a6:	cb 01       	movw	r24, r22
    74a8:	89 87       	std	Y+9, r24	; 0x09
    74aa:	89 85       	ldd	r24, Y+9	; 0x09
    74ac:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    74ae:	88 8d       	ldd	r24, Y+24	; 0x18
    74b0:	18 2f       	mov	r17, r24
    74b2:	1a 95       	dec	r17
    74b4:	f1 f7       	brne	.-4      	; 0x74b2 <FRAMTest3Channel+0x20c>
    74b6:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    74b8:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <calcChecksumFRAM>

	ADCPower(FALSE);
    74bc:	80 e0       	ldi	r24, 0x00	; 0
    74be:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	
}
    74c2:	6b 96       	adiw	r28, 0x1b	; 27
    74c4:	cd bf       	out	0x3d, r28	; 61
    74c6:	de bf       	out	0x3e, r29	; 62
    74c8:	df 91       	pop	r29
    74ca:	cf 91       	pop	r28
    74cc:	1f 91       	pop	r17
    74ce:	0f 91       	pop	r16
    74d0:	ff 90       	pop	r15
    74d2:	ef 90       	pop	r14
    74d4:	df 90       	pop	r13
    74d6:	cf 90       	pop	r12
    74d8:	bf 90       	pop	r11
    74da:	af 90       	pop	r10
    74dc:	9f 90       	pop	r9
    74de:	8f 90       	pop	r8
    74e0:	08 95       	ret

000074e2 <FRAMTest1Channel>:
//need to fix
void FRAMTest1Channel(void) {
    74e2:	0f 93       	push	r16
    74e4:	1f 93       	push	r17
    74e6:	cf 93       	push	r28
    74e8:	df 93       	push	r29
    74ea:	cd b7       	in	r28, 0x3d	; 61
    74ec:	de b7       	in	r29, 0x3e	; 62
    74ee:	68 97       	sbiw	r28, 0x18	; 24
    74f0:	cd bf       	out	0x3d, r28	; 61
    74f2:	de bf       	out	0x3e, r29	; 62

	//CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc, GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    74f4:	81 e0       	ldi	r24, 0x01	; 1
    74f6:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
    74fa:	80 e0       	ldi	r24, 0x00	; 0
    74fc:	90 e0       	ldi	r25, 0x00	; 0
    74fe:	aa e7       	ldi	r26, 0x7A	; 122
    7500:	b3 e4       	ldi	r27, 0x43	; 67
    7502:	89 83       	std	Y+1, r24	; 0x01
    7504:	9a 83       	std	Y+2, r25	; 0x02
    7506:	ab 83       	std	Y+3, r26	; 0x03
    7508:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    750a:	69 81       	ldd	r22, Y+1	; 0x01
    750c:	7a 81       	ldd	r23, Y+2	; 0x02
    750e:	8b 81       	ldd	r24, Y+3	; 0x03
    7510:	9c 81       	ldd	r25, Y+4	; 0x04
    7512:	2b ea       	ldi	r18, 0xAB	; 171
    7514:	3a ea       	ldi	r19, 0xAA	; 170
    7516:	4a e2       	ldi	r20, 0x2A	; 42
    7518:	51 e4       	ldi	r21, 0x41	; 65
    751a:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    751e:	dc 01       	movw	r26, r24
    7520:	cb 01       	movw	r24, r22
    7522:	8d 83       	std	Y+5, r24	; 0x05
    7524:	9e 83       	std	Y+6, r25	; 0x06
    7526:	af 83       	std	Y+7, r26	; 0x07
    7528:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    752a:	11 e0       	ldi	r17, 0x01	; 1
    752c:	6d 81       	ldd	r22, Y+5	; 0x05
    752e:	7e 81       	ldd	r23, Y+6	; 0x06
    7530:	8f 81       	ldd	r24, Y+7	; 0x07
    7532:	98 85       	ldd	r25, Y+8	; 0x08
    7534:	20 e0       	ldi	r18, 0x00	; 0
    7536:	30 e0       	ldi	r19, 0x00	; 0
    7538:	40 e8       	ldi	r20, 0x80	; 128
    753a:	5f e3       	ldi	r21, 0x3F	; 63
    753c:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    7540:	88 23       	and	r24, r24
    7542:	0c f0       	brlt	.+2      	; 0x7546 <FRAMTest1Channel+0x64>
    7544:	10 e0       	ldi	r17, 0x00	; 0
    7546:	11 23       	and	r17, r17
    7548:	19 f0       	breq	.+6      	; 0x7550 <FRAMTest1Channel+0x6e>
		__ticks = 1;
    754a:	81 e0       	ldi	r24, 0x01	; 1
    754c:	89 87       	std	Y+9, r24	; 0x09
    754e:	a3 c0       	rjmp	.+326    	; 0x7696 <FRAMTest1Channel+0x1b4>
	else if (__tmp > 255)
    7550:	11 e0       	ldi	r17, 0x01	; 1
    7552:	6d 81       	ldd	r22, Y+5	; 0x05
    7554:	7e 81       	ldd	r23, Y+6	; 0x06
    7556:	8f 81       	ldd	r24, Y+7	; 0x07
    7558:	98 85       	ldd	r25, Y+8	; 0x08
    755a:	20 e0       	ldi	r18, 0x00	; 0
    755c:	30 e0       	ldi	r19, 0x00	; 0
    755e:	4f e7       	ldi	r20, 0x7F	; 127
    7560:	53 e4       	ldi	r21, 0x43	; 67
    7562:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    7566:	18 16       	cp	r1, r24
    7568:	0c f0       	brlt	.+2      	; 0x756c <FRAMTest1Channel+0x8a>
    756a:	10 e0       	ldi	r17, 0x00	; 0
    756c:	11 23       	and	r17, r17
    756e:	09 f4       	brne	.+2      	; 0x7572 <FRAMTest1Channel+0x90>
    7570:	89 c0       	rjmp	.+274    	; 0x7684 <FRAMTest1Channel+0x1a2>
	{
		_delay_ms(__us / 1000.0);
    7572:	69 81       	ldd	r22, Y+1	; 0x01
    7574:	7a 81       	ldd	r23, Y+2	; 0x02
    7576:	8b 81       	ldd	r24, Y+3	; 0x03
    7578:	9c 81       	ldd	r25, Y+4	; 0x04
    757a:	20 e0       	ldi	r18, 0x00	; 0
    757c:	30 e0       	ldi	r19, 0x00	; 0
    757e:	4a e7       	ldi	r20, 0x7A	; 122
    7580:	54 e4       	ldi	r21, 0x44	; 68
    7582:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
    7586:	dc 01       	movw	r26, r24
    7588:	cb 01       	movw	r24, r22
    758a:	8a 87       	std	Y+10, r24	; 0x0a
    758c:	9b 87       	std	Y+11, r25	; 0x0b
    758e:	ac 87       	std	Y+12, r26	; 0x0c
    7590:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7592:	6a 85       	ldd	r22, Y+10	; 0x0a
    7594:	7b 85       	ldd	r23, Y+11	; 0x0b
    7596:	8c 85       	ldd	r24, Y+12	; 0x0c
    7598:	9d 85       	ldd	r25, Y+13	; 0x0d
    759a:	20 e0       	ldi	r18, 0x00	; 0
    759c:	30 e0       	ldi	r19, 0x00	; 0
    759e:	4a ef       	ldi	r20, 0xFA	; 250
    75a0:	55 e4       	ldi	r21, 0x45	; 69
    75a2:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    75a6:	dc 01       	movw	r26, r24
    75a8:	cb 01       	movw	r24, r22
    75aa:	8e 87       	std	Y+14, r24	; 0x0e
    75ac:	9f 87       	std	Y+15, r25	; 0x0f
    75ae:	a8 8b       	std	Y+16, r26	; 0x10
    75b0:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    75b2:	11 e0       	ldi	r17, 0x01	; 1
    75b4:	6e 85       	ldd	r22, Y+14	; 0x0e
    75b6:	7f 85       	ldd	r23, Y+15	; 0x0f
    75b8:	88 89       	ldd	r24, Y+16	; 0x10
    75ba:	99 89       	ldd	r25, Y+17	; 0x11
    75bc:	20 e0       	ldi	r18, 0x00	; 0
    75be:	30 e0       	ldi	r19, 0x00	; 0
    75c0:	40 e8       	ldi	r20, 0x80	; 128
    75c2:	5f e3       	ldi	r21, 0x3F	; 63
    75c4:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    75c8:	88 23       	and	r24, r24
    75ca:	0c f0       	brlt	.+2      	; 0x75ce <FRAMTest1Channel+0xec>
    75cc:	10 e0       	ldi	r17, 0x00	; 0
    75ce:	11 23       	and	r17, r17
    75d0:	29 f0       	breq	.+10     	; 0x75dc <FRAMTest1Channel+0xfa>
		__ticks = 1;
    75d2:	81 e0       	ldi	r24, 0x01	; 1
    75d4:	90 e0       	ldi	r25, 0x00	; 0
    75d6:	8a 8b       	std	Y+18, r24	; 0x12
    75d8:	9b 8b       	std	Y+19, r25	; 0x13
    75da:	46 c0       	rjmp	.+140    	; 0x7668 <FRAMTest1Channel+0x186>
	else if (__tmp > 65535)
    75dc:	11 e0       	ldi	r17, 0x01	; 1
    75de:	6e 85       	ldd	r22, Y+14	; 0x0e
    75e0:	7f 85       	ldd	r23, Y+15	; 0x0f
    75e2:	88 89       	ldd	r24, Y+16	; 0x10
    75e4:	99 89       	ldd	r25, Y+17	; 0x11
    75e6:	20 e0       	ldi	r18, 0x00	; 0
    75e8:	3f ef       	ldi	r19, 0xFF	; 255
    75ea:	4f e7       	ldi	r20, 0x7F	; 127
    75ec:	57 e4       	ldi	r21, 0x47	; 71
    75ee:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    75f2:	18 16       	cp	r1, r24
    75f4:	0c f0       	brlt	.+2      	; 0x75f8 <FRAMTest1Channel+0x116>
    75f6:	10 e0       	ldi	r17, 0x00	; 0
    75f8:	11 23       	and	r17, r17
    75fa:	61 f1       	breq	.+88     	; 0x7654 <FRAMTest1Channel+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    75fc:	6a 85       	ldd	r22, Y+10	; 0x0a
    75fe:	7b 85       	ldd	r23, Y+11	; 0x0b
    7600:	8c 85       	ldd	r24, Y+12	; 0x0c
    7602:	9d 85       	ldd	r25, Y+13	; 0x0d
    7604:	20 e0       	ldi	r18, 0x00	; 0
    7606:	30 e0       	ldi	r19, 0x00	; 0
    7608:	40 e2       	ldi	r20, 0x20	; 32
    760a:	51 e4       	ldi	r21, 0x41	; 65
    760c:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    7610:	dc 01       	movw	r26, r24
    7612:	cb 01       	movw	r24, r22
    7614:	bc 01       	movw	r22, r24
    7616:	cd 01       	movw	r24, r26
    7618:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    761c:	dc 01       	movw	r26, r24
    761e:	cb 01       	movw	r24, r22
    7620:	8a 8b       	std	Y+18, r24	; 0x12
    7622:	9b 8b       	std	Y+19, r25	; 0x13
    7624:	12 c0       	rjmp	.+36     	; 0x764a <FRAMTest1Channel+0x168>
    7626:	80 e2       	ldi	r24, 0x20	; 32
    7628:	93 e0       	ldi	r25, 0x03	; 3
    762a:	8c 8b       	std	Y+20, r24	; 0x14
    762c:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    762e:	8c 89       	ldd	r24, Y+20	; 0x14
    7630:	9d 89       	ldd	r25, Y+21	; 0x15
    7632:	8c 01       	movw	r16, r24
    7634:	c8 01       	movw	r24, r16
    7636:	01 97       	sbiw	r24, 0x01	; 1
    7638:	f1 f7       	brne	.-4      	; 0x7636 <FRAMTest1Channel+0x154>
    763a:	8c 01       	movw	r16, r24
    763c:	0c 8b       	std	Y+20, r16	; 0x14
    763e:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7640:	8a 89       	ldd	r24, Y+18	; 0x12
    7642:	9b 89       	ldd	r25, Y+19	; 0x13
    7644:	01 97       	sbiw	r24, 0x01	; 1
    7646:	8a 8b       	std	Y+18, r24	; 0x12
    7648:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    764a:	8a 89       	ldd	r24, Y+18	; 0x12
    764c:	9b 89       	ldd	r25, Y+19	; 0x13
    764e:	00 97       	sbiw	r24, 0x00	; 0
    7650:	51 f7       	brne	.-44     	; 0x7626 <FRAMTest1Channel+0x144>
    7652:	28 c0       	rjmp	.+80     	; 0x76a4 <FRAMTest1Channel+0x1c2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7654:	6e 85       	ldd	r22, Y+14	; 0x0e
    7656:	7f 85       	ldd	r23, Y+15	; 0x0f
    7658:	88 89       	ldd	r24, Y+16	; 0x10
    765a:	99 89       	ldd	r25, Y+17	; 0x11
    765c:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    7660:	dc 01       	movw	r26, r24
    7662:	cb 01       	movw	r24, r22
    7664:	8a 8b       	std	Y+18, r24	; 0x12
    7666:	9b 8b       	std	Y+19, r25	; 0x13
    7668:	8a 89       	ldd	r24, Y+18	; 0x12
    766a:	9b 89       	ldd	r25, Y+19	; 0x13
    766c:	8e 8b       	std	Y+22, r24	; 0x16
    766e:	9f 8b       	std	Y+23, r25	; 0x17
    7670:	8e 89       	ldd	r24, Y+22	; 0x16
    7672:	9f 89       	ldd	r25, Y+23	; 0x17
    7674:	8c 01       	movw	r16, r24
    7676:	c8 01       	movw	r24, r16
    7678:	01 97       	sbiw	r24, 0x01	; 1
    767a:	f1 f7       	brne	.-4      	; 0x7678 <FRAMTest1Channel+0x196>
    767c:	8c 01       	movw	r16, r24
    767e:	0e 8b       	std	Y+22, r16	; 0x16
    7680:	1f 8b       	std	Y+23, r17	; 0x17
    7682:	10 c0       	rjmp	.+32     	; 0x76a4 <FRAMTest1Channel+0x1c2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7684:	6d 81       	ldd	r22, Y+5	; 0x05
    7686:	7e 81       	ldd	r23, Y+6	; 0x06
    7688:	8f 81       	ldd	r24, Y+7	; 0x07
    768a:	98 85       	ldd	r25, Y+8	; 0x08
    768c:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    7690:	dc 01       	movw	r26, r24
    7692:	cb 01       	movw	r24, r22
    7694:	89 87       	std	Y+9, r24	; 0x09
    7696:	89 85       	ldd	r24, Y+9	; 0x09
    7698:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    769a:	88 8d       	ldd	r24, Y+24	; 0x18
    769c:	18 2f       	mov	r17, r24
    769e:	1a 95       	dec	r17
    76a0:	f1 f7       	brne	.-4      	; 0x769e <FRAMTest1Channel+0x1bc>
    76a2:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    76a4:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <calcChecksumFRAM>

	ADCPower(FALSE);
    76a8:	80 e0       	ldi	r24, 0x00	; 0
    76aa:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>

}
    76ae:	68 96       	adiw	r28, 0x18	; 24
    76b0:	cd bf       	out	0x3d, r28	; 61
    76b2:	de bf       	out	0x3e, r29	; 62
    76b4:	df 91       	pop	r29
    76b6:	cf 91       	pop	r28
    76b8:	1f 91       	pop	r17
    76ba:	0f 91       	pop	r16
    76bc:	08 95       	ret

000076be <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
    76be:	0f 93       	push	r16
    76c0:	1f 93       	push	r17
    76c2:	cf 93       	push	r28
    76c4:	df 93       	push	r29
    76c6:	cd b7       	in	r28, 0x3d	; 61
    76c8:	de b7       	in	r29, 0x3e	; 62
    76ca:	68 97       	sbiw	r28, 0x18	; 24
    76cc:	cd bf       	out	0x3d, r28	; 61
    76ce:	de bf       	out	0x3e, r29	; 62
	FRAMWriteKnowns();
    76d0:	0e 94 c2 19 	call	0x3384	; 0x3384 <FRAMWriteKnowns>
	ADCPower(TRUE);
    76d4:	81 e0       	ldi	r24, 0x01	; 1
    76d6:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
    76da:	80 e0       	ldi	r24, 0x00	; 0
    76dc:	90 e0       	ldi	r25, 0x00	; 0
    76de:	aa e7       	ldi	r26, 0x7A	; 122
    76e0:	b3 e4       	ldi	r27, 0x43	; 67
    76e2:	89 83       	std	Y+1, r24	; 0x01
    76e4:	9a 83       	std	Y+2, r25	; 0x02
    76e6:	ab 83       	std	Y+3, r26	; 0x03
    76e8:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    76ea:	69 81       	ldd	r22, Y+1	; 0x01
    76ec:	7a 81       	ldd	r23, Y+2	; 0x02
    76ee:	8b 81       	ldd	r24, Y+3	; 0x03
    76f0:	9c 81       	ldd	r25, Y+4	; 0x04
    76f2:	2b ea       	ldi	r18, 0xAB	; 171
    76f4:	3a ea       	ldi	r19, 0xAA	; 170
    76f6:	4a e2       	ldi	r20, 0x2A	; 42
    76f8:	51 e4       	ldi	r21, 0x41	; 65
    76fa:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    76fe:	dc 01       	movw	r26, r24
    7700:	cb 01       	movw	r24, r22
    7702:	8d 83       	std	Y+5, r24	; 0x05
    7704:	9e 83       	std	Y+6, r25	; 0x06
    7706:	af 83       	std	Y+7, r26	; 0x07
    7708:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    770a:	11 e0       	ldi	r17, 0x01	; 1
    770c:	6d 81       	ldd	r22, Y+5	; 0x05
    770e:	7e 81       	ldd	r23, Y+6	; 0x06
    7710:	8f 81       	ldd	r24, Y+7	; 0x07
    7712:	98 85       	ldd	r25, Y+8	; 0x08
    7714:	20 e0       	ldi	r18, 0x00	; 0
    7716:	30 e0       	ldi	r19, 0x00	; 0
    7718:	40 e8       	ldi	r20, 0x80	; 128
    771a:	5f e3       	ldi	r21, 0x3F	; 63
    771c:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    7720:	88 23       	and	r24, r24
    7722:	0c f0       	brlt	.+2      	; 0x7726 <FRAMWriteKnownsCheck+0x68>
    7724:	10 e0       	ldi	r17, 0x00	; 0
    7726:	11 23       	and	r17, r17
    7728:	19 f0       	breq	.+6      	; 0x7730 <FRAMWriteKnownsCheck+0x72>
		__ticks = 1;
    772a:	81 e0       	ldi	r24, 0x01	; 1
    772c:	89 87       	std	Y+9, r24	; 0x09
    772e:	a3 c0       	rjmp	.+326    	; 0x7876 <FRAMWriteKnownsCheck+0x1b8>
	else if (__tmp > 255)
    7730:	11 e0       	ldi	r17, 0x01	; 1
    7732:	6d 81       	ldd	r22, Y+5	; 0x05
    7734:	7e 81       	ldd	r23, Y+6	; 0x06
    7736:	8f 81       	ldd	r24, Y+7	; 0x07
    7738:	98 85       	ldd	r25, Y+8	; 0x08
    773a:	20 e0       	ldi	r18, 0x00	; 0
    773c:	30 e0       	ldi	r19, 0x00	; 0
    773e:	4f e7       	ldi	r20, 0x7F	; 127
    7740:	53 e4       	ldi	r21, 0x43	; 67
    7742:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    7746:	18 16       	cp	r1, r24
    7748:	0c f0       	brlt	.+2      	; 0x774c <FRAMWriteKnownsCheck+0x8e>
    774a:	10 e0       	ldi	r17, 0x00	; 0
    774c:	11 23       	and	r17, r17
    774e:	09 f4       	brne	.+2      	; 0x7752 <FRAMWriteKnownsCheck+0x94>
    7750:	89 c0       	rjmp	.+274    	; 0x7864 <FRAMWriteKnownsCheck+0x1a6>
	{
		_delay_ms(__us / 1000.0);
    7752:	69 81       	ldd	r22, Y+1	; 0x01
    7754:	7a 81       	ldd	r23, Y+2	; 0x02
    7756:	8b 81       	ldd	r24, Y+3	; 0x03
    7758:	9c 81       	ldd	r25, Y+4	; 0x04
    775a:	20 e0       	ldi	r18, 0x00	; 0
    775c:	30 e0       	ldi	r19, 0x00	; 0
    775e:	4a e7       	ldi	r20, 0x7A	; 122
    7760:	54 e4       	ldi	r21, 0x44	; 68
    7762:	0e 94 99 61 	call	0xc332	; 0xc332 <__divsf3>
    7766:	dc 01       	movw	r26, r24
    7768:	cb 01       	movw	r24, r22
    776a:	8a 87       	std	Y+10, r24	; 0x0a
    776c:	9b 87       	std	Y+11, r25	; 0x0b
    776e:	ac 87       	std	Y+12, r26	; 0x0c
    7770:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7772:	6a 85       	ldd	r22, Y+10	; 0x0a
    7774:	7b 85       	ldd	r23, Y+11	; 0x0b
    7776:	8c 85       	ldd	r24, Y+12	; 0x0c
    7778:	9d 85       	ldd	r25, Y+13	; 0x0d
    777a:	20 e0       	ldi	r18, 0x00	; 0
    777c:	30 e0       	ldi	r19, 0x00	; 0
    777e:	4a ef       	ldi	r20, 0xFA	; 250
    7780:	55 e4       	ldi	r21, 0x45	; 69
    7782:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    7786:	dc 01       	movw	r26, r24
    7788:	cb 01       	movw	r24, r22
    778a:	8e 87       	std	Y+14, r24	; 0x0e
    778c:	9f 87       	std	Y+15, r25	; 0x0f
    778e:	a8 8b       	std	Y+16, r26	; 0x10
    7790:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    7792:	11 e0       	ldi	r17, 0x01	; 1
    7794:	6e 85       	ldd	r22, Y+14	; 0x0e
    7796:	7f 85       	ldd	r23, Y+15	; 0x0f
    7798:	88 89       	ldd	r24, Y+16	; 0x10
    779a:	99 89       	ldd	r25, Y+17	; 0x11
    779c:	20 e0       	ldi	r18, 0x00	; 0
    779e:	30 e0       	ldi	r19, 0x00	; 0
    77a0:	40 e8       	ldi	r20, 0x80	; 128
    77a2:	5f e3       	ldi	r21, 0x3F	; 63
    77a4:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    77a8:	88 23       	and	r24, r24
    77aa:	0c f0       	brlt	.+2      	; 0x77ae <FRAMWriteKnownsCheck+0xf0>
    77ac:	10 e0       	ldi	r17, 0x00	; 0
    77ae:	11 23       	and	r17, r17
    77b0:	29 f0       	breq	.+10     	; 0x77bc <FRAMWriteKnownsCheck+0xfe>
		__ticks = 1;
    77b2:	81 e0       	ldi	r24, 0x01	; 1
    77b4:	90 e0       	ldi	r25, 0x00	; 0
    77b6:	8a 8b       	std	Y+18, r24	; 0x12
    77b8:	9b 8b       	std	Y+19, r25	; 0x13
    77ba:	46 c0       	rjmp	.+140    	; 0x7848 <FRAMWriteKnownsCheck+0x18a>
	else if (__tmp > 65535)
    77bc:	11 e0       	ldi	r17, 0x01	; 1
    77be:	6e 85       	ldd	r22, Y+14	; 0x0e
    77c0:	7f 85       	ldd	r23, Y+15	; 0x0f
    77c2:	88 89       	ldd	r24, Y+16	; 0x10
    77c4:	99 89       	ldd	r25, Y+17	; 0x11
    77c6:	20 e0       	ldi	r18, 0x00	; 0
    77c8:	3f ef       	ldi	r19, 0xFF	; 255
    77ca:	4f e7       	ldi	r20, 0x7F	; 127
    77cc:	57 e4       	ldi	r21, 0x47	; 71
    77ce:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    77d2:	18 16       	cp	r1, r24
    77d4:	0c f0       	brlt	.+2      	; 0x77d8 <FRAMWriteKnownsCheck+0x11a>
    77d6:	10 e0       	ldi	r17, 0x00	; 0
    77d8:	11 23       	and	r17, r17
    77da:	61 f1       	breq	.+88     	; 0x7834 <FRAMWriteKnownsCheck+0x176>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    77dc:	6a 85       	ldd	r22, Y+10	; 0x0a
    77de:	7b 85       	ldd	r23, Y+11	; 0x0b
    77e0:	8c 85       	ldd	r24, Y+12	; 0x0c
    77e2:	9d 85       	ldd	r25, Y+13	; 0x0d
    77e4:	20 e0       	ldi	r18, 0x00	; 0
    77e6:	30 e0       	ldi	r19, 0x00	; 0
    77e8:	40 e2       	ldi	r20, 0x20	; 32
    77ea:	51 e4       	ldi	r21, 0x41	; 65
    77ec:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    77f0:	dc 01       	movw	r26, r24
    77f2:	cb 01       	movw	r24, r22
    77f4:	bc 01       	movw	r22, r24
    77f6:	cd 01       	movw	r24, r26
    77f8:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    77fc:	dc 01       	movw	r26, r24
    77fe:	cb 01       	movw	r24, r22
    7800:	8a 8b       	std	Y+18, r24	; 0x12
    7802:	9b 8b       	std	Y+19, r25	; 0x13
    7804:	12 c0       	rjmp	.+36     	; 0x782a <FRAMWriteKnownsCheck+0x16c>
    7806:	80 e2       	ldi	r24, 0x20	; 32
    7808:	93 e0       	ldi	r25, 0x03	; 3
    780a:	8c 8b       	std	Y+20, r24	; 0x14
    780c:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    780e:	8c 89       	ldd	r24, Y+20	; 0x14
    7810:	9d 89       	ldd	r25, Y+21	; 0x15
    7812:	8c 01       	movw	r16, r24
    7814:	c8 01       	movw	r24, r16
    7816:	01 97       	sbiw	r24, 0x01	; 1
    7818:	f1 f7       	brne	.-4      	; 0x7816 <FRAMWriteKnownsCheck+0x158>
    781a:	8c 01       	movw	r16, r24
    781c:	0c 8b       	std	Y+20, r16	; 0x14
    781e:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7820:	8a 89       	ldd	r24, Y+18	; 0x12
    7822:	9b 89       	ldd	r25, Y+19	; 0x13
    7824:	01 97       	sbiw	r24, 0x01	; 1
    7826:	8a 8b       	std	Y+18, r24	; 0x12
    7828:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    782a:	8a 89       	ldd	r24, Y+18	; 0x12
    782c:	9b 89       	ldd	r25, Y+19	; 0x13
    782e:	00 97       	sbiw	r24, 0x00	; 0
    7830:	51 f7       	brne	.-44     	; 0x7806 <FRAMWriteKnownsCheck+0x148>
    7832:	28 c0       	rjmp	.+80     	; 0x7884 <FRAMWriteKnownsCheck+0x1c6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7834:	6e 85       	ldd	r22, Y+14	; 0x0e
    7836:	7f 85       	ldd	r23, Y+15	; 0x0f
    7838:	88 89       	ldd	r24, Y+16	; 0x10
    783a:	99 89       	ldd	r25, Y+17	; 0x11
    783c:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    7840:	dc 01       	movw	r26, r24
    7842:	cb 01       	movw	r24, r22
    7844:	8a 8b       	std	Y+18, r24	; 0x12
    7846:	9b 8b       	std	Y+19, r25	; 0x13
    7848:	8a 89       	ldd	r24, Y+18	; 0x12
    784a:	9b 89       	ldd	r25, Y+19	; 0x13
    784c:	8e 8b       	std	Y+22, r24	; 0x16
    784e:	9f 8b       	std	Y+23, r25	; 0x17
    7850:	8e 89       	ldd	r24, Y+22	; 0x16
    7852:	9f 89       	ldd	r25, Y+23	; 0x17
    7854:	8c 01       	movw	r16, r24
    7856:	c8 01       	movw	r24, r16
    7858:	01 97       	sbiw	r24, 0x01	; 1
    785a:	f1 f7       	brne	.-4      	; 0x7858 <FRAMWriteKnownsCheck+0x19a>
    785c:	8c 01       	movw	r16, r24
    785e:	0e 8b       	std	Y+22, r16	; 0x16
    7860:	1f 8b       	std	Y+23, r17	; 0x17
    7862:	10 c0       	rjmp	.+32     	; 0x7884 <FRAMWriteKnownsCheck+0x1c6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7864:	6d 81       	ldd	r22, Y+5	; 0x05
    7866:	7e 81       	ldd	r23, Y+6	; 0x06
    7868:	8f 81       	ldd	r24, Y+7	; 0x07
    786a:	98 85       	ldd	r25, Y+8	; 0x08
    786c:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    7870:	dc 01       	movw	r26, r24
    7872:	cb 01       	movw	r24, r22
    7874:	89 87       	std	Y+9, r24	; 0x09
    7876:	89 85       	ldd	r24, Y+9	; 0x09
    7878:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    787a:	88 8d       	ldd	r24, Y+24	; 0x18
    787c:	18 2f       	mov	r17, r24
    787e:	1a 95       	dec	r17
    7880:	f1 f7       	brne	.-4      	; 0x787e <FRAMWriteKnownsCheck+0x1c0>
    7882:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(250);
	calcChecksumFRAM();
    7884:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <calcChecksumFRAM>

	ADCPower(FALSE);
    7888:	80 e0       	ldi	r24, 0x00	; 0
    788a:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>

}
    788e:	68 96       	adiw	r28, 0x18	; 24
    7890:	cd bf       	out	0x3d, r28	; 61
    7892:	de bf       	out	0x3e, r29	; 62
    7894:	df 91       	pop	r29
    7896:	cf 91       	pop	r28
    7898:	1f 91       	pop	r17
    789a:	0f 91       	pop	r16
    789c:	08 95       	ret

0000789e <checkMote>:

//random function for testing stuff	
void checkMote(){
    789e:	0f 93       	push	r16
    78a0:	1f 93       	push	r17
    78a2:	cf 93       	push	r28
    78a4:	df 93       	push	r29
    78a6:	cd b7       	in	r28, 0x3d	; 61
    78a8:	de b7       	in	r29, 0x3e	; 62
    78aa:	aa 97       	sbiw	r28, 0x2a	; 42
    78ac:	cd bf       	out	0x3d, r28	; 61
    78ae:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);
    78b0:	81 e0       	ldi	r24, 0x01	; 1
    78b2:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	Ext1Power(TRUE);
    78b6:	81 e0       	ldi	r24, 0x01	; 1
    78b8:	0e 94 3e 35 	call	0x6a7c	; 0x6a7c <Ext1Power>
    78bc:	80 e0       	ldi	r24, 0x00	; 0
    78be:	90 e0       	ldi	r25, 0x00	; 0
    78c0:	a8 ec       	ldi	r26, 0xC8	; 200
    78c2:	b2 e4       	ldi	r27, 0x42	; 66
    78c4:	89 83       	std	Y+1, r24	; 0x01
    78c6:	9a 83       	std	Y+2, r25	; 0x02
    78c8:	ab 83       	std	Y+3, r26	; 0x03
    78ca:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    78cc:	69 81       	ldd	r22, Y+1	; 0x01
    78ce:	7a 81       	ldd	r23, Y+2	; 0x02
    78d0:	8b 81       	ldd	r24, Y+3	; 0x03
    78d2:	9c 81       	ldd	r25, Y+4	; 0x04
    78d4:	20 e0       	ldi	r18, 0x00	; 0
    78d6:	30 e0       	ldi	r19, 0x00	; 0
    78d8:	4a ef       	ldi	r20, 0xFA	; 250
    78da:	55 e4       	ldi	r21, 0x45	; 69
    78dc:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    78e0:	dc 01       	movw	r26, r24
    78e2:	cb 01       	movw	r24, r22
    78e4:	8d 83       	std	Y+5, r24	; 0x05
    78e6:	9e 83       	std	Y+6, r25	; 0x06
    78e8:	af 83       	std	Y+7, r26	; 0x07
    78ea:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    78ec:	11 e0       	ldi	r17, 0x01	; 1
    78ee:	6d 81       	ldd	r22, Y+5	; 0x05
    78f0:	7e 81       	ldd	r23, Y+6	; 0x06
    78f2:	8f 81       	ldd	r24, Y+7	; 0x07
    78f4:	98 85       	ldd	r25, Y+8	; 0x08
    78f6:	20 e0       	ldi	r18, 0x00	; 0
    78f8:	30 e0       	ldi	r19, 0x00	; 0
    78fa:	40 e8       	ldi	r20, 0x80	; 128
    78fc:	5f e3       	ldi	r21, 0x3F	; 63
    78fe:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    7902:	88 23       	and	r24, r24
    7904:	0c f0       	brlt	.+2      	; 0x7908 <checkMote+0x6a>
    7906:	10 e0       	ldi	r17, 0x00	; 0
    7908:	11 23       	and	r17, r17
    790a:	29 f0       	breq	.+10     	; 0x7916 <checkMote+0x78>
		__ticks = 1;
    790c:	81 e0       	ldi	r24, 0x01	; 1
    790e:	90 e0       	ldi	r25, 0x00	; 0
    7910:	89 87       	std	Y+9, r24	; 0x09
    7912:	9a 87       	std	Y+10, r25	; 0x0a
    7914:	46 c0       	rjmp	.+140    	; 0x79a2 <checkMote+0x104>
	else if (__tmp > 65535)
    7916:	11 e0       	ldi	r17, 0x01	; 1
    7918:	6d 81       	ldd	r22, Y+5	; 0x05
    791a:	7e 81       	ldd	r23, Y+6	; 0x06
    791c:	8f 81       	ldd	r24, Y+7	; 0x07
    791e:	98 85       	ldd	r25, Y+8	; 0x08
    7920:	20 e0       	ldi	r18, 0x00	; 0
    7922:	3f ef       	ldi	r19, 0xFF	; 255
    7924:	4f e7       	ldi	r20, 0x7F	; 127
    7926:	57 e4       	ldi	r21, 0x47	; 71
    7928:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    792c:	18 16       	cp	r1, r24
    792e:	0c f0       	brlt	.+2      	; 0x7932 <checkMote+0x94>
    7930:	10 e0       	ldi	r17, 0x00	; 0
    7932:	11 23       	and	r17, r17
    7934:	61 f1       	breq	.+88     	; 0x798e <checkMote+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7936:	69 81       	ldd	r22, Y+1	; 0x01
    7938:	7a 81       	ldd	r23, Y+2	; 0x02
    793a:	8b 81       	ldd	r24, Y+3	; 0x03
    793c:	9c 81       	ldd	r25, Y+4	; 0x04
    793e:	20 e0       	ldi	r18, 0x00	; 0
    7940:	30 e0       	ldi	r19, 0x00	; 0
    7942:	40 e2       	ldi	r20, 0x20	; 32
    7944:	51 e4       	ldi	r21, 0x41	; 65
    7946:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    794a:	dc 01       	movw	r26, r24
    794c:	cb 01       	movw	r24, r22
    794e:	bc 01       	movw	r22, r24
    7950:	cd 01       	movw	r24, r26
    7952:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    7956:	dc 01       	movw	r26, r24
    7958:	cb 01       	movw	r24, r22
    795a:	89 87       	std	Y+9, r24	; 0x09
    795c:	9a 87       	std	Y+10, r25	; 0x0a
    795e:	12 c0       	rjmp	.+36     	; 0x7984 <checkMote+0xe6>
    7960:	80 e2       	ldi	r24, 0x20	; 32
    7962:	93 e0       	ldi	r25, 0x03	; 3
    7964:	8b 87       	std	Y+11, r24	; 0x0b
    7966:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7968:	8b 85       	ldd	r24, Y+11	; 0x0b
    796a:	9c 85       	ldd	r25, Y+12	; 0x0c
    796c:	8c 01       	movw	r16, r24
    796e:	c8 01       	movw	r24, r16
    7970:	01 97       	sbiw	r24, 0x01	; 1
    7972:	f1 f7       	brne	.-4      	; 0x7970 <checkMote+0xd2>
    7974:	8c 01       	movw	r16, r24
    7976:	0b 87       	std	Y+11, r16	; 0x0b
    7978:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    797a:	89 85       	ldd	r24, Y+9	; 0x09
    797c:	9a 85       	ldd	r25, Y+10	; 0x0a
    797e:	01 97       	sbiw	r24, 0x01	; 1
    7980:	89 87       	std	Y+9, r24	; 0x09
    7982:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7984:	89 85       	ldd	r24, Y+9	; 0x09
    7986:	9a 85       	ldd	r25, Y+10	; 0x0a
    7988:	00 97       	sbiw	r24, 0x00	; 0
    798a:	51 f7       	brne	.-44     	; 0x7960 <checkMote+0xc2>
    798c:	17 c0       	rjmp	.+46     	; 0x79bc <checkMote+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    798e:	6d 81       	ldd	r22, Y+5	; 0x05
    7990:	7e 81       	ldd	r23, Y+6	; 0x06
    7992:	8f 81       	ldd	r24, Y+7	; 0x07
    7994:	98 85       	ldd	r25, Y+8	; 0x08
    7996:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    799a:	dc 01       	movw	r26, r24
    799c:	cb 01       	movw	r24, r22
    799e:	89 87       	std	Y+9, r24	; 0x09
    79a0:	9a 87       	std	Y+10, r25	; 0x0a
    79a2:	89 85       	ldd	r24, Y+9	; 0x09
    79a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    79a6:	8d 87       	std	Y+13, r24	; 0x0d
    79a8:	9e 87       	std	Y+14, r25	; 0x0e
    79aa:	8d 85       	ldd	r24, Y+13	; 0x0d
    79ac:	9e 85       	ldd	r25, Y+14	; 0x0e
    79ae:	8c 01       	movw	r16, r24
    79b0:	c8 01       	movw	r24, r16
    79b2:	01 97       	sbiw	r24, 0x01	; 1
    79b4:	f1 f7       	brne	.-4      	; 0x79b2 <checkMote+0x114>
    79b6:	8c 01       	movw	r16, r24
    79b8:	0d 87       	std	Y+13, r16	; 0x0d
    79ba:	1e 87       	std	Y+14, r17	; 0x0e
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    79bc:	88 e0       	ldi	r24, 0x08	; 8
    79be:	60 e0       	ldi	r22, 0x00	; 0
    79c0:	0e 94 a8 33 	call	0x6750	; 0x6750 <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    79c4:	88 e0       	ldi	r24, 0x08	; 8
    79c6:	60 e0       	ldi	r22, 0x00	; 0
    79c8:	0e 94 74 34 	call	0x68e8	; 0x68e8 <PortEx_OUTSET>
    79cc:	80 e0       	ldi	r24, 0x00	; 0
    79ce:	90 e4       	ldi	r25, 0x40	; 64
    79d0:	ac e9       	ldi	r26, 0x9C	; 156
    79d2:	b5 e4       	ldi	r27, 0x45	; 69
    79d4:	8f 87       	std	Y+15, r24	; 0x0f
    79d6:	98 8b       	std	Y+16, r25	; 0x10
    79d8:	a9 8b       	std	Y+17, r26	; 0x11
    79da:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    79dc:	6f 85       	ldd	r22, Y+15	; 0x0f
    79de:	78 89       	ldd	r23, Y+16	; 0x10
    79e0:	89 89       	ldd	r24, Y+17	; 0x11
    79e2:	9a 89       	ldd	r25, Y+18	; 0x12
    79e4:	20 e0       	ldi	r18, 0x00	; 0
    79e6:	30 e0       	ldi	r19, 0x00	; 0
    79e8:	4a ef       	ldi	r20, 0xFA	; 250
    79ea:	55 e4       	ldi	r21, 0x45	; 69
    79ec:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    79f0:	dc 01       	movw	r26, r24
    79f2:	cb 01       	movw	r24, r22
    79f4:	8b 8b       	std	Y+19, r24	; 0x13
    79f6:	9c 8b       	std	Y+20, r25	; 0x14
    79f8:	ad 8b       	std	Y+21, r26	; 0x15
    79fa:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    79fc:	11 e0       	ldi	r17, 0x01	; 1
    79fe:	6b 89       	ldd	r22, Y+19	; 0x13
    7a00:	7c 89       	ldd	r23, Y+20	; 0x14
    7a02:	8d 89       	ldd	r24, Y+21	; 0x15
    7a04:	9e 89       	ldd	r25, Y+22	; 0x16
    7a06:	20 e0       	ldi	r18, 0x00	; 0
    7a08:	30 e0       	ldi	r19, 0x00	; 0
    7a0a:	40 e8       	ldi	r20, 0x80	; 128
    7a0c:	5f e3       	ldi	r21, 0x3F	; 63
    7a0e:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    7a12:	88 23       	and	r24, r24
    7a14:	0c f0       	brlt	.+2      	; 0x7a18 <checkMote+0x17a>
    7a16:	10 e0       	ldi	r17, 0x00	; 0
    7a18:	11 23       	and	r17, r17
    7a1a:	29 f0       	breq	.+10     	; 0x7a26 <checkMote+0x188>
		__ticks = 1;
    7a1c:	81 e0       	ldi	r24, 0x01	; 1
    7a1e:	90 e0       	ldi	r25, 0x00	; 0
    7a20:	8f 8b       	std	Y+23, r24	; 0x17
    7a22:	98 8f       	std	Y+24, r25	; 0x18
    7a24:	46 c0       	rjmp	.+140    	; 0x7ab2 <checkMote+0x214>
	else if (__tmp > 65535)
    7a26:	11 e0       	ldi	r17, 0x01	; 1
    7a28:	6b 89       	ldd	r22, Y+19	; 0x13
    7a2a:	7c 89       	ldd	r23, Y+20	; 0x14
    7a2c:	8d 89       	ldd	r24, Y+21	; 0x15
    7a2e:	9e 89       	ldd	r25, Y+22	; 0x16
    7a30:	20 e0       	ldi	r18, 0x00	; 0
    7a32:	3f ef       	ldi	r19, 0xFF	; 255
    7a34:	4f e7       	ldi	r20, 0x7F	; 127
    7a36:	57 e4       	ldi	r21, 0x47	; 71
    7a38:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    7a3c:	18 16       	cp	r1, r24
    7a3e:	0c f0       	brlt	.+2      	; 0x7a42 <checkMote+0x1a4>
    7a40:	10 e0       	ldi	r17, 0x00	; 0
    7a42:	11 23       	and	r17, r17
    7a44:	61 f1       	breq	.+88     	; 0x7a9e <checkMote+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7a46:	6f 85       	ldd	r22, Y+15	; 0x0f
    7a48:	78 89       	ldd	r23, Y+16	; 0x10
    7a4a:	89 89       	ldd	r24, Y+17	; 0x11
    7a4c:	9a 89       	ldd	r25, Y+18	; 0x12
    7a4e:	20 e0       	ldi	r18, 0x00	; 0
    7a50:	30 e0       	ldi	r19, 0x00	; 0
    7a52:	40 e2       	ldi	r20, 0x20	; 32
    7a54:	51 e4       	ldi	r21, 0x41	; 65
    7a56:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    7a5a:	dc 01       	movw	r26, r24
    7a5c:	cb 01       	movw	r24, r22
    7a5e:	bc 01       	movw	r22, r24
    7a60:	cd 01       	movw	r24, r26
    7a62:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    7a66:	dc 01       	movw	r26, r24
    7a68:	cb 01       	movw	r24, r22
    7a6a:	8f 8b       	std	Y+23, r24	; 0x17
    7a6c:	98 8f       	std	Y+24, r25	; 0x18
    7a6e:	12 c0       	rjmp	.+36     	; 0x7a94 <checkMote+0x1f6>
    7a70:	80 e2       	ldi	r24, 0x20	; 32
    7a72:	93 e0       	ldi	r25, 0x03	; 3
    7a74:	89 8f       	std	Y+25, r24	; 0x19
    7a76:	9a 8f       	std	Y+26, r25	; 0x1a
    7a78:	89 8d       	ldd	r24, Y+25	; 0x19
    7a7a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    7a7c:	8c 01       	movw	r16, r24
    7a7e:	c8 01       	movw	r24, r16
    7a80:	01 97       	sbiw	r24, 0x01	; 1
    7a82:	f1 f7       	brne	.-4      	; 0x7a80 <checkMote+0x1e2>
    7a84:	8c 01       	movw	r16, r24
    7a86:	09 8f       	std	Y+25, r16	; 0x19
    7a88:	1a 8f       	std	Y+26, r17	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7a8a:	8f 89       	ldd	r24, Y+23	; 0x17
    7a8c:	98 8d       	ldd	r25, Y+24	; 0x18
    7a8e:	01 97       	sbiw	r24, 0x01	; 1
    7a90:	8f 8b       	std	Y+23, r24	; 0x17
    7a92:	98 8f       	std	Y+24, r25	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7a94:	8f 89       	ldd	r24, Y+23	; 0x17
    7a96:	98 8d       	ldd	r25, Y+24	; 0x18
    7a98:	00 97       	sbiw	r24, 0x00	; 0
    7a9a:	51 f7       	brne	.-44     	; 0x7a70 <checkMote+0x1d2>
    7a9c:	17 c0       	rjmp	.+46     	; 0x7acc <checkMote+0x22e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7a9e:	6b 89       	ldd	r22, Y+19	; 0x13
    7aa0:	7c 89       	ldd	r23, Y+20	; 0x14
    7aa2:	8d 89       	ldd	r24, Y+21	; 0x15
    7aa4:	9e 89       	ldd	r25, Y+22	; 0x16
    7aa6:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    7aaa:	dc 01       	movw	r26, r24
    7aac:	cb 01       	movw	r24, r22
    7aae:	8f 8b       	std	Y+23, r24	; 0x17
    7ab0:	98 8f       	std	Y+24, r25	; 0x18
    7ab2:	8f 89       	ldd	r24, Y+23	; 0x17
    7ab4:	98 8d       	ldd	r25, Y+24	; 0x18
    7ab6:	8b 8f       	std	Y+27, r24	; 0x1b
    7ab8:	9c 8f       	std	Y+28, r25	; 0x1c
    7aba:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7abc:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7abe:	8c 01       	movw	r16, r24
    7ac0:	c8 01       	movw	r24, r16
    7ac2:	01 97       	sbiw	r24, 0x01	; 1
    7ac4:	f1 f7       	brne	.-4      	; 0x7ac2 <checkMote+0x224>
    7ac6:	8c 01       	movw	r16, r24
    7ac8:	0b 8f       	std	Y+27, r16	; 0x1b
    7aca:	1c 8f       	std	Y+28, r17	; 0x1c
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    7acc:	88 e0       	ldi	r24, 0x08	; 8
    7ace:	60 e0       	ldi	r22, 0x00	; 0
    7ad0:	0e 94 d7 34 	call	0x69ae	; 0x69ae <PortEx_OUTCLR>
    7ad4:	80 e0       	ldi	r24, 0x00	; 0
    7ad6:	90 e4       	ldi	r25, 0x40	; 64
    7ad8:	ac e9       	ldi	r26, 0x9C	; 156
    7ada:	b5 e4       	ldi	r27, 0x45	; 69
    7adc:	8d 8f       	std	Y+29, r24	; 0x1d
    7ade:	9e 8f       	std	Y+30, r25	; 0x1e
    7ae0:	af 8f       	std	Y+31, r26	; 0x1f
    7ae2:	b8 a3       	lds	r27, 0x58
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7ae4:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7ae6:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7ae8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7aea:	98 a1       	lds	r25, 0x48
    7aec:	20 e0       	ldi	r18, 0x00	; 0
    7aee:	30 e0       	ldi	r19, 0x00	; 0
    7af0:	4a ef       	ldi	r20, 0xFA	; 250
    7af2:	55 e4       	ldi	r21, 0x45	; 69
    7af4:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    7af8:	dc 01       	movw	r26, r24
    7afa:	cb 01       	movw	r24, r22
    7afc:	89 a3       	lds	r24, 0x59
    7afe:	9a a3       	lds	r25, 0x5a
    7b00:	ab a3       	lds	r26, 0x5b
    7b02:	bc a3       	lds	r27, 0x5c
	if (__tmp < 1.0)
    7b04:	11 e0       	ldi	r17, 0x01	; 1
    7b06:	69 a1       	lds	r22, 0x49
    7b08:	7a a1       	lds	r23, 0x4a
    7b0a:	8b a1       	lds	r24, 0x4b
    7b0c:	9c a1       	lds	r25, 0x4c
    7b0e:	20 e0       	ldi	r18, 0x00	; 0
    7b10:	30 e0       	ldi	r19, 0x00	; 0
    7b12:	40 e8       	ldi	r20, 0x80	; 128
    7b14:	5f e3       	ldi	r21, 0x3F	; 63
    7b16:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    7b1a:	88 23       	and	r24, r24
    7b1c:	0c f0       	brlt	.+2      	; 0x7b20 <checkMote+0x282>
    7b1e:	10 e0       	ldi	r17, 0x00	; 0
    7b20:	11 23       	and	r17, r17
    7b22:	29 f0       	breq	.+10     	; 0x7b2e <checkMote+0x290>
		__ticks = 1;
    7b24:	81 e0       	ldi	r24, 0x01	; 1
    7b26:	90 e0       	ldi	r25, 0x00	; 0
    7b28:	8d a3       	lds	r24, 0x5d
    7b2a:	9e a3       	lds	r25, 0x5e
    7b2c:	46 c0       	rjmp	.+140    	; 0x7bba <checkMote+0x31c>
	else if (__tmp > 65535)
    7b2e:	11 e0       	ldi	r17, 0x01	; 1
    7b30:	69 a1       	lds	r22, 0x49
    7b32:	7a a1       	lds	r23, 0x4a
    7b34:	8b a1       	lds	r24, 0x4b
    7b36:	9c a1       	lds	r25, 0x4c
    7b38:	20 e0       	ldi	r18, 0x00	; 0
    7b3a:	3f ef       	ldi	r19, 0xFF	; 255
    7b3c:	4f e7       	ldi	r20, 0x7F	; 127
    7b3e:	57 e4       	ldi	r21, 0x47	; 71
    7b40:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    7b44:	18 16       	cp	r1, r24
    7b46:	0c f0       	brlt	.+2      	; 0x7b4a <checkMote+0x2ac>
    7b48:	10 e0       	ldi	r17, 0x00	; 0
    7b4a:	11 23       	and	r17, r17
    7b4c:	61 f1       	breq	.+88     	; 0x7ba6 <checkMote+0x308>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7b4e:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7b50:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7b52:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7b54:	98 a1       	lds	r25, 0x48
    7b56:	20 e0       	ldi	r18, 0x00	; 0
    7b58:	30 e0       	ldi	r19, 0x00	; 0
    7b5a:	40 e2       	ldi	r20, 0x20	; 32
    7b5c:	51 e4       	ldi	r21, 0x41	; 65
    7b5e:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    7b62:	dc 01       	movw	r26, r24
    7b64:	cb 01       	movw	r24, r22
    7b66:	bc 01       	movw	r22, r24
    7b68:	cd 01       	movw	r24, r26
    7b6a:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    7b6e:	dc 01       	movw	r26, r24
    7b70:	cb 01       	movw	r24, r22
    7b72:	8d a3       	lds	r24, 0x5d
    7b74:	9e a3       	lds	r25, 0x5e
    7b76:	12 c0       	rjmp	.+36     	; 0x7b9c <checkMote+0x2fe>
    7b78:	80 e2       	ldi	r24, 0x20	; 32
    7b7a:	93 e0       	ldi	r25, 0x03	; 3
    7b7c:	8f a3       	lds	r24, 0x5f
    7b7e:	98 a7       	lds	r25, 0x78
    7b80:	8f a1       	lds	r24, 0x4f
    7b82:	98 a5       	lds	r25, 0x68
    7b84:	8c 01       	movw	r16, r24
    7b86:	c8 01       	movw	r24, r16
    7b88:	01 97       	sbiw	r24, 0x01	; 1
    7b8a:	f1 f7       	brne	.-4      	; 0x7b88 <checkMote+0x2ea>
    7b8c:	8c 01       	movw	r16, r24
    7b8e:	0f a3       	lds	r16, 0x5f
    7b90:	18 a7       	lds	r17, 0x78
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7b92:	8d a1       	lds	r24, 0x4d
    7b94:	9e a1       	lds	r25, 0x4e
    7b96:	01 97       	sbiw	r24, 0x01	; 1
    7b98:	8d a3       	lds	r24, 0x5d
    7b9a:	9e a3       	lds	r25, 0x5e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7b9c:	8d a1       	lds	r24, 0x4d
    7b9e:	9e a1       	lds	r25, 0x4e
    7ba0:	00 97       	sbiw	r24, 0x00	; 0
    7ba2:	51 f7       	brne	.-44     	; 0x7b78 <checkMote+0x2da>
    7ba4:	18 c0       	rjmp	.+48     	; 0x7bd6 <checkMote+0x338>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7ba6:	69 a1       	lds	r22, 0x49
    7ba8:	7a a1       	lds	r23, 0x4a
    7baa:	8b a1       	lds	r24, 0x4b
    7bac:	9c a1       	lds	r25, 0x4c
    7bae:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    7bb2:	dc 01       	movw	r26, r24
    7bb4:	cb 01       	movw	r24, r22
    7bb6:	8d a3       	lds	r24, 0x5d
    7bb8:	9e a3       	lds	r25, 0x5e
    7bba:	8d a1       	lds	r24, 0x4d
    7bbc:	9e a1       	lds	r25, 0x4e
    7bbe:	89 a7       	lds	r24, 0x79
    7bc0:	9a a7       	lds	r25, 0x7a
    7bc2:	89 a5       	lds	r24, 0x69
    7bc4:	9a a5       	lds	r25, 0x6a
    7bc6:	8c 01       	movw	r16, r24
    7bc8:	c8 01       	movw	r24, r16
    7bca:	01 97       	sbiw	r24, 0x01	; 1
    7bcc:	f1 f7       	brne	.-4      	; 0x7bca <checkMote+0x32c>
    7bce:	8c 01       	movw	r16, r24
    7bd0:	09 a7       	lds	r16, 0x79
    7bd2:	1a a7       	lds	r17, 0x7a
		_delay_ms(5000);
	}
    7bd4:	f7 ce       	rjmp	.-530    	; 0x79c4 <checkMote+0x126>
    7bd6:	f6 ce       	rjmp	.-532    	; 0x79c4 <checkMote+0x126>

00007bd8 <SD_write_and_read_knowns>:
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    7bd8:	cf 93       	push	r28
    7bda:	df 93       	push	r29
    7bdc:	cd b7       	in	r28, 0x3d	; 61
    7bde:	de b7       	in	r29, 0x3e	; 62
    7be0:	28 97       	sbiw	r28, 0x08	; 8
    7be2:	cd bf       	out	0x3d, r28	; 61
    7be4:	de bf       	out	0x3e, r29	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7be6:	19 82       	std	Y+1, r1	; 0x01
    7be8:	1a 82       	std	Y+2, r1	; 0x02
    7bea:	0c c0       	rjmp	.+24     	; 0x7c04 <SD_write_and_read_knowns+0x2c>
    7bec:	29 81       	ldd	r18, Y+1	; 0x01
    7bee:	89 81       	ldd	r24, Y+1	; 0x01
    7bf0:	9a 81       	ldd	r25, Y+2	; 0x02
    7bf2:	84 53       	subi	r24, 0x34	; 52
    7bf4:	9c 4d       	sbci	r25, 0xDC	; 220
    7bf6:	fc 01       	movw	r30, r24
    7bf8:	20 83       	st	Z, r18
    7bfa:	89 81       	ldd	r24, Y+1	; 0x01
    7bfc:	9a 81       	ldd	r25, Y+2	; 0x02
    7bfe:	01 96       	adiw	r24, 0x01	; 1
    7c00:	89 83       	std	Y+1, r24	; 0x01
    7c02:	9a 83       	std	Y+2, r25	; 0x02
    7c04:	89 81       	ldd	r24, Y+1	; 0x01
    7c06:	9a 81       	ldd	r25, Y+2	; 0x02
    7c08:	88 31       	cpi	r24, 0x18	; 24
    7c0a:	91 05       	cpc	r25, r1
    7c0c:	7c f3       	brlt	.-34     	; 0x7bec <SD_write_and_read_knowns+0x14>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    7c0e:	2c ec       	ldi	r18, 0xCC	; 204
    7c10:	33 e2       	ldi	r19, 0x23	; 35
    7c12:	64 e1       	ldi	r22, 0x14	; 20
    7c14:	70 e0       	ldi	r23, 0x00	; 0
    7c16:	80 e0       	ldi	r24, 0x00	; 0
    7c18:	90 e0       	ldi	r25, 0x00	; 0
    7c1a:	a9 01       	movw	r20, r18
    7c1c:	28 e1       	ldi	r18, 0x18	; 24
    7c1e:	30 e0       	ldi	r19, 0x00	; 0
    7c20:	0e 94 84 4e 	call	0x9d08	; 0x9d08 <SD_write_block>
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7c24:	1b 82       	std	Y+3, r1	; 0x03
    7c26:	1c 82       	std	Y+4, r1	; 0x04
    7c28:	0b c0       	rjmp	.+22     	; 0x7c40 <SD_write_and_read_knowns+0x68>
    7c2a:	8b 81       	ldd	r24, Y+3	; 0x03
    7c2c:	9c 81       	ldd	r25, Y+4	; 0x04
    7c2e:	84 53       	subi	r24, 0x34	; 52
    7c30:	9c 4d       	sbci	r25, 0xDC	; 220
    7c32:	fc 01       	movw	r30, r24
    7c34:	10 82       	st	Z, r1
    7c36:	8b 81       	ldd	r24, Y+3	; 0x03
    7c38:	9c 81       	ldd	r25, Y+4	; 0x04
    7c3a:	01 96       	adiw	r24, 0x01	; 1
    7c3c:	8b 83       	std	Y+3, r24	; 0x03
    7c3e:	9c 83       	std	Y+4, r25	; 0x04
    7c40:	8b 81       	ldd	r24, Y+3	; 0x03
    7c42:	9c 81       	ldd	r25, Y+4	; 0x04
    7c44:	88 31       	cpi	r24, 0x18	; 24
    7c46:	91 05       	cpc	r25, r1
    7c48:	84 f3       	brlt	.-32     	; 0x7c2a <SD_write_and_read_knowns+0x52>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    7c4a:	2c ec       	ldi	r18, 0xCC	; 204
    7c4c:	33 e2       	ldi	r19, 0x23	; 35
    7c4e:	64 e1       	ldi	r22, 0x14	; 20
    7c50:	70 e0       	ldi	r23, 0x00	; 0
    7c52:	80 e0       	ldi	r24, 0x00	; 0
    7c54:	90 e0       	ldi	r25, 0x00	; 0
    7c56:	a9 01       	movw	r20, r18
    7c58:	0e 94 52 4f 	call	0x9ea4	; 0x9ea4 <SD_read_block>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    7c5c:	1d 82       	std	Y+5, r1	; 0x05
    7c5e:	1e 82       	std	Y+6, r1	; 0x06
    7c60:	13 c0       	rjmp	.+38     	; 0x7c88 <SD_write_and_read_knowns+0xb0>
    7c62:	8d 81       	ldd	r24, Y+5	; 0x05
    7c64:	9e 81       	ldd	r25, Y+6	; 0x06
    7c66:	24 e6       	ldi	r18, 0x64	; 100
    7c68:	30 e0       	ldi	r19, 0x00	; 0
    7c6a:	b9 01       	movw	r22, r18
    7c6c:	0e 94 3c 63 	call	0xc678	; 0xc678 <__divmodhi4>
    7c70:	28 2f       	mov	r18, r24
    7c72:	8d 81       	ldd	r24, Y+5	; 0x05
    7c74:	9e 81       	ldd	r25, Y+6	; 0x06
    7c76:	84 53       	subi	r24, 0x34	; 52
    7c78:	9c 4d       	sbci	r25, 0xDC	; 220
    7c7a:	fc 01       	movw	r30, r24
    7c7c:	20 83       	st	Z, r18
    7c7e:	8d 81       	ldd	r24, Y+5	; 0x05
    7c80:	9e 81       	ldd	r25, Y+6	; 0x06
    7c82:	01 96       	adiw	r24, 0x01	; 1
    7c84:	8d 83       	std	Y+5, r24	; 0x05
    7c86:	9e 83       	std	Y+6, r25	; 0x06
    7c88:	8d 81       	ldd	r24, Y+5	; 0x05
    7c8a:	9e 81       	ldd	r25, Y+6	; 0x06
    7c8c:	f4 e0       	ldi	r31, 0x04	; 4
    7c8e:	82 3e       	cpi	r24, 0xE2	; 226
    7c90:	9f 07       	cpc	r25, r31
    7c92:	3c f3       	brlt	.-50     	; 0x7c62 <SD_write_and_read_knowns+0x8a>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    7c94:	2c ec       	ldi	r18, 0xCC	; 204
    7c96:	33 e2       	ldi	r19, 0x23	; 35
    7c98:	60 e5       	ldi	r22, 0x50	; 80
    7c9a:	70 e0       	ldi	r23, 0x00	; 0
    7c9c:	80 e0       	ldi	r24, 0x00	; 0
    7c9e:	90 e0       	ldi	r25, 0x00	; 0
    7ca0:	a9 01       	movw	r20, r18
    7ca2:	22 ee       	ldi	r18, 0xE2	; 226
    7ca4:	34 e0       	ldi	r19, 0x04	; 4
    7ca6:	0e 94 c8 4f 	call	0x9f90	; 0x9f90 <SD_write_multiple_blocks>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    7caa:	1f 82       	std	Y+7, r1	; 0x07
    7cac:	18 86       	std	Y+8, r1	; 0x08
    7cae:	0b c0       	rjmp	.+22     	; 0x7cc6 <SD_write_and_read_knowns+0xee>
    7cb0:	8f 81       	ldd	r24, Y+7	; 0x07
    7cb2:	98 85       	ldd	r25, Y+8	; 0x08
    7cb4:	84 53       	subi	r24, 0x34	; 52
    7cb6:	9c 4d       	sbci	r25, 0xDC	; 220
    7cb8:	fc 01       	movw	r30, r24
    7cba:	10 82       	st	Z, r1
    7cbc:	8f 81       	ldd	r24, Y+7	; 0x07
    7cbe:	98 85       	ldd	r25, Y+8	; 0x08
    7cc0:	01 96       	adiw	r24, 0x01	; 1
    7cc2:	8f 83       	std	Y+7, r24	; 0x07
    7cc4:	98 87       	std	Y+8, r25	; 0x08
    7cc6:	8f 81       	ldd	r24, Y+7	; 0x07
    7cc8:	98 85       	ldd	r25, Y+8	; 0x08
    7cca:	f4 e0       	ldi	r31, 0x04	; 4
    7ccc:	82 3e       	cpi	r24, 0xE2	; 226
    7cce:	9f 07       	cpc	r25, r31
    7cd0:	7c f3       	brlt	.-34     	; 0x7cb0 <SD_write_and_read_knowns+0xd8>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    7cd2:	2c ec       	ldi	r18, 0xCC	; 204
    7cd4:	33 e2       	ldi	r19, 0x23	; 35
    7cd6:	60 e5       	ldi	r22, 0x50	; 80
    7cd8:	70 e0       	ldi	r23, 0x00	; 0
    7cda:	80 e0       	ldi	r24, 0x00	; 0
    7cdc:	90 e0       	ldi	r25, 0x00	; 0
    7cde:	a9 01       	movw	r20, r18
    7ce0:	23 e0       	ldi	r18, 0x03	; 3
    7ce2:	30 e0       	ldi	r19, 0x00	; 0
    7ce4:	0e 94 26 51 	call	0xa24c	; 0xa24c <SD_read_multiple_blocks>
}
    7ce8:	28 96       	adiw	r28, 0x08	; 8
    7cea:	cd bf       	out	0x3d, r28	; 61
    7cec:	de bf       	out	0x3e, r29	; 62
    7cee:	df 91       	pop	r29
    7cf0:	cf 91       	pop	r28
    7cf2:	08 95       	ret

00007cf4 <SD_write_and_read_knowns_FAT>:
//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    7cf4:	cf 93       	push	r28
    7cf6:	df 93       	push	r29
    7cf8:	00 d0       	rcall	.+0      	; 0x7cfa <SD_write_and_read_knowns_FAT+0x6>
    7cfa:	0f 92       	push	r0
    7cfc:	cd b7       	in	r28, 0x3d	; 61
    7cfe:	de b7       	in	r29, 0x3e	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7d00:	19 82       	std	Y+1, r1	; 0x01
    7d02:	1a 82       	std	Y+2, r1	; 0x02
    7d04:	0c c0       	rjmp	.+24     	; 0x7d1e <SD_write_and_read_knowns_FAT+0x2a>
    7d06:	29 81       	ldd	r18, Y+1	; 0x01
    7d08:	89 81       	ldd	r24, Y+1	; 0x01
    7d0a:	9a 81       	ldd	r25, Y+2	; 0x02
    7d0c:	84 53       	subi	r24, 0x34	; 52
    7d0e:	9c 4d       	sbci	r25, 0xDC	; 220
    7d10:	fc 01       	movw	r30, r24
    7d12:	20 83       	st	Z, r18
    7d14:	89 81       	ldd	r24, Y+1	; 0x01
    7d16:	9a 81       	ldd	r25, Y+2	; 0x02
    7d18:	01 96       	adiw	r24, 0x01	; 1
    7d1a:	89 83       	std	Y+1, r24	; 0x01
    7d1c:	9a 83       	std	Y+2, r25	; 0x02
    7d1e:	89 81       	ldd	r24, Y+1	; 0x01
    7d20:	9a 81       	ldd	r25, Y+2	; 0x02
    7d22:	88 31       	cpi	r24, 0x18	; 24
    7d24:	91 05       	cpc	r25, r1
    7d26:	7c f3       	brlt	.-34     	; 0x7d06 <SD_write_and_read_knowns_FAT+0x12>
	error = writeFile("testing",FRAMReadBuffer,512);
    7d28:	89 e0       	ldi	r24, 0x09	; 9
    7d2a:	90 e2       	ldi	r25, 0x20	; 32
    7d2c:	2c ec       	ldi	r18, 0xCC	; 204
    7d2e:	33 e2       	ldi	r19, 0x23	; 35
    7d30:	b9 01       	movw	r22, r18
    7d32:	20 e0       	ldi	r18, 0x00	; 0
    7d34:	32 e0       	ldi	r19, 0x02	; 2
    7d36:	40 e0       	ldi	r20, 0x00	; 0
    7d38:	50 e0       	ldi	r21, 0x00	; 0
    7d3a:	0e 94 72 46 	call	0x8ce4	; 0x8ce4 <writeFile>
    7d3e:	80 93 98 50 	sts	0x5098, r24
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7d42:	1b 82       	std	Y+3, r1	; 0x03
    7d44:	1c 82       	std	Y+4, r1	; 0x04
    7d46:	0b c0       	rjmp	.+22     	; 0x7d5e <SD_write_and_read_knowns_FAT+0x6a>
    7d48:	8b 81       	ldd	r24, Y+3	; 0x03
    7d4a:	9c 81       	ldd	r25, Y+4	; 0x04
    7d4c:	84 53       	subi	r24, 0x34	; 52
    7d4e:	9c 4d       	sbci	r25, 0xDC	; 220
    7d50:	fc 01       	movw	r30, r24
    7d52:	10 82       	st	Z, r1
    7d54:	8b 81       	ldd	r24, Y+3	; 0x03
    7d56:	9c 81       	ldd	r25, Y+4	; 0x04
    7d58:	01 96       	adiw	r24, 0x01	; 1
    7d5a:	8b 83       	std	Y+3, r24	; 0x03
    7d5c:	9c 83       	std	Y+4, r25	; 0x04
    7d5e:	8b 81       	ldd	r24, Y+3	; 0x03
    7d60:	9c 81       	ldd	r25, Y+4	; 0x04
    7d62:	88 31       	cpi	r24, 0x18	; 24
    7d64:	91 05       	cpc	r25, r1
    7d66:	84 f3       	brlt	.-32     	; 0x7d48 <SD_write_and_read_knowns_FAT+0x54>
	error = readFile(READ,"testing");		//read the data into the buffer from file
    7d68:	29 e0       	ldi	r18, 0x09	; 9
    7d6a:	30 e2       	ldi	r19, 0x20	; 32
    7d6c:	80 e0       	ldi	r24, 0x00	; 0
    7d6e:	b9 01       	movw	r22, r18
    7d70:	0e 94 8d 44 	call	0x891a	; 0x891a <readFile>
    7d74:	80 93 98 50 	sts	0x5098, r24
}
    7d78:	24 96       	adiw	r28, 0x04	; 4
    7d7a:	cd bf       	out	0x3d, r28	; 61
    7d7c:	de bf       	out	0x3e, r29	; 62
    7d7e:	df 91       	pop	r29
    7d80:	cf 91       	pop	r28
    7d82:	08 95       	ret

00007d84 <chibi_test_radio>:




//function for testing radio transmission
void chibi_test_radio(){
    7d84:	cf 93       	push	r28
    7d86:	df 93       	push	r29
    7d88:	cd b7       	in	r28, 0x3d	; 61
    7d8a:	de b7       	in	r29, 0x3e	; 62
		
	chb_init();
    7d8c:	0e 94 c1 1e 	call	0x3d82	; 0x3d82 <chb_init>
	chb_set_short_addr(0x0002);
    7d90:	82 e0       	ldi	r24, 0x02	; 2
    7d92:	90 e0       	ldi	r25, 0x00	; 0
    7d94:	0e 94 5b 2c 	call	0x58b6	; 0x58b6 <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    7d98:	00 00       	nop
    7d9a:	fe cf       	rjmp	.-4      	; 0x7d98 <chibi_test_radio+0x14>

00007d9c <TestCard>:
	for (int i=0;i<10;i++) FRAMReadBuffer[i] = 0;
	chb_read(FRAMReadBuffer);
	*/
}
//another testing function for sd card
void TestCard(){
    7d9c:	cf 93       	push	r28
    7d9e:	df 93       	push	r29
    7da0:	0f 92       	push	r0
    7da2:	0f 92       	push	r0
    7da4:	cd b7       	in	r28, 0x3d	; 61
    7da6:	de b7       	in	r29, 0x3e	; 62
	SD_init();
    7da8:	0e 94 dd 4b 	call	0x97ba	; 0x97ba <SD_init>
	getBootSectorData();
    7dac:	0e 94 dd 3f 	call	0x7fba	; 0x7fba <getBootSectorData>
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    7db0:	19 82       	std	Y+1, r1	; 0x01
    7db2:	1a 82       	std	Y+2, r1	; 0x02
    7db4:	13 c0       	rjmp	.+38     	; 0x7ddc <TestCard+0x40>
    7db6:	89 81       	ldd	r24, Y+1	; 0x01
    7db8:	9a 81       	ldd	r25, Y+2	; 0x02
    7dba:	29 e7       	ldi	r18, 0x79	; 121
    7dbc:	30 e0       	ldi	r19, 0x00	; 0
    7dbe:	b9 01       	movw	r22, r18
    7dc0:	0e 94 3c 63 	call	0xc678	; 0xc678 <__divmodhi4>
    7dc4:	28 2f       	mov	r18, r24
    7dc6:	89 81       	ldd	r24, Y+1	; 0x01
    7dc8:	9a 81       	ldd	r25, Y+2	; 0x02
    7dca:	84 53       	subi	r24, 0x34	; 52
    7dcc:	9c 4d       	sbci	r25, 0xDC	; 220
    7dce:	fc 01       	movw	r30, r24
    7dd0:	20 83       	st	Z, r18
    7dd2:	89 81       	ldd	r24, Y+1	; 0x01
    7dd4:	9a 81       	ldd	r25, Y+2	; 0x02
    7dd6:	01 96       	adiw	r24, 0x01	; 1
    7dd8:	89 83       	std	Y+1, r24	; 0x01
    7dda:	9a 83       	std	Y+2, r25	; 0x02
    7ddc:	89 81       	ldd	r24, Y+1	; 0x01
    7dde:	9a 81       	ldd	r25, Y+2	; 0x02
    7de0:	f2 e0       	ldi	r31, 0x02	; 2
    7de2:	80 30       	cpi	r24, 0x00	; 0
    7de4:	9f 07       	cpc	r25, r31
    7de6:	3c f3       	brlt	.-50     	; 0x7db6 <TestCard+0x1a>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile("testing",FRAMReadBuffer,512);//}
    7de8:	89 e0       	ldi	r24, 0x09	; 9
    7dea:	90 e2       	ldi	r25, 0x20	; 32
    7dec:	2c ec       	ldi	r18, 0xCC	; 204
    7dee:	33 e2       	ldi	r19, 0x23	; 35
    7df0:	b9 01       	movw	r22, r18
    7df2:	20 e0       	ldi	r18, 0x00	; 0
    7df4:	32 e0       	ldi	r19, 0x02	; 2
    7df6:	40 e0       	ldi	r20, 0x00	; 0
    7df8:	50 e0       	ldi	r21, 0x00	; 0
    7dfa:	0e 94 72 46 	call	0x8ce4	; 0x8ce4 <writeFile>
	nop();
    7dfe:	00 00       	nop
}
    7e00:	0f 90       	pop	r0
    7e02:	0f 90       	pop	r0
    7e04:	df 91       	pop	r29
    7e06:	cf 91       	pop	r28
    7e08:	08 95       	ret

00007e0a <__vector_43>:

//interrupt service routine for handling received data over radio
ISR(PORTE_INT0_vect){
    7e0a:	1f 92       	push	r1
    7e0c:	0f 92       	push	r0
    7e0e:	0f b6       	in	r0, 0x3f	; 63
    7e10:	0f 92       	push	r0
    7e12:	00 90 3b 00 	lds	r0, 0x003B
    7e16:	0f 92       	push	r0
    7e18:	11 24       	eor	r1, r1
    7e1a:	2f 93       	push	r18
    7e1c:	3f 93       	push	r19
    7e1e:	4f 93       	push	r20
    7e20:	5f 93       	push	r21
    7e22:	6f 93       	push	r22
    7e24:	7f 93       	push	r23
    7e26:	8f 93       	push	r24
    7e28:	9f 93       	push	r25
    7e2a:	af 93       	push	r26
    7e2c:	bf 93       	push	r27
    7e2e:	ef 93       	push	r30
    7e30:	ff 93       	push	r31
    7e32:	cf 93       	push	r28
    7e34:	df 93       	push	r29
    7e36:	cd b7       	in	r28, 0x3d	; 61
    7e38:	de b7       	in	r29, 0x3e	; 62
    7e3a:	c4 58       	subi	r28, 0x84	; 132
    7e3c:	d0 40       	sbci	r29, 0x00	; 0
    7e3e:	cd bf       	out	0x3d, r28	; 61
    7e40:	de bf       	out	0x3e, r29	; 62
	char msg[128];
	switch (RadioMonitorMode) {
    7e42:	80 91 53 40 	lds	r24, 0x4053
    7e46:	88 2f       	mov	r24, r24
    7e48:	90 e0       	ldi	r25, 0x00	; 0
    7e4a:	81 30       	cpi	r24, 0x01	; 1
    7e4c:	91 05       	cpc	r25, r1
    7e4e:	29 f0       	breq	.+10     	; 0x7e5a <__vector_43+0x50>
    7e50:	82 30       	cpi	r24, 0x02	; 2
    7e52:	91 05       	cpc	r25, r1
    7e54:	09 f4       	brne	.+2      	; 0x7e58 <__vector_43+0x4e>
    7e56:	73 c0       	rjmp	.+230    	; 0x7f3e <__vector_43+0x134>
    7e58:	91 c0       	rjmp	.+290    	; 0x7f7c <__vector_43+0x172>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    7e5a:	ce 01       	movw	r24, r28
    7e5c:	05 96       	adiw	r24, 0x05	; 5
    7e5e:	0e 94 13 21 	call	0x4226	; 0x4226 <chb_read>
			if(!strncmp(msg,"reset",5)){
    7e62:	ce 01       	movw	r24, r28
    7e64:	05 96       	adiw	r24, 0x05	; 5
    7e66:	21 e1       	ldi	r18, 0x11	; 17
    7e68:	30 e2       	ldi	r19, 0x20	; 32
    7e6a:	b9 01       	movw	r22, r18
    7e6c:	45 e0       	ldi	r20, 0x05	; 5
    7e6e:	50 e0       	ldi	r21, 0x00	; 0
    7e70:	0e 94 ea 63 	call	0xc7d4	; 0xc7d4 <strncmp>
    7e74:	00 97       	sbiw	r24, 0x00	; 0
    7e76:	51 f4       	brne	.+20     	; 0x7e8c <__vector_43+0x82>
				MotesReadyToSynch++;
    7e78:	80 91 6d 50 	lds	r24, 0x506D
    7e7c:	90 91 6e 50 	lds	r25, 0x506E
    7e80:	01 96       	adiw	r24, 0x01	; 1
    7e82:	80 93 6d 50 	sts	0x506D, r24
    7e86:	90 93 6e 50 	sts	0x506E, r25
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    7e8a:	7a c0       	rjmp	.+244    	; 0x7f80 <__vector_43+0x176>
			if(!strncmp(msg,"reset",5)){
				MotesReadyToSynch++;
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
    7e8c:	19 82       	std	Y+1, r1	; 0x01
    7e8e:	1a 82       	std	Y+2, r1	; 0x02
    7e90:	1b 82       	std	Y+3, r1	; 0x03
    7e92:	1c 82       	std	Y+4, r1	; 0x04
    7e94:	1a c0       	rjmp	.+52     	; 0x7eca <__vector_43+0xc0>
    7e96:	9e 01       	movw	r18, r28
    7e98:	2b 5f       	subi	r18, 0xFB	; 251
    7e9a:	3f 4f       	sbci	r19, 0xFF	; 255
    7e9c:	89 81       	ldd	r24, Y+1	; 0x01
    7e9e:	9a 81       	ldd	r25, Y+2	; 0x02
    7ea0:	82 0f       	add	r24, r18
    7ea2:	93 1f       	adc	r25, r19
    7ea4:	fc 01       	movw	r30, r24
    7ea6:	20 81       	ld	r18, Z
    7ea8:	89 81       	ldd	r24, Y+1	; 0x01
    7eaa:	9a 81       	ldd	r25, Y+2	; 0x02
    7eac:	84 53       	subi	r24, 0x34	; 52
    7eae:	9c 4d       	sbci	r25, 0xDC	; 220
    7eb0:	fc 01       	movw	r30, r24
    7eb2:	20 83       	st	Z, r18
    7eb4:	89 81       	ldd	r24, Y+1	; 0x01
    7eb6:	9a 81       	ldd	r25, Y+2	; 0x02
    7eb8:	ab 81       	ldd	r26, Y+3	; 0x03
    7eba:	bc 81       	ldd	r27, Y+4	; 0x04
    7ebc:	01 96       	adiw	r24, 0x01	; 1
    7ebe:	a1 1d       	adc	r26, r1
    7ec0:	b1 1d       	adc	r27, r1
    7ec2:	89 83       	std	Y+1, r24	; 0x01
    7ec4:	9a 83       	std	Y+2, r25	; 0x02
    7ec6:	ab 83       	std	Y+3, r26	; 0x03
    7ec8:	bc 83       	std	Y+4, r27	; 0x04
    7eca:	89 81       	ldd	r24, Y+1	; 0x01
    7ecc:	9a 81       	ldd	r25, Y+2	; 0x02
    7ece:	ab 81       	ldd	r26, Y+3	; 0x03
    7ed0:	bc 81       	ldd	r27, Y+4	; 0x04
    7ed2:	80 38       	cpi	r24, 0x80	; 128
    7ed4:	91 05       	cpc	r25, r1
    7ed6:	a1 05       	cpc	r26, r1
    7ed8:	b1 05       	cpc	r27, r1
    7eda:	e8 f2       	brcs	.-70     	; 0x7e96 <__vector_43+0x8c>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    7edc:	80 91 bf 50 	lds	r24, 0x50BF
    7ee0:	90 91 c0 50 	lds	r25, 0x50C0
    7ee4:	a0 91 c1 50 	lds	r26, 0x50C1
    7ee8:	b0 91 c2 50 	lds	r27, 0x50C2
    7eec:	80 58       	subi	r24, 0x80	; 128
    7eee:	9f 4f       	sbci	r25, 0xFF	; 255
    7ef0:	af 4f       	sbci	r26, 0xFF	; 255
    7ef2:	bf 4f       	sbci	r27, 0xFF	; 255
    7ef4:	80 93 bf 50 	sts	0x50BF, r24
    7ef8:	90 93 c0 50 	sts	0x50C0, r25
    7efc:	a0 93 c1 50 	sts	0x50C1, r26
    7f00:	b0 93 c2 50 	sts	0x50C2, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    7f04:	80 91 bf 50 	lds	r24, 0x50BF
    7f08:	90 91 c0 50 	lds	r25, 0x50C0
    7f0c:	a0 91 c1 50 	lds	r26, 0x50C1
    7f10:	b0 91 c2 50 	lds	r27, 0x50C2
    7f14:	80 58       	subi	r24, 0x80	; 128
    7f16:	9f 4f       	sbci	r25, 0xFF	; 255
    7f18:	af 4f       	sbci	r26, 0xFF	; 255
    7f1a:	bf 4f       	sbci	r27, 0xFF	; 255
    7f1c:	81 37       	cpi	r24, 0x71	; 113
    7f1e:	fc e1       	ldi	r31, 0x1C	; 28
    7f20:	9f 07       	cpc	r25, r31
    7f22:	f0 e0       	ldi	r31, 0x00	; 0
    7f24:	af 07       	cpc	r26, r31
    7f26:	f0 e0       	ldi	r31, 0x00	; 0
    7f28:	bf 07       	cpc	r27, r31
    7f2a:	50 f1       	brcs	.+84     	; 0x7f80 <__vector_43+0x176>
    7f2c:	10 92 bf 50 	sts	0x50BF, r1
    7f30:	10 92 c0 50 	sts	0x50C0, r1
    7f34:	10 92 c1 50 	sts	0x50C1, r1
    7f38:	10 92 c2 50 	sts	0x50C2, r1
			}			
			break;
    7f3c:	21 c0       	rjmp	.+66     	; 0x7f80 <__vector_43+0x176>
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    7f3e:	ce 01       	movw	r24, r28
    7f40:	05 96       	adiw	r24, 0x05	; 5
    7f42:	0e 94 13 21 	call	0x4226	; 0x4226 <chb_read>
			if(!strncmp(msg,"start sampling",14)){	//if basestation synch response message received, do the following
    7f46:	ce 01       	movw	r24, r28
    7f48:	05 96       	adiw	r24, 0x05	; 5
    7f4a:	27 e1       	ldi	r18, 0x17	; 23
    7f4c:	30 e2       	ldi	r19, 0x20	; 32
    7f4e:	b9 01       	movw	r22, r18
    7f50:	4e e0       	ldi	r20, 0x0E	; 14
    7f52:	50 e0       	ldi	r21, 0x00	; 0
    7f54:	0e 94 ea 63 	call	0xc7d4	; 0xc7d4 <strncmp>
    7f58:	00 97       	sbiw	r24, 0x00	; 0
    7f5a:	a1 f4       	brne	.+40     	; 0x7f84 <__vector_43+0x17a>
				RadioMonitorMode = SYNCHED;
    7f5c:	83 e0       	ldi	r24, 0x03	; 3
    7f5e:	80 93 53 40 	sts	0x4053, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    7f62:	80 e4       	ldi	r24, 0x40	; 64
    7f64:	99 e0       	ldi	r25, 0x09	; 9
    7f66:	29 e0       	ldi	r18, 0x09	; 9
    7f68:	fc 01       	movw	r30, r24
    7f6a:	20 83       	st	Z, r18
				TCC1.CTRLA = 0x01;  
    7f6c:	80 e4       	ldi	r24, 0x40	; 64
    7f6e:	98 e0       	ldi	r25, 0x08	; 8
    7f70:	21 e0       	ldi	r18, 0x01	; 1
    7f72:	fc 01       	movw	r30, r24
    7f74:	20 83       	st	Z, r18
				ADC_Resume_Sampling();	//resume sampling with the adc
    7f76:	0e 94 0e 0a 	call	0x141c	; 0x141c <ADC_Resume_Sampling>
			}
			break;
    7f7a:	04 c0       	rjmp	.+8      	; 0x7f84 <__vector_43+0x17a>
		default:
			break;
    7f7c:	00 00       	nop
    7f7e:	03 c0       	rjmp	.+6      	; 0x7f86 <__vector_43+0x17c>
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    7f80:	00 00       	nop
    7f82:	01 c0       	rjmp	.+2      	; 0x7f86 <__vector_43+0x17c>
				RadioMonitorMode = SYNCHED;
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
				TCC1.CTRLA = 0x01;  
				ADC_Resume_Sampling();	//resume sampling with the adc
			}
			break;
    7f84:	00 00       	nop
		default:
			break;
	}
    7f86:	cc 57       	subi	r28, 0x7C	; 124
    7f88:	df 4f       	sbci	r29, 0xFF	; 255
    7f8a:	cd bf       	out	0x3d, r28	; 61
    7f8c:	de bf       	out	0x3e, r29	; 62
    7f8e:	df 91       	pop	r29
    7f90:	cf 91       	pop	r28
    7f92:	ff 91       	pop	r31
    7f94:	ef 91       	pop	r30
    7f96:	bf 91       	pop	r27
    7f98:	af 91       	pop	r26
    7f9a:	9f 91       	pop	r25
    7f9c:	8f 91       	pop	r24
    7f9e:	7f 91       	pop	r23
    7fa0:	6f 91       	pop	r22
    7fa2:	5f 91       	pop	r21
    7fa4:	4f 91       	pop	r20
    7fa6:	3f 91       	pop	r19
    7fa8:	2f 91       	pop	r18
    7faa:	0f 90       	pop	r0
    7fac:	00 92 3b 00 	sts	0x003B, r0
    7fb0:	0f 90       	pop	r0
    7fb2:	0f be       	out	0x3f, r0	; 63
    7fb4:	0f 90       	pop	r0
    7fb6:	1f 90       	pop	r1
    7fb8:	18 95       	reti

00007fba <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    7fba:	ef 92       	push	r14
    7fbc:	ff 92       	push	r15
    7fbe:	0f 93       	push	r16
    7fc0:	1f 93       	push	r17
    7fc2:	cf 93       	push	r28
    7fc4:	df 93       	push	r29
    7fc6:	cd b7       	in	r28, 0x3d	; 61
    7fc8:	de b7       	in	r29, 0x3e	; 62
    7fca:	2a 97       	sbiw	r28, 0x0a	; 10
    7fcc:	cd bf       	out	0x3d, r28	; 61
    7fce:	de bf       	out	0x3e, r29	; 62
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    7fd0:	10 92 72 50 	sts	0x5072, r1
    7fd4:	10 92 73 50 	sts	0x5073, r1
    7fd8:	10 92 74 50 	sts	0x5074, r1
    7fdc:	10 92 75 50 	sts	0x5075, r1

SD_read_block(0,SDBuffer);
    7fe0:	23 ec       	ldi	r18, 0xC3	; 195
    7fe2:	31 e2       	ldi	r19, 0x21	; 33
    7fe4:	60 e0       	ldi	r22, 0x00	; 0
    7fe6:	70 e0       	ldi	r23, 0x00	; 0
    7fe8:	cb 01       	movw	r24, r22
    7fea:	a9 01       	movw	r20, r18
    7fec:	0e 94 52 4f 	call	0x9ea4	; 0x9ea4 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;
    7ff0:	83 ec       	ldi	r24, 0xC3	; 195
    7ff2:	91 e2       	ldi	r25, 0x21	; 33
    7ff4:	89 83       	std	Y+1, r24	; 0x01
    7ff6:	9a 83       	std	Y+2, r25	; 0x02

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    7ff8:	89 81       	ldd	r24, Y+1	; 0x01
    7ffa:	9a 81       	ldd	r25, Y+2	; 0x02
    7ffc:	fc 01       	movw	r30, r24
    7ffe:	80 81       	ld	r24, Z
    8000:	89 3e       	cpi	r24, 0xE9	; 233
    8002:	09 f4       	brne	.+2      	; 0x8006 <getBootSectorData+0x4c>
    8004:	4d c0       	rjmp	.+154    	; 0x80a0 <getBootSectorData+0xe6>
    8006:	89 81       	ldd	r24, Y+1	; 0x01
    8008:	9a 81       	ldd	r25, Y+2	; 0x02
    800a:	fc 01       	movw	r30, r24
    800c:	80 81       	ld	r24, Z
    800e:	8b 3e       	cpi	r24, 0xEB	; 235
    8010:	09 f4       	brne	.+2      	; 0x8014 <getBootSectorData+0x5a>
    8012:	46 c0       	rjmp	.+140    	; 0x80a0 <getBootSectorData+0xe6>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
    8014:	83 ec       	ldi	r24, 0xC3	; 195
    8016:	91 e2       	ldi	r25, 0x21	; 33
    8018:	8b 83       	std	Y+3, r24	; 0x03
    801a:	9c 83       	std	Y+4, r25	; 0x04
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    801c:	8b 81       	ldd	r24, Y+3	; 0x03
    801e:	9c 81       	ldd	r25, Y+4	; 0x04
    8020:	82 50       	subi	r24, 0x02	; 2
    8022:	9e 4f       	sbci	r25, 0xFE	; 254
    8024:	fc 01       	movw	r30, r24
    8026:	80 81       	ld	r24, Z
    8028:	91 81       	ldd	r25, Z+1	; 0x01
    802a:	fa ea       	ldi	r31, 0xAA	; 170
    802c:	85 35       	cpi	r24, 0x55	; 85
    802e:	9f 07       	cpc	r25, r31
    8030:	11 f0       	breq	.+4      	; 0x8036 <getBootSectorData+0x7c>
    8032:	81 e0       	ldi	r24, 0x01	; 1
    8034:	01 c1       	rjmp	.+514    	; 0x8238 <getBootSectorData+0x27e>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
    8036:	8b 81       	ldd	r24, Y+3	; 0x03
    8038:	9c 81       	ldd	r25, Y+4	; 0x04
    803a:	82 54       	subi	r24, 0x42	; 66
    803c:	9e 4f       	sbci	r25, 0xFE	; 254
    803e:	8d 83       	std	Y+5, r24	; 0x05
    8040:	9e 83       	std	Y+6, r25	; 0x06
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    8042:	8d 81       	ldd	r24, Y+5	; 0x05
    8044:	9e 81       	ldd	r25, Y+6	; 0x06
    8046:	fc 01       	movw	r30, r24
    8048:	80 85       	ldd	r24, Z+8	; 0x08
    804a:	91 85       	ldd	r25, Z+9	; 0x09
    804c:	a2 85       	ldd	r26, Z+10	; 0x0a
    804e:	b3 85       	ldd	r27, Z+11	; 0x0b
    8050:	80 93 72 50 	sts	0x5072, r24
    8054:	90 93 73 50 	sts	0x5073, r25
    8058:	a0 93 74 50 	sts	0x5074, r26
    805c:	b0 93 75 50 	sts	0x5075, r27
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    8060:	8d 81       	ldd	r24, Y+5	; 0x05
    8062:	9e 81       	ldd	r25, Y+6	; 0x06
    8064:	fc 01       	movw	r30, r24
    8066:	80 85       	ldd	r24, Z+8	; 0x08
    8068:	91 85       	ldd	r25, Z+9	; 0x09
    806a:	a2 85       	ldd	r26, Z+10	; 0x0a
    806c:	b3 85       	ldd	r27, Z+11	; 0x0b
    806e:	23 ec       	ldi	r18, 0xC3	; 195
    8070:	31 e2       	ldi	r19, 0x21	; 33
    8072:	bc 01       	movw	r22, r24
    8074:	cd 01       	movw	r24, r26
    8076:	a9 01       	movw	r20, r18
    8078:	0e 94 52 4f 	call	0x9ea4	; 0x9ea4 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
    807c:	83 ec       	ldi	r24, 0xC3	; 195
    807e:	91 e2       	ldi	r25, 0x21	; 33
    8080:	89 83       	std	Y+1, r24	; 0x01
    8082:	9a 83       	std	Y+2, r25	; 0x02
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    8084:	89 81       	ldd	r24, Y+1	; 0x01
    8086:	9a 81       	ldd	r25, Y+2	; 0x02
    8088:	fc 01       	movw	r30, r24
    808a:	80 81       	ld	r24, Z
    808c:	89 3e       	cpi	r24, 0xE9	; 233
    808e:	41 f0       	breq	.+16     	; 0x80a0 <getBootSectorData+0xe6>
    8090:	89 81       	ldd	r24, Y+1	; 0x01
    8092:	9a 81       	ldd	r25, Y+2	; 0x02
    8094:	fc 01       	movw	r30, r24
    8096:	80 81       	ld	r24, Z
    8098:	8b 3e       	cpi	r24, 0xEB	; 235
    809a:	11 f0       	breq	.+4      	; 0x80a0 <getBootSectorData+0xe6>
    809c:	81 e0       	ldi	r24, 0x01	; 1
    809e:	cc c0       	rjmp	.+408    	; 0x8238 <getBootSectorData+0x27e>
}

bytesPerSector = bpb->bytesPerSector;
    80a0:	89 81       	ldd	r24, Y+1	; 0x01
    80a2:	9a 81       	ldd	r25, Y+2	; 0x02
    80a4:	fc 01       	movw	r30, r24
    80a6:	83 85       	ldd	r24, Z+11	; 0x0b
    80a8:	94 85       	ldd	r25, Z+12	; 0x0c
    80aa:	80 93 41 40 	sts	0x4041, r24
    80ae:	90 93 42 40 	sts	0x4042, r25
sectorPerCluster = bpb->sectorPerCluster;
    80b2:	89 81       	ldd	r24, Y+1	; 0x01
    80b4:	9a 81       	ldd	r25, Y+2	; 0x02
    80b6:	fc 01       	movw	r30, r24
    80b8:	85 85       	ldd	r24, Z+13	; 0x0d
    80ba:	88 2f       	mov	r24, r24
    80bc:	90 e0       	ldi	r25, 0x00	; 0
    80be:	80 93 70 50 	sts	0x5070, r24
    80c2:	90 93 71 50 	sts	0x5071, r25
reservedSectorCount = bpb->reservedSectorCount;
    80c6:	89 81       	ldd	r24, Y+1	; 0x01
    80c8:	9a 81       	ldd	r25, Y+2	; 0x02
    80ca:	fc 01       	movw	r30, r24
    80cc:	86 85       	ldd	r24, Z+14	; 0x0e
    80ce:	97 85       	ldd	r25, Z+15	; 0x0f
    80d0:	80 93 78 50 	sts	0x5078, r24
    80d4:	90 93 79 50 	sts	0x5079, r25
rootCluster = bpb->rootCluster;
    80d8:	89 81       	ldd	r24, Y+1	; 0x01
    80da:	9a 81       	ldd	r25, Y+2	; 0x02
    80dc:	fc 01       	movw	r30, r24
    80de:	84 a5       	lds	r24, 0x64
    80e0:	95 a5       	lds	r25, 0x65
    80e2:	a6 a5       	lds	r26, 0x66
    80e4:	b7 a5       	lds	r27, 0x67
    80e6:	80 93 54 40 	sts	0x4054, r24
    80ea:	90 93 55 40 	sts	0x4055, r25
    80ee:	a0 93 56 40 	sts	0x4056, r26
    80f2:	b0 93 57 40 	sts	0x4057, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    80f6:	89 81       	ldd	r24, Y+1	; 0x01
    80f8:	9a 81       	ldd	r25, Y+2	; 0x02
    80fa:	fc 01       	movw	r30, r24
    80fc:	24 8d       	ldd	r18, Z+28	; 0x1c
    80fe:	35 8d       	ldd	r19, Z+29	; 0x1d
    8100:	46 8d       	ldd	r20, Z+30	; 0x1e
    8102:	57 8d       	ldd	r21, Z+31	; 0x1f
    8104:	80 91 78 50 	lds	r24, 0x5078
    8108:	90 91 79 50 	lds	r25, 0x5079
    810c:	cc 01       	movw	r24, r24
    810e:	a0 e0       	ldi	r26, 0x00	; 0
    8110:	b0 e0       	ldi	r27, 0x00	; 0
    8112:	79 01       	movw	r14, r18
    8114:	8a 01       	movw	r16, r20
    8116:	e8 0e       	add	r14, r24
    8118:	f9 1e       	adc	r15, r25
    811a:	0a 1f       	adc	r16, r26
    811c:	1b 1f       	adc	r17, r27
    811e:	89 81       	ldd	r24, Y+1	; 0x01
    8120:	9a 81       	ldd	r25, Y+2	; 0x02
    8122:	fc 01       	movw	r30, r24
    8124:	80 89       	ldd	r24, Z+16	; 0x10
    8126:	88 2f       	mov	r24, r24
    8128:	90 e0       	ldi	r25, 0x00	; 0
    812a:	a0 e0       	ldi	r26, 0x00	; 0
    812c:	b0 e0       	ldi	r27, 0x00	; 0
    812e:	29 81       	ldd	r18, Y+1	; 0x01
    8130:	3a 81       	ldd	r19, Y+2	; 0x02
    8132:	f9 01       	movw	r30, r18
    8134:	24 a1       	lds	r18, 0x44
    8136:	35 a1       	lds	r19, 0x45
    8138:	46 a1       	lds	r20, 0x46
    813a:	57 a1       	lds	r21, 0x47
    813c:	bc 01       	movw	r22, r24
    813e:	cd 01       	movw	r24, r26
    8140:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    8144:	dc 01       	movw	r26, r24
    8146:	cb 01       	movw	r24, r22
    8148:	8e 0d       	add	r24, r14
    814a:	9f 1d       	adc	r25, r15
    814c:	a0 1f       	adc	r26, r16
    814e:	b1 1f       	adc	r27, r17
    8150:	80 93 c8 23 	sts	0x23C8, r24
    8154:	90 93 c9 23 	sts	0x23C9, r25
    8158:	a0 93 ca 23 	sts	0x23CA, r26
    815c:	b0 93 cb 23 	sts	0x23CB, r27

dataSectors = bpb->totalSectors_F32
    8160:	89 81       	ldd	r24, Y+1	; 0x01
    8162:	9a 81       	ldd	r25, Y+2	; 0x02
    8164:	fc 01       	movw	r30, r24
    8166:	20 a1       	lds	r18, 0x40
    8168:	31 a1       	lds	r19, 0x41
    816a:	42 a1       	lds	r20, 0x42
    816c:	53 a1       	lds	r21, 0x43
              - bpb->reservedSectorCount
    816e:	89 81       	ldd	r24, Y+1	; 0x01
    8170:	9a 81       	ldd	r25, Y+2	; 0x02
    8172:	fc 01       	movw	r30, r24
    8174:	86 85       	ldd	r24, Z+14	; 0x0e
    8176:	97 85       	ldd	r25, Z+15	; 0x0f
    8178:	cc 01       	movw	r24, r24
    817a:	a0 e0       	ldi	r26, 0x00	; 0
    817c:	b0 e0       	ldi	r27, 0x00	; 0
    817e:	79 01       	movw	r14, r18
    8180:	8a 01       	movw	r16, r20
    8182:	e8 1a       	sub	r14, r24
    8184:	f9 0a       	sbc	r15, r25
    8186:	0a 0b       	sbc	r16, r26
    8188:	1b 0b       	sbc	r17, r27
              - ( bpb->numberofFATs * bpb->FATsize_F32);
    818a:	89 81       	ldd	r24, Y+1	; 0x01
    818c:	9a 81       	ldd	r25, Y+2	; 0x02
    818e:	fc 01       	movw	r30, r24
    8190:	80 89       	ldd	r24, Z+16	; 0x10
    8192:	88 2f       	mov	r24, r24
    8194:	90 e0       	ldi	r25, 0x00	; 0
    8196:	a0 e0       	ldi	r26, 0x00	; 0
    8198:	b0 e0       	ldi	r27, 0x00	; 0
    819a:	29 81       	ldd	r18, Y+1	; 0x01
    819c:	3a 81       	ldd	r19, Y+2	; 0x02
    819e:	f9 01       	movw	r30, r18
    81a0:	24 a1       	lds	r18, 0x44
    81a2:	35 a1       	lds	r19, 0x45
    81a4:	46 a1       	lds	r20, 0x46
    81a6:	57 a1       	lds	r21, 0x47
    81a8:	bc 01       	movw	r22, r24
    81aa:	cd 01       	movw	r24, r26
    81ac:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    81b0:	dc 01       	movw	r26, r24
    81b2:	cb 01       	movw	r24, r22
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    81b4:	a8 01       	movw	r20, r16
    81b6:	97 01       	movw	r18, r14
    81b8:	28 1b       	sub	r18, r24
    81ba:	39 0b       	sbc	r19, r25
    81bc:	4a 0b       	sbc	r20, r26
    81be:	5b 0b       	sbc	r21, r27
    81c0:	da 01       	movw	r26, r20
    81c2:	c9 01       	movw	r24, r18
    81c4:	8f 83       	std	Y+7, r24	; 0x07
    81c6:	98 87       	std	Y+8, r25	; 0x08
    81c8:	a9 87       	std	Y+9, r26	; 0x09
    81ca:	ba 87       	std	Y+10, r27	; 0x0a
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    81cc:	80 91 70 50 	lds	r24, 0x5070
    81d0:	90 91 71 50 	lds	r25, 0x5071
    81d4:	9c 01       	movw	r18, r24
    81d6:	40 e0       	ldi	r20, 0x00	; 0
    81d8:	50 e0       	ldi	r21, 0x00	; 0
    81da:	8f 81       	ldd	r24, Y+7	; 0x07
    81dc:	98 85       	ldd	r25, Y+8	; 0x08
    81de:	a9 85       	ldd	r26, Y+9	; 0x09
    81e0:	ba 85       	ldd	r27, Y+10	; 0x0a
    81e2:	bc 01       	movw	r22, r24
    81e4:	cd 01       	movw	r24, r26
    81e6:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    81ea:	da 01       	movw	r26, r20
    81ec:	c9 01       	movw	r24, r18
    81ee:	80 93 4e 40 	sts	0x404E, r24
    81f2:	90 93 4f 40 	sts	0x404F, r25
    81f6:	a0 93 50 40 	sts	0x4050, r26
    81fa:	b0 93 51 40 	sts	0x4051, r27


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    81fe:	81 e0       	ldi	r24, 0x01	; 1
    8200:	60 e0       	ldi	r22, 0x00	; 0
    8202:	20 e0       	ldi	r18, 0x00	; 0
    8204:	30 e0       	ldi	r19, 0x00	; 0
    8206:	a9 01       	movw	r20, r18
    8208:	0e 94 02 42 	call	0x8404	; 0x8404 <getSetFreeCluster>
    820c:	9b 01       	movw	r18, r22
    820e:	ac 01       	movw	r20, r24
    8210:	80 91 4e 40 	lds	r24, 0x404E
    8214:	90 91 4f 40 	lds	r25, 0x404F
    8218:	a0 91 50 40 	lds	r26, 0x4050
    821c:	b0 91 51 40 	lds	r27, 0x4051
    8220:	82 17       	cp	r24, r18
    8222:	93 07       	cpc	r25, r19
    8224:	a4 07       	cpc	r26, r20
    8226:	b5 07       	cpc	r27, r21
    8228:	18 f4       	brcc	.+6      	; 0x8230 <getBootSectorData+0x276>
     freeClusterCountUpdated = 0;
    822a:	10 92 c4 50 	sts	0x50C4, r1
    822e:	03 c0       	rjmp	.+6      	; 0x8236 <getBootSectorData+0x27c>
else
	 freeClusterCountUpdated = 1;
    8230:	81 e0       	ldi	r24, 0x01	; 1
    8232:	80 93 c4 50 	sts	0x50C4, r24
return 0;
    8236:	80 e0       	ldi	r24, 0x00	; 0
}
    8238:	2a 96       	adiw	r28, 0x0a	; 10
    823a:	cd bf       	out	0x3d, r28	; 61
    823c:	de bf       	out	0x3e, r29	; 62
    823e:	df 91       	pop	r29
    8240:	cf 91       	pop	r28
    8242:	1f 91       	pop	r17
    8244:	0f 91       	pop	r16
    8246:	ff 90       	pop	r15
    8248:	ef 90       	pop	r14
    824a:	08 95       	ret

0000824c <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    824c:	cf 93       	push	r28
    824e:	df 93       	push	r29
    8250:	00 d0       	rcall	.+0      	; 0x8252 <getFirstSector+0x6>
    8252:	0f 92       	push	r0
    8254:	cd b7       	in	r28, 0x3d	; 61
    8256:	de b7       	in	r29, 0x3e	; 62
    8258:	69 83       	std	Y+1, r22	; 0x01
    825a:	7a 83       	std	Y+2, r23	; 0x02
    825c:	8b 83       	std	Y+3, r24	; 0x03
    825e:	9c 83       	std	Y+4, r25	; 0x04
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    8260:	89 81       	ldd	r24, Y+1	; 0x01
    8262:	9a 81       	ldd	r25, Y+2	; 0x02
    8264:	ab 81       	ldd	r26, Y+3	; 0x03
    8266:	bc 81       	ldd	r27, Y+4	; 0x04
    8268:	02 97       	sbiw	r24, 0x02	; 2
    826a:	a1 09       	sbc	r26, r1
    826c:	b1 09       	sbc	r27, r1
    826e:	20 91 70 50 	lds	r18, 0x5070
    8272:	30 91 71 50 	lds	r19, 0x5071
    8276:	99 01       	movw	r18, r18
    8278:	40 e0       	ldi	r20, 0x00	; 0
    827a:	50 e0       	ldi	r21, 0x00	; 0
    827c:	bc 01       	movw	r22, r24
    827e:	cd 01       	movw	r24, r26
    8280:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    8284:	9b 01       	movw	r18, r22
    8286:	ac 01       	movw	r20, r24
    8288:	80 91 c8 23 	lds	r24, 0x23C8
    828c:	90 91 c9 23 	lds	r25, 0x23C9
    8290:	a0 91 ca 23 	lds	r26, 0x23CA
    8294:	b0 91 cb 23 	lds	r27, 0x23CB
    8298:	82 0f       	add	r24, r18
    829a:	93 1f       	adc	r25, r19
    829c:	a4 1f       	adc	r26, r20
    829e:	b5 1f       	adc	r27, r21
}
    82a0:	bc 01       	movw	r22, r24
    82a2:	cd 01       	movw	r24, r26
    82a4:	24 96       	adiw	r28, 0x04	; 4
    82a6:	cd bf       	out	0x3d, r28	; 61
    82a8:	de bf       	out	0x3e, r29	; 62
    82aa:	df 91       	pop	r29
    82ac:	cf 91       	pop	r28
    82ae:	08 95       	ret

000082b0 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    82b0:	ef 92       	push	r14
    82b2:	ff 92       	push	r15
    82b4:	0f 93       	push	r16
    82b6:	1f 93       	push	r17
    82b8:	cf 93       	push	r28
    82ba:	df 93       	push	r29
    82bc:	cd b7       	in	r28, 0x3d	; 61
    82be:	de b7       	in	r29, 0x3e	; 62
    82c0:	62 97       	sbiw	r28, 0x12	; 18
    82c2:	cd bf       	out	0x3d, r28	; 61
    82c4:	de bf       	out	0x3e, r29	; 62
    82c6:	6a 87       	std	Y+10, r22	; 0x0a
    82c8:	7b 87       	std	Y+11, r23	; 0x0b
    82ca:	8c 87       	std	Y+12, r24	; 0x0c
    82cc:	9d 87       	std	Y+13, r25	; 0x0d
    82ce:	4e 87       	std	Y+14, r20	; 0x0e
    82d0:	0f 87       	std	Y+15, r16	; 0x0f
    82d2:	18 8b       	std	Y+16, r17	; 0x10
    82d4:	29 8b       	std	Y+17, r18	; 0x11
    82d6:	3a 8b       	std	Y+18, r19	; 0x12
unsigned int FATEntryOffset;
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
unsigned char retry = 0;
    82d8:	19 82       	std	Y+1, r1	; 0x01

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    82da:	80 91 78 50 	lds	r24, 0x5078
    82de:	90 91 79 50 	lds	r25, 0x5079
    82e2:	9c 01       	movw	r18, r24
    82e4:	40 e0       	ldi	r20, 0x00	; 0
    82e6:	50 e0       	ldi	r21, 0x00	; 0
    82e8:	80 91 72 50 	lds	r24, 0x5072
    82ec:	90 91 73 50 	lds	r25, 0x5073
    82f0:	a0 91 74 50 	lds	r26, 0x5074
    82f4:	b0 91 75 50 	lds	r27, 0x5075
    82f8:	79 01       	movw	r14, r18
    82fa:	8a 01       	movw	r16, r20
    82fc:	e8 0e       	add	r14, r24
    82fe:	f9 1e       	adc	r15, r25
    8300:	0a 1f       	adc	r16, r26
    8302:	1b 1f       	adc	r17, r27
    8304:	8a 85       	ldd	r24, Y+10	; 0x0a
    8306:	9b 85       	ldd	r25, Y+11	; 0x0b
    8308:	ac 85       	ldd	r26, Y+12	; 0x0c
    830a:	bd 85       	ldd	r27, Y+13	; 0x0d
    830c:	88 0f       	add	r24, r24
    830e:	99 1f       	adc	r25, r25
    8310:	aa 1f       	adc	r26, r26
    8312:	bb 1f       	adc	r27, r27
    8314:	88 0f       	add	r24, r24
    8316:	99 1f       	adc	r25, r25
    8318:	aa 1f       	adc	r26, r26
    831a:	bb 1f       	adc	r27, r27
    831c:	20 91 41 40 	lds	r18, 0x4041
    8320:	30 91 42 40 	lds	r19, 0x4042
    8324:	99 01       	movw	r18, r18
    8326:	40 e0       	ldi	r20, 0x00	; 0
    8328:	50 e0       	ldi	r21, 0x00	; 0
    832a:	bc 01       	movw	r22, r24
    832c:	cd 01       	movw	r24, r26
    832e:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    8332:	da 01       	movw	r26, r20
    8334:	c9 01       	movw	r24, r18
    8336:	8e 0d       	add	r24, r14
    8338:	9f 1d       	adc	r25, r15
    833a:	a0 1f       	adc	r26, r16
    833c:	b1 1f       	adc	r27, r17
    833e:	8a 83       	std	Y+2, r24	; 0x02
    8340:	9b 83       	std	Y+3, r25	; 0x03
    8342:	ac 83       	std	Y+4, r26	; 0x04
    8344:	bd 83       	std	Y+5, r27	; 0x05

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    8346:	8a 85       	ldd	r24, Y+10	; 0x0a
    8348:	9b 85       	ldd	r25, Y+11	; 0x0b
    834a:	ac 85       	ldd	r26, Y+12	; 0x0c
    834c:	bd 85       	ldd	r27, Y+13	; 0x0d
    834e:	88 0f       	add	r24, r24
    8350:	99 1f       	adc	r25, r25
    8352:	aa 1f       	adc	r26, r26
    8354:	bb 1f       	adc	r27, r27
    8356:	88 0f       	add	r24, r24
    8358:	99 1f       	adc	r25, r25
    835a:	aa 1f       	adc	r26, r26
    835c:	bb 1f       	adc	r27, r27
    835e:	20 91 41 40 	lds	r18, 0x4041
    8362:	30 91 42 40 	lds	r19, 0x4042
    8366:	99 01       	movw	r18, r18
    8368:	40 e0       	ldi	r20, 0x00	; 0
    836a:	50 e0       	ldi	r21, 0x00	; 0
    836c:	bc 01       	movw	r22, r24
    836e:	cd 01       	movw	r24, r26
    8370:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    8374:	dc 01       	movw	r26, r24
    8376:	cb 01       	movw	r24, r22
    8378:	8e 83       	std	Y+6, r24	; 0x06
    837a:	9f 83       	std	Y+7, r25	; 0x07

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    837c:	8a 81       	ldd	r24, Y+2	; 0x02
    837e:	9b 81       	ldd	r25, Y+3	; 0x03
    8380:	ac 81       	ldd	r26, Y+4	; 0x04
    8382:	bd 81       	ldd	r27, Y+5	; 0x05
    8384:	23 ec       	ldi	r18, 0xC3	; 195
    8386:	31 e2       	ldi	r19, 0x21	; 33
    8388:	bc 01       	movw	r22, r24
    838a:	cd 01       	movw	r24, r26
    838c:	a9 01       	movw	r20, r18
    838e:	0e 94 52 4f 	call	0x9ea4	; 0x9ea4 <SD_read_block>

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    8392:	8e 81       	ldd	r24, Y+6	; 0x06
    8394:	9f 81       	ldd	r25, Y+7	; 0x07
    8396:	8d 53       	subi	r24, 0x3D	; 61
    8398:	9e 4d       	sbci	r25, 0xDE	; 222
    839a:	88 87       	std	Y+8, r24	; 0x08
    839c:	99 87       	std	Y+9, r25	; 0x09

if(get_set == GET)
    839e:	8e 85       	ldd	r24, Y+14	; 0x0e
    83a0:	88 23       	and	r24, r24
    83a2:	49 f4       	brne	.+18     	; 0x83b6 <getSetNextCluster+0x106>
  return ((*FATEntryValue) & 0x0fffffff);
    83a4:	88 85       	ldd	r24, Y+8	; 0x08
    83a6:	99 85       	ldd	r25, Y+9	; 0x09
    83a8:	fc 01       	movw	r30, r24
    83aa:	80 81       	ld	r24, Z
    83ac:	91 81       	ldd	r25, Z+1	; 0x01
    83ae:	a2 81       	ldd	r26, Z+2	; 0x02
    83b0:	b3 81       	ldd	r27, Z+3	; 0x03
    83b2:	bf 70       	andi	r27, 0x0F	; 15
    83b4:	1b c0       	rjmp	.+54     	; 0x83ec <getSetNextCluster+0x13c>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    83b6:	28 85       	ldd	r18, Y+8	; 0x08
    83b8:	39 85       	ldd	r19, Y+9	; 0x09
    83ba:	8f 85       	ldd	r24, Y+15	; 0x0f
    83bc:	98 89       	ldd	r25, Y+16	; 0x10
    83be:	a9 89       	ldd	r26, Y+17	; 0x11
    83c0:	ba 89       	ldd	r27, Y+18	; 0x12
    83c2:	f9 01       	movw	r30, r18
    83c4:	80 83       	st	Z, r24
    83c6:	91 83       	std	Z+1, r25	; 0x01
    83c8:	a2 83       	std	Z+2, r26	; 0x02
    83ca:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    83cc:	8a 81       	ldd	r24, Y+2	; 0x02
    83ce:	9b 81       	ldd	r25, Y+3	; 0x03
    83d0:	ac 81       	ldd	r26, Y+4	; 0x04
    83d2:	bd 81       	ldd	r27, Y+5	; 0x05
    83d4:	23 ec       	ldi	r18, 0xC3	; 195
    83d6:	31 e2       	ldi	r19, 0x21	; 33
    83d8:	bc 01       	movw	r22, r24
    83da:	cd 01       	movw	r24, r26
    83dc:	a9 01       	movw	r20, r18
    83de:	20 e0       	ldi	r18, 0x00	; 0
    83e0:	32 e0       	ldi	r19, 0x02	; 2
    83e2:	0e 94 84 4e 	call	0x9d08	; 0x9d08 <SD_write_block>

return (0);
    83e6:	80 e0       	ldi	r24, 0x00	; 0
    83e8:	90 e0       	ldi	r25, 0x00	; 0
    83ea:	dc 01       	movw	r26, r24
}
    83ec:	bc 01       	movw	r22, r24
    83ee:	cd 01       	movw	r24, r26
    83f0:	62 96       	adiw	r28, 0x12	; 18
    83f2:	cd bf       	out	0x3d, r28	; 61
    83f4:	de bf       	out	0x3e, r29	; 62
    83f6:	df 91       	pop	r29
    83f8:	cf 91       	pop	r28
    83fa:	1f 91       	pop	r17
    83fc:	0f 91       	pop	r16
    83fe:	ff 90       	pop	r15
    8400:	ef 90       	pop	r14
    8402:	08 95       	ret

00008404 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    8404:	cf 93       	push	r28
    8406:	df 93       	push	r29
    8408:	cd b7       	in	r28, 0x3d	; 61
    840a:	de b7       	in	r29, 0x3e	; 62
    840c:	28 97       	sbiw	r28, 0x08	; 8
    840e:	cd bf       	out	0x3d, r28	; 61
    8410:	de bf       	out	0x3e, r29	; 62
    8412:	8b 83       	std	Y+3, r24	; 0x03
    8414:	6c 83       	std	Y+4, r22	; 0x04
    8416:	2d 83       	std	Y+5, r18	; 0x05
    8418:	3e 83       	std	Y+6, r19	; 0x06
    841a:	4f 83       	std	Y+7, r20	; 0x07
    841c:	58 87       	std	Y+8, r21	; 0x08
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;
    841e:	83 ec       	ldi	r24, 0xC3	; 195
    8420:	91 e2       	ldi	r25, 0x21	; 33
    8422:	89 83       	std	Y+1, r24	; 0x01
    8424:	9a 83       	std	Y+2, r25	; 0x02

SD_read_block(unusedSectors + 1,SDBuffer);
    8426:	80 91 72 50 	lds	r24, 0x5072
    842a:	90 91 73 50 	lds	r25, 0x5073
    842e:	a0 91 74 50 	lds	r26, 0x5074
    8432:	b0 91 75 50 	lds	r27, 0x5075
    8436:	01 96       	adiw	r24, 0x01	; 1
    8438:	a1 1d       	adc	r26, r1
    843a:	b1 1d       	adc	r27, r1
    843c:	23 ec       	ldi	r18, 0xC3	; 195
    843e:	31 e2       	ldi	r19, 0x21	; 33
    8440:	bc 01       	movw	r22, r24
    8442:	cd 01       	movw	r24, r26
    8444:	a9 01       	movw	r20, r18
    8446:	0e 94 52 4f 	call	0x9ea4	; 0x9ea4 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    844a:	89 81       	ldd	r24, Y+1	; 0x01
    844c:	9a 81       	ldd	r25, Y+2	; 0x02
    844e:	fc 01       	movw	r30, r24
    8450:	80 81       	ld	r24, Z
    8452:	91 81       	ldd	r25, Z+1	; 0x01
    8454:	a2 81       	ldd	r26, Z+2	; 0x02
    8456:	b3 81       	ldd	r27, Z+3	; 0x03
    8458:	82 35       	cpi	r24, 0x52	; 82
    845a:	f2 e5       	ldi	r31, 0x52	; 82
    845c:	9f 07       	cpc	r25, r31
    845e:	f1 e6       	ldi	r31, 0x61	; 97
    8460:	af 07       	cpc	r26, r31
    8462:	f1 e4       	ldi	r31, 0x41	; 65
    8464:	bf 07       	cpc	r27, r31
    8466:	11 f5       	brne	.+68     	; 0x84ac <getSetFreeCluster+0xa8>
    8468:	89 81       	ldd	r24, Y+1	; 0x01
    846a:	9a 81       	ldd	r25, Y+2	; 0x02
    846c:	8c 51       	subi	r24, 0x1C	; 28
    846e:	9e 4f       	sbci	r25, 0xFE	; 254
    8470:	fc 01       	movw	r30, r24
    8472:	80 81       	ld	r24, Z
    8474:	91 81       	ldd	r25, Z+1	; 0x01
    8476:	a2 81       	ldd	r26, Z+2	; 0x02
    8478:	b3 81       	ldd	r27, Z+3	; 0x03
    847a:	82 37       	cpi	r24, 0x72	; 114
    847c:	f2 e7       	ldi	r31, 0x72	; 114
    847e:	9f 07       	cpc	r25, r31
    8480:	f1 e4       	ldi	r31, 0x41	; 65
    8482:	af 07       	cpc	r26, r31
    8484:	f1 e6       	ldi	r31, 0x61	; 97
    8486:	bf 07       	cpc	r27, r31
    8488:	89 f4       	brne	.+34     	; 0x84ac <getSetFreeCluster+0xa8>
    848a:	89 81       	ldd	r24, Y+1	; 0x01
    848c:	9a 81       	ldd	r25, Y+2	; 0x02
    848e:	84 50       	subi	r24, 0x04	; 4
    8490:	9e 4f       	sbci	r25, 0xFE	; 254
    8492:	fc 01       	movw	r30, r24
    8494:	80 81       	ld	r24, Z
    8496:	91 81       	ldd	r25, Z+1	; 0x01
    8498:	a2 81       	ldd	r26, Z+2	; 0x02
    849a:	b3 81       	ldd	r27, Z+3	; 0x03
    849c:	80 30       	cpi	r24, 0x00	; 0
    849e:	f0 e0       	ldi	r31, 0x00	; 0
    84a0:	9f 07       	cpc	r25, r31
    84a2:	f5 e5       	ldi	r31, 0x55	; 85
    84a4:	af 07       	cpc	r26, r31
    84a6:	fa ea       	ldi	r31, 0xAA	; 170
    84a8:	bf 07       	cpc	r27, r31
    84aa:	21 f0       	breq	.+8      	; 0x84b4 <getSetFreeCluster+0xb0>
  return 0xffffffff;
    84ac:	8f ef       	ldi	r24, 0xFF	; 255
    84ae:	9f ef       	ldi	r25, 0xFF	; 255
    84b0:	dc 01       	movw	r26, r24
    84b2:	51 c0       	rjmp	.+162    	; 0x8556 <getSetFreeCluster+0x152>

 if(get_set == GET)
    84b4:	8c 81       	ldd	r24, Y+4	; 0x04
    84b6:	88 23       	and	r24, r24
    84b8:	b9 f4       	brne	.+46     	; 0x84e8 <getSetFreeCluster+0xe4>
 {
   if(totOrNext == TOTAL_FREE)
    84ba:	8b 81       	ldd	r24, Y+3	; 0x03
    84bc:	81 30       	cpi	r24, 0x01	; 1
    84be:	51 f4       	brne	.+20     	; 0x84d4 <getSetFreeCluster+0xd0>
      return(FS->freeClusterCount);
    84c0:	89 81       	ldd	r24, Y+1	; 0x01
    84c2:	9a 81       	ldd	r25, Y+2	; 0x02
    84c4:	88 51       	subi	r24, 0x18	; 24
    84c6:	9e 4f       	sbci	r25, 0xFE	; 254
    84c8:	fc 01       	movw	r30, r24
    84ca:	80 81       	ld	r24, Z
    84cc:	91 81       	ldd	r25, Z+1	; 0x01
    84ce:	a2 81       	ldd	r26, Z+2	; 0x02
    84d0:	b3 81       	ldd	r27, Z+3	; 0x03
    84d2:	41 c0       	rjmp	.+130    	; 0x8556 <getSetFreeCluster+0x152>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    84d4:	89 81       	ldd	r24, Y+1	; 0x01
    84d6:	9a 81       	ldd	r25, Y+2	; 0x02
    84d8:	84 51       	subi	r24, 0x14	; 20
    84da:	9e 4f       	sbci	r25, 0xFE	; 254
    84dc:	fc 01       	movw	r30, r24
    84de:	80 81       	ld	r24, Z
    84e0:	91 81       	ldd	r25, Z+1	; 0x01
    84e2:	a2 81       	ldd	r26, Z+2	; 0x02
    84e4:	b3 81       	ldd	r27, Z+3	; 0x03
    84e6:	37 c0       	rjmp	.+110    	; 0x8556 <getSetFreeCluster+0x152>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    84e8:	8b 81       	ldd	r24, Y+3	; 0x03
    84ea:	81 30       	cpi	r24, 0x01	; 1
    84ec:	79 f4       	brne	.+30     	; 0x850c <getSetFreeCluster+0x108>
      FS->freeClusterCount = FSEntry;
    84ee:	89 81       	ldd	r24, Y+1	; 0x01
    84f0:	9a 81       	ldd	r25, Y+2	; 0x02
    84f2:	9c 01       	movw	r18, r24
    84f4:	28 51       	subi	r18, 0x18	; 24
    84f6:	3e 4f       	sbci	r19, 0xFE	; 254
    84f8:	8d 81       	ldd	r24, Y+5	; 0x05
    84fa:	9e 81       	ldd	r25, Y+6	; 0x06
    84fc:	af 81       	ldd	r26, Y+7	; 0x07
    84fe:	b8 85       	ldd	r27, Y+8	; 0x08
    8500:	f9 01       	movw	r30, r18
    8502:	80 83       	st	Z, r24
    8504:	91 83       	std	Z+1, r25	; 0x01
    8506:	a2 83       	std	Z+2, r26	; 0x02
    8508:	b3 83       	std	Z+3, r27	; 0x03
    850a:	0e c0       	rjmp	.+28     	; 0x8528 <getSetFreeCluster+0x124>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    850c:	89 81       	ldd	r24, Y+1	; 0x01
    850e:	9a 81       	ldd	r25, Y+2	; 0x02
    8510:	9c 01       	movw	r18, r24
    8512:	24 51       	subi	r18, 0x14	; 20
    8514:	3e 4f       	sbci	r19, 0xFE	; 254
    8516:	8d 81       	ldd	r24, Y+5	; 0x05
    8518:	9e 81       	ldd	r25, Y+6	; 0x06
    851a:	af 81       	ldd	r26, Y+7	; 0x07
    851c:	b8 85       	ldd	r27, Y+8	; 0x08
    851e:	f9 01       	movw	r30, r18
    8520:	80 83       	st	Z, r24
    8522:	91 83       	std	Z+1, r25	; 0x01
    8524:	a2 83       	std	Z+2, r26	; 0x02
    8526:	b3 83       	std	Z+3, r27	; 0x03
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    8528:	80 91 72 50 	lds	r24, 0x5072
    852c:	90 91 73 50 	lds	r25, 0x5073
    8530:	a0 91 74 50 	lds	r26, 0x5074
    8534:	b0 91 75 50 	lds	r27, 0x5075
    8538:	01 96       	adiw	r24, 0x01	; 1
    853a:	a1 1d       	adc	r26, r1
    853c:	b1 1d       	adc	r27, r1
    853e:	23 ec       	ldi	r18, 0xC3	; 195
    8540:	31 e2       	ldi	r19, 0x21	; 33
    8542:	bc 01       	movw	r22, r24
    8544:	cd 01       	movw	r24, r26
    8546:	a9 01       	movw	r20, r18
    8548:	20 e0       	ldi	r18, 0x00	; 0
    854a:	32 e0       	ldi	r19, 0x02	; 2
    854c:	0e 94 84 4e 	call	0x9d08	; 0x9d08 <SD_write_block>
 }
 return 0xffffffff;
    8550:	8f ef       	ldi	r24, 0xFF	; 255
    8552:	9f ef       	ldi	r25, 0xFF	; 255
    8554:	dc 01       	movw	r26, r24
}
    8556:	bc 01       	movw	r22, r24
    8558:	cd 01       	movw	r24, r26
    855a:	28 96       	adiw	r28, 0x08	; 8
    855c:	cd bf       	out	0x3d, r28	; 61
    855e:	de bf       	out	0x3e, r29	; 62
    8560:	df 91       	pop	r29
    8562:	cf 91       	pop	r28
    8564:	08 95       	ret

00008566 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    8566:	0f 93       	push	r16
    8568:	1f 93       	push	r17
    856a:	cf 93       	push	r28
    856c:	df 93       	push	r29
    856e:	cd b7       	in	r28, 0x3d	; 61
    8570:	de b7       	in	r29, 0x3e	; 62
    8572:	6c 97       	sbiw	r28, 0x1c	; 28
    8574:	cd bf       	out	0x3d, r28	; 61
    8576:	de bf       	out	0x3e, r29	; 62
    8578:	8a 8f       	std	Y+26, r24	; 0x1a
    857a:	6b 8f       	std	Y+27, r22	; 0x1b
    857c:	7c 8f       	std	Y+28, r23	; 0x1c
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    857e:	80 91 54 40 	lds	r24, 0x4054
    8582:	90 91 55 40 	lds	r25, 0x4055
    8586:	a0 91 56 40 	lds	r26, 0x4056
    858a:	b0 91 57 40 	lds	r27, 0x4057
    858e:	89 83       	std	Y+1, r24	; 0x01
    8590:	9a 83       	std	Y+2, r25	; 0x02
    8592:	ab 83       	std	Y+3, r26	; 0x03
    8594:	bc 83       	std	Y+4, r27	; 0x04
    8596:	01 c0       	rjmp	.+2      	; 0x859a <findFiles+0x34>
   if(cluster > 0x0ffffff6)
   	 return 0;
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
    8598:	00 00       	nop

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    859a:	89 81       	ldd	r24, Y+1	; 0x01
    859c:	9a 81       	ldd	r25, Y+2	; 0x02
    859e:	ab 81       	ldd	r26, Y+3	; 0x03
    85a0:	bc 81       	ldd	r27, Y+4	; 0x04
    85a2:	bc 01       	movw	r22, r24
    85a4:	cd 01       	movw	r24, r26
    85a6:	0e 94 26 41 	call	0x824c	; 0x824c <getFirstSector>
    85aa:	dc 01       	movw	r26, r24
    85ac:	cb 01       	movw	r24, r22
    85ae:	88 8b       	std	Y+16, r24	; 0x10
    85b0:	99 8b       	std	Y+17, r25	; 0x11
    85b2:	aa 8b       	std	Y+18, r26	; 0x12
    85b4:	bb 8b       	std	Y+19, r27	; 0x13

   for(sector = 0; sector < sectorPerCluster; sector++)
    85b6:	1d 82       	std	Y+5, r1	; 0x05
    85b8:	1e 82       	std	Y+6, r1	; 0x06
    85ba:	1f 82       	std	Y+7, r1	; 0x07
    85bc:	18 86       	std	Y+8, r1	; 0x08
    85be:	68 c1       	rjmp	.+720    	; 0x8890 <findFiles+0x32a>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    85c0:	28 89       	ldd	r18, Y+16	; 0x10
    85c2:	39 89       	ldd	r19, Y+17	; 0x11
    85c4:	4a 89       	ldd	r20, Y+18	; 0x12
    85c6:	5b 89       	ldd	r21, Y+19	; 0x13
    85c8:	8d 81       	ldd	r24, Y+5	; 0x05
    85ca:	9e 81       	ldd	r25, Y+6	; 0x06
    85cc:	af 81       	ldd	r26, Y+7	; 0x07
    85ce:	b8 85       	ldd	r27, Y+8	; 0x08
    85d0:	82 0f       	add	r24, r18
    85d2:	93 1f       	adc	r25, r19
    85d4:	a4 1f       	adc	r26, r20
    85d6:	b5 1f       	adc	r27, r21
    85d8:	23 ec       	ldi	r18, 0xC3	; 195
    85da:	31 e2       	ldi	r19, 0x21	; 33
    85dc:	bc 01       	movw	r22, r24
    85de:	cd 01       	movw	r24, r26
    85e0:	a9 01       	movw	r20, r18
    85e2:	0e 94 52 4f 	call	0x9ea4	; 0x9ea4 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    85e6:	1d 86       	std	Y+13, r1	; 0x0d
    85e8:	1e 86       	std	Y+14, r1	; 0x0e
    85ea:	3d c1       	rjmp	.+634    	; 0x8866 <findFiles+0x300>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    85ec:	8d 85       	ldd	r24, Y+13	; 0x0d
    85ee:	9e 85       	ldd	r25, Y+14	; 0x0e
    85f0:	8d 53       	subi	r24, 0x3D	; 61
    85f2:	9e 4d       	sbci	r25, 0xDE	; 222
    85f4:	8c 8b       	std	Y+20, r24	; 0x14
    85f6:	9d 8b       	std	Y+21, r25	; 0x15

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    85f8:	8c 89       	ldd	r24, Y+20	; 0x14
    85fa:	9d 89       	ldd	r25, Y+21	; 0x15
    85fc:	fc 01       	movw	r30, r24
    85fe:	80 81       	ld	r24, Z
    8600:	88 23       	and	r24, r24
    8602:	19 f4       	brne	.+6      	; 0x860a <findFiles+0xa4>
		{
		  return 0;   
    8604:	80 e0       	ldi	r24, 0x00	; 0
    8606:	90 e0       	ldi	r25, 0x00	; 0
    8608:	80 c1       	rjmp	.+768    	; 0x890a <findFiles+0x3a4>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    860a:	8c 89       	ldd	r24, Y+20	; 0x14
    860c:	9d 89       	ldd	r25, Y+21	; 0x15
    860e:	fc 01       	movw	r30, r24
    8610:	80 81       	ld	r24, Z
    8612:	85 3e       	cpi	r24, 0xE5	; 229
    8614:	09 f4       	brne	.+2      	; 0x8618 <findFiles+0xb2>
    8616:	22 c1       	rjmp	.+580    	; 0x885c <findFiles+0x2f6>
    8618:	8c 89       	ldd	r24, Y+20	; 0x14
    861a:	9d 89       	ldd	r25, Y+21	; 0x15
    861c:	fc 01       	movw	r30, r24
    861e:	83 85       	ldd	r24, Z+11	; 0x0b
    8620:	8f 30       	cpi	r24, 0x0F	; 15
    8622:	09 f4       	brne	.+2      	; 0x8626 <findFiles+0xc0>
    8624:	1b c1       	rjmp	.+566    	; 0x885c <findFiles+0x2f6>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    8626:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8628:	81 30       	cpi	r24, 0x01	; 1
    862a:	21 f0       	breq	.+8      	; 0x8634 <findFiles+0xce>
    862c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    862e:	82 30       	cpi	r24, 0x02	; 2
    8630:	09 f0       	breq	.+2      	; 0x8634 <findFiles+0xce>
    8632:	11 c1       	rjmp	.+546    	; 0x8856 <findFiles+0x2f0>
          {
            for(j=0; j<11; j++)
    8634:	1f 86       	std	Y+15, r1	; 0x0f
    8636:	17 c0       	rjmp	.+46     	; 0x8666 <findFiles+0x100>
            if(dir->name[j] != fileName[j]) break;
    8638:	8f 85       	ldd	r24, Y+15	; 0x0f
    863a:	88 2f       	mov	r24, r24
    863c:	90 e0       	ldi	r25, 0x00	; 0
    863e:	2c 89       	ldd	r18, Y+20	; 0x14
    8640:	3d 89       	ldd	r19, Y+21	; 0x15
    8642:	82 0f       	add	r24, r18
    8644:	93 1f       	adc	r25, r19
    8646:	fc 01       	movw	r30, r24
    8648:	40 81       	ld	r20, Z
    864a:	8f 85       	ldd	r24, Y+15	; 0x0f
    864c:	88 2f       	mov	r24, r24
    864e:	90 e0       	ldi	r25, 0x00	; 0
    8650:	2b 8d       	ldd	r18, Y+27	; 0x1b
    8652:	3c 8d       	ldd	r19, Y+28	; 0x1c
    8654:	82 0f       	add	r24, r18
    8656:	93 1f       	adc	r25, r19
    8658:	fc 01       	movw	r30, r24
    865a:	80 81       	ld	r24, Z
    865c:	48 17       	cp	r20, r24
    865e:	39 f4       	brne	.+14     	; 0x866e <findFiles+0x108>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    8660:	8f 85       	ldd	r24, Y+15	; 0x0f
    8662:	8f 5f       	subi	r24, 0xFF	; 255
    8664:	8f 87       	std	Y+15, r24	; 0x0f
    8666:	8f 85       	ldd	r24, Y+15	; 0x0f
    8668:	8b 30       	cpi	r24, 0x0B	; 11
    866a:	30 f3       	brcs	.-52     	; 0x8638 <findFiles+0xd2>
    866c:	01 c0       	rjmp	.+2      	; 0x8670 <findFiles+0x10a>
            if(dir->name[j] != fileName[j]) break;
    866e:	00 00       	nop
            if(j == 11)
    8670:	8f 85       	ldd	r24, Y+15	; 0x0f
    8672:	8b 30       	cpi	r24, 0x0B	; 11
    8674:	09 f0       	breq	.+2      	; 0x8678 <findFiles+0x112>
    8676:	f2 c0       	rjmp	.+484    	; 0x885c <findFiles+0x2f6>
			{
			  if(flag == GET_FILE)
    8678:	8a 8d       	ldd	r24, Y+26	; 0x1a
    867a:	81 30       	cpi	r24, 0x01	; 1
    867c:	09 f0       	breq	.+2      	; 0x8680 <findFiles+0x11a>
    867e:	52 c0       	rjmp	.+164    	; 0x8724 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    8680:	28 89       	ldd	r18, Y+16	; 0x10
    8682:	39 89       	ldd	r19, Y+17	; 0x11
    8684:	4a 89       	ldd	r20, Y+18	; 0x12
    8686:	5b 89       	ldd	r21, Y+19	; 0x13
    8688:	8d 81       	ldd	r24, Y+5	; 0x05
    868a:	9e 81       	ldd	r25, Y+6	; 0x06
    868c:	af 81       	ldd	r26, Y+7	; 0x07
    868e:	b8 85       	ldd	r27, Y+8	; 0x08
    8690:	82 0f       	add	r24, r18
    8692:	93 1f       	adc	r25, r19
    8694:	a4 1f       	adc	r26, r20
    8696:	b5 1f       	adc	r27, r21
    8698:	80 93 c6 50 	sts	0x50C6, r24
    869c:	90 93 c7 50 	sts	0x50C7, r25
    86a0:	a0 93 c8 50 	sts	0x50C8, r26
    86a4:	b0 93 c9 50 	sts	0x50C9, r27
				appendFileLocation = i;
    86a8:	8d 85       	ldd	r24, Y+13	; 0x0d
    86aa:	9e 85       	ldd	r25, Y+14	; 0x0e
    86ac:	cc 01       	movw	r24, r24
    86ae:	a0 e0       	ldi	r26, 0x00	; 0
    86b0:	b0 e0       	ldi	r27, 0x00	; 0
    86b2:	80 93 c4 23 	sts	0x23C4, r24
    86b6:	90 93 c5 23 	sts	0x23C5, r25
    86ba:	a0 93 c6 23 	sts	0x23C6, r26
    86be:	b0 93 c7 23 	sts	0x23C7, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    86c2:	8c 89       	ldd	r24, Y+20	; 0x14
    86c4:	9d 89       	ldd	r25, Y+21	; 0x15
    86c6:	fc 01       	movw	r30, r24
    86c8:	84 89       	ldd	r24, Z+20	; 0x14
    86ca:	95 89       	ldd	r25, Z+21	; 0x15
    86cc:	cc 01       	movw	r24, r24
    86ce:	a0 e0       	ldi	r26, 0x00	; 0
    86d0:	b0 e0       	ldi	r27, 0x00	; 0
    86d2:	ac 01       	movw	r20, r24
    86d4:	33 27       	eor	r19, r19
    86d6:	22 27       	eor	r18, r18
    86d8:	8c 89       	ldd	r24, Y+20	; 0x14
    86da:	9d 89       	ldd	r25, Y+21	; 0x15
    86dc:	fc 01       	movw	r30, r24
    86de:	82 8d       	ldd	r24, Z+26	; 0x1a
    86e0:	93 8d       	ldd	r25, Z+27	; 0x1b
    86e2:	cc 01       	movw	r24, r24
    86e4:	a0 e0       	ldi	r26, 0x00	; 0
    86e6:	b0 e0       	ldi	r27, 0x00	; 0
    86e8:	82 2b       	or	r24, r18
    86ea:	93 2b       	or	r25, r19
    86ec:	a4 2b       	or	r26, r20
    86ee:	b5 2b       	or	r27, r21
    86f0:	80 93 7c 50 	sts	0x507C, r24
    86f4:	90 93 7d 50 	sts	0x507D, r25
    86f8:	a0 93 7e 50 	sts	0x507E, r26
    86fc:	b0 93 7f 50 	sts	0x507F, r27
				fileSize = dir->fileSize;
    8700:	8c 89       	ldd	r24, Y+20	; 0x14
    8702:	9d 89       	ldd	r25, Y+21	; 0x15
    8704:	fc 01       	movw	r30, r24
    8706:	84 8d       	ldd	r24, Z+28	; 0x1c
    8708:	95 8d       	ldd	r25, Z+29	; 0x1d
    870a:	a6 8d       	ldd	r26, Z+30	; 0x1e
    870c:	b7 8d       	ldd	r27, Z+31	; 0x1f
    870e:	80 93 3d 40 	sts	0x403D, r24
    8712:	90 93 3e 40 	sts	0x403E, r25
    8716:	a0 93 3f 40 	sts	0x403F, r26
    871a:	b0 93 40 40 	sts	0x4040, r27
			    return (dir);
    871e:	8c 89       	ldd	r24, Y+20	; 0x14
    8720:	9d 89       	ldd	r25, Y+21	; 0x15
    8722:	f3 c0       	rjmp	.+486    	; 0x890a <findFiles+0x3a4>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8724:	8c 89       	ldd	r24, Y+20	; 0x14
    8726:	9d 89       	ldd	r25, Y+21	; 0x15
    8728:	fc 01       	movw	r30, r24
    872a:	84 89       	ldd	r24, Z+20	; 0x14
    872c:	95 89       	ldd	r25, Z+21	; 0x15
    872e:	cc 01       	movw	r24, r24
    8730:	a0 e0       	ldi	r26, 0x00	; 0
    8732:	b0 e0       	ldi	r27, 0x00	; 0
    8734:	ac 01       	movw	r20, r24
    8736:	33 27       	eor	r19, r19
    8738:	22 27       	eor	r18, r18
    873a:	8c 89       	ldd	r24, Y+20	; 0x14
    873c:	9d 89       	ldd	r25, Y+21	; 0x15
    873e:	fc 01       	movw	r30, r24
    8740:	82 8d       	ldd	r24, Z+26	; 0x1a
    8742:	93 8d       	ldd	r25, Z+27	; 0x1b
    8744:	cc 01       	movw	r24, r24
    8746:	a0 e0       	ldi	r26, 0x00	; 0
    8748:	b0 e0       	ldi	r27, 0x00	; 0
    874a:	82 2b       	or	r24, r18
    874c:	93 2b       	or	r25, r19
    874e:	a4 2b       	or	r26, r20
    8750:	b5 2b       	or	r27, r21
    8752:	89 87       	std	Y+9, r24	; 0x09
    8754:	9a 87       	std	Y+10, r25	; 0x0a
    8756:	ab 87       	std	Y+11, r26	; 0x0b
    8758:	bc 87       	std	Y+12, r27	; 0x0c
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    875a:	8c 89       	ldd	r24, Y+20	; 0x14
    875c:	9d 89       	ldd	r25, Y+21	; 0x15
    875e:	25 ee       	ldi	r18, 0xE5	; 229
    8760:	fc 01       	movw	r30, r24
    8762:	20 83       	st	Z, r18
				 SD_write_block (firstSector+sector,SDBuffer,512);
    8764:	28 89       	ldd	r18, Y+16	; 0x10
    8766:	39 89       	ldd	r19, Y+17	; 0x11
    8768:	4a 89       	ldd	r20, Y+18	; 0x12
    876a:	5b 89       	ldd	r21, Y+19	; 0x13
    876c:	8d 81       	ldd	r24, Y+5	; 0x05
    876e:	9e 81       	ldd	r25, Y+6	; 0x06
    8770:	af 81       	ldd	r26, Y+7	; 0x07
    8772:	b8 85       	ldd	r27, Y+8	; 0x08
    8774:	82 0f       	add	r24, r18
    8776:	93 1f       	adc	r25, r19
    8778:	a4 1f       	adc	r26, r20
    877a:	b5 1f       	adc	r27, r21
    877c:	23 ec       	ldi	r18, 0xC3	; 195
    877e:	31 e2       	ldi	r19, 0x21	; 33
    8780:	bc 01       	movw	r22, r24
    8782:	cd 01       	movw	r24, r26
    8784:	a9 01       	movw	r20, r18
    8786:	20 e0       	ldi	r18, 0x00	; 0
    8788:	32 e0       	ldi	r19, 0x02	; 2
    878a:	0e 94 84 4e 	call	0x9d08	; 0x9d08 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    878e:	8c 89       	ldd	r24, Y+20	; 0x14
    8790:	9d 89       	ldd	r25, Y+21	; 0x15
    8792:	fc 01       	movw	r30, r24
    8794:	24 8d       	ldd	r18, Z+28	; 0x1c
    8796:	35 8d       	ldd	r19, Z+29	; 0x1d
    8798:	46 8d       	ldd	r20, Z+30	; 0x1e
    879a:	57 8d       	ldd	r21, Z+31	; 0x1f
    879c:	80 e0       	ldi	r24, 0x00	; 0
    879e:	ba 01       	movw	r22, r20
    87a0:	a9 01       	movw	r20, r18
    87a2:	0e 94 21 4b 	call	0x9642	; 0x9642 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    87a6:	82 e0       	ldi	r24, 0x02	; 2
    87a8:	60 e0       	ldi	r22, 0x00	; 0
    87aa:	20 e0       	ldi	r18, 0x00	; 0
    87ac:	30 e0       	ldi	r19, 0x00	; 0
    87ae:	a9 01       	movw	r20, r18
    87b0:	0e 94 02 42 	call	0x8404	; 0x8404 <getSetFreeCluster>
    87b4:	dc 01       	movw	r26, r24
    87b6:	cb 01       	movw	r24, r22
    87b8:	89 83       	std	Y+1, r24	; 0x01
    87ba:	9a 83       	std	Y+2, r25	; 0x02
    87bc:	ab 83       	std	Y+3, r26	; 0x03
    87be:	bc 83       	std	Y+4, r27	; 0x04
				 if(firstCluster < cluster)
    87c0:	29 85       	ldd	r18, Y+9	; 0x09
    87c2:	3a 85       	ldd	r19, Y+10	; 0x0a
    87c4:	4b 85       	ldd	r20, Y+11	; 0x0b
    87c6:	5c 85       	ldd	r21, Y+12	; 0x0c
    87c8:	89 81       	ldd	r24, Y+1	; 0x01
    87ca:	9a 81       	ldd	r25, Y+2	; 0x02
    87cc:	ab 81       	ldd	r26, Y+3	; 0x03
    87ce:	bc 81       	ldd	r27, Y+4	; 0x04
    87d0:	28 17       	cp	r18, r24
    87d2:	39 07       	cpc	r19, r25
    87d4:	4a 07       	cpc	r20, r26
    87d6:	5b 07       	cpc	r21, r27
    87d8:	40 f4       	brcc	.+16     	; 0x87ea <findFiles+0x284>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    87da:	29 85       	ldd	r18, Y+9	; 0x09
    87dc:	3a 85       	ldd	r19, Y+10	; 0x0a
    87de:	4b 85       	ldd	r20, Y+11	; 0x0b
    87e0:	5c 85       	ldd	r21, Y+12	; 0x0c
    87e2:	82 e0       	ldi	r24, 0x02	; 2
    87e4:	61 e0       	ldi	r22, 0x01	; 1
    87e6:	0e 94 02 42 	call	0x8404	; 0x8404 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    87ea:	89 85       	ldd	r24, Y+9	; 0x09
    87ec:	9a 85       	ldd	r25, Y+10	; 0x0a
    87ee:	ab 85       	ldd	r26, Y+11	; 0x0b
    87f0:	bc 85       	ldd	r27, Y+12	; 0x0c
    87f2:	bc 01       	movw	r22, r24
    87f4:	cd 01       	movw	r24, r26
    87f6:	40 e0       	ldi	r20, 0x00	; 0
    87f8:	00 e0       	ldi	r16, 0x00	; 0
    87fa:	10 e0       	ldi	r17, 0x00	; 0
    87fc:	98 01       	movw	r18, r16
    87fe:	0e 94 58 41 	call	0x82b0	; 0x82b0 <getSetNextCluster>
    8802:	dc 01       	movw	r26, r24
    8804:	cb 01       	movw	r24, r22
    8806:	8e 8b       	std	Y+22, r24	; 0x16
    8808:	9f 8b       	std	Y+23, r25	; 0x17
    880a:	a8 8f       	std	Y+24, r26	; 0x18
    880c:	b9 8f       	std	Y+25, r27	; 0x19
					getSetNextCluster (firstCluster, SET, 0);
    880e:	89 85       	ldd	r24, Y+9	; 0x09
    8810:	9a 85       	ldd	r25, Y+10	; 0x0a
    8812:	ab 85       	ldd	r26, Y+11	; 0x0b
    8814:	bc 85       	ldd	r27, Y+12	; 0x0c
    8816:	bc 01       	movw	r22, r24
    8818:	cd 01       	movw	r24, r26
    881a:	41 e0       	ldi	r20, 0x01	; 1
    881c:	00 e0       	ldi	r16, 0x00	; 0
    881e:	10 e0       	ldi	r17, 0x00	; 0
    8820:	98 01       	movw	r18, r16
    8822:	0e 94 58 41 	call	0x82b0	; 0x82b0 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    8826:	8e 89       	ldd	r24, Y+22	; 0x16
    8828:	9f 89       	ldd	r25, Y+23	; 0x17
    882a:	a8 8d       	ldd	r26, Y+24	; 0x18
    882c:	b9 8d       	ldd	r27, Y+25	; 0x19
    882e:	87 3f       	cpi	r24, 0xF7	; 247
    8830:	ff ef       	ldi	r31, 0xFF	; 255
    8832:	9f 07       	cpc	r25, r31
    8834:	ff ef       	ldi	r31, 0xFF	; 255
    8836:	af 07       	cpc	r26, r31
    8838:	ff e0       	ldi	r31, 0x0F	; 15
    883a:	bf 07       	cpc	r27, r31
    883c:	18 f0       	brcs	.+6      	; 0x8844 <findFiles+0x2de>
					   {//file deleted
						   return 0;}
    883e:	80 e0       	ldi	r24, 0x00	; 0
    8840:	90 e0       	ldi	r25, 0x00	; 0
    8842:	63 c0       	rjmp	.+198    	; 0x890a <findFiles+0x3a4>
					firstCluster = nextCluster;
    8844:	8e 89       	ldd	r24, Y+22	; 0x16
    8846:	9f 89       	ldd	r25, Y+23	; 0x17
    8848:	a8 8d       	ldd	r26, Y+24	; 0x18
    884a:	b9 8d       	ldd	r27, Y+25	; 0x19
    884c:	89 87       	std	Y+9, r24	; 0x09
    884e:	9a 87       	std	Y+10, r25	; 0x0a
    8850:	ab 87       	std	Y+11, r26	; 0x0b
    8852:	bc 87       	std	Y+12, r27	; 0x0c
			  	 } 
    8854:	ca cf       	rjmp	.-108    	; 0x87ea <findFiles+0x284>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    8856:	80 e0       	ldi	r24, 0x00	; 0
    8858:	90 e0       	ldi	r25, 0x00	; 0
    885a:	57 c0       	rjmp	.+174    	; 0x890a <findFiles+0x3a4>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    885c:	8d 85       	ldd	r24, Y+13	; 0x0d
    885e:	9e 85       	ldd	r25, Y+14	; 0x0e
    8860:	80 96       	adiw	r24, 0x20	; 32
    8862:	8d 87       	std	Y+13, r24	; 0x0d
    8864:	9e 87       	std	Y+14, r25	; 0x0e
    8866:	80 91 41 40 	lds	r24, 0x4041
    886a:	90 91 42 40 	lds	r25, 0x4042
    886e:	2d 85       	ldd	r18, Y+13	; 0x0d
    8870:	3e 85       	ldd	r19, Y+14	; 0x0e
    8872:	28 17       	cp	r18, r24
    8874:	39 07       	cpc	r19, r25
    8876:	08 f4       	brcc	.+2      	; 0x887a <findFiles+0x314>
    8878:	b9 ce       	rjmp	.-654    	; 0x85ec <findFiles+0x86>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    887a:	8d 81       	ldd	r24, Y+5	; 0x05
    887c:	9e 81       	ldd	r25, Y+6	; 0x06
    887e:	af 81       	ldd	r26, Y+7	; 0x07
    8880:	b8 85       	ldd	r27, Y+8	; 0x08
    8882:	01 96       	adiw	r24, 0x01	; 1
    8884:	a1 1d       	adc	r26, r1
    8886:	b1 1d       	adc	r27, r1
    8888:	8d 83       	std	Y+5, r24	; 0x05
    888a:	9e 83       	std	Y+6, r25	; 0x06
    888c:	af 83       	std	Y+7, r26	; 0x07
    888e:	b8 87       	std	Y+8, r27	; 0x08
    8890:	80 91 70 50 	lds	r24, 0x5070
    8894:	90 91 71 50 	lds	r25, 0x5071
    8898:	9c 01       	movw	r18, r24
    889a:	40 e0       	ldi	r20, 0x00	; 0
    889c:	50 e0       	ldi	r21, 0x00	; 0
    889e:	8d 81       	ldd	r24, Y+5	; 0x05
    88a0:	9e 81       	ldd	r25, Y+6	; 0x06
    88a2:	af 81       	ldd	r26, Y+7	; 0x07
    88a4:	b8 85       	ldd	r27, Y+8	; 0x08
    88a6:	82 17       	cp	r24, r18
    88a8:	93 07       	cpc	r25, r19
    88aa:	a4 07       	cpc	r26, r20
    88ac:	b5 07       	cpc	r27, r21
    88ae:	08 f4       	brcc	.+2      	; 0x88b2 <findFiles+0x34c>
    88b0:	87 ce       	rjmp	.-754    	; 0x85c0 <findFiles+0x5a>
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    88b2:	89 81       	ldd	r24, Y+1	; 0x01
    88b4:	9a 81       	ldd	r25, Y+2	; 0x02
    88b6:	ab 81       	ldd	r26, Y+3	; 0x03
    88b8:	bc 81       	ldd	r27, Y+4	; 0x04
    88ba:	bc 01       	movw	r22, r24
    88bc:	cd 01       	movw	r24, r26
    88be:	40 e0       	ldi	r20, 0x00	; 0
    88c0:	00 e0       	ldi	r16, 0x00	; 0
    88c2:	10 e0       	ldi	r17, 0x00	; 0
    88c4:	98 01       	movw	r18, r16
    88c6:	0e 94 58 41 	call	0x82b0	; 0x82b0 <getSetNextCluster>
    88ca:	dc 01       	movw	r26, r24
    88cc:	cb 01       	movw	r24, r22
    88ce:	89 83       	std	Y+1, r24	; 0x01
    88d0:	9a 83       	std	Y+2, r25	; 0x02
    88d2:	ab 83       	std	Y+3, r26	; 0x03
    88d4:	bc 83       	std	Y+4, r27	; 0x04

   if(cluster > 0x0ffffff6)
    88d6:	89 81       	ldd	r24, Y+1	; 0x01
    88d8:	9a 81       	ldd	r25, Y+2	; 0x02
    88da:	ab 81       	ldd	r26, Y+3	; 0x03
    88dc:	bc 81       	ldd	r27, Y+4	; 0x04
    88de:	87 3f       	cpi	r24, 0xF7	; 247
    88e0:	2f ef       	ldi	r18, 0xFF	; 255
    88e2:	92 07       	cpc	r25, r18
    88e4:	2f ef       	ldi	r18, 0xFF	; 255
    88e6:	a2 07       	cpc	r26, r18
    88e8:	2f e0       	ldi	r18, 0x0F	; 15
    88ea:	b2 07       	cpc	r27, r18
    88ec:	18 f0       	brcs	.+6      	; 0x88f4 <findFiles+0x38e>
   	 return 0;
    88ee:	80 e0       	ldi	r24, 0x00	; 0
    88f0:	90 e0       	ldi	r25, 0x00	; 0
    88f2:	0b c0       	rjmp	.+22     	; 0x890a <findFiles+0x3a4>
   if(cluster == 0) 
    88f4:	89 81       	ldd	r24, Y+1	; 0x01
    88f6:	9a 81       	ldd	r25, Y+2	; 0x02
    88f8:	ab 81       	ldd	r26, Y+3	; 0x03
    88fa:	bc 81       	ldd	r27, Y+4	; 0x04
    88fc:	00 97       	sbiw	r24, 0x00	; 0
    88fe:	a1 05       	cpc	r26, r1
    8900:	b1 05       	cpc	r27, r1
    8902:	09 f0       	breq	.+2      	; 0x8906 <findFiles+0x3a0>
    8904:	49 ce       	rjmp	.-878    	; 0x8598 <findFiles+0x32>
   {//error in getting cluster
	   return 0;}
    8906:	80 e0       	ldi	r24, 0x00	; 0
    8908:	90 e0       	ldi	r25, 0x00	; 0
 }
return 0;
}
    890a:	6c 96       	adiw	r28, 0x1c	; 28
    890c:	cd bf       	out	0x3d, r28	; 61
    890e:	de bf       	out	0x3e, r29	; 62
    8910:	df 91       	pop	r29
    8912:	cf 91       	pop	r28
    8914:	1f 91       	pop	r17
    8916:	0f 91       	pop	r16
    8918:	08 95       	ret

0000891a <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    891a:	0f 93       	push	r16
    891c:	1f 93       	push	r17
    891e:	cf 93       	push	r28
    8920:	df 93       	push	r29
    8922:	cd b7       	in	r28, 0x3d	; 61
    8924:	de b7       	in	r29, 0x3e	; 62
    8926:	67 97       	sbiw	r28, 0x17	; 23
    8928:	cd bf       	out	0x3d, r28	; 61
    892a:	de bf       	out	0x3e, r29	; 62
    892c:	8d 8b       	std	Y+21, r24	; 0x15
    892e:	6e 8b       	std	Y+22, r22	; 0x16
    8930:	7f 8b       	std	Y+23, r23	; 0x17
struct dir_Structure *dir;
unsigned long cluster, byteCounter = 0, fileSize, firstSector;
    8932:	1e 82       	std	Y+6, r1	; 0x06
    8934:	1f 82       	std	Y+7, r1	; 0x07
    8936:	18 86       	std	Y+8, r1	; 0x08
    8938:	19 86       	std	Y+9, r1	; 0x09
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    893a:	8e 89       	ldd	r24, Y+22	; 0x16
    893c:	9f 89       	ldd	r25, Y+23	; 0x17
    893e:	0e 94 3c 45 	call	0x8a78	; 0x8a78 <convertFileName>
    8942:	8a 87       	std	Y+10, r24	; 0x0a
if(error) return 2;
    8944:	8a 85       	ldd	r24, Y+10	; 0x0a
    8946:	88 23       	and	r24, r24
    8948:	11 f0       	breq	.+4      	; 0x894e <readFile+0x34>
    894a:	82 e0       	ldi	r24, 0x02	; 2
    894c:	8d c0       	rjmp	.+282    	; 0x8a68 <readFile+0x14e>

dir = findFiles (GET_FILE, Filename); //get the file location
    894e:	20 eb       	ldi	r18, 0xB0	; 176
    8950:	30 e5       	ldi	r19, 0x50	; 80
    8952:	81 e0       	ldi	r24, 0x01	; 1
    8954:	b9 01       	movw	r22, r18
    8956:	0e 94 b3 42 	call	0x8566	; 0x8566 <findFiles>
    895a:	8b 87       	std	Y+11, r24	; 0x0b
    895c:	9c 87       	std	Y+12, r25	; 0x0c
if(dir == 0) 
    895e:	8b 85       	ldd	r24, Y+11	; 0x0b
    8960:	9c 85       	ldd	r25, Y+12	; 0x0c
    8962:	00 97       	sbiw	r24, 0x00	; 0
    8964:	39 f4       	brne	.+14     	; 0x8974 <readFile+0x5a>
{
  if(flag == READ) return (1);
    8966:	8d 89       	ldd	r24, Y+21	; 0x15
    8968:	88 23       	and	r24, r24
    896a:	11 f4       	brne	.+4      	; 0x8970 <readFile+0x56>
    896c:	81 e0       	ldi	r24, 0x01	; 1
    896e:	7c c0       	rjmp	.+248    	; 0x8a68 <readFile+0x14e>
  else return (0);
    8970:	80 e0       	ldi	r24, 0x00	; 0
    8972:	7a c0       	rjmp	.+244    	; 0x8a68 <readFile+0x14e>
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    8974:	8d 89       	ldd	r24, Y+21	; 0x15
    8976:	81 30       	cpi	r24, 0x01	; 1
    8978:	11 f4       	brne	.+4      	; 0x897e <readFile+0x64>
    897a:	81 e0       	ldi	r24, 0x01	; 1
    897c:	75 c0       	rjmp	.+234    	; 0x8a68 <readFile+0x14e>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    897e:	8b 85       	ldd	r24, Y+11	; 0x0b
    8980:	9c 85       	ldd	r25, Y+12	; 0x0c
    8982:	fc 01       	movw	r30, r24
    8984:	84 89       	ldd	r24, Z+20	; 0x14
    8986:	95 89       	ldd	r25, Z+21	; 0x15
    8988:	cc 01       	movw	r24, r24
    898a:	a0 e0       	ldi	r26, 0x00	; 0
    898c:	b0 e0       	ldi	r27, 0x00	; 0
    898e:	ac 01       	movw	r20, r24
    8990:	33 27       	eor	r19, r19
    8992:	22 27       	eor	r18, r18
    8994:	8b 85       	ldd	r24, Y+11	; 0x0b
    8996:	9c 85       	ldd	r25, Y+12	; 0x0c
    8998:	fc 01       	movw	r30, r24
    899a:	82 8d       	ldd	r24, Z+26	; 0x1a
    899c:	93 8d       	ldd	r25, Z+27	; 0x1b
    899e:	cc 01       	movw	r24, r24
    89a0:	a0 e0       	ldi	r26, 0x00	; 0
    89a2:	b0 e0       	ldi	r27, 0x00	; 0
    89a4:	82 2b       	or	r24, r18
    89a6:	93 2b       	or	r25, r19
    89a8:	a4 2b       	or	r26, r20
    89aa:	b5 2b       	or	r27, r21
    89ac:	89 83       	std	Y+1, r24	; 0x01
    89ae:	9a 83       	std	Y+2, r25	; 0x02
    89b0:	ab 83       	std	Y+3, r26	; 0x03
    89b2:	bc 83       	std	Y+4, r27	; 0x04

fileSize = dir->fileSize;
    89b4:	8b 85       	ldd	r24, Y+11	; 0x0b
    89b6:	9c 85       	ldd	r25, Y+12	; 0x0c
    89b8:	fc 01       	movw	r30, r24
    89ba:	84 8d       	ldd	r24, Z+28	; 0x1c
    89bc:	95 8d       	ldd	r25, Z+29	; 0x1d
    89be:	a6 8d       	ldd	r26, Z+30	; 0x1e
    89c0:	b7 8d       	ldd	r27, Z+31	; 0x1f
    89c2:	8d 87       	std	Y+13, r24	; 0x0d
    89c4:	9e 87       	std	Y+14, r25	; 0x0e
    89c6:	af 87       	std	Y+15, r26	; 0x0f
    89c8:	b8 8b       	std	Y+16, r27	; 0x10
    89ca:	01 c0       	rjmp	.+2      	; 0x89ce <readFile+0xb4>
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
    89cc:	00 00       	nop
fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    89ce:	89 81       	ldd	r24, Y+1	; 0x01
    89d0:	9a 81       	ldd	r25, Y+2	; 0x02
    89d2:	ab 81       	ldd	r26, Y+3	; 0x03
    89d4:	bc 81       	ldd	r27, Y+4	; 0x04
    89d6:	bc 01       	movw	r22, r24
    89d8:	cd 01       	movw	r24, r26
    89da:	0e 94 26 41 	call	0x824c	; 0x824c <getFirstSector>
    89de:	dc 01       	movw	r26, r24
    89e0:	cb 01       	movw	r24, r22
    89e2:	89 8b       	std	Y+17, r24	; 0x11
    89e4:	9a 8b       	std	Y+18, r25	; 0x12
    89e6:	ab 8b       	std	Y+19, r26	; 0x13
    89e8:	bc 8b       	std	Y+20, r27	; 0x14

  for(j=0; j<sectorPerCluster; j++)
    89ea:	1d 82       	std	Y+5, r1	; 0x05
    89ec:	17 c0       	rjmp	.+46     	; 0x8a1c <readFile+0x102>
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    89ee:	8d 81       	ldd	r24, Y+5	; 0x05
    89f0:	28 2f       	mov	r18, r24
    89f2:	30 e0       	ldi	r19, 0x00	; 0
    89f4:	40 e0       	ldi	r20, 0x00	; 0
    89f6:	50 e0       	ldi	r21, 0x00	; 0
    89f8:	89 89       	ldd	r24, Y+17	; 0x11
    89fa:	9a 89       	ldd	r25, Y+18	; 0x12
    89fc:	ab 89       	ldd	r26, Y+19	; 0x13
    89fe:	bc 89       	ldd	r27, Y+20	; 0x14
    8a00:	82 0f       	add	r24, r18
    8a02:	93 1f       	adc	r25, r19
    8a04:	a4 1f       	adc	r26, r20
    8a06:	b5 1f       	adc	r27, r21
    8a08:	2c ec       	ldi	r18, 0xCC	; 204
    8a0a:	33 e2       	ldi	r19, 0x23	; 35
    8a0c:	bc 01       	movw	r22, r24
    8a0e:	cd 01       	movw	r24, r26
    8a10:	a9 01       	movw	r20, r18
    8a12:	0e 94 52 4f 	call	0x9ea4	; 0x9ea4 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    8a16:	8d 81       	ldd	r24, Y+5	; 0x05
    8a18:	8f 5f       	subi	r24, 0xFF	; 255
    8a1a:	8d 83       	std	Y+5, r24	; 0x05
    8a1c:	8d 81       	ldd	r24, Y+5	; 0x05
    8a1e:	28 2f       	mov	r18, r24
    8a20:	30 e0       	ldi	r19, 0x00	; 0
    8a22:	80 91 70 50 	lds	r24, 0x5070
    8a26:	90 91 71 50 	lds	r25, 0x5071
    8a2a:	28 17       	cp	r18, r24
    8a2c:	39 07       	cpc	r19, r25
    8a2e:	f8 f2       	brcs	.-66     	; 0x89ee <readFile+0xd4>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    8a30:	89 81       	ldd	r24, Y+1	; 0x01
    8a32:	9a 81       	ldd	r25, Y+2	; 0x02
    8a34:	ab 81       	ldd	r26, Y+3	; 0x03
    8a36:	bc 81       	ldd	r27, Y+4	; 0x04
    8a38:	bc 01       	movw	r22, r24
    8a3a:	cd 01       	movw	r24, r26
    8a3c:	40 e0       	ldi	r20, 0x00	; 0
    8a3e:	00 e0       	ldi	r16, 0x00	; 0
    8a40:	10 e0       	ldi	r17, 0x00	; 0
    8a42:	98 01       	movw	r18, r16
    8a44:	0e 94 58 41 	call	0x82b0	; 0x82b0 <getSetNextCluster>
    8a48:	dc 01       	movw	r26, r24
    8a4a:	cb 01       	movw	r24, r22
    8a4c:	89 83       	std	Y+1, r24	; 0x01
    8a4e:	9a 83       	std	Y+2, r25	; 0x02
    8a50:	ab 83       	std	Y+3, r26	; 0x03
    8a52:	bc 83       	std	Y+4, r27	; 0x04
  if(cluster == 0) {//Error in getting cluster
    8a54:	89 81       	ldd	r24, Y+1	; 0x01
    8a56:	9a 81       	ldd	r25, Y+2	; 0x02
    8a58:	ab 81       	ldd	r26, Y+3	; 0x03
    8a5a:	bc 81       	ldd	r27, Y+4	; 0x04
    8a5c:	00 97       	sbiw	r24, 0x00	; 0
    8a5e:	a1 05       	cpc	r26, r1
    8a60:	b1 05       	cpc	r27, r1
    8a62:	09 f0       	breq	.+2      	; 0x8a66 <readFile+0x14c>
    8a64:	b3 cf       	rjmp	.-154    	; 0x89cc <readFile+0xb2>
	  return 0;}
    8a66:	80 e0       	ldi	r24, 0x00	; 0
}
return 0;
}
    8a68:	67 96       	adiw	r28, 0x17	; 23
    8a6a:	cd bf       	out	0x3d, r28	; 61
    8a6c:	de bf       	out	0x3e, r29	; 62
    8a6e:	df 91       	pop	r29
    8a70:	cf 91       	pop	r28
    8a72:	1f 91       	pop	r17
    8a74:	0f 91       	pop	r16
    8a76:	08 95       	ret

00008a78 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    8a78:	cf 93       	push	r28
    8a7a:	df 93       	push	r29
    8a7c:	cd b7       	in	r28, 0x3d	; 61
    8a7e:	de b7       	in	r29, 0x3e	; 62
    8a80:	62 97       	sbiw	r28, 0x12	; 18
    8a82:	cd bf       	out	0x3d, r28	; 61
    8a84:	de bf       	out	0x3e, r29	; 62
    8a86:	89 8b       	std	Y+17, r24	; 0x11
    8a88:	9a 8b       	std	Y+18, r25	; 0x12
bool NoExtension = FALSE;
    8a8a:	19 82       	std	Y+1, r1	; 0x01
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
    8a8c:	89 89       	ldd	r24, Y+17	; 0x11
    8a8e:	9a 89       	ldd	r25, Y+18	; 0x12
    8a90:	9c 01       	movw	r18, r24
    8a92:	f9 01       	movw	r30, r18
    8a94:	01 90       	ld	r0, Z+
    8a96:	00 20       	and	r0, r0
    8a98:	e9 f7       	brne	.-6      	; 0x8a94 <convertFileName+0x1c>
    8a9a:	cf 01       	movw	r24, r30
    8a9c:	01 97       	sbiw	r24, 0x01	; 1
    8a9e:	82 1b       	sub	r24, r18
    8aa0:	93 0b       	sbc	r25, r19
    8aa2:	80 31       	cpi	r24, 0x10	; 16
    8aa4:	91 05       	cpc	r25, r1
    8aa6:	10 f0       	brcs	.+4      	; 0x8aac <convertFileName+0x34>
    8aa8:	81 e0       	ldi	r24, 0x01	; 1
    8aaa:	16 c1       	rjmp	.+556    	; 0x8cd8 <convertFileName+0x260>
int i=0;
    8aac:	1c 82       	std	Y+4, r1	; 0x04
    8aae:	1d 82       	std	Y+5, r1	; 0x05
for(; i < strlen(fileName); i++){
    8ab0:	13 c0       	rjmp	.+38     	; 0x8ad8 <convertFileName+0x60>
	Filename[i] = fileName[i];
    8ab2:	8c 81       	ldd	r24, Y+4	; 0x04
    8ab4:	9d 81       	ldd	r25, Y+5	; 0x05
    8ab6:	29 89       	ldd	r18, Y+17	; 0x11
    8ab8:	3a 89       	ldd	r19, Y+18	; 0x12
    8aba:	82 0f       	add	r24, r18
    8abc:	93 1f       	adc	r25, r19
    8abe:	fc 01       	movw	r30, r24
    8ac0:	20 81       	ld	r18, Z
    8ac2:	8c 81       	ldd	r24, Y+4	; 0x04
    8ac4:	9d 81       	ldd	r25, Y+5	; 0x05
    8ac6:	80 55       	subi	r24, 0x50	; 80
    8ac8:	9f 4a       	sbci	r25, 0xAF	; 175
    8aca:	fc 01       	movw	r30, r24
    8acc:	20 83       	st	Z, r18

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
int i=0;
for(; i < strlen(fileName); i++){
    8ace:	8c 81       	ldd	r24, Y+4	; 0x04
    8ad0:	9d 81       	ldd	r25, Y+5	; 0x05
    8ad2:	01 96       	adiw	r24, 0x01	; 1
    8ad4:	8c 83       	std	Y+4, r24	; 0x04
    8ad6:	9d 83       	std	Y+5, r25	; 0x05
    8ad8:	4c 81       	ldd	r20, Y+4	; 0x04
    8ada:	5d 81       	ldd	r21, Y+5	; 0x05
    8adc:	89 89       	ldd	r24, Y+17	; 0x11
    8ade:	9a 89       	ldd	r25, Y+18	; 0x12
    8ae0:	9c 01       	movw	r18, r24
    8ae2:	f9 01       	movw	r30, r18
    8ae4:	01 90       	ld	r0, Z+
    8ae6:	00 20       	and	r0, r0
    8ae8:	e9 f7       	brne	.-6      	; 0x8ae4 <convertFileName+0x6c>
    8aea:	cf 01       	movw	r24, r30
    8aec:	01 97       	sbiw	r24, 0x01	; 1
    8aee:	82 1b       	sub	r24, r18
    8af0:	93 0b       	sbc	r25, r19
    8af2:	48 17       	cp	r20, r24
    8af4:	59 07       	cpc	r21, r25
    8af6:	e8 f2       	brcs	.-70     	; 0x8ab2 <convertFileName+0x3a>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    8af8:	0c c0       	rjmp	.+24     	; 0x8b12 <convertFileName+0x9a>
    8afa:	8c 81       	ldd	r24, Y+4	; 0x04
    8afc:	9d 81       	ldd	r25, Y+5	; 0x05
    8afe:	80 55       	subi	r24, 0x50	; 80
    8b00:	9f 4a       	sbci	r25, 0xAF	; 175
    8b02:	20 e2       	ldi	r18, 0x20	; 32
    8b04:	fc 01       	movw	r30, r24
    8b06:	20 83       	st	Z, r18
    8b08:	8c 81       	ldd	r24, Y+4	; 0x04
    8b0a:	9d 81       	ldd	r25, Y+5	; 0x05
    8b0c:	01 96       	adiw	r24, 0x01	; 1
    8b0e:	8c 83       	std	Y+4, r24	; 0x04
    8b10:	9d 83       	std	Y+5, r25	; 0x05
    8b12:	8c 81       	ldd	r24, Y+4	; 0x04
    8b14:	9d 81       	ldd	r25, Y+5	; 0x05
    8b16:	8f 30       	cpi	r24, 0x0F	; 15
    8b18:	91 05       	cpc	r25, r1
    8b1a:	7c f3       	brlt	.-34     	; 0x8afa <convertFileName+0x82>


for(j=0; j<12; j++)
    8b1c:	1a 82       	std	Y+2, r1	; 0x02
    8b1e:	0c c0       	rjmp	.+24     	; 0x8b38 <convertFileName+0xc0>
if(Filename[j] == '.') break;
    8b20:	8a 81       	ldd	r24, Y+2	; 0x02
    8b22:	88 2f       	mov	r24, r24
    8b24:	90 e0       	ldi	r25, 0x00	; 0
    8b26:	80 55       	subi	r24, 0x50	; 80
    8b28:	9f 4a       	sbci	r25, 0xAF	; 175
    8b2a:	fc 01       	movw	r30, r24
    8b2c:	80 81       	ld	r24, Z
    8b2e:	8e 32       	cpi	r24, 0x2E	; 46
    8b30:	39 f0       	breq	.+14     	; 0x8b40 <convertFileName+0xc8>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    8b32:	8a 81       	ldd	r24, Y+2	; 0x02
    8b34:	8f 5f       	subi	r24, 0xFF	; 255
    8b36:	8a 83       	std	Y+2, r24	; 0x02
    8b38:	8a 81       	ldd	r24, Y+2	; 0x02
    8b3a:	8c 30       	cpi	r24, 0x0C	; 12
    8b3c:	88 f3       	brcs	.-30     	; 0x8b20 <convertFileName+0xa8>
    8b3e:	01 c0       	rjmp	.+2      	; 0x8b42 <convertFileName+0xca>
if(Filename[j] == '.') break;
    8b40:	00 00       	nop

if(j>8 && j<12) {//Invalid fileName
    8b42:	8a 81       	ldd	r24, Y+2	; 0x02
    8b44:	89 30       	cpi	r24, 0x09	; 9
    8b46:	28 f0       	brcs	.+10     	; 0x8b52 <convertFileName+0xda>
    8b48:	8a 81       	ldd	r24, Y+2	; 0x02
    8b4a:	8c 30       	cpi	r24, 0x0C	; 12
    8b4c:	10 f4       	brcc	.+4      	; 0x8b52 <convertFileName+0xda>
	return 1;}
    8b4e:	81 e0       	ldi	r24, 0x01	; 1
    8b50:	c3 c0       	rjmp	.+390    	; 0x8cd8 <convertFileName+0x260>
else if (j==12) NoExtension=TRUE;	
    8b52:	8a 81       	ldd	r24, Y+2	; 0x02
    8b54:	8c 30       	cpi	r24, 0x0C	; 12
    8b56:	11 f4       	brne	.+4      	; 0x8b5c <convertFileName+0xe4>
    8b58:	81 e0       	ldi	r24, 0x01	; 1
    8b5a:	89 83       	std	Y+1, r24	; 0x01

for(k=0; k<j; k++) //setting file name
    8b5c:	1b 82       	std	Y+3, r1	; 0x03
    8b5e:	14 c0       	rjmp	.+40     	; 0x8b88 <convertFileName+0x110>
  fileNameFAT[k] = Filename[k];
    8b60:	8b 81       	ldd	r24, Y+3	; 0x03
    8b62:	88 2f       	mov	r24, r24
    8b64:	90 e0       	ldi	r25, 0x00	; 0
    8b66:	2b 81       	ldd	r18, Y+3	; 0x03
    8b68:	22 2f       	mov	r18, r18
    8b6a:	30 e0       	ldi	r19, 0x00	; 0
    8b6c:	20 55       	subi	r18, 0x50	; 80
    8b6e:	3f 4a       	sbci	r19, 0xAF	; 175
    8b70:	f9 01       	movw	r30, r18
    8b72:	40 81       	ld	r20, Z
    8b74:	9e 01       	movw	r18, r28
    8b76:	2a 5f       	subi	r18, 0xFA	; 250
    8b78:	3f 4f       	sbci	r19, 0xFF	; 255
    8b7a:	82 0f       	add	r24, r18
    8b7c:	93 1f       	adc	r25, r19
    8b7e:	fc 01       	movw	r30, r24
    8b80:	40 83       	st	Z, r20

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    8b82:	8b 81       	ldd	r24, Y+3	; 0x03
    8b84:	8f 5f       	subi	r24, 0xFF	; 255
    8b86:	8b 83       	std	Y+3, r24	; 0x03
    8b88:	9b 81       	ldd	r25, Y+3	; 0x03
    8b8a:	8a 81       	ldd	r24, Y+2	; 0x02
    8b8c:	98 17       	cp	r25, r24
    8b8e:	40 f3       	brcs	.-48     	; 0x8b60 <convertFileName+0xe8>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8b90:	8a 81       	ldd	r24, Y+2	; 0x02
    8b92:	8b 83       	std	Y+3, r24	; 0x03
    8b94:	0e c0       	rjmp	.+28     	; 0x8bb2 <convertFileName+0x13a>
  fileNameFAT[k] = ' ';
    8b96:	8b 81       	ldd	r24, Y+3	; 0x03
    8b98:	88 2f       	mov	r24, r24
    8b9a:	90 e0       	ldi	r25, 0x00	; 0
    8b9c:	9e 01       	movw	r18, r28
    8b9e:	2a 5f       	subi	r18, 0xFA	; 250
    8ba0:	3f 4f       	sbci	r19, 0xFF	; 255
    8ba2:	82 0f       	add	r24, r18
    8ba4:	93 1f       	adc	r25, r19
    8ba6:	20 e2       	ldi	r18, 0x20	; 32
    8ba8:	fc 01       	movw	r30, r24
    8baa:	20 83       	st	Z, r18
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8bac:	8b 81       	ldd	r24, Y+3	; 0x03
    8bae:	8f 5f       	subi	r24, 0xFF	; 255
    8bb0:	8b 83       	std	Y+3, r24	; 0x03
    8bb2:	8b 81       	ldd	r24, Y+3	; 0x03
    8bb4:	88 30       	cpi	r24, 0x08	; 8
    8bb6:	78 f3       	brcs	.-34     	; 0x8b96 <convertFileName+0x11e>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    8bb8:	99 81       	ldd	r25, Y+1	; 0x01
    8bba:	81 e0       	ldi	r24, 0x01	; 1
    8bbc:	89 27       	eor	r24, r25
    8bbe:	88 23       	and	r24, r24
    8bc0:	19 f0       	breq	.+6      	; 0x8bc8 <convertFileName+0x150>
    8bc2:	8a 81       	ldd	r24, Y+2	; 0x02
    8bc4:	8f 5f       	subi	r24, 0xFF	; 255
    8bc6:	8a 83       	std	Y+2, r24	; 0x02
for(k=8; k<11; k++) //setting file extension
    8bc8:	88 e0       	ldi	r24, 0x08	; 8
    8bca:	8b 83       	std	Y+3, r24	; 0x03
    8bcc:	32 c0       	rjmp	.+100    	; 0x8c32 <convertFileName+0x1ba>
{
  if(Filename[j] != 0)
    8bce:	8a 81       	ldd	r24, Y+2	; 0x02
    8bd0:	88 2f       	mov	r24, r24
    8bd2:	90 e0       	ldi	r25, 0x00	; 0
    8bd4:	80 55       	subi	r24, 0x50	; 80
    8bd6:	9f 4a       	sbci	r25, 0xAF	; 175
    8bd8:	fc 01       	movw	r30, r24
    8bda:	80 81       	ld	r24, Z
    8bdc:	88 23       	and	r24, r24
    8bde:	19 f1       	breq	.+70     	; 0x8c26 <convertFileName+0x1ae>
    fileNameFAT[k] = Filename[j++];
    8be0:	8b 81       	ldd	r24, Y+3	; 0x03
    8be2:	88 2f       	mov	r24, r24
    8be4:	90 e0       	ldi	r25, 0x00	; 0
    8be6:	2a 81       	ldd	r18, Y+2	; 0x02
    8be8:	22 2f       	mov	r18, r18
    8bea:	30 e0       	ldi	r19, 0x00	; 0
    8bec:	20 55       	subi	r18, 0x50	; 80
    8bee:	3f 4a       	sbci	r19, 0xAF	; 175
    8bf0:	f9 01       	movw	r30, r18
    8bf2:	40 81       	ld	r20, Z
    8bf4:	9e 01       	movw	r18, r28
    8bf6:	2a 5f       	subi	r18, 0xFA	; 250
    8bf8:	3f 4f       	sbci	r19, 0xFF	; 255
    8bfa:	82 0f       	add	r24, r18
    8bfc:	93 1f       	adc	r25, r19
    8bfe:	fc 01       	movw	r30, r24
    8c00:	40 83       	st	Z, r20
    8c02:	8a 81       	ldd	r24, Y+2	; 0x02
    8c04:	8f 5f       	subi	r24, 0xFF	; 255
    8c06:	8a 83       	std	Y+2, r24	; 0x02
    8c08:	11 c0       	rjmp	.+34     	; 0x8c2c <convertFileName+0x1b4>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    8c0a:	8b 81       	ldd	r24, Y+3	; 0x03
    8c0c:	88 2f       	mov	r24, r24
    8c0e:	90 e0       	ldi	r25, 0x00	; 0
    8c10:	9e 01       	movw	r18, r28
    8c12:	2a 5f       	subi	r18, 0xFA	; 250
    8c14:	3f 4f       	sbci	r19, 0xFF	; 255
    8c16:	82 0f       	add	r24, r18
    8c18:	93 1f       	adc	r25, r19
    8c1a:	20 e2       	ldi	r18, 0x20	; 32
    8c1c:	fc 01       	movw	r30, r24
    8c1e:	20 83       	st	Z, r18
    8c20:	8b 81       	ldd	r24, Y+3	; 0x03
    8c22:	8f 5f       	subi	r24, 0xFF	; 255
    8c24:	8b 83       	std	Y+3, r24	; 0x03
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    8c26:	8b 81       	ldd	r24, Y+3	; 0x03
    8c28:	8b 30       	cpi	r24, 0x0B	; 11
    8c2a:	78 f3       	brcs	.-34     	; 0x8c0a <convertFileName+0x192>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    8c2c:	8b 81       	ldd	r24, Y+3	; 0x03
    8c2e:	8f 5f       	subi	r24, 0xFF	; 255
    8c30:	8b 83       	std	Y+3, r24	; 0x03
    8c32:	8b 81       	ldd	r24, Y+3	; 0x03
    8c34:	8b 30       	cpi	r24, 0x0B	; 11
    8c36:	58 f2       	brcs	.-106    	; 0x8bce <convertFileName+0x156>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8c38:	1a 82       	std	Y+2, r1	; 0x02
    8c3a:	31 c0       	rjmp	.+98     	; 0x8c9e <convertFileName+0x226>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    8c3c:	8a 81       	ldd	r24, Y+2	; 0x02
    8c3e:	88 2f       	mov	r24, r24
    8c40:	90 e0       	ldi	r25, 0x00	; 0
    8c42:	9e 01       	movw	r18, r28
    8c44:	2a 5f       	subi	r18, 0xFA	; 250
    8c46:	3f 4f       	sbci	r19, 0xFF	; 255
    8c48:	82 0f       	add	r24, r18
    8c4a:	93 1f       	adc	r25, r19
    8c4c:	fc 01       	movw	r30, r24
    8c4e:	80 81       	ld	r24, Z
    8c50:	81 36       	cpi	r24, 0x61	; 97
    8c52:	10 f1       	brcs	.+68     	; 0x8c98 <convertFileName+0x220>
    8c54:	8a 81       	ldd	r24, Y+2	; 0x02
    8c56:	88 2f       	mov	r24, r24
    8c58:	90 e0       	ldi	r25, 0x00	; 0
    8c5a:	9e 01       	movw	r18, r28
    8c5c:	2a 5f       	subi	r18, 0xFA	; 250
    8c5e:	3f 4f       	sbci	r19, 0xFF	; 255
    8c60:	82 0f       	add	r24, r18
    8c62:	93 1f       	adc	r25, r19
    8c64:	fc 01       	movw	r30, r24
    8c66:	80 81       	ld	r24, Z
    8c68:	8b 37       	cpi	r24, 0x7B	; 123
    8c6a:	b0 f4       	brcc	.+44     	; 0x8c98 <convertFileName+0x220>
    fileNameFAT[j] -= 0x20;
    8c6c:	8a 81       	ldd	r24, Y+2	; 0x02
    8c6e:	88 2f       	mov	r24, r24
    8c70:	90 e0       	ldi	r25, 0x00	; 0
    8c72:	2a 81       	ldd	r18, Y+2	; 0x02
    8c74:	22 2f       	mov	r18, r18
    8c76:	30 e0       	ldi	r19, 0x00	; 0
    8c78:	ae 01       	movw	r20, r28
    8c7a:	4a 5f       	subi	r20, 0xFA	; 250
    8c7c:	5f 4f       	sbci	r21, 0xFF	; 255
    8c7e:	24 0f       	add	r18, r20
    8c80:	35 1f       	adc	r19, r21
    8c82:	f9 01       	movw	r30, r18
    8c84:	20 81       	ld	r18, Z
    8c86:	42 2f       	mov	r20, r18
    8c88:	40 52       	subi	r20, 0x20	; 32
    8c8a:	9e 01       	movw	r18, r28
    8c8c:	2a 5f       	subi	r18, 0xFA	; 250
    8c8e:	3f 4f       	sbci	r19, 0xFF	; 255
    8c90:	82 0f       	add	r24, r18
    8c92:	93 1f       	adc	r25, r19
    8c94:	fc 01       	movw	r30, r24
    8c96:	40 83       	st	Z, r20
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8c98:	8a 81       	ldd	r24, Y+2	; 0x02
    8c9a:	8f 5f       	subi	r24, 0xFF	; 255
    8c9c:	8a 83       	std	Y+2, r24	; 0x02
    8c9e:	8a 81       	ldd	r24, Y+2	; 0x02
    8ca0:	8b 30       	cpi	r24, 0x0B	; 11
    8ca2:	60 f2       	brcs	.-104    	; 0x8c3c <convertFileName+0x1c4>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8ca4:	1a 82       	std	Y+2, r1	; 0x02
    8ca6:	14 c0       	rjmp	.+40     	; 0x8cd0 <convertFileName+0x258>
  Filename[j] = fileNameFAT[j];
    8ca8:	8a 81       	ldd	r24, Y+2	; 0x02
    8caa:	88 2f       	mov	r24, r24
    8cac:	90 e0       	ldi	r25, 0x00	; 0
    8cae:	2a 81       	ldd	r18, Y+2	; 0x02
    8cb0:	22 2f       	mov	r18, r18
    8cb2:	30 e0       	ldi	r19, 0x00	; 0
    8cb4:	ae 01       	movw	r20, r28
    8cb6:	4a 5f       	subi	r20, 0xFA	; 250
    8cb8:	5f 4f       	sbci	r21, 0xFF	; 255
    8cba:	24 0f       	add	r18, r20
    8cbc:	35 1f       	adc	r19, r21
    8cbe:	f9 01       	movw	r30, r18
    8cc0:	20 81       	ld	r18, Z
    8cc2:	80 55       	subi	r24, 0x50	; 80
    8cc4:	9f 4a       	sbci	r25, 0xAF	; 175
    8cc6:	fc 01       	movw	r30, r24
    8cc8:	20 83       	st	Z, r18

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8cca:	8a 81       	ldd	r24, Y+2	; 0x02
    8ccc:	8f 5f       	subi	r24, 0xFF	; 255
    8cce:	8a 83       	std	Y+2, r24	; 0x02
    8cd0:	8a 81       	ldd	r24, Y+2	; 0x02
    8cd2:	8b 30       	cpi	r24, 0x0B	; 11
    8cd4:	48 f3       	brcs	.-46     	; 0x8ca8 <convertFileName+0x230>
  Filename[j] = fileNameFAT[j];

return 0;
    8cd6:	80 e0       	ldi	r24, 0x00	; 0
}
    8cd8:	62 96       	adiw	r28, 0x12	; 18
    8cda:	cd bf       	out	0x3d, r28	; 61
    8cdc:	de bf       	out	0x3e, r29	; 62
    8cde:	df 91       	pop	r29
    8ce0:	cf 91       	pop	r28
    8ce2:	08 95       	ret

00008ce4 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    8ce4:	ef 92       	push	r14
    8ce6:	ff 92       	push	r15
    8ce8:	0f 93       	push	r16
    8cea:	1f 93       	push	r17
    8cec:	cf 93       	push	r28
    8cee:	df 93       	push	r29
    8cf0:	cd b7       	in	r28, 0x3d	; 61
    8cf2:	de b7       	in	r29, 0x3e	; 62
    8cf4:	e7 97       	sbiw	r28, 0x37	; 55
    8cf6:	cd bf       	out	0x3d, r28	; 61
    8cf8:	de bf       	out	0x3e, r29	; 62
    8cfa:	88 ab       	sts	0x58, r24
    8cfc:	99 ab       	sts	0x59, r25
    8cfe:	6a ab       	sts	0x5a, r22
    8d00:	7b ab       	sts	0x5b, r23
    8d02:	2c ab       	sts	0x5c, r18
    8d04:	3d ab       	sts	0x5d, r19
    8d06:	4e ab       	sts	0x5e, r20
    8d08:	5f ab       	sts	0x5f, r21
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    8d0a:	1a 82       	std	Y+2, r1	; 0x02
    8d0c:	1b 82       	std	Y+3, r1	; 0x03
    8d0e:	1c 82       	std	Y+4, r1	; 0x04
    8d10:	1d 82       	std	Y+5, r1	; 0x05
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    8d12:	1e 82       	std	Y+6, r1	; 0x06
    8d14:	1f 82       	std	Y+7, r1	; 0x07
    8d16:	18 86       	std	Y+8, r1	; 0x08
    8d18:	19 86       	std	Y+9, r1	; 0x09
    8d1a:	1a 86       	std	Y+10, r1	; 0x0a
    8d1c:	1b 86       	std	Y+11, r1	; 0x0b
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    8d1e:	28 a9       	sts	0x48, r18
    8d20:	39 a9       	sts	0x49, r19
    8d22:	81 e0       	ldi	r24, 0x01	; 1
    8d24:	b9 01       	movw	r22, r18
    8d26:	0e 94 8d 44 	call	0x891a	; 0x891a <readFile>
    8d2a:	89 83       	std	Y+1, r24	; 0x01

if(j == 1) 
    8d2c:	89 81       	ldd	r24, Y+1	; 0x01
    8d2e:	81 30       	cpi	r24, 0x01	; 1
    8d30:	09 f0       	breq	.+2      	; 0x8d34 <writeFile+0x50>
    8d32:	84 c0       	rjmp	.+264    	; 0x8e3c <writeFile+0x158>
{
  //File already exists, appending data
  appendFile = 1;
    8d34:	81 e0       	ldi	r24, 0x01	; 1
    8d36:	8c 83       	std	Y+4, r24	; 0x04
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    8d38:	80 91 7c 50 	lds	r24, 0x507C
    8d3c:	90 91 7d 50 	lds	r25, 0x507D
    8d40:	a0 91 7e 50 	lds	r26, 0x507E
    8d44:	b0 91 7f 50 	lds	r27, 0x507F
    8d48:	8c 87       	std	Y+12, r24	; 0x0c
    8d4a:	9d 87       	std	Y+13, r25	; 0x0d
    8d4c:	ae 87       	std	Y+14, r26	; 0x0e
    8d4e:	bf 87       	std	Y+15, r27	; 0x0f
  clusterCount=0;
    8d50:	1c 8a       	std	Y+20, r1	; 0x14
    8d52:	1d 8a       	std	Y+21, r1	; 0x15
    8d54:	1e 8a       	std	Y+22, r1	; 0x16
    8d56:	1f 8a       	std	Y+23, r1	; 0x17
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    8d58:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d5a:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d5c:	ae 85       	ldd	r26, Y+14	; 0x0e
    8d5e:	bf 85       	ldd	r27, Y+15	; 0x0f
    8d60:	bc 01       	movw	r22, r24
    8d62:	cd 01       	movw	r24, r26
    8d64:	40 e0       	ldi	r20, 0x00	; 0
    8d66:	00 e0       	ldi	r16, 0x00	; 0
    8d68:	10 e0       	ldi	r17, 0x00	; 0
    8d6a:	98 01       	movw	r18, r16
    8d6c:	0e 94 58 41 	call	0x82b0	; 0x82b0 <getSetNextCluster>
    8d70:	dc 01       	movw	r26, r24
    8d72:	cb 01       	movw	r24, r22
    8d74:	8a a3       	lds	r24, 0x5a
    8d76:	9b a3       	lds	r25, 0x5b
    8d78:	ac a3       	lds	r26, 0x5c
    8d7a:	bd a3       	lds	r27, 0x5d
    if(nextCluster == EOF) break;
    8d7c:	8a a1       	lds	r24, 0x4a
    8d7e:	9b a1       	lds	r25, 0x4b
    8d80:	ac a1       	lds	r26, 0x4c
    8d82:	bd a1       	lds	r27, 0x4d
    8d84:	8f 3f       	cpi	r24, 0xFF	; 255
    8d86:	0f ef       	ldi	r16, 0xFF	; 255
    8d88:	90 07       	cpc	r25, r16
    8d8a:	0f ef       	ldi	r16, 0xFF	; 255
    8d8c:	a0 07       	cpc	r26, r16
    8d8e:	0f e0       	ldi	r16, 0x0F	; 15
    8d90:	b0 07       	cpc	r27, r16
    8d92:	a1 f0       	breq	.+40     	; 0x8dbc <writeFile+0xd8>
	cluster = nextCluster;
    8d94:	8a a1       	lds	r24, 0x4a
    8d96:	9b a1       	lds	r25, 0x4b
    8d98:	ac a1       	lds	r26, 0x4c
    8d9a:	bd a1       	lds	r27, 0x4d
    8d9c:	8c 87       	std	Y+12, r24	; 0x0c
    8d9e:	9d 87       	std	Y+13, r25	; 0x0d
    8da0:	ae 87       	std	Y+14, r26	; 0x0e
    8da2:	bf 87       	std	Y+15, r27	; 0x0f
	clusterCount++;
    8da4:	8c 89       	ldd	r24, Y+20	; 0x14
    8da6:	9d 89       	ldd	r25, Y+21	; 0x15
    8da8:	ae 89       	ldd	r26, Y+22	; 0x16
    8daa:	bf 89       	ldd	r27, Y+23	; 0x17
    8dac:	01 96       	adiw	r24, 0x01	; 1
    8dae:	a1 1d       	adc	r26, r1
    8db0:	b1 1d       	adc	r27, r1
    8db2:	8c 8b       	std	Y+20, r24	; 0x14
    8db4:	9d 8b       	std	Y+21, r25	; 0x15
    8db6:	ae 8b       	std	Y+22, r26	; 0x16
    8db8:	bf 8b       	std	Y+23, r27	; 0x17
  }
    8dba:	ce cf       	rjmp	.-100    	; 0x8d58 <writeFile+0x74>
  clusterCount=0;
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
    8dbc:	00 00       	nop
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    8dbe:	e0 90 3d 40 	lds	r14, 0x403D
    8dc2:	f0 90 3e 40 	lds	r15, 0x403E
    8dc6:	00 91 3f 40 	lds	r16, 0x403F
    8dca:	10 91 40 40 	lds	r17, 0x4040
    8dce:	80 91 70 50 	lds	r24, 0x5070
    8dd2:	90 91 71 50 	lds	r25, 0x5071
    8dd6:	cc 01       	movw	r24, r24
    8dd8:	a0 e0       	ldi	r26, 0x00	; 0
    8dda:	b0 e0       	ldi	r27, 0x00	; 0
    8ddc:	2c 89       	ldd	r18, Y+20	; 0x14
    8dde:	3d 89       	ldd	r19, Y+21	; 0x15
    8de0:	4e 89       	ldd	r20, Y+22	; 0x16
    8de2:	5f 89       	ldd	r21, Y+23	; 0x17
    8de4:	bc 01       	movw	r22, r24
    8de6:	cd 01       	movw	r24, r26
    8de8:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    8dec:	dc 01       	movw	r26, r24
    8dee:	cb 01       	movw	r24, r22
    8df0:	20 91 41 40 	lds	r18, 0x4041
    8df4:	30 91 42 40 	lds	r19, 0x4042
    8df8:	99 01       	movw	r18, r18
    8dfa:	40 e0       	ldi	r20, 0x00	; 0
    8dfc:	50 e0       	ldi	r21, 0x00	; 0
    8dfe:	bc 01       	movw	r22, r24
    8e00:	cd 01       	movw	r24, r26
    8e02:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    8e06:	dc 01       	movw	r26, r24
    8e08:	cb 01       	movw	r24, r22
    8e0a:	a8 01       	movw	r20, r16
    8e0c:	97 01       	movw	r18, r14
    8e0e:	28 1b       	sub	r18, r24
    8e10:	39 0b       	sbc	r19, r25
    8e12:	4a 0b       	sbc	r20, r26
    8e14:	5b 0b       	sbc	r21, r27
    8e16:	da 01       	movw	r26, r20
    8e18:	c9 01       	movw	r24, r18
    8e1a:	20 91 41 40 	lds	r18, 0x4041
    8e1e:	30 91 42 40 	lds	r19, 0x4042
    8e22:	99 01       	movw	r18, r18
    8e24:	40 e0       	ldi	r20, 0x00	; 0
    8e26:	50 e0       	ldi	r21, 0x00	; 0
    8e28:	bc 01       	movw	r22, r24
    8e2a:	cd 01       	movw	r24, r26
    8e2c:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    8e30:	da 01       	movw	r26, r20
    8e32:	c9 01       	movw	r24, r18
    8e34:	8d 83       	std	Y+5, r24	; 0x05
  start = 1;
    8e36:	81 e0       	ldi	r24, 0x01	; 1
    8e38:	8b 83       	std	Y+3, r24	; 0x03
    8e3a:	69 c0       	rjmp	.+210    	; 0x8f0e <writeFile+0x22a>
}
else if(j == 2) 
    8e3c:	89 81       	ldd	r24, Y+1	; 0x01
    8e3e:	82 30       	cpi	r24, 0x02	; 2
    8e40:	11 f4       	brne	.+4      	; 0x8e46 <writeFile+0x162>
   return 1; //invalid file name
    8e42:	81 e0       	ldi	r24, 0x01	; 1
    8e44:	1b c3       	rjmp	.+1590   	; 0x947c <writeFile+0x798>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    8e46:	82 e0       	ldi	r24, 0x02	; 2
    8e48:	60 e0       	ldi	r22, 0x00	; 0
    8e4a:	20 e0       	ldi	r18, 0x00	; 0
    8e4c:	30 e0       	ldi	r19, 0x00	; 0
    8e4e:	a9 01       	movw	r20, r18
    8e50:	0e 94 02 42 	call	0x8404	; 0x8404 <getSetFreeCluster>
    8e54:	dc 01       	movw	r26, r24
    8e56:	cb 01       	movw	r24, r22
    8e58:	8c 87       	std	Y+12, r24	; 0x0c
    8e5a:	9d 87       	std	Y+13, r25	; 0x0d
    8e5c:	ae 87       	std	Y+14, r26	; 0x0e
    8e5e:	bf 87       	std	Y+15, r27	; 0x0f
  if(cluster > totalClusters)
    8e60:	80 91 4e 40 	lds	r24, 0x404E
    8e64:	90 91 4f 40 	lds	r25, 0x404F
    8e68:	a0 91 50 40 	lds	r26, 0x4050
    8e6c:	b0 91 51 40 	lds	r27, 0x4051
    8e70:	2c 85       	ldd	r18, Y+12	; 0x0c
    8e72:	3d 85       	ldd	r19, Y+13	; 0x0d
    8e74:	4e 85       	ldd	r20, Y+14	; 0x0e
    8e76:	5f 85       	ldd	r21, Y+15	; 0x0f
    8e78:	82 17       	cp	r24, r18
    8e7a:	93 07       	cpc	r25, r19
    8e7c:	a4 07       	cpc	r26, r20
    8e7e:	b5 07       	cpc	r27, r21
    8e80:	60 f4       	brcc	.+24     	; 0x8e9a <writeFile+0x1b6>
     cluster = rootCluster;
    8e82:	80 91 54 40 	lds	r24, 0x4054
    8e86:	90 91 55 40 	lds	r25, 0x4055
    8e8a:	a0 91 56 40 	lds	r26, 0x4056
    8e8e:	b0 91 57 40 	lds	r27, 0x4057
    8e92:	8c 87       	std	Y+12, r24	; 0x0c
    8e94:	9d 87       	std	Y+13, r25	; 0x0d
    8e96:	ae 87       	std	Y+14, r26	; 0x0e
    8e98:	bf 87       	std	Y+15, r27	; 0x0f

  cluster = searchNextFreeCluster(cluster);
    8e9a:	8c 85       	ldd	r24, Y+12	; 0x0c
    8e9c:	9d 85       	ldd	r25, Y+13	; 0x0d
    8e9e:	ae 85       	ldd	r26, Y+14	; 0x0e
    8ea0:	bf 85       	ldd	r27, Y+15	; 0x0f
    8ea2:	bc 01       	movw	r22, r24
    8ea4:	cd 01       	movw	r24, r26
    8ea6:	0e 94 48 4a 	call	0x9490	; 0x9490 <searchNextFreeCluster>
    8eaa:	dc 01       	movw	r26, r24
    8eac:	cb 01       	movw	r24, r22
    8eae:	8c 87       	std	Y+12, r24	; 0x0c
    8eb0:	9d 87       	std	Y+13, r25	; 0x0d
    8eb2:	ae 87       	std	Y+14, r26	; 0x0e
    8eb4:	bf 87       	std	Y+15, r27	; 0x0f
   if(cluster == 0)
    8eb6:	8c 85       	ldd	r24, Y+12	; 0x0c
    8eb8:	9d 85       	ldd	r25, Y+13	; 0x0d
    8eba:	ae 85       	ldd	r26, Y+14	; 0x0e
    8ebc:	bf 85       	ldd	r27, Y+15	; 0x0f
    8ebe:	00 97       	sbiw	r24, 0x00	; 0
    8ec0:	a1 05       	cpc	r26, r1
    8ec2:	b1 05       	cpc	r27, r1
    8ec4:	11 f4       	brne	.+4      	; 0x8eca <writeFile+0x1e6>
   {
	   // No free cluster!
	  return 2;
    8ec6:	82 e0       	ldi	r24, 0x02	; 2
    8ec8:	d9 c2       	rjmp	.+1458   	; 0x947c <writeFile+0x798>
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    8eca:	8c 85       	ldd	r24, Y+12	; 0x0c
    8ecc:	9d 85       	ldd	r25, Y+13	; 0x0d
    8ece:	ae 85       	ldd	r26, Y+14	; 0x0e
    8ed0:	bf 85       	ldd	r27, Y+15	; 0x0f
    8ed2:	bc 01       	movw	r22, r24
    8ed4:	cd 01       	movw	r24, r26
    8ed6:	41 e0       	ldi	r20, 0x01	; 1
    8ed8:	0f ef       	ldi	r16, 0xFF	; 255
    8eda:	1f ef       	ldi	r17, 0xFF	; 255
    8edc:	2f ef       	ldi	r18, 0xFF	; 255
    8ede:	3f e0       	ldi	r19, 0x0F	; 15
    8ee0:	0e 94 58 41 	call	0x82b0	; 0x82b0 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    8ee4:	8c 85       	ldd	r24, Y+12	; 0x0c
    8ee6:	9d 85       	ldd	r25, Y+13	; 0x0d
    8ee8:	ae 85       	ldd	r26, Y+14	; 0x0e
    8eea:	bf 85       	ldd	r27, Y+15	; 0x0f
    8eec:	cd 01       	movw	r24, r26
    8eee:	aa 27       	eor	r26, r26
    8ef0:	bb 27       	eor	r27, r27
    8ef2:	8e 83       	std	Y+6, r24	; 0x06
    8ef4:	9f 83       	std	Y+7, r25	; 0x07
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    8ef6:	8c 85       	ldd	r24, Y+12	; 0x0c
    8ef8:	9d 85       	ldd	r25, Y+13	; 0x0d
    8efa:	88 87       	std	Y+8, r24	; 0x08
    8efc:	99 87       	std	Y+9, r25	; 0x09
  fileSize = 0;
    8efe:	10 92 3d 40 	sts	0x403D, r1
    8f02:	10 92 3e 40 	sts	0x403E, r1
    8f06:	10 92 3f 40 	sts	0x403F, r1
    8f0a:	10 92 40 40 	sts	0x4040, r1
}

//start writing data here

if(start){
    8f0e:	8b 81       	ldd	r24, Y+3	; 0x03
    8f10:	88 23       	and	r24, r24
    8f12:	11 f1       	breq	.+68     	; 0x8f58 <writeFile+0x274>
  start = 0;
    8f14:	1b 82       	std	Y+3, r1	; 0x03
  startBlock = getFirstSector (cluster) + sector;
    8f16:	8c 85       	ldd	r24, Y+12	; 0x0c
    8f18:	9d 85       	ldd	r25, Y+13	; 0x0d
    8f1a:	ae 85       	ldd	r26, Y+14	; 0x0e
    8f1c:	bf 85       	ldd	r27, Y+15	; 0x0f
    8f1e:	bc 01       	movw	r22, r24
    8f20:	cd 01       	movw	r24, r26
    8f22:	0e 94 26 41 	call	0x824c	; 0x824c <getFirstSector>
    8f26:	dc 01       	movw	r26, r24
    8f28:	cb 01       	movw	r24, r22
    8f2a:	9c 01       	movw	r18, r24
    8f2c:	8d 81       	ldd	r24, Y+5	; 0x05
    8f2e:	88 2f       	mov	r24, r24
    8f30:	90 e0       	ldi	r25, 0x00	; 0
    8f32:	82 0f       	add	r24, r18
    8f34:	93 1f       	adc	r25, r19
    8f36:	8a 87       	std	Y+10, r24	; 0x0a
    8f38:	9b 87       	std	Y+11, r25	; 0x0b
  SD_read_block (startBlock,SDBuffer);
    8f3a:	8a 85       	ldd	r24, Y+10	; 0x0a
    8f3c:	9b 85       	ldd	r25, Y+11	; 0x0b
    8f3e:	cc 01       	movw	r24, r24
    8f40:	a0 e0       	ldi	r26, 0x00	; 0
    8f42:	b0 e0       	ldi	r27, 0x00	; 0
    8f44:	23 ec       	ldi	r18, 0xC3	; 195
    8f46:	31 e2       	ldi	r19, 0x21	; 33
    8f48:	bc 01       	movw	r22, r24
    8f4a:	cd 01       	movw	r24, r26
    8f4c:	a9 01       	movw	r20, r18
    8f4e:	0e 94 52 4f 	call	0x9ea4	; 0x9ea4 <SD_read_block>
  j = sector;
    8f52:	8d 81       	ldd	r24, Y+5	; 0x05
    8f54:	89 83       	std	Y+1, r24	; 0x01
    8f56:	0d c0       	rjmp	.+26     	; 0x8f72 <writeFile+0x28e>
}
else{
  startBlock = getFirstSector (cluster);
    8f58:	8c 85       	ldd	r24, Y+12	; 0x0c
    8f5a:	9d 85       	ldd	r25, Y+13	; 0x0d
    8f5c:	ae 85       	ldd	r26, Y+14	; 0x0e
    8f5e:	bf 85       	ldd	r27, Y+15	; 0x0f
    8f60:	bc 01       	movw	r22, r24
    8f62:	cd 01       	movw	r24, r26
    8f64:	0e 94 26 41 	call	0x824c	; 0x824c <getFirstSector>
    8f68:	dc 01       	movw	r26, r24
    8f6a:	cb 01       	movw	r24, r22
    8f6c:	8a 87       	std	Y+10, r24	; 0x0a
    8f6e:	9b 87       	std	Y+11, r25	; 0x0b
  j=0;
    8f70:	19 82       	std	Y+1, r1	; 0x01
}
uint32_t writtenData = 0;
    8f72:	18 8e       	std	Y+24, r1	; 0x18
    8f74:	19 8e       	std	Y+25, r1	; 0x19
    8f76:	1a 8e       	std	Y+26, r1	; 0x1a
    8f78:	1b 8e       	std	Y+27, r1	; 0x1b
uint32_t dataToWrite = 0;
    8f7a:	1c 8e       	std	Y+28, r1	; 0x1c
    8f7c:	1d 8e       	std	Y+29, r1	; 0x1d
    8f7e:	1e 8e       	std	Y+30, r1	; 0x1e
    8f80:	1f 8e       	std	Y+31, r1	; 0x1f
while(lengthOfData!=0){
    8f82:	cd c0       	rjmp	.+410    	; 0x911e <writeFile+0x43a>
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    8f84:	8c a9       	sts	0x4c, r24
    8f86:	9d a9       	sts	0x4d, r25
    8f88:	ae a9       	sts	0x4e, r26
    8f8a:	bf a9       	sts	0x4f, r27
    8f8c:	80 30       	cpi	r24, 0x00	; 0
    8f8e:	32 e0       	ldi	r19, 0x02	; 2
    8f90:	93 07       	cpc	r25, r19
    8f92:	30 e0       	ldi	r19, 0x00	; 0
    8f94:	a3 07       	cpc	r26, r19
    8f96:	30 e0       	ldi	r19, 0x00	; 0
    8f98:	b3 07       	cpc	r27, r19
    8f9a:	08 f1       	brcs	.+66     	; 0x8fde <writeFile+0x2fa>
		 writtenData += 512;
    8f9c:	88 8d       	ldd	r24, Y+24	; 0x18
    8f9e:	99 8d       	ldd	r25, Y+25	; 0x19
    8fa0:	aa 8d       	ldd	r26, Y+26	; 0x1a
    8fa2:	bb 8d       	ldd	r27, Y+27	; 0x1b
    8fa4:	80 50       	subi	r24, 0x00	; 0
    8fa6:	9e 4f       	sbci	r25, 0xFE	; 254
    8fa8:	af 4f       	sbci	r26, 0xFF	; 255
    8faa:	bf 4f       	sbci	r27, 0xFF	; 255
    8fac:	88 8f       	std	Y+24, r24	; 0x18
    8fae:	99 8f       	std	Y+25, r25	; 0x19
    8fb0:	aa 8f       	std	Y+26, r26	; 0x1a
    8fb2:	bb 8f       	std	Y+27, r27	; 0x1b
		 dataToWrite = 512;
    8fb4:	80 e0       	ldi	r24, 0x00	; 0
    8fb6:	92 e0       	ldi	r25, 0x02	; 2
    8fb8:	a0 e0       	ldi	r26, 0x00	; 0
    8fba:	b0 e0       	ldi	r27, 0x00	; 0
    8fbc:	8c 8f       	std	Y+28, r24	; 0x1c
    8fbe:	9d 8f       	std	Y+29, r25	; 0x1d
    8fc0:	ae 8f       	std	Y+30, r26	; 0x1e
    8fc2:	bf 8f       	std	Y+31, r27	; 0x1f
		 lengthOfData -= 512;
    8fc4:	8c a9       	sts	0x4c, r24
    8fc6:	9d a9       	sts	0x4d, r25
    8fc8:	ae a9       	sts	0x4e, r26
    8fca:	bf a9       	sts	0x4f, r27
    8fcc:	80 50       	subi	r24, 0x00	; 0
    8fce:	92 40       	sbci	r25, 0x02	; 2
    8fd0:	a0 40       	sbci	r26, 0x00	; 0
    8fd2:	b0 40       	sbci	r27, 0x00	; 0
    8fd4:	8c ab       	sts	0x5c, r24
    8fd6:	9d ab       	sts	0x5d, r25
    8fd8:	ae ab       	sts	0x5e, r26
    8fda:	bf ab       	sts	0x5f, r27
    8fdc:	1f c0       	rjmp	.+62     	; 0x901c <writeFile+0x338>
	}
	else{
		writtenData += lengthOfData;
    8fde:	28 8d       	ldd	r18, Y+24	; 0x18
    8fe0:	39 8d       	ldd	r19, Y+25	; 0x19
    8fe2:	4a 8d       	ldd	r20, Y+26	; 0x1a
    8fe4:	5b 8d       	ldd	r21, Y+27	; 0x1b
    8fe6:	8c a9       	sts	0x4c, r24
    8fe8:	9d a9       	sts	0x4d, r25
    8fea:	ae a9       	sts	0x4e, r26
    8fec:	bf a9       	sts	0x4f, r27
    8fee:	82 0f       	add	r24, r18
    8ff0:	93 1f       	adc	r25, r19
    8ff2:	a4 1f       	adc	r26, r20
    8ff4:	b5 1f       	adc	r27, r21
    8ff6:	88 8f       	std	Y+24, r24	; 0x18
    8ff8:	99 8f       	std	Y+25, r25	; 0x19
    8ffa:	aa 8f       	std	Y+26, r26	; 0x1a
    8ffc:	bb 8f       	std	Y+27, r27	; 0x1b
		dataToWrite = lengthOfData%512;
    8ffe:	8c a9       	sts	0x4c, r24
    9000:	9d a9       	sts	0x4d, r25
    9002:	ae a9       	sts	0x4e, r26
    9004:	bf a9       	sts	0x4f, r27
    9006:	91 70       	andi	r25, 0x01	; 1
    9008:	a0 70       	andi	r26, 0x00	; 0
    900a:	b0 70       	andi	r27, 0x00	; 0
    900c:	8c 8f       	std	Y+28, r24	; 0x1c
    900e:	9d 8f       	std	Y+29, r25	; 0x1d
    9010:	ae 8f       	std	Y+30, r26	; 0x1e
    9012:	bf 8f       	std	Y+31, r27	; 0x1f
		lengthOfData = 0;
    9014:	1c aa       	sts	0x9c, r17
    9016:	1d aa       	sts	0x9d, r17
    9018:	1e aa       	sts	0x9e, r17
    901a:	1f aa       	sts	0x9f, r17
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    901c:	80 91 3d 40 	lds	r24, 0x403D
    9020:	90 91 3e 40 	lds	r25, 0x403E
    9024:	a0 91 3f 40 	lds	r26, 0x403F
    9028:	b0 91 40 40 	lds	r27, 0x4040
    902c:	80 50       	subi	r24, 0x00	; 0
    902e:	9e 4f       	sbci	r25, 0xFE	; 254
    9030:	af 4f       	sbci	r26, 0xFF	; 255
    9032:	bf 4f       	sbci	r27, 0xFF	; 255
    9034:	80 93 3d 40 	sts	0x403D, r24
    9038:	90 93 3e 40 	sts	0x403E, r25
    903c:	a0 93 3f 40 	sts	0x403F, r26
    9040:	b0 93 40 40 	sts	0x4040, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    9044:	8a 85       	ldd	r24, Y+10	; 0x0a
    9046:	9b 85       	ldd	r25, Y+11	; 0x0b
    9048:	cc 01       	movw	r24, r24
    904a:	a0 e0       	ldi	r26, 0x00	; 0
    904c:	b0 e0       	ldi	r27, 0x00	; 0
    904e:	48 8d       	ldd	r20, Y+24	; 0x18
    9050:	59 8d       	ldd	r21, Y+25	; 0x19
    9052:	2c 8d       	ldd	r18, Y+28	; 0x1c
    9054:	3d 8d       	ldd	r19, Y+29	; 0x1d
    9056:	ba 01       	movw	r22, r20
    9058:	62 1b       	sub	r22, r18
    905a:	73 0b       	sbc	r23, r19
    905c:	9b 01       	movw	r18, r22
    905e:	4a a9       	sts	0x4a, r20
    9060:	5b a9       	sts	0x4b, r21
    9062:	42 0f       	add	r20, r18
    9064:	53 1f       	adc	r21, r19
    9066:	2c 8d       	ldd	r18, Y+28	; 0x1c
    9068:	3d 8d       	ldd	r19, Y+29	; 0x1d
    906a:	bc 01       	movw	r22, r24
    906c:	cd 01       	movw	r24, r26
    906e:	0e 94 84 4e 	call	0x9d08	; 0x9d08 <SD_write_block>
	j++;
    9072:	89 81       	ldd	r24, Y+1	; 0x01
    9074:	8f 5f       	subi	r24, 0xFF	; 255
    9076:	89 83       	std	Y+1, r24	; 0x01
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    9078:	89 81       	ldd	r24, Y+1	; 0x01
    907a:	28 2f       	mov	r18, r24
    907c:	30 e0       	ldi	r19, 0x00	; 0
    907e:	80 91 70 50 	lds	r24, 0x5070
    9082:	90 91 71 50 	lds	r25, 0x5071
    9086:	28 17       	cp	r18, r24
    9088:	39 07       	cpc	r19, r25
    908a:	e1 f5       	brne	.+120    	; 0x9104 <writeFile+0x420>
		j = 0; 
    908c:	19 82       	std	Y+1, r1	; 0x01
 
		prevCluster = cluster;
    908e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9090:	9d 85       	ldd	r25, Y+13	; 0x0d
    9092:	ae 85       	ldd	r26, Y+14	; 0x0e
    9094:	bf 85       	ldd	r27, Y+15	; 0x0f
    9096:	88 8b       	std	Y+16, r24	; 0x10
    9098:	99 8b       	std	Y+17, r25	; 0x11
    909a:	aa 8b       	std	Y+18, r26	; 0x12
    909c:	bb 8b       	std	Y+19, r27	; 0x13
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    909e:	88 89       	ldd	r24, Y+16	; 0x10
    90a0:	99 89       	ldd	r25, Y+17	; 0x11
    90a2:	aa 89       	ldd	r26, Y+18	; 0x12
    90a4:	bb 89       	ldd	r27, Y+19	; 0x13
    90a6:	bc 01       	movw	r22, r24
    90a8:	cd 01       	movw	r24, r26
    90aa:	0e 94 48 4a 	call	0x9490	; 0x9490 <searchNextFreeCluster>
    90ae:	dc 01       	movw	r26, r24
    90b0:	cb 01       	movw	r24, r22
    90b2:	8c 87       	std	Y+12, r24	; 0x0c
    90b4:	9d 87       	std	Y+13, r25	; 0x0d
    90b6:	ae 87       	std	Y+14, r26	; 0x0e
    90b8:	bf 87       	std	Y+15, r27	; 0x0f
		if(cluster == 0){
    90ba:	8c 85       	ldd	r24, Y+12	; 0x0c
    90bc:	9d 85       	ldd	r25, Y+13	; 0x0d
    90be:	ae 85       	ldd	r26, Y+14	; 0x0e
    90c0:	bf 85       	ldd	r27, Y+15	; 0x0f
    90c2:	00 97       	sbiw	r24, 0x00	; 0
    90c4:	a1 05       	cpc	r26, r1
    90c6:	b1 05       	cpc	r27, r1
    90c8:	11 f4       	brne	.+4      	; 0x90ce <writeFile+0x3ea>
		  //No free cluster!
		  return 2;
    90ca:	82 e0       	ldi	r24, 0x02	; 2
    90cc:	d7 c1       	rjmp	.+942    	; 0x947c <writeFile+0x798>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    90ce:	88 89       	ldd	r24, Y+16	; 0x10
    90d0:	99 89       	ldd	r25, Y+17	; 0x11
    90d2:	aa 89       	ldd	r26, Y+18	; 0x12
    90d4:	bb 89       	ldd	r27, Y+19	; 0x13
    90d6:	0c 85       	ldd	r16, Y+12	; 0x0c
    90d8:	1d 85       	ldd	r17, Y+13	; 0x0d
    90da:	2e 85       	ldd	r18, Y+14	; 0x0e
    90dc:	3f 85       	ldd	r19, Y+15	; 0x0f
    90de:	bc 01       	movw	r22, r24
    90e0:	cd 01       	movw	r24, r26
    90e2:	41 e0       	ldi	r20, 0x01	; 1
    90e4:	0e 94 58 41 	call	0x82b0	; 0x82b0 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    90e8:	8c 85       	ldd	r24, Y+12	; 0x0c
    90ea:	9d 85       	ldd	r25, Y+13	; 0x0d
    90ec:	ae 85       	ldd	r26, Y+14	; 0x0e
    90ee:	bf 85       	ldd	r27, Y+15	; 0x0f
    90f0:	bc 01       	movw	r22, r24
    90f2:	cd 01       	movw	r24, r26
    90f4:	41 e0       	ldi	r20, 0x01	; 1
    90f6:	0f ef       	ldi	r16, 0xFF	; 255
    90f8:	1f ef       	ldi	r17, 0xFF	; 255
    90fa:	2f ef       	ldi	r18, 0xFF	; 255
    90fc:	3f e0       	ldi	r19, 0x0F	; 15
    90fe:	0e 94 58 41 	call	0x82b0	; 0x82b0 <getSetNextCluster>
    9102:	05 c0       	rjmp	.+10     	; 0x910e <writeFile+0x42a>
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    9104:	8a 85       	ldd	r24, Y+10	; 0x0a
    9106:	9b 85       	ldd	r25, Y+11	; 0x0b
    9108:	01 96       	adiw	r24, 0x01	; 1
    910a:	8a 87       	std	Y+10, r24	; 0x0a
    910c:	9b 87       	std	Y+11, r25	; 0x0b
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    910e:	2c 85       	ldd	r18, Y+12	; 0x0c
    9110:	3d 85       	ldd	r19, Y+13	; 0x0d
    9112:	4e 85       	ldd	r20, Y+14	; 0x0e
    9114:	5f 85       	ldd	r21, Y+15	; 0x0f
    9116:	82 e0       	ldi	r24, 0x02	; 2
    9118:	61 e0       	ldi	r22, 0x01	; 1
    911a:	0e 94 02 42 	call	0x8404	; 0x8404 <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    911e:	8c a9       	sts	0x4c, r24
    9120:	9d a9       	sts	0x4d, r25
    9122:	ae a9       	sts	0x4e, r26
    9124:	bf a9       	sts	0x4f, r27
    9126:	00 97       	sbiw	r24, 0x00	; 0
    9128:	a1 05       	cpc	r26, r1
    912a:	b1 05       	cpc	r27, r1
    912c:	09 f0       	breq	.+2      	; 0x9130 <writeFile+0x44c>
    912e:	2a cf       	rjmp	.-428    	; 0x8f84 <writeFile+0x2a0>
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    9130:	8c 81       	ldd	r24, Y+4	; 0x04
    9132:	88 23       	and	r24, r24
    9134:	09 f4       	brne	.+2      	; 0x9138 <writeFile+0x454>
    9136:	66 c0       	rjmp	.+204    	; 0x9204 <writeFile+0x520>
{
  SD_read_block (appendFileSector,SDBuffer);    
    9138:	80 91 c6 50 	lds	r24, 0x50C6
    913c:	90 91 c7 50 	lds	r25, 0x50C7
    9140:	a0 91 c8 50 	lds	r26, 0x50C8
    9144:	b0 91 c9 50 	lds	r27, 0x50C9
    9148:	23 ec       	ldi	r18, 0xC3	; 195
    914a:	31 e2       	ldi	r19, 0x21	; 33
    914c:	bc 01       	movw	r22, r24
    914e:	cd 01       	movw	r24, r26
    9150:	a9 01       	movw	r20, r18
    9152:	0e 94 52 4f 	call	0x9ea4	; 0x9ea4 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    9156:	80 91 c4 23 	lds	r24, 0x23C4
    915a:	90 91 c5 23 	lds	r25, 0x23C5
    915e:	a0 91 c6 23 	lds	r26, 0x23C6
    9162:	b0 91 c7 23 	lds	r27, 0x23C7
    9166:	8d 53       	subi	r24, 0x3D	; 61
    9168:	9e 4d       	sbci	r25, 0xDE	; 222
    916a:	8e a3       	lds	r24, 0x5e
    916c:	9f a3       	lds	r25, 0x5f

  dir->lastAccessDate = 0;   //date of last access ignored
    916e:	8e a1       	lds	r24, 0x4e
    9170:	9f a1       	lds	r25, 0x4f
    9172:	fc 01       	movw	r30, r24
    9174:	12 8a       	std	Z+18, r1	; 0x12
    9176:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    9178:	20 91 3d 40 	lds	r18, 0x403D
    917c:	30 91 3e 40 	lds	r19, 0x403E
    9180:	40 91 3f 40 	lds	r20, 0x403F
    9184:	50 91 40 40 	lds	r21, 0x4040
    9188:	8e a1       	lds	r24, 0x4e
    918a:	9f a1       	lds	r25, 0x4f
    918c:	fc 01       	movw	r30, r24
    918e:	84 8d       	ldd	r24, Z+28	; 0x1c
    9190:	95 8d       	ldd	r25, Z+29	; 0x1d
    9192:	a6 8d       	ldd	r26, Z+30	; 0x1e
    9194:	b7 8d       	ldd	r27, Z+31	; 0x1f
    9196:	79 01       	movw	r14, r18
    9198:	8a 01       	movw	r16, r20
    919a:	e8 1a       	sub	r14, r24
    919c:	f9 0a       	sbc	r15, r25
    919e:	0a 0b       	sbc	r16, r26
    91a0:	1b 0b       	sbc	r17, r27
    91a2:	d8 01       	movw	r26, r16
    91a4:	c7 01       	movw	r24, r14
    91a6:	88 a7       	lds	r24, 0x78
    91a8:	99 a7       	lds	r25, 0x79
    91aa:	aa a7       	lds	r26, 0x7a
    91ac:	bb a7       	lds	r27, 0x7b
  dir->fileSize = fileSize;
    91ae:	80 91 3d 40 	lds	r24, 0x403D
    91b2:	90 91 3e 40 	lds	r25, 0x403E
    91b6:	a0 91 3f 40 	lds	r26, 0x403F
    91ba:	b0 91 40 40 	lds	r27, 0x4040
    91be:	2e a1       	lds	r18, 0x4e
    91c0:	3f a1       	lds	r19, 0x4f
    91c2:	f9 01       	movw	r30, r18
    91c4:	84 8f       	std	Z+28, r24	; 0x1c
    91c6:	95 8f       	std	Z+29, r25	; 0x1d
    91c8:	a6 8f       	std	Z+30, r26	; 0x1e
    91ca:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    91cc:	80 91 c6 50 	lds	r24, 0x50C6
    91d0:	90 91 c7 50 	lds	r25, 0x50C7
    91d4:	a0 91 c8 50 	lds	r26, 0x50C8
    91d8:	b0 91 c9 50 	lds	r27, 0x50C9
    91dc:	23 ec       	ldi	r18, 0xC3	; 195
    91de:	31 e2       	ldi	r19, 0x21	; 33
    91e0:	bc 01       	movw	r22, r24
    91e2:	cd 01       	movw	r24, r26
    91e4:	a9 01       	movw	r20, r18
    91e6:	20 e0       	ldi	r18, 0x00	; 0
    91e8:	32 e0       	ldi	r19, 0x02	; 2
    91ea:	0e 94 84 4e 	call	0x9d08	; 0x9d08 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    91ee:	28 a5       	lds	r18, 0x68
    91f0:	39 a5       	lds	r19, 0x69
    91f2:	4a a5       	lds	r20, 0x6a
    91f4:	5b a5       	lds	r21, 0x6b
    91f6:	81 e0       	ldi	r24, 0x01	; 1
    91f8:	ba 01       	movw	r22, r20
    91fa:	a9 01       	movw	r20, r18
    91fc:	0e 94 21 4b 	call	0x9642	; 0x9642 <freeMemoryUpdate>

 //File appended!
  return 0;
    9200:	80 e0       	ldi	r24, 0x00	; 0
    9202:	3c c1       	rjmp	.+632    	; 0x947c <writeFile+0x798>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    9204:	80 91 54 40 	lds	r24, 0x4054
    9208:	90 91 55 40 	lds	r25, 0x4055
    920c:	a0 91 56 40 	lds	r26, 0x4056
    9210:	b0 91 57 40 	lds	r27, 0x4057
    9214:	88 8b       	std	Y+16, r24	; 0x10
    9216:	99 8b       	std	Y+17, r25	; 0x11
    9218:	aa 8b       	std	Y+18, r26	; 0x12
    921a:	bb 8b       	std	Y+19, r27	; 0x13

while(1)
{
   firstSector = getFirstSector (prevCluster);
    921c:	88 89       	ldd	r24, Y+16	; 0x10
    921e:	99 89       	ldd	r25, Y+17	; 0x11
    9220:	aa 89       	ldd	r26, Y+18	; 0x12
    9222:	bb 89       	ldd	r27, Y+19	; 0x13
    9224:	bc 01       	movw	r22, r24
    9226:	cd 01       	movw	r24, r26
    9228:	0e 94 26 41 	call	0x824c	; 0x824c <getFirstSector>
    922c:	dc 01       	movw	r26, r24
    922e:	cb 01       	movw	r24, r22
    9230:	8c a7       	lds	r24, 0x7c
    9232:	9d a7       	lds	r25, 0x7d
    9234:	ae a7       	lds	r26, 0x7e
    9236:	bf a7       	lds	r27, 0x7f

   for(sector = 0; sector < sectorPerCluster; sector++)
    9238:	1d 82       	std	Y+5, r1	; 0x05
    923a:	ad c0       	rjmp	.+346    	; 0x9396 <writeFile+0x6b2>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    923c:	8d 81       	ldd	r24, Y+5	; 0x05
    923e:	28 2f       	mov	r18, r24
    9240:	30 e0       	ldi	r19, 0x00	; 0
    9242:	40 e0       	ldi	r20, 0x00	; 0
    9244:	50 e0       	ldi	r21, 0x00	; 0
    9246:	8c a5       	lds	r24, 0x6c
    9248:	9d a5       	lds	r25, 0x6d
    924a:	ae a5       	lds	r26, 0x6e
    924c:	bf a5       	lds	r27, 0x6f
    924e:	82 0f       	add	r24, r18
    9250:	93 1f       	adc	r25, r19
    9252:	a4 1f       	adc	r26, r20
    9254:	b5 1f       	adc	r27, r21
    9256:	23 ec       	ldi	r18, 0xC3	; 195
    9258:	31 e2       	ldi	r19, 0x21	; 33
    925a:	bc 01       	movw	r22, r24
    925c:	cd 01       	movw	r24, r26
    925e:	a9 01       	movw	r20, r18
    9260:	0e 94 52 4f 	call	0x9ea4	; 0x9ea4 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    9264:	18 a2       	lds	r17, 0x98
    9266:	19 a2       	lds	r17, 0x99
    9268:	89 c0       	rjmp	.+274    	; 0x937c <writeFile+0x698>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    926a:	88 a1       	lds	r24, 0x48
    926c:	99 a1       	lds	r25, 0x49
    926e:	8d 53       	subi	r24, 0x3D	; 61
    9270:	9e 4d       	sbci	r25, 0xDE	; 222
    9272:	8e a3       	lds	r24, 0x5e
    9274:	9f a3       	lds	r25, 0x5f
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    9276:	8a 81       	ldd	r24, Y+2	; 0x02
    9278:	88 23       	and	r24, r24
    927a:	11 f0       	breq	.+4      	; 0x9280 <writeFile+0x59c>
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    927c:	80 e0       	ldi	r24, 0x00	; 0
    927e:	fe c0       	rjmp	.+508    	; 0x947c <writeFile+0x798>
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    9280:	8e a1       	lds	r24, 0x4e
    9282:	9f a1       	lds	r25, 0x4f
    9284:	fc 01       	movw	r30, r24
    9286:	80 81       	ld	r24, Z
    9288:	88 23       	and	r24, r24
    928a:	39 f0       	breq	.+14     	; 0x929a <writeFile+0x5b6>
    928c:	8e a1       	lds	r24, 0x4e
    928e:	9f a1       	lds	r25, 0x4f
    9290:	fc 01       	movw	r30, r24
    9292:	80 81       	ld	r24, Z
    9294:	85 3e       	cpi	r24, 0xE5	; 229
    9296:	09 f0       	breq	.+2      	; 0x929a <writeFile+0x5b6>
    9298:	6c c0       	rjmp	.+216    	; 0x9372 <writeFile+0x68e>
		{
		  for(j=0; j<11; j++)
    929a:	19 82       	std	Y+1, r1	; 0x01
    929c:	13 c0       	rjmp	.+38     	; 0x92c4 <writeFile+0x5e0>
  			dir->name[j] = Filename[j];
    929e:	89 81       	ldd	r24, Y+1	; 0x01
    92a0:	88 2f       	mov	r24, r24
    92a2:	90 e0       	ldi	r25, 0x00	; 0
    92a4:	29 81       	ldd	r18, Y+1	; 0x01
    92a6:	22 2f       	mov	r18, r18
    92a8:	30 e0       	ldi	r19, 0x00	; 0
    92aa:	20 55       	subi	r18, 0x50	; 80
    92ac:	3f 4a       	sbci	r19, 0xAF	; 175
    92ae:	f9 01       	movw	r30, r18
    92b0:	40 81       	ld	r20, Z
    92b2:	2e a1       	lds	r18, 0x4e
    92b4:	3f a1       	lds	r19, 0x4f
    92b6:	82 0f       	add	r24, r18
    92b8:	93 1f       	adc	r25, r19
    92ba:	fc 01       	movw	r30, r24
    92bc:	40 83       	st	Z, r20
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    92be:	89 81       	ldd	r24, Y+1	; 0x01
    92c0:	8f 5f       	subi	r24, 0xFF	; 255
    92c2:	89 83       	std	Y+1, r24	; 0x01
    92c4:	89 81       	ldd	r24, Y+1	; 0x01
    92c6:	8b 30       	cpi	r24, 0x0B	; 11
    92c8:	50 f3       	brcs	.-44     	; 0x929e <writeFile+0x5ba>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    92ca:	8e a1       	lds	r24, 0x4e
    92cc:	9f a1       	lds	r25, 0x4f
    92ce:	20 e2       	ldi	r18, 0x20	; 32
    92d0:	fc 01       	movw	r30, r24
    92d2:	23 87       	std	Z+11, r18	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    92d4:	8e a1       	lds	r24, 0x4e
    92d6:	9f a1       	lds	r25, 0x4f
    92d8:	fc 01       	movw	r30, r24
    92da:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    92dc:	8e a1       	lds	r24, 0x4e
    92de:	9f a1       	lds	r25, 0x4f
    92e0:	fc 01       	movw	r30, r24
    92e2:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    92e4:	8e a1       	lds	r24, 0x4e
    92e6:	9f a1       	lds	r25, 0x4f
    92e8:	fc 01       	movw	r30, r24
    92ea:	12 8a       	std	Z+18, r1	; 0x12
    92ec:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    92ee:	8e a1       	lds	r24, 0x4e
    92f0:	9f a1       	lds	r25, 0x4f
    92f2:	2e 81       	ldd	r18, Y+6	; 0x06
    92f4:	3f 81       	ldd	r19, Y+7	; 0x07
    92f6:	fc 01       	movw	r30, r24
    92f8:	24 8b       	std	Z+20, r18	; 0x14
    92fa:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    92fc:	8e a1       	lds	r24, 0x4e
    92fe:	9f a1       	lds	r25, 0x4f
    9300:	28 85       	ldd	r18, Y+8	; 0x08
    9302:	39 85       	ldd	r19, Y+9	; 0x09
    9304:	fc 01       	movw	r30, r24
    9306:	22 8f       	std	Z+26, r18	; 0x1a
    9308:	33 8f       	std	Z+27, r19	; 0x1b
		  dir->fileSize = fileSize;
    930a:	80 91 3d 40 	lds	r24, 0x403D
    930e:	90 91 3e 40 	lds	r25, 0x403E
    9312:	a0 91 3f 40 	lds	r26, 0x403F
    9316:	b0 91 40 40 	lds	r27, 0x4040
    931a:	2e a1       	lds	r18, 0x4e
    931c:	3f a1       	lds	r19, 0x4f
    931e:	f9 01       	movw	r30, r18
    9320:	84 8f       	std	Z+28, r24	; 0x1c
    9322:	95 8f       	std	Z+29, r25	; 0x1d
    9324:	a6 8f       	std	Z+30, r26	; 0x1e
    9326:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    9328:	8d 81       	ldd	r24, Y+5	; 0x05
    932a:	28 2f       	mov	r18, r24
    932c:	30 e0       	ldi	r19, 0x00	; 0
    932e:	40 e0       	ldi	r20, 0x00	; 0
    9330:	50 e0       	ldi	r21, 0x00	; 0
    9332:	8c a5       	lds	r24, 0x6c
    9334:	9d a5       	lds	r25, 0x6d
    9336:	ae a5       	lds	r26, 0x6e
    9338:	bf a5       	lds	r27, 0x6f
    933a:	82 0f       	add	r24, r18
    933c:	93 1f       	adc	r25, r19
    933e:	a4 1f       	adc	r26, r20
    9340:	b5 1f       	adc	r27, r21
    9342:	23 ec       	ldi	r18, 0xC3	; 195
    9344:	31 e2       	ldi	r19, 0x21	; 33
    9346:	bc 01       	movw	r22, r24
    9348:	cd 01       	movw	r24, r26
    934a:	a9 01       	movw	r20, r18
    934c:	20 e0       	ldi	r18, 0x00	; 0
    934e:	32 e0       	ldi	r19, 0x02	; 2
    9350:	0e 94 84 4e 	call	0x9d08	; 0x9d08 <SD_write_block>
		  fileCreatedFlag = 1;
    9354:	81 e0       	ldi	r24, 0x01	; 1
    9356:	8a 83       	std	Y+2, r24	; 0x02

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    9358:	20 91 3d 40 	lds	r18, 0x403D
    935c:	30 91 3e 40 	lds	r19, 0x403E
    9360:	40 91 3f 40 	lds	r20, 0x403F
    9364:	50 91 40 40 	lds	r21, 0x4040
    9368:	81 e0       	ldi	r24, 0x01	; 1
    936a:	ba 01       	movw	r22, r20
    936c:	a9 01       	movw	r20, r18
    936e:	0e 94 21 4b 	call	0x9642	; 0x9642 <freeMemoryUpdate>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    9372:	88 a1       	lds	r24, 0x48
    9374:	99 a1       	lds	r25, 0x49
    9376:	80 96       	adiw	r24, 0x20	; 32
    9378:	88 a3       	lds	r24, 0x58
    937a:	99 a3       	lds	r25, 0x59
    937c:	28 a1       	lds	r18, 0x48
    937e:	39 a1       	lds	r19, 0x49
    9380:	80 91 41 40 	lds	r24, 0x4041
    9384:	90 91 42 40 	lds	r25, 0x4042
    9388:	28 17       	cp	r18, r24
    938a:	39 07       	cpc	r19, r25
    938c:	08 f4       	brcc	.+2      	; 0x9390 <writeFile+0x6ac>
    938e:	6d cf       	rjmp	.-294    	; 0x926a <writeFile+0x586>

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    9390:	8d 81       	ldd	r24, Y+5	; 0x05
    9392:	8f 5f       	subi	r24, 0xFF	; 255
    9394:	8d 83       	std	Y+5, r24	; 0x05
    9396:	8d 81       	ldd	r24, Y+5	; 0x05
    9398:	28 2f       	mov	r18, r24
    939a:	30 e0       	ldi	r19, 0x00	; 0
    939c:	80 91 70 50 	lds	r24, 0x5070
    93a0:	90 91 71 50 	lds	r25, 0x5071
    93a4:	28 17       	cp	r18, r24
    93a6:	39 07       	cpc	r19, r25
    93a8:	08 f4       	brcc	.+2      	; 0x93ac <writeFile+0x6c8>
    93aa:	48 cf       	rjmp	.-368    	; 0x923c <writeFile+0x558>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    93ac:	88 89       	ldd	r24, Y+16	; 0x10
    93ae:	99 89       	ldd	r25, Y+17	; 0x11
    93b0:	aa 89       	ldd	r26, Y+18	; 0x12
    93b2:	bb 89       	ldd	r27, Y+19	; 0x13
    93b4:	bc 01       	movw	r22, r24
    93b6:	cd 01       	movw	r24, r26
    93b8:	40 e0       	ldi	r20, 0x00	; 0
    93ba:	00 e0       	ldi	r16, 0x00	; 0
    93bc:	10 e0       	ldi	r17, 0x00	; 0
    93be:	98 01       	movw	r18, r16
    93c0:	0e 94 58 41 	call	0x82b0	; 0x82b0 <getSetNextCluster>
    93c4:	dc 01       	movw	r26, r24
    93c6:	cb 01       	movw	r24, r22
    93c8:	8c 87       	std	Y+12, r24	; 0x0c
    93ca:	9d 87       	std	Y+13, r25	; 0x0d
    93cc:	ae 87       	std	Y+14, r26	; 0x0e
    93ce:	bf 87       	std	Y+15, r27	; 0x0f

   if(cluster > 0x0ffffff6)
    93d0:	8c 85       	ldd	r24, Y+12	; 0x0c
    93d2:	9d 85       	ldd	r25, Y+13	; 0x0d
    93d4:	ae 85       	ldd	r26, Y+14	; 0x0e
    93d6:	bf 85       	ldd	r27, Y+15	; 0x0f
    93d8:	87 3f       	cpi	r24, 0xF7	; 247
    93da:	ff ef       	ldi	r31, 0xFF	; 255
    93dc:	9f 07       	cpc	r25, r31
    93de:	ff ef       	ldi	r31, 0xFF	; 255
    93e0:	af 07       	cpc	r26, r31
    93e2:	ff e0       	ldi	r31, 0x0F	; 15
    93e4:	bf 07       	cpc	r27, r31
    93e6:	b8 f1       	brcs	.+110    	; 0x9456 <writeFile+0x772>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    93e8:	8c 85       	ldd	r24, Y+12	; 0x0c
    93ea:	9d 85       	ldd	r25, Y+13	; 0x0d
    93ec:	ae 85       	ldd	r26, Y+14	; 0x0e
    93ee:	bf 85       	ldd	r27, Y+15	; 0x0f
    93f0:	8f 3f       	cpi	r24, 0xFF	; 255
    93f2:	0f ef       	ldi	r16, 0xFF	; 255
    93f4:	90 07       	cpc	r25, r16
    93f6:	0f ef       	ldi	r16, 0xFF	; 255
    93f8:	a0 07       	cpc	r26, r16
    93fa:	0f e0       	ldi	r16, 0x0F	; 15
    93fc:	b0 07       	cpc	r27, r16
    93fe:	49 f5       	brne	.+82     	; 0x9452 <writeFile+0x76e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    9400:	88 89       	ldd	r24, Y+16	; 0x10
    9402:	99 89       	ldd	r25, Y+17	; 0x11
    9404:	aa 89       	ldd	r26, Y+18	; 0x12
    9406:	bb 89       	ldd	r27, Y+19	; 0x13
    9408:	bc 01       	movw	r22, r24
    940a:	cd 01       	movw	r24, r26
    940c:	0e 94 48 4a 	call	0x9490	; 0x9490 <searchNextFreeCluster>
    9410:	dc 01       	movw	r26, r24
    9412:	cb 01       	movw	r24, r22
    9414:	8c 87       	std	Y+12, r24	; 0x0c
    9416:	9d 87       	std	Y+13, r25	; 0x0d
    9418:	ae 87       	std	Y+14, r26	; 0x0e
    941a:	bf 87       	std	Y+15, r27	; 0x0f
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    941c:	88 89       	ldd	r24, Y+16	; 0x10
    941e:	99 89       	ldd	r25, Y+17	; 0x11
    9420:	aa 89       	ldd	r26, Y+18	; 0x12
    9422:	bb 89       	ldd	r27, Y+19	; 0x13
    9424:	0c 85       	ldd	r16, Y+12	; 0x0c
    9426:	1d 85       	ldd	r17, Y+13	; 0x0d
    9428:	2e 85       	ldd	r18, Y+14	; 0x0e
    942a:	3f 85       	ldd	r19, Y+15	; 0x0f
    942c:	bc 01       	movw	r22, r24
    942e:	cd 01       	movw	r24, r26
    9430:	41 e0       	ldi	r20, 0x01	; 1
    9432:	0e 94 58 41 	call	0x82b0	; 0x82b0 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    9436:	8c 85       	ldd	r24, Y+12	; 0x0c
    9438:	9d 85       	ldd	r25, Y+13	; 0x0d
    943a:	ae 85       	ldd	r26, Y+14	; 0x0e
    943c:	bf 85       	ldd	r27, Y+15	; 0x0f
    943e:	bc 01       	movw	r22, r24
    9440:	cd 01       	movw	r24, r26
    9442:	41 e0       	ldi	r20, 0x01	; 1
    9444:	0f ef       	ldi	r16, 0xFF	; 255
    9446:	1f ef       	ldi	r17, 0xFF	; 255
    9448:	2f ef       	ldi	r18, 0xFF	; 255
    944a:	3f e0       	ldi	r19, 0x0F	; 15
    944c:	0e 94 58 41 	call	0x82b0	; 0x82b0 <getSetNextCluster>
    9450:	02 c0       	rjmp	.+4      	; 0x9456 <writeFile+0x772>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    9452:	83 e0       	ldi	r24, 0x03	; 3
    9454:	13 c0       	rjmp	.+38     	; 0x947c <writeFile+0x798>
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    9456:	8c 85       	ldd	r24, Y+12	; 0x0c
    9458:	9d 85       	ldd	r25, Y+13	; 0x0d
    945a:	ae 85       	ldd	r26, Y+14	; 0x0e
    945c:	bf 85       	ldd	r27, Y+15	; 0x0f
    945e:	00 97       	sbiw	r24, 0x00	; 0
    9460:	a1 05       	cpc	r26, r1
    9462:	b1 05       	cpc	r27, r1
    9464:	11 f4       	brne	.+4      	; 0x946a <writeFile+0x786>
	   return 4;
    9466:	84 e0       	ldi	r24, 0x04	; 4
    9468:	09 c0       	rjmp	.+18     	; 0x947c <writeFile+0x798>
	}
   
   prevCluster = cluster;
    946a:	8c 85       	ldd	r24, Y+12	; 0x0c
    946c:	9d 85       	ldd	r25, Y+13	; 0x0d
    946e:	ae 85       	ldd	r26, Y+14	; 0x0e
    9470:	bf 85       	ldd	r27, Y+15	; 0x0f
    9472:	88 8b       	std	Y+16, r24	; 0x10
    9474:	99 8b       	std	Y+17, r25	; 0x11
    9476:	aa 8b       	std	Y+18, r26	; 0x12
    9478:	bb 8b       	std	Y+19, r27	; 0x13
 }
    947a:	d0 ce       	rjmp	.-608    	; 0x921c <writeFile+0x538>
 
 return 0;
}
    947c:	e7 96       	adiw	r28, 0x37	; 55
    947e:	cd bf       	out	0x3d, r28	; 61
    9480:	de bf       	out	0x3e, r29	; 62
    9482:	df 91       	pop	r29
    9484:	cf 91       	pop	r28
    9486:	1f 91       	pop	r17
    9488:	0f 91       	pop	r16
    948a:	ff 90       	pop	r15
    948c:	ef 90       	pop	r14
    948e:	08 95       	ret

00009490 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    9490:	ef 92       	push	r14
    9492:	ff 92       	push	r15
    9494:	0f 93       	push	r16
    9496:	1f 93       	push	r17
    9498:	cf 93       	push	r28
    949a:	df 93       	push	r29
    949c:	cd b7       	in	r28, 0x3d	; 61
    949e:	de b7       	in	r29, 0x3e	; 62
    94a0:	2f 97       	sbiw	r28, 0x0f	; 15
    94a2:	cd bf       	out	0x3d, r28	; 61
    94a4:	de bf       	out	0x3e, r29	; 62
    94a6:	6c 87       	std	Y+12, r22	; 0x0c
    94a8:	7d 87       	std	Y+13, r23	; 0x0d
    94aa:	8e 87       	std	Y+14, r24	; 0x0e
    94ac:	9f 87       	std	Y+15, r25	; 0x0f
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    94ae:	8c 85       	ldd	r24, Y+12	; 0x0c
    94b0:	9d 85       	ldd	r25, Y+13	; 0x0d
    94b2:	ae 85       	ldd	r26, Y+14	; 0x0e
    94b4:	bf 85       	ldd	r27, Y+15	; 0x0f
    94b6:	80 78       	andi	r24, 0x80	; 128
    94b8:	8c 87       	std	Y+12, r24	; 0x0c
    94ba:	9d 87       	std	Y+13, r25	; 0x0d
    94bc:	ae 87       	std	Y+14, r26	; 0x0e
    94be:	bf 87       	std	Y+15, r27	; 0x0f
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    94c0:	8c 85       	ldd	r24, Y+12	; 0x0c
    94c2:	9d 85       	ldd	r25, Y+13	; 0x0d
    94c4:	ae 85       	ldd	r26, Y+14	; 0x0e
    94c6:	bf 85       	ldd	r27, Y+15	; 0x0f
    94c8:	89 83       	std	Y+1, r24	; 0x01
    94ca:	9a 83       	std	Y+2, r25	; 0x02
    94cc:	ab 83       	std	Y+3, r26	; 0x03
    94ce:	bc 83       	std	Y+4, r27	; 0x04
    94d0:	7a c0       	rjmp	.+244    	; 0x95c6 <searchNextFreeCluster+0x136>
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    94d2:	80 91 78 50 	lds	r24, 0x5078
    94d6:	90 91 79 50 	lds	r25, 0x5079
    94da:	9c 01       	movw	r18, r24
    94dc:	40 e0       	ldi	r20, 0x00	; 0
    94de:	50 e0       	ldi	r21, 0x00	; 0
    94e0:	80 91 72 50 	lds	r24, 0x5072
    94e4:	90 91 73 50 	lds	r25, 0x5073
    94e8:	a0 91 74 50 	lds	r26, 0x5074
    94ec:	b0 91 75 50 	lds	r27, 0x5075
    94f0:	79 01       	movw	r14, r18
    94f2:	8a 01       	movw	r16, r20
    94f4:	e8 0e       	add	r14, r24
    94f6:	f9 1e       	adc	r15, r25
    94f8:	0a 1f       	adc	r16, r26
    94fa:	1b 1f       	adc	r17, r27
    94fc:	89 81       	ldd	r24, Y+1	; 0x01
    94fe:	9a 81       	ldd	r25, Y+2	; 0x02
    9500:	ab 81       	ldd	r26, Y+3	; 0x03
    9502:	bc 81       	ldd	r27, Y+4	; 0x04
    9504:	88 0f       	add	r24, r24
    9506:	99 1f       	adc	r25, r25
    9508:	aa 1f       	adc	r26, r26
    950a:	bb 1f       	adc	r27, r27
    950c:	88 0f       	add	r24, r24
    950e:	99 1f       	adc	r25, r25
    9510:	aa 1f       	adc	r26, r26
    9512:	bb 1f       	adc	r27, r27
    9514:	20 91 41 40 	lds	r18, 0x4041
    9518:	30 91 42 40 	lds	r19, 0x4042
    951c:	99 01       	movw	r18, r18
    951e:	40 e0       	ldi	r20, 0x00	; 0
    9520:	50 e0       	ldi	r21, 0x00	; 0
    9522:	bc 01       	movw	r22, r24
    9524:	cd 01       	movw	r24, r26
    9526:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    952a:	da 01       	movw	r26, r20
    952c:	c9 01       	movw	r24, r18
    952e:	8e 0d       	add	r24, r14
    9530:	9f 1d       	adc	r25, r15
    9532:	a0 1f       	adc	r26, r16
    9534:	b1 1f       	adc	r27, r17
    9536:	8e 83       	std	Y+6, r24	; 0x06
    9538:	9f 83       	std	Y+7, r25	; 0x07
    953a:	a8 87       	std	Y+8, r26	; 0x08
    953c:	b9 87       	std	Y+9, r27	; 0x09
      SD_read_block(sector,SDBuffer);
    953e:	8e 81       	ldd	r24, Y+6	; 0x06
    9540:	9f 81       	ldd	r25, Y+7	; 0x07
    9542:	a8 85       	ldd	r26, Y+8	; 0x08
    9544:	b9 85       	ldd	r27, Y+9	; 0x09
    9546:	23 ec       	ldi	r18, 0xC3	; 195
    9548:	31 e2       	ldi	r19, 0x21	; 33
    954a:	bc 01       	movw	r22, r24
    954c:	cd 01       	movw	r24, r26
    954e:	a9 01       	movw	r20, r18
    9550:	0e 94 52 4f 	call	0x9ea4	; 0x9ea4 <SD_read_block>
      for(i=0; i<128; i++)
    9554:	1d 82       	std	Y+5, r1	; 0x05
    9556:	28 c0       	rjmp	.+80     	; 0x95a8 <searchNextFreeCluster+0x118>
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    9558:	8d 81       	ldd	r24, Y+5	; 0x05
    955a:	88 2f       	mov	r24, r24
    955c:	90 e0       	ldi	r25, 0x00	; 0
    955e:	88 0f       	add	r24, r24
    9560:	99 1f       	adc	r25, r25
    9562:	88 0f       	add	r24, r24
    9564:	99 1f       	adc	r25, r25
    9566:	8d 53       	subi	r24, 0x3D	; 61
    9568:	9e 4d       	sbci	r25, 0xDE	; 222
    956a:	8a 87       	std	Y+10, r24	; 0x0a
    956c:	9b 87       	std	Y+11, r25	; 0x0b
         if(((*value) & 0x0fffffff) == 0)
    956e:	8a 85       	ldd	r24, Y+10	; 0x0a
    9570:	9b 85       	ldd	r25, Y+11	; 0x0b
    9572:	fc 01       	movw	r30, r24
    9574:	80 81       	ld	r24, Z
    9576:	91 81       	ldd	r25, Z+1	; 0x01
    9578:	a2 81       	ldd	r26, Z+2	; 0x02
    957a:	b3 81       	ldd	r27, Z+3	; 0x03
    957c:	bf 70       	andi	r27, 0x0F	; 15
    957e:	00 97       	sbiw	r24, 0x00	; 0
    9580:	a1 05       	cpc	r26, r1
    9582:	b1 05       	cpc	r27, r1
    9584:	71 f4       	brne	.+28     	; 0x95a2 <searchNextFreeCluster+0x112>
            return(cluster+i);
    9586:	8d 81       	ldd	r24, Y+5	; 0x05
    9588:	28 2f       	mov	r18, r24
    958a:	30 e0       	ldi	r19, 0x00	; 0
    958c:	40 e0       	ldi	r20, 0x00	; 0
    958e:	50 e0       	ldi	r21, 0x00	; 0
    9590:	89 81       	ldd	r24, Y+1	; 0x01
    9592:	9a 81       	ldd	r25, Y+2	; 0x02
    9594:	ab 81       	ldd	r26, Y+3	; 0x03
    9596:	bc 81       	ldd	r27, Y+4	; 0x04
    9598:	82 0f       	add	r24, r18
    959a:	93 1f       	adc	r25, r19
    959c:	a4 1f       	adc	r26, r20
    959e:	b5 1f       	adc	r27, r21
    95a0:	27 c0       	rjmp	.+78     	; 0x95f0 <searchNextFreeCluster+0x160>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    95a2:	8d 81       	ldd	r24, Y+5	; 0x05
    95a4:	8f 5f       	subi	r24, 0xFF	; 255
    95a6:	8d 83       	std	Y+5, r24	; 0x05
    95a8:	8d 81       	ldd	r24, Y+5	; 0x05
    95aa:	88 23       	and	r24, r24
    95ac:	ac f6       	brge	.-86     	; 0x9558 <searchNextFreeCluster+0xc8>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    95ae:	89 81       	ldd	r24, Y+1	; 0x01
    95b0:	9a 81       	ldd	r25, Y+2	; 0x02
    95b2:	ab 81       	ldd	r26, Y+3	; 0x03
    95b4:	bc 81       	ldd	r27, Y+4	; 0x04
    95b6:	80 58       	subi	r24, 0x80	; 128
    95b8:	9f 4f       	sbci	r25, 0xFF	; 255
    95ba:	af 4f       	sbci	r26, 0xFF	; 255
    95bc:	bf 4f       	sbci	r27, 0xFF	; 255
    95be:	89 83       	std	Y+1, r24	; 0x01
    95c0:	9a 83       	std	Y+2, r25	; 0x02
    95c2:	ab 83       	std	Y+3, r26	; 0x03
    95c4:	bc 83       	std	Y+4, r27	; 0x04
    95c6:	80 91 4e 40 	lds	r24, 0x404E
    95ca:	90 91 4f 40 	lds	r25, 0x404F
    95ce:	a0 91 50 40 	lds	r26, 0x4050
    95d2:	b0 91 51 40 	lds	r27, 0x4051
    95d6:	29 81       	ldd	r18, Y+1	; 0x01
    95d8:	3a 81       	ldd	r19, Y+2	; 0x02
    95da:	4b 81       	ldd	r20, Y+3	; 0x03
    95dc:	5c 81       	ldd	r21, Y+4	; 0x04
    95de:	28 17       	cp	r18, r24
    95e0:	39 07       	cpc	r19, r25
    95e2:	4a 07       	cpc	r20, r26
    95e4:	5b 07       	cpc	r21, r27
    95e6:	08 f4       	brcc	.+2      	; 0x95ea <searchNextFreeCluster+0x15a>
    95e8:	74 cf       	rjmp	.-280    	; 0x94d2 <searchNextFreeCluster+0x42>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    95ea:	80 e0       	ldi	r24, 0x00	; 0
    95ec:	90 e0       	ldi	r25, 0x00	; 0
    95ee:	dc 01       	movw	r26, r24
}
    95f0:	bc 01       	movw	r22, r24
    95f2:	cd 01       	movw	r24, r26
    95f4:	2f 96       	adiw	r28, 0x0f	; 15
    95f6:	cd bf       	out	0x3d, r28	; 61
    95f8:	de bf       	out	0x3e, r29	; 62
    95fa:	df 91       	pop	r29
    95fc:	cf 91       	pop	r28
    95fe:	1f 91       	pop	r17
    9600:	0f 91       	pop	r16
    9602:	ff 90       	pop	r15
    9604:	ef 90       	pop	r14
    9606:	08 95       	ret

00009608 <deleteFile>:
//Function: to delete a specified file from the root directory
//Arguments: pointer to the file name
//return: none
//********************************************************************
void deleteFile (unsigned char *fileName)
{
    9608:	cf 93       	push	r28
    960a:	df 93       	push	r29
    960c:	00 d0       	rcall	.+0      	; 0x960e <deleteFile+0x6>
    960e:	cd b7       	in	r28, 0x3d	; 61
    9610:	de b7       	in	r29, 0x3e	; 62
    9612:	8a 83       	std	Y+2, r24	; 0x02
    9614:	9b 83       	std	Y+3, r25	; 0x03
  unsigned char error;

  error = convertFileName (fileName);
    9616:	8a 81       	ldd	r24, Y+2	; 0x02
    9618:	9b 81       	ldd	r25, Y+3	; 0x03
    961a:	0e 94 3c 45 	call	0x8a78	; 0x8a78 <convertFileName>
    961e:	89 83       	std	Y+1, r24	; 0x01
  if(error) return;
    9620:	89 81       	ldd	r24, Y+1	; 0x01
    9622:	88 23       	and	r24, r24
    9624:	39 f4       	brne	.+14     	; 0x9634 <deleteFile+0x2c>

  findFiles (DELETE, Filename);
    9626:	20 eb       	ldi	r18, 0xB0	; 176
    9628:	30 e5       	ldi	r19, 0x50	; 80
    962a:	82 e0       	ldi	r24, 0x02	; 2
    962c:	b9 01       	movw	r22, r18
    962e:	0e 94 b3 42 	call	0x8566	; 0x8566 <findFiles>
    9632:	01 c0       	rjmp	.+2      	; 0x9636 <deleteFile+0x2e>
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
  if(error) return;
    9634:	00 00       	nop

  findFiles (DELETE, Filename);
}
    9636:	23 96       	adiw	r28, 0x03	; 3
    9638:	cd bf       	out	0x3d, r28	; 61
    963a:	de bf       	out	0x3e, r29	; 62
    963c:	df 91       	pop	r29
    963e:	cf 91       	pop	r28
    9640:	08 95       	ret

00009642 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    9642:	ef 92       	push	r14
    9644:	ff 92       	push	r15
    9646:	0f 93       	push	r16
    9648:	1f 93       	push	r17
    964a:	cf 93       	push	r28
    964c:	df 93       	push	r29
    964e:	cd b7       	in	r28, 0x3d	; 61
    9650:	de b7       	in	r29, 0x3e	; 62
    9652:	29 97       	sbiw	r28, 0x09	; 9
    9654:	cd bf       	out	0x3d, r28	; 61
    9656:	de bf       	out	0x3e, r29	; 62
    9658:	8d 83       	std	Y+5, r24	; 0x05
    965a:	4e 83       	std	Y+6, r20	; 0x06
    965c:	5f 83       	std	Y+7, r21	; 0x07
    965e:	68 87       	std	Y+8, r22	; 0x08
    9660:	79 87       	std	Y+9, r23	; 0x09
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    9662:	8e 81       	ldd	r24, Y+6	; 0x06
    9664:	9f 81       	ldd	r25, Y+7	; 0x07
    9666:	a8 85       	ldd	r26, Y+8	; 0x08
    9668:	b9 85       	ldd	r27, Y+9	; 0x09
    966a:	91 70       	andi	r25, 0x01	; 1
    966c:	a0 70       	andi	r26, 0x00	; 0
    966e:	b0 70       	andi	r27, 0x00	; 0
    9670:	00 97       	sbiw	r24, 0x00	; 0
    9672:	a1 05       	cpc	r26, r1
    9674:	b1 05       	cpc	r27, r1
    9676:	91 f4       	brne	.+36     	; 0x969c <freeMemoryUpdate+0x5a>
    9678:	8e 81       	ldd	r24, Y+6	; 0x06
    967a:	9f 81       	ldd	r25, Y+7	; 0x07
    967c:	a8 85       	ldd	r26, Y+8	; 0x08
    967e:	b9 85       	ldd	r27, Y+9	; 0x09
    9680:	07 2e       	mov	r0, r23
    9682:	79 e0       	ldi	r23, 0x09	; 9
    9684:	b6 95       	lsr	r27
    9686:	a7 95       	ror	r26
    9688:	97 95       	ror	r25
    968a:	87 95       	ror	r24
    968c:	7a 95       	dec	r23
    968e:	d1 f7       	brne	.-12     	; 0x9684 <freeMemoryUpdate+0x42>
    9690:	70 2d       	mov	r23, r0
    9692:	8e 83       	std	Y+6, r24	; 0x06
    9694:	9f 83       	std	Y+7, r25	; 0x07
    9696:	a8 87       	std	Y+8, r26	; 0x08
    9698:	b9 87       	std	Y+9, r27	; 0x09
    969a:	14 c0       	rjmp	.+40     	; 0x96c4 <freeMemoryUpdate+0x82>
  else size = (size / 512) +1;
    969c:	8e 81       	ldd	r24, Y+6	; 0x06
    969e:	9f 81       	ldd	r25, Y+7	; 0x07
    96a0:	a8 85       	ldd	r26, Y+8	; 0x08
    96a2:	b9 85       	ldd	r27, Y+9	; 0x09
    96a4:	07 2e       	mov	r0, r23
    96a6:	79 e0       	ldi	r23, 0x09	; 9
    96a8:	b6 95       	lsr	r27
    96aa:	a7 95       	ror	r26
    96ac:	97 95       	ror	r25
    96ae:	87 95       	ror	r24
    96b0:	7a 95       	dec	r23
    96b2:	d1 f7       	brne	.-12     	; 0x96a8 <freeMemoryUpdate+0x66>
    96b4:	70 2d       	mov	r23, r0
    96b6:	01 96       	adiw	r24, 0x01	; 1
    96b8:	a1 1d       	adc	r26, r1
    96ba:	b1 1d       	adc	r27, r1
    96bc:	8e 83       	std	Y+6, r24	; 0x06
    96be:	9f 83       	std	Y+7, r25	; 0x07
    96c0:	a8 87       	std	Y+8, r26	; 0x08
    96c2:	b9 87       	std	Y+9, r27	; 0x09
  if((size % 8) == 0) size = size / 8;
    96c4:	8e 81       	ldd	r24, Y+6	; 0x06
    96c6:	9f 81       	ldd	r25, Y+7	; 0x07
    96c8:	a8 85       	ldd	r26, Y+8	; 0x08
    96ca:	b9 85       	ldd	r27, Y+9	; 0x09
    96cc:	87 70       	andi	r24, 0x07	; 7
    96ce:	90 70       	andi	r25, 0x00	; 0
    96d0:	a0 70       	andi	r26, 0x00	; 0
    96d2:	b0 70       	andi	r27, 0x00	; 0
    96d4:	00 97       	sbiw	r24, 0x00	; 0
    96d6:	a1 05       	cpc	r26, r1
    96d8:	b1 05       	cpc	r27, r1
    96da:	89 f4       	brne	.+34     	; 0x96fe <freeMemoryUpdate+0xbc>
    96dc:	8e 81       	ldd	r24, Y+6	; 0x06
    96de:	9f 81       	ldd	r25, Y+7	; 0x07
    96e0:	a8 85       	ldd	r26, Y+8	; 0x08
    96e2:	b9 85       	ldd	r27, Y+9	; 0x09
    96e4:	68 94       	set
    96e6:	12 f8       	bld	r1, 2
    96e8:	b6 95       	lsr	r27
    96ea:	a7 95       	ror	r26
    96ec:	97 95       	ror	r25
    96ee:	87 95       	ror	r24
    96f0:	16 94       	lsr	r1
    96f2:	d1 f7       	brne	.-12     	; 0x96e8 <freeMemoryUpdate+0xa6>
    96f4:	8e 83       	std	Y+6, r24	; 0x06
    96f6:	9f 83       	std	Y+7, r25	; 0x07
    96f8:	a8 87       	std	Y+8, r26	; 0x08
    96fa:	b9 87       	std	Y+9, r27	; 0x09
    96fc:	13 c0       	rjmp	.+38     	; 0x9724 <freeMemoryUpdate+0xe2>
  else size = (size / 8) +1;
    96fe:	8e 81       	ldd	r24, Y+6	; 0x06
    9700:	9f 81       	ldd	r25, Y+7	; 0x07
    9702:	a8 85       	ldd	r26, Y+8	; 0x08
    9704:	b9 85       	ldd	r27, Y+9	; 0x09
    9706:	68 94       	set
    9708:	12 f8       	bld	r1, 2
    970a:	b6 95       	lsr	r27
    970c:	a7 95       	ror	r26
    970e:	97 95       	ror	r25
    9710:	87 95       	ror	r24
    9712:	16 94       	lsr	r1
    9714:	d1 f7       	brne	.-12     	; 0x970a <freeMemoryUpdate+0xc8>
    9716:	01 96       	adiw	r24, 0x01	; 1
    9718:	a1 1d       	adc	r26, r1
    971a:	b1 1d       	adc	r27, r1
    971c:	8e 83       	std	Y+6, r24	; 0x06
    971e:	9f 83       	std	Y+7, r25	; 0x07
    9720:	a8 87       	std	Y+8, r26	; 0x08
    9722:	b9 87       	std	Y+9, r27	; 0x09

  if(freeClusterCountUpdated)
    9724:	80 91 c4 50 	lds	r24, 0x50C4
    9728:	88 23       	and	r24, r24
    972a:	e9 f1       	breq	.+122    	; 0x97a6 <freeMemoryUpdate+0x164>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    972c:	81 e0       	ldi	r24, 0x01	; 1
    972e:	60 e0       	ldi	r22, 0x00	; 0
    9730:	20 e0       	ldi	r18, 0x00	; 0
    9732:	30 e0       	ldi	r19, 0x00	; 0
    9734:	a9 01       	movw	r20, r18
    9736:	0e 94 02 42 	call	0x8404	; 0x8404 <getSetFreeCluster>
    973a:	dc 01       	movw	r26, r24
    973c:	cb 01       	movw	r24, r22
    973e:	89 83       	std	Y+1, r24	; 0x01
    9740:	9a 83       	std	Y+2, r25	; 0x02
    9742:	ab 83       	std	Y+3, r26	; 0x03
    9744:	bc 83       	std	Y+4, r27	; 0x04
	if(flag == ADD)
    9746:	8d 81       	ldd	r24, Y+5	; 0x05
    9748:	88 23       	and	r24, r24
    974a:	89 f4       	brne	.+34     	; 0x976e <freeMemoryUpdate+0x12c>
  	   freeClusters = freeClusters + size;
    974c:	29 81       	ldd	r18, Y+1	; 0x01
    974e:	3a 81       	ldd	r19, Y+2	; 0x02
    9750:	4b 81       	ldd	r20, Y+3	; 0x03
    9752:	5c 81       	ldd	r21, Y+4	; 0x04
    9754:	8e 81       	ldd	r24, Y+6	; 0x06
    9756:	9f 81       	ldd	r25, Y+7	; 0x07
    9758:	a8 85       	ldd	r26, Y+8	; 0x08
    975a:	b9 85       	ldd	r27, Y+9	; 0x09
    975c:	82 0f       	add	r24, r18
    975e:	93 1f       	adc	r25, r19
    9760:	a4 1f       	adc	r26, r20
    9762:	b5 1f       	adc	r27, r21
    9764:	89 83       	std	Y+1, r24	; 0x01
    9766:	9a 83       	std	Y+2, r25	; 0x02
    9768:	ab 83       	std	Y+3, r26	; 0x03
    976a:	bc 83       	std	Y+4, r27	; 0x04
    976c:	14 c0       	rjmp	.+40     	; 0x9796 <freeMemoryUpdate+0x154>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    976e:	29 81       	ldd	r18, Y+1	; 0x01
    9770:	3a 81       	ldd	r19, Y+2	; 0x02
    9772:	4b 81       	ldd	r20, Y+3	; 0x03
    9774:	5c 81       	ldd	r21, Y+4	; 0x04
    9776:	8e 81       	ldd	r24, Y+6	; 0x06
    9778:	9f 81       	ldd	r25, Y+7	; 0x07
    977a:	a8 85       	ldd	r26, Y+8	; 0x08
    977c:	b9 85       	ldd	r27, Y+9	; 0x09
    977e:	79 01       	movw	r14, r18
    9780:	8a 01       	movw	r16, r20
    9782:	e8 1a       	sub	r14, r24
    9784:	f9 0a       	sbc	r15, r25
    9786:	0a 0b       	sbc	r16, r26
    9788:	1b 0b       	sbc	r17, r27
    978a:	d8 01       	movw	r26, r16
    978c:	c7 01       	movw	r24, r14
    978e:	89 83       	std	Y+1, r24	; 0x01
    9790:	9a 83       	std	Y+2, r25	; 0x02
    9792:	ab 83       	std	Y+3, r26	; 0x03
    9794:	bc 83       	std	Y+4, r27	; 0x04
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    9796:	29 81       	ldd	r18, Y+1	; 0x01
    9798:	3a 81       	ldd	r19, Y+2	; 0x02
    979a:	4b 81       	ldd	r20, Y+3	; 0x03
    979c:	5c 81       	ldd	r21, Y+4	; 0x04
    979e:	81 e0       	ldi	r24, 0x01	; 1
    97a0:	61 e0       	ldi	r22, 0x01	; 1
    97a2:	0e 94 02 42 	call	0x8404	; 0x8404 <getSetFreeCluster>
  }
}
    97a6:	29 96       	adiw	r28, 0x09	; 9
    97a8:	cd bf       	out	0x3d, r28	; 61
    97aa:	de bf       	out	0x3e, r29	; 62
    97ac:	df 91       	pop	r29
    97ae:	cf 91       	pop	r28
    97b0:	1f 91       	pop	r17
    97b2:	0f 91       	pop	r16
    97b4:	ff 90       	pop	r15
    97b6:	ef 90       	pop	r14
    97b8:	08 95       	ret

000097ba <SD_init>:
# include "E-000001-000009_firmware_rev_1_0.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    97ba:	0f 93       	push	r16
    97bc:	1f 93       	push	r17
    97be:	cf 93       	push	r28
    97c0:	df 93       	push	r29
    97c2:	cd b7       	in	r28, 0x3d	; 61
    97c4:	de b7       	in	r29, 0x3e	; 62
    97c6:	a9 97       	sbiw	r28, 0x29	; 41
    97c8:	cd bf       	out	0x3d, r28	; 61
    97ca:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);				//power up portEX
    97cc:	81 e0       	ldi	r24, 0x01	; 1
    97ce:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    97d2:	81 e0       	ldi	r24, 0x01	; 1
    97d4:	0e 94 3e 35 	call	0x6a7c	; 0x6a7c <Ext1Power>
    97d8:	80 e0       	ldi	r24, 0x00	; 0
    97da:	90 e0       	ldi	r25, 0x00	; 0
    97dc:	a8 ec       	ldi	r26, 0xC8	; 200
    97de:	b2 e4       	ldi	r27, 0x42	; 66
    97e0:	8e 87       	std	Y+14, r24	; 0x0e
    97e2:	9f 87       	std	Y+15, r25	; 0x0f
    97e4:	a8 8b       	std	Y+16, r26	; 0x10
    97e6:	b9 8b       	std	Y+17, r27	; 0x11
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    97e8:	6e 85       	ldd	r22, Y+14	; 0x0e
    97ea:	7f 85       	ldd	r23, Y+15	; 0x0f
    97ec:	88 89       	ldd	r24, Y+16	; 0x10
    97ee:	99 89       	ldd	r25, Y+17	; 0x11
    97f0:	20 e0       	ldi	r18, 0x00	; 0
    97f2:	30 e0       	ldi	r19, 0x00	; 0
    97f4:	4a ef       	ldi	r20, 0xFA	; 250
    97f6:	55 e4       	ldi	r21, 0x45	; 69
    97f8:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    97fc:	dc 01       	movw	r26, r24
    97fe:	cb 01       	movw	r24, r22
    9800:	8a 8b       	std	Y+18, r24	; 0x12
    9802:	9b 8b       	std	Y+19, r25	; 0x13
    9804:	ac 8b       	std	Y+20, r26	; 0x14
    9806:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
    9808:	11 e0       	ldi	r17, 0x01	; 1
    980a:	6a 89       	ldd	r22, Y+18	; 0x12
    980c:	7b 89       	ldd	r23, Y+19	; 0x13
    980e:	8c 89       	ldd	r24, Y+20	; 0x14
    9810:	9d 89       	ldd	r25, Y+21	; 0x15
    9812:	20 e0       	ldi	r18, 0x00	; 0
    9814:	30 e0       	ldi	r19, 0x00	; 0
    9816:	40 e8       	ldi	r20, 0x80	; 128
    9818:	5f e3       	ldi	r21, 0x3F	; 63
    981a:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    981e:	88 23       	and	r24, r24
    9820:	0c f0       	brlt	.+2      	; 0x9824 <SD_init+0x6a>
    9822:	10 e0       	ldi	r17, 0x00	; 0
    9824:	11 23       	and	r17, r17
    9826:	29 f0       	breq	.+10     	; 0x9832 <SD_init+0x78>
		__ticks = 1;
    9828:	81 e0       	ldi	r24, 0x01	; 1
    982a:	90 e0       	ldi	r25, 0x00	; 0
    982c:	8e 8b       	std	Y+22, r24	; 0x16
    982e:	9f 8b       	std	Y+23, r25	; 0x17
    9830:	46 c0       	rjmp	.+140    	; 0x98be <SD_init+0x104>
	else if (__tmp > 65535)
    9832:	11 e0       	ldi	r17, 0x01	; 1
    9834:	6a 89       	ldd	r22, Y+18	; 0x12
    9836:	7b 89       	ldd	r23, Y+19	; 0x13
    9838:	8c 89       	ldd	r24, Y+20	; 0x14
    983a:	9d 89       	ldd	r25, Y+21	; 0x15
    983c:	20 e0       	ldi	r18, 0x00	; 0
    983e:	3f ef       	ldi	r19, 0xFF	; 255
    9840:	4f e7       	ldi	r20, 0x7F	; 127
    9842:	57 e4       	ldi	r21, 0x47	; 71
    9844:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    9848:	18 16       	cp	r1, r24
    984a:	0c f0       	brlt	.+2      	; 0x984e <SD_init+0x94>
    984c:	10 e0       	ldi	r17, 0x00	; 0
    984e:	11 23       	and	r17, r17
    9850:	61 f1       	breq	.+88     	; 0x98aa <SD_init+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9852:	6e 85       	ldd	r22, Y+14	; 0x0e
    9854:	7f 85       	ldd	r23, Y+15	; 0x0f
    9856:	88 89       	ldd	r24, Y+16	; 0x10
    9858:	99 89       	ldd	r25, Y+17	; 0x11
    985a:	20 e0       	ldi	r18, 0x00	; 0
    985c:	30 e0       	ldi	r19, 0x00	; 0
    985e:	40 e2       	ldi	r20, 0x20	; 32
    9860:	51 e4       	ldi	r21, 0x41	; 65
    9862:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    9866:	dc 01       	movw	r26, r24
    9868:	cb 01       	movw	r24, r22
    986a:	bc 01       	movw	r22, r24
    986c:	cd 01       	movw	r24, r26
    986e:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    9872:	dc 01       	movw	r26, r24
    9874:	cb 01       	movw	r24, r22
    9876:	8e 8b       	std	Y+22, r24	; 0x16
    9878:	9f 8b       	std	Y+23, r25	; 0x17
    987a:	12 c0       	rjmp	.+36     	; 0x98a0 <SD_init+0xe6>
    987c:	80 e2       	ldi	r24, 0x20	; 32
    987e:	93 e0       	ldi	r25, 0x03	; 3
    9880:	88 8f       	std	Y+24, r24	; 0x18
    9882:	99 8f       	std	Y+25, r25	; 0x19
    9884:	88 8d       	ldd	r24, Y+24	; 0x18
    9886:	99 8d       	ldd	r25, Y+25	; 0x19
    9888:	8c 01       	movw	r16, r24
    988a:	c8 01       	movw	r24, r16
    988c:	01 97       	sbiw	r24, 0x01	; 1
    988e:	f1 f7       	brne	.-4      	; 0x988c <SD_init+0xd2>
    9890:	8c 01       	movw	r16, r24
    9892:	08 8f       	std	Y+24, r16	; 0x18
    9894:	19 8f       	std	Y+25, r17	; 0x19
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9896:	8e 89       	ldd	r24, Y+22	; 0x16
    9898:	9f 89       	ldd	r25, Y+23	; 0x17
    989a:	01 97       	sbiw	r24, 0x01	; 1
    989c:	8e 8b       	std	Y+22, r24	; 0x16
    989e:	9f 8b       	std	Y+23, r25	; 0x17
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    98a0:	8e 89       	ldd	r24, Y+22	; 0x16
    98a2:	9f 89       	ldd	r25, Y+23	; 0x17
    98a4:	00 97       	sbiw	r24, 0x00	; 0
    98a6:	51 f7       	brne	.-44     	; 0x987c <SD_init+0xc2>
    98a8:	17 c0       	rjmp	.+46     	; 0x98d8 <SD_init+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    98aa:	6a 89       	ldd	r22, Y+18	; 0x12
    98ac:	7b 89       	ldd	r23, Y+19	; 0x13
    98ae:	8c 89       	ldd	r24, Y+20	; 0x14
    98b0:	9d 89       	ldd	r25, Y+21	; 0x15
    98b2:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    98b6:	dc 01       	movw	r26, r24
    98b8:	cb 01       	movw	r24, r22
    98ba:	8e 8b       	std	Y+22, r24	; 0x16
    98bc:	9f 8b       	std	Y+23, r25	; 0x17
    98be:	8e 89       	ldd	r24, Y+22	; 0x16
    98c0:	9f 89       	ldd	r25, Y+23	; 0x17
    98c2:	8a 8f       	std	Y+26, r24	; 0x1a
    98c4:	9b 8f       	std	Y+27, r25	; 0x1b
    98c6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    98c8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    98ca:	8c 01       	movw	r16, r24
    98cc:	f8 01       	movw	r30, r16
    98ce:	31 97       	sbiw	r30, 0x01	; 1
    98d0:	f1 f7       	brne	.-4      	; 0x98ce <SD_init+0x114>
    98d2:	8f 01       	movw	r16, r30
    98d4:	0a 8f       	std	Y+26, r16	; 0x1a
    98d6:	1b 8f       	std	Y+27, r17	; 0x1b
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    98d8:	19 82       	std	Y+1, r1	; 0x01

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    98da:	88 e0       	ldi	r24, 0x08	; 8
    98dc:	60 e0       	ldi	r22, 0x00	; 0
    98de:	0e 94 a8 33 	call	0x6750	; 0x6750 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    98e2:	88 e0       	ldi	r24, 0x08	; 8
    98e4:	60 e0       	ldi	r22, 0x00	; 0
    98e6:	0e 94 74 34 	call	0x68e8	; 0x68e8 <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    98ea:	80 e0       	ldi	r24, 0x00	; 0
    98ec:	90 e0       	ldi	r25, 0x00	; 0
    98ee:	63 e0       	ldi	r22, 0x03	; 3
    98f0:	70 e0       	ldi	r23, 0x00	; 0
    98f2:	0e 94 6c 38 	call	0x70d8	; 0x70d8 <SPIInit2>
	SPICS(TRUE);
    98f6:	81 e0       	ldi	r24, 0x01	; 1
    98f8:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    98fc:	1a 82       	std	Y+2, r1	; 0x02
    98fe:	1b 82       	std	Y+3, r1	; 0x03
    9900:	17 c0       	rjmp	.+46     	; 0x9930 <SD_init+0x176>
		SPIC.DATA=SDHC_DUMMY_BYTE;
    9902:	80 ec       	ldi	r24, 0xC0	; 192
    9904:	98 e0       	ldi	r25, 0x08	; 8
    9906:	2f ef       	ldi	r18, 0xFF	; 255
    9908:	fc 01       	movw	r30, r24
    990a:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    990c:	00 00       	nop
    990e:	80 ec       	ldi	r24, 0xC0	; 192
    9910:	98 e0       	ldi	r25, 0x08	; 8
    9912:	fc 01       	movw	r30, r24
    9914:	82 81       	ldd	r24, Z+2	; 0x02
    9916:	88 23       	and	r24, r24
    9918:	d4 f7       	brge	.-12     	; 0x990e <SD_init+0x154>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    991a:	80 ec       	ldi	r24, 0xC0	; 192
    991c:	98 e0       	ldi	r25, 0x08	; 8
    991e:	fc 01       	movw	r30, r24
    9920:	83 81       	ldd	r24, Z+3	; 0x03
    9922:	80 93 af 50 	sts	0x50AF, r24
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9926:	8a 81       	ldd	r24, Y+2	; 0x02
    9928:	9b 81       	ldd	r25, Y+3	; 0x03
    992a:	01 96       	adiw	r24, 0x01	; 1
    992c:	8a 83       	std	Y+2, r24	; 0x02
    992e:	9b 83       	std	Y+3, r25	; 0x03
    9930:	8a 81       	ldd	r24, Y+2	; 0x02
    9932:	9b 81       	ldd	r25, Y+3	; 0x03
    9934:	8a 30       	cpi	r24, 0x0A	; 10
    9936:	91 05       	cpc	r25, r1
    9938:	24 f3       	brlt	.-56     	; 0x9902 <SD_init+0x148>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    993a:	80 e0       	ldi	r24, 0x00	; 0
    993c:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	SPIDisable();
    9940:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9944:	88 e0       	ldi	r24, 0x08	; 8
    9946:	60 e0       	ldi	r22, 0x00	; 0
    9948:	0e 94 d7 34 	call	0x69ae	; 0x69ae <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    994c:	80 e0       	ldi	r24, 0x00	; 0
    994e:	90 e0       	ldi	r25, 0x00	; 0
    9950:	63 e0       	ldi	r22, 0x03	; 3
    9952:	70 e0       	ldi	r23, 0x00	; 0
    9954:	0e 94 6c 38 	call	0x70d8	; 0x70d8 <SPIInit2>
	SPICS(TRUE);
    9958:	81 e0       	ldi	r24, 0x01	; 1
    995a:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    995e:	1c 82       	std	Y+4, r1	; 0x04
    9960:	1d 82       	std	Y+5, r1	; 0x05
    9962:	0d c0       	rjmp	.+26     	; 0x997e <SD_init+0x1c4>
		if (i >= 10) {												//try command 10 times before timing out
    9964:	8c 81       	ldd	r24, Y+4	; 0x04
    9966:	9d 81       	ldd	r25, Y+5	; 0x05
    9968:	8a 30       	cpi	r24, 0x0A	; 10
    996a:	91 05       	cpc	r25, r1
    996c:	1c f0       	brlt	.+6      	; 0x9974 <SD_init+0x1ba>
			//there was no response to the first command
			errorCode = 1;
    996e:	81 e0       	ldi	r24, 0x01	; 1
    9970:	89 83       	std	Y+1, r24	; 0x01
			break;
    9972:	10 c0       	rjmp	.+32     	; 0x9994 <SD_init+0x1da>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    9974:	8c 81       	ldd	r24, Y+4	; 0x04
    9976:	9d 81       	ldd	r25, Y+5	; 0x05
    9978:	01 96       	adiw	r24, 0x01	; 1
    997a:	8c 83       	std	Y+4, r24	; 0x04
    997c:	9d 83       	std	Y+5, r25	; 0x05
    997e:	80 e0       	ldi	r24, 0x00	; 0
    9980:	40 e0       	ldi	r20, 0x00	; 0
    9982:	50 e0       	ldi	r21, 0x00	; 0
    9984:	ba 01       	movw	r22, r20
    9986:	25 e9       	ldi	r18, 0x95	; 149
    9988:	08 e0       	ldi	r16, 0x08	; 8
    998a:	10 e0       	ldi	r17, 0x00	; 0
    998c:	0e 94 06 4e 	call	0x9c0c	; 0x9c0c <SD_command>
    9990:	81 30       	cpi	r24, 0x01	; 1
    9992:	41 f7       	brne	.-48     	; 0x9964 <SD_init+0x1aa>
    9994:	80 e0       	ldi	r24, 0x00	; 0
    9996:	90 e0       	ldi	r25, 0x00	; 0
    9998:	a8 ec       	ldi	r26, 0xC8	; 200
    999a:	b2 e4       	ldi	r27, 0x42	; 66
    999c:	8c 8f       	std	Y+28, r24	; 0x1c
    999e:	9d 8f       	std	Y+29, r25	; 0x1d
    99a0:	ae 8f       	std	Y+30, r26	; 0x1e
    99a2:	bf 8f       	std	Y+31, r27	; 0x1f
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    99a4:	6c 8d       	ldd	r22, Y+28	; 0x1c
    99a6:	7d 8d       	ldd	r23, Y+29	; 0x1d
    99a8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    99aa:	9f 8d       	ldd	r25, Y+31	; 0x1f
    99ac:	20 e0       	ldi	r18, 0x00	; 0
    99ae:	30 e0       	ldi	r19, 0x00	; 0
    99b0:	4a ef       	ldi	r20, 0xFA	; 250
    99b2:	55 e4       	ldi	r21, 0x45	; 69
    99b4:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    99b8:	dc 01       	movw	r26, r24
    99ba:	cb 01       	movw	r24, r22
    99bc:	88 a3       	lds	r24, 0x58
    99be:	99 a3       	lds	r25, 0x59
    99c0:	aa a3       	lds	r26, 0x5a
    99c2:	bb a3       	lds	r27, 0x5b
	if (__tmp < 1.0)
    99c4:	11 e0       	ldi	r17, 0x01	; 1
    99c6:	68 a1       	lds	r22, 0x48
    99c8:	79 a1       	lds	r23, 0x49
    99ca:	8a a1       	lds	r24, 0x4a
    99cc:	9b a1       	lds	r25, 0x4b
    99ce:	20 e0       	ldi	r18, 0x00	; 0
    99d0:	30 e0       	ldi	r19, 0x00	; 0
    99d2:	40 e8       	ldi	r20, 0x80	; 128
    99d4:	5f e3       	ldi	r21, 0x3F	; 63
    99d6:	0e 94 95 61 	call	0xc32a	; 0xc32a <__cmpsf2>
    99da:	88 23       	and	r24, r24
    99dc:	0c f0       	brlt	.+2      	; 0x99e0 <SD_init+0x226>
    99de:	10 e0       	ldi	r17, 0x00	; 0
    99e0:	11 23       	and	r17, r17
    99e2:	29 f0       	breq	.+10     	; 0x99ee <SD_init+0x234>
		__ticks = 1;
    99e4:	81 e0       	ldi	r24, 0x01	; 1
    99e6:	90 e0       	ldi	r25, 0x00	; 0
    99e8:	8c a3       	lds	r24, 0x5c
    99ea:	9d a3       	lds	r25, 0x5d
    99ec:	46 c0       	rjmp	.+140    	; 0x9a7a <SD_init+0x2c0>
	else if (__tmp > 65535)
    99ee:	11 e0       	ldi	r17, 0x01	; 1
    99f0:	68 a1       	lds	r22, 0x48
    99f2:	79 a1       	lds	r23, 0x49
    99f4:	8a a1       	lds	r24, 0x4a
    99f6:	9b a1       	lds	r25, 0x4b
    99f8:	20 e0       	ldi	r18, 0x00	; 0
    99fa:	3f ef       	ldi	r19, 0xFF	; 255
    99fc:	4f e7       	ldi	r20, 0x7F	; 127
    99fe:	57 e4       	ldi	r21, 0x47	; 71
    9a00:	0e 94 a2 62 	call	0xc544	; 0xc544 <__gesf2>
    9a04:	18 16       	cp	r1, r24
    9a06:	0c f0       	brlt	.+2      	; 0x9a0a <SD_init+0x250>
    9a08:	10 e0       	ldi	r17, 0x00	; 0
    9a0a:	11 23       	and	r17, r17
    9a0c:	61 f1       	breq	.+88     	; 0x9a66 <SD_init+0x2ac>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9a0e:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9a10:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9a12:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9a14:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9a16:	20 e0       	ldi	r18, 0x00	; 0
    9a18:	30 e0       	ldi	r19, 0x00	; 0
    9a1a:	40 e2       	ldi	r20, 0x20	; 32
    9a1c:	51 e4       	ldi	r21, 0x41	; 65
    9a1e:	0e 94 a6 62 	call	0xc54c	; 0xc54c <__mulsf3>
    9a22:	dc 01       	movw	r26, r24
    9a24:	cb 01       	movw	r24, r22
    9a26:	bc 01       	movw	r22, r24
    9a28:	cd 01       	movw	r24, r26
    9a2a:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    9a2e:	dc 01       	movw	r26, r24
    9a30:	cb 01       	movw	r24, r22
    9a32:	8c a3       	lds	r24, 0x5c
    9a34:	9d a3       	lds	r25, 0x5d
    9a36:	12 c0       	rjmp	.+36     	; 0x9a5c <SD_init+0x2a2>
    9a38:	80 e2       	ldi	r24, 0x20	; 32
    9a3a:	93 e0       	ldi	r25, 0x03	; 3
    9a3c:	8e a3       	lds	r24, 0x5e
    9a3e:	9f a3       	lds	r25, 0x5f
    9a40:	8e a1       	lds	r24, 0x4e
    9a42:	9f a1       	lds	r25, 0x4f
    9a44:	8c 01       	movw	r16, r24
    9a46:	c8 01       	movw	r24, r16
    9a48:	01 97       	sbiw	r24, 0x01	; 1
    9a4a:	f1 f7       	brne	.-4      	; 0x9a48 <SD_init+0x28e>
    9a4c:	8c 01       	movw	r16, r24
    9a4e:	0e a3       	lds	r16, 0x5e
    9a50:	1f a3       	lds	r17, 0x5f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9a52:	8c a1       	lds	r24, 0x4c
    9a54:	9d a1       	lds	r25, 0x4d
    9a56:	01 97       	sbiw	r24, 0x01	; 1
    9a58:	8c a3       	lds	r24, 0x5c
    9a5a:	9d a3       	lds	r25, 0x5d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    9a5c:	8c a1       	lds	r24, 0x4c
    9a5e:	9d a1       	lds	r25, 0x4d
    9a60:	00 97       	sbiw	r24, 0x00	; 0
    9a62:	51 f7       	brne	.-44     	; 0x9a38 <SD_init+0x27e>
    9a64:	17 c0       	rjmp	.+46     	; 0x9a94 <SD_init+0x2da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9a66:	68 a1       	lds	r22, 0x48
    9a68:	79 a1       	lds	r23, 0x49
    9a6a:	8a a1       	lds	r24, 0x4a
    9a6c:	9b a1       	lds	r25, 0x4b
    9a6e:	0e 94 01 62 	call	0xc402	; 0xc402 <__fixunssfsi>
    9a72:	dc 01       	movw	r26, r24
    9a74:	cb 01       	movw	r24, r22
    9a76:	8c a3       	lds	r24, 0x5c
    9a78:	9d a3       	lds	r25, 0x5d
    9a7a:	8c a1       	lds	r24, 0x4c
    9a7c:	9d a1       	lds	r25, 0x4d
    9a7e:	88 a7       	lds	r24, 0x78
    9a80:	99 a7       	lds	r25, 0x79
    9a82:	88 a5       	lds	r24, 0x68
    9a84:	99 a5       	lds	r25, 0x69
    9a86:	8c 01       	movw	r16, r24
    9a88:	f8 01       	movw	r30, r16
    9a8a:	31 97       	sbiw	r30, 0x01	; 1
    9a8c:	f1 f7       	brne	.-4      	; 0x9a8a <SD_init+0x2d0>
    9a8e:	8f 01       	movw	r16, r30
    9a90:	08 a7       	lds	r16, 0x78
    9a92:	19 a7       	lds	r17, 0x79
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    9a94:	1e 82       	std	Y+6, r1	; 0x06
    9a96:	1f 82       	std	Y+7, r1	; 0x07
    9a98:	0d c0       	rjmp	.+26     	; 0x9ab4 <SD_init+0x2fa>
		if (i >= 10) {
    9a9a:	8e 81       	ldd	r24, Y+6	; 0x06
    9a9c:	9f 81       	ldd	r25, Y+7	; 0x07
    9a9e:	8a 30       	cpi	r24, 0x0A	; 10
    9aa0:	91 05       	cpc	r25, r1
    9aa2:	1c f0       	brlt	.+6      	; 0x9aaa <SD_init+0x2f0>
			//there was no response to the command
			errorCode = 1;
    9aa4:	81 e0       	ldi	r24, 0x01	; 1
    9aa6:	89 83       	std	Y+1, r24	; 0x01
			break;
    9aa8:	11 c0       	rjmp	.+34     	; 0x9acc <SD_init+0x312>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    9aaa:	8e 81       	ldd	r24, Y+6	; 0x06
    9aac:	9f 81       	ldd	r25, Y+7	; 0x07
    9aae:	01 96       	adiw	r24, 0x01	; 1
    9ab0:	8e 83       	std	Y+6, r24	; 0x06
    9ab2:	9f 83       	std	Y+7, r25	; 0x07
    9ab4:	88 e0       	ldi	r24, 0x08	; 8
    9ab6:	4a ea       	ldi	r20, 0xAA	; 170
    9ab8:	51 e0       	ldi	r21, 0x01	; 1
    9aba:	60 e0       	ldi	r22, 0x00	; 0
    9abc:	70 e0       	ldi	r23, 0x00	; 0
    9abe:	27 e8       	ldi	r18, 0x87	; 135
    9ac0:	08 e0       	ldi	r16, 0x08	; 8
    9ac2:	10 e0       	ldi	r17, 0x00	; 0
    9ac4:	0e 94 06 4e 	call	0x9c0c	; 0x9c0c <SD_command>
    9ac8:	81 30       	cpi	r24, 0x01	; 1
    9aca:	39 f7       	brne	.-50     	; 0x9a9a <SD_init+0x2e0>
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9acc:	18 86       	std	Y+8, r1	; 0x08
    9ace:	19 86       	std	Y+9, r1	; 0x09
    9ad0:	13 c0       	rjmp	.+38     	; 0x9af8 <SD_init+0x33e>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    9ad2:	88 85       	ldd	r24, Y+8	; 0x08
    9ad4:	99 85       	ldd	r25, Y+9	; 0x09
    9ad6:	8c 01       	movw	r16, r24
    9ad8:	0e 5f       	subi	r16, 0xFE	; 254
    9ada:	1f 4f       	sbci	r17, 0xFF	; 255
    9adc:	8f ef       	ldi	r24, 0xFF	; 255
    9ade:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    9ae2:	28 2f       	mov	r18, r24
    9ae4:	c8 01       	movw	r24, r16
    9ae6:	8d 55       	subi	r24, 0x5D	; 93
    9ae8:	9f 4a       	sbci	r25, 0xAF	; 175
    9aea:	fc 01       	movw	r30, r24
    9aec:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9aee:	88 85       	ldd	r24, Y+8	; 0x08
    9af0:	99 85       	ldd	r25, Y+9	; 0x09
    9af2:	01 96       	adiw	r24, 0x01	; 1
    9af4:	88 87       	std	Y+8, r24	; 0x08
    9af6:	99 87       	std	Y+9, r25	; 0x09
    9af8:	88 85       	ldd	r24, Y+8	; 0x08
    9afa:	99 85       	ldd	r25, Y+9	; 0x09
    9afc:	84 30       	cpi	r24, 0x04	; 4
    9afe:	91 05       	cpc	r25, r1
    9b00:	44 f3       	brlt	.-48     	; 0x9ad2 <SD_init+0x318>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    9b02:	80 91 a7 50 	lds	r24, 0x50A7
    9b06:	81 30       	cpi	r24, 0x01	; 1
    9b08:	21 f4       	brne	.+8      	; 0x9b12 <SD_init+0x358>
    9b0a:	80 91 a8 50 	lds	r24, 0x50A8
    9b0e:	8a 3a       	cpi	r24, 0xAA	; 170
    9b10:	11 f0       	breq	.+4      	; 0x9b16 <SD_init+0x35c>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    9b12:	81 e0       	ldi	r24, 0x01	; 1
    9b14:	89 83       	std	Y+1, r24	; 0x01
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    9b16:	87 e3       	ldi	r24, 0x37	; 55
    9b18:	40 e0       	ldi	r20, 0x00	; 0
    9b1a:	50 e0       	ldi	r21, 0x00	; 0
    9b1c:	ba 01       	movw	r22, r20
    9b1e:	2f ef       	ldi	r18, 0xFF	; 255
    9b20:	08 e0       	ldi	r16, 0x08	; 8
    9b22:	10 e0       	ldi	r17, 0x00	; 0
    9b24:	0e 94 06 4e 	call	0x9c0c	; 0x9c0c <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    9b28:	81 e0       	ldi	r24, 0x01	; 1
    9b2a:	40 e0       	ldi	r20, 0x00	; 0
    9b2c:	50 e0       	ldi	r21, 0x00	; 0
    9b2e:	60 e0       	ldi	r22, 0x00	; 0
    9b30:	70 e4       	ldi	r23, 0x40	; 64
    9b32:	2f ef       	ldi	r18, 0xFF	; 255
    9b34:	08 e0       	ldi	r16, 0x08	; 8
    9b36:	10 e0       	ldi	r17, 0x00	; 0
    9b38:	0e 94 06 4e 	call	0x9c0c	; 0x9c0c <SD_command>
	} while(Buffer[1]!= 0x00);
    9b3c:	80 91 a4 50 	lds	r24, 0x50A4
    9b40:	88 23       	and	r24, r24
    9b42:	49 f7       	brne	.-46     	; 0x9b16 <SD_init+0x35c>
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9b44:	1a 86       	std	Y+10, r1	; 0x0a
    9b46:	1b 86       	std	Y+11, r1	; 0x0b
    9b48:	0d c0       	rjmp	.+26     	; 0x9b64 <SD_init+0x3aa>
		if (i >= 10) {
    9b4a:	8a 85       	ldd	r24, Y+10	; 0x0a
    9b4c:	9b 85       	ldd	r25, Y+11	; 0x0b
    9b4e:	8a 30       	cpi	r24, 0x0A	; 10
    9b50:	91 05       	cpc	r25, r1
    9b52:	1c f0       	brlt	.+6      	; 0x9b5a <SD_init+0x3a0>
			//there was no response to the command
			errorCode = 1;
    9b54:	81 e0       	ldi	r24, 0x01	; 1
    9b56:	89 83       	std	Y+1, r24	; 0x01
			break;
    9b58:	10 c0       	rjmp	.+32     	; 0x9b7a <SD_init+0x3c0>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9b5a:	8a 85       	ldd	r24, Y+10	; 0x0a
    9b5c:	9b 85       	ldd	r25, Y+11	; 0x0b
    9b5e:	01 96       	adiw	r24, 0x01	; 1
    9b60:	8a 87       	std	Y+10, r24	; 0x0a
    9b62:	9b 87       	std	Y+11, r25	; 0x0b
    9b64:	8a e3       	ldi	r24, 0x3A	; 58
    9b66:	40 e0       	ldi	r20, 0x00	; 0
    9b68:	50 e0       	ldi	r21, 0x00	; 0
    9b6a:	ba 01       	movw	r22, r20
    9b6c:	2f ef       	ldi	r18, 0xFF	; 255
    9b6e:	08 e0       	ldi	r16, 0x08	; 8
    9b70:	10 e0       	ldi	r17, 0x00	; 0
    9b72:	0e 94 06 4e 	call	0x9c0c	; 0x9c0c <SD_command>
    9b76:	88 23       	and	r24, r24
    9b78:	41 f7       	brne	.-48     	; 0x9b4a <SD_init+0x390>
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9b7a:	1c 86       	std	Y+12, r1	; 0x0c
    9b7c:	1d 86       	std	Y+13, r1	; 0x0d
    9b7e:	0f c0       	rjmp	.+30     	; 0x9b9e <SD_init+0x3e4>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    9b80:	8f ef       	ldi	r24, 0xFF	; 255
    9b82:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    9b86:	28 2f       	mov	r18, r24
    9b88:	8c 85       	ldd	r24, Y+12	; 0x0c
    9b8a:	9d 85       	ldd	r25, Y+13	; 0x0d
    9b8c:	8d 55       	subi	r24, 0x5D	; 93
    9b8e:	9f 4a       	sbci	r25, 0xAF	; 175
    9b90:	fc 01       	movw	r30, r24
    9b92:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    9b94:	8c 85       	ldd	r24, Y+12	; 0x0c
    9b96:	9d 85       	ldd	r25, Y+13	; 0x0d
    9b98:	01 96       	adiw	r24, 0x01	; 1
    9b9a:	8c 87       	std	Y+12, r24	; 0x0c
    9b9c:	9d 87       	std	Y+13, r25	; 0x0d
    9b9e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9ba0:	9d 85       	ldd	r25, Y+13	; 0x0d
    9ba2:	84 30       	cpi	r24, 0x04	; 4
    9ba4:	91 05       	cpc	r25, r1
    9ba6:	64 f3       	brlt	.-40     	; 0x9b80 <SD_init+0x3c6>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    9ba8:	80 91 a3 50 	lds	r24, 0x50A3
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    9bac:	80 e0       	ldi	r24, 0x00	; 0
    9bae:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	SPIDisable();
    9bb2:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9bb6:	88 e0       	ldi	r24, 0x08	; 8
    9bb8:	60 e0       	ldi	r22, 0x00	; 0
    9bba:	0e 94 74 34 	call	0x68e8	; 0x68e8 <PortEx_OUTSET>
	return errorCode;	
    9bbe:	89 81       	ldd	r24, Y+1	; 0x01
}	
    9bc0:	a9 96       	adiw	r28, 0x29	; 41
    9bc2:	cd bf       	out	0x3d, r28	; 61
    9bc4:	de bf       	out	0x3e, r29	; 62
    9bc6:	df 91       	pop	r29
    9bc8:	cf 91       	pop	r28
    9bca:	1f 91       	pop	r17
    9bcc:	0f 91       	pop	r16
    9bce:	08 95       	ret

00009bd0 <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
    9bd0:	cf 93       	push	r28
    9bd2:	df 93       	push	r29
    9bd4:	0f 92       	push	r0
    9bd6:	0f 92       	push	r0
    9bd8:	cd b7       	in	r28, 0x3d	; 61
    9bda:	de b7       	in	r29, 0x3e	; 62
    9bdc:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPIC.DATA = byteToSend;
    9bde:	80 ec       	ldi	r24, 0xC0	; 192
    9be0:	98 e0       	ldi	r25, 0x08	; 8
    9be2:	2a 81       	ldd	r18, Y+2	; 0x02
    9be4:	fc 01       	movw	r30, r24
    9be6:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9be8:	00 00       	nop
    9bea:	80 ec       	ldi	r24, 0xC0	; 192
    9bec:	98 e0       	ldi	r25, 0x08	; 8
    9bee:	fc 01       	movw	r30, r24
    9bf0:	82 81       	ldd	r24, Z+2	; 0x02
    9bf2:	88 23       	and	r24, r24
    9bf4:	d4 f7       	brge	.-12     	; 0x9bea <SPI_write+0x1a>
	data = SPIC.DATA; //read SPI data register to reset status flag
    9bf6:	80 ec       	ldi	r24, 0xC0	; 192
    9bf8:	98 e0       	ldi	r25, 0x08	; 8
    9bfa:	fc 01       	movw	r30, r24
    9bfc:	83 81       	ldd	r24, Z+3	; 0x03
    9bfe:	89 83       	std	Y+1, r24	; 0x01
	return data;
    9c00:	89 81       	ldd	r24, Y+1	; 0x01
}
    9c02:	0f 90       	pop	r0
    9c04:	0f 90       	pop	r0
    9c06:	df 91       	pop	r29
    9c08:	cf 91       	pop	r28
    9c0a:	08 95       	ret

00009c0c <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    9c0c:	0f 93       	push	r16
    9c0e:	1f 93       	push	r17
    9c10:	cf 93       	push	r28
    9c12:	df 93       	push	r29
    9c14:	cd b7       	in	r28, 0x3d	; 61
    9c16:	de b7       	in	r29, 0x3e	; 62
    9c18:	2a 97       	sbiw	r28, 0x0a	; 10
    9c1a:	cd bf       	out	0x3d, r28	; 61
    9c1c:	de bf       	out	0x3e, r29	; 62
    9c1e:	8b 83       	std	Y+3, r24	; 0x03
    9c20:	4c 83       	std	Y+4, r20	; 0x04
    9c22:	5d 83       	std	Y+5, r21	; 0x05
    9c24:	6e 83       	std	Y+6, r22	; 0x06
    9c26:	7f 83       	std	Y+7, r23	; 0x07
    9c28:	28 87       	std	Y+8, r18	; 0x08
    9c2a:	09 87       	std	Y+9, r16	; 0x09
    9c2c:	1a 87       	std	Y+10, r17	; 0x0a
	
	SPI_write(SDHC_COMMAND_START | cmd);
    9c2e:	8b 81       	ldd	r24, Y+3	; 0x03
    9c30:	80 64       	ori	r24, 0x40	; 64
    9c32:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    9c36:	8c 81       	ldd	r24, Y+4	; 0x04
    9c38:	9d 81       	ldd	r25, Y+5	; 0x05
    9c3a:	ae 81       	ldd	r26, Y+6	; 0x06
    9c3c:	bf 81       	ldd	r27, Y+7	; 0x07
    9c3e:	8b 2f       	mov	r24, r27
    9c40:	99 27       	eor	r25, r25
    9c42:	aa 27       	eor	r26, r26
    9c44:	bb 27       	eor	r27, r27
    9c46:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    9c4a:	8c 81       	ldd	r24, Y+4	; 0x04
    9c4c:	9d 81       	ldd	r25, Y+5	; 0x05
    9c4e:	ae 81       	ldd	r26, Y+6	; 0x06
    9c50:	bf 81       	ldd	r27, Y+7	; 0x07
    9c52:	cd 01       	movw	r24, r26
    9c54:	aa 27       	eor	r26, r26
    9c56:	bb 27       	eor	r27, r27
    9c58:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    9c5c:	8c 81       	ldd	r24, Y+4	; 0x04
    9c5e:	9d 81       	ldd	r25, Y+5	; 0x05
    9c60:	ae 81       	ldd	r26, Y+6	; 0x06
    9c62:	bf 81       	ldd	r27, Y+7	; 0x07
    9c64:	89 2f       	mov	r24, r25
    9c66:	9a 2f       	mov	r25, r26
    9c68:	ab 2f       	mov	r26, r27
    9c6a:	bb 27       	eor	r27, r27
    9c6c:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    9c70:	8c 81       	ldd	r24, Y+4	; 0x04
    9c72:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
	SPI_write(crc);
    9c76:	88 85       	ldd	r24, Y+8	; 0x08
    9c78:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
	
	for(int i=0; i<read; i++){
    9c7c:	19 82       	std	Y+1, r1	; 0x01
    9c7e:	1a 82       	std	Y+2, r1	; 0x02
    9c80:	33 c0       	rjmp	.+102    	; 0x9ce8 <SD_command+0xdc>
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    9c82:	89 81       	ldd	r24, Y+1	; 0x01
    9c84:	9a 81       	ldd	r25, Y+2	; 0x02
    9c86:	2d e0       	ldi	r18, 0x0D	; 13
    9c88:	30 e0       	ldi	r19, 0x00	; 0
    9c8a:	b9 01       	movw	r22, r18
    9c8c:	0e 94 3c 63 	call	0xc678	; 0xc678 <__divmodhi4>
    9c90:	8c 01       	movw	r16, r24
    9c92:	8f ef       	ldi	r24, 0xFF	; 255
    9c94:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    9c98:	28 2f       	mov	r18, r24
    9c9a:	c8 01       	movw	r24, r16
    9c9c:	8d 55       	subi	r24, 0x5D	; 93
    9c9e:	9f 4a       	sbci	r25, 0xAF	; 175
    9ca0:	fc 01       	movw	r30, r24
    9ca2:	20 83       	st	Z, r18
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    9ca4:	89 81       	ldd	r24, Y+1	; 0x01
    9ca6:	9a 81       	ldd	r25, Y+2	; 0x02
    9ca8:	2d e0       	ldi	r18, 0x0D	; 13
    9caa:	30 e0       	ldi	r19, 0x00	; 0
    9cac:	b9 01       	movw	r22, r18
    9cae:	0e 94 3c 63 	call	0xc678	; 0xc678 <__divmodhi4>
    9cb2:	8d 55       	subi	r24, 0x5D	; 93
    9cb4:	9f 4a       	sbci	r25, 0xAF	; 175
    9cb6:	fc 01       	movw	r30, r24
    9cb8:	80 81       	ld	r24, Z
    9cba:	8f 3f       	cpi	r24, 0xFF	; 255
    9cbc:	81 f0       	breq	.+32     	; 0x9cde <SD_command+0xd2>
			Buffer[1] = Buffer[i%13];
    9cbe:	89 81       	ldd	r24, Y+1	; 0x01
    9cc0:	9a 81       	ldd	r25, Y+2	; 0x02
    9cc2:	2d e0       	ldi	r18, 0x0D	; 13
    9cc4:	30 e0       	ldi	r19, 0x00	; 0
    9cc6:	b9 01       	movw	r22, r18
    9cc8:	0e 94 3c 63 	call	0xc678	; 0xc678 <__divmodhi4>
    9ccc:	8d 55       	subi	r24, 0x5D	; 93
    9cce:	9f 4a       	sbci	r25, 0xAF	; 175
    9cd0:	fc 01       	movw	r30, r24
    9cd2:	80 81       	ld	r24, Z
    9cd4:	80 93 a4 50 	sts	0x50A4, r24
			return Buffer[1];
    9cd8:	80 91 a4 50 	lds	r24, 0x50A4
    9cdc:	0d c0       	rjmp	.+26     	; 0x9cf8 <SD_command+0xec>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    9cde:	89 81       	ldd	r24, Y+1	; 0x01
    9ce0:	9a 81       	ldd	r25, Y+2	; 0x02
    9ce2:	01 96       	adiw	r24, 0x01	; 1
    9ce4:	89 83       	std	Y+1, r24	; 0x01
    9ce6:	9a 83       	std	Y+2, r25	; 0x02
    9ce8:	29 81       	ldd	r18, Y+1	; 0x01
    9cea:	3a 81       	ldd	r19, Y+2	; 0x02
    9cec:	89 85       	ldd	r24, Y+9	; 0x09
    9cee:	9a 85       	ldd	r25, Y+10	; 0x0a
    9cf0:	28 17       	cp	r18, r24
    9cf2:	39 07       	cpc	r19, r25
    9cf4:	34 f2       	brlt	.-116    	; 0x9c82 <SD_command+0x76>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    9cf6:	8f ef       	ldi	r24, 0xFF	; 255
}
    9cf8:	2a 96       	adiw	r28, 0x0a	; 10
    9cfa:	cd bf       	out	0x3d, r28	; 61
    9cfc:	de bf       	out	0x3e, r29	; 62
    9cfe:	df 91       	pop	r29
    9d00:	cf 91       	pop	r28
    9d02:	1f 91       	pop	r17
    9d04:	0f 91       	pop	r16
    9d06:	08 95       	ret

00009d08 <SD_write_block>:

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    9d08:	0f 93       	push	r16
    9d0a:	1f 93       	push	r17
    9d0c:	cf 93       	push	r28
    9d0e:	df 93       	push	r29
    9d10:	cd b7       	in	r28, 0x3d	; 61
    9d12:	de b7       	in	r29, 0x3e	; 62
    9d14:	62 97       	sbiw	r28, 0x12	; 18
    9d16:	cd bf       	out	0x3d, r28	; 61
    9d18:	de bf       	out	0x3e, r29	; 62
    9d1a:	6b 87       	std	Y+11, r22	; 0x0b
    9d1c:	7c 87       	std	Y+12, r23	; 0x0c
    9d1e:	8d 87       	std	Y+13, r24	; 0x0d
    9d20:	9e 87       	std	Y+14, r25	; 0x0e
    9d22:	4f 87       	std	Y+15, r20	; 0x0f
    9d24:	58 8b       	std	Y+16, r21	; 0x10
    9d26:	29 8b       	std	Y+17, r18	; 0x11
    9d28:	3a 8b       	std	Y+18, r19	; 0x12
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9d2a:	88 e0       	ldi	r24, 0x08	; 8
    9d2c:	60 e0       	ldi	r22, 0x00	; 0
    9d2e:	0e 94 d7 34 	call	0x69ae	; 0x69ae <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9d32:	80 e0       	ldi	r24, 0x00	; 0
    9d34:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
	SPICS(TRUE);
    9d38:	81 e0       	ldi	r24, 0x01	; 1
    9d3a:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    9d3e:	20 e0       	ldi	r18, 0x00	; 0
    9d40:	32 e0       	ldi	r19, 0x02	; 2
    9d42:	89 89       	ldd	r24, Y+17	; 0x11
    9d44:	9a 89       	ldd	r25, Y+18	; 0x12
    9d46:	a9 01       	movw	r20, r18
    9d48:	48 1b       	sub	r20, r24
    9d4a:	59 0b       	sbc	r21, r25
    9d4c:	ca 01       	movw	r24, r20
    9d4e:	89 83       	std	Y+1, r24	; 0x01
    9d50:	9a 83       	std	Y+2, r25	; 0x02
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    9d52:	89 81       	ldd	r24, Y+1	; 0x01
    9d54:	9a 81       	ldd	r25, Y+2	; 0x02
    9d56:	52 e0       	ldi	r21, 0x02	; 2
    9d58:	80 30       	cpi	r24, 0x00	; 0
    9d5a:	95 07       	cpc	r25, r21
    9d5c:	11 f4       	brne	.+4      	; 0x9d62 <SD_write_block+0x5a>
    9d5e:	19 82       	std	Y+1, r1	; 0x01
    9d60:	1a 82       	std	Y+2, r1	; 0x02
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9d62:	1b 82       	std	Y+3, r1	; 0x03
    9d64:	1c 82       	std	Y+4, r1	; 0x04
    9d66:	0b c0       	rjmp	.+22     	; 0x9d7e <SD_write_block+0x76>
	if (i >= 10) {
    9d68:	8b 81       	ldd	r24, Y+3	; 0x03
    9d6a:	9c 81       	ldd	r25, Y+4	; 0x04
    9d6c:	8a 30       	cpi	r24, 0x0A	; 10
    9d6e:	91 05       	cpc	r25, r1
    9d70:	0c f0       	brlt	.+2      	; 0x9d74 <SD_write_block+0x6c>
		//there was no response to the command
		while(1);
    9d72:	ff cf       	rjmp	.-2      	; 0x9d72 <SD_write_block+0x6a>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9d74:	8b 81       	ldd	r24, Y+3	; 0x03
    9d76:	9c 81       	ldd	r25, Y+4	; 0x04
    9d78:	01 96       	adiw	r24, 0x01	; 1
    9d7a:	8b 83       	std	Y+3, r24	; 0x03
    9d7c:	9c 83       	std	Y+4, r25	; 0x04
    9d7e:	2b 85       	ldd	r18, Y+11	; 0x0b
    9d80:	3c 85       	ldd	r19, Y+12	; 0x0c
    9d82:	4d 85       	ldd	r20, Y+13	; 0x0d
    9d84:	5e 85       	ldd	r21, Y+14	; 0x0e
    9d86:	88 e1       	ldi	r24, 0x18	; 24
    9d88:	ba 01       	movw	r22, r20
    9d8a:	a9 01       	movw	r20, r18
    9d8c:	2f ef       	ldi	r18, 0xFF	; 255
    9d8e:	08 e0       	ldi	r16, 0x08	; 8
    9d90:	10 e0       	ldi	r17, 0x00	; 0
    9d92:	0e 94 06 4e 	call	0x9c0c	; 0x9c0c <SD_command>
    9d96:	88 23       	and	r24, r24
    9d98:	39 f7       	brne	.-50     	; 0x9d68 <SD_write_block+0x60>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    9d9a:	8f ef       	ldi	r24, 0xFF	; 255
    9d9c:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    9da0:	80 93 a3 50 	sts	0x50A3, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    9da4:	8e ef       	ldi	r24, 0xFE	; 254
    9da6:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    9daa:	1d 82       	std	Y+5, r1	; 0x05
    9dac:	1e 82       	std	Y+6, r1	; 0x06
    9dae:	1d c0       	rjmp	.+58     	; 0x9dea <SD_write_block+0xe2>
Buffer[i%13] = SPI_write(data[i]);
    9db0:	8d 81       	ldd	r24, Y+5	; 0x05
    9db2:	9e 81       	ldd	r25, Y+6	; 0x06
    9db4:	2d e0       	ldi	r18, 0x0D	; 13
    9db6:	30 e0       	ldi	r19, 0x00	; 0
    9db8:	b9 01       	movw	r22, r18
    9dba:	0e 94 3c 63 	call	0xc678	; 0xc678 <__divmodhi4>
    9dbe:	8c 01       	movw	r16, r24
    9dc0:	8d 81       	ldd	r24, Y+5	; 0x05
    9dc2:	9e 81       	ldd	r25, Y+6	; 0x06
    9dc4:	2f 85       	ldd	r18, Y+15	; 0x0f
    9dc6:	38 89       	ldd	r19, Y+16	; 0x10
    9dc8:	82 0f       	add	r24, r18
    9dca:	93 1f       	adc	r25, r19
    9dcc:	fc 01       	movw	r30, r24
    9dce:	80 81       	ld	r24, Z
    9dd0:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    9dd4:	28 2f       	mov	r18, r24
    9dd6:	c8 01       	movw	r24, r16
    9dd8:	8d 55       	subi	r24, 0x5D	; 93
    9dda:	9f 4a       	sbci	r25, 0xAF	; 175
    9ddc:	fc 01       	movw	r30, r24
    9dde:	20 83       	st	Z, r18
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    9de0:	8d 81       	ldd	r24, Y+5	; 0x05
    9de2:	9e 81       	ldd	r25, Y+6	; 0x06
    9de4:	01 96       	adiw	r24, 0x01	; 1
    9de6:	8d 83       	std	Y+5, r24	; 0x05
    9de8:	9e 83       	std	Y+6, r25	; 0x06
    9dea:	2d 81       	ldd	r18, Y+5	; 0x05
    9dec:	3e 81       	ldd	r19, Y+6	; 0x06
    9dee:	89 89       	ldd	r24, Y+17	; 0x11
    9df0:	9a 89       	ldd	r25, Y+18	; 0x12
    9df2:	28 17       	cp	r18, r24
    9df4:	39 07       	cpc	r19, r25
    9df6:	e4 f2       	brlt	.-72     	; 0x9db0 <SD_write_block+0xa8>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    9df8:	1f 82       	std	Y+7, r1	; 0x07
    9dfa:	18 86       	std	Y+8, r1	; 0x08
    9dfc:	16 c0       	rjmp	.+44     	; 0x9e2a <SD_write_block+0x122>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    9dfe:	8f 81       	ldd	r24, Y+7	; 0x07
    9e00:	98 85       	ldd	r25, Y+8	; 0x08
    9e02:	2d e0       	ldi	r18, 0x0D	; 13
    9e04:	30 e0       	ldi	r19, 0x00	; 0
    9e06:	b9 01       	movw	r22, r18
    9e08:	0e 94 3c 63 	call	0xc678	; 0xc678 <__divmodhi4>
    9e0c:	8c 01       	movw	r16, r24
    9e0e:	80 e0       	ldi	r24, 0x00	; 0
    9e10:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    9e14:	28 2f       	mov	r18, r24
    9e16:	c8 01       	movw	r24, r16
    9e18:	8d 55       	subi	r24, 0x5D	; 93
    9e1a:	9f 4a       	sbci	r25, 0xAF	; 175
    9e1c:	fc 01       	movw	r30, r24
    9e1e:	20 83       	st	Z, r18
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    9e20:	8f 81       	ldd	r24, Y+7	; 0x07
    9e22:	98 85       	ldd	r25, Y+8	; 0x08
    9e24:	01 96       	adiw	r24, 0x01	; 1
    9e26:	8f 83       	std	Y+7, r24	; 0x07
    9e28:	98 87       	std	Y+8, r25	; 0x08
    9e2a:	2f 81       	ldd	r18, Y+7	; 0x07
    9e2c:	38 85       	ldd	r19, Y+8	; 0x08
    9e2e:	89 81       	ldd	r24, Y+1	; 0x01
    9e30:	9a 81       	ldd	r25, Y+2	; 0x02
    9e32:	28 17       	cp	r18, r24
    9e34:	39 07       	cpc	r19, r25
    9e36:	1c f3       	brlt	.-58     	; 0x9dfe <SD_write_block+0xf6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    9e38:	8f ef       	ldi	r24, 0xFF	; 255
    9e3a:	80 93 a3 50 	sts	0x50A3, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    9e3e:	19 86       	std	Y+9, r1	; 0x09
    9e40:	1a 86       	std	Y+10, r1	; 0x0a
    9e42:	0a c0       	rjmp	.+20     	; 0x9e58 <SD_write_block+0x150>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    9e44:	8f ef       	ldi	r24, 0xFF	; 255
    9e46:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    9e4a:	80 93 a3 50 	sts	0x50A3, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    9e4e:	89 85       	ldd	r24, Y+9	; 0x09
    9e50:	9a 85       	ldd	r25, Y+10	; 0x0a
    9e52:	01 96       	adiw	r24, 0x01	; 1
    9e54:	89 87       	std	Y+9, r24	; 0x09
    9e56:	9a 87       	std	Y+10, r25	; 0x0a
    9e58:	89 85       	ldd	r24, Y+9	; 0x09
    9e5a:	9a 85       	ldd	r25, Y+10	; 0x0a
    9e5c:	82 30       	cpi	r24, 0x02	; 2
    9e5e:	91 05       	cpc	r25, r1
    9e60:	8c f3       	brlt	.-30     	; 0x9e44 <SD_write_block+0x13c>
    9e62:	80 91 a3 50 	lds	r24, 0x50A3
    9e66:	8f 3f       	cpi	r24, 0xFF	; 255
    9e68:	69 f3       	breq	.-38     	; 0x9e44 <SD_write_block+0x13c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    9e6a:	80 91 a3 50 	lds	r24, 0x50A3
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    9e6e:	05 c0       	rjmp	.+10     	; 0x9e7a <SD_write_block+0x172>
    9e70:	8f ef       	ldi	r24, 0xFF	; 255
    9e72:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    9e76:	80 93 a3 50 	sts	0x50A3, r24
    9e7a:	80 91 a3 50 	lds	r24, 0x50A3
    9e7e:	8f 3f       	cpi	r24, 0xFF	; 255
    9e80:	b9 f7       	brne	.-18     	; 0x9e70 <SD_write_block+0x168>
	SPICS(FALSE);
    9e82:	80 e0       	ldi	r24, 0x00	; 0
    9e84:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	SPIDisable();
    9e88:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    9e8c:	88 e0       	ldi	r24, 0x08	; 8
    9e8e:	60 e0       	ldi	r22, 0x00	; 0
    9e90:	0e 94 74 34 	call	0x68e8	; 0x68e8 <PortEx_OUTSET>
}
    9e94:	62 96       	adiw	r28, 0x12	; 18
    9e96:	cd bf       	out	0x3d, r28	; 61
    9e98:	de bf       	out	0x3e, r29	; 62
    9e9a:	df 91       	pop	r29
    9e9c:	cf 91       	pop	r28
    9e9e:	1f 91       	pop	r17
    9ea0:	0f 91       	pop	r16
    9ea2:	08 95       	ret

00009ea4 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    9ea4:	0f 93       	push	r16
    9ea6:	1f 93       	push	r17
    9ea8:	cf 93       	push	r28
    9eaa:	df 93       	push	r29
    9eac:	cd b7       	in	r28, 0x3d	; 61
    9eae:	de b7       	in	r29, 0x3e	; 62
    9eb0:	2a 97       	sbiw	r28, 0x0a	; 10
    9eb2:	cd bf       	out	0x3d, r28	; 61
    9eb4:	de bf       	out	0x3e, r29	; 62
    9eb6:	6d 83       	std	Y+5, r22	; 0x05
    9eb8:	7e 83       	std	Y+6, r23	; 0x06
    9eba:	8f 83       	std	Y+7, r24	; 0x07
    9ebc:	98 87       	std	Y+8, r25	; 0x08
    9ebe:	49 87       	std	Y+9, r20	; 0x09
    9ec0:	5a 87       	std	Y+10, r21	; 0x0a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9ec2:	88 e0       	ldi	r24, 0x08	; 8
    9ec4:	60 e0       	ldi	r22, 0x00	; 0
    9ec6:	0e 94 d7 34 	call	0x69ae	; 0x69ae <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9eca:	80 e0       	ldi	r24, 0x00	; 0
    9ecc:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
	SPICS(TRUE);
    9ed0:	81 e0       	ldi	r24, 0x01	; 1
    9ed2:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    9ed6:	19 82       	std	Y+1, r1	; 0x01
    9ed8:	1a 82       	std	Y+2, r1	; 0x02
    9eda:	0b c0       	rjmp	.+22     	; 0x9ef2 <SD_read_block+0x4e>
		if (i >= 10) {
    9edc:	89 81       	ldd	r24, Y+1	; 0x01
    9ede:	9a 81       	ldd	r25, Y+2	; 0x02
    9ee0:	8a 30       	cpi	r24, 0x0A	; 10
    9ee2:	91 05       	cpc	r25, r1
    9ee4:	0c f0       	brlt	.+2      	; 0x9ee8 <SD_read_block+0x44>
			//there was no response to the command
			while(1);
    9ee6:	ff cf       	rjmp	.-2      	; 0x9ee6 <SD_read_block+0x42>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    9ee8:	89 81       	ldd	r24, Y+1	; 0x01
    9eea:	9a 81       	ldd	r25, Y+2	; 0x02
    9eec:	01 96       	adiw	r24, 0x01	; 1
    9eee:	89 83       	std	Y+1, r24	; 0x01
    9ef0:	9a 83       	std	Y+2, r25	; 0x02
    9ef2:	2d 81       	ldd	r18, Y+5	; 0x05
    9ef4:	3e 81       	ldd	r19, Y+6	; 0x06
    9ef6:	4f 81       	ldd	r20, Y+7	; 0x07
    9ef8:	58 85       	ldd	r21, Y+8	; 0x08
    9efa:	81 e1       	ldi	r24, 0x11	; 17
    9efc:	ba 01       	movw	r22, r20
    9efe:	a9 01       	movw	r20, r18
    9f00:	2f ef       	ldi	r18, 0xFF	; 255
    9f02:	08 e0       	ldi	r16, 0x08	; 8
    9f04:	10 e0       	ldi	r17, 0x00	; 0
    9f06:	0e 94 06 4e 	call	0x9c0c	; 0x9c0c <SD_command>
    9f0a:	88 23       	and	r24, r24
    9f0c:	39 f7       	brne	.-50     	; 0x9edc <SD_read_block+0x38>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    9f0e:	05 c0       	rjmp	.+10     	; 0x9f1a <SD_read_block+0x76>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    9f10:	8f ef       	ldi	r24, 0xFF	; 255
    9f12:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    9f16:	80 93 a3 50 	sts	0x50A3, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    9f1a:	80 91 a3 50 	lds	r24, 0x50A3
    9f1e:	8e 3f       	cpi	r24, 0xFE	; 254
    9f20:	b9 f7       	brne	.-18     	; 0x9f10 <SD_read_block+0x6c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9f22:	1b 82       	std	Y+3, r1	; 0x03
    9f24:	1c 82       	std	Y+4, r1	; 0x04
    9f26:	11 c0       	rjmp	.+34     	; 0x9f4a <SD_read_block+0xa6>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    9f28:	8b 81       	ldd	r24, Y+3	; 0x03
    9f2a:	9c 81       	ldd	r25, Y+4	; 0x04
    9f2c:	29 85       	ldd	r18, Y+9	; 0x09
    9f2e:	3a 85       	ldd	r19, Y+10	; 0x0a
    9f30:	89 01       	movw	r16, r18
    9f32:	08 0f       	add	r16, r24
    9f34:	19 1f       	adc	r17, r25
    9f36:	8f ef       	ldi	r24, 0xFF	; 255
    9f38:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    9f3c:	f8 01       	movw	r30, r16
    9f3e:	80 83       	st	Z, r24
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9f40:	8b 81       	ldd	r24, Y+3	; 0x03
    9f42:	9c 81       	ldd	r25, Y+4	; 0x04
    9f44:	01 96       	adiw	r24, 0x01	; 1
    9f46:	8b 83       	std	Y+3, r24	; 0x03
    9f48:	9c 83       	std	Y+4, r25	; 0x04
    9f4a:	8b 81       	ldd	r24, Y+3	; 0x03
    9f4c:	9c 81       	ldd	r25, Y+4	; 0x04
    9f4e:	f2 e0       	ldi	r31, 0x02	; 2
    9f50:	80 30       	cpi	r24, 0x00	; 0
    9f52:	9f 07       	cpc	r25, r31
    9f54:	4c f3       	brlt	.-46     	; 0x9f28 <SD_read_block+0x84>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    9f56:	10 92 af 50 	sts	0x50AF, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    9f5a:	05 c0       	rjmp	.+10     	; 0x9f66 <SD_read_block+0xc2>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    9f5c:	8f ef       	ldi	r24, 0xFF	; 255
    9f5e:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    9f62:	80 93 af 50 	sts	0x50AF, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    9f66:	80 91 af 50 	lds	r24, 0x50AF
    9f6a:	8f 3f       	cpi	r24, 0xFF	; 255
    9f6c:	b9 f7       	brne	.-18     	; 0x9f5c <SD_read_block+0xb8>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    9f6e:	80 e0       	ldi	r24, 0x00	; 0
    9f70:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	SPIDisable();
    9f74:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9f78:	88 e0       	ldi	r24, 0x08	; 8
    9f7a:	60 e0       	ldi	r22, 0x00	; 0
    9f7c:	0e 94 74 34 	call	0x68e8	; 0x68e8 <PortEx_OUTSET>
}
    9f80:	2a 96       	adiw	r28, 0x0a	; 10
    9f82:	cd bf       	out	0x3d, r28	; 61
    9f84:	de bf       	out	0x3e, r29	; 62
    9f86:	df 91       	pop	r29
    9f88:	cf 91       	pop	r28
    9f8a:	1f 91       	pop	r17
    9f8c:	0f 91       	pop	r16
    9f8e:	08 95       	ret

00009f90 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    9f90:	0f 93       	push	r16
    9f92:	1f 93       	push	r17
    9f94:	cf 93       	push	r28
    9f96:	df 93       	push	r29
    9f98:	cd b7       	in	r28, 0x3d	; 61
    9f9a:	de b7       	in	r29, 0x3e	; 62
    9f9c:	6a 97       	sbiw	r28, 0x1a	; 26
    9f9e:	cd bf       	out	0x3d, r28	; 61
    9fa0:	de bf       	out	0x3e, r29	; 62
    9fa2:	6b 8b       	std	Y+19, r22	; 0x13
    9fa4:	7c 8b       	std	Y+20, r23	; 0x14
    9fa6:	8d 8b       	std	Y+21, r24	; 0x15
    9fa8:	9e 8b       	std	Y+22, r25	; 0x16
    9faa:	4f 8b       	std	Y+23, r20	; 0x17
    9fac:	58 8f       	std	Y+24, r21	; 0x18
    9fae:	29 8f       	std	Y+25, r18	; 0x19
    9fb0:	3a 8f       	std	Y+26, r19	; 0x1a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9fb2:	88 e0       	ldi	r24, 0x08	; 8
    9fb4:	60 e0       	ldi	r22, 0x00	; 0
    9fb6:	0e 94 d7 34 	call	0x69ae	; 0x69ae <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9fba:	80 e0       	ldi	r24, 0x00	; 0
    9fbc:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
	SPICS(TRUE);
    9fc0:	81 e0       	ldi	r24, 0x01	; 1
    9fc2:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    9fc6:	89 8d       	ldd	r24, Y+25	; 0x19
    9fc8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9fca:	99 23       	and	r25, r25
    9fcc:	14 f4       	brge	.+4      	; 0x9fd2 <SD_write_multiple_blocks+0x42>
    9fce:	81 50       	subi	r24, 0x01	; 1
    9fd0:	9e 4f       	sbci	r25, 0xFE	; 254
    9fd2:	89 2f       	mov	r24, r25
    9fd4:	99 0f       	add	r25, r25
    9fd6:	99 0b       	sbc	r25, r25
    9fd8:	85 95       	asr	r24
    9fda:	89 83       	std	Y+1, r24	; 0x01
    9fdc:	9a 83       	std	Y+2, r25	; 0x02
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    9fde:	89 8d       	ldd	r24, Y+25	; 0x19
    9fe0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9fe2:	20 e0       	ldi	r18, 0x00	; 0
    9fe4:	32 e0       	ldi	r19, 0x02	; 2
    9fe6:	b9 01       	movw	r22, r18
    9fe8:	0e 94 3c 63 	call	0xc678	; 0xc678 <__divmodhi4>
    9fec:	20 e0       	ldi	r18, 0x00	; 0
    9fee:	32 e0       	ldi	r19, 0x02	; 2
    9ff0:	a9 01       	movw	r20, r18
    9ff2:	48 1b       	sub	r20, r24
    9ff4:	59 0b       	sbc	r21, r25
    9ff6:	ca 01       	movw	r24, r20
    9ff8:	8b 83       	std	Y+3, r24	; 0x03
    9ffa:	9c 83       	std	Y+4, r25	; 0x04
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    9ffc:	8b 81       	ldd	r24, Y+3	; 0x03
    9ffe:	9c 81       	ldd	r25, Y+4	; 0x04
    a000:	52 e0       	ldi	r21, 0x02	; 2
    a002:	80 30       	cpi	r24, 0x00	; 0
    a004:	95 07       	cpc	r25, r21
    a006:	19 f4       	brne	.+6      	; 0xa00e <SD_write_multiple_blocks+0x7e>
    a008:	1b 82       	std	Y+3, r1	; 0x03
    a00a:	1c 82       	std	Y+4, r1	; 0x04
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    a00c:	05 c0       	rjmp	.+10     	; 0xa018 <SD_write_multiple_blocks+0x88>
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
    a00e:	89 81       	ldd	r24, Y+1	; 0x01
    a010:	9a 81       	ldd	r25, Y+2	; 0x02
    a012:	01 96       	adiw	r24, 0x01	; 1
    a014:	89 83       	std	Y+1, r24	; 0x01
    a016:	9a 83       	std	Y+2, r25	; 0x02
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    a018:	00 00       	nop
    a01a:	2b 89       	ldd	r18, Y+19	; 0x13
    a01c:	3c 89       	ldd	r19, Y+20	; 0x14
    a01e:	4d 89       	ldd	r20, Y+21	; 0x15
    a020:	5e 89       	ldd	r21, Y+22	; 0x16
    a022:	89 e1       	ldi	r24, 0x19	; 25
    a024:	ba 01       	movw	r22, r20
    a026:	a9 01       	movw	r20, r18
    a028:	2f ef       	ldi	r18, 0xFF	; 255
    a02a:	08 e0       	ldi	r16, 0x08	; 8
    a02c:	10 e0       	ldi	r17, 0x00	; 0
    a02e:	0e 94 06 4e 	call	0x9c0c	; 0x9c0c <SD_command>
    a032:	88 23       	and	r24, r24
    a034:	91 f7       	brne	.-28     	; 0xa01a <SD_write_multiple_blocks+0x8a>
	for (int j=0;j<numSectors;j++){
    a036:	1d 82       	std	Y+5, r1	; 0x05
    a038:	1e 82       	std	Y+6, r1	; 0x06
    a03a:	ba c0       	rjmp	.+372    	; 0xa1b0 <SD_write_multiple_blocks+0x220>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    a03c:	8f ef       	ldi	r24, 0xFF	; 255
    a03e:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    a042:	80 93 a4 50 	sts	0x50A4, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    a046:	8c ef       	ldi	r24, 0xFC	; 252
    a048:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    a04c:	80 93 a4 50 	sts	0x50A4, r24
		if(j == (numSectors-1)){
    a050:	89 81       	ldd	r24, Y+1	; 0x01
    a052:	9a 81       	ldd	r25, Y+2	; 0x02
    a054:	9c 01       	movw	r18, r24
    a056:	21 50       	subi	r18, 0x01	; 1
    a058:	30 40       	sbci	r19, 0x00	; 0
    a05a:	8d 81       	ldd	r24, Y+5	; 0x05
    a05c:	9e 81       	ldd	r25, Y+6	; 0x06
    a05e:	28 17       	cp	r18, r24
    a060:	39 07       	cpc	r19, r25
    a062:	09 f0       	breq	.+2      	; 0xa066 <SD_write_multiple_blocks+0xd6>
    a064:	54 c0       	rjmp	.+168    	; 0xa10e <SD_write_multiple_blocks+0x17e>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    a066:	1f 82       	std	Y+7, r1	; 0x07
    a068:	18 86       	std	Y+8, r1	; 0x08
    a06a:	25 c0       	rjmp	.+74     	; 0xa0b6 <SD_write_multiple_blocks+0x126>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    a06c:	8f 81       	ldd	r24, Y+7	; 0x07
    a06e:	98 85       	ldd	r25, Y+8	; 0x08
    a070:	2c e0       	ldi	r18, 0x0C	; 12
    a072:	30 e0       	ldi	r19, 0x00	; 0
    a074:	b9 01       	movw	r22, r18
    a076:	0e 94 3c 63 	call	0xc678	; 0xc678 <__divmodhi4>
    a07a:	8c 01       	movw	r16, r24
    a07c:	8d 81       	ldd	r24, Y+5	; 0x05
    a07e:	9e 81       	ldd	r25, Y+6	; 0x06
    a080:	9c 01       	movw	r18, r24
    a082:	32 2f       	mov	r19, r18
    a084:	22 27       	eor	r18, r18
    a086:	33 0f       	add	r19, r19
    a088:	8f 81       	ldd	r24, Y+7	; 0x07
    a08a:	98 85       	ldd	r25, Y+8	; 0x08
    a08c:	82 0f       	add	r24, r18
    a08e:	93 1f       	adc	r25, r19
    a090:	2f 89       	ldd	r18, Y+23	; 0x17
    a092:	38 8d       	ldd	r19, Y+24	; 0x18
    a094:	82 0f       	add	r24, r18
    a096:	93 1f       	adc	r25, r19
    a098:	fc 01       	movw	r30, r24
    a09a:	80 81       	ld	r24, Z
    a09c:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    a0a0:	28 2f       	mov	r18, r24
    a0a2:	c8 01       	movw	r24, r16
    a0a4:	8d 55       	subi	r24, 0x5D	; 93
    a0a6:	9f 4a       	sbci	r25, 0xAF	; 175
    a0a8:	fc 01       	movw	r30, r24
    a0aa:	20 83       	st	Z, r18
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    a0ac:	8f 81       	ldd	r24, Y+7	; 0x07
    a0ae:	98 85       	ldd	r25, Y+8	; 0x08
    a0b0:	01 96       	adiw	r24, 0x01	; 1
    a0b2:	8f 83       	std	Y+7, r24	; 0x07
    a0b4:	98 87       	std	Y+8, r25	; 0x08
    a0b6:	20 e0       	ldi	r18, 0x00	; 0
    a0b8:	32 e0       	ldi	r19, 0x02	; 2
    a0ba:	8b 81       	ldd	r24, Y+3	; 0x03
    a0bc:	9c 81       	ldd	r25, Y+4	; 0x04
    a0be:	28 1b       	sub	r18, r24
    a0c0:	39 0b       	sbc	r19, r25
    a0c2:	8f 81       	ldd	r24, Y+7	; 0x07
    a0c4:	98 85       	ldd	r25, Y+8	; 0x08
    a0c6:	82 17       	cp	r24, r18
    a0c8:	93 07       	cpc	r25, r19
    a0ca:	84 f2       	brlt	.-96     	; 0xa06c <SD_write_multiple_blocks+0xdc>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    a0cc:	19 86       	std	Y+9, r1	; 0x09
    a0ce:	1a 86       	std	Y+10, r1	; 0x0a
    a0d0:	16 c0       	rjmp	.+44     	; 0xa0fe <SD_write_multiple_blocks+0x16e>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    a0d2:	89 85       	ldd	r24, Y+9	; 0x09
    a0d4:	9a 85       	ldd	r25, Y+10	; 0x0a
    a0d6:	2c e0       	ldi	r18, 0x0C	; 12
    a0d8:	30 e0       	ldi	r19, 0x00	; 0
    a0da:	b9 01       	movw	r22, r18
    a0dc:	0e 94 3c 63 	call	0xc678	; 0xc678 <__divmodhi4>
    a0e0:	8c 01       	movw	r16, r24
    a0e2:	80 e0       	ldi	r24, 0x00	; 0
    a0e4:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    a0e8:	28 2f       	mov	r18, r24
    a0ea:	c8 01       	movw	r24, r16
    a0ec:	8d 55       	subi	r24, 0x5D	; 93
    a0ee:	9f 4a       	sbci	r25, 0xAF	; 175
    a0f0:	fc 01       	movw	r30, r24
    a0f2:	20 83       	st	Z, r18
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    a0f4:	89 85       	ldd	r24, Y+9	; 0x09
    a0f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    a0f8:	01 96       	adiw	r24, 0x01	; 1
    a0fa:	89 87       	std	Y+9, r24	; 0x09
    a0fc:	9a 87       	std	Y+10, r25	; 0x0a
    a0fe:	29 85       	ldd	r18, Y+9	; 0x09
    a100:	3a 85       	ldd	r19, Y+10	; 0x0a
    a102:	8b 81       	ldd	r24, Y+3	; 0x03
    a104:	9c 81       	ldd	r25, Y+4	; 0x04
    a106:	28 17       	cp	r18, r24
    a108:	39 07       	cpc	r19, r25
    a10a:	1c f3       	brlt	.-58     	; 0xa0d2 <SD_write_multiple_blocks+0x142>
    a10c:	2e c0       	rjmp	.+92     	; 0xa16a <SD_write_multiple_blocks+0x1da>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a10e:	1b 86       	std	Y+11, r1	; 0x0b
    a110:	1c 86       	std	Y+12, r1	; 0x0c
    a112:	25 c0       	rjmp	.+74     	; 0xa15e <SD_write_multiple_blocks+0x1ce>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    a114:	8b 85       	ldd	r24, Y+11	; 0x0b
    a116:	9c 85       	ldd	r25, Y+12	; 0x0c
    a118:	2c e0       	ldi	r18, 0x0C	; 12
    a11a:	30 e0       	ldi	r19, 0x00	; 0
    a11c:	b9 01       	movw	r22, r18
    a11e:	0e 94 3c 63 	call	0xc678	; 0xc678 <__divmodhi4>
    a122:	8c 01       	movw	r16, r24
    a124:	8d 81       	ldd	r24, Y+5	; 0x05
    a126:	9e 81       	ldd	r25, Y+6	; 0x06
    a128:	9c 01       	movw	r18, r24
    a12a:	32 2f       	mov	r19, r18
    a12c:	22 27       	eor	r18, r18
    a12e:	33 0f       	add	r19, r19
    a130:	8b 85       	ldd	r24, Y+11	; 0x0b
    a132:	9c 85       	ldd	r25, Y+12	; 0x0c
    a134:	82 0f       	add	r24, r18
    a136:	93 1f       	adc	r25, r19
    a138:	2f 89       	ldd	r18, Y+23	; 0x17
    a13a:	38 8d       	ldd	r19, Y+24	; 0x18
    a13c:	82 0f       	add	r24, r18
    a13e:	93 1f       	adc	r25, r19
    a140:	fc 01       	movw	r30, r24
    a142:	80 81       	ld	r24, Z
    a144:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    a148:	28 2f       	mov	r18, r24
    a14a:	c8 01       	movw	r24, r16
    a14c:	8d 55       	subi	r24, 0x5D	; 93
    a14e:	9f 4a       	sbci	r25, 0xAF	; 175
    a150:	fc 01       	movw	r30, r24
    a152:	20 83       	st	Z, r18
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a154:	8b 85       	ldd	r24, Y+11	; 0x0b
    a156:	9c 85       	ldd	r25, Y+12	; 0x0c
    a158:	01 96       	adiw	r24, 0x01	; 1
    a15a:	8b 87       	std	Y+11, r24	; 0x0b
    a15c:	9c 87       	std	Y+12, r25	; 0x0c
    a15e:	8b 85       	ldd	r24, Y+11	; 0x0b
    a160:	9c 85       	ldd	r25, Y+12	; 0x0c
    a162:	f2 e0       	ldi	r31, 0x02	; 2
    a164:	80 30       	cpi	r24, 0x00	; 0
    a166:	9f 07       	cpc	r25, r31
    a168:	ac f2       	brlt	.-86     	; 0xa114 <SD_write_multiple_blocks+0x184>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    a16a:	1d 86       	std	Y+13, r1	; 0x0d
    a16c:	1e 86       	std	Y+14, r1	; 0x0e
    a16e:	0a c0       	rjmp	.+20     	; 0xa184 <SD_write_multiple_blocks+0x1f4>
    a170:	8f ef       	ldi	r24, 0xFF	; 255
    a172:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    a176:	80 93 a4 50 	sts	0x50A4, r24
    a17a:	8d 85       	ldd	r24, Y+13	; 0x0d
    a17c:	9e 85       	ldd	r25, Y+14	; 0x0e
    a17e:	01 96       	adiw	r24, 0x01	; 1
    a180:	8d 87       	std	Y+13, r24	; 0x0d
    a182:	9e 87       	std	Y+14, r25	; 0x0e
    a184:	8d 85       	ldd	r24, Y+13	; 0x0d
    a186:	9e 85       	ldd	r25, Y+14	; 0x0e
    a188:	82 30       	cpi	r24, 0x02	; 2
    a18a:	91 05       	cpc	r25, r1
    a18c:	8c f3       	brlt	.-30     	; 0xa170 <SD_write_multiple_blocks+0x1e0>
		Buffer[1] = FILLER_BYTE;
    a18e:	10 92 a4 50 	sts	0x50A4, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    a192:	05 c0       	rjmp	.+10     	; 0xa19e <SD_write_multiple_blocks+0x20e>
    a194:	8f ef       	ldi	r24, 0xFF	; 255
    a196:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    a19a:	80 93 a4 50 	sts	0x50A4, r24
    a19e:	80 91 a4 50 	lds	r24, 0x50A4
    a1a2:	8f 3f       	cpi	r24, 0xFF	; 255
    a1a4:	b9 f7       	brne	.-18     	; 0xa194 <SD_write_multiple_blocks+0x204>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    a1a6:	8d 81       	ldd	r24, Y+5	; 0x05
    a1a8:	9e 81       	ldd	r25, Y+6	; 0x06
    a1aa:	01 96       	adiw	r24, 0x01	; 1
    a1ac:	8d 83       	std	Y+5, r24	; 0x05
    a1ae:	9e 83       	std	Y+6, r25	; 0x06
    a1b0:	2d 81       	ldd	r18, Y+5	; 0x05
    a1b2:	3e 81       	ldd	r19, Y+6	; 0x06
    a1b4:	89 81       	ldd	r24, Y+1	; 0x01
    a1b6:	9a 81       	ldd	r25, Y+2	; 0x02
    a1b8:	28 17       	cp	r18, r24
    a1ba:	39 07       	cpc	r19, r25
    a1bc:	0c f4       	brge	.+2      	; 0xa1c0 <SD_write_multiple_blocks+0x230>
    a1be:	3e cf       	rjmp	.-388    	; 0xa03c <SD_write_multiple_blocks+0xac>
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a1c0:	1f 86       	std	Y+15, r1	; 0x0f
    a1c2:	18 8a       	std	Y+16, r1	; 0x10
    a1c4:	0a c0       	rjmp	.+20     	; 0xa1da <SD_write_multiple_blocks+0x24a>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a1c6:	8f ef       	ldi	r24, 0xFF	; 255
    a1c8:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    a1cc:	80 93 a4 50 	sts	0x50A4, r24
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a1d0:	8f 85       	ldd	r24, Y+15	; 0x0f
    a1d2:	98 89       	ldd	r25, Y+16	; 0x10
    a1d4:	01 96       	adiw	r24, 0x01	; 1
    a1d6:	8f 87       	std	Y+15, r24	; 0x0f
    a1d8:	98 8b       	std	Y+16, r25	; 0x10
    a1da:	8f 85       	ldd	r24, Y+15	; 0x0f
    a1dc:	98 89       	ldd	r25, Y+16	; 0x10
    a1de:	84 30       	cpi	r24, 0x04	; 4
    a1e0:	91 05       	cpc	r25, r1
    a1e2:	8c f3       	brlt	.-30     	; 0xa1c6 <SD_write_multiple_blocks+0x236>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    a1e4:	8d ef       	ldi	r24, 0xFD	; 253
    a1e6:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    a1ea:	80 93 a4 50 	sts	0x50A4, r24
	for(int i=0;i<4;i++){
    a1ee:	19 8a       	std	Y+17, r1	; 0x11
    a1f0:	1a 8a       	std	Y+18, r1	; 0x12
    a1f2:	0a c0       	rjmp	.+20     	; 0xa208 <SD_write_multiple_blocks+0x278>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a1f4:	8f ef       	ldi	r24, 0xFF	; 255
    a1f6:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    a1fa:	80 93 a4 50 	sts	0x50A4, r24
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    a1fe:	89 89       	ldd	r24, Y+17	; 0x11
    a200:	9a 89       	ldd	r25, Y+18	; 0x12
    a202:	01 96       	adiw	r24, 0x01	; 1
    a204:	89 8b       	std	Y+17, r24	; 0x11
    a206:	9a 8b       	std	Y+18, r25	; 0x12
    a208:	89 89       	ldd	r24, Y+17	; 0x11
    a20a:	9a 89       	ldd	r25, Y+18	; 0x12
    a20c:	84 30       	cpi	r24, 0x04	; 4
    a20e:	91 05       	cpc	r25, r1
    a210:	8c f3       	brlt	.-30     	; 0xa1f4 <SD_write_multiple_blocks+0x264>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    a212:	10 92 a4 50 	sts	0x50A4, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a216:	05 c0       	rjmp	.+10     	; 0xa222 <SD_write_multiple_blocks+0x292>
    a218:	8f ef       	ldi	r24, 0xFF	; 255
    a21a:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    a21e:	80 93 a4 50 	sts	0x50A4, r24
    a222:	80 91 a4 50 	lds	r24, 0x50A4
    a226:	8f 3f       	cpi	r24, 0xFF	; 255
    a228:	b9 f7       	brne	.-18     	; 0xa218 <SD_write_multiple_blocks+0x288>
	SPICS(FALSE);
    a22a:	80 e0       	ldi	r24, 0x00	; 0
    a22c:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	SPIDisable();
    a230:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a234:	88 e0       	ldi	r24, 0x08	; 8
    a236:	60 e0       	ldi	r22, 0x00	; 0
    a238:	0e 94 74 34 	call	0x68e8	; 0x68e8 <PortEx_OUTSET>
}
    a23c:	6a 96       	adiw	r28, 0x1a	; 26
    a23e:	cd bf       	out	0x3d, r28	; 61
    a240:	de bf       	out	0x3e, r29	; 62
    a242:	df 91       	pop	r29
    a244:	cf 91       	pop	r28
    a246:	1f 91       	pop	r17
    a248:	0f 91       	pop	r16
    a24a:	08 95       	ret

0000a24c <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    a24c:	0f 93       	push	r16
    a24e:	1f 93       	push	r17
    a250:	cf 93       	push	r28
    a252:	df 93       	push	r29
    a254:	cd b7       	in	r28, 0x3d	; 61
    a256:	de b7       	in	r29, 0x3e	; 62
    a258:	2e 97       	sbiw	r28, 0x0e	; 14
    a25a:	cd bf       	out	0x3d, r28	; 61
    a25c:	de bf       	out	0x3e, r29	; 62
    a25e:	6f 83       	std	Y+7, r22	; 0x07
    a260:	78 87       	std	Y+8, r23	; 0x08
    a262:	89 87       	std	Y+9, r24	; 0x09
    a264:	9a 87       	std	Y+10, r25	; 0x0a
    a266:	4b 87       	std	Y+11, r20	; 0x0b
    a268:	5c 87       	std	Y+12, r21	; 0x0c
    a26a:	2d 87       	std	Y+13, r18	; 0x0d
    a26c:	3e 87       	std	Y+14, r19	; 0x0e
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a26e:	88 e0       	ldi	r24, 0x08	; 8
    a270:	60 e0       	ldi	r22, 0x00	; 0
    a272:	0e 94 d7 34 	call	0x69ae	; 0x69ae <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a276:	80 e0       	ldi	r24, 0x00	; 0
    a278:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
	SPICS(TRUE);
    a27c:	81 e0       	ldi	r24, 0x01	; 1
    a27e:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    a282:	00 00       	nop
    a284:	2f 81       	ldd	r18, Y+7	; 0x07
    a286:	38 85       	ldd	r19, Y+8	; 0x08
    a288:	49 85       	ldd	r20, Y+9	; 0x09
    a28a:	5a 85       	ldd	r21, Y+10	; 0x0a
    a28c:	82 e1       	ldi	r24, 0x12	; 18
    a28e:	ba 01       	movw	r22, r20
    a290:	a9 01       	movw	r20, r18
    a292:	2f ef       	ldi	r18, 0xFF	; 255
    a294:	08 e0       	ldi	r16, 0x08	; 8
    a296:	10 e0       	ldi	r17, 0x00	; 0
    a298:	0e 94 06 4e 	call	0x9c0c	; 0x9c0c <SD_command>
    a29c:	88 23       	and	r24, r24
    a29e:	91 f7       	brne	.-28     	; 0xa284 <SD_read_multiple_blocks+0x38>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a2a0:	19 82       	std	Y+1, r1	; 0x01
    a2a2:	1a 82       	std	Y+2, r1	; 0x02
    a2a4:	4b c0       	rjmp	.+150    	; 0xa33c <SD_read_multiple_blocks+0xf0>
		Buffer[1]=SDHC_DUMMY_BYTE;
    a2a6:	8f ef       	ldi	r24, 0xFF	; 255
    a2a8:	80 93 a4 50 	sts	0x50A4, r24
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a2ac:	05 c0       	rjmp	.+10     	; 0xa2b8 <SD_read_multiple_blocks+0x6c>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    a2ae:	8f ef       	ldi	r24, 0xFF	; 255
    a2b0:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    a2b4:	80 93 a4 50 	sts	0x50A4, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a2b8:	80 91 a4 50 	lds	r24, 0x50A4
    a2bc:	8e 3f       	cpi	r24, 0xFE	; 254
    a2be:	b9 f7       	brne	.-18     	; 0xa2ae <SD_read_multiple_blocks+0x62>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a2c0:	1b 82       	std	Y+3, r1	; 0x03
    a2c2:	1c 82       	std	Y+4, r1	; 0x04
    a2c4:	19 c0       	rjmp	.+50     	; 0xa2f8 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a2c6:	89 81       	ldd	r24, Y+1	; 0x01
    a2c8:	9a 81       	ldd	r25, Y+2	; 0x02
    a2ca:	9c 01       	movw	r18, r24
    a2cc:	32 2f       	mov	r19, r18
    a2ce:	22 27       	eor	r18, r18
    a2d0:	33 0f       	add	r19, r19
    a2d2:	8b 81       	ldd	r24, Y+3	; 0x03
    a2d4:	9c 81       	ldd	r25, Y+4	; 0x04
    a2d6:	82 0f       	add	r24, r18
    a2d8:	93 1f       	adc	r25, r19
    a2da:	2b 85       	ldd	r18, Y+11	; 0x0b
    a2dc:	3c 85       	ldd	r19, Y+12	; 0x0c
    a2de:	89 01       	movw	r16, r18
    a2e0:	08 0f       	add	r16, r24
    a2e2:	19 1f       	adc	r17, r25
    a2e4:	8f ef       	ldi	r24, 0xFF	; 255
    a2e6:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    a2ea:	f8 01       	movw	r30, r16
    a2ec:	80 83       	st	Z, r24
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a2ee:	8b 81       	ldd	r24, Y+3	; 0x03
    a2f0:	9c 81       	ldd	r25, Y+4	; 0x04
    a2f2:	01 96       	adiw	r24, 0x01	; 1
    a2f4:	8b 83       	std	Y+3, r24	; 0x03
    a2f6:	9c 83       	std	Y+4, r25	; 0x04
    a2f8:	8b 81       	ldd	r24, Y+3	; 0x03
    a2fa:	9c 81       	ldd	r25, Y+4	; 0x04
    a2fc:	f2 e0       	ldi	r31, 0x02	; 2
    a2fe:	80 30       	cpi	r24, 0x00	; 0
    a300:	9f 07       	cpc	r25, r31
    a302:	0c f3       	brlt	.-62     	; 0xa2c6 <SD_read_multiple_blocks+0x7a>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a304:	1d 82       	std	Y+5, r1	; 0x05
    a306:	1e 82       	std	Y+6, r1	; 0x06
    a308:	0f c0       	rjmp	.+30     	; 0xa328 <SD_read_multiple_blocks+0xdc>
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    a30a:	8f ef       	ldi	r24, 0xFF	; 255
    a30c:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    a310:	28 2f       	mov	r18, r24
    a312:	8d 81       	ldd	r24, Y+5	; 0x05
    a314:	9e 81       	ldd	r25, Y+6	; 0x06
    a316:	8d 55       	subi	r24, 0x5D	; 93
    a318:	9f 4a       	sbci	r25, 0xAF	; 175
    a31a:	fc 01       	movw	r30, r24
    a31c:	20 83       	st	Z, r18
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a31e:	8d 81       	ldd	r24, Y+5	; 0x05
    a320:	9e 81       	ldd	r25, Y+6	; 0x06
    a322:	01 96       	adiw	r24, 0x01	; 1
    a324:	8d 83       	std	Y+5, r24	; 0x05
    a326:	9e 83       	std	Y+6, r25	; 0x06
    a328:	8d 81       	ldd	r24, Y+5	; 0x05
    a32a:	9e 81       	ldd	r25, Y+6	; 0x06
    a32c:	82 30       	cpi	r24, 0x02	; 2
    a32e:	91 05       	cpc	r25, r1
    a330:	64 f3       	brlt	.-40     	; 0xa30a <SD_read_multiple_blocks+0xbe>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a332:	89 81       	ldd	r24, Y+1	; 0x01
    a334:	9a 81       	ldd	r25, Y+2	; 0x02
    a336:	01 96       	adiw	r24, 0x01	; 1
    a338:	89 83       	std	Y+1, r24	; 0x01
    a33a:	9a 83       	std	Y+2, r25	; 0x02
    a33c:	29 81       	ldd	r18, Y+1	; 0x01
    a33e:	3a 81       	ldd	r19, Y+2	; 0x02
    a340:	8d 85       	ldd	r24, Y+13	; 0x0d
    a342:	9e 85       	ldd	r25, Y+14	; 0x0e
    a344:	28 17       	cp	r18, r24
    a346:	39 07       	cpc	r19, r25
    a348:	0c f4       	brge	.+2      	; 0xa34c <SD_read_multiple_blocks+0x100>
    a34a:	ad cf       	rjmp	.-166    	; 0xa2a6 <SD_read_multiple_blocks+0x5a>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    a34c:	8c e0       	ldi	r24, 0x0C	; 12
    a34e:	40 e0       	ldi	r20, 0x00	; 0
    a350:	50 e0       	ldi	r21, 0x00	; 0
    a352:	ba 01       	movw	r22, r20
    a354:	2f ef       	ldi	r18, 0xFF	; 255
    a356:	08 e0       	ldi	r16, 0x08	; 8
    a358:	10 e0       	ldi	r17, 0x00	; 0
    a35a:	0e 94 06 4e 	call	0x9c0c	; 0x9c0c <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    a35e:	8f ef       	ldi	r24, 0xFF	; 255
    a360:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    a364:	80 93 a3 50 	sts	0x50A3, r24
	Buffer[1] = FILLER_BYTE;
    a368:	10 92 a4 50 	sts	0x50A4, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a36c:	05 c0       	rjmp	.+10     	; 0xa378 <SD_read_multiple_blocks+0x12c>
    a36e:	8f ef       	ldi	r24, 0xFF	; 255
    a370:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
    a374:	80 93 a4 50 	sts	0x50A4, r24
    a378:	80 91 a4 50 	lds	r24, 0x50A4
    a37c:	8f 3f       	cpi	r24, 0xFF	; 255
    a37e:	b9 f7       	brne	.-18     	; 0xa36e <SD_read_multiple_blocks+0x122>
	SPICS(FALSE);
    a380:	80 e0       	ldi	r24, 0x00	; 0
    a382:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	SPIDisable();
    a386:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a38a:	88 e0       	ldi	r24, 0x08	; 8
    a38c:	60 e0       	ldi	r22, 0x00	; 0
    a38e:	0e 94 74 34 	call	0x68e8	; 0x68e8 <PortEx_OUTSET>
}
    a392:	2e 96       	adiw	r28, 0x0e	; 14
    a394:	cd bf       	out	0x3d, r28	; 61
    a396:	de bf       	out	0x3e, r29	; 62
    a398:	df 91       	pop	r29
    a39a:	cf 91       	pop	r28
    a39c:	1f 91       	pop	r17
    a39e:	0f 91       	pop	r16
    a3a0:	08 95       	ret

0000a3a2 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
    a3a2:	cf 93       	push	r28
    a3a4:	df 93       	push	r29
    a3a6:	cd b7       	in	r28, 0x3d	; 61
    a3a8:	de b7       	in	r29, 0x3e	; 62
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    a3aa:	88 e0       	ldi	r24, 0x08	; 8
    a3ac:	60 e0       	ldi	r22, 0x00	; 0
    a3ae:	0e 94 a8 33 	call	0x6750	; 0x6750 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    a3b2:	88 e0       	ldi	r24, 0x08	; 8
    a3b4:	60 e0       	ldi	r22, 0x00	; 0
    a3b6:	0e 94 74 34 	call	0x68e8	; 0x68e8 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    a3ba:	80 e0       	ldi	r24, 0x00	; 0
    a3bc:	0e 94 44 38 	call	0x7088	; 0x7088 <SPIInit>
	SPICS(TRUE);
    a3c0:	81 e0       	ldi	r24, 0x01	; 1
    a3c2:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    a3c6:	8f ef       	ldi	r24, 0xFF	; 255
    a3c8:	0e 94 e8 4d 	call	0x9bd0	; 0x9bd0 <SPI_write>
	SPICS(FALSE);	//stop spi
    a3cc:	80 e0       	ldi	r24, 0x00	; 0
    a3ce:	0e 94 99 38 	call	0x7132	; 0x7132 <SPICS>
	SPIDisable();
    a3d2:	0e 94 b1 38 	call	0x7162	; 0x7162 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    a3d6:	80 e0       	ldi	r24, 0x00	; 0
    a3d8:	0e 94 97 05 	call	0xb2e	; 0xb2e <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    a3dc:	80 e0       	ldi	r24, 0x00	; 0
    a3de:	0e 94 3e 35 	call	0x6a7c	; 0x6a7c <Ext1Power>
}
    a3e2:	df 91       	pop	r29
    a3e4:	cf 91       	pop	r28
    a3e6:	08 95       	ret

0000a3e8 <main>:
#include "E-000001-000009_firmware_rev_1_0.h"

volatile int numOfSamples;
int32_t testArray[150];

int main(void) {
    a3e8:	8f 92       	push	r8
    a3ea:	9f 92       	push	r9
    a3ec:	af 92       	push	r10
    a3ee:	bf 92       	push	r11
    a3f0:	cf 92       	push	r12
    a3f2:	df 92       	push	r13
    a3f4:	ef 92       	push	r14
    a3f6:	ff 92       	push	r15
    a3f8:	0f 93       	push	r16
    a3fa:	cf 93       	push	r28
    a3fc:	df 93       	push	r29
    a3fe:	00 d0       	rcall	.+0      	; 0xa400 <main+0x18>
    a400:	00 d0       	rcall	.+0      	; 0xa402 <main+0x1a>
    a402:	cd b7       	in	r28, 0x3d	; 61
    a404:	de b7       	in	r29, 0x3e	; 62
	
	int UnityGain[] = {0,0,0};
    a406:	19 82       	std	Y+1, r1	; 0x01
    a408:	1a 82       	std	Y+2, r1	; 0x02
    a40a:	1b 82       	std	Y+3, r1	; 0x03
    a40c:	1c 82       	std	Y+4, r1	; 0x04
    a40e:	1d 82       	std	Y+5, r1	; 0x05
    a410:	1e 82       	std	Y+6, r1	; 0x06
// 	while(1){
// 		nop();
// 	}
	//CO_collectADC(ADC_CH_8_gc, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), GAIN_16_gc, SPS_4K_gc, 100, testArray);
	//CO_collectSeismic1Channel(ADC_CH_8_gc,(uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc),GAIN_1_gc, SSPS_SE_4K_gc, 5, TRUE, 1, 2, 3, 4,100,testArray);
	CO_collectSeismic3Channel_2((uint8_t) (FILTER_CH_3AND7_bm | FILTER_CH_2AND6_bm | FILTER_HP_0_bm | FILTER_LP_600_gc),UnityGain, SSPS_SE_4K_gc, 5, TRUE, 1, 2, 3, 4,100,testArray);
    a412:	00 d0       	rcall	.+0      	; 0xa414 <main+0x2c>
    a414:	00 d0       	rcall	.+0      	; 0xa416 <main+0x2e>
    a416:	2d b7       	in	r18, 0x3d	; 61
    a418:	3e b7       	in	r19, 0x3e	; 62
    a41a:	2f 5f       	subi	r18, 0xFF	; 255
    a41c:	3f 4f       	sbci	r19, 0xFF	; 255
    a41e:	84 e6       	ldi	r24, 0x64	; 100
    a420:	90 e0       	ldi	r25, 0x00	; 0
    a422:	a0 e0       	ldi	r26, 0x00	; 0
    a424:	b0 e0       	ldi	r27, 0x00	; 0
    a426:	f9 01       	movw	r30, r18
    a428:	80 83       	st	Z, r24
    a42a:	91 83       	std	Z+1, r25	; 0x01
    a42c:	a2 83       	std	Z+2, r26	; 0x02
    a42e:	b3 83       	std	Z+3, r27	; 0x03
    a430:	8b ec       	ldi	r24, 0xCB	; 203
    a432:	90 e5       	ldi	r25, 0x50	; 80
    a434:	f9 01       	movw	r30, r18
    a436:	84 83       	std	Z+4, r24	; 0x04
    a438:	95 83       	std	Z+5, r25	; 0x05
    a43a:	86 ec       	ldi	r24, 0xC6	; 198
    a43c:	9e 01       	movw	r18, r28
    a43e:	2f 5f       	subi	r18, 0xFF	; 255
    a440:	3f 4f       	sbci	r19, 0xFF	; 255
    a442:	b9 01       	movw	r22, r18
    a444:	44 e0       	ldi	r20, 0x04	; 4
    a446:	25 e0       	ldi	r18, 0x05	; 5
    a448:	01 e0       	ldi	r16, 0x01	; 1
    a44a:	ee 24       	eor	r14, r14
    a44c:	ff 24       	eor	r15, r15
    a44e:	e3 94       	inc	r14
    a450:	cc 24       	eor	r12, r12
    a452:	dd 24       	eor	r13, r13
    a454:	68 94       	set
    a456:	c1 f8       	bld	r12, 1
    a458:	0f 2e       	mov	r0, r31
    a45a:	f3 e0       	ldi	r31, 0x03	; 3
    a45c:	af 2e       	mov	r10, r31
    a45e:	bb 24       	eor	r11, r11
    a460:	f0 2d       	mov	r31, r0
    a462:	88 24       	eor	r8, r8
    a464:	99 24       	eor	r9, r9
    a466:	68 94       	set
    a468:	82 f8       	bld	r8, 2
    a46a:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <CO_collectSeismic3Channel_2>
    a46e:	8d b7       	in	r24, 0x3d	; 61
    a470:	9e b7       	in	r25, 0x3e	; 62
    a472:	06 96       	adiw	r24, 0x06	; 6
    a474:	8d bf       	out	0x3d, r24	; 61
    a476:	9e bf       	out	0x3e, r25	; 62
    a478:	80 e0       	ldi	r24, 0x00	; 0
    a47a:	90 e0       	ldi	r25, 0x00	; 0
    a47c:	26 96       	adiw	r28, 0x06	; 6
    a47e:	cd bf       	out	0x3d, r28	; 61
    a480:	de bf       	out	0x3e, r29	; 62
    a482:	df 91       	pop	r29
    a484:	cf 91       	pop	r28
    a486:	0f 91       	pop	r16
    a488:	ff 90       	pop	r15
    a48a:	ef 90       	pop	r14
    a48c:	df 90       	pop	r13
    a48e:	cf 90       	pop	r12
    a490:	bf 90       	pop	r11
    a492:	af 90       	pop	r10
    a494:	9f 90       	pop	r9
    a496:	8f 90       	pop	r8
    a498:	08 95       	ret

0000a49a <__muldi3>:
    a49a:	a0 e3       	ldi	r26, 0x30	; 48
    a49c:	b0 e0       	ldi	r27, 0x00	; 0
    a49e:	e3 e5       	ldi	r30, 0x53	; 83
    a4a0:	f2 e5       	ldi	r31, 0x52	; 82
    a4a2:	0c 94 8e 63 	jmp	0xc71c	; 0xc71c <__prologue_saves__+0x4>
    a4a6:	29 8f       	std	Y+25, r18	; 0x19
    a4a8:	3a 8f       	std	Y+26, r19	; 0x1a
    a4aa:	4b 8f       	std	Y+27, r20	; 0x1b
    a4ac:	5c 8f       	std	Y+28, r21	; 0x1c
    a4ae:	6d 8f       	std	Y+29, r22	; 0x1d
    a4b0:	7e 8f       	std	Y+30, r23	; 0x1e
    a4b2:	8f 8f       	std	Y+31, r24	; 0x1f
    a4b4:	98 a3       	lds	r25, 0x58
    a4b6:	a9 8a       	std	Y+17, r10	; 0x11
    a4b8:	ba 8a       	std	Y+18, r11	; 0x12
    a4ba:	cb 8a       	std	Y+19, r12	; 0x13
    a4bc:	dc 8a       	std	Y+20, r13	; 0x14
    a4be:	ed 8a       	std	Y+21, r14	; 0x15
    a4c0:	fe 8a       	std	Y+22, r15	; 0x16
    a4c2:	0f 8b       	std	Y+23, r16	; 0x17
    a4c4:	18 8f       	std	Y+24, r17	; 0x18
    a4c6:	09 8d       	ldd	r16, Y+25	; 0x19
    a4c8:	1a 8d       	ldd	r17, Y+26	; 0x1a
    a4ca:	2b 8d       	ldd	r18, Y+27	; 0x1b
    a4cc:	3c 8d       	ldd	r19, Y+28	; 0x1c
    a4ce:	09 a3       	lds	r16, 0x59
    a4d0:	1a a3       	lds	r17, 0x5a
    a4d2:	2b a3       	lds	r18, 0x5b
    a4d4:	3c a3       	lds	r19, 0x5c
    a4d6:	68 01       	movw	r12, r16
    a4d8:	79 01       	movw	r14, r18
    a4da:	8f ef       	ldi	r24, 0xFF	; 255
    a4dc:	9f ef       	ldi	r25, 0xFF	; 255
    a4de:	a0 e0       	ldi	r26, 0x00	; 0
    a4e0:	b0 e0       	ldi	r27, 0x00	; 0
    a4e2:	c8 22       	and	r12, r24
    a4e4:	d9 22       	and	r13, r25
    a4e6:	ea 22       	and	r14, r26
    a4e8:	fb 22       	and	r15, r27
    a4ea:	89 01       	movw	r16, r18
    a4ec:	22 27       	eor	r18, r18
    a4ee:	33 27       	eor	r19, r19
    a4f0:	09 a7       	lds	r16, 0x79
    a4f2:	1a a7       	lds	r17, 0x7a
    a4f4:	2b a7       	lds	r18, 0x7b
    a4f6:	3c a7       	lds	r19, 0x7c
    a4f8:	09 89       	ldd	r16, Y+17	; 0x11
    a4fa:	1a 89       	ldd	r17, Y+18	; 0x12
    a4fc:	2b 89       	ldd	r18, Y+19	; 0x13
    a4fe:	3c 89       	ldd	r19, Y+20	; 0x14
    a500:	0d a3       	lds	r16, 0x5d
    a502:	1e a3       	lds	r17, 0x5e
    a504:	2f a3       	lds	r18, 0x5f
    a506:	38 a7       	lds	r19, 0x78
    a508:	48 01       	movw	r8, r16
    a50a:	59 01       	movw	r10, r18
    a50c:	88 22       	and	r8, r24
    a50e:	99 22       	and	r9, r25
    a510:	aa 22       	and	r10, r26
    a512:	bb 22       	and	r11, r27
    a514:	29 01       	movw	r4, r18
    a516:	66 24       	eor	r6, r6
    a518:	77 24       	eor	r7, r7
    a51a:	c5 01       	movw	r24, r10
    a51c:	b4 01       	movw	r22, r8
    a51e:	a7 01       	movw	r20, r14
    a520:	96 01       	movw	r18, r12
    a522:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    a526:	6d a7       	lds	r22, 0x7d
    a528:	7e a7       	lds	r23, 0x7e
    a52a:	8f a7       	lds	r24, 0x7f
    a52c:	98 ab       	sts	0x58, r25
    a52e:	c3 01       	movw	r24, r6
    a530:	b2 01       	movw	r22, r4
    a532:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    a536:	6b 01       	movw	r12, r22
    a538:	7c 01       	movw	r14, r24
    a53a:	c5 01       	movw	r24, r10
    a53c:	b4 01       	movw	r22, r8
    a53e:	29 a5       	lds	r18, 0x69
    a540:	3a a5       	lds	r19, 0x6a
    a542:	4b a5       	lds	r20, 0x6b
    a544:	5c a5       	lds	r21, 0x6c
    a546:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    a54a:	4b 01       	movw	r8, r22
    a54c:	5c 01       	movw	r10, r24
    a54e:	c3 01       	movw	r24, r6
    a550:	b2 01       	movw	r22, r4
    a552:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    a556:	ab 01       	movw	r20, r22
    a558:	bc 01       	movw	r22, r24
    a55a:	c8 0c       	add	r12, r8
    a55c:	d9 1c       	adc	r13, r9
    a55e:	ea 1c       	adc	r14, r10
    a560:	fb 1c       	adc	r15, r11
    a562:	0d a5       	lds	r16, 0x6d
    a564:	1e a5       	lds	r17, 0x6e
    a566:	2f a5       	lds	r18, 0x6f
    a568:	38 a9       	sts	0x48, r19
    a56a:	c9 01       	movw	r24, r18
    a56c:	aa 27       	eor	r26, r26
    a56e:	bb 27       	eor	r27, r27
    a570:	c8 0e       	add	r12, r24
    a572:	d9 1e       	adc	r13, r25
    a574:	ea 1e       	adc	r14, r26
    a576:	fb 1e       	adc	r15, r27
    a578:	c8 14       	cp	r12, r8
    a57a:	d9 04       	cpc	r13, r9
    a57c:	ea 04       	cpc	r14, r10
    a57e:	fb 04       	cpc	r15, r11
    a580:	20 f4       	brcc	.+8      	; 0xa58a <__muldi3+0xf0>
    a582:	40 50       	subi	r20, 0x00	; 0
    a584:	50 40       	sbci	r21, 0x00	; 0
    a586:	6f 4f       	sbci	r22, 0xFF	; 255
    a588:	7f 4f       	sbci	r23, 0xFF	; 255
    a58a:	c7 01       	movw	r24, r14
    a58c:	aa 27       	eor	r26, r26
    a58e:	bb 27       	eor	r27, r27
    a590:	84 0f       	add	r24, r20
    a592:	95 1f       	adc	r25, r21
    a594:	a6 1f       	adc	r26, r22
    a596:	b7 1f       	adc	r27, r23
    a598:	8d 83       	std	Y+5, r24	; 0x05
    a59a:	9e 83       	std	Y+6, r25	; 0x06
    a59c:	af 83       	std	Y+7, r26	; 0x07
    a59e:	b8 87       	std	Y+8, r27	; 0x08
    a5a0:	76 01       	movw	r14, r12
    a5a2:	dd 24       	eor	r13, r13
    a5a4:	cc 24       	eor	r12, r12
    a5a6:	4d a5       	lds	r20, 0x6d
    a5a8:	5e a5       	lds	r21, 0x6e
    a5aa:	6f a5       	lds	r22, 0x6f
    a5ac:	78 a9       	sts	0x48, r23
    a5ae:	60 70       	andi	r22, 0x00	; 0
    a5b0:	70 70       	andi	r23, 0x00	; 0
    a5b2:	c4 0e       	add	r12, r20
    a5b4:	d5 1e       	adc	r13, r21
    a5b6:	e6 1e       	adc	r14, r22
    a5b8:	f7 1e       	adc	r15, r23
    a5ba:	c9 82       	std	Y+1, r12	; 0x01
    a5bc:	da 82       	std	Y+2, r13	; 0x02
    a5be:	eb 82       	std	Y+3, r14	; 0x03
    a5c0:	fc 82       	std	Y+4, r15	; 0x04
    a5c2:	1c 2d       	mov	r17, r12
    a5c4:	0a 81       	ldd	r16, Y+2	; 0x02
    a5c6:	8b 80       	ldd	r8, Y+3	; 0x03
    a5c8:	4c 80       	ldd	r4, Y+4	; 0x04
    a5ca:	8d 87       	std	Y+13, r24	; 0x0d
    a5cc:	8e 81       	ldd	r24, Y+6	; 0x06
    a5ce:	8e 87       	std	Y+14, r24	; 0x0e
    a5d0:	8f 81       	ldd	r24, Y+7	; 0x07
    a5d2:	8f 87       	std	Y+15, r24	; 0x0f
    a5d4:	88 85       	ldd	r24, Y+8	; 0x08
    a5d6:	88 8b       	std	Y+16, r24	; 0x10
    a5d8:	2d 89       	ldd	r18, Y+21	; 0x15
    a5da:	3e 89       	ldd	r19, Y+22	; 0x16
    a5dc:	4f 89       	ldd	r20, Y+23	; 0x17
    a5de:	58 8d       	ldd	r21, Y+24	; 0x18
    a5e0:	69 a1       	lds	r22, 0x49
    a5e2:	7a a1       	lds	r23, 0x4a
    a5e4:	8b a1       	lds	r24, 0x4b
    a5e6:	9c a1       	lds	r25, 0x4c
    a5e8:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    a5ec:	6b 01       	movw	r12, r22
    a5ee:	7c 01       	movw	r14, r24
    a5f0:	2d 8d       	ldd	r18, Y+29	; 0x1d
    a5f2:	3e 8d       	ldd	r19, Y+30	; 0x1e
    a5f4:	4f 8d       	ldd	r20, Y+31	; 0x1f
    a5f6:	58 a1       	lds	r21, 0x48
    a5f8:	6d a1       	lds	r22, 0x4d
    a5fa:	7e a1       	lds	r23, 0x4e
    a5fc:	8f a1       	lds	r24, 0x4f
    a5fe:	98 a5       	lds	r25, 0x68
    a600:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    a604:	dc 01       	movw	r26, r24
    a606:	cb 01       	movw	r24, r22
    a608:	c8 0e       	add	r12, r24
    a60a:	d9 1e       	adc	r13, r25
    a60c:	ea 1e       	adc	r14, r26
    a60e:	fb 1e       	adc	r15, r27
    a610:	8d 85       	ldd	r24, Y+13	; 0x0d
    a612:	9e 85       	ldd	r25, Y+14	; 0x0e
    a614:	af 85       	ldd	r26, Y+15	; 0x0f
    a616:	b8 89       	ldd	r27, Y+16	; 0x10
    a618:	8c 0d       	add	r24, r12
    a61a:	9d 1d       	adc	r25, r13
    a61c:	ae 1d       	adc	r26, r14
    a61e:	bf 1d       	adc	r27, r15
    a620:	8d 87       	std	Y+13, r24	; 0x0d
    a622:	9e 87       	std	Y+14, r25	; 0x0e
    a624:	af 87       	std	Y+15, r26	; 0x0f
    a626:	b8 8b       	std	Y+16, r27	; 0x10
    a628:	68 2f       	mov	r22, r24
    a62a:	7e 85       	ldd	r23, Y+14	; 0x0e
    a62c:	21 2f       	mov	r18, r17
    a62e:	30 2f       	mov	r19, r16
    a630:	48 2d       	mov	r20, r8
    a632:	54 2d       	mov	r21, r4
    a634:	8f 85       	ldd	r24, Y+15	; 0x0f
    a636:	98 89       	ldd	r25, Y+16	; 0x10
    a638:	e0 96       	adiw	r28, 0x30	; 48
    a63a:	e0 e1       	ldi	r30, 0x10	; 16
    a63c:	0c 94 a7 63 	jmp	0xc74e	; 0xc74e <__epilogue_restores__+0x4>

0000a640 <__ashldi3>:
    a640:	cf 92       	push	r12
    a642:	df 92       	push	r13
    a644:	ef 92       	push	r14
    a646:	ff 92       	push	r15
    a648:	0f 93       	push	r16
    a64a:	cf 93       	push	r28
    a64c:	df 93       	push	r29
    a64e:	cd b7       	in	r28, 0x3d	; 61
    a650:	de b7       	in	r29, 0x3e	; 62
    a652:	60 97       	sbiw	r28, 0x10	; 16
    a654:	cd bf       	out	0x3d, r28	; 61
    a656:	de bf       	out	0x3e, r29	; 62
    a658:	00 23       	and	r16, r16
    a65a:	09 f4       	brne	.+2      	; 0xa65e <__ashldi3+0x1e>
    a65c:	5a c0       	rjmp	.+180    	; 0xa712 <__ashldi3+0xd2>
    a65e:	29 87       	std	Y+9, r18	; 0x09
    a660:	3a 87       	std	Y+10, r19	; 0x0a
    a662:	4b 87       	std	Y+11, r20	; 0x0b
    a664:	5c 87       	std	Y+12, r21	; 0x0c
    a666:	6d 87       	std	Y+13, r22	; 0x0d
    a668:	7e 87       	std	Y+14, r23	; 0x0e
    a66a:	8f 87       	std	Y+15, r24	; 0x0f
    a66c:	98 8b       	std	Y+16, r25	; 0x10
    a66e:	80 e2       	ldi	r24, 0x20	; 32
    a670:	80 1b       	sub	r24, r16
    a672:	49 85       	ldd	r20, Y+9	; 0x09
    a674:	5a 85       	ldd	r21, Y+10	; 0x0a
    a676:	6b 85       	ldd	r22, Y+11	; 0x0b
    a678:	7c 85       	ldd	r23, Y+12	; 0x0c
    a67a:	18 16       	cp	r1, r24
    a67c:	b4 f0       	brlt	.+44     	; 0xa6aa <__ashldi3+0x6a>
    a67e:	19 82       	std	Y+1, r1	; 0x01
    a680:	1a 82       	std	Y+2, r1	; 0x02
    a682:	1b 82       	std	Y+3, r1	; 0x03
    a684:	1c 82       	std	Y+4, r1	; 0x04
    a686:	99 27       	eor	r25, r25
    a688:	87 fd       	sbrc	r24, 7
    a68a:	90 95       	com	r25
    a68c:	90 95       	com	r25
    a68e:	81 95       	neg	r24
    a690:	9f 4f       	sbci	r25, 0xFF	; 255
    a692:	04 c0       	rjmp	.+8      	; 0xa69c <__ashldi3+0x5c>
    a694:	44 0f       	add	r20, r20
    a696:	55 1f       	adc	r21, r21
    a698:	66 1f       	adc	r22, r22
    a69a:	77 1f       	adc	r23, r23
    a69c:	8a 95       	dec	r24
    a69e:	d2 f7       	brpl	.-12     	; 0xa694 <__ashldi3+0x54>
    a6a0:	4d 83       	std	Y+5, r20	; 0x05
    a6a2:	5e 83       	std	Y+6, r21	; 0x06
    a6a4:	6f 83       	std	Y+7, r22	; 0x07
    a6a6:	78 87       	std	Y+8, r23	; 0x08
    a6a8:	2c c0       	rjmp	.+88     	; 0xa702 <__ashldi3+0xc2>
    a6aa:	6a 01       	movw	r12, r20
    a6ac:	7b 01       	movw	r14, r22
    a6ae:	00 2e       	mov	r0, r16
    a6b0:	04 c0       	rjmp	.+8      	; 0xa6ba <__ashldi3+0x7a>
    a6b2:	cc 0c       	add	r12, r12
    a6b4:	dd 1c       	adc	r13, r13
    a6b6:	ee 1c       	adc	r14, r14
    a6b8:	ff 1c       	adc	r15, r15
    a6ba:	0a 94       	dec	r0
    a6bc:	d2 f7       	brpl	.-12     	; 0xa6b2 <__ashldi3+0x72>
    a6be:	c9 82       	std	Y+1, r12	; 0x01
    a6c0:	da 82       	std	Y+2, r13	; 0x02
    a6c2:	eb 82       	std	Y+3, r14	; 0x03
    a6c4:	fc 82       	std	Y+4, r15	; 0x04
    a6c6:	6a 01       	movw	r12, r20
    a6c8:	7b 01       	movw	r14, r22
    a6ca:	04 c0       	rjmp	.+8      	; 0xa6d4 <__ashldi3+0x94>
    a6cc:	f6 94       	lsr	r15
    a6ce:	e7 94       	ror	r14
    a6d0:	d7 94       	ror	r13
    a6d2:	c7 94       	ror	r12
    a6d4:	8a 95       	dec	r24
    a6d6:	d2 f7       	brpl	.-12     	; 0xa6cc <__ashldi3+0x8c>
    a6d8:	d7 01       	movw	r26, r14
    a6da:	c6 01       	movw	r24, r12
    a6dc:	4d 85       	ldd	r20, Y+13	; 0x0d
    a6de:	5e 85       	ldd	r21, Y+14	; 0x0e
    a6e0:	6f 85       	ldd	r22, Y+15	; 0x0f
    a6e2:	78 89       	ldd	r23, Y+16	; 0x10
    a6e4:	04 c0       	rjmp	.+8      	; 0xa6ee <__ashldi3+0xae>
    a6e6:	44 0f       	add	r20, r20
    a6e8:	55 1f       	adc	r21, r21
    a6ea:	66 1f       	adc	r22, r22
    a6ec:	77 1f       	adc	r23, r23
    a6ee:	0a 95       	dec	r16
    a6f0:	d2 f7       	brpl	.-12     	; 0xa6e6 <__ashldi3+0xa6>
    a6f2:	84 2b       	or	r24, r20
    a6f4:	95 2b       	or	r25, r21
    a6f6:	a6 2b       	or	r26, r22
    a6f8:	b7 2b       	or	r27, r23
    a6fa:	8d 83       	std	Y+5, r24	; 0x05
    a6fc:	9e 83       	std	Y+6, r25	; 0x06
    a6fe:	af 83       	std	Y+7, r26	; 0x07
    a700:	b8 87       	std	Y+8, r27	; 0x08
    a702:	29 81       	ldd	r18, Y+1	; 0x01
    a704:	3a 81       	ldd	r19, Y+2	; 0x02
    a706:	4b 81       	ldd	r20, Y+3	; 0x03
    a708:	5c 81       	ldd	r21, Y+4	; 0x04
    a70a:	6d 81       	ldd	r22, Y+5	; 0x05
    a70c:	7e 81       	ldd	r23, Y+6	; 0x06
    a70e:	8f 81       	ldd	r24, Y+7	; 0x07
    a710:	98 85       	ldd	r25, Y+8	; 0x08
    a712:	60 96       	adiw	r28, 0x10	; 16
    a714:	cd bf       	out	0x3d, r28	; 61
    a716:	de bf       	out	0x3e, r29	; 62
    a718:	df 91       	pop	r29
    a71a:	cf 91       	pop	r28
    a71c:	0f 91       	pop	r16
    a71e:	ff 90       	pop	r15
    a720:	ef 90       	pop	r14
    a722:	df 90       	pop	r13
    a724:	cf 90       	pop	r12
    a726:	08 95       	ret

0000a728 <__divdi3>:
    a728:	a8 e4       	ldi	r26, 0x48	; 72
    a72a:	b0 e0       	ldi	r27, 0x00	; 0
    a72c:	ea e9       	ldi	r30, 0x9A	; 154
    a72e:	f3 e5       	ldi	r31, 0x53	; 83
    a730:	0c 94 8d 63 	jmp	0xc71a	; 0xc71a <__prologue_saves__+0x2>
    a734:	f5 01       	movw	r30, r10
    a736:	29 a3       	lds	r18, 0x59
    a738:	3a a3       	lds	r19, 0x5a
    a73a:	4b a3       	lds	r20, 0x5b
    a73c:	5c a3       	lds	r21, 0x5c
    a73e:	6d a3       	lds	r22, 0x5d
    a740:	7e a3       	lds	r23, 0x5e
    a742:	8f a3       	lds	r24, 0x5f
    a744:	98 a7       	lds	r25, 0x78
    a746:	a9 8e       	std	Y+25, r10	; 0x19
    a748:	fa 8f       	std	Y+26, r31	; 0x1a
    a74a:	cb 8e       	std	Y+27, r12	; 0x1b
    a74c:	dc 8e       	std	Y+28, r13	; 0x1c
    a74e:	ed 8e       	std	Y+29, r14	; 0x1d
    a750:	fe 8e       	std	Y+30, r15	; 0x1e
    a752:	0f 8f       	std	Y+31, r16	; 0x1f
    a754:	18 a3       	lds	r17, 0x58
    a756:	8d a0       	lds	r24, 0x8d
    a758:	9e a0       	lds	r25, 0x8e
    a75a:	af a0       	lds	r26, 0x8f
    a75c:	b8 a4       	lds	r27, 0xa8
    a75e:	b7 fe       	sbrs	r11, 7
    a760:	67 c0       	rjmp	.+206    	; 0xa830 <__divdi3+0x108>
    a762:	21 95       	neg	r18
    a764:	b1 e0       	ldi	r27, 0x01	; 1
    a766:	12 16       	cp	r1, r18
    a768:	08 f0       	brcs	.+2      	; 0xa76c <__divdi3+0x44>
    a76a:	b0 e0       	ldi	r27, 0x00	; 0
    a76c:	31 95       	neg	r19
    a76e:	a1 e0       	ldi	r26, 0x01	; 1
    a770:	13 16       	cp	r1, r19
    a772:	08 f0       	brcs	.+2      	; 0xa776 <__divdi3+0x4e>
    a774:	a0 e0       	ldi	r26, 0x00	; 0
    a776:	b3 2e       	mov	r11, r19
    a778:	bb 1a       	sub	r11, r27
    a77a:	bb 2d       	mov	r27, r11
    a77c:	88 24       	eor	r8, r8
    a77e:	83 94       	inc	r8
    a780:	3b 15       	cp	r19, r11
    a782:	08 f0       	brcs	.+2      	; 0xa786 <__divdi3+0x5e>
    a784:	88 24       	eor	r8, r8
    a786:	a8 29       	or	r26, r8
    a788:	41 95       	neg	r20
    a78a:	31 e0       	ldi	r19, 0x01	; 1
    a78c:	14 16       	cp	r1, r20
    a78e:	08 f0       	brcs	.+2      	; 0xa792 <__divdi3+0x6a>
    a790:	30 e0       	ldi	r19, 0x00	; 0
    a792:	b4 2e       	mov	r11, r20
    a794:	ba 1a       	sub	r11, r26
    a796:	ab 2d       	mov	r26, r11
    a798:	88 24       	eor	r8, r8
    a79a:	83 94       	inc	r8
    a79c:	4b 15       	cp	r20, r11
    a79e:	08 f0       	brcs	.+2      	; 0xa7a2 <__divdi3+0x7a>
    a7a0:	88 24       	eor	r8, r8
    a7a2:	38 29       	or	r19, r8
    a7a4:	51 95       	neg	r21
    a7a6:	41 e0       	ldi	r20, 0x01	; 1
    a7a8:	15 16       	cp	r1, r21
    a7aa:	08 f0       	brcs	.+2      	; 0xa7ae <__divdi3+0x86>
    a7ac:	40 e0       	ldi	r20, 0x00	; 0
    a7ae:	45 2e       	mov	r4, r21
    a7b0:	43 1a       	sub	r4, r19
    a7b2:	31 e0       	ldi	r19, 0x01	; 1
    a7b4:	54 15       	cp	r21, r4
    a7b6:	08 f0       	brcs	.+2      	; 0xa7ba <__divdi3+0x92>
    a7b8:	30 e0       	ldi	r19, 0x00	; 0
    a7ba:	43 2b       	or	r20, r19
    a7bc:	61 95       	neg	r22
    a7be:	31 e0       	ldi	r19, 0x01	; 1
    a7c0:	16 16       	cp	r1, r22
    a7c2:	08 f0       	brcs	.+2      	; 0xa7c6 <__divdi3+0x9e>
    a7c4:	30 e0       	ldi	r19, 0x00	; 0
    a7c6:	86 2e       	mov	r8, r22
    a7c8:	84 1a       	sub	r8, r20
    a7ca:	41 e0       	ldi	r20, 0x01	; 1
    a7cc:	68 15       	cp	r22, r8
    a7ce:	08 f0       	brcs	.+2      	; 0xa7d2 <__divdi3+0xaa>
    a7d0:	40 e0       	ldi	r20, 0x00	; 0
    a7d2:	34 2b       	or	r19, r20
    a7d4:	71 95       	neg	r23
    a7d6:	41 e0       	ldi	r20, 0x01	; 1
    a7d8:	17 16       	cp	r1, r23
    a7da:	08 f0       	brcs	.+2      	; 0xa7de <__divdi3+0xb6>
    a7dc:	40 e0       	ldi	r20, 0x00	; 0
    a7de:	57 2f       	mov	r21, r23
    a7e0:	53 1b       	sub	r21, r19
    a7e2:	31 e0       	ldi	r19, 0x01	; 1
    a7e4:	75 17       	cp	r23, r21
    a7e6:	08 f0       	brcs	.+2      	; 0xa7ea <__divdi3+0xc2>
    a7e8:	30 e0       	ldi	r19, 0x00	; 0
    a7ea:	43 2b       	or	r20, r19
    a7ec:	81 95       	neg	r24
    a7ee:	31 e0       	ldi	r19, 0x01	; 1
    a7f0:	18 16       	cp	r1, r24
    a7f2:	08 f0       	brcs	.+2      	; 0xa7f6 <__divdi3+0xce>
    a7f4:	30 e0       	ldi	r19, 0x00	; 0
    a7f6:	68 2f       	mov	r22, r24
    a7f8:	64 1b       	sub	r22, r20
    a7fa:	46 2f       	mov	r20, r22
    a7fc:	61 e0       	ldi	r22, 0x01	; 1
    a7fe:	84 17       	cp	r24, r20
    a800:	08 f0       	brcs	.+2      	; 0xa804 <__divdi3+0xdc>
    a802:	60 e0       	ldi	r22, 0x00	; 0
    a804:	36 2b       	or	r19, r22
    a806:	91 95       	neg	r25
    a808:	93 1b       	sub	r25, r19
    a80a:	29 a3       	lds	r18, 0x59
    a80c:	ba a3       	lds	r27, 0x5a
    a80e:	ab a3       	lds	r26, 0x5b
    a810:	4c a2       	lds	r20, 0x9c
    a812:	8d a2       	lds	r24, 0x9d
    a814:	5e a3       	lds	r21, 0x5e
    a816:	4f a3       	lds	r20, 0x5f
    a818:	98 a7       	lds	r25, 0x78
    a81a:	8f ef       	ldi	r24, 0xFF	; 255
    a81c:	9f ef       	ldi	r25, 0xFF	; 255
    a81e:	af ef       	ldi	r26, 0xFF	; 255
    a820:	bf ef       	ldi	r27, 0xFF	; 255
    a822:	25 96       	adiw	r28, 0x05	; 5
    a824:	8c af       	sts	0x7c, r24
    a826:	9d af       	sts	0x7d, r25
    a828:	ae af       	sts	0x7e, r26
    a82a:	bf af       	sts	0x7f, r27
    a82c:	25 97       	sbiw	r28, 0x05	; 5
    a82e:	06 c0       	rjmp	.+12     	; 0xa83c <__divdi3+0x114>
    a830:	25 96       	adiw	r28, 0x05	; 5
    a832:	1c ae       	sts	0xbc, r17
    a834:	1d ae       	sts	0xbd, r17
    a836:	1e ae       	sts	0xbe, r17
    a838:	1f ae       	sts	0xbf, r17
    a83a:	25 97       	sbiw	r28, 0x05	; 5
    a83c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    a83e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    a840:	af 8d       	ldd	r26, Y+31	; 0x1f
    a842:	b8 a1       	lds	r27, 0x48
    a844:	b7 ff       	sbrs	r27, 7
    a846:	68 c0       	rjmp	.+208    	; 0xa918 <__divdi3+0x1f0>
    a848:	25 96       	adiw	r28, 0x05	; 5
    a84a:	2c ad       	sts	0x6c, r18
    a84c:	3d ad       	sts	0x6d, r19
    a84e:	4e ad       	sts	0x6e, r20
    a850:	5f ad       	sts	0x6f, r21
    a852:	25 97       	sbiw	r28, 0x05	; 5
    a854:	20 95       	com	r18
    a856:	30 95       	com	r19
    a858:	40 95       	com	r20
    a85a:	50 95       	com	r21
    a85c:	25 96       	adiw	r28, 0x05	; 5
    a85e:	2c af       	sts	0x7c, r18
    a860:	3d af       	sts	0x7d, r19
    a862:	4e af       	sts	0x7e, r20
    a864:	5f af       	sts	0x7f, r21
    a866:	25 97       	sbiw	r28, 0x05	; 5
    a868:	e1 95       	neg	r30
    a86a:	81 e0       	ldi	r24, 0x01	; 1
    a86c:	1e 16       	cp	r1, r30
    a86e:	08 f0       	brcs	.+2      	; 0xa872 <__divdi3+0x14a>
    a870:	80 e0       	ldi	r24, 0x00	; 0
    a872:	f1 95       	neg	r31
    a874:	91 e0       	ldi	r25, 0x01	; 1
    a876:	1f 16       	cp	r1, r31
    a878:	08 f0       	brcs	.+2      	; 0xa87c <__divdi3+0x154>
    a87a:	90 e0       	ldi	r25, 0x00	; 0
    a87c:	4f 2f       	mov	r20, r31
    a87e:	48 1b       	sub	r20, r24
    a880:	81 e0       	ldi	r24, 0x01	; 1
    a882:	f4 17       	cp	r31, r20
    a884:	08 f0       	brcs	.+2      	; 0xa888 <__divdi3+0x160>
    a886:	80 e0       	ldi	r24, 0x00	; 0
    a888:	98 2b       	or	r25, r24
    a88a:	c1 94       	neg	r12
    a88c:	81 e0       	ldi	r24, 0x01	; 1
    a88e:	1c 14       	cp	r1, r12
    a890:	08 f0       	brcs	.+2      	; 0xa894 <__divdi3+0x16c>
    a892:	80 e0       	ldi	r24, 0x00	; 0
    a894:	6c 2d       	mov	r22, r12
    a896:	69 1b       	sub	r22, r25
    a898:	91 e0       	ldi	r25, 0x01	; 1
    a89a:	c6 16       	cp	r12, r22
    a89c:	08 f0       	brcs	.+2      	; 0xa8a0 <__divdi3+0x178>
    a89e:	90 e0       	ldi	r25, 0x00	; 0
    a8a0:	89 2b       	or	r24, r25
    a8a2:	d1 94       	neg	r13
    a8a4:	91 e0       	ldi	r25, 0x01	; 1
    a8a6:	1d 14       	cp	r1, r13
    a8a8:	08 f0       	brcs	.+2      	; 0xa8ac <__divdi3+0x184>
    a8aa:	90 e0       	ldi	r25, 0x00	; 0
    a8ac:	5d 2d       	mov	r21, r13
    a8ae:	58 1b       	sub	r21, r24
    a8b0:	81 e0       	ldi	r24, 0x01	; 1
    a8b2:	d5 16       	cp	r13, r21
    a8b4:	08 f0       	brcs	.+2      	; 0xa8b8 <__divdi3+0x190>
    a8b6:	80 e0       	ldi	r24, 0x00	; 0
    a8b8:	98 2b       	or	r25, r24
    a8ba:	e1 94       	neg	r14
    a8bc:	81 e0       	ldi	r24, 0x01	; 1
    a8be:	1e 14       	cp	r1, r14
    a8c0:	08 f0       	brcs	.+2      	; 0xa8c4 <__divdi3+0x19c>
    a8c2:	80 e0       	ldi	r24, 0x00	; 0
    a8c4:	3e 2d       	mov	r19, r14
    a8c6:	39 1b       	sub	r19, r25
    a8c8:	91 e0       	ldi	r25, 0x01	; 1
    a8ca:	e3 16       	cp	r14, r19
    a8cc:	08 f0       	brcs	.+2      	; 0xa8d0 <__divdi3+0x1a8>
    a8ce:	90 e0       	ldi	r25, 0x00	; 0
    a8d0:	89 2b       	or	r24, r25
    a8d2:	f1 94       	neg	r15
    a8d4:	91 e0       	ldi	r25, 0x01	; 1
    a8d6:	1f 14       	cp	r1, r15
    a8d8:	08 f0       	brcs	.+2      	; 0xa8dc <__divdi3+0x1b4>
    a8da:	90 e0       	ldi	r25, 0x00	; 0
    a8dc:	2f 2d       	mov	r18, r15
    a8de:	28 1b       	sub	r18, r24
    a8e0:	81 e0       	ldi	r24, 0x01	; 1
    a8e2:	f2 16       	cp	r15, r18
    a8e4:	08 f0       	brcs	.+2      	; 0xa8e8 <__divdi3+0x1c0>
    a8e6:	80 e0       	ldi	r24, 0x00	; 0
    a8e8:	98 2b       	or	r25, r24
    a8ea:	01 95       	neg	r16
    a8ec:	81 e0       	ldi	r24, 0x01	; 1
    a8ee:	10 16       	cp	r1, r16
    a8f0:	08 f0       	brcs	.+2      	; 0xa8f4 <__divdi3+0x1cc>
    a8f2:	80 e0       	ldi	r24, 0x00	; 0
    a8f4:	70 2f       	mov	r23, r16
    a8f6:	79 1b       	sub	r23, r25
    a8f8:	97 2f       	mov	r25, r23
    a8fa:	71 e0       	ldi	r23, 0x01	; 1
    a8fc:	09 17       	cp	r16, r25
    a8fe:	08 f0       	brcs	.+2      	; 0xa902 <__divdi3+0x1da>
    a900:	70 e0       	ldi	r23, 0x00	; 0
    a902:	87 2b       	or	r24, r23
    a904:	11 95       	neg	r17
    a906:	18 1b       	sub	r17, r24
    a908:	e9 8f       	std	Y+25, r30	; 0x19
    a90a:	4a 8f       	std	Y+26, r20	; 0x1a
    a90c:	6b 8f       	std	Y+27, r22	; 0x1b
    a90e:	5c 8f       	std	Y+28, r21	; 0x1c
    a910:	3d 8f       	std	Y+29, r19	; 0x1d
    a912:	2e 8f       	std	Y+30, r18	; 0x1e
    a914:	9f 8f       	std	Y+31, r25	; 0x1f
    a916:	18 a3       	lds	r17, 0x58
    a918:	79 8d       	ldd	r23, Y+25	; 0x19
    a91a:	6a 8d       	ldd	r22, Y+26	; 0x1a
    a91c:	5b 8d       	ldd	r21, Y+27	; 0x1b
    a91e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    a920:	3d 8d       	ldd	r19, Y+29	; 0x1d
    a922:	2e 8d       	ldd	r18, Y+30	; 0x1e
    a924:	9f 8d       	ldd	r25, Y+31	; 0x1f
    a926:	88 a1       	lds	r24, 0x48
    a928:	e9 a1       	lds	r30, 0x49
    a92a:	e9 8b       	std	Y+17, r30	; 0x11
    a92c:	ea a1       	lds	r30, 0x4a
    a92e:	ea 8b       	std	Y+18, r30	; 0x12
    a930:	eb a1       	lds	r30, 0x4b
    a932:	eb 8b       	std	Y+19, r30	; 0x13
    a934:	ec a1       	lds	r30, 0x4c
    a936:	ec 8b       	std	Y+20, r30	; 0x14
    a938:	ed a1       	lds	r30, 0x4d
    a93a:	ed 8b       	std	Y+21, r30	; 0x15
    a93c:	ee a1       	lds	r30, 0x4e
    a93e:	ee 8b       	std	Y+22, r30	; 0x16
    a940:	ef a1       	lds	r30, 0x4f
    a942:	ef 8b       	std	Y+23, r30	; 0x17
    a944:	e8 a5       	lds	r30, 0x68
    a946:	e8 8f       	std	Y+24, r30	; 0x18
    a948:	79 87       	std	Y+9, r23	; 0x09
    a94a:	6a 87       	std	Y+10, r22	; 0x0a
    a94c:	5b 87       	std	Y+11, r21	; 0x0b
    a94e:	4c 87       	std	Y+12, r20	; 0x0c
    a950:	3d 87       	std	Y+13, r19	; 0x0d
    a952:	2e 87       	std	Y+14, r18	; 0x0e
    a954:	9f 87       	std	Y+15, r25	; 0x0f
    a956:	88 8b       	std	Y+16, r24	; 0x10
    a958:	89 84       	ldd	r8, Y+9	; 0x09
    a95a:	9a 84       	ldd	r9, Y+10	; 0x0a
    a95c:	ab 84       	ldd	r10, Y+11	; 0x0b
    a95e:	bc 84       	ldd	r11, Y+12	; 0x0c
    a960:	8d 85       	ldd	r24, Y+13	; 0x0d
    a962:	9e 85       	ldd	r25, Y+14	; 0x0e
    a964:	af 85       	ldd	r26, Y+15	; 0x0f
    a966:	b8 89       	ldd	r27, Y+16	; 0x10
    a968:	e9 88       	ldd	r14, Y+17	; 0x11
    a96a:	fa 88       	ldd	r15, Y+18	; 0x12
    a96c:	0b 89       	ldd	r16, Y+19	; 0x13
    a96e:	1c 89       	ldd	r17, Y+20	; 0x14
    a970:	ed aa       	sts	0x9d, r30
    a972:	fe aa       	sts	0x9e, r31
    a974:	0f ab       	sts	0x5f, r16
    a976:	18 af       	sts	0x78, r17
    a978:	cd 88       	ldd	r12, Y+21	; 0x15
    a97a:	de 88       	ldd	r13, Y+22	; 0x16
    a97c:	ef 88       	ldd	r14, Y+23	; 0x17
    a97e:	f8 8c       	ldd	r15, Y+24	; 0x18
    a980:	00 97       	sbiw	r24, 0x00	; 0
    a982:	a1 05       	cpc	r26, r1
    a984:	b1 05       	cpc	r27, r1
    a986:	09 f0       	breq	.+2      	; 0xa98a <__divdi3+0x262>
    a988:	bd c3       	rjmp	.+1914   	; 0xb104 <__divdi3+0x9dc>
    a98a:	c8 14       	cp	r12, r8
    a98c:	d9 04       	cpc	r13, r9
    a98e:	ea 04       	cpc	r14, r10
    a990:	fb 04       	cpc	r15, r11
    a992:	08 f0       	brcs	.+2      	; 0xa996 <__divdi3+0x26e>
    a994:	4d c1       	rjmp	.+666    	; 0xac30 <__divdi3+0x508>
    a996:	00 e0       	ldi	r16, 0x00	; 0
    a998:	80 16       	cp	r8, r16
    a99a:	00 e0       	ldi	r16, 0x00	; 0
    a99c:	90 06       	cpc	r9, r16
    a99e:	01 e0       	ldi	r16, 0x01	; 1
    a9a0:	a0 06       	cpc	r10, r16
    a9a2:	00 e0       	ldi	r16, 0x00	; 0
    a9a4:	b0 06       	cpc	r11, r16
    a9a6:	58 f4       	brcc	.+22     	; 0xa9be <__divdi3+0x296>
    a9a8:	1f ef       	ldi	r17, 0xFF	; 255
    a9aa:	81 16       	cp	r8, r17
    a9ac:	91 04       	cpc	r9, r1
    a9ae:	a1 04       	cpc	r10, r1
    a9b0:	b1 04       	cpc	r11, r1
    a9b2:	09 f0       	breq	.+2      	; 0xa9b6 <__divdi3+0x28e>
    a9b4:	90 f4       	brcc	.+36     	; 0xa9da <__divdi3+0x2b2>
    a9b6:	80 e0       	ldi	r24, 0x00	; 0
    a9b8:	90 e0       	ldi	r25, 0x00	; 0
    a9ba:	dc 01       	movw	r26, r24
    a9bc:	17 c0       	rjmp	.+46     	; 0xa9ec <__divdi3+0x2c4>
    a9be:	20 e0       	ldi	r18, 0x00	; 0
    a9c0:	82 16       	cp	r8, r18
    a9c2:	20 e0       	ldi	r18, 0x00	; 0
    a9c4:	92 06       	cpc	r9, r18
    a9c6:	20 e0       	ldi	r18, 0x00	; 0
    a9c8:	a2 06       	cpc	r10, r18
    a9ca:	21 e0       	ldi	r18, 0x01	; 1
    a9cc:	b2 06       	cpc	r11, r18
    a9ce:	50 f4       	brcc	.+20     	; 0xa9e4 <__divdi3+0x2bc>
    a9d0:	80 e1       	ldi	r24, 0x10	; 16
    a9d2:	90 e0       	ldi	r25, 0x00	; 0
    a9d4:	a0 e0       	ldi	r26, 0x00	; 0
    a9d6:	b0 e0       	ldi	r27, 0x00	; 0
    a9d8:	09 c0       	rjmp	.+18     	; 0xa9ec <__divdi3+0x2c4>
    a9da:	88 e0       	ldi	r24, 0x08	; 8
    a9dc:	90 e0       	ldi	r25, 0x00	; 0
    a9de:	a0 e0       	ldi	r26, 0x00	; 0
    a9e0:	b0 e0       	ldi	r27, 0x00	; 0
    a9e2:	04 c0       	rjmp	.+8      	; 0xa9ec <__divdi3+0x2c4>
    a9e4:	88 e1       	ldi	r24, 0x18	; 24
    a9e6:	90 e0       	ldi	r25, 0x00	; 0
    a9e8:	a0 e0       	ldi	r26, 0x00	; 0
    a9ea:	b0 e0       	ldi	r27, 0x00	; 0
    a9ec:	b5 01       	movw	r22, r10
    a9ee:	a4 01       	movw	r20, r8
    a9f0:	08 2e       	mov	r0, r24
    a9f2:	04 c0       	rjmp	.+8      	; 0xa9fc <__divdi3+0x2d4>
    a9f4:	76 95       	lsr	r23
    a9f6:	67 95       	ror	r22
    a9f8:	57 95       	ror	r21
    a9fa:	47 95       	ror	r20
    a9fc:	0a 94       	dec	r0
    a9fe:	d2 f7       	brpl	.-12     	; 0xa9f4 <__divdi3+0x2cc>
    aa00:	fa 01       	movw	r30, r20
    aa02:	ea 5d       	subi	r30, 0xDA	; 218
    aa04:	ff 4d       	sbci	r31, 0xDF	; 223
    aa06:	20 81       	ld	r18, Z
    aa08:	40 e2       	ldi	r20, 0x20	; 32
    aa0a:	50 e0       	ldi	r21, 0x00	; 0
    aa0c:	60 e0       	ldi	r22, 0x00	; 0
    aa0e:	70 e0       	ldi	r23, 0x00	; 0
    aa10:	48 1b       	sub	r20, r24
    aa12:	59 0b       	sbc	r21, r25
    aa14:	6a 0b       	sbc	r22, r26
    aa16:	7b 0b       	sbc	r23, r27
    aa18:	42 1b       	sub	r20, r18
    aa1a:	51 09       	sbc	r21, r1
    aa1c:	61 09       	sbc	r22, r1
    aa1e:	71 09       	sbc	r23, r1
    aa20:	41 15       	cp	r20, r1
    aa22:	51 05       	cpc	r21, r1
    aa24:	61 05       	cpc	r22, r1
    aa26:	71 05       	cpc	r23, r1
    aa28:	a1 f1       	breq	.+104    	; 0xaa92 <__divdi3+0x36a>
    aa2a:	04 2e       	mov	r0, r20
    aa2c:	04 c0       	rjmp	.+8      	; 0xaa36 <__divdi3+0x30e>
    aa2e:	88 0c       	add	r8, r8
    aa30:	99 1c       	adc	r9, r9
    aa32:	aa 1c       	adc	r10, r10
    aa34:	bb 1c       	adc	r11, r11
    aa36:	0a 94       	dec	r0
    aa38:	d2 f7       	brpl	.-12     	; 0xaa2e <__divdi3+0x306>
    aa3a:	97 01       	movw	r18, r14
    aa3c:	86 01       	movw	r16, r12
    aa3e:	04 2e       	mov	r0, r20
    aa40:	04 c0       	rjmp	.+8      	; 0xaa4a <__divdi3+0x322>
    aa42:	00 0f       	add	r16, r16
    aa44:	11 1f       	adc	r17, r17
    aa46:	22 1f       	adc	r18, r18
    aa48:	33 1f       	adc	r19, r19
    aa4a:	0a 94       	dec	r0
    aa4c:	d2 f7       	brpl	.-12     	; 0xaa42 <__divdi3+0x31a>
    aa4e:	80 e2       	ldi	r24, 0x20	; 32
    aa50:	90 e0       	ldi	r25, 0x00	; 0
    aa52:	84 1b       	sub	r24, r20
    aa54:	95 0b       	sbc	r25, r21
    aa56:	cd a8       	sts	0x8d, r28
    aa58:	de a8       	sts	0x8e, r29
    aa5a:	ef a8       	sts	0x8f, r30
    aa5c:	f8 ac       	sts	0xa8, r31
    aa5e:	04 c0       	rjmp	.+8      	; 0xaa68 <__divdi3+0x340>
    aa60:	f6 94       	lsr	r15
    aa62:	e7 94       	ror	r14
    aa64:	d7 94       	ror	r13
    aa66:	c7 94       	ror	r12
    aa68:	8a 95       	dec	r24
    aa6a:	d2 f7       	brpl	.-12     	; 0xaa60 <__divdi3+0x338>
    aa6c:	c0 2a       	or	r12, r16
    aa6e:	d1 2a       	or	r13, r17
    aa70:	e2 2a       	or	r14, r18
    aa72:	f3 2a       	or	r15, r19
    aa74:	0d a9       	sts	0x4d, r16
    aa76:	1e a9       	sts	0x4e, r17
    aa78:	2f a9       	sts	0x4f, r18
    aa7a:	38 ad       	sts	0x68, r19
    aa7c:	04 c0       	rjmp	.+8      	; 0xaa86 <__divdi3+0x35e>
    aa7e:	00 0f       	add	r16, r16
    aa80:	11 1f       	adc	r17, r17
    aa82:	22 1f       	adc	r18, r18
    aa84:	33 1f       	adc	r19, r19
    aa86:	4a 95       	dec	r20
    aa88:	d2 f7       	brpl	.-12     	; 0xaa7e <__divdi3+0x356>
    aa8a:	0d ab       	sts	0x5d, r16
    aa8c:	1e ab       	sts	0x5e, r17
    aa8e:	2f ab       	sts	0x5f, r18
    aa90:	38 af       	sts	0x78, r19
    aa92:	25 01       	movw	r4, r10
    aa94:	66 24       	eor	r6, r6
    aa96:	77 24       	eor	r7, r7
    aa98:	95 01       	movw	r18, r10
    aa9a:	84 01       	movw	r16, r8
    aa9c:	20 70       	andi	r18, 0x00	; 0
    aa9e:	30 70       	andi	r19, 0x00	; 0
    aaa0:	09 ab       	sts	0x59, r16
    aaa2:	1a ab       	sts	0x5a, r17
    aaa4:	2b ab       	sts	0x5b, r18
    aaa6:	3c ab       	sts	0x5c, r19
    aaa8:	c7 01       	movw	r24, r14
    aaaa:	b6 01       	movw	r22, r12
    aaac:	a3 01       	movw	r20, r6
    aaae:	92 01       	movw	r18, r4
    aab0:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    aab4:	2d a7       	lds	r18, 0x7d
    aab6:	3e a7       	lds	r19, 0x7e
    aab8:	4f a7       	lds	r20, 0x7f
    aaba:	58 ab       	sts	0x58, r21
    aabc:	69 a7       	lds	r22, 0x79
    aabe:	7a a7       	lds	r23, 0x7a
    aac0:	8b a7       	lds	r24, 0x7b
    aac2:	9c a7       	lds	r25, 0x7c
    aac4:	c7 01       	movw	r24, r14
    aac6:	b6 01       	movw	r22, r12
    aac8:	a3 01       	movw	r20, r6
    aaca:	92 01       	movw	r18, r4
    aacc:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    aad0:	ca 01       	movw	r24, r20
    aad2:	b9 01       	movw	r22, r18
    aad4:	29 a9       	sts	0x49, r18
    aad6:	3a a9       	sts	0x4a, r19
    aad8:	4b a9       	sts	0x4b, r20
    aada:	5c a9       	sts	0x4c, r21
    aadc:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    aae0:	ab 01       	movw	r20, r22
    aae2:	bc 01       	movw	r22, r24
    aae4:	09 a5       	lds	r16, 0x69
    aae6:	1a a5       	lds	r17, 0x6a
    aae8:	2b a5       	lds	r18, 0x6b
    aaea:	3c a5       	lds	r19, 0x6c
    aaec:	78 01       	movw	r14, r16
    aaee:	dd 24       	eor	r13, r13
    aaf0:	cc 24       	eor	r12, r12
    aaf2:	0d a9       	sts	0x4d, r16
    aaf4:	1e a9       	sts	0x4e, r17
    aaf6:	2f a9       	sts	0x4f, r18
    aaf8:	38 ad       	sts	0x68, r19
    aafa:	c9 01       	movw	r24, r18
    aafc:	aa 27       	eor	r26, r26
    aafe:	bb 27       	eor	r27, r27
    ab00:	c8 2a       	or	r12, r24
    ab02:	d9 2a       	or	r13, r25
    ab04:	ea 2a       	or	r14, r26
    ab06:	fb 2a       	or	r15, r27
    ab08:	0d a5       	lds	r16, 0x6d
    ab0a:	1e a5       	lds	r17, 0x6e
    ab0c:	2f a5       	lds	r18, 0x6f
    ab0e:	38 a9       	sts	0x48, r19
    ab10:	c4 16       	cp	r12, r20
    ab12:	d5 06       	cpc	r13, r21
    ab14:	e6 06       	cpc	r14, r22
    ab16:	f7 06       	cpc	r15, r23
    ab18:	38 f5       	brcc	.+78     	; 0xab68 <__divdi3+0x440>
    ab1a:	01 50       	subi	r16, 0x01	; 1
    ab1c:	10 40       	sbci	r17, 0x00	; 0
    ab1e:	20 40       	sbci	r18, 0x00	; 0
    ab20:	30 40       	sbci	r19, 0x00	; 0
    ab22:	09 a7       	lds	r16, 0x79
    ab24:	1a a7       	lds	r17, 0x7a
    ab26:	2b a7       	lds	r18, 0x7b
    ab28:	3c a7       	lds	r19, 0x7c
    ab2a:	c8 0c       	add	r12, r8
    ab2c:	d9 1c       	adc	r13, r9
    ab2e:	ea 1c       	adc	r14, r10
    ab30:	fb 1c       	adc	r15, r11
    ab32:	c8 14       	cp	r12, r8
    ab34:	d9 04       	cpc	r13, r9
    ab36:	ea 04       	cpc	r14, r10
    ab38:	fb 04       	cpc	r15, r11
    ab3a:	d0 f0       	brcs	.+52     	; 0xab70 <__divdi3+0x448>
    ab3c:	c4 16       	cp	r12, r20
    ab3e:	d5 06       	cpc	r13, r21
    ab40:	e6 06       	cpc	r14, r22
    ab42:	f7 06       	cpc	r15, r23
    ab44:	a8 f4       	brcc	.+42     	; 0xab70 <__divdi3+0x448>
    ab46:	0d a5       	lds	r16, 0x6d
    ab48:	1e a5       	lds	r17, 0x6e
    ab4a:	2f a5       	lds	r18, 0x6f
    ab4c:	38 a9       	sts	0x48, r19
    ab4e:	02 50       	subi	r16, 0x02	; 2
    ab50:	10 40       	sbci	r17, 0x00	; 0
    ab52:	20 40       	sbci	r18, 0x00	; 0
    ab54:	30 40       	sbci	r19, 0x00	; 0
    ab56:	09 a7       	lds	r16, 0x79
    ab58:	1a a7       	lds	r17, 0x7a
    ab5a:	2b a7       	lds	r18, 0x7b
    ab5c:	3c a7       	lds	r19, 0x7c
    ab5e:	c8 0c       	add	r12, r8
    ab60:	d9 1c       	adc	r13, r9
    ab62:	ea 1c       	adc	r14, r10
    ab64:	fb 1c       	adc	r15, r11
    ab66:	04 c0       	rjmp	.+8      	; 0xab70 <__divdi3+0x448>
    ab68:	09 a7       	lds	r16, 0x79
    ab6a:	1a a7       	lds	r17, 0x7a
    ab6c:	2b a7       	lds	r18, 0x7b
    ab6e:	3c a7       	lds	r19, 0x7c
    ab70:	c4 1a       	sub	r12, r20
    ab72:	d5 0a       	sbc	r13, r21
    ab74:	e6 0a       	sbc	r14, r22
    ab76:	f7 0a       	sbc	r15, r23
    ab78:	c7 01       	movw	r24, r14
    ab7a:	b6 01       	movw	r22, r12
    ab7c:	a3 01       	movw	r20, r6
    ab7e:	92 01       	movw	r18, r4
    ab80:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    ab84:	2d a7       	lds	r18, 0x7d
    ab86:	3e a7       	lds	r19, 0x7e
    ab88:	4f a7       	lds	r20, 0x7f
    ab8a:	58 ab       	sts	0x58, r21
    ab8c:	69 af       	sts	0x79, r22
    ab8e:	7a af       	sts	0x7a, r23
    ab90:	8b af       	sts	0x7b, r24
    ab92:	9c af       	sts	0x7c, r25
    ab94:	c7 01       	movw	r24, r14
    ab96:	b6 01       	movw	r22, r12
    ab98:	a3 01       	movw	r20, r6
    ab9a:	92 01       	movw	r18, r4
    ab9c:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    aba0:	ca 01       	movw	r24, r20
    aba2:	b9 01       	movw	r22, r18
    aba4:	29 a9       	sts	0x49, r18
    aba6:	3a a9       	sts	0x4a, r19
    aba8:	4b a9       	sts	0x4b, r20
    abaa:	5c a9       	sts	0x4c, r21
    abac:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    abb0:	6b 01       	movw	r12, r22
    abb2:	7c 01       	movw	r14, r24
    abb4:	49 ad       	sts	0x69, r20
    abb6:	5a ad       	sts	0x6a, r21
    abb8:	6b ad       	sts	0x6b, r22
    abba:	7c ad       	sts	0x6c, r23
    abbc:	9a 01       	movw	r18, r20
    abbe:	11 27       	eor	r17, r17
    abc0:	00 27       	eor	r16, r16
    abc2:	4d a9       	sts	0x4d, r20
    abc4:	5e a9       	sts	0x4e, r21
    abc6:	6f a9       	sts	0x4f, r22
    abc8:	78 ad       	sts	0x68, r23
    abca:	60 70       	andi	r22, 0x00	; 0
    abcc:	70 70       	andi	r23, 0x00	; 0
    abce:	04 2b       	or	r16, r20
    abd0:	15 2b       	or	r17, r21
    abd2:	26 2b       	or	r18, r22
    abd4:	37 2b       	or	r19, r23
    abd6:	8d a5       	lds	r24, 0x6d
    abd8:	9e a5       	lds	r25, 0x6e
    abda:	af a5       	lds	r26, 0x6f
    abdc:	b8 a9       	sts	0x48, r27
    abde:	0c 15       	cp	r16, r12
    abe0:	1d 05       	cpc	r17, r13
    abe2:	2e 05       	cpc	r18, r14
    abe4:	3f 05       	cpc	r19, r15
    abe6:	c0 f4       	brcc	.+48     	; 0xac18 <__divdi3+0x4f0>
    abe8:	01 97       	sbiw	r24, 0x01	; 1
    abea:	a1 09       	sbc	r26, r1
    abec:	b1 09       	sbc	r27, r1
    abee:	08 0d       	add	r16, r8
    abf0:	19 1d       	adc	r17, r9
    abf2:	2a 1d       	adc	r18, r10
    abf4:	3b 1d       	adc	r19, r11
    abf6:	08 15       	cp	r16, r8
    abf8:	19 05       	cpc	r17, r9
    abfa:	2a 05       	cpc	r18, r10
    abfc:	3b 05       	cpc	r19, r11
    abfe:	60 f0       	brcs	.+24     	; 0xac18 <__divdi3+0x4f0>
    ac00:	0c 15       	cp	r16, r12
    ac02:	1d 05       	cpc	r17, r13
    ac04:	2e 05       	cpc	r18, r14
    ac06:	3f 05       	cpc	r19, r15
    ac08:	38 f4       	brcc	.+14     	; 0xac18 <__divdi3+0x4f0>
    ac0a:	8d a5       	lds	r24, 0x6d
    ac0c:	9e a5       	lds	r25, 0x6e
    ac0e:	af a5       	lds	r26, 0x6f
    ac10:	b8 a9       	sts	0x48, r27
    ac12:	02 97       	sbiw	r24, 0x02	; 2
    ac14:	a1 09       	sbc	r26, r1
    ac16:	b1 09       	sbc	r27, r1
    ac18:	09 a5       	lds	r16, 0x69
    ac1a:	1a a5       	lds	r17, 0x6a
    ac1c:	2b a5       	lds	r18, 0x6b
    ac1e:	3c a5       	lds	r19, 0x6c
    ac20:	78 01       	movw	r14, r16
    ac22:	dd 24       	eor	r13, r13
    ac24:	cc 24       	eor	r12, r12
    ac26:	c8 2a       	or	r12, r24
    ac28:	d9 2a       	or	r13, r25
    ac2a:	ea 2a       	or	r14, r26
    ac2c:	fb 2a       	or	r15, r27
    ac2e:	b7 c4       	rjmp	.+2414   	; 0xb59e <__divdi3+0xe76>
    ac30:	81 14       	cp	r8, r1
    ac32:	91 04       	cpc	r9, r1
    ac34:	a1 04       	cpc	r10, r1
    ac36:	b1 04       	cpc	r11, r1
    ac38:	51 f4       	brne	.+20     	; 0xac4e <__divdi3+0x526>
    ac3a:	61 e0       	ldi	r22, 0x01	; 1
    ac3c:	70 e0       	ldi	r23, 0x00	; 0
    ac3e:	80 e0       	ldi	r24, 0x00	; 0
    ac40:	90 e0       	ldi	r25, 0x00	; 0
    ac42:	a5 01       	movw	r20, r10
    ac44:	94 01       	movw	r18, r8
    ac46:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    ac4a:	49 01       	movw	r8, r18
    ac4c:	5a 01       	movw	r10, r20
    ac4e:	10 e0       	ldi	r17, 0x00	; 0
    ac50:	81 16       	cp	r8, r17
    ac52:	10 e0       	ldi	r17, 0x00	; 0
    ac54:	91 06       	cpc	r9, r17
    ac56:	11 e0       	ldi	r17, 0x01	; 1
    ac58:	a1 06       	cpc	r10, r17
    ac5a:	10 e0       	ldi	r17, 0x00	; 0
    ac5c:	b1 06       	cpc	r11, r17
    ac5e:	58 f4       	brcc	.+22     	; 0xac76 <__divdi3+0x54e>
    ac60:	2f ef       	ldi	r18, 0xFF	; 255
    ac62:	82 16       	cp	r8, r18
    ac64:	91 04       	cpc	r9, r1
    ac66:	a1 04       	cpc	r10, r1
    ac68:	b1 04       	cpc	r11, r1
    ac6a:	09 f0       	breq	.+2      	; 0xac6e <__divdi3+0x546>
    ac6c:	90 f4       	brcc	.+36     	; 0xac92 <__divdi3+0x56a>
    ac6e:	80 e0       	ldi	r24, 0x00	; 0
    ac70:	90 e0       	ldi	r25, 0x00	; 0
    ac72:	dc 01       	movw	r26, r24
    ac74:	17 c0       	rjmp	.+46     	; 0xaca4 <__divdi3+0x57c>
    ac76:	30 e0       	ldi	r19, 0x00	; 0
    ac78:	83 16       	cp	r8, r19
    ac7a:	30 e0       	ldi	r19, 0x00	; 0
    ac7c:	93 06       	cpc	r9, r19
    ac7e:	30 e0       	ldi	r19, 0x00	; 0
    ac80:	a3 06       	cpc	r10, r19
    ac82:	31 e0       	ldi	r19, 0x01	; 1
    ac84:	b3 06       	cpc	r11, r19
    ac86:	50 f4       	brcc	.+20     	; 0xac9c <__divdi3+0x574>
    ac88:	80 e1       	ldi	r24, 0x10	; 16
    ac8a:	90 e0       	ldi	r25, 0x00	; 0
    ac8c:	a0 e0       	ldi	r26, 0x00	; 0
    ac8e:	b0 e0       	ldi	r27, 0x00	; 0
    ac90:	09 c0       	rjmp	.+18     	; 0xaca4 <__divdi3+0x57c>
    ac92:	88 e0       	ldi	r24, 0x08	; 8
    ac94:	90 e0       	ldi	r25, 0x00	; 0
    ac96:	a0 e0       	ldi	r26, 0x00	; 0
    ac98:	b0 e0       	ldi	r27, 0x00	; 0
    ac9a:	04 c0       	rjmp	.+8      	; 0xaca4 <__divdi3+0x57c>
    ac9c:	88 e1       	ldi	r24, 0x18	; 24
    ac9e:	90 e0       	ldi	r25, 0x00	; 0
    aca0:	a0 e0       	ldi	r26, 0x00	; 0
    aca2:	b0 e0       	ldi	r27, 0x00	; 0
    aca4:	b5 01       	movw	r22, r10
    aca6:	a4 01       	movw	r20, r8
    aca8:	08 2e       	mov	r0, r24
    acaa:	04 c0       	rjmp	.+8      	; 0xacb4 <__divdi3+0x58c>
    acac:	76 95       	lsr	r23
    acae:	67 95       	ror	r22
    acb0:	57 95       	ror	r21
    acb2:	47 95       	ror	r20
    acb4:	0a 94       	dec	r0
    acb6:	d2 f7       	brpl	.-12     	; 0xacac <__divdi3+0x584>
    acb8:	fa 01       	movw	r30, r20
    acba:	ea 5d       	subi	r30, 0xDA	; 218
    acbc:	ff 4d       	sbci	r31, 0xDF	; 223
    acbe:	20 81       	ld	r18, Z
    acc0:	ac 01       	movw	r20, r24
    acc2:	bd 01       	movw	r22, r26
    acc4:	42 0f       	add	r20, r18
    acc6:	51 1d       	adc	r21, r1
    acc8:	61 1d       	adc	r22, r1
    acca:	71 1d       	adc	r23, r1
    accc:	80 e2       	ldi	r24, 0x20	; 32
    acce:	90 e0       	ldi	r25, 0x00	; 0
    acd0:	a0 e0       	ldi	r26, 0x00	; 0
    acd2:	b0 e0       	ldi	r27, 0x00	; 0
    acd4:	84 1b       	sub	r24, r20
    acd6:	95 0b       	sbc	r25, r21
    acd8:	a6 0b       	sbc	r26, r22
    acda:	b7 0b       	sbc	r27, r23
    acdc:	51 f4       	brne	.+20     	; 0xacf2 <__divdi3+0x5ca>
    acde:	c8 18       	sub	r12, r8
    ace0:	d9 08       	sbc	r13, r9
    ace2:	ea 08       	sbc	r14, r10
    ace4:	fb 08       	sbc	r15, r11
    ace6:	f1 e0       	ldi	r31, 0x01	; 1
    ace8:	4f 2e       	mov	r4, r31
    acea:	51 2c       	mov	r5, r1
    acec:	61 2c       	mov	r6, r1
    acee:	71 2c       	mov	r7, r1
    acf0:	28 c1       	rjmp	.+592    	; 0xaf42 <__divdi3+0x81a>
    acf2:	08 2e       	mov	r0, r24
    acf4:	04 c0       	rjmp	.+8      	; 0xacfe <__divdi3+0x5d6>
    acf6:	88 0c       	add	r8, r8
    acf8:	99 1c       	adc	r9, r9
    acfa:	aa 1c       	adc	r10, r10
    acfc:	bb 1c       	adc	r11, r11
    acfe:	0a 94       	dec	r0
    ad00:	d2 f7       	brpl	.-12     	; 0xacf6 <__divdi3+0x5ce>
    ad02:	97 01       	movw	r18, r14
    ad04:	86 01       	movw	r16, r12
    ad06:	04 2e       	mov	r0, r20
    ad08:	04 c0       	rjmp	.+8      	; 0xad12 <__divdi3+0x5ea>
    ad0a:	36 95       	lsr	r19
    ad0c:	27 95       	ror	r18
    ad0e:	17 95       	ror	r17
    ad10:	07 95       	ror	r16
    ad12:	0a 94       	dec	r0
    ad14:	d2 f7       	brpl	.-12     	; 0xad0a <__divdi3+0x5e2>
    ad16:	09 ab       	sts	0x59, r16
    ad18:	1a ab       	sts	0x5a, r17
    ad1a:	2b ab       	sts	0x5b, r18
    ad1c:	3c ab       	sts	0x5c, r19
    ad1e:	97 01       	movw	r18, r14
    ad20:	86 01       	movw	r16, r12
    ad22:	08 2e       	mov	r0, r24
    ad24:	04 c0       	rjmp	.+8      	; 0xad2e <__divdi3+0x606>
    ad26:	00 0f       	add	r16, r16
    ad28:	11 1f       	adc	r17, r17
    ad2a:	22 1f       	adc	r18, r18
    ad2c:	33 1f       	adc	r19, r19
    ad2e:	0a 94       	dec	r0
    ad30:	d2 f7       	brpl	.-12     	; 0xad26 <__divdi3+0x5fe>
    ad32:	0d a7       	lds	r16, 0x7d
    ad34:	1e a7       	lds	r17, 0x7e
    ad36:	2f a7       	lds	r18, 0x7f
    ad38:	38 ab       	sts	0x58, r19
    ad3a:	ed a8       	sts	0x8d, r30
    ad3c:	fe a8       	sts	0x8e, r31
    ad3e:	0f a9       	sts	0x4f, r16
    ad40:	18 ad       	sts	0x68, r17
    ad42:	04 c0       	rjmp	.+8      	; 0xad4c <__divdi3+0x624>
    ad44:	16 95       	lsr	r17
    ad46:	07 95       	ror	r16
    ad48:	f7 94       	ror	r15
    ad4a:	e7 94       	ror	r14
    ad4c:	4a 95       	dec	r20
    ad4e:	d2 f7       	brpl	.-12     	; 0xad44 <__divdi3+0x61c>
    ad50:	b8 01       	movw	r22, r16
    ad52:	a7 01       	movw	r20, r14
    ad54:	0d a5       	lds	r16, 0x6d
    ad56:	1e a5       	lds	r17, 0x6e
    ad58:	2f a5       	lds	r18, 0x6f
    ad5a:	38 a9       	sts	0x48, r19
    ad5c:	04 2b       	or	r16, r20
    ad5e:	15 2b       	or	r17, r21
    ad60:	26 2b       	or	r18, r22
    ad62:	37 2b       	or	r19, r23
    ad64:	0d a7       	lds	r16, 0x7d
    ad66:	1e a7       	lds	r17, 0x7e
    ad68:	2f a7       	lds	r18, 0x7f
    ad6a:	38 ab       	sts	0x58, r19
    ad6c:	ed a8       	sts	0x8d, r30
    ad6e:	fe a8       	sts	0x8e, r31
    ad70:	0f a9       	sts	0x4f, r16
    ad72:	18 ad       	sts	0x68, r17
    ad74:	04 c0       	rjmp	.+8      	; 0xad7e <__divdi3+0x656>
    ad76:	ee 0c       	add	r14, r14
    ad78:	ff 1c       	adc	r15, r15
    ad7a:	00 1f       	adc	r16, r16
    ad7c:	11 1f       	adc	r17, r17
    ad7e:	8a 95       	dec	r24
    ad80:	d2 f7       	brpl	.-12     	; 0xad76 <__divdi3+0x64e>
    ad82:	ed aa       	sts	0x9d, r30
    ad84:	fe aa       	sts	0x9e, r31
    ad86:	0f ab       	sts	0x5f, r16
    ad88:	18 af       	sts	0x78, r17
    ad8a:	25 01       	movw	r4, r10
    ad8c:	66 24       	eor	r6, r6
    ad8e:	77 24       	eor	r7, r7
    ad90:	95 01       	movw	r18, r10
    ad92:	84 01       	movw	r16, r8
    ad94:	20 70       	andi	r18, 0x00	; 0
    ad96:	30 70       	andi	r19, 0x00	; 0
    ad98:	09 af       	sts	0x79, r16
    ad9a:	1a af       	sts	0x7a, r17
    ad9c:	2b af       	sts	0x7b, r18
    ad9e:	3c af       	sts	0x7c, r19
    ada0:	69 a9       	sts	0x49, r22
    ada2:	7a a9       	sts	0x4a, r23
    ada4:	8b a9       	sts	0x4b, r24
    ada6:	9c a9       	sts	0x4c, r25
    ada8:	a3 01       	movw	r20, r6
    adaa:	92 01       	movw	r18, r4
    adac:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    adb0:	29 a7       	lds	r18, 0x79
    adb2:	3a a7       	lds	r19, 0x7a
    adb4:	4b a7       	lds	r20, 0x7b
    adb6:	5c a7       	lds	r21, 0x7c
    adb8:	6b 01       	movw	r12, r22
    adba:	7c 01       	movw	r14, r24
    adbc:	69 a9       	sts	0x49, r22
    adbe:	7a a9       	sts	0x4a, r23
    adc0:	8b a9       	sts	0x4b, r24
    adc2:	9c a9       	sts	0x4c, r25
    adc4:	a3 01       	movw	r20, r6
    adc6:	92 01       	movw	r18, r4
    adc8:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    adcc:	ca 01       	movw	r24, r20
    adce:	b9 01       	movw	r22, r18
    add0:	29 ad       	sts	0x69, r18
    add2:	3a ad       	sts	0x6a, r19
    add4:	4b ad       	sts	0x6b, r20
    add6:	5c ad       	sts	0x6c, r21
    add8:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    addc:	ab 01       	movw	r20, r22
    adde:	bc 01       	movw	r22, r24
    ade0:	76 01       	movw	r14, r12
    ade2:	dd 24       	eor	r13, r13
    ade4:	cc 24       	eor	r12, r12
    ade6:	0d a5       	lds	r16, 0x6d
    ade8:	1e a5       	lds	r17, 0x6e
    adea:	2f a5       	lds	r18, 0x6f
    adec:	38 a9       	sts	0x48, r19
    adee:	c9 01       	movw	r24, r18
    adf0:	aa 27       	eor	r26, r26
    adf2:	bb 27       	eor	r27, r27
    adf4:	c8 2a       	or	r12, r24
    adf6:	d9 2a       	or	r13, r25
    adf8:	ea 2a       	or	r14, r26
    adfa:	fb 2a       	or	r15, r27
    adfc:	09 a5       	lds	r16, 0x69
    adfe:	1a a5       	lds	r17, 0x6a
    ae00:	2b a5       	lds	r18, 0x6b
    ae02:	3c a5       	lds	r19, 0x6c
    ae04:	c4 16       	cp	r12, r20
    ae06:	d5 06       	cpc	r13, r21
    ae08:	e6 06       	cpc	r14, r22
    ae0a:	f7 06       	cpc	r15, r23
    ae0c:	38 f5       	brcc	.+78     	; 0xae5c <__divdi3+0x734>
    ae0e:	01 50       	subi	r16, 0x01	; 1
    ae10:	10 40       	sbci	r17, 0x00	; 0
    ae12:	20 40       	sbci	r18, 0x00	; 0
    ae14:	30 40       	sbci	r19, 0x00	; 0
    ae16:	09 ab       	sts	0x59, r16
    ae18:	1a ab       	sts	0x5a, r17
    ae1a:	2b ab       	sts	0x5b, r18
    ae1c:	3c ab       	sts	0x5c, r19
    ae1e:	c8 0c       	add	r12, r8
    ae20:	d9 1c       	adc	r13, r9
    ae22:	ea 1c       	adc	r14, r10
    ae24:	fb 1c       	adc	r15, r11
    ae26:	c8 14       	cp	r12, r8
    ae28:	d9 04       	cpc	r13, r9
    ae2a:	ea 04       	cpc	r14, r10
    ae2c:	fb 04       	cpc	r15, r11
    ae2e:	d0 f0       	brcs	.+52     	; 0xae64 <__divdi3+0x73c>
    ae30:	c4 16       	cp	r12, r20
    ae32:	d5 06       	cpc	r13, r21
    ae34:	e6 06       	cpc	r14, r22
    ae36:	f7 06       	cpc	r15, r23
    ae38:	a8 f4       	brcc	.+42     	; 0xae64 <__divdi3+0x73c>
    ae3a:	09 a5       	lds	r16, 0x69
    ae3c:	1a a5       	lds	r17, 0x6a
    ae3e:	2b a5       	lds	r18, 0x6b
    ae40:	3c a5       	lds	r19, 0x6c
    ae42:	02 50       	subi	r16, 0x02	; 2
    ae44:	10 40       	sbci	r17, 0x00	; 0
    ae46:	20 40       	sbci	r18, 0x00	; 0
    ae48:	30 40       	sbci	r19, 0x00	; 0
    ae4a:	09 ab       	sts	0x59, r16
    ae4c:	1a ab       	sts	0x5a, r17
    ae4e:	2b ab       	sts	0x5b, r18
    ae50:	3c ab       	sts	0x5c, r19
    ae52:	c8 0c       	add	r12, r8
    ae54:	d9 1c       	adc	r13, r9
    ae56:	ea 1c       	adc	r14, r10
    ae58:	fb 1c       	adc	r15, r11
    ae5a:	04 c0       	rjmp	.+8      	; 0xae64 <__divdi3+0x73c>
    ae5c:	09 ab       	sts	0x59, r16
    ae5e:	1a ab       	sts	0x5a, r17
    ae60:	2b ab       	sts	0x5b, r18
    ae62:	3c ab       	sts	0x5c, r19
    ae64:	c4 1a       	sub	r12, r20
    ae66:	d5 0a       	sbc	r13, r21
    ae68:	e6 0a       	sbc	r14, r22
    ae6a:	f7 0a       	sbc	r15, r23
    ae6c:	c7 01       	movw	r24, r14
    ae6e:	b6 01       	movw	r22, r12
    ae70:	a3 01       	movw	r20, r6
    ae72:	92 01       	movw	r18, r4
    ae74:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    ae78:	29 a7       	lds	r18, 0x79
    ae7a:	3a a7       	lds	r19, 0x7a
    ae7c:	4b a7       	lds	r20, 0x7b
    ae7e:	5c a7       	lds	r21, 0x7c
    ae80:	21 96       	adiw	r28, 0x01	; 1
    ae82:	6c af       	sts	0x7c, r22
    ae84:	7d af       	sts	0x7d, r23
    ae86:	8e af       	sts	0x7e, r24
    ae88:	9f af       	sts	0x7f, r25
    ae8a:	21 97       	sbiw	r28, 0x01	; 1
    ae8c:	c7 01       	movw	r24, r14
    ae8e:	b6 01       	movw	r22, r12
    ae90:	a3 01       	movw	r20, r6
    ae92:	92 01       	movw	r18, r4
    ae94:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    ae98:	ca 01       	movw	r24, r20
    ae9a:	b9 01       	movw	r22, r18
    ae9c:	29 ad       	sts	0x69, r18
    ae9e:	3a ad       	sts	0x6a, r19
    aea0:	4b ad       	sts	0x6b, r20
    aea2:	5c ad       	sts	0x6c, r21
    aea4:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    aea8:	8b 01       	movw	r16, r22
    aeaa:	9c 01       	movw	r18, r24
    aeac:	21 96       	adiw	r28, 0x01	; 1
    aeae:	4c ad       	sts	0x6c, r20
    aeb0:	5d ad       	sts	0x6d, r21
    aeb2:	6e ad       	sts	0x6e, r22
    aeb4:	7f ad       	sts	0x6f, r23
    aeb6:	21 97       	sbiw	r28, 0x01	; 1
    aeb8:	da 01       	movw	r26, r20
    aeba:	99 27       	eor	r25, r25
    aebc:	88 27       	eor	r24, r24
    aebe:	4d a5       	lds	r20, 0x6d
    aec0:	5e a5       	lds	r21, 0x6e
    aec2:	6f a5       	lds	r22, 0x6f
    aec4:	78 a9       	sts	0x48, r23
    aec6:	60 70       	andi	r22, 0x00	; 0
    aec8:	70 70       	andi	r23, 0x00	; 0
    aeca:	84 2b       	or	r24, r20
    aecc:	95 2b       	or	r25, r21
    aece:	a6 2b       	or	r26, r22
    aed0:	b7 2b       	or	r27, r23
    aed2:	49 a5       	lds	r20, 0x69
    aed4:	5a a5       	lds	r21, 0x6a
    aed6:	6b a5       	lds	r22, 0x6b
    aed8:	7c a5       	lds	r23, 0x6c
    aeda:	80 17       	cp	r24, r16
    aedc:	91 07       	cpc	r25, r17
    aede:	a2 07       	cpc	r26, r18
    aee0:	b3 07       	cpc	r27, r19
    aee2:	f0 f4       	brcc	.+60     	; 0xaf20 <__divdi3+0x7f8>
    aee4:	41 50       	subi	r20, 0x01	; 1
    aee6:	50 40       	sbci	r21, 0x00	; 0
    aee8:	60 40       	sbci	r22, 0x00	; 0
    aeea:	70 40       	sbci	r23, 0x00	; 0
    aeec:	88 0d       	add	r24, r8
    aeee:	99 1d       	adc	r25, r9
    aef0:	aa 1d       	adc	r26, r10
    aef2:	bb 1d       	adc	r27, r11
    aef4:	88 15       	cp	r24, r8
    aef6:	99 05       	cpc	r25, r9
    aef8:	aa 05       	cpc	r26, r10
    aefa:	bb 05       	cpc	r27, r11
    aefc:	88 f0       	brcs	.+34     	; 0xaf20 <__divdi3+0x7f8>
    aefe:	80 17       	cp	r24, r16
    af00:	91 07       	cpc	r25, r17
    af02:	a2 07       	cpc	r26, r18
    af04:	b3 07       	cpc	r27, r19
    af06:	60 f4       	brcc	.+24     	; 0xaf20 <__divdi3+0x7f8>
    af08:	49 a5       	lds	r20, 0x69
    af0a:	5a a5       	lds	r21, 0x6a
    af0c:	6b a5       	lds	r22, 0x6b
    af0e:	7c a5       	lds	r23, 0x6c
    af10:	42 50       	subi	r20, 0x02	; 2
    af12:	50 40       	sbci	r21, 0x00	; 0
    af14:	60 40       	sbci	r22, 0x00	; 0
    af16:	70 40       	sbci	r23, 0x00	; 0
    af18:	88 0d       	add	r24, r8
    af1a:	99 1d       	adc	r25, r9
    af1c:	aa 1d       	adc	r26, r10
    af1e:	bb 1d       	adc	r27, r11
    af20:	6c 01       	movw	r12, r24
    af22:	7d 01       	movw	r14, r26
    af24:	c0 1a       	sub	r12, r16
    af26:	d1 0a       	sbc	r13, r17
    af28:	e2 0a       	sbc	r14, r18
    af2a:	f3 0a       	sbc	r15, r19
    af2c:	09 a9       	sts	0x49, r16
    af2e:	1a a9       	sts	0x4a, r17
    af30:	2b a9       	sts	0x4b, r18
    af32:	3c a9       	sts	0x4c, r19
    af34:	38 01       	movw	r6, r16
    af36:	55 24       	eor	r5, r5
    af38:	44 24       	eor	r4, r4
    af3a:	44 2a       	or	r4, r20
    af3c:	55 2a       	or	r5, r21
    af3e:	66 2a       	or	r6, r22
    af40:	77 2a       	or	r7, r23
    af42:	85 01       	movw	r16, r10
    af44:	22 27       	eor	r18, r18
    af46:	33 27       	eor	r19, r19
    af48:	0d a7       	lds	r16, 0x7d
    af4a:	1e a7       	lds	r17, 0x7e
    af4c:	2f a7       	lds	r18, 0x7f
    af4e:	38 ab       	sts	0x58, r19
    af50:	95 01       	movw	r18, r10
    af52:	84 01       	movw	r16, r8
    af54:	20 70       	andi	r18, 0x00	; 0
    af56:	30 70       	andi	r19, 0x00	; 0
    af58:	09 af       	sts	0x79, r16
    af5a:	1a af       	sts	0x7a, r17
    af5c:	2b af       	sts	0x7b, r18
    af5e:	3c af       	sts	0x7c, r19
    af60:	c7 01       	movw	r24, r14
    af62:	b6 01       	movw	r22, r12
    af64:	2d a5       	lds	r18, 0x6d
    af66:	3e a5       	lds	r19, 0x6e
    af68:	4f a5       	lds	r20, 0x6f
    af6a:	58 a9       	sts	0x48, r21
    af6c:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    af70:	29 a7       	lds	r18, 0x79
    af72:	3a a7       	lds	r19, 0x7a
    af74:	4b a7       	lds	r20, 0x7b
    af76:	5c a7       	lds	r21, 0x7c
    af78:	69 ab       	sts	0x59, r22
    af7a:	7a ab       	sts	0x5a, r23
    af7c:	8b ab       	sts	0x5b, r24
    af7e:	9c ab       	sts	0x5c, r25
    af80:	c7 01       	movw	r24, r14
    af82:	b6 01       	movw	r22, r12
    af84:	2d a5       	lds	r18, 0x6d
    af86:	3e a5       	lds	r19, 0x6e
    af88:	4f a5       	lds	r20, 0x6f
    af8a:	58 a9       	sts	0x48, r21
    af8c:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    af90:	ca 01       	movw	r24, r20
    af92:	b9 01       	movw	r22, r18
    af94:	29 ad       	sts	0x69, r18
    af96:	3a ad       	sts	0x6a, r19
    af98:	4b ad       	sts	0x6b, r20
    af9a:	5c ad       	sts	0x6c, r21
    af9c:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    afa0:	ab 01       	movw	r20, r22
    afa2:	bc 01       	movw	r22, r24
    afa4:	09 a9       	sts	0x49, r16
    afa6:	1a a9       	sts	0x4a, r17
    afa8:	2b a9       	sts	0x4b, r18
    afaa:	3c a9       	sts	0x4c, r19
    afac:	78 01       	movw	r14, r16
    afae:	dd 24       	eor	r13, r13
    afb0:	cc 24       	eor	r12, r12
    afb2:	0d a9       	sts	0x4d, r16
    afb4:	1e a9       	sts	0x4e, r17
    afb6:	2f a9       	sts	0x4f, r18
    afb8:	38 ad       	sts	0x68, r19
    afba:	c9 01       	movw	r24, r18
    afbc:	aa 27       	eor	r26, r26
    afbe:	bb 27       	eor	r27, r27
    afc0:	c8 2a       	or	r12, r24
    afc2:	d9 2a       	or	r13, r25
    afc4:	ea 2a       	or	r14, r26
    afc6:	fb 2a       	or	r15, r27
    afc8:	09 a5       	lds	r16, 0x69
    afca:	1a a5       	lds	r17, 0x6a
    afcc:	2b a5       	lds	r18, 0x6b
    afce:	3c a5       	lds	r19, 0x6c
    afd0:	c4 16       	cp	r12, r20
    afd2:	d5 06       	cpc	r13, r21
    afd4:	e6 06       	cpc	r14, r22
    afd6:	f7 06       	cpc	r15, r23
    afd8:	38 f5       	brcc	.+78     	; 0xb028 <__divdi3+0x900>
    afda:	01 50       	subi	r16, 0x01	; 1
    afdc:	10 40       	sbci	r17, 0x00	; 0
    afde:	20 40       	sbci	r18, 0x00	; 0
    afe0:	30 40       	sbci	r19, 0x00	; 0
    afe2:	09 ab       	sts	0x59, r16
    afe4:	1a ab       	sts	0x5a, r17
    afe6:	2b ab       	sts	0x5b, r18
    afe8:	3c ab       	sts	0x5c, r19
    afea:	c8 0c       	add	r12, r8
    afec:	d9 1c       	adc	r13, r9
    afee:	ea 1c       	adc	r14, r10
    aff0:	fb 1c       	adc	r15, r11
    aff2:	c8 14       	cp	r12, r8
    aff4:	d9 04       	cpc	r13, r9
    aff6:	ea 04       	cpc	r14, r10
    aff8:	fb 04       	cpc	r15, r11
    affa:	d0 f0       	brcs	.+52     	; 0xb030 <__divdi3+0x908>
    affc:	c4 16       	cp	r12, r20
    affe:	d5 06       	cpc	r13, r21
    b000:	e6 06       	cpc	r14, r22
    b002:	f7 06       	cpc	r15, r23
    b004:	a8 f4       	brcc	.+42     	; 0xb030 <__divdi3+0x908>
    b006:	09 a5       	lds	r16, 0x69
    b008:	1a a5       	lds	r17, 0x6a
    b00a:	2b a5       	lds	r18, 0x6b
    b00c:	3c a5       	lds	r19, 0x6c
    b00e:	02 50       	subi	r16, 0x02	; 2
    b010:	10 40       	sbci	r17, 0x00	; 0
    b012:	20 40       	sbci	r18, 0x00	; 0
    b014:	30 40       	sbci	r19, 0x00	; 0
    b016:	09 ab       	sts	0x59, r16
    b018:	1a ab       	sts	0x5a, r17
    b01a:	2b ab       	sts	0x5b, r18
    b01c:	3c ab       	sts	0x5c, r19
    b01e:	c8 0c       	add	r12, r8
    b020:	d9 1c       	adc	r13, r9
    b022:	ea 1c       	adc	r14, r10
    b024:	fb 1c       	adc	r15, r11
    b026:	04 c0       	rjmp	.+8      	; 0xb030 <__divdi3+0x908>
    b028:	09 ab       	sts	0x59, r16
    b02a:	1a ab       	sts	0x5a, r17
    b02c:	2b ab       	sts	0x5b, r18
    b02e:	3c ab       	sts	0x5c, r19
    b030:	c4 1a       	sub	r12, r20
    b032:	d5 0a       	sbc	r13, r21
    b034:	e6 0a       	sbc	r14, r22
    b036:	f7 0a       	sbc	r15, r23
    b038:	c7 01       	movw	r24, r14
    b03a:	b6 01       	movw	r22, r12
    b03c:	2d a5       	lds	r18, 0x6d
    b03e:	3e a5       	lds	r19, 0x6e
    b040:	4f a5       	lds	r20, 0x6f
    b042:	58 a9       	sts	0x48, r21
    b044:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    b048:	29 a7       	lds	r18, 0x79
    b04a:	3a a7       	lds	r19, 0x7a
    b04c:	4b a7       	lds	r20, 0x7b
    b04e:	5c a7       	lds	r21, 0x7c
    b050:	21 96       	adiw	r28, 0x01	; 1
    b052:	6c af       	sts	0x7c, r22
    b054:	7d af       	sts	0x7d, r23
    b056:	8e af       	sts	0x7e, r24
    b058:	9f af       	sts	0x7f, r25
    b05a:	21 97       	sbiw	r28, 0x01	; 1
    b05c:	c7 01       	movw	r24, r14
    b05e:	b6 01       	movw	r22, r12
    b060:	2d a5       	lds	r18, 0x6d
    b062:	3e a5       	lds	r19, 0x6e
    b064:	4f a5       	lds	r20, 0x6f
    b066:	58 a9       	sts	0x48, r21
    b068:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    b06c:	ca 01       	movw	r24, r20
    b06e:	b9 01       	movw	r22, r18
    b070:	29 ad       	sts	0x69, r18
    b072:	3a ad       	sts	0x6a, r19
    b074:	4b ad       	sts	0x6b, r20
    b076:	5c ad       	sts	0x6c, r21
    b078:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    b07c:	8b 01       	movw	r16, r22
    b07e:	9c 01       	movw	r18, r24
    b080:	21 96       	adiw	r28, 0x01	; 1
    b082:	4c ad       	sts	0x6c, r20
    b084:	5d ad       	sts	0x6d, r21
    b086:	6e ad       	sts	0x6e, r22
    b088:	7f ad       	sts	0x6f, r23
    b08a:	21 97       	sbiw	r28, 0x01	; 1
    b08c:	da 01       	movw	r26, r20
    b08e:	99 27       	eor	r25, r25
    b090:	88 27       	eor	r24, r24
    b092:	4d a9       	sts	0x4d, r20
    b094:	5e a9       	sts	0x4e, r21
    b096:	6f a9       	sts	0x4f, r22
    b098:	78 ad       	sts	0x68, r23
    b09a:	60 70       	andi	r22, 0x00	; 0
    b09c:	70 70       	andi	r23, 0x00	; 0
    b09e:	84 2b       	or	r24, r20
    b0a0:	95 2b       	or	r25, r21
    b0a2:	a6 2b       	or	r26, r22
    b0a4:	b7 2b       	or	r27, r23
    b0a6:	49 a5       	lds	r20, 0x69
    b0a8:	5a a5       	lds	r21, 0x6a
    b0aa:	6b a5       	lds	r22, 0x6b
    b0ac:	7c a5       	lds	r23, 0x6c
    b0ae:	80 17       	cp	r24, r16
    b0b0:	91 07       	cpc	r25, r17
    b0b2:	a2 07       	cpc	r26, r18
    b0b4:	b3 07       	cpc	r27, r19
    b0b6:	d0 f4       	brcc	.+52     	; 0xb0ec <__divdi3+0x9c4>
    b0b8:	41 50       	subi	r20, 0x01	; 1
    b0ba:	50 40       	sbci	r21, 0x00	; 0
    b0bc:	60 40       	sbci	r22, 0x00	; 0
    b0be:	70 40       	sbci	r23, 0x00	; 0
    b0c0:	88 0d       	add	r24, r8
    b0c2:	99 1d       	adc	r25, r9
    b0c4:	aa 1d       	adc	r26, r10
    b0c6:	bb 1d       	adc	r27, r11
    b0c8:	88 15       	cp	r24, r8
    b0ca:	99 05       	cpc	r25, r9
    b0cc:	aa 05       	cpc	r26, r10
    b0ce:	bb 05       	cpc	r27, r11
    b0d0:	68 f0       	brcs	.+26     	; 0xb0ec <__divdi3+0x9c4>
    b0d2:	80 17       	cp	r24, r16
    b0d4:	91 07       	cpc	r25, r17
    b0d6:	a2 07       	cpc	r26, r18
    b0d8:	b3 07       	cpc	r27, r19
    b0da:	40 f4       	brcc	.+16     	; 0xb0ec <__divdi3+0x9c4>
    b0dc:	49 a5       	lds	r20, 0x69
    b0de:	5a a5       	lds	r21, 0x6a
    b0e0:	6b a5       	lds	r22, 0x6b
    b0e2:	7c a5       	lds	r23, 0x6c
    b0e4:	42 50       	subi	r20, 0x02	; 2
    b0e6:	50 40       	sbci	r21, 0x00	; 0
    b0e8:	60 40       	sbci	r22, 0x00	; 0
    b0ea:	70 40       	sbci	r23, 0x00	; 0
    b0ec:	09 a9       	sts	0x49, r16
    b0ee:	1a a9       	sts	0x4a, r17
    b0f0:	2b a9       	sts	0x4b, r18
    b0f2:	3c a9       	sts	0x4c, r19
    b0f4:	78 01       	movw	r14, r16
    b0f6:	dd 24       	eor	r13, r13
    b0f8:	cc 24       	eor	r12, r12
    b0fa:	c4 2a       	or	r12, r20
    b0fc:	d5 2a       	or	r13, r21
    b0fe:	e6 2a       	or	r14, r22
    b100:	f7 2a       	or	r15, r23
    b102:	50 c2       	rjmp	.+1184   	; 0xb5a4 <__divdi3+0xe7c>
    b104:	c8 16       	cp	r12, r24
    b106:	d9 06       	cpc	r13, r25
    b108:	ea 06       	cpc	r14, r26
    b10a:	fb 06       	cpc	r15, r27
    b10c:	08 f4       	brcc	.+2      	; 0xb110 <__divdi3+0x9e8>
    b10e:	37 c2       	rjmp	.+1134   	; 0xb57e <__divdi3+0xe56>
    b110:	80 30       	cpi	r24, 0x00	; 0
    b112:	10 e0       	ldi	r17, 0x00	; 0
    b114:	91 07       	cpc	r25, r17
    b116:	11 e0       	ldi	r17, 0x01	; 1
    b118:	a1 07       	cpc	r26, r17
    b11a:	10 e0       	ldi	r17, 0x00	; 0
    b11c:	b1 07       	cpc	r27, r17
    b11e:	50 f4       	brcc	.+20     	; 0xb134 <__divdi3+0xa0c>
    b120:	8f 3f       	cpi	r24, 0xFF	; 255
    b122:	91 05       	cpc	r25, r1
    b124:	a1 05       	cpc	r26, r1
    b126:	b1 05       	cpc	r27, r1
    b128:	09 f0       	breq	.+2      	; 0xb12c <__divdi3+0xa04>
    b12a:	88 f4       	brcc	.+34     	; 0xb14e <__divdi3+0xa26>
    b12c:	00 e0       	ldi	r16, 0x00	; 0
    b12e:	10 e0       	ldi	r17, 0x00	; 0
    b130:	98 01       	movw	r18, r16
    b132:	16 c0       	rjmp	.+44     	; 0xb160 <__divdi3+0xa38>
    b134:	80 30       	cpi	r24, 0x00	; 0
    b136:	20 e0       	ldi	r18, 0x00	; 0
    b138:	92 07       	cpc	r25, r18
    b13a:	20 e0       	ldi	r18, 0x00	; 0
    b13c:	a2 07       	cpc	r26, r18
    b13e:	21 e0       	ldi	r18, 0x01	; 1
    b140:	b2 07       	cpc	r27, r18
    b142:	50 f4       	brcc	.+20     	; 0xb158 <__divdi3+0xa30>
    b144:	00 e1       	ldi	r16, 0x10	; 16
    b146:	10 e0       	ldi	r17, 0x00	; 0
    b148:	20 e0       	ldi	r18, 0x00	; 0
    b14a:	30 e0       	ldi	r19, 0x00	; 0
    b14c:	09 c0       	rjmp	.+18     	; 0xb160 <__divdi3+0xa38>
    b14e:	08 e0       	ldi	r16, 0x08	; 8
    b150:	10 e0       	ldi	r17, 0x00	; 0
    b152:	20 e0       	ldi	r18, 0x00	; 0
    b154:	30 e0       	ldi	r19, 0x00	; 0
    b156:	04 c0       	rjmp	.+8      	; 0xb160 <__divdi3+0xa38>
    b158:	08 e1       	ldi	r16, 0x18	; 24
    b15a:	10 e0       	ldi	r17, 0x00	; 0
    b15c:	20 e0       	ldi	r18, 0x00	; 0
    b15e:	30 e0       	ldi	r19, 0x00	; 0
    b160:	ac 01       	movw	r20, r24
    b162:	bd 01       	movw	r22, r26
    b164:	00 2e       	mov	r0, r16
    b166:	04 c0       	rjmp	.+8      	; 0xb170 <__divdi3+0xa48>
    b168:	76 95       	lsr	r23
    b16a:	67 95       	ror	r22
    b16c:	57 95       	ror	r21
    b16e:	47 95       	ror	r20
    b170:	0a 94       	dec	r0
    b172:	d2 f7       	brpl	.-12     	; 0xb168 <__divdi3+0xa40>
    b174:	fa 01       	movw	r30, r20
    b176:	ea 5d       	subi	r30, 0xDA	; 218
    b178:	ff 4d       	sbci	r31, 0xDF	; 223
    b17a:	40 81       	ld	r20, Z
    b17c:	04 0f       	add	r16, r20
    b17e:	11 1d       	adc	r17, r1
    b180:	21 1d       	adc	r18, r1
    b182:	31 1d       	adc	r19, r1
    b184:	40 e2       	ldi	r20, 0x20	; 32
    b186:	50 e0       	ldi	r21, 0x00	; 0
    b188:	60 e0       	ldi	r22, 0x00	; 0
    b18a:	70 e0       	ldi	r23, 0x00	; 0
    b18c:	40 1b       	sub	r20, r16
    b18e:	51 0b       	sbc	r21, r17
    b190:	62 0b       	sbc	r22, r18
    b192:	73 0b       	sbc	r23, r19
    b194:	a1 f4       	brne	.+40     	; 0xb1be <__divdi3+0xa96>
    b196:	8c 15       	cp	r24, r12
    b198:	9d 05       	cpc	r25, r13
    b19a:	ae 05       	cpc	r26, r14
    b19c:	bf 05       	cpc	r27, r15
    b19e:	08 f4       	brcc	.+2      	; 0xb1a2 <__divdi3+0xa7a>
    b1a0:	f5 c1       	rjmp	.+1002   	; 0xb58c <__divdi3+0xe64>
    b1a2:	ed a8       	sts	0x8d, r30
    b1a4:	fe a8       	sts	0x8e, r31
    b1a6:	0f a9       	sts	0x4f, r16
    b1a8:	18 ad       	sts	0x68, r17
    b1aa:	44 24       	eor	r4, r4
    b1ac:	55 24       	eor	r5, r5
    b1ae:	32 01       	movw	r6, r4
    b1b0:	e8 14       	cp	r14, r8
    b1b2:	f9 04       	cpc	r15, r9
    b1b4:	0a 05       	cpc	r16, r10
    b1b6:	1b 05       	cpc	r17, r11
    b1b8:	08 f0       	brcs	.+2      	; 0xb1bc <__divdi3+0xa94>
    b1ba:	eb c1       	rjmp	.+982    	; 0xb592 <__divdi3+0xe6a>
    b1bc:	e3 c1       	rjmp	.+966    	; 0xb584 <__divdi3+0xe5c>
    b1be:	34 2e       	mov	r3, r20
    b1c0:	2c 01       	movw	r4, r24
    b1c2:	3d 01       	movw	r6, r26
    b1c4:	04 c0       	rjmp	.+8      	; 0xb1ce <__divdi3+0xaa6>
    b1c6:	44 0c       	add	r4, r4
    b1c8:	55 1c       	adc	r5, r5
    b1ca:	66 1c       	adc	r6, r6
    b1cc:	77 1c       	adc	r7, r7
    b1ce:	4a 95       	dec	r20
    b1d0:	d2 f7       	brpl	.-12     	; 0xb1c6 <__divdi3+0xa9e>
    b1d2:	d5 01       	movw	r26, r10
    b1d4:	c4 01       	movw	r24, r8
    b1d6:	00 2e       	mov	r0, r16
    b1d8:	04 c0       	rjmp	.+8      	; 0xb1e2 <__divdi3+0xaba>
    b1da:	b6 95       	lsr	r27
    b1dc:	a7 95       	ror	r26
    b1de:	97 95       	ror	r25
    b1e0:	87 95       	ror	r24
    b1e2:	0a 94       	dec	r0
    b1e4:	d2 f7       	brpl	.-12     	; 0xb1da <__divdi3+0xab2>
    b1e6:	48 2a       	or	r4, r24
    b1e8:	59 2a       	or	r5, r25
    b1ea:	6a 2a       	or	r6, r26
    b1ec:	7b 2a       	or	r7, r27
    b1ee:	a5 01       	movw	r20, r10
    b1f0:	94 01       	movw	r18, r8
    b1f2:	03 2c       	mov	r0, r3
    b1f4:	04 c0       	rjmp	.+8      	; 0xb1fe <__divdi3+0xad6>
    b1f6:	22 0f       	add	r18, r18
    b1f8:	33 1f       	adc	r19, r19
    b1fa:	44 1f       	adc	r20, r20
    b1fc:	55 1f       	adc	r21, r21
    b1fe:	0a 94       	dec	r0
    b200:	d2 f7       	brpl	.-12     	; 0xb1f6 <__divdi3+0xace>
    b202:	29 af       	sts	0x79, r18
    b204:	3a af       	sts	0x7a, r19
    b206:	4b af       	sts	0x7b, r20
    b208:	5c af       	sts	0x7c, r21
    b20a:	b7 01       	movw	r22, r14
    b20c:	a6 01       	movw	r20, r12
    b20e:	00 2e       	mov	r0, r16
    b210:	04 c0       	rjmp	.+8      	; 0xb21a <__divdi3+0xaf2>
    b212:	76 95       	lsr	r23
    b214:	67 95       	ror	r22
    b216:	57 95       	ror	r21
    b218:	47 95       	ror	r20
    b21a:	0a 94       	dec	r0
    b21c:	d2 f7       	brpl	.-12     	; 0xb212 <__divdi3+0xaea>
    b21e:	49 ab       	sts	0x59, r20
    b220:	5a ab       	sts	0x5a, r21
    b222:	6b ab       	sts	0x5b, r22
    b224:	7c ab       	sts	0x5c, r23
    b226:	c7 01       	movw	r24, r14
    b228:	b6 01       	movw	r22, r12
    b22a:	03 2c       	mov	r0, r3
    b22c:	04 c0       	rjmp	.+8      	; 0xb236 <__divdi3+0xb0e>
    b22e:	66 0f       	add	r22, r22
    b230:	77 1f       	adc	r23, r23
    b232:	88 1f       	adc	r24, r24
    b234:	99 1f       	adc	r25, r25
    b236:	0a 94       	dec	r0
    b238:	d2 f7       	brpl	.-12     	; 0xb22e <__divdi3+0xb06>
    b23a:	6d a7       	lds	r22, 0x7d
    b23c:	7e a7       	lds	r23, 0x7e
    b23e:	8f a7       	lds	r24, 0x7f
    b240:	98 ab       	sts	0x58, r25
    b242:	8d a9       	sts	0x4d, r24
    b244:	9e a9       	sts	0x4e, r25
    b246:	af a9       	sts	0x4f, r26
    b248:	b8 ad       	sts	0x68, r27
    b24a:	04 c0       	rjmp	.+8      	; 0xb254 <__divdi3+0xb2c>
    b24c:	b6 95       	lsr	r27
    b24e:	a7 95       	ror	r26
    b250:	97 95       	ror	r25
    b252:	87 95       	ror	r24
    b254:	0a 95       	dec	r16
    b256:	d2 f7       	brpl	.-12     	; 0xb24c <__divdi3+0xb24>
    b258:	4d a5       	lds	r20, 0x6d
    b25a:	5e a5       	lds	r21, 0x6e
    b25c:	6f a5       	lds	r22, 0x6f
    b25e:	78 a9       	sts	0x48, r23
    b260:	48 2b       	or	r20, r24
    b262:	59 2b       	or	r21, r25
    b264:	6a 2b       	or	r22, r26
    b266:	7b 2b       	or	r23, r27
    b268:	4d a7       	lds	r20, 0x7d
    b26a:	5e a7       	lds	r21, 0x7e
    b26c:	6f a7       	lds	r22, 0x7f
    b26e:	78 ab       	sts	0x58, r23
    b270:	43 01       	movw	r8, r6
    b272:	aa 24       	eor	r10, r10
    b274:	bb 24       	eor	r11, r11
    b276:	93 01       	movw	r18, r6
    b278:	82 01       	movw	r16, r4
    b27a:	20 70       	andi	r18, 0x00	; 0
    b27c:	30 70       	andi	r19, 0x00	; 0
    b27e:	21 96       	adiw	r28, 0x01	; 1
    b280:	0c af       	sts	0x7c, r16
    b282:	1d af       	sts	0x7d, r17
    b284:	2e af       	sts	0x7e, r18
    b286:	3f af       	sts	0x7f, r19
    b288:	21 97       	sbiw	r28, 0x01	; 1
    b28a:	69 a9       	sts	0x49, r22
    b28c:	7a a9       	sts	0x4a, r23
    b28e:	8b a9       	sts	0x4b, r24
    b290:	9c a9       	sts	0x4c, r25
    b292:	a5 01       	movw	r20, r10
    b294:	94 01       	movw	r18, r8
    b296:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    b29a:	29 a7       	lds	r18, 0x79
    b29c:	3a a7       	lds	r19, 0x7a
    b29e:	4b a7       	lds	r20, 0x7b
    b2a0:	5c a7       	lds	r21, 0x7c
    b2a2:	6b 01       	movw	r12, r22
    b2a4:	7c 01       	movw	r14, r24
    b2a6:	69 a9       	sts	0x49, r22
    b2a8:	7a a9       	sts	0x4a, r23
    b2aa:	8b a9       	sts	0x4b, r24
    b2ac:	9c a9       	sts	0x4c, r25
    b2ae:	a5 01       	movw	r20, r10
    b2b0:	94 01       	movw	r18, r8
    b2b2:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    b2b6:	ca 01       	movw	r24, r20
    b2b8:	b9 01       	movw	r22, r18
    b2ba:	21 96       	adiw	r28, 0x01	; 1
    b2bc:	2c ad       	sts	0x6c, r18
    b2be:	3d ad       	sts	0x6d, r19
    b2c0:	4e ad       	sts	0x6e, r20
    b2c2:	5f ad       	sts	0x6f, r21
    b2c4:	21 97       	sbiw	r28, 0x01	; 1
    b2c6:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    b2ca:	dc 01       	movw	r26, r24
    b2cc:	cb 01       	movw	r24, r22
    b2ce:	76 01       	movw	r14, r12
    b2d0:	dd 24       	eor	r13, r13
    b2d2:	cc 24       	eor	r12, r12
    b2d4:	0d a5       	lds	r16, 0x6d
    b2d6:	1e a5       	lds	r17, 0x6e
    b2d8:	2f a5       	lds	r18, 0x6f
    b2da:	38 a9       	sts	0x48, r19
    b2dc:	a9 01       	movw	r20, r18
    b2de:	66 27       	eor	r22, r22
    b2e0:	77 27       	eor	r23, r23
    b2e2:	c4 2a       	or	r12, r20
    b2e4:	d5 2a       	or	r13, r21
    b2e6:	e6 2a       	or	r14, r22
    b2e8:	f7 2a       	or	r15, r23
    b2ea:	09 a5       	lds	r16, 0x69
    b2ec:	1a a5       	lds	r17, 0x6a
    b2ee:	2b a5       	lds	r18, 0x6b
    b2f0:	3c a5       	lds	r19, 0x6c
    b2f2:	c8 16       	cp	r12, r24
    b2f4:	d9 06       	cpc	r13, r25
    b2f6:	ea 06       	cpc	r14, r26
    b2f8:	fb 06       	cpc	r15, r27
    b2fa:	38 f5       	brcc	.+78     	; 0xb34a <__divdi3+0xc22>
    b2fc:	01 50       	subi	r16, 0x01	; 1
    b2fe:	10 40       	sbci	r17, 0x00	; 0
    b300:	20 40       	sbci	r18, 0x00	; 0
    b302:	30 40       	sbci	r19, 0x00	; 0
    b304:	09 ab       	sts	0x59, r16
    b306:	1a ab       	sts	0x5a, r17
    b308:	2b ab       	sts	0x5b, r18
    b30a:	3c ab       	sts	0x5c, r19
    b30c:	c4 0c       	add	r12, r4
    b30e:	d5 1c       	adc	r13, r5
    b310:	e6 1c       	adc	r14, r6
    b312:	f7 1c       	adc	r15, r7
    b314:	c4 14       	cp	r12, r4
    b316:	d5 04       	cpc	r13, r5
    b318:	e6 04       	cpc	r14, r6
    b31a:	f7 04       	cpc	r15, r7
    b31c:	d0 f0       	brcs	.+52     	; 0xb352 <__divdi3+0xc2a>
    b31e:	c8 16       	cp	r12, r24
    b320:	d9 06       	cpc	r13, r25
    b322:	ea 06       	cpc	r14, r26
    b324:	fb 06       	cpc	r15, r27
    b326:	a8 f4       	brcc	.+42     	; 0xb352 <__divdi3+0xc2a>
    b328:	09 a5       	lds	r16, 0x69
    b32a:	1a a5       	lds	r17, 0x6a
    b32c:	2b a5       	lds	r18, 0x6b
    b32e:	3c a5       	lds	r19, 0x6c
    b330:	02 50       	subi	r16, 0x02	; 2
    b332:	10 40       	sbci	r17, 0x00	; 0
    b334:	20 40       	sbci	r18, 0x00	; 0
    b336:	30 40       	sbci	r19, 0x00	; 0
    b338:	09 ab       	sts	0x59, r16
    b33a:	1a ab       	sts	0x5a, r17
    b33c:	2b ab       	sts	0x5b, r18
    b33e:	3c ab       	sts	0x5c, r19
    b340:	c4 0c       	add	r12, r4
    b342:	d5 1c       	adc	r13, r5
    b344:	e6 1c       	adc	r14, r6
    b346:	f7 1c       	adc	r15, r7
    b348:	04 c0       	rjmp	.+8      	; 0xb352 <__divdi3+0xc2a>
    b34a:	09 ab       	sts	0x59, r16
    b34c:	1a ab       	sts	0x5a, r17
    b34e:	2b ab       	sts	0x5b, r18
    b350:	3c ab       	sts	0x5c, r19
    b352:	c8 1a       	sub	r12, r24
    b354:	d9 0a       	sbc	r13, r25
    b356:	ea 0a       	sbc	r14, r26
    b358:	fb 0a       	sbc	r15, r27
    b35a:	c7 01       	movw	r24, r14
    b35c:	b6 01       	movw	r22, r12
    b35e:	a5 01       	movw	r20, r10
    b360:	94 01       	movw	r18, r8
    b362:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    b366:	29 a7       	lds	r18, 0x79
    b368:	3a a7       	lds	r19, 0x7a
    b36a:	4b a7       	lds	r20, 0x7b
    b36c:	5c a7       	lds	r21, 0x7c
    b36e:	29 96       	adiw	r28, 0x09	; 9
    b370:	6c af       	sts	0x7c, r22
    b372:	7d af       	sts	0x7d, r23
    b374:	8e af       	sts	0x7e, r24
    b376:	9f af       	sts	0x7f, r25
    b378:	29 97       	sbiw	r28, 0x09	; 9
    b37a:	c7 01       	movw	r24, r14
    b37c:	b6 01       	movw	r22, r12
    b37e:	a5 01       	movw	r20, r10
    b380:	94 01       	movw	r18, r8
    b382:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    b386:	ca 01       	movw	r24, r20
    b388:	b9 01       	movw	r22, r18
    b38a:	21 96       	adiw	r28, 0x01	; 1
    b38c:	2c ad       	sts	0x6c, r18
    b38e:	3d ad       	sts	0x6d, r19
    b390:	4e ad       	sts	0x6e, r20
    b392:	5f ad       	sts	0x6f, r21
    b394:	21 97       	sbiw	r28, 0x01	; 1
    b396:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    b39a:	4b 01       	movw	r8, r22
    b39c:	5c 01       	movw	r10, r24
    b39e:	29 96       	adiw	r28, 0x09	; 9
    b3a0:	4c ad       	sts	0x6c, r20
    b3a2:	5d ad       	sts	0x6d, r21
    b3a4:	6e ad       	sts	0x6e, r22
    b3a6:	7f ad       	sts	0x6f, r23
    b3a8:	29 97       	sbiw	r28, 0x09	; 9
    b3aa:	9a 01       	movw	r18, r20
    b3ac:	11 27       	eor	r17, r17
    b3ae:	00 27       	eor	r16, r16
    b3b0:	8d a5       	lds	r24, 0x6d
    b3b2:	9e a5       	lds	r25, 0x6e
    b3b4:	af a5       	lds	r26, 0x6f
    b3b6:	b8 a9       	sts	0x48, r27
    b3b8:	a0 70       	andi	r26, 0x00	; 0
    b3ba:	b0 70       	andi	r27, 0x00	; 0
    b3bc:	08 2b       	or	r16, r24
    b3be:	19 2b       	or	r17, r25
    b3c0:	2a 2b       	or	r18, r26
    b3c2:	3b 2b       	or	r19, r27
    b3c4:	89 a5       	lds	r24, 0x69
    b3c6:	9a a5       	lds	r25, 0x6a
    b3c8:	ab a5       	lds	r26, 0x6b
    b3ca:	bc a5       	lds	r27, 0x6c
    b3cc:	08 15       	cp	r16, r8
    b3ce:	19 05       	cpc	r17, r9
    b3d0:	2a 05       	cpc	r18, r10
    b3d2:	3b 05       	cpc	r19, r11
    b3d4:	e0 f4       	brcc	.+56     	; 0xb40e <__divdi3+0xce6>
    b3d6:	01 97       	sbiw	r24, 0x01	; 1
    b3d8:	a1 09       	sbc	r26, r1
    b3da:	b1 09       	sbc	r27, r1
    b3dc:	04 0d       	add	r16, r4
    b3de:	15 1d       	adc	r17, r5
    b3e0:	26 1d       	adc	r18, r6
    b3e2:	37 1d       	adc	r19, r7
    b3e4:	04 15       	cp	r16, r4
    b3e6:	15 05       	cpc	r17, r5
    b3e8:	26 05       	cpc	r18, r6
    b3ea:	37 05       	cpc	r19, r7
    b3ec:	80 f0       	brcs	.+32     	; 0xb40e <__divdi3+0xce6>
    b3ee:	08 15       	cp	r16, r8
    b3f0:	19 05       	cpc	r17, r9
    b3f2:	2a 05       	cpc	r18, r10
    b3f4:	3b 05       	cpc	r19, r11
    b3f6:	58 f4       	brcc	.+22     	; 0xb40e <__divdi3+0xce6>
    b3f8:	89 a5       	lds	r24, 0x69
    b3fa:	9a a5       	lds	r25, 0x6a
    b3fc:	ab a5       	lds	r26, 0x6b
    b3fe:	bc a5       	lds	r27, 0x6c
    b400:	02 97       	sbiw	r24, 0x02	; 2
    b402:	a1 09       	sbc	r26, r1
    b404:	b1 09       	sbc	r27, r1
    b406:	04 0d       	add	r16, r4
    b408:	15 1d       	adc	r17, r5
    b40a:	26 1d       	adc	r18, r6
    b40c:	37 1d       	adc	r19, r7
    b40e:	b9 01       	movw	r22, r18
    b410:	a8 01       	movw	r20, r16
    b412:	48 19       	sub	r20, r8
    b414:	59 09       	sbc	r21, r9
    b416:	6a 09       	sbc	r22, r10
    b418:	7b 09       	sbc	r23, r11
    b41a:	4d a7       	lds	r20, 0x7d
    b41c:	5e a7       	lds	r21, 0x7e
    b41e:	6f a7       	lds	r22, 0x7f
    b420:	78 ab       	sts	0x58, r23
    b422:	09 a9       	sts	0x49, r16
    b424:	1a a9       	sts	0x4a, r17
    b426:	2b a9       	sts	0x4b, r18
    b428:	3c a9       	sts	0x4c, r19
    b42a:	78 01       	movw	r14, r16
    b42c:	dd 24       	eor	r13, r13
    b42e:	cc 24       	eor	r12, r12
    b430:	c8 2a       	or	r12, r24
    b432:	d9 2a       	or	r13, r25
    b434:	ea 2a       	or	r14, r26
    b436:	fb 2a       	or	r15, r27
    b438:	ff ef       	ldi	r31, 0xFF	; 255
    b43a:	8f 2e       	mov	r8, r31
    b43c:	ff ef       	ldi	r31, 0xFF	; 255
    b43e:	9f 2e       	mov	r9, r31
    b440:	a1 2c       	mov	r10, r1
    b442:	b1 2c       	mov	r11, r1
    b444:	8c 20       	and	r8, r12
    b446:	9d 20       	and	r9, r13
    b448:	ae 20       	and	r10, r14
    b44a:	bf 20       	and	r11, r15
    b44c:	87 01       	movw	r16, r14
    b44e:	22 27       	eor	r18, r18
    b450:	33 27       	eor	r19, r19
    b452:	09 a7       	lds	r16, 0x79
    b454:	1a a7       	lds	r17, 0x7a
    b456:	2b a7       	lds	r18, 0x7b
    b458:	3c a7       	lds	r19, 0x7c
    b45a:	49 ac       	sts	0xa9, r20
    b45c:	5a ac       	sts	0xaa, r21
    b45e:	6b ac       	sts	0xab, r22
    b460:	7c ac       	sts	0xac, r23
    b462:	2f ef       	ldi	r18, 0xFF	; 255
    b464:	3f ef       	ldi	r19, 0xFF	; 255
    b466:	40 e0       	ldi	r20, 0x00	; 0
    b468:	50 e0       	ldi	r21, 0x00	; 0
    b46a:	42 22       	and	r4, r18
    b46c:	53 22       	and	r5, r19
    b46e:	64 22       	and	r6, r20
    b470:	75 22       	and	r7, r21
    b472:	29 ad       	sts	0x69, r18
    b474:	3a ad       	sts	0x6a, r19
    b476:	4b ad       	sts	0x6b, r20
    b478:	5c ad       	sts	0x6c, r21
    b47a:	8a 01       	movw	r16, r20
    b47c:	22 27       	eor	r18, r18
    b47e:	33 27       	eor	r19, r19
    b480:	09 ab       	sts	0x59, r16
    b482:	1a ab       	sts	0x5a, r17
    b484:	2b ab       	sts	0x5b, r18
    b486:	3c ab       	sts	0x5c, r19
    b488:	c5 01       	movw	r24, r10
    b48a:	b4 01       	movw	r22, r8
    b48c:	a3 01       	movw	r20, r6
    b48e:	92 01       	movw	r18, r4
    b490:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    b494:	69 af       	sts	0x79, r22
    b496:	7a af       	sts	0x7a, r23
    b498:	8b af       	sts	0x7b, r24
    b49a:	9c af       	sts	0x7c, r25
    b49c:	c5 01       	movw	r24, r10
    b49e:	b4 01       	movw	r22, r8
    b4a0:	29 a9       	sts	0x49, r18
    b4a2:	3a a9       	sts	0x4a, r19
    b4a4:	4b a9       	sts	0x4b, r20
    b4a6:	5c a9       	sts	0x4c, r21
    b4a8:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    b4ac:	4b 01       	movw	r8, r22
    b4ae:	5c 01       	movw	r10, r24
    b4b0:	69 a5       	lds	r22, 0x69
    b4b2:	7a a5       	lds	r23, 0x6a
    b4b4:	8b a5       	lds	r24, 0x6b
    b4b6:	9c a5       	lds	r25, 0x6c
    b4b8:	a3 01       	movw	r20, r6
    b4ba:	92 01       	movw	r18, r4
    b4bc:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    b4c0:	2b 01       	movw	r4, r22
    b4c2:	3c 01       	movw	r6, r24
    b4c4:	69 a5       	lds	r22, 0x69
    b4c6:	7a a5       	lds	r23, 0x6a
    b4c8:	8b a5       	lds	r24, 0x6b
    b4ca:	9c a5       	lds	r25, 0x6c
    b4cc:	29 a9       	sts	0x49, r18
    b4ce:	3a a9       	sts	0x4a, r19
    b4d0:	4b a9       	sts	0x4b, r20
    b4d2:	5c a9       	sts	0x4c, r21
    b4d4:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    b4d8:	ab 01       	movw	r20, r22
    b4da:	bc 01       	movw	r22, r24
    b4dc:	84 0c       	add	r8, r4
    b4de:	95 1c       	adc	r9, r5
    b4e0:	a6 1c       	adc	r10, r6
    b4e2:	b7 1c       	adc	r11, r7
    b4e4:	09 ad       	sts	0x69, r16
    b4e6:	1a ad       	sts	0x6a, r17
    b4e8:	2b ad       	sts	0x6b, r18
    b4ea:	3c ad       	sts	0x6c, r19
    b4ec:	c9 01       	movw	r24, r18
    b4ee:	aa 27       	eor	r26, r26
    b4f0:	bb 27       	eor	r27, r27
    b4f2:	88 0e       	add	r8, r24
    b4f4:	99 1e       	adc	r9, r25
    b4f6:	aa 1e       	adc	r10, r26
    b4f8:	bb 1e       	adc	r11, r27
    b4fa:	84 14       	cp	r8, r4
    b4fc:	95 04       	cpc	r9, r5
    b4fe:	a6 04       	cpc	r10, r6
    b500:	b7 04       	cpc	r11, r7
    b502:	20 f4       	brcc	.+8      	; 0xb50c <__divdi3+0xde4>
    b504:	40 50       	subi	r20, 0x00	; 0
    b506:	50 40       	sbci	r21, 0x00	; 0
    b508:	6f 4f       	sbci	r22, 0xFF	; 255
    b50a:	7f 4f       	sbci	r23, 0xFF	; 255
    b50c:	c5 01       	movw	r24, r10
    b50e:	aa 27       	eor	r26, r26
    b510:	bb 27       	eor	r27, r27
    b512:	84 0f       	add	r24, r20
    b514:	95 1f       	adc	r25, r21
    b516:	a6 1f       	adc	r26, r22
    b518:	b7 1f       	adc	r27, r23
    b51a:	0d a5       	lds	r16, 0x6d
    b51c:	1e a5       	lds	r17, 0x6e
    b51e:	2f a5       	lds	r18, 0x6f
    b520:	38 a9       	sts	0x48, r19
    b522:	08 17       	cp	r16, r24
    b524:	19 07       	cpc	r17, r25
    b526:	2a 07       	cpc	r18, r26
    b528:	3b 07       	cpc	r19, r27
    b52a:	18 f1       	brcs	.+70     	; 0xb572 <__divdi3+0xe4a>
    b52c:	80 17       	cp	r24, r16
    b52e:	91 07       	cpc	r25, r17
    b530:	a2 07       	cpc	r26, r18
    b532:	b3 07       	cpc	r27, r19
    b534:	a1 f5       	brne	.+104    	; 0xb59e <__divdi3+0xe76>
    b536:	54 01       	movw	r10, r8
    b538:	99 24       	eor	r9, r9
    b53a:	88 24       	eor	r8, r8
    b53c:	89 ad       	sts	0x69, r24
    b53e:	9a ad       	sts	0x6a, r25
    b540:	ab ad       	sts	0x6b, r26
    b542:	bc ad       	sts	0x6c, r27
    b544:	a0 70       	andi	r26, 0x00	; 0
    b546:	b0 70       	andi	r27, 0x00	; 0
    b548:	88 0e       	add	r8, r24
    b54a:	99 1e       	adc	r9, r25
    b54c:	aa 1e       	adc	r10, r26
    b54e:	bb 1e       	adc	r11, r27
    b550:	4d a9       	sts	0x4d, r20
    b552:	5e a9       	sts	0x4e, r21
    b554:	6f a9       	sts	0x4f, r22
    b556:	78 ad       	sts	0x68, r23
    b558:	03 2c       	mov	r0, r3
    b55a:	04 c0       	rjmp	.+8      	; 0xb564 <__divdi3+0xe3c>
    b55c:	44 0f       	add	r20, r20
    b55e:	55 1f       	adc	r21, r21
    b560:	66 1f       	adc	r22, r22
    b562:	77 1f       	adc	r23, r23
    b564:	0a 94       	dec	r0
    b566:	d2 f7       	brpl	.-12     	; 0xb55c <__divdi3+0xe34>
    b568:	48 15       	cp	r20, r8
    b56a:	59 05       	cpc	r21, r9
    b56c:	6a 05       	cpc	r22, r10
    b56e:	7b 05       	cpc	r23, r11
    b570:	b0 f4       	brcc	.+44     	; 0xb59e <__divdi3+0xe76>
    b572:	08 94       	sec
    b574:	c1 08       	sbc	r12, r1
    b576:	d1 08       	sbc	r13, r1
    b578:	e1 08       	sbc	r14, r1
    b57a:	f1 08       	sbc	r15, r1
    b57c:	10 c0       	rjmp	.+32     	; 0xb59e <__divdi3+0xe76>
    b57e:	44 24       	eor	r4, r4
    b580:	55 24       	eor	r5, r5
    b582:	32 01       	movw	r6, r4
    b584:	cc 24       	eor	r12, r12
    b586:	dd 24       	eor	r13, r13
    b588:	76 01       	movw	r14, r12
    b58a:	0c c0       	rjmp	.+24     	; 0xb5a4 <__divdi3+0xe7c>
    b58c:	44 24       	eor	r4, r4
    b58e:	55 24       	eor	r5, r5
    b590:	32 01       	movw	r6, r4
    b592:	81 e0       	ldi	r24, 0x01	; 1
    b594:	c8 2e       	mov	r12, r24
    b596:	d1 2c       	mov	r13, r1
    b598:	e1 2c       	mov	r14, r1
    b59a:	f1 2c       	mov	r15, r1
    b59c:	03 c0       	rjmp	.+6      	; 0xb5a4 <__divdi3+0xe7c>
    b59e:	44 24       	eor	r4, r4
    b5a0:	55 24       	eor	r5, r5
    b5a2:	32 01       	movw	r6, r4
    b5a4:	fe 01       	movw	r30, r28
    b5a6:	31 96       	adiw	r30, 0x01	; 1
    b5a8:	88 e0       	ldi	r24, 0x08	; 8
    b5aa:	df 01       	movw	r26, r30
    b5ac:	1d 92       	st	X+, r1
    b5ae:	8a 95       	dec	r24
    b5b0:	e9 f7       	brne	.-6      	; 0xb5ac <__divdi3+0xe84>
    b5b2:	c9 82       	std	Y+1, r12	; 0x01
    b5b4:	da 82       	std	Y+2, r13	; 0x02
    b5b6:	eb 82       	std	Y+3, r14	; 0x03
    b5b8:	fc 82       	std	Y+4, r15	; 0x04
    b5ba:	4d 82       	std	Y+5, r4	; 0x05
    b5bc:	5e 82       	std	Y+6, r5	; 0x06
    b5be:	6f 82       	std	Y+7, r6	; 0x07
    b5c0:	78 86       	std	Y+8, r7	; 0x08
    b5c2:	2c 2d       	mov	r18, r12
    b5c4:	3a 81       	ldd	r19, Y+2	; 0x02
    b5c6:	4b 81       	ldd	r20, Y+3	; 0x03
    b5c8:	5c 81       	ldd	r21, Y+4	; 0x04
    b5ca:	64 2d       	mov	r22, r4
    b5cc:	7e 81       	ldd	r23, Y+6	; 0x06
    b5ce:	8f 81       	ldd	r24, Y+7	; 0x07
    b5d0:	98 85       	ldd	r25, Y+8	; 0x08
    b5d2:	25 96       	adiw	r28, 0x05	; 5
    b5d4:	ec ac       	sts	0xac, r30
    b5d6:	fd ac       	sts	0xad, r31
    b5d8:	0e ad       	sts	0x6e, r16
    b5da:	1f ad       	sts	0x6f, r17
    b5dc:	25 97       	sbiw	r28, 0x05	; 5
    b5de:	e1 14       	cp	r14, r1
    b5e0:	f1 04       	cpc	r15, r1
    b5e2:	01 05       	cpc	r16, r1
    b5e4:	11 05       	cpc	r17, r1
    b5e6:	09 f4       	brne	.+2      	; 0xb5ea <__divdi3+0xec2>
    b5e8:	56 c0       	rjmp	.+172    	; 0xb696 <__divdi3+0xf6e>
    b5ea:	21 95       	neg	r18
    b5ec:	e1 e0       	ldi	r30, 0x01	; 1
    b5ee:	12 16       	cp	r1, r18
    b5f0:	08 f0       	brcs	.+2      	; 0xb5f4 <__divdi3+0xecc>
    b5f2:	e0 e0       	ldi	r30, 0x00	; 0
    b5f4:	31 95       	neg	r19
    b5f6:	f1 e0       	ldi	r31, 0x01	; 1
    b5f8:	13 16       	cp	r1, r19
    b5fa:	08 f0       	brcs	.+2      	; 0xb5fe <__divdi3+0xed6>
    b5fc:	f0 e0       	ldi	r31, 0x00	; 0
    b5fe:	03 2f       	mov	r16, r19
    b600:	0e 1b       	sub	r16, r30
    b602:	e1 e0       	ldi	r30, 0x01	; 1
    b604:	30 17       	cp	r19, r16
    b606:	08 f0       	brcs	.+2      	; 0xb60a <__divdi3+0xee2>
    b608:	e0 e0       	ldi	r30, 0x00	; 0
    b60a:	fe 2b       	or	r31, r30
    b60c:	41 95       	neg	r20
    b60e:	e1 e0       	ldi	r30, 0x01	; 1
    b610:	14 16       	cp	r1, r20
    b612:	08 f0       	brcs	.+2      	; 0xb616 <__divdi3+0xeee>
    b614:	e0 e0       	ldi	r30, 0x00	; 0
    b616:	14 2f       	mov	r17, r20
    b618:	1f 1b       	sub	r17, r31
    b61a:	31 e0       	ldi	r19, 0x01	; 1
    b61c:	41 17       	cp	r20, r17
    b61e:	08 f0       	brcs	.+2      	; 0xb622 <__divdi3+0xefa>
    b620:	30 e0       	ldi	r19, 0x00	; 0
    b622:	e3 2b       	or	r30, r19
    b624:	51 95       	neg	r21
    b626:	f1 e0       	ldi	r31, 0x01	; 1
    b628:	15 16       	cp	r1, r21
    b62a:	08 f0       	brcs	.+2      	; 0xb62e <__divdi3+0xf06>
    b62c:	f0 e0       	ldi	r31, 0x00	; 0
    b62e:	b5 2f       	mov	r27, r21
    b630:	be 1b       	sub	r27, r30
    b632:	31 e0       	ldi	r19, 0x01	; 1
    b634:	5b 17       	cp	r21, r27
    b636:	08 f0       	brcs	.+2      	; 0xb63a <__divdi3+0xf12>
    b638:	30 e0       	ldi	r19, 0x00	; 0
    b63a:	f3 2b       	or	r31, r19
    b63c:	61 95       	neg	r22
    b63e:	e1 e0       	ldi	r30, 0x01	; 1
    b640:	16 16       	cp	r1, r22
    b642:	08 f0       	brcs	.+2      	; 0xb646 <__divdi3+0xf1e>
    b644:	e0 e0       	ldi	r30, 0x00	; 0
    b646:	46 2e       	mov	r4, r22
    b648:	4f 1a       	sub	r4, r31
    b64a:	31 e0       	ldi	r19, 0x01	; 1
    b64c:	64 15       	cp	r22, r4
    b64e:	08 f0       	brcs	.+2      	; 0xb652 <__divdi3+0xf2a>
    b650:	30 e0       	ldi	r19, 0x00	; 0
    b652:	e3 2b       	or	r30, r19
    b654:	71 95       	neg	r23
    b656:	f1 e0       	ldi	r31, 0x01	; 1
    b658:	17 16       	cp	r1, r23
    b65a:	08 f0       	brcs	.+2      	; 0xb65e <__divdi3+0xf36>
    b65c:	f0 e0       	ldi	r31, 0x00	; 0
    b65e:	a7 2f       	mov	r26, r23
    b660:	ae 1b       	sub	r26, r30
    b662:	31 e0       	ldi	r19, 0x01	; 1
    b664:	7a 17       	cp	r23, r26
    b666:	08 f0       	brcs	.+2      	; 0xb66a <__divdi3+0xf42>
    b668:	30 e0       	ldi	r19, 0x00	; 0
    b66a:	f3 2b       	or	r31, r19
    b66c:	81 95       	neg	r24
    b66e:	e1 e0       	ldi	r30, 0x01	; 1
    b670:	18 16       	cp	r1, r24
    b672:	08 f0       	brcs	.+2      	; 0xb676 <__divdi3+0xf4e>
    b674:	e0 e0       	ldi	r30, 0x00	; 0
    b676:	f8 2e       	mov	r15, r24
    b678:	ff 1a       	sub	r15, r31
    b67a:	ff 2d       	mov	r31, r15
    b67c:	31 e0       	ldi	r19, 0x01	; 1
    b67e:	8f 15       	cp	r24, r15
    b680:	08 f0       	brcs	.+2      	; 0xb684 <__divdi3+0xf5c>
    b682:	30 e0       	ldi	r19, 0x00	; 0
    b684:	e3 2b       	or	r30, r19
    b686:	91 95       	neg	r25
    b688:	30 2f       	mov	r19, r16
    b68a:	41 2f       	mov	r20, r17
    b68c:	5b 2f       	mov	r21, r27
    b68e:	64 2d       	mov	r22, r4
    b690:	7a 2f       	mov	r23, r26
    b692:	8f 2f       	mov	r24, r31
    b694:	9e 1b       	sub	r25, r30
    b696:	c8 5b       	subi	r28, 0xB8	; 184
    b698:	df 4f       	sbci	r29, 0xFF	; 255
    b69a:	e1 e1       	ldi	r30, 0x11	; 17
    b69c:	0c 94 a6 63 	jmp	0xc74c	; 0xc74c <__epilogue_restores__+0x2>

0000b6a0 <__udivdi3>:
    b6a0:	a4 e3       	ldi	r26, 0x34	; 52
    b6a2:	b0 e0       	ldi	r27, 0x00	; 0
    b6a4:	e6 e5       	ldi	r30, 0x56	; 86
    b6a6:	fb e5       	ldi	r31, 0x5B	; 91
    b6a8:	0c 94 8d 63 	jmp	0xc71a	; 0xc71a <__prologue_saves__+0x2>
    b6ac:	29 8b       	std	Y+17, r18	; 0x11
    b6ae:	3a 8b       	std	Y+18, r19	; 0x12
    b6b0:	4b 8b       	std	Y+19, r20	; 0x13
    b6b2:	5c 8b       	std	Y+20, r21	; 0x14
    b6b4:	6d 8b       	std	Y+21, r22	; 0x15
    b6b6:	7e 8b       	std	Y+22, r23	; 0x16
    b6b8:	8f 8b       	std	Y+23, r24	; 0x17
    b6ba:	98 8f       	std	Y+24, r25	; 0x18
    b6bc:	a9 86       	std	Y+9, r10	; 0x09
    b6be:	ba 86       	std	Y+10, r11	; 0x0a
    b6c0:	cb 86       	std	Y+11, r12	; 0x0b
    b6c2:	dc 86       	std	Y+12, r13	; 0x0c
    b6c4:	ed 86       	std	Y+13, r14	; 0x0d
    b6c6:	fe 86       	std	Y+14, r15	; 0x0e
    b6c8:	0f 87       	std	Y+15, r16	; 0x0f
    b6ca:	18 8b       	std	Y+16, r17	; 0x10
    b6cc:	89 84       	ldd	r8, Y+9	; 0x09
    b6ce:	9a 84       	ldd	r9, Y+10	; 0x0a
    b6d0:	ab 84       	ldd	r10, Y+11	; 0x0b
    b6d2:	bc 84       	ldd	r11, Y+12	; 0x0c
    b6d4:	8d 85       	ldd	r24, Y+13	; 0x0d
    b6d6:	9e 85       	ldd	r25, Y+14	; 0x0e
    b6d8:	af 85       	ldd	r26, Y+15	; 0x0f
    b6da:	b8 89       	ldd	r27, Y+16	; 0x10
    b6dc:	09 89       	ldd	r16, Y+17	; 0x11
    b6de:	1a 89       	ldd	r17, Y+18	; 0x12
    b6e0:	2b 89       	ldd	r18, Y+19	; 0x13
    b6e2:	3c 89       	ldd	r19, Y+20	; 0x14
    b6e4:	0d a3       	lds	r16, 0x5d
    b6e6:	1e a3       	lds	r17, 0x5e
    b6e8:	2f a3       	lds	r18, 0x5f
    b6ea:	38 a7       	lds	r19, 0x78
    b6ec:	cd 88       	ldd	r12, Y+21	; 0x15
    b6ee:	de 88       	ldd	r13, Y+22	; 0x16
    b6f0:	ef 88       	ldd	r14, Y+23	; 0x17
    b6f2:	f8 8c       	ldd	r15, Y+24	; 0x18
    b6f4:	00 97       	sbiw	r24, 0x00	; 0
    b6f6:	a1 05       	cpc	r26, r1
    b6f8:	b1 05       	cpc	r27, r1
    b6fa:	09 f0       	breq	.+2      	; 0xb6fe <__udivdi3+0x5e>
    b6fc:	b5 c3       	rjmp	.+1898   	; 0xbe68 <__udivdi3+0x7c8>
    b6fe:	c8 14       	cp	r12, r8
    b700:	d9 04       	cpc	r13, r9
    b702:	ea 04       	cpc	r14, r10
    b704:	fb 04       	cpc	r15, r11
    b706:	08 f0       	brcs	.+2      	; 0xb70a <__udivdi3+0x6a>
    b708:	4d c1       	rjmp	.+666    	; 0xb9a4 <__udivdi3+0x304>
    b70a:	10 e0       	ldi	r17, 0x00	; 0
    b70c:	81 16       	cp	r8, r17
    b70e:	10 e0       	ldi	r17, 0x00	; 0
    b710:	91 06       	cpc	r9, r17
    b712:	11 e0       	ldi	r17, 0x01	; 1
    b714:	a1 06       	cpc	r10, r17
    b716:	10 e0       	ldi	r17, 0x00	; 0
    b718:	b1 06       	cpc	r11, r17
    b71a:	58 f4       	brcc	.+22     	; 0xb732 <__udivdi3+0x92>
    b71c:	2f ef       	ldi	r18, 0xFF	; 255
    b71e:	82 16       	cp	r8, r18
    b720:	91 04       	cpc	r9, r1
    b722:	a1 04       	cpc	r10, r1
    b724:	b1 04       	cpc	r11, r1
    b726:	09 f0       	breq	.+2      	; 0xb72a <__udivdi3+0x8a>
    b728:	90 f4       	brcc	.+36     	; 0xb74e <__udivdi3+0xae>
    b72a:	80 e0       	ldi	r24, 0x00	; 0
    b72c:	90 e0       	ldi	r25, 0x00	; 0
    b72e:	dc 01       	movw	r26, r24
    b730:	17 c0       	rjmp	.+46     	; 0xb760 <__udivdi3+0xc0>
    b732:	30 e0       	ldi	r19, 0x00	; 0
    b734:	83 16       	cp	r8, r19
    b736:	30 e0       	ldi	r19, 0x00	; 0
    b738:	93 06       	cpc	r9, r19
    b73a:	30 e0       	ldi	r19, 0x00	; 0
    b73c:	a3 06       	cpc	r10, r19
    b73e:	31 e0       	ldi	r19, 0x01	; 1
    b740:	b3 06       	cpc	r11, r19
    b742:	50 f4       	brcc	.+20     	; 0xb758 <__udivdi3+0xb8>
    b744:	80 e1       	ldi	r24, 0x10	; 16
    b746:	90 e0       	ldi	r25, 0x00	; 0
    b748:	a0 e0       	ldi	r26, 0x00	; 0
    b74a:	b0 e0       	ldi	r27, 0x00	; 0
    b74c:	09 c0       	rjmp	.+18     	; 0xb760 <__udivdi3+0xc0>
    b74e:	88 e0       	ldi	r24, 0x08	; 8
    b750:	90 e0       	ldi	r25, 0x00	; 0
    b752:	a0 e0       	ldi	r26, 0x00	; 0
    b754:	b0 e0       	ldi	r27, 0x00	; 0
    b756:	04 c0       	rjmp	.+8      	; 0xb760 <__udivdi3+0xc0>
    b758:	88 e1       	ldi	r24, 0x18	; 24
    b75a:	90 e0       	ldi	r25, 0x00	; 0
    b75c:	a0 e0       	ldi	r26, 0x00	; 0
    b75e:	b0 e0       	ldi	r27, 0x00	; 0
    b760:	b5 01       	movw	r22, r10
    b762:	a4 01       	movw	r20, r8
    b764:	08 2e       	mov	r0, r24
    b766:	04 c0       	rjmp	.+8      	; 0xb770 <__udivdi3+0xd0>
    b768:	76 95       	lsr	r23
    b76a:	67 95       	ror	r22
    b76c:	57 95       	ror	r21
    b76e:	47 95       	ror	r20
    b770:	0a 94       	dec	r0
    b772:	d2 f7       	brpl	.-12     	; 0xb768 <__udivdi3+0xc8>
    b774:	fa 01       	movw	r30, r20
    b776:	ea 5d       	subi	r30, 0xDA	; 218
    b778:	ff 4d       	sbci	r31, 0xDF	; 223
    b77a:	20 81       	ld	r18, Z
    b77c:	40 e2       	ldi	r20, 0x20	; 32
    b77e:	50 e0       	ldi	r21, 0x00	; 0
    b780:	60 e0       	ldi	r22, 0x00	; 0
    b782:	70 e0       	ldi	r23, 0x00	; 0
    b784:	48 1b       	sub	r20, r24
    b786:	59 0b       	sbc	r21, r25
    b788:	6a 0b       	sbc	r22, r26
    b78a:	7b 0b       	sbc	r23, r27
    b78c:	42 1b       	sub	r20, r18
    b78e:	51 09       	sbc	r21, r1
    b790:	61 09       	sbc	r22, r1
    b792:	71 09       	sbc	r23, r1
    b794:	41 15       	cp	r20, r1
    b796:	51 05       	cpc	r21, r1
    b798:	61 05       	cpc	r22, r1
    b79a:	71 05       	cpc	r23, r1
    b79c:	a1 f1       	breq	.+104    	; 0xb806 <__udivdi3+0x166>
    b79e:	04 2e       	mov	r0, r20
    b7a0:	04 c0       	rjmp	.+8      	; 0xb7aa <__udivdi3+0x10a>
    b7a2:	88 0c       	add	r8, r8
    b7a4:	99 1c       	adc	r9, r9
    b7a6:	aa 1c       	adc	r10, r10
    b7a8:	bb 1c       	adc	r11, r11
    b7aa:	0a 94       	dec	r0
    b7ac:	d2 f7       	brpl	.-12     	; 0xb7a2 <__udivdi3+0x102>
    b7ae:	97 01       	movw	r18, r14
    b7b0:	86 01       	movw	r16, r12
    b7b2:	04 2e       	mov	r0, r20
    b7b4:	04 c0       	rjmp	.+8      	; 0xb7be <__udivdi3+0x11e>
    b7b6:	00 0f       	add	r16, r16
    b7b8:	11 1f       	adc	r17, r17
    b7ba:	22 1f       	adc	r18, r18
    b7bc:	33 1f       	adc	r19, r19
    b7be:	0a 94       	dec	r0
    b7c0:	d2 f7       	brpl	.-12     	; 0xb7b6 <__udivdi3+0x116>
    b7c2:	80 e2       	ldi	r24, 0x20	; 32
    b7c4:	90 e0       	ldi	r25, 0x00	; 0
    b7c6:	84 1b       	sub	r24, r20
    b7c8:	95 0b       	sbc	r25, r21
    b7ca:	cd a0       	lds	r28, 0x8d
    b7cc:	de a0       	lds	r29, 0x8e
    b7ce:	ef a0       	lds	r30, 0x8f
    b7d0:	f8 a4       	lds	r31, 0xa8
    b7d2:	04 c0       	rjmp	.+8      	; 0xb7dc <__udivdi3+0x13c>
    b7d4:	f6 94       	lsr	r15
    b7d6:	e7 94       	ror	r14
    b7d8:	d7 94       	ror	r13
    b7da:	c7 94       	ror	r12
    b7dc:	8a 95       	dec	r24
    b7de:	d2 f7       	brpl	.-12     	; 0xb7d4 <__udivdi3+0x134>
    b7e0:	c0 2a       	or	r12, r16
    b7e2:	d1 2a       	or	r13, r17
    b7e4:	e2 2a       	or	r14, r18
    b7e6:	f3 2a       	or	r15, r19
    b7e8:	0d a1       	lds	r16, 0x4d
    b7ea:	1e a1       	lds	r17, 0x4e
    b7ec:	2f a1       	lds	r18, 0x4f
    b7ee:	38 a5       	lds	r19, 0x68
    b7f0:	04 c0       	rjmp	.+8      	; 0xb7fa <__udivdi3+0x15a>
    b7f2:	00 0f       	add	r16, r16
    b7f4:	11 1f       	adc	r17, r17
    b7f6:	22 1f       	adc	r18, r18
    b7f8:	33 1f       	adc	r19, r19
    b7fa:	4a 95       	dec	r20
    b7fc:	d2 f7       	brpl	.-12     	; 0xb7f2 <__udivdi3+0x152>
    b7fe:	0d a3       	lds	r16, 0x5d
    b800:	1e a3       	lds	r17, 0x5e
    b802:	2f a3       	lds	r18, 0x5f
    b804:	38 a7       	lds	r19, 0x78
    b806:	25 01       	movw	r4, r10
    b808:	66 24       	eor	r6, r6
    b80a:	77 24       	eor	r7, r7
    b80c:	95 01       	movw	r18, r10
    b80e:	84 01       	movw	r16, r8
    b810:	20 70       	andi	r18, 0x00	; 0
    b812:	30 70       	andi	r19, 0x00	; 0
    b814:	09 a3       	lds	r16, 0x59
    b816:	1a a3       	lds	r17, 0x5a
    b818:	2b a3       	lds	r18, 0x5b
    b81a:	3c a3       	lds	r19, 0x5c
    b81c:	c7 01       	movw	r24, r14
    b81e:	b6 01       	movw	r22, r12
    b820:	a3 01       	movw	r20, r6
    b822:	92 01       	movw	r18, r4
    b824:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    b828:	2d 8f       	std	Y+29, r18	; 0x1d
    b82a:	3e 8f       	std	Y+30, r19	; 0x1e
    b82c:	4f 8f       	std	Y+31, r20	; 0x1f
    b82e:	58 a3       	lds	r21, 0x58
    b830:	69 8f       	std	Y+25, r22	; 0x19
    b832:	7a 8f       	std	Y+26, r23	; 0x1a
    b834:	8b 8f       	std	Y+27, r24	; 0x1b
    b836:	9c 8f       	std	Y+28, r25	; 0x1c
    b838:	c7 01       	movw	r24, r14
    b83a:	b6 01       	movw	r22, r12
    b83c:	a3 01       	movw	r20, r6
    b83e:	92 01       	movw	r18, r4
    b840:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    b844:	ca 01       	movw	r24, r20
    b846:	b9 01       	movw	r22, r18
    b848:	29 a1       	lds	r18, 0x49
    b84a:	3a a1       	lds	r19, 0x4a
    b84c:	4b a1       	lds	r20, 0x4b
    b84e:	5c a1       	lds	r21, 0x4c
    b850:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    b854:	ab 01       	movw	r20, r22
    b856:	bc 01       	movw	r22, r24
    b858:	09 8d       	ldd	r16, Y+25	; 0x19
    b85a:	1a 8d       	ldd	r17, Y+26	; 0x1a
    b85c:	2b 8d       	ldd	r18, Y+27	; 0x1b
    b85e:	3c 8d       	ldd	r19, Y+28	; 0x1c
    b860:	78 01       	movw	r14, r16
    b862:	dd 24       	eor	r13, r13
    b864:	cc 24       	eor	r12, r12
    b866:	0d a1       	lds	r16, 0x4d
    b868:	1e a1       	lds	r17, 0x4e
    b86a:	2f a1       	lds	r18, 0x4f
    b86c:	38 a5       	lds	r19, 0x68
    b86e:	c9 01       	movw	r24, r18
    b870:	aa 27       	eor	r26, r26
    b872:	bb 27       	eor	r27, r27
    b874:	c8 2a       	or	r12, r24
    b876:	d9 2a       	or	r13, r25
    b878:	ea 2a       	or	r14, r26
    b87a:	fb 2a       	or	r15, r27
    b87c:	0d 8d       	ldd	r16, Y+29	; 0x1d
    b87e:	1e 8d       	ldd	r17, Y+30	; 0x1e
    b880:	2f 8d       	ldd	r18, Y+31	; 0x1f
    b882:	38 a1       	lds	r19, 0x48
    b884:	c4 16       	cp	r12, r20
    b886:	d5 06       	cpc	r13, r21
    b888:	e6 06       	cpc	r14, r22
    b88a:	f7 06       	cpc	r15, r23
    b88c:	38 f5       	brcc	.+78     	; 0xb8dc <__udivdi3+0x23c>
    b88e:	01 50       	subi	r16, 0x01	; 1
    b890:	10 40       	sbci	r17, 0x00	; 0
    b892:	20 40       	sbci	r18, 0x00	; 0
    b894:	30 40       	sbci	r19, 0x00	; 0
    b896:	09 8f       	std	Y+25, r16	; 0x19
    b898:	1a 8f       	std	Y+26, r17	; 0x1a
    b89a:	2b 8f       	std	Y+27, r18	; 0x1b
    b89c:	3c 8f       	std	Y+28, r19	; 0x1c
    b89e:	c8 0c       	add	r12, r8
    b8a0:	d9 1c       	adc	r13, r9
    b8a2:	ea 1c       	adc	r14, r10
    b8a4:	fb 1c       	adc	r15, r11
    b8a6:	c8 14       	cp	r12, r8
    b8a8:	d9 04       	cpc	r13, r9
    b8aa:	ea 04       	cpc	r14, r10
    b8ac:	fb 04       	cpc	r15, r11
    b8ae:	d0 f0       	brcs	.+52     	; 0xb8e4 <__udivdi3+0x244>
    b8b0:	c4 16       	cp	r12, r20
    b8b2:	d5 06       	cpc	r13, r21
    b8b4:	e6 06       	cpc	r14, r22
    b8b6:	f7 06       	cpc	r15, r23
    b8b8:	a8 f4       	brcc	.+42     	; 0xb8e4 <__udivdi3+0x244>
    b8ba:	0d 8d       	ldd	r16, Y+29	; 0x1d
    b8bc:	1e 8d       	ldd	r17, Y+30	; 0x1e
    b8be:	2f 8d       	ldd	r18, Y+31	; 0x1f
    b8c0:	38 a1       	lds	r19, 0x48
    b8c2:	02 50       	subi	r16, 0x02	; 2
    b8c4:	10 40       	sbci	r17, 0x00	; 0
    b8c6:	20 40       	sbci	r18, 0x00	; 0
    b8c8:	30 40       	sbci	r19, 0x00	; 0
    b8ca:	09 8f       	std	Y+25, r16	; 0x19
    b8cc:	1a 8f       	std	Y+26, r17	; 0x1a
    b8ce:	2b 8f       	std	Y+27, r18	; 0x1b
    b8d0:	3c 8f       	std	Y+28, r19	; 0x1c
    b8d2:	c8 0c       	add	r12, r8
    b8d4:	d9 1c       	adc	r13, r9
    b8d6:	ea 1c       	adc	r14, r10
    b8d8:	fb 1c       	adc	r15, r11
    b8da:	04 c0       	rjmp	.+8      	; 0xb8e4 <__udivdi3+0x244>
    b8dc:	09 8f       	std	Y+25, r16	; 0x19
    b8de:	1a 8f       	std	Y+26, r17	; 0x1a
    b8e0:	2b 8f       	std	Y+27, r18	; 0x1b
    b8e2:	3c 8f       	std	Y+28, r19	; 0x1c
    b8e4:	c4 1a       	sub	r12, r20
    b8e6:	d5 0a       	sbc	r13, r21
    b8e8:	e6 0a       	sbc	r14, r22
    b8ea:	f7 0a       	sbc	r15, r23
    b8ec:	c7 01       	movw	r24, r14
    b8ee:	b6 01       	movw	r22, r12
    b8f0:	a3 01       	movw	r20, r6
    b8f2:	92 01       	movw	r18, r4
    b8f4:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    b8f8:	2d 8f       	std	Y+29, r18	; 0x1d
    b8fa:	3e 8f       	std	Y+30, r19	; 0x1e
    b8fc:	4f 8f       	std	Y+31, r20	; 0x1f
    b8fe:	58 a3       	lds	r21, 0x58
    b900:	69 a7       	lds	r22, 0x79
    b902:	7a a7       	lds	r23, 0x7a
    b904:	8b a7       	lds	r24, 0x7b
    b906:	9c a7       	lds	r25, 0x7c
    b908:	c7 01       	movw	r24, r14
    b90a:	b6 01       	movw	r22, r12
    b90c:	a3 01       	movw	r20, r6
    b90e:	92 01       	movw	r18, r4
    b910:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    b914:	ca 01       	movw	r24, r20
    b916:	b9 01       	movw	r22, r18
    b918:	29 a1       	lds	r18, 0x49
    b91a:	3a a1       	lds	r19, 0x4a
    b91c:	4b a1       	lds	r20, 0x4b
    b91e:	5c a1       	lds	r21, 0x4c
    b920:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    b924:	6b 01       	movw	r12, r22
    b926:	7c 01       	movw	r14, r24
    b928:	49 a5       	lds	r20, 0x69
    b92a:	5a a5       	lds	r21, 0x6a
    b92c:	6b a5       	lds	r22, 0x6b
    b92e:	7c a5       	lds	r23, 0x6c
    b930:	9a 01       	movw	r18, r20
    b932:	11 27       	eor	r17, r17
    b934:	00 27       	eor	r16, r16
    b936:	4d a1       	lds	r20, 0x4d
    b938:	5e a1       	lds	r21, 0x4e
    b93a:	6f a1       	lds	r22, 0x4f
    b93c:	78 a5       	lds	r23, 0x68
    b93e:	60 70       	andi	r22, 0x00	; 0
    b940:	70 70       	andi	r23, 0x00	; 0
    b942:	04 2b       	or	r16, r20
    b944:	15 2b       	or	r17, r21
    b946:	26 2b       	or	r18, r22
    b948:	37 2b       	or	r19, r23
    b94a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    b94c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    b94e:	af 8d       	ldd	r26, Y+31	; 0x1f
    b950:	b8 a1       	lds	r27, 0x48
    b952:	0c 15       	cp	r16, r12
    b954:	1d 05       	cpc	r17, r13
    b956:	2e 05       	cpc	r18, r14
    b958:	3f 05       	cpc	r19, r15
    b95a:	c0 f4       	brcc	.+48     	; 0xb98c <__udivdi3+0x2ec>
    b95c:	01 97       	sbiw	r24, 0x01	; 1
    b95e:	a1 09       	sbc	r26, r1
    b960:	b1 09       	sbc	r27, r1
    b962:	08 0d       	add	r16, r8
    b964:	19 1d       	adc	r17, r9
    b966:	2a 1d       	adc	r18, r10
    b968:	3b 1d       	adc	r19, r11
    b96a:	08 15       	cp	r16, r8
    b96c:	19 05       	cpc	r17, r9
    b96e:	2a 05       	cpc	r18, r10
    b970:	3b 05       	cpc	r19, r11
    b972:	60 f0       	brcs	.+24     	; 0xb98c <__udivdi3+0x2ec>
    b974:	0c 15       	cp	r16, r12
    b976:	1d 05       	cpc	r17, r13
    b978:	2e 05       	cpc	r18, r14
    b97a:	3f 05       	cpc	r19, r15
    b97c:	38 f4       	brcc	.+14     	; 0xb98c <__udivdi3+0x2ec>
    b97e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    b980:	9e 8d       	ldd	r25, Y+30	; 0x1e
    b982:	af 8d       	ldd	r26, Y+31	; 0x1f
    b984:	b8 a1       	lds	r27, 0x48
    b986:	02 97       	sbiw	r24, 0x02	; 2
    b988:	a1 09       	sbc	r26, r1
    b98a:	b1 09       	sbc	r27, r1
    b98c:	09 8d       	ldd	r16, Y+25	; 0x19
    b98e:	1a 8d       	ldd	r17, Y+26	; 0x1a
    b990:	2b 8d       	ldd	r18, Y+27	; 0x1b
    b992:	3c 8d       	ldd	r19, Y+28	; 0x1c
    b994:	78 01       	movw	r14, r16
    b996:	dd 24       	eor	r13, r13
    b998:	cc 24       	eor	r12, r12
    b99a:	c8 2a       	or	r12, r24
    b99c:	d9 2a       	or	r13, r25
    b99e:	ea 2a       	or	r14, r26
    b9a0:	fb 2a       	or	r15, r27
    b9a2:	a5 c4       	rjmp	.+2378   	; 0xc2ee <__udivdi3+0xc4e>
    b9a4:	81 14       	cp	r8, r1
    b9a6:	91 04       	cpc	r9, r1
    b9a8:	a1 04       	cpc	r10, r1
    b9aa:	b1 04       	cpc	r11, r1
    b9ac:	51 f4       	brne	.+20     	; 0xb9c2 <__udivdi3+0x322>
    b9ae:	61 e0       	ldi	r22, 0x01	; 1
    b9b0:	70 e0       	ldi	r23, 0x00	; 0
    b9b2:	80 e0       	ldi	r24, 0x00	; 0
    b9b4:	90 e0       	ldi	r25, 0x00	; 0
    b9b6:	a5 01       	movw	r20, r10
    b9b8:	94 01       	movw	r18, r8
    b9ba:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    b9be:	49 01       	movw	r8, r18
    b9c0:	5a 01       	movw	r10, r20
    b9c2:	10 e0       	ldi	r17, 0x00	; 0
    b9c4:	81 16       	cp	r8, r17
    b9c6:	10 e0       	ldi	r17, 0x00	; 0
    b9c8:	91 06       	cpc	r9, r17
    b9ca:	11 e0       	ldi	r17, 0x01	; 1
    b9cc:	a1 06       	cpc	r10, r17
    b9ce:	10 e0       	ldi	r17, 0x00	; 0
    b9d0:	b1 06       	cpc	r11, r17
    b9d2:	58 f4       	brcc	.+22     	; 0xb9ea <__udivdi3+0x34a>
    b9d4:	2f ef       	ldi	r18, 0xFF	; 255
    b9d6:	82 16       	cp	r8, r18
    b9d8:	91 04       	cpc	r9, r1
    b9da:	a1 04       	cpc	r10, r1
    b9dc:	b1 04       	cpc	r11, r1
    b9de:	09 f0       	breq	.+2      	; 0xb9e2 <__udivdi3+0x342>
    b9e0:	90 f4       	brcc	.+36     	; 0xba06 <__udivdi3+0x366>
    b9e2:	80 e0       	ldi	r24, 0x00	; 0
    b9e4:	90 e0       	ldi	r25, 0x00	; 0
    b9e6:	dc 01       	movw	r26, r24
    b9e8:	17 c0       	rjmp	.+46     	; 0xba18 <__udivdi3+0x378>
    b9ea:	30 e0       	ldi	r19, 0x00	; 0
    b9ec:	83 16       	cp	r8, r19
    b9ee:	30 e0       	ldi	r19, 0x00	; 0
    b9f0:	93 06       	cpc	r9, r19
    b9f2:	30 e0       	ldi	r19, 0x00	; 0
    b9f4:	a3 06       	cpc	r10, r19
    b9f6:	31 e0       	ldi	r19, 0x01	; 1
    b9f8:	b3 06       	cpc	r11, r19
    b9fa:	50 f4       	brcc	.+20     	; 0xba10 <__udivdi3+0x370>
    b9fc:	80 e1       	ldi	r24, 0x10	; 16
    b9fe:	90 e0       	ldi	r25, 0x00	; 0
    ba00:	a0 e0       	ldi	r26, 0x00	; 0
    ba02:	b0 e0       	ldi	r27, 0x00	; 0
    ba04:	09 c0       	rjmp	.+18     	; 0xba18 <__udivdi3+0x378>
    ba06:	88 e0       	ldi	r24, 0x08	; 8
    ba08:	90 e0       	ldi	r25, 0x00	; 0
    ba0a:	a0 e0       	ldi	r26, 0x00	; 0
    ba0c:	b0 e0       	ldi	r27, 0x00	; 0
    ba0e:	04 c0       	rjmp	.+8      	; 0xba18 <__udivdi3+0x378>
    ba10:	88 e1       	ldi	r24, 0x18	; 24
    ba12:	90 e0       	ldi	r25, 0x00	; 0
    ba14:	a0 e0       	ldi	r26, 0x00	; 0
    ba16:	b0 e0       	ldi	r27, 0x00	; 0
    ba18:	b5 01       	movw	r22, r10
    ba1a:	a4 01       	movw	r20, r8
    ba1c:	08 2e       	mov	r0, r24
    ba1e:	04 c0       	rjmp	.+8      	; 0xba28 <__udivdi3+0x388>
    ba20:	76 95       	lsr	r23
    ba22:	67 95       	ror	r22
    ba24:	57 95       	ror	r21
    ba26:	47 95       	ror	r20
    ba28:	0a 94       	dec	r0
    ba2a:	d2 f7       	brpl	.-12     	; 0xba20 <__udivdi3+0x380>
    ba2c:	fa 01       	movw	r30, r20
    ba2e:	ea 5d       	subi	r30, 0xDA	; 218
    ba30:	ff 4d       	sbci	r31, 0xDF	; 223
    ba32:	20 81       	ld	r18, Z
    ba34:	ac 01       	movw	r20, r24
    ba36:	bd 01       	movw	r22, r26
    ba38:	42 0f       	add	r20, r18
    ba3a:	51 1d       	adc	r21, r1
    ba3c:	61 1d       	adc	r22, r1
    ba3e:	71 1d       	adc	r23, r1
    ba40:	80 e2       	ldi	r24, 0x20	; 32
    ba42:	90 e0       	ldi	r25, 0x00	; 0
    ba44:	a0 e0       	ldi	r26, 0x00	; 0
    ba46:	b0 e0       	ldi	r27, 0x00	; 0
    ba48:	84 1b       	sub	r24, r20
    ba4a:	95 0b       	sbc	r25, r21
    ba4c:	a6 0b       	sbc	r26, r22
    ba4e:	b7 0b       	sbc	r27, r23
    ba50:	51 f4       	brne	.+20     	; 0xba66 <__udivdi3+0x3c6>
    ba52:	c8 18       	sub	r12, r8
    ba54:	d9 08       	sbc	r13, r9
    ba56:	ea 08       	sbc	r14, r10
    ba58:	fb 08       	sbc	r15, r11
    ba5a:	f1 e0       	ldi	r31, 0x01	; 1
    ba5c:	4f 2e       	mov	r4, r31
    ba5e:	51 2c       	mov	r5, r1
    ba60:	61 2c       	mov	r6, r1
    ba62:	71 2c       	mov	r7, r1
    ba64:	24 c1       	rjmp	.+584    	; 0xbcae <__udivdi3+0x60e>
    ba66:	08 2e       	mov	r0, r24
    ba68:	04 c0       	rjmp	.+8      	; 0xba72 <__udivdi3+0x3d2>
    ba6a:	88 0c       	add	r8, r8
    ba6c:	99 1c       	adc	r9, r9
    ba6e:	aa 1c       	adc	r10, r10
    ba70:	bb 1c       	adc	r11, r11
    ba72:	0a 94       	dec	r0
    ba74:	d2 f7       	brpl	.-12     	; 0xba6a <__udivdi3+0x3ca>
    ba76:	97 01       	movw	r18, r14
    ba78:	86 01       	movw	r16, r12
    ba7a:	04 2e       	mov	r0, r20
    ba7c:	04 c0       	rjmp	.+8      	; 0xba86 <__udivdi3+0x3e6>
    ba7e:	36 95       	lsr	r19
    ba80:	27 95       	ror	r18
    ba82:	17 95       	ror	r17
    ba84:	07 95       	ror	r16
    ba86:	0a 94       	dec	r0
    ba88:	d2 f7       	brpl	.-12     	; 0xba7e <__udivdi3+0x3de>
    ba8a:	09 a3       	lds	r16, 0x59
    ba8c:	1a a3       	lds	r17, 0x5a
    ba8e:	2b a3       	lds	r18, 0x5b
    ba90:	3c a3       	lds	r19, 0x5c
    ba92:	97 01       	movw	r18, r14
    ba94:	86 01       	movw	r16, r12
    ba96:	08 2e       	mov	r0, r24
    ba98:	04 c0       	rjmp	.+8      	; 0xbaa2 <__udivdi3+0x402>
    ba9a:	00 0f       	add	r16, r16
    ba9c:	11 1f       	adc	r17, r17
    ba9e:	22 1f       	adc	r18, r18
    baa0:	33 1f       	adc	r19, r19
    baa2:	0a 94       	dec	r0
    baa4:	d2 f7       	brpl	.-12     	; 0xba9a <__udivdi3+0x3fa>
    baa6:	0d 8f       	std	Y+29, r16	; 0x1d
    baa8:	1e 8f       	std	Y+30, r17	; 0x1e
    baaa:	2f 8f       	std	Y+31, r18	; 0x1f
    baac:	38 a3       	lds	r19, 0x58
    baae:	0d a1       	lds	r16, 0x4d
    bab0:	1e a1       	lds	r17, 0x4e
    bab2:	2f a1       	lds	r18, 0x4f
    bab4:	38 a5       	lds	r19, 0x68
    bab6:	04 c0       	rjmp	.+8      	; 0xbac0 <__udivdi3+0x420>
    bab8:	36 95       	lsr	r19
    baba:	27 95       	ror	r18
    babc:	17 95       	ror	r17
    babe:	07 95       	ror	r16
    bac0:	4a 95       	dec	r20
    bac2:	d2 f7       	brpl	.-12     	; 0xbab8 <__udivdi3+0x418>
    bac4:	b9 01       	movw	r22, r18
    bac6:	a8 01       	movw	r20, r16
    bac8:	0d 8d       	ldd	r16, Y+29	; 0x1d
    baca:	1e 8d       	ldd	r17, Y+30	; 0x1e
    bacc:	2f 8d       	ldd	r18, Y+31	; 0x1f
    bace:	38 a1       	lds	r19, 0x48
    bad0:	04 2b       	or	r16, r20
    bad2:	15 2b       	or	r17, r21
    bad4:	26 2b       	or	r18, r22
    bad6:	37 2b       	or	r19, r23
    bad8:	0d 8f       	std	Y+29, r16	; 0x1d
    bada:	1e 8f       	std	Y+30, r17	; 0x1e
    badc:	2f 8f       	std	Y+31, r18	; 0x1f
    bade:	38 a3       	lds	r19, 0x58
    bae0:	0d a1       	lds	r16, 0x4d
    bae2:	1e a1       	lds	r17, 0x4e
    bae4:	2f a1       	lds	r18, 0x4f
    bae6:	38 a5       	lds	r19, 0x68
    bae8:	04 c0       	rjmp	.+8      	; 0xbaf2 <__udivdi3+0x452>
    baea:	00 0f       	add	r16, r16
    baec:	11 1f       	adc	r17, r17
    baee:	22 1f       	adc	r18, r18
    baf0:	33 1f       	adc	r19, r19
    baf2:	8a 95       	dec	r24
    baf4:	d2 f7       	brpl	.-12     	; 0xbaea <__udivdi3+0x44a>
    baf6:	0d a3       	lds	r16, 0x5d
    baf8:	1e a3       	lds	r17, 0x5e
    bafa:	2f a3       	lds	r18, 0x5f
    bafc:	38 a7       	lds	r19, 0x78
    bafe:	25 01       	movw	r4, r10
    bb00:	66 24       	eor	r6, r6
    bb02:	77 24       	eor	r7, r7
    bb04:	95 01       	movw	r18, r10
    bb06:	84 01       	movw	r16, r8
    bb08:	20 70       	andi	r18, 0x00	; 0
    bb0a:	30 70       	andi	r19, 0x00	; 0
    bb0c:	09 a7       	lds	r16, 0x79
    bb0e:	1a a7       	lds	r17, 0x7a
    bb10:	2b a7       	lds	r18, 0x7b
    bb12:	3c a7       	lds	r19, 0x7c
    bb14:	69 a1       	lds	r22, 0x49
    bb16:	7a a1       	lds	r23, 0x4a
    bb18:	8b a1       	lds	r24, 0x4b
    bb1a:	9c a1       	lds	r25, 0x4c
    bb1c:	a3 01       	movw	r20, r6
    bb1e:	92 01       	movw	r18, r4
    bb20:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    bb24:	29 8f       	std	Y+25, r18	; 0x19
    bb26:	3a 8f       	std	Y+26, r19	; 0x1a
    bb28:	4b 8f       	std	Y+27, r20	; 0x1b
    bb2a:	5c 8f       	std	Y+28, r21	; 0x1c
    bb2c:	6b 01       	movw	r12, r22
    bb2e:	7c 01       	movw	r14, r24
    bb30:	69 a1       	lds	r22, 0x49
    bb32:	7a a1       	lds	r23, 0x4a
    bb34:	8b a1       	lds	r24, 0x4b
    bb36:	9c a1       	lds	r25, 0x4c
    bb38:	a3 01       	movw	r20, r6
    bb3a:	92 01       	movw	r18, r4
    bb3c:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    bb40:	ca 01       	movw	r24, r20
    bb42:	b9 01       	movw	r22, r18
    bb44:	29 a5       	lds	r18, 0x69
    bb46:	3a a5       	lds	r19, 0x6a
    bb48:	4b a5       	lds	r20, 0x6b
    bb4a:	5c a5       	lds	r21, 0x6c
    bb4c:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    bb50:	ab 01       	movw	r20, r22
    bb52:	bc 01       	movw	r22, r24
    bb54:	76 01       	movw	r14, r12
    bb56:	dd 24       	eor	r13, r13
    bb58:	cc 24       	eor	r12, r12
    bb5a:	0d 8d       	ldd	r16, Y+29	; 0x1d
    bb5c:	1e 8d       	ldd	r17, Y+30	; 0x1e
    bb5e:	2f 8d       	ldd	r18, Y+31	; 0x1f
    bb60:	38 a1       	lds	r19, 0x48
    bb62:	c9 01       	movw	r24, r18
    bb64:	aa 27       	eor	r26, r26
    bb66:	bb 27       	eor	r27, r27
    bb68:	c8 2a       	or	r12, r24
    bb6a:	d9 2a       	or	r13, r25
    bb6c:	ea 2a       	or	r14, r26
    bb6e:	fb 2a       	or	r15, r27
    bb70:	09 8d       	ldd	r16, Y+25	; 0x19
    bb72:	1a 8d       	ldd	r17, Y+26	; 0x1a
    bb74:	2b 8d       	ldd	r18, Y+27	; 0x1b
    bb76:	3c 8d       	ldd	r19, Y+28	; 0x1c
    bb78:	c4 16       	cp	r12, r20
    bb7a:	d5 06       	cpc	r13, r21
    bb7c:	e6 06       	cpc	r14, r22
    bb7e:	f7 06       	cpc	r15, r23
    bb80:	38 f5       	brcc	.+78     	; 0xbbd0 <__udivdi3+0x530>
    bb82:	01 50       	subi	r16, 0x01	; 1
    bb84:	10 40       	sbci	r17, 0x00	; 0
    bb86:	20 40       	sbci	r18, 0x00	; 0
    bb88:	30 40       	sbci	r19, 0x00	; 0
    bb8a:	09 a3       	lds	r16, 0x59
    bb8c:	1a a3       	lds	r17, 0x5a
    bb8e:	2b a3       	lds	r18, 0x5b
    bb90:	3c a3       	lds	r19, 0x5c
    bb92:	c8 0c       	add	r12, r8
    bb94:	d9 1c       	adc	r13, r9
    bb96:	ea 1c       	adc	r14, r10
    bb98:	fb 1c       	adc	r15, r11
    bb9a:	c8 14       	cp	r12, r8
    bb9c:	d9 04       	cpc	r13, r9
    bb9e:	ea 04       	cpc	r14, r10
    bba0:	fb 04       	cpc	r15, r11
    bba2:	d0 f0       	brcs	.+52     	; 0xbbd8 <__udivdi3+0x538>
    bba4:	c4 16       	cp	r12, r20
    bba6:	d5 06       	cpc	r13, r21
    bba8:	e6 06       	cpc	r14, r22
    bbaa:	f7 06       	cpc	r15, r23
    bbac:	a8 f4       	brcc	.+42     	; 0xbbd8 <__udivdi3+0x538>
    bbae:	09 8d       	ldd	r16, Y+25	; 0x19
    bbb0:	1a 8d       	ldd	r17, Y+26	; 0x1a
    bbb2:	2b 8d       	ldd	r18, Y+27	; 0x1b
    bbb4:	3c 8d       	ldd	r19, Y+28	; 0x1c
    bbb6:	02 50       	subi	r16, 0x02	; 2
    bbb8:	10 40       	sbci	r17, 0x00	; 0
    bbba:	20 40       	sbci	r18, 0x00	; 0
    bbbc:	30 40       	sbci	r19, 0x00	; 0
    bbbe:	09 a3       	lds	r16, 0x59
    bbc0:	1a a3       	lds	r17, 0x5a
    bbc2:	2b a3       	lds	r18, 0x5b
    bbc4:	3c a3       	lds	r19, 0x5c
    bbc6:	c8 0c       	add	r12, r8
    bbc8:	d9 1c       	adc	r13, r9
    bbca:	ea 1c       	adc	r14, r10
    bbcc:	fb 1c       	adc	r15, r11
    bbce:	04 c0       	rjmp	.+8      	; 0xbbd8 <__udivdi3+0x538>
    bbd0:	09 a3       	lds	r16, 0x59
    bbd2:	1a a3       	lds	r17, 0x5a
    bbd4:	2b a3       	lds	r18, 0x5b
    bbd6:	3c a3       	lds	r19, 0x5c
    bbd8:	c4 1a       	sub	r12, r20
    bbda:	d5 0a       	sbc	r13, r21
    bbdc:	e6 0a       	sbc	r14, r22
    bbde:	f7 0a       	sbc	r15, r23
    bbe0:	c7 01       	movw	r24, r14
    bbe2:	b6 01       	movw	r22, r12
    bbe4:	a3 01       	movw	r20, r6
    bbe6:	92 01       	movw	r18, r4
    bbe8:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    bbec:	29 8f       	std	Y+25, r18	; 0x19
    bbee:	3a 8f       	std	Y+26, r19	; 0x1a
    bbf0:	4b 8f       	std	Y+27, r20	; 0x1b
    bbf2:	5c 8f       	std	Y+28, r21	; 0x1c
    bbf4:	6d a7       	lds	r22, 0x7d
    bbf6:	7e a7       	lds	r23, 0x7e
    bbf8:	8f a7       	lds	r24, 0x7f
    bbfa:	98 ab       	sts	0x58, r25
    bbfc:	c7 01       	movw	r24, r14
    bbfe:	b6 01       	movw	r22, r12
    bc00:	a3 01       	movw	r20, r6
    bc02:	92 01       	movw	r18, r4
    bc04:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    bc08:	ca 01       	movw	r24, r20
    bc0a:	b9 01       	movw	r22, r18
    bc0c:	29 a5       	lds	r18, 0x69
    bc0e:	3a a5       	lds	r19, 0x6a
    bc10:	4b a5       	lds	r20, 0x6b
    bc12:	5c a5       	lds	r21, 0x6c
    bc14:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    bc18:	8b 01       	movw	r16, r22
    bc1a:	9c 01       	movw	r18, r24
    bc1c:	4d a5       	lds	r20, 0x6d
    bc1e:	5e a5       	lds	r21, 0x6e
    bc20:	6f a5       	lds	r22, 0x6f
    bc22:	78 a9       	sts	0x48, r23
    bc24:	da 01       	movw	r26, r20
    bc26:	99 27       	eor	r25, r25
    bc28:	88 27       	eor	r24, r24
    bc2a:	4d 8d       	ldd	r20, Y+29	; 0x1d
    bc2c:	5e 8d       	ldd	r21, Y+30	; 0x1e
    bc2e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    bc30:	78 a1       	lds	r23, 0x48
    bc32:	60 70       	andi	r22, 0x00	; 0
    bc34:	70 70       	andi	r23, 0x00	; 0
    bc36:	84 2b       	or	r24, r20
    bc38:	95 2b       	or	r25, r21
    bc3a:	a6 2b       	or	r26, r22
    bc3c:	b7 2b       	or	r27, r23
    bc3e:	49 8d       	ldd	r20, Y+25	; 0x19
    bc40:	5a 8d       	ldd	r21, Y+26	; 0x1a
    bc42:	6b 8d       	ldd	r22, Y+27	; 0x1b
    bc44:	7c 8d       	ldd	r23, Y+28	; 0x1c
    bc46:	80 17       	cp	r24, r16
    bc48:	91 07       	cpc	r25, r17
    bc4a:	a2 07       	cpc	r26, r18
    bc4c:	b3 07       	cpc	r27, r19
    bc4e:	f0 f4       	brcc	.+60     	; 0xbc8c <__udivdi3+0x5ec>
    bc50:	41 50       	subi	r20, 0x01	; 1
    bc52:	50 40       	sbci	r21, 0x00	; 0
    bc54:	60 40       	sbci	r22, 0x00	; 0
    bc56:	70 40       	sbci	r23, 0x00	; 0
    bc58:	88 0d       	add	r24, r8
    bc5a:	99 1d       	adc	r25, r9
    bc5c:	aa 1d       	adc	r26, r10
    bc5e:	bb 1d       	adc	r27, r11
    bc60:	88 15       	cp	r24, r8
    bc62:	99 05       	cpc	r25, r9
    bc64:	aa 05       	cpc	r26, r10
    bc66:	bb 05       	cpc	r27, r11
    bc68:	88 f0       	brcs	.+34     	; 0xbc8c <__udivdi3+0x5ec>
    bc6a:	80 17       	cp	r24, r16
    bc6c:	91 07       	cpc	r25, r17
    bc6e:	a2 07       	cpc	r26, r18
    bc70:	b3 07       	cpc	r27, r19
    bc72:	60 f4       	brcc	.+24     	; 0xbc8c <__udivdi3+0x5ec>
    bc74:	49 8d       	ldd	r20, Y+25	; 0x19
    bc76:	5a 8d       	ldd	r21, Y+26	; 0x1a
    bc78:	6b 8d       	ldd	r22, Y+27	; 0x1b
    bc7a:	7c 8d       	ldd	r23, Y+28	; 0x1c
    bc7c:	42 50       	subi	r20, 0x02	; 2
    bc7e:	50 40       	sbci	r21, 0x00	; 0
    bc80:	60 40       	sbci	r22, 0x00	; 0
    bc82:	70 40       	sbci	r23, 0x00	; 0
    bc84:	88 0d       	add	r24, r8
    bc86:	99 1d       	adc	r25, r9
    bc88:	aa 1d       	adc	r26, r10
    bc8a:	bb 1d       	adc	r27, r11
    bc8c:	6c 01       	movw	r12, r24
    bc8e:	7d 01       	movw	r14, r26
    bc90:	c0 1a       	sub	r12, r16
    bc92:	d1 0a       	sbc	r13, r17
    bc94:	e2 0a       	sbc	r14, r18
    bc96:	f3 0a       	sbc	r15, r19
    bc98:	09 a1       	lds	r16, 0x49
    bc9a:	1a a1       	lds	r17, 0x4a
    bc9c:	2b a1       	lds	r18, 0x4b
    bc9e:	3c a1       	lds	r19, 0x4c
    bca0:	38 01       	movw	r6, r16
    bca2:	55 24       	eor	r5, r5
    bca4:	44 24       	eor	r4, r4
    bca6:	44 2a       	or	r4, r20
    bca8:	55 2a       	or	r5, r21
    bcaa:	66 2a       	or	r6, r22
    bcac:	77 2a       	or	r7, r23
    bcae:	85 01       	movw	r16, r10
    bcb0:	22 27       	eor	r18, r18
    bcb2:	33 27       	eor	r19, r19
    bcb4:	0d 8f       	std	Y+29, r16	; 0x1d
    bcb6:	1e 8f       	std	Y+30, r17	; 0x1e
    bcb8:	2f 8f       	std	Y+31, r18	; 0x1f
    bcba:	38 a3       	lds	r19, 0x58
    bcbc:	95 01       	movw	r18, r10
    bcbe:	84 01       	movw	r16, r8
    bcc0:	20 70       	andi	r18, 0x00	; 0
    bcc2:	30 70       	andi	r19, 0x00	; 0
    bcc4:	09 a7       	lds	r16, 0x79
    bcc6:	1a a7       	lds	r17, 0x7a
    bcc8:	2b a7       	lds	r18, 0x7b
    bcca:	3c a7       	lds	r19, 0x7c
    bccc:	c7 01       	movw	r24, r14
    bcce:	b6 01       	movw	r22, r12
    bcd0:	2d 8d       	ldd	r18, Y+29	; 0x1d
    bcd2:	3e 8d       	ldd	r19, Y+30	; 0x1e
    bcd4:	4f 8d       	ldd	r20, Y+31	; 0x1f
    bcd6:	58 a1       	lds	r21, 0x48
    bcd8:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    bcdc:	29 8f       	std	Y+25, r18	; 0x19
    bcde:	3a 8f       	std	Y+26, r19	; 0x1a
    bce0:	4b 8f       	std	Y+27, r20	; 0x1b
    bce2:	5c 8f       	std	Y+28, r21	; 0x1c
    bce4:	69 a3       	lds	r22, 0x59
    bce6:	7a a3       	lds	r23, 0x5a
    bce8:	8b a3       	lds	r24, 0x5b
    bcea:	9c a3       	lds	r25, 0x5c
    bcec:	c7 01       	movw	r24, r14
    bcee:	b6 01       	movw	r22, r12
    bcf0:	2d 8d       	ldd	r18, Y+29	; 0x1d
    bcf2:	3e 8d       	ldd	r19, Y+30	; 0x1e
    bcf4:	4f 8d       	ldd	r20, Y+31	; 0x1f
    bcf6:	58 a1       	lds	r21, 0x48
    bcf8:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    bcfc:	ca 01       	movw	r24, r20
    bcfe:	b9 01       	movw	r22, r18
    bd00:	29 a5       	lds	r18, 0x69
    bd02:	3a a5       	lds	r19, 0x6a
    bd04:	4b a5       	lds	r20, 0x6b
    bd06:	5c a5       	lds	r21, 0x6c
    bd08:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    bd0c:	ab 01       	movw	r20, r22
    bd0e:	bc 01       	movw	r22, r24
    bd10:	09 a1       	lds	r16, 0x49
    bd12:	1a a1       	lds	r17, 0x4a
    bd14:	2b a1       	lds	r18, 0x4b
    bd16:	3c a1       	lds	r19, 0x4c
    bd18:	78 01       	movw	r14, r16
    bd1a:	dd 24       	eor	r13, r13
    bd1c:	cc 24       	eor	r12, r12
    bd1e:	0d a1       	lds	r16, 0x4d
    bd20:	1e a1       	lds	r17, 0x4e
    bd22:	2f a1       	lds	r18, 0x4f
    bd24:	38 a5       	lds	r19, 0x68
    bd26:	c9 01       	movw	r24, r18
    bd28:	aa 27       	eor	r26, r26
    bd2a:	bb 27       	eor	r27, r27
    bd2c:	c8 2a       	or	r12, r24
    bd2e:	d9 2a       	or	r13, r25
    bd30:	ea 2a       	or	r14, r26
    bd32:	fb 2a       	or	r15, r27
    bd34:	09 8d       	ldd	r16, Y+25	; 0x19
    bd36:	1a 8d       	ldd	r17, Y+26	; 0x1a
    bd38:	2b 8d       	ldd	r18, Y+27	; 0x1b
    bd3a:	3c 8d       	ldd	r19, Y+28	; 0x1c
    bd3c:	c4 16       	cp	r12, r20
    bd3e:	d5 06       	cpc	r13, r21
    bd40:	e6 06       	cpc	r14, r22
    bd42:	f7 06       	cpc	r15, r23
    bd44:	38 f5       	brcc	.+78     	; 0xbd94 <__udivdi3+0x6f4>
    bd46:	01 50       	subi	r16, 0x01	; 1
    bd48:	10 40       	sbci	r17, 0x00	; 0
    bd4a:	20 40       	sbci	r18, 0x00	; 0
    bd4c:	30 40       	sbci	r19, 0x00	; 0
    bd4e:	09 a3       	lds	r16, 0x59
    bd50:	1a a3       	lds	r17, 0x5a
    bd52:	2b a3       	lds	r18, 0x5b
    bd54:	3c a3       	lds	r19, 0x5c
    bd56:	c8 0c       	add	r12, r8
    bd58:	d9 1c       	adc	r13, r9
    bd5a:	ea 1c       	adc	r14, r10
    bd5c:	fb 1c       	adc	r15, r11
    bd5e:	c8 14       	cp	r12, r8
    bd60:	d9 04       	cpc	r13, r9
    bd62:	ea 04       	cpc	r14, r10
    bd64:	fb 04       	cpc	r15, r11
    bd66:	d0 f0       	brcs	.+52     	; 0xbd9c <__udivdi3+0x6fc>
    bd68:	c4 16       	cp	r12, r20
    bd6a:	d5 06       	cpc	r13, r21
    bd6c:	e6 06       	cpc	r14, r22
    bd6e:	f7 06       	cpc	r15, r23
    bd70:	a8 f4       	brcc	.+42     	; 0xbd9c <__udivdi3+0x6fc>
    bd72:	09 8d       	ldd	r16, Y+25	; 0x19
    bd74:	1a 8d       	ldd	r17, Y+26	; 0x1a
    bd76:	2b 8d       	ldd	r18, Y+27	; 0x1b
    bd78:	3c 8d       	ldd	r19, Y+28	; 0x1c
    bd7a:	02 50       	subi	r16, 0x02	; 2
    bd7c:	10 40       	sbci	r17, 0x00	; 0
    bd7e:	20 40       	sbci	r18, 0x00	; 0
    bd80:	30 40       	sbci	r19, 0x00	; 0
    bd82:	09 a3       	lds	r16, 0x59
    bd84:	1a a3       	lds	r17, 0x5a
    bd86:	2b a3       	lds	r18, 0x5b
    bd88:	3c a3       	lds	r19, 0x5c
    bd8a:	c8 0c       	add	r12, r8
    bd8c:	d9 1c       	adc	r13, r9
    bd8e:	ea 1c       	adc	r14, r10
    bd90:	fb 1c       	adc	r15, r11
    bd92:	04 c0       	rjmp	.+8      	; 0xbd9c <__udivdi3+0x6fc>
    bd94:	09 a3       	lds	r16, 0x59
    bd96:	1a a3       	lds	r17, 0x5a
    bd98:	2b a3       	lds	r18, 0x5b
    bd9a:	3c a3       	lds	r19, 0x5c
    bd9c:	c4 1a       	sub	r12, r20
    bd9e:	d5 0a       	sbc	r13, r21
    bda0:	e6 0a       	sbc	r14, r22
    bda2:	f7 0a       	sbc	r15, r23
    bda4:	c7 01       	movw	r24, r14
    bda6:	b6 01       	movw	r22, r12
    bda8:	2d 8d       	ldd	r18, Y+29	; 0x1d
    bdaa:	3e 8d       	ldd	r19, Y+30	; 0x1e
    bdac:	4f 8d       	ldd	r20, Y+31	; 0x1f
    bdae:	58 a1       	lds	r21, 0x48
    bdb0:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    bdb4:	29 8f       	std	Y+25, r18	; 0x19
    bdb6:	3a 8f       	std	Y+26, r19	; 0x1a
    bdb8:	4b 8f       	std	Y+27, r20	; 0x1b
    bdba:	5c 8f       	std	Y+28, r21	; 0x1c
    bdbc:	6d a7       	lds	r22, 0x7d
    bdbe:	7e a7       	lds	r23, 0x7e
    bdc0:	8f a7       	lds	r24, 0x7f
    bdc2:	98 ab       	sts	0x58, r25
    bdc4:	c7 01       	movw	r24, r14
    bdc6:	b6 01       	movw	r22, r12
    bdc8:	2d 8d       	ldd	r18, Y+29	; 0x1d
    bdca:	3e 8d       	ldd	r19, Y+30	; 0x1e
    bdcc:	4f 8d       	ldd	r20, Y+31	; 0x1f
    bdce:	58 a1       	lds	r21, 0x48
    bdd0:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    bdd4:	ca 01       	movw	r24, r20
    bdd6:	b9 01       	movw	r22, r18
    bdd8:	29 a5       	lds	r18, 0x69
    bdda:	3a a5       	lds	r19, 0x6a
    bddc:	4b a5       	lds	r20, 0x6b
    bdde:	5c a5       	lds	r21, 0x6c
    bde0:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    bde4:	8b 01       	movw	r16, r22
    bde6:	9c 01       	movw	r18, r24
    bde8:	4d a5       	lds	r20, 0x6d
    bdea:	5e a5       	lds	r21, 0x6e
    bdec:	6f a5       	lds	r22, 0x6f
    bdee:	78 a9       	sts	0x48, r23
    bdf0:	da 01       	movw	r26, r20
    bdf2:	99 27       	eor	r25, r25
    bdf4:	88 27       	eor	r24, r24
    bdf6:	4d a1       	lds	r20, 0x4d
    bdf8:	5e a1       	lds	r21, 0x4e
    bdfa:	6f a1       	lds	r22, 0x4f
    bdfc:	78 a5       	lds	r23, 0x68
    bdfe:	60 70       	andi	r22, 0x00	; 0
    be00:	70 70       	andi	r23, 0x00	; 0
    be02:	84 2b       	or	r24, r20
    be04:	95 2b       	or	r25, r21
    be06:	a6 2b       	or	r26, r22
    be08:	b7 2b       	or	r27, r23
    be0a:	49 8d       	ldd	r20, Y+25	; 0x19
    be0c:	5a 8d       	ldd	r21, Y+26	; 0x1a
    be0e:	6b 8d       	ldd	r22, Y+27	; 0x1b
    be10:	7c 8d       	ldd	r23, Y+28	; 0x1c
    be12:	80 17       	cp	r24, r16
    be14:	91 07       	cpc	r25, r17
    be16:	a2 07       	cpc	r26, r18
    be18:	b3 07       	cpc	r27, r19
    be1a:	d0 f4       	brcc	.+52     	; 0xbe50 <__udivdi3+0x7b0>
    be1c:	41 50       	subi	r20, 0x01	; 1
    be1e:	50 40       	sbci	r21, 0x00	; 0
    be20:	60 40       	sbci	r22, 0x00	; 0
    be22:	70 40       	sbci	r23, 0x00	; 0
    be24:	88 0d       	add	r24, r8
    be26:	99 1d       	adc	r25, r9
    be28:	aa 1d       	adc	r26, r10
    be2a:	bb 1d       	adc	r27, r11
    be2c:	88 15       	cp	r24, r8
    be2e:	99 05       	cpc	r25, r9
    be30:	aa 05       	cpc	r26, r10
    be32:	bb 05       	cpc	r27, r11
    be34:	68 f0       	brcs	.+26     	; 0xbe50 <__udivdi3+0x7b0>
    be36:	80 17       	cp	r24, r16
    be38:	91 07       	cpc	r25, r17
    be3a:	a2 07       	cpc	r26, r18
    be3c:	b3 07       	cpc	r27, r19
    be3e:	40 f4       	brcc	.+16     	; 0xbe50 <__udivdi3+0x7b0>
    be40:	49 8d       	ldd	r20, Y+25	; 0x19
    be42:	5a 8d       	ldd	r21, Y+26	; 0x1a
    be44:	6b 8d       	ldd	r22, Y+27	; 0x1b
    be46:	7c 8d       	ldd	r23, Y+28	; 0x1c
    be48:	42 50       	subi	r20, 0x02	; 2
    be4a:	50 40       	sbci	r21, 0x00	; 0
    be4c:	60 40       	sbci	r22, 0x00	; 0
    be4e:	70 40       	sbci	r23, 0x00	; 0
    be50:	09 a1       	lds	r16, 0x49
    be52:	1a a1       	lds	r17, 0x4a
    be54:	2b a1       	lds	r18, 0x4b
    be56:	3c a1       	lds	r19, 0x4c
    be58:	78 01       	movw	r14, r16
    be5a:	dd 24       	eor	r13, r13
    be5c:	cc 24       	eor	r12, r12
    be5e:	c4 2a       	or	r12, r20
    be60:	d5 2a       	or	r13, r21
    be62:	e6 2a       	or	r14, r22
    be64:	f7 2a       	or	r15, r23
    be66:	46 c2       	rjmp	.+1164   	; 0xc2f4 <__udivdi3+0xc54>
    be68:	c8 16       	cp	r12, r24
    be6a:	d9 06       	cpc	r13, r25
    be6c:	ea 06       	cpc	r14, r26
    be6e:	fb 06       	cpc	r15, r27
    be70:	08 f4       	brcc	.+2      	; 0xbe74 <__udivdi3+0x7d4>
    be72:	2d c2       	rjmp	.+1114   	; 0xc2ce <__udivdi3+0xc2e>
    be74:	80 30       	cpi	r24, 0x00	; 0
    be76:	10 e0       	ldi	r17, 0x00	; 0
    be78:	91 07       	cpc	r25, r17
    be7a:	11 e0       	ldi	r17, 0x01	; 1
    be7c:	a1 07       	cpc	r26, r17
    be7e:	10 e0       	ldi	r17, 0x00	; 0
    be80:	b1 07       	cpc	r27, r17
    be82:	50 f4       	brcc	.+20     	; 0xbe98 <__udivdi3+0x7f8>
    be84:	8f 3f       	cpi	r24, 0xFF	; 255
    be86:	91 05       	cpc	r25, r1
    be88:	a1 05       	cpc	r26, r1
    be8a:	b1 05       	cpc	r27, r1
    be8c:	09 f0       	breq	.+2      	; 0xbe90 <__udivdi3+0x7f0>
    be8e:	88 f4       	brcc	.+34     	; 0xbeb2 <__udivdi3+0x812>
    be90:	00 e0       	ldi	r16, 0x00	; 0
    be92:	10 e0       	ldi	r17, 0x00	; 0
    be94:	98 01       	movw	r18, r16
    be96:	16 c0       	rjmp	.+44     	; 0xbec4 <__udivdi3+0x824>
    be98:	80 30       	cpi	r24, 0x00	; 0
    be9a:	20 e0       	ldi	r18, 0x00	; 0
    be9c:	92 07       	cpc	r25, r18
    be9e:	20 e0       	ldi	r18, 0x00	; 0
    bea0:	a2 07       	cpc	r26, r18
    bea2:	21 e0       	ldi	r18, 0x01	; 1
    bea4:	b2 07       	cpc	r27, r18
    bea6:	50 f4       	brcc	.+20     	; 0xbebc <__udivdi3+0x81c>
    bea8:	00 e1       	ldi	r16, 0x10	; 16
    beaa:	10 e0       	ldi	r17, 0x00	; 0
    beac:	20 e0       	ldi	r18, 0x00	; 0
    beae:	30 e0       	ldi	r19, 0x00	; 0
    beb0:	09 c0       	rjmp	.+18     	; 0xbec4 <__udivdi3+0x824>
    beb2:	08 e0       	ldi	r16, 0x08	; 8
    beb4:	10 e0       	ldi	r17, 0x00	; 0
    beb6:	20 e0       	ldi	r18, 0x00	; 0
    beb8:	30 e0       	ldi	r19, 0x00	; 0
    beba:	04 c0       	rjmp	.+8      	; 0xbec4 <__udivdi3+0x824>
    bebc:	08 e1       	ldi	r16, 0x18	; 24
    bebe:	10 e0       	ldi	r17, 0x00	; 0
    bec0:	20 e0       	ldi	r18, 0x00	; 0
    bec2:	30 e0       	ldi	r19, 0x00	; 0
    bec4:	ac 01       	movw	r20, r24
    bec6:	bd 01       	movw	r22, r26
    bec8:	00 2e       	mov	r0, r16
    beca:	04 c0       	rjmp	.+8      	; 0xbed4 <__udivdi3+0x834>
    becc:	76 95       	lsr	r23
    bece:	67 95       	ror	r22
    bed0:	57 95       	ror	r21
    bed2:	47 95       	ror	r20
    bed4:	0a 94       	dec	r0
    bed6:	d2 f7       	brpl	.-12     	; 0xbecc <__udivdi3+0x82c>
    bed8:	fa 01       	movw	r30, r20
    beda:	ea 5d       	subi	r30, 0xDA	; 218
    bedc:	ff 4d       	sbci	r31, 0xDF	; 223
    bede:	40 81       	ld	r20, Z
    bee0:	04 0f       	add	r16, r20
    bee2:	11 1d       	adc	r17, r1
    bee4:	21 1d       	adc	r18, r1
    bee6:	31 1d       	adc	r19, r1
    bee8:	40 e2       	ldi	r20, 0x20	; 32
    beea:	50 e0       	ldi	r21, 0x00	; 0
    beec:	60 e0       	ldi	r22, 0x00	; 0
    beee:	70 e0       	ldi	r23, 0x00	; 0
    bef0:	40 1b       	sub	r20, r16
    bef2:	51 0b       	sbc	r21, r17
    bef4:	62 0b       	sbc	r22, r18
    bef6:	73 0b       	sbc	r23, r19
    bef8:	a1 f4       	brne	.+40     	; 0xbf22 <__udivdi3+0x882>
    befa:	8c 15       	cp	r24, r12
    befc:	9d 05       	cpc	r25, r13
    befe:	ae 05       	cpc	r26, r14
    bf00:	bf 05       	cpc	r27, r15
    bf02:	08 f4       	brcc	.+2      	; 0xbf06 <__udivdi3+0x866>
    bf04:	eb c1       	rjmp	.+982    	; 0xc2dc <__udivdi3+0xc3c>
    bf06:	0d a1       	lds	r16, 0x4d
    bf08:	1e a1       	lds	r17, 0x4e
    bf0a:	2f a1       	lds	r18, 0x4f
    bf0c:	38 a5       	lds	r19, 0x68
    bf0e:	44 24       	eor	r4, r4
    bf10:	55 24       	eor	r5, r5
    bf12:	32 01       	movw	r6, r4
    bf14:	08 15       	cp	r16, r8
    bf16:	19 05       	cpc	r17, r9
    bf18:	2a 05       	cpc	r18, r10
    bf1a:	3b 05       	cpc	r19, r11
    bf1c:	08 f0       	brcs	.+2      	; 0xbf20 <__udivdi3+0x880>
    bf1e:	e1 c1       	rjmp	.+962    	; 0xc2e2 <__udivdi3+0xc42>
    bf20:	d9 c1       	rjmp	.+946    	; 0xc2d4 <__udivdi3+0xc34>
    bf22:	34 2e       	mov	r3, r20
    bf24:	2c 01       	movw	r4, r24
    bf26:	3d 01       	movw	r6, r26
    bf28:	04 c0       	rjmp	.+8      	; 0xbf32 <__udivdi3+0x892>
    bf2a:	44 0c       	add	r4, r4
    bf2c:	55 1c       	adc	r5, r5
    bf2e:	66 1c       	adc	r6, r6
    bf30:	77 1c       	adc	r7, r7
    bf32:	4a 95       	dec	r20
    bf34:	d2 f7       	brpl	.-12     	; 0xbf2a <__udivdi3+0x88a>
    bf36:	d5 01       	movw	r26, r10
    bf38:	c4 01       	movw	r24, r8
    bf3a:	00 2e       	mov	r0, r16
    bf3c:	04 c0       	rjmp	.+8      	; 0xbf46 <__udivdi3+0x8a6>
    bf3e:	b6 95       	lsr	r27
    bf40:	a7 95       	ror	r26
    bf42:	97 95       	ror	r25
    bf44:	87 95       	ror	r24
    bf46:	0a 94       	dec	r0
    bf48:	d2 f7       	brpl	.-12     	; 0xbf3e <__udivdi3+0x89e>
    bf4a:	48 2a       	or	r4, r24
    bf4c:	59 2a       	or	r5, r25
    bf4e:	6a 2a       	or	r6, r26
    bf50:	7b 2a       	or	r7, r27
    bf52:	a5 01       	movw	r20, r10
    bf54:	94 01       	movw	r18, r8
    bf56:	03 2c       	mov	r0, r3
    bf58:	04 c0       	rjmp	.+8      	; 0xbf62 <__udivdi3+0x8c2>
    bf5a:	22 0f       	add	r18, r18
    bf5c:	33 1f       	adc	r19, r19
    bf5e:	44 1f       	adc	r20, r20
    bf60:	55 1f       	adc	r21, r21
    bf62:	0a 94       	dec	r0
    bf64:	d2 f7       	brpl	.-12     	; 0xbf5a <__udivdi3+0x8ba>
    bf66:	29 a7       	lds	r18, 0x79
    bf68:	3a a7       	lds	r19, 0x7a
    bf6a:	4b a7       	lds	r20, 0x7b
    bf6c:	5c a7       	lds	r21, 0x7c
    bf6e:	b7 01       	movw	r22, r14
    bf70:	a6 01       	movw	r20, r12
    bf72:	00 2e       	mov	r0, r16
    bf74:	04 c0       	rjmp	.+8      	; 0xbf7e <__udivdi3+0x8de>
    bf76:	76 95       	lsr	r23
    bf78:	67 95       	ror	r22
    bf7a:	57 95       	ror	r21
    bf7c:	47 95       	ror	r20
    bf7e:	0a 94       	dec	r0
    bf80:	d2 f7       	brpl	.-12     	; 0xbf76 <__udivdi3+0x8d6>
    bf82:	49 a3       	lds	r20, 0x59
    bf84:	5a a3       	lds	r21, 0x5a
    bf86:	6b a3       	lds	r22, 0x5b
    bf88:	7c a3       	lds	r23, 0x5c
    bf8a:	c7 01       	movw	r24, r14
    bf8c:	b6 01       	movw	r22, r12
    bf8e:	03 2c       	mov	r0, r3
    bf90:	04 c0       	rjmp	.+8      	; 0xbf9a <__udivdi3+0x8fa>
    bf92:	66 0f       	add	r22, r22
    bf94:	77 1f       	adc	r23, r23
    bf96:	88 1f       	adc	r24, r24
    bf98:	99 1f       	adc	r25, r25
    bf9a:	0a 94       	dec	r0
    bf9c:	d2 f7       	brpl	.-12     	; 0xbf92 <__udivdi3+0x8f2>
    bf9e:	6d 8f       	std	Y+29, r22	; 0x1d
    bfa0:	7e 8f       	std	Y+30, r23	; 0x1e
    bfa2:	8f 8f       	std	Y+31, r24	; 0x1f
    bfa4:	98 a3       	lds	r25, 0x58
    bfa6:	8d a1       	lds	r24, 0x4d
    bfa8:	9e a1       	lds	r25, 0x4e
    bfaa:	af a1       	lds	r26, 0x4f
    bfac:	b8 a5       	lds	r27, 0x68
    bfae:	04 c0       	rjmp	.+8      	; 0xbfb8 <__udivdi3+0x918>
    bfb0:	b6 95       	lsr	r27
    bfb2:	a7 95       	ror	r26
    bfb4:	97 95       	ror	r25
    bfb6:	87 95       	ror	r24
    bfb8:	0a 95       	dec	r16
    bfba:	d2 f7       	brpl	.-12     	; 0xbfb0 <__udivdi3+0x910>
    bfbc:	4d 8d       	ldd	r20, Y+29	; 0x1d
    bfbe:	5e 8d       	ldd	r21, Y+30	; 0x1e
    bfc0:	6f 8d       	ldd	r22, Y+31	; 0x1f
    bfc2:	78 a1       	lds	r23, 0x48
    bfc4:	48 2b       	or	r20, r24
    bfc6:	59 2b       	or	r21, r25
    bfc8:	6a 2b       	or	r22, r26
    bfca:	7b 2b       	or	r23, r27
    bfcc:	4d 8f       	std	Y+29, r20	; 0x1d
    bfce:	5e 8f       	std	Y+30, r21	; 0x1e
    bfd0:	6f 8f       	std	Y+31, r22	; 0x1f
    bfd2:	78 a3       	lds	r23, 0x58
    bfd4:	43 01       	movw	r8, r6
    bfd6:	aa 24       	eor	r10, r10
    bfd8:	bb 24       	eor	r11, r11
    bfda:	93 01       	movw	r18, r6
    bfdc:	82 01       	movw	r16, r4
    bfde:	20 70       	andi	r18, 0x00	; 0
    bfe0:	30 70       	andi	r19, 0x00	; 0
    bfe2:	0d a7       	lds	r16, 0x7d
    bfe4:	1e a7       	lds	r17, 0x7e
    bfe6:	2f a7       	lds	r18, 0x7f
    bfe8:	38 ab       	sts	0x58, r19
    bfea:	69 a1       	lds	r22, 0x49
    bfec:	7a a1       	lds	r23, 0x4a
    bfee:	8b a1       	lds	r24, 0x4b
    bff0:	9c a1       	lds	r25, 0x4c
    bff2:	a5 01       	movw	r20, r10
    bff4:	94 01       	movw	r18, r8
    bff6:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    bffa:	29 8f       	std	Y+25, r18	; 0x19
    bffc:	3a 8f       	std	Y+26, r19	; 0x1a
    bffe:	4b 8f       	std	Y+27, r20	; 0x1b
    c000:	5c 8f       	std	Y+28, r21	; 0x1c
    c002:	6b 01       	movw	r12, r22
    c004:	7c 01       	movw	r14, r24
    c006:	69 a1       	lds	r22, 0x49
    c008:	7a a1       	lds	r23, 0x4a
    c00a:	8b a1       	lds	r24, 0x4b
    c00c:	9c a1       	lds	r25, 0x4c
    c00e:	a5 01       	movw	r20, r10
    c010:	94 01       	movw	r18, r8
    c012:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    c016:	ca 01       	movw	r24, r20
    c018:	b9 01       	movw	r22, r18
    c01a:	2d a5       	lds	r18, 0x6d
    c01c:	3e a5       	lds	r19, 0x6e
    c01e:	4f a5       	lds	r20, 0x6f
    c020:	58 a9       	sts	0x48, r21
    c022:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    c026:	dc 01       	movw	r26, r24
    c028:	cb 01       	movw	r24, r22
    c02a:	76 01       	movw	r14, r12
    c02c:	dd 24       	eor	r13, r13
    c02e:	cc 24       	eor	r12, r12
    c030:	0d 8d       	ldd	r16, Y+29	; 0x1d
    c032:	1e 8d       	ldd	r17, Y+30	; 0x1e
    c034:	2f 8d       	ldd	r18, Y+31	; 0x1f
    c036:	38 a1       	lds	r19, 0x48
    c038:	a9 01       	movw	r20, r18
    c03a:	66 27       	eor	r22, r22
    c03c:	77 27       	eor	r23, r23
    c03e:	c4 2a       	or	r12, r20
    c040:	d5 2a       	or	r13, r21
    c042:	e6 2a       	or	r14, r22
    c044:	f7 2a       	or	r15, r23
    c046:	09 8d       	ldd	r16, Y+25	; 0x19
    c048:	1a 8d       	ldd	r17, Y+26	; 0x1a
    c04a:	2b 8d       	ldd	r18, Y+27	; 0x1b
    c04c:	3c 8d       	ldd	r19, Y+28	; 0x1c
    c04e:	c8 16       	cp	r12, r24
    c050:	d9 06       	cpc	r13, r25
    c052:	ea 06       	cpc	r14, r26
    c054:	fb 06       	cpc	r15, r27
    c056:	38 f5       	brcc	.+78     	; 0xc0a6 <__udivdi3+0xa06>
    c058:	01 50       	subi	r16, 0x01	; 1
    c05a:	10 40       	sbci	r17, 0x00	; 0
    c05c:	20 40       	sbci	r18, 0x00	; 0
    c05e:	30 40       	sbci	r19, 0x00	; 0
    c060:	09 a3       	lds	r16, 0x59
    c062:	1a a3       	lds	r17, 0x5a
    c064:	2b a3       	lds	r18, 0x5b
    c066:	3c a3       	lds	r19, 0x5c
    c068:	c4 0c       	add	r12, r4
    c06a:	d5 1c       	adc	r13, r5
    c06c:	e6 1c       	adc	r14, r6
    c06e:	f7 1c       	adc	r15, r7
    c070:	c4 14       	cp	r12, r4
    c072:	d5 04       	cpc	r13, r5
    c074:	e6 04       	cpc	r14, r6
    c076:	f7 04       	cpc	r15, r7
    c078:	d0 f0       	brcs	.+52     	; 0xc0ae <__udivdi3+0xa0e>
    c07a:	c8 16       	cp	r12, r24
    c07c:	d9 06       	cpc	r13, r25
    c07e:	ea 06       	cpc	r14, r26
    c080:	fb 06       	cpc	r15, r27
    c082:	a8 f4       	brcc	.+42     	; 0xc0ae <__udivdi3+0xa0e>
    c084:	09 8d       	ldd	r16, Y+25	; 0x19
    c086:	1a 8d       	ldd	r17, Y+26	; 0x1a
    c088:	2b 8d       	ldd	r18, Y+27	; 0x1b
    c08a:	3c 8d       	ldd	r19, Y+28	; 0x1c
    c08c:	02 50       	subi	r16, 0x02	; 2
    c08e:	10 40       	sbci	r17, 0x00	; 0
    c090:	20 40       	sbci	r18, 0x00	; 0
    c092:	30 40       	sbci	r19, 0x00	; 0
    c094:	09 a3       	lds	r16, 0x59
    c096:	1a a3       	lds	r17, 0x5a
    c098:	2b a3       	lds	r18, 0x5b
    c09a:	3c a3       	lds	r19, 0x5c
    c09c:	c4 0c       	add	r12, r4
    c09e:	d5 1c       	adc	r13, r5
    c0a0:	e6 1c       	adc	r14, r6
    c0a2:	f7 1c       	adc	r15, r7
    c0a4:	04 c0       	rjmp	.+8      	; 0xc0ae <__udivdi3+0xa0e>
    c0a6:	09 a3       	lds	r16, 0x59
    c0a8:	1a a3       	lds	r17, 0x5a
    c0aa:	2b a3       	lds	r18, 0x5b
    c0ac:	3c a3       	lds	r19, 0x5c
    c0ae:	c8 1a       	sub	r12, r24
    c0b0:	d9 0a       	sbc	r13, r25
    c0b2:	ea 0a       	sbc	r14, r26
    c0b4:	fb 0a       	sbc	r15, r27
    c0b6:	c7 01       	movw	r24, r14
    c0b8:	b6 01       	movw	r22, r12
    c0ba:	a5 01       	movw	r20, r10
    c0bc:	94 01       	movw	r18, r8
    c0be:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    c0c2:	29 8f       	std	Y+25, r18	; 0x19
    c0c4:	3a 8f       	std	Y+26, r19	; 0x1a
    c0c6:	4b 8f       	std	Y+27, r20	; 0x1b
    c0c8:	5c 8f       	std	Y+28, r21	; 0x1c
    c0ca:	69 ab       	sts	0x59, r22
    c0cc:	7a ab       	sts	0x5a, r23
    c0ce:	8b ab       	sts	0x5b, r24
    c0d0:	9c ab       	sts	0x5c, r25
    c0d2:	c7 01       	movw	r24, r14
    c0d4:	b6 01       	movw	r22, r12
    c0d6:	a5 01       	movw	r20, r10
    c0d8:	94 01       	movw	r18, r8
    c0da:	0e 94 4f 63 	call	0xc69e	; 0xc69e <__udivmodsi4>
    c0de:	ca 01       	movw	r24, r20
    c0e0:	b9 01       	movw	r22, r18
    c0e2:	2d a5       	lds	r18, 0x6d
    c0e4:	3e a5       	lds	r19, 0x6e
    c0e6:	4f a5       	lds	r20, 0x6f
    c0e8:	58 a9       	sts	0x48, r21
    c0ea:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    c0ee:	4b 01       	movw	r8, r22
    c0f0:	5c 01       	movw	r10, r24
    c0f2:	49 a9       	sts	0x49, r20
    c0f4:	5a a9       	sts	0x4a, r21
    c0f6:	6b a9       	sts	0x4b, r22
    c0f8:	7c a9       	sts	0x4c, r23
    c0fa:	9a 01       	movw	r18, r20
    c0fc:	11 27       	eor	r17, r17
    c0fe:	00 27       	eor	r16, r16
    c100:	8d 8d       	ldd	r24, Y+29	; 0x1d
    c102:	9e 8d       	ldd	r25, Y+30	; 0x1e
    c104:	af 8d       	ldd	r26, Y+31	; 0x1f
    c106:	b8 a1       	lds	r27, 0x48
    c108:	a0 70       	andi	r26, 0x00	; 0
    c10a:	b0 70       	andi	r27, 0x00	; 0
    c10c:	08 2b       	or	r16, r24
    c10e:	19 2b       	or	r17, r25
    c110:	2a 2b       	or	r18, r26
    c112:	3b 2b       	or	r19, r27
    c114:	89 8d       	ldd	r24, Y+25	; 0x19
    c116:	9a 8d       	ldd	r25, Y+26	; 0x1a
    c118:	ab 8d       	ldd	r26, Y+27	; 0x1b
    c11a:	bc 8d       	ldd	r27, Y+28	; 0x1c
    c11c:	08 15       	cp	r16, r8
    c11e:	19 05       	cpc	r17, r9
    c120:	2a 05       	cpc	r18, r10
    c122:	3b 05       	cpc	r19, r11
    c124:	e0 f4       	brcc	.+56     	; 0xc15e <__udivdi3+0xabe>
    c126:	01 97       	sbiw	r24, 0x01	; 1
    c128:	a1 09       	sbc	r26, r1
    c12a:	b1 09       	sbc	r27, r1
    c12c:	04 0d       	add	r16, r4
    c12e:	15 1d       	adc	r17, r5
    c130:	26 1d       	adc	r18, r6
    c132:	37 1d       	adc	r19, r7
    c134:	04 15       	cp	r16, r4
    c136:	15 05       	cpc	r17, r5
    c138:	26 05       	cpc	r18, r6
    c13a:	37 05       	cpc	r19, r7
    c13c:	80 f0       	brcs	.+32     	; 0xc15e <__udivdi3+0xabe>
    c13e:	08 15       	cp	r16, r8
    c140:	19 05       	cpc	r17, r9
    c142:	2a 05       	cpc	r18, r10
    c144:	3b 05       	cpc	r19, r11
    c146:	58 f4       	brcc	.+22     	; 0xc15e <__udivdi3+0xabe>
    c148:	89 8d       	ldd	r24, Y+25	; 0x19
    c14a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    c14c:	ab 8d       	ldd	r26, Y+27	; 0x1b
    c14e:	bc 8d       	ldd	r27, Y+28	; 0x1c
    c150:	02 97       	sbiw	r24, 0x02	; 2
    c152:	a1 09       	sbc	r26, r1
    c154:	b1 09       	sbc	r27, r1
    c156:	04 0d       	add	r16, r4
    c158:	15 1d       	adc	r17, r5
    c15a:	26 1d       	adc	r18, r6
    c15c:	37 1d       	adc	r19, r7
    c15e:	b9 01       	movw	r22, r18
    c160:	a8 01       	movw	r20, r16
    c162:	48 19       	sub	r20, r8
    c164:	59 09       	sbc	r21, r9
    c166:	6a 09       	sbc	r22, r10
    c168:	7b 09       	sbc	r23, r11
    c16a:	4d 8f       	std	Y+29, r20	; 0x1d
    c16c:	5e 8f       	std	Y+30, r21	; 0x1e
    c16e:	6f 8f       	std	Y+31, r22	; 0x1f
    c170:	78 a3       	lds	r23, 0x58
    c172:	09 a1       	lds	r16, 0x49
    c174:	1a a1       	lds	r17, 0x4a
    c176:	2b a1       	lds	r18, 0x4b
    c178:	3c a1       	lds	r19, 0x4c
    c17a:	78 01       	movw	r14, r16
    c17c:	dd 24       	eor	r13, r13
    c17e:	cc 24       	eor	r12, r12
    c180:	c8 2a       	or	r12, r24
    c182:	d9 2a       	or	r13, r25
    c184:	ea 2a       	or	r14, r26
    c186:	fb 2a       	or	r15, r27
    c188:	ff ef       	ldi	r31, 0xFF	; 255
    c18a:	8f 2e       	mov	r8, r31
    c18c:	ff ef       	ldi	r31, 0xFF	; 255
    c18e:	9f 2e       	mov	r9, r31
    c190:	a1 2c       	mov	r10, r1
    c192:	b1 2c       	mov	r11, r1
    c194:	8c 20       	and	r8, r12
    c196:	9d 20       	and	r9, r13
    c198:	ae 20       	and	r10, r14
    c19a:	bf 20       	and	r11, r15
    c19c:	87 01       	movw	r16, r14
    c19e:	22 27       	eor	r18, r18
    c1a0:	33 27       	eor	r19, r19
    c1a2:	09 8f       	std	Y+25, r16	; 0x19
    c1a4:	1a 8f       	std	Y+26, r17	; 0x1a
    c1a6:	2b 8f       	std	Y+27, r18	; 0x1b
    c1a8:	3c 8f       	std	Y+28, r19	; 0x1c
    c1aa:	49 a4       	lds	r20, 0xa9
    c1ac:	5a a4       	lds	r21, 0xaa
    c1ae:	6b a4       	lds	r22, 0xab
    c1b0:	7c a4       	lds	r23, 0xac
    c1b2:	2f ef       	ldi	r18, 0xFF	; 255
    c1b4:	3f ef       	ldi	r19, 0xFF	; 255
    c1b6:	40 e0       	ldi	r20, 0x00	; 0
    c1b8:	50 e0       	ldi	r21, 0x00	; 0
    c1ba:	42 22       	and	r4, r18
    c1bc:	53 22       	and	r5, r19
    c1be:	64 22       	and	r6, r20
    c1c0:	75 22       	and	r7, r21
    c1c2:	29 a5       	lds	r18, 0x69
    c1c4:	3a a5       	lds	r19, 0x6a
    c1c6:	4b a5       	lds	r20, 0x6b
    c1c8:	5c a5       	lds	r21, 0x6c
    c1ca:	8a 01       	movw	r16, r20
    c1cc:	22 27       	eor	r18, r18
    c1ce:	33 27       	eor	r19, r19
    c1d0:	09 a3       	lds	r16, 0x59
    c1d2:	1a a3       	lds	r17, 0x5a
    c1d4:	2b a3       	lds	r18, 0x5b
    c1d6:	3c a3       	lds	r19, 0x5c
    c1d8:	c5 01       	movw	r24, r10
    c1da:	b4 01       	movw	r22, r8
    c1dc:	a3 01       	movw	r20, r6
    c1de:	92 01       	movw	r18, r4
    c1e0:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    c1e4:	69 a7       	lds	r22, 0x79
    c1e6:	7a a7       	lds	r23, 0x7a
    c1e8:	8b a7       	lds	r24, 0x7b
    c1ea:	9c a7       	lds	r25, 0x7c
    c1ec:	c5 01       	movw	r24, r10
    c1ee:	b4 01       	movw	r22, r8
    c1f0:	29 a1       	lds	r18, 0x49
    c1f2:	3a a1       	lds	r19, 0x4a
    c1f4:	4b a1       	lds	r20, 0x4b
    c1f6:	5c a1       	lds	r21, 0x4c
    c1f8:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    c1fc:	4b 01       	movw	r8, r22
    c1fe:	5c 01       	movw	r10, r24
    c200:	69 8d       	ldd	r22, Y+25	; 0x19
    c202:	7a 8d       	ldd	r23, Y+26	; 0x1a
    c204:	8b 8d       	ldd	r24, Y+27	; 0x1b
    c206:	9c 8d       	ldd	r25, Y+28	; 0x1c
    c208:	a3 01       	movw	r20, r6
    c20a:	92 01       	movw	r18, r4
    c20c:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    c210:	2b 01       	movw	r4, r22
    c212:	3c 01       	movw	r6, r24
    c214:	69 8d       	ldd	r22, Y+25	; 0x19
    c216:	7a 8d       	ldd	r23, Y+26	; 0x1a
    c218:	8b 8d       	ldd	r24, Y+27	; 0x1b
    c21a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    c21c:	29 a1       	lds	r18, 0x49
    c21e:	3a a1       	lds	r19, 0x4a
    c220:	4b a1       	lds	r20, 0x4b
    c222:	5c a1       	lds	r21, 0x4c
    c224:	0e 94 09 63 	call	0xc612	; 0xc612 <__mulsi3>
    c228:	ab 01       	movw	r20, r22
    c22a:	bc 01       	movw	r22, r24
    c22c:	84 0c       	add	r8, r4
    c22e:	95 1c       	adc	r9, r5
    c230:	a6 1c       	adc	r10, r6
    c232:	b7 1c       	adc	r11, r7
    c234:	09 a5       	lds	r16, 0x69
    c236:	1a a5       	lds	r17, 0x6a
    c238:	2b a5       	lds	r18, 0x6b
    c23a:	3c a5       	lds	r19, 0x6c
    c23c:	c9 01       	movw	r24, r18
    c23e:	aa 27       	eor	r26, r26
    c240:	bb 27       	eor	r27, r27
    c242:	88 0e       	add	r8, r24
    c244:	99 1e       	adc	r9, r25
    c246:	aa 1e       	adc	r10, r26
    c248:	bb 1e       	adc	r11, r27
    c24a:	84 14       	cp	r8, r4
    c24c:	95 04       	cpc	r9, r5
    c24e:	a6 04       	cpc	r10, r6
    c250:	b7 04       	cpc	r11, r7
    c252:	20 f4       	brcc	.+8      	; 0xc25c <__udivdi3+0xbbc>
    c254:	40 50       	subi	r20, 0x00	; 0
    c256:	50 40       	sbci	r21, 0x00	; 0
    c258:	6f 4f       	sbci	r22, 0xFF	; 255
    c25a:	7f 4f       	sbci	r23, 0xFF	; 255
    c25c:	c5 01       	movw	r24, r10
    c25e:	aa 27       	eor	r26, r26
    c260:	bb 27       	eor	r27, r27
    c262:	84 0f       	add	r24, r20
    c264:	95 1f       	adc	r25, r21
    c266:	a6 1f       	adc	r26, r22
    c268:	b7 1f       	adc	r27, r23
    c26a:	0d 8d       	ldd	r16, Y+29	; 0x1d
    c26c:	1e 8d       	ldd	r17, Y+30	; 0x1e
    c26e:	2f 8d       	ldd	r18, Y+31	; 0x1f
    c270:	38 a1       	lds	r19, 0x48
    c272:	08 17       	cp	r16, r24
    c274:	19 07       	cpc	r17, r25
    c276:	2a 07       	cpc	r18, r26
    c278:	3b 07       	cpc	r19, r27
    c27a:	18 f1       	brcs	.+70     	; 0xc2c2 <__udivdi3+0xc22>
    c27c:	80 17       	cp	r24, r16
    c27e:	91 07       	cpc	r25, r17
    c280:	a2 07       	cpc	r26, r18
    c282:	b3 07       	cpc	r27, r19
    c284:	a1 f5       	brne	.+104    	; 0xc2ee <__udivdi3+0xc4e>
    c286:	54 01       	movw	r10, r8
    c288:	99 24       	eor	r9, r9
    c28a:	88 24       	eor	r8, r8
    c28c:	89 a5       	lds	r24, 0x69
    c28e:	9a a5       	lds	r25, 0x6a
    c290:	ab a5       	lds	r26, 0x6b
    c292:	bc a5       	lds	r27, 0x6c
    c294:	a0 70       	andi	r26, 0x00	; 0
    c296:	b0 70       	andi	r27, 0x00	; 0
    c298:	88 0e       	add	r8, r24
    c29a:	99 1e       	adc	r9, r25
    c29c:	aa 1e       	adc	r10, r26
    c29e:	bb 1e       	adc	r11, r27
    c2a0:	4d a1       	lds	r20, 0x4d
    c2a2:	5e a1       	lds	r21, 0x4e
    c2a4:	6f a1       	lds	r22, 0x4f
    c2a6:	78 a5       	lds	r23, 0x68
    c2a8:	03 2c       	mov	r0, r3
    c2aa:	04 c0       	rjmp	.+8      	; 0xc2b4 <__udivdi3+0xc14>
    c2ac:	44 0f       	add	r20, r20
    c2ae:	55 1f       	adc	r21, r21
    c2b0:	66 1f       	adc	r22, r22
    c2b2:	77 1f       	adc	r23, r23
    c2b4:	0a 94       	dec	r0
    c2b6:	d2 f7       	brpl	.-12     	; 0xc2ac <__udivdi3+0xc0c>
    c2b8:	48 15       	cp	r20, r8
    c2ba:	59 05       	cpc	r21, r9
    c2bc:	6a 05       	cpc	r22, r10
    c2be:	7b 05       	cpc	r23, r11
    c2c0:	b0 f4       	brcc	.+44     	; 0xc2ee <__udivdi3+0xc4e>
    c2c2:	08 94       	sec
    c2c4:	c1 08       	sbc	r12, r1
    c2c6:	d1 08       	sbc	r13, r1
    c2c8:	e1 08       	sbc	r14, r1
    c2ca:	f1 08       	sbc	r15, r1
    c2cc:	10 c0       	rjmp	.+32     	; 0xc2ee <__udivdi3+0xc4e>
    c2ce:	44 24       	eor	r4, r4
    c2d0:	55 24       	eor	r5, r5
    c2d2:	32 01       	movw	r6, r4
    c2d4:	cc 24       	eor	r12, r12
    c2d6:	dd 24       	eor	r13, r13
    c2d8:	76 01       	movw	r14, r12
    c2da:	0c c0       	rjmp	.+24     	; 0xc2f4 <__udivdi3+0xc54>
    c2dc:	44 24       	eor	r4, r4
    c2de:	55 24       	eor	r5, r5
    c2e0:	32 01       	movw	r6, r4
    c2e2:	81 e0       	ldi	r24, 0x01	; 1
    c2e4:	c8 2e       	mov	r12, r24
    c2e6:	d1 2c       	mov	r13, r1
    c2e8:	e1 2c       	mov	r14, r1
    c2ea:	f1 2c       	mov	r15, r1
    c2ec:	03 c0       	rjmp	.+6      	; 0xc2f4 <__udivdi3+0xc54>
    c2ee:	44 24       	eor	r4, r4
    c2f0:	55 24       	eor	r5, r5
    c2f2:	32 01       	movw	r6, r4
    c2f4:	fe 01       	movw	r30, r28
    c2f6:	31 96       	adiw	r30, 0x01	; 1
    c2f8:	88 e0       	ldi	r24, 0x08	; 8
    c2fa:	df 01       	movw	r26, r30
    c2fc:	1d 92       	st	X+, r1
    c2fe:	8a 95       	dec	r24
    c300:	e9 f7       	brne	.-6      	; 0xc2fc <__udivdi3+0xc5c>
    c302:	c9 82       	std	Y+1, r12	; 0x01
    c304:	da 82       	std	Y+2, r13	; 0x02
    c306:	eb 82       	std	Y+3, r14	; 0x03
    c308:	fc 82       	std	Y+4, r15	; 0x04
    c30a:	4d 82       	std	Y+5, r4	; 0x05
    c30c:	5e 82       	std	Y+6, r5	; 0x06
    c30e:	6f 82       	std	Y+7, r6	; 0x07
    c310:	78 86       	std	Y+8, r7	; 0x08
    c312:	2c 2d       	mov	r18, r12
    c314:	3a 81       	ldd	r19, Y+2	; 0x02
    c316:	4b 81       	ldd	r20, Y+3	; 0x03
    c318:	5c 81       	ldd	r21, Y+4	; 0x04
    c31a:	64 2d       	mov	r22, r4
    c31c:	7e 81       	ldd	r23, Y+6	; 0x06
    c31e:	8f 81       	ldd	r24, Y+7	; 0x07
    c320:	98 85       	ldd	r25, Y+8	; 0x08
    c322:	e4 96       	adiw	r28, 0x34	; 52
    c324:	e1 e1       	ldi	r30, 0x11	; 17
    c326:	0c 94 a6 63 	jmp	0xc74c	; 0xc74c <__epilogue_restores__+0x2>

0000c32a <__cmpsf2>:
    c32a:	97 d0       	rcall	.+302    	; 0xc45a <__fp_cmp>
    c32c:	08 f4       	brcc	.+2      	; 0xc330 <__cmpsf2+0x6>
    c32e:	81 e0       	ldi	r24, 0x01	; 1
    c330:	08 95       	ret

0000c332 <__divsf3>:
    c332:	0c d0       	rcall	.+24     	; 0xc34c <__divsf3x>
    c334:	cd c0       	rjmp	.+410    	; 0xc4d0 <__fp_round>
    c336:	c5 d0       	rcall	.+394    	; 0xc4c2 <__fp_pscB>
    c338:	40 f0       	brcs	.+16     	; 0xc34a <__divsf3+0x18>
    c33a:	bc d0       	rcall	.+376    	; 0xc4b4 <__fp_pscA>
    c33c:	30 f0       	brcs	.+12     	; 0xc34a <__divsf3+0x18>
    c33e:	21 f4       	brne	.+8      	; 0xc348 <__divsf3+0x16>
    c340:	5f 3f       	cpi	r21, 0xFF	; 255
    c342:	19 f0       	breq	.+6      	; 0xc34a <__divsf3+0x18>
    c344:	ae c0       	rjmp	.+348    	; 0xc4a2 <__fp_inf>
    c346:	51 11       	cpse	r21, r1
    c348:	f7 c0       	rjmp	.+494    	; 0xc538 <__fp_szero>
    c34a:	b1 c0       	rjmp	.+354    	; 0xc4ae <__fp_nan>

0000c34c <__divsf3x>:
    c34c:	d2 d0       	rcall	.+420    	; 0xc4f2 <__fp_split3>
    c34e:	98 f3       	brcs	.-26     	; 0xc336 <__divsf3+0x4>

0000c350 <__divsf3_pse>:
    c350:	99 23       	and	r25, r25
    c352:	c9 f3       	breq	.-14     	; 0xc346 <__divsf3+0x14>
    c354:	55 23       	and	r21, r21
    c356:	b1 f3       	breq	.-20     	; 0xc344 <__divsf3+0x12>
    c358:	95 1b       	sub	r25, r21
    c35a:	55 0b       	sbc	r21, r21
    c35c:	bb 27       	eor	r27, r27
    c35e:	aa 27       	eor	r26, r26
    c360:	62 17       	cp	r22, r18
    c362:	73 07       	cpc	r23, r19
    c364:	84 07       	cpc	r24, r20
    c366:	38 f0       	brcs	.+14     	; 0xc376 <__divsf3_pse+0x26>
    c368:	9f 5f       	subi	r25, 0xFF	; 255
    c36a:	5f 4f       	sbci	r21, 0xFF	; 255
    c36c:	22 0f       	add	r18, r18
    c36e:	33 1f       	adc	r19, r19
    c370:	44 1f       	adc	r20, r20
    c372:	aa 1f       	adc	r26, r26
    c374:	a9 f3       	breq	.-22     	; 0xc360 <__divsf3_pse+0x10>
    c376:	33 d0       	rcall	.+102    	; 0xc3de <__divsf3_pse+0x8e>
    c378:	0e 2e       	mov	r0, r30
    c37a:	3a f0       	brmi	.+14     	; 0xc38a <__divsf3_pse+0x3a>
    c37c:	e0 e8       	ldi	r30, 0x80	; 128
    c37e:	30 d0       	rcall	.+96     	; 0xc3e0 <__divsf3_pse+0x90>
    c380:	91 50       	subi	r25, 0x01	; 1
    c382:	50 40       	sbci	r21, 0x00	; 0
    c384:	e6 95       	lsr	r30
    c386:	00 1c       	adc	r0, r0
    c388:	ca f7       	brpl	.-14     	; 0xc37c <__divsf3_pse+0x2c>
    c38a:	29 d0       	rcall	.+82     	; 0xc3de <__divsf3_pse+0x8e>
    c38c:	fe 2f       	mov	r31, r30
    c38e:	27 d0       	rcall	.+78     	; 0xc3de <__divsf3_pse+0x8e>
    c390:	66 0f       	add	r22, r22
    c392:	77 1f       	adc	r23, r23
    c394:	88 1f       	adc	r24, r24
    c396:	bb 1f       	adc	r27, r27
    c398:	26 17       	cp	r18, r22
    c39a:	37 07       	cpc	r19, r23
    c39c:	48 07       	cpc	r20, r24
    c39e:	ab 07       	cpc	r26, r27
    c3a0:	b0 e8       	ldi	r27, 0x80	; 128
    c3a2:	09 f0       	breq	.+2      	; 0xc3a6 <__divsf3_pse+0x56>
    c3a4:	bb 0b       	sbc	r27, r27
    c3a6:	80 2d       	mov	r24, r0
    c3a8:	bf 01       	movw	r22, r30
    c3aa:	ff 27       	eor	r31, r31
    c3ac:	93 58       	subi	r25, 0x83	; 131
    c3ae:	5f 4f       	sbci	r21, 0xFF	; 255
    c3b0:	2a f0       	brmi	.+10     	; 0xc3bc <__divsf3_pse+0x6c>
    c3b2:	9e 3f       	cpi	r25, 0xFE	; 254
    c3b4:	51 05       	cpc	r21, r1
    c3b6:	68 f0       	brcs	.+26     	; 0xc3d2 <__divsf3_pse+0x82>
    c3b8:	74 c0       	rjmp	.+232    	; 0xc4a2 <__fp_inf>
    c3ba:	be c0       	rjmp	.+380    	; 0xc538 <__fp_szero>
    c3bc:	5f 3f       	cpi	r21, 0xFF	; 255
    c3be:	ec f3       	brlt	.-6      	; 0xc3ba <__divsf3_pse+0x6a>
    c3c0:	98 3e       	cpi	r25, 0xE8	; 232
    c3c2:	dc f3       	brlt	.-10     	; 0xc3ba <__divsf3_pse+0x6a>
    c3c4:	86 95       	lsr	r24
    c3c6:	77 95       	ror	r23
    c3c8:	67 95       	ror	r22
    c3ca:	b7 95       	ror	r27
    c3cc:	f7 95       	ror	r31
    c3ce:	9f 5f       	subi	r25, 0xFF	; 255
    c3d0:	c9 f7       	brne	.-14     	; 0xc3c4 <__divsf3_pse+0x74>
    c3d2:	88 0f       	add	r24, r24
    c3d4:	91 1d       	adc	r25, r1
    c3d6:	96 95       	lsr	r25
    c3d8:	87 95       	ror	r24
    c3da:	97 f9       	bld	r25, 7
    c3dc:	08 95       	ret
    c3de:	e1 e0       	ldi	r30, 0x01	; 1
    c3e0:	66 0f       	add	r22, r22
    c3e2:	77 1f       	adc	r23, r23
    c3e4:	88 1f       	adc	r24, r24
    c3e6:	bb 1f       	adc	r27, r27
    c3e8:	62 17       	cp	r22, r18
    c3ea:	73 07       	cpc	r23, r19
    c3ec:	84 07       	cpc	r24, r20
    c3ee:	ba 07       	cpc	r27, r26
    c3f0:	20 f0       	brcs	.+8      	; 0xc3fa <__divsf3_pse+0xaa>
    c3f2:	62 1b       	sub	r22, r18
    c3f4:	73 0b       	sbc	r23, r19
    c3f6:	84 0b       	sbc	r24, r20
    c3f8:	ba 0b       	sbc	r27, r26
    c3fa:	ee 1f       	adc	r30, r30
    c3fc:	88 f7       	brcc	.-30     	; 0xc3e0 <__divsf3_pse+0x90>
    c3fe:	e0 95       	com	r30
    c400:	08 95       	ret

0000c402 <__fixunssfsi>:
    c402:	7f d0       	rcall	.+254    	; 0xc502 <__fp_splitA>
    c404:	88 f0       	brcs	.+34     	; 0xc428 <__fixunssfsi+0x26>
    c406:	9f 57       	subi	r25, 0x7F	; 127
    c408:	90 f0       	brcs	.+36     	; 0xc42e <__fixunssfsi+0x2c>
    c40a:	b9 2f       	mov	r27, r25
    c40c:	99 27       	eor	r25, r25
    c40e:	b7 51       	subi	r27, 0x17	; 23
    c410:	a0 f0       	brcs	.+40     	; 0xc43a <__fixunssfsi+0x38>
    c412:	d1 f0       	breq	.+52     	; 0xc448 <__fixunssfsi+0x46>
    c414:	66 0f       	add	r22, r22
    c416:	77 1f       	adc	r23, r23
    c418:	88 1f       	adc	r24, r24
    c41a:	99 1f       	adc	r25, r25
    c41c:	1a f0       	brmi	.+6      	; 0xc424 <__fixunssfsi+0x22>
    c41e:	ba 95       	dec	r27
    c420:	c9 f7       	brne	.-14     	; 0xc414 <__fixunssfsi+0x12>
    c422:	12 c0       	rjmp	.+36     	; 0xc448 <__fixunssfsi+0x46>
    c424:	b1 30       	cpi	r27, 0x01	; 1
    c426:	81 f0       	breq	.+32     	; 0xc448 <__fixunssfsi+0x46>
    c428:	86 d0       	rcall	.+268    	; 0xc536 <__fp_zero>
    c42a:	b1 e0       	ldi	r27, 0x01	; 1
    c42c:	08 95       	ret
    c42e:	83 c0       	rjmp	.+262    	; 0xc536 <__fp_zero>
    c430:	67 2f       	mov	r22, r23
    c432:	78 2f       	mov	r23, r24
    c434:	88 27       	eor	r24, r24
    c436:	b8 5f       	subi	r27, 0xF8	; 248
    c438:	39 f0       	breq	.+14     	; 0xc448 <__fixunssfsi+0x46>
    c43a:	b9 3f       	cpi	r27, 0xF9	; 249
    c43c:	cc f3       	brlt	.-14     	; 0xc430 <__fixunssfsi+0x2e>
    c43e:	86 95       	lsr	r24
    c440:	77 95       	ror	r23
    c442:	67 95       	ror	r22
    c444:	b3 95       	inc	r27
    c446:	d9 f7       	brne	.-10     	; 0xc43e <__fixunssfsi+0x3c>
    c448:	3e f4       	brtc	.+14     	; 0xc458 <__fixunssfsi+0x56>
    c44a:	90 95       	com	r25
    c44c:	80 95       	com	r24
    c44e:	70 95       	com	r23
    c450:	61 95       	neg	r22
    c452:	7f 4f       	sbci	r23, 0xFF	; 255
    c454:	8f 4f       	sbci	r24, 0xFF	; 255
    c456:	9f 4f       	sbci	r25, 0xFF	; 255
    c458:	08 95       	ret

0000c45a <__fp_cmp>:
    c45a:	99 0f       	add	r25, r25
    c45c:	00 08       	sbc	r0, r0
    c45e:	55 0f       	add	r21, r21
    c460:	aa 0b       	sbc	r26, r26
    c462:	e0 e8       	ldi	r30, 0x80	; 128
    c464:	fe ef       	ldi	r31, 0xFE	; 254
    c466:	16 16       	cp	r1, r22
    c468:	17 06       	cpc	r1, r23
    c46a:	e8 07       	cpc	r30, r24
    c46c:	f9 07       	cpc	r31, r25
    c46e:	c0 f0       	brcs	.+48     	; 0xc4a0 <__fp_cmp+0x46>
    c470:	12 16       	cp	r1, r18
    c472:	13 06       	cpc	r1, r19
    c474:	e4 07       	cpc	r30, r20
    c476:	f5 07       	cpc	r31, r21
    c478:	98 f0       	brcs	.+38     	; 0xc4a0 <__fp_cmp+0x46>
    c47a:	62 1b       	sub	r22, r18
    c47c:	73 0b       	sbc	r23, r19
    c47e:	84 0b       	sbc	r24, r20
    c480:	95 0b       	sbc	r25, r21
    c482:	39 f4       	brne	.+14     	; 0xc492 <__fp_cmp+0x38>
    c484:	0a 26       	eor	r0, r26
    c486:	61 f0       	breq	.+24     	; 0xc4a0 <__fp_cmp+0x46>
    c488:	23 2b       	or	r18, r19
    c48a:	24 2b       	or	r18, r20
    c48c:	25 2b       	or	r18, r21
    c48e:	21 f4       	brne	.+8      	; 0xc498 <__fp_cmp+0x3e>
    c490:	08 95       	ret
    c492:	0a 26       	eor	r0, r26
    c494:	09 f4       	brne	.+2      	; 0xc498 <__fp_cmp+0x3e>
    c496:	a1 40       	sbci	r26, 0x01	; 1
    c498:	a6 95       	lsr	r26
    c49a:	8f ef       	ldi	r24, 0xFF	; 255
    c49c:	81 1d       	adc	r24, r1
    c49e:	81 1d       	adc	r24, r1
    c4a0:	08 95       	ret

0000c4a2 <__fp_inf>:
    c4a2:	97 f9       	bld	r25, 7
    c4a4:	9f 67       	ori	r25, 0x7F	; 127
    c4a6:	80 e8       	ldi	r24, 0x80	; 128
    c4a8:	70 e0       	ldi	r23, 0x00	; 0
    c4aa:	60 e0       	ldi	r22, 0x00	; 0
    c4ac:	08 95       	ret

0000c4ae <__fp_nan>:
    c4ae:	9f ef       	ldi	r25, 0xFF	; 255
    c4b0:	80 ec       	ldi	r24, 0xC0	; 192
    c4b2:	08 95       	ret

0000c4b4 <__fp_pscA>:
    c4b4:	00 24       	eor	r0, r0
    c4b6:	0a 94       	dec	r0
    c4b8:	16 16       	cp	r1, r22
    c4ba:	17 06       	cpc	r1, r23
    c4bc:	18 06       	cpc	r1, r24
    c4be:	09 06       	cpc	r0, r25
    c4c0:	08 95       	ret

0000c4c2 <__fp_pscB>:
    c4c2:	00 24       	eor	r0, r0
    c4c4:	0a 94       	dec	r0
    c4c6:	12 16       	cp	r1, r18
    c4c8:	13 06       	cpc	r1, r19
    c4ca:	14 06       	cpc	r1, r20
    c4cc:	05 06       	cpc	r0, r21
    c4ce:	08 95       	ret

0000c4d0 <__fp_round>:
    c4d0:	09 2e       	mov	r0, r25
    c4d2:	03 94       	inc	r0
    c4d4:	00 0c       	add	r0, r0
    c4d6:	11 f4       	brne	.+4      	; 0xc4dc <__fp_round+0xc>
    c4d8:	88 23       	and	r24, r24
    c4da:	52 f0       	brmi	.+20     	; 0xc4f0 <__fp_round+0x20>
    c4dc:	bb 0f       	add	r27, r27
    c4de:	40 f4       	brcc	.+16     	; 0xc4f0 <__fp_round+0x20>
    c4e0:	bf 2b       	or	r27, r31
    c4e2:	11 f4       	brne	.+4      	; 0xc4e8 <__fp_round+0x18>
    c4e4:	60 ff       	sbrs	r22, 0
    c4e6:	04 c0       	rjmp	.+8      	; 0xc4f0 <__fp_round+0x20>
    c4e8:	6f 5f       	subi	r22, 0xFF	; 255
    c4ea:	7f 4f       	sbci	r23, 0xFF	; 255
    c4ec:	8f 4f       	sbci	r24, 0xFF	; 255
    c4ee:	9f 4f       	sbci	r25, 0xFF	; 255
    c4f0:	08 95       	ret

0000c4f2 <__fp_split3>:
    c4f2:	57 fd       	sbrc	r21, 7
    c4f4:	90 58       	subi	r25, 0x80	; 128
    c4f6:	44 0f       	add	r20, r20
    c4f8:	55 1f       	adc	r21, r21
    c4fa:	59 f0       	breq	.+22     	; 0xc512 <__fp_splitA+0x10>
    c4fc:	5f 3f       	cpi	r21, 0xFF	; 255
    c4fe:	71 f0       	breq	.+28     	; 0xc51c <__fp_splitA+0x1a>
    c500:	47 95       	ror	r20

0000c502 <__fp_splitA>:
    c502:	88 0f       	add	r24, r24
    c504:	97 fb       	bst	r25, 7
    c506:	99 1f       	adc	r25, r25
    c508:	61 f0       	breq	.+24     	; 0xc522 <__fp_splitA+0x20>
    c50a:	9f 3f       	cpi	r25, 0xFF	; 255
    c50c:	79 f0       	breq	.+30     	; 0xc52c <__fp_splitA+0x2a>
    c50e:	87 95       	ror	r24
    c510:	08 95       	ret
    c512:	12 16       	cp	r1, r18
    c514:	13 06       	cpc	r1, r19
    c516:	14 06       	cpc	r1, r20
    c518:	55 1f       	adc	r21, r21
    c51a:	f2 cf       	rjmp	.-28     	; 0xc500 <__fp_split3+0xe>
    c51c:	46 95       	lsr	r20
    c51e:	f1 df       	rcall	.-30     	; 0xc502 <__fp_splitA>
    c520:	08 c0       	rjmp	.+16     	; 0xc532 <__fp_splitA+0x30>
    c522:	16 16       	cp	r1, r22
    c524:	17 06       	cpc	r1, r23
    c526:	18 06       	cpc	r1, r24
    c528:	99 1f       	adc	r25, r25
    c52a:	f1 cf       	rjmp	.-30     	; 0xc50e <__fp_splitA+0xc>
    c52c:	86 95       	lsr	r24
    c52e:	71 05       	cpc	r23, r1
    c530:	61 05       	cpc	r22, r1
    c532:	08 94       	sec
    c534:	08 95       	ret

0000c536 <__fp_zero>:
    c536:	e8 94       	clt

0000c538 <__fp_szero>:
    c538:	bb 27       	eor	r27, r27
    c53a:	66 27       	eor	r22, r22
    c53c:	77 27       	eor	r23, r23
    c53e:	cb 01       	movw	r24, r22
    c540:	97 f9       	bld	r25, 7
    c542:	08 95       	ret

0000c544 <__gesf2>:
    c544:	8a df       	rcall	.-236    	; 0xc45a <__fp_cmp>
    c546:	08 f4       	brcc	.+2      	; 0xc54a <__gesf2+0x6>
    c548:	8f ef       	ldi	r24, 0xFF	; 255
    c54a:	08 95       	ret

0000c54c <__mulsf3>:
    c54c:	0b d0       	rcall	.+22     	; 0xc564 <__mulsf3x>
    c54e:	c0 cf       	rjmp	.-128    	; 0xc4d0 <__fp_round>
    c550:	b1 df       	rcall	.-158    	; 0xc4b4 <__fp_pscA>
    c552:	28 f0       	brcs	.+10     	; 0xc55e <__mulsf3+0x12>
    c554:	b6 df       	rcall	.-148    	; 0xc4c2 <__fp_pscB>
    c556:	18 f0       	brcs	.+6      	; 0xc55e <__mulsf3+0x12>
    c558:	95 23       	and	r25, r21
    c55a:	09 f0       	breq	.+2      	; 0xc55e <__mulsf3+0x12>
    c55c:	a2 cf       	rjmp	.-188    	; 0xc4a2 <__fp_inf>
    c55e:	a7 cf       	rjmp	.-178    	; 0xc4ae <__fp_nan>
    c560:	11 24       	eor	r1, r1
    c562:	ea cf       	rjmp	.-44     	; 0xc538 <__fp_szero>

0000c564 <__mulsf3x>:
    c564:	c6 df       	rcall	.-116    	; 0xc4f2 <__fp_split3>
    c566:	a0 f3       	brcs	.-24     	; 0xc550 <__mulsf3+0x4>

0000c568 <__mulsf3_pse>:
    c568:	95 9f       	mul	r25, r21
    c56a:	d1 f3       	breq	.-12     	; 0xc560 <__mulsf3+0x14>
    c56c:	95 0f       	add	r25, r21
    c56e:	50 e0       	ldi	r21, 0x00	; 0
    c570:	55 1f       	adc	r21, r21
    c572:	62 9f       	mul	r22, r18
    c574:	f0 01       	movw	r30, r0
    c576:	72 9f       	mul	r23, r18
    c578:	bb 27       	eor	r27, r27
    c57a:	f0 0d       	add	r31, r0
    c57c:	b1 1d       	adc	r27, r1
    c57e:	63 9f       	mul	r22, r19
    c580:	aa 27       	eor	r26, r26
    c582:	f0 0d       	add	r31, r0
    c584:	b1 1d       	adc	r27, r1
    c586:	aa 1f       	adc	r26, r26
    c588:	64 9f       	mul	r22, r20
    c58a:	66 27       	eor	r22, r22
    c58c:	b0 0d       	add	r27, r0
    c58e:	a1 1d       	adc	r26, r1
    c590:	66 1f       	adc	r22, r22
    c592:	82 9f       	mul	r24, r18
    c594:	22 27       	eor	r18, r18
    c596:	b0 0d       	add	r27, r0
    c598:	a1 1d       	adc	r26, r1
    c59a:	62 1f       	adc	r22, r18
    c59c:	73 9f       	mul	r23, r19
    c59e:	b0 0d       	add	r27, r0
    c5a0:	a1 1d       	adc	r26, r1
    c5a2:	62 1f       	adc	r22, r18
    c5a4:	83 9f       	mul	r24, r19
    c5a6:	a0 0d       	add	r26, r0
    c5a8:	61 1d       	adc	r22, r1
    c5aa:	22 1f       	adc	r18, r18
    c5ac:	74 9f       	mul	r23, r20
    c5ae:	33 27       	eor	r19, r19
    c5b0:	a0 0d       	add	r26, r0
    c5b2:	61 1d       	adc	r22, r1
    c5b4:	23 1f       	adc	r18, r19
    c5b6:	84 9f       	mul	r24, r20
    c5b8:	60 0d       	add	r22, r0
    c5ba:	21 1d       	adc	r18, r1
    c5bc:	82 2f       	mov	r24, r18
    c5be:	76 2f       	mov	r23, r22
    c5c0:	6a 2f       	mov	r22, r26
    c5c2:	11 24       	eor	r1, r1
    c5c4:	9f 57       	subi	r25, 0x7F	; 127
    c5c6:	50 40       	sbci	r21, 0x00	; 0
    c5c8:	8a f0       	brmi	.+34     	; 0xc5ec <__mulsf3_pse+0x84>
    c5ca:	e1 f0       	breq	.+56     	; 0xc604 <__mulsf3_pse+0x9c>
    c5cc:	88 23       	and	r24, r24
    c5ce:	4a f0       	brmi	.+18     	; 0xc5e2 <__mulsf3_pse+0x7a>
    c5d0:	ee 0f       	add	r30, r30
    c5d2:	ff 1f       	adc	r31, r31
    c5d4:	bb 1f       	adc	r27, r27
    c5d6:	66 1f       	adc	r22, r22
    c5d8:	77 1f       	adc	r23, r23
    c5da:	88 1f       	adc	r24, r24
    c5dc:	91 50       	subi	r25, 0x01	; 1
    c5de:	50 40       	sbci	r21, 0x00	; 0
    c5e0:	a9 f7       	brne	.-22     	; 0xc5cc <__mulsf3_pse+0x64>
    c5e2:	9e 3f       	cpi	r25, 0xFE	; 254
    c5e4:	51 05       	cpc	r21, r1
    c5e6:	70 f0       	brcs	.+28     	; 0xc604 <__mulsf3_pse+0x9c>
    c5e8:	5c cf       	rjmp	.-328    	; 0xc4a2 <__fp_inf>
    c5ea:	a6 cf       	rjmp	.-180    	; 0xc538 <__fp_szero>
    c5ec:	5f 3f       	cpi	r21, 0xFF	; 255
    c5ee:	ec f3       	brlt	.-6      	; 0xc5ea <__mulsf3_pse+0x82>
    c5f0:	98 3e       	cpi	r25, 0xE8	; 232
    c5f2:	dc f3       	brlt	.-10     	; 0xc5ea <__mulsf3_pse+0x82>
    c5f4:	86 95       	lsr	r24
    c5f6:	77 95       	ror	r23
    c5f8:	67 95       	ror	r22
    c5fa:	b7 95       	ror	r27
    c5fc:	f7 95       	ror	r31
    c5fe:	e7 95       	ror	r30
    c600:	9f 5f       	subi	r25, 0xFF	; 255
    c602:	c1 f7       	brne	.-16     	; 0xc5f4 <__mulsf3_pse+0x8c>
    c604:	fe 2b       	or	r31, r30
    c606:	88 0f       	add	r24, r24
    c608:	91 1d       	adc	r25, r1
    c60a:	96 95       	lsr	r25
    c60c:	87 95       	ror	r24
    c60e:	97 f9       	bld	r25, 7
    c610:	08 95       	ret

0000c612 <__mulsi3>:
    c612:	62 9f       	mul	r22, r18
    c614:	d0 01       	movw	r26, r0
    c616:	73 9f       	mul	r23, r19
    c618:	f0 01       	movw	r30, r0
    c61a:	82 9f       	mul	r24, r18
    c61c:	e0 0d       	add	r30, r0
    c61e:	f1 1d       	adc	r31, r1
    c620:	64 9f       	mul	r22, r20
    c622:	e0 0d       	add	r30, r0
    c624:	f1 1d       	adc	r31, r1
    c626:	92 9f       	mul	r25, r18
    c628:	f0 0d       	add	r31, r0
    c62a:	83 9f       	mul	r24, r19
    c62c:	f0 0d       	add	r31, r0
    c62e:	74 9f       	mul	r23, r20
    c630:	f0 0d       	add	r31, r0
    c632:	65 9f       	mul	r22, r21
    c634:	f0 0d       	add	r31, r0
    c636:	99 27       	eor	r25, r25
    c638:	72 9f       	mul	r23, r18
    c63a:	b0 0d       	add	r27, r0
    c63c:	e1 1d       	adc	r30, r1
    c63e:	f9 1f       	adc	r31, r25
    c640:	63 9f       	mul	r22, r19
    c642:	b0 0d       	add	r27, r0
    c644:	e1 1d       	adc	r30, r1
    c646:	f9 1f       	adc	r31, r25
    c648:	bd 01       	movw	r22, r26
    c64a:	cf 01       	movw	r24, r30
    c64c:	11 24       	eor	r1, r1
    c64e:	08 95       	ret

0000c650 <__udivmodhi4>:
    c650:	aa 1b       	sub	r26, r26
    c652:	bb 1b       	sub	r27, r27
    c654:	51 e1       	ldi	r21, 0x11	; 17
    c656:	07 c0       	rjmp	.+14     	; 0xc666 <__udivmodhi4_ep>

0000c658 <__udivmodhi4_loop>:
    c658:	aa 1f       	adc	r26, r26
    c65a:	bb 1f       	adc	r27, r27
    c65c:	a6 17       	cp	r26, r22
    c65e:	b7 07       	cpc	r27, r23
    c660:	10 f0       	brcs	.+4      	; 0xc666 <__udivmodhi4_ep>
    c662:	a6 1b       	sub	r26, r22
    c664:	b7 0b       	sbc	r27, r23

0000c666 <__udivmodhi4_ep>:
    c666:	88 1f       	adc	r24, r24
    c668:	99 1f       	adc	r25, r25
    c66a:	5a 95       	dec	r21
    c66c:	a9 f7       	brne	.-22     	; 0xc658 <__udivmodhi4_loop>
    c66e:	80 95       	com	r24
    c670:	90 95       	com	r25
    c672:	bc 01       	movw	r22, r24
    c674:	cd 01       	movw	r24, r26
    c676:	08 95       	ret

0000c678 <__divmodhi4>:
    c678:	97 fb       	bst	r25, 7
    c67a:	09 2e       	mov	r0, r25
    c67c:	07 26       	eor	r0, r23
    c67e:	0a d0       	rcall	.+20     	; 0xc694 <__divmodhi4_neg1>
    c680:	77 fd       	sbrc	r23, 7
    c682:	04 d0       	rcall	.+8      	; 0xc68c <__divmodhi4_neg2>
    c684:	e5 df       	rcall	.-54     	; 0xc650 <__udivmodhi4>
    c686:	06 d0       	rcall	.+12     	; 0xc694 <__divmodhi4_neg1>
    c688:	00 20       	and	r0, r0
    c68a:	1a f4       	brpl	.+6      	; 0xc692 <__divmodhi4_exit>

0000c68c <__divmodhi4_neg2>:
    c68c:	70 95       	com	r23
    c68e:	61 95       	neg	r22
    c690:	7f 4f       	sbci	r23, 0xFF	; 255

0000c692 <__divmodhi4_exit>:
    c692:	08 95       	ret

0000c694 <__divmodhi4_neg1>:
    c694:	f6 f7       	brtc	.-4      	; 0xc692 <__divmodhi4_exit>
    c696:	90 95       	com	r25
    c698:	81 95       	neg	r24
    c69a:	9f 4f       	sbci	r25, 0xFF	; 255
    c69c:	08 95       	ret

0000c69e <__udivmodsi4>:
    c69e:	a1 e2       	ldi	r26, 0x21	; 33
    c6a0:	1a 2e       	mov	r1, r26
    c6a2:	aa 1b       	sub	r26, r26
    c6a4:	bb 1b       	sub	r27, r27
    c6a6:	fd 01       	movw	r30, r26
    c6a8:	0d c0       	rjmp	.+26     	; 0xc6c4 <__udivmodsi4_ep>

0000c6aa <__udivmodsi4_loop>:
    c6aa:	aa 1f       	adc	r26, r26
    c6ac:	bb 1f       	adc	r27, r27
    c6ae:	ee 1f       	adc	r30, r30
    c6b0:	ff 1f       	adc	r31, r31
    c6b2:	a2 17       	cp	r26, r18
    c6b4:	b3 07       	cpc	r27, r19
    c6b6:	e4 07       	cpc	r30, r20
    c6b8:	f5 07       	cpc	r31, r21
    c6ba:	20 f0       	brcs	.+8      	; 0xc6c4 <__udivmodsi4_ep>
    c6bc:	a2 1b       	sub	r26, r18
    c6be:	b3 0b       	sbc	r27, r19
    c6c0:	e4 0b       	sbc	r30, r20
    c6c2:	f5 0b       	sbc	r31, r21

0000c6c4 <__udivmodsi4_ep>:
    c6c4:	66 1f       	adc	r22, r22
    c6c6:	77 1f       	adc	r23, r23
    c6c8:	88 1f       	adc	r24, r24
    c6ca:	99 1f       	adc	r25, r25
    c6cc:	1a 94       	dec	r1
    c6ce:	69 f7       	brne	.-38     	; 0xc6aa <__udivmodsi4_loop>
    c6d0:	60 95       	com	r22
    c6d2:	70 95       	com	r23
    c6d4:	80 95       	com	r24
    c6d6:	90 95       	com	r25
    c6d8:	9b 01       	movw	r18, r22
    c6da:	ac 01       	movw	r20, r24
    c6dc:	bd 01       	movw	r22, r26
    c6de:	cf 01       	movw	r24, r30
    c6e0:	08 95       	ret

0000c6e2 <__divmodsi4>:
    c6e2:	97 fb       	bst	r25, 7
    c6e4:	09 2e       	mov	r0, r25
    c6e6:	05 26       	eor	r0, r21
    c6e8:	0e d0       	rcall	.+28     	; 0xc706 <__divmodsi4_neg1>
    c6ea:	57 fd       	sbrc	r21, 7
    c6ec:	04 d0       	rcall	.+8      	; 0xc6f6 <__divmodsi4_neg2>
    c6ee:	d7 df       	rcall	.-82     	; 0xc69e <__udivmodsi4>
    c6f0:	0a d0       	rcall	.+20     	; 0xc706 <__divmodsi4_neg1>
    c6f2:	00 1c       	adc	r0, r0
    c6f4:	38 f4       	brcc	.+14     	; 0xc704 <__divmodsi4_exit>

0000c6f6 <__divmodsi4_neg2>:
    c6f6:	50 95       	com	r21
    c6f8:	40 95       	com	r20
    c6fa:	30 95       	com	r19
    c6fc:	21 95       	neg	r18
    c6fe:	3f 4f       	sbci	r19, 0xFF	; 255
    c700:	4f 4f       	sbci	r20, 0xFF	; 255
    c702:	5f 4f       	sbci	r21, 0xFF	; 255

0000c704 <__divmodsi4_exit>:
    c704:	08 95       	ret

0000c706 <__divmodsi4_neg1>:
    c706:	f6 f7       	brtc	.-4      	; 0xc704 <__divmodsi4_exit>
    c708:	90 95       	com	r25
    c70a:	80 95       	com	r24
    c70c:	70 95       	com	r23
    c70e:	61 95       	neg	r22
    c710:	7f 4f       	sbci	r23, 0xFF	; 255
    c712:	8f 4f       	sbci	r24, 0xFF	; 255
    c714:	9f 4f       	sbci	r25, 0xFF	; 255
    c716:	08 95       	ret

0000c718 <__prologue_saves__>:
    c718:	2f 92       	push	r2
    c71a:	3f 92       	push	r3
    c71c:	4f 92       	push	r4
    c71e:	5f 92       	push	r5
    c720:	6f 92       	push	r6
    c722:	7f 92       	push	r7
    c724:	8f 92       	push	r8
    c726:	9f 92       	push	r9
    c728:	af 92       	push	r10
    c72a:	bf 92       	push	r11
    c72c:	cf 92       	push	r12
    c72e:	df 92       	push	r13
    c730:	ef 92       	push	r14
    c732:	ff 92       	push	r15
    c734:	0f 93       	push	r16
    c736:	1f 93       	push	r17
    c738:	cf 93       	push	r28
    c73a:	df 93       	push	r29
    c73c:	cd b7       	in	r28, 0x3d	; 61
    c73e:	de b7       	in	r29, 0x3e	; 62
    c740:	ca 1b       	sub	r28, r26
    c742:	db 0b       	sbc	r29, r27
    c744:	cd bf       	out	0x3d, r28	; 61
    c746:	de bf       	out	0x3e, r29	; 62
    c748:	19 94       	eijmp

0000c74a <__epilogue_restores__>:
    c74a:	2a 88       	ldd	r2, Y+18	; 0x12
    c74c:	39 88       	ldd	r3, Y+17	; 0x11
    c74e:	48 88       	ldd	r4, Y+16	; 0x10
    c750:	5f 84       	ldd	r5, Y+15	; 0x0f
    c752:	6e 84       	ldd	r6, Y+14	; 0x0e
    c754:	7d 84       	ldd	r7, Y+13	; 0x0d
    c756:	8c 84       	ldd	r8, Y+12	; 0x0c
    c758:	9b 84       	ldd	r9, Y+11	; 0x0b
    c75a:	aa 84       	ldd	r10, Y+10	; 0x0a
    c75c:	b9 84       	ldd	r11, Y+9	; 0x09
    c75e:	c8 84       	ldd	r12, Y+8	; 0x08
    c760:	df 80       	ldd	r13, Y+7	; 0x07
    c762:	ee 80       	ldd	r14, Y+6	; 0x06
    c764:	fd 80       	ldd	r15, Y+5	; 0x05
    c766:	0c 81       	ldd	r16, Y+4	; 0x04
    c768:	1b 81       	ldd	r17, Y+3	; 0x03
    c76a:	aa 81       	ldd	r26, Y+2	; 0x02
    c76c:	b9 81       	ldd	r27, Y+1	; 0x01
    c76e:	ce 0f       	add	r28, r30
    c770:	d1 1d       	adc	r29, r1
    c772:	cd bf       	out	0x3d, r28	; 61
    c774:	de bf       	out	0x3e, r29	; 62
    c776:	ed 01       	movw	r28, r26
    c778:	08 95       	ret

0000c77a <strcpy_P>:
    c77a:	fb 01       	movw	r30, r22
    c77c:	dc 01       	movw	r26, r24
    c77e:	05 90       	lpm	r0, Z+
    c780:	0d 92       	st	X+, r0
    c782:	00 20       	and	r0, r0
    c784:	e1 f7       	brne	.-8      	; 0xc77e <strcpy_P+0x4>
    c786:	08 95       	ret

0000c788 <memcpy>:
    c788:	fb 01       	movw	r30, r22
    c78a:	dc 01       	movw	r26, r24
    c78c:	02 c0       	rjmp	.+4      	; 0xc792 <memcpy+0xa>
    c78e:	01 90       	ld	r0, Z+
    c790:	0d 92       	st	X+, r0
    c792:	41 50       	subi	r20, 0x01	; 1
    c794:	50 40       	sbci	r21, 0x00	; 0
    c796:	d8 f7       	brcc	.-10     	; 0xc78e <memcpy+0x6>
    c798:	08 95       	ret

0000c79a <memmove>:
    c79a:	68 17       	cp	r22, r24
    c79c:	79 07       	cpc	r23, r25
    c79e:	68 f4       	brcc	.+26     	; 0xc7ba <memmove+0x20>
    c7a0:	fb 01       	movw	r30, r22
    c7a2:	dc 01       	movw	r26, r24
    c7a4:	e4 0f       	add	r30, r20
    c7a6:	f5 1f       	adc	r31, r21
    c7a8:	a4 0f       	add	r26, r20
    c7aa:	b5 1f       	adc	r27, r21
    c7ac:	02 c0       	rjmp	.+4      	; 0xc7b2 <memmove+0x18>
    c7ae:	02 90       	ld	r0, -Z
    c7b0:	0e 92       	st	-X, r0
    c7b2:	41 50       	subi	r20, 0x01	; 1
    c7b4:	50 40       	sbci	r21, 0x00	; 0
    c7b6:	d8 f7       	brcc	.-10     	; 0xc7ae <memmove+0x14>
    c7b8:	08 95       	ret
    c7ba:	0c 94 c4 63 	jmp	0xc788	; 0xc788 <memcpy>

0000c7be <strcat>:
    c7be:	fb 01       	movw	r30, r22
    c7c0:	dc 01       	movw	r26, r24
    c7c2:	0d 90       	ld	r0, X+
    c7c4:	00 20       	and	r0, r0
    c7c6:	e9 f7       	brne	.-6      	; 0xc7c2 <strcat+0x4>
    c7c8:	11 97       	sbiw	r26, 0x01	; 1
    c7ca:	01 90       	ld	r0, Z+
    c7cc:	0d 92       	st	X+, r0
    c7ce:	00 20       	and	r0, r0
    c7d0:	e1 f7       	brne	.-8      	; 0xc7ca <strcat+0xc>
    c7d2:	08 95       	ret

0000c7d4 <strncmp>:
    c7d4:	fb 01       	movw	r30, r22
    c7d6:	dc 01       	movw	r26, r24
    c7d8:	41 50       	subi	r20, 0x01	; 1
    c7da:	50 40       	sbci	r21, 0x00	; 0
    c7dc:	30 f0       	brcs	.+12     	; 0xc7ea <strncmp+0x16>
    c7de:	8d 91       	ld	r24, X+
    c7e0:	01 90       	ld	r0, Z+
    c7e2:	80 19       	sub	r24, r0
    c7e4:	19 f4       	brne	.+6      	; 0xc7ec <strncmp+0x18>
    c7e6:	00 20       	and	r0, r0
    c7e8:	b9 f7       	brne	.-18     	; 0xc7d8 <strncmp+0x4>
    c7ea:	88 1b       	sub	r24, r24
    c7ec:	99 0b       	sbc	r25, r25
    c7ee:	08 95       	ret

0000c7f0 <itoa>:
    c7f0:	fb 01       	movw	r30, r22
    c7f2:	9f 01       	movw	r18, r30
    c7f4:	e8 94       	clt
    c7f6:	42 30       	cpi	r20, 0x02	; 2
    c7f8:	c4 f0       	brlt	.+48     	; 0xc82a <itoa+0x3a>
    c7fa:	45 32       	cpi	r20, 0x25	; 37
    c7fc:	b4 f4       	brge	.+44     	; 0xc82a <itoa+0x3a>
    c7fe:	4a 30       	cpi	r20, 0x0A	; 10
    c800:	29 f4       	brne	.+10     	; 0xc80c <itoa+0x1c>
    c802:	97 fb       	bst	r25, 7
    c804:	1e f4       	brtc	.+6      	; 0xc80c <itoa+0x1c>
    c806:	90 95       	com	r25
    c808:	81 95       	neg	r24
    c80a:	9f 4f       	sbci	r25, 0xFF	; 255
    c80c:	64 2f       	mov	r22, r20
    c80e:	77 27       	eor	r23, r23
    c810:	0e 94 28 63 	call	0xc650	; 0xc650 <__udivmodhi4>
    c814:	80 5d       	subi	r24, 0xD0	; 208
    c816:	8a 33       	cpi	r24, 0x3A	; 58
    c818:	0c f0       	brlt	.+2      	; 0xc81c <itoa+0x2c>
    c81a:	89 5d       	subi	r24, 0xD9	; 217
    c81c:	81 93       	st	Z+, r24
    c81e:	cb 01       	movw	r24, r22
    c820:	00 97       	sbiw	r24, 0x00	; 0
    c822:	a1 f7       	brne	.-24     	; 0xc80c <itoa+0x1c>
    c824:	16 f4       	brtc	.+4      	; 0xc82a <itoa+0x3a>
    c826:	5d e2       	ldi	r21, 0x2D	; 45
    c828:	51 93       	st	Z+, r21
    c82a:	10 82       	st	Z, r1
    c82c:	c9 01       	movw	r24, r18
    c82e:	0c 94 42 66 	jmp	0xcc84	; 0xcc84 <strrev>

0000c832 <printf>:
    c832:	cf 93       	push	r28
    c834:	df 93       	push	r29
    c836:	cd b7       	in	r28, 0x3d	; 61
    c838:	de b7       	in	r29, 0x3e	; 62
    c83a:	fe 01       	movw	r30, r28
    c83c:	36 96       	adiw	r30, 0x06	; 6
    c83e:	61 91       	ld	r22, Z+
    c840:	71 91       	ld	r23, Z+
    c842:	80 91 27 53 	lds	r24, 0x5327
    c846:	90 91 28 53 	lds	r25, 0x5328
    c84a:	af 01       	movw	r20, r30
    c84c:	0e 94 2b 64 	call	0xc856	; 0xc856 <vfprintf>
    c850:	df 91       	pop	r29
    c852:	cf 91       	pop	r28
    c854:	08 95       	ret

0000c856 <vfprintf>:
    c856:	2f 92       	push	r2
    c858:	3f 92       	push	r3
    c85a:	4f 92       	push	r4
    c85c:	5f 92       	push	r5
    c85e:	6f 92       	push	r6
    c860:	7f 92       	push	r7
    c862:	8f 92       	push	r8
    c864:	9f 92       	push	r9
    c866:	af 92       	push	r10
    c868:	bf 92       	push	r11
    c86a:	cf 92       	push	r12
    c86c:	df 92       	push	r13
    c86e:	ef 92       	push	r14
    c870:	ff 92       	push	r15
    c872:	0f 93       	push	r16
    c874:	1f 93       	push	r17
    c876:	cf 93       	push	r28
    c878:	df 93       	push	r29
    c87a:	cd b7       	in	r28, 0x3d	; 61
    c87c:	de b7       	in	r29, 0x3e	; 62
    c87e:	2d 97       	sbiw	r28, 0x0d	; 13
    c880:	cd bf       	out	0x3d, r28	; 61
    c882:	de bf       	out	0x3e, r29	; 62
    c884:	3c 01       	movw	r6, r24
    c886:	6c 87       	std	Y+12, r22	; 0x0c
    c888:	7d 87       	std	Y+13, r23	; 0x0d
    c88a:	5a 01       	movw	r10, r20
    c88c:	fc 01       	movw	r30, r24
    c88e:	16 82       	std	Z+6, r1	; 0x06
    c890:	17 82       	std	Z+7, r1	; 0x07
    c892:	83 81       	ldd	r24, Z+3	; 0x03
    c894:	81 ff       	sbrs	r24, 1
    c896:	c8 c1       	rjmp	.+912    	; 0xcc28 <vfprintf+0x3d2>
    c898:	2e 01       	movw	r4, r28
    c89a:	08 94       	sec
    c89c:	41 1c       	adc	r4, r1
    c89e:	51 1c       	adc	r5, r1
    c8a0:	f3 01       	movw	r30, r6
    c8a2:	93 81       	ldd	r25, Z+3	; 0x03
    c8a4:	ec 85       	ldd	r30, Y+12	; 0x0c
    c8a6:	fd 85       	ldd	r31, Y+13	; 0x0d
    c8a8:	93 fd       	sbrc	r25, 3
    c8aa:	85 91       	lpm	r24, Z+
    c8ac:	93 ff       	sbrs	r25, 3
    c8ae:	81 91       	ld	r24, Z+
    c8b0:	ec 87       	std	Y+12, r30	; 0x0c
    c8b2:	fd 87       	std	Y+13, r31	; 0x0d
    c8b4:	88 23       	and	r24, r24
    c8b6:	09 f4       	brne	.+2      	; 0xc8ba <vfprintf+0x64>
    c8b8:	b3 c1       	rjmp	.+870    	; 0xcc20 <vfprintf+0x3ca>
    c8ba:	85 32       	cpi	r24, 0x25	; 37
    c8bc:	41 f4       	brne	.+16     	; 0xc8ce <vfprintf+0x78>
    c8be:	93 fd       	sbrc	r25, 3
    c8c0:	85 91       	lpm	r24, Z+
    c8c2:	93 ff       	sbrs	r25, 3
    c8c4:	81 91       	ld	r24, Z+
    c8c6:	ec 87       	std	Y+12, r30	; 0x0c
    c8c8:	fd 87       	std	Y+13, r31	; 0x0d
    c8ca:	85 32       	cpi	r24, 0x25	; 37
    c8cc:	29 f4       	brne	.+10     	; 0xc8d8 <vfprintf+0x82>
    c8ce:	90 e0       	ldi	r25, 0x00	; 0
    c8d0:	b3 01       	movw	r22, r6
    c8d2:	0e 94 52 66 	call	0xcca4	; 0xcca4 <fputc>
    c8d6:	e4 cf       	rjmp	.-56     	; 0xc8a0 <vfprintf+0x4a>
    c8d8:	ff 24       	eor	r15, r15
    c8da:	ee 24       	eor	r14, r14
    c8dc:	10 e0       	ldi	r17, 0x00	; 0
    c8de:	10 32       	cpi	r17, 0x20	; 32
    c8e0:	b0 f4       	brcc	.+44     	; 0xc90e <vfprintf+0xb8>
    c8e2:	8b 32       	cpi	r24, 0x2B	; 43
    c8e4:	69 f0       	breq	.+26     	; 0xc900 <vfprintf+0xaa>
    c8e6:	8c 32       	cpi	r24, 0x2C	; 44
    c8e8:	28 f4       	brcc	.+10     	; 0xc8f4 <vfprintf+0x9e>
    c8ea:	80 32       	cpi	r24, 0x20	; 32
    c8ec:	51 f0       	breq	.+20     	; 0xc902 <vfprintf+0xac>
    c8ee:	83 32       	cpi	r24, 0x23	; 35
    c8f0:	71 f4       	brne	.+28     	; 0xc90e <vfprintf+0xb8>
    c8f2:	0b c0       	rjmp	.+22     	; 0xc90a <vfprintf+0xb4>
    c8f4:	8d 32       	cpi	r24, 0x2D	; 45
    c8f6:	39 f0       	breq	.+14     	; 0xc906 <vfprintf+0xb0>
    c8f8:	80 33       	cpi	r24, 0x30	; 48
    c8fa:	49 f4       	brne	.+18     	; 0xc90e <vfprintf+0xb8>
    c8fc:	11 60       	ori	r17, 0x01	; 1
    c8fe:	2c c0       	rjmp	.+88     	; 0xc958 <vfprintf+0x102>
    c900:	12 60       	ori	r17, 0x02	; 2
    c902:	14 60       	ori	r17, 0x04	; 4
    c904:	29 c0       	rjmp	.+82     	; 0xc958 <vfprintf+0x102>
    c906:	18 60       	ori	r17, 0x08	; 8
    c908:	27 c0       	rjmp	.+78     	; 0xc958 <vfprintf+0x102>
    c90a:	10 61       	ori	r17, 0x10	; 16
    c90c:	25 c0       	rjmp	.+74     	; 0xc958 <vfprintf+0x102>
    c90e:	17 fd       	sbrc	r17, 7
    c910:	2e c0       	rjmp	.+92     	; 0xc96e <vfprintf+0x118>
    c912:	28 2f       	mov	r18, r24
    c914:	20 53       	subi	r18, 0x30	; 48
    c916:	2a 30       	cpi	r18, 0x0A	; 10
    c918:	98 f4       	brcc	.+38     	; 0xc940 <vfprintf+0xea>
    c91a:	16 ff       	sbrs	r17, 6
    c91c:	08 c0       	rjmp	.+16     	; 0xc92e <vfprintf+0xd8>
    c91e:	8f 2d       	mov	r24, r15
    c920:	88 0f       	add	r24, r24
    c922:	f8 2e       	mov	r15, r24
    c924:	ff 0c       	add	r15, r15
    c926:	ff 0c       	add	r15, r15
    c928:	f8 0e       	add	r15, r24
    c92a:	f2 0e       	add	r15, r18
    c92c:	15 c0       	rjmp	.+42     	; 0xc958 <vfprintf+0x102>
    c92e:	8e 2d       	mov	r24, r14
    c930:	88 0f       	add	r24, r24
    c932:	e8 2e       	mov	r14, r24
    c934:	ee 0c       	add	r14, r14
    c936:	ee 0c       	add	r14, r14
    c938:	e8 0e       	add	r14, r24
    c93a:	e2 0e       	add	r14, r18
    c93c:	10 62       	ori	r17, 0x20	; 32
    c93e:	0c c0       	rjmp	.+24     	; 0xc958 <vfprintf+0x102>
    c940:	8e 32       	cpi	r24, 0x2E	; 46
    c942:	21 f4       	brne	.+8      	; 0xc94c <vfprintf+0xf6>
    c944:	16 fd       	sbrc	r17, 6
    c946:	6c c1       	rjmp	.+728    	; 0xcc20 <vfprintf+0x3ca>
    c948:	10 64       	ori	r17, 0x40	; 64
    c94a:	06 c0       	rjmp	.+12     	; 0xc958 <vfprintf+0x102>
    c94c:	8c 36       	cpi	r24, 0x6C	; 108
    c94e:	11 f4       	brne	.+4      	; 0xc954 <vfprintf+0xfe>
    c950:	10 68       	ori	r17, 0x80	; 128
    c952:	02 c0       	rjmp	.+4      	; 0xc958 <vfprintf+0x102>
    c954:	88 36       	cpi	r24, 0x68	; 104
    c956:	59 f4       	brne	.+22     	; 0xc96e <vfprintf+0x118>
    c958:	ec 85       	ldd	r30, Y+12	; 0x0c
    c95a:	fd 85       	ldd	r31, Y+13	; 0x0d
    c95c:	93 fd       	sbrc	r25, 3
    c95e:	85 91       	lpm	r24, Z+
    c960:	93 ff       	sbrs	r25, 3
    c962:	81 91       	ld	r24, Z+
    c964:	ec 87       	std	Y+12, r30	; 0x0c
    c966:	fd 87       	std	Y+13, r31	; 0x0d
    c968:	88 23       	and	r24, r24
    c96a:	09 f0       	breq	.+2      	; 0xc96e <vfprintf+0x118>
    c96c:	b8 cf       	rjmp	.-144    	; 0xc8de <vfprintf+0x88>
    c96e:	98 2f       	mov	r25, r24
    c970:	95 54       	subi	r25, 0x45	; 69
    c972:	93 30       	cpi	r25, 0x03	; 3
    c974:	18 f0       	brcs	.+6      	; 0xc97c <vfprintf+0x126>
    c976:	90 52       	subi	r25, 0x20	; 32
    c978:	93 30       	cpi	r25, 0x03	; 3
    c97a:	38 f4       	brcc	.+14     	; 0xc98a <vfprintf+0x134>
    c97c:	24 e0       	ldi	r18, 0x04	; 4
    c97e:	30 e0       	ldi	r19, 0x00	; 0
    c980:	a2 0e       	add	r10, r18
    c982:	b3 1e       	adc	r11, r19
    c984:	3f e3       	ldi	r19, 0x3F	; 63
    c986:	39 83       	std	Y+1, r19	; 0x01
    c988:	0f c0       	rjmp	.+30     	; 0xc9a8 <vfprintf+0x152>
    c98a:	83 36       	cpi	r24, 0x63	; 99
    c98c:	31 f0       	breq	.+12     	; 0xc99a <vfprintf+0x144>
    c98e:	83 37       	cpi	r24, 0x73	; 115
    c990:	81 f0       	breq	.+32     	; 0xc9b2 <vfprintf+0x15c>
    c992:	83 35       	cpi	r24, 0x53	; 83
    c994:	09 f0       	breq	.+2      	; 0xc998 <vfprintf+0x142>
    c996:	5a c0       	rjmp	.+180    	; 0xca4c <vfprintf+0x1f6>
    c998:	22 c0       	rjmp	.+68     	; 0xc9de <vfprintf+0x188>
    c99a:	f5 01       	movw	r30, r10
    c99c:	80 81       	ld	r24, Z
    c99e:	89 83       	std	Y+1, r24	; 0x01
    c9a0:	22 e0       	ldi	r18, 0x02	; 2
    c9a2:	30 e0       	ldi	r19, 0x00	; 0
    c9a4:	a2 0e       	add	r10, r18
    c9a6:	b3 1e       	adc	r11, r19
    c9a8:	21 e0       	ldi	r18, 0x01	; 1
    c9aa:	c2 2e       	mov	r12, r18
    c9ac:	d1 2c       	mov	r13, r1
    c9ae:	42 01       	movw	r8, r4
    c9b0:	14 c0       	rjmp	.+40     	; 0xc9da <vfprintf+0x184>
    c9b2:	92 e0       	ldi	r25, 0x02	; 2
    c9b4:	29 2e       	mov	r2, r25
    c9b6:	31 2c       	mov	r3, r1
    c9b8:	2a 0c       	add	r2, r10
    c9ba:	3b 1c       	adc	r3, r11
    c9bc:	f5 01       	movw	r30, r10
    c9be:	80 80       	ld	r8, Z
    c9c0:	91 80       	ldd	r9, Z+1	; 0x01
    c9c2:	16 ff       	sbrs	r17, 6
    c9c4:	03 c0       	rjmp	.+6      	; 0xc9cc <vfprintf+0x176>
    c9c6:	6f 2d       	mov	r22, r15
    c9c8:	70 e0       	ldi	r23, 0x00	; 0
    c9ca:	02 c0       	rjmp	.+4      	; 0xc9d0 <vfprintf+0x17a>
    c9cc:	6f ef       	ldi	r22, 0xFF	; 255
    c9ce:	7f ef       	ldi	r23, 0xFF	; 255
    c9d0:	c4 01       	movw	r24, r8
    c9d2:	0e 94 37 66 	call	0xcc6e	; 0xcc6e <strnlen>
    c9d6:	6c 01       	movw	r12, r24
    c9d8:	51 01       	movw	r10, r2
    c9da:	1f 77       	andi	r17, 0x7F	; 127
    c9dc:	15 c0       	rjmp	.+42     	; 0xca08 <vfprintf+0x1b2>
    c9de:	82 e0       	ldi	r24, 0x02	; 2
    c9e0:	28 2e       	mov	r2, r24
    c9e2:	31 2c       	mov	r3, r1
    c9e4:	2a 0c       	add	r2, r10
    c9e6:	3b 1c       	adc	r3, r11
    c9e8:	f5 01       	movw	r30, r10
    c9ea:	80 80       	ld	r8, Z
    c9ec:	91 80       	ldd	r9, Z+1	; 0x01
    c9ee:	16 ff       	sbrs	r17, 6
    c9f0:	03 c0       	rjmp	.+6      	; 0xc9f8 <vfprintf+0x1a2>
    c9f2:	6f 2d       	mov	r22, r15
    c9f4:	70 e0       	ldi	r23, 0x00	; 0
    c9f6:	02 c0       	rjmp	.+4      	; 0xc9fc <vfprintf+0x1a6>
    c9f8:	6f ef       	ldi	r22, 0xFF	; 255
    c9fa:	7f ef       	ldi	r23, 0xFF	; 255
    c9fc:	c4 01       	movw	r24, r8
    c9fe:	0e 94 2c 66 	call	0xcc58	; 0xcc58 <strnlen_P>
    ca02:	6c 01       	movw	r12, r24
    ca04:	10 68       	ori	r17, 0x80	; 128
    ca06:	51 01       	movw	r10, r2
    ca08:	13 fd       	sbrc	r17, 3
    ca0a:	1c c0       	rjmp	.+56     	; 0xca44 <vfprintf+0x1ee>
    ca0c:	06 c0       	rjmp	.+12     	; 0xca1a <vfprintf+0x1c4>
    ca0e:	80 e2       	ldi	r24, 0x20	; 32
    ca10:	90 e0       	ldi	r25, 0x00	; 0
    ca12:	b3 01       	movw	r22, r6
    ca14:	0e 94 52 66 	call	0xcca4	; 0xcca4 <fputc>
    ca18:	ea 94       	dec	r14
    ca1a:	8e 2d       	mov	r24, r14
    ca1c:	90 e0       	ldi	r25, 0x00	; 0
    ca1e:	c8 16       	cp	r12, r24
    ca20:	d9 06       	cpc	r13, r25
    ca22:	a8 f3       	brcs	.-22     	; 0xca0e <vfprintf+0x1b8>
    ca24:	0f c0       	rjmp	.+30     	; 0xca44 <vfprintf+0x1ee>
    ca26:	f4 01       	movw	r30, r8
    ca28:	17 fd       	sbrc	r17, 7
    ca2a:	85 91       	lpm	r24, Z+
    ca2c:	17 ff       	sbrs	r17, 7
    ca2e:	81 91       	ld	r24, Z+
    ca30:	4f 01       	movw	r8, r30
    ca32:	90 e0       	ldi	r25, 0x00	; 0
    ca34:	b3 01       	movw	r22, r6
    ca36:	0e 94 52 66 	call	0xcca4	; 0xcca4 <fputc>
    ca3a:	e1 10       	cpse	r14, r1
    ca3c:	ea 94       	dec	r14
    ca3e:	08 94       	sec
    ca40:	c1 08       	sbc	r12, r1
    ca42:	d1 08       	sbc	r13, r1
    ca44:	c1 14       	cp	r12, r1
    ca46:	d1 04       	cpc	r13, r1
    ca48:	71 f7       	brne	.-36     	; 0xca26 <vfprintf+0x1d0>
    ca4a:	e7 c0       	rjmp	.+462    	; 0xcc1a <vfprintf+0x3c4>
    ca4c:	84 36       	cpi	r24, 0x64	; 100
    ca4e:	11 f0       	breq	.+4      	; 0xca54 <vfprintf+0x1fe>
    ca50:	89 36       	cpi	r24, 0x69	; 105
    ca52:	51 f5       	brne	.+84     	; 0xcaa8 <vfprintf+0x252>
    ca54:	f5 01       	movw	r30, r10
    ca56:	17 ff       	sbrs	r17, 7
    ca58:	07 c0       	rjmp	.+14     	; 0xca68 <vfprintf+0x212>
    ca5a:	80 81       	ld	r24, Z
    ca5c:	91 81       	ldd	r25, Z+1	; 0x01
    ca5e:	a2 81       	ldd	r26, Z+2	; 0x02
    ca60:	b3 81       	ldd	r27, Z+3	; 0x03
    ca62:	24 e0       	ldi	r18, 0x04	; 4
    ca64:	30 e0       	ldi	r19, 0x00	; 0
    ca66:	08 c0       	rjmp	.+16     	; 0xca78 <vfprintf+0x222>
    ca68:	80 81       	ld	r24, Z
    ca6a:	91 81       	ldd	r25, Z+1	; 0x01
    ca6c:	aa 27       	eor	r26, r26
    ca6e:	97 fd       	sbrc	r25, 7
    ca70:	a0 95       	com	r26
    ca72:	ba 2f       	mov	r27, r26
    ca74:	22 e0       	ldi	r18, 0x02	; 2
    ca76:	30 e0       	ldi	r19, 0x00	; 0
    ca78:	a2 0e       	add	r10, r18
    ca7a:	b3 1e       	adc	r11, r19
    ca7c:	01 2f       	mov	r16, r17
    ca7e:	0f 76       	andi	r16, 0x6F	; 111
    ca80:	b7 ff       	sbrs	r27, 7
    ca82:	08 c0       	rjmp	.+16     	; 0xca94 <vfprintf+0x23e>
    ca84:	b0 95       	com	r27
    ca86:	a0 95       	com	r26
    ca88:	90 95       	com	r25
    ca8a:	81 95       	neg	r24
    ca8c:	9f 4f       	sbci	r25, 0xFF	; 255
    ca8e:	af 4f       	sbci	r26, 0xFF	; 255
    ca90:	bf 4f       	sbci	r27, 0xFF	; 255
    ca92:	00 68       	ori	r16, 0x80	; 128
    ca94:	bc 01       	movw	r22, r24
    ca96:	cd 01       	movw	r24, r26
    ca98:	a2 01       	movw	r20, r4
    ca9a:	2a e0       	ldi	r18, 0x0A	; 10
    ca9c:	30 e0       	ldi	r19, 0x00	; 0
    ca9e:	0e 94 7e 66 	call	0xccfc	; 0xccfc <__ultoa_invert>
    caa2:	d8 2e       	mov	r13, r24
    caa4:	d4 18       	sub	r13, r4
    caa6:	3f c0       	rjmp	.+126    	; 0xcb26 <vfprintf+0x2d0>
    caa8:	85 37       	cpi	r24, 0x75	; 117
    caaa:	21 f4       	brne	.+8      	; 0xcab4 <vfprintf+0x25e>
    caac:	1f 7e       	andi	r17, 0xEF	; 239
    caae:	2a e0       	ldi	r18, 0x0A	; 10
    cab0:	30 e0       	ldi	r19, 0x00	; 0
    cab2:	20 c0       	rjmp	.+64     	; 0xcaf4 <vfprintf+0x29e>
    cab4:	19 7f       	andi	r17, 0xF9	; 249
    cab6:	8f 36       	cpi	r24, 0x6F	; 111
    cab8:	a9 f0       	breq	.+42     	; 0xcae4 <vfprintf+0x28e>
    caba:	80 37       	cpi	r24, 0x70	; 112
    cabc:	20 f4       	brcc	.+8      	; 0xcac6 <vfprintf+0x270>
    cabe:	88 35       	cpi	r24, 0x58	; 88
    cac0:	09 f0       	breq	.+2      	; 0xcac4 <vfprintf+0x26e>
    cac2:	ae c0       	rjmp	.+348    	; 0xcc20 <vfprintf+0x3ca>
    cac4:	0b c0       	rjmp	.+22     	; 0xcadc <vfprintf+0x286>
    cac6:	80 37       	cpi	r24, 0x70	; 112
    cac8:	21 f0       	breq	.+8      	; 0xcad2 <vfprintf+0x27c>
    caca:	88 37       	cpi	r24, 0x78	; 120
    cacc:	09 f0       	breq	.+2      	; 0xcad0 <vfprintf+0x27a>
    cace:	a8 c0       	rjmp	.+336    	; 0xcc20 <vfprintf+0x3ca>
    cad0:	01 c0       	rjmp	.+2      	; 0xcad4 <vfprintf+0x27e>
    cad2:	10 61       	ori	r17, 0x10	; 16
    cad4:	14 ff       	sbrs	r17, 4
    cad6:	09 c0       	rjmp	.+18     	; 0xcaea <vfprintf+0x294>
    cad8:	14 60       	ori	r17, 0x04	; 4
    cada:	07 c0       	rjmp	.+14     	; 0xcaea <vfprintf+0x294>
    cadc:	14 ff       	sbrs	r17, 4
    cade:	08 c0       	rjmp	.+16     	; 0xcaf0 <vfprintf+0x29a>
    cae0:	16 60       	ori	r17, 0x06	; 6
    cae2:	06 c0       	rjmp	.+12     	; 0xcaf0 <vfprintf+0x29a>
    cae4:	28 e0       	ldi	r18, 0x08	; 8
    cae6:	30 e0       	ldi	r19, 0x00	; 0
    cae8:	05 c0       	rjmp	.+10     	; 0xcaf4 <vfprintf+0x29e>
    caea:	20 e1       	ldi	r18, 0x10	; 16
    caec:	30 e0       	ldi	r19, 0x00	; 0
    caee:	02 c0       	rjmp	.+4      	; 0xcaf4 <vfprintf+0x29e>
    caf0:	20 e1       	ldi	r18, 0x10	; 16
    caf2:	32 e0       	ldi	r19, 0x02	; 2
    caf4:	f5 01       	movw	r30, r10
    caf6:	17 ff       	sbrs	r17, 7
    caf8:	07 c0       	rjmp	.+14     	; 0xcb08 <vfprintf+0x2b2>
    cafa:	60 81       	ld	r22, Z
    cafc:	71 81       	ldd	r23, Z+1	; 0x01
    cafe:	82 81       	ldd	r24, Z+2	; 0x02
    cb00:	93 81       	ldd	r25, Z+3	; 0x03
    cb02:	44 e0       	ldi	r20, 0x04	; 4
    cb04:	50 e0       	ldi	r21, 0x00	; 0
    cb06:	06 c0       	rjmp	.+12     	; 0xcb14 <vfprintf+0x2be>
    cb08:	60 81       	ld	r22, Z
    cb0a:	71 81       	ldd	r23, Z+1	; 0x01
    cb0c:	80 e0       	ldi	r24, 0x00	; 0
    cb0e:	90 e0       	ldi	r25, 0x00	; 0
    cb10:	42 e0       	ldi	r20, 0x02	; 2
    cb12:	50 e0       	ldi	r21, 0x00	; 0
    cb14:	a4 0e       	add	r10, r20
    cb16:	b5 1e       	adc	r11, r21
    cb18:	a2 01       	movw	r20, r4
    cb1a:	0e 94 7e 66 	call	0xccfc	; 0xccfc <__ultoa_invert>
    cb1e:	d8 2e       	mov	r13, r24
    cb20:	d4 18       	sub	r13, r4
    cb22:	01 2f       	mov	r16, r17
    cb24:	0f 77       	andi	r16, 0x7F	; 127
    cb26:	06 ff       	sbrs	r16, 6
    cb28:	09 c0       	rjmp	.+18     	; 0xcb3c <vfprintf+0x2e6>
    cb2a:	0e 7f       	andi	r16, 0xFE	; 254
    cb2c:	df 14       	cp	r13, r15
    cb2e:	30 f4       	brcc	.+12     	; 0xcb3c <vfprintf+0x2e6>
    cb30:	04 ff       	sbrs	r16, 4
    cb32:	06 c0       	rjmp	.+12     	; 0xcb40 <vfprintf+0x2ea>
    cb34:	02 fd       	sbrc	r16, 2
    cb36:	04 c0       	rjmp	.+8      	; 0xcb40 <vfprintf+0x2ea>
    cb38:	0f 7e       	andi	r16, 0xEF	; 239
    cb3a:	02 c0       	rjmp	.+4      	; 0xcb40 <vfprintf+0x2ea>
    cb3c:	1d 2d       	mov	r17, r13
    cb3e:	01 c0       	rjmp	.+2      	; 0xcb42 <vfprintf+0x2ec>
    cb40:	1f 2d       	mov	r17, r15
    cb42:	80 2f       	mov	r24, r16
    cb44:	90 e0       	ldi	r25, 0x00	; 0
    cb46:	04 ff       	sbrs	r16, 4
    cb48:	0c c0       	rjmp	.+24     	; 0xcb62 <vfprintf+0x30c>
    cb4a:	fe 01       	movw	r30, r28
    cb4c:	ed 0d       	add	r30, r13
    cb4e:	f1 1d       	adc	r31, r1
    cb50:	20 81       	ld	r18, Z
    cb52:	20 33       	cpi	r18, 0x30	; 48
    cb54:	11 f4       	brne	.+4      	; 0xcb5a <vfprintf+0x304>
    cb56:	09 7e       	andi	r16, 0xE9	; 233
    cb58:	09 c0       	rjmp	.+18     	; 0xcb6c <vfprintf+0x316>
    cb5a:	02 ff       	sbrs	r16, 2
    cb5c:	06 c0       	rjmp	.+12     	; 0xcb6a <vfprintf+0x314>
    cb5e:	1e 5f       	subi	r17, 0xFE	; 254
    cb60:	05 c0       	rjmp	.+10     	; 0xcb6c <vfprintf+0x316>
    cb62:	86 78       	andi	r24, 0x86	; 134
    cb64:	90 70       	andi	r25, 0x00	; 0
    cb66:	00 97       	sbiw	r24, 0x00	; 0
    cb68:	09 f0       	breq	.+2      	; 0xcb6c <vfprintf+0x316>
    cb6a:	1f 5f       	subi	r17, 0xFF	; 255
    cb6c:	80 2e       	mov	r8, r16
    cb6e:	99 24       	eor	r9, r9
    cb70:	03 fd       	sbrc	r16, 3
    cb72:	12 c0       	rjmp	.+36     	; 0xcb98 <vfprintf+0x342>
    cb74:	00 ff       	sbrs	r16, 0
    cb76:	0d c0       	rjmp	.+26     	; 0xcb92 <vfprintf+0x33c>
    cb78:	fd 2c       	mov	r15, r13
    cb7a:	1e 15       	cp	r17, r14
    cb7c:	50 f4       	brcc	.+20     	; 0xcb92 <vfprintf+0x33c>
    cb7e:	fe 0c       	add	r15, r14
    cb80:	f1 1a       	sub	r15, r17
    cb82:	1e 2d       	mov	r17, r14
    cb84:	06 c0       	rjmp	.+12     	; 0xcb92 <vfprintf+0x33c>
    cb86:	80 e2       	ldi	r24, 0x20	; 32
    cb88:	90 e0       	ldi	r25, 0x00	; 0
    cb8a:	b3 01       	movw	r22, r6
    cb8c:	0e 94 52 66 	call	0xcca4	; 0xcca4 <fputc>
    cb90:	1f 5f       	subi	r17, 0xFF	; 255
    cb92:	1e 15       	cp	r17, r14
    cb94:	c0 f3       	brcs	.-16     	; 0xcb86 <vfprintf+0x330>
    cb96:	04 c0       	rjmp	.+8      	; 0xcba0 <vfprintf+0x34a>
    cb98:	1e 15       	cp	r17, r14
    cb9a:	10 f4       	brcc	.+4      	; 0xcba0 <vfprintf+0x34a>
    cb9c:	e1 1a       	sub	r14, r17
    cb9e:	01 c0       	rjmp	.+2      	; 0xcba2 <vfprintf+0x34c>
    cba0:	ee 24       	eor	r14, r14
    cba2:	84 fe       	sbrs	r8, 4
    cba4:	0f c0       	rjmp	.+30     	; 0xcbc4 <vfprintf+0x36e>
    cba6:	80 e3       	ldi	r24, 0x30	; 48
    cba8:	90 e0       	ldi	r25, 0x00	; 0
    cbaa:	b3 01       	movw	r22, r6
    cbac:	0e 94 52 66 	call	0xcca4	; 0xcca4 <fputc>
    cbb0:	82 fe       	sbrs	r8, 2
    cbb2:	1f c0       	rjmp	.+62     	; 0xcbf2 <vfprintf+0x39c>
    cbb4:	81 fe       	sbrs	r8, 1
    cbb6:	03 c0       	rjmp	.+6      	; 0xcbbe <vfprintf+0x368>
    cbb8:	88 e5       	ldi	r24, 0x58	; 88
    cbba:	90 e0       	ldi	r25, 0x00	; 0
    cbbc:	10 c0       	rjmp	.+32     	; 0xcbde <vfprintf+0x388>
    cbbe:	88 e7       	ldi	r24, 0x78	; 120
    cbc0:	90 e0       	ldi	r25, 0x00	; 0
    cbc2:	0d c0       	rjmp	.+26     	; 0xcbde <vfprintf+0x388>
    cbc4:	c4 01       	movw	r24, r8
    cbc6:	86 78       	andi	r24, 0x86	; 134
    cbc8:	90 70       	andi	r25, 0x00	; 0
    cbca:	00 97       	sbiw	r24, 0x00	; 0
    cbcc:	91 f0       	breq	.+36     	; 0xcbf2 <vfprintf+0x39c>
    cbce:	81 fc       	sbrc	r8, 1
    cbd0:	02 c0       	rjmp	.+4      	; 0xcbd6 <vfprintf+0x380>
    cbd2:	80 e2       	ldi	r24, 0x20	; 32
    cbd4:	01 c0       	rjmp	.+2      	; 0xcbd8 <vfprintf+0x382>
    cbd6:	8b e2       	ldi	r24, 0x2B	; 43
    cbd8:	07 fd       	sbrc	r16, 7
    cbda:	8d e2       	ldi	r24, 0x2D	; 45
    cbdc:	90 e0       	ldi	r25, 0x00	; 0
    cbde:	b3 01       	movw	r22, r6
    cbe0:	0e 94 52 66 	call	0xcca4	; 0xcca4 <fputc>
    cbe4:	06 c0       	rjmp	.+12     	; 0xcbf2 <vfprintf+0x39c>
    cbe6:	80 e3       	ldi	r24, 0x30	; 48
    cbe8:	90 e0       	ldi	r25, 0x00	; 0
    cbea:	b3 01       	movw	r22, r6
    cbec:	0e 94 52 66 	call	0xcca4	; 0xcca4 <fputc>
    cbf0:	fa 94       	dec	r15
    cbf2:	df 14       	cp	r13, r15
    cbf4:	c0 f3       	brcs	.-16     	; 0xcbe6 <vfprintf+0x390>
    cbf6:	da 94       	dec	r13
    cbf8:	f2 01       	movw	r30, r4
    cbfa:	ed 0d       	add	r30, r13
    cbfc:	f1 1d       	adc	r31, r1
    cbfe:	80 81       	ld	r24, Z
    cc00:	90 e0       	ldi	r25, 0x00	; 0
    cc02:	b3 01       	movw	r22, r6
    cc04:	0e 94 52 66 	call	0xcca4	; 0xcca4 <fputc>
    cc08:	dd 20       	and	r13, r13
    cc0a:	a9 f7       	brne	.-22     	; 0xcbf6 <vfprintf+0x3a0>
    cc0c:	06 c0       	rjmp	.+12     	; 0xcc1a <vfprintf+0x3c4>
    cc0e:	80 e2       	ldi	r24, 0x20	; 32
    cc10:	90 e0       	ldi	r25, 0x00	; 0
    cc12:	b3 01       	movw	r22, r6
    cc14:	0e 94 52 66 	call	0xcca4	; 0xcca4 <fputc>
    cc18:	ea 94       	dec	r14
    cc1a:	ee 20       	and	r14, r14
    cc1c:	c1 f7       	brne	.-16     	; 0xcc0e <vfprintf+0x3b8>
    cc1e:	40 ce       	rjmp	.-896    	; 0xc8a0 <vfprintf+0x4a>
    cc20:	f3 01       	movw	r30, r6
    cc22:	86 81       	ldd	r24, Z+6	; 0x06
    cc24:	97 81       	ldd	r25, Z+7	; 0x07
    cc26:	02 c0       	rjmp	.+4      	; 0xcc2c <vfprintf+0x3d6>
    cc28:	8f ef       	ldi	r24, 0xFF	; 255
    cc2a:	9f ef       	ldi	r25, 0xFF	; 255
    cc2c:	2d 96       	adiw	r28, 0x0d	; 13
    cc2e:	cd bf       	out	0x3d, r28	; 61
    cc30:	de bf       	out	0x3e, r29	; 62
    cc32:	df 91       	pop	r29
    cc34:	cf 91       	pop	r28
    cc36:	1f 91       	pop	r17
    cc38:	0f 91       	pop	r16
    cc3a:	ff 90       	pop	r15
    cc3c:	ef 90       	pop	r14
    cc3e:	df 90       	pop	r13
    cc40:	cf 90       	pop	r12
    cc42:	bf 90       	pop	r11
    cc44:	af 90       	pop	r10
    cc46:	9f 90       	pop	r9
    cc48:	8f 90       	pop	r8
    cc4a:	7f 90       	pop	r7
    cc4c:	6f 90       	pop	r6
    cc4e:	5f 90       	pop	r5
    cc50:	4f 90       	pop	r4
    cc52:	3f 90       	pop	r3
    cc54:	2f 90       	pop	r2
    cc56:	08 95       	ret

0000cc58 <strnlen_P>:
    cc58:	fc 01       	movw	r30, r24
    cc5a:	05 90       	lpm	r0, Z+
    cc5c:	61 50       	subi	r22, 0x01	; 1
    cc5e:	70 40       	sbci	r23, 0x00	; 0
    cc60:	01 10       	cpse	r0, r1
    cc62:	d8 f7       	brcc	.-10     	; 0xcc5a <strnlen_P+0x2>
    cc64:	80 95       	com	r24
    cc66:	90 95       	com	r25
    cc68:	8e 0f       	add	r24, r30
    cc6a:	9f 1f       	adc	r25, r31
    cc6c:	08 95       	ret

0000cc6e <strnlen>:
    cc6e:	fc 01       	movw	r30, r24
    cc70:	61 50       	subi	r22, 0x01	; 1
    cc72:	70 40       	sbci	r23, 0x00	; 0
    cc74:	01 90       	ld	r0, Z+
    cc76:	01 10       	cpse	r0, r1
    cc78:	d8 f7       	brcc	.-10     	; 0xcc70 <strnlen+0x2>
    cc7a:	80 95       	com	r24
    cc7c:	90 95       	com	r25
    cc7e:	8e 0f       	add	r24, r30
    cc80:	9f 1f       	adc	r25, r31
    cc82:	08 95       	ret

0000cc84 <strrev>:
    cc84:	dc 01       	movw	r26, r24
    cc86:	fc 01       	movw	r30, r24
    cc88:	67 2f       	mov	r22, r23
    cc8a:	71 91       	ld	r23, Z+
    cc8c:	77 23       	and	r23, r23
    cc8e:	e1 f7       	brne	.-8      	; 0xcc88 <strrev+0x4>
    cc90:	32 97       	sbiw	r30, 0x02	; 2
    cc92:	04 c0       	rjmp	.+8      	; 0xcc9c <strrev+0x18>
    cc94:	7c 91       	ld	r23, X
    cc96:	6d 93       	st	X+, r22
    cc98:	70 83       	st	Z, r23
    cc9a:	62 91       	ld	r22, -Z
    cc9c:	ae 17       	cp	r26, r30
    cc9e:	bf 07       	cpc	r27, r31
    cca0:	c8 f3       	brcs	.-14     	; 0xcc94 <strrev+0x10>
    cca2:	08 95       	ret

0000cca4 <fputc>:
    cca4:	0f 93       	push	r16
    cca6:	1f 93       	push	r17
    cca8:	cf 93       	push	r28
    ccaa:	df 93       	push	r29
    ccac:	8c 01       	movw	r16, r24
    ccae:	eb 01       	movw	r28, r22
    ccb0:	8b 81       	ldd	r24, Y+3	; 0x03
    ccb2:	81 ff       	sbrs	r24, 1
    ccb4:	1b c0       	rjmp	.+54     	; 0xccec <fputc+0x48>
    ccb6:	82 ff       	sbrs	r24, 2
    ccb8:	0d c0       	rjmp	.+26     	; 0xccd4 <fputc+0x30>
    ccba:	2e 81       	ldd	r18, Y+6	; 0x06
    ccbc:	3f 81       	ldd	r19, Y+7	; 0x07
    ccbe:	8c 81       	ldd	r24, Y+4	; 0x04
    ccc0:	9d 81       	ldd	r25, Y+5	; 0x05
    ccc2:	28 17       	cp	r18, r24
    ccc4:	39 07       	cpc	r19, r25
    ccc6:	64 f4       	brge	.+24     	; 0xcce0 <fputc+0x3c>
    ccc8:	e8 81       	ld	r30, Y
    ccca:	f9 81       	ldd	r31, Y+1	; 0x01
    cccc:	01 93       	st	Z+, r16
    ccce:	e8 83       	st	Y, r30
    ccd0:	f9 83       	std	Y+1, r31	; 0x01
    ccd2:	06 c0       	rjmp	.+12     	; 0xcce0 <fputc+0x3c>
    ccd4:	e8 85       	ldd	r30, Y+8	; 0x08
    ccd6:	f9 85       	ldd	r31, Y+9	; 0x09
    ccd8:	80 2f       	mov	r24, r16
    ccda:	19 95       	eicall
    ccdc:	00 97       	sbiw	r24, 0x00	; 0
    ccde:	31 f4       	brne	.+12     	; 0xccec <fputc+0x48>
    cce0:	8e 81       	ldd	r24, Y+6	; 0x06
    cce2:	9f 81       	ldd	r25, Y+7	; 0x07
    cce4:	01 96       	adiw	r24, 0x01	; 1
    cce6:	8e 83       	std	Y+6, r24	; 0x06
    cce8:	9f 83       	std	Y+7, r25	; 0x07
    ccea:	02 c0       	rjmp	.+4      	; 0xccf0 <fputc+0x4c>
    ccec:	0f ef       	ldi	r16, 0xFF	; 255
    ccee:	1f ef       	ldi	r17, 0xFF	; 255
    ccf0:	c8 01       	movw	r24, r16
    ccf2:	df 91       	pop	r29
    ccf4:	cf 91       	pop	r28
    ccf6:	1f 91       	pop	r17
    ccf8:	0f 91       	pop	r16
    ccfa:	08 95       	ret

0000ccfc <__ultoa_invert>:
    ccfc:	fa 01       	movw	r30, r20
    ccfe:	aa 27       	eor	r26, r26
    cd00:	28 30       	cpi	r18, 0x08	; 8
    cd02:	51 f1       	breq	.+84     	; 0xcd58 <__ultoa_invert+0x5c>
    cd04:	20 31       	cpi	r18, 0x10	; 16
    cd06:	81 f1       	breq	.+96     	; 0xcd68 <__ultoa_invert+0x6c>
    cd08:	e8 94       	clt
    cd0a:	6f 93       	push	r22
    cd0c:	6e 7f       	andi	r22, 0xFE	; 254
    cd0e:	6e 5f       	subi	r22, 0xFE	; 254
    cd10:	7f 4f       	sbci	r23, 0xFF	; 255
    cd12:	8f 4f       	sbci	r24, 0xFF	; 255
    cd14:	9f 4f       	sbci	r25, 0xFF	; 255
    cd16:	af 4f       	sbci	r26, 0xFF	; 255
    cd18:	b1 e0       	ldi	r27, 0x01	; 1
    cd1a:	3e d0       	rcall	.+124    	; 0xcd98 <__ultoa_invert+0x9c>
    cd1c:	b4 e0       	ldi	r27, 0x04	; 4
    cd1e:	3c d0       	rcall	.+120    	; 0xcd98 <__ultoa_invert+0x9c>
    cd20:	67 0f       	add	r22, r23
    cd22:	78 1f       	adc	r23, r24
    cd24:	89 1f       	adc	r24, r25
    cd26:	9a 1f       	adc	r25, r26
    cd28:	a1 1d       	adc	r26, r1
    cd2a:	68 0f       	add	r22, r24
    cd2c:	79 1f       	adc	r23, r25
    cd2e:	8a 1f       	adc	r24, r26
    cd30:	91 1d       	adc	r25, r1
    cd32:	a1 1d       	adc	r26, r1
    cd34:	6a 0f       	add	r22, r26
    cd36:	71 1d       	adc	r23, r1
    cd38:	81 1d       	adc	r24, r1
    cd3a:	91 1d       	adc	r25, r1
    cd3c:	a1 1d       	adc	r26, r1
    cd3e:	20 d0       	rcall	.+64     	; 0xcd80 <__ultoa_invert+0x84>
    cd40:	09 f4       	brne	.+2      	; 0xcd44 <__ultoa_invert+0x48>
    cd42:	68 94       	set
    cd44:	3f 91       	pop	r19
    cd46:	2a e0       	ldi	r18, 0x0A	; 10
    cd48:	26 9f       	mul	r18, r22
    cd4a:	11 24       	eor	r1, r1
    cd4c:	30 19       	sub	r19, r0
    cd4e:	30 5d       	subi	r19, 0xD0	; 208
    cd50:	31 93       	st	Z+, r19
    cd52:	de f6       	brtc	.-74     	; 0xcd0a <__ultoa_invert+0xe>
    cd54:	cf 01       	movw	r24, r30
    cd56:	08 95       	ret
    cd58:	46 2f       	mov	r20, r22
    cd5a:	47 70       	andi	r20, 0x07	; 7
    cd5c:	40 5d       	subi	r20, 0xD0	; 208
    cd5e:	41 93       	st	Z+, r20
    cd60:	b3 e0       	ldi	r27, 0x03	; 3
    cd62:	0f d0       	rcall	.+30     	; 0xcd82 <__ultoa_invert+0x86>
    cd64:	c9 f7       	brne	.-14     	; 0xcd58 <__ultoa_invert+0x5c>
    cd66:	f6 cf       	rjmp	.-20     	; 0xcd54 <__ultoa_invert+0x58>
    cd68:	46 2f       	mov	r20, r22
    cd6a:	4f 70       	andi	r20, 0x0F	; 15
    cd6c:	40 5d       	subi	r20, 0xD0	; 208
    cd6e:	4a 33       	cpi	r20, 0x3A	; 58
    cd70:	18 f0       	brcs	.+6      	; 0xcd78 <__ultoa_invert+0x7c>
    cd72:	49 5d       	subi	r20, 0xD9	; 217
    cd74:	31 fd       	sbrc	r19, 1
    cd76:	40 52       	subi	r20, 0x20	; 32
    cd78:	41 93       	st	Z+, r20
    cd7a:	02 d0       	rcall	.+4      	; 0xcd80 <__ultoa_invert+0x84>
    cd7c:	a9 f7       	brne	.-22     	; 0xcd68 <__ultoa_invert+0x6c>
    cd7e:	ea cf       	rjmp	.-44     	; 0xcd54 <__ultoa_invert+0x58>
    cd80:	b4 e0       	ldi	r27, 0x04	; 4
    cd82:	a6 95       	lsr	r26
    cd84:	97 95       	ror	r25
    cd86:	87 95       	ror	r24
    cd88:	77 95       	ror	r23
    cd8a:	67 95       	ror	r22
    cd8c:	ba 95       	dec	r27
    cd8e:	c9 f7       	brne	.-14     	; 0xcd82 <__ultoa_invert+0x86>
    cd90:	00 97       	sbiw	r24, 0x00	; 0
    cd92:	61 05       	cpc	r22, r1
    cd94:	71 05       	cpc	r23, r1
    cd96:	08 95       	ret
    cd98:	9b 01       	movw	r18, r22
    cd9a:	ac 01       	movw	r20, r24
    cd9c:	0a 2e       	mov	r0, r26
    cd9e:	06 94       	lsr	r0
    cda0:	57 95       	ror	r21
    cda2:	47 95       	ror	r20
    cda4:	37 95       	ror	r19
    cda6:	27 95       	ror	r18
    cda8:	ba 95       	dec	r27
    cdaa:	c9 f7       	brne	.-14     	; 0xcd9e <__ultoa_invert+0xa2>
    cdac:	62 0f       	add	r22, r18
    cdae:	73 1f       	adc	r23, r19
    cdb0:	84 1f       	adc	r24, r20
    cdb2:	95 1f       	adc	r25, r21
    cdb4:	a0 1d       	adc	r26, r0
    cdb6:	08 95       	ret

0000cdb8 <_exit>:
    cdb8:	f8 94       	cli

0000cdba <__stop_program>:
    cdba:	ff cf       	rjmp	.-2      	; 0xcdba <__stop_program>
