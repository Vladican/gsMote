
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007d04  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000138  00802000  00007d04  00007d98  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fa5  00802138  00802138  00007ed0  2**0
                  ALLOC
  3 .stab         000029b8  00000000  00000000  00007ed0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a2d  00000000  00000000  0000a888  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000400  00000000  00000000  0000b2b8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000cb74  00000000  00000000  0000b6b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002703  00000000  00000000  0001822c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005561  00000000  00000000  0001a92f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001c9c  00000000  00000000  0001fe90  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004689  00000000  00000000  00021b2c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008353  00000000  00000000  000261b5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0015b166  00000000  00000000  0002e508  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000190  00000000  00000000  0018966e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 f5 08 	jmp	0x11ea	; 0x11ea <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 ba 0d 	jmp	0x1b74	; 0x1b74 <__vector_16>
      44:	0c 94 92 0d 	jmp	0x1b24	; 0x1b24 <__vector_17>
      48:	0c 94 6a 0d 	jmp	0x1ad4	; 0x1ad4 <__vector_18>
      4c:	0c 94 24 0d 	jmp	0x1a48	; 0x1a48 <__vector_19>
      50:	0c 94 47 07 	jmp	0xe8e	; 0xe8e <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 aa 20 	jmp	0x4154	; 0x4154 <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 92 1a 	jmp	0x3524	; 0x3524 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 9d 0a 	jmp	0x153a	; 0x153a <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 fc 0c 	jmp	0x19f8	; 0x19f8 <__vector_79>
     140:	0c 94 d4 0c 	jmp	0x19a8	; 0x19a8 <__vector_80>
     144:	0c 94 ac 0c 	jmp	0x1958	; 0x1958 <__vector_81>
     148:	0c 94 82 0c 	jmp	0x1904	; 0x1904 <__vector_82>
     14c:	0c 94 65 03 	jmp	0x6ca	; 0x6ca <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 d9 07 	jmp	0xfb2	; 0xfb2 <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e4 e0       	ldi	r30, 0x04	; 4
     244:	fd e7       	ldi	r31, 0x7D	; 125
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	a8 33       	cpi	r26, 0x38	; 56
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	a8 e3       	ldi	r26, 0x38	; 56
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	ad 3d       	cpi	r26, 0xDD	; 221
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 01 02 	call	0x402	; 0x402 <main>
     26a:	0c 94 80 3e 	jmp	0x7d00	; 0x7d00 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     272:	cf 92       	push	r12
     274:	df 92       	push	r13
     276:	ef 92       	push	r14
     278:	ff 92       	push	r15
     27a:	0f 93       	push	r16
     27c:	1f 93       	push	r17
     27e:	cf 93       	push	r28
     280:	df 93       	push	r29
     282:	6b 01       	movw	r12, r22
     284:	7c 01       	movw	r14, r24
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     286:	dc 01       	movw	r26, r24
     288:	cb 01       	movw	r24, r22
     28a:	88 55       	subi	r24, 0x58	; 88
     28c:	92 40       	sbci	r25, 0x02	; 2
     28e:	a0 40       	sbci	r26, 0x00	; 0
     290:	b0 40       	sbci	r27, 0x00	; 0
     292:	89 3e       	cpi	r24, 0xE9	; 233
     294:	2f e3       	ldi	r18, 0x3F	; 63
     296:	92 07       	cpc	r25, r18
     298:	2f e0       	ldi	r18, 0x0F	; 15
     29a:	a2 07       	cpc	r26, r18
     29c:	20 e0       	ldi	r18, 0x00	; 0
     29e:	b2 07       	cpc	r27, r18
     2a0:	08 f0       	brcs	.+2      	; 0x2a4 <StartSerial+0x32>
     2a2:	5c c0       	rjmp	.+184    	; 0x35c <StartSerial+0xea>
		//baud rate too fast or too slow
		return false;
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     2a4:	0e 94 24 1d 	call	0x3a48	; 0x3a48 <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     2a8:	e0 e4       	ldi	r30, 0x40	; 64
     2aa:	f6 e0       	ldi	r31, 0x06	; 6
     2ac:	88 e0       	ldi	r24, 0x08	; 8
     2ae:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = PIN3_bm;
     2b0:	85 83       	std	Z+5, r24	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     2b2:	84 e0       	ldi	r24, 0x04	; 4
     2b4:	82 83       	std	Z+2, r24	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     2b6:	cc 0c       	add	r12, r12
     2b8:	dd 1c       	adc	r13, r13
     2ba:	ee 1c       	adc	r14, r14
     2bc:	ff 1c       	adc	r15, r15
     2be:	cc 0c       	add	r12, r12
     2c0:	dd 1c       	adc	r13, r13
     2c2:	ee 1c       	adc	r14, r14
     2c4:	ff 1c       	adc	r15, r15
     2c6:	c7 01       	movw	r24, r14
     2c8:	b6 01       	movw	r22, r12
     2ca:	66 0f       	add	r22, r22
     2cc:	77 1f       	adc	r23, r23
     2ce:	88 1f       	adc	r24, r24
     2d0:	99 1f       	adc	r25, r25
     2d2:	66 0f       	add	r22, r22
     2d4:	77 1f       	adc	r23, r23
     2d6:	88 1f       	adc	r24, r24
     2d8:	99 1f       	adc	r25, r25
     2da:	0e 94 ce 39 	call	0x739c	; 0x739c <__floatunsisf>
     2de:	9b 01       	movw	r18, r22
     2e0:	ac 01       	movw	r20, r24
     2e2:	60 e0       	ldi	r22, 0x00	; 0
     2e4:	74 e2       	ldi	r23, 0x24	; 36
     2e6:	84 ef       	ldi	r24, 0xF4	; 244
     2e8:	9b e4       	ldi	r25, 0x4B	; 75
     2ea:	0e 94 3a 39 	call	0x7274	; 0x7274 <__divsf3>
     2ee:	20 e0       	ldi	r18, 0x00	; 0
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	40 e8       	ldi	r20, 0x80	; 128
     2f4:	5f e3       	ldi	r21, 0x3F	; 63
     2f6:	0e 94 d5 38 	call	0x71aa	; 0x71aa <__subsf3>
     2fa:	c6 2f       	mov	r28, r22
     2fc:	d7 2f       	mov	r29, r23
     2fe:	18 2f       	mov	r17, r24
     300:	09 2f       	mov	r16, r25
     302:	86 2f       	mov	r24, r22
     304:	9d 2f       	mov	r25, r29
     306:	a1 2f       	mov	r26, r17
     308:	b0 2f       	mov	r27, r16
     30a:	bc 01       	movw	r22, r24
     30c:	cd 01       	movw	r24, r26
     30e:	0e 94 a2 39 	call	0x7344	; 0x7344 <__fixunssfsi>
     312:	6b 01       	movw	r12, r22
     314:	7c 01       	movw	r14, r24
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     316:	80 e0       	ldi	r24, 0x00	; 0
     318:	90 e0       	ldi	r25, 0x00	; 0
     31a:	0e 94 ce 39 	call	0x739c	; 0x739c <__floatunsisf>
     31e:	9b 01       	movw	r18, r22
     320:	ac 01       	movw	r20, r24
     322:	8c 2f       	mov	r24, r28
     324:	9d 2f       	mov	r25, r29
     326:	a1 2f       	mov	r26, r17
     328:	b0 2f       	mov	r27, r16
     32a:	bc 01       	movw	r22, r24
     32c:	cd 01       	movw	r24, r26
     32e:	0e 94 d5 38 	call	0x71aa	; 0x71aa <__subsf3>
     332:	20 e0       	ldi	r18, 0x00	; 0
     334:	30 e0       	ldi	r19, 0x00	; 0
     336:	40 e0       	ldi	r20, 0x00	; 0
     338:	5f e3       	ldi	r21, 0x3F	; 63
     33a:	0e 94 5c 3a 	call	0x74b8	; 0x74b8 <__gesf2>
     33e:	88 23       	and	r24, r24
     340:	1c f0       	brlt	.+6      	; 0x348 <StartSerial+0xd6>
     342:	08 94       	sec
     344:	c1 1c       	adc	r12, r1
     346:	d1 1c       	adc	r13, r1
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     348:	e0 ea       	ldi	r30, 0xA0	; 160
     34a:	f8 e0       	ldi	r31, 0x08	; 8
     34c:	c6 82       	std	Z+6, r12	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     34e:	d7 82       	std	Z+7, r13	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     350:	83 e0       	ldi	r24, 0x03	; 3
     352:	85 83       	std	Z+5, r24	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     354:	88 e1       	ldi	r24, 0x18	; 24
     356:	84 83       	std	Z+4, r24	; 0x04
	return true;
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	01 c0       	rjmp	.+2      	; 0x35e <StartSerial+0xec>

bool StartSerial(uint32_t BaudRate){
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
		//baud rate too fast or too slow
		return false;
     35c:	80 e0       	ldi	r24, 0x00	; 0
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
	return true;
}
     35e:	df 91       	pop	r29
     360:	cf 91       	pop	r28
     362:	1f 91       	pop	r17
     364:	0f 91       	pop	r16
     366:	ff 90       	pop	r15
     368:	ef 90       	pop	r14
     36a:	df 90       	pop	r13
     36c:	cf 90       	pop	r12
     36e:	08 95       	ret

00000370 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     370:	e0 ea       	ldi	r30, 0xA0	; 160
     372:	f8 e0       	ldi	r31, 0x08	; 8
     374:	91 81       	ldd	r25, Z+1	; 0x01
     376:	95 ff       	sbrs	r25, 5
     378:	fd cf       	rjmp	.-6      	; 0x374 <SerialWriteByte+0x4>
		//wait
	}
	//send byte
	USARTC0.DATA = byte;
     37a:	80 93 a0 08 	sts	0x08A0, r24
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     37e:	08 95       	ret

00000380 <SerialReadByte>:

uint8_t SerialReadByte(){
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     380:	e0 ea       	ldi	r30, 0xA0	; 160
     382:	f8 e0       	ldi	r31, 0x08	; 8
     384:	81 81       	ldd	r24, Z+1	; 0x01
     386:	88 23       	and	r24, r24
     388:	ec f7       	brge	.-6      	; 0x384 <SerialReadByte+0x4>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     38a:	80 91 a0 08 	lds	r24, 0x08A0
	return byte;	
}
     38e:	08 95       	ret

00000390 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     390:	8f 92       	push	r8
     392:	9f 92       	push	r9
     394:	af 92       	push	r10
     396:	bf 92       	push	r11
     398:	cf 92       	push	r12
     39a:	df 92       	push	r13
     39c:	ef 92       	push	r14
     39e:	ff 92       	push	r15
     3a0:	cf 93       	push	r28
     3a2:	df 93       	push	r29
     3a4:	6a 01       	movw	r12, r20
     3a6:	7b 01       	movw	r14, r22
	uint32_t i;
	for(i=0;i<length;i++){
     3a8:	41 15       	cp	r20, r1
     3aa:	51 05       	cpc	r21, r1
     3ac:	61 05       	cpc	r22, r1
     3ae:	71 05       	cpc	r23, r1
     3b0:	91 f0       	breq	.+36     	; 0x3d6 <SerialWriteBuffer+0x46>
     3b2:	c8 2f       	mov	r28, r24
     3b4:	d9 2f       	mov	r29, r25
     3b6:	88 24       	eor	r8, r8
     3b8:	99 24       	eor	r9, r9
     3ba:	54 01       	movw	r10, r8
		SerialWriteByte(buffer[i]);
     3bc:	89 91       	ld	r24, Y+
     3be:	0e 94 b8 01 	call	0x370	; 0x370 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     3c2:	08 94       	sec
     3c4:	81 1c       	adc	r8, r1
     3c6:	91 1c       	adc	r9, r1
     3c8:	a1 1c       	adc	r10, r1
     3ca:	b1 1c       	adc	r11, r1
     3cc:	8c 14       	cp	r8, r12
     3ce:	9d 04       	cpc	r9, r13
     3d0:	ae 04       	cpc	r10, r14
     3d2:	bf 04       	cpc	r11, r15
     3d4:	99 f7       	brne	.-26     	; 0x3bc <SerialWriteBuffer+0x2c>
		SerialWriteByte(buffer[i]);
	}
}
     3d6:	df 91       	pop	r29
     3d8:	cf 91       	pop	r28
     3da:	ff 90       	pop	r15
     3dc:	ef 90       	pop	r14
     3de:	df 90       	pop	r13
     3e0:	cf 90       	pop	r12
     3e2:	bf 90       	pop	r11
     3e4:	af 90       	pop	r10
     3e6:	9f 90       	pop	r9
     3e8:	8f 90       	pop	r8
     3ea:	08 95       	ret

000003ec <StopSerial>:

void StopSerial(){
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     3ec:	e0 ea       	ldi	r30, 0xA0	; 160
     3ee:	f8 e0       	ldi	r31, 0x08	; 8
     3f0:	84 81       	ldd	r24, Z+4	; 0x04
     3f2:	87 7e       	andi	r24, 0xE7	; 231
     3f4:	84 83       	std	Z+4, r24	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     3f6:	e0 e4       	ldi	r30, 0x40	; 64
     3f8:	f6 e0       	ldi	r31, 0x06	; 6
     3fa:	88 e0       	ldi	r24, 0x08	; 8
     3fc:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     3fe:	82 83       	std	Z+2, r24	; 0x02
     400:	08 95       	ret

00000402 <main>:
 * Created: 9/22/2013 7:28:35 PM
 *  Author: Vlad
 */ 
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     402:	cf 93       	push	r28
     404:	df 93       	push	r29
     406:	cd b7       	in	r28, 0x3d	; 61
     408:	de b7       	in	r29, 0x3e	; 62
     40a:	69 97       	sbiw	r28, 0x19	; 25
     40c:	cd bf       	out	0x3d, r28	; 61
     40e:	de bf       	out	0x3e, r29	; 62
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t freq = 1000;
	volatile uint32_t samples = 0;
     410:	19 82       	std	Y+1, r1	; 0x01
     412:	1a 82       	std	Y+2, r1	; 0x02
     414:	1b 82       	std	Y+3, r1	; 0x03
     416:	1c 82       	std	Y+4, r1	; 0x04
	DataAvailable = 0;
     418:	10 92 d5 21 	sts	0x21D5, r1
	ADC_Sampling_Finished = 1;
     41c:	81 e0       	ldi	r24, 0x01	; 1
     41e:	80 93 cd 50 	sts	0x50CD, r24
	uint8_t RadioMessageBuffer[20];
	set_32MHz();
     422:	0e 94 24 1d 	call	0x3a48	; 0x3a48 <set_32MHz>
	chb_init();
     426:	0e 94 49 16 	call	0x2c92	; 0x2c92 <chb_init>
	chb_set_channel(1);
     42a:	81 e0       	ldi	r24, 0x01	; 1
     42c:	0e 94 be 19 	call	0x337c	; 0x337c <chb_set_channel>
	chb_set_short_addr(0x0002);
     430:	82 e0       	ldi	r24, 0x02	; 2
     432:	90 e0       	ldi	r25, 0x00	; 0
     434:	0e 94 80 18 	call	0x3100	; 0x3100 <chb_set_short_addr>
	pcb_t* pcb = chb_get_pcb();
     438:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <chb_get_pcb>
     43c:	7c 01       	movw	r14, r24

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t freq = 1000;
     43e:	0f 2e       	mov	r0, r31
     440:	f8 ee       	ldi	r31, 0xE8	; 232
     442:	cf 2e       	mov	r12, r31
     444:	f3 e0       	ldi	r31, 0x03	; 3
     446:	df 2e       	mov	r13, r31
     448:	f0 2d       	mov	r31, r0
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
     44a:	19 8e       	std	Y+25, r1	; 0x19
     44c:	02 c0       	rjmp	.+4      	; 0x452 <main+0x50>
					switch(RadioMessageBuffer[1]){
						case 1:
							gain = GAIN_1_gc;
							break;
						case 2:
							gain = GAIN_2_gc;
     44e:	81 e0       	ldi	r24, 0x01	; 1
     450:	89 8f       	std	Y+25, r24	; 0x19
	chb_init();
	chb_set_channel(1);
	chb_set_short_addr(0x0002);
	pcb_t* pcb = chb_get_pcb();
	while(1){
		if(pcb->data_rcv){
     452:	d7 01       	movw	r26, r14
     454:	13 96       	adiw	r26, 0x03	; 3
     456:	8c 91       	ld	r24, X
     458:	13 97       	sbiw	r26, 0x03	; 3
     45a:	88 23       	and	r24, r24
     45c:	d1 f3       	breq	.-12     	; 0x452 <main+0x50>
			//read the data
			length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
     45e:	ce 01       	movw	r24, r28
     460:	05 96       	adiw	r24, 0x05	; 5
     462:	0e 94 21 17 	call	0x2e42	; 0x2e42 <chb_read>
			
			if(length == 1){
     466:	81 30       	cpi	r24, 0x01	; 1
     468:	a1 f7       	brne	.-24     	; 0x452 <main+0x50>
				switch ( RadioMessageBuffer[0])
     46a:	8d 81       	ldd	r24, Y+5	; 0x05
     46c:	82 35       	cpi	r24, 0x52	; 82
     46e:	71 f0       	breq	.+28     	; 0x48c <main+0x8a>
     470:	83 35       	cpi	r24, 0x53	; 83
     472:	30 f4       	brcc	.+12     	; 0x480 <main+0x7e>
     474:	86 34       	cpi	r24, 0x46	; 70
     476:	09 f4       	brne	.+2      	; 0x47a <main+0x78>
     478:	4e c0       	rjmp	.+156    	; 0x516 <main+0x114>
     47a:	87 34       	cpi	r24, 0x47	; 71
     47c:	51 f7       	brne	.-44     	; 0x452 <main+0x50>
     47e:	14 c0       	rjmp	.+40     	; 0x4a8 <main+0xa6>
     480:	83 35       	cpi	r24, 0x53	; 83
     482:	09 f4       	brne	.+2      	; 0x486 <main+0x84>
     484:	4b c0       	rjmp	.+150    	; 0x51c <main+0x11a>
     486:	84 35       	cpi	r24, 0x54	; 84
     488:	21 f7       	brne	.-56     	; 0x452 <main+0x50>
     48a:	50 c0       	rjmp	.+160    	; 0x52c <main+0x12a>
				{
				case 'R':
					//collect data if the ADC is not collecting any data right now
					if(ADC_Sampling_Finished){
     48c:	80 91 cd 50 	lds	r24, 0x50CD
     490:	88 23       	and	r24, r24
     492:	f9 f2       	breq	.-66     	; 0x452 <main+0x50>
						CO_collectADC(ADC_CH_1_gc, gain, freq, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
     494:	80 e0       	ldi	r24, 0x00	; 0
     496:	69 8d       	ldd	r22, Y+25	; 0x19
     498:	a6 01       	movw	r20, r12
     49a:	2c e1       	ldi	r18, 0x1C	; 28
     49c:	37 e0       	ldi	r19, 0x07	; 7
     49e:	0f ed       	ldi	r16, 0xDF	; 223
     4a0:	13 e2       	ldi	r17, 0x23	; 35
     4a2:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <CO_collectADC>
     4a6:	d5 cf       	rjmp	.-86     	; 0x452 <main+0x50>
						//CO_collectSeismic1Channel(ADC_CH_8_gc, gain, freq, 6, TRUE, 1, 2, 3, 4, FR_READ_BUFFER_SIZE/4,(int32_t*)FRAMReadBuffer);
					}						
					break;
				case 'G':
					//set gain to what is specified
					switch(RadioMessageBuffer[1]){
     4a8:	8e 81       	ldd	r24, Y+6	; 0x06
     4aa:	88 30       	cpi	r24, 0x08	; 8
     4ac:	d1 f0       	breq	.+52     	; 0x4e2 <main+0xe0>
     4ae:	89 30       	cpi	r24, 0x09	; 9
     4b0:	38 f4       	brcc	.+14     	; 0x4c0 <main+0xbe>
     4b2:	82 30       	cpi	r24, 0x02	; 2
     4b4:	61 f2       	breq	.-104    	; 0x44e <main+0x4c>
     4b6:	84 30       	cpi	r24, 0x04	; 4
     4b8:	89 f0       	breq	.+34     	; 0x4dc <main+0xda>
     4ba:	81 30       	cpi	r24, 0x01	; 1
     4bc:	09 f5       	brne	.+66     	; 0x500 <main+0xfe>
     4be:	0c c0       	rjmp	.+24     	; 0x4d8 <main+0xd6>
     4c0:	80 32       	cpi	r24, 0x20	; 32
     4c2:	a9 f0       	breq	.+42     	; 0x4ee <main+0xec>
     4c4:	81 32       	cpi	r24, 0x21	; 33
     4c6:	18 f4       	brcc	.+6      	; 0x4ce <main+0xcc>
     4c8:	80 31       	cpi	r24, 0x10	; 16
     4ca:	d1 f4       	brne	.+52     	; 0x500 <main+0xfe>
     4cc:	0d c0       	rjmp	.+26     	; 0x4e8 <main+0xe6>
     4ce:	80 34       	cpi	r24, 0x40	; 64
     4d0:	89 f0       	breq	.+34     	; 0x4f4 <main+0xf2>
     4d2:	80 38       	cpi	r24, 0x80	; 128
     4d4:	a9 f4       	brne	.+42     	; 0x500 <main+0xfe>
     4d6:	11 c0       	rjmp	.+34     	; 0x4fa <main+0xf8>
						case 1:
							gain = GAIN_1_gc;
     4d8:	19 8e       	std	Y+25, r1	; 0x19
     4da:	bb cf       	rjmp	.-138    	; 0x452 <main+0x50>
							break;
						case 2:
							gain = GAIN_2_gc;
							break;
						case 4:
							gain = GAIN_4_gc;
     4dc:	b2 e0       	ldi	r27, 0x02	; 2
     4de:	b9 8f       	std	Y+25, r27	; 0x19
							break;
     4e0:	b8 cf       	rjmp	.-144    	; 0x452 <main+0x50>
						case 8:
							gain = GAIN_8_gc;
     4e2:	e3 e0       	ldi	r30, 0x03	; 3
     4e4:	e9 8f       	std	Y+25, r30	; 0x19
							break;
     4e6:	b5 cf       	rjmp	.-150    	; 0x452 <main+0x50>
						case 16:
							gain = GAIN_16_gc;
     4e8:	f4 e0       	ldi	r31, 0x04	; 4
     4ea:	f9 8f       	std	Y+25, r31	; 0x19
							break;
     4ec:	b2 cf       	rjmp	.-156    	; 0x452 <main+0x50>
						case 32:
							gain = GAIN_32_gc;
     4ee:	85 e0       	ldi	r24, 0x05	; 5
     4f0:	89 8f       	std	Y+25, r24	; 0x19
							break;
     4f2:	af cf       	rjmp	.-162    	; 0x452 <main+0x50>
						case 64:
							gain = GAIN_64_gc;
     4f4:	96 e0       	ldi	r25, 0x06	; 6
     4f6:	99 8f       	std	Y+25, r25	; 0x19
							break;
     4f8:	ac cf       	rjmp	.-168    	; 0x452 <main+0x50>
						case 128:
							gain = GAIN_128_gc;
     4fa:	a7 e0       	ldi	r26, 0x07	; 7
     4fc:	a9 8f       	std	Y+25, r26	; 0x19
							break;
     4fe:	a9 cf       	rjmp	.-174    	; 0x452 <main+0x50>
						default:
							chb_write(0x0000,(uint8_t*)"invalid gain",strlen("invalid gain"));
     500:	80 e0       	ldi	r24, 0x00	; 0
     502:	90 e0       	ldi	r25, 0x00	; 0
     504:	60 e0       	ldi	r22, 0x00	; 0
     506:	70 e2       	ldi	r23, 0x20	; 32
     508:	2c e0       	ldi	r18, 0x0C	; 12
     50a:	30 e0       	ldi	r19, 0x00	; 0
     50c:	40 e0       	ldi	r20, 0x00	; 0
     50e:	50 e0       	ldi	r21, 0x00	; 0
     510:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <chb_write>
							break;
     514:	9e cf       	rjmp	.-196    	; 0x452 <main+0x50>
					}					
					break;
				case 'F':
					//set sampling frequency to what is specified
					freq = *(uint16_t*)(RadioMessageBuffer+1);
     516:	ce 80       	ldd	r12, Y+6	; 0x06
     518:	df 80       	ldd	r13, Y+7	; 0x07
					break;
     51a:	9b cf       	rjmp	.-202    	; 0x452 <main+0x50>
				case 'S':
					//stop the ADC if it is not already
					if(!ADC_Sampling_Finished){
     51c:	80 91 cd 50 	lds	r24, 0x50CD
     520:	88 23       	and	r24, r24
     522:	09 f0       	breq	.+2      	; 0x526 <main+0x124>
     524:	96 cf       	rjmp	.-212    	; 0x452 <main+0x50>
						ADC_Stop_Sampling();
     526:	0e 94 8d 07 	call	0xf1a	; 0xf1a <ADC_Stop_Sampling>
     52a:	93 cf       	rjmp	.-218    	; 0x452 <main+0x50>
					}
					//otherwise, the ADC has finished sampling on its own and the data will be transmitted after this switch statement
					break;
				case 'T':
					if(ADC_Sampling_Finished && DataAvailable){
     52c:	80 91 cd 50 	lds	r24, 0x50CD
     530:	88 23       	and	r24, r24
     532:	09 f4       	brne	.+2      	; 0x536 <main+0x134>
     534:	8e cf       	rjmp	.-228    	; 0x452 <main+0x50>
     536:	80 91 d5 21 	lds	r24, 0x21D5
     53a:	88 23       	and	r24, r24
     53c:	09 f4       	brne	.+2      	; 0x540 <main+0x13e>
     53e:	89 cf       	rjmp	.-238    	; 0x452 <main+0x50>
						//get number of data points collected
						samples = ADC_Get_Num_Samples();
     540:	0e 94 ae 07 	call	0xf5c	; 0xf5c <ADC_Get_Num_Samples>
     544:	a0 e0       	ldi	r26, 0x00	; 0
     546:	b0 e0       	ldi	r27, 0x00	; 0
     548:	89 83       	std	Y+1, r24	; 0x01
     54a:	9a 83       	std	Y+2, r25	; 0x02
     54c:	ab 83       	std	Y+3, r26	; 0x03
     54e:	bc 83       	std	Y+4, r27	; 0x04
						if(samples > 0){
     550:	89 81       	ldd	r24, Y+1	; 0x01
     552:	9a 81       	ldd	r25, Y+2	; 0x02
     554:	ab 81       	ldd	r26, Y+3	; 0x03
     556:	bc 81       	ldd	r27, Y+4	; 0x04
     558:	00 97       	sbiw	r24, 0x00	; 0
     55a:	a1 05       	cpc	r26, r1
     55c:	b1 05       	cpc	r27, r1
     55e:	09 f4       	brne	.+2      	; 0x562 <main+0x160>
     560:	75 c0       	rjmp	.+234    	; 0x64c <main+0x24a>
							for(int i=0;i<(4*samples); i+=100){ 
     562:	89 81       	ldd	r24, Y+1	; 0x01
     564:	9a 81       	ldd	r25, Y+2	; 0x02
     566:	ab 81       	ldd	r26, Y+3	; 0x03
     568:	bc 81       	ldd	r27, Y+4	; 0x04
     56a:	88 0f       	add	r24, r24
     56c:	99 1f       	adc	r25, r25
     56e:	aa 1f       	adc	r26, r26
     570:	bb 1f       	adc	r27, r27
     572:	88 0f       	add	r24, r24
     574:	99 1f       	adc	r25, r25
     576:	aa 1f       	adc	r26, r26
     578:	bb 1f       	adc	r27, r27
     57a:	00 97       	sbiw	r24, 0x00	; 0
     57c:	a1 05       	cpc	r26, r1
     57e:	b1 05       	cpc	r27, r1
     580:	09 f4       	brne	.+2      	; 0x584 <main+0x182>
     582:	64 c0       	rjmp	.+200    	; 0x64c <main+0x24a>
     584:	40 e0       	ldi	r20, 0x00	; 0
     586:	50 e0       	ldi	r21, 0x00	; 0
     588:	ba 01       	movw	r22, r20
     58a:	00 e0       	ldi	r16, 0x00	; 0
     58c:	10 e0       	ldi	r17, 0x00	; 0
								if((samples*4-i) >= 100) chb_write(0x0000,(FRAMReadBuffer+i),100);
     58e:	89 81       	ldd	r24, Y+1	; 0x01
     590:	9a 81       	ldd	r25, Y+2	; 0x02
     592:	ab 81       	ldd	r26, Y+3	; 0x03
     594:	bc 81       	ldd	r27, Y+4	; 0x04
     596:	88 0f       	add	r24, r24
     598:	99 1f       	adc	r25, r25
     59a:	aa 1f       	adc	r26, r26
     59c:	bb 1f       	adc	r27, r27
     59e:	88 0f       	add	r24, r24
     5a0:	99 1f       	adc	r25, r25
     5a2:	aa 1f       	adc	r26, r26
     5a4:	bb 1f       	adc	r27, r27
     5a6:	84 1b       	sub	r24, r20
     5a8:	95 0b       	sbc	r25, r21
     5aa:	a6 0b       	sbc	r26, r22
     5ac:	b7 0b       	sbc	r27, r23
     5ae:	84 36       	cpi	r24, 0x64	; 100
     5b0:	91 05       	cpc	r25, r1
     5b2:	a1 05       	cpc	r26, r1
     5b4:	b1 05       	cpc	r27, r1
     5b6:	60 f0       	brcs	.+24     	; 0x5d0 <main+0x1ce>
     5b8:	b8 01       	movw	r22, r16
     5ba:	61 52       	subi	r22, 0x21	; 33
     5bc:	7c 4d       	sbci	r23, 0xDC	; 220
     5be:	80 e0       	ldi	r24, 0x00	; 0
     5c0:	90 e0       	ldi	r25, 0x00	; 0
     5c2:	24 e6       	ldi	r18, 0x64	; 100
     5c4:	30 e0       	ldi	r19, 0x00	; 0
     5c6:	40 e0       	ldi	r20, 0x00	; 0
     5c8:	50 e0       	ldi	r21, 0x00	; 0
     5ca:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <chb_write>
     5ce:	1c c0       	rjmp	.+56     	; 0x608 <main+0x206>
								else chb_write(0x0000,(FRAMReadBuffer+i),(samples*4-i));
     5d0:	89 81       	ldd	r24, Y+1	; 0x01
     5d2:	9a 81       	ldd	r25, Y+2	; 0x02
     5d4:	ab 81       	ldd	r26, Y+3	; 0x03
     5d6:	bc 81       	ldd	r27, Y+4	; 0x04
     5d8:	f8 01       	movw	r30, r16
     5da:	e1 52       	subi	r30, 0x21	; 33
     5dc:	fc 4d       	sbci	r31, 0xDC	; 220
     5de:	88 0f       	add	r24, r24
     5e0:	99 1f       	adc	r25, r25
     5e2:	aa 1f       	adc	r26, r26
     5e4:	bb 1f       	adc	r27, r27
     5e6:	88 0f       	add	r24, r24
     5e8:	99 1f       	adc	r25, r25
     5ea:	aa 1f       	adc	r26, r26
     5ec:	bb 1f       	adc	r27, r27
     5ee:	4c 01       	movw	r8, r24
     5f0:	5d 01       	movw	r10, r26
     5f2:	84 1a       	sub	r8, r20
     5f4:	95 0a       	sbc	r9, r21
     5f6:	a6 0a       	sbc	r10, r22
     5f8:	b7 0a       	sbc	r11, r23
     5fa:	a5 01       	movw	r20, r10
     5fc:	94 01       	movw	r18, r8
     5fe:	80 e0       	ldi	r24, 0x00	; 0
     600:	90 e0       	ldi	r25, 0x00	; 0
     602:	bf 01       	movw	r22, r30
     604:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <chb_write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     608:	8f ef       	ldi	r24, 0xFF	; 255
     60a:	99 ef       	ldi	r25, 0xF9	; 249
     60c:	a0 e0       	ldi	r26, 0x00	; 0
     60e:	81 50       	subi	r24, 0x01	; 1
     610:	90 40       	sbci	r25, 0x00	; 0
     612:	a0 40       	sbci	r26, 0x00	; 0
     614:	e1 f7       	brne	.-8      	; 0x60e <main+0x20c>
     616:	00 c0       	rjmp	.+0      	; 0x618 <main+0x216>
     618:	00 00       	nop
				case 'T':
					if(ADC_Sampling_Finished && DataAvailable){
						//get number of data points collected
						samples = ADC_Get_Num_Samples();
						if(samples > 0){
							for(int i=0;i<(4*samples); i+=100){ 
     61a:	0c 59       	subi	r16, 0x9C	; 156
     61c:	1f 4f       	sbci	r17, 0xFF	; 255
     61e:	a8 01       	movw	r20, r16
     620:	66 27       	eor	r22, r22
     622:	57 fd       	sbrc	r21, 7
     624:	60 95       	com	r22
     626:	76 2f       	mov	r23, r22
     628:	89 81       	ldd	r24, Y+1	; 0x01
     62a:	9a 81       	ldd	r25, Y+2	; 0x02
     62c:	ab 81       	ldd	r26, Y+3	; 0x03
     62e:	bc 81       	ldd	r27, Y+4	; 0x04
     630:	88 0f       	add	r24, r24
     632:	99 1f       	adc	r25, r25
     634:	aa 1f       	adc	r26, r26
     636:	bb 1f       	adc	r27, r27
     638:	88 0f       	add	r24, r24
     63a:	99 1f       	adc	r25, r25
     63c:	aa 1f       	adc	r26, r26
     63e:	bb 1f       	adc	r27, r27
     640:	48 17       	cp	r20, r24
     642:	59 07       	cpc	r21, r25
     644:	6a 07       	cpc	r22, r26
     646:	7b 07       	cpc	r23, r27
     648:	08 f4       	brcc	.+2      	; 0x64c <main+0x24a>
     64a:	a1 cf       	rjmp	.-190    	; 0x58e <main+0x18c>
								else chb_write(0x0000,(FRAMReadBuffer+i),(samples*4-i));
								//add 1 ms delay between messages
								delay_us(10000);
							}							
						}							
						DataAvailable = 0;
     64c:	10 92 d5 21 	sts	0x21D5, r1
						samples = 0;
     650:	19 82       	std	Y+1, r1	; 0x01
     652:	1a 82       	std	Y+2, r1	; 0x02
     654:	1b 82       	std	Y+3, r1	; 0x03
     656:	1c 82       	std	Y+4, r1	; 0x04
     658:	fc ce       	rjmp	.-520    	; 0x452 <main+0x50>

0000065a <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     65a:	0f 93       	push	r16
     65c:	1f 93       	push	r17
     65e:	cf 93       	push	r28
     660:	8c 01       	movw	r16, r24
	moteID = 1;
     662:	c1 e0       	ldi	r28, 0x01	; 1
     664:	c0 93 c8 50 	sts	0x50C8, r28
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     668:	83 e0       	ldi	r24, 0x03	; 3
     66a:	80 93 5e 40 	sts	0x405E, r24
	chb_init();
     66e:	0e 94 49 16 	call	0x2c92	; 0x2c92 <chb_init>
	chb_set_short_addr(moteID);
     672:	80 91 c8 50 	lds	r24, 0x50C8
     676:	90 e0       	ldi	r25, 0x00	; 0
     678:	0e 94 80 18 	call	0x3100	; 0x3100 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     67c:	88 ec       	ldi	r24, 0xC8	; 200
     67e:	e0 e8       	ldi	r30, 0x80	; 128
     680:	f1 e0       	ldi	r31, 0x01	; 1
     682:	81 83       	std	Z+1, r24	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     684:	e0 e4       	ldi	r30, 0x40	; 64
     686:	f9 e0       	ldi	r31, 0x09	; 9
     688:	89 e0       	ldi	r24, 0x09	; 9
     68a:	80 83       	st	Z, r24
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     68c:	82 e0       	ldi	r24, 0x02	; 2
     68e:	86 83       	std	Z+6, r24	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     690:	24 ef       	ldi	r18, 0xF4	; 244
     692:	31 e0       	ldi	r19, 0x01	; 1
     694:	02 9f       	mul	r16, r18
     696:	c0 01       	movw	r24, r0
     698:	03 9f       	mul	r16, r19
     69a:	90 0d       	add	r25, r0
     69c:	12 9f       	mul	r17, r18
     69e:	90 0d       	add	r25, r0
     6a0:	11 24       	eor	r1, r1
     6a2:	86 a3       	lds	r24, 0x56
     6a4:	97 a3       	lds	r25, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     6a6:	e0 e4       	ldi	r30, 0x40	; 64
     6a8:	f8 e0       	ldi	r31, 0x08	; 8
     6aa:	80 e0       	ldi	r24, 0x00	; 0
     6ac:	9a ef       	ldi	r25, 0xFA	; 250
     6ae:	86 a3       	lds	r24, 0x56
     6b0:	97 a3       	lds	r25, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     6b2:	c6 83       	std	Z+6, r28	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     6b4:	c0 83       	st	Z, r28
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     6b6:	e0 ea       	ldi	r30, 0xA0	; 160
     6b8:	f0 e0       	ldi	r31, 0x00	; 0
     6ba:	82 81       	ldd	r24, Z+2	; 0x02
     6bc:	87 60       	ori	r24, 0x07	; 7
     6be:	82 83       	std	Z+2, r24	; 0x02
	sei(); //  Enable global interrupts
     6c0:	78 94       	sei
}
     6c2:	cf 91       	pop	r28
     6c4:	1f 91       	pop	r17
     6c6:	0f 91       	pop	r16
     6c8:	08 95       	ret

000006ca <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     6ca:	78 94       	sei
     6cc:	1f 92       	push	r1
     6ce:	0f 92       	push	r0
     6d0:	0f b6       	in	r0, 0x3f	; 63
     6d2:	0f 92       	push	r0
     6d4:	0b b6       	in	r0, 0x3b	; 59
     6d6:	0f 92       	push	r0
     6d8:	11 24       	eor	r1, r1
     6da:	ef 92       	push	r14
     6dc:	ff 92       	push	r15
     6de:	0f 93       	push	r16
     6e0:	1f 93       	push	r17
     6e2:	2f 93       	push	r18
     6e4:	3f 93       	push	r19
     6e6:	4f 93       	push	r20
     6e8:	5f 93       	push	r21
     6ea:	6f 93       	push	r22
     6ec:	7f 93       	push	r23
     6ee:	8f 93       	push	r24
     6f0:	9f 93       	push	r25
     6f2:	af 93       	push	r26
     6f4:	bf 93       	push	r27
     6f6:	ef 93       	push	r30
     6f8:	ff 93       	push	r31
     6fa:	cf 93       	push	r28
     6fc:	df 93       	push	r29
     6fe:	cd b7       	in	r28, 0x3d	; 61
     700:	de b7       	in	r29, 0x3e	; 62
     702:	28 97       	sbiw	r28, 0x08	; 8
     704:	cd bf       	out	0x3d, r28	; 61
     706:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     708:	10 92 40 08 	sts	0x0840, r1
	TCD1.CTRLA = 0x00;
     70c:	10 92 40 09 	sts	0x0940, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
     710:	82 e0       	ldi	r24, 0x02	; 2
     712:	80 93 5e 40 	sts	0x405E, r24
	char message[8];
	strcpy(message,"reset");
     716:	de 01       	movw	r26, r28
     718:	11 96       	adiw	r26, 0x01	; 1
     71a:	ed e0       	ldi	r30, 0x0D	; 13
     71c:	f0 e2       	ldi	r31, 0x20	; 32
     71e:	86 e0       	ldi	r24, 0x06	; 6
     720:	01 90       	ld	r0, Z+
     722:	0d 92       	st	X+, r0
     724:	81 50       	subi	r24, 0x01	; 1
     726:	e1 f7       	brne	.-8      	; 0x720 <__vector_83+0x56>
	itoa((int)(moteID),buff,10);
     728:	0f ec       	ldi	r16, 0xCF	; 207
     72a:	10 e5       	ldi	r17, 0x50	; 80
     72c:	80 91 c8 50 	lds	r24, 0x50C8
     730:	90 e0       	ldi	r25, 0x00	; 0
     732:	b8 01       	movw	r22, r16
     734:	4a e0       	ldi	r20, 0x0A	; 10
     736:	50 e0       	ldi	r21, 0x00	; 0
     738:	0e 94 6a 3b 	call	0x76d4	; 0x76d4 <itoa>
	strcat(message,buff);
     73c:	7e 01       	movw	r14, r28
     73e:	08 94       	sec
     740:	e1 1c       	adc	r14, r1
     742:	f1 1c       	adc	r15, r1
     744:	c7 01       	movw	r24, r14
     746:	b8 01       	movw	r22, r16
     748:	0e 94 51 3b 	call	0x76a2	; 0x76a2 <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
     74c:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
     750:	f7 01       	movw	r30, r14
     752:	01 90       	ld	r0, Z+
     754:	00 20       	and	r0, r0
     756:	e9 f7       	brne	.-6      	; 0x752 <__vector_83+0x88>
     758:	31 97       	sbiw	r30, 0x01	; 1
     75a:	ee 19       	sub	r30, r14
     75c:	ff 09       	sbc	r31, r15
     75e:	9f 01       	movw	r18, r30
     760:	40 e0       	ldi	r20, 0x00	; 0
     762:	50 e0       	ldi	r21, 0x00	; 0
     764:	80 e0       	ldi	r24, 0x00	; 0
     766:	90 e0       	ldi	r25, 0x00	; 0
     768:	b7 01       	movw	r22, r14
     76a:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <chb_write>
}	
     76e:	28 96       	adiw	r28, 0x08	; 8
     770:	cd bf       	out	0x3d, r28	; 61
     772:	de bf       	out	0x3e, r29	; 62
     774:	df 91       	pop	r29
     776:	cf 91       	pop	r28
     778:	ff 91       	pop	r31
     77a:	ef 91       	pop	r30
     77c:	bf 91       	pop	r27
     77e:	af 91       	pop	r26
     780:	9f 91       	pop	r25
     782:	8f 91       	pop	r24
     784:	7f 91       	pop	r23
     786:	6f 91       	pop	r22
     788:	5f 91       	pop	r21
     78a:	4f 91       	pop	r20
     78c:	3f 91       	pop	r19
     78e:	2f 91       	pop	r18
     790:	1f 91       	pop	r17
     792:	0f 91       	pop	r16
     794:	ff 90       	pop	r15
     796:	ef 90       	pop	r14
     798:	0f 90       	pop	r0
     79a:	0b be       	out	0x3b, r0	; 59
     79c:	0f 90       	pop	r0
     79e:	0f be       	out	0x3f, r0	; 63
     7a0:	0f 90       	pop	r0
     7a2:	1f 90       	pop	r1
     7a4:	18 95       	reti

000007a6 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     7a6:	cf 93       	push	r28
     7a8:	c6 2f       	mov	r28, r22
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     7aa:	21 e0       	ldi	r18, 0x01	; 1
     7ac:	30 e0       	ldi	r19, 0x00	; 0
     7ae:	a9 01       	movw	r20, r18
     7b0:	02 c0       	rjmp	.+4      	; 0x7b6 <set_ampGain+0x10>
     7b2:	44 0f       	add	r20, r20
     7b4:	55 1f       	adc	r21, r21
     7b6:	8a 95       	dec	r24
     7b8:	e2 f7       	brpl	.-8      	; 0x7b2 <set_ampGain+0xc>
     7ba:	ca 01       	movw	r24, r20
     7bc:	61 e0       	ldi	r22, 0x01	; 1
     7be:	0e 94 e5 1d 	call	0x3bca	; 0x3bca <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     7c2:	c0 ff       	sbrs	r28, 0
     7c4:	05 c0       	rjmp	.+10     	; 0x7d0 <set_ampGain+0x2a>
     7c6:	80 e4       	ldi	r24, 0x40	; 64
     7c8:	e0 e0       	ldi	r30, 0x00	; 0
     7ca:	f6 e0       	ldi	r31, 0x06	; 6
     7cc:	85 83       	std	Z+5, r24	; 0x05
     7ce:	04 c0       	rjmp	.+8      	; 0x7d8 <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
     7d0:	80 e4       	ldi	r24, 0x40	; 64
     7d2:	e0 e0       	ldi	r30, 0x00	; 0
     7d4:	f6 e0       	ldi	r31, 0x06	; 6
     7d6:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     7d8:	c1 ff       	sbrs	r28, 1
     7da:	05 c0       	rjmp	.+10     	; 0x7e6 <set_ampGain+0x40>
     7dc:	82 e0       	ldi	r24, 0x02	; 2
     7de:	e0 e2       	ldi	r30, 0x20	; 32
     7e0:	f6 e0       	ldi	r31, 0x06	; 6
     7e2:	85 83       	std	Z+5, r24	; 0x05
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
     7e6:	82 e0       	ldi	r24, 0x02	; 2
     7e8:	e0 e2       	ldi	r30, 0x20	; 32
     7ea:	f6 e0       	ldi	r31, 0x06	; 6
     7ec:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     7ee:	c2 ff       	sbrs	r28, 2
     7f0:	05 c0       	rjmp	.+10     	; 0x7fc <set_ampGain+0x56>
     7f2:	84 e0       	ldi	r24, 0x04	; 4
     7f4:	e0 e2       	ldi	r30, 0x20	; 32
     7f6:	f6 e0       	ldi	r31, 0x06	; 6
     7f8:	85 83       	std	Z+5, r24	; 0x05
     7fa:	04 c0       	rjmp	.+8      	; 0x804 <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
     7fc:	84 e0       	ldi	r24, 0x04	; 4
     7fe:	e0 e2       	ldi	r30, 0x20	; 32
     800:	f6 e0       	ldi	r31, 0x06	; 6
     802:	86 83       	std	Z+6, r24	; 0x06
     804:	5a e0       	ldi	r21, 0x0A	; 10
     806:	5a 95       	dec	r21
     808:	f1 f7       	brne	.-4      	; 0x806 <set_ampGain+0x60>
     80a:	00 c0       	rjmp	.+0      	; 0x80c <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
     80c:	8f ef       	ldi	r24, 0xFF	; 255
     80e:	61 e0       	ldi	r22, 0x01	; 1
     810:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
     814:	cf 91       	pop	r28
     816:	08 95       	ret

00000818 <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     818:	cf 93       	push	r28
     81a:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     81c:	c8 2f       	mov	r28, r24
     81e:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
     820:	d8 2f       	mov	r29, r24
     822:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     824:	28 2f       	mov	r18, r24
     826:	30 e0       	ldi	r19, 0x00	; 0
     828:	a9 01       	movw	r20, r18
     82a:	45 70       	andi	r20, 0x05	; 5
     82c:	50 70       	andi	r21, 0x00	; 0
     82e:	41 15       	cp	r20, r1
     830:	51 05       	cpc	r21, r1
     832:	49 f0       	breq	.+18     	; 0x846 <set_filter+0x2e>
     834:	90 91 81 50 	lds	r25, 0x5081
     838:	48 2f       	mov	r20, r24
     83a:	42 95       	swap	r20
     83c:	4f 70       	andi	r20, 0x0F	; 15
     83e:	90 7f       	andi	r25, 0xF0	; 240
     840:	94 2b       	or	r25, r20
     842:	90 93 81 50 	sts	0x5081, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     846:	2a 70       	andi	r18, 0x0A	; 10
     848:	30 70       	andi	r19, 0x00	; 0
     84a:	21 15       	cp	r18, r1
     84c:	31 05       	cpc	r19, r1
     84e:	39 f0       	breq	.+14     	; 0x85e <set_filter+0x46>
     850:	90 91 81 50 	lds	r25, 0x5081
     854:	80 7f       	andi	r24, 0xF0	; 240
     856:	9f 70       	andi	r25, 0x0F	; 15
     858:	89 2b       	or	r24, r25
     85a:	80 93 81 50 	sts	0x5081, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     85e:	84 e0       	ldi	r24, 0x04	; 4
     860:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     864:	80 91 81 50 	lds	r24, 0x5081
     868:	80 93 65 50 	sts	0x5065, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     86c:	cc 23       	and	r28, r28
     86e:	19 f0       	breq	.+6      	; 0x876 <set_filter+0x5e>
     870:	81 e0       	ldi	r24, 0x01	; 1
     872:	0e 94 94 1d 	call	0x3b28	; 0x3b28 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     876:	dd 23       	and	r29, r29
     878:	19 f0       	breq	.+6      	; 0x880 <set_filter+0x68>
     87a:	81 e0       	ldi	r24, 0x01	; 1
     87c:	0e 94 a0 1d 	call	0x3b40	; 0x3b40 <upperMuxCS>

	SPICS(TRUE);
     880:	81 e0       	ldi	r24, 0x01	; 1
     882:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     886:	8f ef       	ldi	r24, 0xFF	; 255
     888:	e0 ec       	ldi	r30, 0xC0	; 192
     88a:	f8 e0       	ldi	r31, 0x08	; 8
     88c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     88e:	82 81       	ldd	r24, Z+2	; 0x02
     890:	88 23       	and	r24, r24
     892:	ec f7       	brge	.-6      	; 0x88e <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
     894:	e0 ec       	ldi	r30, 0xC0	; 192
     896:	f8 e0       	ldi	r31, 0x08	; 8
     898:	83 81       	ldd	r24, Z+3	; 0x03
     89a:	80 93 71 50 	sts	0x5071, r24

	nop();
     89e:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     8a0:	a1 e7       	ldi	r26, 0x71	; 113
     8a2:	b0 e5       	ldi	r27, 0x50	; 80
     8a4:	1c 97       	sbiw	r26, 0x0c	; 12
     8a6:	8c 91       	ld	r24, X
     8a8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     8aa:	82 81       	ldd	r24, Z+2	; 0x02
     8ac:	88 23       	and	r24, r24
     8ae:	ec f7       	brge	.-6      	; 0x8aa <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     8b0:	e0 ec       	ldi	r30, 0xC0	; 192
     8b2:	f8 e0       	ldi	r31, 0x08	; 8
     8b4:	83 81       	ldd	r24, Z+3	; 0x03
     8b6:	80 93 71 50 	sts	0x5071, r24
	SPICS(FALSE);
     8ba:	80 e0       	ldi	r24, 0x00	; 0
     8bc:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     8c0:	cc 23       	and	r28, r28
     8c2:	19 f0       	breq	.+6      	; 0x8ca <set_filter+0xb2>
     8c4:	80 e0       	ldi	r24, 0x00	; 0
     8c6:	0e 94 94 1d 	call	0x3b28	; 0x3b28 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     8ca:	dd 23       	and	r29, r29
     8cc:	19 f0       	breq	.+6      	; 0x8d4 <set_filter+0xbc>
     8ce:	80 e0       	ldi	r24, 0x00	; 0
     8d0:	0e 94 a0 1d 	call	0x3b40	; 0x3b40 <upperMuxCS>
	SPIDisable();
     8d4:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <SPIDisable>
}
     8d8:	df 91       	pop	r29
     8da:	cf 91       	pop	r28
     8dc:	08 95       	ret

000008de <ADCPower>:
	*avgV = (average * 1000 / 4095) - 50;
	*maxV = (max * 1000 / 4095) - 50;
	*minV = (min * 1000  / 4095) - 50;
}

void ADCPower(uint8_t on) {
     8de:	0f 93       	push	r16
     8e0:	1f 93       	push	r17
     8e2:	cf 93       	push	r28
     8e4:	df 93       	push	r29
	
	if (on) {
     8e6:	88 23       	and	r24, r24
     8e8:	09 f4       	brne	.+2      	; 0x8ec <ADCPower+0xe>
     8ea:	46 c0       	rjmp	.+140    	; 0x978 <ADCPower+0x9a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     8ec:	00 e0       	ldi	r16, 0x00	; 0
     8ee:	16 e0       	ldi	r17, 0x06	; 6
     8f0:	8e ed       	ldi	r24, 0xDE	; 222
     8f2:	d8 01       	movw	r26, r16
     8f4:	11 96       	adiw	r26, 0x01	; 1
     8f6:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     8f8:	c0 e2       	ldi	r28, 0x20	; 32
     8fa:	d6 e0       	ldi	r29, 0x06	; 6
     8fc:	4e e0       	ldi	r20, 0x0E	; 14
     8fe:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     900:	e0 e4       	ldi	r30, 0x40	; 64
     902:	f6 e0       	ldi	r31, 0x06	; 6
     904:	63 e0       	ldi	r22, 0x03	; 3
     906:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     908:	80 e8       	ldi	r24, 0x80	; 128
     90a:	96 e0       	ldi	r25, 0x06	; 6
     90c:	50 e1       	ldi	r21, 0x10	; 16
     90e:	dc 01       	movw	r26, r24
     910:	11 96       	adiw	r26, 0x01	; 1
     912:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     914:	20 ea       	ldi	r18, 0xA0	; 160
     916:	36 e0       	ldi	r19, 0x06	; 6
     918:	d9 01       	movw	r26, r18
     91a:	11 96       	adiw	r26, 0x01	; 1
     91c:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     91e:	7e e9       	ldi	r23, 0x9E	; 158
     920:	d8 01       	movw	r26, r16
     922:	15 96       	adiw	r26, 0x05	; 5
     924:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     926:	78 e0       	ldi	r23, 0x08	; 8
     928:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     92a:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     92c:	ec 01       	movw	r28, r24
     92e:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     930:	d9 01       	movw	r26, r18
     932:	15 96       	adiw	r26, 0x05	; 5
     934:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
     936:	10 92 81 50 	sts	0x5081, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     93a:	8f ef       	ldi	r24, 0xFF	; 255
     93c:	93 ec       	ldi	r25, 0xC3	; 195
     93e:	a9 e0       	ldi	r26, 0x09	; 9
     940:	81 50       	subi	r24, 0x01	; 1
     942:	90 40       	sbci	r25, 0x00	; 0
     944:	a0 40       	sbci	r26, 0x00	; 0
     946:	e1 f7       	brne	.-8      	; 0x940 <ADCPower+0x62>
     948:	00 c0       	rjmp	.+0      	; 0x94a <ADCPower+0x6c>
     94a:	00 00       	nop
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     94c:	80 e4       	ldi	r24, 0x40	; 64
     94e:	82 83       	std	Z+2, r24	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     950:	10 92 82 50 	sts	0x5082, r1
     954:	10 92 ce 50 	sts	0x50CE, r1
     958:	10 92 d6 23 	sts	0x23D6, r1
     95c:	10 92 7a 50 	sts	0x507A, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
     960:	8f ef       	ldi	r24, 0xFF	; 255
     962:	61 e0       	ldi	r22, 0x01	; 1
     964:	0e 94 e9 1e 	call	0x3dd2	; 0x3dd2 <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     968:	8f ef       	ldi	r24, 0xFF	; 255
     96a:	61 e0       	ldi	r22, 0x01	; 1
     96c:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     970:	8f ef       	ldi	r24, 0xFF	; 255
     972:	0e 94 0c 04 	call	0x818	; 0x818 <set_filter>
     976:	32 c0       	rjmp	.+100    	; 0x9dc <ADCPower+0xfe>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     978:	00 e0       	ldi	r16, 0x00	; 0
     97a:	16 e0       	ldi	r17, 0x06	; 6
     97c:	7e ed       	ldi	r23, 0xDE	; 222
     97e:	d8 01       	movw	r26, r16
     980:	16 96       	adiw	r26, 0x06	; 6
     982:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     984:	a0 e2       	ldi	r26, 0x20	; 32
     986:	b6 e0       	ldi	r27, 0x06	; 6
     988:	4e e0       	ldi	r20, 0x0E	; 14
     98a:	16 96       	adiw	r26, 0x06	; 6
     98c:	4c 93       	st	X, r20
     98e:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     990:	20 e4       	ldi	r18, 0x40	; 64
     992:	36 e0       	ldi	r19, 0x06	; 6
     994:	63 e0       	ldi	r22, 0x03	; 3
     996:	e9 01       	movw	r28, r18
     998:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     99a:	c0 e8       	ldi	r28, 0x80	; 128
     99c:	d6 e0       	ldi	r29, 0x06	; 6
     99e:	50 e1       	ldi	r21, 0x10	; 16
     9a0:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     9a2:	80 ea       	ldi	r24, 0xA0	; 160
     9a4:	96 e0       	ldi	r25, 0x06	; 6
     9a6:	fc 01       	movw	r30, r24
     9a8:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     9aa:	f8 01       	movw	r30, r16
     9ac:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     9ae:	12 96       	adiw	r26, 0x02	; 2
     9b0:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     9b2:	d9 01       	movw	r26, r18
     9b4:	12 96       	adiw	r26, 0x02	; 2
     9b6:	6c 93       	st	X, r22
     9b8:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
     9ba:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     9bc:	ec 01       	movw	r28, r24
     9be:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     9c0:	80 e4       	ldi	r24, 0x40	; 64
     9c2:	12 96       	adiw	r26, 0x02	; 2
     9c4:	8c 93       	st	X, r24
     9c6:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     9c8:	10 92 82 50 	sts	0x5082, r1
     9cc:	10 92 ce 50 	sts	0x50CE, r1
     9d0:	10 92 d6 23 	sts	0x23D6, r1
     9d4:	10 92 7a 50 	sts	0x507A, r1
		channelStatus = 0x00;
     9d8:	10 92 81 50 	sts	0x5081, r1
		
	}
}
     9dc:	df 91       	pop	r29
     9de:	cf 91       	pop	r28
     9e0:	1f 91       	pop	r17
     9e2:	0f 91       	pop	r16
     9e4:	08 95       	ret

000009e6 <CO_collectBatt>:
	*avgV = (average * 1000 / 4095) - 50;
	*maxV = (max * 1000 / 4095) - 50;
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     9e6:	4f 92       	push	r4
     9e8:	5f 92       	push	r5
     9ea:	6f 92       	push	r6
     9ec:	7f 92       	push	r7
     9ee:	8f 92       	push	r8
     9f0:	9f 92       	push	r9
     9f2:	af 92       	push	r10
     9f4:	bf 92       	push	r11
     9f6:	ef 92       	push	r14
     9f8:	ff 92       	push	r15
     9fa:	0f 93       	push	r16
     9fc:	1f 93       	push	r17
     9fe:	cf 93       	push	r28
     a00:	df 93       	push	r29
     a02:	cd b7       	in	r28, 0x3d	; 61
     a04:	de b7       	in	r29, 0x3e	; 62
     a06:	2b 97       	sbiw	r28, 0x0b	; 11
     a08:	cd bf       	out	0x3d, r28	; 61
     a0a:	de bf       	out	0x3e, r29	; 62
     a0c:	8e 83       	std	Y+6, r24	; 0x06
     a0e:	9f 83       	std	Y+7, r25	; 0x07
     a10:	68 87       	std	Y+8, r22	; 0x08
     a12:	79 87       	std	Y+9, r23	; 0x09
     a14:	4a 87       	std	Y+10, r20	; 0x0a
     a16:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
     a18:	81 e0       	ldi	r24, 0x01	; 1
     a1a:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     a1e:	84 e0       	ldi	r24, 0x04	; 4
     a20:	60 e0       	ldi	r22, 0x00	; 0
     a22:	0e 94 e9 1e 	call	0x3dd2	; 0x3dd2 <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     a26:	84 e0       	ldi	r24, 0x04	; 4
     a28:	60 e0       	ldi	r22, 0x00	; 0
     a2a:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <PortEx_OUTSET>
     a2e:	2f ef       	ldi	r18, 0xFF	; 255
     a30:	33 ec       	ldi	r19, 0xC3	; 195
     a32:	49 e0       	ldi	r20, 0x09	; 9
     a34:	21 50       	subi	r18, 0x01	; 1
     a36:	30 40       	sbci	r19, 0x00	; 0
     a38:	40 40       	sbci	r20, 0x00	; 0
     a3a:	e1 f7       	brne	.-8      	; 0xa34 <CO_collectBatt+0x4e>
     a3c:	00 c0       	rjmp	.+0      	; 0xa3e <CO_collectBatt+0x58>
     a3e:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     a40:	80 e4       	ldi	r24, 0x40	; 64
     a42:	92 e0       	ldi	r25, 0x02	; 2
     a44:	0e 94 1b 16 	call	0x2c36	; 0x2c36 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     a48:	00 e4       	ldi	r16, 0x40	; 64
     a4a:	12 e0       	ldi	r17, 0x02	; 2
     a4c:	d8 01       	movw	r26, r16
     a4e:	11 96       	adiw	r26, 0x01	; 1
     a50:	8c 91       	ld	r24, X
     a52:	11 97       	sbiw	r26, 0x01	; 1
     a54:	89 7e       	andi	r24, 0xE9	; 233
     a56:	11 96       	adiw	r26, 0x01	; 1
     a58:	8c 93       	st	X, r24
     a5a:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     a5c:	14 96       	adiw	r26, 0x04	; 4
     a5e:	8c 91       	ld	r24, X
     a60:	14 97       	sbiw	r26, 0x04	; 4
     a62:	88 7f       	andi	r24, 0xF8	; 248
     a64:	83 60       	ori	r24, 0x03	; 3
     a66:	14 96       	adiw	r26, 0x04	; 4
     a68:	8c 93       	st	X, r24
     a6a:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     a6c:	12 96       	adiw	r26, 0x02	; 2
     a6e:	8c 91       	ld	r24, X
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	8f 7c       	andi	r24, 0xCF	; 207
     a74:	12 96       	adiw	r26, 0x02	; 2
     a76:	8c 93       	st	X, r24
     a78:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     a7a:	0f 2e       	mov	r0, r31
     a7c:	f0 e6       	ldi	r31, 0x60	; 96
     a7e:	ef 2e       	mov	r14, r31
     a80:	f2 e0       	ldi	r31, 0x02	; 2
     a82:	ff 2e       	mov	r15, r31
     a84:	f0 2d       	mov	r31, r0
     a86:	f7 01       	movw	r30, r14
     a88:	80 81       	ld	r24, Z
     a8a:	80 7e       	andi	r24, 0xE0	; 224
     a8c:	81 60       	ori	r24, 0x01	; 1
     a8e:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     a90:	89 e0       	ldi	r24, 0x09	; 9
     a92:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
     a94:	8c 91       	ld	r24, X
     a96:	81 60       	ori	r24, 0x01	; 1
     a98:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     a9a:	80 e4       	ldi	r24, 0x40	; 64
     a9c:	92 e0       	ldi	r25, 0x02	; 2
     a9e:	0e 94 a0 15 	call	0x2b40	; 0x2b40 <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     aa2:	80 e4       	ldi	r24, 0x40	; 64
     aa4:	92 e0       	ldi	r25, 0x02	; 2
     aa6:	60 e6       	ldi	r22, 0x60	; 96
     aa8:	72 e0       	ldi	r23, 0x02	; 2
     aaa:	40 e0       	ldi	r20, 0x00	; 0
     aac:	0e 94 aa 15 	call	0x2b54	; 0x2b54 <ADC_Offset_Get_Unsigned>
     ab0:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
     ab2:	d8 01       	movw	r26, r16
     ab4:	8c 91       	ld	r24, X
     ab6:	8e 7f       	andi	r24, 0xFE	; 254
     ab8:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     aba:	f7 01       	movw	r30, r14
     abc:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     abe:	13 96       	adiw	r26, 0x03	; 3
     ac0:	8c 91       	ld	r24, X
     ac2:	13 97       	sbiw	r26, 0x03	; 3
     ac4:	8f 73       	andi	r24, 0x3F	; 63
     ac6:	13 96       	adiw	r26, 0x03	; 3
     ac8:	8c 93       	st	X, r24
     aca:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     acc:	8c 91       	ld	r24, X
     ace:	81 60       	ori	r24, 0x01	; 1
     ad0:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     ad2:	80 e4       	ldi	r24, 0x40	; 64
     ad4:	92 e0       	ldi	r25, 0x02	; 2
     ad6:	0e 94 a0 15 	call	0x2b40	; 0x2b40 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     ada:	d8 01       	movw	r26, r16
     adc:	11 96       	adiw	r26, 0x01	; 1
     ade:	8c 91       	ld	r24, X
     ae0:	11 97       	sbiw	r26, 0x01	; 1
     ae2:	88 60       	ori	r24, 0x08	; 8
     ae4:	11 96       	adiw	r26, 0x01	; 1
     ae6:	8c 93       	st	X, r24
     ae8:	ee 24       	eor	r14, r14
     aea:	ff 24       	eor	r15, r15
     aec:	68 94       	set
     aee:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
     af0:	44 24       	eor	r4, r4
     af2:	55 24       	eor	r5, r5
     af4:	32 01       	movw	r6, r4
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     af6:	20 e0       	ldi	r18, 0x00	; 0
     af8:	30 e1       	ldi	r19, 0x10	; 16
     afa:	40 e0       	ldi	r20, 0x00	; 0
     afc:	50 e0       	ldi	r21, 0x00	; 0
     afe:	2a 83       	std	Y+2, r18	; 0x02
     b00:	3b 83       	std	Y+3, r19	; 0x03
     b02:	4c 83       	std	Y+4, r20	; 0x04
     b04:	5d 83       	std	Y+5, r21	; 0x05
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
     b06:	88 24       	eor	r8, r8
     b08:	99 24       	eor	r9, r9
     b0a:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     b0c:	00 e6       	ldi	r16, 0x60	; 96
     b0e:	12 e0       	ldi	r17, 0x02	; 2
     b10:	d8 01       	movw	r26, r16
     b12:	13 96       	adiw	r26, 0x03	; 3
     b14:	8c 91       	ld	r24, X
     b16:	13 97       	sbiw	r26, 0x03	; 3
     b18:	80 ff       	sbrs	r24, 0
     b1a:	fa cf       	rjmp	.-12     	; 0xb10 <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     b1c:	69 81       	ldd	r22, Y+1	; 0x01
     b1e:	c8 01       	movw	r24, r16
     b20:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
     b24:	a0 e0       	ldi	r26, 0x00	; 0
     b26:	b0 e0       	ldi	r27, 0x00	; 0
     b28:	88 0e       	add	r8, r24
     b2a:	99 1e       	adc	r9, r25
     b2c:	aa 1e       	adc	r10, r26
     b2e:	bb 1e       	adc	r11, r27
     b30:	48 16       	cp	r4, r24
     b32:	59 06       	cpc	r5, r25
     b34:	6a 06       	cpc	r6, r26
     b36:	7b 06       	cpc	r7, r27
     b38:	10 f4       	brcc	.+4      	; 0xb3e <CO_collectBatt+0x158>
     b3a:	2c 01       	movw	r4, r24
     b3c:	3d 01       	movw	r6, r26
     b3e:	2a 81       	ldd	r18, Y+2	; 0x02
     b40:	3b 81       	ldd	r19, Y+3	; 0x03
     b42:	4c 81       	ldd	r20, Y+4	; 0x04
     b44:	5d 81       	ldd	r21, Y+5	; 0x05
     b46:	82 17       	cp	r24, r18
     b48:	93 07       	cpc	r25, r19
     b4a:	a4 07       	cpc	r26, r20
     b4c:	b5 07       	cpc	r27, r21
     b4e:	20 f4       	brcc	.+8      	; 0xb58 <CO_collectBatt+0x172>
     b50:	8a 83       	std	Y+2, r24	; 0x02
     b52:	9b 83       	std	Y+3, r25	; 0x03
     b54:	ac 83       	std	Y+4, r26	; 0x04
     b56:	bd 83       	std	Y+5, r27	; 0x05
     b58:	08 94       	sec
     b5a:	e1 08       	sbc	r14, r1
     b5c:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     b5e:	e1 14       	cp	r14, r1
     b60:	f1 04       	cpc	r15, r1
     b62:	b1 f6       	brne	.-84     	; 0xb10 <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     b64:	e0 e4       	ldi	r30, 0x40	; 64
     b66:	f2 e0       	ldi	r31, 0x02	; 2
     b68:	81 81       	ldd	r24, Z+1	; 0x01
     b6a:	87 7f       	andi	r24, 0xF7	; 247
     b6c:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
     b6e:	80 81       	ld	r24, Z
     b70:	8e 7f       	andi	r24, 0xFE	; 254
     b72:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     b74:	84 e0       	ldi	r24, 0x04	; 4
     b76:	60 e0       	ldi	r22, 0x00	; 0
     b78:	0e 94 91 1e 	call	0x3d22	; 0x3d22 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     b7c:	80 e0       	ldi	r24, 0x00	; 0
     b7e:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
     b82:	c5 01       	movw	r24, r10
     b84:	b4 01       	movw	r22, r8
     b86:	05 2e       	mov	r0, r21
     b88:	5a e0       	ldi	r21, 0x0A	; 10
     b8a:	96 95       	lsr	r25
     b8c:	87 95       	ror	r24
     b8e:	77 95       	ror	r23
     b90:	67 95       	ror	r22
     b92:	5a 95       	dec	r21
     b94:	d1 f7       	brne	.-12     	; 0xb8a <CO_collectBatt+0x1a4>
     b96:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     b98:	28 ee       	ldi	r18, 0xE8	; 232
     b9a:	33 e0       	ldi	r19, 0x03	; 3
     b9c:	40 e0       	ldi	r20, 0x00	; 0
     b9e:	50 e0       	ldi	r21, 0x00	; 0
     ba0:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
     ba4:	0f 2e       	mov	r0, r31
     ba6:	ff ef       	ldi	r31, 0xFF	; 255
     ba8:	8f 2e       	mov	r8, r31
     baa:	ff e0       	ldi	r31, 0x0F	; 15
     bac:	9f 2e       	mov	r9, r31
     bae:	f0 e0       	ldi	r31, 0x00	; 0
     bb0:	af 2e       	mov	r10, r31
     bb2:	f0 e0       	ldi	r31, 0x00	; 0
     bb4:	bf 2e       	mov	r11, r31
     bb6:	f0 2d       	mov	r31, r0
     bb8:	a5 01       	movw	r20, r10
     bba:	94 01       	movw	r18, r8
     bbc:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
     bc0:	c9 01       	movw	r24, r18
     bc2:	c2 97       	sbiw	r24, 0x32	; 50
     bc4:	ae 81       	ldd	r26, Y+6	; 0x06
     bc6:	bf 81       	ldd	r27, Y+7	; 0x07
     bc8:	8d 93       	st	X+, r24
     bca:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
     bcc:	c3 01       	movw	r24, r6
     bce:	b2 01       	movw	r22, r4
     bd0:	28 ee       	ldi	r18, 0xE8	; 232
     bd2:	33 e0       	ldi	r19, 0x03	; 3
     bd4:	40 e0       	ldi	r20, 0x00	; 0
     bd6:	50 e0       	ldi	r21, 0x00	; 0
     bd8:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
     bdc:	a5 01       	movw	r20, r10
     bde:	94 01       	movw	r18, r8
     be0:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
     be4:	c9 01       	movw	r24, r18
     be6:	c2 97       	sbiw	r24, 0x32	; 50
     be8:	ea 85       	ldd	r30, Y+10	; 0x0a
     bea:	fb 85       	ldd	r31, Y+11	; 0x0b
     bec:	80 83       	st	Z, r24
     bee:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     bf0:	6a 81       	ldd	r22, Y+2	; 0x02
     bf2:	7b 81       	ldd	r23, Y+3	; 0x03
     bf4:	8c 81       	ldd	r24, Y+4	; 0x04
     bf6:	9d 81       	ldd	r25, Y+5	; 0x05
     bf8:	28 ee       	ldi	r18, 0xE8	; 232
     bfa:	33 e0       	ldi	r19, 0x03	; 3
     bfc:	40 e0       	ldi	r20, 0x00	; 0
     bfe:	50 e0       	ldi	r21, 0x00	; 0
     c00:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
     c04:	a5 01       	movw	r20, r10
     c06:	94 01       	movw	r18, r8
     c08:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
     c0c:	22 53       	subi	r18, 0x32	; 50
     c0e:	30 40       	sbci	r19, 0x00	; 0
     c10:	a8 85       	ldd	r26, Y+8	; 0x08
     c12:	b9 85       	ldd	r27, Y+9	; 0x09
     c14:	2d 93       	st	X+, r18
     c16:	3c 93       	st	X, r19
     c18:	11 97       	sbiw	r26, 0x01	; 1
}
     c1a:	2b 96       	adiw	r28, 0x0b	; 11
     c1c:	cd bf       	out	0x3d, r28	; 61
     c1e:	de bf       	out	0x3e, r29	; 62
     c20:	df 91       	pop	r29
     c22:	cf 91       	pop	r28
     c24:	1f 91       	pop	r17
     c26:	0f 91       	pop	r16
     c28:	ff 90       	pop	r15
     c2a:	ef 90       	pop	r14
     c2c:	bf 90       	pop	r11
     c2e:	af 90       	pop	r10
     c30:	9f 90       	pop	r9
     c32:	8f 90       	pop	r8
     c34:	7f 90       	pop	r7
     c36:	6f 90       	pop	r6
     c38:	5f 90       	pop	r5
     c3a:	4f 90       	pop	r4
     c3c:	08 95       	ret

00000c3e <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     c3e:	4f 92       	push	r4
     c40:	5f 92       	push	r5
     c42:	6f 92       	push	r6
     c44:	7f 92       	push	r7
     c46:	8f 92       	push	r8
     c48:	9f 92       	push	r9
     c4a:	af 92       	push	r10
     c4c:	bf 92       	push	r11
     c4e:	ef 92       	push	r14
     c50:	ff 92       	push	r15
     c52:	0f 93       	push	r16
     c54:	1f 93       	push	r17
     c56:	cf 93       	push	r28
     c58:	df 93       	push	r29
     c5a:	cd b7       	in	r28, 0x3d	; 61
     c5c:	de b7       	in	r29, 0x3e	; 62
     c5e:	2b 97       	sbiw	r28, 0x0b	; 11
     c60:	cd bf       	out	0x3d, r28	; 61
     c62:	de bf       	out	0x3e, r29	; 62
     c64:	8e 83       	std	Y+6, r24	; 0x06
     c66:	9f 83       	std	Y+7, r25	; 0x07
     c68:	68 87       	std	Y+8, r22	; 0x08
     c6a:	79 87       	std	Y+9, r23	; 0x09
     c6c:	4a 87       	std	Y+10, r20	; 0x0a
     c6e:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
     c70:	81 e0       	ldi	r24, 0x01	; 1
     c72:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     c76:	80 e0       	ldi	r24, 0x00	; 0
     c78:	92 e0       	ldi	r25, 0x02	; 2
     c7a:	0e 94 1b 16 	call	0x2c36	; 0x2c36 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     c7e:	00 e0       	ldi	r16, 0x00	; 0
     c80:	12 e0       	ldi	r17, 0x02	; 2
     c82:	d8 01       	movw	r26, r16
     c84:	11 96       	adiw	r26, 0x01	; 1
     c86:	8c 91       	ld	r24, X
     c88:	11 97       	sbiw	r26, 0x01	; 1
     c8a:	89 7e       	andi	r24, 0xE9	; 233
     c8c:	11 96       	adiw	r26, 0x01	; 1
     c8e:	8c 93       	st	X, r24
     c90:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     c92:	14 96       	adiw	r26, 0x04	; 4
     c94:	8c 91       	ld	r24, X
     c96:	14 97       	sbiw	r26, 0x04	; 4
     c98:	88 7f       	andi	r24, 0xF8	; 248
     c9a:	83 60       	ori	r24, 0x03	; 3
     c9c:	14 96       	adiw	r26, 0x04	; 4
     c9e:	8c 93       	st	X, r24
     ca0:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     ca2:	12 96       	adiw	r26, 0x02	; 2
     ca4:	8c 91       	ld	r24, X
     ca6:	12 97       	sbiw	r26, 0x02	; 2
     ca8:	8f 7c       	andi	r24, 0xCF	; 207
     caa:	12 96       	adiw	r26, 0x02	; 2
     cac:	8c 93       	st	X, r24
     cae:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     cb0:	0f 2e       	mov	r0, r31
     cb2:	f0 e2       	ldi	r31, 0x20	; 32
     cb4:	ef 2e       	mov	r14, r31
     cb6:	f2 e0       	ldi	r31, 0x02	; 2
     cb8:	ff 2e       	mov	r15, r31
     cba:	f0 2d       	mov	r31, r0
     cbc:	f7 01       	movw	r30, r14
     cbe:	80 81       	ld	r24, Z
     cc0:	80 7e       	andi	r24, 0xE0	; 224
     cc2:	81 60       	ori	r24, 0x01	; 1
     cc4:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     cc6:	89 e0       	ldi	r24, 0x09	; 9
     cc8:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
     cca:	8c 91       	ld	r24, X
     ccc:	81 60       	ori	r24, 0x01	; 1
     cce:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     cd0:	80 e0       	ldi	r24, 0x00	; 0
     cd2:	92 e0       	ldi	r25, 0x02	; 2
     cd4:	0e 94 a0 15 	call	0x2b40	; 0x2b40 <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     cd8:	80 e0       	ldi	r24, 0x00	; 0
     cda:	92 e0       	ldi	r25, 0x02	; 2
     cdc:	60 e2       	ldi	r22, 0x20	; 32
     cde:	72 e0       	ldi	r23, 0x02	; 2
     ce0:	40 e0       	ldi	r20, 0x00	; 0
     ce2:	0e 94 aa 15 	call	0x2b54	; 0x2b54 <ADC_Offset_Get_Unsigned>
     ce6:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
     ce8:	d8 01       	movw	r26, r16
     cea:	8c 91       	ld	r24, X
     cec:	8e 7f       	andi	r24, 0xFE	; 254
     cee:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     cf0:	f7 01       	movw	r30, r14
     cf2:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     cf4:	13 96       	adiw	r26, 0x03	; 3
     cf6:	8c 91       	ld	r24, X
     cf8:	13 97       	sbiw	r26, 0x03	; 3
     cfa:	8f 73       	andi	r24, 0x3F	; 63
     cfc:	13 96       	adiw	r26, 0x03	; 3
     cfe:	8c 93       	st	X, r24
     d00:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     d02:	8c 91       	ld	r24, X
     d04:	81 60       	ori	r24, 0x01	; 1
     d06:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     d08:	80 e0       	ldi	r24, 0x00	; 0
     d0a:	92 e0       	ldi	r25, 0x02	; 2
     d0c:	0e 94 a0 15 	call	0x2b40	; 0x2b40 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     d10:	d8 01       	movw	r26, r16
     d12:	11 96       	adiw	r26, 0x01	; 1
     d14:	8c 91       	ld	r24, X
     d16:	11 97       	sbiw	r26, 0x01	; 1
     d18:	88 60       	ori	r24, 0x08	; 8
     d1a:	11 96       	adiw	r26, 0x01	; 1
     d1c:	8c 93       	st	X, r24
     d1e:	ee 24       	eor	r14, r14
     d20:	ff 24       	eor	r15, r15
     d22:	68 94       	set
     d24:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
     d26:	44 24       	eor	r4, r4
     d28:	55 24       	eor	r5, r5
     d2a:	32 01       	movw	r6, r4
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     d2c:	20 e0       	ldi	r18, 0x00	; 0
     d2e:	30 e1       	ldi	r19, 0x10	; 16
     d30:	40 e0       	ldi	r20, 0x00	; 0
     d32:	50 e0       	ldi	r21, 0x00	; 0
     d34:	2a 83       	std	Y+2, r18	; 0x02
     d36:	3b 83       	std	Y+3, r19	; 0x03
     d38:	4c 83       	std	Y+4, r20	; 0x04
     d3a:	5d 83       	std	Y+5, r21	; 0x05
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
     d3c:	88 24       	eor	r8, r8
     d3e:	99 24       	eor	r9, r9
     d40:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     d42:	00 e2       	ldi	r16, 0x20	; 32
     d44:	12 e0       	ldi	r17, 0x02	; 2
     d46:	d8 01       	movw	r26, r16
     d48:	13 96       	adiw	r26, 0x03	; 3
     d4a:	8c 91       	ld	r24, X
     d4c:	13 97       	sbiw	r26, 0x03	; 3
     d4e:	80 ff       	sbrs	r24, 0
     d50:	fa cf       	rjmp	.-12     	; 0xd46 <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     d52:	69 81       	ldd	r22, Y+1	; 0x01
     d54:	c8 01       	movw	r24, r16
     d56:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
     d5a:	a0 e0       	ldi	r26, 0x00	; 0
     d5c:	b0 e0       	ldi	r27, 0x00	; 0
     d5e:	88 0e       	add	r8, r24
     d60:	99 1e       	adc	r9, r25
     d62:	aa 1e       	adc	r10, r26
     d64:	bb 1e       	adc	r11, r27
     d66:	48 16       	cp	r4, r24
     d68:	59 06       	cpc	r5, r25
     d6a:	6a 06       	cpc	r6, r26
     d6c:	7b 06       	cpc	r7, r27
     d6e:	10 f4       	brcc	.+4      	; 0xd74 <CO_collectTemp+0x136>
     d70:	2c 01       	movw	r4, r24
     d72:	3d 01       	movw	r6, r26
     d74:	2a 81       	ldd	r18, Y+2	; 0x02
     d76:	3b 81       	ldd	r19, Y+3	; 0x03
     d78:	4c 81       	ldd	r20, Y+4	; 0x04
     d7a:	5d 81       	ldd	r21, Y+5	; 0x05
     d7c:	82 17       	cp	r24, r18
     d7e:	93 07       	cpc	r25, r19
     d80:	a4 07       	cpc	r26, r20
     d82:	b5 07       	cpc	r27, r21
     d84:	20 f4       	brcc	.+8      	; 0xd8e <CO_collectTemp+0x150>
     d86:	8a 83       	std	Y+2, r24	; 0x02
     d88:	9b 83       	std	Y+3, r25	; 0x03
     d8a:	ac 83       	std	Y+4, r26	; 0x04
     d8c:	bd 83       	std	Y+5, r27	; 0x05
     d8e:	08 94       	sec
     d90:	e1 08       	sbc	r14, r1
     d92:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     d94:	e1 14       	cp	r14, r1
     d96:	f1 04       	cpc	r15, r1
     d98:	b1 f6       	brne	.-84     	; 0xd46 <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     d9a:	e0 e0       	ldi	r30, 0x00	; 0
     d9c:	f2 e0       	ldi	r31, 0x02	; 2
     d9e:	81 81       	ldd	r24, Z+1	; 0x01
     da0:	87 7f       	andi	r24, 0xF7	; 247
     da2:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     da4:	80 81       	ld	r24, Z
     da6:	82 60       	ori	r24, 0x02	; 2
     da8:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
     daa:	80 81       	ld	r24, Z
     dac:	8e 7f       	andi	r24, 0xFE	; 254
     dae:	80 83       	st	Z, r24

	ADCPower(FALSE);
     db0:	80 e0       	ldi	r24, 0x00	; 0
     db2:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>

	average = sum / NUM_SAMPLES;
     db6:	c5 01       	movw	r24, r10
     db8:	b4 01       	movw	r22, r8
     dba:	05 2e       	mov	r0, r21
     dbc:	5a e0       	ldi	r21, 0x0A	; 10
     dbe:	96 95       	lsr	r25
     dc0:	87 95       	ror	r24
     dc2:	77 95       	ror	r23
     dc4:	67 95       	ror	r22
     dc6:	5a 95       	dec	r21
     dc8:	d1 f7       	brne	.-12     	; 0xdbe <CO_collectTemp+0x180>
     dca:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     dcc:	28 ee       	ldi	r18, 0xE8	; 232
     dce:	33 e0       	ldi	r19, 0x03	; 3
     dd0:	40 e0       	ldi	r20, 0x00	; 0
     dd2:	50 e0       	ldi	r21, 0x00	; 0
     dd4:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
     dd8:	0f 2e       	mov	r0, r31
     dda:	ff ef       	ldi	r31, 0xFF	; 255
     ddc:	8f 2e       	mov	r8, r31
     dde:	ff e0       	ldi	r31, 0x0F	; 15
     de0:	9f 2e       	mov	r9, r31
     de2:	f0 e0       	ldi	r31, 0x00	; 0
     de4:	af 2e       	mov	r10, r31
     de6:	f0 e0       	ldi	r31, 0x00	; 0
     de8:	bf 2e       	mov	r11, r31
     dea:	f0 2d       	mov	r31, r0
     dec:	a5 01       	movw	r20, r10
     dee:	94 01       	movw	r18, r8
     df0:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
     df4:	c9 01       	movw	r24, r18
     df6:	c2 97       	sbiw	r24, 0x32	; 50
     df8:	ae 81       	ldd	r26, Y+6	; 0x06
     dfa:	bf 81       	ldd	r27, Y+7	; 0x07
     dfc:	8d 93       	st	X+, r24
     dfe:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
     e00:	c3 01       	movw	r24, r6
     e02:	b2 01       	movw	r22, r4
     e04:	28 ee       	ldi	r18, 0xE8	; 232
     e06:	33 e0       	ldi	r19, 0x03	; 3
     e08:	40 e0       	ldi	r20, 0x00	; 0
     e0a:	50 e0       	ldi	r21, 0x00	; 0
     e0c:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
     e10:	a5 01       	movw	r20, r10
     e12:	94 01       	movw	r18, r8
     e14:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
     e18:	c9 01       	movw	r24, r18
     e1a:	c2 97       	sbiw	r24, 0x32	; 50
     e1c:	ea 85       	ldd	r30, Y+10	; 0x0a
     e1e:	fb 85       	ldd	r31, Y+11	; 0x0b
     e20:	80 83       	st	Z, r24
     e22:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     e24:	6a 81       	ldd	r22, Y+2	; 0x02
     e26:	7b 81       	ldd	r23, Y+3	; 0x03
     e28:	8c 81       	ldd	r24, Y+4	; 0x04
     e2a:	9d 81       	ldd	r25, Y+5	; 0x05
     e2c:	28 ee       	ldi	r18, 0xE8	; 232
     e2e:	33 e0       	ldi	r19, 0x03	; 3
     e30:	40 e0       	ldi	r20, 0x00	; 0
     e32:	50 e0       	ldi	r21, 0x00	; 0
     e34:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
     e38:	a5 01       	movw	r20, r10
     e3a:	94 01       	movw	r18, r8
     e3c:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
     e40:	22 53       	subi	r18, 0x32	; 50
     e42:	30 40       	sbci	r19, 0x00	; 0
     e44:	a8 85       	ldd	r26, Y+8	; 0x08
     e46:	b9 85       	ldd	r27, Y+9	; 0x09
     e48:	2d 93       	st	X+, r18
     e4a:	3c 93       	st	X, r19
     e4c:	11 97       	sbiw	r26, 0x01	; 1
}
     e4e:	2b 96       	adiw	r28, 0x0b	; 11
     e50:	cd bf       	out	0x3d, r28	; 61
     e52:	de bf       	out	0x3e, r29	; 62
     e54:	df 91       	pop	r29
     e56:	cf 91       	pop	r28
     e58:	1f 91       	pop	r17
     e5a:	0f 91       	pop	r16
     e5c:	ff 90       	pop	r15
     e5e:	ef 90       	pop	r14
     e60:	bf 90       	pop	r11
     e62:	af 90       	pop	r10
     e64:	9f 90       	pop	r9
     e66:	8f 90       	pop	r8
     e68:	7f 90       	pop	r7
     e6a:	6f 90       	pop	r6
     e6c:	5f 90       	pop	r5
     e6e:	4f 90       	pop	r4
     e70:	08 95       	ret

00000e72 <enableADCMUX>:
	SPIDisable();
}

void enableADCMUX(uint8_t on) {
	
	if(on) {
     e72:	88 23       	and	r24, r24
     e74:	31 f0       	breq	.+12     	; 0xe82 <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
     e76:	e0 e0       	ldi	r30, 0x00	; 0
     e78:	f6 e0       	ldi	r31, 0x06	; 6
     e7a:	80 e2       	ldi	r24, 0x20	; 32
     e7c:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
     e7e:	85 83       	std	Z+5, r24	; 0x05
     e80:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
     e82:	e0 e0       	ldi	r30, 0x00	; 0
     e84:	f6 e0       	ldi	r31, 0x06	; 6
     e86:	80 e2       	ldi	r24, 0x20	; 32
     e88:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
     e8a:	82 83       	std	Z+2, r24	; 0x02
     e8c:	08 95       	ret

00000e8e <__vector_20>:
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
     e8e:	1f 92       	push	r1
     e90:	0f 92       	push	r0
     e92:	0f b6       	in	r0, 0x3f	; 63
     e94:	0f 92       	push	r0
     e96:	0b b6       	in	r0, 0x3b	; 59
     e98:	0f 92       	push	r0
     e9a:	11 24       	eor	r1, r1
     e9c:	2f 93       	push	r18
     e9e:	3f 93       	push	r19
     ea0:	4f 93       	push	r20
     ea2:	5f 93       	push	r21
     ea4:	6f 93       	push	r22
     ea6:	7f 93       	push	r23
     ea8:	8f 93       	push	r24
     eaa:	9f 93       	push	r25
     eac:	af 93       	push	r26
     eae:	bf 93       	push	r27
     eb0:	ef 93       	push	r30
     eb2:	ff 93       	push	r31

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     eb4:	e0 e4       	ldi	r30, 0x40	; 64
     eb6:	fa e0       	ldi	r31, 0x0A	; 10
     eb8:	80 81       	ld	r24, Z
     eba:	80 7f       	andi	r24, 0xF0	; 240
     ebc:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     ebe:	a0 e0       	ldi	r26, 0x00	; 0
     ec0:	b8 e0       	ldi	r27, 0x08	; 8
     ec2:	8c 91       	ld	r24, X
     ec4:	80 7f       	andi	r24, 0xF0	; 240
     ec6:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     ec8:	a0 e0       	ldi	r26, 0x00	; 0
     eca:	b9 e0       	ldi	r27, 0x09	; 9
     ecc:	8c 91       	ld	r24, X
     ece:	80 7f       	andi	r24, 0xF0	; 240
     ed0:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     ed2:	80 81       	ld	r24, Z
     ed4:	80 7f       	andi	r24, 0xF0	; 240
     ed6:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
     eda:	80 e0       	ldi	r24, 0x00	; 0
     edc:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	SPIDisable();
     ee0:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <SPIDisable>
	enableADCMUX(FALSE);
     ee4:	80 e0       	ldi	r24, 0x00	; 0
     ee6:	0e 94 39 07 	call	0xe72	; 0xe72 <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
     eea:	81 e0       	ldi	r24, 0x01	; 1
     eec:	80 93 cd 50 	sts	0x50CD, r24
	DataAvailable = 1;
     ef0:	80 93 d5 21 	sts	0x21D5, r24
}
     ef4:	ff 91       	pop	r31
     ef6:	ef 91       	pop	r30
     ef8:	bf 91       	pop	r27
     efa:	af 91       	pop	r26
     efc:	9f 91       	pop	r25
     efe:	8f 91       	pop	r24
     f00:	7f 91       	pop	r23
     f02:	6f 91       	pop	r22
     f04:	5f 91       	pop	r21
     f06:	4f 91       	pop	r20
     f08:	3f 91       	pop	r19
     f0a:	2f 91       	pop	r18
     f0c:	0f 90       	pop	r0
     f0e:	0b be       	out	0x3b, r0	; 59
     f10:	0f 90       	pop	r0
     f12:	0f be       	out	0x3f, r0	; 63
     f14:	0f 90       	pop	r0
     f16:	1f 90       	pop	r1
     f18:	18 95       	reti

00000f1a <ADC_Stop_Sampling>:
//turns off ADC timers/counters and spi bus 
//returns number of samples collected by ADC
void ADC_Stop_Sampling(){
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     f1a:	e0 e4       	ldi	r30, 0x40	; 64
     f1c:	fa e0       	ldi	r31, 0x0A	; 10
     f1e:	80 81       	ld	r24, Z
     f20:	80 7f       	andi	r24, 0xF0	; 240
     f22:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     f24:	a0 e0       	ldi	r26, 0x00	; 0
     f26:	b8 e0       	ldi	r27, 0x08	; 8
     f28:	8c 91       	ld	r24, X
     f2a:	80 7f       	andi	r24, 0xF0	; 240
     f2c:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     f2e:	a0 e0       	ldi	r26, 0x00	; 0
     f30:	b9 e0       	ldi	r27, 0x09	; 9
     f32:	8c 91       	ld	r24, X
     f34:	80 7f       	andi	r24, 0xF0	; 240
     f36:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
     f38:	80 81       	ld	r24, Z
     f3a:	80 7f       	andi	r24, 0xF0	; 240
     f3c:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
     f40:	80 e0       	ldi	r24, 0x00	; 0
     f42:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	SPIDisable();
     f46:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <SPIDisable>
	enableADCMUX(FALSE);
     f4a:	80 e0       	ldi	r24, 0x00	; 0
     f4c:	0e 94 39 07 	call	0xe72	; 0xe72 <enableADCMUX>
	ADC_Sampling_Finished = 1;
     f50:	81 e0       	ldi	r24, 0x01	; 1
     f52:	80 93 cd 50 	sts	0x50CD, r24
	DataAvailable = 1;
     f56:	80 93 d5 21 	sts	0x21D5, r24
}
     f5a:	08 95       	ret

00000f5c <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
     f5c:	cf 93       	push	r28
     f5e:	df 93       	push	r29
     f60:	0f 92       	push	r0
     f62:	0f 92       	push	r0
     f64:	cd b7       	in	r28, 0x3d	; 61
     f66:	de b7       	in	r29, 0x3e	; 62
	
	if(ADC_Sampling_Finished){
     f68:	80 91 cd 50 	lds	r24, 0x50CD
     f6c:	88 23       	and	r24, r24
     f6e:	89 f0       	breq	.+34     	; 0xf92 <ADC_Get_Num_Samples+0x36>
		volatile uint16_t count;
		count = TCC1.CNT;
     f70:	e0 e4       	ldi	r30, 0x40	; 64
     f72:	f8 e0       	ldi	r31, 0x08	; 8
     f74:	80 a1       	lds	r24, 0x40
     f76:	91 a1       	lds	r25, 0x41
     f78:	89 83       	std	Y+1, r24	; 0x01
     f7a:	9a 83       	std	Y+2, r25	; 0x02
		if(count == 0) count = TCC1.PER;
     f7c:	89 81       	ldd	r24, Y+1	; 0x01
     f7e:	9a 81       	ldd	r25, Y+2	; 0x02
     f80:	00 97       	sbiw	r24, 0x00	; 0
     f82:	21 f4       	brne	.+8      	; 0xf8c <ADC_Get_Num_Samples+0x30>
     f84:	86 a1       	lds	r24, 0x46
     f86:	97 a1       	lds	r25, 0x47
     f88:	89 83       	std	Y+1, r24	; 0x01
     f8a:	9a 83       	std	Y+2, r25	; 0x02
		return count;
     f8c:	89 81       	ldd	r24, Y+1	; 0x01
     f8e:	9a 81       	ldd	r25, Y+2	; 0x02
     f90:	02 c0       	rjmp	.+4      	; 0xf96 <ADC_Get_Num_Samples+0x3a>
	}
	else return 0;		
     f92:	80 e0       	ldi	r24, 0x00	; 0
     f94:	90 e0       	ldi	r25, 0x00	; 0
}
     f96:	0f 90       	pop	r0
     f98:	0f 90       	pop	r0
     f9a:	df 91       	pop	r29
     f9c:	cf 91       	pop	r28
     f9e:	08 95       	ret

00000fa0 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
     fa0:	e0 ea       	ldi	r30, 0xA0	; 160
     fa2:	f6 e0       	ldi	r31, 0x06	; 6
     fa4:	13 86       	std	Z+11, r1	; 0x0b
}
     fa6:	08 95       	ret

00000fa8 <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
     fa8:	81 e0       	ldi	r24, 0x01	; 1
     faa:	e0 ea       	ldi	r30, 0xA0	; 160
     fac:	f6 e0       	ldi	r31, 0x06	; 6
     fae:	83 87       	std	Z+11, r24	; 0x0b
}	
     fb0:	08 95       	ret

00000fb2 <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
     fb2:	1f 92       	push	r1
     fb4:	0f 92       	push	r0
     fb6:	0f b6       	in	r0, 0x3f	; 63
     fb8:	0f 92       	push	r0
     fba:	0b b6       	in	r0, 0x3b	; 59
     fbc:	0f 92       	push	r0
     fbe:	11 24       	eor	r1, r1
     fc0:	6f 92       	push	r6
     fc2:	7f 92       	push	r7
     fc4:	8f 92       	push	r8
     fc6:	9f 92       	push	r9
     fc8:	af 92       	push	r10
     fca:	bf 92       	push	r11
     fcc:	cf 92       	push	r12
     fce:	df 92       	push	r13
     fd0:	ef 92       	push	r14
     fd2:	ff 92       	push	r15
     fd4:	0f 93       	push	r16
     fd6:	1f 93       	push	r17
     fd8:	2f 93       	push	r18
     fda:	3f 93       	push	r19
     fdc:	4f 93       	push	r20
     fde:	5f 93       	push	r21
     fe0:	6f 93       	push	r22
     fe2:	7f 93       	push	r23
     fe4:	8f 93       	push	r24
     fe6:	9f 93       	push	r25
     fe8:	af 93       	push	r26
     fea:	bf 93       	push	r27
     fec:	ef 93       	push	r30
     fee:	ff 93       	push	r31
     ff0:	cf 93       	push	r28
     ff2:	df 93       	push	r29
     ff4:	cd b7       	in	r28, 0x3d	; 61
     ff6:	de b7       	in	r29, 0x3e	; 62
     ff8:	2c 97       	sbiw	r28, 0x0c	; 12
     ffa:	cd bf       	out	0x3d, r28	; 61
     ffc:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	volatile int64_t var;
	if (discardCount < ADC_DISCARD) {
     ffe:	80 91 5d 40 	lds	r24, 0x405D
    1002:	88 23       	and	r24, r24
    1004:	8c f0       	brlt	.+34     	; 0x1028 <__vector_104+0x76>
		discardCount++;
    1006:	80 91 5d 40 	lds	r24, 0x405D
    100a:	8f 5f       	subi	r24, 0xFF	; 255
    100c:	80 93 5d 40 	sts	0x405D, r24
		if(discardCount == ADC_DISCARD){
    1010:	80 91 5d 40 	lds	r24, 0x405D
    1014:	80 38       	cpi	r24, 0x80	; 128
    1016:	09 f0       	breq	.+2      	; 0x101a <__vector_104+0x68>
    1018:	b4 c0       	rjmp	.+360    	; 0x1182 <__vector_104+0x1d0>
			//set event system to update counter of number of samples every sample event from now on
			TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    101a:	e0 e4       	ldi	r30, 0x40	; 64
    101c:	f8 e0       	ldi	r31, 0x08	; 8
    101e:	80 81       	ld	r24, Z
    1020:	80 7f       	andi	r24, 0xF0	; 240
    1022:	89 60       	ori	r24, 0x09	; 9
    1024:	80 83       	st	Z, r24
    1026:	ad c0       	rjmp	.+346    	; 0x1182 <__vector_104+0x1d0>
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    1028:	81 e0       	ldi	r24, 0x01	; 1
    102a:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    102e:	82 e0       	ldi	r24, 0x02	; 2
    1030:	e0 ea       	ldi	r30, 0xA0	; 160
    1032:	f6 e0       	ldi	r31, 0x06	; 6
    1034:	86 83       	std	Z+6, r24	; 0x06
    1036:	80 e0       	ldi	r24, 0x00	; 0
    1038:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    103a:	e0 ec       	ldi	r30, 0xC0	; 192
    103c:	f8 e0       	ldi	r31, 0x08	; 8
    103e:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
    1040:	25 e6       	ldi	r18, 0x65	; 101
    1042:	30 e5       	ldi	r19, 0x50	; 80
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1044:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1046:	42 81       	ldd	r20, Z+2	; 0x02
    1048:	44 23       	and	r20, r20
    104a:	ec f7       	brge	.-6      	; 0x1046 <__vector_104+0x94>
			SPIBuffer[bufIndex] = SPIC.DATA;
    104c:	43 81       	ldd	r20, Z+3	; 0x03
    104e:	d9 01       	movw	r26, r18
    1050:	a8 0f       	add	r26, r24
    1052:	b9 1f       	adc	r27, r25
    1054:	4c 93       	st	X, r20
    1056:	01 96       	adiw	r24, 0x01	; 1
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1058:	83 30       	cpi	r24, 0x03	; 3
    105a:	91 05       	cpc	r25, r1
    105c:	99 f7       	brne	.-26     	; 0x1044 <__vector_104+0x92>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    105e:	82 e0       	ldi	r24, 0x02	; 2
    1060:	e0 ea       	ldi	r30, 0xA0	; 160
    1062:	f6 e0       	ldi	r31, 0x06	; 6
    1064:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
    1066:	80 e0       	ldi	r24, 0x00	; 0
    1068:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    106c:	80 91 65 50 	lds	r24, 0x5065
    1070:	88 23       	and	r24, r24
    1072:	1c f4       	brge	.+6      	; 0x107a <__vector_104+0xc8>
    1074:	8f ef       	ldi	r24, 0xFF	; 255
    1076:	8c 83       	std	Y+4, r24	; 0x04
    1078:	01 c0       	rjmp	.+2      	; 0x107c <__vector_104+0xca>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    107a:	1c 82       	std	Y+4, r1	; 0x04
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    107c:	80 91 65 50 	lds	r24, 0x5065
    1080:	8b 83       	std	Y+3, r24	; 0x03
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    1082:	80 91 66 50 	lds	r24, 0x5066
    1086:	8a 83       	std	Y+2, r24	; 0x02
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    1088:	80 91 67 50 	lds	r24, 0x5067
    108c:	89 83       	std	Y+1, r24	; 0x01
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    108e:	89 81       	ldd	r24, Y+1	; 0x01
    1090:	9a 81       	ldd	r25, Y+2	; 0x02
    1092:	ab 81       	ldd	r26, Y+3	; 0x03
    1094:	bc 81       	ldd	r27, Y+4	; 0x04
    1096:	ac 01       	movw	r20, r24
    1098:	bd 01       	movw	r22, r26
    109a:	77 0f       	add	r23, r23
    109c:	44 0b       	sbc	r20, r20
    109e:	54 2f       	mov	r21, r20
    10a0:	ba 01       	movw	r22, r20
    10a2:	8d 83       	std	Y+5, r24	; 0x05
    10a4:	9e 83       	std	Y+6, r25	; 0x06
    10a6:	af 83       	std	Y+7, r26	; 0x07
    10a8:	b8 87       	std	Y+8, r27	; 0x08
    10aa:	49 87       	std	Y+9, r20	; 0x09
    10ac:	4a 87       	std	Y+10, r20	; 0x0a
    10ae:	4b 87       	std	Y+11, r20	; 0x0b
    10b0:	4c 87       	std	Y+12, r20	; 0x0c
		ADC_BUFFER[sampleCount] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    10b2:	80 90 74 50 	lds	r8, 0x5074
    10b6:	90 90 75 50 	lds	r9, 0x5075
    10ba:	a0 90 76 50 	lds	r10, 0x5076
    10be:	b0 90 77 50 	lds	r11, 0x5077
    10c2:	2d 81       	ldd	r18, Y+5	; 0x05
    10c4:	3e 81       	ldd	r19, Y+6	; 0x06
    10c6:	4f 81       	ldd	r20, Y+7	; 0x07
    10c8:	58 85       	ldd	r21, Y+8	; 0x08
    10ca:	69 85       	ldd	r22, Y+9	; 0x09
    10cc:	7a 85       	ldd	r23, Y+10	; 0x0a
    10ce:	8b 85       	ldd	r24, Y+11	; 0x0b
    10d0:	9c 85       	ldd	r25, Y+12	; 0x0c
    10d2:	f4 01       	movw	r30, r8
    10d4:	ee 0f       	add	r30, r30
    10d6:	ff 1f       	adc	r31, r31
    10d8:	ee 0f       	add	r30, r30
    10da:	ff 1f       	adc	r31, r31
    10dc:	60 90 72 50 	lds	r6, 0x5072
    10e0:	70 90 73 50 	lds	r7, 0x5073
    10e4:	6e 0e       	add	r6, r30
    10e6:	7f 1e       	adc	r7, r31
    10e8:	0f 2e       	mov	r0, r31
    10ea:	f0 ea       	ldi	r31, 0xA0	; 160
    10ec:	af 2e       	mov	r10, r31
    10ee:	f0 2d       	mov	r31, r0
    10f0:	0f 2e       	mov	r0, r31
    10f2:	f5 e2       	ldi	r31, 0x25	; 37
    10f4:	bf 2e       	mov	r11, r31
    10f6:	f0 2d       	mov	r31, r0
    10f8:	0f 2e       	mov	r0, r31
    10fa:	f6 e2       	ldi	r31, 0x26	; 38
    10fc:	cf 2e       	mov	r12, r31
    10fe:	f0 2d       	mov	r31, r0
    1100:	dd 24       	eor	r13, r13
    1102:	ee 24       	eor	r14, r14
    1104:	ff 24       	eor	r15, r15
    1106:	00 e0       	ldi	r16, 0x00	; 0
    1108:	10 e0       	ldi	r17, 0x00	; 0
    110a:	0e 94 6a 2f 	call	0x5ed4	; 0x5ed4 <__muldi3>
    110e:	aa 24       	eor	r10, r10
    1110:	aa 94       	dec	r10
    1112:	bb 24       	eor	r11, r11
    1114:	ba 94       	dec	r11
    1116:	0f 2e       	mov	r0, r31
    1118:	ff e7       	ldi	r31, 0x7F	; 127
    111a:	cf 2e       	mov	r12, r31
    111c:	f0 2d       	mov	r31, r0
    111e:	0e 94 19 31 	call	0x6232	; 0x6232 <__divdi3>
    1122:	01 e0       	ldi	r16, 0x01	; 1
    1124:	0e 94 3d 30 	call	0x607a	; 0x607a <__ashldi3>
    1128:	0f 2e       	mov	r0, r31
    112a:	f3 e0       	ldi	r31, 0x03	; 3
    112c:	af 2e       	mov	r10, r31
    112e:	f0 2d       	mov	r31, r0
    1130:	bb 24       	eor	r11, r11
    1132:	cc 24       	eor	r12, r12
    1134:	00 e0       	ldi	r16, 0x00	; 0
    1136:	0e 94 19 31 	call	0x6232	; 0x6232 <__divdi3>
    113a:	82 2e       	mov	r8, r18
    113c:	93 2e       	mov	r9, r19
    113e:	a4 2e       	mov	r10, r20
    1140:	b5 2e       	mov	r11, r21
    1142:	b0 94       	com	r11
    1144:	a0 94       	com	r10
    1146:	90 94       	com	r9
    1148:	80 94       	com	r8
    114a:	81 1c       	adc	r8, r1
    114c:	91 1c       	adc	r9, r1
    114e:	a1 1c       	adc	r10, r1
    1150:	b1 1c       	adc	r11, r1
    1152:	f3 01       	movw	r30, r6
    1154:	80 82       	st	Z, r8
    1156:	91 82       	std	Z+1, r9	; 0x01
    1158:	a2 82       	std	Z+2, r10	; 0x02
    115a:	b3 82       	std	Z+3, r11	; 0x03
		sampleCount++;
    115c:	80 91 74 50 	lds	r24, 0x5074
    1160:	90 91 75 50 	lds	r25, 0x5075
    1164:	a0 91 76 50 	lds	r26, 0x5076
    1168:	b0 91 77 50 	lds	r27, 0x5077
    116c:	01 96       	adiw	r24, 0x01	; 1
    116e:	a1 1d       	adc	r26, r1
    1170:	b1 1d       	adc	r27, r1
    1172:	80 93 74 50 	sts	0x5074, r24
    1176:	90 93 75 50 	sts	0x5075, r25
    117a:	a0 93 76 50 	sts	0x5076, r26
    117e:	b0 93 77 50 	sts	0x5077, r27
	}
}
    1182:	2c 96       	adiw	r28, 0x0c	; 12
    1184:	cd bf       	out	0x3d, r28	; 61
    1186:	de bf       	out	0x3e, r29	; 62
    1188:	df 91       	pop	r29
    118a:	cf 91       	pop	r28
    118c:	ff 91       	pop	r31
    118e:	ef 91       	pop	r30
    1190:	bf 91       	pop	r27
    1192:	af 91       	pop	r26
    1194:	9f 91       	pop	r25
    1196:	8f 91       	pop	r24
    1198:	7f 91       	pop	r23
    119a:	6f 91       	pop	r22
    119c:	5f 91       	pop	r21
    119e:	4f 91       	pop	r20
    11a0:	3f 91       	pop	r19
    11a2:	2f 91       	pop	r18
    11a4:	1f 91       	pop	r17
    11a6:	0f 91       	pop	r16
    11a8:	ff 90       	pop	r15
    11aa:	ef 90       	pop	r14
    11ac:	df 90       	pop	r13
    11ae:	cf 90       	pop	r12
    11b0:	bf 90       	pop	r11
    11b2:	af 90       	pop	r10
    11b4:	9f 90       	pop	r9
    11b6:	8f 90       	pop	r8
    11b8:	7f 90       	pop	r7
    11ba:	6f 90       	pop	r6
    11bc:	0f 90       	pop	r0
    11be:	0b be       	out	0x3b, r0	; 59
    11c0:	0f 90       	pop	r0
    11c2:	0f be       	out	0x3f, r0	; 63
    11c4:	0f 90       	pop	r0
    11c6:	1f 90       	pop	r1
    11c8:	18 95       	reti

000011ca <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
    11ca:	88 23       	and	r24, r24
    11cc:	49 f0       	breq	.+18     	; 0x11e0 <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    11ce:	80 e2       	ldi	r24, 0x20	; 32
    11d0:	60 e0       	ldi	r22, 0x00	; 0
    11d2:	0e 94 e9 1e 	call	0x3dd2	; 0x3dd2 <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    11d6:	80 e2       	ldi	r24, 0x20	; 32
    11d8:	60 e0       	ldi	r22, 0x00	; 0
    11da:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <PortEx_OUTSET>
    11de:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    11e0:	80 e2       	ldi	r24, 0x20	; 32
    11e2:	60 e0       	ldi	r22, 0x00	; 0
    11e4:	0e 94 91 1e 	call	0x3d22	; 0x3d22 <PortEx_DIRCLR>
    11e8:	08 95       	ret

000011ea <__vector_14>:
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    11ea:	1f 92       	push	r1
    11ec:	0f 92       	push	r0
    11ee:	0f b6       	in	r0, 0x3f	; 63
    11f0:	0f 92       	push	r0
    11f2:	0b b6       	in	r0, 0x3b	; 59
    11f4:	0f 92       	push	r0
    11f6:	11 24       	eor	r1, r1
    11f8:	6f 92       	push	r6
    11fa:	7f 92       	push	r7
    11fc:	8f 92       	push	r8
    11fe:	9f 92       	push	r9
    1200:	af 92       	push	r10
    1202:	bf 92       	push	r11
    1204:	cf 92       	push	r12
    1206:	df 92       	push	r13
    1208:	ef 92       	push	r14
    120a:	ff 92       	push	r15
    120c:	0f 93       	push	r16
    120e:	1f 93       	push	r17
    1210:	2f 93       	push	r18
    1212:	3f 93       	push	r19
    1214:	4f 93       	push	r20
    1216:	5f 93       	push	r21
    1218:	6f 93       	push	r22
    121a:	7f 93       	push	r23
    121c:	8f 93       	push	r24
    121e:	9f 93       	push	r25
    1220:	af 93       	push	r26
    1222:	bf 93       	push	r27
    1224:	ef 93       	push	r30
    1226:	ff 93       	push	r31
    1228:	cf 93       	push	r28
    122a:	df 93       	push	r29
    122c:	cd b7       	in	r28, 0x3d	; 61
    122e:	de b7       	in	r29, 0x3e	; 62
    1230:	2c 97       	sbiw	r28, 0x0c	; 12
    1232:	cd bf       	out	0x3d, r28	; 61
    1234:	de bf       	out	0x3e, r29	; 62
	volatile int64_t sum = 0;
    1236:	19 82       	std	Y+1, r1	; 0x01
    1238:	1a 82       	std	Y+2, r1	; 0x02
    123a:	1b 82       	std	Y+3, r1	; 0x03
    123c:	1c 82       	std	Y+4, r1	; 0x04
    123e:	1d 82       	std	Y+5, r1	; 0x05
    1240:	1e 82       	std	Y+6, r1	; 0x06
    1242:	1f 82       	std	Y+7, r1	; 0x07
    1244:	18 86       	std	Y+8, r1	; 0x08
    1246:	80 e0       	ldi	r24, 0x00	; 0
    1248:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    124a:	25 e6       	ldi	r18, 0x65	; 101
    124c:	30 e5       	ldi	r19, 0x50	; 80
    124e:	aa 24       	eor	r10, r10
    1250:	aa 94       	dec	r10
    1252:	ac 01       	movw	r20, r24
    1254:	f9 01       	movw	r30, r18
    1256:	e8 0f       	add	r30, r24
    1258:	f9 1f       	adc	r31, r25
    125a:	60 81       	ld	r22, Z
    125c:	66 23       	and	r22, r22
    125e:	14 f4       	brge	.+4      	; 0x1264 <__vector_14+0x7a>
    1260:	ac 86       	std	Y+12, r10	; 0x0c
    1262:	01 c0       	rjmp	.+2      	; 0x1266 <__vector_14+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1264:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1266:	42 0f       	add	r20, r18
    1268:	53 1f       	adc	r21, r19
    126a:	fa 01       	movw	r30, r20
    126c:	40 81       	ld	r20, Z
    126e:	4b 87       	std	Y+11, r20	; 0x0b
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1270:	fc 01       	movw	r30, r24
    1272:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1274:	e2 0f       	add	r30, r18
    1276:	f3 1f       	adc	r31, r19
    1278:	40 81       	ld	r20, Z
    127a:	4a 87       	std	Y+10, r20	; 0x0a
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    127c:	fc 01       	movw	r30, r24
    127e:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1280:	e2 0f       	add	r30, r18
    1282:	f3 1f       	adc	r31, r19
    1284:	40 81       	ld	r20, Z
    1286:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    1288:	49 85       	ldd	r20, Y+9	; 0x09
    128a:	5a 85       	ldd	r21, Y+10	; 0x0a
    128c:	6b 85       	ldd	r22, Y+11	; 0x0b
    128e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1290:	b9 80       	ldd	r11, Y+1	; 0x01
    1292:	ca 80       	ldd	r12, Y+2	; 0x02
    1294:	db 80       	ldd	r13, Y+3	; 0x03
    1296:	ec 80       	ldd	r14, Y+4	; 0x04
    1298:	fd 80       	ldd	r15, Y+5	; 0x05
    129a:	0e 81       	ldd	r16, Y+6	; 0x06
    129c:	1f 81       	ldd	r17, Y+7	; 0x07
    129e:	88 84       	ldd	r8, Y+8	; 0x08
    12a0:	b4 2f       	mov	r27, r20
    12a2:	a5 2f       	mov	r26, r21
    12a4:	f6 2f       	mov	r31, r22
    12a6:	e7 2f       	mov	r30, r23
    12a8:	77 0f       	add	r23, r23
    12aa:	44 0b       	sbc	r20, r20
    12ac:	54 2f       	mov	r21, r20
    12ae:	ba 01       	movw	r22, r20
    12b0:	64 2e       	mov	r6, r20
    12b2:	74 2e       	mov	r7, r20
    12b4:	94 2e       	mov	r9, r20
    12b6:	bb 0e       	add	r11, r27
    12b8:	61 e0       	ldi	r22, 0x01	; 1
    12ba:	bb 16       	cp	r11, r27
    12bc:	08 f0       	brcs	.+2      	; 0x12c0 <__vector_14+0xd6>
    12be:	60 e0       	ldi	r22, 0x00	; 0
    12c0:	ca 0e       	add	r12, r26
    12c2:	51 e0       	ldi	r21, 0x01	; 1
    12c4:	ca 16       	cp	r12, r26
    12c6:	08 f0       	brcs	.+2      	; 0x12ca <__vector_14+0xe0>
    12c8:	50 e0       	ldi	r21, 0x00	; 0
    12ca:	a6 2f       	mov	r26, r22
    12cc:	ac 0d       	add	r26, r12
    12ce:	61 e0       	ldi	r22, 0x01	; 1
    12d0:	ac 15       	cp	r26, r12
    12d2:	08 f0       	brcs	.+2      	; 0x12d6 <__vector_14+0xec>
    12d4:	60 e0       	ldi	r22, 0x00	; 0
    12d6:	56 2b       	or	r21, r22
    12d8:	df 0e       	add	r13, r31
    12da:	61 e0       	ldi	r22, 0x01	; 1
    12dc:	df 16       	cp	r13, r31
    12de:	08 f0       	brcs	.+2      	; 0x12e2 <__vector_14+0xf8>
    12e0:	60 e0       	ldi	r22, 0x00	; 0
    12e2:	f5 2f       	mov	r31, r21
    12e4:	fd 0d       	add	r31, r13
    12e6:	51 e0       	ldi	r21, 0x01	; 1
    12e8:	fd 15       	cp	r31, r13
    12ea:	08 f0       	brcs	.+2      	; 0x12ee <__vector_14+0x104>
    12ec:	50 e0       	ldi	r21, 0x00	; 0
    12ee:	65 2b       	or	r22, r21
    12f0:	ee 0e       	add	r14, r30
    12f2:	51 e0       	ldi	r21, 0x01	; 1
    12f4:	ee 16       	cp	r14, r30
    12f6:	08 f0       	brcs	.+2      	; 0x12fa <__vector_14+0x110>
    12f8:	50 e0       	ldi	r21, 0x00	; 0
    12fa:	e6 2f       	mov	r30, r22
    12fc:	ee 0d       	add	r30, r14
    12fe:	61 e0       	ldi	r22, 0x01	; 1
    1300:	ee 15       	cp	r30, r14
    1302:	08 f0       	brcs	.+2      	; 0x1306 <__vector_14+0x11c>
    1304:	60 e0       	ldi	r22, 0x00	; 0
    1306:	56 2b       	or	r21, r22
    1308:	f6 0c       	add	r15, r6
    130a:	71 e0       	ldi	r23, 0x01	; 1
    130c:	f6 14       	cp	r15, r6
    130e:	08 f0       	brcs	.+2      	; 0x1312 <__vector_14+0x128>
    1310:	70 e0       	ldi	r23, 0x00	; 0
    1312:	b5 2f       	mov	r27, r21
    1314:	bf 0d       	add	r27, r15
    1316:	51 e0       	ldi	r21, 0x01	; 1
    1318:	bf 15       	cp	r27, r15
    131a:	08 f0       	brcs	.+2      	; 0x131e <__vector_14+0x134>
    131c:	50 e0       	ldi	r21, 0x00	; 0
    131e:	75 2b       	or	r23, r21
    1320:	07 0d       	add	r16, r7
    1322:	61 e0       	ldi	r22, 0x01	; 1
    1324:	07 15       	cp	r16, r7
    1326:	08 f0       	brcs	.+2      	; 0x132a <__vector_14+0x140>
    1328:	60 e0       	ldi	r22, 0x00	; 0
    132a:	70 0f       	add	r23, r16
    132c:	51 e0       	ldi	r21, 0x01	; 1
    132e:	70 17       	cp	r23, r16
    1330:	08 f0       	brcs	.+2      	; 0x1334 <__vector_14+0x14a>
    1332:	50 e0       	ldi	r21, 0x00	; 0
    1334:	65 2b       	or	r22, r21
    1336:	19 0d       	add	r17, r9
    1338:	51 e0       	ldi	r21, 0x01	; 1
    133a:	19 15       	cp	r17, r9
    133c:	08 f0       	brcs	.+2      	; 0x1340 <__vector_14+0x156>
    133e:	50 e0       	ldi	r21, 0x00	; 0
    1340:	61 0f       	add	r22, r17
    1342:	01 e0       	ldi	r16, 0x01	; 1
    1344:	61 17       	cp	r22, r17
    1346:	08 f0       	brcs	.+2      	; 0x134a <__vector_14+0x160>
    1348:	00 e0       	ldi	r16, 0x00	; 0
    134a:	50 2b       	or	r21, r16
    134c:	48 0d       	add	r20, r8
    134e:	54 0f       	add	r21, r20
    1350:	b9 82       	std	Y+1, r11	; 0x01
    1352:	aa 83       	std	Y+2, r26	; 0x02
    1354:	fb 83       	std	Y+3, r31	; 0x03
    1356:	ec 83       	std	Y+4, r30	; 0x04
    1358:	bd 83       	std	Y+5, r27	; 0x05
    135a:	7e 83       	std	Y+6, r23	; 0x06
    135c:	6f 83       	std	Y+7, r22	; 0x07
    135e:	58 87       	std	Y+8, r21	; 0x08
    1360:	03 96       	adiw	r24, 0x03	; 3
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1362:	8c 30       	cpi	r24, 0x0C	; 12
    1364:	91 05       	cpc	r25, r1
    1366:	09 f0       	breq	.+2      	; 0x136a <__vector_14+0x180>
    1368:	74 cf       	rjmp	.-280    	; 0x1252 <__vector_14+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    136a:	e9 80       	ldd	r14, Y+1	; 0x01
    136c:	fa 80       	ldd	r15, Y+2	; 0x02
    136e:	0b 81       	ldd	r16, Y+3	; 0x03
    1370:	1c 81       	ldd	r17, Y+4	; 0x04
    1372:	bd 81       	ldd	r27, Y+5	; 0x05
    1374:	ae 81       	ldd	r26, Y+6	; 0x06
    1376:	ff 81       	ldd	r31, Y+7	; 0x07
    1378:	e8 85       	ldd	r30, Y+8	; 0x08
    137a:	2e 2d       	mov	r18, r14
    137c:	3f 2d       	mov	r19, r15
    137e:	40 2f       	mov	r20, r16
    1380:	51 2f       	mov	r21, r17
    1382:	6b 2f       	mov	r22, r27
    1384:	7a 2f       	mov	r23, r26
    1386:	8f 2f       	mov	r24, r31
    1388:	9e 2f       	mov	r25, r30
    138a:	ee 23       	and	r30, r30
    138c:	0c f0       	brlt	.+2      	; 0x1390 <__vector_14+0x1a6>
    138e:	4a c0       	rjmp	.+148    	; 0x1424 <__vector_14+0x23a>
    1390:	93 e0       	ldi	r25, 0x03	; 3
    1392:	e9 0e       	add	r14, r25
    1394:	91 e0       	ldi	r25, 0x01	; 1
    1396:	e2 16       	cp	r14, r18
    1398:	08 f0       	brcs	.+2      	; 0x139c <__vector_14+0x1b2>
    139a:	90 e0       	ldi	r25, 0x00	; 0
    139c:	21 e0       	ldi	r18, 0x01	; 1
    139e:	f3 16       	cp	r15, r19
    13a0:	08 f0       	brcs	.+2      	; 0x13a4 <__vector_14+0x1ba>
    13a2:	20 e0       	ldi	r18, 0x00	; 0
    13a4:	39 2f       	mov	r19, r25
    13a6:	3f 0d       	add	r19, r15
    13a8:	91 e0       	ldi	r25, 0x01	; 1
    13aa:	3f 15       	cp	r19, r15
    13ac:	08 f0       	brcs	.+2      	; 0x13b0 <__vector_14+0x1c6>
    13ae:	90 e0       	ldi	r25, 0x00	; 0
    13b0:	29 2b       	or	r18, r25
    13b2:	91 e0       	ldi	r25, 0x01	; 1
    13b4:	04 17       	cp	r16, r20
    13b6:	08 f0       	brcs	.+2      	; 0x13ba <__vector_14+0x1d0>
    13b8:	90 e0       	ldi	r25, 0x00	; 0
    13ba:	42 2f       	mov	r20, r18
    13bc:	40 0f       	add	r20, r16
    13be:	21 e0       	ldi	r18, 0x01	; 1
    13c0:	40 17       	cp	r20, r16
    13c2:	08 f0       	brcs	.+2      	; 0x13c6 <__vector_14+0x1dc>
    13c4:	20 e0       	ldi	r18, 0x00	; 0
    13c6:	92 2b       	or	r25, r18
    13c8:	21 e0       	ldi	r18, 0x01	; 1
    13ca:	15 17       	cp	r17, r21
    13cc:	08 f0       	brcs	.+2      	; 0x13d0 <__vector_14+0x1e6>
    13ce:	20 e0       	ldi	r18, 0x00	; 0
    13d0:	59 2f       	mov	r21, r25
    13d2:	51 0f       	add	r21, r17
    13d4:	91 e0       	ldi	r25, 0x01	; 1
    13d6:	51 17       	cp	r21, r17
    13d8:	08 f0       	brcs	.+2      	; 0x13dc <__vector_14+0x1f2>
    13da:	90 e0       	ldi	r25, 0x00	; 0
    13dc:	29 2b       	or	r18, r25
    13de:	91 e0       	ldi	r25, 0x01	; 1
    13e0:	b6 17       	cp	r27, r22
    13e2:	08 f0       	brcs	.+2      	; 0x13e6 <__vector_14+0x1fc>
    13e4:	90 e0       	ldi	r25, 0x00	; 0
    13e6:	62 2f       	mov	r22, r18
    13e8:	6b 0f       	add	r22, r27
    13ea:	21 e0       	ldi	r18, 0x01	; 1
    13ec:	6b 17       	cp	r22, r27
    13ee:	08 f0       	brcs	.+2      	; 0x13f2 <__vector_14+0x208>
    13f0:	20 e0       	ldi	r18, 0x00	; 0
    13f2:	92 2b       	or	r25, r18
    13f4:	21 e0       	ldi	r18, 0x01	; 1
    13f6:	a7 17       	cp	r26, r23
    13f8:	08 f0       	brcs	.+2      	; 0x13fc <__vector_14+0x212>
    13fa:	20 e0       	ldi	r18, 0x00	; 0
    13fc:	79 2f       	mov	r23, r25
    13fe:	7a 0f       	add	r23, r26
    1400:	91 e0       	ldi	r25, 0x01	; 1
    1402:	7a 17       	cp	r23, r26
    1404:	08 f0       	brcs	.+2      	; 0x1408 <__vector_14+0x21e>
    1406:	90 e0       	ldi	r25, 0x00	; 0
    1408:	29 2b       	or	r18, r25
    140a:	91 e0       	ldi	r25, 0x01	; 1
    140c:	f8 17       	cp	r31, r24
    140e:	08 f0       	brcs	.+2      	; 0x1412 <__vector_14+0x228>
    1410:	90 e0       	ldi	r25, 0x00	; 0
    1412:	82 2f       	mov	r24, r18
    1414:	8f 0f       	add	r24, r31
    1416:	21 e0       	ldi	r18, 0x01	; 1
    1418:	8f 17       	cp	r24, r31
    141a:	08 f0       	brcs	.+2      	; 0x141e <__vector_14+0x234>
    141c:	20 e0       	ldi	r18, 0x00	; 0
    141e:	92 2b       	or	r25, r18
    1420:	2e 2d       	mov	r18, r14
    1422:	9e 0f       	add	r25, r30
    1424:	02 e0       	ldi	r16, 0x02	; 2
    1426:	0e 94 b1 30 	call	0x6162	; 0x6162 <__ashrdi3>
    142a:	29 83       	std	Y+1, r18	; 0x01
    142c:	3a 83       	std	Y+2, r19	; 0x02
    142e:	4b 83       	std	Y+3, r20	; 0x03
    1430:	5c 83       	std	Y+4, r21	; 0x04
    1432:	6d 83       	std	Y+5, r22	; 0x05
    1434:	7e 83       	std	Y+6, r23	; 0x06
    1436:	8f 83       	std	Y+7, r24	; 0x07
    1438:	98 87       	std	Y+8, r25	; 0x08
	ADC_BUFFER[sampleCount] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    143a:	80 90 74 50 	lds	r8, 0x5074
    143e:	90 90 75 50 	lds	r9, 0x5075
    1442:	a0 90 76 50 	lds	r10, 0x5076
    1446:	b0 90 77 50 	lds	r11, 0x5077
    144a:	29 81       	ldd	r18, Y+1	; 0x01
    144c:	3a 81       	ldd	r19, Y+2	; 0x02
    144e:	4b 81       	ldd	r20, Y+3	; 0x03
    1450:	5c 81       	ldd	r21, Y+4	; 0x04
    1452:	6d 81       	ldd	r22, Y+5	; 0x05
    1454:	7e 81       	ldd	r23, Y+6	; 0x06
    1456:	8f 81       	ldd	r24, Y+7	; 0x07
    1458:	98 85       	ldd	r25, Y+8	; 0x08
    145a:	f4 01       	movw	r30, r8
    145c:	ee 0f       	add	r30, r30
    145e:	ff 1f       	adc	r31, r31
    1460:	ee 0f       	add	r30, r30
    1462:	ff 1f       	adc	r31, r31
    1464:	80 90 72 50 	lds	r8, 0x5072
    1468:	90 90 73 50 	lds	r9, 0x5073
    146c:	8e 0e       	add	r8, r30
    146e:	9f 1e       	adc	r9, r31
    1470:	0f 2e       	mov	r0, r31
    1472:	f0 ea       	ldi	r31, 0xA0	; 160
    1474:	af 2e       	mov	r10, r31
    1476:	f0 2d       	mov	r31, r0
    1478:	0f 2e       	mov	r0, r31
    147a:	f5 e2       	ldi	r31, 0x25	; 37
    147c:	bf 2e       	mov	r11, r31
    147e:	f0 2d       	mov	r31, r0
    1480:	0f 2e       	mov	r0, r31
    1482:	f6 e2       	ldi	r31, 0x26	; 38
    1484:	cf 2e       	mov	r12, r31
    1486:	f0 2d       	mov	r31, r0
    1488:	dd 24       	eor	r13, r13
    148a:	ee 24       	eor	r14, r14
    148c:	ff 24       	eor	r15, r15
    148e:	00 e0       	ldi	r16, 0x00	; 0
    1490:	10 e0       	ldi	r17, 0x00	; 0
    1492:	0e 94 6a 2f 	call	0x5ed4	; 0x5ed4 <__muldi3>
    1496:	aa 24       	eor	r10, r10
    1498:	aa 94       	dec	r10
    149a:	bb 24       	eor	r11, r11
    149c:	ba 94       	dec	r11
    149e:	0f 2e       	mov	r0, r31
    14a0:	ff e7       	ldi	r31, 0x7F	; 127
    14a2:	cf 2e       	mov	r12, r31
    14a4:	f0 2d       	mov	r31, r0
    14a6:	0e 94 19 31 	call	0x6232	; 0x6232 <__divdi3>
    14aa:	01 e0       	ldi	r16, 0x01	; 1
    14ac:	0e 94 3d 30 	call	0x607a	; 0x607a <__ashldi3>
    14b0:	0f 2e       	mov	r0, r31
    14b2:	f3 e0       	ldi	r31, 0x03	; 3
    14b4:	af 2e       	mov	r10, r31
    14b6:	f0 2d       	mov	r31, r0
    14b8:	bb 24       	eor	r11, r11
    14ba:	cc 24       	eor	r12, r12
    14bc:	00 e0       	ldi	r16, 0x00	; 0
    14be:	0e 94 19 31 	call	0x6232	; 0x6232 <__divdi3>
    14c2:	f4 01       	movw	r30, r8
    14c4:	20 83       	st	Z, r18
    14c6:	31 83       	std	Z+1, r19	; 0x01
    14c8:	42 83       	std	Z+2, r20	; 0x02
    14ca:	53 83       	std	Z+3, r21	; 0x03
	sampleCount++;
    14cc:	80 91 74 50 	lds	r24, 0x5074
    14d0:	90 91 75 50 	lds	r25, 0x5075
    14d4:	a0 91 76 50 	lds	r26, 0x5076
    14d8:	b0 91 77 50 	lds	r27, 0x5077
    14dc:	01 96       	adiw	r24, 0x01	; 1
    14de:	a1 1d       	adc	r26, r1
    14e0:	b1 1d       	adc	r27, r1
    14e2:	80 93 74 50 	sts	0x5074, r24
    14e6:	90 93 75 50 	sts	0x5075, r25
    14ea:	a0 93 76 50 	sts	0x5076, r26
    14ee:	b0 93 77 50 	sts	0x5077, r27

}
    14f2:	2c 96       	adiw	r28, 0x0c	; 12
    14f4:	cd bf       	out	0x3d, r28	; 61
    14f6:	de bf       	out	0x3e, r29	; 62
    14f8:	df 91       	pop	r29
    14fa:	cf 91       	pop	r28
    14fc:	ff 91       	pop	r31
    14fe:	ef 91       	pop	r30
    1500:	bf 91       	pop	r27
    1502:	af 91       	pop	r26
    1504:	9f 91       	pop	r25
    1506:	8f 91       	pop	r24
    1508:	7f 91       	pop	r23
    150a:	6f 91       	pop	r22
    150c:	5f 91       	pop	r21
    150e:	4f 91       	pop	r20
    1510:	3f 91       	pop	r19
    1512:	2f 91       	pop	r18
    1514:	1f 91       	pop	r17
    1516:	0f 91       	pop	r16
    1518:	ff 90       	pop	r15
    151a:	ef 90       	pop	r14
    151c:	df 90       	pop	r13
    151e:	cf 90       	pop	r12
    1520:	bf 90       	pop	r11
    1522:	af 90       	pop	r10
    1524:	9f 90       	pop	r9
    1526:	8f 90       	pop	r8
    1528:	7f 90       	pop	r7
    152a:	6f 90       	pop	r6
    152c:	0f 90       	pop	r0
    152e:	0b be       	out	0x3b, r0	; 59
    1530:	0f 90       	pop	r0
    1532:	0f be       	out	0x3f, r0	; 63
    1534:	0f 90       	pop	r0
    1536:	1f 90       	pop	r1
    1538:	18 95       	reti

0000153a <__vector_77>:
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    153a:	1f 92       	push	r1
    153c:	0f 92       	push	r0
    153e:	0f b6       	in	r0, 0x3f	; 63
    1540:	0f 92       	push	r0
    1542:	0b b6       	in	r0, 0x3b	; 59
    1544:	0f 92       	push	r0
    1546:	11 24       	eor	r1, r1
    1548:	6f 92       	push	r6
    154a:	7f 92       	push	r7
    154c:	8f 92       	push	r8
    154e:	9f 92       	push	r9
    1550:	af 92       	push	r10
    1552:	bf 92       	push	r11
    1554:	cf 92       	push	r12
    1556:	df 92       	push	r13
    1558:	ef 92       	push	r14
    155a:	ff 92       	push	r15
    155c:	0f 93       	push	r16
    155e:	1f 93       	push	r17
    1560:	2f 93       	push	r18
    1562:	3f 93       	push	r19
    1564:	4f 93       	push	r20
    1566:	5f 93       	push	r21
    1568:	6f 93       	push	r22
    156a:	7f 93       	push	r23
    156c:	8f 93       	push	r24
    156e:	9f 93       	push	r25
    1570:	af 93       	push	r26
    1572:	bf 93       	push	r27
    1574:	ef 93       	push	r30
    1576:	ff 93       	push	r31
    1578:	cf 93       	push	r28
    157a:	df 93       	push	r29
    157c:	cd b7       	in	r28, 0x3d	; 61
    157e:	de b7       	in	r29, 0x3e	; 62
    1580:	2c 97       	sbiw	r28, 0x0c	; 12
    1582:	cd bf       	out	0x3d, r28	; 61
    1584:	de bf       	out	0x3e, r29	; 62

	volatile int64_t sum = 0;
    1586:	19 82       	std	Y+1, r1	; 0x01
    1588:	1a 82       	std	Y+2, r1	; 0x02
    158a:	1b 82       	std	Y+3, r1	; 0x03
    158c:	1c 82       	std	Y+4, r1	; 0x04
    158e:	1d 82       	std	Y+5, r1	; 0x05
    1590:	1e 82       	std	Y+6, r1	; 0x06
    1592:	1f 82       	std	Y+7, r1	; 0x07
    1594:	18 86       	std	Y+8, r1	; 0x08
    1596:	80 e0       	ldi	r24, 0x00	; 0
    1598:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    159a:	25 e6       	ldi	r18, 0x65	; 101
    159c:	30 e5       	ldi	r19, 0x50	; 80
    159e:	aa 24       	eor	r10, r10
    15a0:	aa 94       	dec	r10
    15a2:	ac 01       	movw	r20, r24
    15a4:	f9 01       	movw	r30, r18
    15a6:	e8 0f       	add	r30, r24
    15a8:	f9 1f       	adc	r31, r25
    15aa:	60 81       	ld	r22, Z
    15ac:	66 23       	and	r22, r22
    15ae:	14 f4       	brge	.+4      	; 0x15b4 <__vector_77+0x7a>
    15b0:	ac 86       	std	Y+12, r10	; 0x0c
    15b2:	01 c0       	rjmp	.+2      	; 0x15b6 <__vector_77+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    15b4:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    15b6:	42 0f       	add	r20, r18
    15b8:	53 1f       	adc	r21, r19
    15ba:	fa 01       	movw	r30, r20
    15bc:	40 81       	ld	r20, Z
    15be:	4b 87       	std	Y+11, r20	; 0x0b
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    15c0:	fc 01       	movw	r30, r24
    15c2:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    15c4:	e2 0f       	add	r30, r18
    15c6:	f3 1f       	adc	r31, r19
    15c8:	40 81       	ld	r20, Z
    15ca:	4a 87       	std	Y+10, r20	; 0x0a
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    15cc:	fc 01       	movw	r30, r24
    15ce:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    15d0:	e2 0f       	add	r30, r18
    15d2:	f3 1f       	adc	r31, r19
    15d4:	40 81       	ld	r20, Z
    15d6:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    15d8:	49 85       	ldd	r20, Y+9	; 0x09
    15da:	5a 85       	ldd	r21, Y+10	; 0x0a
    15dc:	6b 85       	ldd	r22, Y+11	; 0x0b
    15de:	7c 85       	ldd	r23, Y+12	; 0x0c
    15e0:	b9 80       	ldd	r11, Y+1	; 0x01
    15e2:	ca 80       	ldd	r12, Y+2	; 0x02
    15e4:	db 80       	ldd	r13, Y+3	; 0x03
    15e6:	ec 80       	ldd	r14, Y+4	; 0x04
    15e8:	fd 80       	ldd	r15, Y+5	; 0x05
    15ea:	0e 81       	ldd	r16, Y+6	; 0x06
    15ec:	1f 81       	ldd	r17, Y+7	; 0x07
    15ee:	88 84       	ldd	r8, Y+8	; 0x08
    15f0:	b4 2f       	mov	r27, r20
    15f2:	a5 2f       	mov	r26, r21
    15f4:	f6 2f       	mov	r31, r22
    15f6:	e7 2f       	mov	r30, r23
    15f8:	77 0f       	add	r23, r23
    15fa:	44 0b       	sbc	r20, r20
    15fc:	54 2f       	mov	r21, r20
    15fe:	ba 01       	movw	r22, r20
    1600:	64 2e       	mov	r6, r20
    1602:	74 2e       	mov	r7, r20
    1604:	94 2e       	mov	r9, r20
    1606:	bb 0e       	add	r11, r27
    1608:	61 e0       	ldi	r22, 0x01	; 1
    160a:	bb 16       	cp	r11, r27
    160c:	08 f0       	brcs	.+2      	; 0x1610 <__vector_77+0xd6>
    160e:	60 e0       	ldi	r22, 0x00	; 0
    1610:	ca 0e       	add	r12, r26
    1612:	51 e0       	ldi	r21, 0x01	; 1
    1614:	ca 16       	cp	r12, r26
    1616:	08 f0       	brcs	.+2      	; 0x161a <__vector_77+0xe0>
    1618:	50 e0       	ldi	r21, 0x00	; 0
    161a:	a6 2f       	mov	r26, r22
    161c:	ac 0d       	add	r26, r12
    161e:	61 e0       	ldi	r22, 0x01	; 1
    1620:	ac 15       	cp	r26, r12
    1622:	08 f0       	brcs	.+2      	; 0x1626 <__vector_77+0xec>
    1624:	60 e0       	ldi	r22, 0x00	; 0
    1626:	56 2b       	or	r21, r22
    1628:	df 0e       	add	r13, r31
    162a:	61 e0       	ldi	r22, 0x01	; 1
    162c:	df 16       	cp	r13, r31
    162e:	08 f0       	brcs	.+2      	; 0x1632 <__vector_77+0xf8>
    1630:	60 e0       	ldi	r22, 0x00	; 0
    1632:	f5 2f       	mov	r31, r21
    1634:	fd 0d       	add	r31, r13
    1636:	51 e0       	ldi	r21, 0x01	; 1
    1638:	fd 15       	cp	r31, r13
    163a:	08 f0       	brcs	.+2      	; 0x163e <__vector_77+0x104>
    163c:	50 e0       	ldi	r21, 0x00	; 0
    163e:	65 2b       	or	r22, r21
    1640:	ee 0e       	add	r14, r30
    1642:	51 e0       	ldi	r21, 0x01	; 1
    1644:	ee 16       	cp	r14, r30
    1646:	08 f0       	brcs	.+2      	; 0x164a <__vector_77+0x110>
    1648:	50 e0       	ldi	r21, 0x00	; 0
    164a:	e6 2f       	mov	r30, r22
    164c:	ee 0d       	add	r30, r14
    164e:	61 e0       	ldi	r22, 0x01	; 1
    1650:	ee 15       	cp	r30, r14
    1652:	08 f0       	brcs	.+2      	; 0x1656 <__vector_77+0x11c>
    1654:	60 e0       	ldi	r22, 0x00	; 0
    1656:	56 2b       	or	r21, r22
    1658:	f6 0c       	add	r15, r6
    165a:	71 e0       	ldi	r23, 0x01	; 1
    165c:	f6 14       	cp	r15, r6
    165e:	08 f0       	brcs	.+2      	; 0x1662 <__vector_77+0x128>
    1660:	70 e0       	ldi	r23, 0x00	; 0
    1662:	b5 2f       	mov	r27, r21
    1664:	bf 0d       	add	r27, r15
    1666:	51 e0       	ldi	r21, 0x01	; 1
    1668:	bf 15       	cp	r27, r15
    166a:	08 f0       	brcs	.+2      	; 0x166e <__vector_77+0x134>
    166c:	50 e0       	ldi	r21, 0x00	; 0
    166e:	75 2b       	or	r23, r21
    1670:	07 0d       	add	r16, r7
    1672:	61 e0       	ldi	r22, 0x01	; 1
    1674:	07 15       	cp	r16, r7
    1676:	08 f0       	brcs	.+2      	; 0x167a <__vector_77+0x140>
    1678:	60 e0       	ldi	r22, 0x00	; 0
    167a:	70 0f       	add	r23, r16
    167c:	51 e0       	ldi	r21, 0x01	; 1
    167e:	70 17       	cp	r23, r16
    1680:	08 f0       	brcs	.+2      	; 0x1684 <__vector_77+0x14a>
    1682:	50 e0       	ldi	r21, 0x00	; 0
    1684:	65 2b       	or	r22, r21
    1686:	19 0d       	add	r17, r9
    1688:	51 e0       	ldi	r21, 0x01	; 1
    168a:	19 15       	cp	r17, r9
    168c:	08 f0       	brcs	.+2      	; 0x1690 <__vector_77+0x156>
    168e:	50 e0       	ldi	r21, 0x00	; 0
    1690:	61 0f       	add	r22, r17
    1692:	01 e0       	ldi	r16, 0x01	; 1
    1694:	61 17       	cp	r22, r17
    1696:	08 f0       	brcs	.+2      	; 0x169a <__vector_77+0x160>
    1698:	00 e0       	ldi	r16, 0x00	; 0
    169a:	50 2b       	or	r21, r16
    169c:	48 0d       	add	r20, r8
    169e:	54 0f       	add	r21, r20
    16a0:	b9 82       	std	Y+1, r11	; 0x01
    16a2:	aa 83       	std	Y+2, r26	; 0x02
    16a4:	fb 83       	std	Y+3, r31	; 0x03
    16a6:	ec 83       	std	Y+4, r30	; 0x04
    16a8:	bd 83       	std	Y+5, r27	; 0x05
    16aa:	7e 83       	std	Y+6, r23	; 0x06
    16ac:	6f 83       	std	Y+7, r22	; 0x07
    16ae:	58 87       	std	Y+8, r21	; 0x08
    16b0:	03 96       	adiw	r24, 0x03	; 3
ISR(TCD0_OVF_vect) {

	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    16b2:	8c 30       	cpi	r24, 0x0C	; 12
    16b4:	91 05       	cpc	r25, r1
    16b6:	09 f0       	breq	.+2      	; 0x16ba <__vector_77+0x180>
    16b8:	74 cf       	rjmp	.-280    	; 0x15a2 <__vector_77+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    16ba:	e9 80       	ldd	r14, Y+1	; 0x01
    16bc:	fa 80       	ldd	r15, Y+2	; 0x02
    16be:	0b 81       	ldd	r16, Y+3	; 0x03
    16c0:	1c 81       	ldd	r17, Y+4	; 0x04
    16c2:	bd 81       	ldd	r27, Y+5	; 0x05
    16c4:	ae 81       	ldd	r26, Y+6	; 0x06
    16c6:	ff 81       	ldd	r31, Y+7	; 0x07
    16c8:	e8 85       	ldd	r30, Y+8	; 0x08
    16ca:	2e 2d       	mov	r18, r14
    16cc:	3f 2d       	mov	r19, r15
    16ce:	40 2f       	mov	r20, r16
    16d0:	51 2f       	mov	r21, r17
    16d2:	6b 2f       	mov	r22, r27
    16d4:	7a 2f       	mov	r23, r26
    16d6:	8f 2f       	mov	r24, r31
    16d8:	9e 2f       	mov	r25, r30
    16da:	ee 23       	and	r30, r30
    16dc:	0c f0       	brlt	.+2      	; 0x16e0 <__vector_77+0x1a6>
    16de:	4a c0       	rjmp	.+148    	; 0x1774 <__vector_77+0x23a>
    16e0:	93 e0       	ldi	r25, 0x03	; 3
    16e2:	e9 0e       	add	r14, r25
    16e4:	91 e0       	ldi	r25, 0x01	; 1
    16e6:	e2 16       	cp	r14, r18
    16e8:	08 f0       	brcs	.+2      	; 0x16ec <__vector_77+0x1b2>
    16ea:	90 e0       	ldi	r25, 0x00	; 0
    16ec:	21 e0       	ldi	r18, 0x01	; 1
    16ee:	f3 16       	cp	r15, r19
    16f0:	08 f0       	brcs	.+2      	; 0x16f4 <__vector_77+0x1ba>
    16f2:	20 e0       	ldi	r18, 0x00	; 0
    16f4:	39 2f       	mov	r19, r25
    16f6:	3f 0d       	add	r19, r15
    16f8:	91 e0       	ldi	r25, 0x01	; 1
    16fa:	3f 15       	cp	r19, r15
    16fc:	08 f0       	brcs	.+2      	; 0x1700 <__vector_77+0x1c6>
    16fe:	90 e0       	ldi	r25, 0x00	; 0
    1700:	29 2b       	or	r18, r25
    1702:	91 e0       	ldi	r25, 0x01	; 1
    1704:	04 17       	cp	r16, r20
    1706:	08 f0       	brcs	.+2      	; 0x170a <__vector_77+0x1d0>
    1708:	90 e0       	ldi	r25, 0x00	; 0
    170a:	42 2f       	mov	r20, r18
    170c:	40 0f       	add	r20, r16
    170e:	21 e0       	ldi	r18, 0x01	; 1
    1710:	40 17       	cp	r20, r16
    1712:	08 f0       	brcs	.+2      	; 0x1716 <__vector_77+0x1dc>
    1714:	20 e0       	ldi	r18, 0x00	; 0
    1716:	92 2b       	or	r25, r18
    1718:	21 e0       	ldi	r18, 0x01	; 1
    171a:	15 17       	cp	r17, r21
    171c:	08 f0       	brcs	.+2      	; 0x1720 <__vector_77+0x1e6>
    171e:	20 e0       	ldi	r18, 0x00	; 0
    1720:	59 2f       	mov	r21, r25
    1722:	51 0f       	add	r21, r17
    1724:	91 e0       	ldi	r25, 0x01	; 1
    1726:	51 17       	cp	r21, r17
    1728:	08 f0       	brcs	.+2      	; 0x172c <__vector_77+0x1f2>
    172a:	90 e0       	ldi	r25, 0x00	; 0
    172c:	29 2b       	or	r18, r25
    172e:	91 e0       	ldi	r25, 0x01	; 1
    1730:	b6 17       	cp	r27, r22
    1732:	08 f0       	brcs	.+2      	; 0x1736 <__vector_77+0x1fc>
    1734:	90 e0       	ldi	r25, 0x00	; 0
    1736:	62 2f       	mov	r22, r18
    1738:	6b 0f       	add	r22, r27
    173a:	21 e0       	ldi	r18, 0x01	; 1
    173c:	6b 17       	cp	r22, r27
    173e:	08 f0       	brcs	.+2      	; 0x1742 <__vector_77+0x208>
    1740:	20 e0       	ldi	r18, 0x00	; 0
    1742:	92 2b       	or	r25, r18
    1744:	21 e0       	ldi	r18, 0x01	; 1
    1746:	a7 17       	cp	r26, r23
    1748:	08 f0       	brcs	.+2      	; 0x174c <__vector_77+0x212>
    174a:	20 e0       	ldi	r18, 0x00	; 0
    174c:	79 2f       	mov	r23, r25
    174e:	7a 0f       	add	r23, r26
    1750:	91 e0       	ldi	r25, 0x01	; 1
    1752:	7a 17       	cp	r23, r26
    1754:	08 f0       	brcs	.+2      	; 0x1758 <__vector_77+0x21e>
    1756:	90 e0       	ldi	r25, 0x00	; 0
    1758:	29 2b       	or	r18, r25
    175a:	91 e0       	ldi	r25, 0x01	; 1
    175c:	f8 17       	cp	r31, r24
    175e:	08 f0       	brcs	.+2      	; 0x1762 <__vector_77+0x228>
    1760:	90 e0       	ldi	r25, 0x00	; 0
    1762:	82 2f       	mov	r24, r18
    1764:	8f 0f       	add	r24, r31
    1766:	21 e0       	ldi	r18, 0x01	; 1
    1768:	8f 17       	cp	r24, r31
    176a:	08 f0       	brcs	.+2      	; 0x176e <__vector_77+0x234>
    176c:	20 e0       	ldi	r18, 0x00	; 0
    176e:	92 2b       	or	r25, r18
    1770:	2e 2d       	mov	r18, r14
    1772:	9e 0f       	add	r25, r30
    1774:	02 e0       	ldi	r16, 0x02	; 2
    1776:	0e 94 b1 30 	call	0x6162	; 0x6162 <__ashrdi3>
    177a:	29 83       	std	Y+1, r18	; 0x01
    177c:	3a 83       	std	Y+2, r19	; 0x02
    177e:	4b 83       	std	Y+3, r20	; 0x03
    1780:	5c 83       	std	Y+4, r21	; 0x04
    1782:	6d 83       	std	Y+5, r22	; 0x05
    1784:	7e 83       	std	Y+6, r23	; 0x06
    1786:	8f 83       	std	Y+7, r24	; 0x07
    1788:	98 87       	std	Y+8, r25	; 0x08
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    178a:	80 90 74 50 	lds	r8, 0x5074
    178e:	90 90 75 50 	lds	r9, 0x5075
    1792:	a0 90 76 50 	lds	r10, 0x5076
    1796:	b0 90 77 50 	lds	r11, 0x5077
    179a:	29 81       	ldd	r18, Y+1	; 0x01
    179c:	3a 81       	ldd	r19, Y+2	; 0x02
    179e:	4b 81       	ldd	r20, Y+3	; 0x03
    17a0:	5c 81       	ldd	r21, Y+4	; 0x04
    17a2:	6d 81       	ldd	r22, Y+5	; 0x05
    17a4:	7e 81       	ldd	r23, Y+6	; 0x06
    17a6:	8f 81       	ldd	r24, Y+7	; 0x07
    17a8:	98 85       	ldd	r25, Y+8	; 0x08
    17aa:	f4 01       	movw	r30, r8
    17ac:	ee 0f       	add	r30, r30
    17ae:	ff 1f       	adc	r31, r31
    17b0:	ee 0f       	add	r30, r30
    17b2:	ff 1f       	adc	r31, r31
    17b4:	80 90 72 50 	lds	r8, 0x5072
    17b8:	90 90 73 50 	lds	r9, 0x5073
    17bc:	8e 0e       	add	r8, r30
    17be:	9f 1e       	adc	r9, r31
    17c0:	0f 2e       	mov	r0, r31
    17c2:	f0 ea       	ldi	r31, 0xA0	; 160
    17c4:	af 2e       	mov	r10, r31
    17c6:	f0 2d       	mov	r31, r0
    17c8:	0f 2e       	mov	r0, r31
    17ca:	f5 e2       	ldi	r31, 0x25	; 37
    17cc:	bf 2e       	mov	r11, r31
    17ce:	f0 2d       	mov	r31, r0
    17d0:	0f 2e       	mov	r0, r31
    17d2:	f6 e2       	ldi	r31, 0x26	; 38
    17d4:	cf 2e       	mov	r12, r31
    17d6:	f0 2d       	mov	r31, r0
    17d8:	dd 24       	eor	r13, r13
    17da:	ee 24       	eor	r14, r14
    17dc:	ff 24       	eor	r15, r15
    17de:	00 e0       	ldi	r16, 0x00	; 0
    17e0:	10 e0       	ldi	r17, 0x00	; 0
    17e2:	0e 94 6a 2f 	call	0x5ed4	; 0x5ed4 <__muldi3>
    17e6:	aa 24       	eor	r10, r10
    17e8:	aa 94       	dec	r10
    17ea:	bb 24       	eor	r11, r11
    17ec:	ba 94       	dec	r11
    17ee:	0f 2e       	mov	r0, r31
    17f0:	ff e7       	ldi	r31, 0x7F	; 127
    17f2:	cf 2e       	mov	r12, r31
    17f4:	f0 2d       	mov	r31, r0
    17f6:	0e 94 19 31 	call	0x6232	; 0x6232 <__divdi3>
    17fa:	01 e0       	ldi	r16, 0x01	; 1
    17fc:	0e 94 3d 30 	call	0x607a	; 0x607a <__ashldi3>
    1800:	0f 2e       	mov	r0, r31
    1802:	f3 e0       	ldi	r31, 0x03	; 3
    1804:	af 2e       	mov	r10, r31
    1806:	f0 2d       	mov	r31, r0
    1808:	bb 24       	eor	r11, r11
    180a:	cc 24       	eor	r12, r12
    180c:	00 e0       	ldi	r16, 0x00	; 0
    180e:	0e 94 19 31 	call	0x6232	; 0x6232 <__divdi3>
    1812:	f4 01       	movw	r30, r8
    1814:	20 83       	st	Z, r18
    1816:	31 83       	std	Z+1, r19	; 0x01
    1818:	42 83       	std	Z+2, r20	; 0x02
    181a:	53 83       	std	Z+3, r21	; 0x03
	sampleCount++;
    181c:	80 91 74 50 	lds	r24, 0x5074
    1820:	90 91 75 50 	lds	r25, 0x5075
    1824:	a0 91 76 50 	lds	r26, 0x5076
    1828:	b0 91 77 50 	lds	r27, 0x5077
    182c:	01 96       	adiw	r24, 0x01	; 1
    182e:	a1 1d       	adc	r26, r1
    1830:	b1 1d       	adc	r27, r1
    1832:	80 93 74 50 	sts	0x5074, r24
    1836:	90 93 75 50 	sts	0x5075, r25
    183a:	a0 93 76 50 	sts	0x5076, r26
    183e:	b0 93 77 50 	sts	0x5077, r27
}
    1842:	2c 96       	adiw	r28, 0x0c	; 12
    1844:	cd bf       	out	0x3d, r28	; 61
    1846:	de bf       	out	0x3e, r29	; 62
    1848:	df 91       	pop	r29
    184a:	cf 91       	pop	r28
    184c:	ff 91       	pop	r31
    184e:	ef 91       	pop	r30
    1850:	bf 91       	pop	r27
    1852:	af 91       	pop	r26
    1854:	9f 91       	pop	r25
    1856:	8f 91       	pop	r24
    1858:	7f 91       	pop	r23
    185a:	6f 91       	pop	r22
    185c:	5f 91       	pop	r21
    185e:	4f 91       	pop	r20
    1860:	3f 91       	pop	r19
    1862:	2f 91       	pop	r18
    1864:	1f 91       	pop	r17
    1866:	0f 91       	pop	r16
    1868:	ff 90       	pop	r15
    186a:	ef 90       	pop	r14
    186c:	df 90       	pop	r13
    186e:	cf 90       	pop	r12
    1870:	bf 90       	pop	r11
    1872:	af 90       	pop	r10
    1874:	9f 90       	pop	r9
    1876:	8f 90       	pop	r8
    1878:	7f 90       	pop	r7
    187a:	6f 90       	pop	r6
    187c:	0f 90       	pop	r0
    187e:	0b be       	out	0x3b, r0	; 59
    1880:	0f 90       	pop	r0
    1882:	0f be       	out	0x3f, r0	; 63
    1884:	0f 90       	pop	r0
    1886:	1f 90       	pop	r1
    1888:	18 95       	reti

0000188a <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
	
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    188a:	82 e0       	ldi	r24, 0x02	; 2
    188c:	e0 ea       	ldi	r30, 0xA0	; 160
    188e:	f6 e0       	ldi	r31, 0x06	; 6
    1890:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1892:	8a ea       	ldi	r24, 0xAA	; 170
    1894:	e0 ec       	ldi	r30, 0xC0	; 192
    1896:	f8 e0       	ldi	r31, 0x08	; 8
    1898:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    189a:	82 81       	ldd	r24, Z+2	; 0x02
    189c:	88 23       	and	r24, r24
    189e:	ec f7       	brge	.-6      	; 0x189a <sampleCurrentChannel+0x10>
	SPIBuffer[SPICount] = SPIC.DATA;
    18a0:	90 91 c6 50 	lds	r25, 0x50C6
    18a4:	e0 ec       	ldi	r30, 0xC0	; 192
    18a6:	f8 e0       	ldi	r31, 0x08	; 8
    18a8:	83 81       	ldd	r24, Z+3	; 0x03
    18aa:	a5 e6       	ldi	r26, 0x65	; 101
    18ac:	b0 e5       	ldi	r27, 0x50	; 80
    18ae:	a9 0f       	add	r26, r25
    18b0:	b1 1d       	adc	r27, r1
    18b2:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    18b4:	8a ea       	ldi	r24, 0xAA	; 170
    18b6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    18b8:	82 81       	ldd	r24, Z+2	; 0x02
    18ba:	88 23       	and	r24, r24
    18bc:	ec f7       	brge	.-6      	; 0x18b8 <sampleCurrentChannel+0x2e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    18be:	a0 91 c6 50 	lds	r26, 0x50C6
    18c2:	b0 e0       	ldi	r27, 0x00	; 0
    18c4:	e0 ec       	ldi	r30, 0xC0	; 192
    18c6:	f8 e0       	ldi	r31, 0x08	; 8
    18c8:	83 81       	ldd	r24, Z+3	; 0x03
    18ca:	aa 59       	subi	r26, 0x9A	; 154
    18cc:	bf 4a       	sbci	r27, 0xAF	; 175
    18ce:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    18d0:	8a ea       	ldi	r24, 0xAA	; 170
    18d2:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    18d4:	82 81       	ldd	r24, Z+2	; 0x02
    18d6:	88 23       	and	r24, r24
    18d8:	ec f7       	brge	.-6      	; 0x18d4 <sampleCurrentChannel+0x4a>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    18da:	e0 91 c6 50 	lds	r30, 0x50C6
    18de:	f0 e0       	ldi	r31, 0x00	; 0
    18e0:	a0 ec       	ldi	r26, 0xC0	; 192
    18e2:	b8 e0       	ldi	r27, 0x08	; 8
    18e4:	13 96       	adiw	r26, 0x03	; 3
    18e6:	8c 91       	ld	r24, X
    18e8:	13 97       	sbiw	r26, 0x03	; 3
    18ea:	e9 59       	subi	r30, 0x99	; 153
    18ec:	ff 4a       	sbci	r31, 0xAF	; 175
    18ee:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    18f0:	82 e0       	ldi	r24, 0x02	; 2
    18f2:	e0 ea       	ldi	r30, 0xA0	; 160
    18f4:	f6 e0       	ldi	r31, 0x06	; 6
    18f6:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
    18f8:	80 91 c6 50 	lds	r24, 0x50C6
    18fc:	8d 5f       	subi	r24, 0xFD	; 253
    18fe:	80 93 c6 50 	sts	0x50C6, r24
}
    1902:	08 95       	ret

00001904 <__vector_82>:
ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point
ISR(TCD0_CCD_vect) {
    1904:	1f 92       	push	r1
    1906:	0f 92       	push	r0
    1908:	0f b6       	in	r0, 0x3f	; 63
    190a:	0f 92       	push	r0
    190c:	0b b6       	in	r0, 0x3b	; 59
    190e:	0f 92       	push	r0
    1910:	11 24       	eor	r1, r1
    1912:	2f 93       	push	r18
    1914:	3f 93       	push	r19
    1916:	4f 93       	push	r20
    1918:	5f 93       	push	r21
    191a:	6f 93       	push	r22
    191c:	7f 93       	push	r23
    191e:	8f 93       	push	r24
    1920:	9f 93       	push	r25
    1922:	af 93       	push	r26
    1924:	bf 93       	push	r27
    1926:	ef 93       	push	r30
    1928:	ff 93       	push	r31
	sampleCurrentChannel();
    192a:	0e 94 45 0c 	call	0x188a	; 0x188a <sampleCurrentChannel>
	SPICount = 0;
    192e:	10 92 c6 50 	sts	0x50C6, r1
}
    1932:	ff 91       	pop	r31
    1934:	ef 91       	pop	r30
    1936:	bf 91       	pop	r27
    1938:	af 91       	pop	r26
    193a:	9f 91       	pop	r25
    193c:	8f 91       	pop	r24
    193e:	7f 91       	pop	r23
    1940:	6f 91       	pop	r22
    1942:	5f 91       	pop	r21
    1944:	4f 91       	pop	r20
    1946:	3f 91       	pop	r19
    1948:	2f 91       	pop	r18
    194a:	0f 90       	pop	r0
    194c:	0b be       	out	0x3b, r0	; 59
    194e:	0f 90       	pop	r0
    1950:	0f be       	out	0x3f, r0	; 63
    1952:	0f 90       	pop	r0
    1954:	1f 90       	pop	r1
    1956:	18 95       	reti

00001958 <__vector_81>:
ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCD0_CCC_vect) {
    1958:	1f 92       	push	r1
    195a:	0f 92       	push	r0
    195c:	0f b6       	in	r0, 0x3f	; 63
    195e:	0f 92       	push	r0
    1960:	0b b6       	in	r0, 0x3b	; 59
    1962:	0f 92       	push	r0
    1964:	11 24       	eor	r1, r1
    1966:	2f 93       	push	r18
    1968:	3f 93       	push	r19
    196a:	4f 93       	push	r20
    196c:	5f 93       	push	r21
    196e:	6f 93       	push	r22
    1970:	7f 93       	push	r23
    1972:	8f 93       	push	r24
    1974:	9f 93       	push	r25
    1976:	af 93       	push	r26
    1978:	bf 93       	push	r27
    197a:	ef 93       	push	r30
    197c:	ff 93       	push	r31
	sampleCurrentChannel();
    197e:	0e 94 45 0c 	call	0x188a	; 0x188a <sampleCurrentChannel>
}
    1982:	ff 91       	pop	r31
    1984:	ef 91       	pop	r30
    1986:	bf 91       	pop	r27
    1988:	af 91       	pop	r26
    198a:	9f 91       	pop	r25
    198c:	8f 91       	pop	r24
    198e:	7f 91       	pop	r23
    1990:	6f 91       	pop	r22
    1992:	5f 91       	pop	r21
    1994:	4f 91       	pop	r20
    1996:	3f 91       	pop	r19
    1998:	2f 91       	pop	r18
    199a:	0f 90       	pop	r0
    199c:	0b be       	out	0x3b, r0	; 59
    199e:	0f 90       	pop	r0
    19a0:	0f be       	out	0x3f, r0	; 63
    19a2:	0f 90       	pop	r0
    19a4:	1f 90       	pop	r1
    19a6:	18 95       	reti

000019a8 <__vector_80>:
//first averaging point
ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}
//second averaging point
ISR(TCD0_CCB_vect) {
    19a8:	1f 92       	push	r1
    19aa:	0f 92       	push	r0
    19ac:	0f b6       	in	r0, 0x3f	; 63
    19ae:	0f 92       	push	r0
    19b0:	0b b6       	in	r0, 0x3b	; 59
    19b2:	0f 92       	push	r0
    19b4:	11 24       	eor	r1, r1
    19b6:	2f 93       	push	r18
    19b8:	3f 93       	push	r19
    19ba:	4f 93       	push	r20
    19bc:	5f 93       	push	r21
    19be:	6f 93       	push	r22
    19c0:	7f 93       	push	r23
    19c2:	8f 93       	push	r24
    19c4:	9f 93       	push	r25
    19c6:	af 93       	push	r26
    19c8:	bf 93       	push	r27
    19ca:	ef 93       	push	r30
    19cc:	ff 93       	push	r31
	sampleCurrentChannel();
    19ce:	0e 94 45 0c 	call	0x188a	; 0x188a <sampleCurrentChannel>
}
    19d2:	ff 91       	pop	r31
    19d4:	ef 91       	pop	r30
    19d6:	bf 91       	pop	r27
    19d8:	af 91       	pop	r26
    19da:	9f 91       	pop	r25
    19dc:	8f 91       	pop	r24
    19de:	7f 91       	pop	r23
    19e0:	6f 91       	pop	r22
    19e2:	5f 91       	pop	r21
    19e4:	4f 91       	pop	r20
    19e6:	3f 91       	pop	r19
    19e8:	2f 91       	pop	r18
    19ea:	0f 90       	pop	r0
    19ec:	0b be       	out	0x3b, r0	; 59
    19ee:	0f 90       	pop	r0
    19f0:	0f be       	out	0x3f, r0	; 63
    19f2:	0f 90       	pop	r0
    19f4:	1f 90       	pop	r1
    19f6:	18 95       	reti

000019f8 <__vector_79>:
// 	enableADCMUX(FALSE);
	
}

//first averaging point
ISR(TCD0_CCA_vect) {
    19f8:	1f 92       	push	r1
    19fa:	0f 92       	push	r0
    19fc:	0f b6       	in	r0, 0x3f	; 63
    19fe:	0f 92       	push	r0
    1a00:	0b b6       	in	r0, 0x3b	; 59
    1a02:	0f 92       	push	r0
    1a04:	11 24       	eor	r1, r1
    1a06:	2f 93       	push	r18
    1a08:	3f 93       	push	r19
    1a0a:	4f 93       	push	r20
    1a0c:	5f 93       	push	r21
    1a0e:	6f 93       	push	r22
    1a10:	7f 93       	push	r23
    1a12:	8f 93       	push	r24
    1a14:	9f 93       	push	r25
    1a16:	af 93       	push	r26
    1a18:	bf 93       	push	r27
    1a1a:	ef 93       	push	r30
    1a1c:	ff 93       	push	r31
	sampleCurrentChannel();
    1a1e:	0e 94 45 0c 	call	0x188a	; 0x188a <sampleCurrentChannel>
}
    1a22:	ff 91       	pop	r31
    1a24:	ef 91       	pop	r30
    1a26:	bf 91       	pop	r27
    1a28:	af 91       	pop	r26
    1a2a:	9f 91       	pop	r25
    1a2c:	8f 91       	pop	r24
    1a2e:	7f 91       	pop	r23
    1a30:	6f 91       	pop	r22
    1a32:	5f 91       	pop	r21
    1a34:	4f 91       	pop	r20
    1a36:	3f 91       	pop	r19
    1a38:	2f 91       	pop	r18
    1a3a:	0f 90       	pop	r0
    1a3c:	0b be       	out	0x3b, r0	; 59
    1a3e:	0f 90       	pop	r0
    1a40:	0f be       	out	0x3f, r0	; 63
    1a42:	0f 90       	pop	r0
    1a44:	1f 90       	pop	r1
    1a46:	18 95       	reti

00001a48 <__vector_19>:
ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    1a48:	1f 92       	push	r1
    1a4a:	0f 92       	push	r0
    1a4c:	0f b6       	in	r0, 0x3f	; 63
    1a4e:	0f 92       	push	r0
    1a50:	0b b6       	in	r0, 0x3b	; 59
    1a52:	0f 92       	push	r0
    1a54:	11 24       	eor	r1, r1
    1a56:	2f 93       	push	r18
    1a58:	3f 93       	push	r19
    1a5a:	4f 93       	push	r20
    1a5c:	5f 93       	push	r21
    1a5e:	6f 93       	push	r22
    1a60:	7f 93       	push	r23
    1a62:	8f 93       	push	r24
    1a64:	9f 93       	push	r25
    1a66:	af 93       	push	r26
    1a68:	bf 93       	push	r27
    1a6a:	ef 93       	push	r30
    1a6c:	ff 93       	push	r31
	sampleCurrentChannel();
    1a6e:	0e 94 45 0c 	call	0x188a	; 0x188a <sampleCurrentChannel>
	SPICount = 0;
    1a72:	10 92 c6 50 	sts	0x50C6, r1
	if(PORTB.OUT & PIN1_bm) {
    1a76:	e0 e2       	ldi	r30, 0x20	; 32
    1a78:	f6 e0       	ldi	r31, 0x06	; 6
    1a7a:	84 81       	ldd	r24, Z+4	; 0x04
    1a7c:	81 ff       	sbrs	r24, 1
    1a7e:	0f c0       	rjmp	.+30     	; 0x1a9e <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    1a80:	e0 e0       	ldi	r30, 0x00	; 0
    1a82:	f6 e0       	ldi	r31, 0x06	; 6
    1a84:	84 81       	ldd	r24, Z+4	; 0x04
    1a86:	86 ff       	sbrs	r24, 6
    1a88:	05 c0       	rjmp	.+10     	; 0x1a94 <__vector_19+0x4c>
    1a8a:	82 e0       	ldi	r24, 0x02	; 2
    1a8c:	e0 e2       	ldi	r30, 0x20	; 32
    1a8e:	f6 e0       	ldi	r31, 0x06	; 6
    1a90:	87 83       	std	Z+7, r24	; 0x07
    1a92:	0d c0       	rjmp	.+26     	; 0x1aae <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
    1a94:	80 e4       	ldi	r24, 0x40	; 64
    1a96:	e0 e0       	ldi	r30, 0x00	; 0
    1a98:	f6 e0       	ldi	r31, 0x06	; 6
    1a9a:	87 83       	std	Z+7, r24	; 0x07
    1a9c:	08 c0       	rjmp	.+16     	; 0x1aae <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    1a9e:	80 e4       	ldi	r24, 0x40	; 64
    1aa0:	e0 e0       	ldi	r30, 0x00	; 0
    1aa2:	f6 e0       	ldi	r31, 0x06	; 6
    1aa4:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
    1aa6:	82 e0       	ldi	r24, 0x02	; 2
    1aa8:	e0 e2       	ldi	r30, 0x20	; 32
    1aaa:	f6 e0       	ldi	r31, 0x06	; 6
    1aac:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
    1aae:	ff 91       	pop	r31
    1ab0:	ef 91       	pop	r30
    1ab2:	bf 91       	pop	r27
    1ab4:	af 91       	pop	r26
    1ab6:	9f 91       	pop	r25
    1ab8:	8f 91       	pop	r24
    1aba:	7f 91       	pop	r23
    1abc:	6f 91       	pop	r22
    1abe:	5f 91       	pop	r21
    1ac0:	4f 91       	pop	r20
    1ac2:	3f 91       	pop	r19
    1ac4:	2f 91       	pop	r18
    1ac6:	0f 90       	pop	r0
    1ac8:	0b be       	out	0x3b, r0	; 59
    1aca:	0f 90       	pop	r0
    1acc:	0f be       	out	0x3f, r0	; 63
    1ace:	0f 90       	pop	r0
    1ad0:	1f 90       	pop	r1
    1ad2:	18 95       	reti

00001ad4 <__vector_18>:
ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCC0_CCC_vect) {
    1ad4:	1f 92       	push	r1
    1ad6:	0f 92       	push	r0
    1ad8:	0f b6       	in	r0, 0x3f	; 63
    1ada:	0f 92       	push	r0
    1adc:	0b b6       	in	r0, 0x3b	; 59
    1ade:	0f 92       	push	r0
    1ae0:	11 24       	eor	r1, r1
    1ae2:	2f 93       	push	r18
    1ae4:	3f 93       	push	r19
    1ae6:	4f 93       	push	r20
    1ae8:	5f 93       	push	r21
    1aea:	6f 93       	push	r22
    1aec:	7f 93       	push	r23
    1aee:	8f 93       	push	r24
    1af0:	9f 93       	push	r25
    1af2:	af 93       	push	r26
    1af4:	bf 93       	push	r27
    1af6:	ef 93       	push	r30
    1af8:	ff 93       	push	r31
	sampleCurrentChannel();
    1afa:	0e 94 45 0c 	call	0x188a	; 0x188a <sampleCurrentChannel>
}
    1afe:	ff 91       	pop	r31
    1b00:	ef 91       	pop	r30
    1b02:	bf 91       	pop	r27
    1b04:	af 91       	pop	r26
    1b06:	9f 91       	pop	r25
    1b08:	8f 91       	pop	r24
    1b0a:	7f 91       	pop	r23
    1b0c:	6f 91       	pop	r22
    1b0e:	5f 91       	pop	r21
    1b10:	4f 91       	pop	r20
    1b12:	3f 91       	pop	r19
    1b14:	2f 91       	pop	r18
    1b16:	0f 90       	pop	r0
    1b18:	0b be       	out	0x3b, r0	; 59
    1b1a:	0f 90       	pop	r0
    1b1c:	0f be       	out	0x3f, r0	; 63
    1b1e:	0f 90       	pop	r0
    1b20:	1f 90       	pop	r1
    1b22:	18 95       	reti

00001b24 <__vector_17>:
ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

//second averaging point
ISR(TCC0_CCB_vect) {
    1b24:	1f 92       	push	r1
    1b26:	0f 92       	push	r0
    1b28:	0f b6       	in	r0, 0x3f	; 63
    1b2a:	0f 92       	push	r0
    1b2c:	0b b6       	in	r0, 0x3b	; 59
    1b2e:	0f 92       	push	r0
    1b30:	11 24       	eor	r1, r1
    1b32:	2f 93       	push	r18
    1b34:	3f 93       	push	r19
    1b36:	4f 93       	push	r20
    1b38:	5f 93       	push	r21
    1b3a:	6f 93       	push	r22
    1b3c:	7f 93       	push	r23
    1b3e:	8f 93       	push	r24
    1b40:	9f 93       	push	r25
    1b42:	af 93       	push	r26
    1b44:	bf 93       	push	r27
    1b46:	ef 93       	push	r30
    1b48:	ff 93       	push	r31
	sampleCurrentChannel();
    1b4a:	0e 94 45 0c 	call	0x188a	; 0x188a <sampleCurrentChannel>
}
    1b4e:	ff 91       	pop	r31
    1b50:	ef 91       	pop	r30
    1b52:	bf 91       	pop	r27
    1b54:	af 91       	pop	r26
    1b56:	9f 91       	pop	r25
    1b58:	8f 91       	pop	r24
    1b5a:	7f 91       	pop	r23
    1b5c:	6f 91       	pop	r22
    1b5e:	5f 91       	pop	r21
    1b60:	4f 91       	pop	r20
    1b62:	3f 91       	pop	r19
    1b64:	2f 91       	pop	r18
    1b66:	0f 90       	pop	r0
    1b68:	0b be       	out	0x3b, r0	; 59
    1b6a:	0f 90       	pop	r0
    1b6c:	0f be       	out	0x3f, r0	; 63
    1b6e:	0f 90       	pop	r0
    1b70:	1f 90       	pop	r1
    1b72:	18 95       	reti

00001b74 <__vector_16>:
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//first averaging point
ISR(TCC0_CCA_vect) {
    1b74:	1f 92       	push	r1
    1b76:	0f 92       	push	r0
    1b78:	0f b6       	in	r0, 0x3f	; 63
    1b7a:	0f 92       	push	r0
    1b7c:	0b b6       	in	r0, 0x3b	; 59
    1b7e:	0f 92       	push	r0
    1b80:	11 24       	eor	r1, r1
    1b82:	2f 93       	push	r18
    1b84:	3f 93       	push	r19
    1b86:	4f 93       	push	r20
    1b88:	5f 93       	push	r21
    1b8a:	6f 93       	push	r22
    1b8c:	7f 93       	push	r23
    1b8e:	8f 93       	push	r24
    1b90:	9f 93       	push	r25
    1b92:	af 93       	push	r26
    1b94:	bf 93       	push	r27
    1b96:	ef 93       	push	r30
    1b98:	ff 93       	push	r31
	sampleCurrentChannel();
    1b9a:	0e 94 45 0c 	call	0x188a	; 0x188a <sampleCurrentChannel>
}
    1b9e:	ff 91       	pop	r31
    1ba0:	ef 91       	pop	r30
    1ba2:	bf 91       	pop	r27
    1ba4:	af 91       	pop	r26
    1ba6:	9f 91       	pop	r25
    1ba8:	8f 91       	pop	r24
    1baa:	7f 91       	pop	r23
    1bac:	6f 91       	pop	r22
    1bae:	5f 91       	pop	r21
    1bb0:	4f 91       	pop	r20
    1bb2:	3f 91       	pop	r19
    1bb4:	2f 91       	pop	r18
    1bb6:	0f 90       	pop	r0
    1bb8:	0b be       	out	0x3b, r0	; 59
    1bba:	0f 90       	pop	r0
    1bbc:	0f be       	out	0x3f, r0	; 63
    1bbe:	0f 90       	pop	r0
    1bc0:	1f 90       	pop	r1
    1bc2:	18 95       	reti

00001bc4 <writeSE2FRAM>:
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    1bc4:	ff 92       	push	r15
    1bc6:	0f 93       	push	r16
    1bc8:	1f 93       	push	r17
    1bca:	cf 93       	push	r28
    1bcc:	df 93       	push	r29
    1bce:	cd b7       	in	r28, 0x3d	; 61
    1bd0:	de b7       	in	r29, 0x3e	; 62
    1bd2:	28 97       	sbiw	r28, 0x08	; 8
    1bd4:	cd bf       	out	0x3d, r28	; 61
    1bd6:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    1bd8:	19 82       	std	Y+1, r1	; 0x01
    1bda:	1a 82       	std	Y+2, r1	; 0x02
    1bdc:	1b 82       	std	Y+3, r1	; 0x03
    1bde:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    1be0:	80 91 74 50 	lds	r24, 0x5074
    1be4:	90 91 75 50 	lds	r25, 0x5075
    1be8:	a0 91 76 50 	lds	r26, 0x5076
    1bec:	b0 91 77 50 	lds	r27, 0x5077
    1bf0:	01 96       	adiw	r24, 0x01	; 1
    1bf2:	a1 1d       	adc	r26, r1
    1bf4:	b1 1d       	adc	r27, r1
    1bf6:	80 93 74 50 	sts	0x5074, r24
    1bfa:	90 93 75 50 	sts	0x5075, r25
    1bfe:	a0 93 76 50 	sts	0x5076, r26
    1c02:	b0 93 77 50 	sts	0x5077, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    1c06:	80 ed       	ldi	r24, 0xD0	; 208
    1c08:	80 93 c0 08 	sts	0x08C0, r24
    1c0c:	20 e0       	ldi	r18, 0x00	; 0
    1c0e:	30 e0       	ldi	r19, 0x00	; 0
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1c10:	05 e6       	ldi	r16, 0x65	; 101
    1c12:	10 e5       	ldi	r17, 0x50	; 80
    1c14:	ff 24       	eor	r15, r15
    1c16:	fa 94       	dec	r15
    1c18:	c9 01       	movw	r24, r18
    1c1a:	f8 01       	movw	r30, r16
    1c1c:	e2 0f       	add	r30, r18
    1c1e:	f3 1f       	adc	r31, r19
    1c20:	40 81       	ld	r20, Z
    1c22:	44 23       	and	r20, r20
    1c24:	14 f4       	brge	.+4      	; 0x1c2a <writeSE2FRAM+0x66>
    1c26:	f8 86       	std	Y+8, r15	; 0x08
    1c28:	01 c0       	rjmp	.+2      	; 0x1c2c <writeSE2FRAM+0x68>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1c2a:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1c2c:	80 0f       	add	r24, r16
    1c2e:	91 1f       	adc	r25, r17
    1c30:	fc 01       	movw	r30, r24
    1c32:	80 81       	ld	r24, Z
    1c34:	8f 83       	std	Y+7, r24	; 0x07
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    1c36:	f9 01       	movw	r30, r18
    1c38:	31 96       	adiw	r30, 0x01	; 1
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1c3a:	e0 0f       	add	r30, r16
    1c3c:	f1 1f       	adc	r31, r17
    1c3e:	80 81       	ld	r24, Z
    1c40:	8e 83       	std	Y+6, r24	; 0x06
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    1c42:	f9 01       	movw	r30, r18
    1c44:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1c46:	e0 0f       	add	r30, r16
    1c48:	f1 1f       	adc	r31, r17
    1c4a:	80 81       	ld	r24, Z
    1c4c:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    1c4e:	49 81       	ldd	r20, Y+1	; 0x01
    1c50:	5a 81       	ldd	r21, Y+2	; 0x02
    1c52:	6b 81       	ldd	r22, Y+3	; 0x03
    1c54:	7c 81       	ldd	r23, Y+4	; 0x04
    1c56:	8d 81       	ldd	r24, Y+5	; 0x05
    1c58:	9e 81       	ldd	r25, Y+6	; 0x06
    1c5a:	af 81       	ldd	r26, Y+7	; 0x07
    1c5c:	b8 85       	ldd	r27, Y+8	; 0x08
    1c5e:	84 0f       	add	r24, r20
    1c60:	95 1f       	adc	r25, r21
    1c62:	a6 1f       	adc	r26, r22
    1c64:	b7 1f       	adc	r27, r23
    1c66:	89 83       	std	Y+1, r24	; 0x01
    1c68:	9a 83       	std	Y+2, r25	; 0x02
    1c6a:	ab 83       	std	Y+3, r26	; 0x03
    1c6c:	bc 83       	std	Y+4, r27	; 0x04
    1c6e:	2d 5f       	subi	r18, 0xFD	; 253
    1c70:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    1c72:	2c 30       	cpi	r18, 0x0C	; 12
    1c74:	31 05       	cpc	r19, r1
    1c76:	81 f6       	brne	.-96     	; 0x1c18 <writeSE2FRAM+0x54>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    1c78:	69 81       	ldd	r22, Y+1	; 0x01
    1c7a:	7a 81       	ldd	r23, Y+2	; 0x02
    1c7c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c7e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c80:	24 e0       	ldi	r18, 0x04	; 4
    1c82:	30 e0       	ldi	r19, 0x00	; 0
    1c84:	40 e0       	ldi	r20, 0x00	; 0
    1c86:	50 e0       	ldi	r21, 0x00	; 0
    1c88:	0e 94 ec 3a 	call	0x75d8	; 0x75d8 <__divmodsi4>
    1c8c:	29 83       	std	Y+1, r18	; 0x01
    1c8e:	3a 83       	std	Y+2, r19	; 0x02
    1c90:	4b 83       	std	Y+3, r20	; 0x03
    1c92:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    1c94:	29 81       	ldd	r18, Y+1	; 0x01
    1c96:	87 e6       	ldi	r24, 0x67	; 103
    1c98:	90 e5       	ldi	r25, 0x50	; 80
    1c9a:	20 93 67 50 	sts	0x5067, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    1c9e:	2a 81       	ldd	r18, Y+2	; 0x02
    1ca0:	fc 01       	movw	r30, r24
    1ca2:	31 97       	sbiw	r30, 0x01	; 1
    1ca4:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    1ca6:	2b 81       	ldd	r18, Y+3	; 0x03
    1ca8:	02 97       	sbiw	r24, 0x02	; 2
    1caa:	fc 01       	movw	r30, r24
    1cac:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    1cae:	80 e1       	ldi	r24, 0x10	; 16
    1cb0:	e0 e4       	ldi	r30, 0x40	; 64
    1cb2:	f6 e0       	ldi	r31, 0x06	; 6
    1cb4:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1cb6:	88 e0       	ldi	r24, 0x08	; 8
    1cb8:	e0 e2       	ldi	r30, 0x20	; 32
    1cba:	f6 e0       	ldi	r31, 0x06	; 6
    1cbc:	86 83       	std	Z+6, r24	; 0x06
	nop();
    1cbe:	00 00       	nop
	SPIC.DATA = FR_WREN;
    1cc0:	86 e0       	ldi	r24, 0x06	; 6
    1cc2:	e0 ec       	ldi	r30, 0xC0	; 192
    1cc4:	f8 e0       	ldi	r31, 0x08	; 8
    1cc6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1cc8:	82 81       	ldd	r24, Z+2	; 0x02
    1cca:	88 23       	and	r24, r24
    1ccc:	ec f7       	brge	.-6      	; 0x1cc8 <writeSE2FRAM+0x104>
	SPIBuffer[12] = SPIC.DATA;
    1cce:	e0 ec       	ldi	r30, 0xC0	; 192
    1cd0:	f8 e0       	ldi	r31, 0x08	; 8
    1cd2:	83 81       	ldd	r24, Z+3	; 0x03
    1cd4:	80 93 71 50 	sts	0x5071, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    1cd8:	a0 e2       	ldi	r26, 0x20	; 32
    1cda:	b6 e0       	ldi	r27, 0x06	; 6
    1cdc:	88 e0       	ldi	r24, 0x08	; 8
    1cde:	15 96       	adiw	r26, 0x05	; 5
    1ce0:	8c 93       	st	X, r24
    1ce2:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    1ce4:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1ce6:	16 96       	adiw	r26, 0x06	; 6
    1ce8:	8c 93       	st	X, r24
    1cea:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    1cec:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    1cee:	82 e0       	ldi	r24, 0x02	; 2
    1cf0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1cf2:	82 81       	ldd	r24, Z+2	; 0x02
    1cf4:	88 23       	and	r24, r24
    1cf6:	ec f7       	brge	.-6      	; 0x1cf2 <writeSE2FRAM+0x12e>
	SPIBuffer[12] = SPIC.DATA;
    1cf8:	e0 ec       	ldi	r30, 0xC0	; 192
    1cfa:	f8 e0       	ldi	r31, 0x08	; 8
    1cfc:	83 81       	ldd	r24, Z+3	; 0x03
    1cfe:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    1d02:	80 91 58 40 	lds	r24, 0x4058
    1d06:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1d08:	82 81       	ldd	r24, Z+2	; 0x02
    1d0a:	88 23       	and	r24, r24
    1d0c:	ec f7       	brge	.-6      	; 0x1d08 <writeSE2FRAM+0x144>
	SPIBuffer[12] = SPIC.DATA;
    1d0e:	e0 ec       	ldi	r30, 0xC0	; 192
    1d10:	f8 e0       	ldi	r31, 0x08	; 8
    1d12:	83 81       	ldd	r24, Z+3	; 0x03
    1d14:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    1d18:	80 91 57 40 	lds	r24, 0x4057
    1d1c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1d1e:	82 81       	ldd	r24, Z+2	; 0x02
    1d20:	88 23       	and	r24, r24
    1d22:	ec f7       	brge	.-6      	; 0x1d1e <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    1d24:	e0 ec       	ldi	r30, 0xC0	; 192
    1d26:	f8 e0       	ldi	r31, 0x08	; 8
    1d28:	83 81       	ldd	r24, Z+3	; 0x03
    1d2a:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[0];
    1d2e:	80 91 65 50 	lds	r24, 0x5065
    1d32:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1d34:	82 81       	ldd	r24, Z+2	; 0x02
    1d36:	88 23       	and	r24, r24
    1d38:	ec f7       	brge	.-6      	; 0x1d34 <writeSE2FRAM+0x170>
	SPIBuffer[12] = SPIC.DATA;
    1d3a:	e0 ec       	ldi	r30, 0xC0	; 192
    1d3c:	f8 e0       	ldi	r31, 0x08	; 8
    1d3e:	83 81       	ldd	r24, Z+3	; 0x03
    1d40:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[1];
    1d44:	80 91 66 50 	lds	r24, 0x5066
    1d48:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1d4a:	82 81       	ldd	r24, Z+2	; 0x02
    1d4c:	88 23       	and	r24, r24
    1d4e:	ec f7       	brge	.-6      	; 0x1d4a <writeSE2FRAM+0x186>
	SPIBuffer[12] = SPIC.DATA;
    1d50:	e0 ec       	ldi	r30, 0xC0	; 192
    1d52:	f8 e0       	ldi	r31, 0x08	; 8
    1d54:	83 81       	ldd	r24, Z+3	; 0x03
    1d56:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = SPIBuffer[2];
    1d5a:	80 91 67 50 	lds	r24, 0x5067
    1d5e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1d60:	82 81       	ldd	r24, Z+2	; 0x02
    1d62:	88 23       	and	r24, r24
    1d64:	ec f7       	brge	.-6      	; 0x1d60 <writeSE2FRAM+0x19c>
	SPIBuffer[12] = SPIC.DATA;
    1d66:	a0 ec       	ldi	r26, 0xC0	; 192
    1d68:	b8 e0       	ldi	r27, 0x08	; 8
    1d6a:	13 96       	adiw	r26, 0x03	; 3
    1d6c:	8c 91       	ld	r24, X
    1d6e:	13 97       	sbiw	r26, 0x03	; 3
    1d70:	80 93 71 50 	sts	0x5071, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    1d74:	88 e0       	ldi	r24, 0x08	; 8
    1d76:	e0 e2       	ldi	r30, 0x20	; 32
    1d78:	f6 e0       	ldi	r31, 0x06	; 6
    1d7a:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    1d7c:	e0 e4       	ldi	r30, 0x40	; 64
    1d7e:	f6 e0       	ldi	r31, 0x06	; 6
    1d80:	80 e1       	ldi	r24, 0x10	; 16
    1d82:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1d84:	94 e5       	ldi	r25, 0x54	; 84
    1d86:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    1d88:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    1d8a:	80 91 57 40 	lds	r24, 0x4057
    1d8e:	90 91 58 40 	lds	r25, 0x4058
    1d92:	03 96       	adiw	r24, 0x03	; 3
    1d94:	80 93 57 40 	sts	0x4057, r24
    1d98:	90 93 58 40 	sts	0x4058, r25
	checksumADC[0] += SPIBuffer[0];
    1d9c:	80 91 3b 21 	lds	r24, 0x213B
    1da0:	e5 e6       	ldi	r30, 0x65	; 101
    1da2:	f0 e5       	ldi	r31, 0x50	; 80
    1da4:	90 81       	ld	r25, Z
    1da6:	89 0f       	add	r24, r25
    1da8:	80 93 3b 21 	sts	0x213B, r24
	checksumADC[1] += SPIBuffer[1];
    1dac:	80 91 3c 21 	lds	r24, 0x213C
    1db0:	91 81       	ldd	r25, Z+1	; 0x01
    1db2:	89 0f       	add	r24, r25
    1db4:	80 93 3c 21 	sts	0x213C, r24
	checksumADC[2] += SPIBuffer[2];
    1db8:	80 91 3d 21 	lds	r24, 0x213D
    1dbc:	92 81       	ldd	r25, Z+2	; 0x02
    1dbe:	89 0f       	add	r24, r25
    1dc0:	80 93 3d 21 	sts	0x213D, r24
}
    1dc4:	28 96       	adiw	r28, 0x08	; 8
    1dc6:	cd bf       	out	0x3d, r28	; 61
    1dc8:	de bf       	out	0x3e, r29	; 62
    1dca:	df 91       	pop	r29
    1dcc:	cf 91       	pop	r28
    1dce:	1f 91       	pop	r17
    1dd0:	0f 91       	pop	r16
    1dd2:	ff 90       	pop	r15
    1dd4:	08 95       	ret

00001dd6 <calcChecksumFRAM>:

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    1dd6:	2f 92       	push	r2
    1dd8:	3f 92       	push	r3
    1dda:	4f 92       	push	r4
    1ddc:	5f 92       	push	r5
    1dde:	6f 92       	push	r6
    1de0:	7f 92       	push	r7
    1de2:	8f 92       	push	r8
    1de4:	9f 92       	push	r9
    1de6:	af 92       	push	r10
    1de8:	bf 92       	push	r11
    1dea:	cf 92       	push	r12
    1dec:	df 92       	push	r13
    1dee:	ef 92       	push	r14
    1df0:	ff 92       	push	r15
    1df2:	0f 93       	push	r16
    1df4:	1f 93       	push	r17
    1df6:	cf 93       	push	r28
    1df8:	df 93       	push	r29
    1dfa:	00 d0       	rcall	.+0      	; 0x1dfc <calcChecksumFRAM+0x26>
    1dfc:	0f 92       	push	r0
    1dfe:	cd b7       	in	r28, 0x3d	; 61
    1e00:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    1e02:	eb e9       	ldi	r30, 0x9B	; 155
    1e04:	f0 e5       	ldi	r31, 0x50	; 80
    1e06:	10 92 9b 50 	sts	0x509B, r1
    1e0a:	10 92 9c 50 	sts	0x509C, r1
    1e0e:	10 92 9d 50 	sts	0x509D, r1
    1e12:	10 92 9e 50 	sts	0x509E, r1
    1e16:	10 92 9f 50 	sts	0x509F, r1
    1e1a:	10 92 a0 50 	sts	0x50A0, r1
    1e1e:	10 92 a1 50 	sts	0x50A1, r1
    1e22:	10 92 a2 50 	sts	0x50A2, r1
    1e26:	df 01       	movw	r26, r30
    1e28:	18 97       	sbiw	r26, 0x08	; 8
    1e2a:	1c 92       	st	X, r1
    1e2c:	11 96       	adiw	r26, 0x01	; 1
    1e2e:	1c 92       	st	X, r1
    1e30:	11 97       	sbiw	r26, 0x01	; 1
    1e32:	12 96       	adiw	r26, 0x02	; 2
    1e34:	1c 92       	st	X, r1
    1e36:	12 97       	sbiw	r26, 0x02	; 2
    1e38:	13 96       	adiw	r26, 0x03	; 3
    1e3a:	1c 92       	st	X, r1
    1e3c:	13 97       	sbiw	r26, 0x03	; 3
    1e3e:	14 96       	adiw	r26, 0x04	; 4
    1e40:	1c 92       	st	X, r1
    1e42:	14 97       	sbiw	r26, 0x04	; 4
    1e44:	15 96       	adiw	r26, 0x05	; 5
    1e46:	1c 92       	st	X, r1
    1e48:	15 97       	sbiw	r26, 0x05	; 5
    1e4a:	16 96       	adiw	r26, 0x06	; 6
    1e4c:	1c 92       	st	X, r1
    1e4e:	16 97       	sbiw	r26, 0x06	; 6
    1e50:	17 96       	adiw	r26, 0x07	; 7
    1e52:	1c 92       	st	X, r1
    1e54:	70 97       	sbiw	r30, 0x10	; 16
    1e56:	10 82       	st	Z, r1
    1e58:	11 82       	std	Z+1, r1	; 0x01
    1e5a:	12 82       	std	Z+2, r1	; 0x02
    1e5c:	13 82       	std	Z+3, r1	; 0x03
    1e5e:	14 82       	std	Z+4, r1	; 0x04
    1e60:	15 82       	std	Z+5, r1	; 0x05
    1e62:	16 82       	std	Z+6, r1	; 0x06
    1e64:	17 82       	std	Z+7, r1	; 0x07
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    1e66:	8a e3       	ldi	r24, 0x3A	; 58
    1e68:	91 e2       	ldi	r25, 0x21	; 33
    1e6a:	10 92 3a 21 	sts	0x213A, r1
    1e6e:	fc 01       	movw	r30, r24
    1e70:	31 97       	sbiw	r30, 0x01	; 1
    1e72:	10 82       	st	Z, r1
    1e74:	02 97       	sbiw	r24, 0x02	; 2
    1e76:	dc 01       	movw	r26, r24
    1e78:	1c 92       	st	X, r1
	FRAMAddress = FR_BASEADD;
    1e7a:	10 92 57 40 	sts	0x4057, r1
    1e7e:	10 92 58 40 	sts	0x4058, r1
    1e82:	e9 e0       	ldi	r30, 0x09	; 9
    1e84:	f0 e0       	ldi	r31, 0x00	; 0
    1e86:	e9 83       	std	Y+1, r30	; 0x01
    1e88:	fa 83       	std	Y+2, r31	; 0x02
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    1e8a:	99 24       	eor	r9, r9
    1e8c:	9a 94       	dec	r9
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
			if(k%9 == 5) sumFRAM[1] += *temp64;
			if(k%9 == 8) sumFRAM[2] += *temp64;
    1e8e:	0f 2e       	mov	r0, r31
    1e90:	fb e9       	ldi	r31, 0x9B	; 155
    1e92:	ef 2e       	mov	r14, r31
    1e94:	f0 e5       	ldi	r31, 0x50	; 80
    1e96:	ff 2e       	mov	r15, r31
    1e98:	f0 2d       	mov	r31, r0
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
			if(k%9 == 5) sumFRAM[1] += *temp64;
    1e9a:	0f 2e       	mov	r0, r31
    1e9c:	f3 e9       	ldi	r31, 0x93	; 147
    1e9e:	cf 2e       	mov	r12, r31
    1ea0:	f0 e5       	ldi	r31, 0x50	; 80
    1ea2:	df 2e       	mov	r13, r31
    1ea4:	f0 2d       	mov	r31, r0
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1ea6:	0f 2e       	mov	r0, r31
    1ea8:	fb e8       	ldi	r31, 0x8B	; 139
    1eaa:	af 2e       	mov	r10, r31
    1eac:	f0 e5       	ldi	r31, 0x50	; 80
    1eae:	bf 2e       	mov	r11, r31
    1eb0:	f0 2d       	mov	r31, r0
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
    1eb2:	81 e7       	ldi	r24, 0x71	; 113
    1eb4:	9c e1       	ldi	r25, 0x1C	; 28
    1eb6:	0e 94 3f 1f 	call	0x3e7e	; 0x3e7e <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    1eba:	80 91 57 40 	lds	r24, 0x4057
    1ebe:	90 91 58 40 	lds	r25, 0x4058
    1ec2:	8f 58       	subi	r24, 0x8F	; 143
    1ec4:	93 4e       	sbci	r25, 0xE3	; 227
    1ec6:	80 93 57 40 	sts	0x4057, r24
    1eca:	90 93 58 40 	sts	0x4058, r25
    1ece:	0f ed       	ldi	r16, 0xDF	; 223
    1ed0:	13 e2       	ldi	r17, 0x23	; 35
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    1ed2:	80 e0       	ldi	r24, 0x00	; 0
    1ed4:	90 e0       	ldi	r25, 0x00	; 0
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1ed6:	0f 2e       	mov	r0, r31
    1ed8:	f9 e0       	ldi	r31, 0x09	; 9
    1eda:	2f 2e       	mov	r2, r31
    1edc:	33 24       	eor	r3, r3
    1ede:	f0 2d       	mov	r31, r0
    1ee0:	8b 83       	std	Y+3, r24	; 0x03
    1ee2:	9c 83       	std	Y+4, r25	; 0x04
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    1ee4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ee6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ee8:	63 e0       	ldi	r22, 0x03	; 3
    1eea:	70 e0       	ldi	r23, 0x00	; 0
    1eec:	0e 94 a3 3a 	call	0x7546	; 0x7546 <__udivmodhi4>
    1ef0:	9c 01       	movw	r18, r24
    1ef2:	e8 e3       	ldi	r30, 0x38	; 56
    1ef4:	f1 e2       	ldi	r31, 0x21	; 33
    1ef6:	e8 0f       	add	r30, r24
    1ef8:	f9 1f       	adc	r31, r25
    1efa:	90 81       	ld	r25, Z
	checksumADC[1] += SPIBuffer[1];
	checksumADC[2] += SPIBuffer[2];
}

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    1efc:	a8 01       	movw	r20, r16
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    1efe:	d8 01       	movw	r26, r16
    1f00:	8c 91       	ld	r24, X
    1f02:	98 0f       	add	r25, r24
    1f04:	90 83       	st	Z, r25
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    1f06:	21 15       	cp	r18, r1
    1f08:	31 05       	cpc	r19, r1
    1f0a:	19 f5       	brne	.+70     	; 0x1f52 <calcChecksumFRAM+0x17c>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    1f0c:	88 23       	and	r24, r24
    1f0e:	6c f4       	brge	.+26     	; 0x1f2a <calcChecksumFRAM+0x154>
    1f10:	e0 91 63 50 	lds	r30, 0x5063
    1f14:	f0 91 64 50 	lds	r31, 0x5064
    1f18:	10 82       	st	Z, r1
    1f1a:	11 82       	std	Z+1, r1	; 0x01
    1f1c:	12 82       	std	Z+2, r1	; 0x02
    1f1e:	93 82       	std	Z+3, r9	; 0x03
    1f20:	94 82       	std	Z+4, r9	; 0x04
    1f22:	95 82       	std	Z+5, r9	; 0x05
    1f24:	96 82       	std	Z+6, r9	; 0x06
    1f26:	97 82       	std	Z+7, r9	; 0x07
    1f28:	0c c0       	rjmp	.+24     	; 0x1f42 <calcChecksumFRAM+0x16c>
				else *temp64 = 0x0000000000000000;
    1f2a:	e0 91 63 50 	lds	r30, 0x5063
    1f2e:	f0 91 64 50 	lds	r31, 0x5064
    1f32:	10 82       	st	Z, r1
    1f34:	11 82       	std	Z+1, r1	; 0x01
    1f36:	12 82       	std	Z+2, r1	; 0x02
    1f38:	13 82       	std	Z+3, r1	; 0x03
    1f3a:	14 82       	std	Z+4, r1	; 0x04
    1f3c:	15 82       	std	Z+5, r1	; 0x05
    1f3e:	16 82       	std	Z+6, r1	; 0x06
    1f40:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    1f42:	fa 01       	movw	r30, r20
    1f44:	80 81       	ld	r24, Z
    1f46:	e0 91 63 50 	lds	r30, 0x5063
    1f4a:	f0 91 64 50 	lds	r31, 0x5064
    1f4e:	82 83       	std	Z+2, r24	; 0x02
    1f50:	10 c0       	rjmp	.+32     	; 0x1f72 <calcChecksumFRAM+0x19c>
			} else if(k%3 == 1) {
    1f52:	21 30       	cpi	r18, 0x01	; 1
    1f54:	31 05       	cpc	r19, r1
    1f56:	31 f4       	brne	.+12     	; 0x1f64 <calcChecksumFRAM+0x18e>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    1f58:	e0 91 63 50 	lds	r30, 0x5063
    1f5c:	f0 91 64 50 	lds	r31, 0x5064
    1f60:	81 83       	std	Z+1, r24	; 0x01
    1f62:	07 c0       	rjmp	.+14     	; 0x1f72 <calcChecksumFRAM+0x19c>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    1f64:	e0 91 63 50 	lds	r30, 0x5063
    1f68:	f0 91 64 50 	lds	r31, 0x5064
    1f6c:	d8 01       	movw	r26, r16
    1f6e:	8c 91       	ld	r24, X
    1f70:	80 83       	st	Z, r24
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1f72:	8b 81       	ldd	r24, Y+3	; 0x03
    1f74:	9c 81       	ldd	r25, Y+4	; 0x04
    1f76:	b1 01       	movw	r22, r2
    1f78:	0e 94 a3 3a 	call	0x7546	; 0x7546 <__udivmodhi4>
    1f7c:	82 30       	cpi	r24, 0x02	; 2
    1f7e:	91 05       	cpc	r25, r1
    1f80:	09 f0       	breq	.+2      	; 0x1f84 <calcChecksumFRAM+0x1ae>
    1f82:	76 c0       	rjmp	.+236    	; 0x2070 <calcChecksumFRAM+0x29a>
    1f84:	f5 01       	movw	r30, r10
    1f86:	60 81       	ld	r22, Z
    1f88:	51 81       	ldd	r21, Z+1	; 0x01
    1f8a:	42 81       	ldd	r20, Z+2	; 0x02
    1f8c:	33 81       	ldd	r19, Z+3	; 0x03
    1f8e:	24 81       	ldd	r18, Z+4	; 0x04
    1f90:	95 81       	ldd	r25, Z+5	; 0x05
    1f92:	86 81       	ldd	r24, Z+6	; 0x06
    1f94:	47 80       	ldd	r4, Z+7	; 0x07
    1f96:	e0 91 63 50 	lds	r30, 0x5063
    1f9a:	f0 91 64 50 	lds	r31, 0x5064
    1f9e:	70 81       	ld	r23, Z
    1fa0:	a1 81       	ldd	r26, Z+1	; 0x01
    1fa2:	b2 81       	ldd	r27, Z+2	; 0x02
    1fa4:	83 80       	ldd	r8, Z+3	; 0x03
    1fa6:	74 80       	ldd	r7, Z+4	; 0x04
    1fa8:	65 80       	ldd	r6, Z+5	; 0x05
    1faa:	56 80       	ldd	r5, Z+6	; 0x06
    1fac:	e7 81       	ldd	r30, Z+7	; 0x07
    1fae:	76 0f       	add	r23, r22
    1fb0:	f1 e0       	ldi	r31, 0x01	; 1
    1fb2:	76 17       	cp	r23, r22
    1fb4:	08 f0       	brcs	.+2      	; 0x1fb8 <calcChecksumFRAM+0x1e2>
    1fb6:	f0 e0       	ldi	r31, 0x00	; 0
    1fb8:	a5 0f       	add	r26, r21
    1fba:	61 e0       	ldi	r22, 0x01	; 1
    1fbc:	a5 17       	cp	r26, r21
    1fbe:	08 f0       	brcs	.+2      	; 0x1fc2 <calcChecksumFRAM+0x1ec>
    1fc0:	60 e0       	ldi	r22, 0x00	; 0
    1fc2:	fa 0f       	add	r31, r26
    1fc4:	51 e0       	ldi	r21, 0x01	; 1
    1fc6:	fa 17       	cp	r31, r26
    1fc8:	08 f0       	brcs	.+2      	; 0x1fcc <calcChecksumFRAM+0x1f6>
    1fca:	50 e0       	ldi	r21, 0x00	; 0
    1fcc:	65 2b       	or	r22, r21
    1fce:	b4 0f       	add	r27, r20
    1fd0:	51 e0       	ldi	r21, 0x01	; 1
    1fd2:	b4 17       	cp	r27, r20
    1fd4:	08 f0       	brcs	.+2      	; 0x1fd8 <calcChecksumFRAM+0x202>
    1fd6:	50 e0       	ldi	r21, 0x00	; 0
    1fd8:	6b 0f       	add	r22, r27
    1fda:	41 e0       	ldi	r20, 0x01	; 1
    1fdc:	6b 17       	cp	r22, r27
    1fde:	08 f0       	brcs	.+2      	; 0x1fe2 <calcChecksumFRAM+0x20c>
    1fe0:	40 e0       	ldi	r20, 0x00	; 0
    1fe2:	54 2b       	or	r21, r20
    1fe4:	83 0e       	add	r8, r19
    1fe6:	41 e0       	ldi	r20, 0x01	; 1
    1fe8:	83 16       	cp	r8, r19
    1fea:	08 f0       	brcs	.+2      	; 0x1fee <calcChecksumFRAM+0x218>
    1fec:	40 e0       	ldi	r20, 0x00	; 0
    1fee:	58 0d       	add	r21, r8
    1ff0:	31 e0       	ldi	r19, 0x01	; 1
    1ff2:	58 15       	cp	r21, r8
    1ff4:	08 f0       	brcs	.+2      	; 0x1ff8 <calcChecksumFRAM+0x222>
    1ff6:	30 e0       	ldi	r19, 0x00	; 0
    1ff8:	43 2b       	or	r20, r19
    1ffa:	72 0e       	add	r7, r18
    1ffc:	31 e0       	ldi	r19, 0x01	; 1
    1ffe:	72 16       	cp	r7, r18
    2000:	08 f0       	brcs	.+2      	; 0x2004 <calcChecksumFRAM+0x22e>
    2002:	30 e0       	ldi	r19, 0x00	; 0
    2004:	47 0d       	add	r20, r7
    2006:	21 e0       	ldi	r18, 0x01	; 1
    2008:	47 15       	cp	r20, r7
    200a:	08 f0       	brcs	.+2      	; 0x200e <calcChecksumFRAM+0x238>
    200c:	20 e0       	ldi	r18, 0x00	; 0
    200e:	32 2b       	or	r19, r18
    2010:	69 0e       	add	r6, r25
    2012:	21 e0       	ldi	r18, 0x01	; 1
    2014:	69 16       	cp	r6, r25
    2016:	08 f0       	brcs	.+2      	; 0x201a <calcChecksumFRAM+0x244>
    2018:	20 e0       	ldi	r18, 0x00	; 0
    201a:	36 0d       	add	r19, r6
    201c:	91 e0       	ldi	r25, 0x01	; 1
    201e:	36 15       	cp	r19, r6
    2020:	08 f0       	brcs	.+2      	; 0x2024 <calcChecksumFRAM+0x24e>
    2022:	90 e0       	ldi	r25, 0x00	; 0
    2024:	29 2b       	or	r18, r25
    2026:	58 0e       	add	r5, r24
    2028:	91 e0       	ldi	r25, 0x01	; 1
    202a:	58 16       	cp	r5, r24
    202c:	08 f0       	brcs	.+2      	; 0x2030 <calcChecksumFRAM+0x25a>
    202e:	90 e0       	ldi	r25, 0x00	; 0
    2030:	25 0d       	add	r18, r5
    2032:	81 e0       	ldi	r24, 0x01	; 1
    2034:	25 15       	cp	r18, r5
    2036:	08 f0       	brcs	.+2      	; 0x203a <calcChecksumFRAM+0x264>
    2038:	80 e0       	ldi	r24, 0x00	; 0
    203a:	98 2b       	or	r25, r24
    203c:	e4 0d       	add	r30, r4
    203e:	9e 0f       	add	r25, r30
    2040:	d5 01       	movw	r26, r10
    2042:	7c 93       	st	X, r23
    2044:	11 96       	adiw	r26, 0x01	; 1
    2046:	fc 93       	st	X, r31
    2048:	11 97       	sbiw	r26, 0x01	; 1
    204a:	12 96       	adiw	r26, 0x02	; 2
    204c:	6c 93       	st	X, r22
    204e:	12 97       	sbiw	r26, 0x02	; 2
    2050:	13 96       	adiw	r26, 0x03	; 3
    2052:	5c 93       	st	X, r21
    2054:	13 97       	sbiw	r26, 0x03	; 3
    2056:	14 96       	adiw	r26, 0x04	; 4
    2058:	4c 93       	st	X, r20
    205a:	14 97       	sbiw	r26, 0x04	; 4
    205c:	15 96       	adiw	r26, 0x05	; 5
    205e:	3c 93       	st	X, r19
    2060:	15 97       	sbiw	r26, 0x05	; 5
    2062:	16 96       	adiw	r26, 0x06	; 6
    2064:	2c 93       	st	X, r18
    2066:	16 97       	sbiw	r26, 0x06	; 6
    2068:	17 96       	adiw	r26, 0x07	; 7
    206a:	9c 93       	st	X, r25
    206c:	17 97       	sbiw	r26, 0x07	; 7
    206e:	f3 c0       	rjmp	.+486    	; 0x2256 <calcChecksumFRAM+0x480>
			if(k%9 == 5) sumFRAM[1] += *temp64;
    2070:	85 30       	cpi	r24, 0x05	; 5
    2072:	91 05       	cpc	r25, r1
    2074:	09 f0       	breq	.+2      	; 0x2078 <calcChecksumFRAM+0x2a2>
    2076:	76 c0       	rjmp	.+236    	; 0x2164 <calcChecksumFRAM+0x38e>
    2078:	f6 01       	movw	r30, r12
    207a:	60 81       	ld	r22, Z
    207c:	51 81       	ldd	r21, Z+1	; 0x01
    207e:	42 81       	ldd	r20, Z+2	; 0x02
    2080:	33 81       	ldd	r19, Z+3	; 0x03
    2082:	24 81       	ldd	r18, Z+4	; 0x04
    2084:	95 81       	ldd	r25, Z+5	; 0x05
    2086:	86 81       	ldd	r24, Z+6	; 0x06
    2088:	47 80       	ldd	r4, Z+7	; 0x07
    208a:	e0 91 63 50 	lds	r30, 0x5063
    208e:	f0 91 64 50 	lds	r31, 0x5064
    2092:	70 81       	ld	r23, Z
    2094:	a1 81       	ldd	r26, Z+1	; 0x01
    2096:	b2 81       	ldd	r27, Z+2	; 0x02
    2098:	83 80       	ldd	r8, Z+3	; 0x03
    209a:	74 80       	ldd	r7, Z+4	; 0x04
    209c:	65 80       	ldd	r6, Z+5	; 0x05
    209e:	56 80       	ldd	r5, Z+6	; 0x06
    20a0:	e7 81       	ldd	r30, Z+7	; 0x07
    20a2:	76 0f       	add	r23, r22
    20a4:	f1 e0       	ldi	r31, 0x01	; 1
    20a6:	76 17       	cp	r23, r22
    20a8:	08 f0       	brcs	.+2      	; 0x20ac <calcChecksumFRAM+0x2d6>
    20aa:	f0 e0       	ldi	r31, 0x00	; 0
    20ac:	a5 0f       	add	r26, r21
    20ae:	61 e0       	ldi	r22, 0x01	; 1
    20b0:	a5 17       	cp	r26, r21
    20b2:	08 f0       	brcs	.+2      	; 0x20b6 <calcChecksumFRAM+0x2e0>
    20b4:	60 e0       	ldi	r22, 0x00	; 0
    20b6:	fa 0f       	add	r31, r26
    20b8:	51 e0       	ldi	r21, 0x01	; 1
    20ba:	fa 17       	cp	r31, r26
    20bc:	08 f0       	brcs	.+2      	; 0x20c0 <calcChecksumFRAM+0x2ea>
    20be:	50 e0       	ldi	r21, 0x00	; 0
    20c0:	65 2b       	or	r22, r21
    20c2:	b4 0f       	add	r27, r20
    20c4:	51 e0       	ldi	r21, 0x01	; 1
    20c6:	b4 17       	cp	r27, r20
    20c8:	08 f0       	brcs	.+2      	; 0x20cc <calcChecksumFRAM+0x2f6>
    20ca:	50 e0       	ldi	r21, 0x00	; 0
    20cc:	6b 0f       	add	r22, r27
    20ce:	41 e0       	ldi	r20, 0x01	; 1
    20d0:	6b 17       	cp	r22, r27
    20d2:	08 f0       	brcs	.+2      	; 0x20d6 <calcChecksumFRAM+0x300>
    20d4:	40 e0       	ldi	r20, 0x00	; 0
    20d6:	54 2b       	or	r21, r20
    20d8:	83 0e       	add	r8, r19
    20da:	41 e0       	ldi	r20, 0x01	; 1
    20dc:	83 16       	cp	r8, r19
    20de:	08 f0       	brcs	.+2      	; 0x20e2 <calcChecksumFRAM+0x30c>
    20e0:	40 e0       	ldi	r20, 0x00	; 0
    20e2:	58 0d       	add	r21, r8
    20e4:	31 e0       	ldi	r19, 0x01	; 1
    20e6:	58 15       	cp	r21, r8
    20e8:	08 f0       	brcs	.+2      	; 0x20ec <calcChecksumFRAM+0x316>
    20ea:	30 e0       	ldi	r19, 0x00	; 0
    20ec:	43 2b       	or	r20, r19
    20ee:	72 0e       	add	r7, r18
    20f0:	31 e0       	ldi	r19, 0x01	; 1
    20f2:	72 16       	cp	r7, r18
    20f4:	08 f0       	brcs	.+2      	; 0x20f8 <calcChecksumFRAM+0x322>
    20f6:	30 e0       	ldi	r19, 0x00	; 0
    20f8:	47 0d       	add	r20, r7
    20fa:	21 e0       	ldi	r18, 0x01	; 1
    20fc:	47 15       	cp	r20, r7
    20fe:	08 f0       	brcs	.+2      	; 0x2102 <calcChecksumFRAM+0x32c>
    2100:	20 e0       	ldi	r18, 0x00	; 0
    2102:	32 2b       	or	r19, r18
    2104:	69 0e       	add	r6, r25
    2106:	21 e0       	ldi	r18, 0x01	; 1
    2108:	69 16       	cp	r6, r25
    210a:	08 f0       	brcs	.+2      	; 0x210e <calcChecksumFRAM+0x338>
    210c:	20 e0       	ldi	r18, 0x00	; 0
    210e:	36 0d       	add	r19, r6
    2110:	91 e0       	ldi	r25, 0x01	; 1
    2112:	36 15       	cp	r19, r6
    2114:	08 f0       	brcs	.+2      	; 0x2118 <calcChecksumFRAM+0x342>
    2116:	90 e0       	ldi	r25, 0x00	; 0
    2118:	29 2b       	or	r18, r25
    211a:	58 0e       	add	r5, r24
    211c:	91 e0       	ldi	r25, 0x01	; 1
    211e:	58 16       	cp	r5, r24
    2120:	08 f0       	brcs	.+2      	; 0x2124 <calcChecksumFRAM+0x34e>
    2122:	90 e0       	ldi	r25, 0x00	; 0
    2124:	25 0d       	add	r18, r5
    2126:	81 e0       	ldi	r24, 0x01	; 1
    2128:	25 15       	cp	r18, r5
    212a:	08 f0       	brcs	.+2      	; 0x212e <calcChecksumFRAM+0x358>
    212c:	80 e0       	ldi	r24, 0x00	; 0
    212e:	98 2b       	or	r25, r24
    2130:	e4 0d       	add	r30, r4
    2132:	9e 0f       	add	r25, r30
    2134:	d6 01       	movw	r26, r12
    2136:	7c 93       	st	X, r23
    2138:	11 96       	adiw	r26, 0x01	; 1
    213a:	fc 93       	st	X, r31
    213c:	11 97       	sbiw	r26, 0x01	; 1
    213e:	12 96       	adiw	r26, 0x02	; 2
    2140:	6c 93       	st	X, r22
    2142:	12 97       	sbiw	r26, 0x02	; 2
    2144:	13 96       	adiw	r26, 0x03	; 3
    2146:	5c 93       	st	X, r21
    2148:	13 97       	sbiw	r26, 0x03	; 3
    214a:	14 96       	adiw	r26, 0x04	; 4
    214c:	4c 93       	st	X, r20
    214e:	14 97       	sbiw	r26, 0x04	; 4
    2150:	15 96       	adiw	r26, 0x05	; 5
    2152:	3c 93       	st	X, r19
    2154:	15 97       	sbiw	r26, 0x05	; 5
    2156:	16 96       	adiw	r26, 0x06	; 6
    2158:	2c 93       	st	X, r18
    215a:	16 97       	sbiw	r26, 0x06	; 6
    215c:	17 96       	adiw	r26, 0x07	; 7
    215e:	9c 93       	st	X, r25
    2160:	17 97       	sbiw	r26, 0x07	; 7
    2162:	79 c0       	rjmp	.+242    	; 0x2256 <calcChecksumFRAM+0x480>
			if(k%9 == 8) sumFRAM[2] += *temp64;
    2164:	88 30       	cpi	r24, 0x08	; 8
    2166:	91 05       	cpc	r25, r1
    2168:	09 f0       	breq	.+2      	; 0x216c <calcChecksumFRAM+0x396>
    216a:	75 c0       	rjmp	.+234    	; 0x2256 <calcChecksumFRAM+0x480>
    216c:	f7 01       	movw	r30, r14
    216e:	60 81       	ld	r22, Z
    2170:	51 81       	ldd	r21, Z+1	; 0x01
    2172:	42 81       	ldd	r20, Z+2	; 0x02
    2174:	33 81       	ldd	r19, Z+3	; 0x03
    2176:	24 81       	ldd	r18, Z+4	; 0x04
    2178:	95 81       	ldd	r25, Z+5	; 0x05
    217a:	86 81       	ldd	r24, Z+6	; 0x06
    217c:	47 80       	ldd	r4, Z+7	; 0x07
    217e:	e0 91 63 50 	lds	r30, 0x5063
    2182:	f0 91 64 50 	lds	r31, 0x5064
    2186:	70 81       	ld	r23, Z
    2188:	a1 81       	ldd	r26, Z+1	; 0x01
    218a:	b2 81       	ldd	r27, Z+2	; 0x02
    218c:	83 80       	ldd	r8, Z+3	; 0x03
    218e:	74 80       	ldd	r7, Z+4	; 0x04
    2190:	65 80       	ldd	r6, Z+5	; 0x05
    2192:	56 80       	ldd	r5, Z+6	; 0x06
    2194:	e7 81       	ldd	r30, Z+7	; 0x07
    2196:	76 0f       	add	r23, r22
    2198:	f1 e0       	ldi	r31, 0x01	; 1
    219a:	76 17       	cp	r23, r22
    219c:	08 f0       	brcs	.+2      	; 0x21a0 <calcChecksumFRAM+0x3ca>
    219e:	f0 e0       	ldi	r31, 0x00	; 0
    21a0:	a5 0f       	add	r26, r21
    21a2:	61 e0       	ldi	r22, 0x01	; 1
    21a4:	a5 17       	cp	r26, r21
    21a6:	08 f0       	brcs	.+2      	; 0x21aa <calcChecksumFRAM+0x3d4>
    21a8:	60 e0       	ldi	r22, 0x00	; 0
    21aa:	fa 0f       	add	r31, r26
    21ac:	51 e0       	ldi	r21, 0x01	; 1
    21ae:	fa 17       	cp	r31, r26
    21b0:	08 f0       	brcs	.+2      	; 0x21b4 <calcChecksumFRAM+0x3de>
    21b2:	50 e0       	ldi	r21, 0x00	; 0
    21b4:	65 2b       	or	r22, r21
    21b6:	b4 0f       	add	r27, r20
    21b8:	51 e0       	ldi	r21, 0x01	; 1
    21ba:	b4 17       	cp	r27, r20
    21bc:	08 f0       	brcs	.+2      	; 0x21c0 <calcChecksumFRAM+0x3ea>
    21be:	50 e0       	ldi	r21, 0x00	; 0
    21c0:	6b 0f       	add	r22, r27
    21c2:	41 e0       	ldi	r20, 0x01	; 1
    21c4:	6b 17       	cp	r22, r27
    21c6:	08 f0       	brcs	.+2      	; 0x21ca <calcChecksumFRAM+0x3f4>
    21c8:	40 e0       	ldi	r20, 0x00	; 0
    21ca:	54 2b       	or	r21, r20
    21cc:	83 0e       	add	r8, r19
    21ce:	41 e0       	ldi	r20, 0x01	; 1
    21d0:	83 16       	cp	r8, r19
    21d2:	08 f0       	brcs	.+2      	; 0x21d6 <calcChecksumFRAM+0x400>
    21d4:	40 e0       	ldi	r20, 0x00	; 0
    21d6:	58 0d       	add	r21, r8
    21d8:	31 e0       	ldi	r19, 0x01	; 1
    21da:	58 15       	cp	r21, r8
    21dc:	08 f0       	brcs	.+2      	; 0x21e0 <calcChecksumFRAM+0x40a>
    21de:	30 e0       	ldi	r19, 0x00	; 0
    21e0:	43 2b       	or	r20, r19
    21e2:	72 0e       	add	r7, r18
    21e4:	31 e0       	ldi	r19, 0x01	; 1
    21e6:	72 16       	cp	r7, r18
    21e8:	08 f0       	brcs	.+2      	; 0x21ec <calcChecksumFRAM+0x416>
    21ea:	30 e0       	ldi	r19, 0x00	; 0
    21ec:	47 0d       	add	r20, r7
    21ee:	21 e0       	ldi	r18, 0x01	; 1
    21f0:	47 15       	cp	r20, r7
    21f2:	08 f0       	brcs	.+2      	; 0x21f6 <calcChecksumFRAM+0x420>
    21f4:	20 e0       	ldi	r18, 0x00	; 0
    21f6:	32 2b       	or	r19, r18
    21f8:	69 0e       	add	r6, r25
    21fa:	21 e0       	ldi	r18, 0x01	; 1
    21fc:	69 16       	cp	r6, r25
    21fe:	08 f0       	brcs	.+2      	; 0x2202 <calcChecksumFRAM+0x42c>
    2200:	20 e0       	ldi	r18, 0x00	; 0
    2202:	36 0d       	add	r19, r6
    2204:	91 e0       	ldi	r25, 0x01	; 1
    2206:	36 15       	cp	r19, r6
    2208:	08 f0       	brcs	.+2      	; 0x220c <calcChecksumFRAM+0x436>
    220a:	90 e0       	ldi	r25, 0x00	; 0
    220c:	29 2b       	or	r18, r25
    220e:	58 0e       	add	r5, r24
    2210:	91 e0       	ldi	r25, 0x01	; 1
    2212:	58 16       	cp	r5, r24
    2214:	08 f0       	brcs	.+2      	; 0x2218 <calcChecksumFRAM+0x442>
    2216:	90 e0       	ldi	r25, 0x00	; 0
    2218:	25 0d       	add	r18, r5
    221a:	81 e0       	ldi	r24, 0x01	; 1
    221c:	25 15       	cp	r18, r5
    221e:	08 f0       	brcs	.+2      	; 0x2222 <calcChecksumFRAM+0x44c>
    2220:	80 e0       	ldi	r24, 0x00	; 0
    2222:	98 2b       	or	r25, r24
    2224:	e4 0d       	add	r30, r4
    2226:	9e 0f       	add	r25, r30
    2228:	d7 01       	movw	r26, r14
    222a:	7c 93       	st	X, r23
    222c:	11 96       	adiw	r26, 0x01	; 1
    222e:	fc 93       	st	X, r31
    2230:	11 97       	sbiw	r26, 0x01	; 1
    2232:	12 96       	adiw	r26, 0x02	; 2
    2234:	6c 93       	st	X, r22
    2236:	12 97       	sbiw	r26, 0x02	; 2
    2238:	13 96       	adiw	r26, 0x03	; 3
    223a:	5c 93       	st	X, r21
    223c:	13 97       	sbiw	r26, 0x03	; 3
    223e:	14 96       	adiw	r26, 0x04	; 4
    2240:	4c 93       	st	X, r20
    2242:	14 97       	sbiw	r26, 0x04	; 4
    2244:	15 96       	adiw	r26, 0x05	; 5
    2246:	3c 93       	st	X, r19
    2248:	15 97       	sbiw	r26, 0x05	; 5
    224a:	16 96       	adiw	r26, 0x06	; 6
    224c:	2c 93       	st	X, r18
    224e:	16 97       	sbiw	r26, 0x06	; 6
    2250:	17 96       	adiw	r26, 0x07	; 7
    2252:	9c 93       	st	X, r25
    2254:	17 97       	sbiw	r26, 0x07	; 7
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    2256:	eb 81       	ldd	r30, Y+3	; 0x03
    2258:	fc 81       	ldd	r31, Y+4	; 0x04
    225a:	31 96       	adiw	r30, 0x01	; 1
    225c:	eb 83       	std	Y+3, r30	; 0x03
    225e:	fc 83       	std	Y+4, r31	; 0x04
    2260:	0f 5f       	subi	r16, 0xFF	; 255
    2262:	1f 4f       	sbci	r17, 0xFF	; 255
    2264:	2c e1       	ldi	r18, 0x1C	; 28
    2266:	e1 37       	cpi	r30, 0x71	; 113
    2268:	f2 07       	cpc	r31, r18
    226a:	09 f0       	breq	.+2      	; 0x226e <calcChecksumFRAM+0x498>
    226c:	3b ce       	rjmp	.-906    	; 0x1ee4 <calcChecksumFRAM+0x10e>
    226e:	89 81       	ldd	r24, Y+1	; 0x01
    2270:	9a 81       	ldd	r25, Y+2	; 0x02
    2272:	01 97       	sbiw	r24, 0x01	; 1
    2274:	89 83       	std	Y+1, r24	; 0x01
    2276:	9a 83       	std	Y+2, r25	; 0x02
//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    2278:	00 97       	sbiw	r24, 0x00	; 0
    227a:	09 f0       	breq	.+2      	; 0x227e <calcChecksumFRAM+0x4a8>
    227c:	1a ce       	rjmp	.-972    	; 0x1eb2 <calcChecksumFRAM+0xdc>
			
		}
		
	}
	
}
    227e:	24 96       	adiw	r28, 0x04	; 4
    2280:	cd bf       	out	0x3d, r28	; 61
    2282:	de bf       	out	0x3e, r29	; 62
    2284:	df 91       	pop	r29
    2286:	cf 91       	pop	r28
    2288:	1f 91       	pop	r17
    228a:	0f 91       	pop	r16
    228c:	ff 90       	pop	r15
    228e:	ef 90       	pop	r14
    2290:	df 90       	pop	r13
    2292:	cf 90       	pop	r12
    2294:	bf 90       	pop	r11
    2296:	af 90       	pop	r10
    2298:	9f 90       	pop	r9
    229a:	8f 90       	pop	r8
    229c:	7f 90       	pop	r7
    229e:	6f 90       	pop	r6
    22a0:	5f 90       	pop	r5
    22a2:	4f 90       	pop	r4
    22a4:	3f 90       	pop	r3
    22a6:	2f 90       	pop	r2
    22a8:	08 95       	ret

000022aa <FRAMWriteKnowns>:

//test function for FRAM
void FRAMWriteKnowns() {
    22aa:	2f 92       	push	r2
    22ac:	3f 92       	push	r3
    22ae:	4f 92       	push	r4
    22b0:	5f 92       	push	r5
    22b2:	6f 92       	push	r6
    22b4:	7f 92       	push	r7
    22b6:	8f 92       	push	r8
    22b8:	9f 92       	push	r9
    22ba:	af 92       	push	r10
    22bc:	bf 92       	push	r11
    22be:	cf 92       	push	r12
    22c0:	df 92       	push	r13
    22c2:	ef 92       	push	r14
    22c4:	ff 92       	push	r15
    22c6:	0f 93       	push	r16
    22c8:	1f 93       	push	r17
    22ca:	cf 93       	push	r28
    22cc:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    22ce:	10 92 57 40 	sts	0x4057, r1
    22d2:	10 92 58 40 	sts	0x4058, r1
	sampleCount = 0;
    22d6:	10 92 74 50 	sts	0x5074, r1
    22da:	10 92 75 50 	sts	0x5075, r1
    22de:	10 92 76 50 	sts	0x5076, r1
    22e2:	10 92 77 50 	sts	0x5077, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    22e6:	8d e3       	ldi	r24, 0x3D	; 61
    22e8:	91 e2       	ldi	r25, 0x21	; 33
    22ea:	10 92 3d 21 	sts	0x213D, r1
    22ee:	fc 01       	movw	r30, r24
    22f0:	31 97       	sbiw	r30, 0x01	; 1
    22f2:	10 82       	st	Z, r1
    22f4:	02 97       	sbiw	r24, 0x02	; 2
    22f6:	dc 01       	movw	r26, r24
    22f8:	1c 92       	st	X, r1
	
	ADCPower(TRUE);
    22fa:	81 e0       	ldi	r24, 0x01	; 1
    22fc:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    2300:	84 e0       	ldi	r24, 0x04	; 4
    2302:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2306:	80 ed       	ldi	r24, 0xD0	; 208
    2308:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    230c:	8d e0       	ldi	r24, 0x0D	; 13
    230e:	80 93 65 50 	sts	0x5065, r24
	SPIBuffer[1] = 0xF3;
    2312:	83 ef       	ldi	r24, 0xF3	; 243
    2314:	80 93 66 50 	sts	0x5066, r24
	SPIBuffer[2] = 0x57;
    2318:	87 e5       	ldi	r24, 0x57	; 87
    231a:	80 93 67 50 	sts	0x5067, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    231e:	80 91 74 50 	lds	r24, 0x5074
    2322:	90 91 75 50 	lds	r25, 0x5075
    2326:	a0 91 76 50 	lds	r26, 0x5076
    232a:	b0 91 77 50 	lds	r27, 0x5077
    232e:	83 35       	cpi	r24, 0x53	; 83
    2330:	e5 e5       	ldi	r30, 0x55	; 85
    2332:	9e 07       	cpc	r25, r30
    2334:	e0 e0       	ldi	r30, 0x00	; 0
    2336:	ae 07       	cpc	r26, r30
    2338:	e0 e0       	ldi	r30, 0x00	; 0
    233a:	be 07       	cpc	r27, r30
    233c:	08 f0       	brcs	.+2      	; 0x2340 <FRAMWriteKnowns+0x96>
    233e:	cc c0       	rjmp	.+408    	; 0x24d8 <FRAMWriteKnowns+0x22e>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2340:	0f 2e       	mov	r0, r31
    2342:	f0 e4       	ldi	r31, 0x40	; 64
    2344:	ef 2e       	mov	r14, r31
    2346:	f6 e0       	ldi	r31, 0x06	; 6
    2348:	ff 2e       	mov	r15, r31
    234a:	f0 2d       	mov	r31, r0
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    234c:	40 e2       	ldi	r20, 0x20	; 32
    234e:	56 e0       	ldi	r21, 0x06	; 6
    2350:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    2352:	e0 ec       	ldi	r30, 0xC0	; 192
    2354:	f8 e0       	ldi	r31, 0x08	; 8
    2356:	0f 2e       	mov	r0, r31
    2358:	f6 e0       	ldi	r31, 0x06	; 6
    235a:	7f 2e       	mov	r7, r31
    235c:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    235e:	c1 e7       	ldi	r28, 0x71	; 113
    2360:	d0 e5       	ldi	r29, 0x50	; 80
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    2362:	66 24       	eor	r6, r6
    2364:	68 94       	set
    2366:	61 f8       	bld	r6, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2368:	0f 2e       	mov	r0, r31
    236a:	f7 e5       	ldi	r31, 0x57	; 87
    236c:	cf 2e       	mov	r12, r31
    236e:	f0 e4       	ldi	r31, 0x40	; 64
    2370:	df 2e       	mov	r13, r31
    2372:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    2374:	8e 01       	movw	r16, r28
    2376:	0c 50       	subi	r16, 0x0C	; 12
    2378:	10 40       	sbci	r17, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    237a:	0f 2e       	mov	r0, r31
    237c:	f5 ef       	ldi	r31, 0xF5	; 245
    237e:	4f 2e       	mov	r4, r31
    2380:	ff ef       	ldi	r31, 0xFF	; 255
    2382:	5f 2e       	mov	r5, r31
    2384:	f0 2d       	mov	r31, r0
    2386:	4c 0e       	add	r4, r28
    2388:	5d 1e       	adc	r5, r29
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    238a:	0f 2e       	mov	r0, r31
    238c:	f6 ef       	ldi	r31, 0xF6	; 246
    238e:	2f 2e       	mov	r2, r31
    2390:	ff ef       	ldi	r31, 0xFF	; 255
    2392:	3f 2e       	mov	r3, r31
    2394:	f0 2d       	mov	r31, r0
    2396:	2c 0e       	add	r2, r28
    2398:	3d 1e       	adc	r3, r29
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    239a:	6b e3       	ldi	r22, 0x3B	; 59
    239c:	71 e2       	ldi	r23, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    239e:	5b 01       	movw	r10, r22
    23a0:	08 94       	sec
    23a2:	a1 1c       	adc	r10, r1
    23a4:	b1 1c       	adc	r11, r1
		checksumADC[2] += SPIBuffer[2];
    23a6:	88 24       	eor	r8, r8
    23a8:	99 24       	eor	r9, r9
    23aa:	68 94       	set
    23ac:	81 f8       	bld	r8, 1
    23ae:	86 0e       	add	r8, r22
    23b0:	97 1e       	adc	r9, r23
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    23b2:	30 e1       	ldi	r19, 0x10	; 16
    23b4:	d7 01       	movw	r26, r14
    23b6:	16 96       	adiw	r26, 0x06	; 6
    23b8:	3c 93       	st	X, r19
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    23ba:	da 01       	movw	r26, r20
    23bc:	16 96       	adiw	r26, 0x06	; 6
    23be:	2c 93       	st	X, r18
    23c0:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    23c2:	00 00       	nop
		SPIC.DATA = FR_WREN;
    23c4:	73 82       	std	Z+3, r7	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    23c6:	82 81       	ldd	r24, Z+2	; 0x02
    23c8:	88 23       	and	r24, r24
    23ca:	ec f7       	brge	.-6      	; 0x23c6 <FRAMWriteKnowns+0x11c>
		SPIBuffer[12] = SPIC.DATA;
    23cc:	83 81       	ldd	r24, Z+3	; 0x03
    23ce:	88 83       	st	Y, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    23d0:	da 01       	movw	r26, r20
    23d2:	15 96       	adiw	r26, 0x05	; 5
    23d4:	2c 93       	st	X, r18
    23d6:	15 97       	sbiw	r26, 0x05	; 5
		nop(); // time for CS_FRAM to accept high signal
    23d8:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    23da:	16 96       	adiw	r26, 0x06	; 6
    23dc:	2c 93       	st	X, r18
    23de:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    23e0:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    23e2:	63 82       	std	Z+3, r6	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    23e4:	82 81       	ldd	r24, Z+2	; 0x02
    23e6:	88 23       	and	r24, r24
    23e8:	ec f7       	brge	.-6      	; 0x23e4 <FRAMWriteKnowns+0x13a>
		SPIBuffer[12] = SPIC.DATA;
    23ea:	83 81       	ldd	r24, Z+3	; 0x03
    23ec:	88 83       	st	Y, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    23ee:	d6 01       	movw	r26, r12
    23f0:	11 96       	adiw	r26, 0x01	; 1
    23f2:	8c 91       	ld	r24, X
    23f4:	11 97       	sbiw	r26, 0x01	; 1
    23f6:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    23f8:	82 81       	ldd	r24, Z+2	; 0x02
    23fa:	88 23       	and	r24, r24
    23fc:	ec f7       	brge	.-6      	; 0x23f8 <FRAMWriteKnowns+0x14e>
		SPIBuffer[12] = SPIC.DATA;
    23fe:	83 81       	ldd	r24, Z+3	; 0x03
    2400:	88 83       	st	Y, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2402:	d6 01       	movw	r26, r12
    2404:	8c 91       	ld	r24, X
    2406:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2408:	82 81       	ldd	r24, Z+2	; 0x02
    240a:	88 23       	and	r24, r24
    240c:	ec f7       	brge	.-6      	; 0x2408 <FRAMWriteKnowns+0x15e>
		SPIBuffer[12] = SPIC.DATA;
    240e:	83 81       	ldd	r24, Z+3	; 0x03
    2410:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[0];
    2412:	d8 01       	movw	r26, r16
    2414:	8c 91       	ld	r24, X
    2416:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2418:	82 81       	ldd	r24, Z+2	; 0x02
    241a:	88 23       	and	r24, r24
    241c:	ec f7       	brge	.-6      	; 0x2418 <FRAMWriteKnowns+0x16e>
		SPIBuffer[12] = SPIC.DATA;
    241e:	83 81       	ldd	r24, Z+3	; 0x03
    2420:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[1];
    2422:	d2 01       	movw	r26, r4
    2424:	8c 91       	ld	r24, X
    2426:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2428:	82 81       	ldd	r24, Z+2	; 0x02
    242a:	88 23       	and	r24, r24
    242c:	ec f7       	brge	.-6      	; 0x2428 <FRAMWriteKnowns+0x17e>
		SPIBuffer[12] = SPIC.DATA;
    242e:	83 81       	ldd	r24, Z+3	; 0x03
    2430:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[2];
    2432:	d1 01       	movw	r26, r2
    2434:	8c 91       	ld	r24, X
    2436:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2438:	82 81       	ldd	r24, Z+2	; 0x02
    243a:	88 23       	and	r24, r24
    243c:	ec f7       	brge	.-6      	; 0x2438 <FRAMWriteKnowns+0x18e>
		SPIBuffer[12] = SPIC.DATA;
    243e:	83 81       	ldd	r24, Z+3	; 0x03
    2440:	88 83       	st	Y, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2442:	da 01       	movw	r26, r20
    2444:	15 96       	adiw	r26, 0x05	; 5
    2446:	2c 93       	st	X, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2448:	30 e1       	ldi	r19, 0x10	; 16
    244a:	d7 01       	movw	r26, r14
    244c:	15 96       	adiw	r26, 0x05	; 5
    244e:	3c 93       	st	X, r19
		
		FRAMAddress +=3;
    2450:	80 91 57 40 	lds	r24, 0x4057
    2454:	90 91 58 40 	lds	r25, 0x4058
    2458:	03 96       	adiw	r24, 0x03	; 3
    245a:	80 93 57 40 	sts	0x4057, r24
    245e:	90 93 58 40 	sts	0x4058, r25
		checksumADC[0] += SPIBuffer[0];
    2462:	db 01       	movw	r26, r22
    2464:	8c 91       	ld	r24, X
    2466:	d8 01       	movw	r26, r16
    2468:	9c 91       	ld	r25, X
    246a:	89 0f       	add	r24, r25
    246c:	db 01       	movw	r26, r22
    246e:	8c 93       	st	X, r24
		checksumADC[1] += SPIBuffer[1];
    2470:	d5 01       	movw	r26, r10
    2472:	8c 91       	ld	r24, X
    2474:	a6 e6       	ldi	r26, 0x66	; 102
    2476:	b0 e5       	ldi	r27, 0x50	; 80
    2478:	9c 91       	ld	r25, X
    247a:	89 0f       	add	r24, r25
    247c:	d5 01       	movw	r26, r10
    247e:	8c 93       	st	X, r24
		checksumADC[2] += SPIBuffer[2];
    2480:	d4 01       	movw	r26, r8
    2482:	8c 91       	ld	r24, X
    2484:	a7 e6       	ldi	r26, 0x67	; 103
    2486:	b0 e5       	ldi	r27, 0x50	; 80
    2488:	9c 91       	ld	r25, X
    248a:	89 0f       	add	r24, r25
    248c:	d4 01       	movw	r26, r8
    248e:	8c 93       	st	X, r24
		
		sampleCount++;
    2490:	80 91 74 50 	lds	r24, 0x5074
    2494:	90 91 75 50 	lds	r25, 0x5075
    2498:	a0 91 76 50 	lds	r26, 0x5076
    249c:	b0 91 77 50 	lds	r27, 0x5077
    24a0:	01 96       	adiw	r24, 0x01	; 1
    24a2:	a1 1d       	adc	r26, r1
    24a4:	b1 1d       	adc	r27, r1
    24a6:	80 93 74 50 	sts	0x5074, r24
    24aa:	90 93 75 50 	sts	0x5075, r25
    24ae:	a0 93 76 50 	sts	0x5076, r26
    24b2:	b0 93 77 50 	sts	0x5077, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    24b6:	80 91 74 50 	lds	r24, 0x5074
    24ba:	90 91 75 50 	lds	r25, 0x5075
    24be:	a0 91 76 50 	lds	r26, 0x5076
    24c2:	b0 91 77 50 	lds	r27, 0x5077
    24c6:	83 35       	cpi	r24, 0x53	; 83
    24c8:	35 e5       	ldi	r19, 0x55	; 85
    24ca:	93 07       	cpc	r25, r19
    24cc:	30 e0       	ldi	r19, 0x00	; 0
    24ce:	a3 07       	cpc	r26, r19
    24d0:	30 e0       	ldi	r19, 0x00	; 0
    24d2:	b3 07       	cpc	r27, r19
    24d4:	08 f4       	brcc	.+2      	; 0x24d8 <FRAMWriteKnowns+0x22e>
    24d6:	6d cf       	rjmp	.-294    	; 0x23b2 <FRAMWriteKnowns+0x108>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    24d8:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <SPIDisable>
	ADCPower(FALSE);
    24dc:	80 e0       	ldi	r24, 0x00	; 0
    24de:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>
}
    24e2:	df 91       	pop	r29
    24e4:	cf 91       	pop	r28
    24e6:	1f 91       	pop	r17
    24e8:	0f 91       	pop	r16
    24ea:	ff 90       	pop	r15
    24ec:	ef 90       	pop	r14
    24ee:	df 90       	pop	r13
    24f0:	cf 90       	pop	r12
    24f2:	bf 90       	pop	r11
    24f4:	af 90       	pop	r10
    24f6:	9f 90       	pop	r9
    24f8:	8f 90       	pop	r8
    24fa:	7f 90       	pop	r7
    24fc:	6f 90       	pop	r6
    24fe:	5f 90       	pop	r5
    2500:	4f 90       	pop	r4
    2502:	3f 90       	pop	r3
    2504:	2f 90       	pop	r2
    2506:	08 95       	ret

00002508 <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    2508:	80 ff       	sbrs	r24, 0
    250a:	05 c0       	rjmp	.+10     	; 0x2516 <setADCInput+0xe>
    250c:	20 e4       	ldi	r18, 0x40	; 64
    250e:	e0 e0       	ldi	r30, 0x00	; 0
    2510:	f6 e0       	ldi	r31, 0x06	; 6
    2512:	25 83       	std	Z+5, r18	; 0x05
    2514:	04 c0       	rjmp	.+8      	; 0x251e <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    2516:	20 e4       	ldi	r18, 0x40	; 64
    2518:	e0 e0       	ldi	r30, 0x00	; 0
    251a:	f6 e0       	ldi	r31, 0x06	; 6
    251c:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    251e:	81 ff       	sbrs	r24, 1
    2520:	05 c0       	rjmp	.+10     	; 0x252c <setADCInput+0x24>
    2522:	22 e0       	ldi	r18, 0x02	; 2
    2524:	e0 e2       	ldi	r30, 0x20	; 32
    2526:	f6 e0       	ldi	r31, 0x06	; 6
    2528:	25 83       	std	Z+5, r18	; 0x05
    252a:	04 c0       	rjmp	.+8      	; 0x2534 <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    252c:	22 e0       	ldi	r18, 0x02	; 2
    252e:	e0 e2       	ldi	r30, 0x20	; 32
    2530:	f6 e0       	ldi	r31, 0x06	; 6
    2532:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    2534:	82 ff       	sbrs	r24, 2
    2536:	05 c0       	rjmp	.+10     	; 0x2542 <setADCInput+0x3a>
    2538:	84 e0       	ldi	r24, 0x04	; 4
    253a:	e0 e2       	ldi	r30, 0x20	; 32
    253c:	f6 e0       	ldi	r31, 0x06	; 6
    253e:	85 83       	std	Z+5, r24	; 0x05
    2540:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    2542:	84 e0       	ldi	r24, 0x04	; 4
    2544:	e0 e2       	ldi	r30, 0x20	; 32
    2546:	f6 e0       	ldi	r31, 0x06	; 6
    2548:	86 83       	std	Z+6, r24	; 0x06
    254a:	08 95       	ret

0000254c <CO_collectSeismic1Channel_ext>:
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray);
}

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    254c:	2f 92       	push	r2
    254e:	3f 92       	push	r3
    2550:	4f 92       	push	r4
    2552:	5f 92       	push	r5
    2554:	7f 92       	push	r7
    2556:	8f 92       	push	r8
    2558:	9f 92       	push	r9
    255a:	af 92       	push	r10
    255c:	bf 92       	push	r11
    255e:	cf 92       	push	r12
    2560:	df 92       	push	r13
    2562:	ef 92       	push	r14
    2564:	ff 92       	push	r15
    2566:	0f 93       	push	r16
    2568:	1f 93       	push	r17
    256a:	cf 93       	push	r28
    256c:	df 93       	push	r29
    256e:	cd b7       	in	r28, 0x3d	; 61
    2570:	de b7       	in	r29, 0x3e	; 62
    2572:	18 2f       	mov	r17, r24
    2574:	76 2e       	mov	r7, r22
    2576:	f4 2e       	mov	r15, r20
    2578:	19 01       	movw	r2, r18
	
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif
	
	ADC_BUFFER=DataArray;
    257a:	89 8d       	ldd	r24, Y+25	; 0x19
    257c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    257e:	80 93 72 50 	sts	0x5072, r24
    2582:	90 93 73 50 	sts	0x5073, r25
	ADC_Sampling_Finished = 0;
    2586:	10 92 cd 50 	sts	0x50CD, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    258a:	81 e0       	ldi	r24, 0x01	; 1
    258c:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2590:	81 2f       	mov	r24, r17
    2592:	6f 2d       	mov	r22, r15
    2594:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <set_ampGain>
	set_filter(filterConfig);
    2598:	87 2d       	mov	r24, r7
    259a:	0e 94 0c 04 	call	0x818	; 0x818 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    259e:	8e 2d       	mov	r24, r14
    25a0:	0e 94 e5 08 	call	0x11ca	; 0x11ca <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    25a4:	84 e0       	ldi	r24, 0x04	; 4
    25a6:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    25aa:	84 e5       	ldi	r24, 0x54	; 84
    25ac:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    25b0:	81 e0       	ldi	r24, 0x01	; 1
    25b2:	0e 94 39 07 	call	0xe72	; 0xe72 <enableADCMUX>
	setADCInput(channel);
    25b6:	81 2f       	mov	r24, r17
    25b8:	0e 94 84 12 	call	0x2508	; 0x2508 <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    25bc:	e0 ea       	ldi	r30, 0xA0	; 160
    25be:	f6 e0       	ldi	r31, 0x06	; 6
    25c0:	22 e0       	ldi	r18, 0x02	; 2
    25c2:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    25c4:	77 24       	eor	r7, r7
    25c6:	73 94       	inc	r7
    25c8:	72 82       	std	Z+2, r7	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    25ca:	0f 2e       	mov	r0, r31
    25cc:	f0 e8       	ldi	r31, 0x80	; 128
    25ce:	4f 2e       	mov	r4, r31
    25d0:	f1 e0       	ldi	r31, 0x01	; 1
    25d2:	5f 2e       	mov	r5, r31
    25d4:	f0 2d       	mov	r31, r0
    25d6:	88 e7       	ldi	r24, 0x78	; 120
    25d8:	d2 01       	movw	r26, r4
    25da:	8c 93       	st	X, r24

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    25dc:	e0 e0       	ldi	r30, 0x00	; 0
    25de:	f9 e0       	ldi	r31, 0x09	; 9
    25e0:	80 ef       	ldi	r24, 0xF0	; 240
    25e2:	81 83       	std	Z+1, r24	; 0x01
	TCD0.CCA = averagingPtA;
    25e4:	c0 a6       	lds	r28, 0xb0
    25e6:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    25e8:	a2 a6       	lds	r26, 0xb2
    25ea:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    25ec:	84 a6       	lds	r24, 0xb4
    25ee:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    25f0:	8d 89       	ldd	r24, Y+21	; 0x15
    25f2:	9e 89       	ldd	r25, Y+22	; 0x16
    25f4:	86 a7       	lds	r24, 0x76
    25f6:	97 a7       	lds	r25, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    25f8:	80 2f       	mov	r24, r16
    25fa:	90 e0       	ldi	r25, 0x00	; 0
    25fc:	01 97       	sbiw	r24, 0x01	; 1
    25fe:	86 a3       	lds	r24, 0x56
    2600:	97 a3       	lds	r25, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2602:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2604:	8f ef       	ldi	r24, 0xFF	; 255
    2606:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2608:	80 81       	ld	r24, Z
    260a:	80 7f       	andi	r24, 0xF0	; 240
    260c:	88 60       	ori	r24, 0x08	; 8
    260e:	80 83       	st	Z, r24

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    2610:	10 92 74 50 	sts	0x5074, r1
    2614:	10 92 75 50 	sts	0x5075, r1
    2618:	10 92 76 50 	sts	0x5076, r1
    261c:	10 92 77 50 	sts	0x5077, r1
	SPICount = 0;
    2620:	10 92 c6 50 	sts	0x50C6, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm;
    2624:	e0 ea       	ldi	r30, 0xA0	; 160
    2626:	f0 e0       	ldi	r31, 0x00	; 0
    2628:	82 81       	ldd	r24, Z+2	; 0x02
    262a:	87 60       	ori	r24, 0x07	; 7
    262c:	82 83       	std	Z+2, r24	; 0x02
	sei();
    262e:	78 94       	sei

	SPICS(TRUE);
    2630:	81 e0       	ldi	r24, 0x01	; 1
    2632:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2636:	80 e2       	ldi	r24, 0x20	; 32
    2638:	e0 e8       	ldi	r30, 0x80	; 128
    263a:	f6 e0       	ldi	r31, 0x06	; 6
    263c:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    263e:	00 e4       	ldi	r16, 0x40	; 64
    2640:	1a e0       	ldi	r17, 0x0A	; 10
    2642:	83 e2       	ldi	r24, 0x23	; 35
    2644:	f8 01       	movw	r30, r16
    2646:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2648:	61 01       	movw	r12, r2
    264a:	ee 24       	eor	r14, r14
    264c:	ff 24       	eor	r15, r15
    264e:	60 e8       	ldi	r22, 0x80	; 128
    2650:	74 e8       	ldi	r23, 0x84	; 132
    2652:	8e e1       	ldi	r24, 0x1E	; 30
    2654:	90 e0       	ldi	r25, 0x00	; 0
    2656:	a7 01       	movw	r20, r14
    2658:	96 01       	movw	r18, r12
    265a:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    265e:	d8 01       	movw	r26, r16
    2660:	96 96       	adiw	r26, 0x26	; 38
    2662:	2d 93       	st	X+, r18
    2664:	3c 93       	st	X, r19
    2666:	97 97       	sbiw	r26, 0x27	; 39
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2668:	60 e4       	ldi	r22, 0x40	; 64
    266a:	72 e4       	ldi	r23, 0x42	; 66
    266c:	8f e0       	ldi	r24, 0x0F	; 15
    266e:	90 e0       	ldi	r25, 0x00	; 0
    2670:	a7 01       	movw	r20, r14
    2672:	96 01       	movw	r18, r12
    2674:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    2678:	f8 01       	movw	r30, r16
    267a:	22 af       	sts	0x72, r18
    267c:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    267e:	e0 e4       	ldi	r30, 0x40	; 64
    2680:	f8 e0       	ldi	r31, 0x08	; 8
    2682:	8f 89       	ldd	r24, Y+23	; 0x17
    2684:	98 8d       	ldd	r25, Y+24	; 0x18
    2686:	86 a3       	lds	r24, 0x56
    2688:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    268a:	80 ed       	ldi	r24, 0xD0	; 208
    268c:	d2 01       	movw	r26, r4
    268e:	11 96       	adiw	r26, 0x01	; 1
    2690:	8c 93       	st	X, r24
    2692:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2694:	76 82       	std	Z+6, r7	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2696:	80 81       	ld	r24, Z
    2698:	80 7f       	andi	r24, 0xF0	; 240
    269a:	89 60       	ori	r24, 0x09	; 9
    269c:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    269e:	f8 01       	movw	r30, r16
    26a0:	80 81       	ld	r24, Z
    26a2:	80 7f       	andi	r24, 0xF0	; 240
    26a4:	81 60       	ori	r24, 0x01	; 1
    26a6:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    26a8:	df 91       	pop	r29
    26aa:	cf 91       	pop	r28
    26ac:	1f 91       	pop	r17
    26ae:	0f 91       	pop	r16
    26b0:	ff 90       	pop	r15
    26b2:	ef 90       	pop	r14
    26b4:	df 90       	pop	r13
    26b6:	cf 90       	pop	r12
    26b8:	bf 90       	pop	r11
    26ba:	af 90       	pop	r10
    26bc:	9f 90       	pop	r9
    26be:	8f 90       	pop	r8
    26c0:	7f 90       	pop	r7
    26c2:	5f 90       	pop	r5
    26c4:	4f 90       	pop	r4
    26c6:	3f 90       	pop	r3
    26c8:	2f 90       	pop	r2
    26ca:	08 95       	ret

000026cc <CO_collectSeismic1Channel>:
	sampleCount++;

}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    26cc:	2f 92       	push	r2
    26ce:	3f 92       	push	r3
    26d0:	4f 92       	push	r4
    26d2:	5f 92       	push	r5
    26d4:	6f 92       	push	r6
    26d6:	7f 92       	push	r7
    26d8:	8f 92       	push	r8
    26da:	9f 92       	push	r9
    26dc:	af 92       	push	r10
    26de:	bf 92       	push	r11
    26e0:	cf 92       	push	r12
    26e2:	df 92       	push	r13
    26e4:	ef 92       	push	r14
    26e6:	ff 92       	push	r15
    26e8:	0f 93       	push	r16
    26ea:	cf 93       	push	r28
    26ec:	df 93       	push	r29
    26ee:	cd b7       	in	r28, 0x3d	; 61
    26f0:	de b7       	in	r29, 0x3e	; 62
    26f2:	96 2f       	mov	r25, r22
    26f4:	1a 01       	movw	r2, r20
    26f6:	52 2f       	mov	r21, r18
    26f8:	70 2f       	mov	r23, r16
    26fa:	d7 01       	movw	r26, r14
    26fc:	36 01       	movw	r6, r12
    26fe:	25 01       	movw	r4, r10
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    2700:	00 d0       	rcall	.+0      	; 0x2702 <CO_collectSeismic1Channel+0x36>
    2702:	00 d0       	rcall	.+0      	; 0x2704 <CO_collectSeismic1Channel+0x38>
    2704:	2d b7       	in	r18, 0x3d	; 61
    2706:	3e b7       	in	r19, 0x3e	; 62
    2708:	2f 5f       	subi	r18, 0xFF	; 255
    270a:	3f 4f       	sbci	r19, 0xFF	; 255
    270c:	ed b7       	in	r30, 0x3d	; 61
    270e:	fe b7       	in	r31, 0x3e	; 62
    2710:	81 82       	std	Z+1, r8	; 0x01
    2712:	92 82       	std	Z+2, r9	; 0x02
    2714:	8d 88       	ldd	r8, Y+21	; 0x15
    2716:	9e 88       	ldd	r9, Y+22	; 0x16
    2718:	f9 01       	movw	r30, r18
    271a:	82 82       	std	Z+2, r8	; 0x02
    271c:	93 82       	std	Z+3, r9	; 0x03
    271e:	8f 88       	ldd	r8, Y+23	; 0x17
    2720:	98 8c       	ldd	r9, Y+24	; 0x18
    2722:	84 82       	std	Z+4, r8	; 0x04
    2724:	95 82       	std	Z+5, r9	; 0x05
    2726:	64 ec       	ldi	r22, 0xC4	; 196
    2728:	49 2f       	mov	r20, r25
    272a:	91 01       	movw	r18, r2
    272c:	05 2f       	mov	r16, r21
    272e:	e7 2e       	mov	r14, r23
    2730:	6d 01       	movw	r12, r26
    2732:	53 01       	movw	r10, r6
    2734:	42 01       	movw	r8, r4
    2736:	0e 94 a6 12 	call	0x254c	; 0x254c <CO_collectSeismic1Channel_ext>
    273a:	8d b7       	in	r24, 0x3d	; 61
    273c:	9e b7       	in	r25, 0x3e	; 62
    273e:	06 96       	adiw	r24, 0x06	; 6
    2740:	8d bf       	out	0x3d, r24	; 61
    2742:	9e bf       	out	0x3e, r25	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray);
}
    2744:	df 91       	pop	r29
    2746:	cf 91       	pop	r28
    2748:	0f 91       	pop	r16
    274a:	ff 90       	pop	r15
    274c:	ef 90       	pop	r14
    274e:	df 90       	pop	r13
    2750:	cf 90       	pop	r12
    2752:	bf 90       	pop	r11
    2754:	af 90       	pop	r10
    2756:	9f 90       	pop	r9
    2758:	8f 90       	pop	r8
    275a:	7f 90       	pop	r7
    275c:	6f 90       	pop	r6
    275e:	5f 90       	pop	r5
    2760:	4f 90       	pop	r4
    2762:	3f 90       	pop	r3
    2764:	2f 90       	pop	r2
    2766:	08 95       	ret

00002768 <CO_collectSeismic3Axises_ext>:
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray);
}	
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    2768:	2f 92       	push	r2
    276a:	3f 92       	push	r3
    276c:	5f 92       	push	r5
    276e:	6f 92       	push	r6
    2770:	7f 92       	push	r7
    2772:	8f 92       	push	r8
    2774:	9f 92       	push	r9
    2776:	af 92       	push	r10
    2778:	bf 92       	push	r11
    277a:	cf 92       	push	r12
    277c:	df 92       	push	r13
    277e:	ef 92       	push	r14
    2780:	ff 92       	push	r15
    2782:	0f 93       	push	r16
    2784:	1f 93       	push	r17
    2786:	cf 93       	push	r28
    2788:	df 93       	push	r29
    278a:	0f 92       	push	r0
    278c:	0f 92       	push	r0
    278e:	cd b7       	in	r28, 0x3d	; 61
    2790:	de b7       	in	r29, 0x3e	; 62
    2792:	18 2f       	mov	r17, r24
    2794:	3b 01       	movw	r6, r22
    2796:	49 83       	std	Y+1, r20	; 0x01
    2798:	5a 83       	std	Y+2, r21	; 0x02
    279a:	52 2e       	mov	r5, r18
	
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif
	
	ADC_BUFFER = DataArray;
    279c:	89 8d       	ldd	r24, Y+25	; 0x19
    279e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    27a0:	80 93 72 50 	sts	0x5072, r24
    27a4:	90 93 73 50 	sts	0x5073, r25
	ADC_Sampling_Finished = 0;
    27a8:	10 92 cd 50 	sts	0x50CD, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    27ac:	81 e0       	ldi	r24, 0x01	; 1
    27ae:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    27b2:	85 e0       	ldi	r24, 0x05	; 5
    27b4:	d3 01       	movw	r26, r6
    27b6:	6c 91       	ld	r22, X
    27b8:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    27bc:	86 e0       	ldi	r24, 0x06	; 6
    27be:	f3 01       	movw	r30, r6
    27c0:	61 81       	ldd	r22, Z+1	; 0x01
    27c2:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    27c6:	87 e0       	ldi	r24, 0x07	; 7
    27c8:	d3 01       	movw	r26, r6
    27ca:	12 96       	adiw	r26, 0x02	; 2
    27cc:	6c 91       	ld	r22, X
    27ce:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <set_ampGain>
	set_filter(filterConfig);
    27d2:	81 2f       	mov	r24, r17
    27d4:	0e 94 0c 04 	call	0x818	; 0x818 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    27d8:	80 2f       	mov	r24, r16
    27da:	0e 94 e5 08 	call	0x11ca	; 0x11ca <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    27de:	84 e0       	ldi	r24, 0x04	; 4
    27e0:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    27e4:	84 e5       	ldi	r24, 0x54	; 84
    27e6:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    27ea:	81 e0       	ldi	r24, 0x01	; 1
    27ec:	0e 94 39 07 	call	0xe72	; 0xe72 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    27f0:	85 e0       	ldi	r24, 0x05	; 5
    27f2:	0e 94 84 12 	call	0x2508	; 0x2508 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    27f6:	e0 ea       	ldi	r30, 0xA0	; 160
    27f8:	f6 e0       	ldi	r31, 0x06	; 6
    27fa:	22 e0       	ldi	r18, 0x02	; 2
    27fc:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    27fe:	66 24       	eor	r6, r6
    2800:	63 94       	inc	r6
    2802:	62 82       	std	Z+2, r6	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2804:	0f 2e       	mov	r0, r31
    2806:	f0 e8       	ldi	r31, 0x80	; 128
    2808:	2f 2e       	mov	r2, r31
    280a:	f1 e0       	ldi	r31, 0x01	; 1
    280c:	3f 2e       	mov	r3, r31
    280e:	f0 2d       	mov	r31, r0
    2810:	88 e7       	ldi	r24, 0x78	; 120
    2812:	f1 01       	movw	r30, r2
    2814:	80 83       	st	Z, r24

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2816:	e0 e0       	ldi	r30, 0x00	; 0
    2818:	f8 e0       	ldi	r31, 0x08	; 8
    281a:	80 ef       	ldi	r24, 0xF0	; 240
    281c:	81 83       	std	Z+1, r24	; 0x01
	TCC0.CCA = averagingPtA;
    281e:	e0 a6       	lds	r30, 0xb0
    2820:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    2822:	c2 a6       	lds	r28, 0xb2
    2824:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    2826:	a4 a6       	lds	r26, 0xb4
    2828:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    282a:	86 a6       	lds	r24, 0xb6
    282c:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    282e:	85 2d       	mov	r24, r5
    2830:	90 e0       	ldi	r25, 0x00	; 0
    2832:	01 97       	sbiw	r24, 0x01	; 1
    2834:	86 a3       	lds	r24, 0x56
    2836:	97 a3       	lds	r25, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2838:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    283a:	8f ef       	ldi	r24, 0xFF	; 255
    283c:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    283e:	80 81       	ld	r24, Z
    2840:	80 7f       	andi	r24, 0xF0	; 240
    2842:	88 60       	ori	r24, 0x08	; 8
    2844:	80 83       	st	Z, r24

	sampleCount = 0;
    2846:	10 92 74 50 	sts	0x5074, r1
    284a:	10 92 75 50 	sts	0x5075, r1
    284e:	10 92 76 50 	sts	0x5076, r1
    2852:	10 92 77 50 	sts	0x5077, r1
	SPICount = 0;
    2856:	10 92 c6 50 	sts	0x50C6, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    285a:	8d e3       	ldi	r24, 0x3D	; 61
    285c:	91 e2       	ldi	r25, 0x21	; 33
    285e:	10 92 3d 21 	sts	0x213D, r1
    2862:	fc 01       	movw	r30, r24
    2864:	31 97       	sbiw	r30, 0x01	; 1
    2866:	10 82       	st	Z, r1
    2868:	02 97       	sbiw	r24, 0x02	; 2
    286a:	dc 01       	movw	r26, r24
    286c:	1c 92       	st	X, r1

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm);
    286e:	e0 ea       	ldi	r30, 0xA0	; 160
    2870:	f0 e0       	ldi	r31, 0x00	; 0
    2872:	82 81       	ldd	r24, Z+2	; 0x02
    2874:	87 60       	ori	r24, 0x07	; 7
    2876:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2878:	78 94       	sei

	SPICS(TRUE);
    287a:	81 e0       	ldi	r24, 0x01	; 1
    287c:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2880:	80 e2       	ldi	r24, 0x20	; 32
    2882:	e0 e8       	ldi	r30, 0x80	; 128
    2884:	f6 e0       	ldi	r31, 0x06	; 6
    2886:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2888:	00 e4       	ldi	r16, 0x40	; 64
    288a:	1a e0       	ldi	r17, 0x0A	; 10
    288c:	83 e2       	ldi	r24, 0x23	; 35
    288e:	f8 01       	movw	r30, r16
    2890:	81 83       	std	Z+1, r24	; 0x01
	// set period of waveform generator and duty cycle (want duty cycle to be half the period to get clean clock signal)
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2892:	89 81       	ldd	r24, Y+1	; 0x01
    2894:	9a 81       	ldd	r25, Y+2	; 0x02
    2896:	6c 01       	movw	r12, r24
    2898:	ee 24       	eor	r14, r14
    289a:	ff 24       	eor	r15, r15
    289c:	60 e8       	ldi	r22, 0x80	; 128
    289e:	74 e8       	ldi	r23, 0x84	; 132
    28a0:	8e e1       	ldi	r24, 0x1E	; 30
    28a2:	90 e0       	ldi	r25, 0x00	; 0
    28a4:	a7 01       	movw	r20, r14
    28a6:	96 01       	movw	r18, r12
    28a8:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    28ac:	d8 01       	movw	r26, r16
    28ae:	96 96       	adiw	r26, 0x26	; 38
    28b0:	2d 93       	st	X+, r18
    28b2:	3c 93       	st	X, r19
    28b4:	97 97       	sbiw	r26, 0x27	; 39
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    28b6:	60 e4       	ldi	r22, 0x40	; 64
    28b8:	72 e4       	ldi	r23, 0x42	; 66
    28ba:	8f e0       	ldi	r24, 0x0F	; 15
    28bc:	90 e0       	ldi	r25, 0x00	; 0
    28be:	a7 01       	movw	r20, r14
    28c0:	96 01       	movw	r18, r12
    28c2:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    28c6:	f8 01       	movw	r30, r16
    28c8:	22 af       	sts	0x72, r18
    28ca:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    28cc:	e0 e4       	ldi	r30, 0x40	; 64
    28ce:	f8 e0       	ldi	r31, 0x08	; 8
    28d0:	8f 89       	ldd	r24, Y+23	; 0x17
    28d2:	98 8d       	ldd	r25, Y+24	; 0x18
    28d4:	86 a3       	lds	r24, 0x56
    28d6:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
    28d8:	80 ec       	ldi	r24, 0xC0	; 192
    28da:	d1 01       	movw	r26, r2
    28dc:	11 96       	adiw	r26, 0x01	; 1
    28de:	8c 93       	st	X, r24
    28e0:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    28e2:	66 82       	std	Z+6, r6	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    28e4:	80 81       	ld	r24, Z
    28e6:	80 7f       	andi	r24, 0xF0	; 240
    28e8:	89 60       	ori	r24, 0x09	; 9
    28ea:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    28ec:	f8 01       	movw	r30, r16
    28ee:	80 81       	ld	r24, Z
    28f0:	80 7f       	andi	r24, 0xF0	; 240
    28f2:	81 60       	ori	r24, 0x01	; 1
    28f4:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    28f6:	0f 90       	pop	r0
    28f8:	0f 90       	pop	r0
    28fa:	df 91       	pop	r29
    28fc:	cf 91       	pop	r28
    28fe:	1f 91       	pop	r17
    2900:	0f 91       	pop	r16
    2902:	ff 90       	pop	r15
    2904:	ef 90       	pop	r14
    2906:	df 90       	pop	r13
    2908:	cf 90       	pop	r12
    290a:	bf 90       	pop	r11
    290c:	af 90       	pop	r10
    290e:	9f 90       	pop	r9
    2910:	8f 90       	pop	r8
    2912:	7f 90       	pop	r7
    2914:	6f 90       	pop	r6
    2916:	5f 90       	pop	r5
    2918:	3f 90       	pop	r3
    291a:	2f 90       	pop	r2
    291c:	08 95       	ret

0000291e <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    291e:	2f 92       	push	r2
    2920:	3f 92       	push	r3
    2922:	4f 92       	push	r4
    2924:	5f 92       	push	r5
    2926:	6f 92       	push	r6
    2928:	7f 92       	push	r7
    292a:	8f 92       	push	r8
    292c:	9f 92       	push	r9
    292e:	af 92       	push	r10
    2930:	bf 92       	push	r11
    2932:	cf 92       	push	r12
    2934:	df 92       	push	r13
    2936:	ef 92       	push	r14
    2938:	ff 92       	push	r15
    293a:	0f 93       	push	r16
    293c:	1f 93       	push	r17
    293e:	cf 93       	push	r28
    2940:	df 93       	push	r29
    2942:	00 d0       	rcall	.+0      	; 0x2944 <CO_collectSeismic3Axises+0x26>
    2944:	0f 92       	push	r0
    2946:	cd b7       	in	r28, 0x3d	; 61
    2948:	de b7       	in	r29, 0x3e	; 62
    294a:	8b 83       	std	Y+3, r24	; 0x03
    294c:	9c 83       	std	Y+4, r25	; 0x04
    294e:	db 01       	movw	r26, r22
    2950:	94 2f       	mov	r25, r20
    2952:	32 2f       	mov	r19, r18
    2954:	38 01       	movw	r6, r16
    2956:	27 01       	movw	r4, r14
    2958:	16 01       	movw	r2, r12
    295a:	a9 82       	std	Y+1, r10	; 0x01
    295c:	ba 82       	std	Y+2, r11	; 0x02
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    295e:	00 d0       	rcall	.+0      	; 0x2960 <CO_collectSeismic3Axises+0x42>
    2960:	0f 92       	push	r0
    2962:	ed b7       	in	r30, 0x3d	; 61
    2964:	fe b7       	in	r31, 0x3e	; 62
    2966:	81 82       	std	Z+1, r8	; 0x01
    2968:	92 82       	std	Z+2, r9	; 0x02
    296a:	4a 8d       	ldd	r20, Y+26	; 0x1a
    296c:	5b 8d       	ldd	r21, Y+27	; 0x1b
    296e:	43 83       	std	Z+3, r20	; 0x03
    2970:	54 83       	std	Z+4, r21	; 0x04
    2972:	84 ec       	ldi	r24, 0xC4	; 196
    2974:	6b 81       	ldd	r22, Y+3	; 0x03
    2976:	7c 81       	ldd	r23, Y+4	; 0x04
    2978:	ad 01       	movw	r20, r26
    297a:	29 2f       	mov	r18, r25
    297c:	03 2f       	mov	r16, r19
    297e:	73 01       	movw	r14, r6
    2980:	62 01       	movw	r12, r4
    2982:	51 01       	movw	r10, r2
    2984:	89 80       	ldd	r8, Y+1	; 0x01
    2986:	9a 80       	ldd	r9, Y+2	; 0x02
    2988:	0e 94 b4 13 	call	0x2768	; 0x2768 <CO_collectSeismic3Axises_ext>
    298c:	0f 90       	pop	r0
    298e:	0f 90       	pop	r0
    2990:	0f 90       	pop	r0
    2992:	0f 90       	pop	r0
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray);
}	
    2994:	24 96       	adiw	r28, 0x04	; 4
    2996:	cd bf       	out	0x3d, r28	; 61
    2998:	de bf       	out	0x3e, r29	; 62
    299a:	df 91       	pop	r29
    299c:	cf 91       	pop	r28
    299e:	1f 91       	pop	r17
    29a0:	0f 91       	pop	r16
    29a2:	ff 90       	pop	r15
    29a4:	ef 90       	pop	r14
    29a6:	df 90       	pop	r13
    29a8:	cf 90       	pop	r12
    29aa:	bf 90       	pop	r11
    29ac:	af 90       	pop	r10
    29ae:	9f 90       	pop	r9
    29b0:	8f 90       	pop	r8
    29b2:	7f 90       	pop	r7
    29b4:	6f 90       	pop	r6
    29b6:	5f 90       	pop	r5
    29b8:	4f 90       	pop	r4
    29ba:	3f 90       	pop	r3
    29bc:	2f 90       	pop	r2
    29be:	08 95       	ret

000029c0 <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    29c0:	8f 92       	push	r8
    29c2:	9f 92       	push	r9
    29c4:	af 92       	push	r10
    29c6:	bf 92       	push	r11
    29c8:	df 92       	push	r13
    29ca:	ef 92       	push	r14
    29cc:	ff 92       	push	r15
    29ce:	0f 93       	push	r16
    29d0:	1f 93       	push	r17
    29d2:	cf 93       	push	r28
    29d4:	df 93       	push	r29
    29d6:	c8 2f       	mov	r28, r24
    29d8:	d6 2e       	mov	r13, r22
    29da:	d4 2f       	mov	r29, r20
    29dc:	59 01       	movw	r10, r18
    29de:	48 01       	movw	r8, r16
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif

	uint16_t period;
	ADC_BUFFER = DataArray;
    29e0:	e0 92 72 50 	sts	0x5072, r14
    29e4:	f0 92 73 50 	sts	0x5073, r15
	ADC_Sampling_Finished = 0;
    29e8:	10 92 cd 50 	sts	0x50CD, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    29ec:	81 e0       	ldi	r24, 0x01	; 1
    29ee:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    29f2:	8c 2f       	mov	r24, r28
    29f4:	6d 2f       	mov	r22, r29
    29f6:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <set_ampGain>
	set_filter(filterConfig);
    29fa:	8d 2d       	mov	r24, r13
    29fc:	0e 94 0c 04 	call	0x818	; 0x818 <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    2a00:	8c 2f       	mov	r24, r28
    2a02:	85 50       	subi	r24, 0x05	; 5
    2a04:	83 30       	cpi	r24, 0x03	; 3
    2a06:	18 f4       	brcc	.+6      	; 0x2a0e <CO_collectADC_ext+0x4e>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    2a08:	81 e0       	ldi	r24, 0x01	; 1
    2a0a:	0e 94 e5 08 	call	0x11ca	; 0x11ca <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    2a0e:	81 e0       	ldi	r24, 0x01	; 1
    2a10:	0e 94 39 07 	call	0xe72	; 0xe72 <enableADCMUX>
	setADCInput(channel);
    2a14:	8c 2f       	mov	r24, r28
    2a16:	0e 94 84 12 	call	0x2508	; 0x2508 <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    2a1a:	84 e0       	ldi	r24, 0x04	; 4
    2a1c:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2a20:	84 e5       	ldi	r24, 0x54	; 84
    2a22:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    2a26:	e0 ea       	ldi	r30, 0xA0	; 160
    2a28:	f6 e0       	ldi	r31, 0x06	; 6
    2a2a:	dd 24       	eor	r13, r13
    2a2c:	d3 94       	inc	r13
    2a2e:	d2 82       	std	Z+2, r13	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    2a30:	82 e0       	ldi	r24, 0x02	; 2
    2a32:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    2a34:	d2 86       	std	Z+10, r13	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_MED_gc;				
    2a36:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    2a38:	80 e2       	ldi	r24, 0x20	; 32
    2a3a:	e0 e8       	ldi	r30, 0x80	; 128
    2a3c:	f6 e0       	ldi	r31, 0x06	; 6
    2a3e:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2a40:	c0 e4       	ldi	r28, 0x40	; 64
    2a42:	da e0       	ldi	r29, 0x0A	; 10
    2a44:	83 e2       	ldi	r24, 0x23	; 35
    2a46:	89 83       	std	Y+1, r24	; 0x01
	// set period of waveform generator and ccb as duty cycle (want half the period for duty cycle to have good clock signal)
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    2a48:	95 01       	movw	r18, r10
    2a4a:	40 e0       	ldi	r20, 0x00	; 0
    2a4c:	50 e0       	ldi	r21, 0x00	; 0
    2a4e:	60 e8       	ldi	r22, 0x80	; 128
    2a50:	74 e8       	ldi	r23, 0x84	; 132
    2a52:	8e e1       	ldi	r24, 0x1E	; 30
    2a54:	90 e0       	ldi	r25, 0x00	; 0
    2a56:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    2a5a:	89 01       	movw	r16, r18
    2a5c:	9a 01       	movw	r18, r20
    2a5e:	c8 01       	movw	r24, r16
	TCE1.PER = period;
    2a60:	0e a3       	lds	r16, 0x5e
    2a62:	1f a3       	lds	r17, 0x5f
	TCE1.CCBBUF = period / 2;
    2a64:	96 95       	lsr	r25
    2a66:	87 95       	ror	r24
    2a68:	8a af       	sts	0x7a, r24
    2a6a:	9b af       	sts	0x7b, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples;
    2a6c:	e0 e4       	ldi	r30, 0x40	; 64
    2a6e:	f8 e0       	ldi	r31, 0x08	; 8
    2a70:	86 a2       	lds	r24, 0x96
    2a72:	97 a2       	lds	r25, 0x97
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2a74:	88 e7       	ldi	r24, 0x78	; 120
    2a76:	a0 e8       	ldi	r26, 0x80	; 128
    2a78:	b1 e0       	ldi	r27, 0x01	; 1
    2a7a:	11 96       	adiw	r26, 0x01	; 1
    2a7c:	8c 93       	st	X, r24
    2a7e:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2a80:	d6 82       	std	Z+6, r13	; 0x06
	//TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2a82:	88 81       	ld	r24, Y
    2a84:	80 7f       	andi	r24, 0xF0	; 240
    2a86:	81 60       	ori	r24, 0x01	; 1
    2a88:	88 83       	st	Y, r24
	
	sampleCount = 0;
    2a8a:	10 92 74 50 	sts	0x5074, r1
    2a8e:	10 92 75 50 	sts	0x5075, r1
    2a92:	10 92 76 50 	sts	0x5076, r1
    2a96:	10 92 77 50 	sts	0x5077, r1
	discardCount = 0;
    2a9a:	10 92 5d 40 	sts	0x405D, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
    2a9e:	e0 ea       	ldi	r30, 0xA0	; 160
    2aa0:	f0 e0       	ldi	r31, 0x00	; 0
    2aa2:	82 81       	ldd	r24, Z+2	; 0x02
    2aa4:	83 60       	ori	r24, 0x03	; 3
    2aa6:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2aa8:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    2aaa:	df 91       	pop	r29
    2aac:	cf 91       	pop	r28
    2aae:	1f 91       	pop	r17
    2ab0:	0f 91       	pop	r16
    2ab2:	ff 90       	pop	r15
    2ab4:	ef 90       	pop	r14
    2ab6:	df 90       	pop	r13
    2ab8:	bf 90       	pop	r11
    2aba:	af 90       	pop	r10
    2abc:	9f 90       	pop	r9
    2abe:	8f 90       	pop	r8
    2ac0:	08 95       	ret

00002ac2 <CO_collectADC>:
		PORTA.OUTCLR = PIN5_bm;
		PORTA.DIRCLR = PIN5_bm;
	}
}

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    2ac2:	ef 92       	push	r14
    2ac4:	ff 92       	push	r15
    2ac6:	0f 93       	push	r16
    2ac8:	1f 93       	push	r17
    2aca:	96 2f       	mov	r25, r22
    2acc:	fa 01       	movw	r30, r20
    2ace:	d9 01       	movw	r26, r18
    2ad0:	78 01       	movw	r14, r16
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray);
    2ad2:	64 ec       	ldi	r22, 0xC4	; 196
    2ad4:	49 2f       	mov	r20, r25
    2ad6:	9f 01       	movw	r18, r30
    2ad8:	8d 01       	movw	r16, r26
    2ada:	0e 94 e0 14 	call	0x29c0	; 0x29c0 <CO_collectADC_ext>
}
    2ade:	1f 91       	pop	r17
    2ae0:	0f 91       	pop	r16
    2ae2:	ff 90       	pop	r15
    2ae4:	ef 90       	pop	r14
    2ae6:	08 95       	ret

00002ae8 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    2ae8:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2aea:	81 e0       	ldi	r24, 0x01	; 1
    2aec:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    2aee:	84 81       	ldd	r24, Z+4	; 0x04
    2af0:	95 81       	ldd	r25, Z+5	; 0x05
    2af2:	86 1b       	sub	r24, r22
    2af4:	91 09       	sbc	r25, r1

	return answer;
}
    2af6:	08 95       	ret

00002af8 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    2af8:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2afa:	81 e0       	ldi	r24, 0x01	; 1
    2afc:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    2afe:	84 81       	ldd	r24, Z+4	; 0x04
    2b00:	95 81       	ldd	r25, Z+5	; 0x05
    2b02:	77 27       	eor	r23, r23
    2b04:	67 fd       	sbrc	r22, 7
    2b06:	70 95       	com	r23
    2b08:	86 1b       	sub	r24, r22
    2b0a:	97 0b       	sbc	r25, r23

	return answer;
}
    2b0c:	08 95       	ret

00002b0e <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    2b0e:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2b10:	81 e0       	ldi	r24, 0x01	; 1
    2b12:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    2b14:	84 81       	ldd	r24, Z+4	; 0x04
    2b16:	95 81       	ldd	r25, Z+5	; 0x05
}
    2b18:	08 95       	ret

00002b1a <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    2b1a:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2b1c:	81 e0       	ldi	r24, 0x01	; 1
    2b1e:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    2b20:	84 81       	ldd	r24, Z+4	; 0x04
}
    2b22:	08 95       	ret

00002b24 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    2b24:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2b26:	81 e0       	ldi	r24, 0x01	; 1
    2b28:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    2b2a:	85 81       	ldd	r24, Z+5	; 0x05
}
    2b2c:	08 95       	ret

00002b2e <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    2b2e:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    2b30:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    2b32:	14 82       	std	Z+4, r1	; 0x04
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2b34:	9a e2       	ldi	r25, 0x2A	; 42
    2b36:	9a 95       	dec	r25
    2b38:	f1 f7       	brne	.-4      	; 0x2b36 <ADC_Wait_8MHz+0x8>
    2b3a:	00 c0       	rjmp	.+0      	; 0x2b3c <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    2b3c:	84 83       	std	Z+4, r24	; 0x04
}
    2b3e:	08 95       	ret

00002b40 <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    2b40:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    2b42:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    2b44:	91 e0       	ldi	r25, 0x01	; 1
    2b46:	94 83       	std	Z+4, r25	; 0x04
    2b48:	95 e5       	ldi	r25, 0x55	; 85
    2b4a:	9a 95       	dec	r25
    2b4c:	f1 f7       	brne	.-4      	; 0x2b4a <ADC_Wait_32MHz+0xa>
    2b4e:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    2b50:	84 83       	std	Z+4, r24	; 0x04
}
    2b52:	08 95       	ret

00002b54 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    2b54:	ef 92       	push	r14
    2b56:	ff 92       	push	r15
    2b58:	0f 93       	push	r16
    2b5a:	1f 93       	push	r17
    2b5c:	cf 93       	push	r28
    2b5e:	df 93       	push	r29
    2b60:	eb 01       	movw	r28, r22
    if (oversampling)
    2b62:	44 23       	and	r20, r20
    2b64:	c9 f0       	breq	.+50     	; 0x2b98 <ADC_Offset_Get_Unsigned+0x44>
    2b66:	04 e0       	ldi	r16, 0x04	; 4
    2b68:	10 e0       	ldi	r17, 0x00	; 0
    2b6a:	ee 24       	eor	r14, r14
    2b6c:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    2b6e:	88 81       	ld	r24, Y
    2b70:	80 68       	ori	r24, 0x80	; 128
    2b72:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    2b74:	8b 81       	ldd	r24, Y+3	; 0x03
    2b76:	80 ff       	sbrs	r24, 0
    2b78:	fd cf       	rjmp	.-6      	; 0x2b74 <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    2b7a:	ce 01       	movw	r24, r28
    2b7c:	60 e0       	ldi	r22, 0x00	; 0
    2b7e:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <ADC_ResultCh_GetWord_Unsigned>
    2b82:	e8 0e       	add	r14, r24
    2b84:	f9 1e       	adc	r15, r25
    2b86:	01 50       	subi	r16, 0x01	; 1
    2b88:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    2b8a:	89 f7       	brne	.-30     	; 0x2b6e <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    2b8c:	c7 01       	movw	r24, r14
    2b8e:	96 95       	lsr	r25
    2b90:	87 95       	ror	r24
    2b92:	96 95       	lsr	r25
    2b94:	87 95       	ror	r24
    2b96:	09 c0       	rjmp	.+18     	; 0x2baa <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    2b98:	88 81       	ld	r24, Y
    2b9a:	80 68       	ori	r24, 0x80	; 128
    2b9c:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    2b9e:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba0:	80 ff       	sbrs	r24, 0
    2ba2:	fd cf       	rjmp	.-6      	; 0x2b9e <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    2ba4:	ce 01       	movw	r24, r28
    2ba6:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
    2baa:	df 91       	pop	r29
    2bac:	cf 91       	pop	r28
    2bae:	1f 91       	pop	r17
    2bb0:	0f 91       	pop	r16
    2bb2:	ff 90       	pop	r15
    2bb4:	ef 90       	pop	r14
    2bb6:	08 95       	ret

00002bb8 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    2bb8:	ef 92       	push	r14
    2bba:	ff 92       	push	r15
    2bbc:	0f 93       	push	r16
    2bbe:	1f 93       	push	r17
    2bc0:	cf 93       	push	r28
    2bc2:	df 93       	push	r29
    2bc4:	eb 01       	movw	r28, r22
    if (oversampling)
    2bc6:	44 23       	and	r20, r20
    2bc8:	e1 f0       	breq	.+56     	; 0x2c02 <ADC_Offset_Get_Signed+0x4a>
    2bca:	04 e0       	ldi	r16, 0x04	; 4
    2bcc:	10 e0       	ldi	r17, 0x00	; 0
    2bce:	ee 24       	eor	r14, r14
    2bd0:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    2bd2:	88 81       	ld	r24, Y
    2bd4:	80 68       	ori	r24, 0x80	; 128
    2bd6:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    2bd8:	8b 81       	ldd	r24, Y+3	; 0x03
    2bda:	80 ff       	sbrs	r24, 0
    2bdc:	fd cf       	rjmp	.-6      	; 0x2bd8 <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    2bde:	ce 01       	movw	r24, r28
    2be0:	60 e0       	ldi	r22, 0x00	; 0
    2be2:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <ADC_ResultCh_GetWord_Signed>
    2be6:	e8 0e       	add	r14, r24
    2be8:	f9 1e       	adc	r15, r25
    2bea:	01 50       	subi	r16, 0x01	; 1
    2bec:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    2bee:	89 f7       	brne	.-30     	; 0x2bd2 <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    2bf0:	c7 01       	movw	r24, r14
    2bf2:	99 23       	and	r25, r25
    2bf4:	0c f4       	brge	.+2      	; 0x2bf8 <ADC_Offset_Get_Signed+0x40>
    2bf6:	03 96       	adiw	r24, 0x03	; 3
    2bf8:	95 95       	asr	r25
    2bfa:	87 95       	ror	r24
    2bfc:	95 95       	asr	r25
    2bfe:	87 95       	ror	r24
    2c00:	0a c0       	rjmp	.+20     	; 0x2c16 <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    2c02:	88 81       	ld	r24, Y
    2c04:	80 68       	ori	r24, 0x80	; 128
    2c06:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    2c08:	8b 81       	ldd	r24, Y+3	; 0x03
    2c0a:	80 ff       	sbrs	r24, 0
    2c0c:	fd cf       	rjmp	.-6      	; 0x2c08 <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    2c0e:	ce 01       	movw	r24, r28
    2c10:	60 e0       	ldi	r22, 0x00	; 0
    2c12:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
    2c16:	df 91       	pop	r29
    2c18:	cf 91       	pop	r28
    2c1a:	1f 91       	pop	r17
    2c1c:	0f 91       	pop	r16
    2c1e:	ff 90       	pop	r15
    2c20:	ef 90       	pop	r14
    2c22:	08 95       	ret

00002c24 <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    2c24:	aa ec       	ldi	r26, 0xCA	; 202
    2c26:	b1 e0       	ldi	r27, 0x01	; 1
    2c28:	92 e0       	ldi	r25, 0x02	; 2
    2c2a:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
    2c2c:	e8 2f       	mov	r30, r24
    2c2e:	f0 e0       	ldi	r31, 0x00	; 0
    2c30:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    2c32:	1c 92       	st	X, r1

	return result;
}
    2c34:	08 95       	ret

00002c36 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    2c36:	cf 93       	push	r28
    2c38:	df 93       	push	r29
    2c3a:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
    2c3c:	82 e0       	ldi	r24, 0x02	; 2
    2c3e:	c0 30       	cpi	r28, 0x00	; 0
    2c40:	d8 07       	cpc	r29, r24
    2c42:	59 f4       	brne	.+22     	; 0x2c5a <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    2c44:	80 e2       	ldi	r24, 0x20	; 32
    2c46:	0e 94 12 16 	call	0x2c24	; 0x2c24 <SP_ReadCalibrationByte>
    2c4a:	c0 e0       	ldi	r28, 0x00	; 0
    2c4c:	d2 e0       	ldi	r29, 0x02	; 2
    2c4e:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    2c50:	81 e2       	ldi	r24, 0x21	; 33
    2c52:	0e 94 12 16 	call	0x2c24	; 0x2c24 <SP_ReadCalibrationByte>
    2c56:	8d 87       	std	Y+13, r24	; 0x0d
    2c58:	08 c0       	rjmp	.+16     	; 0x2c6a <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    2c5a:	84 e2       	ldi	r24, 0x24	; 36
    2c5c:	0e 94 12 16 	call	0x2c24	; 0x2c24 <SP_ReadCalibrationByte>
    2c60:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    2c62:	85 e2       	ldi	r24, 0x25	; 37
    2c64:	0e 94 12 16 	call	0x2c24	; 0x2c24 <SP_ReadCalibrationByte>
    2c68:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
    2c6a:	df 91       	pop	r29
    2c6c:	cf 91       	pop	r28
    2c6e:	08 95       	ret

00002c70 <radio_msg_received_int_enable>:
	radio_msg_received_int_enable();
}

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
	PORTE.DIRSET = PIN2_bm;
    2c70:	e0 e8       	ldi	r30, 0x80	; 128
    2c72:	f6 e0       	ldi	r31, 0x06	; 6
    2c74:	84 e0       	ldi	r24, 0x04	; 4
    2c76:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    2c78:	86 83       	std	Z+6, r24	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    2c7a:	92 e0       	ldi	r25, 0x02	; 2
    2c7c:	90 8b       	std	Z+16, r25	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    2c7e:	82 87       	std	Z+10, r24	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    2c80:	83 e0       	ldi	r24, 0x03	; 3
    2c82:	81 87       	std	Z+9, r24	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    2c84:	e0 ea       	ldi	r30, 0xA0	; 160
    2c86:	f0 e0       	ldi	r31, 0x00	; 0
    2c88:	82 81       	ldd	r24, Z+2	; 0x02
    2c8a:	84 60       	ori	r24, 0x04	; 4
    2c8c:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2c8e:	78 94       	sei
}
    2c90:	08 95       	ret

00002c92 <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
    2c92:	84 e1       	ldi	r24, 0x14	; 20
    2c94:	ee e3       	ldi	r30, 0x3E	; 62
    2c96:	f1 e2       	ldi	r31, 0x21	; 33
    2c98:	df 01       	movw	r26, r30
    2c9a:	1d 92       	st	X+, r1
    2c9c:	8a 95       	dec	r24
    2c9e:	e9 f7       	brne	.-6      	; 0x2c9a <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
    2ca0:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <chb_get_short_addr>
    2ca4:	80 93 3e 21 	sts	0x213E, r24
    2ca8:	90 93 3f 21 	sts	0x213F, r25
    chb_drvr_init();
    2cac:	0e 94 10 1a 	call	0x3420	; 0x3420 <chb_drvr_init>
	radio_msg_received_int_enable();
    2cb0:	0e 94 38 16 	call	0x2c70	; 0x2c70 <radio_msg_received_int_enable>
}
    2cb4:	08 95       	ret

00002cb6 <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
    2cb6:	8e e3       	ldi	r24, 0x3E	; 62
    2cb8:	91 e2       	ldi	r25, 0x21	; 33
    2cba:	08 95       	ret

00002cbc <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    2cbc:	2f 92       	push	r2
    2cbe:	3f 92       	push	r3
    2cc0:	4f 92       	push	r4
    2cc2:	5f 92       	push	r5
    2cc4:	6f 92       	push	r6
    2cc6:	7f 92       	push	r7
    2cc8:	8f 92       	push	r8
    2cca:	9f 92       	push	r9
    2ccc:	af 92       	push	r10
    2cce:	bf 92       	push	r11
    2cd0:	cf 92       	push	r12
    2cd2:	df 92       	push	r13
    2cd4:	ef 92       	push	r14
    2cd6:	ff 92       	push	r15
    2cd8:	0f 93       	push	r16
    2cda:	1f 93       	push	r17
    2cdc:	cf 93       	push	r28
    2cde:	df 93       	push	r29
    2ce0:	cd b7       	in	r28, 0x3d	; 61
    2ce2:	de b7       	in	r29, 0x3e	; 62
    2ce4:	2e 97       	sbiw	r28, 0x0e	; 14
    2ce6:	cd bf       	out	0x3d, r28	; 61
    2ce8:	de bf       	out	0x3e, r29	; 62
    2cea:	8b 87       	std	Y+11, r24	; 0x0b
    2cec:	9c 87       	std	Y+12, r25	; 0x0c
    2cee:	6d 87       	std	Y+13, r22	; 0x0d
    2cf0:	7e 87       	std	Y+14, r23	; 0x0e
    2cf2:	49 01       	movw	r8, r18
    2cf4:	5a 01       	movw	r10, r20
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    2cf6:	21 15       	cp	r18, r1
    2cf8:	31 05       	cpc	r19, r1
    2cfa:	41 05       	cpc	r20, r1
    2cfc:	51 05       	cpc	r21, r1
    2cfe:	09 f4       	brne	.+2      	; 0x2d02 <chb_write+0x46>
    2d00:	88 c0       	rjmp	.+272    	; 0x2e12 <chb_write+0x156>
{
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    2d02:	ee 24       	eor	r14, r14
                 pcb.txd_noack++;
				 rtry++;
                 break;
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    2d04:	0f 2e       	mov	r0, r31
    2d06:	f9 e4       	ldi	r31, 0x49	; 73
    2d08:	6f 2e       	mov	r6, r31
    2d0a:	f1 e2       	ldi	r31, 0x21	; 33
    2d0c:	7f 2e       	mov	r7, r31
    2d0e:	f0 2d       	mov	r31, r0
             switch (status)
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    2d10:	0f 2e       	mov	r0, r31
    2d12:	f5 e4       	ldi	r31, 0x45	; 69
    2d14:	4f 2e       	mov	r4, r31
    2d16:	f1 e2       	ldi	r31, 0x21	; 33
    2d18:	5f 2e       	mov	r5, r31
    2d1a:	f0 2d       	mov	r31, r0
                 break;
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    2d1c:	0f 2e       	mov	r0, r31
    2d1e:	f7 e4       	ldi	r31, 0x47	; 71
    2d20:	2f 2e       	mov	r2, r31
    2d22:	f1 e2       	ldi	r31, 0x21	; 33
    2d24:	3f 2e       	mov	r3, r31
    2d26:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    2d28:	f8 2c       	mov	r15, r8
    2d2a:	25 e6       	ldi	r18, 0x65	; 101
    2d2c:	82 16       	cp	r8, r18
    2d2e:	91 04       	cpc	r9, r1
    2d30:	a1 04       	cpc	r10, r1
    2d32:	b1 04       	cpc	r11, r1
    2d34:	20 f0       	brcs	.+8      	; 0x2d3e <chb_write+0x82>
    2d36:	0f 2e       	mov	r0, r31
    2d38:	f4 e6       	ldi	r31, 0x64	; 100
    2d3a:	ff 2e       	mov	r15, r31
    2d3c:	f0 2d       	mov	r31, r0
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    2d3e:	8f 2d       	mov	r24, r15
    2d40:	85 5f       	subi	r24, 0xF5	; 245
    2d42:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    2d44:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d46:	9c 85       	ldd	r25, Y+12	; 0x0c
    2d48:	ef ef       	ldi	r30, 0xFF	; 255
    2d4a:	8f 3f       	cpi	r24, 0xFF	; 255
    2d4c:	9e 07       	cpc	r25, r30
    2d4e:	11 f0       	breq	.+4      	; 0x2d54 <chb_write+0x98>
    2d50:	81 e6       	ldi	r24, 0x61	; 97
    2d52:	01 c0       	rjmp	.+2      	; 0x2d56 <chb_write+0x9a>
    2d54:	81 e4       	ldi	r24, 0x41	; 65
    2d56:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    2d58:	88 e9       	ldi	r24, 0x98	; 152
    2d5a:	8b 83       	std	Y+3, r24	; 0x03

    *hdr_ptr++ = pcb.seq++;
    2d5c:	e0 e4       	ldi	r30, 0x40	; 64
    2d5e:	f1 e2       	ldi	r31, 0x21	; 33
    2d60:	80 81       	ld	r24, Z
    2d62:	8c 83       	std	Y+4, r24	; 0x04
    2d64:	8f 5f       	subi	r24, 0xFF	; 255
    2d66:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    2d68:	84 e3       	ldi	r24, 0x34	; 52
    2d6a:	92 e1       	ldi	r25, 0x12	; 18
    2d6c:	8d 83       	std	Y+5, r24	; 0x05
    2d6e:	9e 83       	std	Y+6, r25	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
    2d70:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d72:	9c 85       	ldd	r25, Y+12	; 0x0c
    2d74:	8f 83       	std	Y+7, r24	; 0x07
    2d76:	98 87       	std	Y+8, r25	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
    2d78:	32 97       	sbiw	r30, 0x02	; 2
    2d7a:	80 81       	ld	r24, Z
    2d7c:	91 81       	ldd	r25, Z+1	; 0x01
    2d7e:	89 87       	std	Y+9, r24	; 0x09
    2d80:	9a 87       	std	Y+10, r25	; 0x0a
        // gen frame header
        //hdr_len = chb_gen_hdr(hdr, addr, frm_len);
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		rtry = 0;
    2d82:	00 e0       	ldi	r16, 0x00	; 0
    2d84:	10 e0       	ldi	r17, 0x00	; 0
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    2d86:	cd 84       	ldd	r12, Y+13	; 0x0d
    2d88:	de 84       	ldd	r13, Y+14	; 0x0e
    2d8a:	ce 0c       	add	r12, r14
    2d8c:	d1 1c       	adc	r13, r1
    2d8e:	ce 01       	movw	r24, r28
    2d90:	01 96       	adiw	r24, 0x01	; 1
    2d92:	b6 01       	movw	r22, r12
    2d94:	4f 2d       	mov	r20, r15
    2d96:	0e 94 4c 19 	call	0x3298	; 0x3298 <chb_tx>
    2d9a:	28 2f       	mov	r18, r24

             switch (status)
    2d9c:	83 30       	cpi	r24, 0x03	; 3
    2d9e:	c9 f0       	breq	.+50     	; 0x2dd2 <chb_write+0x116>
    2da0:	84 30       	cpi	r24, 0x04	; 4
    2da2:	18 f4       	brcc	.+6      	; 0x2daa <chb_write+0xee>
    2da4:	81 30       	cpi	r24, 0x01	; 1
    2da6:	e9 f4       	brne	.+58     	; 0x2de2 <chb_write+0x126>
    2da8:	04 c0       	rjmp	.+8      	; 0x2db2 <chb_write+0xf6>
    2daa:	85 30       	cpi	r24, 0x05	; 5
    2dac:	49 f0       	breq	.+18     	; 0x2dc0 <chb_write+0x104>
    2dae:	80 34       	cpi	r24, 0x40	; 64
    2db0:	c1 f4       	brne	.+48     	; 0x2de2 <chb_write+0x126>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    2db2:	f2 01       	movw	r30, r4
    2db4:	80 81       	ld	r24, Z
    2db6:	91 81       	ldd	r25, Z+1	; 0x01
    2db8:	01 96       	adiw	r24, 0x01	; 1
    2dba:	80 83       	st	Z, r24
    2dbc:	91 83       	std	Z+1, r25	; 0x01
                 break;
    2dbe:	11 c0       	rjmp	.+34     	; 0x2de2 <chb_write+0x126>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    2dc0:	f1 01       	movw	r30, r2
    2dc2:	80 81       	ld	r24, Z
    2dc4:	91 81       	ldd	r25, Z+1	; 0x01
    2dc6:	01 96       	adiw	r24, 0x01	; 1
    2dc8:	80 83       	st	Z, r24
    2dca:	91 83       	std	Z+1, r25	; 0x01
				 rtry++;
    2dcc:	0f 5f       	subi	r16, 0xFF	; 255
    2dce:	1f 4f       	sbci	r17, 0xFF	; 255
                 break;
    2dd0:	08 c0       	rjmp	.+16     	; 0x2de2 <chb_write+0x126>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    2dd2:	f3 01       	movw	r30, r6
    2dd4:	80 81       	ld	r24, Z
    2dd6:	91 81       	ldd	r25, Z+1	; 0x01
    2dd8:	01 96       	adiw	r24, 0x01	; 1
    2dda:	80 83       	st	Z, r24
    2ddc:	91 83       	std	Z+1, r25	; 0x01
				 rtry++;
    2dde:	0f 5f       	subi	r16, 0xFF	; 255
    2de0:	1f 4f       	sbci	r17, 0xFF	; 255
                 break;
 
             default:
                 break;
             }
			if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
    2de2:	10 16       	cp	r1, r16
    2de4:	11 06       	cpc	r1, r17
    2de6:	24 f4       	brge	.+8      	; 0x2df0 <chb_write+0x134>
    2de8:	fa e6       	ldi	r31, 0x6A	; 106
    2dea:	fa 95       	dec	r31
    2dec:	f1 f7       	brne	.-4      	; 0x2dea <chb_write+0x12e>
    2dee:	00 c0       	rjmp	.+0      	; 0x2df0 <chb_write+0x134>
			if(rtry==20) return status;;		//after 20 tries give up on sending the message	
    2df0:	04 31       	cpi	r16, 0x14	; 20
    2df2:	11 05       	cpc	r17, r1
    2df4:	79 f0       	breq	.+30     	; 0x2e14 <chb_write+0x158>
		} while(status != CHB_SUCCESS);			
    2df6:	22 23       	and	r18, r18
    2df8:	51 f6       	brne	.-108    	; 0x2d8e <chb_write+0xd2>
        // adjust len and restart
		frm_offset += frm_len;
    2dfa:	ef 0c       	add	r14, r15
        len = len - frm_len;
    2dfc:	8f 18       	sub	r8, r15
    2dfe:	91 08       	sbc	r9, r1
    2e00:	a1 08       	sbc	r10, r1
    2e02:	b1 08       	sbc	r11, r1
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    2e04:	81 14       	cp	r8, r1
    2e06:	91 04       	cpc	r9, r1
    2e08:	a1 04       	cpc	r10, r1
    2e0a:	b1 04       	cpc	r11, r1
    2e0c:	09 f0       	breq	.+2      	; 0x2e10 <chb_write+0x154>
    2e0e:	8c cf       	rjmp	.-232    	; 0x2d28 <chb_write+0x6c>
    2e10:	01 c0       	rjmp	.+2      	; 0x2e14 <chb_write+0x158>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    2e12:	20 e0       	ldi	r18, 0x00	; 0
}
    2e14:	82 2f       	mov	r24, r18
    2e16:	2e 96       	adiw	r28, 0x0e	; 14
    2e18:	cd bf       	out	0x3d, r28	; 61
    2e1a:	de bf       	out	0x3e, r29	; 62
    2e1c:	df 91       	pop	r29
    2e1e:	cf 91       	pop	r28
    2e20:	1f 91       	pop	r17
    2e22:	0f 91       	pop	r16
    2e24:	ff 90       	pop	r15
    2e26:	ef 90       	pop	r14
    2e28:	df 90       	pop	r13
    2e2a:	cf 90       	pop	r12
    2e2c:	bf 90       	pop	r11
    2e2e:	af 90       	pop	r10
    2e30:	9f 90       	pop	r9
    2e32:	8f 90       	pop	r8
    2e34:	7f 90       	pop	r7
    2e36:	6f 90       	pop	r6
    2e38:	5f 90       	pop	r5
    2e3a:	4f 90       	pop	r4
    2e3c:	3f 90       	pop	r3
    2e3e:	2f 90       	pop	r2
    2e40:	08 95       	ret

00002e42 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    2e42:	df 92       	push	r13
    2e44:	ef 92       	push	r14
    2e46:	ff 92       	push	r15
    2e48:	0f 93       	push	r16
    2e4a:	1f 93       	push	r17
    2e4c:	cf 93       	push	r28
    2e4e:	df 93       	push	r29
    2e50:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    2e52:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <chb_buf_read>
    2e56:	d8 2e       	mov	r13, r24
    2e58:	88 23       	and	r24, r24
    2e5a:	0c f4       	brge	.+2      	; 0x2e5e <chb_read+0x1c>
    2e5c:	46 c0       	rjmp	.+140    	; 0x2eea <chb_read+0xa8>
    {
        return 0;
    }
    *data_ptr++ = len;
    2e5e:	f7 01       	movw	r30, r14
    2e60:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    2e62:	88 23       	and	r24, r24
    2e64:	71 f0       	breq	.+28     	; 0x2e82 <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
    2e66:	e7 01       	movw	r28, r14
    2e68:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
    2e6a:	87 01       	movw	r16, r14
    2e6c:	09 5f       	subi	r16, 0xF9	; 249
    2e6e:	1f 4f       	sbci	r17, 0xFF	; 255
    2e70:	81 50       	subi	r24, 0x01	; 1
    2e72:	08 0f       	add	r16, r24
    2e74:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
    2e76:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <chb_buf_read>
    2e7a:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    2e7c:	c0 17       	cp	r28, r16
    2e7e:	d1 07       	cpc	r29, r17
    2e80:	d1 f7       	brne	.-12     	; 0x2e76 <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
    2e82:	f7 01       	movw	r30, r14
    2e84:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
    2e86:	83 85       	ldd	r24, Z+11	; 0x0b
    2e88:	94 85       	ldd	r25, Z+12	; 0x0c
    2e8a:	83 83       	std	Z+3, r24	; 0x03
    2e8c:	94 83       	std	Z+4, r25	; 0x04
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
    2e8e:	85 85       	ldd	r24, Z+13	; 0x0d
    2e90:	96 85       	ldd	r25, Z+14	; 0x0e
    2e92:	81 83       	std	Z+1, r24	; 0x01
    2e94:	92 83       	std	Z+2, r25	; 0x02
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    2e96:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <chb_buf_get_len>
    2e9a:	88 23       	and	r24, r24
    2e9c:	11 f4       	brne	.+4      	; 0x2ea2 <chb_read+0x60>
    {
        pcb.data_rcv = false;
    2e9e:	10 92 41 21 	sts	0x2141, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    2ea2:	80 91 13 20 	lds	r24, 0x2013
    2ea6:	c8 17       	cp	r28, r24
    2ea8:	51 f4       	brne	.+20     	; 0x2ebe <chb_read+0x7c>
    2eaa:	f7 01       	movw	r30, r14
    2eac:	21 81       	ldd	r18, Z+1	; 0x01
    2eae:	32 81       	ldd	r19, Z+2	; 0x02
    2eb0:	80 91 14 20 	lds	r24, 0x2014
    2eb4:	90 91 15 20 	lds	r25, 0x2015
    2eb8:	28 17       	cp	r18, r24
    2eba:	39 07       	cpc	r19, r25
    2ebc:	c1 f0       	breq	.+48     	; 0x2eee <chb_read+0xac>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
    2ebe:	c0 93 13 20 	sts	0x2013, r28
        prev_src_addr = rx->src_addr;
    2ec2:	f7 01       	movw	r30, r14
    2ec4:	81 81       	ldd	r24, Z+1	; 0x01
    2ec6:	92 81       	ldd	r25, Z+2	; 0x02
    2ec8:	80 93 14 20 	sts	0x2014, r24
    2ecc:	90 93 15 20 	sts	0x2015, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    2ed0:	b7 01       	movw	r22, r14
    2ed2:	61 5f       	subi	r22, 0xF1	; 241
    2ed4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ed6:	4d 2d       	mov	r20, r13
    2ed8:	50 e0       	ldi	r21, 0x00	; 0
    2eda:	49 50       	subi	r20, 0x09	; 9
    2edc:	50 40       	sbci	r21, 0x00	; 0
    2ede:	c7 01       	movw	r24, r14
    2ee0:	0e 94 3f 3b 	call	0x767e	; 0x767e <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    2ee4:	8d 2d       	mov	r24, r13
    2ee6:	8b 50       	subi	r24, 0x0B	; 11
    2ee8:	03 c0       	rjmp	.+6      	; 0x2ef0 <chb_read+0xae>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    2eea:	80 e0       	ldi	r24, 0x00	; 0
    2eec:	01 c0       	rjmp	.+2      	; 0x2ef0 <chb_read+0xae>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    2eee:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
    2ef0:	df 91       	pop	r29
    2ef2:	cf 91       	pop	r28
    2ef4:	1f 91       	pop	r17
    2ef6:	0f 91       	pop	r16
    2ef8:	ff 90       	pop	r15
    2efa:	ef 90       	pop	r14
    2efc:	df 90       	pop	r13
    2efe:	08 95       	ret

00002f00 <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
    2f00:	10 92 52 21 	sts	0x2152, r1
    wr_ptr = 0;
    2f04:	10 92 53 21 	sts	0x2153, r1
    len = 0;
    2f08:	10 92 54 21 	sts	0x2154, r1
}
    2f0c:	08 95       	ret

00002f0e <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
    2f0e:	20 91 53 21 	lds	r18, 0x2153
    2f12:	30 e0       	ldi	r19, 0x00	; 0
    2f14:	f9 01       	movw	r30, r18
    2f16:	eb 5a       	subi	r30, 0xAB	; 171
    2f18:	fe 4d       	sbci	r31, 0xDE	; 222
    2f1a:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    2f1c:	c9 01       	movw	r24, r18
    2f1e:	01 96       	adiw	r24, 0x01	; 1
    2f20:	60 e8       	ldi	r22, 0x80	; 128
    2f22:	70 e0       	ldi	r23, 0x00	; 0
    2f24:	0e 94 b7 3a 	call	0x756e	; 0x756e <__divmodhi4>
    2f28:	80 93 53 21 	sts	0x2153, r24
    len++;
    2f2c:	80 91 54 21 	lds	r24, 0x2154
    2f30:	8f 5f       	subi	r24, 0xFF	; 255
    2f32:	80 93 54 21 	sts	0x2154, r24
}
    2f36:	08 95       	ret

00002f38 <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
    2f38:	20 91 52 21 	lds	r18, 0x2152
    2f3c:	30 e0       	ldi	r19, 0x00	; 0
    2f3e:	f9 01       	movw	r30, r18
    2f40:	eb 5a       	subi	r30, 0xAB	; 171
    2f42:	fe 4d       	sbci	r31, 0xDE	; 222
    2f44:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    2f46:	2f 5f       	subi	r18, 0xFF	; 255
    2f48:	3f 4f       	sbci	r19, 0xFF	; 255
    2f4a:	c9 01       	movw	r24, r18
    2f4c:	60 e8       	ldi	r22, 0x80	; 128
    2f4e:	70 e0       	ldi	r23, 0x00	; 0
    2f50:	0e 94 b7 3a 	call	0x756e	; 0x756e <__divmodhi4>
    2f54:	80 93 52 21 	sts	0x2152, r24
    len--;
    2f58:	80 91 54 21 	lds	r24, 0x2154
    2f5c:	81 50       	subi	r24, 0x01	; 1
    2f5e:	80 93 54 21 	sts	0x2154, r24
    return data;
}
    2f62:	84 2f       	mov	r24, r20
    2f64:	08 95       	ret

00002f66 <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
    2f66:	80 91 54 21 	lds	r24, 0x2154
    2f6a:	08 95       	ret

00002f6c <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    2f6c:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    2f6e:	80 e0       	ldi	r24, 0x00	; 0
    2f70:	90 e0       	ldi	r25, 0x00	; 0
    2f72:	48 e0       	ldi	r20, 0x08	; 8
    2f74:	50 e0       	ldi	r21, 0x00	; 0
    2f76:	0e 94 1f 1c 	call	0x383e	; 0x383e <chb_eeprom_read>
}
    2f7a:	08 95       	ret

00002f7c <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    2f7c:	cf 93       	push	r28
    2f7e:	df 93       	push	r29
    2f80:	0f 92       	push	r0
    2f82:	0f 92       	push	r0
    2f84:	cd b7       	in	r28, 0x3d	; 61
    2f86:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    2f88:	89 e0       	ldi	r24, 0x09	; 9
    2f8a:	90 e0       	ldi	r25, 0x00	; 0
    2f8c:	be 01       	movw	r22, r28
    2f8e:	6f 5f       	subi	r22, 0xFF	; 255
    2f90:	7f 4f       	sbci	r23, 0xFF	; 255
    2f92:	42 e0       	ldi	r20, 0x02	; 2
    2f94:	50 e0       	ldi	r21, 0x00	; 0
    2f96:	0e 94 1f 1c 	call	0x383e	; 0x383e <chb_eeprom_read>
    return *(U16 *)addr;
}
    2f9a:	89 81       	ldd	r24, Y+1	; 0x01
    2f9c:	9a 81       	ldd	r25, Y+2	; 0x02
    2f9e:	0f 90       	pop	r0
    2fa0:	0f 90       	pop	r0
    2fa2:	df 91       	pop	r29
    2fa4:	cf 91       	pop	r28
    2fa6:	08 95       	ret

00002fa8 <RadioCS>:
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
}

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    2fa8:	88 23       	and	r24, r24
    2faa:	29 f0       	breq	.+10     	; 0x2fb6 <RadioCS+0xe>
    2fac:	80 e1       	ldi	r24, 0x10	; 16
    2fae:	e0 e6       	ldi	r30, 0x60	; 96
    2fb0:	f6 e0       	ldi	r31, 0x06	; 6
    2fb2:	86 83       	std	Z+6, r24	; 0x06
    2fb4:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    2fb6:	80 e1       	ldi	r24, 0x10	; 16
    2fb8:	e0 e6       	ldi	r30, 0x60	; 96
    2fba:	f6 e0       	ldi	r31, 0x06	; 6
    2fbc:	85 83       	std	Z+5, r24	; 0x05
    2fbe:	08 95       	ret

00002fc0 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    2fc0:	df 92       	push	r13
    2fc2:	ef 92       	push	r14
    2fc4:	ff 92       	push	r15
    2fc6:	0f 93       	push	r16
    2fc8:	1f 93       	push	r17
    2fca:	cf 93       	push	r28
    2fcc:	df 93       	push	r29
    2fce:	8c 01       	movw	r16, r24
    2fd0:	c6 2f       	mov	r28, r22
    2fd2:	7a 01       	movw	r14, r20
    2fd4:	d2 2e       	mov	r13, r18
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    2fd6:	82 2f       	mov	r24, r18
    2fd8:	90 e0       	ldi	r25, 0x00	; 0
    2fda:	86 0f       	add	r24, r22
    2fdc:	91 1d       	adc	r25, r1
    2fde:	80 38       	cpi	r24, 0x80	; 128
    2fe0:	91 05       	cpc	r25, r1
    2fe2:	8c f5       	brge	.+98     	; 0x3046 <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    2fe4:	8f b7       	in	r24, 0x3f	; 63
    2fe6:	80 93 56 40 	sts	0x4056, r24
    2fea:	f8 94       	cli
    RadioCS(TRUE); 
    2fec:	81 e0       	ldi	r24, 0x01	; 1
    2fee:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    2ff2:	80 e6       	ldi	r24, 0x60	; 96
    2ff4:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    2ff8:	cc 23       	and	r28, r28
    2ffa:	79 f0       	breq	.+30     	; 0x301a <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    2ffc:	c8 01       	movw	r24, r16
    2ffe:	01 96       	adiw	r24, 0x01	; 1
    3000:	c1 50       	subi	r28, 0x01	; 1
    3002:	9c 01       	movw	r18, r24
    3004:	2c 0f       	add	r18, r28
    3006:	31 1d       	adc	r19, r1
    3008:	e9 01       	movw	r28, r18

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    300a:	f8 01       	movw	r30, r16
    300c:	81 91       	ld	r24, Z+
    300e:	8f 01       	movw	r16, r30
    3010:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    3014:	0c 17       	cp	r16, r28
    3016:	1d 07       	cpc	r17, r29
    3018:	c1 f7       	brne	.-16     	; 0x300a <chb_frame_write+0x4a>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    301a:	dd 20       	and	r13, r13
    301c:	69 f0       	breq	.+26     	; 0x3038 <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    301e:	e7 01       	movw	r28, r14
    3020:	21 96       	adiw	r28, 0x01	; 1
    3022:	da 94       	dec	r13
    3024:	cd 0d       	add	r28, r13
    3026:	d1 1d       	adc	r29, r1

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    3028:	f7 01       	movw	r30, r14
    302a:	81 91       	ld	r24, Z+
    302c:	7f 01       	movw	r14, r30
    302e:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    3032:	ec 16       	cp	r14, r28
    3034:	fd 06       	cpc	r15, r29
    3036:	c1 f7       	brne	.-16     	; 0x3028 <chb_frame_write+0x68>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    3038:	80 e0       	ldi	r24, 0x00	; 0
    303a:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <RadioCS>
    CHB_LEAVE_CRIT();
    303e:	80 91 56 40 	lds	r24, 0x4056
    3042:	8f bf       	out	0x3f, r24	; 63
    3044:	78 94       	sei
}
    3046:	df 91       	pop	r29
    3048:	cf 91       	pop	r28
    304a:	1f 91       	pop	r17
    304c:	0f 91       	pop	r16
    304e:	ff 90       	pop	r15
    3050:	ef 90       	pop	r14
    3052:	df 90       	pop	r13
    3054:	08 95       	ret

00003056 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    3056:	cf 93       	push	r28
    3058:	df 93       	push	r29
    305a:	d8 2f       	mov	r29, r24
    305c:	c6 2f       	mov	r28, r22
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
    305e:	8f b7       	in	r24, 0x3f	; 63
    3060:	80 93 56 40 	sts	0x4056, r24
    3064:	f8 94       	cli
    RadioCS(TRUE);
    3066:	81 e0       	ldi	r24, 0x01	; 1
    3068:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    306c:	8d 2f       	mov	r24, r29
    306e:	80 6c       	ori	r24, 0xC0	; 192
    3070:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    3074:	8c 2f       	mov	r24, r28
    3076:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <SPID_write>

    RadioCS(FALSE);
    307a:	80 e0       	ldi	r24, 0x00	; 0
    307c:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <RadioCS>
    CHB_LEAVE_CRIT();
    3080:	80 91 56 40 	lds	r24, 0x4056
    3084:	8f bf       	out	0x3f, r24	; 63
    3086:	78 94       	sei
}
    3088:	df 91       	pop	r29
    308a:	cf 91       	pop	r28
    308c:	08 95       	ret

0000308e <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    308e:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
    3090:	85 e0       	ldi	r24, 0x05	; 5
    3092:	0e 94 2b 18 	call	0x3056	; 0x3056 <chb_reg_write>
}
    3096:	08 95       	ret

00003098 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    3098:	0f 93       	push	r16
    309a:	1f 93       	push	r17
    309c:	cf 93       	push	r28
    309e:	df 93       	push	r29
    30a0:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
    30a2:	c6 2f       	mov	r28, r22
    30a4:	d7 2f       	mov	r29, r23
    30a6:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
    30a8:	69 91       	ld	r22, Y+
    30aa:	81 2f       	mov	r24, r17
    30ac:	80 0f       	add	r24, r16
    30ae:	0e 94 2b 18 	call	0x3056	; 0x3056 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    30b2:	1f 5f       	subi	r17, 0xFF	; 255
    30b4:	18 30       	cpi	r17, 0x08	; 8
    30b6:	c1 f7       	brne	.-16     	; 0x30a8 <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    30b8:	df 91       	pop	r29
    30ba:	cf 91       	pop	r28
    30bc:	1f 91       	pop	r17
    30be:	0f 91       	pop	r16
    30c0:	08 95       	ret

000030c2 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    30c2:	cf 93       	push	r28
    30c4:	df 93       	push	r29
    30c6:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    30c8:	80 e0       	ldi	r24, 0x00	; 0
    30ca:	90 e0       	ldi	r25, 0x00	; 0
    30cc:	be 01       	movw	r22, r28
    30ce:	48 e0       	ldi	r20, 0x08	; 8
    30d0:	50 e0       	ldi	r21, 0x00	; 0
    30d2:	0e 94 bc 1b 	call	0x3778	; 0x3778 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    30d6:	84 e2       	ldi	r24, 0x24	; 36
    30d8:	be 01       	movw	r22, r28
    30da:	0e 94 4c 18 	call	0x3098	; 0x3098 <chb_reg_write64>
}
    30de:	df 91       	pop	r29
    30e0:	cf 91       	pop	r28
    30e2:	08 95       	ret

000030e4 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    30e4:	cf 93       	push	r28
    30e6:	df 93       	push	r29
    30e8:	c8 2f       	mov	r28, r24
    30ea:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
    30ec:	0e 94 2b 18 	call	0x3056	; 0x3056 <chb_reg_write>
    30f0:	8c 2f       	mov	r24, r28
    30f2:	8f 5f       	subi	r24, 0xFF	; 255
    30f4:	6d 2f       	mov	r22, r29
    30f6:	0e 94 2b 18 	call	0x3056	; 0x3056 <chb_reg_write>
    }
}
    30fa:	df 91       	pop	r29
    30fc:	cf 91       	pop	r28
    30fe:	08 95       	ret

00003100 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    3100:	0f 93       	push	r16
    3102:	1f 93       	push	r17
    3104:	cf 93       	push	r28
    3106:	df 93       	push	r29
    3108:	0f 92       	push	r0
    310a:	0f 92       	push	r0
    310c:	cd b7       	in	r28, 0x3d	; 61
    310e:	de b7       	in	r29, 0x3e	; 62
    3110:	89 83       	std	Y+1, r24	; 0x01
    3112:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
    3114:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <chb_get_pcb>
    3118:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    311a:	89 e0       	ldi	r24, 0x09	; 9
    311c:	90 e0       	ldi	r25, 0x00	; 0
    311e:	be 01       	movw	r22, r28
    3120:	6f 5f       	subi	r22, 0xFF	; 255
    3122:	7f 4f       	sbci	r23, 0xFF	; 255
    3124:	42 e0       	ldi	r20, 0x02	; 2
    3126:	50 e0       	ldi	r21, 0x00	; 0
    3128:	0e 94 bc 1b 	call	0x3778	; 0x3778 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    312c:	69 81       	ldd	r22, Y+1	; 0x01
    312e:	7a 81       	ldd	r23, Y+2	; 0x02
    3130:	80 e2       	ldi	r24, 0x20	; 32
    3132:	0e 94 72 18 	call	0x30e4	; 0x30e4 <chb_reg_write16>
    pcb->src_addr = addr;
    3136:	89 81       	ldd	r24, Y+1	; 0x01
    3138:	9a 81       	ldd	r25, Y+2	; 0x02
    313a:	f8 01       	movw	r30, r16
    313c:	80 83       	st	Z, r24
    313e:	91 83       	std	Z+1, r25	; 0x01
}
    3140:	0f 90       	pop	r0
    3142:	0f 90       	pop	r0
    3144:	df 91       	pop	r29
    3146:	cf 91       	pop	r28
    3148:	1f 91       	pop	r17
    314a:	0f 91       	pop	r16
    314c:	08 95       	ret

0000314e <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    314e:	cf 93       	push	r28
    3150:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
    3152:	8f b7       	in	r24, 0x3f	; 63
    3154:	80 93 56 40 	sts	0x4056, r24
    3158:	f8 94       	cli
    RadioCS(TRUE);
    315a:	81 e0       	ldi	r24, 0x01	; 1
    315c:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    3160:	8c 2f       	mov	r24, r28
    3162:	80 68       	ori	r24, 0x80	; 128
    3164:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <SPID_write>
    val = SPID_write(val);
    3168:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <SPID_write>
    316c:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    316e:	80 e0       	ldi	r24, 0x00	; 0
    3170:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <RadioCS>
    CHB_LEAVE_CRIT();
    3174:	80 91 56 40 	lds	r24, 0x4056
    3178:	8f bf       	out	0x3f, r24	; 63
    317a:	78 94       	sei

    return val;
}
    317c:	8c 2f       	mov	r24, r28
    317e:	cf 91       	pop	r28
    3180:	08 95       	ret

00003182 <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
    3182:	81 e0       	ldi	r24, 0x01	; 1
    3184:	0e 94 a7 18 	call	0x314e	; 0x314e <chb_reg_read>
}
    3188:	8f 71       	andi	r24, 0x1F	; 31
    318a:	08 95       	ret

0000318c <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    318c:	1f 93       	push	r17
    318e:	cf 93       	push	r28
    3190:	df 93       	push	r29
    3192:	c8 2f       	mov	r28, r24
    3194:	16 2f       	mov	r17, r22
    3196:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
    3198:	0e 94 a7 18 	call	0x314e	; 0x314e <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
    319c:	6d 2f       	mov	r22, r29
    319e:	60 95       	com	r22
    31a0:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
    31a2:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
    31a4:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
    31a6:	8c 2f       	mov	r24, r28
    31a8:	0e 94 2b 18 	call	0x3056	; 0x3056 <chb_reg_write>
}
    31ac:	df 91       	pop	r29
    31ae:	cf 91       	pop	r28
    31b0:	1f 91       	pop	r17
    31b2:	08 95       	ret

000031b4 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    31b4:	cf 93       	push	r28
    31b6:	df 93       	push	r29
    31b8:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    31ba:	80 91 64 06 	lds	r24, 0x0664
    31be:	81 fd       	sbrc	r24, 1
    31c0:	4b c0       	rjmp	.+150    	; 0x3258 <chb_set_state+0xa4>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    31c2:	0e 94 c1 18 	call	0x3182	; 0x3182 <chb_get_state>
    31c6:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    31c8:	81 51       	subi	r24, 0x11	; 17
    31ca:	82 30       	cpi	r24, 0x02	; 2
    31cc:	20 f0       	brcs	.+8      	; 0x31d6 <chb_set_state+0x22>
    31ce:	c1 30       	cpi	r28, 0x01	; 1
    31d0:	11 f0       	breq	.+4      	; 0x31d6 <chb_set_state+0x22>
    31d2:	c2 30       	cpi	r28, 0x02	; 2
    31d4:	21 f4       	brne	.+8      	; 0x31de <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
    31d6:	0e 94 c1 18 	call	0x3182	; 0x3182 <chb_get_state>
    31da:	8c 17       	cp	r24, r28
    31dc:	e1 f3       	breq	.-8      	; 0x31d6 <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    31de:	d6 31       	cpi	r29, 0x16	; 22
    31e0:	f9 f0       	breq	.+62     	; 0x3220 <chb_set_state+0x6c>
    31e2:	d9 31       	cpi	r29, 0x19	; 25
    31e4:	89 f0       	breq	.+34     	; 0x3208 <chb_set_state+0x54>
    31e6:	d8 30       	cpi	r29, 0x08	; 8
    31e8:	31 f5       	brne	.+76     	; 0x3236 <chb_set_state+0x82>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    31ea:	e4 e6       	ldi	r30, 0x64	; 100
    31ec:	f6 e0       	ldi	r31, 0x06	; 6
    31ee:	80 81       	ld	r24, Z
    31f0:	8d 7f       	andi	r24, 0xFD	; 253
    31f2:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    31f4:	82 e0       	ldi	r24, 0x02	; 2
    31f6:	63 e0       	ldi	r22, 0x03	; 3
    31f8:	4f e1       	ldi	r20, 0x1F	; 31
    31fa:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>
    31fe:	8a e0       	ldi	r24, 0x0A	; 10
    3200:	8a 95       	dec	r24
    3202:	f1 f7       	brne	.-4      	; 0x3200 <chb_set_state+0x4c>
    3204:	00 c0       	rjmp	.+0      	; 0x3206 <chb_set_state+0x52>
    3206:	17 c0       	rjmp	.+46     	; 0x3236 <chb_set_state+0x82>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    3208:	c6 31       	cpi	r28, 0x16	; 22
    320a:	a9 f4       	brne	.+42     	; 0x3236 <chb_set_state+0x82>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    320c:	82 e0       	ldi	r24, 0x02	; 2
    320e:	69 e0       	ldi	r22, 0x09	; 9
    3210:	4f e1       	ldi	r20, 0x1F	; 31
    3212:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>
    3216:	9a e0       	ldi	r25, 0x0A	; 10
    3218:	9a 95       	dec	r25
    321a:	f1 f7       	brne	.-4      	; 0x3218 <chb_set_state+0x64>
    321c:	00 c0       	rjmp	.+0      	; 0x321e <chb_set_state+0x6a>
    321e:	0b c0       	rjmp	.+22     	; 0x3236 <chb_set_state+0x82>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    3220:	c9 31       	cpi	r28, 0x19	; 25
    3222:	49 f4       	brne	.+18     	; 0x3236 <chb_set_state+0x82>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    3224:	82 e0       	ldi	r24, 0x02	; 2
    3226:	69 e0       	ldi	r22, 0x09	; 9
    3228:	4f e1       	ldi	r20, 0x1F	; 31
    322a:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>
    322e:	8a e0       	ldi	r24, 0x0A	; 10
    3230:	8a 95       	dec	r24
    3232:	f1 f7       	brne	.-4      	; 0x3230 <chb_set_state+0x7c>
    3234:	00 c0       	rjmp	.+0      	; 0x3236 <chb_set_state+0x82>
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    3236:	82 e0       	ldi	r24, 0x02	; 2
    3238:	6d 2f       	mov	r22, r29
    323a:	4f e1       	ldi	r20, 0x1F	; 31
    323c:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>
    3240:	8f e6       	ldi	r24, 0x6F	; 111
    3242:	93 e0       	ldi	r25, 0x03	; 3
    3244:	01 97       	sbiw	r24, 0x01	; 1
    3246:	f1 f7       	brne	.-4      	; 0x3244 <chb_set_state+0x90>
    3248:	00 c0       	rjmp	.+0      	; 0x324a <chb_set_state+0x96>
    324a:	00 00       	nop

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    324c:	0e 94 c1 18 	call	0x3182	; 0x3182 <chb_get_state>
    3250:	8d 17       	cp	r24, r29
    3252:	21 f4       	brne	.+8      	; 0x325c <chb_set_state+0xa8>
    {
        return RADIO_SUCCESS;
    3254:	80 e4       	ldi	r24, 0x40	; 64
    3256:	03 c0       	rjmp	.+6      	; 0x325e <chb_set_state+0xaa>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
    3258:	84 e4       	ldi	r24, 0x44	; 68
    325a:	01 c0       	rjmp	.+2      	; 0x325e <chb_set_state+0xaa>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
    325c:	83 e4       	ldi	r24, 0x43	; 67
}
    325e:	df 91       	pop	r29
    3260:	cf 91       	pop	r28
    3262:	08 95       	ret

00003264 <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
    3264:	88 23       	and	r24, r24
    3266:	49 f0       	breq	.+18     	; 0x327a <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    3268:	88 e0       	ldi	r24, 0x08	; 8
    326a:	0e 94 da 18 	call	0x31b4	; 0x31b4 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    326e:	e4 e6       	ldi	r30, 0x64	; 100
    3270:	f6 e0       	ldi	r31, 0x06	; 6
    3272:	80 81       	ld	r24, Z
    3274:	82 60       	ori	r24, 0x02	; 2
    3276:	80 83       	st	Z, r24
    3278:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    327a:	e4 e6       	ldi	r30, 0x64	; 100
    327c:	f6 e0       	ldi	r31, 0x06	; 6
    327e:	80 81       	ld	r24, Z
    3280:	8d 7f       	andi	r24, 0xFD	; 253
    3282:	80 83       	st	Z, r24
    3284:	8f e7       	ldi	r24, 0x7F	; 127
    3286:	97 e0       	ldi	r25, 0x07	; 7
    3288:	01 97       	sbiw	r24, 0x01	; 1
    328a:	f1 f7       	brne	.-4      	; 0x3288 <chb_sleep+0x24>
    328c:	00 c0       	rjmp	.+0      	; 0x328e <chb_sleep+0x2a>
    328e:	00 00       	nop

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    3290:	86 e1       	ldi	r24, 0x16	; 22
    3292:	0e 94 da 18 	call	0x31b4	; 0x31b4 <chb_set_state>
    3296:	08 95       	ret

00003298 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    3298:	cf 92       	push	r12
    329a:	df 92       	push	r13
    329c:	ef 92       	push	r14
    329e:	ff 92       	push	r15
    32a0:	0f 93       	push	r16
    32a2:	1f 93       	push	r17
    32a4:	cf 93       	push	r28
    32a6:	df 93       	push	r29
    32a8:	7c 01       	movw	r14, r24
    32aa:	6b 01       	movw	r12, r22
    32ac:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
    32ae:	0e 94 c1 18 	call	0x3182	; 0x3182 <chb_get_state>
    32b2:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
    32b4:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <chb_get_pcb>
    32b8:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    32ba:	12 30       	cpi	r17, 0x02	; 2
    32bc:	f1 f0       	breq	.+60     	; 0x32fa <chb_tx+0x62>
    32be:	12 31       	cpi	r17, 0x12	; 18
    32c0:	f1 f0       	breq	.+60     	; 0x32fe <chb_tx+0x66>
    {
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    32c2:	88 e0       	ldi	r24, 0x08	; 8
    32c4:	0e 94 da 18 	call	0x31b4	; 0x31b4 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    32c8:	89 e1       	ldi	r24, 0x19	; 25
    32ca:	0e 94 da 18 	call	0x31b4	; 0x31b4 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    32ce:	c7 01       	movw	r24, r14
    32d0:	6a e0       	ldi	r22, 0x0A	; 10
    32d2:	a6 01       	movw	r20, r12
    32d4:	20 2f       	mov	r18, r16
    32d6:	0e 94 e0 17 	call	0x2fc0	; 0x2fc0 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    32da:	82 e0       	ldi	r24, 0x02	; 2
    32dc:	62 e0       	ldi	r22, 0x02	; 2
    32de:	4f e1       	ldi	r20, 0x1F	; 31
    32e0:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    32e4:	8c 81       	ldd	r24, Y+4	; 0x04
    32e6:	88 23       	and	r24, r24
    32e8:	e9 f3       	breq	.-6      	; 0x32e4 <chb_tx+0x4c>
    pcb->tx_end = false;
    32ea:	1c 82       	std	Y+4, r1	; 0x04

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    32ec:	82 e0       	ldi	r24, 0x02	; 2
    32ee:	0e 94 a7 18 	call	0x314e	; 0x314e <chb_reg_read>
    32f2:	82 95       	swap	r24
    32f4:	86 95       	lsr	r24
    32f6:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
    32f8:	03 c0       	rjmp	.+6      	; 0x3300 <chb_tx+0x68>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
    32fa:	84 e4       	ldi	r24, 0x44	; 68
    32fc:	01 c0       	rjmp	.+2      	; 0x3300 <chb_tx+0x68>
    32fe:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
    3300:	df 91       	pop	r29
    3302:	cf 91       	pop	r28
    3304:	1f 91       	pop	r17
    3306:	0f 91       	pop	r16
    3308:	ff 90       	pop	r15
    330a:	ef 90       	pop	r14
    330c:	df 90       	pop	r13
    330e:	cf 90       	pop	r12
    3310:	08 95       	ret

00003312 <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
    3312:	81 30       	cpi	r24, 0x01	; 1
    3314:	91 f0       	breq	.+36     	; 0x333a <chb_set_mode+0x28>
    3316:	81 30       	cpi	r24, 0x01	; 1
    3318:	28 f0       	brcs	.+10     	; 0x3324 <chb_set_mode+0x12>
    331a:	82 30       	cpi	r24, 0x02	; 2
    331c:	c9 f0       	breq	.+50     	; 0x3350 <chb_set_mode+0x3e>
    331e:	83 30       	cpi	r24, 0x03	; 3
    3320:	61 f5       	brne	.+88     	; 0x337a <chb_set_mode+0x68>
    3322:	21 c0       	rjmp	.+66     	; 0x3366 <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    3324:	8c e0       	ldi	r24, 0x0C	; 12
    3326:	68 e0       	ldi	r22, 0x08	; 8
    3328:	4f e3       	ldi	r20, 0x3F	; 63
    332a:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    332e:	86 e1       	ldi	r24, 0x16	; 22
    3330:	62 e0       	ldi	r22, 0x02	; 2
    3332:	43 e0       	ldi	r20, 0x03	; 3
    3334:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>
        break;
    3338:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    333a:	8c e0       	ldi	r24, 0x0C	; 12
    333c:	6c e0       	ldi	r22, 0x0C	; 12
    333e:	4f e3       	ldi	r20, 0x3F	; 63
    3340:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    3344:	86 e1       	ldi	r24, 0x16	; 22
    3346:	62 e0       	ldi	r22, 0x02	; 2
    3348:	43 e0       	ldi	r20, 0x03	; 3
    334a:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>
        break;
    334e:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    3350:	8c e0       	ldi	r24, 0x0C	; 12
    3352:	6c e1       	ldi	r22, 0x1C	; 28
    3354:	4f e3       	ldi	r20, 0x3F	; 63
    3356:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    335a:	86 e1       	ldi	r24, 0x16	; 22
    335c:	62 e0       	ldi	r22, 0x02	; 2
    335e:	43 e0       	ldi	r20, 0x03	; 3
    3360:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>
        break;
    3364:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    3366:	8c e0       	ldi	r24, 0x0C	; 12
    3368:	60 e0       	ldi	r22, 0x00	; 0
    336a:	4f e3       	ldi	r20, 0x3F	; 63
    336c:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    3370:	86 e1       	ldi	r24, 0x16	; 22
    3372:	63 e0       	ldi	r22, 0x03	; 3
    3374:	43 e0       	ldi	r20, 0x03	; 3
    3376:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>
    337a:	08 95       	ret

0000337c <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    337c:	cf 93       	push	r28
    337e:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    3380:	88 e0       	ldi	r24, 0x08	; 8
    3382:	6c 2f       	mov	r22, r28
    3384:	4f e1       	ldi	r20, 0x1F	; 31
    3386:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    338a:	0e 94 c1 18 	call	0x3182	; 0x3182 <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    338e:	86 30       	cpi	r24, 0x06	; 6
    3390:	11 f0       	breq	.+4      	; 0x3396 <chb_set_channel+0x1a>
    3392:	89 30       	cpi	r24, 0x09	; 9
    3394:	31 f4       	brne	.+12     	; 0x33a2 <chb_set_channel+0x26>
    3396:	8f e6       	ldi	r24, 0x6F	; 111
    3398:	93 e0       	ldi	r25, 0x03	; 3
    339a:	01 97       	sbiw	r24, 0x01	; 1
    339c:	f1 f7       	brne	.-4      	; 0x339a <chb_set_channel+0x1e>
    339e:	00 c0       	rjmp	.+0      	; 0x33a0 <chb_set_channel+0x24>
    33a0:	00 00       	nop
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    33a2:	88 e0       	ldi	r24, 0x08	; 8
    33a4:	0e 94 a7 18 	call	0x314e	; 0x314e <chb_reg_read>
    33a8:	90 e0       	ldi	r25, 0x00	; 0
    33aa:	8f 71       	andi	r24, 0x1F	; 31
    33ac:	90 70       	andi	r25, 0x00	; 0
    33ae:	6c 2f       	mov	r22, r28
    33b0:	70 e0       	ldi	r23, 0x00	; 0
    33b2:	86 17       	cp	r24, r22
    33b4:	97 07       	cpc	r25, r23
    33b6:	11 f4       	brne	.+4      	; 0x33bc <chb_set_channel+0x40>
    33b8:	80 e4       	ldi	r24, 0x40	; 64
    33ba:	01 c0       	rjmp	.+2      	; 0x33be <chb_set_channel+0x42>
    33bc:	83 e4       	ldi	r24, 0x43	; 67
}
    33be:	cf 91       	pop	r28
    33c0:	08 95       	ret

000033c2 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    33c2:	cf 93       	push	r28
    33c4:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    33c6:	0e 94 a7 18 	call	0x314e	; 0x314e <chb_reg_read>
    33ca:	8c 2b       	or	r24, r28
    33cc:	8f 5f       	subi	r24, 0xFF	; 255
    33ce:	0e 94 a7 18 	call	0x314e	; 0x314e <chb_reg_read>
    }
    return val;
}
    33d2:	80 e0       	ldi	r24, 0x00	; 0
    33d4:	90 e0       	ldi	r25, 0x00	; 0
    33d6:	cf 91       	pop	r28
    33d8:	08 95       	ret

000033da <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
    33da:	e4 e6       	ldi	r30, 0x64	; 100
    33dc:	f6 e0       	ldi	r31, 0x06	; 6
    33de:	80 81       	ld	r24, Z
    33e0:	81 60       	ori	r24, 0x01	; 1
    33e2:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
    33e4:	80 81       	ld	r24, Z
    33e6:	8d 7f       	andi	r24, 0xFD	; 253
    33e8:	80 83       	st	Z, r24
    33ea:	8f ed       	ldi	r24, 0xDF	; 223
    33ec:	9b e0       	ldi	r25, 0x0B	; 11
    33ee:	01 97       	sbiw	r24, 0x01	; 1
    33f0:	f1 f7       	brne	.-4      	; 0x33ee <chb_reset+0x14>
    33f2:	00 c0       	rjmp	.+0      	; 0x33f4 <chb_reset+0x1a>
    33f4:	00 00       	nop

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    33f6:	80 81       	ld	r24, Z
    33f8:	8e 7f       	andi	r24, 0xFE	; 254
    33fa:	80 83       	st	Z, r24
    33fc:	9a e0       	ldi	r25, 0x0A	; 10
    33fe:	9a 95       	dec	r25
    3400:	f1 f7       	brne	.-4      	; 0x33fe <chb_reset+0x24>
    3402:	00 c0       	rjmp	.+0      	; 0x3404 <chb_reset+0x2a>
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    3404:	80 81       	ld	r24, Z
    3406:	81 60       	ori	r24, 0x01	; 1
    3408:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    340a:	8d e1       	ldi	r24, 0x1D	; 29
    340c:	0e 94 a7 18 	call	0x314e	; 0x314e <chb_reg_read>
    3410:	81 30       	cpi	r24, 0x01	; 1
    3412:	d9 f7       	brne	.-10     	; 0x340a <chb_reset+0x30>
    3414:	8c e1       	ldi	r24, 0x1C	; 28
    3416:	0e 94 a7 18 	call	0x314e	; 0x314e <chb_reg_read>
    341a:	87 30       	cpi	r24, 0x07	; 7
    341c:	b1 f7       	brne	.-20     	; 0x340a <chb_reset+0x30>
            break;
        }
    }
	

}
    341e:	08 95       	ret

00003420 <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    3420:	0f 93       	push	r16
    3422:	1f 93       	push	r17
    3424:	cf 93       	push	r28
    3426:	df 93       	push	r29
    3428:	cd b7       	in	r28, 0x3d	; 61
    342a:	de b7       	in	r29, 0x3e	; 62
    342c:	ea 97       	sbiw	r28, 0x3a	; 58
    342e:	cd bf       	out	0x3d, r28	; 61
    3430:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    3432:	0e 94 57 1c 	call	0x38ae	; 0x38ae <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    3436:	e0 e6       	ldi	r30, 0x60	; 96
    3438:	f6 e0       	ldi	r31, 0x06	; 6
    343a:	80 81       	ld	r24, Z
    343c:	82 60       	ori	r24, 0x02	; 2
    343e:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    3440:	80 81       	ld	r24, Z
    3442:	81 60       	ori	r24, 0x01	; 1
    3444:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    3446:	0e 94 ed 19 	call	0x33da	; 0x33da <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    344a:	8e e0       	ldi	r24, 0x0E	; 14
    344c:	60 e0       	ldi	r22, 0x00	; 0
    344e:	0e 94 2b 18 	call	0x3056	; 0x3056 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    3452:	82 e0       	ldi	r24, 0x02	; 2
    3454:	63 e0       	ldi	r22, 0x03	; 3
    3456:	4f e1       	ldi	r20, 0x1F	; 31
    3458:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    345c:	81 e0       	ldi	r24, 0x01	; 1
    345e:	0e 94 a7 18 	call	0x314e	; 0x314e <chb_reg_read>
    3462:	8f 71       	andi	r24, 0x1F	; 31
    3464:	88 30       	cpi	r24, 0x08	; 8
    3466:	d1 f7       	brne	.-12     	; 0x345c <chb_drvr_init+0x3c>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    3468:	8e e2       	ldi	r24, 0x2E	; 46
    346a:	60 e4       	ldi	r22, 0x40	; 64
    346c:	40 ec       	ldi	r20, 0xC0	; 192
    346e:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    3472:	8e e0       	ldi	r24, 0x0E	; 14
    3474:	6c e0       	ldi	r22, 0x0C	; 12
    3476:	0e 94 2b 18 	call	0x3056	; 0x3056 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    347a:	84 e0       	ldi	r24, 0x04	; 4
    347c:	60 e2       	ldi	r22, 0x20	; 32
    347e:	40 e2       	ldi	r20, 0x20	; 32
    3480:	0e 94 c6 18 	call	0x318c	; 0x318c <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    3484:	81 e0       	ldi	r24, 0x01	; 1
    3486:	0e 94 89 19 	call	0x3312	; 0x3312 <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    348a:	81 e0       	ldi	r24, 0x01	; 1
    348c:	0e 94 be 19 	call	0x337c	; 0x337c <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    3490:	86 e1       	ldi	r24, 0x16	; 22
    3492:	0e 94 da 18 	call	0x31b4	; 0x31b4 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    3496:	82 e2       	ldi	r24, 0x22	; 34
    3498:	64 e3       	ldi	r22, 0x34	; 52
    349a:	72 e1       	ldi	r23, 0x12	; 18
    349c:	0e 94 72 18 	call	0x30e4	; 0x30e4 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    34a0:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <chb_get_short_addr>
    34a4:	bc 01       	movw	r22, r24
    34a6:	80 e2       	ldi	r24, 0x20	; 32
    34a8:	0e 94 72 18 	call	0x30e4	; 0x30e4 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    34ac:	ce 01       	movw	r24, r28
    34ae:	01 96       	adiw	r24, 0x01	; 1
    34b0:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    34b4:	84 e2       	ldi	r24, 0x24	; 36
    34b6:	be 01       	movw	r22, r28
    34b8:	6f 5f       	subi	r22, 0xFF	; 255
    34ba:	7f 4f       	sbci	r23, 0xFF	; 255
    34bc:	0e 94 4c 18 	call	0x3098	; 0x3098 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    34c0:	e2 e7       	ldi	r30, 0x72	; 114
    34c2:	f6 e0       	ldi	r31, 0x06	; 6
    34c4:	80 81       	ld	r24, Z
    34c6:	81 60       	ori	r24, 0x01	; 1
    34c8:	80 83       	st	Z, r24
    34ca:	e9 e6       	ldi	r30, 0x69	; 105
    34cc:	f6 e0       	ldi	r31, 0x06	; 6
    34ce:	80 81       	ld	r24, Z
    34d0:	83 60       	ori	r24, 0x03	; 3
    34d2:	80 83       	st	Z, r24
    34d4:	ea e6       	ldi	r30, 0x6A	; 106
    34d6:	f6 e0       	ldi	r31, 0x06	; 6
    34d8:	80 81       	ld	r24, Z
    34da:	84 60       	ori	r24, 0x04	; 4
    34dc:	80 83       	st	Z, r24
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    34de:	e0 ea       	ldi	r30, 0xA0	; 160
    34e0:	f0 e0       	ldi	r31, 0x00	; 0
    34e2:	82 81       	ldd	r24, Z+2	; 0x02
    34e4:	87 60       	ori	r24, 0x07	; 7
    34e6:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
    34e8:	0e 94 c1 18 	call	0x3182	; 0x3182 <chb_get_state>
    34ec:	86 31       	cpi	r24, 0x16	; 22
    34ee:	91 f0       	breq	.+36     	; 0x3514 <chb_drvr_init+0xf4>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    34f0:	8e 01       	movw	r16, r28
    34f2:	07 5f       	subi	r16, 0xF7	; 247
    34f4:	1f 4f       	sbci	r17, 0xFF	; 255
    34f6:	c8 01       	movw	r24, r16
    34f8:	68 ee       	ldi	r22, 0xE8	; 232
    34fa:	71 e0       	ldi	r23, 0x01	; 1
    34fc:	0e 94 38 3b 	call	0x7670	; 0x7670 <strcpy_P>
        printf(buf);
    3500:	0f 92       	push	r0
    3502:	0f 92       	push	r0
    3504:	ed b7       	in	r30, 0x3d	; 61
    3506:	fe b7       	in	r31, 0x3e	; 62
    3508:	01 83       	std	Z+1, r16	; 0x01
    350a:	12 83       	std	Z+2, r17	; 0x02
    350c:	0e 94 8b 3b 	call	0x7716	; 0x7716 <printf>
    3510:	0f 90       	pop	r0
    3512:	0f 90       	pop	r0
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
    3514:	ea 96       	adiw	r28, 0x3a	; 58
    3516:	cd bf       	out	0x3d, r28	; 61
    3518:	de bf       	out	0x3e, r29	; 62
    351a:	df 91       	pop	r29
    351c:	cf 91       	pop	r28
    351e:	1f 91       	pop	r17
    3520:	0f 91       	pop	r16
    3522:	08 95       	ret

00003524 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    3524:	1f 92       	push	r1
    3526:	0f 92       	push	r0
    3528:	0f b6       	in	r0, 0x3f	; 63
    352a:	0f 92       	push	r0
    352c:	0b b6       	in	r0, 0x3b	; 59
    352e:	0f 92       	push	r0
    3530:	11 24       	eor	r1, r1
    3532:	4f 92       	push	r4
    3534:	5f 92       	push	r5
    3536:	6f 92       	push	r6
    3538:	7f 92       	push	r7
    353a:	8f 92       	push	r8
    353c:	9f 92       	push	r9
    353e:	af 92       	push	r10
    3540:	bf 92       	push	r11
    3542:	cf 92       	push	r12
    3544:	df 92       	push	r13
    3546:	ef 92       	push	r14
    3548:	ff 92       	push	r15
    354a:	0f 93       	push	r16
    354c:	1f 93       	push	r17
    354e:	2f 93       	push	r18
    3550:	3f 93       	push	r19
    3552:	4f 93       	push	r20
    3554:	5f 93       	push	r21
    3556:	6f 93       	push	r22
    3558:	7f 93       	push	r23
    355a:	8f 93       	push	r24
    355c:	9f 93       	push	r25
    355e:	af 93       	push	r26
    3560:	bf 93       	push	r27
    3562:	ef 93       	push	r30
    3564:	ff 93       	push	r31
    3566:	cf 93       	push	r28
    3568:	df 93       	push	r29
    356a:	cd b7       	in	r28, 0x3d	; 61
    356c:	de b7       	in	r29, 0x3e	; 62
    356e:	e2 97       	sbiw	r28, 0x32	; 50
    3570:	cd bf       	out	0x3d, r28	; 61
    3572:	de bf       	out	0x3e, r29	; 62
    U8 state, intp_src = 0;
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    3574:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <chb_get_pcb>
    3578:	7c 01       	movw	r14, r24

    CHB_ENTER_CRIT();
    357a:	8f b7       	in	r24, 0x3f	; 63
    357c:	80 93 56 40 	sts	0x4056, r24
    3580:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    3582:	81 e0       	ldi	r24, 0x01	; 1
    3584:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    3588:	8f e8       	ldi	r24, 0x8F	; 143
    358a:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <SPID_write>
    intp_src = SPID_write(0);
    358e:	80 e0       	ldi	r24, 0x00	; 0
    3590:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <SPID_write>
    3594:	18 2f       	mov	r17, r24

    RadioCS(FALSE);
    3596:	80 e0       	ldi	r24, 0x00	; 0
    3598:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <RadioCS>

    while (intp_src)
    359c:	11 23       	and	r17, r17
    359e:	09 f4       	brne	.+2      	; 0x35a2 <__vector_64+0x7e>
    35a0:	be c0       	rjmp	.+380    	; 0x371e <__vector_64+0x1fa>

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    35a2:	aa 24       	eor	r10, r10
    35a4:	bb 24       	eor	r11, r11
    35a6:	68 94       	set
    35a8:	a7 f8       	bld	r10, 7

            // Increment the overflow stat
            pcb->overflow++;

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    35aa:	0f 2e       	mov	r0, r31
    35ac:	f8 e0       	ldi	r31, 0x08	; 8
    35ae:	6f 2e       	mov	r6, r31
    35b0:	f2 e0       	ldi	r31, 0x02	; 2
    35b2:	7f 2e       	mov	r7, r31
    35b4:	f0 2d       	mov	r31, r0
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    35b6:	0f 2e       	mov	r0, r31
    35b8:	f0 e8       	ldi	r31, 0x80	; 128
    35ba:	8f 2e       	mov	r8, r31
    35bc:	f6 e0       	ldi	r31, 0x06	; 6
    35be:	9f 2e       	mov	r9, r31
    35c0:	f0 2d       	mov	r31, r0
    35c2:	cc 24       	eor	r12, r12
    35c4:	68 94       	set
    35c6:	c2 f8       	bld	r12, 2
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    35c8:	12 ff       	sbrs	r17, 2
    35ca:	02 c0       	rjmp	.+4      	; 0x35d0 <__vector_64+0xac>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    35cc:	1b 7f       	andi	r17, 0xFB	; 251
    35ce:	a4 c0       	rjmp	.+328    	; 0x3718 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    35d0:	13 ff       	sbrs	r17, 3
    35d2:	89 c0       	rjmp	.+274    	; 0x36e6 <__vector_64+0x1c2>
        {
            state = chb_get_state();
    35d4:	0e 94 c1 18 	call	0x3182	; 0x3182 <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    35d8:	86 30       	cpi	r24, 0x06	; 6
    35da:	29 f0       	breq	.+10     	; 0x35e6 <__vector_64+0xc2>
    35dc:	86 31       	cpi	r24, 0x16	; 22
    35de:	19 f0       	breq	.+6      	; 0x35e6 <__vector_64+0xc2>
    35e0:	81 31       	cpi	r24, 0x11	; 17
    35e2:	09 f0       	breq	.+2      	; 0x35e6 <__vector_64+0xc2>
    35e4:	76 c0       	rjmp	.+236    	; 0x36d2 <__vector_64+0x1ae>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    35e6:	88 e0       	ldi	r24, 0x08	; 8
    35e8:	0e 94 da 18 	call	0x31b4	; 0x31b4 <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    35ec:	87 e0       	ldi	r24, 0x07	; 7
    35ee:	0e 94 a7 18 	call	0x314e	; 0x314e <chb_reg_read>
    35f2:	f7 01       	movw	r30, r14
    35f4:	82 8b       	std	Z+18, r24	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    35f6:	86 e0       	ldi	r24, 0x06	; 6
    35f8:	0e 94 a7 18 	call	0x314e	; 0x314e <chb_reg_read>
    35fc:	88 1f       	adc	r24, r24
    35fe:	88 27       	eor	r24, r24
    3600:	88 1f       	adc	r24, r24
    3602:	f7 01       	movw	r30, r14
    3604:	83 8b       	std	Z+19, r24	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    3606:	88 23       	and	r24, r24
    3608:	09 f4       	brne	.+2      	; 0x360c <__vector_64+0xe8>
    360a:	66 c0       	rjmp	.+204    	; 0x36d8 <__vector_64+0x1b4>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
    360c:	8f b7       	in	r24, 0x3f	; 63
    360e:	80 93 56 40 	sts	0x4056, r24
    3612:	f8 94       	cli
    RadioCS(TRUE);
    3614:	81 e0       	ldi	r24, 0x01	; 1
    3616:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    361a:	80 e2       	ldi	r24, 0x20	; 32
    361c:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <SPID_write>
    len = SPID_write(0);
    3620:	80 e0       	ldi	r24, 0x00	; 0
    3622:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <SPID_write>
    3626:	d8 2e       	mov	r13, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    3628:	83 50       	subi	r24, 0x03	; 3
    362a:	8d 37       	cpi	r24, 0x7D	; 125
    362c:	08 f0       	brcs	.+2      	; 0x3630 <__vector_64+0x10c>
    362e:	41 c0       	rjmp	.+130    	; 0x36b2 <__vector_64+0x18e>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3630:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <chb_buf_get_len>
    3634:	2d 2d       	mov	r18, r13
    3636:	30 e0       	ldi	r19, 0x00	; 0
    3638:	a5 01       	movw	r20, r10
    363a:	48 1b       	sub	r20, r24
    363c:	51 09       	sbc	r21, r1
    363e:	24 17       	cp	r18, r20
    3640:	35 07       	cpc	r19, r21
    3642:	94 f4       	brge	.+36     	; 0x3668 <__vector_64+0x144>
        {
            chb_buf_write(len);
    3644:	8d 2d       	mov	r24, r13
    3646:	0e 94 87 17 	call	0x2f0e	; 0x2f0e <chb_buf_write>
            
            for (i=0; i<len; i++)
    364a:	dd 20       	and	r13, r13
    364c:	49 f0       	breq	.+18     	; 0x3660 <__vector_64+0x13c>
    364e:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    3650:	80 e0       	ldi	r24, 0x00	; 0
    3652:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <SPID_write>
                chb_buf_write(data);
    3656:	0e 94 87 17 	call	0x2f0e	; 0x2f0e <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    365a:	0f 5f       	subi	r16, 0xFF	; 255
    365c:	0d 15       	cp	r16, r13
    365e:	c1 f7       	brne	.-16     	; 0x3650 <__vector_64+0x12c>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    3660:	f4 01       	movw	r30, r8
    3662:	c5 82       	std	Z+5, r12	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    3664:	c6 82       	std	Z+6, r12	; 0x06
    3666:	25 c0       	rjmp	.+74     	; 0x36b2 <__vector_64+0x18e>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    3668:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <chb_get_pcb>
    366c:	2c 01       	movw	r4, r24
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    366e:	dd 20       	and	r13, r13
    3670:	39 f0       	breq	.+14     	; 0x3680 <__vector_64+0x15c>
    3672:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    3674:	80 e0       	ldi	r24, 0x00	; 0
    3676:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    367a:	0f 5f       	subi	r16, 0xFF	; 255
    367c:	0d 15       	cp	r16, r13
    367e:	d1 f7       	brne	.-12     	; 0x3674 <__vector_64+0x150>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    3680:	f2 01       	movw	r30, r4
    3682:	85 85       	ldd	r24, Z+13	; 0x0d
    3684:	96 85       	ldd	r25, Z+14	; 0x0e
    3686:	01 96       	adiw	r24, 0x01	; 1
    3688:	85 87       	std	Z+13, r24	; 0x0d
    368a:	96 87       	std	Z+14, r25	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    368c:	ce 01       	movw	r24, r28
    368e:	01 96       	adiw	r24, 0x01	; 1
    3690:	b3 01       	movw	r22, r6
    3692:	0e 94 38 3b 	call	0x7670	; 0x7670 <strcpy_P>
            printf(buf);
    3696:	0f 92       	push	r0
    3698:	0f 92       	push	r0
    369a:	41 e0       	ldi	r20, 0x01	; 1
    369c:	50 e0       	ldi	r21, 0x00	; 0
    369e:	4c 0f       	add	r20, r28
    36a0:	5d 1f       	adc	r21, r29
    36a2:	ed b7       	in	r30, 0x3d	; 61
    36a4:	fe b7       	in	r31, 0x3e	; 62
    36a6:	41 83       	std	Z+1, r20	; 0x01
    36a8:	52 83       	std	Z+2, r21	; 0x02
    36aa:	0e 94 8b 3b 	call	0x7716	; 0x7716 <printf>
    36ae:	0f 90       	pop	r0
    36b0:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    36b2:	80 e0       	ldi	r24, 0x00	; 0
    36b4:	0e 94 d4 17 	call	0x2fa8	; 0x2fa8 <RadioCS>
    CHB_LEAVE_CRIT();
    36b8:	80 91 56 40 	lds	r24, 0x4056
    36bc:	8f bf       	out	0x3f, r24	; 63
    36be:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
    36c0:	f7 01       	movw	r30, r14
    36c2:	85 81       	ldd	r24, Z+5	; 0x05
    36c4:	96 81       	ldd	r25, Z+6	; 0x06
    36c6:	01 96       	adiw	r24, 0x01	; 1
    36c8:	85 83       	std	Z+5, r24	; 0x05
    36ca:	96 83       	std	Z+6, r25	; 0x06
                    pcb->data_rcv = true;
    36cc:	81 e0       	ldi	r24, 0x01	; 1
    36ce:	83 83       	std	Z+3, r24	; 0x03
    36d0:	03 c0       	rjmp	.+6      	; 0x36d8 <__vector_64+0x1b4>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    36d2:	81 e0       	ldi	r24, 0x01	; 1
    36d4:	f7 01       	movw	r30, r14
    36d6:	84 83       	std	Z+4, r24	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    36d8:	17 7f       	andi	r17, 0xF7	; 247
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    36da:	86 e1       	ldi	r24, 0x16	; 22
    36dc:	0e 94 da 18 	call	0x31b4	; 0x31b4 <chb_set_state>
    36e0:	80 34       	cpi	r24, 0x40	; 64
    36e2:	d9 f7       	brne	.-10     	; 0x36da <__vector_64+0x1b6>
    36e4:	19 c0       	rjmp	.+50     	; 0x3718 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    36e6:	16 ff       	sbrs	r17, 6
    36e8:	08 c0       	rjmp	.+16     	; 0x36fa <__vector_64+0x1d6>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    36ea:	1f 7b       	andi	r17, 0xBF	; 191
            pcb->underrun++;
    36ec:	f7 01       	movw	r30, r14
    36ee:	87 85       	ldd	r24, Z+15	; 0x0f
    36f0:	90 89       	ldd	r25, Z+16	; 0x10
    36f2:	01 96       	adiw	r24, 0x01	; 1
    36f4:	87 87       	std	Z+15, r24	; 0x0f
    36f6:	90 8b       	std	Z+16, r25	; 0x10
    36f8:	0f c0       	rjmp	.+30     	; 0x3718 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    36fa:	11 ff       	sbrs	r17, 1
    36fc:	02 c0       	rjmp	.+4      	; 0x3702 <__vector_64+0x1de>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    36fe:	1d 7f       	andi	r17, 0xFD	; 253
    3700:	0b c0       	rjmp	.+22     	; 0x3718 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    3702:	10 ff       	sbrs	r17, 0
    3704:	02 c0       	rjmp	.+4      	; 0x370a <__vector_64+0x1e6>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    3706:	1e 7f       	andi	r17, 0xFE	; 254
    3708:	07 c0       	rjmp	.+14     	; 0x3718 <__vector_64+0x1f4>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    370a:	11 23       	and	r17, r17
    370c:	2c f4       	brge	.+10     	; 0x3718 <__vector_64+0x1f4>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    370e:	1f 77       	andi	r17, 0x7F	; 127
            pcb->battlow++;
    3710:	f7 01       	movw	r30, r14
    3712:	81 89       	ldd	r24, Z+17	; 0x11
    3714:	8f 5f       	subi	r24, 0xFF	; 255
    3716:	81 8b       	std	Z+17, r24	; 0x11
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    3718:	11 23       	and	r17, r17
    371a:	09 f0       	breq	.+2      	; 0x371e <__vector_64+0x1fa>
    371c:	55 cf       	rjmp	.-342    	; 0x35c8 <__vector_64+0xa4>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    371e:	80 91 56 40 	lds	r24, 0x4056
    3722:	8f bf       	out	0x3f, r24	; 63
    3724:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    3726:	8f e0       	ldi	r24, 0x0F	; 15
    3728:	0e 94 a7 18 	call	0x314e	; 0x314e <chb_reg_read>
}
    372c:	e2 96       	adiw	r28, 0x32	; 50
    372e:	cd bf       	out	0x3d, r28	; 61
    3730:	de bf       	out	0x3e, r29	; 62
    3732:	df 91       	pop	r29
    3734:	cf 91       	pop	r28
    3736:	ff 91       	pop	r31
    3738:	ef 91       	pop	r30
    373a:	bf 91       	pop	r27
    373c:	af 91       	pop	r26
    373e:	9f 91       	pop	r25
    3740:	8f 91       	pop	r24
    3742:	7f 91       	pop	r23
    3744:	6f 91       	pop	r22
    3746:	5f 91       	pop	r21
    3748:	4f 91       	pop	r20
    374a:	3f 91       	pop	r19
    374c:	2f 91       	pop	r18
    374e:	1f 91       	pop	r17
    3750:	0f 91       	pop	r16
    3752:	ff 90       	pop	r15
    3754:	ef 90       	pop	r14
    3756:	df 90       	pop	r13
    3758:	cf 90       	pop	r12
    375a:	bf 90       	pop	r11
    375c:	af 90       	pop	r10
    375e:	9f 90       	pop	r9
    3760:	8f 90       	pop	r8
    3762:	7f 90       	pop	r7
    3764:	6f 90       	pop	r6
    3766:	5f 90       	pop	r5
    3768:	4f 90       	pop	r4
    376a:	0f 90       	pop	r0
    376c:	0b be       	out	0x3b, r0	; 59
    376e:	0f 90       	pop	r0
    3770:	0f be       	out	0x3f, r0	; 63
    3772:	0f 90       	pop	r0
    3774:	1f 90       	pop	r1
    3776:	18 95       	reti

00003778 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    3778:	0f 93       	push	r16
    377a:	1f 93       	push	r17
    377c:	cf 93       	push	r28
    377e:	df 93       	push	r29
    3780:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3782:	e0 ec       	ldi	r30, 0xC0	; 192
    3784:	f1 e0       	ldi	r31, 0x01	; 1
    3786:	84 85       	ldd	r24, Z+12	; 0x0c
    3788:	87 7f       	andi	r24, 0xF7	; 247
    378a:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    378c:	41 15       	cp	r20, r1
    378e:	51 05       	cpc	r21, r1
    3790:	09 f4       	brne	.+2      	; 0x3794 <chb_eeprom_write+0x1c>
    3792:	50 c0       	rjmp	.+160    	; 0x3834 <chb_eeprom_write+0xbc>
    3794:	e0 e0       	ldi	r30, 0x00	; 0
    3796:	f0 e0       	ldi	r31, 0x00	; 0
    3798:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    379a:	a0 ec       	ldi	r26, 0xC0	; 192
    379c:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    379e:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    37a0:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    37a2:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
    37a4:	cf 01       	movw	r24, r30
    37a6:	80 0f       	add	r24, r16
    37a8:	91 1f       	adc	r25, r17
    37aa:	e6 0f       	add	r30, r22
    37ac:	f7 1f       	adc	r31, r23
    37ae:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    37b0:	1f 96       	adiw	r26, 0x0f	; 15
    37b2:	ec 91       	ld	r30, X
    37b4:	1f 97       	sbiw	r26, 0x0f	; 15
    37b6:	ee 23       	and	r30, r30
    37b8:	dc f3       	brlt	.-10     	; 0x37b0 <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    37ba:	1f 96       	adiw	r26, 0x0f	; 15
    37bc:	ec 91       	ld	r30, X
    37be:	1f 97       	sbiw	r26, 0x0f	; 15
    37c0:	e1 ff       	sbrs	r30, 1
    37c2:	11 c0       	rjmp	.+34     	; 0x37e6 <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    37c4:	1a 96       	adiw	r26, 0x0a	; 10
    37c6:	dc 93       	st	X, r29
    37c8:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
    37ca:	ef 93       	push	r30
    37cc:	ff 93       	push	r31
    37ce:	0f 93       	push	r16
    37d0:	2f 93       	push	r18
    37d2:	eb ec       	ldi	r30, 0xCB	; 203
    37d4:	f1 e0       	ldi	r31, 0x01	; 1
    37d6:	08 ed       	ldi	r16, 0xD8	; 216
    37d8:	21 e0       	ldi	r18, 0x01	; 1
    37da:	04 bf       	out	0x34, r16	; 52
    37dc:	20 83       	st	Z, r18
    37de:	2f 91       	pop	r18
    37e0:	0f 91       	pop	r16
    37e2:	ff 91       	pop	r31
    37e4:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    37e6:	1a 96       	adiw	r26, 0x0a	; 10
    37e8:	cc 93       	st	X, r28
    37ea:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    37ec:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    37ee:	89 2f       	mov	r24, r25
    37f0:	8f 71       	andi	r24, 0x1F	; 31
    37f2:	11 96       	adiw	r26, 0x01	; 1
    37f4:	8c 93       	st	X, r24
    37f6:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
    37f8:	12 96       	adiw	r26, 0x02	; 2
    37fa:	1c 92       	st	X, r1
    37fc:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
    37fe:	14 96       	adiw	r26, 0x04	; 4
    3800:	fc 93       	st	X, r31
    3802:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3804:	1a 96       	adiw	r26, 0x0a	; 10
    3806:	3c 93       	st	X, r19
    3808:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
    380a:	ef 93       	push	r30
    380c:	ff 93       	push	r31
    380e:	0f 93       	push	r16
    3810:	2f 93       	push	r18
    3812:	eb ec       	ldi	r30, 0xCB	; 203
    3814:	f1 e0       	ldi	r31, 0x01	; 1
    3816:	08 ed       	ldi	r16, 0xD8	; 216
    3818:	21 e0       	ldi	r18, 0x01	; 1
    381a:	04 bf       	out	0x34, r16	; 52
    381c:	20 83       	st	Z, r18
    381e:	2f 91       	pop	r18
    3820:	0f 91       	pop	r16
    3822:	ff 91       	pop	r31
    3824:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    3826:	2f 5f       	subi	r18, 0xFF	; 255
    3828:	e2 2f       	mov	r30, r18
    382a:	f0 e0       	ldi	r31, 0x00	; 0
    382c:	e4 17       	cp	r30, r20
    382e:	f5 07       	cpc	r31, r21
    3830:	08 f4       	brcc	.+2      	; 0x3834 <chb_eeprom_write+0xbc>
    3832:	b8 cf       	rjmp	.-144    	; 0x37a4 <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    3834:	df 91       	pop	r29
    3836:	cf 91       	pop	r28
    3838:	1f 91       	pop	r17
    383a:	0f 91       	pop	r16
    383c:	08 95       	ret

0000383e <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    383e:	1f 93       	push	r17
    3840:	cf 93       	push	r28
    3842:	df 93       	push	r29
    3844:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3846:	e0 ec       	ldi	r30, 0xC0	; 192
    3848:	f1 e0       	ldi	r31, 0x01	; 1
    384a:	84 85       	ldd	r24, Z+12	; 0x0c
    384c:	87 7f       	andi	r24, 0xF7	; 247
    384e:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3850:	41 15       	cp	r20, r1
    3852:	51 05       	cpc	r21, r1
    3854:	41 f1       	breq	.+80     	; 0x38a6 <chb_eeprom_read+0x68>
    3856:	80 e0       	ldi	r24, 0x00	; 0
    3858:	90 e0       	ldi	r25, 0x00	; 0
    385a:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    385c:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    385e:	db 01       	movw	r26, r22
    3860:	a8 0f       	add	r26, r24
    3862:	b9 1f       	adc	r27, r25
    3864:	82 0f       	add	r24, r18
    3866:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3868:	17 85       	ldd	r17, Z+15	; 0x0f
    386a:	11 23       	and	r17, r17
    386c:	ec f3       	brlt	.-6      	; 0x3868 <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    386e:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3870:	89 2f       	mov	r24, r25
    3872:	8f 71       	andi	r24, 0x1F	; 31
    3874:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
    3876:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3878:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
    387a:	ef 93       	push	r30
    387c:	ff 93       	push	r31
    387e:	0f 93       	push	r16
    3880:	2f 93       	push	r18
    3882:	eb ec       	ldi	r30, 0xCB	; 203
    3884:	f1 e0       	ldi	r31, 0x01	; 1
    3886:	08 ed       	ldi	r16, 0xD8	; 216
    3888:	21 e0       	ldi	r18, 0x01	; 1
    388a:	04 bf       	out	0x34, r16	; 52
    388c:	20 83       	st	Z, r18
    388e:	2f 91       	pop	r18
    3890:	0f 91       	pop	r16
    3892:	ff 91       	pop	r31
    3894:	ef 91       	pop	r30

    return NVM.DATA0;
    3896:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3898:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    389a:	cf 5f       	subi	r28, 0xFF	; 255
    389c:	8c 2f       	mov	r24, r28
    389e:	90 e0       	ldi	r25, 0x00	; 0
    38a0:	84 17       	cp	r24, r20
    38a2:	95 07       	cpc	r25, r21
    38a4:	e0 f2       	brcs	.-72     	; 0x385e <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    38a6:	df 91       	pop	r29
    38a8:	cf 91       	pop	r28
    38aa:	1f 91       	pop	r17
    38ac:	08 95       	ret

000038ae <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    38ae:	e0 e6       	ldi	r30, 0x60	; 96
    38b0:	f6 e0       	ldi	r31, 0x06	; 6
    38b2:	80 81       	ld	r24, Z
    38b4:	80 6b       	ori	r24, 0xB0	; 176
    38b6:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    38b8:	e4 e6       	ldi	r30, 0x64	; 100
    38ba:	f6 e0       	ldi	r31, 0x06	; 6
    38bc:	80 81       	ld	r24, Z
    38be:	80 61       	ori	r24, 0x10	; 16
    38c0:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    38c2:	a0 ec       	ldi	r26, 0xC0	; 192
    38c4:	b9 e0       	ldi	r27, 0x09	; 9
    38c6:	8c 91       	ld	r24, X
    38c8:	81 65       	ori	r24, 0x51	; 81
    38ca:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    38cc:	80 81       	ld	r24, Z
    38ce:	80 61       	ori	r24, 0x10	; 16
    38d0:	80 83       	st	Z, r24
}
    38d2:	08 95       	ret

000038d4 <SPID_write>:
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    38d4:	e0 ec       	ldi	r30, 0xC0	; 192
    38d6:	f9 e0       	ldi	r31, 0x09	; 9
    38d8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    38da:	82 81       	ldd	r24, Z+2	; 0x02
    38dc:	88 23       	and	r24, r24
    38de:	ec f7       	brge	.-6      	; 0x38da <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    38e0:	e0 ec       	ldi	r30, 0xC0	; 192
    38e2:	f9 e0       	ldi	r31, 0x09	; 9
    38e4:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    38e6:	08 95       	ret

000038e8 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    38e8:	0f 93       	push	r16
    38ea:	cf 93       	push	r28
    38ec:	df 93       	push	r29
    38ee:	0f 92       	push	r0
    38f0:	cd b7       	in	r28, 0x3d	; 61
    38f2:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    38f4:	2f b7       	in	r18, 0x3f	; 63
    38f6:	29 83       	std	Y+1, r18	; 0x01
    38f8:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    38fa:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    38fc:	fc 01       	movw	r30, r24
    38fe:	08 ed       	ldi	r16, 0xD8	; 216
    3900:	04 bf       	out	0x34, r16	; 52
    3902:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    3904:	89 81       	ldd	r24, Y+1	; 0x01
    3906:	8f bf       	out	0x3f, r24	; 63
#endif
}
    3908:	0f 90       	pop	r0
    390a:	df 91       	pop	r29
    390c:	cf 91       	pop	r28
    390e:	0f 91       	pop	r16
    3910:	08 95       	ret

00003912 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    3912:	66 23       	and	r22, r22
    3914:	11 f0       	breq	.+4      	; 0x391a <CLKSYS_XOSC_Config+0x8>
    3916:	90 e2       	ldi	r25, 0x20	; 32
    3918:	01 c0       	rjmp	.+2      	; 0x391c <CLKSYS_XOSC_Config+0xa>
    391a:	90 e0       	ldi	r25, 0x00	; 0
    391c:	84 2b       	or	r24, r20
    391e:	89 2b       	or	r24, r25
    3920:	e0 e5       	ldi	r30, 0x50	; 80
    3922:	f0 e0       	ldi	r31, 0x00	; 0
    3924:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    3926:	08 95       	ret

00003928 <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    3928:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    392a:	86 2b       	or	r24, r22
    392c:	e0 e5       	ldi	r30, 0x50	; 80
    392e:	f0 e0       	ldi	r31, 0x00	; 0
    3930:	85 83       	std	Z+5, r24	; 0x05
}
    3932:	08 95       	ret

00003934 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    3934:	e0 e5       	ldi	r30, 0x50	; 80
    3936:	f0 e0       	ldi	r31, 0x00	; 0
    3938:	90 81       	ld	r25, Z
    393a:	28 2f       	mov	r18, r24
    393c:	20 95       	com	r18
    393e:	92 23       	and	r25, r18
    3940:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    3942:	90 81       	ld	r25, Z
	return clkEnabled;
}
    3944:	89 23       	and	r24, r25
    3946:	08 95       	ret

00003948 <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    3948:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    394a:	81 e4       	ldi	r24, 0x41	; 65
    394c:	90 e0       	ldi	r25, 0x00	; 0
    394e:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <CCPWrite>
}
    3952:	08 95       	ret

00003954 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    3954:	1f 93       	push	r17
    3956:	cf 93       	push	r28
    3958:	df 93       	push	r29
    395a:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    395c:	c0 e4       	ldi	r28, 0x40	; 64
    395e:	d0 e0       	ldi	r29, 0x00	; 0
    3960:	68 81       	ld	r22, Y
    3962:	68 7f       	andi	r22, 0xF8	; 248
    3964:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    3966:	80 e4       	ldi	r24, 0x40	; 64
    3968:	90 e0       	ldi	r25, 0x00	; 0
    396a:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    396e:	88 81       	ld	r24, Y
	return clkCtrl;
}
    3970:	81 23       	and	r24, r17
    3972:	df 91       	pop	r29
    3974:	cf 91       	pop	r28
    3976:	1f 91       	pop	r17
    3978:	08 95       	ret

0000397a <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    397a:	e0 e4       	ldi	r30, 0x40	; 64
    397c:	f0 e0       	ldi	r31, 0x00	; 0
    397e:	93 81       	ldd	r25, Z+3	; 0x03
    3980:	91 7f       	andi	r25, 0xF1	; 241
    3982:	91 60       	ori	r25, 0x01	; 1
    3984:	89 2b       	or	r24, r25
    3986:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    3988:	08 95       	ret

0000398a <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    398a:	e0 e5       	ldi	r30, 0x50	; 80
    398c:	f0 e0       	ldi	r31, 0x00	; 0
    398e:	26 81       	ldd	r18, Z+6	; 0x06
    3990:	98 2f       	mov	r25, r24
    3992:	38 2f       	mov	r19, r24
    3994:	30 95       	com	r19
    3996:	23 23       	and	r18, r19
    3998:	66 23       	and	r22, r22
    399a:	09 f4       	brne	.+2      	; 0x399e <CLKSYS_AutoCalibration_Enable+0x14>
    399c:	90 e0       	ldi	r25, 0x00	; 0
    399e:	92 2b       	or	r25, r18
    39a0:	e0 e5       	ldi	r30, 0x50	; 80
    39a2:	f0 e0       	ldi	r31, 0x00	; 0
    39a4:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    39a6:	81 30       	cpi	r24, 0x01	; 1
    39a8:	31 f4       	brne	.+12     	; 0x39b6 <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    39aa:	e8 e6       	ldi	r30, 0x68	; 104
    39ac:	f0 e0       	ldi	r31, 0x00	; 0
    39ae:	80 81       	ld	r24, Z
    39b0:	81 60       	ori	r24, 0x01	; 1
    39b2:	80 83       	st	Z, r24
    39b4:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    39b6:	82 30       	cpi	r24, 0x02	; 2
    39b8:	29 f4       	brne	.+10     	; 0x39c4 <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    39ba:	e0 e6       	ldi	r30, 0x60	; 96
    39bc:	f0 e0       	ldi	r31, 0x00	; 0
    39be:	80 81       	ld	r24, Z
    39c0:	81 60       	ori	r24, 0x01	; 1
    39c2:	80 83       	st	Z, r24
    39c4:	08 95       	ret

000039c6 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    39c6:	83 e5       	ldi	r24, 0x53	; 83
    39c8:	90 e0       	ldi	r25, 0x00	; 0
    39ca:	63 e0       	ldi	r22, 0x03	; 3
    39cc:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <CCPWrite>
}
    39d0:	08 95       	ret

000039d2 <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    39d2:	82 e4       	ldi	r24, 0x42	; 66
    39d4:	90 e0       	ldi	r25, 0x00	; 0
    39d6:	61 e0       	ldi	r22, 0x01	; 1
    39d8:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <CCPWrite>
}
    39dc:	08 95       	ret

000039de <setXOSC_32MHz>:
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    39de:	80 ec       	ldi	r24, 0xC0	; 192
    39e0:	60 e0       	ldi	r22, 0x00	; 0
    39e2:	4b e0       	ldi	r20, 0x0B	; 11
    39e4:	0e 94 89 1c 	call	0x3912	; 0x3912 <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    39e8:	e0 e5       	ldi	r30, 0x50	; 80
    39ea:	f0 e0       	ldi	r31, 0x00	; 0
    39ec:	80 81       	ld	r24, Z
    39ee:	88 60       	ori	r24, 0x08	; 8
    39f0:	80 83       	st	Z, r24
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    39f2:	81 81       	ldd	r24, Z+1	; 0x01
    39f4:	83 ff       	sbrs	r24, 3
    39f6:	fd cf       	rjmp	.-6      	; 0x39f2 <setXOSC_32MHz+0x14>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    39f8:	80 ec       	ldi	r24, 0xC0	; 192
    39fa:	62 e0       	ldi	r22, 0x02	; 2
    39fc:	0e 94 94 1c 	call	0x3928	; 0x3928 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    3a00:	e0 e5       	ldi	r30, 0x50	; 80
    3a02:	f0 e0       	ldi	r31, 0x00	; 0
    3a04:	80 81       	ld	r24, Z
    3a06:	80 61       	ori	r24, 0x10	; 16
    3a08:	80 83       	st	Z, r24
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    3a0a:	81 81       	ldd	r24, Z+1	; 0x01
    3a0c:	84 ff       	sbrs	r24, 4
    3a0e:	fd cf       	rjmp	.-6      	; 0x3a0a <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    3a10:	84 e0       	ldi	r24, 0x04	; 4
    3a12:	0e 94 aa 1c 	call	0x3954	; 0x3954 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    3a16:	81 e0       	ldi	r24, 0x01	; 1
    3a18:	0e 94 9a 1c 	call	0x3934	; 0x3934 <CLKSYS_Disable>
}
    3a1c:	08 95       	ret

00003a1e <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    3a1e:	e0 e5       	ldi	r30, 0x50	; 80
    3a20:	f0 e0       	ldi	r31, 0x00	; 0
    3a22:	80 81       	ld	r24, Z
    3a24:	82 60       	ori	r24, 0x02	; 2
    3a26:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    3a28:	80 e0       	ldi	r24, 0x00	; 0
    3a2a:	61 e0       	ldi	r22, 0x01	; 1
    3a2c:	0e 94 a4 1c 	call	0x3948	; 0x3948 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    3a30:	e0 e5       	ldi	r30, 0x50	; 80
    3a32:	f0 e0       	ldi	r31, 0x00	; 0
    3a34:	81 81       	ldd	r24, Z+1	; 0x01
    3a36:	81 ff       	sbrs	r24, 1
    3a38:	fd cf       	rjmp	.-6      	; 0x3a34 <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    3a3a:	81 e0       	ldi	r24, 0x01	; 1
    3a3c:	0e 94 aa 1c 	call	0x3954	; 0x3954 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    3a40:	81 e0       	ldi	r24, 0x01	; 1
    3a42:	0e 94 9a 1c 	call	0x3934	; 0x3934 <CLKSYS_Disable>
	
}
    3a46:	08 95       	ret

00003a48 <set_32MHz>:

// produces consistent but inaccurate clock period.
void set_32MHz() {
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    3a48:	e0 e5       	ldi	r30, 0x50	; 80
    3a4a:	f0 e0       	ldi	r31, 0x00	; 0
    3a4c:	80 81       	ld	r24, Z
    3a4e:	82 60       	ori	r24, 0x02	; 2
    3a50:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    3a52:	80 e0       	ldi	r24, 0x00	; 0
    3a54:	60 e0       	ldi	r22, 0x00	; 0
    3a56:	0e 94 a4 1c 	call	0x3948	; 0x3948 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    3a5a:	e0 e5       	ldi	r30, 0x50	; 80
    3a5c:	f0 e0       	ldi	r31, 0x00	; 0
    3a5e:	81 81       	ldd	r24, Z+1	; 0x01
    3a60:	81 ff       	sbrs	r24, 1
    3a62:	fd cf       	rjmp	.-6      	; 0x3a5e <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    3a64:	81 e0       	ldi	r24, 0x01	; 1
    3a66:	0e 94 aa 1c 	call	0x3954	; 0x3954 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    3a6a:	81 e0       	ldi	r24, 0x01	; 1
    3a6c:	0e 94 9a 1c 	call	0x3934	; 0x3934 <CLKSYS_Disable>
	
}
    3a70:	08 95       	ret

00003a72 <portExCS>:


void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
    3a72:	88 23       	and	r24, r24
    3a74:	29 f0       	breq	.+10     	; 0x3a80 <portExCS+0xe>
    3a76:	88 e0       	ldi	r24, 0x08	; 8
    3a78:	e0 e0       	ldi	r30, 0x00	; 0
    3a7a:	f6 e0       	ldi	r31, 0x06	; 6
    3a7c:	86 83       	std	Z+6, r24	; 0x06
    3a7e:	04 c0       	rjmp	.+8      	; 0x3a88 <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
    3a80:	88 e0       	ldi	r24, 0x08	; 8
    3a82:	e0 e0       	ldi	r30, 0x00	; 0
    3a84:	f6 e0       	ldi	r31, 0x06	; 6
    3a86:	85 83       	std	Z+5, r24	; 0x05
    3a88:	8a e6       	ldi	r24, 0x6A	; 106
    3a8a:	8a 95       	dec	r24
    3a8c:	f1 f7       	brne	.-4      	; 0x3a8a <portExCS+0x18>
    3a8e:	00 c0       	rjmp	.+0      	; 0x3a90 <portExCS+0x1e>
	}
	_delay_us(10);
}
    3a90:	08 95       	ret

00003a92 <Ext1Power>:
*/


void Ext1Power(uint8_t on) {
	
	if (on) {
    3a92:	88 23       	and	r24, r24
    3a94:	79 f0       	breq	.+30     	; 0x3ab4 <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
    3a96:	e0 ea       	ldi	r30, 0xA0	; 160
    3a98:	f6 e0       	ldi	r31, 0x06	; 6
    3a9a:	80 e2       	ldi	r24, 0x20	; 32
    3a9c:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
    3a9e:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3aa0:	8f ef       	ldi	r24, 0xFF	; 255
    3aa2:	93 ec       	ldi	r25, 0xC3	; 195
    3aa4:	a9 e0       	ldi	r26, 0x09	; 9
    3aa6:	81 50       	subi	r24, 0x01	; 1
    3aa8:	90 40       	sbci	r25, 0x00	; 0
    3aaa:	a0 40       	sbci	r26, 0x00	; 0
    3aac:	e1 f7       	brne	.-8      	; 0x3aa6 <Ext1Power+0x14>
    3aae:	00 c0       	rjmp	.+0      	; 0x3ab0 <Ext1Power+0x1e>
    3ab0:	00 00       	nop
    3ab2:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    3ab4:	e0 ea       	ldi	r30, 0xA0	; 160
    3ab6:	f6 e0       	ldi	r31, 0x06	; 6
    3ab8:	80 e2       	ldi	r24, 0x20	; 32
    3aba:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    3abc:	82 83       	std	Z+2, r24	; 0x02
    3abe:	08 95       	ret

00003ac0 <Ext2Power>:
	}
}

void Ext2Power(uint8_t on) {
	
	if (on) {
    3ac0:	88 23       	and	r24, r24
    3ac2:	79 f0       	breq	.+30     	; 0x3ae2 <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
    3ac4:	e0 ea       	ldi	r30, 0xA0	; 160
    3ac6:	f6 e0       	ldi	r31, 0x06	; 6
    3ac8:	80 e4       	ldi	r24, 0x40	; 64
    3aca:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
    3acc:	85 83       	std	Z+5, r24	; 0x05
    3ace:	8f ef       	ldi	r24, 0xFF	; 255
    3ad0:	93 ec       	ldi	r25, 0xC3	; 195
    3ad2:	a9 e0       	ldi	r26, 0x09	; 9
    3ad4:	81 50       	subi	r24, 0x01	; 1
    3ad6:	90 40       	sbci	r25, 0x00	; 0
    3ad8:	a0 40       	sbci	r26, 0x00	; 0
    3ada:	e1 f7       	brne	.-8      	; 0x3ad4 <Ext2Power+0x14>
    3adc:	00 c0       	rjmp	.+0      	; 0x3ade <Ext2Power+0x1e>
    3ade:	00 00       	nop
    3ae0:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    3ae2:	e0 ea       	ldi	r30, 0xA0	; 160
    3ae4:	f6 e0       	ldi	r31, 0x06	; 6
    3ae6:	80 e4       	ldi	r24, 0x40	; 64
    3ae8:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    3aea:	82 83       	std	Z+2, r24	; 0x02
    3aec:	08 95       	ret

00003aee <HVPower>:
	}
}

void HVPower(uint8_t on) {
	
	if (on) {
    3aee:	88 23       	and	r24, r24
    3af0:	79 f0       	breq	.+30     	; 0x3b10 <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
    3af2:	e0 ea       	ldi	r30, 0xA0	; 160
    3af4:	f6 e0       	ldi	r31, 0x06	; 6
    3af6:	80 e8       	ldi	r24, 0x80	; 128
    3af8:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
    3afa:	85 83       	std	Z+5, r24	; 0x05
    3afc:	8f ef       	ldi	r24, 0xFF	; 255
    3afe:	93 ec       	ldi	r25, 0xC3	; 195
    3b00:	a9 e0       	ldi	r26, 0x09	; 9
    3b02:	81 50       	subi	r24, 0x01	; 1
    3b04:	90 40       	sbci	r25, 0x00	; 0
    3b06:	a0 40       	sbci	r26, 0x00	; 0
    3b08:	e1 f7       	brne	.-8      	; 0x3b02 <HVPower+0x14>
    3b0a:	00 c0       	rjmp	.+0      	; 0x3b0c <HVPower+0x1e>
    3b0c:	00 00       	nop
    3b0e:	05 c0       	rjmp	.+10     	; 0x3b1a <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    3b10:	e0 ea       	ldi	r30, 0xA0	; 160
    3b12:	f6 e0       	ldi	r31, 0x06	; 6
    3b14:	80 e8       	ldi	r24, 0x80	; 128
    3b16:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    3b18:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3b1a:	af e3       	ldi	r26, 0x3F	; 63
    3b1c:	bf e1       	ldi	r27, 0x1F	; 31
    3b1e:	11 97       	sbiw	r26, 0x01	; 1
    3b20:	f1 f7       	brne	.-4      	; 0x3b1e <HVPower+0x30>
    3b22:	00 c0       	rjmp	.+0      	; 0x3b24 <HVPower+0x36>
    3b24:	00 00       	nop
	}
	_delay_us(1000);
}
    3b26:	08 95       	ret

00003b28 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    3b28:	88 23       	and	r24, r24
    3b2a:	29 f0       	breq	.+10     	; 0x3b36 <lowerMuxCS+0xe>
    3b2c:	80 e1       	ldi	r24, 0x10	; 16
    3b2e:	e0 e8       	ldi	r30, 0x80	; 128
    3b30:	f6 e0       	ldi	r31, 0x06	; 6
    3b32:	86 83       	std	Z+6, r24	; 0x06
    3b34:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
    3b36:	80 e1       	ldi	r24, 0x10	; 16
    3b38:	e0 e8       	ldi	r30, 0x80	; 128
    3b3a:	f6 e0       	ldi	r31, 0x06	; 6
    3b3c:	85 83       	std	Z+5, r24	; 0x05
    3b3e:	08 95       	ret

00003b40 <upperMuxCS>:
}

void upperMuxCS(uint8_t write) {
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    3b40:	88 23       	and	r24, r24
    3b42:	29 f0       	breq	.+10     	; 0x3b4e <upperMuxCS+0xe>
    3b44:	82 e0       	ldi	r24, 0x02	; 2
    3b46:	e0 e4       	ldi	r30, 0x40	; 64
    3b48:	f6 e0       	ldi	r31, 0x06	; 6
    3b4a:	86 83       	std	Z+6, r24	; 0x06
    3b4c:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
    3b4e:	82 e0       	ldi	r24, 0x02	; 2
    3b50:	e0 e4       	ldi	r30, 0x40	; 64
    3b52:	f6 e0       	ldi	r31, 0x06	; 6
    3b54:	85 83       	std	Z+5, r24	; 0x05
    3b56:	08 95       	ret

00003b58 <SPIInit>:
}

void SPIInit(uint8_t mode) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    3b58:	e0 e4       	ldi	r30, 0x40	; 64
    3b5a:	f6 e0       	ldi	r31, 0x06	; 6
    3b5c:	90 e1       	ldi	r25, 0x10	; 16
    3b5e:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    3b60:	28 e3       	ldi	r18, 0x38	; 56
    3b62:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    3b64:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    3b66:	81 65       	ori	r24, 0x51	; 81
    3b68:	a0 ec       	ldi	r26, 0xC0	; 192
    3b6a:	b8 e0       	ldi	r27, 0x08	; 8
    3b6c:	8c 93       	st	X, r24
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    3b6e:	11 96       	adiw	r26, 0x01	; 1
    3b70:	1c 92       	st	X, r1
    3b72:	11 97       	sbiw	r26, 0x01	; 1

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    3b74:	80 ea       	ldi	r24, 0xA0	; 160
    3b76:	81 83       	std	Z+1, r24	; 0x01

	
}
    3b78:	08 95       	ret

00003b7a <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    3b7a:	e0 e4       	ldi	r30, 0x40	; 64
    3b7c:	f6 e0       	ldi	r31, 0x06	; 6
    3b7e:	90 e1       	ldi	r25, 0x10	; 16
    3b80:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    3b82:	28 e3       	ldi	r18, 0x38	; 56
    3b84:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    3b86:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    3b88:	80 65       	ori	r24, 0x50	; 80
    3b8a:	68 2b       	or	r22, r24
    3b8c:	a0 ec       	ldi	r26, 0xC0	; 192
    3b8e:	b8 e0       	ldi	r27, 0x08	; 8
    3b90:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    3b92:	11 96       	adiw	r26, 0x01	; 1
    3b94:	1c 92       	st	X, r1
    3b96:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    3b98:	80 ea       	ldi	r24, 0xA0	; 160
    3b9a:	81 83       	std	Z+1, r24	; 0x01
}
    3b9c:	08 95       	ret

00003b9e <SPICS>:

void SPICS(uint8_t enable) {
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
    3b9e:	88 23       	and	r24, r24
    3ba0:	29 f0       	breq	.+10     	; 0x3bac <SPICS+0xe>
    3ba2:	80 e1       	ldi	r24, 0x10	; 16
    3ba4:	e0 e4       	ldi	r30, 0x40	; 64
    3ba6:	f6 e0       	ldi	r31, 0x06	; 6
    3ba8:	86 83       	std	Z+6, r24	; 0x06
    3baa:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
    3bac:	80 e1       	ldi	r24, 0x10	; 16
    3bae:	e0 e4       	ldi	r30, 0x40	; 64
    3bb0:	f6 e0       	ldi	r31, 0x06	; 6
    3bb2:	85 83       	std	Z+5, r24	; 0x05
    3bb4:	08 95       	ret

00003bb6 <SPIDisable>:
	}	
}

void SPIDisable() {
	
	PORTC.OUTSET = PIN4_bm;
    3bb6:	e0 e4       	ldi	r30, 0x40	; 64
    3bb8:	f6 e0       	ldi	r31, 0x06	; 6
    3bba:	80 e1       	ldi	r24, 0x10	; 16
    3bbc:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
    3bbe:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
    3bc2:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    3bc4:	80 eb       	ldi	r24, 0xB0	; 176
    3bc6:	82 83       	std	Z+2, r24	; 0x02

}
    3bc8:	08 95       	ret

00003bca <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    3bca:	cf 93       	push	r28
    3bcc:	df 93       	push	r29
    3bce:	c8 2f       	mov	r28, r24
    3bd0:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    3bd2:	80 e0       	ldi	r24, 0x00	; 0
    3bd4:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <SPIInit>
	SPICS(TRUE);
    3bd8:	81 e0       	ldi	r24, 0x01	; 1
    3bda:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	portExCS(TRUE);
    3bde:	81 e0       	ldi	r24, 0x01	; 1
    3be0:	0e 94 39 1d 	call	0x3a72	; 0x3a72 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    3be4:	dd 23       	and	r29, r29
    3be6:	89 f0       	breq	.+34     	; 0x3c0a <PortEx_OUTCLR+0x40>
    3be8:	80 91 d6 23 	lds	r24, 0x23D6
    3bec:	c0 95       	com	r28
    3bee:	c8 23       	and	r28, r24
    3bf0:	c0 93 d6 23 	sts	0x23D6, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
    3bf4:	80 e4       	ldi	r24, 0x40	; 64
    3bf6:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
    3bfa:	84 e1       	ldi	r24, 0x14	; 20
    3bfc:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankA_OUT;
    3c00:	80 91 d6 23 	lds	r24, 0x23D6
    3c04:	80 93 67 50 	sts	0x5067, r24
    3c08:	10 c0       	rjmp	.+32     	; 0x3c2a <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    3c0a:	80 91 82 50 	lds	r24, 0x5082
    3c0e:	c0 95       	com	r28
    3c10:	c8 23       	and	r28, r24
    3c12:	c0 93 82 50 	sts	0x5082, r28
	
	SPIBuffer[0] = PS_WRITE;
    3c16:	80 e4       	ldi	r24, 0x40	; 64
    3c18:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
    3c1c:	85 e1       	ldi	r24, 0x15	; 21
    3c1e:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankB_OUT; 
    3c22:	80 91 82 50 	lds	r24, 0x5082
    3c26:	80 93 67 50 	sts	0x5067, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    3c2a:	80 e0       	ldi	r24, 0x00	; 0
    3c2c:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3c2e:	25 e6       	ldi	r18, 0x65	; 101
    3c30:	30 e5       	ldi	r19, 0x50	; 80
    3c32:	a0 ec       	ldi	r26, 0xC0	; 192
    3c34:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    3c36:	c1 e7       	ldi	r28, 0x71	; 113
    3c38:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3c3a:	f9 01       	movw	r30, r18
    3c3c:	e8 0f       	add	r30, r24
    3c3e:	f9 1f       	adc	r31, r25
    3c40:	40 81       	ld	r20, Z
    3c42:	13 96       	adiw	r26, 0x03	; 3
    3c44:	4c 93       	st	X, r20
    3c46:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3c48:	12 96       	adiw	r26, 0x02	; 2
    3c4a:	4c 91       	ld	r20, X
    3c4c:	12 97       	sbiw	r26, 0x02	; 2
    3c4e:	44 23       	and	r20, r20
    3c50:	dc f7       	brge	.-10     	; 0x3c48 <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
    3c52:	13 96       	adiw	r26, 0x03	; 3
    3c54:	4c 91       	ld	r20, X
    3c56:	13 97       	sbiw	r26, 0x03	; 3
    3c58:	48 83       	st	Y, r20
    3c5a:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3c5c:	83 30       	cpi	r24, 0x03	; 3
    3c5e:	91 05       	cpc	r25, r1
    3c60:	61 f7       	brne	.-40     	; 0x3c3a <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    3c62:	80 e0       	ldi	r24, 0x00	; 0
    3c64:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	portExCS(FALSE);
    3c68:	80 e0       	ldi	r24, 0x00	; 0
    3c6a:	0e 94 39 1d 	call	0x3a72	; 0x3a72 <portExCS>
	SPIDisable();
    3c6e:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <SPIDisable>
}
    3c72:	df 91       	pop	r29
    3c74:	cf 91       	pop	r28
    3c76:	08 95       	ret

00003c78 <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    3c78:	cf 93       	push	r28
    3c7a:	df 93       	push	r29
    3c7c:	c8 2f       	mov	r28, r24
    3c7e:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    3c80:	80 e0       	ldi	r24, 0x00	; 0
    3c82:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <SPIInit>
	SPICS(TRUE);
    3c86:	81 e0       	ldi	r24, 0x01	; 1
    3c88:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	portExCS(TRUE);
    3c8c:	81 e0       	ldi	r24, 0x01	; 1
    3c8e:	0e 94 39 1d 	call	0x3a72	; 0x3a72 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    3c92:	dd 23       	and	r29, r29
    3c94:	81 f0       	breq	.+32     	; 0x3cb6 <PortEx_OUTSET+0x3e>
    3c96:	80 91 d6 23 	lds	r24, 0x23D6
    3c9a:	c8 2b       	or	r28, r24
    3c9c:	c0 93 d6 23 	sts	0x23D6, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
    3ca0:	80 e4       	ldi	r24, 0x40	; 64
    3ca2:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
    3ca6:	84 e1       	ldi	r24, 0x14	; 20
    3ca8:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankA_OUT;
    3cac:	80 91 d6 23 	lds	r24, 0x23D6
    3cb0:	80 93 67 50 	sts	0x5067, r24
    3cb4:	0f c0       	rjmp	.+30     	; 0x3cd4 <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    3cb6:	80 91 82 50 	lds	r24, 0x5082
    3cba:	c8 2b       	or	r28, r24
    3cbc:	c0 93 82 50 	sts	0x5082, r28
	
	SPIBuffer[0] = PS_WRITE;
    3cc0:	80 e4       	ldi	r24, 0x40	; 64
    3cc2:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
    3cc6:	85 e1       	ldi	r24, 0x15	; 21
    3cc8:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = bankB_OUT; 
    3ccc:	80 91 82 50 	lds	r24, 0x5082
    3cd0:	80 93 67 50 	sts	0x5067, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    3cd4:	80 e0       	ldi	r24, 0x00	; 0
    3cd6:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3cd8:	25 e6       	ldi	r18, 0x65	; 101
    3cda:	30 e5       	ldi	r19, 0x50	; 80
    3cdc:	a0 ec       	ldi	r26, 0xC0	; 192
    3cde:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    3ce0:	c1 e7       	ldi	r28, 0x71	; 113
    3ce2:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3ce4:	f9 01       	movw	r30, r18
    3ce6:	e8 0f       	add	r30, r24
    3ce8:	f9 1f       	adc	r31, r25
    3cea:	40 81       	ld	r20, Z
    3cec:	13 96       	adiw	r26, 0x03	; 3
    3cee:	4c 93       	st	X, r20
    3cf0:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3cf2:	12 96       	adiw	r26, 0x02	; 2
    3cf4:	4c 91       	ld	r20, X
    3cf6:	12 97       	sbiw	r26, 0x02	; 2
    3cf8:	44 23       	and	r20, r20
    3cfa:	dc f7       	brge	.-10     	; 0x3cf2 <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
    3cfc:	13 96       	adiw	r26, 0x03	; 3
    3cfe:	4c 91       	ld	r20, X
    3d00:	13 97       	sbiw	r26, 0x03	; 3
    3d02:	48 83       	st	Y, r20
    3d04:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3d06:	83 30       	cpi	r24, 0x03	; 3
    3d08:	91 05       	cpc	r25, r1
    3d0a:	61 f7       	brne	.-40     	; 0x3ce4 <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    3d0c:	80 e0       	ldi	r24, 0x00	; 0
    3d0e:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	portExCS(FALSE);
    3d12:	80 e0       	ldi	r24, 0x00	; 0
    3d14:	0e 94 39 1d 	call	0x3a72	; 0x3a72 <portExCS>
	SPIDisable();
    3d18:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <SPIDisable>
}
    3d1c:	df 91       	pop	r29
    3d1e:	cf 91       	pop	r28
    3d20:	08 95       	ret

00003d22 <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    3d22:	cf 93       	push	r28
    3d24:	df 93       	push	r29
    3d26:	c8 2f       	mov	r28, r24
    3d28:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
    3d2a:	80 e0       	ldi	r24, 0x00	; 0
    3d2c:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <SPIInit>
	SPICS(TRUE);
    3d30:	81 e0       	ldi	r24, 0x01	; 1
    3d32:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	portExCS(TRUE);
    3d36:	81 e0       	ldi	r24, 0x01	; 1
    3d38:	0e 94 39 1d 	call	0x3a72	; 0x3a72 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    3d3c:	dd 23       	and	r29, r29
    3d3e:	89 f0       	breq	.+34     	; 0x3d62 <PortEx_DIRCLR+0x40>
    3d40:	80 91 7a 50 	lds	r24, 0x507A
    3d44:	80 95       	com	r24
    3d46:	c8 23       	and	r28, r24
    3d48:	c0 93 7a 50 	sts	0x507A, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
    3d4c:	80 e4       	ldi	r24, 0x40	; 64
    3d4e:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
    3d52:	10 92 66 50 	sts	0x5066, r1
		SPIBuffer[2] = ~bankA_DIR; 
    3d56:	80 91 7a 50 	lds	r24, 0x507A
    3d5a:	80 95       	com	r24
    3d5c:	80 93 67 50 	sts	0x5067, r24
    3d60:	11 c0       	rjmp	.+34     	; 0x3d84 <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    3d62:	80 91 ce 50 	lds	r24, 0x50CE
    3d66:	80 95       	com	r24
    3d68:	c8 23       	and	r28, r24
    3d6a:	c0 93 ce 50 	sts	0x50CE, r28
	
	SPIBuffer[0] = PS_WRITE;
    3d6e:	80 e4       	ldi	r24, 0x40	; 64
    3d70:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
    3d74:	81 e0       	ldi	r24, 0x01	; 1
    3d76:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = ~bankB_DIR;
    3d7a:	80 91 ce 50 	lds	r24, 0x50CE
    3d7e:	80 95       	com	r24
    3d80:	80 93 67 50 	sts	0x5067, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    3d84:	80 e0       	ldi	r24, 0x00	; 0
    3d86:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3d88:	25 e6       	ldi	r18, 0x65	; 101
    3d8a:	30 e5       	ldi	r19, 0x50	; 80
    3d8c:	a0 ec       	ldi	r26, 0xC0	; 192
    3d8e:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    3d90:	c1 e7       	ldi	r28, 0x71	; 113
    3d92:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3d94:	f9 01       	movw	r30, r18
    3d96:	e8 0f       	add	r30, r24
    3d98:	f9 1f       	adc	r31, r25
    3d9a:	40 81       	ld	r20, Z
    3d9c:	13 96       	adiw	r26, 0x03	; 3
    3d9e:	4c 93       	st	X, r20
    3da0:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3da2:	12 96       	adiw	r26, 0x02	; 2
    3da4:	4c 91       	ld	r20, X
    3da6:	12 97       	sbiw	r26, 0x02	; 2
    3da8:	44 23       	and	r20, r20
    3daa:	dc f7       	brge	.-10     	; 0x3da2 <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
    3dac:	13 96       	adiw	r26, 0x03	; 3
    3dae:	4c 91       	ld	r20, X
    3db0:	13 97       	sbiw	r26, 0x03	; 3
    3db2:	48 83       	st	Y, r20
    3db4:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3db6:	83 30       	cpi	r24, 0x03	; 3
    3db8:	91 05       	cpc	r25, r1
    3dba:	61 f7       	brne	.-40     	; 0x3d94 <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    3dbc:	80 e0       	ldi	r24, 0x00	; 0
    3dbe:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	portExCS(FALSE);
    3dc2:	80 e0       	ldi	r24, 0x00	; 0
    3dc4:	0e 94 39 1d 	call	0x3a72	; 0x3a72 <portExCS>
	SPIDisable();
    3dc8:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <SPIDisable>
}
    3dcc:	df 91       	pop	r29
    3dce:	cf 91       	pop	r28
    3dd0:	08 95       	ret

00003dd2 <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    3dd2:	cf 93       	push	r28
    3dd4:	df 93       	push	r29
    3dd6:	c8 2f       	mov	r28, r24
    3dd8:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
    3dda:	80 e0       	ldi	r24, 0x00	; 0
    3ddc:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <SPIInit>
	SPICS(TRUE);
    3de0:	81 e0       	ldi	r24, 0x01	; 1
    3de2:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	portExCS(TRUE);
    3de6:	81 e0       	ldi	r24, 0x01	; 1
    3de8:	0e 94 39 1d 	call	0x3a72	; 0x3a72 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    3dec:	dd 23       	and	r29, r29
    3dee:	81 f0       	breq	.+32     	; 0x3e10 <PortEx_DIRSET+0x3e>
    3df0:	80 91 7a 50 	lds	r24, 0x507A
    3df4:	c8 2b       	or	r28, r24
    3df6:	c0 93 7a 50 	sts	0x507A, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
    3dfa:	80 e4       	ldi	r24, 0x40	; 64
    3dfc:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
    3e00:	10 92 66 50 	sts	0x5066, r1
		SPIBuffer[2] = ~bankA_DIR; 
    3e04:	80 91 7a 50 	lds	r24, 0x507A
    3e08:	80 95       	com	r24
    3e0a:	80 93 67 50 	sts	0x5067, r24
    3e0e:	10 c0       	rjmp	.+32     	; 0x3e30 <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    3e10:	80 91 ce 50 	lds	r24, 0x50CE
    3e14:	c8 2b       	or	r28, r24
    3e16:	c0 93 ce 50 	sts	0x50CE, r28
	
	SPIBuffer[0] = PS_WRITE;
    3e1a:	80 e4       	ldi	r24, 0x40	; 64
    3e1c:	80 93 65 50 	sts	0x5065, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
    3e20:	81 e0       	ldi	r24, 0x01	; 1
    3e22:	80 93 66 50 	sts	0x5066, r24
		SPIBuffer[2] = ~bankB_DIR;
    3e26:	80 91 ce 50 	lds	r24, 0x50CE
    3e2a:	80 95       	com	r24
    3e2c:	80 93 67 50 	sts	0x5067, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    3e30:	80 e0       	ldi	r24, 0x00	; 0
    3e32:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3e34:	25 e6       	ldi	r18, 0x65	; 101
    3e36:	30 e5       	ldi	r19, 0x50	; 80
    3e38:	a0 ec       	ldi	r26, 0xC0	; 192
    3e3a:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    3e3c:	c1 e7       	ldi	r28, 0x71	; 113
    3e3e:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3e40:	f9 01       	movw	r30, r18
    3e42:	e8 0f       	add	r30, r24
    3e44:	f9 1f       	adc	r31, r25
    3e46:	40 81       	ld	r20, Z
    3e48:	13 96       	adiw	r26, 0x03	; 3
    3e4a:	4c 93       	st	X, r20
    3e4c:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    3e4e:	12 96       	adiw	r26, 0x02	; 2
    3e50:	4c 91       	ld	r20, X
    3e52:	12 97       	sbiw	r26, 0x02	; 2
    3e54:	44 23       	and	r20, r20
    3e56:	dc f7       	brge	.-10     	; 0x3e4e <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    3e58:	13 96       	adiw	r26, 0x03	; 3
    3e5a:	4c 91       	ld	r20, X
    3e5c:	13 97       	sbiw	r26, 0x03	; 3
    3e5e:	48 83       	st	Y, r20
    3e60:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3e62:	83 30       	cpi	r24, 0x03	; 3
    3e64:	91 05       	cpc	r25, r1
    3e66:	61 f7       	brne	.-40     	; 0x3e40 <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    3e68:	80 e0       	ldi	r24, 0x00	; 0
    3e6a:	0e 94 39 1d 	call	0x3a72	; 0x3a72 <portExCS>
	SPICS(FALSE);
    3e6e:	80 e0       	ldi	r24, 0x00	; 0
    3e70:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	SPIDisable();
    3e74:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <SPIDisable>


}
    3e78:	df 91       	pop	r29
    3e7a:	cf 91       	pop	r28
    3e7c:	08 95       	ret

00003e7e <readFRAM>:

}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    3e7e:	0f 93       	push	r16
    3e80:	1f 93       	push	r17
    3e82:	cf 93       	push	r28
    3e84:	df 93       	push	r29
    3e86:	8c 01       	movw	r16, r24
	
	SPIInit(SPI_MODE_0_gc);
    3e88:	80 e0       	ldi	r24, 0x00	; 0
    3e8a:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    3e8e:	c0 ec       	ldi	r28, 0xC0	; 192
    3e90:	d8 e0       	ldi	r29, 0x08	; 8
    3e92:	80 ed       	ldi	r24, 0xD0	; 208
    3e94:	88 83       	st	Y, r24
	SPICS(TRUE);
    3e96:	81 e0       	ldi	r24, 0x01	; 1
    3e98:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3e9c:	88 e0       	ldi	r24, 0x08	; 8
    3e9e:	e0 e2       	ldi	r30, 0x20	; 32
    3ea0:	f6 e0       	ldi	r31, 0x06	; 6
    3ea2:	86 83       	std	Z+6, r24	; 0x06
	nop();
    3ea4:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    3ea6:	83 e0       	ldi	r24, 0x03	; 3
    3ea8:	8b 83       	std	Y+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3eaa:	e0 ec       	ldi	r30, 0xC0	; 192
    3eac:	f8 e0       	ldi	r31, 0x08	; 8
    3eae:	82 81       	ldd	r24, Z+2	; 0x02
    3eb0:	88 23       	and	r24, r24
    3eb2:	ec f7       	brge	.-6      	; 0x3eae <readFRAM+0x30>
	SPIBuffer[12] = SPIC.DATA;
    3eb4:	e0 ec       	ldi	r30, 0xC0	; 192
    3eb6:	f8 e0       	ldi	r31, 0x08	; 8
    3eb8:	83 81       	ldd	r24, Z+3	; 0x03
    3eba:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    3ebe:	80 91 58 40 	lds	r24, 0x4058
    3ec2:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3ec4:	82 81       	ldd	r24, Z+2	; 0x02
    3ec6:	88 23       	and	r24, r24
    3ec8:	ec f7       	brge	.-6      	; 0x3ec4 <readFRAM+0x46>
	SPIBuffer[12] = SPIC.DATA;
    3eca:	e0 ec       	ldi	r30, 0xC0	; 192
    3ecc:	f8 e0       	ldi	r31, 0x08	; 8
    3ece:	83 81       	ldd	r24, Z+3	; 0x03
    3ed0:	80 93 71 50 	sts	0x5071, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    3ed4:	80 91 57 40 	lds	r24, 0x4057
    3ed8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3eda:	82 81       	ldd	r24, Z+2	; 0x02
    3edc:	88 23       	and	r24, r24
    3ede:	ec f7       	brge	.-6      	; 0x3eda <readFRAM+0x5c>
	SPIBuffer[12] = SPIC.DATA;
    3ee0:	e0 ec       	ldi	r30, 0xC0	; 192
    3ee2:	f8 e0       	ldi	r31, 0x08	; 8
    3ee4:	83 81       	ldd	r24, Z+3	; 0x03
    3ee6:	80 93 71 50 	sts	0x5071, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    3eea:	01 15       	cp	r16, r1
    3eec:	11 05       	cpc	r17, r1
    3eee:	b1 f0       	breq	.+44     	; 0x3f1c <readFRAM+0x9e>
    3ef0:	ef ed       	ldi	r30, 0xDF	; 223
    3ef2:	f3 e2       	ldi	r31, 0x23	; 35

}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    3ef4:	0e 0f       	add	r16, r30
    3ef6:	1f 1f       	adc	r17, r31
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
		SPIC.DATA = 0xAA;
    3ef8:	a0 ec       	ldi	r26, 0xC0	; 192
    3efa:	b8 e0       	ldi	r27, 0x08	; 8
    3efc:	9a ea       	ldi	r25, 0xAA	; 170
    3efe:	13 96       	adiw	r26, 0x03	; 3
    3f00:	9c 93       	st	X, r25
    3f02:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3f04:	12 96       	adiw	r26, 0x02	; 2
    3f06:	8c 91       	ld	r24, X
    3f08:	12 97       	sbiw	r26, 0x02	; 2
    3f0a:	88 23       	and	r24, r24
    3f0c:	dc f7       	brge	.-10     	; 0x3f04 <readFRAM+0x86>
		FRAMReadBuffer[i] = SPIC.DATA;
    3f0e:	13 96       	adiw	r26, 0x03	; 3
    3f10:	8c 91       	ld	r24, X
    3f12:	13 97       	sbiw	r26, 0x03	; 3
    3f14:	81 93       	st	Z+, r24
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    3f16:	e0 17       	cp	r30, r16
    3f18:	f1 07       	cpc	r31, r17
    3f1a:	89 f7       	brne	.-30     	; 0x3efe <readFRAM+0x80>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    3f1c:	88 e0       	ldi	r24, 0x08	; 8
    3f1e:	e0 e2       	ldi	r30, 0x20	; 32
    3f20:	f6 e0       	ldi	r31, 0x06	; 6
    3f22:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
    3f24:	80 e0       	ldi	r24, 0x00	; 0
    3f26:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	SPIDisable();
    3f2a:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <SPIDisable>

}
    3f2e:	df 91       	pop	r29
    3f30:	cf 91       	pop	r28
    3f32:	1f 91       	pop	r17
    3f34:	0f 91       	pop	r16
    3f36:	08 95       	ret

00003f38 <FRAMTest3Channel>:
//test 3 channel sampling of accelerometer. OBSOLETE
void FRAMTest3Channel(void) {
	//uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
			
	//CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |	FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,	gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    3f38:	81 e0       	ldi	r24, 0x01	; 1
    3f3a:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>
    3f3e:	8f ec       	ldi	r24, 0xCF	; 207
    3f40:	97 e0       	ldi	r25, 0x07	; 7
    3f42:	01 97       	sbiw	r24, 0x01	; 1
    3f44:	f1 f7       	brne	.-4      	; 0x3f42 <FRAMTest3Channel+0xa>
    3f46:	00 c0       	rjmp	.+0      	; 0x3f48 <FRAMTest3Channel+0x10>
    3f48:	00 00       	nop
	_delay_us(250);
	
	calcChecksumFRAM();
    3f4a:	0e 94 eb 0e 	call	0x1dd6	; 0x1dd6 <calcChecksumFRAM>

	ADCPower(FALSE);
    3f4e:	80 e0       	ldi	r24, 0x00	; 0
    3f50:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>
	
}
    3f54:	08 95       	ret

00003f56 <FRAMTest1Channel>:
//test 1 channel sampling of accelerometer. OBSOLETE
void FRAMTest1Channel(void) {

	//CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc, GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    3f56:	81 e0       	ldi	r24, 0x01	; 1
    3f58:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>
    3f5c:	8f ec       	ldi	r24, 0xCF	; 207
    3f5e:	97 e0       	ldi	r25, 0x07	; 7
    3f60:	01 97       	sbiw	r24, 0x01	; 1
    3f62:	f1 f7       	brne	.-4      	; 0x3f60 <FRAMTest1Channel+0xa>
    3f64:	00 c0       	rjmp	.+0      	; 0x3f66 <FRAMTest1Channel+0x10>
    3f66:	00 00       	nop
	_delay_us(250);
	
	calcChecksumFRAM();
    3f68:	0e 94 eb 0e 	call	0x1dd6	; 0x1dd6 <calcChecksumFRAM>

	ADCPower(FALSE);
    3f6c:	80 e0       	ldi	r24, 0x00	; 0
    3f6e:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>

}
    3f72:	08 95       	ret

00003f74 <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
	
	FRAMWriteKnowns();
    3f74:	0e 94 55 11 	call	0x22aa	; 0x22aa <FRAMWriteKnowns>
	ADCPower(TRUE);
    3f78:	81 e0       	ldi	r24, 0x01	; 1
    3f7a:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>
    3f7e:	8f ec       	ldi	r24, 0xCF	; 207
    3f80:	97 e0       	ldi	r25, 0x07	; 7
    3f82:	01 97       	sbiw	r24, 0x01	; 1
    3f84:	f1 f7       	brne	.-4      	; 0x3f82 <FRAMWriteKnownsCheck+0xe>
    3f86:	00 c0       	rjmp	.+0      	; 0x3f88 <FRAMWriteKnownsCheck+0x14>
    3f88:	00 00       	nop

	_delay_us(250);
	calcChecksumFRAM();
    3f8a:	0e 94 eb 0e 	call	0x1dd6	; 0x1dd6 <calcChecksumFRAM>

	ADCPower(FALSE);
    3f8e:	80 e0       	ldi	r24, 0x00	; 0
    3f90:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>

}
    3f94:	08 95       	ret

00003f96 <checkMote>:

//random function for testing stuff	
void checkMote(){
	
	ADCPower(TRUE);
    3f96:	81 e0       	ldi	r24, 0x01	; 1
    3f98:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>
	Ext1Power(TRUE);
    3f9c:	81 e0       	ldi	r24, 0x01	; 1
    3f9e:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3fa2:	8f ef       	ldi	r24, 0xFF	; 255
    3fa4:	93 ec       	ldi	r25, 0xC3	; 195
    3fa6:	a9 e0       	ldi	r26, 0x09	; 9
    3fa8:	81 50       	subi	r24, 0x01	; 1
    3faa:	90 40       	sbci	r25, 0x00	; 0
    3fac:	a0 40       	sbci	r26, 0x00	; 0
    3fae:	e1 f7       	brne	.-8      	; 0x3fa8 <checkMote+0x12>
    3fb0:	00 c0       	rjmp	.+0      	; 0x3fb2 <checkMote+0x1c>
    3fb2:	00 00       	nop
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    3fb4:	88 e0       	ldi	r24, 0x08	; 8
    3fb6:	60 e0       	ldi	r22, 0x00	; 0
    3fb8:	0e 94 e9 1e 	call	0x3dd2	; 0x3dd2 <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    3fbc:	88 e0       	ldi	r24, 0x08	; 8
    3fbe:	60 e0       	ldi	r22, 0x00	; 0
    3fc0:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <PortEx_OUTSET>
    3fc4:	8a ea       	ldi	r24, 0xAA	; 170
    3fc6:	96 ee       	ldi	r25, 0xE6	; 230
    3fc8:	a6 e9       	ldi	r26, 0x96	; 150
    3fca:	b1 e0       	ldi	r27, 0x01	; 1
    3fcc:	81 50       	subi	r24, 0x01	; 1
    3fce:	90 40       	sbci	r25, 0x00	; 0
    3fd0:	a0 40       	sbci	r26, 0x00	; 0
    3fd2:	b0 40       	sbci	r27, 0x00	; 0
    3fd4:	d9 f7       	brne	.-10     	; 0x3fcc <checkMote+0x36>
    3fd6:	00 00       	nop
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    3fd8:	88 e0       	ldi	r24, 0x08	; 8
    3fda:	60 e0       	ldi	r22, 0x00	; 0
    3fdc:	0e 94 e5 1d 	call	0x3bca	; 0x3bca <PortEx_OUTCLR>
    3fe0:	8a ea       	ldi	r24, 0xAA	; 170
    3fe2:	96 ee       	ldi	r25, 0xE6	; 230
    3fe4:	a6 e9       	ldi	r26, 0x96	; 150
    3fe6:	b1 e0       	ldi	r27, 0x01	; 1
    3fe8:	81 50       	subi	r24, 0x01	; 1
    3fea:	90 40       	sbci	r25, 0x00	; 0
    3fec:	a0 40       	sbci	r26, 0x00	; 0
    3fee:	b0 40       	sbci	r27, 0x00	; 0
    3ff0:	d9 f7       	brne	.-10     	; 0x3fe8 <checkMote+0x52>
    3ff2:	00 00       	nop
    3ff4:	e3 cf       	rjmp	.-58     	; 0x3fbc <checkMote+0x26>

00003ff6 <SD_write_and_read_knowns>:
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    3ff6:	0f 93       	push	r16
    3ff8:	1f 93       	push	r17
    3ffa:	cf 93       	push	r28
    3ffc:	df 93       	push	r29
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    3ffe:	0f ed       	ldi	r16, 0xDF	; 223
    4000:	13 e2       	ldi	r17, 0x23	; 35
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    4002:	f8 01       	movw	r30, r16
    4004:	80 e0       	ldi	r24, 0x00	; 0
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    4006:	81 93       	st	Z+, r24
    4008:	8f 5f       	subi	r24, 0xFF	; 255
    400a:	88 31       	cpi	r24, 0x18	; 24
    400c:	e1 f7       	brne	.-8      	; 0x4006 <SD_write_and_read_knowns+0x10>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    400e:	cf ed       	ldi	r28, 0xDF	; 223
    4010:	d3 e2       	ldi	r29, 0x23	; 35
    4012:	64 e1       	ldi	r22, 0x14	; 20
    4014:	70 e0       	ldi	r23, 0x00	; 0
    4016:	80 e0       	ldi	r24, 0x00	; 0
    4018:	90 e0       	ldi	r25, 0x00	; 0
    401a:	ae 01       	movw	r20, r28
    401c:	28 e1       	ldi	r18, 0x18	; 24
    401e:	30 e0       	ldi	r19, 0x00	; 0
    4020:	0e 94 29 2c 	call	0x5852	; 0x5852 <SD_write_block>
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    4024:	68 96       	adiw	r28, 0x18	; 24
    4026:	f8 01       	movw	r30, r16
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    4028:	11 92       	st	Z+, r1
    402a:	ec 17       	cp	r30, r28
    402c:	fd 07       	cpc	r31, r29
    402e:	e1 f7       	brne	.-8      	; 0x4028 <SD_write_and_read_knowns+0x32>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    4030:	64 e1       	ldi	r22, 0x14	; 20
    4032:	70 e0       	ldi	r23, 0x00	; 0
    4034:	80 e0       	ldi	r24, 0x00	; 0
    4036:	90 e0       	ldi	r25, 0x00	; 0
    4038:	4f ed       	ldi	r20, 0xDF	; 223
    403a:	53 e2       	ldi	r21, 0x23	; 35
    403c:	0e 94 de 2c 	call	0x59bc	; 0x59bc <SD_read_block>
    4040:	f8 01       	movw	r30, r16
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    4042:	20 e0       	ldi	r18, 0x00	; 0
    4044:	30 e0       	ldi	r19, 0x00	; 0
    4046:	c4 e6       	ldi	r28, 0x64	; 100
    4048:	d0 e0       	ldi	r29, 0x00	; 0
    404a:	c9 01       	movw	r24, r18
    404c:	be 01       	movw	r22, r28
    404e:	0e 94 b7 3a 	call	0x756e	; 0x756e <__divmodhi4>
    4052:	81 93       	st	Z+, r24
    4054:	2f 5f       	subi	r18, 0xFF	; 255
    4056:	3f 4f       	sbci	r19, 0xFF	; 255
    4058:	84 e0       	ldi	r24, 0x04	; 4
    405a:	22 3e       	cpi	r18, 0xE2	; 226
    405c:	38 07       	cpc	r19, r24
    405e:	a9 f7       	brne	.-22     	; 0x404a <SD_write_and_read_knowns+0x54>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    4060:	60 e5       	ldi	r22, 0x50	; 80
    4062:	70 e0       	ldi	r23, 0x00	; 0
    4064:	80 e0       	ldi	r24, 0x00	; 0
    4066:	90 e0       	ldi	r25, 0x00	; 0
    4068:	4f ed       	ldi	r20, 0xDF	; 223
    406a:	53 e2       	ldi	r21, 0x23	; 35
    406c:	22 ee       	ldi	r18, 0xE2	; 226
    406e:	34 e0       	ldi	r19, 0x04	; 4
    4070:	0e 94 45 2d 	call	0x5a8a	; 0x5a8a <SD_write_multiple_blocks>
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    4074:	81 ec       	ldi	r24, 0xC1	; 193
    4076:	98 e2       	ldi	r25, 0x28	; 40
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    4078:	f8 01       	movw	r30, r16
    407a:	11 92       	st	Z+, r1
    407c:	8f 01       	movw	r16, r30
    407e:	e8 17       	cp	r30, r24
    4080:	f9 07       	cpc	r31, r25
    4082:	d1 f7       	brne	.-12     	; 0x4078 <SD_write_and_read_knowns+0x82>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    4084:	60 e5       	ldi	r22, 0x50	; 80
    4086:	70 e0       	ldi	r23, 0x00	; 0
    4088:	80 e0       	ldi	r24, 0x00	; 0
    408a:	90 e0       	ldi	r25, 0x00	; 0
    408c:	4f ed       	ldi	r20, 0xDF	; 223
    408e:	53 e2       	ldi	r21, 0x23	; 35
    4090:	23 e0       	ldi	r18, 0x03	; 3
    4092:	30 e0       	ldi	r19, 0x00	; 0
    4094:	0e 94 9f 2e 	call	0x5d3e	; 0x5d3e <SD_read_multiple_blocks>
}
    4098:	df 91       	pop	r29
    409a:	cf 91       	pop	r28
    409c:	1f 91       	pop	r17
    409e:	0f 91       	pop	r16
    40a0:	08 95       	ret

000040a2 <SD_write_and_read_knowns_FAT>:

//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    40a2:	0f 93       	push	r16
    40a4:	1f 93       	push	r17
    40a6:	cf 93       	push	r28
    40a8:	df 93       	push	r29
    40aa:	0f ed       	ldi	r16, 0xDF	; 223
    40ac:	13 e2       	ldi	r17, 0x23	; 35
    40ae:	f8 01       	movw	r30, r16
    40b0:	80 e0       	ldi	r24, 0x00	; 0
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    40b2:	81 93       	st	Z+, r24
    40b4:	8f 5f       	subi	r24, 0xFF	; 255
    40b6:	88 31       	cpi	r24, 0x18	; 24
    40b8:	e1 f7       	brne	.-8      	; 0x40b2 <SD_write_and_read_knowns_FAT+0x10>
	error = writeFile((unsigned char*)"testing",FRAMReadBuffer,512);
    40ba:	cf ed       	ldi	r28, 0xDF	; 223
    40bc:	d3 e2       	ldi	r29, 0x23	; 35
    40be:	86 e1       	ldi	r24, 0x16	; 22
    40c0:	90 e2       	ldi	r25, 0x20	; 32
    40c2:	be 01       	movw	r22, r28
    40c4:	20 e0       	ldi	r18, 0x00	; 0
    40c6:	32 e0       	ldi	r19, 0x02	; 2
    40c8:	40 e0       	ldi	r20, 0x00	; 0
    40ca:	50 e0       	ldi	r21, 0x00	; 0
    40cc:	0e 94 16 28 	call	0x502c	; 0x502c <writeFile>
    40d0:	80 93 a3 50 	sts	0x50A3, r24
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
}

//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    40d4:	68 96       	adiw	r28, 0x18	; 24
	
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
	error = writeFile((unsigned char*)"testing",FRAMReadBuffer,512);
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    40d6:	f8 01       	movw	r30, r16
    40d8:	11 92       	st	Z+, r1
    40da:	8f 01       	movw	r16, r30
    40dc:	ec 17       	cp	r30, r28
    40de:	fd 07       	cpc	r31, r29
    40e0:	d1 f7       	brne	.-12     	; 0x40d6 <SD_write_and_read_knowns_FAT+0x34>
	error = readFile(READ,(unsigned char*)"testing");		//read the data into the buffer from file
    40e2:	80 e0       	ldi	r24, 0x00	; 0
    40e4:	66 e1       	ldi	r22, 0x16	; 22
    40e6:	70 e2       	ldi	r23, 0x20	; 32
    40e8:	0e 94 9a 27 	call	0x4f34	; 0x4f34 <readFile>
    40ec:	80 93 a3 50 	sts	0x50A3, r24
}
    40f0:	df 91       	pop	r29
    40f2:	cf 91       	pop	r28
    40f4:	1f 91       	pop	r17
    40f6:	0f 91       	pop	r16
    40f8:	08 95       	ret

000040fa <chibi_test_radio>:


//function for testing radio transmission
void chibi_test_radio(){
		
	chb_init();
    40fa:	0e 94 49 16 	call	0x2c92	; 0x2c92 <chb_init>
	chb_set_short_addr(0x0002);
    40fe:	82 e0       	ldi	r24, 0x02	; 2
    4100:	90 e0       	ldi	r25, 0x00	; 0
    4102:	0e 94 80 18 	call	0x3100	; 0x3100 <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    4106:	00 00       	nop
    4108:	fe cf       	rjmp	.-4      	; 0x4106 <chibi_test_radio+0xc>

0000410a <TestCard>:
	chb_read(FRAMReadBuffer);
	*/
}

//another testing function for sd card
void TestCard(){
    410a:	cf 93       	push	r28
    410c:	df 93       	push	r29
	
	SD_init();
    410e:	0e 94 4f 2b 	call	0x569e	; 0x569e <SD_init>
	getBootSectorData();
    4112:	0e 94 2f 23 	call	0x465e	; 0x465e <getBootSectorData>
    4116:	ef ed       	ldi	r30, 0xDF	; 223
    4118:	f3 e2       	ldi	r31, 0x23	; 35
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    411a:	20 e0       	ldi	r18, 0x00	; 0
    411c:	30 e0       	ldi	r19, 0x00	; 0
    411e:	c9 e7       	ldi	r28, 0x79	; 121
    4120:	d0 e0       	ldi	r29, 0x00	; 0
    4122:	c9 01       	movw	r24, r18
    4124:	be 01       	movw	r22, r28
    4126:	0e 94 b7 3a 	call	0x756e	; 0x756e <__divmodhi4>
    412a:	81 93       	st	Z+, r24
    412c:	2f 5f       	subi	r18, 0xFF	; 255
    412e:	3f 4f       	sbci	r19, 0xFF	; 255
    4130:	82 e0       	ldi	r24, 0x02	; 2
    4132:	20 30       	cpi	r18, 0x00	; 0
    4134:	38 07       	cpc	r19, r24
    4136:	a9 f7       	brne	.-22     	; 0x4122 <TestCard+0x18>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile((unsigned char*)"testing",FRAMReadBuffer,512);//}
    4138:	86 e1       	ldi	r24, 0x16	; 22
    413a:	90 e2       	ldi	r25, 0x20	; 32
    413c:	6f ed       	ldi	r22, 0xDF	; 223
    413e:	73 e2       	ldi	r23, 0x23	; 35
    4140:	20 e0       	ldi	r18, 0x00	; 0
    4142:	32 e0       	ldi	r19, 0x02	; 2
    4144:	40 e0       	ldi	r20, 0x00	; 0
    4146:	50 e0       	ldi	r21, 0x00	; 0
    4148:	0e 94 16 28 	call	0x502c	; 0x502c <writeFile>
	nop();
    414c:	00 00       	nop
}
    414e:	df 91       	pop	r29
    4150:	cf 91       	pop	r28
    4152:	08 95       	ret

00004154 <__vector_43>:

//interrupt service routine for handling received data over radio. Gets called when data received by the mote. Has cases for synching right now.
ISR(PORTE_INT0_vect){
    4154:	1f 92       	push	r1
    4156:	0f 92       	push	r0
    4158:	0f b6       	in	r0, 0x3f	; 63
    415a:	0f 92       	push	r0
    415c:	0b b6       	in	r0, 0x3b	; 59
    415e:	0f 92       	push	r0
    4160:	11 24       	eor	r1, r1
    4162:	2f 93       	push	r18
    4164:	3f 93       	push	r19
    4166:	4f 93       	push	r20
    4168:	5f 93       	push	r21
    416a:	6f 93       	push	r22
    416c:	7f 93       	push	r23
    416e:	8f 93       	push	r24
    4170:	9f 93       	push	r25
    4172:	af 93       	push	r26
    4174:	bf 93       	push	r27
    4176:	ef 93       	push	r30
    4178:	ff 93       	push	r31
	
	chb_rx_data_t* msg = NULL;
	switch (RadioMonitorMode) {
    417a:	80 91 5e 40 	lds	r24, 0x405E
    417e:	81 30       	cpi	r24, 0x01	; 1
    4180:	21 f0       	breq	.+8      	; 0x418a <__vector_43+0x36>
    4182:	82 30       	cpi	r24, 0x02	; 2
    4184:	09 f0       	breq	.+2      	; 0x4188 <__vector_43+0x34>
    4186:	72 c0       	rjmp	.+228    	; 0x426c <__vector_43+0x118>
    4188:	55 c0       	rjmp	.+170    	; 0x4234 <__vector_43+0xe0>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    418a:	80 e0       	ldi	r24, 0x00	; 0
    418c:	90 e0       	ldi	r25, 0x00	; 0
    418e:	0e 94 21 17 	call	0x2e42	; 0x2e42 <chb_read>
			if(!strncmp((const char*)(msg->data),"reset",5)){
    4192:	85 e0       	ldi	r24, 0x05	; 5
    4194:	90 e0       	ldi	r25, 0x00	; 0
    4196:	6e e1       	ldi	r22, 0x1E	; 30
    4198:	70 e2       	ldi	r23, 0x20	; 32
    419a:	45 e0       	ldi	r20, 0x05	; 5
    419c:	50 e0       	ldi	r21, 0x00	; 0
    419e:	0e 94 5c 3b 	call	0x76b8	; 0x76b8 <strncmp>
    41a2:	28 2f       	mov	r18, r24
    41a4:	39 2f       	mov	r19, r25
    41a6:	21 15       	cp	r18, r1
    41a8:	31 05       	cpc	r19, r1
    41aa:	51 f4       	brne	.+20     	; 0x41c0 <__vector_43+0x6c>
				MotesReadyToSynch++;
    41ac:	80 91 78 50 	lds	r24, 0x5078
    41b0:	90 91 79 50 	lds	r25, 0x5079
    41b4:	01 96       	adiw	r24, 0x01	; 1
    41b6:	80 93 78 50 	sts	0x5078, r24
    41ba:	90 93 79 50 	sts	0x5079, r25
    41be:	56 c0       	rjmp	.+172    	; 0x426c <__vector_43+0x118>
    41c0:	e5 e0       	ldi	r30, 0x05	; 5
    41c2:	f0 e0       	ldi	r31, 0x00	; 0
    41c4:	af ed       	ldi	r26, 0xDF	; 223
    41c6:	b3 e2       	ldi	r27, 0x23	; 35
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
    41c8:	81 91       	ld	r24, Z+
    41ca:	8d 93       	st	X+, r24
    41cc:	e5 38       	cpi	r30, 0x85	; 133
    41ce:	f1 05       	cpc	r31, r1
    41d0:	d9 f7       	brne	.-10     	; 0x41c8 <__vector_43+0x74>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    41d2:	80 91 c2 50 	lds	r24, 0x50C2
    41d6:	90 91 c3 50 	lds	r25, 0x50C3
    41da:	a0 91 c4 50 	lds	r26, 0x50C4
    41de:	b0 91 c5 50 	lds	r27, 0x50C5
    41e2:	80 58       	subi	r24, 0x80	; 128
    41e4:	9f 4f       	sbci	r25, 0xFF	; 255
    41e6:	af 4f       	sbci	r26, 0xFF	; 255
    41e8:	bf 4f       	sbci	r27, 0xFF	; 255
    41ea:	80 93 c2 50 	sts	0x50C2, r24
    41ee:	90 93 c3 50 	sts	0x50C3, r25
    41f2:	a0 93 c4 50 	sts	0x50C4, r26
    41f6:	b0 93 c5 50 	sts	0x50C5, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    41fa:	80 91 c2 50 	lds	r24, 0x50C2
    41fe:	90 91 c3 50 	lds	r25, 0x50C3
    4202:	a0 91 c4 50 	lds	r26, 0x50C4
    4206:	b0 91 c5 50 	lds	r27, 0x50C5
    420a:	80 58       	subi	r24, 0x80	; 128
    420c:	9f 4f       	sbci	r25, 0xFF	; 255
    420e:	af 4f       	sbci	r26, 0xFF	; 255
    4210:	bf 4f       	sbci	r27, 0xFF	; 255
    4212:	81 37       	cpi	r24, 0x71	; 113
    4214:	2c e1       	ldi	r18, 0x1C	; 28
    4216:	92 07       	cpc	r25, r18
    4218:	20 e0       	ldi	r18, 0x00	; 0
    421a:	a2 07       	cpc	r26, r18
    421c:	20 e0       	ldi	r18, 0x00	; 0
    421e:	b2 07       	cpc	r27, r18
    4220:	28 f1       	brcs	.+74     	; 0x426c <__vector_43+0x118>
    4222:	10 92 c2 50 	sts	0x50C2, r1
    4226:	10 92 c3 50 	sts	0x50C3, r1
    422a:	10 92 c4 50 	sts	0x50C4, r1
    422e:	10 92 c5 50 	sts	0x50C5, r1
    4232:	1c c0       	rjmp	.+56     	; 0x426c <__vector_43+0x118>
			}			
			break;
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    4234:	80 e0       	ldi	r24, 0x00	; 0
    4236:	90 e0       	ldi	r25, 0x00	; 0
    4238:	0e 94 21 17 	call	0x2e42	; 0x2e42 <chb_read>
			if(!strncmp((const char*)(msg->data),"start sampling",14)){	//if basestation synch response message received, do the following
    423c:	85 e0       	ldi	r24, 0x05	; 5
    423e:	90 e0       	ldi	r25, 0x00	; 0
    4240:	64 e2       	ldi	r22, 0x24	; 36
    4242:	70 e2       	ldi	r23, 0x20	; 32
    4244:	4e e0       	ldi	r20, 0x0E	; 14
    4246:	50 e0       	ldi	r21, 0x00	; 0
    4248:	0e 94 5c 3b 	call	0x76b8	; 0x76b8 <strncmp>
    424c:	28 2f       	mov	r18, r24
    424e:	39 2f       	mov	r19, r25
    4250:	21 15       	cp	r18, r1
    4252:	31 05       	cpc	r19, r1
    4254:	59 f4       	brne	.+22     	; 0x426c <__vector_43+0x118>
				RadioMonitorMode = SYNCHED;
    4256:	83 e0       	ldi	r24, 0x03	; 3
    4258:	80 93 5e 40 	sts	0x405E, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    425c:	89 e0       	ldi	r24, 0x09	; 9
    425e:	80 93 40 09 	sts	0x0940, r24
				TCC1.CTRLA = 0x01;  
    4262:	81 e0       	ldi	r24, 0x01	; 1
    4264:	80 93 40 08 	sts	0x0840, r24
				ADC_Resume_Sampling();	//resume sampling with the adc
    4268:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <ADC_Resume_Sampling>
			}
			break;
		default:
			break;
	}
}
    426c:	ff 91       	pop	r31
    426e:	ef 91       	pop	r30
    4270:	bf 91       	pop	r27
    4272:	af 91       	pop	r26
    4274:	9f 91       	pop	r25
    4276:	8f 91       	pop	r24
    4278:	7f 91       	pop	r23
    427a:	6f 91       	pop	r22
    427c:	5f 91       	pop	r21
    427e:	4f 91       	pop	r20
    4280:	3f 91       	pop	r19
    4282:	2f 91       	pop	r18
    4284:	0f 90       	pop	r0
    4286:	0b be       	out	0x3b, r0	; 59
    4288:	0f 90       	pop	r0
    428a:	0f be       	out	0x3f, r0	; 63
    428c:	0f 90       	pop	r0
    428e:	1f 90       	pop	r1
    4290:	18 95       	reti

00004292 <DeciToString>:

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
    4292:	2f 92       	push	r2
    4294:	3f 92       	push	r3
    4296:	4f 92       	push	r4
    4298:	5f 92       	push	r5
    429a:	6f 92       	push	r6
    429c:	7f 92       	push	r7
    429e:	8f 92       	push	r8
    42a0:	9f 92       	push	r9
    42a2:	af 92       	push	r10
    42a4:	bf 92       	push	r11
    42a6:	cf 92       	push	r12
    42a8:	df 92       	push	r13
    42aa:	ef 92       	push	r14
    42ac:	ff 92       	push	r15
    42ae:	0f 93       	push	r16
    42b0:	1f 93       	push	r17
    42b2:	cf 93       	push	r28
    42b4:	df 93       	push	r29
    42b6:	cd b7       	in	r28, 0x3d	; 61
    42b8:	de b7       	in	r29, 0x3e	; 62
    42ba:	64 97       	sbiw	r28, 0x14	; 20
    42bc:	cd bf       	out	0x3d, r28	; 61
    42be:	de bf       	out	0x3e, r29	; 62
    42c0:	2a 01       	movw	r4, r20
    42c2:	3b 01       	movw	r6, r22
    42c4:	89 01       	movw	r16, r18
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
    42c6:	f9 01       	movw	r30, r18
    42c8:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
    42ca:	41 15       	cp	r20, r1
    42cc:	51 05       	cpc	r21, r1
    42ce:	61 05       	cpc	r22, r1
    42d0:	71 05       	cpc	r23, r1
    42d2:	09 f4       	brne	.+2      	; 0x42d6 <DeciToString+0x44>
    42d4:	4d c0       	rjmp	.+154    	; 0x4370 <DeciToString+0xde>
    42d6:	88 2e       	mov	r8, r24
    42d8:	99 2e       	mov	r9, r25
    42da:	cc 24       	eor	r12, r12
    42dc:	dd 24       	eor	r13, r13
    42de:	76 01       	movw	r14, r12
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
    42e0:	5e 01       	movw	r10, r28
    42e2:	08 94       	sec
    42e4:	a1 1c       	adc	r10, r1
    42e6:	b1 1c       	adc	r11, r1
    42e8:	0f 2e       	mov	r0, r31
    42ea:	f3 e3       	ldi	r31, 0x33	; 51
    42ec:	2f 2e       	mov	r2, r31
    42ee:	f0 e2       	ldi	r31, 0x20	; 32
    42f0:	3f 2e       	mov	r3, r31
    42f2:	f0 2d       	mov	r31, r0
    42f4:	f4 01       	movw	r30, r8
    42f6:	81 91       	ld	r24, Z+
    42f8:	91 91       	ld	r25, Z+
    42fa:	a1 91       	ld	r26, Z+
    42fc:	b1 91       	ld	r27, Z+
    42fe:	4f 01       	movw	r8, r30
    4300:	2d b7       	in	r18, 0x3d	; 61
    4302:	3e b7       	in	r19, 0x3e	; 62
    4304:	28 50       	subi	r18, 0x08	; 8
    4306:	30 40       	sbci	r19, 0x00	; 0
    4308:	2d bf       	out	0x3d, r18	; 61
    430a:	3e bf       	out	0x3e, r19	; 62
    430c:	2f 5f       	subi	r18, 0xFF	; 255
    430e:	3f 4f       	sbci	r19, 0xFF	; 255
    4310:	ed b7       	in	r30, 0x3d	; 61
    4312:	fe b7       	in	r31, 0x3e	; 62
    4314:	a1 82       	std	Z+1, r10	; 0x01
    4316:	b2 82       	std	Z+2, r11	; 0x02
    4318:	f9 01       	movw	r30, r18
    431a:	22 82       	std	Z+2, r2	; 0x02
    431c:	33 82       	std	Z+3, r3	; 0x03
    431e:	84 83       	std	Z+4, r24	; 0x04
    4320:	95 83       	std	Z+5, r25	; 0x05
    4322:	a6 83       	std	Z+6, r26	; 0x06
    4324:	b7 83       	std	Z+7, r27	; 0x07
    4326:	0e 94 9d 3b 	call	0x773a	; 0x773a <sprintf>
		strcat(ReturnString,b);
    432a:	2d b7       	in	r18, 0x3d	; 61
    432c:	3e b7       	in	r19, 0x3e	; 62
    432e:	28 5f       	subi	r18, 0xF8	; 248
    4330:	3f 4f       	sbci	r19, 0xFF	; 255
    4332:	2d bf       	out	0x3d, r18	; 61
    4334:	3e bf       	out	0x3e, r19	; 62
    4336:	c8 01       	movw	r24, r16
    4338:	b5 01       	movw	r22, r10
    433a:	0e 94 51 3b 	call	0x76a2	; 0x76a2 <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
    433e:	a0 2f       	mov	r26, r16
    4340:	b1 2f       	mov	r27, r17
    4342:	fd 01       	movw	r30, r26
    4344:	01 90       	ld	r0, Z+
    4346:	00 20       	and	r0, r0
    4348:	e9 f7       	brne	.-6      	; 0x4344 <DeciToString+0xb2>
    434a:	31 97       	sbiw	r30, 0x01	; 1
    434c:	ea 1b       	sub	r30, r26
    434e:	fb 0b       	sbc	r31, r27
    4350:	e0 0f       	add	r30, r16
    4352:	f1 1f       	adc	r31, r17
    4354:	8a e0       	ldi	r24, 0x0A	; 10
    4356:	90 e0       	ldi	r25, 0x00	; 0
    4358:	80 83       	st	Z, r24
    435a:	91 83       	std	Z+1, r25	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
    435c:	08 94       	sec
    435e:	c1 1c       	adc	r12, r1
    4360:	d1 1c       	adc	r13, r1
    4362:	e1 1c       	adc	r14, r1
    4364:	f1 1c       	adc	r15, r1
    4366:	c4 14       	cp	r12, r4
    4368:	d5 04       	cpc	r13, r5
    436a:	e6 04       	cpc	r14, r6
    436c:	f7 04       	cpc	r15, r7
    436e:	11 f6       	brne	.-124    	; 0x42f4 <DeciToString+0x62>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}		
    4370:	64 96       	adiw	r28, 0x14	; 20
    4372:	cd bf       	out	0x3d, r28	; 61
    4374:	de bf       	out	0x3e, r29	; 62
    4376:	df 91       	pop	r29
    4378:	cf 91       	pop	r28
    437a:	1f 91       	pop	r17
    437c:	0f 91       	pop	r16
    437e:	ff 90       	pop	r15
    4380:	ef 90       	pop	r14
    4382:	df 90       	pop	r13
    4384:	cf 90       	pop	r12
    4386:	bf 90       	pop	r11
    4388:	af 90       	pop	r10
    438a:	9f 90       	pop	r9
    438c:	8f 90       	pop	r8
    438e:	7f 90       	pop	r7
    4390:	6f 90       	pop	r6
    4392:	5f 90       	pop	r5
    4394:	4f 90       	pop	r4
    4396:	3f 90       	pop	r3
    4398:	2f 90       	pop	r2
    439a:	08 95       	ret

0000439c <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    439c:	cf 92       	push	r12
    439e:	df 92       	push	r13
    43a0:	ef 92       	push	r14
    43a2:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    43a4:	20 91 7b 50 	lds	r18, 0x507B
    43a8:	30 91 7c 50 	lds	r19, 0x507C
    43ac:	c0 90 db 23 	lds	r12, 0x23DB
    43b0:	d0 90 dc 23 	lds	r13, 0x23DC
    43b4:	e0 90 dd 23 	lds	r14, 0x23DD
    43b8:	f0 90 de 23 	lds	r15, 0x23DE
    43bc:	62 50       	subi	r22, 0x02	; 2
    43be:	70 40       	sbci	r23, 0x00	; 0
    43c0:	80 40       	sbci	r24, 0x00	; 0
    43c2:	90 40       	sbci	r25, 0x00	; 0
    43c4:	40 e0       	ldi	r20, 0x00	; 0
    43c6:	50 e0       	ldi	r21, 0x00	; 0
    43c8:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    43cc:	dc 01       	movw	r26, r24
    43ce:	cb 01       	movw	r24, r22
    43d0:	c8 0e       	add	r12, r24
    43d2:	d9 1e       	adc	r13, r25
    43d4:	ea 1e       	adc	r14, r26
    43d6:	fb 1e       	adc	r15, r27
}
    43d8:	6c 2d       	mov	r22, r12
    43da:	7d 2d       	mov	r23, r13
    43dc:	8e 2d       	mov	r24, r14
    43de:	9f 2d       	mov	r25, r15
    43e0:	ff 90       	pop	r15
    43e2:	ef 90       	pop	r14
    43e4:	df 90       	pop	r13
    43e6:	cf 90       	pop	r12
    43e8:	08 95       	ret

000043ea <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    43ea:	3f 92       	push	r3
    43ec:	4f 92       	push	r4
    43ee:	5f 92       	push	r5
    43f0:	6f 92       	push	r6
    43f2:	7f 92       	push	r7
    43f4:	8f 92       	push	r8
    43f6:	9f 92       	push	r9
    43f8:	af 92       	push	r10
    43fa:	bf 92       	push	r11
    43fc:	cf 92       	push	r12
    43fe:	df 92       	push	r13
    4400:	ef 92       	push	r14
    4402:	ff 92       	push	r15
    4404:	0f 93       	push	r16
    4406:	1f 93       	push	r17
    4408:	cf 93       	push	r28
    440a:	df 93       	push	r29
    440c:	00 d0       	rcall	.+0      	; 0x440e <getSetNextCluster+0x24>
    440e:	0f 92       	push	r0
    4410:	cd b7       	in	r28, 0x3d	; 61
    4412:	de b7       	in	r29, 0x3e	; 62
    4414:	dc 01       	movw	r26, r24
    4416:	cb 01       	movw	r24, r22
    4418:	34 2e       	mov	r3, r20
    441a:	09 83       	std	Y+1, r16	; 0x01
    441c:	1a 83       	std	Y+2, r17	; 0x02
    441e:	2b 83       	std	Y+3, r18	; 0x03
    4420:	3c 83       	std	Y+4, r19	; 0x04
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    4422:	80 90 83 50 	lds	r8, 0x5083
    4426:	90 90 84 50 	lds	r9, 0x5084
    442a:	2c 01       	movw	r4, r24
    442c:	3d 01       	movw	r6, r26
    442e:	44 0c       	add	r4, r4
    4430:	55 1c       	adc	r5, r5
    4432:	66 1c       	adc	r6, r6
    4434:	77 1c       	adc	r7, r7
    4436:	44 0c       	add	r4, r4
    4438:	55 1c       	adc	r5, r5
    443a:	66 1c       	adc	r6, r6
    443c:	77 1c       	adc	r7, r7
    443e:	20 91 54 40 	lds	r18, 0x4054
    4442:	30 91 55 40 	lds	r19, 0x4055
    4446:	aa 24       	eor	r10, r10
    4448:	bb 24       	eor	r11, r11
    444a:	80 91 7d 50 	lds	r24, 0x507D
    444e:	90 91 7e 50 	lds	r25, 0x507E
    4452:	a0 91 7f 50 	lds	r26, 0x507F
    4456:	b0 91 80 50 	lds	r27, 0x5080
    445a:	88 0e       	add	r8, r24
    445c:	99 1e       	adc	r9, r25
    445e:	aa 1e       	adc	r10, r26
    4460:	bb 1e       	adc	r11, r27
    4462:	40 e0       	ldi	r20, 0x00	; 0
    4464:	50 e0       	ldi	r21, 0x00	; 0
    4466:	c3 01       	movw	r24, r6
    4468:	b2 01       	movw	r22, r4
    446a:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    446e:	69 01       	movw	r12, r18
    4470:	7a 01       	movw	r14, r20
    4472:	c8 0c       	add	r12, r8
    4474:	d9 1c       	adc	r13, r9
    4476:	ea 1c       	adc	r14, r10
    4478:	fb 1c       	adc	r15, r11

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    447a:	00 91 54 40 	lds	r16, 0x4054
    447e:	10 91 55 40 	lds	r17, 0x4055

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    4482:	c7 01       	movw	r24, r14
    4484:	b6 01       	movw	r22, r12
    4486:	46 ed       	ldi	r20, 0xD6	; 214
    4488:	51 e2       	ldi	r21, 0x21	; 33
    448a:	0e 94 de 2c 	call	0x59bc	; 0x59bc <SD_read_block>

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    448e:	98 01       	movw	r18, r16
    4490:	40 e0       	ldi	r20, 0x00	; 0
    4492:	50 e0       	ldi	r21, 0x00	; 0
    4494:	c3 01       	movw	r24, r6
    4496:	b2 01       	movw	r22, r4
    4498:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    449c:	6a 52       	subi	r22, 0x2A	; 42
    449e:	7e 4d       	sbci	r23, 0xDE	; 222

if(get_set == GET)
    44a0:	33 20       	and	r3, r3
    44a2:	41 f4       	brne	.+16     	; 0x44b4 <getSetNextCluster+0xca>
  return ((*FATEntryValue) & 0x0fffffff);
    44a4:	db 01       	movw	r26, r22
    44a6:	0d 91       	ld	r16, X+
    44a8:	1d 91       	ld	r17, X+
    44aa:	2d 91       	ld	r18, X+
    44ac:	3c 91       	ld	r19, X
    44ae:	13 97       	sbiw	r26, 0x03	; 3
    44b0:	3f 70       	andi	r19, 0x0F	; 15
    44b2:	14 c0       	rjmp	.+40     	; 0x44dc <getSetNextCluster+0xf2>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    44b4:	89 81       	ldd	r24, Y+1	; 0x01
    44b6:	9a 81       	ldd	r25, Y+2	; 0x02
    44b8:	ab 81       	ldd	r26, Y+3	; 0x03
    44ba:	bc 81       	ldd	r27, Y+4	; 0x04
    44bc:	fb 01       	movw	r30, r22
    44be:	80 83       	st	Z, r24
    44c0:	91 83       	std	Z+1, r25	; 0x01
    44c2:	a2 83       	std	Z+2, r26	; 0x02
    44c4:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    44c6:	c7 01       	movw	r24, r14
    44c8:	b6 01       	movw	r22, r12
    44ca:	46 ed       	ldi	r20, 0xD6	; 214
    44cc:	51 e2       	ldi	r21, 0x21	; 33
    44ce:	20 e0       	ldi	r18, 0x00	; 0
    44d0:	32 e0       	ldi	r19, 0x02	; 2
    44d2:	0e 94 29 2c 	call	0x5852	; 0x5852 <SD_write_block>

return (0);
    44d6:	00 e0       	ldi	r16, 0x00	; 0
    44d8:	10 e0       	ldi	r17, 0x00	; 0
    44da:	98 01       	movw	r18, r16
}
    44dc:	60 2f       	mov	r22, r16
    44de:	71 2f       	mov	r23, r17
    44e0:	82 2f       	mov	r24, r18
    44e2:	93 2f       	mov	r25, r19
    44e4:	24 96       	adiw	r28, 0x04	; 4
    44e6:	cd bf       	out	0x3d, r28	; 61
    44e8:	de bf       	out	0x3e, r29	; 62
    44ea:	df 91       	pop	r29
    44ec:	cf 91       	pop	r28
    44ee:	1f 91       	pop	r17
    44f0:	0f 91       	pop	r16
    44f2:	ff 90       	pop	r15
    44f4:	ef 90       	pop	r14
    44f6:	df 90       	pop	r13
    44f8:	cf 90       	pop	r12
    44fa:	bf 90       	pop	r11
    44fc:	af 90       	pop	r10
    44fe:	9f 90       	pop	r9
    4500:	8f 90       	pop	r8
    4502:	7f 90       	pop	r7
    4504:	6f 90       	pop	r6
    4506:	5f 90       	pop	r5
    4508:	4f 90       	pop	r4
    450a:	3f 90       	pop	r3
    450c:	08 95       	ret

0000450e <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    450e:	cf 92       	push	r12
    4510:	df 92       	push	r13
    4512:	ef 92       	push	r14
    4514:	ff 92       	push	r15
    4516:	0f 93       	push	r16
    4518:	1f 93       	push	r17
    451a:	cf 93       	push	r28
    451c:	c8 2f       	mov	r28, r24
    451e:	06 2f       	mov	r16, r22
    4520:	69 01       	movw	r12, r18
    4522:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    4524:	80 91 7d 50 	lds	r24, 0x507D
    4528:	90 91 7e 50 	lds	r25, 0x507E
    452c:	a0 91 7f 50 	lds	r26, 0x507F
    4530:	b0 91 80 50 	lds	r27, 0x5080
    4534:	bc 01       	movw	r22, r24
    4536:	cd 01       	movw	r24, r26
    4538:	6f 5f       	subi	r22, 0xFF	; 255
    453a:	7f 4f       	sbci	r23, 0xFF	; 255
    453c:	8f 4f       	sbci	r24, 0xFF	; 255
    453e:	9f 4f       	sbci	r25, 0xFF	; 255
    4540:	46 ed       	ldi	r20, 0xD6	; 214
    4542:	51 e2       	ldi	r21, 0x21	; 33
    4544:	0e 94 de 2c 	call	0x59bc	; 0x59bc <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    4548:	80 91 d6 21 	lds	r24, 0x21D6
    454c:	90 91 d7 21 	lds	r25, 0x21D7
    4550:	a0 91 d8 21 	lds	r26, 0x21D8
    4554:	b0 91 d9 21 	lds	r27, 0x21D9
    4558:	82 35       	cpi	r24, 0x52	; 82
    455a:	22 e5       	ldi	r18, 0x52	; 82
    455c:	92 07       	cpc	r25, r18
    455e:	21 e6       	ldi	r18, 0x61	; 97
    4560:	a2 07       	cpc	r26, r18
    4562:	21 e4       	ldi	r18, 0x41	; 65
    4564:	b2 07       	cpc	r27, r18
    4566:	09 f0       	breq	.+2      	; 0x456a <getSetFreeCluster+0x5c>
    4568:	63 c0       	rjmp	.+198    	; 0x4630 <getSetFreeCluster+0x122>
    456a:	80 91 ba 23 	lds	r24, 0x23BA
    456e:	90 91 bb 23 	lds	r25, 0x23BB
    4572:	a0 91 bc 23 	lds	r26, 0x23BC
    4576:	b0 91 bd 23 	lds	r27, 0x23BD
    457a:	82 37       	cpi	r24, 0x72	; 114
    457c:	22 e7       	ldi	r18, 0x72	; 114
    457e:	92 07       	cpc	r25, r18
    4580:	21 e4       	ldi	r18, 0x41	; 65
    4582:	a2 07       	cpc	r26, r18
    4584:	21 e6       	ldi	r18, 0x61	; 97
    4586:	b2 07       	cpc	r27, r18
    4588:	09 f0       	breq	.+2      	; 0x458c <getSetFreeCluster+0x7e>
    458a:	56 c0       	rjmp	.+172    	; 0x4638 <getSetFreeCluster+0x12a>
    458c:	80 91 d2 23 	lds	r24, 0x23D2
    4590:	90 91 d3 23 	lds	r25, 0x23D3
    4594:	a0 91 d4 23 	lds	r26, 0x23D4
    4598:	b0 91 d5 23 	lds	r27, 0x23D5
    459c:	80 30       	cpi	r24, 0x00	; 0
    459e:	20 e0       	ldi	r18, 0x00	; 0
    45a0:	92 07       	cpc	r25, r18
    45a2:	25 e5       	ldi	r18, 0x55	; 85
    45a4:	a2 07       	cpc	r26, r18
    45a6:	2a ea       	ldi	r18, 0xAA	; 170
    45a8:	b2 07       	cpc	r27, r18
    45aa:	09 f0       	breq	.+2      	; 0x45ae <getSetFreeCluster+0xa0>
    45ac:	49 c0       	rjmp	.+146    	; 0x4640 <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    45ae:	00 23       	and	r16, r16
    45b0:	a1 f4       	brne	.+40     	; 0x45da <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    45b2:	c1 30       	cpi	r28, 0x01	; 1
    45b4:	49 f4       	brne	.+18     	; 0x45c8 <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    45b6:	00 91 be 23 	lds	r16, 0x23BE
    45ba:	10 91 bf 23 	lds	r17, 0x23BF
    45be:	20 91 c0 23 	lds	r18, 0x23C0
    45c2:	30 91 c1 23 	lds	r19, 0x23C1
    45c6:	3f c0       	rjmp	.+126    	; 0x4646 <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    45c8:	00 91 c2 23 	lds	r16, 0x23C2
    45cc:	10 91 c3 23 	lds	r17, 0x23C3
    45d0:	20 91 c4 23 	lds	r18, 0x23C4
    45d4:	30 91 c5 23 	lds	r19, 0x23C5
    45d8:	36 c0       	rjmp	.+108    	; 0x4646 <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    45da:	c1 30       	cpi	r28, 0x01	; 1
    45dc:	49 f4       	brne	.+18     	; 0x45f0 <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    45de:	c0 92 be 23 	sts	0x23BE, r12
    45e2:	d0 92 bf 23 	sts	0x23BF, r13
    45e6:	e0 92 c0 23 	sts	0x23C0, r14
    45ea:	f0 92 c1 23 	sts	0x23C1, r15
    45ee:	08 c0       	rjmp	.+16     	; 0x4600 <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    45f0:	c0 92 c2 23 	sts	0x23C2, r12
    45f4:	d0 92 c3 23 	sts	0x23C3, r13
    45f8:	e0 92 c4 23 	sts	0x23C4, r14
    45fc:	f0 92 c5 23 	sts	0x23C5, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    4600:	80 91 7d 50 	lds	r24, 0x507D
    4604:	90 91 7e 50 	lds	r25, 0x507E
    4608:	a0 91 7f 50 	lds	r26, 0x507F
    460c:	b0 91 80 50 	lds	r27, 0x5080
    4610:	bc 01       	movw	r22, r24
    4612:	cd 01       	movw	r24, r26
    4614:	6f 5f       	subi	r22, 0xFF	; 255
    4616:	7f 4f       	sbci	r23, 0xFF	; 255
    4618:	8f 4f       	sbci	r24, 0xFF	; 255
    461a:	9f 4f       	sbci	r25, 0xFF	; 255
    461c:	46 ed       	ldi	r20, 0xD6	; 214
    461e:	51 e2       	ldi	r21, 0x21	; 33
    4620:	20 e0       	ldi	r18, 0x00	; 0
    4622:	32 e0       	ldi	r19, 0x02	; 2
    4624:	0e 94 29 2c 	call	0x5852	; 0x5852 <SD_write_block>
 }
 return 0xffffffff;
    4628:	0f ef       	ldi	r16, 0xFF	; 255
    462a:	1f ef       	ldi	r17, 0xFF	; 255
    462c:	98 01       	movw	r18, r16
    462e:	0b c0       	rjmp	.+22     	; 0x4646 <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    4630:	0f ef       	ldi	r16, 0xFF	; 255
    4632:	1f ef       	ldi	r17, 0xFF	; 255
    4634:	98 01       	movw	r18, r16
    4636:	07 c0       	rjmp	.+14     	; 0x4646 <getSetFreeCluster+0x138>
    4638:	0f ef       	ldi	r16, 0xFF	; 255
    463a:	1f ef       	ldi	r17, 0xFF	; 255
    463c:	98 01       	movw	r18, r16
    463e:	03 c0       	rjmp	.+6      	; 0x4646 <getSetFreeCluster+0x138>
    4640:	0f ef       	ldi	r16, 0xFF	; 255
    4642:	1f ef       	ldi	r17, 0xFF	; 255
    4644:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    4646:	60 2f       	mov	r22, r16
    4648:	71 2f       	mov	r23, r17
    464a:	82 2f       	mov	r24, r18
    464c:	93 2f       	mov	r25, r19
    464e:	cf 91       	pop	r28
    4650:	1f 91       	pop	r17
    4652:	0f 91       	pop	r16
    4654:	ff 90       	pop	r15
    4656:	ef 90       	pop	r14
    4658:	df 90       	pop	r13
    465a:	cf 90       	pop	r12
    465c:	08 95       	ret

0000465e <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    465e:	ef 92       	push	r14
    4660:	ff 92       	push	r15
    4662:	0f 93       	push	r16
    4664:	1f 93       	push	r17
    4666:	cf 93       	push	r28
    4668:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    466a:	10 92 7d 50 	sts	0x507D, r1
    466e:	10 92 7e 50 	sts	0x507E, r1
    4672:	10 92 7f 50 	sts	0x507F, r1
    4676:	10 92 80 50 	sts	0x5080, r1

SD_read_block(0,SDBuffer);
    467a:	60 e0       	ldi	r22, 0x00	; 0
    467c:	70 e0       	ldi	r23, 0x00	; 0
    467e:	cb 01       	movw	r24, r22
    4680:	46 ed       	ldi	r20, 0xD6	; 214
    4682:	51 e2       	ldi	r21, 0x21	; 33
    4684:	0e 94 de 2c 	call	0x59bc	; 0x59bc <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    4688:	80 91 d6 21 	lds	r24, 0x21D6
    468c:	89 3e       	cpi	r24, 0xE9	; 233
    468e:	31 f1       	breq	.+76     	; 0x46dc <getBootSectorData+0x7e>
    4690:	8b 3e       	cpi	r24, 0xEB	; 235
    4692:	21 f1       	breq	.+72     	; 0x46dc <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4694:	80 91 d4 23 	lds	r24, 0x23D4
    4698:	90 91 d5 23 	lds	r25, 0x23D5
    469c:	2a ea       	ldi	r18, 0xAA	; 170
    469e:	85 35       	cpi	r24, 0x55	; 85
    46a0:	92 07       	cpc	r25, r18
    46a2:	09 f0       	breq	.+2      	; 0x46a6 <getBootSectorData+0x48>
    46a4:	b7 c0       	rjmp	.+366    	; 0x4814 <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    46a6:	60 91 9c 23 	lds	r22, 0x239C
    46aa:	70 91 9d 23 	lds	r23, 0x239D
    46ae:	80 91 9e 23 	lds	r24, 0x239E
    46b2:	90 91 9f 23 	lds	r25, 0x239F
    46b6:	60 93 7d 50 	sts	0x507D, r22
    46ba:	70 93 7e 50 	sts	0x507E, r23
    46be:	80 93 7f 50 	sts	0x507F, r24
    46c2:	90 93 80 50 	sts	0x5080, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    46c6:	46 ed       	ldi	r20, 0xD6	; 214
    46c8:	51 e2       	ldi	r21, 0x21	; 33
    46ca:	0e 94 de 2c 	call	0x59bc	; 0x59bc <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    46ce:	80 91 d6 21 	lds	r24, 0x21D6
    46d2:	89 3e       	cpi	r24, 0xE9	; 233
    46d4:	19 f0       	breq	.+6      	; 0x46dc <getBootSectorData+0x7e>
    46d6:	8b 3e       	cpi	r24, 0xEB	; 235
    46d8:	09 f0       	breq	.+2      	; 0x46dc <getBootSectorData+0x7e>
    46da:	9e c0       	rjmp	.+316    	; 0x4818 <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    46dc:	80 91 e1 21 	lds	r24, 0x21E1
    46e0:	90 91 e2 21 	lds	r25, 0x21E2
    46e4:	80 93 54 40 	sts	0x4054, r24
    46e8:	90 93 55 40 	sts	0x4055, r25
sectorPerCluster = bpb->sectorPerCluster;
    46ec:	80 91 e3 21 	lds	r24, 0x21E3
    46f0:	90 e0       	ldi	r25, 0x00	; 0
    46f2:	80 93 7b 50 	sts	0x507B, r24
    46f6:	90 93 7c 50 	sts	0x507C, r25
reservedSectorCount = bpb->reservedSectorCount;
    46fa:	e0 90 e4 21 	lds	r14, 0x21E4
    46fe:	f0 90 e5 21 	lds	r15, 0x21E5
    4702:	e0 92 83 50 	sts	0x5083, r14
    4706:	f0 92 84 50 	sts	0x5084, r15
rootCluster = bpb->rootCluster;
    470a:	80 91 02 22 	lds	r24, 0x2202
    470e:	90 91 03 22 	lds	r25, 0x2203
    4712:	a0 91 04 22 	lds	r26, 0x2204
    4716:	b0 91 05 22 	lds	r27, 0x2205
    471a:	80 93 5f 40 	sts	0x405F, r24
    471e:	90 93 60 40 	sts	0x4060, r25
    4722:	a0 93 61 40 	sts	0x4061, r26
    4726:	b0 93 62 40 	sts	0x4062, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    472a:	c0 91 83 50 	lds	r28, 0x5083
    472e:	d0 91 84 50 	lds	r29, 0x5084
    4732:	60 91 e6 21 	lds	r22, 0x21E6
    4736:	70 e0       	ldi	r23, 0x00	; 0
    4738:	80 e0       	ldi	r24, 0x00	; 0
    473a:	90 e0       	ldi	r25, 0x00	; 0
    473c:	20 91 fa 21 	lds	r18, 0x21FA
    4740:	30 91 fb 21 	lds	r19, 0x21FB
    4744:	40 91 fc 21 	lds	r20, 0x21FC
    4748:	50 91 fd 21 	lds	r21, 0x21FD
    474c:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    4750:	8b 01       	movw	r16, r22
    4752:	9c 01       	movw	r18, r24
    4754:	ae 01       	movw	r20, r28
    4756:	60 e0       	ldi	r22, 0x00	; 0
    4758:	70 e0       	ldi	r23, 0x00	; 0
    475a:	80 91 f2 21 	lds	r24, 0x21F2
    475e:	90 91 f3 21 	lds	r25, 0x21F3
    4762:	a0 91 f4 21 	lds	r26, 0x21F4
    4766:	b0 91 f5 21 	lds	r27, 0x21F5
    476a:	84 0f       	add	r24, r20
    476c:	95 1f       	adc	r25, r21
    476e:	a6 1f       	adc	r26, r22
    4770:	b7 1f       	adc	r27, r23
    4772:	80 0f       	add	r24, r16
    4774:	91 1f       	adc	r25, r17
    4776:	a2 1f       	adc	r26, r18
    4778:	b3 1f       	adc	r27, r19
    477a:	80 93 db 23 	sts	0x23DB, r24
    477e:	90 93 dc 23 	sts	0x23DC, r25
    4782:	a0 93 dd 23 	sts	0x23DD, r26
    4786:	b0 93 de 23 	sts	0x23DE, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    478a:	e0 91 7b 50 	lds	r30, 0x507B
    478e:	f0 91 7c 50 	lds	r31, 0x507C
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    4792:	c7 01       	movw	r24, r14
    4794:	a0 e0       	ldi	r26, 0x00	; 0
    4796:	b0 e0       	ldi	r27, 0x00	; 0
    4798:	40 91 f6 21 	lds	r20, 0x21F6
    479c:	50 91 f7 21 	lds	r21, 0x21F7
    47a0:	60 91 f8 21 	lds	r22, 0x21F8
    47a4:	70 91 f9 21 	lds	r23, 0x21F9
    47a8:	48 1b       	sub	r20, r24
    47aa:	59 0b       	sbc	r21, r25
    47ac:	6a 0b       	sbc	r22, r26
    47ae:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    47b0:	cb 01       	movw	r24, r22
    47b2:	ba 01       	movw	r22, r20
    47b4:	60 1b       	sub	r22, r16
    47b6:	71 0b       	sbc	r23, r17
    47b8:	82 0b       	sbc	r24, r18
    47ba:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    47bc:	9f 01       	movw	r18, r30
    47be:	40 e0       	ldi	r20, 0x00	; 0
    47c0:	50 e0       	ldi	r21, 0x00	; 0
    47c2:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    47c6:	20 93 59 40 	sts	0x4059, r18
    47ca:	30 93 5a 40 	sts	0x405A, r19
    47ce:	40 93 5b 40 	sts	0x405B, r20
    47d2:	50 93 5c 40 	sts	0x405C, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    47d6:	81 e0       	ldi	r24, 0x01	; 1
    47d8:	60 e0       	ldi	r22, 0x00	; 0
    47da:	20 e0       	ldi	r18, 0x00	; 0
    47dc:	30 e0       	ldi	r19, 0x00	; 0
    47de:	a9 01       	movw	r20, r18
    47e0:	0e 94 87 22 	call	0x450e	; 0x450e <getSetFreeCluster>
    47e4:	ab 01       	movw	r20, r22
    47e6:	bc 01       	movw	r22, r24
    47e8:	80 91 59 40 	lds	r24, 0x4059
    47ec:	90 91 5a 40 	lds	r25, 0x405A
    47f0:	a0 91 5b 40 	lds	r26, 0x405B
    47f4:	b0 91 5c 40 	lds	r27, 0x405C
    47f8:	84 17       	cp	r24, r20
    47fa:	95 07       	cpc	r25, r21
    47fc:	a6 07       	cpc	r26, r22
    47fe:	b7 07       	cpc	r27, r23
    4800:	20 f4       	brcc	.+8      	; 0x480a <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    4802:	10 92 c7 50 	sts	0x50C7, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    4806:	80 e0       	ldi	r24, 0x00	; 0
    4808:	08 c0       	rjmp	.+16     	; 0x481a <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    480a:	81 e0       	ldi	r24, 0x01	; 1
    480c:	80 93 c7 50 	sts	0x50C7, r24
return 0;
    4810:	80 e0       	ldi	r24, 0x00	; 0
    4812:	03 c0       	rjmp	.+6      	; 0x481a <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4814:	81 e0       	ldi	r24, 0x01	; 1
    4816:	01 c0       	rjmp	.+2      	; 0x481a <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4818:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    481a:	df 91       	pop	r29
    481c:	cf 91       	pop	r28
    481e:	1f 91       	pop	r17
    4820:	0f 91       	pop	r16
    4822:	ff 90       	pop	r15
    4824:	ef 90       	pop	r14
    4826:	08 95       	ret

00004828 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    4828:	0f 93       	push	r16
    482a:	1f 93       	push	r17
    482c:	cf 93       	push	r28
    482e:	df 93       	push	r29
    4830:	cd b7       	in	r28, 0x3d	; 61
    4832:	de b7       	in	r29, 0x3e	; 62
    4834:	2b 97       	sbiw	r28, 0x0b	; 11
    4836:	cd bf       	out	0x3d, r28	; 61
    4838:	de bf       	out	0x3e, r29	; 62
    483a:	78 2f       	mov	r23, r24
    483c:	69 2f       	mov	r22, r25
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    483e:	e8 2f       	mov	r30, r24
    4840:	f9 2f       	mov	r31, r25
    4842:	df 01       	movw	r26, r30
    4844:	0d 90       	ld	r0, X+
    4846:	00 20       	and	r0, r0
    4848:	e9 f7       	brne	.-6      	; 0x4844 <convertFileName+0x1c>
    484a:	11 97       	sbiw	r26, 0x01	; 1
    484c:	ae 1b       	sub	r26, r30
    484e:	bf 0b       	sbc	r27, r31
    4850:	a0 31       	cpi	r26, 0x10	; 16
    4852:	b1 05       	cpc	r27, r1
    4854:	08 f0       	brcs	.+2      	; 0x4858 <convertFileName+0x30>
    4856:	9c c0       	rjmp	.+312    	; 0x4990 <convertFileName+0x168>
    4858:	28 2f       	mov	r18, r24
    485a:	39 2f       	mov	r19, r25
    485c:	03 eb       	ldi	r16, 0xB3	; 179
    485e:	10 e5       	ldi	r17, 0x50	; 80
    4860:	a8 01       	movw	r20, r16
    4862:	80 e0       	ldi	r24, 0x00	; 0
    4864:	90 e0       	ldi	r25, 0x00	; 0
    4866:	07 c0       	rjmp	.+14     	; 0x4876 <convertFileName+0x4e>
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
    4868:	d9 01       	movw	r26, r18
    486a:	ed 91       	ld	r30, X+
    486c:	9d 01       	movw	r18, r26
    486e:	da 01       	movw	r26, r20
    4870:	ed 93       	st	X+, r30
    4872:	ad 01       	movw	r20, r26

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    4874:	01 96       	adiw	r24, 0x01	; 1
    4876:	a7 2f       	mov	r26, r23
    4878:	b6 2f       	mov	r27, r22
    487a:	fd 01       	movw	r30, r26
    487c:	01 90       	ld	r0, Z+
    487e:	00 20       	and	r0, r0
    4880:	e9 f7       	brne	.-6      	; 0x487c <convertFileName+0x54>
    4882:	31 97       	sbiw	r30, 0x01	; 1
    4884:	ea 1b       	sub	r30, r26
    4886:	fb 0b       	sbc	r31, r27
    4888:	8e 17       	cp	r24, r30
    488a:	9f 07       	cpc	r25, r31
    488c:	68 f3       	brcs	.-38     	; 0x4868 <convertFileName+0x40>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    488e:	8f 30       	cpi	r24, 0x0F	; 15
    4890:	91 05       	cpc	r25, r1
    4892:	54 f4       	brge	.+20     	; 0x48a8 <convertFileName+0x80>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4894:	fc 01       	movw	r30, r24
    4896:	ed 54       	subi	r30, 0x4D	; 77
    4898:	ff 4a       	sbci	r31, 0xAF	; 175
    489a:	82 ec       	ldi	r24, 0xC2	; 194
    489c:	90 e5       	ldi	r25, 0x50	; 80
if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    489e:	20 e2       	ldi	r18, 0x20	; 32
    48a0:	21 93       	st	Z+, r18
    48a2:	e8 17       	cp	r30, r24
    48a4:	f9 07       	cpc	r31, r25
    48a6:	e1 f7       	brne	.-8      	; 0x48a0 <convertFileName+0x78>


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    48a8:	80 91 b3 50 	lds	r24, 0x50B3
    48ac:	8e 32       	cpi	r24, 0x2E	; 46
    48ae:	91 f0       	breq	.+36     	; 0x48d4 <convertFileName+0xac>
    48b0:	e4 eb       	ldi	r30, 0xB4	; 180
    48b2:	f0 e5       	ldi	r31, 0x50	; 80
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    48b4:	21 e0       	ldi	r18, 0x01	; 1
if(Filename[j] == '.') break;
    48b6:	81 91       	ld	r24, Z+
    48b8:	8e 32       	cpi	r24, 0x2E	; 46
    48ba:	21 f0       	breq	.+8      	; 0x48c4 <convertFileName+0x9c>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    48bc:	2f 5f       	subi	r18, 0xFF	; 255
    48be:	2c 30       	cpi	r18, 0x0C	; 12
    48c0:	d1 f7       	brne	.-12     	; 0x48b6 <convertFileName+0x8e>
    48c2:	05 c0       	rjmp	.+10     	; 0x48ce <convertFileName+0xa6>
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    48c4:	82 2f       	mov	r24, r18
    48c6:	89 50       	subi	r24, 0x09	; 9
    48c8:	83 30       	cpi	r24, 0x03	; 3
    48ca:	08 f4       	brcc	.+2      	; 0x48ce <convertFileName+0xa6>
    48cc:	63 c0       	rjmp	.+198    	; 0x4994 <convertFileName+0x16c>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    48ce:	22 23       	and	r18, r18
    48d0:	29 f4       	brne	.+10     	; 0x48dc <convertFileName+0xb4>
    48d2:	01 c0       	rjmp	.+2      	; 0x48d6 <convertFileName+0xae>
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    48d4:	20 e0       	ldi	r18, 0x00	; 0
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    48d6:	82 2f       	mov	r24, r18

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    48d8:	90 e2       	ldi	r25, 0x20	; 32
    48da:	10 c0       	rjmp	.+32     	; 0x48fc <convertFileName+0xd4>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    48dc:	de 01       	movw	r26, r28
    48de:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    48e0:	82 2f       	mov	r24, r18
    48e2:	81 50       	subi	r24, 0x01	; 1
    48e4:	90 e0       	ldi	r25, 0x00	; 0
    48e6:	8c 54       	subi	r24, 0x4C	; 76
    48e8:	9f 4a       	sbci	r25, 0xAF	; 175
    48ea:	f8 01       	movw	r30, r16
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];
    48ec:	31 91       	ld	r19, Z+
    48ee:	3d 93       	st	X+, r19

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    48f0:	e8 17       	cp	r30, r24
    48f2:	f9 07       	cpc	r31, r25
    48f4:	d9 f7       	brne	.-10     	; 0x48ec <convertFileName+0xc4>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    48f6:	28 30       	cpi	r18, 0x08	; 8
    48f8:	70 f3       	brcs	.-36     	; 0x48d6 <convertFileName+0xae>
    48fa:	0a c0       	rjmp	.+20     	; 0x4910 <convertFileName+0xe8>
  fileNameFAT[k] = ' ';
    48fc:	e1 e0       	ldi	r30, 0x01	; 1
    48fe:	f0 e0       	ldi	r31, 0x00	; 0
    4900:	ec 0f       	add	r30, r28
    4902:	fd 1f       	adc	r31, r29
    4904:	e8 0f       	add	r30, r24
    4906:	f1 1d       	adc	r31, r1
    4908:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    490a:	8f 5f       	subi	r24, 0xFF	; 255
    490c:	88 30       	cpi	r24, 0x08	; 8
    490e:	b0 f3       	brcs	.-20     	; 0x48fc <convertFileName+0xd4>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    4910:	2c 30       	cpi	r18, 0x0C	; 12
    4912:	09 f0       	breq	.+2      	; 0x4916 <convertFileName+0xee>
    4914:	2f 5f       	subi	r18, 0xFF	; 255
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4916:	38 e0       	ldi	r19, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    4918:	83 eb       	ldi	r24, 0xB3	; 179
    491a:	90 e5       	ldi	r25, 0x50	; 80
    491c:	fc 01       	movw	r30, r24
    491e:	e2 0f       	add	r30, r18
    4920:	f1 1d       	adc	r31, r1
    4922:	40 81       	ld	r20, Z
    4924:	44 23       	and	r20, r20
    4926:	19 f4       	brne	.+6      	; 0x492e <convertFileName+0x106>
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    4928:	3b 30       	cpi	r19, 0x0B	; 11
    492a:	50 f0       	brcs	.+20     	; 0x4940 <convertFileName+0x118>
    492c:	15 c0       	rjmp	.+42     	; 0x4958 <convertFileName+0x130>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
    492e:	e1 e0       	ldi	r30, 0x01	; 1
    4930:	f0 e0       	ldi	r31, 0x00	; 0
    4932:	ec 0f       	add	r30, r28
    4934:	fd 1f       	adc	r31, r29
    4936:	e3 0f       	add	r30, r19
    4938:	f1 1d       	adc	r31, r1
    493a:	40 83       	st	Z, r20
    493c:	2f 5f       	subi	r18, 0xFF	; 255
    493e:	0c c0       	rjmp	.+24     	; 0x4958 <convertFileName+0x130>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    4940:	80 e2       	ldi	r24, 0x20	; 32
    4942:	e1 e0       	ldi	r30, 0x01	; 1
    4944:	f0 e0       	ldi	r31, 0x00	; 0
    4946:	ec 0f       	add	r30, r28
    4948:	fd 1f       	adc	r31, r29
    494a:	e3 0f       	add	r30, r19
    494c:	f1 1d       	adc	r31, r1
    494e:	80 83       	st	Z, r24
    4950:	3f 5f       	subi	r19, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    4952:	3b 30       	cpi	r19, 0x0B	; 11
    4954:	b1 f7       	brne	.-20     	; 0x4942 <convertFileName+0x11a>
    4956:	03 c0       	rjmp	.+6      	; 0x495e <convertFileName+0x136>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    4958:	3f 5f       	subi	r19, 0xFF	; 255
    495a:	3b 30       	cpi	r19, 0x0B	; 11
    495c:	f8 f2       	brcs	.-66     	; 0x491c <convertFileName+0xf4>
    495e:	de 01       	movw	r26, r28
    4960:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4962:	ce 01       	movw	r24, r28
    4964:	0c 96       	adiw	r24, 0x0c	; 12
    4966:	fd 01       	movw	r30, r26
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    4968:	20 81       	ld	r18, Z
    496a:	32 2f       	mov	r19, r18
    496c:	31 56       	subi	r19, 0x61	; 97
    496e:	3a 31       	cpi	r19, 0x1A	; 26
    4970:	10 f4       	brcc	.+4      	; 0x4976 <convertFileName+0x14e>
    fileNameFAT[j] -= 0x20;
    4972:	20 52       	subi	r18, 0x20	; 32
    4974:	20 83       	st	Z, r18
    4976:	31 96       	adiw	r30, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    4978:	e8 17       	cp	r30, r24
    497a:	f9 07       	cpc	r31, r25
    497c:	a9 f7       	brne	.-22     	; 0x4968 <convertFileName+0x140>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];
    497e:	2d 91       	ld	r18, X+
    4980:	f8 01       	movw	r30, r16
    4982:	21 93       	st	Z+, r18
    4984:	8f 01       	movw	r16, r30

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    4986:	a8 17       	cp	r26, r24
    4988:	b9 07       	cpc	r27, r25
    498a:	c9 f7       	brne	.-14     	; 0x497e <convertFileName+0x156>
  Filename[j] = fileNameFAT[j];

return 0;
    498c:	80 e0       	ldi	r24, 0x00	; 0
    498e:	03 c0       	rjmp	.+6      	; 0x4996 <convertFileName+0x16e>
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    4990:	81 e0       	ldi	r24, 0x01	; 1
    4992:	01 c0       	rjmp	.+2      	; 0x4996 <convertFileName+0x16e>

for(j=0; j<12; j++)
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    4994:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];

return 0;
}
    4996:	2b 96       	adiw	r28, 0x0b	; 11
    4998:	cd bf       	out	0x3d, r28	; 61
    499a:	de bf       	out	0x3e, r29	; 62
    499c:	df 91       	pop	r29
    499e:	cf 91       	pop	r28
    49a0:	1f 91       	pop	r17
    49a2:	0f 91       	pop	r16
    49a4:	08 95       	ret

000049a6 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    49a6:	4f 92       	push	r4
    49a8:	5f 92       	push	r5
    49aa:	6f 92       	push	r6
    49ac:	7f 92       	push	r7
    49ae:	8f 92       	push	r8
    49b0:	9f 92       	push	r9
    49b2:	af 92       	push	r10
    49b4:	bf 92       	push	r11
    49b6:	cf 92       	push	r12
    49b8:	df 92       	push	r13
    49ba:	ef 92       	push	r14
    49bc:	ff 92       	push	r15
    49be:	cf 93       	push	r28
    49c0:	df 93       	push	r29
    49c2:	2b 01       	movw	r4, r22
    49c4:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    49c6:	20 e8       	ldi	r18, 0x80	; 128
    49c8:	3f ef       	ldi	r19, 0xFF	; 255
    49ca:	4f ef       	ldi	r20, 0xFF	; 255
    49cc:	5f ef       	ldi	r21, 0xFF	; 255
    49ce:	42 22       	and	r4, r18
    49d0:	53 22       	and	r5, r19
    49d2:	64 22       	and	r6, r20
    49d4:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    49d6:	80 91 59 40 	lds	r24, 0x4059
    49da:	90 91 5a 40 	lds	r25, 0x405A
    49de:	a0 91 5b 40 	lds	r26, 0x405B
    49e2:	b0 91 5c 40 	lds	r27, 0x405C
    49e6:	48 16       	cp	r4, r24
    49e8:	59 06       	cpc	r5, r25
    49ea:	6a 06       	cpc	r6, r26
    49ec:	7b 06       	cpc	r7, r27
    49ee:	08 f0       	brcs	.+2      	; 0x49f2 <searchNextFreeCluster+0x4c>
    49f0:	77 c0       	rjmp	.+238    	; 0x4ae0 <searchNextFreeCluster+0x13a>
    49f2:	53 01       	movw	r10, r6
    49f4:	42 01       	movw	r8, r4
    49f6:	88 0c       	add	r8, r8
    49f8:	99 1c       	adc	r9, r9
    49fa:	aa 1c       	adc	r10, r10
    49fc:	bb 1c       	adc	r11, r11
    49fe:	88 0c       	add	r8, r8
    4a00:	99 1c       	adc	r9, r9
    4a02:	aa 1c       	adc	r10, r10
    4a04:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    4a06:	c6 ed       	ldi	r28, 0xD6	; 214
    4a08:	d1 e2       	ldi	r29, 0x21	; 33
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    4a0a:	c0 90 83 50 	lds	r12, 0x5083
    4a0e:	d0 90 84 50 	lds	r13, 0x5084
    4a12:	20 91 54 40 	lds	r18, 0x4054
    4a16:	30 91 55 40 	lds	r19, 0x4055
    4a1a:	ee 24       	eor	r14, r14
    4a1c:	ff 24       	eor	r15, r15
    4a1e:	80 91 7d 50 	lds	r24, 0x507D
    4a22:	90 91 7e 50 	lds	r25, 0x507E
    4a26:	a0 91 7f 50 	lds	r26, 0x507F
    4a2a:	b0 91 80 50 	lds	r27, 0x5080
    4a2e:	c8 0e       	add	r12, r24
    4a30:	d9 1e       	adc	r13, r25
    4a32:	ea 1e       	adc	r14, r26
    4a34:	fb 1e       	adc	r15, r27
    4a36:	40 e0       	ldi	r20, 0x00	; 0
    4a38:	50 e0       	ldi	r21, 0x00	; 0
    4a3a:	c5 01       	movw	r24, r10
    4a3c:	b4 01       	movw	r22, r8
    4a3e:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    4a42:	c7 01       	movw	r24, r14
    4a44:	b6 01       	movw	r22, r12
    4a46:	62 0f       	add	r22, r18
    4a48:	73 1f       	adc	r23, r19
    4a4a:	84 1f       	adc	r24, r20
    4a4c:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    4a4e:	ae 01       	movw	r20, r28
    4a50:	0e 94 de 2c 	call	0x59bc	; 0x59bc <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    4a54:	88 81       	ld	r24, Y
    4a56:	99 81       	ldd	r25, Y+1	; 0x01
    4a58:	aa 81       	ldd	r26, Y+2	; 0x02
    4a5a:	bb 81       	ldd	r27, Y+3	; 0x03
    4a5c:	bf 70       	andi	r27, 0x0F	; 15
    4a5e:	00 97       	sbiw	r24, 0x00	; 0
    4a60:	a1 05       	cpc	r26, r1
    4a62:	b1 05       	cpc	r27, r1
    4a64:	99 f0       	breq	.+38     	; 0x4a8c <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4a66:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    4a68:	e2 2f       	mov	r30, r18
    4a6a:	f0 e0       	ldi	r31, 0x00	; 0
    4a6c:	ee 0f       	add	r30, r30
    4a6e:	ff 1f       	adc	r31, r31
    4a70:	ee 0f       	add	r30, r30
    4a72:	ff 1f       	adc	r31, r31
         if(((*value) & 0x0fffffff) == 0)
    4a74:	ea 52       	subi	r30, 0x2A	; 42
    4a76:	fe 4d       	sbci	r31, 0xDE	; 222
    4a78:	80 81       	ld	r24, Z
    4a7a:	91 81       	ldd	r25, Z+1	; 0x01
    4a7c:	a2 81       	ldd	r26, Z+2	; 0x02
    4a7e:	b3 81       	ldd	r27, Z+3	; 0x03
    4a80:	bf 70       	andi	r27, 0x0F	; 15
    4a82:	00 97       	sbiw	r24, 0x00	; 0
    4a84:	a1 05       	cpc	r26, r1
    4a86:	b1 05       	cpc	r27, r1
    4a88:	39 f4       	brne	.+14     	; 0x4a98 <searchNextFreeCluster+0xf2>
    4a8a:	01 c0       	rjmp	.+2      	; 0x4a8e <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4a8c:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    4a8e:	42 0e       	add	r4, r18
    4a90:	51 1c       	adc	r5, r1
    4a92:	61 1c       	adc	r6, r1
    4a94:	71 1c       	adc	r7, r1
    4a96:	27 c0       	rjmp	.+78     	; 0x4ae6 <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4a98:	2f 5f       	subi	r18, 0xFF	; 255
    4a9a:	32 f7       	brpl	.-52     	; 0x4a68 <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    4a9c:	80 e8       	ldi	r24, 0x80	; 128
    4a9e:	90 e0       	ldi	r25, 0x00	; 0
    4aa0:	a0 e0       	ldi	r26, 0x00	; 0
    4aa2:	b0 e0       	ldi	r27, 0x00	; 0
    4aa4:	48 0e       	add	r4, r24
    4aa6:	59 1e       	adc	r5, r25
    4aa8:	6a 1e       	adc	r6, r26
    4aaa:	7b 1e       	adc	r7, r27
    4aac:	80 91 59 40 	lds	r24, 0x4059
    4ab0:	90 91 5a 40 	lds	r25, 0x405A
    4ab4:	a0 91 5b 40 	lds	r26, 0x405B
    4ab8:	b0 91 5c 40 	lds	r27, 0x405C
    4abc:	20 e0       	ldi	r18, 0x00	; 0
    4abe:	32 e0       	ldi	r19, 0x02	; 2
    4ac0:	40 e0       	ldi	r20, 0x00	; 0
    4ac2:	50 e0       	ldi	r21, 0x00	; 0
    4ac4:	82 0e       	add	r8, r18
    4ac6:	93 1e       	adc	r9, r19
    4ac8:	a4 1e       	adc	r10, r20
    4aca:	b5 1e       	adc	r11, r21
    4acc:	48 16       	cp	r4, r24
    4ace:	59 06       	cpc	r5, r25
    4ad0:	6a 06       	cpc	r6, r26
    4ad2:	7b 06       	cpc	r7, r27
    4ad4:	08 f4       	brcc	.+2      	; 0x4ad8 <searchNextFreeCluster+0x132>
    4ad6:	99 cf       	rjmp	.-206    	; 0x4a0a <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    4ad8:	44 24       	eor	r4, r4
    4ada:	55 24       	eor	r5, r5
    4adc:	32 01       	movw	r6, r4
    4ade:	03 c0       	rjmp	.+6      	; 0x4ae6 <searchNextFreeCluster+0x140>
    4ae0:	44 24       	eor	r4, r4
    4ae2:	55 24       	eor	r5, r5
    4ae4:	32 01       	movw	r6, r4
}
    4ae6:	64 2d       	mov	r22, r4
    4ae8:	75 2d       	mov	r23, r5
    4aea:	86 2d       	mov	r24, r6
    4aec:	97 2d       	mov	r25, r7
    4aee:	df 91       	pop	r29
    4af0:	cf 91       	pop	r28
    4af2:	ff 90       	pop	r15
    4af4:	ef 90       	pop	r14
    4af6:	df 90       	pop	r13
    4af8:	cf 90       	pop	r12
    4afa:	bf 90       	pop	r11
    4afc:	af 90       	pop	r10
    4afe:	9f 90       	pop	r9
    4b00:	8f 90       	pop	r8
    4b02:	7f 90       	pop	r7
    4b04:	6f 90       	pop	r6
    4b06:	5f 90       	pop	r5
    4b08:	4f 90       	pop	r4
    4b0a:	08 95       	ret

00004b0c <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    4b0c:	cf 92       	push	r12
    4b0e:	df 92       	push	r13
    4b10:	ef 92       	push	r14
    4b12:	ff 92       	push	r15
    4b14:	cf 93       	push	r28
    4b16:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    4b18:	db 01       	movw	r26, r22
    4b1a:	ca 01       	movw	r24, r20
    4b1c:	91 70       	andi	r25, 0x01	; 1
    4b1e:	a0 70       	andi	r26, 0x00	; 0
    4b20:	b0 70       	andi	r27, 0x00	; 0
    4b22:	00 97       	sbiw	r24, 0x00	; 0
    4b24:	a1 05       	cpc	r26, r1
    4b26:	b1 05       	cpc	r27, r1
    4b28:	51 f4       	brne	.+20     	; 0x4b3e <freeMemoryUpdate+0x32>
    4b2a:	03 2e       	mov	r0, r19
    4b2c:	39 e0       	ldi	r19, 0x09	; 9
    4b2e:	76 95       	lsr	r23
    4b30:	67 95       	ror	r22
    4b32:	57 95       	ror	r21
    4b34:	47 95       	ror	r20
    4b36:	3a 95       	dec	r19
    4b38:	d1 f7       	brne	.-12     	; 0x4b2e <freeMemoryUpdate+0x22>
    4b3a:	30 2d       	mov	r19, r0
    4b3c:	0d c0       	rjmp	.+26     	; 0x4b58 <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    4b3e:	03 2e       	mov	r0, r19
    4b40:	39 e0       	ldi	r19, 0x09	; 9
    4b42:	76 95       	lsr	r23
    4b44:	67 95       	ror	r22
    4b46:	57 95       	ror	r21
    4b48:	47 95       	ror	r20
    4b4a:	3a 95       	dec	r19
    4b4c:	d1 f7       	brne	.-12     	; 0x4b42 <freeMemoryUpdate+0x36>
    4b4e:	30 2d       	mov	r19, r0
    4b50:	4f 5f       	subi	r20, 0xFF	; 255
    4b52:	5f 4f       	sbci	r21, 0xFF	; 255
    4b54:	6f 4f       	sbci	r22, 0xFF	; 255
    4b56:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    4b58:	db 01       	movw	r26, r22
    4b5a:	ca 01       	movw	r24, r20
    4b5c:	87 70       	andi	r24, 0x07	; 7
    4b5e:	90 70       	andi	r25, 0x00	; 0
    4b60:	a0 70       	andi	r26, 0x00	; 0
    4b62:	b0 70       	andi	r27, 0x00	; 0
    4b64:	00 97       	sbiw	r24, 0x00	; 0
    4b66:	a1 05       	cpc	r26, r1
    4b68:	b1 05       	cpc	r27, r1
    4b6a:	59 f4       	brne	.+22     	; 0x4b82 <freeMemoryUpdate+0x76>
    4b6c:	6a 01       	movw	r12, r20
    4b6e:	7b 01       	movw	r14, r22
    4b70:	68 94       	set
    4b72:	12 f8       	bld	r1, 2
    4b74:	f6 94       	lsr	r15
    4b76:	e7 94       	ror	r14
    4b78:	d7 94       	ror	r13
    4b7a:	c7 94       	ror	r12
    4b7c:	16 94       	lsr	r1
    4b7e:	d1 f7       	brne	.-12     	; 0x4b74 <freeMemoryUpdate+0x68>
    4b80:	0f c0       	rjmp	.+30     	; 0x4ba0 <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    4b82:	6a 01       	movw	r12, r20
    4b84:	7b 01       	movw	r14, r22
    4b86:	68 94       	set
    4b88:	12 f8       	bld	r1, 2
    4b8a:	f6 94       	lsr	r15
    4b8c:	e7 94       	ror	r14
    4b8e:	d7 94       	ror	r13
    4b90:	c7 94       	ror	r12
    4b92:	16 94       	lsr	r1
    4b94:	d1 f7       	brne	.-12     	; 0x4b8a <freeMemoryUpdate+0x7e>
    4b96:	08 94       	sec
    4b98:	c1 1c       	adc	r12, r1
    4b9a:	d1 1c       	adc	r13, r1
    4b9c:	e1 1c       	adc	r14, r1
    4b9e:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    4ba0:	80 91 c7 50 	lds	r24, 0x50C7
    4ba4:	88 23       	and	r24, r24
    4ba6:	d1 f0       	breq	.+52     	; 0x4bdc <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    4ba8:	81 e0       	ldi	r24, 0x01	; 1
    4baa:	60 e0       	ldi	r22, 0x00	; 0
    4bac:	20 e0       	ldi	r18, 0x00	; 0
    4bae:	30 e0       	ldi	r19, 0x00	; 0
    4bb0:	a9 01       	movw	r20, r18
    4bb2:	0e 94 87 22 	call	0x450e	; 0x450e <getSetFreeCluster>
	if(flag == ADD)
    4bb6:	cc 23       	and	r28, r28
    4bb8:	39 f4       	brne	.+14     	; 0x4bc8 <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    4bba:	9b 01       	movw	r18, r22
    4bbc:	ac 01       	movw	r20, r24
    4bbe:	2c 0d       	add	r18, r12
    4bc0:	3d 1d       	adc	r19, r13
    4bc2:	4e 1d       	adc	r20, r14
    4bc4:	5f 1d       	adc	r21, r15
    4bc6:	06 c0       	rjmp	.+12     	; 0x4bd4 <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    4bc8:	9b 01       	movw	r18, r22
    4bca:	ac 01       	movw	r20, r24
    4bcc:	2c 19       	sub	r18, r12
    4bce:	3d 09       	sbc	r19, r13
    4bd0:	4e 09       	sbc	r20, r14
    4bd2:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    4bd4:	81 e0       	ldi	r24, 0x01	; 1
    4bd6:	61 e0       	ldi	r22, 0x01	; 1
    4bd8:	0e 94 87 22 	call	0x450e	; 0x450e <getSetFreeCluster>
  }
}
    4bdc:	cf 91       	pop	r28
    4bde:	ff 90       	pop	r15
    4be0:	ef 90       	pop	r14
    4be2:	df 90       	pop	r13
    4be4:	cf 90       	pop	r12
    4be6:	08 95       	ret

00004be8 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    4be8:	2f 92       	push	r2
    4bea:	3f 92       	push	r3
    4bec:	4f 92       	push	r4
    4bee:	5f 92       	push	r5
    4bf0:	6f 92       	push	r6
    4bf2:	7f 92       	push	r7
    4bf4:	8f 92       	push	r8
    4bf6:	9f 92       	push	r9
    4bf8:	af 92       	push	r10
    4bfa:	bf 92       	push	r11
    4bfc:	cf 92       	push	r12
    4bfe:	df 92       	push	r13
    4c00:	ef 92       	push	r14
    4c02:	ff 92       	push	r15
    4c04:	0f 93       	push	r16
    4c06:	1f 93       	push	r17
    4c08:	cf 93       	push	r28
    4c0a:	df 93       	push	r29
    4c0c:	cd b7       	in	r28, 0x3d	; 61
    4c0e:	de b7       	in	r29, 0x3e	; 62
    4c10:	2c 97       	sbiw	r28, 0x0c	; 12
    4c12:	cd bf       	out	0x3d, r28	; 61
    4c14:	de bf       	out	0x3e, r29	; 62
    4c16:	88 2e       	mov	r8, r24
    4c18:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    4c1a:	80 91 5f 40 	lds	r24, 0x405F
    4c1e:	90 91 60 40 	lds	r25, 0x4060
    4c22:	a0 91 61 40 	lds	r26, 0x4061
    4c26:	b0 91 62 40 	lds	r27, 0x4062
    4c2a:	89 87       	std	Y+9, r24	; 0x09
    4c2c:	9a 87       	std	Y+10, r25	; 0x0a
    4c2e:	ab 87       	std	Y+11, r26	; 0x0b
    4c30:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4c32:	0f 2e       	mov	r0, r31
    4c34:	f6 ed       	ldi	r31, 0xD6	; 214
    4c36:	2f 2e       	mov	r2, r31
    4c38:	f1 e2       	ldi	r31, 0x21	; 33
    4c3a:	3f 2e       	mov	r3, r31
    4c3c:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4c3e:	c8 2c       	mov	r12, r8
    4c40:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4c42:	d2 2c       	mov	r13, r2
    4c44:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4c46:	5b 01       	movw	r10, r22
    4c48:	08 94       	sec
    4c4a:	a1 1c       	adc	r10, r1
    4c4c:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    4c4e:	69 85       	ldd	r22, Y+9	; 0x09
    4c50:	7a 85       	ldd	r23, Y+10	; 0x0a
    4c52:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c54:	9c 85       	ldd	r25, Y+12	; 0x0c
    4c56:	0e 94 ce 21 	call	0x439c	; 0x439c <getFirstSector>
    4c5a:	6d 83       	std	Y+5, r22	; 0x05
    4c5c:	7e 83       	std	Y+6, r23	; 0x06
    4c5e:	8f 83       	std	Y+7, r24	; 0x07
    4c60:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    4c62:	80 91 7b 50 	lds	r24, 0x507B
    4c66:	90 91 7c 50 	lds	r25, 0x507C
    4c6a:	00 97       	sbiw	r24, 0x00	; 0
    4c6c:	09 f4       	brne	.+2      	; 0x4c70 <findFiles+0x88>
    4c6e:	13 c1       	rjmp	.+550    	; 0x4e96 <findFiles+0x2ae>
    4c70:	44 24       	eor	r4, r4
    4c72:	55 24       	eor	r5, r5
    4c74:	32 01       	movw	r6, r4
    4c76:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4c78:	8d 81       	ldd	r24, Y+5	; 0x05
    4c7a:	9e 81       	ldd	r25, Y+6	; 0x06
    4c7c:	af 81       	ldd	r26, Y+7	; 0x07
    4c7e:	b8 85       	ldd	r27, Y+8	; 0x08
    4c80:	84 0d       	add	r24, r4
    4c82:	95 1d       	adc	r25, r5
    4c84:	a6 1d       	adc	r26, r6
    4c86:	b7 1d       	adc	r27, r7
    4c88:	89 83       	std	Y+1, r24	; 0x01
    4c8a:	9a 83       	std	Y+2, r25	; 0x02
    4c8c:	ab 83       	std	Y+3, r26	; 0x03
    4c8e:	bc 83       	std	Y+4, r27	; 0x04
    4c90:	bc 01       	movw	r22, r24
    4c92:	cd 01       	movw	r24, r26
    4c94:	4d 2d       	mov	r20, r13
    4c96:	59 2d       	mov	r21, r9
    4c98:	0e 94 de 2c 	call	0x59bc	; 0x59bc <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    4c9c:	80 91 54 40 	lds	r24, 0x4054
    4ca0:	90 91 55 40 	lds	r25, 0x4055
    4ca4:	00 97       	sbiw	r24, 0x00	; 0
    4ca6:	09 f4       	brne	.+2      	; 0x4caa <findFiles+0xc2>
    4ca8:	e4 c0       	rjmp	.+456    	; 0x4e72 <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4caa:	d1 01       	movw	r26, r2
    4cac:	8c 91       	ld	r24, X
    4cae:	88 23       	and	r24, r24
    4cb0:	09 f4       	brne	.+2      	; 0x4cb4 <findFiles+0xcc>
    4cb2:	10 c1       	rjmp	.+544    	; 0x4ed4 <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4cb4:	4d 2d       	mov	r20, r13
    4cb6:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4cb8:	20 e0       	ldi	r18, 0x00	; 0
    4cba:	30 e0       	ldi	r19, 0x00	; 0
    4cbc:	08 c0       	rjmp	.+16     	; 0x4cce <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4cbe:	a9 01       	movw	r20, r18
    4cc0:	4a 52       	subi	r20, 0x2A	; 42
    4cc2:	5e 4d       	sbci	r21, 0xDE	; 222

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4cc4:	fa 01       	movw	r30, r20
    4cc6:	80 81       	ld	r24, Z
    4cc8:	88 23       	and	r24, r24
    4cca:	09 f4       	brne	.+2      	; 0x4cce <findFiles+0xe6>
    4ccc:	06 c1       	rjmp	.+524    	; 0x4eda <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    4cce:	85 3e       	cpi	r24, 0xE5	; 229
    4cd0:	09 f4       	brne	.+2      	; 0x4cd4 <findFiles+0xec>
    4cd2:	c5 c0       	rjmp	.+394    	; 0x4e5e <findFiles+0x276>
    4cd4:	da 01       	movw	r26, r20
    4cd6:	1b 96       	adiw	r26, 0x0b	; 11
    4cd8:	8c 91       	ld	r24, X
    4cda:	1b 97       	sbiw	r26, 0x0b	; 11
    4cdc:	8f 30       	cpi	r24, 0x0F	; 15
    4cde:	09 f4       	brne	.+2      	; 0x4ce2 <findFiles+0xfa>
    4ce0:	be c0       	rjmp	.+380    	; 0x4e5e <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4ce2:	12 30       	cpi	r17, 0x02	; 2
    4ce4:	08 f0       	brcs	.+2      	; 0x4ce8 <findFiles+0x100>
    4ce6:	fc c0       	rjmp	.+504    	; 0x4ee0 <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    4ce8:	9c 91       	ld	r25, X
    4cea:	f7 01       	movw	r30, r14
    4cec:	80 81       	ld	r24, Z
    4cee:	98 17       	cp	r25, r24
    4cf0:	09 f0       	breq	.+2      	; 0x4cf4 <findFiles+0x10c>
    4cf2:	b5 c0       	rjmp	.+362    	; 0x4e5e <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4cf4:	fa 01       	movw	r30, r20
    4cf6:	31 96       	adiw	r30, 0x01	; 1
    4cf8:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4cfa:	81 e0       	ldi	r24, 0x01	; 1
    4cfc:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    4cfe:	41 91       	ld	r20, Z+
    4d00:	9d 91       	ld	r25, X+
    4d02:	49 17       	cp	r20, r25
    4d04:	31 f4       	brne	.+12     	; 0x4d12 <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4d06:	8f 5f       	subi	r24, 0xFF	; 255
    4d08:	8b 30       	cpi	r24, 0x0B	; 11
    4d0a:	c9 f7       	brne	.-14     	; 0x4cfe <findFiles+0x116>
    4d0c:	8b 01       	movw	r16, r22
    4d0e:	6b 01       	movw	r12, r22
    4d10:	05 c0       	rjmp	.+10     	; 0x4d1c <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    4d12:	8b 30       	cpi	r24, 0x0B	; 11
    4d14:	09 f0       	breq	.+2      	; 0x4d18 <findFiles+0x130>
    4d16:	a3 c0       	rjmp	.+326    	; 0x4e5e <findFiles+0x276>
    4d18:	8b 01       	movw	r16, r22
    4d1a:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    4d1c:	f1 e0       	ldi	r31, 0x01	; 1
    4d1e:	8f 16       	cp	r8, r31
    4d20:	09 f0       	breq	.+2      	; 0x4d24 <findFiles+0x13c>
    4d22:	41 c0       	rjmp	.+130    	; 0x4da6 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    4d24:	89 81       	ldd	r24, Y+1	; 0x01
    4d26:	9a 81       	ldd	r25, Y+2	; 0x02
    4d28:	ab 81       	ldd	r26, Y+3	; 0x03
    4d2a:	bc 81       	ldd	r27, Y+4	; 0x04
    4d2c:	80 93 c9 50 	sts	0x50C9, r24
    4d30:	90 93 ca 50 	sts	0x50CA, r25
    4d34:	a0 93 cb 50 	sts	0x50CB, r26
    4d38:	b0 93 cc 50 	sts	0x50CC, r27
				appendFileLocation = i;
    4d3c:	c9 01       	movw	r24, r18
    4d3e:	a0 e0       	ldi	r26, 0x00	; 0
    4d40:	b0 e0       	ldi	r27, 0x00	; 0
    4d42:	80 93 d7 23 	sts	0x23D7, r24
    4d46:	90 93 d8 23 	sts	0x23D8, r25
    4d4a:	a0 93 d9 23 	sts	0x23D9, r26
    4d4e:	b0 93 da 23 	sts	0x23DA, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4d52:	d6 01       	movw	r26, r12
    4d54:	54 96       	adiw	r26, 0x14	; 20
    4d56:	4d 91       	ld	r20, X+
    4d58:	5c 91       	ld	r21, X
    4d5a:	55 97       	sbiw	r26, 0x15	; 21
    4d5c:	60 e0       	ldi	r22, 0x00	; 0
    4d5e:	70 e0       	ldi	r23, 0x00	; 0
    4d60:	ba 01       	movw	r22, r20
    4d62:	55 27       	eor	r21, r21
    4d64:	44 27       	eor	r20, r20
    4d66:	5a 96       	adiw	r26, 0x1a	; 26
    4d68:	8d 91       	ld	r24, X+
    4d6a:	9c 91       	ld	r25, X
    4d6c:	5b 97       	sbiw	r26, 0x1b	; 27
    4d6e:	a0 e0       	ldi	r26, 0x00	; 0
    4d70:	b0 e0       	ldi	r27, 0x00	; 0
    4d72:	84 2b       	or	r24, r20
    4d74:	95 2b       	or	r25, r21
    4d76:	a6 2b       	or	r26, r22
    4d78:	b7 2b       	or	r27, r23
    4d7a:	80 93 87 50 	sts	0x5087, r24
    4d7e:	90 93 88 50 	sts	0x5088, r25
    4d82:	a0 93 89 50 	sts	0x5089, r26
    4d86:	b0 93 8a 50 	sts	0x508A, r27
				fileSize = dir->fileSize;
    4d8a:	f6 01       	movw	r30, r12
    4d8c:	84 8d       	ldd	r24, Z+28	; 0x1c
    4d8e:	95 8d       	ldd	r25, Z+29	; 0x1d
    4d90:	a6 8d       	ldd	r26, Z+30	; 0x1e
    4d92:	b7 8d       	ldd	r27, Z+31	; 0x1f
    4d94:	80 93 50 40 	sts	0x4050, r24
    4d98:	90 93 51 40 	sts	0x4051, r25
    4d9c:	a0 93 52 40 	sts	0x4052, r26
    4da0:	b0 93 53 40 	sts	0x4053, r27
			    return (dir);
    4da4:	a5 c0       	rjmp	.+330    	; 0x4ef0 <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4da6:	d6 01       	movw	r26, r12
    4da8:	54 96       	adiw	r26, 0x14	; 20
    4daa:	8d 91       	ld	r24, X+
    4dac:	9c 91       	ld	r25, X
    4dae:	55 97       	sbiw	r26, 0x15	; 21
    4db0:	a0 e0       	ldi	r26, 0x00	; 0
    4db2:	b0 e0       	ldi	r27, 0x00	; 0
    4db4:	3c 01       	movw	r6, r24
    4db6:	55 24       	eor	r5, r5
    4db8:	44 24       	eor	r4, r4
    4dba:	f6 01       	movw	r30, r12
    4dbc:	82 8d       	ldd	r24, Z+26	; 0x1a
    4dbe:	93 8d       	ldd	r25, Z+27	; 0x1b
    4dc0:	a0 e0       	ldi	r26, 0x00	; 0
    4dc2:	b0 e0       	ldi	r27, 0x00	; 0
    4dc4:	48 2a       	or	r4, r24
    4dc6:	59 2a       	or	r5, r25
    4dc8:	6a 2a       	or	r6, r26
    4dca:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    4dcc:	85 ee       	ldi	r24, 0xE5	; 229
    4dce:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    4dd0:	69 81       	ldd	r22, Y+1	; 0x01
    4dd2:	7a 81       	ldd	r23, Y+2	; 0x02
    4dd4:	8b 81       	ldd	r24, Y+3	; 0x03
    4dd6:	9c 81       	ldd	r25, Y+4	; 0x04
    4dd8:	46 ed       	ldi	r20, 0xD6	; 214
    4dda:	51 e2       	ldi	r21, 0x21	; 33
    4ddc:	20 e0       	ldi	r18, 0x00	; 0
    4dde:	32 e0       	ldi	r19, 0x02	; 2
    4de0:	0e 94 29 2c 	call	0x5852	; 0x5852 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    4de4:	d6 01       	movw	r26, r12
    4de6:	5c 96       	adiw	r26, 0x1c	; 28
    4de8:	4d 91       	ld	r20, X+
    4dea:	5d 91       	ld	r21, X+
    4dec:	6d 91       	ld	r22, X+
    4dee:	7c 91       	ld	r23, X
    4df0:	5f 97       	sbiw	r26, 0x1f	; 31
    4df2:	80 e0       	ldi	r24, 0x00	; 0
    4df4:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    4df8:	82 e0       	ldi	r24, 0x02	; 2
    4dfa:	60 e0       	ldi	r22, 0x00	; 0
    4dfc:	20 e0       	ldi	r18, 0x00	; 0
    4dfe:	30 e0       	ldi	r19, 0x00	; 0
    4e00:	a9 01       	movw	r20, r18
    4e02:	0e 94 87 22 	call	0x450e	; 0x450e <getSetFreeCluster>
    4e06:	dc 01       	movw	r26, r24
    4e08:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    4e0a:	48 16       	cp	r4, r24
    4e0c:	59 06       	cpc	r5, r25
    4e0e:	6a 06       	cpc	r6, r26
    4e10:	7b 06       	cpc	r7, r27
    4e12:	30 f4       	brcc	.+12     	; 0x4e20 <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    4e14:	82 e0       	ldi	r24, 0x02	; 2
    4e16:	61 e0       	ldi	r22, 0x01	; 1
    4e18:	a3 01       	movw	r20, r6
    4e1a:	92 01       	movw	r18, r4
    4e1c:	0e 94 87 22 	call	0x450e	; 0x450e <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    4e20:	c3 01       	movw	r24, r6
    4e22:	b2 01       	movw	r22, r4
    4e24:	40 e0       	ldi	r20, 0x00	; 0
    4e26:	00 e0       	ldi	r16, 0x00	; 0
    4e28:	10 e0       	ldi	r17, 0x00	; 0
    4e2a:	98 01       	movw	r18, r16
    4e2c:	0e 94 f5 21 	call	0x43ea	; 0x43ea <getSetNextCluster>
    4e30:	6b 01       	movw	r12, r22
    4e32:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    4e34:	c3 01       	movw	r24, r6
    4e36:	b2 01       	movw	r22, r4
    4e38:	41 e0       	ldi	r20, 0x01	; 1
    4e3a:	00 e0       	ldi	r16, 0x00	; 0
    4e3c:	10 e0       	ldi	r17, 0x00	; 0
    4e3e:	98 01       	movw	r18, r16
    4e40:	0e 94 f5 21 	call	0x43ea	; 0x43ea <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    4e44:	b7 ef       	ldi	r27, 0xF7	; 247
    4e46:	cb 16       	cp	r12, r27
    4e48:	bf ef       	ldi	r27, 0xFF	; 255
    4e4a:	db 06       	cpc	r13, r27
    4e4c:	bf ef       	ldi	r27, 0xFF	; 255
    4e4e:	eb 06       	cpc	r14, r27
    4e50:	bf e0       	ldi	r27, 0x0F	; 15
    4e52:	fb 06       	cpc	r15, r27
    4e54:	08 f0       	brcs	.+2      	; 0x4e58 <findFiles+0x270>
    4e56:	47 c0       	rjmp	.+142    	; 0x4ee6 <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    4e58:	26 01       	movw	r4, r12
    4e5a:	37 01       	movw	r6, r14
    4e5c:	e1 cf       	rjmp	.-62     	; 0x4e20 <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4e5e:	20 5e       	subi	r18, 0xE0	; 224
    4e60:	3f 4f       	sbci	r19, 0xFF	; 255
    4e62:	80 91 54 40 	lds	r24, 0x4054
    4e66:	90 91 55 40 	lds	r25, 0x4055
    4e6a:	28 17       	cp	r18, r24
    4e6c:	39 07       	cpc	r19, r25
    4e6e:	08 f4       	brcc	.+2      	; 0x4e72 <findFiles+0x28a>
    4e70:	26 cf       	rjmp	.-436    	; 0x4cbe <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    4e72:	08 94       	sec
    4e74:	41 1c       	adc	r4, r1
    4e76:	51 1c       	adc	r5, r1
    4e78:	61 1c       	adc	r6, r1
    4e7a:	71 1c       	adc	r7, r1
    4e7c:	80 91 7b 50 	lds	r24, 0x507B
    4e80:	90 91 7c 50 	lds	r25, 0x507C
    4e84:	a0 e0       	ldi	r26, 0x00	; 0
    4e86:	b0 e0       	ldi	r27, 0x00	; 0
    4e88:	48 16       	cp	r4, r24
    4e8a:	59 06       	cpc	r5, r25
    4e8c:	6a 06       	cpc	r6, r26
    4e8e:	7b 06       	cpc	r7, r27
    4e90:	08 f4       	brcc	.+2      	; 0x4e94 <findFiles+0x2ac>
    4e92:	f2 ce       	rjmp	.-540    	; 0x4c78 <findFiles+0x90>
    4e94:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    4e96:	69 85       	ldd	r22, Y+9	; 0x09
    4e98:	7a 85       	ldd	r23, Y+10	; 0x0a
    4e9a:	8b 85       	ldd	r24, Y+11	; 0x0b
    4e9c:	9c 85       	ldd	r25, Y+12	; 0x0c
    4e9e:	40 e0       	ldi	r20, 0x00	; 0
    4ea0:	00 e0       	ldi	r16, 0x00	; 0
    4ea2:	10 e0       	ldi	r17, 0x00	; 0
    4ea4:	98 01       	movw	r18, r16
    4ea6:	0e 94 f5 21 	call	0x43ea	; 0x43ea <getSetNextCluster>
    4eaa:	69 87       	std	Y+9, r22	; 0x09
    4eac:	7a 87       	std	Y+10, r23	; 0x0a
    4eae:	8b 87       	std	Y+11, r24	; 0x0b
    4eb0:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    4eb2:	67 3f       	cpi	r22, 0xF7	; 247
    4eb4:	ef ef       	ldi	r30, 0xFF	; 255
    4eb6:	7e 07       	cpc	r23, r30
    4eb8:	ef ef       	ldi	r30, 0xFF	; 255
    4eba:	8e 07       	cpc	r24, r30
    4ebc:	ef e0       	ldi	r30, 0x0F	; 15
    4ebe:	9e 07       	cpc	r25, r30
    4ec0:	a8 f4       	brcc	.+42     	; 0x4eec <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    4ec2:	61 15       	cp	r22, r1
    4ec4:	71 05       	cpc	r23, r1
    4ec6:	81 05       	cpc	r24, r1
    4ec8:	91 05       	cpc	r25, r1
    4eca:	09 f0       	breq	.+2      	; 0x4ece <findFiles+0x2e6>
    4ecc:	c0 ce       	rjmp	.-640    	; 0x4c4e <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    4ece:	00 e0       	ldi	r16, 0x00	; 0
    4ed0:	10 e0       	ldi	r17, 0x00	; 0
    4ed2:	0e c0       	rjmp	.+28     	; 0x4ef0 <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    4ed4:	00 e0       	ldi	r16, 0x00	; 0
    4ed6:	10 e0       	ldi	r17, 0x00	; 0
    4ed8:	0b c0       	rjmp	.+22     	; 0x4ef0 <findFiles+0x308>
    4eda:	00 e0       	ldi	r16, 0x00	; 0
    4edc:	10 e0       	ldi	r17, 0x00	; 0
    4ede:	08 c0       	rjmp	.+16     	; 0x4ef0 <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    4ee0:	00 e0       	ldi	r16, 0x00	; 0
    4ee2:	10 e0       	ldi	r17, 0x00	; 0
    4ee4:	05 c0       	rjmp	.+10     	; 0x4ef0 <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    4ee6:	00 e0       	ldi	r16, 0x00	; 0
    4ee8:	10 e0       	ldi	r17, 0x00	; 0
    4eea:	02 c0       	rjmp	.+4      	; 0x4ef0 <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    4eec:	00 e0       	ldi	r16, 0x00	; 0
    4eee:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    4ef0:	80 2f       	mov	r24, r16
    4ef2:	91 2f       	mov	r25, r17
    4ef4:	2c 96       	adiw	r28, 0x0c	; 12
    4ef6:	cd bf       	out	0x3d, r28	; 61
    4ef8:	de bf       	out	0x3e, r29	; 62
    4efa:	df 91       	pop	r29
    4efc:	cf 91       	pop	r28
    4efe:	1f 91       	pop	r17
    4f00:	0f 91       	pop	r16
    4f02:	ff 90       	pop	r15
    4f04:	ef 90       	pop	r14
    4f06:	df 90       	pop	r13
    4f08:	cf 90       	pop	r12
    4f0a:	bf 90       	pop	r11
    4f0c:	af 90       	pop	r10
    4f0e:	9f 90       	pop	r9
    4f10:	8f 90       	pop	r8
    4f12:	7f 90       	pop	r7
    4f14:	6f 90       	pop	r6
    4f16:	5f 90       	pop	r5
    4f18:	4f 90       	pop	r4
    4f1a:	3f 90       	pop	r3
    4f1c:	2f 90       	pop	r2
    4f1e:	08 95       	ret

00004f20 <deleteFile>:
//********************************************************************
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
    4f20:	0e 94 14 24 	call	0x4828	; 0x4828 <convertFileName>
  if(error) return;
    4f24:	88 23       	and	r24, r24
    4f26:	29 f4       	brne	.+10     	; 0x4f32 <deleteFile+0x12>

  findFiles (DELETE, Filename);
    4f28:	82 e0       	ldi	r24, 0x02	; 2
    4f2a:	63 eb       	ldi	r22, 0xB3	; 179
    4f2c:	70 e5       	ldi	r23, 0x50	; 80
    4f2e:	0e 94 f4 25 	call	0x4be8	; 0x4be8 <findFiles>
    4f32:	08 95       	ret

00004f34 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    4f34:	4f 92       	push	r4
    4f36:	5f 92       	push	r5
    4f38:	6f 92       	push	r6
    4f3a:	7f 92       	push	r7
    4f3c:	af 92       	push	r10
    4f3e:	bf 92       	push	r11
    4f40:	cf 92       	push	r12
    4f42:	df 92       	push	r13
    4f44:	ef 92       	push	r14
    4f46:	ff 92       	push	r15
    4f48:	0f 93       	push	r16
    4f4a:	1f 93       	push	r17
    4f4c:	cf 93       	push	r28
    4f4e:	c8 2f       	mov	r28, r24
    4f50:	cb 01       	movw	r24, r22
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    4f52:	0e 94 14 24 	call	0x4828	; 0x4828 <convertFileName>
if(error) return 2;
    4f56:	88 23       	and	r24, r24
    4f58:	09 f0       	breq	.+2      	; 0x4f5c <readFile+0x28>
    4f5a:	57 c0       	rjmp	.+174    	; 0x500a <readFile+0xd6>

dir = findFiles (GET_FILE, Filename); //get the file location
    4f5c:	81 e0       	ldi	r24, 0x01	; 1
    4f5e:	63 eb       	ldi	r22, 0xB3	; 179
    4f60:	70 e5       	ldi	r23, 0x50	; 80
    4f62:	0e 94 f4 25 	call	0x4be8	; 0x4be8 <findFiles>
    4f66:	fc 01       	movw	r30, r24
if(dir == 0) 
    4f68:	00 97       	sbiw	r24, 0x00	; 0
    4f6a:	31 f4       	brne	.+12     	; 0x4f78 <readFile+0x44>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4f6c:	81 e0       	ldi	r24, 0x01	; 1
    4f6e:	cc 23       	and	r28, r28
    4f70:	09 f4       	brne	.+2      	; 0x4f74 <readFile+0x40>
    4f72:	4e c0       	rjmp	.+156    	; 0x5010 <readFile+0xdc>
    4f74:	80 e0       	ldi	r24, 0x00	; 0
    4f76:	4c c0       	rjmp	.+152    	; 0x5010 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4f78:	c1 30       	cpi	r28, 0x01	; 1
    4f7a:	09 f4       	brne	.+2      	; 0x4f7e <readFile+0x4a>
    4f7c:	48 c0       	rjmp	.+144    	; 0x500e <readFile+0xda>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4f7e:	44 88       	ldd	r4, Z+20	; 0x14
    4f80:	55 88       	ldd	r5, Z+21	; 0x15
    4f82:	66 24       	eor	r6, r6
    4f84:	77 24       	eor	r7, r7
    4f86:	32 01       	movw	r6, r4
    4f88:	55 24       	eor	r5, r5
    4f8a:	44 24       	eor	r4, r4
    4f8c:	82 8d       	ldd	r24, Z+26	; 0x1a
    4f8e:	93 8d       	ldd	r25, Z+27	; 0x1b
    4f90:	a0 e0       	ldi	r26, 0x00	; 0
    4f92:	b0 e0       	ldi	r27, 0x00	; 0
    4f94:	48 2a       	or	r4, r24
    4f96:	59 2a       	or	r5, r25
    4f98:	6a 2a       	or	r6, r26
    4f9a:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4f9c:	0f 2e       	mov	r0, r31
    4f9e:	ff ed       	ldi	r31, 0xDF	; 223
    4fa0:	af 2e       	mov	r10, r31
    4fa2:	f3 e2       	ldi	r31, 0x23	; 35
    4fa4:	bf 2e       	mov	r11, r31
    4fa6:	f0 2d       	mov	r31, r0
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    4fa8:	c3 01       	movw	r24, r6
    4faa:	b2 01       	movw	r22, r4
    4fac:	0e 94 ce 21 	call	0x439c	; 0x439c <getFirstSector>
    4fb0:	6b 01       	movw	r12, r22
    4fb2:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    4fb4:	80 91 7b 50 	lds	r24, 0x507B
    4fb8:	90 91 7c 50 	lds	r25, 0x507C
    4fbc:	00 97       	sbiw	r24, 0x00	; 0
    4fbe:	a1 f0       	breq	.+40     	; 0x4fe8 <readFile+0xb4>
    4fc0:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4fc2:	c7 01       	movw	r24, r14
    4fc4:	b6 01       	movw	r22, r12
    4fc6:	6c 0f       	add	r22, r28
    4fc8:	71 1d       	adc	r23, r1
    4fca:	81 1d       	adc	r24, r1
    4fcc:	91 1d       	adc	r25, r1
    4fce:	a5 01       	movw	r20, r10
    4fd0:	0e 94 de 2c 	call	0x59bc	; 0x59bc <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    4fd4:	cf 5f       	subi	r28, 0xFF	; 255
    4fd6:	80 91 7b 50 	lds	r24, 0x507B
    4fda:	90 91 7c 50 	lds	r25, 0x507C
    4fde:	2c 2f       	mov	r18, r28
    4fe0:	30 e0       	ldi	r19, 0x00	; 0
    4fe2:	28 17       	cp	r18, r24
    4fe4:	39 07       	cpc	r19, r25
    4fe6:	68 f3       	brcs	.-38     	; 0x4fc2 <readFile+0x8e>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    4fe8:	c3 01       	movw	r24, r6
    4fea:	b2 01       	movw	r22, r4
    4fec:	40 e0       	ldi	r20, 0x00	; 0
    4fee:	00 e0       	ldi	r16, 0x00	; 0
    4ff0:	10 e0       	ldi	r17, 0x00	; 0
    4ff2:	98 01       	movw	r18, r16
    4ff4:	0e 94 f5 21 	call	0x43ea	; 0x43ea <getSetNextCluster>
    4ff8:	2b 01       	movw	r4, r22
    4ffa:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    4ffc:	61 15       	cp	r22, r1
    4ffe:	71 05       	cpc	r23, r1
    5000:	81 05       	cpc	r24, r1
    5002:	91 05       	cpc	r25, r1
    5004:	89 f6       	brne	.-94     	; 0x4fa8 <readFile+0x74>
	  return 0;}
    5006:	80 e0       	ldi	r24, 0x00	; 0
    5008:	03 c0       	rjmp	.+6      	; 0x5010 <readFile+0xdc>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    500a:	82 e0       	ldi	r24, 0x02	; 2
    500c:	01 c0       	rjmp	.+2      	; 0x5010 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    500e:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    5010:	cf 91       	pop	r28
    5012:	1f 91       	pop	r17
    5014:	0f 91       	pop	r16
    5016:	ff 90       	pop	r15
    5018:	ef 90       	pop	r14
    501a:	df 90       	pop	r13
    501c:	cf 90       	pop	r12
    501e:	bf 90       	pop	r11
    5020:	af 90       	pop	r10
    5022:	7f 90       	pop	r7
    5024:	6f 90       	pop	r6
    5026:	5f 90       	pop	r5
    5028:	4f 90       	pop	r4
    502a:	08 95       	ret

0000502c <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    502c:	2f 92       	push	r2
    502e:	3f 92       	push	r3
    5030:	4f 92       	push	r4
    5032:	5f 92       	push	r5
    5034:	6f 92       	push	r6
    5036:	7f 92       	push	r7
    5038:	8f 92       	push	r8
    503a:	9f 92       	push	r9
    503c:	af 92       	push	r10
    503e:	bf 92       	push	r11
    5040:	cf 92       	push	r12
    5042:	df 92       	push	r13
    5044:	ef 92       	push	r14
    5046:	ff 92       	push	r15
    5048:	0f 93       	push	r16
    504a:	1f 93       	push	r17
    504c:	cf 93       	push	r28
    504e:	df 93       	push	r29
    5050:	cd b7       	in	r28, 0x3d	; 61
    5052:	de b7       	in	r29, 0x3e	; 62
    5054:	60 97       	sbiw	r28, 0x10	; 16
    5056:	cd bf       	out	0x3d, r28	; 61
    5058:	de bf       	out	0x3e, r29	; 62
    505a:	fc 01       	movw	r30, r24
    505c:	6d 83       	std	Y+5, r22	; 0x05
    505e:	7e 83       	std	Y+6, r23	; 0x06
    5060:	49 01       	movw	r8, r18
    5062:	5a 01       	movw	r10, r20
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    5064:	81 e0       	ldi	r24, 0x01	; 1
    5066:	bf 01       	movw	r22, r30
    5068:	0e 94 9a 27 	call	0x4f34	; 0x4f34 <readFile>

if(j == 1) 
    506c:	81 30       	cpi	r24, 0x01	; 1
    506e:	09 f0       	breq	.+2      	; 0x5072 <writeFile+0x46>
    5070:	7b c0       	rjmp	.+246    	; 0x5168 <writeFile+0x13c>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    5072:	00 91 87 50 	lds	r16, 0x5087
    5076:	10 91 88 50 	lds	r17, 0x5088
    507a:	20 91 89 50 	lds	r18, 0x5089
    507e:	30 91 8a 50 	lds	r19, 0x508A
    5082:	09 83       	std	Y+1, r16	; 0x01
    5084:	1a 83       	std	Y+2, r17	; 0x02
    5086:	2b 83       	std	Y+3, r18	; 0x03
    5088:	3c 83       	std	Y+4, r19	; 0x04
  clusterCount=0;
    508a:	cc 24       	eor	r12, r12
    508c:	dd 24       	eor	r13, r13
    508e:	76 01       	movw	r14, r12
    5090:	24 01       	movw	r4, r8
    5092:	35 01       	movw	r6, r10
    5094:	48 01       	movw	r8, r16
    5096:	59 01       	movw	r10, r18
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    5098:	c5 01       	movw	r24, r10
    509a:	b4 01       	movw	r22, r8
    509c:	40 e0       	ldi	r20, 0x00	; 0
    509e:	00 e0       	ldi	r16, 0x00	; 0
    50a0:	10 e0       	ldi	r17, 0x00	; 0
    50a2:	98 01       	movw	r18, r16
    50a4:	0e 94 f5 21 	call	0x43ea	; 0x43ea <getSetNextCluster>
    50a8:	dc 01       	movw	r26, r24
    50aa:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    50ac:	8f 3f       	cpi	r24, 0xFF	; 255
    50ae:	1f ef       	ldi	r17, 0xFF	; 255
    50b0:	91 07       	cpc	r25, r17
    50b2:	1f ef       	ldi	r17, 0xFF	; 255
    50b4:	a1 07       	cpc	r26, r17
    50b6:	1f ef       	ldi	r17, 0xFF	; 255
    50b8:	b1 07       	cpc	r27, r17
    50ba:	41 f0       	breq	.+16     	; 0x50cc <writeFile+0xa0>
	cluster = nextCluster;
	clusterCount++;
    50bc:	08 94       	sec
    50be:	c1 1c       	adc	r12, r1
    50c0:	d1 1c       	adc	r13, r1
    50c2:	e1 1c       	adc	r14, r1
    50c4:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    50c6:	4c 01       	movw	r8, r24
    50c8:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    50ca:	e6 cf       	rjmp	.-52     	; 0x5098 <writeFile+0x6c>
    50cc:	89 82       	std	Y+1, r8	; 0x01
    50ce:	9a 82       	std	Y+2, r9	; 0x02
    50d0:	ab 82       	std	Y+3, r10	; 0x03
    50d2:	bc 82       	std	Y+4, r11	; 0x04
    50d4:	53 01       	movw	r10, r6
    50d6:	42 01       	movw	r8, r4
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    50d8:	20 91 7b 50 	lds	r18, 0x507B
    50dc:	30 91 7c 50 	lds	r19, 0x507C
    50e0:	80 91 54 40 	lds	r24, 0x4054
    50e4:	90 91 55 40 	lds	r25, 0x4055
    50e8:	60 90 54 40 	lds	r6, 0x4054
    50ec:	70 90 55 40 	lds	r7, 0x4055
    50f0:	bc 01       	movw	r22, r24
    50f2:	80 e0       	ldi	r24, 0x00	; 0
    50f4:	90 e0       	ldi	r25, 0x00	; 0
    50f6:	40 e0       	ldi	r20, 0x00	; 0
    50f8:	50 e0       	ldi	r21, 0x00	; 0
    50fa:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    50fe:	a7 01       	movw	r20, r14
    5100:	96 01       	movw	r18, r12
    5102:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    5106:	dc 01       	movw	r26, r24
    5108:	cb 01       	movw	r24, r22
    510a:	40 91 50 40 	lds	r20, 0x4050
    510e:	50 91 51 40 	lds	r21, 0x4051
    5112:	60 91 52 40 	lds	r22, 0x4052
    5116:	70 91 53 40 	lds	r23, 0x4053
    511a:	8a 01       	movw	r16, r20
    511c:	9b 01       	movw	r18, r22
    511e:	08 1b       	sub	r16, r24
    5120:	19 0b       	sbc	r17, r25
    5122:	2a 0b       	sbc	r18, r26
    5124:	3b 0b       	sbc	r19, r27
    5126:	c9 01       	movw	r24, r18
    5128:	b8 01       	movw	r22, r16
    512a:	93 01       	movw	r18, r6
    512c:	40 e0       	ldi	r20, 0x00	; 0
    512e:	50 e0       	ldi	r21, 0x00	; 0
    5130:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    5134:	02 2f       	mov	r16, r18

//start writing data here

if(start){
  start = 0;
  startBlock = getFirstSector (cluster) + sector;
    5136:	69 81       	ldd	r22, Y+1	; 0x01
    5138:	7a 81       	ldd	r23, Y+2	; 0x02
    513a:	8b 81       	ldd	r24, Y+3	; 0x03
    513c:	9c 81       	ldd	r25, Y+4	; 0x04
    513e:	0e 94 ce 21 	call	0x439c	; 0x439c <getFirstSector>
    5142:	dc 01       	movw	r26, r24
    5144:	cb 01       	movw	r24, r22
    5146:	20 2e       	mov	r2, r16
    5148:	33 24       	eor	r3, r3
    514a:	28 0e       	add	r2, r24
    514c:	39 1e       	adc	r3, r25
  SD_read_block (startBlock,SDBuffer);
    514e:	b1 01       	movw	r22, r2
    5150:	80 e0       	ldi	r24, 0x00	; 0
    5152:	90 e0       	ldi	r25, 0x00	; 0
    5154:	46 ed       	ldi	r20, 0xD6	; 214
    5156:	51 e2       	ldi	r21, 0x21	; 33
    5158:	0e 94 de 2c 	call	0x59bc	; 0x59bc <SD_read_block>
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    515c:	1f 86       	std	Y+15, r1	; 0x0f
    515e:	18 8a       	std	Y+16, r1	; 0x10
    5160:	19 86       	std	Y+9, r1	; 0x09
    5162:	1a 86       	std	Y+10, r1	; 0x0a
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    5164:	11 e0       	ldi	r17, 0x01	; 1
    5166:	4c c0       	rjmp	.+152    	; 0x5200 <writeFile+0x1d4>
}
else if(j == 2) 
    5168:	82 30       	cpi	r24, 0x02	; 2
    516a:	09 f4       	brne	.+2      	; 0x516e <writeFile+0x142>
    516c:	0c c2       	rjmp	.+1048   	; 0x5586 <writeFile+0x55a>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    516e:	82 e0       	ldi	r24, 0x02	; 2
    5170:	60 e0       	ldi	r22, 0x00	; 0
    5172:	20 e0       	ldi	r18, 0x00	; 0
    5174:	30 e0       	ldi	r19, 0x00	; 0
    5176:	a9 01       	movw	r20, r18
    5178:	0e 94 87 22 	call	0x450e	; 0x450e <getSetFreeCluster>
  if(cluster > totalClusters)
    517c:	00 91 59 40 	lds	r16, 0x4059
    5180:	10 91 5a 40 	lds	r17, 0x405A
    5184:	20 91 5b 40 	lds	r18, 0x405B
    5188:	30 91 5c 40 	lds	r19, 0x405C
    518c:	06 17       	cp	r16, r22
    518e:	17 07       	cpc	r17, r23
    5190:	28 07       	cpc	r18, r24
    5192:	39 07       	cpc	r19, r25
    5194:	40 f4       	brcc	.+16     	; 0x51a6 <writeFile+0x17a>
     cluster = rootCluster;
    5196:	60 91 5f 40 	lds	r22, 0x405F
    519a:	70 91 60 40 	lds	r23, 0x4060
    519e:	80 91 61 40 	lds	r24, 0x4061
    51a2:	90 91 62 40 	lds	r25, 0x4062

  cluster = searchNextFreeCluster(cluster);
    51a6:	0e 94 d3 24 	call	0x49a6	; 0x49a6 <searchNextFreeCluster>
    51aa:	69 83       	std	Y+1, r22	; 0x01
    51ac:	7a 83       	std	Y+2, r23	; 0x02
    51ae:	8b 83       	std	Y+3, r24	; 0x03
    51b0:	9c 83       	std	Y+4, r25	; 0x04
   if(cluster == 0)
    51b2:	61 15       	cp	r22, r1
    51b4:	71 05       	cpc	r23, r1
    51b6:	81 05       	cpc	r24, r1
    51b8:	91 05       	cpc	r25, r1
    51ba:	09 f4       	brne	.+2      	; 0x51be <writeFile+0x192>
    51bc:	e6 c1       	rjmp	.+972    	; 0x558a <writeFile+0x55e>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    51be:	41 e0       	ldi	r20, 0x01	; 1
    51c0:	0f ef       	ldi	r16, 0xFF	; 255
    51c2:	1f ef       	ldi	r17, 0xFF	; 255
    51c4:	98 01       	movw	r18, r16
    51c6:	0e 94 f5 21 	call	0x43ea	; 0x43ea <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    51ca:	2b 81       	ldd	r18, Y+3	; 0x03
    51cc:	3c 81       	ldd	r19, Y+4	; 0x04
    51ce:	29 87       	std	Y+9, r18	; 0x09
    51d0:	3a 87       	std	Y+10, r19	; 0x0a
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    51d2:	89 81       	ldd	r24, Y+1	; 0x01
    51d4:	9a 81       	ldd	r25, Y+2	; 0x02
    51d6:	8f 87       	std	Y+15, r24	; 0x0f
    51d8:	98 8b       	std	Y+16, r25	; 0x10
  fileSize = 0;
    51da:	10 92 50 40 	sts	0x4050, r1
    51de:	10 92 51 40 	sts	0x4051, r1
    51e2:	10 92 52 40 	sts	0x4052, r1
    51e6:	10 92 53 40 	sts	0x4053, r1
  startBlock = getFirstSector (cluster) + sector;
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
    51ea:	69 81       	ldd	r22, Y+1	; 0x01
    51ec:	7a 81       	ldd	r23, Y+2	; 0x02
    51ee:	8b 81       	ldd	r24, Y+3	; 0x03
    51f0:	9c 81       	ldd	r25, Y+4	; 0x04
    51f2:	0e 94 ce 21 	call	0x439c	; 0x439c <getFirstSector>
    51f6:	dc 01       	movw	r26, r24
    51f8:	cb 01       	movw	r24, r22
    51fa:	1c 01       	movw	r2, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    51fc:	10 e0       	ldi	r17, 0x00	; 0
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
  j=0;
    51fe:	00 e0       	ldi	r16, 0x00	; 0
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    5200:	81 14       	cp	r8, r1
    5202:	91 04       	cpc	r9, r1
    5204:	a1 04       	cpc	r10, r1
    5206:	b1 04       	cpc	r11, r1
    5208:	09 f4       	brne	.+2      	; 0x520c <writeFile+0x1e0>
    520a:	8d c0       	rjmp	.+282    	; 0x5326 <writeFile+0x2fa>
    520c:	44 24       	eor	r4, r4
    520e:	55 24       	eor	r5, r5
    5210:	32 01       	movw	r6, r4
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
		 writtenData += 512;
		 dataToWrite = 512;
    5212:	c0 2e       	mov	r12, r16
    5214:	1b 87       	std	Y+11, r17	; 0x0b
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    5216:	90 e0       	ldi	r25, 0x00	; 0
    5218:	89 16       	cp	r8, r25
    521a:	92 e0       	ldi	r25, 0x02	; 2
    521c:	99 06       	cpc	r9, r25
    521e:	90 e0       	ldi	r25, 0x00	; 0
    5220:	a9 06       	cpc	r10, r25
    5222:	90 e0       	ldi	r25, 0x00	; 0
    5224:	b9 06       	cpc	r11, r25
    5226:	88 f0       	brcs	.+34     	; 0x524a <writeFile+0x21e>
		 writtenData += 512;
    5228:	00 e0       	ldi	r16, 0x00	; 0
    522a:	12 e0       	ldi	r17, 0x02	; 2
    522c:	20 e0       	ldi	r18, 0x00	; 0
    522e:	30 e0       	ldi	r19, 0x00	; 0
    5230:	40 0e       	add	r4, r16
    5232:	51 1e       	adc	r5, r17
    5234:	62 1e       	adc	r6, r18
    5236:	73 1e       	adc	r7, r19
		 dataToWrite = 512;
		 lengthOfData -= 512;
    5238:	80 e0       	ldi	r24, 0x00	; 0
    523a:	9e ef       	ldi	r25, 0xFE	; 254
    523c:	af ef       	ldi	r26, 0xFF	; 255
    523e:	bf ef       	ldi	r27, 0xFF	; 255
    5240:	88 0e       	add	r8, r24
    5242:	99 1e       	adc	r9, r25
    5244:	aa 1e       	adc	r10, r26
    5246:	bb 1e       	adc	r11, r27
    5248:	0c c0       	rjmp	.+24     	; 0x5262 <writeFile+0x236>
	}
	else{
		writtenData += lengthOfData;
    524a:	48 0c       	add	r4, r8
    524c:	59 1c       	adc	r5, r9
    524e:	6a 1c       	adc	r6, r10
    5250:	7b 1c       	adc	r7, r11
		dataToWrite = lengthOfData%512;
    5252:	95 01       	movw	r18, r10
    5254:	84 01       	movw	r16, r8
    5256:	11 70       	andi	r17, 0x01	; 1
    5258:	20 70       	andi	r18, 0x00	; 0
    525a:	30 70       	andi	r19, 0x00	; 0
		lengthOfData = 0;
    525c:	88 24       	eor	r8, r8
    525e:	99 24       	eor	r9, r9
    5260:	54 01       	movw	r10, r8
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    5262:	80 91 50 40 	lds	r24, 0x4050
    5266:	90 91 51 40 	lds	r25, 0x4051
    526a:	a0 91 52 40 	lds	r26, 0x4052
    526e:	b0 91 53 40 	lds	r27, 0x4053
    5272:	80 50       	subi	r24, 0x00	; 0
    5274:	9e 4f       	sbci	r25, 0xFE	; 254
    5276:	af 4f       	sbci	r26, 0xFF	; 255
    5278:	bf 4f       	sbci	r27, 0xFF	; 255
    527a:	80 93 50 40 	sts	0x4050, r24
    527e:	90 93 51 40 	sts	0x4051, r25
    5282:	a0 93 52 40 	sts	0x4052, r26
    5286:	b0 93 53 40 	sts	0x4053, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    528a:	b1 01       	movw	r22, r2
    528c:	80 e0       	ldi	r24, 0x00	; 0
    528e:	90 e0       	ldi	r25, 0x00	; 0
    5290:	a2 01       	movw	r20, r4
    5292:	40 1b       	sub	r20, r16
    5294:	51 0b       	sbc	r21, r17
    5296:	ad 81       	ldd	r26, Y+5	; 0x05
    5298:	be 81       	ldd	r27, Y+6	; 0x06
    529a:	4a 0f       	add	r20, r26
    529c:	5b 1f       	adc	r21, r27
    529e:	98 01       	movw	r18, r16
    52a0:	0e 94 29 2c 	call	0x5852	; 0x5852 <SD_write_block>
	j++;
    52a4:	c3 94       	inc	r12
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    52a6:	20 91 7b 50 	lds	r18, 0x507B
    52aa:	30 91 7c 50 	lds	r19, 0x507C
    52ae:	8c 2d       	mov	r24, r12
    52b0:	90 e0       	ldi	r25, 0x00	; 0
    52b2:	82 17       	cp	r24, r18
    52b4:	93 07       	cpc	r25, r19
    52b6:	29 f5       	brne	.+74     	; 0x5302 <writeFile+0x2d6>
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    52b8:	69 81       	ldd	r22, Y+1	; 0x01
    52ba:	7a 81       	ldd	r23, Y+2	; 0x02
    52bc:	8b 81       	ldd	r24, Y+3	; 0x03
    52be:	9c 81       	ldd	r25, Y+4	; 0x04
    52c0:	0e 94 d3 24 	call	0x49a6	; 0x49a6 <searchNextFreeCluster>
    52c4:	6b 01       	movw	r12, r22
    52c6:	7c 01       	movw	r14, r24
		if(cluster == 0){
    52c8:	61 15       	cp	r22, r1
    52ca:	71 05       	cpc	r23, r1
    52cc:	81 05       	cpc	r24, r1
    52ce:	91 05       	cpc	r25, r1
    52d0:	09 f4       	brne	.+2      	; 0x52d4 <writeFile+0x2a8>
    52d2:	5d c1       	rjmp	.+698    	; 0x558e <writeFile+0x562>
		  //No free cluster!
		  return 2;
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    52d4:	69 81       	ldd	r22, Y+1	; 0x01
    52d6:	7a 81       	ldd	r23, Y+2	; 0x02
    52d8:	8b 81       	ldd	r24, Y+3	; 0x03
    52da:	9c 81       	ldd	r25, Y+4	; 0x04
    52dc:	41 e0       	ldi	r20, 0x01	; 1
    52de:	97 01       	movw	r18, r14
    52e0:	86 01       	movw	r16, r12
    52e2:	0e 94 f5 21 	call	0x43ea	; 0x43ea <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    52e6:	c7 01       	movw	r24, r14
    52e8:	b6 01       	movw	r22, r12
    52ea:	41 e0       	ldi	r20, 0x01	; 1
    52ec:	0f ef       	ldi	r16, 0xFF	; 255
    52ee:	1f ef       	ldi	r17, 0xFF	; 255
    52f0:	98 01       	movw	r18, r16
    52f2:	0e 94 f5 21 	call	0x43ea	; 0x43ea <getSetNextCluster>
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    52f6:	c9 82       	std	Y+1, r12	; 0x01
    52f8:	da 82       	std	Y+2, r13	; 0x02
    52fa:	eb 82       	std	Y+3, r14	; 0x03
    52fc:	fc 82       	std	Y+4, r15	; 0x04
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
	j++;
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
    52fe:	cc 24       	eor	r12, r12
    5300:	03 c0       	rjmp	.+6      	; 0x5308 <writeFile+0x2dc>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    5302:	08 94       	sec
    5304:	21 1c       	adc	r2, r1
    5306:	31 1c       	adc	r3, r1
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    5308:	82 e0       	ldi	r24, 0x02	; 2
    530a:	61 e0       	ldi	r22, 0x01	; 1
    530c:	29 81       	ldd	r18, Y+1	; 0x01
    530e:	3a 81       	ldd	r19, Y+2	; 0x02
    5310:	4b 81       	ldd	r20, Y+3	; 0x03
    5312:	5c 81       	ldd	r21, Y+4	; 0x04
    5314:	0e 94 87 22 	call	0x450e	; 0x450e <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    5318:	81 14       	cp	r8, r1
    531a:	91 04       	cpc	r9, r1
    531c:	a1 04       	cpc	r10, r1
    531e:	b1 04       	cpc	r11, r1
    5320:	09 f0       	breq	.+2      	; 0x5324 <writeFile+0x2f8>
    5322:	79 cf       	rjmp	.-270    	; 0x5216 <writeFile+0x1ea>
    5324:	1b 85       	ldd	r17, Y+11	; 0x0b
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    5326:	11 23       	and	r17, r17
    5328:	09 f4       	brne	.+2      	; 0x532c <writeFile+0x300>
    532a:	3f c0       	rjmp	.+126    	; 0x53aa <writeFile+0x37e>
{
  SD_read_block (appendFileSector,SDBuffer);    
    532c:	60 91 c9 50 	lds	r22, 0x50C9
    5330:	70 91 ca 50 	lds	r23, 0x50CA
    5334:	80 91 cb 50 	lds	r24, 0x50CB
    5338:	90 91 cc 50 	lds	r25, 0x50CC
    533c:	06 ed       	ldi	r16, 0xD6	; 214
    533e:	11 e2       	ldi	r17, 0x21	; 33
    5340:	a8 01       	movw	r20, r16
    5342:	0e 94 de 2c 	call	0x59bc	; 0x59bc <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    5346:	e0 91 d7 23 	lds	r30, 0x23D7
    534a:	f0 91 d8 23 	lds	r31, 0x23D8
    534e:	e0 0f       	add	r30, r16
    5350:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    5352:	12 8a       	std	Z+18, r1	; 0x12
    5354:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    5356:	80 91 50 40 	lds	r24, 0x4050
    535a:	90 91 51 40 	lds	r25, 0x4051
    535e:	a0 91 52 40 	lds	r26, 0x4052
    5362:	b0 91 53 40 	lds	r27, 0x4053
    5366:	44 8d       	ldd	r20, Z+28	; 0x1c
    5368:	55 8d       	ldd	r21, Z+29	; 0x1d
    536a:	66 8d       	ldd	r22, Z+30	; 0x1e
    536c:	77 8d       	ldd	r23, Z+31	; 0x1f
    536e:	6c 01       	movw	r12, r24
    5370:	7d 01       	movw	r14, r26
    5372:	c4 1a       	sub	r12, r20
    5374:	d5 0a       	sbc	r13, r21
    5376:	e6 0a       	sbc	r14, r22
    5378:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    537a:	84 8f       	std	Z+28, r24	; 0x1c
    537c:	95 8f       	std	Z+29, r25	; 0x1d
    537e:	a6 8f       	std	Z+30, r26	; 0x1e
    5380:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    5382:	60 91 c9 50 	lds	r22, 0x50C9
    5386:	70 91 ca 50 	lds	r23, 0x50CA
    538a:	80 91 cb 50 	lds	r24, 0x50CB
    538e:	90 91 cc 50 	lds	r25, 0x50CC
    5392:	a8 01       	movw	r20, r16
    5394:	20 e0       	ldi	r18, 0x00	; 0
    5396:	32 e0       	ldi	r19, 0x02	; 2
    5398:	0e 94 29 2c 	call	0x5852	; 0x5852 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    539c:	81 e0       	ldi	r24, 0x01	; 1
    539e:	b7 01       	movw	r22, r14
    53a0:	a6 01       	movw	r20, r12
    53a2:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <freeMemoryUpdate>

 //File appended!
  return 0;
    53a6:	80 e0       	ldi	r24, 0x00	; 0
    53a8:	f9 c0       	rjmp	.+498    	; 0x559c <writeFile+0x570>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    53aa:	00 91 5f 40 	lds	r16, 0x405F
    53ae:	10 91 60 40 	lds	r17, 0x4060
    53b2:	20 91 61 40 	lds	r18, 0x4061
    53b6:	30 91 62 40 	lds	r19, 0x4062
    53ba:	0b 87       	std	Y+11, r16	; 0x0b
    53bc:	1c 87       	std	Y+12, r17	; 0x0c
    53be:	2d 87       	std	Y+13, r18	; 0x0d
    53c0:	3e 87       	std	Y+14, r19	; 0x0e
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    53c2:	77 24       	eor	r7, r7
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    53c4:	83 eb       	ldi	r24, 0xB3	; 179
    53c6:	90 e5       	ldi	r25, 0x50	; 80
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    53c8:	0f 2e       	mov	r0, r31
    53ca:	fb e0       	ldi	r31, 0x0B	; 11
    53cc:	af 2e       	mov	r10, r31
    53ce:	bb 24       	eor	r11, r11
    53d0:	f0 2d       	mov	r31, r0
    53d2:	a8 0e       	add	r10, r24
    53d4:	b9 1e       	adc	r11, r25

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    53d6:	88 24       	eor	r8, r8
    53d8:	68 94       	set
    53da:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    53dc:	0f 2e       	mov	r0, r31
    53de:	f6 ed       	ldi	r31, 0xD6	; 214
    53e0:	4f 2e       	mov	r4, r31
    53e2:	f1 e2       	ldi	r31, 0x21	; 33
    53e4:	5f 2e       	mov	r5, r31
    53e6:	f0 2d       	mov	r31, r0
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    53e8:	28 2e       	mov	r2, r24
    53ea:	99 2e       	mov	r9, r25
    53ec:	37 2c       	mov	r3, r7
    53ee:	6f 84       	ldd	r6, Y+15	; 0x0f
    53f0:	78 88       	ldd	r7, Y+16	; 0x10
    53f2:	04 c0       	rjmp	.+8      	; 0x53fc <writeFile+0x3d0>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    53f4:	cb 86       	std	Y+11, r12	; 0x0b
    53f6:	dc 86       	std	Y+12, r13	; 0x0c
    53f8:	ed 86       	std	Y+13, r14	; 0x0d
    53fa:	fe 86       	std	Y+14, r15	; 0x0e

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    53fc:	6b 85       	ldd	r22, Y+11	; 0x0b
    53fe:	7c 85       	ldd	r23, Y+12	; 0x0c
    5400:	8d 85       	ldd	r24, Y+13	; 0x0d
    5402:	9e 85       	ldd	r25, Y+14	; 0x0e
    5404:	0e 94 ce 21 	call	0x439c	; 0x439c <getFirstSector>
    5408:	6d 83       	std	Y+5, r22	; 0x05
    540a:	7e 83       	std	Y+6, r23	; 0x06
    540c:	8f 83       	std	Y+7, r24	; 0x07
    540e:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    5410:	80 91 7b 50 	lds	r24, 0x507B
    5414:	90 91 7c 50 	lds	r25, 0x507C
    5418:	00 97       	sbiw	r24, 0x00	; 0
    541a:	09 f4       	brne	.+2      	; 0x541e <writeFile+0x3f2>
    541c:	77 c0       	rjmp	.+238    	; 0x550c <writeFile+0x4e0>
    541e:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    5420:	cd 80       	ldd	r12, Y+5	; 0x05
    5422:	de 80       	ldd	r13, Y+6	; 0x06
    5424:	ef 80       	ldd	r14, Y+7	; 0x07
    5426:	f8 84       	ldd	r15, Y+8	; 0x08
    5428:	19 81       	ldd	r17, Y+1	; 0x01
    542a:	c1 0e       	add	r12, r17
    542c:	d1 1c       	adc	r13, r1
    542e:	e1 1c       	adc	r14, r1
    5430:	f1 1c       	adc	r15, r1
    5432:	c7 01       	movw	r24, r14
    5434:	b6 01       	movw	r22, r12
    5436:	a2 01       	movw	r20, r4
    5438:	0e 94 de 2c 	call	0x59bc	; 0x59bc <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    543c:	80 91 54 40 	lds	r24, 0x4054
    5440:	90 91 55 40 	lds	r25, 0x4055
    5444:	00 97       	sbiw	r24, 0x00	; 0
    5446:	09 f4       	brne	.+2      	; 0x544a <writeFile+0x41e>
    5448:	54 c0       	rjmp	.+168    	; 0x54f2 <writeFile+0x4c6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    544a:	33 20       	and	r3, r3
    544c:	09 f0       	breq	.+2      	; 0x5450 <writeFile+0x424>
    544e:	a1 c0       	rjmp	.+322    	; 0x5592 <writeFile+0x566>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    5450:	a2 01       	movw	r20, r4
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    5452:	00 e0       	ldi	r16, 0x00	; 0
    5454:	10 e0       	ldi	r17, 0x00	; 0
    5456:	06 c0       	rjmp	.+12     	; 0x5464 <writeFile+0x438>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    5458:	a8 01       	movw	r20, r16
    545a:	4a 52       	subi	r20, 0x2A	; 42
    545c:	5e 4d       	sbci	r21, 0xDE	; 222
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    545e:	22 23       	and	r18, r18
    5460:	09 f0       	breq	.+2      	; 0x5464 <writeFile+0x438>
    5462:	99 c0       	rjmp	.+306    	; 0x5596 <writeFile+0x56a>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    5464:	da 01       	movw	r26, r20
    5466:	8c 91       	ld	r24, X
    5468:	88 23       	and	r24, r24
    546a:	21 f4       	brne	.+8      	; 0x5474 <writeFile+0x448>
    546c:	e2 2d       	mov	r30, r2
    546e:	f9 2d       	mov	r31, r9
    5470:	da 01       	movw	r26, r20
    5472:	04 c0       	rjmp	.+8      	; 0x547c <writeFile+0x450>
    5474:	85 3e       	cpi	r24, 0xE5	; 229
    5476:	d1 f3       	breq	.-12     	; 0x546c <writeFile+0x440>
    5478:	23 2d       	mov	r18, r3
    547a:	30 c0       	rjmp	.+96     	; 0x54dc <writeFile+0x4b0>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
    547c:	81 91       	ld	r24, Z+
    547e:	8d 93       	st	X+, r24
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    5480:	ea 15       	cp	r30, r10
    5482:	fb 05       	cpc	r31, r11
    5484:	d9 f7       	brne	.-10     	; 0x547c <writeFile+0x450>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    5486:	fa 01       	movw	r30, r20
    5488:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    548a:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    548c:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    548e:	12 8a       	std	Z+18, r1	; 0x12
    5490:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    5492:	29 85       	ldd	r18, Y+9	; 0x09
    5494:	3a 85       	ldd	r19, Y+10	; 0x0a
    5496:	24 8b       	std	Z+20, r18	; 0x14
    5498:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    549a:	62 8e       	std	Z+26, r6	; 0x1a
    549c:	73 8e       	std	Z+27, r7	; 0x1b
		  dir->fileSize = fileSize;
    549e:	80 91 50 40 	lds	r24, 0x4050
    54a2:	90 91 51 40 	lds	r25, 0x4051
    54a6:	a0 91 52 40 	lds	r26, 0x4052
    54aa:	b0 91 53 40 	lds	r27, 0x4053
    54ae:	84 8f       	std	Z+28, r24	; 0x1c
    54b0:	95 8f       	std	Z+29, r25	; 0x1d
    54b2:	a6 8f       	std	Z+30, r26	; 0x1e
    54b4:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    54b6:	c7 01       	movw	r24, r14
    54b8:	b6 01       	movw	r22, r12
    54ba:	a2 01       	movw	r20, r4
    54bc:	20 e0       	ldi	r18, 0x00	; 0
    54be:	32 e0       	ldi	r19, 0x02	; 2
    54c0:	0e 94 29 2c 	call	0x5852	; 0x5852 <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    54c4:	40 91 50 40 	lds	r20, 0x4050
    54c8:	50 91 51 40 	lds	r21, 0x4051
    54cc:	60 91 52 40 	lds	r22, 0x4052
    54d0:	70 91 53 40 	lds	r23, 0x4053
    54d4:	81 e0       	ldi	r24, 0x01	; 1
    54d6:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    54da:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    54dc:	00 5e       	subi	r16, 0xE0	; 224
    54de:	1f 4f       	sbci	r17, 0xFF	; 255
    54e0:	80 91 54 40 	lds	r24, 0x4054
    54e4:	90 91 55 40 	lds	r25, 0x4055
    54e8:	08 17       	cp	r16, r24
    54ea:	19 07       	cpc	r17, r25
    54ec:	08 f4       	brcc	.+2      	; 0x54f0 <writeFile+0x4c4>
    54ee:	b4 cf       	rjmp	.-152    	; 0x5458 <writeFile+0x42c>
    54f0:	32 2e       	mov	r3, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    54f2:	09 81       	ldd	r16, Y+1	; 0x01
    54f4:	0f 5f       	subi	r16, 0xFF	; 255
    54f6:	09 83       	std	Y+1, r16	; 0x01
    54f8:	20 91 7b 50 	lds	r18, 0x507B
    54fc:	30 91 7c 50 	lds	r19, 0x507C
    5500:	80 2f       	mov	r24, r16
    5502:	90 e0       	ldi	r25, 0x00	; 0
    5504:	82 17       	cp	r24, r18
    5506:	93 07       	cpc	r25, r19
    5508:	08 f4       	brcc	.+2      	; 0x550c <writeFile+0x4e0>
    550a:	8a cf       	rjmp	.-236    	; 0x5420 <writeFile+0x3f4>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    550c:	6b 85       	ldd	r22, Y+11	; 0x0b
    550e:	7c 85       	ldd	r23, Y+12	; 0x0c
    5510:	8d 85       	ldd	r24, Y+13	; 0x0d
    5512:	9e 85       	ldd	r25, Y+14	; 0x0e
    5514:	40 e0       	ldi	r20, 0x00	; 0
    5516:	00 e0       	ldi	r16, 0x00	; 0
    5518:	10 e0       	ldi	r17, 0x00	; 0
    551a:	98 01       	movw	r18, r16
    551c:	0e 94 f5 21 	call	0x43ea	; 0x43ea <getSetNextCluster>
    5520:	6b 01       	movw	r12, r22
    5522:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    5524:	67 3f       	cpi	r22, 0xF7	; 247
    5526:	1f ef       	ldi	r17, 0xFF	; 255
    5528:	71 07       	cpc	r23, r17
    552a:	1f ef       	ldi	r17, 0xFF	; 255
    552c:	81 07       	cpc	r24, r17
    552e:	1f e0       	ldi	r17, 0x0F	; 15
    5530:	91 07       	cpc	r25, r17
    5532:	08 f1       	brcs	.+66     	; 0x5576 <writeFile+0x54a>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    5534:	6f 3f       	cpi	r22, 0xFF	; 255
    5536:	2f ef       	ldi	r18, 0xFF	; 255
    5538:	72 07       	cpc	r23, r18
    553a:	2f ef       	ldi	r18, 0xFF	; 255
    553c:	82 07       	cpc	r24, r18
    553e:	2f ef       	ldi	r18, 0xFF	; 255
    5540:	92 07       	cpc	r25, r18
    5542:	59 f5       	brne	.+86     	; 0x559a <writeFile+0x56e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    5544:	6b 85       	ldd	r22, Y+11	; 0x0b
    5546:	7c 85       	ldd	r23, Y+12	; 0x0c
    5548:	8d 85       	ldd	r24, Y+13	; 0x0d
    554a:	9e 85       	ldd	r25, Y+14	; 0x0e
    554c:	0e 94 d3 24 	call	0x49a6	; 0x49a6 <searchNextFreeCluster>
    5550:	6b 01       	movw	r12, r22
    5552:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    5554:	6b 85       	ldd	r22, Y+11	; 0x0b
    5556:	7c 85       	ldd	r23, Y+12	; 0x0c
    5558:	8d 85       	ldd	r24, Y+13	; 0x0d
    555a:	9e 85       	ldd	r25, Y+14	; 0x0e
    555c:	41 e0       	ldi	r20, 0x01	; 1
    555e:	97 01       	movw	r18, r14
    5560:	86 01       	movw	r16, r12
    5562:	0e 94 f5 21 	call	0x43ea	; 0x43ea <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    5566:	c7 01       	movw	r24, r14
    5568:	b6 01       	movw	r22, r12
    556a:	41 e0       	ldi	r20, 0x01	; 1
    556c:	0f ef       	ldi	r16, 0xFF	; 255
    556e:	1f ef       	ldi	r17, 0xFF	; 255
    5570:	98 01       	movw	r18, r16
    5572:	0e 94 f5 21 	call	0x43ea	; 0x43ea <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    5576:	c1 14       	cp	r12, r1
    5578:	d1 04       	cpc	r13, r1
    557a:	e1 04       	cpc	r14, r1
    557c:	f1 04       	cpc	r15, r1
    557e:	09 f0       	breq	.+2      	; 0x5582 <writeFile+0x556>
    5580:	39 cf       	rjmp	.-398    	; 0x53f4 <writeFile+0x3c8>
	   return 4;
    5582:	84 e0       	ldi	r24, 0x04	; 4
    5584:	0b c0       	rjmp	.+22     	; 0x559c <writeFile+0x570>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    5586:	81 e0       	ldi	r24, 0x01	; 1
    5588:	09 c0       	rjmp	.+18     	; 0x559c <writeFile+0x570>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    558a:	82 e0       	ldi	r24, 0x02	; 2
    558c:	07 c0       	rjmp	.+14     	; 0x559c <writeFile+0x570>
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
		if(cluster == 0){
		  //No free cluster!
		  return 2;
    558e:	82 e0       	ldi	r24, 0x02	; 2
    5590:	05 c0       	rjmp	.+10     	; 0x559c <writeFile+0x570>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    5592:	80 e0       	ldi	r24, 0x00	; 0
    5594:	03 c0       	rjmp	.+6      	; 0x559c <writeFile+0x570>
    5596:	80 e0       	ldi	r24, 0x00	; 0
    5598:	01 c0       	rjmp	.+2      	; 0x559c <writeFile+0x570>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    559a:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    559c:	60 96       	adiw	r28, 0x10	; 16
    559e:	cd bf       	out	0x3d, r28	; 61
    55a0:	de bf       	out	0x3e, r29	; 62
    55a2:	df 91       	pop	r29
    55a4:	cf 91       	pop	r28
    55a6:	1f 91       	pop	r17
    55a8:	0f 91       	pop	r16
    55aa:	ff 90       	pop	r15
    55ac:	ef 90       	pop	r14
    55ae:	df 90       	pop	r13
    55b0:	cf 90       	pop	r12
    55b2:	bf 90       	pop	r11
    55b4:	af 90       	pop	r10
    55b6:	9f 90       	pop	r9
    55b8:	8f 90       	pop	r8
    55ba:	7f 90       	pop	r7
    55bc:	6f 90       	pop	r6
    55be:	5f 90       	pop	r5
    55c0:	4f 90       	pop	r4
    55c2:	3f 90       	pop	r3
    55c4:	2f 90       	pop	r2
    55c6:	08 95       	ret

000055c8 <SPI_write>:
}	

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
    55c8:	e0 ec       	ldi	r30, 0xC0	; 192
    55ca:	f8 e0       	ldi	r31, 0x08	; 8
    55cc:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    55ce:	82 81       	ldd	r24, Z+2	; 0x02
    55d0:	88 23       	and	r24, r24
    55d2:	ec f7       	brge	.-6      	; 0x55ce <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
    55d4:	e0 ec       	ldi	r30, 0xC0	; 192
    55d6:	f8 e0       	ldi	r31, 0x08	; 8
    55d8:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
}
    55da:	08 95       	ret

000055dc <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    55dc:	8f 92       	push	r8
    55de:	9f 92       	push	r9
    55e0:	af 92       	push	r10
    55e2:	bf 92       	push	r11
    55e4:	cf 92       	push	r12
    55e6:	df 92       	push	r13
    55e8:	ef 92       	push	r14
    55ea:	ff 92       	push	r15
    55ec:	0f 93       	push	r16
    55ee:	1f 93       	push	r17
    55f0:	cf 93       	push	r28
    55f2:	df 93       	push	r29
    55f4:	84 2e       	mov	r8, r20
    55f6:	a5 2e       	mov	r10, r21
    55f8:	c6 2e       	mov	r12, r22
    55fa:	c7 2f       	mov	r28, r23
    55fc:	d2 2f       	mov	r29, r18
    55fe:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    5600:	80 64       	ori	r24, 0x40	; 64
    5602:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    5606:	8c 2f       	mov	r24, r28
    5608:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    560c:	8c 2d       	mov	r24, r12
    560e:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    5612:	8a 2d       	mov	r24, r10
    5614:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    5618:	88 2d       	mov	r24, r8
    561a:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
	SPI_write(crc);
    561e:	8d 2f       	mov	r24, r29
    5620:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
	
	for(int i=0; i<read; i++){
    5624:	10 16       	cp	r1, r16
    5626:	11 06       	cpc	r1, r17
    5628:	64 f5       	brge	.+88     	; 0x5682 <SD_command+0xa6>
    562a:	00 e0       	ldi	r16, 0x00	; 0
    562c:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    562e:	0f 2e       	mov	r0, r31
    5630:	fd e0       	ldi	r31, 0x0D	; 13
    5632:	cf 2e       	mov	r12, r31
    5634:	dd 24       	eor	r13, r13
    5636:	f0 2d       	mov	r31, r0
    5638:	0f 2e       	mov	r0, r31
    563a:	f6 ea       	ldi	r31, 0xA6	; 166
    563c:	af 2e       	mov	r10, r31
    563e:	f0 e5       	ldi	r31, 0x50	; 80
    5640:	bf 2e       	mov	r11, r31
    5642:	f0 2d       	mov	r31, r0
    5644:	c8 01       	movw	r24, r16
    5646:	b6 01       	movw	r22, r12
    5648:	0e 94 b7 3a 	call	0x756e	; 0x756e <__divmodhi4>
    564c:	ec 01       	movw	r28, r24
    564e:	8f ef       	ldi	r24, 0xFF	; 255
    5650:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5654:	f5 01       	movw	r30, r10
    5656:	ec 0f       	add	r30, r28
    5658:	fd 1f       	adc	r31, r29
    565a:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    565c:	80 81       	ld	r24, Z
    565e:	8f 3f       	cpi	r24, 0xFF	; 255
    5660:	49 f0       	breq	.+18     	; 0x5674 <SD_command+0x98>
			Buffer[1] = Buffer[i%13];
    5662:	fe 01       	movw	r30, r28
    5664:	ea 55       	subi	r30, 0x5A	; 90
    5666:	ff 4a       	sbci	r31, 0xAF	; 175
    5668:	80 81       	ld	r24, Z
    566a:	80 93 a7 50 	sts	0x50A7, r24
			return Buffer[1];
    566e:	80 91 a7 50 	lds	r24, 0x50A7
    5672:	08 c0       	rjmp	.+16     	; 0x5684 <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    5674:	0f 5f       	subi	r16, 0xFF	; 255
    5676:	1f 4f       	sbci	r17, 0xFF	; 255
    5678:	0e 15       	cp	r16, r14
    567a:	1f 05       	cpc	r17, r15
    567c:	19 f7       	brne	.-58     	; 0x5644 <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    567e:	8f ef       	ldi	r24, 0xFF	; 255
    5680:	01 c0       	rjmp	.+2      	; 0x5684 <SD_command+0xa8>
    5682:	8f ef       	ldi	r24, 0xFF	; 255
}
    5684:	df 91       	pop	r29
    5686:	cf 91       	pop	r28
    5688:	1f 91       	pop	r17
    568a:	0f 91       	pop	r16
    568c:	ff 90       	pop	r15
    568e:	ef 90       	pop	r14
    5690:	df 90       	pop	r13
    5692:	cf 90       	pop	r12
    5694:	bf 90       	pop	r11
    5696:	af 90       	pop	r10
    5698:	9f 90       	pop	r9
    569a:	8f 90       	pop	r8
    569c:	08 95       	ret

0000569e <SD_init>:
# include "SD_Card.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    569e:	ff 92       	push	r15
    56a0:	0f 93       	push	r16
    56a2:	1f 93       	push	r17
    56a4:	cf 93       	push	r28
    56a6:	df 93       	push	r29
	ADCPower(TRUE);				//power up portEX
    56a8:	81 e0       	ldi	r24, 0x01	; 1
    56aa:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    56ae:	81 e0       	ldi	r24, 0x01	; 1
    56b0:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <Ext1Power>
    56b4:	8f ef       	ldi	r24, 0xFF	; 255
    56b6:	93 ec       	ldi	r25, 0xC3	; 195
    56b8:	a9 e0       	ldi	r26, 0x09	; 9
    56ba:	81 50       	subi	r24, 0x01	; 1
    56bc:	90 40       	sbci	r25, 0x00	; 0
    56be:	a0 40       	sbci	r26, 0x00	; 0
    56c0:	e1 f7       	brne	.-8      	; 0x56ba <SD_init+0x1c>
    56c2:	00 c0       	rjmp	.+0      	; 0x56c4 <SD_init+0x26>
    56c4:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    56c6:	88 e0       	ldi	r24, 0x08	; 8
    56c8:	60 e0       	ldi	r22, 0x00	; 0
    56ca:	0e 94 e9 1e 	call	0x3dd2	; 0x3dd2 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    56ce:	88 e0       	ldi	r24, 0x08	; 8
    56d0:	60 e0       	ldi	r22, 0x00	; 0
    56d2:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    56d6:	80 e0       	ldi	r24, 0x00	; 0
    56d8:	63 e0       	ldi	r22, 0x03	; 3
    56da:	0e 94 bd 1d 	call	0x3b7a	; 0x3b7a <SPIInit2>
	SPICS(TRUE);
    56de:	81 e0       	ldi	r24, 0x01	; 1
    56e0:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
    56e4:	8a e0       	ldi	r24, 0x0A	; 10
    56e6:	90 e0       	ldi	r25, 0x00	; 0
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
		SPIC.DATA=SDHC_DUMMY_BYTE;
    56e8:	e0 ec       	ldi	r30, 0xC0	; 192
    56ea:	f8 e0       	ldi	r31, 0x08	; 8
    56ec:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    56ee:	a2 eb       	ldi	r26, 0xB2	; 178
    56f0:	b0 e5       	ldi	r27, 0x50	; 80

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
		SPIC.DATA=SDHC_DUMMY_BYTE;
    56f2:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    56f4:	22 81       	ldd	r18, Z+2	; 0x02
    56f6:	22 23       	and	r18, r18
    56f8:	ec f7       	brge	.-6      	; 0x56f4 <SD_init+0x56>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    56fa:	23 81       	ldd	r18, Z+3	; 0x03
    56fc:	2c 93       	st	X, r18
    56fe:	01 97       	sbiw	r24, 0x01	; 1
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    5700:	c1 f7       	brne	.-16     	; 0x56f2 <SD_init+0x54>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    5702:	80 e0       	ldi	r24, 0x00	; 0
    5704:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	SPIDisable();
    5708:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    570c:	88 e0       	ldi	r24, 0x08	; 8
    570e:	60 e0       	ldi	r22, 0x00	; 0
    5710:	0e 94 e5 1d 	call	0x3bca	; 0x3bca <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5714:	80 e0       	ldi	r24, 0x00	; 0
    5716:	63 e0       	ldi	r22, 0x03	; 3
    5718:	0e 94 bd 1d 	call	0x3b7a	; 0x3b7a <SPIInit2>
	SPICS(TRUE);
    571c:	81 e0       	ldi	r24, 0x01	; 1
    571e:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    5722:	cb e0       	ldi	r28, 0x0B	; 11
    5724:	d0 e0       	ldi	r29, 0x00	; 0
    5726:	02 c0       	rjmp	.+4      	; 0x572c <SD_init+0x8e>
    5728:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {												//try command 10 times before timing out
    572a:	69 f0       	breq	.+26     	; 0x5746 <SD_init+0xa8>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    572c:	80 e0       	ldi	r24, 0x00	; 0
    572e:	40 e0       	ldi	r20, 0x00	; 0
    5730:	50 e0       	ldi	r21, 0x00	; 0
    5732:	ba 01       	movw	r22, r20
    5734:	25 e9       	ldi	r18, 0x95	; 149
    5736:	08 e0       	ldi	r16, 0x08	; 8
    5738:	10 e0       	ldi	r17, 0x00	; 0
    573a:	0e 94 ee 2a 	call	0x55dc	; 0x55dc <SD_command>
    573e:	81 30       	cpi	r24, 0x01	; 1
    5740:	99 f7       	brne	.-26     	; 0x5728 <SD_init+0x8a>
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    5742:	ff 24       	eor	r15, r15
    5744:	02 c0       	rjmp	.+4      	; 0x574a <SD_init+0xac>
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
		if (i >= 10) {												//try command 10 times before timing out
			//there was no response to the first command
			errorCode = 1;
    5746:	ff 24       	eor	r15, r15
    5748:	f3 94       	inc	r15
    574a:	8f ef       	ldi	r24, 0xFF	; 255
    574c:	93 ec       	ldi	r25, 0xC3	; 195
    574e:	a9 e0       	ldi	r26, 0x09	; 9
    5750:	81 50       	subi	r24, 0x01	; 1
    5752:	90 40       	sbci	r25, 0x00	; 0
    5754:	a0 40       	sbci	r26, 0x00	; 0
    5756:	e1 f7       	brne	.-8      	; 0x5750 <SD_init+0xb2>
    5758:	00 c0       	rjmp	.+0      	; 0x575a <SD_init+0xbc>
    575a:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    575c:	cb e0       	ldi	r28, 0x0B	; 11
    575e:	d0 e0       	ldi	r29, 0x00	; 0
    5760:	02 c0       	rjmp	.+4      	; 0x5766 <SD_init+0xc8>
    5762:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    5764:	69 f0       	breq	.+26     	; 0x5780 <SD_init+0xe2>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    5766:	88 e0       	ldi	r24, 0x08	; 8
    5768:	4a ea       	ldi	r20, 0xAA	; 170
    576a:	51 e0       	ldi	r21, 0x01	; 1
    576c:	60 e0       	ldi	r22, 0x00	; 0
    576e:	70 e0       	ldi	r23, 0x00	; 0
    5770:	27 e8       	ldi	r18, 0x87	; 135
    5772:	08 e0       	ldi	r16, 0x08	; 8
    5774:	10 e0       	ldi	r17, 0x00	; 0
    5776:	0e 94 ee 2a 	call	0x55dc	; 0x55dc <SD_command>
    577a:	81 30       	cpi	r24, 0x01	; 1
    577c:	91 f7       	brne	.-28     	; 0x5762 <SD_init+0xc4>
    577e:	02 c0       	rjmp	.+4      	; 0x5784 <SD_init+0xe6>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    5780:	ff 24       	eor	r15, r15
    5782:	f3 94       	inc	r15
    5784:	c2 e0       	ldi	r28, 0x02	; 2
    5786:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}			
	}		
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    5788:	06 ea       	ldi	r16, 0xA6	; 166
    578a:	10 e5       	ldi	r17, 0x50	; 80
    578c:	8f ef       	ldi	r24, 0xFF	; 255
    578e:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5792:	f8 01       	movw	r30, r16
    5794:	ec 0f       	add	r30, r28
    5796:	fd 1f       	adc	r31, r29
    5798:	80 83       	st	Z, r24
    579a:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    579c:	c6 30       	cpi	r28, 0x06	; 6
    579e:	d1 05       	cpc	r29, r1
    57a0:	a9 f7       	brne	.-22     	; 0x578c <SD_init+0xee>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    57a2:	80 91 aa 50 	lds	r24, 0x50AA
    57a6:	81 30       	cpi	r24, 0x01	; 1
    57a8:	29 f4       	brne	.+10     	; 0x57b4 <SD_init+0x116>
    57aa:	80 91 ab 50 	lds	r24, 0x50AB
    57ae:	8a 3a       	cpi	r24, 0xAA	; 170
    57b0:	21 f4       	brne	.+8      	; 0x57ba <SD_init+0x11c>
    57b2:	05 c0       	rjmp	.+10     	; 0x57be <SD_init+0x120>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    57b4:	ff 24       	eor	r15, r15
    57b6:	f3 94       	inc	r15
    57b8:	02 c0       	rjmp	.+4      	; 0x57be <SD_init+0x120>
    57ba:	ff 24       	eor	r15, r15
    57bc:	f3 94       	inc	r15
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
    57be:	c7 ea       	ldi	r28, 0xA7	; 167
    57c0:	d0 e5       	ldi	r29, 0x50	; 80
		//broken card or voltage out of operating range bounds
		errorCode = 1;
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    57c2:	87 e3       	ldi	r24, 0x37	; 55
    57c4:	40 e0       	ldi	r20, 0x00	; 0
    57c6:	50 e0       	ldi	r21, 0x00	; 0
    57c8:	ba 01       	movw	r22, r20
    57ca:	2f ef       	ldi	r18, 0xFF	; 255
    57cc:	08 e0       	ldi	r16, 0x08	; 8
    57ce:	10 e0       	ldi	r17, 0x00	; 0
    57d0:	0e 94 ee 2a 	call	0x55dc	; 0x55dc <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    57d4:	81 e0       	ldi	r24, 0x01	; 1
    57d6:	40 e0       	ldi	r20, 0x00	; 0
    57d8:	50 e0       	ldi	r21, 0x00	; 0
    57da:	60 e0       	ldi	r22, 0x00	; 0
    57dc:	70 e4       	ldi	r23, 0x40	; 64
    57de:	2f ef       	ldi	r18, 0xFF	; 255
    57e0:	0e 94 ee 2a 	call	0x55dc	; 0x55dc <SD_command>
	} while(Buffer[1]!= 0x00);
    57e4:	88 81       	ld	r24, Y
    57e6:	88 23       	and	r24, r24
    57e8:	61 f7       	brne	.-40     	; 0x57c2 <SD_init+0x124>
    57ea:	cb e0       	ldi	r28, 0x0B	; 11
    57ec:	d0 e0       	ldi	r29, 0x00	; 0
    57ee:	02 c0       	rjmp	.+4      	; 0x57f4 <SD_init+0x156>
    57f0:	21 97       	sbiw	r28, 0x01	; 1
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
		if (i >= 10) {
    57f2:	61 f0       	breq	.+24     	; 0x580c <SD_init+0x16e>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    57f4:	8a e3       	ldi	r24, 0x3A	; 58
    57f6:	40 e0       	ldi	r20, 0x00	; 0
    57f8:	50 e0       	ldi	r21, 0x00	; 0
    57fa:	ba 01       	movw	r22, r20
    57fc:	2f ef       	ldi	r18, 0xFF	; 255
    57fe:	08 e0       	ldi	r16, 0x08	; 8
    5800:	10 e0       	ldi	r17, 0x00	; 0
    5802:	0e 94 ee 2a 	call	0x55dc	; 0x55dc <SD_command>
    5806:	88 23       	and	r24, r24
    5808:	99 f7       	brne	.-26     	; 0x57f0 <SD_init+0x152>
    580a:	02 c0       	rjmp	.+4      	; 0x5810 <SD_init+0x172>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    580c:	ff 24       	eor	r15, r15
    580e:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5810:	c0 e0       	ldi	r28, 0x00	; 0
    5812:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    5814:	06 ea       	ldi	r16, 0xA6	; 166
    5816:	10 e5       	ldi	r17, 0x50	; 80
    5818:	8f ef       	ldi	r24, 0xFF	; 255
    581a:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    581e:	f8 01       	movw	r30, r16
    5820:	ec 0f       	add	r30, r28
    5822:	fd 1f       	adc	r31, r29
    5824:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5826:	21 96       	adiw	r28, 0x01	; 1
    5828:	c4 30       	cpi	r28, 0x04	; 4
    582a:	d1 05       	cpc	r29, r1
    582c:	a9 f7       	brne	.-22     	; 0x5818 <SD_init+0x17a>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    582e:	80 91 a6 50 	lds	r24, 0x50A6
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    5832:	80 e0       	ldi	r24, 0x00	; 0
    5834:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	SPIDisable();
    5838:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    583c:	88 e0       	ldi	r24, 0x08	; 8
    583e:	60 e0       	ldi	r22, 0x00	; 0
    5840:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <PortEx_OUTSET>
	return errorCode;	
}	
    5844:	8f 2d       	mov	r24, r15
    5846:	df 91       	pop	r29
    5848:	cf 91       	pop	r28
    584a:	1f 91       	pop	r17
    584c:	0f 91       	pop	r16
    584e:	ff 90       	pop	r15
    5850:	08 95       	ret

00005852 <SD_write_block>:
	}
	return SDHC_DUMMY_BYTE;
}

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    5852:	6f 92       	push	r6
    5854:	7f 92       	push	r7
    5856:	8f 92       	push	r8
    5858:	9f 92       	push	r9
    585a:	af 92       	push	r10
    585c:	bf 92       	push	r11
    585e:	cf 92       	push	r12
    5860:	df 92       	push	r13
    5862:	ef 92       	push	r14
    5864:	ff 92       	push	r15
    5866:	0f 93       	push	r16
    5868:	1f 93       	push	r17
    586a:	cf 93       	push	r28
    586c:	df 93       	push	r29
    586e:	4b 01       	movw	r8, r22
    5870:	5c 01       	movw	r10, r24
    5872:	74 2e       	mov	r7, r20
    5874:	65 2e       	mov	r6, r21
    5876:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5878:	88 e0       	ldi	r24, 0x08	; 8
    587a:	60 e0       	ldi	r22, 0x00	; 0
    587c:	0e 94 e5 1d 	call	0x3bca	; 0x3bca <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5880:	80 e0       	ldi	r24, 0x00	; 0
    5882:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <SPIInit>
	SPICS(TRUE);
    5886:	81 e0       	ldi	r24, 0x01	; 1
    5888:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    588c:	80 e0       	ldi	r24, 0x00	; 0
    588e:	92 e0       	ldi	r25, 0x02	; 2
    5890:	7c 01       	movw	r14, r24
    5892:	ec 18       	sub	r14, r12
    5894:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5896:	80 e0       	ldi	r24, 0x00	; 0
    5898:	e8 16       	cp	r14, r24
    589a:	82 e0       	ldi	r24, 0x02	; 2
    589c:	f8 06       	cpc	r15, r24
    589e:	11 f4       	brne	.+4      	; 0x58a4 <SD_write_block+0x52>
    58a0:	ee 24       	eor	r14, r14
    58a2:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    58a4:	cb e0       	ldi	r28, 0x0B	; 11
    58a6:	d0 e0       	ldi	r29, 0x00	; 0
    58a8:	03 c0       	rjmp	.+6      	; 0x58b0 <SD_write_block+0x5e>
    58aa:	21 97       	sbiw	r28, 0x01	; 1
	if (i >= 10) {
    58ac:	09 f4       	brne	.+2      	; 0x58b0 <SD_write_block+0x5e>
    58ae:	ff cf       	rjmp	.-2      	; 0x58ae <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    58b0:	88 e1       	ldi	r24, 0x18	; 24
    58b2:	b5 01       	movw	r22, r10
    58b4:	a4 01       	movw	r20, r8
    58b6:	2f ef       	ldi	r18, 0xFF	; 255
    58b8:	08 e0       	ldi	r16, 0x08	; 8
    58ba:	10 e0       	ldi	r17, 0x00	; 0
    58bc:	0e 94 ee 2a 	call	0x55dc	; 0x55dc <SD_command>
    58c0:	88 23       	and	r24, r24
    58c2:	99 f7       	brne	.-26     	; 0x58aa <SD_write_block+0x58>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    58c4:	8f ef       	ldi	r24, 0xFF	; 255
    58c6:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    58ca:	80 93 a6 50 	sts	0x50A6, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    58ce:	8e ef       	ldi	r24, 0xFE	; 254
    58d0:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    58d4:	1c 14       	cp	r1, r12
    58d6:	1d 04       	cpc	r1, r13
    58d8:	bc f4       	brge	.+46     	; 0x5908 <SD_write_block+0xb6>
    58da:	87 2c       	mov	r8, r7
    58dc:	96 2c       	mov	r9, r6
    58de:	00 e0       	ldi	r16, 0x00	; 0
    58e0:	10 e0       	ldi	r17, 0x00	; 0
Buffer[i%13] = SPI_write(data[i]);
    58e2:	c8 01       	movw	r24, r16
    58e4:	6d e0       	ldi	r22, 0x0D	; 13
    58e6:	70 e0       	ldi	r23, 0x00	; 0
    58e8:	0e 94 b7 3a 	call	0x756e	; 0x756e <__divmodhi4>
    58ec:	ec 01       	movw	r28, r24
    58ee:	f4 01       	movw	r30, r8
    58f0:	81 91       	ld	r24, Z+
    58f2:	4f 01       	movw	r8, r30
    58f4:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    58f8:	ca 55       	subi	r28, 0x5A	; 90
    58fa:	df 4a       	sbci	r29, 0xAF	; 175
    58fc:	88 83       	st	Y, r24
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    58fe:	0f 5f       	subi	r16, 0xFF	; 255
    5900:	1f 4f       	sbci	r17, 0xFF	; 255
    5902:	0c 15       	cp	r16, r12
    5904:	1d 05       	cpc	r17, r13
    5906:	69 f7       	brne	.-38     	; 0x58e2 <SD_write_block+0x90>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5908:	1e 14       	cp	r1, r14
    590a:	1f 04       	cpc	r1, r15
    590c:	ec f4       	brge	.+58     	; 0x5948 <SD_write_block+0xf6>
    590e:	00 e0       	ldi	r16, 0x00	; 0
    5910:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    5912:	0f 2e       	mov	r0, r31
    5914:	fd e0       	ldi	r31, 0x0D	; 13
    5916:	cf 2e       	mov	r12, r31
    5918:	dd 24       	eor	r13, r13
    591a:	f0 2d       	mov	r31, r0
    591c:	0f 2e       	mov	r0, r31
    591e:	f6 ea       	ldi	r31, 0xA6	; 166
    5920:	8f 2e       	mov	r8, r31
    5922:	f0 e5       	ldi	r31, 0x50	; 80
    5924:	9f 2e       	mov	r9, r31
    5926:	f0 2d       	mov	r31, r0
    5928:	c8 01       	movw	r24, r16
    592a:	b6 01       	movw	r22, r12
    592c:	0e 94 b7 3a 	call	0x756e	; 0x756e <__divmodhi4>
    5930:	ec 01       	movw	r28, r24
    5932:	80 e0       	ldi	r24, 0x00	; 0
    5934:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5938:	c8 0d       	add	r28, r8
    593a:	d9 1d       	adc	r29, r9
    593c:	88 83       	st	Y, r24
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    593e:	0f 5f       	subi	r16, 0xFF	; 255
    5940:	1f 4f       	sbci	r17, 0xFF	; 255
    5942:	0e 15       	cp	r16, r14
    5944:	1f 05       	cpc	r17, r15
    5946:	81 f7       	brne	.-32     	; 0x5928 <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    5948:	8f ef       	ldi	r24, 0xFF	; 255
    594a:	80 93 a6 50 	sts	0x50A6, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    594e:	c0 e0       	ldi	r28, 0x00	; 0
    5950:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    5952:	06 ea       	ldi	r16, 0xA6	; 166
    5954:	10 e5       	ldi	r17, 0x50	; 80
    5956:	8f ef       	ldi	r24, 0xFF	; 255
    5958:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    595c:	f8 01       	movw	r30, r16
    595e:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    5960:	21 96       	adiw	r28, 0x01	; 1
    5962:	c2 30       	cpi	r28, 0x02	; 2
    5964:	d1 05       	cpc	r29, r1
    5966:	bc f3       	brlt	.-18     	; 0x5956 <SD_write_block+0x104>
    5968:	80 81       	ld	r24, Z
    596a:	8f 3f       	cpi	r24, 0xFF	; 255
    596c:	a1 f3       	breq	.-24     	; 0x5956 <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    596e:	80 91 a6 50 	lds	r24, 0x50A6
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    5972:	80 91 a6 50 	lds	r24, 0x50A6
    5976:	8f 3f       	cpi	r24, 0xFF	; 255
    5978:	49 f0       	breq	.+18     	; 0x598c <SD_write_block+0x13a>
    597a:	c6 ea       	ldi	r28, 0xA6	; 166
    597c:	d0 e5       	ldi	r29, 0x50	; 80
    597e:	8f ef       	ldi	r24, 0xFF	; 255
    5980:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5984:	88 83       	st	Y, r24
    5986:	88 81       	ld	r24, Y
    5988:	8f 3f       	cpi	r24, 0xFF	; 255
    598a:	c9 f7       	brne	.-14     	; 0x597e <SD_write_block+0x12c>
	SPICS(FALSE);
    598c:	80 e0       	ldi	r24, 0x00	; 0
    598e:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	SPIDisable();
    5992:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    5996:	88 e0       	ldi	r24, 0x08	; 8
    5998:	60 e0       	ldi	r22, 0x00	; 0
    599a:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <PortEx_OUTSET>
}
    599e:	df 91       	pop	r29
    59a0:	cf 91       	pop	r28
    59a2:	1f 91       	pop	r17
    59a4:	0f 91       	pop	r16
    59a6:	ff 90       	pop	r15
    59a8:	ef 90       	pop	r14
    59aa:	df 90       	pop	r13
    59ac:	cf 90       	pop	r12
    59ae:	bf 90       	pop	r11
    59b0:	af 90       	pop	r10
    59b2:	9f 90       	pop	r9
    59b4:	8f 90       	pop	r8
    59b6:	7f 90       	pop	r7
    59b8:	6f 90       	pop	r6
    59ba:	08 95       	ret

000059bc <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    59bc:	af 92       	push	r10
    59be:	bf 92       	push	r11
    59c0:	cf 92       	push	r12
    59c2:	df 92       	push	r13
    59c4:	ef 92       	push	r14
    59c6:	ff 92       	push	r15
    59c8:	0f 93       	push	r16
    59ca:	1f 93       	push	r17
    59cc:	cf 93       	push	r28
    59ce:	df 93       	push	r29
    59d0:	6b 01       	movw	r12, r22
    59d2:	7c 01       	movw	r14, r24
    59d4:	b4 2e       	mov	r11, r20
    59d6:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    59d8:	88 e0       	ldi	r24, 0x08	; 8
    59da:	60 e0       	ldi	r22, 0x00	; 0
    59dc:	0e 94 e5 1d 	call	0x3bca	; 0x3bca <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    59e0:	80 e0       	ldi	r24, 0x00	; 0
    59e2:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <SPIInit>
	SPICS(TRUE);
    59e6:	81 e0       	ldi	r24, 0x01	; 1
    59e8:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    59ec:	cb e0       	ldi	r28, 0x0B	; 11
    59ee:	d0 e0       	ldi	r29, 0x00	; 0
    59f0:	03 c0       	rjmp	.+6      	; 0x59f8 <SD_read_block+0x3c>
    59f2:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    59f4:	09 f4       	brne	.+2      	; 0x59f8 <SD_read_block+0x3c>
    59f6:	ff cf       	rjmp	.-2      	; 0x59f6 <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    59f8:	81 e1       	ldi	r24, 0x11	; 17
    59fa:	b7 01       	movw	r22, r14
    59fc:	a6 01       	movw	r20, r12
    59fe:	2f ef       	ldi	r18, 0xFF	; 255
    5a00:	08 e0       	ldi	r16, 0x08	; 8
    5a02:	10 e0       	ldi	r17, 0x00	; 0
    5a04:	0e 94 ee 2a 	call	0x55dc	; 0x55dc <SD_command>
    5a08:	88 23       	and	r24, r24
    5a0a:	99 f7       	brne	.-26     	; 0x59f2 <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    5a0c:	80 91 a6 50 	lds	r24, 0x50A6
    5a10:	8e 3f       	cpi	r24, 0xFE	; 254
    5a12:	49 f0       	breq	.+18     	; 0x5a26 <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    5a14:	c6 ea       	ldi	r28, 0xA6	; 166
    5a16:	d0 e5       	ldi	r29, 0x50	; 80
    5a18:	8f ef       	ldi	r24, 0xFF	; 255
    5a1a:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5a1e:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    5a20:	88 81       	ld	r24, Y
    5a22:	8e 3f       	cpi	r24, 0xFE	; 254
    5a24:	c9 f7       	brne	.-14     	; 0x5a18 <SD_read_block+0x5c>
    5a26:	0b 2d       	mov	r16, r11
    5a28:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5a2a:	c0 e0       	ldi	r28, 0x00	; 0
    5a2c:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5a2e:	8f ef       	ldi	r24, 0xFF	; 255
    5a30:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5a34:	f8 01       	movw	r30, r16
    5a36:	81 93       	st	Z+, r24
    5a38:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5a3a:	21 96       	adiw	r28, 0x01	; 1
    5a3c:	f2 e0       	ldi	r31, 0x02	; 2
    5a3e:	c0 30       	cpi	r28, 0x00	; 0
    5a40:	df 07       	cpc	r29, r31
    5a42:	a9 f7       	brne	.-22     	; 0x5a2e <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    5a44:	10 92 b2 50 	sts	0x50B2, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    5a48:	80 91 b2 50 	lds	r24, 0x50B2
    5a4c:	8f 3f       	cpi	r24, 0xFF	; 255
    5a4e:	49 f0       	breq	.+18     	; 0x5a62 <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    5a50:	c2 eb       	ldi	r28, 0xB2	; 178
    5a52:	d0 e5       	ldi	r29, 0x50	; 80
    5a54:	8f ef       	ldi	r24, 0xFF	; 255
    5a56:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5a5a:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    5a5c:	88 81       	ld	r24, Y
    5a5e:	8f 3f       	cpi	r24, 0xFF	; 255
    5a60:	c9 f7       	brne	.-14     	; 0x5a54 <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    5a62:	80 e0       	ldi	r24, 0x00	; 0
    5a64:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	SPIDisable();
    5a68:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5a6c:	88 e0       	ldi	r24, 0x08	; 8
    5a6e:	60 e0       	ldi	r22, 0x00	; 0
    5a70:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <PortEx_OUTSET>
}
    5a74:	df 91       	pop	r29
    5a76:	cf 91       	pop	r28
    5a78:	1f 91       	pop	r17
    5a7a:	0f 91       	pop	r16
    5a7c:	ff 90       	pop	r15
    5a7e:	ef 90       	pop	r14
    5a80:	df 90       	pop	r13
    5a82:	cf 90       	pop	r12
    5a84:	bf 90       	pop	r11
    5a86:	af 90       	pop	r10
    5a88:	08 95       	ret

00005a8a <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5a8a:	2f 92       	push	r2
    5a8c:	3f 92       	push	r3
    5a8e:	4f 92       	push	r4
    5a90:	5f 92       	push	r5
    5a92:	6f 92       	push	r6
    5a94:	7f 92       	push	r7
    5a96:	8f 92       	push	r8
    5a98:	9f 92       	push	r9
    5a9a:	af 92       	push	r10
    5a9c:	bf 92       	push	r11
    5a9e:	cf 92       	push	r12
    5aa0:	df 92       	push	r13
    5aa2:	ef 92       	push	r14
    5aa4:	ff 92       	push	r15
    5aa6:	0f 93       	push	r16
    5aa8:	1f 93       	push	r17
    5aaa:	cf 93       	push	r28
    5aac:	df 93       	push	r29
    5aae:	cd b7       	in	r28, 0x3d	; 61
    5ab0:	de b7       	in	r29, 0x3e	; 62
    5ab2:	2a 97       	sbiw	r28, 0x0a	; 10
    5ab4:	cd bf       	out	0x3d, r28	; 61
    5ab6:	de bf       	out	0x3e, r29	; 62
    5ab8:	6b 01       	movw	r12, r22
    5aba:	7c 01       	movw	r14, r24
    5abc:	4f 83       	std	Y+7, r20	; 0x07
    5abe:	58 87       	std	Y+8, r21	; 0x08
    5ac0:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5ac2:	88 e0       	ldi	r24, 0x08	; 8
    5ac4:	60 e0       	ldi	r22, 0x00	; 0
    5ac6:	0e 94 e5 1d 	call	0x3bca	; 0x3bca <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5aca:	80 e0       	ldi	r24, 0x00	; 0
    5acc:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <SPIInit>
	SPICS(TRUE);
    5ad0:	81 e0       	ldi	r24, 0x01	; 1
    5ad2:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    5ad6:	c8 01       	movw	r24, r16
    5ad8:	11 23       	and	r17, r17
    5ada:	14 f4       	brge	.+4      	; 0x5ae0 <SD_write_multiple_blocks+0x56>
    5adc:	81 50       	subi	r24, 0x01	; 1
    5ade:	9e 4f       	sbci	r25, 0xFE	; 254
    5ae0:	9c 01       	movw	r18, r24
    5ae2:	23 2f       	mov	r18, r19
    5ae4:	33 0f       	add	r19, r19
    5ae6:	33 0b       	sbc	r19, r19
    5ae8:	25 95       	asr	r18
    5aea:	2b 83       	std	Y+3, r18	; 0x03
    5aec:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    5aee:	20 e0       	ldi	r18, 0x00	; 0
    5af0:	32 e0       	ldi	r19, 0x02	; 2
    5af2:	c8 01       	movw	r24, r16
    5af4:	b9 01       	movw	r22, r18
    5af6:	0e 94 b7 3a 	call	0x756e	; 0x756e <__divmodhi4>
    5afa:	29 01       	movw	r4, r18
    5afc:	48 1a       	sub	r4, r24
    5afe:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5b00:	30 e0       	ldi	r19, 0x00	; 0
    5b02:	43 16       	cp	r4, r19
    5b04:	32 e0       	ldi	r19, 0x02	; 2
    5b06:	53 06       	cpc	r5, r19
    5b08:	31 f0       	breq	.+12     	; 0x5b16 <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    5b0a:	8b 81       	ldd	r24, Y+3	; 0x03
    5b0c:	9c 81       	ldd	r25, Y+4	; 0x04
    5b0e:	01 96       	adiw	r24, 0x01	; 1
    5b10:	8b 83       	std	Y+3, r24	; 0x03
    5b12:	9c 83       	std	Y+4, r25	; 0x04
    5b14:	02 c0       	rjmp	.+4      	; 0x5b1a <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5b16:	44 24       	eor	r4, r4
    5b18:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    5b1a:	89 e1       	ldi	r24, 0x19	; 25
    5b1c:	b7 01       	movw	r22, r14
    5b1e:	a6 01       	movw	r20, r12
    5b20:	2f ef       	ldi	r18, 0xFF	; 255
    5b22:	08 e0       	ldi	r16, 0x08	; 8
    5b24:	10 e0       	ldi	r17, 0x00	; 0
    5b26:	0e 94 ee 2a 	call	0x55dc	; 0x55dc <SD_command>
    5b2a:	88 23       	and	r24, r24
    5b2c:	b1 f7       	brne	.-20     	; 0x5b1a <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    5b2e:	eb 81       	ldd	r30, Y+3	; 0x03
    5b30:	fc 81       	ldd	r31, Y+4	; 0x04
    5b32:	1e 16       	cp	r1, r30
    5b34:	1f 06       	cpc	r1, r31
    5b36:	0c f0       	brlt	.+2      	; 0x5b3a <SD_write_multiple_blocks+0xb0>
    5b38:	ac c0       	rjmp	.+344    	; 0x5c92 <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5b3a:	31 97       	sbiw	r30, 0x01	; 1
    5b3c:	ed 83       	std	Y+5, r30	; 0x05
    5b3e:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5b40:	9f 01       	movw	r18, r30
    5b42:	32 2f       	mov	r19, r18
    5b44:	22 27       	eor	r18, r18
    5b46:	33 0f       	add	r19, r19
    5b48:	8f 81       	ldd	r24, Y+7	; 0x07
    5b4a:	98 85       	ldd	r25, Y+8	; 0x08
    5b4c:	89 83       	std	Y+1, r24	; 0x01
    5b4e:	9a 83       	std	Y+2, r25	; 0x02
    5b50:	66 24       	eor	r6, r6
    5b52:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    5b54:	0f 2e       	mov	r0, r31
    5b56:	f7 ea       	ldi	r31, 0xA7	; 167
    5b58:	8f 2e       	mov	r8, r31
    5b5a:	f0 e5       	ldi	r31, 0x50	; 80
    5b5c:	9f 2e       	mov	r9, r31
    5b5e:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5b60:	0f 2e       	mov	r0, r31
    5b62:	fc e0       	ldi	r31, 0x0C	; 12
    5b64:	cf 2e       	mov	r12, r31
    5b66:	dd 24       	eor	r13, r13
    5b68:	f0 2d       	mov	r31, r0
    5b6a:	0f 2e       	mov	r0, r31
    5b6c:	f6 ea       	ldi	r31, 0xA6	; 166
    5b6e:	af 2e       	mov	r10, r31
    5b70:	f0 e5       	ldi	r31, 0x50	; 80
    5b72:	bf 2e       	mov	r11, r31
    5b74:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5b76:	80 e0       	ldi	r24, 0x00	; 0
    5b78:	92 e0       	ldi	r25, 0x02	; 2
    5b7a:	1c 01       	movw	r2, r24
    5b7c:	24 18       	sub	r2, r4
    5b7e:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5b80:	ef 81       	ldd	r30, Y+7	; 0x07
    5b82:	f8 85       	ldd	r31, Y+8	; 0x08
    5b84:	e2 0f       	add	r30, r18
    5b86:	f3 1f       	adc	r31, r19
    5b88:	ef 83       	std	Y+7, r30	; 0x07
    5b8a:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    5b8c:	8f ef       	ldi	r24, 0xFF	; 255
    5b8e:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5b92:	f4 01       	movw	r30, r8
    5b94:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    5b96:	8c ef       	ldi	r24, 0xFC	; 252
    5b98:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5b9c:	f4 01       	movw	r30, r8
    5b9e:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    5ba0:	2d 81       	ldd	r18, Y+5	; 0x05
    5ba2:	3e 81       	ldd	r19, Y+6	; 0x06
    5ba4:	26 15       	cp	r18, r6
    5ba6:	37 05       	cpc	r19, r7
    5ba8:	09 f0       	breq	.+2      	; 0x5bac <SD_write_multiple_blocks+0x122>
    5baa:	41 c0       	rjmp	.+130    	; 0x5c2e <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5bac:	12 14       	cp	r1, r2
    5bae:	13 04       	cpc	r1, r3
    5bb0:	cc f4       	brge	.+50     	; 0x5be4 <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5bb2:	ef 80       	ldd	r14, Y+7	; 0x07
    5bb4:	f8 84       	ldd	r15, Y+8	; 0x08
    5bb6:	00 e0       	ldi	r16, 0x00	; 0
    5bb8:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5bba:	c8 01       	movw	r24, r16
    5bbc:	b6 01       	movw	r22, r12
    5bbe:	0e 94 b7 3a 	call	0x756e	; 0x756e <__divmodhi4>
    5bc2:	89 87       	std	Y+9, r24	; 0x09
    5bc4:	9a 87       	std	Y+10, r25	; 0x0a
    5bc6:	f7 01       	movw	r30, r14
    5bc8:	81 91       	ld	r24, Z+
    5bca:	7f 01       	movw	r14, r30
    5bcc:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5bd0:	e9 85       	ldd	r30, Y+9	; 0x09
    5bd2:	fa 85       	ldd	r31, Y+10	; 0x0a
    5bd4:	ea 0d       	add	r30, r10
    5bd6:	fb 1d       	adc	r31, r11
    5bd8:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5bda:	0f 5f       	subi	r16, 0xFF	; 255
    5bdc:	1f 4f       	sbci	r17, 0xFF	; 255
    5bde:	02 15       	cp	r16, r2
    5be0:	13 05       	cpc	r17, r3
    5be2:	59 f7       	brne	.-42     	; 0x5bba <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5be4:	14 14       	cp	r1, r4
    5be6:	15 04       	cpc	r1, r5
    5be8:	9c f4       	brge	.+38     	; 0x5c10 <SD_write_multiple_blocks+0x186>
    5bea:	00 e0       	ldi	r16, 0x00	; 0
    5bec:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    5bee:	c8 01       	movw	r24, r16
    5bf0:	b6 01       	movw	r22, r12
    5bf2:	0e 94 b7 3a 	call	0x756e	; 0x756e <__divmodhi4>
    5bf6:	7c 01       	movw	r14, r24
    5bf8:	80 e0       	ldi	r24, 0x00	; 0
    5bfa:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5bfe:	f5 01       	movw	r30, r10
    5c00:	ee 0d       	add	r30, r14
    5c02:	ff 1d       	adc	r31, r15
    5c04:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5c06:	0f 5f       	subi	r16, 0xFF	; 255
    5c08:	1f 4f       	sbci	r17, 0xFF	; 255
    5c0a:	04 15       	cp	r16, r4
    5c0c:	15 05       	cpc	r17, r5
    5c0e:	79 f7       	brne	.-34     	; 0x5bee <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    5c10:	8f ef       	ldi	r24, 0xFF	; 255
    5c12:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5c16:	f4 01       	movw	r30, r8
    5c18:	80 83       	st	Z, r24
    5c1a:	8f ef       	ldi	r24, 0xFF	; 255
    5c1c:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5c20:	f4 01       	movw	r30, r8
    5c22:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    5c24:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5c26:	80 81       	ld	r24, Z
    5c28:	8f 3f       	cpi	r24, 0xFF	; 255
    5c2a:	e1 f4       	brne	.+56     	; 0x5c64 <SD_write_multiple_blocks+0x1da>
    5c2c:	23 c0       	rjmp	.+70     	; 0x5c74 <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5c2e:	e9 80       	ldd	r14, Y+1	; 0x01
    5c30:	fa 80       	ldd	r15, Y+2	; 0x02
    5c32:	00 e0       	ldi	r16, 0x00	; 0
    5c34:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5c36:	c8 01       	movw	r24, r16
    5c38:	b6 01       	movw	r22, r12
    5c3a:	0e 94 b7 3a 	call	0x756e	; 0x756e <__divmodhi4>
    5c3e:	89 87       	std	Y+9, r24	; 0x09
    5c40:	9a 87       	std	Y+10, r25	; 0x0a
    5c42:	f7 01       	movw	r30, r14
    5c44:	81 91       	ld	r24, Z+
    5c46:	7f 01       	movw	r14, r30
    5c48:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5c4c:	e9 85       	ldd	r30, Y+9	; 0x09
    5c4e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5c50:	ea 0d       	add	r30, r10
    5c52:	fb 1d       	adc	r31, r11
    5c54:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5c56:	0f 5f       	subi	r16, 0xFF	; 255
    5c58:	1f 4f       	sbci	r17, 0xFF	; 255
    5c5a:	f2 e0       	ldi	r31, 0x02	; 2
    5c5c:	00 30       	cpi	r16, 0x00	; 0
    5c5e:	1f 07       	cpc	r17, r31
    5c60:	51 f7       	brne	.-44     	; 0x5c36 <SD_write_multiple_blocks+0x1ac>
    5c62:	d6 cf       	rjmp	.-84     	; 0x5c10 <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5c64:	8f ef       	ldi	r24, 0xFF	; 255
    5c66:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5c6a:	f4 01       	movw	r30, r8
    5c6c:	80 83       	st	Z, r24
    5c6e:	80 81       	ld	r24, Z
    5c70:	8f 3f       	cpi	r24, 0xFF	; 255
    5c72:	c1 f7       	brne	.-16     	; 0x5c64 <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    5c74:	08 94       	sec
    5c76:	61 1c       	adc	r6, r1
    5c78:	71 1c       	adc	r7, r1
    5c7a:	29 81       	ldd	r18, Y+1	; 0x01
    5c7c:	3a 81       	ldd	r19, Y+2	; 0x02
    5c7e:	20 50       	subi	r18, 0x00	; 0
    5c80:	3e 4f       	sbci	r19, 0xFE	; 254
    5c82:	29 83       	std	Y+1, r18	; 0x01
    5c84:	3a 83       	std	Y+2, r19	; 0x02
    5c86:	8b 81       	ldd	r24, Y+3	; 0x03
    5c88:	9c 81       	ldd	r25, Y+4	; 0x04
    5c8a:	68 16       	cp	r6, r24
    5c8c:	79 06       	cpc	r7, r25
    5c8e:	09 f0       	breq	.+2      	; 0x5c92 <SD_write_multiple_blocks+0x208>
    5c90:	7d cf       	rjmp	.-262    	; 0x5b8c <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5c92:	ee 24       	eor	r14, r14
    5c94:	ff 24       	eor	r15, r15
    5c96:	68 94       	set
    5c98:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5c9a:	07 ea       	ldi	r16, 0xA7	; 167
    5c9c:	10 e5       	ldi	r17, 0x50	; 80
    5c9e:	8f ef       	ldi	r24, 0xFF	; 255
    5ca0:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5ca4:	f8 01       	movw	r30, r16
    5ca6:	80 83       	st	Z, r24
    5ca8:	08 94       	sec
    5caa:	e1 08       	sbc	r14, r1
    5cac:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    5cae:	e1 14       	cp	r14, r1
    5cb0:	f1 04       	cpc	r15, r1
    5cb2:	a9 f7       	brne	.-22     	; 0x5c9e <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    5cb4:	8d ef       	ldi	r24, 0xFD	; 253
    5cb6:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5cba:	80 93 a7 50 	sts	0x50A7, r24
    5cbe:	ee 24       	eor	r14, r14
    5cc0:	ff 24       	eor	r15, r15
    5cc2:	68 94       	set
    5cc4:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5cc6:	07 ea       	ldi	r16, 0xA7	; 167
    5cc8:	10 e5       	ldi	r17, 0x50	; 80
    5cca:	8f ef       	ldi	r24, 0xFF	; 255
    5ccc:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5cd0:	f8 01       	movw	r30, r16
    5cd2:	80 83       	st	Z, r24
    5cd4:	08 94       	sec
    5cd6:	e1 08       	sbc	r14, r1
    5cd8:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    5cda:	e1 14       	cp	r14, r1
    5cdc:	f1 04       	cpc	r15, r1
    5cde:	a9 f7       	brne	.-22     	; 0x5cca <SD_write_multiple_blocks+0x240>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    5ce0:	10 92 a7 50 	sts	0x50A7, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5ce4:	80 91 a7 50 	lds	r24, 0x50A7
    5ce8:	8f 3f       	cpi	r24, 0xFF	; 255
    5cea:	51 f0       	breq	.+20     	; 0x5d00 <SD_write_multiple_blocks+0x276>
    5cec:	07 ea       	ldi	r16, 0xA7	; 167
    5cee:	10 e5       	ldi	r17, 0x50	; 80
    5cf0:	8f ef       	ldi	r24, 0xFF	; 255
    5cf2:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5cf6:	f8 01       	movw	r30, r16
    5cf8:	80 83       	st	Z, r24
    5cfa:	80 81       	ld	r24, Z
    5cfc:	8f 3f       	cpi	r24, 0xFF	; 255
    5cfe:	c1 f7       	brne	.-16     	; 0x5cf0 <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    5d00:	80 e0       	ldi	r24, 0x00	; 0
    5d02:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	SPIDisable();
    5d06:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5d0a:	88 e0       	ldi	r24, 0x08	; 8
    5d0c:	60 e0       	ldi	r22, 0x00	; 0
    5d0e:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <PortEx_OUTSET>
}
    5d12:	2a 96       	adiw	r28, 0x0a	; 10
    5d14:	cd bf       	out	0x3d, r28	; 61
    5d16:	de bf       	out	0x3e, r29	; 62
    5d18:	df 91       	pop	r29
    5d1a:	cf 91       	pop	r28
    5d1c:	1f 91       	pop	r17
    5d1e:	0f 91       	pop	r16
    5d20:	ff 90       	pop	r15
    5d22:	ef 90       	pop	r14
    5d24:	df 90       	pop	r13
    5d26:	cf 90       	pop	r12
    5d28:	bf 90       	pop	r11
    5d2a:	af 90       	pop	r10
    5d2c:	9f 90       	pop	r9
    5d2e:	8f 90       	pop	r8
    5d30:	7f 90       	pop	r7
    5d32:	6f 90       	pop	r6
    5d34:	5f 90       	pop	r5
    5d36:	4f 90       	pop	r4
    5d38:	3f 90       	pop	r3
    5d3a:	2f 90       	pop	r2
    5d3c:	08 95       	ret

00005d3e <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    5d3e:	2f 92       	push	r2
    5d40:	3f 92       	push	r3
    5d42:	4f 92       	push	r4
    5d44:	5f 92       	push	r5
    5d46:	6f 92       	push	r6
    5d48:	7f 92       	push	r7
    5d4a:	8f 92       	push	r8
    5d4c:	9f 92       	push	r9
    5d4e:	af 92       	push	r10
    5d50:	bf 92       	push	r11
    5d52:	cf 92       	push	r12
    5d54:	df 92       	push	r13
    5d56:	ef 92       	push	r14
    5d58:	ff 92       	push	r15
    5d5a:	0f 93       	push	r16
    5d5c:	1f 93       	push	r17
    5d5e:	cf 93       	push	r28
    5d60:	df 93       	push	r29
    5d62:	6b 01       	movw	r12, r22
    5d64:	7c 01       	movw	r14, r24
    5d66:	c4 2f       	mov	r28, r20
    5d68:	85 2e       	mov	r8, r21
    5d6a:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5d6c:	88 e0       	ldi	r24, 0x08	; 8
    5d6e:	60 e0       	ldi	r22, 0x00	; 0
    5d70:	0e 94 e5 1d 	call	0x3bca	; 0x3bca <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5d74:	80 e0       	ldi	r24, 0x00	; 0
    5d76:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <SPIInit>
	SPICS(TRUE);
    5d7a:	81 e0       	ldi	r24, 0x01	; 1
    5d7c:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    5d80:	82 e1       	ldi	r24, 0x12	; 18
    5d82:	b7 01       	movw	r22, r14
    5d84:	a6 01       	movw	r20, r12
    5d86:	2f ef       	ldi	r18, 0xFF	; 255
    5d88:	08 e0       	ldi	r16, 0x08	; 8
    5d8a:	10 e0       	ldi	r17, 0x00	; 0
    5d8c:	0e 94 ee 2a 	call	0x55dc	; 0x55dc <SD_command>
    5d90:	88 23       	and	r24, r24
    5d92:	b1 f7       	brne	.-20     	; 0x5d80 <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5d94:	16 14       	cp	r1, r6
    5d96:	17 04       	cpc	r1, r7
    5d98:	0c f0       	brlt	.+2      	; 0x5d9c <SD_read_multiple_blocks+0x5e>
    5d9a:	46 c0       	rjmp	.+140    	; 0x5e28 <SD_read_multiple_blocks+0xea>
    5d9c:	ac 2e       	mov	r10, r28
    5d9e:	b8 2c       	mov	r11, r8
    5da0:	88 24       	eor	r8, r8
    5da2:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    5da4:	0f 2e       	mov	r0, r31
    5da6:	f7 ea       	ldi	r31, 0xA7	; 167
    5da8:	cf 2e       	mov	r12, r31
    5daa:	f0 e5       	ldi	r31, 0x50	; 80
    5dac:	df 2e       	mov	r13, r31
    5dae:	f0 2d       	mov	r31, r0
    5db0:	ff 24       	eor	r15, r15
    5db2:	fa 94       	dec	r15
    5db4:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5db6:	0f 2e       	mov	r0, r31
    5db8:	f6 ea       	ldi	r31, 0xA6	; 166
    5dba:	4f 2e       	mov	r4, r31
    5dbc:	f0 e5       	ldi	r31, 0x50	; 80
    5dbe:	5f 2e       	mov	r5, r31
    5dc0:	f0 2d       	mov	r31, r0
    5dc2:	12 01       	movw	r2, r4
    5dc4:	08 94       	sec
    5dc6:	21 1c       	adc	r2, r1
    5dc8:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    5dca:	f6 01       	movw	r30, r12
    5dcc:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5dce:	80 81       	ld	r24, Z
    5dd0:	8e 3f       	cpi	r24, 0xFE	; 254
    5dd2:	41 f0       	breq	.+16     	; 0x5de4 <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    5dd4:	8f 2d       	mov	r24, r15
    5dd6:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5dda:	f6 01       	movw	r30, r12
    5ddc:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5dde:	80 81       	ld	r24, Z
    5de0:	8e 3f       	cpi	r24, 0xFE	; 254
    5de2:	c1 f7       	brne	.-16     	; 0x5dd4 <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5de4:	85 01       	movw	r16, r10
    5de6:	c0 e0       	ldi	r28, 0x00	; 0
    5de8:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5dea:	8f 2d       	mov	r24, r15
    5dec:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5df0:	f8 01       	movw	r30, r16
    5df2:	81 93       	st	Z+, r24
    5df4:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5df6:	21 96       	adiw	r28, 0x01	; 1
    5df8:	f2 e0       	ldi	r31, 0x02	; 2
    5dfa:	c0 30       	cpi	r28, 0x00	; 0
    5dfc:	df 07       	cpc	r29, r31
    5dfe:	a9 f7       	brne	.-22     	; 0x5dea <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5e00:	8f 2d       	mov	r24, r15
    5e02:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5e06:	f2 01       	movw	r30, r4
    5e08:	80 83       	st	Z, r24
    5e0a:	8f 2d       	mov	r24, r15
    5e0c:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5e10:	f1 01       	movw	r30, r2
    5e12:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5e14:	08 94       	sec
    5e16:	81 1c       	adc	r8, r1
    5e18:	91 1c       	adc	r9, r1
    5e1a:	80 e0       	ldi	r24, 0x00	; 0
    5e1c:	92 e0       	ldi	r25, 0x02	; 2
    5e1e:	a8 0e       	add	r10, r24
    5e20:	b9 1e       	adc	r11, r25
    5e22:	86 14       	cp	r8, r6
    5e24:	97 04       	cpc	r9, r7
    5e26:	89 f6       	brne	.-94     	; 0x5dca <SD_read_multiple_blocks+0x8c>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    5e28:	8c e0       	ldi	r24, 0x0C	; 12
    5e2a:	40 e0       	ldi	r20, 0x00	; 0
    5e2c:	50 e0       	ldi	r21, 0x00	; 0
    5e2e:	ba 01       	movw	r22, r20
    5e30:	2f ef       	ldi	r18, 0xFF	; 255
    5e32:	08 e0       	ldi	r16, 0x08	; 8
    5e34:	10 e0       	ldi	r17, 0x00	; 0
    5e36:	0e 94 ee 2a 	call	0x55dc	; 0x55dc <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    5e3a:	8f ef       	ldi	r24, 0xFF	; 255
    5e3c:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5e40:	80 93 a6 50 	sts	0x50A6, r24
	Buffer[1] = FILLER_BYTE;
    5e44:	10 92 a7 50 	sts	0x50A7, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5e48:	80 91 a7 50 	lds	r24, 0x50A7
    5e4c:	8f 3f       	cpi	r24, 0xFF	; 255
    5e4e:	49 f0       	breq	.+18     	; 0x5e62 <SD_read_multiple_blocks+0x124>
    5e50:	c7 ea       	ldi	r28, 0xA7	; 167
    5e52:	d0 e5       	ldi	r29, 0x50	; 80
    5e54:	8f ef       	ldi	r24, 0xFF	; 255
    5e56:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
    5e5a:	88 83       	st	Y, r24
    5e5c:	88 81       	ld	r24, Y
    5e5e:	8f 3f       	cpi	r24, 0xFF	; 255
    5e60:	c9 f7       	brne	.-14     	; 0x5e54 <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    5e62:	80 e0       	ldi	r24, 0x00	; 0
    5e64:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	SPIDisable();
    5e68:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5e6c:	88 e0       	ldi	r24, 0x08	; 8
    5e6e:	60 e0       	ldi	r22, 0x00	; 0
    5e70:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <PortEx_OUTSET>
}
    5e74:	df 91       	pop	r29
    5e76:	cf 91       	pop	r28
    5e78:	1f 91       	pop	r17
    5e7a:	0f 91       	pop	r16
    5e7c:	ff 90       	pop	r15
    5e7e:	ef 90       	pop	r14
    5e80:	df 90       	pop	r13
    5e82:	cf 90       	pop	r12
    5e84:	bf 90       	pop	r11
    5e86:	af 90       	pop	r10
    5e88:	9f 90       	pop	r9
    5e8a:	8f 90       	pop	r8
    5e8c:	7f 90       	pop	r7
    5e8e:	6f 90       	pop	r6
    5e90:	5f 90       	pop	r5
    5e92:	4f 90       	pop	r4
    5e94:	3f 90       	pop	r3
    5e96:	2f 90       	pop	r2
    5e98:	08 95       	ret

00005e9a <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    5e9a:	88 e0       	ldi	r24, 0x08	; 8
    5e9c:	60 e0       	ldi	r22, 0x00	; 0
    5e9e:	0e 94 e9 1e 	call	0x3dd2	; 0x3dd2 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    5ea2:	88 e0       	ldi	r24, 0x08	; 8
    5ea4:	60 e0       	ldi	r22, 0x00	; 0
    5ea6:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    5eaa:	80 e0       	ldi	r24, 0x00	; 0
    5eac:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <SPIInit>
	SPICS(TRUE);
    5eb0:	81 e0       	ldi	r24, 0x01	; 1
    5eb2:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    5eb6:	8f ef       	ldi	r24, 0xFF	; 255
    5eb8:	0e 94 e4 2a 	call	0x55c8	; 0x55c8 <SPI_write>
	SPICS(FALSE);	//stop spi
    5ebc:	80 e0       	ldi	r24, 0x00	; 0
    5ebe:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <SPICS>
	SPIDisable();
    5ec2:	0e 94 db 1d 	call	0x3bb6	; 0x3bb6 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    5ec6:	80 e0       	ldi	r24, 0x00	; 0
    5ec8:	0e 94 6f 04 	call	0x8de	; 0x8de <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    5ecc:	80 e0       	ldi	r24, 0x00	; 0
    5ece:	0e 94 49 1d 	call	0x3a92	; 0x3a92 <Ext1Power>
}
    5ed2:	08 95       	ret

00005ed4 <__muldi3>:
    5ed4:	a0 e3       	ldi	r26, 0x30	; 48
    5ed6:	b0 e0       	ldi	r27, 0x00	; 0
    5ed8:	e0 e7       	ldi	r30, 0x70	; 112
    5eda:	ff e2       	ldi	r31, 0x2F	; 47
    5edc:	0c 94 09 3b 	jmp	0x7612	; 0x7612 <__prologue_saves__+0x4>
    5ee0:	29 8f       	std	Y+25, r18	; 0x19
    5ee2:	3a 8f       	std	Y+26, r19	; 0x1a
    5ee4:	4b 8f       	std	Y+27, r20	; 0x1b
    5ee6:	5c 8f       	std	Y+28, r21	; 0x1c
    5ee8:	6d 8f       	std	Y+29, r22	; 0x1d
    5eea:	7e 8f       	std	Y+30, r23	; 0x1e
    5eec:	8f 8f       	std	Y+31, r24	; 0x1f
    5eee:	98 a3       	lds	r25, 0x58
    5ef0:	a9 8a       	std	Y+17, r10	; 0x11
    5ef2:	ba 8a       	std	Y+18, r11	; 0x12
    5ef4:	cb 8a       	std	Y+19, r12	; 0x13
    5ef6:	dc 8a       	std	Y+20, r13	; 0x14
    5ef8:	ed 8a       	std	Y+21, r14	; 0x15
    5efa:	fe 8a       	std	Y+22, r15	; 0x16
    5efc:	0f 8b       	std	Y+23, r16	; 0x17
    5efe:	18 8f       	std	Y+24, r17	; 0x18
    5f00:	09 8d       	ldd	r16, Y+25	; 0x19
    5f02:	1a 8d       	ldd	r17, Y+26	; 0x1a
    5f04:	2b 8d       	ldd	r18, Y+27	; 0x1b
    5f06:	3c 8d       	ldd	r19, Y+28	; 0x1c
    5f08:	09 a3       	lds	r16, 0x59
    5f0a:	1a a3       	lds	r17, 0x5a
    5f0c:	2b a3       	lds	r18, 0x5b
    5f0e:	3c a3       	lds	r19, 0x5c
    5f10:	68 01       	movw	r12, r16
    5f12:	79 01       	movw	r14, r18
    5f14:	8f ef       	ldi	r24, 0xFF	; 255
    5f16:	9f ef       	ldi	r25, 0xFF	; 255
    5f18:	a0 e0       	ldi	r26, 0x00	; 0
    5f1a:	b0 e0       	ldi	r27, 0x00	; 0
    5f1c:	c8 22       	and	r12, r24
    5f1e:	d9 22       	and	r13, r25
    5f20:	ea 22       	and	r14, r26
    5f22:	fb 22       	and	r15, r27
    5f24:	89 01       	movw	r16, r18
    5f26:	22 27       	eor	r18, r18
    5f28:	33 27       	eor	r19, r19
    5f2a:	09 a7       	lds	r16, 0x79
    5f2c:	1a a7       	lds	r17, 0x7a
    5f2e:	2b a7       	lds	r18, 0x7b
    5f30:	3c a7       	lds	r19, 0x7c
    5f32:	09 89       	ldd	r16, Y+17	; 0x11
    5f34:	1a 89       	ldd	r17, Y+18	; 0x12
    5f36:	2b 89       	ldd	r18, Y+19	; 0x13
    5f38:	3c 89       	ldd	r19, Y+20	; 0x14
    5f3a:	0d a3       	lds	r16, 0x5d
    5f3c:	1e a3       	lds	r17, 0x5e
    5f3e:	2f a3       	lds	r18, 0x5f
    5f40:	38 a7       	lds	r19, 0x78
    5f42:	48 01       	movw	r8, r16
    5f44:	59 01       	movw	r10, r18
    5f46:	88 22       	and	r8, r24
    5f48:	99 22       	and	r9, r25
    5f4a:	aa 22       	and	r10, r26
    5f4c:	bb 22       	and	r11, r27
    5f4e:	29 01       	movw	r4, r18
    5f50:	66 24       	eor	r6, r6
    5f52:	77 24       	eor	r7, r7
    5f54:	c5 01       	movw	r24, r10
    5f56:	b4 01       	movw	r22, r8
    5f58:	a7 01       	movw	r20, r14
    5f5a:	96 01       	movw	r18, r12
    5f5c:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    5f60:	6d a7       	lds	r22, 0x7d
    5f62:	7e a7       	lds	r23, 0x7e
    5f64:	8f a7       	lds	r24, 0x7f
    5f66:	98 ab       	sts	0x58, r25
    5f68:	c3 01       	movw	r24, r6
    5f6a:	b2 01       	movw	r22, r4
    5f6c:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    5f70:	6b 01       	movw	r12, r22
    5f72:	7c 01       	movw	r14, r24
    5f74:	c5 01       	movw	r24, r10
    5f76:	b4 01       	movw	r22, r8
    5f78:	29 a5       	lds	r18, 0x69
    5f7a:	3a a5       	lds	r19, 0x6a
    5f7c:	4b a5       	lds	r20, 0x6b
    5f7e:	5c a5       	lds	r21, 0x6c
    5f80:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    5f84:	4b 01       	movw	r8, r22
    5f86:	5c 01       	movw	r10, r24
    5f88:	c3 01       	movw	r24, r6
    5f8a:	b2 01       	movw	r22, r4
    5f8c:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    5f90:	ab 01       	movw	r20, r22
    5f92:	bc 01       	movw	r22, r24
    5f94:	c8 0c       	add	r12, r8
    5f96:	d9 1c       	adc	r13, r9
    5f98:	ea 1c       	adc	r14, r10
    5f9a:	fb 1c       	adc	r15, r11
    5f9c:	0d a5       	lds	r16, 0x6d
    5f9e:	1e a5       	lds	r17, 0x6e
    5fa0:	2f a5       	lds	r18, 0x6f
    5fa2:	38 a9       	sts	0x48, r19
    5fa4:	c9 01       	movw	r24, r18
    5fa6:	aa 27       	eor	r26, r26
    5fa8:	bb 27       	eor	r27, r27
    5faa:	c8 0e       	add	r12, r24
    5fac:	d9 1e       	adc	r13, r25
    5fae:	ea 1e       	adc	r14, r26
    5fb0:	fb 1e       	adc	r15, r27
    5fb2:	c8 14       	cp	r12, r8
    5fb4:	d9 04       	cpc	r13, r9
    5fb6:	ea 04       	cpc	r14, r10
    5fb8:	fb 04       	cpc	r15, r11
    5fba:	20 f4       	brcc	.+8      	; 0x5fc4 <__muldi3+0xf0>
    5fbc:	40 50       	subi	r20, 0x00	; 0
    5fbe:	50 40       	sbci	r21, 0x00	; 0
    5fc0:	6f 4f       	sbci	r22, 0xFF	; 255
    5fc2:	7f 4f       	sbci	r23, 0xFF	; 255
    5fc4:	c7 01       	movw	r24, r14
    5fc6:	aa 27       	eor	r26, r26
    5fc8:	bb 27       	eor	r27, r27
    5fca:	84 0f       	add	r24, r20
    5fcc:	95 1f       	adc	r25, r21
    5fce:	a6 1f       	adc	r26, r22
    5fd0:	b7 1f       	adc	r27, r23
    5fd2:	8d 83       	std	Y+5, r24	; 0x05
    5fd4:	9e 83       	std	Y+6, r25	; 0x06
    5fd6:	af 83       	std	Y+7, r26	; 0x07
    5fd8:	b8 87       	std	Y+8, r27	; 0x08
    5fda:	76 01       	movw	r14, r12
    5fdc:	dd 24       	eor	r13, r13
    5fde:	cc 24       	eor	r12, r12
    5fe0:	4d a5       	lds	r20, 0x6d
    5fe2:	5e a5       	lds	r21, 0x6e
    5fe4:	6f a5       	lds	r22, 0x6f
    5fe6:	78 a9       	sts	0x48, r23
    5fe8:	60 70       	andi	r22, 0x00	; 0
    5fea:	70 70       	andi	r23, 0x00	; 0
    5fec:	c4 0e       	add	r12, r20
    5fee:	d5 1e       	adc	r13, r21
    5ff0:	e6 1e       	adc	r14, r22
    5ff2:	f7 1e       	adc	r15, r23
    5ff4:	c9 82       	std	Y+1, r12	; 0x01
    5ff6:	da 82       	std	Y+2, r13	; 0x02
    5ff8:	eb 82       	std	Y+3, r14	; 0x03
    5ffa:	fc 82       	std	Y+4, r15	; 0x04
    5ffc:	1c 2d       	mov	r17, r12
    5ffe:	0a 81       	ldd	r16, Y+2	; 0x02
    6000:	8b 80       	ldd	r8, Y+3	; 0x03
    6002:	4c 80       	ldd	r4, Y+4	; 0x04
    6004:	8d 87       	std	Y+13, r24	; 0x0d
    6006:	8e 81       	ldd	r24, Y+6	; 0x06
    6008:	8e 87       	std	Y+14, r24	; 0x0e
    600a:	8f 81       	ldd	r24, Y+7	; 0x07
    600c:	8f 87       	std	Y+15, r24	; 0x0f
    600e:	88 85       	ldd	r24, Y+8	; 0x08
    6010:	88 8b       	std	Y+16, r24	; 0x10
    6012:	2d 89       	ldd	r18, Y+21	; 0x15
    6014:	3e 89       	ldd	r19, Y+22	; 0x16
    6016:	4f 89       	ldd	r20, Y+23	; 0x17
    6018:	58 8d       	ldd	r21, Y+24	; 0x18
    601a:	69 a1       	lds	r22, 0x49
    601c:	7a a1       	lds	r23, 0x4a
    601e:	8b a1       	lds	r24, 0x4b
    6020:	9c a1       	lds	r25, 0x4c
    6022:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    6026:	6b 01       	movw	r12, r22
    6028:	7c 01       	movw	r14, r24
    602a:	2d 8d       	ldd	r18, Y+29	; 0x1d
    602c:	3e 8d       	ldd	r19, Y+30	; 0x1e
    602e:	4f 8d       	ldd	r20, Y+31	; 0x1f
    6030:	58 a1       	lds	r21, 0x48
    6032:	6d a1       	lds	r22, 0x4d
    6034:	7e a1       	lds	r23, 0x4e
    6036:	8f a1       	lds	r24, 0x4f
    6038:	98 a5       	lds	r25, 0x68
    603a:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    603e:	dc 01       	movw	r26, r24
    6040:	cb 01       	movw	r24, r22
    6042:	c8 0e       	add	r12, r24
    6044:	d9 1e       	adc	r13, r25
    6046:	ea 1e       	adc	r14, r26
    6048:	fb 1e       	adc	r15, r27
    604a:	8d 85       	ldd	r24, Y+13	; 0x0d
    604c:	9e 85       	ldd	r25, Y+14	; 0x0e
    604e:	af 85       	ldd	r26, Y+15	; 0x0f
    6050:	b8 89       	ldd	r27, Y+16	; 0x10
    6052:	8c 0d       	add	r24, r12
    6054:	9d 1d       	adc	r25, r13
    6056:	ae 1d       	adc	r26, r14
    6058:	bf 1d       	adc	r27, r15
    605a:	8d 87       	std	Y+13, r24	; 0x0d
    605c:	9e 87       	std	Y+14, r25	; 0x0e
    605e:	af 87       	std	Y+15, r26	; 0x0f
    6060:	b8 8b       	std	Y+16, r27	; 0x10
    6062:	68 2f       	mov	r22, r24
    6064:	7e 85       	ldd	r23, Y+14	; 0x0e
    6066:	21 2f       	mov	r18, r17
    6068:	30 2f       	mov	r19, r16
    606a:	48 2d       	mov	r20, r8
    606c:	54 2d       	mov	r21, r4
    606e:	8f 85       	ldd	r24, Y+15	; 0x0f
    6070:	98 89       	ldd	r25, Y+16	; 0x10
    6072:	e0 96       	adiw	r28, 0x30	; 48
    6074:	e0 e1       	ldi	r30, 0x10	; 16
    6076:	0c 94 22 3b 	jmp	0x7644	; 0x7644 <__epilogue_restores__+0x4>

0000607a <__ashldi3>:
    607a:	cf 92       	push	r12
    607c:	df 92       	push	r13
    607e:	ef 92       	push	r14
    6080:	ff 92       	push	r15
    6082:	0f 93       	push	r16
    6084:	cf 93       	push	r28
    6086:	df 93       	push	r29
    6088:	cd b7       	in	r28, 0x3d	; 61
    608a:	de b7       	in	r29, 0x3e	; 62
    608c:	60 97       	sbiw	r28, 0x10	; 16
    608e:	cd bf       	out	0x3d, r28	; 61
    6090:	de bf       	out	0x3e, r29	; 62
    6092:	00 23       	and	r16, r16
    6094:	09 f4       	brne	.+2      	; 0x6098 <__ashldi3+0x1e>
    6096:	5a c0       	rjmp	.+180    	; 0x614c <__ashldi3+0xd2>
    6098:	29 87       	std	Y+9, r18	; 0x09
    609a:	3a 87       	std	Y+10, r19	; 0x0a
    609c:	4b 87       	std	Y+11, r20	; 0x0b
    609e:	5c 87       	std	Y+12, r21	; 0x0c
    60a0:	6d 87       	std	Y+13, r22	; 0x0d
    60a2:	7e 87       	std	Y+14, r23	; 0x0e
    60a4:	8f 87       	std	Y+15, r24	; 0x0f
    60a6:	98 8b       	std	Y+16, r25	; 0x10
    60a8:	80 e2       	ldi	r24, 0x20	; 32
    60aa:	80 1b       	sub	r24, r16
    60ac:	49 85       	ldd	r20, Y+9	; 0x09
    60ae:	5a 85       	ldd	r21, Y+10	; 0x0a
    60b0:	6b 85       	ldd	r22, Y+11	; 0x0b
    60b2:	7c 85       	ldd	r23, Y+12	; 0x0c
    60b4:	18 16       	cp	r1, r24
    60b6:	b4 f0       	brlt	.+44     	; 0x60e4 <__ashldi3+0x6a>
    60b8:	19 82       	std	Y+1, r1	; 0x01
    60ba:	1a 82       	std	Y+2, r1	; 0x02
    60bc:	1b 82       	std	Y+3, r1	; 0x03
    60be:	1c 82       	std	Y+4, r1	; 0x04
    60c0:	99 27       	eor	r25, r25
    60c2:	87 fd       	sbrc	r24, 7
    60c4:	90 95       	com	r25
    60c6:	90 95       	com	r25
    60c8:	81 95       	neg	r24
    60ca:	9f 4f       	sbci	r25, 0xFF	; 255
    60cc:	04 c0       	rjmp	.+8      	; 0x60d6 <__ashldi3+0x5c>
    60ce:	44 0f       	add	r20, r20
    60d0:	55 1f       	adc	r21, r21
    60d2:	66 1f       	adc	r22, r22
    60d4:	77 1f       	adc	r23, r23
    60d6:	8a 95       	dec	r24
    60d8:	d2 f7       	brpl	.-12     	; 0x60ce <__ashldi3+0x54>
    60da:	4d 83       	std	Y+5, r20	; 0x05
    60dc:	5e 83       	std	Y+6, r21	; 0x06
    60de:	6f 83       	std	Y+7, r22	; 0x07
    60e0:	78 87       	std	Y+8, r23	; 0x08
    60e2:	2c c0       	rjmp	.+88     	; 0x613c <__ashldi3+0xc2>
    60e4:	6a 01       	movw	r12, r20
    60e6:	7b 01       	movw	r14, r22
    60e8:	00 2e       	mov	r0, r16
    60ea:	04 c0       	rjmp	.+8      	; 0x60f4 <__ashldi3+0x7a>
    60ec:	cc 0c       	add	r12, r12
    60ee:	dd 1c       	adc	r13, r13
    60f0:	ee 1c       	adc	r14, r14
    60f2:	ff 1c       	adc	r15, r15
    60f4:	0a 94       	dec	r0
    60f6:	d2 f7       	brpl	.-12     	; 0x60ec <__ashldi3+0x72>
    60f8:	c9 82       	std	Y+1, r12	; 0x01
    60fa:	da 82       	std	Y+2, r13	; 0x02
    60fc:	eb 82       	std	Y+3, r14	; 0x03
    60fe:	fc 82       	std	Y+4, r15	; 0x04
    6100:	6a 01       	movw	r12, r20
    6102:	7b 01       	movw	r14, r22
    6104:	04 c0       	rjmp	.+8      	; 0x610e <__ashldi3+0x94>
    6106:	f6 94       	lsr	r15
    6108:	e7 94       	ror	r14
    610a:	d7 94       	ror	r13
    610c:	c7 94       	ror	r12
    610e:	8a 95       	dec	r24
    6110:	d2 f7       	brpl	.-12     	; 0x6106 <__ashldi3+0x8c>
    6112:	d7 01       	movw	r26, r14
    6114:	c6 01       	movw	r24, r12
    6116:	4d 85       	ldd	r20, Y+13	; 0x0d
    6118:	5e 85       	ldd	r21, Y+14	; 0x0e
    611a:	6f 85       	ldd	r22, Y+15	; 0x0f
    611c:	78 89       	ldd	r23, Y+16	; 0x10
    611e:	04 c0       	rjmp	.+8      	; 0x6128 <__ashldi3+0xae>
    6120:	44 0f       	add	r20, r20
    6122:	55 1f       	adc	r21, r21
    6124:	66 1f       	adc	r22, r22
    6126:	77 1f       	adc	r23, r23
    6128:	0a 95       	dec	r16
    612a:	d2 f7       	brpl	.-12     	; 0x6120 <__ashldi3+0xa6>
    612c:	84 2b       	or	r24, r20
    612e:	95 2b       	or	r25, r21
    6130:	a6 2b       	or	r26, r22
    6132:	b7 2b       	or	r27, r23
    6134:	8d 83       	std	Y+5, r24	; 0x05
    6136:	9e 83       	std	Y+6, r25	; 0x06
    6138:	af 83       	std	Y+7, r26	; 0x07
    613a:	b8 87       	std	Y+8, r27	; 0x08
    613c:	29 81       	ldd	r18, Y+1	; 0x01
    613e:	3a 81       	ldd	r19, Y+2	; 0x02
    6140:	4b 81       	ldd	r20, Y+3	; 0x03
    6142:	5c 81       	ldd	r21, Y+4	; 0x04
    6144:	6d 81       	ldd	r22, Y+5	; 0x05
    6146:	7e 81       	ldd	r23, Y+6	; 0x06
    6148:	8f 81       	ldd	r24, Y+7	; 0x07
    614a:	98 85       	ldd	r25, Y+8	; 0x08
    614c:	60 96       	adiw	r28, 0x10	; 16
    614e:	cd bf       	out	0x3d, r28	; 61
    6150:	de bf       	out	0x3e, r29	; 62
    6152:	df 91       	pop	r29
    6154:	cf 91       	pop	r28
    6156:	0f 91       	pop	r16
    6158:	ff 90       	pop	r15
    615a:	ef 90       	pop	r14
    615c:	df 90       	pop	r13
    615e:	cf 90       	pop	r12
    6160:	08 95       	ret

00006162 <__ashrdi3>:
    6162:	0f 93       	push	r16
    6164:	cf 93       	push	r28
    6166:	df 93       	push	r29
    6168:	cd b7       	in	r28, 0x3d	; 61
    616a:	de b7       	in	r29, 0x3e	; 62
    616c:	60 97       	sbiw	r28, 0x10	; 16
    616e:	cd bf       	out	0x3d, r28	; 61
    6170:	de bf       	out	0x3e, r29	; 62
    6172:	00 23       	and	r16, r16
    6174:	09 f4       	brne	.+2      	; 0x6178 <__ashrdi3+0x16>
    6176:	56 c0       	rjmp	.+172    	; 0x6224 <__ashrdi3+0xc2>
    6178:	29 87       	std	Y+9, r18	; 0x09
    617a:	3a 87       	std	Y+10, r19	; 0x0a
    617c:	4b 87       	std	Y+11, r20	; 0x0b
    617e:	5c 87       	std	Y+12, r21	; 0x0c
    6180:	6d 87       	std	Y+13, r22	; 0x0d
    6182:	7e 87       	std	Y+14, r23	; 0x0e
    6184:	8f 87       	std	Y+15, r24	; 0x0f
    6186:	98 8b       	std	Y+16, r25	; 0x10
    6188:	20 e2       	ldi	r18, 0x20	; 32
    618a:	20 1b       	sub	r18, r16
    618c:	8d 85       	ldd	r24, Y+13	; 0x0d
    618e:	9e 85       	ldd	r25, Y+14	; 0x0e
    6190:	af 85       	ldd	r26, Y+15	; 0x0f
    6192:	b8 89       	ldd	r27, Y+16	; 0x10
    6194:	ac 01       	movw	r20, r24
    6196:	bd 01       	movw	r22, r26
    6198:	12 16       	cp	r1, r18
    619a:	b4 f0       	brlt	.+44     	; 0x61c8 <__ashrdi3+0x66>
    619c:	77 0f       	add	r23, r23
    619e:	44 0b       	sbc	r20, r20
    61a0:	54 2f       	mov	r21, r20
    61a2:	ba 01       	movw	r22, r20
    61a4:	4d 83       	std	Y+5, r20	; 0x05
    61a6:	5e 83       	std	Y+6, r21	; 0x06
    61a8:	6f 83       	std	Y+7, r22	; 0x07
    61aa:	78 87       	std	Y+8, r23	; 0x08
    61ac:	33 27       	eor	r19, r19
    61ae:	27 fd       	sbrc	r18, 7
    61b0:	30 95       	com	r19
    61b2:	30 95       	com	r19
    61b4:	21 95       	neg	r18
    61b6:	3f 4f       	sbci	r19, 0xFF	; 255
    61b8:	04 c0       	rjmp	.+8      	; 0x61c2 <__ashrdi3+0x60>
    61ba:	b5 95       	asr	r27
    61bc:	a7 95       	ror	r26
    61be:	97 95       	ror	r25
    61c0:	87 95       	ror	r24
    61c2:	2a 95       	dec	r18
    61c4:	d2 f7       	brpl	.-12     	; 0x61ba <__ashrdi3+0x58>
    61c6:	22 c0       	rjmp	.+68     	; 0x620c <__ashrdi3+0xaa>
    61c8:	00 2e       	mov	r0, r16
    61ca:	04 c0       	rjmp	.+8      	; 0x61d4 <__ashrdi3+0x72>
    61cc:	75 95       	asr	r23
    61ce:	67 95       	ror	r22
    61d0:	57 95       	ror	r21
    61d2:	47 95       	ror	r20
    61d4:	0a 94       	dec	r0
    61d6:	d2 f7       	brpl	.-12     	; 0x61cc <__ashrdi3+0x6a>
    61d8:	4d 83       	std	Y+5, r20	; 0x05
    61da:	5e 83       	std	Y+6, r21	; 0x06
    61dc:	6f 83       	std	Y+7, r22	; 0x07
    61de:	78 87       	std	Y+8, r23	; 0x08
    61e0:	04 c0       	rjmp	.+8      	; 0x61ea <__ashrdi3+0x88>
    61e2:	88 0f       	add	r24, r24
    61e4:	99 1f       	adc	r25, r25
    61e6:	aa 1f       	adc	r26, r26
    61e8:	bb 1f       	adc	r27, r27
    61ea:	2a 95       	dec	r18
    61ec:	d2 f7       	brpl	.-12     	; 0x61e2 <__ashrdi3+0x80>
    61ee:	49 85       	ldd	r20, Y+9	; 0x09
    61f0:	5a 85       	ldd	r21, Y+10	; 0x0a
    61f2:	6b 85       	ldd	r22, Y+11	; 0x0b
    61f4:	7c 85       	ldd	r23, Y+12	; 0x0c
    61f6:	04 c0       	rjmp	.+8      	; 0x6200 <__ashrdi3+0x9e>
    61f8:	76 95       	lsr	r23
    61fa:	67 95       	ror	r22
    61fc:	57 95       	ror	r21
    61fe:	47 95       	ror	r20
    6200:	0a 95       	dec	r16
    6202:	d2 f7       	brpl	.-12     	; 0x61f8 <__ashrdi3+0x96>
    6204:	84 2b       	or	r24, r20
    6206:	95 2b       	or	r25, r21
    6208:	a6 2b       	or	r26, r22
    620a:	b7 2b       	or	r27, r23
    620c:	89 83       	std	Y+1, r24	; 0x01
    620e:	9a 83       	std	Y+2, r25	; 0x02
    6210:	ab 83       	std	Y+3, r26	; 0x03
    6212:	bc 83       	std	Y+4, r27	; 0x04
    6214:	29 81       	ldd	r18, Y+1	; 0x01
    6216:	3a 81       	ldd	r19, Y+2	; 0x02
    6218:	4b 81       	ldd	r20, Y+3	; 0x03
    621a:	5c 81       	ldd	r21, Y+4	; 0x04
    621c:	6d 81       	ldd	r22, Y+5	; 0x05
    621e:	7e 81       	ldd	r23, Y+6	; 0x06
    6220:	8f 81       	ldd	r24, Y+7	; 0x07
    6222:	98 85       	ldd	r25, Y+8	; 0x08
    6224:	60 96       	adiw	r28, 0x10	; 16
    6226:	cd bf       	out	0x3d, r28	; 61
    6228:	de bf       	out	0x3e, r29	; 62
    622a:	df 91       	pop	r29
    622c:	cf 91       	pop	r28
    622e:	0f 91       	pop	r16
    6230:	08 95       	ret

00006232 <__divdi3>:
    6232:	a8 e4       	ldi	r26, 0x48	; 72
    6234:	b0 e0       	ldi	r27, 0x00	; 0
    6236:	ef e1       	ldi	r30, 0x1F	; 31
    6238:	f1 e3       	ldi	r31, 0x31	; 49
    623a:	0c 94 08 3b 	jmp	0x7610	; 0x7610 <__prologue_saves__+0x2>
    623e:	f5 01       	movw	r30, r10
    6240:	29 a3       	lds	r18, 0x59
    6242:	3a a3       	lds	r19, 0x5a
    6244:	4b a3       	lds	r20, 0x5b
    6246:	5c a3       	lds	r21, 0x5c
    6248:	6d a3       	lds	r22, 0x5d
    624a:	7e a3       	lds	r23, 0x5e
    624c:	8f a3       	lds	r24, 0x5f
    624e:	98 a7       	lds	r25, 0x78
    6250:	a9 8e       	std	Y+25, r10	; 0x19
    6252:	fa 8f       	std	Y+26, r31	; 0x1a
    6254:	cb 8e       	std	Y+27, r12	; 0x1b
    6256:	dc 8e       	std	Y+28, r13	; 0x1c
    6258:	ed 8e       	std	Y+29, r14	; 0x1d
    625a:	fe 8e       	std	Y+30, r15	; 0x1e
    625c:	0f 8f       	std	Y+31, r16	; 0x1f
    625e:	18 a3       	lds	r17, 0x58
    6260:	8d a0       	lds	r24, 0x8d
    6262:	9e a0       	lds	r25, 0x8e
    6264:	af a0       	lds	r26, 0x8f
    6266:	b8 a4       	lds	r27, 0xa8
    6268:	b7 fe       	sbrs	r11, 7
    626a:	67 c0       	rjmp	.+206    	; 0x633a <__divdi3+0x108>
    626c:	21 95       	neg	r18
    626e:	b1 e0       	ldi	r27, 0x01	; 1
    6270:	12 16       	cp	r1, r18
    6272:	08 f0       	brcs	.+2      	; 0x6276 <__divdi3+0x44>
    6274:	b0 e0       	ldi	r27, 0x00	; 0
    6276:	31 95       	neg	r19
    6278:	a1 e0       	ldi	r26, 0x01	; 1
    627a:	13 16       	cp	r1, r19
    627c:	08 f0       	brcs	.+2      	; 0x6280 <__divdi3+0x4e>
    627e:	a0 e0       	ldi	r26, 0x00	; 0
    6280:	b3 2e       	mov	r11, r19
    6282:	bb 1a       	sub	r11, r27
    6284:	bb 2d       	mov	r27, r11
    6286:	88 24       	eor	r8, r8
    6288:	83 94       	inc	r8
    628a:	3b 15       	cp	r19, r11
    628c:	08 f0       	brcs	.+2      	; 0x6290 <__divdi3+0x5e>
    628e:	88 24       	eor	r8, r8
    6290:	a8 29       	or	r26, r8
    6292:	41 95       	neg	r20
    6294:	31 e0       	ldi	r19, 0x01	; 1
    6296:	14 16       	cp	r1, r20
    6298:	08 f0       	brcs	.+2      	; 0x629c <__divdi3+0x6a>
    629a:	30 e0       	ldi	r19, 0x00	; 0
    629c:	b4 2e       	mov	r11, r20
    629e:	ba 1a       	sub	r11, r26
    62a0:	ab 2d       	mov	r26, r11
    62a2:	88 24       	eor	r8, r8
    62a4:	83 94       	inc	r8
    62a6:	4b 15       	cp	r20, r11
    62a8:	08 f0       	brcs	.+2      	; 0x62ac <__divdi3+0x7a>
    62aa:	88 24       	eor	r8, r8
    62ac:	38 29       	or	r19, r8
    62ae:	51 95       	neg	r21
    62b0:	41 e0       	ldi	r20, 0x01	; 1
    62b2:	15 16       	cp	r1, r21
    62b4:	08 f0       	brcs	.+2      	; 0x62b8 <__divdi3+0x86>
    62b6:	40 e0       	ldi	r20, 0x00	; 0
    62b8:	45 2e       	mov	r4, r21
    62ba:	43 1a       	sub	r4, r19
    62bc:	31 e0       	ldi	r19, 0x01	; 1
    62be:	54 15       	cp	r21, r4
    62c0:	08 f0       	brcs	.+2      	; 0x62c4 <__divdi3+0x92>
    62c2:	30 e0       	ldi	r19, 0x00	; 0
    62c4:	43 2b       	or	r20, r19
    62c6:	61 95       	neg	r22
    62c8:	31 e0       	ldi	r19, 0x01	; 1
    62ca:	16 16       	cp	r1, r22
    62cc:	08 f0       	brcs	.+2      	; 0x62d0 <__divdi3+0x9e>
    62ce:	30 e0       	ldi	r19, 0x00	; 0
    62d0:	86 2e       	mov	r8, r22
    62d2:	84 1a       	sub	r8, r20
    62d4:	41 e0       	ldi	r20, 0x01	; 1
    62d6:	68 15       	cp	r22, r8
    62d8:	08 f0       	brcs	.+2      	; 0x62dc <__divdi3+0xaa>
    62da:	40 e0       	ldi	r20, 0x00	; 0
    62dc:	34 2b       	or	r19, r20
    62de:	71 95       	neg	r23
    62e0:	41 e0       	ldi	r20, 0x01	; 1
    62e2:	17 16       	cp	r1, r23
    62e4:	08 f0       	brcs	.+2      	; 0x62e8 <__divdi3+0xb6>
    62e6:	40 e0       	ldi	r20, 0x00	; 0
    62e8:	57 2f       	mov	r21, r23
    62ea:	53 1b       	sub	r21, r19
    62ec:	31 e0       	ldi	r19, 0x01	; 1
    62ee:	75 17       	cp	r23, r21
    62f0:	08 f0       	brcs	.+2      	; 0x62f4 <__divdi3+0xc2>
    62f2:	30 e0       	ldi	r19, 0x00	; 0
    62f4:	43 2b       	or	r20, r19
    62f6:	81 95       	neg	r24
    62f8:	31 e0       	ldi	r19, 0x01	; 1
    62fa:	18 16       	cp	r1, r24
    62fc:	08 f0       	brcs	.+2      	; 0x6300 <__divdi3+0xce>
    62fe:	30 e0       	ldi	r19, 0x00	; 0
    6300:	68 2f       	mov	r22, r24
    6302:	64 1b       	sub	r22, r20
    6304:	46 2f       	mov	r20, r22
    6306:	61 e0       	ldi	r22, 0x01	; 1
    6308:	84 17       	cp	r24, r20
    630a:	08 f0       	brcs	.+2      	; 0x630e <__divdi3+0xdc>
    630c:	60 e0       	ldi	r22, 0x00	; 0
    630e:	36 2b       	or	r19, r22
    6310:	91 95       	neg	r25
    6312:	93 1b       	sub	r25, r19
    6314:	29 a3       	lds	r18, 0x59
    6316:	ba a3       	lds	r27, 0x5a
    6318:	ab a3       	lds	r26, 0x5b
    631a:	4c a2       	lds	r20, 0x9c
    631c:	8d a2       	lds	r24, 0x9d
    631e:	5e a3       	lds	r21, 0x5e
    6320:	4f a3       	lds	r20, 0x5f
    6322:	98 a7       	lds	r25, 0x78
    6324:	8f ef       	ldi	r24, 0xFF	; 255
    6326:	9f ef       	ldi	r25, 0xFF	; 255
    6328:	af ef       	ldi	r26, 0xFF	; 255
    632a:	bf ef       	ldi	r27, 0xFF	; 255
    632c:	25 96       	adiw	r28, 0x05	; 5
    632e:	8c af       	sts	0x7c, r24
    6330:	9d af       	sts	0x7d, r25
    6332:	ae af       	sts	0x7e, r26
    6334:	bf af       	sts	0x7f, r27
    6336:	25 97       	sbiw	r28, 0x05	; 5
    6338:	06 c0       	rjmp	.+12     	; 0x6346 <__divdi3+0x114>
    633a:	25 96       	adiw	r28, 0x05	; 5
    633c:	1c ae       	sts	0xbc, r17
    633e:	1d ae       	sts	0xbd, r17
    6340:	1e ae       	sts	0xbe, r17
    6342:	1f ae       	sts	0xbf, r17
    6344:	25 97       	sbiw	r28, 0x05	; 5
    6346:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6348:	9e 8d       	ldd	r25, Y+30	; 0x1e
    634a:	af 8d       	ldd	r26, Y+31	; 0x1f
    634c:	b8 a1       	lds	r27, 0x48
    634e:	b7 ff       	sbrs	r27, 7
    6350:	68 c0       	rjmp	.+208    	; 0x6422 <__divdi3+0x1f0>
    6352:	25 96       	adiw	r28, 0x05	; 5
    6354:	2c ad       	sts	0x6c, r18
    6356:	3d ad       	sts	0x6d, r19
    6358:	4e ad       	sts	0x6e, r20
    635a:	5f ad       	sts	0x6f, r21
    635c:	25 97       	sbiw	r28, 0x05	; 5
    635e:	20 95       	com	r18
    6360:	30 95       	com	r19
    6362:	40 95       	com	r20
    6364:	50 95       	com	r21
    6366:	25 96       	adiw	r28, 0x05	; 5
    6368:	2c af       	sts	0x7c, r18
    636a:	3d af       	sts	0x7d, r19
    636c:	4e af       	sts	0x7e, r20
    636e:	5f af       	sts	0x7f, r21
    6370:	25 97       	sbiw	r28, 0x05	; 5
    6372:	e1 95       	neg	r30
    6374:	81 e0       	ldi	r24, 0x01	; 1
    6376:	1e 16       	cp	r1, r30
    6378:	08 f0       	brcs	.+2      	; 0x637c <__divdi3+0x14a>
    637a:	80 e0       	ldi	r24, 0x00	; 0
    637c:	f1 95       	neg	r31
    637e:	91 e0       	ldi	r25, 0x01	; 1
    6380:	1f 16       	cp	r1, r31
    6382:	08 f0       	brcs	.+2      	; 0x6386 <__divdi3+0x154>
    6384:	90 e0       	ldi	r25, 0x00	; 0
    6386:	4f 2f       	mov	r20, r31
    6388:	48 1b       	sub	r20, r24
    638a:	81 e0       	ldi	r24, 0x01	; 1
    638c:	f4 17       	cp	r31, r20
    638e:	08 f0       	brcs	.+2      	; 0x6392 <__divdi3+0x160>
    6390:	80 e0       	ldi	r24, 0x00	; 0
    6392:	98 2b       	or	r25, r24
    6394:	c1 94       	neg	r12
    6396:	81 e0       	ldi	r24, 0x01	; 1
    6398:	1c 14       	cp	r1, r12
    639a:	08 f0       	brcs	.+2      	; 0x639e <__divdi3+0x16c>
    639c:	80 e0       	ldi	r24, 0x00	; 0
    639e:	6c 2d       	mov	r22, r12
    63a0:	69 1b       	sub	r22, r25
    63a2:	91 e0       	ldi	r25, 0x01	; 1
    63a4:	c6 16       	cp	r12, r22
    63a6:	08 f0       	brcs	.+2      	; 0x63aa <__divdi3+0x178>
    63a8:	90 e0       	ldi	r25, 0x00	; 0
    63aa:	89 2b       	or	r24, r25
    63ac:	d1 94       	neg	r13
    63ae:	91 e0       	ldi	r25, 0x01	; 1
    63b0:	1d 14       	cp	r1, r13
    63b2:	08 f0       	brcs	.+2      	; 0x63b6 <__divdi3+0x184>
    63b4:	90 e0       	ldi	r25, 0x00	; 0
    63b6:	5d 2d       	mov	r21, r13
    63b8:	58 1b       	sub	r21, r24
    63ba:	81 e0       	ldi	r24, 0x01	; 1
    63bc:	d5 16       	cp	r13, r21
    63be:	08 f0       	brcs	.+2      	; 0x63c2 <__divdi3+0x190>
    63c0:	80 e0       	ldi	r24, 0x00	; 0
    63c2:	98 2b       	or	r25, r24
    63c4:	e1 94       	neg	r14
    63c6:	81 e0       	ldi	r24, 0x01	; 1
    63c8:	1e 14       	cp	r1, r14
    63ca:	08 f0       	brcs	.+2      	; 0x63ce <__divdi3+0x19c>
    63cc:	80 e0       	ldi	r24, 0x00	; 0
    63ce:	3e 2d       	mov	r19, r14
    63d0:	39 1b       	sub	r19, r25
    63d2:	91 e0       	ldi	r25, 0x01	; 1
    63d4:	e3 16       	cp	r14, r19
    63d6:	08 f0       	brcs	.+2      	; 0x63da <__divdi3+0x1a8>
    63d8:	90 e0       	ldi	r25, 0x00	; 0
    63da:	89 2b       	or	r24, r25
    63dc:	f1 94       	neg	r15
    63de:	91 e0       	ldi	r25, 0x01	; 1
    63e0:	1f 14       	cp	r1, r15
    63e2:	08 f0       	brcs	.+2      	; 0x63e6 <__divdi3+0x1b4>
    63e4:	90 e0       	ldi	r25, 0x00	; 0
    63e6:	2f 2d       	mov	r18, r15
    63e8:	28 1b       	sub	r18, r24
    63ea:	81 e0       	ldi	r24, 0x01	; 1
    63ec:	f2 16       	cp	r15, r18
    63ee:	08 f0       	brcs	.+2      	; 0x63f2 <__divdi3+0x1c0>
    63f0:	80 e0       	ldi	r24, 0x00	; 0
    63f2:	98 2b       	or	r25, r24
    63f4:	01 95       	neg	r16
    63f6:	81 e0       	ldi	r24, 0x01	; 1
    63f8:	10 16       	cp	r1, r16
    63fa:	08 f0       	brcs	.+2      	; 0x63fe <__divdi3+0x1cc>
    63fc:	80 e0       	ldi	r24, 0x00	; 0
    63fe:	70 2f       	mov	r23, r16
    6400:	79 1b       	sub	r23, r25
    6402:	97 2f       	mov	r25, r23
    6404:	71 e0       	ldi	r23, 0x01	; 1
    6406:	09 17       	cp	r16, r25
    6408:	08 f0       	brcs	.+2      	; 0x640c <__divdi3+0x1da>
    640a:	70 e0       	ldi	r23, 0x00	; 0
    640c:	87 2b       	or	r24, r23
    640e:	11 95       	neg	r17
    6410:	18 1b       	sub	r17, r24
    6412:	e9 8f       	std	Y+25, r30	; 0x19
    6414:	4a 8f       	std	Y+26, r20	; 0x1a
    6416:	6b 8f       	std	Y+27, r22	; 0x1b
    6418:	5c 8f       	std	Y+28, r21	; 0x1c
    641a:	3d 8f       	std	Y+29, r19	; 0x1d
    641c:	2e 8f       	std	Y+30, r18	; 0x1e
    641e:	9f 8f       	std	Y+31, r25	; 0x1f
    6420:	18 a3       	lds	r17, 0x58
    6422:	79 8d       	ldd	r23, Y+25	; 0x19
    6424:	6a 8d       	ldd	r22, Y+26	; 0x1a
    6426:	5b 8d       	ldd	r21, Y+27	; 0x1b
    6428:	4c 8d       	ldd	r20, Y+28	; 0x1c
    642a:	3d 8d       	ldd	r19, Y+29	; 0x1d
    642c:	2e 8d       	ldd	r18, Y+30	; 0x1e
    642e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6430:	88 a1       	lds	r24, 0x48
    6432:	e9 a1       	lds	r30, 0x49
    6434:	e9 8b       	std	Y+17, r30	; 0x11
    6436:	ea a1       	lds	r30, 0x4a
    6438:	ea 8b       	std	Y+18, r30	; 0x12
    643a:	eb a1       	lds	r30, 0x4b
    643c:	eb 8b       	std	Y+19, r30	; 0x13
    643e:	ec a1       	lds	r30, 0x4c
    6440:	ec 8b       	std	Y+20, r30	; 0x14
    6442:	ed a1       	lds	r30, 0x4d
    6444:	ed 8b       	std	Y+21, r30	; 0x15
    6446:	ee a1       	lds	r30, 0x4e
    6448:	ee 8b       	std	Y+22, r30	; 0x16
    644a:	ef a1       	lds	r30, 0x4f
    644c:	ef 8b       	std	Y+23, r30	; 0x17
    644e:	e8 a5       	lds	r30, 0x68
    6450:	e8 8f       	std	Y+24, r30	; 0x18
    6452:	79 87       	std	Y+9, r23	; 0x09
    6454:	6a 87       	std	Y+10, r22	; 0x0a
    6456:	5b 87       	std	Y+11, r21	; 0x0b
    6458:	4c 87       	std	Y+12, r20	; 0x0c
    645a:	3d 87       	std	Y+13, r19	; 0x0d
    645c:	2e 87       	std	Y+14, r18	; 0x0e
    645e:	9f 87       	std	Y+15, r25	; 0x0f
    6460:	88 8b       	std	Y+16, r24	; 0x10
    6462:	89 84       	ldd	r8, Y+9	; 0x09
    6464:	9a 84       	ldd	r9, Y+10	; 0x0a
    6466:	ab 84       	ldd	r10, Y+11	; 0x0b
    6468:	bc 84       	ldd	r11, Y+12	; 0x0c
    646a:	8d 85       	ldd	r24, Y+13	; 0x0d
    646c:	9e 85       	ldd	r25, Y+14	; 0x0e
    646e:	af 85       	ldd	r26, Y+15	; 0x0f
    6470:	b8 89       	ldd	r27, Y+16	; 0x10
    6472:	e9 88       	ldd	r14, Y+17	; 0x11
    6474:	fa 88       	ldd	r15, Y+18	; 0x12
    6476:	0b 89       	ldd	r16, Y+19	; 0x13
    6478:	1c 89       	ldd	r17, Y+20	; 0x14
    647a:	ed aa       	sts	0x9d, r30
    647c:	fe aa       	sts	0x9e, r31
    647e:	0f ab       	sts	0x5f, r16
    6480:	18 af       	sts	0x78, r17
    6482:	cd 88       	ldd	r12, Y+21	; 0x15
    6484:	de 88       	ldd	r13, Y+22	; 0x16
    6486:	ef 88       	ldd	r14, Y+23	; 0x17
    6488:	f8 8c       	ldd	r15, Y+24	; 0x18
    648a:	00 97       	sbiw	r24, 0x00	; 0
    648c:	a1 05       	cpc	r26, r1
    648e:	b1 05       	cpc	r27, r1
    6490:	09 f0       	breq	.+2      	; 0x6494 <__divdi3+0x262>
    6492:	bd c3       	rjmp	.+1914   	; 0x6c0e <__divdi3+0x9dc>
    6494:	c8 14       	cp	r12, r8
    6496:	d9 04       	cpc	r13, r9
    6498:	ea 04       	cpc	r14, r10
    649a:	fb 04       	cpc	r15, r11
    649c:	08 f0       	brcs	.+2      	; 0x64a0 <__divdi3+0x26e>
    649e:	4d c1       	rjmp	.+666    	; 0x673a <__divdi3+0x508>
    64a0:	00 e0       	ldi	r16, 0x00	; 0
    64a2:	80 16       	cp	r8, r16
    64a4:	00 e0       	ldi	r16, 0x00	; 0
    64a6:	90 06       	cpc	r9, r16
    64a8:	01 e0       	ldi	r16, 0x01	; 1
    64aa:	a0 06       	cpc	r10, r16
    64ac:	00 e0       	ldi	r16, 0x00	; 0
    64ae:	b0 06       	cpc	r11, r16
    64b0:	58 f4       	brcc	.+22     	; 0x64c8 <__divdi3+0x296>
    64b2:	1f ef       	ldi	r17, 0xFF	; 255
    64b4:	81 16       	cp	r8, r17
    64b6:	91 04       	cpc	r9, r1
    64b8:	a1 04       	cpc	r10, r1
    64ba:	b1 04       	cpc	r11, r1
    64bc:	09 f0       	breq	.+2      	; 0x64c0 <__divdi3+0x28e>
    64be:	90 f4       	brcc	.+36     	; 0x64e4 <__divdi3+0x2b2>
    64c0:	80 e0       	ldi	r24, 0x00	; 0
    64c2:	90 e0       	ldi	r25, 0x00	; 0
    64c4:	dc 01       	movw	r26, r24
    64c6:	17 c0       	rjmp	.+46     	; 0x64f6 <__divdi3+0x2c4>
    64c8:	20 e0       	ldi	r18, 0x00	; 0
    64ca:	82 16       	cp	r8, r18
    64cc:	20 e0       	ldi	r18, 0x00	; 0
    64ce:	92 06       	cpc	r9, r18
    64d0:	20 e0       	ldi	r18, 0x00	; 0
    64d2:	a2 06       	cpc	r10, r18
    64d4:	21 e0       	ldi	r18, 0x01	; 1
    64d6:	b2 06       	cpc	r11, r18
    64d8:	50 f4       	brcc	.+20     	; 0x64ee <__divdi3+0x2bc>
    64da:	80 e1       	ldi	r24, 0x10	; 16
    64dc:	90 e0       	ldi	r25, 0x00	; 0
    64de:	a0 e0       	ldi	r26, 0x00	; 0
    64e0:	b0 e0       	ldi	r27, 0x00	; 0
    64e2:	09 c0       	rjmp	.+18     	; 0x64f6 <__divdi3+0x2c4>
    64e4:	88 e0       	ldi	r24, 0x08	; 8
    64e6:	90 e0       	ldi	r25, 0x00	; 0
    64e8:	a0 e0       	ldi	r26, 0x00	; 0
    64ea:	b0 e0       	ldi	r27, 0x00	; 0
    64ec:	04 c0       	rjmp	.+8      	; 0x64f6 <__divdi3+0x2c4>
    64ee:	88 e1       	ldi	r24, 0x18	; 24
    64f0:	90 e0       	ldi	r25, 0x00	; 0
    64f2:	a0 e0       	ldi	r26, 0x00	; 0
    64f4:	b0 e0       	ldi	r27, 0x00	; 0
    64f6:	b5 01       	movw	r22, r10
    64f8:	a4 01       	movw	r20, r8
    64fa:	08 2e       	mov	r0, r24
    64fc:	04 c0       	rjmp	.+8      	; 0x6506 <__divdi3+0x2d4>
    64fe:	76 95       	lsr	r23
    6500:	67 95       	ror	r22
    6502:	57 95       	ror	r21
    6504:	47 95       	ror	r20
    6506:	0a 94       	dec	r0
    6508:	d2 f7       	brpl	.-12     	; 0x64fe <__divdi3+0x2cc>
    650a:	fa 01       	movw	r30, r20
    650c:	e9 5c       	subi	r30, 0xC9	; 201
    650e:	ff 4d       	sbci	r31, 0xDF	; 223
    6510:	20 81       	ld	r18, Z
    6512:	40 e2       	ldi	r20, 0x20	; 32
    6514:	50 e0       	ldi	r21, 0x00	; 0
    6516:	60 e0       	ldi	r22, 0x00	; 0
    6518:	70 e0       	ldi	r23, 0x00	; 0
    651a:	48 1b       	sub	r20, r24
    651c:	59 0b       	sbc	r21, r25
    651e:	6a 0b       	sbc	r22, r26
    6520:	7b 0b       	sbc	r23, r27
    6522:	42 1b       	sub	r20, r18
    6524:	51 09       	sbc	r21, r1
    6526:	61 09       	sbc	r22, r1
    6528:	71 09       	sbc	r23, r1
    652a:	41 15       	cp	r20, r1
    652c:	51 05       	cpc	r21, r1
    652e:	61 05       	cpc	r22, r1
    6530:	71 05       	cpc	r23, r1
    6532:	a1 f1       	breq	.+104    	; 0x659c <__divdi3+0x36a>
    6534:	04 2e       	mov	r0, r20
    6536:	04 c0       	rjmp	.+8      	; 0x6540 <__divdi3+0x30e>
    6538:	88 0c       	add	r8, r8
    653a:	99 1c       	adc	r9, r9
    653c:	aa 1c       	adc	r10, r10
    653e:	bb 1c       	adc	r11, r11
    6540:	0a 94       	dec	r0
    6542:	d2 f7       	brpl	.-12     	; 0x6538 <__divdi3+0x306>
    6544:	97 01       	movw	r18, r14
    6546:	86 01       	movw	r16, r12
    6548:	04 2e       	mov	r0, r20
    654a:	04 c0       	rjmp	.+8      	; 0x6554 <__divdi3+0x322>
    654c:	00 0f       	add	r16, r16
    654e:	11 1f       	adc	r17, r17
    6550:	22 1f       	adc	r18, r18
    6552:	33 1f       	adc	r19, r19
    6554:	0a 94       	dec	r0
    6556:	d2 f7       	brpl	.-12     	; 0x654c <__divdi3+0x31a>
    6558:	80 e2       	ldi	r24, 0x20	; 32
    655a:	90 e0       	ldi	r25, 0x00	; 0
    655c:	84 1b       	sub	r24, r20
    655e:	95 0b       	sbc	r25, r21
    6560:	cd a8       	sts	0x8d, r28
    6562:	de a8       	sts	0x8e, r29
    6564:	ef a8       	sts	0x8f, r30
    6566:	f8 ac       	sts	0xa8, r31
    6568:	04 c0       	rjmp	.+8      	; 0x6572 <__divdi3+0x340>
    656a:	f6 94       	lsr	r15
    656c:	e7 94       	ror	r14
    656e:	d7 94       	ror	r13
    6570:	c7 94       	ror	r12
    6572:	8a 95       	dec	r24
    6574:	d2 f7       	brpl	.-12     	; 0x656a <__divdi3+0x338>
    6576:	c0 2a       	or	r12, r16
    6578:	d1 2a       	or	r13, r17
    657a:	e2 2a       	or	r14, r18
    657c:	f3 2a       	or	r15, r19
    657e:	0d a9       	sts	0x4d, r16
    6580:	1e a9       	sts	0x4e, r17
    6582:	2f a9       	sts	0x4f, r18
    6584:	38 ad       	sts	0x68, r19
    6586:	04 c0       	rjmp	.+8      	; 0x6590 <__divdi3+0x35e>
    6588:	00 0f       	add	r16, r16
    658a:	11 1f       	adc	r17, r17
    658c:	22 1f       	adc	r18, r18
    658e:	33 1f       	adc	r19, r19
    6590:	4a 95       	dec	r20
    6592:	d2 f7       	brpl	.-12     	; 0x6588 <__divdi3+0x356>
    6594:	0d ab       	sts	0x5d, r16
    6596:	1e ab       	sts	0x5e, r17
    6598:	2f ab       	sts	0x5f, r18
    659a:	38 af       	sts	0x78, r19
    659c:	25 01       	movw	r4, r10
    659e:	66 24       	eor	r6, r6
    65a0:	77 24       	eor	r7, r7
    65a2:	95 01       	movw	r18, r10
    65a4:	84 01       	movw	r16, r8
    65a6:	20 70       	andi	r18, 0x00	; 0
    65a8:	30 70       	andi	r19, 0x00	; 0
    65aa:	09 ab       	sts	0x59, r16
    65ac:	1a ab       	sts	0x5a, r17
    65ae:	2b ab       	sts	0x5b, r18
    65b0:	3c ab       	sts	0x5c, r19
    65b2:	c7 01       	movw	r24, r14
    65b4:	b6 01       	movw	r22, r12
    65b6:	a3 01       	movw	r20, r6
    65b8:	92 01       	movw	r18, r4
    65ba:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    65be:	2d a7       	lds	r18, 0x7d
    65c0:	3e a7       	lds	r19, 0x7e
    65c2:	4f a7       	lds	r20, 0x7f
    65c4:	58 ab       	sts	0x58, r21
    65c6:	69 a7       	lds	r22, 0x79
    65c8:	7a a7       	lds	r23, 0x7a
    65ca:	8b a7       	lds	r24, 0x7b
    65cc:	9c a7       	lds	r25, 0x7c
    65ce:	c7 01       	movw	r24, r14
    65d0:	b6 01       	movw	r22, r12
    65d2:	a3 01       	movw	r20, r6
    65d4:	92 01       	movw	r18, r4
    65d6:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    65da:	ca 01       	movw	r24, r20
    65dc:	b9 01       	movw	r22, r18
    65de:	29 a9       	sts	0x49, r18
    65e0:	3a a9       	sts	0x4a, r19
    65e2:	4b a9       	sts	0x4b, r20
    65e4:	5c a9       	sts	0x4c, r21
    65e6:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    65ea:	ab 01       	movw	r20, r22
    65ec:	bc 01       	movw	r22, r24
    65ee:	09 a5       	lds	r16, 0x69
    65f0:	1a a5       	lds	r17, 0x6a
    65f2:	2b a5       	lds	r18, 0x6b
    65f4:	3c a5       	lds	r19, 0x6c
    65f6:	78 01       	movw	r14, r16
    65f8:	dd 24       	eor	r13, r13
    65fa:	cc 24       	eor	r12, r12
    65fc:	0d a9       	sts	0x4d, r16
    65fe:	1e a9       	sts	0x4e, r17
    6600:	2f a9       	sts	0x4f, r18
    6602:	38 ad       	sts	0x68, r19
    6604:	c9 01       	movw	r24, r18
    6606:	aa 27       	eor	r26, r26
    6608:	bb 27       	eor	r27, r27
    660a:	c8 2a       	or	r12, r24
    660c:	d9 2a       	or	r13, r25
    660e:	ea 2a       	or	r14, r26
    6610:	fb 2a       	or	r15, r27
    6612:	0d a5       	lds	r16, 0x6d
    6614:	1e a5       	lds	r17, 0x6e
    6616:	2f a5       	lds	r18, 0x6f
    6618:	38 a9       	sts	0x48, r19
    661a:	c4 16       	cp	r12, r20
    661c:	d5 06       	cpc	r13, r21
    661e:	e6 06       	cpc	r14, r22
    6620:	f7 06       	cpc	r15, r23
    6622:	38 f5       	brcc	.+78     	; 0x6672 <__divdi3+0x440>
    6624:	01 50       	subi	r16, 0x01	; 1
    6626:	10 40       	sbci	r17, 0x00	; 0
    6628:	20 40       	sbci	r18, 0x00	; 0
    662a:	30 40       	sbci	r19, 0x00	; 0
    662c:	09 a7       	lds	r16, 0x79
    662e:	1a a7       	lds	r17, 0x7a
    6630:	2b a7       	lds	r18, 0x7b
    6632:	3c a7       	lds	r19, 0x7c
    6634:	c8 0c       	add	r12, r8
    6636:	d9 1c       	adc	r13, r9
    6638:	ea 1c       	adc	r14, r10
    663a:	fb 1c       	adc	r15, r11
    663c:	c8 14       	cp	r12, r8
    663e:	d9 04       	cpc	r13, r9
    6640:	ea 04       	cpc	r14, r10
    6642:	fb 04       	cpc	r15, r11
    6644:	d0 f0       	brcs	.+52     	; 0x667a <__divdi3+0x448>
    6646:	c4 16       	cp	r12, r20
    6648:	d5 06       	cpc	r13, r21
    664a:	e6 06       	cpc	r14, r22
    664c:	f7 06       	cpc	r15, r23
    664e:	a8 f4       	brcc	.+42     	; 0x667a <__divdi3+0x448>
    6650:	0d a5       	lds	r16, 0x6d
    6652:	1e a5       	lds	r17, 0x6e
    6654:	2f a5       	lds	r18, 0x6f
    6656:	38 a9       	sts	0x48, r19
    6658:	02 50       	subi	r16, 0x02	; 2
    665a:	10 40       	sbci	r17, 0x00	; 0
    665c:	20 40       	sbci	r18, 0x00	; 0
    665e:	30 40       	sbci	r19, 0x00	; 0
    6660:	09 a7       	lds	r16, 0x79
    6662:	1a a7       	lds	r17, 0x7a
    6664:	2b a7       	lds	r18, 0x7b
    6666:	3c a7       	lds	r19, 0x7c
    6668:	c8 0c       	add	r12, r8
    666a:	d9 1c       	adc	r13, r9
    666c:	ea 1c       	adc	r14, r10
    666e:	fb 1c       	adc	r15, r11
    6670:	04 c0       	rjmp	.+8      	; 0x667a <__divdi3+0x448>
    6672:	09 a7       	lds	r16, 0x79
    6674:	1a a7       	lds	r17, 0x7a
    6676:	2b a7       	lds	r18, 0x7b
    6678:	3c a7       	lds	r19, 0x7c
    667a:	c4 1a       	sub	r12, r20
    667c:	d5 0a       	sbc	r13, r21
    667e:	e6 0a       	sbc	r14, r22
    6680:	f7 0a       	sbc	r15, r23
    6682:	c7 01       	movw	r24, r14
    6684:	b6 01       	movw	r22, r12
    6686:	a3 01       	movw	r20, r6
    6688:	92 01       	movw	r18, r4
    668a:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    668e:	2d a7       	lds	r18, 0x7d
    6690:	3e a7       	lds	r19, 0x7e
    6692:	4f a7       	lds	r20, 0x7f
    6694:	58 ab       	sts	0x58, r21
    6696:	69 af       	sts	0x79, r22
    6698:	7a af       	sts	0x7a, r23
    669a:	8b af       	sts	0x7b, r24
    669c:	9c af       	sts	0x7c, r25
    669e:	c7 01       	movw	r24, r14
    66a0:	b6 01       	movw	r22, r12
    66a2:	a3 01       	movw	r20, r6
    66a4:	92 01       	movw	r18, r4
    66a6:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    66aa:	ca 01       	movw	r24, r20
    66ac:	b9 01       	movw	r22, r18
    66ae:	29 a9       	sts	0x49, r18
    66b0:	3a a9       	sts	0x4a, r19
    66b2:	4b a9       	sts	0x4b, r20
    66b4:	5c a9       	sts	0x4c, r21
    66b6:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    66ba:	6b 01       	movw	r12, r22
    66bc:	7c 01       	movw	r14, r24
    66be:	49 ad       	sts	0x69, r20
    66c0:	5a ad       	sts	0x6a, r21
    66c2:	6b ad       	sts	0x6b, r22
    66c4:	7c ad       	sts	0x6c, r23
    66c6:	9a 01       	movw	r18, r20
    66c8:	11 27       	eor	r17, r17
    66ca:	00 27       	eor	r16, r16
    66cc:	4d a9       	sts	0x4d, r20
    66ce:	5e a9       	sts	0x4e, r21
    66d0:	6f a9       	sts	0x4f, r22
    66d2:	78 ad       	sts	0x68, r23
    66d4:	60 70       	andi	r22, 0x00	; 0
    66d6:	70 70       	andi	r23, 0x00	; 0
    66d8:	04 2b       	or	r16, r20
    66da:	15 2b       	or	r17, r21
    66dc:	26 2b       	or	r18, r22
    66de:	37 2b       	or	r19, r23
    66e0:	8d a5       	lds	r24, 0x6d
    66e2:	9e a5       	lds	r25, 0x6e
    66e4:	af a5       	lds	r26, 0x6f
    66e6:	b8 a9       	sts	0x48, r27
    66e8:	0c 15       	cp	r16, r12
    66ea:	1d 05       	cpc	r17, r13
    66ec:	2e 05       	cpc	r18, r14
    66ee:	3f 05       	cpc	r19, r15
    66f0:	c0 f4       	brcc	.+48     	; 0x6722 <__divdi3+0x4f0>
    66f2:	01 97       	sbiw	r24, 0x01	; 1
    66f4:	a1 09       	sbc	r26, r1
    66f6:	b1 09       	sbc	r27, r1
    66f8:	08 0d       	add	r16, r8
    66fa:	19 1d       	adc	r17, r9
    66fc:	2a 1d       	adc	r18, r10
    66fe:	3b 1d       	adc	r19, r11
    6700:	08 15       	cp	r16, r8
    6702:	19 05       	cpc	r17, r9
    6704:	2a 05       	cpc	r18, r10
    6706:	3b 05       	cpc	r19, r11
    6708:	60 f0       	brcs	.+24     	; 0x6722 <__divdi3+0x4f0>
    670a:	0c 15       	cp	r16, r12
    670c:	1d 05       	cpc	r17, r13
    670e:	2e 05       	cpc	r18, r14
    6710:	3f 05       	cpc	r19, r15
    6712:	38 f4       	brcc	.+14     	; 0x6722 <__divdi3+0x4f0>
    6714:	8d a5       	lds	r24, 0x6d
    6716:	9e a5       	lds	r25, 0x6e
    6718:	af a5       	lds	r26, 0x6f
    671a:	b8 a9       	sts	0x48, r27
    671c:	02 97       	sbiw	r24, 0x02	; 2
    671e:	a1 09       	sbc	r26, r1
    6720:	b1 09       	sbc	r27, r1
    6722:	09 a5       	lds	r16, 0x69
    6724:	1a a5       	lds	r17, 0x6a
    6726:	2b a5       	lds	r18, 0x6b
    6728:	3c a5       	lds	r19, 0x6c
    672a:	78 01       	movw	r14, r16
    672c:	dd 24       	eor	r13, r13
    672e:	cc 24       	eor	r12, r12
    6730:	c8 2a       	or	r12, r24
    6732:	d9 2a       	or	r13, r25
    6734:	ea 2a       	or	r14, r26
    6736:	fb 2a       	or	r15, r27
    6738:	b7 c4       	rjmp	.+2414   	; 0x70a8 <__divdi3+0xe76>
    673a:	81 14       	cp	r8, r1
    673c:	91 04       	cpc	r9, r1
    673e:	a1 04       	cpc	r10, r1
    6740:	b1 04       	cpc	r11, r1
    6742:	51 f4       	brne	.+20     	; 0x6758 <__divdi3+0x526>
    6744:	61 e0       	ldi	r22, 0x01	; 1
    6746:	70 e0       	ldi	r23, 0x00	; 0
    6748:	80 e0       	ldi	r24, 0x00	; 0
    674a:	90 e0       	ldi	r25, 0x00	; 0
    674c:	a5 01       	movw	r20, r10
    674e:	94 01       	movw	r18, r8
    6750:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    6754:	49 01       	movw	r8, r18
    6756:	5a 01       	movw	r10, r20
    6758:	10 e0       	ldi	r17, 0x00	; 0
    675a:	81 16       	cp	r8, r17
    675c:	10 e0       	ldi	r17, 0x00	; 0
    675e:	91 06       	cpc	r9, r17
    6760:	11 e0       	ldi	r17, 0x01	; 1
    6762:	a1 06       	cpc	r10, r17
    6764:	10 e0       	ldi	r17, 0x00	; 0
    6766:	b1 06       	cpc	r11, r17
    6768:	58 f4       	brcc	.+22     	; 0x6780 <__divdi3+0x54e>
    676a:	2f ef       	ldi	r18, 0xFF	; 255
    676c:	82 16       	cp	r8, r18
    676e:	91 04       	cpc	r9, r1
    6770:	a1 04       	cpc	r10, r1
    6772:	b1 04       	cpc	r11, r1
    6774:	09 f0       	breq	.+2      	; 0x6778 <__divdi3+0x546>
    6776:	90 f4       	brcc	.+36     	; 0x679c <__divdi3+0x56a>
    6778:	80 e0       	ldi	r24, 0x00	; 0
    677a:	90 e0       	ldi	r25, 0x00	; 0
    677c:	dc 01       	movw	r26, r24
    677e:	17 c0       	rjmp	.+46     	; 0x67ae <__divdi3+0x57c>
    6780:	30 e0       	ldi	r19, 0x00	; 0
    6782:	83 16       	cp	r8, r19
    6784:	30 e0       	ldi	r19, 0x00	; 0
    6786:	93 06       	cpc	r9, r19
    6788:	30 e0       	ldi	r19, 0x00	; 0
    678a:	a3 06       	cpc	r10, r19
    678c:	31 e0       	ldi	r19, 0x01	; 1
    678e:	b3 06       	cpc	r11, r19
    6790:	50 f4       	brcc	.+20     	; 0x67a6 <__divdi3+0x574>
    6792:	80 e1       	ldi	r24, 0x10	; 16
    6794:	90 e0       	ldi	r25, 0x00	; 0
    6796:	a0 e0       	ldi	r26, 0x00	; 0
    6798:	b0 e0       	ldi	r27, 0x00	; 0
    679a:	09 c0       	rjmp	.+18     	; 0x67ae <__divdi3+0x57c>
    679c:	88 e0       	ldi	r24, 0x08	; 8
    679e:	90 e0       	ldi	r25, 0x00	; 0
    67a0:	a0 e0       	ldi	r26, 0x00	; 0
    67a2:	b0 e0       	ldi	r27, 0x00	; 0
    67a4:	04 c0       	rjmp	.+8      	; 0x67ae <__divdi3+0x57c>
    67a6:	88 e1       	ldi	r24, 0x18	; 24
    67a8:	90 e0       	ldi	r25, 0x00	; 0
    67aa:	a0 e0       	ldi	r26, 0x00	; 0
    67ac:	b0 e0       	ldi	r27, 0x00	; 0
    67ae:	b5 01       	movw	r22, r10
    67b0:	a4 01       	movw	r20, r8
    67b2:	08 2e       	mov	r0, r24
    67b4:	04 c0       	rjmp	.+8      	; 0x67be <__divdi3+0x58c>
    67b6:	76 95       	lsr	r23
    67b8:	67 95       	ror	r22
    67ba:	57 95       	ror	r21
    67bc:	47 95       	ror	r20
    67be:	0a 94       	dec	r0
    67c0:	d2 f7       	brpl	.-12     	; 0x67b6 <__divdi3+0x584>
    67c2:	fa 01       	movw	r30, r20
    67c4:	e9 5c       	subi	r30, 0xC9	; 201
    67c6:	ff 4d       	sbci	r31, 0xDF	; 223
    67c8:	20 81       	ld	r18, Z
    67ca:	ac 01       	movw	r20, r24
    67cc:	bd 01       	movw	r22, r26
    67ce:	42 0f       	add	r20, r18
    67d0:	51 1d       	adc	r21, r1
    67d2:	61 1d       	adc	r22, r1
    67d4:	71 1d       	adc	r23, r1
    67d6:	80 e2       	ldi	r24, 0x20	; 32
    67d8:	90 e0       	ldi	r25, 0x00	; 0
    67da:	a0 e0       	ldi	r26, 0x00	; 0
    67dc:	b0 e0       	ldi	r27, 0x00	; 0
    67de:	84 1b       	sub	r24, r20
    67e0:	95 0b       	sbc	r25, r21
    67e2:	a6 0b       	sbc	r26, r22
    67e4:	b7 0b       	sbc	r27, r23
    67e6:	51 f4       	brne	.+20     	; 0x67fc <__divdi3+0x5ca>
    67e8:	c8 18       	sub	r12, r8
    67ea:	d9 08       	sbc	r13, r9
    67ec:	ea 08       	sbc	r14, r10
    67ee:	fb 08       	sbc	r15, r11
    67f0:	f1 e0       	ldi	r31, 0x01	; 1
    67f2:	4f 2e       	mov	r4, r31
    67f4:	51 2c       	mov	r5, r1
    67f6:	61 2c       	mov	r6, r1
    67f8:	71 2c       	mov	r7, r1
    67fa:	28 c1       	rjmp	.+592    	; 0x6a4c <__divdi3+0x81a>
    67fc:	08 2e       	mov	r0, r24
    67fe:	04 c0       	rjmp	.+8      	; 0x6808 <__divdi3+0x5d6>
    6800:	88 0c       	add	r8, r8
    6802:	99 1c       	adc	r9, r9
    6804:	aa 1c       	adc	r10, r10
    6806:	bb 1c       	adc	r11, r11
    6808:	0a 94       	dec	r0
    680a:	d2 f7       	brpl	.-12     	; 0x6800 <__divdi3+0x5ce>
    680c:	97 01       	movw	r18, r14
    680e:	86 01       	movw	r16, r12
    6810:	04 2e       	mov	r0, r20
    6812:	04 c0       	rjmp	.+8      	; 0x681c <__divdi3+0x5ea>
    6814:	36 95       	lsr	r19
    6816:	27 95       	ror	r18
    6818:	17 95       	ror	r17
    681a:	07 95       	ror	r16
    681c:	0a 94       	dec	r0
    681e:	d2 f7       	brpl	.-12     	; 0x6814 <__divdi3+0x5e2>
    6820:	09 ab       	sts	0x59, r16
    6822:	1a ab       	sts	0x5a, r17
    6824:	2b ab       	sts	0x5b, r18
    6826:	3c ab       	sts	0x5c, r19
    6828:	97 01       	movw	r18, r14
    682a:	86 01       	movw	r16, r12
    682c:	08 2e       	mov	r0, r24
    682e:	04 c0       	rjmp	.+8      	; 0x6838 <__divdi3+0x606>
    6830:	00 0f       	add	r16, r16
    6832:	11 1f       	adc	r17, r17
    6834:	22 1f       	adc	r18, r18
    6836:	33 1f       	adc	r19, r19
    6838:	0a 94       	dec	r0
    683a:	d2 f7       	brpl	.-12     	; 0x6830 <__divdi3+0x5fe>
    683c:	0d a7       	lds	r16, 0x7d
    683e:	1e a7       	lds	r17, 0x7e
    6840:	2f a7       	lds	r18, 0x7f
    6842:	38 ab       	sts	0x58, r19
    6844:	ed a8       	sts	0x8d, r30
    6846:	fe a8       	sts	0x8e, r31
    6848:	0f a9       	sts	0x4f, r16
    684a:	18 ad       	sts	0x68, r17
    684c:	04 c0       	rjmp	.+8      	; 0x6856 <__divdi3+0x624>
    684e:	16 95       	lsr	r17
    6850:	07 95       	ror	r16
    6852:	f7 94       	ror	r15
    6854:	e7 94       	ror	r14
    6856:	4a 95       	dec	r20
    6858:	d2 f7       	brpl	.-12     	; 0x684e <__divdi3+0x61c>
    685a:	b8 01       	movw	r22, r16
    685c:	a7 01       	movw	r20, r14
    685e:	0d a5       	lds	r16, 0x6d
    6860:	1e a5       	lds	r17, 0x6e
    6862:	2f a5       	lds	r18, 0x6f
    6864:	38 a9       	sts	0x48, r19
    6866:	04 2b       	or	r16, r20
    6868:	15 2b       	or	r17, r21
    686a:	26 2b       	or	r18, r22
    686c:	37 2b       	or	r19, r23
    686e:	0d a7       	lds	r16, 0x7d
    6870:	1e a7       	lds	r17, 0x7e
    6872:	2f a7       	lds	r18, 0x7f
    6874:	38 ab       	sts	0x58, r19
    6876:	ed a8       	sts	0x8d, r30
    6878:	fe a8       	sts	0x8e, r31
    687a:	0f a9       	sts	0x4f, r16
    687c:	18 ad       	sts	0x68, r17
    687e:	04 c0       	rjmp	.+8      	; 0x6888 <__divdi3+0x656>
    6880:	ee 0c       	add	r14, r14
    6882:	ff 1c       	adc	r15, r15
    6884:	00 1f       	adc	r16, r16
    6886:	11 1f       	adc	r17, r17
    6888:	8a 95       	dec	r24
    688a:	d2 f7       	brpl	.-12     	; 0x6880 <__divdi3+0x64e>
    688c:	ed aa       	sts	0x9d, r30
    688e:	fe aa       	sts	0x9e, r31
    6890:	0f ab       	sts	0x5f, r16
    6892:	18 af       	sts	0x78, r17
    6894:	25 01       	movw	r4, r10
    6896:	66 24       	eor	r6, r6
    6898:	77 24       	eor	r7, r7
    689a:	95 01       	movw	r18, r10
    689c:	84 01       	movw	r16, r8
    689e:	20 70       	andi	r18, 0x00	; 0
    68a0:	30 70       	andi	r19, 0x00	; 0
    68a2:	09 af       	sts	0x79, r16
    68a4:	1a af       	sts	0x7a, r17
    68a6:	2b af       	sts	0x7b, r18
    68a8:	3c af       	sts	0x7c, r19
    68aa:	69 a9       	sts	0x49, r22
    68ac:	7a a9       	sts	0x4a, r23
    68ae:	8b a9       	sts	0x4b, r24
    68b0:	9c a9       	sts	0x4c, r25
    68b2:	a3 01       	movw	r20, r6
    68b4:	92 01       	movw	r18, r4
    68b6:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    68ba:	29 a7       	lds	r18, 0x79
    68bc:	3a a7       	lds	r19, 0x7a
    68be:	4b a7       	lds	r20, 0x7b
    68c0:	5c a7       	lds	r21, 0x7c
    68c2:	6b 01       	movw	r12, r22
    68c4:	7c 01       	movw	r14, r24
    68c6:	69 a9       	sts	0x49, r22
    68c8:	7a a9       	sts	0x4a, r23
    68ca:	8b a9       	sts	0x4b, r24
    68cc:	9c a9       	sts	0x4c, r25
    68ce:	a3 01       	movw	r20, r6
    68d0:	92 01       	movw	r18, r4
    68d2:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    68d6:	ca 01       	movw	r24, r20
    68d8:	b9 01       	movw	r22, r18
    68da:	29 ad       	sts	0x69, r18
    68dc:	3a ad       	sts	0x6a, r19
    68de:	4b ad       	sts	0x6b, r20
    68e0:	5c ad       	sts	0x6c, r21
    68e2:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    68e6:	ab 01       	movw	r20, r22
    68e8:	bc 01       	movw	r22, r24
    68ea:	76 01       	movw	r14, r12
    68ec:	dd 24       	eor	r13, r13
    68ee:	cc 24       	eor	r12, r12
    68f0:	0d a5       	lds	r16, 0x6d
    68f2:	1e a5       	lds	r17, 0x6e
    68f4:	2f a5       	lds	r18, 0x6f
    68f6:	38 a9       	sts	0x48, r19
    68f8:	c9 01       	movw	r24, r18
    68fa:	aa 27       	eor	r26, r26
    68fc:	bb 27       	eor	r27, r27
    68fe:	c8 2a       	or	r12, r24
    6900:	d9 2a       	or	r13, r25
    6902:	ea 2a       	or	r14, r26
    6904:	fb 2a       	or	r15, r27
    6906:	09 a5       	lds	r16, 0x69
    6908:	1a a5       	lds	r17, 0x6a
    690a:	2b a5       	lds	r18, 0x6b
    690c:	3c a5       	lds	r19, 0x6c
    690e:	c4 16       	cp	r12, r20
    6910:	d5 06       	cpc	r13, r21
    6912:	e6 06       	cpc	r14, r22
    6914:	f7 06       	cpc	r15, r23
    6916:	38 f5       	brcc	.+78     	; 0x6966 <__divdi3+0x734>
    6918:	01 50       	subi	r16, 0x01	; 1
    691a:	10 40       	sbci	r17, 0x00	; 0
    691c:	20 40       	sbci	r18, 0x00	; 0
    691e:	30 40       	sbci	r19, 0x00	; 0
    6920:	09 ab       	sts	0x59, r16
    6922:	1a ab       	sts	0x5a, r17
    6924:	2b ab       	sts	0x5b, r18
    6926:	3c ab       	sts	0x5c, r19
    6928:	c8 0c       	add	r12, r8
    692a:	d9 1c       	adc	r13, r9
    692c:	ea 1c       	adc	r14, r10
    692e:	fb 1c       	adc	r15, r11
    6930:	c8 14       	cp	r12, r8
    6932:	d9 04       	cpc	r13, r9
    6934:	ea 04       	cpc	r14, r10
    6936:	fb 04       	cpc	r15, r11
    6938:	d0 f0       	brcs	.+52     	; 0x696e <__divdi3+0x73c>
    693a:	c4 16       	cp	r12, r20
    693c:	d5 06       	cpc	r13, r21
    693e:	e6 06       	cpc	r14, r22
    6940:	f7 06       	cpc	r15, r23
    6942:	a8 f4       	brcc	.+42     	; 0x696e <__divdi3+0x73c>
    6944:	09 a5       	lds	r16, 0x69
    6946:	1a a5       	lds	r17, 0x6a
    6948:	2b a5       	lds	r18, 0x6b
    694a:	3c a5       	lds	r19, 0x6c
    694c:	02 50       	subi	r16, 0x02	; 2
    694e:	10 40       	sbci	r17, 0x00	; 0
    6950:	20 40       	sbci	r18, 0x00	; 0
    6952:	30 40       	sbci	r19, 0x00	; 0
    6954:	09 ab       	sts	0x59, r16
    6956:	1a ab       	sts	0x5a, r17
    6958:	2b ab       	sts	0x5b, r18
    695a:	3c ab       	sts	0x5c, r19
    695c:	c8 0c       	add	r12, r8
    695e:	d9 1c       	adc	r13, r9
    6960:	ea 1c       	adc	r14, r10
    6962:	fb 1c       	adc	r15, r11
    6964:	04 c0       	rjmp	.+8      	; 0x696e <__divdi3+0x73c>
    6966:	09 ab       	sts	0x59, r16
    6968:	1a ab       	sts	0x5a, r17
    696a:	2b ab       	sts	0x5b, r18
    696c:	3c ab       	sts	0x5c, r19
    696e:	c4 1a       	sub	r12, r20
    6970:	d5 0a       	sbc	r13, r21
    6972:	e6 0a       	sbc	r14, r22
    6974:	f7 0a       	sbc	r15, r23
    6976:	c7 01       	movw	r24, r14
    6978:	b6 01       	movw	r22, r12
    697a:	a3 01       	movw	r20, r6
    697c:	92 01       	movw	r18, r4
    697e:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    6982:	29 a7       	lds	r18, 0x79
    6984:	3a a7       	lds	r19, 0x7a
    6986:	4b a7       	lds	r20, 0x7b
    6988:	5c a7       	lds	r21, 0x7c
    698a:	21 96       	adiw	r28, 0x01	; 1
    698c:	6c af       	sts	0x7c, r22
    698e:	7d af       	sts	0x7d, r23
    6990:	8e af       	sts	0x7e, r24
    6992:	9f af       	sts	0x7f, r25
    6994:	21 97       	sbiw	r28, 0x01	; 1
    6996:	c7 01       	movw	r24, r14
    6998:	b6 01       	movw	r22, r12
    699a:	a3 01       	movw	r20, r6
    699c:	92 01       	movw	r18, r4
    699e:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    69a2:	ca 01       	movw	r24, r20
    69a4:	b9 01       	movw	r22, r18
    69a6:	29 ad       	sts	0x69, r18
    69a8:	3a ad       	sts	0x6a, r19
    69aa:	4b ad       	sts	0x6b, r20
    69ac:	5c ad       	sts	0x6c, r21
    69ae:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    69b2:	8b 01       	movw	r16, r22
    69b4:	9c 01       	movw	r18, r24
    69b6:	21 96       	adiw	r28, 0x01	; 1
    69b8:	4c ad       	sts	0x6c, r20
    69ba:	5d ad       	sts	0x6d, r21
    69bc:	6e ad       	sts	0x6e, r22
    69be:	7f ad       	sts	0x6f, r23
    69c0:	21 97       	sbiw	r28, 0x01	; 1
    69c2:	da 01       	movw	r26, r20
    69c4:	99 27       	eor	r25, r25
    69c6:	88 27       	eor	r24, r24
    69c8:	4d a5       	lds	r20, 0x6d
    69ca:	5e a5       	lds	r21, 0x6e
    69cc:	6f a5       	lds	r22, 0x6f
    69ce:	78 a9       	sts	0x48, r23
    69d0:	60 70       	andi	r22, 0x00	; 0
    69d2:	70 70       	andi	r23, 0x00	; 0
    69d4:	84 2b       	or	r24, r20
    69d6:	95 2b       	or	r25, r21
    69d8:	a6 2b       	or	r26, r22
    69da:	b7 2b       	or	r27, r23
    69dc:	49 a5       	lds	r20, 0x69
    69de:	5a a5       	lds	r21, 0x6a
    69e0:	6b a5       	lds	r22, 0x6b
    69e2:	7c a5       	lds	r23, 0x6c
    69e4:	80 17       	cp	r24, r16
    69e6:	91 07       	cpc	r25, r17
    69e8:	a2 07       	cpc	r26, r18
    69ea:	b3 07       	cpc	r27, r19
    69ec:	f0 f4       	brcc	.+60     	; 0x6a2a <__divdi3+0x7f8>
    69ee:	41 50       	subi	r20, 0x01	; 1
    69f0:	50 40       	sbci	r21, 0x00	; 0
    69f2:	60 40       	sbci	r22, 0x00	; 0
    69f4:	70 40       	sbci	r23, 0x00	; 0
    69f6:	88 0d       	add	r24, r8
    69f8:	99 1d       	adc	r25, r9
    69fa:	aa 1d       	adc	r26, r10
    69fc:	bb 1d       	adc	r27, r11
    69fe:	88 15       	cp	r24, r8
    6a00:	99 05       	cpc	r25, r9
    6a02:	aa 05       	cpc	r26, r10
    6a04:	bb 05       	cpc	r27, r11
    6a06:	88 f0       	brcs	.+34     	; 0x6a2a <__divdi3+0x7f8>
    6a08:	80 17       	cp	r24, r16
    6a0a:	91 07       	cpc	r25, r17
    6a0c:	a2 07       	cpc	r26, r18
    6a0e:	b3 07       	cpc	r27, r19
    6a10:	60 f4       	brcc	.+24     	; 0x6a2a <__divdi3+0x7f8>
    6a12:	49 a5       	lds	r20, 0x69
    6a14:	5a a5       	lds	r21, 0x6a
    6a16:	6b a5       	lds	r22, 0x6b
    6a18:	7c a5       	lds	r23, 0x6c
    6a1a:	42 50       	subi	r20, 0x02	; 2
    6a1c:	50 40       	sbci	r21, 0x00	; 0
    6a1e:	60 40       	sbci	r22, 0x00	; 0
    6a20:	70 40       	sbci	r23, 0x00	; 0
    6a22:	88 0d       	add	r24, r8
    6a24:	99 1d       	adc	r25, r9
    6a26:	aa 1d       	adc	r26, r10
    6a28:	bb 1d       	adc	r27, r11
    6a2a:	6c 01       	movw	r12, r24
    6a2c:	7d 01       	movw	r14, r26
    6a2e:	c0 1a       	sub	r12, r16
    6a30:	d1 0a       	sbc	r13, r17
    6a32:	e2 0a       	sbc	r14, r18
    6a34:	f3 0a       	sbc	r15, r19
    6a36:	09 a9       	sts	0x49, r16
    6a38:	1a a9       	sts	0x4a, r17
    6a3a:	2b a9       	sts	0x4b, r18
    6a3c:	3c a9       	sts	0x4c, r19
    6a3e:	38 01       	movw	r6, r16
    6a40:	55 24       	eor	r5, r5
    6a42:	44 24       	eor	r4, r4
    6a44:	44 2a       	or	r4, r20
    6a46:	55 2a       	or	r5, r21
    6a48:	66 2a       	or	r6, r22
    6a4a:	77 2a       	or	r7, r23
    6a4c:	85 01       	movw	r16, r10
    6a4e:	22 27       	eor	r18, r18
    6a50:	33 27       	eor	r19, r19
    6a52:	0d a7       	lds	r16, 0x7d
    6a54:	1e a7       	lds	r17, 0x7e
    6a56:	2f a7       	lds	r18, 0x7f
    6a58:	38 ab       	sts	0x58, r19
    6a5a:	95 01       	movw	r18, r10
    6a5c:	84 01       	movw	r16, r8
    6a5e:	20 70       	andi	r18, 0x00	; 0
    6a60:	30 70       	andi	r19, 0x00	; 0
    6a62:	09 af       	sts	0x79, r16
    6a64:	1a af       	sts	0x7a, r17
    6a66:	2b af       	sts	0x7b, r18
    6a68:	3c af       	sts	0x7c, r19
    6a6a:	c7 01       	movw	r24, r14
    6a6c:	b6 01       	movw	r22, r12
    6a6e:	2d a5       	lds	r18, 0x6d
    6a70:	3e a5       	lds	r19, 0x6e
    6a72:	4f a5       	lds	r20, 0x6f
    6a74:	58 a9       	sts	0x48, r21
    6a76:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    6a7a:	29 a7       	lds	r18, 0x79
    6a7c:	3a a7       	lds	r19, 0x7a
    6a7e:	4b a7       	lds	r20, 0x7b
    6a80:	5c a7       	lds	r21, 0x7c
    6a82:	69 ab       	sts	0x59, r22
    6a84:	7a ab       	sts	0x5a, r23
    6a86:	8b ab       	sts	0x5b, r24
    6a88:	9c ab       	sts	0x5c, r25
    6a8a:	c7 01       	movw	r24, r14
    6a8c:	b6 01       	movw	r22, r12
    6a8e:	2d a5       	lds	r18, 0x6d
    6a90:	3e a5       	lds	r19, 0x6e
    6a92:	4f a5       	lds	r20, 0x6f
    6a94:	58 a9       	sts	0x48, r21
    6a96:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    6a9a:	ca 01       	movw	r24, r20
    6a9c:	b9 01       	movw	r22, r18
    6a9e:	29 ad       	sts	0x69, r18
    6aa0:	3a ad       	sts	0x6a, r19
    6aa2:	4b ad       	sts	0x6b, r20
    6aa4:	5c ad       	sts	0x6c, r21
    6aa6:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    6aaa:	ab 01       	movw	r20, r22
    6aac:	bc 01       	movw	r22, r24
    6aae:	09 a9       	sts	0x49, r16
    6ab0:	1a a9       	sts	0x4a, r17
    6ab2:	2b a9       	sts	0x4b, r18
    6ab4:	3c a9       	sts	0x4c, r19
    6ab6:	78 01       	movw	r14, r16
    6ab8:	dd 24       	eor	r13, r13
    6aba:	cc 24       	eor	r12, r12
    6abc:	0d a9       	sts	0x4d, r16
    6abe:	1e a9       	sts	0x4e, r17
    6ac0:	2f a9       	sts	0x4f, r18
    6ac2:	38 ad       	sts	0x68, r19
    6ac4:	c9 01       	movw	r24, r18
    6ac6:	aa 27       	eor	r26, r26
    6ac8:	bb 27       	eor	r27, r27
    6aca:	c8 2a       	or	r12, r24
    6acc:	d9 2a       	or	r13, r25
    6ace:	ea 2a       	or	r14, r26
    6ad0:	fb 2a       	or	r15, r27
    6ad2:	09 a5       	lds	r16, 0x69
    6ad4:	1a a5       	lds	r17, 0x6a
    6ad6:	2b a5       	lds	r18, 0x6b
    6ad8:	3c a5       	lds	r19, 0x6c
    6ada:	c4 16       	cp	r12, r20
    6adc:	d5 06       	cpc	r13, r21
    6ade:	e6 06       	cpc	r14, r22
    6ae0:	f7 06       	cpc	r15, r23
    6ae2:	38 f5       	brcc	.+78     	; 0x6b32 <__divdi3+0x900>
    6ae4:	01 50       	subi	r16, 0x01	; 1
    6ae6:	10 40       	sbci	r17, 0x00	; 0
    6ae8:	20 40       	sbci	r18, 0x00	; 0
    6aea:	30 40       	sbci	r19, 0x00	; 0
    6aec:	09 ab       	sts	0x59, r16
    6aee:	1a ab       	sts	0x5a, r17
    6af0:	2b ab       	sts	0x5b, r18
    6af2:	3c ab       	sts	0x5c, r19
    6af4:	c8 0c       	add	r12, r8
    6af6:	d9 1c       	adc	r13, r9
    6af8:	ea 1c       	adc	r14, r10
    6afa:	fb 1c       	adc	r15, r11
    6afc:	c8 14       	cp	r12, r8
    6afe:	d9 04       	cpc	r13, r9
    6b00:	ea 04       	cpc	r14, r10
    6b02:	fb 04       	cpc	r15, r11
    6b04:	d0 f0       	brcs	.+52     	; 0x6b3a <__divdi3+0x908>
    6b06:	c4 16       	cp	r12, r20
    6b08:	d5 06       	cpc	r13, r21
    6b0a:	e6 06       	cpc	r14, r22
    6b0c:	f7 06       	cpc	r15, r23
    6b0e:	a8 f4       	brcc	.+42     	; 0x6b3a <__divdi3+0x908>
    6b10:	09 a5       	lds	r16, 0x69
    6b12:	1a a5       	lds	r17, 0x6a
    6b14:	2b a5       	lds	r18, 0x6b
    6b16:	3c a5       	lds	r19, 0x6c
    6b18:	02 50       	subi	r16, 0x02	; 2
    6b1a:	10 40       	sbci	r17, 0x00	; 0
    6b1c:	20 40       	sbci	r18, 0x00	; 0
    6b1e:	30 40       	sbci	r19, 0x00	; 0
    6b20:	09 ab       	sts	0x59, r16
    6b22:	1a ab       	sts	0x5a, r17
    6b24:	2b ab       	sts	0x5b, r18
    6b26:	3c ab       	sts	0x5c, r19
    6b28:	c8 0c       	add	r12, r8
    6b2a:	d9 1c       	adc	r13, r9
    6b2c:	ea 1c       	adc	r14, r10
    6b2e:	fb 1c       	adc	r15, r11
    6b30:	04 c0       	rjmp	.+8      	; 0x6b3a <__divdi3+0x908>
    6b32:	09 ab       	sts	0x59, r16
    6b34:	1a ab       	sts	0x5a, r17
    6b36:	2b ab       	sts	0x5b, r18
    6b38:	3c ab       	sts	0x5c, r19
    6b3a:	c4 1a       	sub	r12, r20
    6b3c:	d5 0a       	sbc	r13, r21
    6b3e:	e6 0a       	sbc	r14, r22
    6b40:	f7 0a       	sbc	r15, r23
    6b42:	c7 01       	movw	r24, r14
    6b44:	b6 01       	movw	r22, r12
    6b46:	2d a5       	lds	r18, 0x6d
    6b48:	3e a5       	lds	r19, 0x6e
    6b4a:	4f a5       	lds	r20, 0x6f
    6b4c:	58 a9       	sts	0x48, r21
    6b4e:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    6b52:	29 a7       	lds	r18, 0x79
    6b54:	3a a7       	lds	r19, 0x7a
    6b56:	4b a7       	lds	r20, 0x7b
    6b58:	5c a7       	lds	r21, 0x7c
    6b5a:	21 96       	adiw	r28, 0x01	; 1
    6b5c:	6c af       	sts	0x7c, r22
    6b5e:	7d af       	sts	0x7d, r23
    6b60:	8e af       	sts	0x7e, r24
    6b62:	9f af       	sts	0x7f, r25
    6b64:	21 97       	sbiw	r28, 0x01	; 1
    6b66:	c7 01       	movw	r24, r14
    6b68:	b6 01       	movw	r22, r12
    6b6a:	2d a5       	lds	r18, 0x6d
    6b6c:	3e a5       	lds	r19, 0x6e
    6b6e:	4f a5       	lds	r20, 0x6f
    6b70:	58 a9       	sts	0x48, r21
    6b72:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    6b76:	ca 01       	movw	r24, r20
    6b78:	b9 01       	movw	r22, r18
    6b7a:	29 ad       	sts	0x69, r18
    6b7c:	3a ad       	sts	0x6a, r19
    6b7e:	4b ad       	sts	0x6b, r20
    6b80:	5c ad       	sts	0x6c, r21
    6b82:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    6b86:	8b 01       	movw	r16, r22
    6b88:	9c 01       	movw	r18, r24
    6b8a:	21 96       	adiw	r28, 0x01	; 1
    6b8c:	4c ad       	sts	0x6c, r20
    6b8e:	5d ad       	sts	0x6d, r21
    6b90:	6e ad       	sts	0x6e, r22
    6b92:	7f ad       	sts	0x6f, r23
    6b94:	21 97       	sbiw	r28, 0x01	; 1
    6b96:	da 01       	movw	r26, r20
    6b98:	99 27       	eor	r25, r25
    6b9a:	88 27       	eor	r24, r24
    6b9c:	4d a9       	sts	0x4d, r20
    6b9e:	5e a9       	sts	0x4e, r21
    6ba0:	6f a9       	sts	0x4f, r22
    6ba2:	78 ad       	sts	0x68, r23
    6ba4:	60 70       	andi	r22, 0x00	; 0
    6ba6:	70 70       	andi	r23, 0x00	; 0
    6ba8:	84 2b       	or	r24, r20
    6baa:	95 2b       	or	r25, r21
    6bac:	a6 2b       	or	r26, r22
    6bae:	b7 2b       	or	r27, r23
    6bb0:	49 a5       	lds	r20, 0x69
    6bb2:	5a a5       	lds	r21, 0x6a
    6bb4:	6b a5       	lds	r22, 0x6b
    6bb6:	7c a5       	lds	r23, 0x6c
    6bb8:	80 17       	cp	r24, r16
    6bba:	91 07       	cpc	r25, r17
    6bbc:	a2 07       	cpc	r26, r18
    6bbe:	b3 07       	cpc	r27, r19
    6bc0:	d0 f4       	brcc	.+52     	; 0x6bf6 <__divdi3+0x9c4>
    6bc2:	41 50       	subi	r20, 0x01	; 1
    6bc4:	50 40       	sbci	r21, 0x00	; 0
    6bc6:	60 40       	sbci	r22, 0x00	; 0
    6bc8:	70 40       	sbci	r23, 0x00	; 0
    6bca:	88 0d       	add	r24, r8
    6bcc:	99 1d       	adc	r25, r9
    6bce:	aa 1d       	adc	r26, r10
    6bd0:	bb 1d       	adc	r27, r11
    6bd2:	88 15       	cp	r24, r8
    6bd4:	99 05       	cpc	r25, r9
    6bd6:	aa 05       	cpc	r26, r10
    6bd8:	bb 05       	cpc	r27, r11
    6bda:	68 f0       	brcs	.+26     	; 0x6bf6 <__divdi3+0x9c4>
    6bdc:	80 17       	cp	r24, r16
    6bde:	91 07       	cpc	r25, r17
    6be0:	a2 07       	cpc	r26, r18
    6be2:	b3 07       	cpc	r27, r19
    6be4:	40 f4       	brcc	.+16     	; 0x6bf6 <__divdi3+0x9c4>
    6be6:	49 a5       	lds	r20, 0x69
    6be8:	5a a5       	lds	r21, 0x6a
    6bea:	6b a5       	lds	r22, 0x6b
    6bec:	7c a5       	lds	r23, 0x6c
    6bee:	42 50       	subi	r20, 0x02	; 2
    6bf0:	50 40       	sbci	r21, 0x00	; 0
    6bf2:	60 40       	sbci	r22, 0x00	; 0
    6bf4:	70 40       	sbci	r23, 0x00	; 0
    6bf6:	09 a9       	sts	0x49, r16
    6bf8:	1a a9       	sts	0x4a, r17
    6bfa:	2b a9       	sts	0x4b, r18
    6bfc:	3c a9       	sts	0x4c, r19
    6bfe:	78 01       	movw	r14, r16
    6c00:	dd 24       	eor	r13, r13
    6c02:	cc 24       	eor	r12, r12
    6c04:	c4 2a       	or	r12, r20
    6c06:	d5 2a       	or	r13, r21
    6c08:	e6 2a       	or	r14, r22
    6c0a:	f7 2a       	or	r15, r23
    6c0c:	50 c2       	rjmp	.+1184   	; 0x70ae <__divdi3+0xe7c>
    6c0e:	c8 16       	cp	r12, r24
    6c10:	d9 06       	cpc	r13, r25
    6c12:	ea 06       	cpc	r14, r26
    6c14:	fb 06       	cpc	r15, r27
    6c16:	08 f4       	brcc	.+2      	; 0x6c1a <__divdi3+0x9e8>
    6c18:	37 c2       	rjmp	.+1134   	; 0x7088 <__divdi3+0xe56>
    6c1a:	80 30       	cpi	r24, 0x00	; 0
    6c1c:	10 e0       	ldi	r17, 0x00	; 0
    6c1e:	91 07       	cpc	r25, r17
    6c20:	11 e0       	ldi	r17, 0x01	; 1
    6c22:	a1 07       	cpc	r26, r17
    6c24:	10 e0       	ldi	r17, 0x00	; 0
    6c26:	b1 07       	cpc	r27, r17
    6c28:	50 f4       	brcc	.+20     	; 0x6c3e <__divdi3+0xa0c>
    6c2a:	8f 3f       	cpi	r24, 0xFF	; 255
    6c2c:	91 05       	cpc	r25, r1
    6c2e:	a1 05       	cpc	r26, r1
    6c30:	b1 05       	cpc	r27, r1
    6c32:	09 f0       	breq	.+2      	; 0x6c36 <__divdi3+0xa04>
    6c34:	88 f4       	brcc	.+34     	; 0x6c58 <__divdi3+0xa26>
    6c36:	00 e0       	ldi	r16, 0x00	; 0
    6c38:	10 e0       	ldi	r17, 0x00	; 0
    6c3a:	98 01       	movw	r18, r16
    6c3c:	16 c0       	rjmp	.+44     	; 0x6c6a <__divdi3+0xa38>
    6c3e:	80 30       	cpi	r24, 0x00	; 0
    6c40:	20 e0       	ldi	r18, 0x00	; 0
    6c42:	92 07       	cpc	r25, r18
    6c44:	20 e0       	ldi	r18, 0x00	; 0
    6c46:	a2 07       	cpc	r26, r18
    6c48:	21 e0       	ldi	r18, 0x01	; 1
    6c4a:	b2 07       	cpc	r27, r18
    6c4c:	50 f4       	brcc	.+20     	; 0x6c62 <__divdi3+0xa30>
    6c4e:	00 e1       	ldi	r16, 0x10	; 16
    6c50:	10 e0       	ldi	r17, 0x00	; 0
    6c52:	20 e0       	ldi	r18, 0x00	; 0
    6c54:	30 e0       	ldi	r19, 0x00	; 0
    6c56:	09 c0       	rjmp	.+18     	; 0x6c6a <__divdi3+0xa38>
    6c58:	08 e0       	ldi	r16, 0x08	; 8
    6c5a:	10 e0       	ldi	r17, 0x00	; 0
    6c5c:	20 e0       	ldi	r18, 0x00	; 0
    6c5e:	30 e0       	ldi	r19, 0x00	; 0
    6c60:	04 c0       	rjmp	.+8      	; 0x6c6a <__divdi3+0xa38>
    6c62:	08 e1       	ldi	r16, 0x18	; 24
    6c64:	10 e0       	ldi	r17, 0x00	; 0
    6c66:	20 e0       	ldi	r18, 0x00	; 0
    6c68:	30 e0       	ldi	r19, 0x00	; 0
    6c6a:	ac 01       	movw	r20, r24
    6c6c:	bd 01       	movw	r22, r26
    6c6e:	00 2e       	mov	r0, r16
    6c70:	04 c0       	rjmp	.+8      	; 0x6c7a <__divdi3+0xa48>
    6c72:	76 95       	lsr	r23
    6c74:	67 95       	ror	r22
    6c76:	57 95       	ror	r21
    6c78:	47 95       	ror	r20
    6c7a:	0a 94       	dec	r0
    6c7c:	d2 f7       	brpl	.-12     	; 0x6c72 <__divdi3+0xa40>
    6c7e:	fa 01       	movw	r30, r20
    6c80:	e9 5c       	subi	r30, 0xC9	; 201
    6c82:	ff 4d       	sbci	r31, 0xDF	; 223
    6c84:	40 81       	ld	r20, Z
    6c86:	04 0f       	add	r16, r20
    6c88:	11 1d       	adc	r17, r1
    6c8a:	21 1d       	adc	r18, r1
    6c8c:	31 1d       	adc	r19, r1
    6c8e:	40 e2       	ldi	r20, 0x20	; 32
    6c90:	50 e0       	ldi	r21, 0x00	; 0
    6c92:	60 e0       	ldi	r22, 0x00	; 0
    6c94:	70 e0       	ldi	r23, 0x00	; 0
    6c96:	40 1b       	sub	r20, r16
    6c98:	51 0b       	sbc	r21, r17
    6c9a:	62 0b       	sbc	r22, r18
    6c9c:	73 0b       	sbc	r23, r19
    6c9e:	a1 f4       	brne	.+40     	; 0x6cc8 <__divdi3+0xa96>
    6ca0:	8c 15       	cp	r24, r12
    6ca2:	9d 05       	cpc	r25, r13
    6ca4:	ae 05       	cpc	r26, r14
    6ca6:	bf 05       	cpc	r27, r15
    6ca8:	08 f4       	brcc	.+2      	; 0x6cac <__divdi3+0xa7a>
    6caa:	f5 c1       	rjmp	.+1002   	; 0x7096 <__divdi3+0xe64>
    6cac:	ed a8       	sts	0x8d, r30
    6cae:	fe a8       	sts	0x8e, r31
    6cb0:	0f a9       	sts	0x4f, r16
    6cb2:	18 ad       	sts	0x68, r17
    6cb4:	44 24       	eor	r4, r4
    6cb6:	55 24       	eor	r5, r5
    6cb8:	32 01       	movw	r6, r4
    6cba:	e8 14       	cp	r14, r8
    6cbc:	f9 04       	cpc	r15, r9
    6cbe:	0a 05       	cpc	r16, r10
    6cc0:	1b 05       	cpc	r17, r11
    6cc2:	08 f0       	brcs	.+2      	; 0x6cc6 <__divdi3+0xa94>
    6cc4:	eb c1       	rjmp	.+982    	; 0x709c <__divdi3+0xe6a>
    6cc6:	e3 c1       	rjmp	.+966    	; 0x708e <__divdi3+0xe5c>
    6cc8:	34 2e       	mov	r3, r20
    6cca:	2c 01       	movw	r4, r24
    6ccc:	3d 01       	movw	r6, r26
    6cce:	04 c0       	rjmp	.+8      	; 0x6cd8 <__divdi3+0xaa6>
    6cd0:	44 0c       	add	r4, r4
    6cd2:	55 1c       	adc	r5, r5
    6cd4:	66 1c       	adc	r6, r6
    6cd6:	77 1c       	adc	r7, r7
    6cd8:	4a 95       	dec	r20
    6cda:	d2 f7       	brpl	.-12     	; 0x6cd0 <__divdi3+0xa9e>
    6cdc:	d5 01       	movw	r26, r10
    6cde:	c4 01       	movw	r24, r8
    6ce0:	00 2e       	mov	r0, r16
    6ce2:	04 c0       	rjmp	.+8      	; 0x6cec <__divdi3+0xaba>
    6ce4:	b6 95       	lsr	r27
    6ce6:	a7 95       	ror	r26
    6ce8:	97 95       	ror	r25
    6cea:	87 95       	ror	r24
    6cec:	0a 94       	dec	r0
    6cee:	d2 f7       	brpl	.-12     	; 0x6ce4 <__divdi3+0xab2>
    6cf0:	48 2a       	or	r4, r24
    6cf2:	59 2a       	or	r5, r25
    6cf4:	6a 2a       	or	r6, r26
    6cf6:	7b 2a       	or	r7, r27
    6cf8:	a5 01       	movw	r20, r10
    6cfa:	94 01       	movw	r18, r8
    6cfc:	03 2c       	mov	r0, r3
    6cfe:	04 c0       	rjmp	.+8      	; 0x6d08 <__divdi3+0xad6>
    6d00:	22 0f       	add	r18, r18
    6d02:	33 1f       	adc	r19, r19
    6d04:	44 1f       	adc	r20, r20
    6d06:	55 1f       	adc	r21, r21
    6d08:	0a 94       	dec	r0
    6d0a:	d2 f7       	brpl	.-12     	; 0x6d00 <__divdi3+0xace>
    6d0c:	29 af       	sts	0x79, r18
    6d0e:	3a af       	sts	0x7a, r19
    6d10:	4b af       	sts	0x7b, r20
    6d12:	5c af       	sts	0x7c, r21
    6d14:	b7 01       	movw	r22, r14
    6d16:	a6 01       	movw	r20, r12
    6d18:	00 2e       	mov	r0, r16
    6d1a:	04 c0       	rjmp	.+8      	; 0x6d24 <__divdi3+0xaf2>
    6d1c:	76 95       	lsr	r23
    6d1e:	67 95       	ror	r22
    6d20:	57 95       	ror	r21
    6d22:	47 95       	ror	r20
    6d24:	0a 94       	dec	r0
    6d26:	d2 f7       	brpl	.-12     	; 0x6d1c <__divdi3+0xaea>
    6d28:	49 ab       	sts	0x59, r20
    6d2a:	5a ab       	sts	0x5a, r21
    6d2c:	6b ab       	sts	0x5b, r22
    6d2e:	7c ab       	sts	0x5c, r23
    6d30:	c7 01       	movw	r24, r14
    6d32:	b6 01       	movw	r22, r12
    6d34:	03 2c       	mov	r0, r3
    6d36:	04 c0       	rjmp	.+8      	; 0x6d40 <__divdi3+0xb0e>
    6d38:	66 0f       	add	r22, r22
    6d3a:	77 1f       	adc	r23, r23
    6d3c:	88 1f       	adc	r24, r24
    6d3e:	99 1f       	adc	r25, r25
    6d40:	0a 94       	dec	r0
    6d42:	d2 f7       	brpl	.-12     	; 0x6d38 <__divdi3+0xb06>
    6d44:	6d a7       	lds	r22, 0x7d
    6d46:	7e a7       	lds	r23, 0x7e
    6d48:	8f a7       	lds	r24, 0x7f
    6d4a:	98 ab       	sts	0x58, r25
    6d4c:	8d a9       	sts	0x4d, r24
    6d4e:	9e a9       	sts	0x4e, r25
    6d50:	af a9       	sts	0x4f, r26
    6d52:	b8 ad       	sts	0x68, r27
    6d54:	04 c0       	rjmp	.+8      	; 0x6d5e <__divdi3+0xb2c>
    6d56:	b6 95       	lsr	r27
    6d58:	a7 95       	ror	r26
    6d5a:	97 95       	ror	r25
    6d5c:	87 95       	ror	r24
    6d5e:	0a 95       	dec	r16
    6d60:	d2 f7       	brpl	.-12     	; 0x6d56 <__divdi3+0xb24>
    6d62:	4d a5       	lds	r20, 0x6d
    6d64:	5e a5       	lds	r21, 0x6e
    6d66:	6f a5       	lds	r22, 0x6f
    6d68:	78 a9       	sts	0x48, r23
    6d6a:	48 2b       	or	r20, r24
    6d6c:	59 2b       	or	r21, r25
    6d6e:	6a 2b       	or	r22, r26
    6d70:	7b 2b       	or	r23, r27
    6d72:	4d a7       	lds	r20, 0x7d
    6d74:	5e a7       	lds	r21, 0x7e
    6d76:	6f a7       	lds	r22, 0x7f
    6d78:	78 ab       	sts	0x58, r23
    6d7a:	43 01       	movw	r8, r6
    6d7c:	aa 24       	eor	r10, r10
    6d7e:	bb 24       	eor	r11, r11
    6d80:	93 01       	movw	r18, r6
    6d82:	82 01       	movw	r16, r4
    6d84:	20 70       	andi	r18, 0x00	; 0
    6d86:	30 70       	andi	r19, 0x00	; 0
    6d88:	21 96       	adiw	r28, 0x01	; 1
    6d8a:	0c af       	sts	0x7c, r16
    6d8c:	1d af       	sts	0x7d, r17
    6d8e:	2e af       	sts	0x7e, r18
    6d90:	3f af       	sts	0x7f, r19
    6d92:	21 97       	sbiw	r28, 0x01	; 1
    6d94:	69 a9       	sts	0x49, r22
    6d96:	7a a9       	sts	0x4a, r23
    6d98:	8b a9       	sts	0x4b, r24
    6d9a:	9c a9       	sts	0x4c, r25
    6d9c:	a5 01       	movw	r20, r10
    6d9e:	94 01       	movw	r18, r8
    6da0:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    6da4:	29 a7       	lds	r18, 0x79
    6da6:	3a a7       	lds	r19, 0x7a
    6da8:	4b a7       	lds	r20, 0x7b
    6daa:	5c a7       	lds	r21, 0x7c
    6dac:	6b 01       	movw	r12, r22
    6dae:	7c 01       	movw	r14, r24
    6db0:	69 a9       	sts	0x49, r22
    6db2:	7a a9       	sts	0x4a, r23
    6db4:	8b a9       	sts	0x4b, r24
    6db6:	9c a9       	sts	0x4c, r25
    6db8:	a5 01       	movw	r20, r10
    6dba:	94 01       	movw	r18, r8
    6dbc:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    6dc0:	ca 01       	movw	r24, r20
    6dc2:	b9 01       	movw	r22, r18
    6dc4:	21 96       	adiw	r28, 0x01	; 1
    6dc6:	2c ad       	sts	0x6c, r18
    6dc8:	3d ad       	sts	0x6d, r19
    6dca:	4e ad       	sts	0x6e, r20
    6dcc:	5f ad       	sts	0x6f, r21
    6dce:	21 97       	sbiw	r28, 0x01	; 1
    6dd0:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    6dd4:	dc 01       	movw	r26, r24
    6dd6:	cb 01       	movw	r24, r22
    6dd8:	76 01       	movw	r14, r12
    6dda:	dd 24       	eor	r13, r13
    6ddc:	cc 24       	eor	r12, r12
    6dde:	0d a5       	lds	r16, 0x6d
    6de0:	1e a5       	lds	r17, 0x6e
    6de2:	2f a5       	lds	r18, 0x6f
    6de4:	38 a9       	sts	0x48, r19
    6de6:	a9 01       	movw	r20, r18
    6de8:	66 27       	eor	r22, r22
    6dea:	77 27       	eor	r23, r23
    6dec:	c4 2a       	or	r12, r20
    6dee:	d5 2a       	or	r13, r21
    6df0:	e6 2a       	or	r14, r22
    6df2:	f7 2a       	or	r15, r23
    6df4:	09 a5       	lds	r16, 0x69
    6df6:	1a a5       	lds	r17, 0x6a
    6df8:	2b a5       	lds	r18, 0x6b
    6dfa:	3c a5       	lds	r19, 0x6c
    6dfc:	c8 16       	cp	r12, r24
    6dfe:	d9 06       	cpc	r13, r25
    6e00:	ea 06       	cpc	r14, r26
    6e02:	fb 06       	cpc	r15, r27
    6e04:	38 f5       	brcc	.+78     	; 0x6e54 <__divdi3+0xc22>
    6e06:	01 50       	subi	r16, 0x01	; 1
    6e08:	10 40       	sbci	r17, 0x00	; 0
    6e0a:	20 40       	sbci	r18, 0x00	; 0
    6e0c:	30 40       	sbci	r19, 0x00	; 0
    6e0e:	09 ab       	sts	0x59, r16
    6e10:	1a ab       	sts	0x5a, r17
    6e12:	2b ab       	sts	0x5b, r18
    6e14:	3c ab       	sts	0x5c, r19
    6e16:	c4 0c       	add	r12, r4
    6e18:	d5 1c       	adc	r13, r5
    6e1a:	e6 1c       	adc	r14, r6
    6e1c:	f7 1c       	adc	r15, r7
    6e1e:	c4 14       	cp	r12, r4
    6e20:	d5 04       	cpc	r13, r5
    6e22:	e6 04       	cpc	r14, r6
    6e24:	f7 04       	cpc	r15, r7
    6e26:	d0 f0       	brcs	.+52     	; 0x6e5c <__divdi3+0xc2a>
    6e28:	c8 16       	cp	r12, r24
    6e2a:	d9 06       	cpc	r13, r25
    6e2c:	ea 06       	cpc	r14, r26
    6e2e:	fb 06       	cpc	r15, r27
    6e30:	a8 f4       	brcc	.+42     	; 0x6e5c <__divdi3+0xc2a>
    6e32:	09 a5       	lds	r16, 0x69
    6e34:	1a a5       	lds	r17, 0x6a
    6e36:	2b a5       	lds	r18, 0x6b
    6e38:	3c a5       	lds	r19, 0x6c
    6e3a:	02 50       	subi	r16, 0x02	; 2
    6e3c:	10 40       	sbci	r17, 0x00	; 0
    6e3e:	20 40       	sbci	r18, 0x00	; 0
    6e40:	30 40       	sbci	r19, 0x00	; 0
    6e42:	09 ab       	sts	0x59, r16
    6e44:	1a ab       	sts	0x5a, r17
    6e46:	2b ab       	sts	0x5b, r18
    6e48:	3c ab       	sts	0x5c, r19
    6e4a:	c4 0c       	add	r12, r4
    6e4c:	d5 1c       	adc	r13, r5
    6e4e:	e6 1c       	adc	r14, r6
    6e50:	f7 1c       	adc	r15, r7
    6e52:	04 c0       	rjmp	.+8      	; 0x6e5c <__divdi3+0xc2a>
    6e54:	09 ab       	sts	0x59, r16
    6e56:	1a ab       	sts	0x5a, r17
    6e58:	2b ab       	sts	0x5b, r18
    6e5a:	3c ab       	sts	0x5c, r19
    6e5c:	c8 1a       	sub	r12, r24
    6e5e:	d9 0a       	sbc	r13, r25
    6e60:	ea 0a       	sbc	r14, r26
    6e62:	fb 0a       	sbc	r15, r27
    6e64:	c7 01       	movw	r24, r14
    6e66:	b6 01       	movw	r22, r12
    6e68:	a5 01       	movw	r20, r10
    6e6a:	94 01       	movw	r18, r8
    6e6c:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    6e70:	29 a7       	lds	r18, 0x79
    6e72:	3a a7       	lds	r19, 0x7a
    6e74:	4b a7       	lds	r20, 0x7b
    6e76:	5c a7       	lds	r21, 0x7c
    6e78:	29 96       	adiw	r28, 0x09	; 9
    6e7a:	6c af       	sts	0x7c, r22
    6e7c:	7d af       	sts	0x7d, r23
    6e7e:	8e af       	sts	0x7e, r24
    6e80:	9f af       	sts	0x7f, r25
    6e82:	29 97       	sbiw	r28, 0x09	; 9
    6e84:	c7 01       	movw	r24, r14
    6e86:	b6 01       	movw	r22, r12
    6e88:	a5 01       	movw	r20, r10
    6e8a:	94 01       	movw	r18, r8
    6e8c:	0e 94 ca 3a 	call	0x7594	; 0x7594 <__udivmodsi4>
    6e90:	ca 01       	movw	r24, r20
    6e92:	b9 01       	movw	r22, r18
    6e94:	21 96       	adiw	r28, 0x01	; 1
    6e96:	2c ad       	sts	0x6c, r18
    6e98:	3d ad       	sts	0x6d, r19
    6e9a:	4e ad       	sts	0x6e, r20
    6e9c:	5f ad       	sts	0x6f, r21
    6e9e:	21 97       	sbiw	r28, 0x01	; 1
    6ea0:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    6ea4:	4b 01       	movw	r8, r22
    6ea6:	5c 01       	movw	r10, r24
    6ea8:	29 96       	adiw	r28, 0x09	; 9
    6eaa:	4c ad       	sts	0x6c, r20
    6eac:	5d ad       	sts	0x6d, r21
    6eae:	6e ad       	sts	0x6e, r22
    6eb0:	7f ad       	sts	0x6f, r23
    6eb2:	29 97       	sbiw	r28, 0x09	; 9
    6eb4:	9a 01       	movw	r18, r20
    6eb6:	11 27       	eor	r17, r17
    6eb8:	00 27       	eor	r16, r16
    6eba:	8d a5       	lds	r24, 0x6d
    6ebc:	9e a5       	lds	r25, 0x6e
    6ebe:	af a5       	lds	r26, 0x6f
    6ec0:	b8 a9       	sts	0x48, r27
    6ec2:	a0 70       	andi	r26, 0x00	; 0
    6ec4:	b0 70       	andi	r27, 0x00	; 0
    6ec6:	08 2b       	or	r16, r24
    6ec8:	19 2b       	or	r17, r25
    6eca:	2a 2b       	or	r18, r26
    6ecc:	3b 2b       	or	r19, r27
    6ece:	89 a5       	lds	r24, 0x69
    6ed0:	9a a5       	lds	r25, 0x6a
    6ed2:	ab a5       	lds	r26, 0x6b
    6ed4:	bc a5       	lds	r27, 0x6c
    6ed6:	08 15       	cp	r16, r8
    6ed8:	19 05       	cpc	r17, r9
    6eda:	2a 05       	cpc	r18, r10
    6edc:	3b 05       	cpc	r19, r11
    6ede:	e0 f4       	brcc	.+56     	; 0x6f18 <__divdi3+0xce6>
    6ee0:	01 97       	sbiw	r24, 0x01	; 1
    6ee2:	a1 09       	sbc	r26, r1
    6ee4:	b1 09       	sbc	r27, r1
    6ee6:	04 0d       	add	r16, r4
    6ee8:	15 1d       	adc	r17, r5
    6eea:	26 1d       	adc	r18, r6
    6eec:	37 1d       	adc	r19, r7
    6eee:	04 15       	cp	r16, r4
    6ef0:	15 05       	cpc	r17, r5
    6ef2:	26 05       	cpc	r18, r6
    6ef4:	37 05       	cpc	r19, r7
    6ef6:	80 f0       	brcs	.+32     	; 0x6f18 <__divdi3+0xce6>
    6ef8:	08 15       	cp	r16, r8
    6efa:	19 05       	cpc	r17, r9
    6efc:	2a 05       	cpc	r18, r10
    6efe:	3b 05       	cpc	r19, r11
    6f00:	58 f4       	brcc	.+22     	; 0x6f18 <__divdi3+0xce6>
    6f02:	89 a5       	lds	r24, 0x69
    6f04:	9a a5       	lds	r25, 0x6a
    6f06:	ab a5       	lds	r26, 0x6b
    6f08:	bc a5       	lds	r27, 0x6c
    6f0a:	02 97       	sbiw	r24, 0x02	; 2
    6f0c:	a1 09       	sbc	r26, r1
    6f0e:	b1 09       	sbc	r27, r1
    6f10:	04 0d       	add	r16, r4
    6f12:	15 1d       	adc	r17, r5
    6f14:	26 1d       	adc	r18, r6
    6f16:	37 1d       	adc	r19, r7
    6f18:	b9 01       	movw	r22, r18
    6f1a:	a8 01       	movw	r20, r16
    6f1c:	48 19       	sub	r20, r8
    6f1e:	59 09       	sbc	r21, r9
    6f20:	6a 09       	sbc	r22, r10
    6f22:	7b 09       	sbc	r23, r11
    6f24:	4d a7       	lds	r20, 0x7d
    6f26:	5e a7       	lds	r21, 0x7e
    6f28:	6f a7       	lds	r22, 0x7f
    6f2a:	78 ab       	sts	0x58, r23
    6f2c:	09 a9       	sts	0x49, r16
    6f2e:	1a a9       	sts	0x4a, r17
    6f30:	2b a9       	sts	0x4b, r18
    6f32:	3c a9       	sts	0x4c, r19
    6f34:	78 01       	movw	r14, r16
    6f36:	dd 24       	eor	r13, r13
    6f38:	cc 24       	eor	r12, r12
    6f3a:	c8 2a       	or	r12, r24
    6f3c:	d9 2a       	or	r13, r25
    6f3e:	ea 2a       	or	r14, r26
    6f40:	fb 2a       	or	r15, r27
    6f42:	ff ef       	ldi	r31, 0xFF	; 255
    6f44:	8f 2e       	mov	r8, r31
    6f46:	ff ef       	ldi	r31, 0xFF	; 255
    6f48:	9f 2e       	mov	r9, r31
    6f4a:	a1 2c       	mov	r10, r1
    6f4c:	b1 2c       	mov	r11, r1
    6f4e:	8c 20       	and	r8, r12
    6f50:	9d 20       	and	r9, r13
    6f52:	ae 20       	and	r10, r14
    6f54:	bf 20       	and	r11, r15
    6f56:	87 01       	movw	r16, r14
    6f58:	22 27       	eor	r18, r18
    6f5a:	33 27       	eor	r19, r19
    6f5c:	09 a7       	lds	r16, 0x79
    6f5e:	1a a7       	lds	r17, 0x7a
    6f60:	2b a7       	lds	r18, 0x7b
    6f62:	3c a7       	lds	r19, 0x7c
    6f64:	49 ac       	sts	0xa9, r20
    6f66:	5a ac       	sts	0xaa, r21
    6f68:	6b ac       	sts	0xab, r22
    6f6a:	7c ac       	sts	0xac, r23
    6f6c:	2f ef       	ldi	r18, 0xFF	; 255
    6f6e:	3f ef       	ldi	r19, 0xFF	; 255
    6f70:	40 e0       	ldi	r20, 0x00	; 0
    6f72:	50 e0       	ldi	r21, 0x00	; 0
    6f74:	42 22       	and	r4, r18
    6f76:	53 22       	and	r5, r19
    6f78:	64 22       	and	r6, r20
    6f7a:	75 22       	and	r7, r21
    6f7c:	29 ad       	sts	0x69, r18
    6f7e:	3a ad       	sts	0x6a, r19
    6f80:	4b ad       	sts	0x6b, r20
    6f82:	5c ad       	sts	0x6c, r21
    6f84:	8a 01       	movw	r16, r20
    6f86:	22 27       	eor	r18, r18
    6f88:	33 27       	eor	r19, r19
    6f8a:	09 ab       	sts	0x59, r16
    6f8c:	1a ab       	sts	0x5a, r17
    6f8e:	2b ab       	sts	0x5b, r18
    6f90:	3c ab       	sts	0x5c, r19
    6f92:	c5 01       	movw	r24, r10
    6f94:	b4 01       	movw	r22, r8
    6f96:	a3 01       	movw	r20, r6
    6f98:	92 01       	movw	r18, r4
    6f9a:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    6f9e:	69 af       	sts	0x79, r22
    6fa0:	7a af       	sts	0x7a, r23
    6fa2:	8b af       	sts	0x7b, r24
    6fa4:	9c af       	sts	0x7c, r25
    6fa6:	c5 01       	movw	r24, r10
    6fa8:	b4 01       	movw	r22, r8
    6faa:	29 a9       	sts	0x49, r18
    6fac:	3a a9       	sts	0x4a, r19
    6fae:	4b a9       	sts	0x4b, r20
    6fb0:	5c a9       	sts	0x4c, r21
    6fb2:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    6fb6:	4b 01       	movw	r8, r22
    6fb8:	5c 01       	movw	r10, r24
    6fba:	69 a5       	lds	r22, 0x69
    6fbc:	7a a5       	lds	r23, 0x6a
    6fbe:	8b a5       	lds	r24, 0x6b
    6fc0:	9c a5       	lds	r25, 0x6c
    6fc2:	a3 01       	movw	r20, r6
    6fc4:	92 01       	movw	r18, r4
    6fc6:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    6fca:	2b 01       	movw	r4, r22
    6fcc:	3c 01       	movw	r6, r24
    6fce:	69 a5       	lds	r22, 0x69
    6fd0:	7a a5       	lds	r23, 0x6a
    6fd2:	8b a5       	lds	r24, 0x6b
    6fd4:	9c a5       	lds	r25, 0x6c
    6fd6:	29 a9       	sts	0x49, r18
    6fd8:	3a a9       	sts	0x4a, r19
    6fda:	4b a9       	sts	0x4b, r20
    6fdc:	5c a9       	sts	0x4c, r21
    6fde:	0e 94 84 3a 	call	0x7508	; 0x7508 <__mulsi3>
    6fe2:	ab 01       	movw	r20, r22
    6fe4:	bc 01       	movw	r22, r24
    6fe6:	84 0c       	add	r8, r4
    6fe8:	95 1c       	adc	r9, r5
    6fea:	a6 1c       	adc	r10, r6
    6fec:	b7 1c       	adc	r11, r7
    6fee:	09 ad       	sts	0x69, r16
    6ff0:	1a ad       	sts	0x6a, r17
    6ff2:	2b ad       	sts	0x6b, r18
    6ff4:	3c ad       	sts	0x6c, r19
    6ff6:	c9 01       	movw	r24, r18
    6ff8:	aa 27       	eor	r26, r26
    6ffa:	bb 27       	eor	r27, r27
    6ffc:	88 0e       	add	r8, r24
    6ffe:	99 1e       	adc	r9, r25
    7000:	aa 1e       	adc	r10, r26
    7002:	bb 1e       	adc	r11, r27
    7004:	84 14       	cp	r8, r4
    7006:	95 04       	cpc	r9, r5
    7008:	a6 04       	cpc	r10, r6
    700a:	b7 04       	cpc	r11, r7
    700c:	20 f4       	brcc	.+8      	; 0x7016 <__divdi3+0xde4>
    700e:	40 50       	subi	r20, 0x00	; 0
    7010:	50 40       	sbci	r21, 0x00	; 0
    7012:	6f 4f       	sbci	r22, 0xFF	; 255
    7014:	7f 4f       	sbci	r23, 0xFF	; 255
    7016:	c5 01       	movw	r24, r10
    7018:	aa 27       	eor	r26, r26
    701a:	bb 27       	eor	r27, r27
    701c:	84 0f       	add	r24, r20
    701e:	95 1f       	adc	r25, r21
    7020:	a6 1f       	adc	r26, r22
    7022:	b7 1f       	adc	r27, r23
    7024:	0d a5       	lds	r16, 0x6d
    7026:	1e a5       	lds	r17, 0x6e
    7028:	2f a5       	lds	r18, 0x6f
    702a:	38 a9       	sts	0x48, r19
    702c:	08 17       	cp	r16, r24
    702e:	19 07       	cpc	r17, r25
    7030:	2a 07       	cpc	r18, r26
    7032:	3b 07       	cpc	r19, r27
    7034:	18 f1       	brcs	.+70     	; 0x707c <__divdi3+0xe4a>
    7036:	80 17       	cp	r24, r16
    7038:	91 07       	cpc	r25, r17
    703a:	a2 07       	cpc	r26, r18
    703c:	b3 07       	cpc	r27, r19
    703e:	a1 f5       	brne	.+104    	; 0x70a8 <__divdi3+0xe76>
    7040:	54 01       	movw	r10, r8
    7042:	99 24       	eor	r9, r9
    7044:	88 24       	eor	r8, r8
    7046:	89 ad       	sts	0x69, r24
    7048:	9a ad       	sts	0x6a, r25
    704a:	ab ad       	sts	0x6b, r26
    704c:	bc ad       	sts	0x6c, r27
    704e:	a0 70       	andi	r26, 0x00	; 0
    7050:	b0 70       	andi	r27, 0x00	; 0
    7052:	88 0e       	add	r8, r24
    7054:	99 1e       	adc	r9, r25
    7056:	aa 1e       	adc	r10, r26
    7058:	bb 1e       	adc	r11, r27
    705a:	4d a9       	sts	0x4d, r20
    705c:	5e a9       	sts	0x4e, r21
    705e:	6f a9       	sts	0x4f, r22
    7060:	78 ad       	sts	0x68, r23
    7062:	03 2c       	mov	r0, r3
    7064:	04 c0       	rjmp	.+8      	; 0x706e <__divdi3+0xe3c>
    7066:	44 0f       	add	r20, r20
    7068:	55 1f       	adc	r21, r21
    706a:	66 1f       	adc	r22, r22
    706c:	77 1f       	adc	r23, r23
    706e:	0a 94       	dec	r0
    7070:	d2 f7       	brpl	.-12     	; 0x7066 <__divdi3+0xe34>
    7072:	48 15       	cp	r20, r8
    7074:	59 05       	cpc	r21, r9
    7076:	6a 05       	cpc	r22, r10
    7078:	7b 05       	cpc	r23, r11
    707a:	b0 f4       	brcc	.+44     	; 0x70a8 <__divdi3+0xe76>
    707c:	08 94       	sec
    707e:	c1 08       	sbc	r12, r1
    7080:	d1 08       	sbc	r13, r1
    7082:	e1 08       	sbc	r14, r1
    7084:	f1 08       	sbc	r15, r1
    7086:	10 c0       	rjmp	.+32     	; 0x70a8 <__divdi3+0xe76>
    7088:	44 24       	eor	r4, r4
    708a:	55 24       	eor	r5, r5
    708c:	32 01       	movw	r6, r4
    708e:	cc 24       	eor	r12, r12
    7090:	dd 24       	eor	r13, r13
    7092:	76 01       	movw	r14, r12
    7094:	0c c0       	rjmp	.+24     	; 0x70ae <__divdi3+0xe7c>
    7096:	44 24       	eor	r4, r4
    7098:	55 24       	eor	r5, r5
    709a:	32 01       	movw	r6, r4
    709c:	81 e0       	ldi	r24, 0x01	; 1
    709e:	c8 2e       	mov	r12, r24
    70a0:	d1 2c       	mov	r13, r1
    70a2:	e1 2c       	mov	r14, r1
    70a4:	f1 2c       	mov	r15, r1
    70a6:	03 c0       	rjmp	.+6      	; 0x70ae <__divdi3+0xe7c>
    70a8:	44 24       	eor	r4, r4
    70aa:	55 24       	eor	r5, r5
    70ac:	32 01       	movw	r6, r4
    70ae:	fe 01       	movw	r30, r28
    70b0:	31 96       	adiw	r30, 0x01	; 1
    70b2:	88 e0       	ldi	r24, 0x08	; 8
    70b4:	df 01       	movw	r26, r30
    70b6:	1d 92       	st	X+, r1
    70b8:	8a 95       	dec	r24
    70ba:	e9 f7       	brne	.-6      	; 0x70b6 <__divdi3+0xe84>
    70bc:	c9 82       	std	Y+1, r12	; 0x01
    70be:	da 82       	std	Y+2, r13	; 0x02
    70c0:	eb 82       	std	Y+3, r14	; 0x03
    70c2:	fc 82       	std	Y+4, r15	; 0x04
    70c4:	4d 82       	std	Y+5, r4	; 0x05
    70c6:	5e 82       	std	Y+6, r5	; 0x06
    70c8:	6f 82       	std	Y+7, r6	; 0x07
    70ca:	78 86       	std	Y+8, r7	; 0x08
    70cc:	2c 2d       	mov	r18, r12
    70ce:	3a 81       	ldd	r19, Y+2	; 0x02
    70d0:	4b 81       	ldd	r20, Y+3	; 0x03
    70d2:	5c 81       	ldd	r21, Y+4	; 0x04
    70d4:	64 2d       	mov	r22, r4
    70d6:	7e 81       	ldd	r23, Y+6	; 0x06
    70d8:	8f 81       	ldd	r24, Y+7	; 0x07
    70da:	98 85       	ldd	r25, Y+8	; 0x08
    70dc:	25 96       	adiw	r28, 0x05	; 5
    70de:	ec ac       	sts	0xac, r30
    70e0:	fd ac       	sts	0xad, r31
    70e2:	0e ad       	sts	0x6e, r16
    70e4:	1f ad       	sts	0x6f, r17
    70e6:	25 97       	sbiw	r28, 0x05	; 5
    70e8:	e1 14       	cp	r14, r1
    70ea:	f1 04       	cpc	r15, r1
    70ec:	01 05       	cpc	r16, r1
    70ee:	11 05       	cpc	r17, r1
    70f0:	09 f4       	brne	.+2      	; 0x70f4 <__divdi3+0xec2>
    70f2:	56 c0       	rjmp	.+172    	; 0x71a0 <__divdi3+0xf6e>
    70f4:	21 95       	neg	r18
    70f6:	e1 e0       	ldi	r30, 0x01	; 1
    70f8:	12 16       	cp	r1, r18
    70fa:	08 f0       	brcs	.+2      	; 0x70fe <__divdi3+0xecc>
    70fc:	e0 e0       	ldi	r30, 0x00	; 0
    70fe:	31 95       	neg	r19
    7100:	f1 e0       	ldi	r31, 0x01	; 1
    7102:	13 16       	cp	r1, r19
    7104:	08 f0       	brcs	.+2      	; 0x7108 <__divdi3+0xed6>
    7106:	f0 e0       	ldi	r31, 0x00	; 0
    7108:	03 2f       	mov	r16, r19
    710a:	0e 1b       	sub	r16, r30
    710c:	e1 e0       	ldi	r30, 0x01	; 1
    710e:	30 17       	cp	r19, r16
    7110:	08 f0       	brcs	.+2      	; 0x7114 <__divdi3+0xee2>
    7112:	e0 e0       	ldi	r30, 0x00	; 0
    7114:	fe 2b       	or	r31, r30
    7116:	41 95       	neg	r20
    7118:	e1 e0       	ldi	r30, 0x01	; 1
    711a:	14 16       	cp	r1, r20
    711c:	08 f0       	brcs	.+2      	; 0x7120 <__divdi3+0xeee>
    711e:	e0 e0       	ldi	r30, 0x00	; 0
    7120:	14 2f       	mov	r17, r20
    7122:	1f 1b       	sub	r17, r31
    7124:	31 e0       	ldi	r19, 0x01	; 1
    7126:	41 17       	cp	r20, r17
    7128:	08 f0       	brcs	.+2      	; 0x712c <__divdi3+0xefa>
    712a:	30 e0       	ldi	r19, 0x00	; 0
    712c:	e3 2b       	or	r30, r19
    712e:	51 95       	neg	r21
    7130:	f1 e0       	ldi	r31, 0x01	; 1
    7132:	15 16       	cp	r1, r21
    7134:	08 f0       	brcs	.+2      	; 0x7138 <__divdi3+0xf06>
    7136:	f0 e0       	ldi	r31, 0x00	; 0
    7138:	b5 2f       	mov	r27, r21
    713a:	be 1b       	sub	r27, r30
    713c:	31 e0       	ldi	r19, 0x01	; 1
    713e:	5b 17       	cp	r21, r27
    7140:	08 f0       	brcs	.+2      	; 0x7144 <__divdi3+0xf12>
    7142:	30 e0       	ldi	r19, 0x00	; 0
    7144:	f3 2b       	or	r31, r19
    7146:	61 95       	neg	r22
    7148:	e1 e0       	ldi	r30, 0x01	; 1
    714a:	16 16       	cp	r1, r22
    714c:	08 f0       	brcs	.+2      	; 0x7150 <__divdi3+0xf1e>
    714e:	e0 e0       	ldi	r30, 0x00	; 0
    7150:	46 2e       	mov	r4, r22
    7152:	4f 1a       	sub	r4, r31
    7154:	31 e0       	ldi	r19, 0x01	; 1
    7156:	64 15       	cp	r22, r4
    7158:	08 f0       	brcs	.+2      	; 0x715c <__divdi3+0xf2a>
    715a:	30 e0       	ldi	r19, 0x00	; 0
    715c:	e3 2b       	or	r30, r19
    715e:	71 95       	neg	r23
    7160:	f1 e0       	ldi	r31, 0x01	; 1
    7162:	17 16       	cp	r1, r23
    7164:	08 f0       	brcs	.+2      	; 0x7168 <__divdi3+0xf36>
    7166:	f0 e0       	ldi	r31, 0x00	; 0
    7168:	a7 2f       	mov	r26, r23
    716a:	ae 1b       	sub	r26, r30
    716c:	31 e0       	ldi	r19, 0x01	; 1
    716e:	7a 17       	cp	r23, r26
    7170:	08 f0       	brcs	.+2      	; 0x7174 <__divdi3+0xf42>
    7172:	30 e0       	ldi	r19, 0x00	; 0
    7174:	f3 2b       	or	r31, r19
    7176:	81 95       	neg	r24
    7178:	e1 e0       	ldi	r30, 0x01	; 1
    717a:	18 16       	cp	r1, r24
    717c:	08 f0       	brcs	.+2      	; 0x7180 <__divdi3+0xf4e>
    717e:	e0 e0       	ldi	r30, 0x00	; 0
    7180:	f8 2e       	mov	r15, r24
    7182:	ff 1a       	sub	r15, r31
    7184:	ff 2d       	mov	r31, r15
    7186:	31 e0       	ldi	r19, 0x01	; 1
    7188:	8f 15       	cp	r24, r15
    718a:	08 f0       	brcs	.+2      	; 0x718e <__divdi3+0xf5c>
    718c:	30 e0       	ldi	r19, 0x00	; 0
    718e:	e3 2b       	or	r30, r19
    7190:	91 95       	neg	r25
    7192:	30 2f       	mov	r19, r16
    7194:	41 2f       	mov	r20, r17
    7196:	5b 2f       	mov	r21, r27
    7198:	64 2d       	mov	r22, r4
    719a:	7a 2f       	mov	r23, r26
    719c:	8f 2f       	mov	r24, r31
    719e:	9e 1b       	sub	r25, r30
    71a0:	c8 5b       	subi	r28, 0xB8	; 184
    71a2:	df 4f       	sbci	r29, 0xFF	; 255
    71a4:	e1 e1       	ldi	r30, 0x11	; 17
    71a6:	0c 94 21 3b 	jmp	0x7642	; 0x7642 <__epilogue_restores__+0x2>

000071aa <__subsf3>:
    71aa:	50 58       	subi	r21, 0x80	; 128

000071ac <__addsf3>:
    71ac:	bb 27       	eor	r27, r27
    71ae:	aa 27       	eor	r26, r26
    71b0:	0e d0       	rcall	.+28     	; 0x71ce <__addsf3x>
    71b2:	48 c1       	rjmp	.+656    	; 0x7444 <__fp_round>
    71b4:	39 d1       	rcall	.+626    	; 0x7428 <__fp_pscA>
    71b6:	30 f0       	brcs	.+12     	; 0x71c4 <__addsf3+0x18>
    71b8:	3e d1       	rcall	.+636    	; 0x7436 <__fp_pscB>
    71ba:	20 f0       	brcs	.+8      	; 0x71c4 <__addsf3+0x18>
    71bc:	31 f4       	brne	.+12     	; 0x71ca <__addsf3+0x1e>
    71be:	9f 3f       	cpi	r25, 0xFF	; 255
    71c0:	11 f4       	brne	.+4      	; 0x71c6 <__addsf3+0x1a>
    71c2:	1e f4       	brtc	.+6      	; 0x71ca <__addsf3+0x1e>
    71c4:	2e c1       	rjmp	.+604    	; 0x7422 <__fp_nan>
    71c6:	0e f4       	brtc	.+2      	; 0x71ca <__addsf3+0x1e>
    71c8:	e0 95       	com	r30
    71ca:	e7 fb       	bst	r30, 7
    71cc:	24 c1       	rjmp	.+584    	; 0x7416 <__fp_inf>

000071ce <__addsf3x>:
    71ce:	e9 2f       	mov	r30, r25
    71d0:	4a d1       	rcall	.+660    	; 0x7466 <__fp_split3>
    71d2:	80 f3       	brcs	.-32     	; 0x71b4 <__addsf3+0x8>
    71d4:	ba 17       	cp	r27, r26
    71d6:	62 07       	cpc	r22, r18
    71d8:	73 07       	cpc	r23, r19
    71da:	84 07       	cpc	r24, r20
    71dc:	95 07       	cpc	r25, r21
    71de:	18 f0       	brcs	.+6      	; 0x71e6 <__addsf3x+0x18>
    71e0:	71 f4       	brne	.+28     	; 0x71fe <__addsf3x+0x30>
    71e2:	9e f5       	brtc	.+102    	; 0x724a <__addsf3x+0x7c>
    71e4:	62 c1       	rjmp	.+708    	; 0x74aa <__fp_zero>
    71e6:	0e f4       	brtc	.+2      	; 0x71ea <__addsf3x+0x1c>
    71e8:	e0 95       	com	r30
    71ea:	0b 2e       	mov	r0, r27
    71ec:	ba 2f       	mov	r27, r26
    71ee:	a0 2d       	mov	r26, r0
    71f0:	0b 01       	movw	r0, r22
    71f2:	b9 01       	movw	r22, r18
    71f4:	90 01       	movw	r18, r0
    71f6:	0c 01       	movw	r0, r24
    71f8:	ca 01       	movw	r24, r20
    71fa:	a0 01       	movw	r20, r0
    71fc:	11 24       	eor	r1, r1
    71fe:	ff 27       	eor	r31, r31
    7200:	59 1b       	sub	r21, r25
    7202:	99 f0       	breq	.+38     	; 0x722a <__addsf3x+0x5c>
    7204:	59 3f       	cpi	r21, 0xF9	; 249
    7206:	50 f4       	brcc	.+20     	; 0x721c <__addsf3x+0x4e>
    7208:	50 3e       	cpi	r21, 0xE0	; 224
    720a:	68 f1       	brcs	.+90     	; 0x7266 <__addsf3x+0x98>
    720c:	1a 16       	cp	r1, r26
    720e:	f0 40       	sbci	r31, 0x00	; 0
    7210:	a2 2f       	mov	r26, r18
    7212:	23 2f       	mov	r18, r19
    7214:	34 2f       	mov	r19, r20
    7216:	44 27       	eor	r20, r20
    7218:	58 5f       	subi	r21, 0xF8	; 248
    721a:	f3 cf       	rjmp	.-26     	; 0x7202 <__addsf3x+0x34>
    721c:	46 95       	lsr	r20
    721e:	37 95       	ror	r19
    7220:	27 95       	ror	r18
    7222:	a7 95       	ror	r26
    7224:	f0 40       	sbci	r31, 0x00	; 0
    7226:	53 95       	inc	r21
    7228:	c9 f7       	brne	.-14     	; 0x721c <__addsf3x+0x4e>
    722a:	7e f4       	brtc	.+30     	; 0x724a <__addsf3x+0x7c>
    722c:	1f 16       	cp	r1, r31
    722e:	ba 0b       	sbc	r27, r26
    7230:	62 0b       	sbc	r22, r18
    7232:	73 0b       	sbc	r23, r19
    7234:	84 0b       	sbc	r24, r20
    7236:	ba f0       	brmi	.+46     	; 0x7266 <__addsf3x+0x98>
    7238:	91 50       	subi	r25, 0x01	; 1
    723a:	a1 f0       	breq	.+40     	; 0x7264 <__addsf3x+0x96>
    723c:	ff 0f       	add	r31, r31
    723e:	bb 1f       	adc	r27, r27
    7240:	66 1f       	adc	r22, r22
    7242:	77 1f       	adc	r23, r23
    7244:	88 1f       	adc	r24, r24
    7246:	c2 f7       	brpl	.-16     	; 0x7238 <__addsf3x+0x6a>
    7248:	0e c0       	rjmp	.+28     	; 0x7266 <__addsf3x+0x98>
    724a:	ba 0f       	add	r27, r26
    724c:	62 1f       	adc	r22, r18
    724e:	73 1f       	adc	r23, r19
    7250:	84 1f       	adc	r24, r20
    7252:	48 f4       	brcc	.+18     	; 0x7266 <__addsf3x+0x98>
    7254:	87 95       	ror	r24
    7256:	77 95       	ror	r23
    7258:	67 95       	ror	r22
    725a:	b7 95       	ror	r27
    725c:	f7 95       	ror	r31
    725e:	9e 3f       	cpi	r25, 0xFE	; 254
    7260:	08 f0       	brcs	.+2      	; 0x7264 <__addsf3x+0x96>
    7262:	b3 cf       	rjmp	.-154    	; 0x71ca <__addsf3+0x1e>
    7264:	93 95       	inc	r25
    7266:	88 0f       	add	r24, r24
    7268:	08 f0       	brcs	.+2      	; 0x726c <__addsf3x+0x9e>
    726a:	99 27       	eor	r25, r25
    726c:	ee 0f       	add	r30, r30
    726e:	97 95       	ror	r25
    7270:	87 95       	ror	r24
    7272:	08 95       	ret

00007274 <__divsf3>:
    7274:	0c d0       	rcall	.+24     	; 0x728e <__divsf3x>
    7276:	e6 c0       	rjmp	.+460    	; 0x7444 <__fp_round>
    7278:	de d0       	rcall	.+444    	; 0x7436 <__fp_pscB>
    727a:	40 f0       	brcs	.+16     	; 0x728c <__divsf3+0x18>
    727c:	d5 d0       	rcall	.+426    	; 0x7428 <__fp_pscA>
    727e:	30 f0       	brcs	.+12     	; 0x728c <__divsf3+0x18>
    7280:	21 f4       	brne	.+8      	; 0x728a <__divsf3+0x16>
    7282:	5f 3f       	cpi	r21, 0xFF	; 255
    7284:	19 f0       	breq	.+6      	; 0x728c <__divsf3+0x18>
    7286:	c7 c0       	rjmp	.+398    	; 0x7416 <__fp_inf>
    7288:	51 11       	cpse	r21, r1
    728a:	10 c1       	rjmp	.+544    	; 0x74ac <__fp_szero>
    728c:	ca c0       	rjmp	.+404    	; 0x7422 <__fp_nan>

0000728e <__divsf3x>:
    728e:	eb d0       	rcall	.+470    	; 0x7466 <__fp_split3>
    7290:	98 f3       	brcs	.-26     	; 0x7278 <__divsf3+0x4>

00007292 <__divsf3_pse>:
    7292:	99 23       	and	r25, r25
    7294:	c9 f3       	breq	.-14     	; 0x7288 <__divsf3+0x14>
    7296:	55 23       	and	r21, r21
    7298:	b1 f3       	breq	.-20     	; 0x7286 <__divsf3+0x12>
    729a:	95 1b       	sub	r25, r21
    729c:	55 0b       	sbc	r21, r21
    729e:	bb 27       	eor	r27, r27
    72a0:	aa 27       	eor	r26, r26
    72a2:	62 17       	cp	r22, r18
    72a4:	73 07       	cpc	r23, r19
    72a6:	84 07       	cpc	r24, r20
    72a8:	38 f0       	brcs	.+14     	; 0x72b8 <__divsf3_pse+0x26>
    72aa:	9f 5f       	subi	r25, 0xFF	; 255
    72ac:	5f 4f       	sbci	r21, 0xFF	; 255
    72ae:	22 0f       	add	r18, r18
    72b0:	33 1f       	adc	r19, r19
    72b2:	44 1f       	adc	r20, r20
    72b4:	aa 1f       	adc	r26, r26
    72b6:	a9 f3       	breq	.-22     	; 0x72a2 <__divsf3_pse+0x10>
    72b8:	33 d0       	rcall	.+102    	; 0x7320 <__divsf3_pse+0x8e>
    72ba:	0e 2e       	mov	r0, r30
    72bc:	3a f0       	brmi	.+14     	; 0x72cc <__divsf3_pse+0x3a>
    72be:	e0 e8       	ldi	r30, 0x80	; 128
    72c0:	30 d0       	rcall	.+96     	; 0x7322 <__divsf3_pse+0x90>
    72c2:	91 50       	subi	r25, 0x01	; 1
    72c4:	50 40       	sbci	r21, 0x00	; 0
    72c6:	e6 95       	lsr	r30
    72c8:	00 1c       	adc	r0, r0
    72ca:	ca f7       	brpl	.-14     	; 0x72be <__divsf3_pse+0x2c>
    72cc:	29 d0       	rcall	.+82     	; 0x7320 <__divsf3_pse+0x8e>
    72ce:	fe 2f       	mov	r31, r30
    72d0:	27 d0       	rcall	.+78     	; 0x7320 <__divsf3_pse+0x8e>
    72d2:	66 0f       	add	r22, r22
    72d4:	77 1f       	adc	r23, r23
    72d6:	88 1f       	adc	r24, r24
    72d8:	bb 1f       	adc	r27, r27
    72da:	26 17       	cp	r18, r22
    72dc:	37 07       	cpc	r19, r23
    72de:	48 07       	cpc	r20, r24
    72e0:	ab 07       	cpc	r26, r27
    72e2:	b0 e8       	ldi	r27, 0x80	; 128
    72e4:	09 f0       	breq	.+2      	; 0x72e8 <__divsf3_pse+0x56>
    72e6:	bb 0b       	sbc	r27, r27
    72e8:	80 2d       	mov	r24, r0
    72ea:	bf 01       	movw	r22, r30
    72ec:	ff 27       	eor	r31, r31
    72ee:	93 58       	subi	r25, 0x83	; 131
    72f0:	5f 4f       	sbci	r21, 0xFF	; 255
    72f2:	2a f0       	brmi	.+10     	; 0x72fe <__divsf3_pse+0x6c>
    72f4:	9e 3f       	cpi	r25, 0xFE	; 254
    72f6:	51 05       	cpc	r21, r1
    72f8:	68 f0       	brcs	.+26     	; 0x7314 <__divsf3_pse+0x82>
    72fa:	8d c0       	rjmp	.+282    	; 0x7416 <__fp_inf>
    72fc:	d7 c0       	rjmp	.+430    	; 0x74ac <__fp_szero>
    72fe:	5f 3f       	cpi	r21, 0xFF	; 255
    7300:	ec f3       	brlt	.-6      	; 0x72fc <__divsf3_pse+0x6a>
    7302:	98 3e       	cpi	r25, 0xE8	; 232
    7304:	dc f3       	brlt	.-10     	; 0x72fc <__divsf3_pse+0x6a>
    7306:	86 95       	lsr	r24
    7308:	77 95       	ror	r23
    730a:	67 95       	ror	r22
    730c:	b7 95       	ror	r27
    730e:	f7 95       	ror	r31
    7310:	9f 5f       	subi	r25, 0xFF	; 255
    7312:	c9 f7       	brne	.-14     	; 0x7306 <__divsf3_pse+0x74>
    7314:	88 0f       	add	r24, r24
    7316:	91 1d       	adc	r25, r1
    7318:	96 95       	lsr	r25
    731a:	87 95       	ror	r24
    731c:	97 f9       	bld	r25, 7
    731e:	08 95       	ret
    7320:	e1 e0       	ldi	r30, 0x01	; 1
    7322:	66 0f       	add	r22, r22
    7324:	77 1f       	adc	r23, r23
    7326:	88 1f       	adc	r24, r24
    7328:	bb 1f       	adc	r27, r27
    732a:	62 17       	cp	r22, r18
    732c:	73 07       	cpc	r23, r19
    732e:	84 07       	cpc	r24, r20
    7330:	ba 07       	cpc	r27, r26
    7332:	20 f0       	brcs	.+8      	; 0x733c <__divsf3_pse+0xaa>
    7334:	62 1b       	sub	r22, r18
    7336:	73 0b       	sbc	r23, r19
    7338:	84 0b       	sbc	r24, r20
    733a:	ba 0b       	sbc	r27, r26
    733c:	ee 1f       	adc	r30, r30
    733e:	88 f7       	brcc	.-30     	; 0x7322 <__divsf3_pse+0x90>
    7340:	e0 95       	com	r30
    7342:	08 95       	ret

00007344 <__fixunssfsi>:
    7344:	98 d0       	rcall	.+304    	; 0x7476 <__fp_splitA>
    7346:	88 f0       	brcs	.+34     	; 0x736a <__fixunssfsi+0x26>
    7348:	9f 57       	subi	r25, 0x7F	; 127
    734a:	90 f0       	brcs	.+36     	; 0x7370 <__fixunssfsi+0x2c>
    734c:	b9 2f       	mov	r27, r25
    734e:	99 27       	eor	r25, r25
    7350:	b7 51       	subi	r27, 0x17	; 23
    7352:	a0 f0       	brcs	.+40     	; 0x737c <__fixunssfsi+0x38>
    7354:	d1 f0       	breq	.+52     	; 0x738a <__fixunssfsi+0x46>
    7356:	66 0f       	add	r22, r22
    7358:	77 1f       	adc	r23, r23
    735a:	88 1f       	adc	r24, r24
    735c:	99 1f       	adc	r25, r25
    735e:	1a f0       	brmi	.+6      	; 0x7366 <__fixunssfsi+0x22>
    7360:	ba 95       	dec	r27
    7362:	c9 f7       	brne	.-14     	; 0x7356 <__fixunssfsi+0x12>
    7364:	12 c0       	rjmp	.+36     	; 0x738a <__fixunssfsi+0x46>
    7366:	b1 30       	cpi	r27, 0x01	; 1
    7368:	81 f0       	breq	.+32     	; 0x738a <__fixunssfsi+0x46>
    736a:	9f d0       	rcall	.+318    	; 0x74aa <__fp_zero>
    736c:	b1 e0       	ldi	r27, 0x01	; 1
    736e:	08 95       	ret
    7370:	9c c0       	rjmp	.+312    	; 0x74aa <__fp_zero>
    7372:	67 2f       	mov	r22, r23
    7374:	78 2f       	mov	r23, r24
    7376:	88 27       	eor	r24, r24
    7378:	b8 5f       	subi	r27, 0xF8	; 248
    737a:	39 f0       	breq	.+14     	; 0x738a <__fixunssfsi+0x46>
    737c:	b9 3f       	cpi	r27, 0xF9	; 249
    737e:	cc f3       	brlt	.-14     	; 0x7372 <__fixunssfsi+0x2e>
    7380:	86 95       	lsr	r24
    7382:	77 95       	ror	r23
    7384:	67 95       	ror	r22
    7386:	b3 95       	inc	r27
    7388:	d9 f7       	brne	.-10     	; 0x7380 <__fixunssfsi+0x3c>
    738a:	3e f4       	brtc	.+14     	; 0x739a <__fixunssfsi+0x56>
    738c:	90 95       	com	r25
    738e:	80 95       	com	r24
    7390:	70 95       	com	r23
    7392:	61 95       	neg	r22
    7394:	7f 4f       	sbci	r23, 0xFF	; 255
    7396:	8f 4f       	sbci	r24, 0xFF	; 255
    7398:	9f 4f       	sbci	r25, 0xFF	; 255
    739a:	08 95       	ret

0000739c <__floatunsisf>:
    739c:	e8 94       	clt
    739e:	09 c0       	rjmp	.+18     	; 0x73b2 <__floatsisf+0x12>

000073a0 <__floatsisf>:
    73a0:	97 fb       	bst	r25, 7
    73a2:	3e f4       	brtc	.+14     	; 0x73b2 <__floatsisf+0x12>
    73a4:	90 95       	com	r25
    73a6:	80 95       	com	r24
    73a8:	70 95       	com	r23
    73aa:	61 95       	neg	r22
    73ac:	7f 4f       	sbci	r23, 0xFF	; 255
    73ae:	8f 4f       	sbci	r24, 0xFF	; 255
    73b0:	9f 4f       	sbci	r25, 0xFF	; 255
    73b2:	99 23       	and	r25, r25
    73b4:	a9 f0       	breq	.+42     	; 0x73e0 <__floatsisf+0x40>
    73b6:	f9 2f       	mov	r31, r25
    73b8:	96 e9       	ldi	r25, 0x96	; 150
    73ba:	bb 27       	eor	r27, r27
    73bc:	93 95       	inc	r25
    73be:	f6 95       	lsr	r31
    73c0:	87 95       	ror	r24
    73c2:	77 95       	ror	r23
    73c4:	67 95       	ror	r22
    73c6:	b7 95       	ror	r27
    73c8:	f1 11       	cpse	r31, r1
    73ca:	f8 cf       	rjmp	.-16     	; 0x73bc <__floatsisf+0x1c>
    73cc:	fa f4       	brpl	.+62     	; 0x740c <__floatsisf+0x6c>
    73ce:	bb 0f       	add	r27, r27
    73d0:	11 f4       	brne	.+4      	; 0x73d6 <__floatsisf+0x36>
    73d2:	60 ff       	sbrs	r22, 0
    73d4:	1b c0       	rjmp	.+54     	; 0x740c <__floatsisf+0x6c>
    73d6:	6f 5f       	subi	r22, 0xFF	; 255
    73d8:	7f 4f       	sbci	r23, 0xFF	; 255
    73da:	8f 4f       	sbci	r24, 0xFF	; 255
    73dc:	9f 4f       	sbci	r25, 0xFF	; 255
    73de:	16 c0       	rjmp	.+44     	; 0x740c <__floatsisf+0x6c>
    73e0:	88 23       	and	r24, r24
    73e2:	11 f0       	breq	.+4      	; 0x73e8 <__floatsisf+0x48>
    73e4:	96 e9       	ldi	r25, 0x96	; 150
    73e6:	11 c0       	rjmp	.+34     	; 0x740a <__floatsisf+0x6a>
    73e8:	77 23       	and	r23, r23
    73ea:	21 f0       	breq	.+8      	; 0x73f4 <__floatsisf+0x54>
    73ec:	9e e8       	ldi	r25, 0x8E	; 142
    73ee:	87 2f       	mov	r24, r23
    73f0:	76 2f       	mov	r23, r22
    73f2:	05 c0       	rjmp	.+10     	; 0x73fe <__floatsisf+0x5e>
    73f4:	66 23       	and	r22, r22
    73f6:	71 f0       	breq	.+28     	; 0x7414 <__floatsisf+0x74>
    73f8:	96 e8       	ldi	r25, 0x86	; 134
    73fa:	86 2f       	mov	r24, r22
    73fc:	70 e0       	ldi	r23, 0x00	; 0
    73fe:	60 e0       	ldi	r22, 0x00	; 0
    7400:	2a f0       	brmi	.+10     	; 0x740c <__floatsisf+0x6c>
    7402:	9a 95       	dec	r25
    7404:	66 0f       	add	r22, r22
    7406:	77 1f       	adc	r23, r23
    7408:	88 1f       	adc	r24, r24
    740a:	da f7       	brpl	.-10     	; 0x7402 <__floatsisf+0x62>
    740c:	88 0f       	add	r24, r24
    740e:	96 95       	lsr	r25
    7410:	87 95       	ror	r24
    7412:	97 f9       	bld	r25, 7
    7414:	08 95       	ret

00007416 <__fp_inf>:
    7416:	97 f9       	bld	r25, 7
    7418:	9f 67       	ori	r25, 0x7F	; 127
    741a:	80 e8       	ldi	r24, 0x80	; 128
    741c:	70 e0       	ldi	r23, 0x00	; 0
    741e:	60 e0       	ldi	r22, 0x00	; 0
    7420:	08 95       	ret

00007422 <__fp_nan>:
    7422:	9f ef       	ldi	r25, 0xFF	; 255
    7424:	80 ec       	ldi	r24, 0xC0	; 192
    7426:	08 95       	ret

00007428 <__fp_pscA>:
    7428:	00 24       	eor	r0, r0
    742a:	0a 94       	dec	r0
    742c:	16 16       	cp	r1, r22
    742e:	17 06       	cpc	r1, r23
    7430:	18 06       	cpc	r1, r24
    7432:	09 06       	cpc	r0, r25
    7434:	08 95       	ret

00007436 <__fp_pscB>:
    7436:	00 24       	eor	r0, r0
    7438:	0a 94       	dec	r0
    743a:	12 16       	cp	r1, r18
    743c:	13 06       	cpc	r1, r19
    743e:	14 06       	cpc	r1, r20
    7440:	05 06       	cpc	r0, r21
    7442:	08 95       	ret

00007444 <__fp_round>:
    7444:	09 2e       	mov	r0, r25
    7446:	03 94       	inc	r0
    7448:	00 0c       	add	r0, r0
    744a:	11 f4       	brne	.+4      	; 0x7450 <__fp_round+0xc>
    744c:	88 23       	and	r24, r24
    744e:	52 f0       	brmi	.+20     	; 0x7464 <__fp_round+0x20>
    7450:	bb 0f       	add	r27, r27
    7452:	40 f4       	brcc	.+16     	; 0x7464 <__fp_round+0x20>
    7454:	bf 2b       	or	r27, r31
    7456:	11 f4       	brne	.+4      	; 0x745c <__fp_round+0x18>
    7458:	60 ff       	sbrs	r22, 0
    745a:	04 c0       	rjmp	.+8      	; 0x7464 <__fp_round+0x20>
    745c:	6f 5f       	subi	r22, 0xFF	; 255
    745e:	7f 4f       	sbci	r23, 0xFF	; 255
    7460:	8f 4f       	sbci	r24, 0xFF	; 255
    7462:	9f 4f       	sbci	r25, 0xFF	; 255
    7464:	08 95       	ret

00007466 <__fp_split3>:
    7466:	57 fd       	sbrc	r21, 7
    7468:	90 58       	subi	r25, 0x80	; 128
    746a:	44 0f       	add	r20, r20
    746c:	55 1f       	adc	r21, r21
    746e:	59 f0       	breq	.+22     	; 0x7486 <__fp_splitA+0x10>
    7470:	5f 3f       	cpi	r21, 0xFF	; 255
    7472:	71 f0       	breq	.+28     	; 0x7490 <__fp_splitA+0x1a>
    7474:	47 95       	ror	r20

00007476 <__fp_splitA>:
    7476:	88 0f       	add	r24, r24
    7478:	97 fb       	bst	r25, 7
    747a:	99 1f       	adc	r25, r25
    747c:	61 f0       	breq	.+24     	; 0x7496 <__fp_splitA+0x20>
    747e:	9f 3f       	cpi	r25, 0xFF	; 255
    7480:	79 f0       	breq	.+30     	; 0x74a0 <__fp_splitA+0x2a>
    7482:	87 95       	ror	r24
    7484:	08 95       	ret
    7486:	12 16       	cp	r1, r18
    7488:	13 06       	cpc	r1, r19
    748a:	14 06       	cpc	r1, r20
    748c:	55 1f       	adc	r21, r21
    748e:	f2 cf       	rjmp	.-28     	; 0x7474 <__fp_split3+0xe>
    7490:	46 95       	lsr	r20
    7492:	f1 df       	rcall	.-30     	; 0x7476 <__fp_splitA>
    7494:	08 c0       	rjmp	.+16     	; 0x74a6 <__fp_splitA+0x30>
    7496:	16 16       	cp	r1, r22
    7498:	17 06       	cpc	r1, r23
    749a:	18 06       	cpc	r1, r24
    749c:	99 1f       	adc	r25, r25
    749e:	f1 cf       	rjmp	.-30     	; 0x7482 <__fp_splitA+0xc>
    74a0:	86 95       	lsr	r24
    74a2:	71 05       	cpc	r23, r1
    74a4:	61 05       	cpc	r22, r1
    74a6:	08 94       	sec
    74a8:	08 95       	ret

000074aa <__fp_zero>:
    74aa:	e8 94       	clt

000074ac <__fp_szero>:
    74ac:	bb 27       	eor	r27, r27
    74ae:	66 27       	eor	r22, r22
    74b0:	77 27       	eor	r23, r23
    74b2:	cb 01       	movw	r24, r22
    74b4:	97 f9       	bld	r25, 7
    74b6:	08 95       	ret

000074b8 <__gesf2>:
    74b8:	03 d0       	rcall	.+6      	; 0x74c0 <__fp_cmp>
    74ba:	08 f4       	brcc	.+2      	; 0x74be <__gesf2+0x6>
    74bc:	8f ef       	ldi	r24, 0xFF	; 255
    74be:	08 95       	ret

000074c0 <__fp_cmp>:
    74c0:	99 0f       	add	r25, r25
    74c2:	00 08       	sbc	r0, r0
    74c4:	55 0f       	add	r21, r21
    74c6:	aa 0b       	sbc	r26, r26
    74c8:	e0 e8       	ldi	r30, 0x80	; 128
    74ca:	fe ef       	ldi	r31, 0xFE	; 254
    74cc:	16 16       	cp	r1, r22
    74ce:	17 06       	cpc	r1, r23
    74d0:	e8 07       	cpc	r30, r24
    74d2:	f9 07       	cpc	r31, r25
    74d4:	c0 f0       	brcs	.+48     	; 0x7506 <__fp_cmp+0x46>
    74d6:	12 16       	cp	r1, r18
    74d8:	13 06       	cpc	r1, r19
    74da:	e4 07       	cpc	r30, r20
    74dc:	f5 07       	cpc	r31, r21
    74de:	98 f0       	brcs	.+38     	; 0x7506 <__fp_cmp+0x46>
    74e0:	62 1b       	sub	r22, r18
    74e2:	73 0b       	sbc	r23, r19
    74e4:	84 0b       	sbc	r24, r20
    74e6:	95 0b       	sbc	r25, r21
    74e8:	39 f4       	brne	.+14     	; 0x74f8 <__fp_cmp+0x38>
    74ea:	0a 26       	eor	r0, r26
    74ec:	61 f0       	breq	.+24     	; 0x7506 <__fp_cmp+0x46>
    74ee:	23 2b       	or	r18, r19
    74f0:	24 2b       	or	r18, r20
    74f2:	25 2b       	or	r18, r21
    74f4:	21 f4       	brne	.+8      	; 0x74fe <__fp_cmp+0x3e>
    74f6:	08 95       	ret
    74f8:	0a 26       	eor	r0, r26
    74fa:	09 f4       	brne	.+2      	; 0x74fe <__fp_cmp+0x3e>
    74fc:	a1 40       	sbci	r26, 0x01	; 1
    74fe:	a6 95       	lsr	r26
    7500:	8f ef       	ldi	r24, 0xFF	; 255
    7502:	81 1d       	adc	r24, r1
    7504:	81 1d       	adc	r24, r1
    7506:	08 95       	ret

00007508 <__mulsi3>:
    7508:	62 9f       	mul	r22, r18
    750a:	d0 01       	movw	r26, r0
    750c:	73 9f       	mul	r23, r19
    750e:	f0 01       	movw	r30, r0
    7510:	82 9f       	mul	r24, r18
    7512:	e0 0d       	add	r30, r0
    7514:	f1 1d       	adc	r31, r1
    7516:	64 9f       	mul	r22, r20
    7518:	e0 0d       	add	r30, r0
    751a:	f1 1d       	adc	r31, r1
    751c:	92 9f       	mul	r25, r18
    751e:	f0 0d       	add	r31, r0
    7520:	83 9f       	mul	r24, r19
    7522:	f0 0d       	add	r31, r0
    7524:	74 9f       	mul	r23, r20
    7526:	f0 0d       	add	r31, r0
    7528:	65 9f       	mul	r22, r21
    752a:	f0 0d       	add	r31, r0
    752c:	99 27       	eor	r25, r25
    752e:	72 9f       	mul	r23, r18
    7530:	b0 0d       	add	r27, r0
    7532:	e1 1d       	adc	r30, r1
    7534:	f9 1f       	adc	r31, r25
    7536:	63 9f       	mul	r22, r19
    7538:	b0 0d       	add	r27, r0
    753a:	e1 1d       	adc	r30, r1
    753c:	f9 1f       	adc	r31, r25
    753e:	bd 01       	movw	r22, r26
    7540:	cf 01       	movw	r24, r30
    7542:	11 24       	eor	r1, r1
    7544:	08 95       	ret

00007546 <__udivmodhi4>:
    7546:	aa 1b       	sub	r26, r26
    7548:	bb 1b       	sub	r27, r27
    754a:	51 e1       	ldi	r21, 0x11	; 17
    754c:	07 c0       	rjmp	.+14     	; 0x755c <__udivmodhi4_ep>

0000754e <__udivmodhi4_loop>:
    754e:	aa 1f       	adc	r26, r26
    7550:	bb 1f       	adc	r27, r27
    7552:	a6 17       	cp	r26, r22
    7554:	b7 07       	cpc	r27, r23
    7556:	10 f0       	brcs	.+4      	; 0x755c <__udivmodhi4_ep>
    7558:	a6 1b       	sub	r26, r22
    755a:	b7 0b       	sbc	r27, r23

0000755c <__udivmodhi4_ep>:
    755c:	88 1f       	adc	r24, r24
    755e:	99 1f       	adc	r25, r25
    7560:	5a 95       	dec	r21
    7562:	a9 f7       	brne	.-22     	; 0x754e <__udivmodhi4_loop>
    7564:	80 95       	com	r24
    7566:	90 95       	com	r25
    7568:	bc 01       	movw	r22, r24
    756a:	cd 01       	movw	r24, r26
    756c:	08 95       	ret

0000756e <__divmodhi4>:
    756e:	97 fb       	bst	r25, 7
    7570:	09 2e       	mov	r0, r25
    7572:	07 26       	eor	r0, r23
    7574:	0a d0       	rcall	.+20     	; 0x758a <__divmodhi4_neg1>
    7576:	77 fd       	sbrc	r23, 7
    7578:	04 d0       	rcall	.+8      	; 0x7582 <__divmodhi4_neg2>
    757a:	e5 df       	rcall	.-54     	; 0x7546 <__udivmodhi4>
    757c:	06 d0       	rcall	.+12     	; 0x758a <__divmodhi4_neg1>
    757e:	00 20       	and	r0, r0
    7580:	1a f4       	brpl	.+6      	; 0x7588 <__divmodhi4_exit>

00007582 <__divmodhi4_neg2>:
    7582:	70 95       	com	r23
    7584:	61 95       	neg	r22
    7586:	7f 4f       	sbci	r23, 0xFF	; 255

00007588 <__divmodhi4_exit>:
    7588:	08 95       	ret

0000758a <__divmodhi4_neg1>:
    758a:	f6 f7       	brtc	.-4      	; 0x7588 <__divmodhi4_exit>
    758c:	90 95       	com	r25
    758e:	81 95       	neg	r24
    7590:	9f 4f       	sbci	r25, 0xFF	; 255
    7592:	08 95       	ret

00007594 <__udivmodsi4>:
    7594:	a1 e2       	ldi	r26, 0x21	; 33
    7596:	1a 2e       	mov	r1, r26
    7598:	aa 1b       	sub	r26, r26
    759a:	bb 1b       	sub	r27, r27
    759c:	fd 01       	movw	r30, r26
    759e:	0d c0       	rjmp	.+26     	; 0x75ba <__udivmodsi4_ep>

000075a0 <__udivmodsi4_loop>:
    75a0:	aa 1f       	adc	r26, r26
    75a2:	bb 1f       	adc	r27, r27
    75a4:	ee 1f       	adc	r30, r30
    75a6:	ff 1f       	adc	r31, r31
    75a8:	a2 17       	cp	r26, r18
    75aa:	b3 07       	cpc	r27, r19
    75ac:	e4 07       	cpc	r30, r20
    75ae:	f5 07       	cpc	r31, r21
    75b0:	20 f0       	brcs	.+8      	; 0x75ba <__udivmodsi4_ep>
    75b2:	a2 1b       	sub	r26, r18
    75b4:	b3 0b       	sbc	r27, r19
    75b6:	e4 0b       	sbc	r30, r20
    75b8:	f5 0b       	sbc	r31, r21

000075ba <__udivmodsi4_ep>:
    75ba:	66 1f       	adc	r22, r22
    75bc:	77 1f       	adc	r23, r23
    75be:	88 1f       	adc	r24, r24
    75c0:	99 1f       	adc	r25, r25
    75c2:	1a 94       	dec	r1
    75c4:	69 f7       	brne	.-38     	; 0x75a0 <__udivmodsi4_loop>
    75c6:	60 95       	com	r22
    75c8:	70 95       	com	r23
    75ca:	80 95       	com	r24
    75cc:	90 95       	com	r25
    75ce:	9b 01       	movw	r18, r22
    75d0:	ac 01       	movw	r20, r24
    75d2:	bd 01       	movw	r22, r26
    75d4:	cf 01       	movw	r24, r30
    75d6:	08 95       	ret

000075d8 <__divmodsi4>:
    75d8:	97 fb       	bst	r25, 7
    75da:	09 2e       	mov	r0, r25
    75dc:	05 26       	eor	r0, r21
    75de:	0e d0       	rcall	.+28     	; 0x75fc <__divmodsi4_neg1>
    75e0:	57 fd       	sbrc	r21, 7
    75e2:	04 d0       	rcall	.+8      	; 0x75ec <__divmodsi4_neg2>
    75e4:	d7 df       	rcall	.-82     	; 0x7594 <__udivmodsi4>
    75e6:	0a d0       	rcall	.+20     	; 0x75fc <__divmodsi4_neg1>
    75e8:	00 1c       	adc	r0, r0
    75ea:	38 f4       	brcc	.+14     	; 0x75fa <__divmodsi4_exit>

000075ec <__divmodsi4_neg2>:
    75ec:	50 95       	com	r21
    75ee:	40 95       	com	r20
    75f0:	30 95       	com	r19
    75f2:	21 95       	neg	r18
    75f4:	3f 4f       	sbci	r19, 0xFF	; 255
    75f6:	4f 4f       	sbci	r20, 0xFF	; 255
    75f8:	5f 4f       	sbci	r21, 0xFF	; 255

000075fa <__divmodsi4_exit>:
    75fa:	08 95       	ret

000075fc <__divmodsi4_neg1>:
    75fc:	f6 f7       	brtc	.-4      	; 0x75fa <__divmodsi4_exit>
    75fe:	90 95       	com	r25
    7600:	80 95       	com	r24
    7602:	70 95       	com	r23
    7604:	61 95       	neg	r22
    7606:	7f 4f       	sbci	r23, 0xFF	; 255
    7608:	8f 4f       	sbci	r24, 0xFF	; 255
    760a:	9f 4f       	sbci	r25, 0xFF	; 255
    760c:	08 95       	ret

0000760e <__prologue_saves__>:
    760e:	2f 92       	push	r2
    7610:	3f 92       	push	r3
    7612:	4f 92       	push	r4
    7614:	5f 92       	push	r5
    7616:	6f 92       	push	r6
    7618:	7f 92       	push	r7
    761a:	8f 92       	push	r8
    761c:	9f 92       	push	r9
    761e:	af 92       	push	r10
    7620:	bf 92       	push	r11
    7622:	cf 92       	push	r12
    7624:	df 92       	push	r13
    7626:	ef 92       	push	r14
    7628:	ff 92       	push	r15
    762a:	0f 93       	push	r16
    762c:	1f 93       	push	r17
    762e:	cf 93       	push	r28
    7630:	df 93       	push	r29
    7632:	cd b7       	in	r28, 0x3d	; 61
    7634:	de b7       	in	r29, 0x3e	; 62
    7636:	ca 1b       	sub	r28, r26
    7638:	db 0b       	sbc	r29, r27
    763a:	cd bf       	out	0x3d, r28	; 61
    763c:	de bf       	out	0x3e, r29	; 62
    763e:	19 94       	eijmp

00007640 <__epilogue_restores__>:
    7640:	2a 88       	ldd	r2, Y+18	; 0x12
    7642:	39 88       	ldd	r3, Y+17	; 0x11
    7644:	48 88       	ldd	r4, Y+16	; 0x10
    7646:	5f 84       	ldd	r5, Y+15	; 0x0f
    7648:	6e 84       	ldd	r6, Y+14	; 0x0e
    764a:	7d 84       	ldd	r7, Y+13	; 0x0d
    764c:	8c 84       	ldd	r8, Y+12	; 0x0c
    764e:	9b 84       	ldd	r9, Y+11	; 0x0b
    7650:	aa 84       	ldd	r10, Y+10	; 0x0a
    7652:	b9 84       	ldd	r11, Y+9	; 0x09
    7654:	c8 84       	ldd	r12, Y+8	; 0x08
    7656:	df 80       	ldd	r13, Y+7	; 0x07
    7658:	ee 80       	ldd	r14, Y+6	; 0x06
    765a:	fd 80       	ldd	r15, Y+5	; 0x05
    765c:	0c 81       	ldd	r16, Y+4	; 0x04
    765e:	1b 81       	ldd	r17, Y+3	; 0x03
    7660:	aa 81       	ldd	r26, Y+2	; 0x02
    7662:	b9 81       	ldd	r27, Y+1	; 0x01
    7664:	ce 0f       	add	r28, r30
    7666:	d1 1d       	adc	r29, r1
    7668:	cd bf       	out	0x3d, r28	; 61
    766a:	de bf       	out	0x3e, r29	; 62
    766c:	ed 01       	movw	r28, r26
    766e:	08 95       	ret

00007670 <strcpy_P>:
    7670:	fb 01       	movw	r30, r22
    7672:	dc 01       	movw	r26, r24
    7674:	05 90       	lpm	r0, Z+
    7676:	0d 92       	st	X+, r0
    7678:	00 20       	and	r0, r0
    767a:	e1 f7       	brne	.-8      	; 0x7674 <strcpy_P+0x4>
    767c:	08 95       	ret

0000767e <memmove>:
    767e:	68 17       	cp	r22, r24
    7680:	79 07       	cpc	r23, r25
    7682:	68 f4       	brcc	.+26     	; 0x769e <memmove+0x20>
    7684:	fb 01       	movw	r30, r22
    7686:	dc 01       	movw	r26, r24
    7688:	e4 0f       	add	r30, r20
    768a:	f5 1f       	adc	r31, r21
    768c:	a4 0f       	add	r26, r20
    768e:	b5 1f       	adc	r27, r21
    7690:	02 c0       	rjmp	.+4      	; 0x7696 <memmove+0x18>
    7692:	02 90       	ld	r0, -Z
    7694:	0e 92       	st	-X, r0
    7696:	41 50       	subi	r20, 0x01	; 1
    7698:	50 40       	sbci	r21, 0x00	; 0
    769a:	d8 f7       	brcc	.-10     	; 0x7692 <memmove+0x14>
    769c:	08 95       	ret
    769e:	0c 94 d2 3d 	jmp	0x7ba4	; 0x7ba4 <memcpy>

000076a2 <strcat>:
    76a2:	fb 01       	movw	r30, r22
    76a4:	dc 01       	movw	r26, r24
    76a6:	0d 90       	ld	r0, X+
    76a8:	00 20       	and	r0, r0
    76aa:	e9 f7       	brne	.-6      	; 0x76a6 <strcat+0x4>
    76ac:	11 97       	sbiw	r26, 0x01	; 1
    76ae:	01 90       	ld	r0, Z+
    76b0:	0d 92       	st	X+, r0
    76b2:	00 20       	and	r0, r0
    76b4:	e1 f7       	brne	.-8      	; 0x76ae <strcat+0xc>
    76b6:	08 95       	ret

000076b8 <strncmp>:
    76b8:	fb 01       	movw	r30, r22
    76ba:	dc 01       	movw	r26, r24
    76bc:	41 50       	subi	r20, 0x01	; 1
    76be:	50 40       	sbci	r21, 0x00	; 0
    76c0:	30 f0       	brcs	.+12     	; 0x76ce <strncmp+0x16>
    76c2:	8d 91       	ld	r24, X+
    76c4:	01 90       	ld	r0, Z+
    76c6:	80 19       	sub	r24, r0
    76c8:	19 f4       	brne	.+6      	; 0x76d0 <strncmp+0x18>
    76ca:	00 20       	and	r0, r0
    76cc:	b9 f7       	brne	.-18     	; 0x76bc <strncmp+0x4>
    76ce:	88 1b       	sub	r24, r24
    76d0:	99 0b       	sbc	r25, r25
    76d2:	08 95       	ret

000076d4 <itoa>:
    76d4:	fb 01       	movw	r30, r22
    76d6:	9f 01       	movw	r18, r30
    76d8:	e8 94       	clt
    76da:	42 30       	cpi	r20, 0x02	; 2
    76dc:	c4 f0       	brlt	.+48     	; 0x770e <itoa+0x3a>
    76de:	45 32       	cpi	r20, 0x25	; 37
    76e0:	b4 f4       	brge	.+44     	; 0x770e <itoa+0x3a>
    76e2:	4a 30       	cpi	r20, 0x0A	; 10
    76e4:	29 f4       	brne	.+10     	; 0x76f0 <itoa+0x1c>
    76e6:	97 fb       	bst	r25, 7
    76e8:	1e f4       	brtc	.+6      	; 0x76f0 <itoa+0x1c>
    76ea:	90 95       	com	r25
    76ec:	81 95       	neg	r24
    76ee:	9f 4f       	sbci	r25, 0xFF	; 255
    76f0:	64 2f       	mov	r22, r20
    76f2:	77 27       	eor	r23, r23
    76f4:	0e 94 a3 3a 	call	0x7546	; 0x7546 <__udivmodhi4>
    76f8:	80 5d       	subi	r24, 0xD0	; 208
    76fa:	8a 33       	cpi	r24, 0x3A	; 58
    76fc:	0c f0       	brlt	.+2      	; 0x7700 <itoa+0x2c>
    76fe:	89 5d       	subi	r24, 0xD9	; 217
    7700:	81 93       	st	Z+, r24
    7702:	cb 01       	movw	r24, r22
    7704:	00 97       	sbiw	r24, 0x00	; 0
    7706:	a1 f7       	brne	.-24     	; 0x76f0 <itoa+0x1c>
    7708:	16 f4       	brtc	.+4      	; 0x770e <itoa+0x3a>
    770a:	5d e2       	ldi	r21, 0x2D	; 45
    770c:	51 93       	st	Z+, r21
    770e:	10 82       	st	Z, r1
    7710:	c9 01       	movw	r24, r18
    7712:	0c 94 e6 3d 	jmp	0x7bcc	; 0x7bcc <strrev>

00007716 <printf>:
    7716:	cf 93       	push	r28
    7718:	df 93       	push	r29
    771a:	cd b7       	in	r28, 0x3d	; 61
    771c:	de b7       	in	r29, 0x3e	; 62
    771e:	fe 01       	movw	r30, r28
    7720:	36 96       	adiw	r30, 0x06	; 6
    7722:	61 91       	ld	r22, Z+
    7724:	71 91       	ld	r23, Z+
    7726:	80 91 d9 50 	lds	r24, 0x50D9
    772a:	90 91 da 50 	lds	r25, 0x50DA
    772e:	af 01       	movw	r20, r30
    7730:	0e 94 c6 3b 	call	0x778c	; 0x778c <vfprintf>
    7734:	df 91       	pop	r29
    7736:	cf 91       	pop	r28
    7738:	08 95       	ret

0000773a <sprintf>:
    773a:	0f 93       	push	r16
    773c:	1f 93       	push	r17
    773e:	cf 93       	push	r28
    7740:	df 93       	push	r29
    7742:	cd b7       	in	r28, 0x3d	; 61
    7744:	de b7       	in	r29, 0x3e	; 62
    7746:	2e 97       	sbiw	r28, 0x0e	; 14
    7748:	cd bf       	out	0x3d, r28	; 61
    774a:	de bf       	out	0x3e, r29	; 62
    774c:	0e 89       	ldd	r16, Y+22	; 0x16
    774e:	1f 89       	ldd	r17, Y+23	; 0x17
    7750:	86 e0       	ldi	r24, 0x06	; 6
    7752:	8c 83       	std	Y+4, r24	; 0x04
    7754:	09 83       	std	Y+1, r16	; 0x01
    7756:	1a 83       	std	Y+2, r17	; 0x02
    7758:	8f ef       	ldi	r24, 0xFF	; 255
    775a:	9f e7       	ldi	r25, 0x7F	; 127
    775c:	8d 83       	std	Y+5, r24	; 0x05
    775e:	9e 83       	std	Y+6, r25	; 0x06
    7760:	ae 01       	movw	r20, r28
    7762:	46 5e       	subi	r20, 0xE6	; 230
    7764:	5f 4f       	sbci	r21, 0xFF	; 255
    7766:	ce 01       	movw	r24, r28
    7768:	01 96       	adiw	r24, 0x01	; 1
    776a:	68 8d       	ldd	r22, Y+24	; 0x18
    776c:	79 8d       	ldd	r23, Y+25	; 0x19
    776e:	0e 94 c6 3b 	call	0x778c	; 0x778c <vfprintf>
    7772:	ef 81       	ldd	r30, Y+7	; 0x07
    7774:	f8 85       	ldd	r31, Y+8	; 0x08
    7776:	e0 0f       	add	r30, r16
    7778:	f1 1f       	adc	r31, r17
    777a:	10 82       	st	Z, r1
    777c:	2e 96       	adiw	r28, 0x0e	; 14
    777e:	cd bf       	out	0x3d, r28	; 61
    7780:	de bf       	out	0x3e, r29	; 62
    7782:	df 91       	pop	r29
    7784:	cf 91       	pop	r28
    7786:	1f 91       	pop	r17
    7788:	0f 91       	pop	r16
    778a:	08 95       	ret

0000778c <vfprintf>:
    778c:	2f 92       	push	r2
    778e:	3f 92       	push	r3
    7790:	4f 92       	push	r4
    7792:	5f 92       	push	r5
    7794:	6f 92       	push	r6
    7796:	7f 92       	push	r7
    7798:	8f 92       	push	r8
    779a:	9f 92       	push	r9
    779c:	af 92       	push	r10
    779e:	bf 92       	push	r11
    77a0:	cf 92       	push	r12
    77a2:	df 92       	push	r13
    77a4:	ef 92       	push	r14
    77a6:	ff 92       	push	r15
    77a8:	0f 93       	push	r16
    77aa:	1f 93       	push	r17
    77ac:	cf 93       	push	r28
    77ae:	df 93       	push	r29
    77b0:	cd b7       	in	r28, 0x3d	; 61
    77b2:	de b7       	in	r29, 0x3e	; 62
    77b4:	2d 97       	sbiw	r28, 0x0d	; 13
    77b6:	cd bf       	out	0x3d, r28	; 61
    77b8:	de bf       	out	0x3e, r29	; 62
    77ba:	3c 01       	movw	r6, r24
    77bc:	6c 87       	std	Y+12, r22	; 0x0c
    77be:	7d 87       	std	Y+13, r23	; 0x0d
    77c0:	5a 01       	movw	r10, r20
    77c2:	fc 01       	movw	r30, r24
    77c4:	16 82       	std	Z+6, r1	; 0x06
    77c6:	17 82       	std	Z+7, r1	; 0x07
    77c8:	83 81       	ldd	r24, Z+3	; 0x03
    77ca:	81 ff       	sbrs	r24, 1
    77cc:	c8 c1       	rjmp	.+912    	; 0x7b5e <vfprintf+0x3d2>
    77ce:	2e 01       	movw	r4, r28
    77d0:	08 94       	sec
    77d2:	41 1c       	adc	r4, r1
    77d4:	51 1c       	adc	r5, r1
    77d6:	f3 01       	movw	r30, r6
    77d8:	93 81       	ldd	r25, Z+3	; 0x03
    77da:	ec 85       	ldd	r30, Y+12	; 0x0c
    77dc:	fd 85       	ldd	r31, Y+13	; 0x0d
    77de:	93 fd       	sbrc	r25, 3
    77e0:	85 91       	lpm	r24, Z+
    77e2:	93 ff       	sbrs	r25, 3
    77e4:	81 91       	ld	r24, Z+
    77e6:	ec 87       	std	Y+12, r30	; 0x0c
    77e8:	fd 87       	std	Y+13, r31	; 0x0d
    77ea:	88 23       	and	r24, r24
    77ec:	09 f4       	brne	.+2      	; 0x77f0 <vfprintf+0x64>
    77ee:	b3 c1       	rjmp	.+870    	; 0x7b56 <vfprintf+0x3ca>
    77f0:	85 32       	cpi	r24, 0x25	; 37
    77f2:	41 f4       	brne	.+16     	; 0x7804 <vfprintf+0x78>
    77f4:	93 fd       	sbrc	r25, 3
    77f6:	85 91       	lpm	r24, Z+
    77f8:	93 ff       	sbrs	r25, 3
    77fa:	81 91       	ld	r24, Z+
    77fc:	ec 87       	std	Y+12, r30	; 0x0c
    77fe:	fd 87       	std	Y+13, r31	; 0x0d
    7800:	85 32       	cpi	r24, 0x25	; 37
    7802:	29 f4       	brne	.+10     	; 0x780e <vfprintf+0x82>
    7804:	90 e0       	ldi	r25, 0x00	; 0
    7806:	b3 01       	movw	r22, r6
    7808:	0e 94 f6 3d 	call	0x7bec	; 0x7bec <fputc>
    780c:	e4 cf       	rjmp	.-56     	; 0x77d6 <vfprintf+0x4a>
    780e:	ff 24       	eor	r15, r15
    7810:	ee 24       	eor	r14, r14
    7812:	10 e0       	ldi	r17, 0x00	; 0
    7814:	10 32       	cpi	r17, 0x20	; 32
    7816:	b0 f4       	brcc	.+44     	; 0x7844 <vfprintf+0xb8>
    7818:	8b 32       	cpi	r24, 0x2B	; 43
    781a:	69 f0       	breq	.+26     	; 0x7836 <vfprintf+0xaa>
    781c:	8c 32       	cpi	r24, 0x2C	; 44
    781e:	28 f4       	brcc	.+10     	; 0x782a <vfprintf+0x9e>
    7820:	80 32       	cpi	r24, 0x20	; 32
    7822:	51 f0       	breq	.+20     	; 0x7838 <vfprintf+0xac>
    7824:	83 32       	cpi	r24, 0x23	; 35
    7826:	71 f4       	brne	.+28     	; 0x7844 <vfprintf+0xb8>
    7828:	0b c0       	rjmp	.+22     	; 0x7840 <vfprintf+0xb4>
    782a:	8d 32       	cpi	r24, 0x2D	; 45
    782c:	39 f0       	breq	.+14     	; 0x783c <vfprintf+0xb0>
    782e:	80 33       	cpi	r24, 0x30	; 48
    7830:	49 f4       	brne	.+18     	; 0x7844 <vfprintf+0xb8>
    7832:	11 60       	ori	r17, 0x01	; 1
    7834:	2c c0       	rjmp	.+88     	; 0x788e <vfprintf+0x102>
    7836:	12 60       	ori	r17, 0x02	; 2
    7838:	14 60       	ori	r17, 0x04	; 4
    783a:	29 c0       	rjmp	.+82     	; 0x788e <vfprintf+0x102>
    783c:	18 60       	ori	r17, 0x08	; 8
    783e:	27 c0       	rjmp	.+78     	; 0x788e <vfprintf+0x102>
    7840:	10 61       	ori	r17, 0x10	; 16
    7842:	25 c0       	rjmp	.+74     	; 0x788e <vfprintf+0x102>
    7844:	17 fd       	sbrc	r17, 7
    7846:	2e c0       	rjmp	.+92     	; 0x78a4 <vfprintf+0x118>
    7848:	28 2f       	mov	r18, r24
    784a:	20 53       	subi	r18, 0x30	; 48
    784c:	2a 30       	cpi	r18, 0x0A	; 10
    784e:	98 f4       	brcc	.+38     	; 0x7876 <vfprintf+0xea>
    7850:	16 ff       	sbrs	r17, 6
    7852:	08 c0       	rjmp	.+16     	; 0x7864 <vfprintf+0xd8>
    7854:	8f 2d       	mov	r24, r15
    7856:	88 0f       	add	r24, r24
    7858:	f8 2e       	mov	r15, r24
    785a:	ff 0c       	add	r15, r15
    785c:	ff 0c       	add	r15, r15
    785e:	f8 0e       	add	r15, r24
    7860:	f2 0e       	add	r15, r18
    7862:	15 c0       	rjmp	.+42     	; 0x788e <vfprintf+0x102>
    7864:	8e 2d       	mov	r24, r14
    7866:	88 0f       	add	r24, r24
    7868:	e8 2e       	mov	r14, r24
    786a:	ee 0c       	add	r14, r14
    786c:	ee 0c       	add	r14, r14
    786e:	e8 0e       	add	r14, r24
    7870:	e2 0e       	add	r14, r18
    7872:	10 62       	ori	r17, 0x20	; 32
    7874:	0c c0       	rjmp	.+24     	; 0x788e <vfprintf+0x102>
    7876:	8e 32       	cpi	r24, 0x2E	; 46
    7878:	21 f4       	brne	.+8      	; 0x7882 <vfprintf+0xf6>
    787a:	16 fd       	sbrc	r17, 6
    787c:	6c c1       	rjmp	.+728    	; 0x7b56 <vfprintf+0x3ca>
    787e:	10 64       	ori	r17, 0x40	; 64
    7880:	06 c0       	rjmp	.+12     	; 0x788e <vfprintf+0x102>
    7882:	8c 36       	cpi	r24, 0x6C	; 108
    7884:	11 f4       	brne	.+4      	; 0x788a <vfprintf+0xfe>
    7886:	10 68       	ori	r17, 0x80	; 128
    7888:	02 c0       	rjmp	.+4      	; 0x788e <vfprintf+0x102>
    788a:	88 36       	cpi	r24, 0x68	; 104
    788c:	59 f4       	brne	.+22     	; 0x78a4 <vfprintf+0x118>
    788e:	ec 85       	ldd	r30, Y+12	; 0x0c
    7890:	fd 85       	ldd	r31, Y+13	; 0x0d
    7892:	93 fd       	sbrc	r25, 3
    7894:	85 91       	lpm	r24, Z+
    7896:	93 ff       	sbrs	r25, 3
    7898:	81 91       	ld	r24, Z+
    789a:	ec 87       	std	Y+12, r30	; 0x0c
    789c:	fd 87       	std	Y+13, r31	; 0x0d
    789e:	88 23       	and	r24, r24
    78a0:	09 f0       	breq	.+2      	; 0x78a4 <vfprintf+0x118>
    78a2:	b8 cf       	rjmp	.-144    	; 0x7814 <vfprintf+0x88>
    78a4:	98 2f       	mov	r25, r24
    78a6:	95 54       	subi	r25, 0x45	; 69
    78a8:	93 30       	cpi	r25, 0x03	; 3
    78aa:	18 f0       	brcs	.+6      	; 0x78b2 <vfprintf+0x126>
    78ac:	90 52       	subi	r25, 0x20	; 32
    78ae:	93 30       	cpi	r25, 0x03	; 3
    78b0:	38 f4       	brcc	.+14     	; 0x78c0 <vfprintf+0x134>
    78b2:	24 e0       	ldi	r18, 0x04	; 4
    78b4:	30 e0       	ldi	r19, 0x00	; 0
    78b6:	a2 0e       	add	r10, r18
    78b8:	b3 1e       	adc	r11, r19
    78ba:	3f e3       	ldi	r19, 0x3F	; 63
    78bc:	39 83       	std	Y+1, r19	; 0x01
    78be:	0f c0       	rjmp	.+30     	; 0x78de <vfprintf+0x152>
    78c0:	83 36       	cpi	r24, 0x63	; 99
    78c2:	31 f0       	breq	.+12     	; 0x78d0 <vfprintf+0x144>
    78c4:	83 37       	cpi	r24, 0x73	; 115
    78c6:	81 f0       	breq	.+32     	; 0x78e8 <vfprintf+0x15c>
    78c8:	83 35       	cpi	r24, 0x53	; 83
    78ca:	09 f0       	breq	.+2      	; 0x78ce <vfprintf+0x142>
    78cc:	5a c0       	rjmp	.+180    	; 0x7982 <vfprintf+0x1f6>
    78ce:	22 c0       	rjmp	.+68     	; 0x7914 <vfprintf+0x188>
    78d0:	f5 01       	movw	r30, r10
    78d2:	80 81       	ld	r24, Z
    78d4:	89 83       	std	Y+1, r24	; 0x01
    78d6:	22 e0       	ldi	r18, 0x02	; 2
    78d8:	30 e0       	ldi	r19, 0x00	; 0
    78da:	a2 0e       	add	r10, r18
    78dc:	b3 1e       	adc	r11, r19
    78de:	21 e0       	ldi	r18, 0x01	; 1
    78e0:	c2 2e       	mov	r12, r18
    78e2:	d1 2c       	mov	r13, r1
    78e4:	42 01       	movw	r8, r4
    78e6:	14 c0       	rjmp	.+40     	; 0x7910 <vfprintf+0x184>
    78e8:	92 e0       	ldi	r25, 0x02	; 2
    78ea:	29 2e       	mov	r2, r25
    78ec:	31 2c       	mov	r3, r1
    78ee:	2a 0c       	add	r2, r10
    78f0:	3b 1c       	adc	r3, r11
    78f2:	f5 01       	movw	r30, r10
    78f4:	80 80       	ld	r8, Z
    78f6:	91 80       	ldd	r9, Z+1	; 0x01
    78f8:	16 ff       	sbrs	r17, 6
    78fa:	03 c0       	rjmp	.+6      	; 0x7902 <vfprintf+0x176>
    78fc:	6f 2d       	mov	r22, r15
    78fe:	70 e0       	ldi	r23, 0x00	; 0
    7900:	02 c0       	rjmp	.+4      	; 0x7906 <vfprintf+0x17a>
    7902:	6f ef       	ldi	r22, 0xFF	; 255
    7904:	7f ef       	ldi	r23, 0xFF	; 255
    7906:	c4 01       	movw	r24, r8
    7908:	0e 94 db 3d 	call	0x7bb6	; 0x7bb6 <strnlen>
    790c:	6c 01       	movw	r12, r24
    790e:	51 01       	movw	r10, r2
    7910:	1f 77       	andi	r17, 0x7F	; 127
    7912:	15 c0       	rjmp	.+42     	; 0x793e <vfprintf+0x1b2>
    7914:	82 e0       	ldi	r24, 0x02	; 2
    7916:	28 2e       	mov	r2, r24
    7918:	31 2c       	mov	r3, r1
    791a:	2a 0c       	add	r2, r10
    791c:	3b 1c       	adc	r3, r11
    791e:	f5 01       	movw	r30, r10
    7920:	80 80       	ld	r8, Z
    7922:	91 80       	ldd	r9, Z+1	; 0x01
    7924:	16 ff       	sbrs	r17, 6
    7926:	03 c0       	rjmp	.+6      	; 0x792e <vfprintf+0x1a2>
    7928:	6f 2d       	mov	r22, r15
    792a:	70 e0       	ldi	r23, 0x00	; 0
    792c:	02 c0       	rjmp	.+4      	; 0x7932 <vfprintf+0x1a6>
    792e:	6f ef       	ldi	r22, 0xFF	; 255
    7930:	7f ef       	ldi	r23, 0xFF	; 255
    7932:	c4 01       	movw	r24, r8
    7934:	0e 94 c7 3d 	call	0x7b8e	; 0x7b8e <strnlen_P>
    7938:	6c 01       	movw	r12, r24
    793a:	10 68       	ori	r17, 0x80	; 128
    793c:	51 01       	movw	r10, r2
    793e:	13 fd       	sbrc	r17, 3
    7940:	1c c0       	rjmp	.+56     	; 0x797a <vfprintf+0x1ee>
    7942:	06 c0       	rjmp	.+12     	; 0x7950 <vfprintf+0x1c4>
    7944:	80 e2       	ldi	r24, 0x20	; 32
    7946:	90 e0       	ldi	r25, 0x00	; 0
    7948:	b3 01       	movw	r22, r6
    794a:	0e 94 f6 3d 	call	0x7bec	; 0x7bec <fputc>
    794e:	ea 94       	dec	r14
    7950:	8e 2d       	mov	r24, r14
    7952:	90 e0       	ldi	r25, 0x00	; 0
    7954:	c8 16       	cp	r12, r24
    7956:	d9 06       	cpc	r13, r25
    7958:	a8 f3       	brcs	.-22     	; 0x7944 <vfprintf+0x1b8>
    795a:	0f c0       	rjmp	.+30     	; 0x797a <vfprintf+0x1ee>
    795c:	f4 01       	movw	r30, r8
    795e:	17 fd       	sbrc	r17, 7
    7960:	85 91       	lpm	r24, Z+
    7962:	17 ff       	sbrs	r17, 7
    7964:	81 91       	ld	r24, Z+
    7966:	4f 01       	movw	r8, r30
    7968:	90 e0       	ldi	r25, 0x00	; 0
    796a:	b3 01       	movw	r22, r6
    796c:	0e 94 f6 3d 	call	0x7bec	; 0x7bec <fputc>
    7970:	e1 10       	cpse	r14, r1
    7972:	ea 94       	dec	r14
    7974:	08 94       	sec
    7976:	c1 08       	sbc	r12, r1
    7978:	d1 08       	sbc	r13, r1
    797a:	c1 14       	cp	r12, r1
    797c:	d1 04       	cpc	r13, r1
    797e:	71 f7       	brne	.-36     	; 0x795c <vfprintf+0x1d0>
    7980:	e7 c0       	rjmp	.+462    	; 0x7b50 <vfprintf+0x3c4>
    7982:	84 36       	cpi	r24, 0x64	; 100
    7984:	11 f0       	breq	.+4      	; 0x798a <vfprintf+0x1fe>
    7986:	89 36       	cpi	r24, 0x69	; 105
    7988:	51 f5       	brne	.+84     	; 0x79de <vfprintf+0x252>
    798a:	f5 01       	movw	r30, r10
    798c:	17 ff       	sbrs	r17, 7
    798e:	07 c0       	rjmp	.+14     	; 0x799e <vfprintf+0x212>
    7990:	80 81       	ld	r24, Z
    7992:	91 81       	ldd	r25, Z+1	; 0x01
    7994:	a2 81       	ldd	r26, Z+2	; 0x02
    7996:	b3 81       	ldd	r27, Z+3	; 0x03
    7998:	24 e0       	ldi	r18, 0x04	; 4
    799a:	30 e0       	ldi	r19, 0x00	; 0
    799c:	08 c0       	rjmp	.+16     	; 0x79ae <vfprintf+0x222>
    799e:	80 81       	ld	r24, Z
    79a0:	91 81       	ldd	r25, Z+1	; 0x01
    79a2:	aa 27       	eor	r26, r26
    79a4:	97 fd       	sbrc	r25, 7
    79a6:	a0 95       	com	r26
    79a8:	ba 2f       	mov	r27, r26
    79aa:	22 e0       	ldi	r18, 0x02	; 2
    79ac:	30 e0       	ldi	r19, 0x00	; 0
    79ae:	a2 0e       	add	r10, r18
    79b0:	b3 1e       	adc	r11, r19
    79b2:	01 2f       	mov	r16, r17
    79b4:	0f 76       	andi	r16, 0x6F	; 111
    79b6:	b7 ff       	sbrs	r27, 7
    79b8:	08 c0       	rjmp	.+16     	; 0x79ca <vfprintf+0x23e>
    79ba:	b0 95       	com	r27
    79bc:	a0 95       	com	r26
    79be:	90 95       	com	r25
    79c0:	81 95       	neg	r24
    79c2:	9f 4f       	sbci	r25, 0xFF	; 255
    79c4:	af 4f       	sbci	r26, 0xFF	; 255
    79c6:	bf 4f       	sbci	r27, 0xFF	; 255
    79c8:	00 68       	ori	r16, 0x80	; 128
    79ca:	bc 01       	movw	r22, r24
    79cc:	cd 01       	movw	r24, r26
    79ce:	a2 01       	movw	r20, r4
    79d0:	2a e0       	ldi	r18, 0x0A	; 10
    79d2:	30 e0       	ldi	r19, 0x00	; 0
    79d4:	0e 94 22 3e 	call	0x7c44	; 0x7c44 <__ultoa_invert>
    79d8:	d8 2e       	mov	r13, r24
    79da:	d4 18       	sub	r13, r4
    79dc:	3f c0       	rjmp	.+126    	; 0x7a5c <vfprintf+0x2d0>
    79de:	85 37       	cpi	r24, 0x75	; 117
    79e0:	21 f4       	brne	.+8      	; 0x79ea <vfprintf+0x25e>
    79e2:	1f 7e       	andi	r17, 0xEF	; 239
    79e4:	2a e0       	ldi	r18, 0x0A	; 10
    79e6:	30 e0       	ldi	r19, 0x00	; 0
    79e8:	20 c0       	rjmp	.+64     	; 0x7a2a <vfprintf+0x29e>
    79ea:	19 7f       	andi	r17, 0xF9	; 249
    79ec:	8f 36       	cpi	r24, 0x6F	; 111
    79ee:	a9 f0       	breq	.+42     	; 0x7a1a <vfprintf+0x28e>
    79f0:	80 37       	cpi	r24, 0x70	; 112
    79f2:	20 f4       	brcc	.+8      	; 0x79fc <vfprintf+0x270>
    79f4:	88 35       	cpi	r24, 0x58	; 88
    79f6:	09 f0       	breq	.+2      	; 0x79fa <vfprintf+0x26e>
    79f8:	ae c0       	rjmp	.+348    	; 0x7b56 <vfprintf+0x3ca>
    79fa:	0b c0       	rjmp	.+22     	; 0x7a12 <vfprintf+0x286>
    79fc:	80 37       	cpi	r24, 0x70	; 112
    79fe:	21 f0       	breq	.+8      	; 0x7a08 <vfprintf+0x27c>
    7a00:	88 37       	cpi	r24, 0x78	; 120
    7a02:	09 f0       	breq	.+2      	; 0x7a06 <vfprintf+0x27a>
    7a04:	a8 c0       	rjmp	.+336    	; 0x7b56 <vfprintf+0x3ca>
    7a06:	01 c0       	rjmp	.+2      	; 0x7a0a <vfprintf+0x27e>
    7a08:	10 61       	ori	r17, 0x10	; 16
    7a0a:	14 ff       	sbrs	r17, 4
    7a0c:	09 c0       	rjmp	.+18     	; 0x7a20 <vfprintf+0x294>
    7a0e:	14 60       	ori	r17, 0x04	; 4
    7a10:	07 c0       	rjmp	.+14     	; 0x7a20 <vfprintf+0x294>
    7a12:	14 ff       	sbrs	r17, 4
    7a14:	08 c0       	rjmp	.+16     	; 0x7a26 <vfprintf+0x29a>
    7a16:	16 60       	ori	r17, 0x06	; 6
    7a18:	06 c0       	rjmp	.+12     	; 0x7a26 <vfprintf+0x29a>
    7a1a:	28 e0       	ldi	r18, 0x08	; 8
    7a1c:	30 e0       	ldi	r19, 0x00	; 0
    7a1e:	05 c0       	rjmp	.+10     	; 0x7a2a <vfprintf+0x29e>
    7a20:	20 e1       	ldi	r18, 0x10	; 16
    7a22:	30 e0       	ldi	r19, 0x00	; 0
    7a24:	02 c0       	rjmp	.+4      	; 0x7a2a <vfprintf+0x29e>
    7a26:	20 e1       	ldi	r18, 0x10	; 16
    7a28:	32 e0       	ldi	r19, 0x02	; 2
    7a2a:	f5 01       	movw	r30, r10
    7a2c:	17 ff       	sbrs	r17, 7
    7a2e:	07 c0       	rjmp	.+14     	; 0x7a3e <vfprintf+0x2b2>
    7a30:	60 81       	ld	r22, Z
    7a32:	71 81       	ldd	r23, Z+1	; 0x01
    7a34:	82 81       	ldd	r24, Z+2	; 0x02
    7a36:	93 81       	ldd	r25, Z+3	; 0x03
    7a38:	44 e0       	ldi	r20, 0x04	; 4
    7a3a:	50 e0       	ldi	r21, 0x00	; 0
    7a3c:	06 c0       	rjmp	.+12     	; 0x7a4a <vfprintf+0x2be>
    7a3e:	60 81       	ld	r22, Z
    7a40:	71 81       	ldd	r23, Z+1	; 0x01
    7a42:	80 e0       	ldi	r24, 0x00	; 0
    7a44:	90 e0       	ldi	r25, 0x00	; 0
    7a46:	42 e0       	ldi	r20, 0x02	; 2
    7a48:	50 e0       	ldi	r21, 0x00	; 0
    7a4a:	a4 0e       	add	r10, r20
    7a4c:	b5 1e       	adc	r11, r21
    7a4e:	a2 01       	movw	r20, r4
    7a50:	0e 94 22 3e 	call	0x7c44	; 0x7c44 <__ultoa_invert>
    7a54:	d8 2e       	mov	r13, r24
    7a56:	d4 18       	sub	r13, r4
    7a58:	01 2f       	mov	r16, r17
    7a5a:	0f 77       	andi	r16, 0x7F	; 127
    7a5c:	06 ff       	sbrs	r16, 6
    7a5e:	09 c0       	rjmp	.+18     	; 0x7a72 <vfprintf+0x2e6>
    7a60:	0e 7f       	andi	r16, 0xFE	; 254
    7a62:	df 14       	cp	r13, r15
    7a64:	30 f4       	brcc	.+12     	; 0x7a72 <vfprintf+0x2e6>
    7a66:	04 ff       	sbrs	r16, 4
    7a68:	06 c0       	rjmp	.+12     	; 0x7a76 <vfprintf+0x2ea>
    7a6a:	02 fd       	sbrc	r16, 2
    7a6c:	04 c0       	rjmp	.+8      	; 0x7a76 <vfprintf+0x2ea>
    7a6e:	0f 7e       	andi	r16, 0xEF	; 239
    7a70:	02 c0       	rjmp	.+4      	; 0x7a76 <vfprintf+0x2ea>
    7a72:	1d 2d       	mov	r17, r13
    7a74:	01 c0       	rjmp	.+2      	; 0x7a78 <vfprintf+0x2ec>
    7a76:	1f 2d       	mov	r17, r15
    7a78:	80 2f       	mov	r24, r16
    7a7a:	90 e0       	ldi	r25, 0x00	; 0
    7a7c:	04 ff       	sbrs	r16, 4
    7a7e:	0c c0       	rjmp	.+24     	; 0x7a98 <vfprintf+0x30c>
    7a80:	fe 01       	movw	r30, r28
    7a82:	ed 0d       	add	r30, r13
    7a84:	f1 1d       	adc	r31, r1
    7a86:	20 81       	ld	r18, Z
    7a88:	20 33       	cpi	r18, 0x30	; 48
    7a8a:	11 f4       	brne	.+4      	; 0x7a90 <vfprintf+0x304>
    7a8c:	09 7e       	andi	r16, 0xE9	; 233
    7a8e:	09 c0       	rjmp	.+18     	; 0x7aa2 <vfprintf+0x316>
    7a90:	02 ff       	sbrs	r16, 2
    7a92:	06 c0       	rjmp	.+12     	; 0x7aa0 <vfprintf+0x314>
    7a94:	1e 5f       	subi	r17, 0xFE	; 254
    7a96:	05 c0       	rjmp	.+10     	; 0x7aa2 <vfprintf+0x316>
    7a98:	86 78       	andi	r24, 0x86	; 134
    7a9a:	90 70       	andi	r25, 0x00	; 0
    7a9c:	00 97       	sbiw	r24, 0x00	; 0
    7a9e:	09 f0       	breq	.+2      	; 0x7aa2 <vfprintf+0x316>
    7aa0:	1f 5f       	subi	r17, 0xFF	; 255
    7aa2:	80 2e       	mov	r8, r16
    7aa4:	99 24       	eor	r9, r9
    7aa6:	03 fd       	sbrc	r16, 3
    7aa8:	12 c0       	rjmp	.+36     	; 0x7ace <vfprintf+0x342>
    7aaa:	00 ff       	sbrs	r16, 0
    7aac:	0d c0       	rjmp	.+26     	; 0x7ac8 <vfprintf+0x33c>
    7aae:	fd 2c       	mov	r15, r13
    7ab0:	1e 15       	cp	r17, r14
    7ab2:	50 f4       	brcc	.+20     	; 0x7ac8 <vfprintf+0x33c>
    7ab4:	fe 0c       	add	r15, r14
    7ab6:	f1 1a       	sub	r15, r17
    7ab8:	1e 2d       	mov	r17, r14
    7aba:	06 c0       	rjmp	.+12     	; 0x7ac8 <vfprintf+0x33c>
    7abc:	80 e2       	ldi	r24, 0x20	; 32
    7abe:	90 e0       	ldi	r25, 0x00	; 0
    7ac0:	b3 01       	movw	r22, r6
    7ac2:	0e 94 f6 3d 	call	0x7bec	; 0x7bec <fputc>
    7ac6:	1f 5f       	subi	r17, 0xFF	; 255
    7ac8:	1e 15       	cp	r17, r14
    7aca:	c0 f3       	brcs	.-16     	; 0x7abc <vfprintf+0x330>
    7acc:	04 c0       	rjmp	.+8      	; 0x7ad6 <vfprintf+0x34a>
    7ace:	1e 15       	cp	r17, r14
    7ad0:	10 f4       	brcc	.+4      	; 0x7ad6 <vfprintf+0x34a>
    7ad2:	e1 1a       	sub	r14, r17
    7ad4:	01 c0       	rjmp	.+2      	; 0x7ad8 <vfprintf+0x34c>
    7ad6:	ee 24       	eor	r14, r14
    7ad8:	84 fe       	sbrs	r8, 4
    7ada:	0f c0       	rjmp	.+30     	; 0x7afa <vfprintf+0x36e>
    7adc:	80 e3       	ldi	r24, 0x30	; 48
    7ade:	90 e0       	ldi	r25, 0x00	; 0
    7ae0:	b3 01       	movw	r22, r6
    7ae2:	0e 94 f6 3d 	call	0x7bec	; 0x7bec <fputc>
    7ae6:	82 fe       	sbrs	r8, 2
    7ae8:	1f c0       	rjmp	.+62     	; 0x7b28 <vfprintf+0x39c>
    7aea:	81 fe       	sbrs	r8, 1
    7aec:	03 c0       	rjmp	.+6      	; 0x7af4 <vfprintf+0x368>
    7aee:	88 e5       	ldi	r24, 0x58	; 88
    7af0:	90 e0       	ldi	r25, 0x00	; 0
    7af2:	10 c0       	rjmp	.+32     	; 0x7b14 <vfprintf+0x388>
    7af4:	88 e7       	ldi	r24, 0x78	; 120
    7af6:	90 e0       	ldi	r25, 0x00	; 0
    7af8:	0d c0       	rjmp	.+26     	; 0x7b14 <vfprintf+0x388>
    7afa:	c4 01       	movw	r24, r8
    7afc:	86 78       	andi	r24, 0x86	; 134
    7afe:	90 70       	andi	r25, 0x00	; 0
    7b00:	00 97       	sbiw	r24, 0x00	; 0
    7b02:	91 f0       	breq	.+36     	; 0x7b28 <vfprintf+0x39c>
    7b04:	81 fc       	sbrc	r8, 1
    7b06:	02 c0       	rjmp	.+4      	; 0x7b0c <vfprintf+0x380>
    7b08:	80 e2       	ldi	r24, 0x20	; 32
    7b0a:	01 c0       	rjmp	.+2      	; 0x7b0e <vfprintf+0x382>
    7b0c:	8b e2       	ldi	r24, 0x2B	; 43
    7b0e:	07 fd       	sbrc	r16, 7
    7b10:	8d e2       	ldi	r24, 0x2D	; 45
    7b12:	90 e0       	ldi	r25, 0x00	; 0
    7b14:	b3 01       	movw	r22, r6
    7b16:	0e 94 f6 3d 	call	0x7bec	; 0x7bec <fputc>
    7b1a:	06 c0       	rjmp	.+12     	; 0x7b28 <vfprintf+0x39c>
    7b1c:	80 e3       	ldi	r24, 0x30	; 48
    7b1e:	90 e0       	ldi	r25, 0x00	; 0
    7b20:	b3 01       	movw	r22, r6
    7b22:	0e 94 f6 3d 	call	0x7bec	; 0x7bec <fputc>
    7b26:	fa 94       	dec	r15
    7b28:	df 14       	cp	r13, r15
    7b2a:	c0 f3       	brcs	.-16     	; 0x7b1c <vfprintf+0x390>
    7b2c:	da 94       	dec	r13
    7b2e:	f2 01       	movw	r30, r4
    7b30:	ed 0d       	add	r30, r13
    7b32:	f1 1d       	adc	r31, r1
    7b34:	80 81       	ld	r24, Z
    7b36:	90 e0       	ldi	r25, 0x00	; 0
    7b38:	b3 01       	movw	r22, r6
    7b3a:	0e 94 f6 3d 	call	0x7bec	; 0x7bec <fputc>
    7b3e:	dd 20       	and	r13, r13
    7b40:	a9 f7       	brne	.-22     	; 0x7b2c <vfprintf+0x3a0>
    7b42:	06 c0       	rjmp	.+12     	; 0x7b50 <vfprintf+0x3c4>
    7b44:	80 e2       	ldi	r24, 0x20	; 32
    7b46:	90 e0       	ldi	r25, 0x00	; 0
    7b48:	b3 01       	movw	r22, r6
    7b4a:	0e 94 f6 3d 	call	0x7bec	; 0x7bec <fputc>
    7b4e:	ea 94       	dec	r14
    7b50:	ee 20       	and	r14, r14
    7b52:	c1 f7       	brne	.-16     	; 0x7b44 <vfprintf+0x3b8>
    7b54:	40 ce       	rjmp	.-896    	; 0x77d6 <vfprintf+0x4a>
    7b56:	f3 01       	movw	r30, r6
    7b58:	86 81       	ldd	r24, Z+6	; 0x06
    7b5a:	97 81       	ldd	r25, Z+7	; 0x07
    7b5c:	02 c0       	rjmp	.+4      	; 0x7b62 <vfprintf+0x3d6>
    7b5e:	8f ef       	ldi	r24, 0xFF	; 255
    7b60:	9f ef       	ldi	r25, 0xFF	; 255
    7b62:	2d 96       	adiw	r28, 0x0d	; 13
    7b64:	cd bf       	out	0x3d, r28	; 61
    7b66:	de bf       	out	0x3e, r29	; 62
    7b68:	df 91       	pop	r29
    7b6a:	cf 91       	pop	r28
    7b6c:	1f 91       	pop	r17
    7b6e:	0f 91       	pop	r16
    7b70:	ff 90       	pop	r15
    7b72:	ef 90       	pop	r14
    7b74:	df 90       	pop	r13
    7b76:	cf 90       	pop	r12
    7b78:	bf 90       	pop	r11
    7b7a:	af 90       	pop	r10
    7b7c:	9f 90       	pop	r9
    7b7e:	8f 90       	pop	r8
    7b80:	7f 90       	pop	r7
    7b82:	6f 90       	pop	r6
    7b84:	5f 90       	pop	r5
    7b86:	4f 90       	pop	r4
    7b88:	3f 90       	pop	r3
    7b8a:	2f 90       	pop	r2
    7b8c:	08 95       	ret

00007b8e <strnlen_P>:
    7b8e:	fc 01       	movw	r30, r24
    7b90:	05 90       	lpm	r0, Z+
    7b92:	61 50       	subi	r22, 0x01	; 1
    7b94:	70 40       	sbci	r23, 0x00	; 0
    7b96:	01 10       	cpse	r0, r1
    7b98:	d8 f7       	brcc	.-10     	; 0x7b90 <strnlen_P+0x2>
    7b9a:	80 95       	com	r24
    7b9c:	90 95       	com	r25
    7b9e:	8e 0f       	add	r24, r30
    7ba0:	9f 1f       	adc	r25, r31
    7ba2:	08 95       	ret

00007ba4 <memcpy>:
    7ba4:	fb 01       	movw	r30, r22
    7ba6:	dc 01       	movw	r26, r24
    7ba8:	02 c0       	rjmp	.+4      	; 0x7bae <memcpy+0xa>
    7baa:	01 90       	ld	r0, Z+
    7bac:	0d 92       	st	X+, r0
    7bae:	41 50       	subi	r20, 0x01	; 1
    7bb0:	50 40       	sbci	r21, 0x00	; 0
    7bb2:	d8 f7       	brcc	.-10     	; 0x7baa <memcpy+0x6>
    7bb4:	08 95       	ret

00007bb6 <strnlen>:
    7bb6:	fc 01       	movw	r30, r24
    7bb8:	61 50       	subi	r22, 0x01	; 1
    7bba:	70 40       	sbci	r23, 0x00	; 0
    7bbc:	01 90       	ld	r0, Z+
    7bbe:	01 10       	cpse	r0, r1
    7bc0:	d8 f7       	brcc	.-10     	; 0x7bb8 <strnlen+0x2>
    7bc2:	80 95       	com	r24
    7bc4:	90 95       	com	r25
    7bc6:	8e 0f       	add	r24, r30
    7bc8:	9f 1f       	adc	r25, r31
    7bca:	08 95       	ret

00007bcc <strrev>:
    7bcc:	dc 01       	movw	r26, r24
    7bce:	fc 01       	movw	r30, r24
    7bd0:	67 2f       	mov	r22, r23
    7bd2:	71 91       	ld	r23, Z+
    7bd4:	77 23       	and	r23, r23
    7bd6:	e1 f7       	brne	.-8      	; 0x7bd0 <strrev+0x4>
    7bd8:	32 97       	sbiw	r30, 0x02	; 2
    7bda:	04 c0       	rjmp	.+8      	; 0x7be4 <strrev+0x18>
    7bdc:	7c 91       	ld	r23, X
    7bde:	6d 93       	st	X+, r22
    7be0:	70 83       	st	Z, r23
    7be2:	62 91       	ld	r22, -Z
    7be4:	ae 17       	cp	r26, r30
    7be6:	bf 07       	cpc	r27, r31
    7be8:	c8 f3       	brcs	.-14     	; 0x7bdc <strrev+0x10>
    7bea:	08 95       	ret

00007bec <fputc>:
    7bec:	0f 93       	push	r16
    7bee:	1f 93       	push	r17
    7bf0:	cf 93       	push	r28
    7bf2:	df 93       	push	r29
    7bf4:	8c 01       	movw	r16, r24
    7bf6:	eb 01       	movw	r28, r22
    7bf8:	8b 81       	ldd	r24, Y+3	; 0x03
    7bfa:	81 ff       	sbrs	r24, 1
    7bfc:	1b c0       	rjmp	.+54     	; 0x7c34 <fputc+0x48>
    7bfe:	82 ff       	sbrs	r24, 2
    7c00:	0d c0       	rjmp	.+26     	; 0x7c1c <fputc+0x30>
    7c02:	2e 81       	ldd	r18, Y+6	; 0x06
    7c04:	3f 81       	ldd	r19, Y+7	; 0x07
    7c06:	8c 81       	ldd	r24, Y+4	; 0x04
    7c08:	9d 81       	ldd	r25, Y+5	; 0x05
    7c0a:	28 17       	cp	r18, r24
    7c0c:	39 07       	cpc	r19, r25
    7c0e:	64 f4       	brge	.+24     	; 0x7c28 <fputc+0x3c>
    7c10:	e8 81       	ld	r30, Y
    7c12:	f9 81       	ldd	r31, Y+1	; 0x01
    7c14:	01 93       	st	Z+, r16
    7c16:	e8 83       	st	Y, r30
    7c18:	f9 83       	std	Y+1, r31	; 0x01
    7c1a:	06 c0       	rjmp	.+12     	; 0x7c28 <fputc+0x3c>
    7c1c:	e8 85       	ldd	r30, Y+8	; 0x08
    7c1e:	f9 85       	ldd	r31, Y+9	; 0x09
    7c20:	80 2f       	mov	r24, r16
    7c22:	19 95       	eicall
    7c24:	00 97       	sbiw	r24, 0x00	; 0
    7c26:	31 f4       	brne	.+12     	; 0x7c34 <fputc+0x48>
    7c28:	8e 81       	ldd	r24, Y+6	; 0x06
    7c2a:	9f 81       	ldd	r25, Y+7	; 0x07
    7c2c:	01 96       	adiw	r24, 0x01	; 1
    7c2e:	8e 83       	std	Y+6, r24	; 0x06
    7c30:	9f 83       	std	Y+7, r25	; 0x07
    7c32:	02 c0       	rjmp	.+4      	; 0x7c38 <fputc+0x4c>
    7c34:	0f ef       	ldi	r16, 0xFF	; 255
    7c36:	1f ef       	ldi	r17, 0xFF	; 255
    7c38:	c8 01       	movw	r24, r16
    7c3a:	df 91       	pop	r29
    7c3c:	cf 91       	pop	r28
    7c3e:	1f 91       	pop	r17
    7c40:	0f 91       	pop	r16
    7c42:	08 95       	ret

00007c44 <__ultoa_invert>:
    7c44:	fa 01       	movw	r30, r20
    7c46:	aa 27       	eor	r26, r26
    7c48:	28 30       	cpi	r18, 0x08	; 8
    7c4a:	51 f1       	breq	.+84     	; 0x7ca0 <__ultoa_invert+0x5c>
    7c4c:	20 31       	cpi	r18, 0x10	; 16
    7c4e:	81 f1       	breq	.+96     	; 0x7cb0 <__ultoa_invert+0x6c>
    7c50:	e8 94       	clt
    7c52:	6f 93       	push	r22
    7c54:	6e 7f       	andi	r22, 0xFE	; 254
    7c56:	6e 5f       	subi	r22, 0xFE	; 254
    7c58:	7f 4f       	sbci	r23, 0xFF	; 255
    7c5a:	8f 4f       	sbci	r24, 0xFF	; 255
    7c5c:	9f 4f       	sbci	r25, 0xFF	; 255
    7c5e:	af 4f       	sbci	r26, 0xFF	; 255
    7c60:	b1 e0       	ldi	r27, 0x01	; 1
    7c62:	3e d0       	rcall	.+124    	; 0x7ce0 <__ultoa_invert+0x9c>
    7c64:	b4 e0       	ldi	r27, 0x04	; 4
    7c66:	3c d0       	rcall	.+120    	; 0x7ce0 <__ultoa_invert+0x9c>
    7c68:	67 0f       	add	r22, r23
    7c6a:	78 1f       	adc	r23, r24
    7c6c:	89 1f       	adc	r24, r25
    7c6e:	9a 1f       	adc	r25, r26
    7c70:	a1 1d       	adc	r26, r1
    7c72:	68 0f       	add	r22, r24
    7c74:	79 1f       	adc	r23, r25
    7c76:	8a 1f       	adc	r24, r26
    7c78:	91 1d       	adc	r25, r1
    7c7a:	a1 1d       	adc	r26, r1
    7c7c:	6a 0f       	add	r22, r26
    7c7e:	71 1d       	adc	r23, r1
    7c80:	81 1d       	adc	r24, r1
    7c82:	91 1d       	adc	r25, r1
    7c84:	a1 1d       	adc	r26, r1
    7c86:	20 d0       	rcall	.+64     	; 0x7cc8 <__ultoa_invert+0x84>
    7c88:	09 f4       	brne	.+2      	; 0x7c8c <__ultoa_invert+0x48>
    7c8a:	68 94       	set
    7c8c:	3f 91       	pop	r19
    7c8e:	2a e0       	ldi	r18, 0x0A	; 10
    7c90:	26 9f       	mul	r18, r22
    7c92:	11 24       	eor	r1, r1
    7c94:	30 19       	sub	r19, r0
    7c96:	30 5d       	subi	r19, 0xD0	; 208
    7c98:	31 93       	st	Z+, r19
    7c9a:	de f6       	brtc	.-74     	; 0x7c52 <__ultoa_invert+0xe>
    7c9c:	cf 01       	movw	r24, r30
    7c9e:	08 95       	ret
    7ca0:	46 2f       	mov	r20, r22
    7ca2:	47 70       	andi	r20, 0x07	; 7
    7ca4:	40 5d       	subi	r20, 0xD0	; 208
    7ca6:	41 93       	st	Z+, r20
    7ca8:	b3 e0       	ldi	r27, 0x03	; 3
    7caa:	0f d0       	rcall	.+30     	; 0x7cca <__ultoa_invert+0x86>
    7cac:	c9 f7       	brne	.-14     	; 0x7ca0 <__ultoa_invert+0x5c>
    7cae:	f6 cf       	rjmp	.-20     	; 0x7c9c <__ultoa_invert+0x58>
    7cb0:	46 2f       	mov	r20, r22
    7cb2:	4f 70       	andi	r20, 0x0F	; 15
    7cb4:	40 5d       	subi	r20, 0xD0	; 208
    7cb6:	4a 33       	cpi	r20, 0x3A	; 58
    7cb8:	18 f0       	brcs	.+6      	; 0x7cc0 <__ultoa_invert+0x7c>
    7cba:	49 5d       	subi	r20, 0xD9	; 217
    7cbc:	31 fd       	sbrc	r19, 1
    7cbe:	40 52       	subi	r20, 0x20	; 32
    7cc0:	41 93       	st	Z+, r20
    7cc2:	02 d0       	rcall	.+4      	; 0x7cc8 <__ultoa_invert+0x84>
    7cc4:	a9 f7       	brne	.-22     	; 0x7cb0 <__ultoa_invert+0x6c>
    7cc6:	ea cf       	rjmp	.-44     	; 0x7c9c <__ultoa_invert+0x58>
    7cc8:	b4 e0       	ldi	r27, 0x04	; 4
    7cca:	a6 95       	lsr	r26
    7ccc:	97 95       	ror	r25
    7cce:	87 95       	ror	r24
    7cd0:	77 95       	ror	r23
    7cd2:	67 95       	ror	r22
    7cd4:	ba 95       	dec	r27
    7cd6:	c9 f7       	brne	.-14     	; 0x7cca <__ultoa_invert+0x86>
    7cd8:	00 97       	sbiw	r24, 0x00	; 0
    7cda:	61 05       	cpc	r22, r1
    7cdc:	71 05       	cpc	r23, r1
    7cde:	08 95       	ret
    7ce0:	9b 01       	movw	r18, r22
    7ce2:	ac 01       	movw	r20, r24
    7ce4:	0a 2e       	mov	r0, r26
    7ce6:	06 94       	lsr	r0
    7ce8:	57 95       	ror	r21
    7cea:	47 95       	ror	r20
    7cec:	37 95       	ror	r19
    7cee:	27 95       	ror	r18
    7cf0:	ba 95       	dec	r27
    7cf2:	c9 f7       	brne	.-14     	; 0x7ce6 <__ultoa_invert+0xa2>
    7cf4:	62 0f       	add	r22, r18
    7cf6:	73 1f       	adc	r23, r19
    7cf8:	84 1f       	adc	r24, r20
    7cfa:	95 1f       	adc	r25, r21
    7cfc:	a0 1d       	adc	r26, r0
    7cfe:	08 95       	ret

00007d00 <_exit>:
    7d00:	f8 94       	cli

00007d02 <__stop_program>:
    7d02:	ff cf       	rjmp	.-2      	; 0x7d02 <__stop_program>
