
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007a2a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000010e  00802000  00007a2a  00007abe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fa9  0080210e  0080210e  00007bcc  2**0
                  ALLOC
  3 .stab         000028f8  00000000  00000000  00007bcc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009ca  00000000  00000000  0000a4c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000420  00000000  00000000  0000ae90  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000bc35  00000000  00000000  0000b2b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000026fc  00000000  00000000  00016ee5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000058d5  00000000  00000000  000195e1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001bcc  00000000  00000000  0001eeb8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004661  00000000  00000000  00020a84  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008320  00000000  00000000  000250e5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0017fd97  00000000  00000000  0002d405  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000001c0  00000000  00000000  001ad19c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 49 0e 	jmp	0x1c92	; 0x1c92 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 7c 13 	jmp	0x26f8	; 0x26f8 <__vector_16>
      44:	0c 94 54 13 	jmp	0x26a8	; 0x26a8 <__vector_17>
      48:	0c 94 2c 13 	jmp	0x2658	; 0x2658 <__vector_18>
      4c:	0c 94 e6 12 	jmp	0x25cc	; 0x25cc <__vector_19>
      50:	0c 94 66 0c 	jmp	0x18cc	; 0x18cc <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 32 1e 	jmp	0x3c64	; 0x3c64 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 28 10 	jmp	0x2050	; 0x2050 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 be 12 	jmp	0x257c	; 0x257c <__vector_79>
     140:	0c 94 96 12 	jmp	0x252c	; 0x252c <__vector_80>
     144:	0c 94 6e 12 	jmp	0x24dc	; 0x24dc <__vector_81>
     148:	0c 94 44 12 	jmp	0x2488	; 0x2488 <__vector_82>
     14c:	0c 94 6b 09 	jmp	0x12d6	; 0x12d6 <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 f8 0c 	jmp	0x19f0	; 0x19f0 <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	ea e2       	ldi	r30, 0x2A	; 42
     244:	fa e7       	ldi	r31, 0x7A	; 122
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	ae 30       	cpi	r26, 0x0E	; 14
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	ae e0       	ldi	r26, 0x0E	; 14
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a7 3b       	cpi	r26, 0xB7	; 183
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 db 06 	call	0xdb6	; 0xdb6 <main>
     26a:	0c 94 13 3d 	jmp	0x7a26	; 0x7a26 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <writeFRAM>:
 * Created: 3/8/2014 11:40:36 AM
 *  Author: VLAD
 */ 
#include "FRAM.h"

void writeFRAM(uint8_t* buffer, uint16_t length) {
     272:	af 92       	push	r10
     274:	bf 92       	push	r11
     276:	df 92       	push	r13
     278:	ef 92       	push	r14
     27a:	ff 92       	push	r15
     27c:	0f 93       	push	r16
     27e:	1f 93       	push	r17
     280:	cf 93       	push	r28
     282:	df 93       	push	r29
     284:	e8 2e       	mov	r14, r24
     286:	d9 2e       	mov	r13, r25
     288:	8b 01       	movw	r16, r22
	
	uint8_t prev_SPI_settings;
	ADCPower(TRUE);
     28a:	81 e0       	ldi	r24, 0x01	; 1
     28c:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	prev_SPI_settings = SPIC.CTRL;
     290:	c0 ec       	ldi	r28, 0xC0	; 192
     292:	d8 e0       	ldi	r29, 0x08	; 8
     294:	f8 80       	ld	r15, Y
	SPIInit(SPI_MODE_0_gc);
     296:	80 e0       	ldi	r24, 0x00	; 0
     298:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     29c:	80 ed       	ldi	r24, 0xD0	; 208
     29e:	88 83       	st	Y, r24
	SPICS(TRUE);
     2a0:	81 e0       	ldi	r24, 0x01	; 1
     2a2:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2a6:	88 e0       	ldi	r24, 0x08	; 8
     2a8:	e0 e2       	ldi	r30, 0x20	; 32
     2aa:	f6 e0       	ldi	r31, 0x06	; 6
     2ac:	86 83       	std	Z+6, r24	; 0x06
	nop();
     2ae:	00 00       	nop
	SPIC.DATA = FR_WREN;
     2b0:	86 e0       	ldi	r24, 0x06	; 6
     2b2:	8b 83       	std	Y+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2b4:	e0 ec       	ldi	r30, 0xC0	; 192
     2b6:	f8 e0       	ldi	r31, 0x08	; 8
     2b8:	82 81       	ldd	r24, Z+2	; 0x02
     2ba:	88 23       	and	r24, r24
     2bc:	ec f7       	brge	.-6      	; 0x2b8 <writeFRAM+0x46>
	SPIBuffer[12] = SPIC.DATA;
     2be:	e0 ec       	ldi	r30, 0xC0	; 192
     2c0:	f8 e0       	ldi	r31, 0x08	; 8
     2c2:	83 81       	ldd	r24, Z+3	; 0x03
     2c4:	80 93 2c 3e 	sts	0x3E2C, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
     2c8:	a0 e2       	ldi	r26, 0x20	; 32
     2ca:	b6 e0       	ldi	r27, 0x06	; 6
     2cc:	88 e0       	ldi	r24, 0x08	; 8
     2ce:	15 96       	adiw	r26, 0x05	; 5
     2d0:	8c 93       	st	X, r24
     2d2:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
     2d4:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2d6:	16 96       	adiw	r26, 0x06	; 6
     2d8:	8c 93       	st	X, r24
     2da:	16 97       	sbiw	r26, 0x06	; 6
	nop();
     2dc:	00 00       	nop
	SPIC.DATA = FR_WRITE;
     2de:	82 e0       	ldi	r24, 0x02	; 2
     2e0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2e2:	82 81       	ldd	r24, Z+2	; 0x02
     2e4:	88 23       	and	r24, r24
     2e6:	ec f7       	brge	.-6      	; 0x2e2 <writeFRAM+0x70>
	SPIBuffer[12] = SPIC.DATA;
     2e8:	e0 ec       	ldi	r30, 0xC0	; 192
     2ea:	f8 e0       	ldi	r31, 0x08	; 8
     2ec:	83 81       	ldd	r24, Z+3	; 0x03
     2ee:	80 93 2c 3e 	sts	0x3E2C, r24
	//send address at which to start writing data
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
     2f2:	80 91 1e 3e 	lds	r24, 0x3E1E
     2f6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2f8:	82 81       	ldd	r24, Z+2	; 0x02
     2fa:	88 23       	and	r24, r24
     2fc:	ec f7       	brge	.-6      	; 0x2f8 <writeFRAM+0x86>
	SPIBuffer[12] = SPIC.DATA;
     2fe:	e0 ec       	ldi	r30, 0xC0	; 192
     300:	f8 e0       	ldi	r31, 0x08	; 8
     302:	83 81       	ldd	r24, Z+3	; 0x03
     304:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
     308:	80 91 1d 3e 	lds	r24, 0x3E1D
     30c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     30e:	82 81       	ldd	r24, Z+2	; 0x02
     310:	88 23       	and	r24, r24
     312:	ec f7       	brge	.-6      	; 0x30e <writeFRAM+0x9c>
	SPIBuffer[12] = SPIC.DATA;
     314:	e0 ec       	ldi	r30, 0xC0	; 192
     316:	f8 e0       	ldi	r31, 0x08	; 8
     318:	83 81       	ldd	r24, Z+3	; 0x03
     31a:	80 93 2c 3e 	sts	0x3E2C, r24
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     31e:	a8 01       	movw	r20, r16
     320:	60 e0       	ldi	r22, 0x00	; 0
     322:	70 e0       	ldi	r23, 0x00	; 0
     324:	41 15       	cp	r20, r1
     326:	51 05       	cpc	r21, r1
     328:	61 05       	cpc	r22, r1
     32a:	71 05       	cpc	r23, r1
     32c:	c9 f0       	breq	.+50     	; 0x360 <writeFRAM+0xee>
     32e:	ae 2c       	mov	r10, r14
     330:	bd 2c       	mov	r11, r13
     332:	80 e0       	ldi	r24, 0x00	; 0
     334:	90 e0       	ldi	r25, 0x00	; 0
     336:	dc 01       	movw	r26, r24
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     338:	2c e2       	ldi	r18, 0x2C	; 44
     33a:	3e e3       	ldi	r19, 0x3E	; 62
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
		SPIC.DATA = buffer[i];
     33c:	e5 01       	movw	r28, r10
     33e:	e9 90       	ld	r14, Y+
     340:	5e 01       	movw	r10, r28
     342:	e3 82       	std	Z+3, r14	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
     344:	e2 80       	ldd	r14, Z+2	; 0x02
     346:	ee 20       	and	r14, r14
     348:	ec f7       	brge	.-6      	; 0x344 <writeFRAM+0xd2>
		SPIBuffer[12] = SPIC.DATA;
     34a:	e3 80       	ldd	r14, Z+3	; 0x03
     34c:	e9 01       	movw	r28, r18
     34e:	e8 82       	st	Y, r14
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     350:	01 96       	adiw	r24, 0x01	; 1
     352:	a1 1d       	adc	r26, r1
     354:	b1 1d       	adc	r27, r1
     356:	84 17       	cp	r24, r20
     358:	95 07       	cpc	r25, r21
     35a:	a6 07       	cpc	r26, r22
     35c:	b7 07       	cpc	r27, r23
     35e:	70 f3       	brcs	.-36     	; 0x33c <writeFRAM+0xca>
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
     360:	88 e0       	ldi	r24, 0x08	; 8
     362:	e0 e2       	ldi	r30, 0x20	; 32
     364:	f6 e0       	ldi	r31, 0x06	; 6
     366:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     368:	80 e0       	ldi	r24, 0x00	; 0
     36a:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIC.CTRL = prev_SPI_settings;
     36e:	f0 92 c0 08 	sts	0x08C0, r15
	//SPIC.CTRL = ADC_SPI_CONFIG_gc;
	//PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
	
	//increment address by the written length
	FRAMAddress +=length;
     372:	80 91 1d 3e 	lds	r24, 0x3E1D
     376:	90 91 1e 3e 	lds	r25, 0x3E1E
     37a:	08 0f       	add	r16, r24
     37c:	19 1f       	adc	r17, r25
     37e:	00 93 1d 3e 	sts	0x3E1D, r16
     382:	10 93 1e 3e 	sts	0x3E1E, r17
}
     386:	df 91       	pop	r29
     388:	cf 91       	pop	r28
     38a:	1f 91       	pop	r17
     38c:	0f 91       	pop	r16
     38e:	ff 90       	pop	r15
     390:	ef 90       	pop	r14
     392:	df 90       	pop	r13
     394:	bf 90       	pop	r11
     396:	af 90       	pop	r10
     398:	08 95       	ret

0000039a <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes, uint16_t startAddress) {
     39a:	df 92       	push	r13
     39c:	ef 92       	push	r14
     39e:	ff 92       	push	r15
     3a0:	0f 93       	push	r16
     3a2:	1f 93       	push	r17
     3a4:	cf 93       	push	r28
     3a6:	df 93       	push	r29
     3a8:	0f 92       	push	r0
     3aa:	0f 92       	push	r0
     3ac:	cd b7       	in	r28, 0x3d	; 61
     3ae:	de b7       	in	r29, 0x3e	; 62
     3b0:	7c 01       	movw	r14, r24
     3b2:	69 83       	std	Y+1, r22	; 0x01
     3b4:	7a 83       	std	Y+2, r23	; 0x02
	
	//save SPI registers
	uint8_t prev_SPI_settings;
	ADCPower(TRUE);
     3b6:	81 e0       	ldi	r24, 0x01	; 1
     3b8:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	prev_SPI_settings = SPIC.CTRL;
     3bc:	00 ec       	ldi	r16, 0xC0	; 192
     3be:	18 e0       	ldi	r17, 0x08	; 8
     3c0:	f8 01       	movw	r30, r16
     3c2:	d0 80       	ld	r13, Z
	SPIInit(SPI_MODE_0_gc);
     3c4:	80 e0       	ldi	r24, 0x00	; 0
     3c6:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     3ca:	80 ed       	ldi	r24, 0xD0	; 208
     3cc:	f8 01       	movw	r30, r16
     3ce:	80 83       	st	Z, r24
	SPICS(TRUE);
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     3d6:	88 e0       	ldi	r24, 0x08	; 8
     3d8:	e0 e2       	ldi	r30, 0x20	; 32
     3da:	f6 e0       	ldi	r31, 0x06	; 6
     3dc:	86 83       	std	Z+6, r24	; 0x06
	nop();
     3de:	00 00       	nop
	
	SPIC.DATA = FR_READ;
     3e0:	83 e0       	ldi	r24, 0x03	; 3
     3e2:	f8 01       	movw	r30, r16
     3e4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3e6:	82 81       	ldd	r24, Z+2	; 0x02
     3e8:	88 23       	and	r24, r24
     3ea:	ec f7       	brge	.-6      	; 0x3e6 <readFRAM+0x4c>
	SPIBuffer[12] = SPIC.DATA;
     3ec:	e0 ec       	ldi	r30, 0xC0	; 192
     3ee:	f8 e0       	ldi	r31, 0x08	; 8
     3f0:	83 81       	ldd	r24, Z+3	; 0x03
     3f2:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = *(((uint8_t*)&startAddress) + 1);;
     3f6:	8a 81       	ldd	r24, Y+2	; 0x02
     3f8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3fa:	82 81       	ldd	r24, Z+2	; 0x02
     3fc:	88 23       	and	r24, r24
     3fe:	ec f7       	brge	.-6      	; 0x3fa <readFRAM+0x60>
	SPIBuffer[12] = SPIC.DATA;
     400:	e0 ec       	ldi	r30, 0xC0	; 192
     402:	f8 e0       	ldi	r31, 0x08	; 8
     404:	83 81       	ldd	r24, Z+3	; 0x03
     406:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
     40a:	89 81       	ldd	r24, Y+1	; 0x01
     40c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     40e:	82 81       	ldd	r24, Z+2	; 0x02
     410:	88 23       	and	r24, r24
     412:	ec f7       	brge	.-6      	; 0x40e <readFRAM+0x74>
	SPIBuffer[12] = SPIC.DATA;
     414:	e0 ec       	ldi	r30, 0xC0	; 192
     416:	f8 e0       	ldi	r31, 0x08	; 8
     418:	83 81       	ldd	r24, Z+3	; 0x03
     41a:	80 93 2c 3e 	sts	0x3E2C, r24
	
	for(uint16_t i = 0; i < numBytes; i++) {
     41e:	e1 14       	cp	r14, r1
     420:	f1 04       	cpc	r15, r1
     422:	b9 f0       	breq	.+46     	; 0x452 <readFRAM+0xb8>
     424:	ec ea       	ldi	r30, 0xAC	; 172
     426:	f1 e2       	ldi	r31, 0x21	; 33
	FRAMAddress +=length;
}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes, uint16_t startAddress) {
     428:	c7 01       	movw	r24, r14
     42a:	8e 0f       	add	r24, r30
     42c:	9f 1f       	adc	r25, r31
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
		SPIC.DATA = 0xAA;
     42e:	a0 ec       	ldi	r26, 0xC0	; 192
     430:	b8 e0       	ldi	r27, 0x08	; 8
     432:	3a ea       	ldi	r19, 0xAA	; 170
     434:	13 96       	adiw	r26, 0x03	; 3
     436:	3c 93       	st	X, r19
     438:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     43a:	12 96       	adiw	r26, 0x02	; 2
     43c:	2c 91       	ld	r18, X
     43e:	12 97       	sbiw	r26, 0x02	; 2
     440:	22 23       	and	r18, r18
     442:	dc f7       	brge	.-10     	; 0x43a <readFRAM+0xa0>
		FRAMReadBuffer[i] = SPIC.DATA;
     444:	13 96       	adiw	r26, 0x03	; 3
     446:	2c 91       	ld	r18, X
     448:	13 97       	sbiw	r26, 0x03	; 3
     44a:	21 93       	st	Z+, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
     44c:	e8 17       	cp	r30, r24
     44e:	f9 07       	cpc	r31, r25
     450:	89 f7       	brne	.-30     	; 0x434 <readFRAM+0x9a>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
     452:	88 e0       	ldi	r24, 0x08	; 8
     454:	e0 e2       	ldi	r30, 0x20	; 32
     456:	f6 e0       	ldi	r31, 0x06	; 6
     458:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     45a:	80 e0       	ldi	r24, 0x00	; 0
     45c:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIC.CTRL = prev_SPI_settings;
     460:	d0 92 c0 08 	sts	0x08C0, r13

}
     464:	0f 90       	pop	r0
     466:	0f 90       	pop	r0
     468:	df 91       	pop	r29
     46a:	cf 91       	pop	r28
     46c:	1f 91       	pop	r17
     46e:	0f 91       	pop	r16
     470:	ff 90       	pop	r15
     472:	ef 90       	pop	r14
     474:	df 90       	pop	r13
     476:	08 95       	ret

00000478 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     478:	cf 92       	push	r12
     47a:	df 92       	push	r13
     47c:	ef 92       	push	r14
     47e:	ff 92       	push	r15
     480:	0f 93       	push	r16
     482:	1f 93       	push	r17
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
     488:	6b 01       	movw	r12, r22
     48a:	7c 01       	movw	r14, r24
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     48c:	dc 01       	movw	r26, r24
     48e:	cb 01       	movw	r24, r22
     490:	88 55       	subi	r24, 0x58	; 88
     492:	92 40       	sbci	r25, 0x02	; 2
     494:	a0 40       	sbci	r26, 0x00	; 0
     496:	b0 40       	sbci	r27, 0x00	; 0
     498:	89 3e       	cpi	r24, 0xE9	; 233
     49a:	2f e3       	ldi	r18, 0x3F	; 63
     49c:	92 07       	cpc	r25, r18
     49e:	2f e0       	ldi	r18, 0x0F	; 15
     4a0:	a2 07       	cpc	r26, r18
     4a2:	20 e0       	ldi	r18, 0x00	; 0
     4a4:	b2 07       	cpc	r27, r18
     4a6:	08 f0       	brcs	.+2      	; 0x4aa <StartSerial+0x32>
     4a8:	5c c0       	rjmp	.+184    	; 0x562 <StartSerial+0xea>
		//baud rate too fast or too slow
		return false;
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     4aa:	0e 94 3c 03 	call	0x678	; 0x678 <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     4ae:	e0 e4       	ldi	r30, 0x40	; 64
     4b0:	f6 e0       	ldi	r31, 0x06	; 6
     4b2:	88 e0       	ldi	r24, 0x08	; 8
     4b4:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = PIN3_bm;
     4b6:	85 83       	std	Z+5, r24	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     4b8:	84 e0       	ldi	r24, 0x04	; 4
     4ba:	82 83       	std	Z+2, r24	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     4bc:	cc 0c       	add	r12, r12
     4be:	dd 1c       	adc	r13, r13
     4c0:	ee 1c       	adc	r14, r14
     4c2:	ff 1c       	adc	r15, r15
     4c4:	cc 0c       	add	r12, r12
     4c6:	dd 1c       	adc	r13, r13
     4c8:	ee 1c       	adc	r14, r14
     4ca:	ff 1c       	adc	r15, r15
     4cc:	c7 01       	movw	r24, r14
     4ce:	b6 01       	movw	r22, r12
     4d0:	66 0f       	add	r22, r22
     4d2:	77 1f       	adc	r23, r23
     4d4:	88 1f       	adc	r24, r24
     4d6:	99 1f       	adc	r25, r25
     4d8:	66 0f       	add	r22, r22
     4da:	77 1f       	adc	r23, r23
     4dc:	88 1f       	adc	r24, r24
     4de:	99 1f       	adc	r25, r25
     4e0:	0e 94 6f 38 	call	0x70de	; 0x70de <__floatunsisf>
     4e4:	9b 01       	movw	r18, r22
     4e6:	ac 01       	movw	r20, r24
     4e8:	60 e0       	ldi	r22, 0x00	; 0
     4ea:	74 e2       	ldi	r23, 0x24	; 36
     4ec:	84 ef       	ldi	r24, 0xF4	; 244
     4ee:	9b e4       	ldi	r25, 0x4B	; 75
     4f0:	0e 94 db 37 	call	0x6fb6	; 0x6fb6 <__divsf3>
     4f4:	20 e0       	ldi	r18, 0x00	; 0
     4f6:	30 e0       	ldi	r19, 0x00	; 0
     4f8:	40 e8       	ldi	r20, 0x80	; 128
     4fa:	5f e3       	ldi	r21, 0x3F	; 63
     4fc:	0e 94 76 37 	call	0x6eec	; 0x6eec <__subsf3>
     500:	c6 2f       	mov	r28, r22
     502:	d7 2f       	mov	r29, r23
     504:	18 2f       	mov	r17, r24
     506:	09 2f       	mov	r16, r25
     508:	86 2f       	mov	r24, r22
     50a:	9d 2f       	mov	r25, r29
     50c:	a1 2f       	mov	r26, r17
     50e:	b0 2f       	mov	r27, r16
     510:	bc 01       	movw	r22, r24
     512:	cd 01       	movw	r24, r26
     514:	0e 94 43 38 	call	0x7086	; 0x7086 <__fixunssfsi>
     518:	6b 01       	movw	r12, r22
     51a:	7c 01       	movw	r14, r24
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     51c:	80 e0       	ldi	r24, 0x00	; 0
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	0e 94 6f 38 	call	0x70de	; 0x70de <__floatunsisf>
     524:	9b 01       	movw	r18, r22
     526:	ac 01       	movw	r20, r24
     528:	8c 2f       	mov	r24, r28
     52a:	9d 2f       	mov	r25, r29
     52c:	a1 2f       	mov	r26, r17
     52e:	b0 2f       	mov	r27, r16
     530:	bc 01       	movw	r22, r24
     532:	cd 01       	movw	r24, r26
     534:	0e 94 76 37 	call	0x6eec	; 0x6eec <__subsf3>
     538:	20 e0       	ldi	r18, 0x00	; 0
     53a:	30 e0       	ldi	r19, 0x00	; 0
     53c:	40 e0       	ldi	r20, 0x00	; 0
     53e:	5f e3       	ldi	r21, 0x3F	; 63
     540:	0e 94 fd 38 	call	0x71fa	; 0x71fa <__gesf2>
     544:	88 23       	and	r24, r24
     546:	1c f0       	brlt	.+6      	; 0x54e <StartSerial+0xd6>
     548:	08 94       	sec
     54a:	c1 1c       	adc	r12, r1
     54c:	d1 1c       	adc	r13, r1
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     54e:	e0 ea       	ldi	r30, 0xA0	; 160
     550:	f8 e0       	ldi	r31, 0x08	; 8
     552:	c6 82       	std	Z+6, r12	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     554:	d7 82       	std	Z+7, r13	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     556:	83 e0       	ldi	r24, 0x03	; 3
     558:	85 83       	std	Z+5, r24	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     55a:	88 e1       	ldi	r24, 0x18	; 24
     55c:	84 83       	std	Z+4, r24	; 0x04
	return true;
     55e:	81 e0       	ldi	r24, 0x01	; 1
     560:	01 c0       	rjmp	.+2      	; 0x564 <StartSerial+0xec>

bool StartSerial(uint32_t BaudRate){
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
		//baud rate too fast or too slow
		return false;
     562:	80 e0       	ldi	r24, 0x00	; 0
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
	return true;
}
     564:	df 91       	pop	r29
     566:	cf 91       	pop	r28
     568:	1f 91       	pop	r17
     56a:	0f 91       	pop	r16
     56c:	ff 90       	pop	r15
     56e:	ef 90       	pop	r14
     570:	df 90       	pop	r13
     572:	cf 90       	pop	r12
     574:	08 95       	ret

00000576 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     576:	e0 ea       	ldi	r30, 0xA0	; 160
     578:	f8 e0       	ldi	r31, 0x08	; 8
     57a:	91 81       	ldd	r25, Z+1	; 0x01
     57c:	95 ff       	sbrs	r25, 5
     57e:	fd cf       	rjmp	.-6      	; 0x57a <SerialWriteByte+0x4>
		//wait
	}
	//send byte
	USARTC0.DATA = byte;
     580:	80 93 a0 08 	sts	0x08A0, r24
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     584:	08 95       	ret

00000586 <SerialReadByte>:

uint8_t SerialReadByte(){
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     586:	e0 ea       	ldi	r30, 0xA0	; 160
     588:	f8 e0       	ldi	r31, 0x08	; 8
     58a:	81 81       	ldd	r24, Z+1	; 0x01
     58c:	88 23       	and	r24, r24
     58e:	ec f7       	brge	.-6      	; 0x58a <SerialReadByte+0x4>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     590:	80 91 a0 08 	lds	r24, 0x08A0
	return byte;	
}
     594:	08 95       	ret

00000596 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     596:	8f 92       	push	r8
     598:	9f 92       	push	r9
     59a:	af 92       	push	r10
     59c:	bf 92       	push	r11
     59e:	cf 92       	push	r12
     5a0:	df 92       	push	r13
     5a2:	ef 92       	push	r14
     5a4:	ff 92       	push	r15
     5a6:	cf 93       	push	r28
     5a8:	df 93       	push	r29
     5aa:	6a 01       	movw	r12, r20
     5ac:	7b 01       	movw	r14, r22
	uint32_t i;
	for(i=0;i<length;i++){
     5ae:	41 15       	cp	r20, r1
     5b0:	51 05       	cpc	r21, r1
     5b2:	61 05       	cpc	r22, r1
     5b4:	71 05       	cpc	r23, r1
     5b6:	91 f0       	breq	.+36     	; 0x5dc <SerialWriteBuffer+0x46>
     5b8:	c8 2f       	mov	r28, r24
     5ba:	d9 2f       	mov	r29, r25
     5bc:	88 24       	eor	r8, r8
     5be:	99 24       	eor	r9, r9
     5c0:	54 01       	movw	r10, r8
		SerialWriteByte(buffer[i]);
     5c2:	89 91       	ld	r24, Y+
     5c4:	0e 94 bb 02 	call	0x576	; 0x576 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     5c8:	08 94       	sec
     5ca:	81 1c       	adc	r8, r1
     5cc:	91 1c       	adc	r9, r1
     5ce:	a1 1c       	adc	r10, r1
     5d0:	b1 1c       	adc	r11, r1
     5d2:	8c 14       	cp	r8, r12
     5d4:	9d 04       	cpc	r9, r13
     5d6:	ae 04       	cpc	r10, r14
     5d8:	bf 04       	cpc	r11, r15
     5da:	99 f7       	brne	.-26     	; 0x5c2 <SerialWriteBuffer+0x2c>
		SerialWriteByte(buffer[i]);
	}
}
     5dc:	df 91       	pop	r29
     5de:	cf 91       	pop	r28
     5e0:	ff 90       	pop	r15
     5e2:	ef 90       	pop	r14
     5e4:	df 90       	pop	r13
     5e6:	cf 90       	pop	r12
     5e8:	bf 90       	pop	r11
     5ea:	af 90       	pop	r10
     5ec:	9f 90       	pop	r9
     5ee:	8f 90       	pop	r8
     5f0:	08 95       	ret

000005f2 <StopSerial>:

void StopSerial(){
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     5f2:	e0 ea       	ldi	r30, 0xA0	; 160
     5f4:	f8 e0       	ldi	r31, 0x08	; 8
     5f6:	84 81       	ldd	r24, Z+4	; 0x04
     5f8:	87 7e       	andi	r24, 0xE7	; 231
     5fa:	84 83       	std	Z+4, r24	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     5fc:	e0 e4       	ldi	r30, 0x40	; 64
     5fe:	f6 e0       	ldi	r31, 0x06	; 6
     600:	88 e0       	ldi	r24, 0x08	; 8
     602:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     604:	82 83       	std	Z+2, r24	; 0x02
     606:	08 95       	ret

00000608 <init>:
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void init(){
	ADC_POWER_ON = 0;
     608:	10 92 32 3e 	sts	0x3E32, r1
}
     60c:	08 95       	ret

0000060e <setXOSC_32MHz>:

void setXOSC_32MHz() {
	// configure the crystal to match the chip
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
     60e:	80 ec       	ldi	r24, 0xC0	; 192
     610:	60 e0       	ldi	r22, 0x00	; 0
     612:	4b e0       	ldi	r20, 0x0B	; 11
     614:	0e 94 13 20 	call	0x4026	; 0x4026 <CLKSYS_XOSC_Config>
	false,
	OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
     618:	e0 e5       	ldi	r30, 0x50	; 80
     61a:	f0 e0       	ldi	r31, 0x00	; 0
     61c:	80 81       	ld	r24, Z
     61e:	88 60       	ori	r24, 0x08	; 8
     620:	80 83       	st	Z, r24
	// wait for signal to stabilize
do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
     622:	81 81       	ldd	r24, Z+1	; 0x01
     624:	83 ff       	sbrs	r24, 3
     626:	fd cf       	rjmp	.-6      	; 0x622 <setXOSC_32MHz+0x14>
// configure PLL to use the crystal and turn on
CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
     628:	80 ec       	ldi	r24, 0xC0	; 192
     62a:	62 e0       	ldi	r22, 0x02	; 2
     62c:	0e 94 1e 20 	call	0x403c	; 0x403c <CLKSYS_PLL_Config>
CLKSYS_Enable( OSC_PLLEN_bm );
     630:	e0 e5       	ldi	r30, 0x50	; 80
     632:	f0 e0       	ldi	r31, 0x00	; 0
     634:	80 81       	ld	r24, Z
     636:	80 61       	ori	r24, 0x10	; 16
     638:	80 83       	st	Z, r24
// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
     63a:	81 81       	ldd	r24, Z+1	; 0x01
     63c:	84 ff       	sbrs	r24, 4
     63e:	fd cf       	rjmp	.-6      	; 0x63a <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
     640:	84 e0       	ldi	r24, 0x04	; 4
     642:	0e 94 34 20 	call	0x4068	; 0x4068 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     646:	81 e0       	ldi	r24, 0x01	; 1
     648:	0e 94 24 20 	call	0x4048	; 0x4048 <CLKSYS_Disable>
}
     64c:	08 95       	ret

0000064e <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
     64e:	e0 e5       	ldi	r30, 0x50	; 80
     650:	f0 e0       	ldi	r31, 0x00	; 0
     652:	80 81       	ld	r24, Z
     654:	82 60       	ori	r24, 0x02	; 2
     656:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
     658:	80 e0       	ldi	r24, 0x00	; 0
     65a:	61 e0       	ldi	r22, 0x01	; 1
     65c:	0e 94 2e 20 	call	0x405c	; 0x405c <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     660:	e0 e5       	ldi	r30, 0x50	; 80
     662:	f0 e0       	ldi	r31, 0x00	; 0
     664:	81 81       	ldd	r24, Z+1	; 0x01
     666:	81 ff       	sbrs	r24, 1
     668:	fd cf       	rjmp	.-6      	; 0x664 <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     66a:	81 e0       	ldi	r24, 0x01	; 1
     66c:	0e 94 34 20 	call	0x4068	; 0x4068 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     670:	81 e0       	ldi	r24, 0x01	; 1
     672:	0e 94 24 20 	call	0x4048	; 0x4048 <CLKSYS_Disable>
	
}
     676:	08 95       	ret

00000678 <set_32MHz>:

// produces consistent but inaccurate clock period.
void set_32MHz() {
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
     678:	e0 e5       	ldi	r30, 0x50	; 80
     67a:	f0 e0       	ldi	r31, 0x00	; 0
     67c:	80 81       	ld	r24, Z
     67e:	82 60       	ori	r24, 0x02	; 2
     680:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
     682:	80 e0       	ldi	r24, 0x00	; 0
     684:	60 e0       	ldi	r22, 0x00	; 0
     686:	0e 94 2e 20 	call	0x405c	; 0x405c <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     68a:	e0 e5       	ldi	r30, 0x50	; 80
     68c:	f0 e0       	ldi	r31, 0x00	; 0
     68e:	81 81       	ldd	r24, Z+1	; 0x01
     690:	81 ff       	sbrs	r24, 1
     692:	fd cf       	rjmp	.-6      	; 0x68e <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     694:	81 e0       	ldi	r24, 0x01	; 1
     696:	0e 94 34 20 	call	0x4068	; 0x4068 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     69a:	81 e0       	ldi	r24, 0x01	; 1
     69c:	0e 94 24 20 	call	0x4048	; 0x4048 <CLKSYS_Disable>
	
}
     6a0:	08 95       	ret

000006a2 <portExCS>:


void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
     6a2:	88 23       	and	r24, r24
     6a4:	29 f0       	breq	.+10     	; 0x6b0 <portExCS+0xe>
     6a6:	88 e0       	ldi	r24, 0x08	; 8
     6a8:	e0 e0       	ldi	r30, 0x00	; 0
     6aa:	f6 e0       	ldi	r31, 0x06	; 6
     6ac:	86 83       	std	Z+6, r24	; 0x06
     6ae:	04 c0       	rjmp	.+8      	; 0x6b8 <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
     6b0:	88 e0       	ldi	r24, 0x08	; 8
     6b2:	e0 e0       	ldi	r30, 0x00	; 0
     6b4:	f6 e0       	ldi	r31, 0x06	; 6
     6b6:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6b8:	8a e6       	ldi	r24, 0x6A	; 106
     6ba:	8a 95       	dec	r24
     6bc:	f1 f7       	brne	.-4      	; 0x6ba <portExCS+0x18>
     6be:	00 c0       	rjmp	.+0      	; 0x6c0 <portExCS+0x1e>
	}
	_delay_us(10);
}
     6c0:	08 95       	ret

000006c2 <Ext1Power>:
	SPIDisable();
}

void Ext1Power(uint8_t on) {
	
	if (on) {
     6c2:	88 23       	and	r24, r24
     6c4:	79 f0       	breq	.+30     	; 0x6e4 <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
     6c6:	e0 ea       	ldi	r30, 0xA0	; 160
     6c8:	f6 e0       	ldi	r31, 0x06	; 6
     6ca:	80 e2       	ldi	r24, 0x20	; 32
     6cc:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
     6ce:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6d0:	8f ef       	ldi	r24, 0xFF	; 255
     6d2:	93 ec       	ldi	r25, 0xC3	; 195
     6d4:	a9 e0       	ldi	r26, 0x09	; 9
     6d6:	81 50       	subi	r24, 0x01	; 1
     6d8:	90 40       	sbci	r25, 0x00	; 0
     6da:	a0 40       	sbci	r26, 0x00	; 0
     6dc:	e1 f7       	brne	.-8      	; 0x6d6 <Ext1Power+0x14>
     6de:	00 c0       	rjmp	.+0      	; 0x6e0 <Ext1Power+0x1e>
     6e0:	00 00       	nop
     6e2:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
     6e4:	e0 ea       	ldi	r30, 0xA0	; 160
     6e6:	f6 e0       	ldi	r31, 0x06	; 6
     6e8:	80 e2       	ldi	r24, 0x20	; 32
     6ea:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
     6ec:	82 83       	std	Z+2, r24	; 0x02
     6ee:	08 95       	ret

000006f0 <Ext2Power>:
	}
}

void Ext2Power(uint8_t on) {
	
	if (on) {
     6f0:	88 23       	and	r24, r24
     6f2:	79 f0       	breq	.+30     	; 0x712 <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
     6f4:	e0 ea       	ldi	r30, 0xA0	; 160
     6f6:	f6 e0       	ldi	r31, 0x06	; 6
     6f8:	80 e4       	ldi	r24, 0x40	; 64
     6fa:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
     6fc:	85 83       	std	Z+5, r24	; 0x05
     6fe:	8f ef       	ldi	r24, 0xFF	; 255
     700:	93 ec       	ldi	r25, 0xC3	; 195
     702:	a9 e0       	ldi	r26, 0x09	; 9
     704:	81 50       	subi	r24, 0x01	; 1
     706:	90 40       	sbci	r25, 0x00	; 0
     708:	a0 40       	sbci	r26, 0x00	; 0
     70a:	e1 f7       	brne	.-8      	; 0x704 <Ext2Power+0x14>
     70c:	00 c0       	rjmp	.+0      	; 0x70e <Ext2Power+0x1e>
     70e:	00 00       	nop
     710:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
     712:	e0 ea       	ldi	r30, 0xA0	; 160
     714:	f6 e0       	ldi	r31, 0x06	; 6
     716:	80 e4       	ldi	r24, 0x40	; 64
     718:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
     71a:	82 83       	std	Z+2, r24	; 0x02
     71c:	08 95       	ret

0000071e <HVPower>:
	}
}

void HVPower(uint8_t on) {
	
	if (on) {
     71e:	88 23       	and	r24, r24
     720:	79 f0       	breq	.+30     	; 0x740 <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
     722:	e0 ea       	ldi	r30, 0xA0	; 160
     724:	f6 e0       	ldi	r31, 0x06	; 6
     726:	80 e8       	ldi	r24, 0x80	; 128
     728:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
     72a:	85 83       	std	Z+5, r24	; 0x05
     72c:	8f ef       	ldi	r24, 0xFF	; 255
     72e:	93 ec       	ldi	r25, 0xC3	; 195
     730:	a9 e0       	ldi	r26, 0x09	; 9
     732:	81 50       	subi	r24, 0x01	; 1
     734:	90 40       	sbci	r25, 0x00	; 0
     736:	a0 40       	sbci	r26, 0x00	; 0
     738:	e1 f7       	brne	.-8      	; 0x732 <HVPower+0x14>
     73a:	00 c0       	rjmp	.+0      	; 0x73c <HVPower+0x1e>
     73c:	00 00       	nop
     73e:	05 c0       	rjmp	.+10     	; 0x74a <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
     740:	e0 ea       	ldi	r30, 0xA0	; 160
     742:	f6 e0       	ldi	r31, 0x06	; 6
     744:	80 e8       	ldi	r24, 0x80	; 128
     746:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
     748:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     74a:	af e3       	ldi	r26, 0x3F	; 63
     74c:	bf e1       	ldi	r27, 0x1F	; 31
     74e:	11 97       	sbiw	r26, 0x01	; 1
     750:	f1 f7       	brne	.-4      	; 0x74e <HVPower+0x30>
     752:	00 c0       	rjmp	.+0      	; 0x754 <HVPower+0x36>
     754:	00 00       	nop
	}
	_delay_us(1000);
}
     756:	08 95       	ret

00000758 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
     758:	88 23       	and	r24, r24
     75a:	29 f0       	breq	.+10     	; 0x766 <lowerMuxCS+0xe>
     75c:	80 e1       	ldi	r24, 0x10	; 16
     75e:	e0 e8       	ldi	r30, 0x80	; 128
     760:	f6 e0       	ldi	r31, 0x06	; 6
     762:	86 83       	std	Z+6, r24	; 0x06
     764:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
     766:	80 e1       	ldi	r24, 0x10	; 16
     768:	e0 e8       	ldi	r30, 0x80	; 128
     76a:	f6 e0       	ldi	r31, 0x06	; 6
     76c:	85 83       	std	Z+5, r24	; 0x05
     76e:	08 95       	ret

00000770 <upperMuxCS>:
}

void upperMuxCS(uint8_t write) {
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
     770:	88 23       	and	r24, r24
     772:	29 f0       	breq	.+10     	; 0x77e <upperMuxCS+0xe>
     774:	82 e0       	ldi	r24, 0x02	; 2
     776:	e0 e4       	ldi	r30, 0x40	; 64
     778:	f6 e0       	ldi	r31, 0x06	; 6
     77a:	86 83       	std	Z+6, r24	; 0x06
     77c:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
     77e:	82 e0       	ldi	r24, 0x02	; 2
     780:	e0 e4       	ldi	r30, 0x40	; 64
     782:	f6 e0       	ldi	r31, 0x06	; 6
     784:	85 83       	std	Z+5, r24	; 0x05
     786:	08 95       	ret

00000788 <SPIInit>:
}

void SPIInit(uint8_t mode) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     788:	e0 e4       	ldi	r30, 0x40	; 64
     78a:	f6 e0       	ldi	r31, 0x06	; 6
     78c:	90 e1       	ldi	r25, 0x10	; 16
     78e:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     790:	28 e3       	ldi	r18, 0x38	; 56
     792:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     794:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
     796:	81 65       	ori	r24, 0x51	; 81
     798:	a0 ec       	ldi	r26, 0xC0	; 192
     79a:	b8 e0       	ldi	r27, 0x08	; 8
     79c:	8c 93       	st	X, r24
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     79e:	11 96       	adiw	r26, 0x01	; 1
     7a0:	1c 92       	st	X, r1
     7a2:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     7a4:	80 ea       	ldi	r24, 0xA0	; 160
     7a6:	81 83       	std	Z+1, r24	; 0x01

	
}
     7a8:	08 95       	ret

000007aa <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     7aa:	e0 e4       	ldi	r30, 0x40	; 64
     7ac:	f6 e0       	ldi	r31, 0x06	; 6
     7ae:	90 e1       	ldi	r25, 0x10	; 16
     7b0:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     7b2:	28 e3       	ldi	r18, 0x38	; 56
     7b4:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     7b6:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
     7b8:	80 65       	ori	r24, 0x50	; 80
     7ba:	68 2b       	or	r22, r24
     7bc:	a0 ec       	ldi	r26, 0xC0	; 192
     7be:	b8 e0       	ldi	r27, 0x08	; 8
     7c0:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     7c2:	11 96       	adiw	r26, 0x01	; 1
     7c4:	1c 92       	st	X, r1
     7c6:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     7c8:	80 ea       	ldi	r24, 0xA0	; 160
     7ca:	81 83       	std	Z+1, r24	; 0x01
}
     7cc:	08 95       	ret

000007ce <SPICS>:

void SPICS(uint8_t enable) {
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
     7ce:	88 23       	and	r24, r24
     7d0:	29 f0       	breq	.+10     	; 0x7dc <SPICS+0xe>
     7d2:	80 e1       	ldi	r24, 0x10	; 16
     7d4:	e0 e4       	ldi	r30, 0x40	; 64
     7d6:	f6 e0       	ldi	r31, 0x06	; 6
     7d8:	86 83       	std	Z+6, r24	; 0x06
     7da:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
     7dc:	80 e1       	ldi	r24, 0x10	; 16
     7de:	e0 e4       	ldi	r30, 0x40	; 64
     7e0:	f6 e0       	ldi	r31, 0x06	; 6
     7e2:	85 83       	std	Z+5, r24	; 0x05
     7e4:	08 95       	ret

000007e6 <SPIDisable>:
	}
}

void SPIDisable() {
	
	PORTC.OUTSET = PIN4_bm;
     7e6:	e0 e4       	ldi	r30, 0x40	; 64
     7e8:	f6 e0       	ldi	r31, 0x06	; 6
     7ea:	80 e1       	ldi	r24, 0x10	; 16
     7ec:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
     7ee:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
     7f2:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
     7f4:	80 eb       	ldi	r24, 0xB0	; 176
     7f6:	82 83       	std	Z+2, r24	; 0x02

}
     7f8:	08 95       	ret

000007fa <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     7fa:	cf 93       	push	r28
     7fc:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     7fe:	c8 2f       	mov	r28, r24
     800:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
     802:	d8 2f       	mov	r29, r24
     804:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     806:	28 2f       	mov	r18, r24
     808:	30 e0       	ldi	r19, 0x00	; 0
     80a:	a9 01       	movw	r20, r18
     80c:	45 70       	andi	r20, 0x05	; 5
     80e:	50 70       	andi	r21, 0x00	; 0
     810:	41 15       	cp	r20, r1
     812:	51 05       	cpc	r21, r1
     814:	49 f0       	breq	.+18     	; 0x828 <set_filter+0x2e>
     816:	90 91 30 3e 	lds	r25, 0x3E30
     81a:	48 2f       	mov	r20, r24
     81c:	42 95       	swap	r20
     81e:	4f 70       	andi	r20, 0x0F	; 15
     820:	90 7f       	andi	r25, 0xF0	; 240
     822:	94 2b       	or	r25, r20
     824:	90 93 30 3e 	sts	0x3E30, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     828:	2a 70       	andi	r18, 0x0A	; 10
     82a:	30 70       	andi	r19, 0x00	; 0
     82c:	21 15       	cp	r18, r1
     82e:	31 05       	cpc	r19, r1
     830:	39 f0       	breq	.+14     	; 0x840 <set_filter+0x46>
     832:	90 91 30 3e 	lds	r25, 0x3E30
     836:	80 7f       	andi	r24, 0xF0	; 240
     838:	9f 70       	andi	r25, 0x0F	; 15
     83a:	89 2b       	or	r24, r25
     83c:	80 93 30 3e 	sts	0x3E30, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     840:	84 e0       	ldi	r24, 0x04	; 4
     842:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     846:	80 91 30 3e 	lds	r24, 0x3E30
     84a:	80 93 20 3e 	sts	0x3E20, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     84e:	cc 23       	and	r28, r28
     850:	19 f0       	breq	.+6      	; 0x858 <set_filter+0x5e>
     852:	81 e0       	ldi	r24, 0x01	; 1
     854:	0e 94 ac 03 	call	0x758	; 0x758 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     858:	dd 23       	and	r29, r29
     85a:	19 f0       	breq	.+6      	; 0x862 <set_filter+0x68>
     85c:	81 e0       	ldi	r24, 0x01	; 1
     85e:	0e 94 b8 03 	call	0x770	; 0x770 <upperMuxCS>

	SPICS(TRUE);
     862:	81 e0       	ldi	r24, 0x01	; 1
     864:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     868:	8f ef       	ldi	r24, 0xFF	; 255
     86a:	e0 ec       	ldi	r30, 0xC0	; 192
     86c:	f8 e0       	ldi	r31, 0x08	; 8
     86e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     870:	82 81       	ldd	r24, Z+2	; 0x02
     872:	88 23       	and	r24, r24
     874:	ec f7       	brge	.-6      	; 0x870 <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
     876:	e0 ec       	ldi	r30, 0xC0	; 192
     878:	f8 e0       	ldi	r31, 0x08	; 8
     87a:	83 81       	ldd	r24, Z+3	; 0x03
     87c:	80 93 2c 3e 	sts	0x3E2C, r24

	nop();
     880:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     882:	ac e2       	ldi	r26, 0x2C	; 44
     884:	be e3       	ldi	r27, 0x3E	; 62
     886:	1c 97       	sbiw	r26, 0x0c	; 12
     888:	8c 91       	ld	r24, X
     88a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     88c:	82 81       	ldd	r24, Z+2	; 0x02
     88e:	88 23       	and	r24, r24
     890:	ec f7       	brge	.-6      	; 0x88c <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     892:	e0 ec       	ldi	r30, 0xC0	; 192
     894:	f8 e0       	ldi	r31, 0x08	; 8
     896:	83 81       	ldd	r24, Z+3	; 0x03
     898:	80 93 2c 3e 	sts	0x3E2C, r24
	SPICS(FALSE);
     89c:	80 e0       	ldi	r24, 0x00	; 0
     89e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     8a2:	cc 23       	and	r28, r28
     8a4:	19 f0       	breq	.+6      	; 0x8ac <set_filter+0xb2>
     8a6:	80 e0       	ldi	r24, 0x00	; 0
     8a8:	0e 94 ac 03 	call	0x758	; 0x758 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     8ac:	dd 23       	and	r29, r29
     8ae:	19 f0       	breq	.+6      	; 0x8b6 <set_filter+0xbc>
     8b0:	80 e0       	ldi	r24, 0x00	; 0
     8b2:	0e 94 b8 03 	call	0x770	; 0x770 <upperMuxCS>
	SPIDisable();
     8b6:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
}
     8ba:	df 91       	pop	r29
     8bc:	cf 91       	pop	r28
     8be:	08 95       	ret

000008c0 <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     8c0:	cf 93       	push	r28
     8c2:	df 93       	push	r29
     8c4:	c8 2f       	mov	r28, r24
     8c6:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     8c8:	80 e0       	ldi	r24, 0x00	; 0
     8ca:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
     8ce:	81 e0       	ldi	r24, 0x01	; 1
     8d0:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(TRUE);
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
     8da:	dd 23       	and	r29, r29
     8dc:	89 f0       	breq	.+34     	; 0x900 <PortEx_OUTCLR+0x40>
     8de:	80 91 ab 21 	lds	r24, 0x21AB
     8e2:	c0 95       	com	r28
     8e4:	c8 23       	and	r28, r24
     8e6:	c0 93 ab 21 	sts	0x21AB, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
     8ea:	80 e4       	ldi	r24, 0x40	; 64
     8ec:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     8f0:	84 e1       	ldi	r24, 0x14	; 20
     8f2:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = bankA_OUT;
     8f6:	80 91 ab 21 	lds	r24, 0x21AB
     8fa:	80 93 22 3e 	sts	0x3E22, r24
     8fe:	10 c0       	rjmp	.+32     	; 0x920 <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
     900:	80 91 31 3e 	lds	r24, 0x3E31
     904:	c0 95       	com	r28
     906:	c8 23       	and	r28, r24
     908:	c0 93 31 3e 	sts	0x3E31, r28
	
	SPIBuffer[0] = PS_WRITE;
     90c:	80 e4       	ldi	r24, 0x40	; 64
     90e:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     912:	85 e1       	ldi	r24, 0x15	; 21
     914:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = bankB_OUT; 
     918:	80 91 31 3e 	lds	r24, 0x3E31
     91c:	80 93 22 3e 	sts	0x3E22, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     920:	80 e0       	ldi	r24, 0x00	; 0
     922:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     924:	20 e2       	ldi	r18, 0x20	; 32
     926:	3e e3       	ldi	r19, 0x3E	; 62
     928:	a0 ec       	ldi	r26, 0xC0	; 192
     92a:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     92c:	cc e2       	ldi	r28, 0x2C	; 44
     92e:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     930:	f9 01       	movw	r30, r18
     932:	e8 0f       	add	r30, r24
     934:	f9 1f       	adc	r31, r25
     936:	40 81       	ld	r20, Z
     938:	13 96       	adiw	r26, 0x03	; 3
     93a:	4c 93       	st	X, r20
     93c:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     93e:	12 96       	adiw	r26, 0x02	; 2
     940:	4c 91       	ld	r20, X
     942:	12 97       	sbiw	r26, 0x02	; 2
     944:	44 23       	and	r20, r20
     946:	dc f7       	brge	.-10     	; 0x93e <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
     948:	13 96       	adiw	r26, 0x03	; 3
     94a:	4c 91       	ld	r20, X
     94c:	13 97       	sbiw	r26, 0x03	; 3
     94e:	48 83       	st	Y, r20
     950:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     952:	83 30       	cpi	r24, 0x03	; 3
     954:	91 05       	cpc	r25, r1
     956:	61 f7       	brne	.-40     	; 0x930 <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     958:	80 e0       	ldi	r24, 0x00	; 0
     95a:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(FALSE);
     95e:	80 e0       	ldi	r24, 0x00	; 0
     960:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	SPIDisable();
     964:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
}
     968:	df 91       	pop	r29
     96a:	cf 91       	pop	r28
     96c:	08 95       	ret

0000096e <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     96e:	cf 93       	push	r28
     970:	df 93       	push	r29
     972:	c8 2f       	mov	r28, r24
     974:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     976:	80 e0       	ldi	r24, 0x00	; 0
     978:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
     97c:	81 e0       	ldi	r24, 0x01	; 1
     97e:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(TRUE);
     982:	81 e0       	ldi	r24, 0x01	; 1
     984:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
     988:	dd 23       	and	r29, r29
     98a:	81 f0       	breq	.+32     	; 0x9ac <PortEx_OUTSET+0x3e>
     98c:	80 91 ab 21 	lds	r24, 0x21AB
     990:	c8 2b       	or	r28, r24
     992:	c0 93 ab 21 	sts	0x21AB, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
     996:	80 e4       	ldi	r24, 0x40	; 64
     998:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     99c:	84 e1       	ldi	r24, 0x14	; 20
     99e:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = bankA_OUT;
     9a2:	80 91 ab 21 	lds	r24, 0x21AB
     9a6:	80 93 22 3e 	sts	0x3E22, r24
     9aa:	0f c0       	rjmp	.+30     	; 0x9ca <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
     9ac:	80 91 31 3e 	lds	r24, 0x3E31
     9b0:	c8 2b       	or	r28, r24
     9b2:	c0 93 31 3e 	sts	0x3E31, r28
	
	SPIBuffer[0] = PS_WRITE;
     9b6:	80 e4       	ldi	r24, 0x40	; 64
     9b8:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     9bc:	85 e1       	ldi	r24, 0x15	; 21
     9be:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = bankB_OUT; 
     9c2:	80 91 31 3e 	lds	r24, 0x3E31
     9c6:	80 93 22 3e 	sts	0x3E22, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     9ca:	80 e0       	ldi	r24, 0x00	; 0
     9cc:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     9ce:	20 e2       	ldi	r18, 0x20	; 32
     9d0:	3e e3       	ldi	r19, 0x3E	; 62
     9d2:	a0 ec       	ldi	r26, 0xC0	; 192
     9d4:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     9d6:	cc e2       	ldi	r28, 0x2C	; 44
     9d8:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     9da:	f9 01       	movw	r30, r18
     9dc:	e8 0f       	add	r30, r24
     9de:	f9 1f       	adc	r31, r25
     9e0:	40 81       	ld	r20, Z
     9e2:	13 96       	adiw	r26, 0x03	; 3
     9e4:	4c 93       	st	X, r20
     9e6:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     9e8:	12 96       	adiw	r26, 0x02	; 2
     9ea:	4c 91       	ld	r20, X
     9ec:	12 97       	sbiw	r26, 0x02	; 2
     9ee:	44 23       	and	r20, r20
     9f0:	dc f7       	brge	.-10     	; 0x9e8 <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
     9f2:	13 96       	adiw	r26, 0x03	; 3
     9f4:	4c 91       	ld	r20, X
     9f6:	13 97       	sbiw	r26, 0x03	; 3
     9f8:	48 83       	st	Y, r20
     9fa:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     9fc:	83 30       	cpi	r24, 0x03	; 3
     9fe:	91 05       	cpc	r25, r1
     a00:	61 f7       	brne	.-40     	; 0x9da <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     a02:	80 e0       	ldi	r24, 0x00	; 0
     a04:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(FALSE);
     a08:	80 e0       	ldi	r24, 0x00	; 0
     a0a:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	SPIDisable();
     a0e:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
}
     a12:	df 91       	pop	r29
     a14:	cf 91       	pop	r28
     a16:	08 95       	ret

00000a18 <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     a18:	cf 93       	push	r28
     a1a:	df 93       	push	r29
     a1c:	c8 2f       	mov	r28, r24
     a1e:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     a20:	80 e0       	ldi	r24, 0x00	; 0
     a22:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
     a26:	81 e0       	ldi	r24, 0x01	; 1
     a28:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(TRUE);
     a2c:	81 e0       	ldi	r24, 0x01	; 1
     a2e:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
     a32:	dd 23       	and	r29, r29
     a34:	89 f0       	breq	.+34     	; 0xa58 <PortEx_DIRCLR+0x40>
     a36:	80 91 2f 3e 	lds	r24, 0x3E2F
     a3a:	80 95       	com	r24
     a3c:	c8 23       	and	r28, r24
     a3e:	c0 93 2f 3e 	sts	0x3E2F, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     a42:	80 e4       	ldi	r24, 0x40	; 64
     a44:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     a48:	10 92 21 3e 	sts	0x3E21, r1
		SPIBuffer[2] = ~bankA_DIR; 
     a4c:	80 91 2f 3e 	lds	r24, 0x3E2F
     a50:	80 95       	com	r24
     a52:	80 93 22 3e 	sts	0x3E22, r24
     a56:	11 c0       	rjmp	.+34     	; 0xa7a <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
     a58:	80 91 46 3e 	lds	r24, 0x3E46
     a5c:	80 95       	com	r24
     a5e:	c8 23       	and	r28, r24
     a60:	c0 93 46 3e 	sts	0x3E46, r28
	
	SPIBuffer[0] = PS_WRITE;
     a64:	80 e4       	ldi	r24, 0x40	; 64
     a66:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     a6a:	81 e0       	ldi	r24, 0x01	; 1
     a6c:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = ~bankB_DIR;
     a70:	80 91 46 3e 	lds	r24, 0x3E46
     a74:	80 95       	com	r24
     a76:	80 93 22 3e 	sts	0x3E22, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     a7e:	20 e2       	ldi	r18, 0x20	; 32
     a80:	3e e3       	ldi	r19, 0x3E	; 62
     a82:	a0 ec       	ldi	r26, 0xC0	; 192
     a84:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     a86:	cc e2       	ldi	r28, 0x2C	; 44
     a88:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     a8a:	f9 01       	movw	r30, r18
     a8c:	e8 0f       	add	r30, r24
     a8e:	f9 1f       	adc	r31, r25
     a90:	40 81       	ld	r20, Z
     a92:	13 96       	adiw	r26, 0x03	; 3
     a94:	4c 93       	st	X, r20
     a96:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     a98:	12 96       	adiw	r26, 0x02	; 2
     a9a:	4c 91       	ld	r20, X
     a9c:	12 97       	sbiw	r26, 0x02	; 2
     a9e:	44 23       	and	r20, r20
     aa0:	dc f7       	brge	.-10     	; 0xa98 <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
     aa2:	13 96       	adiw	r26, 0x03	; 3
     aa4:	4c 91       	ld	r20, X
     aa6:	13 97       	sbiw	r26, 0x03	; 3
     aa8:	48 83       	st	Y, r20
     aaa:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     aac:	83 30       	cpi	r24, 0x03	; 3
     aae:	91 05       	cpc	r25, r1
     ab0:	61 f7       	brne	.-40     	; 0xa8a <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     ab2:	80 e0       	ldi	r24, 0x00	; 0
     ab4:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(FALSE);
     ab8:	80 e0       	ldi	r24, 0x00	; 0
     aba:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	SPIDisable();
     abe:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
}
     ac2:	df 91       	pop	r29
     ac4:	cf 91       	pop	r28
     ac6:	08 95       	ret

00000ac8 <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     ac8:	cf 93       	push	r28
     aca:	df 93       	push	r29
     acc:	c8 2f       	mov	r28, r24
     ace:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
     ad0:	80 e0       	ldi	r24, 0x00	; 0
     ad2:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
     ad6:	81 e0       	ldi	r24, 0x01	; 1
     ad8:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	portExCS(TRUE);
     adc:	81 e0       	ldi	r24, 0x01	; 1
     ade:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
     ae2:	dd 23       	and	r29, r29
     ae4:	81 f0       	breq	.+32     	; 0xb06 <PortEx_DIRSET+0x3e>
     ae6:	80 91 2f 3e 	lds	r24, 0x3E2F
     aea:	c8 2b       	or	r28, r24
     aec:	c0 93 2f 3e 	sts	0x3E2F, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     af0:	80 e4       	ldi	r24, 0x40	; 64
     af2:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     af6:	10 92 21 3e 	sts	0x3E21, r1
		SPIBuffer[2] = ~bankA_DIR; 
     afa:	80 91 2f 3e 	lds	r24, 0x3E2F
     afe:	80 95       	com	r24
     b00:	80 93 22 3e 	sts	0x3E22, r24
     b04:	10 c0       	rjmp	.+32     	; 0xb26 <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
     b06:	80 91 46 3e 	lds	r24, 0x3E46
     b0a:	c8 2b       	or	r28, r24
     b0c:	c0 93 46 3e 	sts	0x3E46, r28
	
	SPIBuffer[0] = PS_WRITE;
     b10:	80 e4       	ldi	r24, 0x40	; 64
     b12:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     b16:	81 e0       	ldi	r24, 0x01	; 1
     b18:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = ~bankB_DIR;
     b1c:	80 91 46 3e 	lds	r24, 0x3E46
     b20:	80 95       	com	r24
     b22:	80 93 22 3e 	sts	0x3E22, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     b26:	80 e0       	ldi	r24, 0x00	; 0
     b28:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     b2a:	20 e2       	ldi	r18, 0x20	; 32
     b2c:	3e e3       	ldi	r19, 0x3E	; 62
     b2e:	a0 ec       	ldi	r26, 0xC0	; 192
     b30:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     b32:	cc e2       	ldi	r28, 0x2C	; 44
     b34:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     b36:	f9 01       	movw	r30, r18
     b38:	e8 0f       	add	r30, r24
     b3a:	f9 1f       	adc	r31, r25
     b3c:	40 81       	ld	r20, Z
     b3e:	13 96       	adiw	r26, 0x03	; 3
     b40:	4c 93       	st	X, r20
     b42:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
     b44:	12 96       	adiw	r26, 0x02	; 2
     b46:	4c 91       	ld	r20, X
     b48:	12 97       	sbiw	r26, 0x02	; 2
     b4a:	44 23       	and	r20, r20
     b4c:	dc f7       	brge	.-10     	; 0xb44 <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     b4e:	13 96       	adiw	r26, 0x03	; 3
     b50:	4c 91       	ld	r20, X
     b52:	13 97       	sbiw	r26, 0x03	; 3
     b54:	48 83       	st	Y, r20
     b56:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     b58:	83 30       	cpi	r24, 0x03	; 3
     b5a:	91 05       	cpc	r25, r1
     b5c:	61 f7       	brne	.-40     	; 0xb36 <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
     b5e:	80 e0       	ldi	r24, 0x00	; 0
     b60:	0e 94 51 03 	call	0x6a2	; 0x6a2 <portExCS>
	SPICS(FALSE);
     b64:	80 e0       	ldi	r24, 0x00	; 0
     b66:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
     b6a:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>


}
     b6e:	df 91       	pop	r29
     b70:	cf 91       	pop	r28
     b72:	08 95       	ret

00000b74 <ADCPower>:
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
	else PORTC.OUTSET = PIN1_bm;
}

void ADCPower(uint8_t on) {
     b74:	0f 93       	push	r16
     b76:	1f 93       	push	r17
     b78:	cf 93       	push	r28
     b7a:	df 93       	push	r29
	
	if (on && !ADC_POWER_ON) {
     b7c:	88 23       	and	r24, r24
     b7e:	09 f4       	brne	.+2      	; 0xb82 <ADCPower+0xe>
     b80:	4e c0       	rjmp	.+156    	; 0xc1e <ADCPower+0xaa>
     b82:	80 91 32 3e 	lds	r24, 0x3E32
     b86:	88 23       	and	r24, r24
     b88:	09 f0       	breq	.+2      	; 0xb8c <ADCPower+0x18>
     b8a:	81 c0       	rjmp	.+258    	; 0xc8e <ADCPower+0x11a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     b8c:	00 e0       	ldi	r16, 0x00	; 0
     b8e:	16 e0       	ldi	r17, 0x06	; 6
     b90:	8e ed       	ldi	r24, 0xDE	; 222
     b92:	d8 01       	movw	r26, r16
     b94:	11 96       	adiw	r26, 0x01	; 1
     b96:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     b98:	c0 e2       	ldi	r28, 0x20	; 32
     b9a:	d6 e0       	ldi	r29, 0x06	; 6
     b9c:	4e e0       	ldi	r20, 0x0E	; 14
     b9e:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     ba0:	e0 e4       	ldi	r30, 0x40	; 64
     ba2:	f6 e0       	ldi	r31, 0x06	; 6
     ba4:	63 e0       	ldi	r22, 0x03	; 3
     ba6:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     ba8:	80 e8       	ldi	r24, 0x80	; 128
     baa:	96 e0       	ldi	r25, 0x06	; 6
     bac:	50 e1       	ldi	r21, 0x10	; 16
     bae:	dc 01       	movw	r26, r24
     bb0:	11 96       	adiw	r26, 0x01	; 1
     bb2:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     bb4:	20 ea       	ldi	r18, 0xA0	; 160
     bb6:	36 e0       	ldi	r19, 0x06	; 6
     bb8:	d9 01       	movw	r26, r18
     bba:	11 96       	adiw	r26, 0x01	; 1
     bbc:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm; // portEx-CS
     bbe:	7e e9       	ldi	r23, 0x9E	; 158
     bc0:	d8 01       	movw	r26, r16
     bc2:	15 96       	adiw	r26, 0x05	; 5
     bc4:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     bc6:	78 e0       	ldi	r23, 0x08	; 8
     bc8:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     bca:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     bcc:	ec 01       	movw	r28, r24
     bce:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     bd0:	d9 01       	movw	r26, r18
     bd2:	15 96       	adiw	r26, 0x05	; 5
     bd4:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
     bd6:	10 92 30 3e 	sts	0x3E30, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     bda:	8f ef       	ldi	r24, 0xFF	; 255
     bdc:	93 ec       	ldi	r25, 0xC3	; 195
     bde:	a9 e0       	ldi	r26, 0x09	; 9
     be0:	81 50       	subi	r24, 0x01	; 1
     be2:	90 40       	sbci	r25, 0x00	; 0
     be4:	a0 40       	sbci	r26, 0x00	; 0
     be6:	e1 f7       	brne	.-8      	; 0xbe0 <ADCPower+0x6c>
     be8:	00 c0       	rjmp	.+0      	; 0xbea <ADCPower+0x76>
     bea:	00 00       	nop
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     bec:	80 e4       	ldi	r24, 0x40	; 64
     bee:	82 83       	std	Z+2, r24	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     bf0:	10 92 31 3e 	sts	0x3E31, r1
     bf4:	10 92 46 3e 	sts	0x3E46, r1
     bf8:	10 92 ab 21 	sts	0x21AB, r1
     bfc:	10 92 2f 3e 	sts	0x3E2F, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
     c00:	8f ef       	ldi	r24, 0xFF	; 255
     c02:	61 e0       	ldi	r22, 0x01	; 1
     c04:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     c08:	8f ef       	ldi	r24, 0xFF	; 255
     c0a:	61 e0       	ldi	r22, 0x01	; 1
     c0c:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     c10:	8f ef       	ldi	r24, 0xFF	; 255
     c12:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>
		ADC_POWER_ON = TRUE;
     c16:	81 e0       	ldi	r24, 0x01	; 1
     c18:	80 93 32 3e 	sts	0x3E32, r24
     c1c:	38 c0       	rjmp	.+112    	; 0xc8e <ADCPower+0x11a>

	} else if(!on && ADC_POWER_ON) {
     c1e:	80 91 32 3e 	lds	r24, 0x3E32
     c22:	88 23       	and	r24, r24
     c24:	a1 f1       	breq	.+104    	; 0xc8e <ADCPower+0x11a>
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     c26:	00 e0       	ldi	r16, 0x00	; 0
     c28:	16 e0       	ldi	r17, 0x06	; 6
     c2a:	7e ed       	ldi	r23, 0xDE	; 222
     c2c:	d8 01       	movw	r26, r16
     c2e:	16 96       	adiw	r26, 0x06	; 6
     c30:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     c32:	a0 e2       	ldi	r26, 0x20	; 32
     c34:	b6 e0       	ldi	r27, 0x06	; 6
     c36:	4e e0       	ldi	r20, 0x0E	; 14
     c38:	16 96       	adiw	r26, 0x06	; 6
     c3a:	4c 93       	st	X, r20
     c3c:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     c3e:	20 e4       	ldi	r18, 0x40	; 64
     c40:	36 e0       	ldi	r19, 0x06	; 6
     c42:	63 e0       	ldi	r22, 0x03	; 3
     c44:	e9 01       	movw	r28, r18
     c46:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     c48:	c0 e8       	ldi	r28, 0x80	; 128
     c4a:	d6 e0       	ldi	r29, 0x06	; 6
     c4c:	50 e1       	ldi	r21, 0x10	; 16
     c4e:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     c50:	80 ea       	ldi	r24, 0xA0	; 160
     c52:	96 e0       	ldi	r25, 0x06	; 6
     c54:	fc 01       	movw	r30, r24
     c56:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     c58:	f8 01       	movw	r30, r16
     c5a:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     c5c:	12 96       	adiw	r26, 0x02	; 2
     c5e:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     c60:	d9 01       	movw	r26, r18
     c62:	12 96       	adiw	r26, 0x02	; 2
     c64:	6c 93       	st	X, r22
     c66:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
     c68:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     c6a:	ec 01       	movw	r28, r24
     c6c:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     c6e:	80 e4       	ldi	r24, 0x40	; 64
     c70:	12 96       	adiw	r26, 0x02	; 2
     c72:	8c 93       	st	X, r24
     c74:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     c76:	10 92 31 3e 	sts	0x3E31, r1
     c7a:	10 92 46 3e 	sts	0x3E46, r1
     c7e:	10 92 ab 21 	sts	0x21AB, r1
     c82:	10 92 2f 3e 	sts	0x3E2F, r1
		channelStatus = 0x00;
     c86:	10 92 30 3e 	sts	0x3E30, r1
		ADC_POWER_ON = FALSE;
     c8a:	10 92 32 3e 	sts	0x3E32, r1
	}
}
     c8e:	df 91       	pop	r29
     c90:	cf 91       	pop	r28
     c92:	1f 91       	pop	r17
     c94:	0f 91       	pop	r16
     c96:	08 95       	ret

00000c98 <DeciToString>:
	PORTC.OUTCLR = PIN4_bm;
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;

}

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
     c98:	2f 92       	push	r2
     c9a:	3f 92       	push	r3
     c9c:	4f 92       	push	r4
     c9e:	5f 92       	push	r5
     ca0:	6f 92       	push	r6
     ca2:	7f 92       	push	r7
     ca4:	8f 92       	push	r8
     ca6:	9f 92       	push	r9
     ca8:	af 92       	push	r10
     caa:	bf 92       	push	r11
     cac:	cf 92       	push	r12
     cae:	df 92       	push	r13
     cb0:	ef 92       	push	r14
     cb2:	ff 92       	push	r15
     cb4:	0f 93       	push	r16
     cb6:	1f 93       	push	r17
     cb8:	cf 93       	push	r28
     cba:	df 93       	push	r29
     cbc:	cd b7       	in	r28, 0x3d	; 61
     cbe:	de b7       	in	r29, 0x3e	; 62
     cc0:	64 97       	sbiw	r28, 0x14	; 20
     cc2:	cd bf       	out	0x3d, r28	; 61
     cc4:	de bf       	out	0x3e, r29	; 62
     cc6:	2a 01       	movw	r4, r20
     cc8:	3b 01       	movw	r6, r22
     cca:	89 01       	movw	r16, r18
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
     ccc:	f9 01       	movw	r30, r18
     cce:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
     cd0:	41 15       	cp	r20, r1
     cd2:	51 05       	cpc	r21, r1
     cd4:	61 05       	cpc	r22, r1
     cd6:	71 05       	cpc	r23, r1
     cd8:	09 f4       	brne	.+2      	; 0xcdc <DeciToString+0x44>
     cda:	4d c0       	rjmp	.+154    	; 0xd76 <DeciToString+0xde>
     cdc:	88 2e       	mov	r8, r24
     cde:	99 2e       	mov	r9, r25
     ce0:	cc 24       	eor	r12, r12
     ce2:	dd 24       	eor	r13, r13
     ce4:	76 01       	movw	r14, r12
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
     ce6:	5e 01       	movw	r10, r28
     ce8:	08 94       	sec
     cea:	a1 1c       	adc	r10, r1
     cec:	b1 1c       	adc	r11, r1
     cee:	0f 2e       	mov	r0, r31
     cf0:	f0 e0       	ldi	r31, 0x00	; 0
     cf2:	2f 2e       	mov	r2, r31
     cf4:	f0 e2       	ldi	r31, 0x20	; 32
     cf6:	3f 2e       	mov	r3, r31
     cf8:	f0 2d       	mov	r31, r0
     cfa:	f4 01       	movw	r30, r8
     cfc:	81 91       	ld	r24, Z+
     cfe:	91 91       	ld	r25, Z+
     d00:	a1 91       	ld	r26, Z+
     d02:	b1 91       	ld	r27, Z+
     d04:	4f 01       	movw	r8, r30
     d06:	2d b7       	in	r18, 0x3d	; 61
     d08:	3e b7       	in	r19, 0x3e	; 62
     d0a:	28 50       	subi	r18, 0x08	; 8
     d0c:	30 40       	sbci	r19, 0x00	; 0
     d0e:	2d bf       	out	0x3d, r18	; 61
     d10:	3e bf       	out	0x3e, r19	; 62
     d12:	2f 5f       	subi	r18, 0xFF	; 255
     d14:	3f 4f       	sbci	r19, 0xFF	; 255
     d16:	ed b7       	in	r30, 0x3d	; 61
     d18:	fe b7       	in	r31, 0x3e	; 62
     d1a:	a1 82       	std	Z+1, r10	; 0x01
     d1c:	b2 82       	std	Z+2, r11	; 0x02
     d1e:	f9 01       	movw	r30, r18
     d20:	22 82       	std	Z+2, r2	; 0x02
     d22:	33 82       	std	Z+3, r3	; 0x03
     d24:	84 83       	std	Z+4, r24	; 0x04
     d26:	95 83       	std	Z+5, r25	; 0x05
     d28:	a6 83       	std	Z+6, r26	; 0x06
     d2a:	b7 83       	std	Z+7, r27	; 0x07
     d2c:	0e 94 30 3a 	call	0x7460	; 0x7460 <sprintf>
		strcat(ReturnString,b);
     d30:	2d b7       	in	r18, 0x3d	; 61
     d32:	3e b7       	in	r19, 0x3e	; 62
     d34:	28 5f       	subi	r18, 0xF8	; 248
     d36:	3f 4f       	sbci	r19, 0xFF	; 255
     d38:	2d bf       	out	0x3d, r18	; 61
     d3a:	3e bf       	out	0x3e, r19	; 62
     d3c:	c8 01       	movw	r24, r16
     d3e:	b5 01       	movw	r22, r10
     d40:	0e 94 f2 39 	call	0x73e4	; 0x73e4 <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
     d44:	a0 2f       	mov	r26, r16
     d46:	b1 2f       	mov	r27, r17
     d48:	fd 01       	movw	r30, r26
     d4a:	01 90       	ld	r0, Z+
     d4c:	00 20       	and	r0, r0
     d4e:	e9 f7       	brne	.-6      	; 0xd4a <DeciToString+0xb2>
     d50:	31 97       	sbiw	r30, 0x01	; 1
     d52:	ea 1b       	sub	r30, r26
     d54:	fb 0b       	sbc	r31, r27
     d56:	e0 0f       	add	r30, r16
     d58:	f1 1f       	adc	r31, r17
     d5a:	8a e0       	ldi	r24, 0x0A	; 10
     d5c:	90 e0       	ldi	r25, 0x00	; 0
     d5e:	80 83       	st	Z, r24
     d60:	91 83       	std	Z+1, r25	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
     d62:	08 94       	sec
     d64:	c1 1c       	adc	r12, r1
     d66:	d1 1c       	adc	r13, r1
     d68:	e1 1c       	adc	r14, r1
     d6a:	f1 1c       	adc	r15, r1
     d6c:	c4 14       	cp	r12, r4
     d6e:	d5 04       	cpc	r13, r5
     d70:	e6 04       	cpc	r14, r6
     d72:	f7 04       	cpc	r15, r7
     d74:	11 f6       	brne	.-124    	; 0xcfa <DeciToString+0x62>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}
}
     d76:	64 96       	adiw	r28, 0x14	; 20
     d78:	cd bf       	out	0x3d, r28	; 61
     d7a:	de bf       	out	0x3e, r29	; 62
     d7c:	df 91       	pop	r29
     d7e:	cf 91       	pop	r28
     d80:	1f 91       	pop	r17
     d82:	0f 91       	pop	r16
     d84:	ff 90       	pop	r15
     d86:	ef 90       	pop	r14
     d88:	df 90       	pop	r13
     d8a:	cf 90       	pop	r12
     d8c:	bf 90       	pop	r11
     d8e:	af 90       	pop	r10
     d90:	9f 90       	pop	r9
     d92:	8f 90       	pop	r8
     d94:	7f 90       	pop	r7
     d96:	6f 90       	pop	r6
     d98:	5f 90       	pop	r5
     d9a:	4f 90       	pop	r4
     d9c:	3f 90       	pop	r3
     d9e:	2f 90       	pop	r2
     da0:	08 95       	ret

00000da2 <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
     da2:	e0 ec       	ldi	r30, 0xC0	; 192
     da4:	f8 e0       	ldi	r31, 0x08	; 8
     da6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
     da8:	82 81       	ldd	r24, Z+2	; 0x02
     daa:	88 23       	and	r24, r24
     dac:	ec f7       	brge	.-6      	; 0xda8 <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
     dae:	e0 ec       	ldi	r30, 0xC0	; 192
     db0:	f8 e0       	ldi	r31, 0x08	; 8
     db2:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
     db4:	08 95       	ret

00000db6 <main>:
 * Created: 9/22/2013 7:28:35 PM
 *  Author: Vlad
 */ 
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     db6:	cf 93       	push	r28
     db8:	df 93       	push	r29
     dba:	cd b7       	in	r28, 0x3d	; 61
     dbc:	de b7       	in	r29, 0x3e	; 62
     dbe:	a0 97       	sbiw	r28, 0x20	; 32
     dc0:	cd bf       	out	0x3d, r28	; 61
     dc2:	de bf       	out	0x3e, r29	; 62
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t ack = 0;
     dc4:	19 82       	std	Y+1, r1	; 0x01
     dc6:	1a 82       	std	Y+2, r1	; 0x02
	volatile uint8_t RawGain;
	uint16_t freq = 2000;
	volatile uint32_t samples = 0;
     dc8:	1c 82       	std	Y+4, r1	; 0x04
     dca:	1d 82       	std	Y+5, r1	; 0x05
     dcc:	1e 82       	std	Y+6, r1	; 0x06
     dce:	1f 82       	std	Y+7, r1	; 0x07
	DataAvailable = 0;
     dd0:	10 92 47 3e 	sts	0x3E47, r1
	ADC_Sampling_Finished = 1;
     dd4:	81 e0       	ldi	r24, 0x01	; 1
     dd6:	80 93 a6 50 	sts	0x50A6, r24
	uint8_t RadioMessageBuffer[20];
	unsigned char ofile[] = {'o','u','t','p','u','t'};
	set_32MHz();
     dda:	0e 94 3c 03 	call	0x678	; 0x678 <set_32MHz>
	chb_init();
     dde:	0e 94 fd 19 	call	0x33fa	; 0x33fa <chb_init>
	chb_set_channel(1);
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <chb_set_channel>
	chb_set_short_addr(0x0001);
     de8:	81 e0       	ldi	r24, 0x01	; 1
     dea:	90 e0       	ldi	r25, 0x00	; 0
     dec:	0e 94 20 1c 	call	0x3840	; 0x3840 <chb_set_short_addr>
	pcb_t* pcb = chb_get_pcb();
     df0:	0e 94 1e 1a 	call	0x343c	; 0x343c <chb_get_pcb>
     df4:	1c 01       	movw	r2, r24
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
	uint16_t ack = 0;
	volatile uint8_t RawGain;
	uint16_t freq = 2000;
     df6:	80 ed       	ldi	r24, 0xD0	; 208
     df8:	97 e0       	ldi	r25, 0x07	; 7
     dfa:	8e 8f       	std	Y+30, r24	; 0x1e
     dfc:	9f 8f       	std	Y+31, r25	; 0x1f
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
	
	uint8_t length;
	uint8_t gain = GAIN_1_gc;
     dfe:	18 a2       	lds	r17, 0x98
				case 'T':
					if(ADC_Sampling_Finished && DataAvailable){
						//get number of data points collected
						samples = ADC_Get_Num_Samples();
						if(samples > 0){	
							uint16_t NumMessages = ((samples*4)/CHB_MAX_PAYLOAD);
     e00:	0f 2e       	mov	r0, r31
     e02:	f4 e6       	ldi	r31, 0x64	; 100
     e04:	4f 2e       	mov	r4, r31
     e06:	f0 e0       	ldi	r31, 0x00	; 0
     e08:	5f 2e       	mov	r5, r31
     e0a:	f0 e0       	ldi	r31, 0x00	; 0
     e0c:	6f 2e       	mov	r6, r31
     e0e:	f0 e0       	ldi	r31, 0x00	; 0
     e10:	7f 2e       	mov	r7, r31
     e12:	f0 2d       	mov	r31, r0
	chb_set_short_addr(0x0001);
	pcb_t* pcb = chb_get_pcb();
	//SD_init();
	//getBootSectorData();
	while(1){
		if(pcb->data_rcv){
     e14:	d1 01       	movw	r26, r2
     e16:	13 96       	adiw	r26, 0x03	; 3
     e18:	8c 91       	ld	r24, X
     e1a:	13 97       	sbiw	r26, 0x03	; 3
     e1c:	88 23       	and	r24, r24
     e1e:	d1 f3       	breq	.-12     	; 0xe14 <main+0x5e>
			//read the data
			length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
     e20:	ce 01       	movw	r24, r28
     e22:	08 96       	adiw	r24, 0x08	; 8
     e24:	0e 94 c1 1a 	call	0x3582	; 0x3582 <chb_read>
			//length should be >1 for setting gain/freq commands: the value is likely sent in a separate message
				switch ( RadioMessageBuffer[0])
     e28:	88 85       	ldd	r24, Y+8	; 0x08
     e2a:	82 35       	cpi	r24, 0x52	; 82
     e2c:	71 f0       	breq	.+28     	; 0xe4a <main+0x94>
     e2e:	83 35       	cpi	r24, 0x53	; 83
     e30:	30 f4       	brcc	.+12     	; 0xe3e <main+0x88>
     e32:	86 34       	cpi	r24, 0x46	; 70
     e34:	09 f4       	brne	.+2      	; 0xe38 <main+0x82>
     e36:	8a c0       	rjmp	.+276    	; 0xf4c <main+0x196>
     e38:	87 34       	cpi	r24, 0x47	; 71
     e3a:	61 f7       	brne	.-40     	; 0xe14 <main+0x5e>
     e3c:	4b c0       	rjmp	.+150    	; 0xed4 <main+0x11e>
     e3e:	83 35       	cpi	r24, 0x53	; 83
     e40:	09 f4       	brne	.+2      	; 0xe44 <main+0x8e>
     e42:	94 c0       	rjmp	.+296    	; 0xf6c <main+0x1b6>
     e44:	84 35       	cpi	r24, 0x54	; 84
     e46:	31 f7       	brne	.-52     	; 0xe14 <main+0x5e>
     e48:	a3 c0       	rjmp	.+326    	; 0xf90 <main+0x1da>
				{
				case 'R':
					//collect data if the ADC is not collecting any data right now
					if(ADC_Sampling_Finished){
     e4a:	80 91 a6 50 	lds	r24, 0x50A6
     e4e:	88 23       	and	r24, r24
     e50:	a9 f1       	breq	.+106    	; 0xebc <main+0x106>
						//CO_collectADC(ADC_CH_1_gc, gain, freq, 10000, (int32_t*)FRAMReadBuffer, FR_READ_BUFFER_SIZE/4, TRUE);
						CO_collectSeismic1Channel(ADC_CH_8_gc, gain, freq, 6, FALSE, 1, 2, 3, 4, 10000,(int32_t*)FRAMReadBuffer, FR_READ_BUFFER_SIZE/4, TRUE);
     e52:	ed b7       	in	r30, 0x3d	; 61
     e54:	fe b7       	in	r31, 0x3e	; 62
     e56:	37 97       	sbiw	r30, 0x07	; 7
     e58:	ed bf       	out	0x3d, r30	; 61
     e5a:	fe bf       	out	0x3e, r31	; 62
     e5c:	31 96       	adiw	r30, 0x01	; 1
     e5e:	80 e1       	ldi	r24, 0x10	; 16
     e60:	97 e2       	ldi	r25, 0x27	; 39
     e62:	ad b7       	in	r26, 0x3d	; 61
     e64:	be b7       	in	r27, 0x3e	; 62
     e66:	11 96       	adiw	r26, 0x01	; 1
     e68:	8d 93       	st	X+, r24
     e6a:	9c 93       	st	X, r25
     e6c:	12 97       	sbiw	r26, 0x02	; 2
     e6e:	ac ea       	ldi	r26, 0xAC	; 172
     e70:	b1 e2       	ldi	r27, 0x21	; 33
     e72:	a2 83       	std	Z+2, r26	; 0x02
     e74:	b3 83       	std	Z+3, r27	; 0x03
     e76:	8c e1       	ldi	r24, 0x1C	; 28
     e78:	97 e0       	ldi	r25, 0x07	; 7
     e7a:	84 83       	std	Z+4, r24	; 0x04
     e7c:	95 83       	std	Z+5, r25	; 0x05
     e7e:	91 e0       	ldi	r25, 0x01	; 1
     e80:	96 83       	std	Z+6, r25	; 0x06
     e82:	87 e0       	ldi	r24, 0x07	; 7
     e84:	68 a1       	lds	r22, 0x48
     e86:	4e 8d       	ldd	r20, Y+30	; 0x1e
     e88:	5f 8d       	ldd	r21, Y+31	; 0x1f
     e8a:	26 e0       	ldi	r18, 0x06	; 6
     e8c:	00 e0       	ldi	r16, 0x00	; 0
     e8e:	ee 24       	eor	r14, r14
     e90:	ff 24       	eor	r15, r15
     e92:	e3 94       	inc	r14
     e94:	cc 24       	eor	r12, r12
     e96:	dd 24       	eor	r13, r13
     e98:	68 94       	set
     e9a:	c1 f8       	bld	r12, 1
     e9c:	0f 2e       	mov	r0, r31
     e9e:	f3 e0       	ldi	r31, 0x03	; 3
     ea0:	af 2e       	mov	r10, r31
     ea2:	bb 24       	eor	r11, r11
     ea4:	f0 2d       	mov	r31, r0
     ea6:	88 24       	eor	r8, r8
     ea8:	99 24       	eor	r9, r9
     eaa:	68 94       	set
     eac:	82 f8       	bld	r8, 2
     eae:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <CO_collectSeismic1Channel>
     eb2:	ad b7       	in	r26, 0x3d	; 61
     eb4:	be b7       	in	r27, 0x3e	; 62
     eb6:	17 96       	adiw	r26, 0x07	; 7
     eb8:	ad bf       	out	0x3d, r26	; 61
     eba:	be bf       	out	0x3e, r27	; 62
					}
					//send acknowledgment
					chb_write(0x0000,&ack,2);						
     ebc:	80 e0       	ldi	r24, 0x00	; 0
     ebe:	90 e0       	ldi	r25, 0x00	; 0
     ec0:	be 01       	movw	r22, r28
     ec2:	6f 5f       	subi	r22, 0xFF	; 255
     ec4:	7f 4f       	sbci	r23, 0xFF	; 255
     ec6:	22 e0       	ldi	r18, 0x02	; 2
     ec8:	30 e0       	ldi	r19, 0x00	; 0
     eca:	40 e0       	ldi	r20, 0x00	; 0
     ecc:	50 e0       	ldi	r21, 0x00	; 0
     ece:	0e 94 21 1a 	call	0x3442	; 0x3442 <chb_write>
					break;
     ed2:	a0 cf       	rjmp	.-192    	; 0xe14 <main+0x5e>
				case 'G':
					//while(!pcb->data_rcv);
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set gain to what is specified
					RawGain = (uint8_t)(*(int32_t*)(RadioMessageBuffer+1));
     ed4:	89 85       	ldd	r24, Y+9	; 0x09
     ed6:	8b 83       	std	Y+3, r24	; 0x03
					switch(RawGain){
     ed8:	8b 81       	ldd	r24, Y+3	; 0x03
     eda:	88 30       	cpi	r24, 0x08	; 8
     edc:	d9 f0       	breq	.+54     	; 0xf14 <main+0x15e>
     ede:	89 30       	cpi	r24, 0x09	; 9
     ee0:	38 f4       	brcc	.+14     	; 0xef0 <main+0x13a>
     ee2:	82 30       	cpi	r24, 0x02	; 2
     ee4:	89 f0       	breq	.+34     	; 0xf08 <main+0x152>
     ee6:	84 30       	cpi	r24, 0x04	; 4
     ee8:	91 f0       	breq	.+36     	; 0xf0e <main+0x158>
     eea:	81 30       	cpi	r24, 0x01	; 1
     eec:	19 f5       	brne	.+70     	; 0xf34 <main+0x17e>
     eee:	21 c0       	rjmp	.+66     	; 0xf32 <main+0x17c>
     ef0:	80 32       	cpi	r24, 0x20	; 32
     ef2:	b1 f0       	breq	.+44     	; 0xf20 <main+0x16a>
     ef4:	81 32       	cpi	r24, 0x21	; 33
     ef6:	18 f4       	brcc	.+6      	; 0xefe <main+0x148>
     ef8:	80 31       	cpi	r24, 0x10	; 16
     efa:	e1 f4       	brne	.+56     	; 0xf34 <main+0x17e>
     efc:	0e c0       	rjmp	.+28     	; 0xf1a <main+0x164>
     efe:	80 34       	cpi	r24, 0x40	; 64
     f00:	91 f0       	breq	.+36     	; 0xf26 <main+0x170>
     f02:	80 38       	cpi	r24, 0x80	; 128
     f04:	b9 f4       	brne	.+46     	; 0xf34 <main+0x17e>
     f06:	12 c0       	rjmp	.+36     	; 0xf2c <main+0x176>
						case 1:
							gain = GAIN_1_gc;
							break;
						case 2:
							gain = GAIN_2_gc;
     f08:	b1 e0       	ldi	r27, 0x01	; 1
     f0a:	b8 a3       	lds	r27, 0x58
							break;
     f0c:	13 c0       	rjmp	.+38     	; 0xf34 <main+0x17e>
						case 4:
							gain = GAIN_4_gc;
     f0e:	e2 e0       	ldi	r30, 0x02	; 2
     f10:	e8 a3       	lds	r30, 0x58
							break;
     f12:	10 c0       	rjmp	.+32     	; 0xf34 <main+0x17e>
						case 8:
							gain = GAIN_8_gc;
     f14:	f3 e0       	ldi	r31, 0x03	; 3
     f16:	f8 a3       	lds	r31, 0x58
							break;
     f18:	0d c0       	rjmp	.+26     	; 0xf34 <main+0x17e>
						case 16:
							gain = GAIN_16_gc;
     f1a:	24 e0       	ldi	r18, 0x04	; 4
     f1c:	28 a3       	lds	r18, 0x58
							break;
     f1e:	0a c0       	rjmp	.+20     	; 0xf34 <main+0x17e>
						case 32:
							gain = GAIN_32_gc;
     f20:	85 e0       	ldi	r24, 0x05	; 5
     f22:	88 a3       	lds	r24, 0x58
							break;
     f24:	07 c0       	rjmp	.+14     	; 0xf34 <main+0x17e>
						case 64:
							gain = GAIN_64_gc;
     f26:	96 e0       	ldi	r25, 0x06	; 6
     f28:	98 a3       	lds	r25, 0x58
							break;
     f2a:	04 c0       	rjmp	.+8      	; 0xf34 <main+0x17e>
						case 128:
							gain = GAIN_128_gc;
     f2c:	a7 e0       	ldi	r26, 0x07	; 7
     f2e:	a8 a3       	lds	r26, 0x58
							break;
     f30:	01 c0       	rjmp	.+2      	; 0xf34 <main+0x17e>
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set gain to what is specified
					RawGain = (uint8_t)(*(int32_t*)(RadioMessageBuffer+1));
					switch(RawGain){
						case 1:
							gain = GAIN_1_gc;
     f32:	18 a2       	lds	r17, 0x98
						default:
							//chb_write(0x0000,(uint8_t*)"invalid gain",strlen("invalid gain"));
							break;
					}
					//send acknowledgment
					chb_write(0x0000,&ack,2);					
     f34:	80 e0       	ldi	r24, 0x00	; 0
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	be 01       	movw	r22, r28
     f3a:	6f 5f       	subi	r22, 0xFF	; 255
     f3c:	7f 4f       	sbci	r23, 0xFF	; 255
     f3e:	22 e0       	ldi	r18, 0x02	; 2
     f40:	30 e0       	ldi	r19, 0x00	; 0
     f42:	40 e0       	ldi	r20, 0x00	; 0
     f44:	50 e0       	ldi	r21, 0x00	; 0
     f46:	0e 94 21 1a 	call	0x3442	; 0x3442 <chb_write>
					break;
     f4a:	64 cf       	rjmp	.-312    	; 0xe14 <main+0x5e>
				case 'F':

					//while(!pcb->data_rcv);
					//length = chb_read((chb_rx_data_t*)RadioMessageBuffer);
					//set sampling frequency to what is specified
					freq = (uint16_t)(*(int32_t*)(RadioMessageBuffer+1));
     f4c:	e9 85       	ldd	r30, Y+9	; 0x09
     f4e:	fa 85       	ldd	r31, Y+10	; 0x0a
     f50:	ee 8f       	std	Y+30, r30	; 0x1e
     f52:	ff 8f       	std	Y+31, r31	; 0x1f
					//send acknowledgment
					chb_write(0x0000,&ack,2);
     f54:	80 e0       	ldi	r24, 0x00	; 0
     f56:	90 e0       	ldi	r25, 0x00	; 0
     f58:	be 01       	movw	r22, r28
     f5a:	6f 5f       	subi	r22, 0xFF	; 255
     f5c:	7f 4f       	sbci	r23, 0xFF	; 255
     f5e:	22 e0       	ldi	r18, 0x02	; 2
     f60:	30 e0       	ldi	r19, 0x00	; 0
     f62:	40 e0       	ldi	r20, 0x00	; 0
     f64:	50 e0       	ldi	r21, 0x00	; 0
     f66:	0e 94 21 1a 	call	0x3442	; 0x3442 <chb_write>
					break;
     f6a:	54 cf       	rjmp	.-344    	; 0xe14 <main+0x5e>
				case 'S':
					//stop the ADC if it is not already
					if(!ADC_Sampling_Finished){
     f6c:	80 91 a6 50 	lds	r24, 0x50A6
     f70:	88 23       	and	r24, r24
     f72:	11 f4       	brne	.+4      	; 0xf78 <main+0x1c2>
						ADC_Stop_Sampling();
     f74:	0e 94 ac 0c 	call	0x1958	; 0x1958 <ADC_Stop_Sampling>
					}
					//otherwise, the ADC has finished sampling on its own and the data is ready to be transmitted
					//send acknowledgment
					chb_write(0x0000,&ack,2);
     f78:	80 e0       	ldi	r24, 0x00	; 0
     f7a:	90 e0       	ldi	r25, 0x00	; 0
     f7c:	be 01       	movw	r22, r28
     f7e:	6f 5f       	subi	r22, 0xFF	; 255
     f80:	7f 4f       	sbci	r23, 0xFF	; 255
     f82:	22 e0       	ldi	r18, 0x02	; 2
     f84:	30 e0       	ldi	r19, 0x00	; 0
     f86:	40 e0       	ldi	r20, 0x00	; 0
     f88:	50 e0       	ldi	r21, 0x00	; 0
     f8a:	0e 94 21 1a 	call	0x3442	; 0x3442 <chb_write>
					break;
     f8e:	42 cf       	rjmp	.-380    	; 0xe14 <main+0x5e>
				case 'T':
					if(ADC_Sampling_Finished && DataAvailable){
     f90:	80 91 a6 50 	lds	r24, 0x50A6
     f94:	88 23       	and	r24, r24
     f96:	09 f4       	brne	.+2      	; 0xf9a <main+0x1e4>
     f98:	3d cf       	rjmp	.-390    	; 0xe14 <main+0x5e>
     f9a:	80 91 47 3e 	lds	r24, 0x3E47
     f9e:	88 23       	and	r24, r24
     fa0:	09 f4       	brne	.+2      	; 0xfa4 <main+0x1ee>
     fa2:	38 cf       	rjmp	.-400    	; 0xe14 <main+0x5e>
						//get number of data points collected
						samples = ADC_Get_Num_Samples();
     fa4:	0e 94 cd 0c 	call	0x199a	; 0x199a <ADC_Get_Num_Samples>
     fa8:	a0 e0       	ldi	r26, 0x00	; 0
     faa:	b0 e0       	ldi	r27, 0x00	; 0
     fac:	8c 83       	std	Y+4, r24	; 0x04
     fae:	9d 83       	std	Y+5, r25	; 0x05
     fb0:	ae 83       	std	Y+6, r26	; 0x06
     fb2:	bf 83       	std	Y+7, r27	; 0x07
						if(samples > 0){	
     fb4:	8c 81       	ldd	r24, Y+4	; 0x04
     fb6:	9d 81       	ldd	r25, Y+5	; 0x05
     fb8:	ae 81       	ldd	r26, Y+6	; 0x06
     fba:	bf 81       	ldd	r27, Y+7	; 0x07
     fbc:	00 97       	sbiw	r24, 0x00	; 0
     fbe:	a1 05       	cpc	r26, r1
     fc0:	b1 05       	cpc	r27, r1
     fc2:	09 f4       	brne	.+2      	; 0xfc6 <main+0x210>
     fc4:	4d c1       	rjmp	.+666    	; 0x1260 <main+0x4aa>
							uint16_t NumMessages = ((samples*4)/CHB_MAX_PAYLOAD);
     fc6:	8c 81       	ldd	r24, Y+4	; 0x04
     fc8:	9d 81       	ldd	r25, Y+5	; 0x05
     fca:	ae 81       	ldd	r26, Y+6	; 0x06
     fcc:	bf 81       	ldd	r27, Y+7	; 0x07
     fce:	bc 01       	movw	r22, r24
     fd0:	cd 01       	movw	r24, r26
     fd2:	66 0f       	add	r22, r22
     fd4:	77 1f       	adc	r23, r23
     fd6:	88 1f       	adc	r24, r24
     fd8:	99 1f       	adc	r25, r25
     fda:	66 0f       	add	r22, r22
     fdc:	77 1f       	adc	r23, r23
     fde:	88 1f       	adc	r24, r24
     fe0:	99 1f       	adc	r25, r25
     fe2:	a3 01       	movw	r20, r6
     fe4:	92 01       	movw	r18, r4
     fe6:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
     fea:	89 01       	movw	r16, r18
     fec:	9a 01       	movw	r18, r20
     fee:	68 01       	movw	r12, r16
     ff0:	0c 8f       	std	Y+28, r16	; 0x1c
     ff2:	1d 8f       	std	Y+29, r17	; 0x1d
							if ((samples*4)%CHB_MAX_PAYLOAD > 0) NumMessages++;
     ff4:	8c 81       	ldd	r24, Y+4	; 0x04
     ff6:	9d 81       	ldd	r25, Y+5	; 0x05
     ff8:	ae 81       	ldd	r26, Y+6	; 0x06
     ffa:	bf 81       	ldd	r27, Y+7	; 0x07
     ffc:	bc 01       	movw	r22, r24
     ffe:	cd 01       	movw	r24, r26
    1000:	66 0f       	add	r22, r22
    1002:	77 1f       	adc	r23, r23
    1004:	88 1f       	adc	r24, r24
    1006:	99 1f       	adc	r25, r25
    1008:	66 0f       	add	r22, r22
    100a:	77 1f       	adc	r23, r23
    100c:	88 1f       	adc	r24, r24
    100e:	99 1f       	adc	r25, r25
    1010:	a3 01       	movw	r20, r6
    1012:	92 01       	movw	r18, r4
    1014:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    1018:	dc 01       	movw	r26, r24
    101a:	cb 01       	movw	r24, r22
    101c:	00 97       	sbiw	r24, 0x00	; 0
    101e:	a1 05       	cpc	r26, r1
    1020:	b1 05       	cpc	r27, r1
    1022:	21 f0       	breq	.+8      	; 0x102c <main+0x276>
    1024:	c6 01       	movw	r24, r12
    1026:	01 96       	adiw	r24, 0x01	; 1
    1028:	8c 8f       	std	Y+28, r24	; 0x1c
    102a:	9d 8f       	std	Y+29, r25	; 0x1d
							//send the number of messages the base station should expect after this message
							chb_write(0x0000,&NumMessages,2);  
    102c:	80 e0       	ldi	r24, 0x00	; 0
    102e:	90 e0       	ldi	r25, 0x00	; 0
    1030:	be 01       	movw	r22, r28
    1032:	64 5e       	subi	r22, 0xE4	; 228
    1034:	7f 4f       	sbci	r23, 0xFF	; 255
    1036:	22 e0       	ldi	r18, 0x02	; 2
    1038:	30 e0       	ldi	r19, 0x00	; 0
    103a:	40 e0       	ldi	r20, 0x00	; 0
    103c:	50 e0       	ldi	r21, 0x00	; 0
    103e:	0e 94 21 1a 	call	0x3442	; 0x3442 <chb_write>
							//read the data from FRAM and send it
							for(uint16_t i =0; i<(samples*4);){	
    1042:	cc 24       	eor	r12, r12
    1044:	dd 24       	eor	r13, r13
    1046:	f7 c0       	rjmp	.+494    	; 0x1236 <main+0x480>
								if(samples*4 - i > 7200){
    1048:	8c 81       	ldd	r24, Y+4	; 0x04
    104a:	9d 81       	ldd	r25, Y+5	; 0x05
    104c:	ae 81       	ldd	r26, Y+6	; 0x06
    104e:	bf 81       	ldd	r27, Y+7	; 0x07
    1050:	88 0f       	add	r24, r24
    1052:	99 1f       	adc	r25, r25
    1054:	aa 1f       	adc	r26, r26
    1056:	bb 1f       	adc	r27, r27
    1058:	88 0f       	add	r24, r24
    105a:	99 1f       	adc	r25, r25
    105c:	aa 1f       	adc	r26, r26
    105e:	bb 1f       	adc	r27, r27
    1060:	88 19       	sub	r24, r8
    1062:	99 09       	sbc	r25, r9
    1064:	aa 09       	sbc	r26, r10
    1066:	bb 09       	sbc	r27, r11
    1068:	81 32       	cpi	r24, 0x21	; 33
    106a:	fc e1       	ldi	r31, 0x1C	; 28
    106c:	9f 07       	cpc	r25, r31
    106e:	f0 e0       	ldi	r31, 0x00	; 0
    1070:	af 07       	cpc	r26, r31
    1072:	f0 e0       	ldi	r31, 0x00	; 0
    1074:	bf 07       	cpc	r27, r31
    1076:	98 f1       	brcs	.+102    	; 0x10de <main+0x328>
									readFRAM(7200,(FRAMAddress-(samples*4))+i);		
    1078:	60 91 1d 3e 	lds	r22, 0x3E1D
    107c:	70 91 1e 3e 	lds	r23, 0x3E1E
    1080:	8c 81       	ldd	r24, Y+4	; 0x04
    1082:	9d 81       	ldd	r25, Y+5	; 0x05
    1084:	ae 81       	ldd	r26, Y+6	; 0x06
    1086:	bf 81       	ldd	r27, Y+7	; 0x07
    1088:	88 0f       	add	r24, r24
    108a:	99 1f       	adc	r25, r25
    108c:	88 0f       	add	r24, r24
    108e:	99 1f       	adc	r25, r25
    1090:	68 1b       	sub	r22, r24
    1092:	79 0b       	sbc	r23, r25
    1094:	6c 0d       	add	r22, r12
    1096:	7d 1d       	adc	r23, r13
    1098:	80 e2       	ldi	r24, 0x20	; 32
    109a:	9c e1       	ldi	r25, 0x1C	; 28
    109c:	0e 94 cd 01 	call	0x39a	; 0x39a <readFRAM>
    10a0:	00 e0       	ldi	r16, 0x00	; 0
    10a2:	10 e0       	ldi	r17, 0x00	; 0
									for(uint32_t j = 0; j<7200;){				
										chb_write(0x0000,FRAMReadBuffer+j,100);
    10a4:	b8 01       	movw	r22, r16
    10a6:	64 55       	subi	r22, 0x54	; 84
    10a8:	7e 4d       	sbci	r23, 0xDE	; 222
    10aa:	80 e0       	ldi	r24, 0x00	; 0
    10ac:	90 e0       	ldi	r25, 0x00	; 0
    10ae:	a3 01       	movw	r20, r6
    10b0:	92 01       	movw	r18, r4
    10b2:	0e 94 21 1a 	call	0x3442	; 0x3442 <chb_write>
    10b6:	8f ef       	ldi	r24, 0xFF	; 255
    10b8:	93 ec       	ldi	r25, 0xC3	; 195
    10ba:	a9 e0       	ldi	r26, 0x09	; 9
    10bc:	81 50       	subi	r24, 0x01	; 1
    10be:	90 40       	sbci	r25, 0x00	; 0
    10c0:	a0 40       	sbci	r26, 0x00	; 0
    10c2:	e1 f7       	brne	.-8      	; 0x10bc <main+0x306>
    10c4:	00 c0       	rjmp	.+0      	; 0x10c6 <main+0x310>
    10c6:	00 00       	nop
    10c8:	0c 59       	subi	r16, 0x9C	; 156
    10ca:	1f 4f       	sbci	r17, 0xFF	; 255
							chb_write(0x0000,&NumMessages,2);  
							//read the data from FRAM and send it
							for(uint16_t i =0; i<(samples*4);){	
								if(samples*4 - i > 7200){
									readFRAM(7200,(FRAMAddress-(samples*4))+i);		
									for(uint32_t j = 0; j<7200;){				
    10cc:	9c e1       	ldi	r25, 0x1C	; 28
    10ce:	00 32       	cpi	r16, 0x20	; 32
    10d0:	19 07       	cpc	r17, r25
    10d2:	41 f7       	brne	.-48     	; 0x10a4 <main+0x2ee>
										chb_write(0x0000,FRAMReadBuffer+j,100);
										_delay_ms(100);
										j+=100;
									}									
									i += 7200;
    10d4:	a0 e2       	ldi	r26, 0x20	; 32
    10d6:	bc e1       	ldi	r27, 0x1C	; 28
    10d8:	ca 0e       	add	r12, r26
    10da:	db 1e       	adc	r13, r27
    10dc:	ac c0       	rjmp	.+344    	; 0x1236 <main+0x480>
								}
								else{
									readFRAM(samples*4 - i,(FRAMAddress-(samples*4))+i);
    10de:	8c 81       	ldd	r24, Y+4	; 0x04
    10e0:	9d 81       	ldd	r25, Y+5	; 0x05
    10e2:	ae 81       	ldd	r26, Y+6	; 0x06
    10e4:	bf 81       	ldd	r27, Y+7	; 0x07
    10e6:	e0 91 1d 3e 	lds	r30, 0x3E1D
    10ea:	f0 91 1e 3e 	lds	r31, 0x3E1E
    10ee:	4c 81       	ldd	r20, Y+4	; 0x04
    10f0:	5d 81       	ldd	r21, Y+5	; 0x05
    10f2:	6e 81       	ldd	r22, Y+6	; 0x06
    10f4:	7f 81       	ldd	r23, Y+7	; 0x07
    10f6:	9c 01       	movw	r18, r24
    10f8:	22 0f       	add	r18, r18
    10fa:	33 1f       	adc	r19, r19
    10fc:	22 0f       	add	r18, r18
    10fe:	33 1f       	adc	r19, r19
    1100:	ca 01       	movw	r24, r20
    1102:	88 0f       	add	r24, r24
    1104:	99 1f       	adc	r25, r25
    1106:	88 0f       	add	r24, r24
    1108:	99 1f       	adc	r25, r25
    110a:	bf 01       	movw	r22, r30
    110c:	68 1b       	sub	r22, r24
    110e:	79 0b       	sbc	r23, r25
    1110:	6c 0d       	add	r22, r12
    1112:	7d 1d       	adc	r23, r13
    1114:	c9 01       	movw	r24, r18
    1116:	8c 19       	sub	r24, r12
    1118:	9d 09       	sbc	r25, r13
    111a:	0e 94 cd 01 	call	0x39a	; 0x39a <readFRAM>
									for(uint32_t j = 0; j<samples*4-i;){
    111e:	cc 24       	eor	r12, r12
    1120:	dd 24       	eor	r13, r13
    1122:	76 01       	movw	r14, r12
    1124:	6a c0       	rjmp	.+212    	; 0x11fa <main+0x444>
										if(samples*4-i-j >= 100){	
    1126:	8c 81       	ldd	r24, Y+4	; 0x04
    1128:	9d 81       	ldd	r25, Y+5	; 0x05
    112a:	ae 81       	ldd	r26, Y+6	; 0x06
    112c:	bf 81       	ldd	r27, Y+7	; 0x07
    112e:	88 0f       	add	r24, r24
    1130:	99 1f       	adc	r25, r25
    1132:	aa 1f       	adc	r26, r26
    1134:	bb 1f       	adc	r27, r27
    1136:	88 0f       	add	r24, r24
    1138:	99 1f       	adc	r25, r25
    113a:	aa 1f       	adc	r26, r26
    113c:	bb 1f       	adc	r27, r27
    113e:	88 19       	sub	r24, r8
    1140:	99 09       	sbc	r25, r9
    1142:	aa 09       	sbc	r26, r10
    1144:	bb 09       	sbc	r27, r11
    1146:	8c 19       	sub	r24, r12
    1148:	9d 09       	sbc	r25, r13
    114a:	ae 09       	sbc	r26, r14
    114c:	bf 09       	sbc	r27, r15
    114e:	84 36       	cpi	r24, 0x64	; 100
    1150:	91 05       	cpc	r25, r1
    1152:	a1 05       	cpc	r26, r1
    1154:	b1 05       	cpc	r27, r1
    1156:	d8 f0       	brcs	.+54     	; 0x118e <main+0x3d8>
											chb_write(0x0000,FRAMReadBuffer+j,100);
    1158:	b6 01       	movw	r22, r12
    115a:	64 55       	subi	r22, 0x54	; 84
    115c:	7e 4d       	sbci	r23, 0xDE	; 222
    115e:	80 e0       	ldi	r24, 0x00	; 0
    1160:	90 e0       	ldi	r25, 0x00	; 0
    1162:	a3 01       	movw	r20, r6
    1164:	92 01       	movw	r18, r4
    1166:	0e 94 21 1a 	call	0x3442	; 0x3442 <chb_write>
    116a:	8f ef       	ldi	r24, 0xFF	; 255
    116c:	93 ec       	ldi	r25, 0xC3	; 195
    116e:	a9 e0       	ldi	r26, 0x09	; 9
    1170:	81 50       	subi	r24, 0x01	; 1
    1172:	90 40       	sbci	r25, 0x00	; 0
    1174:	a0 40       	sbci	r26, 0x00	; 0
    1176:	e1 f7       	brne	.-8      	; 0x1170 <main+0x3ba>
    1178:	00 c0       	rjmp	.+0      	; 0x117a <main+0x3c4>
    117a:	00 00       	nop
											_delay_ms(100);
											j+=100;
    117c:	84 e6       	ldi	r24, 0x64	; 100
    117e:	90 e0       	ldi	r25, 0x00	; 0
    1180:	a0 e0       	ldi	r26, 0x00	; 0
    1182:	b0 e0       	ldi	r27, 0x00	; 0
    1184:	c8 0e       	add	r12, r24
    1186:	d9 1e       	adc	r13, r25
    1188:	ea 1e       	adc	r14, r26
    118a:	fb 1e       	adc	r15, r27
    118c:	36 c0       	rjmp	.+108    	; 0x11fa <main+0x444>
										}
										else{
											chb_write(0x0000,FRAMReadBuffer+j,samples*4 - i - j);
    118e:	8c 81       	ldd	r24, Y+4	; 0x04
    1190:	9d 81       	ldd	r25, Y+5	; 0x05
    1192:	ae 81       	ldd	r26, Y+6	; 0x06
    1194:	bf 81       	ldd	r27, Y+7	; 0x07
    1196:	b6 01       	movw	r22, r12
    1198:	64 55       	subi	r22, 0x54	; 84
    119a:	7e 4d       	sbci	r23, 0xDE	; 222
    119c:	88 0f       	add	r24, r24
    119e:	99 1f       	adc	r25, r25
    11a0:	aa 1f       	adc	r26, r26
    11a2:	bb 1f       	adc	r27, r27
    11a4:	88 0f       	add	r24, r24
    11a6:	99 1f       	adc	r25, r25
    11a8:	aa 1f       	adc	r26, r26
    11aa:	bb 1f       	adc	r27, r27
    11ac:	88 19       	sub	r24, r8
    11ae:	99 09       	sbc	r25, r9
    11b0:	aa 09       	sbc	r26, r10
    11b2:	bb 09       	sbc	r27, r11
    11b4:	9c 01       	movw	r18, r24
    11b6:	ad 01       	movw	r20, r26
    11b8:	2c 19       	sub	r18, r12
    11ba:	3d 09       	sbc	r19, r13
    11bc:	4e 09       	sbc	r20, r14
    11be:	5f 09       	sbc	r21, r15
    11c0:	80 e0       	ldi	r24, 0x00	; 0
    11c2:	90 e0       	ldi	r25, 0x00	; 0
    11c4:	0e 94 21 1a 	call	0x3442	; 0x3442 <chb_write>
    11c8:	8f ef       	ldi	r24, 0xFF	; 255
    11ca:	93 ec       	ldi	r25, 0xC3	; 195
    11cc:	a9 e0       	ldi	r26, 0x09	; 9
    11ce:	81 50       	subi	r24, 0x01	; 1
    11d0:	90 40       	sbci	r25, 0x00	; 0
    11d2:	a0 40       	sbci	r26, 0x00	; 0
    11d4:	e1 f7       	brne	.-8      	; 0x11ce <main+0x418>
    11d6:	00 c0       	rjmp	.+0      	; 0x11d8 <main+0x422>
    11d8:	00 00       	nop
											_delay_ms(100);
											j+=samples*4 - i - j;
    11da:	cc 80       	ldd	r12, Y+4	; 0x04
    11dc:	dd 80       	ldd	r13, Y+5	; 0x05
    11de:	ee 80       	ldd	r14, Y+6	; 0x06
    11e0:	ff 80       	ldd	r15, Y+7	; 0x07
    11e2:	cc 0c       	add	r12, r12
    11e4:	dd 1c       	adc	r13, r13
    11e6:	ee 1c       	adc	r14, r14
    11e8:	ff 1c       	adc	r15, r15
    11ea:	cc 0c       	add	r12, r12
    11ec:	dd 1c       	adc	r13, r13
    11ee:	ee 1c       	adc	r14, r14
    11f0:	ff 1c       	adc	r15, r15
    11f2:	c8 18       	sub	r12, r8
    11f4:	d9 08       	sbc	r13, r9
    11f6:	ea 08       	sbc	r14, r10
    11f8:	fb 08       	sbc	r15, r11
									}									
									i += 7200;
								}
								else{
									readFRAM(samples*4 - i,(FRAMAddress-(samples*4))+i);
									for(uint32_t j = 0; j<samples*4-i;){
    11fa:	8c 81       	ldd	r24, Y+4	; 0x04
    11fc:	9d 81       	ldd	r25, Y+5	; 0x05
    11fe:	ae 81       	ldd	r26, Y+6	; 0x06
    1200:	bf 81       	ldd	r27, Y+7	; 0x07
    1202:	88 0f       	add	r24, r24
    1204:	99 1f       	adc	r25, r25
    1206:	aa 1f       	adc	r26, r26
    1208:	bb 1f       	adc	r27, r27
    120a:	88 0f       	add	r24, r24
    120c:	99 1f       	adc	r25, r25
    120e:	aa 1f       	adc	r26, r26
    1210:	bb 1f       	adc	r27, r27
    1212:	88 19       	sub	r24, r8
    1214:	99 09       	sbc	r25, r9
    1216:	aa 09       	sbc	r26, r10
    1218:	bb 09       	sbc	r27, r11
    121a:	c8 16       	cp	r12, r24
    121c:	d9 06       	cpc	r13, r25
    121e:	ea 06       	cpc	r14, r26
    1220:	fb 06       	cpc	r15, r27
    1222:	08 f4       	brcc	.+2      	; 0x1226 <main+0x470>
    1224:	80 cf       	rjmp	.-256    	; 0x1126 <main+0x370>
											chb_write(0x0000,FRAMReadBuffer+j,samples*4 - i - j);
											_delay_ms(100);
											j+=samples*4 - i - j;
										}											
									}										
									i += samples*4 - i;
    1226:	cc 80       	ldd	r12, Y+4	; 0x04
    1228:	dd 80       	ldd	r13, Y+5	; 0x05
    122a:	ee 80       	ldd	r14, Y+6	; 0x06
    122c:	ff 80       	ldd	r15, Y+7	; 0x07
    122e:	cc 0c       	add	r12, r12
    1230:	dd 1c       	adc	r13, r13
    1232:	cc 0c       	add	r12, r12
    1234:	dd 1c       	adc	r13, r13
							uint16_t NumMessages = ((samples*4)/CHB_MAX_PAYLOAD);
							if ((samples*4)%CHB_MAX_PAYLOAD > 0) NumMessages++;
							//send the number of messages the base station should expect after this message
							chb_write(0x0000,&NumMessages,2);  
							//read the data from FRAM and send it
							for(uint16_t i =0; i<(samples*4);){	
    1236:	46 01       	movw	r8, r12
    1238:	aa 24       	eor	r10, r10
    123a:	bb 24       	eor	r11, r11
    123c:	8c 81       	ldd	r24, Y+4	; 0x04
    123e:	9d 81       	ldd	r25, Y+5	; 0x05
    1240:	ae 81       	ldd	r26, Y+6	; 0x06
    1242:	bf 81       	ldd	r27, Y+7	; 0x07
    1244:	88 0f       	add	r24, r24
    1246:	99 1f       	adc	r25, r25
    1248:	aa 1f       	adc	r26, r26
    124a:	bb 1f       	adc	r27, r27
    124c:	88 0f       	add	r24, r24
    124e:	99 1f       	adc	r25, r25
    1250:	aa 1f       	adc	r26, r26
    1252:	bb 1f       	adc	r27, r27
    1254:	88 16       	cp	r8, r24
    1256:	99 06       	cpc	r9, r25
    1258:	aa 06       	cpc	r10, r26
    125a:	bb 06       	cpc	r11, r27
    125c:	08 f4       	brcc	.+2      	; 0x1260 <main+0x4aa>
    125e:	f4 ce       	rjmp	.-536    	; 0x1048 <main+0x292>
							}
							//chb_write(0x0000,FRAMReadBuffer,samples*4);								
							//write the data to SD card for good measure (make sure transmitted and collected data is the same)	
							//writeFile(ofile, FRAMReadBuffer, samples*4);			
						}							
						DataAvailable = 0;
    1260:	10 92 47 3e 	sts	0x3E47, r1
    1264:	d7 cd       	rjmp	.-1106   	; 0xe14 <main+0x5e>

00001266 <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
    1266:	0f 93       	push	r16
    1268:	1f 93       	push	r17
    126a:	cf 93       	push	r28
    126c:	8c 01       	movw	r16, r24
	moteID = 1;
    126e:	c1 e0       	ldi	r28, 0x01	; 1
    1270:	c0 93 45 3e 	sts	0x3E45, r28
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
    1274:	83 e0       	ldi	r24, 0x03	; 3
    1276:	80 93 1f 3e 	sts	0x3E1F, r24
	chb_init();
    127a:	0e 94 fd 19 	call	0x33fa	; 0x33fa <chb_init>
	chb_set_short_addr(moteID);
    127e:	80 91 45 3e 	lds	r24, 0x3E45
    1282:	90 e0       	ldi	r25, 0x00	; 0
    1284:	0e 94 20 1c 	call	0x3840	; 0x3840 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
    1288:	88 ec       	ldi	r24, 0xC8	; 200
    128a:	e0 e8       	ldi	r30, 0x80	; 128
    128c:	f1 e0       	ldi	r31, 0x01	; 1
    128e:	81 83       	std	Z+1, r24	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
    1290:	e0 e4       	ldi	r30, 0x40	; 64
    1292:	f9 e0       	ldi	r31, 0x09	; 9
    1294:	89 e0       	ldi	r24, 0x09	; 9
    1296:	80 83       	st	Z, r24
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
    1298:	82 e0       	ldi	r24, 0x02	; 2
    129a:	86 83       	std	Z+6, r24	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
    129c:	24 ef       	ldi	r18, 0xF4	; 244
    129e:	31 e0       	ldi	r19, 0x01	; 1
    12a0:	02 9f       	mul	r16, r18
    12a2:	c0 01       	movw	r24, r0
    12a4:	03 9f       	mul	r16, r19
    12a6:	90 0d       	add	r25, r0
    12a8:	12 9f       	mul	r17, r18
    12aa:	90 0d       	add	r25, r0
    12ac:	11 24       	eor	r1, r1
    12ae:	86 a3       	lds	r24, 0x56
    12b0:	97 a3       	lds	r25, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
    12b2:	e0 e4       	ldi	r30, 0x40	; 64
    12b4:	f8 e0       	ldi	r31, 0x08	; 8
    12b6:	80 e0       	ldi	r24, 0x00	; 0
    12b8:	9a ef       	ldi	r25, 0xFA	; 250
    12ba:	86 a3       	lds	r24, 0x56
    12bc:	97 a3       	lds	r25, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
    12be:	c6 83       	std	Z+6, r28	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
    12c0:	c0 83       	st	Z, r28
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
    12c2:	e0 ea       	ldi	r30, 0xA0	; 160
    12c4:	f0 e0       	ldi	r31, 0x00	; 0
    12c6:	82 81       	ldd	r24, Z+2	; 0x02
    12c8:	87 60       	ori	r24, 0x07	; 7
    12ca:	82 83       	std	Z+2, r24	; 0x02
	sei(); //  Enable global interrupts
    12cc:	78 94       	sei
}
    12ce:	cf 91       	pop	r28
    12d0:	1f 91       	pop	r17
    12d2:	0f 91       	pop	r16
    12d4:	08 95       	ret

000012d6 <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
    12d6:	78 94       	sei
    12d8:	1f 92       	push	r1
    12da:	0f 92       	push	r0
    12dc:	0f b6       	in	r0, 0x3f	; 63
    12de:	0f 92       	push	r0
    12e0:	0b b6       	in	r0, 0x3b	; 59
    12e2:	0f 92       	push	r0
    12e4:	11 24       	eor	r1, r1
    12e6:	ef 92       	push	r14
    12e8:	ff 92       	push	r15
    12ea:	0f 93       	push	r16
    12ec:	1f 93       	push	r17
    12ee:	2f 93       	push	r18
    12f0:	3f 93       	push	r19
    12f2:	4f 93       	push	r20
    12f4:	5f 93       	push	r21
    12f6:	6f 93       	push	r22
    12f8:	7f 93       	push	r23
    12fa:	8f 93       	push	r24
    12fc:	9f 93       	push	r25
    12fe:	af 93       	push	r26
    1300:	bf 93       	push	r27
    1302:	ef 93       	push	r30
    1304:	ff 93       	push	r31
    1306:	cf 93       	push	r28
    1308:	df 93       	push	r29
    130a:	cd b7       	in	r28, 0x3d	; 61
    130c:	de b7       	in	r29, 0x3e	; 62
    130e:	28 97       	sbiw	r28, 0x08	; 8
    1310:	cd bf       	out	0x3d, r28	; 61
    1312:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
    1314:	10 92 40 08 	sts	0x0840, r1
	TCD1.CTRLA = 0x00;
    1318:	10 92 40 09 	sts	0x0940, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
    131c:	82 e0       	ldi	r24, 0x02	; 2
    131e:	80 93 1f 3e 	sts	0x3E1F, r24
	char message[8];
	strcpy(message,"reset");
    1322:	de 01       	movw	r26, r28
    1324:	11 96       	adiw	r26, 0x01	; 1
    1326:	e4 e0       	ldi	r30, 0x04	; 4
    1328:	f0 e2       	ldi	r31, 0x20	; 32
    132a:	86 e0       	ldi	r24, 0x06	; 6
    132c:	01 90       	ld	r0, Z+
    132e:	0d 92       	st	X+, r0
    1330:	81 50       	subi	r24, 0x01	; 1
    1332:	e1 f7       	brne	.-8      	; 0x132c <__vector_83+0x56>
	itoa((int)(moteID),buff,10);
    1334:	09 ea       	ldi	r16, 0xA9	; 169
    1336:	10 e5       	ldi	r17, 0x50	; 80
    1338:	80 91 45 3e 	lds	r24, 0x3E45
    133c:	90 e0       	ldi	r25, 0x00	; 0
    133e:	b8 01       	movw	r22, r16
    1340:	4a e0       	ldi	r20, 0x0A	; 10
    1342:	50 e0       	ldi	r21, 0x00	; 0
    1344:	0e 94 fd 39 	call	0x73fa	; 0x73fa <itoa>
	strcat(message,buff);
    1348:	7e 01       	movw	r14, r28
    134a:	08 94       	sec
    134c:	e1 1c       	adc	r14, r1
    134e:	f1 1c       	adc	r15, r1
    1350:	c7 01       	movw	r24, r14
    1352:	b8 01       	movw	r22, r16
    1354:	0e 94 f2 39 	call	0x73e4	; 0x73e4 <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
    1358:	0e 94 ef 0c 	call	0x19de	; 0x19de <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
    135c:	f7 01       	movw	r30, r14
    135e:	01 90       	ld	r0, Z+
    1360:	00 20       	and	r0, r0
    1362:	e9 f7       	brne	.-6      	; 0x135e <__vector_83+0x88>
    1364:	31 97       	sbiw	r30, 0x01	; 1
    1366:	ee 19       	sub	r30, r14
    1368:	ff 09       	sbc	r31, r15
    136a:	9f 01       	movw	r18, r30
    136c:	40 e0       	ldi	r20, 0x00	; 0
    136e:	50 e0       	ldi	r21, 0x00	; 0
    1370:	80 e0       	ldi	r24, 0x00	; 0
    1372:	90 e0       	ldi	r25, 0x00	; 0
    1374:	b7 01       	movw	r22, r14
    1376:	0e 94 21 1a 	call	0x3442	; 0x3442 <chb_write>
}	
    137a:	28 96       	adiw	r28, 0x08	; 8
    137c:	cd bf       	out	0x3d, r28	; 61
    137e:	de bf       	out	0x3e, r29	; 62
    1380:	df 91       	pop	r29
    1382:	cf 91       	pop	r28
    1384:	ff 91       	pop	r31
    1386:	ef 91       	pop	r30
    1388:	bf 91       	pop	r27
    138a:	af 91       	pop	r26
    138c:	9f 91       	pop	r25
    138e:	8f 91       	pop	r24
    1390:	7f 91       	pop	r23
    1392:	6f 91       	pop	r22
    1394:	5f 91       	pop	r21
    1396:	4f 91       	pop	r20
    1398:	3f 91       	pop	r19
    139a:	2f 91       	pop	r18
    139c:	1f 91       	pop	r17
    139e:	0f 91       	pop	r16
    13a0:	ff 90       	pop	r15
    13a2:	ef 90       	pop	r14
    13a4:	0f 90       	pop	r0
    13a6:	0b be       	out	0x3b, r0	; 59
    13a8:	0f 90       	pop	r0
    13aa:	0f be       	out	0x3f, r0	; 63
    13ac:	0f 90       	pop	r0
    13ae:	1f 90       	pop	r1
    13b0:	18 95       	reti

000013b2 <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    13b2:	4f 92       	push	r4
    13b4:	5f 92       	push	r5
    13b6:	6f 92       	push	r6
    13b8:	7f 92       	push	r7
    13ba:	8f 92       	push	r8
    13bc:	9f 92       	push	r9
    13be:	af 92       	push	r10
    13c0:	bf 92       	push	r11
    13c2:	ef 92       	push	r14
    13c4:	ff 92       	push	r15
    13c6:	0f 93       	push	r16
    13c8:	1f 93       	push	r17
    13ca:	cf 93       	push	r28
    13cc:	df 93       	push	r29
    13ce:	cd b7       	in	r28, 0x3d	; 61
    13d0:	de b7       	in	r29, 0x3e	; 62
    13d2:	2b 97       	sbiw	r28, 0x0b	; 11
    13d4:	cd bf       	out	0x3d, r28	; 61
    13d6:	de bf       	out	0x3e, r29	; 62
    13d8:	8e 83       	std	Y+6, r24	; 0x06
    13da:	9f 83       	std	Y+7, r25	; 0x07
    13dc:	68 87       	std	Y+8, r22	; 0x08
    13de:	79 87       	std	Y+9, r23	; 0x09
    13e0:	4a 87       	std	Y+10, r20	; 0x0a
    13e2:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    13e4:	81 e0       	ldi	r24, 0x01	; 1
    13e6:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
    13ea:	80 e0       	ldi	r24, 0x00	; 0
    13ec:	92 e0       	ldi	r25, 0x02	; 2
    13ee:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    13f2:	00 e0       	ldi	r16, 0x00	; 0
    13f4:	12 e0       	ldi	r17, 0x02	; 2
    13f6:	d8 01       	movw	r26, r16
    13f8:	11 96       	adiw	r26, 0x01	; 1
    13fa:	8c 91       	ld	r24, X
    13fc:	11 97       	sbiw	r26, 0x01	; 1
    13fe:	89 7e       	andi	r24, 0xE9	; 233
    1400:	11 96       	adiw	r26, 0x01	; 1
    1402:	8c 93       	st	X, r24
    1404:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
    1406:	14 96       	adiw	r26, 0x04	; 4
    1408:	8c 91       	ld	r24, X
    140a:	14 97       	sbiw	r26, 0x04	; 4
    140c:	88 7f       	andi	r24, 0xF8	; 248
    140e:	83 60       	ori	r24, 0x03	; 3
    1410:	14 96       	adiw	r26, 0x04	; 4
    1412:	8c 93       	st	X, r24
    1414:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
    1416:	12 96       	adiw	r26, 0x02	; 2
    1418:	8c 91       	ld	r24, X
    141a:	12 97       	sbiw	r26, 0x02	; 2
    141c:	8f 7c       	andi	r24, 0xCF	; 207
    141e:	12 96       	adiw	r26, 0x02	; 2
    1420:	8c 93       	st	X, r24
    1422:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
    1424:	0f 2e       	mov	r0, r31
    1426:	f0 e2       	ldi	r31, 0x20	; 32
    1428:	ef 2e       	mov	r14, r31
    142a:	f2 e0       	ldi	r31, 0x02	; 2
    142c:	ff 2e       	mov	r15, r31
    142e:	f0 2d       	mov	r31, r0
    1430:	f7 01       	movw	r30, r14
    1432:	80 81       	ld	r24, Z
    1434:	80 7e       	andi	r24, 0xE0	; 224
    1436:	81 60       	ori	r24, 0x01	; 1
    1438:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    143a:	89 e0       	ldi	r24, 0x09	; 9
    143c:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
    143e:	8c 91       	ld	r24, X
    1440:	81 60       	ori	r24, 0x01	; 1
    1442:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    1444:	80 e0       	ldi	r24, 0x00	; 0
    1446:	92 e0       	ldi	r25, 0x02	; 2
    1448:	0e 94 65 19 	call	0x32ca	; 0x32ca <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
    144c:	80 e0       	ldi	r24, 0x00	; 0
    144e:	92 e0       	ldi	r25, 0x02	; 2
    1450:	60 e2       	ldi	r22, 0x20	; 32
    1452:	72 e0       	ldi	r23, 0x02	; 2
    1454:	40 e0       	ldi	r20, 0x00	; 0
    1456:	0e 94 6f 19 	call	0x32de	; 0x32de <ADC_Offset_Get_Unsigned>
    145a:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
    145c:	d8 01       	movw	r26, r16
    145e:	8c 91       	ld	r24, X
    1460:	8e 7f       	andi	r24, 0xFE	; 254
    1462:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    1464:	f7 01       	movw	r30, r14
    1466:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
    1468:	13 96       	adiw	r26, 0x03	; 3
    146a:	8c 91       	ld	r24, X
    146c:	13 97       	sbiw	r26, 0x03	; 3
    146e:	8f 73       	andi	r24, 0x3F	; 63
    1470:	13 96       	adiw	r26, 0x03	; 3
    1472:	8c 93       	st	X, r24
    1474:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
    1476:	8c 91       	ld	r24, X
    1478:	81 60       	ori	r24, 0x01	; 1
    147a:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    147c:	80 e0       	ldi	r24, 0x00	; 0
    147e:	92 e0       	ldi	r25, 0x02	; 2
    1480:	0e 94 65 19 	call	0x32ca	; 0x32ca <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
    1484:	d8 01       	movw	r26, r16
    1486:	11 96       	adiw	r26, 0x01	; 1
    1488:	8c 91       	ld	r24, X
    148a:	11 97       	sbiw	r26, 0x01	; 1
    148c:	88 60       	ori	r24, 0x08	; 8
    148e:	11 96       	adiw	r26, 0x01	; 1
    1490:	8c 93       	st	X, r24
    1492:	ee 24       	eor	r14, r14
    1494:	ff 24       	eor	r15, r15
    1496:	68 94       	set
    1498:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    149a:	44 24       	eor	r4, r4
    149c:	55 24       	eor	r5, r5
    149e:	32 01       	movw	r6, r4
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
    14a0:	20 e0       	ldi	r18, 0x00	; 0
    14a2:	30 e1       	ldi	r19, 0x10	; 16
    14a4:	40 e0       	ldi	r20, 0x00	; 0
    14a6:	50 e0       	ldi	r21, 0x00	; 0
    14a8:	2a 83       	std	Y+2, r18	; 0x02
    14aa:	3b 83       	std	Y+3, r19	; 0x03
    14ac:	4c 83       	std	Y+4, r20	; 0x04
    14ae:	5d 83       	std	Y+5, r21	; 0x05
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    14b0:	88 24       	eor	r8, r8
    14b2:	99 24       	eor	r9, r9
    14b4:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
    14b6:	00 e2       	ldi	r16, 0x20	; 32
    14b8:	12 e0       	ldi	r17, 0x02	; 2
    14ba:	d8 01       	movw	r26, r16
    14bc:	13 96       	adiw	r26, 0x03	; 3
    14be:	8c 91       	ld	r24, X
    14c0:	13 97       	sbiw	r26, 0x03	; 3
    14c2:	80 ff       	sbrs	r24, 0
    14c4:	fa cf       	rjmp	.-12     	; 0x14ba <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
    14c6:	69 81       	ldd	r22, Y+1	; 0x01
    14c8:	c8 01       	movw	r24, r16
    14ca:	0e 94 41 19 	call	0x3282	; 0x3282 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
    14ce:	a0 e0       	ldi	r26, 0x00	; 0
    14d0:	b0 e0       	ldi	r27, 0x00	; 0
    14d2:	88 0e       	add	r8, r24
    14d4:	99 1e       	adc	r9, r25
    14d6:	aa 1e       	adc	r10, r26
    14d8:	bb 1e       	adc	r11, r27
    14da:	48 16       	cp	r4, r24
    14dc:	59 06       	cpc	r5, r25
    14de:	6a 06       	cpc	r6, r26
    14e0:	7b 06       	cpc	r7, r27
    14e2:	10 f4       	brcc	.+4      	; 0x14e8 <CO_collectTemp+0x136>
    14e4:	2c 01       	movw	r4, r24
    14e6:	3d 01       	movw	r6, r26
    14e8:	2a 81       	ldd	r18, Y+2	; 0x02
    14ea:	3b 81       	ldd	r19, Y+3	; 0x03
    14ec:	4c 81       	ldd	r20, Y+4	; 0x04
    14ee:	5d 81       	ldd	r21, Y+5	; 0x05
    14f0:	82 17       	cp	r24, r18
    14f2:	93 07       	cpc	r25, r19
    14f4:	a4 07       	cpc	r26, r20
    14f6:	b5 07       	cpc	r27, r21
    14f8:	20 f4       	brcc	.+8      	; 0x1502 <CO_collectTemp+0x150>
    14fa:	8a 83       	std	Y+2, r24	; 0x02
    14fc:	9b 83       	std	Y+3, r25	; 0x03
    14fe:	ac 83       	std	Y+4, r26	; 0x04
    1500:	bd 83       	std	Y+5, r27	; 0x05
    1502:	08 94       	sec
    1504:	e1 08       	sbc	r14, r1
    1506:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    1508:	e1 14       	cp	r14, r1
    150a:	f1 04       	cpc	r15, r1
    150c:	b1 f6       	brne	.-84     	; 0x14ba <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
    150e:	e0 e0       	ldi	r30, 0x00	; 0
    1510:	f2 e0       	ldi	r31, 0x02	; 2
    1512:	81 81       	ldd	r24, Z+1	; 0x01
    1514:	87 7f       	andi	r24, 0xF7	; 247
    1516:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
    1518:	80 81       	ld	r24, Z
    151a:	82 60       	ori	r24, 0x02	; 2
    151c:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
    151e:	80 81       	ld	r24, Z
    1520:	8e 7f       	andi	r24, 0xFE	; 254
    1522:	80 83       	st	Z, r24

	ADCPower(FALSE);
    1524:	80 e0       	ldi	r24, 0x00	; 0
    1526:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>

	average = sum / NUM_SAMPLES;
    152a:	c5 01       	movw	r24, r10
    152c:	b4 01       	movw	r22, r8
    152e:	05 2e       	mov	r0, r21
    1530:	5a e0       	ldi	r21, 0x0A	; 10
    1532:	96 95       	lsr	r25
    1534:	87 95       	ror	r24
    1536:	77 95       	ror	r23
    1538:	67 95       	ror	r22
    153a:	5a 95       	dec	r21
    153c:	d1 f7       	brne	.-12     	; 0x1532 <CO_collectTemp+0x180>
    153e:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    1540:	28 ee       	ldi	r18, 0xE8	; 232
    1542:	33 e0       	ldi	r19, 0x03	; 3
    1544:	40 e0       	ldi	r20, 0x00	; 0
    1546:	50 e0       	ldi	r21, 0x00	; 0
    1548:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    154c:	0f 2e       	mov	r0, r31
    154e:	ff ef       	ldi	r31, 0xFF	; 255
    1550:	8f 2e       	mov	r8, r31
    1552:	ff e0       	ldi	r31, 0x0F	; 15
    1554:	9f 2e       	mov	r9, r31
    1556:	f0 e0       	ldi	r31, 0x00	; 0
    1558:	af 2e       	mov	r10, r31
    155a:	f0 e0       	ldi	r31, 0x00	; 0
    155c:	bf 2e       	mov	r11, r31
    155e:	f0 2d       	mov	r31, r0
    1560:	a5 01       	movw	r20, r10
    1562:	94 01       	movw	r18, r8
    1564:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    1568:	c9 01       	movw	r24, r18
    156a:	c2 97       	sbiw	r24, 0x32	; 50
    156c:	ae 81       	ldd	r26, Y+6	; 0x06
    156e:	bf 81       	ldd	r27, Y+7	; 0x07
    1570:	8d 93       	st	X+, r24
    1572:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    1574:	c3 01       	movw	r24, r6
    1576:	b2 01       	movw	r22, r4
    1578:	28 ee       	ldi	r18, 0xE8	; 232
    157a:	33 e0       	ldi	r19, 0x03	; 3
    157c:	40 e0       	ldi	r20, 0x00	; 0
    157e:	50 e0       	ldi	r21, 0x00	; 0
    1580:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    1584:	a5 01       	movw	r20, r10
    1586:	94 01       	movw	r18, r8
    1588:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    158c:	c9 01       	movw	r24, r18
    158e:	c2 97       	sbiw	r24, 0x32	; 50
    1590:	ea 85       	ldd	r30, Y+10	; 0x0a
    1592:	fb 85       	ldd	r31, Y+11	; 0x0b
    1594:	80 83       	st	Z, r24
    1596:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    1598:	6a 81       	ldd	r22, Y+2	; 0x02
    159a:	7b 81       	ldd	r23, Y+3	; 0x03
    159c:	8c 81       	ldd	r24, Y+4	; 0x04
    159e:	9d 81       	ldd	r25, Y+5	; 0x05
    15a0:	28 ee       	ldi	r18, 0xE8	; 232
    15a2:	33 e0       	ldi	r19, 0x03	; 3
    15a4:	40 e0       	ldi	r20, 0x00	; 0
    15a6:	50 e0       	ldi	r21, 0x00	; 0
    15a8:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    15ac:	a5 01       	movw	r20, r10
    15ae:	94 01       	movw	r18, r8
    15b0:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    15b4:	22 53       	subi	r18, 0x32	; 50
    15b6:	30 40       	sbci	r19, 0x00	; 0
    15b8:	a8 85       	ldd	r26, Y+8	; 0x08
    15ba:	b9 85       	ldd	r27, Y+9	; 0x09
    15bc:	2d 93       	st	X+, r18
    15be:	3c 93       	st	X, r19
    15c0:	11 97       	sbiw	r26, 0x01	; 1
}
    15c2:	2b 96       	adiw	r28, 0x0b	; 11
    15c4:	cd bf       	out	0x3d, r28	; 61
    15c6:	de bf       	out	0x3e, r29	; 62
    15c8:	df 91       	pop	r29
    15ca:	cf 91       	pop	r28
    15cc:	1f 91       	pop	r17
    15ce:	0f 91       	pop	r16
    15d0:	ff 90       	pop	r15
    15d2:	ef 90       	pop	r14
    15d4:	bf 90       	pop	r11
    15d6:	af 90       	pop	r10
    15d8:	9f 90       	pop	r9
    15da:	8f 90       	pop	r8
    15dc:	7f 90       	pop	r7
    15de:	6f 90       	pop	r6
    15e0:	5f 90       	pop	r5
    15e2:	4f 90       	pop	r4
    15e4:	08 95       	ret

000015e6 <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    15e6:	4f 92       	push	r4
    15e8:	5f 92       	push	r5
    15ea:	6f 92       	push	r6
    15ec:	7f 92       	push	r7
    15ee:	8f 92       	push	r8
    15f0:	9f 92       	push	r9
    15f2:	af 92       	push	r10
    15f4:	bf 92       	push	r11
    15f6:	ef 92       	push	r14
    15f8:	ff 92       	push	r15
    15fa:	0f 93       	push	r16
    15fc:	1f 93       	push	r17
    15fe:	cf 93       	push	r28
    1600:	df 93       	push	r29
    1602:	cd b7       	in	r28, 0x3d	; 61
    1604:	de b7       	in	r29, 0x3e	; 62
    1606:	2b 97       	sbiw	r28, 0x0b	; 11
    1608:	cd bf       	out	0x3d, r28	; 61
    160a:	de bf       	out	0x3e, r29	; 62
    160c:	8e 83       	std	Y+6, r24	; 0x06
    160e:	9f 83       	std	Y+7, r25	; 0x07
    1610:	68 87       	std	Y+8, r22	; 0x08
    1612:	79 87       	std	Y+9, r23	; 0x09
    1614:	4a 87       	std	Y+10, r20	; 0x0a
    1616:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    1618:	81 e0       	ldi	r24, 0x01	; 1
    161a:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
    161e:	84 e0       	ldi	r24, 0x04	; 4
    1620:	60 e0       	ldi	r22, 0x00	; 0
    1622:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
    1626:	84 e0       	ldi	r24, 0x04	; 4
    1628:	60 e0       	ldi	r22, 0x00	; 0
    162a:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
    162e:	2f ef       	ldi	r18, 0xFF	; 255
    1630:	33 ec       	ldi	r19, 0xC3	; 195
    1632:	49 e0       	ldi	r20, 0x09	; 9
    1634:	21 50       	subi	r18, 0x01	; 1
    1636:	30 40       	sbci	r19, 0x00	; 0
    1638:	40 40       	sbci	r20, 0x00	; 0
    163a:	e1 f7       	brne	.-8      	; 0x1634 <CO_collectBatt+0x4e>
    163c:	00 c0       	rjmp	.+0      	; 0x163e <CO_collectBatt+0x58>
    163e:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
    1640:	80 e4       	ldi	r24, 0x40	; 64
    1642:	92 e0       	ldi	r25, 0x02	; 2
    1644:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    1648:	00 e4       	ldi	r16, 0x40	; 64
    164a:	12 e0       	ldi	r17, 0x02	; 2
    164c:	d8 01       	movw	r26, r16
    164e:	11 96       	adiw	r26, 0x01	; 1
    1650:	8c 91       	ld	r24, X
    1652:	11 97       	sbiw	r26, 0x01	; 1
    1654:	89 7e       	andi	r24, 0xE9	; 233
    1656:	11 96       	adiw	r26, 0x01	; 1
    1658:	8c 93       	st	X, r24
    165a:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
    165c:	14 96       	adiw	r26, 0x04	; 4
    165e:	8c 91       	ld	r24, X
    1660:	14 97       	sbiw	r26, 0x04	; 4
    1662:	88 7f       	andi	r24, 0xF8	; 248
    1664:	83 60       	ori	r24, 0x03	; 3
    1666:	14 96       	adiw	r26, 0x04	; 4
    1668:	8c 93       	st	X, r24
    166a:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
    166c:	12 96       	adiw	r26, 0x02	; 2
    166e:	8c 91       	ld	r24, X
    1670:	12 97       	sbiw	r26, 0x02	; 2
    1672:	8f 7c       	andi	r24, 0xCF	; 207
    1674:	12 96       	adiw	r26, 0x02	; 2
    1676:	8c 93       	st	X, r24
    1678:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
    167a:	0f 2e       	mov	r0, r31
    167c:	f0 e6       	ldi	r31, 0x60	; 96
    167e:	ef 2e       	mov	r14, r31
    1680:	f2 e0       	ldi	r31, 0x02	; 2
    1682:	ff 2e       	mov	r15, r31
    1684:	f0 2d       	mov	r31, r0
    1686:	f7 01       	movw	r30, r14
    1688:	80 81       	ld	r24, Z
    168a:	80 7e       	andi	r24, 0xE0	; 224
    168c:	81 60       	ori	r24, 0x01	; 1
    168e:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    1690:	89 e0       	ldi	r24, 0x09	; 9
    1692:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
    1694:	8c 91       	ld	r24, X
    1696:	81 60       	ori	r24, 0x01	; 1
    1698:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
    169a:	80 e4       	ldi	r24, 0x40	; 64
    169c:	92 e0       	ldi	r25, 0x02	; 2
    169e:	0e 94 65 19 	call	0x32ca	; 0x32ca <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
    16a2:	80 e4       	ldi	r24, 0x40	; 64
    16a4:	92 e0       	ldi	r25, 0x02	; 2
    16a6:	60 e6       	ldi	r22, 0x60	; 96
    16a8:	72 e0       	ldi	r23, 0x02	; 2
    16aa:	40 e0       	ldi	r20, 0x00	; 0
    16ac:	0e 94 6f 19 	call	0x32de	; 0x32de <ADC_Offset_Get_Unsigned>
    16b0:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
    16b2:	d8 01       	movw	r26, r16
    16b4:	8c 91       	ld	r24, X
    16b6:	8e 7f       	andi	r24, 0xFE	; 254
    16b8:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    16ba:	f7 01       	movw	r30, r14
    16bc:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
    16be:	13 96       	adiw	r26, 0x03	; 3
    16c0:	8c 91       	ld	r24, X
    16c2:	13 97       	sbiw	r26, 0x03	; 3
    16c4:	8f 73       	andi	r24, 0x3F	; 63
    16c6:	13 96       	adiw	r26, 0x03	; 3
    16c8:	8c 93       	st	X, r24
    16ca:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
    16cc:	8c 91       	ld	r24, X
    16ce:	81 60       	ori	r24, 0x01	; 1
    16d0:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
    16d2:	80 e4       	ldi	r24, 0x40	; 64
    16d4:	92 e0       	ldi	r25, 0x02	; 2
    16d6:	0e 94 65 19 	call	0x32ca	; 0x32ca <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
    16da:	d8 01       	movw	r26, r16
    16dc:	11 96       	adiw	r26, 0x01	; 1
    16de:	8c 91       	ld	r24, X
    16e0:	11 97       	sbiw	r26, 0x01	; 1
    16e2:	88 60       	ori	r24, 0x08	; 8
    16e4:	11 96       	adiw	r26, 0x01	; 1
    16e6:	8c 93       	st	X, r24
    16e8:	ee 24       	eor	r14, r14
    16ea:	ff 24       	eor	r15, r15
    16ec:	68 94       	set
    16ee:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    16f0:	44 24       	eor	r4, r4
    16f2:	55 24       	eor	r5, r5
    16f4:	32 01       	movw	r6, r4
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
    16f6:	20 e0       	ldi	r18, 0x00	; 0
    16f8:	30 e1       	ldi	r19, 0x10	; 16
    16fa:	40 e0       	ldi	r20, 0x00	; 0
    16fc:	50 e0       	ldi	r21, 0x00	; 0
    16fe:	2a 83       	std	Y+2, r18	; 0x02
    1700:	3b 83       	std	Y+3, r19	; 0x03
    1702:	4c 83       	std	Y+4, r20	; 0x04
    1704:	5d 83       	std	Y+5, r21	; 0x05
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    1706:	88 24       	eor	r8, r8
    1708:	99 24       	eor	r9, r9
    170a:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
    170c:	00 e6       	ldi	r16, 0x60	; 96
    170e:	12 e0       	ldi	r17, 0x02	; 2
    1710:	d8 01       	movw	r26, r16
    1712:	13 96       	adiw	r26, 0x03	; 3
    1714:	8c 91       	ld	r24, X
    1716:	13 97       	sbiw	r26, 0x03	; 3
    1718:	80 ff       	sbrs	r24, 0
    171a:	fa cf       	rjmp	.-12     	; 0x1710 <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
    171c:	69 81       	ldd	r22, Y+1	; 0x01
    171e:	c8 01       	movw	r24, r16
    1720:	0e 94 41 19 	call	0x3282	; 0x3282 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
    1724:	a0 e0       	ldi	r26, 0x00	; 0
    1726:	b0 e0       	ldi	r27, 0x00	; 0
    1728:	88 0e       	add	r8, r24
    172a:	99 1e       	adc	r9, r25
    172c:	aa 1e       	adc	r10, r26
    172e:	bb 1e       	adc	r11, r27
    1730:	48 16       	cp	r4, r24
    1732:	59 06       	cpc	r5, r25
    1734:	6a 06       	cpc	r6, r26
    1736:	7b 06       	cpc	r7, r27
    1738:	10 f4       	brcc	.+4      	; 0x173e <CO_collectBatt+0x158>
    173a:	2c 01       	movw	r4, r24
    173c:	3d 01       	movw	r6, r26
    173e:	2a 81       	ldd	r18, Y+2	; 0x02
    1740:	3b 81       	ldd	r19, Y+3	; 0x03
    1742:	4c 81       	ldd	r20, Y+4	; 0x04
    1744:	5d 81       	ldd	r21, Y+5	; 0x05
    1746:	82 17       	cp	r24, r18
    1748:	93 07       	cpc	r25, r19
    174a:	a4 07       	cpc	r26, r20
    174c:	b5 07       	cpc	r27, r21
    174e:	20 f4       	brcc	.+8      	; 0x1758 <CO_collectBatt+0x172>
    1750:	8a 83       	std	Y+2, r24	; 0x02
    1752:	9b 83       	std	Y+3, r25	; 0x03
    1754:	ac 83       	std	Y+4, r26	; 0x04
    1756:	bd 83       	std	Y+5, r27	; 0x05
    1758:	08 94       	sec
    175a:	e1 08       	sbc	r14, r1
    175c:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    175e:	e1 14       	cp	r14, r1
    1760:	f1 04       	cpc	r15, r1
    1762:	b1 f6       	brne	.-84     	; 0x1710 <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
    1764:	e0 e4       	ldi	r30, 0x40	; 64
    1766:	f2 e0       	ldi	r31, 0x02	; 2
    1768:	81 81       	ldd	r24, Z+1	; 0x01
    176a:	87 7f       	andi	r24, 0xF7	; 247
    176c:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
    176e:	80 81       	ld	r24, Z
    1770:	8e 7f       	andi	r24, 0xFE	; 254
    1772:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
    1774:	84 e0       	ldi	r24, 0x04	; 4
    1776:	60 e0       	ldi	r22, 0x00	; 0
    1778:	0e 94 0c 05 	call	0xa18	; 0xa18 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
    177c:	80 e0       	ldi	r24, 0x00	; 0
    177e:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
    1782:	c5 01       	movw	r24, r10
    1784:	b4 01       	movw	r22, r8
    1786:	05 2e       	mov	r0, r21
    1788:	5a e0       	ldi	r21, 0x0A	; 10
    178a:	96 95       	lsr	r25
    178c:	87 95       	ror	r24
    178e:	77 95       	ror	r23
    1790:	67 95       	ror	r22
    1792:	5a 95       	dec	r21
    1794:	d1 f7       	brne	.-12     	; 0x178a <CO_collectBatt+0x1a4>
    1796:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    1798:	28 ee       	ldi	r18, 0xE8	; 232
    179a:	33 e0       	ldi	r19, 0x03	; 3
    179c:	40 e0       	ldi	r20, 0x00	; 0
    179e:	50 e0       	ldi	r21, 0x00	; 0
    17a0:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    17a4:	0f 2e       	mov	r0, r31
    17a6:	ff ef       	ldi	r31, 0xFF	; 255
    17a8:	8f 2e       	mov	r8, r31
    17aa:	ff e0       	ldi	r31, 0x0F	; 15
    17ac:	9f 2e       	mov	r9, r31
    17ae:	f0 e0       	ldi	r31, 0x00	; 0
    17b0:	af 2e       	mov	r10, r31
    17b2:	f0 e0       	ldi	r31, 0x00	; 0
    17b4:	bf 2e       	mov	r11, r31
    17b6:	f0 2d       	mov	r31, r0
    17b8:	a5 01       	movw	r20, r10
    17ba:	94 01       	movw	r18, r8
    17bc:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    17c0:	c9 01       	movw	r24, r18
    17c2:	c2 97       	sbiw	r24, 0x32	; 50
    17c4:	ae 81       	ldd	r26, Y+6	; 0x06
    17c6:	bf 81       	ldd	r27, Y+7	; 0x07
    17c8:	8d 93       	st	X+, r24
    17ca:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    17cc:	c3 01       	movw	r24, r6
    17ce:	b2 01       	movw	r22, r4
    17d0:	28 ee       	ldi	r18, 0xE8	; 232
    17d2:	33 e0       	ldi	r19, 0x03	; 3
    17d4:	40 e0       	ldi	r20, 0x00	; 0
    17d6:	50 e0       	ldi	r21, 0x00	; 0
    17d8:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    17dc:	a5 01       	movw	r20, r10
    17de:	94 01       	movw	r18, r8
    17e0:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    17e4:	c9 01       	movw	r24, r18
    17e6:	c2 97       	sbiw	r24, 0x32	; 50
    17e8:	ea 85       	ldd	r30, Y+10	; 0x0a
    17ea:	fb 85       	ldd	r31, Y+11	; 0x0b
    17ec:	80 83       	st	Z, r24
    17ee:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    17f0:	6a 81       	ldd	r22, Y+2	; 0x02
    17f2:	7b 81       	ldd	r23, Y+3	; 0x03
    17f4:	8c 81       	ldd	r24, Y+4	; 0x04
    17f6:	9d 81       	ldd	r25, Y+5	; 0x05
    17f8:	28 ee       	ldi	r18, 0xE8	; 232
    17fa:	33 e0       	ldi	r19, 0x03	; 3
    17fc:	40 e0       	ldi	r20, 0x00	; 0
    17fe:	50 e0       	ldi	r21, 0x00	; 0
    1800:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    1804:	a5 01       	movw	r20, r10
    1806:	94 01       	movw	r18, r8
    1808:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    180c:	22 53       	subi	r18, 0x32	; 50
    180e:	30 40       	sbci	r19, 0x00	; 0
    1810:	a8 85       	ldd	r26, Y+8	; 0x08
    1812:	b9 85       	ldd	r27, Y+9	; 0x09
    1814:	2d 93       	st	X+, r18
    1816:	3c 93       	st	X, r19
    1818:	11 97       	sbiw	r26, 0x01	; 1
}
    181a:	2b 96       	adiw	r28, 0x0b	; 11
    181c:	cd bf       	out	0x3d, r28	; 61
    181e:	de bf       	out	0x3e, r29	; 62
    1820:	df 91       	pop	r29
    1822:	cf 91       	pop	r28
    1824:	1f 91       	pop	r17
    1826:	0f 91       	pop	r16
    1828:	ff 90       	pop	r15
    182a:	ef 90       	pop	r14
    182c:	bf 90       	pop	r11
    182e:	af 90       	pop	r10
    1830:	9f 90       	pop	r9
    1832:	8f 90       	pop	r8
    1834:	7f 90       	pop	r7
    1836:	6f 90       	pop	r6
    1838:	5f 90       	pop	r5
    183a:	4f 90       	pop	r4
    183c:	08 95       	ret

0000183e <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
    183e:	cf 93       	push	r28
    1840:	c6 2f       	mov	r28, r22
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
    1842:	21 e0       	ldi	r18, 0x01	; 1
    1844:	30 e0       	ldi	r19, 0x00	; 0
    1846:	a9 01       	movw	r20, r18
    1848:	02 c0       	rjmp	.+4      	; 0x184e <set_ampGain+0x10>
    184a:	44 0f       	add	r20, r20
    184c:	55 1f       	adc	r21, r21
    184e:	8a 95       	dec	r24
    1850:	e2 f7       	brpl	.-8      	; 0x184a <set_ampGain+0xc>
    1852:	ca 01       	movw	r24, r20
    1854:	61 e0       	ldi	r22, 0x01	; 1
    1856:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    185a:	c0 ff       	sbrs	r28, 0
    185c:	05 c0       	rjmp	.+10     	; 0x1868 <set_ampGain+0x2a>
    185e:	80 e4       	ldi	r24, 0x40	; 64
    1860:	e0 e0       	ldi	r30, 0x00	; 0
    1862:	f6 e0       	ldi	r31, 0x06	; 6
    1864:	85 83       	std	Z+5, r24	; 0x05
    1866:	04 c0       	rjmp	.+8      	; 0x1870 <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
    1868:	80 e4       	ldi	r24, 0x40	; 64
    186a:	e0 e0       	ldi	r30, 0x00	; 0
    186c:	f6 e0       	ldi	r31, 0x06	; 6
    186e:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    1870:	c1 ff       	sbrs	r28, 1
    1872:	05 c0       	rjmp	.+10     	; 0x187e <set_ampGain+0x40>
    1874:	82 e0       	ldi	r24, 0x02	; 2
    1876:	e0 e2       	ldi	r30, 0x20	; 32
    1878:	f6 e0       	ldi	r31, 0x06	; 6
    187a:	85 83       	std	Z+5, r24	; 0x05
    187c:	04 c0       	rjmp	.+8      	; 0x1886 <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
    187e:	82 e0       	ldi	r24, 0x02	; 2
    1880:	e0 e2       	ldi	r30, 0x20	; 32
    1882:	f6 e0       	ldi	r31, 0x06	; 6
    1884:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    1886:	c2 ff       	sbrs	r28, 2
    1888:	05 c0       	rjmp	.+10     	; 0x1894 <set_ampGain+0x56>
    188a:	84 e0       	ldi	r24, 0x04	; 4
    188c:	e0 e2       	ldi	r30, 0x20	; 32
    188e:	f6 e0       	ldi	r31, 0x06	; 6
    1890:	85 83       	std	Z+5, r24	; 0x05
    1892:	04 c0       	rjmp	.+8      	; 0x189c <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
    1894:	84 e0       	ldi	r24, 0x04	; 4
    1896:	e0 e2       	ldi	r30, 0x20	; 32
    1898:	f6 e0       	ldi	r31, 0x06	; 6
    189a:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    189c:	5a e0       	ldi	r21, 0x0A	; 10
    189e:	5a 95       	dec	r21
    18a0:	f1 f7       	brne	.-4      	; 0x189e <set_ampGain+0x60>
    18a2:	00 c0       	rjmp	.+0      	; 0x18a4 <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    18a4:	8f ef       	ldi	r24, 0xFF	; 255
    18a6:	61 e0       	ldi	r22, 0x01	; 1
    18a8:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    18ac:	cf 91       	pop	r28
    18ae:	08 95       	ret

000018b0 <enableADCMUX>:

void enableADCMUX(uint8_t on) {
	
	if(on) {
    18b0:	88 23       	and	r24, r24
    18b2:	31 f0       	breq	.+12     	; 0x18c0 <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
    18b4:	e0 e0       	ldi	r30, 0x00	; 0
    18b6:	f6 e0       	ldi	r31, 0x06	; 6
    18b8:	80 e2       	ldi	r24, 0x20	; 32
    18ba:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
    18bc:	85 83       	std	Z+5, r24	; 0x05
    18be:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
    18c0:	e0 e0       	ldi	r30, 0x00	; 0
    18c2:	f6 e0       	ldi	r31, 0x06	; 6
    18c4:	80 e2       	ldi	r24, 0x20	; 32
    18c6:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    18c8:	82 83       	std	Z+2, r24	; 0x02
    18ca:	08 95       	ret

000018cc <__vector_20>:
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
    18cc:	1f 92       	push	r1
    18ce:	0f 92       	push	r0
    18d0:	0f b6       	in	r0, 0x3f	; 63
    18d2:	0f 92       	push	r0
    18d4:	0b b6       	in	r0, 0x3b	; 59
    18d6:	0f 92       	push	r0
    18d8:	11 24       	eor	r1, r1
    18da:	2f 93       	push	r18
    18dc:	3f 93       	push	r19
    18de:	4f 93       	push	r20
    18e0:	5f 93       	push	r21
    18e2:	6f 93       	push	r22
    18e4:	7f 93       	push	r23
    18e6:	8f 93       	push	r24
    18e8:	9f 93       	push	r25
    18ea:	af 93       	push	r26
    18ec:	bf 93       	push	r27
    18ee:	ef 93       	push	r30
    18f0:	ff 93       	push	r31

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    18f2:	e0 e4       	ldi	r30, 0x40	; 64
    18f4:	fa e0       	ldi	r31, 0x0A	; 10
    18f6:	80 81       	ld	r24, Z
    18f8:	80 7f       	andi	r24, 0xF0	; 240
    18fa:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    18fc:	a0 e0       	ldi	r26, 0x00	; 0
    18fe:	b8 e0       	ldi	r27, 0x08	; 8
    1900:	8c 91       	ld	r24, X
    1902:	80 7f       	andi	r24, 0xF0	; 240
    1904:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1906:	a0 e0       	ldi	r26, 0x00	; 0
    1908:	b9 e0       	ldi	r27, 0x09	; 9
    190a:	8c 91       	ld	r24, X
    190c:	80 7f       	andi	r24, 0xF0	; 240
    190e:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1910:	80 81       	ld	r24, Z
    1912:	80 7f       	andi	r24, 0xF0	; 240
    1914:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    1918:	80 e0       	ldi	r24, 0x00	; 0
    191a:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    191e:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	enableADCMUX(FALSE);
    1922:	80 e0       	ldi	r24, 0x00	; 0
    1924:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
    1928:	81 e0       	ldi	r24, 0x01	; 1
    192a:	80 93 a6 50 	sts	0x50A6, r24
	DataAvailable = 1;
    192e:	80 93 47 3e 	sts	0x3E47, r24
}
    1932:	ff 91       	pop	r31
    1934:	ef 91       	pop	r30
    1936:	bf 91       	pop	r27
    1938:	af 91       	pop	r26
    193a:	9f 91       	pop	r25
    193c:	8f 91       	pop	r24
    193e:	7f 91       	pop	r23
    1940:	6f 91       	pop	r22
    1942:	5f 91       	pop	r21
    1944:	4f 91       	pop	r20
    1946:	3f 91       	pop	r19
    1948:	2f 91       	pop	r18
    194a:	0f 90       	pop	r0
    194c:	0b be       	out	0x3b, r0	; 59
    194e:	0f 90       	pop	r0
    1950:	0f be       	out	0x3f, r0	; 63
    1952:	0f 90       	pop	r0
    1954:	1f 90       	pop	r1
    1956:	18 95       	reti

00001958 <ADC_Stop_Sampling>:

//turns off ADC timers/counters and spi bus 
void ADC_Stop_Sampling(){
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1958:	e0 e4       	ldi	r30, 0x40	; 64
    195a:	fa e0       	ldi	r31, 0x0A	; 10
    195c:	80 81       	ld	r24, Z
    195e:	80 7f       	andi	r24, 0xF0	; 240
    1960:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1962:	a0 e0       	ldi	r26, 0x00	; 0
    1964:	b8 e0       	ldi	r27, 0x08	; 8
    1966:	8c 91       	ld	r24, X
    1968:	80 7f       	andi	r24, 0xF0	; 240
    196a:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    196c:	a0 e0       	ldi	r26, 0x00	; 0
    196e:	b9 e0       	ldi	r27, 0x09	; 9
    1970:	8c 91       	ld	r24, X
    1972:	80 7f       	andi	r24, 0xF0	; 240
    1974:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1976:	80 81       	ld	r24, Z
    1978:	80 7f       	andi	r24, 0xF0	; 240
    197a:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    197e:	80 e0       	ldi	r24, 0x00	; 0
    1980:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    1984:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	enableADCMUX(FALSE);
    1988:	80 e0       	ldi	r24, 0x00	; 0
    198a:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <enableADCMUX>
	ADC_Sampling_Finished = 1;
    198e:	81 e0       	ldi	r24, 0x01	; 1
    1990:	80 93 a6 50 	sts	0x50A6, r24
	DataAvailable = 1;
    1994:	80 93 47 3e 	sts	0x3E47, r24
}
    1998:	08 95       	ret

0000199a <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
    199a:	cf 93       	push	r28
    199c:	df 93       	push	r29
    199e:	0f 92       	push	r0
    19a0:	0f 92       	push	r0
    19a2:	cd b7       	in	r28, 0x3d	; 61
    19a4:	de b7       	in	r29, 0x3e	; 62
	
	if(ADC_Sampling_Finished){
    19a6:	80 91 a6 50 	lds	r24, 0x50A6
    19aa:	88 23       	and	r24, r24
    19ac:	89 f0       	breq	.+34     	; 0x19d0 <ADC_Get_Num_Samples+0x36>
		volatile uint16_t count;
		count = TCC1.CNT;
    19ae:	e0 e4       	ldi	r30, 0x40	; 64
    19b0:	f8 e0       	ldi	r31, 0x08	; 8
    19b2:	80 a1       	lds	r24, 0x40
    19b4:	91 a1       	lds	r25, 0x41
    19b6:	89 83       	std	Y+1, r24	; 0x01
    19b8:	9a 83       	std	Y+2, r25	; 0x02
		if(count == 0) count = TCC1.PER;
    19ba:	89 81       	ldd	r24, Y+1	; 0x01
    19bc:	9a 81       	ldd	r25, Y+2	; 0x02
    19be:	00 97       	sbiw	r24, 0x00	; 0
    19c0:	21 f4       	brne	.+8      	; 0x19ca <ADC_Get_Num_Samples+0x30>
    19c2:	86 a1       	lds	r24, 0x46
    19c4:	97 a1       	lds	r25, 0x47
    19c6:	89 83       	std	Y+1, r24	; 0x01
    19c8:	9a 83       	std	Y+2, r25	; 0x02
		return count;
    19ca:	89 81       	ldd	r24, Y+1	; 0x01
    19cc:	9a 81       	ldd	r25, Y+2	; 0x02
    19ce:	02 c0       	rjmp	.+4      	; 0x19d4 <ADC_Get_Num_Samples+0x3a>
	}
	else return 0;		
    19d0:	80 e0       	ldi	r24, 0x00	; 0
    19d2:	90 e0       	ldi	r25, 0x00	; 0
}
    19d4:	0f 90       	pop	r0
    19d6:	0f 90       	pop	r0
    19d8:	df 91       	pop	r29
    19da:	cf 91       	pop	r28
    19dc:	08 95       	ret

000019de <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    19de:	e0 ea       	ldi	r30, 0xA0	; 160
    19e0:	f6 e0       	ldi	r31, 0x06	; 6
    19e2:	13 86       	std	Z+11, r1	; 0x0b
}
    19e4:	08 95       	ret

000019e6 <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    19e6:	81 e0       	ldi	r24, 0x01	; 1
    19e8:	e0 ea       	ldi	r30, 0xA0	; 160
    19ea:	f6 e0       	ldi	r31, 0x06	; 6
    19ec:	83 87       	std	Z+11, r24	; 0x0b
}	
    19ee:	08 95       	ret

000019f0 <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    19f0:	1f 92       	push	r1
    19f2:	0f 92       	push	r0
    19f4:	0f b6       	in	r0, 0x3f	; 63
    19f6:	0f 92       	push	r0
    19f8:	0b b6       	in	r0, 0x3b	; 59
    19fa:	0f 92       	push	r0
    19fc:	11 24       	eor	r1, r1
    19fe:	6f 92       	push	r6
    1a00:	7f 92       	push	r7
    1a02:	8f 92       	push	r8
    1a04:	9f 92       	push	r9
    1a06:	af 92       	push	r10
    1a08:	bf 92       	push	r11
    1a0a:	cf 92       	push	r12
    1a0c:	df 92       	push	r13
    1a0e:	ef 92       	push	r14
    1a10:	ff 92       	push	r15
    1a12:	0f 93       	push	r16
    1a14:	1f 93       	push	r17
    1a16:	2f 93       	push	r18
    1a18:	3f 93       	push	r19
    1a1a:	4f 93       	push	r20
    1a1c:	5f 93       	push	r21
    1a1e:	6f 93       	push	r22
    1a20:	7f 93       	push	r23
    1a22:	8f 93       	push	r24
    1a24:	9f 93       	push	r25
    1a26:	af 93       	push	r26
    1a28:	bf 93       	push	r27
    1a2a:	ef 93       	push	r30
    1a2c:	ff 93       	push	r31
    1a2e:	cf 93       	push	r28
    1a30:	df 93       	push	r29
    1a32:	cd b7       	in	r28, 0x3d	; 61
    1a34:	de b7       	in	r29, 0x3e	; 62
    1a36:	2c 97       	sbiw	r28, 0x0c	; 12
    1a38:	cd bf       	out	0x3d, r28	; 61
    1a3a:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	volatile int64_t var;
	if (discardCount < ADC_DISCARD) {
    1a3c:	80 91 5c 40 	lds	r24, 0x405C
    1a40:	88 23       	and	r24, r24
    1a42:	8c f0       	brlt	.+34     	; 0x1a66 <__vector_104+0x76>
		discardCount++;
    1a44:	80 91 5c 40 	lds	r24, 0x405C
    1a48:	8f 5f       	subi	r24, 0xFF	; 255
    1a4a:	80 93 5c 40 	sts	0x405C, r24
		if(discardCount == ADC_DISCARD){
    1a4e:	80 91 5c 40 	lds	r24, 0x405C
    1a52:	80 38       	cpi	r24, 0x80	; 128
    1a54:	09 f0       	breq	.+2      	; 0x1a58 <__vector_104+0x68>
    1a56:	e9 c0       	rjmp	.+466    	; 0x1c2a <__vector_104+0x23a>
			//set event system to update counter of number of samples every sample event from now on
			TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    1a58:	e0 e4       	ldi	r30, 0x40	; 64
    1a5a:	f8 e0       	ldi	r31, 0x08	; 8
    1a5c:	80 81       	ld	r24, Z
    1a5e:	80 7f       	andi	r24, 0xF0	; 240
    1a60:	89 60       	ori	r24, 0x09	; 9
    1a62:	80 83       	st	Z, r24
    1a64:	e2 c0       	rjmp	.+452    	; 0x1c2a <__vector_104+0x23a>
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    1a66:	81 e0       	ldi	r24, 0x01	; 1
    1a68:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1a6c:	82 e0       	ldi	r24, 0x02	; 2
    1a6e:	e0 ea       	ldi	r30, 0xA0	; 160
    1a70:	f6 e0       	ldi	r31, 0x06	; 6
    1a72:	86 83       	std	Z+6, r24	; 0x06
    1a74:	80 e0       	ldi	r24, 0x00	; 0
    1a76:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1a78:	e0 ec       	ldi	r30, 0xC0	; 192
    1a7a:	f8 e0       	ldi	r31, 0x08	; 8
    1a7c:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
    1a7e:	20 e2       	ldi	r18, 0x20	; 32
    1a80:	3e e3       	ldi	r19, 0x3E	; 62
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1a82:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1a84:	42 81       	ldd	r20, Z+2	; 0x02
    1a86:	44 23       	and	r20, r20
    1a88:	ec f7       	brge	.-6      	; 0x1a84 <__vector_104+0x94>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1a8a:	43 81       	ldd	r20, Z+3	; 0x03
    1a8c:	d9 01       	movw	r26, r18
    1a8e:	a8 0f       	add	r26, r24
    1a90:	b9 1f       	adc	r27, r25
    1a92:	4c 93       	st	X, r20
    1a94:	01 96       	adiw	r24, 0x01	; 1
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1a96:	83 30       	cpi	r24, 0x03	; 3
    1a98:	91 05       	cpc	r25, r1
    1a9a:	99 f7       	brne	.-26     	; 0x1a82 <__vector_104+0x92>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1a9c:	82 e0       	ldi	r24, 0x02	; 2
    1a9e:	e0 ea       	ldi	r30, 0xA0	; 160
    1aa0:	f6 e0       	ldi	r31, 0x06	; 6
    1aa2:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
    1aa4:	80 e0       	ldi	r24, 0x00	; 0
    1aa6:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1aaa:	80 91 20 3e 	lds	r24, 0x3E20
    1aae:	88 23       	and	r24, r24
    1ab0:	1c f4       	brge	.+6      	; 0x1ab8 <__vector_104+0xc8>
    1ab2:	8f ef       	ldi	r24, 0xFF	; 255
    1ab4:	8c 83       	std	Y+4, r24	; 0x04
    1ab6:	01 c0       	rjmp	.+2      	; 0x1aba <__vector_104+0xca>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1ab8:	1c 82       	std	Y+4, r1	; 0x04
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    1aba:	80 91 20 3e 	lds	r24, 0x3E20
    1abe:	8b 83       	std	Y+3, r24	; 0x03
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    1ac0:	80 91 21 3e 	lds	r24, 0x3E21
    1ac4:	8a 83       	std	Y+2, r24	; 0x02
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    1ac6:	80 91 22 3e 	lds	r24, 0x3E22
    1aca:	89 83       	std	Y+1, r24	; 0x01
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    1acc:	89 81       	ldd	r24, Y+1	; 0x01
    1ace:	9a 81       	ldd	r25, Y+2	; 0x02
    1ad0:	ab 81       	ldd	r26, Y+3	; 0x03
    1ad2:	bc 81       	ldd	r27, Y+4	; 0x04
    1ad4:	ac 01       	movw	r20, r24
    1ad6:	bd 01       	movw	r22, r26
    1ad8:	77 0f       	add	r23, r23
    1ada:	44 0b       	sbc	r20, r20
    1adc:	54 2f       	mov	r21, r20
    1ade:	ba 01       	movw	r22, r20
    1ae0:	8d 83       	std	Y+5, r24	; 0x05
    1ae2:	9e 83       	std	Y+6, r25	; 0x06
    1ae4:	af 83       	std	Y+7, r26	; 0x07
    1ae6:	b8 87       	std	Y+8, r27	; 0x08
    1ae8:	49 87       	std	Y+9, r20	; 0x09
    1aea:	4a 87       	std	Y+10, r20	; 0x0a
    1aec:	4b 87       	std	Y+11, r20	; 0x0b
    1aee:	4c 87       	std	Y+12, r20	; 0x0c
		ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1af0:	60 91 65 50 	lds	r22, 0x5065
    1af4:	70 91 66 50 	lds	r23, 0x5066
    1af8:	80 91 67 50 	lds	r24, 0x5067
    1afc:	90 91 68 50 	lds	r25, 0x5068
    1b00:	8d 80       	ldd	r8, Y+5	; 0x05
    1b02:	1e 81       	ldd	r17, Y+6	; 0x06
    1b04:	0f 81       	ldd	r16, Y+7	; 0x07
    1b06:	f8 84       	ldd	r15, Y+8	; 0x08
    1b08:	e9 84       	ldd	r14, Y+9	; 0x09
    1b0a:	da 84       	ldd	r13, Y+10	; 0x0a
    1b0c:	cb 84       	ldd	r12, Y+11	; 0x0b
    1b0e:	bc 84       	ldd	r11, Y+12	; 0x0c
    1b10:	20 91 a7 50 	lds	r18, 0x50A7
    1b14:	30 91 a8 50 	lds	r19, 0x50A8
    1b18:	40 e0       	ldi	r20, 0x00	; 0
    1b1a:	50 e0       	ldi	r21, 0x00	; 0
    1b1c:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    1b20:	66 0f       	add	r22, r22
    1b22:	77 1f       	adc	r23, r23
    1b24:	66 0f       	add	r22, r22
    1b26:	77 1f       	adc	r23, r23
    1b28:	80 91 63 50 	lds	r24, 0x5063
    1b2c:	90 91 64 50 	lds	r25, 0x5064
    1b30:	3c 01       	movw	r6, r24
    1b32:	66 0e       	add	r6, r22
    1b34:	77 1e       	adc	r7, r23
    1b36:	28 2d       	mov	r18, r8
    1b38:	31 2f       	mov	r19, r17
    1b3a:	40 2f       	mov	r20, r16
    1b3c:	5f 2d       	mov	r21, r15
    1b3e:	6e 2d       	mov	r22, r14
    1b40:	7d 2d       	mov	r23, r13
    1b42:	8c 2d       	mov	r24, r12
    1b44:	9b 2d       	mov	r25, r11
    1b46:	0f 2e       	mov	r0, r31
    1b48:	f0 ea       	ldi	r31, 0xA0	; 160
    1b4a:	af 2e       	mov	r10, r31
    1b4c:	f0 2d       	mov	r31, r0
    1b4e:	0f 2e       	mov	r0, r31
    1b50:	f5 e2       	ldi	r31, 0x25	; 37
    1b52:	bf 2e       	mov	r11, r31
    1b54:	f0 2d       	mov	r31, r0
    1b56:	0f 2e       	mov	r0, r31
    1b58:	f6 e2       	ldi	r31, 0x26	; 38
    1b5a:	cf 2e       	mov	r12, r31
    1b5c:	f0 2d       	mov	r31, r0
    1b5e:	dd 24       	eor	r13, r13
    1b60:	ee 24       	eor	r14, r14
    1b62:	ff 24       	eor	r15, r15
    1b64:	00 e0       	ldi	r16, 0x00	; 0
    1b66:	10 e0       	ldi	r17, 0x00	; 0
    1b68:	0e 94 0b 2e 	call	0x5c16	; 0x5c16 <__muldi3>
    1b6c:	aa 24       	eor	r10, r10
    1b6e:	aa 94       	dec	r10
    1b70:	bb 24       	eor	r11, r11
    1b72:	ba 94       	dec	r11
    1b74:	0f 2e       	mov	r0, r31
    1b76:	ff e7       	ldi	r31, 0x7F	; 127
    1b78:	cf 2e       	mov	r12, r31
    1b7a:	f0 2d       	mov	r31, r0
    1b7c:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <__divdi3>
    1b80:	01 e0       	ldi	r16, 0x01	; 1
    1b82:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <__ashldi3>
    1b86:	0f 2e       	mov	r0, r31
    1b88:	f3 e0       	ldi	r31, 0x03	; 3
    1b8a:	af 2e       	mov	r10, r31
    1b8c:	f0 2d       	mov	r31, r0
    1b8e:	bb 24       	eor	r11, r11
    1b90:	cc 24       	eor	r12, r12
    1b92:	00 e0       	ldi	r16, 0x00	; 0
    1b94:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <__divdi3>
    1b98:	82 2e       	mov	r8, r18
    1b9a:	93 2e       	mov	r9, r19
    1b9c:	a4 2e       	mov	r10, r20
    1b9e:	b5 2e       	mov	r11, r21
    1ba0:	b0 94       	com	r11
    1ba2:	a0 94       	com	r10
    1ba4:	90 94       	com	r9
    1ba6:	80 94       	com	r8
    1ba8:	81 1c       	adc	r8, r1
    1baa:	91 1c       	adc	r9, r1
    1bac:	a1 1c       	adc	r10, r1
    1bae:	b1 1c       	adc	r11, r1
    1bb0:	f3 01       	movw	r30, r6
    1bb2:	80 82       	st	Z, r8
    1bb4:	91 82       	std	Z+1, r9	; 0x01
    1bb6:	a2 82       	std	Z+2, r10	; 0x02
    1bb8:	b3 82       	std	Z+3, r11	; 0x03
		if(write_to_FRAM){
    1bba:	80 91 48 40 	lds	r24, 0x4048
    1bbe:	88 23       	and	r24, r24
    1bc0:	09 f1       	breq	.+66     	; 0x1c04 <__vector_104+0x214>
			writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    1bc2:	60 91 65 50 	lds	r22, 0x5065
    1bc6:	70 91 66 50 	lds	r23, 0x5066
    1bca:	80 91 67 50 	lds	r24, 0x5067
    1bce:	90 91 68 50 	lds	r25, 0x5068
    1bd2:	20 91 a7 50 	lds	r18, 0x50A7
    1bd6:	30 91 a8 50 	lds	r19, 0x50A8
    1bda:	40 e0       	ldi	r20, 0x00	; 0
    1bdc:	50 e0       	ldi	r21, 0x00	; 0
    1bde:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    1be2:	dc 01       	movw	r26, r24
    1be4:	cb 01       	movw	r24, r22
    1be6:	9c 01       	movw	r18, r24
    1be8:	22 0f       	add	r18, r18
    1bea:	33 1f       	adc	r19, r19
    1bec:	22 0f       	add	r18, r18
    1bee:	33 1f       	adc	r19, r19
    1bf0:	80 91 63 50 	lds	r24, 0x5063
    1bf4:	90 91 64 50 	lds	r25, 0x5064
    1bf8:	82 0f       	add	r24, r18
    1bfa:	93 1f       	adc	r25, r19
    1bfc:	64 e0       	ldi	r22, 0x04	; 4
    1bfe:	70 e0       	ldi	r23, 0x00	; 0
    1c00:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
		}
		sampleCount++;
    1c04:	80 91 65 50 	lds	r24, 0x5065
    1c08:	90 91 66 50 	lds	r25, 0x5066
    1c0c:	a0 91 67 50 	lds	r26, 0x5067
    1c10:	b0 91 68 50 	lds	r27, 0x5068
    1c14:	01 96       	adiw	r24, 0x01	; 1
    1c16:	a1 1d       	adc	r26, r1
    1c18:	b1 1d       	adc	r27, r1
    1c1a:	80 93 65 50 	sts	0x5065, r24
    1c1e:	90 93 66 50 	sts	0x5066, r25
    1c22:	a0 93 67 50 	sts	0x5067, r26
    1c26:	b0 93 68 50 	sts	0x5068, r27
	}
}
    1c2a:	2c 96       	adiw	r28, 0x0c	; 12
    1c2c:	cd bf       	out	0x3d, r28	; 61
    1c2e:	de bf       	out	0x3e, r29	; 62
    1c30:	df 91       	pop	r29
    1c32:	cf 91       	pop	r28
    1c34:	ff 91       	pop	r31
    1c36:	ef 91       	pop	r30
    1c38:	bf 91       	pop	r27
    1c3a:	af 91       	pop	r26
    1c3c:	9f 91       	pop	r25
    1c3e:	8f 91       	pop	r24
    1c40:	7f 91       	pop	r23
    1c42:	6f 91       	pop	r22
    1c44:	5f 91       	pop	r21
    1c46:	4f 91       	pop	r20
    1c48:	3f 91       	pop	r19
    1c4a:	2f 91       	pop	r18
    1c4c:	1f 91       	pop	r17
    1c4e:	0f 91       	pop	r16
    1c50:	ff 90       	pop	r15
    1c52:	ef 90       	pop	r14
    1c54:	df 90       	pop	r13
    1c56:	cf 90       	pop	r12
    1c58:	bf 90       	pop	r11
    1c5a:	af 90       	pop	r10
    1c5c:	9f 90       	pop	r9
    1c5e:	8f 90       	pop	r8
    1c60:	7f 90       	pop	r7
    1c62:	6f 90       	pop	r6
    1c64:	0f 90       	pop	r0
    1c66:	0b be       	out	0x3b, r0	; 59
    1c68:	0f 90       	pop	r0
    1c6a:	0f be       	out	0x3f, r0	; 63
    1c6c:	0f 90       	pop	r0
    1c6e:	1f 90       	pop	r1
    1c70:	18 95       	reti

00001c72 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
    1c72:	88 23       	and	r24, r24
    1c74:	49 f0       	breq	.+18     	; 0x1c88 <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1c76:	80 e2       	ldi	r24, 0x20	; 32
    1c78:	60 e0       	ldi	r22, 0x00	; 0
    1c7a:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1c7e:	80 e2       	ldi	r24, 0x20	; 32
    1c80:	60 e0       	ldi	r22, 0x00	; 0
    1c82:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
    1c86:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1c88:	80 e2       	ldi	r24, 0x20	; 32
    1c8a:	60 e0       	ldi	r22, 0x00	; 0
    1c8c:	0e 94 0c 05 	call	0xa18	; 0xa18 <PortEx_DIRCLR>
    1c90:	08 95       	ret

00001c92 <__vector_14>:
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1c92:	1f 92       	push	r1
    1c94:	0f 92       	push	r0
    1c96:	0f b6       	in	r0, 0x3f	; 63
    1c98:	0f 92       	push	r0
    1c9a:	0b b6       	in	r0, 0x3b	; 59
    1c9c:	0f 92       	push	r0
    1c9e:	11 24       	eor	r1, r1
    1ca0:	6f 92       	push	r6
    1ca2:	7f 92       	push	r7
    1ca4:	8f 92       	push	r8
    1ca6:	9f 92       	push	r9
    1ca8:	af 92       	push	r10
    1caa:	bf 92       	push	r11
    1cac:	cf 92       	push	r12
    1cae:	df 92       	push	r13
    1cb0:	ef 92       	push	r14
    1cb2:	ff 92       	push	r15
    1cb4:	0f 93       	push	r16
    1cb6:	1f 93       	push	r17
    1cb8:	2f 93       	push	r18
    1cba:	3f 93       	push	r19
    1cbc:	4f 93       	push	r20
    1cbe:	5f 93       	push	r21
    1cc0:	6f 93       	push	r22
    1cc2:	7f 93       	push	r23
    1cc4:	8f 93       	push	r24
    1cc6:	9f 93       	push	r25
    1cc8:	af 93       	push	r26
    1cca:	bf 93       	push	r27
    1ccc:	ef 93       	push	r30
    1cce:	ff 93       	push	r31
    1cd0:	cf 93       	push	r28
    1cd2:	df 93       	push	r29
    1cd4:	cd b7       	in	r28, 0x3d	; 61
    1cd6:	de b7       	in	r29, 0x3e	; 62
    1cd8:	2c 97       	sbiw	r28, 0x0c	; 12
    1cda:	cd bf       	out	0x3d, r28	; 61
    1cdc:	de bf       	out	0x3e, r29	; 62
	volatile int64_t sum = 0;
    1cde:	19 82       	std	Y+1, r1	; 0x01
    1ce0:	1a 82       	std	Y+2, r1	; 0x02
    1ce2:	1b 82       	std	Y+3, r1	; 0x03
    1ce4:	1c 82       	std	Y+4, r1	; 0x04
    1ce6:	1d 82       	std	Y+5, r1	; 0x05
    1ce8:	1e 82       	std	Y+6, r1	; 0x06
    1cea:	1f 82       	std	Y+7, r1	; 0x07
    1cec:	18 86       	std	Y+8, r1	; 0x08
    1cee:	80 e0       	ldi	r24, 0x00	; 0
    1cf0:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1cf2:	20 e2       	ldi	r18, 0x20	; 32
    1cf4:	3e e3       	ldi	r19, 0x3E	; 62
    1cf6:	88 24       	eor	r8, r8
    1cf8:	8a 94       	dec	r8
    1cfa:	ac 01       	movw	r20, r24
    1cfc:	f9 01       	movw	r30, r18
    1cfe:	e8 0f       	add	r30, r24
    1d00:	f9 1f       	adc	r31, r25
    1d02:	60 81       	ld	r22, Z
    1d04:	66 23       	and	r22, r22
    1d06:	14 f4       	brge	.+4      	; 0x1d0c <__vector_14+0x7a>
    1d08:	8c 86       	std	Y+12, r8	; 0x0c
    1d0a:	01 c0       	rjmp	.+2      	; 0x1d0e <__vector_14+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1d0c:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1d0e:	42 0f       	add	r20, r18
    1d10:	53 1f       	adc	r21, r19
    1d12:	fa 01       	movw	r30, r20
    1d14:	40 81       	ld	r20, Z
    1d16:	4b 87       	std	Y+11, r20	; 0x0b
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1d18:	fc 01       	movw	r30, r24
    1d1a:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1d1c:	e2 0f       	add	r30, r18
    1d1e:	f3 1f       	adc	r31, r19
    1d20:	40 81       	ld	r20, Z
    1d22:	4a 87       	std	Y+10, r20	; 0x0a
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1d24:	fc 01       	movw	r30, r24
    1d26:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1d28:	e2 0f       	add	r30, r18
    1d2a:	f3 1f       	adc	r31, r19
    1d2c:	40 81       	ld	r20, Z
    1d2e:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    1d30:	49 85       	ldd	r20, Y+9	; 0x09
    1d32:	5a 85       	ldd	r21, Y+10	; 0x0a
    1d34:	6b 85       	ldd	r22, Y+11	; 0x0b
    1d36:	7c 85       	ldd	r23, Y+12	; 0x0c
    1d38:	a9 80       	ldd	r10, Y+1	; 0x01
    1d3a:	ba 80       	ldd	r11, Y+2	; 0x02
    1d3c:	cb 80       	ldd	r12, Y+3	; 0x03
    1d3e:	dc 80       	ldd	r13, Y+4	; 0x04
    1d40:	ed 80       	ldd	r14, Y+5	; 0x05
    1d42:	fe 80       	ldd	r15, Y+6	; 0x06
    1d44:	0f 81       	ldd	r16, Y+7	; 0x07
    1d46:	18 85       	ldd	r17, Y+8	; 0x08
    1d48:	b4 2f       	mov	r27, r20
    1d4a:	a5 2f       	mov	r26, r21
    1d4c:	f6 2f       	mov	r31, r22
    1d4e:	e7 2f       	mov	r30, r23
    1d50:	77 0f       	add	r23, r23
    1d52:	44 0b       	sbc	r20, r20
    1d54:	54 2f       	mov	r21, r20
    1d56:	ba 01       	movw	r22, r20
    1d58:	64 2e       	mov	r6, r20
    1d5a:	74 2e       	mov	r7, r20
    1d5c:	94 2e       	mov	r9, r20
    1d5e:	ab 0e       	add	r10, r27
    1d60:	61 e0       	ldi	r22, 0x01	; 1
    1d62:	ab 16       	cp	r10, r27
    1d64:	08 f0       	brcs	.+2      	; 0x1d68 <__vector_14+0xd6>
    1d66:	60 e0       	ldi	r22, 0x00	; 0
    1d68:	ba 0e       	add	r11, r26
    1d6a:	51 e0       	ldi	r21, 0x01	; 1
    1d6c:	ba 16       	cp	r11, r26
    1d6e:	08 f0       	brcs	.+2      	; 0x1d72 <__vector_14+0xe0>
    1d70:	50 e0       	ldi	r21, 0x00	; 0
    1d72:	a6 2f       	mov	r26, r22
    1d74:	ab 0d       	add	r26, r11
    1d76:	61 e0       	ldi	r22, 0x01	; 1
    1d78:	ab 15       	cp	r26, r11
    1d7a:	08 f0       	brcs	.+2      	; 0x1d7e <__vector_14+0xec>
    1d7c:	60 e0       	ldi	r22, 0x00	; 0
    1d7e:	56 2b       	or	r21, r22
    1d80:	cf 0e       	add	r12, r31
    1d82:	61 e0       	ldi	r22, 0x01	; 1
    1d84:	cf 16       	cp	r12, r31
    1d86:	08 f0       	brcs	.+2      	; 0x1d8a <__vector_14+0xf8>
    1d88:	60 e0       	ldi	r22, 0x00	; 0
    1d8a:	f5 2f       	mov	r31, r21
    1d8c:	fc 0d       	add	r31, r12
    1d8e:	51 e0       	ldi	r21, 0x01	; 1
    1d90:	fc 15       	cp	r31, r12
    1d92:	08 f0       	brcs	.+2      	; 0x1d96 <__vector_14+0x104>
    1d94:	50 e0       	ldi	r21, 0x00	; 0
    1d96:	65 2b       	or	r22, r21
    1d98:	de 0e       	add	r13, r30
    1d9a:	51 e0       	ldi	r21, 0x01	; 1
    1d9c:	de 16       	cp	r13, r30
    1d9e:	08 f0       	brcs	.+2      	; 0x1da2 <__vector_14+0x110>
    1da0:	50 e0       	ldi	r21, 0x00	; 0
    1da2:	e6 2f       	mov	r30, r22
    1da4:	ed 0d       	add	r30, r13
    1da6:	61 e0       	ldi	r22, 0x01	; 1
    1da8:	ed 15       	cp	r30, r13
    1daa:	08 f0       	brcs	.+2      	; 0x1dae <__vector_14+0x11c>
    1dac:	60 e0       	ldi	r22, 0x00	; 0
    1dae:	56 2b       	or	r21, r22
    1db0:	e6 0c       	add	r14, r6
    1db2:	71 e0       	ldi	r23, 0x01	; 1
    1db4:	e6 14       	cp	r14, r6
    1db6:	08 f0       	brcs	.+2      	; 0x1dba <__vector_14+0x128>
    1db8:	70 e0       	ldi	r23, 0x00	; 0
    1dba:	b5 2f       	mov	r27, r21
    1dbc:	be 0d       	add	r27, r14
    1dbe:	51 e0       	ldi	r21, 0x01	; 1
    1dc0:	be 15       	cp	r27, r14
    1dc2:	08 f0       	brcs	.+2      	; 0x1dc6 <__vector_14+0x134>
    1dc4:	50 e0       	ldi	r21, 0x00	; 0
    1dc6:	75 2b       	or	r23, r21
    1dc8:	f7 0c       	add	r15, r7
    1dca:	61 e0       	ldi	r22, 0x01	; 1
    1dcc:	f7 14       	cp	r15, r7
    1dce:	08 f0       	brcs	.+2      	; 0x1dd2 <__vector_14+0x140>
    1dd0:	60 e0       	ldi	r22, 0x00	; 0
    1dd2:	7f 0d       	add	r23, r15
    1dd4:	51 e0       	ldi	r21, 0x01	; 1
    1dd6:	7f 15       	cp	r23, r15
    1dd8:	08 f0       	brcs	.+2      	; 0x1ddc <__vector_14+0x14a>
    1dda:	50 e0       	ldi	r21, 0x00	; 0
    1ddc:	65 2b       	or	r22, r21
    1dde:	09 0d       	add	r16, r9
    1de0:	51 e0       	ldi	r21, 0x01	; 1
    1de2:	09 15       	cp	r16, r9
    1de4:	08 f0       	brcs	.+2      	; 0x1de8 <__vector_14+0x156>
    1de6:	50 e0       	ldi	r21, 0x00	; 0
    1de8:	60 0f       	add	r22, r16
    1dea:	ff 24       	eor	r15, r15
    1dec:	f3 94       	inc	r15
    1dee:	60 17       	cp	r22, r16
    1df0:	08 f0       	brcs	.+2      	; 0x1df4 <__vector_14+0x162>
    1df2:	ff 24       	eor	r15, r15
    1df4:	5f 29       	or	r21, r15
    1df6:	41 0f       	add	r20, r17
    1df8:	54 0f       	add	r21, r20
    1dfa:	a9 82       	std	Y+1, r10	; 0x01
    1dfc:	aa 83       	std	Y+2, r26	; 0x02
    1dfe:	fb 83       	std	Y+3, r31	; 0x03
    1e00:	ec 83       	std	Y+4, r30	; 0x04
    1e02:	bd 83       	std	Y+5, r27	; 0x05
    1e04:	7e 83       	std	Y+6, r23	; 0x06
    1e06:	6f 83       	std	Y+7, r22	; 0x07
    1e08:	58 87       	std	Y+8, r21	; 0x08
    1e0a:	03 96       	adiw	r24, 0x03	; 3
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1e0c:	8c 30       	cpi	r24, 0x0C	; 12
    1e0e:	91 05       	cpc	r25, r1
    1e10:	09 f0       	breq	.+2      	; 0x1e14 <__vector_14+0x182>
    1e12:	73 cf       	rjmp	.-282    	; 0x1cfa <__vector_14+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    1e14:	e9 80       	ldd	r14, Y+1	; 0x01
    1e16:	fa 80       	ldd	r15, Y+2	; 0x02
    1e18:	0b 81       	ldd	r16, Y+3	; 0x03
    1e1a:	1c 81       	ldd	r17, Y+4	; 0x04
    1e1c:	bd 81       	ldd	r27, Y+5	; 0x05
    1e1e:	ae 81       	ldd	r26, Y+6	; 0x06
    1e20:	ff 81       	ldd	r31, Y+7	; 0x07
    1e22:	e8 85       	ldd	r30, Y+8	; 0x08
    1e24:	2e 2d       	mov	r18, r14
    1e26:	3f 2d       	mov	r19, r15
    1e28:	40 2f       	mov	r20, r16
    1e2a:	51 2f       	mov	r21, r17
    1e2c:	6b 2f       	mov	r22, r27
    1e2e:	7a 2f       	mov	r23, r26
    1e30:	8f 2f       	mov	r24, r31
    1e32:	9e 2f       	mov	r25, r30
    1e34:	ee 23       	and	r30, r30
    1e36:	0c f0       	brlt	.+2      	; 0x1e3a <__vector_14+0x1a8>
    1e38:	4a c0       	rjmp	.+148    	; 0x1ece <__vector_14+0x23c>
    1e3a:	93 e0       	ldi	r25, 0x03	; 3
    1e3c:	e9 0e       	add	r14, r25
    1e3e:	91 e0       	ldi	r25, 0x01	; 1
    1e40:	e2 16       	cp	r14, r18
    1e42:	08 f0       	brcs	.+2      	; 0x1e46 <__vector_14+0x1b4>
    1e44:	90 e0       	ldi	r25, 0x00	; 0
    1e46:	21 e0       	ldi	r18, 0x01	; 1
    1e48:	f3 16       	cp	r15, r19
    1e4a:	08 f0       	brcs	.+2      	; 0x1e4e <__vector_14+0x1bc>
    1e4c:	20 e0       	ldi	r18, 0x00	; 0
    1e4e:	39 2f       	mov	r19, r25
    1e50:	3f 0d       	add	r19, r15
    1e52:	91 e0       	ldi	r25, 0x01	; 1
    1e54:	3f 15       	cp	r19, r15
    1e56:	08 f0       	brcs	.+2      	; 0x1e5a <__vector_14+0x1c8>
    1e58:	90 e0       	ldi	r25, 0x00	; 0
    1e5a:	29 2b       	or	r18, r25
    1e5c:	91 e0       	ldi	r25, 0x01	; 1
    1e5e:	04 17       	cp	r16, r20
    1e60:	08 f0       	brcs	.+2      	; 0x1e64 <__vector_14+0x1d2>
    1e62:	90 e0       	ldi	r25, 0x00	; 0
    1e64:	42 2f       	mov	r20, r18
    1e66:	40 0f       	add	r20, r16
    1e68:	21 e0       	ldi	r18, 0x01	; 1
    1e6a:	40 17       	cp	r20, r16
    1e6c:	08 f0       	brcs	.+2      	; 0x1e70 <__vector_14+0x1de>
    1e6e:	20 e0       	ldi	r18, 0x00	; 0
    1e70:	92 2b       	or	r25, r18
    1e72:	21 e0       	ldi	r18, 0x01	; 1
    1e74:	15 17       	cp	r17, r21
    1e76:	08 f0       	brcs	.+2      	; 0x1e7a <__vector_14+0x1e8>
    1e78:	20 e0       	ldi	r18, 0x00	; 0
    1e7a:	59 2f       	mov	r21, r25
    1e7c:	51 0f       	add	r21, r17
    1e7e:	91 e0       	ldi	r25, 0x01	; 1
    1e80:	51 17       	cp	r21, r17
    1e82:	08 f0       	brcs	.+2      	; 0x1e86 <__vector_14+0x1f4>
    1e84:	90 e0       	ldi	r25, 0x00	; 0
    1e86:	29 2b       	or	r18, r25
    1e88:	91 e0       	ldi	r25, 0x01	; 1
    1e8a:	b6 17       	cp	r27, r22
    1e8c:	08 f0       	brcs	.+2      	; 0x1e90 <__vector_14+0x1fe>
    1e8e:	90 e0       	ldi	r25, 0x00	; 0
    1e90:	62 2f       	mov	r22, r18
    1e92:	6b 0f       	add	r22, r27
    1e94:	21 e0       	ldi	r18, 0x01	; 1
    1e96:	6b 17       	cp	r22, r27
    1e98:	08 f0       	brcs	.+2      	; 0x1e9c <__vector_14+0x20a>
    1e9a:	20 e0       	ldi	r18, 0x00	; 0
    1e9c:	92 2b       	or	r25, r18
    1e9e:	21 e0       	ldi	r18, 0x01	; 1
    1ea0:	a7 17       	cp	r26, r23
    1ea2:	08 f0       	brcs	.+2      	; 0x1ea6 <__vector_14+0x214>
    1ea4:	20 e0       	ldi	r18, 0x00	; 0
    1ea6:	79 2f       	mov	r23, r25
    1ea8:	7a 0f       	add	r23, r26
    1eaa:	91 e0       	ldi	r25, 0x01	; 1
    1eac:	7a 17       	cp	r23, r26
    1eae:	08 f0       	brcs	.+2      	; 0x1eb2 <__vector_14+0x220>
    1eb0:	90 e0       	ldi	r25, 0x00	; 0
    1eb2:	29 2b       	or	r18, r25
    1eb4:	91 e0       	ldi	r25, 0x01	; 1
    1eb6:	f8 17       	cp	r31, r24
    1eb8:	08 f0       	brcs	.+2      	; 0x1ebc <__vector_14+0x22a>
    1eba:	90 e0       	ldi	r25, 0x00	; 0
    1ebc:	82 2f       	mov	r24, r18
    1ebe:	8f 0f       	add	r24, r31
    1ec0:	21 e0       	ldi	r18, 0x01	; 1
    1ec2:	8f 17       	cp	r24, r31
    1ec4:	08 f0       	brcs	.+2      	; 0x1ec8 <__vector_14+0x236>
    1ec6:	20 e0       	ldi	r18, 0x00	; 0
    1ec8:	92 2b       	or	r25, r18
    1eca:	2e 2d       	mov	r18, r14
    1ecc:	9e 0f       	add	r25, r30
    1ece:	02 e0       	ldi	r16, 0x02	; 2
    1ed0:	0e 94 52 2f 	call	0x5ea4	; 0x5ea4 <__ashrdi3>
    1ed4:	29 83       	std	Y+1, r18	; 0x01
    1ed6:	3a 83       	std	Y+2, r19	; 0x02
    1ed8:	4b 83       	std	Y+3, r20	; 0x03
    1eda:	5c 83       	std	Y+4, r21	; 0x04
    1edc:	6d 83       	std	Y+5, r22	; 0x05
    1ede:	7e 83       	std	Y+6, r23	; 0x06
    1ee0:	8f 83       	std	Y+7, r24	; 0x07
    1ee2:	98 87       	std	Y+8, r25	; 0x08
	ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1ee4:	60 91 65 50 	lds	r22, 0x5065
    1ee8:	70 91 66 50 	lds	r23, 0x5066
    1eec:	80 91 67 50 	lds	r24, 0x5067
    1ef0:	90 91 68 50 	lds	r25, 0x5068
    1ef4:	19 81       	ldd	r17, Y+1	; 0x01
    1ef6:	0a 81       	ldd	r16, Y+2	; 0x02
    1ef8:	fb 80       	ldd	r15, Y+3	; 0x03
    1efa:	ec 80       	ldd	r14, Y+4	; 0x04
    1efc:	dd 80       	ldd	r13, Y+5	; 0x05
    1efe:	ce 80       	ldd	r12, Y+6	; 0x06
    1f00:	bf 80       	ldd	r11, Y+7	; 0x07
    1f02:	a8 84       	ldd	r10, Y+8	; 0x08
    1f04:	20 91 a7 50 	lds	r18, 0x50A7
    1f08:	30 91 a8 50 	lds	r19, 0x50A8
    1f0c:	40 e0       	ldi	r20, 0x00	; 0
    1f0e:	50 e0       	ldi	r21, 0x00	; 0
    1f10:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    1f14:	dc 01       	movw	r26, r24
    1f16:	cb 01       	movw	r24, r22
    1f18:	88 0f       	add	r24, r24
    1f1a:	99 1f       	adc	r25, r25
    1f1c:	88 0f       	add	r24, r24
    1f1e:	99 1f       	adc	r25, r25
    1f20:	80 90 63 50 	lds	r8, 0x5063
    1f24:	90 90 64 50 	lds	r9, 0x5064
    1f28:	88 0e       	add	r8, r24
    1f2a:	99 1e       	adc	r9, r25
    1f2c:	21 2f       	mov	r18, r17
    1f2e:	30 2f       	mov	r19, r16
    1f30:	4f 2d       	mov	r20, r15
    1f32:	5e 2d       	mov	r21, r14
    1f34:	6d 2d       	mov	r22, r13
    1f36:	7c 2d       	mov	r23, r12
    1f38:	8b 2d       	mov	r24, r11
    1f3a:	9a 2d       	mov	r25, r10
    1f3c:	0f 2e       	mov	r0, r31
    1f3e:	f0 ea       	ldi	r31, 0xA0	; 160
    1f40:	af 2e       	mov	r10, r31
    1f42:	f0 2d       	mov	r31, r0
    1f44:	0f 2e       	mov	r0, r31
    1f46:	f5 e2       	ldi	r31, 0x25	; 37
    1f48:	bf 2e       	mov	r11, r31
    1f4a:	f0 2d       	mov	r31, r0
    1f4c:	0f 2e       	mov	r0, r31
    1f4e:	f6 e2       	ldi	r31, 0x26	; 38
    1f50:	cf 2e       	mov	r12, r31
    1f52:	f0 2d       	mov	r31, r0
    1f54:	dd 24       	eor	r13, r13
    1f56:	ee 24       	eor	r14, r14
    1f58:	ff 24       	eor	r15, r15
    1f5a:	00 e0       	ldi	r16, 0x00	; 0
    1f5c:	10 e0       	ldi	r17, 0x00	; 0
    1f5e:	0e 94 0b 2e 	call	0x5c16	; 0x5c16 <__muldi3>
    1f62:	aa 24       	eor	r10, r10
    1f64:	aa 94       	dec	r10
    1f66:	bb 24       	eor	r11, r11
    1f68:	ba 94       	dec	r11
    1f6a:	0f 2e       	mov	r0, r31
    1f6c:	ff e7       	ldi	r31, 0x7F	; 127
    1f6e:	cf 2e       	mov	r12, r31
    1f70:	f0 2d       	mov	r31, r0
    1f72:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <__divdi3>
    1f76:	01 e0       	ldi	r16, 0x01	; 1
    1f78:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <__ashldi3>
    1f7c:	0f 2e       	mov	r0, r31
    1f7e:	f3 e0       	ldi	r31, 0x03	; 3
    1f80:	af 2e       	mov	r10, r31
    1f82:	f0 2d       	mov	r31, r0
    1f84:	bb 24       	eor	r11, r11
    1f86:	cc 24       	eor	r12, r12
    1f88:	00 e0       	ldi	r16, 0x00	; 0
    1f8a:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <__divdi3>
    1f8e:	f4 01       	movw	r30, r8
    1f90:	20 83       	st	Z, r18
    1f92:	31 83       	std	Z+1, r19	; 0x01
    1f94:	42 83       	std	Z+2, r20	; 0x02
    1f96:	53 83       	std	Z+3, r21	; 0x03
	if(write_to_FRAM){
    1f98:	80 91 48 40 	lds	r24, 0x4048
    1f9c:	88 23       	and	r24, r24
    1f9e:	09 f1       	breq	.+66     	; 0x1fe2 <__vector_14+0x350>
		writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    1fa0:	60 91 65 50 	lds	r22, 0x5065
    1fa4:	70 91 66 50 	lds	r23, 0x5066
    1fa8:	80 91 67 50 	lds	r24, 0x5067
    1fac:	90 91 68 50 	lds	r25, 0x5068
    1fb0:	20 91 a7 50 	lds	r18, 0x50A7
    1fb4:	30 91 a8 50 	lds	r19, 0x50A8
    1fb8:	40 e0       	ldi	r20, 0x00	; 0
    1fba:	50 e0       	ldi	r21, 0x00	; 0
    1fbc:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    1fc0:	dc 01       	movw	r26, r24
    1fc2:	cb 01       	movw	r24, r22
    1fc4:	9c 01       	movw	r18, r24
    1fc6:	22 0f       	add	r18, r18
    1fc8:	33 1f       	adc	r19, r19
    1fca:	22 0f       	add	r18, r18
    1fcc:	33 1f       	adc	r19, r19
    1fce:	80 91 63 50 	lds	r24, 0x5063
    1fd2:	90 91 64 50 	lds	r25, 0x5064
    1fd6:	82 0f       	add	r24, r18
    1fd8:	93 1f       	adc	r25, r19
    1fda:	64 e0       	ldi	r22, 0x04	; 4
    1fdc:	70 e0       	ldi	r23, 0x00	; 0
    1fde:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
	}
	sampleCount++;
    1fe2:	80 91 65 50 	lds	r24, 0x5065
    1fe6:	90 91 66 50 	lds	r25, 0x5066
    1fea:	a0 91 67 50 	lds	r26, 0x5067
    1fee:	b0 91 68 50 	lds	r27, 0x5068
    1ff2:	01 96       	adiw	r24, 0x01	; 1
    1ff4:	a1 1d       	adc	r26, r1
    1ff6:	b1 1d       	adc	r27, r1
    1ff8:	80 93 65 50 	sts	0x5065, r24
    1ffc:	90 93 66 50 	sts	0x5066, r25
    2000:	a0 93 67 50 	sts	0x5067, r26
    2004:	b0 93 68 50 	sts	0x5068, r27

}
    2008:	2c 96       	adiw	r28, 0x0c	; 12
    200a:	cd bf       	out	0x3d, r28	; 61
    200c:	de bf       	out	0x3e, r29	; 62
    200e:	df 91       	pop	r29
    2010:	cf 91       	pop	r28
    2012:	ff 91       	pop	r31
    2014:	ef 91       	pop	r30
    2016:	bf 91       	pop	r27
    2018:	af 91       	pop	r26
    201a:	9f 91       	pop	r25
    201c:	8f 91       	pop	r24
    201e:	7f 91       	pop	r23
    2020:	6f 91       	pop	r22
    2022:	5f 91       	pop	r21
    2024:	4f 91       	pop	r20
    2026:	3f 91       	pop	r19
    2028:	2f 91       	pop	r18
    202a:	1f 91       	pop	r17
    202c:	0f 91       	pop	r16
    202e:	ff 90       	pop	r15
    2030:	ef 90       	pop	r14
    2032:	df 90       	pop	r13
    2034:	cf 90       	pop	r12
    2036:	bf 90       	pop	r11
    2038:	af 90       	pop	r10
    203a:	9f 90       	pop	r9
    203c:	8f 90       	pop	r8
    203e:	7f 90       	pop	r7
    2040:	6f 90       	pop	r6
    2042:	0f 90       	pop	r0
    2044:	0b be       	out	0x3b, r0	; 59
    2046:	0f 90       	pop	r0
    2048:	0f be       	out	0x3f, r0	; 63
    204a:	0f 90       	pop	r0
    204c:	1f 90       	pop	r1
    204e:	18 95       	reti

00002050 <__vector_77>:
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    2050:	1f 92       	push	r1
    2052:	0f 92       	push	r0
    2054:	0f b6       	in	r0, 0x3f	; 63
    2056:	0f 92       	push	r0
    2058:	0b b6       	in	r0, 0x3b	; 59
    205a:	0f 92       	push	r0
    205c:	11 24       	eor	r1, r1
    205e:	6f 92       	push	r6
    2060:	7f 92       	push	r7
    2062:	8f 92       	push	r8
    2064:	9f 92       	push	r9
    2066:	af 92       	push	r10
    2068:	bf 92       	push	r11
    206a:	cf 92       	push	r12
    206c:	df 92       	push	r13
    206e:	ef 92       	push	r14
    2070:	ff 92       	push	r15
    2072:	0f 93       	push	r16
    2074:	1f 93       	push	r17
    2076:	2f 93       	push	r18
    2078:	3f 93       	push	r19
    207a:	4f 93       	push	r20
    207c:	5f 93       	push	r21
    207e:	6f 93       	push	r22
    2080:	7f 93       	push	r23
    2082:	8f 93       	push	r24
    2084:	9f 93       	push	r25
    2086:	af 93       	push	r26
    2088:	bf 93       	push	r27
    208a:	ef 93       	push	r30
    208c:	ff 93       	push	r31
    208e:	cf 93       	push	r28
    2090:	df 93       	push	r29
    2092:	cd b7       	in	r28, 0x3d	; 61
    2094:	de b7       	in	r29, 0x3e	; 62
    2096:	2c 97       	sbiw	r28, 0x0c	; 12
    2098:	cd bf       	out	0x3d, r28	; 61
    209a:	de bf       	out	0x3e, r29	; 62

	volatile int64_t sum = 0;
    209c:	19 82       	std	Y+1, r1	; 0x01
    209e:	1a 82       	std	Y+2, r1	; 0x02
    20a0:	1b 82       	std	Y+3, r1	; 0x03
    20a2:	1c 82       	std	Y+4, r1	; 0x04
    20a4:	1d 82       	std	Y+5, r1	; 0x05
    20a6:	1e 82       	std	Y+6, r1	; 0x06
    20a8:	1f 82       	std	Y+7, r1	; 0x07
    20aa:	18 86       	std	Y+8, r1	; 0x08
    20ac:	80 e0       	ldi	r24, 0x00	; 0
    20ae:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    20b0:	20 e2       	ldi	r18, 0x20	; 32
    20b2:	3e e3       	ldi	r19, 0x3E	; 62
    20b4:	88 24       	eor	r8, r8
    20b6:	8a 94       	dec	r8
    20b8:	ac 01       	movw	r20, r24
    20ba:	f9 01       	movw	r30, r18
    20bc:	e8 0f       	add	r30, r24
    20be:	f9 1f       	adc	r31, r25
    20c0:	60 81       	ld	r22, Z
    20c2:	66 23       	and	r22, r22
    20c4:	14 f4       	brge	.+4      	; 0x20ca <__vector_77+0x7a>
    20c6:	8c 86       	std	Y+12, r8	; 0x0c
    20c8:	01 c0       	rjmp	.+2      	; 0x20cc <__vector_77+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    20ca:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    20cc:	42 0f       	add	r20, r18
    20ce:	53 1f       	adc	r21, r19
    20d0:	fa 01       	movw	r30, r20
    20d2:	40 81       	ld	r20, Z
    20d4:	4b 87       	std	Y+11, r20	; 0x0b
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    20d6:	fc 01       	movw	r30, r24
    20d8:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    20da:	e2 0f       	add	r30, r18
    20dc:	f3 1f       	adc	r31, r19
    20de:	40 81       	ld	r20, Z
    20e0:	4a 87       	std	Y+10, r20	; 0x0a
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    20e2:	fc 01       	movw	r30, r24
    20e4:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    20e6:	e2 0f       	add	r30, r18
    20e8:	f3 1f       	adc	r31, r19
    20ea:	40 81       	ld	r20, Z
    20ec:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    20ee:	49 85       	ldd	r20, Y+9	; 0x09
    20f0:	5a 85       	ldd	r21, Y+10	; 0x0a
    20f2:	6b 85       	ldd	r22, Y+11	; 0x0b
    20f4:	7c 85       	ldd	r23, Y+12	; 0x0c
    20f6:	a9 80       	ldd	r10, Y+1	; 0x01
    20f8:	ba 80       	ldd	r11, Y+2	; 0x02
    20fa:	cb 80       	ldd	r12, Y+3	; 0x03
    20fc:	dc 80       	ldd	r13, Y+4	; 0x04
    20fe:	ed 80       	ldd	r14, Y+5	; 0x05
    2100:	fe 80       	ldd	r15, Y+6	; 0x06
    2102:	0f 81       	ldd	r16, Y+7	; 0x07
    2104:	18 85       	ldd	r17, Y+8	; 0x08
    2106:	b4 2f       	mov	r27, r20
    2108:	a5 2f       	mov	r26, r21
    210a:	f6 2f       	mov	r31, r22
    210c:	e7 2f       	mov	r30, r23
    210e:	77 0f       	add	r23, r23
    2110:	44 0b       	sbc	r20, r20
    2112:	54 2f       	mov	r21, r20
    2114:	ba 01       	movw	r22, r20
    2116:	64 2e       	mov	r6, r20
    2118:	74 2e       	mov	r7, r20
    211a:	94 2e       	mov	r9, r20
    211c:	ab 0e       	add	r10, r27
    211e:	61 e0       	ldi	r22, 0x01	; 1
    2120:	ab 16       	cp	r10, r27
    2122:	08 f0       	brcs	.+2      	; 0x2126 <__vector_77+0xd6>
    2124:	60 e0       	ldi	r22, 0x00	; 0
    2126:	ba 0e       	add	r11, r26
    2128:	51 e0       	ldi	r21, 0x01	; 1
    212a:	ba 16       	cp	r11, r26
    212c:	08 f0       	brcs	.+2      	; 0x2130 <__vector_77+0xe0>
    212e:	50 e0       	ldi	r21, 0x00	; 0
    2130:	a6 2f       	mov	r26, r22
    2132:	ab 0d       	add	r26, r11
    2134:	61 e0       	ldi	r22, 0x01	; 1
    2136:	ab 15       	cp	r26, r11
    2138:	08 f0       	brcs	.+2      	; 0x213c <__vector_77+0xec>
    213a:	60 e0       	ldi	r22, 0x00	; 0
    213c:	56 2b       	or	r21, r22
    213e:	cf 0e       	add	r12, r31
    2140:	61 e0       	ldi	r22, 0x01	; 1
    2142:	cf 16       	cp	r12, r31
    2144:	08 f0       	brcs	.+2      	; 0x2148 <__vector_77+0xf8>
    2146:	60 e0       	ldi	r22, 0x00	; 0
    2148:	f5 2f       	mov	r31, r21
    214a:	fc 0d       	add	r31, r12
    214c:	51 e0       	ldi	r21, 0x01	; 1
    214e:	fc 15       	cp	r31, r12
    2150:	08 f0       	brcs	.+2      	; 0x2154 <__vector_77+0x104>
    2152:	50 e0       	ldi	r21, 0x00	; 0
    2154:	65 2b       	or	r22, r21
    2156:	de 0e       	add	r13, r30
    2158:	51 e0       	ldi	r21, 0x01	; 1
    215a:	de 16       	cp	r13, r30
    215c:	08 f0       	brcs	.+2      	; 0x2160 <__vector_77+0x110>
    215e:	50 e0       	ldi	r21, 0x00	; 0
    2160:	e6 2f       	mov	r30, r22
    2162:	ed 0d       	add	r30, r13
    2164:	61 e0       	ldi	r22, 0x01	; 1
    2166:	ed 15       	cp	r30, r13
    2168:	08 f0       	brcs	.+2      	; 0x216c <__vector_77+0x11c>
    216a:	60 e0       	ldi	r22, 0x00	; 0
    216c:	56 2b       	or	r21, r22
    216e:	e6 0c       	add	r14, r6
    2170:	71 e0       	ldi	r23, 0x01	; 1
    2172:	e6 14       	cp	r14, r6
    2174:	08 f0       	brcs	.+2      	; 0x2178 <__vector_77+0x128>
    2176:	70 e0       	ldi	r23, 0x00	; 0
    2178:	b5 2f       	mov	r27, r21
    217a:	be 0d       	add	r27, r14
    217c:	51 e0       	ldi	r21, 0x01	; 1
    217e:	be 15       	cp	r27, r14
    2180:	08 f0       	brcs	.+2      	; 0x2184 <__vector_77+0x134>
    2182:	50 e0       	ldi	r21, 0x00	; 0
    2184:	75 2b       	or	r23, r21
    2186:	f7 0c       	add	r15, r7
    2188:	61 e0       	ldi	r22, 0x01	; 1
    218a:	f7 14       	cp	r15, r7
    218c:	08 f0       	brcs	.+2      	; 0x2190 <__vector_77+0x140>
    218e:	60 e0       	ldi	r22, 0x00	; 0
    2190:	7f 0d       	add	r23, r15
    2192:	51 e0       	ldi	r21, 0x01	; 1
    2194:	7f 15       	cp	r23, r15
    2196:	08 f0       	brcs	.+2      	; 0x219a <__vector_77+0x14a>
    2198:	50 e0       	ldi	r21, 0x00	; 0
    219a:	65 2b       	or	r22, r21
    219c:	09 0d       	add	r16, r9
    219e:	51 e0       	ldi	r21, 0x01	; 1
    21a0:	09 15       	cp	r16, r9
    21a2:	08 f0       	brcs	.+2      	; 0x21a6 <__vector_77+0x156>
    21a4:	50 e0       	ldi	r21, 0x00	; 0
    21a6:	60 0f       	add	r22, r16
    21a8:	ff 24       	eor	r15, r15
    21aa:	f3 94       	inc	r15
    21ac:	60 17       	cp	r22, r16
    21ae:	08 f0       	brcs	.+2      	; 0x21b2 <__vector_77+0x162>
    21b0:	ff 24       	eor	r15, r15
    21b2:	5f 29       	or	r21, r15
    21b4:	41 0f       	add	r20, r17
    21b6:	54 0f       	add	r21, r20
    21b8:	a9 82       	std	Y+1, r10	; 0x01
    21ba:	aa 83       	std	Y+2, r26	; 0x02
    21bc:	fb 83       	std	Y+3, r31	; 0x03
    21be:	ec 83       	std	Y+4, r30	; 0x04
    21c0:	bd 83       	std	Y+5, r27	; 0x05
    21c2:	7e 83       	std	Y+6, r23	; 0x06
    21c4:	6f 83       	std	Y+7, r22	; 0x07
    21c6:	58 87       	std	Y+8, r21	; 0x08
    21c8:	03 96       	adiw	r24, 0x03	; 3
ISR(TCD0_OVF_vect) {

	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    21ca:	8c 30       	cpi	r24, 0x0C	; 12
    21cc:	91 05       	cpc	r25, r1
    21ce:	09 f0       	breq	.+2      	; 0x21d2 <__vector_77+0x182>
    21d0:	73 cf       	rjmp	.-282    	; 0x20b8 <__vector_77+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    21d2:	e9 80       	ldd	r14, Y+1	; 0x01
    21d4:	fa 80       	ldd	r15, Y+2	; 0x02
    21d6:	0b 81       	ldd	r16, Y+3	; 0x03
    21d8:	1c 81       	ldd	r17, Y+4	; 0x04
    21da:	bd 81       	ldd	r27, Y+5	; 0x05
    21dc:	ae 81       	ldd	r26, Y+6	; 0x06
    21de:	ff 81       	ldd	r31, Y+7	; 0x07
    21e0:	e8 85       	ldd	r30, Y+8	; 0x08
    21e2:	2e 2d       	mov	r18, r14
    21e4:	3f 2d       	mov	r19, r15
    21e6:	40 2f       	mov	r20, r16
    21e8:	51 2f       	mov	r21, r17
    21ea:	6b 2f       	mov	r22, r27
    21ec:	7a 2f       	mov	r23, r26
    21ee:	8f 2f       	mov	r24, r31
    21f0:	9e 2f       	mov	r25, r30
    21f2:	ee 23       	and	r30, r30
    21f4:	0c f0       	brlt	.+2      	; 0x21f8 <__vector_77+0x1a8>
    21f6:	4a c0       	rjmp	.+148    	; 0x228c <__vector_77+0x23c>
    21f8:	93 e0       	ldi	r25, 0x03	; 3
    21fa:	e9 0e       	add	r14, r25
    21fc:	91 e0       	ldi	r25, 0x01	; 1
    21fe:	e2 16       	cp	r14, r18
    2200:	08 f0       	brcs	.+2      	; 0x2204 <__vector_77+0x1b4>
    2202:	90 e0       	ldi	r25, 0x00	; 0
    2204:	21 e0       	ldi	r18, 0x01	; 1
    2206:	f3 16       	cp	r15, r19
    2208:	08 f0       	brcs	.+2      	; 0x220c <__vector_77+0x1bc>
    220a:	20 e0       	ldi	r18, 0x00	; 0
    220c:	39 2f       	mov	r19, r25
    220e:	3f 0d       	add	r19, r15
    2210:	91 e0       	ldi	r25, 0x01	; 1
    2212:	3f 15       	cp	r19, r15
    2214:	08 f0       	brcs	.+2      	; 0x2218 <__vector_77+0x1c8>
    2216:	90 e0       	ldi	r25, 0x00	; 0
    2218:	29 2b       	or	r18, r25
    221a:	91 e0       	ldi	r25, 0x01	; 1
    221c:	04 17       	cp	r16, r20
    221e:	08 f0       	brcs	.+2      	; 0x2222 <__vector_77+0x1d2>
    2220:	90 e0       	ldi	r25, 0x00	; 0
    2222:	42 2f       	mov	r20, r18
    2224:	40 0f       	add	r20, r16
    2226:	21 e0       	ldi	r18, 0x01	; 1
    2228:	40 17       	cp	r20, r16
    222a:	08 f0       	brcs	.+2      	; 0x222e <__vector_77+0x1de>
    222c:	20 e0       	ldi	r18, 0x00	; 0
    222e:	92 2b       	or	r25, r18
    2230:	21 e0       	ldi	r18, 0x01	; 1
    2232:	15 17       	cp	r17, r21
    2234:	08 f0       	brcs	.+2      	; 0x2238 <__vector_77+0x1e8>
    2236:	20 e0       	ldi	r18, 0x00	; 0
    2238:	59 2f       	mov	r21, r25
    223a:	51 0f       	add	r21, r17
    223c:	91 e0       	ldi	r25, 0x01	; 1
    223e:	51 17       	cp	r21, r17
    2240:	08 f0       	brcs	.+2      	; 0x2244 <__vector_77+0x1f4>
    2242:	90 e0       	ldi	r25, 0x00	; 0
    2244:	29 2b       	or	r18, r25
    2246:	91 e0       	ldi	r25, 0x01	; 1
    2248:	b6 17       	cp	r27, r22
    224a:	08 f0       	brcs	.+2      	; 0x224e <__vector_77+0x1fe>
    224c:	90 e0       	ldi	r25, 0x00	; 0
    224e:	62 2f       	mov	r22, r18
    2250:	6b 0f       	add	r22, r27
    2252:	21 e0       	ldi	r18, 0x01	; 1
    2254:	6b 17       	cp	r22, r27
    2256:	08 f0       	brcs	.+2      	; 0x225a <__vector_77+0x20a>
    2258:	20 e0       	ldi	r18, 0x00	; 0
    225a:	92 2b       	or	r25, r18
    225c:	21 e0       	ldi	r18, 0x01	; 1
    225e:	a7 17       	cp	r26, r23
    2260:	08 f0       	brcs	.+2      	; 0x2264 <__vector_77+0x214>
    2262:	20 e0       	ldi	r18, 0x00	; 0
    2264:	79 2f       	mov	r23, r25
    2266:	7a 0f       	add	r23, r26
    2268:	91 e0       	ldi	r25, 0x01	; 1
    226a:	7a 17       	cp	r23, r26
    226c:	08 f0       	brcs	.+2      	; 0x2270 <__vector_77+0x220>
    226e:	90 e0       	ldi	r25, 0x00	; 0
    2270:	29 2b       	or	r18, r25
    2272:	91 e0       	ldi	r25, 0x01	; 1
    2274:	f8 17       	cp	r31, r24
    2276:	08 f0       	brcs	.+2      	; 0x227a <__vector_77+0x22a>
    2278:	90 e0       	ldi	r25, 0x00	; 0
    227a:	82 2f       	mov	r24, r18
    227c:	8f 0f       	add	r24, r31
    227e:	21 e0       	ldi	r18, 0x01	; 1
    2280:	8f 17       	cp	r24, r31
    2282:	08 f0       	brcs	.+2      	; 0x2286 <__vector_77+0x236>
    2284:	20 e0       	ldi	r18, 0x00	; 0
    2286:	92 2b       	or	r25, r18
    2288:	2e 2d       	mov	r18, r14
    228a:	9e 0f       	add	r25, r30
    228c:	02 e0       	ldi	r16, 0x02	; 2
    228e:	0e 94 52 2f 	call	0x5ea4	; 0x5ea4 <__ashrdi3>
    2292:	29 83       	std	Y+1, r18	; 0x01
    2294:	3a 83       	std	Y+2, r19	; 0x02
    2296:	4b 83       	std	Y+3, r20	; 0x03
    2298:	5c 83       	std	Y+4, r21	; 0x04
    229a:	6d 83       	std	Y+5, r22	; 0x05
    229c:	7e 83       	std	Y+6, r23	; 0x06
    229e:	8f 83       	std	Y+7, r24	; 0x07
    22a0:	98 87       	std	Y+8, r25	; 0x08
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    22a2:	60 91 65 50 	lds	r22, 0x5065
    22a6:	70 91 66 50 	lds	r23, 0x5066
    22aa:	80 91 67 50 	lds	r24, 0x5067
    22ae:	90 91 68 50 	lds	r25, 0x5068
    22b2:	19 81       	ldd	r17, Y+1	; 0x01
    22b4:	0a 81       	ldd	r16, Y+2	; 0x02
    22b6:	fb 80       	ldd	r15, Y+3	; 0x03
    22b8:	ec 80       	ldd	r14, Y+4	; 0x04
    22ba:	dd 80       	ldd	r13, Y+5	; 0x05
    22bc:	ce 80       	ldd	r12, Y+6	; 0x06
    22be:	bf 80       	ldd	r11, Y+7	; 0x07
    22c0:	a8 84       	ldd	r10, Y+8	; 0x08
    22c2:	20 91 a7 50 	lds	r18, 0x50A7
    22c6:	30 91 a8 50 	lds	r19, 0x50A8
    22ca:	40 e0       	ldi	r20, 0x00	; 0
    22cc:	50 e0       	ldi	r21, 0x00	; 0
    22ce:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    22d2:	dc 01       	movw	r26, r24
    22d4:	cb 01       	movw	r24, r22
    22d6:	88 0f       	add	r24, r24
    22d8:	99 1f       	adc	r25, r25
    22da:	88 0f       	add	r24, r24
    22dc:	99 1f       	adc	r25, r25
    22de:	80 90 63 50 	lds	r8, 0x5063
    22e2:	90 90 64 50 	lds	r9, 0x5064
    22e6:	88 0e       	add	r8, r24
    22e8:	99 1e       	adc	r9, r25
    22ea:	21 2f       	mov	r18, r17
    22ec:	30 2f       	mov	r19, r16
    22ee:	4f 2d       	mov	r20, r15
    22f0:	5e 2d       	mov	r21, r14
    22f2:	6d 2d       	mov	r22, r13
    22f4:	7c 2d       	mov	r23, r12
    22f6:	8b 2d       	mov	r24, r11
    22f8:	9a 2d       	mov	r25, r10
    22fa:	0f 2e       	mov	r0, r31
    22fc:	f0 ea       	ldi	r31, 0xA0	; 160
    22fe:	af 2e       	mov	r10, r31
    2300:	f0 2d       	mov	r31, r0
    2302:	0f 2e       	mov	r0, r31
    2304:	f5 e2       	ldi	r31, 0x25	; 37
    2306:	bf 2e       	mov	r11, r31
    2308:	f0 2d       	mov	r31, r0
    230a:	0f 2e       	mov	r0, r31
    230c:	f6 e2       	ldi	r31, 0x26	; 38
    230e:	cf 2e       	mov	r12, r31
    2310:	f0 2d       	mov	r31, r0
    2312:	dd 24       	eor	r13, r13
    2314:	ee 24       	eor	r14, r14
    2316:	ff 24       	eor	r15, r15
    2318:	00 e0       	ldi	r16, 0x00	; 0
    231a:	10 e0       	ldi	r17, 0x00	; 0
    231c:	0e 94 0b 2e 	call	0x5c16	; 0x5c16 <__muldi3>
    2320:	aa 24       	eor	r10, r10
    2322:	aa 94       	dec	r10
    2324:	bb 24       	eor	r11, r11
    2326:	ba 94       	dec	r11
    2328:	0f 2e       	mov	r0, r31
    232a:	ff e7       	ldi	r31, 0x7F	; 127
    232c:	cf 2e       	mov	r12, r31
    232e:	f0 2d       	mov	r31, r0
    2330:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <__divdi3>
    2334:	01 e0       	ldi	r16, 0x01	; 1
    2336:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <__ashldi3>
    233a:	0f 2e       	mov	r0, r31
    233c:	f3 e0       	ldi	r31, 0x03	; 3
    233e:	af 2e       	mov	r10, r31
    2340:	f0 2d       	mov	r31, r0
    2342:	bb 24       	eor	r11, r11
    2344:	cc 24       	eor	r12, r12
    2346:	00 e0       	ldi	r16, 0x00	; 0
    2348:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <__divdi3>
    234c:	f4 01       	movw	r30, r8
    234e:	20 83       	st	Z, r18
    2350:	31 83       	std	Z+1, r19	; 0x01
    2352:	42 83       	std	Z+2, r20	; 0x02
    2354:	53 83       	std	Z+3, r21	; 0x03
	if(write_to_FRAM){
    2356:	80 91 48 40 	lds	r24, 0x4048
    235a:	88 23       	and	r24, r24
    235c:	09 f1       	breq	.+66     	; 0x23a0 <__vector_77+0x350>
		writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    235e:	60 91 65 50 	lds	r22, 0x5065
    2362:	70 91 66 50 	lds	r23, 0x5066
    2366:	80 91 67 50 	lds	r24, 0x5067
    236a:	90 91 68 50 	lds	r25, 0x5068
    236e:	20 91 a7 50 	lds	r18, 0x50A7
    2372:	30 91 a8 50 	lds	r19, 0x50A8
    2376:	40 e0       	ldi	r20, 0x00	; 0
    2378:	50 e0       	ldi	r21, 0x00	; 0
    237a:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    237e:	dc 01       	movw	r26, r24
    2380:	cb 01       	movw	r24, r22
    2382:	9c 01       	movw	r18, r24
    2384:	22 0f       	add	r18, r18
    2386:	33 1f       	adc	r19, r19
    2388:	22 0f       	add	r18, r18
    238a:	33 1f       	adc	r19, r19
    238c:	80 91 63 50 	lds	r24, 0x5063
    2390:	90 91 64 50 	lds	r25, 0x5064
    2394:	82 0f       	add	r24, r18
    2396:	93 1f       	adc	r25, r19
    2398:	64 e0       	ldi	r22, 0x04	; 4
    239a:	70 e0       	ldi	r23, 0x00	; 0
    239c:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
	}
	sampleCount++;
    23a0:	80 91 65 50 	lds	r24, 0x5065
    23a4:	90 91 66 50 	lds	r25, 0x5066
    23a8:	a0 91 67 50 	lds	r26, 0x5067
    23ac:	b0 91 68 50 	lds	r27, 0x5068
    23b0:	01 96       	adiw	r24, 0x01	; 1
    23b2:	a1 1d       	adc	r26, r1
    23b4:	b1 1d       	adc	r27, r1
    23b6:	80 93 65 50 	sts	0x5065, r24
    23ba:	90 93 66 50 	sts	0x5066, r25
    23be:	a0 93 67 50 	sts	0x5067, r26
    23c2:	b0 93 68 50 	sts	0x5068, r27
}
    23c6:	2c 96       	adiw	r28, 0x0c	; 12
    23c8:	cd bf       	out	0x3d, r28	; 61
    23ca:	de bf       	out	0x3e, r29	; 62
    23cc:	df 91       	pop	r29
    23ce:	cf 91       	pop	r28
    23d0:	ff 91       	pop	r31
    23d2:	ef 91       	pop	r30
    23d4:	bf 91       	pop	r27
    23d6:	af 91       	pop	r26
    23d8:	9f 91       	pop	r25
    23da:	8f 91       	pop	r24
    23dc:	7f 91       	pop	r23
    23de:	6f 91       	pop	r22
    23e0:	5f 91       	pop	r21
    23e2:	4f 91       	pop	r20
    23e4:	3f 91       	pop	r19
    23e6:	2f 91       	pop	r18
    23e8:	1f 91       	pop	r17
    23ea:	0f 91       	pop	r16
    23ec:	ff 90       	pop	r15
    23ee:	ef 90       	pop	r14
    23f0:	df 90       	pop	r13
    23f2:	cf 90       	pop	r12
    23f4:	bf 90       	pop	r11
    23f6:	af 90       	pop	r10
    23f8:	9f 90       	pop	r9
    23fa:	8f 90       	pop	r8
    23fc:	7f 90       	pop	r7
    23fe:	6f 90       	pop	r6
    2400:	0f 90       	pop	r0
    2402:	0b be       	out	0x3b, r0	; 59
    2404:	0f 90       	pop	r0
    2406:	0f be       	out	0x3f, r0	; 63
    2408:	0f 90       	pop	r0
    240a:	1f 90       	pop	r1
    240c:	18 95       	reti

0000240e <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
	
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    240e:	82 e0       	ldi	r24, 0x02	; 2
    2410:	e0 ea       	ldi	r30, 0xA0	; 160
    2412:	f6 e0       	ldi	r31, 0x06	; 6
    2414:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2416:	8a ea       	ldi	r24, 0xAA	; 170
    2418:	e0 ec       	ldi	r30, 0xC0	; 192
    241a:	f8 e0       	ldi	r31, 0x08	; 8
    241c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    241e:	82 81       	ldd	r24, Z+2	; 0x02
    2420:	88 23       	and	r24, r24
    2422:	ec f7       	brge	.-6      	; 0x241e <sampleCurrentChannel+0x10>
	SPIBuffer[SPICount] = SPIC.DATA;
    2424:	90 91 a0 50 	lds	r25, 0x50A0
    2428:	e0 ec       	ldi	r30, 0xC0	; 192
    242a:	f8 e0       	ldi	r31, 0x08	; 8
    242c:	83 81       	ldd	r24, Z+3	; 0x03
    242e:	a0 e2       	ldi	r26, 0x20	; 32
    2430:	be e3       	ldi	r27, 0x3E	; 62
    2432:	a9 0f       	add	r26, r25
    2434:	b1 1d       	adc	r27, r1
    2436:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2438:	8a ea       	ldi	r24, 0xAA	; 170
    243a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    243c:	82 81       	ldd	r24, Z+2	; 0x02
    243e:	88 23       	and	r24, r24
    2440:	ec f7       	brge	.-6      	; 0x243c <sampleCurrentChannel+0x2e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    2442:	a0 91 a0 50 	lds	r26, 0x50A0
    2446:	b0 e0       	ldi	r27, 0x00	; 0
    2448:	e0 ec       	ldi	r30, 0xC0	; 192
    244a:	f8 e0       	ldi	r31, 0x08	; 8
    244c:	83 81       	ldd	r24, Z+3	; 0x03
    244e:	af 5d       	subi	r26, 0xDF	; 223
    2450:	b1 4c       	sbci	r27, 0xC1	; 193
    2452:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2454:	8a ea       	ldi	r24, 0xAA	; 170
    2456:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2458:	82 81       	ldd	r24, Z+2	; 0x02
    245a:	88 23       	and	r24, r24
    245c:	ec f7       	brge	.-6      	; 0x2458 <sampleCurrentChannel+0x4a>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    245e:	e0 91 a0 50 	lds	r30, 0x50A0
    2462:	f0 e0       	ldi	r31, 0x00	; 0
    2464:	a0 ec       	ldi	r26, 0xC0	; 192
    2466:	b8 e0       	ldi	r27, 0x08	; 8
    2468:	13 96       	adiw	r26, 0x03	; 3
    246a:	8c 91       	ld	r24, X
    246c:	13 97       	sbiw	r26, 0x03	; 3
    246e:	ee 5d       	subi	r30, 0xDE	; 222
    2470:	f1 4c       	sbci	r31, 0xC1	; 193
    2472:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2474:	82 e0       	ldi	r24, 0x02	; 2
    2476:	e0 ea       	ldi	r30, 0xA0	; 160
    2478:	f6 e0       	ldi	r31, 0x06	; 6
    247a:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
    247c:	80 91 a0 50 	lds	r24, 0x50A0
    2480:	8d 5f       	subi	r24, 0xFD	; 253
    2482:	80 93 a0 50 	sts	0x50A0, r24
}
    2486:	08 95       	ret

00002488 <__vector_82>:
ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point
ISR(TCD0_CCD_vect) {
    2488:	1f 92       	push	r1
    248a:	0f 92       	push	r0
    248c:	0f b6       	in	r0, 0x3f	; 63
    248e:	0f 92       	push	r0
    2490:	0b b6       	in	r0, 0x3b	; 59
    2492:	0f 92       	push	r0
    2494:	11 24       	eor	r1, r1
    2496:	2f 93       	push	r18
    2498:	3f 93       	push	r19
    249a:	4f 93       	push	r20
    249c:	5f 93       	push	r21
    249e:	6f 93       	push	r22
    24a0:	7f 93       	push	r23
    24a2:	8f 93       	push	r24
    24a4:	9f 93       	push	r25
    24a6:	af 93       	push	r26
    24a8:	bf 93       	push	r27
    24aa:	ef 93       	push	r30
    24ac:	ff 93       	push	r31
	sampleCurrentChannel();
    24ae:	0e 94 07 12 	call	0x240e	; 0x240e <sampleCurrentChannel>
	SPICount = 0;
    24b2:	10 92 a0 50 	sts	0x50A0, r1
}
    24b6:	ff 91       	pop	r31
    24b8:	ef 91       	pop	r30
    24ba:	bf 91       	pop	r27
    24bc:	af 91       	pop	r26
    24be:	9f 91       	pop	r25
    24c0:	8f 91       	pop	r24
    24c2:	7f 91       	pop	r23
    24c4:	6f 91       	pop	r22
    24c6:	5f 91       	pop	r21
    24c8:	4f 91       	pop	r20
    24ca:	3f 91       	pop	r19
    24cc:	2f 91       	pop	r18
    24ce:	0f 90       	pop	r0
    24d0:	0b be       	out	0x3b, r0	; 59
    24d2:	0f 90       	pop	r0
    24d4:	0f be       	out	0x3f, r0	; 63
    24d6:	0f 90       	pop	r0
    24d8:	1f 90       	pop	r1
    24da:	18 95       	reti

000024dc <__vector_81>:
ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCD0_CCC_vect) {
    24dc:	1f 92       	push	r1
    24de:	0f 92       	push	r0
    24e0:	0f b6       	in	r0, 0x3f	; 63
    24e2:	0f 92       	push	r0
    24e4:	0b b6       	in	r0, 0x3b	; 59
    24e6:	0f 92       	push	r0
    24e8:	11 24       	eor	r1, r1
    24ea:	2f 93       	push	r18
    24ec:	3f 93       	push	r19
    24ee:	4f 93       	push	r20
    24f0:	5f 93       	push	r21
    24f2:	6f 93       	push	r22
    24f4:	7f 93       	push	r23
    24f6:	8f 93       	push	r24
    24f8:	9f 93       	push	r25
    24fa:	af 93       	push	r26
    24fc:	bf 93       	push	r27
    24fe:	ef 93       	push	r30
    2500:	ff 93       	push	r31
	sampleCurrentChannel();
    2502:	0e 94 07 12 	call	0x240e	; 0x240e <sampleCurrentChannel>
}
    2506:	ff 91       	pop	r31
    2508:	ef 91       	pop	r30
    250a:	bf 91       	pop	r27
    250c:	af 91       	pop	r26
    250e:	9f 91       	pop	r25
    2510:	8f 91       	pop	r24
    2512:	7f 91       	pop	r23
    2514:	6f 91       	pop	r22
    2516:	5f 91       	pop	r21
    2518:	4f 91       	pop	r20
    251a:	3f 91       	pop	r19
    251c:	2f 91       	pop	r18
    251e:	0f 90       	pop	r0
    2520:	0b be       	out	0x3b, r0	; 59
    2522:	0f 90       	pop	r0
    2524:	0f be       	out	0x3f, r0	; 63
    2526:	0f 90       	pop	r0
    2528:	1f 90       	pop	r1
    252a:	18 95       	reti

0000252c <__vector_80>:
//first averaging point
ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}
//second averaging point
ISR(TCD0_CCB_vect) {
    252c:	1f 92       	push	r1
    252e:	0f 92       	push	r0
    2530:	0f b6       	in	r0, 0x3f	; 63
    2532:	0f 92       	push	r0
    2534:	0b b6       	in	r0, 0x3b	; 59
    2536:	0f 92       	push	r0
    2538:	11 24       	eor	r1, r1
    253a:	2f 93       	push	r18
    253c:	3f 93       	push	r19
    253e:	4f 93       	push	r20
    2540:	5f 93       	push	r21
    2542:	6f 93       	push	r22
    2544:	7f 93       	push	r23
    2546:	8f 93       	push	r24
    2548:	9f 93       	push	r25
    254a:	af 93       	push	r26
    254c:	bf 93       	push	r27
    254e:	ef 93       	push	r30
    2550:	ff 93       	push	r31
	sampleCurrentChannel();
    2552:	0e 94 07 12 	call	0x240e	; 0x240e <sampleCurrentChannel>
}
    2556:	ff 91       	pop	r31
    2558:	ef 91       	pop	r30
    255a:	bf 91       	pop	r27
    255c:	af 91       	pop	r26
    255e:	9f 91       	pop	r25
    2560:	8f 91       	pop	r24
    2562:	7f 91       	pop	r23
    2564:	6f 91       	pop	r22
    2566:	5f 91       	pop	r21
    2568:	4f 91       	pop	r20
    256a:	3f 91       	pop	r19
    256c:	2f 91       	pop	r18
    256e:	0f 90       	pop	r0
    2570:	0b be       	out	0x3b, r0	; 59
    2572:	0f 90       	pop	r0
    2574:	0f be       	out	0x3f, r0	; 63
    2576:	0f 90       	pop	r0
    2578:	1f 90       	pop	r1
    257a:	18 95       	reti

0000257c <__vector_79>:
// 	enableADCMUX(FALSE);
	
}

//first averaging point
ISR(TCD0_CCA_vect) {
    257c:	1f 92       	push	r1
    257e:	0f 92       	push	r0
    2580:	0f b6       	in	r0, 0x3f	; 63
    2582:	0f 92       	push	r0
    2584:	0b b6       	in	r0, 0x3b	; 59
    2586:	0f 92       	push	r0
    2588:	11 24       	eor	r1, r1
    258a:	2f 93       	push	r18
    258c:	3f 93       	push	r19
    258e:	4f 93       	push	r20
    2590:	5f 93       	push	r21
    2592:	6f 93       	push	r22
    2594:	7f 93       	push	r23
    2596:	8f 93       	push	r24
    2598:	9f 93       	push	r25
    259a:	af 93       	push	r26
    259c:	bf 93       	push	r27
    259e:	ef 93       	push	r30
    25a0:	ff 93       	push	r31
	sampleCurrentChannel();
    25a2:	0e 94 07 12 	call	0x240e	; 0x240e <sampleCurrentChannel>
}
    25a6:	ff 91       	pop	r31
    25a8:	ef 91       	pop	r30
    25aa:	bf 91       	pop	r27
    25ac:	af 91       	pop	r26
    25ae:	9f 91       	pop	r25
    25b0:	8f 91       	pop	r24
    25b2:	7f 91       	pop	r23
    25b4:	6f 91       	pop	r22
    25b6:	5f 91       	pop	r21
    25b8:	4f 91       	pop	r20
    25ba:	3f 91       	pop	r19
    25bc:	2f 91       	pop	r18
    25be:	0f 90       	pop	r0
    25c0:	0b be       	out	0x3b, r0	; 59
    25c2:	0f 90       	pop	r0
    25c4:	0f be       	out	0x3f, r0	; 63
    25c6:	0f 90       	pop	r0
    25c8:	1f 90       	pop	r1
    25ca:	18 95       	reti

000025cc <__vector_19>:
ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    25cc:	1f 92       	push	r1
    25ce:	0f 92       	push	r0
    25d0:	0f b6       	in	r0, 0x3f	; 63
    25d2:	0f 92       	push	r0
    25d4:	0b b6       	in	r0, 0x3b	; 59
    25d6:	0f 92       	push	r0
    25d8:	11 24       	eor	r1, r1
    25da:	2f 93       	push	r18
    25dc:	3f 93       	push	r19
    25de:	4f 93       	push	r20
    25e0:	5f 93       	push	r21
    25e2:	6f 93       	push	r22
    25e4:	7f 93       	push	r23
    25e6:	8f 93       	push	r24
    25e8:	9f 93       	push	r25
    25ea:	af 93       	push	r26
    25ec:	bf 93       	push	r27
    25ee:	ef 93       	push	r30
    25f0:	ff 93       	push	r31
	sampleCurrentChannel();
    25f2:	0e 94 07 12 	call	0x240e	; 0x240e <sampleCurrentChannel>
	SPICount = 0;
    25f6:	10 92 a0 50 	sts	0x50A0, r1
	if(PORTB.OUT & PIN1_bm) {
    25fa:	e0 e2       	ldi	r30, 0x20	; 32
    25fc:	f6 e0       	ldi	r31, 0x06	; 6
    25fe:	84 81       	ldd	r24, Z+4	; 0x04
    2600:	81 ff       	sbrs	r24, 1
    2602:	0f c0       	rjmp	.+30     	; 0x2622 <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    2604:	e0 e0       	ldi	r30, 0x00	; 0
    2606:	f6 e0       	ldi	r31, 0x06	; 6
    2608:	84 81       	ldd	r24, Z+4	; 0x04
    260a:	86 ff       	sbrs	r24, 6
    260c:	05 c0       	rjmp	.+10     	; 0x2618 <__vector_19+0x4c>
    260e:	82 e0       	ldi	r24, 0x02	; 2
    2610:	e0 e2       	ldi	r30, 0x20	; 32
    2612:	f6 e0       	ldi	r31, 0x06	; 6
    2614:	87 83       	std	Z+7, r24	; 0x07
    2616:	0d c0       	rjmp	.+26     	; 0x2632 <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
    2618:	80 e4       	ldi	r24, 0x40	; 64
    261a:	e0 e0       	ldi	r30, 0x00	; 0
    261c:	f6 e0       	ldi	r31, 0x06	; 6
    261e:	87 83       	std	Z+7, r24	; 0x07
    2620:	08 c0       	rjmp	.+16     	; 0x2632 <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    2622:	80 e4       	ldi	r24, 0x40	; 64
    2624:	e0 e0       	ldi	r30, 0x00	; 0
    2626:	f6 e0       	ldi	r31, 0x06	; 6
    2628:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
    262a:	82 e0       	ldi	r24, 0x02	; 2
    262c:	e0 e2       	ldi	r30, 0x20	; 32
    262e:	f6 e0       	ldi	r31, 0x06	; 6
    2630:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
    2632:	ff 91       	pop	r31
    2634:	ef 91       	pop	r30
    2636:	bf 91       	pop	r27
    2638:	af 91       	pop	r26
    263a:	9f 91       	pop	r25
    263c:	8f 91       	pop	r24
    263e:	7f 91       	pop	r23
    2640:	6f 91       	pop	r22
    2642:	5f 91       	pop	r21
    2644:	4f 91       	pop	r20
    2646:	3f 91       	pop	r19
    2648:	2f 91       	pop	r18
    264a:	0f 90       	pop	r0
    264c:	0b be       	out	0x3b, r0	; 59
    264e:	0f 90       	pop	r0
    2650:	0f be       	out	0x3f, r0	; 63
    2652:	0f 90       	pop	r0
    2654:	1f 90       	pop	r1
    2656:	18 95       	reti

00002658 <__vector_18>:
ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCC0_CCC_vect) {
    2658:	1f 92       	push	r1
    265a:	0f 92       	push	r0
    265c:	0f b6       	in	r0, 0x3f	; 63
    265e:	0f 92       	push	r0
    2660:	0b b6       	in	r0, 0x3b	; 59
    2662:	0f 92       	push	r0
    2664:	11 24       	eor	r1, r1
    2666:	2f 93       	push	r18
    2668:	3f 93       	push	r19
    266a:	4f 93       	push	r20
    266c:	5f 93       	push	r21
    266e:	6f 93       	push	r22
    2670:	7f 93       	push	r23
    2672:	8f 93       	push	r24
    2674:	9f 93       	push	r25
    2676:	af 93       	push	r26
    2678:	bf 93       	push	r27
    267a:	ef 93       	push	r30
    267c:	ff 93       	push	r31
	sampleCurrentChannel();
    267e:	0e 94 07 12 	call	0x240e	; 0x240e <sampleCurrentChannel>
}
    2682:	ff 91       	pop	r31
    2684:	ef 91       	pop	r30
    2686:	bf 91       	pop	r27
    2688:	af 91       	pop	r26
    268a:	9f 91       	pop	r25
    268c:	8f 91       	pop	r24
    268e:	7f 91       	pop	r23
    2690:	6f 91       	pop	r22
    2692:	5f 91       	pop	r21
    2694:	4f 91       	pop	r20
    2696:	3f 91       	pop	r19
    2698:	2f 91       	pop	r18
    269a:	0f 90       	pop	r0
    269c:	0b be       	out	0x3b, r0	; 59
    269e:	0f 90       	pop	r0
    26a0:	0f be       	out	0x3f, r0	; 63
    26a2:	0f 90       	pop	r0
    26a4:	1f 90       	pop	r1
    26a6:	18 95       	reti

000026a8 <__vector_17>:
ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

//second averaging point
ISR(TCC0_CCB_vect) {
    26a8:	1f 92       	push	r1
    26aa:	0f 92       	push	r0
    26ac:	0f b6       	in	r0, 0x3f	; 63
    26ae:	0f 92       	push	r0
    26b0:	0b b6       	in	r0, 0x3b	; 59
    26b2:	0f 92       	push	r0
    26b4:	11 24       	eor	r1, r1
    26b6:	2f 93       	push	r18
    26b8:	3f 93       	push	r19
    26ba:	4f 93       	push	r20
    26bc:	5f 93       	push	r21
    26be:	6f 93       	push	r22
    26c0:	7f 93       	push	r23
    26c2:	8f 93       	push	r24
    26c4:	9f 93       	push	r25
    26c6:	af 93       	push	r26
    26c8:	bf 93       	push	r27
    26ca:	ef 93       	push	r30
    26cc:	ff 93       	push	r31
	sampleCurrentChannel();
    26ce:	0e 94 07 12 	call	0x240e	; 0x240e <sampleCurrentChannel>
}
    26d2:	ff 91       	pop	r31
    26d4:	ef 91       	pop	r30
    26d6:	bf 91       	pop	r27
    26d8:	af 91       	pop	r26
    26da:	9f 91       	pop	r25
    26dc:	8f 91       	pop	r24
    26de:	7f 91       	pop	r23
    26e0:	6f 91       	pop	r22
    26e2:	5f 91       	pop	r21
    26e4:	4f 91       	pop	r20
    26e6:	3f 91       	pop	r19
    26e8:	2f 91       	pop	r18
    26ea:	0f 90       	pop	r0
    26ec:	0b be       	out	0x3b, r0	; 59
    26ee:	0f 90       	pop	r0
    26f0:	0f be       	out	0x3f, r0	; 63
    26f2:	0f 90       	pop	r0
    26f4:	1f 90       	pop	r1
    26f6:	18 95       	reti

000026f8 <__vector_16>:
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//first averaging point
ISR(TCC0_CCA_vect) {
    26f8:	1f 92       	push	r1
    26fa:	0f 92       	push	r0
    26fc:	0f b6       	in	r0, 0x3f	; 63
    26fe:	0f 92       	push	r0
    2700:	0b b6       	in	r0, 0x3b	; 59
    2702:	0f 92       	push	r0
    2704:	11 24       	eor	r1, r1
    2706:	2f 93       	push	r18
    2708:	3f 93       	push	r19
    270a:	4f 93       	push	r20
    270c:	5f 93       	push	r21
    270e:	6f 93       	push	r22
    2710:	7f 93       	push	r23
    2712:	8f 93       	push	r24
    2714:	9f 93       	push	r25
    2716:	af 93       	push	r26
    2718:	bf 93       	push	r27
    271a:	ef 93       	push	r30
    271c:	ff 93       	push	r31
	sampleCurrentChannel();
    271e:	0e 94 07 12 	call	0x240e	; 0x240e <sampleCurrentChannel>
}
    2722:	ff 91       	pop	r31
    2724:	ef 91       	pop	r30
    2726:	bf 91       	pop	r27
    2728:	af 91       	pop	r26
    272a:	9f 91       	pop	r25
    272c:	8f 91       	pop	r24
    272e:	7f 91       	pop	r23
    2730:	6f 91       	pop	r22
    2732:	5f 91       	pop	r21
    2734:	4f 91       	pop	r20
    2736:	3f 91       	pop	r19
    2738:	2f 91       	pop	r18
    273a:	0f 90       	pop	r0
    273c:	0b be       	out	0x3b, r0	; 59
    273e:	0f 90       	pop	r0
    2740:	0f be       	out	0x3f, r0	; 63
    2742:	0f 90       	pop	r0
    2744:	1f 90       	pop	r1
    2746:	18 95       	reti

00002748 <writeSE2FRAM>:
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    2748:	ff 92       	push	r15
    274a:	0f 93       	push	r16
    274c:	1f 93       	push	r17
    274e:	cf 93       	push	r28
    2750:	df 93       	push	r29
    2752:	cd b7       	in	r28, 0x3d	; 61
    2754:	de b7       	in	r29, 0x3e	; 62
    2756:	28 97       	sbiw	r28, 0x08	; 8
    2758:	cd bf       	out	0x3d, r28	; 61
    275a:	de bf       	out	0x3e, r29	; 62

	volatile int32_t sum = 0;
    275c:	19 82       	std	Y+1, r1	; 0x01
    275e:	1a 82       	std	Y+2, r1	; 0x02
    2760:	1b 82       	std	Y+3, r1	; 0x03
    2762:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    2764:	80 91 65 50 	lds	r24, 0x5065
    2768:	90 91 66 50 	lds	r25, 0x5066
    276c:	a0 91 67 50 	lds	r26, 0x5067
    2770:	b0 91 68 50 	lds	r27, 0x5068
    2774:	01 96       	adiw	r24, 0x01	; 1
    2776:	a1 1d       	adc	r26, r1
    2778:	b1 1d       	adc	r27, r1
    277a:	80 93 65 50 	sts	0x5065, r24
    277e:	90 93 66 50 	sts	0x5066, r25
    2782:	a0 93 67 50 	sts	0x5067, r26
    2786:	b0 93 68 50 	sts	0x5068, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    278a:	80 ed       	ldi	r24, 0xD0	; 208
    278c:	80 93 c0 08 	sts	0x08C0, r24
    2790:	20 e0       	ldi	r18, 0x00	; 0
    2792:	30 e0       	ldi	r19, 0x00	; 0
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2794:	00 e2       	ldi	r16, 0x20	; 32
    2796:	1e e3       	ldi	r17, 0x3E	; 62
    2798:	ff 24       	eor	r15, r15
    279a:	fa 94       	dec	r15
    279c:	c9 01       	movw	r24, r18
    279e:	f8 01       	movw	r30, r16
    27a0:	e2 0f       	add	r30, r18
    27a2:	f3 1f       	adc	r31, r19
    27a4:	40 81       	ld	r20, Z
    27a6:	44 23       	and	r20, r20
    27a8:	14 f4       	brge	.+4      	; 0x27ae <writeSE2FRAM+0x66>
    27aa:	f8 86       	std	Y+8, r15	; 0x08
    27ac:	01 c0       	rjmp	.+2      	; 0x27b0 <writeSE2FRAM+0x68>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    27ae:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    27b0:	80 0f       	add	r24, r16
    27b2:	91 1f       	adc	r25, r17
    27b4:	fc 01       	movw	r30, r24
    27b6:	80 81       	ld	r24, Z
    27b8:	8f 83       	std	Y+7, r24	; 0x07
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    27ba:	f9 01       	movw	r30, r18
    27bc:	31 96       	adiw	r30, 0x01	; 1
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    27be:	e0 0f       	add	r30, r16
    27c0:	f1 1f       	adc	r31, r17
    27c2:	80 81       	ld	r24, Z
    27c4:	8e 83       	std	Y+6, r24	; 0x06
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    27c6:	f9 01       	movw	r30, r18
    27c8:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    27ca:	e0 0f       	add	r30, r16
    27cc:	f1 1f       	adc	r31, r17
    27ce:	80 81       	ld	r24, Z
    27d0:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    27d2:	49 81       	ldd	r20, Y+1	; 0x01
    27d4:	5a 81       	ldd	r21, Y+2	; 0x02
    27d6:	6b 81       	ldd	r22, Y+3	; 0x03
    27d8:	7c 81       	ldd	r23, Y+4	; 0x04
    27da:	8d 81       	ldd	r24, Y+5	; 0x05
    27dc:	9e 81       	ldd	r25, Y+6	; 0x06
    27de:	af 81       	ldd	r26, Y+7	; 0x07
    27e0:	b8 85       	ldd	r27, Y+8	; 0x08
    27e2:	84 0f       	add	r24, r20
    27e4:	95 1f       	adc	r25, r21
    27e6:	a6 1f       	adc	r26, r22
    27e8:	b7 1f       	adc	r27, r23
    27ea:	89 83       	std	Y+1, r24	; 0x01
    27ec:	9a 83       	std	Y+2, r25	; 0x02
    27ee:	ab 83       	std	Y+3, r26	; 0x03
    27f0:	bc 83       	std	Y+4, r27	; 0x04
    27f2:	2d 5f       	subi	r18, 0xFD	; 253
    27f4:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    27f6:	2c 30       	cpi	r18, 0x0C	; 12
    27f8:	31 05       	cpc	r19, r1
    27fa:	81 f6       	brne	.-96     	; 0x279c <writeSE2FRAM+0x54>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    27fc:	69 81       	ldd	r22, Y+1	; 0x01
    27fe:	7a 81       	ldd	r23, Y+2	; 0x02
    2800:	8b 81       	ldd	r24, Y+3	; 0x03
    2802:	9c 81       	ldd	r25, Y+4	; 0x04
    2804:	24 e0       	ldi	r18, 0x04	; 4
    2806:	30 e0       	ldi	r19, 0x00	; 0
    2808:	40 e0       	ldi	r20, 0x00	; 0
    280a:	50 e0       	ldi	r21, 0x00	; 0
    280c:	0e 94 79 39 	call	0x72f2	; 0x72f2 <__divmodsi4>
    2810:	29 83       	std	Y+1, r18	; 0x01
    2812:	3a 83       	std	Y+2, r19	; 0x02
    2814:	4b 83       	std	Y+3, r20	; 0x03
    2816:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2818:	29 81       	ldd	r18, Y+1	; 0x01
    281a:	82 e2       	ldi	r24, 0x22	; 34
    281c:	9e e3       	ldi	r25, 0x3E	; 62
    281e:	20 93 22 3e 	sts	0x3E22, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2822:	2a 81       	ldd	r18, Y+2	; 0x02
    2824:	fc 01       	movw	r30, r24
    2826:	31 97       	sbiw	r30, 0x01	; 1
    2828:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    282a:	2b 81       	ldd	r18, Y+3	; 0x03
    282c:	02 97       	sbiw	r24, 0x02	; 2
    282e:	fc 01       	movw	r30, r24
    2830:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2832:	80 e1       	ldi	r24, 0x10	; 16
    2834:	e0 e4       	ldi	r30, 0x40	; 64
    2836:	f6 e0       	ldi	r31, 0x06	; 6
    2838:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    283a:	88 e0       	ldi	r24, 0x08	; 8
    283c:	e0 e2       	ldi	r30, 0x20	; 32
    283e:	f6 e0       	ldi	r31, 0x06	; 6
    2840:	86 83       	std	Z+6, r24	; 0x06
	nop();
    2842:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2844:	86 e0       	ldi	r24, 0x06	; 6
    2846:	e0 ec       	ldi	r30, 0xC0	; 192
    2848:	f8 e0       	ldi	r31, 0x08	; 8
    284a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    284c:	82 81       	ldd	r24, Z+2	; 0x02
    284e:	88 23       	and	r24, r24
    2850:	ec f7       	brge	.-6      	; 0x284c <writeSE2FRAM+0x104>
	SPIBuffer[12] = SPIC.DATA;
    2852:	e0 ec       	ldi	r30, 0xC0	; 192
    2854:	f8 e0       	ldi	r31, 0x08	; 8
    2856:	83 81       	ldd	r24, Z+3	; 0x03
    2858:	80 93 2c 3e 	sts	0x3E2C, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    285c:	a0 e2       	ldi	r26, 0x20	; 32
    285e:	b6 e0       	ldi	r27, 0x06	; 6
    2860:	88 e0       	ldi	r24, 0x08	; 8
    2862:	15 96       	adiw	r26, 0x05	; 5
    2864:	8c 93       	st	X, r24
    2866:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    2868:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    286a:	16 96       	adiw	r26, 0x06	; 6
    286c:	8c 93       	st	X, r24
    286e:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    2870:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2872:	82 e0       	ldi	r24, 0x02	; 2
    2874:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2876:	82 81       	ldd	r24, Z+2	; 0x02
    2878:	88 23       	and	r24, r24
    287a:	ec f7       	brge	.-6      	; 0x2876 <writeSE2FRAM+0x12e>
	SPIBuffer[12] = SPIC.DATA;
    287c:	e0 ec       	ldi	r30, 0xC0	; 192
    287e:	f8 e0       	ldi	r31, 0x08	; 8
    2880:	83 81       	ldd	r24, Z+3	; 0x03
    2882:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2886:	80 91 1e 3e 	lds	r24, 0x3E1E
    288a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    288c:	82 81       	ldd	r24, Z+2	; 0x02
    288e:	88 23       	and	r24, r24
    2890:	ec f7       	brge	.-6      	; 0x288c <writeSE2FRAM+0x144>
	SPIBuffer[12] = SPIC.DATA;
    2892:	e0 ec       	ldi	r30, 0xC0	; 192
    2894:	f8 e0       	ldi	r31, 0x08	; 8
    2896:	83 81       	ldd	r24, Z+3	; 0x03
    2898:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    289c:	80 91 1d 3e 	lds	r24, 0x3E1D
    28a0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    28a2:	82 81       	ldd	r24, Z+2	; 0x02
    28a4:	88 23       	and	r24, r24
    28a6:	ec f7       	brge	.-6      	; 0x28a2 <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    28a8:	e0 ec       	ldi	r30, 0xC0	; 192
    28aa:	f8 e0       	ldi	r31, 0x08	; 8
    28ac:	83 81       	ldd	r24, Z+3	; 0x03
    28ae:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = SPIBuffer[0];
    28b2:	80 91 20 3e 	lds	r24, 0x3E20
    28b6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    28b8:	82 81       	ldd	r24, Z+2	; 0x02
    28ba:	88 23       	and	r24, r24
    28bc:	ec f7       	brge	.-6      	; 0x28b8 <writeSE2FRAM+0x170>
	SPIBuffer[12] = SPIC.DATA;
    28be:	e0 ec       	ldi	r30, 0xC0	; 192
    28c0:	f8 e0       	ldi	r31, 0x08	; 8
    28c2:	83 81       	ldd	r24, Z+3	; 0x03
    28c4:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = SPIBuffer[1];
    28c8:	80 91 21 3e 	lds	r24, 0x3E21
    28cc:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    28ce:	82 81       	ldd	r24, Z+2	; 0x02
    28d0:	88 23       	and	r24, r24
    28d2:	ec f7       	brge	.-6      	; 0x28ce <writeSE2FRAM+0x186>
	SPIBuffer[12] = SPIC.DATA;
    28d4:	e0 ec       	ldi	r30, 0xC0	; 192
    28d6:	f8 e0       	ldi	r31, 0x08	; 8
    28d8:	83 81       	ldd	r24, Z+3	; 0x03
    28da:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = SPIBuffer[2];
    28de:	80 91 22 3e 	lds	r24, 0x3E22
    28e2:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    28e4:	82 81       	ldd	r24, Z+2	; 0x02
    28e6:	88 23       	and	r24, r24
    28e8:	ec f7       	brge	.-6      	; 0x28e4 <writeSE2FRAM+0x19c>
	SPIBuffer[12] = SPIC.DATA;
    28ea:	a0 ec       	ldi	r26, 0xC0	; 192
    28ec:	b8 e0       	ldi	r27, 0x08	; 8
    28ee:	13 96       	adiw	r26, 0x03	; 3
    28f0:	8c 91       	ld	r24, X
    28f2:	13 97       	sbiw	r26, 0x03	; 3
    28f4:	80 93 2c 3e 	sts	0x3E2C, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    28f8:	88 e0       	ldi	r24, 0x08	; 8
    28fa:	e0 e2       	ldi	r30, 0x20	; 32
    28fc:	f6 e0       	ldi	r31, 0x06	; 6
    28fe:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2900:	e0 e4       	ldi	r30, 0x40	; 64
    2902:	f6 e0       	ldi	r31, 0x06	; 6
    2904:	80 e1       	ldi	r24, 0x10	; 16
    2906:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2908:	94 e5       	ldi	r25, 0x54	; 84
    290a:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    290c:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    290e:	80 91 1d 3e 	lds	r24, 0x3E1D
    2912:	90 91 1e 3e 	lds	r25, 0x3E1E
    2916:	03 96       	adiw	r24, 0x03	; 3
    2918:	80 93 1d 3e 	sts	0x3E1D, r24
    291c:	90 93 1e 3e 	sts	0x3E1E, r25
	checksumADC[0] += SPIBuffer[0];
    2920:	80 91 11 21 	lds	r24, 0x2111
    2924:	e0 e2       	ldi	r30, 0x20	; 32
    2926:	fe e3       	ldi	r31, 0x3E	; 62
    2928:	90 81       	ld	r25, Z
    292a:	89 0f       	add	r24, r25
    292c:	80 93 11 21 	sts	0x2111, r24
	checksumADC[1] += SPIBuffer[1];
    2930:	80 91 12 21 	lds	r24, 0x2112
    2934:	91 81       	ldd	r25, Z+1	; 0x01
    2936:	89 0f       	add	r24, r25
    2938:	80 93 12 21 	sts	0x2112, r24
	checksumADC[2] += SPIBuffer[2];
    293c:	80 91 13 21 	lds	r24, 0x2113
    2940:	92 81       	ldd	r25, Z+2	; 0x02
    2942:	89 0f       	add	r24, r25
    2944:	80 93 13 21 	sts	0x2113, r24
}
    2948:	28 96       	adiw	r28, 0x08	; 8
    294a:	cd bf       	out	0x3d, r28	; 61
    294c:	de bf       	out	0x3e, r29	; 62
    294e:	df 91       	pop	r29
    2950:	cf 91       	pop	r28
    2952:	1f 91       	pop	r17
    2954:	0f 91       	pop	r16
    2956:	ff 90       	pop	r15
    2958:	08 95       	ret

0000295a <FRAMWriteKnowns>:
// 	}
// 	
// }

//test function for FRAM
void FRAMWriteKnowns() {
    295a:	2f 92       	push	r2
    295c:	3f 92       	push	r3
    295e:	4f 92       	push	r4
    2960:	5f 92       	push	r5
    2962:	6f 92       	push	r6
    2964:	7f 92       	push	r7
    2966:	8f 92       	push	r8
    2968:	9f 92       	push	r9
    296a:	af 92       	push	r10
    296c:	bf 92       	push	r11
    296e:	cf 92       	push	r12
    2970:	df 92       	push	r13
    2972:	ef 92       	push	r14
    2974:	ff 92       	push	r15
    2976:	0f 93       	push	r16
    2978:	1f 93       	push	r17
    297a:	cf 93       	push	r28
    297c:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    297e:	10 92 1d 3e 	sts	0x3E1D, r1
    2982:	10 92 1e 3e 	sts	0x3E1E, r1
	sampleCount = 0;
    2986:	10 92 65 50 	sts	0x5065, r1
    298a:	10 92 66 50 	sts	0x5066, r1
    298e:	10 92 67 50 	sts	0x5067, r1
    2992:	10 92 68 50 	sts	0x5068, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2996:	83 e1       	ldi	r24, 0x13	; 19
    2998:	91 e2       	ldi	r25, 0x21	; 33
    299a:	10 92 13 21 	sts	0x2113, r1
    299e:	fc 01       	movw	r30, r24
    29a0:	31 97       	sbiw	r30, 0x01	; 1
    29a2:	10 82       	st	Z, r1
    29a4:	02 97       	sbiw	r24, 0x02	; 2
    29a6:	dc 01       	movw	r26, r24
    29a8:	1c 92       	st	X, r1
	
	ADCPower(TRUE);
    29aa:	81 e0       	ldi	r24, 0x01	; 1
    29ac:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    29b0:	84 e0       	ldi	r24, 0x04	; 4
    29b2:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    29b6:	80 ed       	ldi	r24, 0xD0	; 208
    29b8:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    29bc:	8d e0       	ldi	r24, 0x0D	; 13
    29be:	80 93 20 3e 	sts	0x3E20, r24
	SPIBuffer[1] = 0xF3;
    29c2:	83 ef       	ldi	r24, 0xF3	; 243
    29c4:	80 93 21 3e 	sts	0x3E21, r24
	SPIBuffer[2] = 0x57;
    29c8:	87 e5       	ldi	r24, 0x57	; 87
    29ca:	80 93 22 3e 	sts	0x3E22, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    29ce:	80 91 65 50 	lds	r24, 0x5065
    29d2:	90 91 66 50 	lds	r25, 0x5066
    29d6:	a0 91 67 50 	lds	r26, 0x5067
    29da:	b0 91 68 50 	lds	r27, 0x5068
    29de:	83 35       	cpi	r24, 0x53	; 83
    29e0:	e5 e5       	ldi	r30, 0x55	; 85
    29e2:	9e 07       	cpc	r25, r30
    29e4:	e0 e0       	ldi	r30, 0x00	; 0
    29e6:	ae 07       	cpc	r26, r30
    29e8:	e0 e0       	ldi	r30, 0x00	; 0
    29ea:	be 07       	cpc	r27, r30
    29ec:	08 f0       	brcs	.+2      	; 0x29f0 <FRAMWriteKnowns+0x96>
    29ee:	cc c0       	rjmp	.+408    	; 0x2b88 <FRAMWriteKnowns+0x22e>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    29f0:	0f 2e       	mov	r0, r31
    29f2:	f0 e4       	ldi	r31, 0x40	; 64
    29f4:	ef 2e       	mov	r14, r31
    29f6:	f6 e0       	ldi	r31, 0x06	; 6
    29f8:	ff 2e       	mov	r15, r31
    29fa:	f0 2d       	mov	r31, r0
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    29fc:	40 e2       	ldi	r20, 0x20	; 32
    29fe:	56 e0       	ldi	r21, 0x06	; 6
    2a00:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    2a02:	e0 ec       	ldi	r30, 0xC0	; 192
    2a04:	f8 e0       	ldi	r31, 0x08	; 8
    2a06:	0f 2e       	mov	r0, r31
    2a08:	f6 e0       	ldi	r31, 0x06	; 6
    2a0a:	7f 2e       	mov	r7, r31
    2a0c:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    2a0e:	cc e2       	ldi	r28, 0x2C	; 44
    2a10:	de e3       	ldi	r29, 0x3E	; 62
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    2a12:	66 24       	eor	r6, r6
    2a14:	68 94       	set
    2a16:	61 f8       	bld	r6, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2a18:	0f 2e       	mov	r0, r31
    2a1a:	fd e1       	ldi	r31, 0x1D	; 29
    2a1c:	cf 2e       	mov	r12, r31
    2a1e:	fe e3       	ldi	r31, 0x3E	; 62
    2a20:	df 2e       	mov	r13, r31
    2a22:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    2a24:	8e 01       	movw	r16, r28
    2a26:	0c 50       	subi	r16, 0x0C	; 12
    2a28:	10 40       	sbci	r17, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    2a2a:	0f 2e       	mov	r0, r31
    2a2c:	f5 ef       	ldi	r31, 0xF5	; 245
    2a2e:	4f 2e       	mov	r4, r31
    2a30:	ff ef       	ldi	r31, 0xFF	; 255
    2a32:	5f 2e       	mov	r5, r31
    2a34:	f0 2d       	mov	r31, r0
    2a36:	4c 0e       	add	r4, r28
    2a38:	5d 1e       	adc	r5, r29
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    2a3a:	0f 2e       	mov	r0, r31
    2a3c:	f6 ef       	ldi	r31, 0xF6	; 246
    2a3e:	2f 2e       	mov	r2, r31
    2a40:	ff ef       	ldi	r31, 0xFF	; 255
    2a42:	3f 2e       	mov	r3, r31
    2a44:	f0 2d       	mov	r31, r0
    2a46:	2c 0e       	add	r2, r28
    2a48:	3d 1e       	adc	r3, r29
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    2a4a:	61 e1       	ldi	r22, 0x11	; 17
    2a4c:	71 e2       	ldi	r23, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    2a4e:	5b 01       	movw	r10, r22
    2a50:	08 94       	sec
    2a52:	a1 1c       	adc	r10, r1
    2a54:	b1 1c       	adc	r11, r1
		checksumADC[2] += SPIBuffer[2];
    2a56:	88 24       	eor	r8, r8
    2a58:	99 24       	eor	r9, r9
    2a5a:	68 94       	set
    2a5c:	81 f8       	bld	r8, 1
    2a5e:	86 0e       	add	r8, r22
    2a60:	97 1e       	adc	r9, r23
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2a62:	30 e1       	ldi	r19, 0x10	; 16
    2a64:	d7 01       	movw	r26, r14
    2a66:	16 96       	adiw	r26, 0x06	; 6
    2a68:	3c 93       	st	X, r19
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2a6a:	da 01       	movw	r26, r20
    2a6c:	16 96       	adiw	r26, 0x06	; 6
    2a6e:	2c 93       	st	X, r18
    2a70:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    2a72:	00 00       	nop
		SPIC.DATA = FR_WREN;
    2a74:	73 82       	std	Z+3, r7	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2a76:	82 81       	ldd	r24, Z+2	; 0x02
    2a78:	88 23       	and	r24, r24
    2a7a:	ec f7       	brge	.-6      	; 0x2a76 <FRAMWriteKnowns+0x11c>
		SPIBuffer[12] = SPIC.DATA;
    2a7c:	83 81       	ldd	r24, Z+3	; 0x03
    2a7e:	88 83       	st	Y, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    2a80:	da 01       	movw	r26, r20
    2a82:	15 96       	adiw	r26, 0x05	; 5
    2a84:	2c 93       	st	X, r18
    2a86:	15 97       	sbiw	r26, 0x05	; 5
		nop(); // time for CS_FRAM to accept high signal
    2a88:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2a8a:	16 96       	adiw	r26, 0x06	; 6
    2a8c:	2c 93       	st	X, r18
    2a8e:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    2a90:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    2a92:	63 82       	std	Z+3, r6	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2a94:	82 81       	ldd	r24, Z+2	; 0x02
    2a96:	88 23       	and	r24, r24
    2a98:	ec f7       	brge	.-6      	; 0x2a94 <FRAMWriteKnowns+0x13a>
		SPIBuffer[12] = SPIC.DATA;
    2a9a:	83 81       	ldd	r24, Z+3	; 0x03
    2a9c:	88 83       	st	Y, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2a9e:	d6 01       	movw	r26, r12
    2aa0:	11 96       	adiw	r26, 0x01	; 1
    2aa2:	8c 91       	ld	r24, X
    2aa4:	11 97       	sbiw	r26, 0x01	; 1
    2aa6:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2aa8:	82 81       	ldd	r24, Z+2	; 0x02
    2aaa:	88 23       	and	r24, r24
    2aac:	ec f7       	brge	.-6      	; 0x2aa8 <FRAMWriteKnowns+0x14e>
		SPIBuffer[12] = SPIC.DATA;
    2aae:	83 81       	ldd	r24, Z+3	; 0x03
    2ab0:	88 83       	st	Y, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2ab2:	d6 01       	movw	r26, r12
    2ab4:	8c 91       	ld	r24, X
    2ab6:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2ab8:	82 81       	ldd	r24, Z+2	; 0x02
    2aba:	88 23       	and	r24, r24
    2abc:	ec f7       	brge	.-6      	; 0x2ab8 <FRAMWriteKnowns+0x15e>
		SPIBuffer[12] = SPIC.DATA;
    2abe:	83 81       	ldd	r24, Z+3	; 0x03
    2ac0:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[0];
    2ac2:	d8 01       	movw	r26, r16
    2ac4:	8c 91       	ld	r24, X
    2ac6:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2ac8:	82 81       	ldd	r24, Z+2	; 0x02
    2aca:	88 23       	and	r24, r24
    2acc:	ec f7       	brge	.-6      	; 0x2ac8 <FRAMWriteKnowns+0x16e>
		SPIBuffer[12] = SPIC.DATA;
    2ace:	83 81       	ldd	r24, Z+3	; 0x03
    2ad0:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[1];
    2ad2:	d2 01       	movw	r26, r4
    2ad4:	8c 91       	ld	r24, X
    2ad6:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2ad8:	82 81       	ldd	r24, Z+2	; 0x02
    2ada:	88 23       	and	r24, r24
    2adc:	ec f7       	brge	.-6      	; 0x2ad8 <FRAMWriteKnowns+0x17e>
		SPIBuffer[12] = SPIC.DATA;
    2ade:	83 81       	ldd	r24, Z+3	; 0x03
    2ae0:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[2];
    2ae2:	d1 01       	movw	r26, r2
    2ae4:	8c 91       	ld	r24, X
    2ae6:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2ae8:	82 81       	ldd	r24, Z+2	; 0x02
    2aea:	88 23       	and	r24, r24
    2aec:	ec f7       	brge	.-6      	; 0x2ae8 <FRAMWriteKnowns+0x18e>
		SPIBuffer[12] = SPIC.DATA;
    2aee:	83 81       	ldd	r24, Z+3	; 0x03
    2af0:	88 83       	st	Y, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2af2:	da 01       	movw	r26, r20
    2af4:	15 96       	adiw	r26, 0x05	; 5
    2af6:	2c 93       	st	X, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2af8:	30 e1       	ldi	r19, 0x10	; 16
    2afa:	d7 01       	movw	r26, r14
    2afc:	15 96       	adiw	r26, 0x05	; 5
    2afe:	3c 93       	st	X, r19
		
		FRAMAddress +=3;
    2b00:	80 91 1d 3e 	lds	r24, 0x3E1D
    2b04:	90 91 1e 3e 	lds	r25, 0x3E1E
    2b08:	03 96       	adiw	r24, 0x03	; 3
    2b0a:	80 93 1d 3e 	sts	0x3E1D, r24
    2b0e:	90 93 1e 3e 	sts	0x3E1E, r25
		checksumADC[0] += SPIBuffer[0];
    2b12:	db 01       	movw	r26, r22
    2b14:	8c 91       	ld	r24, X
    2b16:	d8 01       	movw	r26, r16
    2b18:	9c 91       	ld	r25, X
    2b1a:	89 0f       	add	r24, r25
    2b1c:	db 01       	movw	r26, r22
    2b1e:	8c 93       	st	X, r24
		checksumADC[1] += SPIBuffer[1];
    2b20:	d5 01       	movw	r26, r10
    2b22:	8c 91       	ld	r24, X
    2b24:	a1 e2       	ldi	r26, 0x21	; 33
    2b26:	be e3       	ldi	r27, 0x3E	; 62
    2b28:	9c 91       	ld	r25, X
    2b2a:	89 0f       	add	r24, r25
    2b2c:	d5 01       	movw	r26, r10
    2b2e:	8c 93       	st	X, r24
		checksumADC[2] += SPIBuffer[2];
    2b30:	d4 01       	movw	r26, r8
    2b32:	8c 91       	ld	r24, X
    2b34:	a2 e2       	ldi	r26, 0x22	; 34
    2b36:	be e3       	ldi	r27, 0x3E	; 62
    2b38:	9c 91       	ld	r25, X
    2b3a:	89 0f       	add	r24, r25
    2b3c:	d4 01       	movw	r26, r8
    2b3e:	8c 93       	st	X, r24
		
		sampleCount++;
    2b40:	80 91 65 50 	lds	r24, 0x5065
    2b44:	90 91 66 50 	lds	r25, 0x5066
    2b48:	a0 91 67 50 	lds	r26, 0x5067
    2b4c:	b0 91 68 50 	lds	r27, 0x5068
    2b50:	01 96       	adiw	r24, 0x01	; 1
    2b52:	a1 1d       	adc	r26, r1
    2b54:	b1 1d       	adc	r27, r1
    2b56:	80 93 65 50 	sts	0x5065, r24
    2b5a:	90 93 66 50 	sts	0x5066, r25
    2b5e:	a0 93 67 50 	sts	0x5067, r26
    2b62:	b0 93 68 50 	sts	0x5068, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    2b66:	80 91 65 50 	lds	r24, 0x5065
    2b6a:	90 91 66 50 	lds	r25, 0x5066
    2b6e:	a0 91 67 50 	lds	r26, 0x5067
    2b72:	b0 91 68 50 	lds	r27, 0x5068
    2b76:	83 35       	cpi	r24, 0x53	; 83
    2b78:	35 e5       	ldi	r19, 0x55	; 85
    2b7a:	93 07       	cpc	r25, r19
    2b7c:	30 e0       	ldi	r19, 0x00	; 0
    2b7e:	a3 07       	cpc	r26, r19
    2b80:	30 e0       	ldi	r19, 0x00	; 0
    2b82:	b3 07       	cpc	r27, r19
    2b84:	08 f4       	brcc	.+2      	; 0x2b88 <FRAMWriteKnowns+0x22e>
    2b86:	6d cf       	rjmp	.-294    	; 0x2a62 <FRAMWriteKnowns+0x108>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    2b88:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	ADCPower(FALSE);
    2b8c:	80 e0       	ldi	r24, 0x00	; 0
    2b8e:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
}
    2b92:	df 91       	pop	r29
    2b94:	cf 91       	pop	r28
    2b96:	1f 91       	pop	r17
    2b98:	0f 91       	pop	r16
    2b9a:	ff 90       	pop	r15
    2b9c:	ef 90       	pop	r14
    2b9e:	df 90       	pop	r13
    2ba0:	cf 90       	pop	r12
    2ba2:	bf 90       	pop	r11
    2ba4:	af 90       	pop	r10
    2ba6:	9f 90       	pop	r9
    2ba8:	8f 90       	pop	r8
    2baa:	7f 90       	pop	r7
    2bac:	6f 90       	pop	r6
    2bae:	5f 90       	pop	r5
    2bb0:	4f 90       	pop	r4
    2bb2:	3f 90       	pop	r3
    2bb4:	2f 90       	pop	r2
    2bb6:	08 95       	ret

00002bb8 <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    2bb8:	80 ff       	sbrs	r24, 0
    2bba:	05 c0       	rjmp	.+10     	; 0x2bc6 <setADCInput+0xe>
    2bbc:	20 e4       	ldi	r18, 0x40	; 64
    2bbe:	e0 e0       	ldi	r30, 0x00	; 0
    2bc0:	f6 e0       	ldi	r31, 0x06	; 6
    2bc2:	25 83       	std	Z+5, r18	; 0x05
    2bc4:	04 c0       	rjmp	.+8      	; 0x2bce <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    2bc6:	20 e4       	ldi	r18, 0x40	; 64
    2bc8:	e0 e0       	ldi	r30, 0x00	; 0
    2bca:	f6 e0       	ldi	r31, 0x06	; 6
    2bcc:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    2bce:	81 ff       	sbrs	r24, 1
    2bd0:	05 c0       	rjmp	.+10     	; 0x2bdc <setADCInput+0x24>
    2bd2:	22 e0       	ldi	r18, 0x02	; 2
    2bd4:	e0 e2       	ldi	r30, 0x20	; 32
    2bd6:	f6 e0       	ldi	r31, 0x06	; 6
    2bd8:	25 83       	std	Z+5, r18	; 0x05
    2bda:	04 c0       	rjmp	.+8      	; 0x2be4 <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    2bdc:	22 e0       	ldi	r18, 0x02	; 2
    2bde:	e0 e2       	ldi	r30, 0x20	; 32
    2be0:	f6 e0       	ldi	r31, 0x06	; 6
    2be2:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    2be4:	82 ff       	sbrs	r24, 2
    2be6:	05 c0       	rjmp	.+10     	; 0x2bf2 <setADCInput+0x3a>
    2be8:	84 e0       	ldi	r24, 0x04	; 4
    2bea:	e0 e2       	ldi	r30, 0x20	; 32
    2bec:	f6 e0       	ldi	r31, 0x06	; 6
    2bee:	85 83       	std	Z+5, r24	; 0x05
    2bf0:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    2bf2:	84 e0       	ldi	r24, 0x04	; 4
    2bf4:	e0 e2       	ldi	r30, 0x20	; 32
    2bf6:	f6 e0       	ldi	r31, 0x06	; 6
    2bf8:	86 83       	std	Z+6, r24	; 0x06
    2bfa:	08 95       	ret

00002bfc <CO_collectSeismic1Channel_ext>:
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2bfc:	2f 92       	push	r2
    2bfe:	3f 92       	push	r3
    2c00:	4f 92       	push	r4
    2c02:	5f 92       	push	r5
    2c04:	7f 92       	push	r7
    2c06:	8f 92       	push	r8
    2c08:	9f 92       	push	r9
    2c0a:	af 92       	push	r10
    2c0c:	bf 92       	push	r11
    2c0e:	cf 92       	push	r12
    2c10:	df 92       	push	r13
    2c12:	ef 92       	push	r14
    2c14:	ff 92       	push	r15
    2c16:	0f 93       	push	r16
    2c18:	1f 93       	push	r17
    2c1a:	cf 93       	push	r28
    2c1c:	df 93       	push	r29
    2c1e:	cd b7       	in	r28, 0x3d	; 61
    2c20:	de b7       	in	r29, 0x3e	; 62
    2c22:	18 2f       	mov	r17, r24
    2c24:	76 2e       	mov	r7, r22
    2c26:	f4 2e       	mov	r15, r20
    2c28:	19 01       	movw	r2, r18
	
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	ADC_BUFFER=DataArray;
    2c2a:	89 8d       	ldd	r24, Y+25	; 0x19
    2c2c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2c2e:	80 93 63 50 	sts	0x5063, r24
    2c32:	90 93 64 50 	sts	0x5064, r25
	ADC_Sampling_Finished = 0;
    2c36:	10 92 a6 50 	sts	0x50A6, r1
	ADC_buffer_size = BufferSize;
    2c3a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2c3c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2c3e:	80 93 a7 50 	sts	0x50A7, r24
    2c42:	90 93 a8 50 	sts	0x50A8, r25
	if(use_FRAM){
    2c46:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2c48:	88 23       	and	r24, r24
    2c4a:	21 f0       	breq	.+8      	; 0x2c54 <CO_collectSeismic1Channel_ext+0x58>
		write_to_FRAM = 1;
    2c4c:	81 e0       	ldi	r24, 0x01	; 1
    2c4e:	80 93 48 40 	sts	0x4048, r24
    2c52:	02 c0       	rjmp	.+4      	; 0x2c58 <CO_collectSeismic1Channel_ext+0x5c>
	}
	else{
		write_to_FRAM = 0;
    2c54:	10 92 48 40 	sts	0x4048, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2c58:	81 e0       	ldi	r24, 0x01	; 1
    2c5a:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2c5e:	81 2f       	mov	r24, r17
    2c60:	6f 2d       	mov	r22, r15
    2c62:	0e 94 1f 0c 	call	0x183e	; 0x183e <set_ampGain>
	set_filter(filterConfig);
    2c66:	87 2d       	mov	r24, r7
    2c68:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2c6c:	8e 2d       	mov	r24, r14
    2c6e:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2c72:	84 e0       	ldi	r24, 0x04	; 4
    2c74:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2c78:	84 e5       	ldi	r24, 0x54	; 84
    2c7a:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2c7e:	81 e0       	ldi	r24, 0x01	; 1
    2c80:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <enableADCMUX>
	setADCInput(channel);
    2c84:	81 2f       	mov	r24, r17
    2c86:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2c8a:	e0 ea       	ldi	r30, 0xA0	; 160
    2c8c:	f6 e0       	ldi	r31, 0x06	; 6
    2c8e:	22 e0       	ldi	r18, 0x02	; 2
    2c90:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2c92:	77 24       	eor	r7, r7
    2c94:	73 94       	inc	r7
    2c96:	72 82       	std	Z+2, r7	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2c98:	0f 2e       	mov	r0, r31
    2c9a:	f0 e8       	ldi	r31, 0x80	; 128
    2c9c:	4f 2e       	mov	r4, r31
    2c9e:	f1 e0       	ldi	r31, 0x01	; 1
    2ca0:	5f 2e       	mov	r5, r31
    2ca2:	f0 2d       	mov	r31, r0
    2ca4:	88 e7       	ldi	r24, 0x78	; 120
    2ca6:	d2 01       	movw	r26, r4
    2ca8:	8c 93       	st	X, r24

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2caa:	e0 e0       	ldi	r30, 0x00	; 0
    2cac:	f9 e0       	ldi	r31, 0x09	; 9
    2cae:	80 ef       	ldi	r24, 0xF0	; 240
    2cb0:	81 83       	std	Z+1, r24	; 0x01
	TCD0.CCA = averagingPtA;
    2cb2:	c0 a6       	lds	r28, 0xb0
    2cb4:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    2cb6:	a2 a6       	lds	r26, 0xb2
    2cb8:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    2cba:	84 a6       	lds	r24, 0xb4
    2cbc:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    2cbe:	8d 89       	ldd	r24, Y+21	; 0x15
    2cc0:	9e 89       	ldd	r25, Y+22	; 0x16
    2cc2:	86 a7       	lds	r24, 0x76
    2cc4:	97 a7       	lds	r25, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    2cc6:	80 2f       	mov	r24, r16
    2cc8:	90 e0       	ldi	r25, 0x00	; 0
    2cca:	01 97       	sbiw	r24, 0x01	; 1
    2ccc:	86 a3       	lds	r24, 0x56
    2cce:	97 a3       	lds	r25, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2cd0:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2cd2:	8f ef       	ldi	r24, 0xFF	; 255
    2cd4:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2cd6:	80 81       	ld	r24, Z
    2cd8:	80 7f       	andi	r24, 0xF0	; 240
    2cda:	88 60       	ori	r24, 0x08	; 8
    2cdc:	80 83       	st	Z, r24

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    2cde:	10 92 65 50 	sts	0x5065, r1
    2ce2:	10 92 66 50 	sts	0x5066, r1
    2ce6:	10 92 67 50 	sts	0x5067, r1
    2cea:	10 92 68 50 	sts	0x5068, r1
	SPICount = 0;
    2cee:	10 92 a0 50 	sts	0x50A0, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm;
    2cf2:	e0 ea       	ldi	r30, 0xA0	; 160
    2cf4:	f0 e0       	ldi	r31, 0x00	; 0
    2cf6:	82 81       	ldd	r24, Z+2	; 0x02
    2cf8:	87 60       	ori	r24, 0x07	; 7
    2cfa:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2cfc:	78 94       	sei

	SPICS(TRUE);
    2cfe:	81 e0       	ldi	r24, 0x01	; 1
    2d00:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2d04:	80 e2       	ldi	r24, 0x20	; 32
    2d06:	e0 e8       	ldi	r30, 0x80	; 128
    2d08:	f6 e0       	ldi	r31, 0x06	; 6
    2d0a:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2d0c:	00 e4       	ldi	r16, 0x40	; 64
    2d0e:	1a e0       	ldi	r17, 0x0A	; 10
    2d10:	83 e2       	ldi	r24, 0x23	; 35
    2d12:	f8 01       	movw	r30, r16
    2d14:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2d16:	61 01       	movw	r12, r2
    2d18:	ee 24       	eor	r14, r14
    2d1a:	ff 24       	eor	r15, r15
    2d1c:	60 e8       	ldi	r22, 0x80	; 128
    2d1e:	74 e8       	ldi	r23, 0x84	; 132
    2d20:	8e e1       	ldi	r24, 0x1E	; 30
    2d22:	90 e0       	ldi	r25, 0x00	; 0
    2d24:	a7 01       	movw	r20, r14
    2d26:	96 01       	movw	r18, r12
    2d28:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    2d2c:	d8 01       	movw	r26, r16
    2d2e:	96 96       	adiw	r26, 0x26	; 38
    2d30:	2d 93       	st	X+, r18
    2d32:	3c 93       	st	X, r19
    2d34:	97 97       	sbiw	r26, 0x27	; 39
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2d36:	60 e4       	ldi	r22, 0x40	; 64
    2d38:	72 e4       	ldi	r23, 0x42	; 66
    2d3a:	8f e0       	ldi	r24, 0x0F	; 15
    2d3c:	90 e0       	ldi	r25, 0x00	; 0
    2d3e:	a7 01       	movw	r20, r14
    2d40:	96 01       	movw	r18, r12
    2d42:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    2d46:	f8 01       	movw	r30, r16
    2d48:	22 af       	sts	0x72, r18
    2d4a:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2d4c:	e0 e4       	ldi	r30, 0x40	; 64
    2d4e:	f8 e0       	ldi	r31, 0x08	; 8
    2d50:	8f 89       	ldd	r24, Y+23	; 0x17
    2d52:	98 8d       	ldd	r25, Y+24	; 0x18
    2d54:	86 a3       	lds	r24, 0x56
    2d56:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    2d58:	80 ed       	ldi	r24, 0xD0	; 208
    2d5a:	d2 01       	movw	r26, r4
    2d5c:	11 96       	adiw	r26, 0x01	; 1
    2d5e:	8c 93       	st	X, r24
    2d60:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2d62:	76 82       	std	Z+6, r7	; 0x06
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2d64:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;
    2d66:	8c e0       	ldi	r24, 0x0C	; 12
    2d68:	81 87       	std	Z+9, r24	; 0x09
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2d6a:	80 81       	ld	r24, Z
    2d6c:	80 7f       	andi	r24, 0xF0	; 240
    2d6e:	89 60       	ori	r24, 0x09	; 9
    2d70:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2d72:	f8 01       	movw	r30, r16
    2d74:	80 81       	ld	r24, Z
    2d76:	80 7f       	andi	r24, 0xF0	; 240
    2d78:	81 60       	ori	r24, 0x01	; 1
    2d7a:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    2d7c:	df 91       	pop	r29
    2d7e:	cf 91       	pop	r28
    2d80:	1f 91       	pop	r17
    2d82:	0f 91       	pop	r16
    2d84:	ff 90       	pop	r15
    2d86:	ef 90       	pop	r14
    2d88:	df 90       	pop	r13
    2d8a:	cf 90       	pop	r12
    2d8c:	bf 90       	pop	r11
    2d8e:	af 90       	pop	r10
    2d90:	9f 90       	pop	r9
    2d92:	8f 90       	pop	r8
    2d94:	7f 90       	pop	r7
    2d96:	5f 90       	pop	r5
    2d98:	4f 90       	pop	r4
    2d9a:	3f 90       	pop	r3
    2d9c:	2f 90       	pop	r2
    2d9e:	08 95       	ret

00002da0 <CO_collectSeismic1Channel>:
	sampleCount++;

}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2da0:	2f 92       	push	r2
    2da2:	3f 92       	push	r3
    2da4:	4f 92       	push	r4
    2da6:	5f 92       	push	r5
    2da8:	6f 92       	push	r6
    2daa:	7f 92       	push	r7
    2dac:	8f 92       	push	r8
    2dae:	9f 92       	push	r9
    2db0:	af 92       	push	r10
    2db2:	bf 92       	push	r11
    2db4:	cf 92       	push	r12
    2db6:	df 92       	push	r13
    2db8:	ef 92       	push	r14
    2dba:	ff 92       	push	r15
    2dbc:	0f 93       	push	r16
    2dbe:	cf 93       	push	r28
    2dc0:	df 93       	push	r29
    2dc2:	0f 92       	push	r0
    2dc4:	0f 92       	push	r0
    2dc6:	cd b7       	in	r28, 0x3d	; 61
    2dc8:	de b7       	in	r29, 0x3e	; 62
    2dca:	96 2f       	mov	r25, r22
    2dcc:	49 83       	std	Y+1, r20	; 0x01
    2dce:	5a 83       	std	Y+2, r21	; 0x02
    2dd0:	52 2f       	mov	r21, r18
    2dd2:	70 2f       	mov	r23, r16
    2dd4:	37 01       	movw	r6, r14
    2dd6:	26 01       	movw	r4, r12
    2dd8:	15 01       	movw	r2, r10
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    2dda:	2d b7       	in	r18, 0x3d	; 61
    2ddc:	3e b7       	in	r19, 0x3e	; 62
    2dde:	29 50       	subi	r18, 0x09	; 9
    2de0:	30 40       	sbci	r19, 0x00	; 0
    2de2:	2d bf       	out	0x3d, r18	; 61
    2de4:	3e bf       	out	0x3e, r19	; 62
    2de6:	ed b7       	in	r30, 0x3d	; 61
    2de8:	fe b7       	in	r31, 0x3e	; 62
    2dea:	31 96       	adiw	r30, 0x01	; 1
    2dec:	ad b7       	in	r26, 0x3d	; 61
    2dee:	be b7       	in	r27, 0x3e	; 62
    2df0:	11 96       	adiw	r26, 0x01	; 1
    2df2:	8d 92       	st	X+, r8
    2df4:	9c 92       	st	X, r9
    2df6:	12 97       	sbiw	r26, 0x02	; 2
    2df8:	2f 89       	ldd	r18, Y+23	; 0x17
    2dfa:	38 8d       	ldd	r19, Y+24	; 0x18
    2dfc:	22 83       	std	Z+2, r18	; 0x02
    2dfe:	33 83       	std	Z+3, r19	; 0x03
    2e00:	29 8d       	ldd	r18, Y+25	; 0x19
    2e02:	3a 8d       	ldd	r19, Y+26	; 0x1a
    2e04:	24 83       	std	Z+4, r18	; 0x04
    2e06:	35 83       	std	Z+5, r19	; 0x05
    2e08:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2e0a:	3c 8d       	ldd	r19, Y+28	; 0x1c
    2e0c:	26 83       	std	Z+6, r18	; 0x06
    2e0e:	37 83       	std	Z+7, r19	; 0x07
    2e10:	2d 8d       	ldd	r18, Y+29	; 0x1d
    2e12:	20 87       	std	Z+8, r18	; 0x08
    2e14:	64 ec       	ldi	r22, 0xC4	; 196
    2e16:	49 2f       	mov	r20, r25
    2e18:	29 81       	ldd	r18, Y+1	; 0x01
    2e1a:	3a 81       	ldd	r19, Y+2	; 0x02
    2e1c:	05 2f       	mov	r16, r21
    2e1e:	e7 2e       	mov	r14, r23
    2e20:	63 01       	movw	r12, r6
    2e22:	52 01       	movw	r10, r4
    2e24:	41 01       	movw	r8, r2
    2e26:	0e 94 fe 15 	call	0x2bfc	; 0x2bfc <CO_collectSeismic1Channel_ext>
    2e2a:	2d b7       	in	r18, 0x3d	; 61
    2e2c:	3e b7       	in	r19, 0x3e	; 62
    2e2e:	27 5f       	subi	r18, 0xF7	; 247
    2e30:	3f 4f       	sbci	r19, 0xFF	; 255
    2e32:	2d bf       	out	0x3d, r18	; 61
    2e34:	3e bf       	out	0x3e, r19	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}
    2e36:	0f 90       	pop	r0
    2e38:	0f 90       	pop	r0
    2e3a:	df 91       	pop	r29
    2e3c:	cf 91       	pop	r28
    2e3e:	0f 91       	pop	r16
    2e40:	ff 90       	pop	r15
    2e42:	ef 90       	pop	r14
    2e44:	df 90       	pop	r13
    2e46:	cf 90       	pop	r12
    2e48:	bf 90       	pop	r11
    2e4a:	af 90       	pop	r10
    2e4c:	9f 90       	pop	r9
    2e4e:	8f 90       	pop	r8
    2e50:	7f 90       	pop	r7
    2e52:	6f 90       	pop	r6
    2e54:	5f 90       	pop	r5
    2e56:	4f 90       	pop	r4
    2e58:	3f 90       	pop	r3
    2e5a:	2f 90       	pop	r2
    2e5c:	08 95       	ret

00002e5e <CO_collectSeismic3Axises_ext>:
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}	
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2e5e:	2f 92       	push	r2
    2e60:	3f 92       	push	r3
    2e62:	5f 92       	push	r5
    2e64:	6f 92       	push	r6
    2e66:	7f 92       	push	r7
    2e68:	8f 92       	push	r8
    2e6a:	9f 92       	push	r9
    2e6c:	af 92       	push	r10
    2e6e:	bf 92       	push	r11
    2e70:	cf 92       	push	r12
    2e72:	df 92       	push	r13
    2e74:	ef 92       	push	r14
    2e76:	ff 92       	push	r15
    2e78:	0f 93       	push	r16
    2e7a:	1f 93       	push	r17
    2e7c:	cf 93       	push	r28
    2e7e:	df 93       	push	r29
    2e80:	0f 92       	push	r0
    2e82:	0f 92       	push	r0
    2e84:	cd b7       	in	r28, 0x3d	; 61
    2e86:	de b7       	in	r29, 0x3e	; 62
    2e88:	18 2f       	mov	r17, r24
    2e8a:	3b 01       	movw	r6, r22
    2e8c:	49 83       	std	Y+1, r20	; 0x01
    2e8e:	5a 83       	std	Y+2, r21	; 0x02
    2e90:	52 2e       	mov	r5, r18
	
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	ADC_BUFFER = DataArray;
    2e92:	89 8d       	ldd	r24, Y+25	; 0x19
    2e94:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2e96:	80 93 63 50 	sts	0x5063, r24
    2e9a:	90 93 64 50 	sts	0x5064, r25
	ADC_Sampling_Finished = 0;
    2e9e:	10 92 a6 50 	sts	0x50A6, r1
	ADC_buffer_size = BufferSize;
    2ea2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2ea4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2ea6:	80 93 a7 50 	sts	0x50A7, r24
    2eaa:	90 93 a8 50 	sts	0x50A8, r25
	if(use_FRAM){
    2eae:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2eb0:	88 23       	and	r24, r24
    2eb2:	21 f0       	breq	.+8      	; 0x2ebc <CO_collectSeismic3Axises_ext+0x5e>
		write_to_FRAM = 1;
    2eb4:	81 e0       	ldi	r24, 0x01	; 1
    2eb6:	80 93 48 40 	sts	0x4048, r24
    2eba:	02 c0       	rjmp	.+4      	; 0x2ec0 <CO_collectSeismic3Axises_ext+0x62>
	}
	else{
		write_to_FRAM = 0;
    2ebc:	10 92 48 40 	sts	0x4048, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2ec0:	81 e0       	ldi	r24, 0x01	; 1
    2ec2:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2ec6:	85 e0       	ldi	r24, 0x05	; 5
    2ec8:	d3 01       	movw	r26, r6
    2eca:	6c 91       	ld	r22, X
    2ecc:	0e 94 1f 0c 	call	0x183e	; 0x183e <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    2ed0:	86 e0       	ldi	r24, 0x06	; 6
    2ed2:	f3 01       	movw	r30, r6
    2ed4:	61 81       	ldd	r22, Z+1	; 0x01
    2ed6:	0e 94 1f 0c 	call	0x183e	; 0x183e <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2eda:	87 e0       	ldi	r24, 0x07	; 7
    2edc:	d3 01       	movw	r26, r6
    2ede:	12 96       	adiw	r26, 0x02	; 2
    2ee0:	6c 91       	ld	r22, X
    2ee2:	0e 94 1f 0c 	call	0x183e	; 0x183e <set_ampGain>
	set_filter(filterConfig);
    2ee6:	81 2f       	mov	r24, r17
    2ee8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2eec:	80 2f       	mov	r24, r16
    2eee:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2ef2:	84 e0       	ldi	r24, 0x04	; 4
    2ef4:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2ef8:	84 e5       	ldi	r24, 0x54	; 84
    2efa:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2efe:	81 e0       	ldi	r24, 0x01	; 1
    2f00:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    2f04:	85 e0       	ldi	r24, 0x05	; 5
    2f06:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2f0a:	e0 ea       	ldi	r30, 0xA0	; 160
    2f0c:	f6 e0       	ldi	r31, 0x06	; 6
    2f0e:	22 e0       	ldi	r18, 0x02	; 2
    2f10:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2f12:	66 24       	eor	r6, r6
    2f14:	63 94       	inc	r6
    2f16:	62 82       	std	Z+2, r6	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2f18:	0f 2e       	mov	r0, r31
    2f1a:	f0 e8       	ldi	r31, 0x80	; 128
    2f1c:	2f 2e       	mov	r2, r31
    2f1e:	f1 e0       	ldi	r31, 0x01	; 1
    2f20:	3f 2e       	mov	r3, r31
    2f22:	f0 2d       	mov	r31, r0
    2f24:	88 e7       	ldi	r24, 0x78	; 120
    2f26:	f1 01       	movw	r30, r2
    2f28:	80 83       	st	Z, r24

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2f2a:	e0 e0       	ldi	r30, 0x00	; 0
    2f2c:	f8 e0       	ldi	r31, 0x08	; 8
    2f2e:	80 ef       	ldi	r24, 0xF0	; 240
    2f30:	81 83       	std	Z+1, r24	; 0x01
	TCC0.CCA = averagingPtA;
    2f32:	e0 a6       	lds	r30, 0xb0
    2f34:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    2f36:	c2 a6       	lds	r28, 0xb2
    2f38:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    2f3a:	a4 a6       	lds	r26, 0xb4
    2f3c:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    2f3e:	86 a6       	lds	r24, 0xb6
    2f40:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    2f42:	85 2d       	mov	r24, r5
    2f44:	90 e0       	ldi	r25, 0x00	; 0
    2f46:	01 97       	sbiw	r24, 0x01	; 1
    2f48:	86 a3       	lds	r24, 0x56
    2f4a:	97 a3       	lds	r25, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2f4c:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2f4e:	8f ef       	ldi	r24, 0xFF	; 255
    2f50:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2f52:	80 81       	ld	r24, Z
    2f54:	80 7f       	andi	r24, 0xF0	; 240
    2f56:	88 60       	ori	r24, 0x08	; 8
    2f58:	80 83       	st	Z, r24

	sampleCount = 0;
    2f5a:	10 92 65 50 	sts	0x5065, r1
    2f5e:	10 92 66 50 	sts	0x5066, r1
    2f62:	10 92 67 50 	sts	0x5067, r1
    2f66:	10 92 68 50 	sts	0x5068, r1
	SPICount = 0;
    2f6a:	10 92 a0 50 	sts	0x50A0, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2f6e:	83 e1       	ldi	r24, 0x13	; 19
    2f70:	91 e2       	ldi	r25, 0x21	; 33
    2f72:	10 92 13 21 	sts	0x2113, r1
    2f76:	fc 01       	movw	r30, r24
    2f78:	31 97       	sbiw	r30, 0x01	; 1
    2f7a:	10 82       	st	Z, r1
    2f7c:	02 97       	sbiw	r24, 0x02	; 2
    2f7e:	dc 01       	movw	r26, r24
    2f80:	1c 92       	st	X, r1

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm);
    2f82:	e0 ea       	ldi	r30, 0xA0	; 160
    2f84:	f0 e0       	ldi	r31, 0x00	; 0
    2f86:	82 81       	ldd	r24, Z+2	; 0x02
    2f88:	87 60       	ori	r24, 0x07	; 7
    2f8a:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2f8c:	78 94       	sei

	SPICS(TRUE);
    2f8e:	81 e0       	ldi	r24, 0x01	; 1
    2f90:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2f94:	80 e2       	ldi	r24, 0x20	; 32
    2f96:	e0 e8       	ldi	r30, 0x80	; 128
    2f98:	f6 e0       	ldi	r31, 0x06	; 6
    2f9a:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2f9c:	00 e4       	ldi	r16, 0x40	; 64
    2f9e:	1a e0       	ldi	r17, 0x0A	; 10
    2fa0:	83 e2       	ldi	r24, 0x23	; 35
    2fa2:	f8 01       	movw	r30, r16
    2fa4:	81 83       	std	Z+1, r24	; 0x01
	// set period of waveform generator and duty cycle (want duty cycle to be half the period to get clean clock signal)
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2fa6:	89 81       	ldd	r24, Y+1	; 0x01
    2fa8:	9a 81       	ldd	r25, Y+2	; 0x02
    2faa:	6c 01       	movw	r12, r24
    2fac:	ee 24       	eor	r14, r14
    2fae:	ff 24       	eor	r15, r15
    2fb0:	60 e8       	ldi	r22, 0x80	; 128
    2fb2:	74 e8       	ldi	r23, 0x84	; 132
    2fb4:	8e e1       	ldi	r24, 0x1E	; 30
    2fb6:	90 e0       	ldi	r25, 0x00	; 0
    2fb8:	a7 01       	movw	r20, r14
    2fba:	96 01       	movw	r18, r12
    2fbc:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    2fc0:	d8 01       	movw	r26, r16
    2fc2:	96 96       	adiw	r26, 0x26	; 38
    2fc4:	2d 93       	st	X+, r18
    2fc6:	3c 93       	st	X, r19
    2fc8:	97 97       	sbiw	r26, 0x27	; 39
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2fca:	60 e4       	ldi	r22, 0x40	; 64
    2fcc:	72 e4       	ldi	r23, 0x42	; 66
    2fce:	8f e0       	ldi	r24, 0x0F	; 15
    2fd0:	90 e0       	ldi	r25, 0x00	; 0
    2fd2:	a7 01       	movw	r20, r14
    2fd4:	96 01       	movw	r18, r12
    2fd6:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    2fda:	f8 01       	movw	r30, r16
    2fdc:	22 af       	sts	0x72, r18
    2fde:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2fe0:	e0 e4       	ldi	r30, 0x40	; 64
    2fe2:	f8 e0       	ldi	r31, 0x08	; 8
    2fe4:	8f 89       	ldd	r24, Y+23	; 0x17
    2fe6:	98 8d       	ldd	r25, Y+24	; 0x18
    2fe8:	86 a3       	lds	r24, 0x56
    2fea:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
    2fec:	80 ec       	ldi	r24, 0xC0	; 192
    2fee:	d1 01       	movw	r26, r2
    2ff0:	11 96       	adiw	r26, 0x01	; 1
    2ff2:	8c 93       	st	X, r24
    2ff4:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2ff6:	66 82       	std	Z+6, r6	; 0x06
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2ff8:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;
    2ffa:	8c e0       	ldi	r24, 0x0C	; 12
    2ffc:	81 87       	std	Z+9, r24	; 0x09
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2ffe:	80 81       	ld	r24, Z
    3000:	80 7f       	andi	r24, 0xF0	; 240
    3002:	89 60       	ori	r24, 0x09	; 9
    3004:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    3006:	f8 01       	movw	r30, r16
    3008:	80 81       	ld	r24, Z
    300a:	80 7f       	andi	r24, 0xF0	; 240
    300c:	81 60       	ori	r24, 0x01	; 1
    300e:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    3010:	0f 90       	pop	r0
    3012:	0f 90       	pop	r0
    3014:	df 91       	pop	r29
    3016:	cf 91       	pop	r28
    3018:	1f 91       	pop	r17
    301a:	0f 91       	pop	r16
    301c:	ff 90       	pop	r15
    301e:	ef 90       	pop	r14
    3020:	df 90       	pop	r13
    3022:	cf 90       	pop	r12
    3024:	bf 90       	pop	r11
    3026:	af 90       	pop	r10
    3028:	9f 90       	pop	r9
    302a:	8f 90       	pop	r8
    302c:	7f 90       	pop	r7
    302e:	6f 90       	pop	r6
    3030:	5f 90       	pop	r5
    3032:	3f 90       	pop	r3
    3034:	2f 90       	pop	r2
    3036:	08 95       	ret

00003038 <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    3038:	2f 92       	push	r2
    303a:	3f 92       	push	r3
    303c:	4f 92       	push	r4
    303e:	5f 92       	push	r5
    3040:	6f 92       	push	r6
    3042:	7f 92       	push	r7
    3044:	8f 92       	push	r8
    3046:	9f 92       	push	r9
    3048:	af 92       	push	r10
    304a:	bf 92       	push	r11
    304c:	cf 92       	push	r12
    304e:	df 92       	push	r13
    3050:	ef 92       	push	r14
    3052:	ff 92       	push	r15
    3054:	0f 93       	push	r16
    3056:	1f 93       	push	r17
    3058:	cf 93       	push	r28
    305a:	df 93       	push	r29
    305c:	00 d0       	rcall	.+0      	; 0x305e <CO_collectSeismic3Axises+0x26>
    305e:	0f 92       	push	r0
    3060:	cd b7       	in	r28, 0x3d	; 61
    3062:	de b7       	in	r29, 0x3e	; 62
    3064:	dc 01       	movw	r26, r24
    3066:	3b 01       	movw	r6, r22
    3068:	94 2f       	mov	r25, r20
    306a:	32 2f       	mov	r19, r18
    306c:	28 01       	movw	r4, r16
    306e:	17 01       	movw	r2, r14
    3070:	c9 82       	std	Y+1, r12	; 0x01
    3072:	da 82       	std	Y+2, r13	; 0x02
    3074:	ab 82       	std	Y+3, r10	; 0x03
    3076:	bc 82       	std	Y+4, r11	; 0x04
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    3078:	4d b7       	in	r20, 0x3d	; 61
    307a:	5e b7       	in	r21, 0x3e	; 62
    307c:	47 50       	subi	r20, 0x07	; 7
    307e:	50 40       	sbci	r21, 0x00	; 0
    3080:	4d bf       	out	0x3d, r20	; 61
    3082:	5e bf       	out	0x3e, r21	; 62
    3084:	6d b7       	in	r22, 0x3d	; 61
    3086:	7e b7       	in	r23, 0x3e	; 62
    3088:	6f 5f       	subi	r22, 0xFF	; 255
    308a:	7f 4f       	sbci	r23, 0xFF	; 255
    308c:	ed b7       	in	r30, 0x3d	; 61
    308e:	fe b7       	in	r31, 0x3e	; 62
    3090:	81 82       	std	Z+1, r8	; 0x01
    3092:	92 82       	std	Z+2, r9	; 0x02
    3094:	4a 8d       	ldd	r20, Y+26	; 0x1a
    3096:	5b 8d       	ldd	r21, Y+27	; 0x1b
    3098:	fb 01       	movw	r30, r22
    309a:	42 83       	std	Z+2, r20	; 0x02
    309c:	53 83       	std	Z+3, r21	; 0x03
    309e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    30a0:	5d 8d       	ldd	r21, Y+29	; 0x1d
    30a2:	44 83       	std	Z+4, r20	; 0x04
    30a4:	55 83       	std	Z+5, r21	; 0x05
    30a6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    30a8:	86 83       	std	Z+6, r24	; 0x06
    30aa:	84 ec       	ldi	r24, 0xC4	; 196
    30ac:	bd 01       	movw	r22, r26
    30ae:	a3 01       	movw	r20, r6
    30b0:	29 2f       	mov	r18, r25
    30b2:	03 2f       	mov	r16, r19
    30b4:	72 01       	movw	r14, r4
    30b6:	61 01       	movw	r12, r2
    30b8:	a9 80       	ldd	r10, Y+1	; 0x01
    30ba:	ba 80       	ldd	r11, Y+2	; 0x02
    30bc:	8b 80       	ldd	r8, Y+3	; 0x03
    30be:	9c 80       	ldd	r9, Y+4	; 0x04
    30c0:	0e 94 2f 17 	call	0x2e5e	; 0x2e5e <CO_collectSeismic3Axises_ext>
    30c4:	4d b7       	in	r20, 0x3d	; 61
    30c6:	5e b7       	in	r21, 0x3e	; 62
    30c8:	49 5f       	subi	r20, 0xF9	; 249
    30ca:	5f 4f       	sbci	r21, 0xFF	; 255
    30cc:	4d bf       	out	0x3d, r20	; 61
    30ce:	5e bf       	out	0x3e, r21	; 62
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}	
    30d0:	24 96       	adiw	r28, 0x04	; 4
    30d2:	cd bf       	out	0x3d, r28	; 61
    30d4:	de bf       	out	0x3e, r29	; 62
    30d6:	df 91       	pop	r29
    30d8:	cf 91       	pop	r28
    30da:	1f 91       	pop	r17
    30dc:	0f 91       	pop	r16
    30de:	ff 90       	pop	r15
    30e0:	ef 90       	pop	r14
    30e2:	df 90       	pop	r13
    30e4:	cf 90       	pop	r12
    30e6:	bf 90       	pop	r11
    30e8:	af 90       	pop	r10
    30ea:	9f 90       	pop	r9
    30ec:	8f 90       	pop	r8
    30ee:	7f 90       	pop	r7
    30f0:	6f 90       	pop	r6
    30f2:	5f 90       	pop	r5
    30f4:	4f 90       	pop	r4
    30f6:	3f 90       	pop	r3
    30f8:	2f 90       	pop	r2
    30fa:	08 95       	ret

000030fc <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    30fc:	6f 92       	push	r6
    30fe:	7f 92       	push	r7
    3100:	8f 92       	push	r8
    3102:	9f 92       	push	r9
    3104:	af 92       	push	r10
    3106:	bf 92       	push	r11
    3108:	cf 92       	push	r12
    310a:	df 92       	push	r13
    310c:	ef 92       	push	r14
    310e:	ff 92       	push	r15
    3110:	0f 93       	push	r16
    3112:	1f 93       	push	r17
    3114:	cf 93       	push	r28
    3116:	df 93       	push	r29
    3118:	c8 2f       	mov	r28, r24
    311a:	b6 2e       	mov	r11, r22
    311c:	d4 2f       	mov	r29, r20
    311e:	49 01       	movw	r8, r18
    3120:	38 01       	movw	r6, r16
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	uint16_t period;
	ADC_BUFFER = DataArray;
    3122:	e0 92 63 50 	sts	0x5063, r14
    3126:	f0 92 64 50 	sts	0x5064, r15
	ADC_Sampling_Finished = 0;
    312a:	10 92 a6 50 	sts	0x50A6, r1
	ADC_buffer_size = BufferSize;
    312e:	c0 92 a7 50 	sts	0x50A7, r12
    3132:	d0 92 a8 50 	sts	0x50A8, r13
	if(use_FRAM){
    3136:	aa 20       	and	r10, r10
    3138:	21 f0       	breq	.+8      	; 0x3142 <CO_collectADC_ext+0x46>
		write_to_FRAM = 1;
    313a:	81 e0       	ldi	r24, 0x01	; 1
    313c:	80 93 48 40 	sts	0x4048, r24
    3140:	02 c0       	rjmp	.+4      	; 0x3146 <CO_collectADC_ext+0x4a>
	}
	else{
		write_to_FRAM = 0;
    3142:	10 92 48 40 	sts	0x4048, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    3146:	81 e0       	ldi	r24, 0x01	; 1
    3148:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    314c:	8c 2f       	mov	r24, r28
    314e:	6d 2f       	mov	r22, r29
    3150:	0e 94 1f 0c 	call	0x183e	; 0x183e <set_ampGain>
	set_filter(filterConfig);
    3154:	8b 2d       	mov	r24, r11
    3156:	0e 94 fd 03 	call	0x7fa	; 0x7fa <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    315a:	8c 2f       	mov	r24, r28
    315c:	85 50       	subi	r24, 0x05	; 5
    315e:	83 30       	cpi	r24, 0x03	; 3
    3160:	18 f4       	brcc	.+6      	; 0x3168 <CO_collectADC_ext+0x6c>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    3162:	81 e0       	ldi	r24, 0x01	; 1
    3164:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    3168:	81 e0       	ldi	r24, 0x01	; 1
    316a:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <enableADCMUX>
	setADCInput(channel);
    316e:	8c 2f       	mov	r24, r28
    3170:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    3174:	84 e0       	ldi	r24, 0x04	; 4
    3176:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    317a:	84 e5       	ldi	r24, 0x54	; 84
    317c:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    3180:	e0 ea       	ldi	r30, 0xA0	; 160
    3182:	f6 e0       	ldi	r31, 0x06	; 6
    3184:	ee 24       	eor	r14, r14
    3186:	e3 94       	inc	r14
    3188:	e2 82       	std	Z+2, r14	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    318a:	82 e0       	ldi	r24, 0x02	; 2
    318c:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    318e:	e2 86       	std	Z+10, r14	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_MED_gc;				
    3190:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    3192:	80 e2       	ldi	r24, 0x20	; 32
    3194:	e0 e8       	ldi	r30, 0x80	; 128
    3196:	f6 e0       	ldi	r31, 0x06	; 6
    3198:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    319a:	c0 e4       	ldi	r28, 0x40	; 64
    319c:	da e0       	ldi	r29, 0x0A	; 10
    319e:	83 e2       	ldi	r24, 0x23	; 35
    31a0:	89 83       	std	Y+1, r24	; 0x01
	// set period of waveform generator and ccb as duty cycle (want half the period for duty cycle to have good clock signal)
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    31a2:	94 01       	movw	r18, r8
    31a4:	40 e0       	ldi	r20, 0x00	; 0
    31a6:	50 e0       	ldi	r21, 0x00	; 0
    31a8:	60 e8       	ldi	r22, 0x80	; 128
    31aa:	74 e8       	ldi	r23, 0x84	; 132
    31ac:	8e e1       	ldi	r24, 0x1E	; 30
    31ae:	90 e0       	ldi	r25, 0x00	; 0
    31b0:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    31b4:	89 01       	movw	r16, r18
    31b6:	9a 01       	movw	r18, r20
    31b8:	c8 01       	movw	r24, r16
	TCE1.PER = period;
    31ba:	0e a3       	lds	r16, 0x5e
    31bc:	1f a3       	lds	r17, 0x5f
	TCE1.CCBBUF = period / 2;
    31be:	96 95       	lsr	r25
    31c0:	87 95       	ror	r24
    31c2:	8a af       	sts	0x7a, r24
    31c4:	9b af       	sts	0x7b, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples;
    31c6:	e0 e4       	ldi	r30, 0x40	; 64
    31c8:	f8 e0       	ldi	r31, 0x08	; 8
    31ca:	66 a2       	lds	r22, 0x96
    31cc:	77 a2       	lds	r23, 0x97
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    31ce:	88 e7       	ldi	r24, 0x78	; 120
    31d0:	a0 e8       	ldi	r26, 0x80	; 128
    31d2:	b1 e0       	ldi	r27, 0x01	; 1
    31d4:	11 96       	adiw	r26, 0x01	; 1
    31d6:	8c 93       	st	X, r24
    31d8:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    31da:	e6 82       	std	Z+6, r14	; 0x06
	//reset count to zero
	TCC1.CTRLA = 0x00;
    31dc:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;
    31de:	8c e0       	ldi	r24, 0x0C	; 12
    31e0:	81 87       	std	Z+9, r24	; 0x09
	//TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    31e2:	88 81       	ld	r24, Y
    31e4:	80 7f       	andi	r24, 0xF0	; 240
    31e6:	81 60       	ori	r24, 0x01	; 1
    31e8:	88 83       	st	Y, r24
	
	sampleCount = 0;
    31ea:	10 92 65 50 	sts	0x5065, r1
    31ee:	10 92 66 50 	sts	0x5066, r1
    31f2:	10 92 67 50 	sts	0x5067, r1
    31f6:	10 92 68 50 	sts	0x5068, r1
	discardCount = 0;
    31fa:	10 92 5c 40 	sts	0x405C, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
    31fe:	e0 ea       	ldi	r30, 0xA0	; 160
    3200:	f0 e0       	ldi	r31, 0x00	; 0
    3202:	82 81       	ldd	r24, Z+2	; 0x02
    3204:	83 60       	ori	r24, 0x03	; 3
    3206:	82 83       	std	Z+2, r24	; 0x02
	sei();
    3208:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    320a:	df 91       	pop	r29
    320c:	cf 91       	pop	r28
    320e:	1f 91       	pop	r17
    3210:	0f 91       	pop	r16
    3212:	ff 90       	pop	r15
    3214:	ef 90       	pop	r14
    3216:	df 90       	pop	r13
    3218:	cf 90       	pop	r12
    321a:	bf 90       	pop	r11
    321c:	af 90       	pop	r10
    321e:	9f 90       	pop	r9
    3220:	8f 90       	pop	r8
    3222:	7f 90       	pop	r7
    3224:	6f 90       	pop	r6
    3226:	08 95       	ret

00003228 <CO_collectADC>:
		PORTA.OUTCLR = PIN5_bm;
		PORTA.DIRCLR = PIN5_bm;
	}
}

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    3228:	8f 92       	push	r8
    322a:	9f 92       	push	r9
    322c:	af 92       	push	r10
    322e:	cf 92       	push	r12
    3230:	df 92       	push	r13
    3232:	ef 92       	push	r14
    3234:	ff 92       	push	r15
    3236:	0f 93       	push	r16
    3238:	1f 93       	push	r17
    323a:	cf 93       	push	r28
    323c:	df 93       	push	r29
    323e:	96 2f       	mov	r25, r22
    3240:	fa 01       	movw	r30, r20
    3242:	d9 01       	movw	r26, r18
    3244:	e8 01       	movw	r28, r16
    3246:	47 01       	movw	r8, r14
    3248:	ac 2c       	mov	r10, r12
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_1AND5_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray, BufferSize, use_FRAM);
    324a:	61 ec       	ldi	r22, 0xC1	; 193
    324c:	49 2f       	mov	r20, r25
    324e:	9f 01       	movw	r18, r30
    3250:	8d 01       	movw	r16, r26
    3252:	7e 01       	movw	r14, r28
    3254:	64 01       	movw	r12, r8
    3256:	0e 94 7e 18 	call	0x30fc	; 0x30fc <CO_collectADC_ext>
}
    325a:	df 91       	pop	r29
    325c:	cf 91       	pop	r28
    325e:	1f 91       	pop	r17
    3260:	0f 91       	pop	r16
    3262:	ff 90       	pop	r15
    3264:	ef 90       	pop	r14
    3266:	df 90       	pop	r13
    3268:	cf 90       	pop	r12
    326a:	af 90       	pop	r10
    326c:	9f 90       	pop	r9
    326e:	8f 90       	pop	r8
    3270:	08 95       	ret

00003272 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    3272:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3274:	81 e0       	ldi	r24, 0x01	; 1
    3276:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    3278:	84 81       	ldd	r24, Z+4	; 0x04
    327a:	95 81       	ldd	r25, Z+5	; 0x05
    327c:	86 1b       	sub	r24, r22
    327e:	91 09       	sbc	r25, r1

	return answer;
}
    3280:	08 95       	ret

00003282 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    3282:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3284:	81 e0       	ldi	r24, 0x01	; 1
    3286:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    3288:	84 81       	ldd	r24, Z+4	; 0x04
    328a:	95 81       	ldd	r25, Z+5	; 0x05
    328c:	77 27       	eor	r23, r23
    328e:	67 fd       	sbrc	r22, 7
    3290:	70 95       	com	r23
    3292:	86 1b       	sub	r24, r22
    3294:	97 0b       	sbc	r25, r23

	return answer;
}
    3296:	08 95       	ret

00003298 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    3298:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    329a:	81 e0       	ldi	r24, 0x01	; 1
    329c:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    329e:	84 81       	ldd	r24, Z+4	; 0x04
    32a0:	95 81       	ldd	r25, Z+5	; 0x05
}
    32a2:	08 95       	ret

000032a4 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    32a4:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    32a6:	81 e0       	ldi	r24, 0x01	; 1
    32a8:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    32aa:	84 81       	ldd	r24, Z+4	; 0x04
}
    32ac:	08 95       	ret

000032ae <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    32ae:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    32b0:	81 e0       	ldi	r24, 0x01	; 1
    32b2:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    32b4:	85 81       	ldd	r24, Z+5	; 0x05
}
    32b6:	08 95       	ret

000032b8 <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    32b8:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    32ba:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    32bc:	14 82       	std	Z+4, r1	; 0x04
    32be:	9a e2       	ldi	r25, 0x2A	; 42
    32c0:	9a 95       	dec	r25
    32c2:	f1 f7       	brne	.-4      	; 0x32c0 <ADC_Wait_8MHz+0x8>
    32c4:	00 c0       	rjmp	.+0      	; 0x32c6 <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    32c6:	84 83       	std	Z+4, r24	; 0x04
}
    32c8:	08 95       	ret

000032ca <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    32ca:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    32cc:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    32ce:	91 e0       	ldi	r25, 0x01	; 1
    32d0:	94 83       	std	Z+4, r25	; 0x04
    32d2:	95 e5       	ldi	r25, 0x55	; 85
    32d4:	9a 95       	dec	r25
    32d6:	f1 f7       	brne	.-4      	; 0x32d4 <ADC_Wait_32MHz+0xa>
    32d8:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    32da:	84 83       	std	Z+4, r24	; 0x04
}
    32dc:	08 95       	ret

000032de <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    32de:	ef 92       	push	r14
    32e0:	ff 92       	push	r15
    32e2:	0f 93       	push	r16
    32e4:	1f 93       	push	r17
    32e6:	cf 93       	push	r28
    32e8:	df 93       	push	r29
    32ea:	eb 01       	movw	r28, r22
    if (oversampling)
    32ec:	44 23       	and	r20, r20
    32ee:	c9 f0       	breq	.+50     	; 0x3322 <ADC_Offset_Get_Unsigned+0x44>
    32f0:	04 e0       	ldi	r16, 0x04	; 4
    32f2:	10 e0       	ldi	r17, 0x00	; 0
    32f4:	ee 24       	eor	r14, r14
    32f6:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    32f8:	88 81       	ld	r24, Y
    32fa:	80 68       	ori	r24, 0x80	; 128
    32fc:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    32fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3300:	80 ff       	sbrs	r24, 0
    3302:	fd cf       	rjmp	.-6      	; 0x32fe <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    3304:	ce 01       	movw	r24, r28
    3306:	60 e0       	ldi	r22, 0x00	; 0
    3308:	0e 94 39 19 	call	0x3272	; 0x3272 <ADC_ResultCh_GetWord_Unsigned>
    330c:	e8 0e       	add	r14, r24
    330e:	f9 1e       	adc	r15, r25
    3310:	01 50       	subi	r16, 0x01	; 1
    3312:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    3314:	89 f7       	brne	.-30     	; 0x32f8 <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    3316:	c7 01       	movw	r24, r14
    3318:	96 95       	lsr	r25
    331a:	87 95       	ror	r24
    331c:	96 95       	lsr	r25
    331e:	87 95       	ror	r24
    3320:	09 c0       	rjmp	.+18     	; 0x3334 <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3322:	88 81       	ld	r24, Y
    3324:	80 68       	ori	r24, 0x80	; 128
    3326:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3328:	8b 81       	ldd	r24, Y+3	; 0x03
    332a:	80 ff       	sbrs	r24, 0
    332c:	fd cf       	rjmp	.-6      	; 0x3328 <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    332e:	ce 01       	movw	r24, r28
    3330:	0e 94 4c 19 	call	0x3298	; 0x3298 <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
    3334:	df 91       	pop	r29
    3336:	cf 91       	pop	r28
    3338:	1f 91       	pop	r17
    333a:	0f 91       	pop	r16
    333c:	ff 90       	pop	r15
    333e:	ef 90       	pop	r14
    3340:	08 95       	ret

00003342 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3342:	ef 92       	push	r14
    3344:	ff 92       	push	r15
    3346:	0f 93       	push	r16
    3348:	1f 93       	push	r17
    334a:	cf 93       	push	r28
    334c:	df 93       	push	r29
    334e:	eb 01       	movw	r28, r22
    if (oversampling)
    3350:	44 23       	and	r20, r20
    3352:	e1 f0       	breq	.+56     	; 0x338c <ADC_Offset_Get_Signed+0x4a>
    3354:	04 e0       	ldi	r16, 0x04	; 4
    3356:	10 e0       	ldi	r17, 0x00	; 0
    3358:	ee 24       	eor	r14, r14
    335a:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    335c:	88 81       	ld	r24, Y
    335e:	80 68       	ori	r24, 0x80	; 128
    3360:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3362:	8b 81       	ldd	r24, Y+3	; 0x03
    3364:	80 ff       	sbrs	r24, 0
    3366:	fd cf       	rjmp	.-6      	; 0x3362 <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3368:	ce 01       	movw	r24, r28
    336a:	60 e0       	ldi	r22, 0x00	; 0
    336c:	0e 94 41 19 	call	0x3282	; 0x3282 <ADC_ResultCh_GetWord_Signed>
    3370:	e8 0e       	add	r14, r24
    3372:	f9 1e       	adc	r15, r25
    3374:	01 50       	subi	r16, 0x01	; 1
    3376:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    3378:	89 f7       	brne	.-30     	; 0x335c <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    337a:	c7 01       	movw	r24, r14
    337c:	99 23       	and	r25, r25
    337e:	0c f4       	brge	.+2      	; 0x3382 <ADC_Offset_Get_Signed+0x40>
    3380:	03 96       	adiw	r24, 0x03	; 3
    3382:	95 95       	asr	r25
    3384:	87 95       	ror	r24
    3386:	95 95       	asr	r25
    3388:	87 95       	ror	r24
    338a:	0a c0       	rjmp	.+20     	; 0x33a0 <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    338c:	88 81       	ld	r24, Y
    338e:	80 68       	ori	r24, 0x80	; 128
    3390:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3392:	8b 81       	ldd	r24, Y+3	; 0x03
    3394:	80 ff       	sbrs	r24, 0
    3396:	fd cf       	rjmp	.-6      	; 0x3392 <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3398:	ce 01       	movw	r24, r28
    339a:	60 e0       	ldi	r22, 0x00	; 0
    339c:	0e 94 41 19 	call	0x3282	; 0x3282 <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
    33a0:	df 91       	pop	r29
    33a2:	cf 91       	pop	r28
    33a4:	1f 91       	pop	r17
    33a6:	0f 91       	pop	r16
    33a8:	ff 90       	pop	r15
    33aa:	ef 90       	pop	r14
    33ac:	08 95       	ret

000033ae <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    33ae:	aa ec       	ldi	r26, 0xCA	; 202
    33b0:	b1 e0       	ldi	r27, 0x01	; 1
    33b2:	92 e0       	ldi	r25, 0x02	; 2
    33b4:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
    33b6:	e8 2f       	mov	r30, r24
    33b8:	f0 e0       	ldi	r31, 0x00	; 0
    33ba:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    33bc:	1c 92       	st	X, r1

	return result;
}
    33be:	08 95       	ret

000033c0 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    33c0:	cf 93       	push	r28
    33c2:	df 93       	push	r29
    33c4:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
    33c6:	82 e0       	ldi	r24, 0x02	; 2
    33c8:	c0 30       	cpi	r28, 0x00	; 0
    33ca:	d8 07       	cpc	r29, r24
    33cc:	59 f4       	brne	.+22     	; 0x33e4 <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    33ce:	80 e2       	ldi	r24, 0x20	; 32
    33d0:	0e 94 d7 19 	call	0x33ae	; 0x33ae <SP_ReadCalibrationByte>
    33d4:	c0 e0       	ldi	r28, 0x00	; 0
    33d6:	d2 e0       	ldi	r29, 0x02	; 2
    33d8:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    33da:	81 e2       	ldi	r24, 0x21	; 33
    33dc:	0e 94 d7 19 	call	0x33ae	; 0x33ae <SP_ReadCalibrationByte>
    33e0:	8d 87       	std	Y+13, r24	; 0x0d
    33e2:	08 c0       	rjmp	.+16     	; 0x33f4 <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    33e4:	84 e2       	ldi	r24, 0x24	; 36
    33e6:	0e 94 d7 19 	call	0x33ae	; 0x33ae <SP_ReadCalibrationByte>
    33ea:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    33ec:	85 e2       	ldi	r24, 0x25	; 37
    33ee:	0e 94 d7 19 	call	0x33ae	; 0x33ae <SP_ReadCalibrationByte>
    33f2:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
    33f4:	df 91       	pop	r29
    33f6:	cf 91       	pop	r28
    33f8:	08 95       	ret

000033fa <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
    33fa:	84 e1       	ldi	r24, 0x14	; 20
    33fc:	e4 e1       	ldi	r30, 0x14	; 20
    33fe:	f1 e2       	ldi	r31, 0x21	; 33
    3400:	df 01       	movw	r26, r30
    3402:	1d 92       	st	X+, r1
    3404:	8a 95       	dec	r24
    3406:	e9 f7       	brne	.-6      	; 0x3402 <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
    3408:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <chb_get_short_addr>
    340c:	80 93 14 21 	sts	0x2114, r24
    3410:	90 93 15 21 	sts	0x2115, r25
    chb_drvr_init();
    3414:	0e 94 b0 1d 	call	0x3b60	; 0x3b60 <chb_drvr_init>
	//radio_msg_received_int_enable();
}
    3418:	08 95       	ret

0000341a <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
	PORTE.DIRSET = PIN2_bm;
    341a:	e0 e8       	ldi	r30, 0x80	; 128
    341c:	f6 e0       	ldi	r31, 0x06	; 6
    341e:	84 e0       	ldi	r24, 0x04	; 4
    3420:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    3422:	86 83       	std	Z+6, r24	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    3424:	92 e0       	ldi	r25, 0x02	; 2
    3426:	90 8b       	std	Z+16, r25	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    3428:	82 87       	std	Z+10, r24	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    342a:	83 e0       	ldi	r24, 0x03	; 3
    342c:	81 87       	std	Z+9, r24	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    342e:	e0 ea       	ldi	r30, 0xA0	; 160
    3430:	f0 e0       	ldi	r31, 0x00	; 0
    3432:	82 81       	ldd	r24, Z+2	; 0x02
    3434:	84 60       	ori	r24, 0x04	; 4
    3436:	82 83       	std	Z+2, r24	; 0x02
	sei();
    3438:	78 94       	sei
}
    343a:	08 95       	ret

0000343c <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
    343c:	84 e1       	ldi	r24, 0x14	; 20
    343e:	91 e2       	ldi	r25, 0x21	; 33
    3440:	08 95       	ret

00003442 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    3442:	2f 92       	push	r2
    3444:	3f 92       	push	r3
    3446:	4f 92       	push	r4
    3448:	5f 92       	push	r5
    344a:	6f 92       	push	r6
    344c:	7f 92       	push	r7
    344e:	8f 92       	push	r8
    3450:	9f 92       	push	r9
    3452:	af 92       	push	r10
    3454:	bf 92       	push	r11
    3456:	cf 92       	push	r12
    3458:	df 92       	push	r13
    345a:	ef 92       	push	r14
    345c:	ff 92       	push	r15
    345e:	0f 93       	push	r16
    3460:	1f 93       	push	r17
    3462:	cf 93       	push	r28
    3464:	df 93       	push	r29
    3466:	cd b7       	in	r28, 0x3d	; 61
    3468:	de b7       	in	r29, 0x3e	; 62
    346a:	2a 97       	sbiw	r28, 0x0a	; 10
    346c:	cd bf       	out	0x3d, r28	; 61
    346e:	de bf       	out	0x3e, r29	; 62
    3470:	2c 01       	movw	r4, r24
    3472:	1b 01       	movw	r2, r22
    3474:	69 01       	movw	r12, r18
    3476:	7a 01       	movw	r14, r20
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    3478:	21 15       	cp	r18, r1
    347a:	31 05       	cpc	r19, r1
    347c:	41 05       	cpc	r20, r1
    347e:	51 05       	cpc	r21, r1
    3480:	09 f4       	brne	.+2      	; 0x3484 <chb_write+0x42>
    3482:	68 c0       	rjmp	.+208    	; 0x3554 <chb_write+0x112>
    U8 status, frm_len, hdr[CHB_HDR_SZ + 1];
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    3484:	88 24       	eor	r8, r8
    3486:	99 24       	eor	r9, r9
    3488:	54 01       	movw	r10, r8
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    348a:	08 e9       	ldi	r16, 0x98	; 152

    *hdr_ptr++ = pcb.seq++;
    348c:	0f 2e       	mov	r0, r31
    348e:	f6 e1       	ldi	r31, 0x16	; 22
    3490:	6f 2e       	mov	r6, r31
    3492:	f1 e2       	ldi	r31, 0x21	; 33
    3494:	7f 2e       	mov	r7, r31
    3496:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    3498:	1c 2d       	mov	r17, r12
    349a:	85 e6       	ldi	r24, 0x65	; 101
    349c:	c8 16       	cp	r12, r24
    349e:	d1 04       	cpc	r13, r1
    34a0:	e1 04       	cpc	r14, r1
    34a2:	f1 04       	cpc	r15, r1
    34a4:	08 f0       	brcs	.+2      	; 0x34a8 <chb_write+0x66>
    34a6:	14 e6       	ldi	r17, 0x64	; 100
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    34a8:	81 2f       	mov	r24, r17
    34aa:	85 5f       	subi	r24, 0xF5	; 245
    34ac:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    34ae:	9f ef       	ldi	r25, 0xFF	; 255
    34b0:	49 16       	cp	r4, r25
    34b2:	9f ef       	ldi	r25, 0xFF	; 255
    34b4:	59 06       	cpc	r5, r25
    34b6:	11 f0       	breq	.+4      	; 0x34bc <chb_write+0x7a>
    34b8:	81 e6       	ldi	r24, 0x61	; 97
    34ba:	01 c0       	rjmp	.+2      	; 0x34be <chb_write+0x7c>
    34bc:	81 e4       	ldi	r24, 0x41	; 65
    34be:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    34c0:	0b 83       	std	Y+3, r16	; 0x03

    *hdr_ptr++ = pcb.seq++;
    34c2:	f3 01       	movw	r30, r6
    34c4:	80 81       	ld	r24, Z
    34c6:	8c 83       	std	Y+4, r24	; 0x04
    34c8:	8f 5f       	subi	r24, 0xFF	; 255
    34ca:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    34cc:	84 e3       	ldi	r24, 0x34	; 52
    34ce:	92 e1       	ldi	r25, 0x12	; 18
    34d0:	8d 83       	std	Y+5, r24	; 0x05
    34d2:	9e 83       	std	Y+6, r25	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
    34d4:	4f 82       	std	Y+7, r4	; 0x07
    34d6:	58 86       	std	Y+8, r5	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
    34d8:	e4 e1       	ldi	r30, 0x14	; 20
    34da:	f1 e2       	ldi	r31, 0x21	; 33
    34dc:	80 81       	ld	r24, Z
    34de:	91 81       	ldd	r25, Z+1	; 0x01
    34e0:	89 87       	std	Y+9, r24	; 0x09
    34e2:	9a 87       	std	Y+10, r25	; 0x0a
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		//rtry = 0;
		//do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    34e4:	b1 01       	movw	r22, r2
    34e6:	68 0d       	add	r22, r8
    34e8:	79 1d       	adc	r23, r9
    34ea:	ce 01       	movw	r24, r28
    34ec:	01 96       	adiw	r24, 0x01	; 1
    34ee:	41 2f       	mov	r20, r17
    34f0:	0e 94 ec 1c 	call	0x39d8	; 0x39d8 <chb_tx>

             switch (status)
    34f4:	83 30       	cpi	r24, 0x03	; 3
    34f6:	c9 f0       	breq	.+50     	; 0x352a <chb_write+0xe8>
    34f8:	84 30       	cpi	r24, 0x04	; 4
    34fa:	18 f4       	brcc	.+6      	; 0x3502 <chb_write+0xc0>
    34fc:	81 30       	cpi	r24, 0x01	; 1
    34fe:	e1 f4       	brne	.+56     	; 0x3538 <chb_write+0xf6>
    3500:	04 c0       	rjmp	.+8      	; 0x350a <chb_write+0xc8>
    3502:	85 30       	cpi	r24, 0x05	; 5
    3504:	51 f0       	breq	.+20     	; 0x351a <chb_write+0xd8>
    3506:	80 34       	cpi	r24, 0x40	; 64
    3508:	b9 f4       	brne	.+46     	; 0x3538 <chb_write+0xf6>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    350a:	eb e1       	ldi	r30, 0x1B	; 27
    350c:	f1 e2       	ldi	r31, 0x21	; 33
    350e:	80 81       	ld	r24, Z
    3510:	91 81       	ldd	r25, Z+1	; 0x01
    3512:	01 96       	adiw	r24, 0x01	; 1
    3514:	80 83       	st	Z, r24
    3516:	91 83       	std	Z+1, r25	; 0x01
                 break;
    3518:	0f c0       	rjmp	.+30     	; 0x3538 <chb_write+0xf6>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    351a:	ed e1       	ldi	r30, 0x1D	; 29
    351c:	f1 e2       	ldi	r31, 0x21	; 33
    351e:	80 81       	ld	r24, Z
    3520:	91 81       	ldd	r25, Z+1	; 0x01
    3522:	01 96       	adiw	r24, 0x01	; 1
    3524:	80 83       	st	Z, r24
    3526:	91 83       	std	Z+1, r25	; 0x01
				 //rtry++;
                 break;
    3528:	07 c0       	rjmp	.+14     	; 0x3538 <chb_write+0xf6>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    352a:	ef e1       	ldi	r30, 0x1F	; 31
    352c:	f1 e2       	ldi	r31, 0x21	; 33
    352e:	80 81       	ld	r24, Z
    3530:	91 81       	ldd	r25, Z+1	; 0x01
    3532:	01 96       	adiw	r24, 0x01	; 1
    3534:	80 83       	st	Z, r24
    3536:	91 83       	std	Z+1, r25	; 0x01
             }
			//if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
			//if(rtry==20) return status;;		//after 20 tries give up on sending the message	
		//} while(status != CHB_SUCCESS);			
        // adjust len and restart
		frm_offset += frm_len;
    3538:	81 2f       	mov	r24, r17
    353a:	90 e0       	ldi	r25, 0x00	; 0
    353c:	a0 e0       	ldi	r26, 0x00	; 0
    353e:	b0 e0       	ldi	r27, 0x00	; 0
    3540:	88 0e       	add	r8, r24
    3542:	99 1e       	adc	r9, r25
    3544:	aa 1e       	adc	r10, r26
    3546:	bb 1e       	adc	r11, r27
		//_delay_ms(100);				//wait a little before sending next message
        len = len - frm_len;
    3548:	c8 1a       	sub	r12, r24
    354a:	d9 0a       	sbc	r13, r25
    354c:	ea 0a       	sbc	r14, r26
    354e:	fb 0a       	sbc	r15, r27
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    3550:	09 f0       	breq	.+2      	; 0x3554 <chb_write+0x112>
    3552:	a2 cf       	rjmp	.-188    	; 0x3498 <chb_write+0x56>
		frm_offset += frm_len;
		//_delay_ms(100);				//wait a little before sending next message
        len = len - frm_len;
    }
    return CHB_SUCCESS;
}
    3554:	80 e0       	ldi	r24, 0x00	; 0
    3556:	2a 96       	adiw	r28, 0x0a	; 10
    3558:	cd bf       	out	0x3d, r28	; 61
    355a:	de bf       	out	0x3e, r29	; 62
    355c:	df 91       	pop	r29
    355e:	cf 91       	pop	r28
    3560:	1f 91       	pop	r17
    3562:	0f 91       	pop	r16
    3564:	ff 90       	pop	r15
    3566:	ef 90       	pop	r14
    3568:	df 90       	pop	r13
    356a:	cf 90       	pop	r12
    356c:	bf 90       	pop	r11
    356e:	af 90       	pop	r10
    3570:	9f 90       	pop	r9
    3572:	8f 90       	pop	r8
    3574:	7f 90       	pop	r7
    3576:	6f 90       	pop	r6
    3578:	5f 90       	pop	r5
    357a:	4f 90       	pop	r4
    357c:	3f 90       	pop	r3
    357e:	2f 90       	pop	r2
    3580:	08 95       	ret

00003582 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    3582:	df 92       	push	r13
    3584:	ef 92       	push	r14
    3586:	ff 92       	push	r15
    3588:	0f 93       	push	r16
    358a:	1f 93       	push	r17
    358c:	cf 93       	push	r28
    358e:	df 93       	push	r29
    3590:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    3592:	0e 94 3c 1b 	call	0x3678	; 0x3678 <chb_buf_read>
    3596:	d8 2e       	mov	r13, r24
    3598:	88 23       	and	r24, r24
    359a:	0c f4       	brge	.+2      	; 0x359e <chb_read+0x1c>
    359c:	46 c0       	rjmp	.+140    	; 0x362a <chb_read+0xa8>
    {
        return 0;
    }
    *data_ptr++ = len;
    359e:	f7 01       	movw	r30, r14
    35a0:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    35a2:	88 23       	and	r24, r24
    35a4:	71 f0       	breq	.+28     	; 0x35c2 <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
    35a6:	e7 01       	movw	r28, r14
    35a8:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
    35aa:	87 01       	movw	r16, r14
    35ac:	09 5f       	subi	r16, 0xF9	; 249
    35ae:	1f 4f       	sbci	r17, 0xFF	; 255
    35b0:	81 50       	subi	r24, 0x01	; 1
    35b2:	08 0f       	add	r16, r24
    35b4:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
    35b6:	0e 94 3c 1b 	call	0x3678	; 0x3678 <chb_buf_read>
    35ba:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    35bc:	c0 17       	cp	r28, r16
    35be:	d1 07       	cpc	r29, r17
    35c0:	d1 f7       	brne	.-12     	; 0x35b6 <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
    35c2:	f7 01       	movw	r30, r14
    35c4:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
    35c6:	83 85       	ldd	r24, Z+11	; 0x0b
    35c8:	94 85       	ldd	r25, Z+12	; 0x0c
    35ca:	83 83       	std	Z+3, r24	; 0x03
    35cc:	94 83       	std	Z+4, r25	; 0x04
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
    35ce:	85 85       	ldd	r24, Z+13	; 0x0d
    35d0:	96 85       	ldd	r25, Z+14	; 0x0e
    35d2:	81 83       	std	Z+1, r24	; 0x01
    35d4:	92 83       	std	Z+2, r25	; 0x02
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    35d6:	0e 94 53 1b 	call	0x36a6	; 0x36a6 <chb_buf_get_len>
    35da:	88 23       	and	r24, r24
    35dc:	11 f4       	brne	.+4      	; 0x35e2 <chb_read+0x60>
    {
        pcb.data_rcv = false;
    35de:	10 92 17 21 	sts	0x2117, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    35e2:	80 91 0a 20 	lds	r24, 0x200A
    35e6:	c8 17       	cp	r28, r24
    35e8:	51 f4       	brne	.+20     	; 0x35fe <chb_read+0x7c>
    35ea:	f7 01       	movw	r30, r14
    35ec:	21 81       	ldd	r18, Z+1	; 0x01
    35ee:	32 81       	ldd	r19, Z+2	; 0x02
    35f0:	80 91 0b 20 	lds	r24, 0x200B
    35f4:	90 91 0c 20 	lds	r25, 0x200C
    35f8:	28 17       	cp	r18, r24
    35fa:	39 07       	cpc	r19, r25
    35fc:	c1 f0       	breq	.+48     	; 0x362e <chb_read+0xac>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
    35fe:	c0 93 0a 20 	sts	0x200A, r28
        prev_src_addr = rx->src_addr;
    3602:	f7 01       	movw	r30, r14
    3604:	81 81       	ldd	r24, Z+1	; 0x01
    3606:	92 81       	ldd	r25, Z+2	; 0x02
    3608:	80 93 0b 20 	sts	0x200B, r24
    360c:	90 93 0c 20 	sts	0x200C, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    3610:	b7 01       	movw	r22, r14
    3612:	61 5f       	subi	r22, 0xF1	; 241
    3614:	7f 4f       	sbci	r23, 0xFF	; 255
    3616:	4d 2d       	mov	r20, r13
    3618:	50 e0       	ldi	r21, 0x00	; 0
    361a:	49 50       	subi	r20, 0x09	; 9
    361c:	50 40       	sbci	r21, 0x00	; 0
    361e:	c7 01       	movw	r24, r14
    3620:	0e 94 e0 39 	call	0x73c0	; 0x73c0 <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    3624:	8d 2d       	mov	r24, r13
    3626:	8b 50       	subi	r24, 0x0B	; 11
    3628:	03 c0       	rjmp	.+6      	; 0x3630 <chb_read+0xae>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    362a:	80 e0       	ldi	r24, 0x00	; 0
    362c:	01 c0       	rjmp	.+2      	; 0x3630 <chb_read+0xae>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    362e:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
    3630:	df 91       	pop	r29
    3632:	cf 91       	pop	r28
    3634:	1f 91       	pop	r17
    3636:	0f 91       	pop	r16
    3638:	ff 90       	pop	r15
    363a:	ef 90       	pop	r14
    363c:	df 90       	pop	r13
    363e:	08 95       	ret

00003640 <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
    3640:	10 92 28 21 	sts	0x2128, r1
    wr_ptr = 0;
    3644:	10 92 29 21 	sts	0x2129, r1
    len = 0;
    3648:	10 92 2a 21 	sts	0x212A, r1
}
    364c:	08 95       	ret

0000364e <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
    364e:	20 91 29 21 	lds	r18, 0x2129
    3652:	30 e0       	ldi	r19, 0x00	; 0
    3654:	f9 01       	movw	r30, r18
    3656:	e5 5d       	subi	r30, 0xD5	; 213
    3658:	fe 4d       	sbci	r31, 0xDE	; 222
    365a:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    365c:	c9 01       	movw	r24, r18
    365e:	01 96       	adiw	r24, 0x01	; 1
    3660:	60 e8       	ldi	r22, 0x80	; 128
    3662:	70 e0       	ldi	r23, 0x00	; 0
    3664:	0e 94 44 39 	call	0x7288	; 0x7288 <__divmodhi4>
    3668:	80 93 29 21 	sts	0x2129, r24
    len++;
    366c:	80 91 2a 21 	lds	r24, 0x212A
    3670:	8f 5f       	subi	r24, 0xFF	; 255
    3672:	80 93 2a 21 	sts	0x212A, r24
}
    3676:	08 95       	ret

00003678 <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
    3678:	20 91 28 21 	lds	r18, 0x2128
    367c:	30 e0       	ldi	r19, 0x00	; 0
    367e:	f9 01       	movw	r30, r18
    3680:	e5 5d       	subi	r30, 0xD5	; 213
    3682:	fe 4d       	sbci	r31, 0xDE	; 222
    3684:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    3686:	2f 5f       	subi	r18, 0xFF	; 255
    3688:	3f 4f       	sbci	r19, 0xFF	; 255
    368a:	c9 01       	movw	r24, r18
    368c:	60 e8       	ldi	r22, 0x80	; 128
    368e:	70 e0       	ldi	r23, 0x00	; 0
    3690:	0e 94 44 39 	call	0x7288	; 0x7288 <__divmodhi4>
    3694:	80 93 28 21 	sts	0x2128, r24
    len--;
    3698:	80 91 2a 21 	lds	r24, 0x212A
    369c:	81 50       	subi	r24, 0x01	; 1
    369e:	80 93 2a 21 	sts	0x212A, r24
    return data;
}
    36a2:	84 2f       	mov	r24, r20
    36a4:	08 95       	ret

000036a6 <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
    36a6:	80 91 2a 21 	lds	r24, 0x212A
    36aa:	08 95       	ret

000036ac <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    36ac:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    36ae:	80 e0       	ldi	r24, 0x00	; 0
    36b0:	90 e0       	ldi	r25, 0x00	; 0
    36b2:	48 e0       	ldi	r20, 0x08	; 8
    36b4:	50 e0       	ldi	r21, 0x00	; 0
    36b6:	0e 94 a9 1f 	call	0x3f52	; 0x3f52 <chb_eeprom_read>
}
    36ba:	08 95       	ret

000036bc <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    36bc:	cf 93       	push	r28
    36be:	df 93       	push	r29
    36c0:	0f 92       	push	r0
    36c2:	0f 92       	push	r0
    36c4:	cd b7       	in	r28, 0x3d	; 61
    36c6:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    36c8:	89 e0       	ldi	r24, 0x09	; 9
    36ca:	90 e0       	ldi	r25, 0x00	; 0
    36cc:	be 01       	movw	r22, r28
    36ce:	6f 5f       	subi	r22, 0xFF	; 255
    36d0:	7f 4f       	sbci	r23, 0xFF	; 255
    36d2:	42 e0       	ldi	r20, 0x02	; 2
    36d4:	50 e0       	ldi	r21, 0x00	; 0
    36d6:	0e 94 a9 1f 	call	0x3f52	; 0x3f52 <chb_eeprom_read>
    return *(U16 *)addr;
}
    36da:	89 81       	ldd	r24, Y+1	; 0x01
    36dc:	9a 81       	ldd	r25, Y+2	; 0x02
    36de:	0f 90       	pop	r0
    36e0:	0f 90       	pop	r0
    36e2:	df 91       	pop	r29
    36e4:	cf 91       	pop	r28
    36e6:	08 95       	ret

000036e8 <RadioCS>:
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
}

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    36e8:	88 23       	and	r24, r24
    36ea:	29 f0       	breq	.+10     	; 0x36f6 <RadioCS+0xe>
    36ec:	80 e1       	ldi	r24, 0x10	; 16
    36ee:	e0 e6       	ldi	r30, 0x60	; 96
    36f0:	f6 e0       	ldi	r31, 0x06	; 6
    36f2:	86 83       	std	Z+6, r24	; 0x06
    36f4:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    36f6:	80 e1       	ldi	r24, 0x10	; 16
    36f8:	e0 e6       	ldi	r30, 0x60	; 96
    36fa:	f6 e0       	ldi	r31, 0x06	; 6
    36fc:	85 83       	std	Z+5, r24	; 0x05
    36fe:	08 95       	ret

00003700 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    3700:	df 92       	push	r13
    3702:	ef 92       	push	r14
    3704:	ff 92       	push	r15
    3706:	0f 93       	push	r16
    3708:	1f 93       	push	r17
    370a:	cf 93       	push	r28
    370c:	df 93       	push	r29
    370e:	8c 01       	movw	r16, r24
    3710:	c6 2f       	mov	r28, r22
    3712:	7a 01       	movw	r14, r20
    3714:	d2 2e       	mov	r13, r18
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    3716:	82 2f       	mov	r24, r18
    3718:	90 e0       	ldi	r25, 0x00	; 0
    371a:	86 0f       	add	r24, r22
    371c:	91 1d       	adc	r25, r1
    371e:	80 38       	cpi	r24, 0x80	; 128
    3720:	91 05       	cpc	r25, r1
    3722:	8c f5       	brge	.+98     	; 0x3786 <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    3724:	8f b7       	in	r24, 0x3f	; 63
    3726:	80 93 57 40 	sts	0x4057, r24
    372a:	f8 94       	cli
    RadioCS(TRUE); 
    372c:	81 e0       	ldi	r24, 0x01	; 1
    372e:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    3732:	80 e6       	ldi	r24, 0x60	; 96
    3734:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    3738:	cc 23       	and	r28, r28
    373a:	79 f0       	breq	.+30     	; 0x375a <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    373c:	c8 01       	movw	r24, r16
    373e:	01 96       	adiw	r24, 0x01	; 1
    3740:	c1 50       	subi	r28, 0x01	; 1
    3742:	9c 01       	movw	r18, r24
    3744:	2c 0f       	add	r18, r28
    3746:	31 1d       	adc	r19, r1
    3748:	e9 01       	movw	r28, r18

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    374a:	f8 01       	movw	r30, r16
    374c:	81 91       	ld	r24, Z+
    374e:	8f 01       	movw	r16, r30
    3750:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    3754:	0c 17       	cp	r16, r28
    3756:	1d 07       	cpc	r17, r29
    3758:	c1 f7       	brne	.-16     	; 0x374a <chb_frame_write+0x4a>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    375a:	dd 20       	and	r13, r13
    375c:	69 f0       	breq	.+26     	; 0x3778 <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    375e:	e7 01       	movw	r28, r14
    3760:	21 96       	adiw	r28, 0x01	; 1
    3762:	da 94       	dec	r13
    3764:	cd 0d       	add	r28, r13
    3766:	d1 1d       	adc	r29, r1

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    3768:	f7 01       	movw	r30, r14
    376a:	81 91       	ld	r24, Z+
    376c:	7f 01       	movw	r14, r30
    376e:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    3772:	ec 16       	cp	r14, r28
    3774:	fd 06       	cpc	r15, r29
    3776:	c1 f7       	brne	.-16     	; 0x3768 <chb_frame_write+0x68>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    3778:	80 e0       	ldi	r24, 0x00	; 0
    377a:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <RadioCS>
    CHB_LEAVE_CRIT();
    377e:	80 91 57 40 	lds	r24, 0x4057
    3782:	8f bf       	out	0x3f, r24	; 63
    3784:	78 94       	sei
}
    3786:	df 91       	pop	r29
    3788:	cf 91       	pop	r28
    378a:	1f 91       	pop	r17
    378c:	0f 91       	pop	r16
    378e:	ff 90       	pop	r15
    3790:	ef 90       	pop	r14
    3792:	df 90       	pop	r13
    3794:	08 95       	ret

00003796 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    3796:	cf 93       	push	r28
    3798:	df 93       	push	r29
    379a:	d8 2f       	mov	r29, r24
    379c:	c6 2f       	mov	r28, r22
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
    379e:	8f b7       	in	r24, 0x3f	; 63
    37a0:	80 93 57 40 	sts	0x4057, r24
    37a4:	f8 94       	cli
    RadioCS(TRUE);
    37a6:	81 e0       	ldi	r24, 0x01	; 1
    37a8:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    37ac:	8d 2f       	mov	r24, r29
    37ae:	80 6c       	ori	r24, 0xC0	; 192
    37b0:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    37b4:	8c 2f       	mov	r24, r28
    37b6:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <SPID_write>

    RadioCS(FALSE);
    37ba:	80 e0       	ldi	r24, 0x00	; 0
    37bc:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <RadioCS>
    CHB_LEAVE_CRIT();
    37c0:	80 91 57 40 	lds	r24, 0x4057
    37c4:	8f bf       	out	0x3f, r24	; 63
    37c6:	78 94       	sei
}
    37c8:	df 91       	pop	r29
    37ca:	cf 91       	pop	r28
    37cc:	08 95       	ret

000037ce <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    37ce:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
    37d0:	85 e0       	ldi	r24, 0x05	; 5
    37d2:	0e 94 cb 1b 	call	0x3796	; 0x3796 <chb_reg_write>
}
    37d6:	08 95       	ret

000037d8 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    37d8:	0f 93       	push	r16
    37da:	1f 93       	push	r17
    37dc:	cf 93       	push	r28
    37de:	df 93       	push	r29
    37e0:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
    37e2:	c6 2f       	mov	r28, r22
    37e4:	d7 2f       	mov	r29, r23
    37e6:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
    37e8:	69 91       	ld	r22, Y+
    37ea:	81 2f       	mov	r24, r17
    37ec:	80 0f       	add	r24, r16
    37ee:	0e 94 cb 1b 	call	0x3796	; 0x3796 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    37f2:	1f 5f       	subi	r17, 0xFF	; 255
    37f4:	18 30       	cpi	r17, 0x08	; 8
    37f6:	c1 f7       	brne	.-16     	; 0x37e8 <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    37f8:	df 91       	pop	r29
    37fa:	cf 91       	pop	r28
    37fc:	1f 91       	pop	r17
    37fe:	0f 91       	pop	r16
    3800:	08 95       	ret

00003802 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    3802:	cf 93       	push	r28
    3804:	df 93       	push	r29
    3806:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    3808:	80 e0       	ldi	r24, 0x00	; 0
    380a:	90 e0       	ldi	r25, 0x00	; 0
    380c:	be 01       	movw	r22, r28
    380e:	48 e0       	ldi	r20, 0x08	; 8
    3810:	50 e0       	ldi	r21, 0x00	; 0
    3812:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    3816:	84 e2       	ldi	r24, 0x24	; 36
    3818:	be 01       	movw	r22, r28
    381a:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <chb_reg_write64>
}
    381e:	df 91       	pop	r29
    3820:	cf 91       	pop	r28
    3822:	08 95       	ret

00003824 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    3824:	cf 93       	push	r28
    3826:	df 93       	push	r29
    3828:	c8 2f       	mov	r28, r24
    382a:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
    382c:	0e 94 cb 1b 	call	0x3796	; 0x3796 <chb_reg_write>
    3830:	8c 2f       	mov	r24, r28
    3832:	8f 5f       	subi	r24, 0xFF	; 255
    3834:	6d 2f       	mov	r22, r29
    3836:	0e 94 cb 1b 	call	0x3796	; 0x3796 <chb_reg_write>
    }
}
    383a:	df 91       	pop	r29
    383c:	cf 91       	pop	r28
    383e:	08 95       	ret

00003840 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    3840:	0f 93       	push	r16
    3842:	1f 93       	push	r17
    3844:	cf 93       	push	r28
    3846:	df 93       	push	r29
    3848:	0f 92       	push	r0
    384a:	0f 92       	push	r0
    384c:	cd b7       	in	r28, 0x3d	; 61
    384e:	de b7       	in	r29, 0x3e	; 62
    3850:	89 83       	std	Y+1, r24	; 0x01
    3852:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
    3854:	0e 94 1e 1a 	call	0x343c	; 0x343c <chb_get_pcb>
    3858:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    385a:	89 e0       	ldi	r24, 0x09	; 9
    385c:	90 e0       	ldi	r25, 0x00	; 0
    385e:	be 01       	movw	r22, r28
    3860:	6f 5f       	subi	r22, 0xFF	; 255
    3862:	7f 4f       	sbci	r23, 0xFF	; 255
    3864:	42 e0       	ldi	r20, 0x02	; 2
    3866:	50 e0       	ldi	r21, 0x00	; 0
    3868:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    386c:	69 81       	ldd	r22, Y+1	; 0x01
    386e:	7a 81       	ldd	r23, Y+2	; 0x02
    3870:	80 e2       	ldi	r24, 0x20	; 32
    3872:	0e 94 12 1c 	call	0x3824	; 0x3824 <chb_reg_write16>
    pcb->src_addr = addr;
    3876:	89 81       	ldd	r24, Y+1	; 0x01
    3878:	9a 81       	ldd	r25, Y+2	; 0x02
    387a:	f8 01       	movw	r30, r16
    387c:	80 83       	st	Z, r24
    387e:	91 83       	std	Z+1, r25	; 0x01
}
    3880:	0f 90       	pop	r0
    3882:	0f 90       	pop	r0
    3884:	df 91       	pop	r29
    3886:	cf 91       	pop	r28
    3888:	1f 91       	pop	r17
    388a:	0f 91       	pop	r16
    388c:	08 95       	ret

0000388e <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    388e:	cf 93       	push	r28
    3890:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
    3892:	8f b7       	in	r24, 0x3f	; 63
    3894:	80 93 57 40 	sts	0x4057, r24
    3898:	f8 94       	cli
    RadioCS(TRUE);
    389a:	81 e0       	ldi	r24, 0x01	; 1
    389c:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    38a0:	8c 2f       	mov	r24, r28
    38a2:	80 68       	ori	r24, 0x80	; 128
    38a4:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <SPID_write>
    val = SPID_write(val);
    38a8:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <SPID_write>
    38ac:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    38ae:	80 e0       	ldi	r24, 0x00	; 0
    38b0:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <RadioCS>
    CHB_LEAVE_CRIT();
    38b4:	80 91 57 40 	lds	r24, 0x4057
    38b8:	8f bf       	out	0x3f, r24	; 63
    38ba:	78 94       	sei

    return val;
}
    38bc:	8c 2f       	mov	r24, r28
    38be:	cf 91       	pop	r28
    38c0:	08 95       	ret

000038c2 <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
    38c2:	81 e0       	ldi	r24, 0x01	; 1
    38c4:	0e 94 47 1c 	call	0x388e	; 0x388e <chb_reg_read>
}
    38c8:	8f 71       	andi	r24, 0x1F	; 31
    38ca:	08 95       	ret

000038cc <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    38cc:	1f 93       	push	r17
    38ce:	cf 93       	push	r28
    38d0:	df 93       	push	r29
    38d2:	c8 2f       	mov	r28, r24
    38d4:	16 2f       	mov	r17, r22
    38d6:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
    38d8:	0e 94 47 1c 	call	0x388e	; 0x388e <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
    38dc:	6d 2f       	mov	r22, r29
    38de:	60 95       	com	r22
    38e0:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
    38e2:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
    38e4:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
    38e6:	8c 2f       	mov	r24, r28
    38e8:	0e 94 cb 1b 	call	0x3796	; 0x3796 <chb_reg_write>
}
    38ec:	df 91       	pop	r29
    38ee:	cf 91       	pop	r28
    38f0:	1f 91       	pop	r17
    38f2:	08 95       	ret

000038f4 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    38f4:	cf 93       	push	r28
    38f6:	df 93       	push	r29
    38f8:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    38fa:	80 91 64 06 	lds	r24, 0x0664
    38fe:	81 fd       	sbrc	r24, 1
    3900:	4b c0       	rjmp	.+150    	; 0x3998 <chb_set_state+0xa4>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    3902:	0e 94 61 1c 	call	0x38c2	; 0x38c2 <chb_get_state>
    3906:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    3908:	81 51       	subi	r24, 0x11	; 17
    390a:	82 30       	cpi	r24, 0x02	; 2
    390c:	20 f0       	brcs	.+8      	; 0x3916 <chb_set_state+0x22>
    390e:	c1 30       	cpi	r28, 0x01	; 1
    3910:	11 f0       	breq	.+4      	; 0x3916 <chb_set_state+0x22>
    3912:	c2 30       	cpi	r28, 0x02	; 2
    3914:	21 f4       	brne	.+8      	; 0x391e <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
    3916:	0e 94 61 1c 	call	0x38c2	; 0x38c2 <chb_get_state>
    391a:	8c 17       	cp	r24, r28
    391c:	e1 f3       	breq	.-8      	; 0x3916 <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    391e:	d6 31       	cpi	r29, 0x16	; 22
    3920:	f9 f0       	breq	.+62     	; 0x3960 <chb_set_state+0x6c>
    3922:	d9 31       	cpi	r29, 0x19	; 25
    3924:	89 f0       	breq	.+34     	; 0x3948 <chb_set_state+0x54>
    3926:	d8 30       	cpi	r29, 0x08	; 8
    3928:	31 f5       	brne	.+76     	; 0x3976 <chb_set_state+0x82>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    392a:	e4 e6       	ldi	r30, 0x64	; 100
    392c:	f6 e0       	ldi	r31, 0x06	; 6
    392e:	80 81       	ld	r24, Z
    3930:	8d 7f       	andi	r24, 0xFD	; 253
    3932:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    3934:	82 e0       	ldi	r24, 0x02	; 2
    3936:	63 e0       	ldi	r22, 0x03	; 3
    3938:	4f e1       	ldi	r20, 0x1F	; 31
    393a:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>
    393e:	8a e0       	ldi	r24, 0x0A	; 10
    3940:	8a 95       	dec	r24
    3942:	f1 f7       	brne	.-4      	; 0x3940 <chb_set_state+0x4c>
    3944:	00 c0       	rjmp	.+0      	; 0x3946 <chb_set_state+0x52>
    3946:	17 c0       	rjmp	.+46     	; 0x3976 <chb_set_state+0x82>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    3948:	c6 31       	cpi	r28, 0x16	; 22
    394a:	a9 f4       	brne	.+42     	; 0x3976 <chb_set_state+0x82>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    394c:	82 e0       	ldi	r24, 0x02	; 2
    394e:	69 e0       	ldi	r22, 0x09	; 9
    3950:	4f e1       	ldi	r20, 0x1F	; 31
    3952:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>
    3956:	9a e0       	ldi	r25, 0x0A	; 10
    3958:	9a 95       	dec	r25
    395a:	f1 f7       	brne	.-4      	; 0x3958 <chb_set_state+0x64>
    395c:	00 c0       	rjmp	.+0      	; 0x395e <chb_set_state+0x6a>
    395e:	0b c0       	rjmp	.+22     	; 0x3976 <chb_set_state+0x82>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    3960:	c9 31       	cpi	r28, 0x19	; 25
    3962:	49 f4       	brne	.+18     	; 0x3976 <chb_set_state+0x82>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    3964:	82 e0       	ldi	r24, 0x02	; 2
    3966:	69 e0       	ldi	r22, 0x09	; 9
    3968:	4f e1       	ldi	r20, 0x1F	; 31
    396a:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>
    396e:	8a e0       	ldi	r24, 0x0A	; 10
    3970:	8a 95       	dec	r24
    3972:	f1 f7       	brne	.-4      	; 0x3970 <chb_set_state+0x7c>
    3974:	00 c0       	rjmp	.+0      	; 0x3976 <chb_set_state+0x82>
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    3976:	82 e0       	ldi	r24, 0x02	; 2
    3978:	6d 2f       	mov	r22, r29
    397a:	4f e1       	ldi	r20, 0x1F	; 31
    397c:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>
    3980:	8f e6       	ldi	r24, 0x6F	; 111
    3982:	93 e0       	ldi	r25, 0x03	; 3
    3984:	01 97       	sbiw	r24, 0x01	; 1
    3986:	f1 f7       	brne	.-4      	; 0x3984 <chb_set_state+0x90>
    3988:	00 c0       	rjmp	.+0      	; 0x398a <chb_set_state+0x96>
    398a:	00 00       	nop

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    398c:	0e 94 61 1c 	call	0x38c2	; 0x38c2 <chb_get_state>
    3990:	8d 17       	cp	r24, r29
    3992:	21 f4       	brne	.+8      	; 0x399c <chb_set_state+0xa8>
    {
        return RADIO_SUCCESS;
    3994:	80 e4       	ldi	r24, 0x40	; 64
    3996:	03 c0       	rjmp	.+6      	; 0x399e <chb_set_state+0xaa>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
    3998:	84 e4       	ldi	r24, 0x44	; 68
    399a:	01 c0       	rjmp	.+2      	; 0x399e <chb_set_state+0xaa>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
    399c:	83 e4       	ldi	r24, 0x43	; 67
}
    399e:	df 91       	pop	r29
    39a0:	cf 91       	pop	r28
    39a2:	08 95       	ret

000039a4 <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
    39a4:	88 23       	and	r24, r24
    39a6:	49 f0       	breq	.+18     	; 0x39ba <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    39a8:	88 e0       	ldi	r24, 0x08	; 8
    39aa:	0e 94 7a 1c 	call	0x38f4	; 0x38f4 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    39ae:	e4 e6       	ldi	r30, 0x64	; 100
    39b0:	f6 e0       	ldi	r31, 0x06	; 6
    39b2:	80 81       	ld	r24, Z
    39b4:	82 60       	ori	r24, 0x02	; 2
    39b6:	80 83       	st	Z, r24
    39b8:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    39ba:	e4 e6       	ldi	r30, 0x64	; 100
    39bc:	f6 e0       	ldi	r31, 0x06	; 6
    39be:	80 81       	ld	r24, Z
    39c0:	8d 7f       	andi	r24, 0xFD	; 253
    39c2:	80 83       	st	Z, r24
    39c4:	8f e7       	ldi	r24, 0x7F	; 127
    39c6:	97 e0       	ldi	r25, 0x07	; 7
    39c8:	01 97       	sbiw	r24, 0x01	; 1
    39ca:	f1 f7       	brne	.-4      	; 0x39c8 <chb_sleep+0x24>
    39cc:	00 c0       	rjmp	.+0      	; 0x39ce <chb_sleep+0x2a>
    39ce:	00 00       	nop

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    39d0:	86 e1       	ldi	r24, 0x16	; 22
    39d2:	0e 94 7a 1c 	call	0x38f4	; 0x38f4 <chb_set_state>
    39d6:	08 95       	ret

000039d8 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    39d8:	cf 92       	push	r12
    39da:	df 92       	push	r13
    39dc:	ef 92       	push	r14
    39de:	ff 92       	push	r15
    39e0:	0f 93       	push	r16
    39e2:	1f 93       	push	r17
    39e4:	cf 93       	push	r28
    39e6:	df 93       	push	r29
    39e8:	7c 01       	movw	r14, r24
    39ea:	6b 01       	movw	r12, r22
    39ec:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
    39ee:	0e 94 61 1c 	call	0x38c2	; 0x38c2 <chb_get_state>
    39f2:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
    39f4:	0e 94 1e 1a 	call	0x343c	; 0x343c <chb_get_pcb>
    39f8:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    39fa:	12 30       	cpi	r17, 0x02	; 2
    39fc:	f1 f0       	breq	.+60     	; 0x3a3a <chb_tx+0x62>
    39fe:	12 31       	cpi	r17, 0x12	; 18
    3a00:	f1 f0       	breq	.+60     	; 0x3a3e <chb_tx+0x66>
    {
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    3a02:	88 e0       	ldi	r24, 0x08	; 8
    3a04:	0e 94 7a 1c 	call	0x38f4	; 0x38f4 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    3a08:	89 e1       	ldi	r24, 0x19	; 25
    3a0a:	0e 94 7a 1c 	call	0x38f4	; 0x38f4 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    3a0e:	c7 01       	movw	r24, r14
    3a10:	6a e0       	ldi	r22, 0x0A	; 10
    3a12:	a6 01       	movw	r20, r12
    3a14:	20 2f       	mov	r18, r16
    3a16:	0e 94 80 1b 	call	0x3700	; 0x3700 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    3a1a:	82 e0       	ldi	r24, 0x02	; 2
    3a1c:	62 e0       	ldi	r22, 0x02	; 2
    3a1e:	4f e1       	ldi	r20, 0x1F	; 31
    3a20:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    3a24:	8c 81       	ldd	r24, Y+4	; 0x04
    3a26:	88 23       	and	r24, r24
    3a28:	e9 f3       	breq	.-6      	; 0x3a24 <chb_tx+0x4c>
    pcb->tx_end = false;
    3a2a:	1c 82       	std	Y+4, r1	; 0x04

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    3a2c:	82 e0       	ldi	r24, 0x02	; 2
    3a2e:	0e 94 47 1c 	call	0x388e	; 0x388e <chb_reg_read>
    3a32:	82 95       	swap	r24
    3a34:	86 95       	lsr	r24
    3a36:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
    3a38:	03 c0       	rjmp	.+6      	; 0x3a40 <chb_tx+0x68>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
    3a3a:	84 e4       	ldi	r24, 0x44	; 68
    3a3c:	01 c0       	rjmp	.+2      	; 0x3a40 <chb_tx+0x68>
    3a3e:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
    3a40:	df 91       	pop	r29
    3a42:	cf 91       	pop	r28
    3a44:	1f 91       	pop	r17
    3a46:	0f 91       	pop	r16
    3a48:	ff 90       	pop	r15
    3a4a:	ef 90       	pop	r14
    3a4c:	df 90       	pop	r13
    3a4e:	cf 90       	pop	r12
    3a50:	08 95       	ret

00003a52 <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
    3a52:	81 30       	cpi	r24, 0x01	; 1
    3a54:	91 f0       	breq	.+36     	; 0x3a7a <chb_set_mode+0x28>
    3a56:	81 30       	cpi	r24, 0x01	; 1
    3a58:	28 f0       	brcs	.+10     	; 0x3a64 <chb_set_mode+0x12>
    3a5a:	82 30       	cpi	r24, 0x02	; 2
    3a5c:	c9 f0       	breq	.+50     	; 0x3a90 <chb_set_mode+0x3e>
    3a5e:	83 30       	cpi	r24, 0x03	; 3
    3a60:	61 f5       	brne	.+88     	; 0x3aba <chb_set_mode+0x68>
    3a62:	21 c0       	rjmp	.+66     	; 0x3aa6 <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    3a64:	8c e0       	ldi	r24, 0x0C	; 12
    3a66:	68 e0       	ldi	r22, 0x08	; 8
    3a68:	4f e3       	ldi	r20, 0x3F	; 63
    3a6a:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    3a6e:	86 e1       	ldi	r24, 0x16	; 22
    3a70:	62 e0       	ldi	r22, 0x02	; 2
    3a72:	43 e0       	ldi	r20, 0x03	; 3
    3a74:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>
        break;
    3a78:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    3a7a:	8c e0       	ldi	r24, 0x0C	; 12
    3a7c:	6c e0       	ldi	r22, 0x0C	; 12
    3a7e:	4f e3       	ldi	r20, 0x3F	; 63
    3a80:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    3a84:	86 e1       	ldi	r24, 0x16	; 22
    3a86:	62 e0       	ldi	r22, 0x02	; 2
    3a88:	43 e0       	ldi	r20, 0x03	; 3
    3a8a:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>
        break;
    3a8e:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    3a90:	8c e0       	ldi	r24, 0x0C	; 12
    3a92:	6c e1       	ldi	r22, 0x1C	; 28
    3a94:	4f e3       	ldi	r20, 0x3F	; 63
    3a96:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    3a9a:	86 e1       	ldi	r24, 0x16	; 22
    3a9c:	62 e0       	ldi	r22, 0x02	; 2
    3a9e:	43 e0       	ldi	r20, 0x03	; 3
    3aa0:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>
        break;
    3aa4:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    3aa6:	8c e0       	ldi	r24, 0x0C	; 12
    3aa8:	60 e0       	ldi	r22, 0x00	; 0
    3aaa:	4f e3       	ldi	r20, 0x3F	; 63
    3aac:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    3ab0:	86 e1       	ldi	r24, 0x16	; 22
    3ab2:	63 e0       	ldi	r22, 0x03	; 3
    3ab4:	43 e0       	ldi	r20, 0x03	; 3
    3ab6:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>
    3aba:	08 95       	ret

00003abc <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    3abc:	cf 93       	push	r28
    3abe:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    3ac0:	88 e0       	ldi	r24, 0x08	; 8
    3ac2:	6c 2f       	mov	r22, r28
    3ac4:	4f e1       	ldi	r20, 0x1F	; 31
    3ac6:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    3aca:	0e 94 61 1c 	call	0x38c2	; 0x38c2 <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    3ace:	86 30       	cpi	r24, 0x06	; 6
    3ad0:	11 f0       	breq	.+4      	; 0x3ad6 <chb_set_channel+0x1a>
    3ad2:	89 30       	cpi	r24, 0x09	; 9
    3ad4:	31 f4       	brne	.+12     	; 0x3ae2 <chb_set_channel+0x26>
    3ad6:	8f e6       	ldi	r24, 0x6F	; 111
    3ad8:	93 e0       	ldi	r25, 0x03	; 3
    3ada:	01 97       	sbiw	r24, 0x01	; 1
    3adc:	f1 f7       	brne	.-4      	; 0x3ada <chb_set_channel+0x1e>
    3ade:	00 c0       	rjmp	.+0      	; 0x3ae0 <chb_set_channel+0x24>
    3ae0:	00 00       	nop
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    3ae2:	88 e0       	ldi	r24, 0x08	; 8
    3ae4:	0e 94 47 1c 	call	0x388e	; 0x388e <chb_reg_read>
    3ae8:	90 e0       	ldi	r25, 0x00	; 0
    3aea:	8f 71       	andi	r24, 0x1F	; 31
    3aec:	90 70       	andi	r25, 0x00	; 0
    3aee:	6c 2f       	mov	r22, r28
    3af0:	70 e0       	ldi	r23, 0x00	; 0
    3af2:	86 17       	cp	r24, r22
    3af4:	97 07       	cpc	r25, r23
    3af6:	11 f4       	brne	.+4      	; 0x3afc <chb_set_channel+0x40>
    3af8:	80 e4       	ldi	r24, 0x40	; 64
    3afa:	01 c0       	rjmp	.+2      	; 0x3afe <chb_set_channel+0x42>
    3afc:	83 e4       	ldi	r24, 0x43	; 67
}
    3afe:	cf 91       	pop	r28
    3b00:	08 95       	ret

00003b02 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    3b02:	cf 93       	push	r28
    3b04:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    3b06:	0e 94 47 1c 	call	0x388e	; 0x388e <chb_reg_read>
    3b0a:	8c 2b       	or	r24, r28
    3b0c:	8f 5f       	subi	r24, 0xFF	; 255
    3b0e:	0e 94 47 1c 	call	0x388e	; 0x388e <chb_reg_read>
    }
    return val;
}
    3b12:	80 e0       	ldi	r24, 0x00	; 0
    3b14:	90 e0       	ldi	r25, 0x00	; 0
    3b16:	cf 91       	pop	r28
    3b18:	08 95       	ret

00003b1a <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
    3b1a:	e4 e6       	ldi	r30, 0x64	; 100
    3b1c:	f6 e0       	ldi	r31, 0x06	; 6
    3b1e:	80 81       	ld	r24, Z
    3b20:	81 60       	ori	r24, 0x01	; 1
    3b22:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
    3b24:	80 81       	ld	r24, Z
    3b26:	8d 7f       	andi	r24, 0xFD	; 253
    3b28:	80 83       	st	Z, r24
    3b2a:	8f ed       	ldi	r24, 0xDF	; 223
    3b2c:	9b e0       	ldi	r25, 0x0B	; 11
    3b2e:	01 97       	sbiw	r24, 0x01	; 1
    3b30:	f1 f7       	brne	.-4      	; 0x3b2e <chb_reset+0x14>
    3b32:	00 c0       	rjmp	.+0      	; 0x3b34 <chb_reset+0x1a>
    3b34:	00 00       	nop

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    3b36:	80 81       	ld	r24, Z
    3b38:	8e 7f       	andi	r24, 0xFE	; 254
    3b3a:	80 83       	st	Z, r24
    3b3c:	9a e0       	ldi	r25, 0x0A	; 10
    3b3e:	9a 95       	dec	r25
    3b40:	f1 f7       	brne	.-4      	; 0x3b3e <chb_reset+0x24>
    3b42:	00 c0       	rjmp	.+0      	; 0x3b44 <chb_reset+0x2a>
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    3b44:	80 81       	ld	r24, Z
    3b46:	81 60       	ori	r24, 0x01	; 1
    3b48:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    3b4a:	8d e1       	ldi	r24, 0x1D	; 29
    3b4c:	0e 94 47 1c 	call	0x388e	; 0x388e <chb_reg_read>
    3b50:	81 30       	cpi	r24, 0x01	; 1
    3b52:	d9 f7       	brne	.-10     	; 0x3b4a <chb_reset+0x30>
    3b54:	8c e1       	ldi	r24, 0x1C	; 28
    3b56:	0e 94 47 1c 	call	0x388e	; 0x388e <chb_reg_read>
    3b5a:	87 30       	cpi	r24, 0x07	; 7
    3b5c:	b1 f7       	brne	.-20     	; 0x3b4a <chb_reset+0x30>
            break;
        }
    }
	

}
    3b5e:	08 95       	ret

00003b60 <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    3b60:	0f 93       	push	r16
    3b62:	1f 93       	push	r17
    3b64:	cf 93       	push	r28
    3b66:	df 93       	push	r29
    3b68:	cd b7       	in	r28, 0x3d	; 61
    3b6a:	de b7       	in	r29, 0x3e	; 62
    3b6c:	ea 97       	sbiw	r28, 0x3a	; 58
    3b6e:	cd bf       	out	0x3d, r28	; 61
    3b70:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    3b72:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    3b76:	e0 e6       	ldi	r30, 0x60	; 96
    3b78:	f6 e0       	ldi	r31, 0x06	; 6
    3b7a:	80 81       	ld	r24, Z
    3b7c:	82 60       	ori	r24, 0x02	; 2
    3b7e:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    3b80:	80 81       	ld	r24, Z
    3b82:	81 60       	ori	r24, 0x01	; 1
    3b84:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    3b86:	0e 94 8d 1d 	call	0x3b1a	; 0x3b1a <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    3b8a:	8e e0       	ldi	r24, 0x0E	; 14
    3b8c:	60 e0       	ldi	r22, 0x00	; 0
    3b8e:	0e 94 cb 1b 	call	0x3796	; 0x3796 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    3b92:	82 e0       	ldi	r24, 0x02	; 2
    3b94:	63 e0       	ldi	r22, 0x03	; 3
    3b96:	4f e1       	ldi	r20, 0x1F	; 31
    3b98:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    3b9c:	81 e0       	ldi	r24, 0x01	; 1
    3b9e:	0e 94 47 1c 	call	0x388e	; 0x388e <chb_reg_read>
    3ba2:	8f 71       	andi	r24, 0x1F	; 31
    3ba4:	88 30       	cpi	r24, 0x08	; 8
    3ba6:	d1 f7       	brne	.-12     	; 0x3b9c <chb_drvr_init+0x3c>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    3ba8:	8e e2       	ldi	r24, 0x2E	; 46
    3baa:	60 e4       	ldi	r22, 0x40	; 64
    3bac:	40 ec       	ldi	r20, 0xC0	; 192
    3bae:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    3bb2:	8e e0       	ldi	r24, 0x0E	; 14
    3bb4:	6c e0       	ldi	r22, 0x0C	; 12
    3bb6:	0e 94 cb 1b 	call	0x3796	; 0x3796 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    3bba:	84 e0       	ldi	r24, 0x04	; 4
    3bbc:	60 e2       	ldi	r22, 0x20	; 32
    3bbe:	40 e2       	ldi	r20, 0x20	; 32
    3bc0:	0e 94 66 1c 	call	0x38cc	; 0x38cc <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    3bc4:	81 e0       	ldi	r24, 0x01	; 1
    3bc6:	0e 94 29 1d 	call	0x3a52	; 0x3a52 <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    3bca:	81 e0       	ldi	r24, 0x01	; 1
    3bcc:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    3bd0:	86 e1       	ldi	r24, 0x16	; 22
    3bd2:	0e 94 7a 1c 	call	0x38f4	; 0x38f4 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    3bd6:	82 e2       	ldi	r24, 0x22	; 34
    3bd8:	64 e3       	ldi	r22, 0x34	; 52
    3bda:	72 e1       	ldi	r23, 0x12	; 18
    3bdc:	0e 94 12 1c 	call	0x3824	; 0x3824 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    3be0:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <chb_get_short_addr>
    3be4:	bc 01       	movw	r22, r24
    3be6:	80 e2       	ldi	r24, 0x20	; 32
    3be8:	0e 94 12 1c 	call	0x3824	; 0x3824 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    3bec:	ce 01       	movw	r24, r28
    3bee:	01 96       	adiw	r24, 0x01	; 1
    3bf0:	0e 94 56 1b 	call	0x36ac	; 0x36ac <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    3bf4:	84 e2       	ldi	r24, 0x24	; 36
    3bf6:	be 01       	movw	r22, r28
    3bf8:	6f 5f       	subi	r22, 0xFF	; 255
    3bfa:	7f 4f       	sbci	r23, 0xFF	; 255
    3bfc:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    3c00:	e2 e7       	ldi	r30, 0x72	; 114
    3c02:	f6 e0       	ldi	r31, 0x06	; 6
    3c04:	80 81       	ld	r24, Z
    3c06:	81 60       	ori	r24, 0x01	; 1
    3c08:	80 83       	st	Z, r24
    3c0a:	e9 e6       	ldi	r30, 0x69	; 105
    3c0c:	f6 e0       	ldi	r31, 0x06	; 6
    3c0e:	80 81       	ld	r24, Z
    3c10:	83 60       	ori	r24, 0x03	; 3
    3c12:	80 83       	st	Z, r24
    3c14:	ea e6       	ldi	r30, 0x6A	; 106
    3c16:	f6 e0       	ldi	r31, 0x06	; 6
    3c18:	80 81       	ld	r24, Z
    3c1a:	84 60       	ori	r24, 0x04	; 4
    3c1c:	80 83       	st	Z, r24
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    3c1e:	e0 ea       	ldi	r30, 0xA0	; 160
    3c20:	f0 e0       	ldi	r31, 0x00	; 0
    3c22:	82 81       	ldd	r24, Z+2	; 0x02
    3c24:	87 60       	ori	r24, 0x07	; 7
    3c26:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
    3c28:	0e 94 61 1c 	call	0x38c2	; 0x38c2 <chb_get_state>
    3c2c:	86 31       	cpi	r24, 0x16	; 22
    3c2e:	91 f0       	breq	.+36     	; 0x3c54 <chb_drvr_init+0xf4>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    3c30:	8e 01       	movw	r16, r28
    3c32:	07 5f       	subi	r16, 0xF7	; 247
    3c34:	1f 4f       	sbci	r17, 0xFF	; 255
    3c36:	c8 01       	movw	r24, r16
    3c38:	68 ee       	ldi	r22, 0xE8	; 232
    3c3a:	71 e0       	ldi	r23, 0x01	; 1
    3c3c:	0e 94 d9 39 	call	0x73b2	; 0x73b2 <strcpy_P>
        printf(buf);
    3c40:	0f 92       	push	r0
    3c42:	0f 92       	push	r0
    3c44:	ed b7       	in	r30, 0x3d	; 61
    3c46:	fe b7       	in	r31, 0x3e	; 62
    3c48:	01 83       	std	Z+1, r16	; 0x01
    3c4a:	12 83       	std	Z+2, r17	; 0x02
    3c4c:	0e 94 1e 3a 	call	0x743c	; 0x743c <printf>
    3c50:	0f 90       	pop	r0
    3c52:	0f 90       	pop	r0
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
    3c54:	ea 96       	adiw	r28, 0x3a	; 58
    3c56:	cd bf       	out	0x3d, r28	; 61
    3c58:	de bf       	out	0x3e, r29	; 62
    3c5a:	df 91       	pop	r29
    3c5c:	cf 91       	pop	r28
    3c5e:	1f 91       	pop	r17
    3c60:	0f 91       	pop	r16
    3c62:	08 95       	ret

00003c64 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    3c64:	1f 92       	push	r1
    3c66:	0f 92       	push	r0
    3c68:	0f b6       	in	r0, 0x3f	; 63
    3c6a:	0f 92       	push	r0
    3c6c:	0b b6       	in	r0, 0x3b	; 59
    3c6e:	0f 92       	push	r0
    3c70:	11 24       	eor	r1, r1
    3c72:	6f 92       	push	r6
    3c74:	7f 92       	push	r7
    3c76:	8f 92       	push	r8
    3c78:	9f 92       	push	r9
    3c7a:	af 92       	push	r10
    3c7c:	bf 92       	push	r11
    3c7e:	df 92       	push	r13
    3c80:	ef 92       	push	r14
    3c82:	ff 92       	push	r15
    3c84:	0f 93       	push	r16
    3c86:	1f 93       	push	r17
    3c88:	2f 93       	push	r18
    3c8a:	3f 93       	push	r19
    3c8c:	4f 93       	push	r20
    3c8e:	5f 93       	push	r21
    3c90:	6f 93       	push	r22
    3c92:	7f 93       	push	r23
    3c94:	8f 93       	push	r24
    3c96:	9f 93       	push	r25
    3c98:	af 93       	push	r26
    3c9a:	bf 93       	push	r27
    3c9c:	ef 93       	push	r30
    3c9e:	ff 93       	push	r31
    3ca0:	cf 93       	push	r28
    3ca2:	df 93       	push	r29
    3ca4:	cd b7       	in	r28, 0x3d	; 61
    3ca6:	de b7       	in	r29, 0x3e	; 62
    3ca8:	e2 97       	sbiw	r28, 0x32	; 50
    3caa:	cd bf       	out	0x3d, r28	; 61
    3cac:	de bf       	out	0x3e, r29	; 62
    U8 state, intp_src = 0;
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    3cae:	0e 94 1e 1a 	call	0x343c	; 0x343c <chb_get_pcb>
    3cb2:	7c 01       	movw	r14, r24

    CHB_ENTER_CRIT();
    3cb4:	8f b7       	in	r24, 0x3f	; 63
    3cb6:	80 93 57 40 	sts	0x4057, r24
    3cba:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    3cbc:	81 e0       	ldi	r24, 0x01	; 1
    3cbe:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    3cc2:	8f e8       	ldi	r24, 0x8F	; 143
    3cc4:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <SPID_write>
    intp_src = SPID_write(0);
    3cc8:	80 e0       	ldi	r24, 0x00	; 0
    3cca:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <SPID_write>
    3cce:	18 2f       	mov	r17, r24

    RadioCS(FALSE);
    3cd0:	80 e0       	ldi	r24, 0x00	; 0
    3cd2:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <RadioCS>

    while (intp_src)
    3cd6:	11 23       	and	r17, r17
    3cd8:	09 f4       	brne	.+2      	; 0x3cdc <__vector_64+0x78>
    3cda:	ae c0       	rjmp	.+348    	; 0x3e38 <__vector_64+0x1d4>

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3cdc:	aa 24       	eor	r10, r10
    3cde:	bb 24       	eor	r11, r11
    3ce0:	68 94       	set
    3ce2:	a7 f8       	bld	r10, 7

            // Increment the overflow stat
            pcb->overflow++;

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    3ce4:	0f 2e       	mov	r0, r31
    3ce6:	f8 e0       	ldi	r31, 0x08	; 8
    3ce8:	8f 2e       	mov	r8, r31
    3cea:	f2 e0       	ldi	r31, 0x02	; 2
    3cec:	9f 2e       	mov	r9, r31
    3cee:	f0 2d       	mov	r31, r0
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    3cf0:	12 ff       	sbrs	r17, 2
    3cf2:	02 c0       	rjmp	.+4      	; 0x3cf8 <__vector_64+0x94>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    3cf4:	1b 7f       	andi	r17, 0xFB	; 251
    3cf6:	9d c0       	rjmp	.+314    	; 0x3e32 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    3cf8:	13 ff       	sbrs	r17, 3
    3cfa:	82 c0       	rjmp	.+260    	; 0x3e00 <__vector_64+0x19c>
        {
            state = chb_get_state();
    3cfc:	0e 94 61 1c 	call	0x38c2	; 0x38c2 <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    3d00:	86 30       	cpi	r24, 0x06	; 6
    3d02:	29 f0       	breq	.+10     	; 0x3d0e <__vector_64+0xaa>
    3d04:	86 31       	cpi	r24, 0x16	; 22
    3d06:	19 f0       	breq	.+6      	; 0x3d0e <__vector_64+0xaa>
    3d08:	81 31       	cpi	r24, 0x11	; 17
    3d0a:	09 f0       	breq	.+2      	; 0x3d0e <__vector_64+0xaa>
    3d0c:	6f c0       	rjmp	.+222    	; 0x3dec <__vector_64+0x188>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				//chb_set_state(CHB_TRX_OFF);
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    3d0e:	87 e0       	ldi	r24, 0x07	; 7
    3d10:	0e 94 47 1c 	call	0x388e	; 0x388e <chb_reg_read>
    3d14:	f7 01       	movw	r30, r14
    3d16:	82 8b       	std	Z+18, r24	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    3d18:	86 e0       	ldi	r24, 0x06	; 6
    3d1a:	0e 94 47 1c 	call	0x388e	; 0x388e <chb_reg_read>
    3d1e:	88 1f       	adc	r24, r24
    3d20:	88 27       	eor	r24, r24
    3d22:	88 1f       	adc	r24, r24
    3d24:	f7 01       	movw	r30, r14
    3d26:	83 8b       	std	Z+19, r24	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    3d28:	88 23       	and	r24, r24
    3d2a:	09 f4       	brne	.+2      	; 0x3d2e <__vector_64+0xca>
    3d2c:	62 c0       	rjmp	.+196    	; 0x3df2 <__vector_64+0x18e>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
    3d2e:	8f b7       	in	r24, 0x3f	; 63
    3d30:	80 93 57 40 	sts	0x4057, r24
    3d34:	f8 94       	cli
    RadioCS(TRUE);
    3d36:	81 e0       	ldi	r24, 0x01	; 1
    3d38:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    3d3c:	80 e2       	ldi	r24, 0x20	; 32
    3d3e:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <SPID_write>
    len = SPID_write(0);
    3d42:	80 e0       	ldi	r24, 0x00	; 0
    3d44:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <SPID_write>
    3d48:	d8 2e       	mov	r13, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    3d4a:	83 50       	subi	r24, 0x03	; 3
    3d4c:	8d 37       	cpi	r24, 0x7D	; 125
    3d4e:	f0 f5       	brcc	.+124    	; 0x3dcc <__vector_64+0x168>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3d50:	0e 94 53 1b 	call	0x36a6	; 0x36a6 <chb_buf_get_len>
    3d54:	2d 2d       	mov	r18, r13
    3d56:	30 e0       	ldi	r19, 0x00	; 0
    3d58:	a5 01       	movw	r20, r10
    3d5a:	48 1b       	sub	r20, r24
    3d5c:	51 09       	sbc	r21, r1
    3d5e:	24 17       	cp	r18, r20
    3d60:	35 07       	cpc	r19, r21
    3d62:	7c f4       	brge	.+30     	; 0x3d82 <__vector_64+0x11e>
        {
            chb_buf_write(len);
    3d64:	8d 2d       	mov	r24, r13
    3d66:	0e 94 27 1b 	call	0x364e	; 0x364e <chb_buf_write>
            
            for (i=0; i<len; i++)
    3d6a:	dd 20       	and	r13, r13
    3d6c:	79 f1       	breq	.+94     	; 0x3dcc <__vector_64+0x168>
    3d6e:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    3d70:	80 e0       	ldi	r24, 0x00	; 0
    3d72:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <SPID_write>
                chb_buf_write(data);
    3d76:	0e 94 27 1b 	call	0x364e	; 0x364e <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    3d7a:	0f 5f       	subi	r16, 0xFF	; 255
    3d7c:	0d 15       	cp	r16, r13
    3d7e:	c1 f7       	brne	.-16     	; 0x3d70 <__vector_64+0x10c>
    3d80:	25 c0       	rjmp	.+74     	; 0x3dcc <__vector_64+0x168>
			//PORTE.OUTCLR = PIN2_bm;
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    3d82:	0e 94 1e 1a 	call	0x343c	; 0x343c <chb_get_pcb>
    3d86:	3c 01       	movw	r6, r24
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3d88:	dd 20       	and	r13, r13
    3d8a:	39 f0       	breq	.+14     	; 0x3d9a <__vector_64+0x136>
    3d8c:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    3d8e:	80 e0       	ldi	r24, 0x00	; 0
    3d90:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3d94:	0f 5f       	subi	r16, 0xFF	; 255
    3d96:	0d 15       	cp	r16, r13
    3d98:	d1 f7       	brne	.-12     	; 0x3d8e <__vector_64+0x12a>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    3d9a:	f3 01       	movw	r30, r6
    3d9c:	85 85       	ldd	r24, Z+13	; 0x0d
    3d9e:	96 85       	ldd	r25, Z+14	; 0x0e
    3da0:	01 96       	adiw	r24, 0x01	; 1
    3da2:	85 87       	std	Z+13, r24	; 0x0d
    3da4:	96 87       	std	Z+14, r25	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    3da6:	ce 01       	movw	r24, r28
    3da8:	01 96       	adiw	r24, 0x01	; 1
    3daa:	b4 01       	movw	r22, r8
    3dac:	0e 94 d9 39 	call	0x73b2	; 0x73b2 <strcpy_P>
            printf(buf);
    3db0:	0f 92       	push	r0
    3db2:	0f 92       	push	r0
    3db4:	41 e0       	ldi	r20, 0x01	; 1
    3db6:	50 e0       	ldi	r21, 0x00	; 0
    3db8:	4c 0f       	add	r20, r28
    3dba:	5d 1f       	adc	r21, r29
    3dbc:	ed b7       	in	r30, 0x3d	; 61
    3dbe:	fe b7       	in	r31, 0x3e	; 62
    3dc0:	41 83       	std	Z+1, r20	; 0x01
    3dc2:	52 83       	std	Z+2, r21	; 0x02
    3dc4:	0e 94 1e 3a 	call	0x743c	; 0x743c <printf>
    3dc8:	0f 90       	pop	r0
    3dca:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    3dcc:	80 e0       	ldi	r24, 0x00	; 0
    3dce:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <RadioCS>
    CHB_LEAVE_CRIT();
    3dd2:	80 91 57 40 	lds	r24, 0x4057
    3dd6:	8f bf       	out	0x3f, r24	; 63
    3dd8:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
    3dda:	f7 01       	movw	r30, r14
    3ddc:	85 81       	ldd	r24, Z+5	; 0x05
    3dde:	96 81       	ldd	r25, Z+6	; 0x06
    3de0:	01 96       	adiw	r24, 0x01	; 1
    3de2:	85 83       	std	Z+5, r24	; 0x05
    3de4:	96 83       	std	Z+6, r25	; 0x06
                    pcb->data_rcv = true;
    3de6:	81 e0       	ldi	r24, 0x01	; 1
    3de8:	83 83       	std	Z+3, r24	; 0x03
    3dea:	03 c0       	rjmp	.+6      	; 0x3df2 <__vector_64+0x18e>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    3dec:	81 e0       	ldi	r24, 0x01	; 1
    3dee:	f7 01       	movw	r30, r14
    3df0:	84 83       	std	Z+4, r24	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    3df2:	17 7f       	andi	r17, 0xF7	; 247
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    3df4:	86 e1       	ldi	r24, 0x16	; 22
    3df6:	0e 94 7a 1c 	call	0x38f4	; 0x38f4 <chb_set_state>
    3dfa:	80 34       	cpi	r24, 0x40	; 64
    3dfc:	d9 f7       	brne	.-10     	; 0x3df4 <__vector_64+0x190>
    3dfe:	19 c0       	rjmp	.+50     	; 0x3e32 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    3e00:	16 ff       	sbrs	r17, 6
    3e02:	08 c0       	rjmp	.+16     	; 0x3e14 <__vector_64+0x1b0>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    3e04:	1f 7b       	andi	r17, 0xBF	; 191
            pcb->underrun++;
    3e06:	f7 01       	movw	r30, r14
    3e08:	87 85       	ldd	r24, Z+15	; 0x0f
    3e0a:	90 89       	ldd	r25, Z+16	; 0x10
    3e0c:	01 96       	adiw	r24, 0x01	; 1
    3e0e:	87 87       	std	Z+15, r24	; 0x0f
    3e10:	90 8b       	std	Z+16, r25	; 0x10
    3e12:	0f c0       	rjmp	.+30     	; 0x3e32 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    3e14:	11 ff       	sbrs	r17, 1
    3e16:	02 c0       	rjmp	.+4      	; 0x3e1c <__vector_64+0x1b8>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    3e18:	1d 7f       	andi	r17, 0xFD	; 253
    3e1a:	0b c0       	rjmp	.+22     	; 0x3e32 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    3e1c:	10 ff       	sbrs	r17, 0
    3e1e:	02 c0       	rjmp	.+4      	; 0x3e24 <__vector_64+0x1c0>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    3e20:	1e 7f       	andi	r17, 0xFE	; 254
    3e22:	07 c0       	rjmp	.+14     	; 0x3e32 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    3e24:	11 23       	and	r17, r17
    3e26:	2c f4       	brge	.+10     	; 0x3e32 <__vector_64+0x1ce>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    3e28:	1f 77       	andi	r17, 0x7F	; 127
            pcb->battlow++;
    3e2a:	f7 01       	movw	r30, r14
    3e2c:	81 89       	ldd	r24, Z+17	; 0x11
    3e2e:	8f 5f       	subi	r24, 0xFF	; 255
    3e30:	81 8b       	std	Z+17, r24	; 0x11
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    3e32:	11 23       	and	r17, r17
    3e34:	09 f0       	breq	.+2      	; 0x3e38 <__vector_64+0x1d4>
    3e36:	5c cf       	rjmp	.-328    	; 0x3cf0 <__vector_64+0x8c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    3e38:	80 91 57 40 	lds	r24, 0x4057
    3e3c:	8f bf       	out	0x3f, r24	; 63
    3e3e:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    3e40:	8f e0       	ldi	r24, 0x0F	; 15
    3e42:	0e 94 47 1c 	call	0x388e	; 0x388e <chb_reg_read>
}
    3e46:	e2 96       	adiw	r28, 0x32	; 50
    3e48:	cd bf       	out	0x3d, r28	; 61
    3e4a:	de bf       	out	0x3e, r29	; 62
    3e4c:	df 91       	pop	r29
    3e4e:	cf 91       	pop	r28
    3e50:	ff 91       	pop	r31
    3e52:	ef 91       	pop	r30
    3e54:	bf 91       	pop	r27
    3e56:	af 91       	pop	r26
    3e58:	9f 91       	pop	r25
    3e5a:	8f 91       	pop	r24
    3e5c:	7f 91       	pop	r23
    3e5e:	6f 91       	pop	r22
    3e60:	5f 91       	pop	r21
    3e62:	4f 91       	pop	r20
    3e64:	3f 91       	pop	r19
    3e66:	2f 91       	pop	r18
    3e68:	1f 91       	pop	r17
    3e6a:	0f 91       	pop	r16
    3e6c:	ff 90       	pop	r15
    3e6e:	ef 90       	pop	r14
    3e70:	df 90       	pop	r13
    3e72:	bf 90       	pop	r11
    3e74:	af 90       	pop	r10
    3e76:	9f 90       	pop	r9
    3e78:	8f 90       	pop	r8
    3e7a:	7f 90       	pop	r7
    3e7c:	6f 90       	pop	r6
    3e7e:	0f 90       	pop	r0
    3e80:	0b be       	out	0x3b, r0	; 59
    3e82:	0f 90       	pop	r0
    3e84:	0f be       	out	0x3f, r0	; 63
    3e86:	0f 90       	pop	r0
    3e88:	1f 90       	pop	r1
    3e8a:	18 95       	reti

00003e8c <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    3e8c:	0f 93       	push	r16
    3e8e:	1f 93       	push	r17
    3e90:	cf 93       	push	r28
    3e92:	df 93       	push	r29
    3e94:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3e96:	e0 ec       	ldi	r30, 0xC0	; 192
    3e98:	f1 e0       	ldi	r31, 0x01	; 1
    3e9a:	84 85       	ldd	r24, Z+12	; 0x0c
    3e9c:	87 7f       	andi	r24, 0xF7	; 247
    3e9e:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    3ea0:	41 15       	cp	r20, r1
    3ea2:	51 05       	cpc	r21, r1
    3ea4:	09 f4       	brne	.+2      	; 0x3ea8 <chb_eeprom_write+0x1c>
    3ea6:	50 c0       	rjmp	.+160    	; 0x3f48 <chb_eeprom_write+0xbc>
    3ea8:	e0 e0       	ldi	r30, 0x00	; 0
    3eaa:	f0 e0       	ldi	r31, 0x00	; 0
    3eac:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3eae:	a0 ec       	ldi	r26, 0xC0	; 192
    3eb0:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3eb2:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3eb4:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3eb6:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
    3eb8:	cf 01       	movw	r24, r30
    3eba:	80 0f       	add	r24, r16
    3ebc:	91 1f       	adc	r25, r17
    3ebe:	e6 0f       	add	r30, r22
    3ec0:	f7 1f       	adc	r31, r23
    3ec2:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3ec4:	1f 96       	adiw	r26, 0x0f	; 15
    3ec6:	ec 91       	ld	r30, X
    3ec8:	1f 97       	sbiw	r26, 0x0f	; 15
    3eca:	ee 23       	and	r30, r30
    3ecc:	dc f3       	brlt	.-10     	; 0x3ec4 <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    3ece:	1f 96       	adiw	r26, 0x0f	; 15
    3ed0:	ec 91       	ld	r30, X
    3ed2:	1f 97       	sbiw	r26, 0x0f	; 15
    3ed4:	e1 ff       	sbrs	r30, 1
    3ed6:	11 c0       	rjmp	.+34     	; 0x3efa <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3ed8:	1a 96       	adiw	r26, 0x0a	; 10
    3eda:	dc 93       	st	X, r29
    3edc:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
    3ede:	ef 93       	push	r30
    3ee0:	ff 93       	push	r31
    3ee2:	0f 93       	push	r16
    3ee4:	2f 93       	push	r18
    3ee6:	eb ec       	ldi	r30, 0xCB	; 203
    3ee8:	f1 e0       	ldi	r31, 0x01	; 1
    3eea:	08 ed       	ldi	r16, 0xD8	; 216
    3eec:	21 e0       	ldi	r18, 0x01	; 1
    3eee:	04 bf       	out	0x34, r16	; 52
    3ef0:	20 83       	st	Z, r18
    3ef2:	2f 91       	pop	r18
    3ef4:	0f 91       	pop	r16
    3ef6:	ff 91       	pop	r31
    3ef8:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3efa:	1a 96       	adiw	r26, 0x0a	; 10
    3efc:	cc 93       	st	X, r28
    3efe:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    3f00:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3f02:	89 2f       	mov	r24, r25
    3f04:	8f 71       	andi	r24, 0x1F	; 31
    3f06:	11 96       	adiw	r26, 0x01	; 1
    3f08:	8c 93       	st	X, r24
    3f0a:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
    3f0c:	12 96       	adiw	r26, 0x02	; 2
    3f0e:	1c 92       	st	X, r1
    3f10:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
    3f12:	14 96       	adiw	r26, 0x04	; 4
    3f14:	fc 93       	st	X, r31
    3f16:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3f18:	1a 96       	adiw	r26, 0x0a	; 10
    3f1a:	3c 93       	st	X, r19
    3f1c:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
    3f1e:	ef 93       	push	r30
    3f20:	ff 93       	push	r31
    3f22:	0f 93       	push	r16
    3f24:	2f 93       	push	r18
    3f26:	eb ec       	ldi	r30, 0xCB	; 203
    3f28:	f1 e0       	ldi	r31, 0x01	; 1
    3f2a:	08 ed       	ldi	r16, 0xD8	; 216
    3f2c:	21 e0       	ldi	r18, 0x01	; 1
    3f2e:	04 bf       	out	0x34, r16	; 52
    3f30:	20 83       	st	Z, r18
    3f32:	2f 91       	pop	r18
    3f34:	0f 91       	pop	r16
    3f36:	ff 91       	pop	r31
    3f38:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    3f3a:	2f 5f       	subi	r18, 0xFF	; 255
    3f3c:	e2 2f       	mov	r30, r18
    3f3e:	f0 e0       	ldi	r31, 0x00	; 0
    3f40:	e4 17       	cp	r30, r20
    3f42:	f5 07       	cpc	r31, r21
    3f44:	08 f4       	brcc	.+2      	; 0x3f48 <chb_eeprom_write+0xbc>
    3f46:	b8 cf       	rjmp	.-144    	; 0x3eb8 <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    3f48:	df 91       	pop	r29
    3f4a:	cf 91       	pop	r28
    3f4c:	1f 91       	pop	r17
    3f4e:	0f 91       	pop	r16
    3f50:	08 95       	ret

00003f52 <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    3f52:	1f 93       	push	r17
    3f54:	cf 93       	push	r28
    3f56:	df 93       	push	r29
    3f58:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3f5a:	e0 ec       	ldi	r30, 0xC0	; 192
    3f5c:	f1 e0       	ldi	r31, 0x01	; 1
    3f5e:	84 85       	ldd	r24, Z+12	; 0x0c
    3f60:	87 7f       	andi	r24, 0xF7	; 247
    3f62:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3f64:	41 15       	cp	r20, r1
    3f66:	51 05       	cpc	r21, r1
    3f68:	41 f1       	breq	.+80     	; 0x3fba <chb_eeprom_read+0x68>
    3f6a:	80 e0       	ldi	r24, 0x00	; 0
    3f6c:	90 e0       	ldi	r25, 0x00	; 0
    3f6e:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3f70:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3f72:	db 01       	movw	r26, r22
    3f74:	a8 0f       	add	r26, r24
    3f76:	b9 1f       	adc	r27, r25
    3f78:	82 0f       	add	r24, r18
    3f7a:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3f7c:	17 85       	ldd	r17, Z+15	; 0x0f
    3f7e:	11 23       	and	r17, r17
    3f80:	ec f3       	brlt	.-6      	; 0x3f7c <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    3f82:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3f84:	89 2f       	mov	r24, r25
    3f86:	8f 71       	andi	r24, 0x1F	; 31
    3f88:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
    3f8a:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3f8c:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
    3f8e:	ef 93       	push	r30
    3f90:	ff 93       	push	r31
    3f92:	0f 93       	push	r16
    3f94:	2f 93       	push	r18
    3f96:	eb ec       	ldi	r30, 0xCB	; 203
    3f98:	f1 e0       	ldi	r31, 0x01	; 1
    3f9a:	08 ed       	ldi	r16, 0xD8	; 216
    3f9c:	21 e0       	ldi	r18, 0x01	; 1
    3f9e:	04 bf       	out	0x34, r16	; 52
    3fa0:	20 83       	st	Z, r18
    3fa2:	2f 91       	pop	r18
    3fa4:	0f 91       	pop	r16
    3fa6:	ff 91       	pop	r31
    3fa8:	ef 91       	pop	r30

    return NVM.DATA0;
    3faa:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3fac:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3fae:	cf 5f       	subi	r28, 0xFF	; 255
    3fb0:	8c 2f       	mov	r24, r28
    3fb2:	90 e0       	ldi	r25, 0x00	; 0
    3fb4:	84 17       	cp	r24, r20
    3fb6:	95 07       	cpc	r25, r21
    3fb8:	e0 f2       	brcs	.-72     	; 0x3f72 <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    3fba:	df 91       	pop	r29
    3fbc:	cf 91       	pop	r28
    3fbe:	1f 91       	pop	r17
    3fc0:	08 95       	ret

00003fc2 <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    3fc2:	e0 e6       	ldi	r30, 0x60	; 96
    3fc4:	f6 e0       	ldi	r31, 0x06	; 6
    3fc6:	80 81       	ld	r24, Z
    3fc8:	80 6b       	ori	r24, 0xB0	; 176
    3fca:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    3fcc:	e4 e6       	ldi	r30, 0x64	; 100
    3fce:	f6 e0       	ldi	r31, 0x06	; 6
    3fd0:	80 81       	ld	r24, Z
    3fd2:	80 61       	ori	r24, 0x10	; 16
    3fd4:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    3fd6:	a0 ec       	ldi	r26, 0xC0	; 192
    3fd8:	b9 e0       	ldi	r27, 0x09	; 9
    3fda:	8c 91       	ld	r24, X
    3fdc:	81 65       	ori	r24, 0x51	; 81
    3fde:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    3fe0:	80 81       	ld	r24, Z
    3fe2:	80 61       	ori	r24, 0x10	; 16
    3fe4:	80 83       	st	Z, r24
}
    3fe6:	08 95       	ret

00003fe8 <SPID_write>:
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    3fe8:	e0 ec       	ldi	r30, 0xC0	; 192
    3fea:	f9 e0       	ldi	r31, 0x09	; 9
    3fec:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    3fee:	82 81       	ldd	r24, Z+2	; 0x02
    3ff0:	88 23       	and	r24, r24
    3ff2:	ec f7       	brge	.-6      	; 0x3fee <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    3ff4:	e0 ec       	ldi	r30, 0xC0	; 192
    3ff6:	f9 e0       	ldi	r31, 0x09	; 9
    3ff8:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    3ffa:	08 95       	ret

00003ffc <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3ffc:	0f 93       	push	r16
    3ffe:	cf 93       	push	r28
    4000:	df 93       	push	r29
    4002:	0f 92       	push	r0
    4004:	cd b7       	in	r28, 0x3d	; 61
    4006:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    4008:	2f b7       	in	r18, 0x3f	; 63
    400a:	29 83       	std	Y+1, r18	; 0x01
    400c:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    400e:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    4010:	fc 01       	movw	r30, r24
    4012:	08 ed       	ldi	r16, 0xD8	; 216
    4014:	04 bf       	out	0x34, r16	; 52
    4016:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    4018:	89 81       	ldd	r24, Y+1	; 0x01
    401a:	8f bf       	out	0x3f, r24	; 63
#endif
}
    401c:	0f 90       	pop	r0
    401e:	df 91       	pop	r29
    4020:	cf 91       	pop	r28
    4022:	0f 91       	pop	r16
    4024:	08 95       	ret

00004026 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    4026:	66 23       	and	r22, r22
    4028:	11 f0       	breq	.+4      	; 0x402e <CLKSYS_XOSC_Config+0x8>
    402a:	90 e2       	ldi	r25, 0x20	; 32
    402c:	01 c0       	rjmp	.+2      	; 0x4030 <CLKSYS_XOSC_Config+0xa>
    402e:	90 e0       	ldi	r25, 0x00	; 0
    4030:	84 2b       	or	r24, r20
    4032:	89 2b       	or	r24, r25
    4034:	e0 e5       	ldi	r30, 0x50	; 80
    4036:	f0 e0       	ldi	r31, 0x00	; 0
    4038:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    403a:	08 95       	ret

0000403c <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    403c:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    403e:	86 2b       	or	r24, r22
    4040:	e0 e5       	ldi	r30, 0x50	; 80
    4042:	f0 e0       	ldi	r31, 0x00	; 0
    4044:	85 83       	std	Z+5, r24	; 0x05
}
    4046:	08 95       	ret

00004048 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    4048:	e0 e5       	ldi	r30, 0x50	; 80
    404a:	f0 e0       	ldi	r31, 0x00	; 0
    404c:	90 81       	ld	r25, Z
    404e:	28 2f       	mov	r18, r24
    4050:	20 95       	com	r18
    4052:	92 23       	and	r25, r18
    4054:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    4056:	90 81       	ld	r25, Z
	return clkEnabled;
}
    4058:	89 23       	and	r24, r25
    405a:	08 95       	ret

0000405c <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    405c:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    405e:	81 e4       	ldi	r24, 0x41	; 65
    4060:	90 e0       	ldi	r25, 0x00	; 0
    4062:	0e 94 fe 1f 	call	0x3ffc	; 0x3ffc <CCPWrite>
}
    4066:	08 95       	ret

00004068 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    4068:	1f 93       	push	r17
    406a:	cf 93       	push	r28
    406c:	df 93       	push	r29
    406e:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    4070:	c0 e4       	ldi	r28, 0x40	; 64
    4072:	d0 e0       	ldi	r29, 0x00	; 0
    4074:	68 81       	ld	r22, Y
    4076:	68 7f       	andi	r22, 0xF8	; 248
    4078:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    407a:	80 e4       	ldi	r24, 0x40	; 64
    407c:	90 e0       	ldi	r25, 0x00	; 0
    407e:	0e 94 fe 1f 	call	0x3ffc	; 0x3ffc <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    4082:	88 81       	ld	r24, Y
	return clkCtrl;
}
    4084:	81 23       	and	r24, r17
    4086:	df 91       	pop	r29
    4088:	cf 91       	pop	r28
    408a:	1f 91       	pop	r17
    408c:	08 95       	ret

0000408e <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    408e:	e0 e4       	ldi	r30, 0x40	; 64
    4090:	f0 e0       	ldi	r31, 0x00	; 0
    4092:	93 81       	ldd	r25, Z+3	; 0x03
    4094:	91 7f       	andi	r25, 0xF1	; 241
    4096:	91 60       	ori	r25, 0x01	; 1
    4098:	89 2b       	or	r24, r25
    409a:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    409c:	08 95       	ret

0000409e <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    409e:	e0 e5       	ldi	r30, 0x50	; 80
    40a0:	f0 e0       	ldi	r31, 0x00	; 0
    40a2:	26 81       	ldd	r18, Z+6	; 0x06
    40a4:	98 2f       	mov	r25, r24
    40a6:	38 2f       	mov	r19, r24
    40a8:	30 95       	com	r19
    40aa:	23 23       	and	r18, r19
    40ac:	66 23       	and	r22, r22
    40ae:	09 f4       	brne	.+2      	; 0x40b2 <CLKSYS_AutoCalibration_Enable+0x14>
    40b0:	90 e0       	ldi	r25, 0x00	; 0
    40b2:	92 2b       	or	r25, r18
    40b4:	e0 e5       	ldi	r30, 0x50	; 80
    40b6:	f0 e0       	ldi	r31, 0x00	; 0
    40b8:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    40ba:	81 30       	cpi	r24, 0x01	; 1
    40bc:	31 f4       	brne	.+12     	; 0x40ca <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    40be:	e8 e6       	ldi	r30, 0x68	; 104
    40c0:	f0 e0       	ldi	r31, 0x00	; 0
    40c2:	80 81       	ld	r24, Z
    40c4:	81 60       	ori	r24, 0x01	; 1
    40c6:	80 83       	st	Z, r24
    40c8:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    40ca:	82 30       	cpi	r24, 0x02	; 2
    40cc:	29 f4       	brne	.+10     	; 0x40d8 <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    40ce:	e0 e6       	ldi	r30, 0x60	; 96
    40d0:	f0 e0       	ldi	r31, 0x00	; 0
    40d2:	80 81       	ld	r24, Z
    40d4:	81 60       	ori	r24, 0x01	; 1
    40d6:	80 83       	st	Z, r24
    40d8:	08 95       	ret

000040da <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    40da:	83 e5       	ldi	r24, 0x53	; 83
    40dc:	90 e0       	ldi	r25, 0x00	; 0
    40de:	63 e0       	ldi	r22, 0x03	; 3
    40e0:	0e 94 fe 1f 	call	0x3ffc	; 0x3ffc <CCPWrite>
}
    40e4:	08 95       	ret

000040e6 <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    40e6:	82 e4       	ldi	r24, 0x42	; 66
    40e8:	90 e0       	ldi	r25, 0x00	; 0
    40ea:	61 e0       	ldi	r22, 0x01	; 1
    40ec:	0e 94 fe 1f 	call	0x3ffc	; 0x3ffc <CCPWrite>
}
    40f0:	08 95       	ret

000040f2 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    40f2:	cf 92       	push	r12
    40f4:	df 92       	push	r13
    40f6:	ef 92       	push	r14
    40f8:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    40fa:	20 91 69 50 	lds	r18, 0x5069
    40fe:	30 91 6a 50 	lds	r19, 0x506A
    4102:	c0 90 4d 40 	lds	r12, 0x404D
    4106:	d0 90 4e 40 	lds	r13, 0x404E
    410a:	e0 90 4f 40 	lds	r14, 0x404F
    410e:	f0 90 50 40 	lds	r15, 0x4050
    4112:	62 50       	subi	r22, 0x02	; 2
    4114:	70 40       	sbci	r23, 0x00	; 0
    4116:	80 40       	sbci	r24, 0x00	; 0
    4118:	90 40       	sbci	r25, 0x00	; 0
    411a:	40 e0       	ldi	r20, 0x00	; 0
    411c:	50 e0       	ldi	r21, 0x00	; 0
    411e:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    4122:	dc 01       	movw	r26, r24
    4124:	cb 01       	movw	r24, r22
    4126:	c8 0e       	add	r12, r24
    4128:	d9 1e       	adc	r13, r25
    412a:	ea 1e       	adc	r14, r26
    412c:	fb 1e       	adc	r15, r27
}
    412e:	6c 2d       	mov	r22, r12
    4130:	7d 2d       	mov	r23, r13
    4132:	8e 2d       	mov	r24, r14
    4134:	9f 2d       	mov	r25, r15
    4136:	ff 90       	pop	r15
    4138:	ef 90       	pop	r14
    413a:	df 90       	pop	r13
    413c:	cf 90       	pop	r12
    413e:	08 95       	ret

00004140 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    4140:	3f 92       	push	r3
    4142:	4f 92       	push	r4
    4144:	5f 92       	push	r5
    4146:	6f 92       	push	r6
    4148:	7f 92       	push	r7
    414a:	8f 92       	push	r8
    414c:	9f 92       	push	r9
    414e:	af 92       	push	r10
    4150:	bf 92       	push	r11
    4152:	cf 92       	push	r12
    4154:	df 92       	push	r13
    4156:	ef 92       	push	r14
    4158:	ff 92       	push	r15
    415a:	0f 93       	push	r16
    415c:	1f 93       	push	r17
    415e:	cf 93       	push	r28
    4160:	df 93       	push	r29
    4162:	00 d0       	rcall	.+0      	; 0x4164 <getSetNextCluster+0x24>
    4164:	0f 92       	push	r0
    4166:	cd b7       	in	r28, 0x3d	; 61
    4168:	de b7       	in	r29, 0x3e	; 62
    416a:	dc 01       	movw	r26, r24
    416c:	cb 01       	movw	r24, r22
    416e:	34 2e       	mov	r3, r20
    4170:	09 83       	std	Y+1, r16	; 0x01
    4172:	1a 83       	std	Y+2, r17	; 0x02
    4174:	2b 83       	std	Y+3, r18	; 0x03
    4176:	3c 83       	std	Y+4, r19	; 0x04
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    4178:	80 90 6f 50 	lds	r8, 0x506F
    417c:	90 90 70 50 	lds	r9, 0x5070
    4180:	2c 01       	movw	r4, r24
    4182:	3d 01       	movw	r6, r26
    4184:	44 0c       	add	r4, r4
    4186:	55 1c       	adc	r5, r5
    4188:	66 1c       	adc	r6, r6
    418a:	77 1c       	adc	r7, r7
    418c:	44 0c       	add	r4, r4
    418e:	55 1c       	adc	r5, r5
    4190:	66 1c       	adc	r6, r6
    4192:	77 1c       	adc	r7, r7
    4194:	20 91 55 40 	lds	r18, 0x4055
    4198:	30 91 56 40 	lds	r19, 0x4056
    419c:	aa 24       	eor	r10, r10
    419e:	bb 24       	eor	r11, r11
    41a0:	80 91 6b 50 	lds	r24, 0x506B
    41a4:	90 91 6c 50 	lds	r25, 0x506C
    41a8:	a0 91 6d 50 	lds	r26, 0x506D
    41ac:	b0 91 6e 50 	lds	r27, 0x506E
    41b0:	88 0e       	add	r8, r24
    41b2:	99 1e       	adc	r9, r25
    41b4:	aa 1e       	adc	r10, r26
    41b6:	bb 1e       	adc	r11, r27
    41b8:	40 e0       	ldi	r20, 0x00	; 0
    41ba:	50 e0       	ldi	r21, 0x00	; 0
    41bc:	c3 01       	movw	r24, r6
    41be:	b2 01       	movw	r22, r4
    41c0:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    41c4:	69 01       	movw	r12, r18
    41c6:	7a 01       	movw	r14, r20
    41c8:	c8 0c       	add	r12, r8
    41ca:	d9 1c       	adc	r13, r9
    41cc:	ea 1c       	adc	r14, r10
    41ce:	fb 1c       	adc	r15, r11

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    41d0:	00 91 55 40 	lds	r16, 0x4055
    41d4:	10 91 56 40 	lds	r17, 0x4056

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    41d8:	c7 01       	movw	r24, r14
    41da:	b6 01       	movw	r22, r12
    41dc:	48 e4       	ldi	r20, 0x48	; 72
    41de:	5e e3       	ldi	r21, 0x3E	; 62
    41e0:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <SD_read_block>

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    41e4:	98 01       	movw	r18, r16
    41e6:	40 e0       	ldi	r20, 0x00	; 0
    41e8:	50 e0       	ldi	r21, 0x00	; 0
    41ea:	c3 01       	movw	r24, r6
    41ec:	b2 01       	movw	r22, r4
    41ee:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    41f2:	68 5b       	subi	r22, 0xB8	; 184
    41f4:	71 4c       	sbci	r23, 0xC1	; 193

if(get_set == GET)
    41f6:	33 20       	and	r3, r3
    41f8:	41 f4       	brne	.+16     	; 0x420a <getSetNextCluster+0xca>
  return ((*FATEntryValue) & 0x0fffffff);
    41fa:	db 01       	movw	r26, r22
    41fc:	0d 91       	ld	r16, X+
    41fe:	1d 91       	ld	r17, X+
    4200:	2d 91       	ld	r18, X+
    4202:	3c 91       	ld	r19, X
    4204:	13 97       	sbiw	r26, 0x03	; 3
    4206:	3f 70       	andi	r19, 0x0F	; 15
    4208:	14 c0       	rjmp	.+40     	; 0x4232 <getSetNextCluster+0xf2>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    420a:	89 81       	ldd	r24, Y+1	; 0x01
    420c:	9a 81       	ldd	r25, Y+2	; 0x02
    420e:	ab 81       	ldd	r26, Y+3	; 0x03
    4210:	bc 81       	ldd	r27, Y+4	; 0x04
    4212:	fb 01       	movw	r30, r22
    4214:	80 83       	st	Z, r24
    4216:	91 83       	std	Z+1, r25	; 0x01
    4218:	a2 83       	std	Z+2, r26	; 0x02
    421a:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    421c:	c7 01       	movw	r24, r14
    421e:	b6 01       	movw	r22, r12
    4220:	48 e4       	ldi	r20, 0x48	; 72
    4222:	5e e3       	ldi	r21, 0x3E	; 62
    4224:	20 e0       	ldi	r18, 0x00	; 0
    4226:	32 e0       	ldi	r19, 0x02	; 2
    4228:	0e 94 ca 2a 	call	0x5594	; 0x5594 <SD_write_block>

return (0);
    422c:	00 e0       	ldi	r16, 0x00	; 0
    422e:	10 e0       	ldi	r17, 0x00	; 0
    4230:	98 01       	movw	r18, r16
}
    4232:	60 2f       	mov	r22, r16
    4234:	71 2f       	mov	r23, r17
    4236:	82 2f       	mov	r24, r18
    4238:	93 2f       	mov	r25, r19
    423a:	24 96       	adiw	r28, 0x04	; 4
    423c:	cd bf       	out	0x3d, r28	; 61
    423e:	de bf       	out	0x3e, r29	; 62
    4240:	df 91       	pop	r29
    4242:	cf 91       	pop	r28
    4244:	1f 91       	pop	r17
    4246:	0f 91       	pop	r16
    4248:	ff 90       	pop	r15
    424a:	ef 90       	pop	r14
    424c:	df 90       	pop	r13
    424e:	cf 90       	pop	r12
    4250:	bf 90       	pop	r11
    4252:	af 90       	pop	r10
    4254:	9f 90       	pop	r9
    4256:	8f 90       	pop	r8
    4258:	7f 90       	pop	r7
    425a:	6f 90       	pop	r6
    425c:	5f 90       	pop	r5
    425e:	4f 90       	pop	r4
    4260:	3f 90       	pop	r3
    4262:	08 95       	ret

00004264 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    4264:	cf 92       	push	r12
    4266:	df 92       	push	r13
    4268:	ef 92       	push	r14
    426a:	ff 92       	push	r15
    426c:	0f 93       	push	r16
    426e:	1f 93       	push	r17
    4270:	cf 93       	push	r28
    4272:	c8 2f       	mov	r28, r24
    4274:	06 2f       	mov	r16, r22
    4276:	69 01       	movw	r12, r18
    4278:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    427a:	80 91 6b 50 	lds	r24, 0x506B
    427e:	90 91 6c 50 	lds	r25, 0x506C
    4282:	a0 91 6d 50 	lds	r26, 0x506D
    4286:	b0 91 6e 50 	lds	r27, 0x506E
    428a:	bc 01       	movw	r22, r24
    428c:	cd 01       	movw	r24, r26
    428e:	6f 5f       	subi	r22, 0xFF	; 255
    4290:	7f 4f       	sbci	r23, 0xFF	; 255
    4292:	8f 4f       	sbci	r24, 0xFF	; 255
    4294:	9f 4f       	sbci	r25, 0xFF	; 255
    4296:	48 e4       	ldi	r20, 0x48	; 72
    4298:	5e e3       	ldi	r21, 0x3E	; 62
    429a:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    429e:	80 91 48 3e 	lds	r24, 0x3E48
    42a2:	90 91 49 3e 	lds	r25, 0x3E49
    42a6:	a0 91 4a 3e 	lds	r26, 0x3E4A
    42aa:	b0 91 4b 3e 	lds	r27, 0x3E4B
    42ae:	82 35       	cpi	r24, 0x52	; 82
    42b0:	22 e5       	ldi	r18, 0x52	; 82
    42b2:	92 07       	cpc	r25, r18
    42b4:	21 e6       	ldi	r18, 0x61	; 97
    42b6:	a2 07       	cpc	r26, r18
    42b8:	21 e4       	ldi	r18, 0x41	; 65
    42ba:	b2 07       	cpc	r27, r18
    42bc:	09 f0       	breq	.+2      	; 0x42c0 <getSetFreeCluster+0x5c>
    42be:	63 c0       	rjmp	.+198    	; 0x4386 <getSetFreeCluster+0x122>
    42c0:	80 91 2c 40 	lds	r24, 0x402C
    42c4:	90 91 2d 40 	lds	r25, 0x402D
    42c8:	a0 91 2e 40 	lds	r26, 0x402E
    42cc:	b0 91 2f 40 	lds	r27, 0x402F
    42d0:	82 37       	cpi	r24, 0x72	; 114
    42d2:	22 e7       	ldi	r18, 0x72	; 114
    42d4:	92 07       	cpc	r25, r18
    42d6:	21 e4       	ldi	r18, 0x41	; 65
    42d8:	a2 07       	cpc	r26, r18
    42da:	21 e6       	ldi	r18, 0x61	; 97
    42dc:	b2 07       	cpc	r27, r18
    42de:	09 f0       	breq	.+2      	; 0x42e2 <getSetFreeCluster+0x7e>
    42e0:	56 c0       	rjmp	.+172    	; 0x438e <getSetFreeCluster+0x12a>
    42e2:	80 91 44 40 	lds	r24, 0x4044
    42e6:	90 91 45 40 	lds	r25, 0x4045
    42ea:	a0 91 46 40 	lds	r26, 0x4046
    42ee:	b0 91 47 40 	lds	r27, 0x4047
    42f2:	80 30       	cpi	r24, 0x00	; 0
    42f4:	20 e0       	ldi	r18, 0x00	; 0
    42f6:	92 07       	cpc	r25, r18
    42f8:	25 e5       	ldi	r18, 0x55	; 85
    42fa:	a2 07       	cpc	r26, r18
    42fc:	2a ea       	ldi	r18, 0xAA	; 170
    42fe:	b2 07       	cpc	r27, r18
    4300:	09 f0       	breq	.+2      	; 0x4304 <getSetFreeCluster+0xa0>
    4302:	49 c0       	rjmp	.+146    	; 0x4396 <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    4304:	00 23       	and	r16, r16
    4306:	a1 f4       	brne	.+40     	; 0x4330 <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    4308:	c1 30       	cpi	r28, 0x01	; 1
    430a:	49 f4       	brne	.+18     	; 0x431e <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    430c:	00 91 30 40 	lds	r16, 0x4030
    4310:	10 91 31 40 	lds	r17, 0x4031
    4314:	20 91 32 40 	lds	r18, 0x4032
    4318:	30 91 33 40 	lds	r19, 0x4033
    431c:	3f c0       	rjmp	.+126    	; 0x439c <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    431e:	00 91 34 40 	lds	r16, 0x4034
    4322:	10 91 35 40 	lds	r17, 0x4035
    4326:	20 91 36 40 	lds	r18, 0x4036
    432a:	30 91 37 40 	lds	r19, 0x4037
    432e:	36 c0       	rjmp	.+108    	; 0x439c <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    4330:	c1 30       	cpi	r28, 0x01	; 1
    4332:	49 f4       	brne	.+18     	; 0x4346 <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    4334:	c0 92 30 40 	sts	0x4030, r12
    4338:	d0 92 31 40 	sts	0x4031, r13
    433c:	e0 92 32 40 	sts	0x4032, r14
    4340:	f0 92 33 40 	sts	0x4033, r15
    4344:	08 c0       	rjmp	.+16     	; 0x4356 <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    4346:	c0 92 34 40 	sts	0x4034, r12
    434a:	d0 92 35 40 	sts	0x4035, r13
    434e:	e0 92 36 40 	sts	0x4036, r14
    4352:	f0 92 37 40 	sts	0x4037, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    4356:	80 91 6b 50 	lds	r24, 0x506B
    435a:	90 91 6c 50 	lds	r25, 0x506C
    435e:	a0 91 6d 50 	lds	r26, 0x506D
    4362:	b0 91 6e 50 	lds	r27, 0x506E
    4366:	bc 01       	movw	r22, r24
    4368:	cd 01       	movw	r24, r26
    436a:	6f 5f       	subi	r22, 0xFF	; 255
    436c:	7f 4f       	sbci	r23, 0xFF	; 255
    436e:	8f 4f       	sbci	r24, 0xFF	; 255
    4370:	9f 4f       	sbci	r25, 0xFF	; 255
    4372:	48 e4       	ldi	r20, 0x48	; 72
    4374:	5e e3       	ldi	r21, 0x3E	; 62
    4376:	20 e0       	ldi	r18, 0x00	; 0
    4378:	32 e0       	ldi	r19, 0x02	; 2
    437a:	0e 94 ca 2a 	call	0x5594	; 0x5594 <SD_write_block>
 }
 return 0xffffffff;
    437e:	0f ef       	ldi	r16, 0xFF	; 255
    4380:	1f ef       	ldi	r17, 0xFF	; 255
    4382:	98 01       	movw	r18, r16
    4384:	0b c0       	rjmp	.+22     	; 0x439c <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    4386:	0f ef       	ldi	r16, 0xFF	; 255
    4388:	1f ef       	ldi	r17, 0xFF	; 255
    438a:	98 01       	movw	r18, r16
    438c:	07 c0       	rjmp	.+14     	; 0x439c <getSetFreeCluster+0x138>
    438e:	0f ef       	ldi	r16, 0xFF	; 255
    4390:	1f ef       	ldi	r17, 0xFF	; 255
    4392:	98 01       	movw	r18, r16
    4394:	03 c0       	rjmp	.+6      	; 0x439c <getSetFreeCluster+0x138>
    4396:	0f ef       	ldi	r16, 0xFF	; 255
    4398:	1f ef       	ldi	r17, 0xFF	; 255
    439a:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    439c:	60 2f       	mov	r22, r16
    439e:	71 2f       	mov	r23, r17
    43a0:	82 2f       	mov	r24, r18
    43a2:	93 2f       	mov	r25, r19
    43a4:	cf 91       	pop	r28
    43a6:	1f 91       	pop	r17
    43a8:	0f 91       	pop	r16
    43aa:	ff 90       	pop	r15
    43ac:	ef 90       	pop	r14
    43ae:	df 90       	pop	r13
    43b0:	cf 90       	pop	r12
    43b2:	08 95       	ret

000043b4 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    43b4:	ef 92       	push	r14
    43b6:	ff 92       	push	r15
    43b8:	0f 93       	push	r16
    43ba:	1f 93       	push	r17
    43bc:	cf 93       	push	r28
    43be:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    43c0:	10 92 6b 50 	sts	0x506B, r1
    43c4:	10 92 6c 50 	sts	0x506C, r1
    43c8:	10 92 6d 50 	sts	0x506D, r1
    43cc:	10 92 6e 50 	sts	0x506E, r1

SD_read_block(0,SDBuffer);
    43d0:	60 e0       	ldi	r22, 0x00	; 0
    43d2:	70 e0       	ldi	r23, 0x00	; 0
    43d4:	cb 01       	movw	r24, r22
    43d6:	48 e4       	ldi	r20, 0x48	; 72
    43d8:	5e e3       	ldi	r21, 0x3E	; 62
    43da:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    43de:	80 91 48 3e 	lds	r24, 0x3E48
    43e2:	89 3e       	cpi	r24, 0xE9	; 233
    43e4:	31 f1       	breq	.+76     	; 0x4432 <getBootSectorData+0x7e>
    43e6:	8b 3e       	cpi	r24, 0xEB	; 235
    43e8:	21 f1       	breq	.+72     	; 0x4432 <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    43ea:	80 91 46 40 	lds	r24, 0x4046
    43ee:	90 91 47 40 	lds	r25, 0x4047
    43f2:	2a ea       	ldi	r18, 0xAA	; 170
    43f4:	85 35       	cpi	r24, 0x55	; 85
    43f6:	92 07       	cpc	r25, r18
    43f8:	09 f0       	breq	.+2      	; 0x43fc <getBootSectorData+0x48>
    43fa:	b7 c0       	rjmp	.+366    	; 0x456a <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    43fc:	60 91 0e 40 	lds	r22, 0x400E
    4400:	70 91 0f 40 	lds	r23, 0x400F
    4404:	80 91 10 40 	lds	r24, 0x4010
    4408:	90 91 11 40 	lds	r25, 0x4011
    440c:	60 93 6b 50 	sts	0x506B, r22
    4410:	70 93 6c 50 	sts	0x506C, r23
    4414:	80 93 6d 50 	sts	0x506D, r24
    4418:	90 93 6e 50 	sts	0x506E, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    441c:	48 e4       	ldi	r20, 0x48	; 72
    441e:	5e e3       	ldi	r21, 0x3E	; 62
    4420:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4424:	80 91 48 3e 	lds	r24, 0x3E48
    4428:	89 3e       	cpi	r24, 0xE9	; 233
    442a:	19 f0       	breq	.+6      	; 0x4432 <getBootSectorData+0x7e>
    442c:	8b 3e       	cpi	r24, 0xEB	; 235
    442e:	09 f0       	breq	.+2      	; 0x4432 <getBootSectorData+0x7e>
    4430:	9e c0       	rjmp	.+316    	; 0x456e <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    4432:	80 91 53 3e 	lds	r24, 0x3E53
    4436:	90 91 54 3e 	lds	r25, 0x3E54
    443a:	80 93 55 40 	sts	0x4055, r24
    443e:	90 93 56 40 	sts	0x4056, r25
sectorPerCluster = bpb->sectorPerCluster;
    4442:	80 91 55 3e 	lds	r24, 0x3E55
    4446:	90 e0       	ldi	r25, 0x00	; 0
    4448:	80 93 69 50 	sts	0x5069, r24
    444c:	90 93 6a 50 	sts	0x506A, r25
reservedSectorCount = bpb->reservedSectorCount;
    4450:	e0 90 56 3e 	lds	r14, 0x3E56
    4454:	f0 90 57 3e 	lds	r15, 0x3E57
    4458:	e0 92 6f 50 	sts	0x506F, r14
    445c:	f0 92 70 50 	sts	0x5070, r15
rootCluster = bpb->rootCluster;
    4460:	80 91 74 3e 	lds	r24, 0x3E74
    4464:	90 91 75 3e 	lds	r25, 0x3E75
    4468:	a0 91 76 3e 	lds	r26, 0x3E76
    446c:	b0 91 77 3e 	lds	r27, 0x3E77
    4470:	80 93 5d 40 	sts	0x405D, r24
    4474:	90 93 5e 40 	sts	0x405E, r25
    4478:	a0 93 5f 40 	sts	0x405F, r26
    447c:	b0 93 60 40 	sts	0x4060, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    4480:	c0 91 6f 50 	lds	r28, 0x506F
    4484:	d0 91 70 50 	lds	r29, 0x5070
    4488:	60 91 58 3e 	lds	r22, 0x3E58
    448c:	70 e0       	ldi	r23, 0x00	; 0
    448e:	80 e0       	ldi	r24, 0x00	; 0
    4490:	90 e0       	ldi	r25, 0x00	; 0
    4492:	20 91 6c 3e 	lds	r18, 0x3E6C
    4496:	30 91 6d 3e 	lds	r19, 0x3E6D
    449a:	40 91 6e 3e 	lds	r20, 0x3E6E
    449e:	50 91 6f 3e 	lds	r21, 0x3E6F
    44a2:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    44a6:	8b 01       	movw	r16, r22
    44a8:	9c 01       	movw	r18, r24
    44aa:	ae 01       	movw	r20, r28
    44ac:	60 e0       	ldi	r22, 0x00	; 0
    44ae:	70 e0       	ldi	r23, 0x00	; 0
    44b0:	80 91 64 3e 	lds	r24, 0x3E64
    44b4:	90 91 65 3e 	lds	r25, 0x3E65
    44b8:	a0 91 66 3e 	lds	r26, 0x3E66
    44bc:	b0 91 67 3e 	lds	r27, 0x3E67
    44c0:	84 0f       	add	r24, r20
    44c2:	95 1f       	adc	r25, r21
    44c4:	a6 1f       	adc	r26, r22
    44c6:	b7 1f       	adc	r27, r23
    44c8:	80 0f       	add	r24, r16
    44ca:	91 1f       	adc	r25, r17
    44cc:	a2 1f       	adc	r26, r18
    44ce:	b3 1f       	adc	r27, r19
    44d0:	80 93 4d 40 	sts	0x404D, r24
    44d4:	90 93 4e 40 	sts	0x404E, r25
    44d8:	a0 93 4f 40 	sts	0x404F, r26
    44dc:	b0 93 50 40 	sts	0x4050, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    44e0:	e0 91 69 50 	lds	r30, 0x5069
    44e4:	f0 91 6a 50 	lds	r31, 0x506A
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    44e8:	c7 01       	movw	r24, r14
    44ea:	a0 e0       	ldi	r26, 0x00	; 0
    44ec:	b0 e0       	ldi	r27, 0x00	; 0
    44ee:	40 91 68 3e 	lds	r20, 0x3E68
    44f2:	50 91 69 3e 	lds	r21, 0x3E69
    44f6:	60 91 6a 3e 	lds	r22, 0x3E6A
    44fa:	70 91 6b 3e 	lds	r23, 0x3E6B
    44fe:	48 1b       	sub	r20, r24
    4500:	59 0b       	sbc	r21, r25
    4502:	6a 0b       	sbc	r22, r26
    4504:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    4506:	cb 01       	movw	r24, r22
    4508:	ba 01       	movw	r22, r20
    450a:	60 1b       	sub	r22, r16
    450c:	71 0b       	sbc	r23, r17
    450e:	82 0b       	sbc	r24, r18
    4510:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    4512:	9f 01       	movw	r18, r30
    4514:	40 e0       	ldi	r20, 0x00	; 0
    4516:	50 e0       	ldi	r21, 0x00	; 0
    4518:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    451c:	20 93 58 40 	sts	0x4058, r18
    4520:	30 93 59 40 	sts	0x4059, r19
    4524:	40 93 5a 40 	sts	0x405A, r20
    4528:	50 93 5b 40 	sts	0x405B, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    452c:	81 e0       	ldi	r24, 0x01	; 1
    452e:	60 e0       	ldi	r22, 0x00	; 0
    4530:	20 e0       	ldi	r18, 0x00	; 0
    4532:	30 e0       	ldi	r19, 0x00	; 0
    4534:	a9 01       	movw	r20, r18
    4536:	0e 94 32 21 	call	0x4264	; 0x4264 <getSetFreeCluster>
    453a:	ab 01       	movw	r20, r22
    453c:	bc 01       	movw	r22, r24
    453e:	80 91 58 40 	lds	r24, 0x4058
    4542:	90 91 59 40 	lds	r25, 0x4059
    4546:	a0 91 5a 40 	lds	r26, 0x405A
    454a:	b0 91 5b 40 	lds	r27, 0x405B
    454e:	84 17       	cp	r24, r20
    4550:	95 07       	cpc	r25, r21
    4552:	a6 07       	cpc	r26, r22
    4554:	b7 07       	cpc	r27, r23
    4556:	20 f4       	brcc	.+8      	; 0x4560 <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    4558:	10 92 a1 50 	sts	0x50A1, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    455c:	80 e0       	ldi	r24, 0x00	; 0
    455e:	08 c0       	rjmp	.+16     	; 0x4570 <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    4560:	81 e0       	ldi	r24, 0x01	; 1
    4562:	80 93 a1 50 	sts	0x50A1, r24
return 0;
    4566:	80 e0       	ldi	r24, 0x00	; 0
    4568:	03 c0       	rjmp	.+6      	; 0x4570 <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    456a:	81 e0       	ldi	r24, 0x01	; 1
    456c:	01 c0       	rjmp	.+2      	; 0x4570 <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    456e:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    4570:	df 91       	pop	r29
    4572:	cf 91       	pop	r28
    4574:	1f 91       	pop	r17
    4576:	0f 91       	pop	r16
    4578:	ff 90       	pop	r15
    457a:	ef 90       	pop	r14
    457c:	08 95       	ret

0000457e <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    457e:	0f 93       	push	r16
    4580:	1f 93       	push	r17
    4582:	cf 93       	push	r28
    4584:	df 93       	push	r29
    4586:	cd b7       	in	r28, 0x3d	; 61
    4588:	de b7       	in	r29, 0x3e	; 62
    458a:	2b 97       	sbiw	r28, 0x0b	; 11
    458c:	cd bf       	out	0x3d, r28	; 61
    458e:	de bf       	out	0x3e, r29	; 62
    4590:	78 2f       	mov	r23, r24
    4592:	69 2f       	mov	r22, r25
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    4594:	e8 2f       	mov	r30, r24
    4596:	f9 2f       	mov	r31, r25
    4598:	df 01       	movw	r26, r30
    459a:	0d 90       	ld	r0, X+
    459c:	00 20       	and	r0, r0
    459e:	e9 f7       	brne	.-6      	; 0x459a <convertFileName+0x1c>
    45a0:	11 97       	sbiw	r26, 0x01	; 1
    45a2:	ae 1b       	sub	r26, r30
    45a4:	bf 0b       	sbc	r27, r31
    45a6:	a0 31       	cpi	r26, 0x10	; 16
    45a8:	b1 05       	cpc	r27, r1
    45aa:	08 f0       	brcs	.+2      	; 0x45ae <convertFileName+0x30>
    45ac:	9c c0       	rjmp	.+312    	; 0x46e6 <convertFileName+0x168>
    45ae:	28 2f       	mov	r18, r24
    45b0:	39 2f       	mov	r19, r25
    45b2:	01 e9       	ldi	r16, 0x91	; 145
    45b4:	10 e5       	ldi	r17, 0x50	; 80
    45b6:	a8 01       	movw	r20, r16
    45b8:	80 e0       	ldi	r24, 0x00	; 0
    45ba:	90 e0       	ldi	r25, 0x00	; 0
    45bc:	07 c0       	rjmp	.+14     	; 0x45cc <convertFileName+0x4e>
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
    45be:	d9 01       	movw	r26, r18
    45c0:	ed 91       	ld	r30, X+
    45c2:	9d 01       	movw	r18, r26
    45c4:	da 01       	movw	r26, r20
    45c6:	ed 93       	st	X+, r30
    45c8:	ad 01       	movw	r20, r26

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    45ca:	01 96       	adiw	r24, 0x01	; 1
    45cc:	a7 2f       	mov	r26, r23
    45ce:	b6 2f       	mov	r27, r22
    45d0:	fd 01       	movw	r30, r26
    45d2:	01 90       	ld	r0, Z+
    45d4:	00 20       	and	r0, r0
    45d6:	e9 f7       	brne	.-6      	; 0x45d2 <convertFileName+0x54>
    45d8:	31 97       	sbiw	r30, 0x01	; 1
    45da:	ea 1b       	sub	r30, r26
    45dc:	fb 0b       	sbc	r31, r27
    45de:	8e 17       	cp	r24, r30
    45e0:	9f 07       	cpc	r25, r31
    45e2:	68 f3       	brcs	.-38     	; 0x45be <convertFileName+0x40>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    45e4:	8f 30       	cpi	r24, 0x0F	; 15
    45e6:	91 05       	cpc	r25, r1
    45e8:	54 f4       	brge	.+20     	; 0x45fe <convertFileName+0x80>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    45ea:	fc 01       	movw	r30, r24
    45ec:	ef 56       	subi	r30, 0x6F	; 111
    45ee:	ff 4a       	sbci	r31, 0xAF	; 175
    45f0:	80 ea       	ldi	r24, 0xA0	; 160
    45f2:	90 e5       	ldi	r25, 0x50	; 80
if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    45f4:	20 e2       	ldi	r18, 0x20	; 32
    45f6:	21 93       	st	Z+, r18
    45f8:	e8 17       	cp	r30, r24
    45fa:	f9 07       	cpc	r31, r25
    45fc:	e1 f7       	brne	.-8      	; 0x45f6 <convertFileName+0x78>


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    45fe:	80 91 91 50 	lds	r24, 0x5091
    4602:	8e 32       	cpi	r24, 0x2E	; 46
    4604:	91 f0       	breq	.+36     	; 0x462a <convertFileName+0xac>
    4606:	e2 e9       	ldi	r30, 0x92	; 146
    4608:	f0 e5       	ldi	r31, 0x50	; 80
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    460a:	21 e0       	ldi	r18, 0x01	; 1
if(Filename[j] == '.') break;
    460c:	81 91       	ld	r24, Z+
    460e:	8e 32       	cpi	r24, 0x2E	; 46
    4610:	21 f0       	breq	.+8      	; 0x461a <convertFileName+0x9c>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    4612:	2f 5f       	subi	r18, 0xFF	; 255
    4614:	2c 30       	cpi	r18, 0x0C	; 12
    4616:	d1 f7       	brne	.-12     	; 0x460c <convertFileName+0x8e>
    4618:	05 c0       	rjmp	.+10     	; 0x4624 <convertFileName+0xa6>
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    461a:	82 2f       	mov	r24, r18
    461c:	89 50       	subi	r24, 0x09	; 9
    461e:	83 30       	cpi	r24, 0x03	; 3
    4620:	08 f4       	brcc	.+2      	; 0x4624 <convertFileName+0xa6>
    4622:	63 c0       	rjmp	.+198    	; 0x46ea <convertFileName+0x16c>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4624:	22 23       	and	r18, r18
    4626:	29 f4       	brne	.+10     	; 0x4632 <convertFileName+0xb4>
    4628:	01 c0       	rjmp	.+2      	; 0x462c <convertFileName+0xae>
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    462a:	20 e0       	ldi	r18, 0x00	; 0
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    462c:	82 2f       	mov	r24, r18

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    462e:	90 e2       	ldi	r25, 0x20	; 32
    4630:	10 c0       	rjmp	.+32     	; 0x4652 <convertFileName+0xd4>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4632:	de 01       	movw	r26, r28
    4634:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4636:	82 2f       	mov	r24, r18
    4638:	81 50       	subi	r24, 0x01	; 1
    463a:	90 e0       	ldi	r25, 0x00	; 0
    463c:	8e 56       	subi	r24, 0x6E	; 110
    463e:	9f 4a       	sbci	r25, 0xAF	; 175
    4640:	f8 01       	movw	r30, r16
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];
    4642:	31 91       	ld	r19, Z+
    4644:	3d 93       	st	X+, r19

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4646:	e8 17       	cp	r30, r24
    4648:	f9 07       	cpc	r31, r25
    464a:	d9 f7       	brne	.-10     	; 0x4642 <convertFileName+0xc4>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    464c:	28 30       	cpi	r18, 0x08	; 8
    464e:	70 f3       	brcs	.-36     	; 0x462c <convertFileName+0xae>
    4650:	0a c0       	rjmp	.+20     	; 0x4666 <convertFileName+0xe8>
  fileNameFAT[k] = ' ';
    4652:	e1 e0       	ldi	r30, 0x01	; 1
    4654:	f0 e0       	ldi	r31, 0x00	; 0
    4656:	ec 0f       	add	r30, r28
    4658:	fd 1f       	adc	r31, r29
    465a:	e8 0f       	add	r30, r24
    465c:	f1 1d       	adc	r31, r1
    465e:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    4660:	8f 5f       	subi	r24, 0xFF	; 255
    4662:	88 30       	cpi	r24, 0x08	; 8
    4664:	b0 f3       	brcs	.-20     	; 0x4652 <convertFileName+0xd4>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    4666:	2c 30       	cpi	r18, 0x0C	; 12
    4668:	09 f0       	breq	.+2      	; 0x466c <convertFileName+0xee>
    466a:	2f 5f       	subi	r18, 0xFF	; 255
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    466c:	38 e0       	ldi	r19, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    466e:	81 e9       	ldi	r24, 0x91	; 145
    4670:	90 e5       	ldi	r25, 0x50	; 80
    4672:	fc 01       	movw	r30, r24
    4674:	e2 0f       	add	r30, r18
    4676:	f1 1d       	adc	r31, r1
    4678:	40 81       	ld	r20, Z
    467a:	44 23       	and	r20, r20
    467c:	19 f4       	brne	.+6      	; 0x4684 <convertFileName+0x106>
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    467e:	3b 30       	cpi	r19, 0x0B	; 11
    4680:	50 f0       	brcs	.+20     	; 0x4696 <convertFileName+0x118>
    4682:	15 c0       	rjmp	.+42     	; 0x46ae <convertFileName+0x130>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
    4684:	e1 e0       	ldi	r30, 0x01	; 1
    4686:	f0 e0       	ldi	r31, 0x00	; 0
    4688:	ec 0f       	add	r30, r28
    468a:	fd 1f       	adc	r31, r29
    468c:	e3 0f       	add	r30, r19
    468e:	f1 1d       	adc	r31, r1
    4690:	40 83       	st	Z, r20
    4692:	2f 5f       	subi	r18, 0xFF	; 255
    4694:	0c c0       	rjmp	.+24     	; 0x46ae <convertFileName+0x130>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    4696:	80 e2       	ldi	r24, 0x20	; 32
    4698:	e1 e0       	ldi	r30, 0x01	; 1
    469a:	f0 e0       	ldi	r31, 0x00	; 0
    469c:	ec 0f       	add	r30, r28
    469e:	fd 1f       	adc	r31, r29
    46a0:	e3 0f       	add	r30, r19
    46a2:	f1 1d       	adc	r31, r1
    46a4:	80 83       	st	Z, r24
    46a6:	3f 5f       	subi	r19, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    46a8:	3b 30       	cpi	r19, 0x0B	; 11
    46aa:	b1 f7       	brne	.-20     	; 0x4698 <convertFileName+0x11a>
    46ac:	03 c0       	rjmp	.+6      	; 0x46b4 <convertFileName+0x136>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    46ae:	3f 5f       	subi	r19, 0xFF	; 255
    46b0:	3b 30       	cpi	r19, 0x0B	; 11
    46b2:	f8 f2       	brcs	.-66     	; 0x4672 <convertFileName+0xf4>
    46b4:	de 01       	movw	r26, r28
    46b6:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    46b8:	ce 01       	movw	r24, r28
    46ba:	0c 96       	adiw	r24, 0x0c	; 12
    46bc:	fd 01       	movw	r30, r26
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    46be:	20 81       	ld	r18, Z
    46c0:	32 2f       	mov	r19, r18
    46c2:	31 56       	subi	r19, 0x61	; 97
    46c4:	3a 31       	cpi	r19, 0x1A	; 26
    46c6:	10 f4       	brcc	.+4      	; 0x46cc <convertFileName+0x14e>
    fileNameFAT[j] -= 0x20;
    46c8:	20 52       	subi	r18, 0x20	; 32
    46ca:	20 83       	st	Z, r18
    46cc:	31 96       	adiw	r30, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    46ce:	e8 17       	cp	r30, r24
    46d0:	f9 07       	cpc	r31, r25
    46d2:	a9 f7       	brne	.-22     	; 0x46be <convertFileName+0x140>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];
    46d4:	2d 91       	ld	r18, X+
    46d6:	f8 01       	movw	r30, r16
    46d8:	21 93       	st	Z+, r18
    46da:	8f 01       	movw	r16, r30

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    46dc:	a8 17       	cp	r26, r24
    46de:	b9 07       	cpc	r27, r25
    46e0:	c9 f7       	brne	.-14     	; 0x46d4 <convertFileName+0x156>
  Filename[j] = fileNameFAT[j];

return 0;
    46e2:	80 e0       	ldi	r24, 0x00	; 0
    46e4:	03 c0       	rjmp	.+6      	; 0x46ec <convertFileName+0x16e>
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    46e6:	81 e0       	ldi	r24, 0x01	; 1
    46e8:	01 c0       	rjmp	.+2      	; 0x46ec <convertFileName+0x16e>

for(j=0; j<12; j++)
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    46ea:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];

return 0;
}
    46ec:	2b 96       	adiw	r28, 0x0b	; 11
    46ee:	cd bf       	out	0x3d, r28	; 61
    46f0:	de bf       	out	0x3e, r29	; 62
    46f2:	df 91       	pop	r29
    46f4:	cf 91       	pop	r28
    46f6:	1f 91       	pop	r17
    46f8:	0f 91       	pop	r16
    46fa:	08 95       	ret

000046fc <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    46fc:	4f 92       	push	r4
    46fe:	5f 92       	push	r5
    4700:	6f 92       	push	r6
    4702:	7f 92       	push	r7
    4704:	8f 92       	push	r8
    4706:	9f 92       	push	r9
    4708:	af 92       	push	r10
    470a:	bf 92       	push	r11
    470c:	cf 92       	push	r12
    470e:	df 92       	push	r13
    4710:	ef 92       	push	r14
    4712:	ff 92       	push	r15
    4714:	cf 93       	push	r28
    4716:	df 93       	push	r29
    4718:	2b 01       	movw	r4, r22
    471a:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    471c:	20 e8       	ldi	r18, 0x80	; 128
    471e:	3f ef       	ldi	r19, 0xFF	; 255
    4720:	4f ef       	ldi	r20, 0xFF	; 255
    4722:	5f ef       	ldi	r21, 0xFF	; 255
    4724:	42 22       	and	r4, r18
    4726:	53 22       	and	r5, r19
    4728:	64 22       	and	r6, r20
    472a:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    472c:	80 91 58 40 	lds	r24, 0x4058
    4730:	90 91 59 40 	lds	r25, 0x4059
    4734:	a0 91 5a 40 	lds	r26, 0x405A
    4738:	b0 91 5b 40 	lds	r27, 0x405B
    473c:	48 16       	cp	r4, r24
    473e:	59 06       	cpc	r5, r25
    4740:	6a 06       	cpc	r6, r26
    4742:	7b 06       	cpc	r7, r27
    4744:	08 f0       	brcs	.+2      	; 0x4748 <searchNextFreeCluster+0x4c>
    4746:	77 c0       	rjmp	.+238    	; 0x4836 <searchNextFreeCluster+0x13a>
    4748:	53 01       	movw	r10, r6
    474a:	42 01       	movw	r8, r4
    474c:	88 0c       	add	r8, r8
    474e:	99 1c       	adc	r9, r9
    4750:	aa 1c       	adc	r10, r10
    4752:	bb 1c       	adc	r11, r11
    4754:	88 0c       	add	r8, r8
    4756:	99 1c       	adc	r9, r9
    4758:	aa 1c       	adc	r10, r10
    475a:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    475c:	c8 e4       	ldi	r28, 0x48	; 72
    475e:	de e3       	ldi	r29, 0x3E	; 62
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    4760:	c0 90 6f 50 	lds	r12, 0x506F
    4764:	d0 90 70 50 	lds	r13, 0x5070
    4768:	20 91 55 40 	lds	r18, 0x4055
    476c:	30 91 56 40 	lds	r19, 0x4056
    4770:	ee 24       	eor	r14, r14
    4772:	ff 24       	eor	r15, r15
    4774:	80 91 6b 50 	lds	r24, 0x506B
    4778:	90 91 6c 50 	lds	r25, 0x506C
    477c:	a0 91 6d 50 	lds	r26, 0x506D
    4780:	b0 91 6e 50 	lds	r27, 0x506E
    4784:	c8 0e       	add	r12, r24
    4786:	d9 1e       	adc	r13, r25
    4788:	ea 1e       	adc	r14, r26
    478a:	fb 1e       	adc	r15, r27
    478c:	40 e0       	ldi	r20, 0x00	; 0
    478e:	50 e0       	ldi	r21, 0x00	; 0
    4790:	c5 01       	movw	r24, r10
    4792:	b4 01       	movw	r22, r8
    4794:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    4798:	c7 01       	movw	r24, r14
    479a:	b6 01       	movw	r22, r12
    479c:	62 0f       	add	r22, r18
    479e:	73 1f       	adc	r23, r19
    47a0:	84 1f       	adc	r24, r20
    47a2:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    47a4:	ae 01       	movw	r20, r28
    47a6:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    47aa:	88 81       	ld	r24, Y
    47ac:	99 81       	ldd	r25, Y+1	; 0x01
    47ae:	aa 81       	ldd	r26, Y+2	; 0x02
    47b0:	bb 81       	ldd	r27, Y+3	; 0x03
    47b2:	bf 70       	andi	r27, 0x0F	; 15
    47b4:	00 97       	sbiw	r24, 0x00	; 0
    47b6:	a1 05       	cpc	r26, r1
    47b8:	b1 05       	cpc	r27, r1
    47ba:	99 f0       	breq	.+38     	; 0x47e2 <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    47bc:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    47be:	e2 2f       	mov	r30, r18
    47c0:	f0 e0       	ldi	r31, 0x00	; 0
    47c2:	ee 0f       	add	r30, r30
    47c4:	ff 1f       	adc	r31, r31
    47c6:	ee 0f       	add	r30, r30
    47c8:	ff 1f       	adc	r31, r31
         if(((*value) & 0x0fffffff) == 0)
    47ca:	e8 5b       	subi	r30, 0xB8	; 184
    47cc:	f1 4c       	sbci	r31, 0xC1	; 193
    47ce:	80 81       	ld	r24, Z
    47d0:	91 81       	ldd	r25, Z+1	; 0x01
    47d2:	a2 81       	ldd	r26, Z+2	; 0x02
    47d4:	b3 81       	ldd	r27, Z+3	; 0x03
    47d6:	bf 70       	andi	r27, 0x0F	; 15
    47d8:	00 97       	sbiw	r24, 0x00	; 0
    47da:	a1 05       	cpc	r26, r1
    47dc:	b1 05       	cpc	r27, r1
    47de:	39 f4       	brne	.+14     	; 0x47ee <searchNextFreeCluster+0xf2>
    47e0:	01 c0       	rjmp	.+2      	; 0x47e4 <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    47e2:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    47e4:	42 0e       	add	r4, r18
    47e6:	51 1c       	adc	r5, r1
    47e8:	61 1c       	adc	r6, r1
    47ea:	71 1c       	adc	r7, r1
    47ec:	27 c0       	rjmp	.+78     	; 0x483c <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    47ee:	2f 5f       	subi	r18, 0xFF	; 255
    47f0:	32 f7       	brpl	.-52     	; 0x47be <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    47f2:	80 e8       	ldi	r24, 0x80	; 128
    47f4:	90 e0       	ldi	r25, 0x00	; 0
    47f6:	a0 e0       	ldi	r26, 0x00	; 0
    47f8:	b0 e0       	ldi	r27, 0x00	; 0
    47fa:	48 0e       	add	r4, r24
    47fc:	59 1e       	adc	r5, r25
    47fe:	6a 1e       	adc	r6, r26
    4800:	7b 1e       	adc	r7, r27
    4802:	80 91 58 40 	lds	r24, 0x4058
    4806:	90 91 59 40 	lds	r25, 0x4059
    480a:	a0 91 5a 40 	lds	r26, 0x405A
    480e:	b0 91 5b 40 	lds	r27, 0x405B
    4812:	20 e0       	ldi	r18, 0x00	; 0
    4814:	32 e0       	ldi	r19, 0x02	; 2
    4816:	40 e0       	ldi	r20, 0x00	; 0
    4818:	50 e0       	ldi	r21, 0x00	; 0
    481a:	82 0e       	add	r8, r18
    481c:	93 1e       	adc	r9, r19
    481e:	a4 1e       	adc	r10, r20
    4820:	b5 1e       	adc	r11, r21
    4822:	48 16       	cp	r4, r24
    4824:	59 06       	cpc	r5, r25
    4826:	6a 06       	cpc	r6, r26
    4828:	7b 06       	cpc	r7, r27
    482a:	08 f4       	brcc	.+2      	; 0x482e <searchNextFreeCluster+0x132>
    482c:	99 cf       	rjmp	.-206    	; 0x4760 <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    482e:	44 24       	eor	r4, r4
    4830:	55 24       	eor	r5, r5
    4832:	32 01       	movw	r6, r4
    4834:	03 c0       	rjmp	.+6      	; 0x483c <searchNextFreeCluster+0x140>
    4836:	44 24       	eor	r4, r4
    4838:	55 24       	eor	r5, r5
    483a:	32 01       	movw	r6, r4
}
    483c:	64 2d       	mov	r22, r4
    483e:	75 2d       	mov	r23, r5
    4840:	86 2d       	mov	r24, r6
    4842:	97 2d       	mov	r25, r7
    4844:	df 91       	pop	r29
    4846:	cf 91       	pop	r28
    4848:	ff 90       	pop	r15
    484a:	ef 90       	pop	r14
    484c:	df 90       	pop	r13
    484e:	cf 90       	pop	r12
    4850:	bf 90       	pop	r11
    4852:	af 90       	pop	r10
    4854:	9f 90       	pop	r9
    4856:	8f 90       	pop	r8
    4858:	7f 90       	pop	r7
    485a:	6f 90       	pop	r6
    485c:	5f 90       	pop	r5
    485e:	4f 90       	pop	r4
    4860:	08 95       	ret

00004862 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    4862:	cf 92       	push	r12
    4864:	df 92       	push	r13
    4866:	ef 92       	push	r14
    4868:	ff 92       	push	r15
    486a:	cf 93       	push	r28
    486c:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    486e:	db 01       	movw	r26, r22
    4870:	ca 01       	movw	r24, r20
    4872:	91 70       	andi	r25, 0x01	; 1
    4874:	a0 70       	andi	r26, 0x00	; 0
    4876:	b0 70       	andi	r27, 0x00	; 0
    4878:	00 97       	sbiw	r24, 0x00	; 0
    487a:	a1 05       	cpc	r26, r1
    487c:	b1 05       	cpc	r27, r1
    487e:	51 f4       	brne	.+20     	; 0x4894 <freeMemoryUpdate+0x32>
    4880:	03 2e       	mov	r0, r19
    4882:	39 e0       	ldi	r19, 0x09	; 9
    4884:	76 95       	lsr	r23
    4886:	67 95       	ror	r22
    4888:	57 95       	ror	r21
    488a:	47 95       	ror	r20
    488c:	3a 95       	dec	r19
    488e:	d1 f7       	brne	.-12     	; 0x4884 <freeMemoryUpdate+0x22>
    4890:	30 2d       	mov	r19, r0
    4892:	0d c0       	rjmp	.+26     	; 0x48ae <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    4894:	03 2e       	mov	r0, r19
    4896:	39 e0       	ldi	r19, 0x09	; 9
    4898:	76 95       	lsr	r23
    489a:	67 95       	ror	r22
    489c:	57 95       	ror	r21
    489e:	47 95       	ror	r20
    48a0:	3a 95       	dec	r19
    48a2:	d1 f7       	brne	.-12     	; 0x4898 <freeMemoryUpdate+0x36>
    48a4:	30 2d       	mov	r19, r0
    48a6:	4f 5f       	subi	r20, 0xFF	; 255
    48a8:	5f 4f       	sbci	r21, 0xFF	; 255
    48aa:	6f 4f       	sbci	r22, 0xFF	; 255
    48ac:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    48ae:	db 01       	movw	r26, r22
    48b0:	ca 01       	movw	r24, r20
    48b2:	87 70       	andi	r24, 0x07	; 7
    48b4:	90 70       	andi	r25, 0x00	; 0
    48b6:	a0 70       	andi	r26, 0x00	; 0
    48b8:	b0 70       	andi	r27, 0x00	; 0
    48ba:	00 97       	sbiw	r24, 0x00	; 0
    48bc:	a1 05       	cpc	r26, r1
    48be:	b1 05       	cpc	r27, r1
    48c0:	59 f4       	brne	.+22     	; 0x48d8 <freeMemoryUpdate+0x76>
    48c2:	6a 01       	movw	r12, r20
    48c4:	7b 01       	movw	r14, r22
    48c6:	68 94       	set
    48c8:	12 f8       	bld	r1, 2
    48ca:	f6 94       	lsr	r15
    48cc:	e7 94       	ror	r14
    48ce:	d7 94       	ror	r13
    48d0:	c7 94       	ror	r12
    48d2:	16 94       	lsr	r1
    48d4:	d1 f7       	brne	.-12     	; 0x48ca <freeMemoryUpdate+0x68>
    48d6:	0f c0       	rjmp	.+30     	; 0x48f6 <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    48d8:	6a 01       	movw	r12, r20
    48da:	7b 01       	movw	r14, r22
    48dc:	68 94       	set
    48de:	12 f8       	bld	r1, 2
    48e0:	f6 94       	lsr	r15
    48e2:	e7 94       	ror	r14
    48e4:	d7 94       	ror	r13
    48e6:	c7 94       	ror	r12
    48e8:	16 94       	lsr	r1
    48ea:	d1 f7       	brne	.-12     	; 0x48e0 <freeMemoryUpdate+0x7e>
    48ec:	08 94       	sec
    48ee:	c1 1c       	adc	r12, r1
    48f0:	d1 1c       	adc	r13, r1
    48f2:	e1 1c       	adc	r14, r1
    48f4:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    48f6:	80 91 a1 50 	lds	r24, 0x50A1
    48fa:	88 23       	and	r24, r24
    48fc:	d1 f0       	breq	.+52     	; 0x4932 <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    48fe:	81 e0       	ldi	r24, 0x01	; 1
    4900:	60 e0       	ldi	r22, 0x00	; 0
    4902:	20 e0       	ldi	r18, 0x00	; 0
    4904:	30 e0       	ldi	r19, 0x00	; 0
    4906:	a9 01       	movw	r20, r18
    4908:	0e 94 32 21 	call	0x4264	; 0x4264 <getSetFreeCluster>
	if(flag == ADD)
    490c:	cc 23       	and	r28, r28
    490e:	39 f4       	brne	.+14     	; 0x491e <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    4910:	9b 01       	movw	r18, r22
    4912:	ac 01       	movw	r20, r24
    4914:	2c 0d       	add	r18, r12
    4916:	3d 1d       	adc	r19, r13
    4918:	4e 1d       	adc	r20, r14
    491a:	5f 1d       	adc	r21, r15
    491c:	06 c0       	rjmp	.+12     	; 0x492a <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    491e:	9b 01       	movw	r18, r22
    4920:	ac 01       	movw	r20, r24
    4922:	2c 19       	sub	r18, r12
    4924:	3d 09       	sbc	r19, r13
    4926:	4e 09       	sbc	r20, r14
    4928:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    492a:	81 e0       	ldi	r24, 0x01	; 1
    492c:	61 e0       	ldi	r22, 0x01	; 1
    492e:	0e 94 32 21 	call	0x4264	; 0x4264 <getSetFreeCluster>
  }
}
    4932:	cf 91       	pop	r28
    4934:	ff 90       	pop	r15
    4936:	ef 90       	pop	r14
    4938:	df 90       	pop	r13
    493a:	cf 90       	pop	r12
    493c:	08 95       	ret

0000493e <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    493e:	2f 92       	push	r2
    4940:	3f 92       	push	r3
    4942:	4f 92       	push	r4
    4944:	5f 92       	push	r5
    4946:	6f 92       	push	r6
    4948:	7f 92       	push	r7
    494a:	8f 92       	push	r8
    494c:	9f 92       	push	r9
    494e:	af 92       	push	r10
    4950:	bf 92       	push	r11
    4952:	cf 92       	push	r12
    4954:	df 92       	push	r13
    4956:	ef 92       	push	r14
    4958:	ff 92       	push	r15
    495a:	0f 93       	push	r16
    495c:	1f 93       	push	r17
    495e:	cf 93       	push	r28
    4960:	df 93       	push	r29
    4962:	cd b7       	in	r28, 0x3d	; 61
    4964:	de b7       	in	r29, 0x3e	; 62
    4966:	2c 97       	sbiw	r28, 0x0c	; 12
    4968:	cd bf       	out	0x3d, r28	; 61
    496a:	de bf       	out	0x3e, r29	; 62
    496c:	88 2e       	mov	r8, r24
    496e:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    4970:	80 91 5d 40 	lds	r24, 0x405D
    4974:	90 91 5e 40 	lds	r25, 0x405E
    4978:	a0 91 5f 40 	lds	r26, 0x405F
    497c:	b0 91 60 40 	lds	r27, 0x4060
    4980:	89 87       	std	Y+9, r24	; 0x09
    4982:	9a 87       	std	Y+10, r25	; 0x0a
    4984:	ab 87       	std	Y+11, r26	; 0x0b
    4986:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4988:	0f 2e       	mov	r0, r31
    498a:	f8 e4       	ldi	r31, 0x48	; 72
    498c:	2f 2e       	mov	r2, r31
    498e:	fe e3       	ldi	r31, 0x3E	; 62
    4990:	3f 2e       	mov	r3, r31
    4992:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4994:	c8 2c       	mov	r12, r8
    4996:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4998:	d2 2c       	mov	r13, r2
    499a:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    499c:	5b 01       	movw	r10, r22
    499e:	08 94       	sec
    49a0:	a1 1c       	adc	r10, r1
    49a2:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    49a4:	69 85       	ldd	r22, Y+9	; 0x09
    49a6:	7a 85       	ldd	r23, Y+10	; 0x0a
    49a8:	8b 85       	ldd	r24, Y+11	; 0x0b
    49aa:	9c 85       	ldd	r25, Y+12	; 0x0c
    49ac:	0e 94 79 20 	call	0x40f2	; 0x40f2 <getFirstSector>
    49b0:	6d 83       	std	Y+5, r22	; 0x05
    49b2:	7e 83       	std	Y+6, r23	; 0x06
    49b4:	8f 83       	std	Y+7, r24	; 0x07
    49b6:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    49b8:	80 91 69 50 	lds	r24, 0x5069
    49bc:	90 91 6a 50 	lds	r25, 0x506A
    49c0:	00 97       	sbiw	r24, 0x00	; 0
    49c2:	09 f4       	brne	.+2      	; 0x49c6 <findFiles+0x88>
    49c4:	13 c1       	rjmp	.+550    	; 0x4bec <findFiles+0x2ae>
    49c6:	44 24       	eor	r4, r4
    49c8:	55 24       	eor	r5, r5
    49ca:	32 01       	movw	r6, r4
    49cc:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    49ce:	8d 81       	ldd	r24, Y+5	; 0x05
    49d0:	9e 81       	ldd	r25, Y+6	; 0x06
    49d2:	af 81       	ldd	r26, Y+7	; 0x07
    49d4:	b8 85       	ldd	r27, Y+8	; 0x08
    49d6:	84 0d       	add	r24, r4
    49d8:	95 1d       	adc	r25, r5
    49da:	a6 1d       	adc	r26, r6
    49dc:	b7 1d       	adc	r27, r7
    49de:	89 83       	std	Y+1, r24	; 0x01
    49e0:	9a 83       	std	Y+2, r25	; 0x02
    49e2:	ab 83       	std	Y+3, r26	; 0x03
    49e4:	bc 83       	std	Y+4, r27	; 0x04
    49e6:	bc 01       	movw	r22, r24
    49e8:	cd 01       	movw	r24, r26
    49ea:	4d 2d       	mov	r20, r13
    49ec:	59 2d       	mov	r21, r9
    49ee:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    49f2:	80 91 55 40 	lds	r24, 0x4055
    49f6:	90 91 56 40 	lds	r25, 0x4056
    49fa:	00 97       	sbiw	r24, 0x00	; 0
    49fc:	09 f4       	brne	.+2      	; 0x4a00 <findFiles+0xc2>
    49fe:	e4 c0       	rjmp	.+456    	; 0x4bc8 <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4a00:	d1 01       	movw	r26, r2
    4a02:	8c 91       	ld	r24, X
    4a04:	88 23       	and	r24, r24
    4a06:	09 f4       	brne	.+2      	; 0x4a0a <findFiles+0xcc>
    4a08:	10 c1       	rjmp	.+544    	; 0x4c2a <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4a0a:	4d 2d       	mov	r20, r13
    4a0c:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4a0e:	20 e0       	ldi	r18, 0x00	; 0
    4a10:	30 e0       	ldi	r19, 0x00	; 0
    4a12:	08 c0       	rjmp	.+16     	; 0x4a24 <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4a14:	a9 01       	movw	r20, r18
    4a16:	48 5b       	subi	r20, 0xB8	; 184
    4a18:	51 4c       	sbci	r21, 0xC1	; 193

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4a1a:	fa 01       	movw	r30, r20
    4a1c:	80 81       	ld	r24, Z
    4a1e:	88 23       	and	r24, r24
    4a20:	09 f4       	brne	.+2      	; 0x4a24 <findFiles+0xe6>
    4a22:	06 c1       	rjmp	.+524    	; 0x4c30 <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    4a24:	85 3e       	cpi	r24, 0xE5	; 229
    4a26:	09 f4       	brne	.+2      	; 0x4a2a <findFiles+0xec>
    4a28:	c5 c0       	rjmp	.+394    	; 0x4bb4 <findFiles+0x276>
    4a2a:	da 01       	movw	r26, r20
    4a2c:	1b 96       	adiw	r26, 0x0b	; 11
    4a2e:	8c 91       	ld	r24, X
    4a30:	1b 97       	sbiw	r26, 0x0b	; 11
    4a32:	8f 30       	cpi	r24, 0x0F	; 15
    4a34:	09 f4       	brne	.+2      	; 0x4a38 <findFiles+0xfa>
    4a36:	be c0       	rjmp	.+380    	; 0x4bb4 <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4a38:	12 30       	cpi	r17, 0x02	; 2
    4a3a:	08 f0       	brcs	.+2      	; 0x4a3e <findFiles+0x100>
    4a3c:	fc c0       	rjmp	.+504    	; 0x4c36 <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    4a3e:	9c 91       	ld	r25, X
    4a40:	f7 01       	movw	r30, r14
    4a42:	80 81       	ld	r24, Z
    4a44:	98 17       	cp	r25, r24
    4a46:	09 f0       	breq	.+2      	; 0x4a4a <findFiles+0x10c>
    4a48:	b5 c0       	rjmp	.+362    	; 0x4bb4 <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4a4a:	fa 01       	movw	r30, r20
    4a4c:	31 96       	adiw	r30, 0x01	; 1
    4a4e:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4a50:	81 e0       	ldi	r24, 0x01	; 1
    4a52:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    4a54:	41 91       	ld	r20, Z+
    4a56:	9d 91       	ld	r25, X+
    4a58:	49 17       	cp	r20, r25
    4a5a:	31 f4       	brne	.+12     	; 0x4a68 <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    4a5c:	8f 5f       	subi	r24, 0xFF	; 255
    4a5e:	8b 30       	cpi	r24, 0x0B	; 11
    4a60:	c9 f7       	brne	.-14     	; 0x4a54 <findFiles+0x116>
    4a62:	8b 01       	movw	r16, r22
    4a64:	6b 01       	movw	r12, r22
    4a66:	05 c0       	rjmp	.+10     	; 0x4a72 <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    4a68:	8b 30       	cpi	r24, 0x0B	; 11
    4a6a:	09 f0       	breq	.+2      	; 0x4a6e <findFiles+0x130>
    4a6c:	a3 c0       	rjmp	.+326    	; 0x4bb4 <findFiles+0x276>
    4a6e:	8b 01       	movw	r16, r22
    4a70:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    4a72:	f1 e0       	ldi	r31, 0x01	; 1
    4a74:	8f 16       	cp	r8, r31
    4a76:	09 f0       	breq	.+2      	; 0x4a7a <findFiles+0x13c>
    4a78:	41 c0       	rjmp	.+130    	; 0x4afc <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    4a7a:	89 81       	ldd	r24, Y+1	; 0x01
    4a7c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a7e:	ab 81       	ldd	r26, Y+3	; 0x03
    4a80:	bc 81       	ldd	r27, Y+4	; 0x04
    4a82:	80 93 a2 50 	sts	0x50A2, r24
    4a86:	90 93 a3 50 	sts	0x50A3, r25
    4a8a:	a0 93 a4 50 	sts	0x50A4, r26
    4a8e:	b0 93 a5 50 	sts	0x50A5, r27
				appendFileLocation = i;
    4a92:	c9 01       	movw	r24, r18
    4a94:	a0 e0       	ldi	r26, 0x00	; 0
    4a96:	b0 e0       	ldi	r27, 0x00	; 0
    4a98:	80 93 49 40 	sts	0x4049, r24
    4a9c:	90 93 4a 40 	sts	0x404A, r25
    4aa0:	a0 93 4b 40 	sts	0x404B, r26
    4aa4:	b0 93 4c 40 	sts	0x404C, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4aa8:	d6 01       	movw	r26, r12
    4aaa:	54 96       	adiw	r26, 0x14	; 20
    4aac:	4d 91       	ld	r20, X+
    4aae:	5c 91       	ld	r21, X
    4ab0:	55 97       	sbiw	r26, 0x15	; 21
    4ab2:	60 e0       	ldi	r22, 0x00	; 0
    4ab4:	70 e0       	ldi	r23, 0x00	; 0
    4ab6:	ba 01       	movw	r22, r20
    4ab8:	55 27       	eor	r21, r21
    4aba:	44 27       	eor	r20, r20
    4abc:	5a 96       	adiw	r26, 0x1a	; 26
    4abe:	8d 91       	ld	r24, X+
    4ac0:	9c 91       	ld	r25, X
    4ac2:	5b 97       	sbiw	r26, 0x1b	; 27
    4ac4:	a0 e0       	ldi	r26, 0x00	; 0
    4ac6:	b0 e0       	ldi	r27, 0x00	; 0
    4ac8:	84 2b       	or	r24, r20
    4aca:	95 2b       	or	r25, r21
    4acc:	a6 2b       	or	r26, r22
    4ace:	b7 2b       	or	r27, r23
    4ad0:	80 93 73 50 	sts	0x5073, r24
    4ad4:	90 93 74 50 	sts	0x5074, r25
    4ad8:	a0 93 75 50 	sts	0x5075, r26
    4adc:	b0 93 76 50 	sts	0x5076, r27
				fileSize = dir->fileSize;
    4ae0:	f6 01       	movw	r30, r12
    4ae2:	84 8d       	ldd	r24, Z+28	; 0x1c
    4ae4:	95 8d       	ldd	r25, Z+29	; 0x1d
    4ae6:	a6 8d       	ldd	r26, Z+30	; 0x1e
    4ae8:	b7 8d       	ldd	r27, Z+31	; 0x1f
    4aea:	80 93 51 40 	sts	0x4051, r24
    4aee:	90 93 52 40 	sts	0x4052, r25
    4af2:	a0 93 53 40 	sts	0x4053, r26
    4af6:	b0 93 54 40 	sts	0x4054, r27
			    return (dir);
    4afa:	a5 c0       	rjmp	.+330    	; 0x4c46 <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4afc:	d6 01       	movw	r26, r12
    4afe:	54 96       	adiw	r26, 0x14	; 20
    4b00:	8d 91       	ld	r24, X+
    4b02:	9c 91       	ld	r25, X
    4b04:	55 97       	sbiw	r26, 0x15	; 21
    4b06:	a0 e0       	ldi	r26, 0x00	; 0
    4b08:	b0 e0       	ldi	r27, 0x00	; 0
    4b0a:	3c 01       	movw	r6, r24
    4b0c:	55 24       	eor	r5, r5
    4b0e:	44 24       	eor	r4, r4
    4b10:	f6 01       	movw	r30, r12
    4b12:	82 8d       	ldd	r24, Z+26	; 0x1a
    4b14:	93 8d       	ldd	r25, Z+27	; 0x1b
    4b16:	a0 e0       	ldi	r26, 0x00	; 0
    4b18:	b0 e0       	ldi	r27, 0x00	; 0
    4b1a:	48 2a       	or	r4, r24
    4b1c:	59 2a       	or	r5, r25
    4b1e:	6a 2a       	or	r6, r26
    4b20:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    4b22:	85 ee       	ldi	r24, 0xE5	; 229
    4b24:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    4b26:	69 81       	ldd	r22, Y+1	; 0x01
    4b28:	7a 81       	ldd	r23, Y+2	; 0x02
    4b2a:	8b 81       	ldd	r24, Y+3	; 0x03
    4b2c:	9c 81       	ldd	r25, Y+4	; 0x04
    4b2e:	48 e4       	ldi	r20, 0x48	; 72
    4b30:	5e e3       	ldi	r21, 0x3E	; 62
    4b32:	20 e0       	ldi	r18, 0x00	; 0
    4b34:	32 e0       	ldi	r19, 0x02	; 2
    4b36:	0e 94 ca 2a 	call	0x5594	; 0x5594 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    4b3a:	d6 01       	movw	r26, r12
    4b3c:	5c 96       	adiw	r26, 0x1c	; 28
    4b3e:	4d 91       	ld	r20, X+
    4b40:	5d 91       	ld	r21, X+
    4b42:	6d 91       	ld	r22, X+
    4b44:	7c 91       	ld	r23, X
    4b46:	5f 97       	sbiw	r26, 0x1f	; 31
    4b48:	80 e0       	ldi	r24, 0x00	; 0
    4b4a:	0e 94 31 24 	call	0x4862	; 0x4862 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    4b4e:	82 e0       	ldi	r24, 0x02	; 2
    4b50:	60 e0       	ldi	r22, 0x00	; 0
    4b52:	20 e0       	ldi	r18, 0x00	; 0
    4b54:	30 e0       	ldi	r19, 0x00	; 0
    4b56:	a9 01       	movw	r20, r18
    4b58:	0e 94 32 21 	call	0x4264	; 0x4264 <getSetFreeCluster>
    4b5c:	dc 01       	movw	r26, r24
    4b5e:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    4b60:	48 16       	cp	r4, r24
    4b62:	59 06       	cpc	r5, r25
    4b64:	6a 06       	cpc	r6, r26
    4b66:	7b 06       	cpc	r7, r27
    4b68:	30 f4       	brcc	.+12     	; 0x4b76 <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    4b6a:	82 e0       	ldi	r24, 0x02	; 2
    4b6c:	61 e0       	ldi	r22, 0x01	; 1
    4b6e:	a3 01       	movw	r20, r6
    4b70:	92 01       	movw	r18, r4
    4b72:	0e 94 32 21 	call	0x4264	; 0x4264 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    4b76:	c3 01       	movw	r24, r6
    4b78:	b2 01       	movw	r22, r4
    4b7a:	40 e0       	ldi	r20, 0x00	; 0
    4b7c:	00 e0       	ldi	r16, 0x00	; 0
    4b7e:	10 e0       	ldi	r17, 0x00	; 0
    4b80:	98 01       	movw	r18, r16
    4b82:	0e 94 a0 20 	call	0x4140	; 0x4140 <getSetNextCluster>
    4b86:	6b 01       	movw	r12, r22
    4b88:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    4b8a:	c3 01       	movw	r24, r6
    4b8c:	b2 01       	movw	r22, r4
    4b8e:	41 e0       	ldi	r20, 0x01	; 1
    4b90:	00 e0       	ldi	r16, 0x00	; 0
    4b92:	10 e0       	ldi	r17, 0x00	; 0
    4b94:	98 01       	movw	r18, r16
    4b96:	0e 94 a0 20 	call	0x4140	; 0x4140 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    4b9a:	b7 ef       	ldi	r27, 0xF7	; 247
    4b9c:	cb 16       	cp	r12, r27
    4b9e:	bf ef       	ldi	r27, 0xFF	; 255
    4ba0:	db 06       	cpc	r13, r27
    4ba2:	bf ef       	ldi	r27, 0xFF	; 255
    4ba4:	eb 06       	cpc	r14, r27
    4ba6:	bf e0       	ldi	r27, 0x0F	; 15
    4ba8:	fb 06       	cpc	r15, r27
    4baa:	08 f0       	brcs	.+2      	; 0x4bae <findFiles+0x270>
    4bac:	47 c0       	rjmp	.+142    	; 0x4c3c <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    4bae:	26 01       	movw	r4, r12
    4bb0:	37 01       	movw	r6, r14
    4bb2:	e1 cf       	rjmp	.-62     	; 0x4b76 <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4bb4:	20 5e       	subi	r18, 0xE0	; 224
    4bb6:	3f 4f       	sbci	r19, 0xFF	; 255
    4bb8:	80 91 55 40 	lds	r24, 0x4055
    4bbc:	90 91 56 40 	lds	r25, 0x4056
    4bc0:	28 17       	cp	r18, r24
    4bc2:	39 07       	cpc	r19, r25
    4bc4:	08 f4       	brcc	.+2      	; 0x4bc8 <findFiles+0x28a>
    4bc6:	26 cf       	rjmp	.-436    	; 0x4a14 <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    4bc8:	08 94       	sec
    4bca:	41 1c       	adc	r4, r1
    4bcc:	51 1c       	adc	r5, r1
    4bce:	61 1c       	adc	r6, r1
    4bd0:	71 1c       	adc	r7, r1
    4bd2:	80 91 69 50 	lds	r24, 0x5069
    4bd6:	90 91 6a 50 	lds	r25, 0x506A
    4bda:	a0 e0       	ldi	r26, 0x00	; 0
    4bdc:	b0 e0       	ldi	r27, 0x00	; 0
    4bde:	48 16       	cp	r4, r24
    4be0:	59 06       	cpc	r5, r25
    4be2:	6a 06       	cpc	r6, r26
    4be4:	7b 06       	cpc	r7, r27
    4be6:	08 f4       	brcc	.+2      	; 0x4bea <findFiles+0x2ac>
    4be8:	f2 ce       	rjmp	.-540    	; 0x49ce <findFiles+0x90>
    4bea:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    4bec:	69 85       	ldd	r22, Y+9	; 0x09
    4bee:	7a 85       	ldd	r23, Y+10	; 0x0a
    4bf0:	8b 85       	ldd	r24, Y+11	; 0x0b
    4bf2:	9c 85       	ldd	r25, Y+12	; 0x0c
    4bf4:	40 e0       	ldi	r20, 0x00	; 0
    4bf6:	00 e0       	ldi	r16, 0x00	; 0
    4bf8:	10 e0       	ldi	r17, 0x00	; 0
    4bfa:	98 01       	movw	r18, r16
    4bfc:	0e 94 a0 20 	call	0x4140	; 0x4140 <getSetNextCluster>
    4c00:	69 87       	std	Y+9, r22	; 0x09
    4c02:	7a 87       	std	Y+10, r23	; 0x0a
    4c04:	8b 87       	std	Y+11, r24	; 0x0b
    4c06:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    4c08:	67 3f       	cpi	r22, 0xF7	; 247
    4c0a:	ef ef       	ldi	r30, 0xFF	; 255
    4c0c:	7e 07       	cpc	r23, r30
    4c0e:	ef ef       	ldi	r30, 0xFF	; 255
    4c10:	8e 07       	cpc	r24, r30
    4c12:	ef e0       	ldi	r30, 0x0F	; 15
    4c14:	9e 07       	cpc	r25, r30
    4c16:	a8 f4       	brcc	.+42     	; 0x4c42 <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    4c18:	61 15       	cp	r22, r1
    4c1a:	71 05       	cpc	r23, r1
    4c1c:	81 05       	cpc	r24, r1
    4c1e:	91 05       	cpc	r25, r1
    4c20:	09 f0       	breq	.+2      	; 0x4c24 <findFiles+0x2e6>
    4c22:	c0 ce       	rjmp	.-640    	; 0x49a4 <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    4c24:	00 e0       	ldi	r16, 0x00	; 0
    4c26:	10 e0       	ldi	r17, 0x00	; 0
    4c28:	0e c0       	rjmp	.+28     	; 0x4c46 <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    4c2a:	00 e0       	ldi	r16, 0x00	; 0
    4c2c:	10 e0       	ldi	r17, 0x00	; 0
    4c2e:	0b c0       	rjmp	.+22     	; 0x4c46 <findFiles+0x308>
    4c30:	00 e0       	ldi	r16, 0x00	; 0
    4c32:	10 e0       	ldi	r17, 0x00	; 0
    4c34:	08 c0       	rjmp	.+16     	; 0x4c46 <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    4c36:	00 e0       	ldi	r16, 0x00	; 0
    4c38:	10 e0       	ldi	r17, 0x00	; 0
    4c3a:	05 c0       	rjmp	.+10     	; 0x4c46 <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    4c3c:	00 e0       	ldi	r16, 0x00	; 0
    4c3e:	10 e0       	ldi	r17, 0x00	; 0
    4c40:	02 c0       	rjmp	.+4      	; 0x4c46 <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    4c42:	00 e0       	ldi	r16, 0x00	; 0
    4c44:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    4c46:	80 2f       	mov	r24, r16
    4c48:	91 2f       	mov	r25, r17
    4c4a:	2c 96       	adiw	r28, 0x0c	; 12
    4c4c:	cd bf       	out	0x3d, r28	; 61
    4c4e:	de bf       	out	0x3e, r29	; 62
    4c50:	df 91       	pop	r29
    4c52:	cf 91       	pop	r28
    4c54:	1f 91       	pop	r17
    4c56:	0f 91       	pop	r16
    4c58:	ff 90       	pop	r15
    4c5a:	ef 90       	pop	r14
    4c5c:	df 90       	pop	r13
    4c5e:	cf 90       	pop	r12
    4c60:	bf 90       	pop	r11
    4c62:	af 90       	pop	r10
    4c64:	9f 90       	pop	r9
    4c66:	8f 90       	pop	r8
    4c68:	7f 90       	pop	r7
    4c6a:	6f 90       	pop	r6
    4c6c:	5f 90       	pop	r5
    4c6e:	4f 90       	pop	r4
    4c70:	3f 90       	pop	r3
    4c72:	2f 90       	pop	r2
    4c74:	08 95       	ret

00004c76 <deleteFile>:
//********************************************************************
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
    4c76:	0e 94 bf 22 	call	0x457e	; 0x457e <convertFileName>
  if(error) return;
    4c7a:	88 23       	and	r24, r24
    4c7c:	29 f4       	brne	.+10     	; 0x4c88 <deleteFile+0x12>

  findFiles (DELETE, Filename);
    4c7e:	82 e0       	ldi	r24, 0x02	; 2
    4c80:	61 e9       	ldi	r22, 0x91	; 145
    4c82:	70 e5       	ldi	r23, 0x50	; 80
    4c84:	0e 94 9f 24 	call	0x493e	; 0x493e <findFiles>
    4c88:	08 95       	ret

00004c8a <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    4c8a:	4f 92       	push	r4
    4c8c:	5f 92       	push	r5
    4c8e:	6f 92       	push	r6
    4c90:	7f 92       	push	r7
    4c92:	af 92       	push	r10
    4c94:	bf 92       	push	r11
    4c96:	cf 92       	push	r12
    4c98:	df 92       	push	r13
    4c9a:	ef 92       	push	r14
    4c9c:	ff 92       	push	r15
    4c9e:	0f 93       	push	r16
    4ca0:	1f 93       	push	r17
    4ca2:	cf 93       	push	r28
    4ca4:	c8 2f       	mov	r28, r24
    4ca6:	cb 01       	movw	r24, r22
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    4ca8:	0e 94 bf 22 	call	0x457e	; 0x457e <convertFileName>
if(error) return 2;
    4cac:	88 23       	and	r24, r24
    4cae:	09 f0       	breq	.+2      	; 0x4cb2 <readFile+0x28>
    4cb0:	57 c0       	rjmp	.+174    	; 0x4d60 <readFile+0xd6>

dir = findFiles (GET_FILE, Filename); //get the file location
    4cb2:	81 e0       	ldi	r24, 0x01	; 1
    4cb4:	61 e9       	ldi	r22, 0x91	; 145
    4cb6:	70 e5       	ldi	r23, 0x50	; 80
    4cb8:	0e 94 9f 24 	call	0x493e	; 0x493e <findFiles>
    4cbc:	fc 01       	movw	r30, r24
if(dir == 0) 
    4cbe:	00 97       	sbiw	r24, 0x00	; 0
    4cc0:	31 f4       	brne	.+12     	; 0x4cce <readFile+0x44>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4cc2:	81 e0       	ldi	r24, 0x01	; 1
    4cc4:	cc 23       	and	r28, r28
    4cc6:	09 f4       	brne	.+2      	; 0x4cca <readFile+0x40>
    4cc8:	4e c0       	rjmp	.+156    	; 0x4d66 <readFile+0xdc>
    4cca:	80 e0       	ldi	r24, 0x00	; 0
    4ccc:	4c c0       	rjmp	.+152    	; 0x4d66 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4cce:	c1 30       	cpi	r28, 0x01	; 1
    4cd0:	09 f4       	brne	.+2      	; 0x4cd4 <readFile+0x4a>
    4cd2:	48 c0       	rjmp	.+144    	; 0x4d64 <readFile+0xda>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4cd4:	44 88       	ldd	r4, Z+20	; 0x14
    4cd6:	55 88       	ldd	r5, Z+21	; 0x15
    4cd8:	66 24       	eor	r6, r6
    4cda:	77 24       	eor	r7, r7
    4cdc:	32 01       	movw	r6, r4
    4cde:	55 24       	eor	r5, r5
    4ce0:	44 24       	eor	r4, r4
    4ce2:	82 8d       	ldd	r24, Z+26	; 0x1a
    4ce4:	93 8d       	ldd	r25, Z+27	; 0x1b
    4ce6:	a0 e0       	ldi	r26, 0x00	; 0
    4ce8:	b0 e0       	ldi	r27, 0x00	; 0
    4cea:	48 2a       	or	r4, r24
    4cec:	59 2a       	or	r5, r25
    4cee:	6a 2a       	or	r6, r26
    4cf0:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4cf2:	0f 2e       	mov	r0, r31
    4cf4:	fc ea       	ldi	r31, 0xAC	; 172
    4cf6:	af 2e       	mov	r10, r31
    4cf8:	f1 e2       	ldi	r31, 0x21	; 33
    4cfa:	bf 2e       	mov	r11, r31
    4cfc:	f0 2d       	mov	r31, r0
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    4cfe:	c3 01       	movw	r24, r6
    4d00:	b2 01       	movw	r22, r4
    4d02:	0e 94 79 20 	call	0x40f2	; 0x40f2 <getFirstSector>
    4d06:	6b 01       	movw	r12, r22
    4d08:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    4d0a:	80 91 69 50 	lds	r24, 0x5069
    4d0e:	90 91 6a 50 	lds	r25, 0x506A
    4d12:	00 97       	sbiw	r24, 0x00	; 0
    4d14:	a1 f0       	breq	.+40     	; 0x4d3e <readFile+0xb4>
    4d16:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4d18:	c7 01       	movw	r24, r14
    4d1a:	b6 01       	movw	r22, r12
    4d1c:	6c 0f       	add	r22, r28
    4d1e:	71 1d       	adc	r23, r1
    4d20:	81 1d       	adc	r24, r1
    4d22:	91 1d       	adc	r25, r1
    4d24:	a5 01       	movw	r20, r10
    4d26:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    4d2a:	cf 5f       	subi	r28, 0xFF	; 255
    4d2c:	80 91 69 50 	lds	r24, 0x5069
    4d30:	90 91 6a 50 	lds	r25, 0x506A
    4d34:	2c 2f       	mov	r18, r28
    4d36:	30 e0       	ldi	r19, 0x00	; 0
    4d38:	28 17       	cp	r18, r24
    4d3a:	39 07       	cpc	r19, r25
    4d3c:	68 f3       	brcs	.-38     	; 0x4d18 <readFile+0x8e>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    4d3e:	c3 01       	movw	r24, r6
    4d40:	b2 01       	movw	r22, r4
    4d42:	40 e0       	ldi	r20, 0x00	; 0
    4d44:	00 e0       	ldi	r16, 0x00	; 0
    4d46:	10 e0       	ldi	r17, 0x00	; 0
    4d48:	98 01       	movw	r18, r16
    4d4a:	0e 94 a0 20 	call	0x4140	; 0x4140 <getSetNextCluster>
    4d4e:	2b 01       	movw	r4, r22
    4d50:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    4d52:	61 15       	cp	r22, r1
    4d54:	71 05       	cpc	r23, r1
    4d56:	81 05       	cpc	r24, r1
    4d58:	91 05       	cpc	r25, r1
    4d5a:	89 f6       	brne	.-94     	; 0x4cfe <readFile+0x74>
	  return 0;}
    4d5c:	80 e0       	ldi	r24, 0x00	; 0
    4d5e:	03 c0       	rjmp	.+6      	; 0x4d66 <readFile+0xdc>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4d60:	82 e0       	ldi	r24, 0x02	; 2
    4d62:	01 c0       	rjmp	.+2      	; 0x4d66 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4d64:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    4d66:	cf 91       	pop	r28
    4d68:	1f 91       	pop	r17
    4d6a:	0f 91       	pop	r16
    4d6c:	ff 90       	pop	r15
    4d6e:	ef 90       	pop	r14
    4d70:	df 90       	pop	r13
    4d72:	cf 90       	pop	r12
    4d74:	bf 90       	pop	r11
    4d76:	af 90       	pop	r10
    4d78:	7f 90       	pop	r7
    4d7a:	6f 90       	pop	r6
    4d7c:	5f 90       	pop	r5
    4d7e:	4f 90       	pop	r4
    4d80:	08 95       	ret

00004d82 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4d82:	2f 92       	push	r2
    4d84:	3f 92       	push	r3
    4d86:	4f 92       	push	r4
    4d88:	5f 92       	push	r5
    4d8a:	6f 92       	push	r6
    4d8c:	7f 92       	push	r7
    4d8e:	8f 92       	push	r8
    4d90:	9f 92       	push	r9
    4d92:	af 92       	push	r10
    4d94:	bf 92       	push	r11
    4d96:	cf 92       	push	r12
    4d98:	df 92       	push	r13
    4d9a:	ef 92       	push	r14
    4d9c:	ff 92       	push	r15
    4d9e:	0f 93       	push	r16
    4da0:	1f 93       	push	r17
    4da2:	cf 93       	push	r28
    4da4:	df 93       	push	r29
    4da6:	cd b7       	in	r28, 0x3d	; 61
    4da8:	de b7       	in	r29, 0x3e	; 62
    4daa:	60 97       	sbiw	r28, 0x10	; 16
    4dac:	cd bf       	out	0x3d, r28	; 61
    4dae:	de bf       	out	0x3e, r29	; 62
    4db0:	fc 01       	movw	r30, r24
    4db2:	6d 83       	std	Y+5, r22	; 0x05
    4db4:	7e 83       	std	Y+6, r23	; 0x06
    4db6:	49 01       	movw	r8, r18
    4db8:	5a 01       	movw	r10, r20
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    4dba:	81 e0       	ldi	r24, 0x01	; 1
    4dbc:	bf 01       	movw	r22, r30
    4dbe:	0e 94 45 26 	call	0x4c8a	; 0x4c8a <readFile>

if(j == 1) 
    4dc2:	81 30       	cpi	r24, 0x01	; 1
    4dc4:	09 f0       	breq	.+2      	; 0x4dc8 <writeFile+0x46>
    4dc6:	7b c0       	rjmp	.+246    	; 0x4ebe <writeFile+0x13c>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    4dc8:	00 91 73 50 	lds	r16, 0x5073
    4dcc:	10 91 74 50 	lds	r17, 0x5074
    4dd0:	20 91 75 50 	lds	r18, 0x5075
    4dd4:	30 91 76 50 	lds	r19, 0x5076
    4dd8:	09 83       	std	Y+1, r16	; 0x01
    4dda:	1a 83       	std	Y+2, r17	; 0x02
    4ddc:	2b 83       	std	Y+3, r18	; 0x03
    4dde:	3c 83       	std	Y+4, r19	; 0x04
  clusterCount=0;
    4de0:	cc 24       	eor	r12, r12
    4de2:	dd 24       	eor	r13, r13
    4de4:	76 01       	movw	r14, r12
    4de6:	24 01       	movw	r4, r8
    4de8:	35 01       	movw	r6, r10
    4dea:	48 01       	movw	r8, r16
    4dec:	59 01       	movw	r10, r18
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    4dee:	c5 01       	movw	r24, r10
    4df0:	b4 01       	movw	r22, r8
    4df2:	40 e0       	ldi	r20, 0x00	; 0
    4df4:	00 e0       	ldi	r16, 0x00	; 0
    4df6:	10 e0       	ldi	r17, 0x00	; 0
    4df8:	98 01       	movw	r18, r16
    4dfa:	0e 94 a0 20 	call	0x4140	; 0x4140 <getSetNextCluster>
    4dfe:	dc 01       	movw	r26, r24
    4e00:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    4e02:	8f 3f       	cpi	r24, 0xFF	; 255
    4e04:	1f ef       	ldi	r17, 0xFF	; 255
    4e06:	91 07       	cpc	r25, r17
    4e08:	1f ef       	ldi	r17, 0xFF	; 255
    4e0a:	a1 07       	cpc	r26, r17
    4e0c:	1f ef       	ldi	r17, 0xFF	; 255
    4e0e:	b1 07       	cpc	r27, r17
    4e10:	41 f0       	breq	.+16     	; 0x4e22 <writeFile+0xa0>
	cluster = nextCluster;
	clusterCount++;
    4e12:	08 94       	sec
    4e14:	c1 1c       	adc	r12, r1
    4e16:	d1 1c       	adc	r13, r1
    4e18:	e1 1c       	adc	r14, r1
    4e1a:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    4e1c:	4c 01       	movw	r8, r24
    4e1e:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    4e20:	e6 cf       	rjmp	.-52     	; 0x4dee <writeFile+0x6c>
    4e22:	89 82       	std	Y+1, r8	; 0x01
    4e24:	9a 82       	std	Y+2, r9	; 0x02
    4e26:	ab 82       	std	Y+3, r10	; 0x03
    4e28:	bc 82       	std	Y+4, r11	; 0x04
    4e2a:	53 01       	movw	r10, r6
    4e2c:	42 01       	movw	r8, r4
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    4e2e:	20 91 69 50 	lds	r18, 0x5069
    4e32:	30 91 6a 50 	lds	r19, 0x506A
    4e36:	80 91 55 40 	lds	r24, 0x4055
    4e3a:	90 91 56 40 	lds	r25, 0x4056
    4e3e:	60 90 55 40 	lds	r6, 0x4055
    4e42:	70 90 56 40 	lds	r7, 0x4056
    4e46:	bc 01       	movw	r22, r24
    4e48:	80 e0       	ldi	r24, 0x00	; 0
    4e4a:	90 e0       	ldi	r25, 0x00	; 0
    4e4c:	40 e0       	ldi	r20, 0x00	; 0
    4e4e:	50 e0       	ldi	r21, 0x00	; 0
    4e50:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    4e54:	a7 01       	movw	r20, r14
    4e56:	96 01       	movw	r18, r12
    4e58:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    4e5c:	dc 01       	movw	r26, r24
    4e5e:	cb 01       	movw	r24, r22
    4e60:	40 91 51 40 	lds	r20, 0x4051
    4e64:	50 91 52 40 	lds	r21, 0x4052
    4e68:	60 91 53 40 	lds	r22, 0x4053
    4e6c:	70 91 54 40 	lds	r23, 0x4054
    4e70:	8a 01       	movw	r16, r20
    4e72:	9b 01       	movw	r18, r22
    4e74:	08 1b       	sub	r16, r24
    4e76:	19 0b       	sbc	r17, r25
    4e78:	2a 0b       	sbc	r18, r26
    4e7a:	3b 0b       	sbc	r19, r27
    4e7c:	c9 01       	movw	r24, r18
    4e7e:	b8 01       	movw	r22, r16
    4e80:	93 01       	movw	r18, r6
    4e82:	40 e0       	ldi	r20, 0x00	; 0
    4e84:	50 e0       	ldi	r21, 0x00	; 0
    4e86:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    4e8a:	02 2f       	mov	r16, r18

//start writing data here

if(start){
  start = 0;
  startBlock = getFirstSector (cluster) + sector;
    4e8c:	69 81       	ldd	r22, Y+1	; 0x01
    4e8e:	7a 81       	ldd	r23, Y+2	; 0x02
    4e90:	8b 81       	ldd	r24, Y+3	; 0x03
    4e92:	9c 81       	ldd	r25, Y+4	; 0x04
    4e94:	0e 94 79 20 	call	0x40f2	; 0x40f2 <getFirstSector>
    4e98:	dc 01       	movw	r26, r24
    4e9a:	cb 01       	movw	r24, r22
    4e9c:	20 2e       	mov	r2, r16
    4e9e:	33 24       	eor	r3, r3
    4ea0:	28 0e       	add	r2, r24
    4ea2:	39 1e       	adc	r3, r25
  SD_read_block (startBlock,SDBuffer);
    4ea4:	b1 01       	movw	r22, r2
    4ea6:	80 e0       	ldi	r24, 0x00	; 0
    4ea8:	90 e0       	ldi	r25, 0x00	; 0
    4eaa:	48 e4       	ldi	r20, 0x48	; 72
    4eac:	5e e3       	ldi	r21, 0x3E	; 62
    4eae:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <SD_read_block>
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    4eb2:	1f 86       	std	Y+15, r1	; 0x0f
    4eb4:	18 8a       	std	Y+16, r1	; 0x10
    4eb6:	19 86       	std	Y+9, r1	; 0x09
    4eb8:	1a 86       	std	Y+10, r1	; 0x0a
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    4eba:	11 e0       	ldi	r17, 0x01	; 1
    4ebc:	4c c0       	rjmp	.+152    	; 0x4f56 <writeFile+0x1d4>
}
else if(j == 2) 
    4ebe:	82 30       	cpi	r24, 0x02	; 2
    4ec0:	09 f4       	brne	.+2      	; 0x4ec4 <writeFile+0x142>
    4ec2:	0c c2       	rjmp	.+1048   	; 0x52dc <writeFile+0x55a>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    4ec4:	82 e0       	ldi	r24, 0x02	; 2
    4ec6:	60 e0       	ldi	r22, 0x00	; 0
    4ec8:	20 e0       	ldi	r18, 0x00	; 0
    4eca:	30 e0       	ldi	r19, 0x00	; 0
    4ecc:	a9 01       	movw	r20, r18
    4ece:	0e 94 32 21 	call	0x4264	; 0x4264 <getSetFreeCluster>
  if(cluster > totalClusters)
    4ed2:	00 91 58 40 	lds	r16, 0x4058
    4ed6:	10 91 59 40 	lds	r17, 0x4059
    4eda:	20 91 5a 40 	lds	r18, 0x405A
    4ede:	30 91 5b 40 	lds	r19, 0x405B
    4ee2:	06 17       	cp	r16, r22
    4ee4:	17 07       	cpc	r17, r23
    4ee6:	28 07       	cpc	r18, r24
    4ee8:	39 07       	cpc	r19, r25
    4eea:	40 f4       	brcc	.+16     	; 0x4efc <writeFile+0x17a>
     cluster = rootCluster;
    4eec:	60 91 5d 40 	lds	r22, 0x405D
    4ef0:	70 91 5e 40 	lds	r23, 0x405E
    4ef4:	80 91 5f 40 	lds	r24, 0x405F
    4ef8:	90 91 60 40 	lds	r25, 0x4060

  cluster = searchNextFreeCluster(cluster);
    4efc:	0e 94 7e 23 	call	0x46fc	; 0x46fc <searchNextFreeCluster>
    4f00:	69 83       	std	Y+1, r22	; 0x01
    4f02:	7a 83       	std	Y+2, r23	; 0x02
    4f04:	8b 83       	std	Y+3, r24	; 0x03
    4f06:	9c 83       	std	Y+4, r25	; 0x04
   if(cluster == 0)
    4f08:	61 15       	cp	r22, r1
    4f0a:	71 05       	cpc	r23, r1
    4f0c:	81 05       	cpc	r24, r1
    4f0e:	91 05       	cpc	r25, r1
    4f10:	09 f4       	brne	.+2      	; 0x4f14 <writeFile+0x192>
    4f12:	e6 c1       	rjmp	.+972    	; 0x52e0 <writeFile+0x55e>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    4f14:	41 e0       	ldi	r20, 0x01	; 1
    4f16:	0f ef       	ldi	r16, 0xFF	; 255
    4f18:	1f ef       	ldi	r17, 0xFF	; 255
    4f1a:	98 01       	movw	r18, r16
    4f1c:	0e 94 a0 20 	call	0x4140	; 0x4140 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    4f20:	2b 81       	ldd	r18, Y+3	; 0x03
    4f22:	3c 81       	ldd	r19, Y+4	; 0x04
    4f24:	29 87       	std	Y+9, r18	; 0x09
    4f26:	3a 87       	std	Y+10, r19	; 0x0a
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    4f28:	89 81       	ldd	r24, Y+1	; 0x01
    4f2a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f2c:	8f 87       	std	Y+15, r24	; 0x0f
    4f2e:	98 8b       	std	Y+16, r25	; 0x10
  fileSize = 0;
    4f30:	10 92 51 40 	sts	0x4051, r1
    4f34:	10 92 52 40 	sts	0x4052, r1
    4f38:	10 92 53 40 	sts	0x4053, r1
    4f3c:	10 92 54 40 	sts	0x4054, r1
  startBlock = getFirstSector (cluster) + sector;
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
    4f40:	69 81       	ldd	r22, Y+1	; 0x01
    4f42:	7a 81       	ldd	r23, Y+2	; 0x02
    4f44:	8b 81       	ldd	r24, Y+3	; 0x03
    4f46:	9c 81       	ldd	r25, Y+4	; 0x04
    4f48:	0e 94 79 20 	call	0x40f2	; 0x40f2 <getFirstSector>
    4f4c:	dc 01       	movw	r26, r24
    4f4e:	cb 01       	movw	r24, r22
    4f50:	1c 01       	movw	r2, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4f52:	10 e0       	ldi	r17, 0x00	; 0
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
  j=0;
    4f54:	00 e0       	ldi	r16, 0x00	; 0
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    4f56:	81 14       	cp	r8, r1
    4f58:	91 04       	cpc	r9, r1
    4f5a:	a1 04       	cpc	r10, r1
    4f5c:	b1 04       	cpc	r11, r1
    4f5e:	09 f4       	brne	.+2      	; 0x4f62 <writeFile+0x1e0>
    4f60:	8d c0       	rjmp	.+282    	; 0x507c <writeFile+0x2fa>
    4f62:	44 24       	eor	r4, r4
    4f64:	55 24       	eor	r5, r5
    4f66:	32 01       	movw	r6, r4
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
		 writtenData += 512;
		 dataToWrite = 512;
    4f68:	c0 2e       	mov	r12, r16
    4f6a:	1b 87       	std	Y+11, r17	; 0x0b
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    4f6c:	90 e0       	ldi	r25, 0x00	; 0
    4f6e:	89 16       	cp	r8, r25
    4f70:	92 e0       	ldi	r25, 0x02	; 2
    4f72:	99 06       	cpc	r9, r25
    4f74:	90 e0       	ldi	r25, 0x00	; 0
    4f76:	a9 06       	cpc	r10, r25
    4f78:	90 e0       	ldi	r25, 0x00	; 0
    4f7a:	b9 06       	cpc	r11, r25
    4f7c:	88 f0       	brcs	.+34     	; 0x4fa0 <writeFile+0x21e>
		 writtenData += 512;
    4f7e:	00 e0       	ldi	r16, 0x00	; 0
    4f80:	12 e0       	ldi	r17, 0x02	; 2
    4f82:	20 e0       	ldi	r18, 0x00	; 0
    4f84:	30 e0       	ldi	r19, 0x00	; 0
    4f86:	40 0e       	add	r4, r16
    4f88:	51 1e       	adc	r5, r17
    4f8a:	62 1e       	adc	r6, r18
    4f8c:	73 1e       	adc	r7, r19
		 dataToWrite = 512;
		 lengthOfData -= 512;
    4f8e:	80 e0       	ldi	r24, 0x00	; 0
    4f90:	9e ef       	ldi	r25, 0xFE	; 254
    4f92:	af ef       	ldi	r26, 0xFF	; 255
    4f94:	bf ef       	ldi	r27, 0xFF	; 255
    4f96:	88 0e       	add	r8, r24
    4f98:	99 1e       	adc	r9, r25
    4f9a:	aa 1e       	adc	r10, r26
    4f9c:	bb 1e       	adc	r11, r27
    4f9e:	0c c0       	rjmp	.+24     	; 0x4fb8 <writeFile+0x236>
	}
	else{
		writtenData += lengthOfData;
    4fa0:	48 0c       	add	r4, r8
    4fa2:	59 1c       	adc	r5, r9
    4fa4:	6a 1c       	adc	r6, r10
    4fa6:	7b 1c       	adc	r7, r11
		dataToWrite = lengthOfData%512;
    4fa8:	95 01       	movw	r18, r10
    4faa:	84 01       	movw	r16, r8
    4fac:	11 70       	andi	r17, 0x01	; 1
    4fae:	20 70       	andi	r18, 0x00	; 0
    4fb0:	30 70       	andi	r19, 0x00	; 0
		lengthOfData = 0;
    4fb2:	88 24       	eor	r8, r8
    4fb4:	99 24       	eor	r9, r9
    4fb6:	54 01       	movw	r10, r8
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    4fb8:	80 91 51 40 	lds	r24, 0x4051
    4fbc:	90 91 52 40 	lds	r25, 0x4052
    4fc0:	a0 91 53 40 	lds	r26, 0x4053
    4fc4:	b0 91 54 40 	lds	r27, 0x4054
    4fc8:	80 50       	subi	r24, 0x00	; 0
    4fca:	9e 4f       	sbci	r25, 0xFE	; 254
    4fcc:	af 4f       	sbci	r26, 0xFF	; 255
    4fce:	bf 4f       	sbci	r27, 0xFF	; 255
    4fd0:	80 93 51 40 	sts	0x4051, r24
    4fd4:	90 93 52 40 	sts	0x4052, r25
    4fd8:	a0 93 53 40 	sts	0x4053, r26
    4fdc:	b0 93 54 40 	sts	0x4054, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    4fe0:	b1 01       	movw	r22, r2
    4fe2:	80 e0       	ldi	r24, 0x00	; 0
    4fe4:	90 e0       	ldi	r25, 0x00	; 0
    4fe6:	a2 01       	movw	r20, r4
    4fe8:	40 1b       	sub	r20, r16
    4fea:	51 0b       	sbc	r21, r17
    4fec:	ad 81       	ldd	r26, Y+5	; 0x05
    4fee:	be 81       	ldd	r27, Y+6	; 0x06
    4ff0:	4a 0f       	add	r20, r26
    4ff2:	5b 1f       	adc	r21, r27
    4ff4:	98 01       	movw	r18, r16
    4ff6:	0e 94 ca 2a 	call	0x5594	; 0x5594 <SD_write_block>
	j++;
    4ffa:	c3 94       	inc	r12
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    4ffc:	20 91 69 50 	lds	r18, 0x5069
    5000:	30 91 6a 50 	lds	r19, 0x506A
    5004:	8c 2d       	mov	r24, r12
    5006:	90 e0       	ldi	r25, 0x00	; 0
    5008:	82 17       	cp	r24, r18
    500a:	93 07       	cpc	r25, r19
    500c:	29 f5       	brne	.+74     	; 0x5058 <writeFile+0x2d6>
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    500e:	69 81       	ldd	r22, Y+1	; 0x01
    5010:	7a 81       	ldd	r23, Y+2	; 0x02
    5012:	8b 81       	ldd	r24, Y+3	; 0x03
    5014:	9c 81       	ldd	r25, Y+4	; 0x04
    5016:	0e 94 7e 23 	call	0x46fc	; 0x46fc <searchNextFreeCluster>
    501a:	6b 01       	movw	r12, r22
    501c:	7c 01       	movw	r14, r24
		if(cluster == 0){
    501e:	61 15       	cp	r22, r1
    5020:	71 05       	cpc	r23, r1
    5022:	81 05       	cpc	r24, r1
    5024:	91 05       	cpc	r25, r1
    5026:	09 f4       	brne	.+2      	; 0x502a <writeFile+0x2a8>
    5028:	5d c1       	rjmp	.+698    	; 0x52e4 <writeFile+0x562>
		  //No free cluster!
		  return 2;
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    502a:	69 81       	ldd	r22, Y+1	; 0x01
    502c:	7a 81       	ldd	r23, Y+2	; 0x02
    502e:	8b 81       	ldd	r24, Y+3	; 0x03
    5030:	9c 81       	ldd	r25, Y+4	; 0x04
    5032:	41 e0       	ldi	r20, 0x01	; 1
    5034:	97 01       	movw	r18, r14
    5036:	86 01       	movw	r16, r12
    5038:	0e 94 a0 20 	call	0x4140	; 0x4140 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    503c:	c7 01       	movw	r24, r14
    503e:	b6 01       	movw	r22, r12
    5040:	41 e0       	ldi	r20, 0x01	; 1
    5042:	0f ef       	ldi	r16, 0xFF	; 255
    5044:	1f ef       	ldi	r17, 0xFF	; 255
    5046:	98 01       	movw	r18, r16
    5048:	0e 94 a0 20 	call	0x4140	; 0x4140 <getSetNextCluster>
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    504c:	c9 82       	std	Y+1, r12	; 0x01
    504e:	da 82       	std	Y+2, r13	; 0x02
    5050:	eb 82       	std	Y+3, r14	; 0x03
    5052:	fc 82       	std	Y+4, r15	; 0x04
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
	j++;
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
    5054:	cc 24       	eor	r12, r12
    5056:	03 c0       	rjmp	.+6      	; 0x505e <writeFile+0x2dc>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    5058:	08 94       	sec
    505a:	21 1c       	adc	r2, r1
    505c:	31 1c       	adc	r3, r1
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    505e:	82 e0       	ldi	r24, 0x02	; 2
    5060:	61 e0       	ldi	r22, 0x01	; 1
    5062:	29 81       	ldd	r18, Y+1	; 0x01
    5064:	3a 81       	ldd	r19, Y+2	; 0x02
    5066:	4b 81       	ldd	r20, Y+3	; 0x03
    5068:	5c 81       	ldd	r21, Y+4	; 0x04
    506a:	0e 94 32 21 	call	0x4264	; 0x4264 <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    506e:	81 14       	cp	r8, r1
    5070:	91 04       	cpc	r9, r1
    5072:	a1 04       	cpc	r10, r1
    5074:	b1 04       	cpc	r11, r1
    5076:	09 f0       	breq	.+2      	; 0x507a <writeFile+0x2f8>
    5078:	79 cf       	rjmp	.-270    	; 0x4f6c <writeFile+0x1ea>
    507a:	1b 85       	ldd	r17, Y+11	; 0x0b
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    507c:	11 23       	and	r17, r17
    507e:	09 f4       	brne	.+2      	; 0x5082 <writeFile+0x300>
    5080:	3f c0       	rjmp	.+126    	; 0x5100 <writeFile+0x37e>
{
  SD_read_block (appendFileSector,SDBuffer);    
    5082:	60 91 a2 50 	lds	r22, 0x50A2
    5086:	70 91 a3 50 	lds	r23, 0x50A3
    508a:	80 91 a4 50 	lds	r24, 0x50A4
    508e:	90 91 a5 50 	lds	r25, 0x50A5
    5092:	08 e4       	ldi	r16, 0x48	; 72
    5094:	1e e3       	ldi	r17, 0x3E	; 62
    5096:	a8 01       	movw	r20, r16
    5098:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    509c:	e0 91 49 40 	lds	r30, 0x4049
    50a0:	f0 91 4a 40 	lds	r31, 0x404A
    50a4:	e0 0f       	add	r30, r16
    50a6:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    50a8:	12 8a       	std	Z+18, r1	; 0x12
    50aa:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    50ac:	80 91 51 40 	lds	r24, 0x4051
    50b0:	90 91 52 40 	lds	r25, 0x4052
    50b4:	a0 91 53 40 	lds	r26, 0x4053
    50b8:	b0 91 54 40 	lds	r27, 0x4054
    50bc:	44 8d       	ldd	r20, Z+28	; 0x1c
    50be:	55 8d       	ldd	r21, Z+29	; 0x1d
    50c0:	66 8d       	ldd	r22, Z+30	; 0x1e
    50c2:	77 8d       	ldd	r23, Z+31	; 0x1f
    50c4:	6c 01       	movw	r12, r24
    50c6:	7d 01       	movw	r14, r26
    50c8:	c4 1a       	sub	r12, r20
    50ca:	d5 0a       	sbc	r13, r21
    50cc:	e6 0a       	sbc	r14, r22
    50ce:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    50d0:	84 8f       	std	Z+28, r24	; 0x1c
    50d2:	95 8f       	std	Z+29, r25	; 0x1d
    50d4:	a6 8f       	std	Z+30, r26	; 0x1e
    50d6:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    50d8:	60 91 a2 50 	lds	r22, 0x50A2
    50dc:	70 91 a3 50 	lds	r23, 0x50A3
    50e0:	80 91 a4 50 	lds	r24, 0x50A4
    50e4:	90 91 a5 50 	lds	r25, 0x50A5
    50e8:	a8 01       	movw	r20, r16
    50ea:	20 e0       	ldi	r18, 0x00	; 0
    50ec:	32 e0       	ldi	r19, 0x02	; 2
    50ee:	0e 94 ca 2a 	call	0x5594	; 0x5594 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    50f2:	81 e0       	ldi	r24, 0x01	; 1
    50f4:	b7 01       	movw	r22, r14
    50f6:	a6 01       	movw	r20, r12
    50f8:	0e 94 31 24 	call	0x4862	; 0x4862 <freeMemoryUpdate>

 //File appended!
  return 0;
    50fc:	80 e0       	ldi	r24, 0x00	; 0
    50fe:	f9 c0       	rjmp	.+498    	; 0x52f2 <writeFile+0x570>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    5100:	00 91 5d 40 	lds	r16, 0x405D
    5104:	10 91 5e 40 	lds	r17, 0x405E
    5108:	20 91 5f 40 	lds	r18, 0x405F
    510c:	30 91 60 40 	lds	r19, 0x4060
    5110:	0b 87       	std	Y+11, r16	; 0x0b
    5112:	1c 87       	std	Y+12, r17	; 0x0c
    5114:	2d 87       	std	Y+13, r18	; 0x0d
    5116:	3e 87       	std	Y+14, r19	; 0x0e
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    5118:	77 24       	eor	r7, r7
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    511a:	81 e9       	ldi	r24, 0x91	; 145
    511c:	90 e5       	ldi	r25, 0x50	; 80
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    511e:	0f 2e       	mov	r0, r31
    5120:	fb e0       	ldi	r31, 0x0B	; 11
    5122:	af 2e       	mov	r10, r31
    5124:	bb 24       	eor	r11, r11
    5126:	f0 2d       	mov	r31, r0
    5128:	a8 0e       	add	r10, r24
    512a:	b9 1e       	adc	r11, r25

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    512c:	88 24       	eor	r8, r8
    512e:	68 94       	set
    5130:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    5132:	0f 2e       	mov	r0, r31
    5134:	f8 e4       	ldi	r31, 0x48	; 72
    5136:	4f 2e       	mov	r4, r31
    5138:	fe e3       	ldi	r31, 0x3E	; 62
    513a:	5f 2e       	mov	r5, r31
    513c:	f0 2d       	mov	r31, r0
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    513e:	28 2e       	mov	r2, r24
    5140:	99 2e       	mov	r9, r25
    5142:	37 2c       	mov	r3, r7
    5144:	6f 84       	ldd	r6, Y+15	; 0x0f
    5146:	78 88       	ldd	r7, Y+16	; 0x10
    5148:	04 c0       	rjmp	.+8      	; 0x5152 <writeFile+0x3d0>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    514a:	cb 86       	std	Y+11, r12	; 0x0b
    514c:	dc 86       	std	Y+12, r13	; 0x0c
    514e:	ed 86       	std	Y+13, r14	; 0x0d
    5150:	fe 86       	std	Y+14, r15	; 0x0e

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    5152:	6b 85       	ldd	r22, Y+11	; 0x0b
    5154:	7c 85       	ldd	r23, Y+12	; 0x0c
    5156:	8d 85       	ldd	r24, Y+13	; 0x0d
    5158:	9e 85       	ldd	r25, Y+14	; 0x0e
    515a:	0e 94 79 20 	call	0x40f2	; 0x40f2 <getFirstSector>
    515e:	6d 83       	std	Y+5, r22	; 0x05
    5160:	7e 83       	std	Y+6, r23	; 0x06
    5162:	8f 83       	std	Y+7, r24	; 0x07
    5164:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    5166:	80 91 69 50 	lds	r24, 0x5069
    516a:	90 91 6a 50 	lds	r25, 0x506A
    516e:	00 97       	sbiw	r24, 0x00	; 0
    5170:	09 f4       	brne	.+2      	; 0x5174 <writeFile+0x3f2>
    5172:	77 c0       	rjmp	.+238    	; 0x5262 <writeFile+0x4e0>
    5174:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    5176:	cd 80       	ldd	r12, Y+5	; 0x05
    5178:	de 80       	ldd	r13, Y+6	; 0x06
    517a:	ef 80       	ldd	r14, Y+7	; 0x07
    517c:	f8 84       	ldd	r15, Y+8	; 0x08
    517e:	19 81       	ldd	r17, Y+1	; 0x01
    5180:	c1 0e       	add	r12, r17
    5182:	d1 1c       	adc	r13, r1
    5184:	e1 1c       	adc	r14, r1
    5186:	f1 1c       	adc	r15, r1
    5188:	c7 01       	movw	r24, r14
    518a:	b6 01       	movw	r22, r12
    518c:	a2 01       	movw	r20, r4
    518e:	0e 94 7f 2b 	call	0x56fe	; 0x56fe <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    5192:	80 91 55 40 	lds	r24, 0x4055
    5196:	90 91 56 40 	lds	r25, 0x4056
    519a:	00 97       	sbiw	r24, 0x00	; 0
    519c:	09 f4       	brne	.+2      	; 0x51a0 <writeFile+0x41e>
    519e:	54 c0       	rjmp	.+168    	; 0x5248 <writeFile+0x4c6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    51a0:	33 20       	and	r3, r3
    51a2:	09 f0       	breq	.+2      	; 0x51a6 <writeFile+0x424>
    51a4:	a1 c0       	rjmp	.+322    	; 0x52e8 <writeFile+0x566>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    51a6:	a2 01       	movw	r20, r4
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    51a8:	00 e0       	ldi	r16, 0x00	; 0
    51aa:	10 e0       	ldi	r17, 0x00	; 0
    51ac:	06 c0       	rjmp	.+12     	; 0x51ba <writeFile+0x438>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    51ae:	a8 01       	movw	r20, r16
    51b0:	48 5b       	subi	r20, 0xB8	; 184
    51b2:	51 4c       	sbci	r21, 0xC1	; 193
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    51b4:	22 23       	and	r18, r18
    51b6:	09 f0       	breq	.+2      	; 0x51ba <writeFile+0x438>
    51b8:	99 c0       	rjmp	.+306    	; 0x52ec <writeFile+0x56a>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    51ba:	da 01       	movw	r26, r20
    51bc:	8c 91       	ld	r24, X
    51be:	88 23       	and	r24, r24
    51c0:	21 f4       	brne	.+8      	; 0x51ca <writeFile+0x448>
    51c2:	e2 2d       	mov	r30, r2
    51c4:	f9 2d       	mov	r31, r9
    51c6:	da 01       	movw	r26, r20
    51c8:	04 c0       	rjmp	.+8      	; 0x51d2 <writeFile+0x450>
    51ca:	85 3e       	cpi	r24, 0xE5	; 229
    51cc:	d1 f3       	breq	.-12     	; 0x51c2 <writeFile+0x440>
    51ce:	23 2d       	mov	r18, r3
    51d0:	30 c0       	rjmp	.+96     	; 0x5232 <writeFile+0x4b0>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
    51d2:	81 91       	ld	r24, Z+
    51d4:	8d 93       	st	X+, r24
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    51d6:	ea 15       	cp	r30, r10
    51d8:	fb 05       	cpc	r31, r11
    51da:	d9 f7       	brne	.-10     	; 0x51d2 <writeFile+0x450>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    51dc:	fa 01       	movw	r30, r20
    51de:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    51e0:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    51e2:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    51e4:	12 8a       	std	Z+18, r1	; 0x12
    51e6:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    51e8:	29 85       	ldd	r18, Y+9	; 0x09
    51ea:	3a 85       	ldd	r19, Y+10	; 0x0a
    51ec:	24 8b       	std	Z+20, r18	; 0x14
    51ee:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    51f0:	62 8e       	std	Z+26, r6	; 0x1a
    51f2:	73 8e       	std	Z+27, r7	; 0x1b
		  dir->fileSize = fileSize;
    51f4:	80 91 51 40 	lds	r24, 0x4051
    51f8:	90 91 52 40 	lds	r25, 0x4052
    51fc:	a0 91 53 40 	lds	r26, 0x4053
    5200:	b0 91 54 40 	lds	r27, 0x4054
    5204:	84 8f       	std	Z+28, r24	; 0x1c
    5206:	95 8f       	std	Z+29, r25	; 0x1d
    5208:	a6 8f       	std	Z+30, r26	; 0x1e
    520a:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    520c:	c7 01       	movw	r24, r14
    520e:	b6 01       	movw	r22, r12
    5210:	a2 01       	movw	r20, r4
    5212:	20 e0       	ldi	r18, 0x00	; 0
    5214:	32 e0       	ldi	r19, 0x02	; 2
    5216:	0e 94 ca 2a 	call	0x5594	; 0x5594 <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    521a:	40 91 51 40 	lds	r20, 0x4051
    521e:	50 91 52 40 	lds	r21, 0x4052
    5222:	60 91 53 40 	lds	r22, 0x4053
    5226:	70 91 54 40 	lds	r23, 0x4054
    522a:	81 e0       	ldi	r24, 0x01	; 1
    522c:	0e 94 31 24 	call	0x4862	; 0x4862 <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    5230:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    5232:	00 5e       	subi	r16, 0xE0	; 224
    5234:	1f 4f       	sbci	r17, 0xFF	; 255
    5236:	80 91 55 40 	lds	r24, 0x4055
    523a:	90 91 56 40 	lds	r25, 0x4056
    523e:	08 17       	cp	r16, r24
    5240:	19 07       	cpc	r17, r25
    5242:	08 f4       	brcc	.+2      	; 0x5246 <writeFile+0x4c4>
    5244:	b4 cf       	rjmp	.-152    	; 0x51ae <writeFile+0x42c>
    5246:	32 2e       	mov	r3, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    5248:	09 81       	ldd	r16, Y+1	; 0x01
    524a:	0f 5f       	subi	r16, 0xFF	; 255
    524c:	09 83       	std	Y+1, r16	; 0x01
    524e:	20 91 69 50 	lds	r18, 0x5069
    5252:	30 91 6a 50 	lds	r19, 0x506A
    5256:	80 2f       	mov	r24, r16
    5258:	90 e0       	ldi	r25, 0x00	; 0
    525a:	82 17       	cp	r24, r18
    525c:	93 07       	cpc	r25, r19
    525e:	08 f4       	brcc	.+2      	; 0x5262 <writeFile+0x4e0>
    5260:	8a cf       	rjmp	.-236    	; 0x5176 <writeFile+0x3f4>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    5262:	6b 85       	ldd	r22, Y+11	; 0x0b
    5264:	7c 85       	ldd	r23, Y+12	; 0x0c
    5266:	8d 85       	ldd	r24, Y+13	; 0x0d
    5268:	9e 85       	ldd	r25, Y+14	; 0x0e
    526a:	40 e0       	ldi	r20, 0x00	; 0
    526c:	00 e0       	ldi	r16, 0x00	; 0
    526e:	10 e0       	ldi	r17, 0x00	; 0
    5270:	98 01       	movw	r18, r16
    5272:	0e 94 a0 20 	call	0x4140	; 0x4140 <getSetNextCluster>
    5276:	6b 01       	movw	r12, r22
    5278:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    527a:	67 3f       	cpi	r22, 0xF7	; 247
    527c:	1f ef       	ldi	r17, 0xFF	; 255
    527e:	71 07       	cpc	r23, r17
    5280:	1f ef       	ldi	r17, 0xFF	; 255
    5282:	81 07       	cpc	r24, r17
    5284:	1f e0       	ldi	r17, 0x0F	; 15
    5286:	91 07       	cpc	r25, r17
    5288:	08 f1       	brcs	.+66     	; 0x52cc <writeFile+0x54a>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    528a:	6f 3f       	cpi	r22, 0xFF	; 255
    528c:	2f ef       	ldi	r18, 0xFF	; 255
    528e:	72 07       	cpc	r23, r18
    5290:	2f ef       	ldi	r18, 0xFF	; 255
    5292:	82 07       	cpc	r24, r18
    5294:	2f ef       	ldi	r18, 0xFF	; 255
    5296:	92 07       	cpc	r25, r18
    5298:	59 f5       	brne	.+86     	; 0x52f0 <writeFile+0x56e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    529a:	6b 85       	ldd	r22, Y+11	; 0x0b
    529c:	7c 85       	ldd	r23, Y+12	; 0x0c
    529e:	8d 85       	ldd	r24, Y+13	; 0x0d
    52a0:	9e 85       	ldd	r25, Y+14	; 0x0e
    52a2:	0e 94 7e 23 	call	0x46fc	; 0x46fc <searchNextFreeCluster>
    52a6:	6b 01       	movw	r12, r22
    52a8:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    52aa:	6b 85       	ldd	r22, Y+11	; 0x0b
    52ac:	7c 85       	ldd	r23, Y+12	; 0x0c
    52ae:	8d 85       	ldd	r24, Y+13	; 0x0d
    52b0:	9e 85       	ldd	r25, Y+14	; 0x0e
    52b2:	41 e0       	ldi	r20, 0x01	; 1
    52b4:	97 01       	movw	r18, r14
    52b6:	86 01       	movw	r16, r12
    52b8:	0e 94 a0 20 	call	0x4140	; 0x4140 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    52bc:	c7 01       	movw	r24, r14
    52be:	b6 01       	movw	r22, r12
    52c0:	41 e0       	ldi	r20, 0x01	; 1
    52c2:	0f ef       	ldi	r16, 0xFF	; 255
    52c4:	1f ef       	ldi	r17, 0xFF	; 255
    52c6:	98 01       	movw	r18, r16
    52c8:	0e 94 a0 20 	call	0x4140	; 0x4140 <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    52cc:	c1 14       	cp	r12, r1
    52ce:	d1 04       	cpc	r13, r1
    52d0:	e1 04       	cpc	r14, r1
    52d2:	f1 04       	cpc	r15, r1
    52d4:	09 f0       	breq	.+2      	; 0x52d8 <writeFile+0x556>
    52d6:	39 cf       	rjmp	.-398    	; 0x514a <writeFile+0x3c8>
	   return 4;
    52d8:	84 e0       	ldi	r24, 0x04	; 4
    52da:	0b c0       	rjmp	.+22     	; 0x52f2 <writeFile+0x570>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    52dc:	81 e0       	ldi	r24, 0x01	; 1
    52de:	09 c0       	rjmp	.+18     	; 0x52f2 <writeFile+0x570>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    52e0:	82 e0       	ldi	r24, 0x02	; 2
    52e2:	07 c0       	rjmp	.+14     	; 0x52f2 <writeFile+0x570>
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
		if(cluster == 0){
		  //No free cluster!
		  return 2;
    52e4:	82 e0       	ldi	r24, 0x02	; 2
    52e6:	05 c0       	rjmp	.+10     	; 0x52f2 <writeFile+0x570>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    52e8:	80 e0       	ldi	r24, 0x00	; 0
    52ea:	03 c0       	rjmp	.+6      	; 0x52f2 <writeFile+0x570>
    52ec:	80 e0       	ldi	r24, 0x00	; 0
    52ee:	01 c0       	rjmp	.+2      	; 0x52f2 <writeFile+0x570>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    52f0:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    52f2:	60 96       	adiw	r28, 0x10	; 16
    52f4:	cd bf       	out	0x3d, r28	; 61
    52f6:	de bf       	out	0x3e, r29	; 62
    52f8:	df 91       	pop	r29
    52fa:	cf 91       	pop	r28
    52fc:	1f 91       	pop	r17
    52fe:	0f 91       	pop	r16
    5300:	ff 90       	pop	r15
    5302:	ef 90       	pop	r14
    5304:	df 90       	pop	r13
    5306:	cf 90       	pop	r12
    5308:	bf 90       	pop	r11
    530a:	af 90       	pop	r10
    530c:	9f 90       	pop	r9
    530e:	8f 90       	pop	r8
    5310:	7f 90       	pop	r7
    5312:	6f 90       	pop	r6
    5314:	5f 90       	pop	r5
    5316:	4f 90       	pop	r4
    5318:	3f 90       	pop	r3
    531a:	2f 90       	pop	r2
    531c:	08 95       	ret

0000531e <SD_command>:
// 	data = SPIC.DATA; //read SPI data register to reset status flag
// 	return data;
// }

//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    531e:	8f 92       	push	r8
    5320:	9f 92       	push	r9
    5322:	af 92       	push	r10
    5324:	bf 92       	push	r11
    5326:	cf 92       	push	r12
    5328:	df 92       	push	r13
    532a:	ef 92       	push	r14
    532c:	ff 92       	push	r15
    532e:	0f 93       	push	r16
    5330:	1f 93       	push	r17
    5332:	cf 93       	push	r28
    5334:	df 93       	push	r29
    5336:	84 2e       	mov	r8, r20
    5338:	a5 2e       	mov	r10, r21
    533a:	c6 2e       	mov	r12, r22
    533c:	c7 2f       	mov	r28, r23
    533e:	d2 2f       	mov	r29, r18
    5340:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    5342:	80 64       	ori	r24, 0x40	; 64
    5344:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    5348:	8c 2f       	mov	r24, r28
    534a:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    534e:	8c 2d       	mov	r24, r12
    5350:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    5354:	8a 2d       	mov	r24, r10
    5356:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    535a:	88 2d       	mov	r24, r8
    535c:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPI_write(crc);
    5360:	8d 2f       	mov	r24, r29
    5362:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	
	for(int i=0; i<read; i++){
    5366:	10 16       	cp	r1, r16
    5368:	11 06       	cpc	r1, r17
    536a:	64 f5       	brge	.+88     	; 0x53c4 <SD_command+0xa6>
    536c:	00 e0       	ldi	r16, 0x00	; 0
    536e:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    5370:	0f 2e       	mov	r0, r31
    5372:	fd e0       	ldi	r31, 0x0D	; 13
    5374:	cf 2e       	mov	r12, r31
    5376:	dd 24       	eor	r13, r13
    5378:	f0 2d       	mov	r31, r0
    537a:	0f 2e       	mov	r0, r31
    537c:	f4 e3       	ldi	r31, 0x34	; 52
    537e:	af 2e       	mov	r10, r31
    5380:	fe e3       	ldi	r31, 0x3E	; 62
    5382:	bf 2e       	mov	r11, r31
    5384:	f0 2d       	mov	r31, r0
    5386:	c8 01       	movw	r24, r16
    5388:	b6 01       	movw	r22, r12
    538a:	0e 94 44 39 	call	0x7288	; 0x7288 <__divmodhi4>
    538e:	ec 01       	movw	r28, r24
    5390:	8f ef       	ldi	r24, 0xFF	; 255
    5392:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5396:	f5 01       	movw	r30, r10
    5398:	ec 0f       	add	r30, r28
    539a:	fd 1f       	adc	r31, r29
    539c:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    539e:	80 81       	ld	r24, Z
    53a0:	8f 3f       	cpi	r24, 0xFF	; 255
    53a2:	49 f0       	breq	.+18     	; 0x53b6 <SD_command+0x98>
			Buffer[1] = Buffer[i%13];
    53a4:	fe 01       	movw	r30, r28
    53a6:	ec 5c       	subi	r30, 0xCC	; 204
    53a8:	f1 4c       	sbci	r31, 0xC1	; 193
    53aa:	80 81       	ld	r24, Z
    53ac:	80 93 35 3e 	sts	0x3E35, r24
			return Buffer[1];
    53b0:	80 91 35 3e 	lds	r24, 0x3E35
    53b4:	08 c0       	rjmp	.+16     	; 0x53c6 <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    53b6:	0f 5f       	subi	r16, 0xFF	; 255
    53b8:	1f 4f       	sbci	r17, 0xFF	; 255
    53ba:	0e 15       	cp	r16, r14
    53bc:	1f 05       	cpc	r17, r15
    53be:	19 f7       	brne	.-58     	; 0x5386 <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    53c0:	8f ef       	ldi	r24, 0xFF	; 255
    53c2:	01 c0       	rjmp	.+2      	; 0x53c6 <SD_command+0xa8>
    53c4:	8f ef       	ldi	r24, 0xFF	; 255
}
    53c6:	df 91       	pop	r29
    53c8:	cf 91       	pop	r28
    53ca:	1f 91       	pop	r17
    53cc:	0f 91       	pop	r16
    53ce:	ff 90       	pop	r15
    53d0:	ef 90       	pop	r14
    53d2:	df 90       	pop	r13
    53d4:	cf 90       	pop	r12
    53d6:	bf 90       	pop	r11
    53d8:	af 90       	pop	r10
    53da:	9f 90       	pop	r9
    53dc:	8f 90       	pop	r8
    53de:	08 95       	ret

000053e0 <SD_init>:
# include "SD_Card.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    53e0:	ff 92       	push	r15
    53e2:	0f 93       	push	r16
    53e4:	1f 93       	push	r17
    53e6:	cf 93       	push	r28
    53e8:	df 93       	push	r29
	
	ADCPower(TRUE);				//power up portEX
    53ea:	81 e0       	ldi	r24, 0x01	; 1
    53ec:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    53f0:	81 e0       	ldi	r24, 0x01	; 1
    53f2:	0e 94 61 03 	call	0x6c2	; 0x6c2 <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    53f6:	8f ef       	ldi	r24, 0xFF	; 255
    53f8:	93 ec       	ldi	r25, 0xC3	; 195
    53fa:	a9 e0       	ldi	r26, 0x09	; 9
    53fc:	81 50       	subi	r24, 0x01	; 1
    53fe:	90 40       	sbci	r25, 0x00	; 0
    5400:	a0 40       	sbci	r26, 0x00	; 0
    5402:	e1 f7       	brne	.-8      	; 0x53fc <SD_init+0x1c>
    5404:	00 c0       	rjmp	.+0      	; 0x5406 <SD_init+0x26>
    5406:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
	
	PortEx_DIRSET(BIT3_bm, PS_BANKB); //SD card CS
    5408:	88 e0       	ldi	r24, 0x08	; 8
    540a:	60 e0       	ldi	r22, 0x00	; 0
    540c:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB); //pull SD cs high
    5410:	88 e0       	ldi	r24, 0x08	; 8
    5412:	60 e0       	ldi	r22, 0x00	; 0
    5414:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5418:	80 e0       	ldi	r24, 0x00	; 0
    541a:	63 e0       	ldi	r22, 0x03	; 3
    541c:	0e 94 d5 03 	call	0x7aa	; 0x7aa <SPIInit2>
	SPICS(TRUE);
    5420:	81 e0       	ldi	r24, 0x01	; 1
    5422:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
    5426:	8a e0       	ldi	r24, 0x0A	; 10
    5428:	90 e0       	ldi	r25, 0x00	; 0
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    542a:	e0 ec       	ldi	r30, 0xC0	; 192
    542c:	f8 e0       	ldi	r31, 0x08	; 8
    542e:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
    5430:	a0 e4       	ldi	r26, 0x40	; 64
    5432:	be e3       	ldi	r27, 0x3E	; 62
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    5434:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    5436:	22 81       	ldd	r18, Z+2	; 0x02
    5438:	22 23       	and	r18, r18
    543a:	ec f7       	brge	.-6      	; 0x5436 <SD_init+0x56>
		Buffer[12] = SPIC.DATA;
    543c:	23 81       	ldd	r18, Z+3	; 0x03
    543e:	2c 93       	st	X, r18
    5440:	01 97       	sbiw	r24, 0x01	; 1
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
    5442:	c1 f7       	brne	.-16     	; 0x5434 <SD_init+0x54>
		SPIC.DATA = SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
	}
	
	SPICS(FALSE);
    5444:	80 e0       	ldi	r24, 0x00	; 0
    5446:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    544a:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    544e:	88 e0       	ldi	r24, 0x08	; 8
    5450:	60 e0       	ldi	r22, 0x00	; 0
    5452:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5456:	80 e0       	ldi	r24, 0x00	; 0
    5458:	63 e0       	ldi	r22, 0x03	; 3
    545a:	0e 94 d5 03 	call	0x7aa	; 0x7aa <SPIInit2>
	SPICS(TRUE);
    545e:	81 e0       	ldi	r24, 0x01	; 1
    5460:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    5464:	cb e0       	ldi	r28, 0x0B	; 11
    5466:	d0 e0       	ldi	r29, 0x00	; 0
    5468:	02 c0       	rjmp	.+4      	; 0x546e <SD_init+0x8e>
    546a:	21 97       	sbiw	r28, 0x01	; 1
		//try command 10 times before timing out
		if (i >= 10) {
    546c:	69 f0       	breq	.+26     	; 0x5488 <SD_init+0xa8>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    546e:	80 e0       	ldi	r24, 0x00	; 0
    5470:	40 e0       	ldi	r20, 0x00	; 0
    5472:	50 e0       	ldi	r21, 0x00	; 0
    5474:	ba 01       	movw	r22, r20
    5476:	25 e9       	ldi	r18, 0x95	; 149
    5478:	08 e0       	ldi	r16, 0x08	; 8
    547a:	10 e0       	ldi	r17, 0x00	; 0
    547c:	0e 94 8f 29 	call	0x531e	; 0x531e <SD_command>
    5480:	81 30       	cpi	r24, 0x01	; 1
    5482:	99 f7       	brne	.-26     	; 0x546a <SD_init+0x8a>
uint8_t SD_init(void){
	
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    5484:	ff 24       	eor	r15, r15
    5486:	02 c0       	rjmp	.+4      	; 0x548c <SD_init+0xac>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
		//try command 10 times before timing out
		if (i >= 10) {
			//there was no response to the first command
			errorCode = 1;
    5488:	ff 24       	eor	r15, r15
    548a:	f3 94       	inc	r15
    548c:	8f ef       	ldi	r24, 0xFF	; 255
    548e:	93 ec       	ldi	r25, 0xC3	; 195
    5490:	a9 e0       	ldi	r26, 0x09	; 9
    5492:	81 50       	subi	r24, 0x01	; 1
    5494:	90 40       	sbci	r25, 0x00	; 0
    5496:	a0 40       	sbci	r26, 0x00	; 0
    5498:	e1 f7       	brne	.-8      	; 0x5492 <SD_init+0xb2>
    549a:	00 c0       	rjmp	.+0      	; 0x549c <SD_init+0xbc>
    549c:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    549e:	cb e0       	ldi	r28, 0x0B	; 11
    54a0:	d0 e0       	ldi	r29, 0x00	; 0
    54a2:	02 c0       	rjmp	.+4      	; 0x54a8 <SD_init+0xc8>
    54a4:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    54a6:	69 f0       	breq	.+26     	; 0x54c2 <SD_init+0xe2>
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    54a8:	88 e0       	ldi	r24, 0x08	; 8
    54aa:	4a ea       	ldi	r20, 0xAA	; 170
    54ac:	51 e0       	ldi	r21, 0x01	; 1
    54ae:	60 e0       	ldi	r22, 0x00	; 0
    54b0:	70 e0       	ldi	r23, 0x00	; 0
    54b2:	27 e8       	ldi	r18, 0x87	; 135
    54b4:	08 e0       	ldi	r16, 0x08	; 8
    54b6:	10 e0       	ldi	r17, 0x00	; 0
    54b8:	0e 94 8f 29 	call	0x531e	; 0x531e <SD_command>
    54bc:	81 30       	cpi	r24, 0x01	; 1
    54be:	91 f7       	brne	.-28     	; 0x54a4 <SD_init+0xc4>
    54c0:	02 c0       	rjmp	.+4      	; 0x54c6 <SD_init+0xe6>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    54c2:	ff 24       	eor	r15, r15
    54c4:	f3 94       	inc	r15
    54c6:	c2 e0       	ldi	r28, 0x02	; 2
    54c8:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}
	}
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    54ca:	04 e3       	ldi	r16, 0x34	; 52
    54cc:	1e e3       	ldi	r17, 0x3E	; 62
    54ce:	8f ef       	ldi	r24, 0xFF	; 255
    54d0:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    54d4:	f8 01       	movw	r30, r16
    54d6:	ec 0f       	add	r30, r28
    54d8:	fd 1f       	adc	r31, r29
    54da:	80 83       	st	Z, r24
    54dc:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}
	for(int i=0;i<4;i++){
    54de:	c6 30       	cpi	r28, 0x06	; 6
    54e0:	d1 05       	cpc	r29, r1
    54e2:	a9 f7       	brne	.-22     	; 0x54ce <SD_init+0xee>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	//check that the response is the same as the argument sent in
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){
    54e4:	80 91 38 3e 	lds	r24, 0x3E38
    54e8:	81 30       	cpi	r24, 0x01	; 1
    54ea:	29 f4       	brne	.+10     	; 0x54f6 <SD_init+0x116>
    54ec:	80 91 39 3e 	lds	r24, 0x3E39
    54f0:	8a 3a       	cpi	r24, 0xAA	; 170
    54f2:	21 f4       	brne	.+8      	; 0x54fc <SD_init+0x11c>
    54f4:	05 c0       	rjmp	.+10     	; 0x5500 <SD_init+0x120>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    54f6:	ff 24       	eor	r15, r15
    54f8:	f3 94       	inc	r15
    54fa:	02 c0       	rjmp	.+4      	; 0x5500 <SD_init+0x120>
    54fc:	ff 24       	eor	r15, r15
    54fe:	f3 94       	inc	r15
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
    5500:	c5 e3       	ldi	r28, 0x35	; 53
    5502:	de e3       	ldi	r29, 0x3E	; 62
		errorCode = 1;
	}
	//send second initialization command
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
    5504:	87 e3       	ldi	r24, 0x37	; 55
    5506:	40 e0       	ldi	r20, 0x00	; 0
    5508:	50 e0       	ldi	r21, 0x00	; 0
    550a:	ba 01       	movw	r22, r20
    550c:	2f ef       	ldi	r18, 0xFF	; 255
    550e:	08 e0       	ldi	r16, 0x08	; 8
    5510:	10 e0       	ldi	r17, 0x00	; 0
    5512:	0e 94 8f 29 	call	0x531e	; 0x531e <SD_command>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
    5516:	81 e0       	ldi	r24, 0x01	; 1
    5518:	40 e0       	ldi	r20, 0x00	; 0
    551a:	50 e0       	ldi	r21, 0x00	; 0
    551c:	60 e0       	ldi	r22, 0x00	; 0
    551e:	70 e4       	ldi	r23, 0x40	; 64
    5520:	2f ef       	ldi	r18, 0xFF	; 255
    5522:	0e 94 8f 29 	call	0x531e	; 0x531e <SD_command>
	} while(Buffer[1]!= 0x00);	
    5526:	88 81       	ld	r24, Y
    5528:	88 23       	and	r24, r24
    552a:	61 f7       	brne	.-40     	; 0x5504 <SD_init+0x124>
    552c:	cb e0       	ldi	r28, 0x0B	; 11
    552e:	d0 e0       	ldi	r29, 0x00	; 0
    5530:	02 c0       	rjmp	.+4      	; 0x5536 <SD_init+0x156>
    5532:	21 97       	sbiw	r28, 0x01	; 1
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
		if (i >= 10) {
    5534:	61 f0       	breq	.+24     	; 0x554e <SD_init+0x16e>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
    5536:	8a e3       	ldi	r24, 0x3A	; 58
    5538:	40 e0       	ldi	r20, 0x00	; 0
    553a:	50 e0       	ldi	r21, 0x00	; 0
    553c:	ba 01       	movw	r22, r20
    553e:	2f ef       	ldi	r18, 0xFF	; 255
    5540:	08 e0       	ldi	r16, 0x08	; 8
    5542:	10 e0       	ldi	r17, 0x00	; 0
    5544:	0e 94 8f 29 	call	0x531e	; 0x531e <SD_command>
    5548:	88 23       	and	r24, r24
    554a:	99 f7       	brne	.-26     	; 0x5532 <SD_init+0x152>
    554c:	02 c0       	rjmp	.+4      	; 0x5552 <SD_init+0x172>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    554e:	ff 24       	eor	r15, r15
    5550:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5552:	c0 e0       	ldi	r28, 0x00	; 0
    5554:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    5556:	04 e3       	ldi	r16, 0x34	; 52
    5558:	1e e3       	ldi	r17, 0x3E	; 62
    555a:	8f ef       	ldi	r24, 0xFF	; 255
    555c:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5560:	f8 01       	movw	r30, r16
    5562:	ec 0f       	add	r30, r28
    5564:	fd 1f       	adc	r31, r29
    5566:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5568:	21 96       	adiw	r28, 0x01	; 1
    556a:	c4 30       	cpi	r28, 0x04	; 4
    556c:	d1 05       	cpc	r29, r1
    556e:	a9 f7       	brne	.-22     	; 0x555a <SD_init+0x17a>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    5570:	80 91 34 3e 	lds	r24, 0x3E34
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    5574:	80 e0       	ldi	r24, 0x00	; 0
    5576:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    557a:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	//pull SD cs high
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    557e:	88 e0       	ldi	r24, 0x08	; 8
    5580:	60 e0       	ldi	r22, 0x00	; 0
    5582:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
	
	return errorCode;					
}
    5586:	8f 2d       	mov	r24, r15
    5588:	df 91       	pop	r29
    558a:	cf 91       	pop	r28
    558c:	1f 91       	pop	r17
    558e:	0f 91       	pop	r16
    5590:	ff 90       	pop	r15
    5592:	08 95       	ret

00005594 <SD_write_block>:
	}
	return SDHC_DUMMY_BYTE;
}

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    5594:	6f 92       	push	r6
    5596:	7f 92       	push	r7
    5598:	8f 92       	push	r8
    559a:	9f 92       	push	r9
    559c:	af 92       	push	r10
    559e:	bf 92       	push	r11
    55a0:	cf 92       	push	r12
    55a2:	df 92       	push	r13
    55a4:	ef 92       	push	r14
    55a6:	ff 92       	push	r15
    55a8:	0f 93       	push	r16
    55aa:	1f 93       	push	r17
    55ac:	cf 93       	push	r28
    55ae:	df 93       	push	r29
    55b0:	4b 01       	movw	r8, r22
    55b2:	5c 01       	movw	r10, r24
    55b4:	74 2e       	mov	r7, r20
    55b6:	65 2e       	mov	r6, r21
    55b8:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    55ba:	88 e0       	ldi	r24, 0x08	; 8
    55bc:	60 e0       	ldi	r22, 0x00	; 0
    55be:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    55c2:	80 e0       	ldi	r24, 0x00	; 0
    55c4:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    55c8:	81 e0       	ldi	r24, 0x01	; 1
    55ca:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    55ce:	80 e0       	ldi	r24, 0x00	; 0
    55d0:	92 e0       	ldi	r25, 0x02	; 2
    55d2:	7c 01       	movw	r14, r24
    55d4:	ec 18       	sub	r14, r12
    55d6:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    55d8:	80 e0       	ldi	r24, 0x00	; 0
    55da:	e8 16       	cp	r14, r24
    55dc:	82 e0       	ldi	r24, 0x02	; 2
    55de:	f8 06       	cpc	r15, r24
    55e0:	11 f4       	brne	.+4      	; 0x55e6 <SD_write_block+0x52>
    55e2:	ee 24       	eor	r14, r14
    55e4:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    55e6:	cb e0       	ldi	r28, 0x0B	; 11
    55e8:	d0 e0       	ldi	r29, 0x00	; 0
    55ea:	03 c0       	rjmp	.+6      	; 0x55f2 <SD_write_block+0x5e>
    55ec:	21 97       	sbiw	r28, 0x01	; 1
	if (i >= 10) {
    55ee:	09 f4       	brne	.+2      	; 0x55f2 <SD_write_block+0x5e>
    55f0:	ff cf       	rjmp	.-2      	; 0x55f0 <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    55f2:	88 e1       	ldi	r24, 0x18	; 24
    55f4:	b5 01       	movw	r22, r10
    55f6:	a4 01       	movw	r20, r8
    55f8:	2f ef       	ldi	r18, 0xFF	; 255
    55fa:	08 e0       	ldi	r16, 0x08	; 8
    55fc:	10 e0       	ldi	r17, 0x00	; 0
    55fe:	0e 94 8f 29 	call	0x531e	; 0x531e <SD_command>
    5602:	88 23       	and	r24, r24
    5604:	99 f7       	brne	.-26     	; 0x55ec <SD_write_block+0x58>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    5606:	8f ef       	ldi	r24, 0xFF	; 255
    5608:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    560c:	80 93 34 3e 	sts	0x3E34, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    5610:	8e ef       	ldi	r24, 0xFE	; 254
    5612:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    5616:	1c 14       	cp	r1, r12
    5618:	1d 04       	cpc	r1, r13
    561a:	bc f4       	brge	.+46     	; 0x564a <SD_write_block+0xb6>
    561c:	87 2c       	mov	r8, r7
    561e:	96 2c       	mov	r9, r6
    5620:	00 e0       	ldi	r16, 0x00	; 0
    5622:	10 e0       	ldi	r17, 0x00	; 0
Buffer[i%13] = SPI_write(data[i]);
    5624:	c8 01       	movw	r24, r16
    5626:	6d e0       	ldi	r22, 0x0D	; 13
    5628:	70 e0       	ldi	r23, 0x00	; 0
    562a:	0e 94 44 39 	call	0x7288	; 0x7288 <__divmodhi4>
    562e:	ec 01       	movw	r28, r24
    5630:	f4 01       	movw	r30, r8
    5632:	81 91       	ld	r24, Z+
    5634:	4f 01       	movw	r8, r30
    5636:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    563a:	cc 5c       	subi	r28, 0xCC	; 204
    563c:	d1 4c       	sbci	r29, 0xC1	; 193
    563e:	88 83       	st	Y, r24
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    5640:	0f 5f       	subi	r16, 0xFF	; 255
    5642:	1f 4f       	sbci	r17, 0xFF	; 255
    5644:	0c 15       	cp	r16, r12
    5646:	1d 05       	cpc	r17, r13
    5648:	69 f7       	brne	.-38     	; 0x5624 <SD_write_block+0x90>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    564a:	1e 14       	cp	r1, r14
    564c:	1f 04       	cpc	r1, r15
    564e:	ec f4       	brge	.+58     	; 0x568a <SD_write_block+0xf6>
    5650:	00 e0       	ldi	r16, 0x00	; 0
    5652:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    5654:	0f 2e       	mov	r0, r31
    5656:	fd e0       	ldi	r31, 0x0D	; 13
    5658:	cf 2e       	mov	r12, r31
    565a:	dd 24       	eor	r13, r13
    565c:	f0 2d       	mov	r31, r0
    565e:	0f 2e       	mov	r0, r31
    5660:	f4 e3       	ldi	r31, 0x34	; 52
    5662:	8f 2e       	mov	r8, r31
    5664:	fe e3       	ldi	r31, 0x3E	; 62
    5666:	9f 2e       	mov	r9, r31
    5668:	f0 2d       	mov	r31, r0
    566a:	c8 01       	movw	r24, r16
    566c:	b6 01       	movw	r22, r12
    566e:	0e 94 44 39 	call	0x7288	; 0x7288 <__divmodhi4>
    5672:	ec 01       	movw	r28, r24
    5674:	80 e0       	ldi	r24, 0x00	; 0
    5676:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    567a:	c8 0d       	add	r28, r8
    567c:	d9 1d       	adc	r29, r9
    567e:	88 83       	st	Y, r24
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5680:	0f 5f       	subi	r16, 0xFF	; 255
    5682:	1f 4f       	sbci	r17, 0xFF	; 255
    5684:	0e 15       	cp	r16, r14
    5686:	1f 05       	cpc	r17, r15
    5688:	81 f7       	brne	.-32     	; 0x566a <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    568a:	8f ef       	ldi	r24, 0xFF	; 255
    568c:	80 93 34 3e 	sts	0x3E34, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    5690:	c0 e0       	ldi	r28, 0x00	; 0
    5692:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    5694:	04 e3       	ldi	r16, 0x34	; 52
    5696:	1e e3       	ldi	r17, 0x3E	; 62
    5698:	8f ef       	ldi	r24, 0xFF	; 255
    569a:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    569e:	f8 01       	movw	r30, r16
    56a0:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    56a2:	21 96       	adiw	r28, 0x01	; 1
    56a4:	c2 30       	cpi	r28, 0x02	; 2
    56a6:	d1 05       	cpc	r29, r1
    56a8:	bc f3       	brlt	.-18     	; 0x5698 <SD_write_block+0x104>
    56aa:	80 81       	ld	r24, Z
    56ac:	8f 3f       	cpi	r24, 0xFF	; 255
    56ae:	a1 f3       	breq	.-24     	; 0x5698 <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    56b0:	80 91 34 3e 	lds	r24, 0x3E34
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    56b4:	80 91 34 3e 	lds	r24, 0x3E34
    56b8:	8f 3f       	cpi	r24, 0xFF	; 255
    56ba:	49 f0       	breq	.+18     	; 0x56ce <SD_write_block+0x13a>
    56bc:	c4 e3       	ldi	r28, 0x34	; 52
    56be:	de e3       	ldi	r29, 0x3E	; 62
    56c0:	8f ef       	ldi	r24, 0xFF	; 255
    56c2:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    56c6:	88 83       	st	Y, r24
    56c8:	88 81       	ld	r24, Y
    56ca:	8f 3f       	cpi	r24, 0xFF	; 255
    56cc:	c9 f7       	brne	.-14     	; 0x56c0 <SD_write_block+0x12c>
	SPICS(FALSE);
    56ce:	80 e0       	ldi	r24, 0x00	; 0
    56d0:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    56d4:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    56d8:	88 e0       	ldi	r24, 0x08	; 8
    56da:	60 e0       	ldi	r22, 0x00	; 0
    56dc:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
}
    56e0:	df 91       	pop	r29
    56e2:	cf 91       	pop	r28
    56e4:	1f 91       	pop	r17
    56e6:	0f 91       	pop	r16
    56e8:	ff 90       	pop	r15
    56ea:	ef 90       	pop	r14
    56ec:	df 90       	pop	r13
    56ee:	cf 90       	pop	r12
    56f0:	bf 90       	pop	r11
    56f2:	af 90       	pop	r10
    56f4:	9f 90       	pop	r9
    56f6:	8f 90       	pop	r8
    56f8:	7f 90       	pop	r7
    56fa:	6f 90       	pop	r6
    56fc:	08 95       	ret

000056fe <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    56fe:	af 92       	push	r10
    5700:	bf 92       	push	r11
    5702:	cf 92       	push	r12
    5704:	df 92       	push	r13
    5706:	ef 92       	push	r14
    5708:	ff 92       	push	r15
    570a:	0f 93       	push	r16
    570c:	1f 93       	push	r17
    570e:	cf 93       	push	r28
    5710:	df 93       	push	r29
    5712:	6b 01       	movw	r12, r22
    5714:	7c 01       	movw	r14, r24
    5716:	b4 2e       	mov	r11, r20
    5718:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    571a:	88 e0       	ldi	r24, 0x08	; 8
    571c:	60 e0       	ldi	r22, 0x00	; 0
    571e:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5722:	80 e0       	ldi	r24, 0x00	; 0
    5724:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    5728:	81 e0       	ldi	r24, 0x01	; 1
    572a:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    572e:	cb e0       	ldi	r28, 0x0B	; 11
    5730:	d0 e0       	ldi	r29, 0x00	; 0
    5732:	03 c0       	rjmp	.+6      	; 0x573a <SD_read_block+0x3c>
    5734:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    5736:	09 f4       	brne	.+2      	; 0x573a <SD_read_block+0x3c>
    5738:	ff cf       	rjmp	.-2      	; 0x5738 <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    573a:	81 e1       	ldi	r24, 0x11	; 17
    573c:	b7 01       	movw	r22, r14
    573e:	a6 01       	movw	r20, r12
    5740:	2f ef       	ldi	r18, 0xFF	; 255
    5742:	08 e0       	ldi	r16, 0x08	; 8
    5744:	10 e0       	ldi	r17, 0x00	; 0
    5746:	0e 94 8f 29 	call	0x531e	; 0x531e <SD_command>
    574a:	88 23       	and	r24, r24
    574c:	99 f7       	brne	.-26     	; 0x5734 <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    574e:	80 91 34 3e 	lds	r24, 0x3E34
    5752:	8e 3f       	cpi	r24, 0xFE	; 254
    5754:	49 f0       	breq	.+18     	; 0x5768 <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    5756:	c4 e3       	ldi	r28, 0x34	; 52
    5758:	de e3       	ldi	r29, 0x3E	; 62
    575a:	8f ef       	ldi	r24, 0xFF	; 255
    575c:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5760:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    5762:	88 81       	ld	r24, Y
    5764:	8e 3f       	cpi	r24, 0xFE	; 254
    5766:	c9 f7       	brne	.-14     	; 0x575a <SD_read_block+0x5c>
    5768:	0b 2d       	mov	r16, r11
    576a:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    576c:	c0 e0       	ldi	r28, 0x00	; 0
    576e:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5770:	8f ef       	ldi	r24, 0xFF	; 255
    5772:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5776:	f8 01       	movw	r30, r16
    5778:	81 93       	st	Z+, r24
    577a:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    577c:	21 96       	adiw	r28, 0x01	; 1
    577e:	f2 e0       	ldi	r31, 0x02	; 2
    5780:	c0 30       	cpi	r28, 0x00	; 0
    5782:	df 07       	cpc	r29, r31
    5784:	a9 f7       	brne	.-22     	; 0x5770 <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    5786:	10 92 40 3e 	sts	0x3E40, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    578a:	80 91 40 3e 	lds	r24, 0x3E40
    578e:	8f 3f       	cpi	r24, 0xFF	; 255
    5790:	49 f0       	breq	.+18     	; 0x57a4 <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    5792:	c0 e4       	ldi	r28, 0x40	; 64
    5794:	de e3       	ldi	r29, 0x3E	; 62
    5796:	8f ef       	ldi	r24, 0xFF	; 255
    5798:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    579c:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    579e:	88 81       	ld	r24, Y
    57a0:	8f 3f       	cpi	r24, 0xFF	; 255
    57a2:	c9 f7       	brne	.-14     	; 0x5796 <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    57a4:	80 e0       	ldi	r24, 0x00	; 0
    57a6:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    57aa:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    57ae:	88 e0       	ldi	r24, 0x08	; 8
    57b0:	60 e0       	ldi	r22, 0x00	; 0
    57b2:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
}
    57b6:	df 91       	pop	r29
    57b8:	cf 91       	pop	r28
    57ba:	1f 91       	pop	r17
    57bc:	0f 91       	pop	r16
    57be:	ff 90       	pop	r15
    57c0:	ef 90       	pop	r14
    57c2:	df 90       	pop	r13
    57c4:	cf 90       	pop	r12
    57c6:	bf 90       	pop	r11
    57c8:	af 90       	pop	r10
    57ca:	08 95       	ret

000057cc <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    57cc:	2f 92       	push	r2
    57ce:	3f 92       	push	r3
    57d0:	4f 92       	push	r4
    57d2:	5f 92       	push	r5
    57d4:	6f 92       	push	r6
    57d6:	7f 92       	push	r7
    57d8:	8f 92       	push	r8
    57da:	9f 92       	push	r9
    57dc:	af 92       	push	r10
    57de:	bf 92       	push	r11
    57e0:	cf 92       	push	r12
    57e2:	df 92       	push	r13
    57e4:	ef 92       	push	r14
    57e6:	ff 92       	push	r15
    57e8:	0f 93       	push	r16
    57ea:	1f 93       	push	r17
    57ec:	cf 93       	push	r28
    57ee:	df 93       	push	r29
    57f0:	cd b7       	in	r28, 0x3d	; 61
    57f2:	de b7       	in	r29, 0x3e	; 62
    57f4:	2a 97       	sbiw	r28, 0x0a	; 10
    57f6:	cd bf       	out	0x3d, r28	; 61
    57f8:	de bf       	out	0x3e, r29	; 62
    57fa:	6b 01       	movw	r12, r22
    57fc:	7c 01       	movw	r14, r24
    57fe:	4f 83       	std	Y+7, r20	; 0x07
    5800:	58 87       	std	Y+8, r21	; 0x08
    5802:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5804:	88 e0       	ldi	r24, 0x08	; 8
    5806:	60 e0       	ldi	r22, 0x00	; 0
    5808:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    580c:	80 e0       	ldi	r24, 0x00	; 0
    580e:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    5812:	81 e0       	ldi	r24, 0x01	; 1
    5814:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    5818:	c8 01       	movw	r24, r16
    581a:	11 23       	and	r17, r17
    581c:	14 f4       	brge	.+4      	; 0x5822 <SD_write_multiple_blocks+0x56>
    581e:	81 50       	subi	r24, 0x01	; 1
    5820:	9e 4f       	sbci	r25, 0xFE	; 254
    5822:	9c 01       	movw	r18, r24
    5824:	23 2f       	mov	r18, r19
    5826:	33 0f       	add	r19, r19
    5828:	33 0b       	sbc	r19, r19
    582a:	25 95       	asr	r18
    582c:	2b 83       	std	Y+3, r18	; 0x03
    582e:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    5830:	20 e0       	ldi	r18, 0x00	; 0
    5832:	32 e0       	ldi	r19, 0x02	; 2
    5834:	c8 01       	movw	r24, r16
    5836:	b9 01       	movw	r22, r18
    5838:	0e 94 44 39 	call	0x7288	; 0x7288 <__divmodhi4>
    583c:	29 01       	movw	r4, r18
    583e:	48 1a       	sub	r4, r24
    5840:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5842:	30 e0       	ldi	r19, 0x00	; 0
    5844:	43 16       	cp	r4, r19
    5846:	32 e0       	ldi	r19, 0x02	; 2
    5848:	53 06       	cpc	r5, r19
    584a:	31 f0       	breq	.+12     	; 0x5858 <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    584c:	8b 81       	ldd	r24, Y+3	; 0x03
    584e:	9c 81       	ldd	r25, Y+4	; 0x04
    5850:	01 96       	adiw	r24, 0x01	; 1
    5852:	8b 83       	std	Y+3, r24	; 0x03
    5854:	9c 83       	std	Y+4, r25	; 0x04
    5856:	02 c0       	rjmp	.+4      	; 0x585c <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5858:	44 24       	eor	r4, r4
    585a:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    585c:	89 e1       	ldi	r24, 0x19	; 25
    585e:	b7 01       	movw	r22, r14
    5860:	a6 01       	movw	r20, r12
    5862:	2f ef       	ldi	r18, 0xFF	; 255
    5864:	08 e0       	ldi	r16, 0x08	; 8
    5866:	10 e0       	ldi	r17, 0x00	; 0
    5868:	0e 94 8f 29 	call	0x531e	; 0x531e <SD_command>
    586c:	88 23       	and	r24, r24
    586e:	b1 f7       	brne	.-20     	; 0x585c <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    5870:	eb 81       	ldd	r30, Y+3	; 0x03
    5872:	fc 81       	ldd	r31, Y+4	; 0x04
    5874:	1e 16       	cp	r1, r30
    5876:	1f 06       	cpc	r1, r31
    5878:	0c f0       	brlt	.+2      	; 0x587c <SD_write_multiple_blocks+0xb0>
    587a:	ac c0       	rjmp	.+344    	; 0x59d4 <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    587c:	31 97       	sbiw	r30, 0x01	; 1
    587e:	ed 83       	std	Y+5, r30	; 0x05
    5880:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5882:	9f 01       	movw	r18, r30
    5884:	32 2f       	mov	r19, r18
    5886:	22 27       	eor	r18, r18
    5888:	33 0f       	add	r19, r19
    588a:	8f 81       	ldd	r24, Y+7	; 0x07
    588c:	98 85       	ldd	r25, Y+8	; 0x08
    588e:	89 83       	std	Y+1, r24	; 0x01
    5890:	9a 83       	std	Y+2, r25	; 0x02
    5892:	66 24       	eor	r6, r6
    5894:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    5896:	0f 2e       	mov	r0, r31
    5898:	f5 e3       	ldi	r31, 0x35	; 53
    589a:	8f 2e       	mov	r8, r31
    589c:	fe e3       	ldi	r31, 0x3E	; 62
    589e:	9f 2e       	mov	r9, r31
    58a0:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    58a2:	0f 2e       	mov	r0, r31
    58a4:	fc e0       	ldi	r31, 0x0C	; 12
    58a6:	cf 2e       	mov	r12, r31
    58a8:	dd 24       	eor	r13, r13
    58aa:	f0 2d       	mov	r31, r0
    58ac:	0f 2e       	mov	r0, r31
    58ae:	f4 e3       	ldi	r31, 0x34	; 52
    58b0:	af 2e       	mov	r10, r31
    58b2:	fe e3       	ldi	r31, 0x3E	; 62
    58b4:	bf 2e       	mov	r11, r31
    58b6:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    58b8:	80 e0       	ldi	r24, 0x00	; 0
    58ba:	92 e0       	ldi	r25, 0x02	; 2
    58bc:	1c 01       	movw	r2, r24
    58be:	24 18       	sub	r2, r4
    58c0:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    58c2:	ef 81       	ldd	r30, Y+7	; 0x07
    58c4:	f8 85       	ldd	r31, Y+8	; 0x08
    58c6:	e2 0f       	add	r30, r18
    58c8:	f3 1f       	adc	r31, r19
    58ca:	ef 83       	std	Y+7, r30	; 0x07
    58cc:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    58ce:	8f ef       	ldi	r24, 0xFF	; 255
    58d0:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    58d4:	f4 01       	movw	r30, r8
    58d6:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    58d8:	8c ef       	ldi	r24, 0xFC	; 252
    58da:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    58de:	f4 01       	movw	r30, r8
    58e0:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    58e2:	2d 81       	ldd	r18, Y+5	; 0x05
    58e4:	3e 81       	ldd	r19, Y+6	; 0x06
    58e6:	26 15       	cp	r18, r6
    58e8:	37 05       	cpc	r19, r7
    58ea:	09 f0       	breq	.+2      	; 0x58ee <SD_write_multiple_blocks+0x122>
    58ec:	41 c0       	rjmp	.+130    	; 0x5970 <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    58ee:	12 14       	cp	r1, r2
    58f0:	13 04       	cpc	r1, r3
    58f2:	cc f4       	brge	.+50     	; 0x5926 <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    58f4:	ef 80       	ldd	r14, Y+7	; 0x07
    58f6:	f8 84       	ldd	r15, Y+8	; 0x08
    58f8:	00 e0       	ldi	r16, 0x00	; 0
    58fa:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    58fc:	c8 01       	movw	r24, r16
    58fe:	b6 01       	movw	r22, r12
    5900:	0e 94 44 39 	call	0x7288	; 0x7288 <__divmodhi4>
    5904:	89 87       	std	Y+9, r24	; 0x09
    5906:	9a 87       	std	Y+10, r25	; 0x0a
    5908:	f7 01       	movw	r30, r14
    590a:	81 91       	ld	r24, Z+
    590c:	7f 01       	movw	r14, r30
    590e:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5912:	e9 85       	ldd	r30, Y+9	; 0x09
    5914:	fa 85       	ldd	r31, Y+10	; 0x0a
    5916:	ea 0d       	add	r30, r10
    5918:	fb 1d       	adc	r31, r11
    591a:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    591c:	0f 5f       	subi	r16, 0xFF	; 255
    591e:	1f 4f       	sbci	r17, 0xFF	; 255
    5920:	02 15       	cp	r16, r2
    5922:	13 05       	cpc	r17, r3
    5924:	59 f7       	brne	.-42     	; 0x58fc <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5926:	14 14       	cp	r1, r4
    5928:	15 04       	cpc	r1, r5
    592a:	9c f4       	brge	.+38     	; 0x5952 <SD_write_multiple_blocks+0x186>
    592c:	00 e0       	ldi	r16, 0x00	; 0
    592e:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    5930:	c8 01       	movw	r24, r16
    5932:	b6 01       	movw	r22, r12
    5934:	0e 94 44 39 	call	0x7288	; 0x7288 <__divmodhi4>
    5938:	7c 01       	movw	r14, r24
    593a:	80 e0       	ldi	r24, 0x00	; 0
    593c:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5940:	f5 01       	movw	r30, r10
    5942:	ee 0d       	add	r30, r14
    5944:	ff 1d       	adc	r31, r15
    5946:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5948:	0f 5f       	subi	r16, 0xFF	; 255
    594a:	1f 4f       	sbci	r17, 0xFF	; 255
    594c:	04 15       	cp	r16, r4
    594e:	15 05       	cpc	r17, r5
    5950:	79 f7       	brne	.-34     	; 0x5930 <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    5952:	8f ef       	ldi	r24, 0xFF	; 255
    5954:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5958:	f4 01       	movw	r30, r8
    595a:	80 83       	st	Z, r24
    595c:	8f ef       	ldi	r24, 0xFF	; 255
    595e:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5962:	f4 01       	movw	r30, r8
    5964:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    5966:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5968:	80 81       	ld	r24, Z
    596a:	8f 3f       	cpi	r24, 0xFF	; 255
    596c:	e1 f4       	brne	.+56     	; 0x59a6 <SD_write_multiple_blocks+0x1da>
    596e:	23 c0       	rjmp	.+70     	; 0x59b6 <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5970:	e9 80       	ldd	r14, Y+1	; 0x01
    5972:	fa 80       	ldd	r15, Y+2	; 0x02
    5974:	00 e0       	ldi	r16, 0x00	; 0
    5976:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5978:	c8 01       	movw	r24, r16
    597a:	b6 01       	movw	r22, r12
    597c:	0e 94 44 39 	call	0x7288	; 0x7288 <__divmodhi4>
    5980:	89 87       	std	Y+9, r24	; 0x09
    5982:	9a 87       	std	Y+10, r25	; 0x0a
    5984:	f7 01       	movw	r30, r14
    5986:	81 91       	ld	r24, Z+
    5988:	7f 01       	movw	r14, r30
    598a:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    598e:	e9 85       	ldd	r30, Y+9	; 0x09
    5990:	fa 85       	ldd	r31, Y+10	; 0x0a
    5992:	ea 0d       	add	r30, r10
    5994:	fb 1d       	adc	r31, r11
    5996:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5998:	0f 5f       	subi	r16, 0xFF	; 255
    599a:	1f 4f       	sbci	r17, 0xFF	; 255
    599c:	f2 e0       	ldi	r31, 0x02	; 2
    599e:	00 30       	cpi	r16, 0x00	; 0
    59a0:	1f 07       	cpc	r17, r31
    59a2:	51 f7       	brne	.-44     	; 0x5978 <SD_write_multiple_blocks+0x1ac>
    59a4:	d6 cf       	rjmp	.-84     	; 0x5952 <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    59a6:	8f ef       	ldi	r24, 0xFF	; 255
    59a8:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    59ac:	f4 01       	movw	r30, r8
    59ae:	80 83       	st	Z, r24
    59b0:	80 81       	ld	r24, Z
    59b2:	8f 3f       	cpi	r24, 0xFF	; 255
    59b4:	c1 f7       	brne	.-16     	; 0x59a6 <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    59b6:	08 94       	sec
    59b8:	61 1c       	adc	r6, r1
    59ba:	71 1c       	adc	r7, r1
    59bc:	29 81       	ldd	r18, Y+1	; 0x01
    59be:	3a 81       	ldd	r19, Y+2	; 0x02
    59c0:	20 50       	subi	r18, 0x00	; 0
    59c2:	3e 4f       	sbci	r19, 0xFE	; 254
    59c4:	29 83       	std	Y+1, r18	; 0x01
    59c6:	3a 83       	std	Y+2, r19	; 0x02
    59c8:	8b 81       	ldd	r24, Y+3	; 0x03
    59ca:	9c 81       	ldd	r25, Y+4	; 0x04
    59cc:	68 16       	cp	r6, r24
    59ce:	79 06       	cpc	r7, r25
    59d0:	09 f0       	breq	.+2      	; 0x59d4 <SD_write_multiple_blocks+0x208>
    59d2:	7d cf       	rjmp	.-262    	; 0x58ce <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    59d4:	ee 24       	eor	r14, r14
    59d6:	ff 24       	eor	r15, r15
    59d8:	68 94       	set
    59da:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    59dc:	05 e3       	ldi	r16, 0x35	; 53
    59de:	1e e3       	ldi	r17, 0x3E	; 62
    59e0:	8f ef       	ldi	r24, 0xFF	; 255
    59e2:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    59e6:	f8 01       	movw	r30, r16
    59e8:	80 83       	st	Z, r24
    59ea:	08 94       	sec
    59ec:	e1 08       	sbc	r14, r1
    59ee:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    59f0:	e1 14       	cp	r14, r1
    59f2:	f1 04       	cpc	r15, r1
    59f4:	a9 f7       	brne	.-22     	; 0x59e0 <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    59f6:	8d ef       	ldi	r24, 0xFD	; 253
    59f8:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    59fc:	80 93 35 3e 	sts	0x3E35, r24
    5a00:	ee 24       	eor	r14, r14
    5a02:	ff 24       	eor	r15, r15
    5a04:	68 94       	set
    5a06:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5a08:	05 e3       	ldi	r16, 0x35	; 53
    5a0a:	1e e3       	ldi	r17, 0x3E	; 62
    5a0c:	8f ef       	ldi	r24, 0xFF	; 255
    5a0e:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5a12:	f8 01       	movw	r30, r16
    5a14:	80 83       	st	Z, r24
    5a16:	08 94       	sec
    5a18:	e1 08       	sbc	r14, r1
    5a1a:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    5a1c:	e1 14       	cp	r14, r1
    5a1e:	f1 04       	cpc	r15, r1
    5a20:	a9 f7       	brne	.-22     	; 0x5a0c <SD_write_multiple_blocks+0x240>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    5a22:	10 92 35 3e 	sts	0x3E35, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5a26:	80 91 35 3e 	lds	r24, 0x3E35
    5a2a:	8f 3f       	cpi	r24, 0xFF	; 255
    5a2c:	51 f0       	breq	.+20     	; 0x5a42 <SD_write_multiple_blocks+0x276>
    5a2e:	05 e3       	ldi	r16, 0x35	; 53
    5a30:	1e e3       	ldi	r17, 0x3E	; 62
    5a32:	8f ef       	ldi	r24, 0xFF	; 255
    5a34:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5a38:	f8 01       	movw	r30, r16
    5a3a:	80 83       	st	Z, r24
    5a3c:	80 81       	ld	r24, Z
    5a3e:	8f 3f       	cpi	r24, 0xFF	; 255
    5a40:	c1 f7       	brne	.-16     	; 0x5a32 <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    5a42:	80 e0       	ldi	r24, 0x00	; 0
    5a44:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5a48:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5a4c:	88 e0       	ldi	r24, 0x08	; 8
    5a4e:	60 e0       	ldi	r22, 0x00	; 0
    5a50:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
}
    5a54:	2a 96       	adiw	r28, 0x0a	; 10
    5a56:	cd bf       	out	0x3d, r28	; 61
    5a58:	de bf       	out	0x3e, r29	; 62
    5a5a:	df 91       	pop	r29
    5a5c:	cf 91       	pop	r28
    5a5e:	1f 91       	pop	r17
    5a60:	0f 91       	pop	r16
    5a62:	ff 90       	pop	r15
    5a64:	ef 90       	pop	r14
    5a66:	df 90       	pop	r13
    5a68:	cf 90       	pop	r12
    5a6a:	bf 90       	pop	r11
    5a6c:	af 90       	pop	r10
    5a6e:	9f 90       	pop	r9
    5a70:	8f 90       	pop	r8
    5a72:	7f 90       	pop	r7
    5a74:	6f 90       	pop	r6
    5a76:	5f 90       	pop	r5
    5a78:	4f 90       	pop	r4
    5a7a:	3f 90       	pop	r3
    5a7c:	2f 90       	pop	r2
    5a7e:	08 95       	ret

00005a80 <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    5a80:	2f 92       	push	r2
    5a82:	3f 92       	push	r3
    5a84:	4f 92       	push	r4
    5a86:	5f 92       	push	r5
    5a88:	6f 92       	push	r6
    5a8a:	7f 92       	push	r7
    5a8c:	8f 92       	push	r8
    5a8e:	9f 92       	push	r9
    5a90:	af 92       	push	r10
    5a92:	bf 92       	push	r11
    5a94:	cf 92       	push	r12
    5a96:	df 92       	push	r13
    5a98:	ef 92       	push	r14
    5a9a:	ff 92       	push	r15
    5a9c:	0f 93       	push	r16
    5a9e:	1f 93       	push	r17
    5aa0:	cf 93       	push	r28
    5aa2:	df 93       	push	r29
    5aa4:	6b 01       	movw	r12, r22
    5aa6:	7c 01       	movw	r14, r24
    5aa8:	c4 2f       	mov	r28, r20
    5aaa:	85 2e       	mov	r8, r21
    5aac:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5aae:	88 e0       	ldi	r24, 0x08	; 8
    5ab0:	60 e0       	ldi	r22, 0x00	; 0
    5ab2:	0e 94 60 04 	call	0x8c0	; 0x8c0 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5ab6:	80 e0       	ldi	r24, 0x00	; 0
    5ab8:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    5abc:	81 e0       	ldi	r24, 0x01	; 1
    5abe:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    5ac2:	82 e1       	ldi	r24, 0x12	; 18
    5ac4:	b7 01       	movw	r22, r14
    5ac6:	a6 01       	movw	r20, r12
    5ac8:	2f ef       	ldi	r18, 0xFF	; 255
    5aca:	08 e0       	ldi	r16, 0x08	; 8
    5acc:	10 e0       	ldi	r17, 0x00	; 0
    5ace:	0e 94 8f 29 	call	0x531e	; 0x531e <SD_command>
    5ad2:	88 23       	and	r24, r24
    5ad4:	b1 f7       	brne	.-20     	; 0x5ac2 <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5ad6:	16 14       	cp	r1, r6
    5ad8:	17 04       	cpc	r1, r7
    5ada:	0c f0       	brlt	.+2      	; 0x5ade <SD_read_multiple_blocks+0x5e>
    5adc:	46 c0       	rjmp	.+140    	; 0x5b6a <SD_read_multiple_blocks+0xea>
    5ade:	ac 2e       	mov	r10, r28
    5ae0:	b8 2c       	mov	r11, r8
    5ae2:	88 24       	eor	r8, r8
    5ae4:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    5ae6:	0f 2e       	mov	r0, r31
    5ae8:	f5 e3       	ldi	r31, 0x35	; 53
    5aea:	cf 2e       	mov	r12, r31
    5aec:	fe e3       	ldi	r31, 0x3E	; 62
    5aee:	df 2e       	mov	r13, r31
    5af0:	f0 2d       	mov	r31, r0
    5af2:	ff 24       	eor	r15, r15
    5af4:	fa 94       	dec	r15
    5af6:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5af8:	0f 2e       	mov	r0, r31
    5afa:	f4 e3       	ldi	r31, 0x34	; 52
    5afc:	4f 2e       	mov	r4, r31
    5afe:	fe e3       	ldi	r31, 0x3E	; 62
    5b00:	5f 2e       	mov	r5, r31
    5b02:	f0 2d       	mov	r31, r0
    5b04:	12 01       	movw	r2, r4
    5b06:	08 94       	sec
    5b08:	21 1c       	adc	r2, r1
    5b0a:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    5b0c:	f6 01       	movw	r30, r12
    5b0e:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5b10:	80 81       	ld	r24, Z
    5b12:	8e 3f       	cpi	r24, 0xFE	; 254
    5b14:	41 f0       	breq	.+16     	; 0x5b26 <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    5b16:	8f 2d       	mov	r24, r15
    5b18:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5b1c:	f6 01       	movw	r30, r12
    5b1e:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5b20:	80 81       	ld	r24, Z
    5b22:	8e 3f       	cpi	r24, 0xFE	; 254
    5b24:	c1 f7       	brne	.-16     	; 0x5b16 <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5b26:	85 01       	movw	r16, r10
    5b28:	c0 e0       	ldi	r28, 0x00	; 0
    5b2a:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5b2c:	8f 2d       	mov	r24, r15
    5b2e:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5b32:	f8 01       	movw	r30, r16
    5b34:	81 93       	st	Z+, r24
    5b36:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5b38:	21 96       	adiw	r28, 0x01	; 1
    5b3a:	f2 e0       	ldi	r31, 0x02	; 2
    5b3c:	c0 30       	cpi	r28, 0x00	; 0
    5b3e:	df 07       	cpc	r29, r31
    5b40:	a9 f7       	brne	.-22     	; 0x5b2c <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5b42:	8f 2d       	mov	r24, r15
    5b44:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5b48:	f2 01       	movw	r30, r4
    5b4a:	80 83       	st	Z, r24
    5b4c:	8f 2d       	mov	r24, r15
    5b4e:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5b52:	f1 01       	movw	r30, r2
    5b54:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5b56:	08 94       	sec
    5b58:	81 1c       	adc	r8, r1
    5b5a:	91 1c       	adc	r9, r1
    5b5c:	80 e0       	ldi	r24, 0x00	; 0
    5b5e:	92 e0       	ldi	r25, 0x02	; 2
    5b60:	a8 0e       	add	r10, r24
    5b62:	b9 1e       	adc	r11, r25
    5b64:	86 14       	cp	r8, r6
    5b66:	97 04       	cpc	r9, r7
    5b68:	89 f6       	brne	.-94     	; 0x5b0c <SD_read_multiple_blocks+0x8c>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    5b6a:	8c e0       	ldi	r24, 0x0C	; 12
    5b6c:	40 e0       	ldi	r20, 0x00	; 0
    5b6e:	50 e0       	ldi	r21, 0x00	; 0
    5b70:	ba 01       	movw	r22, r20
    5b72:	2f ef       	ldi	r18, 0xFF	; 255
    5b74:	08 e0       	ldi	r16, 0x08	; 8
    5b76:	10 e0       	ldi	r17, 0x00	; 0
    5b78:	0e 94 8f 29 	call	0x531e	; 0x531e <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    5b7c:	8f ef       	ldi	r24, 0xFF	; 255
    5b7e:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5b82:	80 93 34 3e 	sts	0x3E34, r24
	Buffer[1] = FILLER_BYTE;
    5b86:	10 92 35 3e 	sts	0x3E35, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5b8a:	80 91 35 3e 	lds	r24, 0x3E35
    5b8e:	8f 3f       	cpi	r24, 0xFF	; 255
    5b90:	49 f0       	breq	.+18     	; 0x5ba4 <SD_read_multiple_blocks+0x124>
    5b92:	c5 e3       	ldi	r28, 0x35	; 53
    5b94:	de e3       	ldi	r29, 0x3E	; 62
    5b96:	8f ef       	ldi	r24, 0xFF	; 255
    5b98:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
    5b9c:	88 83       	st	Y, r24
    5b9e:	88 81       	ld	r24, Y
    5ba0:	8f 3f       	cpi	r24, 0xFF	; 255
    5ba2:	c9 f7       	brne	.-14     	; 0x5b96 <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    5ba4:	80 e0       	ldi	r24, 0x00	; 0
    5ba6:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5baa:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5bae:	88 e0       	ldi	r24, 0x08	; 8
    5bb0:	60 e0       	ldi	r22, 0x00	; 0
    5bb2:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
}
    5bb6:	df 91       	pop	r29
    5bb8:	cf 91       	pop	r28
    5bba:	1f 91       	pop	r17
    5bbc:	0f 91       	pop	r16
    5bbe:	ff 90       	pop	r15
    5bc0:	ef 90       	pop	r14
    5bc2:	df 90       	pop	r13
    5bc4:	cf 90       	pop	r12
    5bc6:	bf 90       	pop	r11
    5bc8:	af 90       	pop	r10
    5bca:	9f 90       	pop	r9
    5bcc:	8f 90       	pop	r8
    5bce:	7f 90       	pop	r7
    5bd0:	6f 90       	pop	r6
    5bd2:	5f 90       	pop	r5
    5bd4:	4f 90       	pop	r4
    5bd6:	3f 90       	pop	r3
    5bd8:	2f 90       	pop	r2
    5bda:	08 95       	ret

00005bdc <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    5bdc:	88 e0       	ldi	r24, 0x08	; 8
    5bde:	60 e0       	ldi	r22, 0x00	; 0
    5be0:	0e 94 64 05 	call	0xac8	; 0xac8 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    5be4:	88 e0       	ldi	r24, 0x08	; 8
    5be6:	60 e0       	ldi	r22, 0x00	; 0
    5be8:	0e 94 b7 04 	call	0x96e	; 0x96e <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    5bec:	80 e0       	ldi	r24, 0x00	; 0
    5bee:	0e 94 c4 03 	call	0x788	; 0x788 <SPIInit>
	SPICS(TRUE);
    5bf2:	81 e0       	ldi	r24, 0x01	; 1
    5bf4:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    5bf8:	8f ef       	ldi	r24, 0xFF	; 255
    5bfa:	0e 94 d1 06 	call	0xda2	; 0xda2 <SPI_write>
	SPICS(FALSE);	//stop spi
    5bfe:	80 e0       	ldi	r24, 0x00	; 0
    5c00:	0e 94 e7 03 	call	0x7ce	; 0x7ce <SPICS>
	SPIDisable();
    5c04:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    5c08:	80 e0       	ldi	r24, 0x00	; 0
    5c0a:	0e 94 ba 05 	call	0xb74	; 0xb74 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    5c0e:	80 e0       	ldi	r24, 0x00	; 0
    5c10:	0e 94 61 03 	call	0x6c2	; 0x6c2 <Ext1Power>
}
    5c14:	08 95       	ret

00005c16 <__muldi3>:
    5c16:	a0 e3       	ldi	r26, 0x30	; 48
    5c18:	b0 e0       	ldi	r27, 0x00	; 0
    5c1a:	e1 e1       	ldi	r30, 0x11	; 17
    5c1c:	fe e2       	ldi	r31, 0x2E	; 46
    5c1e:	0c 94 aa 39 	jmp	0x7354	; 0x7354 <__prologue_saves__+0x4>
    5c22:	29 8f       	std	Y+25, r18	; 0x19
    5c24:	3a 8f       	std	Y+26, r19	; 0x1a
    5c26:	4b 8f       	std	Y+27, r20	; 0x1b
    5c28:	5c 8f       	std	Y+28, r21	; 0x1c
    5c2a:	6d 8f       	std	Y+29, r22	; 0x1d
    5c2c:	7e 8f       	std	Y+30, r23	; 0x1e
    5c2e:	8f 8f       	std	Y+31, r24	; 0x1f
    5c30:	98 a3       	lds	r25, 0x58
    5c32:	a9 8a       	std	Y+17, r10	; 0x11
    5c34:	ba 8a       	std	Y+18, r11	; 0x12
    5c36:	cb 8a       	std	Y+19, r12	; 0x13
    5c38:	dc 8a       	std	Y+20, r13	; 0x14
    5c3a:	ed 8a       	std	Y+21, r14	; 0x15
    5c3c:	fe 8a       	std	Y+22, r15	; 0x16
    5c3e:	0f 8b       	std	Y+23, r16	; 0x17
    5c40:	18 8f       	std	Y+24, r17	; 0x18
    5c42:	09 8d       	ldd	r16, Y+25	; 0x19
    5c44:	1a 8d       	ldd	r17, Y+26	; 0x1a
    5c46:	2b 8d       	ldd	r18, Y+27	; 0x1b
    5c48:	3c 8d       	ldd	r19, Y+28	; 0x1c
    5c4a:	09 a3       	lds	r16, 0x59
    5c4c:	1a a3       	lds	r17, 0x5a
    5c4e:	2b a3       	lds	r18, 0x5b
    5c50:	3c a3       	lds	r19, 0x5c
    5c52:	68 01       	movw	r12, r16
    5c54:	79 01       	movw	r14, r18
    5c56:	8f ef       	ldi	r24, 0xFF	; 255
    5c58:	9f ef       	ldi	r25, 0xFF	; 255
    5c5a:	a0 e0       	ldi	r26, 0x00	; 0
    5c5c:	b0 e0       	ldi	r27, 0x00	; 0
    5c5e:	c8 22       	and	r12, r24
    5c60:	d9 22       	and	r13, r25
    5c62:	ea 22       	and	r14, r26
    5c64:	fb 22       	and	r15, r27
    5c66:	89 01       	movw	r16, r18
    5c68:	22 27       	eor	r18, r18
    5c6a:	33 27       	eor	r19, r19
    5c6c:	09 a7       	lds	r16, 0x79
    5c6e:	1a a7       	lds	r17, 0x7a
    5c70:	2b a7       	lds	r18, 0x7b
    5c72:	3c a7       	lds	r19, 0x7c
    5c74:	09 89       	ldd	r16, Y+17	; 0x11
    5c76:	1a 89       	ldd	r17, Y+18	; 0x12
    5c78:	2b 89       	ldd	r18, Y+19	; 0x13
    5c7a:	3c 89       	ldd	r19, Y+20	; 0x14
    5c7c:	0d a3       	lds	r16, 0x5d
    5c7e:	1e a3       	lds	r17, 0x5e
    5c80:	2f a3       	lds	r18, 0x5f
    5c82:	38 a7       	lds	r19, 0x78
    5c84:	48 01       	movw	r8, r16
    5c86:	59 01       	movw	r10, r18
    5c88:	88 22       	and	r8, r24
    5c8a:	99 22       	and	r9, r25
    5c8c:	aa 22       	and	r10, r26
    5c8e:	bb 22       	and	r11, r27
    5c90:	29 01       	movw	r4, r18
    5c92:	66 24       	eor	r6, r6
    5c94:	77 24       	eor	r7, r7
    5c96:	c5 01       	movw	r24, r10
    5c98:	b4 01       	movw	r22, r8
    5c9a:	a7 01       	movw	r20, r14
    5c9c:	96 01       	movw	r18, r12
    5c9e:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    5ca2:	6d a7       	lds	r22, 0x7d
    5ca4:	7e a7       	lds	r23, 0x7e
    5ca6:	8f a7       	lds	r24, 0x7f
    5ca8:	98 ab       	sts	0x58, r25
    5caa:	c3 01       	movw	r24, r6
    5cac:	b2 01       	movw	r22, r4
    5cae:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    5cb2:	6b 01       	movw	r12, r22
    5cb4:	7c 01       	movw	r14, r24
    5cb6:	c5 01       	movw	r24, r10
    5cb8:	b4 01       	movw	r22, r8
    5cba:	29 a5       	lds	r18, 0x69
    5cbc:	3a a5       	lds	r19, 0x6a
    5cbe:	4b a5       	lds	r20, 0x6b
    5cc0:	5c a5       	lds	r21, 0x6c
    5cc2:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    5cc6:	4b 01       	movw	r8, r22
    5cc8:	5c 01       	movw	r10, r24
    5cca:	c3 01       	movw	r24, r6
    5ccc:	b2 01       	movw	r22, r4
    5cce:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    5cd2:	ab 01       	movw	r20, r22
    5cd4:	bc 01       	movw	r22, r24
    5cd6:	c8 0c       	add	r12, r8
    5cd8:	d9 1c       	adc	r13, r9
    5cda:	ea 1c       	adc	r14, r10
    5cdc:	fb 1c       	adc	r15, r11
    5cde:	0d a5       	lds	r16, 0x6d
    5ce0:	1e a5       	lds	r17, 0x6e
    5ce2:	2f a5       	lds	r18, 0x6f
    5ce4:	38 a9       	sts	0x48, r19
    5ce6:	c9 01       	movw	r24, r18
    5ce8:	aa 27       	eor	r26, r26
    5cea:	bb 27       	eor	r27, r27
    5cec:	c8 0e       	add	r12, r24
    5cee:	d9 1e       	adc	r13, r25
    5cf0:	ea 1e       	adc	r14, r26
    5cf2:	fb 1e       	adc	r15, r27
    5cf4:	c8 14       	cp	r12, r8
    5cf6:	d9 04       	cpc	r13, r9
    5cf8:	ea 04       	cpc	r14, r10
    5cfa:	fb 04       	cpc	r15, r11
    5cfc:	20 f4       	brcc	.+8      	; 0x5d06 <__muldi3+0xf0>
    5cfe:	40 50       	subi	r20, 0x00	; 0
    5d00:	50 40       	sbci	r21, 0x00	; 0
    5d02:	6f 4f       	sbci	r22, 0xFF	; 255
    5d04:	7f 4f       	sbci	r23, 0xFF	; 255
    5d06:	c7 01       	movw	r24, r14
    5d08:	aa 27       	eor	r26, r26
    5d0a:	bb 27       	eor	r27, r27
    5d0c:	84 0f       	add	r24, r20
    5d0e:	95 1f       	adc	r25, r21
    5d10:	a6 1f       	adc	r26, r22
    5d12:	b7 1f       	adc	r27, r23
    5d14:	8d 83       	std	Y+5, r24	; 0x05
    5d16:	9e 83       	std	Y+6, r25	; 0x06
    5d18:	af 83       	std	Y+7, r26	; 0x07
    5d1a:	b8 87       	std	Y+8, r27	; 0x08
    5d1c:	76 01       	movw	r14, r12
    5d1e:	dd 24       	eor	r13, r13
    5d20:	cc 24       	eor	r12, r12
    5d22:	4d a5       	lds	r20, 0x6d
    5d24:	5e a5       	lds	r21, 0x6e
    5d26:	6f a5       	lds	r22, 0x6f
    5d28:	78 a9       	sts	0x48, r23
    5d2a:	60 70       	andi	r22, 0x00	; 0
    5d2c:	70 70       	andi	r23, 0x00	; 0
    5d2e:	c4 0e       	add	r12, r20
    5d30:	d5 1e       	adc	r13, r21
    5d32:	e6 1e       	adc	r14, r22
    5d34:	f7 1e       	adc	r15, r23
    5d36:	c9 82       	std	Y+1, r12	; 0x01
    5d38:	da 82       	std	Y+2, r13	; 0x02
    5d3a:	eb 82       	std	Y+3, r14	; 0x03
    5d3c:	fc 82       	std	Y+4, r15	; 0x04
    5d3e:	1c 2d       	mov	r17, r12
    5d40:	0a 81       	ldd	r16, Y+2	; 0x02
    5d42:	8b 80       	ldd	r8, Y+3	; 0x03
    5d44:	4c 80       	ldd	r4, Y+4	; 0x04
    5d46:	8d 87       	std	Y+13, r24	; 0x0d
    5d48:	8e 81       	ldd	r24, Y+6	; 0x06
    5d4a:	8e 87       	std	Y+14, r24	; 0x0e
    5d4c:	8f 81       	ldd	r24, Y+7	; 0x07
    5d4e:	8f 87       	std	Y+15, r24	; 0x0f
    5d50:	88 85       	ldd	r24, Y+8	; 0x08
    5d52:	88 8b       	std	Y+16, r24	; 0x10
    5d54:	2d 89       	ldd	r18, Y+21	; 0x15
    5d56:	3e 89       	ldd	r19, Y+22	; 0x16
    5d58:	4f 89       	ldd	r20, Y+23	; 0x17
    5d5a:	58 8d       	ldd	r21, Y+24	; 0x18
    5d5c:	69 a1       	lds	r22, 0x49
    5d5e:	7a a1       	lds	r23, 0x4a
    5d60:	8b a1       	lds	r24, 0x4b
    5d62:	9c a1       	lds	r25, 0x4c
    5d64:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    5d68:	6b 01       	movw	r12, r22
    5d6a:	7c 01       	movw	r14, r24
    5d6c:	2d 8d       	ldd	r18, Y+29	; 0x1d
    5d6e:	3e 8d       	ldd	r19, Y+30	; 0x1e
    5d70:	4f 8d       	ldd	r20, Y+31	; 0x1f
    5d72:	58 a1       	lds	r21, 0x48
    5d74:	6d a1       	lds	r22, 0x4d
    5d76:	7e a1       	lds	r23, 0x4e
    5d78:	8f a1       	lds	r24, 0x4f
    5d7a:	98 a5       	lds	r25, 0x68
    5d7c:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    5d80:	dc 01       	movw	r26, r24
    5d82:	cb 01       	movw	r24, r22
    5d84:	c8 0e       	add	r12, r24
    5d86:	d9 1e       	adc	r13, r25
    5d88:	ea 1e       	adc	r14, r26
    5d8a:	fb 1e       	adc	r15, r27
    5d8c:	8d 85       	ldd	r24, Y+13	; 0x0d
    5d8e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5d90:	af 85       	ldd	r26, Y+15	; 0x0f
    5d92:	b8 89       	ldd	r27, Y+16	; 0x10
    5d94:	8c 0d       	add	r24, r12
    5d96:	9d 1d       	adc	r25, r13
    5d98:	ae 1d       	adc	r26, r14
    5d9a:	bf 1d       	adc	r27, r15
    5d9c:	8d 87       	std	Y+13, r24	; 0x0d
    5d9e:	9e 87       	std	Y+14, r25	; 0x0e
    5da0:	af 87       	std	Y+15, r26	; 0x0f
    5da2:	b8 8b       	std	Y+16, r27	; 0x10
    5da4:	68 2f       	mov	r22, r24
    5da6:	7e 85       	ldd	r23, Y+14	; 0x0e
    5da8:	21 2f       	mov	r18, r17
    5daa:	30 2f       	mov	r19, r16
    5dac:	48 2d       	mov	r20, r8
    5dae:	54 2d       	mov	r21, r4
    5db0:	8f 85       	ldd	r24, Y+15	; 0x0f
    5db2:	98 89       	ldd	r25, Y+16	; 0x10
    5db4:	e0 96       	adiw	r28, 0x30	; 48
    5db6:	e0 e1       	ldi	r30, 0x10	; 16
    5db8:	0c 94 c3 39 	jmp	0x7386	; 0x7386 <__epilogue_restores__+0x4>

00005dbc <__ashldi3>:
    5dbc:	cf 92       	push	r12
    5dbe:	df 92       	push	r13
    5dc0:	ef 92       	push	r14
    5dc2:	ff 92       	push	r15
    5dc4:	0f 93       	push	r16
    5dc6:	cf 93       	push	r28
    5dc8:	df 93       	push	r29
    5dca:	cd b7       	in	r28, 0x3d	; 61
    5dcc:	de b7       	in	r29, 0x3e	; 62
    5dce:	60 97       	sbiw	r28, 0x10	; 16
    5dd0:	cd bf       	out	0x3d, r28	; 61
    5dd2:	de bf       	out	0x3e, r29	; 62
    5dd4:	00 23       	and	r16, r16
    5dd6:	09 f4       	brne	.+2      	; 0x5dda <__ashldi3+0x1e>
    5dd8:	5a c0       	rjmp	.+180    	; 0x5e8e <__ashldi3+0xd2>
    5dda:	29 87       	std	Y+9, r18	; 0x09
    5ddc:	3a 87       	std	Y+10, r19	; 0x0a
    5dde:	4b 87       	std	Y+11, r20	; 0x0b
    5de0:	5c 87       	std	Y+12, r21	; 0x0c
    5de2:	6d 87       	std	Y+13, r22	; 0x0d
    5de4:	7e 87       	std	Y+14, r23	; 0x0e
    5de6:	8f 87       	std	Y+15, r24	; 0x0f
    5de8:	98 8b       	std	Y+16, r25	; 0x10
    5dea:	80 e2       	ldi	r24, 0x20	; 32
    5dec:	80 1b       	sub	r24, r16
    5dee:	49 85       	ldd	r20, Y+9	; 0x09
    5df0:	5a 85       	ldd	r21, Y+10	; 0x0a
    5df2:	6b 85       	ldd	r22, Y+11	; 0x0b
    5df4:	7c 85       	ldd	r23, Y+12	; 0x0c
    5df6:	18 16       	cp	r1, r24
    5df8:	b4 f0       	brlt	.+44     	; 0x5e26 <__ashldi3+0x6a>
    5dfa:	19 82       	std	Y+1, r1	; 0x01
    5dfc:	1a 82       	std	Y+2, r1	; 0x02
    5dfe:	1b 82       	std	Y+3, r1	; 0x03
    5e00:	1c 82       	std	Y+4, r1	; 0x04
    5e02:	99 27       	eor	r25, r25
    5e04:	87 fd       	sbrc	r24, 7
    5e06:	90 95       	com	r25
    5e08:	90 95       	com	r25
    5e0a:	81 95       	neg	r24
    5e0c:	9f 4f       	sbci	r25, 0xFF	; 255
    5e0e:	04 c0       	rjmp	.+8      	; 0x5e18 <__ashldi3+0x5c>
    5e10:	44 0f       	add	r20, r20
    5e12:	55 1f       	adc	r21, r21
    5e14:	66 1f       	adc	r22, r22
    5e16:	77 1f       	adc	r23, r23
    5e18:	8a 95       	dec	r24
    5e1a:	d2 f7       	brpl	.-12     	; 0x5e10 <__ashldi3+0x54>
    5e1c:	4d 83       	std	Y+5, r20	; 0x05
    5e1e:	5e 83       	std	Y+6, r21	; 0x06
    5e20:	6f 83       	std	Y+7, r22	; 0x07
    5e22:	78 87       	std	Y+8, r23	; 0x08
    5e24:	2c c0       	rjmp	.+88     	; 0x5e7e <__ashldi3+0xc2>
    5e26:	6a 01       	movw	r12, r20
    5e28:	7b 01       	movw	r14, r22
    5e2a:	00 2e       	mov	r0, r16
    5e2c:	04 c0       	rjmp	.+8      	; 0x5e36 <__ashldi3+0x7a>
    5e2e:	cc 0c       	add	r12, r12
    5e30:	dd 1c       	adc	r13, r13
    5e32:	ee 1c       	adc	r14, r14
    5e34:	ff 1c       	adc	r15, r15
    5e36:	0a 94       	dec	r0
    5e38:	d2 f7       	brpl	.-12     	; 0x5e2e <__ashldi3+0x72>
    5e3a:	c9 82       	std	Y+1, r12	; 0x01
    5e3c:	da 82       	std	Y+2, r13	; 0x02
    5e3e:	eb 82       	std	Y+3, r14	; 0x03
    5e40:	fc 82       	std	Y+4, r15	; 0x04
    5e42:	6a 01       	movw	r12, r20
    5e44:	7b 01       	movw	r14, r22
    5e46:	04 c0       	rjmp	.+8      	; 0x5e50 <__ashldi3+0x94>
    5e48:	f6 94       	lsr	r15
    5e4a:	e7 94       	ror	r14
    5e4c:	d7 94       	ror	r13
    5e4e:	c7 94       	ror	r12
    5e50:	8a 95       	dec	r24
    5e52:	d2 f7       	brpl	.-12     	; 0x5e48 <__ashldi3+0x8c>
    5e54:	d7 01       	movw	r26, r14
    5e56:	c6 01       	movw	r24, r12
    5e58:	4d 85       	ldd	r20, Y+13	; 0x0d
    5e5a:	5e 85       	ldd	r21, Y+14	; 0x0e
    5e5c:	6f 85       	ldd	r22, Y+15	; 0x0f
    5e5e:	78 89       	ldd	r23, Y+16	; 0x10
    5e60:	04 c0       	rjmp	.+8      	; 0x5e6a <__ashldi3+0xae>
    5e62:	44 0f       	add	r20, r20
    5e64:	55 1f       	adc	r21, r21
    5e66:	66 1f       	adc	r22, r22
    5e68:	77 1f       	adc	r23, r23
    5e6a:	0a 95       	dec	r16
    5e6c:	d2 f7       	brpl	.-12     	; 0x5e62 <__ashldi3+0xa6>
    5e6e:	84 2b       	or	r24, r20
    5e70:	95 2b       	or	r25, r21
    5e72:	a6 2b       	or	r26, r22
    5e74:	b7 2b       	or	r27, r23
    5e76:	8d 83       	std	Y+5, r24	; 0x05
    5e78:	9e 83       	std	Y+6, r25	; 0x06
    5e7a:	af 83       	std	Y+7, r26	; 0x07
    5e7c:	b8 87       	std	Y+8, r27	; 0x08
    5e7e:	29 81       	ldd	r18, Y+1	; 0x01
    5e80:	3a 81       	ldd	r19, Y+2	; 0x02
    5e82:	4b 81       	ldd	r20, Y+3	; 0x03
    5e84:	5c 81       	ldd	r21, Y+4	; 0x04
    5e86:	6d 81       	ldd	r22, Y+5	; 0x05
    5e88:	7e 81       	ldd	r23, Y+6	; 0x06
    5e8a:	8f 81       	ldd	r24, Y+7	; 0x07
    5e8c:	98 85       	ldd	r25, Y+8	; 0x08
    5e8e:	60 96       	adiw	r28, 0x10	; 16
    5e90:	cd bf       	out	0x3d, r28	; 61
    5e92:	de bf       	out	0x3e, r29	; 62
    5e94:	df 91       	pop	r29
    5e96:	cf 91       	pop	r28
    5e98:	0f 91       	pop	r16
    5e9a:	ff 90       	pop	r15
    5e9c:	ef 90       	pop	r14
    5e9e:	df 90       	pop	r13
    5ea0:	cf 90       	pop	r12
    5ea2:	08 95       	ret

00005ea4 <__ashrdi3>:
    5ea4:	0f 93       	push	r16
    5ea6:	cf 93       	push	r28
    5ea8:	df 93       	push	r29
    5eaa:	cd b7       	in	r28, 0x3d	; 61
    5eac:	de b7       	in	r29, 0x3e	; 62
    5eae:	60 97       	sbiw	r28, 0x10	; 16
    5eb0:	cd bf       	out	0x3d, r28	; 61
    5eb2:	de bf       	out	0x3e, r29	; 62
    5eb4:	00 23       	and	r16, r16
    5eb6:	09 f4       	brne	.+2      	; 0x5eba <__ashrdi3+0x16>
    5eb8:	56 c0       	rjmp	.+172    	; 0x5f66 <__ashrdi3+0xc2>
    5eba:	29 87       	std	Y+9, r18	; 0x09
    5ebc:	3a 87       	std	Y+10, r19	; 0x0a
    5ebe:	4b 87       	std	Y+11, r20	; 0x0b
    5ec0:	5c 87       	std	Y+12, r21	; 0x0c
    5ec2:	6d 87       	std	Y+13, r22	; 0x0d
    5ec4:	7e 87       	std	Y+14, r23	; 0x0e
    5ec6:	8f 87       	std	Y+15, r24	; 0x0f
    5ec8:	98 8b       	std	Y+16, r25	; 0x10
    5eca:	20 e2       	ldi	r18, 0x20	; 32
    5ecc:	20 1b       	sub	r18, r16
    5ece:	8d 85       	ldd	r24, Y+13	; 0x0d
    5ed0:	9e 85       	ldd	r25, Y+14	; 0x0e
    5ed2:	af 85       	ldd	r26, Y+15	; 0x0f
    5ed4:	b8 89       	ldd	r27, Y+16	; 0x10
    5ed6:	ac 01       	movw	r20, r24
    5ed8:	bd 01       	movw	r22, r26
    5eda:	12 16       	cp	r1, r18
    5edc:	b4 f0       	brlt	.+44     	; 0x5f0a <__ashrdi3+0x66>
    5ede:	77 0f       	add	r23, r23
    5ee0:	44 0b       	sbc	r20, r20
    5ee2:	54 2f       	mov	r21, r20
    5ee4:	ba 01       	movw	r22, r20
    5ee6:	4d 83       	std	Y+5, r20	; 0x05
    5ee8:	5e 83       	std	Y+6, r21	; 0x06
    5eea:	6f 83       	std	Y+7, r22	; 0x07
    5eec:	78 87       	std	Y+8, r23	; 0x08
    5eee:	33 27       	eor	r19, r19
    5ef0:	27 fd       	sbrc	r18, 7
    5ef2:	30 95       	com	r19
    5ef4:	30 95       	com	r19
    5ef6:	21 95       	neg	r18
    5ef8:	3f 4f       	sbci	r19, 0xFF	; 255
    5efa:	04 c0       	rjmp	.+8      	; 0x5f04 <__ashrdi3+0x60>
    5efc:	b5 95       	asr	r27
    5efe:	a7 95       	ror	r26
    5f00:	97 95       	ror	r25
    5f02:	87 95       	ror	r24
    5f04:	2a 95       	dec	r18
    5f06:	d2 f7       	brpl	.-12     	; 0x5efc <__ashrdi3+0x58>
    5f08:	22 c0       	rjmp	.+68     	; 0x5f4e <__ashrdi3+0xaa>
    5f0a:	00 2e       	mov	r0, r16
    5f0c:	04 c0       	rjmp	.+8      	; 0x5f16 <__ashrdi3+0x72>
    5f0e:	75 95       	asr	r23
    5f10:	67 95       	ror	r22
    5f12:	57 95       	ror	r21
    5f14:	47 95       	ror	r20
    5f16:	0a 94       	dec	r0
    5f18:	d2 f7       	brpl	.-12     	; 0x5f0e <__ashrdi3+0x6a>
    5f1a:	4d 83       	std	Y+5, r20	; 0x05
    5f1c:	5e 83       	std	Y+6, r21	; 0x06
    5f1e:	6f 83       	std	Y+7, r22	; 0x07
    5f20:	78 87       	std	Y+8, r23	; 0x08
    5f22:	04 c0       	rjmp	.+8      	; 0x5f2c <__ashrdi3+0x88>
    5f24:	88 0f       	add	r24, r24
    5f26:	99 1f       	adc	r25, r25
    5f28:	aa 1f       	adc	r26, r26
    5f2a:	bb 1f       	adc	r27, r27
    5f2c:	2a 95       	dec	r18
    5f2e:	d2 f7       	brpl	.-12     	; 0x5f24 <__ashrdi3+0x80>
    5f30:	49 85       	ldd	r20, Y+9	; 0x09
    5f32:	5a 85       	ldd	r21, Y+10	; 0x0a
    5f34:	6b 85       	ldd	r22, Y+11	; 0x0b
    5f36:	7c 85       	ldd	r23, Y+12	; 0x0c
    5f38:	04 c0       	rjmp	.+8      	; 0x5f42 <__ashrdi3+0x9e>
    5f3a:	76 95       	lsr	r23
    5f3c:	67 95       	ror	r22
    5f3e:	57 95       	ror	r21
    5f40:	47 95       	ror	r20
    5f42:	0a 95       	dec	r16
    5f44:	d2 f7       	brpl	.-12     	; 0x5f3a <__ashrdi3+0x96>
    5f46:	84 2b       	or	r24, r20
    5f48:	95 2b       	or	r25, r21
    5f4a:	a6 2b       	or	r26, r22
    5f4c:	b7 2b       	or	r27, r23
    5f4e:	89 83       	std	Y+1, r24	; 0x01
    5f50:	9a 83       	std	Y+2, r25	; 0x02
    5f52:	ab 83       	std	Y+3, r26	; 0x03
    5f54:	bc 83       	std	Y+4, r27	; 0x04
    5f56:	29 81       	ldd	r18, Y+1	; 0x01
    5f58:	3a 81       	ldd	r19, Y+2	; 0x02
    5f5a:	4b 81       	ldd	r20, Y+3	; 0x03
    5f5c:	5c 81       	ldd	r21, Y+4	; 0x04
    5f5e:	6d 81       	ldd	r22, Y+5	; 0x05
    5f60:	7e 81       	ldd	r23, Y+6	; 0x06
    5f62:	8f 81       	ldd	r24, Y+7	; 0x07
    5f64:	98 85       	ldd	r25, Y+8	; 0x08
    5f66:	60 96       	adiw	r28, 0x10	; 16
    5f68:	cd bf       	out	0x3d, r28	; 61
    5f6a:	de bf       	out	0x3e, r29	; 62
    5f6c:	df 91       	pop	r29
    5f6e:	cf 91       	pop	r28
    5f70:	0f 91       	pop	r16
    5f72:	08 95       	ret

00005f74 <__divdi3>:
    5f74:	a8 e4       	ldi	r26, 0x48	; 72
    5f76:	b0 e0       	ldi	r27, 0x00	; 0
    5f78:	e0 ec       	ldi	r30, 0xC0	; 192
    5f7a:	ff e2       	ldi	r31, 0x2F	; 47
    5f7c:	0c 94 a9 39 	jmp	0x7352	; 0x7352 <__prologue_saves__+0x2>
    5f80:	f5 01       	movw	r30, r10
    5f82:	29 a3       	lds	r18, 0x59
    5f84:	3a a3       	lds	r19, 0x5a
    5f86:	4b a3       	lds	r20, 0x5b
    5f88:	5c a3       	lds	r21, 0x5c
    5f8a:	6d a3       	lds	r22, 0x5d
    5f8c:	7e a3       	lds	r23, 0x5e
    5f8e:	8f a3       	lds	r24, 0x5f
    5f90:	98 a7       	lds	r25, 0x78
    5f92:	a9 8e       	std	Y+25, r10	; 0x19
    5f94:	fa 8f       	std	Y+26, r31	; 0x1a
    5f96:	cb 8e       	std	Y+27, r12	; 0x1b
    5f98:	dc 8e       	std	Y+28, r13	; 0x1c
    5f9a:	ed 8e       	std	Y+29, r14	; 0x1d
    5f9c:	fe 8e       	std	Y+30, r15	; 0x1e
    5f9e:	0f 8f       	std	Y+31, r16	; 0x1f
    5fa0:	18 a3       	lds	r17, 0x58
    5fa2:	8d a0       	lds	r24, 0x8d
    5fa4:	9e a0       	lds	r25, 0x8e
    5fa6:	af a0       	lds	r26, 0x8f
    5fa8:	b8 a4       	lds	r27, 0xa8
    5faa:	b7 fe       	sbrs	r11, 7
    5fac:	67 c0       	rjmp	.+206    	; 0x607c <__stack+0x7d>
    5fae:	21 95       	neg	r18
    5fb0:	b1 e0       	ldi	r27, 0x01	; 1
    5fb2:	12 16       	cp	r1, r18
    5fb4:	08 f0       	brcs	.+2      	; 0x5fb8 <__divdi3+0x44>
    5fb6:	b0 e0       	ldi	r27, 0x00	; 0
    5fb8:	31 95       	neg	r19
    5fba:	a1 e0       	ldi	r26, 0x01	; 1
    5fbc:	13 16       	cp	r1, r19
    5fbe:	08 f0       	brcs	.+2      	; 0x5fc2 <__divdi3+0x4e>
    5fc0:	a0 e0       	ldi	r26, 0x00	; 0
    5fc2:	b3 2e       	mov	r11, r19
    5fc4:	bb 1a       	sub	r11, r27
    5fc6:	bb 2d       	mov	r27, r11
    5fc8:	88 24       	eor	r8, r8
    5fca:	83 94       	inc	r8
    5fcc:	3b 15       	cp	r19, r11
    5fce:	08 f0       	brcs	.+2      	; 0x5fd2 <__divdi3+0x5e>
    5fd0:	88 24       	eor	r8, r8
    5fd2:	a8 29       	or	r26, r8
    5fd4:	41 95       	neg	r20
    5fd6:	31 e0       	ldi	r19, 0x01	; 1
    5fd8:	14 16       	cp	r1, r20
    5fda:	08 f0       	brcs	.+2      	; 0x5fde <__divdi3+0x6a>
    5fdc:	30 e0       	ldi	r19, 0x00	; 0
    5fde:	b4 2e       	mov	r11, r20
    5fe0:	ba 1a       	sub	r11, r26
    5fe2:	ab 2d       	mov	r26, r11
    5fe4:	88 24       	eor	r8, r8
    5fe6:	83 94       	inc	r8
    5fe8:	4b 15       	cp	r20, r11
    5fea:	08 f0       	brcs	.+2      	; 0x5fee <__divdi3+0x7a>
    5fec:	88 24       	eor	r8, r8
    5fee:	38 29       	or	r19, r8
    5ff0:	51 95       	neg	r21
    5ff2:	41 e0       	ldi	r20, 0x01	; 1
    5ff4:	15 16       	cp	r1, r21
    5ff6:	08 f0       	brcs	.+2      	; 0x5ffa <__divdi3+0x86>
    5ff8:	40 e0       	ldi	r20, 0x00	; 0
    5ffa:	45 2e       	mov	r4, r21
    5ffc:	43 1a       	sub	r4, r19
    5ffe:	31 e0       	ldi	r19, 0x01	; 1
    6000:	54 15       	cp	r21, r4
    6002:	08 f0       	brcs	.+2      	; 0x6006 <__stack+0x7>
    6004:	30 e0       	ldi	r19, 0x00	; 0
    6006:	43 2b       	or	r20, r19
    6008:	61 95       	neg	r22
    600a:	31 e0       	ldi	r19, 0x01	; 1
    600c:	16 16       	cp	r1, r22
    600e:	08 f0       	brcs	.+2      	; 0x6012 <__stack+0x13>
    6010:	30 e0       	ldi	r19, 0x00	; 0
    6012:	86 2e       	mov	r8, r22
    6014:	84 1a       	sub	r8, r20
    6016:	41 e0       	ldi	r20, 0x01	; 1
    6018:	68 15       	cp	r22, r8
    601a:	08 f0       	brcs	.+2      	; 0x601e <__stack+0x1f>
    601c:	40 e0       	ldi	r20, 0x00	; 0
    601e:	34 2b       	or	r19, r20
    6020:	71 95       	neg	r23
    6022:	41 e0       	ldi	r20, 0x01	; 1
    6024:	17 16       	cp	r1, r23
    6026:	08 f0       	brcs	.+2      	; 0x602a <__stack+0x2b>
    6028:	40 e0       	ldi	r20, 0x00	; 0
    602a:	57 2f       	mov	r21, r23
    602c:	53 1b       	sub	r21, r19
    602e:	31 e0       	ldi	r19, 0x01	; 1
    6030:	75 17       	cp	r23, r21
    6032:	08 f0       	brcs	.+2      	; 0x6036 <__stack+0x37>
    6034:	30 e0       	ldi	r19, 0x00	; 0
    6036:	43 2b       	or	r20, r19
    6038:	81 95       	neg	r24
    603a:	31 e0       	ldi	r19, 0x01	; 1
    603c:	18 16       	cp	r1, r24
    603e:	08 f0       	brcs	.+2      	; 0x6042 <__stack+0x43>
    6040:	30 e0       	ldi	r19, 0x00	; 0
    6042:	68 2f       	mov	r22, r24
    6044:	64 1b       	sub	r22, r20
    6046:	46 2f       	mov	r20, r22
    6048:	61 e0       	ldi	r22, 0x01	; 1
    604a:	84 17       	cp	r24, r20
    604c:	08 f0       	brcs	.+2      	; 0x6050 <__stack+0x51>
    604e:	60 e0       	ldi	r22, 0x00	; 0
    6050:	36 2b       	or	r19, r22
    6052:	91 95       	neg	r25
    6054:	93 1b       	sub	r25, r19
    6056:	29 a3       	lds	r18, 0x59
    6058:	ba a3       	lds	r27, 0x5a
    605a:	ab a3       	lds	r26, 0x5b
    605c:	4c a2       	lds	r20, 0x9c
    605e:	8d a2       	lds	r24, 0x9d
    6060:	5e a3       	lds	r21, 0x5e
    6062:	4f a3       	lds	r20, 0x5f
    6064:	98 a7       	lds	r25, 0x78
    6066:	8f ef       	ldi	r24, 0xFF	; 255
    6068:	9f ef       	ldi	r25, 0xFF	; 255
    606a:	af ef       	ldi	r26, 0xFF	; 255
    606c:	bf ef       	ldi	r27, 0xFF	; 255
    606e:	25 96       	adiw	r28, 0x05	; 5
    6070:	8c af       	sts	0x7c, r24
    6072:	9d af       	sts	0x7d, r25
    6074:	ae af       	sts	0x7e, r26
    6076:	bf af       	sts	0x7f, r27
    6078:	25 97       	sbiw	r28, 0x05	; 5
    607a:	06 c0       	rjmp	.+12     	; 0x6088 <__stack+0x89>
    607c:	25 96       	adiw	r28, 0x05	; 5
    607e:	1c ae       	sts	0xbc, r17
    6080:	1d ae       	sts	0xbd, r17
    6082:	1e ae       	sts	0xbe, r17
    6084:	1f ae       	sts	0xbf, r17
    6086:	25 97       	sbiw	r28, 0x05	; 5
    6088:	8d 8d       	ldd	r24, Y+29	; 0x1d
    608a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    608c:	af 8d       	ldd	r26, Y+31	; 0x1f
    608e:	b8 a1       	lds	r27, 0x48
    6090:	b7 ff       	sbrs	r27, 7
    6092:	68 c0       	rjmp	.+208    	; 0x6164 <__stack+0x165>
    6094:	25 96       	adiw	r28, 0x05	; 5
    6096:	2c ad       	sts	0x6c, r18
    6098:	3d ad       	sts	0x6d, r19
    609a:	4e ad       	sts	0x6e, r20
    609c:	5f ad       	sts	0x6f, r21
    609e:	25 97       	sbiw	r28, 0x05	; 5
    60a0:	20 95       	com	r18
    60a2:	30 95       	com	r19
    60a4:	40 95       	com	r20
    60a6:	50 95       	com	r21
    60a8:	25 96       	adiw	r28, 0x05	; 5
    60aa:	2c af       	sts	0x7c, r18
    60ac:	3d af       	sts	0x7d, r19
    60ae:	4e af       	sts	0x7e, r20
    60b0:	5f af       	sts	0x7f, r21
    60b2:	25 97       	sbiw	r28, 0x05	; 5
    60b4:	e1 95       	neg	r30
    60b6:	81 e0       	ldi	r24, 0x01	; 1
    60b8:	1e 16       	cp	r1, r30
    60ba:	08 f0       	brcs	.+2      	; 0x60be <__stack+0xbf>
    60bc:	80 e0       	ldi	r24, 0x00	; 0
    60be:	f1 95       	neg	r31
    60c0:	91 e0       	ldi	r25, 0x01	; 1
    60c2:	1f 16       	cp	r1, r31
    60c4:	08 f0       	brcs	.+2      	; 0x60c8 <__stack+0xc9>
    60c6:	90 e0       	ldi	r25, 0x00	; 0
    60c8:	4f 2f       	mov	r20, r31
    60ca:	48 1b       	sub	r20, r24
    60cc:	81 e0       	ldi	r24, 0x01	; 1
    60ce:	f4 17       	cp	r31, r20
    60d0:	08 f0       	brcs	.+2      	; 0x60d4 <__stack+0xd5>
    60d2:	80 e0       	ldi	r24, 0x00	; 0
    60d4:	98 2b       	or	r25, r24
    60d6:	c1 94       	neg	r12
    60d8:	81 e0       	ldi	r24, 0x01	; 1
    60da:	1c 14       	cp	r1, r12
    60dc:	08 f0       	brcs	.+2      	; 0x60e0 <__stack+0xe1>
    60de:	80 e0       	ldi	r24, 0x00	; 0
    60e0:	6c 2d       	mov	r22, r12
    60e2:	69 1b       	sub	r22, r25
    60e4:	91 e0       	ldi	r25, 0x01	; 1
    60e6:	c6 16       	cp	r12, r22
    60e8:	08 f0       	brcs	.+2      	; 0x60ec <__stack+0xed>
    60ea:	90 e0       	ldi	r25, 0x00	; 0
    60ec:	89 2b       	or	r24, r25
    60ee:	d1 94       	neg	r13
    60f0:	91 e0       	ldi	r25, 0x01	; 1
    60f2:	1d 14       	cp	r1, r13
    60f4:	08 f0       	brcs	.+2      	; 0x60f8 <__stack+0xf9>
    60f6:	90 e0       	ldi	r25, 0x00	; 0
    60f8:	5d 2d       	mov	r21, r13
    60fa:	58 1b       	sub	r21, r24
    60fc:	81 e0       	ldi	r24, 0x01	; 1
    60fe:	d5 16       	cp	r13, r21
    6100:	08 f0       	brcs	.+2      	; 0x6104 <__stack+0x105>
    6102:	80 e0       	ldi	r24, 0x00	; 0
    6104:	98 2b       	or	r25, r24
    6106:	e1 94       	neg	r14
    6108:	81 e0       	ldi	r24, 0x01	; 1
    610a:	1e 14       	cp	r1, r14
    610c:	08 f0       	brcs	.+2      	; 0x6110 <__stack+0x111>
    610e:	80 e0       	ldi	r24, 0x00	; 0
    6110:	3e 2d       	mov	r19, r14
    6112:	39 1b       	sub	r19, r25
    6114:	91 e0       	ldi	r25, 0x01	; 1
    6116:	e3 16       	cp	r14, r19
    6118:	08 f0       	brcs	.+2      	; 0x611c <__stack+0x11d>
    611a:	90 e0       	ldi	r25, 0x00	; 0
    611c:	89 2b       	or	r24, r25
    611e:	f1 94       	neg	r15
    6120:	91 e0       	ldi	r25, 0x01	; 1
    6122:	1f 14       	cp	r1, r15
    6124:	08 f0       	brcs	.+2      	; 0x6128 <__stack+0x129>
    6126:	90 e0       	ldi	r25, 0x00	; 0
    6128:	2f 2d       	mov	r18, r15
    612a:	28 1b       	sub	r18, r24
    612c:	81 e0       	ldi	r24, 0x01	; 1
    612e:	f2 16       	cp	r15, r18
    6130:	08 f0       	brcs	.+2      	; 0x6134 <__stack+0x135>
    6132:	80 e0       	ldi	r24, 0x00	; 0
    6134:	98 2b       	or	r25, r24
    6136:	01 95       	neg	r16
    6138:	81 e0       	ldi	r24, 0x01	; 1
    613a:	10 16       	cp	r1, r16
    613c:	08 f0       	brcs	.+2      	; 0x6140 <__stack+0x141>
    613e:	80 e0       	ldi	r24, 0x00	; 0
    6140:	70 2f       	mov	r23, r16
    6142:	79 1b       	sub	r23, r25
    6144:	97 2f       	mov	r25, r23
    6146:	71 e0       	ldi	r23, 0x01	; 1
    6148:	09 17       	cp	r16, r25
    614a:	08 f0       	brcs	.+2      	; 0x614e <__stack+0x14f>
    614c:	70 e0       	ldi	r23, 0x00	; 0
    614e:	87 2b       	or	r24, r23
    6150:	11 95       	neg	r17
    6152:	18 1b       	sub	r17, r24
    6154:	e9 8f       	std	Y+25, r30	; 0x19
    6156:	4a 8f       	std	Y+26, r20	; 0x1a
    6158:	6b 8f       	std	Y+27, r22	; 0x1b
    615a:	5c 8f       	std	Y+28, r21	; 0x1c
    615c:	3d 8f       	std	Y+29, r19	; 0x1d
    615e:	2e 8f       	std	Y+30, r18	; 0x1e
    6160:	9f 8f       	std	Y+31, r25	; 0x1f
    6162:	18 a3       	lds	r17, 0x58
    6164:	79 8d       	ldd	r23, Y+25	; 0x19
    6166:	6a 8d       	ldd	r22, Y+26	; 0x1a
    6168:	5b 8d       	ldd	r21, Y+27	; 0x1b
    616a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    616c:	3d 8d       	ldd	r19, Y+29	; 0x1d
    616e:	2e 8d       	ldd	r18, Y+30	; 0x1e
    6170:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6172:	88 a1       	lds	r24, 0x48
    6174:	e9 a1       	lds	r30, 0x49
    6176:	e9 8b       	std	Y+17, r30	; 0x11
    6178:	ea a1       	lds	r30, 0x4a
    617a:	ea 8b       	std	Y+18, r30	; 0x12
    617c:	eb a1       	lds	r30, 0x4b
    617e:	eb 8b       	std	Y+19, r30	; 0x13
    6180:	ec a1       	lds	r30, 0x4c
    6182:	ec 8b       	std	Y+20, r30	; 0x14
    6184:	ed a1       	lds	r30, 0x4d
    6186:	ed 8b       	std	Y+21, r30	; 0x15
    6188:	ee a1       	lds	r30, 0x4e
    618a:	ee 8b       	std	Y+22, r30	; 0x16
    618c:	ef a1       	lds	r30, 0x4f
    618e:	ef 8b       	std	Y+23, r30	; 0x17
    6190:	e8 a5       	lds	r30, 0x68
    6192:	e8 8f       	std	Y+24, r30	; 0x18
    6194:	79 87       	std	Y+9, r23	; 0x09
    6196:	6a 87       	std	Y+10, r22	; 0x0a
    6198:	5b 87       	std	Y+11, r21	; 0x0b
    619a:	4c 87       	std	Y+12, r20	; 0x0c
    619c:	3d 87       	std	Y+13, r19	; 0x0d
    619e:	2e 87       	std	Y+14, r18	; 0x0e
    61a0:	9f 87       	std	Y+15, r25	; 0x0f
    61a2:	88 8b       	std	Y+16, r24	; 0x10
    61a4:	89 84       	ldd	r8, Y+9	; 0x09
    61a6:	9a 84       	ldd	r9, Y+10	; 0x0a
    61a8:	ab 84       	ldd	r10, Y+11	; 0x0b
    61aa:	bc 84       	ldd	r11, Y+12	; 0x0c
    61ac:	8d 85       	ldd	r24, Y+13	; 0x0d
    61ae:	9e 85       	ldd	r25, Y+14	; 0x0e
    61b0:	af 85       	ldd	r26, Y+15	; 0x0f
    61b2:	b8 89       	ldd	r27, Y+16	; 0x10
    61b4:	e9 88       	ldd	r14, Y+17	; 0x11
    61b6:	fa 88       	ldd	r15, Y+18	; 0x12
    61b8:	0b 89       	ldd	r16, Y+19	; 0x13
    61ba:	1c 89       	ldd	r17, Y+20	; 0x14
    61bc:	ed aa       	sts	0x9d, r30
    61be:	fe aa       	sts	0x9e, r31
    61c0:	0f ab       	sts	0x5f, r16
    61c2:	18 af       	sts	0x78, r17
    61c4:	cd 88       	ldd	r12, Y+21	; 0x15
    61c6:	de 88       	ldd	r13, Y+22	; 0x16
    61c8:	ef 88       	ldd	r14, Y+23	; 0x17
    61ca:	f8 8c       	ldd	r15, Y+24	; 0x18
    61cc:	00 97       	sbiw	r24, 0x00	; 0
    61ce:	a1 05       	cpc	r26, r1
    61d0:	b1 05       	cpc	r27, r1
    61d2:	09 f0       	breq	.+2      	; 0x61d6 <__stack+0x1d7>
    61d4:	bd c3       	rjmp	.+1914   	; 0x6950 <__stack+0x951>
    61d6:	c8 14       	cp	r12, r8
    61d8:	d9 04       	cpc	r13, r9
    61da:	ea 04       	cpc	r14, r10
    61dc:	fb 04       	cpc	r15, r11
    61de:	08 f0       	brcs	.+2      	; 0x61e2 <__stack+0x1e3>
    61e0:	4d c1       	rjmp	.+666    	; 0x647c <__stack+0x47d>
    61e2:	00 e0       	ldi	r16, 0x00	; 0
    61e4:	80 16       	cp	r8, r16
    61e6:	00 e0       	ldi	r16, 0x00	; 0
    61e8:	90 06       	cpc	r9, r16
    61ea:	01 e0       	ldi	r16, 0x01	; 1
    61ec:	a0 06       	cpc	r10, r16
    61ee:	00 e0       	ldi	r16, 0x00	; 0
    61f0:	b0 06       	cpc	r11, r16
    61f2:	58 f4       	brcc	.+22     	; 0x620a <__stack+0x20b>
    61f4:	1f ef       	ldi	r17, 0xFF	; 255
    61f6:	81 16       	cp	r8, r17
    61f8:	91 04       	cpc	r9, r1
    61fa:	a1 04       	cpc	r10, r1
    61fc:	b1 04       	cpc	r11, r1
    61fe:	09 f0       	breq	.+2      	; 0x6202 <__stack+0x203>
    6200:	90 f4       	brcc	.+36     	; 0x6226 <__stack+0x227>
    6202:	80 e0       	ldi	r24, 0x00	; 0
    6204:	90 e0       	ldi	r25, 0x00	; 0
    6206:	dc 01       	movw	r26, r24
    6208:	17 c0       	rjmp	.+46     	; 0x6238 <__stack+0x239>
    620a:	20 e0       	ldi	r18, 0x00	; 0
    620c:	82 16       	cp	r8, r18
    620e:	20 e0       	ldi	r18, 0x00	; 0
    6210:	92 06       	cpc	r9, r18
    6212:	20 e0       	ldi	r18, 0x00	; 0
    6214:	a2 06       	cpc	r10, r18
    6216:	21 e0       	ldi	r18, 0x01	; 1
    6218:	b2 06       	cpc	r11, r18
    621a:	50 f4       	brcc	.+20     	; 0x6230 <__stack+0x231>
    621c:	80 e1       	ldi	r24, 0x10	; 16
    621e:	90 e0       	ldi	r25, 0x00	; 0
    6220:	a0 e0       	ldi	r26, 0x00	; 0
    6222:	b0 e0       	ldi	r27, 0x00	; 0
    6224:	09 c0       	rjmp	.+18     	; 0x6238 <__stack+0x239>
    6226:	88 e0       	ldi	r24, 0x08	; 8
    6228:	90 e0       	ldi	r25, 0x00	; 0
    622a:	a0 e0       	ldi	r26, 0x00	; 0
    622c:	b0 e0       	ldi	r27, 0x00	; 0
    622e:	04 c0       	rjmp	.+8      	; 0x6238 <__stack+0x239>
    6230:	88 e1       	ldi	r24, 0x18	; 24
    6232:	90 e0       	ldi	r25, 0x00	; 0
    6234:	a0 e0       	ldi	r26, 0x00	; 0
    6236:	b0 e0       	ldi	r27, 0x00	; 0
    6238:	b5 01       	movw	r22, r10
    623a:	a4 01       	movw	r20, r8
    623c:	08 2e       	mov	r0, r24
    623e:	04 c0       	rjmp	.+8      	; 0x6248 <__stack+0x249>
    6240:	76 95       	lsr	r23
    6242:	67 95       	ror	r22
    6244:	57 95       	ror	r21
    6246:	47 95       	ror	r20
    6248:	0a 94       	dec	r0
    624a:	d2 f7       	brpl	.-12     	; 0x6240 <__stack+0x241>
    624c:	fa 01       	movw	r30, r20
    624e:	e3 5f       	subi	r30, 0xF3	; 243
    6250:	ff 4d       	sbci	r31, 0xDF	; 223
    6252:	20 81       	ld	r18, Z
    6254:	40 e2       	ldi	r20, 0x20	; 32
    6256:	50 e0       	ldi	r21, 0x00	; 0
    6258:	60 e0       	ldi	r22, 0x00	; 0
    625a:	70 e0       	ldi	r23, 0x00	; 0
    625c:	48 1b       	sub	r20, r24
    625e:	59 0b       	sbc	r21, r25
    6260:	6a 0b       	sbc	r22, r26
    6262:	7b 0b       	sbc	r23, r27
    6264:	42 1b       	sub	r20, r18
    6266:	51 09       	sbc	r21, r1
    6268:	61 09       	sbc	r22, r1
    626a:	71 09       	sbc	r23, r1
    626c:	41 15       	cp	r20, r1
    626e:	51 05       	cpc	r21, r1
    6270:	61 05       	cpc	r22, r1
    6272:	71 05       	cpc	r23, r1
    6274:	a1 f1       	breq	.+104    	; 0x62de <__stack+0x2df>
    6276:	04 2e       	mov	r0, r20
    6278:	04 c0       	rjmp	.+8      	; 0x6282 <__stack+0x283>
    627a:	88 0c       	add	r8, r8
    627c:	99 1c       	adc	r9, r9
    627e:	aa 1c       	adc	r10, r10
    6280:	bb 1c       	adc	r11, r11
    6282:	0a 94       	dec	r0
    6284:	d2 f7       	brpl	.-12     	; 0x627a <__stack+0x27b>
    6286:	97 01       	movw	r18, r14
    6288:	86 01       	movw	r16, r12
    628a:	04 2e       	mov	r0, r20
    628c:	04 c0       	rjmp	.+8      	; 0x6296 <__stack+0x297>
    628e:	00 0f       	add	r16, r16
    6290:	11 1f       	adc	r17, r17
    6292:	22 1f       	adc	r18, r18
    6294:	33 1f       	adc	r19, r19
    6296:	0a 94       	dec	r0
    6298:	d2 f7       	brpl	.-12     	; 0x628e <__stack+0x28f>
    629a:	80 e2       	ldi	r24, 0x20	; 32
    629c:	90 e0       	ldi	r25, 0x00	; 0
    629e:	84 1b       	sub	r24, r20
    62a0:	95 0b       	sbc	r25, r21
    62a2:	cd a8       	sts	0x8d, r28
    62a4:	de a8       	sts	0x8e, r29
    62a6:	ef a8       	sts	0x8f, r30
    62a8:	f8 ac       	sts	0xa8, r31
    62aa:	04 c0       	rjmp	.+8      	; 0x62b4 <__stack+0x2b5>
    62ac:	f6 94       	lsr	r15
    62ae:	e7 94       	ror	r14
    62b0:	d7 94       	ror	r13
    62b2:	c7 94       	ror	r12
    62b4:	8a 95       	dec	r24
    62b6:	d2 f7       	brpl	.-12     	; 0x62ac <__stack+0x2ad>
    62b8:	c0 2a       	or	r12, r16
    62ba:	d1 2a       	or	r13, r17
    62bc:	e2 2a       	or	r14, r18
    62be:	f3 2a       	or	r15, r19
    62c0:	0d a9       	sts	0x4d, r16
    62c2:	1e a9       	sts	0x4e, r17
    62c4:	2f a9       	sts	0x4f, r18
    62c6:	38 ad       	sts	0x68, r19
    62c8:	04 c0       	rjmp	.+8      	; 0x62d2 <__stack+0x2d3>
    62ca:	00 0f       	add	r16, r16
    62cc:	11 1f       	adc	r17, r17
    62ce:	22 1f       	adc	r18, r18
    62d0:	33 1f       	adc	r19, r19
    62d2:	4a 95       	dec	r20
    62d4:	d2 f7       	brpl	.-12     	; 0x62ca <__stack+0x2cb>
    62d6:	0d ab       	sts	0x5d, r16
    62d8:	1e ab       	sts	0x5e, r17
    62da:	2f ab       	sts	0x5f, r18
    62dc:	38 af       	sts	0x78, r19
    62de:	25 01       	movw	r4, r10
    62e0:	66 24       	eor	r6, r6
    62e2:	77 24       	eor	r7, r7
    62e4:	95 01       	movw	r18, r10
    62e6:	84 01       	movw	r16, r8
    62e8:	20 70       	andi	r18, 0x00	; 0
    62ea:	30 70       	andi	r19, 0x00	; 0
    62ec:	09 ab       	sts	0x59, r16
    62ee:	1a ab       	sts	0x5a, r17
    62f0:	2b ab       	sts	0x5b, r18
    62f2:	3c ab       	sts	0x5c, r19
    62f4:	c7 01       	movw	r24, r14
    62f6:	b6 01       	movw	r22, r12
    62f8:	a3 01       	movw	r20, r6
    62fa:	92 01       	movw	r18, r4
    62fc:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    6300:	2d a7       	lds	r18, 0x7d
    6302:	3e a7       	lds	r19, 0x7e
    6304:	4f a7       	lds	r20, 0x7f
    6306:	58 ab       	sts	0x58, r21
    6308:	69 a7       	lds	r22, 0x79
    630a:	7a a7       	lds	r23, 0x7a
    630c:	8b a7       	lds	r24, 0x7b
    630e:	9c a7       	lds	r25, 0x7c
    6310:	c7 01       	movw	r24, r14
    6312:	b6 01       	movw	r22, r12
    6314:	a3 01       	movw	r20, r6
    6316:	92 01       	movw	r18, r4
    6318:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    631c:	ca 01       	movw	r24, r20
    631e:	b9 01       	movw	r22, r18
    6320:	29 a9       	sts	0x49, r18
    6322:	3a a9       	sts	0x4a, r19
    6324:	4b a9       	sts	0x4b, r20
    6326:	5c a9       	sts	0x4c, r21
    6328:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    632c:	ab 01       	movw	r20, r22
    632e:	bc 01       	movw	r22, r24
    6330:	09 a5       	lds	r16, 0x69
    6332:	1a a5       	lds	r17, 0x6a
    6334:	2b a5       	lds	r18, 0x6b
    6336:	3c a5       	lds	r19, 0x6c
    6338:	78 01       	movw	r14, r16
    633a:	dd 24       	eor	r13, r13
    633c:	cc 24       	eor	r12, r12
    633e:	0d a9       	sts	0x4d, r16
    6340:	1e a9       	sts	0x4e, r17
    6342:	2f a9       	sts	0x4f, r18
    6344:	38 ad       	sts	0x68, r19
    6346:	c9 01       	movw	r24, r18
    6348:	aa 27       	eor	r26, r26
    634a:	bb 27       	eor	r27, r27
    634c:	c8 2a       	or	r12, r24
    634e:	d9 2a       	or	r13, r25
    6350:	ea 2a       	or	r14, r26
    6352:	fb 2a       	or	r15, r27
    6354:	0d a5       	lds	r16, 0x6d
    6356:	1e a5       	lds	r17, 0x6e
    6358:	2f a5       	lds	r18, 0x6f
    635a:	38 a9       	sts	0x48, r19
    635c:	c4 16       	cp	r12, r20
    635e:	d5 06       	cpc	r13, r21
    6360:	e6 06       	cpc	r14, r22
    6362:	f7 06       	cpc	r15, r23
    6364:	38 f5       	brcc	.+78     	; 0x63b4 <__stack+0x3b5>
    6366:	01 50       	subi	r16, 0x01	; 1
    6368:	10 40       	sbci	r17, 0x00	; 0
    636a:	20 40       	sbci	r18, 0x00	; 0
    636c:	30 40       	sbci	r19, 0x00	; 0
    636e:	09 a7       	lds	r16, 0x79
    6370:	1a a7       	lds	r17, 0x7a
    6372:	2b a7       	lds	r18, 0x7b
    6374:	3c a7       	lds	r19, 0x7c
    6376:	c8 0c       	add	r12, r8
    6378:	d9 1c       	adc	r13, r9
    637a:	ea 1c       	adc	r14, r10
    637c:	fb 1c       	adc	r15, r11
    637e:	c8 14       	cp	r12, r8
    6380:	d9 04       	cpc	r13, r9
    6382:	ea 04       	cpc	r14, r10
    6384:	fb 04       	cpc	r15, r11
    6386:	d0 f0       	brcs	.+52     	; 0x63bc <__stack+0x3bd>
    6388:	c4 16       	cp	r12, r20
    638a:	d5 06       	cpc	r13, r21
    638c:	e6 06       	cpc	r14, r22
    638e:	f7 06       	cpc	r15, r23
    6390:	a8 f4       	brcc	.+42     	; 0x63bc <__stack+0x3bd>
    6392:	0d a5       	lds	r16, 0x6d
    6394:	1e a5       	lds	r17, 0x6e
    6396:	2f a5       	lds	r18, 0x6f
    6398:	38 a9       	sts	0x48, r19
    639a:	02 50       	subi	r16, 0x02	; 2
    639c:	10 40       	sbci	r17, 0x00	; 0
    639e:	20 40       	sbci	r18, 0x00	; 0
    63a0:	30 40       	sbci	r19, 0x00	; 0
    63a2:	09 a7       	lds	r16, 0x79
    63a4:	1a a7       	lds	r17, 0x7a
    63a6:	2b a7       	lds	r18, 0x7b
    63a8:	3c a7       	lds	r19, 0x7c
    63aa:	c8 0c       	add	r12, r8
    63ac:	d9 1c       	adc	r13, r9
    63ae:	ea 1c       	adc	r14, r10
    63b0:	fb 1c       	adc	r15, r11
    63b2:	04 c0       	rjmp	.+8      	; 0x63bc <__stack+0x3bd>
    63b4:	09 a7       	lds	r16, 0x79
    63b6:	1a a7       	lds	r17, 0x7a
    63b8:	2b a7       	lds	r18, 0x7b
    63ba:	3c a7       	lds	r19, 0x7c
    63bc:	c4 1a       	sub	r12, r20
    63be:	d5 0a       	sbc	r13, r21
    63c0:	e6 0a       	sbc	r14, r22
    63c2:	f7 0a       	sbc	r15, r23
    63c4:	c7 01       	movw	r24, r14
    63c6:	b6 01       	movw	r22, r12
    63c8:	a3 01       	movw	r20, r6
    63ca:	92 01       	movw	r18, r4
    63cc:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    63d0:	2d a7       	lds	r18, 0x7d
    63d2:	3e a7       	lds	r19, 0x7e
    63d4:	4f a7       	lds	r20, 0x7f
    63d6:	58 ab       	sts	0x58, r21
    63d8:	69 af       	sts	0x79, r22
    63da:	7a af       	sts	0x7a, r23
    63dc:	8b af       	sts	0x7b, r24
    63de:	9c af       	sts	0x7c, r25
    63e0:	c7 01       	movw	r24, r14
    63e2:	b6 01       	movw	r22, r12
    63e4:	a3 01       	movw	r20, r6
    63e6:	92 01       	movw	r18, r4
    63e8:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    63ec:	ca 01       	movw	r24, r20
    63ee:	b9 01       	movw	r22, r18
    63f0:	29 a9       	sts	0x49, r18
    63f2:	3a a9       	sts	0x4a, r19
    63f4:	4b a9       	sts	0x4b, r20
    63f6:	5c a9       	sts	0x4c, r21
    63f8:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    63fc:	6b 01       	movw	r12, r22
    63fe:	7c 01       	movw	r14, r24
    6400:	49 ad       	sts	0x69, r20
    6402:	5a ad       	sts	0x6a, r21
    6404:	6b ad       	sts	0x6b, r22
    6406:	7c ad       	sts	0x6c, r23
    6408:	9a 01       	movw	r18, r20
    640a:	11 27       	eor	r17, r17
    640c:	00 27       	eor	r16, r16
    640e:	4d a9       	sts	0x4d, r20
    6410:	5e a9       	sts	0x4e, r21
    6412:	6f a9       	sts	0x4f, r22
    6414:	78 ad       	sts	0x68, r23
    6416:	60 70       	andi	r22, 0x00	; 0
    6418:	70 70       	andi	r23, 0x00	; 0
    641a:	04 2b       	or	r16, r20
    641c:	15 2b       	or	r17, r21
    641e:	26 2b       	or	r18, r22
    6420:	37 2b       	or	r19, r23
    6422:	8d a5       	lds	r24, 0x6d
    6424:	9e a5       	lds	r25, 0x6e
    6426:	af a5       	lds	r26, 0x6f
    6428:	b8 a9       	sts	0x48, r27
    642a:	0c 15       	cp	r16, r12
    642c:	1d 05       	cpc	r17, r13
    642e:	2e 05       	cpc	r18, r14
    6430:	3f 05       	cpc	r19, r15
    6432:	c0 f4       	brcc	.+48     	; 0x6464 <__stack+0x465>
    6434:	01 97       	sbiw	r24, 0x01	; 1
    6436:	a1 09       	sbc	r26, r1
    6438:	b1 09       	sbc	r27, r1
    643a:	08 0d       	add	r16, r8
    643c:	19 1d       	adc	r17, r9
    643e:	2a 1d       	adc	r18, r10
    6440:	3b 1d       	adc	r19, r11
    6442:	08 15       	cp	r16, r8
    6444:	19 05       	cpc	r17, r9
    6446:	2a 05       	cpc	r18, r10
    6448:	3b 05       	cpc	r19, r11
    644a:	60 f0       	brcs	.+24     	; 0x6464 <__stack+0x465>
    644c:	0c 15       	cp	r16, r12
    644e:	1d 05       	cpc	r17, r13
    6450:	2e 05       	cpc	r18, r14
    6452:	3f 05       	cpc	r19, r15
    6454:	38 f4       	brcc	.+14     	; 0x6464 <__stack+0x465>
    6456:	8d a5       	lds	r24, 0x6d
    6458:	9e a5       	lds	r25, 0x6e
    645a:	af a5       	lds	r26, 0x6f
    645c:	b8 a9       	sts	0x48, r27
    645e:	02 97       	sbiw	r24, 0x02	; 2
    6460:	a1 09       	sbc	r26, r1
    6462:	b1 09       	sbc	r27, r1
    6464:	09 a5       	lds	r16, 0x69
    6466:	1a a5       	lds	r17, 0x6a
    6468:	2b a5       	lds	r18, 0x6b
    646a:	3c a5       	lds	r19, 0x6c
    646c:	78 01       	movw	r14, r16
    646e:	dd 24       	eor	r13, r13
    6470:	cc 24       	eor	r12, r12
    6472:	c8 2a       	or	r12, r24
    6474:	d9 2a       	or	r13, r25
    6476:	ea 2a       	or	r14, r26
    6478:	fb 2a       	or	r15, r27
    647a:	b7 c4       	rjmp	.+2414   	; 0x6dea <__stack+0xdeb>
    647c:	81 14       	cp	r8, r1
    647e:	91 04       	cpc	r9, r1
    6480:	a1 04       	cpc	r10, r1
    6482:	b1 04       	cpc	r11, r1
    6484:	51 f4       	brne	.+20     	; 0x649a <__stack+0x49b>
    6486:	61 e0       	ldi	r22, 0x01	; 1
    6488:	70 e0       	ldi	r23, 0x00	; 0
    648a:	80 e0       	ldi	r24, 0x00	; 0
    648c:	90 e0       	ldi	r25, 0x00	; 0
    648e:	a5 01       	movw	r20, r10
    6490:	94 01       	movw	r18, r8
    6492:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    6496:	49 01       	movw	r8, r18
    6498:	5a 01       	movw	r10, r20
    649a:	10 e0       	ldi	r17, 0x00	; 0
    649c:	81 16       	cp	r8, r17
    649e:	10 e0       	ldi	r17, 0x00	; 0
    64a0:	91 06       	cpc	r9, r17
    64a2:	11 e0       	ldi	r17, 0x01	; 1
    64a4:	a1 06       	cpc	r10, r17
    64a6:	10 e0       	ldi	r17, 0x00	; 0
    64a8:	b1 06       	cpc	r11, r17
    64aa:	58 f4       	brcc	.+22     	; 0x64c2 <__stack+0x4c3>
    64ac:	2f ef       	ldi	r18, 0xFF	; 255
    64ae:	82 16       	cp	r8, r18
    64b0:	91 04       	cpc	r9, r1
    64b2:	a1 04       	cpc	r10, r1
    64b4:	b1 04       	cpc	r11, r1
    64b6:	09 f0       	breq	.+2      	; 0x64ba <__stack+0x4bb>
    64b8:	90 f4       	brcc	.+36     	; 0x64de <__stack+0x4df>
    64ba:	80 e0       	ldi	r24, 0x00	; 0
    64bc:	90 e0       	ldi	r25, 0x00	; 0
    64be:	dc 01       	movw	r26, r24
    64c0:	17 c0       	rjmp	.+46     	; 0x64f0 <__stack+0x4f1>
    64c2:	30 e0       	ldi	r19, 0x00	; 0
    64c4:	83 16       	cp	r8, r19
    64c6:	30 e0       	ldi	r19, 0x00	; 0
    64c8:	93 06       	cpc	r9, r19
    64ca:	30 e0       	ldi	r19, 0x00	; 0
    64cc:	a3 06       	cpc	r10, r19
    64ce:	31 e0       	ldi	r19, 0x01	; 1
    64d0:	b3 06       	cpc	r11, r19
    64d2:	50 f4       	brcc	.+20     	; 0x64e8 <__stack+0x4e9>
    64d4:	80 e1       	ldi	r24, 0x10	; 16
    64d6:	90 e0       	ldi	r25, 0x00	; 0
    64d8:	a0 e0       	ldi	r26, 0x00	; 0
    64da:	b0 e0       	ldi	r27, 0x00	; 0
    64dc:	09 c0       	rjmp	.+18     	; 0x64f0 <__stack+0x4f1>
    64de:	88 e0       	ldi	r24, 0x08	; 8
    64e0:	90 e0       	ldi	r25, 0x00	; 0
    64e2:	a0 e0       	ldi	r26, 0x00	; 0
    64e4:	b0 e0       	ldi	r27, 0x00	; 0
    64e6:	04 c0       	rjmp	.+8      	; 0x64f0 <__stack+0x4f1>
    64e8:	88 e1       	ldi	r24, 0x18	; 24
    64ea:	90 e0       	ldi	r25, 0x00	; 0
    64ec:	a0 e0       	ldi	r26, 0x00	; 0
    64ee:	b0 e0       	ldi	r27, 0x00	; 0
    64f0:	b5 01       	movw	r22, r10
    64f2:	a4 01       	movw	r20, r8
    64f4:	08 2e       	mov	r0, r24
    64f6:	04 c0       	rjmp	.+8      	; 0x6500 <__stack+0x501>
    64f8:	76 95       	lsr	r23
    64fa:	67 95       	ror	r22
    64fc:	57 95       	ror	r21
    64fe:	47 95       	ror	r20
    6500:	0a 94       	dec	r0
    6502:	d2 f7       	brpl	.-12     	; 0x64f8 <__stack+0x4f9>
    6504:	fa 01       	movw	r30, r20
    6506:	e3 5f       	subi	r30, 0xF3	; 243
    6508:	ff 4d       	sbci	r31, 0xDF	; 223
    650a:	20 81       	ld	r18, Z
    650c:	ac 01       	movw	r20, r24
    650e:	bd 01       	movw	r22, r26
    6510:	42 0f       	add	r20, r18
    6512:	51 1d       	adc	r21, r1
    6514:	61 1d       	adc	r22, r1
    6516:	71 1d       	adc	r23, r1
    6518:	80 e2       	ldi	r24, 0x20	; 32
    651a:	90 e0       	ldi	r25, 0x00	; 0
    651c:	a0 e0       	ldi	r26, 0x00	; 0
    651e:	b0 e0       	ldi	r27, 0x00	; 0
    6520:	84 1b       	sub	r24, r20
    6522:	95 0b       	sbc	r25, r21
    6524:	a6 0b       	sbc	r26, r22
    6526:	b7 0b       	sbc	r27, r23
    6528:	51 f4       	brne	.+20     	; 0x653e <__stack+0x53f>
    652a:	c8 18       	sub	r12, r8
    652c:	d9 08       	sbc	r13, r9
    652e:	ea 08       	sbc	r14, r10
    6530:	fb 08       	sbc	r15, r11
    6532:	f1 e0       	ldi	r31, 0x01	; 1
    6534:	4f 2e       	mov	r4, r31
    6536:	51 2c       	mov	r5, r1
    6538:	61 2c       	mov	r6, r1
    653a:	71 2c       	mov	r7, r1
    653c:	28 c1       	rjmp	.+592    	; 0x678e <__stack+0x78f>
    653e:	08 2e       	mov	r0, r24
    6540:	04 c0       	rjmp	.+8      	; 0x654a <__stack+0x54b>
    6542:	88 0c       	add	r8, r8
    6544:	99 1c       	adc	r9, r9
    6546:	aa 1c       	adc	r10, r10
    6548:	bb 1c       	adc	r11, r11
    654a:	0a 94       	dec	r0
    654c:	d2 f7       	brpl	.-12     	; 0x6542 <__stack+0x543>
    654e:	97 01       	movw	r18, r14
    6550:	86 01       	movw	r16, r12
    6552:	04 2e       	mov	r0, r20
    6554:	04 c0       	rjmp	.+8      	; 0x655e <__stack+0x55f>
    6556:	36 95       	lsr	r19
    6558:	27 95       	ror	r18
    655a:	17 95       	ror	r17
    655c:	07 95       	ror	r16
    655e:	0a 94       	dec	r0
    6560:	d2 f7       	brpl	.-12     	; 0x6556 <__stack+0x557>
    6562:	09 ab       	sts	0x59, r16
    6564:	1a ab       	sts	0x5a, r17
    6566:	2b ab       	sts	0x5b, r18
    6568:	3c ab       	sts	0x5c, r19
    656a:	97 01       	movw	r18, r14
    656c:	86 01       	movw	r16, r12
    656e:	08 2e       	mov	r0, r24
    6570:	04 c0       	rjmp	.+8      	; 0x657a <__stack+0x57b>
    6572:	00 0f       	add	r16, r16
    6574:	11 1f       	adc	r17, r17
    6576:	22 1f       	adc	r18, r18
    6578:	33 1f       	adc	r19, r19
    657a:	0a 94       	dec	r0
    657c:	d2 f7       	brpl	.-12     	; 0x6572 <__stack+0x573>
    657e:	0d a7       	lds	r16, 0x7d
    6580:	1e a7       	lds	r17, 0x7e
    6582:	2f a7       	lds	r18, 0x7f
    6584:	38 ab       	sts	0x58, r19
    6586:	ed a8       	sts	0x8d, r30
    6588:	fe a8       	sts	0x8e, r31
    658a:	0f a9       	sts	0x4f, r16
    658c:	18 ad       	sts	0x68, r17
    658e:	04 c0       	rjmp	.+8      	; 0x6598 <__stack+0x599>
    6590:	16 95       	lsr	r17
    6592:	07 95       	ror	r16
    6594:	f7 94       	ror	r15
    6596:	e7 94       	ror	r14
    6598:	4a 95       	dec	r20
    659a:	d2 f7       	brpl	.-12     	; 0x6590 <__stack+0x591>
    659c:	b8 01       	movw	r22, r16
    659e:	a7 01       	movw	r20, r14
    65a0:	0d a5       	lds	r16, 0x6d
    65a2:	1e a5       	lds	r17, 0x6e
    65a4:	2f a5       	lds	r18, 0x6f
    65a6:	38 a9       	sts	0x48, r19
    65a8:	04 2b       	or	r16, r20
    65aa:	15 2b       	or	r17, r21
    65ac:	26 2b       	or	r18, r22
    65ae:	37 2b       	or	r19, r23
    65b0:	0d a7       	lds	r16, 0x7d
    65b2:	1e a7       	lds	r17, 0x7e
    65b4:	2f a7       	lds	r18, 0x7f
    65b6:	38 ab       	sts	0x58, r19
    65b8:	ed a8       	sts	0x8d, r30
    65ba:	fe a8       	sts	0x8e, r31
    65bc:	0f a9       	sts	0x4f, r16
    65be:	18 ad       	sts	0x68, r17
    65c0:	04 c0       	rjmp	.+8      	; 0x65ca <__stack+0x5cb>
    65c2:	ee 0c       	add	r14, r14
    65c4:	ff 1c       	adc	r15, r15
    65c6:	00 1f       	adc	r16, r16
    65c8:	11 1f       	adc	r17, r17
    65ca:	8a 95       	dec	r24
    65cc:	d2 f7       	brpl	.-12     	; 0x65c2 <__stack+0x5c3>
    65ce:	ed aa       	sts	0x9d, r30
    65d0:	fe aa       	sts	0x9e, r31
    65d2:	0f ab       	sts	0x5f, r16
    65d4:	18 af       	sts	0x78, r17
    65d6:	25 01       	movw	r4, r10
    65d8:	66 24       	eor	r6, r6
    65da:	77 24       	eor	r7, r7
    65dc:	95 01       	movw	r18, r10
    65de:	84 01       	movw	r16, r8
    65e0:	20 70       	andi	r18, 0x00	; 0
    65e2:	30 70       	andi	r19, 0x00	; 0
    65e4:	09 af       	sts	0x79, r16
    65e6:	1a af       	sts	0x7a, r17
    65e8:	2b af       	sts	0x7b, r18
    65ea:	3c af       	sts	0x7c, r19
    65ec:	69 a9       	sts	0x49, r22
    65ee:	7a a9       	sts	0x4a, r23
    65f0:	8b a9       	sts	0x4b, r24
    65f2:	9c a9       	sts	0x4c, r25
    65f4:	a3 01       	movw	r20, r6
    65f6:	92 01       	movw	r18, r4
    65f8:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    65fc:	29 a7       	lds	r18, 0x79
    65fe:	3a a7       	lds	r19, 0x7a
    6600:	4b a7       	lds	r20, 0x7b
    6602:	5c a7       	lds	r21, 0x7c
    6604:	6b 01       	movw	r12, r22
    6606:	7c 01       	movw	r14, r24
    6608:	69 a9       	sts	0x49, r22
    660a:	7a a9       	sts	0x4a, r23
    660c:	8b a9       	sts	0x4b, r24
    660e:	9c a9       	sts	0x4c, r25
    6610:	a3 01       	movw	r20, r6
    6612:	92 01       	movw	r18, r4
    6614:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    6618:	ca 01       	movw	r24, r20
    661a:	b9 01       	movw	r22, r18
    661c:	29 ad       	sts	0x69, r18
    661e:	3a ad       	sts	0x6a, r19
    6620:	4b ad       	sts	0x6b, r20
    6622:	5c ad       	sts	0x6c, r21
    6624:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    6628:	ab 01       	movw	r20, r22
    662a:	bc 01       	movw	r22, r24
    662c:	76 01       	movw	r14, r12
    662e:	dd 24       	eor	r13, r13
    6630:	cc 24       	eor	r12, r12
    6632:	0d a5       	lds	r16, 0x6d
    6634:	1e a5       	lds	r17, 0x6e
    6636:	2f a5       	lds	r18, 0x6f
    6638:	38 a9       	sts	0x48, r19
    663a:	c9 01       	movw	r24, r18
    663c:	aa 27       	eor	r26, r26
    663e:	bb 27       	eor	r27, r27
    6640:	c8 2a       	or	r12, r24
    6642:	d9 2a       	or	r13, r25
    6644:	ea 2a       	or	r14, r26
    6646:	fb 2a       	or	r15, r27
    6648:	09 a5       	lds	r16, 0x69
    664a:	1a a5       	lds	r17, 0x6a
    664c:	2b a5       	lds	r18, 0x6b
    664e:	3c a5       	lds	r19, 0x6c
    6650:	c4 16       	cp	r12, r20
    6652:	d5 06       	cpc	r13, r21
    6654:	e6 06       	cpc	r14, r22
    6656:	f7 06       	cpc	r15, r23
    6658:	38 f5       	brcc	.+78     	; 0x66a8 <__stack+0x6a9>
    665a:	01 50       	subi	r16, 0x01	; 1
    665c:	10 40       	sbci	r17, 0x00	; 0
    665e:	20 40       	sbci	r18, 0x00	; 0
    6660:	30 40       	sbci	r19, 0x00	; 0
    6662:	09 ab       	sts	0x59, r16
    6664:	1a ab       	sts	0x5a, r17
    6666:	2b ab       	sts	0x5b, r18
    6668:	3c ab       	sts	0x5c, r19
    666a:	c8 0c       	add	r12, r8
    666c:	d9 1c       	adc	r13, r9
    666e:	ea 1c       	adc	r14, r10
    6670:	fb 1c       	adc	r15, r11
    6672:	c8 14       	cp	r12, r8
    6674:	d9 04       	cpc	r13, r9
    6676:	ea 04       	cpc	r14, r10
    6678:	fb 04       	cpc	r15, r11
    667a:	d0 f0       	brcs	.+52     	; 0x66b0 <__stack+0x6b1>
    667c:	c4 16       	cp	r12, r20
    667e:	d5 06       	cpc	r13, r21
    6680:	e6 06       	cpc	r14, r22
    6682:	f7 06       	cpc	r15, r23
    6684:	a8 f4       	brcc	.+42     	; 0x66b0 <__stack+0x6b1>
    6686:	09 a5       	lds	r16, 0x69
    6688:	1a a5       	lds	r17, 0x6a
    668a:	2b a5       	lds	r18, 0x6b
    668c:	3c a5       	lds	r19, 0x6c
    668e:	02 50       	subi	r16, 0x02	; 2
    6690:	10 40       	sbci	r17, 0x00	; 0
    6692:	20 40       	sbci	r18, 0x00	; 0
    6694:	30 40       	sbci	r19, 0x00	; 0
    6696:	09 ab       	sts	0x59, r16
    6698:	1a ab       	sts	0x5a, r17
    669a:	2b ab       	sts	0x5b, r18
    669c:	3c ab       	sts	0x5c, r19
    669e:	c8 0c       	add	r12, r8
    66a0:	d9 1c       	adc	r13, r9
    66a2:	ea 1c       	adc	r14, r10
    66a4:	fb 1c       	adc	r15, r11
    66a6:	04 c0       	rjmp	.+8      	; 0x66b0 <__stack+0x6b1>
    66a8:	09 ab       	sts	0x59, r16
    66aa:	1a ab       	sts	0x5a, r17
    66ac:	2b ab       	sts	0x5b, r18
    66ae:	3c ab       	sts	0x5c, r19
    66b0:	c4 1a       	sub	r12, r20
    66b2:	d5 0a       	sbc	r13, r21
    66b4:	e6 0a       	sbc	r14, r22
    66b6:	f7 0a       	sbc	r15, r23
    66b8:	c7 01       	movw	r24, r14
    66ba:	b6 01       	movw	r22, r12
    66bc:	a3 01       	movw	r20, r6
    66be:	92 01       	movw	r18, r4
    66c0:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    66c4:	29 a7       	lds	r18, 0x79
    66c6:	3a a7       	lds	r19, 0x7a
    66c8:	4b a7       	lds	r20, 0x7b
    66ca:	5c a7       	lds	r21, 0x7c
    66cc:	21 96       	adiw	r28, 0x01	; 1
    66ce:	6c af       	sts	0x7c, r22
    66d0:	7d af       	sts	0x7d, r23
    66d2:	8e af       	sts	0x7e, r24
    66d4:	9f af       	sts	0x7f, r25
    66d6:	21 97       	sbiw	r28, 0x01	; 1
    66d8:	c7 01       	movw	r24, r14
    66da:	b6 01       	movw	r22, r12
    66dc:	a3 01       	movw	r20, r6
    66de:	92 01       	movw	r18, r4
    66e0:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    66e4:	ca 01       	movw	r24, r20
    66e6:	b9 01       	movw	r22, r18
    66e8:	29 ad       	sts	0x69, r18
    66ea:	3a ad       	sts	0x6a, r19
    66ec:	4b ad       	sts	0x6b, r20
    66ee:	5c ad       	sts	0x6c, r21
    66f0:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    66f4:	8b 01       	movw	r16, r22
    66f6:	9c 01       	movw	r18, r24
    66f8:	21 96       	adiw	r28, 0x01	; 1
    66fa:	4c ad       	sts	0x6c, r20
    66fc:	5d ad       	sts	0x6d, r21
    66fe:	6e ad       	sts	0x6e, r22
    6700:	7f ad       	sts	0x6f, r23
    6702:	21 97       	sbiw	r28, 0x01	; 1
    6704:	da 01       	movw	r26, r20
    6706:	99 27       	eor	r25, r25
    6708:	88 27       	eor	r24, r24
    670a:	4d a5       	lds	r20, 0x6d
    670c:	5e a5       	lds	r21, 0x6e
    670e:	6f a5       	lds	r22, 0x6f
    6710:	78 a9       	sts	0x48, r23
    6712:	60 70       	andi	r22, 0x00	; 0
    6714:	70 70       	andi	r23, 0x00	; 0
    6716:	84 2b       	or	r24, r20
    6718:	95 2b       	or	r25, r21
    671a:	a6 2b       	or	r26, r22
    671c:	b7 2b       	or	r27, r23
    671e:	49 a5       	lds	r20, 0x69
    6720:	5a a5       	lds	r21, 0x6a
    6722:	6b a5       	lds	r22, 0x6b
    6724:	7c a5       	lds	r23, 0x6c
    6726:	80 17       	cp	r24, r16
    6728:	91 07       	cpc	r25, r17
    672a:	a2 07       	cpc	r26, r18
    672c:	b3 07       	cpc	r27, r19
    672e:	f0 f4       	brcc	.+60     	; 0x676c <__stack+0x76d>
    6730:	41 50       	subi	r20, 0x01	; 1
    6732:	50 40       	sbci	r21, 0x00	; 0
    6734:	60 40       	sbci	r22, 0x00	; 0
    6736:	70 40       	sbci	r23, 0x00	; 0
    6738:	88 0d       	add	r24, r8
    673a:	99 1d       	adc	r25, r9
    673c:	aa 1d       	adc	r26, r10
    673e:	bb 1d       	adc	r27, r11
    6740:	88 15       	cp	r24, r8
    6742:	99 05       	cpc	r25, r9
    6744:	aa 05       	cpc	r26, r10
    6746:	bb 05       	cpc	r27, r11
    6748:	88 f0       	brcs	.+34     	; 0x676c <__stack+0x76d>
    674a:	80 17       	cp	r24, r16
    674c:	91 07       	cpc	r25, r17
    674e:	a2 07       	cpc	r26, r18
    6750:	b3 07       	cpc	r27, r19
    6752:	60 f4       	brcc	.+24     	; 0x676c <__stack+0x76d>
    6754:	49 a5       	lds	r20, 0x69
    6756:	5a a5       	lds	r21, 0x6a
    6758:	6b a5       	lds	r22, 0x6b
    675a:	7c a5       	lds	r23, 0x6c
    675c:	42 50       	subi	r20, 0x02	; 2
    675e:	50 40       	sbci	r21, 0x00	; 0
    6760:	60 40       	sbci	r22, 0x00	; 0
    6762:	70 40       	sbci	r23, 0x00	; 0
    6764:	88 0d       	add	r24, r8
    6766:	99 1d       	adc	r25, r9
    6768:	aa 1d       	adc	r26, r10
    676a:	bb 1d       	adc	r27, r11
    676c:	6c 01       	movw	r12, r24
    676e:	7d 01       	movw	r14, r26
    6770:	c0 1a       	sub	r12, r16
    6772:	d1 0a       	sbc	r13, r17
    6774:	e2 0a       	sbc	r14, r18
    6776:	f3 0a       	sbc	r15, r19
    6778:	09 a9       	sts	0x49, r16
    677a:	1a a9       	sts	0x4a, r17
    677c:	2b a9       	sts	0x4b, r18
    677e:	3c a9       	sts	0x4c, r19
    6780:	38 01       	movw	r6, r16
    6782:	55 24       	eor	r5, r5
    6784:	44 24       	eor	r4, r4
    6786:	44 2a       	or	r4, r20
    6788:	55 2a       	or	r5, r21
    678a:	66 2a       	or	r6, r22
    678c:	77 2a       	or	r7, r23
    678e:	85 01       	movw	r16, r10
    6790:	22 27       	eor	r18, r18
    6792:	33 27       	eor	r19, r19
    6794:	0d a7       	lds	r16, 0x7d
    6796:	1e a7       	lds	r17, 0x7e
    6798:	2f a7       	lds	r18, 0x7f
    679a:	38 ab       	sts	0x58, r19
    679c:	95 01       	movw	r18, r10
    679e:	84 01       	movw	r16, r8
    67a0:	20 70       	andi	r18, 0x00	; 0
    67a2:	30 70       	andi	r19, 0x00	; 0
    67a4:	09 af       	sts	0x79, r16
    67a6:	1a af       	sts	0x7a, r17
    67a8:	2b af       	sts	0x7b, r18
    67aa:	3c af       	sts	0x7c, r19
    67ac:	c7 01       	movw	r24, r14
    67ae:	b6 01       	movw	r22, r12
    67b0:	2d a5       	lds	r18, 0x6d
    67b2:	3e a5       	lds	r19, 0x6e
    67b4:	4f a5       	lds	r20, 0x6f
    67b6:	58 a9       	sts	0x48, r21
    67b8:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    67bc:	29 a7       	lds	r18, 0x79
    67be:	3a a7       	lds	r19, 0x7a
    67c0:	4b a7       	lds	r20, 0x7b
    67c2:	5c a7       	lds	r21, 0x7c
    67c4:	69 ab       	sts	0x59, r22
    67c6:	7a ab       	sts	0x5a, r23
    67c8:	8b ab       	sts	0x5b, r24
    67ca:	9c ab       	sts	0x5c, r25
    67cc:	c7 01       	movw	r24, r14
    67ce:	b6 01       	movw	r22, r12
    67d0:	2d a5       	lds	r18, 0x6d
    67d2:	3e a5       	lds	r19, 0x6e
    67d4:	4f a5       	lds	r20, 0x6f
    67d6:	58 a9       	sts	0x48, r21
    67d8:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    67dc:	ca 01       	movw	r24, r20
    67de:	b9 01       	movw	r22, r18
    67e0:	29 ad       	sts	0x69, r18
    67e2:	3a ad       	sts	0x6a, r19
    67e4:	4b ad       	sts	0x6b, r20
    67e6:	5c ad       	sts	0x6c, r21
    67e8:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    67ec:	ab 01       	movw	r20, r22
    67ee:	bc 01       	movw	r22, r24
    67f0:	09 a9       	sts	0x49, r16
    67f2:	1a a9       	sts	0x4a, r17
    67f4:	2b a9       	sts	0x4b, r18
    67f6:	3c a9       	sts	0x4c, r19
    67f8:	78 01       	movw	r14, r16
    67fa:	dd 24       	eor	r13, r13
    67fc:	cc 24       	eor	r12, r12
    67fe:	0d a9       	sts	0x4d, r16
    6800:	1e a9       	sts	0x4e, r17
    6802:	2f a9       	sts	0x4f, r18
    6804:	38 ad       	sts	0x68, r19
    6806:	c9 01       	movw	r24, r18
    6808:	aa 27       	eor	r26, r26
    680a:	bb 27       	eor	r27, r27
    680c:	c8 2a       	or	r12, r24
    680e:	d9 2a       	or	r13, r25
    6810:	ea 2a       	or	r14, r26
    6812:	fb 2a       	or	r15, r27
    6814:	09 a5       	lds	r16, 0x69
    6816:	1a a5       	lds	r17, 0x6a
    6818:	2b a5       	lds	r18, 0x6b
    681a:	3c a5       	lds	r19, 0x6c
    681c:	c4 16       	cp	r12, r20
    681e:	d5 06       	cpc	r13, r21
    6820:	e6 06       	cpc	r14, r22
    6822:	f7 06       	cpc	r15, r23
    6824:	38 f5       	brcc	.+78     	; 0x6874 <__stack+0x875>
    6826:	01 50       	subi	r16, 0x01	; 1
    6828:	10 40       	sbci	r17, 0x00	; 0
    682a:	20 40       	sbci	r18, 0x00	; 0
    682c:	30 40       	sbci	r19, 0x00	; 0
    682e:	09 ab       	sts	0x59, r16
    6830:	1a ab       	sts	0x5a, r17
    6832:	2b ab       	sts	0x5b, r18
    6834:	3c ab       	sts	0x5c, r19
    6836:	c8 0c       	add	r12, r8
    6838:	d9 1c       	adc	r13, r9
    683a:	ea 1c       	adc	r14, r10
    683c:	fb 1c       	adc	r15, r11
    683e:	c8 14       	cp	r12, r8
    6840:	d9 04       	cpc	r13, r9
    6842:	ea 04       	cpc	r14, r10
    6844:	fb 04       	cpc	r15, r11
    6846:	d0 f0       	brcs	.+52     	; 0x687c <__stack+0x87d>
    6848:	c4 16       	cp	r12, r20
    684a:	d5 06       	cpc	r13, r21
    684c:	e6 06       	cpc	r14, r22
    684e:	f7 06       	cpc	r15, r23
    6850:	a8 f4       	brcc	.+42     	; 0x687c <__stack+0x87d>
    6852:	09 a5       	lds	r16, 0x69
    6854:	1a a5       	lds	r17, 0x6a
    6856:	2b a5       	lds	r18, 0x6b
    6858:	3c a5       	lds	r19, 0x6c
    685a:	02 50       	subi	r16, 0x02	; 2
    685c:	10 40       	sbci	r17, 0x00	; 0
    685e:	20 40       	sbci	r18, 0x00	; 0
    6860:	30 40       	sbci	r19, 0x00	; 0
    6862:	09 ab       	sts	0x59, r16
    6864:	1a ab       	sts	0x5a, r17
    6866:	2b ab       	sts	0x5b, r18
    6868:	3c ab       	sts	0x5c, r19
    686a:	c8 0c       	add	r12, r8
    686c:	d9 1c       	adc	r13, r9
    686e:	ea 1c       	adc	r14, r10
    6870:	fb 1c       	adc	r15, r11
    6872:	04 c0       	rjmp	.+8      	; 0x687c <__stack+0x87d>
    6874:	09 ab       	sts	0x59, r16
    6876:	1a ab       	sts	0x5a, r17
    6878:	2b ab       	sts	0x5b, r18
    687a:	3c ab       	sts	0x5c, r19
    687c:	c4 1a       	sub	r12, r20
    687e:	d5 0a       	sbc	r13, r21
    6880:	e6 0a       	sbc	r14, r22
    6882:	f7 0a       	sbc	r15, r23
    6884:	c7 01       	movw	r24, r14
    6886:	b6 01       	movw	r22, r12
    6888:	2d a5       	lds	r18, 0x6d
    688a:	3e a5       	lds	r19, 0x6e
    688c:	4f a5       	lds	r20, 0x6f
    688e:	58 a9       	sts	0x48, r21
    6890:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    6894:	29 a7       	lds	r18, 0x79
    6896:	3a a7       	lds	r19, 0x7a
    6898:	4b a7       	lds	r20, 0x7b
    689a:	5c a7       	lds	r21, 0x7c
    689c:	21 96       	adiw	r28, 0x01	; 1
    689e:	6c af       	sts	0x7c, r22
    68a0:	7d af       	sts	0x7d, r23
    68a2:	8e af       	sts	0x7e, r24
    68a4:	9f af       	sts	0x7f, r25
    68a6:	21 97       	sbiw	r28, 0x01	; 1
    68a8:	c7 01       	movw	r24, r14
    68aa:	b6 01       	movw	r22, r12
    68ac:	2d a5       	lds	r18, 0x6d
    68ae:	3e a5       	lds	r19, 0x6e
    68b0:	4f a5       	lds	r20, 0x6f
    68b2:	58 a9       	sts	0x48, r21
    68b4:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    68b8:	ca 01       	movw	r24, r20
    68ba:	b9 01       	movw	r22, r18
    68bc:	29 ad       	sts	0x69, r18
    68be:	3a ad       	sts	0x6a, r19
    68c0:	4b ad       	sts	0x6b, r20
    68c2:	5c ad       	sts	0x6c, r21
    68c4:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    68c8:	8b 01       	movw	r16, r22
    68ca:	9c 01       	movw	r18, r24
    68cc:	21 96       	adiw	r28, 0x01	; 1
    68ce:	4c ad       	sts	0x6c, r20
    68d0:	5d ad       	sts	0x6d, r21
    68d2:	6e ad       	sts	0x6e, r22
    68d4:	7f ad       	sts	0x6f, r23
    68d6:	21 97       	sbiw	r28, 0x01	; 1
    68d8:	da 01       	movw	r26, r20
    68da:	99 27       	eor	r25, r25
    68dc:	88 27       	eor	r24, r24
    68de:	4d a9       	sts	0x4d, r20
    68e0:	5e a9       	sts	0x4e, r21
    68e2:	6f a9       	sts	0x4f, r22
    68e4:	78 ad       	sts	0x68, r23
    68e6:	60 70       	andi	r22, 0x00	; 0
    68e8:	70 70       	andi	r23, 0x00	; 0
    68ea:	84 2b       	or	r24, r20
    68ec:	95 2b       	or	r25, r21
    68ee:	a6 2b       	or	r26, r22
    68f0:	b7 2b       	or	r27, r23
    68f2:	49 a5       	lds	r20, 0x69
    68f4:	5a a5       	lds	r21, 0x6a
    68f6:	6b a5       	lds	r22, 0x6b
    68f8:	7c a5       	lds	r23, 0x6c
    68fa:	80 17       	cp	r24, r16
    68fc:	91 07       	cpc	r25, r17
    68fe:	a2 07       	cpc	r26, r18
    6900:	b3 07       	cpc	r27, r19
    6902:	d0 f4       	brcc	.+52     	; 0x6938 <__stack+0x939>
    6904:	41 50       	subi	r20, 0x01	; 1
    6906:	50 40       	sbci	r21, 0x00	; 0
    6908:	60 40       	sbci	r22, 0x00	; 0
    690a:	70 40       	sbci	r23, 0x00	; 0
    690c:	88 0d       	add	r24, r8
    690e:	99 1d       	adc	r25, r9
    6910:	aa 1d       	adc	r26, r10
    6912:	bb 1d       	adc	r27, r11
    6914:	88 15       	cp	r24, r8
    6916:	99 05       	cpc	r25, r9
    6918:	aa 05       	cpc	r26, r10
    691a:	bb 05       	cpc	r27, r11
    691c:	68 f0       	brcs	.+26     	; 0x6938 <__stack+0x939>
    691e:	80 17       	cp	r24, r16
    6920:	91 07       	cpc	r25, r17
    6922:	a2 07       	cpc	r26, r18
    6924:	b3 07       	cpc	r27, r19
    6926:	40 f4       	brcc	.+16     	; 0x6938 <__stack+0x939>
    6928:	49 a5       	lds	r20, 0x69
    692a:	5a a5       	lds	r21, 0x6a
    692c:	6b a5       	lds	r22, 0x6b
    692e:	7c a5       	lds	r23, 0x6c
    6930:	42 50       	subi	r20, 0x02	; 2
    6932:	50 40       	sbci	r21, 0x00	; 0
    6934:	60 40       	sbci	r22, 0x00	; 0
    6936:	70 40       	sbci	r23, 0x00	; 0
    6938:	09 a9       	sts	0x49, r16
    693a:	1a a9       	sts	0x4a, r17
    693c:	2b a9       	sts	0x4b, r18
    693e:	3c a9       	sts	0x4c, r19
    6940:	78 01       	movw	r14, r16
    6942:	dd 24       	eor	r13, r13
    6944:	cc 24       	eor	r12, r12
    6946:	c4 2a       	or	r12, r20
    6948:	d5 2a       	or	r13, r21
    694a:	e6 2a       	or	r14, r22
    694c:	f7 2a       	or	r15, r23
    694e:	50 c2       	rjmp	.+1184   	; 0x6df0 <__stack+0xdf1>
    6950:	c8 16       	cp	r12, r24
    6952:	d9 06       	cpc	r13, r25
    6954:	ea 06       	cpc	r14, r26
    6956:	fb 06       	cpc	r15, r27
    6958:	08 f4       	brcc	.+2      	; 0x695c <__stack+0x95d>
    695a:	37 c2       	rjmp	.+1134   	; 0x6dca <__stack+0xdcb>
    695c:	80 30       	cpi	r24, 0x00	; 0
    695e:	10 e0       	ldi	r17, 0x00	; 0
    6960:	91 07       	cpc	r25, r17
    6962:	11 e0       	ldi	r17, 0x01	; 1
    6964:	a1 07       	cpc	r26, r17
    6966:	10 e0       	ldi	r17, 0x00	; 0
    6968:	b1 07       	cpc	r27, r17
    696a:	50 f4       	brcc	.+20     	; 0x6980 <__stack+0x981>
    696c:	8f 3f       	cpi	r24, 0xFF	; 255
    696e:	91 05       	cpc	r25, r1
    6970:	a1 05       	cpc	r26, r1
    6972:	b1 05       	cpc	r27, r1
    6974:	09 f0       	breq	.+2      	; 0x6978 <__stack+0x979>
    6976:	88 f4       	brcc	.+34     	; 0x699a <__stack+0x99b>
    6978:	00 e0       	ldi	r16, 0x00	; 0
    697a:	10 e0       	ldi	r17, 0x00	; 0
    697c:	98 01       	movw	r18, r16
    697e:	16 c0       	rjmp	.+44     	; 0x69ac <__stack+0x9ad>
    6980:	80 30       	cpi	r24, 0x00	; 0
    6982:	20 e0       	ldi	r18, 0x00	; 0
    6984:	92 07       	cpc	r25, r18
    6986:	20 e0       	ldi	r18, 0x00	; 0
    6988:	a2 07       	cpc	r26, r18
    698a:	21 e0       	ldi	r18, 0x01	; 1
    698c:	b2 07       	cpc	r27, r18
    698e:	50 f4       	brcc	.+20     	; 0x69a4 <__stack+0x9a5>
    6990:	00 e1       	ldi	r16, 0x10	; 16
    6992:	10 e0       	ldi	r17, 0x00	; 0
    6994:	20 e0       	ldi	r18, 0x00	; 0
    6996:	30 e0       	ldi	r19, 0x00	; 0
    6998:	09 c0       	rjmp	.+18     	; 0x69ac <__stack+0x9ad>
    699a:	08 e0       	ldi	r16, 0x08	; 8
    699c:	10 e0       	ldi	r17, 0x00	; 0
    699e:	20 e0       	ldi	r18, 0x00	; 0
    69a0:	30 e0       	ldi	r19, 0x00	; 0
    69a2:	04 c0       	rjmp	.+8      	; 0x69ac <__stack+0x9ad>
    69a4:	08 e1       	ldi	r16, 0x18	; 24
    69a6:	10 e0       	ldi	r17, 0x00	; 0
    69a8:	20 e0       	ldi	r18, 0x00	; 0
    69aa:	30 e0       	ldi	r19, 0x00	; 0
    69ac:	ac 01       	movw	r20, r24
    69ae:	bd 01       	movw	r22, r26
    69b0:	00 2e       	mov	r0, r16
    69b2:	04 c0       	rjmp	.+8      	; 0x69bc <__stack+0x9bd>
    69b4:	76 95       	lsr	r23
    69b6:	67 95       	ror	r22
    69b8:	57 95       	ror	r21
    69ba:	47 95       	ror	r20
    69bc:	0a 94       	dec	r0
    69be:	d2 f7       	brpl	.-12     	; 0x69b4 <__stack+0x9b5>
    69c0:	fa 01       	movw	r30, r20
    69c2:	e3 5f       	subi	r30, 0xF3	; 243
    69c4:	ff 4d       	sbci	r31, 0xDF	; 223
    69c6:	40 81       	ld	r20, Z
    69c8:	04 0f       	add	r16, r20
    69ca:	11 1d       	adc	r17, r1
    69cc:	21 1d       	adc	r18, r1
    69ce:	31 1d       	adc	r19, r1
    69d0:	40 e2       	ldi	r20, 0x20	; 32
    69d2:	50 e0       	ldi	r21, 0x00	; 0
    69d4:	60 e0       	ldi	r22, 0x00	; 0
    69d6:	70 e0       	ldi	r23, 0x00	; 0
    69d8:	40 1b       	sub	r20, r16
    69da:	51 0b       	sbc	r21, r17
    69dc:	62 0b       	sbc	r22, r18
    69de:	73 0b       	sbc	r23, r19
    69e0:	a1 f4       	brne	.+40     	; 0x6a0a <__stack+0xa0b>
    69e2:	8c 15       	cp	r24, r12
    69e4:	9d 05       	cpc	r25, r13
    69e6:	ae 05       	cpc	r26, r14
    69e8:	bf 05       	cpc	r27, r15
    69ea:	08 f4       	brcc	.+2      	; 0x69ee <__stack+0x9ef>
    69ec:	f5 c1       	rjmp	.+1002   	; 0x6dd8 <__stack+0xdd9>
    69ee:	ed a8       	sts	0x8d, r30
    69f0:	fe a8       	sts	0x8e, r31
    69f2:	0f a9       	sts	0x4f, r16
    69f4:	18 ad       	sts	0x68, r17
    69f6:	44 24       	eor	r4, r4
    69f8:	55 24       	eor	r5, r5
    69fa:	32 01       	movw	r6, r4
    69fc:	e8 14       	cp	r14, r8
    69fe:	f9 04       	cpc	r15, r9
    6a00:	0a 05       	cpc	r16, r10
    6a02:	1b 05       	cpc	r17, r11
    6a04:	08 f0       	brcs	.+2      	; 0x6a08 <__stack+0xa09>
    6a06:	eb c1       	rjmp	.+982    	; 0x6dde <__stack+0xddf>
    6a08:	e3 c1       	rjmp	.+966    	; 0x6dd0 <__stack+0xdd1>
    6a0a:	34 2e       	mov	r3, r20
    6a0c:	2c 01       	movw	r4, r24
    6a0e:	3d 01       	movw	r6, r26
    6a10:	04 c0       	rjmp	.+8      	; 0x6a1a <__stack+0xa1b>
    6a12:	44 0c       	add	r4, r4
    6a14:	55 1c       	adc	r5, r5
    6a16:	66 1c       	adc	r6, r6
    6a18:	77 1c       	adc	r7, r7
    6a1a:	4a 95       	dec	r20
    6a1c:	d2 f7       	brpl	.-12     	; 0x6a12 <__stack+0xa13>
    6a1e:	d5 01       	movw	r26, r10
    6a20:	c4 01       	movw	r24, r8
    6a22:	00 2e       	mov	r0, r16
    6a24:	04 c0       	rjmp	.+8      	; 0x6a2e <__stack+0xa2f>
    6a26:	b6 95       	lsr	r27
    6a28:	a7 95       	ror	r26
    6a2a:	97 95       	ror	r25
    6a2c:	87 95       	ror	r24
    6a2e:	0a 94       	dec	r0
    6a30:	d2 f7       	brpl	.-12     	; 0x6a26 <__stack+0xa27>
    6a32:	48 2a       	or	r4, r24
    6a34:	59 2a       	or	r5, r25
    6a36:	6a 2a       	or	r6, r26
    6a38:	7b 2a       	or	r7, r27
    6a3a:	a5 01       	movw	r20, r10
    6a3c:	94 01       	movw	r18, r8
    6a3e:	03 2c       	mov	r0, r3
    6a40:	04 c0       	rjmp	.+8      	; 0x6a4a <__stack+0xa4b>
    6a42:	22 0f       	add	r18, r18
    6a44:	33 1f       	adc	r19, r19
    6a46:	44 1f       	adc	r20, r20
    6a48:	55 1f       	adc	r21, r21
    6a4a:	0a 94       	dec	r0
    6a4c:	d2 f7       	brpl	.-12     	; 0x6a42 <__stack+0xa43>
    6a4e:	29 af       	sts	0x79, r18
    6a50:	3a af       	sts	0x7a, r19
    6a52:	4b af       	sts	0x7b, r20
    6a54:	5c af       	sts	0x7c, r21
    6a56:	b7 01       	movw	r22, r14
    6a58:	a6 01       	movw	r20, r12
    6a5a:	00 2e       	mov	r0, r16
    6a5c:	04 c0       	rjmp	.+8      	; 0x6a66 <__stack+0xa67>
    6a5e:	76 95       	lsr	r23
    6a60:	67 95       	ror	r22
    6a62:	57 95       	ror	r21
    6a64:	47 95       	ror	r20
    6a66:	0a 94       	dec	r0
    6a68:	d2 f7       	brpl	.-12     	; 0x6a5e <__stack+0xa5f>
    6a6a:	49 ab       	sts	0x59, r20
    6a6c:	5a ab       	sts	0x5a, r21
    6a6e:	6b ab       	sts	0x5b, r22
    6a70:	7c ab       	sts	0x5c, r23
    6a72:	c7 01       	movw	r24, r14
    6a74:	b6 01       	movw	r22, r12
    6a76:	03 2c       	mov	r0, r3
    6a78:	04 c0       	rjmp	.+8      	; 0x6a82 <__stack+0xa83>
    6a7a:	66 0f       	add	r22, r22
    6a7c:	77 1f       	adc	r23, r23
    6a7e:	88 1f       	adc	r24, r24
    6a80:	99 1f       	adc	r25, r25
    6a82:	0a 94       	dec	r0
    6a84:	d2 f7       	brpl	.-12     	; 0x6a7a <__stack+0xa7b>
    6a86:	6d a7       	lds	r22, 0x7d
    6a88:	7e a7       	lds	r23, 0x7e
    6a8a:	8f a7       	lds	r24, 0x7f
    6a8c:	98 ab       	sts	0x58, r25
    6a8e:	8d a9       	sts	0x4d, r24
    6a90:	9e a9       	sts	0x4e, r25
    6a92:	af a9       	sts	0x4f, r26
    6a94:	b8 ad       	sts	0x68, r27
    6a96:	04 c0       	rjmp	.+8      	; 0x6aa0 <__stack+0xaa1>
    6a98:	b6 95       	lsr	r27
    6a9a:	a7 95       	ror	r26
    6a9c:	97 95       	ror	r25
    6a9e:	87 95       	ror	r24
    6aa0:	0a 95       	dec	r16
    6aa2:	d2 f7       	brpl	.-12     	; 0x6a98 <__stack+0xa99>
    6aa4:	4d a5       	lds	r20, 0x6d
    6aa6:	5e a5       	lds	r21, 0x6e
    6aa8:	6f a5       	lds	r22, 0x6f
    6aaa:	78 a9       	sts	0x48, r23
    6aac:	48 2b       	or	r20, r24
    6aae:	59 2b       	or	r21, r25
    6ab0:	6a 2b       	or	r22, r26
    6ab2:	7b 2b       	or	r23, r27
    6ab4:	4d a7       	lds	r20, 0x7d
    6ab6:	5e a7       	lds	r21, 0x7e
    6ab8:	6f a7       	lds	r22, 0x7f
    6aba:	78 ab       	sts	0x58, r23
    6abc:	43 01       	movw	r8, r6
    6abe:	aa 24       	eor	r10, r10
    6ac0:	bb 24       	eor	r11, r11
    6ac2:	93 01       	movw	r18, r6
    6ac4:	82 01       	movw	r16, r4
    6ac6:	20 70       	andi	r18, 0x00	; 0
    6ac8:	30 70       	andi	r19, 0x00	; 0
    6aca:	21 96       	adiw	r28, 0x01	; 1
    6acc:	0c af       	sts	0x7c, r16
    6ace:	1d af       	sts	0x7d, r17
    6ad0:	2e af       	sts	0x7e, r18
    6ad2:	3f af       	sts	0x7f, r19
    6ad4:	21 97       	sbiw	r28, 0x01	; 1
    6ad6:	69 a9       	sts	0x49, r22
    6ad8:	7a a9       	sts	0x4a, r23
    6ada:	8b a9       	sts	0x4b, r24
    6adc:	9c a9       	sts	0x4c, r25
    6ade:	a5 01       	movw	r20, r10
    6ae0:	94 01       	movw	r18, r8
    6ae2:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    6ae6:	29 a7       	lds	r18, 0x79
    6ae8:	3a a7       	lds	r19, 0x7a
    6aea:	4b a7       	lds	r20, 0x7b
    6aec:	5c a7       	lds	r21, 0x7c
    6aee:	6b 01       	movw	r12, r22
    6af0:	7c 01       	movw	r14, r24
    6af2:	69 a9       	sts	0x49, r22
    6af4:	7a a9       	sts	0x4a, r23
    6af6:	8b a9       	sts	0x4b, r24
    6af8:	9c a9       	sts	0x4c, r25
    6afa:	a5 01       	movw	r20, r10
    6afc:	94 01       	movw	r18, r8
    6afe:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    6b02:	ca 01       	movw	r24, r20
    6b04:	b9 01       	movw	r22, r18
    6b06:	21 96       	adiw	r28, 0x01	; 1
    6b08:	2c ad       	sts	0x6c, r18
    6b0a:	3d ad       	sts	0x6d, r19
    6b0c:	4e ad       	sts	0x6e, r20
    6b0e:	5f ad       	sts	0x6f, r21
    6b10:	21 97       	sbiw	r28, 0x01	; 1
    6b12:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    6b16:	dc 01       	movw	r26, r24
    6b18:	cb 01       	movw	r24, r22
    6b1a:	76 01       	movw	r14, r12
    6b1c:	dd 24       	eor	r13, r13
    6b1e:	cc 24       	eor	r12, r12
    6b20:	0d a5       	lds	r16, 0x6d
    6b22:	1e a5       	lds	r17, 0x6e
    6b24:	2f a5       	lds	r18, 0x6f
    6b26:	38 a9       	sts	0x48, r19
    6b28:	a9 01       	movw	r20, r18
    6b2a:	66 27       	eor	r22, r22
    6b2c:	77 27       	eor	r23, r23
    6b2e:	c4 2a       	or	r12, r20
    6b30:	d5 2a       	or	r13, r21
    6b32:	e6 2a       	or	r14, r22
    6b34:	f7 2a       	or	r15, r23
    6b36:	09 a5       	lds	r16, 0x69
    6b38:	1a a5       	lds	r17, 0x6a
    6b3a:	2b a5       	lds	r18, 0x6b
    6b3c:	3c a5       	lds	r19, 0x6c
    6b3e:	c8 16       	cp	r12, r24
    6b40:	d9 06       	cpc	r13, r25
    6b42:	ea 06       	cpc	r14, r26
    6b44:	fb 06       	cpc	r15, r27
    6b46:	38 f5       	brcc	.+78     	; 0x6b96 <__stack+0xb97>
    6b48:	01 50       	subi	r16, 0x01	; 1
    6b4a:	10 40       	sbci	r17, 0x00	; 0
    6b4c:	20 40       	sbci	r18, 0x00	; 0
    6b4e:	30 40       	sbci	r19, 0x00	; 0
    6b50:	09 ab       	sts	0x59, r16
    6b52:	1a ab       	sts	0x5a, r17
    6b54:	2b ab       	sts	0x5b, r18
    6b56:	3c ab       	sts	0x5c, r19
    6b58:	c4 0c       	add	r12, r4
    6b5a:	d5 1c       	adc	r13, r5
    6b5c:	e6 1c       	adc	r14, r6
    6b5e:	f7 1c       	adc	r15, r7
    6b60:	c4 14       	cp	r12, r4
    6b62:	d5 04       	cpc	r13, r5
    6b64:	e6 04       	cpc	r14, r6
    6b66:	f7 04       	cpc	r15, r7
    6b68:	d0 f0       	brcs	.+52     	; 0x6b9e <__stack+0xb9f>
    6b6a:	c8 16       	cp	r12, r24
    6b6c:	d9 06       	cpc	r13, r25
    6b6e:	ea 06       	cpc	r14, r26
    6b70:	fb 06       	cpc	r15, r27
    6b72:	a8 f4       	brcc	.+42     	; 0x6b9e <__stack+0xb9f>
    6b74:	09 a5       	lds	r16, 0x69
    6b76:	1a a5       	lds	r17, 0x6a
    6b78:	2b a5       	lds	r18, 0x6b
    6b7a:	3c a5       	lds	r19, 0x6c
    6b7c:	02 50       	subi	r16, 0x02	; 2
    6b7e:	10 40       	sbci	r17, 0x00	; 0
    6b80:	20 40       	sbci	r18, 0x00	; 0
    6b82:	30 40       	sbci	r19, 0x00	; 0
    6b84:	09 ab       	sts	0x59, r16
    6b86:	1a ab       	sts	0x5a, r17
    6b88:	2b ab       	sts	0x5b, r18
    6b8a:	3c ab       	sts	0x5c, r19
    6b8c:	c4 0c       	add	r12, r4
    6b8e:	d5 1c       	adc	r13, r5
    6b90:	e6 1c       	adc	r14, r6
    6b92:	f7 1c       	adc	r15, r7
    6b94:	04 c0       	rjmp	.+8      	; 0x6b9e <__stack+0xb9f>
    6b96:	09 ab       	sts	0x59, r16
    6b98:	1a ab       	sts	0x5a, r17
    6b9a:	2b ab       	sts	0x5b, r18
    6b9c:	3c ab       	sts	0x5c, r19
    6b9e:	c8 1a       	sub	r12, r24
    6ba0:	d9 0a       	sbc	r13, r25
    6ba2:	ea 0a       	sbc	r14, r26
    6ba4:	fb 0a       	sbc	r15, r27
    6ba6:	c7 01       	movw	r24, r14
    6ba8:	b6 01       	movw	r22, r12
    6baa:	a5 01       	movw	r20, r10
    6bac:	94 01       	movw	r18, r8
    6bae:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    6bb2:	29 a7       	lds	r18, 0x79
    6bb4:	3a a7       	lds	r19, 0x7a
    6bb6:	4b a7       	lds	r20, 0x7b
    6bb8:	5c a7       	lds	r21, 0x7c
    6bba:	29 96       	adiw	r28, 0x09	; 9
    6bbc:	6c af       	sts	0x7c, r22
    6bbe:	7d af       	sts	0x7d, r23
    6bc0:	8e af       	sts	0x7e, r24
    6bc2:	9f af       	sts	0x7f, r25
    6bc4:	29 97       	sbiw	r28, 0x09	; 9
    6bc6:	c7 01       	movw	r24, r14
    6bc8:	b6 01       	movw	r22, r12
    6bca:	a5 01       	movw	r20, r10
    6bcc:	94 01       	movw	r18, r8
    6bce:	0e 94 57 39 	call	0x72ae	; 0x72ae <__udivmodsi4>
    6bd2:	ca 01       	movw	r24, r20
    6bd4:	b9 01       	movw	r22, r18
    6bd6:	21 96       	adiw	r28, 0x01	; 1
    6bd8:	2c ad       	sts	0x6c, r18
    6bda:	3d ad       	sts	0x6d, r19
    6bdc:	4e ad       	sts	0x6e, r20
    6bde:	5f ad       	sts	0x6f, r21
    6be0:	21 97       	sbiw	r28, 0x01	; 1
    6be2:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    6be6:	4b 01       	movw	r8, r22
    6be8:	5c 01       	movw	r10, r24
    6bea:	29 96       	adiw	r28, 0x09	; 9
    6bec:	4c ad       	sts	0x6c, r20
    6bee:	5d ad       	sts	0x6d, r21
    6bf0:	6e ad       	sts	0x6e, r22
    6bf2:	7f ad       	sts	0x6f, r23
    6bf4:	29 97       	sbiw	r28, 0x09	; 9
    6bf6:	9a 01       	movw	r18, r20
    6bf8:	11 27       	eor	r17, r17
    6bfa:	00 27       	eor	r16, r16
    6bfc:	8d a5       	lds	r24, 0x6d
    6bfe:	9e a5       	lds	r25, 0x6e
    6c00:	af a5       	lds	r26, 0x6f
    6c02:	b8 a9       	sts	0x48, r27
    6c04:	a0 70       	andi	r26, 0x00	; 0
    6c06:	b0 70       	andi	r27, 0x00	; 0
    6c08:	08 2b       	or	r16, r24
    6c0a:	19 2b       	or	r17, r25
    6c0c:	2a 2b       	or	r18, r26
    6c0e:	3b 2b       	or	r19, r27
    6c10:	89 a5       	lds	r24, 0x69
    6c12:	9a a5       	lds	r25, 0x6a
    6c14:	ab a5       	lds	r26, 0x6b
    6c16:	bc a5       	lds	r27, 0x6c
    6c18:	08 15       	cp	r16, r8
    6c1a:	19 05       	cpc	r17, r9
    6c1c:	2a 05       	cpc	r18, r10
    6c1e:	3b 05       	cpc	r19, r11
    6c20:	e0 f4       	brcc	.+56     	; 0x6c5a <__stack+0xc5b>
    6c22:	01 97       	sbiw	r24, 0x01	; 1
    6c24:	a1 09       	sbc	r26, r1
    6c26:	b1 09       	sbc	r27, r1
    6c28:	04 0d       	add	r16, r4
    6c2a:	15 1d       	adc	r17, r5
    6c2c:	26 1d       	adc	r18, r6
    6c2e:	37 1d       	adc	r19, r7
    6c30:	04 15       	cp	r16, r4
    6c32:	15 05       	cpc	r17, r5
    6c34:	26 05       	cpc	r18, r6
    6c36:	37 05       	cpc	r19, r7
    6c38:	80 f0       	brcs	.+32     	; 0x6c5a <__stack+0xc5b>
    6c3a:	08 15       	cp	r16, r8
    6c3c:	19 05       	cpc	r17, r9
    6c3e:	2a 05       	cpc	r18, r10
    6c40:	3b 05       	cpc	r19, r11
    6c42:	58 f4       	brcc	.+22     	; 0x6c5a <__stack+0xc5b>
    6c44:	89 a5       	lds	r24, 0x69
    6c46:	9a a5       	lds	r25, 0x6a
    6c48:	ab a5       	lds	r26, 0x6b
    6c4a:	bc a5       	lds	r27, 0x6c
    6c4c:	02 97       	sbiw	r24, 0x02	; 2
    6c4e:	a1 09       	sbc	r26, r1
    6c50:	b1 09       	sbc	r27, r1
    6c52:	04 0d       	add	r16, r4
    6c54:	15 1d       	adc	r17, r5
    6c56:	26 1d       	adc	r18, r6
    6c58:	37 1d       	adc	r19, r7
    6c5a:	b9 01       	movw	r22, r18
    6c5c:	a8 01       	movw	r20, r16
    6c5e:	48 19       	sub	r20, r8
    6c60:	59 09       	sbc	r21, r9
    6c62:	6a 09       	sbc	r22, r10
    6c64:	7b 09       	sbc	r23, r11
    6c66:	4d a7       	lds	r20, 0x7d
    6c68:	5e a7       	lds	r21, 0x7e
    6c6a:	6f a7       	lds	r22, 0x7f
    6c6c:	78 ab       	sts	0x58, r23
    6c6e:	09 a9       	sts	0x49, r16
    6c70:	1a a9       	sts	0x4a, r17
    6c72:	2b a9       	sts	0x4b, r18
    6c74:	3c a9       	sts	0x4c, r19
    6c76:	78 01       	movw	r14, r16
    6c78:	dd 24       	eor	r13, r13
    6c7a:	cc 24       	eor	r12, r12
    6c7c:	c8 2a       	or	r12, r24
    6c7e:	d9 2a       	or	r13, r25
    6c80:	ea 2a       	or	r14, r26
    6c82:	fb 2a       	or	r15, r27
    6c84:	ff ef       	ldi	r31, 0xFF	; 255
    6c86:	8f 2e       	mov	r8, r31
    6c88:	ff ef       	ldi	r31, 0xFF	; 255
    6c8a:	9f 2e       	mov	r9, r31
    6c8c:	a1 2c       	mov	r10, r1
    6c8e:	b1 2c       	mov	r11, r1
    6c90:	8c 20       	and	r8, r12
    6c92:	9d 20       	and	r9, r13
    6c94:	ae 20       	and	r10, r14
    6c96:	bf 20       	and	r11, r15
    6c98:	87 01       	movw	r16, r14
    6c9a:	22 27       	eor	r18, r18
    6c9c:	33 27       	eor	r19, r19
    6c9e:	09 a7       	lds	r16, 0x79
    6ca0:	1a a7       	lds	r17, 0x7a
    6ca2:	2b a7       	lds	r18, 0x7b
    6ca4:	3c a7       	lds	r19, 0x7c
    6ca6:	49 ac       	sts	0xa9, r20
    6ca8:	5a ac       	sts	0xaa, r21
    6caa:	6b ac       	sts	0xab, r22
    6cac:	7c ac       	sts	0xac, r23
    6cae:	2f ef       	ldi	r18, 0xFF	; 255
    6cb0:	3f ef       	ldi	r19, 0xFF	; 255
    6cb2:	40 e0       	ldi	r20, 0x00	; 0
    6cb4:	50 e0       	ldi	r21, 0x00	; 0
    6cb6:	42 22       	and	r4, r18
    6cb8:	53 22       	and	r5, r19
    6cba:	64 22       	and	r6, r20
    6cbc:	75 22       	and	r7, r21
    6cbe:	29 ad       	sts	0x69, r18
    6cc0:	3a ad       	sts	0x6a, r19
    6cc2:	4b ad       	sts	0x6b, r20
    6cc4:	5c ad       	sts	0x6c, r21
    6cc6:	8a 01       	movw	r16, r20
    6cc8:	22 27       	eor	r18, r18
    6cca:	33 27       	eor	r19, r19
    6ccc:	09 ab       	sts	0x59, r16
    6cce:	1a ab       	sts	0x5a, r17
    6cd0:	2b ab       	sts	0x5b, r18
    6cd2:	3c ab       	sts	0x5c, r19
    6cd4:	c5 01       	movw	r24, r10
    6cd6:	b4 01       	movw	r22, r8
    6cd8:	a3 01       	movw	r20, r6
    6cda:	92 01       	movw	r18, r4
    6cdc:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    6ce0:	69 af       	sts	0x79, r22
    6ce2:	7a af       	sts	0x7a, r23
    6ce4:	8b af       	sts	0x7b, r24
    6ce6:	9c af       	sts	0x7c, r25
    6ce8:	c5 01       	movw	r24, r10
    6cea:	b4 01       	movw	r22, r8
    6cec:	29 a9       	sts	0x49, r18
    6cee:	3a a9       	sts	0x4a, r19
    6cf0:	4b a9       	sts	0x4b, r20
    6cf2:	5c a9       	sts	0x4c, r21
    6cf4:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    6cf8:	4b 01       	movw	r8, r22
    6cfa:	5c 01       	movw	r10, r24
    6cfc:	69 a5       	lds	r22, 0x69
    6cfe:	7a a5       	lds	r23, 0x6a
    6d00:	8b a5       	lds	r24, 0x6b
    6d02:	9c a5       	lds	r25, 0x6c
    6d04:	a3 01       	movw	r20, r6
    6d06:	92 01       	movw	r18, r4
    6d08:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    6d0c:	2b 01       	movw	r4, r22
    6d0e:	3c 01       	movw	r6, r24
    6d10:	69 a5       	lds	r22, 0x69
    6d12:	7a a5       	lds	r23, 0x6a
    6d14:	8b a5       	lds	r24, 0x6b
    6d16:	9c a5       	lds	r25, 0x6c
    6d18:	29 a9       	sts	0x49, r18
    6d1a:	3a a9       	sts	0x4a, r19
    6d1c:	4b a9       	sts	0x4b, r20
    6d1e:	5c a9       	sts	0x4c, r21
    6d20:	0e 94 25 39 	call	0x724a	; 0x724a <__mulsi3>
    6d24:	ab 01       	movw	r20, r22
    6d26:	bc 01       	movw	r22, r24
    6d28:	84 0c       	add	r8, r4
    6d2a:	95 1c       	adc	r9, r5
    6d2c:	a6 1c       	adc	r10, r6
    6d2e:	b7 1c       	adc	r11, r7
    6d30:	09 ad       	sts	0x69, r16
    6d32:	1a ad       	sts	0x6a, r17
    6d34:	2b ad       	sts	0x6b, r18
    6d36:	3c ad       	sts	0x6c, r19
    6d38:	c9 01       	movw	r24, r18
    6d3a:	aa 27       	eor	r26, r26
    6d3c:	bb 27       	eor	r27, r27
    6d3e:	88 0e       	add	r8, r24
    6d40:	99 1e       	adc	r9, r25
    6d42:	aa 1e       	adc	r10, r26
    6d44:	bb 1e       	adc	r11, r27
    6d46:	84 14       	cp	r8, r4
    6d48:	95 04       	cpc	r9, r5
    6d4a:	a6 04       	cpc	r10, r6
    6d4c:	b7 04       	cpc	r11, r7
    6d4e:	20 f4       	brcc	.+8      	; 0x6d58 <__stack+0xd59>
    6d50:	40 50       	subi	r20, 0x00	; 0
    6d52:	50 40       	sbci	r21, 0x00	; 0
    6d54:	6f 4f       	sbci	r22, 0xFF	; 255
    6d56:	7f 4f       	sbci	r23, 0xFF	; 255
    6d58:	c5 01       	movw	r24, r10
    6d5a:	aa 27       	eor	r26, r26
    6d5c:	bb 27       	eor	r27, r27
    6d5e:	84 0f       	add	r24, r20
    6d60:	95 1f       	adc	r25, r21
    6d62:	a6 1f       	adc	r26, r22
    6d64:	b7 1f       	adc	r27, r23
    6d66:	0d a5       	lds	r16, 0x6d
    6d68:	1e a5       	lds	r17, 0x6e
    6d6a:	2f a5       	lds	r18, 0x6f
    6d6c:	38 a9       	sts	0x48, r19
    6d6e:	08 17       	cp	r16, r24
    6d70:	19 07       	cpc	r17, r25
    6d72:	2a 07       	cpc	r18, r26
    6d74:	3b 07       	cpc	r19, r27
    6d76:	18 f1       	brcs	.+70     	; 0x6dbe <__stack+0xdbf>
    6d78:	80 17       	cp	r24, r16
    6d7a:	91 07       	cpc	r25, r17
    6d7c:	a2 07       	cpc	r26, r18
    6d7e:	b3 07       	cpc	r27, r19
    6d80:	a1 f5       	brne	.+104    	; 0x6dea <__stack+0xdeb>
    6d82:	54 01       	movw	r10, r8
    6d84:	99 24       	eor	r9, r9
    6d86:	88 24       	eor	r8, r8
    6d88:	89 ad       	sts	0x69, r24
    6d8a:	9a ad       	sts	0x6a, r25
    6d8c:	ab ad       	sts	0x6b, r26
    6d8e:	bc ad       	sts	0x6c, r27
    6d90:	a0 70       	andi	r26, 0x00	; 0
    6d92:	b0 70       	andi	r27, 0x00	; 0
    6d94:	88 0e       	add	r8, r24
    6d96:	99 1e       	adc	r9, r25
    6d98:	aa 1e       	adc	r10, r26
    6d9a:	bb 1e       	adc	r11, r27
    6d9c:	4d a9       	sts	0x4d, r20
    6d9e:	5e a9       	sts	0x4e, r21
    6da0:	6f a9       	sts	0x4f, r22
    6da2:	78 ad       	sts	0x68, r23
    6da4:	03 2c       	mov	r0, r3
    6da6:	04 c0       	rjmp	.+8      	; 0x6db0 <__stack+0xdb1>
    6da8:	44 0f       	add	r20, r20
    6daa:	55 1f       	adc	r21, r21
    6dac:	66 1f       	adc	r22, r22
    6dae:	77 1f       	adc	r23, r23
    6db0:	0a 94       	dec	r0
    6db2:	d2 f7       	brpl	.-12     	; 0x6da8 <__stack+0xda9>
    6db4:	48 15       	cp	r20, r8
    6db6:	59 05       	cpc	r21, r9
    6db8:	6a 05       	cpc	r22, r10
    6dba:	7b 05       	cpc	r23, r11
    6dbc:	b0 f4       	brcc	.+44     	; 0x6dea <__stack+0xdeb>
    6dbe:	08 94       	sec
    6dc0:	c1 08       	sbc	r12, r1
    6dc2:	d1 08       	sbc	r13, r1
    6dc4:	e1 08       	sbc	r14, r1
    6dc6:	f1 08       	sbc	r15, r1
    6dc8:	10 c0       	rjmp	.+32     	; 0x6dea <__stack+0xdeb>
    6dca:	44 24       	eor	r4, r4
    6dcc:	55 24       	eor	r5, r5
    6dce:	32 01       	movw	r6, r4
    6dd0:	cc 24       	eor	r12, r12
    6dd2:	dd 24       	eor	r13, r13
    6dd4:	76 01       	movw	r14, r12
    6dd6:	0c c0       	rjmp	.+24     	; 0x6df0 <__stack+0xdf1>
    6dd8:	44 24       	eor	r4, r4
    6dda:	55 24       	eor	r5, r5
    6ddc:	32 01       	movw	r6, r4
    6dde:	81 e0       	ldi	r24, 0x01	; 1
    6de0:	c8 2e       	mov	r12, r24
    6de2:	d1 2c       	mov	r13, r1
    6de4:	e1 2c       	mov	r14, r1
    6de6:	f1 2c       	mov	r15, r1
    6de8:	03 c0       	rjmp	.+6      	; 0x6df0 <__stack+0xdf1>
    6dea:	44 24       	eor	r4, r4
    6dec:	55 24       	eor	r5, r5
    6dee:	32 01       	movw	r6, r4
    6df0:	fe 01       	movw	r30, r28
    6df2:	31 96       	adiw	r30, 0x01	; 1
    6df4:	88 e0       	ldi	r24, 0x08	; 8
    6df6:	df 01       	movw	r26, r30
    6df8:	1d 92       	st	X+, r1
    6dfa:	8a 95       	dec	r24
    6dfc:	e9 f7       	brne	.-6      	; 0x6df8 <__stack+0xdf9>
    6dfe:	c9 82       	std	Y+1, r12	; 0x01
    6e00:	da 82       	std	Y+2, r13	; 0x02
    6e02:	eb 82       	std	Y+3, r14	; 0x03
    6e04:	fc 82       	std	Y+4, r15	; 0x04
    6e06:	4d 82       	std	Y+5, r4	; 0x05
    6e08:	5e 82       	std	Y+6, r5	; 0x06
    6e0a:	6f 82       	std	Y+7, r6	; 0x07
    6e0c:	78 86       	std	Y+8, r7	; 0x08
    6e0e:	2c 2d       	mov	r18, r12
    6e10:	3a 81       	ldd	r19, Y+2	; 0x02
    6e12:	4b 81       	ldd	r20, Y+3	; 0x03
    6e14:	5c 81       	ldd	r21, Y+4	; 0x04
    6e16:	64 2d       	mov	r22, r4
    6e18:	7e 81       	ldd	r23, Y+6	; 0x06
    6e1a:	8f 81       	ldd	r24, Y+7	; 0x07
    6e1c:	98 85       	ldd	r25, Y+8	; 0x08
    6e1e:	25 96       	adiw	r28, 0x05	; 5
    6e20:	ec ac       	sts	0xac, r30
    6e22:	fd ac       	sts	0xad, r31
    6e24:	0e ad       	sts	0x6e, r16
    6e26:	1f ad       	sts	0x6f, r17
    6e28:	25 97       	sbiw	r28, 0x05	; 5
    6e2a:	e1 14       	cp	r14, r1
    6e2c:	f1 04       	cpc	r15, r1
    6e2e:	01 05       	cpc	r16, r1
    6e30:	11 05       	cpc	r17, r1
    6e32:	09 f4       	brne	.+2      	; 0x6e36 <__stack+0xe37>
    6e34:	56 c0       	rjmp	.+172    	; 0x6ee2 <__stack+0xee3>
    6e36:	21 95       	neg	r18
    6e38:	e1 e0       	ldi	r30, 0x01	; 1
    6e3a:	12 16       	cp	r1, r18
    6e3c:	08 f0       	brcs	.+2      	; 0x6e40 <__stack+0xe41>
    6e3e:	e0 e0       	ldi	r30, 0x00	; 0
    6e40:	31 95       	neg	r19
    6e42:	f1 e0       	ldi	r31, 0x01	; 1
    6e44:	13 16       	cp	r1, r19
    6e46:	08 f0       	brcs	.+2      	; 0x6e4a <__stack+0xe4b>
    6e48:	f0 e0       	ldi	r31, 0x00	; 0
    6e4a:	03 2f       	mov	r16, r19
    6e4c:	0e 1b       	sub	r16, r30
    6e4e:	e1 e0       	ldi	r30, 0x01	; 1
    6e50:	30 17       	cp	r19, r16
    6e52:	08 f0       	brcs	.+2      	; 0x6e56 <__stack+0xe57>
    6e54:	e0 e0       	ldi	r30, 0x00	; 0
    6e56:	fe 2b       	or	r31, r30
    6e58:	41 95       	neg	r20
    6e5a:	e1 e0       	ldi	r30, 0x01	; 1
    6e5c:	14 16       	cp	r1, r20
    6e5e:	08 f0       	brcs	.+2      	; 0x6e62 <__stack+0xe63>
    6e60:	e0 e0       	ldi	r30, 0x00	; 0
    6e62:	14 2f       	mov	r17, r20
    6e64:	1f 1b       	sub	r17, r31
    6e66:	31 e0       	ldi	r19, 0x01	; 1
    6e68:	41 17       	cp	r20, r17
    6e6a:	08 f0       	brcs	.+2      	; 0x6e6e <__stack+0xe6f>
    6e6c:	30 e0       	ldi	r19, 0x00	; 0
    6e6e:	e3 2b       	or	r30, r19
    6e70:	51 95       	neg	r21
    6e72:	f1 e0       	ldi	r31, 0x01	; 1
    6e74:	15 16       	cp	r1, r21
    6e76:	08 f0       	brcs	.+2      	; 0x6e7a <__stack+0xe7b>
    6e78:	f0 e0       	ldi	r31, 0x00	; 0
    6e7a:	b5 2f       	mov	r27, r21
    6e7c:	be 1b       	sub	r27, r30
    6e7e:	31 e0       	ldi	r19, 0x01	; 1
    6e80:	5b 17       	cp	r21, r27
    6e82:	08 f0       	brcs	.+2      	; 0x6e86 <__stack+0xe87>
    6e84:	30 e0       	ldi	r19, 0x00	; 0
    6e86:	f3 2b       	or	r31, r19
    6e88:	61 95       	neg	r22
    6e8a:	e1 e0       	ldi	r30, 0x01	; 1
    6e8c:	16 16       	cp	r1, r22
    6e8e:	08 f0       	brcs	.+2      	; 0x6e92 <__stack+0xe93>
    6e90:	e0 e0       	ldi	r30, 0x00	; 0
    6e92:	46 2e       	mov	r4, r22
    6e94:	4f 1a       	sub	r4, r31
    6e96:	31 e0       	ldi	r19, 0x01	; 1
    6e98:	64 15       	cp	r22, r4
    6e9a:	08 f0       	brcs	.+2      	; 0x6e9e <__stack+0xe9f>
    6e9c:	30 e0       	ldi	r19, 0x00	; 0
    6e9e:	e3 2b       	or	r30, r19
    6ea0:	71 95       	neg	r23
    6ea2:	f1 e0       	ldi	r31, 0x01	; 1
    6ea4:	17 16       	cp	r1, r23
    6ea6:	08 f0       	brcs	.+2      	; 0x6eaa <__stack+0xeab>
    6ea8:	f0 e0       	ldi	r31, 0x00	; 0
    6eaa:	a7 2f       	mov	r26, r23
    6eac:	ae 1b       	sub	r26, r30
    6eae:	31 e0       	ldi	r19, 0x01	; 1
    6eb0:	7a 17       	cp	r23, r26
    6eb2:	08 f0       	brcs	.+2      	; 0x6eb6 <__stack+0xeb7>
    6eb4:	30 e0       	ldi	r19, 0x00	; 0
    6eb6:	f3 2b       	or	r31, r19
    6eb8:	81 95       	neg	r24
    6eba:	e1 e0       	ldi	r30, 0x01	; 1
    6ebc:	18 16       	cp	r1, r24
    6ebe:	08 f0       	brcs	.+2      	; 0x6ec2 <__stack+0xec3>
    6ec0:	e0 e0       	ldi	r30, 0x00	; 0
    6ec2:	f8 2e       	mov	r15, r24
    6ec4:	ff 1a       	sub	r15, r31
    6ec6:	ff 2d       	mov	r31, r15
    6ec8:	31 e0       	ldi	r19, 0x01	; 1
    6eca:	8f 15       	cp	r24, r15
    6ecc:	08 f0       	brcs	.+2      	; 0x6ed0 <__stack+0xed1>
    6ece:	30 e0       	ldi	r19, 0x00	; 0
    6ed0:	e3 2b       	or	r30, r19
    6ed2:	91 95       	neg	r25
    6ed4:	30 2f       	mov	r19, r16
    6ed6:	41 2f       	mov	r20, r17
    6ed8:	5b 2f       	mov	r21, r27
    6eda:	64 2d       	mov	r22, r4
    6edc:	7a 2f       	mov	r23, r26
    6ede:	8f 2f       	mov	r24, r31
    6ee0:	9e 1b       	sub	r25, r30
    6ee2:	c8 5b       	subi	r28, 0xB8	; 184
    6ee4:	df 4f       	sbci	r29, 0xFF	; 255
    6ee6:	e1 e1       	ldi	r30, 0x11	; 17
    6ee8:	0c 94 c2 39 	jmp	0x7384	; 0x7384 <__epilogue_restores__+0x2>

00006eec <__subsf3>:
    6eec:	50 58       	subi	r21, 0x80	; 128

00006eee <__addsf3>:
    6eee:	bb 27       	eor	r27, r27
    6ef0:	aa 27       	eor	r26, r26
    6ef2:	0e d0       	rcall	.+28     	; 0x6f10 <__addsf3x>
    6ef4:	48 c1       	rjmp	.+656    	; 0x7186 <__fp_round>
    6ef6:	39 d1       	rcall	.+626    	; 0x716a <__fp_pscA>
    6ef8:	30 f0       	brcs	.+12     	; 0x6f06 <__addsf3+0x18>
    6efa:	3e d1       	rcall	.+636    	; 0x7178 <__fp_pscB>
    6efc:	20 f0       	brcs	.+8      	; 0x6f06 <__addsf3+0x18>
    6efe:	31 f4       	brne	.+12     	; 0x6f0c <__addsf3+0x1e>
    6f00:	9f 3f       	cpi	r25, 0xFF	; 255
    6f02:	11 f4       	brne	.+4      	; 0x6f08 <__addsf3+0x1a>
    6f04:	1e f4       	brtc	.+6      	; 0x6f0c <__addsf3+0x1e>
    6f06:	2e c1       	rjmp	.+604    	; 0x7164 <__fp_nan>
    6f08:	0e f4       	brtc	.+2      	; 0x6f0c <__addsf3+0x1e>
    6f0a:	e0 95       	com	r30
    6f0c:	e7 fb       	bst	r30, 7
    6f0e:	24 c1       	rjmp	.+584    	; 0x7158 <__fp_inf>

00006f10 <__addsf3x>:
    6f10:	e9 2f       	mov	r30, r25
    6f12:	4a d1       	rcall	.+660    	; 0x71a8 <__fp_split3>
    6f14:	80 f3       	brcs	.-32     	; 0x6ef6 <__addsf3+0x8>
    6f16:	ba 17       	cp	r27, r26
    6f18:	62 07       	cpc	r22, r18
    6f1a:	73 07       	cpc	r23, r19
    6f1c:	84 07       	cpc	r24, r20
    6f1e:	95 07       	cpc	r25, r21
    6f20:	18 f0       	brcs	.+6      	; 0x6f28 <__addsf3x+0x18>
    6f22:	71 f4       	brne	.+28     	; 0x6f40 <__addsf3x+0x30>
    6f24:	9e f5       	brtc	.+102    	; 0x6f8c <__addsf3x+0x7c>
    6f26:	62 c1       	rjmp	.+708    	; 0x71ec <__fp_zero>
    6f28:	0e f4       	brtc	.+2      	; 0x6f2c <__addsf3x+0x1c>
    6f2a:	e0 95       	com	r30
    6f2c:	0b 2e       	mov	r0, r27
    6f2e:	ba 2f       	mov	r27, r26
    6f30:	a0 2d       	mov	r26, r0
    6f32:	0b 01       	movw	r0, r22
    6f34:	b9 01       	movw	r22, r18
    6f36:	90 01       	movw	r18, r0
    6f38:	0c 01       	movw	r0, r24
    6f3a:	ca 01       	movw	r24, r20
    6f3c:	a0 01       	movw	r20, r0
    6f3e:	11 24       	eor	r1, r1
    6f40:	ff 27       	eor	r31, r31
    6f42:	59 1b       	sub	r21, r25
    6f44:	99 f0       	breq	.+38     	; 0x6f6c <__addsf3x+0x5c>
    6f46:	59 3f       	cpi	r21, 0xF9	; 249
    6f48:	50 f4       	brcc	.+20     	; 0x6f5e <__addsf3x+0x4e>
    6f4a:	50 3e       	cpi	r21, 0xE0	; 224
    6f4c:	68 f1       	brcs	.+90     	; 0x6fa8 <__addsf3x+0x98>
    6f4e:	1a 16       	cp	r1, r26
    6f50:	f0 40       	sbci	r31, 0x00	; 0
    6f52:	a2 2f       	mov	r26, r18
    6f54:	23 2f       	mov	r18, r19
    6f56:	34 2f       	mov	r19, r20
    6f58:	44 27       	eor	r20, r20
    6f5a:	58 5f       	subi	r21, 0xF8	; 248
    6f5c:	f3 cf       	rjmp	.-26     	; 0x6f44 <__addsf3x+0x34>
    6f5e:	46 95       	lsr	r20
    6f60:	37 95       	ror	r19
    6f62:	27 95       	ror	r18
    6f64:	a7 95       	ror	r26
    6f66:	f0 40       	sbci	r31, 0x00	; 0
    6f68:	53 95       	inc	r21
    6f6a:	c9 f7       	brne	.-14     	; 0x6f5e <__addsf3x+0x4e>
    6f6c:	7e f4       	brtc	.+30     	; 0x6f8c <__addsf3x+0x7c>
    6f6e:	1f 16       	cp	r1, r31
    6f70:	ba 0b       	sbc	r27, r26
    6f72:	62 0b       	sbc	r22, r18
    6f74:	73 0b       	sbc	r23, r19
    6f76:	84 0b       	sbc	r24, r20
    6f78:	ba f0       	brmi	.+46     	; 0x6fa8 <__addsf3x+0x98>
    6f7a:	91 50       	subi	r25, 0x01	; 1
    6f7c:	a1 f0       	breq	.+40     	; 0x6fa6 <__addsf3x+0x96>
    6f7e:	ff 0f       	add	r31, r31
    6f80:	bb 1f       	adc	r27, r27
    6f82:	66 1f       	adc	r22, r22
    6f84:	77 1f       	adc	r23, r23
    6f86:	88 1f       	adc	r24, r24
    6f88:	c2 f7       	brpl	.-16     	; 0x6f7a <__addsf3x+0x6a>
    6f8a:	0e c0       	rjmp	.+28     	; 0x6fa8 <__addsf3x+0x98>
    6f8c:	ba 0f       	add	r27, r26
    6f8e:	62 1f       	adc	r22, r18
    6f90:	73 1f       	adc	r23, r19
    6f92:	84 1f       	adc	r24, r20
    6f94:	48 f4       	brcc	.+18     	; 0x6fa8 <__addsf3x+0x98>
    6f96:	87 95       	ror	r24
    6f98:	77 95       	ror	r23
    6f9a:	67 95       	ror	r22
    6f9c:	b7 95       	ror	r27
    6f9e:	f7 95       	ror	r31
    6fa0:	9e 3f       	cpi	r25, 0xFE	; 254
    6fa2:	08 f0       	brcs	.+2      	; 0x6fa6 <__addsf3x+0x96>
    6fa4:	b3 cf       	rjmp	.-154    	; 0x6f0c <__addsf3+0x1e>
    6fa6:	93 95       	inc	r25
    6fa8:	88 0f       	add	r24, r24
    6faa:	08 f0       	brcs	.+2      	; 0x6fae <__addsf3x+0x9e>
    6fac:	99 27       	eor	r25, r25
    6fae:	ee 0f       	add	r30, r30
    6fb0:	97 95       	ror	r25
    6fb2:	87 95       	ror	r24
    6fb4:	08 95       	ret

00006fb6 <__divsf3>:
    6fb6:	0c d0       	rcall	.+24     	; 0x6fd0 <__divsf3x>
    6fb8:	e6 c0       	rjmp	.+460    	; 0x7186 <__fp_round>
    6fba:	de d0       	rcall	.+444    	; 0x7178 <__fp_pscB>
    6fbc:	40 f0       	brcs	.+16     	; 0x6fce <__divsf3+0x18>
    6fbe:	d5 d0       	rcall	.+426    	; 0x716a <__fp_pscA>
    6fc0:	30 f0       	brcs	.+12     	; 0x6fce <__divsf3+0x18>
    6fc2:	21 f4       	brne	.+8      	; 0x6fcc <__divsf3+0x16>
    6fc4:	5f 3f       	cpi	r21, 0xFF	; 255
    6fc6:	19 f0       	breq	.+6      	; 0x6fce <__divsf3+0x18>
    6fc8:	c7 c0       	rjmp	.+398    	; 0x7158 <__fp_inf>
    6fca:	51 11       	cpse	r21, r1
    6fcc:	10 c1       	rjmp	.+544    	; 0x71ee <__fp_szero>
    6fce:	ca c0       	rjmp	.+404    	; 0x7164 <__fp_nan>

00006fd0 <__divsf3x>:
    6fd0:	eb d0       	rcall	.+470    	; 0x71a8 <__fp_split3>
    6fd2:	98 f3       	brcs	.-26     	; 0x6fba <__divsf3+0x4>

00006fd4 <__divsf3_pse>:
    6fd4:	99 23       	and	r25, r25
    6fd6:	c9 f3       	breq	.-14     	; 0x6fca <__divsf3+0x14>
    6fd8:	55 23       	and	r21, r21
    6fda:	b1 f3       	breq	.-20     	; 0x6fc8 <__divsf3+0x12>
    6fdc:	95 1b       	sub	r25, r21
    6fde:	55 0b       	sbc	r21, r21
    6fe0:	bb 27       	eor	r27, r27
    6fe2:	aa 27       	eor	r26, r26
    6fe4:	62 17       	cp	r22, r18
    6fe6:	73 07       	cpc	r23, r19
    6fe8:	84 07       	cpc	r24, r20
    6fea:	38 f0       	brcs	.+14     	; 0x6ffa <__divsf3_pse+0x26>
    6fec:	9f 5f       	subi	r25, 0xFF	; 255
    6fee:	5f 4f       	sbci	r21, 0xFF	; 255
    6ff0:	22 0f       	add	r18, r18
    6ff2:	33 1f       	adc	r19, r19
    6ff4:	44 1f       	adc	r20, r20
    6ff6:	aa 1f       	adc	r26, r26
    6ff8:	a9 f3       	breq	.-22     	; 0x6fe4 <__divsf3_pse+0x10>
    6ffa:	33 d0       	rcall	.+102    	; 0x7062 <__divsf3_pse+0x8e>
    6ffc:	0e 2e       	mov	r0, r30
    6ffe:	3a f0       	brmi	.+14     	; 0x700e <__divsf3_pse+0x3a>
    7000:	e0 e8       	ldi	r30, 0x80	; 128
    7002:	30 d0       	rcall	.+96     	; 0x7064 <__divsf3_pse+0x90>
    7004:	91 50       	subi	r25, 0x01	; 1
    7006:	50 40       	sbci	r21, 0x00	; 0
    7008:	e6 95       	lsr	r30
    700a:	00 1c       	adc	r0, r0
    700c:	ca f7       	brpl	.-14     	; 0x7000 <__divsf3_pse+0x2c>
    700e:	29 d0       	rcall	.+82     	; 0x7062 <__divsf3_pse+0x8e>
    7010:	fe 2f       	mov	r31, r30
    7012:	27 d0       	rcall	.+78     	; 0x7062 <__divsf3_pse+0x8e>
    7014:	66 0f       	add	r22, r22
    7016:	77 1f       	adc	r23, r23
    7018:	88 1f       	adc	r24, r24
    701a:	bb 1f       	adc	r27, r27
    701c:	26 17       	cp	r18, r22
    701e:	37 07       	cpc	r19, r23
    7020:	48 07       	cpc	r20, r24
    7022:	ab 07       	cpc	r26, r27
    7024:	b0 e8       	ldi	r27, 0x80	; 128
    7026:	09 f0       	breq	.+2      	; 0x702a <__divsf3_pse+0x56>
    7028:	bb 0b       	sbc	r27, r27
    702a:	80 2d       	mov	r24, r0
    702c:	bf 01       	movw	r22, r30
    702e:	ff 27       	eor	r31, r31
    7030:	93 58       	subi	r25, 0x83	; 131
    7032:	5f 4f       	sbci	r21, 0xFF	; 255
    7034:	2a f0       	brmi	.+10     	; 0x7040 <__divsf3_pse+0x6c>
    7036:	9e 3f       	cpi	r25, 0xFE	; 254
    7038:	51 05       	cpc	r21, r1
    703a:	68 f0       	brcs	.+26     	; 0x7056 <__divsf3_pse+0x82>
    703c:	8d c0       	rjmp	.+282    	; 0x7158 <__fp_inf>
    703e:	d7 c0       	rjmp	.+430    	; 0x71ee <__fp_szero>
    7040:	5f 3f       	cpi	r21, 0xFF	; 255
    7042:	ec f3       	brlt	.-6      	; 0x703e <__divsf3_pse+0x6a>
    7044:	98 3e       	cpi	r25, 0xE8	; 232
    7046:	dc f3       	brlt	.-10     	; 0x703e <__divsf3_pse+0x6a>
    7048:	86 95       	lsr	r24
    704a:	77 95       	ror	r23
    704c:	67 95       	ror	r22
    704e:	b7 95       	ror	r27
    7050:	f7 95       	ror	r31
    7052:	9f 5f       	subi	r25, 0xFF	; 255
    7054:	c9 f7       	brne	.-14     	; 0x7048 <__divsf3_pse+0x74>
    7056:	88 0f       	add	r24, r24
    7058:	91 1d       	adc	r25, r1
    705a:	96 95       	lsr	r25
    705c:	87 95       	ror	r24
    705e:	97 f9       	bld	r25, 7
    7060:	08 95       	ret
    7062:	e1 e0       	ldi	r30, 0x01	; 1
    7064:	66 0f       	add	r22, r22
    7066:	77 1f       	adc	r23, r23
    7068:	88 1f       	adc	r24, r24
    706a:	bb 1f       	adc	r27, r27
    706c:	62 17       	cp	r22, r18
    706e:	73 07       	cpc	r23, r19
    7070:	84 07       	cpc	r24, r20
    7072:	ba 07       	cpc	r27, r26
    7074:	20 f0       	brcs	.+8      	; 0x707e <__divsf3_pse+0xaa>
    7076:	62 1b       	sub	r22, r18
    7078:	73 0b       	sbc	r23, r19
    707a:	84 0b       	sbc	r24, r20
    707c:	ba 0b       	sbc	r27, r26
    707e:	ee 1f       	adc	r30, r30
    7080:	88 f7       	brcc	.-30     	; 0x7064 <__divsf3_pse+0x90>
    7082:	e0 95       	com	r30
    7084:	08 95       	ret

00007086 <__fixunssfsi>:
    7086:	98 d0       	rcall	.+304    	; 0x71b8 <__fp_splitA>
    7088:	88 f0       	brcs	.+34     	; 0x70ac <__fixunssfsi+0x26>
    708a:	9f 57       	subi	r25, 0x7F	; 127
    708c:	90 f0       	brcs	.+36     	; 0x70b2 <__fixunssfsi+0x2c>
    708e:	b9 2f       	mov	r27, r25
    7090:	99 27       	eor	r25, r25
    7092:	b7 51       	subi	r27, 0x17	; 23
    7094:	a0 f0       	brcs	.+40     	; 0x70be <__fixunssfsi+0x38>
    7096:	d1 f0       	breq	.+52     	; 0x70cc <__fixunssfsi+0x46>
    7098:	66 0f       	add	r22, r22
    709a:	77 1f       	adc	r23, r23
    709c:	88 1f       	adc	r24, r24
    709e:	99 1f       	adc	r25, r25
    70a0:	1a f0       	brmi	.+6      	; 0x70a8 <__fixunssfsi+0x22>
    70a2:	ba 95       	dec	r27
    70a4:	c9 f7       	brne	.-14     	; 0x7098 <__fixunssfsi+0x12>
    70a6:	12 c0       	rjmp	.+36     	; 0x70cc <__fixunssfsi+0x46>
    70a8:	b1 30       	cpi	r27, 0x01	; 1
    70aa:	81 f0       	breq	.+32     	; 0x70cc <__fixunssfsi+0x46>
    70ac:	9f d0       	rcall	.+318    	; 0x71ec <__fp_zero>
    70ae:	b1 e0       	ldi	r27, 0x01	; 1
    70b0:	08 95       	ret
    70b2:	9c c0       	rjmp	.+312    	; 0x71ec <__fp_zero>
    70b4:	67 2f       	mov	r22, r23
    70b6:	78 2f       	mov	r23, r24
    70b8:	88 27       	eor	r24, r24
    70ba:	b8 5f       	subi	r27, 0xF8	; 248
    70bc:	39 f0       	breq	.+14     	; 0x70cc <__fixunssfsi+0x46>
    70be:	b9 3f       	cpi	r27, 0xF9	; 249
    70c0:	cc f3       	brlt	.-14     	; 0x70b4 <__fixunssfsi+0x2e>
    70c2:	86 95       	lsr	r24
    70c4:	77 95       	ror	r23
    70c6:	67 95       	ror	r22
    70c8:	b3 95       	inc	r27
    70ca:	d9 f7       	brne	.-10     	; 0x70c2 <__fixunssfsi+0x3c>
    70cc:	3e f4       	brtc	.+14     	; 0x70dc <__fixunssfsi+0x56>
    70ce:	90 95       	com	r25
    70d0:	80 95       	com	r24
    70d2:	70 95       	com	r23
    70d4:	61 95       	neg	r22
    70d6:	7f 4f       	sbci	r23, 0xFF	; 255
    70d8:	8f 4f       	sbci	r24, 0xFF	; 255
    70da:	9f 4f       	sbci	r25, 0xFF	; 255
    70dc:	08 95       	ret

000070de <__floatunsisf>:
    70de:	e8 94       	clt
    70e0:	09 c0       	rjmp	.+18     	; 0x70f4 <__floatsisf+0x12>

000070e2 <__floatsisf>:
    70e2:	97 fb       	bst	r25, 7
    70e4:	3e f4       	brtc	.+14     	; 0x70f4 <__floatsisf+0x12>
    70e6:	90 95       	com	r25
    70e8:	80 95       	com	r24
    70ea:	70 95       	com	r23
    70ec:	61 95       	neg	r22
    70ee:	7f 4f       	sbci	r23, 0xFF	; 255
    70f0:	8f 4f       	sbci	r24, 0xFF	; 255
    70f2:	9f 4f       	sbci	r25, 0xFF	; 255
    70f4:	99 23       	and	r25, r25
    70f6:	a9 f0       	breq	.+42     	; 0x7122 <__floatsisf+0x40>
    70f8:	f9 2f       	mov	r31, r25
    70fa:	96 e9       	ldi	r25, 0x96	; 150
    70fc:	bb 27       	eor	r27, r27
    70fe:	93 95       	inc	r25
    7100:	f6 95       	lsr	r31
    7102:	87 95       	ror	r24
    7104:	77 95       	ror	r23
    7106:	67 95       	ror	r22
    7108:	b7 95       	ror	r27
    710a:	f1 11       	cpse	r31, r1
    710c:	f8 cf       	rjmp	.-16     	; 0x70fe <__floatsisf+0x1c>
    710e:	fa f4       	brpl	.+62     	; 0x714e <__floatsisf+0x6c>
    7110:	bb 0f       	add	r27, r27
    7112:	11 f4       	brne	.+4      	; 0x7118 <__floatsisf+0x36>
    7114:	60 ff       	sbrs	r22, 0
    7116:	1b c0       	rjmp	.+54     	; 0x714e <__floatsisf+0x6c>
    7118:	6f 5f       	subi	r22, 0xFF	; 255
    711a:	7f 4f       	sbci	r23, 0xFF	; 255
    711c:	8f 4f       	sbci	r24, 0xFF	; 255
    711e:	9f 4f       	sbci	r25, 0xFF	; 255
    7120:	16 c0       	rjmp	.+44     	; 0x714e <__floatsisf+0x6c>
    7122:	88 23       	and	r24, r24
    7124:	11 f0       	breq	.+4      	; 0x712a <__floatsisf+0x48>
    7126:	96 e9       	ldi	r25, 0x96	; 150
    7128:	11 c0       	rjmp	.+34     	; 0x714c <__floatsisf+0x6a>
    712a:	77 23       	and	r23, r23
    712c:	21 f0       	breq	.+8      	; 0x7136 <__floatsisf+0x54>
    712e:	9e e8       	ldi	r25, 0x8E	; 142
    7130:	87 2f       	mov	r24, r23
    7132:	76 2f       	mov	r23, r22
    7134:	05 c0       	rjmp	.+10     	; 0x7140 <__floatsisf+0x5e>
    7136:	66 23       	and	r22, r22
    7138:	71 f0       	breq	.+28     	; 0x7156 <__floatsisf+0x74>
    713a:	96 e8       	ldi	r25, 0x86	; 134
    713c:	86 2f       	mov	r24, r22
    713e:	70 e0       	ldi	r23, 0x00	; 0
    7140:	60 e0       	ldi	r22, 0x00	; 0
    7142:	2a f0       	brmi	.+10     	; 0x714e <__floatsisf+0x6c>
    7144:	9a 95       	dec	r25
    7146:	66 0f       	add	r22, r22
    7148:	77 1f       	adc	r23, r23
    714a:	88 1f       	adc	r24, r24
    714c:	da f7       	brpl	.-10     	; 0x7144 <__floatsisf+0x62>
    714e:	88 0f       	add	r24, r24
    7150:	96 95       	lsr	r25
    7152:	87 95       	ror	r24
    7154:	97 f9       	bld	r25, 7
    7156:	08 95       	ret

00007158 <__fp_inf>:
    7158:	97 f9       	bld	r25, 7
    715a:	9f 67       	ori	r25, 0x7F	; 127
    715c:	80 e8       	ldi	r24, 0x80	; 128
    715e:	70 e0       	ldi	r23, 0x00	; 0
    7160:	60 e0       	ldi	r22, 0x00	; 0
    7162:	08 95       	ret

00007164 <__fp_nan>:
    7164:	9f ef       	ldi	r25, 0xFF	; 255
    7166:	80 ec       	ldi	r24, 0xC0	; 192
    7168:	08 95       	ret

0000716a <__fp_pscA>:
    716a:	00 24       	eor	r0, r0
    716c:	0a 94       	dec	r0
    716e:	16 16       	cp	r1, r22
    7170:	17 06       	cpc	r1, r23
    7172:	18 06       	cpc	r1, r24
    7174:	09 06       	cpc	r0, r25
    7176:	08 95       	ret

00007178 <__fp_pscB>:
    7178:	00 24       	eor	r0, r0
    717a:	0a 94       	dec	r0
    717c:	12 16       	cp	r1, r18
    717e:	13 06       	cpc	r1, r19
    7180:	14 06       	cpc	r1, r20
    7182:	05 06       	cpc	r0, r21
    7184:	08 95       	ret

00007186 <__fp_round>:
    7186:	09 2e       	mov	r0, r25
    7188:	03 94       	inc	r0
    718a:	00 0c       	add	r0, r0
    718c:	11 f4       	brne	.+4      	; 0x7192 <__fp_round+0xc>
    718e:	88 23       	and	r24, r24
    7190:	52 f0       	brmi	.+20     	; 0x71a6 <__fp_round+0x20>
    7192:	bb 0f       	add	r27, r27
    7194:	40 f4       	brcc	.+16     	; 0x71a6 <__fp_round+0x20>
    7196:	bf 2b       	or	r27, r31
    7198:	11 f4       	brne	.+4      	; 0x719e <__fp_round+0x18>
    719a:	60 ff       	sbrs	r22, 0
    719c:	04 c0       	rjmp	.+8      	; 0x71a6 <__fp_round+0x20>
    719e:	6f 5f       	subi	r22, 0xFF	; 255
    71a0:	7f 4f       	sbci	r23, 0xFF	; 255
    71a2:	8f 4f       	sbci	r24, 0xFF	; 255
    71a4:	9f 4f       	sbci	r25, 0xFF	; 255
    71a6:	08 95       	ret

000071a8 <__fp_split3>:
    71a8:	57 fd       	sbrc	r21, 7
    71aa:	90 58       	subi	r25, 0x80	; 128
    71ac:	44 0f       	add	r20, r20
    71ae:	55 1f       	adc	r21, r21
    71b0:	59 f0       	breq	.+22     	; 0x71c8 <__fp_splitA+0x10>
    71b2:	5f 3f       	cpi	r21, 0xFF	; 255
    71b4:	71 f0       	breq	.+28     	; 0x71d2 <__fp_splitA+0x1a>
    71b6:	47 95       	ror	r20

000071b8 <__fp_splitA>:
    71b8:	88 0f       	add	r24, r24
    71ba:	97 fb       	bst	r25, 7
    71bc:	99 1f       	adc	r25, r25
    71be:	61 f0       	breq	.+24     	; 0x71d8 <__fp_splitA+0x20>
    71c0:	9f 3f       	cpi	r25, 0xFF	; 255
    71c2:	79 f0       	breq	.+30     	; 0x71e2 <__fp_splitA+0x2a>
    71c4:	87 95       	ror	r24
    71c6:	08 95       	ret
    71c8:	12 16       	cp	r1, r18
    71ca:	13 06       	cpc	r1, r19
    71cc:	14 06       	cpc	r1, r20
    71ce:	55 1f       	adc	r21, r21
    71d0:	f2 cf       	rjmp	.-28     	; 0x71b6 <__fp_split3+0xe>
    71d2:	46 95       	lsr	r20
    71d4:	f1 df       	rcall	.-30     	; 0x71b8 <__fp_splitA>
    71d6:	08 c0       	rjmp	.+16     	; 0x71e8 <__fp_splitA+0x30>
    71d8:	16 16       	cp	r1, r22
    71da:	17 06       	cpc	r1, r23
    71dc:	18 06       	cpc	r1, r24
    71de:	99 1f       	adc	r25, r25
    71e0:	f1 cf       	rjmp	.-30     	; 0x71c4 <__fp_splitA+0xc>
    71e2:	86 95       	lsr	r24
    71e4:	71 05       	cpc	r23, r1
    71e6:	61 05       	cpc	r22, r1
    71e8:	08 94       	sec
    71ea:	08 95       	ret

000071ec <__fp_zero>:
    71ec:	e8 94       	clt

000071ee <__fp_szero>:
    71ee:	bb 27       	eor	r27, r27
    71f0:	66 27       	eor	r22, r22
    71f2:	77 27       	eor	r23, r23
    71f4:	cb 01       	movw	r24, r22
    71f6:	97 f9       	bld	r25, 7
    71f8:	08 95       	ret

000071fa <__gesf2>:
    71fa:	03 d0       	rcall	.+6      	; 0x7202 <__fp_cmp>
    71fc:	08 f4       	brcc	.+2      	; 0x7200 <__gesf2+0x6>
    71fe:	8f ef       	ldi	r24, 0xFF	; 255
    7200:	08 95       	ret

00007202 <__fp_cmp>:
    7202:	99 0f       	add	r25, r25
    7204:	00 08       	sbc	r0, r0
    7206:	55 0f       	add	r21, r21
    7208:	aa 0b       	sbc	r26, r26
    720a:	e0 e8       	ldi	r30, 0x80	; 128
    720c:	fe ef       	ldi	r31, 0xFE	; 254
    720e:	16 16       	cp	r1, r22
    7210:	17 06       	cpc	r1, r23
    7212:	e8 07       	cpc	r30, r24
    7214:	f9 07       	cpc	r31, r25
    7216:	c0 f0       	brcs	.+48     	; 0x7248 <__fp_cmp+0x46>
    7218:	12 16       	cp	r1, r18
    721a:	13 06       	cpc	r1, r19
    721c:	e4 07       	cpc	r30, r20
    721e:	f5 07       	cpc	r31, r21
    7220:	98 f0       	brcs	.+38     	; 0x7248 <__fp_cmp+0x46>
    7222:	62 1b       	sub	r22, r18
    7224:	73 0b       	sbc	r23, r19
    7226:	84 0b       	sbc	r24, r20
    7228:	95 0b       	sbc	r25, r21
    722a:	39 f4       	brne	.+14     	; 0x723a <__fp_cmp+0x38>
    722c:	0a 26       	eor	r0, r26
    722e:	61 f0       	breq	.+24     	; 0x7248 <__fp_cmp+0x46>
    7230:	23 2b       	or	r18, r19
    7232:	24 2b       	or	r18, r20
    7234:	25 2b       	or	r18, r21
    7236:	21 f4       	brne	.+8      	; 0x7240 <__fp_cmp+0x3e>
    7238:	08 95       	ret
    723a:	0a 26       	eor	r0, r26
    723c:	09 f4       	brne	.+2      	; 0x7240 <__fp_cmp+0x3e>
    723e:	a1 40       	sbci	r26, 0x01	; 1
    7240:	a6 95       	lsr	r26
    7242:	8f ef       	ldi	r24, 0xFF	; 255
    7244:	81 1d       	adc	r24, r1
    7246:	81 1d       	adc	r24, r1
    7248:	08 95       	ret

0000724a <__mulsi3>:
    724a:	62 9f       	mul	r22, r18
    724c:	d0 01       	movw	r26, r0
    724e:	73 9f       	mul	r23, r19
    7250:	f0 01       	movw	r30, r0
    7252:	82 9f       	mul	r24, r18
    7254:	e0 0d       	add	r30, r0
    7256:	f1 1d       	adc	r31, r1
    7258:	64 9f       	mul	r22, r20
    725a:	e0 0d       	add	r30, r0
    725c:	f1 1d       	adc	r31, r1
    725e:	92 9f       	mul	r25, r18
    7260:	f0 0d       	add	r31, r0
    7262:	83 9f       	mul	r24, r19
    7264:	f0 0d       	add	r31, r0
    7266:	74 9f       	mul	r23, r20
    7268:	f0 0d       	add	r31, r0
    726a:	65 9f       	mul	r22, r21
    726c:	f0 0d       	add	r31, r0
    726e:	99 27       	eor	r25, r25
    7270:	72 9f       	mul	r23, r18
    7272:	b0 0d       	add	r27, r0
    7274:	e1 1d       	adc	r30, r1
    7276:	f9 1f       	adc	r31, r25
    7278:	63 9f       	mul	r22, r19
    727a:	b0 0d       	add	r27, r0
    727c:	e1 1d       	adc	r30, r1
    727e:	f9 1f       	adc	r31, r25
    7280:	bd 01       	movw	r22, r26
    7282:	cf 01       	movw	r24, r30
    7284:	11 24       	eor	r1, r1
    7286:	08 95       	ret

00007288 <__divmodhi4>:
    7288:	97 fb       	bst	r25, 7
    728a:	09 2e       	mov	r0, r25
    728c:	07 26       	eor	r0, r23
    728e:	0a d0       	rcall	.+20     	; 0x72a4 <__divmodhi4_neg1>
    7290:	77 fd       	sbrc	r23, 7
    7292:	04 d0       	rcall	.+8      	; 0x729c <__divmodhi4_neg2>
    7294:	49 d0       	rcall	.+146    	; 0x7328 <__udivmodhi4>
    7296:	06 d0       	rcall	.+12     	; 0x72a4 <__divmodhi4_neg1>
    7298:	00 20       	and	r0, r0
    729a:	1a f4       	brpl	.+6      	; 0x72a2 <__divmodhi4_exit>

0000729c <__divmodhi4_neg2>:
    729c:	70 95       	com	r23
    729e:	61 95       	neg	r22
    72a0:	7f 4f       	sbci	r23, 0xFF	; 255

000072a2 <__divmodhi4_exit>:
    72a2:	08 95       	ret

000072a4 <__divmodhi4_neg1>:
    72a4:	f6 f7       	brtc	.-4      	; 0x72a2 <__divmodhi4_exit>
    72a6:	90 95       	com	r25
    72a8:	81 95       	neg	r24
    72aa:	9f 4f       	sbci	r25, 0xFF	; 255
    72ac:	08 95       	ret

000072ae <__udivmodsi4>:
    72ae:	a1 e2       	ldi	r26, 0x21	; 33
    72b0:	1a 2e       	mov	r1, r26
    72b2:	aa 1b       	sub	r26, r26
    72b4:	bb 1b       	sub	r27, r27
    72b6:	fd 01       	movw	r30, r26
    72b8:	0d c0       	rjmp	.+26     	; 0x72d4 <__udivmodsi4_ep>

000072ba <__udivmodsi4_loop>:
    72ba:	aa 1f       	adc	r26, r26
    72bc:	bb 1f       	adc	r27, r27
    72be:	ee 1f       	adc	r30, r30
    72c0:	ff 1f       	adc	r31, r31
    72c2:	a2 17       	cp	r26, r18
    72c4:	b3 07       	cpc	r27, r19
    72c6:	e4 07       	cpc	r30, r20
    72c8:	f5 07       	cpc	r31, r21
    72ca:	20 f0       	brcs	.+8      	; 0x72d4 <__udivmodsi4_ep>
    72cc:	a2 1b       	sub	r26, r18
    72ce:	b3 0b       	sbc	r27, r19
    72d0:	e4 0b       	sbc	r30, r20
    72d2:	f5 0b       	sbc	r31, r21

000072d4 <__udivmodsi4_ep>:
    72d4:	66 1f       	adc	r22, r22
    72d6:	77 1f       	adc	r23, r23
    72d8:	88 1f       	adc	r24, r24
    72da:	99 1f       	adc	r25, r25
    72dc:	1a 94       	dec	r1
    72de:	69 f7       	brne	.-38     	; 0x72ba <__udivmodsi4_loop>
    72e0:	60 95       	com	r22
    72e2:	70 95       	com	r23
    72e4:	80 95       	com	r24
    72e6:	90 95       	com	r25
    72e8:	9b 01       	movw	r18, r22
    72ea:	ac 01       	movw	r20, r24
    72ec:	bd 01       	movw	r22, r26
    72ee:	cf 01       	movw	r24, r30
    72f0:	08 95       	ret

000072f2 <__divmodsi4>:
    72f2:	97 fb       	bst	r25, 7
    72f4:	09 2e       	mov	r0, r25
    72f6:	05 26       	eor	r0, r21
    72f8:	0e d0       	rcall	.+28     	; 0x7316 <__divmodsi4_neg1>
    72fa:	57 fd       	sbrc	r21, 7
    72fc:	04 d0       	rcall	.+8      	; 0x7306 <__divmodsi4_neg2>
    72fe:	d7 df       	rcall	.-82     	; 0x72ae <__udivmodsi4>
    7300:	0a d0       	rcall	.+20     	; 0x7316 <__divmodsi4_neg1>
    7302:	00 1c       	adc	r0, r0
    7304:	38 f4       	brcc	.+14     	; 0x7314 <__divmodsi4_exit>

00007306 <__divmodsi4_neg2>:
    7306:	50 95       	com	r21
    7308:	40 95       	com	r20
    730a:	30 95       	com	r19
    730c:	21 95       	neg	r18
    730e:	3f 4f       	sbci	r19, 0xFF	; 255
    7310:	4f 4f       	sbci	r20, 0xFF	; 255
    7312:	5f 4f       	sbci	r21, 0xFF	; 255

00007314 <__divmodsi4_exit>:
    7314:	08 95       	ret

00007316 <__divmodsi4_neg1>:
    7316:	f6 f7       	brtc	.-4      	; 0x7314 <__divmodsi4_exit>
    7318:	90 95       	com	r25
    731a:	80 95       	com	r24
    731c:	70 95       	com	r23
    731e:	61 95       	neg	r22
    7320:	7f 4f       	sbci	r23, 0xFF	; 255
    7322:	8f 4f       	sbci	r24, 0xFF	; 255
    7324:	9f 4f       	sbci	r25, 0xFF	; 255
    7326:	08 95       	ret

00007328 <__udivmodhi4>:
    7328:	aa 1b       	sub	r26, r26
    732a:	bb 1b       	sub	r27, r27
    732c:	51 e1       	ldi	r21, 0x11	; 17
    732e:	07 c0       	rjmp	.+14     	; 0x733e <__udivmodhi4_ep>

00007330 <__udivmodhi4_loop>:
    7330:	aa 1f       	adc	r26, r26
    7332:	bb 1f       	adc	r27, r27
    7334:	a6 17       	cp	r26, r22
    7336:	b7 07       	cpc	r27, r23
    7338:	10 f0       	brcs	.+4      	; 0x733e <__udivmodhi4_ep>
    733a:	a6 1b       	sub	r26, r22
    733c:	b7 0b       	sbc	r27, r23

0000733e <__udivmodhi4_ep>:
    733e:	88 1f       	adc	r24, r24
    7340:	99 1f       	adc	r25, r25
    7342:	5a 95       	dec	r21
    7344:	a9 f7       	brne	.-22     	; 0x7330 <__udivmodhi4_loop>
    7346:	80 95       	com	r24
    7348:	90 95       	com	r25
    734a:	bc 01       	movw	r22, r24
    734c:	cd 01       	movw	r24, r26
    734e:	08 95       	ret

00007350 <__prologue_saves__>:
    7350:	2f 92       	push	r2
    7352:	3f 92       	push	r3
    7354:	4f 92       	push	r4
    7356:	5f 92       	push	r5
    7358:	6f 92       	push	r6
    735a:	7f 92       	push	r7
    735c:	8f 92       	push	r8
    735e:	9f 92       	push	r9
    7360:	af 92       	push	r10
    7362:	bf 92       	push	r11
    7364:	cf 92       	push	r12
    7366:	df 92       	push	r13
    7368:	ef 92       	push	r14
    736a:	ff 92       	push	r15
    736c:	0f 93       	push	r16
    736e:	1f 93       	push	r17
    7370:	cf 93       	push	r28
    7372:	df 93       	push	r29
    7374:	cd b7       	in	r28, 0x3d	; 61
    7376:	de b7       	in	r29, 0x3e	; 62
    7378:	ca 1b       	sub	r28, r26
    737a:	db 0b       	sbc	r29, r27
    737c:	cd bf       	out	0x3d, r28	; 61
    737e:	de bf       	out	0x3e, r29	; 62
    7380:	19 94       	eijmp

00007382 <__epilogue_restores__>:
    7382:	2a 88       	ldd	r2, Y+18	; 0x12
    7384:	39 88       	ldd	r3, Y+17	; 0x11
    7386:	48 88       	ldd	r4, Y+16	; 0x10
    7388:	5f 84       	ldd	r5, Y+15	; 0x0f
    738a:	6e 84       	ldd	r6, Y+14	; 0x0e
    738c:	7d 84       	ldd	r7, Y+13	; 0x0d
    738e:	8c 84       	ldd	r8, Y+12	; 0x0c
    7390:	9b 84       	ldd	r9, Y+11	; 0x0b
    7392:	aa 84       	ldd	r10, Y+10	; 0x0a
    7394:	b9 84       	ldd	r11, Y+9	; 0x09
    7396:	c8 84       	ldd	r12, Y+8	; 0x08
    7398:	df 80       	ldd	r13, Y+7	; 0x07
    739a:	ee 80       	ldd	r14, Y+6	; 0x06
    739c:	fd 80       	ldd	r15, Y+5	; 0x05
    739e:	0c 81       	ldd	r16, Y+4	; 0x04
    73a0:	1b 81       	ldd	r17, Y+3	; 0x03
    73a2:	aa 81       	ldd	r26, Y+2	; 0x02
    73a4:	b9 81       	ldd	r27, Y+1	; 0x01
    73a6:	ce 0f       	add	r28, r30
    73a8:	d1 1d       	adc	r29, r1
    73aa:	cd bf       	out	0x3d, r28	; 61
    73ac:	de bf       	out	0x3e, r29	; 62
    73ae:	ed 01       	movw	r28, r26
    73b0:	08 95       	ret

000073b2 <strcpy_P>:
    73b2:	fb 01       	movw	r30, r22
    73b4:	dc 01       	movw	r26, r24
    73b6:	05 90       	lpm	r0, Z+
    73b8:	0d 92       	st	X+, r0
    73ba:	00 20       	and	r0, r0
    73bc:	e1 f7       	brne	.-8      	; 0x73b6 <strcpy_P+0x4>
    73be:	08 95       	ret

000073c0 <memmove>:
    73c0:	68 17       	cp	r22, r24
    73c2:	79 07       	cpc	r23, r25
    73c4:	68 f4       	brcc	.+26     	; 0x73e0 <memmove+0x20>
    73c6:	fb 01       	movw	r30, r22
    73c8:	dc 01       	movw	r26, r24
    73ca:	e4 0f       	add	r30, r20
    73cc:	f5 1f       	adc	r31, r21
    73ce:	a4 0f       	add	r26, r20
    73d0:	b5 1f       	adc	r27, r21
    73d2:	02 c0       	rjmp	.+4      	; 0x73d8 <memmove+0x18>
    73d4:	02 90       	ld	r0, -Z
    73d6:	0e 92       	st	-X, r0
    73d8:	41 50       	subi	r20, 0x01	; 1
    73da:	50 40       	sbci	r21, 0x00	; 0
    73dc:	d8 f7       	brcc	.-10     	; 0x73d4 <memmove+0x14>
    73de:	08 95       	ret
    73e0:	0c 94 65 3c 	jmp	0x78ca	; 0x78ca <memcpy>

000073e4 <strcat>:
    73e4:	fb 01       	movw	r30, r22
    73e6:	dc 01       	movw	r26, r24
    73e8:	0d 90       	ld	r0, X+
    73ea:	00 20       	and	r0, r0
    73ec:	e9 f7       	brne	.-6      	; 0x73e8 <strcat+0x4>
    73ee:	11 97       	sbiw	r26, 0x01	; 1
    73f0:	01 90       	ld	r0, Z+
    73f2:	0d 92       	st	X+, r0
    73f4:	00 20       	and	r0, r0
    73f6:	e1 f7       	brne	.-8      	; 0x73f0 <strcat+0xc>
    73f8:	08 95       	ret

000073fa <itoa>:
    73fa:	fb 01       	movw	r30, r22
    73fc:	9f 01       	movw	r18, r30
    73fe:	e8 94       	clt
    7400:	42 30       	cpi	r20, 0x02	; 2
    7402:	c4 f0       	brlt	.+48     	; 0x7434 <itoa+0x3a>
    7404:	45 32       	cpi	r20, 0x25	; 37
    7406:	b4 f4       	brge	.+44     	; 0x7434 <itoa+0x3a>
    7408:	4a 30       	cpi	r20, 0x0A	; 10
    740a:	29 f4       	brne	.+10     	; 0x7416 <itoa+0x1c>
    740c:	97 fb       	bst	r25, 7
    740e:	1e f4       	brtc	.+6      	; 0x7416 <itoa+0x1c>
    7410:	90 95       	com	r25
    7412:	81 95       	neg	r24
    7414:	9f 4f       	sbci	r25, 0xFF	; 255
    7416:	64 2f       	mov	r22, r20
    7418:	77 27       	eor	r23, r23
    741a:	0e 94 94 39 	call	0x7328	; 0x7328 <__udivmodhi4>
    741e:	80 5d       	subi	r24, 0xD0	; 208
    7420:	8a 33       	cpi	r24, 0x3A	; 58
    7422:	0c f0       	brlt	.+2      	; 0x7426 <itoa+0x2c>
    7424:	89 5d       	subi	r24, 0xD9	; 217
    7426:	81 93       	st	Z+, r24
    7428:	cb 01       	movw	r24, r22
    742a:	00 97       	sbiw	r24, 0x00	; 0
    742c:	a1 f7       	brne	.-24     	; 0x7416 <itoa+0x1c>
    742e:	16 f4       	brtc	.+4      	; 0x7434 <itoa+0x3a>
    7430:	5d e2       	ldi	r21, 0x2D	; 45
    7432:	51 93       	st	Z+, r21
    7434:	10 82       	st	Z, r1
    7436:	c9 01       	movw	r24, r18
    7438:	0c 94 79 3c 	jmp	0x78f2	; 0x78f2 <strrev>

0000743c <printf>:
    743c:	cf 93       	push	r28
    743e:	df 93       	push	r29
    7440:	cd b7       	in	r28, 0x3d	; 61
    7442:	de b7       	in	r29, 0x3e	; 62
    7444:	fe 01       	movw	r30, r28
    7446:	36 96       	adiw	r30, 0x06	; 6
    7448:	61 91       	ld	r22, Z+
    744a:	71 91       	ld	r23, Z+
    744c:	80 91 b3 50 	lds	r24, 0x50B3
    7450:	90 91 b4 50 	lds	r25, 0x50B4
    7454:	af 01       	movw	r20, r30
    7456:	0e 94 59 3a 	call	0x74b2	; 0x74b2 <vfprintf>
    745a:	df 91       	pop	r29
    745c:	cf 91       	pop	r28
    745e:	08 95       	ret

00007460 <sprintf>:
    7460:	0f 93       	push	r16
    7462:	1f 93       	push	r17
    7464:	cf 93       	push	r28
    7466:	df 93       	push	r29
    7468:	cd b7       	in	r28, 0x3d	; 61
    746a:	de b7       	in	r29, 0x3e	; 62
    746c:	2e 97       	sbiw	r28, 0x0e	; 14
    746e:	cd bf       	out	0x3d, r28	; 61
    7470:	de bf       	out	0x3e, r29	; 62
    7472:	0e 89       	ldd	r16, Y+22	; 0x16
    7474:	1f 89       	ldd	r17, Y+23	; 0x17
    7476:	86 e0       	ldi	r24, 0x06	; 6
    7478:	8c 83       	std	Y+4, r24	; 0x04
    747a:	09 83       	std	Y+1, r16	; 0x01
    747c:	1a 83       	std	Y+2, r17	; 0x02
    747e:	8f ef       	ldi	r24, 0xFF	; 255
    7480:	9f e7       	ldi	r25, 0x7F	; 127
    7482:	8d 83       	std	Y+5, r24	; 0x05
    7484:	9e 83       	std	Y+6, r25	; 0x06
    7486:	ae 01       	movw	r20, r28
    7488:	46 5e       	subi	r20, 0xE6	; 230
    748a:	5f 4f       	sbci	r21, 0xFF	; 255
    748c:	ce 01       	movw	r24, r28
    748e:	01 96       	adiw	r24, 0x01	; 1
    7490:	68 8d       	ldd	r22, Y+24	; 0x18
    7492:	79 8d       	ldd	r23, Y+25	; 0x19
    7494:	0e 94 59 3a 	call	0x74b2	; 0x74b2 <vfprintf>
    7498:	ef 81       	ldd	r30, Y+7	; 0x07
    749a:	f8 85       	ldd	r31, Y+8	; 0x08
    749c:	e0 0f       	add	r30, r16
    749e:	f1 1f       	adc	r31, r17
    74a0:	10 82       	st	Z, r1
    74a2:	2e 96       	adiw	r28, 0x0e	; 14
    74a4:	cd bf       	out	0x3d, r28	; 61
    74a6:	de bf       	out	0x3e, r29	; 62
    74a8:	df 91       	pop	r29
    74aa:	cf 91       	pop	r28
    74ac:	1f 91       	pop	r17
    74ae:	0f 91       	pop	r16
    74b0:	08 95       	ret

000074b2 <vfprintf>:
    74b2:	2f 92       	push	r2
    74b4:	3f 92       	push	r3
    74b6:	4f 92       	push	r4
    74b8:	5f 92       	push	r5
    74ba:	6f 92       	push	r6
    74bc:	7f 92       	push	r7
    74be:	8f 92       	push	r8
    74c0:	9f 92       	push	r9
    74c2:	af 92       	push	r10
    74c4:	bf 92       	push	r11
    74c6:	cf 92       	push	r12
    74c8:	df 92       	push	r13
    74ca:	ef 92       	push	r14
    74cc:	ff 92       	push	r15
    74ce:	0f 93       	push	r16
    74d0:	1f 93       	push	r17
    74d2:	cf 93       	push	r28
    74d4:	df 93       	push	r29
    74d6:	cd b7       	in	r28, 0x3d	; 61
    74d8:	de b7       	in	r29, 0x3e	; 62
    74da:	2d 97       	sbiw	r28, 0x0d	; 13
    74dc:	cd bf       	out	0x3d, r28	; 61
    74de:	de bf       	out	0x3e, r29	; 62
    74e0:	3c 01       	movw	r6, r24
    74e2:	6c 87       	std	Y+12, r22	; 0x0c
    74e4:	7d 87       	std	Y+13, r23	; 0x0d
    74e6:	5a 01       	movw	r10, r20
    74e8:	fc 01       	movw	r30, r24
    74ea:	16 82       	std	Z+6, r1	; 0x06
    74ec:	17 82       	std	Z+7, r1	; 0x07
    74ee:	83 81       	ldd	r24, Z+3	; 0x03
    74f0:	81 ff       	sbrs	r24, 1
    74f2:	c8 c1       	rjmp	.+912    	; 0x7884 <vfprintf+0x3d2>
    74f4:	2e 01       	movw	r4, r28
    74f6:	08 94       	sec
    74f8:	41 1c       	adc	r4, r1
    74fa:	51 1c       	adc	r5, r1
    74fc:	f3 01       	movw	r30, r6
    74fe:	93 81       	ldd	r25, Z+3	; 0x03
    7500:	ec 85       	ldd	r30, Y+12	; 0x0c
    7502:	fd 85       	ldd	r31, Y+13	; 0x0d
    7504:	93 fd       	sbrc	r25, 3
    7506:	85 91       	lpm	r24, Z+
    7508:	93 ff       	sbrs	r25, 3
    750a:	81 91       	ld	r24, Z+
    750c:	ec 87       	std	Y+12, r30	; 0x0c
    750e:	fd 87       	std	Y+13, r31	; 0x0d
    7510:	88 23       	and	r24, r24
    7512:	09 f4       	brne	.+2      	; 0x7516 <vfprintf+0x64>
    7514:	b3 c1       	rjmp	.+870    	; 0x787c <vfprintf+0x3ca>
    7516:	85 32       	cpi	r24, 0x25	; 37
    7518:	41 f4       	brne	.+16     	; 0x752a <vfprintf+0x78>
    751a:	93 fd       	sbrc	r25, 3
    751c:	85 91       	lpm	r24, Z+
    751e:	93 ff       	sbrs	r25, 3
    7520:	81 91       	ld	r24, Z+
    7522:	ec 87       	std	Y+12, r30	; 0x0c
    7524:	fd 87       	std	Y+13, r31	; 0x0d
    7526:	85 32       	cpi	r24, 0x25	; 37
    7528:	29 f4       	brne	.+10     	; 0x7534 <vfprintf+0x82>
    752a:	90 e0       	ldi	r25, 0x00	; 0
    752c:	b3 01       	movw	r22, r6
    752e:	0e 94 89 3c 	call	0x7912	; 0x7912 <fputc>
    7532:	e4 cf       	rjmp	.-56     	; 0x74fc <vfprintf+0x4a>
    7534:	ff 24       	eor	r15, r15
    7536:	ee 24       	eor	r14, r14
    7538:	10 e0       	ldi	r17, 0x00	; 0
    753a:	10 32       	cpi	r17, 0x20	; 32
    753c:	b0 f4       	brcc	.+44     	; 0x756a <vfprintf+0xb8>
    753e:	8b 32       	cpi	r24, 0x2B	; 43
    7540:	69 f0       	breq	.+26     	; 0x755c <vfprintf+0xaa>
    7542:	8c 32       	cpi	r24, 0x2C	; 44
    7544:	28 f4       	brcc	.+10     	; 0x7550 <vfprintf+0x9e>
    7546:	80 32       	cpi	r24, 0x20	; 32
    7548:	51 f0       	breq	.+20     	; 0x755e <vfprintf+0xac>
    754a:	83 32       	cpi	r24, 0x23	; 35
    754c:	71 f4       	brne	.+28     	; 0x756a <vfprintf+0xb8>
    754e:	0b c0       	rjmp	.+22     	; 0x7566 <vfprintf+0xb4>
    7550:	8d 32       	cpi	r24, 0x2D	; 45
    7552:	39 f0       	breq	.+14     	; 0x7562 <vfprintf+0xb0>
    7554:	80 33       	cpi	r24, 0x30	; 48
    7556:	49 f4       	brne	.+18     	; 0x756a <vfprintf+0xb8>
    7558:	11 60       	ori	r17, 0x01	; 1
    755a:	2c c0       	rjmp	.+88     	; 0x75b4 <vfprintf+0x102>
    755c:	12 60       	ori	r17, 0x02	; 2
    755e:	14 60       	ori	r17, 0x04	; 4
    7560:	29 c0       	rjmp	.+82     	; 0x75b4 <vfprintf+0x102>
    7562:	18 60       	ori	r17, 0x08	; 8
    7564:	27 c0       	rjmp	.+78     	; 0x75b4 <vfprintf+0x102>
    7566:	10 61       	ori	r17, 0x10	; 16
    7568:	25 c0       	rjmp	.+74     	; 0x75b4 <vfprintf+0x102>
    756a:	17 fd       	sbrc	r17, 7
    756c:	2e c0       	rjmp	.+92     	; 0x75ca <vfprintf+0x118>
    756e:	28 2f       	mov	r18, r24
    7570:	20 53       	subi	r18, 0x30	; 48
    7572:	2a 30       	cpi	r18, 0x0A	; 10
    7574:	98 f4       	brcc	.+38     	; 0x759c <vfprintf+0xea>
    7576:	16 ff       	sbrs	r17, 6
    7578:	08 c0       	rjmp	.+16     	; 0x758a <vfprintf+0xd8>
    757a:	8f 2d       	mov	r24, r15
    757c:	88 0f       	add	r24, r24
    757e:	f8 2e       	mov	r15, r24
    7580:	ff 0c       	add	r15, r15
    7582:	ff 0c       	add	r15, r15
    7584:	f8 0e       	add	r15, r24
    7586:	f2 0e       	add	r15, r18
    7588:	15 c0       	rjmp	.+42     	; 0x75b4 <vfprintf+0x102>
    758a:	8e 2d       	mov	r24, r14
    758c:	88 0f       	add	r24, r24
    758e:	e8 2e       	mov	r14, r24
    7590:	ee 0c       	add	r14, r14
    7592:	ee 0c       	add	r14, r14
    7594:	e8 0e       	add	r14, r24
    7596:	e2 0e       	add	r14, r18
    7598:	10 62       	ori	r17, 0x20	; 32
    759a:	0c c0       	rjmp	.+24     	; 0x75b4 <vfprintf+0x102>
    759c:	8e 32       	cpi	r24, 0x2E	; 46
    759e:	21 f4       	brne	.+8      	; 0x75a8 <vfprintf+0xf6>
    75a0:	16 fd       	sbrc	r17, 6
    75a2:	6c c1       	rjmp	.+728    	; 0x787c <vfprintf+0x3ca>
    75a4:	10 64       	ori	r17, 0x40	; 64
    75a6:	06 c0       	rjmp	.+12     	; 0x75b4 <vfprintf+0x102>
    75a8:	8c 36       	cpi	r24, 0x6C	; 108
    75aa:	11 f4       	brne	.+4      	; 0x75b0 <vfprintf+0xfe>
    75ac:	10 68       	ori	r17, 0x80	; 128
    75ae:	02 c0       	rjmp	.+4      	; 0x75b4 <vfprintf+0x102>
    75b0:	88 36       	cpi	r24, 0x68	; 104
    75b2:	59 f4       	brne	.+22     	; 0x75ca <vfprintf+0x118>
    75b4:	ec 85       	ldd	r30, Y+12	; 0x0c
    75b6:	fd 85       	ldd	r31, Y+13	; 0x0d
    75b8:	93 fd       	sbrc	r25, 3
    75ba:	85 91       	lpm	r24, Z+
    75bc:	93 ff       	sbrs	r25, 3
    75be:	81 91       	ld	r24, Z+
    75c0:	ec 87       	std	Y+12, r30	; 0x0c
    75c2:	fd 87       	std	Y+13, r31	; 0x0d
    75c4:	88 23       	and	r24, r24
    75c6:	09 f0       	breq	.+2      	; 0x75ca <vfprintf+0x118>
    75c8:	b8 cf       	rjmp	.-144    	; 0x753a <vfprintf+0x88>
    75ca:	98 2f       	mov	r25, r24
    75cc:	95 54       	subi	r25, 0x45	; 69
    75ce:	93 30       	cpi	r25, 0x03	; 3
    75d0:	18 f0       	brcs	.+6      	; 0x75d8 <vfprintf+0x126>
    75d2:	90 52       	subi	r25, 0x20	; 32
    75d4:	93 30       	cpi	r25, 0x03	; 3
    75d6:	38 f4       	brcc	.+14     	; 0x75e6 <vfprintf+0x134>
    75d8:	24 e0       	ldi	r18, 0x04	; 4
    75da:	30 e0       	ldi	r19, 0x00	; 0
    75dc:	a2 0e       	add	r10, r18
    75de:	b3 1e       	adc	r11, r19
    75e0:	3f e3       	ldi	r19, 0x3F	; 63
    75e2:	39 83       	std	Y+1, r19	; 0x01
    75e4:	0f c0       	rjmp	.+30     	; 0x7604 <vfprintf+0x152>
    75e6:	83 36       	cpi	r24, 0x63	; 99
    75e8:	31 f0       	breq	.+12     	; 0x75f6 <vfprintf+0x144>
    75ea:	83 37       	cpi	r24, 0x73	; 115
    75ec:	81 f0       	breq	.+32     	; 0x760e <vfprintf+0x15c>
    75ee:	83 35       	cpi	r24, 0x53	; 83
    75f0:	09 f0       	breq	.+2      	; 0x75f4 <vfprintf+0x142>
    75f2:	5a c0       	rjmp	.+180    	; 0x76a8 <vfprintf+0x1f6>
    75f4:	22 c0       	rjmp	.+68     	; 0x763a <vfprintf+0x188>
    75f6:	f5 01       	movw	r30, r10
    75f8:	80 81       	ld	r24, Z
    75fa:	89 83       	std	Y+1, r24	; 0x01
    75fc:	22 e0       	ldi	r18, 0x02	; 2
    75fe:	30 e0       	ldi	r19, 0x00	; 0
    7600:	a2 0e       	add	r10, r18
    7602:	b3 1e       	adc	r11, r19
    7604:	21 e0       	ldi	r18, 0x01	; 1
    7606:	c2 2e       	mov	r12, r18
    7608:	d1 2c       	mov	r13, r1
    760a:	42 01       	movw	r8, r4
    760c:	14 c0       	rjmp	.+40     	; 0x7636 <vfprintf+0x184>
    760e:	92 e0       	ldi	r25, 0x02	; 2
    7610:	29 2e       	mov	r2, r25
    7612:	31 2c       	mov	r3, r1
    7614:	2a 0c       	add	r2, r10
    7616:	3b 1c       	adc	r3, r11
    7618:	f5 01       	movw	r30, r10
    761a:	80 80       	ld	r8, Z
    761c:	91 80       	ldd	r9, Z+1	; 0x01
    761e:	16 ff       	sbrs	r17, 6
    7620:	03 c0       	rjmp	.+6      	; 0x7628 <vfprintf+0x176>
    7622:	6f 2d       	mov	r22, r15
    7624:	70 e0       	ldi	r23, 0x00	; 0
    7626:	02 c0       	rjmp	.+4      	; 0x762c <vfprintf+0x17a>
    7628:	6f ef       	ldi	r22, 0xFF	; 255
    762a:	7f ef       	ldi	r23, 0xFF	; 255
    762c:	c4 01       	movw	r24, r8
    762e:	0e 94 6e 3c 	call	0x78dc	; 0x78dc <strnlen>
    7632:	6c 01       	movw	r12, r24
    7634:	51 01       	movw	r10, r2
    7636:	1f 77       	andi	r17, 0x7F	; 127
    7638:	15 c0       	rjmp	.+42     	; 0x7664 <vfprintf+0x1b2>
    763a:	82 e0       	ldi	r24, 0x02	; 2
    763c:	28 2e       	mov	r2, r24
    763e:	31 2c       	mov	r3, r1
    7640:	2a 0c       	add	r2, r10
    7642:	3b 1c       	adc	r3, r11
    7644:	f5 01       	movw	r30, r10
    7646:	80 80       	ld	r8, Z
    7648:	91 80       	ldd	r9, Z+1	; 0x01
    764a:	16 ff       	sbrs	r17, 6
    764c:	03 c0       	rjmp	.+6      	; 0x7654 <vfprintf+0x1a2>
    764e:	6f 2d       	mov	r22, r15
    7650:	70 e0       	ldi	r23, 0x00	; 0
    7652:	02 c0       	rjmp	.+4      	; 0x7658 <vfprintf+0x1a6>
    7654:	6f ef       	ldi	r22, 0xFF	; 255
    7656:	7f ef       	ldi	r23, 0xFF	; 255
    7658:	c4 01       	movw	r24, r8
    765a:	0e 94 5a 3c 	call	0x78b4	; 0x78b4 <strnlen_P>
    765e:	6c 01       	movw	r12, r24
    7660:	10 68       	ori	r17, 0x80	; 128
    7662:	51 01       	movw	r10, r2
    7664:	13 fd       	sbrc	r17, 3
    7666:	1c c0       	rjmp	.+56     	; 0x76a0 <vfprintf+0x1ee>
    7668:	06 c0       	rjmp	.+12     	; 0x7676 <vfprintf+0x1c4>
    766a:	80 e2       	ldi	r24, 0x20	; 32
    766c:	90 e0       	ldi	r25, 0x00	; 0
    766e:	b3 01       	movw	r22, r6
    7670:	0e 94 89 3c 	call	0x7912	; 0x7912 <fputc>
    7674:	ea 94       	dec	r14
    7676:	8e 2d       	mov	r24, r14
    7678:	90 e0       	ldi	r25, 0x00	; 0
    767a:	c8 16       	cp	r12, r24
    767c:	d9 06       	cpc	r13, r25
    767e:	a8 f3       	brcs	.-22     	; 0x766a <vfprintf+0x1b8>
    7680:	0f c0       	rjmp	.+30     	; 0x76a0 <vfprintf+0x1ee>
    7682:	f4 01       	movw	r30, r8
    7684:	17 fd       	sbrc	r17, 7
    7686:	85 91       	lpm	r24, Z+
    7688:	17 ff       	sbrs	r17, 7
    768a:	81 91       	ld	r24, Z+
    768c:	4f 01       	movw	r8, r30
    768e:	90 e0       	ldi	r25, 0x00	; 0
    7690:	b3 01       	movw	r22, r6
    7692:	0e 94 89 3c 	call	0x7912	; 0x7912 <fputc>
    7696:	e1 10       	cpse	r14, r1
    7698:	ea 94       	dec	r14
    769a:	08 94       	sec
    769c:	c1 08       	sbc	r12, r1
    769e:	d1 08       	sbc	r13, r1
    76a0:	c1 14       	cp	r12, r1
    76a2:	d1 04       	cpc	r13, r1
    76a4:	71 f7       	brne	.-36     	; 0x7682 <vfprintf+0x1d0>
    76a6:	e7 c0       	rjmp	.+462    	; 0x7876 <vfprintf+0x3c4>
    76a8:	84 36       	cpi	r24, 0x64	; 100
    76aa:	11 f0       	breq	.+4      	; 0x76b0 <vfprintf+0x1fe>
    76ac:	89 36       	cpi	r24, 0x69	; 105
    76ae:	51 f5       	brne	.+84     	; 0x7704 <vfprintf+0x252>
    76b0:	f5 01       	movw	r30, r10
    76b2:	17 ff       	sbrs	r17, 7
    76b4:	07 c0       	rjmp	.+14     	; 0x76c4 <vfprintf+0x212>
    76b6:	80 81       	ld	r24, Z
    76b8:	91 81       	ldd	r25, Z+1	; 0x01
    76ba:	a2 81       	ldd	r26, Z+2	; 0x02
    76bc:	b3 81       	ldd	r27, Z+3	; 0x03
    76be:	24 e0       	ldi	r18, 0x04	; 4
    76c0:	30 e0       	ldi	r19, 0x00	; 0
    76c2:	08 c0       	rjmp	.+16     	; 0x76d4 <vfprintf+0x222>
    76c4:	80 81       	ld	r24, Z
    76c6:	91 81       	ldd	r25, Z+1	; 0x01
    76c8:	aa 27       	eor	r26, r26
    76ca:	97 fd       	sbrc	r25, 7
    76cc:	a0 95       	com	r26
    76ce:	ba 2f       	mov	r27, r26
    76d0:	22 e0       	ldi	r18, 0x02	; 2
    76d2:	30 e0       	ldi	r19, 0x00	; 0
    76d4:	a2 0e       	add	r10, r18
    76d6:	b3 1e       	adc	r11, r19
    76d8:	01 2f       	mov	r16, r17
    76da:	0f 76       	andi	r16, 0x6F	; 111
    76dc:	b7 ff       	sbrs	r27, 7
    76de:	08 c0       	rjmp	.+16     	; 0x76f0 <vfprintf+0x23e>
    76e0:	b0 95       	com	r27
    76e2:	a0 95       	com	r26
    76e4:	90 95       	com	r25
    76e6:	81 95       	neg	r24
    76e8:	9f 4f       	sbci	r25, 0xFF	; 255
    76ea:	af 4f       	sbci	r26, 0xFF	; 255
    76ec:	bf 4f       	sbci	r27, 0xFF	; 255
    76ee:	00 68       	ori	r16, 0x80	; 128
    76f0:	bc 01       	movw	r22, r24
    76f2:	cd 01       	movw	r24, r26
    76f4:	a2 01       	movw	r20, r4
    76f6:	2a e0       	ldi	r18, 0x0A	; 10
    76f8:	30 e0       	ldi	r19, 0x00	; 0
    76fa:	0e 94 b5 3c 	call	0x796a	; 0x796a <__ultoa_invert>
    76fe:	d8 2e       	mov	r13, r24
    7700:	d4 18       	sub	r13, r4
    7702:	3f c0       	rjmp	.+126    	; 0x7782 <vfprintf+0x2d0>
    7704:	85 37       	cpi	r24, 0x75	; 117
    7706:	21 f4       	brne	.+8      	; 0x7710 <vfprintf+0x25e>
    7708:	1f 7e       	andi	r17, 0xEF	; 239
    770a:	2a e0       	ldi	r18, 0x0A	; 10
    770c:	30 e0       	ldi	r19, 0x00	; 0
    770e:	20 c0       	rjmp	.+64     	; 0x7750 <vfprintf+0x29e>
    7710:	19 7f       	andi	r17, 0xF9	; 249
    7712:	8f 36       	cpi	r24, 0x6F	; 111
    7714:	a9 f0       	breq	.+42     	; 0x7740 <vfprintf+0x28e>
    7716:	80 37       	cpi	r24, 0x70	; 112
    7718:	20 f4       	brcc	.+8      	; 0x7722 <vfprintf+0x270>
    771a:	88 35       	cpi	r24, 0x58	; 88
    771c:	09 f0       	breq	.+2      	; 0x7720 <vfprintf+0x26e>
    771e:	ae c0       	rjmp	.+348    	; 0x787c <vfprintf+0x3ca>
    7720:	0b c0       	rjmp	.+22     	; 0x7738 <vfprintf+0x286>
    7722:	80 37       	cpi	r24, 0x70	; 112
    7724:	21 f0       	breq	.+8      	; 0x772e <vfprintf+0x27c>
    7726:	88 37       	cpi	r24, 0x78	; 120
    7728:	09 f0       	breq	.+2      	; 0x772c <vfprintf+0x27a>
    772a:	a8 c0       	rjmp	.+336    	; 0x787c <vfprintf+0x3ca>
    772c:	01 c0       	rjmp	.+2      	; 0x7730 <vfprintf+0x27e>
    772e:	10 61       	ori	r17, 0x10	; 16
    7730:	14 ff       	sbrs	r17, 4
    7732:	09 c0       	rjmp	.+18     	; 0x7746 <vfprintf+0x294>
    7734:	14 60       	ori	r17, 0x04	; 4
    7736:	07 c0       	rjmp	.+14     	; 0x7746 <vfprintf+0x294>
    7738:	14 ff       	sbrs	r17, 4
    773a:	08 c0       	rjmp	.+16     	; 0x774c <vfprintf+0x29a>
    773c:	16 60       	ori	r17, 0x06	; 6
    773e:	06 c0       	rjmp	.+12     	; 0x774c <vfprintf+0x29a>
    7740:	28 e0       	ldi	r18, 0x08	; 8
    7742:	30 e0       	ldi	r19, 0x00	; 0
    7744:	05 c0       	rjmp	.+10     	; 0x7750 <vfprintf+0x29e>
    7746:	20 e1       	ldi	r18, 0x10	; 16
    7748:	30 e0       	ldi	r19, 0x00	; 0
    774a:	02 c0       	rjmp	.+4      	; 0x7750 <vfprintf+0x29e>
    774c:	20 e1       	ldi	r18, 0x10	; 16
    774e:	32 e0       	ldi	r19, 0x02	; 2
    7750:	f5 01       	movw	r30, r10
    7752:	17 ff       	sbrs	r17, 7
    7754:	07 c0       	rjmp	.+14     	; 0x7764 <vfprintf+0x2b2>
    7756:	60 81       	ld	r22, Z
    7758:	71 81       	ldd	r23, Z+1	; 0x01
    775a:	82 81       	ldd	r24, Z+2	; 0x02
    775c:	93 81       	ldd	r25, Z+3	; 0x03
    775e:	44 e0       	ldi	r20, 0x04	; 4
    7760:	50 e0       	ldi	r21, 0x00	; 0
    7762:	06 c0       	rjmp	.+12     	; 0x7770 <vfprintf+0x2be>
    7764:	60 81       	ld	r22, Z
    7766:	71 81       	ldd	r23, Z+1	; 0x01
    7768:	80 e0       	ldi	r24, 0x00	; 0
    776a:	90 e0       	ldi	r25, 0x00	; 0
    776c:	42 e0       	ldi	r20, 0x02	; 2
    776e:	50 e0       	ldi	r21, 0x00	; 0
    7770:	a4 0e       	add	r10, r20
    7772:	b5 1e       	adc	r11, r21
    7774:	a2 01       	movw	r20, r4
    7776:	0e 94 b5 3c 	call	0x796a	; 0x796a <__ultoa_invert>
    777a:	d8 2e       	mov	r13, r24
    777c:	d4 18       	sub	r13, r4
    777e:	01 2f       	mov	r16, r17
    7780:	0f 77       	andi	r16, 0x7F	; 127
    7782:	06 ff       	sbrs	r16, 6
    7784:	09 c0       	rjmp	.+18     	; 0x7798 <vfprintf+0x2e6>
    7786:	0e 7f       	andi	r16, 0xFE	; 254
    7788:	df 14       	cp	r13, r15
    778a:	30 f4       	brcc	.+12     	; 0x7798 <vfprintf+0x2e6>
    778c:	04 ff       	sbrs	r16, 4
    778e:	06 c0       	rjmp	.+12     	; 0x779c <vfprintf+0x2ea>
    7790:	02 fd       	sbrc	r16, 2
    7792:	04 c0       	rjmp	.+8      	; 0x779c <vfprintf+0x2ea>
    7794:	0f 7e       	andi	r16, 0xEF	; 239
    7796:	02 c0       	rjmp	.+4      	; 0x779c <vfprintf+0x2ea>
    7798:	1d 2d       	mov	r17, r13
    779a:	01 c0       	rjmp	.+2      	; 0x779e <vfprintf+0x2ec>
    779c:	1f 2d       	mov	r17, r15
    779e:	80 2f       	mov	r24, r16
    77a0:	90 e0       	ldi	r25, 0x00	; 0
    77a2:	04 ff       	sbrs	r16, 4
    77a4:	0c c0       	rjmp	.+24     	; 0x77be <vfprintf+0x30c>
    77a6:	fe 01       	movw	r30, r28
    77a8:	ed 0d       	add	r30, r13
    77aa:	f1 1d       	adc	r31, r1
    77ac:	20 81       	ld	r18, Z
    77ae:	20 33       	cpi	r18, 0x30	; 48
    77b0:	11 f4       	brne	.+4      	; 0x77b6 <vfprintf+0x304>
    77b2:	09 7e       	andi	r16, 0xE9	; 233
    77b4:	09 c0       	rjmp	.+18     	; 0x77c8 <vfprintf+0x316>
    77b6:	02 ff       	sbrs	r16, 2
    77b8:	06 c0       	rjmp	.+12     	; 0x77c6 <vfprintf+0x314>
    77ba:	1e 5f       	subi	r17, 0xFE	; 254
    77bc:	05 c0       	rjmp	.+10     	; 0x77c8 <vfprintf+0x316>
    77be:	86 78       	andi	r24, 0x86	; 134
    77c0:	90 70       	andi	r25, 0x00	; 0
    77c2:	00 97       	sbiw	r24, 0x00	; 0
    77c4:	09 f0       	breq	.+2      	; 0x77c8 <vfprintf+0x316>
    77c6:	1f 5f       	subi	r17, 0xFF	; 255
    77c8:	80 2e       	mov	r8, r16
    77ca:	99 24       	eor	r9, r9
    77cc:	03 fd       	sbrc	r16, 3
    77ce:	12 c0       	rjmp	.+36     	; 0x77f4 <vfprintf+0x342>
    77d0:	00 ff       	sbrs	r16, 0
    77d2:	0d c0       	rjmp	.+26     	; 0x77ee <vfprintf+0x33c>
    77d4:	fd 2c       	mov	r15, r13
    77d6:	1e 15       	cp	r17, r14
    77d8:	50 f4       	brcc	.+20     	; 0x77ee <vfprintf+0x33c>
    77da:	fe 0c       	add	r15, r14
    77dc:	f1 1a       	sub	r15, r17
    77de:	1e 2d       	mov	r17, r14
    77e0:	06 c0       	rjmp	.+12     	; 0x77ee <vfprintf+0x33c>
    77e2:	80 e2       	ldi	r24, 0x20	; 32
    77e4:	90 e0       	ldi	r25, 0x00	; 0
    77e6:	b3 01       	movw	r22, r6
    77e8:	0e 94 89 3c 	call	0x7912	; 0x7912 <fputc>
    77ec:	1f 5f       	subi	r17, 0xFF	; 255
    77ee:	1e 15       	cp	r17, r14
    77f0:	c0 f3       	brcs	.-16     	; 0x77e2 <vfprintf+0x330>
    77f2:	04 c0       	rjmp	.+8      	; 0x77fc <vfprintf+0x34a>
    77f4:	1e 15       	cp	r17, r14
    77f6:	10 f4       	brcc	.+4      	; 0x77fc <vfprintf+0x34a>
    77f8:	e1 1a       	sub	r14, r17
    77fa:	01 c0       	rjmp	.+2      	; 0x77fe <vfprintf+0x34c>
    77fc:	ee 24       	eor	r14, r14
    77fe:	84 fe       	sbrs	r8, 4
    7800:	0f c0       	rjmp	.+30     	; 0x7820 <vfprintf+0x36e>
    7802:	80 e3       	ldi	r24, 0x30	; 48
    7804:	90 e0       	ldi	r25, 0x00	; 0
    7806:	b3 01       	movw	r22, r6
    7808:	0e 94 89 3c 	call	0x7912	; 0x7912 <fputc>
    780c:	82 fe       	sbrs	r8, 2
    780e:	1f c0       	rjmp	.+62     	; 0x784e <vfprintf+0x39c>
    7810:	81 fe       	sbrs	r8, 1
    7812:	03 c0       	rjmp	.+6      	; 0x781a <vfprintf+0x368>
    7814:	88 e5       	ldi	r24, 0x58	; 88
    7816:	90 e0       	ldi	r25, 0x00	; 0
    7818:	10 c0       	rjmp	.+32     	; 0x783a <vfprintf+0x388>
    781a:	88 e7       	ldi	r24, 0x78	; 120
    781c:	90 e0       	ldi	r25, 0x00	; 0
    781e:	0d c0       	rjmp	.+26     	; 0x783a <vfprintf+0x388>
    7820:	c4 01       	movw	r24, r8
    7822:	86 78       	andi	r24, 0x86	; 134
    7824:	90 70       	andi	r25, 0x00	; 0
    7826:	00 97       	sbiw	r24, 0x00	; 0
    7828:	91 f0       	breq	.+36     	; 0x784e <vfprintf+0x39c>
    782a:	81 fc       	sbrc	r8, 1
    782c:	02 c0       	rjmp	.+4      	; 0x7832 <vfprintf+0x380>
    782e:	80 e2       	ldi	r24, 0x20	; 32
    7830:	01 c0       	rjmp	.+2      	; 0x7834 <vfprintf+0x382>
    7832:	8b e2       	ldi	r24, 0x2B	; 43
    7834:	07 fd       	sbrc	r16, 7
    7836:	8d e2       	ldi	r24, 0x2D	; 45
    7838:	90 e0       	ldi	r25, 0x00	; 0
    783a:	b3 01       	movw	r22, r6
    783c:	0e 94 89 3c 	call	0x7912	; 0x7912 <fputc>
    7840:	06 c0       	rjmp	.+12     	; 0x784e <vfprintf+0x39c>
    7842:	80 e3       	ldi	r24, 0x30	; 48
    7844:	90 e0       	ldi	r25, 0x00	; 0
    7846:	b3 01       	movw	r22, r6
    7848:	0e 94 89 3c 	call	0x7912	; 0x7912 <fputc>
    784c:	fa 94       	dec	r15
    784e:	df 14       	cp	r13, r15
    7850:	c0 f3       	brcs	.-16     	; 0x7842 <vfprintf+0x390>
    7852:	da 94       	dec	r13
    7854:	f2 01       	movw	r30, r4
    7856:	ed 0d       	add	r30, r13
    7858:	f1 1d       	adc	r31, r1
    785a:	80 81       	ld	r24, Z
    785c:	90 e0       	ldi	r25, 0x00	; 0
    785e:	b3 01       	movw	r22, r6
    7860:	0e 94 89 3c 	call	0x7912	; 0x7912 <fputc>
    7864:	dd 20       	and	r13, r13
    7866:	a9 f7       	brne	.-22     	; 0x7852 <vfprintf+0x3a0>
    7868:	06 c0       	rjmp	.+12     	; 0x7876 <vfprintf+0x3c4>
    786a:	80 e2       	ldi	r24, 0x20	; 32
    786c:	90 e0       	ldi	r25, 0x00	; 0
    786e:	b3 01       	movw	r22, r6
    7870:	0e 94 89 3c 	call	0x7912	; 0x7912 <fputc>
    7874:	ea 94       	dec	r14
    7876:	ee 20       	and	r14, r14
    7878:	c1 f7       	brne	.-16     	; 0x786a <vfprintf+0x3b8>
    787a:	40 ce       	rjmp	.-896    	; 0x74fc <vfprintf+0x4a>
    787c:	f3 01       	movw	r30, r6
    787e:	86 81       	ldd	r24, Z+6	; 0x06
    7880:	97 81       	ldd	r25, Z+7	; 0x07
    7882:	02 c0       	rjmp	.+4      	; 0x7888 <vfprintf+0x3d6>
    7884:	8f ef       	ldi	r24, 0xFF	; 255
    7886:	9f ef       	ldi	r25, 0xFF	; 255
    7888:	2d 96       	adiw	r28, 0x0d	; 13
    788a:	cd bf       	out	0x3d, r28	; 61
    788c:	de bf       	out	0x3e, r29	; 62
    788e:	df 91       	pop	r29
    7890:	cf 91       	pop	r28
    7892:	1f 91       	pop	r17
    7894:	0f 91       	pop	r16
    7896:	ff 90       	pop	r15
    7898:	ef 90       	pop	r14
    789a:	df 90       	pop	r13
    789c:	cf 90       	pop	r12
    789e:	bf 90       	pop	r11
    78a0:	af 90       	pop	r10
    78a2:	9f 90       	pop	r9
    78a4:	8f 90       	pop	r8
    78a6:	7f 90       	pop	r7
    78a8:	6f 90       	pop	r6
    78aa:	5f 90       	pop	r5
    78ac:	4f 90       	pop	r4
    78ae:	3f 90       	pop	r3
    78b0:	2f 90       	pop	r2
    78b2:	08 95       	ret

000078b4 <strnlen_P>:
    78b4:	fc 01       	movw	r30, r24
    78b6:	05 90       	lpm	r0, Z+
    78b8:	61 50       	subi	r22, 0x01	; 1
    78ba:	70 40       	sbci	r23, 0x00	; 0
    78bc:	01 10       	cpse	r0, r1
    78be:	d8 f7       	brcc	.-10     	; 0x78b6 <strnlen_P+0x2>
    78c0:	80 95       	com	r24
    78c2:	90 95       	com	r25
    78c4:	8e 0f       	add	r24, r30
    78c6:	9f 1f       	adc	r25, r31
    78c8:	08 95       	ret

000078ca <memcpy>:
    78ca:	fb 01       	movw	r30, r22
    78cc:	dc 01       	movw	r26, r24
    78ce:	02 c0       	rjmp	.+4      	; 0x78d4 <memcpy+0xa>
    78d0:	01 90       	ld	r0, Z+
    78d2:	0d 92       	st	X+, r0
    78d4:	41 50       	subi	r20, 0x01	; 1
    78d6:	50 40       	sbci	r21, 0x00	; 0
    78d8:	d8 f7       	brcc	.-10     	; 0x78d0 <memcpy+0x6>
    78da:	08 95       	ret

000078dc <strnlen>:
    78dc:	fc 01       	movw	r30, r24
    78de:	61 50       	subi	r22, 0x01	; 1
    78e0:	70 40       	sbci	r23, 0x00	; 0
    78e2:	01 90       	ld	r0, Z+
    78e4:	01 10       	cpse	r0, r1
    78e6:	d8 f7       	brcc	.-10     	; 0x78de <strnlen+0x2>
    78e8:	80 95       	com	r24
    78ea:	90 95       	com	r25
    78ec:	8e 0f       	add	r24, r30
    78ee:	9f 1f       	adc	r25, r31
    78f0:	08 95       	ret

000078f2 <strrev>:
    78f2:	dc 01       	movw	r26, r24
    78f4:	fc 01       	movw	r30, r24
    78f6:	67 2f       	mov	r22, r23
    78f8:	71 91       	ld	r23, Z+
    78fa:	77 23       	and	r23, r23
    78fc:	e1 f7       	brne	.-8      	; 0x78f6 <strrev+0x4>
    78fe:	32 97       	sbiw	r30, 0x02	; 2
    7900:	04 c0       	rjmp	.+8      	; 0x790a <strrev+0x18>
    7902:	7c 91       	ld	r23, X
    7904:	6d 93       	st	X+, r22
    7906:	70 83       	st	Z, r23
    7908:	62 91       	ld	r22, -Z
    790a:	ae 17       	cp	r26, r30
    790c:	bf 07       	cpc	r27, r31
    790e:	c8 f3       	brcs	.-14     	; 0x7902 <strrev+0x10>
    7910:	08 95       	ret

00007912 <fputc>:
    7912:	0f 93       	push	r16
    7914:	1f 93       	push	r17
    7916:	cf 93       	push	r28
    7918:	df 93       	push	r29
    791a:	8c 01       	movw	r16, r24
    791c:	eb 01       	movw	r28, r22
    791e:	8b 81       	ldd	r24, Y+3	; 0x03
    7920:	81 ff       	sbrs	r24, 1
    7922:	1b c0       	rjmp	.+54     	; 0x795a <fputc+0x48>
    7924:	82 ff       	sbrs	r24, 2
    7926:	0d c0       	rjmp	.+26     	; 0x7942 <fputc+0x30>
    7928:	2e 81       	ldd	r18, Y+6	; 0x06
    792a:	3f 81       	ldd	r19, Y+7	; 0x07
    792c:	8c 81       	ldd	r24, Y+4	; 0x04
    792e:	9d 81       	ldd	r25, Y+5	; 0x05
    7930:	28 17       	cp	r18, r24
    7932:	39 07       	cpc	r19, r25
    7934:	64 f4       	brge	.+24     	; 0x794e <fputc+0x3c>
    7936:	e8 81       	ld	r30, Y
    7938:	f9 81       	ldd	r31, Y+1	; 0x01
    793a:	01 93       	st	Z+, r16
    793c:	e8 83       	st	Y, r30
    793e:	f9 83       	std	Y+1, r31	; 0x01
    7940:	06 c0       	rjmp	.+12     	; 0x794e <fputc+0x3c>
    7942:	e8 85       	ldd	r30, Y+8	; 0x08
    7944:	f9 85       	ldd	r31, Y+9	; 0x09
    7946:	80 2f       	mov	r24, r16
    7948:	19 95       	eicall
    794a:	00 97       	sbiw	r24, 0x00	; 0
    794c:	31 f4       	brne	.+12     	; 0x795a <fputc+0x48>
    794e:	8e 81       	ldd	r24, Y+6	; 0x06
    7950:	9f 81       	ldd	r25, Y+7	; 0x07
    7952:	01 96       	adiw	r24, 0x01	; 1
    7954:	8e 83       	std	Y+6, r24	; 0x06
    7956:	9f 83       	std	Y+7, r25	; 0x07
    7958:	02 c0       	rjmp	.+4      	; 0x795e <fputc+0x4c>
    795a:	0f ef       	ldi	r16, 0xFF	; 255
    795c:	1f ef       	ldi	r17, 0xFF	; 255
    795e:	c8 01       	movw	r24, r16
    7960:	df 91       	pop	r29
    7962:	cf 91       	pop	r28
    7964:	1f 91       	pop	r17
    7966:	0f 91       	pop	r16
    7968:	08 95       	ret

0000796a <__ultoa_invert>:
    796a:	fa 01       	movw	r30, r20
    796c:	aa 27       	eor	r26, r26
    796e:	28 30       	cpi	r18, 0x08	; 8
    7970:	51 f1       	breq	.+84     	; 0x79c6 <__ultoa_invert+0x5c>
    7972:	20 31       	cpi	r18, 0x10	; 16
    7974:	81 f1       	breq	.+96     	; 0x79d6 <__ultoa_invert+0x6c>
    7976:	e8 94       	clt
    7978:	6f 93       	push	r22
    797a:	6e 7f       	andi	r22, 0xFE	; 254
    797c:	6e 5f       	subi	r22, 0xFE	; 254
    797e:	7f 4f       	sbci	r23, 0xFF	; 255
    7980:	8f 4f       	sbci	r24, 0xFF	; 255
    7982:	9f 4f       	sbci	r25, 0xFF	; 255
    7984:	af 4f       	sbci	r26, 0xFF	; 255
    7986:	b1 e0       	ldi	r27, 0x01	; 1
    7988:	3e d0       	rcall	.+124    	; 0x7a06 <__ultoa_invert+0x9c>
    798a:	b4 e0       	ldi	r27, 0x04	; 4
    798c:	3c d0       	rcall	.+120    	; 0x7a06 <__ultoa_invert+0x9c>
    798e:	67 0f       	add	r22, r23
    7990:	78 1f       	adc	r23, r24
    7992:	89 1f       	adc	r24, r25
    7994:	9a 1f       	adc	r25, r26
    7996:	a1 1d       	adc	r26, r1
    7998:	68 0f       	add	r22, r24
    799a:	79 1f       	adc	r23, r25
    799c:	8a 1f       	adc	r24, r26
    799e:	91 1d       	adc	r25, r1
    79a0:	a1 1d       	adc	r26, r1
    79a2:	6a 0f       	add	r22, r26
    79a4:	71 1d       	adc	r23, r1
    79a6:	81 1d       	adc	r24, r1
    79a8:	91 1d       	adc	r25, r1
    79aa:	a1 1d       	adc	r26, r1
    79ac:	20 d0       	rcall	.+64     	; 0x79ee <__ultoa_invert+0x84>
    79ae:	09 f4       	brne	.+2      	; 0x79b2 <__ultoa_invert+0x48>
    79b0:	68 94       	set
    79b2:	3f 91       	pop	r19
    79b4:	2a e0       	ldi	r18, 0x0A	; 10
    79b6:	26 9f       	mul	r18, r22
    79b8:	11 24       	eor	r1, r1
    79ba:	30 19       	sub	r19, r0
    79bc:	30 5d       	subi	r19, 0xD0	; 208
    79be:	31 93       	st	Z+, r19
    79c0:	de f6       	brtc	.-74     	; 0x7978 <__ultoa_invert+0xe>
    79c2:	cf 01       	movw	r24, r30
    79c4:	08 95       	ret
    79c6:	46 2f       	mov	r20, r22
    79c8:	47 70       	andi	r20, 0x07	; 7
    79ca:	40 5d       	subi	r20, 0xD0	; 208
    79cc:	41 93       	st	Z+, r20
    79ce:	b3 e0       	ldi	r27, 0x03	; 3
    79d0:	0f d0       	rcall	.+30     	; 0x79f0 <__ultoa_invert+0x86>
    79d2:	c9 f7       	brne	.-14     	; 0x79c6 <__ultoa_invert+0x5c>
    79d4:	f6 cf       	rjmp	.-20     	; 0x79c2 <__ultoa_invert+0x58>
    79d6:	46 2f       	mov	r20, r22
    79d8:	4f 70       	andi	r20, 0x0F	; 15
    79da:	40 5d       	subi	r20, 0xD0	; 208
    79dc:	4a 33       	cpi	r20, 0x3A	; 58
    79de:	18 f0       	brcs	.+6      	; 0x79e6 <__ultoa_invert+0x7c>
    79e0:	49 5d       	subi	r20, 0xD9	; 217
    79e2:	31 fd       	sbrc	r19, 1
    79e4:	40 52       	subi	r20, 0x20	; 32
    79e6:	41 93       	st	Z+, r20
    79e8:	02 d0       	rcall	.+4      	; 0x79ee <__ultoa_invert+0x84>
    79ea:	a9 f7       	brne	.-22     	; 0x79d6 <__ultoa_invert+0x6c>
    79ec:	ea cf       	rjmp	.-44     	; 0x79c2 <__ultoa_invert+0x58>
    79ee:	b4 e0       	ldi	r27, 0x04	; 4
    79f0:	a6 95       	lsr	r26
    79f2:	97 95       	ror	r25
    79f4:	87 95       	ror	r24
    79f6:	77 95       	ror	r23
    79f8:	67 95       	ror	r22
    79fa:	ba 95       	dec	r27
    79fc:	c9 f7       	brne	.-14     	; 0x79f0 <__ultoa_invert+0x86>
    79fe:	00 97       	sbiw	r24, 0x00	; 0
    7a00:	61 05       	cpc	r22, r1
    7a02:	71 05       	cpc	r23, r1
    7a04:	08 95       	ret
    7a06:	9b 01       	movw	r18, r22
    7a08:	ac 01       	movw	r20, r24
    7a0a:	0a 2e       	mov	r0, r26
    7a0c:	06 94       	lsr	r0
    7a0e:	57 95       	ror	r21
    7a10:	47 95       	ror	r20
    7a12:	37 95       	ror	r19
    7a14:	27 95       	ror	r18
    7a16:	ba 95       	dec	r27
    7a18:	c9 f7       	brne	.-14     	; 0x7a0c <__ultoa_invert+0xa2>
    7a1a:	62 0f       	add	r22, r18
    7a1c:	73 1f       	adc	r23, r19
    7a1e:	84 1f       	adc	r24, r20
    7a20:	95 1f       	adc	r25, r21
    7a22:	a0 1d       	adc	r26, r0
    7a24:	08 95       	ret

00007a26 <_exit>:
    7a26:	f8 94       	cli

00007a28 <__stop_program>:
    7a28:	ff cf       	rjmp	.-2      	; 0x7a28 <__stop_program>
