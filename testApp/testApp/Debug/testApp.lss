
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000739e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000010e  00802000  0000739e  00007432  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fa5  0080210e  0080210e  00007540  2**0
                  ALLOC
  3 .stab         000028f8  00000000  00000000  00007540  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009ca  00000000  00000000  00009e38  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000420  00000000  00000000  0000a808  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000b72b  00000000  00000000  0000ac28  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002619  00000000  00000000  00016353  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005869  00000000  00000000  0001896c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001b58  00000000  00000000  0001e1d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000045d3  00000000  00000000  0001fd30  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007f02  00000000  00000000  00024303  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0017fd89  00000000  00000000  0002c205  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000001d8  00000000  00000000  001abf8e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 de 0b 	jmp	0x17bc	; 0x17bc <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 a3 10 	jmp	0x2146	; 0x2146 <__vector_16>
      44:	0c 94 7b 10 	jmp	0x20f6	; 0x20f6 <__vector_17>
      48:	0c 94 53 10 	jmp	0x20a6	; 0x20a6 <__vector_18>
      4c:	0c 94 0d 10 	jmp	0x201a	; 0x201a <__vector_19>
      50:	0c 94 30 0a 	jmp	0x1460	; 0x1460 <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 ec 1a 	jmp	0x35d8	; 0x35d8 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 86 0d 	jmp	0x1b0c	; 0x1b0c <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 e5 0f 	jmp	0x1fca	; 0x1fca <__vector_79>
     140:	0c 94 bd 0f 	jmp	0x1f7a	; 0x1f7a <__vector_80>
     144:	0c 94 95 0f 	jmp	0x1f2a	; 0x1f2a <__vector_81>
     148:	0c 94 6b 0f 	jmp	0x1ed6	; 0x1ed6 <__vector_82>
     14c:	0c 94 35 07 	jmp	0xe6a	; 0xe6a <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 c2 0a 	jmp	0x1584	; 0x1584 <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	ee e9       	ldi	r30, 0x9E	; 158
     244:	f3 e7       	ldi	r31, 0x73	; 115
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	ae 30       	cpi	r26, 0x0E	; 14
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	ae e0       	ldi	r26, 0x0E	; 14
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a3 3b       	cpi	r26, 0xB3	; 179
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 b6 06 	call	0xd6c	; 0xd6c <main>
     26a:	0c 94 cd 39 	jmp	0x739a	; 0x739a <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <writeFRAM>:
 * Created: 3/8/2014 11:40:36 AM
 *  Author: VLAD
 */ 
#include "FRAM.h"

void writeFRAM(uint8_t* buffer, uint16_t length) {
     272:	cf 92       	push	r12
     274:	df 92       	push	r13
     276:	ef 92       	push	r14
     278:	ff 92       	push	r15
     27a:	0f 93       	push	r16
     27c:	1f 93       	push	r17
     27e:	cf 93       	push	r28
     280:	df 93       	push	r29
     282:	f8 2e       	mov	r15, r24
     284:	e9 2e       	mov	r14, r25
     286:	8b 01       	movw	r16, r22
	
	ADCPower(TRUE);
     288:	81 e0       	ldi	r24, 0x01	; 1
     28a:	0e 94 a3 05 	call	0xb46	; 0xb46 <ADCPower>
	SPIInit(SPI_MODE_0_gc);
     28e:	80 e0       	ldi	r24, 0x00	; 0
     290:	0e 94 ad 03 	call	0x75a	; 0x75a <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     294:	c0 ec       	ldi	r28, 0xC0	; 192
     296:	d8 e0       	ldi	r29, 0x08	; 8
     298:	80 ed       	ldi	r24, 0xD0	; 208
     29a:	88 83       	st	Y, r24
	SPICS(TRUE);
     29c:	81 e0       	ldi	r24, 0x01	; 1
     29e:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2a2:	88 e0       	ldi	r24, 0x08	; 8
     2a4:	e0 e2       	ldi	r30, 0x20	; 32
     2a6:	f6 e0       	ldi	r31, 0x06	; 6
     2a8:	86 83       	std	Z+6, r24	; 0x06
	nop();
     2aa:	00 00       	nop
	SPIC.DATA = FR_WREN;
     2ac:	86 e0       	ldi	r24, 0x06	; 6
     2ae:	8b 83       	std	Y+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2b0:	e0 ec       	ldi	r30, 0xC0	; 192
     2b2:	f8 e0       	ldi	r31, 0x08	; 8
     2b4:	82 81       	ldd	r24, Z+2	; 0x02
     2b6:	88 23       	and	r24, r24
     2b8:	ec f7       	brge	.-6      	; 0x2b4 <writeFRAM+0x42>
	SPIBuffer[12] = SPIC.DATA;
     2ba:	e0 ec       	ldi	r30, 0xC0	; 192
     2bc:	f8 e0       	ldi	r31, 0x08	; 8
     2be:	83 81       	ldd	r24, Z+3	; 0x03
     2c0:	80 93 2c 3e 	sts	0x3E2C, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
     2c4:	a0 e2       	ldi	r26, 0x20	; 32
     2c6:	b6 e0       	ldi	r27, 0x06	; 6
     2c8:	88 e0       	ldi	r24, 0x08	; 8
     2ca:	15 96       	adiw	r26, 0x05	; 5
     2cc:	8c 93       	st	X, r24
     2ce:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
     2d0:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2d2:	16 96       	adiw	r26, 0x06	; 6
     2d4:	8c 93       	st	X, r24
     2d6:	16 97       	sbiw	r26, 0x06	; 6
	nop();
     2d8:	00 00       	nop
	SPIC.DATA = FR_WRITE;
     2da:	82 e0       	ldi	r24, 0x02	; 2
     2dc:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2de:	82 81       	ldd	r24, Z+2	; 0x02
     2e0:	88 23       	and	r24, r24
     2e2:	ec f7       	brge	.-6      	; 0x2de <writeFRAM+0x6c>
	SPIBuffer[12] = SPIC.DATA;
     2e4:	e0 ec       	ldi	r30, 0xC0	; 192
     2e6:	f8 e0       	ldi	r31, 0x08	; 8
     2e8:	83 81       	ldd	r24, Z+3	; 0x03
     2ea:	80 93 2c 3e 	sts	0x3E2C, r24
	//send address at which to start writing data
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
     2ee:	80 91 1e 3e 	lds	r24, 0x3E1E
     2f2:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2f4:	82 81       	ldd	r24, Z+2	; 0x02
     2f6:	88 23       	and	r24, r24
     2f8:	ec f7       	brge	.-6      	; 0x2f4 <writeFRAM+0x82>
	SPIBuffer[12] = SPIC.DATA;
     2fa:	e0 ec       	ldi	r30, 0xC0	; 192
     2fc:	f8 e0       	ldi	r31, 0x08	; 8
     2fe:	83 81       	ldd	r24, Z+3	; 0x03
     300:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
     304:	80 91 1d 3e 	lds	r24, 0x3E1D
     308:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     30a:	82 81       	ldd	r24, Z+2	; 0x02
     30c:	88 23       	and	r24, r24
     30e:	ec f7       	brge	.-6      	; 0x30a <writeFRAM+0x98>
	SPIBuffer[12] = SPIC.DATA;
     310:	e0 ec       	ldi	r30, 0xC0	; 192
     312:	f8 e0       	ldi	r31, 0x08	; 8
     314:	83 81       	ldd	r24, Z+3	; 0x03
     316:	80 93 2c 3e 	sts	0x3E2C, r24
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     31a:	a8 01       	movw	r20, r16
     31c:	60 e0       	ldi	r22, 0x00	; 0
     31e:	70 e0       	ldi	r23, 0x00	; 0
     320:	41 15       	cp	r20, r1
     322:	51 05       	cpc	r21, r1
     324:	61 05       	cpc	r22, r1
     326:	71 05       	cpc	r23, r1
     328:	c9 f0       	breq	.+50     	; 0x35c <writeFRAM+0xea>
     32a:	cf 2c       	mov	r12, r15
     32c:	de 2c       	mov	r13, r14
     32e:	80 e0       	ldi	r24, 0x00	; 0
     330:	90 e0       	ldi	r25, 0x00	; 0
     332:	dc 01       	movw	r26, r24
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     334:	2c e2       	ldi	r18, 0x2C	; 44
     336:	3e e3       	ldi	r19, 0x3E	; 62
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
		SPIC.DATA = buffer[i];
     338:	e6 01       	movw	r28, r12
     33a:	f9 90       	ld	r15, Y+
     33c:	6e 01       	movw	r12, r28
     33e:	f3 82       	std	Z+3, r15	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
     340:	f2 80       	ldd	r15, Z+2	; 0x02
     342:	ff 20       	and	r15, r15
     344:	ec f7       	brge	.-6      	; 0x340 <writeFRAM+0xce>
		SPIBuffer[12] = SPIC.DATA;
     346:	f3 80       	ldd	r15, Z+3	; 0x03
     348:	e9 01       	movw	r28, r18
     34a:	f8 82       	st	Y, r15
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     34c:	01 96       	adiw	r24, 0x01	; 1
     34e:	a1 1d       	adc	r26, r1
     350:	b1 1d       	adc	r27, r1
     352:	84 17       	cp	r24, r20
     354:	95 07       	cpc	r25, r21
     356:	a6 07       	cpc	r26, r22
     358:	b7 07       	cpc	r27, r23
     35a:	70 f3       	brcs	.-36     	; 0x338 <writeFRAM+0xc6>
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
     35c:	88 e0       	ldi	r24, 0x08	; 8
     35e:	e0 e2       	ldi	r30, 0x20	; 32
     360:	f6 e0       	ldi	r31, 0x06	; 6
     362:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     364:	80 e0       	ldi	r24, 0x00	; 0
     366:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	//SPIC.CTRL = ADC_SPI_CONFIG_gc;
	//PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
	
	//increment address by the written length
	FRAMAddress +=length;
     36a:	80 91 1d 3e 	lds	r24, 0x3E1D
     36e:	90 91 1e 3e 	lds	r25, 0x3E1E
     372:	08 0f       	add	r16, r24
     374:	19 1f       	adc	r17, r25
     376:	00 93 1d 3e 	sts	0x3E1D, r16
     37a:	10 93 1e 3e 	sts	0x3E1E, r17
}
     37e:	df 91       	pop	r29
     380:	cf 91       	pop	r28
     382:	1f 91       	pop	r17
     384:	0f 91       	pop	r16
     386:	ff 90       	pop	r15
     388:	ef 90       	pop	r14
     38a:	df 90       	pop	r13
     38c:	cf 90       	pop	r12
     38e:	08 95       	ret

00000390 <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
     390:	0f 93       	push	r16
     392:	1f 93       	push	r17
     394:	cf 93       	push	r28
     396:	df 93       	push	r29
     398:	8c 01       	movw	r16, r24
	
	ADCPower(TRUE);
     39a:	81 e0       	ldi	r24, 0x01	; 1
     39c:	0e 94 a3 05 	call	0xb46	; 0xb46 <ADCPower>
	SPIInit(SPI_MODE_0_gc);
     3a0:	80 e0       	ldi	r24, 0x00	; 0
     3a2:	0e 94 ad 03 	call	0x75a	; 0x75a <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     3a6:	c0 ec       	ldi	r28, 0xC0	; 192
     3a8:	d8 e0       	ldi	r29, 0x08	; 8
     3aa:	80 ed       	ldi	r24, 0xD0	; 208
     3ac:	88 83       	st	Y, r24
	SPICS(TRUE);
     3ae:	81 e0       	ldi	r24, 0x01	; 1
     3b0:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     3b4:	88 e0       	ldi	r24, 0x08	; 8
     3b6:	e0 e2       	ldi	r30, 0x20	; 32
     3b8:	f6 e0       	ldi	r31, 0x06	; 6
     3ba:	86 83       	std	Z+6, r24	; 0x06
	nop();
     3bc:	00 00       	nop
	
	SPIC.DATA = FR_READ;
     3be:	83 e0       	ldi	r24, 0x03	; 3
     3c0:	8b 83       	std	Y+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3c2:	e0 ec       	ldi	r30, 0xC0	; 192
     3c4:	f8 e0       	ldi	r31, 0x08	; 8
     3c6:	82 81       	ldd	r24, Z+2	; 0x02
     3c8:	88 23       	and	r24, r24
     3ca:	ec f7       	brge	.-6      	; 0x3c6 <readFRAM+0x36>
	SPIBuffer[12] = SPIC.DATA;
     3cc:	e0 ec       	ldi	r30, 0xC0	; 192
     3ce:	f8 e0       	ldi	r31, 0x08	; 8
     3d0:	83 81       	ldd	r24, Z+3	; 0x03
     3d2:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
     3d6:	80 91 1e 3e 	lds	r24, 0x3E1E
     3da:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3dc:	82 81       	ldd	r24, Z+2	; 0x02
     3de:	88 23       	and	r24, r24
     3e0:	ec f7       	brge	.-6      	; 0x3dc <readFRAM+0x4c>
	SPIBuffer[12] = SPIC.DATA;
     3e2:	e0 ec       	ldi	r30, 0xC0	; 192
     3e4:	f8 e0       	ldi	r31, 0x08	; 8
     3e6:	83 81       	ldd	r24, Z+3	; 0x03
     3e8:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
     3ec:	80 91 1d 3e 	lds	r24, 0x3E1D
     3f0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3f2:	82 81       	ldd	r24, Z+2	; 0x02
     3f4:	88 23       	and	r24, r24
     3f6:	ec f7       	brge	.-6      	; 0x3f2 <readFRAM+0x62>
	SPIBuffer[12] = SPIC.DATA;
     3f8:	e0 ec       	ldi	r30, 0xC0	; 192
     3fa:	f8 e0       	ldi	r31, 0x08	; 8
     3fc:	83 81       	ldd	r24, Z+3	; 0x03
     3fe:	80 93 2c 3e 	sts	0x3E2C, r24
	
	for(uint16_t i = 0; i < numBytes; i++) {
     402:	01 15       	cp	r16, r1
     404:	11 05       	cpc	r17, r1
     406:	b1 f0       	breq	.+44     	; 0x434 <readFRAM+0xa4>
     408:	ec ea       	ldi	r30, 0xAC	; 172
     40a:	f1 e2       	ldi	r31, 0x21	; 33
	FRAMAddress +=length;
}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
     40c:	0e 0f       	add	r16, r30
     40e:	1f 1f       	adc	r17, r31
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
		SPIC.DATA = 0xAA;
     410:	a0 ec       	ldi	r26, 0xC0	; 192
     412:	b8 e0       	ldi	r27, 0x08	; 8
     414:	9a ea       	ldi	r25, 0xAA	; 170
     416:	13 96       	adiw	r26, 0x03	; 3
     418:	9c 93       	st	X, r25
     41a:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     41c:	12 96       	adiw	r26, 0x02	; 2
     41e:	8c 91       	ld	r24, X
     420:	12 97       	sbiw	r26, 0x02	; 2
     422:	88 23       	and	r24, r24
     424:	dc f7       	brge	.-10     	; 0x41c <readFRAM+0x8c>
		FRAMReadBuffer[i] = SPIC.DATA;
     426:	13 96       	adiw	r26, 0x03	; 3
     428:	8c 91       	ld	r24, X
     42a:	13 97       	sbiw	r26, 0x03	; 3
     42c:	81 93       	st	Z+, r24
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
     42e:	e0 17       	cp	r30, r16
     430:	f1 07       	cpc	r31, r17
     432:	89 f7       	brne	.-30     	; 0x416 <readFRAM+0x86>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
     434:	88 e0       	ldi	r24, 0x08	; 8
     436:	e0 e2       	ldi	r30, 0x20	; 32
     438:	f6 e0       	ldi	r31, 0x06	; 6
     43a:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     43c:	80 e0       	ldi	r24, 0x00	; 0
     43e:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	SPIDisable();
     442:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <SPIDisable>

}
     446:	df 91       	pop	r29
     448:	cf 91       	pop	r28
     44a:	1f 91       	pop	r17
     44c:	0f 91       	pop	r16
     44e:	08 95       	ret

00000450 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     450:	cf 92       	push	r12
     452:	df 92       	push	r13
     454:	ef 92       	push	r14
     456:	ff 92       	push	r15
     458:	0f 93       	push	r16
     45a:	1f 93       	push	r17
     45c:	cf 93       	push	r28
     45e:	df 93       	push	r29
     460:	6b 01       	movw	r12, r22
     462:	7c 01       	movw	r14, r24
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     464:	dc 01       	movw	r26, r24
     466:	cb 01       	movw	r24, r22
     468:	88 55       	subi	r24, 0x58	; 88
     46a:	92 40       	sbci	r25, 0x02	; 2
     46c:	a0 40       	sbci	r26, 0x00	; 0
     46e:	b0 40       	sbci	r27, 0x00	; 0
     470:	89 3e       	cpi	r24, 0xE9	; 233
     472:	2f e3       	ldi	r18, 0x3F	; 63
     474:	92 07       	cpc	r25, r18
     476:	2f e0       	ldi	r18, 0x0F	; 15
     478:	a2 07       	cpc	r26, r18
     47a:	20 e0       	ldi	r18, 0x00	; 0
     47c:	b2 07       	cpc	r27, r18
     47e:	08 f0       	brcs	.+2      	; 0x482 <StartSerial+0x32>
     480:	5c c0       	rjmp	.+184    	; 0x53a <StartSerial+0xea>
		//baud rate too fast or too slow
		return false;
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     482:	0e 94 25 03 	call	0x64a	; 0x64a <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     486:	e0 e4       	ldi	r30, 0x40	; 64
     488:	f6 e0       	ldi	r31, 0x06	; 6
     48a:	88 e0       	ldi	r24, 0x08	; 8
     48c:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = PIN3_bm;
     48e:	85 83       	std	Z+5, r24	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     490:	84 e0       	ldi	r24, 0x04	; 4
     492:	82 83       	std	Z+2, r24	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     494:	cc 0c       	add	r12, r12
     496:	dd 1c       	adc	r13, r13
     498:	ee 1c       	adc	r14, r14
     49a:	ff 1c       	adc	r15, r15
     49c:	cc 0c       	add	r12, r12
     49e:	dd 1c       	adc	r13, r13
     4a0:	ee 1c       	adc	r14, r14
     4a2:	ff 1c       	adc	r15, r15
     4a4:	c7 01       	movw	r24, r14
     4a6:	b6 01       	movw	r22, r12
     4a8:	66 0f       	add	r22, r22
     4aa:	77 1f       	adc	r23, r23
     4ac:	88 1f       	adc	r24, r24
     4ae:	99 1f       	adc	r25, r25
     4b0:	66 0f       	add	r22, r22
     4b2:	77 1f       	adc	r23, r23
     4b4:	88 1f       	adc	r24, r24
     4b6:	99 1f       	adc	r25, r25
     4b8:	0e 94 29 35 	call	0x6a52	; 0x6a52 <__floatunsisf>
     4bc:	9b 01       	movw	r18, r22
     4be:	ac 01       	movw	r20, r24
     4c0:	60 e0       	ldi	r22, 0x00	; 0
     4c2:	74 e2       	ldi	r23, 0x24	; 36
     4c4:	84 ef       	ldi	r24, 0xF4	; 244
     4c6:	9b e4       	ldi	r25, 0x4B	; 75
     4c8:	0e 94 95 34 	call	0x692a	; 0x692a <__divsf3>
     4cc:	20 e0       	ldi	r18, 0x00	; 0
     4ce:	30 e0       	ldi	r19, 0x00	; 0
     4d0:	40 e8       	ldi	r20, 0x80	; 128
     4d2:	5f e3       	ldi	r21, 0x3F	; 63
     4d4:	0e 94 30 34 	call	0x6860	; 0x6860 <__subsf3>
     4d8:	c6 2f       	mov	r28, r22
     4da:	d7 2f       	mov	r29, r23
     4dc:	18 2f       	mov	r17, r24
     4de:	09 2f       	mov	r16, r25
     4e0:	86 2f       	mov	r24, r22
     4e2:	9d 2f       	mov	r25, r29
     4e4:	a1 2f       	mov	r26, r17
     4e6:	b0 2f       	mov	r27, r16
     4e8:	bc 01       	movw	r22, r24
     4ea:	cd 01       	movw	r24, r26
     4ec:	0e 94 fd 34 	call	0x69fa	; 0x69fa <__fixunssfsi>
     4f0:	6b 01       	movw	r12, r22
     4f2:	7c 01       	movw	r14, r24
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     4f4:	80 e0       	ldi	r24, 0x00	; 0
     4f6:	90 e0       	ldi	r25, 0x00	; 0
     4f8:	0e 94 29 35 	call	0x6a52	; 0x6a52 <__floatunsisf>
     4fc:	9b 01       	movw	r18, r22
     4fe:	ac 01       	movw	r20, r24
     500:	8c 2f       	mov	r24, r28
     502:	9d 2f       	mov	r25, r29
     504:	a1 2f       	mov	r26, r17
     506:	b0 2f       	mov	r27, r16
     508:	bc 01       	movw	r22, r24
     50a:	cd 01       	movw	r24, r26
     50c:	0e 94 30 34 	call	0x6860	; 0x6860 <__subsf3>
     510:	20 e0       	ldi	r18, 0x00	; 0
     512:	30 e0       	ldi	r19, 0x00	; 0
     514:	40 e0       	ldi	r20, 0x00	; 0
     516:	5f e3       	ldi	r21, 0x3F	; 63
     518:	0e 94 b7 35 	call	0x6b6e	; 0x6b6e <__gesf2>
     51c:	88 23       	and	r24, r24
     51e:	1c f0       	brlt	.+6      	; 0x526 <StartSerial+0xd6>
     520:	08 94       	sec
     522:	c1 1c       	adc	r12, r1
     524:	d1 1c       	adc	r13, r1
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     526:	e0 ea       	ldi	r30, 0xA0	; 160
     528:	f8 e0       	ldi	r31, 0x08	; 8
     52a:	c6 82       	std	Z+6, r12	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     52c:	d7 82       	std	Z+7, r13	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     52e:	83 e0       	ldi	r24, 0x03	; 3
     530:	85 83       	std	Z+5, r24	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     532:	88 e1       	ldi	r24, 0x18	; 24
     534:	84 83       	std	Z+4, r24	; 0x04
	return true;
     536:	81 e0       	ldi	r24, 0x01	; 1
     538:	01 c0       	rjmp	.+2      	; 0x53c <StartSerial+0xec>

bool StartSerial(uint32_t BaudRate){
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
		//baud rate too fast or too slow
		return false;
     53a:	80 e0       	ldi	r24, 0x00	; 0
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
	return true;
}
     53c:	df 91       	pop	r29
     53e:	cf 91       	pop	r28
     540:	1f 91       	pop	r17
     542:	0f 91       	pop	r16
     544:	ff 90       	pop	r15
     546:	ef 90       	pop	r14
     548:	df 90       	pop	r13
     54a:	cf 90       	pop	r12
     54c:	08 95       	ret

0000054e <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     54e:	e0 ea       	ldi	r30, 0xA0	; 160
     550:	f8 e0       	ldi	r31, 0x08	; 8
     552:	91 81       	ldd	r25, Z+1	; 0x01
     554:	95 ff       	sbrs	r25, 5
     556:	fd cf       	rjmp	.-6      	; 0x552 <SerialWriteByte+0x4>
		//wait
	}
	//send byte
	USARTC0.DATA = byte;
     558:	80 93 a0 08 	sts	0x08A0, r24
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     55c:	08 95       	ret

0000055e <SerialReadByte>:

uint8_t SerialReadByte(){
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     55e:	e0 ea       	ldi	r30, 0xA0	; 160
     560:	f8 e0       	ldi	r31, 0x08	; 8
     562:	81 81       	ldd	r24, Z+1	; 0x01
     564:	88 23       	and	r24, r24
     566:	ec f7       	brge	.-6      	; 0x562 <SerialReadByte+0x4>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     568:	80 91 a0 08 	lds	r24, 0x08A0
	return byte;	
}
     56c:	08 95       	ret

0000056e <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     56e:	8f 92       	push	r8
     570:	9f 92       	push	r9
     572:	af 92       	push	r10
     574:	bf 92       	push	r11
     576:	cf 92       	push	r12
     578:	df 92       	push	r13
     57a:	ef 92       	push	r14
     57c:	ff 92       	push	r15
     57e:	cf 93       	push	r28
     580:	df 93       	push	r29
     582:	6a 01       	movw	r12, r20
     584:	7b 01       	movw	r14, r22
	uint32_t i;
	for(i=0;i<length;i++){
     586:	41 15       	cp	r20, r1
     588:	51 05       	cpc	r21, r1
     58a:	61 05       	cpc	r22, r1
     58c:	71 05       	cpc	r23, r1
     58e:	91 f0       	breq	.+36     	; 0x5b4 <SerialWriteBuffer+0x46>
     590:	c8 2f       	mov	r28, r24
     592:	d9 2f       	mov	r29, r25
     594:	88 24       	eor	r8, r8
     596:	99 24       	eor	r9, r9
     598:	54 01       	movw	r10, r8
		SerialWriteByte(buffer[i]);
     59a:	89 91       	ld	r24, Y+
     59c:	0e 94 a7 02 	call	0x54e	; 0x54e <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     5a0:	08 94       	sec
     5a2:	81 1c       	adc	r8, r1
     5a4:	91 1c       	adc	r9, r1
     5a6:	a1 1c       	adc	r10, r1
     5a8:	b1 1c       	adc	r11, r1
     5aa:	8c 14       	cp	r8, r12
     5ac:	9d 04       	cpc	r9, r13
     5ae:	ae 04       	cpc	r10, r14
     5b0:	bf 04       	cpc	r11, r15
     5b2:	99 f7       	brne	.-26     	; 0x59a <SerialWriteBuffer+0x2c>
		SerialWriteByte(buffer[i]);
	}
}
     5b4:	df 91       	pop	r29
     5b6:	cf 91       	pop	r28
     5b8:	ff 90       	pop	r15
     5ba:	ef 90       	pop	r14
     5bc:	df 90       	pop	r13
     5be:	cf 90       	pop	r12
     5c0:	bf 90       	pop	r11
     5c2:	af 90       	pop	r10
     5c4:	9f 90       	pop	r9
     5c6:	8f 90       	pop	r8
     5c8:	08 95       	ret

000005ca <StopSerial>:

void StopSerial(){
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     5ca:	e0 ea       	ldi	r30, 0xA0	; 160
     5cc:	f8 e0       	ldi	r31, 0x08	; 8
     5ce:	84 81       	ldd	r24, Z+4	; 0x04
     5d0:	87 7e       	andi	r24, 0xE7	; 231
     5d2:	84 83       	std	Z+4, r24	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     5d4:	e0 e4       	ldi	r30, 0x40	; 64
     5d6:	f6 e0       	ldi	r31, 0x06	; 6
     5d8:	88 e0       	ldi	r24, 0x08	; 8
     5da:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     5dc:	82 83       	std	Z+2, r24	; 0x02
     5de:	08 95       	ret

000005e0 <setXOSC_32MHz>:
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
	// configure the crystal to match the chip
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
     5e0:	80 ec       	ldi	r24, 0xC0	; 192
     5e2:	60 e0       	ldi	r22, 0x00	; 0
     5e4:	4b e0       	ldi	r20, 0x0B	; 11
     5e6:	0e 94 cd 1c 	call	0x399a	; 0x399a <CLKSYS_XOSC_Config>
	false,
	OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
     5ea:	e0 e5       	ldi	r30, 0x50	; 80
     5ec:	f0 e0       	ldi	r31, 0x00	; 0
     5ee:	80 81       	ld	r24, Z
     5f0:	88 60       	ori	r24, 0x08	; 8
     5f2:	80 83       	st	Z, r24
	// wait for signal to stabilize
do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
     5f4:	81 81       	ldd	r24, Z+1	; 0x01
     5f6:	83 ff       	sbrs	r24, 3
     5f8:	fd cf       	rjmp	.-6      	; 0x5f4 <setXOSC_32MHz+0x14>
// configure PLL to use the crystal and turn on
CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
     5fa:	80 ec       	ldi	r24, 0xC0	; 192
     5fc:	62 e0       	ldi	r22, 0x02	; 2
     5fe:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <CLKSYS_PLL_Config>
CLKSYS_Enable( OSC_PLLEN_bm );
     602:	e0 e5       	ldi	r30, 0x50	; 80
     604:	f0 e0       	ldi	r31, 0x00	; 0
     606:	80 81       	ld	r24, Z
     608:	80 61       	ori	r24, 0x10	; 16
     60a:	80 83       	st	Z, r24
// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
     60c:	81 81       	ldd	r24, Z+1	; 0x01
     60e:	84 ff       	sbrs	r24, 4
     610:	fd cf       	rjmp	.-6      	; 0x60c <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
     612:	84 e0       	ldi	r24, 0x04	; 4
     614:	0e 94 ee 1c 	call	0x39dc	; 0x39dc <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     618:	81 e0       	ldi	r24, 0x01	; 1
     61a:	0e 94 de 1c 	call	0x39bc	; 0x39bc <CLKSYS_Disable>
}
     61e:	08 95       	ret

00000620 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
     620:	e0 e5       	ldi	r30, 0x50	; 80
     622:	f0 e0       	ldi	r31, 0x00	; 0
     624:	80 81       	ld	r24, Z
     626:	82 60       	ori	r24, 0x02	; 2
     628:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
     62a:	80 e0       	ldi	r24, 0x00	; 0
     62c:	61 e0       	ldi	r22, 0x01	; 1
     62e:	0e 94 e8 1c 	call	0x39d0	; 0x39d0 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     632:	e0 e5       	ldi	r30, 0x50	; 80
     634:	f0 e0       	ldi	r31, 0x00	; 0
     636:	81 81       	ldd	r24, Z+1	; 0x01
     638:	81 ff       	sbrs	r24, 1
     63a:	fd cf       	rjmp	.-6      	; 0x636 <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     63c:	81 e0       	ldi	r24, 0x01	; 1
     63e:	0e 94 ee 1c 	call	0x39dc	; 0x39dc <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     642:	81 e0       	ldi	r24, 0x01	; 1
     644:	0e 94 de 1c 	call	0x39bc	; 0x39bc <CLKSYS_Disable>
	
}
     648:	08 95       	ret

0000064a <set_32MHz>:

// produces consistent but inaccurate clock period.
void set_32MHz() {
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
     64a:	e0 e5       	ldi	r30, 0x50	; 80
     64c:	f0 e0       	ldi	r31, 0x00	; 0
     64e:	80 81       	ld	r24, Z
     650:	82 60       	ori	r24, 0x02	; 2
     652:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
     654:	80 e0       	ldi	r24, 0x00	; 0
     656:	60 e0       	ldi	r22, 0x00	; 0
     658:	0e 94 e8 1c 	call	0x39d0	; 0x39d0 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     65c:	e0 e5       	ldi	r30, 0x50	; 80
     65e:	f0 e0       	ldi	r31, 0x00	; 0
     660:	81 81       	ldd	r24, Z+1	; 0x01
     662:	81 ff       	sbrs	r24, 1
     664:	fd cf       	rjmp	.-6      	; 0x660 <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     666:	81 e0       	ldi	r24, 0x01	; 1
     668:	0e 94 ee 1c 	call	0x39dc	; 0x39dc <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     66c:	81 e0       	ldi	r24, 0x01	; 1
     66e:	0e 94 de 1c 	call	0x39bc	; 0x39bc <CLKSYS_Disable>
	
}
     672:	08 95       	ret

00000674 <portExCS>:


void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
     674:	88 23       	and	r24, r24
     676:	29 f0       	breq	.+10     	; 0x682 <portExCS+0xe>
     678:	88 e0       	ldi	r24, 0x08	; 8
     67a:	e0 e0       	ldi	r30, 0x00	; 0
     67c:	f6 e0       	ldi	r31, 0x06	; 6
     67e:	86 83       	std	Z+6, r24	; 0x06
     680:	04 c0       	rjmp	.+8      	; 0x68a <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
     682:	88 e0       	ldi	r24, 0x08	; 8
     684:	e0 e0       	ldi	r30, 0x00	; 0
     686:	f6 e0       	ldi	r31, 0x06	; 6
     688:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     68a:	8a e6       	ldi	r24, 0x6A	; 106
     68c:	8a 95       	dec	r24
     68e:	f1 f7       	brne	.-4      	; 0x68c <portExCS+0x18>
     690:	00 c0       	rjmp	.+0      	; 0x692 <portExCS+0x1e>
	}
	_delay_us(10);
}
     692:	08 95       	ret

00000694 <Ext1Power>:
	SPIDisable();
}

void Ext1Power(uint8_t on) {
	
	if (on) {
     694:	88 23       	and	r24, r24
     696:	79 f0       	breq	.+30     	; 0x6b6 <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
     698:	e0 ea       	ldi	r30, 0xA0	; 160
     69a:	f6 e0       	ldi	r31, 0x06	; 6
     69c:	80 e2       	ldi	r24, 0x20	; 32
     69e:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
     6a0:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     6a2:	8f ef       	ldi	r24, 0xFF	; 255
     6a4:	93 ec       	ldi	r25, 0xC3	; 195
     6a6:	a9 e0       	ldi	r26, 0x09	; 9
     6a8:	81 50       	subi	r24, 0x01	; 1
     6aa:	90 40       	sbci	r25, 0x00	; 0
     6ac:	a0 40       	sbci	r26, 0x00	; 0
     6ae:	e1 f7       	brne	.-8      	; 0x6a8 <Ext1Power+0x14>
     6b0:	00 c0       	rjmp	.+0      	; 0x6b2 <Ext1Power+0x1e>
     6b2:	00 00       	nop
     6b4:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
     6b6:	e0 ea       	ldi	r30, 0xA0	; 160
     6b8:	f6 e0       	ldi	r31, 0x06	; 6
     6ba:	80 e2       	ldi	r24, 0x20	; 32
     6bc:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
     6be:	82 83       	std	Z+2, r24	; 0x02
     6c0:	08 95       	ret

000006c2 <Ext2Power>:
	}
}

void Ext2Power(uint8_t on) {
	
	if (on) {
     6c2:	88 23       	and	r24, r24
     6c4:	79 f0       	breq	.+30     	; 0x6e4 <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
     6c6:	e0 ea       	ldi	r30, 0xA0	; 160
     6c8:	f6 e0       	ldi	r31, 0x06	; 6
     6ca:	80 e4       	ldi	r24, 0x40	; 64
     6cc:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
     6ce:	85 83       	std	Z+5, r24	; 0x05
     6d0:	8f ef       	ldi	r24, 0xFF	; 255
     6d2:	93 ec       	ldi	r25, 0xC3	; 195
     6d4:	a9 e0       	ldi	r26, 0x09	; 9
     6d6:	81 50       	subi	r24, 0x01	; 1
     6d8:	90 40       	sbci	r25, 0x00	; 0
     6da:	a0 40       	sbci	r26, 0x00	; 0
     6dc:	e1 f7       	brne	.-8      	; 0x6d6 <Ext2Power+0x14>
     6de:	00 c0       	rjmp	.+0      	; 0x6e0 <Ext2Power+0x1e>
     6e0:	00 00       	nop
     6e2:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
     6e4:	e0 ea       	ldi	r30, 0xA0	; 160
     6e6:	f6 e0       	ldi	r31, 0x06	; 6
     6e8:	80 e4       	ldi	r24, 0x40	; 64
     6ea:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
     6ec:	82 83       	std	Z+2, r24	; 0x02
     6ee:	08 95       	ret

000006f0 <HVPower>:
	}
}

void HVPower(uint8_t on) {
	
	if (on) {
     6f0:	88 23       	and	r24, r24
     6f2:	79 f0       	breq	.+30     	; 0x712 <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
     6f4:	e0 ea       	ldi	r30, 0xA0	; 160
     6f6:	f6 e0       	ldi	r31, 0x06	; 6
     6f8:	80 e8       	ldi	r24, 0x80	; 128
     6fa:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
     6fc:	85 83       	std	Z+5, r24	; 0x05
     6fe:	8f ef       	ldi	r24, 0xFF	; 255
     700:	93 ec       	ldi	r25, 0xC3	; 195
     702:	a9 e0       	ldi	r26, 0x09	; 9
     704:	81 50       	subi	r24, 0x01	; 1
     706:	90 40       	sbci	r25, 0x00	; 0
     708:	a0 40       	sbci	r26, 0x00	; 0
     70a:	e1 f7       	brne	.-8      	; 0x704 <HVPower+0x14>
     70c:	00 c0       	rjmp	.+0      	; 0x70e <HVPower+0x1e>
     70e:	00 00       	nop
     710:	05 c0       	rjmp	.+10     	; 0x71c <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
     712:	e0 ea       	ldi	r30, 0xA0	; 160
     714:	f6 e0       	ldi	r31, 0x06	; 6
     716:	80 e8       	ldi	r24, 0x80	; 128
     718:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
     71a:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     71c:	af e3       	ldi	r26, 0x3F	; 63
     71e:	bf e1       	ldi	r27, 0x1F	; 31
     720:	11 97       	sbiw	r26, 0x01	; 1
     722:	f1 f7       	brne	.-4      	; 0x720 <HVPower+0x30>
     724:	00 c0       	rjmp	.+0      	; 0x726 <HVPower+0x36>
     726:	00 00       	nop
	}
	_delay_us(1000);
}
     728:	08 95       	ret

0000072a <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
     72a:	88 23       	and	r24, r24
     72c:	29 f0       	breq	.+10     	; 0x738 <lowerMuxCS+0xe>
     72e:	80 e1       	ldi	r24, 0x10	; 16
     730:	e0 e8       	ldi	r30, 0x80	; 128
     732:	f6 e0       	ldi	r31, 0x06	; 6
     734:	86 83       	std	Z+6, r24	; 0x06
     736:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
     738:	80 e1       	ldi	r24, 0x10	; 16
     73a:	e0 e8       	ldi	r30, 0x80	; 128
     73c:	f6 e0       	ldi	r31, 0x06	; 6
     73e:	85 83       	std	Z+5, r24	; 0x05
     740:	08 95       	ret

00000742 <upperMuxCS>:
}

void upperMuxCS(uint8_t write) {
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
     742:	88 23       	and	r24, r24
     744:	29 f0       	breq	.+10     	; 0x750 <upperMuxCS+0xe>
     746:	82 e0       	ldi	r24, 0x02	; 2
     748:	e0 e4       	ldi	r30, 0x40	; 64
     74a:	f6 e0       	ldi	r31, 0x06	; 6
     74c:	86 83       	std	Z+6, r24	; 0x06
     74e:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
     750:	82 e0       	ldi	r24, 0x02	; 2
     752:	e0 e4       	ldi	r30, 0x40	; 64
     754:	f6 e0       	ldi	r31, 0x06	; 6
     756:	85 83       	std	Z+5, r24	; 0x05
     758:	08 95       	ret

0000075a <SPIInit>:
}

void SPIInit(uint8_t mode) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     75a:	e0 e4       	ldi	r30, 0x40	; 64
     75c:	f6 e0       	ldi	r31, 0x06	; 6
     75e:	90 e1       	ldi	r25, 0x10	; 16
     760:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     762:	28 e3       	ldi	r18, 0x38	; 56
     764:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     766:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
     768:	81 65       	ori	r24, 0x51	; 81
     76a:	a0 ec       	ldi	r26, 0xC0	; 192
     76c:	b8 e0       	ldi	r27, 0x08	; 8
     76e:	8c 93       	st	X, r24
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     770:	11 96       	adiw	r26, 0x01	; 1
     772:	1c 92       	st	X, r1
     774:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     776:	80 ea       	ldi	r24, 0xA0	; 160
     778:	81 83       	std	Z+1, r24	; 0x01

	
}
     77a:	08 95       	ret

0000077c <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     77c:	e0 e4       	ldi	r30, 0x40	; 64
     77e:	f6 e0       	ldi	r31, 0x06	; 6
     780:	90 e1       	ldi	r25, 0x10	; 16
     782:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     784:	28 e3       	ldi	r18, 0x38	; 56
     786:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     788:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
     78a:	80 65       	ori	r24, 0x50	; 80
     78c:	68 2b       	or	r22, r24
     78e:	a0 ec       	ldi	r26, 0xC0	; 192
     790:	b8 e0       	ldi	r27, 0x08	; 8
     792:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     794:	11 96       	adiw	r26, 0x01	; 1
     796:	1c 92       	st	X, r1
     798:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     79a:	80 ea       	ldi	r24, 0xA0	; 160
     79c:	81 83       	std	Z+1, r24	; 0x01
}
     79e:	08 95       	ret

000007a0 <SPICS>:

void SPICS(uint8_t enable) {
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
     7a0:	88 23       	and	r24, r24
     7a2:	29 f0       	breq	.+10     	; 0x7ae <SPICS+0xe>
     7a4:	80 e1       	ldi	r24, 0x10	; 16
     7a6:	e0 e4       	ldi	r30, 0x40	; 64
     7a8:	f6 e0       	ldi	r31, 0x06	; 6
     7aa:	86 83       	std	Z+6, r24	; 0x06
     7ac:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
     7ae:	80 e1       	ldi	r24, 0x10	; 16
     7b0:	e0 e4       	ldi	r30, 0x40	; 64
     7b2:	f6 e0       	ldi	r31, 0x06	; 6
     7b4:	85 83       	std	Z+5, r24	; 0x05
     7b6:	08 95       	ret

000007b8 <SPIDisable>:
	}
}

void SPIDisable() {
	
	PORTC.OUTSET = PIN4_bm;
     7b8:	e0 e4       	ldi	r30, 0x40	; 64
     7ba:	f6 e0       	ldi	r31, 0x06	; 6
     7bc:	80 e1       	ldi	r24, 0x10	; 16
     7be:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
     7c0:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
     7c4:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
     7c6:	80 eb       	ldi	r24, 0xB0	; 176
     7c8:	82 83       	std	Z+2, r24	; 0x02

}
     7ca:	08 95       	ret

000007cc <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     7cc:	cf 93       	push	r28
     7ce:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     7d0:	c8 2f       	mov	r28, r24
     7d2:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
     7d4:	d8 2f       	mov	r29, r24
     7d6:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     7d8:	28 2f       	mov	r18, r24
     7da:	30 e0       	ldi	r19, 0x00	; 0
     7dc:	a9 01       	movw	r20, r18
     7de:	45 70       	andi	r20, 0x05	; 5
     7e0:	50 70       	andi	r21, 0x00	; 0
     7e2:	41 15       	cp	r20, r1
     7e4:	51 05       	cpc	r21, r1
     7e6:	49 f0       	breq	.+18     	; 0x7fa <set_filter+0x2e>
     7e8:	90 91 30 3e 	lds	r25, 0x3E30
     7ec:	48 2f       	mov	r20, r24
     7ee:	42 95       	swap	r20
     7f0:	4f 70       	andi	r20, 0x0F	; 15
     7f2:	90 7f       	andi	r25, 0xF0	; 240
     7f4:	94 2b       	or	r25, r20
     7f6:	90 93 30 3e 	sts	0x3E30, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     7fa:	2a 70       	andi	r18, 0x0A	; 10
     7fc:	30 70       	andi	r19, 0x00	; 0
     7fe:	21 15       	cp	r18, r1
     800:	31 05       	cpc	r19, r1
     802:	39 f0       	breq	.+14     	; 0x812 <set_filter+0x46>
     804:	90 91 30 3e 	lds	r25, 0x3E30
     808:	80 7f       	andi	r24, 0xF0	; 240
     80a:	9f 70       	andi	r25, 0x0F	; 15
     80c:	89 2b       	or	r24, r25
     80e:	80 93 30 3e 	sts	0x3E30, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     812:	84 e0       	ldi	r24, 0x04	; 4
     814:	0e 94 ad 03 	call	0x75a	; 0x75a <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     818:	80 91 30 3e 	lds	r24, 0x3E30
     81c:	80 93 20 3e 	sts	0x3E20, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     820:	cc 23       	and	r28, r28
     822:	19 f0       	breq	.+6      	; 0x82a <set_filter+0x5e>
     824:	81 e0       	ldi	r24, 0x01	; 1
     826:	0e 94 95 03 	call	0x72a	; 0x72a <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     82a:	dd 23       	and	r29, r29
     82c:	19 f0       	breq	.+6      	; 0x834 <set_filter+0x68>
     82e:	81 e0       	ldi	r24, 0x01	; 1
     830:	0e 94 a1 03 	call	0x742	; 0x742 <upperMuxCS>

	SPICS(TRUE);
     834:	81 e0       	ldi	r24, 0x01	; 1
     836:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     83a:	8f ef       	ldi	r24, 0xFF	; 255
     83c:	e0 ec       	ldi	r30, 0xC0	; 192
     83e:	f8 e0       	ldi	r31, 0x08	; 8
     840:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     842:	82 81       	ldd	r24, Z+2	; 0x02
     844:	88 23       	and	r24, r24
     846:	ec f7       	brge	.-6      	; 0x842 <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
     848:	e0 ec       	ldi	r30, 0xC0	; 192
     84a:	f8 e0       	ldi	r31, 0x08	; 8
     84c:	83 81       	ldd	r24, Z+3	; 0x03
     84e:	80 93 2c 3e 	sts	0x3E2C, r24

	nop();
     852:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     854:	ac e2       	ldi	r26, 0x2C	; 44
     856:	be e3       	ldi	r27, 0x3E	; 62
     858:	1c 97       	sbiw	r26, 0x0c	; 12
     85a:	8c 91       	ld	r24, X
     85c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     85e:	82 81       	ldd	r24, Z+2	; 0x02
     860:	88 23       	and	r24, r24
     862:	ec f7       	brge	.-6      	; 0x85e <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     864:	e0 ec       	ldi	r30, 0xC0	; 192
     866:	f8 e0       	ldi	r31, 0x08	; 8
     868:	83 81       	ldd	r24, Z+3	; 0x03
     86a:	80 93 2c 3e 	sts	0x3E2C, r24
	SPICS(FALSE);
     86e:	80 e0       	ldi	r24, 0x00	; 0
     870:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     874:	cc 23       	and	r28, r28
     876:	19 f0       	breq	.+6      	; 0x87e <set_filter+0xb2>
     878:	80 e0       	ldi	r24, 0x00	; 0
     87a:	0e 94 95 03 	call	0x72a	; 0x72a <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     87e:	dd 23       	and	r29, r29
     880:	19 f0       	breq	.+6      	; 0x888 <set_filter+0xbc>
     882:	80 e0       	ldi	r24, 0x00	; 0
     884:	0e 94 a1 03 	call	0x742	; 0x742 <upperMuxCS>
	SPIDisable();
     888:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <SPIDisable>
}
     88c:	df 91       	pop	r29
     88e:	cf 91       	pop	r28
     890:	08 95       	ret

00000892 <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     892:	cf 93       	push	r28
     894:	df 93       	push	r29
     896:	c8 2f       	mov	r28, r24
     898:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     89a:	80 e0       	ldi	r24, 0x00	; 0
     89c:	0e 94 ad 03 	call	0x75a	; 0x75a <SPIInit>
	SPICS(TRUE);
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	portExCS(TRUE);
     8a6:	81 e0       	ldi	r24, 0x01	; 1
     8a8:	0e 94 3a 03 	call	0x674	; 0x674 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
     8ac:	dd 23       	and	r29, r29
     8ae:	89 f0       	breq	.+34     	; 0x8d2 <PortEx_OUTCLR+0x40>
     8b0:	80 91 ab 21 	lds	r24, 0x21AB
     8b4:	c0 95       	com	r28
     8b6:	c8 23       	and	r28, r24
     8b8:	c0 93 ab 21 	sts	0x21AB, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
     8bc:	80 e4       	ldi	r24, 0x40	; 64
     8be:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     8c2:	84 e1       	ldi	r24, 0x14	; 20
     8c4:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = bankA_OUT;
     8c8:	80 91 ab 21 	lds	r24, 0x21AB
     8cc:	80 93 22 3e 	sts	0x3E22, r24
     8d0:	10 c0       	rjmp	.+32     	; 0x8f2 <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
     8d2:	80 91 31 3e 	lds	r24, 0x3E31
     8d6:	c0 95       	com	r28
     8d8:	c8 23       	and	r28, r24
     8da:	c0 93 31 3e 	sts	0x3E31, r28
	
	SPIBuffer[0] = PS_WRITE;
     8de:	80 e4       	ldi	r24, 0x40	; 64
     8e0:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     8e4:	85 e1       	ldi	r24, 0x15	; 21
     8e6:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = bankB_OUT; 
     8ea:	80 91 31 3e 	lds	r24, 0x3E31
     8ee:	80 93 22 3e 	sts	0x3E22, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     8f2:	80 e0       	ldi	r24, 0x00	; 0
     8f4:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     8f6:	20 e2       	ldi	r18, 0x20	; 32
     8f8:	3e e3       	ldi	r19, 0x3E	; 62
     8fa:	a0 ec       	ldi	r26, 0xC0	; 192
     8fc:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     8fe:	cc e2       	ldi	r28, 0x2C	; 44
     900:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     902:	f9 01       	movw	r30, r18
     904:	e8 0f       	add	r30, r24
     906:	f9 1f       	adc	r31, r25
     908:	40 81       	ld	r20, Z
     90a:	13 96       	adiw	r26, 0x03	; 3
     90c:	4c 93       	st	X, r20
     90e:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     910:	12 96       	adiw	r26, 0x02	; 2
     912:	4c 91       	ld	r20, X
     914:	12 97       	sbiw	r26, 0x02	; 2
     916:	44 23       	and	r20, r20
     918:	dc f7       	brge	.-10     	; 0x910 <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
     91a:	13 96       	adiw	r26, 0x03	; 3
     91c:	4c 91       	ld	r20, X
     91e:	13 97       	sbiw	r26, 0x03	; 3
     920:	48 83       	st	Y, r20
     922:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     924:	83 30       	cpi	r24, 0x03	; 3
     926:	91 05       	cpc	r25, r1
     928:	61 f7       	brne	.-40     	; 0x902 <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     92a:	80 e0       	ldi	r24, 0x00	; 0
     92c:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	portExCS(FALSE);
     930:	80 e0       	ldi	r24, 0x00	; 0
     932:	0e 94 3a 03 	call	0x674	; 0x674 <portExCS>
	SPIDisable();
     936:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <SPIDisable>
}
     93a:	df 91       	pop	r29
     93c:	cf 91       	pop	r28
     93e:	08 95       	ret

00000940 <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     940:	cf 93       	push	r28
     942:	df 93       	push	r29
     944:	c8 2f       	mov	r28, r24
     946:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     948:	80 e0       	ldi	r24, 0x00	; 0
     94a:	0e 94 ad 03 	call	0x75a	; 0x75a <SPIInit>
	SPICS(TRUE);
     94e:	81 e0       	ldi	r24, 0x01	; 1
     950:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	portExCS(TRUE);
     954:	81 e0       	ldi	r24, 0x01	; 1
     956:	0e 94 3a 03 	call	0x674	; 0x674 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
     95a:	dd 23       	and	r29, r29
     95c:	81 f0       	breq	.+32     	; 0x97e <PortEx_OUTSET+0x3e>
     95e:	80 91 ab 21 	lds	r24, 0x21AB
     962:	c8 2b       	or	r28, r24
     964:	c0 93 ab 21 	sts	0x21AB, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
     968:	80 e4       	ldi	r24, 0x40	; 64
     96a:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     96e:	84 e1       	ldi	r24, 0x14	; 20
     970:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = bankA_OUT;
     974:	80 91 ab 21 	lds	r24, 0x21AB
     978:	80 93 22 3e 	sts	0x3E22, r24
     97c:	0f c0       	rjmp	.+30     	; 0x99c <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
     97e:	80 91 31 3e 	lds	r24, 0x3E31
     982:	c8 2b       	or	r28, r24
     984:	c0 93 31 3e 	sts	0x3E31, r28
	
	SPIBuffer[0] = PS_WRITE;
     988:	80 e4       	ldi	r24, 0x40	; 64
     98a:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     98e:	85 e1       	ldi	r24, 0x15	; 21
     990:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = bankB_OUT; 
     994:	80 91 31 3e 	lds	r24, 0x3E31
     998:	80 93 22 3e 	sts	0x3E22, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     99c:	80 e0       	ldi	r24, 0x00	; 0
     99e:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     9a0:	20 e2       	ldi	r18, 0x20	; 32
     9a2:	3e e3       	ldi	r19, 0x3E	; 62
     9a4:	a0 ec       	ldi	r26, 0xC0	; 192
     9a6:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     9a8:	cc e2       	ldi	r28, 0x2C	; 44
     9aa:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     9ac:	f9 01       	movw	r30, r18
     9ae:	e8 0f       	add	r30, r24
     9b0:	f9 1f       	adc	r31, r25
     9b2:	40 81       	ld	r20, Z
     9b4:	13 96       	adiw	r26, 0x03	; 3
     9b6:	4c 93       	st	X, r20
     9b8:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     9ba:	12 96       	adiw	r26, 0x02	; 2
     9bc:	4c 91       	ld	r20, X
     9be:	12 97       	sbiw	r26, 0x02	; 2
     9c0:	44 23       	and	r20, r20
     9c2:	dc f7       	brge	.-10     	; 0x9ba <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
     9c4:	13 96       	adiw	r26, 0x03	; 3
     9c6:	4c 91       	ld	r20, X
     9c8:	13 97       	sbiw	r26, 0x03	; 3
     9ca:	48 83       	st	Y, r20
     9cc:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     9ce:	83 30       	cpi	r24, 0x03	; 3
     9d0:	91 05       	cpc	r25, r1
     9d2:	61 f7       	brne	.-40     	; 0x9ac <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     9d4:	80 e0       	ldi	r24, 0x00	; 0
     9d6:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	portExCS(FALSE);
     9da:	80 e0       	ldi	r24, 0x00	; 0
     9dc:	0e 94 3a 03 	call	0x674	; 0x674 <portExCS>
	SPIDisable();
     9e0:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <SPIDisable>
}
     9e4:	df 91       	pop	r29
     9e6:	cf 91       	pop	r28
     9e8:	08 95       	ret

000009ea <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     9ea:	cf 93       	push	r28
     9ec:	df 93       	push	r29
     9ee:	c8 2f       	mov	r28, r24
     9f0:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     9f2:	80 e0       	ldi	r24, 0x00	; 0
     9f4:	0e 94 ad 03 	call	0x75a	; 0x75a <SPIInit>
	SPICS(TRUE);
     9f8:	81 e0       	ldi	r24, 0x01	; 1
     9fa:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	portExCS(TRUE);
     9fe:	81 e0       	ldi	r24, 0x01	; 1
     a00:	0e 94 3a 03 	call	0x674	; 0x674 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
     a04:	dd 23       	and	r29, r29
     a06:	89 f0       	breq	.+34     	; 0xa2a <PortEx_DIRCLR+0x40>
     a08:	80 91 2f 3e 	lds	r24, 0x3E2F
     a0c:	80 95       	com	r24
     a0e:	c8 23       	and	r28, r24
     a10:	c0 93 2f 3e 	sts	0x3E2F, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     a14:	80 e4       	ldi	r24, 0x40	; 64
     a16:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     a1a:	10 92 21 3e 	sts	0x3E21, r1
		SPIBuffer[2] = ~bankA_DIR; 
     a1e:	80 91 2f 3e 	lds	r24, 0x3E2F
     a22:	80 95       	com	r24
     a24:	80 93 22 3e 	sts	0x3E22, r24
     a28:	11 c0       	rjmp	.+34     	; 0xa4c <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
     a2a:	80 91 45 3e 	lds	r24, 0x3E45
     a2e:	80 95       	com	r24
     a30:	c8 23       	and	r28, r24
     a32:	c0 93 45 3e 	sts	0x3E45, r28
	
	SPIBuffer[0] = PS_WRITE;
     a36:	80 e4       	ldi	r24, 0x40	; 64
     a38:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     a3c:	81 e0       	ldi	r24, 0x01	; 1
     a3e:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = ~bankB_DIR;
     a42:	80 91 45 3e 	lds	r24, 0x3E45
     a46:	80 95       	com	r24
     a48:	80 93 22 3e 	sts	0x3E22, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     a4c:	80 e0       	ldi	r24, 0x00	; 0
     a4e:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     a50:	20 e2       	ldi	r18, 0x20	; 32
     a52:	3e e3       	ldi	r19, 0x3E	; 62
     a54:	a0 ec       	ldi	r26, 0xC0	; 192
     a56:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     a58:	cc e2       	ldi	r28, 0x2C	; 44
     a5a:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     a5c:	f9 01       	movw	r30, r18
     a5e:	e8 0f       	add	r30, r24
     a60:	f9 1f       	adc	r31, r25
     a62:	40 81       	ld	r20, Z
     a64:	13 96       	adiw	r26, 0x03	; 3
     a66:	4c 93       	st	X, r20
     a68:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     a6a:	12 96       	adiw	r26, 0x02	; 2
     a6c:	4c 91       	ld	r20, X
     a6e:	12 97       	sbiw	r26, 0x02	; 2
     a70:	44 23       	and	r20, r20
     a72:	dc f7       	brge	.-10     	; 0xa6a <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
     a74:	13 96       	adiw	r26, 0x03	; 3
     a76:	4c 91       	ld	r20, X
     a78:	13 97       	sbiw	r26, 0x03	; 3
     a7a:	48 83       	st	Y, r20
     a7c:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     a7e:	83 30       	cpi	r24, 0x03	; 3
     a80:	91 05       	cpc	r25, r1
     a82:	61 f7       	brne	.-40     	; 0xa5c <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     a84:	80 e0       	ldi	r24, 0x00	; 0
     a86:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	portExCS(FALSE);
     a8a:	80 e0       	ldi	r24, 0x00	; 0
     a8c:	0e 94 3a 03 	call	0x674	; 0x674 <portExCS>
	SPIDisable();
     a90:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <SPIDisable>
}
     a94:	df 91       	pop	r29
     a96:	cf 91       	pop	r28
     a98:	08 95       	ret

00000a9a <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     a9a:	cf 93       	push	r28
     a9c:	df 93       	push	r29
     a9e:	c8 2f       	mov	r28, r24
     aa0:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
     aa2:	80 e0       	ldi	r24, 0x00	; 0
     aa4:	0e 94 ad 03 	call	0x75a	; 0x75a <SPIInit>
	SPICS(TRUE);
     aa8:	81 e0       	ldi	r24, 0x01	; 1
     aaa:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	portExCS(TRUE);
     aae:	81 e0       	ldi	r24, 0x01	; 1
     ab0:	0e 94 3a 03 	call	0x674	; 0x674 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
     ab4:	dd 23       	and	r29, r29
     ab6:	81 f0       	breq	.+32     	; 0xad8 <PortEx_DIRSET+0x3e>
     ab8:	80 91 2f 3e 	lds	r24, 0x3E2F
     abc:	c8 2b       	or	r28, r24
     abe:	c0 93 2f 3e 	sts	0x3E2F, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     ac2:	80 e4       	ldi	r24, 0x40	; 64
     ac4:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     ac8:	10 92 21 3e 	sts	0x3E21, r1
		SPIBuffer[2] = ~bankA_DIR; 
     acc:	80 91 2f 3e 	lds	r24, 0x3E2F
     ad0:	80 95       	com	r24
     ad2:	80 93 22 3e 	sts	0x3E22, r24
     ad6:	10 c0       	rjmp	.+32     	; 0xaf8 <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
     ad8:	80 91 45 3e 	lds	r24, 0x3E45
     adc:	c8 2b       	or	r28, r24
     ade:	c0 93 45 3e 	sts	0x3E45, r28
	
	SPIBuffer[0] = PS_WRITE;
     ae2:	80 e4       	ldi	r24, 0x40	; 64
     ae4:	80 93 20 3e 	sts	0x3E20, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     ae8:	81 e0       	ldi	r24, 0x01	; 1
     aea:	80 93 21 3e 	sts	0x3E21, r24
		SPIBuffer[2] = ~bankB_DIR;
     aee:	80 91 45 3e 	lds	r24, 0x3E45
     af2:	80 95       	com	r24
     af4:	80 93 22 3e 	sts	0x3E22, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     af8:	80 e0       	ldi	r24, 0x00	; 0
     afa:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     afc:	20 e2       	ldi	r18, 0x20	; 32
     afe:	3e e3       	ldi	r19, 0x3E	; 62
     b00:	a0 ec       	ldi	r26, 0xC0	; 192
     b02:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     b04:	cc e2       	ldi	r28, 0x2C	; 44
     b06:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     b08:	f9 01       	movw	r30, r18
     b0a:	e8 0f       	add	r30, r24
     b0c:	f9 1f       	adc	r31, r25
     b0e:	40 81       	ld	r20, Z
     b10:	13 96       	adiw	r26, 0x03	; 3
     b12:	4c 93       	st	X, r20
     b14:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
     b16:	12 96       	adiw	r26, 0x02	; 2
     b18:	4c 91       	ld	r20, X
     b1a:	12 97       	sbiw	r26, 0x02	; 2
     b1c:	44 23       	and	r20, r20
     b1e:	dc f7       	brge	.-10     	; 0xb16 <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     b20:	13 96       	adiw	r26, 0x03	; 3
     b22:	4c 91       	ld	r20, X
     b24:	13 97       	sbiw	r26, 0x03	; 3
     b26:	48 83       	st	Y, r20
     b28:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     b2a:	83 30       	cpi	r24, 0x03	; 3
     b2c:	91 05       	cpc	r25, r1
     b2e:	61 f7       	brne	.-40     	; 0xb08 <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
     b30:	80 e0       	ldi	r24, 0x00	; 0
     b32:	0e 94 3a 03 	call	0x674	; 0x674 <portExCS>
	SPICS(FALSE);
     b36:	80 e0       	ldi	r24, 0x00	; 0
     b38:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	SPIDisable();
     b3c:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <SPIDisable>


}
     b40:	df 91       	pop	r29
     b42:	cf 91       	pop	r28
     b44:	08 95       	ret

00000b46 <ADCPower>:
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
	else PORTC.OUTSET = PIN1_bm;
}

void ADCPower(uint8_t on) {
     b46:	0f 93       	push	r16
     b48:	1f 93       	push	r17
     b4a:	cf 93       	push	r28
     b4c:	df 93       	push	r29
	
	if (on) {
     b4e:	88 23       	and	r24, r24
     b50:	09 f4       	brne	.+2      	; 0xb54 <ADCPower+0xe>
     b52:	46 c0       	rjmp	.+140    	; 0xbe0 <ADCPower+0x9a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     b54:	00 e0       	ldi	r16, 0x00	; 0
     b56:	16 e0       	ldi	r17, 0x06	; 6
     b58:	8e ed       	ldi	r24, 0xDE	; 222
     b5a:	d8 01       	movw	r26, r16
     b5c:	11 96       	adiw	r26, 0x01	; 1
     b5e:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     b60:	c0 e2       	ldi	r28, 0x20	; 32
     b62:	d6 e0       	ldi	r29, 0x06	; 6
     b64:	4e e0       	ldi	r20, 0x0E	; 14
     b66:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     b68:	e0 e4       	ldi	r30, 0x40	; 64
     b6a:	f6 e0       	ldi	r31, 0x06	; 6
     b6c:	63 e0       	ldi	r22, 0x03	; 3
     b6e:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     b70:	80 e8       	ldi	r24, 0x80	; 128
     b72:	96 e0       	ldi	r25, 0x06	; 6
     b74:	50 e1       	ldi	r21, 0x10	; 16
     b76:	dc 01       	movw	r26, r24
     b78:	11 96       	adiw	r26, 0x01	; 1
     b7a:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     b7c:	20 ea       	ldi	r18, 0xA0	; 160
     b7e:	36 e0       	ldi	r19, 0x06	; 6
     b80:	d9 01       	movw	r26, r18
     b82:	11 96       	adiw	r26, 0x01	; 1
     b84:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     b86:	7e e9       	ldi	r23, 0x9E	; 158
     b88:	d8 01       	movw	r26, r16
     b8a:	15 96       	adiw	r26, 0x05	; 5
     b8c:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     b8e:	78 e0       	ldi	r23, 0x08	; 8
     b90:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     b92:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     b94:	ec 01       	movw	r28, r24
     b96:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     b98:	d9 01       	movw	r26, r18
     b9a:	15 96       	adiw	r26, 0x05	; 5
     b9c:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
     b9e:	10 92 30 3e 	sts	0x3E30, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     ba2:	8f ef       	ldi	r24, 0xFF	; 255
     ba4:	93 ec       	ldi	r25, 0xC3	; 195
     ba6:	a9 e0       	ldi	r26, 0x09	; 9
     ba8:	81 50       	subi	r24, 0x01	; 1
     baa:	90 40       	sbci	r25, 0x00	; 0
     bac:	a0 40       	sbci	r26, 0x00	; 0
     bae:	e1 f7       	brne	.-8      	; 0xba8 <ADCPower+0x62>
     bb0:	00 c0       	rjmp	.+0      	; 0xbb2 <ADCPower+0x6c>
     bb2:	00 00       	nop
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     bb4:	80 e4       	ldi	r24, 0x40	; 64
     bb6:	82 83       	std	Z+2, r24	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     bb8:	10 92 31 3e 	sts	0x3E31, r1
     bbc:	10 92 45 3e 	sts	0x3E45, r1
     bc0:	10 92 ab 21 	sts	0x21AB, r1
     bc4:	10 92 2f 3e 	sts	0x3E2F, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
     bc8:	8f ef       	ldi	r24, 0xFF	; 255
     bca:	61 e0       	ldi	r22, 0x01	; 1
     bcc:	0e 94 4d 05 	call	0xa9a	; 0xa9a <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     bd0:	8f ef       	ldi	r24, 0xFF	; 255
     bd2:	61 e0       	ldi	r22, 0x01	; 1
     bd4:	0e 94 a0 04 	call	0x940	; 0x940 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     bd8:	8f ef       	ldi	r24, 0xFF	; 255
     bda:	0e 94 e6 03 	call	0x7cc	; 0x7cc <set_filter>
     bde:	32 c0       	rjmp	.+100    	; 0xc44 <ADCPower+0xfe>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     be0:	00 e0       	ldi	r16, 0x00	; 0
     be2:	16 e0       	ldi	r17, 0x06	; 6
     be4:	7e ed       	ldi	r23, 0xDE	; 222
     be6:	d8 01       	movw	r26, r16
     be8:	16 96       	adiw	r26, 0x06	; 6
     bea:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     bec:	a0 e2       	ldi	r26, 0x20	; 32
     bee:	b6 e0       	ldi	r27, 0x06	; 6
     bf0:	4e e0       	ldi	r20, 0x0E	; 14
     bf2:	16 96       	adiw	r26, 0x06	; 6
     bf4:	4c 93       	st	X, r20
     bf6:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     bf8:	20 e4       	ldi	r18, 0x40	; 64
     bfa:	36 e0       	ldi	r19, 0x06	; 6
     bfc:	63 e0       	ldi	r22, 0x03	; 3
     bfe:	e9 01       	movw	r28, r18
     c00:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     c02:	c0 e8       	ldi	r28, 0x80	; 128
     c04:	d6 e0       	ldi	r29, 0x06	; 6
     c06:	50 e1       	ldi	r21, 0x10	; 16
     c08:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     c0a:	80 ea       	ldi	r24, 0xA0	; 160
     c0c:	96 e0       	ldi	r25, 0x06	; 6
     c0e:	fc 01       	movw	r30, r24
     c10:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     c12:	f8 01       	movw	r30, r16
     c14:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     c16:	12 96       	adiw	r26, 0x02	; 2
     c18:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     c1a:	d9 01       	movw	r26, r18
     c1c:	12 96       	adiw	r26, 0x02	; 2
     c1e:	6c 93       	st	X, r22
     c20:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
     c22:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     c24:	ec 01       	movw	r28, r24
     c26:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     c28:	80 e4       	ldi	r24, 0x40	; 64
     c2a:	12 96       	adiw	r26, 0x02	; 2
     c2c:	8c 93       	st	X, r24
     c2e:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     c30:	10 92 31 3e 	sts	0x3E31, r1
     c34:	10 92 45 3e 	sts	0x3E45, r1
     c38:	10 92 ab 21 	sts	0x21AB, r1
     c3c:	10 92 2f 3e 	sts	0x3E2F, r1
		channelStatus = 0x00;
     c40:	10 92 30 3e 	sts	0x3E30, r1
		
	}
}
     c44:	df 91       	pop	r29
     c46:	cf 91       	pop	r28
     c48:	1f 91       	pop	r17
     c4a:	0f 91       	pop	r16
     c4c:	08 95       	ret

00000c4e <DeciToString>:
	PORTC.OUTCLR = PIN4_bm;
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;

}

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
     c4e:	2f 92       	push	r2
     c50:	3f 92       	push	r3
     c52:	4f 92       	push	r4
     c54:	5f 92       	push	r5
     c56:	6f 92       	push	r6
     c58:	7f 92       	push	r7
     c5a:	8f 92       	push	r8
     c5c:	9f 92       	push	r9
     c5e:	af 92       	push	r10
     c60:	bf 92       	push	r11
     c62:	cf 92       	push	r12
     c64:	df 92       	push	r13
     c66:	ef 92       	push	r14
     c68:	ff 92       	push	r15
     c6a:	0f 93       	push	r16
     c6c:	1f 93       	push	r17
     c6e:	cf 93       	push	r28
     c70:	df 93       	push	r29
     c72:	cd b7       	in	r28, 0x3d	; 61
     c74:	de b7       	in	r29, 0x3e	; 62
     c76:	64 97       	sbiw	r28, 0x14	; 20
     c78:	cd bf       	out	0x3d, r28	; 61
     c7a:	de bf       	out	0x3e, r29	; 62
     c7c:	2a 01       	movw	r4, r20
     c7e:	3b 01       	movw	r6, r22
     c80:	89 01       	movw	r16, r18
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
     c82:	f9 01       	movw	r30, r18
     c84:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
     c86:	41 15       	cp	r20, r1
     c88:	51 05       	cpc	r21, r1
     c8a:	61 05       	cpc	r22, r1
     c8c:	71 05       	cpc	r23, r1
     c8e:	09 f4       	brne	.+2      	; 0xc92 <DeciToString+0x44>
     c90:	4d c0       	rjmp	.+154    	; 0xd2c <DeciToString+0xde>
     c92:	88 2e       	mov	r8, r24
     c94:	99 2e       	mov	r9, r25
     c96:	cc 24       	eor	r12, r12
     c98:	dd 24       	eor	r13, r13
     c9a:	76 01       	movw	r14, r12
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
     c9c:	5e 01       	movw	r10, r28
     c9e:	08 94       	sec
     ca0:	a1 1c       	adc	r10, r1
     ca2:	b1 1c       	adc	r11, r1
     ca4:	0f 2e       	mov	r0, r31
     ca6:	f0 e0       	ldi	r31, 0x00	; 0
     ca8:	2f 2e       	mov	r2, r31
     caa:	f0 e2       	ldi	r31, 0x20	; 32
     cac:	3f 2e       	mov	r3, r31
     cae:	f0 2d       	mov	r31, r0
     cb0:	f4 01       	movw	r30, r8
     cb2:	81 91       	ld	r24, Z+
     cb4:	91 91       	ld	r25, Z+
     cb6:	a1 91       	ld	r26, Z+
     cb8:	b1 91       	ld	r27, Z+
     cba:	4f 01       	movw	r8, r30
     cbc:	2d b7       	in	r18, 0x3d	; 61
     cbe:	3e b7       	in	r19, 0x3e	; 62
     cc0:	28 50       	subi	r18, 0x08	; 8
     cc2:	30 40       	sbci	r19, 0x00	; 0
     cc4:	2d bf       	out	0x3d, r18	; 61
     cc6:	3e bf       	out	0x3e, r19	; 62
     cc8:	2f 5f       	subi	r18, 0xFF	; 255
     cca:	3f 4f       	sbci	r19, 0xFF	; 255
     ccc:	ed b7       	in	r30, 0x3d	; 61
     cce:	fe b7       	in	r31, 0x3e	; 62
     cd0:	a1 82       	std	Z+1, r10	; 0x01
     cd2:	b2 82       	std	Z+2, r11	; 0x02
     cd4:	f9 01       	movw	r30, r18
     cd6:	22 82       	std	Z+2, r2	; 0x02
     cd8:	33 82       	std	Z+3, r3	; 0x03
     cda:	84 83       	std	Z+4, r24	; 0x04
     cdc:	95 83       	std	Z+5, r25	; 0x05
     cde:	a6 83       	std	Z+6, r26	; 0x06
     ce0:	b7 83       	std	Z+7, r27	; 0x07
     ce2:	0e 94 ea 36 	call	0x6dd4	; 0x6dd4 <sprintf>
		strcat(ReturnString,b);
     ce6:	2d b7       	in	r18, 0x3d	; 61
     ce8:	3e b7       	in	r19, 0x3e	; 62
     cea:	28 5f       	subi	r18, 0xF8	; 248
     cec:	3f 4f       	sbci	r19, 0xFF	; 255
     cee:	2d bf       	out	0x3d, r18	; 61
     cf0:	3e bf       	out	0x3e, r19	; 62
     cf2:	c8 01       	movw	r24, r16
     cf4:	b5 01       	movw	r22, r10
     cf6:	0e 94 ac 36 	call	0x6d58	; 0x6d58 <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
     cfa:	a0 2f       	mov	r26, r16
     cfc:	b1 2f       	mov	r27, r17
     cfe:	fd 01       	movw	r30, r26
     d00:	01 90       	ld	r0, Z+
     d02:	00 20       	and	r0, r0
     d04:	e9 f7       	brne	.-6      	; 0xd00 <DeciToString+0xb2>
     d06:	31 97       	sbiw	r30, 0x01	; 1
     d08:	ea 1b       	sub	r30, r26
     d0a:	fb 0b       	sbc	r31, r27
     d0c:	e0 0f       	add	r30, r16
     d0e:	f1 1f       	adc	r31, r17
     d10:	8a e0       	ldi	r24, 0x0A	; 10
     d12:	90 e0       	ldi	r25, 0x00	; 0
     d14:	80 83       	st	Z, r24
     d16:	91 83       	std	Z+1, r25	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
     d18:	08 94       	sec
     d1a:	c1 1c       	adc	r12, r1
     d1c:	d1 1c       	adc	r13, r1
     d1e:	e1 1c       	adc	r14, r1
     d20:	f1 1c       	adc	r15, r1
     d22:	c4 14       	cp	r12, r4
     d24:	d5 04       	cpc	r13, r5
     d26:	e6 04       	cpc	r14, r6
     d28:	f7 04       	cpc	r15, r7
     d2a:	11 f6       	brne	.-124    	; 0xcb0 <DeciToString+0x62>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}
}
     d2c:	64 96       	adiw	r28, 0x14	; 20
     d2e:	cd bf       	out	0x3d, r28	; 61
     d30:	de bf       	out	0x3e, r29	; 62
     d32:	df 91       	pop	r29
     d34:	cf 91       	pop	r28
     d36:	1f 91       	pop	r17
     d38:	0f 91       	pop	r16
     d3a:	ff 90       	pop	r15
     d3c:	ef 90       	pop	r14
     d3e:	df 90       	pop	r13
     d40:	cf 90       	pop	r12
     d42:	bf 90       	pop	r11
     d44:	af 90       	pop	r10
     d46:	9f 90       	pop	r9
     d48:	8f 90       	pop	r8
     d4a:	7f 90       	pop	r7
     d4c:	6f 90       	pop	r6
     d4e:	5f 90       	pop	r5
     d50:	4f 90       	pop	r4
     d52:	3f 90       	pop	r3
     d54:	2f 90       	pop	r2
     d56:	08 95       	ret

00000d58 <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
     d58:	e0 ec       	ldi	r30, 0xC0	; 192
     d5a:	f8 e0       	ldi	r31, 0x08	; 8
     d5c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
     d5e:	82 81       	ldd	r24, Z+2	; 0x02
     d60:	88 23       	and	r24, r24
     d62:	ec f7       	brge	.-6      	; 0xd5e <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
     d64:	e0 ec       	ldi	r30, 0xC0	; 192
     d66:	f8 e0       	ldi	r31, 0x08	; 8
     d68:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
     d6a:	08 95       	ret

00000d6c <main>:
 * Created: 3/8/2014 8:19:11 PM
 *  Author: VLAD
 */ 
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     d6c:	cf 93       	push	r28
     d6e:	df 93       	push	r29
		FRAMReadBuffer[200+i] = i*2;
	}
	for(int i=0; i<200; i++){
		FRAMReadBuffer[400+i] = i*3;
	}
	for(int i=0; i<200; i++){
     d70:	cc ea       	ldi	r28, 0xAC	; 172
     d72:	d1 e2       	ldi	r29, 0x21	; 33
 * Created: 3/8/2014 8:19:11 PM
 *  Author: VLAD
 */ 
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     d74:	fe 01       	movw	r30, r28
     d76:	80 e0       	ldi	r24, 0x00	; 0
	
	for(int i=0; i<200; i++){
		FRAMReadBuffer[i] = i;
     d78:	81 93       	st	Z+, r24
     d7a:	8f 5f       	subi	r24, 0xFF	; 255
 */ 
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
	
	for(int i=0; i<200; i++){
     d7c:	88 3c       	cpi	r24, 0xC8	; 200
     d7e:	e1 f7       	brne	.-8      	; 0xd78 <main+0xc>
     d80:	e4 e7       	ldi	r30, 0x74	; 116
     d82:	f2 e2       	ldi	r31, 0x22	; 34
 * Created: 3/8/2014 8:19:11 PM
 *  Author: VLAD
 */ 
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     d84:	8c e3       	ldi	r24, 0x3C	; 60
     d86:	93 e2       	ldi	r25, 0x23	; 35
     d88:	20 e0       	ldi	r18, 0x00	; 0
	
	for(int i=0; i<200; i++){
		FRAMReadBuffer[i] = i;
	}
	for(int i=0; i<200; i++){
		FRAMReadBuffer[200+i] = i*2;
     d8a:	21 93       	st	Z+, r18
     d8c:	2e 5f       	subi	r18, 0xFE	; 254
int main(){
	
	for(int i=0; i<200; i++){
		FRAMReadBuffer[i] = i;
	}
	for(int i=0; i<200; i++){
     d8e:	e8 17       	cp	r30, r24
     d90:	f9 07       	cpc	r31, r25
     d92:	d9 f7       	brne	.-10     	; 0xd8a <main+0x1e>
     d94:	ec e3       	ldi	r30, 0x3C	; 60
     d96:	f3 e2       	ldi	r31, 0x23	; 35
     d98:	80 e0       	ldi	r24, 0x00	; 0
		FRAMReadBuffer[200+i] = i*2;
	}
	for(int i=0; i<200; i++){
		FRAMReadBuffer[400+i] = i*3;
     d9a:	81 93       	st	Z+, r24
     d9c:	8d 5f       	subi	r24, 0xFD	; 253
		FRAMReadBuffer[i] = i;
	}
	for(int i=0; i<200; i++){
		FRAMReadBuffer[200+i] = i*2;
	}
	for(int i=0; i<200; i++){
     d9e:	88 35       	cpi	r24, 0x58	; 88
     da0:	e1 f7       	brne	.-8      	; 0xd9a <main+0x2e>
     da2:	e4 e0       	ldi	r30, 0x04	; 4
     da4:	f4 e2       	ldi	r31, 0x24	; 36
 * Created: 3/8/2014 8:19:11 PM
 *  Author: VLAD
 */ 
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     da6:	8c ec       	ldi	r24, 0xCC	; 204
     da8:	94 e2       	ldi	r25, 0x24	; 36
     daa:	20 e0       	ldi	r18, 0x00	; 0
	}
	for(int i=0; i<200; i++){
		FRAMReadBuffer[400+i] = i*3;
	}
	for(int i=0; i<200; i++){
		FRAMReadBuffer[600+i] = i*4;
     dac:	21 93       	st	Z+, r18
     dae:	2c 5f       	subi	r18, 0xFC	; 252
		FRAMReadBuffer[200+i] = i*2;
	}
	for(int i=0; i<200; i++){
		FRAMReadBuffer[400+i] = i*3;
	}
	for(int i=0; i<200; i++){
     db0:	e8 17       	cp	r30, r24
     db2:	f9 07       	cpc	r31, r25
     db4:	d9 f7       	brne	.-10     	; 0xdac <main+0x40>
     db6:	ec ec       	ldi	r30, 0xCC	; 204
     db8:	f4 e2       	ldi	r31, 0x24	; 36
     dba:	80 e0       	ldi	r24, 0x00	; 0
		FRAMReadBuffer[600+i] = i*4;
	}
	for(int i=0; i<200; i++){
		FRAMReadBuffer[800+i] = i*5;
     dbc:	81 93       	st	Z+, r24
     dbe:	8b 5f       	subi	r24, 0xFB	; 251
		FRAMReadBuffer[400+i] = i*3;
	}
	for(int i=0; i<200; i++){
		FRAMReadBuffer[600+i] = i*4;
	}
	for(int i=0; i<200; i++){
     dc0:	88 3e       	cpi	r24, 0xE8	; 232
     dc2:	e1 f7       	brne	.-8      	; 0xdbc <main+0x50>
		FRAMReadBuffer[800+i] = i*5;
	}
	writeFRAM(FRAMReadBuffer, 1000);
     dc4:	8c ea       	ldi	r24, 0xAC	; 172
     dc6:	91 e2       	ldi	r25, 0x21	; 33
     dc8:	68 ee       	ldi	r22, 0xE8	; 232
     dca:	73 e0       	ldi	r23, 0x03	; 3
     dcc:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
 * Created: 3/8/2014 8:19:11 PM
 *  Author: VLAD
 */ 
#include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     dd0:	84 e9       	ldi	r24, 0x94	; 148
     dd2:	95 e2       	ldi	r25, 0x25	; 37
	for(int i=0; i<200; i++){
		FRAMReadBuffer[800+i] = i*5;
	}
	writeFRAM(FRAMReadBuffer, 1000);
	for(int i=0; i<1000; i++){
		FRAMReadBuffer[i] = 0;
     dd4:	19 92       	st	Y+, r1
	}
	for(int i=0; i<200; i++){
		FRAMReadBuffer[800+i] = i*5;
	}
	writeFRAM(FRAMReadBuffer, 1000);
	for(int i=0; i<1000; i++){
     dd6:	c8 17       	cp	r28, r24
     dd8:	d9 07       	cpc	r29, r25
     dda:	e1 f7       	brne	.-8      	; 0xdd4 <main+0x68>
		FRAMReadBuffer[i] = 0;
	}
	nop();
     ddc:	00 00       	nop
	FRAMAddress = 0;
     dde:	10 92 1d 3e 	sts	0x3E1D, r1
     de2:	10 92 1e 3e 	sts	0x3E1E, r1
	readFRAM(1000);
     de6:	88 ee       	ldi	r24, 0xE8	; 232
     de8:	93 e0       	ldi	r25, 0x03	; 3
     dea:	0e 94 c8 01 	call	0x390	; 0x390 <readFRAM>
	nop();
     dee:	00 00       	nop
     df0:	80 e0       	ldi	r24, 0x00	; 0
     df2:	90 e0       	ldi	r25, 0x00	; 0
     df4:	df 91       	pop	r29
     df6:	cf 91       	pop	r28
     df8:	08 95       	ret

00000dfa <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     dfa:	0f 93       	push	r16
     dfc:	1f 93       	push	r17
     dfe:	cf 93       	push	r28
     e00:	8c 01       	movw	r16, r24
	moteID = 1;
     e02:	c1 e0       	ldi	r28, 0x01	; 1
     e04:	c0 93 44 3e 	sts	0x3E44, r28
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     e08:	83 e0       	ldi	r24, 0x03	; 3
     e0a:	80 93 1f 3e 	sts	0x3E1F, r24
	chb_init();
     e0e:	0e 94 b7 16 	call	0x2d6e	; 0x2d6e <chb_init>
	chb_set_short_addr(moteID);
     e12:	80 91 44 3e 	lds	r24, 0x3E44
     e16:	90 e0       	ldi	r25, 0x00	; 0
     e18:	0e 94 da 18 	call	0x31b4	; 0x31b4 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     e1c:	88 ec       	ldi	r24, 0xC8	; 200
     e1e:	e0 e8       	ldi	r30, 0x80	; 128
     e20:	f1 e0       	ldi	r31, 0x01	; 1
     e22:	81 83       	std	Z+1, r24	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     e24:	e0 e4       	ldi	r30, 0x40	; 64
     e26:	f9 e0       	ldi	r31, 0x09	; 9
     e28:	89 e0       	ldi	r24, 0x09	; 9
     e2a:	80 83       	st	Z, r24
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     e2c:	82 e0       	ldi	r24, 0x02	; 2
     e2e:	86 83       	std	Z+6, r24	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     e30:	24 ef       	ldi	r18, 0xF4	; 244
     e32:	31 e0       	ldi	r19, 0x01	; 1
     e34:	02 9f       	mul	r16, r18
     e36:	c0 01       	movw	r24, r0
     e38:	03 9f       	mul	r16, r19
     e3a:	90 0d       	add	r25, r0
     e3c:	12 9f       	mul	r17, r18
     e3e:	90 0d       	add	r25, r0
     e40:	11 24       	eor	r1, r1
     e42:	86 a3       	lds	r24, 0x56
     e44:	97 a3       	lds	r25, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     e46:	e0 e4       	ldi	r30, 0x40	; 64
     e48:	f8 e0       	ldi	r31, 0x08	; 8
     e4a:	80 e0       	ldi	r24, 0x00	; 0
     e4c:	9a ef       	ldi	r25, 0xFA	; 250
     e4e:	86 a3       	lds	r24, 0x56
     e50:	97 a3       	lds	r25, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     e52:	c6 83       	std	Z+6, r28	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     e54:	c0 83       	st	Z, r28
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     e56:	e0 ea       	ldi	r30, 0xA0	; 160
     e58:	f0 e0       	ldi	r31, 0x00	; 0
     e5a:	82 81       	ldd	r24, Z+2	; 0x02
     e5c:	87 60       	ori	r24, 0x07	; 7
     e5e:	82 83       	std	Z+2, r24	; 0x02
	sei(); //  Enable global interrupts
     e60:	78 94       	sei
}
     e62:	cf 91       	pop	r28
     e64:	1f 91       	pop	r17
     e66:	0f 91       	pop	r16
     e68:	08 95       	ret

00000e6a <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     e6a:	78 94       	sei
     e6c:	1f 92       	push	r1
     e6e:	0f 92       	push	r0
     e70:	0f b6       	in	r0, 0x3f	; 63
     e72:	0f 92       	push	r0
     e74:	0b b6       	in	r0, 0x3b	; 59
     e76:	0f 92       	push	r0
     e78:	11 24       	eor	r1, r1
     e7a:	ef 92       	push	r14
     e7c:	ff 92       	push	r15
     e7e:	0f 93       	push	r16
     e80:	1f 93       	push	r17
     e82:	2f 93       	push	r18
     e84:	3f 93       	push	r19
     e86:	4f 93       	push	r20
     e88:	5f 93       	push	r21
     e8a:	6f 93       	push	r22
     e8c:	7f 93       	push	r23
     e8e:	8f 93       	push	r24
     e90:	9f 93       	push	r25
     e92:	af 93       	push	r26
     e94:	bf 93       	push	r27
     e96:	ef 93       	push	r30
     e98:	ff 93       	push	r31
     e9a:	cf 93       	push	r28
     e9c:	df 93       	push	r29
     e9e:	cd b7       	in	r28, 0x3d	; 61
     ea0:	de b7       	in	r29, 0x3e	; 62
     ea2:	28 97       	sbiw	r28, 0x08	; 8
     ea4:	cd bf       	out	0x3d, r28	; 61
     ea6:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     ea8:	10 92 40 08 	sts	0x0840, r1
	TCD1.CTRLA = 0x00;
     eac:	10 92 40 09 	sts	0x0940, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
     eb0:	82 e0       	ldi	r24, 0x02	; 2
     eb2:	80 93 1f 3e 	sts	0x3E1F, r24
	char message[8];
	strcpy(message,"reset");
     eb6:	de 01       	movw	r26, r28
     eb8:	11 96       	adiw	r26, 0x01	; 1
     eba:	e4 e0       	ldi	r30, 0x04	; 4
     ebc:	f0 e2       	ldi	r31, 0x20	; 32
     ebe:	86 e0       	ldi	r24, 0x06	; 6
     ec0:	01 90       	ld	r0, Z+
     ec2:	0d 92       	st	X+, r0
     ec4:	81 50       	subi	r24, 0x01	; 1
     ec6:	e1 f7       	brne	.-8      	; 0xec0 <__vector_83+0x56>
	itoa((int)(moteID),buff,10);
     ec8:	05 ea       	ldi	r16, 0xA5	; 165
     eca:	10 e5       	ldi	r17, 0x50	; 80
     ecc:	80 91 44 3e 	lds	r24, 0x3E44
     ed0:	90 e0       	ldi	r25, 0x00	; 0
     ed2:	b8 01       	movw	r22, r16
     ed4:	4a e0       	ldi	r20, 0x0A	; 10
     ed6:	50 e0       	ldi	r21, 0x00	; 0
     ed8:	0e 94 b7 36 	call	0x6d6e	; 0x6d6e <itoa>
	strcat(message,buff);
     edc:	7e 01       	movw	r14, r28
     ede:	08 94       	sec
     ee0:	e1 1c       	adc	r14, r1
     ee2:	f1 1c       	adc	r15, r1
     ee4:	c7 01       	movw	r24, r14
     ee6:	b8 01       	movw	r22, r16
     ee8:	0e 94 ac 36 	call	0x6d58	; 0x6d58 <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
     eec:	0e 94 b9 0a 	call	0x1572	; 0x1572 <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
     ef0:	f7 01       	movw	r30, r14
     ef2:	01 90       	ld	r0, Z+
     ef4:	00 20       	and	r0, r0
     ef6:	e9 f7       	brne	.-6      	; 0xef2 <__vector_83+0x88>
     ef8:	31 97       	sbiw	r30, 0x01	; 1
     efa:	ee 19       	sub	r30, r14
     efc:	ff 09       	sbc	r31, r15
     efe:	9f 01       	movw	r18, r30
     f00:	40 e0       	ldi	r20, 0x00	; 0
     f02:	50 e0       	ldi	r21, 0x00	; 0
     f04:	80 e0       	ldi	r24, 0x00	; 0
     f06:	90 e0       	ldi	r25, 0x00	; 0
     f08:	b7 01       	movw	r22, r14
     f0a:	0e 94 db 16 	call	0x2db6	; 0x2db6 <chb_write>
}	
     f0e:	28 96       	adiw	r28, 0x08	; 8
     f10:	cd bf       	out	0x3d, r28	; 61
     f12:	de bf       	out	0x3e, r29	; 62
     f14:	df 91       	pop	r29
     f16:	cf 91       	pop	r28
     f18:	ff 91       	pop	r31
     f1a:	ef 91       	pop	r30
     f1c:	bf 91       	pop	r27
     f1e:	af 91       	pop	r26
     f20:	9f 91       	pop	r25
     f22:	8f 91       	pop	r24
     f24:	7f 91       	pop	r23
     f26:	6f 91       	pop	r22
     f28:	5f 91       	pop	r21
     f2a:	4f 91       	pop	r20
     f2c:	3f 91       	pop	r19
     f2e:	2f 91       	pop	r18
     f30:	1f 91       	pop	r17
     f32:	0f 91       	pop	r16
     f34:	ff 90       	pop	r15
     f36:	ef 90       	pop	r14
     f38:	0f 90       	pop	r0
     f3a:	0b be       	out	0x3b, r0	; 59
     f3c:	0f 90       	pop	r0
     f3e:	0f be       	out	0x3f, r0	; 63
     f40:	0f 90       	pop	r0
     f42:	1f 90       	pop	r1
     f44:	18 95       	reti

00000f46 <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     f46:	4f 92       	push	r4
     f48:	5f 92       	push	r5
     f4a:	6f 92       	push	r6
     f4c:	7f 92       	push	r7
     f4e:	8f 92       	push	r8
     f50:	9f 92       	push	r9
     f52:	af 92       	push	r10
     f54:	bf 92       	push	r11
     f56:	ef 92       	push	r14
     f58:	ff 92       	push	r15
     f5a:	0f 93       	push	r16
     f5c:	1f 93       	push	r17
     f5e:	cf 93       	push	r28
     f60:	df 93       	push	r29
     f62:	cd b7       	in	r28, 0x3d	; 61
     f64:	de b7       	in	r29, 0x3e	; 62
     f66:	2b 97       	sbiw	r28, 0x0b	; 11
     f68:	cd bf       	out	0x3d, r28	; 61
     f6a:	de bf       	out	0x3e, r29	; 62
     f6c:	8e 83       	std	Y+6, r24	; 0x06
     f6e:	9f 83       	std	Y+7, r25	; 0x07
     f70:	68 87       	std	Y+8, r22	; 0x08
     f72:	79 87       	std	Y+9, r23	; 0x09
     f74:	4a 87       	std	Y+10, r20	; 0x0a
     f76:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
     f78:	81 e0       	ldi	r24, 0x01	; 1
     f7a:	0e 94 a3 05 	call	0xb46	; 0xb46 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     f7e:	80 e0       	ldi	r24, 0x00	; 0
     f80:	92 e0       	ldi	r25, 0x02	; 2
     f82:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     f86:	00 e0       	ldi	r16, 0x00	; 0
     f88:	12 e0       	ldi	r17, 0x02	; 2
     f8a:	d8 01       	movw	r26, r16
     f8c:	11 96       	adiw	r26, 0x01	; 1
     f8e:	8c 91       	ld	r24, X
     f90:	11 97       	sbiw	r26, 0x01	; 1
     f92:	89 7e       	andi	r24, 0xE9	; 233
     f94:	11 96       	adiw	r26, 0x01	; 1
     f96:	8c 93       	st	X, r24
     f98:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     f9a:	14 96       	adiw	r26, 0x04	; 4
     f9c:	8c 91       	ld	r24, X
     f9e:	14 97       	sbiw	r26, 0x04	; 4
     fa0:	88 7f       	andi	r24, 0xF8	; 248
     fa2:	83 60       	ori	r24, 0x03	; 3
     fa4:	14 96       	adiw	r26, 0x04	; 4
     fa6:	8c 93       	st	X, r24
     fa8:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     faa:	12 96       	adiw	r26, 0x02	; 2
     fac:	8c 91       	ld	r24, X
     fae:	12 97       	sbiw	r26, 0x02	; 2
     fb0:	8f 7c       	andi	r24, 0xCF	; 207
     fb2:	12 96       	adiw	r26, 0x02	; 2
     fb4:	8c 93       	st	X, r24
     fb6:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     fb8:	0f 2e       	mov	r0, r31
     fba:	f0 e2       	ldi	r31, 0x20	; 32
     fbc:	ef 2e       	mov	r14, r31
     fbe:	f2 e0       	ldi	r31, 0x02	; 2
     fc0:	ff 2e       	mov	r15, r31
     fc2:	f0 2d       	mov	r31, r0
     fc4:	f7 01       	movw	r30, r14
     fc6:	80 81       	ld	r24, Z
     fc8:	80 7e       	andi	r24, 0xE0	; 224
     fca:	81 60       	ori	r24, 0x01	; 1
     fcc:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     fce:	89 e0       	ldi	r24, 0x09	; 9
     fd0:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
     fd2:	8c 91       	ld	r24, X
     fd4:	81 60       	ori	r24, 0x01	; 1
     fd6:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     fd8:	80 e0       	ldi	r24, 0x00	; 0
     fda:	92 e0       	ldi	r25, 0x02	; 2
     fdc:	0e 94 1f 16 	call	0x2c3e	; 0x2c3e <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     fe0:	80 e0       	ldi	r24, 0x00	; 0
     fe2:	92 e0       	ldi	r25, 0x02	; 2
     fe4:	60 e2       	ldi	r22, 0x20	; 32
     fe6:	72 e0       	ldi	r23, 0x02	; 2
     fe8:	40 e0       	ldi	r20, 0x00	; 0
     fea:	0e 94 29 16 	call	0x2c52	; 0x2c52 <ADC_Offset_Get_Unsigned>
     fee:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
     ff0:	d8 01       	movw	r26, r16
     ff2:	8c 91       	ld	r24, X
     ff4:	8e 7f       	andi	r24, 0xFE	; 254
     ff6:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     ff8:	f7 01       	movw	r30, r14
     ffa:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     ffc:	13 96       	adiw	r26, 0x03	; 3
     ffe:	8c 91       	ld	r24, X
    1000:	13 97       	sbiw	r26, 0x03	; 3
    1002:	8f 73       	andi	r24, 0x3F	; 63
    1004:	13 96       	adiw	r26, 0x03	; 3
    1006:	8c 93       	st	X, r24
    1008:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
    100a:	8c 91       	ld	r24, X
    100c:	81 60       	ori	r24, 0x01	; 1
    100e:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    1010:	80 e0       	ldi	r24, 0x00	; 0
    1012:	92 e0       	ldi	r25, 0x02	; 2
    1014:	0e 94 1f 16 	call	0x2c3e	; 0x2c3e <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
    1018:	d8 01       	movw	r26, r16
    101a:	11 96       	adiw	r26, 0x01	; 1
    101c:	8c 91       	ld	r24, X
    101e:	11 97       	sbiw	r26, 0x01	; 1
    1020:	88 60       	ori	r24, 0x08	; 8
    1022:	11 96       	adiw	r26, 0x01	; 1
    1024:	8c 93       	st	X, r24
    1026:	ee 24       	eor	r14, r14
    1028:	ff 24       	eor	r15, r15
    102a:	68 94       	set
    102c:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    102e:	44 24       	eor	r4, r4
    1030:	55 24       	eor	r5, r5
    1032:	32 01       	movw	r6, r4
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
    1034:	20 e0       	ldi	r18, 0x00	; 0
    1036:	30 e1       	ldi	r19, 0x10	; 16
    1038:	40 e0       	ldi	r20, 0x00	; 0
    103a:	50 e0       	ldi	r21, 0x00	; 0
    103c:	2a 83       	std	Y+2, r18	; 0x02
    103e:	3b 83       	std	Y+3, r19	; 0x03
    1040:	4c 83       	std	Y+4, r20	; 0x04
    1042:	5d 83       	std	Y+5, r21	; 0x05
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    1044:	88 24       	eor	r8, r8
    1046:	99 24       	eor	r9, r9
    1048:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
    104a:	00 e2       	ldi	r16, 0x20	; 32
    104c:	12 e0       	ldi	r17, 0x02	; 2
    104e:	d8 01       	movw	r26, r16
    1050:	13 96       	adiw	r26, 0x03	; 3
    1052:	8c 91       	ld	r24, X
    1054:	13 97       	sbiw	r26, 0x03	; 3
    1056:	80 ff       	sbrs	r24, 0
    1058:	fa cf       	rjmp	.-12     	; 0x104e <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
    105a:	69 81       	ldd	r22, Y+1	; 0x01
    105c:	c8 01       	movw	r24, r16
    105e:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
    1062:	a0 e0       	ldi	r26, 0x00	; 0
    1064:	b0 e0       	ldi	r27, 0x00	; 0
    1066:	88 0e       	add	r8, r24
    1068:	99 1e       	adc	r9, r25
    106a:	aa 1e       	adc	r10, r26
    106c:	bb 1e       	adc	r11, r27
    106e:	48 16       	cp	r4, r24
    1070:	59 06       	cpc	r5, r25
    1072:	6a 06       	cpc	r6, r26
    1074:	7b 06       	cpc	r7, r27
    1076:	10 f4       	brcc	.+4      	; 0x107c <CO_collectTemp+0x136>
    1078:	2c 01       	movw	r4, r24
    107a:	3d 01       	movw	r6, r26
    107c:	2a 81       	ldd	r18, Y+2	; 0x02
    107e:	3b 81       	ldd	r19, Y+3	; 0x03
    1080:	4c 81       	ldd	r20, Y+4	; 0x04
    1082:	5d 81       	ldd	r21, Y+5	; 0x05
    1084:	82 17       	cp	r24, r18
    1086:	93 07       	cpc	r25, r19
    1088:	a4 07       	cpc	r26, r20
    108a:	b5 07       	cpc	r27, r21
    108c:	20 f4       	brcc	.+8      	; 0x1096 <CO_collectTemp+0x150>
    108e:	8a 83       	std	Y+2, r24	; 0x02
    1090:	9b 83       	std	Y+3, r25	; 0x03
    1092:	ac 83       	std	Y+4, r26	; 0x04
    1094:	bd 83       	std	Y+5, r27	; 0x05
    1096:	08 94       	sec
    1098:	e1 08       	sbc	r14, r1
    109a:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    109c:	e1 14       	cp	r14, r1
    109e:	f1 04       	cpc	r15, r1
    10a0:	b1 f6       	brne	.-84     	; 0x104e <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
    10a2:	e0 e0       	ldi	r30, 0x00	; 0
    10a4:	f2 e0       	ldi	r31, 0x02	; 2
    10a6:	81 81       	ldd	r24, Z+1	; 0x01
    10a8:	87 7f       	andi	r24, 0xF7	; 247
    10aa:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
    10ac:	80 81       	ld	r24, Z
    10ae:	82 60       	ori	r24, 0x02	; 2
    10b0:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
    10b2:	80 81       	ld	r24, Z
    10b4:	8e 7f       	andi	r24, 0xFE	; 254
    10b6:	80 83       	st	Z, r24

	ADCPower(FALSE);
    10b8:	80 e0       	ldi	r24, 0x00	; 0
    10ba:	0e 94 a3 05 	call	0xb46	; 0xb46 <ADCPower>

	average = sum / NUM_SAMPLES;
    10be:	c5 01       	movw	r24, r10
    10c0:	b4 01       	movw	r22, r8
    10c2:	05 2e       	mov	r0, r21
    10c4:	5a e0       	ldi	r21, 0x0A	; 10
    10c6:	96 95       	lsr	r25
    10c8:	87 95       	ror	r24
    10ca:	77 95       	ror	r23
    10cc:	67 95       	ror	r22
    10ce:	5a 95       	dec	r21
    10d0:	d1 f7       	brne	.-12     	; 0x10c6 <CO_collectTemp+0x180>
    10d2:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    10d4:	28 ee       	ldi	r18, 0xE8	; 232
    10d6:	33 e0       	ldi	r19, 0x03	; 3
    10d8:	40 e0       	ldi	r20, 0x00	; 0
    10da:	50 e0       	ldi	r21, 0x00	; 0
    10dc:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    10e0:	0f 2e       	mov	r0, r31
    10e2:	ff ef       	ldi	r31, 0xFF	; 255
    10e4:	8f 2e       	mov	r8, r31
    10e6:	ff e0       	ldi	r31, 0x0F	; 15
    10e8:	9f 2e       	mov	r9, r31
    10ea:	f0 e0       	ldi	r31, 0x00	; 0
    10ec:	af 2e       	mov	r10, r31
    10ee:	f0 e0       	ldi	r31, 0x00	; 0
    10f0:	bf 2e       	mov	r11, r31
    10f2:	f0 2d       	mov	r31, r0
    10f4:	a5 01       	movw	r20, r10
    10f6:	94 01       	movw	r18, r8
    10f8:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    10fc:	c9 01       	movw	r24, r18
    10fe:	c2 97       	sbiw	r24, 0x32	; 50
    1100:	ae 81       	ldd	r26, Y+6	; 0x06
    1102:	bf 81       	ldd	r27, Y+7	; 0x07
    1104:	8d 93       	st	X+, r24
    1106:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    1108:	c3 01       	movw	r24, r6
    110a:	b2 01       	movw	r22, r4
    110c:	28 ee       	ldi	r18, 0xE8	; 232
    110e:	33 e0       	ldi	r19, 0x03	; 3
    1110:	40 e0       	ldi	r20, 0x00	; 0
    1112:	50 e0       	ldi	r21, 0x00	; 0
    1114:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    1118:	a5 01       	movw	r20, r10
    111a:	94 01       	movw	r18, r8
    111c:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    1120:	c9 01       	movw	r24, r18
    1122:	c2 97       	sbiw	r24, 0x32	; 50
    1124:	ea 85       	ldd	r30, Y+10	; 0x0a
    1126:	fb 85       	ldd	r31, Y+11	; 0x0b
    1128:	80 83       	st	Z, r24
    112a:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    112c:	6a 81       	ldd	r22, Y+2	; 0x02
    112e:	7b 81       	ldd	r23, Y+3	; 0x03
    1130:	8c 81       	ldd	r24, Y+4	; 0x04
    1132:	9d 81       	ldd	r25, Y+5	; 0x05
    1134:	28 ee       	ldi	r18, 0xE8	; 232
    1136:	33 e0       	ldi	r19, 0x03	; 3
    1138:	40 e0       	ldi	r20, 0x00	; 0
    113a:	50 e0       	ldi	r21, 0x00	; 0
    113c:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    1140:	a5 01       	movw	r20, r10
    1142:	94 01       	movw	r18, r8
    1144:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    1148:	22 53       	subi	r18, 0x32	; 50
    114a:	30 40       	sbci	r19, 0x00	; 0
    114c:	a8 85       	ldd	r26, Y+8	; 0x08
    114e:	b9 85       	ldd	r27, Y+9	; 0x09
    1150:	2d 93       	st	X+, r18
    1152:	3c 93       	st	X, r19
    1154:	11 97       	sbiw	r26, 0x01	; 1
}
    1156:	2b 96       	adiw	r28, 0x0b	; 11
    1158:	cd bf       	out	0x3d, r28	; 61
    115a:	de bf       	out	0x3e, r29	; 62
    115c:	df 91       	pop	r29
    115e:	cf 91       	pop	r28
    1160:	1f 91       	pop	r17
    1162:	0f 91       	pop	r16
    1164:	ff 90       	pop	r15
    1166:	ef 90       	pop	r14
    1168:	bf 90       	pop	r11
    116a:	af 90       	pop	r10
    116c:	9f 90       	pop	r9
    116e:	8f 90       	pop	r8
    1170:	7f 90       	pop	r7
    1172:	6f 90       	pop	r6
    1174:	5f 90       	pop	r5
    1176:	4f 90       	pop	r4
    1178:	08 95       	ret

0000117a <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    117a:	4f 92       	push	r4
    117c:	5f 92       	push	r5
    117e:	6f 92       	push	r6
    1180:	7f 92       	push	r7
    1182:	8f 92       	push	r8
    1184:	9f 92       	push	r9
    1186:	af 92       	push	r10
    1188:	bf 92       	push	r11
    118a:	ef 92       	push	r14
    118c:	ff 92       	push	r15
    118e:	0f 93       	push	r16
    1190:	1f 93       	push	r17
    1192:	cf 93       	push	r28
    1194:	df 93       	push	r29
    1196:	cd b7       	in	r28, 0x3d	; 61
    1198:	de b7       	in	r29, 0x3e	; 62
    119a:	2b 97       	sbiw	r28, 0x0b	; 11
    119c:	cd bf       	out	0x3d, r28	; 61
    119e:	de bf       	out	0x3e, r29	; 62
    11a0:	8e 83       	std	Y+6, r24	; 0x06
    11a2:	9f 83       	std	Y+7, r25	; 0x07
    11a4:	68 87       	std	Y+8, r22	; 0x08
    11a6:	79 87       	std	Y+9, r23	; 0x09
    11a8:	4a 87       	std	Y+10, r20	; 0x0a
    11aa:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    11ac:	81 e0       	ldi	r24, 0x01	; 1
    11ae:	0e 94 a3 05 	call	0xb46	; 0xb46 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
    11b2:	84 e0       	ldi	r24, 0x04	; 4
    11b4:	60 e0       	ldi	r22, 0x00	; 0
    11b6:	0e 94 4d 05 	call	0xa9a	; 0xa9a <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
    11ba:	84 e0       	ldi	r24, 0x04	; 4
    11bc:	60 e0       	ldi	r22, 0x00	; 0
    11be:	0e 94 a0 04 	call	0x940	; 0x940 <PortEx_OUTSET>
    11c2:	2f ef       	ldi	r18, 0xFF	; 255
    11c4:	33 ec       	ldi	r19, 0xC3	; 195
    11c6:	49 e0       	ldi	r20, 0x09	; 9
    11c8:	21 50       	subi	r18, 0x01	; 1
    11ca:	30 40       	sbci	r19, 0x00	; 0
    11cc:	40 40       	sbci	r20, 0x00	; 0
    11ce:	e1 f7       	brne	.-8      	; 0x11c8 <CO_collectBatt+0x4e>
    11d0:	00 c0       	rjmp	.+0      	; 0x11d2 <CO_collectBatt+0x58>
    11d2:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
    11d4:	80 e4       	ldi	r24, 0x40	; 64
    11d6:	92 e0       	ldi	r25, 0x02	; 2
    11d8:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    11dc:	00 e4       	ldi	r16, 0x40	; 64
    11de:	12 e0       	ldi	r17, 0x02	; 2
    11e0:	d8 01       	movw	r26, r16
    11e2:	11 96       	adiw	r26, 0x01	; 1
    11e4:	8c 91       	ld	r24, X
    11e6:	11 97       	sbiw	r26, 0x01	; 1
    11e8:	89 7e       	andi	r24, 0xE9	; 233
    11ea:	11 96       	adiw	r26, 0x01	; 1
    11ec:	8c 93       	st	X, r24
    11ee:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
    11f0:	14 96       	adiw	r26, 0x04	; 4
    11f2:	8c 91       	ld	r24, X
    11f4:	14 97       	sbiw	r26, 0x04	; 4
    11f6:	88 7f       	andi	r24, 0xF8	; 248
    11f8:	83 60       	ori	r24, 0x03	; 3
    11fa:	14 96       	adiw	r26, 0x04	; 4
    11fc:	8c 93       	st	X, r24
    11fe:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
    1200:	12 96       	adiw	r26, 0x02	; 2
    1202:	8c 91       	ld	r24, X
    1204:	12 97       	sbiw	r26, 0x02	; 2
    1206:	8f 7c       	andi	r24, 0xCF	; 207
    1208:	12 96       	adiw	r26, 0x02	; 2
    120a:	8c 93       	st	X, r24
    120c:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
    120e:	0f 2e       	mov	r0, r31
    1210:	f0 e6       	ldi	r31, 0x60	; 96
    1212:	ef 2e       	mov	r14, r31
    1214:	f2 e0       	ldi	r31, 0x02	; 2
    1216:	ff 2e       	mov	r15, r31
    1218:	f0 2d       	mov	r31, r0
    121a:	f7 01       	movw	r30, r14
    121c:	80 81       	ld	r24, Z
    121e:	80 7e       	andi	r24, 0xE0	; 224
    1220:	81 60       	ori	r24, 0x01	; 1
    1222:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    1224:	89 e0       	ldi	r24, 0x09	; 9
    1226:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
    1228:	8c 91       	ld	r24, X
    122a:	81 60       	ori	r24, 0x01	; 1
    122c:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
    122e:	80 e4       	ldi	r24, 0x40	; 64
    1230:	92 e0       	ldi	r25, 0x02	; 2
    1232:	0e 94 1f 16 	call	0x2c3e	; 0x2c3e <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
    1236:	80 e4       	ldi	r24, 0x40	; 64
    1238:	92 e0       	ldi	r25, 0x02	; 2
    123a:	60 e6       	ldi	r22, 0x60	; 96
    123c:	72 e0       	ldi	r23, 0x02	; 2
    123e:	40 e0       	ldi	r20, 0x00	; 0
    1240:	0e 94 29 16 	call	0x2c52	; 0x2c52 <ADC_Offset_Get_Unsigned>
    1244:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
    1246:	d8 01       	movw	r26, r16
    1248:	8c 91       	ld	r24, X
    124a:	8e 7f       	andi	r24, 0xFE	; 254
    124c:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    124e:	f7 01       	movw	r30, r14
    1250:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
    1252:	13 96       	adiw	r26, 0x03	; 3
    1254:	8c 91       	ld	r24, X
    1256:	13 97       	sbiw	r26, 0x03	; 3
    1258:	8f 73       	andi	r24, 0x3F	; 63
    125a:	13 96       	adiw	r26, 0x03	; 3
    125c:	8c 93       	st	X, r24
    125e:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
    1260:	8c 91       	ld	r24, X
    1262:	81 60       	ori	r24, 0x01	; 1
    1264:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
    1266:	80 e4       	ldi	r24, 0x40	; 64
    1268:	92 e0       	ldi	r25, 0x02	; 2
    126a:	0e 94 1f 16 	call	0x2c3e	; 0x2c3e <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
    126e:	d8 01       	movw	r26, r16
    1270:	11 96       	adiw	r26, 0x01	; 1
    1272:	8c 91       	ld	r24, X
    1274:	11 97       	sbiw	r26, 0x01	; 1
    1276:	88 60       	ori	r24, 0x08	; 8
    1278:	11 96       	adiw	r26, 0x01	; 1
    127a:	8c 93       	st	X, r24
    127c:	ee 24       	eor	r14, r14
    127e:	ff 24       	eor	r15, r15
    1280:	68 94       	set
    1282:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    1284:	44 24       	eor	r4, r4
    1286:	55 24       	eor	r5, r5
    1288:	32 01       	movw	r6, r4
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
    128a:	20 e0       	ldi	r18, 0x00	; 0
    128c:	30 e1       	ldi	r19, 0x10	; 16
    128e:	40 e0       	ldi	r20, 0x00	; 0
    1290:	50 e0       	ldi	r21, 0x00	; 0
    1292:	2a 83       	std	Y+2, r18	; 0x02
    1294:	3b 83       	std	Y+3, r19	; 0x03
    1296:	4c 83       	std	Y+4, r20	; 0x04
    1298:	5d 83       	std	Y+5, r21	; 0x05
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    129a:	88 24       	eor	r8, r8
    129c:	99 24       	eor	r9, r9
    129e:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
    12a0:	00 e6       	ldi	r16, 0x60	; 96
    12a2:	12 e0       	ldi	r17, 0x02	; 2
    12a4:	d8 01       	movw	r26, r16
    12a6:	13 96       	adiw	r26, 0x03	; 3
    12a8:	8c 91       	ld	r24, X
    12aa:	13 97       	sbiw	r26, 0x03	; 3
    12ac:	80 ff       	sbrs	r24, 0
    12ae:	fa cf       	rjmp	.-12     	; 0x12a4 <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
    12b0:	69 81       	ldd	r22, Y+1	; 0x01
    12b2:	c8 01       	movw	r24, r16
    12b4:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
    12b8:	a0 e0       	ldi	r26, 0x00	; 0
    12ba:	b0 e0       	ldi	r27, 0x00	; 0
    12bc:	88 0e       	add	r8, r24
    12be:	99 1e       	adc	r9, r25
    12c0:	aa 1e       	adc	r10, r26
    12c2:	bb 1e       	adc	r11, r27
    12c4:	48 16       	cp	r4, r24
    12c6:	59 06       	cpc	r5, r25
    12c8:	6a 06       	cpc	r6, r26
    12ca:	7b 06       	cpc	r7, r27
    12cc:	10 f4       	brcc	.+4      	; 0x12d2 <CO_collectBatt+0x158>
    12ce:	2c 01       	movw	r4, r24
    12d0:	3d 01       	movw	r6, r26
    12d2:	2a 81       	ldd	r18, Y+2	; 0x02
    12d4:	3b 81       	ldd	r19, Y+3	; 0x03
    12d6:	4c 81       	ldd	r20, Y+4	; 0x04
    12d8:	5d 81       	ldd	r21, Y+5	; 0x05
    12da:	82 17       	cp	r24, r18
    12dc:	93 07       	cpc	r25, r19
    12de:	a4 07       	cpc	r26, r20
    12e0:	b5 07       	cpc	r27, r21
    12e2:	20 f4       	brcc	.+8      	; 0x12ec <CO_collectBatt+0x172>
    12e4:	8a 83       	std	Y+2, r24	; 0x02
    12e6:	9b 83       	std	Y+3, r25	; 0x03
    12e8:	ac 83       	std	Y+4, r26	; 0x04
    12ea:	bd 83       	std	Y+5, r27	; 0x05
    12ec:	08 94       	sec
    12ee:	e1 08       	sbc	r14, r1
    12f0:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    12f2:	e1 14       	cp	r14, r1
    12f4:	f1 04       	cpc	r15, r1
    12f6:	b1 f6       	brne	.-84     	; 0x12a4 <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
    12f8:	e0 e4       	ldi	r30, 0x40	; 64
    12fa:	f2 e0       	ldi	r31, 0x02	; 2
    12fc:	81 81       	ldd	r24, Z+1	; 0x01
    12fe:	87 7f       	andi	r24, 0xF7	; 247
    1300:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
    1302:	80 81       	ld	r24, Z
    1304:	8e 7f       	andi	r24, 0xFE	; 254
    1306:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
    1308:	84 e0       	ldi	r24, 0x04	; 4
    130a:	60 e0       	ldi	r22, 0x00	; 0
    130c:	0e 94 f5 04 	call	0x9ea	; 0x9ea <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
    1310:	80 e0       	ldi	r24, 0x00	; 0
    1312:	0e 94 a3 05 	call	0xb46	; 0xb46 <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
    1316:	c5 01       	movw	r24, r10
    1318:	b4 01       	movw	r22, r8
    131a:	05 2e       	mov	r0, r21
    131c:	5a e0       	ldi	r21, 0x0A	; 10
    131e:	96 95       	lsr	r25
    1320:	87 95       	ror	r24
    1322:	77 95       	ror	r23
    1324:	67 95       	ror	r22
    1326:	5a 95       	dec	r21
    1328:	d1 f7       	brne	.-12     	; 0x131e <CO_collectBatt+0x1a4>
    132a:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    132c:	28 ee       	ldi	r18, 0xE8	; 232
    132e:	33 e0       	ldi	r19, 0x03	; 3
    1330:	40 e0       	ldi	r20, 0x00	; 0
    1332:	50 e0       	ldi	r21, 0x00	; 0
    1334:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    1338:	0f 2e       	mov	r0, r31
    133a:	ff ef       	ldi	r31, 0xFF	; 255
    133c:	8f 2e       	mov	r8, r31
    133e:	ff e0       	ldi	r31, 0x0F	; 15
    1340:	9f 2e       	mov	r9, r31
    1342:	f0 e0       	ldi	r31, 0x00	; 0
    1344:	af 2e       	mov	r10, r31
    1346:	f0 e0       	ldi	r31, 0x00	; 0
    1348:	bf 2e       	mov	r11, r31
    134a:	f0 2d       	mov	r31, r0
    134c:	a5 01       	movw	r20, r10
    134e:	94 01       	movw	r18, r8
    1350:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    1354:	c9 01       	movw	r24, r18
    1356:	c2 97       	sbiw	r24, 0x32	; 50
    1358:	ae 81       	ldd	r26, Y+6	; 0x06
    135a:	bf 81       	ldd	r27, Y+7	; 0x07
    135c:	8d 93       	st	X+, r24
    135e:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    1360:	c3 01       	movw	r24, r6
    1362:	b2 01       	movw	r22, r4
    1364:	28 ee       	ldi	r18, 0xE8	; 232
    1366:	33 e0       	ldi	r19, 0x03	; 3
    1368:	40 e0       	ldi	r20, 0x00	; 0
    136a:	50 e0       	ldi	r21, 0x00	; 0
    136c:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    1370:	a5 01       	movw	r20, r10
    1372:	94 01       	movw	r18, r8
    1374:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    1378:	c9 01       	movw	r24, r18
    137a:	c2 97       	sbiw	r24, 0x32	; 50
    137c:	ea 85       	ldd	r30, Y+10	; 0x0a
    137e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1380:	80 83       	st	Z, r24
    1382:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    1384:	6a 81       	ldd	r22, Y+2	; 0x02
    1386:	7b 81       	ldd	r23, Y+3	; 0x03
    1388:	8c 81       	ldd	r24, Y+4	; 0x04
    138a:	9d 81       	ldd	r25, Y+5	; 0x05
    138c:	28 ee       	ldi	r18, 0xE8	; 232
    138e:	33 e0       	ldi	r19, 0x03	; 3
    1390:	40 e0       	ldi	r20, 0x00	; 0
    1392:	50 e0       	ldi	r21, 0x00	; 0
    1394:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    1398:	a5 01       	movw	r20, r10
    139a:	94 01       	movw	r18, r8
    139c:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    13a0:	22 53       	subi	r18, 0x32	; 50
    13a2:	30 40       	sbci	r19, 0x00	; 0
    13a4:	a8 85       	ldd	r26, Y+8	; 0x08
    13a6:	b9 85       	ldd	r27, Y+9	; 0x09
    13a8:	2d 93       	st	X+, r18
    13aa:	3c 93       	st	X, r19
    13ac:	11 97       	sbiw	r26, 0x01	; 1
}
    13ae:	2b 96       	adiw	r28, 0x0b	; 11
    13b0:	cd bf       	out	0x3d, r28	; 61
    13b2:	de bf       	out	0x3e, r29	; 62
    13b4:	df 91       	pop	r29
    13b6:	cf 91       	pop	r28
    13b8:	1f 91       	pop	r17
    13ba:	0f 91       	pop	r16
    13bc:	ff 90       	pop	r15
    13be:	ef 90       	pop	r14
    13c0:	bf 90       	pop	r11
    13c2:	af 90       	pop	r10
    13c4:	9f 90       	pop	r9
    13c6:	8f 90       	pop	r8
    13c8:	7f 90       	pop	r7
    13ca:	6f 90       	pop	r6
    13cc:	5f 90       	pop	r5
    13ce:	4f 90       	pop	r4
    13d0:	08 95       	ret

000013d2 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
    13d2:	cf 93       	push	r28
    13d4:	c6 2f       	mov	r28, r22
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
    13d6:	21 e0       	ldi	r18, 0x01	; 1
    13d8:	30 e0       	ldi	r19, 0x00	; 0
    13da:	a9 01       	movw	r20, r18
    13dc:	02 c0       	rjmp	.+4      	; 0x13e2 <set_ampGain+0x10>
    13de:	44 0f       	add	r20, r20
    13e0:	55 1f       	adc	r21, r21
    13e2:	8a 95       	dec	r24
    13e4:	e2 f7       	brpl	.-8      	; 0x13de <set_ampGain+0xc>
    13e6:	ca 01       	movw	r24, r20
    13e8:	61 e0       	ldi	r22, 0x01	; 1
    13ea:	0e 94 49 04 	call	0x892	; 0x892 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    13ee:	c0 ff       	sbrs	r28, 0
    13f0:	05 c0       	rjmp	.+10     	; 0x13fc <set_ampGain+0x2a>
    13f2:	80 e4       	ldi	r24, 0x40	; 64
    13f4:	e0 e0       	ldi	r30, 0x00	; 0
    13f6:	f6 e0       	ldi	r31, 0x06	; 6
    13f8:	85 83       	std	Z+5, r24	; 0x05
    13fa:	04 c0       	rjmp	.+8      	; 0x1404 <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
    13fc:	80 e4       	ldi	r24, 0x40	; 64
    13fe:	e0 e0       	ldi	r30, 0x00	; 0
    1400:	f6 e0       	ldi	r31, 0x06	; 6
    1402:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    1404:	c1 ff       	sbrs	r28, 1
    1406:	05 c0       	rjmp	.+10     	; 0x1412 <set_ampGain+0x40>
    1408:	82 e0       	ldi	r24, 0x02	; 2
    140a:	e0 e2       	ldi	r30, 0x20	; 32
    140c:	f6 e0       	ldi	r31, 0x06	; 6
    140e:	85 83       	std	Z+5, r24	; 0x05
    1410:	04 c0       	rjmp	.+8      	; 0x141a <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
    1412:	82 e0       	ldi	r24, 0x02	; 2
    1414:	e0 e2       	ldi	r30, 0x20	; 32
    1416:	f6 e0       	ldi	r31, 0x06	; 6
    1418:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    141a:	c2 ff       	sbrs	r28, 2
    141c:	05 c0       	rjmp	.+10     	; 0x1428 <set_ampGain+0x56>
    141e:	84 e0       	ldi	r24, 0x04	; 4
    1420:	e0 e2       	ldi	r30, 0x20	; 32
    1422:	f6 e0       	ldi	r31, 0x06	; 6
    1424:	85 83       	std	Z+5, r24	; 0x05
    1426:	04 c0       	rjmp	.+8      	; 0x1430 <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
    1428:	84 e0       	ldi	r24, 0x04	; 4
    142a:	e0 e2       	ldi	r30, 0x20	; 32
    142c:	f6 e0       	ldi	r31, 0x06	; 6
    142e:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1430:	5a e0       	ldi	r21, 0x0A	; 10
    1432:	5a 95       	dec	r21
    1434:	f1 f7       	brne	.-4      	; 0x1432 <set_ampGain+0x60>
    1436:	00 c0       	rjmp	.+0      	; 0x1438 <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    1438:	8f ef       	ldi	r24, 0xFF	; 255
    143a:	61 e0       	ldi	r22, 0x01	; 1
    143c:	0e 94 a0 04 	call	0x940	; 0x940 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    1440:	cf 91       	pop	r28
    1442:	08 95       	ret

00001444 <enableADCMUX>:

void enableADCMUX(uint8_t on) {
	
	if(on) {
    1444:	88 23       	and	r24, r24
    1446:	31 f0       	breq	.+12     	; 0x1454 <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
    1448:	e0 e0       	ldi	r30, 0x00	; 0
    144a:	f6 e0       	ldi	r31, 0x06	; 6
    144c:	80 e2       	ldi	r24, 0x20	; 32
    144e:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
    1450:	85 83       	std	Z+5, r24	; 0x05
    1452:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
    1454:	e0 e0       	ldi	r30, 0x00	; 0
    1456:	f6 e0       	ldi	r31, 0x06	; 6
    1458:	80 e2       	ldi	r24, 0x20	; 32
    145a:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    145c:	82 83       	std	Z+2, r24	; 0x02
    145e:	08 95       	ret

00001460 <__vector_20>:
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
    1460:	1f 92       	push	r1
    1462:	0f 92       	push	r0
    1464:	0f b6       	in	r0, 0x3f	; 63
    1466:	0f 92       	push	r0
    1468:	0b b6       	in	r0, 0x3b	; 59
    146a:	0f 92       	push	r0
    146c:	11 24       	eor	r1, r1
    146e:	2f 93       	push	r18
    1470:	3f 93       	push	r19
    1472:	4f 93       	push	r20
    1474:	5f 93       	push	r21
    1476:	6f 93       	push	r22
    1478:	7f 93       	push	r23
    147a:	8f 93       	push	r24
    147c:	9f 93       	push	r25
    147e:	af 93       	push	r26
    1480:	bf 93       	push	r27
    1482:	ef 93       	push	r30
    1484:	ff 93       	push	r31

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1486:	e0 e4       	ldi	r30, 0x40	; 64
    1488:	fa e0       	ldi	r31, 0x0A	; 10
    148a:	80 81       	ld	r24, Z
    148c:	80 7f       	andi	r24, 0xF0	; 240
    148e:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1490:	a0 e0       	ldi	r26, 0x00	; 0
    1492:	b8 e0       	ldi	r27, 0x08	; 8
    1494:	8c 91       	ld	r24, X
    1496:	80 7f       	andi	r24, 0xF0	; 240
    1498:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    149a:	a0 e0       	ldi	r26, 0x00	; 0
    149c:	b9 e0       	ldi	r27, 0x09	; 9
    149e:	8c 91       	ld	r24, X
    14a0:	80 7f       	andi	r24, 0xF0	; 240
    14a2:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    14a4:	80 81       	ld	r24, Z
    14a6:	80 7f       	andi	r24, 0xF0	; 240
    14a8:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    14ac:	80 e0       	ldi	r24, 0x00	; 0
    14ae:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	SPIDisable();
    14b2:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <SPIDisable>
	enableADCMUX(FALSE);
    14b6:	80 e0       	ldi	r24, 0x00	; 0
    14b8:	0e 94 22 0a 	call	0x1444	; 0x1444 <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
    14bc:	81 e0       	ldi	r24, 0x01	; 1
    14be:	80 93 a4 50 	sts	0x50A4, r24
	DataAvailable = 1;
    14c2:	80 93 46 3e 	sts	0x3E46, r24
}
    14c6:	ff 91       	pop	r31
    14c8:	ef 91       	pop	r30
    14ca:	bf 91       	pop	r27
    14cc:	af 91       	pop	r26
    14ce:	9f 91       	pop	r25
    14d0:	8f 91       	pop	r24
    14d2:	7f 91       	pop	r23
    14d4:	6f 91       	pop	r22
    14d6:	5f 91       	pop	r21
    14d8:	4f 91       	pop	r20
    14da:	3f 91       	pop	r19
    14dc:	2f 91       	pop	r18
    14de:	0f 90       	pop	r0
    14e0:	0b be       	out	0x3b, r0	; 59
    14e2:	0f 90       	pop	r0
    14e4:	0f be       	out	0x3f, r0	; 63
    14e6:	0f 90       	pop	r0
    14e8:	1f 90       	pop	r1
    14ea:	18 95       	reti

000014ec <ADC_Stop_Sampling>:

//turns off ADC timers/counters and spi bus 
void ADC_Stop_Sampling(){
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    14ec:	e0 e4       	ldi	r30, 0x40	; 64
    14ee:	fa e0       	ldi	r31, 0x0A	; 10
    14f0:	80 81       	ld	r24, Z
    14f2:	80 7f       	andi	r24, 0xF0	; 240
    14f4:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    14f6:	a0 e0       	ldi	r26, 0x00	; 0
    14f8:	b8 e0       	ldi	r27, 0x08	; 8
    14fa:	8c 91       	ld	r24, X
    14fc:	80 7f       	andi	r24, 0xF0	; 240
    14fe:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1500:	a0 e0       	ldi	r26, 0x00	; 0
    1502:	b9 e0       	ldi	r27, 0x09	; 9
    1504:	8c 91       	ld	r24, X
    1506:	80 7f       	andi	r24, 0xF0	; 240
    1508:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    150a:	80 81       	ld	r24, Z
    150c:	80 7f       	andi	r24, 0xF0	; 240
    150e:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    1512:	80 e0       	ldi	r24, 0x00	; 0
    1514:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	SPIDisable();
    1518:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <SPIDisable>
	enableADCMUX(FALSE);
    151c:	80 e0       	ldi	r24, 0x00	; 0
    151e:	0e 94 22 0a 	call	0x1444	; 0x1444 <enableADCMUX>
	ADC_Sampling_Finished = 1;
    1522:	81 e0       	ldi	r24, 0x01	; 1
    1524:	80 93 a4 50 	sts	0x50A4, r24
	DataAvailable = 1;
    1528:	80 93 46 3e 	sts	0x3E46, r24
}
    152c:	08 95       	ret

0000152e <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
    152e:	cf 93       	push	r28
    1530:	df 93       	push	r29
    1532:	0f 92       	push	r0
    1534:	0f 92       	push	r0
    1536:	cd b7       	in	r28, 0x3d	; 61
    1538:	de b7       	in	r29, 0x3e	; 62
	
	if(ADC_Sampling_Finished){
    153a:	80 91 a4 50 	lds	r24, 0x50A4
    153e:	88 23       	and	r24, r24
    1540:	89 f0       	breq	.+34     	; 0x1564 <ADC_Get_Num_Samples+0x36>
		volatile uint16_t count;
		count = TCC1.CNT;
    1542:	e0 e4       	ldi	r30, 0x40	; 64
    1544:	f8 e0       	ldi	r31, 0x08	; 8
    1546:	80 a1       	lds	r24, 0x40
    1548:	91 a1       	lds	r25, 0x41
    154a:	89 83       	std	Y+1, r24	; 0x01
    154c:	9a 83       	std	Y+2, r25	; 0x02
		if(count == 0) count = TCC1.PER;
    154e:	89 81       	ldd	r24, Y+1	; 0x01
    1550:	9a 81       	ldd	r25, Y+2	; 0x02
    1552:	00 97       	sbiw	r24, 0x00	; 0
    1554:	21 f4       	brne	.+8      	; 0x155e <ADC_Get_Num_Samples+0x30>
    1556:	86 a1       	lds	r24, 0x46
    1558:	97 a1       	lds	r25, 0x47
    155a:	89 83       	std	Y+1, r24	; 0x01
    155c:	9a 83       	std	Y+2, r25	; 0x02
		return count;
    155e:	89 81       	ldd	r24, Y+1	; 0x01
    1560:	9a 81       	ldd	r25, Y+2	; 0x02
    1562:	02 c0       	rjmp	.+4      	; 0x1568 <ADC_Get_Num_Samples+0x3a>
	}
	else return 0;		
    1564:	80 e0       	ldi	r24, 0x00	; 0
    1566:	90 e0       	ldi	r25, 0x00	; 0
}
    1568:	0f 90       	pop	r0
    156a:	0f 90       	pop	r0
    156c:	df 91       	pop	r29
    156e:	cf 91       	pop	r28
    1570:	08 95       	ret

00001572 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    1572:	e0 ea       	ldi	r30, 0xA0	; 160
    1574:	f6 e0       	ldi	r31, 0x06	; 6
    1576:	13 86       	std	Z+11, r1	; 0x0b
}
    1578:	08 95       	ret

0000157a <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    157a:	81 e0       	ldi	r24, 0x01	; 1
    157c:	e0 ea       	ldi	r30, 0xA0	; 160
    157e:	f6 e0       	ldi	r31, 0x06	; 6
    1580:	83 87       	std	Z+11, r24	; 0x0b
}	
    1582:	08 95       	ret

00001584 <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    1584:	1f 92       	push	r1
    1586:	0f 92       	push	r0
    1588:	0f b6       	in	r0, 0x3f	; 63
    158a:	0f 92       	push	r0
    158c:	0b b6       	in	r0, 0x3b	; 59
    158e:	0f 92       	push	r0
    1590:	11 24       	eor	r1, r1
    1592:	6f 92       	push	r6
    1594:	7f 92       	push	r7
    1596:	8f 92       	push	r8
    1598:	9f 92       	push	r9
    159a:	af 92       	push	r10
    159c:	bf 92       	push	r11
    159e:	cf 92       	push	r12
    15a0:	df 92       	push	r13
    15a2:	ef 92       	push	r14
    15a4:	ff 92       	push	r15
    15a6:	0f 93       	push	r16
    15a8:	1f 93       	push	r17
    15aa:	2f 93       	push	r18
    15ac:	3f 93       	push	r19
    15ae:	4f 93       	push	r20
    15b0:	5f 93       	push	r21
    15b2:	6f 93       	push	r22
    15b4:	7f 93       	push	r23
    15b6:	8f 93       	push	r24
    15b8:	9f 93       	push	r25
    15ba:	af 93       	push	r26
    15bc:	bf 93       	push	r27
    15be:	ef 93       	push	r30
    15c0:	ff 93       	push	r31
    15c2:	cf 93       	push	r28
    15c4:	df 93       	push	r29
    15c6:	cd b7       	in	r28, 0x3d	; 61
    15c8:	de b7       	in	r29, 0x3e	; 62
    15ca:	2c 97       	sbiw	r28, 0x0c	; 12
    15cc:	cd bf       	out	0x3d, r28	; 61
    15ce:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	volatile int64_t var;
	if (discardCount < ADC_DISCARD) {
    15d0:	80 91 5a 40 	lds	r24, 0x405A
    15d4:	88 23       	and	r24, r24
    15d6:	8c f0       	brlt	.+34     	; 0x15fa <__vector_104+0x76>
		discardCount++;
    15d8:	80 91 5a 40 	lds	r24, 0x405A
    15dc:	8f 5f       	subi	r24, 0xFF	; 255
    15de:	80 93 5a 40 	sts	0x405A, r24
		if(discardCount == ADC_DISCARD){
    15e2:	80 91 5a 40 	lds	r24, 0x405A
    15e6:	80 38       	cpi	r24, 0x80	; 128
    15e8:	09 f0       	breq	.+2      	; 0x15ec <__vector_104+0x68>
    15ea:	b4 c0       	rjmp	.+360    	; 0x1754 <__vector_104+0x1d0>
			//set event system to update counter of number of samples every sample event from now on
			TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    15ec:	e0 e4       	ldi	r30, 0x40	; 64
    15ee:	f8 e0       	ldi	r31, 0x08	; 8
    15f0:	80 81       	ld	r24, Z
    15f2:	80 7f       	andi	r24, 0xF0	; 240
    15f4:	89 60       	ori	r24, 0x09	; 9
    15f6:	80 83       	st	Z, r24
    15f8:	ad c0       	rjmp	.+346    	; 0x1754 <__vector_104+0x1d0>
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    15fa:	81 e0       	ldi	r24, 0x01	; 1
    15fc:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1600:	82 e0       	ldi	r24, 0x02	; 2
    1602:	e0 ea       	ldi	r30, 0xA0	; 160
    1604:	f6 e0       	ldi	r31, 0x06	; 6
    1606:	86 83       	std	Z+6, r24	; 0x06
    1608:	80 e0       	ldi	r24, 0x00	; 0
    160a:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    160c:	e0 ec       	ldi	r30, 0xC0	; 192
    160e:	f8 e0       	ldi	r31, 0x08	; 8
    1610:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
    1612:	20 e2       	ldi	r18, 0x20	; 32
    1614:	3e e3       	ldi	r19, 0x3E	; 62
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1616:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1618:	42 81       	ldd	r20, Z+2	; 0x02
    161a:	44 23       	and	r20, r20
    161c:	ec f7       	brge	.-6      	; 0x1618 <__vector_104+0x94>
			SPIBuffer[bufIndex] = SPIC.DATA;
    161e:	43 81       	ldd	r20, Z+3	; 0x03
    1620:	d9 01       	movw	r26, r18
    1622:	a8 0f       	add	r26, r24
    1624:	b9 1f       	adc	r27, r25
    1626:	4c 93       	st	X, r20
    1628:	01 96       	adiw	r24, 0x01	; 1
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    162a:	83 30       	cpi	r24, 0x03	; 3
    162c:	91 05       	cpc	r25, r1
    162e:	99 f7       	brne	.-26     	; 0x1616 <__vector_104+0x92>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1630:	82 e0       	ldi	r24, 0x02	; 2
    1632:	e0 ea       	ldi	r30, 0xA0	; 160
    1634:	f6 e0       	ldi	r31, 0x06	; 6
    1636:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
    1638:	80 e0       	ldi	r24, 0x00	; 0
    163a:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    163e:	80 91 20 3e 	lds	r24, 0x3E20
    1642:	88 23       	and	r24, r24
    1644:	1c f4       	brge	.+6      	; 0x164c <__vector_104+0xc8>
    1646:	8f ef       	ldi	r24, 0xFF	; 255
    1648:	8c 83       	std	Y+4, r24	; 0x04
    164a:	01 c0       	rjmp	.+2      	; 0x164e <__vector_104+0xca>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    164c:	1c 82       	std	Y+4, r1	; 0x04
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    164e:	80 91 20 3e 	lds	r24, 0x3E20
    1652:	8b 83       	std	Y+3, r24	; 0x03
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    1654:	80 91 21 3e 	lds	r24, 0x3E21
    1658:	8a 83       	std	Y+2, r24	; 0x02
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    165a:	80 91 22 3e 	lds	r24, 0x3E22
    165e:	89 83       	std	Y+1, r24	; 0x01
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    1660:	89 81       	ldd	r24, Y+1	; 0x01
    1662:	9a 81       	ldd	r25, Y+2	; 0x02
    1664:	ab 81       	ldd	r26, Y+3	; 0x03
    1666:	bc 81       	ldd	r27, Y+4	; 0x04
    1668:	ac 01       	movw	r20, r24
    166a:	bd 01       	movw	r22, r26
    166c:	77 0f       	add	r23, r23
    166e:	44 0b       	sbc	r20, r20
    1670:	54 2f       	mov	r21, r20
    1672:	ba 01       	movw	r22, r20
    1674:	8d 83       	std	Y+5, r24	; 0x05
    1676:	9e 83       	std	Y+6, r25	; 0x06
    1678:	af 83       	std	Y+7, r26	; 0x07
    167a:	b8 87       	std	Y+8, r27	; 0x08
    167c:	49 87       	std	Y+9, r20	; 0x09
    167e:	4a 87       	std	Y+10, r20	; 0x0a
    1680:	4b 87       	std	Y+11, r20	; 0x0b
    1682:	4c 87       	std	Y+12, r20	; 0x0c
		ADC_BUFFER[sampleCount] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1684:	80 90 63 50 	lds	r8, 0x5063
    1688:	90 90 64 50 	lds	r9, 0x5064
    168c:	a0 90 65 50 	lds	r10, 0x5065
    1690:	b0 90 66 50 	lds	r11, 0x5066
    1694:	2d 81       	ldd	r18, Y+5	; 0x05
    1696:	3e 81       	ldd	r19, Y+6	; 0x06
    1698:	4f 81       	ldd	r20, Y+7	; 0x07
    169a:	58 85       	ldd	r21, Y+8	; 0x08
    169c:	69 85       	ldd	r22, Y+9	; 0x09
    169e:	7a 85       	ldd	r23, Y+10	; 0x0a
    16a0:	8b 85       	ldd	r24, Y+11	; 0x0b
    16a2:	9c 85       	ldd	r25, Y+12	; 0x0c
    16a4:	f4 01       	movw	r30, r8
    16a6:	ee 0f       	add	r30, r30
    16a8:	ff 1f       	adc	r31, r31
    16aa:	ee 0f       	add	r30, r30
    16ac:	ff 1f       	adc	r31, r31
    16ae:	60 90 61 50 	lds	r6, 0x5061
    16b2:	70 90 62 50 	lds	r7, 0x5062
    16b6:	6e 0e       	add	r6, r30
    16b8:	7f 1e       	adc	r7, r31
    16ba:	0f 2e       	mov	r0, r31
    16bc:	f0 ea       	ldi	r31, 0xA0	; 160
    16be:	af 2e       	mov	r10, r31
    16c0:	f0 2d       	mov	r31, r0
    16c2:	0f 2e       	mov	r0, r31
    16c4:	f5 e2       	ldi	r31, 0x25	; 37
    16c6:	bf 2e       	mov	r11, r31
    16c8:	f0 2d       	mov	r31, r0
    16ca:	0f 2e       	mov	r0, r31
    16cc:	f6 e2       	ldi	r31, 0x26	; 38
    16ce:	cf 2e       	mov	r12, r31
    16d0:	f0 2d       	mov	r31, r0
    16d2:	dd 24       	eor	r13, r13
    16d4:	ee 24       	eor	r14, r14
    16d6:	ff 24       	eor	r15, r15
    16d8:	00 e0       	ldi	r16, 0x00	; 0
    16da:	10 e0       	ldi	r17, 0x00	; 0
    16dc:	0e 94 c5 2a 	call	0x558a	; 0x558a <__muldi3>
    16e0:	aa 24       	eor	r10, r10
    16e2:	aa 94       	dec	r10
    16e4:	bb 24       	eor	r11, r11
    16e6:	ba 94       	dec	r11
    16e8:	0f 2e       	mov	r0, r31
    16ea:	ff e7       	ldi	r31, 0x7F	; 127
    16ec:	cf 2e       	mov	r12, r31
    16ee:	f0 2d       	mov	r31, r0
    16f0:	0e 94 74 2c 	call	0x58e8	; 0x58e8 <__divdi3>
    16f4:	01 e0       	ldi	r16, 0x01	; 1
    16f6:	0e 94 98 2b 	call	0x5730	; 0x5730 <__ashldi3>
    16fa:	0f 2e       	mov	r0, r31
    16fc:	f3 e0       	ldi	r31, 0x03	; 3
    16fe:	af 2e       	mov	r10, r31
    1700:	f0 2d       	mov	r31, r0
    1702:	bb 24       	eor	r11, r11
    1704:	cc 24       	eor	r12, r12
    1706:	00 e0       	ldi	r16, 0x00	; 0
    1708:	0e 94 74 2c 	call	0x58e8	; 0x58e8 <__divdi3>
    170c:	82 2e       	mov	r8, r18
    170e:	93 2e       	mov	r9, r19
    1710:	a4 2e       	mov	r10, r20
    1712:	b5 2e       	mov	r11, r21
    1714:	b0 94       	com	r11
    1716:	a0 94       	com	r10
    1718:	90 94       	com	r9
    171a:	80 94       	com	r8
    171c:	81 1c       	adc	r8, r1
    171e:	91 1c       	adc	r9, r1
    1720:	a1 1c       	adc	r10, r1
    1722:	b1 1c       	adc	r11, r1
    1724:	f3 01       	movw	r30, r6
    1726:	80 82       	st	Z, r8
    1728:	91 82       	std	Z+1, r9	; 0x01
    172a:	a2 82       	std	Z+2, r10	; 0x02
    172c:	b3 82       	std	Z+3, r11	; 0x03
		sampleCount++;
    172e:	80 91 63 50 	lds	r24, 0x5063
    1732:	90 91 64 50 	lds	r25, 0x5064
    1736:	a0 91 65 50 	lds	r26, 0x5065
    173a:	b0 91 66 50 	lds	r27, 0x5066
    173e:	01 96       	adiw	r24, 0x01	; 1
    1740:	a1 1d       	adc	r26, r1
    1742:	b1 1d       	adc	r27, r1
    1744:	80 93 63 50 	sts	0x5063, r24
    1748:	90 93 64 50 	sts	0x5064, r25
    174c:	a0 93 65 50 	sts	0x5065, r26
    1750:	b0 93 66 50 	sts	0x5066, r27
	}
}
    1754:	2c 96       	adiw	r28, 0x0c	; 12
    1756:	cd bf       	out	0x3d, r28	; 61
    1758:	de bf       	out	0x3e, r29	; 62
    175a:	df 91       	pop	r29
    175c:	cf 91       	pop	r28
    175e:	ff 91       	pop	r31
    1760:	ef 91       	pop	r30
    1762:	bf 91       	pop	r27
    1764:	af 91       	pop	r26
    1766:	9f 91       	pop	r25
    1768:	8f 91       	pop	r24
    176a:	7f 91       	pop	r23
    176c:	6f 91       	pop	r22
    176e:	5f 91       	pop	r21
    1770:	4f 91       	pop	r20
    1772:	3f 91       	pop	r19
    1774:	2f 91       	pop	r18
    1776:	1f 91       	pop	r17
    1778:	0f 91       	pop	r16
    177a:	ff 90       	pop	r15
    177c:	ef 90       	pop	r14
    177e:	df 90       	pop	r13
    1780:	cf 90       	pop	r12
    1782:	bf 90       	pop	r11
    1784:	af 90       	pop	r10
    1786:	9f 90       	pop	r9
    1788:	8f 90       	pop	r8
    178a:	7f 90       	pop	r7
    178c:	6f 90       	pop	r6
    178e:	0f 90       	pop	r0
    1790:	0b be       	out	0x3b, r0	; 59
    1792:	0f 90       	pop	r0
    1794:	0f be       	out	0x3f, r0	; 63
    1796:	0f 90       	pop	r0
    1798:	1f 90       	pop	r1
    179a:	18 95       	reti

0000179c <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
    179c:	88 23       	and	r24, r24
    179e:	49 f0       	breq	.+18     	; 0x17b2 <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    17a0:	80 e2       	ldi	r24, 0x20	; 32
    17a2:	60 e0       	ldi	r22, 0x00	; 0
    17a4:	0e 94 4d 05 	call	0xa9a	; 0xa9a <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    17a8:	80 e2       	ldi	r24, 0x20	; 32
    17aa:	60 e0       	ldi	r22, 0x00	; 0
    17ac:	0e 94 a0 04 	call	0x940	; 0x940 <PortEx_OUTSET>
    17b0:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    17b2:	80 e2       	ldi	r24, 0x20	; 32
    17b4:	60 e0       	ldi	r22, 0x00	; 0
    17b6:	0e 94 f5 04 	call	0x9ea	; 0x9ea <PortEx_DIRCLR>
    17ba:	08 95       	ret

000017bc <__vector_14>:
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    17bc:	1f 92       	push	r1
    17be:	0f 92       	push	r0
    17c0:	0f b6       	in	r0, 0x3f	; 63
    17c2:	0f 92       	push	r0
    17c4:	0b b6       	in	r0, 0x3b	; 59
    17c6:	0f 92       	push	r0
    17c8:	11 24       	eor	r1, r1
    17ca:	6f 92       	push	r6
    17cc:	7f 92       	push	r7
    17ce:	8f 92       	push	r8
    17d0:	9f 92       	push	r9
    17d2:	af 92       	push	r10
    17d4:	bf 92       	push	r11
    17d6:	cf 92       	push	r12
    17d8:	df 92       	push	r13
    17da:	ef 92       	push	r14
    17dc:	ff 92       	push	r15
    17de:	0f 93       	push	r16
    17e0:	1f 93       	push	r17
    17e2:	2f 93       	push	r18
    17e4:	3f 93       	push	r19
    17e6:	4f 93       	push	r20
    17e8:	5f 93       	push	r21
    17ea:	6f 93       	push	r22
    17ec:	7f 93       	push	r23
    17ee:	8f 93       	push	r24
    17f0:	9f 93       	push	r25
    17f2:	af 93       	push	r26
    17f4:	bf 93       	push	r27
    17f6:	ef 93       	push	r30
    17f8:	ff 93       	push	r31
    17fa:	cf 93       	push	r28
    17fc:	df 93       	push	r29
    17fe:	cd b7       	in	r28, 0x3d	; 61
    1800:	de b7       	in	r29, 0x3e	; 62
    1802:	2c 97       	sbiw	r28, 0x0c	; 12
    1804:	cd bf       	out	0x3d, r28	; 61
    1806:	de bf       	out	0x3e, r29	; 62
	volatile int64_t sum = 0;
    1808:	19 82       	std	Y+1, r1	; 0x01
    180a:	1a 82       	std	Y+2, r1	; 0x02
    180c:	1b 82       	std	Y+3, r1	; 0x03
    180e:	1c 82       	std	Y+4, r1	; 0x04
    1810:	1d 82       	std	Y+5, r1	; 0x05
    1812:	1e 82       	std	Y+6, r1	; 0x06
    1814:	1f 82       	std	Y+7, r1	; 0x07
    1816:	18 86       	std	Y+8, r1	; 0x08
    1818:	80 e0       	ldi	r24, 0x00	; 0
    181a:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    181c:	20 e2       	ldi	r18, 0x20	; 32
    181e:	3e e3       	ldi	r19, 0x3E	; 62
    1820:	aa 24       	eor	r10, r10
    1822:	aa 94       	dec	r10
    1824:	ac 01       	movw	r20, r24
    1826:	f9 01       	movw	r30, r18
    1828:	e8 0f       	add	r30, r24
    182a:	f9 1f       	adc	r31, r25
    182c:	60 81       	ld	r22, Z
    182e:	66 23       	and	r22, r22
    1830:	14 f4       	brge	.+4      	; 0x1836 <__vector_14+0x7a>
    1832:	ac 86       	std	Y+12, r10	; 0x0c
    1834:	01 c0       	rjmp	.+2      	; 0x1838 <__vector_14+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1836:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1838:	42 0f       	add	r20, r18
    183a:	53 1f       	adc	r21, r19
    183c:	fa 01       	movw	r30, r20
    183e:	40 81       	ld	r20, Z
    1840:	4b 87       	std	Y+11, r20	; 0x0b
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1842:	fc 01       	movw	r30, r24
    1844:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1846:	e2 0f       	add	r30, r18
    1848:	f3 1f       	adc	r31, r19
    184a:	40 81       	ld	r20, Z
    184c:	4a 87       	std	Y+10, r20	; 0x0a
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    184e:	fc 01       	movw	r30, r24
    1850:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1852:	e2 0f       	add	r30, r18
    1854:	f3 1f       	adc	r31, r19
    1856:	40 81       	ld	r20, Z
    1858:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    185a:	49 85       	ldd	r20, Y+9	; 0x09
    185c:	5a 85       	ldd	r21, Y+10	; 0x0a
    185e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1860:	7c 85       	ldd	r23, Y+12	; 0x0c
    1862:	b9 80       	ldd	r11, Y+1	; 0x01
    1864:	ca 80       	ldd	r12, Y+2	; 0x02
    1866:	db 80       	ldd	r13, Y+3	; 0x03
    1868:	ec 80       	ldd	r14, Y+4	; 0x04
    186a:	fd 80       	ldd	r15, Y+5	; 0x05
    186c:	0e 81       	ldd	r16, Y+6	; 0x06
    186e:	1f 81       	ldd	r17, Y+7	; 0x07
    1870:	88 84       	ldd	r8, Y+8	; 0x08
    1872:	b4 2f       	mov	r27, r20
    1874:	a5 2f       	mov	r26, r21
    1876:	f6 2f       	mov	r31, r22
    1878:	e7 2f       	mov	r30, r23
    187a:	77 0f       	add	r23, r23
    187c:	44 0b       	sbc	r20, r20
    187e:	54 2f       	mov	r21, r20
    1880:	ba 01       	movw	r22, r20
    1882:	64 2e       	mov	r6, r20
    1884:	74 2e       	mov	r7, r20
    1886:	94 2e       	mov	r9, r20
    1888:	bb 0e       	add	r11, r27
    188a:	61 e0       	ldi	r22, 0x01	; 1
    188c:	bb 16       	cp	r11, r27
    188e:	08 f0       	brcs	.+2      	; 0x1892 <__vector_14+0xd6>
    1890:	60 e0       	ldi	r22, 0x00	; 0
    1892:	ca 0e       	add	r12, r26
    1894:	51 e0       	ldi	r21, 0x01	; 1
    1896:	ca 16       	cp	r12, r26
    1898:	08 f0       	brcs	.+2      	; 0x189c <__vector_14+0xe0>
    189a:	50 e0       	ldi	r21, 0x00	; 0
    189c:	a6 2f       	mov	r26, r22
    189e:	ac 0d       	add	r26, r12
    18a0:	61 e0       	ldi	r22, 0x01	; 1
    18a2:	ac 15       	cp	r26, r12
    18a4:	08 f0       	brcs	.+2      	; 0x18a8 <__vector_14+0xec>
    18a6:	60 e0       	ldi	r22, 0x00	; 0
    18a8:	56 2b       	or	r21, r22
    18aa:	df 0e       	add	r13, r31
    18ac:	61 e0       	ldi	r22, 0x01	; 1
    18ae:	df 16       	cp	r13, r31
    18b0:	08 f0       	brcs	.+2      	; 0x18b4 <__vector_14+0xf8>
    18b2:	60 e0       	ldi	r22, 0x00	; 0
    18b4:	f5 2f       	mov	r31, r21
    18b6:	fd 0d       	add	r31, r13
    18b8:	51 e0       	ldi	r21, 0x01	; 1
    18ba:	fd 15       	cp	r31, r13
    18bc:	08 f0       	brcs	.+2      	; 0x18c0 <__vector_14+0x104>
    18be:	50 e0       	ldi	r21, 0x00	; 0
    18c0:	65 2b       	or	r22, r21
    18c2:	ee 0e       	add	r14, r30
    18c4:	51 e0       	ldi	r21, 0x01	; 1
    18c6:	ee 16       	cp	r14, r30
    18c8:	08 f0       	brcs	.+2      	; 0x18cc <__vector_14+0x110>
    18ca:	50 e0       	ldi	r21, 0x00	; 0
    18cc:	e6 2f       	mov	r30, r22
    18ce:	ee 0d       	add	r30, r14
    18d0:	61 e0       	ldi	r22, 0x01	; 1
    18d2:	ee 15       	cp	r30, r14
    18d4:	08 f0       	brcs	.+2      	; 0x18d8 <__vector_14+0x11c>
    18d6:	60 e0       	ldi	r22, 0x00	; 0
    18d8:	56 2b       	or	r21, r22
    18da:	f6 0c       	add	r15, r6
    18dc:	71 e0       	ldi	r23, 0x01	; 1
    18de:	f6 14       	cp	r15, r6
    18e0:	08 f0       	brcs	.+2      	; 0x18e4 <__vector_14+0x128>
    18e2:	70 e0       	ldi	r23, 0x00	; 0
    18e4:	b5 2f       	mov	r27, r21
    18e6:	bf 0d       	add	r27, r15
    18e8:	51 e0       	ldi	r21, 0x01	; 1
    18ea:	bf 15       	cp	r27, r15
    18ec:	08 f0       	brcs	.+2      	; 0x18f0 <__vector_14+0x134>
    18ee:	50 e0       	ldi	r21, 0x00	; 0
    18f0:	75 2b       	or	r23, r21
    18f2:	07 0d       	add	r16, r7
    18f4:	61 e0       	ldi	r22, 0x01	; 1
    18f6:	07 15       	cp	r16, r7
    18f8:	08 f0       	brcs	.+2      	; 0x18fc <__vector_14+0x140>
    18fa:	60 e0       	ldi	r22, 0x00	; 0
    18fc:	70 0f       	add	r23, r16
    18fe:	51 e0       	ldi	r21, 0x01	; 1
    1900:	70 17       	cp	r23, r16
    1902:	08 f0       	brcs	.+2      	; 0x1906 <__vector_14+0x14a>
    1904:	50 e0       	ldi	r21, 0x00	; 0
    1906:	65 2b       	or	r22, r21
    1908:	19 0d       	add	r17, r9
    190a:	51 e0       	ldi	r21, 0x01	; 1
    190c:	19 15       	cp	r17, r9
    190e:	08 f0       	brcs	.+2      	; 0x1912 <__vector_14+0x156>
    1910:	50 e0       	ldi	r21, 0x00	; 0
    1912:	61 0f       	add	r22, r17
    1914:	01 e0       	ldi	r16, 0x01	; 1
    1916:	61 17       	cp	r22, r17
    1918:	08 f0       	brcs	.+2      	; 0x191c <__vector_14+0x160>
    191a:	00 e0       	ldi	r16, 0x00	; 0
    191c:	50 2b       	or	r21, r16
    191e:	48 0d       	add	r20, r8
    1920:	54 0f       	add	r21, r20
    1922:	b9 82       	std	Y+1, r11	; 0x01
    1924:	aa 83       	std	Y+2, r26	; 0x02
    1926:	fb 83       	std	Y+3, r31	; 0x03
    1928:	ec 83       	std	Y+4, r30	; 0x04
    192a:	bd 83       	std	Y+5, r27	; 0x05
    192c:	7e 83       	std	Y+6, r23	; 0x06
    192e:	6f 83       	std	Y+7, r22	; 0x07
    1930:	58 87       	std	Y+8, r21	; 0x08
    1932:	03 96       	adiw	r24, 0x03	; 3
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1934:	8c 30       	cpi	r24, 0x0C	; 12
    1936:	91 05       	cpc	r25, r1
    1938:	09 f0       	breq	.+2      	; 0x193c <__vector_14+0x180>
    193a:	74 cf       	rjmp	.-280    	; 0x1824 <__vector_14+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    193c:	e9 80       	ldd	r14, Y+1	; 0x01
    193e:	fa 80       	ldd	r15, Y+2	; 0x02
    1940:	0b 81       	ldd	r16, Y+3	; 0x03
    1942:	1c 81       	ldd	r17, Y+4	; 0x04
    1944:	bd 81       	ldd	r27, Y+5	; 0x05
    1946:	ae 81       	ldd	r26, Y+6	; 0x06
    1948:	ff 81       	ldd	r31, Y+7	; 0x07
    194a:	e8 85       	ldd	r30, Y+8	; 0x08
    194c:	2e 2d       	mov	r18, r14
    194e:	3f 2d       	mov	r19, r15
    1950:	40 2f       	mov	r20, r16
    1952:	51 2f       	mov	r21, r17
    1954:	6b 2f       	mov	r22, r27
    1956:	7a 2f       	mov	r23, r26
    1958:	8f 2f       	mov	r24, r31
    195a:	9e 2f       	mov	r25, r30
    195c:	ee 23       	and	r30, r30
    195e:	0c f0       	brlt	.+2      	; 0x1962 <__vector_14+0x1a6>
    1960:	4a c0       	rjmp	.+148    	; 0x19f6 <__vector_14+0x23a>
    1962:	93 e0       	ldi	r25, 0x03	; 3
    1964:	e9 0e       	add	r14, r25
    1966:	91 e0       	ldi	r25, 0x01	; 1
    1968:	e2 16       	cp	r14, r18
    196a:	08 f0       	brcs	.+2      	; 0x196e <__vector_14+0x1b2>
    196c:	90 e0       	ldi	r25, 0x00	; 0
    196e:	21 e0       	ldi	r18, 0x01	; 1
    1970:	f3 16       	cp	r15, r19
    1972:	08 f0       	brcs	.+2      	; 0x1976 <__vector_14+0x1ba>
    1974:	20 e0       	ldi	r18, 0x00	; 0
    1976:	39 2f       	mov	r19, r25
    1978:	3f 0d       	add	r19, r15
    197a:	91 e0       	ldi	r25, 0x01	; 1
    197c:	3f 15       	cp	r19, r15
    197e:	08 f0       	brcs	.+2      	; 0x1982 <__vector_14+0x1c6>
    1980:	90 e0       	ldi	r25, 0x00	; 0
    1982:	29 2b       	or	r18, r25
    1984:	91 e0       	ldi	r25, 0x01	; 1
    1986:	04 17       	cp	r16, r20
    1988:	08 f0       	brcs	.+2      	; 0x198c <__vector_14+0x1d0>
    198a:	90 e0       	ldi	r25, 0x00	; 0
    198c:	42 2f       	mov	r20, r18
    198e:	40 0f       	add	r20, r16
    1990:	21 e0       	ldi	r18, 0x01	; 1
    1992:	40 17       	cp	r20, r16
    1994:	08 f0       	brcs	.+2      	; 0x1998 <__vector_14+0x1dc>
    1996:	20 e0       	ldi	r18, 0x00	; 0
    1998:	92 2b       	or	r25, r18
    199a:	21 e0       	ldi	r18, 0x01	; 1
    199c:	15 17       	cp	r17, r21
    199e:	08 f0       	brcs	.+2      	; 0x19a2 <__vector_14+0x1e6>
    19a0:	20 e0       	ldi	r18, 0x00	; 0
    19a2:	59 2f       	mov	r21, r25
    19a4:	51 0f       	add	r21, r17
    19a6:	91 e0       	ldi	r25, 0x01	; 1
    19a8:	51 17       	cp	r21, r17
    19aa:	08 f0       	brcs	.+2      	; 0x19ae <__vector_14+0x1f2>
    19ac:	90 e0       	ldi	r25, 0x00	; 0
    19ae:	29 2b       	or	r18, r25
    19b0:	91 e0       	ldi	r25, 0x01	; 1
    19b2:	b6 17       	cp	r27, r22
    19b4:	08 f0       	brcs	.+2      	; 0x19b8 <__vector_14+0x1fc>
    19b6:	90 e0       	ldi	r25, 0x00	; 0
    19b8:	62 2f       	mov	r22, r18
    19ba:	6b 0f       	add	r22, r27
    19bc:	21 e0       	ldi	r18, 0x01	; 1
    19be:	6b 17       	cp	r22, r27
    19c0:	08 f0       	brcs	.+2      	; 0x19c4 <__vector_14+0x208>
    19c2:	20 e0       	ldi	r18, 0x00	; 0
    19c4:	92 2b       	or	r25, r18
    19c6:	21 e0       	ldi	r18, 0x01	; 1
    19c8:	a7 17       	cp	r26, r23
    19ca:	08 f0       	brcs	.+2      	; 0x19ce <__vector_14+0x212>
    19cc:	20 e0       	ldi	r18, 0x00	; 0
    19ce:	79 2f       	mov	r23, r25
    19d0:	7a 0f       	add	r23, r26
    19d2:	91 e0       	ldi	r25, 0x01	; 1
    19d4:	7a 17       	cp	r23, r26
    19d6:	08 f0       	brcs	.+2      	; 0x19da <__vector_14+0x21e>
    19d8:	90 e0       	ldi	r25, 0x00	; 0
    19da:	29 2b       	or	r18, r25
    19dc:	91 e0       	ldi	r25, 0x01	; 1
    19de:	f8 17       	cp	r31, r24
    19e0:	08 f0       	brcs	.+2      	; 0x19e4 <__vector_14+0x228>
    19e2:	90 e0       	ldi	r25, 0x00	; 0
    19e4:	82 2f       	mov	r24, r18
    19e6:	8f 0f       	add	r24, r31
    19e8:	21 e0       	ldi	r18, 0x01	; 1
    19ea:	8f 17       	cp	r24, r31
    19ec:	08 f0       	brcs	.+2      	; 0x19f0 <__vector_14+0x234>
    19ee:	20 e0       	ldi	r18, 0x00	; 0
    19f0:	92 2b       	or	r25, r18
    19f2:	2e 2d       	mov	r18, r14
    19f4:	9e 0f       	add	r25, r30
    19f6:	02 e0       	ldi	r16, 0x02	; 2
    19f8:	0e 94 0c 2c 	call	0x5818	; 0x5818 <__ashrdi3>
    19fc:	29 83       	std	Y+1, r18	; 0x01
    19fe:	3a 83       	std	Y+2, r19	; 0x02
    1a00:	4b 83       	std	Y+3, r20	; 0x03
    1a02:	5c 83       	std	Y+4, r21	; 0x04
    1a04:	6d 83       	std	Y+5, r22	; 0x05
    1a06:	7e 83       	std	Y+6, r23	; 0x06
    1a08:	8f 83       	std	Y+7, r24	; 0x07
    1a0a:	98 87       	std	Y+8, r25	; 0x08
	ADC_BUFFER[sampleCount] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1a0c:	80 90 63 50 	lds	r8, 0x5063
    1a10:	90 90 64 50 	lds	r9, 0x5064
    1a14:	a0 90 65 50 	lds	r10, 0x5065
    1a18:	b0 90 66 50 	lds	r11, 0x5066
    1a1c:	29 81       	ldd	r18, Y+1	; 0x01
    1a1e:	3a 81       	ldd	r19, Y+2	; 0x02
    1a20:	4b 81       	ldd	r20, Y+3	; 0x03
    1a22:	5c 81       	ldd	r21, Y+4	; 0x04
    1a24:	6d 81       	ldd	r22, Y+5	; 0x05
    1a26:	7e 81       	ldd	r23, Y+6	; 0x06
    1a28:	8f 81       	ldd	r24, Y+7	; 0x07
    1a2a:	98 85       	ldd	r25, Y+8	; 0x08
    1a2c:	f4 01       	movw	r30, r8
    1a2e:	ee 0f       	add	r30, r30
    1a30:	ff 1f       	adc	r31, r31
    1a32:	ee 0f       	add	r30, r30
    1a34:	ff 1f       	adc	r31, r31
    1a36:	80 90 61 50 	lds	r8, 0x5061
    1a3a:	90 90 62 50 	lds	r9, 0x5062
    1a3e:	8e 0e       	add	r8, r30
    1a40:	9f 1e       	adc	r9, r31
    1a42:	0f 2e       	mov	r0, r31
    1a44:	f0 ea       	ldi	r31, 0xA0	; 160
    1a46:	af 2e       	mov	r10, r31
    1a48:	f0 2d       	mov	r31, r0
    1a4a:	0f 2e       	mov	r0, r31
    1a4c:	f5 e2       	ldi	r31, 0x25	; 37
    1a4e:	bf 2e       	mov	r11, r31
    1a50:	f0 2d       	mov	r31, r0
    1a52:	0f 2e       	mov	r0, r31
    1a54:	f6 e2       	ldi	r31, 0x26	; 38
    1a56:	cf 2e       	mov	r12, r31
    1a58:	f0 2d       	mov	r31, r0
    1a5a:	dd 24       	eor	r13, r13
    1a5c:	ee 24       	eor	r14, r14
    1a5e:	ff 24       	eor	r15, r15
    1a60:	00 e0       	ldi	r16, 0x00	; 0
    1a62:	10 e0       	ldi	r17, 0x00	; 0
    1a64:	0e 94 c5 2a 	call	0x558a	; 0x558a <__muldi3>
    1a68:	aa 24       	eor	r10, r10
    1a6a:	aa 94       	dec	r10
    1a6c:	bb 24       	eor	r11, r11
    1a6e:	ba 94       	dec	r11
    1a70:	0f 2e       	mov	r0, r31
    1a72:	ff e7       	ldi	r31, 0x7F	; 127
    1a74:	cf 2e       	mov	r12, r31
    1a76:	f0 2d       	mov	r31, r0
    1a78:	0e 94 74 2c 	call	0x58e8	; 0x58e8 <__divdi3>
    1a7c:	01 e0       	ldi	r16, 0x01	; 1
    1a7e:	0e 94 98 2b 	call	0x5730	; 0x5730 <__ashldi3>
    1a82:	0f 2e       	mov	r0, r31
    1a84:	f3 e0       	ldi	r31, 0x03	; 3
    1a86:	af 2e       	mov	r10, r31
    1a88:	f0 2d       	mov	r31, r0
    1a8a:	bb 24       	eor	r11, r11
    1a8c:	cc 24       	eor	r12, r12
    1a8e:	00 e0       	ldi	r16, 0x00	; 0
    1a90:	0e 94 74 2c 	call	0x58e8	; 0x58e8 <__divdi3>
    1a94:	f4 01       	movw	r30, r8
    1a96:	20 83       	st	Z, r18
    1a98:	31 83       	std	Z+1, r19	; 0x01
    1a9a:	42 83       	std	Z+2, r20	; 0x02
    1a9c:	53 83       	std	Z+3, r21	; 0x03
	sampleCount++;
    1a9e:	80 91 63 50 	lds	r24, 0x5063
    1aa2:	90 91 64 50 	lds	r25, 0x5064
    1aa6:	a0 91 65 50 	lds	r26, 0x5065
    1aaa:	b0 91 66 50 	lds	r27, 0x5066
    1aae:	01 96       	adiw	r24, 0x01	; 1
    1ab0:	a1 1d       	adc	r26, r1
    1ab2:	b1 1d       	adc	r27, r1
    1ab4:	80 93 63 50 	sts	0x5063, r24
    1ab8:	90 93 64 50 	sts	0x5064, r25
    1abc:	a0 93 65 50 	sts	0x5065, r26
    1ac0:	b0 93 66 50 	sts	0x5066, r27

}
    1ac4:	2c 96       	adiw	r28, 0x0c	; 12
    1ac6:	cd bf       	out	0x3d, r28	; 61
    1ac8:	de bf       	out	0x3e, r29	; 62
    1aca:	df 91       	pop	r29
    1acc:	cf 91       	pop	r28
    1ace:	ff 91       	pop	r31
    1ad0:	ef 91       	pop	r30
    1ad2:	bf 91       	pop	r27
    1ad4:	af 91       	pop	r26
    1ad6:	9f 91       	pop	r25
    1ad8:	8f 91       	pop	r24
    1ada:	7f 91       	pop	r23
    1adc:	6f 91       	pop	r22
    1ade:	5f 91       	pop	r21
    1ae0:	4f 91       	pop	r20
    1ae2:	3f 91       	pop	r19
    1ae4:	2f 91       	pop	r18
    1ae6:	1f 91       	pop	r17
    1ae8:	0f 91       	pop	r16
    1aea:	ff 90       	pop	r15
    1aec:	ef 90       	pop	r14
    1aee:	df 90       	pop	r13
    1af0:	cf 90       	pop	r12
    1af2:	bf 90       	pop	r11
    1af4:	af 90       	pop	r10
    1af6:	9f 90       	pop	r9
    1af8:	8f 90       	pop	r8
    1afa:	7f 90       	pop	r7
    1afc:	6f 90       	pop	r6
    1afe:	0f 90       	pop	r0
    1b00:	0b be       	out	0x3b, r0	; 59
    1b02:	0f 90       	pop	r0
    1b04:	0f be       	out	0x3f, r0	; 63
    1b06:	0f 90       	pop	r0
    1b08:	1f 90       	pop	r1
    1b0a:	18 95       	reti

00001b0c <__vector_77>:
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1b0c:	1f 92       	push	r1
    1b0e:	0f 92       	push	r0
    1b10:	0f b6       	in	r0, 0x3f	; 63
    1b12:	0f 92       	push	r0
    1b14:	0b b6       	in	r0, 0x3b	; 59
    1b16:	0f 92       	push	r0
    1b18:	11 24       	eor	r1, r1
    1b1a:	6f 92       	push	r6
    1b1c:	7f 92       	push	r7
    1b1e:	8f 92       	push	r8
    1b20:	9f 92       	push	r9
    1b22:	af 92       	push	r10
    1b24:	bf 92       	push	r11
    1b26:	cf 92       	push	r12
    1b28:	df 92       	push	r13
    1b2a:	ef 92       	push	r14
    1b2c:	ff 92       	push	r15
    1b2e:	0f 93       	push	r16
    1b30:	1f 93       	push	r17
    1b32:	2f 93       	push	r18
    1b34:	3f 93       	push	r19
    1b36:	4f 93       	push	r20
    1b38:	5f 93       	push	r21
    1b3a:	6f 93       	push	r22
    1b3c:	7f 93       	push	r23
    1b3e:	8f 93       	push	r24
    1b40:	9f 93       	push	r25
    1b42:	af 93       	push	r26
    1b44:	bf 93       	push	r27
    1b46:	ef 93       	push	r30
    1b48:	ff 93       	push	r31
    1b4a:	cf 93       	push	r28
    1b4c:	df 93       	push	r29
    1b4e:	cd b7       	in	r28, 0x3d	; 61
    1b50:	de b7       	in	r29, 0x3e	; 62
    1b52:	2c 97       	sbiw	r28, 0x0c	; 12
    1b54:	cd bf       	out	0x3d, r28	; 61
    1b56:	de bf       	out	0x3e, r29	; 62

	volatile int64_t sum = 0;
    1b58:	19 82       	std	Y+1, r1	; 0x01
    1b5a:	1a 82       	std	Y+2, r1	; 0x02
    1b5c:	1b 82       	std	Y+3, r1	; 0x03
    1b5e:	1c 82       	std	Y+4, r1	; 0x04
    1b60:	1d 82       	std	Y+5, r1	; 0x05
    1b62:	1e 82       	std	Y+6, r1	; 0x06
    1b64:	1f 82       	std	Y+7, r1	; 0x07
    1b66:	18 86       	std	Y+8, r1	; 0x08
    1b68:	80 e0       	ldi	r24, 0x00	; 0
    1b6a:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1b6c:	20 e2       	ldi	r18, 0x20	; 32
    1b6e:	3e e3       	ldi	r19, 0x3E	; 62
    1b70:	aa 24       	eor	r10, r10
    1b72:	aa 94       	dec	r10
    1b74:	ac 01       	movw	r20, r24
    1b76:	f9 01       	movw	r30, r18
    1b78:	e8 0f       	add	r30, r24
    1b7a:	f9 1f       	adc	r31, r25
    1b7c:	60 81       	ld	r22, Z
    1b7e:	66 23       	and	r22, r22
    1b80:	14 f4       	brge	.+4      	; 0x1b86 <__vector_77+0x7a>
    1b82:	ac 86       	std	Y+12, r10	; 0x0c
    1b84:	01 c0       	rjmp	.+2      	; 0x1b88 <__vector_77+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1b86:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1b88:	42 0f       	add	r20, r18
    1b8a:	53 1f       	adc	r21, r19
    1b8c:	fa 01       	movw	r30, r20
    1b8e:	40 81       	ld	r20, Z
    1b90:	4b 87       	std	Y+11, r20	; 0x0b
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1b92:	fc 01       	movw	r30, r24
    1b94:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1b96:	e2 0f       	add	r30, r18
    1b98:	f3 1f       	adc	r31, r19
    1b9a:	40 81       	ld	r20, Z
    1b9c:	4a 87       	std	Y+10, r20	; 0x0a
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1b9e:	fc 01       	movw	r30, r24
    1ba0:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1ba2:	e2 0f       	add	r30, r18
    1ba4:	f3 1f       	adc	r31, r19
    1ba6:	40 81       	ld	r20, Z
    1ba8:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    1baa:	49 85       	ldd	r20, Y+9	; 0x09
    1bac:	5a 85       	ldd	r21, Y+10	; 0x0a
    1bae:	6b 85       	ldd	r22, Y+11	; 0x0b
    1bb0:	7c 85       	ldd	r23, Y+12	; 0x0c
    1bb2:	b9 80       	ldd	r11, Y+1	; 0x01
    1bb4:	ca 80       	ldd	r12, Y+2	; 0x02
    1bb6:	db 80       	ldd	r13, Y+3	; 0x03
    1bb8:	ec 80       	ldd	r14, Y+4	; 0x04
    1bba:	fd 80       	ldd	r15, Y+5	; 0x05
    1bbc:	0e 81       	ldd	r16, Y+6	; 0x06
    1bbe:	1f 81       	ldd	r17, Y+7	; 0x07
    1bc0:	88 84       	ldd	r8, Y+8	; 0x08
    1bc2:	b4 2f       	mov	r27, r20
    1bc4:	a5 2f       	mov	r26, r21
    1bc6:	f6 2f       	mov	r31, r22
    1bc8:	e7 2f       	mov	r30, r23
    1bca:	77 0f       	add	r23, r23
    1bcc:	44 0b       	sbc	r20, r20
    1bce:	54 2f       	mov	r21, r20
    1bd0:	ba 01       	movw	r22, r20
    1bd2:	64 2e       	mov	r6, r20
    1bd4:	74 2e       	mov	r7, r20
    1bd6:	94 2e       	mov	r9, r20
    1bd8:	bb 0e       	add	r11, r27
    1bda:	61 e0       	ldi	r22, 0x01	; 1
    1bdc:	bb 16       	cp	r11, r27
    1bde:	08 f0       	brcs	.+2      	; 0x1be2 <__vector_77+0xd6>
    1be0:	60 e0       	ldi	r22, 0x00	; 0
    1be2:	ca 0e       	add	r12, r26
    1be4:	51 e0       	ldi	r21, 0x01	; 1
    1be6:	ca 16       	cp	r12, r26
    1be8:	08 f0       	brcs	.+2      	; 0x1bec <__vector_77+0xe0>
    1bea:	50 e0       	ldi	r21, 0x00	; 0
    1bec:	a6 2f       	mov	r26, r22
    1bee:	ac 0d       	add	r26, r12
    1bf0:	61 e0       	ldi	r22, 0x01	; 1
    1bf2:	ac 15       	cp	r26, r12
    1bf4:	08 f0       	brcs	.+2      	; 0x1bf8 <__vector_77+0xec>
    1bf6:	60 e0       	ldi	r22, 0x00	; 0
    1bf8:	56 2b       	or	r21, r22
    1bfa:	df 0e       	add	r13, r31
    1bfc:	61 e0       	ldi	r22, 0x01	; 1
    1bfe:	df 16       	cp	r13, r31
    1c00:	08 f0       	brcs	.+2      	; 0x1c04 <__vector_77+0xf8>
    1c02:	60 e0       	ldi	r22, 0x00	; 0
    1c04:	f5 2f       	mov	r31, r21
    1c06:	fd 0d       	add	r31, r13
    1c08:	51 e0       	ldi	r21, 0x01	; 1
    1c0a:	fd 15       	cp	r31, r13
    1c0c:	08 f0       	brcs	.+2      	; 0x1c10 <__vector_77+0x104>
    1c0e:	50 e0       	ldi	r21, 0x00	; 0
    1c10:	65 2b       	or	r22, r21
    1c12:	ee 0e       	add	r14, r30
    1c14:	51 e0       	ldi	r21, 0x01	; 1
    1c16:	ee 16       	cp	r14, r30
    1c18:	08 f0       	brcs	.+2      	; 0x1c1c <__vector_77+0x110>
    1c1a:	50 e0       	ldi	r21, 0x00	; 0
    1c1c:	e6 2f       	mov	r30, r22
    1c1e:	ee 0d       	add	r30, r14
    1c20:	61 e0       	ldi	r22, 0x01	; 1
    1c22:	ee 15       	cp	r30, r14
    1c24:	08 f0       	brcs	.+2      	; 0x1c28 <__vector_77+0x11c>
    1c26:	60 e0       	ldi	r22, 0x00	; 0
    1c28:	56 2b       	or	r21, r22
    1c2a:	f6 0c       	add	r15, r6
    1c2c:	71 e0       	ldi	r23, 0x01	; 1
    1c2e:	f6 14       	cp	r15, r6
    1c30:	08 f0       	brcs	.+2      	; 0x1c34 <__vector_77+0x128>
    1c32:	70 e0       	ldi	r23, 0x00	; 0
    1c34:	b5 2f       	mov	r27, r21
    1c36:	bf 0d       	add	r27, r15
    1c38:	51 e0       	ldi	r21, 0x01	; 1
    1c3a:	bf 15       	cp	r27, r15
    1c3c:	08 f0       	brcs	.+2      	; 0x1c40 <__vector_77+0x134>
    1c3e:	50 e0       	ldi	r21, 0x00	; 0
    1c40:	75 2b       	or	r23, r21
    1c42:	07 0d       	add	r16, r7
    1c44:	61 e0       	ldi	r22, 0x01	; 1
    1c46:	07 15       	cp	r16, r7
    1c48:	08 f0       	brcs	.+2      	; 0x1c4c <__vector_77+0x140>
    1c4a:	60 e0       	ldi	r22, 0x00	; 0
    1c4c:	70 0f       	add	r23, r16
    1c4e:	51 e0       	ldi	r21, 0x01	; 1
    1c50:	70 17       	cp	r23, r16
    1c52:	08 f0       	brcs	.+2      	; 0x1c56 <__vector_77+0x14a>
    1c54:	50 e0       	ldi	r21, 0x00	; 0
    1c56:	65 2b       	or	r22, r21
    1c58:	19 0d       	add	r17, r9
    1c5a:	51 e0       	ldi	r21, 0x01	; 1
    1c5c:	19 15       	cp	r17, r9
    1c5e:	08 f0       	brcs	.+2      	; 0x1c62 <__vector_77+0x156>
    1c60:	50 e0       	ldi	r21, 0x00	; 0
    1c62:	61 0f       	add	r22, r17
    1c64:	01 e0       	ldi	r16, 0x01	; 1
    1c66:	61 17       	cp	r22, r17
    1c68:	08 f0       	brcs	.+2      	; 0x1c6c <__vector_77+0x160>
    1c6a:	00 e0       	ldi	r16, 0x00	; 0
    1c6c:	50 2b       	or	r21, r16
    1c6e:	48 0d       	add	r20, r8
    1c70:	54 0f       	add	r21, r20
    1c72:	b9 82       	std	Y+1, r11	; 0x01
    1c74:	aa 83       	std	Y+2, r26	; 0x02
    1c76:	fb 83       	std	Y+3, r31	; 0x03
    1c78:	ec 83       	std	Y+4, r30	; 0x04
    1c7a:	bd 83       	std	Y+5, r27	; 0x05
    1c7c:	7e 83       	std	Y+6, r23	; 0x06
    1c7e:	6f 83       	std	Y+7, r22	; 0x07
    1c80:	58 87       	std	Y+8, r21	; 0x08
    1c82:	03 96       	adiw	r24, 0x03	; 3
ISR(TCD0_OVF_vect) {

	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1c84:	8c 30       	cpi	r24, 0x0C	; 12
    1c86:	91 05       	cpc	r25, r1
    1c88:	09 f0       	breq	.+2      	; 0x1c8c <__vector_77+0x180>
    1c8a:	74 cf       	rjmp	.-280    	; 0x1b74 <__vector_77+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    1c8c:	e9 80       	ldd	r14, Y+1	; 0x01
    1c8e:	fa 80       	ldd	r15, Y+2	; 0x02
    1c90:	0b 81       	ldd	r16, Y+3	; 0x03
    1c92:	1c 81       	ldd	r17, Y+4	; 0x04
    1c94:	bd 81       	ldd	r27, Y+5	; 0x05
    1c96:	ae 81       	ldd	r26, Y+6	; 0x06
    1c98:	ff 81       	ldd	r31, Y+7	; 0x07
    1c9a:	e8 85       	ldd	r30, Y+8	; 0x08
    1c9c:	2e 2d       	mov	r18, r14
    1c9e:	3f 2d       	mov	r19, r15
    1ca0:	40 2f       	mov	r20, r16
    1ca2:	51 2f       	mov	r21, r17
    1ca4:	6b 2f       	mov	r22, r27
    1ca6:	7a 2f       	mov	r23, r26
    1ca8:	8f 2f       	mov	r24, r31
    1caa:	9e 2f       	mov	r25, r30
    1cac:	ee 23       	and	r30, r30
    1cae:	0c f0       	brlt	.+2      	; 0x1cb2 <__vector_77+0x1a6>
    1cb0:	4a c0       	rjmp	.+148    	; 0x1d46 <__vector_77+0x23a>
    1cb2:	93 e0       	ldi	r25, 0x03	; 3
    1cb4:	e9 0e       	add	r14, r25
    1cb6:	91 e0       	ldi	r25, 0x01	; 1
    1cb8:	e2 16       	cp	r14, r18
    1cba:	08 f0       	brcs	.+2      	; 0x1cbe <__vector_77+0x1b2>
    1cbc:	90 e0       	ldi	r25, 0x00	; 0
    1cbe:	21 e0       	ldi	r18, 0x01	; 1
    1cc0:	f3 16       	cp	r15, r19
    1cc2:	08 f0       	brcs	.+2      	; 0x1cc6 <__vector_77+0x1ba>
    1cc4:	20 e0       	ldi	r18, 0x00	; 0
    1cc6:	39 2f       	mov	r19, r25
    1cc8:	3f 0d       	add	r19, r15
    1cca:	91 e0       	ldi	r25, 0x01	; 1
    1ccc:	3f 15       	cp	r19, r15
    1cce:	08 f0       	brcs	.+2      	; 0x1cd2 <__vector_77+0x1c6>
    1cd0:	90 e0       	ldi	r25, 0x00	; 0
    1cd2:	29 2b       	or	r18, r25
    1cd4:	91 e0       	ldi	r25, 0x01	; 1
    1cd6:	04 17       	cp	r16, r20
    1cd8:	08 f0       	brcs	.+2      	; 0x1cdc <__vector_77+0x1d0>
    1cda:	90 e0       	ldi	r25, 0x00	; 0
    1cdc:	42 2f       	mov	r20, r18
    1cde:	40 0f       	add	r20, r16
    1ce0:	21 e0       	ldi	r18, 0x01	; 1
    1ce2:	40 17       	cp	r20, r16
    1ce4:	08 f0       	brcs	.+2      	; 0x1ce8 <__vector_77+0x1dc>
    1ce6:	20 e0       	ldi	r18, 0x00	; 0
    1ce8:	92 2b       	or	r25, r18
    1cea:	21 e0       	ldi	r18, 0x01	; 1
    1cec:	15 17       	cp	r17, r21
    1cee:	08 f0       	brcs	.+2      	; 0x1cf2 <__vector_77+0x1e6>
    1cf0:	20 e0       	ldi	r18, 0x00	; 0
    1cf2:	59 2f       	mov	r21, r25
    1cf4:	51 0f       	add	r21, r17
    1cf6:	91 e0       	ldi	r25, 0x01	; 1
    1cf8:	51 17       	cp	r21, r17
    1cfa:	08 f0       	brcs	.+2      	; 0x1cfe <__vector_77+0x1f2>
    1cfc:	90 e0       	ldi	r25, 0x00	; 0
    1cfe:	29 2b       	or	r18, r25
    1d00:	91 e0       	ldi	r25, 0x01	; 1
    1d02:	b6 17       	cp	r27, r22
    1d04:	08 f0       	brcs	.+2      	; 0x1d08 <__vector_77+0x1fc>
    1d06:	90 e0       	ldi	r25, 0x00	; 0
    1d08:	62 2f       	mov	r22, r18
    1d0a:	6b 0f       	add	r22, r27
    1d0c:	21 e0       	ldi	r18, 0x01	; 1
    1d0e:	6b 17       	cp	r22, r27
    1d10:	08 f0       	brcs	.+2      	; 0x1d14 <__vector_77+0x208>
    1d12:	20 e0       	ldi	r18, 0x00	; 0
    1d14:	92 2b       	or	r25, r18
    1d16:	21 e0       	ldi	r18, 0x01	; 1
    1d18:	a7 17       	cp	r26, r23
    1d1a:	08 f0       	brcs	.+2      	; 0x1d1e <__vector_77+0x212>
    1d1c:	20 e0       	ldi	r18, 0x00	; 0
    1d1e:	79 2f       	mov	r23, r25
    1d20:	7a 0f       	add	r23, r26
    1d22:	91 e0       	ldi	r25, 0x01	; 1
    1d24:	7a 17       	cp	r23, r26
    1d26:	08 f0       	brcs	.+2      	; 0x1d2a <__vector_77+0x21e>
    1d28:	90 e0       	ldi	r25, 0x00	; 0
    1d2a:	29 2b       	or	r18, r25
    1d2c:	91 e0       	ldi	r25, 0x01	; 1
    1d2e:	f8 17       	cp	r31, r24
    1d30:	08 f0       	brcs	.+2      	; 0x1d34 <__vector_77+0x228>
    1d32:	90 e0       	ldi	r25, 0x00	; 0
    1d34:	82 2f       	mov	r24, r18
    1d36:	8f 0f       	add	r24, r31
    1d38:	21 e0       	ldi	r18, 0x01	; 1
    1d3a:	8f 17       	cp	r24, r31
    1d3c:	08 f0       	brcs	.+2      	; 0x1d40 <__vector_77+0x234>
    1d3e:	20 e0       	ldi	r18, 0x00	; 0
    1d40:	92 2b       	or	r25, r18
    1d42:	2e 2d       	mov	r18, r14
    1d44:	9e 0f       	add	r25, r30
    1d46:	02 e0       	ldi	r16, 0x02	; 2
    1d48:	0e 94 0c 2c 	call	0x5818	; 0x5818 <__ashrdi3>
    1d4c:	29 83       	std	Y+1, r18	; 0x01
    1d4e:	3a 83       	std	Y+2, r19	; 0x02
    1d50:	4b 83       	std	Y+3, r20	; 0x03
    1d52:	5c 83       	std	Y+4, r21	; 0x04
    1d54:	6d 83       	std	Y+5, r22	; 0x05
    1d56:	7e 83       	std	Y+6, r23	; 0x06
    1d58:	8f 83       	std	Y+7, r24	; 0x07
    1d5a:	98 87       	std	Y+8, r25	; 0x08
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1d5c:	80 90 63 50 	lds	r8, 0x5063
    1d60:	90 90 64 50 	lds	r9, 0x5064
    1d64:	a0 90 65 50 	lds	r10, 0x5065
    1d68:	b0 90 66 50 	lds	r11, 0x5066
    1d6c:	29 81       	ldd	r18, Y+1	; 0x01
    1d6e:	3a 81       	ldd	r19, Y+2	; 0x02
    1d70:	4b 81       	ldd	r20, Y+3	; 0x03
    1d72:	5c 81       	ldd	r21, Y+4	; 0x04
    1d74:	6d 81       	ldd	r22, Y+5	; 0x05
    1d76:	7e 81       	ldd	r23, Y+6	; 0x06
    1d78:	8f 81       	ldd	r24, Y+7	; 0x07
    1d7a:	98 85       	ldd	r25, Y+8	; 0x08
    1d7c:	f4 01       	movw	r30, r8
    1d7e:	ee 0f       	add	r30, r30
    1d80:	ff 1f       	adc	r31, r31
    1d82:	ee 0f       	add	r30, r30
    1d84:	ff 1f       	adc	r31, r31
    1d86:	80 90 61 50 	lds	r8, 0x5061
    1d8a:	90 90 62 50 	lds	r9, 0x5062
    1d8e:	8e 0e       	add	r8, r30
    1d90:	9f 1e       	adc	r9, r31
    1d92:	0f 2e       	mov	r0, r31
    1d94:	f0 ea       	ldi	r31, 0xA0	; 160
    1d96:	af 2e       	mov	r10, r31
    1d98:	f0 2d       	mov	r31, r0
    1d9a:	0f 2e       	mov	r0, r31
    1d9c:	f5 e2       	ldi	r31, 0x25	; 37
    1d9e:	bf 2e       	mov	r11, r31
    1da0:	f0 2d       	mov	r31, r0
    1da2:	0f 2e       	mov	r0, r31
    1da4:	f6 e2       	ldi	r31, 0x26	; 38
    1da6:	cf 2e       	mov	r12, r31
    1da8:	f0 2d       	mov	r31, r0
    1daa:	dd 24       	eor	r13, r13
    1dac:	ee 24       	eor	r14, r14
    1dae:	ff 24       	eor	r15, r15
    1db0:	00 e0       	ldi	r16, 0x00	; 0
    1db2:	10 e0       	ldi	r17, 0x00	; 0
    1db4:	0e 94 c5 2a 	call	0x558a	; 0x558a <__muldi3>
    1db8:	aa 24       	eor	r10, r10
    1dba:	aa 94       	dec	r10
    1dbc:	bb 24       	eor	r11, r11
    1dbe:	ba 94       	dec	r11
    1dc0:	0f 2e       	mov	r0, r31
    1dc2:	ff e7       	ldi	r31, 0x7F	; 127
    1dc4:	cf 2e       	mov	r12, r31
    1dc6:	f0 2d       	mov	r31, r0
    1dc8:	0e 94 74 2c 	call	0x58e8	; 0x58e8 <__divdi3>
    1dcc:	01 e0       	ldi	r16, 0x01	; 1
    1dce:	0e 94 98 2b 	call	0x5730	; 0x5730 <__ashldi3>
    1dd2:	0f 2e       	mov	r0, r31
    1dd4:	f3 e0       	ldi	r31, 0x03	; 3
    1dd6:	af 2e       	mov	r10, r31
    1dd8:	f0 2d       	mov	r31, r0
    1dda:	bb 24       	eor	r11, r11
    1ddc:	cc 24       	eor	r12, r12
    1dde:	00 e0       	ldi	r16, 0x00	; 0
    1de0:	0e 94 74 2c 	call	0x58e8	; 0x58e8 <__divdi3>
    1de4:	f4 01       	movw	r30, r8
    1de6:	20 83       	st	Z, r18
    1de8:	31 83       	std	Z+1, r19	; 0x01
    1dea:	42 83       	std	Z+2, r20	; 0x02
    1dec:	53 83       	std	Z+3, r21	; 0x03
	sampleCount++;
    1dee:	80 91 63 50 	lds	r24, 0x5063
    1df2:	90 91 64 50 	lds	r25, 0x5064
    1df6:	a0 91 65 50 	lds	r26, 0x5065
    1dfa:	b0 91 66 50 	lds	r27, 0x5066
    1dfe:	01 96       	adiw	r24, 0x01	; 1
    1e00:	a1 1d       	adc	r26, r1
    1e02:	b1 1d       	adc	r27, r1
    1e04:	80 93 63 50 	sts	0x5063, r24
    1e08:	90 93 64 50 	sts	0x5064, r25
    1e0c:	a0 93 65 50 	sts	0x5065, r26
    1e10:	b0 93 66 50 	sts	0x5066, r27
}
    1e14:	2c 96       	adiw	r28, 0x0c	; 12
    1e16:	cd bf       	out	0x3d, r28	; 61
    1e18:	de bf       	out	0x3e, r29	; 62
    1e1a:	df 91       	pop	r29
    1e1c:	cf 91       	pop	r28
    1e1e:	ff 91       	pop	r31
    1e20:	ef 91       	pop	r30
    1e22:	bf 91       	pop	r27
    1e24:	af 91       	pop	r26
    1e26:	9f 91       	pop	r25
    1e28:	8f 91       	pop	r24
    1e2a:	7f 91       	pop	r23
    1e2c:	6f 91       	pop	r22
    1e2e:	5f 91       	pop	r21
    1e30:	4f 91       	pop	r20
    1e32:	3f 91       	pop	r19
    1e34:	2f 91       	pop	r18
    1e36:	1f 91       	pop	r17
    1e38:	0f 91       	pop	r16
    1e3a:	ff 90       	pop	r15
    1e3c:	ef 90       	pop	r14
    1e3e:	df 90       	pop	r13
    1e40:	cf 90       	pop	r12
    1e42:	bf 90       	pop	r11
    1e44:	af 90       	pop	r10
    1e46:	9f 90       	pop	r9
    1e48:	8f 90       	pop	r8
    1e4a:	7f 90       	pop	r7
    1e4c:	6f 90       	pop	r6
    1e4e:	0f 90       	pop	r0
    1e50:	0b be       	out	0x3b, r0	; 59
    1e52:	0f 90       	pop	r0
    1e54:	0f be       	out	0x3f, r0	; 63
    1e56:	0f 90       	pop	r0
    1e58:	1f 90       	pop	r1
    1e5a:	18 95       	reti

00001e5c <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
	
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1e5c:	82 e0       	ldi	r24, 0x02	; 2
    1e5e:	e0 ea       	ldi	r30, 0xA0	; 160
    1e60:	f6 e0       	ldi	r31, 0x06	; 6
    1e62:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1e64:	8a ea       	ldi	r24, 0xAA	; 170
    1e66:	e0 ec       	ldi	r30, 0xC0	; 192
    1e68:	f8 e0       	ldi	r31, 0x08	; 8
    1e6a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1e6c:	82 81       	ldd	r24, Z+2	; 0x02
    1e6e:	88 23       	and	r24, r24
    1e70:	ec f7       	brge	.-6      	; 0x1e6c <sampleCurrentChannel+0x10>
	SPIBuffer[SPICount] = SPIC.DATA;
    1e72:	90 91 9e 50 	lds	r25, 0x509E
    1e76:	e0 ec       	ldi	r30, 0xC0	; 192
    1e78:	f8 e0       	ldi	r31, 0x08	; 8
    1e7a:	83 81       	ldd	r24, Z+3	; 0x03
    1e7c:	a0 e2       	ldi	r26, 0x20	; 32
    1e7e:	be e3       	ldi	r27, 0x3E	; 62
    1e80:	a9 0f       	add	r26, r25
    1e82:	b1 1d       	adc	r27, r1
    1e84:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1e86:	8a ea       	ldi	r24, 0xAA	; 170
    1e88:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1e8a:	82 81       	ldd	r24, Z+2	; 0x02
    1e8c:	88 23       	and	r24, r24
    1e8e:	ec f7       	brge	.-6      	; 0x1e8a <sampleCurrentChannel+0x2e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    1e90:	a0 91 9e 50 	lds	r26, 0x509E
    1e94:	b0 e0       	ldi	r27, 0x00	; 0
    1e96:	e0 ec       	ldi	r30, 0xC0	; 192
    1e98:	f8 e0       	ldi	r31, 0x08	; 8
    1e9a:	83 81       	ldd	r24, Z+3	; 0x03
    1e9c:	af 5d       	subi	r26, 0xDF	; 223
    1e9e:	b1 4c       	sbci	r27, 0xC1	; 193
    1ea0:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1ea2:	8a ea       	ldi	r24, 0xAA	; 170
    1ea4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1ea6:	82 81       	ldd	r24, Z+2	; 0x02
    1ea8:	88 23       	and	r24, r24
    1eaa:	ec f7       	brge	.-6      	; 0x1ea6 <sampleCurrentChannel+0x4a>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    1eac:	e0 91 9e 50 	lds	r30, 0x509E
    1eb0:	f0 e0       	ldi	r31, 0x00	; 0
    1eb2:	a0 ec       	ldi	r26, 0xC0	; 192
    1eb4:	b8 e0       	ldi	r27, 0x08	; 8
    1eb6:	13 96       	adiw	r26, 0x03	; 3
    1eb8:	8c 91       	ld	r24, X
    1eba:	13 97       	sbiw	r26, 0x03	; 3
    1ebc:	ee 5d       	subi	r30, 0xDE	; 222
    1ebe:	f1 4c       	sbci	r31, 0xC1	; 193
    1ec0:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1ec2:	82 e0       	ldi	r24, 0x02	; 2
    1ec4:	e0 ea       	ldi	r30, 0xA0	; 160
    1ec6:	f6 e0       	ldi	r31, 0x06	; 6
    1ec8:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
    1eca:	80 91 9e 50 	lds	r24, 0x509E
    1ece:	8d 5f       	subi	r24, 0xFD	; 253
    1ed0:	80 93 9e 50 	sts	0x509E, r24
}
    1ed4:	08 95       	ret

00001ed6 <__vector_82>:
ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point
ISR(TCD0_CCD_vect) {
    1ed6:	1f 92       	push	r1
    1ed8:	0f 92       	push	r0
    1eda:	0f b6       	in	r0, 0x3f	; 63
    1edc:	0f 92       	push	r0
    1ede:	0b b6       	in	r0, 0x3b	; 59
    1ee0:	0f 92       	push	r0
    1ee2:	11 24       	eor	r1, r1
    1ee4:	2f 93       	push	r18
    1ee6:	3f 93       	push	r19
    1ee8:	4f 93       	push	r20
    1eea:	5f 93       	push	r21
    1eec:	6f 93       	push	r22
    1eee:	7f 93       	push	r23
    1ef0:	8f 93       	push	r24
    1ef2:	9f 93       	push	r25
    1ef4:	af 93       	push	r26
    1ef6:	bf 93       	push	r27
    1ef8:	ef 93       	push	r30
    1efa:	ff 93       	push	r31
	sampleCurrentChannel();
    1efc:	0e 94 2e 0f 	call	0x1e5c	; 0x1e5c <sampleCurrentChannel>
	SPICount = 0;
    1f00:	10 92 9e 50 	sts	0x509E, r1
}
    1f04:	ff 91       	pop	r31
    1f06:	ef 91       	pop	r30
    1f08:	bf 91       	pop	r27
    1f0a:	af 91       	pop	r26
    1f0c:	9f 91       	pop	r25
    1f0e:	8f 91       	pop	r24
    1f10:	7f 91       	pop	r23
    1f12:	6f 91       	pop	r22
    1f14:	5f 91       	pop	r21
    1f16:	4f 91       	pop	r20
    1f18:	3f 91       	pop	r19
    1f1a:	2f 91       	pop	r18
    1f1c:	0f 90       	pop	r0
    1f1e:	0b be       	out	0x3b, r0	; 59
    1f20:	0f 90       	pop	r0
    1f22:	0f be       	out	0x3f, r0	; 63
    1f24:	0f 90       	pop	r0
    1f26:	1f 90       	pop	r1
    1f28:	18 95       	reti

00001f2a <__vector_81>:
ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCD0_CCC_vect) {
    1f2a:	1f 92       	push	r1
    1f2c:	0f 92       	push	r0
    1f2e:	0f b6       	in	r0, 0x3f	; 63
    1f30:	0f 92       	push	r0
    1f32:	0b b6       	in	r0, 0x3b	; 59
    1f34:	0f 92       	push	r0
    1f36:	11 24       	eor	r1, r1
    1f38:	2f 93       	push	r18
    1f3a:	3f 93       	push	r19
    1f3c:	4f 93       	push	r20
    1f3e:	5f 93       	push	r21
    1f40:	6f 93       	push	r22
    1f42:	7f 93       	push	r23
    1f44:	8f 93       	push	r24
    1f46:	9f 93       	push	r25
    1f48:	af 93       	push	r26
    1f4a:	bf 93       	push	r27
    1f4c:	ef 93       	push	r30
    1f4e:	ff 93       	push	r31
	sampleCurrentChannel();
    1f50:	0e 94 2e 0f 	call	0x1e5c	; 0x1e5c <sampleCurrentChannel>
}
    1f54:	ff 91       	pop	r31
    1f56:	ef 91       	pop	r30
    1f58:	bf 91       	pop	r27
    1f5a:	af 91       	pop	r26
    1f5c:	9f 91       	pop	r25
    1f5e:	8f 91       	pop	r24
    1f60:	7f 91       	pop	r23
    1f62:	6f 91       	pop	r22
    1f64:	5f 91       	pop	r21
    1f66:	4f 91       	pop	r20
    1f68:	3f 91       	pop	r19
    1f6a:	2f 91       	pop	r18
    1f6c:	0f 90       	pop	r0
    1f6e:	0b be       	out	0x3b, r0	; 59
    1f70:	0f 90       	pop	r0
    1f72:	0f be       	out	0x3f, r0	; 63
    1f74:	0f 90       	pop	r0
    1f76:	1f 90       	pop	r1
    1f78:	18 95       	reti

00001f7a <__vector_80>:
//first averaging point
ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}
//second averaging point
ISR(TCD0_CCB_vect) {
    1f7a:	1f 92       	push	r1
    1f7c:	0f 92       	push	r0
    1f7e:	0f b6       	in	r0, 0x3f	; 63
    1f80:	0f 92       	push	r0
    1f82:	0b b6       	in	r0, 0x3b	; 59
    1f84:	0f 92       	push	r0
    1f86:	11 24       	eor	r1, r1
    1f88:	2f 93       	push	r18
    1f8a:	3f 93       	push	r19
    1f8c:	4f 93       	push	r20
    1f8e:	5f 93       	push	r21
    1f90:	6f 93       	push	r22
    1f92:	7f 93       	push	r23
    1f94:	8f 93       	push	r24
    1f96:	9f 93       	push	r25
    1f98:	af 93       	push	r26
    1f9a:	bf 93       	push	r27
    1f9c:	ef 93       	push	r30
    1f9e:	ff 93       	push	r31
	sampleCurrentChannel();
    1fa0:	0e 94 2e 0f 	call	0x1e5c	; 0x1e5c <sampleCurrentChannel>
}
    1fa4:	ff 91       	pop	r31
    1fa6:	ef 91       	pop	r30
    1fa8:	bf 91       	pop	r27
    1faa:	af 91       	pop	r26
    1fac:	9f 91       	pop	r25
    1fae:	8f 91       	pop	r24
    1fb0:	7f 91       	pop	r23
    1fb2:	6f 91       	pop	r22
    1fb4:	5f 91       	pop	r21
    1fb6:	4f 91       	pop	r20
    1fb8:	3f 91       	pop	r19
    1fba:	2f 91       	pop	r18
    1fbc:	0f 90       	pop	r0
    1fbe:	0b be       	out	0x3b, r0	; 59
    1fc0:	0f 90       	pop	r0
    1fc2:	0f be       	out	0x3f, r0	; 63
    1fc4:	0f 90       	pop	r0
    1fc6:	1f 90       	pop	r1
    1fc8:	18 95       	reti

00001fca <__vector_79>:
// 	enableADCMUX(FALSE);
	
}

//first averaging point
ISR(TCD0_CCA_vect) {
    1fca:	1f 92       	push	r1
    1fcc:	0f 92       	push	r0
    1fce:	0f b6       	in	r0, 0x3f	; 63
    1fd0:	0f 92       	push	r0
    1fd2:	0b b6       	in	r0, 0x3b	; 59
    1fd4:	0f 92       	push	r0
    1fd6:	11 24       	eor	r1, r1
    1fd8:	2f 93       	push	r18
    1fda:	3f 93       	push	r19
    1fdc:	4f 93       	push	r20
    1fde:	5f 93       	push	r21
    1fe0:	6f 93       	push	r22
    1fe2:	7f 93       	push	r23
    1fe4:	8f 93       	push	r24
    1fe6:	9f 93       	push	r25
    1fe8:	af 93       	push	r26
    1fea:	bf 93       	push	r27
    1fec:	ef 93       	push	r30
    1fee:	ff 93       	push	r31
	sampleCurrentChannel();
    1ff0:	0e 94 2e 0f 	call	0x1e5c	; 0x1e5c <sampleCurrentChannel>
}
    1ff4:	ff 91       	pop	r31
    1ff6:	ef 91       	pop	r30
    1ff8:	bf 91       	pop	r27
    1ffa:	af 91       	pop	r26
    1ffc:	9f 91       	pop	r25
    1ffe:	8f 91       	pop	r24
    2000:	7f 91       	pop	r23
    2002:	6f 91       	pop	r22
    2004:	5f 91       	pop	r21
    2006:	4f 91       	pop	r20
    2008:	3f 91       	pop	r19
    200a:	2f 91       	pop	r18
    200c:	0f 90       	pop	r0
    200e:	0b be       	out	0x3b, r0	; 59
    2010:	0f 90       	pop	r0
    2012:	0f be       	out	0x3f, r0	; 63
    2014:	0f 90       	pop	r0
    2016:	1f 90       	pop	r1
    2018:	18 95       	reti

0000201a <__vector_19>:
ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    201a:	1f 92       	push	r1
    201c:	0f 92       	push	r0
    201e:	0f b6       	in	r0, 0x3f	; 63
    2020:	0f 92       	push	r0
    2022:	0b b6       	in	r0, 0x3b	; 59
    2024:	0f 92       	push	r0
    2026:	11 24       	eor	r1, r1
    2028:	2f 93       	push	r18
    202a:	3f 93       	push	r19
    202c:	4f 93       	push	r20
    202e:	5f 93       	push	r21
    2030:	6f 93       	push	r22
    2032:	7f 93       	push	r23
    2034:	8f 93       	push	r24
    2036:	9f 93       	push	r25
    2038:	af 93       	push	r26
    203a:	bf 93       	push	r27
    203c:	ef 93       	push	r30
    203e:	ff 93       	push	r31
	sampleCurrentChannel();
    2040:	0e 94 2e 0f 	call	0x1e5c	; 0x1e5c <sampleCurrentChannel>
	SPICount = 0;
    2044:	10 92 9e 50 	sts	0x509E, r1
	if(PORTB.OUT & PIN1_bm) {
    2048:	e0 e2       	ldi	r30, 0x20	; 32
    204a:	f6 e0       	ldi	r31, 0x06	; 6
    204c:	84 81       	ldd	r24, Z+4	; 0x04
    204e:	81 ff       	sbrs	r24, 1
    2050:	0f c0       	rjmp	.+30     	; 0x2070 <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    2052:	e0 e0       	ldi	r30, 0x00	; 0
    2054:	f6 e0       	ldi	r31, 0x06	; 6
    2056:	84 81       	ldd	r24, Z+4	; 0x04
    2058:	86 ff       	sbrs	r24, 6
    205a:	05 c0       	rjmp	.+10     	; 0x2066 <__vector_19+0x4c>
    205c:	82 e0       	ldi	r24, 0x02	; 2
    205e:	e0 e2       	ldi	r30, 0x20	; 32
    2060:	f6 e0       	ldi	r31, 0x06	; 6
    2062:	87 83       	std	Z+7, r24	; 0x07
    2064:	0d c0       	rjmp	.+26     	; 0x2080 <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
    2066:	80 e4       	ldi	r24, 0x40	; 64
    2068:	e0 e0       	ldi	r30, 0x00	; 0
    206a:	f6 e0       	ldi	r31, 0x06	; 6
    206c:	87 83       	std	Z+7, r24	; 0x07
    206e:	08 c0       	rjmp	.+16     	; 0x2080 <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    2070:	80 e4       	ldi	r24, 0x40	; 64
    2072:	e0 e0       	ldi	r30, 0x00	; 0
    2074:	f6 e0       	ldi	r31, 0x06	; 6
    2076:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
    2078:	82 e0       	ldi	r24, 0x02	; 2
    207a:	e0 e2       	ldi	r30, 0x20	; 32
    207c:	f6 e0       	ldi	r31, 0x06	; 6
    207e:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
    2080:	ff 91       	pop	r31
    2082:	ef 91       	pop	r30
    2084:	bf 91       	pop	r27
    2086:	af 91       	pop	r26
    2088:	9f 91       	pop	r25
    208a:	8f 91       	pop	r24
    208c:	7f 91       	pop	r23
    208e:	6f 91       	pop	r22
    2090:	5f 91       	pop	r21
    2092:	4f 91       	pop	r20
    2094:	3f 91       	pop	r19
    2096:	2f 91       	pop	r18
    2098:	0f 90       	pop	r0
    209a:	0b be       	out	0x3b, r0	; 59
    209c:	0f 90       	pop	r0
    209e:	0f be       	out	0x3f, r0	; 63
    20a0:	0f 90       	pop	r0
    20a2:	1f 90       	pop	r1
    20a4:	18 95       	reti

000020a6 <__vector_18>:
ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCC0_CCC_vect) {
    20a6:	1f 92       	push	r1
    20a8:	0f 92       	push	r0
    20aa:	0f b6       	in	r0, 0x3f	; 63
    20ac:	0f 92       	push	r0
    20ae:	0b b6       	in	r0, 0x3b	; 59
    20b0:	0f 92       	push	r0
    20b2:	11 24       	eor	r1, r1
    20b4:	2f 93       	push	r18
    20b6:	3f 93       	push	r19
    20b8:	4f 93       	push	r20
    20ba:	5f 93       	push	r21
    20bc:	6f 93       	push	r22
    20be:	7f 93       	push	r23
    20c0:	8f 93       	push	r24
    20c2:	9f 93       	push	r25
    20c4:	af 93       	push	r26
    20c6:	bf 93       	push	r27
    20c8:	ef 93       	push	r30
    20ca:	ff 93       	push	r31
	sampleCurrentChannel();
    20cc:	0e 94 2e 0f 	call	0x1e5c	; 0x1e5c <sampleCurrentChannel>
}
    20d0:	ff 91       	pop	r31
    20d2:	ef 91       	pop	r30
    20d4:	bf 91       	pop	r27
    20d6:	af 91       	pop	r26
    20d8:	9f 91       	pop	r25
    20da:	8f 91       	pop	r24
    20dc:	7f 91       	pop	r23
    20de:	6f 91       	pop	r22
    20e0:	5f 91       	pop	r21
    20e2:	4f 91       	pop	r20
    20e4:	3f 91       	pop	r19
    20e6:	2f 91       	pop	r18
    20e8:	0f 90       	pop	r0
    20ea:	0b be       	out	0x3b, r0	; 59
    20ec:	0f 90       	pop	r0
    20ee:	0f be       	out	0x3f, r0	; 63
    20f0:	0f 90       	pop	r0
    20f2:	1f 90       	pop	r1
    20f4:	18 95       	reti

000020f6 <__vector_17>:
ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

//second averaging point
ISR(TCC0_CCB_vect) {
    20f6:	1f 92       	push	r1
    20f8:	0f 92       	push	r0
    20fa:	0f b6       	in	r0, 0x3f	; 63
    20fc:	0f 92       	push	r0
    20fe:	0b b6       	in	r0, 0x3b	; 59
    2100:	0f 92       	push	r0
    2102:	11 24       	eor	r1, r1
    2104:	2f 93       	push	r18
    2106:	3f 93       	push	r19
    2108:	4f 93       	push	r20
    210a:	5f 93       	push	r21
    210c:	6f 93       	push	r22
    210e:	7f 93       	push	r23
    2110:	8f 93       	push	r24
    2112:	9f 93       	push	r25
    2114:	af 93       	push	r26
    2116:	bf 93       	push	r27
    2118:	ef 93       	push	r30
    211a:	ff 93       	push	r31
	sampleCurrentChannel();
    211c:	0e 94 2e 0f 	call	0x1e5c	; 0x1e5c <sampleCurrentChannel>
}
    2120:	ff 91       	pop	r31
    2122:	ef 91       	pop	r30
    2124:	bf 91       	pop	r27
    2126:	af 91       	pop	r26
    2128:	9f 91       	pop	r25
    212a:	8f 91       	pop	r24
    212c:	7f 91       	pop	r23
    212e:	6f 91       	pop	r22
    2130:	5f 91       	pop	r21
    2132:	4f 91       	pop	r20
    2134:	3f 91       	pop	r19
    2136:	2f 91       	pop	r18
    2138:	0f 90       	pop	r0
    213a:	0b be       	out	0x3b, r0	; 59
    213c:	0f 90       	pop	r0
    213e:	0f be       	out	0x3f, r0	; 63
    2140:	0f 90       	pop	r0
    2142:	1f 90       	pop	r1
    2144:	18 95       	reti

00002146 <__vector_16>:
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//first averaging point
ISR(TCC0_CCA_vect) {
    2146:	1f 92       	push	r1
    2148:	0f 92       	push	r0
    214a:	0f b6       	in	r0, 0x3f	; 63
    214c:	0f 92       	push	r0
    214e:	0b b6       	in	r0, 0x3b	; 59
    2150:	0f 92       	push	r0
    2152:	11 24       	eor	r1, r1
    2154:	2f 93       	push	r18
    2156:	3f 93       	push	r19
    2158:	4f 93       	push	r20
    215a:	5f 93       	push	r21
    215c:	6f 93       	push	r22
    215e:	7f 93       	push	r23
    2160:	8f 93       	push	r24
    2162:	9f 93       	push	r25
    2164:	af 93       	push	r26
    2166:	bf 93       	push	r27
    2168:	ef 93       	push	r30
    216a:	ff 93       	push	r31
	sampleCurrentChannel();
    216c:	0e 94 2e 0f 	call	0x1e5c	; 0x1e5c <sampleCurrentChannel>
}
    2170:	ff 91       	pop	r31
    2172:	ef 91       	pop	r30
    2174:	bf 91       	pop	r27
    2176:	af 91       	pop	r26
    2178:	9f 91       	pop	r25
    217a:	8f 91       	pop	r24
    217c:	7f 91       	pop	r23
    217e:	6f 91       	pop	r22
    2180:	5f 91       	pop	r21
    2182:	4f 91       	pop	r20
    2184:	3f 91       	pop	r19
    2186:	2f 91       	pop	r18
    2188:	0f 90       	pop	r0
    218a:	0b be       	out	0x3b, r0	; 59
    218c:	0f 90       	pop	r0
    218e:	0f be       	out	0x3f, r0	; 63
    2190:	0f 90       	pop	r0
    2192:	1f 90       	pop	r1
    2194:	18 95       	reti

00002196 <writeSE2FRAM>:
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    2196:	ff 92       	push	r15
    2198:	0f 93       	push	r16
    219a:	1f 93       	push	r17
    219c:	cf 93       	push	r28
    219e:	df 93       	push	r29
    21a0:	cd b7       	in	r28, 0x3d	; 61
    21a2:	de b7       	in	r29, 0x3e	; 62
    21a4:	28 97       	sbiw	r28, 0x08	; 8
    21a6:	cd bf       	out	0x3d, r28	; 61
    21a8:	de bf       	out	0x3e, r29	; 62

	volatile int32_t sum = 0;
    21aa:	19 82       	std	Y+1, r1	; 0x01
    21ac:	1a 82       	std	Y+2, r1	; 0x02
    21ae:	1b 82       	std	Y+3, r1	; 0x03
    21b0:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    21b2:	80 91 63 50 	lds	r24, 0x5063
    21b6:	90 91 64 50 	lds	r25, 0x5064
    21ba:	a0 91 65 50 	lds	r26, 0x5065
    21be:	b0 91 66 50 	lds	r27, 0x5066
    21c2:	01 96       	adiw	r24, 0x01	; 1
    21c4:	a1 1d       	adc	r26, r1
    21c6:	b1 1d       	adc	r27, r1
    21c8:	80 93 63 50 	sts	0x5063, r24
    21cc:	90 93 64 50 	sts	0x5064, r25
    21d0:	a0 93 65 50 	sts	0x5065, r26
    21d4:	b0 93 66 50 	sts	0x5066, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    21d8:	80 ed       	ldi	r24, 0xD0	; 208
    21da:	80 93 c0 08 	sts	0x08C0, r24
    21de:	20 e0       	ldi	r18, 0x00	; 0
    21e0:	30 e0       	ldi	r19, 0x00	; 0
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    21e2:	00 e2       	ldi	r16, 0x20	; 32
    21e4:	1e e3       	ldi	r17, 0x3E	; 62
    21e6:	ff 24       	eor	r15, r15
    21e8:	fa 94       	dec	r15
    21ea:	c9 01       	movw	r24, r18
    21ec:	f8 01       	movw	r30, r16
    21ee:	e2 0f       	add	r30, r18
    21f0:	f3 1f       	adc	r31, r19
    21f2:	40 81       	ld	r20, Z
    21f4:	44 23       	and	r20, r20
    21f6:	14 f4       	brge	.+4      	; 0x21fc <writeSE2FRAM+0x66>
    21f8:	f8 86       	std	Y+8, r15	; 0x08
    21fa:	01 c0       	rjmp	.+2      	; 0x21fe <writeSE2FRAM+0x68>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    21fc:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    21fe:	80 0f       	add	r24, r16
    2200:	91 1f       	adc	r25, r17
    2202:	fc 01       	movw	r30, r24
    2204:	80 81       	ld	r24, Z
    2206:	8f 83       	std	Y+7, r24	; 0x07
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    2208:	f9 01       	movw	r30, r18
    220a:	31 96       	adiw	r30, 0x01	; 1
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    220c:	e0 0f       	add	r30, r16
    220e:	f1 1f       	adc	r31, r17
    2210:	80 81       	ld	r24, Z
    2212:	8e 83       	std	Y+6, r24	; 0x06
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    2214:	f9 01       	movw	r30, r18
    2216:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2218:	e0 0f       	add	r30, r16
    221a:	f1 1f       	adc	r31, r17
    221c:	80 81       	ld	r24, Z
    221e:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    2220:	49 81       	ldd	r20, Y+1	; 0x01
    2222:	5a 81       	ldd	r21, Y+2	; 0x02
    2224:	6b 81       	ldd	r22, Y+3	; 0x03
    2226:	7c 81       	ldd	r23, Y+4	; 0x04
    2228:	8d 81       	ldd	r24, Y+5	; 0x05
    222a:	9e 81       	ldd	r25, Y+6	; 0x06
    222c:	af 81       	ldd	r26, Y+7	; 0x07
    222e:	b8 85       	ldd	r27, Y+8	; 0x08
    2230:	84 0f       	add	r24, r20
    2232:	95 1f       	adc	r25, r21
    2234:	a6 1f       	adc	r26, r22
    2236:	b7 1f       	adc	r27, r23
    2238:	89 83       	std	Y+1, r24	; 0x01
    223a:	9a 83       	std	Y+2, r25	; 0x02
    223c:	ab 83       	std	Y+3, r26	; 0x03
    223e:	bc 83       	std	Y+4, r27	; 0x04
    2240:	2d 5f       	subi	r18, 0xFD	; 253
    2242:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2244:	2c 30       	cpi	r18, 0x0C	; 12
    2246:	31 05       	cpc	r19, r1
    2248:	81 f6       	brne	.-96     	; 0x21ea <writeSE2FRAM+0x54>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    224a:	69 81       	ldd	r22, Y+1	; 0x01
    224c:	7a 81       	ldd	r23, Y+2	; 0x02
    224e:	8b 81       	ldd	r24, Y+3	; 0x03
    2250:	9c 81       	ldd	r25, Y+4	; 0x04
    2252:	24 e0       	ldi	r18, 0x04	; 4
    2254:	30 e0       	ldi	r19, 0x00	; 0
    2256:	40 e0       	ldi	r20, 0x00	; 0
    2258:	50 e0       	ldi	r21, 0x00	; 0
    225a:	0e 94 33 36 	call	0x6c66	; 0x6c66 <__divmodsi4>
    225e:	29 83       	std	Y+1, r18	; 0x01
    2260:	3a 83       	std	Y+2, r19	; 0x02
    2262:	4b 83       	std	Y+3, r20	; 0x03
    2264:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2266:	29 81       	ldd	r18, Y+1	; 0x01
    2268:	82 e2       	ldi	r24, 0x22	; 34
    226a:	9e e3       	ldi	r25, 0x3E	; 62
    226c:	20 93 22 3e 	sts	0x3E22, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2270:	2a 81       	ldd	r18, Y+2	; 0x02
    2272:	fc 01       	movw	r30, r24
    2274:	31 97       	sbiw	r30, 0x01	; 1
    2276:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    2278:	2b 81       	ldd	r18, Y+3	; 0x03
    227a:	02 97       	sbiw	r24, 0x02	; 2
    227c:	fc 01       	movw	r30, r24
    227e:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2280:	80 e1       	ldi	r24, 0x10	; 16
    2282:	e0 e4       	ldi	r30, 0x40	; 64
    2284:	f6 e0       	ldi	r31, 0x06	; 6
    2286:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2288:	88 e0       	ldi	r24, 0x08	; 8
    228a:	e0 e2       	ldi	r30, 0x20	; 32
    228c:	f6 e0       	ldi	r31, 0x06	; 6
    228e:	86 83       	std	Z+6, r24	; 0x06
	nop();
    2290:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2292:	86 e0       	ldi	r24, 0x06	; 6
    2294:	e0 ec       	ldi	r30, 0xC0	; 192
    2296:	f8 e0       	ldi	r31, 0x08	; 8
    2298:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    229a:	82 81       	ldd	r24, Z+2	; 0x02
    229c:	88 23       	and	r24, r24
    229e:	ec f7       	brge	.-6      	; 0x229a <writeSE2FRAM+0x104>
	SPIBuffer[12] = SPIC.DATA;
    22a0:	e0 ec       	ldi	r30, 0xC0	; 192
    22a2:	f8 e0       	ldi	r31, 0x08	; 8
    22a4:	83 81       	ldd	r24, Z+3	; 0x03
    22a6:	80 93 2c 3e 	sts	0x3E2C, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    22aa:	a0 e2       	ldi	r26, 0x20	; 32
    22ac:	b6 e0       	ldi	r27, 0x06	; 6
    22ae:	88 e0       	ldi	r24, 0x08	; 8
    22b0:	15 96       	adiw	r26, 0x05	; 5
    22b2:	8c 93       	st	X, r24
    22b4:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    22b6:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    22b8:	16 96       	adiw	r26, 0x06	; 6
    22ba:	8c 93       	st	X, r24
    22bc:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    22be:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    22c0:	82 e0       	ldi	r24, 0x02	; 2
    22c2:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    22c4:	82 81       	ldd	r24, Z+2	; 0x02
    22c6:	88 23       	and	r24, r24
    22c8:	ec f7       	brge	.-6      	; 0x22c4 <writeSE2FRAM+0x12e>
	SPIBuffer[12] = SPIC.DATA;
    22ca:	e0 ec       	ldi	r30, 0xC0	; 192
    22cc:	f8 e0       	ldi	r31, 0x08	; 8
    22ce:	83 81       	ldd	r24, Z+3	; 0x03
    22d0:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    22d4:	80 91 1e 3e 	lds	r24, 0x3E1E
    22d8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    22da:	82 81       	ldd	r24, Z+2	; 0x02
    22dc:	88 23       	and	r24, r24
    22de:	ec f7       	brge	.-6      	; 0x22da <writeSE2FRAM+0x144>
	SPIBuffer[12] = SPIC.DATA;
    22e0:	e0 ec       	ldi	r30, 0xC0	; 192
    22e2:	f8 e0       	ldi	r31, 0x08	; 8
    22e4:	83 81       	ldd	r24, Z+3	; 0x03
    22e6:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    22ea:	80 91 1d 3e 	lds	r24, 0x3E1D
    22ee:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    22f0:	82 81       	ldd	r24, Z+2	; 0x02
    22f2:	88 23       	and	r24, r24
    22f4:	ec f7       	brge	.-6      	; 0x22f0 <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    22f6:	e0 ec       	ldi	r30, 0xC0	; 192
    22f8:	f8 e0       	ldi	r31, 0x08	; 8
    22fa:	83 81       	ldd	r24, Z+3	; 0x03
    22fc:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = SPIBuffer[0];
    2300:	80 91 20 3e 	lds	r24, 0x3E20
    2304:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2306:	82 81       	ldd	r24, Z+2	; 0x02
    2308:	88 23       	and	r24, r24
    230a:	ec f7       	brge	.-6      	; 0x2306 <writeSE2FRAM+0x170>
	SPIBuffer[12] = SPIC.DATA;
    230c:	e0 ec       	ldi	r30, 0xC0	; 192
    230e:	f8 e0       	ldi	r31, 0x08	; 8
    2310:	83 81       	ldd	r24, Z+3	; 0x03
    2312:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = SPIBuffer[1];
    2316:	80 91 21 3e 	lds	r24, 0x3E21
    231a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    231c:	82 81       	ldd	r24, Z+2	; 0x02
    231e:	88 23       	and	r24, r24
    2320:	ec f7       	brge	.-6      	; 0x231c <writeSE2FRAM+0x186>
	SPIBuffer[12] = SPIC.DATA;
    2322:	e0 ec       	ldi	r30, 0xC0	; 192
    2324:	f8 e0       	ldi	r31, 0x08	; 8
    2326:	83 81       	ldd	r24, Z+3	; 0x03
    2328:	80 93 2c 3e 	sts	0x3E2C, r24
	SPIC.DATA = SPIBuffer[2];
    232c:	80 91 22 3e 	lds	r24, 0x3E22
    2330:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2332:	82 81       	ldd	r24, Z+2	; 0x02
    2334:	88 23       	and	r24, r24
    2336:	ec f7       	brge	.-6      	; 0x2332 <writeSE2FRAM+0x19c>
	SPIBuffer[12] = SPIC.DATA;
    2338:	a0 ec       	ldi	r26, 0xC0	; 192
    233a:	b8 e0       	ldi	r27, 0x08	; 8
    233c:	13 96       	adiw	r26, 0x03	; 3
    233e:	8c 91       	ld	r24, X
    2340:	13 97       	sbiw	r26, 0x03	; 3
    2342:	80 93 2c 3e 	sts	0x3E2C, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2346:	88 e0       	ldi	r24, 0x08	; 8
    2348:	e0 e2       	ldi	r30, 0x20	; 32
    234a:	f6 e0       	ldi	r31, 0x06	; 6
    234c:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    234e:	e0 e4       	ldi	r30, 0x40	; 64
    2350:	f6 e0       	ldi	r31, 0x06	; 6
    2352:	80 e1       	ldi	r24, 0x10	; 16
    2354:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2356:	94 e5       	ldi	r25, 0x54	; 84
    2358:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    235a:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    235c:	80 91 1d 3e 	lds	r24, 0x3E1D
    2360:	90 91 1e 3e 	lds	r25, 0x3E1E
    2364:	03 96       	adiw	r24, 0x03	; 3
    2366:	80 93 1d 3e 	sts	0x3E1D, r24
    236a:	90 93 1e 3e 	sts	0x3E1E, r25
	checksumADC[0] += SPIBuffer[0];
    236e:	80 91 11 21 	lds	r24, 0x2111
    2372:	e0 e2       	ldi	r30, 0x20	; 32
    2374:	fe e3       	ldi	r31, 0x3E	; 62
    2376:	90 81       	ld	r25, Z
    2378:	89 0f       	add	r24, r25
    237a:	80 93 11 21 	sts	0x2111, r24
	checksumADC[1] += SPIBuffer[1];
    237e:	80 91 12 21 	lds	r24, 0x2112
    2382:	91 81       	ldd	r25, Z+1	; 0x01
    2384:	89 0f       	add	r24, r25
    2386:	80 93 12 21 	sts	0x2112, r24
	checksumADC[2] += SPIBuffer[2];
    238a:	80 91 13 21 	lds	r24, 0x2113
    238e:	92 81       	ldd	r25, Z+2	; 0x02
    2390:	89 0f       	add	r24, r25
    2392:	80 93 13 21 	sts	0x2113, r24
}
    2396:	28 96       	adiw	r28, 0x08	; 8
    2398:	cd bf       	out	0x3d, r28	; 61
    239a:	de bf       	out	0x3e, r29	; 62
    239c:	df 91       	pop	r29
    239e:	cf 91       	pop	r28
    23a0:	1f 91       	pop	r17
    23a2:	0f 91       	pop	r16
    23a4:	ff 90       	pop	r15
    23a6:	08 95       	ret

000023a8 <FRAMWriteKnowns>:
// 	}
// 	
// }

//test function for FRAM
void FRAMWriteKnowns() {
    23a8:	2f 92       	push	r2
    23aa:	3f 92       	push	r3
    23ac:	4f 92       	push	r4
    23ae:	5f 92       	push	r5
    23b0:	6f 92       	push	r6
    23b2:	7f 92       	push	r7
    23b4:	8f 92       	push	r8
    23b6:	9f 92       	push	r9
    23b8:	af 92       	push	r10
    23ba:	bf 92       	push	r11
    23bc:	cf 92       	push	r12
    23be:	df 92       	push	r13
    23c0:	ef 92       	push	r14
    23c2:	ff 92       	push	r15
    23c4:	0f 93       	push	r16
    23c6:	1f 93       	push	r17
    23c8:	cf 93       	push	r28
    23ca:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    23cc:	10 92 1d 3e 	sts	0x3E1D, r1
    23d0:	10 92 1e 3e 	sts	0x3E1E, r1
	sampleCount = 0;
    23d4:	10 92 63 50 	sts	0x5063, r1
    23d8:	10 92 64 50 	sts	0x5064, r1
    23dc:	10 92 65 50 	sts	0x5065, r1
    23e0:	10 92 66 50 	sts	0x5066, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    23e4:	83 e1       	ldi	r24, 0x13	; 19
    23e6:	91 e2       	ldi	r25, 0x21	; 33
    23e8:	10 92 13 21 	sts	0x2113, r1
    23ec:	fc 01       	movw	r30, r24
    23ee:	31 97       	sbiw	r30, 0x01	; 1
    23f0:	10 82       	st	Z, r1
    23f2:	02 97       	sbiw	r24, 0x02	; 2
    23f4:	dc 01       	movw	r26, r24
    23f6:	1c 92       	st	X, r1
	
	ADCPower(TRUE);
    23f8:	81 e0       	ldi	r24, 0x01	; 1
    23fa:	0e 94 a3 05 	call	0xb46	; 0xb46 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    23fe:	84 e0       	ldi	r24, 0x04	; 4
    2400:	0e 94 ad 03 	call	0x75a	; 0x75a <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2404:	80 ed       	ldi	r24, 0xD0	; 208
    2406:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    240a:	8d e0       	ldi	r24, 0x0D	; 13
    240c:	80 93 20 3e 	sts	0x3E20, r24
	SPIBuffer[1] = 0xF3;
    2410:	83 ef       	ldi	r24, 0xF3	; 243
    2412:	80 93 21 3e 	sts	0x3E21, r24
	SPIBuffer[2] = 0x57;
    2416:	87 e5       	ldi	r24, 0x57	; 87
    2418:	80 93 22 3e 	sts	0x3E22, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    241c:	80 91 63 50 	lds	r24, 0x5063
    2420:	90 91 64 50 	lds	r25, 0x5064
    2424:	a0 91 65 50 	lds	r26, 0x5065
    2428:	b0 91 66 50 	lds	r27, 0x5066
    242c:	83 35       	cpi	r24, 0x53	; 83
    242e:	e5 e5       	ldi	r30, 0x55	; 85
    2430:	9e 07       	cpc	r25, r30
    2432:	e0 e0       	ldi	r30, 0x00	; 0
    2434:	ae 07       	cpc	r26, r30
    2436:	e0 e0       	ldi	r30, 0x00	; 0
    2438:	be 07       	cpc	r27, r30
    243a:	08 f0       	brcs	.+2      	; 0x243e <FRAMWriteKnowns+0x96>
    243c:	cc c0       	rjmp	.+408    	; 0x25d6 <FRAMWriteKnowns+0x22e>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    243e:	0f 2e       	mov	r0, r31
    2440:	f0 e4       	ldi	r31, 0x40	; 64
    2442:	ef 2e       	mov	r14, r31
    2444:	f6 e0       	ldi	r31, 0x06	; 6
    2446:	ff 2e       	mov	r15, r31
    2448:	f0 2d       	mov	r31, r0
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    244a:	40 e2       	ldi	r20, 0x20	; 32
    244c:	56 e0       	ldi	r21, 0x06	; 6
    244e:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    2450:	e0 ec       	ldi	r30, 0xC0	; 192
    2452:	f8 e0       	ldi	r31, 0x08	; 8
    2454:	0f 2e       	mov	r0, r31
    2456:	f6 e0       	ldi	r31, 0x06	; 6
    2458:	7f 2e       	mov	r7, r31
    245a:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    245c:	cc e2       	ldi	r28, 0x2C	; 44
    245e:	de e3       	ldi	r29, 0x3E	; 62
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    2460:	66 24       	eor	r6, r6
    2462:	68 94       	set
    2464:	61 f8       	bld	r6, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2466:	0f 2e       	mov	r0, r31
    2468:	fd e1       	ldi	r31, 0x1D	; 29
    246a:	cf 2e       	mov	r12, r31
    246c:	fe e3       	ldi	r31, 0x3E	; 62
    246e:	df 2e       	mov	r13, r31
    2470:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    2472:	8e 01       	movw	r16, r28
    2474:	0c 50       	subi	r16, 0x0C	; 12
    2476:	10 40       	sbci	r17, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    2478:	0f 2e       	mov	r0, r31
    247a:	f5 ef       	ldi	r31, 0xF5	; 245
    247c:	4f 2e       	mov	r4, r31
    247e:	ff ef       	ldi	r31, 0xFF	; 255
    2480:	5f 2e       	mov	r5, r31
    2482:	f0 2d       	mov	r31, r0
    2484:	4c 0e       	add	r4, r28
    2486:	5d 1e       	adc	r5, r29
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    2488:	0f 2e       	mov	r0, r31
    248a:	f6 ef       	ldi	r31, 0xF6	; 246
    248c:	2f 2e       	mov	r2, r31
    248e:	ff ef       	ldi	r31, 0xFF	; 255
    2490:	3f 2e       	mov	r3, r31
    2492:	f0 2d       	mov	r31, r0
    2494:	2c 0e       	add	r2, r28
    2496:	3d 1e       	adc	r3, r29
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    2498:	61 e1       	ldi	r22, 0x11	; 17
    249a:	71 e2       	ldi	r23, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    249c:	5b 01       	movw	r10, r22
    249e:	08 94       	sec
    24a0:	a1 1c       	adc	r10, r1
    24a2:	b1 1c       	adc	r11, r1
		checksumADC[2] += SPIBuffer[2];
    24a4:	88 24       	eor	r8, r8
    24a6:	99 24       	eor	r9, r9
    24a8:	68 94       	set
    24aa:	81 f8       	bld	r8, 1
    24ac:	86 0e       	add	r8, r22
    24ae:	97 1e       	adc	r9, r23
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    24b0:	30 e1       	ldi	r19, 0x10	; 16
    24b2:	d7 01       	movw	r26, r14
    24b4:	16 96       	adiw	r26, 0x06	; 6
    24b6:	3c 93       	st	X, r19
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    24b8:	da 01       	movw	r26, r20
    24ba:	16 96       	adiw	r26, 0x06	; 6
    24bc:	2c 93       	st	X, r18
    24be:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    24c0:	00 00       	nop
		SPIC.DATA = FR_WREN;
    24c2:	73 82       	std	Z+3, r7	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    24c4:	82 81       	ldd	r24, Z+2	; 0x02
    24c6:	88 23       	and	r24, r24
    24c8:	ec f7       	brge	.-6      	; 0x24c4 <FRAMWriteKnowns+0x11c>
		SPIBuffer[12] = SPIC.DATA;
    24ca:	83 81       	ldd	r24, Z+3	; 0x03
    24cc:	88 83       	st	Y, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    24ce:	da 01       	movw	r26, r20
    24d0:	15 96       	adiw	r26, 0x05	; 5
    24d2:	2c 93       	st	X, r18
    24d4:	15 97       	sbiw	r26, 0x05	; 5
		nop(); // time for CS_FRAM to accept high signal
    24d6:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    24d8:	16 96       	adiw	r26, 0x06	; 6
    24da:	2c 93       	st	X, r18
    24dc:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    24de:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    24e0:	63 82       	std	Z+3, r6	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    24e2:	82 81       	ldd	r24, Z+2	; 0x02
    24e4:	88 23       	and	r24, r24
    24e6:	ec f7       	brge	.-6      	; 0x24e2 <FRAMWriteKnowns+0x13a>
		SPIBuffer[12] = SPIC.DATA;
    24e8:	83 81       	ldd	r24, Z+3	; 0x03
    24ea:	88 83       	st	Y, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    24ec:	d6 01       	movw	r26, r12
    24ee:	11 96       	adiw	r26, 0x01	; 1
    24f0:	8c 91       	ld	r24, X
    24f2:	11 97       	sbiw	r26, 0x01	; 1
    24f4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    24f6:	82 81       	ldd	r24, Z+2	; 0x02
    24f8:	88 23       	and	r24, r24
    24fa:	ec f7       	brge	.-6      	; 0x24f6 <FRAMWriteKnowns+0x14e>
		SPIBuffer[12] = SPIC.DATA;
    24fc:	83 81       	ldd	r24, Z+3	; 0x03
    24fe:	88 83       	st	Y, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2500:	d6 01       	movw	r26, r12
    2502:	8c 91       	ld	r24, X
    2504:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2506:	82 81       	ldd	r24, Z+2	; 0x02
    2508:	88 23       	and	r24, r24
    250a:	ec f7       	brge	.-6      	; 0x2506 <FRAMWriteKnowns+0x15e>
		SPIBuffer[12] = SPIC.DATA;
    250c:	83 81       	ldd	r24, Z+3	; 0x03
    250e:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[0];
    2510:	d8 01       	movw	r26, r16
    2512:	8c 91       	ld	r24, X
    2514:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2516:	82 81       	ldd	r24, Z+2	; 0x02
    2518:	88 23       	and	r24, r24
    251a:	ec f7       	brge	.-6      	; 0x2516 <FRAMWriteKnowns+0x16e>
		SPIBuffer[12] = SPIC.DATA;
    251c:	83 81       	ldd	r24, Z+3	; 0x03
    251e:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[1];
    2520:	d2 01       	movw	r26, r4
    2522:	8c 91       	ld	r24, X
    2524:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2526:	82 81       	ldd	r24, Z+2	; 0x02
    2528:	88 23       	and	r24, r24
    252a:	ec f7       	brge	.-6      	; 0x2526 <FRAMWriteKnowns+0x17e>
		SPIBuffer[12] = SPIC.DATA;
    252c:	83 81       	ldd	r24, Z+3	; 0x03
    252e:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[2];
    2530:	d1 01       	movw	r26, r2
    2532:	8c 91       	ld	r24, X
    2534:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2536:	82 81       	ldd	r24, Z+2	; 0x02
    2538:	88 23       	and	r24, r24
    253a:	ec f7       	brge	.-6      	; 0x2536 <FRAMWriteKnowns+0x18e>
		SPIBuffer[12] = SPIC.DATA;
    253c:	83 81       	ldd	r24, Z+3	; 0x03
    253e:	88 83       	st	Y, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2540:	da 01       	movw	r26, r20
    2542:	15 96       	adiw	r26, 0x05	; 5
    2544:	2c 93       	st	X, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2546:	30 e1       	ldi	r19, 0x10	; 16
    2548:	d7 01       	movw	r26, r14
    254a:	15 96       	adiw	r26, 0x05	; 5
    254c:	3c 93       	st	X, r19
		
		FRAMAddress +=3;
    254e:	80 91 1d 3e 	lds	r24, 0x3E1D
    2552:	90 91 1e 3e 	lds	r25, 0x3E1E
    2556:	03 96       	adiw	r24, 0x03	; 3
    2558:	80 93 1d 3e 	sts	0x3E1D, r24
    255c:	90 93 1e 3e 	sts	0x3E1E, r25
		checksumADC[0] += SPIBuffer[0];
    2560:	db 01       	movw	r26, r22
    2562:	8c 91       	ld	r24, X
    2564:	d8 01       	movw	r26, r16
    2566:	9c 91       	ld	r25, X
    2568:	89 0f       	add	r24, r25
    256a:	db 01       	movw	r26, r22
    256c:	8c 93       	st	X, r24
		checksumADC[1] += SPIBuffer[1];
    256e:	d5 01       	movw	r26, r10
    2570:	8c 91       	ld	r24, X
    2572:	a1 e2       	ldi	r26, 0x21	; 33
    2574:	be e3       	ldi	r27, 0x3E	; 62
    2576:	9c 91       	ld	r25, X
    2578:	89 0f       	add	r24, r25
    257a:	d5 01       	movw	r26, r10
    257c:	8c 93       	st	X, r24
		checksumADC[2] += SPIBuffer[2];
    257e:	d4 01       	movw	r26, r8
    2580:	8c 91       	ld	r24, X
    2582:	a2 e2       	ldi	r26, 0x22	; 34
    2584:	be e3       	ldi	r27, 0x3E	; 62
    2586:	9c 91       	ld	r25, X
    2588:	89 0f       	add	r24, r25
    258a:	d4 01       	movw	r26, r8
    258c:	8c 93       	st	X, r24
		
		sampleCount++;
    258e:	80 91 63 50 	lds	r24, 0x5063
    2592:	90 91 64 50 	lds	r25, 0x5064
    2596:	a0 91 65 50 	lds	r26, 0x5065
    259a:	b0 91 66 50 	lds	r27, 0x5066
    259e:	01 96       	adiw	r24, 0x01	; 1
    25a0:	a1 1d       	adc	r26, r1
    25a2:	b1 1d       	adc	r27, r1
    25a4:	80 93 63 50 	sts	0x5063, r24
    25a8:	90 93 64 50 	sts	0x5064, r25
    25ac:	a0 93 65 50 	sts	0x5065, r26
    25b0:	b0 93 66 50 	sts	0x5066, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    25b4:	80 91 63 50 	lds	r24, 0x5063
    25b8:	90 91 64 50 	lds	r25, 0x5064
    25bc:	a0 91 65 50 	lds	r26, 0x5065
    25c0:	b0 91 66 50 	lds	r27, 0x5066
    25c4:	83 35       	cpi	r24, 0x53	; 83
    25c6:	35 e5       	ldi	r19, 0x55	; 85
    25c8:	93 07       	cpc	r25, r19
    25ca:	30 e0       	ldi	r19, 0x00	; 0
    25cc:	a3 07       	cpc	r26, r19
    25ce:	30 e0       	ldi	r19, 0x00	; 0
    25d0:	b3 07       	cpc	r27, r19
    25d2:	08 f4       	brcc	.+2      	; 0x25d6 <FRAMWriteKnowns+0x22e>
    25d4:	6d cf       	rjmp	.-294    	; 0x24b0 <FRAMWriteKnowns+0x108>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    25d6:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <SPIDisable>
	ADCPower(FALSE);
    25da:	80 e0       	ldi	r24, 0x00	; 0
    25dc:	0e 94 a3 05 	call	0xb46	; 0xb46 <ADCPower>
}
    25e0:	df 91       	pop	r29
    25e2:	cf 91       	pop	r28
    25e4:	1f 91       	pop	r17
    25e6:	0f 91       	pop	r16
    25e8:	ff 90       	pop	r15
    25ea:	ef 90       	pop	r14
    25ec:	df 90       	pop	r13
    25ee:	cf 90       	pop	r12
    25f0:	bf 90       	pop	r11
    25f2:	af 90       	pop	r10
    25f4:	9f 90       	pop	r9
    25f6:	8f 90       	pop	r8
    25f8:	7f 90       	pop	r7
    25fa:	6f 90       	pop	r6
    25fc:	5f 90       	pop	r5
    25fe:	4f 90       	pop	r4
    2600:	3f 90       	pop	r3
    2602:	2f 90       	pop	r2
    2604:	08 95       	ret

00002606 <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    2606:	80 ff       	sbrs	r24, 0
    2608:	05 c0       	rjmp	.+10     	; 0x2614 <setADCInput+0xe>
    260a:	20 e4       	ldi	r18, 0x40	; 64
    260c:	e0 e0       	ldi	r30, 0x00	; 0
    260e:	f6 e0       	ldi	r31, 0x06	; 6
    2610:	25 83       	std	Z+5, r18	; 0x05
    2612:	04 c0       	rjmp	.+8      	; 0x261c <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    2614:	20 e4       	ldi	r18, 0x40	; 64
    2616:	e0 e0       	ldi	r30, 0x00	; 0
    2618:	f6 e0       	ldi	r31, 0x06	; 6
    261a:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    261c:	81 ff       	sbrs	r24, 1
    261e:	05 c0       	rjmp	.+10     	; 0x262a <setADCInput+0x24>
    2620:	22 e0       	ldi	r18, 0x02	; 2
    2622:	e0 e2       	ldi	r30, 0x20	; 32
    2624:	f6 e0       	ldi	r31, 0x06	; 6
    2626:	25 83       	std	Z+5, r18	; 0x05
    2628:	04 c0       	rjmp	.+8      	; 0x2632 <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    262a:	22 e0       	ldi	r18, 0x02	; 2
    262c:	e0 e2       	ldi	r30, 0x20	; 32
    262e:	f6 e0       	ldi	r31, 0x06	; 6
    2630:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    2632:	82 ff       	sbrs	r24, 2
    2634:	05 c0       	rjmp	.+10     	; 0x2640 <setADCInput+0x3a>
    2636:	84 e0       	ldi	r24, 0x04	; 4
    2638:	e0 e2       	ldi	r30, 0x20	; 32
    263a:	f6 e0       	ldi	r31, 0x06	; 6
    263c:	85 83       	std	Z+5, r24	; 0x05
    263e:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    2640:	84 e0       	ldi	r24, 0x04	; 4
    2642:	e0 e2       	ldi	r30, 0x20	; 32
    2644:	f6 e0       	ldi	r31, 0x06	; 6
    2646:	86 83       	std	Z+6, r24	; 0x06
    2648:	08 95       	ret

0000264a <CO_collectSeismic1Channel_ext>:
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray);
}

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    264a:	2f 92       	push	r2
    264c:	3f 92       	push	r3
    264e:	4f 92       	push	r4
    2650:	5f 92       	push	r5
    2652:	7f 92       	push	r7
    2654:	8f 92       	push	r8
    2656:	9f 92       	push	r9
    2658:	af 92       	push	r10
    265a:	bf 92       	push	r11
    265c:	cf 92       	push	r12
    265e:	df 92       	push	r13
    2660:	ef 92       	push	r14
    2662:	ff 92       	push	r15
    2664:	0f 93       	push	r16
    2666:	1f 93       	push	r17
    2668:	cf 93       	push	r28
    266a:	df 93       	push	r29
    266c:	cd b7       	in	r28, 0x3d	; 61
    266e:	de b7       	in	r29, 0x3e	; 62
    2670:	18 2f       	mov	r17, r24
    2672:	76 2e       	mov	r7, r22
    2674:	f4 2e       	mov	r15, r20
    2676:	19 01       	movw	r2, r18
	
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif
	
	ADC_BUFFER=DataArray;
    2678:	89 8d       	ldd	r24, Y+25	; 0x19
    267a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    267c:	80 93 61 50 	sts	0x5061, r24
    2680:	90 93 62 50 	sts	0x5062, r25
	ADC_Sampling_Finished = 0;
    2684:	10 92 a4 50 	sts	0x50A4, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2688:	81 e0       	ldi	r24, 0x01	; 1
    268a:	0e 94 a3 05 	call	0xb46	; 0xb46 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    268e:	81 2f       	mov	r24, r17
    2690:	6f 2d       	mov	r22, r15
    2692:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <set_ampGain>
	set_filter(filterConfig);
    2696:	87 2d       	mov	r24, r7
    2698:	0e 94 e6 03 	call	0x7cc	; 0x7cc <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    269c:	8e 2d       	mov	r24, r14
    269e:	0e 94 ce 0b 	call	0x179c	; 0x179c <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    26a2:	84 e0       	ldi	r24, 0x04	; 4
    26a4:	0e 94 ad 03 	call	0x75a	; 0x75a <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    26a8:	84 e5       	ldi	r24, 0x54	; 84
    26aa:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    26ae:	81 e0       	ldi	r24, 0x01	; 1
    26b0:	0e 94 22 0a 	call	0x1444	; 0x1444 <enableADCMUX>
	setADCInput(channel);
    26b4:	81 2f       	mov	r24, r17
    26b6:	0e 94 03 13 	call	0x2606	; 0x2606 <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    26ba:	e0 ea       	ldi	r30, 0xA0	; 160
    26bc:	f6 e0       	ldi	r31, 0x06	; 6
    26be:	22 e0       	ldi	r18, 0x02	; 2
    26c0:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    26c2:	77 24       	eor	r7, r7
    26c4:	73 94       	inc	r7
    26c6:	72 82       	std	Z+2, r7	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    26c8:	0f 2e       	mov	r0, r31
    26ca:	f0 e8       	ldi	r31, 0x80	; 128
    26cc:	4f 2e       	mov	r4, r31
    26ce:	f1 e0       	ldi	r31, 0x01	; 1
    26d0:	5f 2e       	mov	r5, r31
    26d2:	f0 2d       	mov	r31, r0
    26d4:	88 e7       	ldi	r24, 0x78	; 120
    26d6:	d2 01       	movw	r26, r4
    26d8:	8c 93       	st	X, r24

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    26da:	e0 e0       	ldi	r30, 0x00	; 0
    26dc:	f9 e0       	ldi	r31, 0x09	; 9
    26de:	80 ef       	ldi	r24, 0xF0	; 240
    26e0:	81 83       	std	Z+1, r24	; 0x01
	TCD0.CCA = averagingPtA;
    26e2:	c0 a6       	lds	r28, 0xb0
    26e4:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    26e6:	a2 a6       	lds	r26, 0xb2
    26e8:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    26ea:	84 a6       	lds	r24, 0xb4
    26ec:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    26ee:	8d 89       	ldd	r24, Y+21	; 0x15
    26f0:	9e 89       	ldd	r25, Y+22	; 0x16
    26f2:	86 a7       	lds	r24, 0x76
    26f4:	97 a7       	lds	r25, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    26f6:	80 2f       	mov	r24, r16
    26f8:	90 e0       	ldi	r25, 0x00	; 0
    26fa:	01 97       	sbiw	r24, 0x01	; 1
    26fc:	86 a3       	lds	r24, 0x56
    26fe:	97 a3       	lds	r25, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2700:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2702:	8f ef       	ldi	r24, 0xFF	; 255
    2704:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2706:	80 81       	ld	r24, Z
    2708:	80 7f       	andi	r24, 0xF0	; 240
    270a:	88 60       	ori	r24, 0x08	; 8
    270c:	80 83       	st	Z, r24

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    270e:	10 92 63 50 	sts	0x5063, r1
    2712:	10 92 64 50 	sts	0x5064, r1
    2716:	10 92 65 50 	sts	0x5065, r1
    271a:	10 92 66 50 	sts	0x5066, r1
	SPICount = 0;
    271e:	10 92 9e 50 	sts	0x509E, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm;
    2722:	e0 ea       	ldi	r30, 0xA0	; 160
    2724:	f0 e0       	ldi	r31, 0x00	; 0
    2726:	82 81       	ldd	r24, Z+2	; 0x02
    2728:	87 60       	ori	r24, 0x07	; 7
    272a:	82 83       	std	Z+2, r24	; 0x02
	sei();
    272c:	78 94       	sei

	SPICS(TRUE);
    272e:	81 e0       	ldi	r24, 0x01	; 1
    2730:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2734:	80 e2       	ldi	r24, 0x20	; 32
    2736:	e0 e8       	ldi	r30, 0x80	; 128
    2738:	f6 e0       	ldi	r31, 0x06	; 6
    273a:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    273c:	00 e4       	ldi	r16, 0x40	; 64
    273e:	1a e0       	ldi	r17, 0x0A	; 10
    2740:	83 e2       	ldi	r24, 0x23	; 35
    2742:	f8 01       	movw	r30, r16
    2744:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2746:	61 01       	movw	r12, r2
    2748:	ee 24       	eor	r14, r14
    274a:	ff 24       	eor	r15, r15
    274c:	60 e8       	ldi	r22, 0x80	; 128
    274e:	74 e8       	ldi	r23, 0x84	; 132
    2750:	8e e1       	ldi	r24, 0x1E	; 30
    2752:	90 e0       	ldi	r25, 0x00	; 0
    2754:	a7 01       	movw	r20, r14
    2756:	96 01       	movw	r18, r12
    2758:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    275c:	d8 01       	movw	r26, r16
    275e:	96 96       	adiw	r26, 0x26	; 38
    2760:	2d 93       	st	X+, r18
    2762:	3c 93       	st	X, r19
    2764:	97 97       	sbiw	r26, 0x27	; 39
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2766:	60 e4       	ldi	r22, 0x40	; 64
    2768:	72 e4       	ldi	r23, 0x42	; 66
    276a:	8f e0       	ldi	r24, 0x0F	; 15
    276c:	90 e0       	ldi	r25, 0x00	; 0
    276e:	a7 01       	movw	r20, r14
    2770:	96 01       	movw	r18, r12
    2772:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    2776:	f8 01       	movw	r30, r16
    2778:	22 af       	sts	0x72, r18
    277a:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    277c:	e0 e4       	ldi	r30, 0x40	; 64
    277e:	f8 e0       	ldi	r31, 0x08	; 8
    2780:	8f 89       	ldd	r24, Y+23	; 0x17
    2782:	98 8d       	ldd	r25, Y+24	; 0x18
    2784:	86 a3       	lds	r24, 0x56
    2786:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    2788:	80 ed       	ldi	r24, 0xD0	; 208
    278a:	d2 01       	movw	r26, r4
    278c:	11 96       	adiw	r26, 0x01	; 1
    278e:	8c 93       	st	X, r24
    2790:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2792:	76 82       	std	Z+6, r7	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2794:	80 81       	ld	r24, Z
    2796:	80 7f       	andi	r24, 0xF0	; 240
    2798:	89 60       	ori	r24, 0x09	; 9
    279a:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    279c:	f8 01       	movw	r30, r16
    279e:	80 81       	ld	r24, Z
    27a0:	80 7f       	andi	r24, 0xF0	; 240
    27a2:	81 60       	ori	r24, 0x01	; 1
    27a4:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    27a6:	df 91       	pop	r29
    27a8:	cf 91       	pop	r28
    27aa:	1f 91       	pop	r17
    27ac:	0f 91       	pop	r16
    27ae:	ff 90       	pop	r15
    27b0:	ef 90       	pop	r14
    27b2:	df 90       	pop	r13
    27b4:	cf 90       	pop	r12
    27b6:	bf 90       	pop	r11
    27b8:	af 90       	pop	r10
    27ba:	9f 90       	pop	r9
    27bc:	8f 90       	pop	r8
    27be:	7f 90       	pop	r7
    27c0:	5f 90       	pop	r5
    27c2:	4f 90       	pop	r4
    27c4:	3f 90       	pop	r3
    27c6:	2f 90       	pop	r2
    27c8:	08 95       	ret

000027ca <CO_collectSeismic1Channel>:
	sampleCount++;

}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    27ca:	2f 92       	push	r2
    27cc:	3f 92       	push	r3
    27ce:	4f 92       	push	r4
    27d0:	5f 92       	push	r5
    27d2:	6f 92       	push	r6
    27d4:	7f 92       	push	r7
    27d6:	8f 92       	push	r8
    27d8:	9f 92       	push	r9
    27da:	af 92       	push	r10
    27dc:	bf 92       	push	r11
    27de:	cf 92       	push	r12
    27e0:	df 92       	push	r13
    27e2:	ef 92       	push	r14
    27e4:	ff 92       	push	r15
    27e6:	0f 93       	push	r16
    27e8:	cf 93       	push	r28
    27ea:	df 93       	push	r29
    27ec:	cd b7       	in	r28, 0x3d	; 61
    27ee:	de b7       	in	r29, 0x3e	; 62
    27f0:	96 2f       	mov	r25, r22
    27f2:	1a 01       	movw	r2, r20
    27f4:	52 2f       	mov	r21, r18
    27f6:	70 2f       	mov	r23, r16
    27f8:	d7 01       	movw	r26, r14
    27fa:	36 01       	movw	r6, r12
    27fc:	25 01       	movw	r4, r10
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    27fe:	00 d0       	rcall	.+0      	; 0x2800 <CO_collectSeismic1Channel+0x36>
    2800:	00 d0       	rcall	.+0      	; 0x2802 <CO_collectSeismic1Channel+0x38>
    2802:	2d b7       	in	r18, 0x3d	; 61
    2804:	3e b7       	in	r19, 0x3e	; 62
    2806:	2f 5f       	subi	r18, 0xFF	; 255
    2808:	3f 4f       	sbci	r19, 0xFF	; 255
    280a:	ed b7       	in	r30, 0x3d	; 61
    280c:	fe b7       	in	r31, 0x3e	; 62
    280e:	81 82       	std	Z+1, r8	; 0x01
    2810:	92 82       	std	Z+2, r9	; 0x02
    2812:	8d 88       	ldd	r8, Y+21	; 0x15
    2814:	9e 88       	ldd	r9, Y+22	; 0x16
    2816:	f9 01       	movw	r30, r18
    2818:	82 82       	std	Z+2, r8	; 0x02
    281a:	93 82       	std	Z+3, r9	; 0x03
    281c:	8f 88       	ldd	r8, Y+23	; 0x17
    281e:	98 8c       	ldd	r9, Y+24	; 0x18
    2820:	84 82       	std	Z+4, r8	; 0x04
    2822:	95 82       	std	Z+5, r9	; 0x05
    2824:	64 ec       	ldi	r22, 0xC4	; 196
    2826:	49 2f       	mov	r20, r25
    2828:	91 01       	movw	r18, r2
    282a:	05 2f       	mov	r16, r21
    282c:	e7 2e       	mov	r14, r23
    282e:	6d 01       	movw	r12, r26
    2830:	53 01       	movw	r10, r6
    2832:	42 01       	movw	r8, r4
    2834:	0e 94 25 13 	call	0x264a	; 0x264a <CO_collectSeismic1Channel_ext>
    2838:	8d b7       	in	r24, 0x3d	; 61
    283a:	9e b7       	in	r25, 0x3e	; 62
    283c:	06 96       	adiw	r24, 0x06	; 6
    283e:	8d bf       	out	0x3d, r24	; 61
    2840:	9e bf       	out	0x3e, r25	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray);
}
    2842:	df 91       	pop	r29
    2844:	cf 91       	pop	r28
    2846:	0f 91       	pop	r16
    2848:	ff 90       	pop	r15
    284a:	ef 90       	pop	r14
    284c:	df 90       	pop	r13
    284e:	cf 90       	pop	r12
    2850:	bf 90       	pop	r11
    2852:	af 90       	pop	r10
    2854:	9f 90       	pop	r9
    2856:	8f 90       	pop	r8
    2858:	7f 90       	pop	r7
    285a:	6f 90       	pop	r6
    285c:	5f 90       	pop	r5
    285e:	4f 90       	pop	r4
    2860:	3f 90       	pop	r3
    2862:	2f 90       	pop	r2
    2864:	08 95       	ret

00002866 <CO_collectSeismic3Axises_ext>:
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray);
}	
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    2866:	2f 92       	push	r2
    2868:	3f 92       	push	r3
    286a:	5f 92       	push	r5
    286c:	6f 92       	push	r6
    286e:	7f 92       	push	r7
    2870:	8f 92       	push	r8
    2872:	9f 92       	push	r9
    2874:	af 92       	push	r10
    2876:	bf 92       	push	r11
    2878:	cf 92       	push	r12
    287a:	df 92       	push	r13
    287c:	ef 92       	push	r14
    287e:	ff 92       	push	r15
    2880:	0f 93       	push	r16
    2882:	1f 93       	push	r17
    2884:	cf 93       	push	r28
    2886:	df 93       	push	r29
    2888:	0f 92       	push	r0
    288a:	0f 92       	push	r0
    288c:	cd b7       	in	r28, 0x3d	; 61
    288e:	de b7       	in	r29, 0x3e	; 62
    2890:	18 2f       	mov	r17, r24
    2892:	3b 01       	movw	r6, r22
    2894:	49 83       	std	Y+1, r20	; 0x01
    2896:	5a 83       	std	Y+2, r21	; 0x02
    2898:	52 2e       	mov	r5, r18
	
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif
	
	ADC_BUFFER = DataArray;
    289a:	89 8d       	ldd	r24, Y+25	; 0x19
    289c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    289e:	80 93 61 50 	sts	0x5061, r24
    28a2:	90 93 62 50 	sts	0x5062, r25
	ADC_Sampling_Finished = 0;
    28a6:	10 92 a4 50 	sts	0x50A4, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    28aa:	81 e0       	ldi	r24, 0x01	; 1
    28ac:	0e 94 a3 05 	call	0xb46	; 0xb46 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    28b0:	85 e0       	ldi	r24, 0x05	; 5
    28b2:	d3 01       	movw	r26, r6
    28b4:	6c 91       	ld	r22, X
    28b6:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    28ba:	86 e0       	ldi	r24, 0x06	; 6
    28bc:	f3 01       	movw	r30, r6
    28be:	61 81       	ldd	r22, Z+1	; 0x01
    28c0:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    28c4:	87 e0       	ldi	r24, 0x07	; 7
    28c6:	d3 01       	movw	r26, r6
    28c8:	12 96       	adiw	r26, 0x02	; 2
    28ca:	6c 91       	ld	r22, X
    28cc:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <set_ampGain>
	set_filter(filterConfig);
    28d0:	81 2f       	mov	r24, r17
    28d2:	0e 94 e6 03 	call	0x7cc	; 0x7cc <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    28d6:	80 2f       	mov	r24, r16
    28d8:	0e 94 ce 0b 	call	0x179c	; 0x179c <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    28dc:	84 e0       	ldi	r24, 0x04	; 4
    28de:	0e 94 ad 03 	call	0x75a	; 0x75a <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    28e2:	84 e5       	ldi	r24, 0x54	; 84
    28e4:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    28e8:	81 e0       	ldi	r24, 0x01	; 1
    28ea:	0e 94 22 0a 	call	0x1444	; 0x1444 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    28ee:	85 e0       	ldi	r24, 0x05	; 5
    28f0:	0e 94 03 13 	call	0x2606	; 0x2606 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    28f4:	e0 ea       	ldi	r30, 0xA0	; 160
    28f6:	f6 e0       	ldi	r31, 0x06	; 6
    28f8:	22 e0       	ldi	r18, 0x02	; 2
    28fa:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    28fc:	66 24       	eor	r6, r6
    28fe:	63 94       	inc	r6
    2900:	62 82       	std	Z+2, r6	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2902:	0f 2e       	mov	r0, r31
    2904:	f0 e8       	ldi	r31, 0x80	; 128
    2906:	2f 2e       	mov	r2, r31
    2908:	f1 e0       	ldi	r31, 0x01	; 1
    290a:	3f 2e       	mov	r3, r31
    290c:	f0 2d       	mov	r31, r0
    290e:	88 e7       	ldi	r24, 0x78	; 120
    2910:	f1 01       	movw	r30, r2
    2912:	80 83       	st	Z, r24

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2914:	e0 e0       	ldi	r30, 0x00	; 0
    2916:	f8 e0       	ldi	r31, 0x08	; 8
    2918:	80 ef       	ldi	r24, 0xF0	; 240
    291a:	81 83       	std	Z+1, r24	; 0x01
	TCC0.CCA = averagingPtA;
    291c:	e0 a6       	lds	r30, 0xb0
    291e:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    2920:	c2 a6       	lds	r28, 0xb2
    2922:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    2924:	a4 a6       	lds	r26, 0xb4
    2926:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    2928:	86 a6       	lds	r24, 0xb6
    292a:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    292c:	85 2d       	mov	r24, r5
    292e:	90 e0       	ldi	r25, 0x00	; 0
    2930:	01 97       	sbiw	r24, 0x01	; 1
    2932:	86 a3       	lds	r24, 0x56
    2934:	97 a3       	lds	r25, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2936:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2938:	8f ef       	ldi	r24, 0xFF	; 255
    293a:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    293c:	80 81       	ld	r24, Z
    293e:	80 7f       	andi	r24, 0xF0	; 240
    2940:	88 60       	ori	r24, 0x08	; 8
    2942:	80 83       	st	Z, r24

	sampleCount = 0;
    2944:	10 92 63 50 	sts	0x5063, r1
    2948:	10 92 64 50 	sts	0x5064, r1
    294c:	10 92 65 50 	sts	0x5065, r1
    2950:	10 92 66 50 	sts	0x5066, r1
	SPICount = 0;
    2954:	10 92 9e 50 	sts	0x509E, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2958:	83 e1       	ldi	r24, 0x13	; 19
    295a:	91 e2       	ldi	r25, 0x21	; 33
    295c:	10 92 13 21 	sts	0x2113, r1
    2960:	fc 01       	movw	r30, r24
    2962:	31 97       	sbiw	r30, 0x01	; 1
    2964:	10 82       	st	Z, r1
    2966:	02 97       	sbiw	r24, 0x02	; 2
    2968:	dc 01       	movw	r26, r24
    296a:	1c 92       	st	X, r1

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm);
    296c:	e0 ea       	ldi	r30, 0xA0	; 160
    296e:	f0 e0       	ldi	r31, 0x00	; 0
    2970:	82 81       	ldd	r24, Z+2	; 0x02
    2972:	87 60       	ori	r24, 0x07	; 7
    2974:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2976:	78 94       	sei

	SPICS(TRUE);
    2978:	81 e0       	ldi	r24, 0x01	; 1
    297a:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    297e:	80 e2       	ldi	r24, 0x20	; 32
    2980:	e0 e8       	ldi	r30, 0x80	; 128
    2982:	f6 e0       	ldi	r31, 0x06	; 6
    2984:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2986:	00 e4       	ldi	r16, 0x40	; 64
    2988:	1a e0       	ldi	r17, 0x0A	; 10
    298a:	83 e2       	ldi	r24, 0x23	; 35
    298c:	f8 01       	movw	r30, r16
    298e:	81 83       	std	Z+1, r24	; 0x01
	// set period of waveform generator and duty cycle (want duty cycle to be half the period to get clean clock signal)
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2990:	89 81       	ldd	r24, Y+1	; 0x01
    2992:	9a 81       	ldd	r25, Y+2	; 0x02
    2994:	6c 01       	movw	r12, r24
    2996:	ee 24       	eor	r14, r14
    2998:	ff 24       	eor	r15, r15
    299a:	60 e8       	ldi	r22, 0x80	; 128
    299c:	74 e8       	ldi	r23, 0x84	; 132
    299e:	8e e1       	ldi	r24, 0x1E	; 30
    29a0:	90 e0       	ldi	r25, 0x00	; 0
    29a2:	a7 01       	movw	r20, r14
    29a4:	96 01       	movw	r18, r12
    29a6:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    29aa:	d8 01       	movw	r26, r16
    29ac:	96 96       	adiw	r26, 0x26	; 38
    29ae:	2d 93       	st	X+, r18
    29b0:	3c 93       	st	X, r19
    29b2:	97 97       	sbiw	r26, 0x27	; 39
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    29b4:	60 e4       	ldi	r22, 0x40	; 64
    29b6:	72 e4       	ldi	r23, 0x42	; 66
    29b8:	8f e0       	ldi	r24, 0x0F	; 15
    29ba:	90 e0       	ldi	r25, 0x00	; 0
    29bc:	a7 01       	movw	r20, r14
    29be:	96 01       	movw	r18, r12
    29c0:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    29c4:	f8 01       	movw	r30, r16
    29c6:	22 af       	sts	0x72, r18
    29c8:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    29ca:	e0 e4       	ldi	r30, 0x40	; 64
    29cc:	f8 e0       	ldi	r31, 0x08	; 8
    29ce:	8f 89       	ldd	r24, Y+23	; 0x17
    29d0:	98 8d       	ldd	r25, Y+24	; 0x18
    29d2:	86 a3       	lds	r24, 0x56
    29d4:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
    29d6:	80 ec       	ldi	r24, 0xC0	; 192
    29d8:	d1 01       	movw	r26, r2
    29da:	11 96       	adiw	r26, 0x01	; 1
    29dc:	8c 93       	st	X, r24
    29de:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    29e0:	66 82       	std	Z+6, r6	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    29e2:	80 81       	ld	r24, Z
    29e4:	80 7f       	andi	r24, 0xF0	; 240
    29e6:	89 60       	ori	r24, 0x09	; 9
    29e8:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    29ea:	f8 01       	movw	r30, r16
    29ec:	80 81       	ld	r24, Z
    29ee:	80 7f       	andi	r24, 0xF0	; 240
    29f0:	81 60       	ori	r24, 0x01	; 1
    29f2:	80 83       	st	Z, r24
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    29f4:	0f 90       	pop	r0
    29f6:	0f 90       	pop	r0
    29f8:	df 91       	pop	r29
    29fa:	cf 91       	pop	r28
    29fc:	1f 91       	pop	r17
    29fe:	0f 91       	pop	r16
    2a00:	ff 90       	pop	r15
    2a02:	ef 90       	pop	r14
    2a04:	df 90       	pop	r13
    2a06:	cf 90       	pop	r12
    2a08:	bf 90       	pop	r11
    2a0a:	af 90       	pop	r10
    2a0c:	9f 90       	pop	r9
    2a0e:	8f 90       	pop	r8
    2a10:	7f 90       	pop	r7
    2a12:	6f 90       	pop	r6
    2a14:	5f 90       	pop	r5
    2a16:	3f 90       	pop	r3
    2a18:	2f 90       	pop	r2
    2a1a:	08 95       	ret

00002a1c <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray) {
    2a1c:	2f 92       	push	r2
    2a1e:	3f 92       	push	r3
    2a20:	4f 92       	push	r4
    2a22:	5f 92       	push	r5
    2a24:	6f 92       	push	r6
    2a26:	7f 92       	push	r7
    2a28:	8f 92       	push	r8
    2a2a:	9f 92       	push	r9
    2a2c:	af 92       	push	r10
    2a2e:	bf 92       	push	r11
    2a30:	cf 92       	push	r12
    2a32:	df 92       	push	r13
    2a34:	ef 92       	push	r14
    2a36:	ff 92       	push	r15
    2a38:	0f 93       	push	r16
    2a3a:	1f 93       	push	r17
    2a3c:	cf 93       	push	r28
    2a3e:	df 93       	push	r29
    2a40:	00 d0       	rcall	.+0      	; 0x2a42 <CO_collectSeismic3Axises+0x26>
    2a42:	0f 92       	push	r0
    2a44:	cd b7       	in	r28, 0x3d	; 61
    2a46:	de b7       	in	r29, 0x3e	; 62
    2a48:	8b 83       	std	Y+3, r24	; 0x03
    2a4a:	9c 83       	std	Y+4, r25	; 0x04
    2a4c:	db 01       	movw	r26, r22
    2a4e:	94 2f       	mov	r25, r20
    2a50:	32 2f       	mov	r19, r18
    2a52:	38 01       	movw	r6, r16
    2a54:	27 01       	movw	r4, r14
    2a56:	16 01       	movw	r2, r12
    2a58:	a9 82       	std	Y+1, r10	; 0x01
    2a5a:	ba 82       	std	Y+2, r11	; 0x02
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    2a5c:	00 d0       	rcall	.+0      	; 0x2a5e <CO_collectSeismic3Axises+0x42>
    2a5e:	0f 92       	push	r0
    2a60:	ed b7       	in	r30, 0x3d	; 61
    2a62:	fe b7       	in	r31, 0x3e	; 62
    2a64:	81 82       	std	Z+1, r8	; 0x01
    2a66:	92 82       	std	Z+2, r9	; 0x02
    2a68:	4a 8d       	ldd	r20, Y+26	; 0x1a
    2a6a:	5b 8d       	ldd	r21, Y+27	; 0x1b
    2a6c:	43 83       	std	Z+3, r20	; 0x03
    2a6e:	54 83       	std	Z+4, r21	; 0x04
    2a70:	84 ec       	ldi	r24, 0xC4	; 196
    2a72:	6b 81       	ldd	r22, Y+3	; 0x03
    2a74:	7c 81       	ldd	r23, Y+4	; 0x04
    2a76:	ad 01       	movw	r20, r26
    2a78:	29 2f       	mov	r18, r25
    2a7a:	03 2f       	mov	r16, r19
    2a7c:	73 01       	movw	r14, r6
    2a7e:	62 01       	movw	r12, r4
    2a80:	51 01       	movw	r10, r2
    2a82:	89 80       	ldd	r8, Y+1	; 0x01
    2a84:	9a 80       	ldd	r9, Y+2	; 0x02
    2a86:	0e 94 33 14 	call	0x2866	; 0x2866 <CO_collectSeismic3Axises_ext>
    2a8a:	0f 90       	pop	r0
    2a8c:	0f 90       	pop	r0
    2a8e:	0f 90       	pop	r0
    2a90:	0f 90       	pop	r0
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray);
}	
    2a92:	24 96       	adiw	r28, 0x04	; 4
    2a94:	cd bf       	out	0x3d, r28	; 61
    2a96:	de bf       	out	0x3e, r29	; 62
    2a98:	df 91       	pop	r29
    2a9a:	cf 91       	pop	r28
    2a9c:	1f 91       	pop	r17
    2a9e:	0f 91       	pop	r16
    2aa0:	ff 90       	pop	r15
    2aa2:	ef 90       	pop	r14
    2aa4:	df 90       	pop	r13
    2aa6:	cf 90       	pop	r12
    2aa8:	bf 90       	pop	r11
    2aaa:	af 90       	pop	r10
    2aac:	9f 90       	pop	r9
    2aae:	8f 90       	pop	r8
    2ab0:	7f 90       	pop	r7
    2ab2:	6f 90       	pop	r6
    2ab4:	5f 90       	pop	r5
    2ab6:	4f 90       	pop	r4
    2ab8:	3f 90       	pop	r3
    2aba:	2f 90       	pop	r2
    2abc:	08 95       	ret

00002abe <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    2abe:	8f 92       	push	r8
    2ac0:	9f 92       	push	r9
    2ac2:	af 92       	push	r10
    2ac4:	bf 92       	push	r11
    2ac6:	df 92       	push	r13
    2ac8:	ef 92       	push	r14
    2aca:	ff 92       	push	r15
    2acc:	0f 93       	push	r16
    2ace:	1f 93       	push	r17
    2ad0:	cf 93       	push	r28
    2ad2:	df 93       	push	r29
    2ad4:	c8 2f       	mov	r28, r24
    2ad6:	d6 2e       	mov	r13, r22
    2ad8:	d4 2f       	mov	r29, r20
    2ada:	59 01       	movw	r10, r18
    2adc:	48 01       	movw	r8, r16
	#ifndef F_CPU
	#define F_CPU 32000000UL
	#endif

	uint16_t period;
	ADC_BUFFER = DataArray;
    2ade:	e0 92 61 50 	sts	0x5061, r14
    2ae2:	f0 92 62 50 	sts	0x5062, r15
	ADC_Sampling_Finished = 0;
    2ae6:	10 92 a4 50 	sts	0x50A4, r1
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2aea:	81 e0       	ldi	r24, 0x01	; 1
    2aec:	0e 94 a3 05 	call	0xb46	; 0xb46 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    2af0:	8c 2f       	mov	r24, r28
    2af2:	6d 2f       	mov	r22, r29
    2af4:	0e 94 e9 09 	call	0x13d2	; 0x13d2 <set_ampGain>
	set_filter(filterConfig);
    2af8:	8d 2d       	mov	r24, r13
    2afa:	0e 94 e6 03 	call	0x7cc	; 0x7cc <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    2afe:	8c 2f       	mov	r24, r28
    2b00:	85 50       	subi	r24, 0x05	; 5
    2b02:	83 30       	cpi	r24, 0x03	; 3
    2b04:	18 f4       	brcc	.+6      	; 0x2b0c <CO_collectADC_ext+0x4e>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    2b06:	81 e0       	ldi	r24, 0x01	; 1
    2b08:	0e 94 ce 0b 	call	0x179c	; 0x179c <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    2b0c:	81 e0       	ldi	r24, 0x01	; 1
    2b0e:	0e 94 22 0a 	call	0x1444	; 0x1444 <enableADCMUX>
	setADCInput(channel);
    2b12:	8c 2f       	mov	r24, r28
    2b14:	0e 94 03 13 	call	0x2606	; 0x2606 <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    2b18:	84 e0       	ldi	r24, 0x04	; 4
    2b1a:	0e 94 ad 03 	call	0x75a	; 0x75a <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2b1e:	84 e5       	ldi	r24, 0x54	; 84
    2b20:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    2b24:	e0 ea       	ldi	r30, 0xA0	; 160
    2b26:	f6 e0       	ldi	r31, 0x06	; 6
    2b28:	dd 24       	eor	r13, r13
    2b2a:	d3 94       	inc	r13
    2b2c:	d2 82       	std	Z+2, r13	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    2b2e:	82 e0       	ldi	r24, 0x02	; 2
    2b30:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    2b32:	d2 86       	std	Z+10, r13	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_MED_gc;				
    2b34:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    2b36:	80 e2       	ldi	r24, 0x20	; 32
    2b38:	e0 e8       	ldi	r30, 0x80	; 128
    2b3a:	f6 e0       	ldi	r31, 0x06	; 6
    2b3c:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2b3e:	c0 e4       	ldi	r28, 0x40	; 64
    2b40:	da e0       	ldi	r29, 0x0A	; 10
    2b42:	83 e2       	ldi	r24, 0x23	; 35
    2b44:	89 83       	std	Y+1, r24	; 0x01
	// set period of waveform generator and ccb as duty cycle (want half the period for duty cycle to have good clock signal)
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    2b46:	95 01       	movw	r18, r10
    2b48:	40 e0       	ldi	r20, 0x00	; 0
    2b4a:	50 e0       	ldi	r21, 0x00	; 0
    2b4c:	60 e8       	ldi	r22, 0x80	; 128
    2b4e:	74 e8       	ldi	r23, 0x84	; 132
    2b50:	8e e1       	ldi	r24, 0x1E	; 30
    2b52:	90 e0       	ldi	r25, 0x00	; 0
    2b54:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    2b58:	89 01       	movw	r16, r18
    2b5a:	9a 01       	movw	r18, r20
    2b5c:	c8 01       	movw	r24, r16
	TCE1.PER = period;
    2b5e:	0e a3       	lds	r16, 0x5e
    2b60:	1f a3       	lds	r17, 0x5f
	TCE1.CCBBUF = period / 2;
    2b62:	96 95       	lsr	r25
    2b64:	87 95       	ror	r24
    2b66:	8a af       	sts	0x7a, r24
    2b68:	9b af       	sts	0x7b, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples;
    2b6a:	e0 e4       	ldi	r30, 0x40	; 64
    2b6c:	f8 e0       	ldi	r31, 0x08	; 8
    2b6e:	86 a2       	lds	r24, 0x96
    2b70:	97 a2       	lds	r25, 0x97
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2b72:	88 e7       	ldi	r24, 0x78	; 120
    2b74:	a0 e8       	ldi	r26, 0x80	; 128
    2b76:	b1 e0       	ldi	r27, 0x01	; 1
    2b78:	11 96       	adiw	r26, 0x01	; 1
    2b7a:	8c 93       	st	X, r24
    2b7c:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2b7e:	d6 82       	std	Z+6, r13	; 0x06
	//TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2b80:	88 81       	ld	r24, Y
    2b82:	80 7f       	andi	r24, 0xF0	; 240
    2b84:	81 60       	ori	r24, 0x01	; 1
    2b86:	88 83       	st	Y, r24
	
	sampleCount = 0;
    2b88:	10 92 63 50 	sts	0x5063, r1
    2b8c:	10 92 64 50 	sts	0x5064, r1
    2b90:	10 92 65 50 	sts	0x5065, r1
    2b94:	10 92 66 50 	sts	0x5066, r1
	discardCount = 0;
    2b98:	10 92 5a 40 	sts	0x405A, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
    2b9c:	e0 ea       	ldi	r30, 0xA0	; 160
    2b9e:	f0 e0       	ldi	r31, 0x00	; 0
    2ba0:	82 81       	ldd	r24, Z+2	; 0x02
    2ba2:	83 60       	ori	r24, 0x03	; 3
    2ba4:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2ba6:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    2ba8:	df 91       	pop	r29
    2baa:	cf 91       	pop	r28
    2bac:	1f 91       	pop	r17
    2bae:	0f 91       	pop	r16
    2bb0:	ff 90       	pop	r15
    2bb2:	ef 90       	pop	r14
    2bb4:	df 90       	pop	r13
    2bb6:	bf 90       	pop	r11
    2bb8:	af 90       	pop	r10
    2bba:	9f 90       	pop	r9
    2bbc:	8f 90       	pop	r8
    2bbe:	08 95       	ret

00002bc0 <CO_collectADC>:
		PORTA.OUTCLR = PIN5_bm;
		PORTA.DIRCLR = PIN5_bm;
	}
}

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray) {
    2bc0:	ef 92       	push	r14
    2bc2:	ff 92       	push	r15
    2bc4:	0f 93       	push	r16
    2bc6:	1f 93       	push	r17
    2bc8:	96 2f       	mov	r25, r22
    2bca:	fa 01       	movw	r30, r20
    2bcc:	d9 01       	movw	r26, r18
    2bce:	78 01       	movw	r14, r16
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_1AND5_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray);
    2bd0:	61 ec       	ldi	r22, 0xC1	; 193
    2bd2:	49 2f       	mov	r20, r25
    2bd4:	9f 01       	movw	r18, r30
    2bd6:	8d 01       	movw	r16, r26
    2bd8:	0e 94 5f 15 	call	0x2abe	; 0x2abe <CO_collectADC_ext>
}
    2bdc:	1f 91       	pop	r17
    2bde:	0f 91       	pop	r16
    2be0:	ff 90       	pop	r15
    2be2:	ef 90       	pop	r14
    2be4:	08 95       	ret

00002be6 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    2be6:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2be8:	81 e0       	ldi	r24, 0x01	; 1
    2bea:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    2bec:	84 81       	ldd	r24, Z+4	; 0x04
    2bee:	95 81       	ldd	r25, Z+5	; 0x05
    2bf0:	86 1b       	sub	r24, r22
    2bf2:	91 09       	sbc	r25, r1

	return answer;
}
    2bf4:	08 95       	ret

00002bf6 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    2bf6:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2bf8:	81 e0       	ldi	r24, 0x01	; 1
    2bfa:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    2bfc:	84 81       	ldd	r24, Z+4	; 0x04
    2bfe:	95 81       	ldd	r25, Z+5	; 0x05
    2c00:	77 27       	eor	r23, r23
    2c02:	67 fd       	sbrc	r22, 7
    2c04:	70 95       	com	r23
    2c06:	86 1b       	sub	r24, r22
    2c08:	97 0b       	sbc	r25, r23

	return answer;
}
    2c0a:	08 95       	ret

00002c0c <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    2c0c:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2c0e:	81 e0       	ldi	r24, 0x01	; 1
    2c10:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    2c12:	84 81       	ldd	r24, Z+4	; 0x04
    2c14:	95 81       	ldd	r25, Z+5	; 0x05
}
    2c16:	08 95       	ret

00002c18 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    2c18:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2c1a:	81 e0       	ldi	r24, 0x01	; 1
    2c1c:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    2c1e:	84 81       	ldd	r24, Z+4	; 0x04
}
    2c20:	08 95       	ret

00002c22 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    2c22:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2c24:	81 e0       	ldi	r24, 0x01	; 1
    2c26:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    2c28:	85 81       	ldd	r24, Z+5	; 0x05
}
    2c2a:	08 95       	ret

00002c2c <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    2c2c:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    2c2e:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    2c30:	14 82       	std	Z+4, r1	; 0x04
    2c32:	9a e2       	ldi	r25, 0x2A	; 42
    2c34:	9a 95       	dec	r25
    2c36:	f1 f7       	brne	.-4      	; 0x2c34 <ADC_Wait_8MHz+0x8>
    2c38:	00 c0       	rjmp	.+0      	; 0x2c3a <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    2c3a:	84 83       	std	Z+4, r24	; 0x04
}
    2c3c:	08 95       	ret

00002c3e <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    2c3e:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    2c40:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    2c42:	91 e0       	ldi	r25, 0x01	; 1
    2c44:	94 83       	std	Z+4, r25	; 0x04
    2c46:	95 e5       	ldi	r25, 0x55	; 85
    2c48:	9a 95       	dec	r25
    2c4a:	f1 f7       	brne	.-4      	; 0x2c48 <ADC_Wait_32MHz+0xa>
    2c4c:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    2c4e:	84 83       	std	Z+4, r24	; 0x04
}
    2c50:	08 95       	ret

00002c52 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    2c52:	ef 92       	push	r14
    2c54:	ff 92       	push	r15
    2c56:	0f 93       	push	r16
    2c58:	1f 93       	push	r17
    2c5a:	cf 93       	push	r28
    2c5c:	df 93       	push	r29
    2c5e:	eb 01       	movw	r28, r22
    if (oversampling)
    2c60:	44 23       	and	r20, r20
    2c62:	c9 f0       	breq	.+50     	; 0x2c96 <ADC_Offset_Get_Unsigned+0x44>
    2c64:	04 e0       	ldi	r16, 0x04	; 4
    2c66:	10 e0       	ldi	r17, 0x00	; 0
    2c68:	ee 24       	eor	r14, r14
    2c6a:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    2c6c:	88 81       	ld	r24, Y
    2c6e:	80 68       	ori	r24, 0x80	; 128
    2c70:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    2c72:	8b 81       	ldd	r24, Y+3	; 0x03
    2c74:	80 ff       	sbrs	r24, 0
    2c76:	fd cf       	rjmp	.-6      	; 0x2c72 <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    2c78:	ce 01       	movw	r24, r28
    2c7a:	60 e0       	ldi	r22, 0x00	; 0
    2c7c:	0e 94 f3 15 	call	0x2be6	; 0x2be6 <ADC_ResultCh_GetWord_Unsigned>
    2c80:	e8 0e       	add	r14, r24
    2c82:	f9 1e       	adc	r15, r25
    2c84:	01 50       	subi	r16, 0x01	; 1
    2c86:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    2c88:	89 f7       	brne	.-30     	; 0x2c6c <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    2c8a:	c7 01       	movw	r24, r14
    2c8c:	96 95       	lsr	r25
    2c8e:	87 95       	ror	r24
    2c90:	96 95       	lsr	r25
    2c92:	87 95       	ror	r24
    2c94:	09 c0       	rjmp	.+18     	; 0x2ca8 <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    2c96:	88 81       	ld	r24, Y
    2c98:	80 68       	ori	r24, 0x80	; 128
    2c9a:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    2c9c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c9e:	80 ff       	sbrs	r24, 0
    2ca0:	fd cf       	rjmp	.-6      	; 0x2c9c <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    2ca2:	ce 01       	movw	r24, r28
    2ca4:	0e 94 06 16 	call	0x2c0c	; 0x2c0c <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
    2ca8:	df 91       	pop	r29
    2caa:	cf 91       	pop	r28
    2cac:	1f 91       	pop	r17
    2cae:	0f 91       	pop	r16
    2cb0:	ff 90       	pop	r15
    2cb2:	ef 90       	pop	r14
    2cb4:	08 95       	ret

00002cb6 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    2cb6:	ef 92       	push	r14
    2cb8:	ff 92       	push	r15
    2cba:	0f 93       	push	r16
    2cbc:	1f 93       	push	r17
    2cbe:	cf 93       	push	r28
    2cc0:	df 93       	push	r29
    2cc2:	eb 01       	movw	r28, r22
    if (oversampling)
    2cc4:	44 23       	and	r20, r20
    2cc6:	e1 f0       	breq	.+56     	; 0x2d00 <ADC_Offset_Get_Signed+0x4a>
    2cc8:	04 e0       	ldi	r16, 0x04	; 4
    2cca:	10 e0       	ldi	r17, 0x00	; 0
    2ccc:	ee 24       	eor	r14, r14
    2cce:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    2cd0:	88 81       	ld	r24, Y
    2cd2:	80 68       	ori	r24, 0x80	; 128
    2cd4:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    2cd6:	8b 81       	ldd	r24, Y+3	; 0x03
    2cd8:	80 ff       	sbrs	r24, 0
    2cda:	fd cf       	rjmp	.-6      	; 0x2cd6 <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    2cdc:	ce 01       	movw	r24, r28
    2cde:	60 e0       	ldi	r22, 0x00	; 0
    2ce0:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <ADC_ResultCh_GetWord_Signed>
    2ce4:	e8 0e       	add	r14, r24
    2ce6:	f9 1e       	adc	r15, r25
    2ce8:	01 50       	subi	r16, 0x01	; 1
    2cea:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    2cec:	89 f7       	brne	.-30     	; 0x2cd0 <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    2cee:	c7 01       	movw	r24, r14
    2cf0:	99 23       	and	r25, r25
    2cf2:	0c f4       	brge	.+2      	; 0x2cf6 <ADC_Offset_Get_Signed+0x40>
    2cf4:	03 96       	adiw	r24, 0x03	; 3
    2cf6:	95 95       	asr	r25
    2cf8:	87 95       	ror	r24
    2cfa:	95 95       	asr	r25
    2cfc:	87 95       	ror	r24
    2cfe:	0a c0       	rjmp	.+20     	; 0x2d14 <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    2d00:	88 81       	ld	r24, Y
    2d02:	80 68       	ori	r24, 0x80	; 128
    2d04:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    2d06:	8b 81       	ldd	r24, Y+3	; 0x03
    2d08:	80 ff       	sbrs	r24, 0
    2d0a:	fd cf       	rjmp	.-6      	; 0x2d06 <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    2d0c:	ce 01       	movw	r24, r28
    2d0e:	60 e0       	ldi	r22, 0x00	; 0
    2d10:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
    2d14:	df 91       	pop	r29
    2d16:	cf 91       	pop	r28
    2d18:	1f 91       	pop	r17
    2d1a:	0f 91       	pop	r16
    2d1c:	ff 90       	pop	r15
    2d1e:	ef 90       	pop	r14
    2d20:	08 95       	ret

00002d22 <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    2d22:	aa ec       	ldi	r26, 0xCA	; 202
    2d24:	b1 e0       	ldi	r27, 0x01	; 1
    2d26:	92 e0       	ldi	r25, 0x02	; 2
    2d28:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
    2d2a:	e8 2f       	mov	r30, r24
    2d2c:	f0 e0       	ldi	r31, 0x00	; 0
    2d2e:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    2d30:	1c 92       	st	X, r1

	return result;
}
    2d32:	08 95       	ret

00002d34 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    2d34:	cf 93       	push	r28
    2d36:	df 93       	push	r29
    2d38:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
    2d3a:	82 e0       	ldi	r24, 0x02	; 2
    2d3c:	c0 30       	cpi	r28, 0x00	; 0
    2d3e:	d8 07       	cpc	r29, r24
    2d40:	59 f4       	brne	.+22     	; 0x2d58 <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    2d42:	80 e2       	ldi	r24, 0x20	; 32
    2d44:	0e 94 91 16 	call	0x2d22	; 0x2d22 <SP_ReadCalibrationByte>
    2d48:	c0 e0       	ldi	r28, 0x00	; 0
    2d4a:	d2 e0       	ldi	r29, 0x02	; 2
    2d4c:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    2d4e:	81 e2       	ldi	r24, 0x21	; 33
    2d50:	0e 94 91 16 	call	0x2d22	; 0x2d22 <SP_ReadCalibrationByte>
    2d54:	8d 87       	std	Y+13, r24	; 0x0d
    2d56:	08 c0       	rjmp	.+16     	; 0x2d68 <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    2d58:	84 e2       	ldi	r24, 0x24	; 36
    2d5a:	0e 94 91 16 	call	0x2d22	; 0x2d22 <SP_ReadCalibrationByte>
    2d5e:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    2d60:	85 e2       	ldi	r24, 0x25	; 37
    2d62:	0e 94 91 16 	call	0x2d22	; 0x2d22 <SP_ReadCalibrationByte>
    2d66:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
    2d68:	df 91       	pop	r29
    2d6a:	cf 91       	pop	r28
    2d6c:	08 95       	ret

00002d6e <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
    2d6e:	84 e1       	ldi	r24, 0x14	; 20
    2d70:	e4 e1       	ldi	r30, 0x14	; 20
    2d72:	f1 e2       	ldi	r31, 0x21	; 33
    2d74:	df 01       	movw	r26, r30
    2d76:	1d 92       	st	X+, r1
    2d78:	8a 95       	dec	r24
    2d7a:	e9 f7       	brne	.-6      	; 0x2d76 <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
    2d7c:	0e 94 18 18 	call	0x3030	; 0x3030 <chb_get_short_addr>
    2d80:	80 93 14 21 	sts	0x2114, r24
    2d84:	90 93 15 21 	sts	0x2115, r25
    chb_drvr_init();
    2d88:	0e 94 6a 1a 	call	0x34d4	; 0x34d4 <chb_drvr_init>
	//radio_msg_received_int_enable();
}
    2d8c:	08 95       	ret

00002d8e <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
	PORTE.DIRSET = PIN2_bm;
    2d8e:	e0 e8       	ldi	r30, 0x80	; 128
    2d90:	f6 e0       	ldi	r31, 0x06	; 6
    2d92:	84 e0       	ldi	r24, 0x04	; 4
    2d94:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    2d96:	86 83       	std	Z+6, r24	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    2d98:	92 e0       	ldi	r25, 0x02	; 2
    2d9a:	90 8b       	std	Z+16, r25	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    2d9c:	82 87       	std	Z+10, r24	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    2d9e:	83 e0       	ldi	r24, 0x03	; 3
    2da0:	81 87       	std	Z+9, r24	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    2da2:	e0 ea       	ldi	r30, 0xA0	; 160
    2da4:	f0 e0       	ldi	r31, 0x00	; 0
    2da6:	82 81       	ldd	r24, Z+2	; 0x02
    2da8:	84 60       	ori	r24, 0x04	; 4
    2daa:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2dac:	78 94       	sei
}
    2dae:	08 95       	ret

00002db0 <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
    2db0:	84 e1       	ldi	r24, 0x14	; 20
    2db2:	91 e2       	ldi	r25, 0x21	; 33
    2db4:	08 95       	ret

00002db6 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    2db6:	2f 92       	push	r2
    2db8:	3f 92       	push	r3
    2dba:	4f 92       	push	r4
    2dbc:	5f 92       	push	r5
    2dbe:	6f 92       	push	r6
    2dc0:	7f 92       	push	r7
    2dc2:	8f 92       	push	r8
    2dc4:	9f 92       	push	r9
    2dc6:	af 92       	push	r10
    2dc8:	bf 92       	push	r11
    2dca:	cf 92       	push	r12
    2dcc:	df 92       	push	r13
    2dce:	ef 92       	push	r14
    2dd0:	ff 92       	push	r15
    2dd2:	0f 93       	push	r16
    2dd4:	1f 93       	push	r17
    2dd6:	cf 93       	push	r28
    2dd8:	df 93       	push	r29
    2dda:	cd b7       	in	r28, 0x3d	; 61
    2ddc:	de b7       	in	r29, 0x3e	; 62
    2dde:	2a 97       	sbiw	r28, 0x0a	; 10
    2de0:	cd bf       	out	0x3d, r28	; 61
    2de2:	de bf       	out	0x3e, r29	; 62
    2de4:	2c 01       	movw	r4, r24
    2de6:	1b 01       	movw	r2, r22
    2de8:	69 01       	movw	r12, r18
    2dea:	7a 01       	movw	r14, r20
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    2dec:	21 15       	cp	r18, r1
    2dee:	31 05       	cpc	r19, r1
    2df0:	41 05       	cpc	r20, r1
    2df2:	51 05       	cpc	r21, r1
    2df4:	09 f4       	brne	.+2      	; 0x2df8 <chb_write+0x42>
    2df6:	68 c0       	rjmp	.+208    	; 0x2ec8 <chb_write+0x112>
    U8 status, frm_len, hdr[CHB_HDR_SZ + 1];
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    2df8:	88 24       	eor	r8, r8
    2dfa:	99 24       	eor	r9, r9
    2dfc:	54 01       	movw	r10, r8
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    2dfe:	08 e9       	ldi	r16, 0x98	; 152

    *hdr_ptr++ = pcb.seq++;
    2e00:	0f 2e       	mov	r0, r31
    2e02:	f6 e1       	ldi	r31, 0x16	; 22
    2e04:	6f 2e       	mov	r6, r31
    2e06:	f1 e2       	ldi	r31, 0x21	; 33
    2e08:	7f 2e       	mov	r7, r31
    2e0a:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    2e0c:	1c 2d       	mov	r17, r12
    2e0e:	85 e6       	ldi	r24, 0x65	; 101
    2e10:	c8 16       	cp	r12, r24
    2e12:	d1 04       	cpc	r13, r1
    2e14:	e1 04       	cpc	r14, r1
    2e16:	f1 04       	cpc	r15, r1
    2e18:	08 f0       	brcs	.+2      	; 0x2e1c <chb_write+0x66>
    2e1a:	14 e6       	ldi	r17, 0x64	; 100
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    2e1c:	81 2f       	mov	r24, r17
    2e1e:	85 5f       	subi	r24, 0xF5	; 245
    2e20:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    2e22:	9f ef       	ldi	r25, 0xFF	; 255
    2e24:	49 16       	cp	r4, r25
    2e26:	9f ef       	ldi	r25, 0xFF	; 255
    2e28:	59 06       	cpc	r5, r25
    2e2a:	11 f0       	breq	.+4      	; 0x2e30 <chb_write+0x7a>
    2e2c:	81 e6       	ldi	r24, 0x61	; 97
    2e2e:	01 c0       	rjmp	.+2      	; 0x2e32 <chb_write+0x7c>
    2e30:	81 e4       	ldi	r24, 0x41	; 65
    2e32:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    2e34:	0b 83       	std	Y+3, r16	; 0x03

    *hdr_ptr++ = pcb.seq++;
    2e36:	f3 01       	movw	r30, r6
    2e38:	80 81       	ld	r24, Z
    2e3a:	8c 83       	std	Y+4, r24	; 0x04
    2e3c:	8f 5f       	subi	r24, 0xFF	; 255
    2e3e:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    2e40:	84 e3       	ldi	r24, 0x34	; 52
    2e42:	92 e1       	ldi	r25, 0x12	; 18
    2e44:	8d 83       	std	Y+5, r24	; 0x05
    2e46:	9e 83       	std	Y+6, r25	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
    2e48:	4f 82       	std	Y+7, r4	; 0x07
    2e4a:	58 86       	std	Y+8, r5	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
    2e4c:	e4 e1       	ldi	r30, 0x14	; 20
    2e4e:	f1 e2       	ldi	r31, 0x21	; 33
    2e50:	80 81       	ld	r24, Z
    2e52:	91 81       	ldd	r25, Z+1	; 0x01
    2e54:	89 87       	std	Y+9, r24	; 0x09
    2e56:	9a 87       	std	Y+10, r25	; 0x0a
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		//rtry = 0;
		//do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    2e58:	b1 01       	movw	r22, r2
    2e5a:	68 0d       	add	r22, r8
    2e5c:	79 1d       	adc	r23, r9
    2e5e:	ce 01       	movw	r24, r28
    2e60:	01 96       	adiw	r24, 0x01	; 1
    2e62:	41 2f       	mov	r20, r17
    2e64:	0e 94 a6 19 	call	0x334c	; 0x334c <chb_tx>

             switch (status)
    2e68:	83 30       	cpi	r24, 0x03	; 3
    2e6a:	c9 f0       	breq	.+50     	; 0x2e9e <chb_write+0xe8>
    2e6c:	84 30       	cpi	r24, 0x04	; 4
    2e6e:	18 f4       	brcc	.+6      	; 0x2e76 <chb_write+0xc0>
    2e70:	81 30       	cpi	r24, 0x01	; 1
    2e72:	e1 f4       	brne	.+56     	; 0x2eac <chb_write+0xf6>
    2e74:	04 c0       	rjmp	.+8      	; 0x2e7e <chb_write+0xc8>
    2e76:	85 30       	cpi	r24, 0x05	; 5
    2e78:	51 f0       	breq	.+20     	; 0x2e8e <chb_write+0xd8>
    2e7a:	80 34       	cpi	r24, 0x40	; 64
    2e7c:	b9 f4       	brne	.+46     	; 0x2eac <chb_write+0xf6>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    2e7e:	eb e1       	ldi	r30, 0x1B	; 27
    2e80:	f1 e2       	ldi	r31, 0x21	; 33
    2e82:	80 81       	ld	r24, Z
    2e84:	91 81       	ldd	r25, Z+1	; 0x01
    2e86:	01 96       	adiw	r24, 0x01	; 1
    2e88:	80 83       	st	Z, r24
    2e8a:	91 83       	std	Z+1, r25	; 0x01
                 break;
    2e8c:	0f c0       	rjmp	.+30     	; 0x2eac <chb_write+0xf6>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    2e8e:	ed e1       	ldi	r30, 0x1D	; 29
    2e90:	f1 e2       	ldi	r31, 0x21	; 33
    2e92:	80 81       	ld	r24, Z
    2e94:	91 81       	ldd	r25, Z+1	; 0x01
    2e96:	01 96       	adiw	r24, 0x01	; 1
    2e98:	80 83       	st	Z, r24
    2e9a:	91 83       	std	Z+1, r25	; 0x01
				 //rtry++;
                 break;
    2e9c:	07 c0       	rjmp	.+14     	; 0x2eac <chb_write+0xf6>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    2e9e:	ef e1       	ldi	r30, 0x1F	; 31
    2ea0:	f1 e2       	ldi	r31, 0x21	; 33
    2ea2:	80 81       	ld	r24, Z
    2ea4:	91 81       	ldd	r25, Z+1	; 0x01
    2ea6:	01 96       	adiw	r24, 0x01	; 1
    2ea8:	80 83       	st	Z, r24
    2eaa:	91 83       	std	Z+1, r25	; 0x01
             }
			//if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
			//if(rtry==20) return status;;		//after 20 tries give up on sending the message	
		//} while(status != CHB_SUCCESS);			
        // adjust len and restart
		frm_offset += frm_len;
    2eac:	81 2f       	mov	r24, r17
    2eae:	90 e0       	ldi	r25, 0x00	; 0
    2eb0:	a0 e0       	ldi	r26, 0x00	; 0
    2eb2:	b0 e0       	ldi	r27, 0x00	; 0
    2eb4:	88 0e       	add	r8, r24
    2eb6:	99 1e       	adc	r9, r25
    2eb8:	aa 1e       	adc	r10, r26
    2eba:	bb 1e       	adc	r11, r27
        len = len - frm_len;
    2ebc:	c8 1a       	sub	r12, r24
    2ebe:	d9 0a       	sbc	r13, r25
    2ec0:	ea 0a       	sbc	r14, r26
    2ec2:	fb 0a       	sbc	r15, r27
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    2ec4:	09 f0       	breq	.+2      	; 0x2ec8 <chb_write+0x112>
    2ec6:	a2 cf       	rjmp	.-188    	; 0x2e0c <chb_write+0x56>
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(100);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
}
    2ec8:	80 e0       	ldi	r24, 0x00	; 0
    2eca:	2a 96       	adiw	r28, 0x0a	; 10
    2ecc:	cd bf       	out	0x3d, r28	; 61
    2ece:	de bf       	out	0x3e, r29	; 62
    2ed0:	df 91       	pop	r29
    2ed2:	cf 91       	pop	r28
    2ed4:	1f 91       	pop	r17
    2ed6:	0f 91       	pop	r16
    2ed8:	ff 90       	pop	r15
    2eda:	ef 90       	pop	r14
    2edc:	df 90       	pop	r13
    2ede:	cf 90       	pop	r12
    2ee0:	bf 90       	pop	r11
    2ee2:	af 90       	pop	r10
    2ee4:	9f 90       	pop	r9
    2ee6:	8f 90       	pop	r8
    2ee8:	7f 90       	pop	r7
    2eea:	6f 90       	pop	r6
    2eec:	5f 90       	pop	r5
    2eee:	4f 90       	pop	r4
    2ef0:	3f 90       	pop	r3
    2ef2:	2f 90       	pop	r2
    2ef4:	08 95       	ret

00002ef6 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    2ef6:	df 92       	push	r13
    2ef8:	ef 92       	push	r14
    2efa:	ff 92       	push	r15
    2efc:	0f 93       	push	r16
    2efe:	1f 93       	push	r17
    2f00:	cf 93       	push	r28
    2f02:	df 93       	push	r29
    2f04:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    2f06:	0e 94 f6 17 	call	0x2fec	; 0x2fec <chb_buf_read>
    2f0a:	d8 2e       	mov	r13, r24
    2f0c:	88 23       	and	r24, r24
    2f0e:	0c f4       	brge	.+2      	; 0x2f12 <chb_read+0x1c>
    2f10:	46 c0       	rjmp	.+140    	; 0x2f9e <chb_read+0xa8>
    {
        return 0;
    }
    *data_ptr++ = len;
    2f12:	f7 01       	movw	r30, r14
    2f14:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    2f16:	88 23       	and	r24, r24
    2f18:	71 f0       	breq	.+28     	; 0x2f36 <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
    2f1a:	e7 01       	movw	r28, r14
    2f1c:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
    2f1e:	87 01       	movw	r16, r14
    2f20:	09 5f       	subi	r16, 0xF9	; 249
    2f22:	1f 4f       	sbci	r17, 0xFF	; 255
    2f24:	81 50       	subi	r24, 0x01	; 1
    2f26:	08 0f       	add	r16, r24
    2f28:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
    2f2a:	0e 94 f6 17 	call	0x2fec	; 0x2fec <chb_buf_read>
    2f2e:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    2f30:	c0 17       	cp	r28, r16
    2f32:	d1 07       	cpc	r29, r17
    2f34:	d1 f7       	brne	.-12     	; 0x2f2a <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
    2f36:	f7 01       	movw	r30, r14
    2f38:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
    2f3a:	83 85       	ldd	r24, Z+11	; 0x0b
    2f3c:	94 85       	ldd	r25, Z+12	; 0x0c
    2f3e:	83 83       	std	Z+3, r24	; 0x03
    2f40:	94 83       	std	Z+4, r25	; 0x04
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
    2f42:	85 85       	ldd	r24, Z+13	; 0x0d
    2f44:	96 85       	ldd	r25, Z+14	; 0x0e
    2f46:	81 83       	std	Z+1, r24	; 0x01
    2f48:	92 83       	std	Z+2, r25	; 0x02
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    2f4a:	0e 94 0d 18 	call	0x301a	; 0x301a <chb_buf_get_len>
    2f4e:	88 23       	and	r24, r24
    2f50:	11 f4       	brne	.+4      	; 0x2f56 <chb_read+0x60>
    {
        pcb.data_rcv = false;
    2f52:	10 92 17 21 	sts	0x2117, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    2f56:	80 91 0a 20 	lds	r24, 0x200A
    2f5a:	c8 17       	cp	r28, r24
    2f5c:	51 f4       	brne	.+20     	; 0x2f72 <chb_read+0x7c>
    2f5e:	f7 01       	movw	r30, r14
    2f60:	21 81       	ldd	r18, Z+1	; 0x01
    2f62:	32 81       	ldd	r19, Z+2	; 0x02
    2f64:	80 91 0b 20 	lds	r24, 0x200B
    2f68:	90 91 0c 20 	lds	r25, 0x200C
    2f6c:	28 17       	cp	r18, r24
    2f6e:	39 07       	cpc	r19, r25
    2f70:	c1 f0       	breq	.+48     	; 0x2fa2 <chb_read+0xac>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
    2f72:	c0 93 0a 20 	sts	0x200A, r28
        prev_src_addr = rx->src_addr;
    2f76:	f7 01       	movw	r30, r14
    2f78:	81 81       	ldd	r24, Z+1	; 0x01
    2f7a:	92 81       	ldd	r25, Z+2	; 0x02
    2f7c:	80 93 0b 20 	sts	0x200B, r24
    2f80:	90 93 0c 20 	sts	0x200C, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    2f84:	b7 01       	movw	r22, r14
    2f86:	61 5f       	subi	r22, 0xF1	; 241
    2f88:	7f 4f       	sbci	r23, 0xFF	; 255
    2f8a:	4d 2d       	mov	r20, r13
    2f8c:	50 e0       	ldi	r21, 0x00	; 0
    2f8e:	49 50       	subi	r20, 0x09	; 9
    2f90:	50 40       	sbci	r21, 0x00	; 0
    2f92:	c7 01       	movw	r24, r14
    2f94:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    2f98:	8d 2d       	mov	r24, r13
    2f9a:	8b 50       	subi	r24, 0x0B	; 11
    2f9c:	03 c0       	rjmp	.+6      	; 0x2fa4 <chb_read+0xae>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    2f9e:	80 e0       	ldi	r24, 0x00	; 0
    2fa0:	01 c0       	rjmp	.+2      	; 0x2fa4 <chb_read+0xae>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    2fa2:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
    2fa4:	df 91       	pop	r29
    2fa6:	cf 91       	pop	r28
    2fa8:	1f 91       	pop	r17
    2faa:	0f 91       	pop	r16
    2fac:	ff 90       	pop	r15
    2fae:	ef 90       	pop	r14
    2fb0:	df 90       	pop	r13
    2fb2:	08 95       	ret

00002fb4 <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
    2fb4:	10 92 28 21 	sts	0x2128, r1
    wr_ptr = 0;
    2fb8:	10 92 29 21 	sts	0x2129, r1
    len = 0;
    2fbc:	10 92 2a 21 	sts	0x212A, r1
}
    2fc0:	08 95       	ret

00002fc2 <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
    2fc2:	20 91 29 21 	lds	r18, 0x2129
    2fc6:	30 e0       	ldi	r19, 0x00	; 0
    2fc8:	f9 01       	movw	r30, r18
    2fca:	e5 5d       	subi	r30, 0xD5	; 213
    2fcc:	fe 4d       	sbci	r31, 0xDE	; 222
    2fce:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    2fd0:	c9 01       	movw	r24, r18
    2fd2:	01 96       	adiw	r24, 0x01	; 1
    2fd4:	60 e8       	ldi	r22, 0x80	; 128
    2fd6:	70 e0       	ldi	r23, 0x00	; 0
    2fd8:	0e 94 fe 35 	call	0x6bfc	; 0x6bfc <__divmodhi4>
    2fdc:	80 93 29 21 	sts	0x2129, r24
    len++;
    2fe0:	80 91 2a 21 	lds	r24, 0x212A
    2fe4:	8f 5f       	subi	r24, 0xFF	; 255
    2fe6:	80 93 2a 21 	sts	0x212A, r24
}
    2fea:	08 95       	ret

00002fec <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
    2fec:	20 91 28 21 	lds	r18, 0x2128
    2ff0:	30 e0       	ldi	r19, 0x00	; 0
    2ff2:	f9 01       	movw	r30, r18
    2ff4:	e5 5d       	subi	r30, 0xD5	; 213
    2ff6:	fe 4d       	sbci	r31, 0xDE	; 222
    2ff8:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    2ffa:	2f 5f       	subi	r18, 0xFF	; 255
    2ffc:	3f 4f       	sbci	r19, 0xFF	; 255
    2ffe:	c9 01       	movw	r24, r18
    3000:	60 e8       	ldi	r22, 0x80	; 128
    3002:	70 e0       	ldi	r23, 0x00	; 0
    3004:	0e 94 fe 35 	call	0x6bfc	; 0x6bfc <__divmodhi4>
    3008:	80 93 28 21 	sts	0x2128, r24
    len--;
    300c:	80 91 2a 21 	lds	r24, 0x212A
    3010:	81 50       	subi	r24, 0x01	; 1
    3012:	80 93 2a 21 	sts	0x212A, r24
    return data;
}
    3016:	84 2f       	mov	r24, r20
    3018:	08 95       	ret

0000301a <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
    301a:	80 91 2a 21 	lds	r24, 0x212A
    301e:	08 95       	ret

00003020 <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    3020:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    3022:	80 e0       	ldi	r24, 0x00	; 0
    3024:	90 e0       	ldi	r25, 0x00	; 0
    3026:	48 e0       	ldi	r20, 0x08	; 8
    3028:	50 e0       	ldi	r21, 0x00	; 0
    302a:	0e 94 63 1c 	call	0x38c6	; 0x38c6 <chb_eeprom_read>
}
    302e:	08 95       	ret

00003030 <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    3030:	cf 93       	push	r28
    3032:	df 93       	push	r29
    3034:	0f 92       	push	r0
    3036:	0f 92       	push	r0
    3038:	cd b7       	in	r28, 0x3d	; 61
    303a:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    303c:	89 e0       	ldi	r24, 0x09	; 9
    303e:	90 e0       	ldi	r25, 0x00	; 0
    3040:	be 01       	movw	r22, r28
    3042:	6f 5f       	subi	r22, 0xFF	; 255
    3044:	7f 4f       	sbci	r23, 0xFF	; 255
    3046:	42 e0       	ldi	r20, 0x02	; 2
    3048:	50 e0       	ldi	r21, 0x00	; 0
    304a:	0e 94 63 1c 	call	0x38c6	; 0x38c6 <chb_eeprom_read>
    return *(U16 *)addr;
}
    304e:	89 81       	ldd	r24, Y+1	; 0x01
    3050:	9a 81       	ldd	r25, Y+2	; 0x02
    3052:	0f 90       	pop	r0
    3054:	0f 90       	pop	r0
    3056:	df 91       	pop	r29
    3058:	cf 91       	pop	r28
    305a:	08 95       	ret

0000305c <RadioCS>:
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
}

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    305c:	88 23       	and	r24, r24
    305e:	29 f0       	breq	.+10     	; 0x306a <RadioCS+0xe>
    3060:	80 e1       	ldi	r24, 0x10	; 16
    3062:	e0 e6       	ldi	r30, 0x60	; 96
    3064:	f6 e0       	ldi	r31, 0x06	; 6
    3066:	86 83       	std	Z+6, r24	; 0x06
    3068:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    306a:	80 e1       	ldi	r24, 0x10	; 16
    306c:	e0 e6       	ldi	r30, 0x60	; 96
    306e:	f6 e0       	ldi	r31, 0x06	; 6
    3070:	85 83       	std	Z+5, r24	; 0x05
    3072:	08 95       	ret

00003074 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    3074:	df 92       	push	r13
    3076:	ef 92       	push	r14
    3078:	ff 92       	push	r15
    307a:	0f 93       	push	r16
    307c:	1f 93       	push	r17
    307e:	cf 93       	push	r28
    3080:	df 93       	push	r29
    3082:	8c 01       	movw	r16, r24
    3084:	c6 2f       	mov	r28, r22
    3086:	7a 01       	movw	r14, r20
    3088:	d2 2e       	mov	r13, r18
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    308a:	82 2f       	mov	r24, r18
    308c:	90 e0       	ldi	r25, 0x00	; 0
    308e:	86 0f       	add	r24, r22
    3090:	91 1d       	adc	r25, r1
    3092:	80 38       	cpi	r24, 0x80	; 128
    3094:	91 05       	cpc	r25, r1
    3096:	8c f5       	brge	.+98     	; 0x30fa <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    3098:	8f b7       	in	r24, 0x3f	; 63
    309a:	80 93 55 40 	sts	0x4055, r24
    309e:	f8 94       	cli
    RadioCS(TRUE); 
    30a0:	81 e0       	ldi	r24, 0x01	; 1
    30a2:	0e 94 2e 18 	call	0x305c	; 0x305c <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    30a6:	80 e6       	ldi	r24, 0x60	; 96
    30a8:	0e 94 ae 1c 	call	0x395c	; 0x395c <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    30ac:	cc 23       	and	r28, r28
    30ae:	79 f0       	breq	.+30     	; 0x30ce <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    30b0:	c8 01       	movw	r24, r16
    30b2:	01 96       	adiw	r24, 0x01	; 1
    30b4:	c1 50       	subi	r28, 0x01	; 1
    30b6:	9c 01       	movw	r18, r24
    30b8:	2c 0f       	add	r18, r28
    30ba:	31 1d       	adc	r19, r1
    30bc:	e9 01       	movw	r28, r18

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    30be:	f8 01       	movw	r30, r16
    30c0:	81 91       	ld	r24, Z+
    30c2:	8f 01       	movw	r16, r30
    30c4:	0e 94 ae 1c 	call	0x395c	; 0x395c <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    30c8:	0c 17       	cp	r16, r28
    30ca:	1d 07       	cpc	r17, r29
    30cc:	c1 f7       	brne	.-16     	; 0x30be <chb_frame_write+0x4a>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    30ce:	dd 20       	and	r13, r13
    30d0:	69 f0       	breq	.+26     	; 0x30ec <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    30d2:	e7 01       	movw	r28, r14
    30d4:	21 96       	adiw	r28, 0x01	; 1
    30d6:	da 94       	dec	r13
    30d8:	cd 0d       	add	r28, r13
    30da:	d1 1d       	adc	r29, r1

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    30dc:	f7 01       	movw	r30, r14
    30de:	81 91       	ld	r24, Z+
    30e0:	7f 01       	movw	r14, r30
    30e2:	0e 94 ae 1c 	call	0x395c	; 0x395c <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    30e6:	ec 16       	cp	r14, r28
    30e8:	fd 06       	cpc	r15, r29
    30ea:	c1 f7       	brne	.-16     	; 0x30dc <chb_frame_write+0x68>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    30ec:	80 e0       	ldi	r24, 0x00	; 0
    30ee:	0e 94 2e 18 	call	0x305c	; 0x305c <RadioCS>
    CHB_LEAVE_CRIT();
    30f2:	80 91 55 40 	lds	r24, 0x4055
    30f6:	8f bf       	out	0x3f, r24	; 63
    30f8:	78 94       	sei
}
    30fa:	df 91       	pop	r29
    30fc:	cf 91       	pop	r28
    30fe:	1f 91       	pop	r17
    3100:	0f 91       	pop	r16
    3102:	ff 90       	pop	r15
    3104:	ef 90       	pop	r14
    3106:	df 90       	pop	r13
    3108:	08 95       	ret

0000310a <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    310a:	cf 93       	push	r28
    310c:	df 93       	push	r29
    310e:	d8 2f       	mov	r29, r24
    3110:	c6 2f       	mov	r28, r22
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
    3112:	8f b7       	in	r24, 0x3f	; 63
    3114:	80 93 55 40 	sts	0x4055, r24
    3118:	f8 94       	cli
    RadioCS(TRUE);
    311a:	81 e0       	ldi	r24, 0x01	; 1
    311c:	0e 94 2e 18 	call	0x305c	; 0x305c <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    3120:	8d 2f       	mov	r24, r29
    3122:	80 6c       	ori	r24, 0xC0	; 192
    3124:	0e 94 ae 1c 	call	0x395c	; 0x395c <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    3128:	8c 2f       	mov	r24, r28
    312a:	0e 94 ae 1c 	call	0x395c	; 0x395c <SPID_write>

    RadioCS(FALSE);
    312e:	80 e0       	ldi	r24, 0x00	; 0
    3130:	0e 94 2e 18 	call	0x305c	; 0x305c <RadioCS>
    CHB_LEAVE_CRIT();
    3134:	80 91 55 40 	lds	r24, 0x4055
    3138:	8f bf       	out	0x3f, r24	; 63
    313a:	78 94       	sei
}
    313c:	df 91       	pop	r29
    313e:	cf 91       	pop	r28
    3140:	08 95       	ret

00003142 <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    3142:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
    3144:	85 e0       	ldi	r24, 0x05	; 5
    3146:	0e 94 85 18 	call	0x310a	; 0x310a <chb_reg_write>
}
    314a:	08 95       	ret

0000314c <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    314c:	0f 93       	push	r16
    314e:	1f 93       	push	r17
    3150:	cf 93       	push	r28
    3152:	df 93       	push	r29
    3154:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
    3156:	c6 2f       	mov	r28, r22
    3158:	d7 2f       	mov	r29, r23
    315a:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
    315c:	69 91       	ld	r22, Y+
    315e:	81 2f       	mov	r24, r17
    3160:	80 0f       	add	r24, r16
    3162:	0e 94 85 18 	call	0x310a	; 0x310a <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    3166:	1f 5f       	subi	r17, 0xFF	; 255
    3168:	18 30       	cpi	r17, 0x08	; 8
    316a:	c1 f7       	brne	.-16     	; 0x315c <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    316c:	df 91       	pop	r29
    316e:	cf 91       	pop	r28
    3170:	1f 91       	pop	r17
    3172:	0f 91       	pop	r16
    3174:	08 95       	ret

00003176 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    3176:	cf 93       	push	r28
    3178:	df 93       	push	r29
    317a:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    317c:	80 e0       	ldi	r24, 0x00	; 0
    317e:	90 e0       	ldi	r25, 0x00	; 0
    3180:	be 01       	movw	r22, r28
    3182:	48 e0       	ldi	r20, 0x08	; 8
    3184:	50 e0       	ldi	r21, 0x00	; 0
    3186:	0e 94 00 1c 	call	0x3800	; 0x3800 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    318a:	84 e2       	ldi	r24, 0x24	; 36
    318c:	be 01       	movw	r22, r28
    318e:	0e 94 a6 18 	call	0x314c	; 0x314c <chb_reg_write64>
}
    3192:	df 91       	pop	r29
    3194:	cf 91       	pop	r28
    3196:	08 95       	ret

00003198 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    3198:	cf 93       	push	r28
    319a:	df 93       	push	r29
    319c:	c8 2f       	mov	r28, r24
    319e:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
    31a0:	0e 94 85 18 	call	0x310a	; 0x310a <chb_reg_write>
    31a4:	8c 2f       	mov	r24, r28
    31a6:	8f 5f       	subi	r24, 0xFF	; 255
    31a8:	6d 2f       	mov	r22, r29
    31aa:	0e 94 85 18 	call	0x310a	; 0x310a <chb_reg_write>
    }
}
    31ae:	df 91       	pop	r29
    31b0:	cf 91       	pop	r28
    31b2:	08 95       	ret

000031b4 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    31b4:	0f 93       	push	r16
    31b6:	1f 93       	push	r17
    31b8:	cf 93       	push	r28
    31ba:	df 93       	push	r29
    31bc:	0f 92       	push	r0
    31be:	0f 92       	push	r0
    31c0:	cd b7       	in	r28, 0x3d	; 61
    31c2:	de b7       	in	r29, 0x3e	; 62
    31c4:	89 83       	std	Y+1, r24	; 0x01
    31c6:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
    31c8:	0e 94 d8 16 	call	0x2db0	; 0x2db0 <chb_get_pcb>
    31cc:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    31ce:	89 e0       	ldi	r24, 0x09	; 9
    31d0:	90 e0       	ldi	r25, 0x00	; 0
    31d2:	be 01       	movw	r22, r28
    31d4:	6f 5f       	subi	r22, 0xFF	; 255
    31d6:	7f 4f       	sbci	r23, 0xFF	; 255
    31d8:	42 e0       	ldi	r20, 0x02	; 2
    31da:	50 e0       	ldi	r21, 0x00	; 0
    31dc:	0e 94 00 1c 	call	0x3800	; 0x3800 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    31e0:	69 81       	ldd	r22, Y+1	; 0x01
    31e2:	7a 81       	ldd	r23, Y+2	; 0x02
    31e4:	80 e2       	ldi	r24, 0x20	; 32
    31e6:	0e 94 cc 18 	call	0x3198	; 0x3198 <chb_reg_write16>
    pcb->src_addr = addr;
    31ea:	89 81       	ldd	r24, Y+1	; 0x01
    31ec:	9a 81       	ldd	r25, Y+2	; 0x02
    31ee:	f8 01       	movw	r30, r16
    31f0:	80 83       	st	Z, r24
    31f2:	91 83       	std	Z+1, r25	; 0x01
}
    31f4:	0f 90       	pop	r0
    31f6:	0f 90       	pop	r0
    31f8:	df 91       	pop	r29
    31fa:	cf 91       	pop	r28
    31fc:	1f 91       	pop	r17
    31fe:	0f 91       	pop	r16
    3200:	08 95       	ret

00003202 <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    3202:	cf 93       	push	r28
    3204:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
    3206:	8f b7       	in	r24, 0x3f	; 63
    3208:	80 93 55 40 	sts	0x4055, r24
    320c:	f8 94       	cli
    RadioCS(TRUE);
    320e:	81 e0       	ldi	r24, 0x01	; 1
    3210:	0e 94 2e 18 	call	0x305c	; 0x305c <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    3214:	8c 2f       	mov	r24, r28
    3216:	80 68       	ori	r24, 0x80	; 128
    3218:	0e 94 ae 1c 	call	0x395c	; 0x395c <SPID_write>
    val = SPID_write(val);
    321c:	0e 94 ae 1c 	call	0x395c	; 0x395c <SPID_write>
    3220:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    3222:	80 e0       	ldi	r24, 0x00	; 0
    3224:	0e 94 2e 18 	call	0x305c	; 0x305c <RadioCS>
    CHB_LEAVE_CRIT();
    3228:	80 91 55 40 	lds	r24, 0x4055
    322c:	8f bf       	out	0x3f, r24	; 63
    322e:	78 94       	sei

    return val;
}
    3230:	8c 2f       	mov	r24, r28
    3232:	cf 91       	pop	r28
    3234:	08 95       	ret

00003236 <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
    3236:	81 e0       	ldi	r24, 0x01	; 1
    3238:	0e 94 01 19 	call	0x3202	; 0x3202 <chb_reg_read>
}
    323c:	8f 71       	andi	r24, 0x1F	; 31
    323e:	08 95       	ret

00003240 <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    3240:	1f 93       	push	r17
    3242:	cf 93       	push	r28
    3244:	df 93       	push	r29
    3246:	c8 2f       	mov	r28, r24
    3248:	16 2f       	mov	r17, r22
    324a:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
    324c:	0e 94 01 19 	call	0x3202	; 0x3202 <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
    3250:	6d 2f       	mov	r22, r29
    3252:	60 95       	com	r22
    3254:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
    3256:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
    3258:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
    325a:	8c 2f       	mov	r24, r28
    325c:	0e 94 85 18 	call	0x310a	; 0x310a <chb_reg_write>
}
    3260:	df 91       	pop	r29
    3262:	cf 91       	pop	r28
    3264:	1f 91       	pop	r17
    3266:	08 95       	ret

00003268 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    3268:	cf 93       	push	r28
    326a:	df 93       	push	r29
    326c:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    326e:	80 91 64 06 	lds	r24, 0x0664
    3272:	81 fd       	sbrc	r24, 1
    3274:	4b c0       	rjmp	.+150    	; 0x330c <chb_set_state+0xa4>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    3276:	0e 94 1b 19 	call	0x3236	; 0x3236 <chb_get_state>
    327a:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    327c:	81 51       	subi	r24, 0x11	; 17
    327e:	82 30       	cpi	r24, 0x02	; 2
    3280:	20 f0       	brcs	.+8      	; 0x328a <chb_set_state+0x22>
    3282:	c1 30       	cpi	r28, 0x01	; 1
    3284:	11 f0       	breq	.+4      	; 0x328a <chb_set_state+0x22>
    3286:	c2 30       	cpi	r28, 0x02	; 2
    3288:	21 f4       	brne	.+8      	; 0x3292 <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
    328a:	0e 94 1b 19 	call	0x3236	; 0x3236 <chb_get_state>
    328e:	8c 17       	cp	r24, r28
    3290:	e1 f3       	breq	.-8      	; 0x328a <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    3292:	d6 31       	cpi	r29, 0x16	; 22
    3294:	f9 f0       	breq	.+62     	; 0x32d4 <chb_set_state+0x6c>
    3296:	d9 31       	cpi	r29, 0x19	; 25
    3298:	89 f0       	breq	.+34     	; 0x32bc <chb_set_state+0x54>
    329a:	d8 30       	cpi	r29, 0x08	; 8
    329c:	31 f5       	brne	.+76     	; 0x32ea <chb_set_state+0x82>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    329e:	e4 e6       	ldi	r30, 0x64	; 100
    32a0:	f6 e0       	ldi	r31, 0x06	; 6
    32a2:	80 81       	ld	r24, Z
    32a4:	8d 7f       	andi	r24, 0xFD	; 253
    32a6:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    32a8:	82 e0       	ldi	r24, 0x02	; 2
    32aa:	63 e0       	ldi	r22, 0x03	; 3
    32ac:	4f e1       	ldi	r20, 0x1F	; 31
    32ae:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>
    32b2:	8a e0       	ldi	r24, 0x0A	; 10
    32b4:	8a 95       	dec	r24
    32b6:	f1 f7       	brne	.-4      	; 0x32b4 <chb_set_state+0x4c>
    32b8:	00 c0       	rjmp	.+0      	; 0x32ba <chb_set_state+0x52>
    32ba:	17 c0       	rjmp	.+46     	; 0x32ea <chb_set_state+0x82>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    32bc:	c6 31       	cpi	r28, 0x16	; 22
    32be:	a9 f4       	brne	.+42     	; 0x32ea <chb_set_state+0x82>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    32c0:	82 e0       	ldi	r24, 0x02	; 2
    32c2:	69 e0       	ldi	r22, 0x09	; 9
    32c4:	4f e1       	ldi	r20, 0x1F	; 31
    32c6:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>
    32ca:	9a e0       	ldi	r25, 0x0A	; 10
    32cc:	9a 95       	dec	r25
    32ce:	f1 f7       	brne	.-4      	; 0x32cc <chb_set_state+0x64>
    32d0:	00 c0       	rjmp	.+0      	; 0x32d2 <chb_set_state+0x6a>
    32d2:	0b c0       	rjmp	.+22     	; 0x32ea <chb_set_state+0x82>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    32d4:	c9 31       	cpi	r28, 0x19	; 25
    32d6:	49 f4       	brne	.+18     	; 0x32ea <chb_set_state+0x82>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    32d8:	82 e0       	ldi	r24, 0x02	; 2
    32da:	69 e0       	ldi	r22, 0x09	; 9
    32dc:	4f e1       	ldi	r20, 0x1F	; 31
    32de:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>
    32e2:	8a e0       	ldi	r24, 0x0A	; 10
    32e4:	8a 95       	dec	r24
    32e6:	f1 f7       	brne	.-4      	; 0x32e4 <chb_set_state+0x7c>
    32e8:	00 c0       	rjmp	.+0      	; 0x32ea <chb_set_state+0x82>
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    32ea:	82 e0       	ldi	r24, 0x02	; 2
    32ec:	6d 2f       	mov	r22, r29
    32ee:	4f e1       	ldi	r20, 0x1F	; 31
    32f0:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>
    32f4:	8f e6       	ldi	r24, 0x6F	; 111
    32f6:	93 e0       	ldi	r25, 0x03	; 3
    32f8:	01 97       	sbiw	r24, 0x01	; 1
    32fa:	f1 f7       	brne	.-4      	; 0x32f8 <chb_set_state+0x90>
    32fc:	00 c0       	rjmp	.+0      	; 0x32fe <chb_set_state+0x96>
    32fe:	00 00       	nop

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    3300:	0e 94 1b 19 	call	0x3236	; 0x3236 <chb_get_state>
    3304:	8d 17       	cp	r24, r29
    3306:	21 f4       	brne	.+8      	; 0x3310 <chb_set_state+0xa8>
    {
        return RADIO_SUCCESS;
    3308:	80 e4       	ldi	r24, 0x40	; 64
    330a:	03 c0       	rjmp	.+6      	; 0x3312 <chb_set_state+0xaa>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
    330c:	84 e4       	ldi	r24, 0x44	; 68
    330e:	01 c0       	rjmp	.+2      	; 0x3312 <chb_set_state+0xaa>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
    3310:	83 e4       	ldi	r24, 0x43	; 67
}
    3312:	df 91       	pop	r29
    3314:	cf 91       	pop	r28
    3316:	08 95       	ret

00003318 <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
    3318:	88 23       	and	r24, r24
    331a:	49 f0       	breq	.+18     	; 0x332e <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    331c:	88 e0       	ldi	r24, 0x08	; 8
    331e:	0e 94 34 19 	call	0x3268	; 0x3268 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    3322:	e4 e6       	ldi	r30, 0x64	; 100
    3324:	f6 e0       	ldi	r31, 0x06	; 6
    3326:	80 81       	ld	r24, Z
    3328:	82 60       	ori	r24, 0x02	; 2
    332a:	80 83       	st	Z, r24
    332c:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    332e:	e4 e6       	ldi	r30, 0x64	; 100
    3330:	f6 e0       	ldi	r31, 0x06	; 6
    3332:	80 81       	ld	r24, Z
    3334:	8d 7f       	andi	r24, 0xFD	; 253
    3336:	80 83       	st	Z, r24
    3338:	8f e7       	ldi	r24, 0x7F	; 127
    333a:	97 e0       	ldi	r25, 0x07	; 7
    333c:	01 97       	sbiw	r24, 0x01	; 1
    333e:	f1 f7       	brne	.-4      	; 0x333c <chb_sleep+0x24>
    3340:	00 c0       	rjmp	.+0      	; 0x3342 <chb_sleep+0x2a>
    3342:	00 00       	nop

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    3344:	86 e1       	ldi	r24, 0x16	; 22
    3346:	0e 94 34 19 	call	0x3268	; 0x3268 <chb_set_state>
    334a:	08 95       	ret

0000334c <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    334c:	cf 92       	push	r12
    334e:	df 92       	push	r13
    3350:	ef 92       	push	r14
    3352:	ff 92       	push	r15
    3354:	0f 93       	push	r16
    3356:	1f 93       	push	r17
    3358:	cf 93       	push	r28
    335a:	df 93       	push	r29
    335c:	7c 01       	movw	r14, r24
    335e:	6b 01       	movw	r12, r22
    3360:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
    3362:	0e 94 1b 19 	call	0x3236	; 0x3236 <chb_get_state>
    3366:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
    3368:	0e 94 d8 16 	call	0x2db0	; 0x2db0 <chb_get_pcb>
    336c:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    336e:	12 30       	cpi	r17, 0x02	; 2
    3370:	f1 f0       	breq	.+60     	; 0x33ae <chb_tx+0x62>
    3372:	12 31       	cpi	r17, 0x12	; 18
    3374:	f1 f0       	breq	.+60     	; 0x33b2 <chb_tx+0x66>
    {
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    3376:	88 e0       	ldi	r24, 0x08	; 8
    3378:	0e 94 34 19 	call	0x3268	; 0x3268 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    337c:	89 e1       	ldi	r24, 0x19	; 25
    337e:	0e 94 34 19 	call	0x3268	; 0x3268 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    3382:	c7 01       	movw	r24, r14
    3384:	6a e0       	ldi	r22, 0x0A	; 10
    3386:	a6 01       	movw	r20, r12
    3388:	20 2f       	mov	r18, r16
    338a:	0e 94 3a 18 	call	0x3074	; 0x3074 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    338e:	82 e0       	ldi	r24, 0x02	; 2
    3390:	62 e0       	ldi	r22, 0x02	; 2
    3392:	4f e1       	ldi	r20, 0x1F	; 31
    3394:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    3398:	8c 81       	ldd	r24, Y+4	; 0x04
    339a:	88 23       	and	r24, r24
    339c:	e9 f3       	breq	.-6      	; 0x3398 <chb_tx+0x4c>
    pcb->tx_end = false;
    339e:	1c 82       	std	Y+4, r1	; 0x04

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    33a0:	82 e0       	ldi	r24, 0x02	; 2
    33a2:	0e 94 01 19 	call	0x3202	; 0x3202 <chb_reg_read>
    33a6:	82 95       	swap	r24
    33a8:	86 95       	lsr	r24
    33aa:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
    33ac:	03 c0       	rjmp	.+6      	; 0x33b4 <chb_tx+0x68>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
    33ae:	84 e4       	ldi	r24, 0x44	; 68
    33b0:	01 c0       	rjmp	.+2      	; 0x33b4 <chb_tx+0x68>
    33b2:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
    33b4:	df 91       	pop	r29
    33b6:	cf 91       	pop	r28
    33b8:	1f 91       	pop	r17
    33ba:	0f 91       	pop	r16
    33bc:	ff 90       	pop	r15
    33be:	ef 90       	pop	r14
    33c0:	df 90       	pop	r13
    33c2:	cf 90       	pop	r12
    33c4:	08 95       	ret

000033c6 <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
    33c6:	81 30       	cpi	r24, 0x01	; 1
    33c8:	91 f0       	breq	.+36     	; 0x33ee <chb_set_mode+0x28>
    33ca:	81 30       	cpi	r24, 0x01	; 1
    33cc:	28 f0       	brcs	.+10     	; 0x33d8 <chb_set_mode+0x12>
    33ce:	82 30       	cpi	r24, 0x02	; 2
    33d0:	c9 f0       	breq	.+50     	; 0x3404 <chb_set_mode+0x3e>
    33d2:	83 30       	cpi	r24, 0x03	; 3
    33d4:	61 f5       	brne	.+88     	; 0x342e <chb_set_mode+0x68>
    33d6:	21 c0       	rjmp	.+66     	; 0x341a <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    33d8:	8c e0       	ldi	r24, 0x0C	; 12
    33da:	68 e0       	ldi	r22, 0x08	; 8
    33dc:	4f e3       	ldi	r20, 0x3F	; 63
    33de:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    33e2:	86 e1       	ldi	r24, 0x16	; 22
    33e4:	62 e0       	ldi	r22, 0x02	; 2
    33e6:	43 e0       	ldi	r20, 0x03	; 3
    33e8:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>
        break;
    33ec:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    33ee:	8c e0       	ldi	r24, 0x0C	; 12
    33f0:	6c e0       	ldi	r22, 0x0C	; 12
    33f2:	4f e3       	ldi	r20, 0x3F	; 63
    33f4:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    33f8:	86 e1       	ldi	r24, 0x16	; 22
    33fa:	62 e0       	ldi	r22, 0x02	; 2
    33fc:	43 e0       	ldi	r20, 0x03	; 3
    33fe:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>
        break;
    3402:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    3404:	8c e0       	ldi	r24, 0x0C	; 12
    3406:	6c e1       	ldi	r22, 0x1C	; 28
    3408:	4f e3       	ldi	r20, 0x3F	; 63
    340a:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    340e:	86 e1       	ldi	r24, 0x16	; 22
    3410:	62 e0       	ldi	r22, 0x02	; 2
    3412:	43 e0       	ldi	r20, 0x03	; 3
    3414:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>
        break;
    3418:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    341a:	8c e0       	ldi	r24, 0x0C	; 12
    341c:	60 e0       	ldi	r22, 0x00	; 0
    341e:	4f e3       	ldi	r20, 0x3F	; 63
    3420:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    3424:	86 e1       	ldi	r24, 0x16	; 22
    3426:	63 e0       	ldi	r22, 0x03	; 3
    3428:	43 e0       	ldi	r20, 0x03	; 3
    342a:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>
    342e:	08 95       	ret

00003430 <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    3430:	cf 93       	push	r28
    3432:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    3434:	88 e0       	ldi	r24, 0x08	; 8
    3436:	6c 2f       	mov	r22, r28
    3438:	4f e1       	ldi	r20, 0x1F	; 31
    343a:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    343e:	0e 94 1b 19 	call	0x3236	; 0x3236 <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    3442:	86 30       	cpi	r24, 0x06	; 6
    3444:	11 f0       	breq	.+4      	; 0x344a <chb_set_channel+0x1a>
    3446:	89 30       	cpi	r24, 0x09	; 9
    3448:	31 f4       	brne	.+12     	; 0x3456 <chb_set_channel+0x26>
    344a:	8f e6       	ldi	r24, 0x6F	; 111
    344c:	93 e0       	ldi	r25, 0x03	; 3
    344e:	01 97       	sbiw	r24, 0x01	; 1
    3450:	f1 f7       	brne	.-4      	; 0x344e <chb_set_channel+0x1e>
    3452:	00 c0       	rjmp	.+0      	; 0x3454 <chb_set_channel+0x24>
    3454:	00 00       	nop
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    3456:	88 e0       	ldi	r24, 0x08	; 8
    3458:	0e 94 01 19 	call	0x3202	; 0x3202 <chb_reg_read>
    345c:	90 e0       	ldi	r25, 0x00	; 0
    345e:	8f 71       	andi	r24, 0x1F	; 31
    3460:	90 70       	andi	r25, 0x00	; 0
    3462:	6c 2f       	mov	r22, r28
    3464:	70 e0       	ldi	r23, 0x00	; 0
    3466:	86 17       	cp	r24, r22
    3468:	97 07       	cpc	r25, r23
    346a:	11 f4       	brne	.+4      	; 0x3470 <chb_set_channel+0x40>
    346c:	80 e4       	ldi	r24, 0x40	; 64
    346e:	01 c0       	rjmp	.+2      	; 0x3472 <chb_set_channel+0x42>
    3470:	83 e4       	ldi	r24, 0x43	; 67
}
    3472:	cf 91       	pop	r28
    3474:	08 95       	ret

00003476 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    3476:	cf 93       	push	r28
    3478:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    347a:	0e 94 01 19 	call	0x3202	; 0x3202 <chb_reg_read>
    347e:	8c 2b       	or	r24, r28
    3480:	8f 5f       	subi	r24, 0xFF	; 255
    3482:	0e 94 01 19 	call	0x3202	; 0x3202 <chb_reg_read>
    }
    return val;
}
    3486:	80 e0       	ldi	r24, 0x00	; 0
    3488:	90 e0       	ldi	r25, 0x00	; 0
    348a:	cf 91       	pop	r28
    348c:	08 95       	ret

0000348e <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
    348e:	e4 e6       	ldi	r30, 0x64	; 100
    3490:	f6 e0       	ldi	r31, 0x06	; 6
    3492:	80 81       	ld	r24, Z
    3494:	81 60       	ori	r24, 0x01	; 1
    3496:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
    3498:	80 81       	ld	r24, Z
    349a:	8d 7f       	andi	r24, 0xFD	; 253
    349c:	80 83       	st	Z, r24
    349e:	8f ed       	ldi	r24, 0xDF	; 223
    34a0:	9b e0       	ldi	r25, 0x0B	; 11
    34a2:	01 97       	sbiw	r24, 0x01	; 1
    34a4:	f1 f7       	brne	.-4      	; 0x34a2 <chb_reset+0x14>
    34a6:	00 c0       	rjmp	.+0      	; 0x34a8 <chb_reset+0x1a>
    34a8:	00 00       	nop

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    34aa:	80 81       	ld	r24, Z
    34ac:	8e 7f       	andi	r24, 0xFE	; 254
    34ae:	80 83       	st	Z, r24
    34b0:	9a e0       	ldi	r25, 0x0A	; 10
    34b2:	9a 95       	dec	r25
    34b4:	f1 f7       	brne	.-4      	; 0x34b2 <chb_reset+0x24>
    34b6:	00 c0       	rjmp	.+0      	; 0x34b8 <chb_reset+0x2a>
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    34b8:	80 81       	ld	r24, Z
    34ba:	81 60       	ori	r24, 0x01	; 1
    34bc:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    34be:	8d e1       	ldi	r24, 0x1D	; 29
    34c0:	0e 94 01 19 	call	0x3202	; 0x3202 <chb_reg_read>
    34c4:	81 30       	cpi	r24, 0x01	; 1
    34c6:	d9 f7       	brne	.-10     	; 0x34be <chb_reset+0x30>
    34c8:	8c e1       	ldi	r24, 0x1C	; 28
    34ca:	0e 94 01 19 	call	0x3202	; 0x3202 <chb_reg_read>
    34ce:	87 30       	cpi	r24, 0x07	; 7
    34d0:	b1 f7       	brne	.-20     	; 0x34be <chb_reset+0x30>
            break;
        }
    }
	

}
    34d2:	08 95       	ret

000034d4 <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    34d4:	0f 93       	push	r16
    34d6:	1f 93       	push	r17
    34d8:	cf 93       	push	r28
    34da:	df 93       	push	r29
    34dc:	cd b7       	in	r28, 0x3d	; 61
    34de:	de b7       	in	r29, 0x3e	; 62
    34e0:	ea 97       	sbiw	r28, 0x3a	; 58
    34e2:	cd bf       	out	0x3d, r28	; 61
    34e4:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    34e6:	0e 94 9b 1c 	call	0x3936	; 0x3936 <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    34ea:	e0 e6       	ldi	r30, 0x60	; 96
    34ec:	f6 e0       	ldi	r31, 0x06	; 6
    34ee:	80 81       	ld	r24, Z
    34f0:	82 60       	ori	r24, 0x02	; 2
    34f2:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    34f4:	80 81       	ld	r24, Z
    34f6:	81 60       	ori	r24, 0x01	; 1
    34f8:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    34fa:	0e 94 47 1a 	call	0x348e	; 0x348e <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    34fe:	8e e0       	ldi	r24, 0x0E	; 14
    3500:	60 e0       	ldi	r22, 0x00	; 0
    3502:	0e 94 85 18 	call	0x310a	; 0x310a <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    3506:	82 e0       	ldi	r24, 0x02	; 2
    3508:	63 e0       	ldi	r22, 0x03	; 3
    350a:	4f e1       	ldi	r20, 0x1F	; 31
    350c:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    3510:	81 e0       	ldi	r24, 0x01	; 1
    3512:	0e 94 01 19 	call	0x3202	; 0x3202 <chb_reg_read>
    3516:	8f 71       	andi	r24, 0x1F	; 31
    3518:	88 30       	cpi	r24, 0x08	; 8
    351a:	d1 f7       	brne	.-12     	; 0x3510 <chb_drvr_init+0x3c>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    351c:	8e e2       	ldi	r24, 0x2E	; 46
    351e:	60 e4       	ldi	r22, 0x40	; 64
    3520:	40 ec       	ldi	r20, 0xC0	; 192
    3522:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    3526:	8e e0       	ldi	r24, 0x0E	; 14
    3528:	6c e0       	ldi	r22, 0x0C	; 12
    352a:	0e 94 85 18 	call	0x310a	; 0x310a <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    352e:	84 e0       	ldi	r24, 0x04	; 4
    3530:	60 e2       	ldi	r22, 0x20	; 32
    3532:	40 e2       	ldi	r20, 0x20	; 32
    3534:	0e 94 20 19 	call	0x3240	; 0x3240 <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    3538:	81 e0       	ldi	r24, 0x01	; 1
    353a:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    353e:	81 e0       	ldi	r24, 0x01	; 1
    3540:	0e 94 18 1a 	call	0x3430	; 0x3430 <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    3544:	86 e1       	ldi	r24, 0x16	; 22
    3546:	0e 94 34 19 	call	0x3268	; 0x3268 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    354a:	82 e2       	ldi	r24, 0x22	; 34
    354c:	64 e3       	ldi	r22, 0x34	; 52
    354e:	72 e1       	ldi	r23, 0x12	; 18
    3550:	0e 94 cc 18 	call	0x3198	; 0x3198 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    3554:	0e 94 18 18 	call	0x3030	; 0x3030 <chb_get_short_addr>
    3558:	bc 01       	movw	r22, r24
    355a:	80 e2       	ldi	r24, 0x20	; 32
    355c:	0e 94 cc 18 	call	0x3198	; 0x3198 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    3560:	ce 01       	movw	r24, r28
    3562:	01 96       	adiw	r24, 0x01	; 1
    3564:	0e 94 10 18 	call	0x3020	; 0x3020 <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    3568:	84 e2       	ldi	r24, 0x24	; 36
    356a:	be 01       	movw	r22, r28
    356c:	6f 5f       	subi	r22, 0xFF	; 255
    356e:	7f 4f       	sbci	r23, 0xFF	; 255
    3570:	0e 94 a6 18 	call	0x314c	; 0x314c <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    3574:	e2 e7       	ldi	r30, 0x72	; 114
    3576:	f6 e0       	ldi	r31, 0x06	; 6
    3578:	80 81       	ld	r24, Z
    357a:	81 60       	ori	r24, 0x01	; 1
    357c:	80 83       	st	Z, r24
    357e:	e9 e6       	ldi	r30, 0x69	; 105
    3580:	f6 e0       	ldi	r31, 0x06	; 6
    3582:	80 81       	ld	r24, Z
    3584:	83 60       	ori	r24, 0x03	; 3
    3586:	80 83       	st	Z, r24
    3588:	ea e6       	ldi	r30, 0x6A	; 106
    358a:	f6 e0       	ldi	r31, 0x06	; 6
    358c:	80 81       	ld	r24, Z
    358e:	84 60       	ori	r24, 0x04	; 4
    3590:	80 83       	st	Z, r24
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    3592:	e0 ea       	ldi	r30, 0xA0	; 160
    3594:	f0 e0       	ldi	r31, 0x00	; 0
    3596:	82 81       	ldd	r24, Z+2	; 0x02
    3598:	87 60       	ori	r24, 0x07	; 7
    359a:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
    359c:	0e 94 1b 19 	call	0x3236	; 0x3236 <chb_get_state>
    35a0:	86 31       	cpi	r24, 0x16	; 22
    35a2:	91 f0       	breq	.+36     	; 0x35c8 <chb_drvr_init+0xf4>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    35a4:	8e 01       	movw	r16, r28
    35a6:	07 5f       	subi	r16, 0xF7	; 247
    35a8:	1f 4f       	sbci	r17, 0xFF	; 255
    35aa:	c8 01       	movw	r24, r16
    35ac:	68 ee       	ldi	r22, 0xE8	; 232
    35ae:	71 e0       	ldi	r23, 0x01	; 1
    35b0:	0e 94 93 36 	call	0x6d26	; 0x6d26 <strcpy_P>
        printf(buf);
    35b4:	0f 92       	push	r0
    35b6:	0f 92       	push	r0
    35b8:	ed b7       	in	r30, 0x3d	; 61
    35ba:	fe b7       	in	r31, 0x3e	; 62
    35bc:	01 83       	std	Z+1, r16	; 0x01
    35be:	12 83       	std	Z+2, r17	; 0x02
    35c0:	0e 94 d8 36 	call	0x6db0	; 0x6db0 <printf>
    35c4:	0f 90       	pop	r0
    35c6:	0f 90       	pop	r0
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
    35c8:	ea 96       	adiw	r28, 0x3a	; 58
    35ca:	cd bf       	out	0x3d, r28	; 61
    35cc:	de bf       	out	0x3e, r29	; 62
    35ce:	df 91       	pop	r29
    35d0:	cf 91       	pop	r28
    35d2:	1f 91       	pop	r17
    35d4:	0f 91       	pop	r16
    35d6:	08 95       	ret

000035d8 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    35d8:	1f 92       	push	r1
    35da:	0f 92       	push	r0
    35dc:	0f b6       	in	r0, 0x3f	; 63
    35de:	0f 92       	push	r0
    35e0:	0b b6       	in	r0, 0x3b	; 59
    35e2:	0f 92       	push	r0
    35e4:	11 24       	eor	r1, r1
    35e6:	6f 92       	push	r6
    35e8:	7f 92       	push	r7
    35ea:	8f 92       	push	r8
    35ec:	9f 92       	push	r9
    35ee:	af 92       	push	r10
    35f0:	bf 92       	push	r11
    35f2:	df 92       	push	r13
    35f4:	ef 92       	push	r14
    35f6:	ff 92       	push	r15
    35f8:	0f 93       	push	r16
    35fa:	1f 93       	push	r17
    35fc:	2f 93       	push	r18
    35fe:	3f 93       	push	r19
    3600:	4f 93       	push	r20
    3602:	5f 93       	push	r21
    3604:	6f 93       	push	r22
    3606:	7f 93       	push	r23
    3608:	8f 93       	push	r24
    360a:	9f 93       	push	r25
    360c:	af 93       	push	r26
    360e:	bf 93       	push	r27
    3610:	ef 93       	push	r30
    3612:	ff 93       	push	r31
    3614:	cf 93       	push	r28
    3616:	df 93       	push	r29
    3618:	cd b7       	in	r28, 0x3d	; 61
    361a:	de b7       	in	r29, 0x3e	; 62
    361c:	e2 97       	sbiw	r28, 0x32	; 50
    361e:	cd bf       	out	0x3d, r28	; 61
    3620:	de bf       	out	0x3e, r29	; 62
    U8 state, intp_src = 0;
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    3622:	0e 94 d8 16 	call	0x2db0	; 0x2db0 <chb_get_pcb>
    3626:	7c 01       	movw	r14, r24

    CHB_ENTER_CRIT();
    3628:	8f b7       	in	r24, 0x3f	; 63
    362a:	80 93 55 40 	sts	0x4055, r24
    362e:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    3630:	81 e0       	ldi	r24, 0x01	; 1
    3632:	0e 94 2e 18 	call	0x305c	; 0x305c <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    3636:	8f e8       	ldi	r24, 0x8F	; 143
    3638:	0e 94 ae 1c 	call	0x395c	; 0x395c <SPID_write>
    intp_src = SPID_write(0);
    363c:	80 e0       	ldi	r24, 0x00	; 0
    363e:	0e 94 ae 1c 	call	0x395c	; 0x395c <SPID_write>
    3642:	18 2f       	mov	r17, r24

    RadioCS(FALSE);
    3644:	80 e0       	ldi	r24, 0x00	; 0
    3646:	0e 94 2e 18 	call	0x305c	; 0x305c <RadioCS>

    while (intp_src)
    364a:	11 23       	and	r17, r17
    364c:	09 f4       	brne	.+2      	; 0x3650 <__vector_64+0x78>
    364e:	ae c0       	rjmp	.+348    	; 0x37ac <__vector_64+0x1d4>

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3650:	aa 24       	eor	r10, r10
    3652:	bb 24       	eor	r11, r11
    3654:	68 94       	set
    3656:	a7 f8       	bld	r10, 7

            // Increment the overflow stat
            pcb->overflow++;

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    3658:	0f 2e       	mov	r0, r31
    365a:	f8 e0       	ldi	r31, 0x08	; 8
    365c:	8f 2e       	mov	r8, r31
    365e:	f2 e0       	ldi	r31, 0x02	; 2
    3660:	9f 2e       	mov	r9, r31
    3662:	f0 2d       	mov	r31, r0
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    3664:	12 ff       	sbrs	r17, 2
    3666:	02 c0       	rjmp	.+4      	; 0x366c <__vector_64+0x94>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    3668:	1b 7f       	andi	r17, 0xFB	; 251
    366a:	9d c0       	rjmp	.+314    	; 0x37a6 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    366c:	13 ff       	sbrs	r17, 3
    366e:	82 c0       	rjmp	.+260    	; 0x3774 <__vector_64+0x19c>
        {
            state = chb_get_state();
    3670:	0e 94 1b 19 	call	0x3236	; 0x3236 <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    3674:	86 30       	cpi	r24, 0x06	; 6
    3676:	29 f0       	breq	.+10     	; 0x3682 <__vector_64+0xaa>
    3678:	86 31       	cpi	r24, 0x16	; 22
    367a:	19 f0       	breq	.+6      	; 0x3682 <__vector_64+0xaa>
    367c:	81 31       	cpi	r24, 0x11	; 17
    367e:	09 f0       	breq	.+2      	; 0x3682 <__vector_64+0xaa>
    3680:	6f c0       	rjmp	.+222    	; 0x3760 <__vector_64+0x188>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				//chb_set_state(CHB_TRX_OFF);
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    3682:	87 e0       	ldi	r24, 0x07	; 7
    3684:	0e 94 01 19 	call	0x3202	; 0x3202 <chb_reg_read>
    3688:	f7 01       	movw	r30, r14
    368a:	82 8b       	std	Z+18, r24	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    368c:	86 e0       	ldi	r24, 0x06	; 6
    368e:	0e 94 01 19 	call	0x3202	; 0x3202 <chb_reg_read>
    3692:	88 1f       	adc	r24, r24
    3694:	88 27       	eor	r24, r24
    3696:	88 1f       	adc	r24, r24
    3698:	f7 01       	movw	r30, r14
    369a:	83 8b       	std	Z+19, r24	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    369c:	88 23       	and	r24, r24
    369e:	09 f4       	brne	.+2      	; 0x36a2 <__vector_64+0xca>
    36a0:	62 c0       	rjmp	.+196    	; 0x3766 <__vector_64+0x18e>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
    36a2:	8f b7       	in	r24, 0x3f	; 63
    36a4:	80 93 55 40 	sts	0x4055, r24
    36a8:	f8 94       	cli
    RadioCS(TRUE);
    36aa:	81 e0       	ldi	r24, 0x01	; 1
    36ac:	0e 94 2e 18 	call	0x305c	; 0x305c <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    36b0:	80 e2       	ldi	r24, 0x20	; 32
    36b2:	0e 94 ae 1c 	call	0x395c	; 0x395c <SPID_write>
    len = SPID_write(0);
    36b6:	80 e0       	ldi	r24, 0x00	; 0
    36b8:	0e 94 ae 1c 	call	0x395c	; 0x395c <SPID_write>
    36bc:	d8 2e       	mov	r13, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    36be:	83 50       	subi	r24, 0x03	; 3
    36c0:	8d 37       	cpi	r24, 0x7D	; 125
    36c2:	f0 f5       	brcc	.+124    	; 0x3740 <__vector_64+0x168>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    36c4:	0e 94 0d 18 	call	0x301a	; 0x301a <chb_buf_get_len>
    36c8:	2d 2d       	mov	r18, r13
    36ca:	30 e0       	ldi	r19, 0x00	; 0
    36cc:	a5 01       	movw	r20, r10
    36ce:	48 1b       	sub	r20, r24
    36d0:	51 09       	sbc	r21, r1
    36d2:	24 17       	cp	r18, r20
    36d4:	35 07       	cpc	r19, r21
    36d6:	7c f4       	brge	.+30     	; 0x36f6 <__vector_64+0x11e>
        {
            chb_buf_write(len);
    36d8:	8d 2d       	mov	r24, r13
    36da:	0e 94 e1 17 	call	0x2fc2	; 0x2fc2 <chb_buf_write>
            
            for (i=0; i<len; i++)
    36de:	dd 20       	and	r13, r13
    36e0:	79 f1       	breq	.+94     	; 0x3740 <__vector_64+0x168>
    36e2:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    36e4:	80 e0       	ldi	r24, 0x00	; 0
    36e6:	0e 94 ae 1c 	call	0x395c	; 0x395c <SPID_write>
                chb_buf_write(data);
    36ea:	0e 94 e1 17 	call	0x2fc2	; 0x2fc2 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    36ee:	0f 5f       	subi	r16, 0xFF	; 255
    36f0:	0d 15       	cp	r16, r13
    36f2:	c1 f7       	brne	.-16     	; 0x36e4 <__vector_64+0x10c>
    36f4:	25 c0       	rjmp	.+74     	; 0x3740 <__vector_64+0x168>
			//PORTE.OUTCLR = PIN2_bm;
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    36f6:	0e 94 d8 16 	call	0x2db0	; 0x2db0 <chb_get_pcb>
    36fa:	3c 01       	movw	r6, r24
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    36fc:	dd 20       	and	r13, r13
    36fe:	39 f0       	breq	.+14     	; 0x370e <__vector_64+0x136>
    3700:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    3702:	80 e0       	ldi	r24, 0x00	; 0
    3704:	0e 94 ae 1c 	call	0x395c	; 0x395c <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3708:	0f 5f       	subi	r16, 0xFF	; 255
    370a:	0d 15       	cp	r16, r13
    370c:	d1 f7       	brne	.-12     	; 0x3702 <__vector_64+0x12a>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    370e:	f3 01       	movw	r30, r6
    3710:	85 85       	ldd	r24, Z+13	; 0x0d
    3712:	96 85       	ldd	r25, Z+14	; 0x0e
    3714:	01 96       	adiw	r24, 0x01	; 1
    3716:	85 87       	std	Z+13, r24	; 0x0d
    3718:	96 87       	std	Z+14, r25	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    371a:	ce 01       	movw	r24, r28
    371c:	01 96       	adiw	r24, 0x01	; 1
    371e:	b4 01       	movw	r22, r8
    3720:	0e 94 93 36 	call	0x6d26	; 0x6d26 <strcpy_P>
            printf(buf);
    3724:	0f 92       	push	r0
    3726:	0f 92       	push	r0
    3728:	41 e0       	ldi	r20, 0x01	; 1
    372a:	50 e0       	ldi	r21, 0x00	; 0
    372c:	4c 0f       	add	r20, r28
    372e:	5d 1f       	adc	r21, r29
    3730:	ed b7       	in	r30, 0x3d	; 61
    3732:	fe b7       	in	r31, 0x3e	; 62
    3734:	41 83       	std	Z+1, r20	; 0x01
    3736:	52 83       	std	Z+2, r21	; 0x02
    3738:	0e 94 d8 36 	call	0x6db0	; 0x6db0 <printf>
    373c:	0f 90       	pop	r0
    373e:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    3740:	80 e0       	ldi	r24, 0x00	; 0
    3742:	0e 94 2e 18 	call	0x305c	; 0x305c <RadioCS>
    CHB_LEAVE_CRIT();
    3746:	80 91 55 40 	lds	r24, 0x4055
    374a:	8f bf       	out	0x3f, r24	; 63
    374c:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
    374e:	f7 01       	movw	r30, r14
    3750:	85 81       	ldd	r24, Z+5	; 0x05
    3752:	96 81       	ldd	r25, Z+6	; 0x06
    3754:	01 96       	adiw	r24, 0x01	; 1
    3756:	85 83       	std	Z+5, r24	; 0x05
    3758:	96 83       	std	Z+6, r25	; 0x06
                    pcb->data_rcv = true;
    375a:	81 e0       	ldi	r24, 0x01	; 1
    375c:	83 83       	std	Z+3, r24	; 0x03
    375e:	03 c0       	rjmp	.+6      	; 0x3766 <__vector_64+0x18e>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    3760:	81 e0       	ldi	r24, 0x01	; 1
    3762:	f7 01       	movw	r30, r14
    3764:	84 83       	std	Z+4, r24	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    3766:	17 7f       	andi	r17, 0xF7	; 247
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    3768:	86 e1       	ldi	r24, 0x16	; 22
    376a:	0e 94 34 19 	call	0x3268	; 0x3268 <chb_set_state>
    376e:	80 34       	cpi	r24, 0x40	; 64
    3770:	d9 f7       	brne	.-10     	; 0x3768 <__vector_64+0x190>
    3772:	19 c0       	rjmp	.+50     	; 0x37a6 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    3774:	16 ff       	sbrs	r17, 6
    3776:	08 c0       	rjmp	.+16     	; 0x3788 <__vector_64+0x1b0>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    3778:	1f 7b       	andi	r17, 0xBF	; 191
            pcb->underrun++;
    377a:	f7 01       	movw	r30, r14
    377c:	87 85       	ldd	r24, Z+15	; 0x0f
    377e:	90 89       	ldd	r25, Z+16	; 0x10
    3780:	01 96       	adiw	r24, 0x01	; 1
    3782:	87 87       	std	Z+15, r24	; 0x0f
    3784:	90 8b       	std	Z+16, r25	; 0x10
    3786:	0f c0       	rjmp	.+30     	; 0x37a6 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    3788:	11 ff       	sbrs	r17, 1
    378a:	02 c0       	rjmp	.+4      	; 0x3790 <__vector_64+0x1b8>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    378c:	1d 7f       	andi	r17, 0xFD	; 253
    378e:	0b c0       	rjmp	.+22     	; 0x37a6 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    3790:	10 ff       	sbrs	r17, 0
    3792:	02 c0       	rjmp	.+4      	; 0x3798 <__vector_64+0x1c0>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    3794:	1e 7f       	andi	r17, 0xFE	; 254
    3796:	07 c0       	rjmp	.+14     	; 0x37a6 <__vector_64+0x1ce>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    3798:	11 23       	and	r17, r17
    379a:	2c f4       	brge	.+10     	; 0x37a6 <__vector_64+0x1ce>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    379c:	1f 77       	andi	r17, 0x7F	; 127
            pcb->battlow++;
    379e:	f7 01       	movw	r30, r14
    37a0:	81 89       	ldd	r24, Z+17	; 0x11
    37a2:	8f 5f       	subi	r24, 0xFF	; 255
    37a4:	81 8b       	std	Z+17, r24	; 0x11
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    37a6:	11 23       	and	r17, r17
    37a8:	09 f0       	breq	.+2      	; 0x37ac <__vector_64+0x1d4>
    37aa:	5c cf       	rjmp	.-328    	; 0x3664 <__vector_64+0x8c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    37ac:	80 91 55 40 	lds	r24, 0x4055
    37b0:	8f bf       	out	0x3f, r24	; 63
    37b2:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    37b4:	8f e0       	ldi	r24, 0x0F	; 15
    37b6:	0e 94 01 19 	call	0x3202	; 0x3202 <chb_reg_read>
}
    37ba:	e2 96       	adiw	r28, 0x32	; 50
    37bc:	cd bf       	out	0x3d, r28	; 61
    37be:	de bf       	out	0x3e, r29	; 62
    37c0:	df 91       	pop	r29
    37c2:	cf 91       	pop	r28
    37c4:	ff 91       	pop	r31
    37c6:	ef 91       	pop	r30
    37c8:	bf 91       	pop	r27
    37ca:	af 91       	pop	r26
    37cc:	9f 91       	pop	r25
    37ce:	8f 91       	pop	r24
    37d0:	7f 91       	pop	r23
    37d2:	6f 91       	pop	r22
    37d4:	5f 91       	pop	r21
    37d6:	4f 91       	pop	r20
    37d8:	3f 91       	pop	r19
    37da:	2f 91       	pop	r18
    37dc:	1f 91       	pop	r17
    37de:	0f 91       	pop	r16
    37e0:	ff 90       	pop	r15
    37e2:	ef 90       	pop	r14
    37e4:	df 90       	pop	r13
    37e6:	bf 90       	pop	r11
    37e8:	af 90       	pop	r10
    37ea:	9f 90       	pop	r9
    37ec:	8f 90       	pop	r8
    37ee:	7f 90       	pop	r7
    37f0:	6f 90       	pop	r6
    37f2:	0f 90       	pop	r0
    37f4:	0b be       	out	0x3b, r0	; 59
    37f6:	0f 90       	pop	r0
    37f8:	0f be       	out	0x3f, r0	; 63
    37fa:	0f 90       	pop	r0
    37fc:	1f 90       	pop	r1
    37fe:	18 95       	reti

00003800 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    3800:	0f 93       	push	r16
    3802:	1f 93       	push	r17
    3804:	cf 93       	push	r28
    3806:	df 93       	push	r29
    3808:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    380a:	e0 ec       	ldi	r30, 0xC0	; 192
    380c:	f1 e0       	ldi	r31, 0x01	; 1
    380e:	84 85       	ldd	r24, Z+12	; 0x0c
    3810:	87 7f       	andi	r24, 0xF7	; 247
    3812:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    3814:	41 15       	cp	r20, r1
    3816:	51 05       	cpc	r21, r1
    3818:	09 f4       	brne	.+2      	; 0x381c <chb_eeprom_write+0x1c>
    381a:	50 c0       	rjmp	.+160    	; 0x38bc <chb_eeprom_write+0xbc>
    381c:	e0 e0       	ldi	r30, 0x00	; 0
    381e:	f0 e0       	ldi	r31, 0x00	; 0
    3820:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3822:	a0 ec       	ldi	r26, 0xC0	; 192
    3824:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3826:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3828:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    382a:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
    382c:	cf 01       	movw	r24, r30
    382e:	80 0f       	add	r24, r16
    3830:	91 1f       	adc	r25, r17
    3832:	e6 0f       	add	r30, r22
    3834:	f7 1f       	adc	r31, r23
    3836:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3838:	1f 96       	adiw	r26, 0x0f	; 15
    383a:	ec 91       	ld	r30, X
    383c:	1f 97       	sbiw	r26, 0x0f	; 15
    383e:	ee 23       	and	r30, r30
    3840:	dc f3       	brlt	.-10     	; 0x3838 <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    3842:	1f 96       	adiw	r26, 0x0f	; 15
    3844:	ec 91       	ld	r30, X
    3846:	1f 97       	sbiw	r26, 0x0f	; 15
    3848:	e1 ff       	sbrs	r30, 1
    384a:	11 c0       	rjmp	.+34     	; 0x386e <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    384c:	1a 96       	adiw	r26, 0x0a	; 10
    384e:	dc 93       	st	X, r29
    3850:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
    3852:	ef 93       	push	r30
    3854:	ff 93       	push	r31
    3856:	0f 93       	push	r16
    3858:	2f 93       	push	r18
    385a:	eb ec       	ldi	r30, 0xCB	; 203
    385c:	f1 e0       	ldi	r31, 0x01	; 1
    385e:	08 ed       	ldi	r16, 0xD8	; 216
    3860:	21 e0       	ldi	r18, 0x01	; 1
    3862:	04 bf       	out	0x34, r16	; 52
    3864:	20 83       	st	Z, r18
    3866:	2f 91       	pop	r18
    3868:	0f 91       	pop	r16
    386a:	ff 91       	pop	r31
    386c:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    386e:	1a 96       	adiw	r26, 0x0a	; 10
    3870:	cc 93       	st	X, r28
    3872:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    3874:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3876:	89 2f       	mov	r24, r25
    3878:	8f 71       	andi	r24, 0x1F	; 31
    387a:	11 96       	adiw	r26, 0x01	; 1
    387c:	8c 93       	st	X, r24
    387e:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
    3880:	12 96       	adiw	r26, 0x02	; 2
    3882:	1c 92       	st	X, r1
    3884:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
    3886:	14 96       	adiw	r26, 0x04	; 4
    3888:	fc 93       	st	X, r31
    388a:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    388c:	1a 96       	adiw	r26, 0x0a	; 10
    388e:	3c 93       	st	X, r19
    3890:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
    3892:	ef 93       	push	r30
    3894:	ff 93       	push	r31
    3896:	0f 93       	push	r16
    3898:	2f 93       	push	r18
    389a:	eb ec       	ldi	r30, 0xCB	; 203
    389c:	f1 e0       	ldi	r31, 0x01	; 1
    389e:	08 ed       	ldi	r16, 0xD8	; 216
    38a0:	21 e0       	ldi	r18, 0x01	; 1
    38a2:	04 bf       	out	0x34, r16	; 52
    38a4:	20 83       	st	Z, r18
    38a6:	2f 91       	pop	r18
    38a8:	0f 91       	pop	r16
    38aa:	ff 91       	pop	r31
    38ac:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    38ae:	2f 5f       	subi	r18, 0xFF	; 255
    38b0:	e2 2f       	mov	r30, r18
    38b2:	f0 e0       	ldi	r31, 0x00	; 0
    38b4:	e4 17       	cp	r30, r20
    38b6:	f5 07       	cpc	r31, r21
    38b8:	08 f4       	brcc	.+2      	; 0x38bc <chb_eeprom_write+0xbc>
    38ba:	b8 cf       	rjmp	.-144    	; 0x382c <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    38bc:	df 91       	pop	r29
    38be:	cf 91       	pop	r28
    38c0:	1f 91       	pop	r17
    38c2:	0f 91       	pop	r16
    38c4:	08 95       	ret

000038c6 <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    38c6:	1f 93       	push	r17
    38c8:	cf 93       	push	r28
    38ca:	df 93       	push	r29
    38cc:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    38ce:	e0 ec       	ldi	r30, 0xC0	; 192
    38d0:	f1 e0       	ldi	r31, 0x01	; 1
    38d2:	84 85       	ldd	r24, Z+12	; 0x0c
    38d4:	87 7f       	andi	r24, 0xF7	; 247
    38d6:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    38d8:	41 15       	cp	r20, r1
    38da:	51 05       	cpc	r21, r1
    38dc:	41 f1       	breq	.+80     	; 0x392e <chb_eeprom_read+0x68>
    38de:	80 e0       	ldi	r24, 0x00	; 0
    38e0:	90 e0       	ldi	r25, 0x00	; 0
    38e2:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    38e4:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    38e6:	db 01       	movw	r26, r22
    38e8:	a8 0f       	add	r26, r24
    38ea:	b9 1f       	adc	r27, r25
    38ec:	82 0f       	add	r24, r18
    38ee:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    38f0:	17 85       	ldd	r17, Z+15	; 0x0f
    38f2:	11 23       	and	r17, r17
    38f4:	ec f3       	brlt	.-6      	; 0x38f0 <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    38f6:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    38f8:	89 2f       	mov	r24, r25
    38fa:	8f 71       	andi	r24, 0x1F	; 31
    38fc:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
    38fe:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3900:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
    3902:	ef 93       	push	r30
    3904:	ff 93       	push	r31
    3906:	0f 93       	push	r16
    3908:	2f 93       	push	r18
    390a:	eb ec       	ldi	r30, 0xCB	; 203
    390c:	f1 e0       	ldi	r31, 0x01	; 1
    390e:	08 ed       	ldi	r16, 0xD8	; 216
    3910:	21 e0       	ldi	r18, 0x01	; 1
    3912:	04 bf       	out	0x34, r16	; 52
    3914:	20 83       	st	Z, r18
    3916:	2f 91       	pop	r18
    3918:	0f 91       	pop	r16
    391a:	ff 91       	pop	r31
    391c:	ef 91       	pop	r30

    return NVM.DATA0;
    391e:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3920:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3922:	cf 5f       	subi	r28, 0xFF	; 255
    3924:	8c 2f       	mov	r24, r28
    3926:	90 e0       	ldi	r25, 0x00	; 0
    3928:	84 17       	cp	r24, r20
    392a:	95 07       	cpc	r25, r21
    392c:	e0 f2       	brcs	.-72     	; 0x38e6 <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    392e:	df 91       	pop	r29
    3930:	cf 91       	pop	r28
    3932:	1f 91       	pop	r17
    3934:	08 95       	ret

00003936 <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    3936:	e0 e6       	ldi	r30, 0x60	; 96
    3938:	f6 e0       	ldi	r31, 0x06	; 6
    393a:	80 81       	ld	r24, Z
    393c:	80 6b       	ori	r24, 0xB0	; 176
    393e:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    3940:	e4 e6       	ldi	r30, 0x64	; 100
    3942:	f6 e0       	ldi	r31, 0x06	; 6
    3944:	80 81       	ld	r24, Z
    3946:	80 61       	ori	r24, 0x10	; 16
    3948:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    394a:	a0 ec       	ldi	r26, 0xC0	; 192
    394c:	b9 e0       	ldi	r27, 0x09	; 9
    394e:	8c 91       	ld	r24, X
    3950:	81 65       	ori	r24, 0x51	; 81
    3952:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    3954:	80 81       	ld	r24, Z
    3956:	80 61       	ori	r24, 0x10	; 16
    3958:	80 83       	st	Z, r24
}
    395a:	08 95       	ret

0000395c <SPID_write>:
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    395c:	e0 ec       	ldi	r30, 0xC0	; 192
    395e:	f9 e0       	ldi	r31, 0x09	; 9
    3960:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    3962:	82 81       	ldd	r24, Z+2	; 0x02
    3964:	88 23       	and	r24, r24
    3966:	ec f7       	brge	.-6      	; 0x3962 <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    3968:	e0 ec       	ldi	r30, 0xC0	; 192
    396a:	f9 e0       	ldi	r31, 0x09	; 9
    396c:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    396e:	08 95       	ret

00003970 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3970:	0f 93       	push	r16
    3972:	cf 93       	push	r28
    3974:	df 93       	push	r29
    3976:	0f 92       	push	r0
    3978:	cd b7       	in	r28, 0x3d	; 61
    397a:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    397c:	2f b7       	in	r18, 0x3f	; 63
    397e:	29 83       	std	Y+1, r18	; 0x01
    3980:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    3982:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    3984:	fc 01       	movw	r30, r24
    3986:	08 ed       	ldi	r16, 0xD8	; 216
    3988:	04 bf       	out	0x34, r16	; 52
    398a:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    398c:	89 81       	ldd	r24, Y+1	; 0x01
    398e:	8f bf       	out	0x3f, r24	; 63
#endif
}
    3990:	0f 90       	pop	r0
    3992:	df 91       	pop	r29
    3994:	cf 91       	pop	r28
    3996:	0f 91       	pop	r16
    3998:	08 95       	ret

0000399a <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    399a:	66 23       	and	r22, r22
    399c:	11 f0       	breq	.+4      	; 0x39a2 <CLKSYS_XOSC_Config+0x8>
    399e:	90 e2       	ldi	r25, 0x20	; 32
    39a0:	01 c0       	rjmp	.+2      	; 0x39a4 <CLKSYS_XOSC_Config+0xa>
    39a2:	90 e0       	ldi	r25, 0x00	; 0
    39a4:	84 2b       	or	r24, r20
    39a6:	89 2b       	or	r24, r25
    39a8:	e0 e5       	ldi	r30, 0x50	; 80
    39aa:	f0 e0       	ldi	r31, 0x00	; 0
    39ac:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    39ae:	08 95       	ret

000039b0 <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    39b0:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    39b2:	86 2b       	or	r24, r22
    39b4:	e0 e5       	ldi	r30, 0x50	; 80
    39b6:	f0 e0       	ldi	r31, 0x00	; 0
    39b8:	85 83       	std	Z+5, r24	; 0x05
}
    39ba:	08 95       	ret

000039bc <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    39bc:	e0 e5       	ldi	r30, 0x50	; 80
    39be:	f0 e0       	ldi	r31, 0x00	; 0
    39c0:	90 81       	ld	r25, Z
    39c2:	28 2f       	mov	r18, r24
    39c4:	20 95       	com	r18
    39c6:	92 23       	and	r25, r18
    39c8:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    39ca:	90 81       	ld	r25, Z
	return clkEnabled;
}
    39cc:	89 23       	and	r24, r25
    39ce:	08 95       	ret

000039d0 <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    39d0:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    39d2:	81 e4       	ldi	r24, 0x41	; 65
    39d4:	90 e0       	ldi	r25, 0x00	; 0
    39d6:	0e 94 b8 1c 	call	0x3970	; 0x3970 <CCPWrite>
}
    39da:	08 95       	ret

000039dc <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    39dc:	1f 93       	push	r17
    39de:	cf 93       	push	r28
    39e0:	df 93       	push	r29
    39e2:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    39e4:	c0 e4       	ldi	r28, 0x40	; 64
    39e6:	d0 e0       	ldi	r29, 0x00	; 0
    39e8:	68 81       	ld	r22, Y
    39ea:	68 7f       	andi	r22, 0xF8	; 248
    39ec:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    39ee:	80 e4       	ldi	r24, 0x40	; 64
    39f0:	90 e0       	ldi	r25, 0x00	; 0
    39f2:	0e 94 b8 1c 	call	0x3970	; 0x3970 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    39f6:	88 81       	ld	r24, Y
	return clkCtrl;
}
    39f8:	81 23       	and	r24, r17
    39fa:	df 91       	pop	r29
    39fc:	cf 91       	pop	r28
    39fe:	1f 91       	pop	r17
    3a00:	08 95       	ret

00003a02 <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    3a02:	e0 e4       	ldi	r30, 0x40	; 64
    3a04:	f0 e0       	ldi	r31, 0x00	; 0
    3a06:	93 81       	ldd	r25, Z+3	; 0x03
    3a08:	91 7f       	andi	r25, 0xF1	; 241
    3a0a:	91 60       	ori	r25, 0x01	; 1
    3a0c:	89 2b       	or	r24, r25
    3a0e:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    3a10:	08 95       	ret

00003a12 <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    3a12:	e0 e5       	ldi	r30, 0x50	; 80
    3a14:	f0 e0       	ldi	r31, 0x00	; 0
    3a16:	26 81       	ldd	r18, Z+6	; 0x06
    3a18:	98 2f       	mov	r25, r24
    3a1a:	38 2f       	mov	r19, r24
    3a1c:	30 95       	com	r19
    3a1e:	23 23       	and	r18, r19
    3a20:	66 23       	and	r22, r22
    3a22:	09 f4       	brne	.+2      	; 0x3a26 <CLKSYS_AutoCalibration_Enable+0x14>
    3a24:	90 e0       	ldi	r25, 0x00	; 0
    3a26:	92 2b       	or	r25, r18
    3a28:	e0 e5       	ldi	r30, 0x50	; 80
    3a2a:	f0 e0       	ldi	r31, 0x00	; 0
    3a2c:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    3a2e:	81 30       	cpi	r24, 0x01	; 1
    3a30:	31 f4       	brne	.+12     	; 0x3a3e <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    3a32:	e8 e6       	ldi	r30, 0x68	; 104
    3a34:	f0 e0       	ldi	r31, 0x00	; 0
    3a36:	80 81       	ld	r24, Z
    3a38:	81 60       	ori	r24, 0x01	; 1
    3a3a:	80 83       	st	Z, r24
    3a3c:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    3a3e:	82 30       	cpi	r24, 0x02	; 2
    3a40:	29 f4       	brne	.+10     	; 0x3a4c <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    3a42:	e0 e6       	ldi	r30, 0x60	; 96
    3a44:	f0 e0       	ldi	r31, 0x00	; 0
    3a46:	80 81       	ld	r24, Z
    3a48:	81 60       	ori	r24, 0x01	; 1
    3a4a:	80 83       	st	Z, r24
    3a4c:	08 95       	ret

00003a4e <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    3a4e:	83 e5       	ldi	r24, 0x53	; 83
    3a50:	90 e0       	ldi	r25, 0x00	; 0
    3a52:	63 e0       	ldi	r22, 0x03	; 3
    3a54:	0e 94 b8 1c 	call	0x3970	; 0x3970 <CCPWrite>
}
    3a58:	08 95       	ret

00003a5a <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    3a5a:	82 e4       	ldi	r24, 0x42	; 66
    3a5c:	90 e0       	ldi	r25, 0x00	; 0
    3a5e:	61 e0       	ldi	r22, 0x01	; 1
    3a60:	0e 94 b8 1c 	call	0x3970	; 0x3970 <CCPWrite>
}
    3a64:	08 95       	ret

00003a66 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    3a66:	cf 92       	push	r12
    3a68:	df 92       	push	r13
    3a6a:	ef 92       	push	r14
    3a6c:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    3a6e:	20 91 67 50 	lds	r18, 0x5067
    3a72:	30 91 68 50 	lds	r19, 0x5068
    3a76:	c0 90 4b 40 	lds	r12, 0x404B
    3a7a:	d0 90 4c 40 	lds	r13, 0x404C
    3a7e:	e0 90 4d 40 	lds	r14, 0x404D
    3a82:	f0 90 4e 40 	lds	r15, 0x404E
    3a86:	62 50       	subi	r22, 0x02	; 2
    3a88:	70 40       	sbci	r23, 0x00	; 0
    3a8a:	80 40       	sbci	r24, 0x00	; 0
    3a8c:	90 40       	sbci	r25, 0x00	; 0
    3a8e:	40 e0       	ldi	r20, 0x00	; 0
    3a90:	50 e0       	ldi	r21, 0x00	; 0
    3a92:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    3a96:	dc 01       	movw	r26, r24
    3a98:	cb 01       	movw	r24, r22
    3a9a:	c8 0e       	add	r12, r24
    3a9c:	d9 1e       	adc	r13, r25
    3a9e:	ea 1e       	adc	r14, r26
    3aa0:	fb 1e       	adc	r15, r27
}
    3aa2:	6c 2d       	mov	r22, r12
    3aa4:	7d 2d       	mov	r23, r13
    3aa6:	8e 2d       	mov	r24, r14
    3aa8:	9f 2d       	mov	r25, r15
    3aaa:	ff 90       	pop	r15
    3aac:	ef 90       	pop	r14
    3aae:	df 90       	pop	r13
    3ab0:	cf 90       	pop	r12
    3ab2:	08 95       	ret

00003ab4 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    3ab4:	3f 92       	push	r3
    3ab6:	4f 92       	push	r4
    3ab8:	5f 92       	push	r5
    3aba:	6f 92       	push	r6
    3abc:	7f 92       	push	r7
    3abe:	8f 92       	push	r8
    3ac0:	9f 92       	push	r9
    3ac2:	af 92       	push	r10
    3ac4:	bf 92       	push	r11
    3ac6:	cf 92       	push	r12
    3ac8:	df 92       	push	r13
    3aca:	ef 92       	push	r14
    3acc:	ff 92       	push	r15
    3ace:	0f 93       	push	r16
    3ad0:	1f 93       	push	r17
    3ad2:	cf 93       	push	r28
    3ad4:	df 93       	push	r29
    3ad6:	00 d0       	rcall	.+0      	; 0x3ad8 <getSetNextCluster+0x24>
    3ad8:	0f 92       	push	r0
    3ada:	cd b7       	in	r28, 0x3d	; 61
    3adc:	de b7       	in	r29, 0x3e	; 62
    3ade:	dc 01       	movw	r26, r24
    3ae0:	cb 01       	movw	r24, r22
    3ae2:	34 2e       	mov	r3, r20
    3ae4:	09 83       	std	Y+1, r16	; 0x01
    3ae6:	1a 83       	std	Y+2, r17	; 0x02
    3ae8:	2b 83       	std	Y+3, r18	; 0x03
    3aea:	3c 83       	std	Y+4, r19	; 0x04
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    3aec:	80 90 6d 50 	lds	r8, 0x506D
    3af0:	90 90 6e 50 	lds	r9, 0x506E
    3af4:	2c 01       	movw	r4, r24
    3af6:	3d 01       	movw	r6, r26
    3af8:	44 0c       	add	r4, r4
    3afa:	55 1c       	adc	r5, r5
    3afc:	66 1c       	adc	r6, r6
    3afe:	77 1c       	adc	r7, r7
    3b00:	44 0c       	add	r4, r4
    3b02:	55 1c       	adc	r5, r5
    3b04:	66 1c       	adc	r6, r6
    3b06:	77 1c       	adc	r7, r7
    3b08:	20 91 53 40 	lds	r18, 0x4053
    3b0c:	30 91 54 40 	lds	r19, 0x4054
    3b10:	aa 24       	eor	r10, r10
    3b12:	bb 24       	eor	r11, r11
    3b14:	80 91 69 50 	lds	r24, 0x5069
    3b18:	90 91 6a 50 	lds	r25, 0x506A
    3b1c:	a0 91 6b 50 	lds	r26, 0x506B
    3b20:	b0 91 6c 50 	lds	r27, 0x506C
    3b24:	88 0e       	add	r8, r24
    3b26:	99 1e       	adc	r9, r25
    3b28:	aa 1e       	adc	r10, r26
    3b2a:	bb 1e       	adc	r11, r27
    3b2c:	40 e0       	ldi	r20, 0x00	; 0
    3b2e:	50 e0       	ldi	r21, 0x00	; 0
    3b30:	c3 01       	movw	r24, r6
    3b32:	b2 01       	movw	r22, r4
    3b34:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    3b38:	69 01       	movw	r12, r18
    3b3a:	7a 01       	movw	r14, r20
    3b3c:	c8 0c       	add	r12, r8
    3b3e:	d9 1c       	adc	r13, r9
    3b40:	ea 1c       	adc	r14, r10
    3b42:	fb 1c       	adc	r15, r11

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    3b44:	00 91 53 40 	lds	r16, 0x4053
    3b48:	10 91 54 40 	lds	r17, 0x4054

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    3b4c:	c7 01       	movw	r24, r14
    3b4e:	b6 01       	movw	r22, r12
    3b50:	47 e4       	ldi	r20, 0x47	; 71
    3b52:	5e e3       	ldi	r21, 0x3E	; 62
    3b54:	0e 94 39 28 	call	0x5072	; 0x5072 <SD_read_block>

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    3b58:	98 01       	movw	r18, r16
    3b5a:	40 e0       	ldi	r20, 0x00	; 0
    3b5c:	50 e0       	ldi	r21, 0x00	; 0
    3b5e:	c3 01       	movw	r24, r6
    3b60:	b2 01       	movw	r22, r4
    3b62:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    3b66:	69 5b       	subi	r22, 0xB9	; 185
    3b68:	71 4c       	sbci	r23, 0xC1	; 193

if(get_set == GET)
    3b6a:	33 20       	and	r3, r3
    3b6c:	41 f4       	brne	.+16     	; 0x3b7e <getSetNextCluster+0xca>
  return ((*FATEntryValue) & 0x0fffffff);
    3b6e:	db 01       	movw	r26, r22
    3b70:	0d 91       	ld	r16, X+
    3b72:	1d 91       	ld	r17, X+
    3b74:	2d 91       	ld	r18, X+
    3b76:	3c 91       	ld	r19, X
    3b78:	13 97       	sbiw	r26, 0x03	; 3
    3b7a:	3f 70       	andi	r19, 0x0F	; 15
    3b7c:	14 c0       	rjmp	.+40     	; 0x3ba6 <getSetNextCluster+0xf2>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    3b7e:	89 81       	ldd	r24, Y+1	; 0x01
    3b80:	9a 81       	ldd	r25, Y+2	; 0x02
    3b82:	ab 81       	ldd	r26, Y+3	; 0x03
    3b84:	bc 81       	ldd	r27, Y+4	; 0x04
    3b86:	fb 01       	movw	r30, r22
    3b88:	80 83       	st	Z, r24
    3b8a:	91 83       	std	Z+1, r25	; 0x01
    3b8c:	a2 83       	std	Z+2, r26	; 0x02
    3b8e:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    3b90:	c7 01       	movw	r24, r14
    3b92:	b6 01       	movw	r22, r12
    3b94:	47 e4       	ldi	r20, 0x47	; 71
    3b96:	5e e3       	ldi	r21, 0x3E	; 62
    3b98:	20 e0       	ldi	r18, 0x00	; 0
    3b9a:	32 e0       	ldi	r19, 0x02	; 2
    3b9c:	0e 94 84 27 	call	0x4f08	; 0x4f08 <SD_write_block>

return (0);
    3ba0:	00 e0       	ldi	r16, 0x00	; 0
    3ba2:	10 e0       	ldi	r17, 0x00	; 0
    3ba4:	98 01       	movw	r18, r16
}
    3ba6:	60 2f       	mov	r22, r16
    3ba8:	71 2f       	mov	r23, r17
    3baa:	82 2f       	mov	r24, r18
    3bac:	93 2f       	mov	r25, r19
    3bae:	24 96       	adiw	r28, 0x04	; 4
    3bb0:	cd bf       	out	0x3d, r28	; 61
    3bb2:	de bf       	out	0x3e, r29	; 62
    3bb4:	df 91       	pop	r29
    3bb6:	cf 91       	pop	r28
    3bb8:	1f 91       	pop	r17
    3bba:	0f 91       	pop	r16
    3bbc:	ff 90       	pop	r15
    3bbe:	ef 90       	pop	r14
    3bc0:	df 90       	pop	r13
    3bc2:	cf 90       	pop	r12
    3bc4:	bf 90       	pop	r11
    3bc6:	af 90       	pop	r10
    3bc8:	9f 90       	pop	r9
    3bca:	8f 90       	pop	r8
    3bcc:	7f 90       	pop	r7
    3bce:	6f 90       	pop	r6
    3bd0:	5f 90       	pop	r5
    3bd2:	4f 90       	pop	r4
    3bd4:	3f 90       	pop	r3
    3bd6:	08 95       	ret

00003bd8 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    3bd8:	cf 92       	push	r12
    3bda:	df 92       	push	r13
    3bdc:	ef 92       	push	r14
    3bde:	ff 92       	push	r15
    3be0:	0f 93       	push	r16
    3be2:	1f 93       	push	r17
    3be4:	cf 93       	push	r28
    3be6:	c8 2f       	mov	r28, r24
    3be8:	06 2f       	mov	r16, r22
    3bea:	69 01       	movw	r12, r18
    3bec:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    3bee:	80 91 69 50 	lds	r24, 0x5069
    3bf2:	90 91 6a 50 	lds	r25, 0x506A
    3bf6:	a0 91 6b 50 	lds	r26, 0x506B
    3bfa:	b0 91 6c 50 	lds	r27, 0x506C
    3bfe:	bc 01       	movw	r22, r24
    3c00:	cd 01       	movw	r24, r26
    3c02:	6f 5f       	subi	r22, 0xFF	; 255
    3c04:	7f 4f       	sbci	r23, 0xFF	; 255
    3c06:	8f 4f       	sbci	r24, 0xFF	; 255
    3c08:	9f 4f       	sbci	r25, 0xFF	; 255
    3c0a:	47 e4       	ldi	r20, 0x47	; 71
    3c0c:	5e e3       	ldi	r21, 0x3E	; 62
    3c0e:	0e 94 39 28 	call	0x5072	; 0x5072 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    3c12:	80 91 47 3e 	lds	r24, 0x3E47
    3c16:	90 91 48 3e 	lds	r25, 0x3E48
    3c1a:	a0 91 49 3e 	lds	r26, 0x3E49
    3c1e:	b0 91 4a 3e 	lds	r27, 0x3E4A
    3c22:	82 35       	cpi	r24, 0x52	; 82
    3c24:	22 e5       	ldi	r18, 0x52	; 82
    3c26:	92 07       	cpc	r25, r18
    3c28:	21 e6       	ldi	r18, 0x61	; 97
    3c2a:	a2 07       	cpc	r26, r18
    3c2c:	21 e4       	ldi	r18, 0x41	; 65
    3c2e:	b2 07       	cpc	r27, r18
    3c30:	09 f0       	breq	.+2      	; 0x3c34 <getSetFreeCluster+0x5c>
    3c32:	63 c0       	rjmp	.+198    	; 0x3cfa <getSetFreeCluster+0x122>
    3c34:	80 91 2b 40 	lds	r24, 0x402B
    3c38:	90 91 2c 40 	lds	r25, 0x402C
    3c3c:	a0 91 2d 40 	lds	r26, 0x402D
    3c40:	b0 91 2e 40 	lds	r27, 0x402E
    3c44:	82 37       	cpi	r24, 0x72	; 114
    3c46:	22 e7       	ldi	r18, 0x72	; 114
    3c48:	92 07       	cpc	r25, r18
    3c4a:	21 e4       	ldi	r18, 0x41	; 65
    3c4c:	a2 07       	cpc	r26, r18
    3c4e:	21 e6       	ldi	r18, 0x61	; 97
    3c50:	b2 07       	cpc	r27, r18
    3c52:	09 f0       	breq	.+2      	; 0x3c56 <getSetFreeCluster+0x7e>
    3c54:	56 c0       	rjmp	.+172    	; 0x3d02 <getSetFreeCluster+0x12a>
    3c56:	80 91 43 40 	lds	r24, 0x4043
    3c5a:	90 91 44 40 	lds	r25, 0x4044
    3c5e:	a0 91 45 40 	lds	r26, 0x4045
    3c62:	b0 91 46 40 	lds	r27, 0x4046
    3c66:	80 30       	cpi	r24, 0x00	; 0
    3c68:	20 e0       	ldi	r18, 0x00	; 0
    3c6a:	92 07       	cpc	r25, r18
    3c6c:	25 e5       	ldi	r18, 0x55	; 85
    3c6e:	a2 07       	cpc	r26, r18
    3c70:	2a ea       	ldi	r18, 0xAA	; 170
    3c72:	b2 07       	cpc	r27, r18
    3c74:	09 f0       	breq	.+2      	; 0x3c78 <getSetFreeCluster+0xa0>
    3c76:	49 c0       	rjmp	.+146    	; 0x3d0a <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    3c78:	00 23       	and	r16, r16
    3c7a:	a1 f4       	brne	.+40     	; 0x3ca4 <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    3c7c:	c1 30       	cpi	r28, 0x01	; 1
    3c7e:	49 f4       	brne	.+18     	; 0x3c92 <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    3c80:	00 91 2f 40 	lds	r16, 0x402F
    3c84:	10 91 30 40 	lds	r17, 0x4030
    3c88:	20 91 31 40 	lds	r18, 0x4031
    3c8c:	30 91 32 40 	lds	r19, 0x4032
    3c90:	3f c0       	rjmp	.+126    	; 0x3d10 <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    3c92:	00 91 33 40 	lds	r16, 0x4033
    3c96:	10 91 34 40 	lds	r17, 0x4034
    3c9a:	20 91 35 40 	lds	r18, 0x4035
    3c9e:	30 91 36 40 	lds	r19, 0x4036
    3ca2:	36 c0       	rjmp	.+108    	; 0x3d10 <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    3ca4:	c1 30       	cpi	r28, 0x01	; 1
    3ca6:	49 f4       	brne	.+18     	; 0x3cba <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    3ca8:	c0 92 2f 40 	sts	0x402F, r12
    3cac:	d0 92 30 40 	sts	0x4030, r13
    3cb0:	e0 92 31 40 	sts	0x4031, r14
    3cb4:	f0 92 32 40 	sts	0x4032, r15
    3cb8:	08 c0       	rjmp	.+16     	; 0x3cca <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    3cba:	c0 92 33 40 	sts	0x4033, r12
    3cbe:	d0 92 34 40 	sts	0x4034, r13
    3cc2:	e0 92 35 40 	sts	0x4035, r14
    3cc6:	f0 92 36 40 	sts	0x4036, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    3cca:	80 91 69 50 	lds	r24, 0x5069
    3cce:	90 91 6a 50 	lds	r25, 0x506A
    3cd2:	a0 91 6b 50 	lds	r26, 0x506B
    3cd6:	b0 91 6c 50 	lds	r27, 0x506C
    3cda:	bc 01       	movw	r22, r24
    3cdc:	cd 01       	movw	r24, r26
    3cde:	6f 5f       	subi	r22, 0xFF	; 255
    3ce0:	7f 4f       	sbci	r23, 0xFF	; 255
    3ce2:	8f 4f       	sbci	r24, 0xFF	; 255
    3ce4:	9f 4f       	sbci	r25, 0xFF	; 255
    3ce6:	47 e4       	ldi	r20, 0x47	; 71
    3ce8:	5e e3       	ldi	r21, 0x3E	; 62
    3cea:	20 e0       	ldi	r18, 0x00	; 0
    3cec:	32 e0       	ldi	r19, 0x02	; 2
    3cee:	0e 94 84 27 	call	0x4f08	; 0x4f08 <SD_write_block>
 }
 return 0xffffffff;
    3cf2:	0f ef       	ldi	r16, 0xFF	; 255
    3cf4:	1f ef       	ldi	r17, 0xFF	; 255
    3cf6:	98 01       	movw	r18, r16
    3cf8:	0b c0       	rjmp	.+22     	; 0x3d10 <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    3cfa:	0f ef       	ldi	r16, 0xFF	; 255
    3cfc:	1f ef       	ldi	r17, 0xFF	; 255
    3cfe:	98 01       	movw	r18, r16
    3d00:	07 c0       	rjmp	.+14     	; 0x3d10 <getSetFreeCluster+0x138>
    3d02:	0f ef       	ldi	r16, 0xFF	; 255
    3d04:	1f ef       	ldi	r17, 0xFF	; 255
    3d06:	98 01       	movw	r18, r16
    3d08:	03 c0       	rjmp	.+6      	; 0x3d10 <getSetFreeCluster+0x138>
    3d0a:	0f ef       	ldi	r16, 0xFF	; 255
    3d0c:	1f ef       	ldi	r17, 0xFF	; 255
    3d0e:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    3d10:	60 2f       	mov	r22, r16
    3d12:	71 2f       	mov	r23, r17
    3d14:	82 2f       	mov	r24, r18
    3d16:	93 2f       	mov	r25, r19
    3d18:	cf 91       	pop	r28
    3d1a:	1f 91       	pop	r17
    3d1c:	0f 91       	pop	r16
    3d1e:	ff 90       	pop	r15
    3d20:	ef 90       	pop	r14
    3d22:	df 90       	pop	r13
    3d24:	cf 90       	pop	r12
    3d26:	08 95       	ret

00003d28 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    3d28:	ef 92       	push	r14
    3d2a:	ff 92       	push	r15
    3d2c:	0f 93       	push	r16
    3d2e:	1f 93       	push	r17
    3d30:	cf 93       	push	r28
    3d32:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    3d34:	10 92 69 50 	sts	0x5069, r1
    3d38:	10 92 6a 50 	sts	0x506A, r1
    3d3c:	10 92 6b 50 	sts	0x506B, r1
    3d40:	10 92 6c 50 	sts	0x506C, r1

SD_read_block(0,SDBuffer);
    3d44:	60 e0       	ldi	r22, 0x00	; 0
    3d46:	70 e0       	ldi	r23, 0x00	; 0
    3d48:	cb 01       	movw	r24, r22
    3d4a:	47 e4       	ldi	r20, 0x47	; 71
    3d4c:	5e e3       	ldi	r21, 0x3E	; 62
    3d4e:	0e 94 39 28 	call	0x5072	; 0x5072 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    3d52:	80 91 47 3e 	lds	r24, 0x3E47
    3d56:	89 3e       	cpi	r24, 0xE9	; 233
    3d58:	31 f1       	breq	.+76     	; 0x3da6 <getBootSectorData+0x7e>
    3d5a:	8b 3e       	cpi	r24, 0xEB	; 235
    3d5c:	21 f1       	breq	.+72     	; 0x3da6 <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    3d5e:	80 91 45 40 	lds	r24, 0x4045
    3d62:	90 91 46 40 	lds	r25, 0x4046
    3d66:	2a ea       	ldi	r18, 0xAA	; 170
    3d68:	85 35       	cpi	r24, 0x55	; 85
    3d6a:	92 07       	cpc	r25, r18
    3d6c:	09 f0       	breq	.+2      	; 0x3d70 <getBootSectorData+0x48>
    3d6e:	b7 c0       	rjmp	.+366    	; 0x3ede <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    3d70:	60 91 0d 40 	lds	r22, 0x400D
    3d74:	70 91 0e 40 	lds	r23, 0x400E
    3d78:	80 91 0f 40 	lds	r24, 0x400F
    3d7c:	90 91 10 40 	lds	r25, 0x4010
    3d80:	60 93 69 50 	sts	0x5069, r22
    3d84:	70 93 6a 50 	sts	0x506A, r23
    3d88:	80 93 6b 50 	sts	0x506B, r24
    3d8c:	90 93 6c 50 	sts	0x506C, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    3d90:	47 e4       	ldi	r20, 0x47	; 71
    3d92:	5e e3       	ldi	r21, 0x3E	; 62
    3d94:	0e 94 39 28 	call	0x5072	; 0x5072 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    3d98:	80 91 47 3e 	lds	r24, 0x3E47
    3d9c:	89 3e       	cpi	r24, 0xE9	; 233
    3d9e:	19 f0       	breq	.+6      	; 0x3da6 <getBootSectorData+0x7e>
    3da0:	8b 3e       	cpi	r24, 0xEB	; 235
    3da2:	09 f0       	breq	.+2      	; 0x3da6 <getBootSectorData+0x7e>
    3da4:	9e c0       	rjmp	.+316    	; 0x3ee2 <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    3da6:	80 91 52 3e 	lds	r24, 0x3E52
    3daa:	90 91 53 3e 	lds	r25, 0x3E53
    3dae:	80 93 53 40 	sts	0x4053, r24
    3db2:	90 93 54 40 	sts	0x4054, r25
sectorPerCluster = bpb->sectorPerCluster;
    3db6:	80 91 54 3e 	lds	r24, 0x3E54
    3dba:	90 e0       	ldi	r25, 0x00	; 0
    3dbc:	80 93 67 50 	sts	0x5067, r24
    3dc0:	90 93 68 50 	sts	0x5068, r25
reservedSectorCount = bpb->reservedSectorCount;
    3dc4:	e0 90 55 3e 	lds	r14, 0x3E55
    3dc8:	f0 90 56 3e 	lds	r15, 0x3E56
    3dcc:	e0 92 6d 50 	sts	0x506D, r14
    3dd0:	f0 92 6e 50 	sts	0x506E, r15
rootCluster = bpb->rootCluster;
    3dd4:	80 91 73 3e 	lds	r24, 0x3E73
    3dd8:	90 91 74 3e 	lds	r25, 0x3E74
    3ddc:	a0 91 75 3e 	lds	r26, 0x3E75
    3de0:	b0 91 76 3e 	lds	r27, 0x3E76
    3de4:	80 93 5b 40 	sts	0x405B, r24
    3de8:	90 93 5c 40 	sts	0x405C, r25
    3dec:	a0 93 5d 40 	sts	0x405D, r26
    3df0:	b0 93 5e 40 	sts	0x405E, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    3df4:	c0 91 6d 50 	lds	r28, 0x506D
    3df8:	d0 91 6e 50 	lds	r29, 0x506E
    3dfc:	60 91 57 3e 	lds	r22, 0x3E57
    3e00:	70 e0       	ldi	r23, 0x00	; 0
    3e02:	80 e0       	ldi	r24, 0x00	; 0
    3e04:	90 e0       	ldi	r25, 0x00	; 0
    3e06:	20 91 6b 3e 	lds	r18, 0x3E6B
    3e0a:	30 91 6c 3e 	lds	r19, 0x3E6C
    3e0e:	40 91 6d 3e 	lds	r20, 0x3E6D
    3e12:	50 91 6e 3e 	lds	r21, 0x3E6E
    3e16:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    3e1a:	8b 01       	movw	r16, r22
    3e1c:	9c 01       	movw	r18, r24
    3e1e:	ae 01       	movw	r20, r28
    3e20:	60 e0       	ldi	r22, 0x00	; 0
    3e22:	70 e0       	ldi	r23, 0x00	; 0
    3e24:	80 91 63 3e 	lds	r24, 0x3E63
    3e28:	90 91 64 3e 	lds	r25, 0x3E64
    3e2c:	a0 91 65 3e 	lds	r26, 0x3E65
    3e30:	b0 91 66 3e 	lds	r27, 0x3E66
    3e34:	84 0f       	add	r24, r20
    3e36:	95 1f       	adc	r25, r21
    3e38:	a6 1f       	adc	r26, r22
    3e3a:	b7 1f       	adc	r27, r23
    3e3c:	80 0f       	add	r24, r16
    3e3e:	91 1f       	adc	r25, r17
    3e40:	a2 1f       	adc	r26, r18
    3e42:	b3 1f       	adc	r27, r19
    3e44:	80 93 4b 40 	sts	0x404B, r24
    3e48:	90 93 4c 40 	sts	0x404C, r25
    3e4c:	a0 93 4d 40 	sts	0x404D, r26
    3e50:	b0 93 4e 40 	sts	0x404E, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    3e54:	e0 91 67 50 	lds	r30, 0x5067
    3e58:	f0 91 68 50 	lds	r31, 0x5068
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    3e5c:	c7 01       	movw	r24, r14
    3e5e:	a0 e0       	ldi	r26, 0x00	; 0
    3e60:	b0 e0       	ldi	r27, 0x00	; 0
    3e62:	40 91 67 3e 	lds	r20, 0x3E67
    3e66:	50 91 68 3e 	lds	r21, 0x3E68
    3e6a:	60 91 69 3e 	lds	r22, 0x3E69
    3e6e:	70 91 6a 3e 	lds	r23, 0x3E6A
    3e72:	48 1b       	sub	r20, r24
    3e74:	59 0b       	sbc	r21, r25
    3e76:	6a 0b       	sbc	r22, r26
    3e78:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    3e7a:	cb 01       	movw	r24, r22
    3e7c:	ba 01       	movw	r22, r20
    3e7e:	60 1b       	sub	r22, r16
    3e80:	71 0b       	sbc	r23, r17
    3e82:	82 0b       	sbc	r24, r18
    3e84:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    3e86:	9f 01       	movw	r18, r30
    3e88:	40 e0       	ldi	r20, 0x00	; 0
    3e8a:	50 e0       	ldi	r21, 0x00	; 0
    3e8c:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    3e90:	20 93 56 40 	sts	0x4056, r18
    3e94:	30 93 57 40 	sts	0x4057, r19
    3e98:	40 93 58 40 	sts	0x4058, r20
    3e9c:	50 93 59 40 	sts	0x4059, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    3ea0:	81 e0       	ldi	r24, 0x01	; 1
    3ea2:	60 e0       	ldi	r22, 0x00	; 0
    3ea4:	20 e0       	ldi	r18, 0x00	; 0
    3ea6:	30 e0       	ldi	r19, 0x00	; 0
    3ea8:	a9 01       	movw	r20, r18
    3eaa:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <getSetFreeCluster>
    3eae:	ab 01       	movw	r20, r22
    3eb0:	bc 01       	movw	r22, r24
    3eb2:	80 91 56 40 	lds	r24, 0x4056
    3eb6:	90 91 57 40 	lds	r25, 0x4057
    3eba:	a0 91 58 40 	lds	r26, 0x4058
    3ebe:	b0 91 59 40 	lds	r27, 0x4059
    3ec2:	84 17       	cp	r24, r20
    3ec4:	95 07       	cpc	r25, r21
    3ec6:	a6 07       	cpc	r26, r22
    3ec8:	b7 07       	cpc	r27, r23
    3eca:	20 f4       	brcc	.+8      	; 0x3ed4 <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    3ecc:	10 92 9f 50 	sts	0x509F, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    3ed0:	80 e0       	ldi	r24, 0x00	; 0
    3ed2:	08 c0       	rjmp	.+16     	; 0x3ee4 <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    3ed4:	81 e0       	ldi	r24, 0x01	; 1
    3ed6:	80 93 9f 50 	sts	0x509F, r24
return 0;
    3eda:	80 e0       	ldi	r24, 0x00	; 0
    3edc:	03 c0       	rjmp	.+6      	; 0x3ee4 <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    3ede:	81 e0       	ldi	r24, 0x01	; 1
    3ee0:	01 c0       	rjmp	.+2      	; 0x3ee4 <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    3ee2:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    3ee4:	df 91       	pop	r29
    3ee6:	cf 91       	pop	r28
    3ee8:	1f 91       	pop	r17
    3eea:	0f 91       	pop	r16
    3eec:	ff 90       	pop	r15
    3eee:	ef 90       	pop	r14
    3ef0:	08 95       	ret

00003ef2 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    3ef2:	0f 93       	push	r16
    3ef4:	1f 93       	push	r17
    3ef6:	cf 93       	push	r28
    3ef8:	df 93       	push	r29
    3efa:	cd b7       	in	r28, 0x3d	; 61
    3efc:	de b7       	in	r29, 0x3e	; 62
    3efe:	2b 97       	sbiw	r28, 0x0b	; 11
    3f00:	cd bf       	out	0x3d, r28	; 61
    3f02:	de bf       	out	0x3e, r29	; 62
    3f04:	78 2f       	mov	r23, r24
    3f06:	69 2f       	mov	r22, r25
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    3f08:	e8 2f       	mov	r30, r24
    3f0a:	f9 2f       	mov	r31, r25
    3f0c:	df 01       	movw	r26, r30
    3f0e:	0d 90       	ld	r0, X+
    3f10:	00 20       	and	r0, r0
    3f12:	e9 f7       	brne	.-6      	; 0x3f0e <convertFileName+0x1c>
    3f14:	11 97       	sbiw	r26, 0x01	; 1
    3f16:	ae 1b       	sub	r26, r30
    3f18:	bf 0b       	sbc	r27, r31
    3f1a:	a0 31       	cpi	r26, 0x10	; 16
    3f1c:	b1 05       	cpc	r27, r1
    3f1e:	08 f0       	brcs	.+2      	; 0x3f22 <convertFileName+0x30>
    3f20:	9c c0       	rjmp	.+312    	; 0x405a <convertFileName+0x168>
    3f22:	28 2f       	mov	r18, r24
    3f24:	39 2f       	mov	r19, r25
    3f26:	0f e8       	ldi	r16, 0x8F	; 143
    3f28:	10 e5       	ldi	r17, 0x50	; 80
    3f2a:	a8 01       	movw	r20, r16
    3f2c:	80 e0       	ldi	r24, 0x00	; 0
    3f2e:	90 e0       	ldi	r25, 0x00	; 0
    3f30:	07 c0       	rjmp	.+14     	; 0x3f40 <convertFileName+0x4e>
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
    3f32:	d9 01       	movw	r26, r18
    3f34:	ed 91       	ld	r30, X+
    3f36:	9d 01       	movw	r18, r26
    3f38:	da 01       	movw	r26, r20
    3f3a:	ed 93       	st	X+, r30
    3f3c:	ad 01       	movw	r20, r26

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    3f3e:	01 96       	adiw	r24, 0x01	; 1
    3f40:	a7 2f       	mov	r26, r23
    3f42:	b6 2f       	mov	r27, r22
    3f44:	fd 01       	movw	r30, r26
    3f46:	01 90       	ld	r0, Z+
    3f48:	00 20       	and	r0, r0
    3f4a:	e9 f7       	brne	.-6      	; 0x3f46 <convertFileName+0x54>
    3f4c:	31 97       	sbiw	r30, 0x01	; 1
    3f4e:	ea 1b       	sub	r30, r26
    3f50:	fb 0b       	sbc	r31, r27
    3f52:	8e 17       	cp	r24, r30
    3f54:	9f 07       	cpc	r25, r31
    3f56:	68 f3       	brcs	.-38     	; 0x3f32 <convertFileName+0x40>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    3f58:	8f 30       	cpi	r24, 0x0F	; 15
    3f5a:	91 05       	cpc	r25, r1
    3f5c:	54 f4       	brge	.+20     	; 0x3f72 <convertFileName+0x80>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    3f5e:	fc 01       	movw	r30, r24
    3f60:	e1 57       	subi	r30, 0x71	; 113
    3f62:	ff 4a       	sbci	r31, 0xAF	; 175
    3f64:	8e e9       	ldi	r24, 0x9E	; 158
    3f66:	90 e5       	ldi	r25, 0x50	; 80
if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    3f68:	20 e2       	ldi	r18, 0x20	; 32
    3f6a:	21 93       	st	Z+, r18
    3f6c:	e8 17       	cp	r30, r24
    3f6e:	f9 07       	cpc	r31, r25
    3f70:	e1 f7       	brne	.-8      	; 0x3f6a <convertFileName+0x78>


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    3f72:	80 91 8f 50 	lds	r24, 0x508F
    3f76:	8e 32       	cpi	r24, 0x2E	; 46
    3f78:	91 f0       	breq	.+36     	; 0x3f9e <convertFileName+0xac>
    3f7a:	e0 e9       	ldi	r30, 0x90	; 144
    3f7c:	f0 e5       	ldi	r31, 0x50	; 80
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    3f7e:	21 e0       	ldi	r18, 0x01	; 1
if(Filename[j] == '.') break;
    3f80:	81 91       	ld	r24, Z+
    3f82:	8e 32       	cpi	r24, 0x2E	; 46
    3f84:	21 f0       	breq	.+8      	; 0x3f8e <convertFileName+0x9c>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    3f86:	2f 5f       	subi	r18, 0xFF	; 255
    3f88:	2c 30       	cpi	r18, 0x0C	; 12
    3f8a:	d1 f7       	brne	.-12     	; 0x3f80 <convertFileName+0x8e>
    3f8c:	05 c0       	rjmp	.+10     	; 0x3f98 <convertFileName+0xa6>
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    3f8e:	82 2f       	mov	r24, r18
    3f90:	89 50       	subi	r24, 0x09	; 9
    3f92:	83 30       	cpi	r24, 0x03	; 3
    3f94:	08 f4       	brcc	.+2      	; 0x3f98 <convertFileName+0xa6>
    3f96:	63 c0       	rjmp	.+198    	; 0x405e <convertFileName+0x16c>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    3f98:	22 23       	and	r18, r18
    3f9a:	29 f4       	brne	.+10     	; 0x3fa6 <convertFileName+0xb4>
    3f9c:	01 c0       	rjmp	.+2      	; 0x3fa0 <convertFileName+0xae>
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    3f9e:	20 e0       	ldi	r18, 0x00	; 0
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    3fa0:	82 2f       	mov	r24, r18

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    3fa2:	90 e2       	ldi	r25, 0x20	; 32
    3fa4:	10 c0       	rjmp	.+32     	; 0x3fc6 <convertFileName+0xd4>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    3fa6:	de 01       	movw	r26, r28
    3fa8:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    3faa:	82 2f       	mov	r24, r18
    3fac:	81 50       	subi	r24, 0x01	; 1
    3fae:	90 e0       	ldi	r25, 0x00	; 0
    3fb0:	80 57       	subi	r24, 0x70	; 112
    3fb2:	9f 4a       	sbci	r25, 0xAF	; 175
    3fb4:	f8 01       	movw	r30, r16
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];
    3fb6:	31 91       	ld	r19, Z+
    3fb8:	3d 93       	st	X+, r19

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    3fba:	e8 17       	cp	r30, r24
    3fbc:	f9 07       	cpc	r31, r25
    3fbe:	d9 f7       	brne	.-10     	; 0x3fb6 <convertFileName+0xc4>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    3fc0:	28 30       	cpi	r18, 0x08	; 8
    3fc2:	70 f3       	brcs	.-36     	; 0x3fa0 <convertFileName+0xae>
    3fc4:	0a c0       	rjmp	.+20     	; 0x3fda <convertFileName+0xe8>
  fileNameFAT[k] = ' ';
    3fc6:	e1 e0       	ldi	r30, 0x01	; 1
    3fc8:	f0 e0       	ldi	r31, 0x00	; 0
    3fca:	ec 0f       	add	r30, r28
    3fcc:	fd 1f       	adc	r31, r29
    3fce:	e8 0f       	add	r30, r24
    3fd0:	f1 1d       	adc	r31, r1
    3fd2:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    3fd4:	8f 5f       	subi	r24, 0xFF	; 255
    3fd6:	88 30       	cpi	r24, 0x08	; 8
    3fd8:	b0 f3       	brcs	.-20     	; 0x3fc6 <convertFileName+0xd4>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    3fda:	2c 30       	cpi	r18, 0x0C	; 12
    3fdc:	09 f0       	breq	.+2      	; 0x3fe0 <convertFileName+0xee>
    3fde:	2f 5f       	subi	r18, 0xFF	; 255
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    3fe0:	38 e0       	ldi	r19, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    3fe2:	8f e8       	ldi	r24, 0x8F	; 143
    3fe4:	90 e5       	ldi	r25, 0x50	; 80
    3fe6:	fc 01       	movw	r30, r24
    3fe8:	e2 0f       	add	r30, r18
    3fea:	f1 1d       	adc	r31, r1
    3fec:	40 81       	ld	r20, Z
    3fee:	44 23       	and	r20, r20
    3ff0:	19 f4       	brne	.+6      	; 0x3ff8 <convertFileName+0x106>
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    3ff2:	3b 30       	cpi	r19, 0x0B	; 11
    3ff4:	50 f0       	brcs	.+20     	; 0x400a <convertFileName+0x118>
    3ff6:	15 c0       	rjmp	.+42     	; 0x4022 <convertFileName+0x130>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
    3ff8:	e1 e0       	ldi	r30, 0x01	; 1
    3ffa:	f0 e0       	ldi	r31, 0x00	; 0
    3ffc:	ec 0f       	add	r30, r28
    3ffe:	fd 1f       	adc	r31, r29
    4000:	e3 0f       	add	r30, r19
    4002:	f1 1d       	adc	r31, r1
    4004:	40 83       	st	Z, r20
    4006:	2f 5f       	subi	r18, 0xFF	; 255
    4008:	0c c0       	rjmp	.+24     	; 0x4022 <convertFileName+0x130>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    400a:	80 e2       	ldi	r24, 0x20	; 32
    400c:	e1 e0       	ldi	r30, 0x01	; 1
    400e:	f0 e0       	ldi	r31, 0x00	; 0
    4010:	ec 0f       	add	r30, r28
    4012:	fd 1f       	adc	r31, r29
    4014:	e3 0f       	add	r30, r19
    4016:	f1 1d       	adc	r31, r1
    4018:	80 83       	st	Z, r24
    401a:	3f 5f       	subi	r19, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    401c:	3b 30       	cpi	r19, 0x0B	; 11
    401e:	b1 f7       	brne	.-20     	; 0x400c <convertFileName+0x11a>
    4020:	03 c0       	rjmp	.+6      	; 0x4028 <convertFileName+0x136>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    4022:	3f 5f       	subi	r19, 0xFF	; 255
    4024:	3b 30       	cpi	r19, 0x0B	; 11
    4026:	f8 f2       	brcs	.-66     	; 0x3fe6 <convertFileName+0xf4>
    4028:	de 01       	movw	r26, r28
    402a:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    402c:	ce 01       	movw	r24, r28
    402e:	0c 96       	adiw	r24, 0x0c	; 12
    4030:	fd 01       	movw	r30, r26
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    4032:	20 81       	ld	r18, Z
    4034:	32 2f       	mov	r19, r18
    4036:	31 56       	subi	r19, 0x61	; 97
    4038:	3a 31       	cpi	r19, 0x1A	; 26
    403a:	10 f4       	brcc	.+4      	; 0x4040 <convertFileName+0x14e>
    fileNameFAT[j] -= 0x20;
    403c:	20 52       	subi	r18, 0x20	; 32
    403e:	20 83       	st	Z, r18
    4040:	31 96       	adiw	r30, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    4042:	e8 17       	cp	r30, r24
    4044:	f9 07       	cpc	r31, r25
    4046:	a9 f7       	brne	.-22     	; 0x4032 <convertFileName+0x140>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];
    4048:	2d 91       	ld	r18, X+
    404a:	f8 01       	movw	r30, r16
    404c:	21 93       	st	Z+, r18
    404e:	8f 01       	movw	r16, r30

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    4050:	a8 17       	cp	r26, r24
    4052:	b9 07       	cpc	r27, r25
    4054:	c9 f7       	brne	.-14     	; 0x4048 <convertFileName+0x156>
  Filename[j] = fileNameFAT[j];

return 0;
    4056:	80 e0       	ldi	r24, 0x00	; 0
    4058:	03 c0       	rjmp	.+6      	; 0x4060 <convertFileName+0x16e>
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    405a:	81 e0       	ldi	r24, 0x01	; 1
    405c:	01 c0       	rjmp	.+2      	; 0x4060 <convertFileName+0x16e>

for(j=0; j<12; j++)
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    405e:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];

return 0;
}
    4060:	2b 96       	adiw	r28, 0x0b	; 11
    4062:	cd bf       	out	0x3d, r28	; 61
    4064:	de bf       	out	0x3e, r29	; 62
    4066:	df 91       	pop	r29
    4068:	cf 91       	pop	r28
    406a:	1f 91       	pop	r17
    406c:	0f 91       	pop	r16
    406e:	08 95       	ret

00004070 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    4070:	4f 92       	push	r4
    4072:	5f 92       	push	r5
    4074:	6f 92       	push	r6
    4076:	7f 92       	push	r7
    4078:	8f 92       	push	r8
    407a:	9f 92       	push	r9
    407c:	af 92       	push	r10
    407e:	bf 92       	push	r11
    4080:	cf 92       	push	r12
    4082:	df 92       	push	r13
    4084:	ef 92       	push	r14
    4086:	ff 92       	push	r15
    4088:	cf 93       	push	r28
    408a:	df 93       	push	r29
    408c:	2b 01       	movw	r4, r22
    408e:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    4090:	20 e8       	ldi	r18, 0x80	; 128
    4092:	3f ef       	ldi	r19, 0xFF	; 255
    4094:	4f ef       	ldi	r20, 0xFF	; 255
    4096:	5f ef       	ldi	r21, 0xFF	; 255
    4098:	42 22       	and	r4, r18
    409a:	53 22       	and	r5, r19
    409c:	64 22       	and	r6, r20
    409e:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    40a0:	80 91 56 40 	lds	r24, 0x4056
    40a4:	90 91 57 40 	lds	r25, 0x4057
    40a8:	a0 91 58 40 	lds	r26, 0x4058
    40ac:	b0 91 59 40 	lds	r27, 0x4059
    40b0:	48 16       	cp	r4, r24
    40b2:	59 06       	cpc	r5, r25
    40b4:	6a 06       	cpc	r6, r26
    40b6:	7b 06       	cpc	r7, r27
    40b8:	08 f0       	brcs	.+2      	; 0x40bc <searchNextFreeCluster+0x4c>
    40ba:	77 c0       	rjmp	.+238    	; 0x41aa <searchNextFreeCluster+0x13a>
    40bc:	53 01       	movw	r10, r6
    40be:	42 01       	movw	r8, r4
    40c0:	88 0c       	add	r8, r8
    40c2:	99 1c       	adc	r9, r9
    40c4:	aa 1c       	adc	r10, r10
    40c6:	bb 1c       	adc	r11, r11
    40c8:	88 0c       	add	r8, r8
    40ca:	99 1c       	adc	r9, r9
    40cc:	aa 1c       	adc	r10, r10
    40ce:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    40d0:	c7 e4       	ldi	r28, 0x47	; 71
    40d2:	de e3       	ldi	r29, 0x3E	; 62
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    40d4:	c0 90 6d 50 	lds	r12, 0x506D
    40d8:	d0 90 6e 50 	lds	r13, 0x506E
    40dc:	20 91 53 40 	lds	r18, 0x4053
    40e0:	30 91 54 40 	lds	r19, 0x4054
    40e4:	ee 24       	eor	r14, r14
    40e6:	ff 24       	eor	r15, r15
    40e8:	80 91 69 50 	lds	r24, 0x5069
    40ec:	90 91 6a 50 	lds	r25, 0x506A
    40f0:	a0 91 6b 50 	lds	r26, 0x506B
    40f4:	b0 91 6c 50 	lds	r27, 0x506C
    40f8:	c8 0e       	add	r12, r24
    40fa:	d9 1e       	adc	r13, r25
    40fc:	ea 1e       	adc	r14, r26
    40fe:	fb 1e       	adc	r15, r27
    4100:	40 e0       	ldi	r20, 0x00	; 0
    4102:	50 e0       	ldi	r21, 0x00	; 0
    4104:	c5 01       	movw	r24, r10
    4106:	b4 01       	movw	r22, r8
    4108:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    410c:	c7 01       	movw	r24, r14
    410e:	b6 01       	movw	r22, r12
    4110:	62 0f       	add	r22, r18
    4112:	73 1f       	adc	r23, r19
    4114:	84 1f       	adc	r24, r20
    4116:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    4118:	ae 01       	movw	r20, r28
    411a:	0e 94 39 28 	call	0x5072	; 0x5072 <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    411e:	88 81       	ld	r24, Y
    4120:	99 81       	ldd	r25, Y+1	; 0x01
    4122:	aa 81       	ldd	r26, Y+2	; 0x02
    4124:	bb 81       	ldd	r27, Y+3	; 0x03
    4126:	bf 70       	andi	r27, 0x0F	; 15
    4128:	00 97       	sbiw	r24, 0x00	; 0
    412a:	a1 05       	cpc	r26, r1
    412c:	b1 05       	cpc	r27, r1
    412e:	99 f0       	breq	.+38     	; 0x4156 <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4130:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    4132:	e2 2f       	mov	r30, r18
    4134:	f0 e0       	ldi	r31, 0x00	; 0
    4136:	ee 0f       	add	r30, r30
    4138:	ff 1f       	adc	r31, r31
    413a:	ee 0f       	add	r30, r30
    413c:	ff 1f       	adc	r31, r31
         if(((*value) & 0x0fffffff) == 0)
    413e:	e9 5b       	subi	r30, 0xB9	; 185
    4140:	f1 4c       	sbci	r31, 0xC1	; 193
    4142:	80 81       	ld	r24, Z
    4144:	91 81       	ldd	r25, Z+1	; 0x01
    4146:	a2 81       	ldd	r26, Z+2	; 0x02
    4148:	b3 81       	ldd	r27, Z+3	; 0x03
    414a:	bf 70       	andi	r27, 0x0F	; 15
    414c:	00 97       	sbiw	r24, 0x00	; 0
    414e:	a1 05       	cpc	r26, r1
    4150:	b1 05       	cpc	r27, r1
    4152:	39 f4       	brne	.+14     	; 0x4162 <searchNextFreeCluster+0xf2>
    4154:	01 c0       	rjmp	.+2      	; 0x4158 <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4156:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    4158:	42 0e       	add	r4, r18
    415a:	51 1c       	adc	r5, r1
    415c:	61 1c       	adc	r6, r1
    415e:	71 1c       	adc	r7, r1
    4160:	27 c0       	rjmp	.+78     	; 0x41b0 <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4162:	2f 5f       	subi	r18, 0xFF	; 255
    4164:	32 f7       	brpl	.-52     	; 0x4132 <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    4166:	80 e8       	ldi	r24, 0x80	; 128
    4168:	90 e0       	ldi	r25, 0x00	; 0
    416a:	a0 e0       	ldi	r26, 0x00	; 0
    416c:	b0 e0       	ldi	r27, 0x00	; 0
    416e:	48 0e       	add	r4, r24
    4170:	59 1e       	adc	r5, r25
    4172:	6a 1e       	adc	r6, r26
    4174:	7b 1e       	adc	r7, r27
    4176:	80 91 56 40 	lds	r24, 0x4056
    417a:	90 91 57 40 	lds	r25, 0x4057
    417e:	a0 91 58 40 	lds	r26, 0x4058
    4182:	b0 91 59 40 	lds	r27, 0x4059
    4186:	20 e0       	ldi	r18, 0x00	; 0
    4188:	32 e0       	ldi	r19, 0x02	; 2
    418a:	40 e0       	ldi	r20, 0x00	; 0
    418c:	50 e0       	ldi	r21, 0x00	; 0
    418e:	82 0e       	add	r8, r18
    4190:	93 1e       	adc	r9, r19
    4192:	a4 1e       	adc	r10, r20
    4194:	b5 1e       	adc	r11, r21
    4196:	48 16       	cp	r4, r24
    4198:	59 06       	cpc	r5, r25
    419a:	6a 06       	cpc	r6, r26
    419c:	7b 06       	cpc	r7, r27
    419e:	08 f4       	brcc	.+2      	; 0x41a2 <searchNextFreeCluster+0x132>
    41a0:	99 cf       	rjmp	.-206    	; 0x40d4 <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    41a2:	44 24       	eor	r4, r4
    41a4:	55 24       	eor	r5, r5
    41a6:	32 01       	movw	r6, r4
    41a8:	03 c0       	rjmp	.+6      	; 0x41b0 <searchNextFreeCluster+0x140>
    41aa:	44 24       	eor	r4, r4
    41ac:	55 24       	eor	r5, r5
    41ae:	32 01       	movw	r6, r4
}
    41b0:	64 2d       	mov	r22, r4
    41b2:	75 2d       	mov	r23, r5
    41b4:	86 2d       	mov	r24, r6
    41b6:	97 2d       	mov	r25, r7
    41b8:	df 91       	pop	r29
    41ba:	cf 91       	pop	r28
    41bc:	ff 90       	pop	r15
    41be:	ef 90       	pop	r14
    41c0:	df 90       	pop	r13
    41c2:	cf 90       	pop	r12
    41c4:	bf 90       	pop	r11
    41c6:	af 90       	pop	r10
    41c8:	9f 90       	pop	r9
    41ca:	8f 90       	pop	r8
    41cc:	7f 90       	pop	r7
    41ce:	6f 90       	pop	r6
    41d0:	5f 90       	pop	r5
    41d2:	4f 90       	pop	r4
    41d4:	08 95       	ret

000041d6 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    41d6:	cf 92       	push	r12
    41d8:	df 92       	push	r13
    41da:	ef 92       	push	r14
    41dc:	ff 92       	push	r15
    41de:	cf 93       	push	r28
    41e0:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    41e2:	db 01       	movw	r26, r22
    41e4:	ca 01       	movw	r24, r20
    41e6:	91 70       	andi	r25, 0x01	; 1
    41e8:	a0 70       	andi	r26, 0x00	; 0
    41ea:	b0 70       	andi	r27, 0x00	; 0
    41ec:	00 97       	sbiw	r24, 0x00	; 0
    41ee:	a1 05       	cpc	r26, r1
    41f0:	b1 05       	cpc	r27, r1
    41f2:	51 f4       	brne	.+20     	; 0x4208 <freeMemoryUpdate+0x32>
    41f4:	03 2e       	mov	r0, r19
    41f6:	39 e0       	ldi	r19, 0x09	; 9
    41f8:	76 95       	lsr	r23
    41fa:	67 95       	ror	r22
    41fc:	57 95       	ror	r21
    41fe:	47 95       	ror	r20
    4200:	3a 95       	dec	r19
    4202:	d1 f7       	brne	.-12     	; 0x41f8 <freeMemoryUpdate+0x22>
    4204:	30 2d       	mov	r19, r0
    4206:	0d c0       	rjmp	.+26     	; 0x4222 <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    4208:	03 2e       	mov	r0, r19
    420a:	39 e0       	ldi	r19, 0x09	; 9
    420c:	76 95       	lsr	r23
    420e:	67 95       	ror	r22
    4210:	57 95       	ror	r21
    4212:	47 95       	ror	r20
    4214:	3a 95       	dec	r19
    4216:	d1 f7       	brne	.-12     	; 0x420c <freeMemoryUpdate+0x36>
    4218:	30 2d       	mov	r19, r0
    421a:	4f 5f       	subi	r20, 0xFF	; 255
    421c:	5f 4f       	sbci	r21, 0xFF	; 255
    421e:	6f 4f       	sbci	r22, 0xFF	; 255
    4220:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    4222:	db 01       	movw	r26, r22
    4224:	ca 01       	movw	r24, r20
    4226:	87 70       	andi	r24, 0x07	; 7
    4228:	90 70       	andi	r25, 0x00	; 0
    422a:	a0 70       	andi	r26, 0x00	; 0
    422c:	b0 70       	andi	r27, 0x00	; 0
    422e:	00 97       	sbiw	r24, 0x00	; 0
    4230:	a1 05       	cpc	r26, r1
    4232:	b1 05       	cpc	r27, r1
    4234:	59 f4       	brne	.+22     	; 0x424c <freeMemoryUpdate+0x76>
    4236:	6a 01       	movw	r12, r20
    4238:	7b 01       	movw	r14, r22
    423a:	68 94       	set
    423c:	12 f8       	bld	r1, 2
    423e:	f6 94       	lsr	r15
    4240:	e7 94       	ror	r14
    4242:	d7 94       	ror	r13
    4244:	c7 94       	ror	r12
    4246:	16 94       	lsr	r1
    4248:	d1 f7       	brne	.-12     	; 0x423e <freeMemoryUpdate+0x68>
    424a:	0f c0       	rjmp	.+30     	; 0x426a <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    424c:	6a 01       	movw	r12, r20
    424e:	7b 01       	movw	r14, r22
    4250:	68 94       	set
    4252:	12 f8       	bld	r1, 2
    4254:	f6 94       	lsr	r15
    4256:	e7 94       	ror	r14
    4258:	d7 94       	ror	r13
    425a:	c7 94       	ror	r12
    425c:	16 94       	lsr	r1
    425e:	d1 f7       	brne	.-12     	; 0x4254 <freeMemoryUpdate+0x7e>
    4260:	08 94       	sec
    4262:	c1 1c       	adc	r12, r1
    4264:	d1 1c       	adc	r13, r1
    4266:	e1 1c       	adc	r14, r1
    4268:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    426a:	80 91 9f 50 	lds	r24, 0x509F
    426e:	88 23       	and	r24, r24
    4270:	d1 f0       	breq	.+52     	; 0x42a6 <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    4272:	81 e0       	ldi	r24, 0x01	; 1
    4274:	60 e0       	ldi	r22, 0x00	; 0
    4276:	20 e0       	ldi	r18, 0x00	; 0
    4278:	30 e0       	ldi	r19, 0x00	; 0
    427a:	a9 01       	movw	r20, r18
    427c:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <getSetFreeCluster>
	if(flag == ADD)
    4280:	cc 23       	and	r28, r28
    4282:	39 f4       	brne	.+14     	; 0x4292 <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    4284:	9b 01       	movw	r18, r22
    4286:	ac 01       	movw	r20, r24
    4288:	2c 0d       	add	r18, r12
    428a:	3d 1d       	adc	r19, r13
    428c:	4e 1d       	adc	r20, r14
    428e:	5f 1d       	adc	r21, r15
    4290:	06 c0       	rjmp	.+12     	; 0x429e <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    4292:	9b 01       	movw	r18, r22
    4294:	ac 01       	movw	r20, r24
    4296:	2c 19       	sub	r18, r12
    4298:	3d 09       	sbc	r19, r13
    429a:	4e 09       	sbc	r20, r14
    429c:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    429e:	81 e0       	ldi	r24, 0x01	; 1
    42a0:	61 e0       	ldi	r22, 0x01	; 1
    42a2:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <getSetFreeCluster>
  }
}
    42a6:	cf 91       	pop	r28
    42a8:	ff 90       	pop	r15
    42aa:	ef 90       	pop	r14
    42ac:	df 90       	pop	r13
    42ae:	cf 90       	pop	r12
    42b0:	08 95       	ret

000042b2 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    42b2:	2f 92       	push	r2
    42b4:	3f 92       	push	r3
    42b6:	4f 92       	push	r4
    42b8:	5f 92       	push	r5
    42ba:	6f 92       	push	r6
    42bc:	7f 92       	push	r7
    42be:	8f 92       	push	r8
    42c0:	9f 92       	push	r9
    42c2:	af 92       	push	r10
    42c4:	bf 92       	push	r11
    42c6:	cf 92       	push	r12
    42c8:	df 92       	push	r13
    42ca:	ef 92       	push	r14
    42cc:	ff 92       	push	r15
    42ce:	0f 93       	push	r16
    42d0:	1f 93       	push	r17
    42d2:	cf 93       	push	r28
    42d4:	df 93       	push	r29
    42d6:	cd b7       	in	r28, 0x3d	; 61
    42d8:	de b7       	in	r29, 0x3e	; 62
    42da:	2c 97       	sbiw	r28, 0x0c	; 12
    42dc:	cd bf       	out	0x3d, r28	; 61
    42de:	de bf       	out	0x3e, r29	; 62
    42e0:	88 2e       	mov	r8, r24
    42e2:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    42e4:	80 91 5b 40 	lds	r24, 0x405B
    42e8:	90 91 5c 40 	lds	r25, 0x405C
    42ec:	a0 91 5d 40 	lds	r26, 0x405D
    42f0:	b0 91 5e 40 	lds	r27, 0x405E
    42f4:	89 87       	std	Y+9, r24	; 0x09
    42f6:	9a 87       	std	Y+10, r25	; 0x0a
    42f8:	ab 87       	std	Y+11, r26	; 0x0b
    42fa:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    42fc:	0f 2e       	mov	r0, r31
    42fe:	f7 e4       	ldi	r31, 0x47	; 71
    4300:	2f 2e       	mov	r2, r31
    4302:	fe e3       	ldi	r31, 0x3E	; 62
    4304:	3f 2e       	mov	r3, r31
    4306:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4308:	c8 2c       	mov	r12, r8
    430a:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    430c:	d2 2c       	mov	r13, r2
    430e:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4310:	5b 01       	movw	r10, r22
    4312:	08 94       	sec
    4314:	a1 1c       	adc	r10, r1
    4316:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    4318:	69 85       	ldd	r22, Y+9	; 0x09
    431a:	7a 85       	ldd	r23, Y+10	; 0x0a
    431c:	8b 85       	ldd	r24, Y+11	; 0x0b
    431e:	9c 85       	ldd	r25, Y+12	; 0x0c
    4320:	0e 94 33 1d 	call	0x3a66	; 0x3a66 <getFirstSector>
    4324:	6d 83       	std	Y+5, r22	; 0x05
    4326:	7e 83       	std	Y+6, r23	; 0x06
    4328:	8f 83       	std	Y+7, r24	; 0x07
    432a:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    432c:	80 91 67 50 	lds	r24, 0x5067
    4330:	90 91 68 50 	lds	r25, 0x5068
    4334:	00 97       	sbiw	r24, 0x00	; 0
    4336:	09 f4       	brne	.+2      	; 0x433a <findFiles+0x88>
    4338:	13 c1       	rjmp	.+550    	; 0x4560 <findFiles+0x2ae>
    433a:	44 24       	eor	r4, r4
    433c:	55 24       	eor	r5, r5
    433e:	32 01       	movw	r6, r4
    4340:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4342:	8d 81       	ldd	r24, Y+5	; 0x05
    4344:	9e 81       	ldd	r25, Y+6	; 0x06
    4346:	af 81       	ldd	r26, Y+7	; 0x07
    4348:	b8 85       	ldd	r27, Y+8	; 0x08
    434a:	84 0d       	add	r24, r4
    434c:	95 1d       	adc	r25, r5
    434e:	a6 1d       	adc	r26, r6
    4350:	b7 1d       	adc	r27, r7
    4352:	89 83       	std	Y+1, r24	; 0x01
    4354:	9a 83       	std	Y+2, r25	; 0x02
    4356:	ab 83       	std	Y+3, r26	; 0x03
    4358:	bc 83       	std	Y+4, r27	; 0x04
    435a:	bc 01       	movw	r22, r24
    435c:	cd 01       	movw	r24, r26
    435e:	4d 2d       	mov	r20, r13
    4360:	59 2d       	mov	r21, r9
    4362:	0e 94 39 28 	call	0x5072	; 0x5072 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    4366:	80 91 53 40 	lds	r24, 0x4053
    436a:	90 91 54 40 	lds	r25, 0x4054
    436e:	00 97       	sbiw	r24, 0x00	; 0
    4370:	09 f4       	brne	.+2      	; 0x4374 <findFiles+0xc2>
    4372:	e4 c0       	rjmp	.+456    	; 0x453c <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4374:	d1 01       	movw	r26, r2
    4376:	8c 91       	ld	r24, X
    4378:	88 23       	and	r24, r24
    437a:	09 f4       	brne	.+2      	; 0x437e <findFiles+0xcc>
    437c:	10 c1       	rjmp	.+544    	; 0x459e <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    437e:	4d 2d       	mov	r20, r13
    4380:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4382:	20 e0       	ldi	r18, 0x00	; 0
    4384:	30 e0       	ldi	r19, 0x00	; 0
    4386:	08 c0       	rjmp	.+16     	; 0x4398 <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4388:	a9 01       	movw	r20, r18
    438a:	49 5b       	subi	r20, 0xB9	; 185
    438c:	51 4c       	sbci	r21, 0xC1	; 193

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    438e:	fa 01       	movw	r30, r20
    4390:	80 81       	ld	r24, Z
    4392:	88 23       	and	r24, r24
    4394:	09 f4       	brne	.+2      	; 0x4398 <findFiles+0xe6>
    4396:	06 c1       	rjmp	.+524    	; 0x45a4 <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    4398:	85 3e       	cpi	r24, 0xE5	; 229
    439a:	09 f4       	brne	.+2      	; 0x439e <findFiles+0xec>
    439c:	c5 c0       	rjmp	.+394    	; 0x4528 <findFiles+0x276>
    439e:	da 01       	movw	r26, r20
    43a0:	1b 96       	adiw	r26, 0x0b	; 11
    43a2:	8c 91       	ld	r24, X
    43a4:	1b 97       	sbiw	r26, 0x0b	; 11
    43a6:	8f 30       	cpi	r24, 0x0F	; 15
    43a8:	09 f4       	brne	.+2      	; 0x43ac <findFiles+0xfa>
    43aa:	be c0       	rjmp	.+380    	; 0x4528 <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    43ac:	12 30       	cpi	r17, 0x02	; 2
    43ae:	08 f0       	brcs	.+2      	; 0x43b2 <findFiles+0x100>
    43b0:	fc c0       	rjmp	.+504    	; 0x45aa <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    43b2:	9c 91       	ld	r25, X
    43b4:	f7 01       	movw	r30, r14
    43b6:	80 81       	ld	r24, Z
    43b8:	98 17       	cp	r25, r24
    43ba:	09 f0       	breq	.+2      	; 0x43be <findFiles+0x10c>
    43bc:	b5 c0       	rjmp	.+362    	; 0x4528 <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    43be:	fa 01       	movw	r30, r20
    43c0:	31 96       	adiw	r30, 0x01	; 1
    43c2:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    43c4:	81 e0       	ldi	r24, 0x01	; 1
    43c6:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    43c8:	41 91       	ld	r20, Z+
    43ca:	9d 91       	ld	r25, X+
    43cc:	49 17       	cp	r20, r25
    43ce:	31 f4       	brne	.+12     	; 0x43dc <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    43d0:	8f 5f       	subi	r24, 0xFF	; 255
    43d2:	8b 30       	cpi	r24, 0x0B	; 11
    43d4:	c9 f7       	brne	.-14     	; 0x43c8 <findFiles+0x116>
    43d6:	8b 01       	movw	r16, r22
    43d8:	6b 01       	movw	r12, r22
    43da:	05 c0       	rjmp	.+10     	; 0x43e6 <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    43dc:	8b 30       	cpi	r24, 0x0B	; 11
    43de:	09 f0       	breq	.+2      	; 0x43e2 <findFiles+0x130>
    43e0:	a3 c0       	rjmp	.+326    	; 0x4528 <findFiles+0x276>
    43e2:	8b 01       	movw	r16, r22
    43e4:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    43e6:	f1 e0       	ldi	r31, 0x01	; 1
    43e8:	8f 16       	cp	r8, r31
    43ea:	09 f0       	breq	.+2      	; 0x43ee <findFiles+0x13c>
    43ec:	41 c0       	rjmp	.+130    	; 0x4470 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    43ee:	89 81       	ldd	r24, Y+1	; 0x01
    43f0:	9a 81       	ldd	r25, Y+2	; 0x02
    43f2:	ab 81       	ldd	r26, Y+3	; 0x03
    43f4:	bc 81       	ldd	r27, Y+4	; 0x04
    43f6:	80 93 a0 50 	sts	0x50A0, r24
    43fa:	90 93 a1 50 	sts	0x50A1, r25
    43fe:	a0 93 a2 50 	sts	0x50A2, r26
    4402:	b0 93 a3 50 	sts	0x50A3, r27
				appendFileLocation = i;
    4406:	c9 01       	movw	r24, r18
    4408:	a0 e0       	ldi	r26, 0x00	; 0
    440a:	b0 e0       	ldi	r27, 0x00	; 0
    440c:	80 93 47 40 	sts	0x4047, r24
    4410:	90 93 48 40 	sts	0x4048, r25
    4414:	a0 93 49 40 	sts	0x4049, r26
    4418:	b0 93 4a 40 	sts	0x404A, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    441c:	d6 01       	movw	r26, r12
    441e:	54 96       	adiw	r26, 0x14	; 20
    4420:	4d 91       	ld	r20, X+
    4422:	5c 91       	ld	r21, X
    4424:	55 97       	sbiw	r26, 0x15	; 21
    4426:	60 e0       	ldi	r22, 0x00	; 0
    4428:	70 e0       	ldi	r23, 0x00	; 0
    442a:	ba 01       	movw	r22, r20
    442c:	55 27       	eor	r21, r21
    442e:	44 27       	eor	r20, r20
    4430:	5a 96       	adiw	r26, 0x1a	; 26
    4432:	8d 91       	ld	r24, X+
    4434:	9c 91       	ld	r25, X
    4436:	5b 97       	sbiw	r26, 0x1b	; 27
    4438:	a0 e0       	ldi	r26, 0x00	; 0
    443a:	b0 e0       	ldi	r27, 0x00	; 0
    443c:	84 2b       	or	r24, r20
    443e:	95 2b       	or	r25, r21
    4440:	a6 2b       	or	r26, r22
    4442:	b7 2b       	or	r27, r23
    4444:	80 93 71 50 	sts	0x5071, r24
    4448:	90 93 72 50 	sts	0x5072, r25
    444c:	a0 93 73 50 	sts	0x5073, r26
    4450:	b0 93 74 50 	sts	0x5074, r27
				fileSize = dir->fileSize;
    4454:	f6 01       	movw	r30, r12
    4456:	84 8d       	ldd	r24, Z+28	; 0x1c
    4458:	95 8d       	ldd	r25, Z+29	; 0x1d
    445a:	a6 8d       	ldd	r26, Z+30	; 0x1e
    445c:	b7 8d       	ldd	r27, Z+31	; 0x1f
    445e:	80 93 4f 40 	sts	0x404F, r24
    4462:	90 93 50 40 	sts	0x4050, r25
    4466:	a0 93 51 40 	sts	0x4051, r26
    446a:	b0 93 52 40 	sts	0x4052, r27
			    return (dir);
    446e:	a5 c0       	rjmp	.+330    	; 0x45ba <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4470:	d6 01       	movw	r26, r12
    4472:	54 96       	adiw	r26, 0x14	; 20
    4474:	8d 91       	ld	r24, X+
    4476:	9c 91       	ld	r25, X
    4478:	55 97       	sbiw	r26, 0x15	; 21
    447a:	a0 e0       	ldi	r26, 0x00	; 0
    447c:	b0 e0       	ldi	r27, 0x00	; 0
    447e:	3c 01       	movw	r6, r24
    4480:	55 24       	eor	r5, r5
    4482:	44 24       	eor	r4, r4
    4484:	f6 01       	movw	r30, r12
    4486:	82 8d       	ldd	r24, Z+26	; 0x1a
    4488:	93 8d       	ldd	r25, Z+27	; 0x1b
    448a:	a0 e0       	ldi	r26, 0x00	; 0
    448c:	b0 e0       	ldi	r27, 0x00	; 0
    448e:	48 2a       	or	r4, r24
    4490:	59 2a       	or	r5, r25
    4492:	6a 2a       	or	r6, r26
    4494:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    4496:	85 ee       	ldi	r24, 0xE5	; 229
    4498:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    449a:	69 81       	ldd	r22, Y+1	; 0x01
    449c:	7a 81       	ldd	r23, Y+2	; 0x02
    449e:	8b 81       	ldd	r24, Y+3	; 0x03
    44a0:	9c 81       	ldd	r25, Y+4	; 0x04
    44a2:	47 e4       	ldi	r20, 0x47	; 71
    44a4:	5e e3       	ldi	r21, 0x3E	; 62
    44a6:	20 e0       	ldi	r18, 0x00	; 0
    44a8:	32 e0       	ldi	r19, 0x02	; 2
    44aa:	0e 94 84 27 	call	0x4f08	; 0x4f08 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    44ae:	d6 01       	movw	r26, r12
    44b0:	5c 96       	adiw	r26, 0x1c	; 28
    44b2:	4d 91       	ld	r20, X+
    44b4:	5d 91       	ld	r21, X+
    44b6:	6d 91       	ld	r22, X+
    44b8:	7c 91       	ld	r23, X
    44ba:	5f 97       	sbiw	r26, 0x1f	; 31
    44bc:	80 e0       	ldi	r24, 0x00	; 0
    44be:	0e 94 eb 20 	call	0x41d6	; 0x41d6 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    44c2:	82 e0       	ldi	r24, 0x02	; 2
    44c4:	60 e0       	ldi	r22, 0x00	; 0
    44c6:	20 e0       	ldi	r18, 0x00	; 0
    44c8:	30 e0       	ldi	r19, 0x00	; 0
    44ca:	a9 01       	movw	r20, r18
    44cc:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <getSetFreeCluster>
    44d0:	dc 01       	movw	r26, r24
    44d2:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    44d4:	48 16       	cp	r4, r24
    44d6:	59 06       	cpc	r5, r25
    44d8:	6a 06       	cpc	r6, r26
    44da:	7b 06       	cpc	r7, r27
    44dc:	30 f4       	brcc	.+12     	; 0x44ea <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    44de:	82 e0       	ldi	r24, 0x02	; 2
    44e0:	61 e0       	ldi	r22, 0x01	; 1
    44e2:	a3 01       	movw	r20, r6
    44e4:	92 01       	movw	r18, r4
    44e6:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    44ea:	c3 01       	movw	r24, r6
    44ec:	b2 01       	movw	r22, r4
    44ee:	40 e0       	ldi	r20, 0x00	; 0
    44f0:	00 e0       	ldi	r16, 0x00	; 0
    44f2:	10 e0       	ldi	r17, 0x00	; 0
    44f4:	98 01       	movw	r18, r16
    44f6:	0e 94 5a 1d 	call	0x3ab4	; 0x3ab4 <getSetNextCluster>
    44fa:	6b 01       	movw	r12, r22
    44fc:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    44fe:	c3 01       	movw	r24, r6
    4500:	b2 01       	movw	r22, r4
    4502:	41 e0       	ldi	r20, 0x01	; 1
    4504:	00 e0       	ldi	r16, 0x00	; 0
    4506:	10 e0       	ldi	r17, 0x00	; 0
    4508:	98 01       	movw	r18, r16
    450a:	0e 94 5a 1d 	call	0x3ab4	; 0x3ab4 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    450e:	b7 ef       	ldi	r27, 0xF7	; 247
    4510:	cb 16       	cp	r12, r27
    4512:	bf ef       	ldi	r27, 0xFF	; 255
    4514:	db 06       	cpc	r13, r27
    4516:	bf ef       	ldi	r27, 0xFF	; 255
    4518:	eb 06       	cpc	r14, r27
    451a:	bf e0       	ldi	r27, 0x0F	; 15
    451c:	fb 06       	cpc	r15, r27
    451e:	08 f0       	brcs	.+2      	; 0x4522 <findFiles+0x270>
    4520:	47 c0       	rjmp	.+142    	; 0x45b0 <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    4522:	26 01       	movw	r4, r12
    4524:	37 01       	movw	r6, r14
    4526:	e1 cf       	rjmp	.-62     	; 0x44ea <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4528:	20 5e       	subi	r18, 0xE0	; 224
    452a:	3f 4f       	sbci	r19, 0xFF	; 255
    452c:	80 91 53 40 	lds	r24, 0x4053
    4530:	90 91 54 40 	lds	r25, 0x4054
    4534:	28 17       	cp	r18, r24
    4536:	39 07       	cpc	r19, r25
    4538:	08 f4       	brcc	.+2      	; 0x453c <findFiles+0x28a>
    453a:	26 cf       	rjmp	.-436    	; 0x4388 <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    453c:	08 94       	sec
    453e:	41 1c       	adc	r4, r1
    4540:	51 1c       	adc	r5, r1
    4542:	61 1c       	adc	r6, r1
    4544:	71 1c       	adc	r7, r1
    4546:	80 91 67 50 	lds	r24, 0x5067
    454a:	90 91 68 50 	lds	r25, 0x5068
    454e:	a0 e0       	ldi	r26, 0x00	; 0
    4550:	b0 e0       	ldi	r27, 0x00	; 0
    4552:	48 16       	cp	r4, r24
    4554:	59 06       	cpc	r5, r25
    4556:	6a 06       	cpc	r6, r26
    4558:	7b 06       	cpc	r7, r27
    455a:	08 f4       	brcc	.+2      	; 0x455e <findFiles+0x2ac>
    455c:	f2 ce       	rjmp	.-540    	; 0x4342 <findFiles+0x90>
    455e:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    4560:	69 85       	ldd	r22, Y+9	; 0x09
    4562:	7a 85       	ldd	r23, Y+10	; 0x0a
    4564:	8b 85       	ldd	r24, Y+11	; 0x0b
    4566:	9c 85       	ldd	r25, Y+12	; 0x0c
    4568:	40 e0       	ldi	r20, 0x00	; 0
    456a:	00 e0       	ldi	r16, 0x00	; 0
    456c:	10 e0       	ldi	r17, 0x00	; 0
    456e:	98 01       	movw	r18, r16
    4570:	0e 94 5a 1d 	call	0x3ab4	; 0x3ab4 <getSetNextCluster>
    4574:	69 87       	std	Y+9, r22	; 0x09
    4576:	7a 87       	std	Y+10, r23	; 0x0a
    4578:	8b 87       	std	Y+11, r24	; 0x0b
    457a:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    457c:	67 3f       	cpi	r22, 0xF7	; 247
    457e:	ef ef       	ldi	r30, 0xFF	; 255
    4580:	7e 07       	cpc	r23, r30
    4582:	ef ef       	ldi	r30, 0xFF	; 255
    4584:	8e 07       	cpc	r24, r30
    4586:	ef e0       	ldi	r30, 0x0F	; 15
    4588:	9e 07       	cpc	r25, r30
    458a:	a8 f4       	brcc	.+42     	; 0x45b6 <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    458c:	61 15       	cp	r22, r1
    458e:	71 05       	cpc	r23, r1
    4590:	81 05       	cpc	r24, r1
    4592:	91 05       	cpc	r25, r1
    4594:	09 f0       	breq	.+2      	; 0x4598 <findFiles+0x2e6>
    4596:	c0 ce       	rjmp	.-640    	; 0x4318 <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    4598:	00 e0       	ldi	r16, 0x00	; 0
    459a:	10 e0       	ldi	r17, 0x00	; 0
    459c:	0e c0       	rjmp	.+28     	; 0x45ba <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    459e:	00 e0       	ldi	r16, 0x00	; 0
    45a0:	10 e0       	ldi	r17, 0x00	; 0
    45a2:	0b c0       	rjmp	.+22     	; 0x45ba <findFiles+0x308>
    45a4:	00 e0       	ldi	r16, 0x00	; 0
    45a6:	10 e0       	ldi	r17, 0x00	; 0
    45a8:	08 c0       	rjmp	.+16     	; 0x45ba <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    45aa:	00 e0       	ldi	r16, 0x00	; 0
    45ac:	10 e0       	ldi	r17, 0x00	; 0
    45ae:	05 c0       	rjmp	.+10     	; 0x45ba <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    45b0:	00 e0       	ldi	r16, 0x00	; 0
    45b2:	10 e0       	ldi	r17, 0x00	; 0
    45b4:	02 c0       	rjmp	.+4      	; 0x45ba <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    45b6:	00 e0       	ldi	r16, 0x00	; 0
    45b8:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    45ba:	80 2f       	mov	r24, r16
    45bc:	91 2f       	mov	r25, r17
    45be:	2c 96       	adiw	r28, 0x0c	; 12
    45c0:	cd bf       	out	0x3d, r28	; 61
    45c2:	de bf       	out	0x3e, r29	; 62
    45c4:	df 91       	pop	r29
    45c6:	cf 91       	pop	r28
    45c8:	1f 91       	pop	r17
    45ca:	0f 91       	pop	r16
    45cc:	ff 90       	pop	r15
    45ce:	ef 90       	pop	r14
    45d0:	df 90       	pop	r13
    45d2:	cf 90       	pop	r12
    45d4:	bf 90       	pop	r11
    45d6:	af 90       	pop	r10
    45d8:	9f 90       	pop	r9
    45da:	8f 90       	pop	r8
    45dc:	7f 90       	pop	r7
    45de:	6f 90       	pop	r6
    45e0:	5f 90       	pop	r5
    45e2:	4f 90       	pop	r4
    45e4:	3f 90       	pop	r3
    45e6:	2f 90       	pop	r2
    45e8:	08 95       	ret

000045ea <deleteFile>:
//********************************************************************
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
    45ea:	0e 94 79 1f 	call	0x3ef2	; 0x3ef2 <convertFileName>
  if(error) return;
    45ee:	88 23       	and	r24, r24
    45f0:	29 f4       	brne	.+10     	; 0x45fc <deleteFile+0x12>

  findFiles (DELETE, Filename);
    45f2:	82 e0       	ldi	r24, 0x02	; 2
    45f4:	6f e8       	ldi	r22, 0x8F	; 143
    45f6:	70 e5       	ldi	r23, 0x50	; 80
    45f8:	0e 94 59 21 	call	0x42b2	; 0x42b2 <findFiles>
    45fc:	08 95       	ret

000045fe <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    45fe:	4f 92       	push	r4
    4600:	5f 92       	push	r5
    4602:	6f 92       	push	r6
    4604:	7f 92       	push	r7
    4606:	af 92       	push	r10
    4608:	bf 92       	push	r11
    460a:	cf 92       	push	r12
    460c:	df 92       	push	r13
    460e:	ef 92       	push	r14
    4610:	ff 92       	push	r15
    4612:	0f 93       	push	r16
    4614:	1f 93       	push	r17
    4616:	cf 93       	push	r28
    4618:	c8 2f       	mov	r28, r24
    461a:	cb 01       	movw	r24, r22
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    461c:	0e 94 79 1f 	call	0x3ef2	; 0x3ef2 <convertFileName>
if(error) return 2;
    4620:	88 23       	and	r24, r24
    4622:	09 f0       	breq	.+2      	; 0x4626 <readFile+0x28>
    4624:	57 c0       	rjmp	.+174    	; 0x46d4 <readFile+0xd6>

dir = findFiles (GET_FILE, Filename); //get the file location
    4626:	81 e0       	ldi	r24, 0x01	; 1
    4628:	6f e8       	ldi	r22, 0x8F	; 143
    462a:	70 e5       	ldi	r23, 0x50	; 80
    462c:	0e 94 59 21 	call	0x42b2	; 0x42b2 <findFiles>
    4630:	fc 01       	movw	r30, r24
if(dir == 0) 
    4632:	00 97       	sbiw	r24, 0x00	; 0
    4634:	31 f4       	brne	.+12     	; 0x4642 <readFile+0x44>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4636:	81 e0       	ldi	r24, 0x01	; 1
    4638:	cc 23       	and	r28, r28
    463a:	09 f4       	brne	.+2      	; 0x463e <readFile+0x40>
    463c:	4e c0       	rjmp	.+156    	; 0x46da <readFile+0xdc>
    463e:	80 e0       	ldi	r24, 0x00	; 0
    4640:	4c c0       	rjmp	.+152    	; 0x46da <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4642:	c1 30       	cpi	r28, 0x01	; 1
    4644:	09 f4       	brne	.+2      	; 0x4648 <readFile+0x4a>
    4646:	48 c0       	rjmp	.+144    	; 0x46d8 <readFile+0xda>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4648:	44 88       	ldd	r4, Z+20	; 0x14
    464a:	55 88       	ldd	r5, Z+21	; 0x15
    464c:	66 24       	eor	r6, r6
    464e:	77 24       	eor	r7, r7
    4650:	32 01       	movw	r6, r4
    4652:	55 24       	eor	r5, r5
    4654:	44 24       	eor	r4, r4
    4656:	82 8d       	ldd	r24, Z+26	; 0x1a
    4658:	93 8d       	ldd	r25, Z+27	; 0x1b
    465a:	a0 e0       	ldi	r26, 0x00	; 0
    465c:	b0 e0       	ldi	r27, 0x00	; 0
    465e:	48 2a       	or	r4, r24
    4660:	59 2a       	or	r5, r25
    4662:	6a 2a       	or	r6, r26
    4664:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4666:	0f 2e       	mov	r0, r31
    4668:	fc ea       	ldi	r31, 0xAC	; 172
    466a:	af 2e       	mov	r10, r31
    466c:	f1 e2       	ldi	r31, 0x21	; 33
    466e:	bf 2e       	mov	r11, r31
    4670:	f0 2d       	mov	r31, r0
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    4672:	c3 01       	movw	r24, r6
    4674:	b2 01       	movw	r22, r4
    4676:	0e 94 33 1d 	call	0x3a66	; 0x3a66 <getFirstSector>
    467a:	6b 01       	movw	r12, r22
    467c:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    467e:	80 91 67 50 	lds	r24, 0x5067
    4682:	90 91 68 50 	lds	r25, 0x5068
    4686:	00 97       	sbiw	r24, 0x00	; 0
    4688:	a1 f0       	breq	.+40     	; 0x46b2 <readFile+0xb4>
    468a:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    468c:	c7 01       	movw	r24, r14
    468e:	b6 01       	movw	r22, r12
    4690:	6c 0f       	add	r22, r28
    4692:	71 1d       	adc	r23, r1
    4694:	81 1d       	adc	r24, r1
    4696:	91 1d       	adc	r25, r1
    4698:	a5 01       	movw	r20, r10
    469a:	0e 94 39 28 	call	0x5072	; 0x5072 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    469e:	cf 5f       	subi	r28, 0xFF	; 255
    46a0:	80 91 67 50 	lds	r24, 0x5067
    46a4:	90 91 68 50 	lds	r25, 0x5068
    46a8:	2c 2f       	mov	r18, r28
    46aa:	30 e0       	ldi	r19, 0x00	; 0
    46ac:	28 17       	cp	r18, r24
    46ae:	39 07       	cpc	r19, r25
    46b0:	68 f3       	brcs	.-38     	; 0x468c <readFile+0x8e>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    46b2:	c3 01       	movw	r24, r6
    46b4:	b2 01       	movw	r22, r4
    46b6:	40 e0       	ldi	r20, 0x00	; 0
    46b8:	00 e0       	ldi	r16, 0x00	; 0
    46ba:	10 e0       	ldi	r17, 0x00	; 0
    46bc:	98 01       	movw	r18, r16
    46be:	0e 94 5a 1d 	call	0x3ab4	; 0x3ab4 <getSetNextCluster>
    46c2:	2b 01       	movw	r4, r22
    46c4:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    46c6:	61 15       	cp	r22, r1
    46c8:	71 05       	cpc	r23, r1
    46ca:	81 05       	cpc	r24, r1
    46cc:	91 05       	cpc	r25, r1
    46ce:	89 f6       	brne	.-94     	; 0x4672 <readFile+0x74>
	  return 0;}
    46d0:	80 e0       	ldi	r24, 0x00	; 0
    46d2:	03 c0       	rjmp	.+6      	; 0x46da <readFile+0xdc>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    46d4:	82 e0       	ldi	r24, 0x02	; 2
    46d6:	01 c0       	rjmp	.+2      	; 0x46da <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    46d8:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    46da:	cf 91       	pop	r28
    46dc:	1f 91       	pop	r17
    46de:	0f 91       	pop	r16
    46e0:	ff 90       	pop	r15
    46e2:	ef 90       	pop	r14
    46e4:	df 90       	pop	r13
    46e6:	cf 90       	pop	r12
    46e8:	bf 90       	pop	r11
    46ea:	af 90       	pop	r10
    46ec:	7f 90       	pop	r7
    46ee:	6f 90       	pop	r6
    46f0:	5f 90       	pop	r5
    46f2:	4f 90       	pop	r4
    46f4:	08 95       	ret

000046f6 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    46f6:	2f 92       	push	r2
    46f8:	3f 92       	push	r3
    46fa:	4f 92       	push	r4
    46fc:	5f 92       	push	r5
    46fe:	6f 92       	push	r6
    4700:	7f 92       	push	r7
    4702:	8f 92       	push	r8
    4704:	9f 92       	push	r9
    4706:	af 92       	push	r10
    4708:	bf 92       	push	r11
    470a:	cf 92       	push	r12
    470c:	df 92       	push	r13
    470e:	ef 92       	push	r14
    4710:	ff 92       	push	r15
    4712:	0f 93       	push	r16
    4714:	1f 93       	push	r17
    4716:	cf 93       	push	r28
    4718:	df 93       	push	r29
    471a:	cd b7       	in	r28, 0x3d	; 61
    471c:	de b7       	in	r29, 0x3e	; 62
    471e:	60 97       	sbiw	r28, 0x10	; 16
    4720:	cd bf       	out	0x3d, r28	; 61
    4722:	de bf       	out	0x3e, r29	; 62
    4724:	fc 01       	movw	r30, r24
    4726:	6d 83       	std	Y+5, r22	; 0x05
    4728:	7e 83       	std	Y+6, r23	; 0x06
    472a:	49 01       	movw	r8, r18
    472c:	5a 01       	movw	r10, r20
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    472e:	81 e0       	ldi	r24, 0x01	; 1
    4730:	bf 01       	movw	r22, r30
    4732:	0e 94 ff 22 	call	0x45fe	; 0x45fe <readFile>

if(j == 1) 
    4736:	81 30       	cpi	r24, 0x01	; 1
    4738:	09 f0       	breq	.+2      	; 0x473c <writeFile+0x46>
    473a:	7b c0       	rjmp	.+246    	; 0x4832 <writeFile+0x13c>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    473c:	00 91 71 50 	lds	r16, 0x5071
    4740:	10 91 72 50 	lds	r17, 0x5072
    4744:	20 91 73 50 	lds	r18, 0x5073
    4748:	30 91 74 50 	lds	r19, 0x5074
    474c:	09 83       	std	Y+1, r16	; 0x01
    474e:	1a 83       	std	Y+2, r17	; 0x02
    4750:	2b 83       	std	Y+3, r18	; 0x03
    4752:	3c 83       	std	Y+4, r19	; 0x04
  clusterCount=0;
    4754:	cc 24       	eor	r12, r12
    4756:	dd 24       	eor	r13, r13
    4758:	76 01       	movw	r14, r12
    475a:	24 01       	movw	r4, r8
    475c:	35 01       	movw	r6, r10
    475e:	48 01       	movw	r8, r16
    4760:	59 01       	movw	r10, r18
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    4762:	c5 01       	movw	r24, r10
    4764:	b4 01       	movw	r22, r8
    4766:	40 e0       	ldi	r20, 0x00	; 0
    4768:	00 e0       	ldi	r16, 0x00	; 0
    476a:	10 e0       	ldi	r17, 0x00	; 0
    476c:	98 01       	movw	r18, r16
    476e:	0e 94 5a 1d 	call	0x3ab4	; 0x3ab4 <getSetNextCluster>
    4772:	dc 01       	movw	r26, r24
    4774:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    4776:	8f 3f       	cpi	r24, 0xFF	; 255
    4778:	1f ef       	ldi	r17, 0xFF	; 255
    477a:	91 07       	cpc	r25, r17
    477c:	1f ef       	ldi	r17, 0xFF	; 255
    477e:	a1 07       	cpc	r26, r17
    4780:	1f ef       	ldi	r17, 0xFF	; 255
    4782:	b1 07       	cpc	r27, r17
    4784:	41 f0       	breq	.+16     	; 0x4796 <writeFile+0xa0>
	cluster = nextCluster;
	clusterCount++;
    4786:	08 94       	sec
    4788:	c1 1c       	adc	r12, r1
    478a:	d1 1c       	adc	r13, r1
    478c:	e1 1c       	adc	r14, r1
    478e:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    4790:	4c 01       	movw	r8, r24
    4792:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    4794:	e6 cf       	rjmp	.-52     	; 0x4762 <writeFile+0x6c>
    4796:	89 82       	std	Y+1, r8	; 0x01
    4798:	9a 82       	std	Y+2, r9	; 0x02
    479a:	ab 82       	std	Y+3, r10	; 0x03
    479c:	bc 82       	std	Y+4, r11	; 0x04
    479e:	53 01       	movw	r10, r6
    47a0:	42 01       	movw	r8, r4
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    47a2:	20 91 67 50 	lds	r18, 0x5067
    47a6:	30 91 68 50 	lds	r19, 0x5068
    47aa:	80 91 53 40 	lds	r24, 0x4053
    47ae:	90 91 54 40 	lds	r25, 0x4054
    47b2:	60 90 53 40 	lds	r6, 0x4053
    47b6:	70 90 54 40 	lds	r7, 0x4054
    47ba:	bc 01       	movw	r22, r24
    47bc:	80 e0       	ldi	r24, 0x00	; 0
    47be:	90 e0       	ldi	r25, 0x00	; 0
    47c0:	40 e0       	ldi	r20, 0x00	; 0
    47c2:	50 e0       	ldi	r21, 0x00	; 0
    47c4:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    47c8:	a7 01       	movw	r20, r14
    47ca:	96 01       	movw	r18, r12
    47cc:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    47d0:	dc 01       	movw	r26, r24
    47d2:	cb 01       	movw	r24, r22
    47d4:	40 91 4f 40 	lds	r20, 0x404F
    47d8:	50 91 50 40 	lds	r21, 0x4050
    47dc:	60 91 51 40 	lds	r22, 0x4051
    47e0:	70 91 52 40 	lds	r23, 0x4052
    47e4:	8a 01       	movw	r16, r20
    47e6:	9b 01       	movw	r18, r22
    47e8:	08 1b       	sub	r16, r24
    47ea:	19 0b       	sbc	r17, r25
    47ec:	2a 0b       	sbc	r18, r26
    47ee:	3b 0b       	sbc	r19, r27
    47f0:	c9 01       	movw	r24, r18
    47f2:	b8 01       	movw	r22, r16
    47f4:	93 01       	movw	r18, r6
    47f6:	40 e0       	ldi	r20, 0x00	; 0
    47f8:	50 e0       	ldi	r21, 0x00	; 0
    47fa:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    47fe:	02 2f       	mov	r16, r18

//start writing data here

if(start){
  start = 0;
  startBlock = getFirstSector (cluster) + sector;
    4800:	69 81       	ldd	r22, Y+1	; 0x01
    4802:	7a 81       	ldd	r23, Y+2	; 0x02
    4804:	8b 81       	ldd	r24, Y+3	; 0x03
    4806:	9c 81       	ldd	r25, Y+4	; 0x04
    4808:	0e 94 33 1d 	call	0x3a66	; 0x3a66 <getFirstSector>
    480c:	dc 01       	movw	r26, r24
    480e:	cb 01       	movw	r24, r22
    4810:	20 2e       	mov	r2, r16
    4812:	33 24       	eor	r3, r3
    4814:	28 0e       	add	r2, r24
    4816:	39 1e       	adc	r3, r25
  SD_read_block (startBlock,SDBuffer);
    4818:	b1 01       	movw	r22, r2
    481a:	80 e0       	ldi	r24, 0x00	; 0
    481c:	90 e0       	ldi	r25, 0x00	; 0
    481e:	47 e4       	ldi	r20, 0x47	; 71
    4820:	5e e3       	ldi	r21, 0x3E	; 62
    4822:	0e 94 39 28 	call	0x5072	; 0x5072 <SD_read_block>
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    4826:	1f 86       	std	Y+15, r1	; 0x0f
    4828:	18 8a       	std	Y+16, r1	; 0x10
    482a:	19 86       	std	Y+9, r1	; 0x09
    482c:	1a 86       	std	Y+10, r1	; 0x0a
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    482e:	11 e0       	ldi	r17, 0x01	; 1
    4830:	4c c0       	rjmp	.+152    	; 0x48ca <writeFile+0x1d4>
}
else if(j == 2) 
    4832:	82 30       	cpi	r24, 0x02	; 2
    4834:	09 f4       	brne	.+2      	; 0x4838 <writeFile+0x142>
    4836:	0c c2       	rjmp	.+1048   	; 0x4c50 <writeFile+0x55a>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    4838:	82 e0       	ldi	r24, 0x02	; 2
    483a:	60 e0       	ldi	r22, 0x00	; 0
    483c:	20 e0       	ldi	r18, 0x00	; 0
    483e:	30 e0       	ldi	r19, 0x00	; 0
    4840:	a9 01       	movw	r20, r18
    4842:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <getSetFreeCluster>
  if(cluster > totalClusters)
    4846:	00 91 56 40 	lds	r16, 0x4056
    484a:	10 91 57 40 	lds	r17, 0x4057
    484e:	20 91 58 40 	lds	r18, 0x4058
    4852:	30 91 59 40 	lds	r19, 0x4059
    4856:	06 17       	cp	r16, r22
    4858:	17 07       	cpc	r17, r23
    485a:	28 07       	cpc	r18, r24
    485c:	39 07       	cpc	r19, r25
    485e:	40 f4       	brcc	.+16     	; 0x4870 <writeFile+0x17a>
     cluster = rootCluster;
    4860:	60 91 5b 40 	lds	r22, 0x405B
    4864:	70 91 5c 40 	lds	r23, 0x405C
    4868:	80 91 5d 40 	lds	r24, 0x405D
    486c:	90 91 5e 40 	lds	r25, 0x405E

  cluster = searchNextFreeCluster(cluster);
    4870:	0e 94 38 20 	call	0x4070	; 0x4070 <searchNextFreeCluster>
    4874:	69 83       	std	Y+1, r22	; 0x01
    4876:	7a 83       	std	Y+2, r23	; 0x02
    4878:	8b 83       	std	Y+3, r24	; 0x03
    487a:	9c 83       	std	Y+4, r25	; 0x04
   if(cluster == 0)
    487c:	61 15       	cp	r22, r1
    487e:	71 05       	cpc	r23, r1
    4880:	81 05       	cpc	r24, r1
    4882:	91 05       	cpc	r25, r1
    4884:	09 f4       	brne	.+2      	; 0x4888 <writeFile+0x192>
    4886:	e6 c1       	rjmp	.+972    	; 0x4c54 <writeFile+0x55e>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    4888:	41 e0       	ldi	r20, 0x01	; 1
    488a:	0f ef       	ldi	r16, 0xFF	; 255
    488c:	1f ef       	ldi	r17, 0xFF	; 255
    488e:	98 01       	movw	r18, r16
    4890:	0e 94 5a 1d 	call	0x3ab4	; 0x3ab4 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    4894:	2b 81       	ldd	r18, Y+3	; 0x03
    4896:	3c 81       	ldd	r19, Y+4	; 0x04
    4898:	29 87       	std	Y+9, r18	; 0x09
    489a:	3a 87       	std	Y+10, r19	; 0x0a
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    489c:	89 81       	ldd	r24, Y+1	; 0x01
    489e:	9a 81       	ldd	r25, Y+2	; 0x02
    48a0:	8f 87       	std	Y+15, r24	; 0x0f
    48a2:	98 8b       	std	Y+16, r25	; 0x10
  fileSize = 0;
    48a4:	10 92 4f 40 	sts	0x404F, r1
    48a8:	10 92 50 40 	sts	0x4050, r1
    48ac:	10 92 51 40 	sts	0x4051, r1
    48b0:	10 92 52 40 	sts	0x4052, r1
  startBlock = getFirstSector (cluster) + sector;
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
    48b4:	69 81       	ldd	r22, Y+1	; 0x01
    48b6:	7a 81       	ldd	r23, Y+2	; 0x02
    48b8:	8b 81       	ldd	r24, Y+3	; 0x03
    48ba:	9c 81       	ldd	r25, Y+4	; 0x04
    48bc:	0e 94 33 1d 	call	0x3a66	; 0x3a66 <getFirstSector>
    48c0:	dc 01       	movw	r26, r24
    48c2:	cb 01       	movw	r24, r22
    48c4:	1c 01       	movw	r2, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    48c6:	10 e0       	ldi	r17, 0x00	; 0
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
  j=0;
    48c8:	00 e0       	ldi	r16, 0x00	; 0
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    48ca:	81 14       	cp	r8, r1
    48cc:	91 04       	cpc	r9, r1
    48ce:	a1 04       	cpc	r10, r1
    48d0:	b1 04       	cpc	r11, r1
    48d2:	09 f4       	brne	.+2      	; 0x48d6 <writeFile+0x1e0>
    48d4:	8d c0       	rjmp	.+282    	; 0x49f0 <writeFile+0x2fa>
    48d6:	44 24       	eor	r4, r4
    48d8:	55 24       	eor	r5, r5
    48da:	32 01       	movw	r6, r4
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
		 writtenData += 512;
		 dataToWrite = 512;
    48dc:	c0 2e       	mov	r12, r16
    48de:	1b 87       	std	Y+11, r17	; 0x0b
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    48e0:	90 e0       	ldi	r25, 0x00	; 0
    48e2:	89 16       	cp	r8, r25
    48e4:	92 e0       	ldi	r25, 0x02	; 2
    48e6:	99 06       	cpc	r9, r25
    48e8:	90 e0       	ldi	r25, 0x00	; 0
    48ea:	a9 06       	cpc	r10, r25
    48ec:	90 e0       	ldi	r25, 0x00	; 0
    48ee:	b9 06       	cpc	r11, r25
    48f0:	88 f0       	brcs	.+34     	; 0x4914 <writeFile+0x21e>
		 writtenData += 512;
    48f2:	00 e0       	ldi	r16, 0x00	; 0
    48f4:	12 e0       	ldi	r17, 0x02	; 2
    48f6:	20 e0       	ldi	r18, 0x00	; 0
    48f8:	30 e0       	ldi	r19, 0x00	; 0
    48fa:	40 0e       	add	r4, r16
    48fc:	51 1e       	adc	r5, r17
    48fe:	62 1e       	adc	r6, r18
    4900:	73 1e       	adc	r7, r19
		 dataToWrite = 512;
		 lengthOfData -= 512;
    4902:	80 e0       	ldi	r24, 0x00	; 0
    4904:	9e ef       	ldi	r25, 0xFE	; 254
    4906:	af ef       	ldi	r26, 0xFF	; 255
    4908:	bf ef       	ldi	r27, 0xFF	; 255
    490a:	88 0e       	add	r8, r24
    490c:	99 1e       	adc	r9, r25
    490e:	aa 1e       	adc	r10, r26
    4910:	bb 1e       	adc	r11, r27
    4912:	0c c0       	rjmp	.+24     	; 0x492c <writeFile+0x236>
	}
	else{
		writtenData += lengthOfData;
    4914:	48 0c       	add	r4, r8
    4916:	59 1c       	adc	r5, r9
    4918:	6a 1c       	adc	r6, r10
    491a:	7b 1c       	adc	r7, r11
		dataToWrite = lengthOfData%512;
    491c:	95 01       	movw	r18, r10
    491e:	84 01       	movw	r16, r8
    4920:	11 70       	andi	r17, 0x01	; 1
    4922:	20 70       	andi	r18, 0x00	; 0
    4924:	30 70       	andi	r19, 0x00	; 0
		lengthOfData = 0;
    4926:	88 24       	eor	r8, r8
    4928:	99 24       	eor	r9, r9
    492a:	54 01       	movw	r10, r8
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    492c:	80 91 4f 40 	lds	r24, 0x404F
    4930:	90 91 50 40 	lds	r25, 0x4050
    4934:	a0 91 51 40 	lds	r26, 0x4051
    4938:	b0 91 52 40 	lds	r27, 0x4052
    493c:	80 50       	subi	r24, 0x00	; 0
    493e:	9e 4f       	sbci	r25, 0xFE	; 254
    4940:	af 4f       	sbci	r26, 0xFF	; 255
    4942:	bf 4f       	sbci	r27, 0xFF	; 255
    4944:	80 93 4f 40 	sts	0x404F, r24
    4948:	90 93 50 40 	sts	0x4050, r25
    494c:	a0 93 51 40 	sts	0x4051, r26
    4950:	b0 93 52 40 	sts	0x4052, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    4954:	b1 01       	movw	r22, r2
    4956:	80 e0       	ldi	r24, 0x00	; 0
    4958:	90 e0       	ldi	r25, 0x00	; 0
    495a:	a2 01       	movw	r20, r4
    495c:	40 1b       	sub	r20, r16
    495e:	51 0b       	sbc	r21, r17
    4960:	ad 81       	ldd	r26, Y+5	; 0x05
    4962:	be 81       	ldd	r27, Y+6	; 0x06
    4964:	4a 0f       	add	r20, r26
    4966:	5b 1f       	adc	r21, r27
    4968:	98 01       	movw	r18, r16
    496a:	0e 94 84 27 	call	0x4f08	; 0x4f08 <SD_write_block>
	j++;
    496e:	c3 94       	inc	r12
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    4970:	20 91 67 50 	lds	r18, 0x5067
    4974:	30 91 68 50 	lds	r19, 0x5068
    4978:	8c 2d       	mov	r24, r12
    497a:	90 e0       	ldi	r25, 0x00	; 0
    497c:	82 17       	cp	r24, r18
    497e:	93 07       	cpc	r25, r19
    4980:	29 f5       	brne	.+74     	; 0x49cc <writeFile+0x2d6>
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    4982:	69 81       	ldd	r22, Y+1	; 0x01
    4984:	7a 81       	ldd	r23, Y+2	; 0x02
    4986:	8b 81       	ldd	r24, Y+3	; 0x03
    4988:	9c 81       	ldd	r25, Y+4	; 0x04
    498a:	0e 94 38 20 	call	0x4070	; 0x4070 <searchNextFreeCluster>
    498e:	6b 01       	movw	r12, r22
    4990:	7c 01       	movw	r14, r24
		if(cluster == 0){
    4992:	61 15       	cp	r22, r1
    4994:	71 05       	cpc	r23, r1
    4996:	81 05       	cpc	r24, r1
    4998:	91 05       	cpc	r25, r1
    499a:	09 f4       	brne	.+2      	; 0x499e <writeFile+0x2a8>
    499c:	5d c1       	rjmp	.+698    	; 0x4c58 <writeFile+0x562>
		  //No free cluster!
		  return 2;
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    499e:	69 81       	ldd	r22, Y+1	; 0x01
    49a0:	7a 81       	ldd	r23, Y+2	; 0x02
    49a2:	8b 81       	ldd	r24, Y+3	; 0x03
    49a4:	9c 81       	ldd	r25, Y+4	; 0x04
    49a6:	41 e0       	ldi	r20, 0x01	; 1
    49a8:	97 01       	movw	r18, r14
    49aa:	86 01       	movw	r16, r12
    49ac:	0e 94 5a 1d 	call	0x3ab4	; 0x3ab4 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    49b0:	c7 01       	movw	r24, r14
    49b2:	b6 01       	movw	r22, r12
    49b4:	41 e0       	ldi	r20, 0x01	; 1
    49b6:	0f ef       	ldi	r16, 0xFF	; 255
    49b8:	1f ef       	ldi	r17, 0xFF	; 255
    49ba:	98 01       	movw	r18, r16
    49bc:	0e 94 5a 1d 	call	0x3ab4	; 0x3ab4 <getSetNextCluster>
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    49c0:	c9 82       	std	Y+1, r12	; 0x01
    49c2:	da 82       	std	Y+2, r13	; 0x02
    49c4:	eb 82       	std	Y+3, r14	; 0x03
    49c6:	fc 82       	std	Y+4, r15	; 0x04
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
	j++;
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
    49c8:	cc 24       	eor	r12, r12
    49ca:	03 c0       	rjmp	.+6      	; 0x49d2 <writeFile+0x2dc>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    49cc:	08 94       	sec
    49ce:	21 1c       	adc	r2, r1
    49d0:	31 1c       	adc	r3, r1
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    49d2:	82 e0       	ldi	r24, 0x02	; 2
    49d4:	61 e0       	ldi	r22, 0x01	; 1
    49d6:	29 81       	ldd	r18, Y+1	; 0x01
    49d8:	3a 81       	ldd	r19, Y+2	; 0x02
    49da:	4b 81       	ldd	r20, Y+3	; 0x03
    49dc:	5c 81       	ldd	r21, Y+4	; 0x04
    49de:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    49e2:	81 14       	cp	r8, r1
    49e4:	91 04       	cpc	r9, r1
    49e6:	a1 04       	cpc	r10, r1
    49e8:	b1 04       	cpc	r11, r1
    49ea:	09 f0       	breq	.+2      	; 0x49ee <writeFile+0x2f8>
    49ec:	79 cf       	rjmp	.-270    	; 0x48e0 <writeFile+0x1ea>
    49ee:	1b 85       	ldd	r17, Y+11	; 0x0b
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    49f0:	11 23       	and	r17, r17
    49f2:	09 f4       	brne	.+2      	; 0x49f6 <writeFile+0x300>
    49f4:	3f c0       	rjmp	.+126    	; 0x4a74 <writeFile+0x37e>
{
  SD_read_block (appendFileSector,SDBuffer);    
    49f6:	60 91 a0 50 	lds	r22, 0x50A0
    49fa:	70 91 a1 50 	lds	r23, 0x50A1
    49fe:	80 91 a2 50 	lds	r24, 0x50A2
    4a02:	90 91 a3 50 	lds	r25, 0x50A3
    4a06:	07 e4       	ldi	r16, 0x47	; 71
    4a08:	1e e3       	ldi	r17, 0x3E	; 62
    4a0a:	a8 01       	movw	r20, r16
    4a0c:	0e 94 39 28 	call	0x5072	; 0x5072 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    4a10:	e0 91 47 40 	lds	r30, 0x4047
    4a14:	f0 91 48 40 	lds	r31, 0x4048
    4a18:	e0 0f       	add	r30, r16
    4a1a:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    4a1c:	12 8a       	std	Z+18, r1	; 0x12
    4a1e:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    4a20:	80 91 4f 40 	lds	r24, 0x404F
    4a24:	90 91 50 40 	lds	r25, 0x4050
    4a28:	a0 91 51 40 	lds	r26, 0x4051
    4a2c:	b0 91 52 40 	lds	r27, 0x4052
    4a30:	44 8d       	ldd	r20, Z+28	; 0x1c
    4a32:	55 8d       	ldd	r21, Z+29	; 0x1d
    4a34:	66 8d       	ldd	r22, Z+30	; 0x1e
    4a36:	77 8d       	ldd	r23, Z+31	; 0x1f
    4a38:	6c 01       	movw	r12, r24
    4a3a:	7d 01       	movw	r14, r26
    4a3c:	c4 1a       	sub	r12, r20
    4a3e:	d5 0a       	sbc	r13, r21
    4a40:	e6 0a       	sbc	r14, r22
    4a42:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    4a44:	84 8f       	std	Z+28, r24	; 0x1c
    4a46:	95 8f       	std	Z+29, r25	; 0x1d
    4a48:	a6 8f       	std	Z+30, r26	; 0x1e
    4a4a:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    4a4c:	60 91 a0 50 	lds	r22, 0x50A0
    4a50:	70 91 a1 50 	lds	r23, 0x50A1
    4a54:	80 91 a2 50 	lds	r24, 0x50A2
    4a58:	90 91 a3 50 	lds	r25, 0x50A3
    4a5c:	a8 01       	movw	r20, r16
    4a5e:	20 e0       	ldi	r18, 0x00	; 0
    4a60:	32 e0       	ldi	r19, 0x02	; 2
    4a62:	0e 94 84 27 	call	0x4f08	; 0x4f08 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    4a66:	81 e0       	ldi	r24, 0x01	; 1
    4a68:	b7 01       	movw	r22, r14
    4a6a:	a6 01       	movw	r20, r12
    4a6c:	0e 94 eb 20 	call	0x41d6	; 0x41d6 <freeMemoryUpdate>

 //File appended!
  return 0;
    4a70:	80 e0       	ldi	r24, 0x00	; 0
    4a72:	f9 c0       	rjmp	.+498    	; 0x4c66 <writeFile+0x570>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    4a74:	00 91 5b 40 	lds	r16, 0x405B
    4a78:	10 91 5c 40 	lds	r17, 0x405C
    4a7c:	20 91 5d 40 	lds	r18, 0x405D
    4a80:	30 91 5e 40 	lds	r19, 0x405E
    4a84:	0b 87       	std	Y+11, r16	; 0x0b
    4a86:	1c 87       	std	Y+12, r17	; 0x0c
    4a88:	2d 87       	std	Y+13, r18	; 0x0d
    4a8a:	3e 87       	std	Y+14, r19	; 0x0e
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4a8c:	77 24       	eor	r7, r7
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4a8e:	8f e8       	ldi	r24, 0x8F	; 143
    4a90:	90 e5       	ldi	r25, 0x50	; 80
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4a92:	0f 2e       	mov	r0, r31
    4a94:	fb e0       	ldi	r31, 0x0B	; 11
    4a96:	af 2e       	mov	r10, r31
    4a98:	bb 24       	eor	r11, r11
    4a9a:	f0 2d       	mov	r31, r0
    4a9c:	a8 0e       	add	r10, r24
    4a9e:	b9 1e       	adc	r11, r25

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    4aa0:	88 24       	eor	r8, r8
    4aa2:	68 94       	set
    4aa4:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4aa6:	0f 2e       	mov	r0, r31
    4aa8:	f7 e4       	ldi	r31, 0x47	; 71
    4aaa:	4f 2e       	mov	r4, r31
    4aac:	fe e3       	ldi	r31, 0x3E	; 62
    4aae:	5f 2e       	mov	r5, r31
    4ab0:	f0 2d       	mov	r31, r0
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4ab2:	28 2e       	mov	r2, r24
    4ab4:	99 2e       	mov	r9, r25
    4ab6:	37 2c       	mov	r3, r7
    4ab8:	6f 84       	ldd	r6, Y+15	; 0x0f
    4aba:	78 88       	ldd	r7, Y+16	; 0x10
    4abc:	04 c0       	rjmp	.+8      	; 0x4ac6 <writeFile+0x3d0>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    4abe:	cb 86       	std	Y+11, r12	; 0x0b
    4ac0:	dc 86       	std	Y+12, r13	; 0x0c
    4ac2:	ed 86       	std	Y+13, r14	; 0x0d
    4ac4:	fe 86       	std	Y+14, r15	; 0x0e

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    4ac6:	6b 85       	ldd	r22, Y+11	; 0x0b
    4ac8:	7c 85       	ldd	r23, Y+12	; 0x0c
    4aca:	8d 85       	ldd	r24, Y+13	; 0x0d
    4acc:	9e 85       	ldd	r25, Y+14	; 0x0e
    4ace:	0e 94 33 1d 	call	0x3a66	; 0x3a66 <getFirstSector>
    4ad2:	6d 83       	std	Y+5, r22	; 0x05
    4ad4:	7e 83       	std	Y+6, r23	; 0x06
    4ad6:	8f 83       	std	Y+7, r24	; 0x07
    4ad8:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    4ada:	80 91 67 50 	lds	r24, 0x5067
    4ade:	90 91 68 50 	lds	r25, 0x5068
    4ae2:	00 97       	sbiw	r24, 0x00	; 0
    4ae4:	09 f4       	brne	.+2      	; 0x4ae8 <writeFile+0x3f2>
    4ae6:	77 c0       	rjmp	.+238    	; 0x4bd6 <writeFile+0x4e0>
    4ae8:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4aea:	cd 80       	ldd	r12, Y+5	; 0x05
    4aec:	de 80       	ldd	r13, Y+6	; 0x06
    4aee:	ef 80       	ldd	r14, Y+7	; 0x07
    4af0:	f8 84       	ldd	r15, Y+8	; 0x08
    4af2:	19 81       	ldd	r17, Y+1	; 0x01
    4af4:	c1 0e       	add	r12, r17
    4af6:	d1 1c       	adc	r13, r1
    4af8:	e1 1c       	adc	r14, r1
    4afa:	f1 1c       	adc	r15, r1
    4afc:	c7 01       	movw	r24, r14
    4afe:	b6 01       	movw	r22, r12
    4b00:	a2 01       	movw	r20, r4
    4b02:	0e 94 39 28 	call	0x5072	; 0x5072 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    4b06:	80 91 53 40 	lds	r24, 0x4053
    4b0a:	90 91 54 40 	lds	r25, 0x4054
    4b0e:	00 97       	sbiw	r24, 0x00	; 0
    4b10:	09 f4       	brne	.+2      	; 0x4b14 <writeFile+0x41e>
    4b12:	54 c0       	rjmp	.+168    	; 0x4bbc <writeFile+0x4c6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    4b14:	33 20       	and	r3, r3
    4b16:	09 f0       	breq	.+2      	; 0x4b1a <writeFile+0x424>
    4b18:	a1 c0       	rjmp	.+322    	; 0x4c5c <writeFile+0x566>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4b1a:	a2 01       	movw	r20, r4
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    4b1c:	00 e0       	ldi	r16, 0x00	; 0
    4b1e:	10 e0       	ldi	r17, 0x00	; 0
    4b20:	06 c0       	rjmp	.+12     	; 0x4b2e <writeFile+0x438>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4b22:	a8 01       	movw	r20, r16
    4b24:	49 5b       	subi	r20, 0xB9	; 185
    4b26:	51 4c       	sbci	r21, 0xC1	; 193
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    4b28:	22 23       	and	r18, r18
    4b2a:	09 f0       	breq	.+2      	; 0x4b2e <writeFile+0x438>
    4b2c:	99 c0       	rjmp	.+306    	; 0x4c60 <writeFile+0x56a>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4b2e:	da 01       	movw	r26, r20
    4b30:	8c 91       	ld	r24, X
    4b32:	88 23       	and	r24, r24
    4b34:	21 f4       	brne	.+8      	; 0x4b3e <writeFile+0x448>
    4b36:	e2 2d       	mov	r30, r2
    4b38:	f9 2d       	mov	r31, r9
    4b3a:	da 01       	movw	r26, r20
    4b3c:	04 c0       	rjmp	.+8      	; 0x4b46 <writeFile+0x450>
    4b3e:	85 3e       	cpi	r24, 0xE5	; 229
    4b40:	d1 f3       	breq	.-12     	; 0x4b36 <writeFile+0x440>
    4b42:	23 2d       	mov	r18, r3
    4b44:	30 c0       	rjmp	.+96     	; 0x4ba6 <writeFile+0x4b0>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
    4b46:	81 91       	ld	r24, Z+
    4b48:	8d 93       	st	X+, r24
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    4b4a:	ea 15       	cp	r30, r10
    4b4c:	fb 05       	cpc	r31, r11
    4b4e:	d9 f7       	brne	.-10     	; 0x4b46 <writeFile+0x450>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    4b50:	fa 01       	movw	r30, r20
    4b52:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    4b54:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    4b56:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    4b58:	12 8a       	std	Z+18, r1	; 0x12
    4b5a:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    4b5c:	29 85       	ldd	r18, Y+9	; 0x09
    4b5e:	3a 85       	ldd	r19, Y+10	; 0x0a
    4b60:	24 8b       	std	Z+20, r18	; 0x14
    4b62:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    4b64:	62 8e       	std	Z+26, r6	; 0x1a
    4b66:	73 8e       	std	Z+27, r7	; 0x1b
		  dir->fileSize = fileSize;
    4b68:	80 91 4f 40 	lds	r24, 0x404F
    4b6c:	90 91 50 40 	lds	r25, 0x4050
    4b70:	a0 91 51 40 	lds	r26, 0x4051
    4b74:	b0 91 52 40 	lds	r27, 0x4052
    4b78:	84 8f       	std	Z+28, r24	; 0x1c
    4b7a:	95 8f       	std	Z+29, r25	; 0x1d
    4b7c:	a6 8f       	std	Z+30, r26	; 0x1e
    4b7e:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    4b80:	c7 01       	movw	r24, r14
    4b82:	b6 01       	movw	r22, r12
    4b84:	a2 01       	movw	r20, r4
    4b86:	20 e0       	ldi	r18, 0x00	; 0
    4b88:	32 e0       	ldi	r19, 0x02	; 2
    4b8a:	0e 94 84 27 	call	0x4f08	; 0x4f08 <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    4b8e:	40 91 4f 40 	lds	r20, 0x404F
    4b92:	50 91 50 40 	lds	r21, 0x4050
    4b96:	60 91 51 40 	lds	r22, 0x4051
    4b9a:	70 91 52 40 	lds	r23, 0x4052
    4b9e:	81 e0       	ldi	r24, 0x01	; 1
    4ba0:	0e 94 eb 20 	call	0x41d6	; 0x41d6 <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    4ba4:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    4ba6:	00 5e       	subi	r16, 0xE0	; 224
    4ba8:	1f 4f       	sbci	r17, 0xFF	; 255
    4baa:	80 91 53 40 	lds	r24, 0x4053
    4bae:	90 91 54 40 	lds	r25, 0x4054
    4bb2:	08 17       	cp	r16, r24
    4bb4:	19 07       	cpc	r17, r25
    4bb6:	08 f4       	brcc	.+2      	; 0x4bba <writeFile+0x4c4>
    4bb8:	b4 cf       	rjmp	.-152    	; 0x4b22 <writeFile+0x42c>
    4bba:	32 2e       	mov	r3, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    4bbc:	09 81       	ldd	r16, Y+1	; 0x01
    4bbe:	0f 5f       	subi	r16, 0xFF	; 255
    4bc0:	09 83       	std	Y+1, r16	; 0x01
    4bc2:	20 91 67 50 	lds	r18, 0x5067
    4bc6:	30 91 68 50 	lds	r19, 0x5068
    4bca:	80 2f       	mov	r24, r16
    4bcc:	90 e0       	ldi	r25, 0x00	; 0
    4bce:	82 17       	cp	r24, r18
    4bd0:	93 07       	cpc	r25, r19
    4bd2:	08 f4       	brcc	.+2      	; 0x4bd6 <writeFile+0x4e0>
    4bd4:	8a cf       	rjmp	.-236    	; 0x4aea <writeFile+0x3f4>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    4bd6:	6b 85       	ldd	r22, Y+11	; 0x0b
    4bd8:	7c 85       	ldd	r23, Y+12	; 0x0c
    4bda:	8d 85       	ldd	r24, Y+13	; 0x0d
    4bdc:	9e 85       	ldd	r25, Y+14	; 0x0e
    4bde:	40 e0       	ldi	r20, 0x00	; 0
    4be0:	00 e0       	ldi	r16, 0x00	; 0
    4be2:	10 e0       	ldi	r17, 0x00	; 0
    4be4:	98 01       	movw	r18, r16
    4be6:	0e 94 5a 1d 	call	0x3ab4	; 0x3ab4 <getSetNextCluster>
    4bea:	6b 01       	movw	r12, r22
    4bec:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    4bee:	67 3f       	cpi	r22, 0xF7	; 247
    4bf0:	1f ef       	ldi	r17, 0xFF	; 255
    4bf2:	71 07       	cpc	r23, r17
    4bf4:	1f ef       	ldi	r17, 0xFF	; 255
    4bf6:	81 07       	cpc	r24, r17
    4bf8:	1f e0       	ldi	r17, 0x0F	; 15
    4bfa:	91 07       	cpc	r25, r17
    4bfc:	08 f1       	brcs	.+66     	; 0x4c40 <writeFile+0x54a>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    4bfe:	6f 3f       	cpi	r22, 0xFF	; 255
    4c00:	2f ef       	ldi	r18, 0xFF	; 255
    4c02:	72 07       	cpc	r23, r18
    4c04:	2f ef       	ldi	r18, 0xFF	; 255
    4c06:	82 07       	cpc	r24, r18
    4c08:	2f ef       	ldi	r18, 0xFF	; 255
    4c0a:	92 07       	cpc	r25, r18
    4c0c:	59 f5       	brne	.+86     	; 0x4c64 <writeFile+0x56e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    4c0e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4c10:	7c 85       	ldd	r23, Y+12	; 0x0c
    4c12:	8d 85       	ldd	r24, Y+13	; 0x0d
    4c14:	9e 85       	ldd	r25, Y+14	; 0x0e
    4c16:	0e 94 38 20 	call	0x4070	; 0x4070 <searchNextFreeCluster>
    4c1a:	6b 01       	movw	r12, r22
    4c1c:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    4c1e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4c20:	7c 85       	ldd	r23, Y+12	; 0x0c
    4c22:	8d 85       	ldd	r24, Y+13	; 0x0d
    4c24:	9e 85       	ldd	r25, Y+14	; 0x0e
    4c26:	41 e0       	ldi	r20, 0x01	; 1
    4c28:	97 01       	movw	r18, r14
    4c2a:	86 01       	movw	r16, r12
    4c2c:	0e 94 5a 1d 	call	0x3ab4	; 0x3ab4 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    4c30:	c7 01       	movw	r24, r14
    4c32:	b6 01       	movw	r22, r12
    4c34:	41 e0       	ldi	r20, 0x01	; 1
    4c36:	0f ef       	ldi	r16, 0xFF	; 255
    4c38:	1f ef       	ldi	r17, 0xFF	; 255
    4c3a:	98 01       	movw	r18, r16
    4c3c:	0e 94 5a 1d 	call	0x3ab4	; 0x3ab4 <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    4c40:	c1 14       	cp	r12, r1
    4c42:	d1 04       	cpc	r13, r1
    4c44:	e1 04       	cpc	r14, r1
    4c46:	f1 04       	cpc	r15, r1
    4c48:	09 f0       	breq	.+2      	; 0x4c4c <writeFile+0x556>
    4c4a:	39 cf       	rjmp	.-398    	; 0x4abe <writeFile+0x3c8>
	   return 4;
    4c4c:	84 e0       	ldi	r24, 0x04	; 4
    4c4e:	0b c0       	rjmp	.+22     	; 0x4c66 <writeFile+0x570>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    4c50:	81 e0       	ldi	r24, 0x01	; 1
    4c52:	09 c0       	rjmp	.+18     	; 0x4c66 <writeFile+0x570>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    4c54:	82 e0       	ldi	r24, 0x02	; 2
    4c56:	07 c0       	rjmp	.+14     	; 0x4c66 <writeFile+0x570>
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
		if(cluster == 0){
		  //No free cluster!
		  return 2;
    4c58:	82 e0       	ldi	r24, 0x02	; 2
    4c5a:	05 c0       	rjmp	.+10     	; 0x4c66 <writeFile+0x570>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    4c5c:	80 e0       	ldi	r24, 0x00	; 0
    4c5e:	03 c0       	rjmp	.+6      	; 0x4c66 <writeFile+0x570>
    4c60:	80 e0       	ldi	r24, 0x00	; 0
    4c62:	01 c0       	rjmp	.+2      	; 0x4c66 <writeFile+0x570>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    4c64:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    4c66:	60 96       	adiw	r28, 0x10	; 16
    4c68:	cd bf       	out	0x3d, r28	; 61
    4c6a:	de bf       	out	0x3e, r29	; 62
    4c6c:	df 91       	pop	r29
    4c6e:	cf 91       	pop	r28
    4c70:	1f 91       	pop	r17
    4c72:	0f 91       	pop	r16
    4c74:	ff 90       	pop	r15
    4c76:	ef 90       	pop	r14
    4c78:	df 90       	pop	r13
    4c7a:	cf 90       	pop	r12
    4c7c:	bf 90       	pop	r11
    4c7e:	af 90       	pop	r10
    4c80:	9f 90       	pop	r9
    4c82:	8f 90       	pop	r8
    4c84:	7f 90       	pop	r7
    4c86:	6f 90       	pop	r6
    4c88:	5f 90       	pop	r5
    4c8a:	4f 90       	pop	r4
    4c8c:	3f 90       	pop	r3
    4c8e:	2f 90       	pop	r2
    4c90:	08 95       	ret

00004c92 <SD_command>:
// 	data = SPIC.DATA; //read SPI data register to reset status flag
// 	return data;
// }

//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    4c92:	8f 92       	push	r8
    4c94:	9f 92       	push	r9
    4c96:	af 92       	push	r10
    4c98:	bf 92       	push	r11
    4c9a:	cf 92       	push	r12
    4c9c:	df 92       	push	r13
    4c9e:	ef 92       	push	r14
    4ca0:	ff 92       	push	r15
    4ca2:	0f 93       	push	r16
    4ca4:	1f 93       	push	r17
    4ca6:	cf 93       	push	r28
    4ca8:	df 93       	push	r29
    4caa:	84 2e       	mov	r8, r20
    4cac:	a5 2e       	mov	r10, r21
    4cae:	c6 2e       	mov	r12, r22
    4cb0:	c7 2f       	mov	r28, r23
    4cb2:	d2 2f       	mov	r29, r18
    4cb4:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    4cb6:	80 64       	ori	r24, 0x40	; 64
    4cb8:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    4cbc:	8c 2f       	mov	r24, r28
    4cbe:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    4cc2:	8c 2d       	mov	r24, r12
    4cc4:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    4cc8:	8a 2d       	mov	r24, r10
    4cca:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    4cce:	88 2d       	mov	r24, r8
    4cd0:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
	SPI_write(crc);
    4cd4:	8d 2f       	mov	r24, r29
    4cd6:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
	
	for(int i=0; i<read; i++){
    4cda:	10 16       	cp	r1, r16
    4cdc:	11 06       	cpc	r1, r17
    4cde:	64 f5       	brge	.+88     	; 0x4d38 <SD_command+0xa6>
    4ce0:	00 e0       	ldi	r16, 0x00	; 0
    4ce2:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    4ce4:	0f 2e       	mov	r0, r31
    4ce6:	fd e0       	ldi	r31, 0x0D	; 13
    4ce8:	cf 2e       	mov	r12, r31
    4cea:	dd 24       	eor	r13, r13
    4cec:	f0 2d       	mov	r31, r0
    4cee:	0f 2e       	mov	r0, r31
    4cf0:	f3 e3       	ldi	r31, 0x33	; 51
    4cf2:	af 2e       	mov	r10, r31
    4cf4:	fe e3       	ldi	r31, 0x3E	; 62
    4cf6:	bf 2e       	mov	r11, r31
    4cf8:	f0 2d       	mov	r31, r0
    4cfa:	c8 01       	movw	r24, r16
    4cfc:	b6 01       	movw	r22, r12
    4cfe:	0e 94 fe 35 	call	0x6bfc	; 0x6bfc <__divmodhi4>
    4d02:	ec 01       	movw	r28, r24
    4d04:	8f ef       	ldi	r24, 0xFF	; 255
    4d06:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    4d0a:	f5 01       	movw	r30, r10
    4d0c:	ec 0f       	add	r30, r28
    4d0e:	fd 1f       	adc	r31, r29
    4d10:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    4d12:	80 81       	ld	r24, Z
    4d14:	8f 3f       	cpi	r24, 0xFF	; 255
    4d16:	49 f0       	breq	.+18     	; 0x4d2a <SD_command+0x98>
			Buffer[1] = Buffer[i%13];
    4d18:	fe 01       	movw	r30, r28
    4d1a:	ed 5c       	subi	r30, 0xCD	; 205
    4d1c:	f1 4c       	sbci	r31, 0xC1	; 193
    4d1e:	80 81       	ld	r24, Z
    4d20:	80 93 34 3e 	sts	0x3E34, r24
			return Buffer[1];
    4d24:	80 91 34 3e 	lds	r24, 0x3E34
    4d28:	08 c0       	rjmp	.+16     	; 0x4d3a <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    4d2a:	0f 5f       	subi	r16, 0xFF	; 255
    4d2c:	1f 4f       	sbci	r17, 0xFF	; 255
    4d2e:	0e 15       	cp	r16, r14
    4d30:	1f 05       	cpc	r17, r15
    4d32:	19 f7       	brne	.-58     	; 0x4cfa <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    4d34:	8f ef       	ldi	r24, 0xFF	; 255
    4d36:	01 c0       	rjmp	.+2      	; 0x4d3a <SD_command+0xa8>
    4d38:	8f ef       	ldi	r24, 0xFF	; 255
}
    4d3a:	df 91       	pop	r29
    4d3c:	cf 91       	pop	r28
    4d3e:	1f 91       	pop	r17
    4d40:	0f 91       	pop	r16
    4d42:	ff 90       	pop	r15
    4d44:	ef 90       	pop	r14
    4d46:	df 90       	pop	r13
    4d48:	cf 90       	pop	r12
    4d4a:	bf 90       	pop	r11
    4d4c:	af 90       	pop	r10
    4d4e:	9f 90       	pop	r9
    4d50:	8f 90       	pop	r8
    4d52:	08 95       	ret

00004d54 <SD_init>:
# include "SD_Card.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    4d54:	ff 92       	push	r15
    4d56:	0f 93       	push	r16
    4d58:	1f 93       	push	r17
    4d5a:	cf 93       	push	r28
    4d5c:	df 93       	push	r29
	
	ADCPower(TRUE);				//power up portEX
    4d5e:	81 e0       	ldi	r24, 0x01	; 1
    4d60:	0e 94 a3 05 	call	0xb46	; 0xb46 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    4d64:	81 e0       	ldi	r24, 0x01	; 1
    4d66:	0e 94 4a 03 	call	0x694	; 0x694 <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    4d6a:	8f ef       	ldi	r24, 0xFF	; 255
    4d6c:	93 ec       	ldi	r25, 0xC3	; 195
    4d6e:	a9 e0       	ldi	r26, 0x09	; 9
    4d70:	81 50       	subi	r24, 0x01	; 1
    4d72:	90 40       	sbci	r25, 0x00	; 0
    4d74:	a0 40       	sbci	r26, 0x00	; 0
    4d76:	e1 f7       	brne	.-8      	; 0x4d70 <SD_init+0x1c>
    4d78:	00 c0       	rjmp	.+0      	; 0x4d7a <SD_init+0x26>
    4d7a:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
	
	PortEx_DIRSET(BIT3_bm, PS_BANKB); //SD card CS
    4d7c:	88 e0       	ldi	r24, 0x08	; 8
    4d7e:	60 e0       	ldi	r22, 0x00	; 0
    4d80:	0e 94 4d 05 	call	0xa9a	; 0xa9a <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB); //pull SD cs high
    4d84:	88 e0       	ldi	r24, 0x08	; 8
    4d86:	60 e0       	ldi	r22, 0x00	; 0
    4d88:	0e 94 a0 04 	call	0x940	; 0x940 <PortEx_OUTSET>
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
    4d8c:	80 e0       	ldi	r24, 0x00	; 0
    4d8e:	63 e0       	ldi	r22, 0x03	; 3
    4d90:	0e 94 be 03 	call	0x77c	; 0x77c <SPIInit2>
	SPICS(TRUE);
    4d94:	81 e0       	ldi	r24, 0x01	; 1
    4d96:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
    4d9a:	8a e0       	ldi	r24, 0x0A	; 10
    4d9c:	90 e0       	ldi	r25, 0x00	; 0
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    4d9e:	e0 ec       	ldi	r30, 0xC0	; 192
    4da0:	f8 e0       	ldi	r31, 0x08	; 8
    4da2:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
    4da4:	af e3       	ldi	r26, 0x3F	; 63
    4da6:	be e3       	ldi	r27, 0x3E	; 62
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    4da8:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    4daa:	22 81       	ldd	r18, Z+2	; 0x02
    4dac:	22 23       	and	r18, r18
    4dae:	ec f7       	brge	.-6      	; 0x4daa <SD_init+0x56>
		Buffer[12] = SPIC.DATA;
    4db0:	23 81       	ldd	r18, Z+3	; 0x03
    4db2:	2c 93       	st	X, r18
    4db4:	01 97       	sbiw	r24, 0x01	; 1
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
    4db6:	c1 f7       	brne	.-16     	; 0x4da8 <SD_init+0x54>
		SPIC.DATA = SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
	}
	
	SPICS(FALSE);
    4db8:	80 e0       	ldi	r24, 0x00	; 0
    4dba:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	SPIDisable();
    4dbe:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <SPIDisable>
	
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    4dc2:	88 e0       	ldi	r24, 0x08	; 8
    4dc4:	60 e0       	ldi	r22, 0x00	; 0
    4dc6:	0e 94 49 04 	call	0x892	; 0x892 <PortEx_OUTCLR>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    4dca:	80 e0       	ldi	r24, 0x00	; 0
    4dcc:	63 e0       	ldi	r22, 0x03	; 3
    4dce:	0e 94 be 03 	call	0x77c	; 0x77c <SPIInit2>
	SPICS(TRUE);
    4dd2:	81 e0       	ldi	r24, 0x01	; 1
    4dd4:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    4dd8:	cb e0       	ldi	r28, 0x0B	; 11
    4dda:	d0 e0       	ldi	r29, 0x00	; 0
    4ddc:	02 c0       	rjmp	.+4      	; 0x4de2 <SD_init+0x8e>
    4dde:	21 97       	sbiw	r28, 0x01	; 1
		//try command 10 times before timing out
		if (i >= 10) {
    4de0:	69 f0       	breq	.+26     	; 0x4dfc <SD_init+0xa8>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    4de2:	80 e0       	ldi	r24, 0x00	; 0
    4de4:	40 e0       	ldi	r20, 0x00	; 0
    4de6:	50 e0       	ldi	r21, 0x00	; 0
    4de8:	ba 01       	movw	r22, r20
    4dea:	25 e9       	ldi	r18, 0x95	; 149
    4dec:	08 e0       	ldi	r16, 0x08	; 8
    4dee:	10 e0       	ldi	r17, 0x00	; 0
    4df0:	0e 94 49 26 	call	0x4c92	; 0x4c92 <SD_command>
    4df4:	81 30       	cpi	r24, 0x01	; 1
    4df6:	99 f7       	brne	.-26     	; 0x4dde <SD_init+0x8a>
uint8_t SD_init(void){
	
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    4df8:	ff 24       	eor	r15, r15
    4dfa:	02 c0       	rjmp	.+4      	; 0x4e00 <SD_init+0xac>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
		//try command 10 times before timing out
		if (i >= 10) {
			//there was no response to the first command
			errorCode = 1;
    4dfc:	ff 24       	eor	r15, r15
    4dfe:	f3 94       	inc	r15
    4e00:	8f ef       	ldi	r24, 0xFF	; 255
    4e02:	93 ec       	ldi	r25, 0xC3	; 195
    4e04:	a9 e0       	ldi	r26, 0x09	; 9
    4e06:	81 50       	subi	r24, 0x01	; 1
    4e08:	90 40       	sbci	r25, 0x00	; 0
    4e0a:	a0 40       	sbci	r26, 0x00	; 0
    4e0c:	e1 f7       	brne	.-8      	; 0x4e06 <SD_init+0xb2>
    4e0e:	00 c0       	rjmp	.+0      	; 0x4e10 <SD_init+0xbc>
    4e10:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    4e12:	cb e0       	ldi	r28, 0x0B	; 11
    4e14:	d0 e0       	ldi	r29, 0x00	; 0
    4e16:	02 c0       	rjmp	.+4      	; 0x4e1c <SD_init+0xc8>
    4e18:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    4e1a:	69 f0       	breq	.+26     	; 0x4e36 <SD_init+0xe2>
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    4e1c:	88 e0       	ldi	r24, 0x08	; 8
    4e1e:	4a ea       	ldi	r20, 0xAA	; 170
    4e20:	51 e0       	ldi	r21, 0x01	; 1
    4e22:	60 e0       	ldi	r22, 0x00	; 0
    4e24:	70 e0       	ldi	r23, 0x00	; 0
    4e26:	27 e8       	ldi	r18, 0x87	; 135
    4e28:	08 e0       	ldi	r16, 0x08	; 8
    4e2a:	10 e0       	ldi	r17, 0x00	; 0
    4e2c:	0e 94 49 26 	call	0x4c92	; 0x4c92 <SD_command>
    4e30:	81 30       	cpi	r24, 0x01	; 1
    4e32:	91 f7       	brne	.-28     	; 0x4e18 <SD_init+0xc4>
    4e34:	02 c0       	rjmp	.+4      	; 0x4e3a <SD_init+0xe6>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    4e36:	ff 24       	eor	r15, r15
    4e38:	f3 94       	inc	r15
    4e3a:	c2 e0       	ldi	r28, 0x02	; 2
    4e3c:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}
	}
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    4e3e:	03 e3       	ldi	r16, 0x33	; 51
    4e40:	1e e3       	ldi	r17, 0x3E	; 62
    4e42:	8f ef       	ldi	r24, 0xFF	; 255
    4e44:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    4e48:	f8 01       	movw	r30, r16
    4e4a:	ec 0f       	add	r30, r28
    4e4c:	fd 1f       	adc	r31, r29
    4e4e:	80 83       	st	Z, r24
    4e50:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}
	for(int i=0;i<4;i++){
    4e52:	c6 30       	cpi	r28, 0x06	; 6
    4e54:	d1 05       	cpc	r29, r1
    4e56:	a9 f7       	brne	.-22     	; 0x4e42 <SD_init+0xee>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	//check that the response is the same as the argument sent in
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){
    4e58:	80 91 37 3e 	lds	r24, 0x3E37
    4e5c:	81 30       	cpi	r24, 0x01	; 1
    4e5e:	29 f4       	brne	.+10     	; 0x4e6a <SD_init+0x116>
    4e60:	80 91 38 3e 	lds	r24, 0x3E38
    4e64:	8a 3a       	cpi	r24, 0xAA	; 170
    4e66:	21 f4       	brne	.+8      	; 0x4e70 <SD_init+0x11c>
    4e68:	05 c0       	rjmp	.+10     	; 0x4e74 <SD_init+0x120>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    4e6a:	ff 24       	eor	r15, r15
    4e6c:	f3 94       	inc	r15
    4e6e:	02 c0       	rjmp	.+4      	; 0x4e74 <SD_init+0x120>
    4e70:	ff 24       	eor	r15, r15
    4e72:	f3 94       	inc	r15
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
    4e74:	c4 e3       	ldi	r28, 0x34	; 52
    4e76:	de e3       	ldi	r29, 0x3E	; 62
		errorCode = 1;
	}
	//send second initialization command
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
    4e78:	87 e3       	ldi	r24, 0x37	; 55
    4e7a:	40 e0       	ldi	r20, 0x00	; 0
    4e7c:	50 e0       	ldi	r21, 0x00	; 0
    4e7e:	ba 01       	movw	r22, r20
    4e80:	2f ef       	ldi	r18, 0xFF	; 255
    4e82:	08 e0       	ldi	r16, 0x08	; 8
    4e84:	10 e0       	ldi	r17, 0x00	; 0
    4e86:	0e 94 49 26 	call	0x4c92	; 0x4c92 <SD_command>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
    4e8a:	81 e0       	ldi	r24, 0x01	; 1
    4e8c:	40 e0       	ldi	r20, 0x00	; 0
    4e8e:	50 e0       	ldi	r21, 0x00	; 0
    4e90:	60 e0       	ldi	r22, 0x00	; 0
    4e92:	70 e4       	ldi	r23, 0x40	; 64
    4e94:	2f ef       	ldi	r18, 0xFF	; 255
    4e96:	0e 94 49 26 	call	0x4c92	; 0x4c92 <SD_command>
	} while(Buffer[1]!= 0x00);	
    4e9a:	88 81       	ld	r24, Y
    4e9c:	88 23       	and	r24, r24
    4e9e:	61 f7       	brne	.-40     	; 0x4e78 <SD_init+0x124>
    4ea0:	cb e0       	ldi	r28, 0x0B	; 11
    4ea2:	d0 e0       	ldi	r29, 0x00	; 0
    4ea4:	02 c0       	rjmp	.+4      	; 0x4eaa <SD_init+0x156>
    4ea6:	21 97       	sbiw	r28, 0x01	; 1
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
		if (i >= 10) {
    4ea8:	61 f0       	breq	.+24     	; 0x4ec2 <SD_init+0x16e>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
    4eaa:	8a e3       	ldi	r24, 0x3A	; 58
    4eac:	40 e0       	ldi	r20, 0x00	; 0
    4eae:	50 e0       	ldi	r21, 0x00	; 0
    4eb0:	ba 01       	movw	r22, r20
    4eb2:	2f ef       	ldi	r18, 0xFF	; 255
    4eb4:	08 e0       	ldi	r16, 0x08	; 8
    4eb6:	10 e0       	ldi	r17, 0x00	; 0
    4eb8:	0e 94 49 26 	call	0x4c92	; 0x4c92 <SD_command>
    4ebc:	88 23       	and	r24, r24
    4ebe:	99 f7       	brne	.-26     	; 0x4ea6 <SD_init+0x152>
    4ec0:	02 c0       	rjmp	.+4      	; 0x4ec6 <SD_init+0x172>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    4ec2:	ff 24       	eor	r15, r15
    4ec4:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    4ec6:	c0 e0       	ldi	r28, 0x00	; 0
    4ec8:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    4eca:	03 e3       	ldi	r16, 0x33	; 51
    4ecc:	1e e3       	ldi	r17, 0x3E	; 62
    4ece:	8f ef       	ldi	r24, 0xFF	; 255
    4ed0:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    4ed4:	f8 01       	movw	r30, r16
    4ed6:	ec 0f       	add	r30, r28
    4ed8:	fd 1f       	adc	r31, r29
    4eda:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    4edc:	21 96       	adiw	r28, 0x01	; 1
    4ede:	c4 30       	cpi	r28, 0x04	; 4
    4ee0:	d1 05       	cpc	r29, r1
    4ee2:	a9 f7       	brne	.-22     	; 0x4ece <SD_init+0x17a>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    4ee4:	80 91 33 3e 	lds	r24, 0x3E33
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    4ee8:	80 e0       	ldi	r24, 0x00	; 0
    4eea:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	SPIDisable();
    4eee:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <SPIDisable>
	//pull SD cs high
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    4ef2:	88 e0       	ldi	r24, 0x08	; 8
    4ef4:	60 e0       	ldi	r22, 0x00	; 0
    4ef6:	0e 94 a0 04 	call	0x940	; 0x940 <PortEx_OUTSET>
	
	return errorCode;					
}
    4efa:	8f 2d       	mov	r24, r15
    4efc:	df 91       	pop	r29
    4efe:	cf 91       	pop	r28
    4f00:	1f 91       	pop	r17
    4f02:	0f 91       	pop	r16
    4f04:	ff 90       	pop	r15
    4f06:	08 95       	ret

00004f08 <SD_write_block>:
	}
	return SDHC_DUMMY_BYTE;
}

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    4f08:	6f 92       	push	r6
    4f0a:	7f 92       	push	r7
    4f0c:	8f 92       	push	r8
    4f0e:	9f 92       	push	r9
    4f10:	af 92       	push	r10
    4f12:	bf 92       	push	r11
    4f14:	cf 92       	push	r12
    4f16:	df 92       	push	r13
    4f18:	ef 92       	push	r14
    4f1a:	ff 92       	push	r15
    4f1c:	0f 93       	push	r16
    4f1e:	1f 93       	push	r17
    4f20:	cf 93       	push	r28
    4f22:	df 93       	push	r29
    4f24:	4b 01       	movw	r8, r22
    4f26:	5c 01       	movw	r10, r24
    4f28:	74 2e       	mov	r7, r20
    4f2a:	65 2e       	mov	r6, r21
    4f2c:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    4f2e:	88 e0       	ldi	r24, 0x08	; 8
    4f30:	60 e0       	ldi	r22, 0x00	; 0
    4f32:	0e 94 49 04 	call	0x892	; 0x892 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    4f36:	80 e0       	ldi	r24, 0x00	; 0
    4f38:	0e 94 ad 03 	call	0x75a	; 0x75a <SPIInit>
	SPICS(TRUE);
    4f3c:	81 e0       	ldi	r24, 0x01	; 1
    4f3e:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    4f42:	80 e0       	ldi	r24, 0x00	; 0
    4f44:	92 e0       	ldi	r25, 0x02	; 2
    4f46:	7c 01       	movw	r14, r24
    4f48:	ec 18       	sub	r14, r12
    4f4a:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    4f4c:	80 e0       	ldi	r24, 0x00	; 0
    4f4e:	e8 16       	cp	r14, r24
    4f50:	82 e0       	ldi	r24, 0x02	; 2
    4f52:	f8 06       	cpc	r15, r24
    4f54:	11 f4       	brne	.+4      	; 0x4f5a <SD_write_block+0x52>
    4f56:	ee 24       	eor	r14, r14
    4f58:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    4f5a:	cb e0       	ldi	r28, 0x0B	; 11
    4f5c:	d0 e0       	ldi	r29, 0x00	; 0
    4f5e:	03 c0       	rjmp	.+6      	; 0x4f66 <SD_write_block+0x5e>
    4f60:	21 97       	sbiw	r28, 0x01	; 1
	if (i >= 10) {
    4f62:	09 f4       	brne	.+2      	; 0x4f66 <SD_write_block+0x5e>
    4f64:	ff cf       	rjmp	.-2      	; 0x4f64 <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    4f66:	88 e1       	ldi	r24, 0x18	; 24
    4f68:	b5 01       	movw	r22, r10
    4f6a:	a4 01       	movw	r20, r8
    4f6c:	2f ef       	ldi	r18, 0xFF	; 255
    4f6e:	08 e0       	ldi	r16, 0x08	; 8
    4f70:	10 e0       	ldi	r17, 0x00	; 0
    4f72:	0e 94 49 26 	call	0x4c92	; 0x4c92 <SD_command>
    4f76:	88 23       	and	r24, r24
    4f78:	99 f7       	brne	.-26     	; 0x4f60 <SD_write_block+0x58>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    4f7a:	8f ef       	ldi	r24, 0xFF	; 255
    4f7c:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    4f80:	80 93 33 3e 	sts	0x3E33, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    4f84:	8e ef       	ldi	r24, 0xFE	; 254
    4f86:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    4f8a:	1c 14       	cp	r1, r12
    4f8c:	1d 04       	cpc	r1, r13
    4f8e:	bc f4       	brge	.+46     	; 0x4fbe <SD_write_block+0xb6>
    4f90:	87 2c       	mov	r8, r7
    4f92:	96 2c       	mov	r9, r6
    4f94:	00 e0       	ldi	r16, 0x00	; 0
    4f96:	10 e0       	ldi	r17, 0x00	; 0
Buffer[i%13] = SPI_write(data[i]);
    4f98:	c8 01       	movw	r24, r16
    4f9a:	6d e0       	ldi	r22, 0x0D	; 13
    4f9c:	70 e0       	ldi	r23, 0x00	; 0
    4f9e:	0e 94 fe 35 	call	0x6bfc	; 0x6bfc <__divmodhi4>
    4fa2:	ec 01       	movw	r28, r24
    4fa4:	f4 01       	movw	r30, r8
    4fa6:	81 91       	ld	r24, Z+
    4fa8:	4f 01       	movw	r8, r30
    4faa:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    4fae:	cd 5c       	subi	r28, 0xCD	; 205
    4fb0:	d1 4c       	sbci	r29, 0xC1	; 193
    4fb2:	88 83       	st	Y, r24
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    4fb4:	0f 5f       	subi	r16, 0xFF	; 255
    4fb6:	1f 4f       	sbci	r17, 0xFF	; 255
    4fb8:	0c 15       	cp	r16, r12
    4fba:	1d 05       	cpc	r17, r13
    4fbc:	69 f7       	brne	.-38     	; 0x4f98 <SD_write_block+0x90>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    4fbe:	1e 14       	cp	r1, r14
    4fc0:	1f 04       	cpc	r1, r15
    4fc2:	ec f4       	brge	.+58     	; 0x4ffe <SD_write_block+0xf6>
    4fc4:	00 e0       	ldi	r16, 0x00	; 0
    4fc6:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    4fc8:	0f 2e       	mov	r0, r31
    4fca:	fd e0       	ldi	r31, 0x0D	; 13
    4fcc:	cf 2e       	mov	r12, r31
    4fce:	dd 24       	eor	r13, r13
    4fd0:	f0 2d       	mov	r31, r0
    4fd2:	0f 2e       	mov	r0, r31
    4fd4:	f3 e3       	ldi	r31, 0x33	; 51
    4fd6:	8f 2e       	mov	r8, r31
    4fd8:	fe e3       	ldi	r31, 0x3E	; 62
    4fda:	9f 2e       	mov	r9, r31
    4fdc:	f0 2d       	mov	r31, r0
    4fde:	c8 01       	movw	r24, r16
    4fe0:	b6 01       	movw	r22, r12
    4fe2:	0e 94 fe 35 	call	0x6bfc	; 0x6bfc <__divmodhi4>
    4fe6:	ec 01       	movw	r28, r24
    4fe8:	80 e0       	ldi	r24, 0x00	; 0
    4fea:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    4fee:	c8 0d       	add	r28, r8
    4ff0:	d9 1d       	adc	r29, r9
    4ff2:	88 83       	st	Y, r24
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    4ff4:	0f 5f       	subi	r16, 0xFF	; 255
    4ff6:	1f 4f       	sbci	r17, 0xFF	; 255
    4ff8:	0e 15       	cp	r16, r14
    4ffa:	1f 05       	cpc	r17, r15
    4ffc:	81 f7       	brne	.-32     	; 0x4fde <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    4ffe:	8f ef       	ldi	r24, 0xFF	; 255
    5000:	80 93 33 3e 	sts	0x3E33, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    5004:	c0 e0       	ldi	r28, 0x00	; 0
    5006:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    5008:	03 e3       	ldi	r16, 0x33	; 51
    500a:	1e e3       	ldi	r17, 0x3E	; 62
    500c:	8f ef       	ldi	r24, 0xFF	; 255
    500e:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    5012:	f8 01       	movw	r30, r16
    5014:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    5016:	21 96       	adiw	r28, 0x01	; 1
    5018:	c2 30       	cpi	r28, 0x02	; 2
    501a:	d1 05       	cpc	r29, r1
    501c:	bc f3       	brlt	.-18     	; 0x500c <SD_write_block+0x104>
    501e:	80 81       	ld	r24, Z
    5020:	8f 3f       	cpi	r24, 0xFF	; 255
    5022:	a1 f3       	breq	.-24     	; 0x500c <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    5024:	80 91 33 3e 	lds	r24, 0x3E33
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    5028:	80 91 33 3e 	lds	r24, 0x3E33
    502c:	8f 3f       	cpi	r24, 0xFF	; 255
    502e:	49 f0       	breq	.+18     	; 0x5042 <SD_write_block+0x13a>
    5030:	c3 e3       	ldi	r28, 0x33	; 51
    5032:	de e3       	ldi	r29, 0x3E	; 62
    5034:	8f ef       	ldi	r24, 0xFF	; 255
    5036:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    503a:	88 83       	st	Y, r24
    503c:	88 81       	ld	r24, Y
    503e:	8f 3f       	cpi	r24, 0xFF	; 255
    5040:	c9 f7       	brne	.-14     	; 0x5034 <SD_write_block+0x12c>
	SPICS(FALSE);
    5042:	80 e0       	ldi	r24, 0x00	; 0
    5044:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	SPIDisable();
    5048:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    504c:	88 e0       	ldi	r24, 0x08	; 8
    504e:	60 e0       	ldi	r22, 0x00	; 0
    5050:	0e 94 a0 04 	call	0x940	; 0x940 <PortEx_OUTSET>
}
    5054:	df 91       	pop	r29
    5056:	cf 91       	pop	r28
    5058:	1f 91       	pop	r17
    505a:	0f 91       	pop	r16
    505c:	ff 90       	pop	r15
    505e:	ef 90       	pop	r14
    5060:	df 90       	pop	r13
    5062:	cf 90       	pop	r12
    5064:	bf 90       	pop	r11
    5066:	af 90       	pop	r10
    5068:	9f 90       	pop	r9
    506a:	8f 90       	pop	r8
    506c:	7f 90       	pop	r7
    506e:	6f 90       	pop	r6
    5070:	08 95       	ret

00005072 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    5072:	af 92       	push	r10
    5074:	bf 92       	push	r11
    5076:	cf 92       	push	r12
    5078:	df 92       	push	r13
    507a:	ef 92       	push	r14
    507c:	ff 92       	push	r15
    507e:	0f 93       	push	r16
    5080:	1f 93       	push	r17
    5082:	cf 93       	push	r28
    5084:	df 93       	push	r29
    5086:	6b 01       	movw	r12, r22
    5088:	7c 01       	movw	r14, r24
    508a:	b4 2e       	mov	r11, r20
    508c:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    508e:	88 e0       	ldi	r24, 0x08	; 8
    5090:	60 e0       	ldi	r22, 0x00	; 0
    5092:	0e 94 49 04 	call	0x892	; 0x892 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5096:	80 e0       	ldi	r24, 0x00	; 0
    5098:	0e 94 ad 03 	call	0x75a	; 0x75a <SPIInit>
	SPICS(TRUE);
    509c:	81 e0       	ldi	r24, 0x01	; 1
    509e:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    50a2:	cb e0       	ldi	r28, 0x0B	; 11
    50a4:	d0 e0       	ldi	r29, 0x00	; 0
    50a6:	03 c0       	rjmp	.+6      	; 0x50ae <SD_read_block+0x3c>
    50a8:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    50aa:	09 f4       	brne	.+2      	; 0x50ae <SD_read_block+0x3c>
    50ac:	ff cf       	rjmp	.-2      	; 0x50ac <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    50ae:	81 e1       	ldi	r24, 0x11	; 17
    50b0:	b7 01       	movw	r22, r14
    50b2:	a6 01       	movw	r20, r12
    50b4:	2f ef       	ldi	r18, 0xFF	; 255
    50b6:	08 e0       	ldi	r16, 0x08	; 8
    50b8:	10 e0       	ldi	r17, 0x00	; 0
    50ba:	0e 94 49 26 	call	0x4c92	; 0x4c92 <SD_command>
    50be:	88 23       	and	r24, r24
    50c0:	99 f7       	brne	.-26     	; 0x50a8 <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    50c2:	80 91 33 3e 	lds	r24, 0x3E33
    50c6:	8e 3f       	cpi	r24, 0xFE	; 254
    50c8:	49 f0       	breq	.+18     	; 0x50dc <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    50ca:	c3 e3       	ldi	r28, 0x33	; 51
    50cc:	de e3       	ldi	r29, 0x3E	; 62
    50ce:	8f ef       	ldi	r24, 0xFF	; 255
    50d0:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    50d4:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    50d6:	88 81       	ld	r24, Y
    50d8:	8e 3f       	cpi	r24, 0xFE	; 254
    50da:	c9 f7       	brne	.-14     	; 0x50ce <SD_read_block+0x5c>
    50dc:	0b 2d       	mov	r16, r11
    50de:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    50e0:	c0 e0       	ldi	r28, 0x00	; 0
    50e2:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    50e4:	8f ef       	ldi	r24, 0xFF	; 255
    50e6:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    50ea:	f8 01       	movw	r30, r16
    50ec:	81 93       	st	Z+, r24
    50ee:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    50f0:	21 96       	adiw	r28, 0x01	; 1
    50f2:	f2 e0       	ldi	r31, 0x02	; 2
    50f4:	c0 30       	cpi	r28, 0x00	; 0
    50f6:	df 07       	cpc	r29, r31
    50f8:	a9 f7       	brne	.-22     	; 0x50e4 <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    50fa:	10 92 3f 3e 	sts	0x3E3F, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    50fe:	80 91 3f 3e 	lds	r24, 0x3E3F
    5102:	8f 3f       	cpi	r24, 0xFF	; 255
    5104:	49 f0       	breq	.+18     	; 0x5118 <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    5106:	cf e3       	ldi	r28, 0x3F	; 63
    5108:	de e3       	ldi	r29, 0x3E	; 62
    510a:	8f ef       	ldi	r24, 0xFF	; 255
    510c:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    5110:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    5112:	88 81       	ld	r24, Y
    5114:	8f 3f       	cpi	r24, 0xFF	; 255
    5116:	c9 f7       	brne	.-14     	; 0x510a <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    5118:	80 e0       	ldi	r24, 0x00	; 0
    511a:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	SPIDisable();
    511e:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5122:	88 e0       	ldi	r24, 0x08	; 8
    5124:	60 e0       	ldi	r22, 0x00	; 0
    5126:	0e 94 a0 04 	call	0x940	; 0x940 <PortEx_OUTSET>
}
    512a:	df 91       	pop	r29
    512c:	cf 91       	pop	r28
    512e:	1f 91       	pop	r17
    5130:	0f 91       	pop	r16
    5132:	ff 90       	pop	r15
    5134:	ef 90       	pop	r14
    5136:	df 90       	pop	r13
    5138:	cf 90       	pop	r12
    513a:	bf 90       	pop	r11
    513c:	af 90       	pop	r10
    513e:	08 95       	ret

00005140 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5140:	2f 92       	push	r2
    5142:	3f 92       	push	r3
    5144:	4f 92       	push	r4
    5146:	5f 92       	push	r5
    5148:	6f 92       	push	r6
    514a:	7f 92       	push	r7
    514c:	8f 92       	push	r8
    514e:	9f 92       	push	r9
    5150:	af 92       	push	r10
    5152:	bf 92       	push	r11
    5154:	cf 92       	push	r12
    5156:	df 92       	push	r13
    5158:	ef 92       	push	r14
    515a:	ff 92       	push	r15
    515c:	0f 93       	push	r16
    515e:	1f 93       	push	r17
    5160:	cf 93       	push	r28
    5162:	df 93       	push	r29
    5164:	cd b7       	in	r28, 0x3d	; 61
    5166:	de b7       	in	r29, 0x3e	; 62
    5168:	2a 97       	sbiw	r28, 0x0a	; 10
    516a:	cd bf       	out	0x3d, r28	; 61
    516c:	de bf       	out	0x3e, r29	; 62
    516e:	6b 01       	movw	r12, r22
    5170:	7c 01       	movw	r14, r24
    5172:	4f 83       	std	Y+7, r20	; 0x07
    5174:	58 87       	std	Y+8, r21	; 0x08
    5176:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5178:	88 e0       	ldi	r24, 0x08	; 8
    517a:	60 e0       	ldi	r22, 0x00	; 0
    517c:	0e 94 49 04 	call	0x892	; 0x892 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5180:	80 e0       	ldi	r24, 0x00	; 0
    5182:	0e 94 ad 03 	call	0x75a	; 0x75a <SPIInit>
	SPICS(TRUE);
    5186:	81 e0       	ldi	r24, 0x01	; 1
    5188:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    518c:	c8 01       	movw	r24, r16
    518e:	11 23       	and	r17, r17
    5190:	14 f4       	brge	.+4      	; 0x5196 <SD_write_multiple_blocks+0x56>
    5192:	81 50       	subi	r24, 0x01	; 1
    5194:	9e 4f       	sbci	r25, 0xFE	; 254
    5196:	9c 01       	movw	r18, r24
    5198:	23 2f       	mov	r18, r19
    519a:	33 0f       	add	r19, r19
    519c:	33 0b       	sbc	r19, r19
    519e:	25 95       	asr	r18
    51a0:	2b 83       	std	Y+3, r18	; 0x03
    51a2:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    51a4:	20 e0       	ldi	r18, 0x00	; 0
    51a6:	32 e0       	ldi	r19, 0x02	; 2
    51a8:	c8 01       	movw	r24, r16
    51aa:	b9 01       	movw	r22, r18
    51ac:	0e 94 fe 35 	call	0x6bfc	; 0x6bfc <__divmodhi4>
    51b0:	29 01       	movw	r4, r18
    51b2:	48 1a       	sub	r4, r24
    51b4:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    51b6:	30 e0       	ldi	r19, 0x00	; 0
    51b8:	43 16       	cp	r4, r19
    51ba:	32 e0       	ldi	r19, 0x02	; 2
    51bc:	53 06       	cpc	r5, r19
    51be:	31 f0       	breq	.+12     	; 0x51cc <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    51c0:	8b 81       	ldd	r24, Y+3	; 0x03
    51c2:	9c 81       	ldd	r25, Y+4	; 0x04
    51c4:	01 96       	adiw	r24, 0x01	; 1
    51c6:	8b 83       	std	Y+3, r24	; 0x03
    51c8:	9c 83       	std	Y+4, r25	; 0x04
    51ca:	02 c0       	rjmp	.+4      	; 0x51d0 <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    51cc:	44 24       	eor	r4, r4
    51ce:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    51d0:	89 e1       	ldi	r24, 0x19	; 25
    51d2:	b7 01       	movw	r22, r14
    51d4:	a6 01       	movw	r20, r12
    51d6:	2f ef       	ldi	r18, 0xFF	; 255
    51d8:	08 e0       	ldi	r16, 0x08	; 8
    51da:	10 e0       	ldi	r17, 0x00	; 0
    51dc:	0e 94 49 26 	call	0x4c92	; 0x4c92 <SD_command>
    51e0:	88 23       	and	r24, r24
    51e2:	b1 f7       	brne	.-20     	; 0x51d0 <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    51e4:	eb 81       	ldd	r30, Y+3	; 0x03
    51e6:	fc 81       	ldd	r31, Y+4	; 0x04
    51e8:	1e 16       	cp	r1, r30
    51ea:	1f 06       	cpc	r1, r31
    51ec:	0c f0       	brlt	.+2      	; 0x51f0 <SD_write_multiple_blocks+0xb0>
    51ee:	ac c0       	rjmp	.+344    	; 0x5348 <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    51f0:	31 97       	sbiw	r30, 0x01	; 1
    51f2:	ed 83       	std	Y+5, r30	; 0x05
    51f4:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    51f6:	9f 01       	movw	r18, r30
    51f8:	32 2f       	mov	r19, r18
    51fa:	22 27       	eor	r18, r18
    51fc:	33 0f       	add	r19, r19
    51fe:	8f 81       	ldd	r24, Y+7	; 0x07
    5200:	98 85       	ldd	r25, Y+8	; 0x08
    5202:	89 83       	std	Y+1, r24	; 0x01
    5204:	9a 83       	std	Y+2, r25	; 0x02
    5206:	66 24       	eor	r6, r6
    5208:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    520a:	0f 2e       	mov	r0, r31
    520c:	f4 e3       	ldi	r31, 0x34	; 52
    520e:	8f 2e       	mov	r8, r31
    5210:	fe e3       	ldi	r31, 0x3E	; 62
    5212:	9f 2e       	mov	r9, r31
    5214:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5216:	0f 2e       	mov	r0, r31
    5218:	fc e0       	ldi	r31, 0x0C	; 12
    521a:	cf 2e       	mov	r12, r31
    521c:	dd 24       	eor	r13, r13
    521e:	f0 2d       	mov	r31, r0
    5220:	0f 2e       	mov	r0, r31
    5222:	f3 e3       	ldi	r31, 0x33	; 51
    5224:	af 2e       	mov	r10, r31
    5226:	fe e3       	ldi	r31, 0x3E	; 62
    5228:	bf 2e       	mov	r11, r31
    522a:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    522c:	80 e0       	ldi	r24, 0x00	; 0
    522e:	92 e0       	ldi	r25, 0x02	; 2
    5230:	1c 01       	movw	r2, r24
    5232:	24 18       	sub	r2, r4
    5234:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5236:	ef 81       	ldd	r30, Y+7	; 0x07
    5238:	f8 85       	ldd	r31, Y+8	; 0x08
    523a:	e2 0f       	add	r30, r18
    523c:	f3 1f       	adc	r31, r19
    523e:	ef 83       	std	Y+7, r30	; 0x07
    5240:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    5242:	8f ef       	ldi	r24, 0xFF	; 255
    5244:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    5248:	f4 01       	movw	r30, r8
    524a:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    524c:	8c ef       	ldi	r24, 0xFC	; 252
    524e:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    5252:	f4 01       	movw	r30, r8
    5254:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    5256:	2d 81       	ldd	r18, Y+5	; 0x05
    5258:	3e 81       	ldd	r19, Y+6	; 0x06
    525a:	26 15       	cp	r18, r6
    525c:	37 05       	cpc	r19, r7
    525e:	09 f0       	breq	.+2      	; 0x5262 <SD_write_multiple_blocks+0x122>
    5260:	41 c0       	rjmp	.+130    	; 0x52e4 <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5262:	12 14       	cp	r1, r2
    5264:	13 04       	cpc	r1, r3
    5266:	cc f4       	brge	.+50     	; 0x529a <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    5268:	ef 80       	ldd	r14, Y+7	; 0x07
    526a:	f8 84       	ldd	r15, Y+8	; 0x08
    526c:	00 e0       	ldi	r16, 0x00	; 0
    526e:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5270:	c8 01       	movw	r24, r16
    5272:	b6 01       	movw	r22, r12
    5274:	0e 94 fe 35 	call	0x6bfc	; 0x6bfc <__divmodhi4>
    5278:	89 87       	std	Y+9, r24	; 0x09
    527a:	9a 87       	std	Y+10, r25	; 0x0a
    527c:	f7 01       	movw	r30, r14
    527e:	81 91       	ld	r24, Z+
    5280:	7f 01       	movw	r14, r30
    5282:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    5286:	e9 85       	ldd	r30, Y+9	; 0x09
    5288:	fa 85       	ldd	r31, Y+10	; 0x0a
    528a:	ea 0d       	add	r30, r10
    528c:	fb 1d       	adc	r31, r11
    528e:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5290:	0f 5f       	subi	r16, 0xFF	; 255
    5292:	1f 4f       	sbci	r17, 0xFF	; 255
    5294:	02 15       	cp	r16, r2
    5296:	13 05       	cpc	r17, r3
    5298:	59 f7       	brne	.-42     	; 0x5270 <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    529a:	14 14       	cp	r1, r4
    529c:	15 04       	cpc	r1, r5
    529e:	9c f4       	brge	.+38     	; 0x52c6 <SD_write_multiple_blocks+0x186>
    52a0:	00 e0       	ldi	r16, 0x00	; 0
    52a2:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    52a4:	c8 01       	movw	r24, r16
    52a6:	b6 01       	movw	r22, r12
    52a8:	0e 94 fe 35 	call	0x6bfc	; 0x6bfc <__divmodhi4>
    52ac:	7c 01       	movw	r14, r24
    52ae:	80 e0       	ldi	r24, 0x00	; 0
    52b0:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    52b4:	f5 01       	movw	r30, r10
    52b6:	ee 0d       	add	r30, r14
    52b8:	ff 1d       	adc	r31, r15
    52ba:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    52bc:	0f 5f       	subi	r16, 0xFF	; 255
    52be:	1f 4f       	sbci	r17, 0xFF	; 255
    52c0:	04 15       	cp	r16, r4
    52c2:	15 05       	cpc	r17, r5
    52c4:	79 f7       	brne	.-34     	; 0x52a4 <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    52c6:	8f ef       	ldi	r24, 0xFF	; 255
    52c8:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    52cc:	f4 01       	movw	r30, r8
    52ce:	80 83       	st	Z, r24
    52d0:	8f ef       	ldi	r24, 0xFF	; 255
    52d2:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    52d6:	f4 01       	movw	r30, r8
    52d8:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    52da:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    52dc:	80 81       	ld	r24, Z
    52de:	8f 3f       	cpi	r24, 0xFF	; 255
    52e0:	e1 f4       	brne	.+56     	; 0x531a <SD_write_multiple_blocks+0x1da>
    52e2:	23 c0       	rjmp	.+70     	; 0x532a <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    52e4:	e9 80       	ldd	r14, Y+1	; 0x01
    52e6:	fa 80       	ldd	r15, Y+2	; 0x02
    52e8:	00 e0       	ldi	r16, 0x00	; 0
    52ea:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    52ec:	c8 01       	movw	r24, r16
    52ee:	b6 01       	movw	r22, r12
    52f0:	0e 94 fe 35 	call	0x6bfc	; 0x6bfc <__divmodhi4>
    52f4:	89 87       	std	Y+9, r24	; 0x09
    52f6:	9a 87       	std	Y+10, r25	; 0x0a
    52f8:	f7 01       	movw	r30, r14
    52fa:	81 91       	ld	r24, Z+
    52fc:	7f 01       	movw	r14, r30
    52fe:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    5302:	e9 85       	ldd	r30, Y+9	; 0x09
    5304:	fa 85       	ldd	r31, Y+10	; 0x0a
    5306:	ea 0d       	add	r30, r10
    5308:	fb 1d       	adc	r31, r11
    530a:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    530c:	0f 5f       	subi	r16, 0xFF	; 255
    530e:	1f 4f       	sbci	r17, 0xFF	; 255
    5310:	f2 e0       	ldi	r31, 0x02	; 2
    5312:	00 30       	cpi	r16, 0x00	; 0
    5314:	1f 07       	cpc	r17, r31
    5316:	51 f7       	brne	.-44     	; 0x52ec <SD_write_multiple_blocks+0x1ac>
    5318:	d6 cf       	rjmp	.-84     	; 0x52c6 <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    531a:	8f ef       	ldi	r24, 0xFF	; 255
    531c:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    5320:	f4 01       	movw	r30, r8
    5322:	80 83       	st	Z, r24
    5324:	80 81       	ld	r24, Z
    5326:	8f 3f       	cpi	r24, 0xFF	; 255
    5328:	c1 f7       	brne	.-16     	; 0x531a <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    532a:	08 94       	sec
    532c:	61 1c       	adc	r6, r1
    532e:	71 1c       	adc	r7, r1
    5330:	29 81       	ldd	r18, Y+1	; 0x01
    5332:	3a 81       	ldd	r19, Y+2	; 0x02
    5334:	20 50       	subi	r18, 0x00	; 0
    5336:	3e 4f       	sbci	r19, 0xFE	; 254
    5338:	29 83       	std	Y+1, r18	; 0x01
    533a:	3a 83       	std	Y+2, r19	; 0x02
    533c:	8b 81       	ldd	r24, Y+3	; 0x03
    533e:	9c 81       	ldd	r25, Y+4	; 0x04
    5340:	68 16       	cp	r6, r24
    5342:	79 06       	cpc	r7, r25
    5344:	09 f0       	breq	.+2      	; 0x5348 <SD_write_multiple_blocks+0x208>
    5346:	7d cf       	rjmp	.-262    	; 0x5242 <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5348:	ee 24       	eor	r14, r14
    534a:	ff 24       	eor	r15, r15
    534c:	68 94       	set
    534e:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5350:	04 e3       	ldi	r16, 0x34	; 52
    5352:	1e e3       	ldi	r17, 0x3E	; 62
    5354:	8f ef       	ldi	r24, 0xFF	; 255
    5356:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    535a:	f8 01       	movw	r30, r16
    535c:	80 83       	st	Z, r24
    535e:	08 94       	sec
    5360:	e1 08       	sbc	r14, r1
    5362:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    5364:	e1 14       	cp	r14, r1
    5366:	f1 04       	cpc	r15, r1
    5368:	a9 f7       	brne	.-22     	; 0x5354 <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    536a:	8d ef       	ldi	r24, 0xFD	; 253
    536c:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    5370:	80 93 34 3e 	sts	0x3E34, r24
    5374:	ee 24       	eor	r14, r14
    5376:	ff 24       	eor	r15, r15
    5378:	68 94       	set
    537a:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    537c:	04 e3       	ldi	r16, 0x34	; 52
    537e:	1e e3       	ldi	r17, 0x3E	; 62
    5380:	8f ef       	ldi	r24, 0xFF	; 255
    5382:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    5386:	f8 01       	movw	r30, r16
    5388:	80 83       	st	Z, r24
    538a:	08 94       	sec
    538c:	e1 08       	sbc	r14, r1
    538e:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    5390:	e1 14       	cp	r14, r1
    5392:	f1 04       	cpc	r15, r1
    5394:	a9 f7       	brne	.-22     	; 0x5380 <SD_write_multiple_blocks+0x240>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    5396:	10 92 34 3e 	sts	0x3E34, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    539a:	80 91 34 3e 	lds	r24, 0x3E34
    539e:	8f 3f       	cpi	r24, 0xFF	; 255
    53a0:	51 f0       	breq	.+20     	; 0x53b6 <SD_write_multiple_blocks+0x276>
    53a2:	04 e3       	ldi	r16, 0x34	; 52
    53a4:	1e e3       	ldi	r17, 0x3E	; 62
    53a6:	8f ef       	ldi	r24, 0xFF	; 255
    53a8:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    53ac:	f8 01       	movw	r30, r16
    53ae:	80 83       	st	Z, r24
    53b0:	80 81       	ld	r24, Z
    53b2:	8f 3f       	cpi	r24, 0xFF	; 255
    53b4:	c1 f7       	brne	.-16     	; 0x53a6 <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    53b6:	80 e0       	ldi	r24, 0x00	; 0
    53b8:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	SPIDisable();
    53bc:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    53c0:	88 e0       	ldi	r24, 0x08	; 8
    53c2:	60 e0       	ldi	r22, 0x00	; 0
    53c4:	0e 94 a0 04 	call	0x940	; 0x940 <PortEx_OUTSET>
}
    53c8:	2a 96       	adiw	r28, 0x0a	; 10
    53ca:	cd bf       	out	0x3d, r28	; 61
    53cc:	de bf       	out	0x3e, r29	; 62
    53ce:	df 91       	pop	r29
    53d0:	cf 91       	pop	r28
    53d2:	1f 91       	pop	r17
    53d4:	0f 91       	pop	r16
    53d6:	ff 90       	pop	r15
    53d8:	ef 90       	pop	r14
    53da:	df 90       	pop	r13
    53dc:	cf 90       	pop	r12
    53de:	bf 90       	pop	r11
    53e0:	af 90       	pop	r10
    53e2:	9f 90       	pop	r9
    53e4:	8f 90       	pop	r8
    53e6:	7f 90       	pop	r7
    53e8:	6f 90       	pop	r6
    53ea:	5f 90       	pop	r5
    53ec:	4f 90       	pop	r4
    53ee:	3f 90       	pop	r3
    53f0:	2f 90       	pop	r2
    53f2:	08 95       	ret

000053f4 <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    53f4:	2f 92       	push	r2
    53f6:	3f 92       	push	r3
    53f8:	4f 92       	push	r4
    53fa:	5f 92       	push	r5
    53fc:	6f 92       	push	r6
    53fe:	7f 92       	push	r7
    5400:	8f 92       	push	r8
    5402:	9f 92       	push	r9
    5404:	af 92       	push	r10
    5406:	bf 92       	push	r11
    5408:	cf 92       	push	r12
    540a:	df 92       	push	r13
    540c:	ef 92       	push	r14
    540e:	ff 92       	push	r15
    5410:	0f 93       	push	r16
    5412:	1f 93       	push	r17
    5414:	cf 93       	push	r28
    5416:	df 93       	push	r29
    5418:	6b 01       	movw	r12, r22
    541a:	7c 01       	movw	r14, r24
    541c:	c4 2f       	mov	r28, r20
    541e:	85 2e       	mov	r8, r21
    5420:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5422:	88 e0       	ldi	r24, 0x08	; 8
    5424:	60 e0       	ldi	r22, 0x00	; 0
    5426:	0e 94 49 04 	call	0x892	; 0x892 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    542a:	80 e0       	ldi	r24, 0x00	; 0
    542c:	0e 94 ad 03 	call	0x75a	; 0x75a <SPIInit>
	SPICS(TRUE);
    5430:	81 e0       	ldi	r24, 0x01	; 1
    5432:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    5436:	82 e1       	ldi	r24, 0x12	; 18
    5438:	b7 01       	movw	r22, r14
    543a:	a6 01       	movw	r20, r12
    543c:	2f ef       	ldi	r18, 0xFF	; 255
    543e:	08 e0       	ldi	r16, 0x08	; 8
    5440:	10 e0       	ldi	r17, 0x00	; 0
    5442:	0e 94 49 26 	call	0x4c92	; 0x4c92 <SD_command>
    5446:	88 23       	and	r24, r24
    5448:	b1 f7       	brne	.-20     	; 0x5436 <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    544a:	16 14       	cp	r1, r6
    544c:	17 04       	cpc	r1, r7
    544e:	0c f0       	brlt	.+2      	; 0x5452 <SD_read_multiple_blocks+0x5e>
    5450:	46 c0       	rjmp	.+140    	; 0x54de <SD_read_multiple_blocks+0xea>
    5452:	ac 2e       	mov	r10, r28
    5454:	b8 2c       	mov	r11, r8
    5456:	88 24       	eor	r8, r8
    5458:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    545a:	0f 2e       	mov	r0, r31
    545c:	f4 e3       	ldi	r31, 0x34	; 52
    545e:	cf 2e       	mov	r12, r31
    5460:	fe e3       	ldi	r31, 0x3E	; 62
    5462:	df 2e       	mov	r13, r31
    5464:	f0 2d       	mov	r31, r0
    5466:	ff 24       	eor	r15, r15
    5468:	fa 94       	dec	r15
    546a:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    546c:	0f 2e       	mov	r0, r31
    546e:	f3 e3       	ldi	r31, 0x33	; 51
    5470:	4f 2e       	mov	r4, r31
    5472:	fe e3       	ldi	r31, 0x3E	; 62
    5474:	5f 2e       	mov	r5, r31
    5476:	f0 2d       	mov	r31, r0
    5478:	12 01       	movw	r2, r4
    547a:	08 94       	sec
    547c:	21 1c       	adc	r2, r1
    547e:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    5480:	f6 01       	movw	r30, r12
    5482:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5484:	80 81       	ld	r24, Z
    5486:	8e 3f       	cpi	r24, 0xFE	; 254
    5488:	41 f0       	breq	.+16     	; 0x549a <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    548a:	8f 2d       	mov	r24, r15
    548c:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    5490:	f6 01       	movw	r30, r12
    5492:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    5494:	80 81       	ld	r24, Z
    5496:	8e 3f       	cpi	r24, 0xFE	; 254
    5498:	c1 f7       	brne	.-16     	; 0x548a <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    549a:	85 01       	movw	r16, r10
    549c:	c0 e0       	ldi	r28, 0x00	; 0
    549e:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    54a0:	8f 2d       	mov	r24, r15
    54a2:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    54a6:	f8 01       	movw	r30, r16
    54a8:	81 93       	st	Z+, r24
    54aa:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    54ac:	21 96       	adiw	r28, 0x01	; 1
    54ae:	f2 e0       	ldi	r31, 0x02	; 2
    54b0:	c0 30       	cpi	r28, 0x00	; 0
    54b2:	df 07       	cpc	r29, r31
    54b4:	a9 f7       	brne	.-22     	; 0x54a0 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    54b6:	8f 2d       	mov	r24, r15
    54b8:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    54bc:	f2 01       	movw	r30, r4
    54be:	80 83       	st	Z, r24
    54c0:	8f 2d       	mov	r24, r15
    54c2:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    54c6:	f1 01       	movw	r30, r2
    54c8:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    54ca:	08 94       	sec
    54cc:	81 1c       	adc	r8, r1
    54ce:	91 1c       	adc	r9, r1
    54d0:	80 e0       	ldi	r24, 0x00	; 0
    54d2:	92 e0       	ldi	r25, 0x02	; 2
    54d4:	a8 0e       	add	r10, r24
    54d6:	b9 1e       	adc	r11, r25
    54d8:	86 14       	cp	r8, r6
    54da:	97 04       	cpc	r9, r7
    54dc:	89 f6       	brne	.-94     	; 0x5480 <SD_read_multiple_blocks+0x8c>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    54de:	8c e0       	ldi	r24, 0x0C	; 12
    54e0:	40 e0       	ldi	r20, 0x00	; 0
    54e2:	50 e0       	ldi	r21, 0x00	; 0
    54e4:	ba 01       	movw	r22, r20
    54e6:	2f ef       	ldi	r18, 0xFF	; 255
    54e8:	08 e0       	ldi	r16, 0x08	; 8
    54ea:	10 e0       	ldi	r17, 0x00	; 0
    54ec:	0e 94 49 26 	call	0x4c92	; 0x4c92 <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    54f0:	8f ef       	ldi	r24, 0xFF	; 255
    54f2:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    54f6:	80 93 33 3e 	sts	0x3E33, r24
	Buffer[1] = FILLER_BYTE;
    54fa:	10 92 34 3e 	sts	0x3E34, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    54fe:	80 91 34 3e 	lds	r24, 0x3E34
    5502:	8f 3f       	cpi	r24, 0xFF	; 255
    5504:	49 f0       	breq	.+18     	; 0x5518 <SD_read_multiple_blocks+0x124>
    5506:	c4 e3       	ldi	r28, 0x34	; 52
    5508:	de e3       	ldi	r29, 0x3E	; 62
    550a:	8f ef       	ldi	r24, 0xFF	; 255
    550c:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
    5510:	88 83       	st	Y, r24
    5512:	88 81       	ld	r24, Y
    5514:	8f 3f       	cpi	r24, 0xFF	; 255
    5516:	c9 f7       	brne	.-14     	; 0x550a <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    5518:	80 e0       	ldi	r24, 0x00	; 0
    551a:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	SPIDisable();
    551e:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5522:	88 e0       	ldi	r24, 0x08	; 8
    5524:	60 e0       	ldi	r22, 0x00	; 0
    5526:	0e 94 a0 04 	call	0x940	; 0x940 <PortEx_OUTSET>
}
    552a:	df 91       	pop	r29
    552c:	cf 91       	pop	r28
    552e:	1f 91       	pop	r17
    5530:	0f 91       	pop	r16
    5532:	ff 90       	pop	r15
    5534:	ef 90       	pop	r14
    5536:	df 90       	pop	r13
    5538:	cf 90       	pop	r12
    553a:	bf 90       	pop	r11
    553c:	af 90       	pop	r10
    553e:	9f 90       	pop	r9
    5540:	8f 90       	pop	r8
    5542:	7f 90       	pop	r7
    5544:	6f 90       	pop	r6
    5546:	5f 90       	pop	r5
    5548:	4f 90       	pop	r4
    554a:	3f 90       	pop	r3
    554c:	2f 90       	pop	r2
    554e:	08 95       	ret

00005550 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    5550:	88 e0       	ldi	r24, 0x08	; 8
    5552:	60 e0       	ldi	r22, 0x00	; 0
    5554:	0e 94 4d 05 	call	0xa9a	; 0xa9a <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    5558:	88 e0       	ldi	r24, 0x08	; 8
    555a:	60 e0       	ldi	r22, 0x00	; 0
    555c:	0e 94 a0 04 	call	0x940	; 0x940 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    5560:	80 e0       	ldi	r24, 0x00	; 0
    5562:	0e 94 ad 03 	call	0x75a	; 0x75a <SPIInit>
	SPICS(TRUE);
    5566:	81 e0       	ldi	r24, 0x01	; 1
    5568:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    556c:	8f ef       	ldi	r24, 0xFF	; 255
    556e:	0e 94 ac 06 	call	0xd58	; 0xd58 <SPI_write>
	SPICS(FALSE);	//stop spi
    5572:	80 e0       	ldi	r24, 0x00	; 0
    5574:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <SPICS>
	SPIDisable();
    5578:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    557c:	80 e0       	ldi	r24, 0x00	; 0
    557e:	0e 94 a3 05 	call	0xb46	; 0xb46 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    5582:	80 e0       	ldi	r24, 0x00	; 0
    5584:	0e 94 4a 03 	call	0x694	; 0x694 <Ext1Power>
}
    5588:	08 95       	ret

0000558a <__muldi3>:
    558a:	a0 e3       	ldi	r26, 0x30	; 48
    558c:	b0 e0       	ldi	r27, 0x00	; 0
    558e:	eb ec       	ldi	r30, 0xCB	; 203
    5590:	fa e2       	ldi	r31, 0x2A	; 42
    5592:	0c 94 64 36 	jmp	0x6cc8	; 0x6cc8 <__prologue_saves__+0x4>
    5596:	29 8f       	std	Y+25, r18	; 0x19
    5598:	3a 8f       	std	Y+26, r19	; 0x1a
    559a:	4b 8f       	std	Y+27, r20	; 0x1b
    559c:	5c 8f       	std	Y+28, r21	; 0x1c
    559e:	6d 8f       	std	Y+29, r22	; 0x1d
    55a0:	7e 8f       	std	Y+30, r23	; 0x1e
    55a2:	8f 8f       	std	Y+31, r24	; 0x1f
    55a4:	98 a3       	lds	r25, 0x58
    55a6:	a9 8a       	std	Y+17, r10	; 0x11
    55a8:	ba 8a       	std	Y+18, r11	; 0x12
    55aa:	cb 8a       	std	Y+19, r12	; 0x13
    55ac:	dc 8a       	std	Y+20, r13	; 0x14
    55ae:	ed 8a       	std	Y+21, r14	; 0x15
    55b0:	fe 8a       	std	Y+22, r15	; 0x16
    55b2:	0f 8b       	std	Y+23, r16	; 0x17
    55b4:	18 8f       	std	Y+24, r17	; 0x18
    55b6:	09 8d       	ldd	r16, Y+25	; 0x19
    55b8:	1a 8d       	ldd	r17, Y+26	; 0x1a
    55ba:	2b 8d       	ldd	r18, Y+27	; 0x1b
    55bc:	3c 8d       	ldd	r19, Y+28	; 0x1c
    55be:	09 a3       	lds	r16, 0x59
    55c0:	1a a3       	lds	r17, 0x5a
    55c2:	2b a3       	lds	r18, 0x5b
    55c4:	3c a3       	lds	r19, 0x5c
    55c6:	68 01       	movw	r12, r16
    55c8:	79 01       	movw	r14, r18
    55ca:	8f ef       	ldi	r24, 0xFF	; 255
    55cc:	9f ef       	ldi	r25, 0xFF	; 255
    55ce:	a0 e0       	ldi	r26, 0x00	; 0
    55d0:	b0 e0       	ldi	r27, 0x00	; 0
    55d2:	c8 22       	and	r12, r24
    55d4:	d9 22       	and	r13, r25
    55d6:	ea 22       	and	r14, r26
    55d8:	fb 22       	and	r15, r27
    55da:	89 01       	movw	r16, r18
    55dc:	22 27       	eor	r18, r18
    55de:	33 27       	eor	r19, r19
    55e0:	09 a7       	lds	r16, 0x79
    55e2:	1a a7       	lds	r17, 0x7a
    55e4:	2b a7       	lds	r18, 0x7b
    55e6:	3c a7       	lds	r19, 0x7c
    55e8:	09 89       	ldd	r16, Y+17	; 0x11
    55ea:	1a 89       	ldd	r17, Y+18	; 0x12
    55ec:	2b 89       	ldd	r18, Y+19	; 0x13
    55ee:	3c 89       	ldd	r19, Y+20	; 0x14
    55f0:	0d a3       	lds	r16, 0x5d
    55f2:	1e a3       	lds	r17, 0x5e
    55f4:	2f a3       	lds	r18, 0x5f
    55f6:	38 a7       	lds	r19, 0x78
    55f8:	48 01       	movw	r8, r16
    55fa:	59 01       	movw	r10, r18
    55fc:	88 22       	and	r8, r24
    55fe:	99 22       	and	r9, r25
    5600:	aa 22       	and	r10, r26
    5602:	bb 22       	and	r11, r27
    5604:	29 01       	movw	r4, r18
    5606:	66 24       	eor	r6, r6
    5608:	77 24       	eor	r7, r7
    560a:	c5 01       	movw	r24, r10
    560c:	b4 01       	movw	r22, r8
    560e:	a7 01       	movw	r20, r14
    5610:	96 01       	movw	r18, r12
    5612:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    5616:	6d a7       	lds	r22, 0x7d
    5618:	7e a7       	lds	r23, 0x7e
    561a:	8f a7       	lds	r24, 0x7f
    561c:	98 ab       	sts	0x58, r25
    561e:	c3 01       	movw	r24, r6
    5620:	b2 01       	movw	r22, r4
    5622:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    5626:	6b 01       	movw	r12, r22
    5628:	7c 01       	movw	r14, r24
    562a:	c5 01       	movw	r24, r10
    562c:	b4 01       	movw	r22, r8
    562e:	29 a5       	lds	r18, 0x69
    5630:	3a a5       	lds	r19, 0x6a
    5632:	4b a5       	lds	r20, 0x6b
    5634:	5c a5       	lds	r21, 0x6c
    5636:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    563a:	4b 01       	movw	r8, r22
    563c:	5c 01       	movw	r10, r24
    563e:	c3 01       	movw	r24, r6
    5640:	b2 01       	movw	r22, r4
    5642:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    5646:	ab 01       	movw	r20, r22
    5648:	bc 01       	movw	r22, r24
    564a:	c8 0c       	add	r12, r8
    564c:	d9 1c       	adc	r13, r9
    564e:	ea 1c       	adc	r14, r10
    5650:	fb 1c       	adc	r15, r11
    5652:	0d a5       	lds	r16, 0x6d
    5654:	1e a5       	lds	r17, 0x6e
    5656:	2f a5       	lds	r18, 0x6f
    5658:	38 a9       	sts	0x48, r19
    565a:	c9 01       	movw	r24, r18
    565c:	aa 27       	eor	r26, r26
    565e:	bb 27       	eor	r27, r27
    5660:	c8 0e       	add	r12, r24
    5662:	d9 1e       	adc	r13, r25
    5664:	ea 1e       	adc	r14, r26
    5666:	fb 1e       	adc	r15, r27
    5668:	c8 14       	cp	r12, r8
    566a:	d9 04       	cpc	r13, r9
    566c:	ea 04       	cpc	r14, r10
    566e:	fb 04       	cpc	r15, r11
    5670:	20 f4       	brcc	.+8      	; 0x567a <__muldi3+0xf0>
    5672:	40 50       	subi	r20, 0x00	; 0
    5674:	50 40       	sbci	r21, 0x00	; 0
    5676:	6f 4f       	sbci	r22, 0xFF	; 255
    5678:	7f 4f       	sbci	r23, 0xFF	; 255
    567a:	c7 01       	movw	r24, r14
    567c:	aa 27       	eor	r26, r26
    567e:	bb 27       	eor	r27, r27
    5680:	84 0f       	add	r24, r20
    5682:	95 1f       	adc	r25, r21
    5684:	a6 1f       	adc	r26, r22
    5686:	b7 1f       	adc	r27, r23
    5688:	8d 83       	std	Y+5, r24	; 0x05
    568a:	9e 83       	std	Y+6, r25	; 0x06
    568c:	af 83       	std	Y+7, r26	; 0x07
    568e:	b8 87       	std	Y+8, r27	; 0x08
    5690:	76 01       	movw	r14, r12
    5692:	dd 24       	eor	r13, r13
    5694:	cc 24       	eor	r12, r12
    5696:	4d a5       	lds	r20, 0x6d
    5698:	5e a5       	lds	r21, 0x6e
    569a:	6f a5       	lds	r22, 0x6f
    569c:	78 a9       	sts	0x48, r23
    569e:	60 70       	andi	r22, 0x00	; 0
    56a0:	70 70       	andi	r23, 0x00	; 0
    56a2:	c4 0e       	add	r12, r20
    56a4:	d5 1e       	adc	r13, r21
    56a6:	e6 1e       	adc	r14, r22
    56a8:	f7 1e       	adc	r15, r23
    56aa:	c9 82       	std	Y+1, r12	; 0x01
    56ac:	da 82       	std	Y+2, r13	; 0x02
    56ae:	eb 82       	std	Y+3, r14	; 0x03
    56b0:	fc 82       	std	Y+4, r15	; 0x04
    56b2:	1c 2d       	mov	r17, r12
    56b4:	0a 81       	ldd	r16, Y+2	; 0x02
    56b6:	8b 80       	ldd	r8, Y+3	; 0x03
    56b8:	4c 80       	ldd	r4, Y+4	; 0x04
    56ba:	8d 87       	std	Y+13, r24	; 0x0d
    56bc:	8e 81       	ldd	r24, Y+6	; 0x06
    56be:	8e 87       	std	Y+14, r24	; 0x0e
    56c0:	8f 81       	ldd	r24, Y+7	; 0x07
    56c2:	8f 87       	std	Y+15, r24	; 0x0f
    56c4:	88 85       	ldd	r24, Y+8	; 0x08
    56c6:	88 8b       	std	Y+16, r24	; 0x10
    56c8:	2d 89       	ldd	r18, Y+21	; 0x15
    56ca:	3e 89       	ldd	r19, Y+22	; 0x16
    56cc:	4f 89       	ldd	r20, Y+23	; 0x17
    56ce:	58 8d       	ldd	r21, Y+24	; 0x18
    56d0:	69 a1       	lds	r22, 0x49
    56d2:	7a a1       	lds	r23, 0x4a
    56d4:	8b a1       	lds	r24, 0x4b
    56d6:	9c a1       	lds	r25, 0x4c
    56d8:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    56dc:	6b 01       	movw	r12, r22
    56de:	7c 01       	movw	r14, r24
    56e0:	2d 8d       	ldd	r18, Y+29	; 0x1d
    56e2:	3e 8d       	ldd	r19, Y+30	; 0x1e
    56e4:	4f 8d       	ldd	r20, Y+31	; 0x1f
    56e6:	58 a1       	lds	r21, 0x48
    56e8:	6d a1       	lds	r22, 0x4d
    56ea:	7e a1       	lds	r23, 0x4e
    56ec:	8f a1       	lds	r24, 0x4f
    56ee:	98 a5       	lds	r25, 0x68
    56f0:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    56f4:	dc 01       	movw	r26, r24
    56f6:	cb 01       	movw	r24, r22
    56f8:	c8 0e       	add	r12, r24
    56fa:	d9 1e       	adc	r13, r25
    56fc:	ea 1e       	adc	r14, r26
    56fe:	fb 1e       	adc	r15, r27
    5700:	8d 85       	ldd	r24, Y+13	; 0x0d
    5702:	9e 85       	ldd	r25, Y+14	; 0x0e
    5704:	af 85       	ldd	r26, Y+15	; 0x0f
    5706:	b8 89       	ldd	r27, Y+16	; 0x10
    5708:	8c 0d       	add	r24, r12
    570a:	9d 1d       	adc	r25, r13
    570c:	ae 1d       	adc	r26, r14
    570e:	bf 1d       	adc	r27, r15
    5710:	8d 87       	std	Y+13, r24	; 0x0d
    5712:	9e 87       	std	Y+14, r25	; 0x0e
    5714:	af 87       	std	Y+15, r26	; 0x0f
    5716:	b8 8b       	std	Y+16, r27	; 0x10
    5718:	68 2f       	mov	r22, r24
    571a:	7e 85       	ldd	r23, Y+14	; 0x0e
    571c:	21 2f       	mov	r18, r17
    571e:	30 2f       	mov	r19, r16
    5720:	48 2d       	mov	r20, r8
    5722:	54 2d       	mov	r21, r4
    5724:	8f 85       	ldd	r24, Y+15	; 0x0f
    5726:	98 89       	ldd	r25, Y+16	; 0x10
    5728:	e0 96       	adiw	r28, 0x30	; 48
    572a:	e0 e1       	ldi	r30, 0x10	; 16
    572c:	0c 94 7d 36 	jmp	0x6cfa	; 0x6cfa <__epilogue_restores__+0x4>

00005730 <__ashldi3>:
    5730:	cf 92       	push	r12
    5732:	df 92       	push	r13
    5734:	ef 92       	push	r14
    5736:	ff 92       	push	r15
    5738:	0f 93       	push	r16
    573a:	cf 93       	push	r28
    573c:	df 93       	push	r29
    573e:	cd b7       	in	r28, 0x3d	; 61
    5740:	de b7       	in	r29, 0x3e	; 62
    5742:	60 97       	sbiw	r28, 0x10	; 16
    5744:	cd bf       	out	0x3d, r28	; 61
    5746:	de bf       	out	0x3e, r29	; 62
    5748:	00 23       	and	r16, r16
    574a:	09 f4       	brne	.+2      	; 0x574e <__ashldi3+0x1e>
    574c:	5a c0       	rjmp	.+180    	; 0x5802 <__ashldi3+0xd2>
    574e:	29 87       	std	Y+9, r18	; 0x09
    5750:	3a 87       	std	Y+10, r19	; 0x0a
    5752:	4b 87       	std	Y+11, r20	; 0x0b
    5754:	5c 87       	std	Y+12, r21	; 0x0c
    5756:	6d 87       	std	Y+13, r22	; 0x0d
    5758:	7e 87       	std	Y+14, r23	; 0x0e
    575a:	8f 87       	std	Y+15, r24	; 0x0f
    575c:	98 8b       	std	Y+16, r25	; 0x10
    575e:	80 e2       	ldi	r24, 0x20	; 32
    5760:	80 1b       	sub	r24, r16
    5762:	49 85       	ldd	r20, Y+9	; 0x09
    5764:	5a 85       	ldd	r21, Y+10	; 0x0a
    5766:	6b 85       	ldd	r22, Y+11	; 0x0b
    5768:	7c 85       	ldd	r23, Y+12	; 0x0c
    576a:	18 16       	cp	r1, r24
    576c:	b4 f0       	brlt	.+44     	; 0x579a <__ashldi3+0x6a>
    576e:	19 82       	std	Y+1, r1	; 0x01
    5770:	1a 82       	std	Y+2, r1	; 0x02
    5772:	1b 82       	std	Y+3, r1	; 0x03
    5774:	1c 82       	std	Y+4, r1	; 0x04
    5776:	99 27       	eor	r25, r25
    5778:	87 fd       	sbrc	r24, 7
    577a:	90 95       	com	r25
    577c:	90 95       	com	r25
    577e:	81 95       	neg	r24
    5780:	9f 4f       	sbci	r25, 0xFF	; 255
    5782:	04 c0       	rjmp	.+8      	; 0x578c <__ashldi3+0x5c>
    5784:	44 0f       	add	r20, r20
    5786:	55 1f       	adc	r21, r21
    5788:	66 1f       	adc	r22, r22
    578a:	77 1f       	adc	r23, r23
    578c:	8a 95       	dec	r24
    578e:	d2 f7       	brpl	.-12     	; 0x5784 <__ashldi3+0x54>
    5790:	4d 83       	std	Y+5, r20	; 0x05
    5792:	5e 83       	std	Y+6, r21	; 0x06
    5794:	6f 83       	std	Y+7, r22	; 0x07
    5796:	78 87       	std	Y+8, r23	; 0x08
    5798:	2c c0       	rjmp	.+88     	; 0x57f2 <__ashldi3+0xc2>
    579a:	6a 01       	movw	r12, r20
    579c:	7b 01       	movw	r14, r22
    579e:	00 2e       	mov	r0, r16
    57a0:	04 c0       	rjmp	.+8      	; 0x57aa <__ashldi3+0x7a>
    57a2:	cc 0c       	add	r12, r12
    57a4:	dd 1c       	adc	r13, r13
    57a6:	ee 1c       	adc	r14, r14
    57a8:	ff 1c       	adc	r15, r15
    57aa:	0a 94       	dec	r0
    57ac:	d2 f7       	brpl	.-12     	; 0x57a2 <__ashldi3+0x72>
    57ae:	c9 82       	std	Y+1, r12	; 0x01
    57b0:	da 82       	std	Y+2, r13	; 0x02
    57b2:	eb 82       	std	Y+3, r14	; 0x03
    57b4:	fc 82       	std	Y+4, r15	; 0x04
    57b6:	6a 01       	movw	r12, r20
    57b8:	7b 01       	movw	r14, r22
    57ba:	04 c0       	rjmp	.+8      	; 0x57c4 <__ashldi3+0x94>
    57bc:	f6 94       	lsr	r15
    57be:	e7 94       	ror	r14
    57c0:	d7 94       	ror	r13
    57c2:	c7 94       	ror	r12
    57c4:	8a 95       	dec	r24
    57c6:	d2 f7       	brpl	.-12     	; 0x57bc <__ashldi3+0x8c>
    57c8:	d7 01       	movw	r26, r14
    57ca:	c6 01       	movw	r24, r12
    57cc:	4d 85       	ldd	r20, Y+13	; 0x0d
    57ce:	5e 85       	ldd	r21, Y+14	; 0x0e
    57d0:	6f 85       	ldd	r22, Y+15	; 0x0f
    57d2:	78 89       	ldd	r23, Y+16	; 0x10
    57d4:	04 c0       	rjmp	.+8      	; 0x57de <__ashldi3+0xae>
    57d6:	44 0f       	add	r20, r20
    57d8:	55 1f       	adc	r21, r21
    57da:	66 1f       	adc	r22, r22
    57dc:	77 1f       	adc	r23, r23
    57de:	0a 95       	dec	r16
    57e0:	d2 f7       	brpl	.-12     	; 0x57d6 <__ashldi3+0xa6>
    57e2:	84 2b       	or	r24, r20
    57e4:	95 2b       	or	r25, r21
    57e6:	a6 2b       	or	r26, r22
    57e8:	b7 2b       	or	r27, r23
    57ea:	8d 83       	std	Y+5, r24	; 0x05
    57ec:	9e 83       	std	Y+6, r25	; 0x06
    57ee:	af 83       	std	Y+7, r26	; 0x07
    57f0:	b8 87       	std	Y+8, r27	; 0x08
    57f2:	29 81       	ldd	r18, Y+1	; 0x01
    57f4:	3a 81       	ldd	r19, Y+2	; 0x02
    57f6:	4b 81       	ldd	r20, Y+3	; 0x03
    57f8:	5c 81       	ldd	r21, Y+4	; 0x04
    57fa:	6d 81       	ldd	r22, Y+5	; 0x05
    57fc:	7e 81       	ldd	r23, Y+6	; 0x06
    57fe:	8f 81       	ldd	r24, Y+7	; 0x07
    5800:	98 85       	ldd	r25, Y+8	; 0x08
    5802:	60 96       	adiw	r28, 0x10	; 16
    5804:	cd bf       	out	0x3d, r28	; 61
    5806:	de bf       	out	0x3e, r29	; 62
    5808:	df 91       	pop	r29
    580a:	cf 91       	pop	r28
    580c:	0f 91       	pop	r16
    580e:	ff 90       	pop	r15
    5810:	ef 90       	pop	r14
    5812:	df 90       	pop	r13
    5814:	cf 90       	pop	r12
    5816:	08 95       	ret

00005818 <__ashrdi3>:
    5818:	0f 93       	push	r16
    581a:	cf 93       	push	r28
    581c:	df 93       	push	r29
    581e:	cd b7       	in	r28, 0x3d	; 61
    5820:	de b7       	in	r29, 0x3e	; 62
    5822:	60 97       	sbiw	r28, 0x10	; 16
    5824:	cd bf       	out	0x3d, r28	; 61
    5826:	de bf       	out	0x3e, r29	; 62
    5828:	00 23       	and	r16, r16
    582a:	09 f4       	brne	.+2      	; 0x582e <__ashrdi3+0x16>
    582c:	56 c0       	rjmp	.+172    	; 0x58da <__ashrdi3+0xc2>
    582e:	29 87       	std	Y+9, r18	; 0x09
    5830:	3a 87       	std	Y+10, r19	; 0x0a
    5832:	4b 87       	std	Y+11, r20	; 0x0b
    5834:	5c 87       	std	Y+12, r21	; 0x0c
    5836:	6d 87       	std	Y+13, r22	; 0x0d
    5838:	7e 87       	std	Y+14, r23	; 0x0e
    583a:	8f 87       	std	Y+15, r24	; 0x0f
    583c:	98 8b       	std	Y+16, r25	; 0x10
    583e:	20 e2       	ldi	r18, 0x20	; 32
    5840:	20 1b       	sub	r18, r16
    5842:	8d 85       	ldd	r24, Y+13	; 0x0d
    5844:	9e 85       	ldd	r25, Y+14	; 0x0e
    5846:	af 85       	ldd	r26, Y+15	; 0x0f
    5848:	b8 89       	ldd	r27, Y+16	; 0x10
    584a:	ac 01       	movw	r20, r24
    584c:	bd 01       	movw	r22, r26
    584e:	12 16       	cp	r1, r18
    5850:	b4 f0       	brlt	.+44     	; 0x587e <__ashrdi3+0x66>
    5852:	77 0f       	add	r23, r23
    5854:	44 0b       	sbc	r20, r20
    5856:	54 2f       	mov	r21, r20
    5858:	ba 01       	movw	r22, r20
    585a:	4d 83       	std	Y+5, r20	; 0x05
    585c:	5e 83       	std	Y+6, r21	; 0x06
    585e:	6f 83       	std	Y+7, r22	; 0x07
    5860:	78 87       	std	Y+8, r23	; 0x08
    5862:	33 27       	eor	r19, r19
    5864:	27 fd       	sbrc	r18, 7
    5866:	30 95       	com	r19
    5868:	30 95       	com	r19
    586a:	21 95       	neg	r18
    586c:	3f 4f       	sbci	r19, 0xFF	; 255
    586e:	04 c0       	rjmp	.+8      	; 0x5878 <__ashrdi3+0x60>
    5870:	b5 95       	asr	r27
    5872:	a7 95       	ror	r26
    5874:	97 95       	ror	r25
    5876:	87 95       	ror	r24
    5878:	2a 95       	dec	r18
    587a:	d2 f7       	brpl	.-12     	; 0x5870 <__ashrdi3+0x58>
    587c:	22 c0       	rjmp	.+68     	; 0x58c2 <__ashrdi3+0xaa>
    587e:	00 2e       	mov	r0, r16
    5880:	04 c0       	rjmp	.+8      	; 0x588a <__ashrdi3+0x72>
    5882:	75 95       	asr	r23
    5884:	67 95       	ror	r22
    5886:	57 95       	ror	r21
    5888:	47 95       	ror	r20
    588a:	0a 94       	dec	r0
    588c:	d2 f7       	brpl	.-12     	; 0x5882 <__ashrdi3+0x6a>
    588e:	4d 83       	std	Y+5, r20	; 0x05
    5890:	5e 83       	std	Y+6, r21	; 0x06
    5892:	6f 83       	std	Y+7, r22	; 0x07
    5894:	78 87       	std	Y+8, r23	; 0x08
    5896:	04 c0       	rjmp	.+8      	; 0x58a0 <__ashrdi3+0x88>
    5898:	88 0f       	add	r24, r24
    589a:	99 1f       	adc	r25, r25
    589c:	aa 1f       	adc	r26, r26
    589e:	bb 1f       	adc	r27, r27
    58a0:	2a 95       	dec	r18
    58a2:	d2 f7       	brpl	.-12     	; 0x5898 <__ashrdi3+0x80>
    58a4:	49 85       	ldd	r20, Y+9	; 0x09
    58a6:	5a 85       	ldd	r21, Y+10	; 0x0a
    58a8:	6b 85       	ldd	r22, Y+11	; 0x0b
    58aa:	7c 85       	ldd	r23, Y+12	; 0x0c
    58ac:	04 c0       	rjmp	.+8      	; 0x58b6 <__ashrdi3+0x9e>
    58ae:	76 95       	lsr	r23
    58b0:	67 95       	ror	r22
    58b2:	57 95       	ror	r21
    58b4:	47 95       	ror	r20
    58b6:	0a 95       	dec	r16
    58b8:	d2 f7       	brpl	.-12     	; 0x58ae <__ashrdi3+0x96>
    58ba:	84 2b       	or	r24, r20
    58bc:	95 2b       	or	r25, r21
    58be:	a6 2b       	or	r26, r22
    58c0:	b7 2b       	or	r27, r23
    58c2:	89 83       	std	Y+1, r24	; 0x01
    58c4:	9a 83       	std	Y+2, r25	; 0x02
    58c6:	ab 83       	std	Y+3, r26	; 0x03
    58c8:	bc 83       	std	Y+4, r27	; 0x04
    58ca:	29 81       	ldd	r18, Y+1	; 0x01
    58cc:	3a 81       	ldd	r19, Y+2	; 0x02
    58ce:	4b 81       	ldd	r20, Y+3	; 0x03
    58d0:	5c 81       	ldd	r21, Y+4	; 0x04
    58d2:	6d 81       	ldd	r22, Y+5	; 0x05
    58d4:	7e 81       	ldd	r23, Y+6	; 0x06
    58d6:	8f 81       	ldd	r24, Y+7	; 0x07
    58d8:	98 85       	ldd	r25, Y+8	; 0x08
    58da:	60 96       	adiw	r28, 0x10	; 16
    58dc:	cd bf       	out	0x3d, r28	; 61
    58de:	de bf       	out	0x3e, r29	; 62
    58e0:	df 91       	pop	r29
    58e2:	cf 91       	pop	r28
    58e4:	0f 91       	pop	r16
    58e6:	08 95       	ret

000058e8 <__divdi3>:
    58e8:	a8 e4       	ldi	r26, 0x48	; 72
    58ea:	b0 e0       	ldi	r27, 0x00	; 0
    58ec:	ea e7       	ldi	r30, 0x7A	; 122
    58ee:	fc e2       	ldi	r31, 0x2C	; 44
    58f0:	0c 94 63 36 	jmp	0x6cc6	; 0x6cc6 <__prologue_saves__+0x2>
    58f4:	f5 01       	movw	r30, r10
    58f6:	29 a3       	lds	r18, 0x59
    58f8:	3a a3       	lds	r19, 0x5a
    58fa:	4b a3       	lds	r20, 0x5b
    58fc:	5c a3       	lds	r21, 0x5c
    58fe:	6d a3       	lds	r22, 0x5d
    5900:	7e a3       	lds	r23, 0x5e
    5902:	8f a3       	lds	r24, 0x5f
    5904:	98 a7       	lds	r25, 0x78
    5906:	a9 8e       	std	Y+25, r10	; 0x19
    5908:	fa 8f       	std	Y+26, r31	; 0x1a
    590a:	cb 8e       	std	Y+27, r12	; 0x1b
    590c:	dc 8e       	std	Y+28, r13	; 0x1c
    590e:	ed 8e       	std	Y+29, r14	; 0x1d
    5910:	fe 8e       	std	Y+30, r15	; 0x1e
    5912:	0f 8f       	std	Y+31, r16	; 0x1f
    5914:	18 a3       	lds	r17, 0x58
    5916:	8d a0       	lds	r24, 0x8d
    5918:	9e a0       	lds	r25, 0x8e
    591a:	af a0       	lds	r26, 0x8f
    591c:	b8 a4       	lds	r27, 0xa8
    591e:	b7 fe       	sbrs	r11, 7
    5920:	67 c0       	rjmp	.+206    	; 0x59f0 <__divdi3+0x108>
    5922:	21 95       	neg	r18
    5924:	b1 e0       	ldi	r27, 0x01	; 1
    5926:	12 16       	cp	r1, r18
    5928:	08 f0       	brcs	.+2      	; 0x592c <__divdi3+0x44>
    592a:	b0 e0       	ldi	r27, 0x00	; 0
    592c:	31 95       	neg	r19
    592e:	a1 e0       	ldi	r26, 0x01	; 1
    5930:	13 16       	cp	r1, r19
    5932:	08 f0       	brcs	.+2      	; 0x5936 <__divdi3+0x4e>
    5934:	a0 e0       	ldi	r26, 0x00	; 0
    5936:	b3 2e       	mov	r11, r19
    5938:	bb 1a       	sub	r11, r27
    593a:	bb 2d       	mov	r27, r11
    593c:	88 24       	eor	r8, r8
    593e:	83 94       	inc	r8
    5940:	3b 15       	cp	r19, r11
    5942:	08 f0       	brcs	.+2      	; 0x5946 <__divdi3+0x5e>
    5944:	88 24       	eor	r8, r8
    5946:	a8 29       	or	r26, r8
    5948:	41 95       	neg	r20
    594a:	31 e0       	ldi	r19, 0x01	; 1
    594c:	14 16       	cp	r1, r20
    594e:	08 f0       	brcs	.+2      	; 0x5952 <__divdi3+0x6a>
    5950:	30 e0       	ldi	r19, 0x00	; 0
    5952:	b4 2e       	mov	r11, r20
    5954:	ba 1a       	sub	r11, r26
    5956:	ab 2d       	mov	r26, r11
    5958:	88 24       	eor	r8, r8
    595a:	83 94       	inc	r8
    595c:	4b 15       	cp	r20, r11
    595e:	08 f0       	brcs	.+2      	; 0x5962 <__divdi3+0x7a>
    5960:	88 24       	eor	r8, r8
    5962:	38 29       	or	r19, r8
    5964:	51 95       	neg	r21
    5966:	41 e0       	ldi	r20, 0x01	; 1
    5968:	15 16       	cp	r1, r21
    596a:	08 f0       	brcs	.+2      	; 0x596e <__divdi3+0x86>
    596c:	40 e0       	ldi	r20, 0x00	; 0
    596e:	45 2e       	mov	r4, r21
    5970:	43 1a       	sub	r4, r19
    5972:	31 e0       	ldi	r19, 0x01	; 1
    5974:	54 15       	cp	r21, r4
    5976:	08 f0       	brcs	.+2      	; 0x597a <__divdi3+0x92>
    5978:	30 e0       	ldi	r19, 0x00	; 0
    597a:	43 2b       	or	r20, r19
    597c:	61 95       	neg	r22
    597e:	31 e0       	ldi	r19, 0x01	; 1
    5980:	16 16       	cp	r1, r22
    5982:	08 f0       	brcs	.+2      	; 0x5986 <__divdi3+0x9e>
    5984:	30 e0       	ldi	r19, 0x00	; 0
    5986:	86 2e       	mov	r8, r22
    5988:	84 1a       	sub	r8, r20
    598a:	41 e0       	ldi	r20, 0x01	; 1
    598c:	68 15       	cp	r22, r8
    598e:	08 f0       	brcs	.+2      	; 0x5992 <__divdi3+0xaa>
    5990:	40 e0       	ldi	r20, 0x00	; 0
    5992:	34 2b       	or	r19, r20
    5994:	71 95       	neg	r23
    5996:	41 e0       	ldi	r20, 0x01	; 1
    5998:	17 16       	cp	r1, r23
    599a:	08 f0       	brcs	.+2      	; 0x599e <__divdi3+0xb6>
    599c:	40 e0       	ldi	r20, 0x00	; 0
    599e:	57 2f       	mov	r21, r23
    59a0:	53 1b       	sub	r21, r19
    59a2:	31 e0       	ldi	r19, 0x01	; 1
    59a4:	75 17       	cp	r23, r21
    59a6:	08 f0       	brcs	.+2      	; 0x59aa <__divdi3+0xc2>
    59a8:	30 e0       	ldi	r19, 0x00	; 0
    59aa:	43 2b       	or	r20, r19
    59ac:	81 95       	neg	r24
    59ae:	31 e0       	ldi	r19, 0x01	; 1
    59b0:	18 16       	cp	r1, r24
    59b2:	08 f0       	brcs	.+2      	; 0x59b6 <__divdi3+0xce>
    59b4:	30 e0       	ldi	r19, 0x00	; 0
    59b6:	68 2f       	mov	r22, r24
    59b8:	64 1b       	sub	r22, r20
    59ba:	46 2f       	mov	r20, r22
    59bc:	61 e0       	ldi	r22, 0x01	; 1
    59be:	84 17       	cp	r24, r20
    59c0:	08 f0       	brcs	.+2      	; 0x59c4 <__divdi3+0xdc>
    59c2:	60 e0       	ldi	r22, 0x00	; 0
    59c4:	36 2b       	or	r19, r22
    59c6:	91 95       	neg	r25
    59c8:	93 1b       	sub	r25, r19
    59ca:	29 a3       	lds	r18, 0x59
    59cc:	ba a3       	lds	r27, 0x5a
    59ce:	ab a3       	lds	r26, 0x5b
    59d0:	4c a2       	lds	r20, 0x9c
    59d2:	8d a2       	lds	r24, 0x9d
    59d4:	5e a3       	lds	r21, 0x5e
    59d6:	4f a3       	lds	r20, 0x5f
    59d8:	98 a7       	lds	r25, 0x78
    59da:	8f ef       	ldi	r24, 0xFF	; 255
    59dc:	9f ef       	ldi	r25, 0xFF	; 255
    59de:	af ef       	ldi	r26, 0xFF	; 255
    59e0:	bf ef       	ldi	r27, 0xFF	; 255
    59e2:	25 96       	adiw	r28, 0x05	; 5
    59e4:	8c af       	sts	0x7c, r24
    59e6:	9d af       	sts	0x7d, r25
    59e8:	ae af       	sts	0x7e, r26
    59ea:	bf af       	sts	0x7f, r27
    59ec:	25 97       	sbiw	r28, 0x05	; 5
    59ee:	06 c0       	rjmp	.+12     	; 0x59fc <__divdi3+0x114>
    59f0:	25 96       	adiw	r28, 0x05	; 5
    59f2:	1c ae       	sts	0xbc, r17
    59f4:	1d ae       	sts	0xbd, r17
    59f6:	1e ae       	sts	0xbe, r17
    59f8:	1f ae       	sts	0xbf, r17
    59fa:	25 97       	sbiw	r28, 0x05	; 5
    59fc:	8d 8d       	ldd	r24, Y+29	; 0x1d
    59fe:	9e 8d       	ldd	r25, Y+30	; 0x1e
    5a00:	af 8d       	ldd	r26, Y+31	; 0x1f
    5a02:	b8 a1       	lds	r27, 0x48
    5a04:	b7 ff       	sbrs	r27, 7
    5a06:	68 c0       	rjmp	.+208    	; 0x5ad8 <__divdi3+0x1f0>
    5a08:	25 96       	adiw	r28, 0x05	; 5
    5a0a:	2c ad       	sts	0x6c, r18
    5a0c:	3d ad       	sts	0x6d, r19
    5a0e:	4e ad       	sts	0x6e, r20
    5a10:	5f ad       	sts	0x6f, r21
    5a12:	25 97       	sbiw	r28, 0x05	; 5
    5a14:	20 95       	com	r18
    5a16:	30 95       	com	r19
    5a18:	40 95       	com	r20
    5a1a:	50 95       	com	r21
    5a1c:	25 96       	adiw	r28, 0x05	; 5
    5a1e:	2c af       	sts	0x7c, r18
    5a20:	3d af       	sts	0x7d, r19
    5a22:	4e af       	sts	0x7e, r20
    5a24:	5f af       	sts	0x7f, r21
    5a26:	25 97       	sbiw	r28, 0x05	; 5
    5a28:	e1 95       	neg	r30
    5a2a:	81 e0       	ldi	r24, 0x01	; 1
    5a2c:	1e 16       	cp	r1, r30
    5a2e:	08 f0       	brcs	.+2      	; 0x5a32 <__divdi3+0x14a>
    5a30:	80 e0       	ldi	r24, 0x00	; 0
    5a32:	f1 95       	neg	r31
    5a34:	91 e0       	ldi	r25, 0x01	; 1
    5a36:	1f 16       	cp	r1, r31
    5a38:	08 f0       	brcs	.+2      	; 0x5a3c <__divdi3+0x154>
    5a3a:	90 e0       	ldi	r25, 0x00	; 0
    5a3c:	4f 2f       	mov	r20, r31
    5a3e:	48 1b       	sub	r20, r24
    5a40:	81 e0       	ldi	r24, 0x01	; 1
    5a42:	f4 17       	cp	r31, r20
    5a44:	08 f0       	brcs	.+2      	; 0x5a48 <__divdi3+0x160>
    5a46:	80 e0       	ldi	r24, 0x00	; 0
    5a48:	98 2b       	or	r25, r24
    5a4a:	c1 94       	neg	r12
    5a4c:	81 e0       	ldi	r24, 0x01	; 1
    5a4e:	1c 14       	cp	r1, r12
    5a50:	08 f0       	brcs	.+2      	; 0x5a54 <__divdi3+0x16c>
    5a52:	80 e0       	ldi	r24, 0x00	; 0
    5a54:	6c 2d       	mov	r22, r12
    5a56:	69 1b       	sub	r22, r25
    5a58:	91 e0       	ldi	r25, 0x01	; 1
    5a5a:	c6 16       	cp	r12, r22
    5a5c:	08 f0       	brcs	.+2      	; 0x5a60 <__divdi3+0x178>
    5a5e:	90 e0       	ldi	r25, 0x00	; 0
    5a60:	89 2b       	or	r24, r25
    5a62:	d1 94       	neg	r13
    5a64:	91 e0       	ldi	r25, 0x01	; 1
    5a66:	1d 14       	cp	r1, r13
    5a68:	08 f0       	brcs	.+2      	; 0x5a6c <__divdi3+0x184>
    5a6a:	90 e0       	ldi	r25, 0x00	; 0
    5a6c:	5d 2d       	mov	r21, r13
    5a6e:	58 1b       	sub	r21, r24
    5a70:	81 e0       	ldi	r24, 0x01	; 1
    5a72:	d5 16       	cp	r13, r21
    5a74:	08 f0       	brcs	.+2      	; 0x5a78 <__divdi3+0x190>
    5a76:	80 e0       	ldi	r24, 0x00	; 0
    5a78:	98 2b       	or	r25, r24
    5a7a:	e1 94       	neg	r14
    5a7c:	81 e0       	ldi	r24, 0x01	; 1
    5a7e:	1e 14       	cp	r1, r14
    5a80:	08 f0       	brcs	.+2      	; 0x5a84 <__divdi3+0x19c>
    5a82:	80 e0       	ldi	r24, 0x00	; 0
    5a84:	3e 2d       	mov	r19, r14
    5a86:	39 1b       	sub	r19, r25
    5a88:	91 e0       	ldi	r25, 0x01	; 1
    5a8a:	e3 16       	cp	r14, r19
    5a8c:	08 f0       	brcs	.+2      	; 0x5a90 <__divdi3+0x1a8>
    5a8e:	90 e0       	ldi	r25, 0x00	; 0
    5a90:	89 2b       	or	r24, r25
    5a92:	f1 94       	neg	r15
    5a94:	91 e0       	ldi	r25, 0x01	; 1
    5a96:	1f 14       	cp	r1, r15
    5a98:	08 f0       	brcs	.+2      	; 0x5a9c <__divdi3+0x1b4>
    5a9a:	90 e0       	ldi	r25, 0x00	; 0
    5a9c:	2f 2d       	mov	r18, r15
    5a9e:	28 1b       	sub	r18, r24
    5aa0:	81 e0       	ldi	r24, 0x01	; 1
    5aa2:	f2 16       	cp	r15, r18
    5aa4:	08 f0       	brcs	.+2      	; 0x5aa8 <__divdi3+0x1c0>
    5aa6:	80 e0       	ldi	r24, 0x00	; 0
    5aa8:	98 2b       	or	r25, r24
    5aaa:	01 95       	neg	r16
    5aac:	81 e0       	ldi	r24, 0x01	; 1
    5aae:	10 16       	cp	r1, r16
    5ab0:	08 f0       	brcs	.+2      	; 0x5ab4 <__divdi3+0x1cc>
    5ab2:	80 e0       	ldi	r24, 0x00	; 0
    5ab4:	70 2f       	mov	r23, r16
    5ab6:	79 1b       	sub	r23, r25
    5ab8:	97 2f       	mov	r25, r23
    5aba:	71 e0       	ldi	r23, 0x01	; 1
    5abc:	09 17       	cp	r16, r25
    5abe:	08 f0       	brcs	.+2      	; 0x5ac2 <__divdi3+0x1da>
    5ac0:	70 e0       	ldi	r23, 0x00	; 0
    5ac2:	87 2b       	or	r24, r23
    5ac4:	11 95       	neg	r17
    5ac6:	18 1b       	sub	r17, r24
    5ac8:	e9 8f       	std	Y+25, r30	; 0x19
    5aca:	4a 8f       	std	Y+26, r20	; 0x1a
    5acc:	6b 8f       	std	Y+27, r22	; 0x1b
    5ace:	5c 8f       	std	Y+28, r21	; 0x1c
    5ad0:	3d 8f       	std	Y+29, r19	; 0x1d
    5ad2:	2e 8f       	std	Y+30, r18	; 0x1e
    5ad4:	9f 8f       	std	Y+31, r25	; 0x1f
    5ad6:	18 a3       	lds	r17, 0x58
    5ad8:	79 8d       	ldd	r23, Y+25	; 0x19
    5ada:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5adc:	5b 8d       	ldd	r21, Y+27	; 0x1b
    5ade:	4c 8d       	ldd	r20, Y+28	; 0x1c
    5ae0:	3d 8d       	ldd	r19, Y+29	; 0x1d
    5ae2:	2e 8d       	ldd	r18, Y+30	; 0x1e
    5ae4:	9f 8d       	ldd	r25, Y+31	; 0x1f
    5ae6:	88 a1       	lds	r24, 0x48
    5ae8:	e9 a1       	lds	r30, 0x49
    5aea:	e9 8b       	std	Y+17, r30	; 0x11
    5aec:	ea a1       	lds	r30, 0x4a
    5aee:	ea 8b       	std	Y+18, r30	; 0x12
    5af0:	eb a1       	lds	r30, 0x4b
    5af2:	eb 8b       	std	Y+19, r30	; 0x13
    5af4:	ec a1       	lds	r30, 0x4c
    5af6:	ec 8b       	std	Y+20, r30	; 0x14
    5af8:	ed a1       	lds	r30, 0x4d
    5afa:	ed 8b       	std	Y+21, r30	; 0x15
    5afc:	ee a1       	lds	r30, 0x4e
    5afe:	ee 8b       	std	Y+22, r30	; 0x16
    5b00:	ef a1       	lds	r30, 0x4f
    5b02:	ef 8b       	std	Y+23, r30	; 0x17
    5b04:	e8 a5       	lds	r30, 0x68
    5b06:	e8 8f       	std	Y+24, r30	; 0x18
    5b08:	79 87       	std	Y+9, r23	; 0x09
    5b0a:	6a 87       	std	Y+10, r22	; 0x0a
    5b0c:	5b 87       	std	Y+11, r21	; 0x0b
    5b0e:	4c 87       	std	Y+12, r20	; 0x0c
    5b10:	3d 87       	std	Y+13, r19	; 0x0d
    5b12:	2e 87       	std	Y+14, r18	; 0x0e
    5b14:	9f 87       	std	Y+15, r25	; 0x0f
    5b16:	88 8b       	std	Y+16, r24	; 0x10
    5b18:	89 84       	ldd	r8, Y+9	; 0x09
    5b1a:	9a 84       	ldd	r9, Y+10	; 0x0a
    5b1c:	ab 84       	ldd	r10, Y+11	; 0x0b
    5b1e:	bc 84       	ldd	r11, Y+12	; 0x0c
    5b20:	8d 85       	ldd	r24, Y+13	; 0x0d
    5b22:	9e 85       	ldd	r25, Y+14	; 0x0e
    5b24:	af 85       	ldd	r26, Y+15	; 0x0f
    5b26:	b8 89       	ldd	r27, Y+16	; 0x10
    5b28:	e9 88       	ldd	r14, Y+17	; 0x11
    5b2a:	fa 88       	ldd	r15, Y+18	; 0x12
    5b2c:	0b 89       	ldd	r16, Y+19	; 0x13
    5b2e:	1c 89       	ldd	r17, Y+20	; 0x14
    5b30:	ed aa       	sts	0x9d, r30
    5b32:	fe aa       	sts	0x9e, r31
    5b34:	0f ab       	sts	0x5f, r16
    5b36:	18 af       	sts	0x78, r17
    5b38:	cd 88       	ldd	r12, Y+21	; 0x15
    5b3a:	de 88       	ldd	r13, Y+22	; 0x16
    5b3c:	ef 88       	ldd	r14, Y+23	; 0x17
    5b3e:	f8 8c       	ldd	r15, Y+24	; 0x18
    5b40:	00 97       	sbiw	r24, 0x00	; 0
    5b42:	a1 05       	cpc	r26, r1
    5b44:	b1 05       	cpc	r27, r1
    5b46:	09 f0       	breq	.+2      	; 0x5b4a <__divdi3+0x262>
    5b48:	bd c3       	rjmp	.+1914   	; 0x62c4 <__stack+0x2c5>
    5b4a:	c8 14       	cp	r12, r8
    5b4c:	d9 04       	cpc	r13, r9
    5b4e:	ea 04       	cpc	r14, r10
    5b50:	fb 04       	cpc	r15, r11
    5b52:	08 f0       	brcs	.+2      	; 0x5b56 <__divdi3+0x26e>
    5b54:	4d c1       	rjmp	.+666    	; 0x5df0 <__divdi3+0x508>
    5b56:	00 e0       	ldi	r16, 0x00	; 0
    5b58:	80 16       	cp	r8, r16
    5b5a:	00 e0       	ldi	r16, 0x00	; 0
    5b5c:	90 06       	cpc	r9, r16
    5b5e:	01 e0       	ldi	r16, 0x01	; 1
    5b60:	a0 06       	cpc	r10, r16
    5b62:	00 e0       	ldi	r16, 0x00	; 0
    5b64:	b0 06       	cpc	r11, r16
    5b66:	58 f4       	brcc	.+22     	; 0x5b7e <__divdi3+0x296>
    5b68:	1f ef       	ldi	r17, 0xFF	; 255
    5b6a:	81 16       	cp	r8, r17
    5b6c:	91 04       	cpc	r9, r1
    5b6e:	a1 04       	cpc	r10, r1
    5b70:	b1 04       	cpc	r11, r1
    5b72:	09 f0       	breq	.+2      	; 0x5b76 <__divdi3+0x28e>
    5b74:	90 f4       	brcc	.+36     	; 0x5b9a <__divdi3+0x2b2>
    5b76:	80 e0       	ldi	r24, 0x00	; 0
    5b78:	90 e0       	ldi	r25, 0x00	; 0
    5b7a:	dc 01       	movw	r26, r24
    5b7c:	17 c0       	rjmp	.+46     	; 0x5bac <__divdi3+0x2c4>
    5b7e:	20 e0       	ldi	r18, 0x00	; 0
    5b80:	82 16       	cp	r8, r18
    5b82:	20 e0       	ldi	r18, 0x00	; 0
    5b84:	92 06       	cpc	r9, r18
    5b86:	20 e0       	ldi	r18, 0x00	; 0
    5b88:	a2 06       	cpc	r10, r18
    5b8a:	21 e0       	ldi	r18, 0x01	; 1
    5b8c:	b2 06       	cpc	r11, r18
    5b8e:	50 f4       	brcc	.+20     	; 0x5ba4 <__divdi3+0x2bc>
    5b90:	80 e1       	ldi	r24, 0x10	; 16
    5b92:	90 e0       	ldi	r25, 0x00	; 0
    5b94:	a0 e0       	ldi	r26, 0x00	; 0
    5b96:	b0 e0       	ldi	r27, 0x00	; 0
    5b98:	09 c0       	rjmp	.+18     	; 0x5bac <__divdi3+0x2c4>
    5b9a:	88 e0       	ldi	r24, 0x08	; 8
    5b9c:	90 e0       	ldi	r25, 0x00	; 0
    5b9e:	a0 e0       	ldi	r26, 0x00	; 0
    5ba0:	b0 e0       	ldi	r27, 0x00	; 0
    5ba2:	04 c0       	rjmp	.+8      	; 0x5bac <__divdi3+0x2c4>
    5ba4:	88 e1       	ldi	r24, 0x18	; 24
    5ba6:	90 e0       	ldi	r25, 0x00	; 0
    5ba8:	a0 e0       	ldi	r26, 0x00	; 0
    5baa:	b0 e0       	ldi	r27, 0x00	; 0
    5bac:	b5 01       	movw	r22, r10
    5bae:	a4 01       	movw	r20, r8
    5bb0:	08 2e       	mov	r0, r24
    5bb2:	04 c0       	rjmp	.+8      	; 0x5bbc <__divdi3+0x2d4>
    5bb4:	76 95       	lsr	r23
    5bb6:	67 95       	ror	r22
    5bb8:	57 95       	ror	r21
    5bba:	47 95       	ror	r20
    5bbc:	0a 94       	dec	r0
    5bbe:	d2 f7       	brpl	.-12     	; 0x5bb4 <__divdi3+0x2cc>
    5bc0:	fa 01       	movw	r30, r20
    5bc2:	e3 5f       	subi	r30, 0xF3	; 243
    5bc4:	ff 4d       	sbci	r31, 0xDF	; 223
    5bc6:	20 81       	ld	r18, Z
    5bc8:	40 e2       	ldi	r20, 0x20	; 32
    5bca:	50 e0       	ldi	r21, 0x00	; 0
    5bcc:	60 e0       	ldi	r22, 0x00	; 0
    5bce:	70 e0       	ldi	r23, 0x00	; 0
    5bd0:	48 1b       	sub	r20, r24
    5bd2:	59 0b       	sbc	r21, r25
    5bd4:	6a 0b       	sbc	r22, r26
    5bd6:	7b 0b       	sbc	r23, r27
    5bd8:	42 1b       	sub	r20, r18
    5bda:	51 09       	sbc	r21, r1
    5bdc:	61 09       	sbc	r22, r1
    5bde:	71 09       	sbc	r23, r1
    5be0:	41 15       	cp	r20, r1
    5be2:	51 05       	cpc	r21, r1
    5be4:	61 05       	cpc	r22, r1
    5be6:	71 05       	cpc	r23, r1
    5be8:	a1 f1       	breq	.+104    	; 0x5c52 <__divdi3+0x36a>
    5bea:	04 2e       	mov	r0, r20
    5bec:	04 c0       	rjmp	.+8      	; 0x5bf6 <__divdi3+0x30e>
    5bee:	88 0c       	add	r8, r8
    5bf0:	99 1c       	adc	r9, r9
    5bf2:	aa 1c       	adc	r10, r10
    5bf4:	bb 1c       	adc	r11, r11
    5bf6:	0a 94       	dec	r0
    5bf8:	d2 f7       	brpl	.-12     	; 0x5bee <__divdi3+0x306>
    5bfa:	97 01       	movw	r18, r14
    5bfc:	86 01       	movw	r16, r12
    5bfe:	04 2e       	mov	r0, r20
    5c00:	04 c0       	rjmp	.+8      	; 0x5c0a <__divdi3+0x322>
    5c02:	00 0f       	add	r16, r16
    5c04:	11 1f       	adc	r17, r17
    5c06:	22 1f       	adc	r18, r18
    5c08:	33 1f       	adc	r19, r19
    5c0a:	0a 94       	dec	r0
    5c0c:	d2 f7       	brpl	.-12     	; 0x5c02 <__divdi3+0x31a>
    5c0e:	80 e2       	ldi	r24, 0x20	; 32
    5c10:	90 e0       	ldi	r25, 0x00	; 0
    5c12:	84 1b       	sub	r24, r20
    5c14:	95 0b       	sbc	r25, r21
    5c16:	cd a8       	sts	0x8d, r28
    5c18:	de a8       	sts	0x8e, r29
    5c1a:	ef a8       	sts	0x8f, r30
    5c1c:	f8 ac       	sts	0xa8, r31
    5c1e:	04 c0       	rjmp	.+8      	; 0x5c28 <__divdi3+0x340>
    5c20:	f6 94       	lsr	r15
    5c22:	e7 94       	ror	r14
    5c24:	d7 94       	ror	r13
    5c26:	c7 94       	ror	r12
    5c28:	8a 95       	dec	r24
    5c2a:	d2 f7       	brpl	.-12     	; 0x5c20 <__divdi3+0x338>
    5c2c:	c0 2a       	or	r12, r16
    5c2e:	d1 2a       	or	r13, r17
    5c30:	e2 2a       	or	r14, r18
    5c32:	f3 2a       	or	r15, r19
    5c34:	0d a9       	sts	0x4d, r16
    5c36:	1e a9       	sts	0x4e, r17
    5c38:	2f a9       	sts	0x4f, r18
    5c3a:	38 ad       	sts	0x68, r19
    5c3c:	04 c0       	rjmp	.+8      	; 0x5c46 <__divdi3+0x35e>
    5c3e:	00 0f       	add	r16, r16
    5c40:	11 1f       	adc	r17, r17
    5c42:	22 1f       	adc	r18, r18
    5c44:	33 1f       	adc	r19, r19
    5c46:	4a 95       	dec	r20
    5c48:	d2 f7       	brpl	.-12     	; 0x5c3e <__divdi3+0x356>
    5c4a:	0d ab       	sts	0x5d, r16
    5c4c:	1e ab       	sts	0x5e, r17
    5c4e:	2f ab       	sts	0x5f, r18
    5c50:	38 af       	sts	0x78, r19
    5c52:	25 01       	movw	r4, r10
    5c54:	66 24       	eor	r6, r6
    5c56:	77 24       	eor	r7, r7
    5c58:	95 01       	movw	r18, r10
    5c5a:	84 01       	movw	r16, r8
    5c5c:	20 70       	andi	r18, 0x00	; 0
    5c5e:	30 70       	andi	r19, 0x00	; 0
    5c60:	09 ab       	sts	0x59, r16
    5c62:	1a ab       	sts	0x5a, r17
    5c64:	2b ab       	sts	0x5b, r18
    5c66:	3c ab       	sts	0x5c, r19
    5c68:	c7 01       	movw	r24, r14
    5c6a:	b6 01       	movw	r22, r12
    5c6c:	a3 01       	movw	r20, r6
    5c6e:	92 01       	movw	r18, r4
    5c70:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    5c74:	2d a7       	lds	r18, 0x7d
    5c76:	3e a7       	lds	r19, 0x7e
    5c78:	4f a7       	lds	r20, 0x7f
    5c7a:	58 ab       	sts	0x58, r21
    5c7c:	69 a7       	lds	r22, 0x79
    5c7e:	7a a7       	lds	r23, 0x7a
    5c80:	8b a7       	lds	r24, 0x7b
    5c82:	9c a7       	lds	r25, 0x7c
    5c84:	c7 01       	movw	r24, r14
    5c86:	b6 01       	movw	r22, r12
    5c88:	a3 01       	movw	r20, r6
    5c8a:	92 01       	movw	r18, r4
    5c8c:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    5c90:	ca 01       	movw	r24, r20
    5c92:	b9 01       	movw	r22, r18
    5c94:	29 a9       	sts	0x49, r18
    5c96:	3a a9       	sts	0x4a, r19
    5c98:	4b a9       	sts	0x4b, r20
    5c9a:	5c a9       	sts	0x4c, r21
    5c9c:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    5ca0:	ab 01       	movw	r20, r22
    5ca2:	bc 01       	movw	r22, r24
    5ca4:	09 a5       	lds	r16, 0x69
    5ca6:	1a a5       	lds	r17, 0x6a
    5ca8:	2b a5       	lds	r18, 0x6b
    5caa:	3c a5       	lds	r19, 0x6c
    5cac:	78 01       	movw	r14, r16
    5cae:	dd 24       	eor	r13, r13
    5cb0:	cc 24       	eor	r12, r12
    5cb2:	0d a9       	sts	0x4d, r16
    5cb4:	1e a9       	sts	0x4e, r17
    5cb6:	2f a9       	sts	0x4f, r18
    5cb8:	38 ad       	sts	0x68, r19
    5cba:	c9 01       	movw	r24, r18
    5cbc:	aa 27       	eor	r26, r26
    5cbe:	bb 27       	eor	r27, r27
    5cc0:	c8 2a       	or	r12, r24
    5cc2:	d9 2a       	or	r13, r25
    5cc4:	ea 2a       	or	r14, r26
    5cc6:	fb 2a       	or	r15, r27
    5cc8:	0d a5       	lds	r16, 0x6d
    5cca:	1e a5       	lds	r17, 0x6e
    5ccc:	2f a5       	lds	r18, 0x6f
    5cce:	38 a9       	sts	0x48, r19
    5cd0:	c4 16       	cp	r12, r20
    5cd2:	d5 06       	cpc	r13, r21
    5cd4:	e6 06       	cpc	r14, r22
    5cd6:	f7 06       	cpc	r15, r23
    5cd8:	38 f5       	brcc	.+78     	; 0x5d28 <__divdi3+0x440>
    5cda:	01 50       	subi	r16, 0x01	; 1
    5cdc:	10 40       	sbci	r17, 0x00	; 0
    5cde:	20 40       	sbci	r18, 0x00	; 0
    5ce0:	30 40       	sbci	r19, 0x00	; 0
    5ce2:	09 a7       	lds	r16, 0x79
    5ce4:	1a a7       	lds	r17, 0x7a
    5ce6:	2b a7       	lds	r18, 0x7b
    5ce8:	3c a7       	lds	r19, 0x7c
    5cea:	c8 0c       	add	r12, r8
    5cec:	d9 1c       	adc	r13, r9
    5cee:	ea 1c       	adc	r14, r10
    5cf0:	fb 1c       	adc	r15, r11
    5cf2:	c8 14       	cp	r12, r8
    5cf4:	d9 04       	cpc	r13, r9
    5cf6:	ea 04       	cpc	r14, r10
    5cf8:	fb 04       	cpc	r15, r11
    5cfa:	d0 f0       	brcs	.+52     	; 0x5d30 <__divdi3+0x448>
    5cfc:	c4 16       	cp	r12, r20
    5cfe:	d5 06       	cpc	r13, r21
    5d00:	e6 06       	cpc	r14, r22
    5d02:	f7 06       	cpc	r15, r23
    5d04:	a8 f4       	brcc	.+42     	; 0x5d30 <__divdi3+0x448>
    5d06:	0d a5       	lds	r16, 0x6d
    5d08:	1e a5       	lds	r17, 0x6e
    5d0a:	2f a5       	lds	r18, 0x6f
    5d0c:	38 a9       	sts	0x48, r19
    5d0e:	02 50       	subi	r16, 0x02	; 2
    5d10:	10 40       	sbci	r17, 0x00	; 0
    5d12:	20 40       	sbci	r18, 0x00	; 0
    5d14:	30 40       	sbci	r19, 0x00	; 0
    5d16:	09 a7       	lds	r16, 0x79
    5d18:	1a a7       	lds	r17, 0x7a
    5d1a:	2b a7       	lds	r18, 0x7b
    5d1c:	3c a7       	lds	r19, 0x7c
    5d1e:	c8 0c       	add	r12, r8
    5d20:	d9 1c       	adc	r13, r9
    5d22:	ea 1c       	adc	r14, r10
    5d24:	fb 1c       	adc	r15, r11
    5d26:	04 c0       	rjmp	.+8      	; 0x5d30 <__divdi3+0x448>
    5d28:	09 a7       	lds	r16, 0x79
    5d2a:	1a a7       	lds	r17, 0x7a
    5d2c:	2b a7       	lds	r18, 0x7b
    5d2e:	3c a7       	lds	r19, 0x7c
    5d30:	c4 1a       	sub	r12, r20
    5d32:	d5 0a       	sbc	r13, r21
    5d34:	e6 0a       	sbc	r14, r22
    5d36:	f7 0a       	sbc	r15, r23
    5d38:	c7 01       	movw	r24, r14
    5d3a:	b6 01       	movw	r22, r12
    5d3c:	a3 01       	movw	r20, r6
    5d3e:	92 01       	movw	r18, r4
    5d40:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    5d44:	2d a7       	lds	r18, 0x7d
    5d46:	3e a7       	lds	r19, 0x7e
    5d48:	4f a7       	lds	r20, 0x7f
    5d4a:	58 ab       	sts	0x58, r21
    5d4c:	69 af       	sts	0x79, r22
    5d4e:	7a af       	sts	0x7a, r23
    5d50:	8b af       	sts	0x7b, r24
    5d52:	9c af       	sts	0x7c, r25
    5d54:	c7 01       	movw	r24, r14
    5d56:	b6 01       	movw	r22, r12
    5d58:	a3 01       	movw	r20, r6
    5d5a:	92 01       	movw	r18, r4
    5d5c:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    5d60:	ca 01       	movw	r24, r20
    5d62:	b9 01       	movw	r22, r18
    5d64:	29 a9       	sts	0x49, r18
    5d66:	3a a9       	sts	0x4a, r19
    5d68:	4b a9       	sts	0x4b, r20
    5d6a:	5c a9       	sts	0x4c, r21
    5d6c:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    5d70:	6b 01       	movw	r12, r22
    5d72:	7c 01       	movw	r14, r24
    5d74:	49 ad       	sts	0x69, r20
    5d76:	5a ad       	sts	0x6a, r21
    5d78:	6b ad       	sts	0x6b, r22
    5d7a:	7c ad       	sts	0x6c, r23
    5d7c:	9a 01       	movw	r18, r20
    5d7e:	11 27       	eor	r17, r17
    5d80:	00 27       	eor	r16, r16
    5d82:	4d a9       	sts	0x4d, r20
    5d84:	5e a9       	sts	0x4e, r21
    5d86:	6f a9       	sts	0x4f, r22
    5d88:	78 ad       	sts	0x68, r23
    5d8a:	60 70       	andi	r22, 0x00	; 0
    5d8c:	70 70       	andi	r23, 0x00	; 0
    5d8e:	04 2b       	or	r16, r20
    5d90:	15 2b       	or	r17, r21
    5d92:	26 2b       	or	r18, r22
    5d94:	37 2b       	or	r19, r23
    5d96:	8d a5       	lds	r24, 0x6d
    5d98:	9e a5       	lds	r25, 0x6e
    5d9a:	af a5       	lds	r26, 0x6f
    5d9c:	b8 a9       	sts	0x48, r27
    5d9e:	0c 15       	cp	r16, r12
    5da0:	1d 05       	cpc	r17, r13
    5da2:	2e 05       	cpc	r18, r14
    5da4:	3f 05       	cpc	r19, r15
    5da6:	c0 f4       	brcc	.+48     	; 0x5dd8 <__divdi3+0x4f0>
    5da8:	01 97       	sbiw	r24, 0x01	; 1
    5daa:	a1 09       	sbc	r26, r1
    5dac:	b1 09       	sbc	r27, r1
    5dae:	08 0d       	add	r16, r8
    5db0:	19 1d       	adc	r17, r9
    5db2:	2a 1d       	adc	r18, r10
    5db4:	3b 1d       	adc	r19, r11
    5db6:	08 15       	cp	r16, r8
    5db8:	19 05       	cpc	r17, r9
    5dba:	2a 05       	cpc	r18, r10
    5dbc:	3b 05       	cpc	r19, r11
    5dbe:	60 f0       	brcs	.+24     	; 0x5dd8 <__divdi3+0x4f0>
    5dc0:	0c 15       	cp	r16, r12
    5dc2:	1d 05       	cpc	r17, r13
    5dc4:	2e 05       	cpc	r18, r14
    5dc6:	3f 05       	cpc	r19, r15
    5dc8:	38 f4       	brcc	.+14     	; 0x5dd8 <__divdi3+0x4f0>
    5dca:	8d a5       	lds	r24, 0x6d
    5dcc:	9e a5       	lds	r25, 0x6e
    5dce:	af a5       	lds	r26, 0x6f
    5dd0:	b8 a9       	sts	0x48, r27
    5dd2:	02 97       	sbiw	r24, 0x02	; 2
    5dd4:	a1 09       	sbc	r26, r1
    5dd6:	b1 09       	sbc	r27, r1
    5dd8:	09 a5       	lds	r16, 0x69
    5dda:	1a a5       	lds	r17, 0x6a
    5ddc:	2b a5       	lds	r18, 0x6b
    5dde:	3c a5       	lds	r19, 0x6c
    5de0:	78 01       	movw	r14, r16
    5de2:	dd 24       	eor	r13, r13
    5de4:	cc 24       	eor	r12, r12
    5de6:	c8 2a       	or	r12, r24
    5de8:	d9 2a       	or	r13, r25
    5dea:	ea 2a       	or	r14, r26
    5dec:	fb 2a       	or	r15, r27
    5dee:	b7 c4       	rjmp	.+2414   	; 0x675e <__stack+0x75f>
    5df0:	81 14       	cp	r8, r1
    5df2:	91 04       	cpc	r9, r1
    5df4:	a1 04       	cpc	r10, r1
    5df6:	b1 04       	cpc	r11, r1
    5df8:	51 f4       	brne	.+20     	; 0x5e0e <__divdi3+0x526>
    5dfa:	61 e0       	ldi	r22, 0x01	; 1
    5dfc:	70 e0       	ldi	r23, 0x00	; 0
    5dfe:	80 e0       	ldi	r24, 0x00	; 0
    5e00:	90 e0       	ldi	r25, 0x00	; 0
    5e02:	a5 01       	movw	r20, r10
    5e04:	94 01       	movw	r18, r8
    5e06:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    5e0a:	49 01       	movw	r8, r18
    5e0c:	5a 01       	movw	r10, r20
    5e0e:	10 e0       	ldi	r17, 0x00	; 0
    5e10:	81 16       	cp	r8, r17
    5e12:	10 e0       	ldi	r17, 0x00	; 0
    5e14:	91 06       	cpc	r9, r17
    5e16:	11 e0       	ldi	r17, 0x01	; 1
    5e18:	a1 06       	cpc	r10, r17
    5e1a:	10 e0       	ldi	r17, 0x00	; 0
    5e1c:	b1 06       	cpc	r11, r17
    5e1e:	58 f4       	brcc	.+22     	; 0x5e36 <__divdi3+0x54e>
    5e20:	2f ef       	ldi	r18, 0xFF	; 255
    5e22:	82 16       	cp	r8, r18
    5e24:	91 04       	cpc	r9, r1
    5e26:	a1 04       	cpc	r10, r1
    5e28:	b1 04       	cpc	r11, r1
    5e2a:	09 f0       	breq	.+2      	; 0x5e2e <__divdi3+0x546>
    5e2c:	90 f4       	brcc	.+36     	; 0x5e52 <__divdi3+0x56a>
    5e2e:	80 e0       	ldi	r24, 0x00	; 0
    5e30:	90 e0       	ldi	r25, 0x00	; 0
    5e32:	dc 01       	movw	r26, r24
    5e34:	17 c0       	rjmp	.+46     	; 0x5e64 <__divdi3+0x57c>
    5e36:	30 e0       	ldi	r19, 0x00	; 0
    5e38:	83 16       	cp	r8, r19
    5e3a:	30 e0       	ldi	r19, 0x00	; 0
    5e3c:	93 06       	cpc	r9, r19
    5e3e:	30 e0       	ldi	r19, 0x00	; 0
    5e40:	a3 06       	cpc	r10, r19
    5e42:	31 e0       	ldi	r19, 0x01	; 1
    5e44:	b3 06       	cpc	r11, r19
    5e46:	50 f4       	brcc	.+20     	; 0x5e5c <__divdi3+0x574>
    5e48:	80 e1       	ldi	r24, 0x10	; 16
    5e4a:	90 e0       	ldi	r25, 0x00	; 0
    5e4c:	a0 e0       	ldi	r26, 0x00	; 0
    5e4e:	b0 e0       	ldi	r27, 0x00	; 0
    5e50:	09 c0       	rjmp	.+18     	; 0x5e64 <__divdi3+0x57c>
    5e52:	88 e0       	ldi	r24, 0x08	; 8
    5e54:	90 e0       	ldi	r25, 0x00	; 0
    5e56:	a0 e0       	ldi	r26, 0x00	; 0
    5e58:	b0 e0       	ldi	r27, 0x00	; 0
    5e5a:	04 c0       	rjmp	.+8      	; 0x5e64 <__divdi3+0x57c>
    5e5c:	88 e1       	ldi	r24, 0x18	; 24
    5e5e:	90 e0       	ldi	r25, 0x00	; 0
    5e60:	a0 e0       	ldi	r26, 0x00	; 0
    5e62:	b0 e0       	ldi	r27, 0x00	; 0
    5e64:	b5 01       	movw	r22, r10
    5e66:	a4 01       	movw	r20, r8
    5e68:	08 2e       	mov	r0, r24
    5e6a:	04 c0       	rjmp	.+8      	; 0x5e74 <__divdi3+0x58c>
    5e6c:	76 95       	lsr	r23
    5e6e:	67 95       	ror	r22
    5e70:	57 95       	ror	r21
    5e72:	47 95       	ror	r20
    5e74:	0a 94       	dec	r0
    5e76:	d2 f7       	brpl	.-12     	; 0x5e6c <__divdi3+0x584>
    5e78:	fa 01       	movw	r30, r20
    5e7a:	e3 5f       	subi	r30, 0xF3	; 243
    5e7c:	ff 4d       	sbci	r31, 0xDF	; 223
    5e7e:	20 81       	ld	r18, Z
    5e80:	ac 01       	movw	r20, r24
    5e82:	bd 01       	movw	r22, r26
    5e84:	42 0f       	add	r20, r18
    5e86:	51 1d       	adc	r21, r1
    5e88:	61 1d       	adc	r22, r1
    5e8a:	71 1d       	adc	r23, r1
    5e8c:	80 e2       	ldi	r24, 0x20	; 32
    5e8e:	90 e0       	ldi	r25, 0x00	; 0
    5e90:	a0 e0       	ldi	r26, 0x00	; 0
    5e92:	b0 e0       	ldi	r27, 0x00	; 0
    5e94:	84 1b       	sub	r24, r20
    5e96:	95 0b       	sbc	r25, r21
    5e98:	a6 0b       	sbc	r26, r22
    5e9a:	b7 0b       	sbc	r27, r23
    5e9c:	51 f4       	brne	.+20     	; 0x5eb2 <__divdi3+0x5ca>
    5e9e:	c8 18       	sub	r12, r8
    5ea0:	d9 08       	sbc	r13, r9
    5ea2:	ea 08       	sbc	r14, r10
    5ea4:	fb 08       	sbc	r15, r11
    5ea6:	f1 e0       	ldi	r31, 0x01	; 1
    5ea8:	4f 2e       	mov	r4, r31
    5eaa:	51 2c       	mov	r5, r1
    5eac:	61 2c       	mov	r6, r1
    5eae:	71 2c       	mov	r7, r1
    5eb0:	28 c1       	rjmp	.+592    	; 0x6102 <__stack+0x103>
    5eb2:	08 2e       	mov	r0, r24
    5eb4:	04 c0       	rjmp	.+8      	; 0x5ebe <__divdi3+0x5d6>
    5eb6:	88 0c       	add	r8, r8
    5eb8:	99 1c       	adc	r9, r9
    5eba:	aa 1c       	adc	r10, r10
    5ebc:	bb 1c       	adc	r11, r11
    5ebe:	0a 94       	dec	r0
    5ec0:	d2 f7       	brpl	.-12     	; 0x5eb6 <__divdi3+0x5ce>
    5ec2:	97 01       	movw	r18, r14
    5ec4:	86 01       	movw	r16, r12
    5ec6:	04 2e       	mov	r0, r20
    5ec8:	04 c0       	rjmp	.+8      	; 0x5ed2 <__divdi3+0x5ea>
    5eca:	36 95       	lsr	r19
    5ecc:	27 95       	ror	r18
    5ece:	17 95       	ror	r17
    5ed0:	07 95       	ror	r16
    5ed2:	0a 94       	dec	r0
    5ed4:	d2 f7       	brpl	.-12     	; 0x5eca <__divdi3+0x5e2>
    5ed6:	09 ab       	sts	0x59, r16
    5ed8:	1a ab       	sts	0x5a, r17
    5eda:	2b ab       	sts	0x5b, r18
    5edc:	3c ab       	sts	0x5c, r19
    5ede:	97 01       	movw	r18, r14
    5ee0:	86 01       	movw	r16, r12
    5ee2:	08 2e       	mov	r0, r24
    5ee4:	04 c0       	rjmp	.+8      	; 0x5eee <__divdi3+0x606>
    5ee6:	00 0f       	add	r16, r16
    5ee8:	11 1f       	adc	r17, r17
    5eea:	22 1f       	adc	r18, r18
    5eec:	33 1f       	adc	r19, r19
    5eee:	0a 94       	dec	r0
    5ef0:	d2 f7       	brpl	.-12     	; 0x5ee6 <__divdi3+0x5fe>
    5ef2:	0d a7       	lds	r16, 0x7d
    5ef4:	1e a7       	lds	r17, 0x7e
    5ef6:	2f a7       	lds	r18, 0x7f
    5ef8:	38 ab       	sts	0x58, r19
    5efa:	ed a8       	sts	0x8d, r30
    5efc:	fe a8       	sts	0x8e, r31
    5efe:	0f a9       	sts	0x4f, r16
    5f00:	18 ad       	sts	0x68, r17
    5f02:	04 c0       	rjmp	.+8      	; 0x5f0c <__divdi3+0x624>
    5f04:	16 95       	lsr	r17
    5f06:	07 95       	ror	r16
    5f08:	f7 94       	ror	r15
    5f0a:	e7 94       	ror	r14
    5f0c:	4a 95       	dec	r20
    5f0e:	d2 f7       	brpl	.-12     	; 0x5f04 <__divdi3+0x61c>
    5f10:	b8 01       	movw	r22, r16
    5f12:	a7 01       	movw	r20, r14
    5f14:	0d a5       	lds	r16, 0x6d
    5f16:	1e a5       	lds	r17, 0x6e
    5f18:	2f a5       	lds	r18, 0x6f
    5f1a:	38 a9       	sts	0x48, r19
    5f1c:	04 2b       	or	r16, r20
    5f1e:	15 2b       	or	r17, r21
    5f20:	26 2b       	or	r18, r22
    5f22:	37 2b       	or	r19, r23
    5f24:	0d a7       	lds	r16, 0x7d
    5f26:	1e a7       	lds	r17, 0x7e
    5f28:	2f a7       	lds	r18, 0x7f
    5f2a:	38 ab       	sts	0x58, r19
    5f2c:	ed a8       	sts	0x8d, r30
    5f2e:	fe a8       	sts	0x8e, r31
    5f30:	0f a9       	sts	0x4f, r16
    5f32:	18 ad       	sts	0x68, r17
    5f34:	04 c0       	rjmp	.+8      	; 0x5f3e <__divdi3+0x656>
    5f36:	ee 0c       	add	r14, r14
    5f38:	ff 1c       	adc	r15, r15
    5f3a:	00 1f       	adc	r16, r16
    5f3c:	11 1f       	adc	r17, r17
    5f3e:	8a 95       	dec	r24
    5f40:	d2 f7       	brpl	.-12     	; 0x5f36 <__divdi3+0x64e>
    5f42:	ed aa       	sts	0x9d, r30
    5f44:	fe aa       	sts	0x9e, r31
    5f46:	0f ab       	sts	0x5f, r16
    5f48:	18 af       	sts	0x78, r17
    5f4a:	25 01       	movw	r4, r10
    5f4c:	66 24       	eor	r6, r6
    5f4e:	77 24       	eor	r7, r7
    5f50:	95 01       	movw	r18, r10
    5f52:	84 01       	movw	r16, r8
    5f54:	20 70       	andi	r18, 0x00	; 0
    5f56:	30 70       	andi	r19, 0x00	; 0
    5f58:	09 af       	sts	0x79, r16
    5f5a:	1a af       	sts	0x7a, r17
    5f5c:	2b af       	sts	0x7b, r18
    5f5e:	3c af       	sts	0x7c, r19
    5f60:	69 a9       	sts	0x49, r22
    5f62:	7a a9       	sts	0x4a, r23
    5f64:	8b a9       	sts	0x4b, r24
    5f66:	9c a9       	sts	0x4c, r25
    5f68:	a3 01       	movw	r20, r6
    5f6a:	92 01       	movw	r18, r4
    5f6c:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    5f70:	29 a7       	lds	r18, 0x79
    5f72:	3a a7       	lds	r19, 0x7a
    5f74:	4b a7       	lds	r20, 0x7b
    5f76:	5c a7       	lds	r21, 0x7c
    5f78:	6b 01       	movw	r12, r22
    5f7a:	7c 01       	movw	r14, r24
    5f7c:	69 a9       	sts	0x49, r22
    5f7e:	7a a9       	sts	0x4a, r23
    5f80:	8b a9       	sts	0x4b, r24
    5f82:	9c a9       	sts	0x4c, r25
    5f84:	a3 01       	movw	r20, r6
    5f86:	92 01       	movw	r18, r4
    5f88:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    5f8c:	ca 01       	movw	r24, r20
    5f8e:	b9 01       	movw	r22, r18
    5f90:	29 ad       	sts	0x69, r18
    5f92:	3a ad       	sts	0x6a, r19
    5f94:	4b ad       	sts	0x6b, r20
    5f96:	5c ad       	sts	0x6c, r21
    5f98:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    5f9c:	ab 01       	movw	r20, r22
    5f9e:	bc 01       	movw	r22, r24
    5fa0:	76 01       	movw	r14, r12
    5fa2:	dd 24       	eor	r13, r13
    5fa4:	cc 24       	eor	r12, r12
    5fa6:	0d a5       	lds	r16, 0x6d
    5fa8:	1e a5       	lds	r17, 0x6e
    5faa:	2f a5       	lds	r18, 0x6f
    5fac:	38 a9       	sts	0x48, r19
    5fae:	c9 01       	movw	r24, r18
    5fb0:	aa 27       	eor	r26, r26
    5fb2:	bb 27       	eor	r27, r27
    5fb4:	c8 2a       	or	r12, r24
    5fb6:	d9 2a       	or	r13, r25
    5fb8:	ea 2a       	or	r14, r26
    5fba:	fb 2a       	or	r15, r27
    5fbc:	09 a5       	lds	r16, 0x69
    5fbe:	1a a5       	lds	r17, 0x6a
    5fc0:	2b a5       	lds	r18, 0x6b
    5fc2:	3c a5       	lds	r19, 0x6c
    5fc4:	c4 16       	cp	r12, r20
    5fc6:	d5 06       	cpc	r13, r21
    5fc8:	e6 06       	cpc	r14, r22
    5fca:	f7 06       	cpc	r15, r23
    5fcc:	38 f5       	brcc	.+78     	; 0x601c <__stack+0x1d>
    5fce:	01 50       	subi	r16, 0x01	; 1
    5fd0:	10 40       	sbci	r17, 0x00	; 0
    5fd2:	20 40       	sbci	r18, 0x00	; 0
    5fd4:	30 40       	sbci	r19, 0x00	; 0
    5fd6:	09 ab       	sts	0x59, r16
    5fd8:	1a ab       	sts	0x5a, r17
    5fda:	2b ab       	sts	0x5b, r18
    5fdc:	3c ab       	sts	0x5c, r19
    5fde:	c8 0c       	add	r12, r8
    5fe0:	d9 1c       	adc	r13, r9
    5fe2:	ea 1c       	adc	r14, r10
    5fe4:	fb 1c       	adc	r15, r11
    5fe6:	c8 14       	cp	r12, r8
    5fe8:	d9 04       	cpc	r13, r9
    5fea:	ea 04       	cpc	r14, r10
    5fec:	fb 04       	cpc	r15, r11
    5fee:	d0 f0       	brcs	.+52     	; 0x6024 <__stack+0x25>
    5ff0:	c4 16       	cp	r12, r20
    5ff2:	d5 06       	cpc	r13, r21
    5ff4:	e6 06       	cpc	r14, r22
    5ff6:	f7 06       	cpc	r15, r23
    5ff8:	a8 f4       	brcc	.+42     	; 0x6024 <__stack+0x25>
    5ffa:	09 a5       	lds	r16, 0x69
    5ffc:	1a a5       	lds	r17, 0x6a
    5ffe:	2b a5       	lds	r18, 0x6b
    6000:	3c a5       	lds	r19, 0x6c
    6002:	02 50       	subi	r16, 0x02	; 2
    6004:	10 40       	sbci	r17, 0x00	; 0
    6006:	20 40       	sbci	r18, 0x00	; 0
    6008:	30 40       	sbci	r19, 0x00	; 0
    600a:	09 ab       	sts	0x59, r16
    600c:	1a ab       	sts	0x5a, r17
    600e:	2b ab       	sts	0x5b, r18
    6010:	3c ab       	sts	0x5c, r19
    6012:	c8 0c       	add	r12, r8
    6014:	d9 1c       	adc	r13, r9
    6016:	ea 1c       	adc	r14, r10
    6018:	fb 1c       	adc	r15, r11
    601a:	04 c0       	rjmp	.+8      	; 0x6024 <__stack+0x25>
    601c:	09 ab       	sts	0x59, r16
    601e:	1a ab       	sts	0x5a, r17
    6020:	2b ab       	sts	0x5b, r18
    6022:	3c ab       	sts	0x5c, r19
    6024:	c4 1a       	sub	r12, r20
    6026:	d5 0a       	sbc	r13, r21
    6028:	e6 0a       	sbc	r14, r22
    602a:	f7 0a       	sbc	r15, r23
    602c:	c7 01       	movw	r24, r14
    602e:	b6 01       	movw	r22, r12
    6030:	a3 01       	movw	r20, r6
    6032:	92 01       	movw	r18, r4
    6034:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    6038:	29 a7       	lds	r18, 0x79
    603a:	3a a7       	lds	r19, 0x7a
    603c:	4b a7       	lds	r20, 0x7b
    603e:	5c a7       	lds	r21, 0x7c
    6040:	21 96       	adiw	r28, 0x01	; 1
    6042:	6c af       	sts	0x7c, r22
    6044:	7d af       	sts	0x7d, r23
    6046:	8e af       	sts	0x7e, r24
    6048:	9f af       	sts	0x7f, r25
    604a:	21 97       	sbiw	r28, 0x01	; 1
    604c:	c7 01       	movw	r24, r14
    604e:	b6 01       	movw	r22, r12
    6050:	a3 01       	movw	r20, r6
    6052:	92 01       	movw	r18, r4
    6054:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    6058:	ca 01       	movw	r24, r20
    605a:	b9 01       	movw	r22, r18
    605c:	29 ad       	sts	0x69, r18
    605e:	3a ad       	sts	0x6a, r19
    6060:	4b ad       	sts	0x6b, r20
    6062:	5c ad       	sts	0x6c, r21
    6064:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    6068:	8b 01       	movw	r16, r22
    606a:	9c 01       	movw	r18, r24
    606c:	21 96       	adiw	r28, 0x01	; 1
    606e:	4c ad       	sts	0x6c, r20
    6070:	5d ad       	sts	0x6d, r21
    6072:	6e ad       	sts	0x6e, r22
    6074:	7f ad       	sts	0x6f, r23
    6076:	21 97       	sbiw	r28, 0x01	; 1
    6078:	da 01       	movw	r26, r20
    607a:	99 27       	eor	r25, r25
    607c:	88 27       	eor	r24, r24
    607e:	4d a5       	lds	r20, 0x6d
    6080:	5e a5       	lds	r21, 0x6e
    6082:	6f a5       	lds	r22, 0x6f
    6084:	78 a9       	sts	0x48, r23
    6086:	60 70       	andi	r22, 0x00	; 0
    6088:	70 70       	andi	r23, 0x00	; 0
    608a:	84 2b       	or	r24, r20
    608c:	95 2b       	or	r25, r21
    608e:	a6 2b       	or	r26, r22
    6090:	b7 2b       	or	r27, r23
    6092:	49 a5       	lds	r20, 0x69
    6094:	5a a5       	lds	r21, 0x6a
    6096:	6b a5       	lds	r22, 0x6b
    6098:	7c a5       	lds	r23, 0x6c
    609a:	80 17       	cp	r24, r16
    609c:	91 07       	cpc	r25, r17
    609e:	a2 07       	cpc	r26, r18
    60a0:	b3 07       	cpc	r27, r19
    60a2:	f0 f4       	brcc	.+60     	; 0x60e0 <__stack+0xe1>
    60a4:	41 50       	subi	r20, 0x01	; 1
    60a6:	50 40       	sbci	r21, 0x00	; 0
    60a8:	60 40       	sbci	r22, 0x00	; 0
    60aa:	70 40       	sbci	r23, 0x00	; 0
    60ac:	88 0d       	add	r24, r8
    60ae:	99 1d       	adc	r25, r9
    60b0:	aa 1d       	adc	r26, r10
    60b2:	bb 1d       	adc	r27, r11
    60b4:	88 15       	cp	r24, r8
    60b6:	99 05       	cpc	r25, r9
    60b8:	aa 05       	cpc	r26, r10
    60ba:	bb 05       	cpc	r27, r11
    60bc:	88 f0       	brcs	.+34     	; 0x60e0 <__stack+0xe1>
    60be:	80 17       	cp	r24, r16
    60c0:	91 07       	cpc	r25, r17
    60c2:	a2 07       	cpc	r26, r18
    60c4:	b3 07       	cpc	r27, r19
    60c6:	60 f4       	brcc	.+24     	; 0x60e0 <__stack+0xe1>
    60c8:	49 a5       	lds	r20, 0x69
    60ca:	5a a5       	lds	r21, 0x6a
    60cc:	6b a5       	lds	r22, 0x6b
    60ce:	7c a5       	lds	r23, 0x6c
    60d0:	42 50       	subi	r20, 0x02	; 2
    60d2:	50 40       	sbci	r21, 0x00	; 0
    60d4:	60 40       	sbci	r22, 0x00	; 0
    60d6:	70 40       	sbci	r23, 0x00	; 0
    60d8:	88 0d       	add	r24, r8
    60da:	99 1d       	adc	r25, r9
    60dc:	aa 1d       	adc	r26, r10
    60de:	bb 1d       	adc	r27, r11
    60e0:	6c 01       	movw	r12, r24
    60e2:	7d 01       	movw	r14, r26
    60e4:	c0 1a       	sub	r12, r16
    60e6:	d1 0a       	sbc	r13, r17
    60e8:	e2 0a       	sbc	r14, r18
    60ea:	f3 0a       	sbc	r15, r19
    60ec:	09 a9       	sts	0x49, r16
    60ee:	1a a9       	sts	0x4a, r17
    60f0:	2b a9       	sts	0x4b, r18
    60f2:	3c a9       	sts	0x4c, r19
    60f4:	38 01       	movw	r6, r16
    60f6:	55 24       	eor	r5, r5
    60f8:	44 24       	eor	r4, r4
    60fa:	44 2a       	or	r4, r20
    60fc:	55 2a       	or	r5, r21
    60fe:	66 2a       	or	r6, r22
    6100:	77 2a       	or	r7, r23
    6102:	85 01       	movw	r16, r10
    6104:	22 27       	eor	r18, r18
    6106:	33 27       	eor	r19, r19
    6108:	0d a7       	lds	r16, 0x7d
    610a:	1e a7       	lds	r17, 0x7e
    610c:	2f a7       	lds	r18, 0x7f
    610e:	38 ab       	sts	0x58, r19
    6110:	95 01       	movw	r18, r10
    6112:	84 01       	movw	r16, r8
    6114:	20 70       	andi	r18, 0x00	; 0
    6116:	30 70       	andi	r19, 0x00	; 0
    6118:	09 af       	sts	0x79, r16
    611a:	1a af       	sts	0x7a, r17
    611c:	2b af       	sts	0x7b, r18
    611e:	3c af       	sts	0x7c, r19
    6120:	c7 01       	movw	r24, r14
    6122:	b6 01       	movw	r22, r12
    6124:	2d a5       	lds	r18, 0x6d
    6126:	3e a5       	lds	r19, 0x6e
    6128:	4f a5       	lds	r20, 0x6f
    612a:	58 a9       	sts	0x48, r21
    612c:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    6130:	29 a7       	lds	r18, 0x79
    6132:	3a a7       	lds	r19, 0x7a
    6134:	4b a7       	lds	r20, 0x7b
    6136:	5c a7       	lds	r21, 0x7c
    6138:	69 ab       	sts	0x59, r22
    613a:	7a ab       	sts	0x5a, r23
    613c:	8b ab       	sts	0x5b, r24
    613e:	9c ab       	sts	0x5c, r25
    6140:	c7 01       	movw	r24, r14
    6142:	b6 01       	movw	r22, r12
    6144:	2d a5       	lds	r18, 0x6d
    6146:	3e a5       	lds	r19, 0x6e
    6148:	4f a5       	lds	r20, 0x6f
    614a:	58 a9       	sts	0x48, r21
    614c:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    6150:	ca 01       	movw	r24, r20
    6152:	b9 01       	movw	r22, r18
    6154:	29 ad       	sts	0x69, r18
    6156:	3a ad       	sts	0x6a, r19
    6158:	4b ad       	sts	0x6b, r20
    615a:	5c ad       	sts	0x6c, r21
    615c:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    6160:	ab 01       	movw	r20, r22
    6162:	bc 01       	movw	r22, r24
    6164:	09 a9       	sts	0x49, r16
    6166:	1a a9       	sts	0x4a, r17
    6168:	2b a9       	sts	0x4b, r18
    616a:	3c a9       	sts	0x4c, r19
    616c:	78 01       	movw	r14, r16
    616e:	dd 24       	eor	r13, r13
    6170:	cc 24       	eor	r12, r12
    6172:	0d a9       	sts	0x4d, r16
    6174:	1e a9       	sts	0x4e, r17
    6176:	2f a9       	sts	0x4f, r18
    6178:	38 ad       	sts	0x68, r19
    617a:	c9 01       	movw	r24, r18
    617c:	aa 27       	eor	r26, r26
    617e:	bb 27       	eor	r27, r27
    6180:	c8 2a       	or	r12, r24
    6182:	d9 2a       	or	r13, r25
    6184:	ea 2a       	or	r14, r26
    6186:	fb 2a       	or	r15, r27
    6188:	09 a5       	lds	r16, 0x69
    618a:	1a a5       	lds	r17, 0x6a
    618c:	2b a5       	lds	r18, 0x6b
    618e:	3c a5       	lds	r19, 0x6c
    6190:	c4 16       	cp	r12, r20
    6192:	d5 06       	cpc	r13, r21
    6194:	e6 06       	cpc	r14, r22
    6196:	f7 06       	cpc	r15, r23
    6198:	38 f5       	brcc	.+78     	; 0x61e8 <__stack+0x1e9>
    619a:	01 50       	subi	r16, 0x01	; 1
    619c:	10 40       	sbci	r17, 0x00	; 0
    619e:	20 40       	sbci	r18, 0x00	; 0
    61a0:	30 40       	sbci	r19, 0x00	; 0
    61a2:	09 ab       	sts	0x59, r16
    61a4:	1a ab       	sts	0x5a, r17
    61a6:	2b ab       	sts	0x5b, r18
    61a8:	3c ab       	sts	0x5c, r19
    61aa:	c8 0c       	add	r12, r8
    61ac:	d9 1c       	adc	r13, r9
    61ae:	ea 1c       	adc	r14, r10
    61b0:	fb 1c       	adc	r15, r11
    61b2:	c8 14       	cp	r12, r8
    61b4:	d9 04       	cpc	r13, r9
    61b6:	ea 04       	cpc	r14, r10
    61b8:	fb 04       	cpc	r15, r11
    61ba:	d0 f0       	brcs	.+52     	; 0x61f0 <__stack+0x1f1>
    61bc:	c4 16       	cp	r12, r20
    61be:	d5 06       	cpc	r13, r21
    61c0:	e6 06       	cpc	r14, r22
    61c2:	f7 06       	cpc	r15, r23
    61c4:	a8 f4       	brcc	.+42     	; 0x61f0 <__stack+0x1f1>
    61c6:	09 a5       	lds	r16, 0x69
    61c8:	1a a5       	lds	r17, 0x6a
    61ca:	2b a5       	lds	r18, 0x6b
    61cc:	3c a5       	lds	r19, 0x6c
    61ce:	02 50       	subi	r16, 0x02	; 2
    61d0:	10 40       	sbci	r17, 0x00	; 0
    61d2:	20 40       	sbci	r18, 0x00	; 0
    61d4:	30 40       	sbci	r19, 0x00	; 0
    61d6:	09 ab       	sts	0x59, r16
    61d8:	1a ab       	sts	0x5a, r17
    61da:	2b ab       	sts	0x5b, r18
    61dc:	3c ab       	sts	0x5c, r19
    61de:	c8 0c       	add	r12, r8
    61e0:	d9 1c       	adc	r13, r9
    61e2:	ea 1c       	adc	r14, r10
    61e4:	fb 1c       	adc	r15, r11
    61e6:	04 c0       	rjmp	.+8      	; 0x61f0 <__stack+0x1f1>
    61e8:	09 ab       	sts	0x59, r16
    61ea:	1a ab       	sts	0x5a, r17
    61ec:	2b ab       	sts	0x5b, r18
    61ee:	3c ab       	sts	0x5c, r19
    61f0:	c4 1a       	sub	r12, r20
    61f2:	d5 0a       	sbc	r13, r21
    61f4:	e6 0a       	sbc	r14, r22
    61f6:	f7 0a       	sbc	r15, r23
    61f8:	c7 01       	movw	r24, r14
    61fa:	b6 01       	movw	r22, r12
    61fc:	2d a5       	lds	r18, 0x6d
    61fe:	3e a5       	lds	r19, 0x6e
    6200:	4f a5       	lds	r20, 0x6f
    6202:	58 a9       	sts	0x48, r21
    6204:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    6208:	29 a7       	lds	r18, 0x79
    620a:	3a a7       	lds	r19, 0x7a
    620c:	4b a7       	lds	r20, 0x7b
    620e:	5c a7       	lds	r21, 0x7c
    6210:	21 96       	adiw	r28, 0x01	; 1
    6212:	6c af       	sts	0x7c, r22
    6214:	7d af       	sts	0x7d, r23
    6216:	8e af       	sts	0x7e, r24
    6218:	9f af       	sts	0x7f, r25
    621a:	21 97       	sbiw	r28, 0x01	; 1
    621c:	c7 01       	movw	r24, r14
    621e:	b6 01       	movw	r22, r12
    6220:	2d a5       	lds	r18, 0x6d
    6222:	3e a5       	lds	r19, 0x6e
    6224:	4f a5       	lds	r20, 0x6f
    6226:	58 a9       	sts	0x48, r21
    6228:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    622c:	ca 01       	movw	r24, r20
    622e:	b9 01       	movw	r22, r18
    6230:	29 ad       	sts	0x69, r18
    6232:	3a ad       	sts	0x6a, r19
    6234:	4b ad       	sts	0x6b, r20
    6236:	5c ad       	sts	0x6c, r21
    6238:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    623c:	8b 01       	movw	r16, r22
    623e:	9c 01       	movw	r18, r24
    6240:	21 96       	adiw	r28, 0x01	; 1
    6242:	4c ad       	sts	0x6c, r20
    6244:	5d ad       	sts	0x6d, r21
    6246:	6e ad       	sts	0x6e, r22
    6248:	7f ad       	sts	0x6f, r23
    624a:	21 97       	sbiw	r28, 0x01	; 1
    624c:	da 01       	movw	r26, r20
    624e:	99 27       	eor	r25, r25
    6250:	88 27       	eor	r24, r24
    6252:	4d a9       	sts	0x4d, r20
    6254:	5e a9       	sts	0x4e, r21
    6256:	6f a9       	sts	0x4f, r22
    6258:	78 ad       	sts	0x68, r23
    625a:	60 70       	andi	r22, 0x00	; 0
    625c:	70 70       	andi	r23, 0x00	; 0
    625e:	84 2b       	or	r24, r20
    6260:	95 2b       	or	r25, r21
    6262:	a6 2b       	or	r26, r22
    6264:	b7 2b       	or	r27, r23
    6266:	49 a5       	lds	r20, 0x69
    6268:	5a a5       	lds	r21, 0x6a
    626a:	6b a5       	lds	r22, 0x6b
    626c:	7c a5       	lds	r23, 0x6c
    626e:	80 17       	cp	r24, r16
    6270:	91 07       	cpc	r25, r17
    6272:	a2 07       	cpc	r26, r18
    6274:	b3 07       	cpc	r27, r19
    6276:	d0 f4       	brcc	.+52     	; 0x62ac <__stack+0x2ad>
    6278:	41 50       	subi	r20, 0x01	; 1
    627a:	50 40       	sbci	r21, 0x00	; 0
    627c:	60 40       	sbci	r22, 0x00	; 0
    627e:	70 40       	sbci	r23, 0x00	; 0
    6280:	88 0d       	add	r24, r8
    6282:	99 1d       	adc	r25, r9
    6284:	aa 1d       	adc	r26, r10
    6286:	bb 1d       	adc	r27, r11
    6288:	88 15       	cp	r24, r8
    628a:	99 05       	cpc	r25, r9
    628c:	aa 05       	cpc	r26, r10
    628e:	bb 05       	cpc	r27, r11
    6290:	68 f0       	brcs	.+26     	; 0x62ac <__stack+0x2ad>
    6292:	80 17       	cp	r24, r16
    6294:	91 07       	cpc	r25, r17
    6296:	a2 07       	cpc	r26, r18
    6298:	b3 07       	cpc	r27, r19
    629a:	40 f4       	brcc	.+16     	; 0x62ac <__stack+0x2ad>
    629c:	49 a5       	lds	r20, 0x69
    629e:	5a a5       	lds	r21, 0x6a
    62a0:	6b a5       	lds	r22, 0x6b
    62a2:	7c a5       	lds	r23, 0x6c
    62a4:	42 50       	subi	r20, 0x02	; 2
    62a6:	50 40       	sbci	r21, 0x00	; 0
    62a8:	60 40       	sbci	r22, 0x00	; 0
    62aa:	70 40       	sbci	r23, 0x00	; 0
    62ac:	09 a9       	sts	0x49, r16
    62ae:	1a a9       	sts	0x4a, r17
    62b0:	2b a9       	sts	0x4b, r18
    62b2:	3c a9       	sts	0x4c, r19
    62b4:	78 01       	movw	r14, r16
    62b6:	dd 24       	eor	r13, r13
    62b8:	cc 24       	eor	r12, r12
    62ba:	c4 2a       	or	r12, r20
    62bc:	d5 2a       	or	r13, r21
    62be:	e6 2a       	or	r14, r22
    62c0:	f7 2a       	or	r15, r23
    62c2:	50 c2       	rjmp	.+1184   	; 0x6764 <__stack+0x765>
    62c4:	c8 16       	cp	r12, r24
    62c6:	d9 06       	cpc	r13, r25
    62c8:	ea 06       	cpc	r14, r26
    62ca:	fb 06       	cpc	r15, r27
    62cc:	08 f4       	brcc	.+2      	; 0x62d0 <__stack+0x2d1>
    62ce:	37 c2       	rjmp	.+1134   	; 0x673e <__stack+0x73f>
    62d0:	80 30       	cpi	r24, 0x00	; 0
    62d2:	10 e0       	ldi	r17, 0x00	; 0
    62d4:	91 07       	cpc	r25, r17
    62d6:	11 e0       	ldi	r17, 0x01	; 1
    62d8:	a1 07       	cpc	r26, r17
    62da:	10 e0       	ldi	r17, 0x00	; 0
    62dc:	b1 07       	cpc	r27, r17
    62de:	50 f4       	brcc	.+20     	; 0x62f4 <__stack+0x2f5>
    62e0:	8f 3f       	cpi	r24, 0xFF	; 255
    62e2:	91 05       	cpc	r25, r1
    62e4:	a1 05       	cpc	r26, r1
    62e6:	b1 05       	cpc	r27, r1
    62e8:	09 f0       	breq	.+2      	; 0x62ec <__stack+0x2ed>
    62ea:	88 f4       	brcc	.+34     	; 0x630e <__stack+0x30f>
    62ec:	00 e0       	ldi	r16, 0x00	; 0
    62ee:	10 e0       	ldi	r17, 0x00	; 0
    62f0:	98 01       	movw	r18, r16
    62f2:	16 c0       	rjmp	.+44     	; 0x6320 <__stack+0x321>
    62f4:	80 30       	cpi	r24, 0x00	; 0
    62f6:	20 e0       	ldi	r18, 0x00	; 0
    62f8:	92 07       	cpc	r25, r18
    62fa:	20 e0       	ldi	r18, 0x00	; 0
    62fc:	a2 07       	cpc	r26, r18
    62fe:	21 e0       	ldi	r18, 0x01	; 1
    6300:	b2 07       	cpc	r27, r18
    6302:	50 f4       	brcc	.+20     	; 0x6318 <__stack+0x319>
    6304:	00 e1       	ldi	r16, 0x10	; 16
    6306:	10 e0       	ldi	r17, 0x00	; 0
    6308:	20 e0       	ldi	r18, 0x00	; 0
    630a:	30 e0       	ldi	r19, 0x00	; 0
    630c:	09 c0       	rjmp	.+18     	; 0x6320 <__stack+0x321>
    630e:	08 e0       	ldi	r16, 0x08	; 8
    6310:	10 e0       	ldi	r17, 0x00	; 0
    6312:	20 e0       	ldi	r18, 0x00	; 0
    6314:	30 e0       	ldi	r19, 0x00	; 0
    6316:	04 c0       	rjmp	.+8      	; 0x6320 <__stack+0x321>
    6318:	08 e1       	ldi	r16, 0x18	; 24
    631a:	10 e0       	ldi	r17, 0x00	; 0
    631c:	20 e0       	ldi	r18, 0x00	; 0
    631e:	30 e0       	ldi	r19, 0x00	; 0
    6320:	ac 01       	movw	r20, r24
    6322:	bd 01       	movw	r22, r26
    6324:	00 2e       	mov	r0, r16
    6326:	04 c0       	rjmp	.+8      	; 0x6330 <__stack+0x331>
    6328:	76 95       	lsr	r23
    632a:	67 95       	ror	r22
    632c:	57 95       	ror	r21
    632e:	47 95       	ror	r20
    6330:	0a 94       	dec	r0
    6332:	d2 f7       	brpl	.-12     	; 0x6328 <__stack+0x329>
    6334:	fa 01       	movw	r30, r20
    6336:	e3 5f       	subi	r30, 0xF3	; 243
    6338:	ff 4d       	sbci	r31, 0xDF	; 223
    633a:	40 81       	ld	r20, Z
    633c:	04 0f       	add	r16, r20
    633e:	11 1d       	adc	r17, r1
    6340:	21 1d       	adc	r18, r1
    6342:	31 1d       	adc	r19, r1
    6344:	40 e2       	ldi	r20, 0x20	; 32
    6346:	50 e0       	ldi	r21, 0x00	; 0
    6348:	60 e0       	ldi	r22, 0x00	; 0
    634a:	70 e0       	ldi	r23, 0x00	; 0
    634c:	40 1b       	sub	r20, r16
    634e:	51 0b       	sbc	r21, r17
    6350:	62 0b       	sbc	r22, r18
    6352:	73 0b       	sbc	r23, r19
    6354:	a1 f4       	brne	.+40     	; 0x637e <__stack+0x37f>
    6356:	8c 15       	cp	r24, r12
    6358:	9d 05       	cpc	r25, r13
    635a:	ae 05       	cpc	r26, r14
    635c:	bf 05       	cpc	r27, r15
    635e:	08 f4       	brcc	.+2      	; 0x6362 <__stack+0x363>
    6360:	f5 c1       	rjmp	.+1002   	; 0x674c <__stack+0x74d>
    6362:	ed a8       	sts	0x8d, r30
    6364:	fe a8       	sts	0x8e, r31
    6366:	0f a9       	sts	0x4f, r16
    6368:	18 ad       	sts	0x68, r17
    636a:	44 24       	eor	r4, r4
    636c:	55 24       	eor	r5, r5
    636e:	32 01       	movw	r6, r4
    6370:	e8 14       	cp	r14, r8
    6372:	f9 04       	cpc	r15, r9
    6374:	0a 05       	cpc	r16, r10
    6376:	1b 05       	cpc	r17, r11
    6378:	08 f0       	brcs	.+2      	; 0x637c <__stack+0x37d>
    637a:	eb c1       	rjmp	.+982    	; 0x6752 <__stack+0x753>
    637c:	e3 c1       	rjmp	.+966    	; 0x6744 <__stack+0x745>
    637e:	34 2e       	mov	r3, r20
    6380:	2c 01       	movw	r4, r24
    6382:	3d 01       	movw	r6, r26
    6384:	04 c0       	rjmp	.+8      	; 0x638e <__stack+0x38f>
    6386:	44 0c       	add	r4, r4
    6388:	55 1c       	adc	r5, r5
    638a:	66 1c       	adc	r6, r6
    638c:	77 1c       	adc	r7, r7
    638e:	4a 95       	dec	r20
    6390:	d2 f7       	brpl	.-12     	; 0x6386 <__stack+0x387>
    6392:	d5 01       	movw	r26, r10
    6394:	c4 01       	movw	r24, r8
    6396:	00 2e       	mov	r0, r16
    6398:	04 c0       	rjmp	.+8      	; 0x63a2 <__stack+0x3a3>
    639a:	b6 95       	lsr	r27
    639c:	a7 95       	ror	r26
    639e:	97 95       	ror	r25
    63a0:	87 95       	ror	r24
    63a2:	0a 94       	dec	r0
    63a4:	d2 f7       	brpl	.-12     	; 0x639a <__stack+0x39b>
    63a6:	48 2a       	or	r4, r24
    63a8:	59 2a       	or	r5, r25
    63aa:	6a 2a       	or	r6, r26
    63ac:	7b 2a       	or	r7, r27
    63ae:	a5 01       	movw	r20, r10
    63b0:	94 01       	movw	r18, r8
    63b2:	03 2c       	mov	r0, r3
    63b4:	04 c0       	rjmp	.+8      	; 0x63be <__stack+0x3bf>
    63b6:	22 0f       	add	r18, r18
    63b8:	33 1f       	adc	r19, r19
    63ba:	44 1f       	adc	r20, r20
    63bc:	55 1f       	adc	r21, r21
    63be:	0a 94       	dec	r0
    63c0:	d2 f7       	brpl	.-12     	; 0x63b6 <__stack+0x3b7>
    63c2:	29 af       	sts	0x79, r18
    63c4:	3a af       	sts	0x7a, r19
    63c6:	4b af       	sts	0x7b, r20
    63c8:	5c af       	sts	0x7c, r21
    63ca:	b7 01       	movw	r22, r14
    63cc:	a6 01       	movw	r20, r12
    63ce:	00 2e       	mov	r0, r16
    63d0:	04 c0       	rjmp	.+8      	; 0x63da <__stack+0x3db>
    63d2:	76 95       	lsr	r23
    63d4:	67 95       	ror	r22
    63d6:	57 95       	ror	r21
    63d8:	47 95       	ror	r20
    63da:	0a 94       	dec	r0
    63dc:	d2 f7       	brpl	.-12     	; 0x63d2 <__stack+0x3d3>
    63de:	49 ab       	sts	0x59, r20
    63e0:	5a ab       	sts	0x5a, r21
    63e2:	6b ab       	sts	0x5b, r22
    63e4:	7c ab       	sts	0x5c, r23
    63e6:	c7 01       	movw	r24, r14
    63e8:	b6 01       	movw	r22, r12
    63ea:	03 2c       	mov	r0, r3
    63ec:	04 c0       	rjmp	.+8      	; 0x63f6 <__stack+0x3f7>
    63ee:	66 0f       	add	r22, r22
    63f0:	77 1f       	adc	r23, r23
    63f2:	88 1f       	adc	r24, r24
    63f4:	99 1f       	adc	r25, r25
    63f6:	0a 94       	dec	r0
    63f8:	d2 f7       	brpl	.-12     	; 0x63ee <__stack+0x3ef>
    63fa:	6d a7       	lds	r22, 0x7d
    63fc:	7e a7       	lds	r23, 0x7e
    63fe:	8f a7       	lds	r24, 0x7f
    6400:	98 ab       	sts	0x58, r25
    6402:	8d a9       	sts	0x4d, r24
    6404:	9e a9       	sts	0x4e, r25
    6406:	af a9       	sts	0x4f, r26
    6408:	b8 ad       	sts	0x68, r27
    640a:	04 c0       	rjmp	.+8      	; 0x6414 <__stack+0x415>
    640c:	b6 95       	lsr	r27
    640e:	a7 95       	ror	r26
    6410:	97 95       	ror	r25
    6412:	87 95       	ror	r24
    6414:	0a 95       	dec	r16
    6416:	d2 f7       	brpl	.-12     	; 0x640c <__stack+0x40d>
    6418:	4d a5       	lds	r20, 0x6d
    641a:	5e a5       	lds	r21, 0x6e
    641c:	6f a5       	lds	r22, 0x6f
    641e:	78 a9       	sts	0x48, r23
    6420:	48 2b       	or	r20, r24
    6422:	59 2b       	or	r21, r25
    6424:	6a 2b       	or	r22, r26
    6426:	7b 2b       	or	r23, r27
    6428:	4d a7       	lds	r20, 0x7d
    642a:	5e a7       	lds	r21, 0x7e
    642c:	6f a7       	lds	r22, 0x7f
    642e:	78 ab       	sts	0x58, r23
    6430:	43 01       	movw	r8, r6
    6432:	aa 24       	eor	r10, r10
    6434:	bb 24       	eor	r11, r11
    6436:	93 01       	movw	r18, r6
    6438:	82 01       	movw	r16, r4
    643a:	20 70       	andi	r18, 0x00	; 0
    643c:	30 70       	andi	r19, 0x00	; 0
    643e:	21 96       	adiw	r28, 0x01	; 1
    6440:	0c af       	sts	0x7c, r16
    6442:	1d af       	sts	0x7d, r17
    6444:	2e af       	sts	0x7e, r18
    6446:	3f af       	sts	0x7f, r19
    6448:	21 97       	sbiw	r28, 0x01	; 1
    644a:	69 a9       	sts	0x49, r22
    644c:	7a a9       	sts	0x4a, r23
    644e:	8b a9       	sts	0x4b, r24
    6450:	9c a9       	sts	0x4c, r25
    6452:	a5 01       	movw	r20, r10
    6454:	94 01       	movw	r18, r8
    6456:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    645a:	29 a7       	lds	r18, 0x79
    645c:	3a a7       	lds	r19, 0x7a
    645e:	4b a7       	lds	r20, 0x7b
    6460:	5c a7       	lds	r21, 0x7c
    6462:	6b 01       	movw	r12, r22
    6464:	7c 01       	movw	r14, r24
    6466:	69 a9       	sts	0x49, r22
    6468:	7a a9       	sts	0x4a, r23
    646a:	8b a9       	sts	0x4b, r24
    646c:	9c a9       	sts	0x4c, r25
    646e:	a5 01       	movw	r20, r10
    6470:	94 01       	movw	r18, r8
    6472:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    6476:	ca 01       	movw	r24, r20
    6478:	b9 01       	movw	r22, r18
    647a:	21 96       	adiw	r28, 0x01	; 1
    647c:	2c ad       	sts	0x6c, r18
    647e:	3d ad       	sts	0x6d, r19
    6480:	4e ad       	sts	0x6e, r20
    6482:	5f ad       	sts	0x6f, r21
    6484:	21 97       	sbiw	r28, 0x01	; 1
    6486:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    648a:	dc 01       	movw	r26, r24
    648c:	cb 01       	movw	r24, r22
    648e:	76 01       	movw	r14, r12
    6490:	dd 24       	eor	r13, r13
    6492:	cc 24       	eor	r12, r12
    6494:	0d a5       	lds	r16, 0x6d
    6496:	1e a5       	lds	r17, 0x6e
    6498:	2f a5       	lds	r18, 0x6f
    649a:	38 a9       	sts	0x48, r19
    649c:	a9 01       	movw	r20, r18
    649e:	66 27       	eor	r22, r22
    64a0:	77 27       	eor	r23, r23
    64a2:	c4 2a       	or	r12, r20
    64a4:	d5 2a       	or	r13, r21
    64a6:	e6 2a       	or	r14, r22
    64a8:	f7 2a       	or	r15, r23
    64aa:	09 a5       	lds	r16, 0x69
    64ac:	1a a5       	lds	r17, 0x6a
    64ae:	2b a5       	lds	r18, 0x6b
    64b0:	3c a5       	lds	r19, 0x6c
    64b2:	c8 16       	cp	r12, r24
    64b4:	d9 06       	cpc	r13, r25
    64b6:	ea 06       	cpc	r14, r26
    64b8:	fb 06       	cpc	r15, r27
    64ba:	38 f5       	brcc	.+78     	; 0x650a <__stack+0x50b>
    64bc:	01 50       	subi	r16, 0x01	; 1
    64be:	10 40       	sbci	r17, 0x00	; 0
    64c0:	20 40       	sbci	r18, 0x00	; 0
    64c2:	30 40       	sbci	r19, 0x00	; 0
    64c4:	09 ab       	sts	0x59, r16
    64c6:	1a ab       	sts	0x5a, r17
    64c8:	2b ab       	sts	0x5b, r18
    64ca:	3c ab       	sts	0x5c, r19
    64cc:	c4 0c       	add	r12, r4
    64ce:	d5 1c       	adc	r13, r5
    64d0:	e6 1c       	adc	r14, r6
    64d2:	f7 1c       	adc	r15, r7
    64d4:	c4 14       	cp	r12, r4
    64d6:	d5 04       	cpc	r13, r5
    64d8:	e6 04       	cpc	r14, r6
    64da:	f7 04       	cpc	r15, r7
    64dc:	d0 f0       	brcs	.+52     	; 0x6512 <__stack+0x513>
    64de:	c8 16       	cp	r12, r24
    64e0:	d9 06       	cpc	r13, r25
    64e2:	ea 06       	cpc	r14, r26
    64e4:	fb 06       	cpc	r15, r27
    64e6:	a8 f4       	brcc	.+42     	; 0x6512 <__stack+0x513>
    64e8:	09 a5       	lds	r16, 0x69
    64ea:	1a a5       	lds	r17, 0x6a
    64ec:	2b a5       	lds	r18, 0x6b
    64ee:	3c a5       	lds	r19, 0x6c
    64f0:	02 50       	subi	r16, 0x02	; 2
    64f2:	10 40       	sbci	r17, 0x00	; 0
    64f4:	20 40       	sbci	r18, 0x00	; 0
    64f6:	30 40       	sbci	r19, 0x00	; 0
    64f8:	09 ab       	sts	0x59, r16
    64fa:	1a ab       	sts	0x5a, r17
    64fc:	2b ab       	sts	0x5b, r18
    64fe:	3c ab       	sts	0x5c, r19
    6500:	c4 0c       	add	r12, r4
    6502:	d5 1c       	adc	r13, r5
    6504:	e6 1c       	adc	r14, r6
    6506:	f7 1c       	adc	r15, r7
    6508:	04 c0       	rjmp	.+8      	; 0x6512 <__stack+0x513>
    650a:	09 ab       	sts	0x59, r16
    650c:	1a ab       	sts	0x5a, r17
    650e:	2b ab       	sts	0x5b, r18
    6510:	3c ab       	sts	0x5c, r19
    6512:	c8 1a       	sub	r12, r24
    6514:	d9 0a       	sbc	r13, r25
    6516:	ea 0a       	sbc	r14, r26
    6518:	fb 0a       	sbc	r15, r27
    651a:	c7 01       	movw	r24, r14
    651c:	b6 01       	movw	r22, r12
    651e:	a5 01       	movw	r20, r10
    6520:	94 01       	movw	r18, r8
    6522:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    6526:	29 a7       	lds	r18, 0x79
    6528:	3a a7       	lds	r19, 0x7a
    652a:	4b a7       	lds	r20, 0x7b
    652c:	5c a7       	lds	r21, 0x7c
    652e:	29 96       	adiw	r28, 0x09	; 9
    6530:	6c af       	sts	0x7c, r22
    6532:	7d af       	sts	0x7d, r23
    6534:	8e af       	sts	0x7e, r24
    6536:	9f af       	sts	0x7f, r25
    6538:	29 97       	sbiw	r28, 0x09	; 9
    653a:	c7 01       	movw	r24, r14
    653c:	b6 01       	movw	r22, r12
    653e:	a5 01       	movw	r20, r10
    6540:	94 01       	movw	r18, r8
    6542:	0e 94 11 36 	call	0x6c22	; 0x6c22 <__udivmodsi4>
    6546:	ca 01       	movw	r24, r20
    6548:	b9 01       	movw	r22, r18
    654a:	21 96       	adiw	r28, 0x01	; 1
    654c:	2c ad       	sts	0x6c, r18
    654e:	3d ad       	sts	0x6d, r19
    6550:	4e ad       	sts	0x6e, r20
    6552:	5f ad       	sts	0x6f, r21
    6554:	21 97       	sbiw	r28, 0x01	; 1
    6556:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    655a:	4b 01       	movw	r8, r22
    655c:	5c 01       	movw	r10, r24
    655e:	29 96       	adiw	r28, 0x09	; 9
    6560:	4c ad       	sts	0x6c, r20
    6562:	5d ad       	sts	0x6d, r21
    6564:	6e ad       	sts	0x6e, r22
    6566:	7f ad       	sts	0x6f, r23
    6568:	29 97       	sbiw	r28, 0x09	; 9
    656a:	9a 01       	movw	r18, r20
    656c:	11 27       	eor	r17, r17
    656e:	00 27       	eor	r16, r16
    6570:	8d a5       	lds	r24, 0x6d
    6572:	9e a5       	lds	r25, 0x6e
    6574:	af a5       	lds	r26, 0x6f
    6576:	b8 a9       	sts	0x48, r27
    6578:	a0 70       	andi	r26, 0x00	; 0
    657a:	b0 70       	andi	r27, 0x00	; 0
    657c:	08 2b       	or	r16, r24
    657e:	19 2b       	or	r17, r25
    6580:	2a 2b       	or	r18, r26
    6582:	3b 2b       	or	r19, r27
    6584:	89 a5       	lds	r24, 0x69
    6586:	9a a5       	lds	r25, 0x6a
    6588:	ab a5       	lds	r26, 0x6b
    658a:	bc a5       	lds	r27, 0x6c
    658c:	08 15       	cp	r16, r8
    658e:	19 05       	cpc	r17, r9
    6590:	2a 05       	cpc	r18, r10
    6592:	3b 05       	cpc	r19, r11
    6594:	e0 f4       	brcc	.+56     	; 0x65ce <__stack+0x5cf>
    6596:	01 97       	sbiw	r24, 0x01	; 1
    6598:	a1 09       	sbc	r26, r1
    659a:	b1 09       	sbc	r27, r1
    659c:	04 0d       	add	r16, r4
    659e:	15 1d       	adc	r17, r5
    65a0:	26 1d       	adc	r18, r6
    65a2:	37 1d       	adc	r19, r7
    65a4:	04 15       	cp	r16, r4
    65a6:	15 05       	cpc	r17, r5
    65a8:	26 05       	cpc	r18, r6
    65aa:	37 05       	cpc	r19, r7
    65ac:	80 f0       	brcs	.+32     	; 0x65ce <__stack+0x5cf>
    65ae:	08 15       	cp	r16, r8
    65b0:	19 05       	cpc	r17, r9
    65b2:	2a 05       	cpc	r18, r10
    65b4:	3b 05       	cpc	r19, r11
    65b6:	58 f4       	brcc	.+22     	; 0x65ce <__stack+0x5cf>
    65b8:	89 a5       	lds	r24, 0x69
    65ba:	9a a5       	lds	r25, 0x6a
    65bc:	ab a5       	lds	r26, 0x6b
    65be:	bc a5       	lds	r27, 0x6c
    65c0:	02 97       	sbiw	r24, 0x02	; 2
    65c2:	a1 09       	sbc	r26, r1
    65c4:	b1 09       	sbc	r27, r1
    65c6:	04 0d       	add	r16, r4
    65c8:	15 1d       	adc	r17, r5
    65ca:	26 1d       	adc	r18, r6
    65cc:	37 1d       	adc	r19, r7
    65ce:	b9 01       	movw	r22, r18
    65d0:	a8 01       	movw	r20, r16
    65d2:	48 19       	sub	r20, r8
    65d4:	59 09       	sbc	r21, r9
    65d6:	6a 09       	sbc	r22, r10
    65d8:	7b 09       	sbc	r23, r11
    65da:	4d a7       	lds	r20, 0x7d
    65dc:	5e a7       	lds	r21, 0x7e
    65de:	6f a7       	lds	r22, 0x7f
    65e0:	78 ab       	sts	0x58, r23
    65e2:	09 a9       	sts	0x49, r16
    65e4:	1a a9       	sts	0x4a, r17
    65e6:	2b a9       	sts	0x4b, r18
    65e8:	3c a9       	sts	0x4c, r19
    65ea:	78 01       	movw	r14, r16
    65ec:	dd 24       	eor	r13, r13
    65ee:	cc 24       	eor	r12, r12
    65f0:	c8 2a       	or	r12, r24
    65f2:	d9 2a       	or	r13, r25
    65f4:	ea 2a       	or	r14, r26
    65f6:	fb 2a       	or	r15, r27
    65f8:	ff ef       	ldi	r31, 0xFF	; 255
    65fa:	8f 2e       	mov	r8, r31
    65fc:	ff ef       	ldi	r31, 0xFF	; 255
    65fe:	9f 2e       	mov	r9, r31
    6600:	a1 2c       	mov	r10, r1
    6602:	b1 2c       	mov	r11, r1
    6604:	8c 20       	and	r8, r12
    6606:	9d 20       	and	r9, r13
    6608:	ae 20       	and	r10, r14
    660a:	bf 20       	and	r11, r15
    660c:	87 01       	movw	r16, r14
    660e:	22 27       	eor	r18, r18
    6610:	33 27       	eor	r19, r19
    6612:	09 a7       	lds	r16, 0x79
    6614:	1a a7       	lds	r17, 0x7a
    6616:	2b a7       	lds	r18, 0x7b
    6618:	3c a7       	lds	r19, 0x7c
    661a:	49 ac       	sts	0xa9, r20
    661c:	5a ac       	sts	0xaa, r21
    661e:	6b ac       	sts	0xab, r22
    6620:	7c ac       	sts	0xac, r23
    6622:	2f ef       	ldi	r18, 0xFF	; 255
    6624:	3f ef       	ldi	r19, 0xFF	; 255
    6626:	40 e0       	ldi	r20, 0x00	; 0
    6628:	50 e0       	ldi	r21, 0x00	; 0
    662a:	42 22       	and	r4, r18
    662c:	53 22       	and	r5, r19
    662e:	64 22       	and	r6, r20
    6630:	75 22       	and	r7, r21
    6632:	29 ad       	sts	0x69, r18
    6634:	3a ad       	sts	0x6a, r19
    6636:	4b ad       	sts	0x6b, r20
    6638:	5c ad       	sts	0x6c, r21
    663a:	8a 01       	movw	r16, r20
    663c:	22 27       	eor	r18, r18
    663e:	33 27       	eor	r19, r19
    6640:	09 ab       	sts	0x59, r16
    6642:	1a ab       	sts	0x5a, r17
    6644:	2b ab       	sts	0x5b, r18
    6646:	3c ab       	sts	0x5c, r19
    6648:	c5 01       	movw	r24, r10
    664a:	b4 01       	movw	r22, r8
    664c:	a3 01       	movw	r20, r6
    664e:	92 01       	movw	r18, r4
    6650:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    6654:	69 af       	sts	0x79, r22
    6656:	7a af       	sts	0x7a, r23
    6658:	8b af       	sts	0x7b, r24
    665a:	9c af       	sts	0x7c, r25
    665c:	c5 01       	movw	r24, r10
    665e:	b4 01       	movw	r22, r8
    6660:	29 a9       	sts	0x49, r18
    6662:	3a a9       	sts	0x4a, r19
    6664:	4b a9       	sts	0x4b, r20
    6666:	5c a9       	sts	0x4c, r21
    6668:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    666c:	4b 01       	movw	r8, r22
    666e:	5c 01       	movw	r10, r24
    6670:	69 a5       	lds	r22, 0x69
    6672:	7a a5       	lds	r23, 0x6a
    6674:	8b a5       	lds	r24, 0x6b
    6676:	9c a5       	lds	r25, 0x6c
    6678:	a3 01       	movw	r20, r6
    667a:	92 01       	movw	r18, r4
    667c:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    6680:	2b 01       	movw	r4, r22
    6682:	3c 01       	movw	r6, r24
    6684:	69 a5       	lds	r22, 0x69
    6686:	7a a5       	lds	r23, 0x6a
    6688:	8b a5       	lds	r24, 0x6b
    668a:	9c a5       	lds	r25, 0x6c
    668c:	29 a9       	sts	0x49, r18
    668e:	3a a9       	sts	0x4a, r19
    6690:	4b a9       	sts	0x4b, r20
    6692:	5c a9       	sts	0x4c, r21
    6694:	0e 94 df 35 	call	0x6bbe	; 0x6bbe <__mulsi3>
    6698:	ab 01       	movw	r20, r22
    669a:	bc 01       	movw	r22, r24
    669c:	84 0c       	add	r8, r4
    669e:	95 1c       	adc	r9, r5
    66a0:	a6 1c       	adc	r10, r6
    66a2:	b7 1c       	adc	r11, r7
    66a4:	09 ad       	sts	0x69, r16
    66a6:	1a ad       	sts	0x6a, r17
    66a8:	2b ad       	sts	0x6b, r18
    66aa:	3c ad       	sts	0x6c, r19
    66ac:	c9 01       	movw	r24, r18
    66ae:	aa 27       	eor	r26, r26
    66b0:	bb 27       	eor	r27, r27
    66b2:	88 0e       	add	r8, r24
    66b4:	99 1e       	adc	r9, r25
    66b6:	aa 1e       	adc	r10, r26
    66b8:	bb 1e       	adc	r11, r27
    66ba:	84 14       	cp	r8, r4
    66bc:	95 04       	cpc	r9, r5
    66be:	a6 04       	cpc	r10, r6
    66c0:	b7 04       	cpc	r11, r7
    66c2:	20 f4       	brcc	.+8      	; 0x66cc <__stack+0x6cd>
    66c4:	40 50       	subi	r20, 0x00	; 0
    66c6:	50 40       	sbci	r21, 0x00	; 0
    66c8:	6f 4f       	sbci	r22, 0xFF	; 255
    66ca:	7f 4f       	sbci	r23, 0xFF	; 255
    66cc:	c5 01       	movw	r24, r10
    66ce:	aa 27       	eor	r26, r26
    66d0:	bb 27       	eor	r27, r27
    66d2:	84 0f       	add	r24, r20
    66d4:	95 1f       	adc	r25, r21
    66d6:	a6 1f       	adc	r26, r22
    66d8:	b7 1f       	adc	r27, r23
    66da:	0d a5       	lds	r16, 0x6d
    66dc:	1e a5       	lds	r17, 0x6e
    66de:	2f a5       	lds	r18, 0x6f
    66e0:	38 a9       	sts	0x48, r19
    66e2:	08 17       	cp	r16, r24
    66e4:	19 07       	cpc	r17, r25
    66e6:	2a 07       	cpc	r18, r26
    66e8:	3b 07       	cpc	r19, r27
    66ea:	18 f1       	brcs	.+70     	; 0x6732 <__stack+0x733>
    66ec:	80 17       	cp	r24, r16
    66ee:	91 07       	cpc	r25, r17
    66f0:	a2 07       	cpc	r26, r18
    66f2:	b3 07       	cpc	r27, r19
    66f4:	a1 f5       	brne	.+104    	; 0x675e <__stack+0x75f>
    66f6:	54 01       	movw	r10, r8
    66f8:	99 24       	eor	r9, r9
    66fa:	88 24       	eor	r8, r8
    66fc:	89 ad       	sts	0x69, r24
    66fe:	9a ad       	sts	0x6a, r25
    6700:	ab ad       	sts	0x6b, r26
    6702:	bc ad       	sts	0x6c, r27
    6704:	a0 70       	andi	r26, 0x00	; 0
    6706:	b0 70       	andi	r27, 0x00	; 0
    6708:	88 0e       	add	r8, r24
    670a:	99 1e       	adc	r9, r25
    670c:	aa 1e       	adc	r10, r26
    670e:	bb 1e       	adc	r11, r27
    6710:	4d a9       	sts	0x4d, r20
    6712:	5e a9       	sts	0x4e, r21
    6714:	6f a9       	sts	0x4f, r22
    6716:	78 ad       	sts	0x68, r23
    6718:	03 2c       	mov	r0, r3
    671a:	04 c0       	rjmp	.+8      	; 0x6724 <__stack+0x725>
    671c:	44 0f       	add	r20, r20
    671e:	55 1f       	adc	r21, r21
    6720:	66 1f       	adc	r22, r22
    6722:	77 1f       	adc	r23, r23
    6724:	0a 94       	dec	r0
    6726:	d2 f7       	brpl	.-12     	; 0x671c <__stack+0x71d>
    6728:	48 15       	cp	r20, r8
    672a:	59 05       	cpc	r21, r9
    672c:	6a 05       	cpc	r22, r10
    672e:	7b 05       	cpc	r23, r11
    6730:	b0 f4       	brcc	.+44     	; 0x675e <__stack+0x75f>
    6732:	08 94       	sec
    6734:	c1 08       	sbc	r12, r1
    6736:	d1 08       	sbc	r13, r1
    6738:	e1 08       	sbc	r14, r1
    673a:	f1 08       	sbc	r15, r1
    673c:	10 c0       	rjmp	.+32     	; 0x675e <__stack+0x75f>
    673e:	44 24       	eor	r4, r4
    6740:	55 24       	eor	r5, r5
    6742:	32 01       	movw	r6, r4
    6744:	cc 24       	eor	r12, r12
    6746:	dd 24       	eor	r13, r13
    6748:	76 01       	movw	r14, r12
    674a:	0c c0       	rjmp	.+24     	; 0x6764 <__stack+0x765>
    674c:	44 24       	eor	r4, r4
    674e:	55 24       	eor	r5, r5
    6750:	32 01       	movw	r6, r4
    6752:	81 e0       	ldi	r24, 0x01	; 1
    6754:	c8 2e       	mov	r12, r24
    6756:	d1 2c       	mov	r13, r1
    6758:	e1 2c       	mov	r14, r1
    675a:	f1 2c       	mov	r15, r1
    675c:	03 c0       	rjmp	.+6      	; 0x6764 <__stack+0x765>
    675e:	44 24       	eor	r4, r4
    6760:	55 24       	eor	r5, r5
    6762:	32 01       	movw	r6, r4
    6764:	fe 01       	movw	r30, r28
    6766:	31 96       	adiw	r30, 0x01	; 1
    6768:	88 e0       	ldi	r24, 0x08	; 8
    676a:	df 01       	movw	r26, r30
    676c:	1d 92       	st	X+, r1
    676e:	8a 95       	dec	r24
    6770:	e9 f7       	brne	.-6      	; 0x676c <__stack+0x76d>
    6772:	c9 82       	std	Y+1, r12	; 0x01
    6774:	da 82       	std	Y+2, r13	; 0x02
    6776:	eb 82       	std	Y+3, r14	; 0x03
    6778:	fc 82       	std	Y+4, r15	; 0x04
    677a:	4d 82       	std	Y+5, r4	; 0x05
    677c:	5e 82       	std	Y+6, r5	; 0x06
    677e:	6f 82       	std	Y+7, r6	; 0x07
    6780:	78 86       	std	Y+8, r7	; 0x08
    6782:	2c 2d       	mov	r18, r12
    6784:	3a 81       	ldd	r19, Y+2	; 0x02
    6786:	4b 81       	ldd	r20, Y+3	; 0x03
    6788:	5c 81       	ldd	r21, Y+4	; 0x04
    678a:	64 2d       	mov	r22, r4
    678c:	7e 81       	ldd	r23, Y+6	; 0x06
    678e:	8f 81       	ldd	r24, Y+7	; 0x07
    6790:	98 85       	ldd	r25, Y+8	; 0x08
    6792:	25 96       	adiw	r28, 0x05	; 5
    6794:	ec ac       	sts	0xac, r30
    6796:	fd ac       	sts	0xad, r31
    6798:	0e ad       	sts	0x6e, r16
    679a:	1f ad       	sts	0x6f, r17
    679c:	25 97       	sbiw	r28, 0x05	; 5
    679e:	e1 14       	cp	r14, r1
    67a0:	f1 04       	cpc	r15, r1
    67a2:	01 05       	cpc	r16, r1
    67a4:	11 05       	cpc	r17, r1
    67a6:	09 f4       	brne	.+2      	; 0x67aa <__stack+0x7ab>
    67a8:	56 c0       	rjmp	.+172    	; 0x6856 <__stack+0x857>
    67aa:	21 95       	neg	r18
    67ac:	e1 e0       	ldi	r30, 0x01	; 1
    67ae:	12 16       	cp	r1, r18
    67b0:	08 f0       	brcs	.+2      	; 0x67b4 <__stack+0x7b5>
    67b2:	e0 e0       	ldi	r30, 0x00	; 0
    67b4:	31 95       	neg	r19
    67b6:	f1 e0       	ldi	r31, 0x01	; 1
    67b8:	13 16       	cp	r1, r19
    67ba:	08 f0       	brcs	.+2      	; 0x67be <__stack+0x7bf>
    67bc:	f0 e0       	ldi	r31, 0x00	; 0
    67be:	03 2f       	mov	r16, r19
    67c0:	0e 1b       	sub	r16, r30
    67c2:	e1 e0       	ldi	r30, 0x01	; 1
    67c4:	30 17       	cp	r19, r16
    67c6:	08 f0       	brcs	.+2      	; 0x67ca <__stack+0x7cb>
    67c8:	e0 e0       	ldi	r30, 0x00	; 0
    67ca:	fe 2b       	or	r31, r30
    67cc:	41 95       	neg	r20
    67ce:	e1 e0       	ldi	r30, 0x01	; 1
    67d0:	14 16       	cp	r1, r20
    67d2:	08 f0       	brcs	.+2      	; 0x67d6 <__stack+0x7d7>
    67d4:	e0 e0       	ldi	r30, 0x00	; 0
    67d6:	14 2f       	mov	r17, r20
    67d8:	1f 1b       	sub	r17, r31
    67da:	31 e0       	ldi	r19, 0x01	; 1
    67dc:	41 17       	cp	r20, r17
    67de:	08 f0       	brcs	.+2      	; 0x67e2 <__stack+0x7e3>
    67e0:	30 e0       	ldi	r19, 0x00	; 0
    67e2:	e3 2b       	or	r30, r19
    67e4:	51 95       	neg	r21
    67e6:	f1 e0       	ldi	r31, 0x01	; 1
    67e8:	15 16       	cp	r1, r21
    67ea:	08 f0       	brcs	.+2      	; 0x67ee <__stack+0x7ef>
    67ec:	f0 e0       	ldi	r31, 0x00	; 0
    67ee:	b5 2f       	mov	r27, r21
    67f0:	be 1b       	sub	r27, r30
    67f2:	31 e0       	ldi	r19, 0x01	; 1
    67f4:	5b 17       	cp	r21, r27
    67f6:	08 f0       	brcs	.+2      	; 0x67fa <__stack+0x7fb>
    67f8:	30 e0       	ldi	r19, 0x00	; 0
    67fa:	f3 2b       	or	r31, r19
    67fc:	61 95       	neg	r22
    67fe:	e1 e0       	ldi	r30, 0x01	; 1
    6800:	16 16       	cp	r1, r22
    6802:	08 f0       	brcs	.+2      	; 0x6806 <__stack+0x807>
    6804:	e0 e0       	ldi	r30, 0x00	; 0
    6806:	46 2e       	mov	r4, r22
    6808:	4f 1a       	sub	r4, r31
    680a:	31 e0       	ldi	r19, 0x01	; 1
    680c:	64 15       	cp	r22, r4
    680e:	08 f0       	brcs	.+2      	; 0x6812 <__stack+0x813>
    6810:	30 e0       	ldi	r19, 0x00	; 0
    6812:	e3 2b       	or	r30, r19
    6814:	71 95       	neg	r23
    6816:	f1 e0       	ldi	r31, 0x01	; 1
    6818:	17 16       	cp	r1, r23
    681a:	08 f0       	brcs	.+2      	; 0x681e <__stack+0x81f>
    681c:	f0 e0       	ldi	r31, 0x00	; 0
    681e:	a7 2f       	mov	r26, r23
    6820:	ae 1b       	sub	r26, r30
    6822:	31 e0       	ldi	r19, 0x01	; 1
    6824:	7a 17       	cp	r23, r26
    6826:	08 f0       	brcs	.+2      	; 0x682a <__stack+0x82b>
    6828:	30 e0       	ldi	r19, 0x00	; 0
    682a:	f3 2b       	or	r31, r19
    682c:	81 95       	neg	r24
    682e:	e1 e0       	ldi	r30, 0x01	; 1
    6830:	18 16       	cp	r1, r24
    6832:	08 f0       	brcs	.+2      	; 0x6836 <__stack+0x837>
    6834:	e0 e0       	ldi	r30, 0x00	; 0
    6836:	f8 2e       	mov	r15, r24
    6838:	ff 1a       	sub	r15, r31
    683a:	ff 2d       	mov	r31, r15
    683c:	31 e0       	ldi	r19, 0x01	; 1
    683e:	8f 15       	cp	r24, r15
    6840:	08 f0       	brcs	.+2      	; 0x6844 <__stack+0x845>
    6842:	30 e0       	ldi	r19, 0x00	; 0
    6844:	e3 2b       	or	r30, r19
    6846:	91 95       	neg	r25
    6848:	30 2f       	mov	r19, r16
    684a:	41 2f       	mov	r20, r17
    684c:	5b 2f       	mov	r21, r27
    684e:	64 2d       	mov	r22, r4
    6850:	7a 2f       	mov	r23, r26
    6852:	8f 2f       	mov	r24, r31
    6854:	9e 1b       	sub	r25, r30
    6856:	c8 5b       	subi	r28, 0xB8	; 184
    6858:	df 4f       	sbci	r29, 0xFF	; 255
    685a:	e1 e1       	ldi	r30, 0x11	; 17
    685c:	0c 94 7c 36 	jmp	0x6cf8	; 0x6cf8 <__epilogue_restores__+0x2>

00006860 <__subsf3>:
    6860:	50 58       	subi	r21, 0x80	; 128

00006862 <__addsf3>:
    6862:	bb 27       	eor	r27, r27
    6864:	aa 27       	eor	r26, r26
    6866:	0e d0       	rcall	.+28     	; 0x6884 <__addsf3x>
    6868:	48 c1       	rjmp	.+656    	; 0x6afa <__fp_round>
    686a:	39 d1       	rcall	.+626    	; 0x6ade <__fp_pscA>
    686c:	30 f0       	brcs	.+12     	; 0x687a <__addsf3+0x18>
    686e:	3e d1       	rcall	.+636    	; 0x6aec <__fp_pscB>
    6870:	20 f0       	brcs	.+8      	; 0x687a <__addsf3+0x18>
    6872:	31 f4       	brne	.+12     	; 0x6880 <__addsf3+0x1e>
    6874:	9f 3f       	cpi	r25, 0xFF	; 255
    6876:	11 f4       	brne	.+4      	; 0x687c <__addsf3+0x1a>
    6878:	1e f4       	brtc	.+6      	; 0x6880 <__addsf3+0x1e>
    687a:	2e c1       	rjmp	.+604    	; 0x6ad8 <__fp_nan>
    687c:	0e f4       	brtc	.+2      	; 0x6880 <__addsf3+0x1e>
    687e:	e0 95       	com	r30
    6880:	e7 fb       	bst	r30, 7
    6882:	24 c1       	rjmp	.+584    	; 0x6acc <__fp_inf>

00006884 <__addsf3x>:
    6884:	e9 2f       	mov	r30, r25
    6886:	4a d1       	rcall	.+660    	; 0x6b1c <__fp_split3>
    6888:	80 f3       	brcs	.-32     	; 0x686a <__addsf3+0x8>
    688a:	ba 17       	cp	r27, r26
    688c:	62 07       	cpc	r22, r18
    688e:	73 07       	cpc	r23, r19
    6890:	84 07       	cpc	r24, r20
    6892:	95 07       	cpc	r25, r21
    6894:	18 f0       	brcs	.+6      	; 0x689c <__addsf3x+0x18>
    6896:	71 f4       	brne	.+28     	; 0x68b4 <__addsf3x+0x30>
    6898:	9e f5       	brtc	.+102    	; 0x6900 <__addsf3x+0x7c>
    689a:	62 c1       	rjmp	.+708    	; 0x6b60 <__fp_zero>
    689c:	0e f4       	brtc	.+2      	; 0x68a0 <__addsf3x+0x1c>
    689e:	e0 95       	com	r30
    68a0:	0b 2e       	mov	r0, r27
    68a2:	ba 2f       	mov	r27, r26
    68a4:	a0 2d       	mov	r26, r0
    68a6:	0b 01       	movw	r0, r22
    68a8:	b9 01       	movw	r22, r18
    68aa:	90 01       	movw	r18, r0
    68ac:	0c 01       	movw	r0, r24
    68ae:	ca 01       	movw	r24, r20
    68b0:	a0 01       	movw	r20, r0
    68b2:	11 24       	eor	r1, r1
    68b4:	ff 27       	eor	r31, r31
    68b6:	59 1b       	sub	r21, r25
    68b8:	99 f0       	breq	.+38     	; 0x68e0 <__addsf3x+0x5c>
    68ba:	59 3f       	cpi	r21, 0xF9	; 249
    68bc:	50 f4       	brcc	.+20     	; 0x68d2 <__addsf3x+0x4e>
    68be:	50 3e       	cpi	r21, 0xE0	; 224
    68c0:	68 f1       	brcs	.+90     	; 0x691c <__addsf3x+0x98>
    68c2:	1a 16       	cp	r1, r26
    68c4:	f0 40       	sbci	r31, 0x00	; 0
    68c6:	a2 2f       	mov	r26, r18
    68c8:	23 2f       	mov	r18, r19
    68ca:	34 2f       	mov	r19, r20
    68cc:	44 27       	eor	r20, r20
    68ce:	58 5f       	subi	r21, 0xF8	; 248
    68d0:	f3 cf       	rjmp	.-26     	; 0x68b8 <__addsf3x+0x34>
    68d2:	46 95       	lsr	r20
    68d4:	37 95       	ror	r19
    68d6:	27 95       	ror	r18
    68d8:	a7 95       	ror	r26
    68da:	f0 40       	sbci	r31, 0x00	; 0
    68dc:	53 95       	inc	r21
    68de:	c9 f7       	brne	.-14     	; 0x68d2 <__addsf3x+0x4e>
    68e0:	7e f4       	brtc	.+30     	; 0x6900 <__addsf3x+0x7c>
    68e2:	1f 16       	cp	r1, r31
    68e4:	ba 0b       	sbc	r27, r26
    68e6:	62 0b       	sbc	r22, r18
    68e8:	73 0b       	sbc	r23, r19
    68ea:	84 0b       	sbc	r24, r20
    68ec:	ba f0       	brmi	.+46     	; 0x691c <__addsf3x+0x98>
    68ee:	91 50       	subi	r25, 0x01	; 1
    68f0:	a1 f0       	breq	.+40     	; 0x691a <__addsf3x+0x96>
    68f2:	ff 0f       	add	r31, r31
    68f4:	bb 1f       	adc	r27, r27
    68f6:	66 1f       	adc	r22, r22
    68f8:	77 1f       	adc	r23, r23
    68fa:	88 1f       	adc	r24, r24
    68fc:	c2 f7       	brpl	.-16     	; 0x68ee <__addsf3x+0x6a>
    68fe:	0e c0       	rjmp	.+28     	; 0x691c <__addsf3x+0x98>
    6900:	ba 0f       	add	r27, r26
    6902:	62 1f       	adc	r22, r18
    6904:	73 1f       	adc	r23, r19
    6906:	84 1f       	adc	r24, r20
    6908:	48 f4       	brcc	.+18     	; 0x691c <__addsf3x+0x98>
    690a:	87 95       	ror	r24
    690c:	77 95       	ror	r23
    690e:	67 95       	ror	r22
    6910:	b7 95       	ror	r27
    6912:	f7 95       	ror	r31
    6914:	9e 3f       	cpi	r25, 0xFE	; 254
    6916:	08 f0       	brcs	.+2      	; 0x691a <__addsf3x+0x96>
    6918:	b3 cf       	rjmp	.-154    	; 0x6880 <__addsf3+0x1e>
    691a:	93 95       	inc	r25
    691c:	88 0f       	add	r24, r24
    691e:	08 f0       	brcs	.+2      	; 0x6922 <__addsf3x+0x9e>
    6920:	99 27       	eor	r25, r25
    6922:	ee 0f       	add	r30, r30
    6924:	97 95       	ror	r25
    6926:	87 95       	ror	r24
    6928:	08 95       	ret

0000692a <__divsf3>:
    692a:	0c d0       	rcall	.+24     	; 0x6944 <__divsf3x>
    692c:	e6 c0       	rjmp	.+460    	; 0x6afa <__fp_round>
    692e:	de d0       	rcall	.+444    	; 0x6aec <__fp_pscB>
    6930:	40 f0       	brcs	.+16     	; 0x6942 <__divsf3+0x18>
    6932:	d5 d0       	rcall	.+426    	; 0x6ade <__fp_pscA>
    6934:	30 f0       	brcs	.+12     	; 0x6942 <__divsf3+0x18>
    6936:	21 f4       	brne	.+8      	; 0x6940 <__divsf3+0x16>
    6938:	5f 3f       	cpi	r21, 0xFF	; 255
    693a:	19 f0       	breq	.+6      	; 0x6942 <__divsf3+0x18>
    693c:	c7 c0       	rjmp	.+398    	; 0x6acc <__fp_inf>
    693e:	51 11       	cpse	r21, r1
    6940:	10 c1       	rjmp	.+544    	; 0x6b62 <__fp_szero>
    6942:	ca c0       	rjmp	.+404    	; 0x6ad8 <__fp_nan>

00006944 <__divsf3x>:
    6944:	eb d0       	rcall	.+470    	; 0x6b1c <__fp_split3>
    6946:	98 f3       	brcs	.-26     	; 0x692e <__divsf3+0x4>

00006948 <__divsf3_pse>:
    6948:	99 23       	and	r25, r25
    694a:	c9 f3       	breq	.-14     	; 0x693e <__divsf3+0x14>
    694c:	55 23       	and	r21, r21
    694e:	b1 f3       	breq	.-20     	; 0x693c <__divsf3+0x12>
    6950:	95 1b       	sub	r25, r21
    6952:	55 0b       	sbc	r21, r21
    6954:	bb 27       	eor	r27, r27
    6956:	aa 27       	eor	r26, r26
    6958:	62 17       	cp	r22, r18
    695a:	73 07       	cpc	r23, r19
    695c:	84 07       	cpc	r24, r20
    695e:	38 f0       	brcs	.+14     	; 0x696e <__divsf3_pse+0x26>
    6960:	9f 5f       	subi	r25, 0xFF	; 255
    6962:	5f 4f       	sbci	r21, 0xFF	; 255
    6964:	22 0f       	add	r18, r18
    6966:	33 1f       	adc	r19, r19
    6968:	44 1f       	adc	r20, r20
    696a:	aa 1f       	adc	r26, r26
    696c:	a9 f3       	breq	.-22     	; 0x6958 <__divsf3_pse+0x10>
    696e:	33 d0       	rcall	.+102    	; 0x69d6 <__divsf3_pse+0x8e>
    6970:	0e 2e       	mov	r0, r30
    6972:	3a f0       	brmi	.+14     	; 0x6982 <__divsf3_pse+0x3a>
    6974:	e0 e8       	ldi	r30, 0x80	; 128
    6976:	30 d0       	rcall	.+96     	; 0x69d8 <__divsf3_pse+0x90>
    6978:	91 50       	subi	r25, 0x01	; 1
    697a:	50 40       	sbci	r21, 0x00	; 0
    697c:	e6 95       	lsr	r30
    697e:	00 1c       	adc	r0, r0
    6980:	ca f7       	brpl	.-14     	; 0x6974 <__divsf3_pse+0x2c>
    6982:	29 d0       	rcall	.+82     	; 0x69d6 <__divsf3_pse+0x8e>
    6984:	fe 2f       	mov	r31, r30
    6986:	27 d0       	rcall	.+78     	; 0x69d6 <__divsf3_pse+0x8e>
    6988:	66 0f       	add	r22, r22
    698a:	77 1f       	adc	r23, r23
    698c:	88 1f       	adc	r24, r24
    698e:	bb 1f       	adc	r27, r27
    6990:	26 17       	cp	r18, r22
    6992:	37 07       	cpc	r19, r23
    6994:	48 07       	cpc	r20, r24
    6996:	ab 07       	cpc	r26, r27
    6998:	b0 e8       	ldi	r27, 0x80	; 128
    699a:	09 f0       	breq	.+2      	; 0x699e <__divsf3_pse+0x56>
    699c:	bb 0b       	sbc	r27, r27
    699e:	80 2d       	mov	r24, r0
    69a0:	bf 01       	movw	r22, r30
    69a2:	ff 27       	eor	r31, r31
    69a4:	93 58       	subi	r25, 0x83	; 131
    69a6:	5f 4f       	sbci	r21, 0xFF	; 255
    69a8:	2a f0       	brmi	.+10     	; 0x69b4 <__divsf3_pse+0x6c>
    69aa:	9e 3f       	cpi	r25, 0xFE	; 254
    69ac:	51 05       	cpc	r21, r1
    69ae:	68 f0       	brcs	.+26     	; 0x69ca <__divsf3_pse+0x82>
    69b0:	8d c0       	rjmp	.+282    	; 0x6acc <__fp_inf>
    69b2:	d7 c0       	rjmp	.+430    	; 0x6b62 <__fp_szero>
    69b4:	5f 3f       	cpi	r21, 0xFF	; 255
    69b6:	ec f3       	brlt	.-6      	; 0x69b2 <__divsf3_pse+0x6a>
    69b8:	98 3e       	cpi	r25, 0xE8	; 232
    69ba:	dc f3       	brlt	.-10     	; 0x69b2 <__divsf3_pse+0x6a>
    69bc:	86 95       	lsr	r24
    69be:	77 95       	ror	r23
    69c0:	67 95       	ror	r22
    69c2:	b7 95       	ror	r27
    69c4:	f7 95       	ror	r31
    69c6:	9f 5f       	subi	r25, 0xFF	; 255
    69c8:	c9 f7       	brne	.-14     	; 0x69bc <__divsf3_pse+0x74>
    69ca:	88 0f       	add	r24, r24
    69cc:	91 1d       	adc	r25, r1
    69ce:	96 95       	lsr	r25
    69d0:	87 95       	ror	r24
    69d2:	97 f9       	bld	r25, 7
    69d4:	08 95       	ret
    69d6:	e1 e0       	ldi	r30, 0x01	; 1
    69d8:	66 0f       	add	r22, r22
    69da:	77 1f       	adc	r23, r23
    69dc:	88 1f       	adc	r24, r24
    69de:	bb 1f       	adc	r27, r27
    69e0:	62 17       	cp	r22, r18
    69e2:	73 07       	cpc	r23, r19
    69e4:	84 07       	cpc	r24, r20
    69e6:	ba 07       	cpc	r27, r26
    69e8:	20 f0       	brcs	.+8      	; 0x69f2 <__divsf3_pse+0xaa>
    69ea:	62 1b       	sub	r22, r18
    69ec:	73 0b       	sbc	r23, r19
    69ee:	84 0b       	sbc	r24, r20
    69f0:	ba 0b       	sbc	r27, r26
    69f2:	ee 1f       	adc	r30, r30
    69f4:	88 f7       	brcc	.-30     	; 0x69d8 <__divsf3_pse+0x90>
    69f6:	e0 95       	com	r30
    69f8:	08 95       	ret

000069fa <__fixunssfsi>:
    69fa:	98 d0       	rcall	.+304    	; 0x6b2c <__fp_splitA>
    69fc:	88 f0       	brcs	.+34     	; 0x6a20 <__fixunssfsi+0x26>
    69fe:	9f 57       	subi	r25, 0x7F	; 127
    6a00:	90 f0       	brcs	.+36     	; 0x6a26 <__fixunssfsi+0x2c>
    6a02:	b9 2f       	mov	r27, r25
    6a04:	99 27       	eor	r25, r25
    6a06:	b7 51       	subi	r27, 0x17	; 23
    6a08:	a0 f0       	brcs	.+40     	; 0x6a32 <__fixunssfsi+0x38>
    6a0a:	d1 f0       	breq	.+52     	; 0x6a40 <__fixunssfsi+0x46>
    6a0c:	66 0f       	add	r22, r22
    6a0e:	77 1f       	adc	r23, r23
    6a10:	88 1f       	adc	r24, r24
    6a12:	99 1f       	adc	r25, r25
    6a14:	1a f0       	brmi	.+6      	; 0x6a1c <__fixunssfsi+0x22>
    6a16:	ba 95       	dec	r27
    6a18:	c9 f7       	brne	.-14     	; 0x6a0c <__fixunssfsi+0x12>
    6a1a:	12 c0       	rjmp	.+36     	; 0x6a40 <__fixunssfsi+0x46>
    6a1c:	b1 30       	cpi	r27, 0x01	; 1
    6a1e:	81 f0       	breq	.+32     	; 0x6a40 <__fixunssfsi+0x46>
    6a20:	9f d0       	rcall	.+318    	; 0x6b60 <__fp_zero>
    6a22:	b1 e0       	ldi	r27, 0x01	; 1
    6a24:	08 95       	ret
    6a26:	9c c0       	rjmp	.+312    	; 0x6b60 <__fp_zero>
    6a28:	67 2f       	mov	r22, r23
    6a2a:	78 2f       	mov	r23, r24
    6a2c:	88 27       	eor	r24, r24
    6a2e:	b8 5f       	subi	r27, 0xF8	; 248
    6a30:	39 f0       	breq	.+14     	; 0x6a40 <__fixunssfsi+0x46>
    6a32:	b9 3f       	cpi	r27, 0xF9	; 249
    6a34:	cc f3       	brlt	.-14     	; 0x6a28 <__fixunssfsi+0x2e>
    6a36:	86 95       	lsr	r24
    6a38:	77 95       	ror	r23
    6a3a:	67 95       	ror	r22
    6a3c:	b3 95       	inc	r27
    6a3e:	d9 f7       	brne	.-10     	; 0x6a36 <__fixunssfsi+0x3c>
    6a40:	3e f4       	brtc	.+14     	; 0x6a50 <__fixunssfsi+0x56>
    6a42:	90 95       	com	r25
    6a44:	80 95       	com	r24
    6a46:	70 95       	com	r23
    6a48:	61 95       	neg	r22
    6a4a:	7f 4f       	sbci	r23, 0xFF	; 255
    6a4c:	8f 4f       	sbci	r24, 0xFF	; 255
    6a4e:	9f 4f       	sbci	r25, 0xFF	; 255
    6a50:	08 95       	ret

00006a52 <__floatunsisf>:
    6a52:	e8 94       	clt
    6a54:	09 c0       	rjmp	.+18     	; 0x6a68 <__floatsisf+0x12>

00006a56 <__floatsisf>:
    6a56:	97 fb       	bst	r25, 7
    6a58:	3e f4       	brtc	.+14     	; 0x6a68 <__floatsisf+0x12>
    6a5a:	90 95       	com	r25
    6a5c:	80 95       	com	r24
    6a5e:	70 95       	com	r23
    6a60:	61 95       	neg	r22
    6a62:	7f 4f       	sbci	r23, 0xFF	; 255
    6a64:	8f 4f       	sbci	r24, 0xFF	; 255
    6a66:	9f 4f       	sbci	r25, 0xFF	; 255
    6a68:	99 23       	and	r25, r25
    6a6a:	a9 f0       	breq	.+42     	; 0x6a96 <__floatsisf+0x40>
    6a6c:	f9 2f       	mov	r31, r25
    6a6e:	96 e9       	ldi	r25, 0x96	; 150
    6a70:	bb 27       	eor	r27, r27
    6a72:	93 95       	inc	r25
    6a74:	f6 95       	lsr	r31
    6a76:	87 95       	ror	r24
    6a78:	77 95       	ror	r23
    6a7a:	67 95       	ror	r22
    6a7c:	b7 95       	ror	r27
    6a7e:	f1 11       	cpse	r31, r1
    6a80:	f8 cf       	rjmp	.-16     	; 0x6a72 <__floatsisf+0x1c>
    6a82:	fa f4       	brpl	.+62     	; 0x6ac2 <__floatsisf+0x6c>
    6a84:	bb 0f       	add	r27, r27
    6a86:	11 f4       	brne	.+4      	; 0x6a8c <__floatsisf+0x36>
    6a88:	60 ff       	sbrs	r22, 0
    6a8a:	1b c0       	rjmp	.+54     	; 0x6ac2 <__floatsisf+0x6c>
    6a8c:	6f 5f       	subi	r22, 0xFF	; 255
    6a8e:	7f 4f       	sbci	r23, 0xFF	; 255
    6a90:	8f 4f       	sbci	r24, 0xFF	; 255
    6a92:	9f 4f       	sbci	r25, 0xFF	; 255
    6a94:	16 c0       	rjmp	.+44     	; 0x6ac2 <__floatsisf+0x6c>
    6a96:	88 23       	and	r24, r24
    6a98:	11 f0       	breq	.+4      	; 0x6a9e <__floatsisf+0x48>
    6a9a:	96 e9       	ldi	r25, 0x96	; 150
    6a9c:	11 c0       	rjmp	.+34     	; 0x6ac0 <__floatsisf+0x6a>
    6a9e:	77 23       	and	r23, r23
    6aa0:	21 f0       	breq	.+8      	; 0x6aaa <__floatsisf+0x54>
    6aa2:	9e e8       	ldi	r25, 0x8E	; 142
    6aa4:	87 2f       	mov	r24, r23
    6aa6:	76 2f       	mov	r23, r22
    6aa8:	05 c0       	rjmp	.+10     	; 0x6ab4 <__floatsisf+0x5e>
    6aaa:	66 23       	and	r22, r22
    6aac:	71 f0       	breq	.+28     	; 0x6aca <__floatsisf+0x74>
    6aae:	96 e8       	ldi	r25, 0x86	; 134
    6ab0:	86 2f       	mov	r24, r22
    6ab2:	70 e0       	ldi	r23, 0x00	; 0
    6ab4:	60 e0       	ldi	r22, 0x00	; 0
    6ab6:	2a f0       	brmi	.+10     	; 0x6ac2 <__floatsisf+0x6c>
    6ab8:	9a 95       	dec	r25
    6aba:	66 0f       	add	r22, r22
    6abc:	77 1f       	adc	r23, r23
    6abe:	88 1f       	adc	r24, r24
    6ac0:	da f7       	brpl	.-10     	; 0x6ab8 <__floatsisf+0x62>
    6ac2:	88 0f       	add	r24, r24
    6ac4:	96 95       	lsr	r25
    6ac6:	87 95       	ror	r24
    6ac8:	97 f9       	bld	r25, 7
    6aca:	08 95       	ret

00006acc <__fp_inf>:
    6acc:	97 f9       	bld	r25, 7
    6ace:	9f 67       	ori	r25, 0x7F	; 127
    6ad0:	80 e8       	ldi	r24, 0x80	; 128
    6ad2:	70 e0       	ldi	r23, 0x00	; 0
    6ad4:	60 e0       	ldi	r22, 0x00	; 0
    6ad6:	08 95       	ret

00006ad8 <__fp_nan>:
    6ad8:	9f ef       	ldi	r25, 0xFF	; 255
    6ada:	80 ec       	ldi	r24, 0xC0	; 192
    6adc:	08 95       	ret

00006ade <__fp_pscA>:
    6ade:	00 24       	eor	r0, r0
    6ae0:	0a 94       	dec	r0
    6ae2:	16 16       	cp	r1, r22
    6ae4:	17 06       	cpc	r1, r23
    6ae6:	18 06       	cpc	r1, r24
    6ae8:	09 06       	cpc	r0, r25
    6aea:	08 95       	ret

00006aec <__fp_pscB>:
    6aec:	00 24       	eor	r0, r0
    6aee:	0a 94       	dec	r0
    6af0:	12 16       	cp	r1, r18
    6af2:	13 06       	cpc	r1, r19
    6af4:	14 06       	cpc	r1, r20
    6af6:	05 06       	cpc	r0, r21
    6af8:	08 95       	ret

00006afa <__fp_round>:
    6afa:	09 2e       	mov	r0, r25
    6afc:	03 94       	inc	r0
    6afe:	00 0c       	add	r0, r0
    6b00:	11 f4       	brne	.+4      	; 0x6b06 <__fp_round+0xc>
    6b02:	88 23       	and	r24, r24
    6b04:	52 f0       	brmi	.+20     	; 0x6b1a <__fp_round+0x20>
    6b06:	bb 0f       	add	r27, r27
    6b08:	40 f4       	brcc	.+16     	; 0x6b1a <__fp_round+0x20>
    6b0a:	bf 2b       	or	r27, r31
    6b0c:	11 f4       	brne	.+4      	; 0x6b12 <__fp_round+0x18>
    6b0e:	60 ff       	sbrs	r22, 0
    6b10:	04 c0       	rjmp	.+8      	; 0x6b1a <__fp_round+0x20>
    6b12:	6f 5f       	subi	r22, 0xFF	; 255
    6b14:	7f 4f       	sbci	r23, 0xFF	; 255
    6b16:	8f 4f       	sbci	r24, 0xFF	; 255
    6b18:	9f 4f       	sbci	r25, 0xFF	; 255
    6b1a:	08 95       	ret

00006b1c <__fp_split3>:
    6b1c:	57 fd       	sbrc	r21, 7
    6b1e:	90 58       	subi	r25, 0x80	; 128
    6b20:	44 0f       	add	r20, r20
    6b22:	55 1f       	adc	r21, r21
    6b24:	59 f0       	breq	.+22     	; 0x6b3c <__fp_splitA+0x10>
    6b26:	5f 3f       	cpi	r21, 0xFF	; 255
    6b28:	71 f0       	breq	.+28     	; 0x6b46 <__fp_splitA+0x1a>
    6b2a:	47 95       	ror	r20

00006b2c <__fp_splitA>:
    6b2c:	88 0f       	add	r24, r24
    6b2e:	97 fb       	bst	r25, 7
    6b30:	99 1f       	adc	r25, r25
    6b32:	61 f0       	breq	.+24     	; 0x6b4c <__fp_splitA+0x20>
    6b34:	9f 3f       	cpi	r25, 0xFF	; 255
    6b36:	79 f0       	breq	.+30     	; 0x6b56 <__fp_splitA+0x2a>
    6b38:	87 95       	ror	r24
    6b3a:	08 95       	ret
    6b3c:	12 16       	cp	r1, r18
    6b3e:	13 06       	cpc	r1, r19
    6b40:	14 06       	cpc	r1, r20
    6b42:	55 1f       	adc	r21, r21
    6b44:	f2 cf       	rjmp	.-28     	; 0x6b2a <__fp_split3+0xe>
    6b46:	46 95       	lsr	r20
    6b48:	f1 df       	rcall	.-30     	; 0x6b2c <__fp_splitA>
    6b4a:	08 c0       	rjmp	.+16     	; 0x6b5c <__fp_splitA+0x30>
    6b4c:	16 16       	cp	r1, r22
    6b4e:	17 06       	cpc	r1, r23
    6b50:	18 06       	cpc	r1, r24
    6b52:	99 1f       	adc	r25, r25
    6b54:	f1 cf       	rjmp	.-30     	; 0x6b38 <__fp_splitA+0xc>
    6b56:	86 95       	lsr	r24
    6b58:	71 05       	cpc	r23, r1
    6b5a:	61 05       	cpc	r22, r1
    6b5c:	08 94       	sec
    6b5e:	08 95       	ret

00006b60 <__fp_zero>:
    6b60:	e8 94       	clt

00006b62 <__fp_szero>:
    6b62:	bb 27       	eor	r27, r27
    6b64:	66 27       	eor	r22, r22
    6b66:	77 27       	eor	r23, r23
    6b68:	cb 01       	movw	r24, r22
    6b6a:	97 f9       	bld	r25, 7
    6b6c:	08 95       	ret

00006b6e <__gesf2>:
    6b6e:	03 d0       	rcall	.+6      	; 0x6b76 <__fp_cmp>
    6b70:	08 f4       	brcc	.+2      	; 0x6b74 <__gesf2+0x6>
    6b72:	8f ef       	ldi	r24, 0xFF	; 255
    6b74:	08 95       	ret

00006b76 <__fp_cmp>:
    6b76:	99 0f       	add	r25, r25
    6b78:	00 08       	sbc	r0, r0
    6b7a:	55 0f       	add	r21, r21
    6b7c:	aa 0b       	sbc	r26, r26
    6b7e:	e0 e8       	ldi	r30, 0x80	; 128
    6b80:	fe ef       	ldi	r31, 0xFE	; 254
    6b82:	16 16       	cp	r1, r22
    6b84:	17 06       	cpc	r1, r23
    6b86:	e8 07       	cpc	r30, r24
    6b88:	f9 07       	cpc	r31, r25
    6b8a:	c0 f0       	brcs	.+48     	; 0x6bbc <__fp_cmp+0x46>
    6b8c:	12 16       	cp	r1, r18
    6b8e:	13 06       	cpc	r1, r19
    6b90:	e4 07       	cpc	r30, r20
    6b92:	f5 07       	cpc	r31, r21
    6b94:	98 f0       	brcs	.+38     	; 0x6bbc <__fp_cmp+0x46>
    6b96:	62 1b       	sub	r22, r18
    6b98:	73 0b       	sbc	r23, r19
    6b9a:	84 0b       	sbc	r24, r20
    6b9c:	95 0b       	sbc	r25, r21
    6b9e:	39 f4       	brne	.+14     	; 0x6bae <__fp_cmp+0x38>
    6ba0:	0a 26       	eor	r0, r26
    6ba2:	61 f0       	breq	.+24     	; 0x6bbc <__fp_cmp+0x46>
    6ba4:	23 2b       	or	r18, r19
    6ba6:	24 2b       	or	r18, r20
    6ba8:	25 2b       	or	r18, r21
    6baa:	21 f4       	brne	.+8      	; 0x6bb4 <__fp_cmp+0x3e>
    6bac:	08 95       	ret
    6bae:	0a 26       	eor	r0, r26
    6bb0:	09 f4       	brne	.+2      	; 0x6bb4 <__fp_cmp+0x3e>
    6bb2:	a1 40       	sbci	r26, 0x01	; 1
    6bb4:	a6 95       	lsr	r26
    6bb6:	8f ef       	ldi	r24, 0xFF	; 255
    6bb8:	81 1d       	adc	r24, r1
    6bba:	81 1d       	adc	r24, r1
    6bbc:	08 95       	ret

00006bbe <__mulsi3>:
    6bbe:	62 9f       	mul	r22, r18
    6bc0:	d0 01       	movw	r26, r0
    6bc2:	73 9f       	mul	r23, r19
    6bc4:	f0 01       	movw	r30, r0
    6bc6:	82 9f       	mul	r24, r18
    6bc8:	e0 0d       	add	r30, r0
    6bca:	f1 1d       	adc	r31, r1
    6bcc:	64 9f       	mul	r22, r20
    6bce:	e0 0d       	add	r30, r0
    6bd0:	f1 1d       	adc	r31, r1
    6bd2:	92 9f       	mul	r25, r18
    6bd4:	f0 0d       	add	r31, r0
    6bd6:	83 9f       	mul	r24, r19
    6bd8:	f0 0d       	add	r31, r0
    6bda:	74 9f       	mul	r23, r20
    6bdc:	f0 0d       	add	r31, r0
    6bde:	65 9f       	mul	r22, r21
    6be0:	f0 0d       	add	r31, r0
    6be2:	99 27       	eor	r25, r25
    6be4:	72 9f       	mul	r23, r18
    6be6:	b0 0d       	add	r27, r0
    6be8:	e1 1d       	adc	r30, r1
    6bea:	f9 1f       	adc	r31, r25
    6bec:	63 9f       	mul	r22, r19
    6bee:	b0 0d       	add	r27, r0
    6bf0:	e1 1d       	adc	r30, r1
    6bf2:	f9 1f       	adc	r31, r25
    6bf4:	bd 01       	movw	r22, r26
    6bf6:	cf 01       	movw	r24, r30
    6bf8:	11 24       	eor	r1, r1
    6bfa:	08 95       	ret

00006bfc <__divmodhi4>:
    6bfc:	97 fb       	bst	r25, 7
    6bfe:	09 2e       	mov	r0, r25
    6c00:	07 26       	eor	r0, r23
    6c02:	0a d0       	rcall	.+20     	; 0x6c18 <__divmodhi4_neg1>
    6c04:	77 fd       	sbrc	r23, 7
    6c06:	04 d0       	rcall	.+8      	; 0x6c10 <__divmodhi4_neg2>
    6c08:	49 d0       	rcall	.+146    	; 0x6c9c <__udivmodhi4>
    6c0a:	06 d0       	rcall	.+12     	; 0x6c18 <__divmodhi4_neg1>
    6c0c:	00 20       	and	r0, r0
    6c0e:	1a f4       	brpl	.+6      	; 0x6c16 <__divmodhi4_exit>

00006c10 <__divmodhi4_neg2>:
    6c10:	70 95       	com	r23
    6c12:	61 95       	neg	r22
    6c14:	7f 4f       	sbci	r23, 0xFF	; 255

00006c16 <__divmodhi4_exit>:
    6c16:	08 95       	ret

00006c18 <__divmodhi4_neg1>:
    6c18:	f6 f7       	brtc	.-4      	; 0x6c16 <__divmodhi4_exit>
    6c1a:	90 95       	com	r25
    6c1c:	81 95       	neg	r24
    6c1e:	9f 4f       	sbci	r25, 0xFF	; 255
    6c20:	08 95       	ret

00006c22 <__udivmodsi4>:
    6c22:	a1 e2       	ldi	r26, 0x21	; 33
    6c24:	1a 2e       	mov	r1, r26
    6c26:	aa 1b       	sub	r26, r26
    6c28:	bb 1b       	sub	r27, r27
    6c2a:	fd 01       	movw	r30, r26
    6c2c:	0d c0       	rjmp	.+26     	; 0x6c48 <__udivmodsi4_ep>

00006c2e <__udivmodsi4_loop>:
    6c2e:	aa 1f       	adc	r26, r26
    6c30:	bb 1f       	adc	r27, r27
    6c32:	ee 1f       	adc	r30, r30
    6c34:	ff 1f       	adc	r31, r31
    6c36:	a2 17       	cp	r26, r18
    6c38:	b3 07       	cpc	r27, r19
    6c3a:	e4 07       	cpc	r30, r20
    6c3c:	f5 07       	cpc	r31, r21
    6c3e:	20 f0       	brcs	.+8      	; 0x6c48 <__udivmodsi4_ep>
    6c40:	a2 1b       	sub	r26, r18
    6c42:	b3 0b       	sbc	r27, r19
    6c44:	e4 0b       	sbc	r30, r20
    6c46:	f5 0b       	sbc	r31, r21

00006c48 <__udivmodsi4_ep>:
    6c48:	66 1f       	adc	r22, r22
    6c4a:	77 1f       	adc	r23, r23
    6c4c:	88 1f       	adc	r24, r24
    6c4e:	99 1f       	adc	r25, r25
    6c50:	1a 94       	dec	r1
    6c52:	69 f7       	brne	.-38     	; 0x6c2e <__udivmodsi4_loop>
    6c54:	60 95       	com	r22
    6c56:	70 95       	com	r23
    6c58:	80 95       	com	r24
    6c5a:	90 95       	com	r25
    6c5c:	9b 01       	movw	r18, r22
    6c5e:	ac 01       	movw	r20, r24
    6c60:	bd 01       	movw	r22, r26
    6c62:	cf 01       	movw	r24, r30
    6c64:	08 95       	ret

00006c66 <__divmodsi4>:
    6c66:	97 fb       	bst	r25, 7
    6c68:	09 2e       	mov	r0, r25
    6c6a:	05 26       	eor	r0, r21
    6c6c:	0e d0       	rcall	.+28     	; 0x6c8a <__divmodsi4_neg1>
    6c6e:	57 fd       	sbrc	r21, 7
    6c70:	04 d0       	rcall	.+8      	; 0x6c7a <__divmodsi4_neg2>
    6c72:	d7 df       	rcall	.-82     	; 0x6c22 <__udivmodsi4>
    6c74:	0a d0       	rcall	.+20     	; 0x6c8a <__divmodsi4_neg1>
    6c76:	00 1c       	adc	r0, r0
    6c78:	38 f4       	brcc	.+14     	; 0x6c88 <__divmodsi4_exit>

00006c7a <__divmodsi4_neg2>:
    6c7a:	50 95       	com	r21
    6c7c:	40 95       	com	r20
    6c7e:	30 95       	com	r19
    6c80:	21 95       	neg	r18
    6c82:	3f 4f       	sbci	r19, 0xFF	; 255
    6c84:	4f 4f       	sbci	r20, 0xFF	; 255
    6c86:	5f 4f       	sbci	r21, 0xFF	; 255

00006c88 <__divmodsi4_exit>:
    6c88:	08 95       	ret

00006c8a <__divmodsi4_neg1>:
    6c8a:	f6 f7       	brtc	.-4      	; 0x6c88 <__divmodsi4_exit>
    6c8c:	90 95       	com	r25
    6c8e:	80 95       	com	r24
    6c90:	70 95       	com	r23
    6c92:	61 95       	neg	r22
    6c94:	7f 4f       	sbci	r23, 0xFF	; 255
    6c96:	8f 4f       	sbci	r24, 0xFF	; 255
    6c98:	9f 4f       	sbci	r25, 0xFF	; 255
    6c9a:	08 95       	ret

00006c9c <__udivmodhi4>:
    6c9c:	aa 1b       	sub	r26, r26
    6c9e:	bb 1b       	sub	r27, r27
    6ca0:	51 e1       	ldi	r21, 0x11	; 17
    6ca2:	07 c0       	rjmp	.+14     	; 0x6cb2 <__udivmodhi4_ep>

00006ca4 <__udivmodhi4_loop>:
    6ca4:	aa 1f       	adc	r26, r26
    6ca6:	bb 1f       	adc	r27, r27
    6ca8:	a6 17       	cp	r26, r22
    6caa:	b7 07       	cpc	r27, r23
    6cac:	10 f0       	brcs	.+4      	; 0x6cb2 <__udivmodhi4_ep>
    6cae:	a6 1b       	sub	r26, r22
    6cb0:	b7 0b       	sbc	r27, r23

00006cb2 <__udivmodhi4_ep>:
    6cb2:	88 1f       	adc	r24, r24
    6cb4:	99 1f       	adc	r25, r25
    6cb6:	5a 95       	dec	r21
    6cb8:	a9 f7       	brne	.-22     	; 0x6ca4 <__udivmodhi4_loop>
    6cba:	80 95       	com	r24
    6cbc:	90 95       	com	r25
    6cbe:	bc 01       	movw	r22, r24
    6cc0:	cd 01       	movw	r24, r26
    6cc2:	08 95       	ret

00006cc4 <__prologue_saves__>:
    6cc4:	2f 92       	push	r2
    6cc6:	3f 92       	push	r3
    6cc8:	4f 92       	push	r4
    6cca:	5f 92       	push	r5
    6ccc:	6f 92       	push	r6
    6cce:	7f 92       	push	r7
    6cd0:	8f 92       	push	r8
    6cd2:	9f 92       	push	r9
    6cd4:	af 92       	push	r10
    6cd6:	bf 92       	push	r11
    6cd8:	cf 92       	push	r12
    6cda:	df 92       	push	r13
    6cdc:	ef 92       	push	r14
    6cde:	ff 92       	push	r15
    6ce0:	0f 93       	push	r16
    6ce2:	1f 93       	push	r17
    6ce4:	cf 93       	push	r28
    6ce6:	df 93       	push	r29
    6ce8:	cd b7       	in	r28, 0x3d	; 61
    6cea:	de b7       	in	r29, 0x3e	; 62
    6cec:	ca 1b       	sub	r28, r26
    6cee:	db 0b       	sbc	r29, r27
    6cf0:	cd bf       	out	0x3d, r28	; 61
    6cf2:	de bf       	out	0x3e, r29	; 62
    6cf4:	19 94       	eijmp

00006cf6 <__epilogue_restores__>:
    6cf6:	2a 88       	ldd	r2, Y+18	; 0x12
    6cf8:	39 88       	ldd	r3, Y+17	; 0x11
    6cfa:	48 88       	ldd	r4, Y+16	; 0x10
    6cfc:	5f 84       	ldd	r5, Y+15	; 0x0f
    6cfe:	6e 84       	ldd	r6, Y+14	; 0x0e
    6d00:	7d 84       	ldd	r7, Y+13	; 0x0d
    6d02:	8c 84       	ldd	r8, Y+12	; 0x0c
    6d04:	9b 84       	ldd	r9, Y+11	; 0x0b
    6d06:	aa 84       	ldd	r10, Y+10	; 0x0a
    6d08:	b9 84       	ldd	r11, Y+9	; 0x09
    6d0a:	c8 84       	ldd	r12, Y+8	; 0x08
    6d0c:	df 80       	ldd	r13, Y+7	; 0x07
    6d0e:	ee 80       	ldd	r14, Y+6	; 0x06
    6d10:	fd 80       	ldd	r15, Y+5	; 0x05
    6d12:	0c 81       	ldd	r16, Y+4	; 0x04
    6d14:	1b 81       	ldd	r17, Y+3	; 0x03
    6d16:	aa 81       	ldd	r26, Y+2	; 0x02
    6d18:	b9 81       	ldd	r27, Y+1	; 0x01
    6d1a:	ce 0f       	add	r28, r30
    6d1c:	d1 1d       	adc	r29, r1
    6d1e:	cd bf       	out	0x3d, r28	; 61
    6d20:	de bf       	out	0x3e, r29	; 62
    6d22:	ed 01       	movw	r28, r26
    6d24:	08 95       	ret

00006d26 <strcpy_P>:
    6d26:	fb 01       	movw	r30, r22
    6d28:	dc 01       	movw	r26, r24
    6d2a:	05 90       	lpm	r0, Z+
    6d2c:	0d 92       	st	X+, r0
    6d2e:	00 20       	and	r0, r0
    6d30:	e1 f7       	brne	.-8      	; 0x6d2a <strcpy_P+0x4>
    6d32:	08 95       	ret

00006d34 <memmove>:
    6d34:	68 17       	cp	r22, r24
    6d36:	79 07       	cpc	r23, r25
    6d38:	68 f4       	brcc	.+26     	; 0x6d54 <memmove+0x20>
    6d3a:	fb 01       	movw	r30, r22
    6d3c:	dc 01       	movw	r26, r24
    6d3e:	e4 0f       	add	r30, r20
    6d40:	f5 1f       	adc	r31, r21
    6d42:	a4 0f       	add	r26, r20
    6d44:	b5 1f       	adc	r27, r21
    6d46:	02 c0       	rjmp	.+4      	; 0x6d4c <memmove+0x18>
    6d48:	02 90       	ld	r0, -Z
    6d4a:	0e 92       	st	-X, r0
    6d4c:	41 50       	subi	r20, 0x01	; 1
    6d4e:	50 40       	sbci	r21, 0x00	; 0
    6d50:	d8 f7       	brcc	.-10     	; 0x6d48 <memmove+0x14>
    6d52:	08 95       	ret
    6d54:	0c 94 1f 39 	jmp	0x723e	; 0x723e <memcpy>

00006d58 <strcat>:
    6d58:	fb 01       	movw	r30, r22
    6d5a:	dc 01       	movw	r26, r24
    6d5c:	0d 90       	ld	r0, X+
    6d5e:	00 20       	and	r0, r0
    6d60:	e9 f7       	brne	.-6      	; 0x6d5c <strcat+0x4>
    6d62:	11 97       	sbiw	r26, 0x01	; 1
    6d64:	01 90       	ld	r0, Z+
    6d66:	0d 92       	st	X+, r0
    6d68:	00 20       	and	r0, r0
    6d6a:	e1 f7       	brne	.-8      	; 0x6d64 <strcat+0xc>
    6d6c:	08 95       	ret

00006d6e <itoa>:
    6d6e:	fb 01       	movw	r30, r22
    6d70:	9f 01       	movw	r18, r30
    6d72:	e8 94       	clt
    6d74:	42 30       	cpi	r20, 0x02	; 2
    6d76:	c4 f0       	brlt	.+48     	; 0x6da8 <itoa+0x3a>
    6d78:	45 32       	cpi	r20, 0x25	; 37
    6d7a:	b4 f4       	brge	.+44     	; 0x6da8 <itoa+0x3a>
    6d7c:	4a 30       	cpi	r20, 0x0A	; 10
    6d7e:	29 f4       	brne	.+10     	; 0x6d8a <itoa+0x1c>
    6d80:	97 fb       	bst	r25, 7
    6d82:	1e f4       	brtc	.+6      	; 0x6d8a <itoa+0x1c>
    6d84:	90 95       	com	r25
    6d86:	81 95       	neg	r24
    6d88:	9f 4f       	sbci	r25, 0xFF	; 255
    6d8a:	64 2f       	mov	r22, r20
    6d8c:	77 27       	eor	r23, r23
    6d8e:	0e 94 4e 36 	call	0x6c9c	; 0x6c9c <__udivmodhi4>
    6d92:	80 5d       	subi	r24, 0xD0	; 208
    6d94:	8a 33       	cpi	r24, 0x3A	; 58
    6d96:	0c f0       	brlt	.+2      	; 0x6d9a <itoa+0x2c>
    6d98:	89 5d       	subi	r24, 0xD9	; 217
    6d9a:	81 93       	st	Z+, r24
    6d9c:	cb 01       	movw	r24, r22
    6d9e:	00 97       	sbiw	r24, 0x00	; 0
    6da0:	a1 f7       	brne	.-24     	; 0x6d8a <itoa+0x1c>
    6da2:	16 f4       	brtc	.+4      	; 0x6da8 <itoa+0x3a>
    6da4:	5d e2       	ldi	r21, 0x2D	; 45
    6da6:	51 93       	st	Z+, r21
    6da8:	10 82       	st	Z, r1
    6daa:	c9 01       	movw	r24, r18
    6dac:	0c 94 33 39 	jmp	0x7266	; 0x7266 <strrev>

00006db0 <printf>:
    6db0:	cf 93       	push	r28
    6db2:	df 93       	push	r29
    6db4:	cd b7       	in	r28, 0x3d	; 61
    6db6:	de b7       	in	r29, 0x3e	; 62
    6db8:	fe 01       	movw	r30, r28
    6dba:	36 96       	adiw	r30, 0x06	; 6
    6dbc:	61 91       	ld	r22, Z+
    6dbe:	71 91       	ld	r23, Z+
    6dc0:	80 91 af 50 	lds	r24, 0x50AF
    6dc4:	90 91 b0 50 	lds	r25, 0x50B0
    6dc8:	af 01       	movw	r20, r30
    6dca:	0e 94 13 37 	call	0x6e26	; 0x6e26 <vfprintf>
    6dce:	df 91       	pop	r29
    6dd0:	cf 91       	pop	r28
    6dd2:	08 95       	ret

00006dd4 <sprintf>:
    6dd4:	0f 93       	push	r16
    6dd6:	1f 93       	push	r17
    6dd8:	cf 93       	push	r28
    6dda:	df 93       	push	r29
    6ddc:	cd b7       	in	r28, 0x3d	; 61
    6dde:	de b7       	in	r29, 0x3e	; 62
    6de0:	2e 97       	sbiw	r28, 0x0e	; 14
    6de2:	cd bf       	out	0x3d, r28	; 61
    6de4:	de bf       	out	0x3e, r29	; 62
    6de6:	0e 89       	ldd	r16, Y+22	; 0x16
    6de8:	1f 89       	ldd	r17, Y+23	; 0x17
    6dea:	86 e0       	ldi	r24, 0x06	; 6
    6dec:	8c 83       	std	Y+4, r24	; 0x04
    6dee:	09 83       	std	Y+1, r16	; 0x01
    6df0:	1a 83       	std	Y+2, r17	; 0x02
    6df2:	8f ef       	ldi	r24, 0xFF	; 255
    6df4:	9f e7       	ldi	r25, 0x7F	; 127
    6df6:	8d 83       	std	Y+5, r24	; 0x05
    6df8:	9e 83       	std	Y+6, r25	; 0x06
    6dfa:	ae 01       	movw	r20, r28
    6dfc:	46 5e       	subi	r20, 0xE6	; 230
    6dfe:	5f 4f       	sbci	r21, 0xFF	; 255
    6e00:	ce 01       	movw	r24, r28
    6e02:	01 96       	adiw	r24, 0x01	; 1
    6e04:	68 8d       	ldd	r22, Y+24	; 0x18
    6e06:	79 8d       	ldd	r23, Y+25	; 0x19
    6e08:	0e 94 13 37 	call	0x6e26	; 0x6e26 <vfprintf>
    6e0c:	ef 81       	ldd	r30, Y+7	; 0x07
    6e0e:	f8 85       	ldd	r31, Y+8	; 0x08
    6e10:	e0 0f       	add	r30, r16
    6e12:	f1 1f       	adc	r31, r17
    6e14:	10 82       	st	Z, r1
    6e16:	2e 96       	adiw	r28, 0x0e	; 14
    6e18:	cd bf       	out	0x3d, r28	; 61
    6e1a:	de bf       	out	0x3e, r29	; 62
    6e1c:	df 91       	pop	r29
    6e1e:	cf 91       	pop	r28
    6e20:	1f 91       	pop	r17
    6e22:	0f 91       	pop	r16
    6e24:	08 95       	ret

00006e26 <vfprintf>:
    6e26:	2f 92       	push	r2
    6e28:	3f 92       	push	r3
    6e2a:	4f 92       	push	r4
    6e2c:	5f 92       	push	r5
    6e2e:	6f 92       	push	r6
    6e30:	7f 92       	push	r7
    6e32:	8f 92       	push	r8
    6e34:	9f 92       	push	r9
    6e36:	af 92       	push	r10
    6e38:	bf 92       	push	r11
    6e3a:	cf 92       	push	r12
    6e3c:	df 92       	push	r13
    6e3e:	ef 92       	push	r14
    6e40:	ff 92       	push	r15
    6e42:	0f 93       	push	r16
    6e44:	1f 93       	push	r17
    6e46:	cf 93       	push	r28
    6e48:	df 93       	push	r29
    6e4a:	cd b7       	in	r28, 0x3d	; 61
    6e4c:	de b7       	in	r29, 0x3e	; 62
    6e4e:	2d 97       	sbiw	r28, 0x0d	; 13
    6e50:	cd bf       	out	0x3d, r28	; 61
    6e52:	de bf       	out	0x3e, r29	; 62
    6e54:	3c 01       	movw	r6, r24
    6e56:	6c 87       	std	Y+12, r22	; 0x0c
    6e58:	7d 87       	std	Y+13, r23	; 0x0d
    6e5a:	5a 01       	movw	r10, r20
    6e5c:	fc 01       	movw	r30, r24
    6e5e:	16 82       	std	Z+6, r1	; 0x06
    6e60:	17 82       	std	Z+7, r1	; 0x07
    6e62:	83 81       	ldd	r24, Z+3	; 0x03
    6e64:	81 ff       	sbrs	r24, 1
    6e66:	c8 c1       	rjmp	.+912    	; 0x71f8 <vfprintf+0x3d2>
    6e68:	2e 01       	movw	r4, r28
    6e6a:	08 94       	sec
    6e6c:	41 1c       	adc	r4, r1
    6e6e:	51 1c       	adc	r5, r1
    6e70:	f3 01       	movw	r30, r6
    6e72:	93 81       	ldd	r25, Z+3	; 0x03
    6e74:	ec 85       	ldd	r30, Y+12	; 0x0c
    6e76:	fd 85       	ldd	r31, Y+13	; 0x0d
    6e78:	93 fd       	sbrc	r25, 3
    6e7a:	85 91       	lpm	r24, Z+
    6e7c:	93 ff       	sbrs	r25, 3
    6e7e:	81 91       	ld	r24, Z+
    6e80:	ec 87       	std	Y+12, r30	; 0x0c
    6e82:	fd 87       	std	Y+13, r31	; 0x0d
    6e84:	88 23       	and	r24, r24
    6e86:	09 f4       	brne	.+2      	; 0x6e8a <vfprintf+0x64>
    6e88:	b3 c1       	rjmp	.+870    	; 0x71f0 <vfprintf+0x3ca>
    6e8a:	85 32       	cpi	r24, 0x25	; 37
    6e8c:	41 f4       	brne	.+16     	; 0x6e9e <vfprintf+0x78>
    6e8e:	93 fd       	sbrc	r25, 3
    6e90:	85 91       	lpm	r24, Z+
    6e92:	93 ff       	sbrs	r25, 3
    6e94:	81 91       	ld	r24, Z+
    6e96:	ec 87       	std	Y+12, r30	; 0x0c
    6e98:	fd 87       	std	Y+13, r31	; 0x0d
    6e9a:	85 32       	cpi	r24, 0x25	; 37
    6e9c:	29 f4       	brne	.+10     	; 0x6ea8 <vfprintf+0x82>
    6e9e:	90 e0       	ldi	r25, 0x00	; 0
    6ea0:	b3 01       	movw	r22, r6
    6ea2:	0e 94 43 39 	call	0x7286	; 0x7286 <fputc>
    6ea6:	e4 cf       	rjmp	.-56     	; 0x6e70 <vfprintf+0x4a>
    6ea8:	ff 24       	eor	r15, r15
    6eaa:	ee 24       	eor	r14, r14
    6eac:	10 e0       	ldi	r17, 0x00	; 0
    6eae:	10 32       	cpi	r17, 0x20	; 32
    6eb0:	b0 f4       	brcc	.+44     	; 0x6ede <vfprintf+0xb8>
    6eb2:	8b 32       	cpi	r24, 0x2B	; 43
    6eb4:	69 f0       	breq	.+26     	; 0x6ed0 <vfprintf+0xaa>
    6eb6:	8c 32       	cpi	r24, 0x2C	; 44
    6eb8:	28 f4       	brcc	.+10     	; 0x6ec4 <vfprintf+0x9e>
    6eba:	80 32       	cpi	r24, 0x20	; 32
    6ebc:	51 f0       	breq	.+20     	; 0x6ed2 <vfprintf+0xac>
    6ebe:	83 32       	cpi	r24, 0x23	; 35
    6ec0:	71 f4       	brne	.+28     	; 0x6ede <vfprintf+0xb8>
    6ec2:	0b c0       	rjmp	.+22     	; 0x6eda <vfprintf+0xb4>
    6ec4:	8d 32       	cpi	r24, 0x2D	; 45
    6ec6:	39 f0       	breq	.+14     	; 0x6ed6 <vfprintf+0xb0>
    6ec8:	80 33       	cpi	r24, 0x30	; 48
    6eca:	49 f4       	brne	.+18     	; 0x6ede <vfprintf+0xb8>
    6ecc:	11 60       	ori	r17, 0x01	; 1
    6ece:	2c c0       	rjmp	.+88     	; 0x6f28 <vfprintf+0x102>
    6ed0:	12 60       	ori	r17, 0x02	; 2
    6ed2:	14 60       	ori	r17, 0x04	; 4
    6ed4:	29 c0       	rjmp	.+82     	; 0x6f28 <vfprintf+0x102>
    6ed6:	18 60       	ori	r17, 0x08	; 8
    6ed8:	27 c0       	rjmp	.+78     	; 0x6f28 <vfprintf+0x102>
    6eda:	10 61       	ori	r17, 0x10	; 16
    6edc:	25 c0       	rjmp	.+74     	; 0x6f28 <vfprintf+0x102>
    6ede:	17 fd       	sbrc	r17, 7
    6ee0:	2e c0       	rjmp	.+92     	; 0x6f3e <vfprintf+0x118>
    6ee2:	28 2f       	mov	r18, r24
    6ee4:	20 53       	subi	r18, 0x30	; 48
    6ee6:	2a 30       	cpi	r18, 0x0A	; 10
    6ee8:	98 f4       	brcc	.+38     	; 0x6f10 <vfprintf+0xea>
    6eea:	16 ff       	sbrs	r17, 6
    6eec:	08 c0       	rjmp	.+16     	; 0x6efe <vfprintf+0xd8>
    6eee:	8f 2d       	mov	r24, r15
    6ef0:	88 0f       	add	r24, r24
    6ef2:	f8 2e       	mov	r15, r24
    6ef4:	ff 0c       	add	r15, r15
    6ef6:	ff 0c       	add	r15, r15
    6ef8:	f8 0e       	add	r15, r24
    6efa:	f2 0e       	add	r15, r18
    6efc:	15 c0       	rjmp	.+42     	; 0x6f28 <vfprintf+0x102>
    6efe:	8e 2d       	mov	r24, r14
    6f00:	88 0f       	add	r24, r24
    6f02:	e8 2e       	mov	r14, r24
    6f04:	ee 0c       	add	r14, r14
    6f06:	ee 0c       	add	r14, r14
    6f08:	e8 0e       	add	r14, r24
    6f0a:	e2 0e       	add	r14, r18
    6f0c:	10 62       	ori	r17, 0x20	; 32
    6f0e:	0c c0       	rjmp	.+24     	; 0x6f28 <vfprintf+0x102>
    6f10:	8e 32       	cpi	r24, 0x2E	; 46
    6f12:	21 f4       	brne	.+8      	; 0x6f1c <vfprintf+0xf6>
    6f14:	16 fd       	sbrc	r17, 6
    6f16:	6c c1       	rjmp	.+728    	; 0x71f0 <vfprintf+0x3ca>
    6f18:	10 64       	ori	r17, 0x40	; 64
    6f1a:	06 c0       	rjmp	.+12     	; 0x6f28 <vfprintf+0x102>
    6f1c:	8c 36       	cpi	r24, 0x6C	; 108
    6f1e:	11 f4       	brne	.+4      	; 0x6f24 <vfprintf+0xfe>
    6f20:	10 68       	ori	r17, 0x80	; 128
    6f22:	02 c0       	rjmp	.+4      	; 0x6f28 <vfprintf+0x102>
    6f24:	88 36       	cpi	r24, 0x68	; 104
    6f26:	59 f4       	brne	.+22     	; 0x6f3e <vfprintf+0x118>
    6f28:	ec 85       	ldd	r30, Y+12	; 0x0c
    6f2a:	fd 85       	ldd	r31, Y+13	; 0x0d
    6f2c:	93 fd       	sbrc	r25, 3
    6f2e:	85 91       	lpm	r24, Z+
    6f30:	93 ff       	sbrs	r25, 3
    6f32:	81 91       	ld	r24, Z+
    6f34:	ec 87       	std	Y+12, r30	; 0x0c
    6f36:	fd 87       	std	Y+13, r31	; 0x0d
    6f38:	88 23       	and	r24, r24
    6f3a:	09 f0       	breq	.+2      	; 0x6f3e <vfprintf+0x118>
    6f3c:	b8 cf       	rjmp	.-144    	; 0x6eae <vfprintf+0x88>
    6f3e:	98 2f       	mov	r25, r24
    6f40:	95 54       	subi	r25, 0x45	; 69
    6f42:	93 30       	cpi	r25, 0x03	; 3
    6f44:	18 f0       	brcs	.+6      	; 0x6f4c <vfprintf+0x126>
    6f46:	90 52       	subi	r25, 0x20	; 32
    6f48:	93 30       	cpi	r25, 0x03	; 3
    6f4a:	38 f4       	brcc	.+14     	; 0x6f5a <vfprintf+0x134>
    6f4c:	24 e0       	ldi	r18, 0x04	; 4
    6f4e:	30 e0       	ldi	r19, 0x00	; 0
    6f50:	a2 0e       	add	r10, r18
    6f52:	b3 1e       	adc	r11, r19
    6f54:	3f e3       	ldi	r19, 0x3F	; 63
    6f56:	39 83       	std	Y+1, r19	; 0x01
    6f58:	0f c0       	rjmp	.+30     	; 0x6f78 <vfprintf+0x152>
    6f5a:	83 36       	cpi	r24, 0x63	; 99
    6f5c:	31 f0       	breq	.+12     	; 0x6f6a <vfprintf+0x144>
    6f5e:	83 37       	cpi	r24, 0x73	; 115
    6f60:	81 f0       	breq	.+32     	; 0x6f82 <vfprintf+0x15c>
    6f62:	83 35       	cpi	r24, 0x53	; 83
    6f64:	09 f0       	breq	.+2      	; 0x6f68 <vfprintf+0x142>
    6f66:	5a c0       	rjmp	.+180    	; 0x701c <vfprintf+0x1f6>
    6f68:	22 c0       	rjmp	.+68     	; 0x6fae <vfprintf+0x188>
    6f6a:	f5 01       	movw	r30, r10
    6f6c:	80 81       	ld	r24, Z
    6f6e:	89 83       	std	Y+1, r24	; 0x01
    6f70:	22 e0       	ldi	r18, 0x02	; 2
    6f72:	30 e0       	ldi	r19, 0x00	; 0
    6f74:	a2 0e       	add	r10, r18
    6f76:	b3 1e       	adc	r11, r19
    6f78:	21 e0       	ldi	r18, 0x01	; 1
    6f7a:	c2 2e       	mov	r12, r18
    6f7c:	d1 2c       	mov	r13, r1
    6f7e:	42 01       	movw	r8, r4
    6f80:	14 c0       	rjmp	.+40     	; 0x6faa <vfprintf+0x184>
    6f82:	92 e0       	ldi	r25, 0x02	; 2
    6f84:	29 2e       	mov	r2, r25
    6f86:	31 2c       	mov	r3, r1
    6f88:	2a 0c       	add	r2, r10
    6f8a:	3b 1c       	adc	r3, r11
    6f8c:	f5 01       	movw	r30, r10
    6f8e:	80 80       	ld	r8, Z
    6f90:	91 80       	ldd	r9, Z+1	; 0x01
    6f92:	16 ff       	sbrs	r17, 6
    6f94:	03 c0       	rjmp	.+6      	; 0x6f9c <vfprintf+0x176>
    6f96:	6f 2d       	mov	r22, r15
    6f98:	70 e0       	ldi	r23, 0x00	; 0
    6f9a:	02 c0       	rjmp	.+4      	; 0x6fa0 <vfprintf+0x17a>
    6f9c:	6f ef       	ldi	r22, 0xFF	; 255
    6f9e:	7f ef       	ldi	r23, 0xFF	; 255
    6fa0:	c4 01       	movw	r24, r8
    6fa2:	0e 94 28 39 	call	0x7250	; 0x7250 <strnlen>
    6fa6:	6c 01       	movw	r12, r24
    6fa8:	51 01       	movw	r10, r2
    6faa:	1f 77       	andi	r17, 0x7F	; 127
    6fac:	15 c0       	rjmp	.+42     	; 0x6fd8 <vfprintf+0x1b2>
    6fae:	82 e0       	ldi	r24, 0x02	; 2
    6fb0:	28 2e       	mov	r2, r24
    6fb2:	31 2c       	mov	r3, r1
    6fb4:	2a 0c       	add	r2, r10
    6fb6:	3b 1c       	adc	r3, r11
    6fb8:	f5 01       	movw	r30, r10
    6fba:	80 80       	ld	r8, Z
    6fbc:	91 80       	ldd	r9, Z+1	; 0x01
    6fbe:	16 ff       	sbrs	r17, 6
    6fc0:	03 c0       	rjmp	.+6      	; 0x6fc8 <vfprintf+0x1a2>
    6fc2:	6f 2d       	mov	r22, r15
    6fc4:	70 e0       	ldi	r23, 0x00	; 0
    6fc6:	02 c0       	rjmp	.+4      	; 0x6fcc <vfprintf+0x1a6>
    6fc8:	6f ef       	ldi	r22, 0xFF	; 255
    6fca:	7f ef       	ldi	r23, 0xFF	; 255
    6fcc:	c4 01       	movw	r24, r8
    6fce:	0e 94 14 39 	call	0x7228	; 0x7228 <strnlen_P>
    6fd2:	6c 01       	movw	r12, r24
    6fd4:	10 68       	ori	r17, 0x80	; 128
    6fd6:	51 01       	movw	r10, r2
    6fd8:	13 fd       	sbrc	r17, 3
    6fda:	1c c0       	rjmp	.+56     	; 0x7014 <vfprintf+0x1ee>
    6fdc:	06 c0       	rjmp	.+12     	; 0x6fea <vfprintf+0x1c4>
    6fde:	80 e2       	ldi	r24, 0x20	; 32
    6fe0:	90 e0       	ldi	r25, 0x00	; 0
    6fe2:	b3 01       	movw	r22, r6
    6fe4:	0e 94 43 39 	call	0x7286	; 0x7286 <fputc>
    6fe8:	ea 94       	dec	r14
    6fea:	8e 2d       	mov	r24, r14
    6fec:	90 e0       	ldi	r25, 0x00	; 0
    6fee:	c8 16       	cp	r12, r24
    6ff0:	d9 06       	cpc	r13, r25
    6ff2:	a8 f3       	brcs	.-22     	; 0x6fde <vfprintf+0x1b8>
    6ff4:	0f c0       	rjmp	.+30     	; 0x7014 <vfprintf+0x1ee>
    6ff6:	f4 01       	movw	r30, r8
    6ff8:	17 fd       	sbrc	r17, 7
    6ffa:	85 91       	lpm	r24, Z+
    6ffc:	17 ff       	sbrs	r17, 7
    6ffe:	81 91       	ld	r24, Z+
    7000:	4f 01       	movw	r8, r30
    7002:	90 e0       	ldi	r25, 0x00	; 0
    7004:	b3 01       	movw	r22, r6
    7006:	0e 94 43 39 	call	0x7286	; 0x7286 <fputc>
    700a:	e1 10       	cpse	r14, r1
    700c:	ea 94       	dec	r14
    700e:	08 94       	sec
    7010:	c1 08       	sbc	r12, r1
    7012:	d1 08       	sbc	r13, r1
    7014:	c1 14       	cp	r12, r1
    7016:	d1 04       	cpc	r13, r1
    7018:	71 f7       	brne	.-36     	; 0x6ff6 <vfprintf+0x1d0>
    701a:	e7 c0       	rjmp	.+462    	; 0x71ea <vfprintf+0x3c4>
    701c:	84 36       	cpi	r24, 0x64	; 100
    701e:	11 f0       	breq	.+4      	; 0x7024 <vfprintf+0x1fe>
    7020:	89 36       	cpi	r24, 0x69	; 105
    7022:	51 f5       	brne	.+84     	; 0x7078 <vfprintf+0x252>
    7024:	f5 01       	movw	r30, r10
    7026:	17 ff       	sbrs	r17, 7
    7028:	07 c0       	rjmp	.+14     	; 0x7038 <vfprintf+0x212>
    702a:	80 81       	ld	r24, Z
    702c:	91 81       	ldd	r25, Z+1	; 0x01
    702e:	a2 81       	ldd	r26, Z+2	; 0x02
    7030:	b3 81       	ldd	r27, Z+3	; 0x03
    7032:	24 e0       	ldi	r18, 0x04	; 4
    7034:	30 e0       	ldi	r19, 0x00	; 0
    7036:	08 c0       	rjmp	.+16     	; 0x7048 <vfprintf+0x222>
    7038:	80 81       	ld	r24, Z
    703a:	91 81       	ldd	r25, Z+1	; 0x01
    703c:	aa 27       	eor	r26, r26
    703e:	97 fd       	sbrc	r25, 7
    7040:	a0 95       	com	r26
    7042:	ba 2f       	mov	r27, r26
    7044:	22 e0       	ldi	r18, 0x02	; 2
    7046:	30 e0       	ldi	r19, 0x00	; 0
    7048:	a2 0e       	add	r10, r18
    704a:	b3 1e       	adc	r11, r19
    704c:	01 2f       	mov	r16, r17
    704e:	0f 76       	andi	r16, 0x6F	; 111
    7050:	b7 ff       	sbrs	r27, 7
    7052:	08 c0       	rjmp	.+16     	; 0x7064 <vfprintf+0x23e>
    7054:	b0 95       	com	r27
    7056:	a0 95       	com	r26
    7058:	90 95       	com	r25
    705a:	81 95       	neg	r24
    705c:	9f 4f       	sbci	r25, 0xFF	; 255
    705e:	af 4f       	sbci	r26, 0xFF	; 255
    7060:	bf 4f       	sbci	r27, 0xFF	; 255
    7062:	00 68       	ori	r16, 0x80	; 128
    7064:	bc 01       	movw	r22, r24
    7066:	cd 01       	movw	r24, r26
    7068:	a2 01       	movw	r20, r4
    706a:	2a e0       	ldi	r18, 0x0A	; 10
    706c:	30 e0       	ldi	r19, 0x00	; 0
    706e:	0e 94 6f 39 	call	0x72de	; 0x72de <__ultoa_invert>
    7072:	d8 2e       	mov	r13, r24
    7074:	d4 18       	sub	r13, r4
    7076:	3f c0       	rjmp	.+126    	; 0x70f6 <vfprintf+0x2d0>
    7078:	85 37       	cpi	r24, 0x75	; 117
    707a:	21 f4       	brne	.+8      	; 0x7084 <vfprintf+0x25e>
    707c:	1f 7e       	andi	r17, 0xEF	; 239
    707e:	2a e0       	ldi	r18, 0x0A	; 10
    7080:	30 e0       	ldi	r19, 0x00	; 0
    7082:	20 c0       	rjmp	.+64     	; 0x70c4 <vfprintf+0x29e>
    7084:	19 7f       	andi	r17, 0xF9	; 249
    7086:	8f 36       	cpi	r24, 0x6F	; 111
    7088:	a9 f0       	breq	.+42     	; 0x70b4 <vfprintf+0x28e>
    708a:	80 37       	cpi	r24, 0x70	; 112
    708c:	20 f4       	brcc	.+8      	; 0x7096 <vfprintf+0x270>
    708e:	88 35       	cpi	r24, 0x58	; 88
    7090:	09 f0       	breq	.+2      	; 0x7094 <vfprintf+0x26e>
    7092:	ae c0       	rjmp	.+348    	; 0x71f0 <vfprintf+0x3ca>
    7094:	0b c0       	rjmp	.+22     	; 0x70ac <vfprintf+0x286>
    7096:	80 37       	cpi	r24, 0x70	; 112
    7098:	21 f0       	breq	.+8      	; 0x70a2 <vfprintf+0x27c>
    709a:	88 37       	cpi	r24, 0x78	; 120
    709c:	09 f0       	breq	.+2      	; 0x70a0 <vfprintf+0x27a>
    709e:	a8 c0       	rjmp	.+336    	; 0x71f0 <vfprintf+0x3ca>
    70a0:	01 c0       	rjmp	.+2      	; 0x70a4 <vfprintf+0x27e>
    70a2:	10 61       	ori	r17, 0x10	; 16
    70a4:	14 ff       	sbrs	r17, 4
    70a6:	09 c0       	rjmp	.+18     	; 0x70ba <vfprintf+0x294>
    70a8:	14 60       	ori	r17, 0x04	; 4
    70aa:	07 c0       	rjmp	.+14     	; 0x70ba <vfprintf+0x294>
    70ac:	14 ff       	sbrs	r17, 4
    70ae:	08 c0       	rjmp	.+16     	; 0x70c0 <vfprintf+0x29a>
    70b0:	16 60       	ori	r17, 0x06	; 6
    70b2:	06 c0       	rjmp	.+12     	; 0x70c0 <vfprintf+0x29a>
    70b4:	28 e0       	ldi	r18, 0x08	; 8
    70b6:	30 e0       	ldi	r19, 0x00	; 0
    70b8:	05 c0       	rjmp	.+10     	; 0x70c4 <vfprintf+0x29e>
    70ba:	20 e1       	ldi	r18, 0x10	; 16
    70bc:	30 e0       	ldi	r19, 0x00	; 0
    70be:	02 c0       	rjmp	.+4      	; 0x70c4 <vfprintf+0x29e>
    70c0:	20 e1       	ldi	r18, 0x10	; 16
    70c2:	32 e0       	ldi	r19, 0x02	; 2
    70c4:	f5 01       	movw	r30, r10
    70c6:	17 ff       	sbrs	r17, 7
    70c8:	07 c0       	rjmp	.+14     	; 0x70d8 <vfprintf+0x2b2>
    70ca:	60 81       	ld	r22, Z
    70cc:	71 81       	ldd	r23, Z+1	; 0x01
    70ce:	82 81       	ldd	r24, Z+2	; 0x02
    70d0:	93 81       	ldd	r25, Z+3	; 0x03
    70d2:	44 e0       	ldi	r20, 0x04	; 4
    70d4:	50 e0       	ldi	r21, 0x00	; 0
    70d6:	06 c0       	rjmp	.+12     	; 0x70e4 <vfprintf+0x2be>
    70d8:	60 81       	ld	r22, Z
    70da:	71 81       	ldd	r23, Z+1	; 0x01
    70dc:	80 e0       	ldi	r24, 0x00	; 0
    70de:	90 e0       	ldi	r25, 0x00	; 0
    70e0:	42 e0       	ldi	r20, 0x02	; 2
    70e2:	50 e0       	ldi	r21, 0x00	; 0
    70e4:	a4 0e       	add	r10, r20
    70e6:	b5 1e       	adc	r11, r21
    70e8:	a2 01       	movw	r20, r4
    70ea:	0e 94 6f 39 	call	0x72de	; 0x72de <__ultoa_invert>
    70ee:	d8 2e       	mov	r13, r24
    70f0:	d4 18       	sub	r13, r4
    70f2:	01 2f       	mov	r16, r17
    70f4:	0f 77       	andi	r16, 0x7F	; 127
    70f6:	06 ff       	sbrs	r16, 6
    70f8:	09 c0       	rjmp	.+18     	; 0x710c <vfprintf+0x2e6>
    70fa:	0e 7f       	andi	r16, 0xFE	; 254
    70fc:	df 14       	cp	r13, r15
    70fe:	30 f4       	brcc	.+12     	; 0x710c <vfprintf+0x2e6>
    7100:	04 ff       	sbrs	r16, 4
    7102:	06 c0       	rjmp	.+12     	; 0x7110 <vfprintf+0x2ea>
    7104:	02 fd       	sbrc	r16, 2
    7106:	04 c0       	rjmp	.+8      	; 0x7110 <vfprintf+0x2ea>
    7108:	0f 7e       	andi	r16, 0xEF	; 239
    710a:	02 c0       	rjmp	.+4      	; 0x7110 <vfprintf+0x2ea>
    710c:	1d 2d       	mov	r17, r13
    710e:	01 c0       	rjmp	.+2      	; 0x7112 <vfprintf+0x2ec>
    7110:	1f 2d       	mov	r17, r15
    7112:	80 2f       	mov	r24, r16
    7114:	90 e0       	ldi	r25, 0x00	; 0
    7116:	04 ff       	sbrs	r16, 4
    7118:	0c c0       	rjmp	.+24     	; 0x7132 <vfprintf+0x30c>
    711a:	fe 01       	movw	r30, r28
    711c:	ed 0d       	add	r30, r13
    711e:	f1 1d       	adc	r31, r1
    7120:	20 81       	ld	r18, Z
    7122:	20 33       	cpi	r18, 0x30	; 48
    7124:	11 f4       	brne	.+4      	; 0x712a <vfprintf+0x304>
    7126:	09 7e       	andi	r16, 0xE9	; 233
    7128:	09 c0       	rjmp	.+18     	; 0x713c <vfprintf+0x316>
    712a:	02 ff       	sbrs	r16, 2
    712c:	06 c0       	rjmp	.+12     	; 0x713a <vfprintf+0x314>
    712e:	1e 5f       	subi	r17, 0xFE	; 254
    7130:	05 c0       	rjmp	.+10     	; 0x713c <vfprintf+0x316>
    7132:	86 78       	andi	r24, 0x86	; 134
    7134:	90 70       	andi	r25, 0x00	; 0
    7136:	00 97       	sbiw	r24, 0x00	; 0
    7138:	09 f0       	breq	.+2      	; 0x713c <vfprintf+0x316>
    713a:	1f 5f       	subi	r17, 0xFF	; 255
    713c:	80 2e       	mov	r8, r16
    713e:	99 24       	eor	r9, r9
    7140:	03 fd       	sbrc	r16, 3
    7142:	12 c0       	rjmp	.+36     	; 0x7168 <vfprintf+0x342>
    7144:	00 ff       	sbrs	r16, 0
    7146:	0d c0       	rjmp	.+26     	; 0x7162 <vfprintf+0x33c>
    7148:	fd 2c       	mov	r15, r13
    714a:	1e 15       	cp	r17, r14
    714c:	50 f4       	brcc	.+20     	; 0x7162 <vfprintf+0x33c>
    714e:	fe 0c       	add	r15, r14
    7150:	f1 1a       	sub	r15, r17
    7152:	1e 2d       	mov	r17, r14
    7154:	06 c0       	rjmp	.+12     	; 0x7162 <vfprintf+0x33c>
    7156:	80 e2       	ldi	r24, 0x20	; 32
    7158:	90 e0       	ldi	r25, 0x00	; 0
    715a:	b3 01       	movw	r22, r6
    715c:	0e 94 43 39 	call	0x7286	; 0x7286 <fputc>
    7160:	1f 5f       	subi	r17, 0xFF	; 255
    7162:	1e 15       	cp	r17, r14
    7164:	c0 f3       	brcs	.-16     	; 0x7156 <vfprintf+0x330>
    7166:	04 c0       	rjmp	.+8      	; 0x7170 <vfprintf+0x34a>
    7168:	1e 15       	cp	r17, r14
    716a:	10 f4       	brcc	.+4      	; 0x7170 <vfprintf+0x34a>
    716c:	e1 1a       	sub	r14, r17
    716e:	01 c0       	rjmp	.+2      	; 0x7172 <vfprintf+0x34c>
    7170:	ee 24       	eor	r14, r14
    7172:	84 fe       	sbrs	r8, 4
    7174:	0f c0       	rjmp	.+30     	; 0x7194 <vfprintf+0x36e>
    7176:	80 e3       	ldi	r24, 0x30	; 48
    7178:	90 e0       	ldi	r25, 0x00	; 0
    717a:	b3 01       	movw	r22, r6
    717c:	0e 94 43 39 	call	0x7286	; 0x7286 <fputc>
    7180:	82 fe       	sbrs	r8, 2
    7182:	1f c0       	rjmp	.+62     	; 0x71c2 <vfprintf+0x39c>
    7184:	81 fe       	sbrs	r8, 1
    7186:	03 c0       	rjmp	.+6      	; 0x718e <vfprintf+0x368>
    7188:	88 e5       	ldi	r24, 0x58	; 88
    718a:	90 e0       	ldi	r25, 0x00	; 0
    718c:	10 c0       	rjmp	.+32     	; 0x71ae <vfprintf+0x388>
    718e:	88 e7       	ldi	r24, 0x78	; 120
    7190:	90 e0       	ldi	r25, 0x00	; 0
    7192:	0d c0       	rjmp	.+26     	; 0x71ae <vfprintf+0x388>
    7194:	c4 01       	movw	r24, r8
    7196:	86 78       	andi	r24, 0x86	; 134
    7198:	90 70       	andi	r25, 0x00	; 0
    719a:	00 97       	sbiw	r24, 0x00	; 0
    719c:	91 f0       	breq	.+36     	; 0x71c2 <vfprintf+0x39c>
    719e:	81 fc       	sbrc	r8, 1
    71a0:	02 c0       	rjmp	.+4      	; 0x71a6 <vfprintf+0x380>
    71a2:	80 e2       	ldi	r24, 0x20	; 32
    71a4:	01 c0       	rjmp	.+2      	; 0x71a8 <vfprintf+0x382>
    71a6:	8b e2       	ldi	r24, 0x2B	; 43
    71a8:	07 fd       	sbrc	r16, 7
    71aa:	8d e2       	ldi	r24, 0x2D	; 45
    71ac:	90 e0       	ldi	r25, 0x00	; 0
    71ae:	b3 01       	movw	r22, r6
    71b0:	0e 94 43 39 	call	0x7286	; 0x7286 <fputc>
    71b4:	06 c0       	rjmp	.+12     	; 0x71c2 <vfprintf+0x39c>
    71b6:	80 e3       	ldi	r24, 0x30	; 48
    71b8:	90 e0       	ldi	r25, 0x00	; 0
    71ba:	b3 01       	movw	r22, r6
    71bc:	0e 94 43 39 	call	0x7286	; 0x7286 <fputc>
    71c0:	fa 94       	dec	r15
    71c2:	df 14       	cp	r13, r15
    71c4:	c0 f3       	brcs	.-16     	; 0x71b6 <vfprintf+0x390>
    71c6:	da 94       	dec	r13
    71c8:	f2 01       	movw	r30, r4
    71ca:	ed 0d       	add	r30, r13
    71cc:	f1 1d       	adc	r31, r1
    71ce:	80 81       	ld	r24, Z
    71d0:	90 e0       	ldi	r25, 0x00	; 0
    71d2:	b3 01       	movw	r22, r6
    71d4:	0e 94 43 39 	call	0x7286	; 0x7286 <fputc>
    71d8:	dd 20       	and	r13, r13
    71da:	a9 f7       	brne	.-22     	; 0x71c6 <vfprintf+0x3a0>
    71dc:	06 c0       	rjmp	.+12     	; 0x71ea <vfprintf+0x3c4>
    71de:	80 e2       	ldi	r24, 0x20	; 32
    71e0:	90 e0       	ldi	r25, 0x00	; 0
    71e2:	b3 01       	movw	r22, r6
    71e4:	0e 94 43 39 	call	0x7286	; 0x7286 <fputc>
    71e8:	ea 94       	dec	r14
    71ea:	ee 20       	and	r14, r14
    71ec:	c1 f7       	brne	.-16     	; 0x71de <vfprintf+0x3b8>
    71ee:	40 ce       	rjmp	.-896    	; 0x6e70 <vfprintf+0x4a>
    71f0:	f3 01       	movw	r30, r6
    71f2:	86 81       	ldd	r24, Z+6	; 0x06
    71f4:	97 81       	ldd	r25, Z+7	; 0x07
    71f6:	02 c0       	rjmp	.+4      	; 0x71fc <vfprintf+0x3d6>
    71f8:	8f ef       	ldi	r24, 0xFF	; 255
    71fa:	9f ef       	ldi	r25, 0xFF	; 255
    71fc:	2d 96       	adiw	r28, 0x0d	; 13
    71fe:	cd bf       	out	0x3d, r28	; 61
    7200:	de bf       	out	0x3e, r29	; 62
    7202:	df 91       	pop	r29
    7204:	cf 91       	pop	r28
    7206:	1f 91       	pop	r17
    7208:	0f 91       	pop	r16
    720a:	ff 90       	pop	r15
    720c:	ef 90       	pop	r14
    720e:	df 90       	pop	r13
    7210:	cf 90       	pop	r12
    7212:	bf 90       	pop	r11
    7214:	af 90       	pop	r10
    7216:	9f 90       	pop	r9
    7218:	8f 90       	pop	r8
    721a:	7f 90       	pop	r7
    721c:	6f 90       	pop	r6
    721e:	5f 90       	pop	r5
    7220:	4f 90       	pop	r4
    7222:	3f 90       	pop	r3
    7224:	2f 90       	pop	r2
    7226:	08 95       	ret

00007228 <strnlen_P>:
    7228:	fc 01       	movw	r30, r24
    722a:	05 90       	lpm	r0, Z+
    722c:	61 50       	subi	r22, 0x01	; 1
    722e:	70 40       	sbci	r23, 0x00	; 0
    7230:	01 10       	cpse	r0, r1
    7232:	d8 f7       	brcc	.-10     	; 0x722a <strnlen_P+0x2>
    7234:	80 95       	com	r24
    7236:	90 95       	com	r25
    7238:	8e 0f       	add	r24, r30
    723a:	9f 1f       	adc	r25, r31
    723c:	08 95       	ret

0000723e <memcpy>:
    723e:	fb 01       	movw	r30, r22
    7240:	dc 01       	movw	r26, r24
    7242:	02 c0       	rjmp	.+4      	; 0x7248 <memcpy+0xa>
    7244:	01 90       	ld	r0, Z+
    7246:	0d 92       	st	X+, r0
    7248:	41 50       	subi	r20, 0x01	; 1
    724a:	50 40       	sbci	r21, 0x00	; 0
    724c:	d8 f7       	brcc	.-10     	; 0x7244 <memcpy+0x6>
    724e:	08 95       	ret

00007250 <strnlen>:
    7250:	fc 01       	movw	r30, r24
    7252:	61 50       	subi	r22, 0x01	; 1
    7254:	70 40       	sbci	r23, 0x00	; 0
    7256:	01 90       	ld	r0, Z+
    7258:	01 10       	cpse	r0, r1
    725a:	d8 f7       	brcc	.-10     	; 0x7252 <strnlen+0x2>
    725c:	80 95       	com	r24
    725e:	90 95       	com	r25
    7260:	8e 0f       	add	r24, r30
    7262:	9f 1f       	adc	r25, r31
    7264:	08 95       	ret

00007266 <strrev>:
    7266:	dc 01       	movw	r26, r24
    7268:	fc 01       	movw	r30, r24
    726a:	67 2f       	mov	r22, r23
    726c:	71 91       	ld	r23, Z+
    726e:	77 23       	and	r23, r23
    7270:	e1 f7       	brne	.-8      	; 0x726a <strrev+0x4>
    7272:	32 97       	sbiw	r30, 0x02	; 2
    7274:	04 c0       	rjmp	.+8      	; 0x727e <strrev+0x18>
    7276:	7c 91       	ld	r23, X
    7278:	6d 93       	st	X+, r22
    727a:	70 83       	st	Z, r23
    727c:	62 91       	ld	r22, -Z
    727e:	ae 17       	cp	r26, r30
    7280:	bf 07       	cpc	r27, r31
    7282:	c8 f3       	brcs	.-14     	; 0x7276 <strrev+0x10>
    7284:	08 95       	ret

00007286 <fputc>:
    7286:	0f 93       	push	r16
    7288:	1f 93       	push	r17
    728a:	cf 93       	push	r28
    728c:	df 93       	push	r29
    728e:	8c 01       	movw	r16, r24
    7290:	eb 01       	movw	r28, r22
    7292:	8b 81       	ldd	r24, Y+3	; 0x03
    7294:	81 ff       	sbrs	r24, 1
    7296:	1b c0       	rjmp	.+54     	; 0x72ce <fputc+0x48>
    7298:	82 ff       	sbrs	r24, 2
    729a:	0d c0       	rjmp	.+26     	; 0x72b6 <fputc+0x30>
    729c:	2e 81       	ldd	r18, Y+6	; 0x06
    729e:	3f 81       	ldd	r19, Y+7	; 0x07
    72a0:	8c 81       	ldd	r24, Y+4	; 0x04
    72a2:	9d 81       	ldd	r25, Y+5	; 0x05
    72a4:	28 17       	cp	r18, r24
    72a6:	39 07       	cpc	r19, r25
    72a8:	64 f4       	brge	.+24     	; 0x72c2 <fputc+0x3c>
    72aa:	e8 81       	ld	r30, Y
    72ac:	f9 81       	ldd	r31, Y+1	; 0x01
    72ae:	01 93       	st	Z+, r16
    72b0:	e8 83       	st	Y, r30
    72b2:	f9 83       	std	Y+1, r31	; 0x01
    72b4:	06 c0       	rjmp	.+12     	; 0x72c2 <fputc+0x3c>
    72b6:	e8 85       	ldd	r30, Y+8	; 0x08
    72b8:	f9 85       	ldd	r31, Y+9	; 0x09
    72ba:	80 2f       	mov	r24, r16
    72bc:	19 95       	eicall
    72be:	00 97       	sbiw	r24, 0x00	; 0
    72c0:	31 f4       	brne	.+12     	; 0x72ce <fputc+0x48>
    72c2:	8e 81       	ldd	r24, Y+6	; 0x06
    72c4:	9f 81       	ldd	r25, Y+7	; 0x07
    72c6:	01 96       	adiw	r24, 0x01	; 1
    72c8:	8e 83       	std	Y+6, r24	; 0x06
    72ca:	9f 83       	std	Y+7, r25	; 0x07
    72cc:	02 c0       	rjmp	.+4      	; 0x72d2 <fputc+0x4c>
    72ce:	0f ef       	ldi	r16, 0xFF	; 255
    72d0:	1f ef       	ldi	r17, 0xFF	; 255
    72d2:	c8 01       	movw	r24, r16
    72d4:	df 91       	pop	r29
    72d6:	cf 91       	pop	r28
    72d8:	1f 91       	pop	r17
    72da:	0f 91       	pop	r16
    72dc:	08 95       	ret

000072de <__ultoa_invert>:
    72de:	fa 01       	movw	r30, r20
    72e0:	aa 27       	eor	r26, r26
    72e2:	28 30       	cpi	r18, 0x08	; 8
    72e4:	51 f1       	breq	.+84     	; 0x733a <__ultoa_invert+0x5c>
    72e6:	20 31       	cpi	r18, 0x10	; 16
    72e8:	81 f1       	breq	.+96     	; 0x734a <__ultoa_invert+0x6c>
    72ea:	e8 94       	clt
    72ec:	6f 93       	push	r22
    72ee:	6e 7f       	andi	r22, 0xFE	; 254
    72f0:	6e 5f       	subi	r22, 0xFE	; 254
    72f2:	7f 4f       	sbci	r23, 0xFF	; 255
    72f4:	8f 4f       	sbci	r24, 0xFF	; 255
    72f6:	9f 4f       	sbci	r25, 0xFF	; 255
    72f8:	af 4f       	sbci	r26, 0xFF	; 255
    72fa:	b1 e0       	ldi	r27, 0x01	; 1
    72fc:	3e d0       	rcall	.+124    	; 0x737a <__ultoa_invert+0x9c>
    72fe:	b4 e0       	ldi	r27, 0x04	; 4
    7300:	3c d0       	rcall	.+120    	; 0x737a <__ultoa_invert+0x9c>
    7302:	67 0f       	add	r22, r23
    7304:	78 1f       	adc	r23, r24
    7306:	89 1f       	adc	r24, r25
    7308:	9a 1f       	adc	r25, r26
    730a:	a1 1d       	adc	r26, r1
    730c:	68 0f       	add	r22, r24
    730e:	79 1f       	adc	r23, r25
    7310:	8a 1f       	adc	r24, r26
    7312:	91 1d       	adc	r25, r1
    7314:	a1 1d       	adc	r26, r1
    7316:	6a 0f       	add	r22, r26
    7318:	71 1d       	adc	r23, r1
    731a:	81 1d       	adc	r24, r1
    731c:	91 1d       	adc	r25, r1
    731e:	a1 1d       	adc	r26, r1
    7320:	20 d0       	rcall	.+64     	; 0x7362 <__ultoa_invert+0x84>
    7322:	09 f4       	brne	.+2      	; 0x7326 <__ultoa_invert+0x48>
    7324:	68 94       	set
    7326:	3f 91       	pop	r19
    7328:	2a e0       	ldi	r18, 0x0A	; 10
    732a:	26 9f       	mul	r18, r22
    732c:	11 24       	eor	r1, r1
    732e:	30 19       	sub	r19, r0
    7330:	30 5d       	subi	r19, 0xD0	; 208
    7332:	31 93       	st	Z+, r19
    7334:	de f6       	brtc	.-74     	; 0x72ec <__ultoa_invert+0xe>
    7336:	cf 01       	movw	r24, r30
    7338:	08 95       	ret
    733a:	46 2f       	mov	r20, r22
    733c:	47 70       	andi	r20, 0x07	; 7
    733e:	40 5d       	subi	r20, 0xD0	; 208
    7340:	41 93       	st	Z+, r20
    7342:	b3 e0       	ldi	r27, 0x03	; 3
    7344:	0f d0       	rcall	.+30     	; 0x7364 <__ultoa_invert+0x86>
    7346:	c9 f7       	brne	.-14     	; 0x733a <__ultoa_invert+0x5c>
    7348:	f6 cf       	rjmp	.-20     	; 0x7336 <__ultoa_invert+0x58>
    734a:	46 2f       	mov	r20, r22
    734c:	4f 70       	andi	r20, 0x0F	; 15
    734e:	40 5d       	subi	r20, 0xD0	; 208
    7350:	4a 33       	cpi	r20, 0x3A	; 58
    7352:	18 f0       	brcs	.+6      	; 0x735a <__ultoa_invert+0x7c>
    7354:	49 5d       	subi	r20, 0xD9	; 217
    7356:	31 fd       	sbrc	r19, 1
    7358:	40 52       	subi	r20, 0x20	; 32
    735a:	41 93       	st	Z+, r20
    735c:	02 d0       	rcall	.+4      	; 0x7362 <__ultoa_invert+0x84>
    735e:	a9 f7       	brne	.-22     	; 0x734a <__ultoa_invert+0x6c>
    7360:	ea cf       	rjmp	.-44     	; 0x7336 <__ultoa_invert+0x58>
    7362:	b4 e0       	ldi	r27, 0x04	; 4
    7364:	a6 95       	lsr	r26
    7366:	97 95       	ror	r25
    7368:	87 95       	ror	r24
    736a:	77 95       	ror	r23
    736c:	67 95       	ror	r22
    736e:	ba 95       	dec	r27
    7370:	c9 f7       	brne	.-14     	; 0x7364 <__ultoa_invert+0x86>
    7372:	00 97       	sbiw	r24, 0x00	; 0
    7374:	61 05       	cpc	r22, r1
    7376:	71 05       	cpc	r23, r1
    7378:	08 95       	ret
    737a:	9b 01       	movw	r18, r22
    737c:	ac 01       	movw	r20, r24
    737e:	0a 2e       	mov	r0, r26
    7380:	06 94       	lsr	r0
    7382:	57 95       	ror	r21
    7384:	47 95       	ror	r20
    7386:	37 95       	ror	r19
    7388:	27 95       	ror	r18
    738a:	ba 95       	dec	r27
    738c:	c9 f7       	brne	.-14     	; 0x7380 <__ultoa_invert+0xa2>
    738e:	62 0f       	add	r22, r18
    7390:	73 1f       	adc	r23, r19
    7392:	84 1f       	adc	r24, r20
    7394:	95 1f       	adc	r25, r21
    7396:	a0 1d       	adc	r26, r0
    7398:	08 95       	ret

0000739a <_exit>:
    739a:	f8 94       	cli

0000739c <__stop_program>:
    739c:	ff cf       	rjmp	.-2      	; 0x739c <__stop_program>
