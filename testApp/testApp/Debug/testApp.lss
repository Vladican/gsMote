
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007828  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000010e  00802000  00007828  000078bc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fae  0080210e  0080210e  000079ca  2**0
                  ALLOC
  3 .stab         000028f8  00000000  00000000  000079cc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009ca  00000000  00000000  0000a2c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000420  00000000  00000000  0000ac90  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000c340  00000000  00000000  0000b0b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000272a  00000000  00000000  000173f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000058dd  00000000  00000000  00019b1a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001bd8  00000000  00000000  0001f3f8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000046b8  00000000  00000000  00020fd0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000822a  00000000  00000000  00025688  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0017fdaa  00000000  00000000  0002d8b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000190  00000000  00000000  001ad65c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 43 0d 	jmp	0x1a86	; 0x1a86 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 7b 12 	jmp	0x24f6	; 0x24f6 <__vector_16>
      44:	0c 94 53 12 	jmp	0x24a6	; 0x24a6 <__vector_17>
      48:	0c 94 2b 12 	jmp	0x2456	; 0x2456 <__vector_18>
      4c:	0c 94 e5 11 	jmp	0x23ca	; 0x23ca <__vector_19>
      50:	0c 94 60 0b 	jmp	0x16c0	; 0x16c0 <__vector_20>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 21 04 	jmp	0x842	; 0x842 <__vector_47>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 59 1d 	jmp	0x3ab2	; 0x3ab2 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 22 0f 	jmp	0x1e44	; 0x1e44 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 bd 11 	jmp	0x237a	; 0x237a <__vector_79>
     140:	0c 94 95 11 	jmp	0x232a	; 0x232a <__vector_80>
     144:	0c 94 6d 11 	jmp	0x22da	; 0x22da <__vector_81>
     148:	0c 94 43 11 	jmp	0x2286	; 0x2286 <__vector_82>
     14c:	0c 94 65 08 	jmp	0x10ca	; 0x10ca <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 f2 0b 	jmp	0x17e4	; 0x17e4 <__vector_104>
     1a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e8 e2       	ldi	r30, 0x28	; 40
     244:	f8 e7       	ldi	r31, 0x78	; 120
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	ae 30       	cpi	r26, 0x0E	; 14
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	ae e0       	ldi	r26, 0x0E	; 14
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	ac 3b       	cpi	r26, 0xBC	; 188
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 04 03 	call	0x608	; 0x608 <main>
     26a:	0c 94 12 3c 	jmp	0x7824	; 0x7824 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <writeFRAM>:
 * Created: 3/8/2014 11:40:36 AM
 *  Author: VLAD
 */ 
#include "FRAM.h"

void writeFRAM(uint8_t* buffer, uint16_t length) {
     272:	af 92       	push	r10
     274:	bf 92       	push	r11
     276:	df 92       	push	r13
     278:	ef 92       	push	r14
     27a:	ff 92       	push	r15
     27c:	0f 93       	push	r16
     27e:	1f 93       	push	r17
     280:	cf 93       	push	r28
     282:	df 93       	push	r29
     284:	e8 2e       	mov	r14, r24
     286:	d9 2e       	mov	r13, r25
     288:	8b 01       	movw	r16, r22
	
	uint8_t prev_SPI_settings;
	ADCPower(TRUE);
     28a:	81 e0       	ldi	r24, 0x01	; 1
     28c:	0e 94 0c 07 	call	0xe18	; 0xe18 <ADCPower>
	
	prev_SPI_settings = SPIC.CTRL;
     290:	c0 ec       	ldi	r28, 0xC0	; 192
     292:	d8 e0       	ldi	r29, 0x08	; 8
     294:	f8 80       	ld	r15, Y
	SPIInit(SPI_MODE_0_gc);
     296:	80 e0       	ldi	r24, 0x00	; 0
     298:	0e 94 16 05 	call	0xa2c	; 0xa2c <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     29c:	80 ed       	ldi	r24, 0xD0	; 208
     29e:	88 83       	st	Y, r24
	SPICS(TRUE);
     2a0:	81 e0       	ldi	r24, 0x01	; 1
     2a2:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2a6:	88 e0       	ldi	r24, 0x08	; 8
     2a8:	e0 e2       	ldi	r30, 0x20	; 32
     2aa:	f6 e0       	ldi	r31, 0x06	; 6
     2ac:	86 83       	std	Z+6, r24	; 0x06
	nop();
     2ae:	00 00       	nop
	SPIC.DATA = FR_WREN;
     2b0:	86 e0       	ldi	r24, 0x06	; 6
     2b2:	8b 83       	std	Y+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2b4:	e0 ec       	ldi	r30, 0xC0	; 192
     2b6:	f8 e0       	ldi	r31, 0x08	; 8
     2b8:	82 81       	ldd	r24, Z+2	; 0x02
     2ba:	88 23       	and	r24, r24
     2bc:	ec f7       	brge	.-6      	; 0x2b8 <writeFRAM+0x46>
	SPIBuffer[12] = SPIC.DATA;
     2be:	e0 ec       	ldi	r30, 0xC0	; 192
     2c0:	f8 e0       	ldi	r31, 0x08	; 8
     2c2:	83 81       	ldd	r24, Z+3	; 0x03
     2c4:	80 93 31 3e 	sts	0x3E31, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
     2c8:	a0 e2       	ldi	r26, 0x20	; 32
     2ca:	b6 e0       	ldi	r27, 0x06	; 6
     2cc:	88 e0       	ldi	r24, 0x08	; 8
     2ce:	15 96       	adiw	r26, 0x05	; 5
     2d0:	8c 93       	st	X, r24
     2d2:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
     2d4:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     2d6:	16 96       	adiw	r26, 0x06	; 6
     2d8:	8c 93       	st	X, r24
     2da:	16 97       	sbiw	r26, 0x06	; 6
	nop();
     2dc:	00 00       	nop
	SPIC.DATA = FR_WRITE;
     2de:	82 e0       	ldi	r24, 0x02	; 2
     2e0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2e2:	82 81       	ldd	r24, Z+2	; 0x02
     2e4:	88 23       	and	r24, r24
     2e6:	ec f7       	brge	.-6      	; 0x2e2 <writeFRAM+0x70>
	SPIBuffer[12] = SPIC.DATA;
     2e8:	e0 ec       	ldi	r30, 0xC0	; 192
     2ea:	f8 e0       	ldi	r31, 0x08	; 8
     2ec:	83 81       	ldd	r24, Z+3	; 0x03
     2ee:	80 93 31 3e 	sts	0x3E31, r24
	//send address at which to start writing data
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
     2f2:	80 91 23 3e 	lds	r24, 0x3E23
     2f6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     2f8:	82 81       	ldd	r24, Z+2	; 0x02
     2fa:	88 23       	and	r24, r24
     2fc:	ec f7       	brge	.-6      	; 0x2f8 <writeFRAM+0x86>
	SPIBuffer[12] = SPIC.DATA;
     2fe:	e0 ec       	ldi	r30, 0xC0	; 192
     300:	f8 e0       	ldi	r31, 0x08	; 8
     302:	83 81       	ldd	r24, Z+3	; 0x03
     304:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
     308:	80 91 22 3e 	lds	r24, 0x3E22
     30c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     30e:	82 81       	ldd	r24, Z+2	; 0x02
     310:	88 23       	and	r24, r24
     312:	ec f7       	brge	.-6      	; 0x30e <writeFRAM+0x9c>
	SPIBuffer[12] = SPIC.DATA;
     314:	e0 ec       	ldi	r30, 0xC0	; 192
     316:	f8 e0       	ldi	r31, 0x08	; 8
     318:	83 81       	ldd	r24, Z+3	; 0x03
     31a:	80 93 31 3e 	sts	0x3E31, r24
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     31e:	a8 01       	movw	r20, r16
     320:	60 e0       	ldi	r22, 0x00	; 0
     322:	70 e0       	ldi	r23, 0x00	; 0
     324:	41 15       	cp	r20, r1
     326:	51 05       	cpc	r21, r1
     328:	61 05       	cpc	r22, r1
     32a:	71 05       	cpc	r23, r1
     32c:	c9 f0       	breq	.+50     	; 0x360 <writeFRAM+0xee>
     32e:	ae 2c       	mov	r10, r14
     330:	bd 2c       	mov	r11, r13
     332:	80 e0       	ldi	r24, 0x00	; 0
     334:	90 e0       	ldi	r25, 0x00	; 0
     336:	dc 01       	movw	r26, r24
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     338:	21 e3       	ldi	r18, 0x31	; 49
     33a:	3e e3       	ldi	r19, 0x3E	; 62
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
		SPIC.DATA = buffer[i];
     33c:	e5 01       	movw	r28, r10
     33e:	e9 90       	ld	r14, Y+
     340:	5e 01       	movw	r10, r28
     342:	e3 82       	std	Z+3, r14	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
     344:	e2 80       	ldd	r14, Z+2	; 0x02
     346:	ee 20       	and	r14, r14
     348:	ec f7       	brge	.-6      	; 0x344 <writeFRAM+0xd2>
		SPIBuffer[12] = SPIC.DATA;
     34a:	e3 80       	ldd	r14, Z+3	; 0x03
     34c:	e9 01       	movw	r28, r18
     34e:	e8 82       	st	Y, r14
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	//write data to FRAM
	for(uint32_t i = 0; i< length; i++){
     350:	01 96       	adiw	r24, 0x01	; 1
     352:	a1 1d       	adc	r26, r1
     354:	b1 1d       	adc	r27, r1
     356:	84 17       	cp	r24, r20
     358:	95 07       	cpc	r25, r21
     35a:	a6 07       	cpc	r26, r22
     35c:	b7 07       	cpc	r27, r23
     35e:	70 f3       	brcs	.-36     	; 0x33c <writeFRAM+0xca>
		SPIC.DATA = buffer[i];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
     360:	88 e0       	ldi	r24, 0x08	; 8
     362:	e0 e2       	ldi	r30, 0x20	; 32
     364:	f6 e0       	ldi	r31, 0x06	; 6
     366:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     368:	80 e0       	ldi	r24, 0x00	; 0
     36a:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	SPIC.CTRL = prev_SPI_settings;
     36e:	f0 92 c0 08 	sts	0x08C0, r15
	//SPIC.CTRL = ADC_SPI_CONFIG_gc;
	//PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
	
	//increment address by the written length
	FRAMAddress +=length;
     372:	80 91 22 3e 	lds	r24, 0x3E22
     376:	90 91 23 3e 	lds	r25, 0x3E23
     37a:	08 0f       	add	r16, r24
     37c:	19 1f       	adc	r17, r25
     37e:	00 93 22 3e 	sts	0x3E22, r16
     382:	10 93 23 3e 	sts	0x3E23, r17
}
     386:	df 91       	pop	r29
     388:	cf 91       	pop	r28
     38a:	1f 91       	pop	r17
     38c:	0f 91       	pop	r16
     38e:	ff 90       	pop	r15
     390:	ef 90       	pop	r14
     392:	df 90       	pop	r13
     394:	bf 90       	pop	r11
     396:	af 90       	pop	r10
     398:	08 95       	ret

0000039a <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes, uint16_t startAddress) {
     39a:	df 92       	push	r13
     39c:	ef 92       	push	r14
     39e:	ff 92       	push	r15
     3a0:	0f 93       	push	r16
     3a2:	1f 93       	push	r17
     3a4:	cf 93       	push	r28
     3a6:	df 93       	push	r29
     3a8:	0f 92       	push	r0
     3aa:	0f 92       	push	r0
     3ac:	cd b7       	in	r28, 0x3d	; 61
     3ae:	de b7       	in	r29, 0x3e	; 62
     3b0:	7c 01       	movw	r14, r24
     3b2:	69 83       	std	Y+1, r22	; 0x01
     3b4:	7a 83       	std	Y+2, r23	; 0x02
	
	//save SPI registers
	uint8_t prev_SPI_settings;
	ADCPower(TRUE);
     3b6:	81 e0       	ldi	r24, 0x01	; 1
     3b8:	0e 94 0c 07 	call	0xe18	; 0xe18 <ADCPower>
	
	prev_SPI_settings = SPIC.CTRL;
     3bc:	00 ec       	ldi	r16, 0xC0	; 192
     3be:	18 e0       	ldi	r17, 0x08	; 8
     3c0:	f8 01       	movw	r30, r16
     3c2:	d0 80       	ld	r13, Z
	SPIInit(SPI_MODE_0_gc);
     3c4:	80 e0       	ldi	r24, 0x00	; 0
     3c6:	0e 94 16 05 	call	0xa2c	; 0xa2c <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
     3ca:	80 ed       	ldi	r24, 0xD0	; 208
     3cc:	f8 01       	movw	r30, r16
     3ce:	80 83       	st	Z, r24
	SPICS(TRUE);
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
     3d6:	88 e0       	ldi	r24, 0x08	; 8
     3d8:	e0 e2       	ldi	r30, 0x20	; 32
     3da:	f6 e0       	ldi	r31, 0x06	; 6
     3dc:	86 83       	std	Z+6, r24	; 0x06
	nop();
     3de:	00 00       	nop
	
	SPIC.DATA = FR_READ;
     3e0:	83 e0       	ldi	r24, 0x03	; 3
     3e2:	f8 01       	movw	r30, r16
     3e4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3e6:	82 81       	ldd	r24, Z+2	; 0x02
     3e8:	88 23       	and	r24, r24
     3ea:	ec f7       	brge	.-6      	; 0x3e6 <readFRAM+0x4c>
	SPIBuffer[12] = SPIC.DATA;
     3ec:	e0 ec       	ldi	r30, 0xC0	; 192
     3ee:	f8 e0       	ldi	r31, 0x08	; 8
     3f0:	83 81       	ldd	r24, Z+3	; 0x03
     3f2:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = *(((uint8_t*)&startAddress) + 1);;
     3f6:	8a 81       	ldd	r24, Y+2	; 0x02
     3f8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     3fa:	82 81       	ldd	r24, Z+2	; 0x02
     3fc:	88 23       	and	r24, r24
     3fe:	ec f7       	brge	.-6      	; 0x3fa <readFRAM+0x60>
	SPIBuffer[12] = SPIC.DATA;
     400:	e0 ec       	ldi	r30, 0xC0	; 192
     402:	f8 e0       	ldi	r31, 0x08	; 8
     404:	83 81       	ldd	r24, Z+3	; 0x03
     406:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
     40a:	89 81       	ldd	r24, Y+1	; 0x01
     40c:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     40e:	82 81       	ldd	r24, Z+2	; 0x02
     410:	88 23       	and	r24, r24
     412:	ec f7       	brge	.-6      	; 0x40e <readFRAM+0x74>
	SPIBuffer[12] = SPIC.DATA;
     414:	e0 ec       	ldi	r30, 0xC0	; 192
     416:	f8 e0       	ldi	r31, 0x08	; 8
     418:	83 81       	ldd	r24, Z+3	; 0x03
     41a:	80 93 31 3e 	sts	0x3E31, r24
	
	for(uint16_t i = 0; i < numBytes; i++) {
     41e:	e1 14       	cp	r14, r1
     420:	f1 04       	cpc	r15, r1
     422:	b9 f0       	breq	.+46     	; 0x452 <readFRAM+0xb8>
     424:	e1 eb       	ldi	r30, 0xB1	; 177
     426:	f1 e2       	ldi	r31, 0x21	; 33
	FRAMAddress +=length;
}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes, uint16_t startAddress) {
     428:	c7 01       	movw	r24, r14
     42a:	8e 0f       	add	r24, r30
     42c:	9f 1f       	adc	r25, r31
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
		SPIC.DATA = 0xAA;
     42e:	a0 ec       	ldi	r26, 0xC0	; 192
     430:	b8 e0       	ldi	r27, 0x08	; 8
     432:	3a ea       	ldi	r19, 0xAA	; 170
     434:	13 96       	adiw	r26, 0x03	; 3
     436:	3c 93       	st	X, r19
     438:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     43a:	12 96       	adiw	r26, 0x02	; 2
     43c:	2c 91       	ld	r18, X
     43e:	12 97       	sbiw	r26, 0x02	; 2
     440:	22 23       	and	r18, r18
     442:	dc f7       	brge	.-10     	; 0x43a <readFRAM+0xa0>
		FRAMReadBuffer[i] = SPIC.DATA;
     444:	13 96       	adiw	r26, 0x03	; 3
     446:	2c 91       	ld	r18, X
     448:	13 97       	sbiw	r26, 0x03	; 3
     44a:	21 93       	st	Z+, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&startAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) {
     44c:	e8 17       	cp	r30, r24
     44e:	f9 07       	cpc	r31, r25
     450:	89 f7       	brne	.-30     	; 0x434 <readFRAM+0x9a>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
     452:	88 e0       	ldi	r24, 0x08	; 8
     454:	e0 e2       	ldi	r30, 0x20	; 32
     456:	f6 e0       	ldi	r31, 0x06	; 6
     458:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
     45a:	80 e0       	ldi	r24, 0x00	; 0
     45c:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	SPIC.CTRL = prev_SPI_settings;
     460:	d0 92 c0 08 	sts	0x08C0, r13

}
     464:	0f 90       	pop	r0
     466:	0f 90       	pop	r0
     468:	df 91       	pop	r29
     46a:	cf 91       	pop	r28
     46c:	1f 91       	pop	r17
     46e:	0f 91       	pop	r16
     470:	ff 90       	pop	r15
     472:	ef 90       	pop	r14
     474:	df 90       	pop	r13
     476:	08 95       	ret

00000478 <StartSerial>:
 * Created: 9/20/2013 9:50:45 AM
 *  Author: Vlad
 */ 
#include "SerialUSB.h"

bool StartSerial(uint32_t BaudRate){
     478:	cf 92       	push	r12
     47a:	df 92       	push	r13
     47c:	ef 92       	push	r14
     47e:	ff 92       	push	r15
     480:	0f 93       	push	r16
     482:	1f 93       	push	r17
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
     488:	6b 01       	movw	r12, r22
     48a:	7c 01       	movw	r14, r24
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
     48c:	dc 01       	movw	r26, r24
     48e:	cb 01       	movw	r24, r22
     490:	88 55       	subi	r24, 0x58	; 88
     492:	92 40       	sbci	r25, 0x02	; 2
     494:	a0 40       	sbci	r26, 0x00	; 0
     496:	b0 40       	sbci	r27, 0x00	; 0
     498:	89 3e       	cpi	r24, 0xE9	; 233
     49a:	2f e3       	ldi	r18, 0x3F	; 63
     49c:	92 07       	cpc	r25, r18
     49e:	2f e0       	ldi	r18, 0x0F	; 15
     4a0:	a2 07       	cpc	r26, r18
     4a2:	20 e0       	ldi	r18, 0x00	; 0
     4a4:	b2 07       	cpc	r27, r18
     4a6:	08 f0       	brcs	.+2      	; 0x4aa <StartSerial+0x32>
     4a8:	5c c0       	rjmp	.+184    	; 0x562 <StartSerial+0xea>
		//baud rate too fast or too slow
		return false;
	}
	//set F_CPU/F_PER to 32 MHz (default is the 2 MHz RC oscillator)
	set_32MHz();
     4aa:	0e 94 8e 04 	call	0x91c	; 0x91c <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     4ae:	e0 e4       	ldi	r30, 0x40	; 64
     4b0:	f6 e0       	ldi	r31, 0x06	; 6
     4b2:	88 e0       	ldi	r24, 0x08	; 8
     4b4:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = PIN3_bm;
     4b6:	85 83       	std	Z+5, r24	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     4b8:	84 e0       	ldi	r24, 0x04	; 4
     4ba:	82 83       	std	Z+2, r24	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	prescaler = (uint32_t)((((float)F_CPU)/((float)(16*BaudRate)))-1);
     4bc:	cc 0c       	add	r12, r12
     4be:	dd 1c       	adc	r13, r13
     4c0:	ee 1c       	adc	r14, r14
     4c2:	ff 1c       	adc	r15, r15
     4c4:	cc 0c       	add	r12, r12
     4c6:	dd 1c       	adc	r13, r13
     4c8:	ee 1c       	adc	r14, r14
     4ca:	ff 1c       	adc	r15, r15
     4cc:	c7 01       	movw	r24, r14
     4ce:	b6 01       	movw	r22, r12
     4d0:	66 0f       	add	r22, r22
     4d2:	77 1f       	adc	r23, r23
     4d4:	88 1f       	adc	r24, r24
     4d6:	99 1f       	adc	r25, r25
     4d8:	66 0f       	add	r22, r22
     4da:	77 1f       	adc	r23, r23
     4dc:	88 1f       	adc	r24, r24
     4de:	99 1f       	adc	r25, r25
     4e0:	0e 94 6e 37 	call	0x6edc	; 0x6edc <__floatunsisf>
     4e4:	9b 01       	movw	r18, r22
     4e6:	ac 01       	movw	r20, r24
     4e8:	60 e0       	ldi	r22, 0x00	; 0
     4ea:	74 e2       	ldi	r23, 0x24	; 36
     4ec:	84 ef       	ldi	r24, 0xF4	; 244
     4ee:	9b e4       	ldi	r25, 0x4B	; 75
     4f0:	0e 94 da 36 	call	0x6db4	; 0x6db4 <__divsf3>
     4f4:	20 e0       	ldi	r18, 0x00	; 0
     4f6:	30 e0       	ldi	r19, 0x00	; 0
     4f8:	40 e8       	ldi	r20, 0x80	; 128
     4fa:	5f e3       	ldi	r21, 0x3F	; 63
     4fc:	0e 94 75 36 	call	0x6cea	; 0x6cea <__subsf3>
     500:	c6 2f       	mov	r28, r22
     502:	d7 2f       	mov	r29, r23
     504:	18 2f       	mov	r17, r24
     506:	09 2f       	mov	r16, r25
     508:	86 2f       	mov	r24, r22
     50a:	9d 2f       	mov	r25, r29
     50c:	a1 2f       	mov	r26, r17
     50e:	b0 2f       	mov	r27, r16
     510:	bc 01       	movw	r22, r24
     512:	cd 01       	movw	r24, r26
     514:	0e 94 42 37 	call	0x6e84	; 0x6e84 <__fixunssfsi>
     518:	6b 01       	movw	r12, r22
     51a:	7c 01       	movw	r14, r24
	//increment prescaler if truncated part was >= 0.5
	if((((float)F_CPU/((float)(16*BaudRate)))-1)-prescaler >= 0.5) prescaler++;
     51c:	80 e0       	ldi	r24, 0x00	; 0
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	0e 94 6e 37 	call	0x6edc	; 0x6edc <__floatunsisf>
     524:	9b 01       	movw	r18, r22
     526:	ac 01       	movw	r20, r24
     528:	8c 2f       	mov	r24, r28
     52a:	9d 2f       	mov	r25, r29
     52c:	a1 2f       	mov	r26, r17
     52e:	b0 2f       	mov	r27, r16
     530:	bc 01       	movw	r22, r24
     532:	cd 01       	movw	r24, r26
     534:	0e 94 75 36 	call	0x6cea	; 0x6cea <__subsf3>
     538:	20 e0       	ldi	r18, 0x00	; 0
     53a:	30 e0       	ldi	r19, 0x00	; 0
     53c:	40 e0       	ldi	r20, 0x00	; 0
     53e:	5f e3       	ldi	r21, 0x3F	; 63
     540:	0e 94 fc 37 	call	0x6ff8	; 0x6ff8 <__gesf2>
     544:	88 23       	and	r24, r24
     546:	1c f0       	brlt	.+6      	; 0x54e <StartSerial+0xd6>
     548:	08 94       	sec
     54a:	c1 1c       	adc	r12, r1
     54c:	d1 1c       	adc	r13, r1
	
	USARTC0.BAUDCTRLA = prescaler & 0xFF;
     54e:	e0 ea       	ldi	r30, 0xA0	; 160
     550:	f8 e0       	ldi	r31, 0x08	; 8
     552:	c6 82       	std	Z+6, r12	; 0x06
	USARTC0.BAUDCTRLB = prescaler >>8;
     554:	d7 82       	std	Z+7, r13	; 0x07
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     556:	83 e0       	ldi	r24, 0x03	; 3
     558:	85 83       	std	Z+5, r24	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     55a:	88 e1       	ldi	r24, 0x18	; 24
     55c:	84 83       	std	Z+4, r24	; 0x04
	return true;
     55e:	81 e0       	ldi	r24, 0x01	; 1
     560:	01 c0       	rjmp	.+2      	; 0x564 <StartSerial+0xec>

bool StartSerial(uint32_t BaudRate){
	uint16_t prescaler;
	if(BaudRate <600 || BaudRate >1000000){
		//baud rate too fast or too slow
		return false;
     562:	80 e0       	ldi	r24, 0x00	; 0
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
	return true;
}
     564:	df 91       	pop	r29
     566:	cf 91       	pop	r28
     568:	1f 91       	pop	r17
     56a:	0f 91       	pop	r16
     56c:	ff 90       	pop	r15
     56e:	ef 90       	pop	r14
     570:	df 90       	pop	r13
     572:	cf 90       	pop	r12
     574:	08 95       	ret

00000576 <SerialWriteByte>:

void SerialWriteByte(uint8_t byte){
	//wait for transmit buffer to become available
	while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     576:	e0 ea       	ldi	r30, 0xA0	; 160
     578:	f8 e0       	ldi	r31, 0x08	; 8
     57a:	91 81       	ldd	r25, Z+1	; 0x01
     57c:	95 ff       	sbrs	r25, 5
     57e:	fd cf       	rjmp	.-6      	; 0x57a <SerialWriteByte+0x4>
		//wait
	}
	//send byte
	USARTC0.DATA = byte;
     580:	80 93 a0 08 	sts	0x08A0, r24
	//wait for transmit to finish
	//while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
		//wait
	//}
}
     584:	08 95       	ret

00000586 <SerialReadByte>:

uint8_t SerialReadByte(){
	uint8_t byte;
	//wait for reception of message
	while ((USARTC0.STATUS & BIT7_bm) != BIT7_bm){
     586:	e0 ea       	ldi	r30, 0xA0	; 160
     588:	f8 e0       	ldi	r31, 0x08	; 8
     58a:	81 81       	ldd	r24, Z+1	; 0x01
     58c:	88 23       	and	r24, r24
     58e:	ec f7       	brge	.-6      	; 0x58a <SerialReadByte+0x4>
		//add timeout logic
	}	
	//read in byte
	byte = USARTC0.DATA;
     590:	80 91 a0 08 	lds	r24, 0x08A0
	return byte;	
}
     594:	08 95       	ret

00000596 <SerialWriteBuffer>:

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
     596:	8f 92       	push	r8
     598:	9f 92       	push	r9
     59a:	af 92       	push	r10
     59c:	bf 92       	push	r11
     59e:	cf 92       	push	r12
     5a0:	df 92       	push	r13
     5a2:	ef 92       	push	r14
     5a4:	ff 92       	push	r15
     5a6:	cf 93       	push	r28
     5a8:	df 93       	push	r29
     5aa:	6a 01       	movw	r12, r20
     5ac:	7b 01       	movw	r14, r22
	uint32_t i;
	for(i=0;i<length;i++){
     5ae:	41 15       	cp	r20, r1
     5b0:	51 05       	cpc	r21, r1
     5b2:	61 05       	cpc	r22, r1
     5b4:	71 05       	cpc	r23, r1
     5b6:	91 f0       	breq	.+36     	; 0x5dc <SerialWriteBuffer+0x46>
     5b8:	c8 2f       	mov	r28, r24
     5ba:	d9 2f       	mov	r29, r25
     5bc:	88 24       	eor	r8, r8
     5be:	99 24       	eor	r9, r9
     5c0:	54 01       	movw	r10, r8
		SerialWriteByte(buffer[i]);
     5c2:	89 91       	ld	r24, Y+
     5c4:	0e 94 bb 02 	call	0x576	; 0x576 <SerialWriteByte>
	return byte;	
}

void SerialWriteBuffer(uint8_t* buffer, uint32_t length){
	uint32_t i;
	for(i=0;i<length;i++){
     5c8:	08 94       	sec
     5ca:	81 1c       	adc	r8, r1
     5cc:	91 1c       	adc	r9, r1
     5ce:	a1 1c       	adc	r10, r1
     5d0:	b1 1c       	adc	r11, r1
     5d2:	8c 14       	cp	r8, r12
     5d4:	9d 04       	cpc	r9, r13
     5d6:	ae 04       	cpc	r10, r14
     5d8:	bf 04       	cpc	r11, r15
     5da:	99 f7       	brne	.-26     	; 0x5c2 <SerialWriteBuffer+0x2c>
		SerialWriteByte(buffer[i]);
	}
}
     5dc:	df 91       	pop	r29
     5de:	cf 91       	pop	r28
     5e0:	ff 90       	pop	r15
     5e2:	ef 90       	pop	r14
     5e4:	df 90       	pop	r13
     5e6:	cf 90       	pop	r12
     5e8:	bf 90       	pop	r11
     5ea:	af 90       	pop	r10
     5ec:	9f 90       	pop	r9
     5ee:	8f 90       	pop	r8
     5f0:	08 95       	ret

000005f2 <StopSerial>:

void StopSerial(){
	//turn off Rx and Tx for USART
	USARTC0.CTRLB &= ~(BIT4_bm | BIT3_bm);
     5f2:	e0 ea       	ldi	r30, 0xA0	; 160
     5f4:	f8 e0       	ldi	r31, 0x08	; 8
     5f6:	84 81       	ldd	r24, Z+4	; 0x04
     5f8:	87 7e       	andi	r24, 0xE7	; 231
     5fa:	84 83       	std	Z+4, r24	; 0x04
	//clear output pin
	PORTC.OUTCLR = PIN3_bm;
     5fc:	e0 e4       	ldi	r30, 0x40	; 64
     5fe:	f6 e0       	ldi	r31, 0x06	; 6
     600:	88 e0       	ldi	r24, 0x08	; 8
     602:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN3_bm;
     604:	82 83       	std	Z+2, r24	; 0x02
     606:	08 95       	ret

00000608 <main>:
 */ 
# include "E-000001-000009_firmware_rev_1_0.h"

volatile uint8_t TimedOut = 0;

int main(){
     608:	cf 93       	push	r28
     60a:	df 93       	push	r29
     60c:	cd b7       	in	r28, 0x3d	; 61
     60e:	de b7       	in	r29, 0x3e	; 62
     610:	c8 56       	subi	r28, 0x68	; 104
     612:	d0 40       	sbci	r29, 0x00	; 0
     614:	cd bf       	out	0x3d, r28	; 61
     616:	de bf       	out	0x3e, r29	; 62

	uint32_t length;
	uint16_t dest_addr;
	uint16_t ack = 0;
     618:	19 82       	std	Y+1, r1	; 0x01
     61a:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t  MessageBuffer[100];
	uint16_t NumReceivedMessages, NumMessages, TimeoutCount;
	//set timeout about 2 sec
	uint16_t timeout = 4000;
	
	set_32MHz_Calibrated();
     61c:	0e 94 68 04 	call	0x8d0	; 0x8d0 <set_32MHz_Calibrated>
	
	//chb_set_pwr(0xe1);
	chb_init();
     620:	0e 94 f6 18 	call	0x31ec	; 0x31ec <chb_init>
	chb_set_short_addr(0x0000);
     624:	80 e0       	ldi	r24, 0x00	; 0
     626:	90 e0       	ldi	r25, 0x00	; 0
     628:	0e 94 2f 1b 	call	0x365e	; 0x365e <chb_set_short_addr>
	chb_set_channel(1);
     62c:	81 e0       	ldi	r24, 0x01	; 1
     62e:	0e 94 79 1c 	call	0x38f2	; 0x38f2 <chb_set_channel>
	//chb_set_pwr(0);
	StartSerial((uint32_t)57600);
     632:	60 e0       	ldi	r22, 0x00	; 0
     634:	71 ee       	ldi	r23, 0xE1	; 225
     636:	80 e0       	ldi	r24, 0x00	; 0
     638:	90 e0       	ldi	r25, 0x00	; 0
     63a:	0e 94 3c 02 	call	0x478	; 0x478 <StartSerial>

	while(!chb_set_state(CHB_RX_AACK_ON) == RADIO_SUCCESS);
     63e:	86 e1       	ldi	r24, 0x16	; 22
     640:	0e 94 89 1b 	call	0x3712	; 0x3712 <chb_set_state>
	pcb_t* pcb = chb_get_pcb();
     644:	0e 94 17 19 	call	0x322e	; 0x322e <chb_get_pcb>
     648:	a9 96       	adiw	r28, 0x29	; 41
     64a:	8e af       	sts	0x7e, r24
     64c:	9f af       	sts	0x7f, r25
     64e:	a9 97       	sbiw	r28, 0x29	; 41
	
	
	//set the period to 2 seconds
	TCE0.PER = timeout;
     650:	e0 e0       	ldi	r30, 0x00	; 0
     652:	fa e0       	ldi	r31, 0x0A	; 10
     654:	80 ea       	ldi	r24, 0xA0	; 160
     656:	9f e0       	ldi	r25, 0x0F	; 15
     658:	86 a3       	lds	r24, 0x56
     65a:	97 a3       	lds	r25, 0x57
	TCE0.CTRLFSET = 0x08;
     65c:	88 e0       	ldi	r24, 0x08	; 8
     65e:	81 87       	std	Z+9, r24	; 0x09
	//set overflow interrupt
	TCE0.INTCTRLA = TC_OVFINTLVL_LO_gc;
     660:	81 e0       	ldi	r24, 0x01	; 1
     662:	86 83       	std	Z+6, r24	; 0x06
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
     664:	e0 ea       	ldi	r30, 0xA0	; 160
     666:	f0 e0       	ldi	r31, 0x00	; 0
     668:	82 81       	ldd	r24, Z+2	; 0x02
     66a:	81 60       	ori	r24, 0x01	; 1
     66c:	82 83       	std	Z+2, r24	; 0x02
	sei();
     66e:	78 94       	sei
	
	while(1){
		length = 0;
		//wait for inputs over serial
		while(!(USARTC0.STATUS & BIT7_bm));
     670:	0f 2e       	mov	r0, r31
     672:	f0 ea       	ldi	r31, 0xA0	; 160
     674:	6f 2e       	mov	r6, r31
     676:	f8 e0       	ldi	r31, 0x08	; 8
     678:	7f 2e       	mov	r7, r31
     67a:	f0 2d       	mov	r31, r0
		if(length > 2){
			//clear out message buffer in case any stray message was received
			if(pcb->data_rcv){ 
				chb_read((chb_rx_data_t*)FRAMReadBuffer);
			}
			TCE0.CTRLA = 0x07;
     67c:	0f 2e       	mov	r0, r31
     67e:	44 24       	eor	r4, r4
     680:	fa e0       	ldi	r31, 0x0A	; 10
     682:	5f 2e       	mov	r5, r31
     684:	f0 2d       	mov	r31, r0
					TCE0.CTRLFSET = 0x08;
 					continue;
 				}			
				//if(TCF0.CNT - TimeoutCount >= timeout) continue;
				//read the data. expecting a 1 byte message containing number of messages that follow
				length = chb_read((chb_rx_data_t*)FRAMReadBuffer);
     686:	0f 2e       	mov	r0, r31
     688:	f1 eb       	ldi	r31, 0xB1	; 177
     68a:	2f 2e       	mov	r2, r31
     68c:	f1 e2       	ldi	r31, 0x21	; 33
     68e:	3f 2e       	mov	r3, r31
     690:	f0 2d       	mov	r31, r0
	sei();
	
	while(1){
		length = 0;
		//wait for inputs over serial
		while(!(USARTC0.STATUS & BIT7_bm));
     692:	d3 01       	movw	r26, r6
     694:	11 96       	adiw	r26, 0x01	; 1
     696:	8c 91       	ld	r24, X
     698:	11 97       	sbiw	r26, 0x01	; 1
     69a:	88 23       	and	r24, r24
     69c:	d4 f7       	brge	.-12     	; 0x692 <main+0x8a>
		length = SerialReadByte();
     69e:	0e 94 c3 02 	call	0x586	; 0x586 <SerialReadByte>
     6a2:	88 2e       	mov	r8, r24
     6a4:	99 24       	eor	r9, r9
     6a6:	aa 24       	eor	r10, r10
     6a8:	bb 24       	eor	r11, r11
		for(uint32_t i = 0; i<length; i++){
     6aa:	81 14       	cp	r8, r1
     6ac:	91 04       	cpc	r9, r1
     6ae:	a1 04       	cpc	r10, r1
     6b0:	b1 04       	cpc	r11, r1
     6b2:	79 f3       	breq	.-34     	; 0x692 <main+0x8a>
     6b4:	8e 01       	movw	r16, r28
     6b6:	0d 5f       	subi	r16, 0xFD	; 253
     6b8:	1f 4f       	sbci	r17, 0xFF	; 255
     6ba:	cc 24       	eor	r12, r12
     6bc:	dd 24       	eor	r13, r13
     6be:	76 01       	movw	r14, r12
			MessageBuffer[i] = SerialReadByte();
     6c0:	0e 94 c3 02 	call	0x586	; 0x586 <SerialReadByte>
     6c4:	f8 01       	movw	r30, r16
     6c6:	81 93       	st	Z+, r24
     6c8:	8f 01       	movw	r16, r30
	while(1){
		length = 0;
		//wait for inputs over serial
		while(!(USARTC0.STATUS & BIT7_bm));
		length = SerialReadByte();
		for(uint32_t i = 0; i<length; i++){
     6ca:	08 94       	sec
     6cc:	c1 1c       	adc	r12, r1
     6ce:	d1 1c       	adc	r13, r1
     6d0:	e1 1c       	adc	r14, r1
     6d2:	f1 1c       	adc	r15, r1
     6d4:	8c 14       	cp	r8, r12
     6d6:	9d 04       	cpc	r9, r13
     6d8:	ae 04       	cpc	r10, r14
     6da:	bf 04       	cpc	r11, r15
     6dc:	89 f7       	brne	.-30     	; 0x6c0 <main+0xb8>
			MessageBuffer[i] = SerialReadByte();
		}
		dest_addr = ((uint16_t*)MessageBuffer)[0];
     6de:	0b 81       	ldd	r16, Y+3	; 0x03
     6e0:	1c 81       	ldd	r17, Y+4	; 0x04
			
		
		if(length > 2){
     6e2:	f3 e0       	ldi	r31, 0x03	; 3
     6e4:	8f 16       	cp	r8, r31
     6e6:	91 04       	cpc	r9, r1
     6e8:	a1 04       	cpc	r10, r1
     6ea:	b1 04       	cpc	r11, r1
     6ec:	90 f2       	brcs	.-92     	; 0x692 <main+0x8a>
			//clear out message buffer in case any stray message was received
			if(pcb->data_rcv){ 
     6ee:	a9 96       	adiw	r28, 0x29	; 41
     6f0:	ae ad       	sts	0x6e, r26
     6f2:	bf ad       	sts	0x6f, r27
     6f4:	a9 97       	sbiw	r28, 0x29	; 41
     6f6:	17 96       	adiw	r26, 0x07	; 7
     6f8:	8c 91       	ld	r24, X
     6fa:	17 97       	sbiw	r26, 0x07	; 7
     6fc:	88 23       	and	r24, r24
     6fe:	19 f0       	breq	.+6      	; 0x706 <main+0xfe>
				chb_read((chb_rx_data_t*)FRAMReadBuffer);
     700:	c1 01       	movw	r24, r2
     702:	0e 94 c8 19 	call	0x3390	; 0x3390 <chb_read>
			}
			TCE0.CTRLA = 0x07;
     706:	87 e0       	ldi	r24, 0x07	; 7
     708:	f2 01       	movw	r30, r4
     70a:	80 83       	st	Z, r24
			TimedOut = 0;				
     70c:	10 92 0e 21 	sts	0x210E, r1
			//process/send the bytes over radio
			while(chb_write(dest_addr,MessageBuffer+2,length-2) != CHB_SUCCESS){
     710:	8e ef       	ldi	r24, 0xFE	; 254
     712:	9f ef       	ldi	r25, 0xFF	; 255
     714:	af ef       	ldi	r26, 0xFF	; 255
     716:	bf ef       	ldi	r27, 0xFF	; 255
     718:	88 0e       	add	r8, r24
     71a:	99 1e       	adc	r9, r25
     71c:	aa 1e       	adc	r10, r26
     71e:	bb 1e       	adc	r11, r27
     720:	04 c0       	rjmp	.+8      	; 0x72a <main+0x122>
				if(TimedOut) break;
     722:	80 91 0e 21 	lds	r24, 0x210E
     726:	88 23       	and	r24, r24
     728:	51 f4       	brne	.+20     	; 0x73e <main+0x136>
				chb_read((chb_rx_data_t*)FRAMReadBuffer);
			}
			TCE0.CTRLA = 0x07;
			TimedOut = 0;				
			//process/send the bytes over radio
			while(chb_write(dest_addr,MessageBuffer+2,length-2) != CHB_SUCCESS){
     72a:	c8 01       	movw	r24, r16
     72c:	be 01       	movw	r22, r28
     72e:	6b 5f       	subi	r22, 0xFB	; 251
     730:	7f 4f       	sbci	r23, 0xFF	; 255
     732:	a5 01       	movw	r20, r10
     734:	94 01       	movw	r18, r8
     736:	0e 94 1a 19 	call	0x3234	; 0x3234 <chb_write>
     73a:	88 23       	and	r24, r24
     73c:	91 f7       	brne	.-28     	; 0x722 <main+0x11a>
				if(TimedOut) break;
			}
			if(TimedOut) {
     73e:	80 91 0e 21 	lds	r24, 0x210E
     742:	88 23       	and	r24, r24
     744:	39 f0       	breq	.+14     	; 0x754 <main+0x14c>
				TCE0.CTRLA = 0x00;
     746:	d2 01       	movw	r26, r4
     748:	1c 92       	st	X, r1
				TCE0.CTRLFSET = 0x08;
     74a:	e8 e0       	ldi	r30, 0x08	; 8
     74c:	19 96       	adiw	r26, 0x09	; 9
     74e:	ec 93       	st	X, r30
     750:	19 97       	sbiw	r26, 0x09	; 9
				continue;
     752:	9f cf       	rjmp	.-194    	; 0x692 <main+0x8a>
			}				
		
			TCE0.CTRLFSET = 0x08;
     754:	e8 e0       	ldi	r30, 0x08	; 8
     756:	d2 01       	movw	r26, r4
     758:	19 96       	adiw	r26, 0x09	; 9
     75a:	ec 93       	st	X, r30
     75c:	19 97       	sbiw	r26, 0x09	; 9
			TimedOut = 0;
     75e:	10 92 0e 21 	sts	0x210E, r1
			//set prescalar of 1024... each timer tick is 512 micro seconds
			//TCE0.CTRLA = 0x07;
			//wait for response/data over radio if the message was sent to only 1 mote and not broadcast
			if(dest_addr != 0xFFFF){
     762:	ff ef       	ldi	r31, 0xFF	; 255
     764:	0f 3f       	cpi	r16, 0xFF	; 255
     766:	1f 07       	cpc	r17, r31
     768:	29 f4       	brne	.+10     	; 0x774 <main+0x16c>
     76a:	64 c0       	rjmp	.+200    	; 0x834 <main+0x22c>
				while(!pcb->data_rcv){
					//no response detected so go back to waiting for next serial command
					if(TimedOut) break;
     76c:	80 91 0e 21 	lds	r24, 0x210E
     770:	88 23       	and	r24, r24
     772:	49 f4       	brne	.+18     	; 0x786 <main+0x17e>
			TimedOut = 0;
			//set prescalar of 1024... each timer tick is 512 micro seconds
			//TCE0.CTRLA = 0x07;
			//wait for response/data over radio if the message was sent to only 1 mote and not broadcast
			if(dest_addr != 0xFFFF){
				while(!pcb->data_rcv){
     774:	a9 96       	adiw	r28, 0x29	; 41
     776:	ae ad       	sts	0x6e, r26
     778:	bf ad       	sts	0x6f, r27
     77a:	a9 97       	sbiw	r28, 0x29	; 41
     77c:	17 96       	adiw	r26, 0x07	; 7
     77e:	8c 91       	ld	r24, X
     780:	17 97       	sbiw	r26, 0x07	; 7
     782:	88 23       	and	r24, r24
     784:	99 f3       	breq	.-26     	; 0x76c <main+0x164>
					//no response detected so go back to waiting for next serial command
					if(TimedOut) break;
					//if(TCF0.CNT - TimeoutCount >= timeout) break;
				}
 				if(TimedOut) {
     786:	80 91 0e 21 	lds	r24, 0x210E
     78a:	88 23       	and	r24, r24
     78c:	29 f0       	breq	.+10     	; 0x798 <main+0x190>
					TCE0.CTRLA = 0x00;
     78e:	f2 01       	movw	r30, r4
     790:	10 82       	st	Z, r1
					TCE0.CTRLFSET = 0x08;
     792:	88 e0       	ldi	r24, 0x08	; 8
     794:	81 87       	std	Z+9, r24	; 0x09
 					continue;
     796:	7d cf       	rjmp	.-262    	; 0x692 <main+0x8a>
 				}			
				//if(TCF0.CNT - TimeoutCount >= timeout) continue;
				//read the data. expecting a 1 byte message containing number of messages that follow
				length = chb_read((chb_rx_data_t*)FRAMReadBuffer);
     798:	c1 01       	movw	r24, r2
     79a:	0e 94 c8 19 	call	0x3390	; 0x3390 <chb_read>
				if (length == 2){
     79e:	82 30       	cpi	r24, 0x02	; 2
     7a0:	09 f0       	breq	.+2      	; 0x7a4 <main+0x19c>
     7a2:	48 c0       	rjmp	.+144    	; 0x834 <main+0x22c>
					length = 0;
					NumReceivedMessages = 0;
					//get the number of messages (2 bytes)
					NumMessages = ((uint16_t*)FRAMReadBuffer)[0];
     7a4:	d1 01       	movw	r26, r2
     7a6:	8d 90       	ld	r8, X+
     7a8:	9c 90       	ld	r9, X
     7aa:	11 97       	sbiw	r26, 0x01	; 1
					//start timeout clock
					//TimeoutCount = TCF0.CNT;
					//reset timer count
					//TCE0.CTRLA = 0x00;
					TCE0.CTRLFSET = 0x08;
     7ac:	88 e0       	ldi	r24, 0x08	; 8
     7ae:	f2 01       	movw	r30, r4
     7b0:	81 87       	std	Z+9, r24	; 0x09
					//clear timeout flag
					TimedOut = 0;
     7b2:	10 92 0e 21 	sts	0x210E, r1
					//TCE0.CTRLA = 0x07;
					while(NumReceivedMessages <NumMessages){
     7b6:	81 14       	cp	r8, r1
     7b8:	91 04       	cpc	r9, r1
     7ba:	e1 f1       	breq	.+120    	; 0x834 <main+0x22c>
				//if(TCF0.CNT - TimeoutCount >= timeout) continue;
				//read the data. expecting a 1 byte message containing number of messages that follow
				length = chb_read((chb_rx_data_t*)FRAMReadBuffer);
				if (length == 2){
					length = 0;
					NumReceivedMessages = 0;
     7bc:	cc 24       	eor	r12, r12
     7be:	dd 24       	eor	r13, r13
					//clear timeout flag
					TimedOut = 0;
					//TCE0.CTRLA = 0x07;
					while(NumReceivedMessages <NumMessages){
						//wait for all messages to come in
						if(pcb->data_rcv){
     7c0:	a9 96       	adiw	r28, 0x29	; 41
     7c2:	ae ad       	sts	0x6e, r26
     7c4:	bf ad       	sts	0x6f, r27
     7c6:	a9 97       	sbiw	r28, 0x29	; 41
     7c8:	17 96       	adiw	r26, 0x07	; 7
     7ca:	8c 91       	ld	r24, X
     7cc:	17 97       	sbiw	r26, 0x07	; 7
     7ce:	88 23       	and	r24, r24
     7d0:	51 f1       	breq	.+84     	; 0x826 <main+0x21e>
							length = chb_read((chb_rx_data_t*)(FRAMReadBuffer));
     7d2:	c1 01       	movw	r24, r2
     7d4:	0e 94 c8 19 	call	0x3390	; 0x3390 <chb_read>
     7d8:	48 2f       	mov	r20, r24
     7da:	50 e0       	ldi	r21, 0x00	; 0
     7dc:	60 e0       	ldi	r22, 0x00	; 0
     7de:	70 e0       	ldi	r23, 0x00	; 0
							//pass the data to USB
							SerialWriteBuffer(FRAMReadBuffer,length);
     7e0:	c1 01       	movw	r24, r2
     7e2:	0e 94 cb 02 	call	0x596	; 0x596 <SerialWriteBuffer>
							NumReceivedMessages++;
     7e6:	08 94       	sec
     7e8:	c1 1c       	adc	r12, r1
     7ea:	d1 1c       	adc	r13, r1
							//reset timeout count
							//TimeoutCount = TCF0.CNT;
							//reset timer count
							//TCE0.CTRLA = 0x00;
							//send acknowledgment
							TCE0.CTRLFSET = 0x08;
     7ec:	88 e0       	ldi	r24, 0x08	; 8
     7ee:	f2 01       	movw	r30, r4
     7f0:	81 87       	std	Z+9, r24	; 0x09
							//clear timeout flag
							TimedOut = 0;
     7f2:	10 92 0e 21 	sts	0x210E, r1
							while(chb_write(dest_addr,&ack,2) != CHB_SUCCESS){
     7f6:	04 c0       	rjmp	.+8      	; 0x800 <main+0x1f8>
								if(TimedOut) break;	
     7f8:	80 91 0e 21 	lds	r24, 0x210E
     7fc:	88 23       	and	r24, r24
     7fe:	61 f4       	brne	.+24     	; 0x818 <main+0x210>
							//TCE0.CTRLA = 0x00;
							//send acknowledgment
							TCE0.CTRLFSET = 0x08;
							//clear timeout flag
							TimedOut = 0;
							while(chb_write(dest_addr,&ack,2) != CHB_SUCCESS){
     800:	c8 01       	movw	r24, r16
     802:	be 01       	movw	r22, r28
     804:	6f 5f       	subi	r22, 0xFF	; 255
     806:	7f 4f       	sbci	r23, 0xFF	; 255
     808:	22 e0       	ldi	r18, 0x02	; 2
     80a:	30 e0       	ldi	r19, 0x00	; 0
     80c:	40 e0       	ldi	r20, 0x00	; 0
     80e:	50 e0       	ldi	r21, 0x00	; 0
     810:	0e 94 1a 19 	call	0x3234	; 0x3234 <chb_write>
     814:	88 23       	and	r24, r24
     816:	81 f7       	brne	.-32     	; 0x7f8 <main+0x1f0>
								if(TimedOut) break;	
							}
							TCE0.CTRLFSET = 0x08;
     818:	e8 e0       	ldi	r30, 0x08	; 8
     81a:	d2 01       	movw	r26, r4
     81c:	19 96       	adiw	r26, 0x09	; 9
     81e:	ec 93       	st	X, r30
     820:	19 97       	sbiw	r26, 0x09	; 9
							//clear timeout flag
							TimedOut = 0;
     822:	10 92 0e 21 	sts	0x210E, r1
							//TCE0.CTRLA = 0x07;
						}
						//if(TCF0.CNT - TimeoutCount >= timeout) break;
						if(TimedOut) break;		
     826:	80 91 0e 21 	lds	r24, 0x210E
     82a:	88 23       	and	r24, r24
     82c:	19 f4       	brne	.+6      	; 0x834 <main+0x22c>
					//TCE0.CTRLA = 0x00;
					TCE0.CTRLFSET = 0x08;
					//clear timeout flag
					TimedOut = 0;
					//TCE0.CTRLA = 0x07;
					while(NumReceivedMessages <NumMessages){
     82e:	c8 14       	cp	r12, r8
     830:	d9 04       	cpc	r13, r9
     832:	30 f2       	brcs	.-116    	; 0x7c0 <main+0x1b8>
					}
					//SerialWriteBuffer(FRAMReadBuffer,length);
					//check if timed out
				}	
			}			
			TCE0.CTRLA = 0x00;
     834:	d2 01       	movw	r26, r4
     836:	1c 92       	st	X, r1
			TCE0.CTRLFSET = 0x08;
     838:	e8 e0       	ldi	r30, 0x08	; 8
     83a:	19 96       	adiw	r26, 0x09	; 9
     83c:	ec 93       	st	X, r30
     83e:	19 97       	sbiw	r26, 0x09	; 9
     840:	28 cf       	rjmp	.-432    	; 0x692 <main+0x8a>

00000842 <__vector_47>:
		}
	}	
}

ISR(TCE0_OVF_vect){
     842:	1f 92       	push	r1
     844:	0f 92       	push	r0
     846:	0f b6       	in	r0, 0x3f	; 63
     848:	0f 92       	push	r0
     84a:	11 24       	eor	r1, r1
     84c:	8f 93       	push	r24
	//reset timer count
	//TCE0.CTRLA = 0x00;
	//TCE0.CTRLFSET = 0x0C;
	//set timeout flag
	TimedOut = 1;
     84e:	81 e0       	ldi	r24, 0x01	; 1
     850:	80 93 0e 21 	sts	0x210E, r24
     854:	8f 91       	pop	r24
     856:	0f 90       	pop	r0
     858:	0f be       	out	0x3f, r0	; 63
     85a:	0f 90       	pop	r0
     85c:	1f 90       	pop	r1
     85e:	18 95       	reti

00000860 <init>:
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void init(){
	ADC_POWER_ON = 0;
     860:	10 92 37 3e 	sts	0x3E37, r1
}
     864:	08 95       	ret

00000866 <setXOSC_32MHz>:

void setXOSC_32MHz() {
	// configure the crystal to match the chip
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
     866:	80 ec       	ldi	r24, 0xC0	; 192
     868:	60 e0       	ldi	r22, 0x00	; 0
     86a:	4b e0       	ldi	r20, 0x0B	; 11
     86c:	0e 94 12 1f 	call	0x3e24	; 0x3e24 <CLKSYS_XOSC_Config>
	false,
	OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
     870:	e0 e5       	ldi	r30, 0x50	; 80
     872:	f0 e0       	ldi	r31, 0x00	; 0
     874:	80 81       	ld	r24, Z
     876:	88 60       	ori	r24, 0x08	; 8
     878:	80 83       	st	Z, r24
	// wait for signal to stabilize
do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
     87a:	81 81       	ldd	r24, Z+1	; 0x01
     87c:	83 ff       	sbrs	r24, 3
     87e:	fd cf       	rjmp	.-6      	; 0x87a <setXOSC_32MHz+0x14>
// configure PLL to use the crystal and turn on
CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
     880:	80 ec       	ldi	r24, 0xC0	; 192
     882:	62 e0       	ldi	r22, 0x02	; 2
     884:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <CLKSYS_PLL_Config>
CLKSYS_Enable( OSC_PLLEN_bm );
     888:	e0 e5       	ldi	r30, 0x50	; 80
     88a:	f0 e0       	ldi	r31, 0x00	; 0
     88c:	80 81       	ld	r24, Z
     88e:	80 61       	ori	r24, 0x10	; 16
     890:	80 83       	st	Z, r24
// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
     892:	81 81       	ldd	r24, Z+1	; 0x01
     894:	84 ff       	sbrs	r24, 4
     896:	fd cf       	rjmp	.-6      	; 0x892 <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
     898:	84 e0       	ldi	r24, 0x04	; 4
     89a:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     89e:	81 e0       	ldi	r24, 0x01	; 1
     8a0:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <CLKSYS_Disable>
}
     8a4:	08 95       	ret

000008a6 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
     8a6:	e0 e5       	ldi	r30, 0x50	; 80
     8a8:	f0 e0       	ldi	r31, 0x00	; 0
     8aa:	80 81       	ld	r24, Z
     8ac:	82 60       	ori	r24, 0x02	; 2
     8ae:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
     8b0:	80 e0       	ldi	r24, 0x00	; 0
     8b2:	61 e0       	ldi	r22, 0x01	; 1
     8b4:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     8b8:	e0 e5       	ldi	r30, 0x50	; 80
     8ba:	f0 e0       	ldi	r31, 0x00	; 0
     8bc:	81 81       	ldd	r24, Z+1	; 0x01
     8be:	81 ff       	sbrs	r24, 1
     8c0:	fd cf       	rjmp	.-6      	; 0x8bc <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     8c2:	81 e0       	ldi	r24, 0x01	; 1
     8c4:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     8c8:	81 e0       	ldi	r24, 0x01	; 1
     8ca:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <CLKSYS_Disable>
	
}
     8ce:	08 95       	ret

000008d0 <set_32MHz_Calibrated>:

void set_32MHz_Calibrated() {
	
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
     8d0:	e0 e5       	ldi	r30, 0x50	; 80
     8d2:	f0 e0       	ldi	r31, 0x00	; 0
     8d4:	80 81       	ld	r24, Z
     8d6:	82 60       	ori	r24, 0x02	; 2
     8d8:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
     8da:	80 e0       	ldi	r24, 0x00	; 0
     8dc:	60 e0       	ldi	r22, 0x00	; 0
     8de:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     8e2:	e0 e5       	ldi	r30, 0x50	; 80
     8e4:	f0 e0       	ldi	r31, 0x00	; 0
     8e6:	81 81       	ldd	r24, Z+1	; 0x01
     8e8:	81 ff       	sbrs	r24, 1
     8ea:	fd cf       	rjmp	.-6      	; 0x8e6 <set_32MHz_Calibrated+0x16>
	// Select 32kHz crystal and low power mode
	CLKSYS_XOSC_Config( 0, true, OSC_XOSCSEL_32KHz_gc );
     8ec:	80 e0       	ldi	r24, 0x00	; 0
     8ee:	61 e0       	ldi	r22, 0x01	; 1
     8f0:	42 e0       	ldi	r20, 0x02	; 2
     8f2:	0e 94 12 1f 	call	0x3e24	; 0x3e24 <CLKSYS_XOSC_Config>
	CLKSYS_Enable( OSC_XOSCEN_bm );
     8f6:	e0 e5       	ldi	r30, 0x50	; 80
     8f8:	f0 e0       	ldi	r31, 0x00	; 0
     8fa:	80 81       	ld	r24, Z
     8fc:	88 60       	ori	r24, 0x08	; 8
     8fe:	80 83       	st	Z, r24
	//wait for the 32kHz crystal to stabilize
	do {} while (CLKSYS_IsReady(OSC_XOSCRDY_bm) == 0);
     900:	81 81       	ldd	r24, Z+1	; 0x01
     902:	83 ff       	sbrs	r24, 3
     904:	fd cf       	rjmp	.-6      	; 0x900 <set_32MHz_Calibrated+0x30>
	//set the 32kHz crystal to calibrate the 32MHz RC oscillator
	CLKSYS_AutoCalibration_Enable( OSC_RC32MCREF_bm, true );
     906:	82 e0       	ldi	r24, 0x02	; 2
     908:	61 e0       	ldi	r22, 0x01	; 1
     90a:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <CLKSYS_AutoCalibration_Enable>
	//set the calibrated 32MHz RC oscillator as system clock
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     90e:	81 e0       	ldi	r24, 0x01	; 1
     910:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     914:	81 e0       	ldi	r24, 0x01	; 1
     916:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <CLKSYS_Disable>
}
     91a:	08 95       	ret

0000091c <set_32MHz>:

// produces consistent but inaccurate clock period.
void set_32MHz() {
	#define F_CPU 32000000UL
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
     91c:	e0 e5       	ldi	r30, 0x50	; 80
     91e:	f0 e0       	ldi	r31, 0x00	; 0
     920:	80 81       	ld	r24, Z
     922:	82 60       	ori	r24, 0x02	; 2
     924:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
     926:	80 e0       	ldi	r24, 0x00	; 0
     928:	60 e0       	ldi	r22, 0x00	; 0
     92a:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
     92e:	e0 e5       	ldi	r30, 0x50	; 80
     930:	f0 e0       	ldi	r31, 0x00	; 0
     932:	81 81       	ldd	r24, Z+1	; 0x01
     934:	81 ff       	sbrs	r24, 1
     936:	fd cf       	rjmp	.-6      	; 0x932 <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
     938:	81 e0       	ldi	r24, 0x01	; 1
     93a:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
     93e:	81 e0       	ldi	r24, 0x01	; 1
     940:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <CLKSYS_Disable>
	
}
     944:	08 95       	ret

00000946 <portExCS>:


void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
     946:	88 23       	and	r24, r24
     948:	29 f0       	breq	.+10     	; 0x954 <portExCS+0xe>
     94a:	88 e0       	ldi	r24, 0x08	; 8
     94c:	e0 e0       	ldi	r30, 0x00	; 0
     94e:	f6 e0       	ldi	r31, 0x06	; 6
     950:	86 83       	std	Z+6, r24	; 0x06
     952:	04 c0       	rjmp	.+8      	; 0x95c <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
     954:	88 e0       	ldi	r24, 0x08	; 8
     956:	e0 e0       	ldi	r30, 0x00	; 0
     958:	f6 e0       	ldi	r31, 0x06	; 6
     95a:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     95c:	8a e6       	ldi	r24, 0x6A	; 106
     95e:	8a 95       	dec	r24
     960:	f1 f7       	brne	.-4      	; 0x95e <portExCS+0x18>
     962:	00 c0       	rjmp	.+0      	; 0x964 <portExCS+0x1e>
	}
	_delay_us(10);
}
     964:	08 95       	ret

00000966 <Ext1Power>:
	SPIDisable();
}

void Ext1Power(uint8_t on) {
	
	if (on) {
     966:	88 23       	and	r24, r24
     968:	79 f0       	breq	.+30     	; 0x988 <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
     96a:	e0 ea       	ldi	r30, 0xA0	; 160
     96c:	f6 e0       	ldi	r31, 0x06	; 6
     96e:	80 e2       	ldi	r24, 0x20	; 32
     970:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
     972:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     974:	8f ef       	ldi	r24, 0xFF	; 255
     976:	93 ec       	ldi	r25, 0xC3	; 195
     978:	a9 e0       	ldi	r26, 0x09	; 9
     97a:	81 50       	subi	r24, 0x01	; 1
     97c:	90 40       	sbci	r25, 0x00	; 0
     97e:	a0 40       	sbci	r26, 0x00	; 0
     980:	e1 f7       	brne	.-8      	; 0x97a <Ext1Power+0x14>
     982:	00 c0       	rjmp	.+0      	; 0x984 <Ext1Power+0x1e>
     984:	00 00       	nop
     986:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
     988:	e0 ea       	ldi	r30, 0xA0	; 160
     98a:	f6 e0       	ldi	r31, 0x06	; 6
     98c:	80 e2       	ldi	r24, 0x20	; 32
     98e:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
     990:	82 83       	std	Z+2, r24	; 0x02
     992:	08 95       	ret

00000994 <Ext2Power>:
	}
}

void Ext2Power(uint8_t on) {
	
	if (on) {
     994:	88 23       	and	r24, r24
     996:	79 f0       	breq	.+30     	; 0x9b6 <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
     998:	e0 ea       	ldi	r30, 0xA0	; 160
     99a:	f6 e0       	ldi	r31, 0x06	; 6
     99c:	80 e4       	ldi	r24, 0x40	; 64
     99e:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
     9a0:	85 83       	std	Z+5, r24	; 0x05
     9a2:	8f ef       	ldi	r24, 0xFF	; 255
     9a4:	93 ec       	ldi	r25, 0xC3	; 195
     9a6:	a9 e0       	ldi	r26, 0x09	; 9
     9a8:	81 50       	subi	r24, 0x01	; 1
     9aa:	90 40       	sbci	r25, 0x00	; 0
     9ac:	a0 40       	sbci	r26, 0x00	; 0
     9ae:	e1 f7       	brne	.-8      	; 0x9a8 <Ext2Power+0x14>
     9b0:	00 c0       	rjmp	.+0      	; 0x9b2 <Ext2Power+0x1e>
     9b2:	00 00       	nop
     9b4:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
     9b6:	e0 ea       	ldi	r30, 0xA0	; 160
     9b8:	f6 e0       	ldi	r31, 0x06	; 6
     9ba:	80 e4       	ldi	r24, 0x40	; 64
     9bc:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
     9be:	82 83       	std	Z+2, r24	; 0x02
     9c0:	08 95       	ret

000009c2 <HVPower>:
	}
}

void HVPower(uint8_t on) {
	
	if (on) {
     9c2:	88 23       	and	r24, r24
     9c4:	79 f0       	breq	.+30     	; 0x9e4 <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
     9c6:	e0 ea       	ldi	r30, 0xA0	; 160
     9c8:	f6 e0       	ldi	r31, 0x06	; 6
     9ca:	80 e8       	ldi	r24, 0x80	; 128
     9cc:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
     9ce:	85 83       	std	Z+5, r24	; 0x05
     9d0:	8f ef       	ldi	r24, 0xFF	; 255
     9d2:	93 ec       	ldi	r25, 0xC3	; 195
     9d4:	a9 e0       	ldi	r26, 0x09	; 9
     9d6:	81 50       	subi	r24, 0x01	; 1
     9d8:	90 40       	sbci	r25, 0x00	; 0
     9da:	a0 40       	sbci	r26, 0x00	; 0
     9dc:	e1 f7       	brne	.-8      	; 0x9d6 <HVPower+0x14>
     9de:	00 c0       	rjmp	.+0      	; 0x9e0 <HVPower+0x1e>
     9e0:	00 00       	nop
     9e2:	05 c0       	rjmp	.+10     	; 0x9ee <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
     9e4:	e0 ea       	ldi	r30, 0xA0	; 160
     9e6:	f6 e0       	ldi	r31, 0x06	; 6
     9e8:	80 e8       	ldi	r24, 0x80	; 128
     9ea:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
     9ec:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     9ee:	af e3       	ldi	r26, 0x3F	; 63
     9f0:	bf e1       	ldi	r27, 0x1F	; 31
     9f2:	11 97       	sbiw	r26, 0x01	; 1
     9f4:	f1 f7       	brne	.-4      	; 0x9f2 <HVPower+0x30>
     9f6:	00 c0       	rjmp	.+0      	; 0x9f8 <HVPower+0x36>
     9f8:	00 00       	nop
	}
	_delay_us(1000);
}
     9fa:	08 95       	ret

000009fc <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
	
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
     9fc:	88 23       	and	r24, r24
     9fe:	29 f0       	breq	.+10     	; 0xa0a <lowerMuxCS+0xe>
     a00:	80 e1       	ldi	r24, 0x10	; 16
     a02:	e0 e8       	ldi	r30, 0x80	; 128
     a04:	f6 e0       	ldi	r31, 0x06	; 6
     a06:	86 83       	std	Z+6, r24	; 0x06
     a08:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
     a0a:	80 e1       	ldi	r24, 0x10	; 16
     a0c:	e0 e8       	ldi	r30, 0x80	; 128
     a0e:	f6 e0       	ldi	r31, 0x06	; 6
     a10:	85 83       	std	Z+5, r24	; 0x05
     a12:	08 95       	ret

00000a14 <upperMuxCS>:
}

void upperMuxCS(uint8_t write) {
	
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
     a14:	88 23       	and	r24, r24
     a16:	29 f0       	breq	.+10     	; 0xa22 <upperMuxCS+0xe>
     a18:	82 e0       	ldi	r24, 0x02	; 2
     a1a:	e0 e4       	ldi	r30, 0x40	; 64
     a1c:	f6 e0       	ldi	r31, 0x06	; 6
     a1e:	86 83       	std	Z+6, r24	; 0x06
     a20:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
     a22:	82 e0       	ldi	r24, 0x02	; 2
     a24:	e0 e4       	ldi	r30, 0x40	; 64
     a26:	f6 e0       	ldi	r31, 0x06	; 6
     a28:	85 83       	std	Z+5, r24	; 0x05
     a2a:	08 95       	ret

00000a2c <SPIInit>:
}

void SPIInit(uint8_t mode) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     a2c:	e0 e4       	ldi	r30, 0x40	; 64
     a2e:	f6 e0       	ldi	r31, 0x06	; 6
     a30:	90 e1       	ldi	r25, 0x10	; 16
     a32:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     a34:	28 e3       	ldi	r18, 0x38	; 56
     a36:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     a38:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
     a3a:	81 65       	ori	r24, 0x51	; 81
     a3c:	a0 ec       	ldi	r26, 0xC0	; 192
     a3e:	b8 e0       	ldi	r27, 0x08	; 8
     a40:	8c 93       	st	X, r24
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     a42:	11 96       	adiw	r26, 0x01	; 1
     a44:	1c 92       	st	X, r1
     a46:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     a48:	80 ea       	ldi	r24, 0xA0	; 160
     a4a:	81 83       	std	Z+1, r24	; 0x01

	
}
     a4c:	08 95       	ret

00000a4e <SPIInit2>:

//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
     a4e:	e0 e4       	ldi	r30, 0x40	; 64
     a50:	f6 e0       	ldi	r31, 0x06	; 6
     a52:	90 e1       	ldi	r25, 0x10	; 16
     a54:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
     a56:	28 e3       	ldi	r18, 0x38	; 56
     a58:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
     a5a:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
     a5c:	80 65       	ori	r24, 0x50	; 80
     a5e:	68 2b       	or	r22, r24
     a60:	a0 ec       	ldi	r26, 0xC0	; 192
     a62:	b8 e0       	ldi	r27, 0x08	; 8
     a64:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
     a66:	11 96       	adiw	r26, 0x01	; 1
     a68:	1c 92       	st	X, r1
     a6a:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
     a6c:	80 ea       	ldi	r24, 0xA0	; 160
     a6e:	81 83       	std	Z+1, r24	; 0x01
}
     a70:	08 95       	ret

00000a72 <SPICS>:

void SPICS(uint8_t enable) {
	
	if (enable) PORTC.OUTCLR = PIN4_bm;
     a72:	88 23       	and	r24, r24
     a74:	29 f0       	breq	.+10     	; 0xa80 <SPICS+0xe>
     a76:	80 e1       	ldi	r24, 0x10	; 16
     a78:	e0 e4       	ldi	r30, 0x40	; 64
     a7a:	f6 e0       	ldi	r31, 0x06	; 6
     a7c:	86 83       	std	Z+6, r24	; 0x06
     a7e:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
     a80:	80 e1       	ldi	r24, 0x10	; 16
     a82:	e0 e4       	ldi	r30, 0x40	; 64
     a84:	f6 e0       	ldi	r31, 0x06	; 6
     a86:	85 83       	std	Z+5, r24	; 0x05
     a88:	08 95       	ret

00000a8a <SPIDisable>:
	}
}

void SPIDisable() {
	
	PORTC.OUTSET = PIN4_bm;
     a8a:	e0 e4       	ldi	r30, 0x40	; 64
     a8c:	f6 e0       	ldi	r31, 0x06	; 6
     a8e:	80 e1       	ldi	r24, 0x10	; 16
     a90:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
     a92:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
     a96:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
     a98:	80 eb       	ldi	r24, 0xB0	; 176
     a9a:	82 83       	std	Z+2, r24	; 0x02

}
     a9c:	08 95       	ret

00000a9e <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     a9e:	cf 93       	push	r28
     aa0:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     aa2:	c8 2f       	mov	r28, r24
     aa4:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
     aa6:	d8 2f       	mov	r29, r24
     aa8:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     aaa:	28 2f       	mov	r18, r24
     aac:	30 e0       	ldi	r19, 0x00	; 0
     aae:	a9 01       	movw	r20, r18
     ab0:	45 70       	andi	r20, 0x05	; 5
     ab2:	50 70       	andi	r21, 0x00	; 0
     ab4:	41 15       	cp	r20, r1
     ab6:	51 05       	cpc	r21, r1
     ab8:	49 f0       	breq	.+18     	; 0xacc <set_filter+0x2e>
     aba:	90 91 35 3e 	lds	r25, 0x3E35
     abe:	48 2f       	mov	r20, r24
     ac0:	42 95       	swap	r20
     ac2:	4f 70       	andi	r20, 0x0F	; 15
     ac4:	90 7f       	andi	r25, 0xF0	; 240
     ac6:	94 2b       	or	r25, r20
     ac8:	90 93 35 3e 	sts	0x3E35, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     acc:	2a 70       	andi	r18, 0x0A	; 10
     ace:	30 70       	andi	r19, 0x00	; 0
     ad0:	21 15       	cp	r18, r1
     ad2:	31 05       	cpc	r19, r1
     ad4:	39 f0       	breq	.+14     	; 0xae4 <set_filter+0x46>
     ad6:	90 91 35 3e 	lds	r25, 0x3E35
     ada:	80 7f       	andi	r24, 0xF0	; 240
     adc:	9f 70       	andi	r25, 0x0F	; 15
     ade:	89 2b       	or	r24, r25
     ae0:	80 93 35 3e 	sts	0x3E35, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     ae4:	84 e0       	ldi	r24, 0x04	; 4
     ae6:	0e 94 16 05 	call	0xa2c	; 0xa2c <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     aea:	80 91 35 3e 	lds	r24, 0x3E35
     aee:	80 93 25 3e 	sts	0x3E25, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     af2:	cc 23       	and	r28, r28
     af4:	19 f0       	breq	.+6      	; 0xafc <set_filter+0x5e>
     af6:	81 e0       	ldi	r24, 0x01	; 1
     af8:	0e 94 fe 04 	call	0x9fc	; 0x9fc <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     afc:	dd 23       	and	r29, r29
     afe:	19 f0       	breq	.+6      	; 0xb06 <set_filter+0x68>
     b00:	81 e0       	ldi	r24, 0x01	; 1
     b02:	0e 94 0a 05 	call	0xa14	; 0xa14 <upperMuxCS>

	SPICS(TRUE);
     b06:	81 e0       	ldi	r24, 0x01	; 1
     b08:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     b0c:	8f ef       	ldi	r24, 0xFF	; 255
     b0e:	e0 ec       	ldi	r30, 0xC0	; 192
     b10:	f8 e0       	ldi	r31, 0x08	; 8
     b12:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     b14:	82 81       	ldd	r24, Z+2	; 0x02
     b16:	88 23       	and	r24, r24
     b18:	ec f7       	brge	.-6      	; 0xb14 <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
     b1a:	e0 ec       	ldi	r30, 0xC0	; 192
     b1c:	f8 e0       	ldi	r31, 0x08	; 8
     b1e:	83 81       	ldd	r24, Z+3	; 0x03
     b20:	80 93 31 3e 	sts	0x3E31, r24

	nop();
     b24:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     b26:	a1 e3       	ldi	r26, 0x31	; 49
     b28:	be e3       	ldi	r27, 0x3E	; 62
     b2a:	1c 97       	sbiw	r26, 0x0c	; 12
     b2c:	8c 91       	ld	r24, X
     b2e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     b30:	82 81       	ldd	r24, Z+2	; 0x02
     b32:	88 23       	and	r24, r24
     b34:	ec f7       	brge	.-6      	; 0xb30 <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     b36:	e0 ec       	ldi	r30, 0xC0	; 192
     b38:	f8 e0       	ldi	r31, 0x08	; 8
     b3a:	83 81       	ldd	r24, Z+3	; 0x03
     b3c:	80 93 31 3e 	sts	0x3E31, r24
	SPICS(FALSE);
     b40:	80 e0       	ldi	r24, 0x00	; 0
     b42:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     b46:	cc 23       	and	r28, r28
     b48:	19 f0       	breq	.+6      	; 0xb50 <set_filter+0xb2>
     b4a:	80 e0       	ldi	r24, 0x00	; 0
     b4c:	0e 94 fe 04 	call	0x9fc	; 0x9fc <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     b50:	dd 23       	and	r29, r29
     b52:	19 f0       	breq	.+6      	; 0xb5a <set_filter+0xbc>
     b54:	80 e0       	ldi	r24, 0x00	; 0
     b56:	0e 94 0a 05 	call	0xa14	; 0xa14 <upperMuxCS>
	SPIDisable();
     b5a:	0e 94 45 05 	call	0xa8a	; 0xa8a <SPIDisable>
}
     b5e:	df 91       	pop	r29
     b60:	cf 91       	pop	r28
     b62:	08 95       	ret

00000b64 <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     b64:	cf 93       	push	r28
     b66:	df 93       	push	r29
     b68:	c8 2f       	mov	r28, r24
     b6a:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     b6c:	80 e0       	ldi	r24, 0x00	; 0
     b6e:	0e 94 16 05 	call	0xa2c	; 0xa2c <SPIInit>
	SPICS(TRUE);
     b72:	81 e0       	ldi	r24, 0x01	; 1
     b74:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	portExCS(TRUE);
     b78:	81 e0       	ldi	r24, 0x01	; 1
     b7a:	0e 94 a3 04 	call	0x946	; 0x946 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
     b7e:	dd 23       	and	r29, r29
     b80:	89 f0       	breq	.+34     	; 0xba4 <PortEx_OUTCLR+0x40>
     b82:	80 91 b0 21 	lds	r24, 0x21B0
     b86:	c0 95       	com	r28
     b88:	c8 23       	and	r28, r24
     b8a:	c0 93 b0 21 	sts	0x21B0, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
     b8e:	80 e4       	ldi	r24, 0x40	; 64
     b90:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     b94:	84 e1       	ldi	r24, 0x14	; 20
     b96:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = bankA_OUT;
     b9a:	80 91 b0 21 	lds	r24, 0x21B0
     b9e:	80 93 27 3e 	sts	0x3E27, r24
     ba2:	10 c0       	rjmp	.+32     	; 0xbc4 <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
     ba4:	80 91 36 3e 	lds	r24, 0x3E36
     ba8:	c0 95       	com	r28
     baa:	c8 23       	and	r28, r24
     bac:	c0 93 36 3e 	sts	0x3E36, r28
	
	SPIBuffer[0] = PS_WRITE;
     bb0:	80 e4       	ldi	r24, 0x40	; 64
     bb2:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     bb6:	85 e1       	ldi	r24, 0x15	; 21
     bb8:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = bankB_OUT; 
     bbc:	80 91 36 3e 	lds	r24, 0x3E36
     bc0:	80 93 27 3e 	sts	0x3E27, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
     bc4:	80 e0       	ldi	r24, 0x00	; 0
     bc6:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     bc8:	25 e2       	ldi	r18, 0x25	; 37
     bca:	3e e3       	ldi	r19, 0x3E	; 62
     bcc:	a0 ec       	ldi	r26, 0xC0	; 192
     bce:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     bd0:	c1 e3       	ldi	r28, 0x31	; 49
     bd2:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     bd4:	f9 01       	movw	r30, r18
     bd6:	e8 0f       	add	r30, r24
     bd8:	f9 1f       	adc	r31, r25
     bda:	40 81       	ld	r20, Z
     bdc:	13 96       	adiw	r26, 0x03	; 3
     bde:	4c 93       	st	X, r20
     be0:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     be2:	12 96       	adiw	r26, 0x02	; 2
     be4:	4c 91       	ld	r20, X
     be6:	12 97       	sbiw	r26, 0x02	; 2
     be8:	44 23       	and	r20, r20
     bea:	dc f7       	brge	.-10     	; 0xbe2 <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
     bec:	13 96       	adiw	r26, 0x03	; 3
     bee:	4c 91       	ld	r20, X
     bf0:	13 97       	sbiw	r26, 0x03	; 3
     bf2:	48 83       	st	Y, r20
     bf4:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     bf6:	83 30       	cpi	r24, 0x03	; 3
     bf8:	91 05       	cpc	r25, r1
     bfa:	61 f7       	brne	.-40     	; 0xbd4 <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     bfc:	80 e0       	ldi	r24, 0x00	; 0
     bfe:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	portExCS(FALSE);
     c02:	80 e0       	ldi	r24, 0x00	; 0
     c04:	0e 94 a3 04 	call	0x946	; 0x946 <portExCS>
	SPIDisable();
     c08:	0e 94 45 05 	call	0xa8a	; 0xa8a <SPIDisable>
}
     c0c:	df 91       	pop	r29
     c0e:	cf 91       	pop	r28
     c10:	08 95       	ret

00000c12 <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     c12:	cf 93       	push	r28
     c14:	df 93       	push	r29
     c16:	c8 2f       	mov	r28, r24
     c18:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     c1a:	80 e0       	ldi	r24, 0x00	; 0
     c1c:	0e 94 16 05 	call	0xa2c	; 0xa2c <SPIInit>
	SPICS(TRUE);
     c20:	81 e0       	ldi	r24, 0x01	; 1
     c22:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	portExCS(TRUE);
     c26:	81 e0       	ldi	r24, 0x01	; 1
     c28:	0e 94 a3 04 	call	0x946	; 0x946 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
     c2c:	dd 23       	and	r29, r29
     c2e:	81 f0       	breq	.+32     	; 0xc50 <PortEx_OUTSET+0x3e>
     c30:	80 91 b0 21 	lds	r24, 0x21B0
     c34:	c8 2b       	or	r28, r24
     c36:	c0 93 b0 21 	sts	0x21B0, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
     c3a:	80 e4       	ldi	r24, 0x40	; 64
     c3c:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
     c40:	84 e1       	ldi	r24, 0x14	; 20
     c42:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = bankA_OUT;
     c46:	80 91 b0 21 	lds	r24, 0x21B0
     c4a:	80 93 27 3e 	sts	0x3E27, r24
     c4e:	0f c0       	rjmp	.+30     	; 0xc6e <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
     c50:	80 91 36 3e 	lds	r24, 0x3E36
     c54:	c8 2b       	or	r28, r24
     c56:	c0 93 36 3e 	sts	0x3E36, r28
	
	SPIBuffer[0] = PS_WRITE;
     c5a:	80 e4       	ldi	r24, 0x40	; 64
     c5c:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
     c60:	85 e1       	ldi	r24, 0x15	; 21
     c62:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = bankB_OUT; 
     c66:	80 91 36 3e 	lds	r24, 0x3E36
     c6a:	80 93 27 3e 	sts	0x3E27, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
     c6e:	80 e0       	ldi	r24, 0x00	; 0
     c70:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     c72:	25 e2       	ldi	r18, 0x25	; 37
     c74:	3e e3       	ldi	r19, 0x3E	; 62
     c76:	a0 ec       	ldi	r26, 0xC0	; 192
     c78:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     c7a:	c1 e3       	ldi	r28, 0x31	; 49
     c7c:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     c7e:	f9 01       	movw	r30, r18
     c80:	e8 0f       	add	r30, r24
     c82:	f9 1f       	adc	r31, r25
     c84:	40 81       	ld	r20, Z
     c86:	13 96       	adiw	r26, 0x03	; 3
     c88:	4c 93       	st	X, r20
     c8a:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     c8c:	12 96       	adiw	r26, 0x02	; 2
     c8e:	4c 91       	ld	r20, X
     c90:	12 97       	sbiw	r26, 0x02	; 2
     c92:	44 23       	and	r20, r20
     c94:	dc f7       	brge	.-10     	; 0xc8c <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
     c96:	13 96       	adiw	r26, 0x03	; 3
     c98:	4c 91       	ld	r20, X
     c9a:	13 97       	sbiw	r26, 0x03	; 3
     c9c:	48 83       	st	Y, r20
     c9e:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     ca0:	83 30       	cpi	r24, 0x03	; 3
     ca2:	91 05       	cpc	r25, r1
     ca4:	61 f7       	brne	.-40     	; 0xc7e <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     ca6:	80 e0       	ldi	r24, 0x00	; 0
     ca8:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	portExCS(FALSE);
     cac:	80 e0       	ldi	r24, 0x00	; 0
     cae:	0e 94 a3 04 	call	0x946	; 0x946 <portExCS>
	SPIDisable();
     cb2:	0e 94 45 05 	call	0xa8a	; 0xa8a <SPIDisable>
}
     cb6:	df 91       	pop	r29
     cb8:	cf 91       	pop	r28
     cba:	08 95       	ret

00000cbc <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     cbc:	cf 93       	push	r28
     cbe:	df 93       	push	r29
     cc0:	c8 2f       	mov	r28, r24
     cc2:	d6 2f       	mov	r29, r22
	
	SPIInit(PS_SPI_MODE);
     cc4:	80 e0       	ldi	r24, 0x00	; 0
     cc6:	0e 94 16 05 	call	0xa2c	; 0xa2c <SPIInit>
	SPICS(TRUE);
     cca:	81 e0       	ldi	r24, 0x01	; 1
     ccc:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	portExCS(TRUE);
     cd0:	81 e0       	ldi	r24, 0x01	; 1
     cd2:	0e 94 a3 04 	call	0x946	; 0x946 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
     cd6:	dd 23       	and	r29, r29
     cd8:	89 f0       	breq	.+34     	; 0xcfc <PortEx_DIRCLR+0x40>
     cda:	80 91 34 3e 	lds	r24, 0x3E34
     cde:	80 95       	com	r24
     ce0:	c8 23       	and	r28, r24
     ce2:	c0 93 34 3e 	sts	0x3E34, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     ce6:	80 e4       	ldi	r24, 0x40	; 64
     ce8:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     cec:	10 92 26 3e 	sts	0x3E26, r1
		SPIBuffer[2] = ~bankA_DIR; 
     cf0:	80 91 34 3e 	lds	r24, 0x3E34
     cf4:	80 95       	com	r24
     cf6:	80 93 27 3e 	sts	0x3E27, r24
     cfa:	11 c0       	rjmp	.+34     	; 0xd1e <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
     cfc:	80 91 4b 3e 	lds	r24, 0x3E4B
     d00:	80 95       	com	r24
     d02:	c8 23       	and	r28, r24
     d04:	c0 93 4b 3e 	sts	0x3E4B, r28
	
	SPIBuffer[0] = PS_WRITE;
     d08:	80 e4       	ldi	r24, 0x40	; 64
     d0a:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     d0e:	81 e0       	ldi	r24, 0x01	; 1
     d10:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = ~bankB_DIR;
     d14:	80 91 4b 3e 	lds	r24, 0x3E4B
     d18:	80 95       	com	r24
     d1a:	80 93 27 3e 	sts	0x3E27, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
     d1e:	80 e0       	ldi	r24, 0x00	; 0
     d20:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     d22:	25 e2       	ldi	r18, 0x25	; 37
     d24:	3e e3       	ldi	r19, 0x3E	; 62
     d26:	a0 ec       	ldi	r26, 0xC0	; 192
     d28:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
     d2a:	c1 e3       	ldi	r28, 0x31	; 49
     d2c:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     d2e:	f9 01       	movw	r30, r18
     d30:	e8 0f       	add	r30, r24
     d32:	f9 1f       	adc	r31, r25
     d34:	40 81       	ld	r20, Z
     d36:	13 96       	adiw	r26, 0x03	; 3
     d38:	4c 93       	st	X, r20
     d3a:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
     d3c:	12 96       	adiw	r26, 0x02	; 2
     d3e:	4c 91       	ld	r20, X
     d40:	12 97       	sbiw	r26, 0x02	; 2
     d42:	44 23       	and	r20, r20
     d44:	dc f7       	brge	.-10     	; 0xd3c <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
     d46:	13 96       	adiw	r26, 0x03	; 3
     d48:	4c 91       	ld	r20, X
     d4a:	13 97       	sbiw	r26, 0x03	; 3
     d4c:	48 83       	st	Y, r20
     d4e:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     d50:	83 30       	cpi	r24, 0x03	; 3
     d52:	91 05       	cpc	r25, r1
     d54:	61 f7       	brne	.-40     	; 0xd2e <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
     d56:	80 e0       	ldi	r24, 0x00	; 0
     d58:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	portExCS(FALSE);
     d5c:	80 e0       	ldi	r24, 0x00	; 0
     d5e:	0e 94 a3 04 	call	0x946	; 0x946 <portExCS>
	SPIDisable();
     d62:	0e 94 45 05 	call	0xa8a	; 0xa8a <SPIDisable>
}
     d66:	df 91       	pop	r29
     d68:	cf 91       	pop	r28
     d6a:	08 95       	ret

00000d6c <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     d6c:	cf 93       	push	r28
     d6e:	df 93       	push	r29
     d70:	c8 2f       	mov	r28, r24
     d72:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
     d74:	80 e0       	ldi	r24, 0x00	; 0
     d76:	0e 94 16 05 	call	0xa2c	; 0xa2c <SPIInit>
	SPICS(TRUE);
     d7a:	81 e0       	ldi	r24, 0x01	; 1
     d7c:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	portExCS(TRUE);
     d80:	81 e0       	ldi	r24, 0x01	; 1
     d82:	0e 94 a3 04 	call	0x946	; 0x946 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
     d86:	dd 23       	and	r29, r29
     d88:	81 f0       	breq	.+32     	; 0xdaa <PortEx_DIRSET+0x3e>
     d8a:	80 91 34 3e 	lds	r24, 0x3E34
     d8e:	c8 2b       	or	r28, r24
     d90:	c0 93 34 3e 	sts	0x3E34, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
     d94:	80 e4       	ldi	r24, 0x40	; 64
     d96:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
     d9a:	10 92 26 3e 	sts	0x3E26, r1
		SPIBuffer[2] = ~bankA_DIR; 
     d9e:	80 91 34 3e 	lds	r24, 0x3E34
     da2:	80 95       	com	r24
     da4:	80 93 27 3e 	sts	0x3E27, r24
     da8:	10 c0       	rjmp	.+32     	; 0xdca <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
     daa:	80 91 4b 3e 	lds	r24, 0x3E4B
     dae:	c8 2b       	or	r28, r24
     db0:	c0 93 4b 3e 	sts	0x3E4B, r28
	
	SPIBuffer[0] = PS_WRITE;
     db4:	80 e4       	ldi	r24, 0x40	; 64
     db6:	80 93 25 3e 	sts	0x3E25, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
     dba:	81 e0       	ldi	r24, 0x01	; 1
     dbc:	80 93 26 3e 	sts	0x3E26, r24
		SPIBuffer[2] = ~bankB_DIR;
     dc0:	80 91 4b 3e 	lds	r24, 0x3E4B
     dc4:	80 95       	com	r24
     dc6:	80 93 27 3e 	sts	0x3E27, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
     dca:	80 e0       	ldi	r24, 0x00	; 0
     dcc:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     dce:	25 e2       	ldi	r18, 0x25	; 37
     dd0:	3e e3       	ldi	r19, 0x3E	; 62
     dd2:	a0 ec       	ldi	r26, 0xC0	; 192
     dd4:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     dd6:	c1 e3       	ldi	r28, 0x31	; 49
     dd8:	de e3       	ldi	r29, 0x3E	; 62
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
     dda:	f9 01       	movw	r30, r18
     ddc:	e8 0f       	add	r30, r24
     dde:	f9 1f       	adc	r31, r25
     de0:	40 81       	ld	r20, Z
     de2:	13 96       	adiw	r26, 0x03	; 3
     de4:	4c 93       	st	X, r20
     de6:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
     de8:	12 96       	adiw	r26, 0x02	; 2
     dea:	4c 91       	ld	r20, X
     dec:	12 97       	sbiw	r26, 0x02	; 2
     dee:	44 23       	and	r20, r20
     df0:	dc f7       	brge	.-10     	; 0xde8 <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
     df2:	13 96       	adiw	r26, 0x03	; 3
     df4:	4c 91       	ld	r20, X
     df6:	13 97       	sbiw	r26, 0x03	; 3
     df8:	48 83       	st	Y, r20
     dfa:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     dfc:	83 30       	cpi	r24, 0x03	; 3
     dfe:	91 05       	cpc	r25, r1
     e00:	61 f7       	brne	.-40     	; 0xdda <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
     e02:	80 e0       	ldi	r24, 0x00	; 0
     e04:	0e 94 a3 04 	call	0x946	; 0x946 <portExCS>
	SPICS(FALSE);
     e08:	80 e0       	ldi	r24, 0x00	; 0
     e0a:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	SPIDisable();
     e0e:	0e 94 45 05 	call	0xa8a	; 0xa8a <SPIDisable>


}
     e12:	df 91       	pop	r29
     e14:	cf 91       	pop	r28
     e16:	08 95       	ret

00000e18 <ADCPower>:
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
	else PORTC.OUTSET = PIN1_bm;
}

void ADCPower(uint8_t on) {
     e18:	0f 93       	push	r16
     e1a:	1f 93       	push	r17
     e1c:	cf 93       	push	r28
     e1e:	df 93       	push	r29
	
	if (on && !ADC_POWER_ON) {
     e20:	88 23       	and	r24, r24
     e22:	09 f4       	brne	.+2      	; 0xe26 <ADCPower+0xe>
     e24:	4e c0       	rjmp	.+156    	; 0xec2 <ADCPower+0xaa>
     e26:	80 91 37 3e 	lds	r24, 0x3E37
     e2a:	88 23       	and	r24, r24
     e2c:	09 f0       	breq	.+2      	; 0xe30 <ADCPower+0x18>
     e2e:	81 c0       	rjmp	.+258    	; 0xf32 <ADCPower+0x11a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     e30:	00 e0       	ldi	r16, 0x00	; 0
     e32:	16 e0       	ldi	r17, 0x06	; 6
     e34:	8e ed       	ldi	r24, 0xDE	; 222
     e36:	d8 01       	movw	r26, r16
     e38:	11 96       	adiw	r26, 0x01	; 1
     e3a:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     e3c:	c0 e2       	ldi	r28, 0x20	; 32
     e3e:	d6 e0       	ldi	r29, 0x06	; 6
     e40:	4e e0       	ldi	r20, 0x0E	; 14
     e42:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     e44:	e0 e4       	ldi	r30, 0x40	; 64
     e46:	f6 e0       	ldi	r31, 0x06	; 6
     e48:	63 e0       	ldi	r22, 0x03	; 3
     e4a:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     e4c:	80 e8       	ldi	r24, 0x80	; 128
     e4e:	96 e0       	ldi	r25, 0x06	; 6
     e50:	50 e1       	ldi	r21, 0x10	; 16
     e52:	dc 01       	movw	r26, r24
     e54:	11 96       	adiw	r26, 0x01	; 1
     e56:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     e58:	20 ea       	ldi	r18, 0xA0	; 160
     e5a:	36 e0       	ldi	r19, 0x06	; 6
     e5c:	d9 01       	movw	r26, r18
     e5e:	11 96       	adiw	r26, 0x01	; 1
     e60:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm; // portEx-CS
     e62:	7e e9       	ldi	r23, 0x9E	; 158
     e64:	d8 01       	movw	r26, r16
     e66:	15 96       	adiw	r26, 0x05	; 5
     e68:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     e6a:	78 e0       	ldi	r23, 0x08	; 8
     e6c:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     e6e:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     e70:	ec 01       	movw	r28, r24
     e72:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     e74:	d9 01       	movw	r26, r18
     e76:	15 96       	adiw	r26, 0x05	; 5
     e78:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
     e7a:	10 92 35 3e 	sts	0x3E35, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     e7e:	8f ef       	ldi	r24, 0xFF	; 255
     e80:	93 ec       	ldi	r25, 0xC3	; 195
     e82:	a9 e0       	ldi	r26, 0x09	; 9
     e84:	81 50       	subi	r24, 0x01	; 1
     e86:	90 40       	sbci	r25, 0x00	; 0
     e88:	a0 40       	sbci	r26, 0x00	; 0
     e8a:	e1 f7       	brne	.-8      	; 0xe84 <ADCPower+0x6c>
     e8c:	00 c0       	rjmp	.+0      	; 0xe8e <ADCPower+0x76>
     e8e:	00 00       	nop
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     e90:	80 e4       	ldi	r24, 0x40	; 64
     e92:	82 83       	std	Z+2, r24	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     e94:	10 92 36 3e 	sts	0x3E36, r1
     e98:	10 92 4b 3e 	sts	0x3E4B, r1
     e9c:	10 92 b0 21 	sts	0x21B0, r1
     ea0:	10 92 34 3e 	sts	0x3E34, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
     ea4:	8f ef       	ldi	r24, 0xFF	; 255
     ea6:	61 e0       	ldi	r22, 0x01	; 1
     ea8:	0e 94 b6 06 	call	0xd6c	; 0xd6c <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     eac:	8f ef       	ldi	r24, 0xFF	; 255
     eae:	61 e0       	ldi	r22, 0x01	; 1
     eb0:	0e 94 09 06 	call	0xc12	; 0xc12 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     eb4:	8f ef       	ldi	r24, 0xFF	; 255
     eb6:	0e 94 4f 05 	call	0xa9e	; 0xa9e <set_filter>
		ADC_POWER_ON = TRUE;
     eba:	81 e0       	ldi	r24, 0x01	; 1
     ebc:	80 93 37 3e 	sts	0x3E37, r24
     ec0:	38 c0       	rjmp	.+112    	; 0xf32 <ADCPower+0x11a>

	} else if(!on && ADC_POWER_ON) {
     ec2:	80 91 37 3e 	lds	r24, 0x3E37
     ec6:	88 23       	and	r24, r24
     ec8:	a1 f1       	breq	.+104    	; 0xf32 <ADCPower+0x11a>
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     eca:	00 e0       	ldi	r16, 0x00	; 0
     ecc:	16 e0       	ldi	r17, 0x06	; 6
     ece:	7e ed       	ldi	r23, 0xDE	; 222
     ed0:	d8 01       	movw	r26, r16
     ed2:	16 96       	adiw	r26, 0x06	; 6
     ed4:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     ed6:	a0 e2       	ldi	r26, 0x20	; 32
     ed8:	b6 e0       	ldi	r27, 0x06	; 6
     eda:	4e e0       	ldi	r20, 0x0E	; 14
     edc:	16 96       	adiw	r26, 0x06	; 6
     ede:	4c 93       	st	X, r20
     ee0:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     ee2:	20 e4       	ldi	r18, 0x40	; 64
     ee4:	36 e0       	ldi	r19, 0x06	; 6
     ee6:	63 e0       	ldi	r22, 0x03	; 3
     ee8:	e9 01       	movw	r28, r18
     eea:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     eec:	c0 e8       	ldi	r28, 0x80	; 128
     eee:	d6 e0       	ldi	r29, 0x06	; 6
     ef0:	50 e1       	ldi	r21, 0x10	; 16
     ef2:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     ef4:	80 ea       	ldi	r24, 0xA0	; 160
     ef6:	96 e0       	ldi	r25, 0x06	; 6
     ef8:	fc 01       	movw	r30, r24
     efa:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     efc:	f8 01       	movw	r30, r16
     efe:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     f00:	12 96       	adiw	r26, 0x02	; 2
     f02:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     f04:	d9 01       	movw	r26, r18
     f06:	12 96       	adiw	r26, 0x02	; 2
     f08:	6c 93       	st	X, r22
     f0a:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
     f0c:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     f0e:	ec 01       	movw	r28, r24
     f10:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     f12:	80 e4       	ldi	r24, 0x40	; 64
     f14:	12 96       	adiw	r26, 0x02	; 2
     f16:	8c 93       	st	X, r24
     f18:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     f1a:	10 92 36 3e 	sts	0x3E36, r1
     f1e:	10 92 4b 3e 	sts	0x3E4B, r1
     f22:	10 92 b0 21 	sts	0x21B0, r1
     f26:	10 92 34 3e 	sts	0x3E34, r1
		channelStatus = 0x00;
     f2a:	10 92 35 3e 	sts	0x3E35, r1
		ADC_POWER_ON = FALSE;
     f2e:	10 92 37 3e 	sts	0x3E37, r1
	}
}
     f32:	df 91       	pop	r29
     f34:	cf 91       	pop	r28
     f36:	1f 91       	pop	r17
     f38:	0f 91       	pop	r16
     f3a:	08 95       	ret

00000f3c <DeciToString>:
	PORTC.OUTCLR = PIN4_bm;
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;

}

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
     f3c:	2f 92       	push	r2
     f3e:	3f 92       	push	r3
     f40:	4f 92       	push	r4
     f42:	5f 92       	push	r5
     f44:	6f 92       	push	r6
     f46:	7f 92       	push	r7
     f48:	8f 92       	push	r8
     f4a:	9f 92       	push	r9
     f4c:	af 92       	push	r10
     f4e:	bf 92       	push	r11
     f50:	cf 92       	push	r12
     f52:	df 92       	push	r13
     f54:	ef 92       	push	r14
     f56:	ff 92       	push	r15
     f58:	0f 93       	push	r16
     f5a:	1f 93       	push	r17
     f5c:	cf 93       	push	r28
     f5e:	df 93       	push	r29
     f60:	cd b7       	in	r28, 0x3d	; 61
     f62:	de b7       	in	r29, 0x3e	; 62
     f64:	64 97       	sbiw	r28, 0x14	; 20
     f66:	cd bf       	out	0x3d, r28	; 61
     f68:	de bf       	out	0x3e, r29	; 62
     f6a:	2a 01       	movw	r4, r20
     f6c:	3b 01       	movw	r6, r22
     f6e:	89 01       	movw	r16, r18
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
     f70:	f9 01       	movw	r30, r18
     f72:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
     f74:	41 15       	cp	r20, r1
     f76:	51 05       	cpc	r21, r1
     f78:	61 05       	cpc	r22, r1
     f7a:	71 05       	cpc	r23, r1
     f7c:	09 f4       	brne	.+2      	; 0xf80 <DeciToString+0x44>
     f7e:	4d c0       	rjmp	.+154    	; 0x101a <DeciToString+0xde>
     f80:	88 2e       	mov	r8, r24
     f82:	99 2e       	mov	r9, r25
     f84:	cc 24       	eor	r12, r12
     f86:	dd 24       	eor	r13, r13
     f88:	76 01       	movw	r14, r12
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
     f8a:	5e 01       	movw	r10, r28
     f8c:	08 94       	sec
     f8e:	a1 1c       	adc	r10, r1
     f90:	b1 1c       	adc	r11, r1
     f92:	0f 2e       	mov	r0, r31
     f94:	f0 e0       	ldi	r31, 0x00	; 0
     f96:	2f 2e       	mov	r2, r31
     f98:	f0 e2       	ldi	r31, 0x20	; 32
     f9a:	3f 2e       	mov	r3, r31
     f9c:	f0 2d       	mov	r31, r0
     f9e:	f4 01       	movw	r30, r8
     fa0:	81 91       	ld	r24, Z+
     fa2:	91 91       	ld	r25, Z+
     fa4:	a1 91       	ld	r26, Z+
     fa6:	b1 91       	ld	r27, Z+
     fa8:	4f 01       	movw	r8, r30
     faa:	2d b7       	in	r18, 0x3d	; 61
     fac:	3e b7       	in	r19, 0x3e	; 62
     fae:	28 50       	subi	r18, 0x08	; 8
     fb0:	30 40       	sbci	r19, 0x00	; 0
     fb2:	2d bf       	out	0x3d, r18	; 61
     fb4:	3e bf       	out	0x3e, r19	; 62
     fb6:	2f 5f       	subi	r18, 0xFF	; 255
     fb8:	3f 4f       	sbci	r19, 0xFF	; 255
     fba:	ed b7       	in	r30, 0x3d	; 61
     fbc:	fe b7       	in	r31, 0x3e	; 62
     fbe:	a1 82       	std	Z+1, r10	; 0x01
     fc0:	b2 82       	std	Z+2, r11	; 0x02
     fc2:	f9 01       	movw	r30, r18
     fc4:	22 82       	std	Z+2, r2	; 0x02
     fc6:	33 82       	std	Z+3, r3	; 0x03
     fc8:	84 83       	std	Z+4, r24	; 0x04
     fca:	95 83       	std	Z+5, r25	; 0x05
     fcc:	a6 83       	std	Z+6, r26	; 0x06
     fce:	b7 83       	std	Z+7, r27	; 0x07
     fd0:	0e 94 2f 39 	call	0x725e	; 0x725e <sprintf>
		strcat(ReturnString,b);
     fd4:	2d b7       	in	r18, 0x3d	; 61
     fd6:	3e b7       	in	r19, 0x3e	; 62
     fd8:	28 5f       	subi	r18, 0xF8	; 248
     fda:	3f 4f       	sbci	r19, 0xFF	; 255
     fdc:	2d bf       	out	0x3d, r18	; 61
     fde:	3e bf       	out	0x3e, r19	; 62
     fe0:	c8 01       	movw	r24, r16
     fe2:	b5 01       	movw	r22, r10
     fe4:	0e 94 f1 38 	call	0x71e2	; 0x71e2 <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
     fe8:	a0 2f       	mov	r26, r16
     fea:	b1 2f       	mov	r27, r17
     fec:	fd 01       	movw	r30, r26
     fee:	01 90       	ld	r0, Z+
     ff0:	00 20       	and	r0, r0
     ff2:	e9 f7       	brne	.-6      	; 0xfee <DeciToString+0xb2>
     ff4:	31 97       	sbiw	r30, 0x01	; 1
     ff6:	ea 1b       	sub	r30, r26
     ff8:	fb 0b       	sbc	r31, r27
     ffa:	e0 0f       	add	r30, r16
     ffc:	f1 1f       	adc	r31, r17
     ffe:	8a e0       	ldi	r24, 0x0A	; 10
    1000:	90 e0       	ldi	r25, 0x00	; 0
    1002:	80 83       	st	Z, r24
    1004:	91 83       	std	Z+1, r25	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
    1006:	08 94       	sec
    1008:	c1 1c       	adc	r12, r1
    100a:	d1 1c       	adc	r13, r1
    100c:	e1 1c       	adc	r14, r1
    100e:	f1 1c       	adc	r15, r1
    1010:	c4 14       	cp	r12, r4
    1012:	d5 04       	cpc	r13, r5
    1014:	e6 04       	cpc	r14, r6
    1016:	f7 04       	cpc	r15, r7
    1018:	11 f6       	brne	.-124    	; 0xf9e <DeciToString+0x62>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}
}
    101a:	64 96       	adiw	r28, 0x14	; 20
    101c:	cd bf       	out	0x3d, r28	; 61
    101e:	de bf       	out	0x3e, r29	; 62
    1020:	df 91       	pop	r29
    1022:	cf 91       	pop	r28
    1024:	1f 91       	pop	r17
    1026:	0f 91       	pop	r16
    1028:	ff 90       	pop	r15
    102a:	ef 90       	pop	r14
    102c:	df 90       	pop	r13
    102e:	cf 90       	pop	r12
    1030:	bf 90       	pop	r11
    1032:	af 90       	pop	r10
    1034:	9f 90       	pop	r9
    1036:	8f 90       	pop	r8
    1038:	7f 90       	pop	r7
    103a:	6f 90       	pop	r6
    103c:	5f 90       	pop	r5
    103e:	4f 90       	pop	r4
    1040:	3f 90       	pop	r3
    1042:	2f 90       	pop	r2
    1044:	08 95       	ret

00001046 <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
    1046:	e0 ec       	ldi	r30, 0xC0	; 192
    1048:	f8 e0       	ldi	r31, 0x08	; 8
    104a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    104c:	82 81       	ldd	r24, Z+2	; 0x02
    104e:	88 23       	and	r24, r24
    1050:	ec f7       	brge	.-6      	; 0x104c <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
    1052:	e0 ec       	ldi	r30, 0xC0	; 192
    1054:	f8 e0       	ldi	r31, 0x08	; 8
    1056:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    1058:	08 95       	ret

0000105a <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
    105a:	0f 93       	push	r16
    105c:	1f 93       	push	r17
    105e:	cf 93       	push	r28
    1060:	8c 01       	movw	r16, r24
	moteID = 1;
    1062:	c1 e0       	ldi	r28, 0x01	; 1
    1064:	c0 93 4a 3e 	sts	0x3E4A, r28
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
    1068:	83 e0       	ldi	r24, 0x03	; 3
    106a:	80 93 24 3e 	sts	0x3E24, r24
	chb_init();
    106e:	0e 94 f6 18 	call	0x31ec	; 0x31ec <chb_init>
	chb_set_short_addr(moteID);
    1072:	80 91 4a 3e 	lds	r24, 0x3E4A
    1076:	90 e0       	ldi	r25, 0x00	; 0
    1078:	0e 94 2f 1b 	call	0x365e	; 0x365e <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
    107c:	88 ec       	ldi	r24, 0xC8	; 200
    107e:	e0 e8       	ldi	r30, 0x80	; 128
    1080:	f1 e0       	ldi	r31, 0x01	; 1
    1082:	81 83       	std	Z+1, r24	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
    1084:	e0 e4       	ldi	r30, 0x40	; 64
    1086:	f9 e0       	ldi	r31, 0x09	; 9
    1088:	89 e0       	ldi	r24, 0x09	; 9
    108a:	80 83       	st	Z, r24
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
    108c:	82 e0       	ldi	r24, 0x02	; 2
    108e:	86 83       	std	Z+6, r24	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
    1090:	24 ef       	ldi	r18, 0xF4	; 244
    1092:	31 e0       	ldi	r19, 0x01	; 1
    1094:	02 9f       	mul	r16, r18
    1096:	c0 01       	movw	r24, r0
    1098:	03 9f       	mul	r16, r19
    109a:	90 0d       	add	r25, r0
    109c:	12 9f       	mul	r17, r18
    109e:	90 0d       	add	r25, r0
    10a0:	11 24       	eor	r1, r1
    10a2:	86 a3       	lds	r24, 0x56
    10a4:	97 a3       	lds	r25, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
    10a6:	e0 e4       	ldi	r30, 0x40	; 64
    10a8:	f8 e0       	ldi	r31, 0x08	; 8
    10aa:	80 e0       	ldi	r24, 0x00	; 0
    10ac:	9a ef       	ldi	r25, 0xFA	; 250
    10ae:	86 a3       	lds	r24, 0x56
    10b0:	97 a3       	lds	r25, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
    10b2:	c6 83       	std	Z+6, r28	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
    10b4:	c0 83       	st	Z, r28
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
    10b6:	e0 ea       	ldi	r30, 0xA0	; 160
    10b8:	f0 e0       	ldi	r31, 0x00	; 0
    10ba:	82 81       	ldd	r24, Z+2	; 0x02
    10bc:	87 60       	ori	r24, 0x07	; 7
    10be:	82 83       	std	Z+2, r24	; 0x02
	sei(); //  Enable global interrupts
    10c0:	78 94       	sei
}
    10c2:	cf 91       	pop	r28
    10c4:	1f 91       	pop	r17
    10c6:	0f 91       	pop	r16
    10c8:	08 95       	ret

000010ca <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
    10ca:	78 94       	sei
    10cc:	1f 92       	push	r1
    10ce:	0f 92       	push	r0
    10d0:	0f b6       	in	r0, 0x3f	; 63
    10d2:	0f 92       	push	r0
    10d4:	0b b6       	in	r0, 0x3b	; 59
    10d6:	0f 92       	push	r0
    10d8:	11 24       	eor	r1, r1
    10da:	ef 92       	push	r14
    10dc:	ff 92       	push	r15
    10de:	0f 93       	push	r16
    10e0:	1f 93       	push	r17
    10e2:	2f 93       	push	r18
    10e4:	3f 93       	push	r19
    10e6:	4f 93       	push	r20
    10e8:	5f 93       	push	r21
    10ea:	6f 93       	push	r22
    10ec:	7f 93       	push	r23
    10ee:	8f 93       	push	r24
    10f0:	9f 93       	push	r25
    10f2:	af 93       	push	r26
    10f4:	bf 93       	push	r27
    10f6:	ef 93       	push	r30
    10f8:	ff 93       	push	r31
    10fa:	cf 93       	push	r28
    10fc:	df 93       	push	r29
    10fe:	cd b7       	in	r28, 0x3d	; 61
    1100:	de b7       	in	r29, 0x3e	; 62
    1102:	28 97       	sbiw	r28, 0x08	; 8
    1104:	cd bf       	out	0x3d, r28	; 61
    1106:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
    1108:	10 92 40 08 	sts	0x0840, r1
	TCD1.CTRLA = 0x00;
    110c:	10 92 40 09 	sts	0x0940, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
    1110:	82 e0       	ldi	r24, 0x02	; 2
    1112:	80 93 24 3e 	sts	0x3E24, r24
	char message[8];
	strcpy(message,"reset");
    1116:	de 01       	movw	r26, r28
    1118:	11 96       	adiw	r26, 0x01	; 1
    111a:	e4 e0       	ldi	r30, 0x04	; 4
    111c:	f0 e2       	ldi	r31, 0x20	; 32
    111e:	86 e0       	ldi	r24, 0x06	; 6
    1120:	01 90       	ld	r0, Z+
    1122:	0d 92       	st	X+, r0
    1124:	81 50       	subi	r24, 0x01	; 1
    1126:	e1 f7       	brne	.-8      	; 0x1120 <__vector_83+0x56>
	itoa((int)(moteID),buff,10);
    1128:	0e ea       	ldi	r16, 0xAE	; 174
    112a:	10 e5       	ldi	r17, 0x50	; 80
    112c:	80 91 4a 3e 	lds	r24, 0x3E4A
    1130:	90 e0       	ldi	r25, 0x00	; 0
    1132:	b8 01       	movw	r22, r16
    1134:	4a e0       	ldi	r20, 0x0A	; 10
    1136:	50 e0       	ldi	r21, 0x00	; 0
    1138:	0e 94 fc 38 	call	0x71f8	; 0x71f8 <itoa>
	strcat(message,buff);
    113c:	7e 01       	movw	r14, r28
    113e:	08 94       	sec
    1140:	e1 1c       	adc	r14, r1
    1142:	f1 1c       	adc	r15, r1
    1144:	c7 01       	movw	r24, r14
    1146:	b8 01       	movw	r22, r16
    1148:	0e 94 f1 38 	call	0x71e2	; 0x71e2 <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
    114c:	0e 94 e9 0b 	call	0x17d2	; 0x17d2 <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
    1150:	f7 01       	movw	r30, r14
    1152:	01 90       	ld	r0, Z+
    1154:	00 20       	and	r0, r0
    1156:	e9 f7       	brne	.-6      	; 0x1152 <__vector_83+0x88>
    1158:	31 97       	sbiw	r30, 0x01	; 1
    115a:	ee 19       	sub	r30, r14
    115c:	ff 09       	sbc	r31, r15
    115e:	9f 01       	movw	r18, r30
    1160:	40 e0       	ldi	r20, 0x00	; 0
    1162:	50 e0       	ldi	r21, 0x00	; 0
    1164:	80 e0       	ldi	r24, 0x00	; 0
    1166:	90 e0       	ldi	r25, 0x00	; 0
    1168:	b7 01       	movw	r22, r14
    116a:	0e 94 1a 19 	call	0x3234	; 0x3234 <chb_write>
}	
    116e:	28 96       	adiw	r28, 0x08	; 8
    1170:	cd bf       	out	0x3d, r28	; 61
    1172:	de bf       	out	0x3e, r29	; 62
    1174:	df 91       	pop	r29
    1176:	cf 91       	pop	r28
    1178:	ff 91       	pop	r31
    117a:	ef 91       	pop	r30
    117c:	bf 91       	pop	r27
    117e:	af 91       	pop	r26
    1180:	9f 91       	pop	r25
    1182:	8f 91       	pop	r24
    1184:	7f 91       	pop	r23
    1186:	6f 91       	pop	r22
    1188:	5f 91       	pop	r21
    118a:	4f 91       	pop	r20
    118c:	3f 91       	pop	r19
    118e:	2f 91       	pop	r18
    1190:	1f 91       	pop	r17
    1192:	0f 91       	pop	r16
    1194:	ff 90       	pop	r15
    1196:	ef 90       	pop	r14
    1198:	0f 90       	pop	r0
    119a:	0b be       	out	0x3b, r0	; 59
    119c:	0f 90       	pop	r0
    119e:	0f be       	out	0x3f, r0	; 63
    11a0:	0f 90       	pop	r0
    11a2:	1f 90       	pop	r1
    11a4:	18 95       	reti

000011a6 <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    11a6:	4f 92       	push	r4
    11a8:	5f 92       	push	r5
    11aa:	6f 92       	push	r6
    11ac:	7f 92       	push	r7
    11ae:	8f 92       	push	r8
    11b0:	9f 92       	push	r9
    11b2:	af 92       	push	r10
    11b4:	bf 92       	push	r11
    11b6:	ef 92       	push	r14
    11b8:	ff 92       	push	r15
    11ba:	0f 93       	push	r16
    11bc:	1f 93       	push	r17
    11be:	cf 93       	push	r28
    11c0:	df 93       	push	r29
    11c2:	cd b7       	in	r28, 0x3d	; 61
    11c4:	de b7       	in	r29, 0x3e	; 62
    11c6:	2b 97       	sbiw	r28, 0x0b	; 11
    11c8:	cd bf       	out	0x3d, r28	; 61
    11ca:	de bf       	out	0x3e, r29	; 62
    11cc:	8e 83       	std	Y+6, r24	; 0x06
    11ce:	9f 83       	std	Y+7, r25	; 0x07
    11d0:	68 87       	std	Y+8, r22	; 0x08
    11d2:	79 87       	std	Y+9, r23	; 0x09
    11d4:	4a 87       	std	Y+10, r20	; 0x0a
    11d6:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    11d8:	81 e0       	ldi	r24, 0x01	; 1
    11da:	0e 94 0c 07 	call	0xe18	; 0xe18 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
    11de:	80 e0       	ldi	r24, 0x00	; 0
    11e0:	92 e0       	ldi	r25, 0x02	; 2
    11e2:	0e 94 d9 18 	call	0x31b2	; 0x31b2 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    11e6:	00 e0       	ldi	r16, 0x00	; 0
    11e8:	12 e0       	ldi	r17, 0x02	; 2
    11ea:	d8 01       	movw	r26, r16
    11ec:	11 96       	adiw	r26, 0x01	; 1
    11ee:	8c 91       	ld	r24, X
    11f0:	11 97       	sbiw	r26, 0x01	; 1
    11f2:	89 7e       	andi	r24, 0xE9	; 233
    11f4:	11 96       	adiw	r26, 0x01	; 1
    11f6:	8c 93       	st	X, r24
    11f8:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
    11fa:	14 96       	adiw	r26, 0x04	; 4
    11fc:	8c 91       	ld	r24, X
    11fe:	14 97       	sbiw	r26, 0x04	; 4
    1200:	88 7f       	andi	r24, 0xF8	; 248
    1202:	83 60       	ori	r24, 0x03	; 3
    1204:	14 96       	adiw	r26, 0x04	; 4
    1206:	8c 93       	st	X, r24
    1208:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
    120a:	12 96       	adiw	r26, 0x02	; 2
    120c:	8c 91       	ld	r24, X
    120e:	12 97       	sbiw	r26, 0x02	; 2
    1210:	8f 7c       	andi	r24, 0xCF	; 207
    1212:	12 96       	adiw	r26, 0x02	; 2
    1214:	8c 93       	st	X, r24
    1216:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
    1218:	0f 2e       	mov	r0, r31
    121a:	f0 e2       	ldi	r31, 0x20	; 32
    121c:	ef 2e       	mov	r14, r31
    121e:	f2 e0       	ldi	r31, 0x02	; 2
    1220:	ff 2e       	mov	r15, r31
    1222:	f0 2d       	mov	r31, r0
    1224:	f7 01       	movw	r30, r14
    1226:	80 81       	ld	r24, Z
    1228:	80 7e       	andi	r24, 0xE0	; 224
    122a:	81 60       	ori	r24, 0x01	; 1
    122c:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    122e:	89 e0       	ldi	r24, 0x09	; 9
    1230:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
    1232:	8c 91       	ld	r24, X
    1234:	81 60       	ori	r24, 0x01	; 1
    1236:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    1238:	80 e0       	ldi	r24, 0x00	; 0
    123a:	92 e0       	ldi	r25, 0x02	; 2
    123c:	0e 94 5e 18 	call	0x30bc	; 0x30bc <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
    1240:	80 e0       	ldi	r24, 0x00	; 0
    1242:	92 e0       	ldi	r25, 0x02	; 2
    1244:	60 e2       	ldi	r22, 0x20	; 32
    1246:	72 e0       	ldi	r23, 0x02	; 2
    1248:	40 e0       	ldi	r20, 0x00	; 0
    124a:	0e 94 68 18 	call	0x30d0	; 0x30d0 <ADC_Offset_Get_Unsigned>
    124e:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
    1250:	d8 01       	movw	r26, r16
    1252:	8c 91       	ld	r24, X
    1254:	8e 7f       	andi	r24, 0xFE	; 254
    1256:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    1258:	f7 01       	movw	r30, r14
    125a:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
    125c:	13 96       	adiw	r26, 0x03	; 3
    125e:	8c 91       	ld	r24, X
    1260:	13 97       	sbiw	r26, 0x03	; 3
    1262:	8f 73       	andi	r24, 0x3F	; 63
    1264:	13 96       	adiw	r26, 0x03	; 3
    1266:	8c 93       	st	X, r24
    1268:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
    126a:	8c 91       	ld	r24, X
    126c:	81 60       	ori	r24, 0x01	; 1
    126e:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
    1270:	80 e0       	ldi	r24, 0x00	; 0
    1272:	92 e0       	ldi	r25, 0x02	; 2
    1274:	0e 94 5e 18 	call	0x30bc	; 0x30bc <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
    1278:	d8 01       	movw	r26, r16
    127a:	11 96       	adiw	r26, 0x01	; 1
    127c:	8c 91       	ld	r24, X
    127e:	11 97       	sbiw	r26, 0x01	; 1
    1280:	88 60       	ori	r24, 0x08	; 8
    1282:	11 96       	adiw	r26, 0x01	; 1
    1284:	8c 93       	st	X, r24
    1286:	ee 24       	eor	r14, r14
    1288:	ff 24       	eor	r15, r15
    128a:	68 94       	set
    128c:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    128e:	44 24       	eor	r4, r4
    1290:	55 24       	eor	r5, r5
    1292:	32 01       	movw	r6, r4
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
    1294:	20 e0       	ldi	r18, 0x00	; 0
    1296:	30 e1       	ldi	r19, 0x10	; 16
    1298:	40 e0       	ldi	r20, 0x00	; 0
    129a:	50 e0       	ldi	r21, 0x00	; 0
    129c:	2a 83       	std	Y+2, r18	; 0x02
    129e:	3b 83       	std	Y+3, r19	; 0x03
    12a0:	4c 83       	std	Y+4, r20	; 0x04
    12a2:	5d 83       	std	Y+5, r21	; 0x05
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    12a4:	88 24       	eor	r8, r8
    12a6:	99 24       	eor	r9, r9
    12a8:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
    12aa:	00 e2       	ldi	r16, 0x20	; 32
    12ac:	12 e0       	ldi	r17, 0x02	; 2
    12ae:	d8 01       	movw	r26, r16
    12b0:	13 96       	adiw	r26, 0x03	; 3
    12b2:	8c 91       	ld	r24, X
    12b4:	13 97       	sbiw	r26, 0x03	; 3
    12b6:	80 ff       	sbrs	r24, 0
    12b8:	fa cf       	rjmp	.-12     	; 0x12ae <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
    12ba:	69 81       	ldd	r22, Y+1	; 0x01
    12bc:	c8 01       	movw	r24, r16
    12be:	0e 94 3a 18 	call	0x3074	; 0x3074 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
    12c2:	a0 e0       	ldi	r26, 0x00	; 0
    12c4:	b0 e0       	ldi	r27, 0x00	; 0
    12c6:	88 0e       	add	r8, r24
    12c8:	99 1e       	adc	r9, r25
    12ca:	aa 1e       	adc	r10, r26
    12cc:	bb 1e       	adc	r11, r27
    12ce:	48 16       	cp	r4, r24
    12d0:	59 06       	cpc	r5, r25
    12d2:	6a 06       	cpc	r6, r26
    12d4:	7b 06       	cpc	r7, r27
    12d6:	10 f4       	brcc	.+4      	; 0x12dc <CO_collectTemp+0x136>
    12d8:	2c 01       	movw	r4, r24
    12da:	3d 01       	movw	r6, r26
    12dc:	2a 81       	ldd	r18, Y+2	; 0x02
    12de:	3b 81       	ldd	r19, Y+3	; 0x03
    12e0:	4c 81       	ldd	r20, Y+4	; 0x04
    12e2:	5d 81       	ldd	r21, Y+5	; 0x05
    12e4:	82 17       	cp	r24, r18
    12e6:	93 07       	cpc	r25, r19
    12e8:	a4 07       	cpc	r26, r20
    12ea:	b5 07       	cpc	r27, r21
    12ec:	20 f4       	brcc	.+8      	; 0x12f6 <CO_collectTemp+0x150>
    12ee:	8a 83       	std	Y+2, r24	; 0x02
    12f0:	9b 83       	std	Y+3, r25	; 0x03
    12f2:	ac 83       	std	Y+4, r26	; 0x04
    12f4:	bd 83       	std	Y+5, r27	; 0x05
    12f6:	08 94       	sec
    12f8:	e1 08       	sbc	r14, r1
    12fa:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    12fc:	e1 14       	cp	r14, r1
    12fe:	f1 04       	cpc	r15, r1
    1300:	b1 f6       	brne	.-84     	; 0x12ae <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
    1302:	e0 e0       	ldi	r30, 0x00	; 0
    1304:	f2 e0       	ldi	r31, 0x02	; 2
    1306:	81 81       	ldd	r24, Z+1	; 0x01
    1308:	87 7f       	andi	r24, 0xF7	; 247
    130a:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
    130c:	80 81       	ld	r24, Z
    130e:	82 60       	ori	r24, 0x02	; 2
    1310:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
    1312:	80 81       	ld	r24, Z
    1314:	8e 7f       	andi	r24, 0xFE	; 254
    1316:	80 83       	st	Z, r24

	ADCPower(FALSE);
    1318:	80 e0       	ldi	r24, 0x00	; 0
    131a:	0e 94 0c 07 	call	0xe18	; 0xe18 <ADCPower>

	average = sum / NUM_SAMPLES;
    131e:	c5 01       	movw	r24, r10
    1320:	b4 01       	movw	r22, r8
    1322:	05 2e       	mov	r0, r21
    1324:	5a e0       	ldi	r21, 0x0A	; 10
    1326:	96 95       	lsr	r25
    1328:	87 95       	ror	r24
    132a:	77 95       	ror	r23
    132c:	67 95       	ror	r22
    132e:	5a 95       	dec	r21
    1330:	d1 f7       	brne	.-12     	; 0x1326 <CO_collectTemp+0x180>
    1332:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    1334:	28 ee       	ldi	r18, 0xE8	; 232
    1336:	33 e0       	ldi	r19, 0x03	; 3
    1338:	40 e0       	ldi	r20, 0x00	; 0
    133a:	50 e0       	ldi	r21, 0x00	; 0
    133c:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    1340:	0f 2e       	mov	r0, r31
    1342:	ff ef       	ldi	r31, 0xFF	; 255
    1344:	8f 2e       	mov	r8, r31
    1346:	ff e0       	ldi	r31, 0x0F	; 15
    1348:	9f 2e       	mov	r9, r31
    134a:	f0 e0       	ldi	r31, 0x00	; 0
    134c:	af 2e       	mov	r10, r31
    134e:	f0 e0       	ldi	r31, 0x00	; 0
    1350:	bf 2e       	mov	r11, r31
    1352:	f0 2d       	mov	r31, r0
    1354:	a5 01       	movw	r20, r10
    1356:	94 01       	movw	r18, r8
    1358:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    135c:	c9 01       	movw	r24, r18
    135e:	c2 97       	sbiw	r24, 0x32	; 50
    1360:	ae 81       	ldd	r26, Y+6	; 0x06
    1362:	bf 81       	ldd	r27, Y+7	; 0x07
    1364:	8d 93       	st	X+, r24
    1366:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    1368:	c3 01       	movw	r24, r6
    136a:	b2 01       	movw	r22, r4
    136c:	28 ee       	ldi	r18, 0xE8	; 232
    136e:	33 e0       	ldi	r19, 0x03	; 3
    1370:	40 e0       	ldi	r20, 0x00	; 0
    1372:	50 e0       	ldi	r21, 0x00	; 0
    1374:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    1378:	a5 01       	movw	r20, r10
    137a:	94 01       	movw	r18, r8
    137c:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    1380:	c9 01       	movw	r24, r18
    1382:	c2 97       	sbiw	r24, 0x32	; 50
    1384:	ea 85       	ldd	r30, Y+10	; 0x0a
    1386:	fb 85       	ldd	r31, Y+11	; 0x0b
    1388:	80 83       	st	Z, r24
    138a:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    138c:	6a 81       	ldd	r22, Y+2	; 0x02
    138e:	7b 81       	ldd	r23, Y+3	; 0x03
    1390:	8c 81       	ldd	r24, Y+4	; 0x04
    1392:	9d 81       	ldd	r25, Y+5	; 0x05
    1394:	28 ee       	ldi	r18, 0xE8	; 232
    1396:	33 e0       	ldi	r19, 0x03	; 3
    1398:	40 e0       	ldi	r20, 0x00	; 0
    139a:	50 e0       	ldi	r21, 0x00	; 0
    139c:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    13a0:	a5 01       	movw	r20, r10
    13a2:	94 01       	movw	r18, r8
    13a4:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    13a8:	22 53       	subi	r18, 0x32	; 50
    13aa:	30 40       	sbci	r19, 0x00	; 0
    13ac:	a8 85       	ldd	r26, Y+8	; 0x08
    13ae:	b9 85       	ldd	r27, Y+9	; 0x09
    13b0:	2d 93       	st	X+, r18
    13b2:	3c 93       	st	X, r19
    13b4:	11 97       	sbiw	r26, 0x01	; 1
}
    13b6:	2b 96       	adiw	r28, 0x0b	; 11
    13b8:	cd bf       	out	0x3d, r28	; 61
    13ba:	de bf       	out	0x3e, r29	; 62
    13bc:	df 91       	pop	r29
    13be:	cf 91       	pop	r28
    13c0:	1f 91       	pop	r17
    13c2:	0f 91       	pop	r16
    13c4:	ff 90       	pop	r15
    13c6:	ef 90       	pop	r14
    13c8:	bf 90       	pop	r11
    13ca:	af 90       	pop	r10
    13cc:	9f 90       	pop	r9
    13ce:	8f 90       	pop	r8
    13d0:	7f 90       	pop	r7
    13d2:	6f 90       	pop	r6
    13d4:	5f 90       	pop	r5
    13d6:	4f 90       	pop	r4
    13d8:	08 95       	ret

000013da <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
    13da:	4f 92       	push	r4
    13dc:	5f 92       	push	r5
    13de:	6f 92       	push	r6
    13e0:	7f 92       	push	r7
    13e2:	8f 92       	push	r8
    13e4:	9f 92       	push	r9
    13e6:	af 92       	push	r10
    13e8:	bf 92       	push	r11
    13ea:	ef 92       	push	r14
    13ec:	ff 92       	push	r15
    13ee:	0f 93       	push	r16
    13f0:	1f 93       	push	r17
    13f2:	cf 93       	push	r28
    13f4:	df 93       	push	r29
    13f6:	cd b7       	in	r28, 0x3d	; 61
    13f8:	de b7       	in	r29, 0x3e	; 62
    13fa:	2b 97       	sbiw	r28, 0x0b	; 11
    13fc:	cd bf       	out	0x3d, r28	; 61
    13fe:	de bf       	out	0x3e, r29	; 62
    1400:	8e 83       	std	Y+6, r24	; 0x06
    1402:	9f 83       	std	Y+7, r25	; 0x07
    1404:	68 87       	std	Y+8, r22	; 0x08
    1406:	79 87       	std	Y+9, r23	; 0x09
    1408:	4a 87       	std	Y+10, r20	; 0x0a
    140a:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
    140c:	81 e0       	ldi	r24, 0x01	; 1
    140e:	0e 94 0c 07 	call	0xe18	; 0xe18 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
    1412:	84 e0       	ldi	r24, 0x04	; 4
    1414:	60 e0       	ldi	r22, 0x00	; 0
    1416:	0e 94 b6 06 	call	0xd6c	; 0xd6c <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
    141a:	84 e0       	ldi	r24, 0x04	; 4
    141c:	60 e0       	ldi	r22, 0x00	; 0
    141e:	0e 94 09 06 	call	0xc12	; 0xc12 <PortEx_OUTSET>
    1422:	2f ef       	ldi	r18, 0xFF	; 255
    1424:	33 ec       	ldi	r19, 0xC3	; 195
    1426:	49 e0       	ldi	r20, 0x09	; 9
    1428:	21 50       	subi	r18, 0x01	; 1
    142a:	30 40       	sbci	r19, 0x00	; 0
    142c:	40 40       	sbci	r20, 0x00	; 0
    142e:	e1 f7       	brne	.-8      	; 0x1428 <CO_collectBatt+0x4e>
    1430:	00 c0       	rjmp	.+0      	; 0x1432 <CO_collectBatt+0x58>
    1432:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
    1434:	80 e4       	ldi	r24, 0x40	; 64
    1436:	92 e0       	ldi	r25, 0x02	; 2
    1438:	0e 94 d9 18 	call	0x31b2	; 0x31b2 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
    143c:	00 e4       	ldi	r16, 0x40	; 64
    143e:	12 e0       	ldi	r17, 0x02	; 2
    1440:	d8 01       	movw	r26, r16
    1442:	11 96       	adiw	r26, 0x01	; 1
    1444:	8c 91       	ld	r24, X
    1446:	11 97       	sbiw	r26, 0x01	; 1
    1448:	89 7e       	andi	r24, 0xE9	; 233
    144a:	11 96       	adiw	r26, 0x01	; 1
    144c:	8c 93       	st	X, r24
    144e:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
    1450:	14 96       	adiw	r26, 0x04	; 4
    1452:	8c 91       	ld	r24, X
    1454:	14 97       	sbiw	r26, 0x04	; 4
    1456:	88 7f       	andi	r24, 0xF8	; 248
    1458:	83 60       	ori	r24, 0x03	; 3
    145a:	14 96       	adiw	r26, 0x04	; 4
    145c:	8c 93       	st	X, r24
    145e:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
    1460:	12 96       	adiw	r26, 0x02	; 2
    1462:	8c 91       	ld	r24, X
    1464:	12 97       	sbiw	r26, 0x02	; 2
    1466:	8f 7c       	andi	r24, 0xCF	; 207
    1468:	12 96       	adiw	r26, 0x02	; 2
    146a:	8c 93       	st	X, r24
    146c:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
    146e:	0f 2e       	mov	r0, r31
    1470:	f0 e6       	ldi	r31, 0x60	; 96
    1472:	ef 2e       	mov	r14, r31
    1474:	f2 e0       	ldi	r31, 0x02	; 2
    1476:	ff 2e       	mov	r15, r31
    1478:	f0 2d       	mov	r31, r0
    147a:	f7 01       	movw	r30, r14
    147c:	80 81       	ld	r24, Z
    147e:	80 7e       	andi	r24, 0xE0	; 224
    1480:	81 60       	ori	r24, 0x01	; 1
    1482:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
    1484:	89 e0       	ldi	r24, 0x09	; 9
    1486:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
    1488:	8c 91       	ld	r24, X
    148a:	81 60       	ori	r24, 0x01	; 1
    148c:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
    148e:	80 e4       	ldi	r24, 0x40	; 64
    1490:	92 e0       	ldi	r25, 0x02	; 2
    1492:	0e 94 5e 18 	call	0x30bc	; 0x30bc <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
    1496:	80 e4       	ldi	r24, 0x40	; 64
    1498:	92 e0       	ldi	r25, 0x02	; 2
    149a:	60 e6       	ldi	r22, 0x60	; 96
    149c:	72 e0       	ldi	r23, 0x02	; 2
    149e:	40 e0       	ldi	r20, 0x00	; 0
    14a0:	0e 94 68 18 	call	0x30d0	; 0x30d0 <ADC_Offset_Get_Unsigned>
    14a4:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
    14a6:	d8 01       	movw	r26, r16
    14a8:	8c 91       	ld	r24, X
    14aa:	8e 7f       	andi	r24, 0xFE	; 254
    14ac:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
    14ae:	f7 01       	movw	r30, r14
    14b0:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
    14b2:	13 96       	adiw	r26, 0x03	; 3
    14b4:	8c 91       	ld	r24, X
    14b6:	13 97       	sbiw	r26, 0x03	; 3
    14b8:	8f 73       	andi	r24, 0x3F	; 63
    14ba:	13 96       	adiw	r26, 0x03	; 3
    14bc:	8c 93       	st	X, r24
    14be:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
    14c0:	8c 91       	ld	r24, X
    14c2:	81 60       	ori	r24, 0x01	; 1
    14c4:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
    14c6:	80 e4       	ldi	r24, 0x40	; 64
    14c8:	92 e0       	ldi	r25, 0x02	; 2
    14ca:	0e 94 5e 18 	call	0x30bc	; 0x30bc <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
    14ce:	d8 01       	movw	r26, r16
    14d0:	11 96       	adiw	r26, 0x01	; 1
    14d2:	8c 91       	ld	r24, X
    14d4:	11 97       	sbiw	r26, 0x01	; 1
    14d6:	88 60       	ori	r24, 0x08	; 8
    14d8:	11 96       	adiw	r26, 0x01	; 1
    14da:	8c 93       	st	X, r24
    14dc:	ee 24       	eor	r14, r14
    14de:	ff 24       	eor	r15, r15
    14e0:	68 94       	set
    14e2:	f2 f8       	bld	r15, 2
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
    14e4:	44 24       	eor	r4, r4
    14e6:	55 24       	eor	r5, r5
    14e8:	32 01       	movw	r6, r4
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
    14ea:	20 e0       	ldi	r18, 0x00	; 0
    14ec:	30 e1       	ldi	r19, 0x10	; 16
    14ee:	40 e0       	ldi	r20, 0x00	; 0
    14f0:	50 e0       	ldi	r21, 0x00	; 0
    14f2:	2a 83       	std	Y+2, r18	; 0x02
    14f4:	3b 83       	std	Y+3, r19	; 0x03
    14f6:	4c 83       	std	Y+4, r20	; 0x04
    14f8:	5d 83       	std	Y+5, r21	; 0x05
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	
	uint32_t sum = 0;
    14fa:	88 24       	eor	r8, r8
    14fc:	99 24       	eor	r9, r9
    14fe:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
    1500:	00 e6       	ldi	r16, 0x60	; 96
    1502:	12 e0       	ldi	r17, 0x02	; 2
    1504:	d8 01       	movw	r26, r16
    1506:	13 96       	adiw	r26, 0x03	; 3
    1508:	8c 91       	ld	r24, X
    150a:	13 97       	sbiw	r26, 0x03	; 3
    150c:	80 ff       	sbrs	r24, 0
    150e:	fa cf       	rjmp	.-12     	; 0x1504 <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
    1510:	69 81       	ldd	r22, Y+1	; 0x01
    1512:	c8 01       	movw	r24, r16
    1514:	0e 94 3a 18 	call	0x3074	; 0x3074 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
    1518:	a0 e0       	ldi	r26, 0x00	; 0
    151a:	b0 e0       	ldi	r27, 0x00	; 0
    151c:	88 0e       	add	r8, r24
    151e:	99 1e       	adc	r9, r25
    1520:	aa 1e       	adc	r10, r26
    1522:	bb 1e       	adc	r11, r27
    1524:	48 16       	cp	r4, r24
    1526:	59 06       	cpc	r5, r25
    1528:	6a 06       	cpc	r6, r26
    152a:	7b 06       	cpc	r7, r27
    152c:	10 f4       	brcc	.+4      	; 0x1532 <CO_collectBatt+0x158>
    152e:	2c 01       	movw	r4, r24
    1530:	3d 01       	movw	r6, r26
    1532:	2a 81       	ldd	r18, Y+2	; 0x02
    1534:	3b 81       	ldd	r19, Y+3	; 0x03
    1536:	4c 81       	ldd	r20, Y+4	; 0x04
    1538:	5d 81       	ldd	r21, Y+5	; 0x05
    153a:	82 17       	cp	r24, r18
    153c:	93 07       	cpc	r25, r19
    153e:	a4 07       	cpc	r26, r20
    1540:	b5 07       	cpc	r27, r21
    1542:	20 f4       	brcc	.+8      	; 0x154c <CO_collectBatt+0x172>
    1544:	8a 83       	std	Y+2, r24	; 0x02
    1546:	9b 83       	std	Y+3, r25	; 0x03
    1548:	ac 83       	std	Y+4, r26	; 0x04
    154a:	bd 83       	std	Y+5, r27	; 0x05
    154c:	08 94       	sec
    154e:	e1 08       	sbc	r14, r1
    1550:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
    1552:	e1 14       	cp	r14, r1
    1554:	f1 04       	cpc	r15, r1
    1556:	b1 f6       	brne	.-84     	; 0x1504 <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
    1558:	e0 e4       	ldi	r30, 0x40	; 64
    155a:	f2 e0       	ldi	r31, 0x02	; 2
    155c:	81 81       	ldd	r24, Z+1	; 0x01
    155e:	87 7f       	andi	r24, 0xF7	; 247
    1560:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
    1562:	80 81       	ld	r24, Z
    1564:	8e 7f       	andi	r24, 0xFE	; 254
    1566:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
    1568:	84 e0       	ldi	r24, 0x04	; 4
    156a:	60 e0       	ldi	r22, 0x00	; 0
    156c:	0e 94 5e 06 	call	0xcbc	; 0xcbc <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
    1570:	80 e0       	ldi	r24, 0x00	; 0
    1572:	0e 94 0c 07 	call	0xe18	; 0xe18 <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
    1576:	c5 01       	movw	r24, r10
    1578:	b4 01       	movw	r22, r8
    157a:	05 2e       	mov	r0, r21
    157c:	5a e0       	ldi	r21, 0x0A	; 10
    157e:	96 95       	lsr	r25
    1580:	87 95       	ror	r24
    1582:	77 95       	ror	r23
    1584:	67 95       	ror	r22
    1586:	5a 95       	dec	r21
    1588:	d1 f7       	brne	.-12     	; 0x157e <CO_collectBatt+0x1a4>
    158a:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
    158c:	28 ee       	ldi	r18, 0xE8	; 232
    158e:	33 e0       	ldi	r19, 0x03	; 3
    1590:	40 e0       	ldi	r20, 0x00	; 0
    1592:	50 e0       	ldi	r21, 0x00	; 0
    1594:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    1598:	0f 2e       	mov	r0, r31
    159a:	ff ef       	ldi	r31, 0xFF	; 255
    159c:	8f 2e       	mov	r8, r31
    159e:	ff e0       	ldi	r31, 0x0F	; 15
    15a0:	9f 2e       	mov	r9, r31
    15a2:	f0 e0       	ldi	r31, 0x00	; 0
    15a4:	af 2e       	mov	r10, r31
    15a6:	f0 e0       	ldi	r31, 0x00	; 0
    15a8:	bf 2e       	mov	r11, r31
    15aa:	f0 2d       	mov	r31, r0
    15ac:	a5 01       	movw	r20, r10
    15ae:	94 01       	movw	r18, r8
    15b0:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    15b4:	c9 01       	movw	r24, r18
    15b6:	c2 97       	sbiw	r24, 0x32	; 50
    15b8:	ae 81       	ldd	r26, Y+6	; 0x06
    15ba:	bf 81       	ldd	r27, Y+7	; 0x07
    15bc:	8d 93       	st	X+, r24
    15be:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
    15c0:	c3 01       	movw	r24, r6
    15c2:	b2 01       	movw	r22, r4
    15c4:	28 ee       	ldi	r18, 0xE8	; 232
    15c6:	33 e0       	ldi	r19, 0x03	; 3
    15c8:	40 e0       	ldi	r20, 0x00	; 0
    15ca:	50 e0       	ldi	r21, 0x00	; 0
    15cc:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    15d0:	a5 01       	movw	r20, r10
    15d2:	94 01       	movw	r18, r8
    15d4:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    15d8:	c9 01       	movw	r24, r18
    15da:	c2 97       	sbiw	r24, 0x32	; 50
    15dc:	ea 85       	ldd	r30, Y+10	; 0x0a
    15de:	fb 85       	ldd	r31, Y+11	; 0x0b
    15e0:	80 83       	st	Z, r24
    15e2:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
    15e4:	6a 81       	ldd	r22, Y+2	; 0x02
    15e6:	7b 81       	ldd	r23, Y+3	; 0x03
    15e8:	8c 81       	ldd	r24, Y+4	; 0x04
    15ea:	9d 81       	ldd	r25, Y+5	; 0x05
    15ec:	28 ee       	ldi	r18, 0xE8	; 232
    15ee:	33 e0       	ldi	r19, 0x03	; 3
    15f0:	40 e0       	ldi	r20, 0x00	; 0
    15f2:	50 e0       	ldi	r21, 0x00	; 0
    15f4:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    15f8:	a5 01       	movw	r20, r10
    15fa:	94 01       	movw	r18, r8
    15fc:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    1600:	22 53       	subi	r18, 0x32	; 50
    1602:	30 40       	sbci	r19, 0x00	; 0
    1604:	a8 85       	ldd	r26, Y+8	; 0x08
    1606:	b9 85       	ldd	r27, Y+9	; 0x09
    1608:	2d 93       	st	X+, r18
    160a:	3c 93       	st	X, r19
    160c:	11 97       	sbiw	r26, 0x01	; 1
}
    160e:	2b 96       	adiw	r28, 0x0b	; 11
    1610:	cd bf       	out	0x3d, r28	; 61
    1612:	de bf       	out	0x3e, r29	; 62
    1614:	df 91       	pop	r29
    1616:	cf 91       	pop	r28
    1618:	1f 91       	pop	r17
    161a:	0f 91       	pop	r16
    161c:	ff 90       	pop	r15
    161e:	ef 90       	pop	r14
    1620:	bf 90       	pop	r11
    1622:	af 90       	pop	r10
    1624:	9f 90       	pop	r9
    1626:	8f 90       	pop	r8
    1628:	7f 90       	pop	r7
    162a:	6f 90       	pop	r6
    162c:	5f 90       	pop	r5
    162e:	4f 90       	pop	r4
    1630:	08 95       	ret

00001632 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
    1632:	cf 93       	push	r28
    1634:	c6 2f       	mov	r28, r22
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
    1636:	21 e0       	ldi	r18, 0x01	; 1
    1638:	30 e0       	ldi	r19, 0x00	; 0
    163a:	a9 01       	movw	r20, r18
    163c:	02 c0       	rjmp	.+4      	; 0x1642 <set_ampGain+0x10>
    163e:	44 0f       	add	r20, r20
    1640:	55 1f       	adc	r21, r21
    1642:	8a 95       	dec	r24
    1644:	e2 f7       	brpl	.-8      	; 0x163e <set_ampGain+0xc>
    1646:	ca 01       	movw	r24, r20
    1648:	61 e0       	ldi	r22, 0x01	; 1
    164a:	0e 94 b2 05 	call	0xb64	; 0xb64 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    164e:	c0 ff       	sbrs	r28, 0
    1650:	05 c0       	rjmp	.+10     	; 0x165c <set_ampGain+0x2a>
    1652:	80 e4       	ldi	r24, 0x40	; 64
    1654:	e0 e0       	ldi	r30, 0x00	; 0
    1656:	f6 e0       	ldi	r31, 0x06	; 6
    1658:	85 83       	std	Z+5, r24	; 0x05
    165a:	04 c0       	rjmp	.+8      	; 0x1664 <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
    165c:	80 e4       	ldi	r24, 0x40	; 64
    165e:	e0 e0       	ldi	r30, 0x00	; 0
    1660:	f6 e0       	ldi	r31, 0x06	; 6
    1662:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    1664:	c1 ff       	sbrs	r28, 1
    1666:	05 c0       	rjmp	.+10     	; 0x1672 <set_ampGain+0x40>
    1668:	82 e0       	ldi	r24, 0x02	; 2
    166a:	e0 e2       	ldi	r30, 0x20	; 32
    166c:	f6 e0       	ldi	r31, 0x06	; 6
    166e:	85 83       	std	Z+5, r24	; 0x05
    1670:	04 c0       	rjmp	.+8      	; 0x167a <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
    1672:	82 e0       	ldi	r24, 0x02	; 2
    1674:	e0 e2       	ldi	r30, 0x20	; 32
    1676:	f6 e0       	ldi	r31, 0x06	; 6
    1678:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    167a:	c2 ff       	sbrs	r28, 2
    167c:	05 c0       	rjmp	.+10     	; 0x1688 <set_ampGain+0x56>
    167e:	84 e0       	ldi	r24, 0x04	; 4
    1680:	e0 e2       	ldi	r30, 0x20	; 32
    1682:	f6 e0       	ldi	r31, 0x06	; 6
    1684:	85 83       	std	Z+5, r24	; 0x05
    1686:	04 c0       	rjmp	.+8      	; 0x1690 <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
    1688:	84 e0       	ldi	r24, 0x04	; 4
    168a:	e0 e2       	ldi	r30, 0x20	; 32
    168c:	f6 e0       	ldi	r31, 0x06	; 6
    168e:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1690:	5a e0       	ldi	r21, 0x0A	; 10
    1692:	5a 95       	dec	r21
    1694:	f1 f7       	brne	.-4      	; 0x1692 <set_ampGain+0x60>
    1696:	00 c0       	rjmp	.+0      	; 0x1698 <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    1698:	8f ef       	ldi	r24, 0xFF	; 255
    169a:	61 e0       	ldi	r22, 0x01	; 1
    169c:	0e 94 09 06 	call	0xc12	; 0xc12 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    16a0:	cf 91       	pop	r28
    16a2:	08 95       	ret

000016a4 <enableADCMUX>:

void enableADCMUX(uint8_t on) {
	
	if(on) {
    16a4:	88 23       	and	r24, r24
    16a6:	31 f0       	breq	.+12     	; 0x16b4 <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
    16a8:	e0 e0       	ldi	r30, 0x00	; 0
    16aa:	f6 e0       	ldi	r31, 0x06	; 6
    16ac:	80 e2       	ldi	r24, 0x20	; 32
    16ae:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
    16b0:	85 83       	std	Z+5, r24	; 0x05
    16b2:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
    16b4:	e0 e0       	ldi	r30, 0x00	; 0
    16b6:	f6 e0       	ldi	r31, 0x06	; 6
    16b8:	80 e2       	ldi	r24, 0x20	; 32
    16ba:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    16bc:	82 83       	std	Z+2, r24	; 0x02
    16be:	08 95       	ret

000016c0 <__vector_20>:
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//triggers when specified number of samples has been collected by ADC
ISR(TCC1_OVF_vect){
    16c0:	1f 92       	push	r1
    16c2:	0f 92       	push	r0
    16c4:	0f b6       	in	r0, 0x3f	; 63
    16c6:	0f 92       	push	r0
    16c8:	0b b6       	in	r0, 0x3b	; 59
    16ca:	0f 92       	push	r0
    16cc:	11 24       	eor	r1, r1
    16ce:	2f 93       	push	r18
    16d0:	3f 93       	push	r19
    16d2:	4f 93       	push	r20
    16d4:	5f 93       	push	r21
    16d6:	6f 93       	push	r22
    16d8:	7f 93       	push	r23
    16da:	8f 93       	push	r24
    16dc:	9f 93       	push	r25
    16de:	af 93       	push	r26
    16e0:	bf 93       	push	r27
    16e2:	ef 93       	push	r30
    16e4:	ff 93       	push	r31

	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    16e6:	e0 e4       	ldi	r30, 0x40	; 64
    16e8:	fa e0       	ldi	r31, 0x0A	; 10
    16ea:	80 81       	ld	r24, Z
    16ec:	80 7f       	andi	r24, 0xF0	; 240
    16ee:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    16f0:	a0 e0       	ldi	r26, 0x00	; 0
    16f2:	b8 e0       	ldi	r27, 0x08	; 8
    16f4:	8c 91       	ld	r24, X
    16f6:	80 7f       	andi	r24, 0xF0	; 240
    16f8:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    16fa:	a0 e0       	ldi	r26, 0x00	; 0
    16fc:	b9 e0       	ldi	r27, 0x09	; 9
    16fe:	8c 91       	ld	r24, X
    1700:	80 7f       	andi	r24, 0xF0	; 240
    1702:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1704:	80 81       	ld	r24, Z
    1706:	80 7f       	andi	r24, 0xF0	; 240
    1708:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    170c:	80 e0       	ldi	r24, 0x00	; 0
    170e:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	SPIDisable();
    1712:	0e 94 45 05 	call	0xa8a	; 0xa8a <SPIDisable>
	enableADCMUX(FALSE);
    1716:	80 e0       	ldi	r24, 0x00	; 0
    1718:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <enableADCMUX>
	
	//set a global flag to tell system that all the samples have been collected
	ADC_Sampling_Finished = 1;
    171c:	81 e0       	ldi	r24, 0x01	; 1
    171e:	80 93 ab 50 	sts	0x50AB, r24
	DataAvailable = 1;
    1722:	80 93 4c 3e 	sts	0x3E4C, r24
}
    1726:	ff 91       	pop	r31
    1728:	ef 91       	pop	r30
    172a:	bf 91       	pop	r27
    172c:	af 91       	pop	r26
    172e:	9f 91       	pop	r25
    1730:	8f 91       	pop	r24
    1732:	7f 91       	pop	r23
    1734:	6f 91       	pop	r22
    1736:	5f 91       	pop	r21
    1738:	4f 91       	pop	r20
    173a:	3f 91       	pop	r19
    173c:	2f 91       	pop	r18
    173e:	0f 90       	pop	r0
    1740:	0b be       	out	0x3b, r0	; 59
    1742:	0f 90       	pop	r0
    1744:	0f be       	out	0x3f, r0	; 63
    1746:	0f 90       	pop	r0
    1748:	1f 90       	pop	r1
    174a:	18 95       	reti

0000174c <ADC_Stop_Sampling>:

//turns off ADC timers/counters and spi bus 
void ADC_Stop_Sampling(){
	
	// turn off ADC timer(s)
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    174c:	e0 e4       	ldi	r30, 0x40	; 64
    174e:	fa e0       	ldi	r31, 0x0A	; 10
    1750:	80 81       	ld	r24, Z
    1752:	80 7f       	andi	r24, 0xF0	; 240
    1754:	80 83       	st	Z, r24
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1756:	a0 e0       	ldi	r26, 0x00	; 0
    1758:	b8 e0       	ldi	r27, 0x08	; 8
    175a:	8c 91       	ld	r24, X
    175c:	80 7f       	andi	r24, 0xF0	; 240
    175e:	8c 93       	st	X, r24
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1760:	a0 e0       	ldi	r26, 0x00	; 0
    1762:	b9 e0       	ldi	r27, 0x09	; 9
    1764:	8c 91       	ld	r24, X
    1766:	80 7f       	andi	r24, 0xF0	; 240
    1768:	8c 93       	st	X, r24
	TCC1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    176a:	80 81       	ld	r24, Z
    176c:	80 7f       	andi	r24, 0xF0	; 240
    176e:	80 93 40 08 	sts	0x0840, r24

	//turn off SPI bus and ADC MUX used by ADC
	SPICS(FALSE);
    1772:	80 e0       	ldi	r24, 0x00	; 0
    1774:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	SPIDisable();
    1778:	0e 94 45 05 	call	0xa8a	; 0xa8a <SPIDisable>
	enableADCMUX(FALSE);
    177c:	80 e0       	ldi	r24, 0x00	; 0
    177e:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <enableADCMUX>
	ADC_Sampling_Finished = 1;
    1782:	81 e0       	ldi	r24, 0x01	; 1
    1784:	80 93 ab 50 	sts	0x50AB, r24
	DataAvailable = 1;
    1788:	80 93 4c 3e 	sts	0x3E4C, r24
}
    178c:	08 95       	ret

0000178e <ADC_Get_Num_Samples>:

//returns number of samples collected by last ADC sampling time
uint16_t ADC_Get_Num_Samples(){
    178e:	cf 93       	push	r28
    1790:	df 93       	push	r29
    1792:	0f 92       	push	r0
    1794:	0f 92       	push	r0
    1796:	cd b7       	in	r28, 0x3d	; 61
    1798:	de b7       	in	r29, 0x3e	; 62
	
	if(ADC_Sampling_Finished){
    179a:	80 91 ab 50 	lds	r24, 0x50AB
    179e:	88 23       	and	r24, r24
    17a0:	89 f0       	breq	.+34     	; 0x17c4 <ADC_Get_Num_Samples+0x36>
		volatile uint16_t count;
		count = TCC1.CNT;
    17a2:	e0 e4       	ldi	r30, 0x40	; 64
    17a4:	f8 e0       	ldi	r31, 0x08	; 8
    17a6:	80 a1       	lds	r24, 0x40
    17a8:	91 a1       	lds	r25, 0x41
    17aa:	89 83       	std	Y+1, r24	; 0x01
    17ac:	9a 83       	std	Y+2, r25	; 0x02
		if(count == 0) count = TCC1.PER;
    17ae:	89 81       	ldd	r24, Y+1	; 0x01
    17b0:	9a 81       	ldd	r25, Y+2	; 0x02
    17b2:	00 97       	sbiw	r24, 0x00	; 0
    17b4:	21 f4       	brne	.+8      	; 0x17be <ADC_Get_Num_Samples+0x30>
    17b6:	86 a1       	lds	r24, 0x46
    17b8:	97 a1       	lds	r25, 0x47
    17ba:	89 83       	std	Y+1, r24	; 0x01
    17bc:	9a 83       	std	Y+2, r25	; 0x02
		return count;
    17be:	89 81       	ldd	r24, Y+1	; 0x01
    17c0:	9a 81       	ldd	r25, Y+2	; 0x02
    17c2:	02 c0       	rjmp	.+4      	; 0x17c8 <ADC_Get_Num_Samples+0x3a>
	}
	else return 0;		
    17c4:	80 e0       	ldi	r24, 0x00	; 0
    17c6:	90 e0       	ldi	r25, 0x00	; 0
}
    17c8:	0f 90       	pop	r0
    17ca:	0f 90       	pop	r0
    17cc:	df 91       	pop	r29
    17ce:	cf 91       	pop	r28
    17d0:	08 95       	ret

000017d2 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    17d2:	e0 ea       	ldi	r30, 0xA0	; 160
    17d4:	f6 e0       	ldi	r31, 0x06	; 6
    17d6:	13 86       	std	Z+11, r1	; 0x0b
}
    17d8:	08 95       	ret

000017da <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    17da:	81 e0       	ldi	r24, 0x01	; 1
    17dc:	e0 ea       	ldi	r30, 0xA0	; 160
    17de:	f6 e0       	ldi	r31, 0x06	; 6
    17e0:	83 87       	std	Z+11, r24	; 0x0b
}	
    17e2:	08 95       	ret

000017e4 <__vector_104>:
// 	}	
// 	}	
// }

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    17e4:	1f 92       	push	r1
    17e6:	0f 92       	push	r0
    17e8:	0f b6       	in	r0, 0x3f	; 63
    17ea:	0f 92       	push	r0
    17ec:	0b b6       	in	r0, 0x3b	; 59
    17ee:	0f 92       	push	r0
    17f0:	11 24       	eor	r1, r1
    17f2:	6f 92       	push	r6
    17f4:	7f 92       	push	r7
    17f6:	8f 92       	push	r8
    17f8:	9f 92       	push	r9
    17fa:	af 92       	push	r10
    17fc:	bf 92       	push	r11
    17fe:	cf 92       	push	r12
    1800:	df 92       	push	r13
    1802:	ef 92       	push	r14
    1804:	ff 92       	push	r15
    1806:	0f 93       	push	r16
    1808:	1f 93       	push	r17
    180a:	2f 93       	push	r18
    180c:	3f 93       	push	r19
    180e:	4f 93       	push	r20
    1810:	5f 93       	push	r21
    1812:	6f 93       	push	r22
    1814:	7f 93       	push	r23
    1816:	8f 93       	push	r24
    1818:	9f 93       	push	r25
    181a:	af 93       	push	r26
    181c:	bf 93       	push	r27
    181e:	ef 93       	push	r30
    1820:	ff 93       	push	r31
    1822:	cf 93       	push	r28
    1824:	df 93       	push	r29
    1826:	cd b7       	in	r28, 0x3d	; 61
    1828:	de b7       	in	r29, 0x3e	; 62
    182a:	2c 97       	sbiw	r28, 0x0c	; 12
    182c:	cd bf       	out	0x3d, r28	; 61
    182e:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	volatile int64_t var;
	if (discardCount < ADC_DISCARD) {
    1830:	80 91 61 40 	lds	r24, 0x4061
    1834:	88 23       	and	r24, r24
    1836:	8c f0       	brlt	.+34     	; 0x185a <__vector_104+0x76>
		discardCount++;
    1838:	80 91 61 40 	lds	r24, 0x4061
    183c:	8f 5f       	subi	r24, 0xFF	; 255
    183e:	80 93 61 40 	sts	0x4061, r24
		if(discardCount == ADC_DISCARD){
    1842:	80 91 61 40 	lds	r24, 0x4061
    1846:	80 38       	cpi	r24, 0x80	; 128
    1848:	09 f0       	breq	.+2      	; 0x184c <__vector_104+0x68>
    184a:	e9 c0       	rjmp	.+466    	; 0x1a1e <__vector_104+0x23a>
			//set event system to update counter of number of samples every sample event from now on
			TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    184c:	e0 e4       	ldi	r30, 0x40	; 64
    184e:	f8 e0       	ldi	r31, 0x08	; 8
    1850:	80 81       	ld	r24, Z
    1852:	80 7f       	andi	r24, 0xF0	; 240
    1854:	89 60       	ori	r24, 0x09	; 9
    1856:	80 83       	st	Z, r24
    1858:	e2 c0       	rjmp	.+452    	; 0x1a1e <__vector_104+0x23a>
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    185a:	81 e0       	ldi	r24, 0x01	; 1
    185c:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1860:	82 e0       	ldi	r24, 0x02	; 2
    1862:	e0 ea       	ldi	r30, 0xA0	; 160
    1864:	f6 e0       	ldi	r31, 0x06	; 6
    1866:	86 83       	std	Z+6, r24	; 0x06
    1868:	80 e0       	ldi	r24, 0x00	; 0
    186a:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    186c:	e0 ec       	ldi	r30, 0xC0	; 192
    186e:	f8 e0       	ldi	r31, 0x08	; 8
    1870:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
    1872:	25 e2       	ldi	r18, 0x25	; 37
    1874:	3e e3       	ldi	r19, 0x3E	; 62
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1876:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1878:	42 81       	ldd	r20, Z+2	; 0x02
    187a:	44 23       	and	r20, r20
    187c:	ec f7       	brge	.-6      	; 0x1878 <__vector_104+0x94>
			SPIBuffer[bufIndex] = SPIC.DATA;
    187e:	43 81       	ldd	r20, Z+3	; 0x03
    1880:	d9 01       	movw	r26, r18
    1882:	a8 0f       	add	r26, r24
    1884:	b9 1f       	adc	r27, r25
    1886:	4c 93       	st	X, r20
    1888:	01 96       	adiw	r24, 0x01	; 1
		}
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    188a:	83 30       	cpi	r24, 0x03	; 3
    188c:	91 05       	cpc	r25, r1
    188e:	99 f7       	brne	.-26     	; 0x1876 <__vector_104+0x92>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1890:	82 e0       	ldi	r24, 0x02	; 2
    1892:	e0 ea       	ldi	r30, 0xA0	; 160
    1894:	f6 e0       	ldi	r31, 0x06	; 6
    1896:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
    1898:	80 e0       	ldi	r24, 0x00	; 0
    189a:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    189e:	80 91 25 3e 	lds	r24, 0x3E25
    18a2:	88 23       	and	r24, r24
    18a4:	1c f4       	brge	.+6      	; 0x18ac <__vector_104+0xc8>
    18a6:	8f ef       	ldi	r24, 0xFF	; 255
    18a8:	8c 83       	std	Y+4, r24	; 0x04
    18aa:	01 c0       	rjmp	.+2      	; 0x18ae <__vector_104+0xca>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    18ac:	1c 82       	std	Y+4, r1	; 0x04
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    18ae:	80 91 25 3e 	lds	r24, 0x3E25
    18b2:	8b 83       	std	Y+3, r24	; 0x03
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    18b4:	80 91 26 3e 	lds	r24, 0x3E26
    18b8:	8a 83       	std	Y+2, r24	; 0x02
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    18ba:	80 91 27 3e 	lds	r24, 0x3E27
    18be:	89 83       	std	Y+1, r24	; 0x01
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    18c0:	89 81       	ldd	r24, Y+1	; 0x01
    18c2:	9a 81       	ldd	r25, Y+2	; 0x02
    18c4:	ab 81       	ldd	r26, Y+3	; 0x03
    18c6:	bc 81       	ldd	r27, Y+4	; 0x04
    18c8:	ac 01       	movw	r20, r24
    18ca:	bd 01       	movw	r22, r26
    18cc:	77 0f       	add	r23, r23
    18ce:	44 0b       	sbc	r20, r20
    18d0:	54 2f       	mov	r21, r20
    18d2:	ba 01       	movw	r22, r20
    18d4:	8d 83       	std	Y+5, r24	; 0x05
    18d6:	9e 83       	std	Y+6, r25	; 0x06
    18d8:	af 83       	std	Y+7, r26	; 0x07
    18da:	b8 87       	std	Y+8, r27	; 0x08
    18dc:	49 87       	std	Y+9, r20	; 0x09
    18de:	4a 87       	std	Y+10, r20	; 0x0a
    18e0:	4b 87       	std	Y+11, r20	; 0x0b
    18e2:	4c 87       	std	Y+12, r20	; 0x0c
		ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    18e4:	60 91 6a 50 	lds	r22, 0x506A
    18e8:	70 91 6b 50 	lds	r23, 0x506B
    18ec:	80 91 6c 50 	lds	r24, 0x506C
    18f0:	90 91 6d 50 	lds	r25, 0x506D
    18f4:	8d 80       	ldd	r8, Y+5	; 0x05
    18f6:	1e 81       	ldd	r17, Y+6	; 0x06
    18f8:	0f 81       	ldd	r16, Y+7	; 0x07
    18fa:	f8 84       	ldd	r15, Y+8	; 0x08
    18fc:	e9 84       	ldd	r14, Y+9	; 0x09
    18fe:	da 84       	ldd	r13, Y+10	; 0x0a
    1900:	cb 84       	ldd	r12, Y+11	; 0x0b
    1902:	bc 84       	ldd	r11, Y+12	; 0x0c
    1904:	20 91 ac 50 	lds	r18, 0x50AC
    1908:	30 91 ad 50 	lds	r19, 0x50AD
    190c:	40 e0       	ldi	r20, 0x00	; 0
    190e:	50 e0       	ldi	r21, 0x00	; 0
    1910:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    1914:	66 0f       	add	r22, r22
    1916:	77 1f       	adc	r23, r23
    1918:	66 0f       	add	r22, r22
    191a:	77 1f       	adc	r23, r23
    191c:	80 91 68 50 	lds	r24, 0x5068
    1920:	90 91 69 50 	lds	r25, 0x5069
    1924:	3c 01       	movw	r6, r24
    1926:	66 0e       	add	r6, r22
    1928:	77 1e       	adc	r7, r23
    192a:	28 2d       	mov	r18, r8
    192c:	31 2f       	mov	r19, r17
    192e:	40 2f       	mov	r20, r16
    1930:	5f 2d       	mov	r21, r15
    1932:	6e 2d       	mov	r22, r14
    1934:	7d 2d       	mov	r23, r13
    1936:	8c 2d       	mov	r24, r12
    1938:	9b 2d       	mov	r25, r11
    193a:	0f 2e       	mov	r0, r31
    193c:	f0 ea       	ldi	r31, 0xA0	; 160
    193e:	af 2e       	mov	r10, r31
    1940:	f0 2d       	mov	r31, r0
    1942:	0f 2e       	mov	r0, r31
    1944:	f5 e2       	ldi	r31, 0x25	; 37
    1946:	bf 2e       	mov	r11, r31
    1948:	f0 2d       	mov	r31, r0
    194a:	0f 2e       	mov	r0, r31
    194c:	f6 e2       	ldi	r31, 0x26	; 38
    194e:	cf 2e       	mov	r12, r31
    1950:	f0 2d       	mov	r31, r0
    1952:	dd 24       	eor	r13, r13
    1954:	ee 24       	eor	r14, r14
    1956:	ff 24       	eor	r15, r15
    1958:	00 e0       	ldi	r16, 0x00	; 0
    195a:	10 e0       	ldi	r17, 0x00	; 0
    195c:	0e 94 0a 2d 	call	0x5a14	; 0x5a14 <__muldi3>
    1960:	aa 24       	eor	r10, r10
    1962:	aa 94       	dec	r10
    1964:	bb 24       	eor	r11, r11
    1966:	ba 94       	dec	r11
    1968:	0f 2e       	mov	r0, r31
    196a:	ff e7       	ldi	r31, 0x7F	; 127
    196c:	cf 2e       	mov	r12, r31
    196e:	f0 2d       	mov	r31, r0
    1970:	0e 94 b9 2e 	call	0x5d72	; 0x5d72 <__divdi3>
    1974:	01 e0       	ldi	r16, 0x01	; 1
    1976:	0e 94 dd 2d 	call	0x5bba	; 0x5bba <__ashldi3>
    197a:	0f 2e       	mov	r0, r31
    197c:	f3 e0       	ldi	r31, 0x03	; 3
    197e:	af 2e       	mov	r10, r31
    1980:	f0 2d       	mov	r31, r0
    1982:	bb 24       	eor	r11, r11
    1984:	cc 24       	eor	r12, r12
    1986:	00 e0       	ldi	r16, 0x00	; 0
    1988:	0e 94 b9 2e 	call	0x5d72	; 0x5d72 <__divdi3>
    198c:	82 2e       	mov	r8, r18
    198e:	93 2e       	mov	r9, r19
    1990:	a4 2e       	mov	r10, r20
    1992:	b5 2e       	mov	r11, r21
    1994:	b0 94       	com	r11
    1996:	a0 94       	com	r10
    1998:	90 94       	com	r9
    199a:	80 94       	com	r8
    199c:	81 1c       	adc	r8, r1
    199e:	91 1c       	adc	r9, r1
    19a0:	a1 1c       	adc	r10, r1
    19a2:	b1 1c       	adc	r11, r1
    19a4:	f3 01       	movw	r30, r6
    19a6:	80 82       	st	Z, r8
    19a8:	91 82       	std	Z+1, r9	; 0x01
    19aa:	a2 82       	std	Z+2, r10	; 0x02
    19ac:	b3 82       	std	Z+3, r11	; 0x03
		if(write_to_FRAM){
    19ae:	80 91 4d 40 	lds	r24, 0x404D
    19b2:	88 23       	and	r24, r24
    19b4:	09 f1       	breq	.+66     	; 0x19f8 <__vector_104+0x214>
			writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    19b6:	60 91 6a 50 	lds	r22, 0x506A
    19ba:	70 91 6b 50 	lds	r23, 0x506B
    19be:	80 91 6c 50 	lds	r24, 0x506C
    19c2:	90 91 6d 50 	lds	r25, 0x506D
    19c6:	20 91 ac 50 	lds	r18, 0x50AC
    19ca:	30 91 ad 50 	lds	r19, 0x50AD
    19ce:	40 e0       	ldi	r20, 0x00	; 0
    19d0:	50 e0       	ldi	r21, 0x00	; 0
    19d2:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    19d6:	dc 01       	movw	r26, r24
    19d8:	cb 01       	movw	r24, r22
    19da:	9c 01       	movw	r18, r24
    19dc:	22 0f       	add	r18, r18
    19de:	33 1f       	adc	r19, r19
    19e0:	22 0f       	add	r18, r18
    19e2:	33 1f       	adc	r19, r19
    19e4:	80 91 68 50 	lds	r24, 0x5068
    19e8:	90 91 69 50 	lds	r25, 0x5069
    19ec:	82 0f       	add	r24, r18
    19ee:	93 1f       	adc	r25, r19
    19f0:	64 e0       	ldi	r22, 0x04	; 4
    19f2:	70 e0       	ldi	r23, 0x00	; 0
    19f4:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
		}
		sampleCount++;
    19f8:	80 91 6a 50 	lds	r24, 0x506A
    19fc:	90 91 6b 50 	lds	r25, 0x506B
    1a00:	a0 91 6c 50 	lds	r26, 0x506C
    1a04:	b0 91 6d 50 	lds	r27, 0x506D
    1a08:	01 96       	adiw	r24, 0x01	; 1
    1a0a:	a1 1d       	adc	r26, r1
    1a0c:	b1 1d       	adc	r27, r1
    1a0e:	80 93 6a 50 	sts	0x506A, r24
    1a12:	90 93 6b 50 	sts	0x506B, r25
    1a16:	a0 93 6c 50 	sts	0x506C, r26
    1a1a:	b0 93 6d 50 	sts	0x506D, r27
	}
}
    1a1e:	2c 96       	adiw	r28, 0x0c	; 12
    1a20:	cd bf       	out	0x3d, r28	; 61
    1a22:	de bf       	out	0x3e, r29	; 62
    1a24:	df 91       	pop	r29
    1a26:	cf 91       	pop	r28
    1a28:	ff 91       	pop	r31
    1a2a:	ef 91       	pop	r30
    1a2c:	bf 91       	pop	r27
    1a2e:	af 91       	pop	r26
    1a30:	9f 91       	pop	r25
    1a32:	8f 91       	pop	r24
    1a34:	7f 91       	pop	r23
    1a36:	6f 91       	pop	r22
    1a38:	5f 91       	pop	r21
    1a3a:	4f 91       	pop	r20
    1a3c:	3f 91       	pop	r19
    1a3e:	2f 91       	pop	r18
    1a40:	1f 91       	pop	r17
    1a42:	0f 91       	pop	r16
    1a44:	ff 90       	pop	r15
    1a46:	ef 90       	pop	r14
    1a48:	df 90       	pop	r13
    1a4a:	cf 90       	pop	r12
    1a4c:	bf 90       	pop	r11
    1a4e:	af 90       	pop	r10
    1a50:	9f 90       	pop	r9
    1a52:	8f 90       	pop	r8
    1a54:	7f 90       	pop	r7
    1a56:	6f 90       	pop	r6
    1a58:	0f 90       	pop	r0
    1a5a:	0b be       	out	0x3b, r0	; 59
    1a5c:	0f 90       	pop	r0
    1a5e:	0f be       	out	0x3f, r0	; 63
    1a60:	0f 90       	pop	r0
    1a62:	1f 90       	pop	r1
    1a64:	18 95       	reti

00001a66 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
    1a66:	88 23       	and	r24, r24
    1a68:	49 f0       	breq	.+18     	; 0x1a7c <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1a6a:	80 e2       	ldi	r24, 0x20	; 32
    1a6c:	60 e0       	ldi	r22, 0x00	; 0
    1a6e:	0e 94 b6 06 	call	0xd6c	; 0xd6c <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1a72:	80 e2       	ldi	r24, 0x20	; 32
    1a74:	60 e0       	ldi	r22, 0x00	; 0
    1a76:	0e 94 09 06 	call	0xc12	; 0xc12 <PortEx_OUTSET>
    1a7a:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1a7c:	80 e2       	ldi	r24, 0x20	; 32
    1a7e:	60 e0       	ldi	r22, 0x00	; 0
    1a80:	0e 94 5e 06 	call	0xcbc	; 0xcbc <PortEx_DIRCLR>
    1a84:	08 95       	ret

00001a86 <__vector_14>:
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1a86:	1f 92       	push	r1
    1a88:	0f 92       	push	r0
    1a8a:	0f b6       	in	r0, 0x3f	; 63
    1a8c:	0f 92       	push	r0
    1a8e:	0b b6       	in	r0, 0x3b	; 59
    1a90:	0f 92       	push	r0
    1a92:	11 24       	eor	r1, r1
    1a94:	6f 92       	push	r6
    1a96:	7f 92       	push	r7
    1a98:	8f 92       	push	r8
    1a9a:	9f 92       	push	r9
    1a9c:	af 92       	push	r10
    1a9e:	bf 92       	push	r11
    1aa0:	cf 92       	push	r12
    1aa2:	df 92       	push	r13
    1aa4:	ef 92       	push	r14
    1aa6:	ff 92       	push	r15
    1aa8:	0f 93       	push	r16
    1aaa:	1f 93       	push	r17
    1aac:	2f 93       	push	r18
    1aae:	3f 93       	push	r19
    1ab0:	4f 93       	push	r20
    1ab2:	5f 93       	push	r21
    1ab4:	6f 93       	push	r22
    1ab6:	7f 93       	push	r23
    1ab8:	8f 93       	push	r24
    1aba:	9f 93       	push	r25
    1abc:	af 93       	push	r26
    1abe:	bf 93       	push	r27
    1ac0:	ef 93       	push	r30
    1ac2:	ff 93       	push	r31
    1ac4:	cf 93       	push	r28
    1ac6:	df 93       	push	r29
    1ac8:	cd b7       	in	r28, 0x3d	; 61
    1aca:	de b7       	in	r29, 0x3e	; 62
    1acc:	2c 97       	sbiw	r28, 0x0c	; 12
    1ace:	cd bf       	out	0x3d, r28	; 61
    1ad0:	de bf       	out	0x3e, r29	; 62
	volatile int64_t sum = 0;
    1ad2:	19 82       	std	Y+1, r1	; 0x01
    1ad4:	1a 82       	std	Y+2, r1	; 0x02
    1ad6:	1b 82       	std	Y+3, r1	; 0x03
    1ad8:	1c 82       	std	Y+4, r1	; 0x04
    1ada:	1d 82       	std	Y+5, r1	; 0x05
    1adc:	1e 82       	std	Y+6, r1	; 0x06
    1ade:	1f 82       	std	Y+7, r1	; 0x07
    1ae0:	18 86       	std	Y+8, r1	; 0x08
    1ae2:	80 e0       	ldi	r24, 0x00	; 0
    1ae4:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1ae6:	25 e2       	ldi	r18, 0x25	; 37
    1ae8:	3e e3       	ldi	r19, 0x3E	; 62
    1aea:	88 24       	eor	r8, r8
    1aec:	8a 94       	dec	r8
    1aee:	ac 01       	movw	r20, r24
    1af0:	f9 01       	movw	r30, r18
    1af2:	e8 0f       	add	r30, r24
    1af4:	f9 1f       	adc	r31, r25
    1af6:	60 81       	ld	r22, Z
    1af8:	66 23       	and	r22, r22
    1afa:	14 f4       	brge	.+4      	; 0x1b00 <__vector_14+0x7a>
    1afc:	8c 86       	std	Y+12, r8	; 0x0c
    1afe:	01 c0       	rjmp	.+2      	; 0x1b02 <__vector_14+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1b00:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1b02:	42 0f       	add	r20, r18
    1b04:	53 1f       	adc	r21, r19
    1b06:	fa 01       	movw	r30, r20
    1b08:	40 81       	ld	r20, Z
    1b0a:	4b 87       	std	Y+11, r20	; 0x0b
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1b0c:	fc 01       	movw	r30, r24
    1b0e:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1b10:	e2 0f       	add	r30, r18
    1b12:	f3 1f       	adc	r31, r19
    1b14:	40 81       	ld	r20, Z
    1b16:	4a 87       	std	Y+10, r20	; 0x0a
	}
	
}

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    1b18:	fc 01       	movw	r30, r24
    1b1a:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1b1c:	e2 0f       	add	r30, r18
    1b1e:	f3 1f       	adc	r31, r19
    1b20:	40 81       	ld	r20, Z
    1b22:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    1b24:	49 85       	ldd	r20, Y+9	; 0x09
    1b26:	5a 85       	ldd	r21, Y+10	; 0x0a
    1b28:	6b 85       	ldd	r22, Y+11	; 0x0b
    1b2a:	7c 85       	ldd	r23, Y+12	; 0x0c
    1b2c:	a9 80       	ldd	r10, Y+1	; 0x01
    1b2e:	ba 80       	ldd	r11, Y+2	; 0x02
    1b30:	cb 80       	ldd	r12, Y+3	; 0x03
    1b32:	dc 80       	ldd	r13, Y+4	; 0x04
    1b34:	ed 80       	ldd	r14, Y+5	; 0x05
    1b36:	fe 80       	ldd	r15, Y+6	; 0x06
    1b38:	0f 81       	ldd	r16, Y+7	; 0x07
    1b3a:	18 85       	ldd	r17, Y+8	; 0x08
    1b3c:	b4 2f       	mov	r27, r20
    1b3e:	a5 2f       	mov	r26, r21
    1b40:	f6 2f       	mov	r31, r22
    1b42:	e7 2f       	mov	r30, r23
    1b44:	77 0f       	add	r23, r23
    1b46:	44 0b       	sbc	r20, r20
    1b48:	54 2f       	mov	r21, r20
    1b4a:	ba 01       	movw	r22, r20
    1b4c:	64 2e       	mov	r6, r20
    1b4e:	74 2e       	mov	r7, r20
    1b50:	94 2e       	mov	r9, r20
    1b52:	ab 0e       	add	r10, r27
    1b54:	61 e0       	ldi	r22, 0x01	; 1
    1b56:	ab 16       	cp	r10, r27
    1b58:	08 f0       	brcs	.+2      	; 0x1b5c <__vector_14+0xd6>
    1b5a:	60 e0       	ldi	r22, 0x00	; 0
    1b5c:	ba 0e       	add	r11, r26
    1b5e:	51 e0       	ldi	r21, 0x01	; 1
    1b60:	ba 16       	cp	r11, r26
    1b62:	08 f0       	brcs	.+2      	; 0x1b66 <__vector_14+0xe0>
    1b64:	50 e0       	ldi	r21, 0x00	; 0
    1b66:	a6 2f       	mov	r26, r22
    1b68:	ab 0d       	add	r26, r11
    1b6a:	61 e0       	ldi	r22, 0x01	; 1
    1b6c:	ab 15       	cp	r26, r11
    1b6e:	08 f0       	brcs	.+2      	; 0x1b72 <__vector_14+0xec>
    1b70:	60 e0       	ldi	r22, 0x00	; 0
    1b72:	56 2b       	or	r21, r22
    1b74:	cf 0e       	add	r12, r31
    1b76:	61 e0       	ldi	r22, 0x01	; 1
    1b78:	cf 16       	cp	r12, r31
    1b7a:	08 f0       	brcs	.+2      	; 0x1b7e <__vector_14+0xf8>
    1b7c:	60 e0       	ldi	r22, 0x00	; 0
    1b7e:	f5 2f       	mov	r31, r21
    1b80:	fc 0d       	add	r31, r12
    1b82:	51 e0       	ldi	r21, 0x01	; 1
    1b84:	fc 15       	cp	r31, r12
    1b86:	08 f0       	brcs	.+2      	; 0x1b8a <__vector_14+0x104>
    1b88:	50 e0       	ldi	r21, 0x00	; 0
    1b8a:	65 2b       	or	r22, r21
    1b8c:	de 0e       	add	r13, r30
    1b8e:	51 e0       	ldi	r21, 0x01	; 1
    1b90:	de 16       	cp	r13, r30
    1b92:	08 f0       	brcs	.+2      	; 0x1b96 <__vector_14+0x110>
    1b94:	50 e0       	ldi	r21, 0x00	; 0
    1b96:	e6 2f       	mov	r30, r22
    1b98:	ed 0d       	add	r30, r13
    1b9a:	61 e0       	ldi	r22, 0x01	; 1
    1b9c:	ed 15       	cp	r30, r13
    1b9e:	08 f0       	brcs	.+2      	; 0x1ba2 <__vector_14+0x11c>
    1ba0:	60 e0       	ldi	r22, 0x00	; 0
    1ba2:	56 2b       	or	r21, r22
    1ba4:	e6 0c       	add	r14, r6
    1ba6:	71 e0       	ldi	r23, 0x01	; 1
    1ba8:	e6 14       	cp	r14, r6
    1baa:	08 f0       	brcs	.+2      	; 0x1bae <__vector_14+0x128>
    1bac:	70 e0       	ldi	r23, 0x00	; 0
    1bae:	b5 2f       	mov	r27, r21
    1bb0:	be 0d       	add	r27, r14
    1bb2:	51 e0       	ldi	r21, 0x01	; 1
    1bb4:	be 15       	cp	r27, r14
    1bb6:	08 f0       	brcs	.+2      	; 0x1bba <__vector_14+0x134>
    1bb8:	50 e0       	ldi	r21, 0x00	; 0
    1bba:	75 2b       	or	r23, r21
    1bbc:	f7 0c       	add	r15, r7
    1bbe:	61 e0       	ldi	r22, 0x01	; 1
    1bc0:	f7 14       	cp	r15, r7
    1bc2:	08 f0       	brcs	.+2      	; 0x1bc6 <__vector_14+0x140>
    1bc4:	60 e0       	ldi	r22, 0x00	; 0
    1bc6:	7f 0d       	add	r23, r15
    1bc8:	51 e0       	ldi	r21, 0x01	; 1
    1bca:	7f 15       	cp	r23, r15
    1bcc:	08 f0       	brcs	.+2      	; 0x1bd0 <__vector_14+0x14a>
    1bce:	50 e0       	ldi	r21, 0x00	; 0
    1bd0:	65 2b       	or	r22, r21
    1bd2:	09 0d       	add	r16, r9
    1bd4:	51 e0       	ldi	r21, 0x01	; 1
    1bd6:	09 15       	cp	r16, r9
    1bd8:	08 f0       	brcs	.+2      	; 0x1bdc <__vector_14+0x156>
    1bda:	50 e0       	ldi	r21, 0x00	; 0
    1bdc:	60 0f       	add	r22, r16
    1bde:	ff 24       	eor	r15, r15
    1be0:	f3 94       	inc	r15
    1be2:	60 17       	cp	r22, r16
    1be4:	08 f0       	brcs	.+2      	; 0x1be8 <__vector_14+0x162>
    1be6:	ff 24       	eor	r15, r15
    1be8:	5f 29       	or	r21, r15
    1bea:	41 0f       	add	r20, r17
    1bec:	54 0f       	add	r21, r20
    1bee:	a9 82       	std	Y+1, r10	; 0x01
    1bf0:	aa 83       	std	Y+2, r26	; 0x02
    1bf2:	fb 83       	std	Y+3, r31	; 0x03
    1bf4:	ec 83       	std	Y+4, r30	; 0x04
    1bf6:	bd 83       	std	Y+5, r27	; 0x05
    1bf8:	7e 83       	std	Y+6, r23	; 0x06
    1bfa:	6f 83       	std	Y+7, r22	; 0x07
    1bfc:	58 87       	std	Y+8, r21	; 0x08
    1bfe:	03 96       	adiw	r24, 0x03	; 3
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1c00:	8c 30       	cpi	r24, 0x0C	; 12
    1c02:	91 05       	cpc	r25, r1
    1c04:	09 f0       	breq	.+2      	; 0x1c08 <__vector_14+0x182>
    1c06:	73 cf       	rjmp	.-282    	; 0x1aee <__vector_14+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    1c08:	e9 80       	ldd	r14, Y+1	; 0x01
    1c0a:	fa 80       	ldd	r15, Y+2	; 0x02
    1c0c:	0b 81       	ldd	r16, Y+3	; 0x03
    1c0e:	1c 81       	ldd	r17, Y+4	; 0x04
    1c10:	bd 81       	ldd	r27, Y+5	; 0x05
    1c12:	ae 81       	ldd	r26, Y+6	; 0x06
    1c14:	ff 81       	ldd	r31, Y+7	; 0x07
    1c16:	e8 85       	ldd	r30, Y+8	; 0x08
    1c18:	2e 2d       	mov	r18, r14
    1c1a:	3f 2d       	mov	r19, r15
    1c1c:	40 2f       	mov	r20, r16
    1c1e:	51 2f       	mov	r21, r17
    1c20:	6b 2f       	mov	r22, r27
    1c22:	7a 2f       	mov	r23, r26
    1c24:	8f 2f       	mov	r24, r31
    1c26:	9e 2f       	mov	r25, r30
    1c28:	ee 23       	and	r30, r30
    1c2a:	0c f0       	brlt	.+2      	; 0x1c2e <__vector_14+0x1a8>
    1c2c:	4a c0       	rjmp	.+148    	; 0x1cc2 <__vector_14+0x23c>
    1c2e:	93 e0       	ldi	r25, 0x03	; 3
    1c30:	e9 0e       	add	r14, r25
    1c32:	91 e0       	ldi	r25, 0x01	; 1
    1c34:	e2 16       	cp	r14, r18
    1c36:	08 f0       	brcs	.+2      	; 0x1c3a <__vector_14+0x1b4>
    1c38:	90 e0       	ldi	r25, 0x00	; 0
    1c3a:	21 e0       	ldi	r18, 0x01	; 1
    1c3c:	f3 16       	cp	r15, r19
    1c3e:	08 f0       	brcs	.+2      	; 0x1c42 <__vector_14+0x1bc>
    1c40:	20 e0       	ldi	r18, 0x00	; 0
    1c42:	39 2f       	mov	r19, r25
    1c44:	3f 0d       	add	r19, r15
    1c46:	91 e0       	ldi	r25, 0x01	; 1
    1c48:	3f 15       	cp	r19, r15
    1c4a:	08 f0       	brcs	.+2      	; 0x1c4e <__vector_14+0x1c8>
    1c4c:	90 e0       	ldi	r25, 0x00	; 0
    1c4e:	29 2b       	or	r18, r25
    1c50:	91 e0       	ldi	r25, 0x01	; 1
    1c52:	04 17       	cp	r16, r20
    1c54:	08 f0       	brcs	.+2      	; 0x1c58 <__vector_14+0x1d2>
    1c56:	90 e0       	ldi	r25, 0x00	; 0
    1c58:	42 2f       	mov	r20, r18
    1c5a:	40 0f       	add	r20, r16
    1c5c:	21 e0       	ldi	r18, 0x01	; 1
    1c5e:	40 17       	cp	r20, r16
    1c60:	08 f0       	brcs	.+2      	; 0x1c64 <__vector_14+0x1de>
    1c62:	20 e0       	ldi	r18, 0x00	; 0
    1c64:	92 2b       	or	r25, r18
    1c66:	21 e0       	ldi	r18, 0x01	; 1
    1c68:	15 17       	cp	r17, r21
    1c6a:	08 f0       	brcs	.+2      	; 0x1c6e <__vector_14+0x1e8>
    1c6c:	20 e0       	ldi	r18, 0x00	; 0
    1c6e:	59 2f       	mov	r21, r25
    1c70:	51 0f       	add	r21, r17
    1c72:	91 e0       	ldi	r25, 0x01	; 1
    1c74:	51 17       	cp	r21, r17
    1c76:	08 f0       	brcs	.+2      	; 0x1c7a <__vector_14+0x1f4>
    1c78:	90 e0       	ldi	r25, 0x00	; 0
    1c7a:	29 2b       	or	r18, r25
    1c7c:	91 e0       	ldi	r25, 0x01	; 1
    1c7e:	b6 17       	cp	r27, r22
    1c80:	08 f0       	brcs	.+2      	; 0x1c84 <__vector_14+0x1fe>
    1c82:	90 e0       	ldi	r25, 0x00	; 0
    1c84:	62 2f       	mov	r22, r18
    1c86:	6b 0f       	add	r22, r27
    1c88:	21 e0       	ldi	r18, 0x01	; 1
    1c8a:	6b 17       	cp	r22, r27
    1c8c:	08 f0       	brcs	.+2      	; 0x1c90 <__vector_14+0x20a>
    1c8e:	20 e0       	ldi	r18, 0x00	; 0
    1c90:	92 2b       	or	r25, r18
    1c92:	21 e0       	ldi	r18, 0x01	; 1
    1c94:	a7 17       	cp	r26, r23
    1c96:	08 f0       	brcs	.+2      	; 0x1c9a <__vector_14+0x214>
    1c98:	20 e0       	ldi	r18, 0x00	; 0
    1c9a:	79 2f       	mov	r23, r25
    1c9c:	7a 0f       	add	r23, r26
    1c9e:	91 e0       	ldi	r25, 0x01	; 1
    1ca0:	7a 17       	cp	r23, r26
    1ca2:	08 f0       	brcs	.+2      	; 0x1ca6 <__vector_14+0x220>
    1ca4:	90 e0       	ldi	r25, 0x00	; 0
    1ca6:	29 2b       	or	r18, r25
    1ca8:	91 e0       	ldi	r25, 0x01	; 1
    1caa:	f8 17       	cp	r31, r24
    1cac:	08 f0       	brcs	.+2      	; 0x1cb0 <__vector_14+0x22a>
    1cae:	90 e0       	ldi	r25, 0x00	; 0
    1cb0:	82 2f       	mov	r24, r18
    1cb2:	8f 0f       	add	r24, r31
    1cb4:	21 e0       	ldi	r18, 0x01	; 1
    1cb6:	8f 17       	cp	r24, r31
    1cb8:	08 f0       	brcs	.+2      	; 0x1cbc <__vector_14+0x236>
    1cba:	20 e0       	ldi	r18, 0x00	; 0
    1cbc:	92 2b       	or	r25, r18
    1cbe:	2e 2d       	mov	r18, r14
    1cc0:	9e 0f       	add	r25, r30
    1cc2:	02 e0       	ldi	r16, 0x02	; 2
    1cc4:	0e 94 51 2e 	call	0x5ca2	; 0x5ca2 <__ashrdi3>
    1cc8:	29 83       	std	Y+1, r18	; 0x01
    1cca:	3a 83       	std	Y+2, r19	; 0x02
    1ccc:	4b 83       	std	Y+3, r20	; 0x03
    1cce:	5c 83       	std	Y+4, r21	; 0x04
    1cd0:	6d 83       	std	Y+5, r22	; 0x05
    1cd2:	7e 83       	std	Y+6, r23	; 0x06
    1cd4:	8f 83       	std	Y+7, r24	; 0x07
    1cd6:	98 87       	std	Y+8, r25	; 0x08
	ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1cd8:	60 91 6a 50 	lds	r22, 0x506A
    1cdc:	70 91 6b 50 	lds	r23, 0x506B
    1ce0:	80 91 6c 50 	lds	r24, 0x506C
    1ce4:	90 91 6d 50 	lds	r25, 0x506D
    1ce8:	19 81       	ldd	r17, Y+1	; 0x01
    1cea:	0a 81       	ldd	r16, Y+2	; 0x02
    1cec:	fb 80       	ldd	r15, Y+3	; 0x03
    1cee:	ec 80       	ldd	r14, Y+4	; 0x04
    1cf0:	dd 80       	ldd	r13, Y+5	; 0x05
    1cf2:	ce 80       	ldd	r12, Y+6	; 0x06
    1cf4:	bf 80       	ldd	r11, Y+7	; 0x07
    1cf6:	a8 84       	ldd	r10, Y+8	; 0x08
    1cf8:	20 91 ac 50 	lds	r18, 0x50AC
    1cfc:	30 91 ad 50 	lds	r19, 0x50AD
    1d00:	40 e0       	ldi	r20, 0x00	; 0
    1d02:	50 e0       	ldi	r21, 0x00	; 0
    1d04:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    1d08:	dc 01       	movw	r26, r24
    1d0a:	cb 01       	movw	r24, r22
    1d0c:	88 0f       	add	r24, r24
    1d0e:	99 1f       	adc	r25, r25
    1d10:	88 0f       	add	r24, r24
    1d12:	99 1f       	adc	r25, r25
    1d14:	80 90 68 50 	lds	r8, 0x5068
    1d18:	90 90 69 50 	lds	r9, 0x5069
    1d1c:	88 0e       	add	r8, r24
    1d1e:	99 1e       	adc	r9, r25
    1d20:	21 2f       	mov	r18, r17
    1d22:	30 2f       	mov	r19, r16
    1d24:	4f 2d       	mov	r20, r15
    1d26:	5e 2d       	mov	r21, r14
    1d28:	6d 2d       	mov	r22, r13
    1d2a:	7c 2d       	mov	r23, r12
    1d2c:	8b 2d       	mov	r24, r11
    1d2e:	9a 2d       	mov	r25, r10
    1d30:	0f 2e       	mov	r0, r31
    1d32:	f0 ea       	ldi	r31, 0xA0	; 160
    1d34:	af 2e       	mov	r10, r31
    1d36:	f0 2d       	mov	r31, r0
    1d38:	0f 2e       	mov	r0, r31
    1d3a:	f5 e2       	ldi	r31, 0x25	; 37
    1d3c:	bf 2e       	mov	r11, r31
    1d3e:	f0 2d       	mov	r31, r0
    1d40:	0f 2e       	mov	r0, r31
    1d42:	f6 e2       	ldi	r31, 0x26	; 38
    1d44:	cf 2e       	mov	r12, r31
    1d46:	f0 2d       	mov	r31, r0
    1d48:	dd 24       	eor	r13, r13
    1d4a:	ee 24       	eor	r14, r14
    1d4c:	ff 24       	eor	r15, r15
    1d4e:	00 e0       	ldi	r16, 0x00	; 0
    1d50:	10 e0       	ldi	r17, 0x00	; 0
    1d52:	0e 94 0a 2d 	call	0x5a14	; 0x5a14 <__muldi3>
    1d56:	aa 24       	eor	r10, r10
    1d58:	aa 94       	dec	r10
    1d5a:	bb 24       	eor	r11, r11
    1d5c:	ba 94       	dec	r11
    1d5e:	0f 2e       	mov	r0, r31
    1d60:	ff e7       	ldi	r31, 0x7F	; 127
    1d62:	cf 2e       	mov	r12, r31
    1d64:	f0 2d       	mov	r31, r0
    1d66:	0e 94 b9 2e 	call	0x5d72	; 0x5d72 <__divdi3>
    1d6a:	01 e0       	ldi	r16, 0x01	; 1
    1d6c:	0e 94 dd 2d 	call	0x5bba	; 0x5bba <__ashldi3>
    1d70:	0f 2e       	mov	r0, r31
    1d72:	f3 e0       	ldi	r31, 0x03	; 3
    1d74:	af 2e       	mov	r10, r31
    1d76:	f0 2d       	mov	r31, r0
    1d78:	bb 24       	eor	r11, r11
    1d7a:	cc 24       	eor	r12, r12
    1d7c:	00 e0       	ldi	r16, 0x00	; 0
    1d7e:	0e 94 b9 2e 	call	0x5d72	; 0x5d72 <__divdi3>
    1d82:	f4 01       	movw	r30, r8
    1d84:	20 83       	st	Z, r18
    1d86:	31 83       	std	Z+1, r19	; 0x01
    1d88:	42 83       	std	Z+2, r20	; 0x02
    1d8a:	53 83       	std	Z+3, r21	; 0x03
	if(write_to_FRAM){
    1d8c:	80 91 4d 40 	lds	r24, 0x404D
    1d90:	88 23       	and	r24, r24
    1d92:	09 f1       	breq	.+66     	; 0x1dd6 <__vector_14+0x350>
		writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    1d94:	60 91 6a 50 	lds	r22, 0x506A
    1d98:	70 91 6b 50 	lds	r23, 0x506B
    1d9c:	80 91 6c 50 	lds	r24, 0x506C
    1da0:	90 91 6d 50 	lds	r25, 0x506D
    1da4:	20 91 ac 50 	lds	r18, 0x50AC
    1da8:	30 91 ad 50 	lds	r19, 0x50AD
    1dac:	40 e0       	ldi	r20, 0x00	; 0
    1dae:	50 e0       	ldi	r21, 0x00	; 0
    1db0:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    1db4:	dc 01       	movw	r26, r24
    1db6:	cb 01       	movw	r24, r22
    1db8:	9c 01       	movw	r18, r24
    1dba:	22 0f       	add	r18, r18
    1dbc:	33 1f       	adc	r19, r19
    1dbe:	22 0f       	add	r18, r18
    1dc0:	33 1f       	adc	r19, r19
    1dc2:	80 91 68 50 	lds	r24, 0x5068
    1dc6:	90 91 69 50 	lds	r25, 0x5069
    1dca:	82 0f       	add	r24, r18
    1dcc:	93 1f       	adc	r25, r19
    1dce:	64 e0       	ldi	r22, 0x04	; 4
    1dd0:	70 e0       	ldi	r23, 0x00	; 0
    1dd2:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
	}
	sampleCount++;
    1dd6:	80 91 6a 50 	lds	r24, 0x506A
    1dda:	90 91 6b 50 	lds	r25, 0x506B
    1dde:	a0 91 6c 50 	lds	r26, 0x506C
    1de2:	b0 91 6d 50 	lds	r27, 0x506D
    1de6:	01 96       	adiw	r24, 0x01	; 1
    1de8:	a1 1d       	adc	r26, r1
    1dea:	b1 1d       	adc	r27, r1
    1dec:	80 93 6a 50 	sts	0x506A, r24
    1df0:	90 93 6b 50 	sts	0x506B, r25
    1df4:	a0 93 6c 50 	sts	0x506C, r26
    1df8:	b0 93 6d 50 	sts	0x506D, r27

}
    1dfc:	2c 96       	adiw	r28, 0x0c	; 12
    1dfe:	cd bf       	out	0x3d, r28	; 61
    1e00:	de bf       	out	0x3e, r29	; 62
    1e02:	df 91       	pop	r29
    1e04:	cf 91       	pop	r28
    1e06:	ff 91       	pop	r31
    1e08:	ef 91       	pop	r30
    1e0a:	bf 91       	pop	r27
    1e0c:	af 91       	pop	r26
    1e0e:	9f 91       	pop	r25
    1e10:	8f 91       	pop	r24
    1e12:	7f 91       	pop	r23
    1e14:	6f 91       	pop	r22
    1e16:	5f 91       	pop	r21
    1e18:	4f 91       	pop	r20
    1e1a:	3f 91       	pop	r19
    1e1c:	2f 91       	pop	r18
    1e1e:	1f 91       	pop	r17
    1e20:	0f 91       	pop	r16
    1e22:	ff 90       	pop	r15
    1e24:	ef 90       	pop	r14
    1e26:	df 90       	pop	r13
    1e28:	cf 90       	pop	r12
    1e2a:	bf 90       	pop	r11
    1e2c:	af 90       	pop	r10
    1e2e:	9f 90       	pop	r9
    1e30:	8f 90       	pop	r8
    1e32:	7f 90       	pop	r7
    1e34:	6f 90       	pop	r6
    1e36:	0f 90       	pop	r0
    1e38:	0b be       	out	0x3b, r0	; 59
    1e3a:	0f 90       	pop	r0
    1e3c:	0f be       	out	0x3f, r0	; 63
    1e3e:	0f 90       	pop	r0
    1e40:	1f 90       	pop	r1
    1e42:	18 95       	reti

00001e44 <__vector_77>:
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1e44:	1f 92       	push	r1
    1e46:	0f 92       	push	r0
    1e48:	0f b6       	in	r0, 0x3f	; 63
    1e4a:	0f 92       	push	r0
    1e4c:	0b b6       	in	r0, 0x3b	; 59
    1e4e:	0f 92       	push	r0
    1e50:	11 24       	eor	r1, r1
    1e52:	6f 92       	push	r6
    1e54:	7f 92       	push	r7
    1e56:	8f 92       	push	r8
    1e58:	9f 92       	push	r9
    1e5a:	af 92       	push	r10
    1e5c:	bf 92       	push	r11
    1e5e:	cf 92       	push	r12
    1e60:	df 92       	push	r13
    1e62:	ef 92       	push	r14
    1e64:	ff 92       	push	r15
    1e66:	0f 93       	push	r16
    1e68:	1f 93       	push	r17
    1e6a:	2f 93       	push	r18
    1e6c:	3f 93       	push	r19
    1e6e:	4f 93       	push	r20
    1e70:	5f 93       	push	r21
    1e72:	6f 93       	push	r22
    1e74:	7f 93       	push	r23
    1e76:	8f 93       	push	r24
    1e78:	9f 93       	push	r25
    1e7a:	af 93       	push	r26
    1e7c:	bf 93       	push	r27
    1e7e:	ef 93       	push	r30
    1e80:	ff 93       	push	r31
    1e82:	cf 93       	push	r28
    1e84:	df 93       	push	r29
    1e86:	cd b7       	in	r28, 0x3d	; 61
    1e88:	de b7       	in	r29, 0x3e	; 62
    1e8a:	2c 97       	sbiw	r28, 0x0c	; 12
    1e8c:	cd bf       	out	0x3d, r28	; 61
    1e8e:	de bf       	out	0x3e, r29	; 62

	volatile int64_t sum = 0;
    1e90:	19 82       	std	Y+1, r1	; 0x01
    1e92:	1a 82       	std	Y+2, r1	; 0x02
    1e94:	1b 82       	std	Y+3, r1	; 0x03
    1e96:	1c 82       	std	Y+4, r1	; 0x04
    1e98:	1d 82       	std	Y+5, r1	; 0x05
    1e9a:	1e 82       	std	Y+6, r1	; 0x06
    1e9c:	1f 82       	std	Y+7, r1	; 0x07
    1e9e:	18 86       	std	Y+8, r1	; 0x08
    1ea0:	80 e0       	ldi	r24, 0x00	; 0
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1ea4:	25 e2       	ldi	r18, 0x25	; 37
    1ea6:	3e e3       	ldi	r19, 0x3E	; 62
    1ea8:	88 24       	eor	r8, r8
    1eaa:	8a 94       	dec	r8
    1eac:	ac 01       	movw	r20, r24
    1eae:	f9 01       	movw	r30, r18
    1eb0:	e8 0f       	add	r30, r24
    1eb2:	f9 1f       	adc	r31, r25
    1eb4:	60 81       	ld	r22, Z
    1eb6:	66 23       	and	r22, r22
    1eb8:	14 f4       	brge	.+4      	; 0x1ebe <__vector_77+0x7a>
    1eba:	8c 86       	std	Y+12, r8	; 0x0c
    1ebc:	01 c0       	rjmp	.+2      	; 0x1ec0 <__vector_77+0x7c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1ebe:	1c 86       	std	Y+12, r1	; 0x0c
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    1ec0:	42 0f       	add	r20, r18
    1ec2:	53 1f       	adc	r21, r19
    1ec4:	fa 01       	movw	r30, r20
    1ec6:	40 81       	ld	r20, Z
    1ec8:	4b 87       	std	Y+11, r20	; 0x0b
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1eca:	fc 01       	movw	r30, r24
    1ecc:	31 96       	adiw	r30, 0x01	; 1
		
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    1ece:	e2 0f       	add	r30, r18
    1ed0:	f3 1f       	adc	r31, r19
    1ed2:	40 81       	ld	r20, Z
    1ed4:	4a 87       	std	Y+10, r20	; 0x0a
	sampleCurrentChannel();
	SPICount = 0;
}

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    1ed6:	fc 01       	movw	r30, r24
    1ed8:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    1eda:	e2 0f       	add	r30, r18
    1edc:	f3 1f       	adc	r31, r19
    1ede:	40 81       	ld	r20, Z
    1ee0:	49 87       	std	Y+9, r20	; 0x09
		sum += currentSample;
    1ee2:	49 85       	ldd	r20, Y+9	; 0x09
    1ee4:	5a 85       	ldd	r21, Y+10	; 0x0a
    1ee6:	6b 85       	ldd	r22, Y+11	; 0x0b
    1ee8:	7c 85       	ldd	r23, Y+12	; 0x0c
    1eea:	a9 80       	ldd	r10, Y+1	; 0x01
    1eec:	ba 80       	ldd	r11, Y+2	; 0x02
    1eee:	cb 80       	ldd	r12, Y+3	; 0x03
    1ef0:	dc 80       	ldd	r13, Y+4	; 0x04
    1ef2:	ed 80       	ldd	r14, Y+5	; 0x05
    1ef4:	fe 80       	ldd	r15, Y+6	; 0x06
    1ef6:	0f 81       	ldd	r16, Y+7	; 0x07
    1ef8:	18 85       	ldd	r17, Y+8	; 0x08
    1efa:	b4 2f       	mov	r27, r20
    1efc:	a5 2f       	mov	r26, r21
    1efe:	f6 2f       	mov	r31, r22
    1f00:	e7 2f       	mov	r30, r23
    1f02:	77 0f       	add	r23, r23
    1f04:	44 0b       	sbc	r20, r20
    1f06:	54 2f       	mov	r21, r20
    1f08:	ba 01       	movw	r22, r20
    1f0a:	64 2e       	mov	r6, r20
    1f0c:	74 2e       	mov	r7, r20
    1f0e:	94 2e       	mov	r9, r20
    1f10:	ab 0e       	add	r10, r27
    1f12:	61 e0       	ldi	r22, 0x01	; 1
    1f14:	ab 16       	cp	r10, r27
    1f16:	08 f0       	brcs	.+2      	; 0x1f1a <__vector_77+0xd6>
    1f18:	60 e0       	ldi	r22, 0x00	; 0
    1f1a:	ba 0e       	add	r11, r26
    1f1c:	51 e0       	ldi	r21, 0x01	; 1
    1f1e:	ba 16       	cp	r11, r26
    1f20:	08 f0       	brcs	.+2      	; 0x1f24 <__vector_77+0xe0>
    1f22:	50 e0       	ldi	r21, 0x00	; 0
    1f24:	a6 2f       	mov	r26, r22
    1f26:	ab 0d       	add	r26, r11
    1f28:	61 e0       	ldi	r22, 0x01	; 1
    1f2a:	ab 15       	cp	r26, r11
    1f2c:	08 f0       	brcs	.+2      	; 0x1f30 <__vector_77+0xec>
    1f2e:	60 e0       	ldi	r22, 0x00	; 0
    1f30:	56 2b       	or	r21, r22
    1f32:	cf 0e       	add	r12, r31
    1f34:	61 e0       	ldi	r22, 0x01	; 1
    1f36:	cf 16       	cp	r12, r31
    1f38:	08 f0       	brcs	.+2      	; 0x1f3c <__vector_77+0xf8>
    1f3a:	60 e0       	ldi	r22, 0x00	; 0
    1f3c:	f5 2f       	mov	r31, r21
    1f3e:	fc 0d       	add	r31, r12
    1f40:	51 e0       	ldi	r21, 0x01	; 1
    1f42:	fc 15       	cp	r31, r12
    1f44:	08 f0       	brcs	.+2      	; 0x1f48 <__vector_77+0x104>
    1f46:	50 e0       	ldi	r21, 0x00	; 0
    1f48:	65 2b       	or	r22, r21
    1f4a:	de 0e       	add	r13, r30
    1f4c:	51 e0       	ldi	r21, 0x01	; 1
    1f4e:	de 16       	cp	r13, r30
    1f50:	08 f0       	brcs	.+2      	; 0x1f54 <__vector_77+0x110>
    1f52:	50 e0       	ldi	r21, 0x00	; 0
    1f54:	e6 2f       	mov	r30, r22
    1f56:	ed 0d       	add	r30, r13
    1f58:	61 e0       	ldi	r22, 0x01	; 1
    1f5a:	ed 15       	cp	r30, r13
    1f5c:	08 f0       	brcs	.+2      	; 0x1f60 <__vector_77+0x11c>
    1f5e:	60 e0       	ldi	r22, 0x00	; 0
    1f60:	56 2b       	or	r21, r22
    1f62:	e6 0c       	add	r14, r6
    1f64:	71 e0       	ldi	r23, 0x01	; 1
    1f66:	e6 14       	cp	r14, r6
    1f68:	08 f0       	brcs	.+2      	; 0x1f6c <__vector_77+0x128>
    1f6a:	70 e0       	ldi	r23, 0x00	; 0
    1f6c:	b5 2f       	mov	r27, r21
    1f6e:	be 0d       	add	r27, r14
    1f70:	51 e0       	ldi	r21, 0x01	; 1
    1f72:	be 15       	cp	r27, r14
    1f74:	08 f0       	brcs	.+2      	; 0x1f78 <__vector_77+0x134>
    1f76:	50 e0       	ldi	r21, 0x00	; 0
    1f78:	75 2b       	or	r23, r21
    1f7a:	f7 0c       	add	r15, r7
    1f7c:	61 e0       	ldi	r22, 0x01	; 1
    1f7e:	f7 14       	cp	r15, r7
    1f80:	08 f0       	brcs	.+2      	; 0x1f84 <__vector_77+0x140>
    1f82:	60 e0       	ldi	r22, 0x00	; 0
    1f84:	7f 0d       	add	r23, r15
    1f86:	51 e0       	ldi	r21, 0x01	; 1
    1f88:	7f 15       	cp	r23, r15
    1f8a:	08 f0       	brcs	.+2      	; 0x1f8e <__vector_77+0x14a>
    1f8c:	50 e0       	ldi	r21, 0x00	; 0
    1f8e:	65 2b       	or	r22, r21
    1f90:	09 0d       	add	r16, r9
    1f92:	51 e0       	ldi	r21, 0x01	; 1
    1f94:	09 15       	cp	r16, r9
    1f96:	08 f0       	brcs	.+2      	; 0x1f9a <__vector_77+0x156>
    1f98:	50 e0       	ldi	r21, 0x00	; 0
    1f9a:	60 0f       	add	r22, r16
    1f9c:	ff 24       	eor	r15, r15
    1f9e:	f3 94       	inc	r15
    1fa0:	60 17       	cp	r22, r16
    1fa2:	08 f0       	brcs	.+2      	; 0x1fa6 <__vector_77+0x162>
    1fa4:	ff 24       	eor	r15, r15
    1fa6:	5f 29       	or	r21, r15
    1fa8:	41 0f       	add	r20, r17
    1faa:	54 0f       	add	r21, r20
    1fac:	a9 82       	std	Y+1, r10	; 0x01
    1fae:	aa 83       	std	Y+2, r26	; 0x02
    1fb0:	fb 83       	std	Y+3, r31	; 0x03
    1fb2:	ec 83       	std	Y+4, r30	; 0x04
    1fb4:	bd 83       	std	Y+5, r27	; 0x05
    1fb6:	7e 83       	std	Y+6, r23	; 0x06
    1fb8:	6f 83       	std	Y+7, r22	; 0x07
    1fba:	58 87       	std	Y+8, r21	; 0x08
    1fbc:	03 96       	adiw	r24, 0x03	; 3
ISR(TCD0_OVF_vect) {

	volatile int64_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    1fbe:	8c 30       	cpi	r24, 0x0C	; 12
    1fc0:	91 05       	cpc	r25, r1
    1fc2:	09 f0       	breq	.+2      	; 0x1fc6 <__vector_77+0x182>
    1fc4:	73 cf       	rjmp	.-282    	; 0x1eac <__vector_77+0x68>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    1fc6:	e9 80       	ldd	r14, Y+1	; 0x01
    1fc8:	fa 80       	ldd	r15, Y+2	; 0x02
    1fca:	0b 81       	ldd	r16, Y+3	; 0x03
    1fcc:	1c 81       	ldd	r17, Y+4	; 0x04
    1fce:	bd 81       	ldd	r27, Y+5	; 0x05
    1fd0:	ae 81       	ldd	r26, Y+6	; 0x06
    1fd2:	ff 81       	ldd	r31, Y+7	; 0x07
    1fd4:	e8 85       	ldd	r30, Y+8	; 0x08
    1fd6:	2e 2d       	mov	r18, r14
    1fd8:	3f 2d       	mov	r19, r15
    1fda:	40 2f       	mov	r20, r16
    1fdc:	51 2f       	mov	r21, r17
    1fde:	6b 2f       	mov	r22, r27
    1fe0:	7a 2f       	mov	r23, r26
    1fe2:	8f 2f       	mov	r24, r31
    1fe4:	9e 2f       	mov	r25, r30
    1fe6:	ee 23       	and	r30, r30
    1fe8:	0c f0       	brlt	.+2      	; 0x1fec <__vector_77+0x1a8>
    1fea:	4a c0       	rjmp	.+148    	; 0x2080 <__vector_77+0x23c>
    1fec:	93 e0       	ldi	r25, 0x03	; 3
    1fee:	e9 0e       	add	r14, r25
    1ff0:	91 e0       	ldi	r25, 0x01	; 1
    1ff2:	e2 16       	cp	r14, r18
    1ff4:	08 f0       	brcs	.+2      	; 0x1ff8 <__vector_77+0x1b4>
    1ff6:	90 e0       	ldi	r25, 0x00	; 0
    1ff8:	21 e0       	ldi	r18, 0x01	; 1
    1ffa:	f3 16       	cp	r15, r19
    1ffc:	08 f0       	brcs	.+2      	; 0x2000 <__vector_77+0x1bc>
    1ffe:	20 e0       	ldi	r18, 0x00	; 0
    2000:	39 2f       	mov	r19, r25
    2002:	3f 0d       	add	r19, r15
    2004:	91 e0       	ldi	r25, 0x01	; 1
    2006:	3f 15       	cp	r19, r15
    2008:	08 f0       	brcs	.+2      	; 0x200c <__vector_77+0x1c8>
    200a:	90 e0       	ldi	r25, 0x00	; 0
    200c:	29 2b       	or	r18, r25
    200e:	91 e0       	ldi	r25, 0x01	; 1
    2010:	04 17       	cp	r16, r20
    2012:	08 f0       	brcs	.+2      	; 0x2016 <__vector_77+0x1d2>
    2014:	90 e0       	ldi	r25, 0x00	; 0
    2016:	42 2f       	mov	r20, r18
    2018:	40 0f       	add	r20, r16
    201a:	21 e0       	ldi	r18, 0x01	; 1
    201c:	40 17       	cp	r20, r16
    201e:	08 f0       	brcs	.+2      	; 0x2022 <__vector_77+0x1de>
    2020:	20 e0       	ldi	r18, 0x00	; 0
    2022:	92 2b       	or	r25, r18
    2024:	21 e0       	ldi	r18, 0x01	; 1
    2026:	15 17       	cp	r17, r21
    2028:	08 f0       	brcs	.+2      	; 0x202c <__vector_77+0x1e8>
    202a:	20 e0       	ldi	r18, 0x00	; 0
    202c:	59 2f       	mov	r21, r25
    202e:	51 0f       	add	r21, r17
    2030:	91 e0       	ldi	r25, 0x01	; 1
    2032:	51 17       	cp	r21, r17
    2034:	08 f0       	brcs	.+2      	; 0x2038 <__vector_77+0x1f4>
    2036:	90 e0       	ldi	r25, 0x00	; 0
    2038:	29 2b       	or	r18, r25
    203a:	91 e0       	ldi	r25, 0x01	; 1
    203c:	b6 17       	cp	r27, r22
    203e:	08 f0       	brcs	.+2      	; 0x2042 <__vector_77+0x1fe>
    2040:	90 e0       	ldi	r25, 0x00	; 0
    2042:	62 2f       	mov	r22, r18
    2044:	6b 0f       	add	r22, r27
    2046:	21 e0       	ldi	r18, 0x01	; 1
    2048:	6b 17       	cp	r22, r27
    204a:	08 f0       	brcs	.+2      	; 0x204e <__vector_77+0x20a>
    204c:	20 e0       	ldi	r18, 0x00	; 0
    204e:	92 2b       	or	r25, r18
    2050:	21 e0       	ldi	r18, 0x01	; 1
    2052:	a7 17       	cp	r26, r23
    2054:	08 f0       	brcs	.+2      	; 0x2058 <__vector_77+0x214>
    2056:	20 e0       	ldi	r18, 0x00	; 0
    2058:	79 2f       	mov	r23, r25
    205a:	7a 0f       	add	r23, r26
    205c:	91 e0       	ldi	r25, 0x01	; 1
    205e:	7a 17       	cp	r23, r26
    2060:	08 f0       	brcs	.+2      	; 0x2064 <__vector_77+0x220>
    2062:	90 e0       	ldi	r25, 0x00	; 0
    2064:	29 2b       	or	r18, r25
    2066:	91 e0       	ldi	r25, 0x01	; 1
    2068:	f8 17       	cp	r31, r24
    206a:	08 f0       	brcs	.+2      	; 0x206e <__vector_77+0x22a>
    206c:	90 e0       	ldi	r25, 0x00	; 0
    206e:	82 2f       	mov	r24, r18
    2070:	8f 0f       	add	r24, r31
    2072:	21 e0       	ldi	r18, 0x01	; 1
    2074:	8f 17       	cp	r24, r31
    2076:	08 f0       	brcs	.+2      	; 0x207a <__vector_77+0x236>
    2078:	20 e0       	ldi	r18, 0x00	; 0
    207a:	92 2b       	or	r25, r18
    207c:	2e 2d       	mov	r18, r14
    207e:	9e 0f       	add	r25, r30
    2080:	02 e0       	ldi	r16, 0x02	; 2
    2082:	0e 94 51 2e 	call	0x5ca2	; 0x5ca2 <__ashrdi3>
    2086:	29 83       	std	Y+1, r18	; 0x01
    2088:	3a 83       	std	Y+2, r19	; 0x02
    208a:	4b 83       	std	Y+3, r20	; 0x03
    208c:	5c 83       	std	Y+4, r21	; 0x04
    208e:	6d 83       	std	Y+5, r22	; 0x05
    2090:	7e 83       	std	Y+6, r23	; 0x06
    2092:	8f 83       	std	Y+7, r24	; 0x07
    2094:	98 87       	std	Y+8, r25	; 0x08
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount%ADC_buffer_size] = (int32_t)(sum * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    2096:	60 91 6a 50 	lds	r22, 0x506A
    209a:	70 91 6b 50 	lds	r23, 0x506B
    209e:	80 91 6c 50 	lds	r24, 0x506C
    20a2:	90 91 6d 50 	lds	r25, 0x506D
    20a6:	19 81       	ldd	r17, Y+1	; 0x01
    20a8:	0a 81       	ldd	r16, Y+2	; 0x02
    20aa:	fb 80       	ldd	r15, Y+3	; 0x03
    20ac:	ec 80       	ldd	r14, Y+4	; 0x04
    20ae:	dd 80       	ldd	r13, Y+5	; 0x05
    20b0:	ce 80       	ldd	r12, Y+6	; 0x06
    20b2:	bf 80       	ldd	r11, Y+7	; 0x07
    20b4:	a8 84       	ldd	r10, Y+8	; 0x08
    20b6:	20 91 ac 50 	lds	r18, 0x50AC
    20ba:	30 91 ad 50 	lds	r19, 0x50AD
    20be:	40 e0       	ldi	r20, 0x00	; 0
    20c0:	50 e0       	ldi	r21, 0x00	; 0
    20c2:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    20c6:	dc 01       	movw	r26, r24
    20c8:	cb 01       	movw	r24, r22
    20ca:	88 0f       	add	r24, r24
    20cc:	99 1f       	adc	r25, r25
    20ce:	88 0f       	add	r24, r24
    20d0:	99 1f       	adc	r25, r25
    20d2:	80 90 68 50 	lds	r8, 0x5068
    20d6:	90 90 69 50 	lds	r9, 0x5069
    20da:	88 0e       	add	r8, r24
    20dc:	99 1e       	adc	r9, r25
    20de:	21 2f       	mov	r18, r17
    20e0:	30 2f       	mov	r19, r16
    20e2:	4f 2d       	mov	r20, r15
    20e4:	5e 2d       	mov	r21, r14
    20e6:	6d 2d       	mov	r22, r13
    20e8:	7c 2d       	mov	r23, r12
    20ea:	8b 2d       	mov	r24, r11
    20ec:	9a 2d       	mov	r25, r10
    20ee:	0f 2e       	mov	r0, r31
    20f0:	f0 ea       	ldi	r31, 0xA0	; 160
    20f2:	af 2e       	mov	r10, r31
    20f4:	f0 2d       	mov	r31, r0
    20f6:	0f 2e       	mov	r0, r31
    20f8:	f5 e2       	ldi	r31, 0x25	; 37
    20fa:	bf 2e       	mov	r11, r31
    20fc:	f0 2d       	mov	r31, r0
    20fe:	0f 2e       	mov	r0, r31
    2100:	f6 e2       	ldi	r31, 0x26	; 38
    2102:	cf 2e       	mov	r12, r31
    2104:	f0 2d       	mov	r31, r0
    2106:	dd 24       	eor	r13, r13
    2108:	ee 24       	eor	r14, r14
    210a:	ff 24       	eor	r15, r15
    210c:	00 e0       	ldi	r16, 0x00	; 0
    210e:	10 e0       	ldi	r17, 0x00	; 0
    2110:	0e 94 0a 2d 	call	0x5a14	; 0x5a14 <__muldi3>
    2114:	aa 24       	eor	r10, r10
    2116:	aa 94       	dec	r10
    2118:	bb 24       	eor	r11, r11
    211a:	ba 94       	dec	r11
    211c:	0f 2e       	mov	r0, r31
    211e:	ff e7       	ldi	r31, 0x7F	; 127
    2120:	cf 2e       	mov	r12, r31
    2122:	f0 2d       	mov	r31, r0
    2124:	0e 94 b9 2e 	call	0x5d72	; 0x5d72 <__divdi3>
    2128:	01 e0       	ldi	r16, 0x01	; 1
    212a:	0e 94 dd 2d 	call	0x5bba	; 0x5bba <__ashldi3>
    212e:	0f 2e       	mov	r0, r31
    2130:	f3 e0       	ldi	r31, 0x03	; 3
    2132:	af 2e       	mov	r10, r31
    2134:	f0 2d       	mov	r31, r0
    2136:	bb 24       	eor	r11, r11
    2138:	cc 24       	eor	r12, r12
    213a:	00 e0       	ldi	r16, 0x00	; 0
    213c:	0e 94 b9 2e 	call	0x5d72	; 0x5d72 <__divdi3>
    2140:	f4 01       	movw	r30, r8
    2142:	20 83       	st	Z, r18
    2144:	31 83       	std	Z+1, r19	; 0x01
    2146:	42 83       	std	Z+2, r20	; 0x02
    2148:	53 83       	std	Z+3, r21	; 0x03
	if(write_to_FRAM){
    214a:	80 91 4d 40 	lds	r24, 0x404D
    214e:	88 23       	and	r24, r24
    2150:	09 f1       	breq	.+66     	; 0x2194 <__vector_77+0x350>
		writeFRAM((uint8_t*)(ADC_BUFFER+(sampleCount%ADC_buffer_size)), 4);
    2152:	60 91 6a 50 	lds	r22, 0x506A
    2156:	70 91 6b 50 	lds	r23, 0x506B
    215a:	80 91 6c 50 	lds	r24, 0x506C
    215e:	90 91 6d 50 	lds	r25, 0x506D
    2162:	20 91 ac 50 	lds	r18, 0x50AC
    2166:	30 91 ad 50 	lds	r19, 0x50AD
    216a:	40 e0       	ldi	r20, 0x00	; 0
    216c:	50 e0       	ldi	r21, 0x00	; 0
    216e:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    2172:	dc 01       	movw	r26, r24
    2174:	cb 01       	movw	r24, r22
    2176:	9c 01       	movw	r18, r24
    2178:	22 0f       	add	r18, r18
    217a:	33 1f       	adc	r19, r19
    217c:	22 0f       	add	r18, r18
    217e:	33 1f       	adc	r19, r19
    2180:	80 91 68 50 	lds	r24, 0x5068
    2184:	90 91 69 50 	lds	r25, 0x5069
    2188:	82 0f       	add	r24, r18
    218a:	93 1f       	adc	r25, r19
    218c:	64 e0       	ldi	r22, 0x04	; 4
    218e:	70 e0       	ldi	r23, 0x00	; 0
    2190:	0e 94 39 01 	call	0x272	; 0x272 <writeFRAM>
	}
	sampleCount++;
    2194:	80 91 6a 50 	lds	r24, 0x506A
    2198:	90 91 6b 50 	lds	r25, 0x506B
    219c:	a0 91 6c 50 	lds	r26, 0x506C
    21a0:	b0 91 6d 50 	lds	r27, 0x506D
    21a4:	01 96       	adiw	r24, 0x01	; 1
    21a6:	a1 1d       	adc	r26, r1
    21a8:	b1 1d       	adc	r27, r1
    21aa:	80 93 6a 50 	sts	0x506A, r24
    21ae:	90 93 6b 50 	sts	0x506B, r25
    21b2:	a0 93 6c 50 	sts	0x506C, r26
    21b6:	b0 93 6d 50 	sts	0x506D, r27
}
    21ba:	2c 96       	adiw	r28, 0x0c	; 12
    21bc:	cd bf       	out	0x3d, r28	; 61
    21be:	de bf       	out	0x3e, r29	; 62
    21c0:	df 91       	pop	r29
    21c2:	cf 91       	pop	r28
    21c4:	ff 91       	pop	r31
    21c6:	ef 91       	pop	r30
    21c8:	bf 91       	pop	r27
    21ca:	af 91       	pop	r26
    21cc:	9f 91       	pop	r25
    21ce:	8f 91       	pop	r24
    21d0:	7f 91       	pop	r23
    21d2:	6f 91       	pop	r22
    21d4:	5f 91       	pop	r21
    21d6:	4f 91       	pop	r20
    21d8:	3f 91       	pop	r19
    21da:	2f 91       	pop	r18
    21dc:	1f 91       	pop	r17
    21de:	0f 91       	pop	r16
    21e0:	ff 90       	pop	r15
    21e2:	ef 90       	pop	r14
    21e4:	df 90       	pop	r13
    21e6:	cf 90       	pop	r12
    21e8:	bf 90       	pop	r11
    21ea:	af 90       	pop	r10
    21ec:	9f 90       	pop	r9
    21ee:	8f 90       	pop	r8
    21f0:	7f 90       	pop	r7
    21f2:	6f 90       	pop	r6
    21f4:	0f 90       	pop	r0
    21f6:	0b be       	out	0x3b, r0	; 59
    21f8:	0f 90       	pop	r0
    21fa:	0f be       	out	0x3f, r0	; 63
    21fc:	0f 90       	pop	r0
    21fe:	1f 90       	pop	r1
    2200:	18 95       	reti

00002202 <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
	
	SPICS(TRUE);
    2202:	81 e0       	ldi	r24, 0x01	; 1
    2204:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    2208:	82 e0       	ldi	r24, 0x02	; 2
    220a:	e0 ea       	ldi	r30, 0xA0	; 160
    220c:	f6 e0       	ldi	r31, 0x06	; 6
    220e:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2210:	8a ea       	ldi	r24, 0xAA	; 170
    2212:	e0 ec       	ldi	r30, 0xC0	; 192
    2214:	f8 e0       	ldi	r31, 0x08	; 8
    2216:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2218:	82 81       	ldd	r24, Z+2	; 0x02
    221a:	88 23       	and	r24, r24
    221c:	ec f7       	brge	.-6      	; 0x2218 <sampleCurrentChannel+0x16>
	SPIBuffer[SPICount] = SPIC.DATA;
    221e:	90 91 a5 50 	lds	r25, 0x50A5
    2222:	e0 ec       	ldi	r30, 0xC0	; 192
    2224:	f8 e0       	ldi	r31, 0x08	; 8
    2226:	83 81       	ldd	r24, Z+3	; 0x03
    2228:	a5 e2       	ldi	r26, 0x25	; 37
    222a:	be e3       	ldi	r27, 0x3E	; 62
    222c:	a9 0f       	add	r26, r25
    222e:	b1 1d       	adc	r27, r1
    2230:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2232:	8a ea       	ldi	r24, 0xAA	; 170
    2234:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2236:	82 81       	ldd	r24, Z+2	; 0x02
    2238:	88 23       	and	r24, r24
    223a:	ec f7       	brge	.-6      	; 0x2236 <sampleCurrentChannel+0x34>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    223c:	a0 91 a5 50 	lds	r26, 0x50A5
    2240:	b0 e0       	ldi	r27, 0x00	; 0
    2242:	e0 ec       	ldi	r30, 0xC0	; 192
    2244:	f8 e0       	ldi	r31, 0x08	; 8
    2246:	83 81       	ldd	r24, Z+3	; 0x03
    2248:	aa 5d       	subi	r26, 0xDA	; 218
    224a:	b1 4c       	sbci	r27, 0xC1	; 193
    224c:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    224e:	8a ea       	ldi	r24, 0xAA	; 170
    2250:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2252:	82 81       	ldd	r24, Z+2	; 0x02
    2254:	88 23       	and	r24, r24
    2256:	ec f7       	brge	.-6      	; 0x2252 <sampleCurrentChannel+0x50>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    2258:	e0 91 a5 50 	lds	r30, 0x50A5
    225c:	f0 e0       	ldi	r31, 0x00	; 0
    225e:	a0 ec       	ldi	r26, 0xC0	; 192
    2260:	b8 e0       	ldi	r27, 0x08	; 8
    2262:	13 96       	adiw	r26, 0x03	; 3
    2264:	8c 91       	ld	r24, X
    2266:	e9 5d       	subi	r30, 0xD9	; 217
    2268:	f1 4c       	sbci	r31, 0xC1	; 193
    226a:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    226c:	82 e0       	ldi	r24, 0x02	; 2
    226e:	e0 ea       	ldi	r30, 0xA0	; 160
    2270:	f6 e0       	ldi	r31, 0x06	; 6
    2272:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
    2274:	80 91 a5 50 	lds	r24, 0x50A5
    2278:	8d 5f       	subi	r24, 0xFD	; 253
    227a:	80 93 a5 50 	sts	0x50A5, r24
	SPICS(FALSE);
    227e:	80 e0       	ldi	r24, 0x00	; 0
    2280:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
}
    2284:	08 95       	ret

00002286 <__vector_82>:
ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point
ISR(TCD0_CCD_vect) {
    2286:	1f 92       	push	r1
    2288:	0f 92       	push	r0
    228a:	0f b6       	in	r0, 0x3f	; 63
    228c:	0f 92       	push	r0
    228e:	0b b6       	in	r0, 0x3b	; 59
    2290:	0f 92       	push	r0
    2292:	11 24       	eor	r1, r1
    2294:	2f 93       	push	r18
    2296:	3f 93       	push	r19
    2298:	4f 93       	push	r20
    229a:	5f 93       	push	r21
    229c:	6f 93       	push	r22
    229e:	7f 93       	push	r23
    22a0:	8f 93       	push	r24
    22a2:	9f 93       	push	r25
    22a4:	af 93       	push	r26
    22a6:	bf 93       	push	r27
    22a8:	ef 93       	push	r30
    22aa:	ff 93       	push	r31
	sampleCurrentChannel();
    22ac:	0e 94 01 11 	call	0x2202	; 0x2202 <sampleCurrentChannel>
	SPICount = 0;
    22b0:	10 92 a5 50 	sts	0x50A5, r1
}
    22b4:	ff 91       	pop	r31
    22b6:	ef 91       	pop	r30
    22b8:	bf 91       	pop	r27
    22ba:	af 91       	pop	r26
    22bc:	9f 91       	pop	r25
    22be:	8f 91       	pop	r24
    22c0:	7f 91       	pop	r23
    22c2:	6f 91       	pop	r22
    22c4:	5f 91       	pop	r21
    22c6:	4f 91       	pop	r20
    22c8:	3f 91       	pop	r19
    22ca:	2f 91       	pop	r18
    22cc:	0f 90       	pop	r0
    22ce:	0b be       	out	0x3b, r0	; 59
    22d0:	0f 90       	pop	r0
    22d2:	0f be       	out	0x3f, r0	; 63
    22d4:	0f 90       	pop	r0
    22d6:	1f 90       	pop	r1
    22d8:	18 95       	reti

000022da <__vector_81>:
ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCD0_CCC_vect) {
    22da:	1f 92       	push	r1
    22dc:	0f 92       	push	r0
    22de:	0f b6       	in	r0, 0x3f	; 63
    22e0:	0f 92       	push	r0
    22e2:	0b b6       	in	r0, 0x3b	; 59
    22e4:	0f 92       	push	r0
    22e6:	11 24       	eor	r1, r1
    22e8:	2f 93       	push	r18
    22ea:	3f 93       	push	r19
    22ec:	4f 93       	push	r20
    22ee:	5f 93       	push	r21
    22f0:	6f 93       	push	r22
    22f2:	7f 93       	push	r23
    22f4:	8f 93       	push	r24
    22f6:	9f 93       	push	r25
    22f8:	af 93       	push	r26
    22fa:	bf 93       	push	r27
    22fc:	ef 93       	push	r30
    22fe:	ff 93       	push	r31
	sampleCurrentChannel();
    2300:	0e 94 01 11 	call	0x2202	; 0x2202 <sampleCurrentChannel>
}
    2304:	ff 91       	pop	r31
    2306:	ef 91       	pop	r30
    2308:	bf 91       	pop	r27
    230a:	af 91       	pop	r26
    230c:	9f 91       	pop	r25
    230e:	8f 91       	pop	r24
    2310:	7f 91       	pop	r23
    2312:	6f 91       	pop	r22
    2314:	5f 91       	pop	r21
    2316:	4f 91       	pop	r20
    2318:	3f 91       	pop	r19
    231a:	2f 91       	pop	r18
    231c:	0f 90       	pop	r0
    231e:	0b be       	out	0x3b, r0	; 59
    2320:	0f 90       	pop	r0
    2322:	0f be       	out	0x3f, r0	; 63
    2324:	0f 90       	pop	r0
    2326:	1f 90       	pop	r1
    2328:	18 95       	reti

0000232a <__vector_80>:
//first averaging point
ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}
//second averaging point
ISR(TCD0_CCB_vect) {
    232a:	1f 92       	push	r1
    232c:	0f 92       	push	r0
    232e:	0f b6       	in	r0, 0x3f	; 63
    2330:	0f 92       	push	r0
    2332:	0b b6       	in	r0, 0x3b	; 59
    2334:	0f 92       	push	r0
    2336:	11 24       	eor	r1, r1
    2338:	2f 93       	push	r18
    233a:	3f 93       	push	r19
    233c:	4f 93       	push	r20
    233e:	5f 93       	push	r21
    2340:	6f 93       	push	r22
    2342:	7f 93       	push	r23
    2344:	8f 93       	push	r24
    2346:	9f 93       	push	r25
    2348:	af 93       	push	r26
    234a:	bf 93       	push	r27
    234c:	ef 93       	push	r30
    234e:	ff 93       	push	r31
	sampleCurrentChannel();
    2350:	0e 94 01 11 	call	0x2202	; 0x2202 <sampleCurrentChannel>
}
    2354:	ff 91       	pop	r31
    2356:	ef 91       	pop	r30
    2358:	bf 91       	pop	r27
    235a:	af 91       	pop	r26
    235c:	9f 91       	pop	r25
    235e:	8f 91       	pop	r24
    2360:	7f 91       	pop	r23
    2362:	6f 91       	pop	r22
    2364:	5f 91       	pop	r21
    2366:	4f 91       	pop	r20
    2368:	3f 91       	pop	r19
    236a:	2f 91       	pop	r18
    236c:	0f 90       	pop	r0
    236e:	0b be       	out	0x3b, r0	; 59
    2370:	0f 90       	pop	r0
    2372:	0f be       	out	0x3f, r0	; 63
    2374:	0f 90       	pop	r0
    2376:	1f 90       	pop	r1
    2378:	18 95       	reti

0000237a <__vector_79>:
// 	enableADCMUX(FALSE);
	
}

//first averaging point
ISR(TCD0_CCA_vect) {
    237a:	1f 92       	push	r1
    237c:	0f 92       	push	r0
    237e:	0f b6       	in	r0, 0x3f	; 63
    2380:	0f 92       	push	r0
    2382:	0b b6       	in	r0, 0x3b	; 59
    2384:	0f 92       	push	r0
    2386:	11 24       	eor	r1, r1
    2388:	2f 93       	push	r18
    238a:	3f 93       	push	r19
    238c:	4f 93       	push	r20
    238e:	5f 93       	push	r21
    2390:	6f 93       	push	r22
    2392:	7f 93       	push	r23
    2394:	8f 93       	push	r24
    2396:	9f 93       	push	r25
    2398:	af 93       	push	r26
    239a:	bf 93       	push	r27
    239c:	ef 93       	push	r30
    239e:	ff 93       	push	r31
	sampleCurrentChannel();
    23a0:	0e 94 01 11 	call	0x2202	; 0x2202 <sampleCurrentChannel>
}
    23a4:	ff 91       	pop	r31
    23a6:	ef 91       	pop	r30
    23a8:	bf 91       	pop	r27
    23aa:	af 91       	pop	r26
    23ac:	9f 91       	pop	r25
    23ae:	8f 91       	pop	r24
    23b0:	7f 91       	pop	r23
    23b2:	6f 91       	pop	r22
    23b4:	5f 91       	pop	r21
    23b6:	4f 91       	pop	r20
    23b8:	3f 91       	pop	r19
    23ba:	2f 91       	pop	r18
    23bc:	0f 90       	pop	r0
    23be:	0b be       	out	0x3b, r0	; 59
    23c0:	0f 90       	pop	r0
    23c2:	0f be       	out	0x3f, r0	; 63
    23c4:	0f 90       	pop	r0
    23c6:	1f 90       	pop	r1
    23c8:	18 95       	reti

000023ca <__vector_19>:
ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    23ca:	1f 92       	push	r1
    23cc:	0f 92       	push	r0
    23ce:	0f b6       	in	r0, 0x3f	; 63
    23d0:	0f 92       	push	r0
    23d2:	0b b6       	in	r0, 0x3b	; 59
    23d4:	0f 92       	push	r0
    23d6:	11 24       	eor	r1, r1
    23d8:	2f 93       	push	r18
    23da:	3f 93       	push	r19
    23dc:	4f 93       	push	r20
    23de:	5f 93       	push	r21
    23e0:	6f 93       	push	r22
    23e2:	7f 93       	push	r23
    23e4:	8f 93       	push	r24
    23e6:	9f 93       	push	r25
    23e8:	af 93       	push	r26
    23ea:	bf 93       	push	r27
    23ec:	ef 93       	push	r30
    23ee:	ff 93       	push	r31
	sampleCurrentChannel();
    23f0:	0e 94 01 11 	call	0x2202	; 0x2202 <sampleCurrentChannel>
	SPICount = 0;
    23f4:	10 92 a5 50 	sts	0x50A5, r1
	if(PORTB.OUT & PIN1_bm) {
    23f8:	e0 e2       	ldi	r30, 0x20	; 32
    23fa:	f6 e0       	ldi	r31, 0x06	; 6
    23fc:	84 81       	ldd	r24, Z+4	; 0x04
    23fe:	81 ff       	sbrs	r24, 1
    2400:	0f c0       	rjmp	.+30     	; 0x2420 <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    2402:	e0 e0       	ldi	r30, 0x00	; 0
    2404:	f6 e0       	ldi	r31, 0x06	; 6
    2406:	84 81       	ldd	r24, Z+4	; 0x04
    2408:	86 ff       	sbrs	r24, 6
    240a:	05 c0       	rjmp	.+10     	; 0x2416 <__vector_19+0x4c>
    240c:	82 e0       	ldi	r24, 0x02	; 2
    240e:	e0 e2       	ldi	r30, 0x20	; 32
    2410:	f6 e0       	ldi	r31, 0x06	; 6
    2412:	87 83       	std	Z+7, r24	; 0x07
    2414:	0d c0       	rjmp	.+26     	; 0x2430 <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
    2416:	80 e4       	ldi	r24, 0x40	; 64
    2418:	e0 e0       	ldi	r30, 0x00	; 0
    241a:	f6 e0       	ldi	r31, 0x06	; 6
    241c:	87 83       	std	Z+7, r24	; 0x07
    241e:	08 c0       	rjmp	.+16     	; 0x2430 <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    2420:	80 e4       	ldi	r24, 0x40	; 64
    2422:	e0 e0       	ldi	r30, 0x00	; 0
    2424:	f6 e0       	ldi	r31, 0x06	; 6
    2426:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
    2428:	82 e0       	ldi	r24, 0x02	; 2
    242a:	e0 e2       	ldi	r30, 0x20	; 32
    242c:	f6 e0       	ldi	r31, 0x06	; 6
    242e:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
    2430:	ff 91       	pop	r31
    2432:	ef 91       	pop	r30
    2434:	bf 91       	pop	r27
    2436:	af 91       	pop	r26
    2438:	9f 91       	pop	r25
    243a:	8f 91       	pop	r24
    243c:	7f 91       	pop	r23
    243e:	6f 91       	pop	r22
    2440:	5f 91       	pop	r21
    2442:	4f 91       	pop	r20
    2444:	3f 91       	pop	r19
    2446:	2f 91       	pop	r18
    2448:	0f 90       	pop	r0
    244a:	0b be       	out	0x3b, r0	; 59
    244c:	0f 90       	pop	r0
    244e:	0f be       	out	0x3f, r0	; 63
    2450:	0f 90       	pop	r0
    2452:	1f 90       	pop	r1
    2454:	18 95       	reti

00002456 <__vector_18>:
ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

//third averaging point
ISR(TCC0_CCC_vect) {
    2456:	1f 92       	push	r1
    2458:	0f 92       	push	r0
    245a:	0f b6       	in	r0, 0x3f	; 63
    245c:	0f 92       	push	r0
    245e:	0b b6       	in	r0, 0x3b	; 59
    2460:	0f 92       	push	r0
    2462:	11 24       	eor	r1, r1
    2464:	2f 93       	push	r18
    2466:	3f 93       	push	r19
    2468:	4f 93       	push	r20
    246a:	5f 93       	push	r21
    246c:	6f 93       	push	r22
    246e:	7f 93       	push	r23
    2470:	8f 93       	push	r24
    2472:	9f 93       	push	r25
    2474:	af 93       	push	r26
    2476:	bf 93       	push	r27
    2478:	ef 93       	push	r30
    247a:	ff 93       	push	r31
	sampleCurrentChannel();
    247c:	0e 94 01 11 	call	0x2202	; 0x2202 <sampleCurrentChannel>
}
    2480:	ff 91       	pop	r31
    2482:	ef 91       	pop	r30
    2484:	bf 91       	pop	r27
    2486:	af 91       	pop	r26
    2488:	9f 91       	pop	r25
    248a:	8f 91       	pop	r24
    248c:	7f 91       	pop	r23
    248e:	6f 91       	pop	r22
    2490:	5f 91       	pop	r21
    2492:	4f 91       	pop	r20
    2494:	3f 91       	pop	r19
    2496:	2f 91       	pop	r18
    2498:	0f 90       	pop	r0
    249a:	0b be       	out	0x3b, r0	; 59
    249c:	0f 90       	pop	r0
    249e:	0f be       	out	0x3f, r0	; 63
    24a0:	0f 90       	pop	r0
    24a2:	1f 90       	pop	r1
    24a4:	18 95       	reti

000024a6 <__vector_17>:
ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

//second averaging point
ISR(TCC0_CCB_vect) {
    24a6:	1f 92       	push	r1
    24a8:	0f 92       	push	r0
    24aa:	0f b6       	in	r0, 0x3f	; 63
    24ac:	0f 92       	push	r0
    24ae:	0b b6       	in	r0, 0x3b	; 59
    24b0:	0f 92       	push	r0
    24b2:	11 24       	eor	r1, r1
    24b4:	2f 93       	push	r18
    24b6:	3f 93       	push	r19
    24b8:	4f 93       	push	r20
    24ba:	5f 93       	push	r21
    24bc:	6f 93       	push	r22
    24be:	7f 93       	push	r23
    24c0:	8f 93       	push	r24
    24c2:	9f 93       	push	r25
    24c4:	af 93       	push	r26
    24c6:	bf 93       	push	r27
    24c8:	ef 93       	push	r30
    24ca:	ff 93       	push	r31
	sampleCurrentChannel();
    24cc:	0e 94 01 11 	call	0x2202	; 0x2202 <sampleCurrentChannel>
}
    24d0:	ff 91       	pop	r31
    24d2:	ef 91       	pop	r30
    24d4:	bf 91       	pop	r27
    24d6:	af 91       	pop	r26
    24d8:	9f 91       	pop	r25
    24da:	8f 91       	pop	r24
    24dc:	7f 91       	pop	r23
    24de:	6f 91       	pop	r22
    24e0:	5f 91       	pop	r21
    24e2:	4f 91       	pop	r20
    24e4:	3f 91       	pop	r19
    24e6:	2f 91       	pop	r18
    24e8:	0f 90       	pop	r0
    24ea:	0b be       	out	0x3b, r0	; 59
    24ec:	0f 90       	pop	r0
    24ee:	0f be       	out	0x3f, r0	; 63
    24f0:	0f 90       	pop	r0
    24f2:	1f 90       	pop	r1
    24f4:	18 95       	reti

000024f6 <__vector_16>:
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}

//first averaging point
ISR(TCC0_CCA_vect) {
    24f6:	1f 92       	push	r1
    24f8:	0f 92       	push	r0
    24fa:	0f b6       	in	r0, 0x3f	; 63
    24fc:	0f 92       	push	r0
    24fe:	0b b6       	in	r0, 0x3b	; 59
    2500:	0f 92       	push	r0
    2502:	11 24       	eor	r1, r1
    2504:	2f 93       	push	r18
    2506:	3f 93       	push	r19
    2508:	4f 93       	push	r20
    250a:	5f 93       	push	r21
    250c:	6f 93       	push	r22
    250e:	7f 93       	push	r23
    2510:	8f 93       	push	r24
    2512:	9f 93       	push	r25
    2514:	af 93       	push	r26
    2516:	bf 93       	push	r27
    2518:	ef 93       	push	r30
    251a:	ff 93       	push	r31
	sampleCurrentChannel();
    251c:	0e 94 01 11 	call	0x2202	; 0x2202 <sampleCurrentChannel>
}
    2520:	ff 91       	pop	r31
    2522:	ef 91       	pop	r30
    2524:	bf 91       	pop	r27
    2526:	af 91       	pop	r26
    2528:	9f 91       	pop	r25
    252a:	8f 91       	pop	r24
    252c:	7f 91       	pop	r23
    252e:	6f 91       	pop	r22
    2530:	5f 91       	pop	r21
    2532:	4f 91       	pop	r20
    2534:	3f 91       	pop	r19
    2536:	2f 91       	pop	r18
    2538:	0f 90       	pop	r0
    253a:	0b be       	out	0x3b, r0	; 59
    253c:	0f 90       	pop	r0
    253e:	0f be       	out	0x3f, r0	; 63
    2540:	0f 90       	pop	r0
    2542:	1f 90       	pop	r1
    2544:	18 95       	reti

00002546 <writeSE2FRAM>:
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    2546:	ff 92       	push	r15
    2548:	0f 93       	push	r16
    254a:	1f 93       	push	r17
    254c:	cf 93       	push	r28
    254e:	df 93       	push	r29
    2550:	cd b7       	in	r28, 0x3d	; 61
    2552:	de b7       	in	r29, 0x3e	; 62
    2554:	28 97       	sbiw	r28, 0x08	; 8
    2556:	cd bf       	out	0x3d, r28	; 61
    2558:	de bf       	out	0x3e, r29	; 62

	volatile int32_t sum = 0;
    255a:	19 82       	std	Y+1, r1	; 0x01
    255c:	1a 82       	std	Y+2, r1	; 0x02
    255e:	1b 82       	std	Y+3, r1	; 0x03
    2560:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    2562:	80 91 6a 50 	lds	r24, 0x506A
    2566:	90 91 6b 50 	lds	r25, 0x506B
    256a:	a0 91 6c 50 	lds	r26, 0x506C
    256e:	b0 91 6d 50 	lds	r27, 0x506D
    2572:	01 96       	adiw	r24, 0x01	; 1
    2574:	a1 1d       	adc	r26, r1
    2576:	b1 1d       	adc	r27, r1
    2578:	80 93 6a 50 	sts	0x506A, r24
    257c:	90 93 6b 50 	sts	0x506B, r25
    2580:	a0 93 6c 50 	sts	0x506C, r26
    2584:	b0 93 6d 50 	sts	0x506D, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    2588:	80 ed       	ldi	r24, 0xD0	; 208
    258a:	80 93 c0 08 	sts	0x08C0, r24
    258e:	20 e0       	ldi	r18, 0x00	; 0
    2590:	30 e0       	ldi	r19, 0x00	; 0
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2592:	05 e2       	ldi	r16, 0x25	; 37
    2594:	1e e3       	ldi	r17, 0x3E	; 62
    2596:	ff 24       	eor	r15, r15
    2598:	fa 94       	dec	r15
    259a:	c9 01       	movw	r24, r18
    259c:	f8 01       	movw	r30, r16
    259e:	e2 0f       	add	r30, r18
    25a0:	f3 1f       	adc	r31, r19
    25a2:	40 81       	ld	r20, Z
    25a4:	44 23       	and	r20, r20
    25a6:	14 f4       	brge	.+4      	; 0x25ac <writeSE2FRAM+0x66>
    25a8:	f8 86       	std	Y+8, r15	; 0x08
    25aa:	01 c0       	rjmp	.+2      	; 0x25ae <writeSE2FRAM+0x68>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    25ac:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    25ae:	80 0f       	add	r24, r16
    25b0:	91 1f       	adc	r25, r17
    25b2:	fc 01       	movw	r30, r24
    25b4:	80 81       	ld	r24, Z
    25b6:	8f 83       	std	Y+7, r24	; 0x07
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    25b8:	f9 01       	movw	r30, r18
    25ba:	31 96       	adiw	r30, 0x01	; 1
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    25bc:	e0 0f       	add	r30, r16
    25be:	f1 1f       	adc	r31, r17
    25c0:	80 81       	ld	r24, Z
    25c2:	8e 83       	std	Y+6, r24	; 0x06
	SPICount +=3;
	SPICS(FALSE);
}

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    25c4:	f9 01       	movw	r30, r18
    25c6:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    25c8:	e0 0f       	add	r30, r16
    25ca:	f1 1f       	adc	r31, r17
    25cc:	80 81       	ld	r24, Z
    25ce:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    25d0:	49 81       	ldd	r20, Y+1	; 0x01
    25d2:	5a 81       	ldd	r21, Y+2	; 0x02
    25d4:	6b 81       	ldd	r22, Y+3	; 0x03
    25d6:	7c 81       	ldd	r23, Y+4	; 0x04
    25d8:	8d 81       	ldd	r24, Y+5	; 0x05
    25da:	9e 81       	ldd	r25, Y+6	; 0x06
    25dc:	af 81       	ldd	r26, Y+7	; 0x07
    25de:	b8 85       	ldd	r27, Y+8	; 0x08
    25e0:	84 0f       	add	r24, r20
    25e2:	95 1f       	adc	r25, r21
    25e4:	a6 1f       	adc	r26, r22
    25e6:	b7 1f       	adc	r27, r23
    25e8:	89 83       	std	Y+1, r24	; 0x01
    25ea:	9a 83       	std	Y+2, r25	; 0x02
    25ec:	ab 83       	std	Y+3, r26	; 0x03
    25ee:	bc 83       	std	Y+4, r27	; 0x04
    25f0:	2d 5f       	subi	r18, 0xFD	; 253
    25f2:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    25f4:	2c 30       	cpi	r18, 0x0C	; 12
    25f6:	31 05       	cpc	r19, r1
    25f8:	81 f6       	brne	.-96     	; 0x259a <writeSE2FRAM+0x54>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    25fa:	69 81       	ldd	r22, Y+1	; 0x01
    25fc:	7a 81       	ldd	r23, Y+2	; 0x02
    25fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2600:	9c 81       	ldd	r25, Y+4	; 0x04
    2602:	24 e0       	ldi	r18, 0x04	; 4
    2604:	30 e0       	ldi	r19, 0x00	; 0
    2606:	40 e0       	ldi	r20, 0x00	; 0
    2608:	50 e0       	ldi	r21, 0x00	; 0
    260a:	0e 94 78 38 	call	0x70f0	; 0x70f0 <__divmodsi4>
    260e:	29 83       	std	Y+1, r18	; 0x01
    2610:	3a 83       	std	Y+2, r19	; 0x02
    2612:	4b 83       	std	Y+3, r20	; 0x03
    2614:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2616:	29 81       	ldd	r18, Y+1	; 0x01
    2618:	87 e2       	ldi	r24, 0x27	; 39
    261a:	9e e3       	ldi	r25, 0x3E	; 62
    261c:	20 93 27 3e 	sts	0x3E27, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2620:	2a 81       	ldd	r18, Y+2	; 0x02
    2622:	fc 01       	movw	r30, r24
    2624:	31 97       	sbiw	r30, 0x01	; 1
    2626:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    2628:	2b 81       	ldd	r18, Y+3	; 0x03
    262a:	02 97       	sbiw	r24, 0x02	; 2
    262c:	fc 01       	movw	r30, r24
    262e:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2630:	80 e1       	ldi	r24, 0x10	; 16
    2632:	e0 e4       	ldi	r30, 0x40	; 64
    2634:	f6 e0       	ldi	r31, 0x06	; 6
    2636:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2638:	88 e0       	ldi	r24, 0x08	; 8
    263a:	e0 e2       	ldi	r30, 0x20	; 32
    263c:	f6 e0       	ldi	r31, 0x06	; 6
    263e:	86 83       	std	Z+6, r24	; 0x06
	nop();
    2640:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2642:	86 e0       	ldi	r24, 0x06	; 6
    2644:	e0 ec       	ldi	r30, 0xC0	; 192
    2646:	f8 e0       	ldi	r31, 0x08	; 8
    2648:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    264a:	82 81       	ldd	r24, Z+2	; 0x02
    264c:	88 23       	and	r24, r24
    264e:	ec f7       	brge	.-6      	; 0x264a <writeSE2FRAM+0x104>
	SPIBuffer[12] = SPIC.DATA;
    2650:	e0 ec       	ldi	r30, 0xC0	; 192
    2652:	f8 e0       	ldi	r31, 0x08	; 8
    2654:	83 81       	ldd	r24, Z+3	; 0x03
    2656:	80 93 31 3e 	sts	0x3E31, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    265a:	a0 e2       	ldi	r26, 0x20	; 32
    265c:	b6 e0       	ldi	r27, 0x06	; 6
    265e:	88 e0       	ldi	r24, 0x08	; 8
    2660:	15 96       	adiw	r26, 0x05	; 5
    2662:	8c 93       	st	X, r24
    2664:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    2666:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2668:	16 96       	adiw	r26, 0x06	; 6
    266a:	8c 93       	st	X, r24
    266c:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    266e:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2670:	82 e0       	ldi	r24, 0x02	; 2
    2672:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2674:	82 81       	ldd	r24, Z+2	; 0x02
    2676:	88 23       	and	r24, r24
    2678:	ec f7       	brge	.-6      	; 0x2674 <writeSE2FRAM+0x12e>
	SPIBuffer[12] = SPIC.DATA;
    267a:	e0 ec       	ldi	r30, 0xC0	; 192
    267c:	f8 e0       	ldi	r31, 0x08	; 8
    267e:	83 81       	ldd	r24, Z+3	; 0x03
    2680:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2684:	80 91 23 3e 	lds	r24, 0x3E23
    2688:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    268a:	82 81       	ldd	r24, Z+2	; 0x02
    268c:	88 23       	and	r24, r24
    268e:	ec f7       	brge	.-6      	; 0x268a <writeSE2FRAM+0x144>
	SPIBuffer[12] = SPIC.DATA;
    2690:	e0 ec       	ldi	r30, 0xC0	; 192
    2692:	f8 e0       	ldi	r31, 0x08	; 8
    2694:	83 81       	ldd	r24, Z+3	; 0x03
    2696:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    269a:	80 91 22 3e 	lds	r24, 0x3E22
    269e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    26a0:	82 81       	ldd	r24, Z+2	; 0x02
    26a2:	88 23       	and	r24, r24
    26a4:	ec f7       	brge	.-6      	; 0x26a0 <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    26a6:	e0 ec       	ldi	r30, 0xC0	; 192
    26a8:	f8 e0       	ldi	r31, 0x08	; 8
    26aa:	83 81       	ldd	r24, Z+3	; 0x03
    26ac:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = SPIBuffer[0];
    26b0:	80 91 25 3e 	lds	r24, 0x3E25
    26b4:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    26b6:	82 81       	ldd	r24, Z+2	; 0x02
    26b8:	88 23       	and	r24, r24
    26ba:	ec f7       	brge	.-6      	; 0x26b6 <writeSE2FRAM+0x170>
	SPIBuffer[12] = SPIC.DATA;
    26bc:	e0 ec       	ldi	r30, 0xC0	; 192
    26be:	f8 e0       	ldi	r31, 0x08	; 8
    26c0:	83 81       	ldd	r24, Z+3	; 0x03
    26c2:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = SPIBuffer[1];
    26c6:	80 91 26 3e 	lds	r24, 0x3E26
    26ca:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    26cc:	82 81       	ldd	r24, Z+2	; 0x02
    26ce:	88 23       	and	r24, r24
    26d0:	ec f7       	brge	.-6      	; 0x26cc <writeSE2FRAM+0x186>
	SPIBuffer[12] = SPIC.DATA;
    26d2:	e0 ec       	ldi	r30, 0xC0	; 192
    26d4:	f8 e0       	ldi	r31, 0x08	; 8
    26d6:	83 81       	ldd	r24, Z+3	; 0x03
    26d8:	80 93 31 3e 	sts	0x3E31, r24
	SPIC.DATA = SPIBuffer[2];
    26dc:	80 91 27 3e 	lds	r24, 0x3E27
    26e0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    26e2:	82 81       	ldd	r24, Z+2	; 0x02
    26e4:	88 23       	and	r24, r24
    26e6:	ec f7       	brge	.-6      	; 0x26e2 <writeSE2FRAM+0x19c>
	SPIBuffer[12] = SPIC.DATA;
    26e8:	a0 ec       	ldi	r26, 0xC0	; 192
    26ea:	b8 e0       	ldi	r27, 0x08	; 8
    26ec:	13 96       	adiw	r26, 0x03	; 3
    26ee:	8c 91       	ld	r24, X
    26f0:	13 97       	sbiw	r26, 0x03	; 3
    26f2:	80 93 31 3e 	sts	0x3E31, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    26f6:	88 e0       	ldi	r24, 0x08	; 8
    26f8:	e0 e2       	ldi	r30, 0x20	; 32
    26fa:	f6 e0       	ldi	r31, 0x06	; 6
    26fc:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    26fe:	e0 e4       	ldi	r30, 0x40	; 64
    2700:	f6 e0       	ldi	r31, 0x06	; 6
    2702:	80 e1       	ldi	r24, 0x10	; 16
    2704:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2706:	94 e5       	ldi	r25, 0x54	; 84
    2708:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    270a:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    270c:	80 91 22 3e 	lds	r24, 0x3E22
    2710:	90 91 23 3e 	lds	r25, 0x3E23
    2714:	03 96       	adiw	r24, 0x03	; 3
    2716:	80 93 22 3e 	sts	0x3E22, r24
    271a:	90 93 23 3e 	sts	0x3E23, r25
	checksumADC[0] += SPIBuffer[0];
    271e:	80 91 12 21 	lds	r24, 0x2112
    2722:	e5 e2       	ldi	r30, 0x25	; 37
    2724:	fe e3       	ldi	r31, 0x3E	; 62
    2726:	90 81       	ld	r25, Z
    2728:	89 0f       	add	r24, r25
    272a:	80 93 12 21 	sts	0x2112, r24
	checksumADC[1] += SPIBuffer[1];
    272e:	80 91 13 21 	lds	r24, 0x2113
    2732:	91 81       	ldd	r25, Z+1	; 0x01
    2734:	89 0f       	add	r24, r25
    2736:	80 93 13 21 	sts	0x2113, r24
	checksumADC[2] += SPIBuffer[2];
    273a:	80 91 14 21 	lds	r24, 0x2114
    273e:	92 81       	ldd	r25, Z+2	; 0x02
    2740:	89 0f       	add	r24, r25
    2742:	80 93 14 21 	sts	0x2114, r24
}
    2746:	28 96       	adiw	r28, 0x08	; 8
    2748:	cd bf       	out	0x3d, r28	; 61
    274a:	de bf       	out	0x3e, r29	; 62
    274c:	df 91       	pop	r29
    274e:	cf 91       	pop	r28
    2750:	1f 91       	pop	r17
    2752:	0f 91       	pop	r16
    2754:	ff 90       	pop	r15
    2756:	08 95       	ret

00002758 <FRAMWriteKnowns>:
// 	}
// 	
// }

//test function for FRAM
void FRAMWriteKnowns() {
    2758:	2f 92       	push	r2
    275a:	3f 92       	push	r3
    275c:	4f 92       	push	r4
    275e:	5f 92       	push	r5
    2760:	6f 92       	push	r6
    2762:	7f 92       	push	r7
    2764:	8f 92       	push	r8
    2766:	9f 92       	push	r9
    2768:	af 92       	push	r10
    276a:	bf 92       	push	r11
    276c:	cf 92       	push	r12
    276e:	df 92       	push	r13
    2770:	ef 92       	push	r14
    2772:	ff 92       	push	r15
    2774:	0f 93       	push	r16
    2776:	1f 93       	push	r17
    2778:	cf 93       	push	r28
    277a:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    277c:	10 92 22 3e 	sts	0x3E22, r1
    2780:	10 92 23 3e 	sts	0x3E23, r1
	sampleCount = 0;
    2784:	10 92 6a 50 	sts	0x506A, r1
    2788:	10 92 6b 50 	sts	0x506B, r1
    278c:	10 92 6c 50 	sts	0x506C, r1
    2790:	10 92 6d 50 	sts	0x506D, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2794:	84 e1       	ldi	r24, 0x14	; 20
    2796:	91 e2       	ldi	r25, 0x21	; 33
    2798:	10 92 14 21 	sts	0x2114, r1
    279c:	fc 01       	movw	r30, r24
    279e:	31 97       	sbiw	r30, 0x01	; 1
    27a0:	10 82       	st	Z, r1
    27a2:	02 97       	sbiw	r24, 0x02	; 2
    27a4:	dc 01       	movw	r26, r24
    27a6:	1c 92       	st	X, r1
	
	ADCPower(TRUE);
    27a8:	81 e0       	ldi	r24, 0x01	; 1
    27aa:	0e 94 0c 07 	call	0xe18	; 0xe18 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    27ae:	84 e0       	ldi	r24, 0x04	; 4
    27b0:	0e 94 16 05 	call	0xa2c	; 0xa2c <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    27b4:	80 ed       	ldi	r24, 0xD0	; 208
    27b6:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    27ba:	8d e0       	ldi	r24, 0x0D	; 13
    27bc:	80 93 25 3e 	sts	0x3E25, r24
	SPIBuffer[1] = 0xF3;
    27c0:	83 ef       	ldi	r24, 0xF3	; 243
    27c2:	80 93 26 3e 	sts	0x3E26, r24
	SPIBuffer[2] = 0x57;
    27c6:	87 e5       	ldi	r24, 0x57	; 87
    27c8:	80 93 27 3e 	sts	0x3E27, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    27cc:	80 91 6a 50 	lds	r24, 0x506A
    27d0:	90 91 6b 50 	lds	r25, 0x506B
    27d4:	a0 91 6c 50 	lds	r26, 0x506C
    27d8:	b0 91 6d 50 	lds	r27, 0x506D
    27dc:	83 35       	cpi	r24, 0x53	; 83
    27de:	e5 e5       	ldi	r30, 0x55	; 85
    27e0:	9e 07       	cpc	r25, r30
    27e2:	e0 e0       	ldi	r30, 0x00	; 0
    27e4:	ae 07       	cpc	r26, r30
    27e6:	e0 e0       	ldi	r30, 0x00	; 0
    27e8:	be 07       	cpc	r27, r30
    27ea:	08 f0       	brcs	.+2      	; 0x27ee <FRAMWriteKnowns+0x96>
    27ec:	cc c0       	rjmp	.+408    	; 0x2986 <FRAMWriteKnowns+0x22e>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    27ee:	0f 2e       	mov	r0, r31
    27f0:	f0 e4       	ldi	r31, 0x40	; 64
    27f2:	ef 2e       	mov	r14, r31
    27f4:	f6 e0       	ldi	r31, 0x06	; 6
    27f6:	ff 2e       	mov	r15, r31
    27f8:	f0 2d       	mov	r31, r0
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    27fa:	40 e2       	ldi	r20, 0x20	; 32
    27fc:	56 e0       	ldi	r21, 0x06	; 6
    27fe:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    2800:	e0 ec       	ldi	r30, 0xC0	; 192
    2802:	f8 e0       	ldi	r31, 0x08	; 8
    2804:	0f 2e       	mov	r0, r31
    2806:	f6 e0       	ldi	r31, 0x06	; 6
    2808:	7f 2e       	mov	r7, r31
    280a:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    280c:	c1 e3       	ldi	r28, 0x31	; 49
    280e:	de e3       	ldi	r29, 0x3E	; 62
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    2810:	66 24       	eor	r6, r6
    2812:	68 94       	set
    2814:	61 f8       	bld	r6, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2816:	0f 2e       	mov	r0, r31
    2818:	f2 e2       	ldi	r31, 0x22	; 34
    281a:	cf 2e       	mov	r12, r31
    281c:	fe e3       	ldi	r31, 0x3E	; 62
    281e:	df 2e       	mov	r13, r31
    2820:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    2822:	8e 01       	movw	r16, r28
    2824:	0c 50       	subi	r16, 0x0C	; 12
    2826:	10 40       	sbci	r17, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    2828:	0f 2e       	mov	r0, r31
    282a:	f5 ef       	ldi	r31, 0xF5	; 245
    282c:	4f 2e       	mov	r4, r31
    282e:	ff ef       	ldi	r31, 0xFF	; 255
    2830:	5f 2e       	mov	r5, r31
    2832:	f0 2d       	mov	r31, r0
    2834:	4c 0e       	add	r4, r28
    2836:	5d 1e       	adc	r5, r29
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    2838:	0f 2e       	mov	r0, r31
    283a:	f6 ef       	ldi	r31, 0xF6	; 246
    283c:	2f 2e       	mov	r2, r31
    283e:	ff ef       	ldi	r31, 0xFF	; 255
    2840:	3f 2e       	mov	r3, r31
    2842:	f0 2d       	mov	r31, r0
    2844:	2c 0e       	add	r2, r28
    2846:	3d 1e       	adc	r3, r29
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    2848:	62 e1       	ldi	r22, 0x12	; 18
    284a:	71 e2       	ldi	r23, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    284c:	5b 01       	movw	r10, r22
    284e:	08 94       	sec
    2850:	a1 1c       	adc	r10, r1
    2852:	b1 1c       	adc	r11, r1
		checksumADC[2] += SPIBuffer[2];
    2854:	88 24       	eor	r8, r8
    2856:	99 24       	eor	r9, r9
    2858:	68 94       	set
    285a:	81 f8       	bld	r8, 1
    285c:	86 0e       	add	r8, r22
    285e:	97 1e       	adc	r9, r23
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2860:	30 e1       	ldi	r19, 0x10	; 16
    2862:	d7 01       	movw	r26, r14
    2864:	16 96       	adiw	r26, 0x06	; 6
    2866:	3c 93       	st	X, r19
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2868:	da 01       	movw	r26, r20
    286a:	16 96       	adiw	r26, 0x06	; 6
    286c:	2c 93       	st	X, r18
    286e:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    2870:	00 00       	nop
		SPIC.DATA = FR_WREN;
    2872:	73 82       	std	Z+3, r7	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2874:	82 81       	ldd	r24, Z+2	; 0x02
    2876:	88 23       	and	r24, r24
    2878:	ec f7       	brge	.-6      	; 0x2874 <FRAMWriteKnowns+0x11c>
		SPIBuffer[12] = SPIC.DATA;
    287a:	83 81       	ldd	r24, Z+3	; 0x03
    287c:	88 83       	st	Y, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    287e:	da 01       	movw	r26, r20
    2880:	15 96       	adiw	r26, 0x05	; 5
    2882:	2c 93       	st	X, r18
    2884:	15 97       	sbiw	r26, 0x05	; 5
		nop(); // time for CS_FRAM to accept high signal
    2886:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2888:	16 96       	adiw	r26, 0x06	; 6
    288a:	2c 93       	st	X, r18
    288c:	16 97       	sbiw	r26, 0x06	; 6
		nop();
    288e:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    2890:	63 82       	std	Z+3, r6	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    2892:	82 81       	ldd	r24, Z+2	; 0x02
    2894:	88 23       	and	r24, r24
    2896:	ec f7       	brge	.-6      	; 0x2892 <FRAMWriteKnowns+0x13a>
		SPIBuffer[12] = SPIC.DATA;
    2898:	83 81       	ldd	r24, Z+3	; 0x03
    289a:	88 83       	st	Y, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    289c:	d6 01       	movw	r26, r12
    289e:	11 96       	adiw	r26, 0x01	; 1
    28a0:	8c 91       	ld	r24, X
    28a2:	11 97       	sbiw	r26, 0x01	; 1
    28a4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    28a6:	82 81       	ldd	r24, Z+2	; 0x02
    28a8:	88 23       	and	r24, r24
    28aa:	ec f7       	brge	.-6      	; 0x28a6 <FRAMWriteKnowns+0x14e>
		SPIBuffer[12] = SPIC.DATA;
    28ac:	83 81       	ldd	r24, Z+3	; 0x03
    28ae:	88 83       	st	Y, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    28b0:	d6 01       	movw	r26, r12
    28b2:	8c 91       	ld	r24, X
    28b4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    28b6:	82 81       	ldd	r24, Z+2	; 0x02
    28b8:	88 23       	and	r24, r24
    28ba:	ec f7       	brge	.-6      	; 0x28b6 <FRAMWriteKnowns+0x15e>
		SPIBuffer[12] = SPIC.DATA;
    28bc:	83 81       	ldd	r24, Z+3	; 0x03
    28be:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[0];
    28c0:	d8 01       	movw	r26, r16
    28c2:	8c 91       	ld	r24, X
    28c4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    28c6:	82 81       	ldd	r24, Z+2	; 0x02
    28c8:	88 23       	and	r24, r24
    28ca:	ec f7       	brge	.-6      	; 0x28c6 <FRAMWriteKnowns+0x16e>
		SPIBuffer[12] = SPIC.DATA;
    28cc:	83 81       	ldd	r24, Z+3	; 0x03
    28ce:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[1];
    28d0:	d2 01       	movw	r26, r4
    28d2:	8c 91       	ld	r24, X
    28d4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    28d6:	82 81       	ldd	r24, Z+2	; 0x02
    28d8:	88 23       	and	r24, r24
    28da:	ec f7       	brge	.-6      	; 0x28d6 <FRAMWriteKnowns+0x17e>
		SPIBuffer[12] = SPIC.DATA;
    28dc:	83 81       	ldd	r24, Z+3	; 0x03
    28de:	88 83       	st	Y, r24
		SPIC.DATA = SPIBuffer[2];
    28e0:	d1 01       	movw	r26, r2
    28e2:	8c 91       	ld	r24, X
    28e4:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    28e6:	82 81       	ldd	r24, Z+2	; 0x02
    28e8:	88 23       	and	r24, r24
    28ea:	ec f7       	brge	.-6      	; 0x28e6 <FRAMWriteKnowns+0x18e>
		SPIBuffer[12] = SPIC.DATA;
    28ec:	83 81       	ldd	r24, Z+3	; 0x03
    28ee:	88 83       	st	Y, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    28f0:	da 01       	movw	r26, r20
    28f2:	15 96       	adiw	r26, 0x05	; 5
    28f4:	2c 93       	st	X, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    28f6:	30 e1       	ldi	r19, 0x10	; 16
    28f8:	d7 01       	movw	r26, r14
    28fa:	15 96       	adiw	r26, 0x05	; 5
    28fc:	3c 93       	st	X, r19
		
		FRAMAddress +=3;
    28fe:	80 91 22 3e 	lds	r24, 0x3E22
    2902:	90 91 23 3e 	lds	r25, 0x3E23
    2906:	03 96       	adiw	r24, 0x03	; 3
    2908:	80 93 22 3e 	sts	0x3E22, r24
    290c:	90 93 23 3e 	sts	0x3E23, r25
		checksumADC[0] += SPIBuffer[0];
    2910:	db 01       	movw	r26, r22
    2912:	8c 91       	ld	r24, X
    2914:	d8 01       	movw	r26, r16
    2916:	9c 91       	ld	r25, X
    2918:	89 0f       	add	r24, r25
    291a:	db 01       	movw	r26, r22
    291c:	8c 93       	st	X, r24
		checksumADC[1] += SPIBuffer[1];
    291e:	d5 01       	movw	r26, r10
    2920:	8c 91       	ld	r24, X
    2922:	a6 e2       	ldi	r26, 0x26	; 38
    2924:	be e3       	ldi	r27, 0x3E	; 62
    2926:	9c 91       	ld	r25, X
    2928:	89 0f       	add	r24, r25
    292a:	d5 01       	movw	r26, r10
    292c:	8c 93       	st	X, r24
		checksumADC[2] += SPIBuffer[2];
    292e:	d4 01       	movw	r26, r8
    2930:	8c 91       	ld	r24, X
    2932:	a7 e2       	ldi	r26, 0x27	; 39
    2934:	be e3       	ldi	r27, 0x3E	; 62
    2936:	9c 91       	ld	r25, X
    2938:	89 0f       	add	r24, r25
    293a:	d4 01       	movw	r26, r8
    293c:	8c 93       	st	X, r24
		
		sampleCount++;
    293e:	80 91 6a 50 	lds	r24, 0x506A
    2942:	90 91 6b 50 	lds	r25, 0x506B
    2946:	a0 91 6c 50 	lds	r26, 0x506C
    294a:	b0 91 6d 50 	lds	r27, 0x506D
    294e:	01 96       	adiw	r24, 0x01	; 1
    2950:	a1 1d       	adc	r26, r1
    2952:	b1 1d       	adc	r27, r1
    2954:	80 93 6a 50 	sts	0x506A, r24
    2958:	90 93 6b 50 	sts	0x506B, r25
    295c:	a0 93 6c 50 	sts	0x506C, r26
    2960:	b0 93 6d 50 	sts	0x506D, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    2964:	80 91 6a 50 	lds	r24, 0x506A
    2968:	90 91 6b 50 	lds	r25, 0x506B
    296c:	a0 91 6c 50 	lds	r26, 0x506C
    2970:	b0 91 6d 50 	lds	r27, 0x506D
    2974:	83 35       	cpi	r24, 0x53	; 83
    2976:	35 e5       	ldi	r19, 0x55	; 85
    2978:	93 07       	cpc	r25, r19
    297a:	30 e0       	ldi	r19, 0x00	; 0
    297c:	a3 07       	cpc	r26, r19
    297e:	30 e0       	ldi	r19, 0x00	; 0
    2980:	b3 07       	cpc	r27, r19
    2982:	08 f4       	brcc	.+2      	; 0x2986 <FRAMWriteKnowns+0x22e>
    2984:	6d cf       	rjmp	.-294    	; 0x2860 <FRAMWriteKnowns+0x108>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    2986:	0e 94 45 05 	call	0xa8a	; 0xa8a <SPIDisable>
	ADCPower(FALSE);
    298a:	80 e0       	ldi	r24, 0x00	; 0
    298c:	0e 94 0c 07 	call	0xe18	; 0xe18 <ADCPower>
}
    2990:	df 91       	pop	r29
    2992:	cf 91       	pop	r28
    2994:	1f 91       	pop	r17
    2996:	0f 91       	pop	r16
    2998:	ff 90       	pop	r15
    299a:	ef 90       	pop	r14
    299c:	df 90       	pop	r13
    299e:	cf 90       	pop	r12
    29a0:	bf 90       	pop	r11
    29a2:	af 90       	pop	r10
    29a4:	9f 90       	pop	r9
    29a6:	8f 90       	pop	r8
    29a8:	7f 90       	pop	r7
    29aa:	6f 90       	pop	r6
    29ac:	5f 90       	pop	r5
    29ae:	4f 90       	pop	r4
    29b0:	3f 90       	pop	r3
    29b2:	2f 90       	pop	r2
    29b4:	08 95       	ret

000029b6 <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    29b6:	80 ff       	sbrs	r24, 0
    29b8:	05 c0       	rjmp	.+10     	; 0x29c4 <setADCInput+0xe>
    29ba:	20 e4       	ldi	r18, 0x40	; 64
    29bc:	e0 e0       	ldi	r30, 0x00	; 0
    29be:	f6 e0       	ldi	r31, 0x06	; 6
    29c0:	25 83       	std	Z+5, r18	; 0x05
    29c2:	04 c0       	rjmp	.+8      	; 0x29cc <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    29c4:	20 e4       	ldi	r18, 0x40	; 64
    29c6:	e0 e0       	ldi	r30, 0x00	; 0
    29c8:	f6 e0       	ldi	r31, 0x06	; 6
    29ca:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    29cc:	81 ff       	sbrs	r24, 1
    29ce:	05 c0       	rjmp	.+10     	; 0x29da <setADCInput+0x24>
    29d0:	22 e0       	ldi	r18, 0x02	; 2
    29d2:	e0 e2       	ldi	r30, 0x20	; 32
    29d4:	f6 e0       	ldi	r31, 0x06	; 6
    29d6:	25 83       	std	Z+5, r18	; 0x05
    29d8:	04 c0       	rjmp	.+8      	; 0x29e2 <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    29da:	22 e0       	ldi	r18, 0x02	; 2
    29dc:	e0 e2       	ldi	r30, 0x20	; 32
    29de:	f6 e0       	ldi	r31, 0x06	; 6
    29e0:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    29e2:	82 ff       	sbrs	r24, 2
    29e4:	05 c0       	rjmp	.+10     	; 0x29f0 <setADCInput+0x3a>
    29e6:	84 e0       	ldi	r24, 0x04	; 4
    29e8:	e0 e2       	ldi	r30, 0x20	; 32
    29ea:	f6 e0       	ldi	r31, 0x06	; 6
    29ec:	85 83       	std	Z+5, r24	; 0x05
    29ee:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    29f0:	84 e0       	ldi	r24, 0x04	; 4
    29f2:	e0 e2       	ldi	r30, 0x20	; 32
    29f4:	f6 e0       	ldi	r31, 0x06	; 6
    29f6:	86 83       	std	Z+6, r24	; 0x06
    29f8:	08 95       	ret

000029fa <CO_collectSeismic1Channel_ext>:
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel_ext(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    29fa:	2f 92       	push	r2
    29fc:	3f 92       	push	r3
    29fe:	4f 92       	push	r4
    2a00:	5f 92       	push	r5
    2a02:	7f 92       	push	r7
    2a04:	8f 92       	push	r8
    2a06:	9f 92       	push	r9
    2a08:	af 92       	push	r10
    2a0a:	bf 92       	push	r11
    2a0c:	cf 92       	push	r12
    2a0e:	df 92       	push	r13
    2a10:	ef 92       	push	r14
    2a12:	ff 92       	push	r15
    2a14:	0f 93       	push	r16
    2a16:	1f 93       	push	r17
    2a18:	cf 93       	push	r28
    2a1a:	df 93       	push	r29
    2a1c:	cd b7       	in	r28, 0x3d	; 61
    2a1e:	de b7       	in	r29, 0x3e	; 62
    2a20:	18 2f       	mov	r17, r24
    2a22:	76 2e       	mov	r7, r22
    2a24:	f4 2e       	mov	r15, r20
    2a26:	19 01       	movw	r2, r18
	
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	ADC_BUFFER=DataArray;
    2a28:	89 8d       	ldd	r24, Y+25	; 0x19
    2a2a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2a2c:	80 93 68 50 	sts	0x5068, r24
    2a30:	90 93 69 50 	sts	0x5069, r25
	ADC_Sampling_Finished = 0;
    2a34:	10 92 ab 50 	sts	0x50AB, r1
	ADC_buffer_size = BufferSize;
    2a38:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2a3a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2a3c:	80 93 ac 50 	sts	0x50AC, r24
    2a40:	90 93 ad 50 	sts	0x50AD, r25
	if(use_FRAM){
    2a44:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2a46:	88 23       	and	r24, r24
    2a48:	21 f0       	breq	.+8      	; 0x2a52 <CO_collectSeismic1Channel_ext+0x58>
		write_to_FRAM = 1;
    2a4a:	81 e0       	ldi	r24, 0x01	; 1
    2a4c:	80 93 4d 40 	sts	0x404D, r24
    2a50:	02 c0       	rjmp	.+4      	; 0x2a56 <CO_collectSeismic1Channel_ext+0x5c>
	}
	else{
		write_to_FRAM = 0;
    2a52:	10 92 4d 40 	sts	0x404D, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2a56:	81 e0       	ldi	r24, 0x01	; 1
    2a58:	0e 94 0c 07 	call	0xe18	; 0xe18 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    2a5c:	81 2f       	mov	r24, r17
    2a5e:	6f 2d       	mov	r22, r15
    2a60:	0e 94 19 0b 	call	0x1632	; 0x1632 <set_ampGain>
	set_filter(filterConfig);
    2a64:	87 2d       	mov	r24, r7
    2a66:	0e 94 4f 05 	call	0xa9e	; 0xa9e <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2a6a:	8e 2d       	mov	r24, r14
    2a6c:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2a70:	84 e0       	ldi	r24, 0x04	; 4
    2a72:	0e 94 16 05 	call	0xa2c	; 0xa2c <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2a76:	84 e5       	ldi	r24, 0x54	; 84
    2a78:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2a7c:	81 e0       	ldi	r24, 0x01	; 1
    2a7e:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <enableADCMUX>
	setADCInput(channel);
    2a82:	81 2f       	mov	r24, r17
    2a84:	0e 94 db 14 	call	0x29b6	; 0x29b6 <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2a88:	e0 ea       	ldi	r30, 0xA0	; 160
    2a8a:	f6 e0       	ldi	r31, 0x06	; 6
    2a8c:	22 e0       	ldi	r18, 0x02	; 2
    2a8e:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2a90:	77 24       	eor	r7, r7
    2a92:	73 94       	inc	r7
    2a94:	72 82       	std	Z+2, r7	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2a96:	0f 2e       	mov	r0, r31
    2a98:	f0 e8       	ldi	r31, 0x80	; 128
    2a9a:	4f 2e       	mov	r4, r31
    2a9c:	f1 e0       	ldi	r31, 0x01	; 1
    2a9e:	5f 2e       	mov	r5, r31
    2aa0:	f0 2d       	mov	r31, r0
    2aa2:	88 e7       	ldi	r24, 0x78	; 120
    2aa4:	d2 01       	movw	r26, r4
    2aa6:	8c 93       	st	X, r24

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2aa8:	e0 e0       	ldi	r30, 0x00	; 0
    2aaa:	f9 e0       	ldi	r31, 0x09	; 9
    2aac:	80 ef       	ldi	r24, 0xF0	; 240
    2aae:	81 83       	std	Z+1, r24	; 0x01
	TCD0.CCA = averagingPtA;
    2ab0:	c0 a6       	lds	r28, 0xb0
    2ab2:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    2ab4:	a2 a6       	lds	r26, 0xb2
    2ab6:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    2ab8:	84 a6       	lds	r24, 0xb4
    2aba:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    2abc:	8d 89       	ldd	r24, Y+21	; 0x15
    2abe:	9e 89       	ldd	r25, Y+22	; 0x16
    2ac0:	86 a7       	lds	r24, 0x76
    2ac2:	97 a7       	lds	r25, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    2ac4:	80 2f       	mov	r24, r16
    2ac6:	90 e0       	ldi	r25, 0x00	; 0
    2ac8:	01 97       	sbiw	r24, 0x01	; 1
    2aca:	86 a3       	lds	r24, 0x56
    2acc:	97 a3       	lds	r25, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2ace:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2ad0:	8f ef       	ldi	r24, 0xFF	; 255
    2ad2:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2ad4:	80 81       	ld	r24, Z
    2ad6:	80 7f       	andi	r24, 0xF0	; 240
    2ad8:	88 60       	ori	r24, 0x08	; 8
    2ada:	80 83       	st	Z, r24

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    2adc:	10 92 6a 50 	sts	0x506A, r1
    2ae0:	10 92 6b 50 	sts	0x506B, r1
    2ae4:	10 92 6c 50 	sts	0x506C, r1
    2ae8:	10 92 6d 50 	sts	0x506D, r1
	SPICount = 0;
    2aec:	10 92 a5 50 	sts	0x50A5, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2af0:	80 e2       	ldi	r24, 0x20	; 32
    2af2:	e0 e8       	ldi	r30, 0x80	; 128
    2af4:	f6 e0       	ldi	r31, 0x06	; 6
    2af6:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2af8:	00 e4       	ldi	r16, 0x40	; 64
    2afa:	1a e0       	ldi	r17, 0x0A	; 10
    2afc:	83 e2       	ldi	r24, 0x23	; 35
    2afe:	f8 01       	movw	r30, r16
    2b00:	81 83       	std	Z+1, r24	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2b02:	61 01       	movw	r12, r2
    2b04:	ee 24       	eor	r14, r14
    2b06:	ff 24       	eor	r15, r15
    2b08:	60 e8       	ldi	r22, 0x80	; 128
    2b0a:	74 e8       	ldi	r23, 0x84	; 132
    2b0c:	8e e1       	ldi	r24, 0x1E	; 30
    2b0e:	90 e0       	ldi	r25, 0x00	; 0
    2b10:	a7 01       	movw	r20, r14
    2b12:	96 01       	movw	r18, r12
    2b14:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    2b18:	d8 01       	movw	r26, r16
    2b1a:	96 96       	adiw	r26, 0x26	; 38
    2b1c:	2d 93       	st	X+, r18
    2b1e:	3c 93       	st	X, r19
    2b20:	97 97       	sbiw	r26, 0x27	; 39
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2b22:	60 e4       	ldi	r22, 0x40	; 64
    2b24:	72 e4       	ldi	r23, 0x42	; 66
    2b26:	8f e0       	ldi	r24, 0x0F	; 15
    2b28:	90 e0       	ldi	r25, 0x00	; 0
    2b2a:	a7 01       	movw	r20, r14
    2b2c:	96 01       	movw	r18, r12
    2b2e:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    2b32:	f8 01       	movw	r30, r16
    2b34:	22 af       	sts	0x72, r18
    2b36:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2b38:	e0 e4       	ldi	r30, 0x40	; 64
    2b3a:	f8 e0       	ldi	r31, 0x08	; 8
    2b3c:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;	
    2b3e:	8c e0       	ldi	r24, 0x0C	; 12
    2b40:	81 87       	std	Z+9, r24	; 0x09
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2b42:	8f 89       	ldd	r24, Y+23	; 0x17
    2b44:	98 8d       	ldd	r25, Y+24	; 0x18
    2b46:	86 a3       	lds	r24, 0x56
    2b48:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCD0_OVF_gc;
    2b4a:	80 ed       	ldi	r24, 0xD0	; 208
    2b4c:	d2 01       	movw	r26, r4
    2b4e:	11 96       	adiw	r26, 0x01	; 1
    2b50:	8c 93       	st	X, r24
    2b52:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2b54:	76 82       	std	Z+6, r7	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2b56:	80 81       	ld	r24, Z
    2b58:	80 7f       	andi	r24, 0xF0	; 240
    2b5a:	89 60       	ori	r24, 0x09	; 9
    2b5c:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2b5e:	f8 01       	movw	r30, r16
    2b60:	80 81       	ld	r24, Z
    2b62:	80 7f       	andi	r24, 0xF0	; 240
    2b64:	81 60       	ori	r24, 0x01	; 1
    2b66:	80 83       	st	Z, r24
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm;
    2b68:	e0 ea       	ldi	r30, 0xA0	; 160
    2b6a:	f0 e0       	ldi	r31, 0x00	; 0
    2b6c:	82 81       	ldd	r24, Z+2	; 0x02
    2b6e:	87 60       	ori	r24, 0x07	; 7
    2b70:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2b72:	78 94       	sei
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	
}
    2b74:	df 91       	pop	r29
    2b76:	cf 91       	pop	r28
    2b78:	1f 91       	pop	r17
    2b7a:	0f 91       	pop	r16
    2b7c:	ff 90       	pop	r15
    2b7e:	ef 90       	pop	r14
    2b80:	df 90       	pop	r13
    2b82:	cf 90       	pop	r12
    2b84:	bf 90       	pop	r11
    2b86:	af 90       	pop	r10
    2b88:	9f 90       	pop	r9
    2b8a:	8f 90       	pop	r8
    2b8c:	7f 90       	pop	r7
    2b8e:	5f 90       	pop	r5
    2b90:	4f 90       	pop	r4
    2b92:	3f 90       	pop	r3
    2b94:	2f 90       	pop	r2
    2b96:	08 95       	ret

00002b98 <CO_collectSeismic1Channel>:
	sampleCount++;

}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA,
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2b98:	2f 92       	push	r2
    2b9a:	3f 92       	push	r3
    2b9c:	4f 92       	push	r4
    2b9e:	5f 92       	push	r5
    2ba0:	6f 92       	push	r6
    2ba2:	7f 92       	push	r7
    2ba4:	8f 92       	push	r8
    2ba6:	9f 92       	push	r9
    2ba8:	af 92       	push	r10
    2baa:	bf 92       	push	r11
    2bac:	cf 92       	push	r12
    2bae:	df 92       	push	r13
    2bb0:	ef 92       	push	r14
    2bb2:	ff 92       	push	r15
    2bb4:	0f 93       	push	r16
    2bb6:	cf 93       	push	r28
    2bb8:	df 93       	push	r29
    2bba:	0f 92       	push	r0
    2bbc:	0f 92       	push	r0
    2bbe:	cd b7       	in	r28, 0x3d	; 61
    2bc0:	de b7       	in	r29, 0x3e	; 62
    2bc2:	96 2f       	mov	r25, r22
    2bc4:	49 83       	std	Y+1, r20	; 0x01
    2bc6:	5a 83       	std	Y+2, r21	; 0x02
    2bc8:	52 2f       	mov	r21, r18
    2bca:	70 2f       	mov	r23, r16
    2bcc:	37 01       	movw	r6, r14
    2bce:	26 01       	movw	r4, r12
    2bd0:	15 01       	movw	r2, r10
	
	CO_collectSeismic1Channel_ext(channel, (uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond, subsamplesPerSample, DCPassEnable, averagingPtA,
    2bd2:	2d b7       	in	r18, 0x3d	; 61
    2bd4:	3e b7       	in	r19, 0x3e	; 62
    2bd6:	29 50       	subi	r18, 0x09	; 9
    2bd8:	30 40       	sbci	r19, 0x00	; 0
    2bda:	2d bf       	out	0x3d, r18	; 61
    2bdc:	3e bf       	out	0x3e, r19	; 62
    2bde:	ed b7       	in	r30, 0x3d	; 61
    2be0:	fe b7       	in	r31, 0x3e	; 62
    2be2:	31 96       	adiw	r30, 0x01	; 1
    2be4:	ad b7       	in	r26, 0x3d	; 61
    2be6:	be b7       	in	r27, 0x3e	; 62
    2be8:	11 96       	adiw	r26, 0x01	; 1
    2bea:	8d 92       	st	X+, r8
    2bec:	9c 92       	st	X, r9
    2bee:	12 97       	sbiw	r26, 0x02	; 2
    2bf0:	2f 89       	ldd	r18, Y+23	; 0x17
    2bf2:	38 8d       	ldd	r19, Y+24	; 0x18
    2bf4:	22 83       	std	Z+2, r18	; 0x02
    2bf6:	33 83       	std	Z+3, r19	; 0x03
    2bf8:	29 8d       	ldd	r18, Y+25	; 0x19
    2bfa:	3a 8d       	ldd	r19, Y+26	; 0x1a
    2bfc:	24 83       	std	Z+4, r18	; 0x04
    2bfe:	35 83       	std	Z+5, r19	; 0x05
    2c00:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2c02:	3c 8d       	ldd	r19, Y+28	; 0x1c
    2c04:	26 83       	std	Z+6, r18	; 0x06
    2c06:	37 83       	std	Z+7, r19	; 0x07
    2c08:	2d 8d       	ldd	r18, Y+29	; 0x1d
    2c0a:	20 87       	std	Z+8, r18	; 0x08
    2c0c:	64 ec       	ldi	r22, 0xC4	; 196
    2c0e:	49 2f       	mov	r20, r25
    2c10:	29 81       	ldd	r18, Y+1	; 0x01
    2c12:	3a 81       	ldd	r19, Y+2	; 0x02
    2c14:	05 2f       	mov	r16, r21
    2c16:	e7 2e       	mov	r14, r23
    2c18:	63 01       	movw	r12, r6
    2c1a:	52 01       	movw	r10, r4
    2c1c:	41 01       	movw	r8, r2
    2c1e:	0e 94 fd 14 	call	0x29fa	; 0x29fa <CO_collectSeismic1Channel_ext>
    2c22:	2d b7       	in	r18, 0x3d	; 61
    2c24:	3e b7       	in	r19, 0x3e	; 62
    2c26:	27 5f       	subi	r18, 0xF7	; 247
    2c28:	3f 4f       	sbci	r19, 0xFF	; 255
    2c2a:	2d bf       	out	0x3d, r18	; 61
    2c2c:	3e bf       	out	0x3e, r19	; 62
	averagingPtB, averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}
    2c2e:	0f 90       	pop	r0
    2c30:	0f 90       	pop	r0
    2c32:	df 91       	pop	r29
    2c34:	cf 91       	pop	r28
    2c36:	0f 91       	pop	r16
    2c38:	ff 90       	pop	r15
    2c3a:	ef 90       	pop	r14
    2c3c:	df 90       	pop	r13
    2c3e:	cf 90       	pop	r12
    2c40:	bf 90       	pop	r11
    2c42:	af 90       	pop	r10
    2c44:	9f 90       	pop	r9
    2c46:	8f 90       	pop	r8
    2c48:	7f 90       	pop	r7
    2c4a:	6f 90       	pop	r6
    2c4c:	5f 90       	pop	r5
    2c4e:	4f 90       	pop	r4
    2c50:	3f 90       	pop	r3
    2c52:	2f 90       	pop	r2
    2c54:	08 95       	ret

00002c56 <CO_collectSeismic3Axises_ext>:
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}	
void CO_collectSeismic3Axises_ext(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2c56:	2f 92       	push	r2
    2c58:	3f 92       	push	r3
    2c5a:	5f 92       	push	r5
    2c5c:	6f 92       	push	r6
    2c5e:	7f 92       	push	r7
    2c60:	8f 92       	push	r8
    2c62:	9f 92       	push	r9
    2c64:	af 92       	push	r10
    2c66:	bf 92       	push	r11
    2c68:	cf 92       	push	r12
    2c6a:	df 92       	push	r13
    2c6c:	ef 92       	push	r14
    2c6e:	ff 92       	push	r15
    2c70:	0f 93       	push	r16
    2c72:	1f 93       	push	r17
    2c74:	cf 93       	push	r28
    2c76:	df 93       	push	r29
    2c78:	0f 92       	push	r0
    2c7a:	0f 92       	push	r0
    2c7c:	cd b7       	in	r28, 0x3d	; 61
    2c7e:	de b7       	in	r29, 0x3e	; 62
    2c80:	18 2f       	mov	r17, r24
    2c82:	3b 01       	movw	r6, r22
    2c84:	49 83       	std	Y+1, r20	; 0x01
    2c86:	5a 83       	std	Y+2, r21	; 0x02
    2c88:	52 2e       	mov	r5, r18
	
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	ADC_BUFFER = DataArray;
    2c8a:	89 8d       	ldd	r24, Y+25	; 0x19
    2c8c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2c8e:	80 93 68 50 	sts	0x5068, r24
    2c92:	90 93 69 50 	sts	0x5069, r25
	ADC_Sampling_Finished = 0;
    2c96:	10 92 ab 50 	sts	0x50AB, r1
	ADC_buffer_size = BufferSize;
    2c9a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2c9c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2c9e:	80 93 ac 50 	sts	0x50AC, r24
    2ca2:	90 93 ad 50 	sts	0x50AD, r25
	if(use_FRAM){
    2ca6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2ca8:	88 23       	and	r24, r24
    2caa:	21 f0       	breq	.+8      	; 0x2cb4 <CO_collectSeismic3Axises_ext+0x5e>
		write_to_FRAM = 1;
    2cac:	81 e0       	ldi	r24, 0x01	; 1
    2cae:	80 93 4d 40 	sts	0x404D, r24
    2cb2:	02 c0       	rjmp	.+4      	; 0x2cb8 <CO_collectSeismic3Axises_ext+0x62>
	}
	else{
		write_to_FRAM = 0;
    2cb4:	10 92 4d 40 	sts	0x404D, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2cb8:	81 e0       	ldi	r24, 0x01	; 1
    2cba:	0e 94 0c 07 	call	0xe18	; 0xe18 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    2cbe:	85 e0       	ldi	r24, 0x05	; 5
    2cc0:	d3 01       	movw	r26, r6
    2cc2:	6c 91       	ld	r22, X
    2cc4:	0e 94 19 0b 	call	0x1632	; 0x1632 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    2cc8:	86 e0       	ldi	r24, 0x06	; 6
    2cca:	f3 01       	movw	r30, r6
    2ccc:	61 81       	ldd	r22, Z+1	; 0x01
    2cce:	0e 94 19 0b 	call	0x1632	; 0x1632 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    2cd2:	87 e0       	ldi	r24, 0x07	; 7
    2cd4:	d3 01       	movw	r26, r6
    2cd6:	12 96       	adiw	r26, 0x02	; 2
    2cd8:	6c 91       	ld	r22, X
    2cda:	0e 94 19 0b 	call	0x1632	; 0x1632 <set_ampGain>
	set_filter(filterConfig);
    2cde:	81 2f       	mov	r24, r17
    2ce0:	0e 94 4f 05 	call	0xa9e	; 0xa9e <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    2ce4:	80 2f       	mov	r24, r16
    2ce6:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2cea:	84 e0       	ldi	r24, 0x04	; 4
    2cec:	0e 94 16 05 	call	0xa2c	; 0xa2c <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2cf0:	84 e5       	ldi	r24, 0x54	; 84
    2cf2:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    2cf6:	81 e0       	ldi	r24, 0x01	; 1
    2cf8:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    2cfc:	85 e0       	ldi	r24, 0x05	; 5
    2cfe:	0e 94 db 14 	call	0x29b6	; 0x29b6 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    2d02:	e0 ea       	ldi	r30, 0xA0	; 160
    2d04:	f6 e0       	ldi	r31, 0x06	; 6
    2d06:	22 e0       	ldi	r18, 0x02	; 2
    2d08:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    2d0a:	66 24       	eor	r6, r6
    2d0c:	63 94       	inc	r6
    2d0e:	62 82       	std	Z+2, r6	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2d10:	0f 2e       	mov	r0, r31
    2d12:	f0 e8       	ldi	r31, 0x80	; 128
    2d14:	2f 2e       	mov	r2, r31
    2d16:	f1 e0       	ldi	r31, 0x01	; 1
    2d18:	3f 2e       	mov	r3, r31
    2d1a:	f0 2d       	mov	r31, r0
    2d1c:	88 e7       	ldi	r24, 0x78	; 120
    2d1e:	f1 01       	movw	r30, r2
    2d20:	80 83       	st	Z, r24

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2d22:	e0 e0       	ldi	r30, 0x00	; 0
    2d24:	f8 e0       	ldi	r31, 0x08	; 8
    2d26:	80 ef       	ldi	r24, 0xF0	; 240
    2d28:	81 83       	std	Z+1, r24	; 0x01
	TCC0.CCA = averagingPtA;
    2d2a:	e0 a6       	lds	r30, 0xb0
    2d2c:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    2d2e:	c2 a6       	lds	r28, 0xb2
    2d30:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    2d32:	a4 a6       	lds	r26, 0xb4
    2d34:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    2d36:	86 a6       	lds	r24, 0xb6
    2d38:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    2d3a:	85 2d       	mov	r24, r5
    2d3c:	90 e0       	ldi	r25, 0x00	; 0
    2d3e:	01 97       	sbiw	r24, 0x01	; 1
    2d40:	86 a3       	lds	r24, 0x56
    2d42:	97 a3       	lds	r25, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2d44:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2d46:	8f ef       	ldi	r24, 0xFF	; 255
    2d48:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2d4a:	80 81       	ld	r24, Z
    2d4c:	80 7f       	andi	r24, 0xF0	; 240
    2d4e:	88 60       	ori	r24, 0x08	; 8
    2d50:	80 83       	st	Z, r24

	sampleCount = 0;
    2d52:	10 92 6a 50 	sts	0x506A, r1
    2d56:	10 92 6b 50 	sts	0x506B, r1
    2d5a:	10 92 6c 50 	sts	0x506C, r1
    2d5e:	10 92 6d 50 	sts	0x506D, r1
	SPICount = 0;
    2d62:	10 92 a5 50 	sts	0x50A5, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    2d66:	84 e1       	ldi	r24, 0x14	; 20
    2d68:	91 e2       	ldi	r25, 0x21	; 33
    2d6a:	10 92 14 21 	sts	0x2114, r1
    2d6e:	fc 01       	movw	r30, r24
    2d70:	31 97       	sbiw	r30, 0x01	; 1
    2d72:	10 82       	st	Z, r1
    2d74:	02 97       	sbiw	r24, 0x02	; 2
    2d76:	dc 01       	movw	r26, r24
    2d78:	1c 92       	st	X, r1

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2d7a:	80 e2       	ldi	r24, 0x20	; 32
    2d7c:	e0 e8       	ldi	r30, 0x80	; 128
    2d7e:	f6 e0       	ldi	r31, 0x06	; 6
    2d80:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2d82:	00 e4       	ldi	r16, 0x40	; 64
    2d84:	1a e0       	ldi	r17, 0x0A	; 10
    2d86:	83 e2       	ldi	r24, 0x23	; 35
    2d88:	f8 01       	movw	r30, r16
    2d8a:	81 83       	std	Z+1, r24	; 0x01
	// set period of waveform generator and duty cycle (want duty cycle to be half the period to get clean clock signal)
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    2d8c:	89 81       	ldd	r24, Y+1	; 0x01
    2d8e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d90:	6c 01       	movw	r12, r24
    2d92:	ee 24       	eor	r14, r14
    2d94:	ff 24       	eor	r15, r15
    2d96:	60 e8       	ldi	r22, 0x80	; 128
    2d98:	74 e8       	ldi	r23, 0x84	; 132
    2d9a:	8e e1       	ldi	r24, 0x1E	; 30
    2d9c:	90 e0       	ldi	r25, 0x00	; 0
    2d9e:	a7 01       	movw	r20, r14
    2da0:	96 01       	movw	r18, r12
    2da2:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    2da6:	d8 01       	movw	r26, r16
    2da8:	96 96       	adiw	r26, 0x26	; 38
    2daa:	2d 93       	st	X+, r18
    2dac:	3c 93       	st	X, r19
    2dae:	97 97       	sbiw	r26, 0x27	; 39
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    2db0:	60 e4       	ldi	r22, 0x40	; 64
    2db2:	72 e4       	ldi	r23, 0x42	; 66
    2db4:	8f e0       	ldi	r24, 0x0F	; 15
    2db6:	90 e0       	ldi	r25, 0x00	; 0
    2db8:	a7 01       	movw	r20, r14
    2dba:	96 01       	movw	r18, r12
    2dbc:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    2dc0:	f8 01       	movw	r30, r16
    2dc2:	22 af       	sts	0x72, r18
    2dc4:	33 af       	sts	0x73, r19
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2dc6:	e0 e4       	ldi	r30, 0x40	; 64
    2dc8:	f8 e0       	ldi	r31, 0x08	; 8
    2dca:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;	
    2dcc:	8c e0       	ldi	r24, 0x0C	; 12
    2dce:	81 87       	std	Z+9, r24	; 0x09
	//set the period as number of samples to know when to stop sampling
	TCC1.PER = numOfSamples;
    2dd0:	8f 89       	ldd	r24, Y+23	; 0x17
    2dd2:	98 8d       	ldd	r25, Y+24	; 0x18
    2dd4:	86 a3       	lds	r24, 0x56
    2dd6:	97 a3       	lds	r25, 0x57
	//Configure IO13(PF0) to drive event channel that triggers event every time the 4 samples are collected and averaged
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
    2dd8:	80 ec       	ldi	r24, 0xC0	; 192
    2dda:	d1 01       	movw	r26, r2
    2ddc:	11 96       	adiw	r26, 0x01	; 1
    2dde:	8c 93       	st	X, r24
    2de0:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2de2:	66 82       	std	Z+6, r6	; 0x06
	//set event system to update counter of number of samples every sample event
	TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
    2de4:	80 81       	ld	r24, Z
    2de6:	80 7f       	andi	r24, 0xF0	; 240
    2de8:	89 60       	ori	r24, 0x09	; 9
    2dea:	80 83       	st	Z, r24
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2dec:	f8 01       	movw	r30, r16
    2dee:	80 81       	ld	r24, Z
    2df0:	80 7f       	andi	r24, 0xF0	; 240
    2df2:	81 60       	ori	r24, 0x01	; 1
    2df4:	80 83       	st	Z, r24
	
	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm);
    2df6:	e0 ea       	ldi	r30, 0xA0	; 160
    2df8:	f0 e0       	ldi	r31, 0x00	; 0
    2dfa:	82 81       	ldd	r24, Z+2	; 0x02
    2dfc:	87 60       	ori	r24, 0x07	; 7
    2dfe:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2e00:	78 94       	sei
// 
// 	SPICS(FALSE);
// 	SPIDisable();
// 	enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    2e02:	0f 90       	pop	r0
    2e04:	0f 90       	pop	r0
    2e06:	df 91       	pop	r29
    2e08:	cf 91       	pop	r28
    2e0a:	1f 91       	pop	r17
    2e0c:	0f 91       	pop	r16
    2e0e:	ff 90       	pop	r15
    2e10:	ef 90       	pop	r14
    2e12:	df 90       	pop	r13
    2e14:	cf 90       	pop	r12
    2e16:	bf 90       	pop	r11
    2e18:	af 90       	pop	r10
    2e1a:	9f 90       	pop	r9
    2e1c:	8f 90       	pop	r8
    2e1e:	7f 90       	pop	r7
    2e20:	6f 90       	pop	r6
    2e22:	5f 90       	pop	r5
    2e24:	3f 90       	pop	r3
    2e26:	2f 90       	pop	r2
    2e28:	08 95       	ret

00002e2a <CO_collectSeismic3Axises>:
	ADCPower(FALSE);
	
}*/
void CO_collectSeismic3Axises(uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2e2a:	2f 92       	push	r2
    2e2c:	3f 92       	push	r3
    2e2e:	4f 92       	push	r4
    2e30:	5f 92       	push	r5
    2e32:	6f 92       	push	r6
    2e34:	7f 92       	push	r7
    2e36:	8f 92       	push	r8
    2e38:	9f 92       	push	r9
    2e3a:	af 92       	push	r10
    2e3c:	bf 92       	push	r11
    2e3e:	cf 92       	push	r12
    2e40:	df 92       	push	r13
    2e42:	ef 92       	push	r14
    2e44:	ff 92       	push	r15
    2e46:	0f 93       	push	r16
    2e48:	1f 93       	push	r17
    2e4a:	cf 93       	push	r28
    2e4c:	df 93       	push	r29
    2e4e:	00 d0       	rcall	.+0      	; 0x2e50 <CO_collectSeismic3Axises+0x26>
    2e50:	0f 92       	push	r0
    2e52:	cd b7       	in	r28, 0x3d	; 61
    2e54:	de b7       	in	r29, 0x3e	; 62
    2e56:	dc 01       	movw	r26, r24
    2e58:	3b 01       	movw	r6, r22
    2e5a:	94 2f       	mov	r25, r20
    2e5c:	32 2f       	mov	r19, r18
    2e5e:	28 01       	movw	r4, r16
    2e60:	17 01       	movw	r2, r14
    2e62:	c9 82       	std	Y+1, r12	; 0x01
    2e64:	da 82       	std	Y+2, r13	; 0x02
    2e66:	ab 82       	std	Y+3, r10	; 0x03
    2e68:	bc 82       	std	Y+4, r11	; 0x04
	
	CO_collectSeismic3Axises_ext((uint8_t) (FILTER_CH_3AND7_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gain, subsamplesPerSecond,
    2e6a:	4d b7       	in	r20, 0x3d	; 61
    2e6c:	5e b7       	in	r21, 0x3e	; 62
    2e6e:	47 50       	subi	r20, 0x07	; 7
    2e70:	50 40       	sbci	r21, 0x00	; 0
    2e72:	4d bf       	out	0x3d, r20	; 61
    2e74:	5e bf       	out	0x3e, r21	; 62
    2e76:	6d b7       	in	r22, 0x3d	; 61
    2e78:	7e b7       	in	r23, 0x3e	; 62
    2e7a:	6f 5f       	subi	r22, 0xFF	; 255
    2e7c:	7f 4f       	sbci	r23, 0xFF	; 255
    2e7e:	ed b7       	in	r30, 0x3d	; 61
    2e80:	fe b7       	in	r31, 0x3e	; 62
    2e82:	81 82       	std	Z+1, r8	; 0x01
    2e84:	92 82       	std	Z+2, r9	; 0x02
    2e86:	4a 8d       	ldd	r20, Y+26	; 0x1a
    2e88:	5b 8d       	ldd	r21, Y+27	; 0x1b
    2e8a:	fb 01       	movw	r30, r22
    2e8c:	42 83       	std	Z+2, r20	; 0x02
    2e8e:	53 83       	std	Z+3, r21	; 0x03
    2e90:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2e92:	5d 8d       	ldd	r21, Y+29	; 0x1d
    2e94:	44 83       	std	Z+4, r20	; 0x04
    2e96:	55 83       	std	Z+5, r21	; 0x05
    2e98:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2e9a:	86 83       	std	Z+6, r24	; 0x06
    2e9c:	84 ec       	ldi	r24, 0xC4	; 196
    2e9e:	bd 01       	movw	r22, r26
    2ea0:	a3 01       	movw	r20, r6
    2ea2:	29 2f       	mov	r18, r25
    2ea4:	03 2f       	mov	r16, r19
    2ea6:	72 01       	movw	r14, r4
    2ea8:	61 01       	movw	r12, r2
    2eaa:	a9 80       	ldd	r10, Y+1	; 0x01
    2eac:	ba 80       	ldd	r11, Y+2	; 0x02
    2eae:	8b 80       	ldd	r8, Y+3	; 0x03
    2eb0:	9c 80       	ldd	r9, Y+4	; 0x04
    2eb2:	0e 94 2b 16 	call	0x2c56	; 0x2c56 <CO_collectSeismic3Axises_ext>
    2eb6:	4d b7       	in	r20, 0x3d	; 61
    2eb8:	5e b7       	in	r21, 0x3e	; 62
    2eba:	49 5f       	subi	r20, 0xF9	; 249
    2ebc:	5f 4f       	sbci	r21, 0xFF	; 255
    2ebe:	4d bf       	out	0x3d, r20	; 61
    2ec0:	5e bf       	out	0x3e, r21	; 62
	subsamplesPerChannel, DCPassEnable, averagingPtA, averagingPtB,
	averagingPtC, averagingPtD, numOfSamples, DataArray, BufferSize, use_FRAM);
}	
    2ec2:	24 96       	adiw	r28, 0x04	; 4
    2ec4:	cd bf       	out	0x3d, r28	; 61
    2ec6:	de bf       	out	0x3e, r29	; 62
    2ec8:	df 91       	pop	r29
    2eca:	cf 91       	pop	r28
    2ecc:	1f 91       	pop	r17
    2ece:	0f 91       	pop	r16
    2ed0:	ff 90       	pop	r15
    2ed2:	ef 90       	pop	r14
    2ed4:	df 90       	pop	r13
    2ed6:	cf 90       	pop	r12
    2ed8:	bf 90       	pop	r11
    2eda:	af 90       	pop	r10
    2edc:	9f 90       	pop	r9
    2ede:	8f 90       	pop	r8
    2ee0:	7f 90       	pop	r7
    2ee2:	6f 90       	pop	r6
    2ee4:	5f 90       	pop	r5
    2ee6:	4f 90       	pop	r4
    2ee8:	3f 90       	pop	r3
    2eea:	2f 90       	pop	r2
    2eec:	08 95       	ret

00002eee <CO_collectADC_ext>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC_ext(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    2eee:	6f 92       	push	r6
    2ef0:	7f 92       	push	r7
    2ef2:	8f 92       	push	r8
    2ef4:	9f 92       	push	r9
    2ef6:	af 92       	push	r10
    2ef8:	bf 92       	push	r11
    2efa:	cf 92       	push	r12
    2efc:	df 92       	push	r13
    2efe:	ef 92       	push	r14
    2f00:	ff 92       	push	r15
    2f02:	0f 93       	push	r16
    2f04:	1f 93       	push	r17
    2f06:	cf 93       	push	r28
    2f08:	df 93       	push	r29
    2f0a:	c8 2f       	mov	r28, r24
    2f0c:	b6 2e       	mov	r11, r22
    2f0e:	d4 2f       	mov	r29, r20
    2f10:	49 01       	movw	r8, r18
    2f12:	38 01       	movw	r6, r16
// 	#ifndef F_CPU
// 	#define F_CPU 32000000UL
// 	#endif
	
	uint16_t period;
	ADC_BUFFER = DataArray;
    2f14:	e0 92 68 50 	sts	0x5068, r14
    2f18:	f0 92 69 50 	sts	0x5069, r15
	ADC_Sampling_Finished = 0;
    2f1c:	10 92 ab 50 	sts	0x50AB, r1
	ADC_buffer_size = BufferSize;
    2f20:	c0 92 ac 50 	sts	0x50AC, r12
    2f24:	d0 92 ad 50 	sts	0x50AD, r13
	if(use_FRAM){
    2f28:	aa 20       	and	r10, r10
    2f2a:	21 f0       	breq	.+8      	; 0x2f34 <CO_collectADC_ext+0x46>
		write_to_FRAM = 1;
    2f2c:	81 e0       	ldi	r24, 0x01	; 1
    2f2e:	80 93 4d 40 	sts	0x404D, r24
    2f32:	02 c0       	rjmp	.+4      	; 0x2f38 <CO_collectADC_ext+0x4a>
	}
	else{
		write_to_FRAM = 0;
    2f34:	10 92 4d 40 	sts	0x404D, r1
	}
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2f38:	81 e0       	ldi	r24, 0x01	; 1
    2f3a:	0e 94 0c 07 	call	0xe18	; 0xe18 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    2f3e:	8c 2f       	mov	r24, r28
    2f40:	6d 2f       	mov	r22, r29
    2f42:	0e 94 19 0b 	call	0x1632	; 0x1632 <set_ampGain>
	set_filter(filterConfig);
    2f46:	8b 2d       	mov	r24, r11
    2f48:	0e 94 4f 05 	call	0xa9e	; 0xa9e <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    2f4c:	8c 2f       	mov	r24, r28
    2f4e:	85 50       	subi	r24, 0x05	; 5
    2f50:	83 30       	cpi	r24, 0x03	; 3
    2f52:	18 f4       	brcc	.+6      	; 0x2f5a <CO_collectADC_ext+0x6c>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    2f54:	81 e0       	ldi	r24, 0x01	; 1
    2f56:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    2f5a:	81 e0       	ldi	r24, 0x01	; 1
    2f5c:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <enableADCMUX>
	setADCInput(channel);
    2f60:	8c 2f       	mov	r24, r28
    2f62:	0e 94 db 14 	call	0x29b6	; 0x29b6 <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    2f66:	84 e0       	ldi	r24, 0x04	; 4
    2f68:	0e 94 16 05 	call	0xa2c	; 0xa2c <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2f6c:	84 e5       	ldi	r24, 0x54	; 84
    2f6e:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    2f72:	e0 ea       	ldi	r30, 0xA0	; 160
    2f74:	f6 e0       	ldi	r31, 0x06	; 6
    2f76:	ee 24       	eor	r14, r14
    2f78:	e3 94       	inc	r14
    2f7a:	e2 82       	std	Z+2, r14	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    2f7c:	82 e0       	ldi	r24, 0x02	; 2
    2f7e:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    2f80:	e2 86       	std	Z+10, r14	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_MED_gc;				
    2f82:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    2f84:	80 e2       	ldi	r24, 0x20	; 32
    2f86:	e0 e8       	ldi	r30, 0x80	; 128
    2f88:	f6 e0       	ldi	r31, 0x06	; 6
    2f8a:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2f8c:	c0 e4       	ldi	r28, 0x40	; 64
    2f8e:	da e0       	ldi	r29, 0x0A	; 10
    2f90:	83 e2       	ldi	r24, 0x23	; 35
    2f92:	89 83       	std	Y+1, r24	; 0x01
	// set period of waveform generator and ccb as duty cycle (want half the period for duty cycle to have good clock signal)
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    2f94:	94 01       	movw	r18, r8
    2f96:	40 e0       	ldi	r20, 0x00	; 0
    2f98:	50 e0       	ldi	r21, 0x00	; 0
    2f9a:	60 e8       	ldi	r22, 0x80	; 128
    2f9c:	74 e8       	ldi	r23, 0x84	; 132
    2f9e:	8e e1       	ldi	r24, 0x1E	; 30
    2fa0:	90 e0       	ldi	r25, 0x00	; 0
    2fa2:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    2fa6:	89 01       	movw	r16, r18
    2fa8:	9a 01       	movw	r18, r20
    2faa:	c8 01       	movw	r24, r16
	TCE1.PER = period;
    2fac:	0e a3       	lds	r16, 0x5e
    2fae:	1f a3       	lds	r17, 0x5f
	TCE1.CCBBUF = period / 2;
    2fb0:	96 95       	lsr	r25
    2fb2:	87 95       	ror	r24
    2fb4:	8a af       	sts	0x7a, r24
    2fb6:	9b af       	sts	0x7b, r25
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	//reset count to zero
	TCC1.CTRLA = 0x00;
    2fb8:	e0 e4       	ldi	r30, 0x40	; 64
    2fba:	f8 e0       	ldi	r31, 0x08	; 8
    2fbc:	10 82       	st	Z, r1
	TCC1.CTRLFSET = 0x0C;
    2fbe:	8c e0       	ldi	r24, 0x0C	; 12
    2fc0:	81 87       	std	Z+9, r24	; 0x09
	
	//set the period as number of samples to know when to stop sampling (and compensate for discarded samples at start of sampling)
	TCC1.PER = numOfSamples;
    2fc2:	66 a2       	lds	r22, 0x96
    2fc4:	77 a2       	lds	r23, 0x97
	//Configure IO13(PF0) to drive event channel that triggers event every time a sample is collected
	EVSYS.CH1MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    2fc6:	88 e7       	ldi	r24, 0x78	; 120
    2fc8:	a0 e8       	ldi	r26, 0x80	; 128
    2fca:	b1 e0       	ldi	r27, 0x01	; 1
    2fcc:	11 96       	adiw	r26, 0x01	; 1
    2fce:	8c 93       	st	X, r24
    2fd0:	11 97       	sbiw	r26, 0x01	; 1
	//set overflow interrupt to low lvl
	TCC1.INTCTRLA =  TC_OVFINTLVL_LO_gc;
    2fd2:	e6 82       	std	Z+6, r14	; 0x06
	//TCC1.CTRLA = ( TCC1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_EVCH1_gc;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2fd4:	88 81       	ld	r24, Y
    2fd6:	80 7f       	andi	r24, 0xF0	; 240
    2fd8:	81 60       	ori	r24, 0x01	; 1
    2fda:	88 83       	st	Y, r24
	
	sampleCount = 0;
    2fdc:	10 92 6a 50 	sts	0x506A, r1
    2fe0:	10 92 6b 50 	sts	0x506B, r1
    2fe4:	10 92 6c 50 	sts	0x506C, r1
    2fe8:	10 92 6d 50 	sts	0x506D, r1
	discardCount = 0;
    2fec:	10 92 61 40 	sts	0x4061, r1
		
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
    2ff0:	e0 ea       	ldi	r30, 0xA0	; 160
    2ff2:	f0 e0       	ldi	r31, 0x00	; 0
    2ff4:	82 81       	ldd	r24, Z+2	; 0x02
    2ff6:	83 60       	ori	r24, 0x03	; 3
    2ff8:	82 83       	std	Z+2, r24	; 0x02
	sei();
    2ffa:	78 94       	sei
	//cli();

	//SPIDisable();	
	//enableADCMUX(FALSE);
	//ADCPower(FALSE);
}
    2ffc:	df 91       	pop	r29
    2ffe:	cf 91       	pop	r28
    3000:	1f 91       	pop	r17
    3002:	0f 91       	pop	r16
    3004:	ff 90       	pop	r15
    3006:	ef 90       	pop	r14
    3008:	df 90       	pop	r13
    300a:	cf 90       	pop	r12
    300c:	bf 90       	pop	r11
    300e:	af 90       	pop	r10
    3010:	9f 90       	pop	r9
    3012:	8f 90       	pop	r8
    3014:	7f 90       	pop	r7
    3016:	6f 90       	pop	r6
    3018:	08 95       	ret

0000301a <CO_collectADC>:
		PORTA.OUTCLR = PIN5_bm;
		PORTA.DIRCLR = PIN5_bm;
	}
}

void CO_collectADC(uint8_t channel, uint8_t gainExponent, uint16_t SPS, uint16_t numOfSamples, int32_t* DataArray, uint16_t BufferSize, uint8_t use_FRAM) {
    301a:	8f 92       	push	r8
    301c:	9f 92       	push	r9
    301e:	af 92       	push	r10
    3020:	cf 92       	push	r12
    3022:	df 92       	push	r13
    3024:	ef 92       	push	r14
    3026:	ff 92       	push	r15
    3028:	0f 93       	push	r16
    302a:	1f 93       	push	r17
    302c:	cf 93       	push	r28
    302e:	df 93       	push	r29
    3030:	96 2f       	mov	r25, r22
    3032:	fa 01       	movw	r30, r20
    3034:	d9 01       	movw	r26, r18
    3036:	e8 01       	movw	r28, r16
    3038:	47 01       	movw	r8, r14
    303a:	ac 2c       	mov	r10, r12
	
	CO_collectADC_ext(channel, (uint8_t) (FILTER_CH_1AND5_bm | FILTER_HP_0_bm | FILTER_LP_600_gc), gainExponent, SPS, numOfSamples, DataArray, BufferSize, use_FRAM);
    303c:	61 ec       	ldi	r22, 0xC1	; 193
    303e:	49 2f       	mov	r20, r25
    3040:	9f 01       	movw	r18, r30
    3042:	8d 01       	movw	r16, r26
    3044:	7e 01       	movw	r14, r28
    3046:	64 01       	movw	r12, r8
    3048:	0e 94 77 17 	call	0x2eee	; 0x2eee <CO_collectADC_ext>
}
    304c:	df 91       	pop	r29
    304e:	cf 91       	pop	r28
    3050:	1f 91       	pop	r17
    3052:	0f 91       	pop	r16
    3054:	ff 90       	pop	r15
    3056:	ef 90       	pop	r14
    3058:	df 90       	pop	r13
    305a:	cf 90       	pop	r12
    305c:	af 90       	pop	r10
    305e:	9f 90       	pop	r9
    3060:	8f 90       	pop	r8
    3062:	08 95       	ret

00003064 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    3064:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3066:	81 e0       	ldi	r24, 0x01	; 1
    3068:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    306a:	84 81       	ldd	r24, Z+4	; 0x04
    306c:	95 81       	ldd	r25, Z+5	; 0x05
    306e:	86 1b       	sub	r24, r22
    3070:	91 09       	sbc	r25, r1

	return answer;
}
    3072:	08 95       	ret

00003074 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    3074:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3076:	81 e0       	ldi	r24, 0x01	; 1
    3078:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    307a:	84 81       	ldd	r24, Z+4	; 0x04
    307c:	95 81       	ldd	r25, Z+5	; 0x05
    307e:	77 27       	eor	r23, r23
    3080:	67 fd       	sbrc	r22, 7
    3082:	70 95       	com	r23
    3084:	86 1b       	sub	r24, r22
    3086:	97 0b       	sbc	r25, r23

	return answer;
}
    3088:	08 95       	ret

0000308a <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    308a:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    308c:	81 e0       	ldi	r24, 0x01	; 1
    308e:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    3090:	84 81       	ldd	r24, Z+4	; 0x04
    3092:	95 81       	ldd	r25, Z+5	; 0x05
}
    3094:	08 95       	ret

00003096 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    3096:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3098:	81 e0       	ldi	r24, 0x01	; 1
    309a:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    309c:	84 81       	ldd	r24, Z+4	; 0x04
}
    309e:	08 95       	ret

000030a0 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    30a0:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    30a2:	81 e0       	ldi	r24, 0x01	; 1
    30a4:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    30a6:	85 81       	ldd	r24, Z+5	; 0x05
}
    30a8:	08 95       	ret

000030aa <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    30aa:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    30ac:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    30ae:	14 82       	std	Z+4, r1	; 0x04
    30b0:	9a e2       	ldi	r25, 0x2A	; 42
    30b2:	9a 95       	dec	r25
    30b4:	f1 f7       	brne	.-4      	; 0x30b2 <ADC_Wait_8MHz+0x8>
    30b6:	00 c0       	rjmp	.+0      	; 0x30b8 <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    30b8:	84 83       	std	Z+4, r24	; 0x04
}
    30ba:	08 95       	ret

000030bc <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    30bc:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    30be:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    30c0:	91 e0       	ldi	r25, 0x01	; 1
    30c2:	94 83       	std	Z+4, r25	; 0x04
    30c4:	95 e5       	ldi	r25, 0x55	; 85
    30c6:	9a 95       	dec	r25
    30c8:	f1 f7       	brne	.-4      	; 0x30c6 <ADC_Wait_32MHz+0xa>
    30ca:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    30cc:	84 83       	std	Z+4, r24	; 0x04
}
    30ce:	08 95       	ret

000030d0 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    30d0:	ef 92       	push	r14
    30d2:	ff 92       	push	r15
    30d4:	0f 93       	push	r16
    30d6:	1f 93       	push	r17
    30d8:	cf 93       	push	r28
    30da:	df 93       	push	r29
    30dc:	eb 01       	movw	r28, r22
    if (oversampling)
    30de:	44 23       	and	r20, r20
    30e0:	c9 f0       	breq	.+50     	; 0x3114 <ADC_Offset_Get_Unsigned+0x44>
    30e2:	04 e0       	ldi	r16, 0x04	; 4
    30e4:	10 e0       	ldi	r17, 0x00	; 0
    30e6:	ee 24       	eor	r14, r14
    30e8:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    30ea:	88 81       	ld	r24, Y
    30ec:	80 68       	ori	r24, 0x80	; 128
    30ee:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    30f0:	8b 81       	ldd	r24, Y+3	; 0x03
    30f2:	80 ff       	sbrs	r24, 0
    30f4:	fd cf       	rjmp	.-6      	; 0x30f0 <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    30f6:	ce 01       	movw	r24, r28
    30f8:	60 e0       	ldi	r22, 0x00	; 0
    30fa:	0e 94 32 18 	call	0x3064	; 0x3064 <ADC_ResultCh_GetWord_Unsigned>
    30fe:	e8 0e       	add	r14, r24
    3100:	f9 1e       	adc	r15, r25
    3102:	01 50       	subi	r16, 0x01	; 1
    3104:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    3106:	89 f7       	brne	.-30     	; 0x30ea <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    3108:	c7 01       	movw	r24, r14
    310a:	96 95       	lsr	r25
    310c:	87 95       	ror	r24
    310e:	96 95       	lsr	r25
    3110:	87 95       	ror	r24
    3112:	09 c0       	rjmp	.+18     	; 0x3126 <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3114:	88 81       	ld	r24, Y
    3116:	80 68       	ori	r24, 0x80	; 128
    3118:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    311a:	8b 81       	ldd	r24, Y+3	; 0x03
    311c:	80 ff       	sbrs	r24, 0
    311e:	fd cf       	rjmp	.-6      	; 0x311a <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    3120:	ce 01       	movw	r24, r28
    3122:	0e 94 45 18 	call	0x308a	; 0x308a <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
    3126:	df 91       	pop	r29
    3128:	cf 91       	pop	r28
    312a:	1f 91       	pop	r17
    312c:	0f 91       	pop	r16
    312e:	ff 90       	pop	r15
    3130:	ef 90       	pop	r14
    3132:	08 95       	ret

00003134 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3134:	ef 92       	push	r14
    3136:	ff 92       	push	r15
    3138:	0f 93       	push	r16
    313a:	1f 93       	push	r17
    313c:	cf 93       	push	r28
    313e:	df 93       	push	r29
    3140:	eb 01       	movw	r28, r22
    if (oversampling)
    3142:	44 23       	and	r20, r20
    3144:	e1 f0       	breq	.+56     	; 0x317e <ADC_Offset_Get_Signed+0x4a>
    3146:	04 e0       	ldi	r16, 0x04	; 4
    3148:	10 e0       	ldi	r17, 0x00	; 0
    314a:	ee 24       	eor	r14, r14
    314c:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    314e:	88 81       	ld	r24, Y
    3150:	80 68       	ori	r24, 0x80	; 128
    3152:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3154:	8b 81       	ldd	r24, Y+3	; 0x03
    3156:	80 ff       	sbrs	r24, 0
    3158:	fd cf       	rjmp	.-6      	; 0x3154 <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    315a:	ce 01       	movw	r24, r28
    315c:	60 e0       	ldi	r22, 0x00	; 0
    315e:	0e 94 3a 18 	call	0x3074	; 0x3074 <ADC_ResultCh_GetWord_Signed>
    3162:	e8 0e       	add	r14, r24
    3164:	f9 1e       	adc	r15, r25
    3166:	01 50       	subi	r16, 0x01	; 1
    3168:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    316a:	89 f7       	brne	.-30     	; 0x314e <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    316c:	c7 01       	movw	r24, r14
    316e:	99 23       	and	r25, r25
    3170:	0c f4       	brge	.+2      	; 0x3174 <ADC_Offset_Get_Signed+0x40>
    3172:	03 96       	adiw	r24, 0x03	; 3
    3174:	95 95       	asr	r25
    3176:	87 95       	ror	r24
    3178:	95 95       	asr	r25
    317a:	87 95       	ror	r24
    317c:	0a c0       	rjmp	.+20     	; 0x3192 <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    317e:	88 81       	ld	r24, Y
    3180:	80 68       	ori	r24, 0x80	; 128
    3182:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3184:	8b 81       	ldd	r24, Y+3	; 0x03
    3186:	80 ff       	sbrs	r24, 0
    3188:	fd cf       	rjmp	.-6      	; 0x3184 <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    318a:	ce 01       	movw	r24, r28
    318c:	60 e0       	ldi	r22, 0x00	; 0
    318e:	0e 94 3a 18 	call	0x3074	; 0x3074 <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
    3192:	df 91       	pop	r29
    3194:	cf 91       	pop	r28
    3196:	1f 91       	pop	r17
    3198:	0f 91       	pop	r16
    319a:	ff 90       	pop	r15
    319c:	ef 90       	pop	r14
    319e:	08 95       	ret

000031a0 <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    31a0:	aa ec       	ldi	r26, 0xCA	; 202
    31a2:	b1 e0       	ldi	r27, 0x01	; 1
    31a4:	92 e0       	ldi	r25, 0x02	; 2
    31a6:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
    31a8:	e8 2f       	mov	r30, r24
    31aa:	f0 e0       	ldi	r31, 0x00	; 0
    31ac:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    31ae:	1c 92       	st	X, r1

	return result;
}
    31b0:	08 95       	ret

000031b2 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    31b2:	cf 93       	push	r28
    31b4:	df 93       	push	r29
    31b6:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
    31b8:	82 e0       	ldi	r24, 0x02	; 2
    31ba:	c0 30       	cpi	r28, 0x00	; 0
    31bc:	d8 07       	cpc	r29, r24
    31be:	59 f4       	brne	.+22     	; 0x31d6 <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    31c0:	80 e2       	ldi	r24, 0x20	; 32
    31c2:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <SP_ReadCalibrationByte>
    31c6:	c0 e0       	ldi	r28, 0x00	; 0
    31c8:	d2 e0       	ldi	r29, 0x02	; 2
    31ca:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    31cc:	81 e2       	ldi	r24, 0x21	; 33
    31ce:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <SP_ReadCalibrationByte>
    31d2:	8d 87       	std	Y+13, r24	; 0x0d
    31d4:	08 c0       	rjmp	.+16     	; 0x31e6 <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    31d6:	84 e2       	ldi	r24, 0x24	; 36
    31d8:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <SP_ReadCalibrationByte>
    31dc:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    31de:	85 e2       	ldi	r24, 0x25	; 37
    31e0:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <SP_ReadCalibrationByte>
    31e4:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
    31e6:	df 91       	pop	r29
    31e8:	cf 91       	pop	r28
    31ea:	08 95       	ret

000031ec <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
    31ec:	88 e1       	ldi	r24, 0x18	; 24
    31ee:	e5 e1       	ldi	r30, 0x15	; 21
    31f0:	f1 e2       	ldi	r31, 0x21	; 33
    31f2:	df 01       	movw	r26, r30
    31f4:	1d 92       	st	X+, r1
    31f6:	8a 95       	dec	r24
    31f8:	e9 f7       	brne	.-6      	; 0x31f4 <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
    31fa:	0e 94 6d 1a 	call	0x34da	; 0x34da <chb_get_short_addr>
    31fe:	80 93 15 21 	sts	0x2115, r24
    3202:	90 93 16 21 	sts	0x2116, r25
    chb_drvr_init();
    3206:	0e 94 cb 1c 	call	0x3996	; 0x3996 <chb_drvr_init>
	//radio_msg_received_int_enable();
}
    320a:	08 95       	ret

0000320c <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
	PORTE.DIRSET = PIN2_bm;
    320c:	e0 e8       	ldi	r30, 0x80	; 128
    320e:	f6 e0       	ldi	r31, 0x06	; 6
    3210:	84 e0       	ldi	r24, 0x04	; 4
    3212:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    3214:	86 83       	std	Z+6, r24	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    3216:	92 e0       	ldi	r25, 0x02	; 2
    3218:	90 8b       	std	Z+16, r25	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    321a:	82 87       	std	Z+10, r24	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    321c:	83 e0       	ldi	r24, 0x03	; 3
    321e:	81 87       	std	Z+9, r24	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    3220:	e0 ea       	ldi	r30, 0xA0	; 160
    3222:	f0 e0       	ldi	r31, 0x00	; 0
    3224:	82 81       	ldd	r24, Z+2	; 0x02
    3226:	84 60       	ori	r24, 0x04	; 4
    3228:	82 83       	std	Z+2, r24	; 0x02
	sei();
    322a:	78 94       	sei
}
    322c:	08 95       	ret

0000322e <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
    322e:	85 e1       	ldi	r24, 0x15	; 21
    3230:	91 e2       	ldi	r25, 0x21	; 33
    3232:	08 95       	ret

00003234 <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    3234:	2f 92       	push	r2
    3236:	3f 92       	push	r3
    3238:	4f 92       	push	r4
    323a:	5f 92       	push	r5
    323c:	6f 92       	push	r6
    323e:	7f 92       	push	r7
    3240:	8f 92       	push	r8
    3242:	9f 92       	push	r9
    3244:	af 92       	push	r10
    3246:	bf 92       	push	r11
    3248:	cf 92       	push	r12
    324a:	df 92       	push	r13
    324c:	ef 92       	push	r14
    324e:	ff 92       	push	r15
    3250:	0f 93       	push	r16
    3252:	1f 93       	push	r17
    3254:	cf 93       	push	r28
    3256:	df 93       	push	r29
    3258:	cd b7       	in	r28, 0x3d	; 61
    325a:	de b7       	in	r29, 0x3e	; 62
    325c:	2a 97       	sbiw	r28, 0x0a	; 10
    325e:	cd bf       	out	0x3d, r28	; 61
    3260:	de bf       	out	0x3e, r29	; 62
    3262:	2c 01       	movw	r4, r24
    3264:	1b 01       	movw	r2, r22
    3266:	69 01       	movw	r12, r18
    3268:	7a 01       	movw	r14, r20
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    326a:	21 15       	cp	r18, r1
    326c:	31 05       	cpc	r19, r1
    326e:	41 05       	cpc	r20, r1
    3270:	51 05       	cpc	r21, r1
    3272:	09 f4       	brne	.+2      	; 0x3276 <chb_write+0x42>
    3274:	76 c0       	rjmp	.+236    	; 0x3362 <chb_write+0x12e>
    U8 status, frm_len, hdr[CHB_HDR_SZ + 1];
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    3276:	88 24       	eor	r8, r8
    3278:	99 24       	eor	r9, r9
    327a:	54 01       	movw	r10, r8
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    327c:	08 e9       	ldi	r16, 0x98	; 152

    *hdr_ptr++ = pcb.seq++;
    327e:	0f 2e       	mov	r0, r31
    3280:	fb e1       	ldi	r31, 0x1B	; 27
    3282:	6f 2e       	mov	r6, r31
    3284:	f1 e2       	ldi	r31, 0x21	; 33
    3286:	7f 2e       	mov	r7, r31
    3288:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    328a:	1c 2d       	mov	r17, r12
    328c:	85 e6       	ldi	r24, 0x65	; 101
    328e:	c8 16       	cp	r12, r24
    3290:	d1 04       	cpc	r13, r1
    3292:	e1 04       	cpc	r14, r1
    3294:	f1 04       	cpc	r15, r1
    3296:	08 f0       	brcs	.+2      	; 0x329a <chb_write+0x66>
    3298:	14 e6       	ldi	r17, 0x64	; 100
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    329a:	81 2f       	mov	r24, r17
    329c:	85 5f       	subi	r24, 0xF5	; 245
    329e:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    32a0:	9f ef       	ldi	r25, 0xFF	; 255
    32a2:	49 16       	cp	r4, r25
    32a4:	9f ef       	ldi	r25, 0xFF	; 255
    32a6:	59 06       	cpc	r5, r25
    32a8:	11 f0       	breq	.+4      	; 0x32ae <chb_write+0x7a>
    32aa:	81 e6       	ldi	r24, 0x61	; 97
    32ac:	01 c0       	rjmp	.+2      	; 0x32b0 <chb_write+0x7c>
    32ae:	81 e4       	ldi	r24, 0x41	; 65
    32b0:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    32b2:	0b 83       	std	Y+3, r16	; 0x03

    *hdr_ptr++ = pcb.seq++;
    32b4:	f3 01       	movw	r30, r6
    32b6:	80 81       	ld	r24, Z
    32b8:	8c 83       	std	Y+4, r24	; 0x04
    32ba:	8f 5f       	subi	r24, 0xFF	; 255
    32bc:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    32be:	84 e3       	ldi	r24, 0x34	; 52
    32c0:	92 e1       	ldi	r25, 0x12	; 18
    32c2:	8d 83       	std	Y+5, r24	; 0x05
    32c4:	9e 83       	std	Y+6, r25	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
    32c6:	4f 82       	std	Y+7, r4	; 0x07
    32c8:	58 86       	std	Y+8, r5	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
    32ca:	e5 e1       	ldi	r30, 0x15	; 21
    32cc:	f1 e2       	ldi	r31, 0x21	; 33
    32ce:	80 81       	ld	r24, Z
    32d0:	91 81       	ldd	r25, Z+1	; 0x01
    32d2:	89 87       	std	Y+9, r24	; 0x09
    32d4:	9a 87       	std	Y+10, r25	; 0x0a
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		//rtry = 0;
		//do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    32d6:	b1 01       	movw	r22, r2
    32d8:	68 0d       	add	r22, r8
    32da:	79 1d       	adc	r23, r9
    32dc:	ce 01       	movw	r24, r28
    32de:	01 96       	adiw	r24, 0x01	; 1
    32e0:	41 2f       	mov	r20, r17
    32e2:	0e 94 09 1c 	call	0x3812	; 0x3812 <chb_tx>
		if (status != CHB_SUCCESS){
    32e6:	88 23       	and	r24, r24
    32e8:	69 f1       	breq	.+90     	; 0x3344 <chb_write+0x110>
		chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		//rtry = 0;
		//do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    32ea:	28 2f       	mov	r18, r24
		if (status != CHB_SUCCESS){
             switch (status)
    32ec:	83 30       	cpi	r24, 0x03	; 3
    32ee:	f9 f0       	breq	.+62     	; 0x332e <chb_write+0xfa>
    32f0:	84 30       	cpi	r24, 0x04	; 4
    32f2:	18 f4       	brcc	.+6      	; 0x32fa <chb_write+0xc6>
    32f4:	81 30       	cpi	r24, 0x01	; 1
    32f6:	b1 f5       	brne	.+108    	; 0x3364 <chb_write+0x130>
    32f8:	04 c0       	rjmp	.+8      	; 0x3302 <chb_write+0xce>
    32fa:	85 30       	cpi	r24, 0x05	; 5
    32fc:	69 f0       	breq	.+26     	; 0x3318 <chb_write+0xe4>
    32fe:	80 34       	cpi	r24, 0x40	; 64
    3300:	89 f5       	brne	.+98     	; 0x3364 <chb_write+0x130>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    3302:	20 91 20 21 	lds	r18, 0x2120
    3306:	30 91 21 21 	lds	r19, 0x2121
    330a:	2f 5f       	subi	r18, 0xFF	; 255
    330c:	3f 4f       	sbci	r19, 0xFF	; 255
    330e:	20 93 20 21 	sts	0x2120, r18
    3312:	30 93 21 21 	sts	0x2121, r19
                 break;
    3316:	26 c0       	rjmp	.+76     	; 0x3364 <chb_write+0x130>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    3318:	80 91 22 21 	lds	r24, 0x2122
    331c:	90 91 23 21 	lds	r25, 0x2123
    3320:	01 96       	adiw	r24, 0x01	; 1
    3322:	80 93 22 21 	sts	0x2122, r24
    3326:	90 93 23 21 	sts	0x2123, r25
                 break;
 
             default:
                 break;
             }
			 return status;
    332a:	82 2f       	mov	r24, r18
                 break;
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
				 //rtry++;
                 break;
    332c:	1b c0       	rjmp	.+54     	; 0x3364 <chb_write+0x130>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    332e:	20 91 24 21 	lds	r18, 0x2124
    3332:	30 91 25 21 	lds	r19, 0x2125
    3336:	2f 5f       	subi	r18, 0xFF	; 255
    3338:	3f 4f       	sbci	r19, 0xFF	; 255
    333a:	20 93 24 21 	sts	0x2124, r18
    333e:	30 93 25 21 	sts	0x2125, r19
				 //rtry++;
                 break;
    3342:	10 c0       	rjmp	.+32     	; 0x3364 <chb_write+0x130>
		}			 
			//if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
			//if(rtry==20) return status;;		//after 20 tries give up on sending the message	
		//} while(status != CHB_SUCCESS);			
        // adjust len and restart
		frm_offset += frm_len;
    3344:	41 2f       	mov	r20, r17
    3346:	50 e0       	ldi	r21, 0x00	; 0
    3348:	60 e0       	ldi	r22, 0x00	; 0
    334a:	70 e0       	ldi	r23, 0x00	; 0
    334c:	84 0e       	add	r8, r20
    334e:	95 1e       	adc	r9, r21
    3350:	a6 1e       	adc	r10, r22
    3352:	b7 1e       	adc	r11, r23
		//if (len > CHB_MAX_PAYLOAD) _delay_ms(100);				//wait a little before sending next message
        len = len - frm_len;
    3354:	c4 1a       	sub	r12, r20
    3356:	d5 0a       	sbc	r13, r21
    3358:	e6 0a       	sbc	r14, r22
    335a:	f7 0a       	sbc	r15, r23
	U32 frm_offset;
	//U8 hdr_len;
    //int rtry;
	
	frm_offset = 0;
    while (len > 0)
    335c:	09 f0       	breq	.+2      	; 0x3360 <chb_write+0x12c>
    335e:	95 cf       	rjmp	.-214    	; 0x328a <chb_write+0x56>
    3360:	01 c0       	rjmp	.+2      	; 0x3364 <chb_write+0x130>
        // adjust len and restart
		frm_offset += frm_len;
		//if (len > CHB_MAX_PAYLOAD) _delay_ms(100);				//wait a little before sending next message
        len = len - frm_len;
    }
	return CHB_SUCCESS;
    3362:	80 e0       	ldi	r24, 0x00	; 0
}
    3364:	2a 96       	adiw	r28, 0x0a	; 10
    3366:	cd bf       	out	0x3d, r28	; 61
    3368:	de bf       	out	0x3e, r29	; 62
    336a:	df 91       	pop	r29
    336c:	cf 91       	pop	r28
    336e:	1f 91       	pop	r17
    3370:	0f 91       	pop	r16
    3372:	ff 90       	pop	r15
    3374:	ef 90       	pop	r14
    3376:	df 90       	pop	r13
    3378:	cf 90       	pop	r12
    337a:	bf 90       	pop	r11
    337c:	af 90       	pop	r10
    337e:	9f 90       	pop	r9
    3380:	8f 90       	pop	r8
    3382:	7f 90       	pop	r7
    3384:	6f 90       	pop	r6
    3386:	5f 90       	pop	r5
    3388:	4f 90       	pop	r4
    338a:	3f 90       	pop	r3
    338c:	2f 90       	pop	r2
    338e:	08 95       	ret

00003390 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    3390:	df 92       	push	r13
    3392:	ef 92       	push	r14
    3394:	ff 92       	push	r15
    3396:	0f 93       	push	r16
    3398:	1f 93       	push	r17
    339a:	cf 93       	push	r28
    339c:	df 93       	push	r29
    339e:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    33a0:	0e 94 4b 1a 	call	0x3496	; 0x3496 <chb_buf_read>
    33a4:	d8 2e       	mov	r13, r24
    33a6:	88 23       	and	r24, r24
    33a8:	0c f4       	brge	.+2      	; 0x33ac <chb_read+0x1c>
    33aa:	4e c0       	rjmp	.+156    	; 0x3448 <chb_read+0xb8>
    {
        return 0;
    }
    *data_ptr++ = len;
    33ac:	f7 01       	movw	r30, r14
    33ae:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    33b0:	88 23       	and	r24, r24
    33b2:	71 f0       	breq	.+28     	; 0x33d0 <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
    33b4:	e7 01       	movw	r28, r14
    33b6:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
    33b8:	87 01       	movw	r16, r14
    33ba:	09 5f       	subi	r16, 0xF9	; 249
    33bc:	1f 4f       	sbci	r17, 0xFF	; 255
    33be:	81 50       	subi	r24, 0x01	; 1
    33c0:	08 0f       	add	r16, r24
    33c2:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
    33c4:	0e 94 4b 1a 	call	0x3496	; 0x3496 <chb_buf_read>
    33c8:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    33ca:	c0 17       	cp	r28, r16
    33cc:	d1 07       	cpc	r29, r17
    33ce:	d1 f7       	brne	.-12     	; 0x33c4 <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
    33d0:	f7 01       	movw	r30, r14
    33d2:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
    33d4:	83 85       	ldd	r24, Z+11	; 0x0b
    33d6:	94 85       	ldd	r25, Z+12	; 0x0c
    33d8:	83 83       	std	Z+3, r24	; 0x03
    33da:	94 83       	std	Z+4, r25	; 0x04
	pcb.destination_addr = rx->dest_addr;
    33dc:	80 93 19 21 	sts	0x2119, r24
    33e0:	90 93 1a 21 	sts	0x211A, r25
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
    33e4:	85 85       	ldd	r24, Z+13	; 0x0d
    33e6:	96 85       	ldd	r25, Z+14	; 0x0e
    33e8:	81 83       	std	Z+1, r24	; 0x01
    33ea:	92 83       	std	Z+2, r25	; 0x02
	pcb.sender_addr = rx->src_addr;
    33ec:	80 93 17 21 	sts	0x2117, r24
    33f0:	90 93 18 21 	sts	0x2118, r25
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    33f4:	0e 94 62 1a 	call	0x34c4	; 0x34c4 <chb_buf_get_len>
    33f8:	88 23       	and	r24, r24
    33fa:	11 f4       	brne	.+4      	; 0x3400 <chb_read+0x70>
    {
        pcb.data_rcv = false;
    33fc:	10 92 1c 21 	sts	0x211C, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    3400:	80 91 0a 20 	lds	r24, 0x200A
    3404:	c8 17       	cp	r28, r24
    3406:	51 f4       	brne	.+20     	; 0x341c <chb_read+0x8c>
    3408:	f7 01       	movw	r30, r14
    340a:	21 81       	ldd	r18, Z+1	; 0x01
    340c:	32 81       	ldd	r19, Z+2	; 0x02
    340e:	80 91 0b 20 	lds	r24, 0x200B
    3412:	90 91 0c 20 	lds	r25, 0x200C
    3416:	28 17       	cp	r18, r24
    3418:	39 07       	cpc	r19, r25
    341a:	c1 f0       	breq	.+48     	; 0x344c <chb_read+0xbc>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
    341c:	c0 93 0a 20 	sts	0x200A, r28
        prev_src_addr = rx->src_addr;
    3420:	f7 01       	movw	r30, r14
    3422:	81 81       	ldd	r24, Z+1	; 0x01
    3424:	92 81       	ldd	r25, Z+2	; 0x02
    3426:	80 93 0b 20 	sts	0x200B, r24
    342a:	90 93 0c 20 	sts	0x200C, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    342e:	b7 01       	movw	r22, r14
    3430:	61 5f       	subi	r22, 0xF1	; 241
    3432:	7f 4f       	sbci	r23, 0xFF	; 255
    3434:	4d 2d       	mov	r20, r13
    3436:	50 e0       	ldi	r21, 0x00	; 0
    3438:	49 50       	subi	r20, 0x09	; 9
    343a:	50 40       	sbci	r21, 0x00	; 0
    343c:	c7 01       	movw	r24, r14
    343e:	0e 94 df 38 	call	0x71be	; 0x71be <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    3442:	8d 2d       	mov	r24, r13
    3444:	8b 50       	subi	r24, 0x0B	; 11
    3446:	03 c0       	rjmp	.+6      	; 0x344e <chb_read+0xbe>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    3448:	80 e0       	ldi	r24, 0x00	; 0
    344a:	01 c0       	rjmp	.+2      	; 0x344e <chb_read+0xbe>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    344c:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
    344e:	df 91       	pop	r29
    3450:	cf 91       	pop	r28
    3452:	1f 91       	pop	r17
    3454:	0f 91       	pop	r16
    3456:	ff 90       	pop	r15
    3458:	ef 90       	pop	r14
    345a:	df 90       	pop	r13
    345c:	08 95       	ret

0000345e <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
    345e:	10 92 2d 21 	sts	0x212D, r1
    wr_ptr = 0;
    3462:	10 92 2e 21 	sts	0x212E, r1
    len = 0;
    3466:	10 92 2f 21 	sts	0x212F, r1
}
    346a:	08 95       	ret

0000346c <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
    346c:	20 91 2e 21 	lds	r18, 0x212E
    3470:	30 e0       	ldi	r19, 0x00	; 0
    3472:	f9 01       	movw	r30, r18
    3474:	e0 5d       	subi	r30, 0xD0	; 208
    3476:	fe 4d       	sbci	r31, 0xDE	; 222
    3478:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    347a:	c9 01       	movw	r24, r18
    347c:	01 96       	adiw	r24, 0x01	; 1
    347e:	60 e8       	ldi	r22, 0x80	; 128
    3480:	70 e0       	ldi	r23, 0x00	; 0
    3482:	0e 94 43 38 	call	0x7086	; 0x7086 <__divmodhi4>
    3486:	80 93 2e 21 	sts	0x212E, r24
    len++;
    348a:	80 91 2f 21 	lds	r24, 0x212F
    348e:	8f 5f       	subi	r24, 0xFF	; 255
    3490:	80 93 2f 21 	sts	0x212F, r24
}
    3494:	08 95       	ret

00003496 <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
    3496:	20 91 2d 21 	lds	r18, 0x212D
    349a:	30 e0       	ldi	r19, 0x00	; 0
    349c:	f9 01       	movw	r30, r18
    349e:	e0 5d       	subi	r30, 0xD0	; 208
    34a0:	fe 4d       	sbci	r31, 0xDE	; 222
    34a2:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    34a4:	2f 5f       	subi	r18, 0xFF	; 255
    34a6:	3f 4f       	sbci	r19, 0xFF	; 255
    34a8:	c9 01       	movw	r24, r18
    34aa:	60 e8       	ldi	r22, 0x80	; 128
    34ac:	70 e0       	ldi	r23, 0x00	; 0
    34ae:	0e 94 43 38 	call	0x7086	; 0x7086 <__divmodhi4>
    34b2:	80 93 2d 21 	sts	0x212D, r24
    len--;
    34b6:	80 91 2f 21 	lds	r24, 0x212F
    34ba:	81 50       	subi	r24, 0x01	; 1
    34bc:	80 93 2f 21 	sts	0x212F, r24
    return data;
}
    34c0:	84 2f       	mov	r24, r20
    34c2:	08 95       	ret

000034c4 <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
    34c4:	80 91 2f 21 	lds	r24, 0x212F
    34c8:	08 95       	ret

000034ca <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    34ca:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    34cc:	80 e0       	ldi	r24, 0x00	; 0
    34ce:	90 e0       	ldi	r25, 0x00	; 0
    34d0:	48 e0       	ldi	r20, 0x08	; 8
    34d2:	50 e0       	ldi	r21, 0x00	; 0
    34d4:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <chb_eeprom_read>
}
    34d8:	08 95       	ret

000034da <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    34da:	cf 93       	push	r28
    34dc:	df 93       	push	r29
    34de:	0f 92       	push	r0
    34e0:	0f 92       	push	r0
    34e2:	cd b7       	in	r28, 0x3d	; 61
    34e4:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    34e6:	89 e0       	ldi	r24, 0x09	; 9
    34e8:	90 e0       	ldi	r25, 0x00	; 0
    34ea:	be 01       	movw	r22, r28
    34ec:	6f 5f       	subi	r22, 0xFF	; 255
    34ee:	7f 4f       	sbci	r23, 0xFF	; 255
    34f0:	42 e0       	ldi	r20, 0x02	; 2
    34f2:	50 e0       	ldi	r21, 0x00	; 0
    34f4:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <chb_eeprom_read>
    return *(U16 *)addr;
}
    34f8:	89 81       	ldd	r24, Y+1	; 0x01
    34fa:	9a 81       	ldd	r25, Y+2	; 0x02
    34fc:	0f 90       	pop	r0
    34fe:	0f 90       	pop	r0
    3500:	df 91       	pop	r29
    3502:	cf 91       	pop	r28
    3504:	08 95       	ret

00003506 <RadioCS>:
    CHB_LEAVE_CRIT();
}

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    3506:	88 23       	and	r24, r24
    3508:	29 f0       	breq	.+10     	; 0x3514 <RadioCS+0xe>
    350a:	80 e1       	ldi	r24, 0x10	; 16
    350c:	e0 e6       	ldi	r30, 0x60	; 96
    350e:	f6 e0       	ldi	r31, 0x06	; 6
    3510:	86 83       	std	Z+6, r24	; 0x06
    3512:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    3514:	80 e1       	ldi	r24, 0x10	; 16
    3516:	e0 e6       	ldi	r30, 0x60	; 96
    3518:	f6 e0       	ldi	r31, 0x06	; 6
    351a:	85 83       	std	Z+5, r24	; 0x05
    351c:	08 95       	ret

0000351e <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    351e:	df 92       	push	r13
    3520:	ef 92       	push	r14
    3522:	ff 92       	push	r15
    3524:	0f 93       	push	r16
    3526:	1f 93       	push	r17
    3528:	cf 93       	push	r28
    352a:	df 93       	push	r29
    352c:	8c 01       	movw	r16, r24
    352e:	c6 2f       	mov	r28, r22
    3530:	7a 01       	movw	r14, r20
    3532:	d2 2e       	mov	r13, r18
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    3534:	82 2f       	mov	r24, r18
    3536:	90 e0       	ldi	r25, 0x00	; 0
    3538:	86 0f       	add	r24, r22
    353a:	91 1d       	adc	r25, r1
    353c:	80 38       	cpi	r24, 0x80	; 128
    353e:	91 05       	cpc	r25, r1
    3540:	8c f5       	brge	.+98     	; 0x35a4 <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    3542:	8f b7       	in	r24, 0x3f	; 63
    3544:	80 93 5c 40 	sts	0x405C, r24
    3548:	f8 94       	cli
    RadioCS(TRUE); 
    354a:	81 e0       	ldi	r24, 0x01	; 1
    354c:	0e 94 83 1a 	call	0x3506	; 0x3506 <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    3550:	80 e6       	ldi	r24, 0x60	; 96
    3552:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    3556:	cc 23       	and	r28, r28
    3558:	79 f0       	breq	.+30     	; 0x3578 <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    355a:	c8 01       	movw	r24, r16
    355c:	01 96       	adiw	r24, 0x01	; 1
    355e:	c1 50       	subi	r28, 0x01	; 1
    3560:	9c 01       	movw	r18, r24
    3562:	2c 0f       	add	r18, r28
    3564:	31 1d       	adc	r19, r1
    3566:	e9 01       	movw	r28, r18

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    3568:	f8 01       	movw	r30, r16
    356a:	81 91       	ld	r24, Z+
    356c:	8f 01       	movw	r16, r30
    356e:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    3572:	0c 17       	cp	r16, r28
    3574:	1d 07       	cpc	r17, r29
    3576:	c1 f7       	brne	.-16     	; 0x3568 <chb_frame_write+0x4a>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    3578:	dd 20       	and	r13, r13
    357a:	69 f0       	breq	.+26     	; 0x3596 <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    357c:	e7 01       	movw	r28, r14
    357e:	21 96       	adiw	r28, 0x01	; 1
    3580:	da 94       	dec	r13
    3582:	cd 0d       	add	r28, r13
    3584:	d1 1d       	adc	r29, r1

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    3586:	f7 01       	movw	r30, r14
    3588:	81 91       	ld	r24, Z+
    358a:	7f 01       	movw	r14, r30
    358c:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    3590:	ec 16       	cp	r14, r28
    3592:	fd 06       	cpc	r15, r29
    3594:	c1 f7       	brne	.-16     	; 0x3586 <chb_frame_write+0x68>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    3596:	80 e0       	ldi	r24, 0x00	; 0
    3598:	0e 94 83 1a 	call	0x3506	; 0x3506 <RadioCS>
    CHB_LEAVE_CRIT();
    359c:	80 91 5c 40 	lds	r24, 0x405C
    35a0:	8f bf       	out	0x3f, r24	; 63
    35a2:	78 94       	sei
}
    35a4:	df 91       	pop	r29
    35a6:	cf 91       	pop	r28
    35a8:	1f 91       	pop	r17
    35aa:	0f 91       	pop	r16
    35ac:	ff 90       	pop	r15
    35ae:	ef 90       	pop	r14
    35b0:	df 90       	pop	r13
    35b2:	08 95       	ret

000035b4 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    35b4:	cf 93       	push	r28
    35b6:	df 93       	push	r29
    35b8:	d8 2f       	mov	r29, r24
    35ba:	c6 2f       	mov	r28, r22
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
    35bc:	8f b7       	in	r24, 0x3f	; 63
    35be:	80 93 5c 40 	sts	0x405C, r24
    35c2:	f8 94       	cli
    RadioCS(TRUE);
    35c4:	81 e0       	ldi	r24, 0x01	; 1
    35c6:	0e 94 83 1a 	call	0x3506	; 0x3506 <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    35ca:	8d 2f       	mov	r24, r29
    35cc:	80 6c       	ori	r24, 0xC0	; 192
    35ce:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    35d2:	8c 2f       	mov	r24, r28
    35d4:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <SPID_write>

    RadioCS(FALSE);
    35d8:	80 e0       	ldi	r24, 0x00	; 0
    35da:	0e 94 83 1a 	call	0x3506	; 0x3506 <RadioCS>
    CHB_LEAVE_CRIT();
    35de:	80 91 5c 40 	lds	r24, 0x405C
    35e2:	8f bf       	out	0x3f, r24	; 63
    35e4:	78 94       	sei
}
    35e6:	df 91       	pop	r29
    35e8:	cf 91       	pop	r28
    35ea:	08 95       	ret

000035ec <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    35ec:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
    35ee:	85 e0       	ldi	r24, 0x05	; 5
    35f0:	0e 94 da 1a 	call	0x35b4	; 0x35b4 <chb_reg_write>
}
    35f4:	08 95       	ret

000035f6 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    35f6:	0f 93       	push	r16
    35f8:	1f 93       	push	r17
    35fa:	cf 93       	push	r28
    35fc:	df 93       	push	r29
    35fe:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
    3600:	c6 2f       	mov	r28, r22
    3602:	d7 2f       	mov	r29, r23
    3604:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
    3606:	69 91       	ld	r22, Y+
    3608:	81 2f       	mov	r24, r17
    360a:	80 0f       	add	r24, r16
    360c:	0e 94 da 1a 	call	0x35b4	; 0x35b4 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    3610:	1f 5f       	subi	r17, 0xFF	; 255
    3612:	18 30       	cpi	r17, 0x08	; 8
    3614:	c1 f7       	brne	.-16     	; 0x3606 <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    3616:	df 91       	pop	r29
    3618:	cf 91       	pop	r28
    361a:	1f 91       	pop	r17
    361c:	0f 91       	pop	r16
    361e:	08 95       	ret

00003620 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    3620:	cf 93       	push	r28
    3622:	df 93       	push	r29
    3624:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    3626:	80 e0       	ldi	r24, 0x00	; 0
    3628:	90 e0       	ldi	r25, 0x00	; 0
    362a:	be 01       	movw	r22, r28
    362c:	48 e0       	ldi	r20, 0x08	; 8
    362e:	50 e0       	ldi	r21, 0x00	; 0
    3630:	0e 94 45 1e 	call	0x3c8a	; 0x3c8a <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    3634:	84 e2       	ldi	r24, 0x24	; 36
    3636:	be 01       	movw	r22, r28
    3638:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <chb_reg_write64>
}
    363c:	df 91       	pop	r29
    363e:	cf 91       	pop	r28
    3640:	08 95       	ret

00003642 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    3642:	cf 93       	push	r28
    3644:	df 93       	push	r29
    3646:	c8 2f       	mov	r28, r24
    3648:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
    364a:	0e 94 da 1a 	call	0x35b4	; 0x35b4 <chb_reg_write>
    364e:	8c 2f       	mov	r24, r28
    3650:	8f 5f       	subi	r24, 0xFF	; 255
    3652:	6d 2f       	mov	r22, r29
    3654:	0e 94 da 1a 	call	0x35b4	; 0x35b4 <chb_reg_write>
    }
}
    3658:	df 91       	pop	r29
    365a:	cf 91       	pop	r28
    365c:	08 95       	ret

0000365e <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    365e:	0f 93       	push	r16
    3660:	1f 93       	push	r17
    3662:	cf 93       	push	r28
    3664:	df 93       	push	r29
    3666:	0f 92       	push	r0
    3668:	0f 92       	push	r0
    366a:	cd b7       	in	r28, 0x3d	; 61
    366c:	de b7       	in	r29, 0x3e	; 62
    366e:	89 83       	std	Y+1, r24	; 0x01
    3670:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
    3672:	0e 94 17 19 	call	0x322e	; 0x322e <chb_get_pcb>
    3676:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    3678:	89 e0       	ldi	r24, 0x09	; 9
    367a:	90 e0       	ldi	r25, 0x00	; 0
    367c:	be 01       	movw	r22, r28
    367e:	6f 5f       	subi	r22, 0xFF	; 255
    3680:	7f 4f       	sbci	r23, 0xFF	; 255
    3682:	42 e0       	ldi	r20, 0x02	; 2
    3684:	50 e0       	ldi	r21, 0x00	; 0
    3686:	0e 94 45 1e 	call	0x3c8a	; 0x3c8a <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    368a:	69 81       	ldd	r22, Y+1	; 0x01
    368c:	7a 81       	ldd	r23, Y+2	; 0x02
    368e:	80 e2       	ldi	r24, 0x20	; 32
    3690:	0e 94 21 1b 	call	0x3642	; 0x3642 <chb_reg_write16>
    pcb->src_addr = addr;
    3694:	89 81       	ldd	r24, Y+1	; 0x01
    3696:	9a 81       	ldd	r25, Y+2	; 0x02
    3698:	f8 01       	movw	r30, r16
    369a:	80 83       	st	Z, r24
    369c:	91 83       	std	Z+1, r25	; 0x01
}
    369e:	0f 90       	pop	r0
    36a0:	0f 90       	pop	r0
    36a2:	df 91       	pop	r29
    36a4:	cf 91       	pop	r28
    36a6:	1f 91       	pop	r17
    36a8:	0f 91       	pop	r16
    36aa:	08 95       	ret

000036ac <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    36ac:	cf 93       	push	r28
    36ae:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
    36b0:	8f b7       	in	r24, 0x3f	; 63
    36b2:	80 93 5c 40 	sts	0x405C, r24
    36b6:	f8 94       	cli
    RadioCS(TRUE);
    36b8:	81 e0       	ldi	r24, 0x01	; 1
    36ba:	0e 94 83 1a 	call	0x3506	; 0x3506 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    36be:	8c 2f       	mov	r24, r28
    36c0:	80 68       	ori	r24, 0x80	; 128
    36c2:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <SPID_write>
    val = SPID_write(val);
    36c6:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <SPID_write>
    36ca:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    36cc:	80 e0       	ldi	r24, 0x00	; 0
    36ce:	0e 94 83 1a 	call	0x3506	; 0x3506 <RadioCS>
    CHB_LEAVE_CRIT();
    36d2:	80 91 5c 40 	lds	r24, 0x405C
    36d6:	8f bf       	out	0x3f, r24	; 63
    36d8:	78 94       	sei

    return val;
}
    36da:	8c 2f       	mov	r24, r28
    36dc:	cf 91       	pop	r28
    36de:	08 95       	ret

000036e0 <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
    36e0:	81 e0       	ldi	r24, 0x01	; 1
    36e2:	0e 94 56 1b 	call	0x36ac	; 0x36ac <chb_reg_read>
}
    36e6:	8f 71       	andi	r24, 0x1F	; 31
    36e8:	08 95       	ret

000036ea <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    36ea:	1f 93       	push	r17
    36ec:	cf 93       	push	r28
    36ee:	df 93       	push	r29
    36f0:	c8 2f       	mov	r28, r24
    36f2:	16 2f       	mov	r17, r22
    36f4:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
    36f6:	0e 94 56 1b 	call	0x36ac	; 0x36ac <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
    36fa:	6d 2f       	mov	r22, r29
    36fc:	60 95       	com	r22
    36fe:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
    3700:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
    3702:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
    3704:	8c 2f       	mov	r24, r28
    3706:	0e 94 da 1a 	call	0x35b4	; 0x35b4 <chb_reg_write>
}
    370a:	df 91       	pop	r29
    370c:	cf 91       	pop	r28
    370e:	1f 91       	pop	r17
    3710:	08 95       	ret

00003712 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    3712:	cf 93       	push	r28
    3714:	df 93       	push	r29
    3716:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    3718:	80 91 64 06 	lds	r24, 0x0664
    371c:	81 fd       	sbrc	r24, 1
    371e:	53 c0       	rjmp	.+166    	; 0x37c6 <chb_set_state+0xb4>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    3720:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <chb_get_state>
    3724:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    3726:	81 51       	subi	r24, 0x11	; 17
    3728:	82 30       	cpi	r24, 0x02	; 2
    372a:	20 f0       	brcs	.+8      	; 0x3734 <chb_set_state+0x22>
    372c:	c1 30       	cpi	r28, 0x01	; 1
    372e:	11 f0       	breq	.+4      	; 0x3734 <chb_set_state+0x22>
    3730:	c2 30       	cpi	r28, 0x02	; 2
    3732:	21 f4       	brne	.+8      	; 0x373c <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
    3734:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <chb_get_state>
    3738:	8c 17       	cp	r24, r28
    373a:	e1 f3       	breq	.-8      	; 0x3734 <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    373c:	d6 31       	cpi	r29, 0x16	; 22
    373e:	f9 f0       	breq	.+62     	; 0x377e <chb_set_state+0x6c>
    3740:	d9 31       	cpi	r29, 0x19	; 25
    3742:	89 f0       	breq	.+34     	; 0x3766 <chb_set_state+0x54>
    3744:	d8 30       	cpi	r29, 0x08	; 8
    3746:	39 f5       	brne	.+78     	; 0x3796 <chb_set_state+0x84>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    3748:	e4 e6       	ldi	r30, 0x64	; 100
    374a:	f6 e0       	ldi	r31, 0x06	; 6
    374c:	80 81       	ld	r24, Z
    374e:	8d 7f       	andi	r24, 0xFD	; 253
    3750:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    3752:	82 e0       	ldi	r24, 0x02	; 2
    3754:	63 e0       	ldi	r22, 0x03	; 3
    3756:	4f e1       	ldi	r20, 0x1F	; 31
    3758:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>
    375c:	8a e0       	ldi	r24, 0x0A	; 10
    375e:	8a 95       	dec	r24
    3760:	f1 f7       	brne	.-4      	; 0x375e <chb_set_state+0x4c>
    3762:	00 c0       	rjmp	.+0      	; 0x3764 <chb_set_state+0x52>
    3764:	18 c0       	rjmp	.+48     	; 0x3796 <chb_set_state+0x84>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    3766:	c6 31       	cpi	r28, 0x16	; 22
    3768:	b1 f4       	brne	.+44     	; 0x3796 <chb_set_state+0x84>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    376a:	82 e0       	ldi	r24, 0x02	; 2
    376c:	69 e0       	ldi	r22, 0x09	; 9
    376e:	4f e1       	ldi	r20, 0x1F	; 31
    3770:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>
    3774:	9a e0       	ldi	r25, 0x0A	; 10
    3776:	9a 95       	dec	r25
    3778:	f1 f7       	brne	.-4      	; 0x3776 <chb_set_state+0x64>
    377a:	00 c0       	rjmp	.+0      	; 0x377c <chb_set_state+0x6a>
    377c:	2a c0       	rjmp	.+84     	; 0x37d2 <chb_set_state+0xc0>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    377e:	c9 31       	cpi	r28, 0x19	; 25
    3780:	51 f4       	brne	.+20     	; 0x3796 <chb_set_state+0x84>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    3782:	82 e0       	ldi	r24, 0x02	; 2
    3784:	69 e0       	ldi	r22, 0x09	; 9
    3786:	4f e1       	ldi	r20, 0x1F	; 31
    3788:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>
    378c:	8a e0       	ldi	r24, 0x0A	; 10
    378e:	8a 95       	dec	r24
    3790:	f1 f7       	brne	.-4      	; 0x378e <chb_set_state+0x7c>
    3792:	00 c0       	rjmp	.+0      	; 0x3794 <chb_set_state+0x82>
    3794:	1e c0       	rjmp	.+60     	; 0x37d2 <chb_set_state+0xc0>
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    3796:	82 e0       	ldi	r24, 0x02	; 2
    3798:	6d 2f       	mov	r22, r29
    379a:	4f e1       	ldi	r20, 0x1F	; 31
    379c:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
	if(curr_state == CHB_TRX_OFF){
    37a0:	c8 30       	cpi	r28, 0x08	; 8
    37a2:	39 f4       	brne	.+14     	; 0x37b2 <chb_set_state+0xa0>
    37a4:	8f e6       	ldi	r24, 0x6F	; 111
    37a6:	93 e0       	ldi	r25, 0x03	; 3
    37a8:	01 97       	sbiw	r24, 0x01	; 1
    37aa:	f1 f7       	brne	.-4      	; 0x37a8 <chb_set_state+0x96>
    37ac:	00 c0       	rjmp	.+0      	; 0x37ae <chb_set_state+0x9c>
    37ae:	00 00       	nop
    37b0:	04 c0       	rjmp	.+8      	; 0x37ba <chb_set_state+0xa8>
    37b2:	9a e0       	ldi	r25, 0x0A	; 10
    37b4:	9a 95       	dec	r25
    37b6:	f1 f7       	brne	.-4      	; 0x37b4 <chb_set_state+0xa2>
    37b8:	00 c0       	rjmp	.+0      	; 0x37ba <chb_set_state+0xa8>
	}
	else{
		_delay_us(TIME_RX_ON_PLL_ON);
	}				

    if (chb_get_state() == state)
    37ba:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <chb_get_state>
    37be:	8d 17       	cp	r24, r29
    37c0:	21 f4       	brne	.+8      	; 0x37ca <chb_set_state+0xb8>
    {
        return RADIO_SUCCESS;
    37c2:	80 e4       	ldi	r24, 0x40	; 64
    37c4:	03 c0       	rjmp	.+6      	; 0x37cc <chb_set_state+0xba>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
    37c6:	84 e4       	ldi	r24, 0x44	; 68
    37c8:	01 c0       	rjmp	.+2      	; 0x37cc <chb_set_state+0xba>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
    37ca:	83 e4       	ldi	r24, 0x43	; 67
}
    37cc:	df 91       	pop	r29
    37ce:	cf 91       	pop	r28
    37d0:	08 95       	ret
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    37d2:	82 e0       	ldi	r24, 0x02	; 2
    37d4:	6d 2f       	mov	r22, r29
    37d6:	4f e1       	ldi	r20, 0x1F	; 31
    37d8:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>
    37dc:	ea cf       	rjmp	.-44     	; 0x37b2 <chb_set_state+0xa0>

000037de <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
    37de:	88 23       	and	r24, r24
    37e0:	49 f0       	breq	.+18     	; 0x37f4 <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    37e2:	88 e0       	ldi	r24, 0x08	; 8
    37e4:	0e 94 89 1b 	call	0x3712	; 0x3712 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    37e8:	e4 e6       	ldi	r30, 0x64	; 100
    37ea:	f6 e0       	ldi	r31, 0x06	; 6
    37ec:	80 81       	ld	r24, Z
    37ee:	82 60       	ori	r24, 0x02	; 2
    37f0:	80 83       	st	Z, r24
    37f2:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    37f4:	e4 e6       	ldi	r30, 0x64	; 100
    37f6:	f6 e0       	ldi	r31, 0x06	; 6
    37f8:	80 81       	ld	r24, Z
    37fa:	8d 7f       	andi	r24, 0xFD	; 253
    37fc:	80 83       	st	Z, r24
    37fe:	8f e7       	ldi	r24, 0x7F	; 127
    3800:	97 e0       	ldi	r25, 0x07	; 7
    3802:	01 97       	sbiw	r24, 0x01	; 1
    3804:	f1 f7       	brne	.-4      	; 0x3802 <chb_sleep+0x24>
    3806:	00 c0       	rjmp	.+0      	; 0x3808 <chb_sleep+0x2a>
    3808:	00 00       	nop

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    380a:	86 e1       	ldi	r24, 0x16	; 22
    380c:	0e 94 89 1b 	call	0x3712	; 0x3712 <chb_set_state>
    3810:	08 95       	ret

00003812 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    3812:	cf 92       	push	r12
    3814:	df 92       	push	r13
    3816:	ef 92       	push	r14
    3818:	ff 92       	push	r15
    381a:	0f 93       	push	r16
    381c:	1f 93       	push	r17
    381e:	cf 93       	push	r28
    3820:	df 93       	push	r29
    3822:	7c 01       	movw	r14, r24
    3824:	6b 01       	movw	r12, r22
    3826:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
    3828:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <chb_get_state>
    382c:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
    382e:	0e 94 17 19 	call	0x322e	; 0x322e <chb_get_pcb>
    3832:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    3834:	12 30       	cpi	r17, 0x02	; 2
    3836:	e1 f0       	breq	.+56     	; 0x3870 <chb_tx+0x5e>
    3838:	12 31       	cpi	r17, 0x12	; 18
    383a:	e1 f0       	breq	.+56     	; 0x3874 <chb_tx+0x62>
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    //chb_set_state(CHB_TRX_OFF);
    chb_set_state(CHB_TX_ARET_ON);
    383c:	89 e1       	ldi	r24, 0x19	; 25
    383e:	0e 94 89 1b 	call	0x3712	; 0x3712 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    3842:	c7 01       	movw	r24, r14
    3844:	6a e0       	ldi	r22, 0x0A	; 10
    3846:	a6 01       	movw	r20, r12
    3848:	20 2f       	mov	r18, r16
    384a:	0e 94 8f 1a 	call	0x351e	; 0x351e <chb_frame_write>

    //Do frame transmission. 
	pcb->tx_end = false;
    384e:	18 86       	std	Y+8, r1	; 0x08
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    3850:	82 e0       	ldi	r24, 0x02	; 2
    3852:	62 e0       	ldi	r22, 0x02	; 2
    3854:	4f e1       	ldi	r20, 0x1F	; 31
    3856:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    385a:	88 85       	ldd	r24, Y+8	; 0x08
    385c:	88 23       	and	r24, r24
    385e:	e9 f3       	breq	.-6      	; 0x385a <chb_tx+0x48>
    pcb->tx_end = false;
    3860:	18 86       	std	Y+8, r1	; 0x08

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    3862:	82 e0       	ldi	r24, 0x02	; 2
    3864:	0e 94 56 1b 	call	0x36ac	; 0x36ac <chb_reg_read>
    3868:	82 95       	swap	r24
    386a:	86 95       	lsr	r24
    386c:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
    386e:	03 c0       	rjmp	.+6      	; 0x3876 <chb_tx+0x64>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
    3870:	84 e4       	ldi	r24, 0x44	; 68
    3872:	01 c0       	rjmp	.+2      	; 0x3876 <chb_tx+0x64>
    3874:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
    3876:	df 91       	pop	r29
    3878:	cf 91       	pop	r28
    387a:	1f 91       	pop	r17
    387c:	0f 91       	pop	r16
    387e:	ff 90       	pop	r15
    3880:	ef 90       	pop	r14
    3882:	df 90       	pop	r13
    3884:	cf 90       	pop	r12
    3886:	08 95       	ret

00003888 <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
    3888:	81 30       	cpi	r24, 0x01	; 1
    388a:	91 f0       	breq	.+36     	; 0x38b0 <chb_set_mode+0x28>
    388c:	81 30       	cpi	r24, 0x01	; 1
    388e:	28 f0       	brcs	.+10     	; 0x389a <chb_set_mode+0x12>
    3890:	82 30       	cpi	r24, 0x02	; 2
    3892:	c9 f0       	breq	.+50     	; 0x38c6 <chb_set_mode+0x3e>
    3894:	83 30       	cpi	r24, 0x03	; 3
    3896:	61 f5       	brne	.+88     	; 0x38f0 <chb_set_mode+0x68>
    3898:	21 c0       	rjmp	.+66     	; 0x38dc <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    389a:	8c e0       	ldi	r24, 0x0C	; 12
    389c:	68 e0       	ldi	r22, 0x08	; 8
    389e:	4f e3       	ldi	r20, 0x3F	; 63
    38a0:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    38a4:	86 e1       	ldi	r24, 0x16	; 22
    38a6:	62 e0       	ldi	r22, 0x02	; 2
    38a8:	43 e0       	ldi	r20, 0x03	; 3
    38aa:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>
        break;
    38ae:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    38b0:	8c e0       	ldi	r24, 0x0C	; 12
    38b2:	6c e0       	ldi	r22, 0x0C	; 12
    38b4:	4f e3       	ldi	r20, 0x3F	; 63
    38b6:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    38ba:	86 e1       	ldi	r24, 0x16	; 22
    38bc:	62 e0       	ldi	r22, 0x02	; 2
    38be:	43 e0       	ldi	r20, 0x03	; 3
    38c0:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>
        break;
    38c4:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    38c6:	8c e0       	ldi	r24, 0x0C	; 12
    38c8:	6c e1       	ldi	r22, 0x1C	; 28
    38ca:	4f e3       	ldi	r20, 0x3F	; 63
    38cc:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    38d0:	86 e1       	ldi	r24, 0x16	; 22
    38d2:	62 e0       	ldi	r22, 0x02	; 2
    38d4:	43 e0       	ldi	r20, 0x03	; 3
    38d6:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>
        break;
    38da:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    38dc:	8c e0       	ldi	r24, 0x0C	; 12
    38de:	60 e0       	ldi	r22, 0x00	; 0
    38e0:	4f e3       	ldi	r20, 0x3F	; 63
    38e2:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    38e6:	86 e1       	ldi	r24, 0x16	; 22
    38e8:	63 e0       	ldi	r22, 0x03	; 3
    38ea:	43 e0       	ldi	r20, 0x03	; 3
    38ec:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>
    38f0:	08 95       	ret

000038f2 <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    38f2:	cf 93       	push	r28
    38f4:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    38f6:	88 e0       	ldi	r24, 0x08	; 8
    38f8:	6c 2f       	mov	r22, r28
    38fa:	4f e1       	ldi	r20, 0x1F	; 31
    38fc:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    3900:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    3904:	86 30       	cpi	r24, 0x06	; 6
    3906:	11 f0       	breq	.+4      	; 0x390c <chb_set_channel+0x1a>
    3908:	89 30       	cpi	r24, 0x09	; 9
    390a:	31 f4       	brne	.+12     	; 0x3918 <chb_set_channel+0x26>
    390c:	8f e6       	ldi	r24, 0x6F	; 111
    390e:	93 e0       	ldi	r25, 0x03	; 3
    3910:	01 97       	sbiw	r24, 0x01	; 1
    3912:	f1 f7       	brne	.-4      	; 0x3910 <chb_set_channel+0x1e>
    3914:	00 c0       	rjmp	.+0      	; 0x3916 <chb_set_channel+0x24>
    3916:	00 00       	nop
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    3918:	88 e0       	ldi	r24, 0x08	; 8
    391a:	0e 94 56 1b 	call	0x36ac	; 0x36ac <chb_reg_read>
    391e:	90 e0       	ldi	r25, 0x00	; 0
    3920:	8f 71       	andi	r24, 0x1F	; 31
    3922:	90 70       	andi	r25, 0x00	; 0
    3924:	6c 2f       	mov	r22, r28
    3926:	70 e0       	ldi	r23, 0x00	; 0
    3928:	86 17       	cp	r24, r22
    392a:	97 07       	cpc	r25, r23
    392c:	11 f4       	brne	.+4      	; 0x3932 <chb_set_channel+0x40>
    392e:	80 e4       	ldi	r24, 0x40	; 64
    3930:	01 c0       	rjmp	.+2      	; 0x3934 <chb_set_channel+0x42>
    3932:	83 e4       	ldi	r24, 0x43	; 67
}
    3934:	cf 91       	pop	r28
    3936:	08 95       	ret

00003938 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    3938:	cf 93       	push	r28
    393a:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    393c:	0e 94 56 1b 	call	0x36ac	; 0x36ac <chb_reg_read>
    3940:	8c 2b       	or	r24, r28
    3942:	8f 5f       	subi	r24, 0xFF	; 255
    3944:	0e 94 56 1b 	call	0x36ac	; 0x36ac <chb_reg_read>
    }
    return val;
}
    3948:	80 e0       	ldi	r24, 0x00	; 0
    394a:	90 e0       	ldi	r25, 0x00	; 0
    394c:	cf 91       	pop	r28
    394e:	08 95       	ret

00003950 <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
    3950:	e4 e6       	ldi	r30, 0x64	; 100
    3952:	f6 e0       	ldi	r31, 0x06	; 6
    3954:	80 81       	ld	r24, Z
    3956:	81 60       	ori	r24, 0x01	; 1
    3958:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
    395a:	80 81       	ld	r24, Z
    395c:	8d 7f       	andi	r24, 0xFD	; 253
    395e:	80 83       	st	Z, r24
    3960:	8f ed       	ldi	r24, 0xDF	; 223
    3962:	9b e0       	ldi	r25, 0x0B	; 11
    3964:	01 97       	sbiw	r24, 0x01	; 1
    3966:	f1 f7       	brne	.-4      	; 0x3964 <chb_reset+0x14>
    3968:	00 c0       	rjmp	.+0      	; 0x396a <chb_reset+0x1a>
    396a:	00 00       	nop

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    396c:	80 81       	ld	r24, Z
    396e:	8e 7f       	andi	r24, 0xFE	; 254
    3970:	80 83       	st	Z, r24
    3972:	9a e0       	ldi	r25, 0x0A	; 10
    3974:	9a 95       	dec	r25
    3976:	f1 f7       	brne	.-4      	; 0x3974 <chb_reset+0x24>
    3978:	00 c0       	rjmp	.+0      	; 0x397a <chb_reset+0x2a>
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    397a:	80 81       	ld	r24, Z
    397c:	81 60       	ori	r24, 0x01	; 1
    397e:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    3980:	8d e1       	ldi	r24, 0x1D	; 29
    3982:	0e 94 56 1b 	call	0x36ac	; 0x36ac <chb_reg_read>
    3986:	81 30       	cpi	r24, 0x01	; 1
    3988:	d9 f7       	brne	.-10     	; 0x3980 <chb_reset+0x30>
    398a:	8c e1       	ldi	r24, 0x1C	; 28
    398c:	0e 94 56 1b 	call	0x36ac	; 0x36ac <chb_reg_read>
    3990:	87 30       	cpi	r24, 0x07	; 7
    3992:	b1 f7       	brne	.-20     	; 0x3980 <chb_reset+0x30>
            break;
        }
    }
	

}
    3994:	08 95       	ret

00003996 <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    3996:	0f 93       	push	r16
    3998:	1f 93       	push	r17
    399a:	cf 93       	push	r28
    399c:	df 93       	push	r29
    399e:	cd b7       	in	r28, 0x3d	; 61
    39a0:	de b7       	in	r29, 0x3e	; 62
    39a2:	ea 97       	sbiw	r28, 0x3a	; 58
    39a4:	cd bf       	out	0x3d, r28	; 61
    39a6:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    39a8:	0e 94 e0 1e 	call	0x3dc0	; 0x3dc0 <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    39ac:	e0 e6       	ldi	r30, 0x60	; 96
    39ae:	f6 e0       	ldi	r31, 0x06	; 6
    39b0:	80 81       	ld	r24, Z
    39b2:	82 60       	ori	r24, 0x02	; 2
    39b4:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    39b6:	80 81       	ld	r24, Z
    39b8:	81 60       	ori	r24, 0x01	; 1
    39ba:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    39bc:	0e 94 a8 1c 	call	0x3950	; 0x3950 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    39c0:	8e e0       	ldi	r24, 0x0E	; 14
    39c2:	60 e0       	ldi	r22, 0x00	; 0
    39c4:	0e 94 da 1a 	call	0x35b4	; 0x35b4 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    39c8:	82 e0       	ldi	r24, 0x02	; 2
    39ca:	63 e0       	ldi	r22, 0x03	; 3
    39cc:	4f e1       	ldi	r20, 0x1F	; 31
    39ce:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    39d2:	81 e0       	ldi	r24, 0x01	; 1
    39d4:	0e 94 56 1b 	call	0x36ac	; 0x36ac <chb_reg_read>
    39d8:	8f 71       	andi	r24, 0x1F	; 31
    39da:	88 30       	cpi	r24, 0x08	; 8
    39dc:	d1 f7       	brne	.-12     	; 0x39d2 <chb_drvr_init+0x3c>

    // set radio cfg parameters
    // **note** uncomment if these will be set to something other than default
    chb_reg_read_mod_write(XAH_CTRL_0, CHB_MAX_FRAME_RETRIES << CHB_MAX_FRAME_RETRIES_POS, 0xF << CHB_MAX_FRAME_RETRIES_POS);
    39de:	8c e2       	ldi	r24, 0x2C	; 44
    39e0:	60 e3       	ldi	r22, 0x30	; 48
    39e2:	40 ef       	ldi	r20, 0xF0	; 240
    39e4:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>
    //chb_reg_read_mod_write(XAH_CTRL_0, CHB_MAX_CSMA_RETRIES << CHB_MAX_CSMA_RETIRES_POS, 0x7 << CHB_MAX_CSMA_RETIRES_POS);
    //chb_reg_read_mod_write(CSMA_SEED_1, CHB_CSMA_SEED1 << CHB_CSMA_SEED1_POS, 0x7 << CHB_CSMA_SEED1_POS);
    chb_reg_write(CSMA_SEED_0, CHB_CSMA_SEED0);     
    39e8:	8d e2       	ldi	r24, 0x2D	; 45
    39ea:	60 e0       	ldi	r22, 0x00	; 0
    39ec:	0e 94 da 1a 	call	0x35b4	; 0x35b4 <chb_reg_write>
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    39f0:	8e e2       	ldi	r24, 0x2E	; 46
    39f2:	60 e4       	ldi	r22, 0x40	; 64
    39f4:	40 ec       	ldi	r20, 0xC0	; 192
    39f6:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    39fa:	8e e0       	ldi	r24, 0x0E	; 14
    39fc:	6c e0       	ldi	r22, 0x0C	; 12
    39fe:	0e 94 da 1a 	call	0x35b4	; 0x35b4 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    3a02:	84 e0       	ldi	r24, 0x04	; 4
    3a04:	60 e2       	ldi	r22, 0x20	; 32
    3a06:	40 e2       	ldi	r20, 0x20	; 32
    3a08:	0e 94 75 1b 	call	0x36ea	; 0x36ea <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    3a0c:	81 e0       	ldi	r24, 0x01	; 1
    3a0e:	0e 94 44 1c 	call	0x3888	; 0x3888 <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    3a12:	81 e0       	ldi	r24, 0x01	; 1
    3a14:	0e 94 79 1c 	call	0x38f2	; 0x38f2 <chb_set_channel>
	
	chb_set_pwr(0xE1);
    3a18:	81 ee       	ldi	r24, 0xE1	; 225
    3a1a:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <chb_set_pwr>
    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    3a1e:	86 e1       	ldi	r24, 0x16	; 22
    3a20:	0e 94 89 1b 	call	0x3712	; 0x3712 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    3a24:	82 e2       	ldi	r24, 0x22	; 34
    3a26:	64 e3       	ldi	r22, 0x34	; 52
    3a28:	72 e1       	ldi	r23, 0x12	; 18
    3a2a:	0e 94 21 1b 	call	0x3642	; 0x3642 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    3a2e:	0e 94 6d 1a 	call	0x34da	; 0x34da <chb_get_short_addr>
    3a32:	bc 01       	movw	r22, r24
    3a34:	80 e2       	ldi	r24, 0x20	; 32
    3a36:	0e 94 21 1b 	call	0x3642	; 0x3642 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    3a3a:	ce 01       	movw	r24, r28
    3a3c:	01 96       	adiw	r24, 0x01	; 1
    3a3e:	0e 94 65 1a 	call	0x34ca	; 0x34ca <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    3a42:	84 e2       	ldi	r24, 0x24	; 36
    3a44:	be 01       	movw	r22, r28
    3a46:	6f 5f       	subi	r22, 0xFF	; 255
    3a48:	7f 4f       	sbci	r23, 0xFF	; 255
    3a4a:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    3a4e:	e2 e7       	ldi	r30, 0x72	; 114
    3a50:	f6 e0       	ldi	r31, 0x06	; 6
    3a52:	80 81       	ld	r24, Z
    3a54:	81 60       	ori	r24, 0x01	; 1
    3a56:	80 83       	st	Z, r24
    3a58:	e9 e6       	ldi	r30, 0x69	; 105
    3a5a:	f6 e0       	ldi	r31, 0x06	; 6
    3a5c:	80 81       	ld	r24, Z
    3a5e:	83 60       	ori	r24, 0x03	; 3
    3a60:	80 83       	st	Z, r24
    3a62:	ea e6       	ldi	r30, 0x6A	; 106
    3a64:	f6 e0       	ldi	r31, 0x06	; 6
    3a66:	80 81       	ld	r24, Z
    3a68:	84 60       	ori	r24, 0x04	; 4
    3a6a:	80 83       	st	Z, r24
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    3a6c:	e0 ea       	ldi	r30, 0xA0	; 160
    3a6e:	f0 e0       	ldi	r31, 0x00	; 0
    3a70:	82 81       	ldd	r24, Z+2	; 0x02
    3a72:	87 60       	ori	r24, 0x07	; 7
    3a74:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
    3a76:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <chb_get_state>
    3a7a:	86 31       	cpi	r24, 0x16	; 22
    3a7c:	91 f0       	breq	.+36     	; 0x3aa2 <chb_drvr_init+0x10c>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    3a7e:	8e 01       	movw	r16, r28
    3a80:	07 5f       	subi	r16, 0xF7	; 247
    3a82:	1f 4f       	sbci	r17, 0xFF	; 255
    3a84:	c8 01       	movw	r24, r16
    3a86:	68 ee       	ldi	r22, 0xE8	; 232
    3a88:	71 e0       	ldi	r23, 0x01	; 1
    3a8a:	0e 94 d8 38 	call	0x71b0	; 0x71b0 <strcpy_P>
        printf(buf);
    3a8e:	0f 92       	push	r0
    3a90:	0f 92       	push	r0
    3a92:	ed b7       	in	r30, 0x3d	; 61
    3a94:	fe b7       	in	r31, 0x3e	; 62
    3a96:	01 83       	std	Z+1, r16	; 0x01
    3a98:	12 83       	std	Z+2, r17	; 0x02
    3a9a:	0e 94 1d 39 	call	0x723a	; 0x723a <printf>
    3a9e:	0f 90       	pop	r0
    3aa0:	0f 90       	pop	r0
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
    3aa2:	ea 96       	adiw	r28, 0x3a	; 58
    3aa4:	cd bf       	out	0x3d, r28	; 61
    3aa6:	de bf       	out	0x3e, r29	; 62
    3aa8:	df 91       	pop	r29
    3aaa:	cf 91       	pop	r28
    3aac:	1f 91       	pop	r17
    3aae:	0f 91       	pop	r16
    3ab0:	08 95       	ret

00003ab2 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    3ab2:	1f 92       	push	r1
    3ab4:	0f 92       	push	r0
    3ab6:	0f b6       	in	r0, 0x3f	; 63
    3ab8:	0f 92       	push	r0
    3aba:	0b b6       	in	r0, 0x3b	; 59
    3abc:	0f 92       	push	r0
    3abe:	11 24       	eor	r1, r1
    3ac0:	af 92       	push	r10
    3ac2:	bf 92       	push	r11
    3ac4:	cf 92       	push	r12
    3ac6:	df 92       	push	r13
    3ac8:	ef 92       	push	r14
    3aca:	ff 92       	push	r15
    3acc:	0f 93       	push	r16
    3ace:	1f 93       	push	r17
    3ad0:	2f 93       	push	r18
    3ad2:	3f 93       	push	r19
    3ad4:	4f 93       	push	r20
    3ad6:	5f 93       	push	r21
    3ad8:	6f 93       	push	r22
    3ada:	7f 93       	push	r23
    3adc:	8f 93       	push	r24
    3ade:	9f 93       	push	r25
    3ae0:	af 93       	push	r26
    3ae2:	bf 93       	push	r27
    3ae4:	cf 93       	push	r28
    3ae6:	df 93       	push	r29
    3ae8:	ef 93       	push	r30
    3aea:	ff 93       	push	r31
    U8 state, intp_src = 0;
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    3aec:	0e 94 17 19 	call	0x322e	; 0x322e <chb_get_pcb>
    3af0:	8c 01       	movw	r16, r24

    CHB_ENTER_CRIT();
    3af2:	8f b7       	in	r24, 0x3f	; 63
    3af4:	80 93 5c 40 	sts	0x405C, r24
    3af8:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    3afa:	81 e0       	ldi	r24, 0x01	; 1
    3afc:	0e 94 83 1a 	call	0x3506	; 0x3506 <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    3b00:	8f e8       	ldi	r24, 0x8F	; 143
    3b02:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <SPID_write>
    intp_src = SPID_write(0);
    3b06:	80 e0       	ldi	r24, 0x00	; 0
    3b08:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <SPID_write>
    3b0c:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    3b0e:	80 e0       	ldi	r24, 0x00	; 0
    3b10:	0e 94 83 1a 	call	0x3506	; 0x3506 <RadioCS>

    while (intp_src)
    3b14:	cc 23       	and	r28, r28
    3b16:	09 f4       	brne	.+2      	; 0x3b1a <__vector_64+0x68>
    3b18:	97 c0       	rjmp	.+302    	; 0x3c48 <__vector_64+0x196>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            //else{
                pcb->tx_end = true;
    3b1a:	ff 24       	eor	r15, r15
    3b1c:	f3 94       	inc	r15

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3b1e:	cc 24       	eor	r12, r12
    3b20:	dd 24       	eor	r13, r13
    3b22:	68 94       	set
    3b24:	c7 f8       	bld	r12, 7
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    3b26:	c2 ff       	sbrs	r28, 2
    3b28:	02 c0       	rjmp	.+4      	; 0x3b2e <__vector_64+0x7c>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    3b2a:	cb 7f       	andi	r28, 0xFB	; 251
    3b2c:	8a c0       	rjmp	.+276    	; 0x3c42 <__vector_64+0x190>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    3b2e:	c3 ff       	sbrs	r28, 3
    3b30:	6f c0       	rjmp	.+222    	; 0x3c10 <__vector_64+0x15e>
        {
            state = chb_get_state();
    3b32:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    3b36:	86 30       	cpi	r24, 0x06	; 6
    3b38:	29 f0       	breq	.+10     	; 0x3b44 <__vector_64+0x92>
    3b3a:	86 31       	cpi	r24, 0x16	; 22
    3b3c:	19 f0       	breq	.+6      	; 0x3b44 <__vector_64+0x92>
    3b3e:	81 31       	cpi	r24, 0x11	; 17
    3b40:	09 f0       	breq	.+2      	; 0x3b44 <__vector_64+0x92>
    3b42:	5a c0       	rjmp	.+180    	; 0x3bf8 <__vector_64+0x146>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    3b44:	87 e0       	ldi	r24, 0x07	; 7
    3b46:	0e 94 56 1b 	call	0x36ac	; 0x36ac <chb_reg_read>
    3b4a:	f8 01       	movw	r30, r16
    3b4c:	86 8b       	std	Z+22, r24	; 0x16

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    3b4e:	86 e0       	ldi	r24, 0x06	; 6
    3b50:	0e 94 56 1b 	call	0x36ac	; 0x36ac <chb_reg_read>
    3b54:	88 1f       	adc	r24, r24
    3b56:	88 27       	eor	r24, r24
    3b58:	88 1f       	adc	r24, r24
    3b5a:	f8 01       	movw	r30, r16
    3b5c:	87 8b       	std	Z+23, r24	; 0x17

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    3b5e:	88 23       	and	r24, r24
    3b60:	09 f4       	brne	.+2      	; 0x3b64 <__vector_64+0xb2>
    3b62:	4a c0       	rjmp	.+148    	; 0x3bf8 <__vector_64+0x146>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
    3b64:	8f b7       	in	r24, 0x3f	; 63
    3b66:	80 93 5c 40 	sts	0x405C, r24
    3b6a:	f8 94       	cli
    RadioCS(TRUE);
    3b6c:	8f 2d       	mov	r24, r15
    3b6e:	0e 94 83 1a 	call	0x3506	; 0x3506 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    3b72:	80 e2       	ldi	r24, 0x20	; 32
    3b74:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <SPID_write>
    len = SPID_write(0);
    3b78:	80 e0       	ldi	r24, 0x00	; 0
    3b7a:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <SPID_write>
    3b7e:	e8 2e       	mov	r14, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    3b80:	83 50       	subi	r24, 0x03	; 3
    3b82:	8d 37       	cpi	r24, 0x7D	; 125
    3b84:	58 f5       	brcc	.+86     	; 0x3bdc <__vector_64+0x12a>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3b86:	0e 94 62 1a 	call	0x34c4	; 0x34c4 <chb_buf_get_len>
    3b8a:	2e 2d       	mov	r18, r14
    3b8c:	30 e0       	ldi	r19, 0x00	; 0
    3b8e:	a6 01       	movw	r20, r12
    3b90:	48 1b       	sub	r20, r24
    3b92:	51 09       	sbc	r21, r1
    3b94:	24 17       	cp	r18, r20
    3b96:	35 07       	cpc	r19, r21
    3b98:	7c f4       	brge	.+30     	; 0x3bb8 <__vector_64+0x106>
        {
            chb_buf_write(len);
    3b9a:	8e 2d       	mov	r24, r14
    3b9c:	0e 94 36 1a 	call	0x346c	; 0x346c <chb_buf_write>
            
            for (i=0; i<len; i++)
    3ba0:	ee 20       	and	r14, r14
    3ba2:	e1 f0       	breq	.+56     	; 0x3bdc <__vector_64+0x12a>
    3ba4:	d0 e0       	ldi	r29, 0x00	; 0
            {
                data = SPID_write(0);
    3ba6:	80 e0       	ldi	r24, 0x00	; 0
    3ba8:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <SPID_write>
                chb_buf_write(data);
    3bac:	0e 94 36 1a 	call	0x346c	; 0x346c <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    3bb0:	df 5f       	subi	r29, 0xFF	; 255
    3bb2:	de 15       	cp	r29, r14
    3bb4:	c1 f7       	brne	.-16     	; 0x3ba6 <__vector_64+0xf4>
    3bb6:	12 c0       	rjmp	.+36     	; 0x3bdc <__vector_64+0x12a>
			//PORTE.OUTCLR = PIN2_bm;
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    3bb8:	0e 94 17 19 	call	0x322e	; 0x322e <chb_get_pcb>
    3bbc:	5c 01       	movw	r10, r24
            //char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3bbe:	ee 20       	and	r14, r14
    3bc0:	39 f0       	breq	.+14     	; 0x3bd0 <__vector_64+0x11e>
    3bc2:	d0 e0       	ldi	r29, 0x00	; 0
            {
                data = SPID_write(0);
    3bc4:	80 e0       	ldi	r24, 0x00	; 0
    3bc6:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            //char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    3bca:	df 5f       	subi	r29, 0xFF	; 255
    3bcc:	de 15       	cp	r29, r14
    3bce:	d1 f7       	brne	.-12     	; 0x3bc4 <__vector_64+0x112>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    3bd0:	f5 01       	movw	r30, r10
    3bd2:	81 89       	ldd	r24, Z+17	; 0x11
    3bd4:	92 89       	ldd	r25, Z+18	; 0x12
    3bd6:	01 96       	adiw	r24, 0x01	; 1
    3bd8:	81 8b       	std	Z+17, r24	; 0x11
    3bda:	92 8b       	std	Z+18, r25	; 0x12
            //strcpy_P(buf, chb_err_overflow);
            //printf(buf);
        }
    }

    RadioCS(FALSE);
    3bdc:	80 e0       	ldi	r24, 0x00	; 0
    3bde:	0e 94 83 1a 	call	0x3506	; 0x3506 <RadioCS>
    CHB_LEAVE_CRIT();
    3be2:	80 91 5c 40 	lds	r24, 0x405C
    3be6:	8f bf       	out	0x3f, r24	; 63
    3be8:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
    3bea:	f8 01       	movw	r30, r16
    3bec:	81 85       	ldd	r24, Z+9	; 0x09
    3bee:	92 85       	ldd	r25, Z+10	; 0x0a
    3bf0:	01 96       	adiw	r24, 0x01	; 1
    3bf2:	81 87       	std	Z+9, r24	; 0x09
    3bf4:	92 87       	std	Z+10, r25	; 0x0a
                    pcb->data_rcv = true;
    3bf6:	f7 82       	std	Z+7, r15	; 0x07
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            //else{
                pcb->tx_end = true;
    3bf8:	f8 01       	movw	r30, r16
    3bfa:	f0 86       	std	Z+8, r15	; 0x08
            //}
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    3bfc:	c7 7f       	andi	r28, 0xF7	; 247
			//go to receive state
            while (chb_get_state() != RX_STATE){
    3bfe:	03 c0       	rjmp	.+6      	; 0x3c06 <__vector_64+0x154>
	            chb_set_state(RX_STATE);
    3c00:	86 e1       	ldi	r24, 0x16	; 22
    3c02:	0e 94 89 1b 	call	0x3712	; 0x3712 <chb_set_state>
            //else{
                pcb->tx_end = true;
            //}
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
			//go to receive state
            while (chb_get_state() != RX_STATE){
    3c06:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <chb_get_state>
    3c0a:	86 31       	cpi	r24, 0x16	; 22
    3c0c:	c9 f7       	brne	.-14     	; 0x3c00 <__vector_64+0x14e>
    3c0e:	19 c0       	rjmp	.+50     	; 0x3c42 <__vector_64+0x190>
	            chb_set_state(RX_STATE);
            }
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    3c10:	c6 ff       	sbrs	r28, 6
    3c12:	08 c0       	rjmp	.+16     	; 0x3c24 <__vector_64+0x172>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    3c14:	cf 7b       	andi	r28, 0xBF	; 191
            pcb->underrun++;
    3c16:	f8 01       	movw	r30, r16
    3c18:	83 89       	ldd	r24, Z+19	; 0x13
    3c1a:	94 89       	ldd	r25, Z+20	; 0x14
    3c1c:	01 96       	adiw	r24, 0x01	; 1
    3c1e:	83 8b       	std	Z+19, r24	; 0x13
    3c20:	94 8b       	std	Z+20, r25	; 0x14
    3c22:	0f c0       	rjmp	.+30     	; 0x3c42 <__vector_64+0x190>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    3c24:	c1 ff       	sbrs	r28, 1
    3c26:	02 c0       	rjmp	.+4      	; 0x3c2c <__vector_64+0x17a>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    3c28:	cd 7f       	andi	r28, 0xFD	; 253
    3c2a:	0b c0       	rjmp	.+22     	; 0x3c42 <__vector_64+0x190>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    3c2c:	c0 ff       	sbrs	r28, 0
    3c2e:	02 c0       	rjmp	.+4      	; 0x3c34 <__vector_64+0x182>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    3c30:	ce 7f       	andi	r28, 0xFE	; 254
    3c32:	07 c0       	rjmp	.+14     	; 0x3c42 <__vector_64+0x190>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    3c34:	cc 23       	and	r28, r28
    3c36:	2c f4       	brge	.+10     	; 0x3c42 <__vector_64+0x190>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    3c38:	cf 77       	andi	r28, 0x7F	; 127
            pcb->battlow++;
    3c3a:	f8 01       	movw	r30, r16
    3c3c:	85 89       	ldd	r24, Z+21	; 0x15
    3c3e:	8f 5f       	subi	r24, 0xFF	; 255
    3c40:	85 8b       	std	Z+21, r24	; 0x15
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    3c42:	cc 23       	and	r28, r28
    3c44:	09 f0       	breq	.+2      	; 0x3c48 <__vector_64+0x196>
    3c46:	6f cf       	rjmp	.-290    	; 0x3b26 <__vector_64+0x74>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    3c48:	80 91 5c 40 	lds	r24, 0x405C
    3c4c:	8f bf       	out	0x3f, r24	; 63
    3c4e:	78 94       	sei
}
    3c50:	ff 91       	pop	r31
    3c52:	ef 91       	pop	r30
    3c54:	df 91       	pop	r29
    3c56:	cf 91       	pop	r28
    3c58:	bf 91       	pop	r27
    3c5a:	af 91       	pop	r26
    3c5c:	9f 91       	pop	r25
    3c5e:	8f 91       	pop	r24
    3c60:	7f 91       	pop	r23
    3c62:	6f 91       	pop	r22
    3c64:	5f 91       	pop	r21
    3c66:	4f 91       	pop	r20
    3c68:	3f 91       	pop	r19
    3c6a:	2f 91       	pop	r18
    3c6c:	1f 91       	pop	r17
    3c6e:	0f 91       	pop	r16
    3c70:	ff 90       	pop	r15
    3c72:	ef 90       	pop	r14
    3c74:	df 90       	pop	r13
    3c76:	cf 90       	pop	r12
    3c78:	bf 90       	pop	r11
    3c7a:	af 90       	pop	r10
    3c7c:	0f 90       	pop	r0
    3c7e:	0b be       	out	0x3b, r0	; 59
    3c80:	0f 90       	pop	r0
    3c82:	0f be       	out	0x3f, r0	; 63
    3c84:	0f 90       	pop	r0
    3c86:	1f 90       	pop	r1
    3c88:	18 95       	reti

00003c8a <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    3c8a:	0f 93       	push	r16
    3c8c:	1f 93       	push	r17
    3c8e:	cf 93       	push	r28
    3c90:	df 93       	push	r29
    3c92:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3c94:	e0 ec       	ldi	r30, 0xC0	; 192
    3c96:	f1 e0       	ldi	r31, 0x01	; 1
    3c98:	84 85       	ldd	r24, Z+12	; 0x0c
    3c9a:	87 7f       	andi	r24, 0xF7	; 247
    3c9c:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    3c9e:	41 15       	cp	r20, r1
    3ca0:	51 05       	cpc	r21, r1
    3ca2:	09 f4       	brne	.+2      	; 0x3ca6 <chb_eeprom_write+0x1c>
    3ca4:	50 c0       	rjmp	.+160    	; 0x3d46 <chb_eeprom_write+0xbc>
    3ca6:	e0 e0       	ldi	r30, 0x00	; 0
    3ca8:	f0 e0       	ldi	r31, 0x00	; 0
    3caa:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3cac:	a0 ec       	ldi	r26, 0xC0	; 192
    3cae:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3cb0:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3cb2:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3cb4:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
    3cb6:	cf 01       	movw	r24, r30
    3cb8:	80 0f       	add	r24, r16
    3cba:	91 1f       	adc	r25, r17
    3cbc:	e6 0f       	add	r30, r22
    3cbe:	f7 1f       	adc	r31, r23
    3cc0:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3cc2:	1f 96       	adiw	r26, 0x0f	; 15
    3cc4:	ec 91       	ld	r30, X
    3cc6:	1f 97       	sbiw	r26, 0x0f	; 15
    3cc8:	ee 23       	and	r30, r30
    3cca:	dc f3       	brlt	.-10     	; 0x3cc2 <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    3ccc:	1f 96       	adiw	r26, 0x0f	; 15
    3cce:	ec 91       	ld	r30, X
    3cd0:	1f 97       	sbiw	r26, 0x0f	; 15
    3cd2:	e1 ff       	sbrs	r30, 1
    3cd4:	11 c0       	rjmp	.+34     	; 0x3cf8 <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3cd6:	1a 96       	adiw	r26, 0x0a	; 10
    3cd8:	dc 93       	st	X, r29
    3cda:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
    3cdc:	ef 93       	push	r30
    3cde:	ff 93       	push	r31
    3ce0:	0f 93       	push	r16
    3ce2:	2f 93       	push	r18
    3ce4:	eb ec       	ldi	r30, 0xCB	; 203
    3ce6:	f1 e0       	ldi	r31, 0x01	; 1
    3ce8:	08 ed       	ldi	r16, 0xD8	; 216
    3cea:	21 e0       	ldi	r18, 0x01	; 1
    3cec:	04 bf       	out	0x34, r16	; 52
    3cee:	20 83       	st	Z, r18
    3cf0:	2f 91       	pop	r18
    3cf2:	0f 91       	pop	r16
    3cf4:	ff 91       	pop	r31
    3cf6:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3cf8:	1a 96       	adiw	r26, 0x0a	; 10
    3cfa:	cc 93       	st	X, r28
    3cfc:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    3cfe:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3d00:	89 2f       	mov	r24, r25
    3d02:	8f 71       	andi	r24, 0x1F	; 31
    3d04:	11 96       	adiw	r26, 0x01	; 1
    3d06:	8c 93       	st	X, r24
    3d08:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
    3d0a:	12 96       	adiw	r26, 0x02	; 2
    3d0c:	1c 92       	st	X, r1
    3d0e:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
    3d10:	14 96       	adiw	r26, 0x04	; 4
    3d12:	fc 93       	st	X, r31
    3d14:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3d16:	1a 96       	adiw	r26, 0x0a	; 10
    3d18:	3c 93       	st	X, r19
    3d1a:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
    3d1c:	ef 93       	push	r30
    3d1e:	ff 93       	push	r31
    3d20:	0f 93       	push	r16
    3d22:	2f 93       	push	r18
    3d24:	eb ec       	ldi	r30, 0xCB	; 203
    3d26:	f1 e0       	ldi	r31, 0x01	; 1
    3d28:	08 ed       	ldi	r16, 0xD8	; 216
    3d2a:	21 e0       	ldi	r18, 0x01	; 1
    3d2c:	04 bf       	out	0x34, r16	; 52
    3d2e:	20 83       	st	Z, r18
    3d30:	2f 91       	pop	r18
    3d32:	0f 91       	pop	r16
    3d34:	ff 91       	pop	r31
    3d36:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    3d38:	2f 5f       	subi	r18, 0xFF	; 255
    3d3a:	e2 2f       	mov	r30, r18
    3d3c:	f0 e0       	ldi	r31, 0x00	; 0
    3d3e:	e4 17       	cp	r30, r20
    3d40:	f5 07       	cpc	r31, r21
    3d42:	08 f4       	brcc	.+2      	; 0x3d46 <chb_eeprom_write+0xbc>
    3d44:	b8 cf       	rjmp	.-144    	; 0x3cb6 <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    3d46:	df 91       	pop	r29
    3d48:	cf 91       	pop	r28
    3d4a:	1f 91       	pop	r17
    3d4c:	0f 91       	pop	r16
    3d4e:	08 95       	ret

00003d50 <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    3d50:	1f 93       	push	r17
    3d52:	cf 93       	push	r28
    3d54:	df 93       	push	r29
    3d56:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3d58:	e0 ec       	ldi	r30, 0xC0	; 192
    3d5a:	f1 e0       	ldi	r31, 0x01	; 1
    3d5c:	84 85       	ldd	r24, Z+12	; 0x0c
    3d5e:	87 7f       	andi	r24, 0xF7	; 247
    3d60:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3d62:	41 15       	cp	r20, r1
    3d64:	51 05       	cpc	r21, r1
    3d66:	41 f1       	breq	.+80     	; 0x3db8 <chb_eeprom_read+0x68>
    3d68:	80 e0       	ldi	r24, 0x00	; 0
    3d6a:	90 e0       	ldi	r25, 0x00	; 0
    3d6c:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3d6e:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3d70:	db 01       	movw	r26, r22
    3d72:	a8 0f       	add	r26, r24
    3d74:	b9 1f       	adc	r27, r25
    3d76:	82 0f       	add	r24, r18
    3d78:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3d7a:	17 85       	ldd	r17, Z+15	; 0x0f
    3d7c:	11 23       	and	r17, r17
    3d7e:	ec f3       	brlt	.-6      	; 0x3d7a <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    3d80:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3d82:	89 2f       	mov	r24, r25
    3d84:	8f 71       	andi	r24, 0x1F	; 31
    3d86:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
    3d88:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    3d8a:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
    3d8c:	ef 93       	push	r30
    3d8e:	ff 93       	push	r31
    3d90:	0f 93       	push	r16
    3d92:	2f 93       	push	r18
    3d94:	eb ec       	ldi	r30, 0xCB	; 203
    3d96:	f1 e0       	ldi	r31, 0x01	; 1
    3d98:	08 ed       	ldi	r16, 0xD8	; 216
    3d9a:	21 e0       	ldi	r18, 0x01	; 1
    3d9c:	04 bf       	out	0x34, r16	; 52
    3d9e:	20 83       	st	Z, r18
    3da0:	2f 91       	pop	r18
    3da2:	0f 91       	pop	r16
    3da4:	ff 91       	pop	r31
    3da6:	ef 91       	pop	r30

    return NVM.DATA0;
    3da8:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3daa:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    3dac:	cf 5f       	subi	r28, 0xFF	; 255
    3dae:	8c 2f       	mov	r24, r28
    3db0:	90 e0       	ldi	r25, 0x00	; 0
    3db2:	84 17       	cp	r24, r20
    3db4:	95 07       	cpc	r25, r21
    3db6:	e0 f2       	brcs	.-72     	; 0x3d70 <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    3db8:	df 91       	pop	r29
    3dba:	cf 91       	pop	r28
    3dbc:	1f 91       	pop	r17
    3dbe:	08 95       	ret

00003dc0 <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    3dc0:	e0 e6       	ldi	r30, 0x60	; 96
    3dc2:	f6 e0       	ldi	r31, 0x06	; 6
    3dc4:	80 81       	ld	r24, Z
    3dc6:	80 6b       	ori	r24, 0xB0	; 176
    3dc8:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    3dca:	e4 e6       	ldi	r30, 0x64	; 100
    3dcc:	f6 e0       	ldi	r31, 0x06	; 6
    3dce:	80 81       	ld	r24, Z
    3dd0:	80 61       	ori	r24, 0x10	; 16
    3dd2:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    3dd4:	a0 ec       	ldi	r26, 0xC0	; 192
    3dd6:	b9 e0       	ldi	r27, 0x09	; 9
    3dd8:	8c 91       	ld	r24, X
    3dda:	81 65       	ori	r24, 0x51	; 81
    3ddc:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    3dde:	80 81       	ld	r24, Z
    3de0:	80 61       	ori	r24, 0x10	; 16
    3de2:	80 83       	st	Z, r24
}
    3de4:	08 95       	ret

00003de6 <SPID_write>:
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    3de6:	e0 ec       	ldi	r30, 0xC0	; 192
    3de8:	f9 e0       	ldi	r31, 0x09	; 9
    3dea:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    3dec:	82 81       	ldd	r24, Z+2	; 0x02
    3dee:	88 23       	and	r24, r24
    3df0:	ec f7       	brge	.-6      	; 0x3dec <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    3df2:	e0 ec       	ldi	r30, 0xC0	; 192
    3df4:	f9 e0       	ldi	r31, 0x09	; 9
    3df6:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    3df8:	08 95       	ret

00003dfa <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3dfa:	0f 93       	push	r16
    3dfc:	cf 93       	push	r28
    3dfe:	df 93       	push	r29
    3e00:	0f 92       	push	r0
    3e02:	cd b7       	in	r28, 0x3d	; 61
    3e04:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    3e06:	2f b7       	in	r18, 0x3f	; 63
    3e08:	29 83       	std	Y+1, r18	; 0x01
    3e0a:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    3e0c:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    3e0e:	fc 01       	movw	r30, r24
    3e10:	08 ed       	ldi	r16, 0xD8	; 216
    3e12:	04 bf       	out	0x34, r16	; 52
    3e14:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    3e16:	89 81       	ldd	r24, Y+1	; 0x01
    3e18:	8f bf       	out	0x3f, r24	; 63
#endif
}
    3e1a:	0f 90       	pop	r0
    3e1c:	df 91       	pop	r29
    3e1e:	cf 91       	pop	r28
    3e20:	0f 91       	pop	r16
    3e22:	08 95       	ret

00003e24 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    3e24:	66 23       	and	r22, r22
    3e26:	11 f0       	breq	.+4      	; 0x3e2c <CLKSYS_XOSC_Config+0x8>
    3e28:	90 e2       	ldi	r25, 0x20	; 32
    3e2a:	01 c0       	rjmp	.+2      	; 0x3e2e <CLKSYS_XOSC_Config+0xa>
    3e2c:	90 e0       	ldi	r25, 0x00	; 0
    3e2e:	84 2b       	or	r24, r20
    3e30:	89 2b       	or	r24, r25
    3e32:	e0 e5       	ldi	r30, 0x50	; 80
    3e34:	f0 e0       	ldi	r31, 0x00	; 0
    3e36:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    3e38:	08 95       	ret

00003e3a <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    3e3a:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    3e3c:	86 2b       	or	r24, r22
    3e3e:	e0 e5       	ldi	r30, 0x50	; 80
    3e40:	f0 e0       	ldi	r31, 0x00	; 0
    3e42:	85 83       	std	Z+5, r24	; 0x05
}
    3e44:	08 95       	ret

00003e46 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    3e46:	e0 e5       	ldi	r30, 0x50	; 80
    3e48:	f0 e0       	ldi	r31, 0x00	; 0
    3e4a:	90 81       	ld	r25, Z
    3e4c:	28 2f       	mov	r18, r24
    3e4e:	20 95       	com	r18
    3e50:	92 23       	and	r25, r18
    3e52:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    3e54:	90 81       	ld	r25, Z
	return clkEnabled;
}
    3e56:	89 23       	and	r24, r25
    3e58:	08 95       	ret

00003e5a <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    3e5a:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    3e5c:	81 e4       	ldi	r24, 0x41	; 65
    3e5e:	90 e0       	ldi	r25, 0x00	; 0
    3e60:	0e 94 fd 1e 	call	0x3dfa	; 0x3dfa <CCPWrite>
}
    3e64:	08 95       	ret

00003e66 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    3e66:	1f 93       	push	r17
    3e68:	cf 93       	push	r28
    3e6a:	df 93       	push	r29
    3e6c:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    3e6e:	c0 e4       	ldi	r28, 0x40	; 64
    3e70:	d0 e0       	ldi	r29, 0x00	; 0
    3e72:	68 81       	ld	r22, Y
    3e74:	68 7f       	andi	r22, 0xF8	; 248
    3e76:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    3e78:	80 e4       	ldi	r24, 0x40	; 64
    3e7a:	90 e0       	ldi	r25, 0x00	; 0
    3e7c:	0e 94 fd 1e 	call	0x3dfa	; 0x3dfa <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    3e80:	88 81       	ld	r24, Y
	return clkCtrl;
}
    3e82:	81 23       	and	r24, r17
    3e84:	df 91       	pop	r29
    3e86:	cf 91       	pop	r28
    3e88:	1f 91       	pop	r17
    3e8a:	08 95       	ret

00003e8c <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    3e8c:	e0 e4       	ldi	r30, 0x40	; 64
    3e8e:	f0 e0       	ldi	r31, 0x00	; 0
    3e90:	93 81       	ldd	r25, Z+3	; 0x03
    3e92:	91 7f       	andi	r25, 0xF1	; 241
    3e94:	91 60       	ori	r25, 0x01	; 1
    3e96:	89 2b       	or	r24, r25
    3e98:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    3e9a:	08 95       	ret

00003e9c <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    3e9c:	e0 e5       	ldi	r30, 0x50	; 80
    3e9e:	f0 e0       	ldi	r31, 0x00	; 0
    3ea0:	26 81       	ldd	r18, Z+6	; 0x06
    3ea2:	98 2f       	mov	r25, r24
    3ea4:	38 2f       	mov	r19, r24
    3ea6:	30 95       	com	r19
    3ea8:	23 23       	and	r18, r19
    3eaa:	66 23       	and	r22, r22
    3eac:	09 f4       	brne	.+2      	; 0x3eb0 <CLKSYS_AutoCalibration_Enable+0x14>
    3eae:	90 e0       	ldi	r25, 0x00	; 0
    3eb0:	92 2b       	or	r25, r18
    3eb2:	e0 e5       	ldi	r30, 0x50	; 80
    3eb4:	f0 e0       	ldi	r31, 0x00	; 0
    3eb6:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    3eb8:	81 30       	cpi	r24, 0x01	; 1
    3eba:	31 f4       	brne	.+12     	; 0x3ec8 <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    3ebc:	e8 e6       	ldi	r30, 0x68	; 104
    3ebe:	f0 e0       	ldi	r31, 0x00	; 0
    3ec0:	80 81       	ld	r24, Z
    3ec2:	81 60       	ori	r24, 0x01	; 1
    3ec4:	80 83       	st	Z, r24
    3ec6:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    3ec8:	82 30       	cpi	r24, 0x02	; 2
    3eca:	29 f4       	brne	.+10     	; 0x3ed6 <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    3ecc:	e0 e6       	ldi	r30, 0x60	; 96
    3ece:	f0 e0       	ldi	r31, 0x00	; 0
    3ed0:	80 81       	ld	r24, Z
    3ed2:	81 60       	ori	r24, 0x01	; 1
    3ed4:	80 83       	st	Z, r24
    3ed6:	08 95       	ret

00003ed8 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    3ed8:	83 e5       	ldi	r24, 0x53	; 83
    3eda:	90 e0       	ldi	r25, 0x00	; 0
    3edc:	63 e0       	ldi	r22, 0x03	; 3
    3ede:	0e 94 fd 1e 	call	0x3dfa	; 0x3dfa <CCPWrite>
}
    3ee2:	08 95       	ret

00003ee4 <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    3ee4:	82 e4       	ldi	r24, 0x42	; 66
    3ee6:	90 e0       	ldi	r25, 0x00	; 0
    3ee8:	61 e0       	ldi	r22, 0x01	; 1
    3eea:	0e 94 fd 1e 	call	0x3dfa	; 0x3dfa <CCPWrite>
}
    3eee:	08 95       	ret

00003ef0 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    3ef0:	cf 92       	push	r12
    3ef2:	df 92       	push	r13
    3ef4:	ef 92       	push	r14
    3ef6:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    3ef8:	20 91 6e 50 	lds	r18, 0x506E
    3efc:	30 91 6f 50 	lds	r19, 0x506F
    3f00:	c0 90 52 40 	lds	r12, 0x4052
    3f04:	d0 90 53 40 	lds	r13, 0x4053
    3f08:	e0 90 54 40 	lds	r14, 0x4054
    3f0c:	f0 90 55 40 	lds	r15, 0x4055
    3f10:	62 50       	subi	r22, 0x02	; 2
    3f12:	70 40       	sbci	r23, 0x00	; 0
    3f14:	80 40       	sbci	r24, 0x00	; 0
    3f16:	90 40       	sbci	r25, 0x00	; 0
    3f18:	40 e0       	ldi	r20, 0x00	; 0
    3f1a:	50 e0       	ldi	r21, 0x00	; 0
    3f1c:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    3f20:	dc 01       	movw	r26, r24
    3f22:	cb 01       	movw	r24, r22
    3f24:	c8 0e       	add	r12, r24
    3f26:	d9 1e       	adc	r13, r25
    3f28:	ea 1e       	adc	r14, r26
    3f2a:	fb 1e       	adc	r15, r27
}
    3f2c:	6c 2d       	mov	r22, r12
    3f2e:	7d 2d       	mov	r23, r13
    3f30:	8e 2d       	mov	r24, r14
    3f32:	9f 2d       	mov	r25, r15
    3f34:	ff 90       	pop	r15
    3f36:	ef 90       	pop	r14
    3f38:	df 90       	pop	r13
    3f3a:	cf 90       	pop	r12
    3f3c:	08 95       	ret

00003f3e <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    3f3e:	3f 92       	push	r3
    3f40:	4f 92       	push	r4
    3f42:	5f 92       	push	r5
    3f44:	6f 92       	push	r6
    3f46:	7f 92       	push	r7
    3f48:	8f 92       	push	r8
    3f4a:	9f 92       	push	r9
    3f4c:	af 92       	push	r10
    3f4e:	bf 92       	push	r11
    3f50:	cf 92       	push	r12
    3f52:	df 92       	push	r13
    3f54:	ef 92       	push	r14
    3f56:	ff 92       	push	r15
    3f58:	0f 93       	push	r16
    3f5a:	1f 93       	push	r17
    3f5c:	cf 93       	push	r28
    3f5e:	df 93       	push	r29
    3f60:	00 d0       	rcall	.+0      	; 0x3f62 <getSetNextCluster+0x24>
    3f62:	0f 92       	push	r0
    3f64:	cd b7       	in	r28, 0x3d	; 61
    3f66:	de b7       	in	r29, 0x3e	; 62
    3f68:	dc 01       	movw	r26, r24
    3f6a:	cb 01       	movw	r24, r22
    3f6c:	34 2e       	mov	r3, r20
    3f6e:	09 83       	std	Y+1, r16	; 0x01
    3f70:	1a 83       	std	Y+2, r17	; 0x02
    3f72:	2b 83       	std	Y+3, r18	; 0x03
    3f74:	3c 83       	std	Y+4, r19	; 0x04
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    3f76:	80 90 74 50 	lds	r8, 0x5074
    3f7a:	90 90 75 50 	lds	r9, 0x5075
    3f7e:	2c 01       	movw	r4, r24
    3f80:	3d 01       	movw	r6, r26
    3f82:	44 0c       	add	r4, r4
    3f84:	55 1c       	adc	r5, r5
    3f86:	66 1c       	adc	r6, r6
    3f88:	77 1c       	adc	r7, r7
    3f8a:	44 0c       	add	r4, r4
    3f8c:	55 1c       	adc	r5, r5
    3f8e:	66 1c       	adc	r6, r6
    3f90:	77 1c       	adc	r7, r7
    3f92:	20 91 5a 40 	lds	r18, 0x405A
    3f96:	30 91 5b 40 	lds	r19, 0x405B
    3f9a:	aa 24       	eor	r10, r10
    3f9c:	bb 24       	eor	r11, r11
    3f9e:	80 91 70 50 	lds	r24, 0x5070
    3fa2:	90 91 71 50 	lds	r25, 0x5071
    3fa6:	a0 91 72 50 	lds	r26, 0x5072
    3faa:	b0 91 73 50 	lds	r27, 0x5073
    3fae:	88 0e       	add	r8, r24
    3fb0:	99 1e       	adc	r9, r25
    3fb2:	aa 1e       	adc	r10, r26
    3fb4:	bb 1e       	adc	r11, r27
    3fb6:	40 e0       	ldi	r20, 0x00	; 0
    3fb8:	50 e0       	ldi	r21, 0x00	; 0
    3fba:	c3 01       	movw	r24, r6
    3fbc:	b2 01       	movw	r22, r4
    3fbe:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    3fc2:	69 01       	movw	r12, r18
    3fc4:	7a 01       	movw	r14, r20
    3fc6:	c8 0c       	add	r12, r8
    3fc8:	d9 1c       	adc	r13, r9
    3fca:	ea 1c       	adc	r14, r10
    3fcc:	fb 1c       	adc	r15, r11

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    3fce:	00 91 5a 40 	lds	r16, 0x405A
    3fd2:	10 91 5b 40 	lds	r17, 0x405B

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    3fd6:	c7 01       	movw	r24, r14
    3fd8:	b6 01       	movw	r22, r12
    3fda:	4d e4       	ldi	r20, 0x4D	; 77
    3fdc:	5e e3       	ldi	r21, 0x3E	; 62
    3fde:	0e 94 7e 2a 	call	0x54fc	; 0x54fc <SD_read_block>

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    3fe2:	98 01       	movw	r18, r16
    3fe4:	40 e0       	ldi	r20, 0x00	; 0
    3fe6:	50 e0       	ldi	r21, 0x00	; 0
    3fe8:	c3 01       	movw	r24, r6
    3fea:	b2 01       	movw	r22, r4
    3fec:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    3ff0:	63 5b       	subi	r22, 0xB3	; 179
    3ff2:	71 4c       	sbci	r23, 0xC1	; 193

if(get_set == GET)
    3ff4:	33 20       	and	r3, r3
    3ff6:	41 f4       	brne	.+16     	; 0x4008 <getSetNextCluster+0xca>
  return ((*FATEntryValue) & 0x0fffffff);
    3ff8:	db 01       	movw	r26, r22
    3ffa:	0d 91       	ld	r16, X+
    3ffc:	1d 91       	ld	r17, X+
    3ffe:	2d 91       	ld	r18, X+
    4000:	3c 91       	ld	r19, X
    4002:	13 97       	sbiw	r26, 0x03	; 3
    4004:	3f 70       	andi	r19, 0x0F	; 15
    4006:	14 c0       	rjmp	.+40     	; 0x4030 <getSetNextCluster+0xf2>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    4008:	89 81       	ldd	r24, Y+1	; 0x01
    400a:	9a 81       	ldd	r25, Y+2	; 0x02
    400c:	ab 81       	ldd	r26, Y+3	; 0x03
    400e:	bc 81       	ldd	r27, Y+4	; 0x04
    4010:	fb 01       	movw	r30, r22
    4012:	80 83       	st	Z, r24
    4014:	91 83       	std	Z+1, r25	; 0x01
    4016:	a2 83       	std	Z+2, r26	; 0x02
    4018:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    401a:	c7 01       	movw	r24, r14
    401c:	b6 01       	movw	r22, r12
    401e:	4d e4       	ldi	r20, 0x4D	; 77
    4020:	5e e3       	ldi	r21, 0x3E	; 62
    4022:	20 e0       	ldi	r18, 0x00	; 0
    4024:	32 e0       	ldi	r19, 0x02	; 2
    4026:	0e 94 c9 29 	call	0x5392	; 0x5392 <SD_write_block>

return (0);
    402a:	00 e0       	ldi	r16, 0x00	; 0
    402c:	10 e0       	ldi	r17, 0x00	; 0
    402e:	98 01       	movw	r18, r16
}
    4030:	60 2f       	mov	r22, r16
    4032:	71 2f       	mov	r23, r17
    4034:	82 2f       	mov	r24, r18
    4036:	93 2f       	mov	r25, r19
    4038:	24 96       	adiw	r28, 0x04	; 4
    403a:	cd bf       	out	0x3d, r28	; 61
    403c:	de bf       	out	0x3e, r29	; 62
    403e:	df 91       	pop	r29
    4040:	cf 91       	pop	r28
    4042:	1f 91       	pop	r17
    4044:	0f 91       	pop	r16
    4046:	ff 90       	pop	r15
    4048:	ef 90       	pop	r14
    404a:	df 90       	pop	r13
    404c:	cf 90       	pop	r12
    404e:	bf 90       	pop	r11
    4050:	af 90       	pop	r10
    4052:	9f 90       	pop	r9
    4054:	8f 90       	pop	r8
    4056:	7f 90       	pop	r7
    4058:	6f 90       	pop	r6
    405a:	5f 90       	pop	r5
    405c:	4f 90       	pop	r4
    405e:	3f 90       	pop	r3
    4060:	08 95       	ret

00004062 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    4062:	cf 92       	push	r12
    4064:	df 92       	push	r13
    4066:	ef 92       	push	r14
    4068:	ff 92       	push	r15
    406a:	0f 93       	push	r16
    406c:	1f 93       	push	r17
    406e:	cf 93       	push	r28
    4070:	c8 2f       	mov	r28, r24
    4072:	06 2f       	mov	r16, r22
    4074:	69 01       	movw	r12, r18
    4076:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    4078:	80 91 70 50 	lds	r24, 0x5070
    407c:	90 91 71 50 	lds	r25, 0x5071
    4080:	a0 91 72 50 	lds	r26, 0x5072
    4084:	b0 91 73 50 	lds	r27, 0x5073
    4088:	bc 01       	movw	r22, r24
    408a:	cd 01       	movw	r24, r26
    408c:	6f 5f       	subi	r22, 0xFF	; 255
    408e:	7f 4f       	sbci	r23, 0xFF	; 255
    4090:	8f 4f       	sbci	r24, 0xFF	; 255
    4092:	9f 4f       	sbci	r25, 0xFF	; 255
    4094:	4d e4       	ldi	r20, 0x4D	; 77
    4096:	5e e3       	ldi	r21, 0x3E	; 62
    4098:	0e 94 7e 2a 	call	0x54fc	; 0x54fc <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    409c:	80 91 4d 3e 	lds	r24, 0x3E4D
    40a0:	90 91 4e 3e 	lds	r25, 0x3E4E
    40a4:	a0 91 4f 3e 	lds	r26, 0x3E4F
    40a8:	b0 91 50 3e 	lds	r27, 0x3E50
    40ac:	82 35       	cpi	r24, 0x52	; 82
    40ae:	22 e5       	ldi	r18, 0x52	; 82
    40b0:	92 07       	cpc	r25, r18
    40b2:	21 e6       	ldi	r18, 0x61	; 97
    40b4:	a2 07       	cpc	r26, r18
    40b6:	21 e4       	ldi	r18, 0x41	; 65
    40b8:	b2 07       	cpc	r27, r18
    40ba:	09 f0       	breq	.+2      	; 0x40be <getSetFreeCluster+0x5c>
    40bc:	63 c0       	rjmp	.+198    	; 0x4184 <getSetFreeCluster+0x122>
    40be:	80 91 31 40 	lds	r24, 0x4031
    40c2:	90 91 32 40 	lds	r25, 0x4032
    40c6:	a0 91 33 40 	lds	r26, 0x4033
    40ca:	b0 91 34 40 	lds	r27, 0x4034
    40ce:	82 37       	cpi	r24, 0x72	; 114
    40d0:	22 e7       	ldi	r18, 0x72	; 114
    40d2:	92 07       	cpc	r25, r18
    40d4:	21 e4       	ldi	r18, 0x41	; 65
    40d6:	a2 07       	cpc	r26, r18
    40d8:	21 e6       	ldi	r18, 0x61	; 97
    40da:	b2 07       	cpc	r27, r18
    40dc:	09 f0       	breq	.+2      	; 0x40e0 <getSetFreeCluster+0x7e>
    40de:	56 c0       	rjmp	.+172    	; 0x418c <getSetFreeCluster+0x12a>
    40e0:	80 91 49 40 	lds	r24, 0x4049
    40e4:	90 91 4a 40 	lds	r25, 0x404A
    40e8:	a0 91 4b 40 	lds	r26, 0x404B
    40ec:	b0 91 4c 40 	lds	r27, 0x404C
    40f0:	80 30       	cpi	r24, 0x00	; 0
    40f2:	20 e0       	ldi	r18, 0x00	; 0
    40f4:	92 07       	cpc	r25, r18
    40f6:	25 e5       	ldi	r18, 0x55	; 85
    40f8:	a2 07       	cpc	r26, r18
    40fa:	2a ea       	ldi	r18, 0xAA	; 170
    40fc:	b2 07       	cpc	r27, r18
    40fe:	09 f0       	breq	.+2      	; 0x4102 <getSetFreeCluster+0xa0>
    4100:	49 c0       	rjmp	.+146    	; 0x4194 <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    4102:	00 23       	and	r16, r16
    4104:	a1 f4       	brne	.+40     	; 0x412e <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    4106:	c1 30       	cpi	r28, 0x01	; 1
    4108:	49 f4       	brne	.+18     	; 0x411c <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    410a:	00 91 35 40 	lds	r16, 0x4035
    410e:	10 91 36 40 	lds	r17, 0x4036
    4112:	20 91 37 40 	lds	r18, 0x4037
    4116:	30 91 38 40 	lds	r19, 0x4038
    411a:	3f c0       	rjmp	.+126    	; 0x419a <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    411c:	00 91 39 40 	lds	r16, 0x4039
    4120:	10 91 3a 40 	lds	r17, 0x403A
    4124:	20 91 3b 40 	lds	r18, 0x403B
    4128:	30 91 3c 40 	lds	r19, 0x403C
    412c:	36 c0       	rjmp	.+108    	; 0x419a <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    412e:	c1 30       	cpi	r28, 0x01	; 1
    4130:	49 f4       	brne	.+18     	; 0x4144 <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    4132:	c0 92 35 40 	sts	0x4035, r12
    4136:	d0 92 36 40 	sts	0x4036, r13
    413a:	e0 92 37 40 	sts	0x4037, r14
    413e:	f0 92 38 40 	sts	0x4038, r15
    4142:	08 c0       	rjmp	.+16     	; 0x4154 <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    4144:	c0 92 39 40 	sts	0x4039, r12
    4148:	d0 92 3a 40 	sts	0x403A, r13
    414c:	e0 92 3b 40 	sts	0x403B, r14
    4150:	f0 92 3c 40 	sts	0x403C, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    4154:	80 91 70 50 	lds	r24, 0x5070
    4158:	90 91 71 50 	lds	r25, 0x5071
    415c:	a0 91 72 50 	lds	r26, 0x5072
    4160:	b0 91 73 50 	lds	r27, 0x5073
    4164:	bc 01       	movw	r22, r24
    4166:	cd 01       	movw	r24, r26
    4168:	6f 5f       	subi	r22, 0xFF	; 255
    416a:	7f 4f       	sbci	r23, 0xFF	; 255
    416c:	8f 4f       	sbci	r24, 0xFF	; 255
    416e:	9f 4f       	sbci	r25, 0xFF	; 255
    4170:	4d e4       	ldi	r20, 0x4D	; 77
    4172:	5e e3       	ldi	r21, 0x3E	; 62
    4174:	20 e0       	ldi	r18, 0x00	; 0
    4176:	32 e0       	ldi	r19, 0x02	; 2
    4178:	0e 94 c9 29 	call	0x5392	; 0x5392 <SD_write_block>
 }
 return 0xffffffff;
    417c:	0f ef       	ldi	r16, 0xFF	; 255
    417e:	1f ef       	ldi	r17, 0xFF	; 255
    4180:	98 01       	movw	r18, r16
    4182:	0b c0       	rjmp	.+22     	; 0x419a <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    4184:	0f ef       	ldi	r16, 0xFF	; 255
    4186:	1f ef       	ldi	r17, 0xFF	; 255
    4188:	98 01       	movw	r18, r16
    418a:	07 c0       	rjmp	.+14     	; 0x419a <getSetFreeCluster+0x138>
    418c:	0f ef       	ldi	r16, 0xFF	; 255
    418e:	1f ef       	ldi	r17, 0xFF	; 255
    4190:	98 01       	movw	r18, r16
    4192:	03 c0       	rjmp	.+6      	; 0x419a <getSetFreeCluster+0x138>
    4194:	0f ef       	ldi	r16, 0xFF	; 255
    4196:	1f ef       	ldi	r17, 0xFF	; 255
    4198:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    419a:	60 2f       	mov	r22, r16
    419c:	71 2f       	mov	r23, r17
    419e:	82 2f       	mov	r24, r18
    41a0:	93 2f       	mov	r25, r19
    41a2:	cf 91       	pop	r28
    41a4:	1f 91       	pop	r17
    41a6:	0f 91       	pop	r16
    41a8:	ff 90       	pop	r15
    41aa:	ef 90       	pop	r14
    41ac:	df 90       	pop	r13
    41ae:	cf 90       	pop	r12
    41b0:	08 95       	ret

000041b2 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    41b2:	ef 92       	push	r14
    41b4:	ff 92       	push	r15
    41b6:	0f 93       	push	r16
    41b8:	1f 93       	push	r17
    41ba:	cf 93       	push	r28
    41bc:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    41be:	10 92 70 50 	sts	0x5070, r1
    41c2:	10 92 71 50 	sts	0x5071, r1
    41c6:	10 92 72 50 	sts	0x5072, r1
    41ca:	10 92 73 50 	sts	0x5073, r1

SD_read_block(0,SDBuffer);
    41ce:	60 e0       	ldi	r22, 0x00	; 0
    41d0:	70 e0       	ldi	r23, 0x00	; 0
    41d2:	cb 01       	movw	r24, r22
    41d4:	4d e4       	ldi	r20, 0x4D	; 77
    41d6:	5e e3       	ldi	r21, 0x3E	; 62
    41d8:	0e 94 7e 2a 	call	0x54fc	; 0x54fc <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    41dc:	80 91 4d 3e 	lds	r24, 0x3E4D
    41e0:	89 3e       	cpi	r24, 0xE9	; 233
    41e2:	31 f1       	breq	.+76     	; 0x4230 <getBootSectorData+0x7e>
    41e4:	8b 3e       	cpi	r24, 0xEB	; 235
    41e6:	21 f1       	breq	.+72     	; 0x4230 <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    41e8:	80 91 4b 40 	lds	r24, 0x404B
    41ec:	90 91 4c 40 	lds	r25, 0x404C
    41f0:	2a ea       	ldi	r18, 0xAA	; 170
    41f2:	85 35       	cpi	r24, 0x55	; 85
    41f4:	92 07       	cpc	r25, r18
    41f6:	09 f0       	breq	.+2      	; 0x41fa <getBootSectorData+0x48>
    41f8:	b7 c0       	rjmp	.+366    	; 0x4368 <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    41fa:	60 91 13 40 	lds	r22, 0x4013
    41fe:	70 91 14 40 	lds	r23, 0x4014
    4202:	80 91 15 40 	lds	r24, 0x4015
    4206:	90 91 16 40 	lds	r25, 0x4016
    420a:	60 93 70 50 	sts	0x5070, r22
    420e:	70 93 71 50 	sts	0x5071, r23
    4212:	80 93 72 50 	sts	0x5072, r24
    4216:	90 93 73 50 	sts	0x5073, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    421a:	4d e4       	ldi	r20, 0x4D	; 77
    421c:	5e e3       	ldi	r21, 0x3E	; 62
    421e:	0e 94 7e 2a 	call	0x54fc	; 0x54fc <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4222:	80 91 4d 3e 	lds	r24, 0x3E4D
    4226:	89 3e       	cpi	r24, 0xE9	; 233
    4228:	19 f0       	breq	.+6      	; 0x4230 <getBootSectorData+0x7e>
    422a:	8b 3e       	cpi	r24, 0xEB	; 235
    422c:	09 f0       	breq	.+2      	; 0x4230 <getBootSectorData+0x7e>
    422e:	9e c0       	rjmp	.+316    	; 0x436c <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    4230:	80 91 58 3e 	lds	r24, 0x3E58
    4234:	90 91 59 3e 	lds	r25, 0x3E59
    4238:	80 93 5a 40 	sts	0x405A, r24
    423c:	90 93 5b 40 	sts	0x405B, r25
sectorPerCluster = bpb->sectorPerCluster;
    4240:	80 91 5a 3e 	lds	r24, 0x3E5A
    4244:	90 e0       	ldi	r25, 0x00	; 0
    4246:	80 93 6e 50 	sts	0x506E, r24
    424a:	90 93 6f 50 	sts	0x506F, r25
reservedSectorCount = bpb->reservedSectorCount;
    424e:	e0 90 5b 3e 	lds	r14, 0x3E5B
    4252:	f0 90 5c 3e 	lds	r15, 0x3E5C
    4256:	e0 92 74 50 	sts	0x5074, r14
    425a:	f0 92 75 50 	sts	0x5075, r15
rootCluster = bpb->rootCluster;
    425e:	80 91 79 3e 	lds	r24, 0x3E79
    4262:	90 91 7a 3e 	lds	r25, 0x3E7A
    4266:	a0 91 7b 3e 	lds	r26, 0x3E7B
    426a:	b0 91 7c 3e 	lds	r27, 0x3E7C
    426e:	80 93 62 40 	sts	0x4062, r24
    4272:	90 93 63 40 	sts	0x4063, r25
    4276:	a0 93 64 40 	sts	0x4064, r26
    427a:	b0 93 65 40 	sts	0x4065, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    427e:	c0 91 74 50 	lds	r28, 0x5074
    4282:	d0 91 75 50 	lds	r29, 0x5075
    4286:	60 91 5d 3e 	lds	r22, 0x3E5D
    428a:	70 e0       	ldi	r23, 0x00	; 0
    428c:	80 e0       	ldi	r24, 0x00	; 0
    428e:	90 e0       	ldi	r25, 0x00	; 0
    4290:	20 91 71 3e 	lds	r18, 0x3E71
    4294:	30 91 72 3e 	lds	r19, 0x3E72
    4298:	40 91 73 3e 	lds	r20, 0x3E73
    429c:	50 91 74 3e 	lds	r21, 0x3E74
    42a0:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    42a4:	8b 01       	movw	r16, r22
    42a6:	9c 01       	movw	r18, r24
    42a8:	ae 01       	movw	r20, r28
    42aa:	60 e0       	ldi	r22, 0x00	; 0
    42ac:	70 e0       	ldi	r23, 0x00	; 0
    42ae:	80 91 69 3e 	lds	r24, 0x3E69
    42b2:	90 91 6a 3e 	lds	r25, 0x3E6A
    42b6:	a0 91 6b 3e 	lds	r26, 0x3E6B
    42ba:	b0 91 6c 3e 	lds	r27, 0x3E6C
    42be:	84 0f       	add	r24, r20
    42c0:	95 1f       	adc	r25, r21
    42c2:	a6 1f       	adc	r26, r22
    42c4:	b7 1f       	adc	r27, r23
    42c6:	80 0f       	add	r24, r16
    42c8:	91 1f       	adc	r25, r17
    42ca:	a2 1f       	adc	r26, r18
    42cc:	b3 1f       	adc	r27, r19
    42ce:	80 93 52 40 	sts	0x4052, r24
    42d2:	90 93 53 40 	sts	0x4053, r25
    42d6:	a0 93 54 40 	sts	0x4054, r26
    42da:	b0 93 55 40 	sts	0x4055, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    42de:	e0 91 6e 50 	lds	r30, 0x506E
    42e2:	f0 91 6f 50 	lds	r31, 0x506F
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    42e6:	c7 01       	movw	r24, r14
    42e8:	a0 e0       	ldi	r26, 0x00	; 0
    42ea:	b0 e0       	ldi	r27, 0x00	; 0
    42ec:	40 91 6d 3e 	lds	r20, 0x3E6D
    42f0:	50 91 6e 3e 	lds	r21, 0x3E6E
    42f4:	60 91 6f 3e 	lds	r22, 0x3E6F
    42f8:	70 91 70 3e 	lds	r23, 0x3E70
    42fc:	48 1b       	sub	r20, r24
    42fe:	59 0b       	sbc	r21, r25
    4300:	6a 0b       	sbc	r22, r26
    4302:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    4304:	cb 01       	movw	r24, r22
    4306:	ba 01       	movw	r22, r20
    4308:	60 1b       	sub	r22, r16
    430a:	71 0b       	sbc	r23, r17
    430c:	82 0b       	sbc	r24, r18
    430e:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    4310:	9f 01       	movw	r18, r30
    4312:	40 e0       	ldi	r20, 0x00	; 0
    4314:	50 e0       	ldi	r21, 0x00	; 0
    4316:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    431a:	20 93 5d 40 	sts	0x405D, r18
    431e:	30 93 5e 40 	sts	0x405E, r19
    4322:	40 93 5f 40 	sts	0x405F, r20
    4326:	50 93 60 40 	sts	0x4060, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    432a:	81 e0       	ldi	r24, 0x01	; 1
    432c:	60 e0       	ldi	r22, 0x00	; 0
    432e:	20 e0       	ldi	r18, 0x00	; 0
    4330:	30 e0       	ldi	r19, 0x00	; 0
    4332:	a9 01       	movw	r20, r18
    4334:	0e 94 31 20 	call	0x4062	; 0x4062 <getSetFreeCluster>
    4338:	ab 01       	movw	r20, r22
    433a:	bc 01       	movw	r22, r24
    433c:	80 91 5d 40 	lds	r24, 0x405D
    4340:	90 91 5e 40 	lds	r25, 0x405E
    4344:	a0 91 5f 40 	lds	r26, 0x405F
    4348:	b0 91 60 40 	lds	r27, 0x4060
    434c:	84 17       	cp	r24, r20
    434e:	95 07       	cpc	r25, r21
    4350:	a6 07       	cpc	r26, r22
    4352:	b7 07       	cpc	r27, r23
    4354:	20 f4       	brcc	.+8      	; 0x435e <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    4356:	10 92 a6 50 	sts	0x50A6, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    435a:	80 e0       	ldi	r24, 0x00	; 0
    435c:	08 c0       	rjmp	.+16     	; 0x436e <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    435e:	81 e0       	ldi	r24, 0x01	; 1
    4360:	80 93 a6 50 	sts	0x50A6, r24
return 0;
    4364:	80 e0       	ldi	r24, 0x00	; 0
    4366:	03 c0       	rjmp	.+6      	; 0x436e <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4368:	81 e0       	ldi	r24, 0x01	; 1
    436a:	01 c0       	rjmp	.+2      	; 0x436e <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    436c:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    436e:	df 91       	pop	r29
    4370:	cf 91       	pop	r28
    4372:	1f 91       	pop	r17
    4374:	0f 91       	pop	r16
    4376:	ff 90       	pop	r15
    4378:	ef 90       	pop	r14
    437a:	08 95       	ret

0000437c <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    437c:	0f 93       	push	r16
    437e:	1f 93       	push	r17
    4380:	cf 93       	push	r28
    4382:	df 93       	push	r29
    4384:	cd b7       	in	r28, 0x3d	; 61
    4386:	de b7       	in	r29, 0x3e	; 62
    4388:	2b 97       	sbiw	r28, 0x0b	; 11
    438a:	cd bf       	out	0x3d, r28	; 61
    438c:	de bf       	out	0x3e, r29	; 62
    438e:	78 2f       	mov	r23, r24
    4390:	69 2f       	mov	r22, r25
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    4392:	e8 2f       	mov	r30, r24
    4394:	f9 2f       	mov	r31, r25
    4396:	df 01       	movw	r26, r30
    4398:	0d 90       	ld	r0, X+
    439a:	00 20       	and	r0, r0
    439c:	e9 f7       	brne	.-6      	; 0x4398 <convertFileName+0x1c>
    439e:	11 97       	sbiw	r26, 0x01	; 1
    43a0:	ae 1b       	sub	r26, r30
    43a2:	bf 0b       	sbc	r27, r31
    43a4:	a0 31       	cpi	r26, 0x10	; 16
    43a6:	b1 05       	cpc	r27, r1
    43a8:	08 f0       	brcs	.+2      	; 0x43ac <convertFileName+0x30>
    43aa:	9c c0       	rjmp	.+312    	; 0x44e4 <convertFileName+0x168>
    43ac:	28 2f       	mov	r18, r24
    43ae:	39 2f       	mov	r19, r25
    43b0:	06 e9       	ldi	r16, 0x96	; 150
    43b2:	10 e5       	ldi	r17, 0x50	; 80
    43b4:	a8 01       	movw	r20, r16
    43b6:	80 e0       	ldi	r24, 0x00	; 0
    43b8:	90 e0       	ldi	r25, 0x00	; 0
    43ba:	07 c0       	rjmp	.+14     	; 0x43ca <convertFileName+0x4e>
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
    43bc:	d9 01       	movw	r26, r18
    43be:	ed 91       	ld	r30, X+
    43c0:	9d 01       	movw	r18, r26
    43c2:	da 01       	movw	r26, r20
    43c4:	ed 93       	st	X+, r30
    43c6:	ad 01       	movw	r20, r26

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    43c8:	01 96       	adiw	r24, 0x01	; 1
    43ca:	a7 2f       	mov	r26, r23
    43cc:	b6 2f       	mov	r27, r22
    43ce:	fd 01       	movw	r30, r26
    43d0:	01 90       	ld	r0, Z+
    43d2:	00 20       	and	r0, r0
    43d4:	e9 f7       	brne	.-6      	; 0x43d0 <convertFileName+0x54>
    43d6:	31 97       	sbiw	r30, 0x01	; 1
    43d8:	ea 1b       	sub	r30, r26
    43da:	fb 0b       	sbc	r31, r27
    43dc:	8e 17       	cp	r24, r30
    43de:	9f 07       	cpc	r25, r31
    43e0:	68 f3       	brcs	.-38     	; 0x43bc <convertFileName+0x40>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    43e2:	8f 30       	cpi	r24, 0x0F	; 15
    43e4:	91 05       	cpc	r25, r1
    43e6:	54 f4       	brge	.+20     	; 0x43fc <convertFileName+0x80>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    43e8:	fc 01       	movw	r30, r24
    43ea:	ea 56       	subi	r30, 0x6A	; 106
    43ec:	ff 4a       	sbci	r31, 0xAF	; 175
    43ee:	85 ea       	ldi	r24, 0xA5	; 165
    43f0:	90 e5       	ldi	r25, 0x50	; 80
if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    43f2:	20 e2       	ldi	r18, 0x20	; 32
    43f4:	21 93       	st	Z+, r18
    43f6:	e8 17       	cp	r30, r24
    43f8:	f9 07       	cpc	r31, r25
    43fa:	e1 f7       	brne	.-8      	; 0x43f4 <convertFileName+0x78>


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    43fc:	80 91 96 50 	lds	r24, 0x5096
    4400:	8e 32       	cpi	r24, 0x2E	; 46
    4402:	91 f0       	breq	.+36     	; 0x4428 <convertFileName+0xac>
    4404:	e7 e9       	ldi	r30, 0x97	; 151
    4406:	f0 e5       	ldi	r31, 0x50	; 80
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    4408:	21 e0       	ldi	r18, 0x01	; 1
if(Filename[j] == '.') break;
    440a:	81 91       	ld	r24, Z+
    440c:	8e 32       	cpi	r24, 0x2E	; 46
    440e:	21 f0       	breq	.+8      	; 0x4418 <convertFileName+0x9c>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    4410:	2f 5f       	subi	r18, 0xFF	; 255
    4412:	2c 30       	cpi	r18, 0x0C	; 12
    4414:	d1 f7       	brne	.-12     	; 0x440a <convertFileName+0x8e>
    4416:	05 c0       	rjmp	.+10     	; 0x4422 <convertFileName+0xa6>
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    4418:	82 2f       	mov	r24, r18
    441a:	89 50       	subi	r24, 0x09	; 9
    441c:	83 30       	cpi	r24, 0x03	; 3
    441e:	08 f4       	brcc	.+2      	; 0x4422 <convertFileName+0xa6>
    4420:	63 c0       	rjmp	.+198    	; 0x44e8 <convertFileName+0x16c>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4422:	22 23       	and	r18, r18
    4424:	29 f4       	brne	.+10     	; 0x4430 <convertFileName+0xb4>
    4426:	01 c0       	rjmp	.+2      	; 0x442a <convertFileName+0xae>
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
if(Filename[j] == '.') break;
    4428:	20 e0       	ldi	r18, 0x00	; 0
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    442a:	82 2f       	mov	r24, r18

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    442c:	90 e2       	ldi	r25, 0x20	; 32
    442e:	10 c0       	rjmp	.+32     	; 0x4450 <convertFileName+0xd4>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4430:	de 01       	movw	r26, r28
    4432:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4434:	82 2f       	mov	r24, r18
    4436:	81 50       	subi	r24, 0x01	; 1
    4438:	90 e0       	ldi	r25, 0x00	; 0
    443a:	89 56       	subi	r24, 0x69	; 105
    443c:	9f 4a       	sbci	r25, 0xAF	; 175
    443e:	f8 01       	movw	r30, r16
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];
    4440:	31 91       	ld	r19, Z+
    4442:	3d 93       	st	X+, r19

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    4444:	e8 17       	cp	r30, r24
    4446:	f9 07       	cpc	r31, r25
    4448:	d9 f7       	brne	.-10     	; 0x4440 <convertFileName+0xc4>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    444a:	28 30       	cpi	r18, 0x08	; 8
    444c:	70 f3       	brcs	.-36     	; 0x442a <convertFileName+0xae>
    444e:	0a c0       	rjmp	.+20     	; 0x4464 <convertFileName+0xe8>
  fileNameFAT[k] = ' ';
    4450:	e1 e0       	ldi	r30, 0x01	; 1
    4452:	f0 e0       	ldi	r31, 0x00	; 0
    4454:	ec 0f       	add	r30, r28
    4456:	fd 1f       	adc	r31, r29
    4458:	e8 0f       	add	r30, r24
    445a:	f1 1d       	adc	r31, r1
    445c:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    445e:	8f 5f       	subi	r24, 0xFF	; 255
    4460:	88 30       	cpi	r24, 0x08	; 8
    4462:	b0 f3       	brcs	.-20     	; 0x4450 <convertFileName+0xd4>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    4464:	2c 30       	cpi	r18, 0x0C	; 12
    4466:	09 f0       	breq	.+2      	; 0x446a <convertFileName+0xee>
    4468:	2f 5f       	subi	r18, 0xFF	; 255
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    446a:	38 e0       	ldi	r19, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    446c:	86 e9       	ldi	r24, 0x96	; 150
    446e:	90 e5       	ldi	r25, 0x50	; 80
    4470:	fc 01       	movw	r30, r24
    4472:	e2 0f       	add	r30, r18
    4474:	f1 1d       	adc	r31, r1
    4476:	40 81       	ld	r20, Z
    4478:	44 23       	and	r20, r20
    447a:	19 f4       	brne	.+6      	; 0x4482 <convertFileName+0x106>
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    447c:	3b 30       	cpi	r19, 0x0B	; 11
    447e:	50 f0       	brcs	.+20     	; 0x4494 <convertFileName+0x118>
    4480:	15 c0       	rjmp	.+42     	; 0x44ac <convertFileName+0x130>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
    4482:	e1 e0       	ldi	r30, 0x01	; 1
    4484:	f0 e0       	ldi	r31, 0x00	; 0
    4486:	ec 0f       	add	r30, r28
    4488:	fd 1f       	adc	r31, r29
    448a:	e3 0f       	add	r30, r19
    448c:	f1 1d       	adc	r31, r1
    448e:	40 83       	st	Z, r20
    4490:	2f 5f       	subi	r18, 0xFF	; 255
    4492:	0c c0       	rjmp	.+24     	; 0x44ac <convertFileName+0x130>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    4494:	80 e2       	ldi	r24, 0x20	; 32
    4496:	e1 e0       	ldi	r30, 0x01	; 1
    4498:	f0 e0       	ldi	r31, 0x00	; 0
    449a:	ec 0f       	add	r30, r28
    449c:	fd 1f       	adc	r31, r29
    449e:	e3 0f       	add	r30, r19
    44a0:	f1 1d       	adc	r31, r1
    44a2:	80 83       	st	Z, r24
    44a4:	3f 5f       	subi	r19, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    44a6:	3b 30       	cpi	r19, 0x0B	; 11
    44a8:	b1 f7       	brne	.-20     	; 0x4496 <convertFileName+0x11a>
    44aa:	03 c0       	rjmp	.+6      	; 0x44b2 <convertFileName+0x136>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    44ac:	3f 5f       	subi	r19, 0xFF	; 255
    44ae:	3b 30       	cpi	r19, 0x0B	; 11
    44b0:	f8 f2       	brcs	.-66     	; 0x4470 <convertFileName+0xf4>
    44b2:	de 01       	movw	r26, r28
    44b4:	11 96       	adiw	r26, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    44b6:	ce 01       	movw	r24, r28
    44b8:	0c 96       	adiw	r24, 0x0c	; 12
    44ba:	fd 01       	movw	r30, r26
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    44bc:	20 81       	ld	r18, Z
    44be:	32 2f       	mov	r19, r18
    44c0:	31 56       	subi	r19, 0x61	; 97
    44c2:	3a 31       	cpi	r19, 0x1A	; 26
    44c4:	10 f4       	brcc	.+4      	; 0x44ca <convertFileName+0x14e>
    fileNameFAT[j] -= 0x20;
    44c6:	20 52       	subi	r18, 0x20	; 32
    44c8:	20 83       	st	Z, r18
    44ca:	31 96       	adiw	r30, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    44cc:	e8 17       	cp	r30, r24
    44ce:	f9 07       	cpc	r31, r25
    44d0:	a9 f7       	brne	.-22     	; 0x44bc <convertFileName+0x140>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];
    44d2:	2d 91       	ld	r18, X+
    44d4:	f8 01       	movw	r30, r16
    44d6:	21 93       	st	Z+, r18
    44d8:	8f 01       	movw	r16, r30

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    44da:	a8 17       	cp	r26, r24
    44dc:	b9 07       	cpc	r27, r25
    44de:	c9 f7       	brne	.-14     	; 0x44d2 <convertFileName+0x156>
  Filename[j] = fileNameFAT[j];

return 0;
    44e0:	80 e0       	ldi	r24, 0x00	; 0
    44e2:	03 c0       	rjmp	.+6      	; 0x44ea <convertFileName+0x16e>
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    44e4:	81 e0       	ldi	r24, 0x01	; 1
    44e6:	01 c0       	rjmp	.+2      	; 0x44ea <convertFileName+0x16e>

for(j=0; j<12; j++)
if(Filename[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    44e8:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  Filename[j] = fileNameFAT[j];

return 0;
}
    44ea:	2b 96       	adiw	r28, 0x0b	; 11
    44ec:	cd bf       	out	0x3d, r28	; 61
    44ee:	de bf       	out	0x3e, r29	; 62
    44f0:	df 91       	pop	r29
    44f2:	cf 91       	pop	r28
    44f4:	1f 91       	pop	r17
    44f6:	0f 91       	pop	r16
    44f8:	08 95       	ret

000044fa <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    44fa:	4f 92       	push	r4
    44fc:	5f 92       	push	r5
    44fe:	6f 92       	push	r6
    4500:	7f 92       	push	r7
    4502:	8f 92       	push	r8
    4504:	9f 92       	push	r9
    4506:	af 92       	push	r10
    4508:	bf 92       	push	r11
    450a:	cf 92       	push	r12
    450c:	df 92       	push	r13
    450e:	ef 92       	push	r14
    4510:	ff 92       	push	r15
    4512:	cf 93       	push	r28
    4514:	df 93       	push	r29
    4516:	2b 01       	movw	r4, r22
    4518:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    451a:	20 e8       	ldi	r18, 0x80	; 128
    451c:	3f ef       	ldi	r19, 0xFF	; 255
    451e:	4f ef       	ldi	r20, 0xFF	; 255
    4520:	5f ef       	ldi	r21, 0xFF	; 255
    4522:	42 22       	and	r4, r18
    4524:	53 22       	and	r5, r19
    4526:	64 22       	and	r6, r20
    4528:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    452a:	80 91 5d 40 	lds	r24, 0x405D
    452e:	90 91 5e 40 	lds	r25, 0x405E
    4532:	a0 91 5f 40 	lds	r26, 0x405F
    4536:	b0 91 60 40 	lds	r27, 0x4060
    453a:	48 16       	cp	r4, r24
    453c:	59 06       	cpc	r5, r25
    453e:	6a 06       	cpc	r6, r26
    4540:	7b 06       	cpc	r7, r27
    4542:	08 f0       	brcs	.+2      	; 0x4546 <searchNextFreeCluster+0x4c>
    4544:	77 c0       	rjmp	.+238    	; 0x4634 <searchNextFreeCluster+0x13a>
    4546:	53 01       	movw	r10, r6
    4548:	42 01       	movw	r8, r4
    454a:	88 0c       	add	r8, r8
    454c:	99 1c       	adc	r9, r9
    454e:	aa 1c       	adc	r10, r10
    4550:	bb 1c       	adc	r11, r11
    4552:	88 0c       	add	r8, r8
    4554:	99 1c       	adc	r9, r9
    4556:	aa 1c       	adc	r10, r10
    4558:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    455a:	cd e4       	ldi	r28, 0x4D	; 77
    455c:	de e3       	ldi	r29, 0x3E	; 62
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    455e:	c0 90 74 50 	lds	r12, 0x5074
    4562:	d0 90 75 50 	lds	r13, 0x5075
    4566:	20 91 5a 40 	lds	r18, 0x405A
    456a:	30 91 5b 40 	lds	r19, 0x405B
    456e:	ee 24       	eor	r14, r14
    4570:	ff 24       	eor	r15, r15
    4572:	80 91 70 50 	lds	r24, 0x5070
    4576:	90 91 71 50 	lds	r25, 0x5071
    457a:	a0 91 72 50 	lds	r26, 0x5072
    457e:	b0 91 73 50 	lds	r27, 0x5073
    4582:	c8 0e       	add	r12, r24
    4584:	d9 1e       	adc	r13, r25
    4586:	ea 1e       	adc	r14, r26
    4588:	fb 1e       	adc	r15, r27
    458a:	40 e0       	ldi	r20, 0x00	; 0
    458c:	50 e0       	ldi	r21, 0x00	; 0
    458e:	c5 01       	movw	r24, r10
    4590:	b4 01       	movw	r22, r8
    4592:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    4596:	c7 01       	movw	r24, r14
    4598:	b6 01       	movw	r22, r12
    459a:	62 0f       	add	r22, r18
    459c:	73 1f       	adc	r23, r19
    459e:	84 1f       	adc	r24, r20
    45a0:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    45a2:	ae 01       	movw	r20, r28
    45a4:	0e 94 7e 2a 	call	0x54fc	; 0x54fc <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    45a8:	88 81       	ld	r24, Y
    45aa:	99 81       	ldd	r25, Y+1	; 0x01
    45ac:	aa 81       	ldd	r26, Y+2	; 0x02
    45ae:	bb 81       	ldd	r27, Y+3	; 0x03
    45b0:	bf 70       	andi	r27, 0x0F	; 15
    45b2:	00 97       	sbiw	r24, 0x00	; 0
    45b4:	a1 05       	cpc	r26, r1
    45b6:	b1 05       	cpc	r27, r1
    45b8:	99 f0       	breq	.+38     	; 0x45e0 <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    45ba:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    45bc:	e2 2f       	mov	r30, r18
    45be:	f0 e0       	ldi	r31, 0x00	; 0
    45c0:	ee 0f       	add	r30, r30
    45c2:	ff 1f       	adc	r31, r31
    45c4:	ee 0f       	add	r30, r30
    45c6:	ff 1f       	adc	r31, r31
         if(((*value) & 0x0fffffff) == 0)
    45c8:	e3 5b       	subi	r30, 0xB3	; 179
    45ca:	f1 4c       	sbci	r31, 0xC1	; 193
    45cc:	80 81       	ld	r24, Z
    45ce:	91 81       	ldd	r25, Z+1	; 0x01
    45d0:	a2 81       	ldd	r26, Z+2	; 0x02
    45d2:	b3 81       	ldd	r27, Z+3	; 0x03
    45d4:	bf 70       	andi	r27, 0x0F	; 15
    45d6:	00 97       	sbiw	r24, 0x00	; 0
    45d8:	a1 05       	cpc	r26, r1
    45da:	b1 05       	cpc	r27, r1
    45dc:	39 f4       	brne	.+14     	; 0x45ec <searchNextFreeCluster+0xf2>
    45de:	01 c0       	rjmp	.+2      	; 0x45e2 <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    45e0:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    45e2:	42 0e       	add	r4, r18
    45e4:	51 1c       	adc	r5, r1
    45e6:	61 1c       	adc	r6, r1
    45e8:	71 1c       	adc	r7, r1
    45ea:	27 c0       	rjmp	.+78     	; 0x463a <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    45ec:	2f 5f       	subi	r18, 0xFF	; 255
    45ee:	32 f7       	brpl	.-52     	; 0x45bc <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    45f0:	80 e8       	ldi	r24, 0x80	; 128
    45f2:	90 e0       	ldi	r25, 0x00	; 0
    45f4:	a0 e0       	ldi	r26, 0x00	; 0
    45f6:	b0 e0       	ldi	r27, 0x00	; 0
    45f8:	48 0e       	add	r4, r24
    45fa:	59 1e       	adc	r5, r25
    45fc:	6a 1e       	adc	r6, r26
    45fe:	7b 1e       	adc	r7, r27
    4600:	80 91 5d 40 	lds	r24, 0x405D
    4604:	90 91 5e 40 	lds	r25, 0x405E
    4608:	a0 91 5f 40 	lds	r26, 0x405F
    460c:	b0 91 60 40 	lds	r27, 0x4060
    4610:	20 e0       	ldi	r18, 0x00	; 0
    4612:	32 e0       	ldi	r19, 0x02	; 2
    4614:	40 e0       	ldi	r20, 0x00	; 0
    4616:	50 e0       	ldi	r21, 0x00	; 0
    4618:	82 0e       	add	r8, r18
    461a:	93 1e       	adc	r9, r19
    461c:	a4 1e       	adc	r10, r20
    461e:	b5 1e       	adc	r11, r21
    4620:	48 16       	cp	r4, r24
    4622:	59 06       	cpc	r5, r25
    4624:	6a 06       	cpc	r6, r26
    4626:	7b 06       	cpc	r7, r27
    4628:	08 f4       	brcc	.+2      	; 0x462c <searchNextFreeCluster+0x132>
    462a:	99 cf       	rjmp	.-206    	; 0x455e <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    462c:	44 24       	eor	r4, r4
    462e:	55 24       	eor	r5, r5
    4630:	32 01       	movw	r6, r4
    4632:	03 c0       	rjmp	.+6      	; 0x463a <searchNextFreeCluster+0x140>
    4634:	44 24       	eor	r4, r4
    4636:	55 24       	eor	r5, r5
    4638:	32 01       	movw	r6, r4
}
    463a:	64 2d       	mov	r22, r4
    463c:	75 2d       	mov	r23, r5
    463e:	86 2d       	mov	r24, r6
    4640:	97 2d       	mov	r25, r7
    4642:	df 91       	pop	r29
    4644:	cf 91       	pop	r28
    4646:	ff 90       	pop	r15
    4648:	ef 90       	pop	r14
    464a:	df 90       	pop	r13
    464c:	cf 90       	pop	r12
    464e:	bf 90       	pop	r11
    4650:	af 90       	pop	r10
    4652:	9f 90       	pop	r9
    4654:	8f 90       	pop	r8
    4656:	7f 90       	pop	r7
    4658:	6f 90       	pop	r6
    465a:	5f 90       	pop	r5
    465c:	4f 90       	pop	r4
    465e:	08 95       	ret

00004660 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    4660:	cf 92       	push	r12
    4662:	df 92       	push	r13
    4664:	ef 92       	push	r14
    4666:	ff 92       	push	r15
    4668:	cf 93       	push	r28
    466a:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    466c:	db 01       	movw	r26, r22
    466e:	ca 01       	movw	r24, r20
    4670:	91 70       	andi	r25, 0x01	; 1
    4672:	a0 70       	andi	r26, 0x00	; 0
    4674:	b0 70       	andi	r27, 0x00	; 0
    4676:	00 97       	sbiw	r24, 0x00	; 0
    4678:	a1 05       	cpc	r26, r1
    467a:	b1 05       	cpc	r27, r1
    467c:	51 f4       	brne	.+20     	; 0x4692 <freeMemoryUpdate+0x32>
    467e:	03 2e       	mov	r0, r19
    4680:	39 e0       	ldi	r19, 0x09	; 9
    4682:	76 95       	lsr	r23
    4684:	67 95       	ror	r22
    4686:	57 95       	ror	r21
    4688:	47 95       	ror	r20
    468a:	3a 95       	dec	r19
    468c:	d1 f7       	brne	.-12     	; 0x4682 <freeMemoryUpdate+0x22>
    468e:	30 2d       	mov	r19, r0
    4690:	0d c0       	rjmp	.+26     	; 0x46ac <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    4692:	03 2e       	mov	r0, r19
    4694:	39 e0       	ldi	r19, 0x09	; 9
    4696:	76 95       	lsr	r23
    4698:	67 95       	ror	r22
    469a:	57 95       	ror	r21
    469c:	47 95       	ror	r20
    469e:	3a 95       	dec	r19
    46a0:	d1 f7       	brne	.-12     	; 0x4696 <freeMemoryUpdate+0x36>
    46a2:	30 2d       	mov	r19, r0
    46a4:	4f 5f       	subi	r20, 0xFF	; 255
    46a6:	5f 4f       	sbci	r21, 0xFF	; 255
    46a8:	6f 4f       	sbci	r22, 0xFF	; 255
    46aa:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    46ac:	db 01       	movw	r26, r22
    46ae:	ca 01       	movw	r24, r20
    46b0:	87 70       	andi	r24, 0x07	; 7
    46b2:	90 70       	andi	r25, 0x00	; 0
    46b4:	a0 70       	andi	r26, 0x00	; 0
    46b6:	b0 70       	andi	r27, 0x00	; 0
    46b8:	00 97       	sbiw	r24, 0x00	; 0
    46ba:	a1 05       	cpc	r26, r1
    46bc:	b1 05       	cpc	r27, r1
    46be:	59 f4       	brne	.+22     	; 0x46d6 <freeMemoryUpdate+0x76>
    46c0:	6a 01       	movw	r12, r20
    46c2:	7b 01       	movw	r14, r22
    46c4:	68 94       	set
    46c6:	12 f8       	bld	r1, 2
    46c8:	f6 94       	lsr	r15
    46ca:	e7 94       	ror	r14
    46cc:	d7 94       	ror	r13
    46ce:	c7 94       	ror	r12
    46d0:	16 94       	lsr	r1
    46d2:	d1 f7       	brne	.-12     	; 0x46c8 <freeMemoryUpdate+0x68>
    46d4:	0f c0       	rjmp	.+30     	; 0x46f4 <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    46d6:	6a 01       	movw	r12, r20
    46d8:	7b 01       	movw	r14, r22
    46da:	68 94       	set
    46dc:	12 f8       	bld	r1, 2
    46de:	f6 94       	lsr	r15
    46e0:	e7 94       	ror	r14
    46e2:	d7 94       	ror	r13
    46e4:	c7 94       	ror	r12
    46e6:	16 94       	lsr	r1
    46e8:	d1 f7       	brne	.-12     	; 0x46de <freeMemoryUpdate+0x7e>
    46ea:	08 94       	sec
    46ec:	c1 1c       	adc	r12, r1
    46ee:	d1 1c       	adc	r13, r1
    46f0:	e1 1c       	adc	r14, r1
    46f2:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    46f4:	80 91 a6 50 	lds	r24, 0x50A6
    46f8:	88 23       	and	r24, r24
    46fa:	d1 f0       	breq	.+52     	; 0x4730 <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    46fc:	81 e0       	ldi	r24, 0x01	; 1
    46fe:	60 e0       	ldi	r22, 0x00	; 0
    4700:	20 e0       	ldi	r18, 0x00	; 0
    4702:	30 e0       	ldi	r19, 0x00	; 0
    4704:	a9 01       	movw	r20, r18
    4706:	0e 94 31 20 	call	0x4062	; 0x4062 <getSetFreeCluster>
	if(flag == ADD)
    470a:	cc 23       	and	r28, r28
    470c:	39 f4       	brne	.+14     	; 0x471c <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    470e:	9b 01       	movw	r18, r22
    4710:	ac 01       	movw	r20, r24
    4712:	2c 0d       	add	r18, r12
    4714:	3d 1d       	adc	r19, r13
    4716:	4e 1d       	adc	r20, r14
    4718:	5f 1d       	adc	r21, r15
    471a:	06 c0       	rjmp	.+12     	; 0x4728 <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    471c:	9b 01       	movw	r18, r22
    471e:	ac 01       	movw	r20, r24
    4720:	2c 19       	sub	r18, r12
    4722:	3d 09       	sbc	r19, r13
    4724:	4e 09       	sbc	r20, r14
    4726:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    4728:	81 e0       	ldi	r24, 0x01	; 1
    472a:	61 e0       	ldi	r22, 0x01	; 1
    472c:	0e 94 31 20 	call	0x4062	; 0x4062 <getSetFreeCluster>
  }
}
    4730:	cf 91       	pop	r28
    4732:	ff 90       	pop	r15
    4734:	ef 90       	pop	r14
    4736:	df 90       	pop	r13
    4738:	cf 90       	pop	r12
    473a:	08 95       	ret

0000473c <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    473c:	2f 92       	push	r2
    473e:	3f 92       	push	r3
    4740:	4f 92       	push	r4
    4742:	5f 92       	push	r5
    4744:	6f 92       	push	r6
    4746:	7f 92       	push	r7
    4748:	8f 92       	push	r8
    474a:	9f 92       	push	r9
    474c:	af 92       	push	r10
    474e:	bf 92       	push	r11
    4750:	cf 92       	push	r12
    4752:	df 92       	push	r13
    4754:	ef 92       	push	r14
    4756:	ff 92       	push	r15
    4758:	0f 93       	push	r16
    475a:	1f 93       	push	r17
    475c:	cf 93       	push	r28
    475e:	df 93       	push	r29
    4760:	cd b7       	in	r28, 0x3d	; 61
    4762:	de b7       	in	r29, 0x3e	; 62
    4764:	2c 97       	sbiw	r28, 0x0c	; 12
    4766:	cd bf       	out	0x3d, r28	; 61
    4768:	de bf       	out	0x3e, r29	; 62
    476a:	88 2e       	mov	r8, r24
    476c:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    476e:	80 91 62 40 	lds	r24, 0x4062
    4772:	90 91 63 40 	lds	r25, 0x4063
    4776:	a0 91 64 40 	lds	r26, 0x4064
    477a:	b0 91 65 40 	lds	r27, 0x4065
    477e:	89 87       	std	Y+9, r24	; 0x09
    4780:	9a 87       	std	Y+10, r25	; 0x0a
    4782:	ab 87       	std	Y+11, r26	; 0x0b
    4784:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4786:	0f 2e       	mov	r0, r31
    4788:	fd e4       	ldi	r31, 0x4D	; 77
    478a:	2f 2e       	mov	r2, r31
    478c:	fe e3       	ldi	r31, 0x3E	; 62
    478e:	3f 2e       	mov	r3, r31
    4790:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4792:	c8 2c       	mov	r12, r8
    4794:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4796:	d2 2c       	mov	r13, r2
    4798:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    479a:	5b 01       	movw	r10, r22
    479c:	08 94       	sec
    479e:	a1 1c       	adc	r10, r1
    47a0:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    47a2:	69 85       	ldd	r22, Y+9	; 0x09
    47a4:	7a 85       	ldd	r23, Y+10	; 0x0a
    47a6:	8b 85       	ldd	r24, Y+11	; 0x0b
    47a8:	9c 85       	ldd	r25, Y+12	; 0x0c
    47aa:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <getFirstSector>
    47ae:	6d 83       	std	Y+5, r22	; 0x05
    47b0:	7e 83       	std	Y+6, r23	; 0x06
    47b2:	8f 83       	std	Y+7, r24	; 0x07
    47b4:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    47b6:	80 91 6e 50 	lds	r24, 0x506E
    47ba:	90 91 6f 50 	lds	r25, 0x506F
    47be:	00 97       	sbiw	r24, 0x00	; 0
    47c0:	09 f4       	brne	.+2      	; 0x47c4 <findFiles+0x88>
    47c2:	13 c1       	rjmp	.+550    	; 0x49ea <findFiles+0x2ae>
    47c4:	44 24       	eor	r4, r4
    47c6:	55 24       	eor	r5, r5
    47c8:	32 01       	movw	r6, r4
    47ca:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    47cc:	8d 81       	ldd	r24, Y+5	; 0x05
    47ce:	9e 81       	ldd	r25, Y+6	; 0x06
    47d0:	af 81       	ldd	r26, Y+7	; 0x07
    47d2:	b8 85       	ldd	r27, Y+8	; 0x08
    47d4:	84 0d       	add	r24, r4
    47d6:	95 1d       	adc	r25, r5
    47d8:	a6 1d       	adc	r26, r6
    47da:	b7 1d       	adc	r27, r7
    47dc:	89 83       	std	Y+1, r24	; 0x01
    47de:	9a 83       	std	Y+2, r25	; 0x02
    47e0:	ab 83       	std	Y+3, r26	; 0x03
    47e2:	bc 83       	std	Y+4, r27	; 0x04
    47e4:	bc 01       	movw	r22, r24
    47e6:	cd 01       	movw	r24, r26
    47e8:	4d 2d       	mov	r20, r13
    47ea:	59 2d       	mov	r21, r9
    47ec:	0e 94 7e 2a 	call	0x54fc	; 0x54fc <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    47f0:	80 91 5a 40 	lds	r24, 0x405A
    47f4:	90 91 5b 40 	lds	r25, 0x405B
    47f8:	00 97       	sbiw	r24, 0x00	; 0
    47fa:	09 f4       	brne	.+2      	; 0x47fe <findFiles+0xc2>
    47fc:	e4 c0       	rjmp	.+456    	; 0x49c6 <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    47fe:	d1 01       	movw	r26, r2
    4800:	8c 91       	ld	r24, X
    4802:	88 23       	and	r24, r24
    4804:	09 f4       	brne	.+2      	; 0x4808 <findFiles+0xcc>
    4806:	10 c1       	rjmp	.+544    	; 0x4a28 <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4808:	4d 2d       	mov	r20, r13
    480a:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    480c:	20 e0       	ldi	r18, 0x00	; 0
    480e:	30 e0       	ldi	r19, 0x00	; 0
    4810:	08 c0       	rjmp	.+16     	; 0x4822 <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4812:	a9 01       	movw	r20, r18
    4814:	43 5b       	subi	r20, 0xB3	; 179
    4816:	51 4c       	sbci	r21, 0xC1	; 193

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4818:	fa 01       	movw	r30, r20
    481a:	80 81       	ld	r24, Z
    481c:	88 23       	and	r24, r24
    481e:	09 f4       	brne	.+2      	; 0x4822 <findFiles+0xe6>
    4820:	06 c1       	rjmp	.+524    	; 0x4a2e <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    4822:	85 3e       	cpi	r24, 0xE5	; 229
    4824:	09 f4       	brne	.+2      	; 0x4828 <findFiles+0xec>
    4826:	c5 c0       	rjmp	.+394    	; 0x49b2 <findFiles+0x276>
    4828:	da 01       	movw	r26, r20
    482a:	1b 96       	adiw	r26, 0x0b	; 11
    482c:	8c 91       	ld	r24, X
    482e:	1b 97       	sbiw	r26, 0x0b	; 11
    4830:	8f 30       	cpi	r24, 0x0F	; 15
    4832:	09 f4       	brne	.+2      	; 0x4836 <findFiles+0xfa>
    4834:	be c0       	rjmp	.+380    	; 0x49b2 <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    4836:	12 30       	cpi	r17, 0x02	; 2
    4838:	08 f0       	brcs	.+2      	; 0x483c <findFiles+0x100>
    483a:	fc c0       	rjmp	.+504    	; 0x4a34 <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    483c:	9c 91       	ld	r25, X
    483e:	f7 01       	movw	r30, r14
    4840:	80 81       	ld	r24, Z
    4842:	98 17       	cp	r25, r24
    4844:	09 f0       	breq	.+2      	; 0x4848 <findFiles+0x10c>
    4846:	b5 c0       	rjmp	.+362    	; 0x49b2 <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4848:	fa 01       	movw	r30, r20
    484a:	31 96       	adiw	r30, 0x01	; 1
    484c:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    484e:	81 e0       	ldi	r24, 0x01	; 1
    4850:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    4852:	41 91       	ld	r20, Z+
    4854:	9d 91       	ld	r25, X+
    4856:	49 17       	cp	r20, r25
    4858:	31 f4       	brne	.+12     	; 0x4866 <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    485a:	8f 5f       	subi	r24, 0xFF	; 255
    485c:	8b 30       	cpi	r24, 0x0B	; 11
    485e:	c9 f7       	brne	.-14     	; 0x4852 <findFiles+0x116>
    4860:	8b 01       	movw	r16, r22
    4862:	6b 01       	movw	r12, r22
    4864:	05 c0       	rjmp	.+10     	; 0x4870 <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    4866:	8b 30       	cpi	r24, 0x0B	; 11
    4868:	09 f0       	breq	.+2      	; 0x486c <findFiles+0x130>
    486a:	a3 c0       	rjmp	.+326    	; 0x49b2 <findFiles+0x276>
    486c:	8b 01       	movw	r16, r22
    486e:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    4870:	f1 e0       	ldi	r31, 0x01	; 1
    4872:	8f 16       	cp	r8, r31
    4874:	09 f0       	breq	.+2      	; 0x4878 <findFiles+0x13c>
    4876:	41 c0       	rjmp	.+130    	; 0x48fa <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    4878:	89 81       	ldd	r24, Y+1	; 0x01
    487a:	9a 81       	ldd	r25, Y+2	; 0x02
    487c:	ab 81       	ldd	r26, Y+3	; 0x03
    487e:	bc 81       	ldd	r27, Y+4	; 0x04
    4880:	80 93 a7 50 	sts	0x50A7, r24
    4884:	90 93 a8 50 	sts	0x50A8, r25
    4888:	a0 93 a9 50 	sts	0x50A9, r26
    488c:	b0 93 aa 50 	sts	0x50AA, r27
				appendFileLocation = i;
    4890:	c9 01       	movw	r24, r18
    4892:	a0 e0       	ldi	r26, 0x00	; 0
    4894:	b0 e0       	ldi	r27, 0x00	; 0
    4896:	80 93 4e 40 	sts	0x404E, r24
    489a:	90 93 4f 40 	sts	0x404F, r25
    489e:	a0 93 50 40 	sts	0x4050, r26
    48a2:	b0 93 51 40 	sts	0x4051, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    48a6:	d6 01       	movw	r26, r12
    48a8:	54 96       	adiw	r26, 0x14	; 20
    48aa:	4d 91       	ld	r20, X+
    48ac:	5c 91       	ld	r21, X
    48ae:	55 97       	sbiw	r26, 0x15	; 21
    48b0:	60 e0       	ldi	r22, 0x00	; 0
    48b2:	70 e0       	ldi	r23, 0x00	; 0
    48b4:	ba 01       	movw	r22, r20
    48b6:	55 27       	eor	r21, r21
    48b8:	44 27       	eor	r20, r20
    48ba:	5a 96       	adiw	r26, 0x1a	; 26
    48bc:	8d 91       	ld	r24, X+
    48be:	9c 91       	ld	r25, X
    48c0:	5b 97       	sbiw	r26, 0x1b	; 27
    48c2:	a0 e0       	ldi	r26, 0x00	; 0
    48c4:	b0 e0       	ldi	r27, 0x00	; 0
    48c6:	84 2b       	or	r24, r20
    48c8:	95 2b       	or	r25, r21
    48ca:	a6 2b       	or	r26, r22
    48cc:	b7 2b       	or	r27, r23
    48ce:	80 93 78 50 	sts	0x5078, r24
    48d2:	90 93 79 50 	sts	0x5079, r25
    48d6:	a0 93 7a 50 	sts	0x507A, r26
    48da:	b0 93 7b 50 	sts	0x507B, r27
				fileSize = dir->fileSize;
    48de:	f6 01       	movw	r30, r12
    48e0:	84 8d       	ldd	r24, Z+28	; 0x1c
    48e2:	95 8d       	ldd	r25, Z+29	; 0x1d
    48e4:	a6 8d       	ldd	r26, Z+30	; 0x1e
    48e6:	b7 8d       	ldd	r27, Z+31	; 0x1f
    48e8:	80 93 56 40 	sts	0x4056, r24
    48ec:	90 93 57 40 	sts	0x4057, r25
    48f0:	a0 93 58 40 	sts	0x4058, r26
    48f4:	b0 93 59 40 	sts	0x4059, r27
			    return (dir);
    48f8:	a5 c0       	rjmp	.+330    	; 0x4a44 <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    48fa:	d6 01       	movw	r26, r12
    48fc:	54 96       	adiw	r26, 0x14	; 20
    48fe:	8d 91       	ld	r24, X+
    4900:	9c 91       	ld	r25, X
    4902:	55 97       	sbiw	r26, 0x15	; 21
    4904:	a0 e0       	ldi	r26, 0x00	; 0
    4906:	b0 e0       	ldi	r27, 0x00	; 0
    4908:	3c 01       	movw	r6, r24
    490a:	55 24       	eor	r5, r5
    490c:	44 24       	eor	r4, r4
    490e:	f6 01       	movw	r30, r12
    4910:	82 8d       	ldd	r24, Z+26	; 0x1a
    4912:	93 8d       	ldd	r25, Z+27	; 0x1b
    4914:	a0 e0       	ldi	r26, 0x00	; 0
    4916:	b0 e0       	ldi	r27, 0x00	; 0
    4918:	48 2a       	or	r4, r24
    491a:	59 2a       	or	r5, r25
    491c:	6a 2a       	or	r6, r26
    491e:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    4920:	85 ee       	ldi	r24, 0xE5	; 229
    4922:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    4924:	69 81       	ldd	r22, Y+1	; 0x01
    4926:	7a 81       	ldd	r23, Y+2	; 0x02
    4928:	8b 81       	ldd	r24, Y+3	; 0x03
    492a:	9c 81       	ldd	r25, Y+4	; 0x04
    492c:	4d e4       	ldi	r20, 0x4D	; 77
    492e:	5e e3       	ldi	r21, 0x3E	; 62
    4930:	20 e0       	ldi	r18, 0x00	; 0
    4932:	32 e0       	ldi	r19, 0x02	; 2
    4934:	0e 94 c9 29 	call	0x5392	; 0x5392 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    4938:	d6 01       	movw	r26, r12
    493a:	5c 96       	adiw	r26, 0x1c	; 28
    493c:	4d 91       	ld	r20, X+
    493e:	5d 91       	ld	r21, X+
    4940:	6d 91       	ld	r22, X+
    4942:	7c 91       	ld	r23, X
    4944:	5f 97       	sbiw	r26, 0x1f	; 31
    4946:	80 e0       	ldi	r24, 0x00	; 0
    4948:	0e 94 30 23 	call	0x4660	; 0x4660 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    494c:	82 e0       	ldi	r24, 0x02	; 2
    494e:	60 e0       	ldi	r22, 0x00	; 0
    4950:	20 e0       	ldi	r18, 0x00	; 0
    4952:	30 e0       	ldi	r19, 0x00	; 0
    4954:	a9 01       	movw	r20, r18
    4956:	0e 94 31 20 	call	0x4062	; 0x4062 <getSetFreeCluster>
    495a:	dc 01       	movw	r26, r24
    495c:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    495e:	48 16       	cp	r4, r24
    4960:	59 06       	cpc	r5, r25
    4962:	6a 06       	cpc	r6, r26
    4964:	7b 06       	cpc	r7, r27
    4966:	30 f4       	brcc	.+12     	; 0x4974 <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    4968:	82 e0       	ldi	r24, 0x02	; 2
    496a:	61 e0       	ldi	r22, 0x01	; 1
    496c:	a3 01       	movw	r20, r6
    496e:	92 01       	movw	r18, r4
    4970:	0e 94 31 20 	call	0x4062	; 0x4062 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    4974:	c3 01       	movw	r24, r6
    4976:	b2 01       	movw	r22, r4
    4978:	40 e0       	ldi	r20, 0x00	; 0
    497a:	00 e0       	ldi	r16, 0x00	; 0
    497c:	10 e0       	ldi	r17, 0x00	; 0
    497e:	98 01       	movw	r18, r16
    4980:	0e 94 9f 1f 	call	0x3f3e	; 0x3f3e <getSetNextCluster>
    4984:	6b 01       	movw	r12, r22
    4986:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    4988:	c3 01       	movw	r24, r6
    498a:	b2 01       	movw	r22, r4
    498c:	41 e0       	ldi	r20, 0x01	; 1
    498e:	00 e0       	ldi	r16, 0x00	; 0
    4990:	10 e0       	ldi	r17, 0x00	; 0
    4992:	98 01       	movw	r18, r16
    4994:	0e 94 9f 1f 	call	0x3f3e	; 0x3f3e <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    4998:	b7 ef       	ldi	r27, 0xF7	; 247
    499a:	cb 16       	cp	r12, r27
    499c:	bf ef       	ldi	r27, 0xFF	; 255
    499e:	db 06       	cpc	r13, r27
    49a0:	bf ef       	ldi	r27, 0xFF	; 255
    49a2:	eb 06       	cpc	r14, r27
    49a4:	bf e0       	ldi	r27, 0x0F	; 15
    49a6:	fb 06       	cpc	r15, r27
    49a8:	08 f0       	brcs	.+2      	; 0x49ac <findFiles+0x270>
    49aa:	47 c0       	rjmp	.+142    	; 0x4a3a <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    49ac:	26 01       	movw	r4, r12
    49ae:	37 01       	movw	r6, r14
    49b0:	e1 cf       	rjmp	.-62     	; 0x4974 <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    49b2:	20 5e       	subi	r18, 0xE0	; 224
    49b4:	3f 4f       	sbci	r19, 0xFF	; 255
    49b6:	80 91 5a 40 	lds	r24, 0x405A
    49ba:	90 91 5b 40 	lds	r25, 0x405B
    49be:	28 17       	cp	r18, r24
    49c0:	39 07       	cpc	r19, r25
    49c2:	08 f4       	brcc	.+2      	; 0x49c6 <findFiles+0x28a>
    49c4:	26 cf       	rjmp	.-436    	; 0x4812 <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    49c6:	08 94       	sec
    49c8:	41 1c       	adc	r4, r1
    49ca:	51 1c       	adc	r5, r1
    49cc:	61 1c       	adc	r6, r1
    49ce:	71 1c       	adc	r7, r1
    49d0:	80 91 6e 50 	lds	r24, 0x506E
    49d4:	90 91 6f 50 	lds	r25, 0x506F
    49d8:	a0 e0       	ldi	r26, 0x00	; 0
    49da:	b0 e0       	ldi	r27, 0x00	; 0
    49dc:	48 16       	cp	r4, r24
    49de:	59 06       	cpc	r5, r25
    49e0:	6a 06       	cpc	r6, r26
    49e2:	7b 06       	cpc	r7, r27
    49e4:	08 f4       	brcc	.+2      	; 0x49e8 <findFiles+0x2ac>
    49e6:	f2 ce       	rjmp	.-540    	; 0x47cc <findFiles+0x90>
    49e8:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    49ea:	69 85       	ldd	r22, Y+9	; 0x09
    49ec:	7a 85       	ldd	r23, Y+10	; 0x0a
    49ee:	8b 85       	ldd	r24, Y+11	; 0x0b
    49f0:	9c 85       	ldd	r25, Y+12	; 0x0c
    49f2:	40 e0       	ldi	r20, 0x00	; 0
    49f4:	00 e0       	ldi	r16, 0x00	; 0
    49f6:	10 e0       	ldi	r17, 0x00	; 0
    49f8:	98 01       	movw	r18, r16
    49fa:	0e 94 9f 1f 	call	0x3f3e	; 0x3f3e <getSetNextCluster>
    49fe:	69 87       	std	Y+9, r22	; 0x09
    4a00:	7a 87       	std	Y+10, r23	; 0x0a
    4a02:	8b 87       	std	Y+11, r24	; 0x0b
    4a04:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    4a06:	67 3f       	cpi	r22, 0xF7	; 247
    4a08:	ef ef       	ldi	r30, 0xFF	; 255
    4a0a:	7e 07       	cpc	r23, r30
    4a0c:	ef ef       	ldi	r30, 0xFF	; 255
    4a0e:	8e 07       	cpc	r24, r30
    4a10:	ef e0       	ldi	r30, 0x0F	; 15
    4a12:	9e 07       	cpc	r25, r30
    4a14:	a8 f4       	brcc	.+42     	; 0x4a40 <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    4a16:	61 15       	cp	r22, r1
    4a18:	71 05       	cpc	r23, r1
    4a1a:	81 05       	cpc	r24, r1
    4a1c:	91 05       	cpc	r25, r1
    4a1e:	09 f0       	breq	.+2      	; 0x4a22 <findFiles+0x2e6>
    4a20:	c0 ce       	rjmp	.-640    	; 0x47a2 <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    4a22:	00 e0       	ldi	r16, 0x00	; 0
    4a24:	10 e0       	ldi	r17, 0x00	; 0
    4a26:	0e c0       	rjmp	.+28     	; 0x4a44 <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    4a28:	00 e0       	ldi	r16, 0x00	; 0
    4a2a:	10 e0       	ldi	r17, 0x00	; 0
    4a2c:	0b c0       	rjmp	.+22     	; 0x4a44 <findFiles+0x308>
    4a2e:	00 e0       	ldi	r16, 0x00	; 0
    4a30:	10 e0       	ldi	r17, 0x00	; 0
    4a32:	08 c0       	rjmp	.+16     	; 0x4a44 <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    4a34:	00 e0       	ldi	r16, 0x00	; 0
    4a36:	10 e0       	ldi	r17, 0x00	; 0
    4a38:	05 c0       	rjmp	.+10     	; 0x4a44 <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    4a3a:	00 e0       	ldi	r16, 0x00	; 0
    4a3c:	10 e0       	ldi	r17, 0x00	; 0
    4a3e:	02 c0       	rjmp	.+4      	; 0x4a44 <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    4a40:	00 e0       	ldi	r16, 0x00	; 0
    4a42:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    4a44:	80 2f       	mov	r24, r16
    4a46:	91 2f       	mov	r25, r17
    4a48:	2c 96       	adiw	r28, 0x0c	; 12
    4a4a:	cd bf       	out	0x3d, r28	; 61
    4a4c:	de bf       	out	0x3e, r29	; 62
    4a4e:	df 91       	pop	r29
    4a50:	cf 91       	pop	r28
    4a52:	1f 91       	pop	r17
    4a54:	0f 91       	pop	r16
    4a56:	ff 90       	pop	r15
    4a58:	ef 90       	pop	r14
    4a5a:	df 90       	pop	r13
    4a5c:	cf 90       	pop	r12
    4a5e:	bf 90       	pop	r11
    4a60:	af 90       	pop	r10
    4a62:	9f 90       	pop	r9
    4a64:	8f 90       	pop	r8
    4a66:	7f 90       	pop	r7
    4a68:	6f 90       	pop	r6
    4a6a:	5f 90       	pop	r5
    4a6c:	4f 90       	pop	r4
    4a6e:	3f 90       	pop	r3
    4a70:	2f 90       	pop	r2
    4a72:	08 95       	ret

00004a74 <deleteFile>:
//********************************************************************
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
    4a74:	0e 94 be 21 	call	0x437c	; 0x437c <convertFileName>
  if(error) return;
    4a78:	88 23       	and	r24, r24
    4a7a:	29 f4       	brne	.+10     	; 0x4a86 <deleteFile+0x12>

  findFiles (DELETE, Filename);
    4a7c:	82 e0       	ldi	r24, 0x02	; 2
    4a7e:	66 e9       	ldi	r22, 0x96	; 150
    4a80:	70 e5       	ldi	r23, 0x50	; 80
    4a82:	0e 94 9e 23 	call	0x473c	; 0x473c <findFiles>
    4a86:	08 95       	ret

00004a88 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    4a88:	4f 92       	push	r4
    4a8a:	5f 92       	push	r5
    4a8c:	6f 92       	push	r6
    4a8e:	7f 92       	push	r7
    4a90:	af 92       	push	r10
    4a92:	bf 92       	push	r11
    4a94:	cf 92       	push	r12
    4a96:	df 92       	push	r13
    4a98:	ef 92       	push	r14
    4a9a:	ff 92       	push	r15
    4a9c:	0f 93       	push	r16
    4a9e:	1f 93       	push	r17
    4aa0:	cf 93       	push	r28
    4aa2:	c8 2f       	mov	r28, r24
    4aa4:	cb 01       	movw	r24, r22
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    4aa6:	0e 94 be 21 	call	0x437c	; 0x437c <convertFileName>
if(error) return 2;
    4aaa:	88 23       	and	r24, r24
    4aac:	09 f0       	breq	.+2      	; 0x4ab0 <readFile+0x28>
    4aae:	57 c0       	rjmp	.+174    	; 0x4b5e <readFile+0xd6>

dir = findFiles (GET_FILE, Filename); //get the file location
    4ab0:	81 e0       	ldi	r24, 0x01	; 1
    4ab2:	66 e9       	ldi	r22, 0x96	; 150
    4ab4:	70 e5       	ldi	r23, 0x50	; 80
    4ab6:	0e 94 9e 23 	call	0x473c	; 0x473c <findFiles>
    4aba:	fc 01       	movw	r30, r24
if(dir == 0) 
    4abc:	00 97       	sbiw	r24, 0x00	; 0
    4abe:	31 f4       	brne	.+12     	; 0x4acc <readFile+0x44>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4ac0:	81 e0       	ldi	r24, 0x01	; 1
    4ac2:	cc 23       	and	r28, r28
    4ac4:	09 f4       	brne	.+2      	; 0x4ac8 <readFile+0x40>
    4ac6:	4e c0       	rjmp	.+156    	; 0x4b64 <readFile+0xdc>
    4ac8:	80 e0       	ldi	r24, 0x00	; 0
    4aca:	4c c0       	rjmp	.+152    	; 0x4b64 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4acc:	c1 30       	cpi	r28, 0x01	; 1
    4ace:	09 f4       	brne	.+2      	; 0x4ad2 <readFile+0x4a>
    4ad0:	48 c0       	rjmp	.+144    	; 0x4b62 <readFile+0xda>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4ad2:	44 88       	ldd	r4, Z+20	; 0x14
    4ad4:	55 88       	ldd	r5, Z+21	; 0x15
    4ad6:	66 24       	eor	r6, r6
    4ad8:	77 24       	eor	r7, r7
    4ada:	32 01       	movw	r6, r4
    4adc:	55 24       	eor	r5, r5
    4ade:	44 24       	eor	r4, r4
    4ae0:	82 8d       	ldd	r24, Z+26	; 0x1a
    4ae2:	93 8d       	ldd	r25, Z+27	; 0x1b
    4ae4:	a0 e0       	ldi	r26, 0x00	; 0
    4ae6:	b0 e0       	ldi	r27, 0x00	; 0
    4ae8:	48 2a       	or	r4, r24
    4aea:	59 2a       	or	r5, r25
    4aec:	6a 2a       	or	r6, r26
    4aee:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4af0:	0f 2e       	mov	r0, r31
    4af2:	f1 eb       	ldi	r31, 0xB1	; 177
    4af4:	af 2e       	mov	r10, r31
    4af6:	f1 e2       	ldi	r31, 0x21	; 33
    4af8:	bf 2e       	mov	r11, r31
    4afa:	f0 2d       	mov	r31, r0
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    4afc:	c3 01       	movw	r24, r6
    4afe:	b2 01       	movw	r22, r4
    4b00:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <getFirstSector>
    4b04:	6b 01       	movw	r12, r22
    4b06:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    4b08:	80 91 6e 50 	lds	r24, 0x506E
    4b0c:	90 91 6f 50 	lds	r25, 0x506F
    4b10:	00 97       	sbiw	r24, 0x00	; 0
    4b12:	a1 f0       	breq	.+40     	; 0x4b3c <readFile+0xb4>
    4b14:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4b16:	c7 01       	movw	r24, r14
    4b18:	b6 01       	movw	r22, r12
    4b1a:	6c 0f       	add	r22, r28
    4b1c:	71 1d       	adc	r23, r1
    4b1e:	81 1d       	adc	r24, r1
    4b20:	91 1d       	adc	r25, r1
    4b22:	a5 01       	movw	r20, r10
    4b24:	0e 94 7e 2a 	call	0x54fc	; 0x54fc <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    4b28:	cf 5f       	subi	r28, 0xFF	; 255
    4b2a:	80 91 6e 50 	lds	r24, 0x506E
    4b2e:	90 91 6f 50 	lds	r25, 0x506F
    4b32:	2c 2f       	mov	r18, r28
    4b34:	30 e0       	ldi	r19, 0x00	; 0
    4b36:	28 17       	cp	r18, r24
    4b38:	39 07       	cpc	r19, r25
    4b3a:	68 f3       	brcs	.-38     	; 0x4b16 <readFile+0x8e>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    4b3c:	c3 01       	movw	r24, r6
    4b3e:	b2 01       	movw	r22, r4
    4b40:	40 e0       	ldi	r20, 0x00	; 0
    4b42:	00 e0       	ldi	r16, 0x00	; 0
    4b44:	10 e0       	ldi	r17, 0x00	; 0
    4b46:	98 01       	movw	r18, r16
    4b48:	0e 94 9f 1f 	call	0x3f3e	; 0x3f3e <getSetNextCluster>
    4b4c:	2b 01       	movw	r4, r22
    4b4e:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    4b50:	61 15       	cp	r22, r1
    4b52:	71 05       	cpc	r23, r1
    4b54:	81 05       	cpc	r24, r1
    4b56:	91 05       	cpc	r25, r1
    4b58:	89 f6       	brne	.-94     	; 0x4afc <readFile+0x74>
	  return 0;}
    4b5a:	80 e0       	ldi	r24, 0x00	; 0
    4b5c:	03 c0       	rjmp	.+6      	; 0x4b64 <readFile+0xdc>
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4b5e:	82 e0       	ldi	r24, 0x02	; 2
    4b60:	01 c0       	rjmp	.+2      	; 0x4b64 <readFile+0xdc>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    4b62:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    4b64:	cf 91       	pop	r28
    4b66:	1f 91       	pop	r17
    4b68:	0f 91       	pop	r16
    4b6a:	ff 90       	pop	r15
    4b6c:	ef 90       	pop	r14
    4b6e:	df 90       	pop	r13
    4b70:	cf 90       	pop	r12
    4b72:	bf 90       	pop	r11
    4b74:	af 90       	pop	r10
    4b76:	7f 90       	pop	r7
    4b78:	6f 90       	pop	r6
    4b7a:	5f 90       	pop	r5
    4b7c:	4f 90       	pop	r4
    4b7e:	08 95       	ret

00004b80 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4b80:	2f 92       	push	r2
    4b82:	3f 92       	push	r3
    4b84:	4f 92       	push	r4
    4b86:	5f 92       	push	r5
    4b88:	6f 92       	push	r6
    4b8a:	7f 92       	push	r7
    4b8c:	8f 92       	push	r8
    4b8e:	9f 92       	push	r9
    4b90:	af 92       	push	r10
    4b92:	bf 92       	push	r11
    4b94:	cf 92       	push	r12
    4b96:	df 92       	push	r13
    4b98:	ef 92       	push	r14
    4b9a:	ff 92       	push	r15
    4b9c:	0f 93       	push	r16
    4b9e:	1f 93       	push	r17
    4ba0:	cf 93       	push	r28
    4ba2:	df 93       	push	r29
    4ba4:	cd b7       	in	r28, 0x3d	; 61
    4ba6:	de b7       	in	r29, 0x3e	; 62
    4ba8:	60 97       	sbiw	r28, 0x10	; 16
    4baa:	cd bf       	out	0x3d, r28	; 61
    4bac:	de bf       	out	0x3e, r29	; 62
    4bae:	fc 01       	movw	r30, r24
    4bb0:	6d 83       	std	Y+5, r22	; 0x05
    4bb2:	7e 83       	std	Y+6, r23	; 0x06
    4bb4:	49 01       	movw	r8, r18
    4bb6:	5a 01       	movw	r10, r20
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    4bb8:	81 e0       	ldi	r24, 0x01	; 1
    4bba:	bf 01       	movw	r22, r30
    4bbc:	0e 94 44 25 	call	0x4a88	; 0x4a88 <readFile>

if(j == 1) 
    4bc0:	81 30       	cpi	r24, 0x01	; 1
    4bc2:	09 f0       	breq	.+2      	; 0x4bc6 <writeFile+0x46>
    4bc4:	7b c0       	rjmp	.+246    	; 0x4cbc <writeFile+0x13c>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    4bc6:	00 91 78 50 	lds	r16, 0x5078
    4bca:	10 91 79 50 	lds	r17, 0x5079
    4bce:	20 91 7a 50 	lds	r18, 0x507A
    4bd2:	30 91 7b 50 	lds	r19, 0x507B
    4bd6:	09 83       	std	Y+1, r16	; 0x01
    4bd8:	1a 83       	std	Y+2, r17	; 0x02
    4bda:	2b 83       	std	Y+3, r18	; 0x03
    4bdc:	3c 83       	std	Y+4, r19	; 0x04
  clusterCount=0;
    4bde:	cc 24       	eor	r12, r12
    4be0:	dd 24       	eor	r13, r13
    4be2:	76 01       	movw	r14, r12
    4be4:	24 01       	movw	r4, r8
    4be6:	35 01       	movw	r6, r10
    4be8:	48 01       	movw	r8, r16
    4bea:	59 01       	movw	r10, r18
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    4bec:	c5 01       	movw	r24, r10
    4bee:	b4 01       	movw	r22, r8
    4bf0:	40 e0       	ldi	r20, 0x00	; 0
    4bf2:	00 e0       	ldi	r16, 0x00	; 0
    4bf4:	10 e0       	ldi	r17, 0x00	; 0
    4bf6:	98 01       	movw	r18, r16
    4bf8:	0e 94 9f 1f 	call	0x3f3e	; 0x3f3e <getSetNextCluster>
    4bfc:	dc 01       	movw	r26, r24
    4bfe:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    4c00:	8f 3f       	cpi	r24, 0xFF	; 255
    4c02:	1f ef       	ldi	r17, 0xFF	; 255
    4c04:	91 07       	cpc	r25, r17
    4c06:	1f ef       	ldi	r17, 0xFF	; 255
    4c08:	a1 07       	cpc	r26, r17
    4c0a:	1f ef       	ldi	r17, 0xFF	; 255
    4c0c:	b1 07       	cpc	r27, r17
    4c0e:	41 f0       	breq	.+16     	; 0x4c20 <writeFile+0xa0>
	cluster = nextCluster;
	clusterCount++;
    4c10:	08 94       	sec
    4c12:	c1 1c       	adc	r12, r1
    4c14:	d1 1c       	adc	r13, r1
    4c16:	e1 1c       	adc	r14, r1
    4c18:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    4c1a:	4c 01       	movw	r8, r24
    4c1c:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    4c1e:	e6 cf       	rjmp	.-52     	; 0x4bec <writeFile+0x6c>
    4c20:	89 82       	std	Y+1, r8	; 0x01
    4c22:	9a 82       	std	Y+2, r9	; 0x02
    4c24:	ab 82       	std	Y+3, r10	; 0x03
    4c26:	bc 82       	std	Y+4, r11	; 0x04
    4c28:	53 01       	movw	r10, r6
    4c2a:	42 01       	movw	r8, r4
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    4c2c:	20 91 6e 50 	lds	r18, 0x506E
    4c30:	30 91 6f 50 	lds	r19, 0x506F
    4c34:	80 91 5a 40 	lds	r24, 0x405A
    4c38:	90 91 5b 40 	lds	r25, 0x405B
    4c3c:	60 90 5a 40 	lds	r6, 0x405A
    4c40:	70 90 5b 40 	lds	r7, 0x405B
    4c44:	bc 01       	movw	r22, r24
    4c46:	80 e0       	ldi	r24, 0x00	; 0
    4c48:	90 e0       	ldi	r25, 0x00	; 0
    4c4a:	40 e0       	ldi	r20, 0x00	; 0
    4c4c:	50 e0       	ldi	r21, 0x00	; 0
    4c4e:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    4c52:	a7 01       	movw	r20, r14
    4c54:	96 01       	movw	r18, r12
    4c56:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    4c5a:	dc 01       	movw	r26, r24
    4c5c:	cb 01       	movw	r24, r22
    4c5e:	40 91 56 40 	lds	r20, 0x4056
    4c62:	50 91 57 40 	lds	r21, 0x4057
    4c66:	60 91 58 40 	lds	r22, 0x4058
    4c6a:	70 91 59 40 	lds	r23, 0x4059
    4c6e:	8a 01       	movw	r16, r20
    4c70:	9b 01       	movw	r18, r22
    4c72:	08 1b       	sub	r16, r24
    4c74:	19 0b       	sbc	r17, r25
    4c76:	2a 0b       	sbc	r18, r26
    4c78:	3b 0b       	sbc	r19, r27
    4c7a:	c9 01       	movw	r24, r18
    4c7c:	b8 01       	movw	r22, r16
    4c7e:	93 01       	movw	r18, r6
    4c80:	40 e0       	ldi	r20, 0x00	; 0
    4c82:	50 e0       	ldi	r21, 0x00	; 0
    4c84:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    4c88:	02 2f       	mov	r16, r18

//start writing data here

if(start){
  start = 0;
  startBlock = getFirstSector (cluster) + sector;
    4c8a:	69 81       	ldd	r22, Y+1	; 0x01
    4c8c:	7a 81       	ldd	r23, Y+2	; 0x02
    4c8e:	8b 81       	ldd	r24, Y+3	; 0x03
    4c90:	9c 81       	ldd	r25, Y+4	; 0x04
    4c92:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <getFirstSector>
    4c96:	dc 01       	movw	r26, r24
    4c98:	cb 01       	movw	r24, r22
    4c9a:	20 2e       	mov	r2, r16
    4c9c:	33 24       	eor	r3, r3
    4c9e:	28 0e       	add	r2, r24
    4ca0:	39 1e       	adc	r3, r25
  SD_read_block (startBlock,SDBuffer);
    4ca2:	b1 01       	movw	r22, r2
    4ca4:	80 e0       	ldi	r24, 0x00	; 0
    4ca6:	90 e0       	ldi	r25, 0x00	; 0
    4ca8:	4d e4       	ldi	r20, 0x4D	; 77
    4caa:	5e e3       	ldi	r21, 0x3E	; 62
    4cac:	0e 94 7e 2a 	call	0x54fc	; 0x54fc <SD_read_block>
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    4cb0:	1f 86       	std	Y+15, r1	; 0x0f
    4cb2:	18 8a       	std	Y+16, r1	; 0x10
    4cb4:	19 86       	std	Y+9, r1	; 0x09
    4cb6:	1a 86       	std	Y+10, r1	; 0x0a
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    4cb8:	11 e0       	ldi	r17, 0x01	; 1
    4cba:	4c c0       	rjmp	.+152    	; 0x4d54 <writeFile+0x1d4>
}
else if(j == 2) 
    4cbc:	82 30       	cpi	r24, 0x02	; 2
    4cbe:	09 f4       	brne	.+2      	; 0x4cc2 <writeFile+0x142>
    4cc0:	0c c2       	rjmp	.+1048   	; 0x50da <writeFile+0x55a>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    4cc2:	82 e0       	ldi	r24, 0x02	; 2
    4cc4:	60 e0       	ldi	r22, 0x00	; 0
    4cc6:	20 e0       	ldi	r18, 0x00	; 0
    4cc8:	30 e0       	ldi	r19, 0x00	; 0
    4cca:	a9 01       	movw	r20, r18
    4ccc:	0e 94 31 20 	call	0x4062	; 0x4062 <getSetFreeCluster>
  if(cluster > totalClusters)
    4cd0:	00 91 5d 40 	lds	r16, 0x405D
    4cd4:	10 91 5e 40 	lds	r17, 0x405E
    4cd8:	20 91 5f 40 	lds	r18, 0x405F
    4cdc:	30 91 60 40 	lds	r19, 0x4060
    4ce0:	06 17       	cp	r16, r22
    4ce2:	17 07       	cpc	r17, r23
    4ce4:	28 07       	cpc	r18, r24
    4ce6:	39 07       	cpc	r19, r25
    4ce8:	40 f4       	brcc	.+16     	; 0x4cfa <writeFile+0x17a>
     cluster = rootCluster;
    4cea:	60 91 62 40 	lds	r22, 0x4062
    4cee:	70 91 63 40 	lds	r23, 0x4063
    4cf2:	80 91 64 40 	lds	r24, 0x4064
    4cf6:	90 91 65 40 	lds	r25, 0x4065

  cluster = searchNextFreeCluster(cluster);
    4cfa:	0e 94 7d 22 	call	0x44fa	; 0x44fa <searchNextFreeCluster>
    4cfe:	69 83       	std	Y+1, r22	; 0x01
    4d00:	7a 83       	std	Y+2, r23	; 0x02
    4d02:	8b 83       	std	Y+3, r24	; 0x03
    4d04:	9c 83       	std	Y+4, r25	; 0x04
   if(cluster == 0)
    4d06:	61 15       	cp	r22, r1
    4d08:	71 05       	cpc	r23, r1
    4d0a:	81 05       	cpc	r24, r1
    4d0c:	91 05       	cpc	r25, r1
    4d0e:	09 f4       	brne	.+2      	; 0x4d12 <writeFile+0x192>
    4d10:	e6 c1       	rjmp	.+972    	; 0x50de <writeFile+0x55e>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    4d12:	41 e0       	ldi	r20, 0x01	; 1
    4d14:	0f ef       	ldi	r16, 0xFF	; 255
    4d16:	1f ef       	ldi	r17, 0xFF	; 255
    4d18:	98 01       	movw	r18, r16
    4d1a:	0e 94 9f 1f 	call	0x3f3e	; 0x3f3e <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    4d1e:	2b 81       	ldd	r18, Y+3	; 0x03
    4d20:	3c 81       	ldd	r19, Y+4	; 0x04
    4d22:	29 87       	std	Y+9, r18	; 0x09
    4d24:	3a 87       	std	Y+10, r19	; 0x0a
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    4d26:	89 81       	ldd	r24, Y+1	; 0x01
    4d28:	9a 81       	ldd	r25, Y+2	; 0x02
    4d2a:	8f 87       	std	Y+15, r24	; 0x0f
    4d2c:	98 8b       	std	Y+16, r25	; 0x10
  fileSize = 0;
    4d2e:	10 92 56 40 	sts	0x4056, r1
    4d32:	10 92 57 40 	sts	0x4057, r1
    4d36:	10 92 58 40 	sts	0x4058, r1
    4d3a:	10 92 59 40 	sts	0x4059, r1
  startBlock = getFirstSector (cluster) + sector;
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
    4d3e:	69 81       	ldd	r22, Y+1	; 0x01
    4d40:	7a 81       	ldd	r23, Y+2	; 0x02
    4d42:	8b 81       	ldd	r24, Y+3	; 0x03
    4d44:	9c 81       	ldd	r25, Y+4	; 0x04
    4d46:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <getFirstSector>
    4d4a:	dc 01       	movw	r26, r24
    4d4c:	cb 01       	movw	r24, r22
    4d4e:	1c 01       	movw	r2, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4d50:	10 e0       	ldi	r17, 0x00	; 0
  SD_read_block (startBlock,SDBuffer);
  j = sector;
}
else{
  startBlock = getFirstSector (cluster);
  j=0;
    4d52:	00 e0       	ldi	r16, 0x00	; 0
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    4d54:	81 14       	cp	r8, r1
    4d56:	91 04       	cpc	r9, r1
    4d58:	a1 04       	cpc	r10, r1
    4d5a:	b1 04       	cpc	r11, r1
    4d5c:	09 f4       	brne	.+2      	; 0x4d60 <writeFile+0x1e0>
    4d5e:	8d c0       	rjmp	.+282    	; 0x4e7a <writeFile+0x2fa>
    4d60:	44 24       	eor	r4, r4
    4d62:	55 24       	eor	r5, r5
    4d64:	32 01       	movw	r6, r4
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
		 writtenData += 512;
		 dataToWrite = 512;
    4d66:	c0 2e       	mov	r12, r16
    4d68:	1b 87       	std	Y+11, r17	; 0x0b
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    4d6a:	90 e0       	ldi	r25, 0x00	; 0
    4d6c:	89 16       	cp	r8, r25
    4d6e:	92 e0       	ldi	r25, 0x02	; 2
    4d70:	99 06       	cpc	r9, r25
    4d72:	90 e0       	ldi	r25, 0x00	; 0
    4d74:	a9 06       	cpc	r10, r25
    4d76:	90 e0       	ldi	r25, 0x00	; 0
    4d78:	b9 06       	cpc	r11, r25
    4d7a:	88 f0       	brcs	.+34     	; 0x4d9e <writeFile+0x21e>
		 writtenData += 512;
    4d7c:	00 e0       	ldi	r16, 0x00	; 0
    4d7e:	12 e0       	ldi	r17, 0x02	; 2
    4d80:	20 e0       	ldi	r18, 0x00	; 0
    4d82:	30 e0       	ldi	r19, 0x00	; 0
    4d84:	40 0e       	add	r4, r16
    4d86:	51 1e       	adc	r5, r17
    4d88:	62 1e       	adc	r6, r18
    4d8a:	73 1e       	adc	r7, r19
		 dataToWrite = 512;
		 lengthOfData -= 512;
    4d8c:	80 e0       	ldi	r24, 0x00	; 0
    4d8e:	9e ef       	ldi	r25, 0xFE	; 254
    4d90:	af ef       	ldi	r26, 0xFF	; 255
    4d92:	bf ef       	ldi	r27, 0xFF	; 255
    4d94:	88 0e       	add	r8, r24
    4d96:	99 1e       	adc	r9, r25
    4d98:	aa 1e       	adc	r10, r26
    4d9a:	bb 1e       	adc	r11, r27
    4d9c:	0c c0       	rjmp	.+24     	; 0x4db6 <writeFile+0x236>
	}
	else{
		writtenData += lengthOfData;
    4d9e:	48 0c       	add	r4, r8
    4da0:	59 1c       	adc	r5, r9
    4da2:	6a 1c       	adc	r6, r10
    4da4:	7b 1c       	adc	r7, r11
		dataToWrite = lengthOfData%512;
    4da6:	95 01       	movw	r18, r10
    4da8:	84 01       	movw	r16, r8
    4daa:	11 70       	andi	r17, 0x01	; 1
    4dac:	20 70       	andi	r18, 0x00	; 0
    4dae:	30 70       	andi	r19, 0x00	; 0
		lengthOfData = 0;
    4db0:	88 24       	eor	r8, r8
    4db2:	99 24       	eor	r9, r9
    4db4:	54 01       	movw	r10, r8
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    4db6:	80 91 56 40 	lds	r24, 0x4056
    4dba:	90 91 57 40 	lds	r25, 0x4057
    4dbe:	a0 91 58 40 	lds	r26, 0x4058
    4dc2:	b0 91 59 40 	lds	r27, 0x4059
    4dc6:	80 50       	subi	r24, 0x00	; 0
    4dc8:	9e 4f       	sbci	r25, 0xFE	; 254
    4dca:	af 4f       	sbci	r26, 0xFF	; 255
    4dcc:	bf 4f       	sbci	r27, 0xFF	; 255
    4dce:	80 93 56 40 	sts	0x4056, r24
    4dd2:	90 93 57 40 	sts	0x4057, r25
    4dd6:	a0 93 58 40 	sts	0x4058, r26
    4dda:	b0 93 59 40 	sts	0x4059, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    4dde:	b1 01       	movw	r22, r2
    4de0:	80 e0       	ldi	r24, 0x00	; 0
    4de2:	90 e0       	ldi	r25, 0x00	; 0
    4de4:	a2 01       	movw	r20, r4
    4de6:	40 1b       	sub	r20, r16
    4de8:	51 0b       	sbc	r21, r17
    4dea:	ad 81       	ldd	r26, Y+5	; 0x05
    4dec:	be 81       	ldd	r27, Y+6	; 0x06
    4dee:	4a 0f       	add	r20, r26
    4df0:	5b 1f       	adc	r21, r27
    4df2:	98 01       	movw	r18, r16
    4df4:	0e 94 c9 29 	call	0x5392	; 0x5392 <SD_write_block>
	j++;
    4df8:	c3 94       	inc	r12
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    4dfa:	20 91 6e 50 	lds	r18, 0x506E
    4dfe:	30 91 6f 50 	lds	r19, 0x506F
    4e02:	8c 2d       	mov	r24, r12
    4e04:	90 e0       	ldi	r25, 0x00	; 0
    4e06:	82 17       	cp	r24, r18
    4e08:	93 07       	cpc	r25, r19
    4e0a:	29 f5       	brne	.+74     	; 0x4e56 <writeFile+0x2d6>
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    4e0c:	69 81       	ldd	r22, Y+1	; 0x01
    4e0e:	7a 81       	ldd	r23, Y+2	; 0x02
    4e10:	8b 81       	ldd	r24, Y+3	; 0x03
    4e12:	9c 81       	ldd	r25, Y+4	; 0x04
    4e14:	0e 94 7d 22 	call	0x44fa	; 0x44fa <searchNextFreeCluster>
    4e18:	6b 01       	movw	r12, r22
    4e1a:	7c 01       	movw	r14, r24
		if(cluster == 0){
    4e1c:	61 15       	cp	r22, r1
    4e1e:	71 05       	cpc	r23, r1
    4e20:	81 05       	cpc	r24, r1
    4e22:	91 05       	cpc	r25, r1
    4e24:	09 f4       	brne	.+2      	; 0x4e28 <writeFile+0x2a8>
    4e26:	5d c1       	rjmp	.+698    	; 0x50e2 <writeFile+0x562>
		  //No free cluster!
		  return 2;
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    4e28:	69 81       	ldd	r22, Y+1	; 0x01
    4e2a:	7a 81       	ldd	r23, Y+2	; 0x02
    4e2c:	8b 81       	ldd	r24, Y+3	; 0x03
    4e2e:	9c 81       	ldd	r25, Y+4	; 0x04
    4e30:	41 e0       	ldi	r20, 0x01	; 1
    4e32:	97 01       	movw	r18, r14
    4e34:	86 01       	movw	r16, r12
    4e36:	0e 94 9f 1f 	call	0x3f3e	; 0x3f3e <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    4e3a:	c7 01       	movw	r24, r14
    4e3c:	b6 01       	movw	r22, r12
    4e3e:	41 e0       	ldi	r20, 0x01	; 1
    4e40:	0f ef       	ldi	r16, 0xFF	; 255
    4e42:	1f ef       	ldi	r17, 0xFF	; 255
    4e44:	98 01       	movw	r18, r16
    4e46:	0e 94 9f 1f 	call	0x3f3e	; 0x3f3e <getSetNextCluster>
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    4e4a:	c9 82       	std	Y+1, r12	; 0x01
    4e4c:	da 82       	std	Y+2, r13	; 0x02
    4e4e:	eb 82       	std	Y+3, r14	; 0x03
    4e50:	fc 82       	std	Y+4, r15	; 0x04
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
	j++;
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
		j = 0; 
    4e52:	cc 24       	eor	r12, r12
    4e54:	03 c0       	rjmp	.+6      	; 0x4e5c <writeFile+0x2dc>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    4e56:	08 94       	sec
    4e58:	21 1c       	adc	r2, r1
    4e5a:	31 1c       	adc	r3, r1
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    4e5c:	82 e0       	ldi	r24, 0x02	; 2
    4e5e:	61 e0       	ldi	r22, 0x01	; 1
    4e60:	29 81       	ldd	r18, Y+1	; 0x01
    4e62:	3a 81       	ldd	r19, Y+2	; 0x02
    4e64:	4b 81       	ldd	r20, Y+3	; 0x03
    4e66:	5c 81       	ldd	r21, Y+4	; 0x04
    4e68:	0e 94 31 20 	call	0x4062	; 0x4062 <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    4e6c:	81 14       	cp	r8, r1
    4e6e:	91 04       	cpc	r9, r1
    4e70:	a1 04       	cpc	r10, r1
    4e72:	b1 04       	cpc	r11, r1
    4e74:	09 f0       	breq	.+2      	; 0x4e78 <writeFile+0x2f8>
    4e76:	79 cf       	rjmp	.-270    	; 0x4d6a <writeFile+0x1ea>
    4e78:	1b 85       	ldd	r17, Y+11	; 0x0b
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    4e7a:	11 23       	and	r17, r17
    4e7c:	09 f4       	brne	.+2      	; 0x4e80 <writeFile+0x300>
    4e7e:	3f c0       	rjmp	.+126    	; 0x4efe <writeFile+0x37e>
{
  SD_read_block (appendFileSector,SDBuffer);    
    4e80:	60 91 a7 50 	lds	r22, 0x50A7
    4e84:	70 91 a8 50 	lds	r23, 0x50A8
    4e88:	80 91 a9 50 	lds	r24, 0x50A9
    4e8c:	90 91 aa 50 	lds	r25, 0x50AA
    4e90:	0d e4       	ldi	r16, 0x4D	; 77
    4e92:	1e e3       	ldi	r17, 0x3E	; 62
    4e94:	a8 01       	movw	r20, r16
    4e96:	0e 94 7e 2a 	call	0x54fc	; 0x54fc <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    4e9a:	e0 91 4e 40 	lds	r30, 0x404E
    4e9e:	f0 91 4f 40 	lds	r31, 0x404F
    4ea2:	e0 0f       	add	r30, r16
    4ea4:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    4ea6:	12 8a       	std	Z+18, r1	; 0x12
    4ea8:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    4eaa:	80 91 56 40 	lds	r24, 0x4056
    4eae:	90 91 57 40 	lds	r25, 0x4057
    4eb2:	a0 91 58 40 	lds	r26, 0x4058
    4eb6:	b0 91 59 40 	lds	r27, 0x4059
    4eba:	44 8d       	ldd	r20, Z+28	; 0x1c
    4ebc:	55 8d       	ldd	r21, Z+29	; 0x1d
    4ebe:	66 8d       	ldd	r22, Z+30	; 0x1e
    4ec0:	77 8d       	ldd	r23, Z+31	; 0x1f
    4ec2:	6c 01       	movw	r12, r24
    4ec4:	7d 01       	movw	r14, r26
    4ec6:	c4 1a       	sub	r12, r20
    4ec8:	d5 0a       	sbc	r13, r21
    4eca:	e6 0a       	sbc	r14, r22
    4ecc:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    4ece:	84 8f       	std	Z+28, r24	; 0x1c
    4ed0:	95 8f       	std	Z+29, r25	; 0x1d
    4ed2:	a6 8f       	std	Z+30, r26	; 0x1e
    4ed4:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    4ed6:	60 91 a7 50 	lds	r22, 0x50A7
    4eda:	70 91 a8 50 	lds	r23, 0x50A8
    4ede:	80 91 a9 50 	lds	r24, 0x50A9
    4ee2:	90 91 aa 50 	lds	r25, 0x50AA
    4ee6:	a8 01       	movw	r20, r16
    4ee8:	20 e0       	ldi	r18, 0x00	; 0
    4eea:	32 e0       	ldi	r19, 0x02	; 2
    4eec:	0e 94 c9 29 	call	0x5392	; 0x5392 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    4ef0:	81 e0       	ldi	r24, 0x01	; 1
    4ef2:	b7 01       	movw	r22, r14
    4ef4:	a6 01       	movw	r20, r12
    4ef6:	0e 94 30 23 	call	0x4660	; 0x4660 <freeMemoryUpdate>

 //File appended!
  return 0;
    4efa:	80 e0       	ldi	r24, 0x00	; 0
    4efc:	f9 c0       	rjmp	.+498    	; 0x50f0 <writeFile+0x570>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    4efe:	00 91 62 40 	lds	r16, 0x4062
    4f02:	10 91 63 40 	lds	r17, 0x4063
    4f06:	20 91 64 40 	lds	r18, 0x4064
    4f0a:	30 91 65 40 	lds	r19, 0x4065
    4f0e:	0b 87       	std	Y+11, r16	; 0x0b
    4f10:	1c 87       	std	Y+12, r17	; 0x0c
    4f12:	2d 87       	std	Y+13, r18	; 0x0d
    4f14:	3e 87       	std	Y+14, r19	; 0x0e
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4f16:	77 24       	eor	r7, r7
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4f18:	86 e9       	ldi	r24, 0x96	; 150
    4f1a:	90 e5       	ldi	r25, 0x50	; 80
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    4f1c:	0f 2e       	mov	r0, r31
    4f1e:	fb e0       	ldi	r31, 0x0B	; 11
    4f20:	af 2e       	mov	r10, r31
    4f22:	bb 24       	eor	r11, r11
    4f24:	f0 2d       	mov	r31, r0
    4f26:	a8 0e       	add	r10, r24
    4f28:	b9 1e       	adc	r11, r25

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    4f2a:	88 24       	eor	r8, r8
    4f2c:	68 94       	set
    4f2e:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4f30:	0f 2e       	mov	r0, r31
    4f32:	fd e4       	ldi	r31, 0x4D	; 77
    4f34:	4f 2e       	mov	r4, r31
    4f36:	fe e3       	ldi	r31, 0x3E	; 62
    4f38:	5f 2e       	mov	r5, r31
    4f3a:	f0 2d       	mov	r31, r0
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4f3c:	28 2e       	mov	r2, r24
    4f3e:	99 2e       	mov	r9, r25
    4f40:	37 2c       	mov	r3, r7
    4f42:	6f 84       	ldd	r6, Y+15	; 0x0f
    4f44:	78 88       	ldd	r7, Y+16	; 0x10
    4f46:	04 c0       	rjmp	.+8      	; 0x4f50 <writeFile+0x3d0>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    4f48:	cb 86       	std	Y+11, r12	; 0x0b
    4f4a:	dc 86       	std	Y+12, r13	; 0x0c
    4f4c:	ed 86       	std	Y+13, r14	; 0x0d
    4f4e:	fe 86       	std	Y+14, r15	; 0x0e

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    4f50:	6b 85       	ldd	r22, Y+11	; 0x0b
    4f52:	7c 85       	ldd	r23, Y+12	; 0x0c
    4f54:	8d 85       	ldd	r24, Y+13	; 0x0d
    4f56:	9e 85       	ldd	r25, Y+14	; 0x0e
    4f58:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <getFirstSector>
    4f5c:	6d 83       	std	Y+5, r22	; 0x05
    4f5e:	7e 83       	std	Y+6, r23	; 0x06
    4f60:	8f 83       	std	Y+7, r24	; 0x07
    4f62:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    4f64:	80 91 6e 50 	lds	r24, 0x506E
    4f68:	90 91 6f 50 	lds	r25, 0x506F
    4f6c:	00 97       	sbiw	r24, 0x00	; 0
    4f6e:	09 f4       	brne	.+2      	; 0x4f72 <writeFile+0x3f2>
    4f70:	77 c0       	rjmp	.+238    	; 0x5060 <writeFile+0x4e0>
    4f72:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4f74:	cd 80       	ldd	r12, Y+5	; 0x05
    4f76:	de 80       	ldd	r13, Y+6	; 0x06
    4f78:	ef 80       	ldd	r14, Y+7	; 0x07
    4f7a:	f8 84       	ldd	r15, Y+8	; 0x08
    4f7c:	19 81       	ldd	r17, Y+1	; 0x01
    4f7e:	c1 0e       	add	r12, r17
    4f80:	d1 1c       	adc	r13, r1
    4f82:	e1 1c       	adc	r14, r1
    4f84:	f1 1c       	adc	r15, r1
    4f86:	c7 01       	movw	r24, r14
    4f88:	b6 01       	movw	r22, r12
    4f8a:	a2 01       	movw	r20, r4
    4f8c:	0e 94 7e 2a 	call	0x54fc	; 0x54fc <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    4f90:	80 91 5a 40 	lds	r24, 0x405A
    4f94:	90 91 5b 40 	lds	r25, 0x405B
    4f98:	00 97       	sbiw	r24, 0x00	; 0
    4f9a:	09 f4       	brne	.+2      	; 0x4f9e <writeFile+0x41e>
    4f9c:	54 c0       	rjmp	.+168    	; 0x5046 <writeFile+0x4c6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    4f9e:	33 20       	and	r3, r3
    4fa0:	09 f0       	breq	.+2      	; 0x4fa4 <writeFile+0x424>
    4fa2:	a1 c0       	rjmp	.+322    	; 0x50e6 <writeFile+0x566>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4fa4:	a2 01       	movw	r20, r4
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    4fa6:	00 e0       	ldi	r16, 0x00	; 0
    4fa8:	10 e0       	ldi	r17, 0x00	; 0
    4faa:	06 c0       	rjmp	.+12     	; 0x4fb8 <writeFile+0x438>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4fac:	a8 01       	movw	r20, r16
    4fae:	43 5b       	subi	r20, 0xB3	; 179
    4fb0:	51 4c       	sbci	r21, 0xC1	; 193
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    4fb2:	22 23       	and	r18, r18
    4fb4:	09 f0       	breq	.+2      	; 0x4fb8 <writeFile+0x438>
    4fb6:	99 c0       	rjmp	.+306    	; 0x50ea <writeFile+0x56a>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4fb8:	da 01       	movw	r26, r20
    4fba:	8c 91       	ld	r24, X
    4fbc:	88 23       	and	r24, r24
    4fbe:	21 f4       	brne	.+8      	; 0x4fc8 <writeFile+0x448>
    4fc0:	e2 2d       	mov	r30, r2
    4fc2:	f9 2d       	mov	r31, r9
    4fc4:	da 01       	movw	r26, r20
    4fc6:	04 c0       	rjmp	.+8      	; 0x4fd0 <writeFile+0x450>
    4fc8:	85 3e       	cpi	r24, 0xE5	; 229
    4fca:	d1 f3       	breq	.-12     	; 0x4fc0 <writeFile+0x440>
    4fcc:	23 2d       	mov	r18, r3
    4fce:	30 c0       	rjmp	.+96     	; 0x5030 <writeFile+0x4b0>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = Filename[j];
    4fd0:	81 91       	ld	r24, Z+
    4fd2:	8d 93       	st	X+, r24
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    4fd4:	ea 15       	cp	r30, r10
    4fd6:	fb 05       	cpc	r31, r11
    4fd8:	d9 f7       	brne	.-10     	; 0x4fd0 <writeFile+0x450>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    4fda:	fa 01       	movw	r30, r20
    4fdc:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    4fde:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    4fe0:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    4fe2:	12 8a       	std	Z+18, r1	; 0x12
    4fe4:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    4fe6:	29 85       	ldd	r18, Y+9	; 0x09
    4fe8:	3a 85       	ldd	r19, Y+10	; 0x0a
    4fea:	24 8b       	std	Z+20, r18	; 0x14
    4fec:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    4fee:	62 8e       	std	Z+26, r6	; 0x1a
    4ff0:	73 8e       	std	Z+27, r7	; 0x1b
		  dir->fileSize = fileSize;
    4ff2:	80 91 56 40 	lds	r24, 0x4056
    4ff6:	90 91 57 40 	lds	r25, 0x4057
    4ffa:	a0 91 58 40 	lds	r26, 0x4058
    4ffe:	b0 91 59 40 	lds	r27, 0x4059
    5002:	84 8f       	std	Z+28, r24	; 0x1c
    5004:	95 8f       	std	Z+29, r25	; 0x1d
    5006:	a6 8f       	std	Z+30, r26	; 0x1e
    5008:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    500a:	c7 01       	movw	r24, r14
    500c:	b6 01       	movw	r22, r12
    500e:	a2 01       	movw	r20, r4
    5010:	20 e0       	ldi	r18, 0x00	; 0
    5012:	32 e0       	ldi	r19, 0x02	; 2
    5014:	0e 94 c9 29 	call	0x5392	; 0x5392 <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    5018:	40 91 56 40 	lds	r20, 0x4056
    501c:	50 91 57 40 	lds	r21, 0x4057
    5020:	60 91 58 40 	lds	r22, 0x4058
    5024:	70 91 59 40 	lds	r23, 0x4059
    5028:	81 e0       	ldi	r24, 0x01	; 1
    502a:	0e 94 30 23 	call	0x4660	; 0x4660 <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    502e:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    5030:	00 5e       	subi	r16, 0xE0	; 224
    5032:	1f 4f       	sbci	r17, 0xFF	; 255
    5034:	80 91 5a 40 	lds	r24, 0x405A
    5038:	90 91 5b 40 	lds	r25, 0x405B
    503c:	08 17       	cp	r16, r24
    503e:	19 07       	cpc	r17, r25
    5040:	08 f4       	brcc	.+2      	; 0x5044 <writeFile+0x4c4>
    5042:	b4 cf       	rjmp	.-152    	; 0x4fac <writeFile+0x42c>
    5044:	32 2e       	mov	r3, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    5046:	09 81       	ldd	r16, Y+1	; 0x01
    5048:	0f 5f       	subi	r16, 0xFF	; 255
    504a:	09 83       	std	Y+1, r16	; 0x01
    504c:	20 91 6e 50 	lds	r18, 0x506E
    5050:	30 91 6f 50 	lds	r19, 0x506F
    5054:	80 2f       	mov	r24, r16
    5056:	90 e0       	ldi	r25, 0x00	; 0
    5058:	82 17       	cp	r24, r18
    505a:	93 07       	cpc	r25, r19
    505c:	08 f4       	brcc	.+2      	; 0x5060 <writeFile+0x4e0>
    505e:	8a cf       	rjmp	.-236    	; 0x4f74 <writeFile+0x3f4>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    5060:	6b 85       	ldd	r22, Y+11	; 0x0b
    5062:	7c 85       	ldd	r23, Y+12	; 0x0c
    5064:	8d 85       	ldd	r24, Y+13	; 0x0d
    5066:	9e 85       	ldd	r25, Y+14	; 0x0e
    5068:	40 e0       	ldi	r20, 0x00	; 0
    506a:	00 e0       	ldi	r16, 0x00	; 0
    506c:	10 e0       	ldi	r17, 0x00	; 0
    506e:	98 01       	movw	r18, r16
    5070:	0e 94 9f 1f 	call	0x3f3e	; 0x3f3e <getSetNextCluster>
    5074:	6b 01       	movw	r12, r22
    5076:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    5078:	67 3f       	cpi	r22, 0xF7	; 247
    507a:	1f ef       	ldi	r17, 0xFF	; 255
    507c:	71 07       	cpc	r23, r17
    507e:	1f ef       	ldi	r17, 0xFF	; 255
    5080:	81 07       	cpc	r24, r17
    5082:	1f e0       	ldi	r17, 0x0F	; 15
    5084:	91 07       	cpc	r25, r17
    5086:	08 f1       	brcs	.+66     	; 0x50ca <writeFile+0x54a>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    5088:	6f 3f       	cpi	r22, 0xFF	; 255
    508a:	2f ef       	ldi	r18, 0xFF	; 255
    508c:	72 07       	cpc	r23, r18
    508e:	2f ef       	ldi	r18, 0xFF	; 255
    5090:	82 07       	cpc	r24, r18
    5092:	2f ef       	ldi	r18, 0xFF	; 255
    5094:	92 07       	cpc	r25, r18
    5096:	59 f5       	brne	.+86     	; 0x50ee <writeFile+0x56e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    5098:	6b 85       	ldd	r22, Y+11	; 0x0b
    509a:	7c 85       	ldd	r23, Y+12	; 0x0c
    509c:	8d 85       	ldd	r24, Y+13	; 0x0d
    509e:	9e 85       	ldd	r25, Y+14	; 0x0e
    50a0:	0e 94 7d 22 	call	0x44fa	; 0x44fa <searchNextFreeCluster>
    50a4:	6b 01       	movw	r12, r22
    50a6:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    50a8:	6b 85       	ldd	r22, Y+11	; 0x0b
    50aa:	7c 85       	ldd	r23, Y+12	; 0x0c
    50ac:	8d 85       	ldd	r24, Y+13	; 0x0d
    50ae:	9e 85       	ldd	r25, Y+14	; 0x0e
    50b0:	41 e0       	ldi	r20, 0x01	; 1
    50b2:	97 01       	movw	r18, r14
    50b4:	86 01       	movw	r16, r12
    50b6:	0e 94 9f 1f 	call	0x3f3e	; 0x3f3e <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    50ba:	c7 01       	movw	r24, r14
    50bc:	b6 01       	movw	r22, r12
    50be:	41 e0       	ldi	r20, 0x01	; 1
    50c0:	0f ef       	ldi	r16, 0xFF	; 255
    50c2:	1f ef       	ldi	r17, 0xFF	; 255
    50c4:	98 01       	movw	r18, r16
    50c6:	0e 94 9f 1f 	call	0x3f3e	; 0x3f3e <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    50ca:	c1 14       	cp	r12, r1
    50cc:	d1 04       	cpc	r13, r1
    50ce:	e1 04       	cpc	r14, r1
    50d0:	f1 04       	cpc	r15, r1
    50d2:	09 f0       	breq	.+2      	; 0x50d6 <writeFile+0x556>
    50d4:	39 cf       	rjmp	.-398    	; 0x4f48 <writeFile+0x3c8>
	   return 4;
    50d6:	84 e0       	ldi	r24, 0x04	; 4
    50d8:	0b c0       	rjmp	.+22     	; 0x50f0 <writeFile+0x570>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    50da:	81 e0       	ldi	r24, 0x01	; 1
    50dc:	09 c0       	rjmp	.+18     	; 0x50f0 <writeFile+0x570>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    50de:	82 e0       	ldi	r24, 0x02	; 2
    50e0:	07 c0       	rjmp	.+14     	; 0x50f0 <writeFile+0x570>
 
		prevCluster = cluster;
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
		if(cluster == 0){
		  //No free cluster!
		  return 2;
    50e2:	82 e0       	ldi	r24, 0x02	; 2
    50e4:	05 c0       	rjmp	.+10     	; 0x50f0 <writeFile+0x570>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    50e6:	80 e0       	ldi	r24, 0x00	; 0
    50e8:	03 c0       	rjmp	.+6      	; 0x50f0 <writeFile+0x570>
    50ea:	80 e0       	ldi	r24, 0x00	; 0
    50ec:	01 c0       	rjmp	.+2      	; 0x50f0 <writeFile+0x570>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    50ee:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    50f0:	60 96       	adiw	r28, 0x10	; 16
    50f2:	cd bf       	out	0x3d, r28	; 61
    50f4:	de bf       	out	0x3e, r29	; 62
    50f6:	df 91       	pop	r29
    50f8:	cf 91       	pop	r28
    50fa:	1f 91       	pop	r17
    50fc:	0f 91       	pop	r16
    50fe:	ff 90       	pop	r15
    5100:	ef 90       	pop	r14
    5102:	df 90       	pop	r13
    5104:	cf 90       	pop	r12
    5106:	bf 90       	pop	r11
    5108:	af 90       	pop	r10
    510a:	9f 90       	pop	r9
    510c:	8f 90       	pop	r8
    510e:	7f 90       	pop	r7
    5110:	6f 90       	pop	r6
    5112:	5f 90       	pop	r5
    5114:	4f 90       	pop	r4
    5116:	3f 90       	pop	r3
    5118:	2f 90       	pop	r2
    511a:	08 95       	ret

0000511c <SD_command>:
// 	data = SPIC.DATA; //read SPI data register to reset status flag
// 	return data;
// }

//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    511c:	8f 92       	push	r8
    511e:	9f 92       	push	r9
    5120:	af 92       	push	r10
    5122:	bf 92       	push	r11
    5124:	cf 92       	push	r12
    5126:	df 92       	push	r13
    5128:	ef 92       	push	r14
    512a:	ff 92       	push	r15
    512c:	0f 93       	push	r16
    512e:	1f 93       	push	r17
    5130:	cf 93       	push	r28
    5132:	df 93       	push	r29
    5134:	84 2e       	mov	r8, r20
    5136:	a5 2e       	mov	r10, r21
    5138:	c6 2e       	mov	r12, r22
    513a:	c7 2f       	mov	r28, r23
    513c:	d2 2f       	mov	r29, r18
    513e:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    5140:	80 64       	ori	r24, 0x40	; 64
    5142:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    5146:	8c 2f       	mov	r24, r28
    5148:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    514c:	8c 2d       	mov	r24, r12
    514e:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    5152:	8a 2d       	mov	r24, r10
    5154:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    5158:	88 2d       	mov	r24, r8
    515a:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
	SPI_write(crc);
    515e:	8d 2f       	mov	r24, r29
    5160:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
	
	for(int i=0; i<read; i++){
    5164:	10 16       	cp	r1, r16
    5166:	11 06       	cpc	r1, r17
    5168:	64 f5       	brge	.+88     	; 0x51c2 <SD_command+0xa6>
    516a:	00 e0       	ldi	r16, 0x00	; 0
    516c:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    516e:	0f 2e       	mov	r0, r31
    5170:	fd e0       	ldi	r31, 0x0D	; 13
    5172:	cf 2e       	mov	r12, r31
    5174:	dd 24       	eor	r13, r13
    5176:	f0 2d       	mov	r31, r0
    5178:	0f 2e       	mov	r0, r31
    517a:	f9 e3       	ldi	r31, 0x39	; 57
    517c:	af 2e       	mov	r10, r31
    517e:	fe e3       	ldi	r31, 0x3E	; 62
    5180:	bf 2e       	mov	r11, r31
    5182:	f0 2d       	mov	r31, r0
    5184:	c8 01       	movw	r24, r16
    5186:	b6 01       	movw	r22, r12
    5188:	0e 94 43 38 	call	0x7086	; 0x7086 <__divmodhi4>
    518c:	ec 01       	movw	r28, r24
    518e:	8f ef       	ldi	r24, 0xFF	; 255
    5190:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    5194:	f5 01       	movw	r30, r10
    5196:	ec 0f       	add	r30, r28
    5198:	fd 1f       	adc	r31, r29
    519a:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    519c:	80 81       	ld	r24, Z
    519e:	8f 3f       	cpi	r24, 0xFF	; 255
    51a0:	49 f0       	breq	.+18     	; 0x51b4 <SD_command+0x98>
			Buffer[1] = Buffer[i%13];
    51a2:	fe 01       	movw	r30, r28
    51a4:	e7 5c       	subi	r30, 0xC7	; 199
    51a6:	f1 4c       	sbci	r31, 0xC1	; 193
    51a8:	80 81       	ld	r24, Z
    51aa:	80 93 3a 3e 	sts	0x3E3A, r24
			return Buffer[1];
    51ae:	80 91 3a 3e 	lds	r24, 0x3E3A
    51b2:	08 c0       	rjmp	.+16     	; 0x51c4 <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    51b4:	0f 5f       	subi	r16, 0xFF	; 255
    51b6:	1f 4f       	sbci	r17, 0xFF	; 255
    51b8:	0e 15       	cp	r16, r14
    51ba:	1f 05       	cpc	r17, r15
    51bc:	19 f7       	brne	.-58     	; 0x5184 <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    51be:	8f ef       	ldi	r24, 0xFF	; 255
    51c0:	01 c0       	rjmp	.+2      	; 0x51c4 <SD_command+0xa8>
    51c2:	8f ef       	ldi	r24, 0xFF	; 255
}
    51c4:	df 91       	pop	r29
    51c6:	cf 91       	pop	r28
    51c8:	1f 91       	pop	r17
    51ca:	0f 91       	pop	r16
    51cc:	ff 90       	pop	r15
    51ce:	ef 90       	pop	r14
    51d0:	df 90       	pop	r13
    51d2:	cf 90       	pop	r12
    51d4:	bf 90       	pop	r11
    51d6:	af 90       	pop	r10
    51d8:	9f 90       	pop	r9
    51da:	8f 90       	pop	r8
    51dc:	08 95       	ret

000051de <SD_init>:
# include "SD_Card.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    51de:	ff 92       	push	r15
    51e0:	0f 93       	push	r16
    51e2:	1f 93       	push	r17
    51e4:	cf 93       	push	r28
    51e6:	df 93       	push	r29
	
	ADCPower(TRUE);				//power up portEX
    51e8:	81 e0       	ldi	r24, 0x01	; 1
    51ea:	0e 94 0c 07 	call	0xe18	; 0xe18 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    51ee:	81 e0       	ldi	r24, 0x01	; 1
    51f0:	0e 94 b3 04 	call	0x966	; 0x966 <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    51f4:	8f ef       	ldi	r24, 0xFF	; 255
    51f6:	93 ec       	ldi	r25, 0xC3	; 195
    51f8:	a9 e0       	ldi	r26, 0x09	; 9
    51fa:	81 50       	subi	r24, 0x01	; 1
    51fc:	90 40       	sbci	r25, 0x00	; 0
    51fe:	a0 40       	sbci	r26, 0x00	; 0
    5200:	e1 f7       	brne	.-8      	; 0x51fa <SD_init+0x1c>
    5202:	00 c0       	rjmp	.+0      	; 0x5204 <SD_init+0x26>
    5204:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
	
	PortEx_DIRSET(BIT3_bm, PS_BANKB); //SD card CS
    5206:	88 e0       	ldi	r24, 0x08	; 8
    5208:	60 e0       	ldi	r22, 0x00	; 0
    520a:	0e 94 b6 06 	call	0xd6c	; 0xd6c <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB); //pull SD cs high
    520e:	88 e0       	ldi	r24, 0x08	; 8
    5210:	60 e0       	ldi	r22, 0x00	; 0
    5212:	0e 94 09 06 	call	0xc12	; 0xc12 <PortEx_OUTSET>
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5216:	80 e0       	ldi	r24, 0x00	; 0
    5218:	63 e0       	ldi	r22, 0x03	; 3
    521a:	0e 94 27 05 	call	0xa4e	; 0xa4e <SPIInit2>
	SPICS(TRUE);
    521e:	81 e0       	ldi	r24, 0x01	; 1
    5220:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
    5224:	8a e0       	ldi	r24, 0x0A	; 10
    5226:	90 e0       	ldi	r25, 0x00	; 0
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    5228:	e0 ec       	ldi	r30, 0xC0	; 192
    522a:	f8 e0       	ldi	r31, 0x08	; 8
    522c:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
    522e:	a5 e4       	ldi	r26, 0x45	; 69
    5230:	be e3       	ldi	r27, 0x3E	; 62
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
		SPIC.DATA = SDHC_DUMMY_BYTE;
    5232:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    5234:	22 81       	ldd	r18, Z+2	; 0x02
    5236:	22 23       	and	r18, r18
    5238:	ec f7       	brge	.-6      	; 0x5234 <SD_init+0x56>
		Buffer[12] = SPIC.DATA;
    523a:	23 81       	ldd	r18, Z+3	; 0x03
    523c:	2c 93       	st	X, r18
    523e:	01 97       	sbiw	r24, 0x01	; 1
	
	SPIInit2(SPI_MODE_0_gc, SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	//idle for 10 bytes / 80 clocks
	for(int i=0; i<10; i++){
    5240:	c1 f7       	brne	.-16     	; 0x5232 <SD_init+0x54>
		SPIC.DATA = SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm));
		Buffer[12] = SPIC.DATA;
	}
	
	SPICS(FALSE);
    5242:	80 e0       	ldi	r24, 0x00	; 0
    5244:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	SPIDisable();
    5248:	0e 94 45 05 	call	0xa8a	; 0xa8a <SPIDisable>
	
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    524c:	88 e0       	ldi	r24, 0x08	; 8
    524e:	60 e0       	ldi	r22, 0x00	; 0
    5250:	0e 94 b2 05 	call	0xb64	; 0xb64 <PortEx_OUTCLR>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    5254:	80 e0       	ldi	r24, 0x00	; 0
    5256:	63 e0       	ldi	r22, 0x03	; 3
    5258:	0e 94 27 05 	call	0xa4e	; 0xa4e <SPIInit2>
	SPICS(TRUE);
    525c:	81 e0       	ldi	r24, 0x01	; 1
    525e:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    5262:	cb e0       	ldi	r28, 0x0B	; 11
    5264:	d0 e0       	ldi	r29, 0x00	; 0
    5266:	02 c0       	rjmp	.+4      	; 0x526c <SD_init+0x8e>
    5268:	21 97       	sbiw	r28, 0x01	; 1
		//try command 10 times before timing out
		if (i >= 10) {
    526a:	69 f0       	breq	.+26     	; 0x5286 <SD_init+0xa8>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
    526c:	80 e0       	ldi	r24, 0x00	; 0
    526e:	40 e0       	ldi	r20, 0x00	; 0
    5270:	50 e0       	ldi	r21, 0x00	; 0
    5272:	ba 01       	movw	r22, r20
    5274:	25 e9       	ldi	r18, 0x95	; 149
    5276:	08 e0       	ldi	r16, 0x08	; 8
    5278:	10 e0       	ldi	r17, 0x00	; 0
    527a:	0e 94 8e 28 	call	0x511c	; 0x511c <SD_command>
    527e:	81 30       	cpi	r24, 0x01	; 1
    5280:	99 f7       	brne	.-26     	; 0x5268 <SD_init+0x8a>
uint8_t SD_init(void){
	
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    5282:	ff 24       	eor	r15, r15
    5284:	02 c0       	rjmp	.+4      	; 0x528a <SD_init+0xac>
	//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
	for(int i=0; SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){
		//try command 10 times before timing out
		if (i >= 10) {
			//there was no response to the first command
			errorCode = 1;
    5286:	ff 24       	eor	r15, r15
    5288:	f3 94       	inc	r15
    528a:	8f ef       	ldi	r24, 0xFF	; 255
    528c:	93 ec       	ldi	r25, 0xC3	; 195
    528e:	a9 e0       	ldi	r26, 0x09	; 9
    5290:	81 50       	subi	r24, 0x01	; 1
    5292:	90 40       	sbci	r25, 0x00	; 0
    5294:	a0 40       	sbci	r26, 0x00	; 0
    5296:	e1 f7       	brne	.-8      	; 0x5290 <SD_init+0xb2>
    5298:	00 c0       	rjmp	.+0      	; 0x529a <SD_init+0xbc>
    529a:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    529c:	cb e0       	ldi	r28, 0x0B	; 11
    529e:	d0 e0       	ldi	r29, 0x00	; 0
    52a0:	02 c0       	rjmp	.+4      	; 0x52a6 <SD_init+0xc8>
    52a2:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    52a4:	69 f0       	breq	.+26     	; 0x52c0 <SD_init+0xe2>
			break;
		}
	}
	_delay_ms(100);
	//check voltage range (used to indicate to sd card that we know it is an sdhc card)
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){
    52a6:	88 e0       	ldi	r24, 0x08	; 8
    52a8:	4a ea       	ldi	r20, 0xAA	; 170
    52aa:	51 e0       	ldi	r21, 0x01	; 1
    52ac:	60 e0       	ldi	r22, 0x00	; 0
    52ae:	70 e0       	ldi	r23, 0x00	; 0
    52b0:	27 e8       	ldi	r18, 0x87	; 135
    52b2:	08 e0       	ldi	r16, 0x08	; 8
    52b4:	10 e0       	ldi	r17, 0x00	; 0
    52b6:	0e 94 8e 28 	call	0x511c	; 0x511c <SD_command>
    52ba:	81 30       	cpi	r24, 0x01	; 1
    52bc:	91 f7       	brne	.-28     	; 0x52a2 <SD_init+0xc4>
    52be:	02 c0       	rjmp	.+4      	; 0x52c4 <SD_init+0xe6>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    52c0:	ff 24       	eor	r15, r15
    52c2:	f3 94       	inc	r15
    52c4:	c2 e0       	ldi	r28, 0x02	; 2
    52c6:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}
	}
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    52c8:	09 e3       	ldi	r16, 0x39	; 57
    52ca:	1e e3       	ldi	r17, 0x3E	; 62
    52cc:	8f ef       	ldi	r24, 0xFF	; 255
    52ce:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    52d2:	f8 01       	movw	r30, r16
    52d4:	ec 0f       	add	r30, r28
    52d6:	fd 1f       	adc	r31, r29
    52d8:	80 83       	st	Z, r24
    52da:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}
	for(int i=0;i<4;i++){
    52dc:	c6 30       	cpi	r28, 0x06	; 6
    52de:	d1 05       	cpc	r29, r1
    52e0:	a9 f7       	brne	.-22     	; 0x52cc <SD_init+0xee>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	//check that the response is the same as the argument sent in
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){
    52e2:	80 91 3d 3e 	lds	r24, 0x3E3D
    52e6:	81 30       	cpi	r24, 0x01	; 1
    52e8:	29 f4       	brne	.+10     	; 0x52f4 <SD_init+0x116>
    52ea:	80 91 3e 3e 	lds	r24, 0x3E3E
    52ee:	8a 3a       	cpi	r24, 0xAA	; 170
    52f0:	21 f4       	brne	.+8      	; 0x52fa <SD_init+0x11c>
    52f2:	05 c0       	rjmp	.+10     	; 0x52fe <SD_init+0x120>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    52f4:	ff 24       	eor	r15, r15
    52f6:	f3 94       	inc	r15
    52f8:	02 c0       	rjmp	.+4      	; 0x52fe <SD_init+0x120>
    52fa:	ff 24       	eor	r15, r15
    52fc:	f3 94       	inc	r15
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
    52fe:	ca e3       	ldi	r28, 0x3A	; 58
    5300:	de e3       	ldi	r29, 0x3E	; 62
		errorCode = 1;
	}
	//send second initialization command
	do{
		//next command will be advanced
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);
    5302:	87 e3       	ldi	r24, 0x37	; 55
    5304:	40 e0       	ldi	r20, 0x00	; 0
    5306:	50 e0       	ldi	r21, 0x00	; 0
    5308:	ba 01       	movw	r22, r20
    530a:	2f ef       	ldi	r18, 0xFF	; 255
    530c:	08 e0       	ldi	r16, 0x08	; 8
    530e:	10 e0       	ldi	r17, 0x00	; 0
    5310:	0e 94 8e 28 	call	0x511c	; 0x511c <SD_command>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
    5314:	81 e0       	ldi	r24, 0x01	; 1
    5316:	40 e0       	ldi	r20, 0x00	; 0
    5318:	50 e0       	ldi	r21, 0x00	; 0
    531a:	60 e0       	ldi	r22, 0x00	; 0
    531c:	70 e4       	ldi	r23, 0x40	; 64
    531e:	2f ef       	ldi	r18, 0xFF	; 255
    5320:	0e 94 8e 28 	call	0x511c	; 0x511c <SD_command>
	} while(Buffer[1]!= 0x00);	
    5324:	88 81       	ld	r24, Y
    5326:	88 23       	and	r24, r24
    5328:	61 f7       	brne	.-40     	; 0x5302 <SD_init+0x124>
    532a:	cb e0       	ldi	r28, 0x0B	; 11
    532c:	d0 e0       	ldi	r29, 0x00	; 0
    532e:	02 c0       	rjmp	.+4      	; 0x5334 <SD_init+0x156>
    5330:	21 97       	sbiw	r28, 0x01	; 1
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
		if (i >= 10) {
    5332:	61 f0       	breq	.+24     	; 0x534c <SD_init+0x16e>
		//initialize the SDHC card in SPI mode
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);
	} while(Buffer[1]!= 0x00);	
	
	//check OCR register
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){
    5334:	8a e3       	ldi	r24, 0x3A	; 58
    5336:	40 e0       	ldi	r20, 0x00	; 0
    5338:	50 e0       	ldi	r21, 0x00	; 0
    533a:	ba 01       	movw	r22, r20
    533c:	2f ef       	ldi	r18, 0xFF	; 255
    533e:	08 e0       	ldi	r16, 0x08	; 8
    5340:	10 e0       	ldi	r17, 0x00	; 0
    5342:	0e 94 8e 28 	call	0x511c	; 0x511c <SD_command>
    5346:	88 23       	and	r24, r24
    5348:	99 f7       	brne	.-26     	; 0x5330 <SD_init+0x152>
    534a:	02 c0       	rjmp	.+4      	; 0x5350 <SD_init+0x172>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    534c:	ff 24       	eor	r15, r15
    534e:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5350:	c0 e0       	ldi	r28, 0x00	; 0
    5352:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    5354:	09 e3       	ldi	r16, 0x39	; 57
    5356:	1e e3       	ldi	r17, 0x3E	; 62
    5358:	8f ef       	ldi	r24, 0xFF	; 255
    535a:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    535e:	f8 01       	movw	r30, r16
    5360:	ec 0f       	add	r30, r28
    5362:	fd 1f       	adc	r31, r29
    5364:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5366:	21 96       	adiw	r28, 0x01	; 1
    5368:	c4 30       	cpi	r28, 0x04	; 4
    536a:	d1 05       	cpc	r29, r1
    536c:	a9 f7       	brne	.-22     	; 0x5358 <SD_init+0x17a>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    536e:	80 91 39 3e 	lds	r24, 0x3E39
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    5372:	80 e0       	ldi	r24, 0x00	; 0
    5374:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	SPIDisable();
    5378:	0e 94 45 05 	call	0xa8a	; 0xa8a <SPIDisable>
	//pull SD cs high
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    537c:	88 e0       	ldi	r24, 0x08	; 8
    537e:	60 e0       	ldi	r22, 0x00	; 0
    5380:	0e 94 09 06 	call	0xc12	; 0xc12 <PortEx_OUTSET>
	
	return errorCode;					
}
    5384:	8f 2d       	mov	r24, r15
    5386:	df 91       	pop	r29
    5388:	cf 91       	pop	r28
    538a:	1f 91       	pop	r17
    538c:	0f 91       	pop	r16
    538e:	ff 90       	pop	r15
    5390:	08 95       	ret

00005392 <SD_write_block>:
	}
	return SDHC_DUMMY_BYTE;
}

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    5392:	6f 92       	push	r6
    5394:	7f 92       	push	r7
    5396:	8f 92       	push	r8
    5398:	9f 92       	push	r9
    539a:	af 92       	push	r10
    539c:	bf 92       	push	r11
    539e:	cf 92       	push	r12
    53a0:	df 92       	push	r13
    53a2:	ef 92       	push	r14
    53a4:	ff 92       	push	r15
    53a6:	0f 93       	push	r16
    53a8:	1f 93       	push	r17
    53aa:	cf 93       	push	r28
    53ac:	df 93       	push	r29
    53ae:	4b 01       	movw	r8, r22
    53b0:	5c 01       	movw	r10, r24
    53b2:	74 2e       	mov	r7, r20
    53b4:	65 2e       	mov	r6, r21
    53b6:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    53b8:	88 e0       	ldi	r24, 0x08	; 8
    53ba:	60 e0       	ldi	r22, 0x00	; 0
    53bc:	0e 94 b2 05 	call	0xb64	; 0xb64 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    53c0:	80 e0       	ldi	r24, 0x00	; 0
    53c2:	0e 94 16 05 	call	0xa2c	; 0xa2c <SPIInit>
	SPICS(TRUE);
    53c6:	81 e0       	ldi	r24, 0x01	; 1
    53c8:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    53cc:	80 e0       	ldi	r24, 0x00	; 0
    53ce:	92 e0       	ldi	r25, 0x02	; 2
    53d0:	7c 01       	movw	r14, r24
    53d2:	ec 18       	sub	r14, r12
    53d4:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    53d6:	80 e0       	ldi	r24, 0x00	; 0
    53d8:	e8 16       	cp	r14, r24
    53da:	82 e0       	ldi	r24, 0x02	; 2
    53dc:	f8 06       	cpc	r15, r24
    53de:	11 f4       	brne	.+4      	; 0x53e4 <SD_write_block+0x52>
    53e0:	ee 24       	eor	r14, r14
    53e2:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    53e4:	cb e0       	ldi	r28, 0x0B	; 11
    53e6:	d0 e0       	ldi	r29, 0x00	; 0
    53e8:	03 c0       	rjmp	.+6      	; 0x53f0 <SD_write_block+0x5e>
    53ea:	21 97       	sbiw	r28, 0x01	; 1
	if (i >= 10) {
    53ec:	09 f4       	brne	.+2      	; 0x53f0 <SD_write_block+0x5e>
    53ee:	ff cf       	rjmp	.-2      	; 0x53ee <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    53f0:	88 e1       	ldi	r24, 0x18	; 24
    53f2:	b5 01       	movw	r22, r10
    53f4:	a4 01       	movw	r20, r8
    53f6:	2f ef       	ldi	r18, 0xFF	; 255
    53f8:	08 e0       	ldi	r16, 0x08	; 8
    53fa:	10 e0       	ldi	r17, 0x00	; 0
    53fc:	0e 94 8e 28 	call	0x511c	; 0x511c <SD_command>
    5400:	88 23       	and	r24, r24
    5402:	99 f7       	brne	.-26     	; 0x53ea <SD_write_block+0x58>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    5404:	8f ef       	ldi	r24, 0xFF	; 255
    5406:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    540a:	80 93 39 3e 	sts	0x3E39, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    540e:	8e ef       	ldi	r24, 0xFE	; 254
    5410:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    5414:	1c 14       	cp	r1, r12
    5416:	1d 04       	cpc	r1, r13
    5418:	bc f4       	brge	.+46     	; 0x5448 <SD_write_block+0xb6>
    541a:	87 2c       	mov	r8, r7
    541c:	96 2c       	mov	r9, r6
    541e:	00 e0       	ldi	r16, 0x00	; 0
    5420:	10 e0       	ldi	r17, 0x00	; 0
Buffer[i%13] = SPI_write(data[i]);
    5422:	c8 01       	movw	r24, r16
    5424:	6d e0       	ldi	r22, 0x0D	; 13
    5426:	70 e0       	ldi	r23, 0x00	; 0
    5428:	0e 94 43 38 	call	0x7086	; 0x7086 <__divmodhi4>
    542c:	ec 01       	movw	r28, r24
    542e:	f4 01       	movw	r30, r8
    5430:	81 91       	ld	r24, Z+
    5432:	4f 01       	movw	r8, r30
    5434:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    5438:	c7 5c       	subi	r28, 0xC7	; 199
    543a:	d1 4c       	sbci	r29, 0xC1	; 193
    543c:	88 83       	st	Y, r24
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    543e:	0f 5f       	subi	r16, 0xFF	; 255
    5440:	1f 4f       	sbci	r17, 0xFF	; 255
    5442:	0c 15       	cp	r16, r12
    5444:	1d 05       	cpc	r17, r13
    5446:	69 f7       	brne	.-38     	; 0x5422 <SD_write_block+0x90>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5448:	1e 14       	cp	r1, r14
    544a:	1f 04       	cpc	r1, r15
    544c:	ec f4       	brge	.+58     	; 0x5488 <SD_write_block+0xf6>
    544e:	00 e0       	ldi	r16, 0x00	; 0
    5450:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    5452:	0f 2e       	mov	r0, r31
    5454:	fd e0       	ldi	r31, 0x0D	; 13
    5456:	cf 2e       	mov	r12, r31
    5458:	dd 24       	eor	r13, r13
    545a:	f0 2d       	mov	r31, r0
    545c:	0f 2e       	mov	r0, r31
    545e:	f9 e3       	ldi	r31, 0x39	; 57
    5460:	8f 2e       	mov	r8, r31
    5462:	fe e3       	ldi	r31, 0x3E	; 62
    5464:	9f 2e       	mov	r9, r31
    5466:	f0 2d       	mov	r31, r0
    5468:	c8 01       	movw	r24, r16
    546a:	b6 01       	movw	r22, r12
    546c:	0e 94 43 38 	call	0x7086	; 0x7086 <__divmodhi4>
    5470:	ec 01       	movw	r28, r24
    5472:	80 e0       	ldi	r24, 0x00	; 0
    5474:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    5478:	c8 0d       	add	r28, r8
    547a:	d9 1d       	adc	r29, r9
    547c:	88 83       	st	Y, r24
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    547e:	0f 5f       	subi	r16, 0xFF	; 255
    5480:	1f 4f       	sbci	r17, 0xFF	; 255
    5482:	0e 15       	cp	r16, r14
    5484:	1f 05       	cpc	r17, r15
    5486:	81 f7       	brne	.-32     	; 0x5468 <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    5488:	8f ef       	ldi	r24, 0xFF	; 255
    548a:	80 93 39 3e 	sts	0x3E39, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    548e:	c0 e0       	ldi	r28, 0x00	; 0
    5490:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    5492:	09 e3       	ldi	r16, 0x39	; 57
    5494:	1e e3       	ldi	r17, 0x3E	; 62
    5496:	8f ef       	ldi	r24, 0xFF	; 255
    5498:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    549c:	f8 01       	movw	r30, r16
    549e:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    54a0:	21 96       	adiw	r28, 0x01	; 1
    54a2:	c2 30       	cpi	r28, 0x02	; 2
    54a4:	d1 05       	cpc	r29, r1
    54a6:	bc f3       	brlt	.-18     	; 0x5496 <SD_write_block+0x104>
    54a8:	80 81       	ld	r24, Z
    54aa:	8f 3f       	cpi	r24, 0xFF	; 255
    54ac:	a1 f3       	breq	.-24     	; 0x5496 <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    54ae:	80 91 39 3e 	lds	r24, 0x3E39
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    54b2:	80 91 39 3e 	lds	r24, 0x3E39
    54b6:	8f 3f       	cpi	r24, 0xFF	; 255
    54b8:	49 f0       	breq	.+18     	; 0x54cc <SD_write_block+0x13a>
    54ba:	c9 e3       	ldi	r28, 0x39	; 57
    54bc:	de e3       	ldi	r29, 0x3E	; 62
    54be:	8f ef       	ldi	r24, 0xFF	; 255
    54c0:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    54c4:	88 83       	st	Y, r24
    54c6:	88 81       	ld	r24, Y
    54c8:	8f 3f       	cpi	r24, 0xFF	; 255
    54ca:	c9 f7       	brne	.-14     	; 0x54be <SD_write_block+0x12c>
	SPICS(FALSE);
    54cc:	80 e0       	ldi	r24, 0x00	; 0
    54ce:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	SPIDisable();
    54d2:	0e 94 45 05 	call	0xa8a	; 0xa8a <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    54d6:	88 e0       	ldi	r24, 0x08	; 8
    54d8:	60 e0       	ldi	r22, 0x00	; 0
    54da:	0e 94 09 06 	call	0xc12	; 0xc12 <PortEx_OUTSET>
}
    54de:	df 91       	pop	r29
    54e0:	cf 91       	pop	r28
    54e2:	1f 91       	pop	r17
    54e4:	0f 91       	pop	r16
    54e6:	ff 90       	pop	r15
    54e8:	ef 90       	pop	r14
    54ea:	df 90       	pop	r13
    54ec:	cf 90       	pop	r12
    54ee:	bf 90       	pop	r11
    54f0:	af 90       	pop	r10
    54f2:	9f 90       	pop	r9
    54f4:	8f 90       	pop	r8
    54f6:	7f 90       	pop	r7
    54f8:	6f 90       	pop	r6
    54fa:	08 95       	ret

000054fc <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    54fc:	af 92       	push	r10
    54fe:	bf 92       	push	r11
    5500:	cf 92       	push	r12
    5502:	df 92       	push	r13
    5504:	ef 92       	push	r14
    5506:	ff 92       	push	r15
    5508:	0f 93       	push	r16
    550a:	1f 93       	push	r17
    550c:	cf 93       	push	r28
    550e:	df 93       	push	r29
    5510:	6b 01       	movw	r12, r22
    5512:	7c 01       	movw	r14, r24
    5514:	b4 2e       	mov	r11, r20
    5516:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5518:	88 e0       	ldi	r24, 0x08	; 8
    551a:	60 e0       	ldi	r22, 0x00	; 0
    551c:	0e 94 b2 05 	call	0xb64	; 0xb64 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    5520:	80 e0       	ldi	r24, 0x00	; 0
    5522:	0e 94 16 05 	call	0xa2c	; 0xa2c <SPIInit>
	SPICS(TRUE);
    5526:	81 e0       	ldi	r24, 0x01	; 1
    5528:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    552c:	cb e0       	ldi	r28, 0x0B	; 11
    552e:	d0 e0       	ldi	r29, 0x00	; 0
    5530:	03 c0       	rjmp	.+6      	; 0x5538 <SD_read_block+0x3c>
    5532:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    5534:	09 f4       	brne	.+2      	; 0x5538 <SD_read_block+0x3c>
    5536:	ff cf       	rjmp	.-2      	; 0x5536 <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5538:	81 e1       	ldi	r24, 0x11	; 17
    553a:	b7 01       	movw	r22, r14
    553c:	a6 01       	movw	r20, r12
    553e:	2f ef       	ldi	r18, 0xFF	; 255
    5540:	08 e0       	ldi	r16, 0x08	; 8
    5542:	10 e0       	ldi	r17, 0x00	; 0
    5544:	0e 94 8e 28 	call	0x511c	; 0x511c <SD_command>
    5548:	88 23       	and	r24, r24
    554a:	99 f7       	brne	.-26     	; 0x5532 <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    554c:	80 91 39 3e 	lds	r24, 0x3E39
    5550:	8e 3f       	cpi	r24, 0xFE	; 254
    5552:	49 f0       	breq	.+18     	; 0x5566 <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    5554:	c9 e3       	ldi	r28, 0x39	; 57
    5556:	de e3       	ldi	r29, 0x3E	; 62
    5558:	8f ef       	ldi	r24, 0xFF	; 255
    555a:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    555e:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    5560:	88 81       	ld	r24, Y
    5562:	8e 3f       	cpi	r24, 0xFE	; 254
    5564:	c9 f7       	brne	.-14     	; 0x5558 <SD_read_block+0x5c>
    5566:	0b 2d       	mov	r16, r11
    5568:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    556a:	c0 e0       	ldi	r28, 0x00	; 0
    556c:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    556e:	8f ef       	ldi	r24, 0xFF	; 255
    5570:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    5574:	f8 01       	movw	r30, r16
    5576:	81 93       	st	Z+, r24
    5578:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    557a:	21 96       	adiw	r28, 0x01	; 1
    557c:	f2 e0       	ldi	r31, 0x02	; 2
    557e:	c0 30       	cpi	r28, 0x00	; 0
    5580:	df 07       	cpc	r29, r31
    5582:	a9 f7       	brne	.-22     	; 0x556e <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    5584:	10 92 45 3e 	sts	0x3E45, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    5588:	80 91 45 3e 	lds	r24, 0x3E45
    558c:	8f 3f       	cpi	r24, 0xFF	; 255
    558e:	49 f0       	breq	.+18     	; 0x55a2 <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    5590:	c5 e4       	ldi	r28, 0x45	; 69
    5592:	de e3       	ldi	r29, 0x3E	; 62
    5594:	8f ef       	ldi	r24, 0xFF	; 255
    5596:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    559a:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    559c:	88 81       	ld	r24, Y
    559e:	8f 3f       	cpi	r24, 0xFF	; 255
    55a0:	c9 f7       	brne	.-14     	; 0x5594 <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    55a2:	80 e0       	ldi	r24, 0x00	; 0
    55a4:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	SPIDisable();
    55a8:	0e 94 45 05 	call	0xa8a	; 0xa8a <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    55ac:	88 e0       	ldi	r24, 0x08	; 8
    55ae:	60 e0       	ldi	r22, 0x00	; 0
    55b0:	0e 94 09 06 	call	0xc12	; 0xc12 <PortEx_OUTSET>
}
    55b4:	df 91       	pop	r29
    55b6:	cf 91       	pop	r28
    55b8:	1f 91       	pop	r17
    55ba:	0f 91       	pop	r16
    55bc:	ff 90       	pop	r15
    55be:	ef 90       	pop	r14
    55c0:	df 90       	pop	r13
    55c2:	cf 90       	pop	r12
    55c4:	bf 90       	pop	r11
    55c6:	af 90       	pop	r10
    55c8:	08 95       	ret

000055ca <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    55ca:	2f 92       	push	r2
    55cc:	3f 92       	push	r3
    55ce:	4f 92       	push	r4
    55d0:	5f 92       	push	r5
    55d2:	6f 92       	push	r6
    55d4:	7f 92       	push	r7
    55d6:	8f 92       	push	r8
    55d8:	9f 92       	push	r9
    55da:	af 92       	push	r10
    55dc:	bf 92       	push	r11
    55de:	cf 92       	push	r12
    55e0:	df 92       	push	r13
    55e2:	ef 92       	push	r14
    55e4:	ff 92       	push	r15
    55e6:	0f 93       	push	r16
    55e8:	1f 93       	push	r17
    55ea:	cf 93       	push	r28
    55ec:	df 93       	push	r29
    55ee:	cd b7       	in	r28, 0x3d	; 61
    55f0:	de b7       	in	r29, 0x3e	; 62
    55f2:	2a 97       	sbiw	r28, 0x0a	; 10
    55f4:	cd bf       	out	0x3d, r28	; 61
    55f6:	de bf       	out	0x3e, r29	; 62
    55f8:	6b 01       	movw	r12, r22
    55fa:	7c 01       	movw	r14, r24
    55fc:	4f 83       	std	Y+7, r20	; 0x07
    55fe:	58 87       	std	Y+8, r21	; 0x08
    5600:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5602:	88 e0       	ldi	r24, 0x08	; 8
    5604:	60 e0       	ldi	r22, 0x00	; 0
    5606:	0e 94 b2 05 	call	0xb64	; 0xb64 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    560a:	80 e0       	ldi	r24, 0x00	; 0
    560c:	0e 94 16 05 	call	0xa2c	; 0xa2c <SPIInit>
	SPICS(TRUE);
    5610:	81 e0       	ldi	r24, 0x01	; 1
    5612:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    5616:	c8 01       	movw	r24, r16
    5618:	11 23       	and	r17, r17
    561a:	14 f4       	brge	.+4      	; 0x5620 <SD_write_multiple_blocks+0x56>
    561c:	81 50       	subi	r24, 0x01	; 1
    561e:	9e 4f       	sbci	r25, 0xFE	; 254
    5620:	9c 01       	movw	r18, r24
    5622:	23 2f       	mov	r18, r19
    5624:	33 0f       	add	r19, r19
    5626:	33 0b       	sbc	r19, r19
    5628:	25 95       	asr	r18
    562a:	2b 83       	std	Y+3, r18	; 0x03
    562c:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    562e:	20 e0       	ldi	r18, 0x00	; 0
    5630:	32 e0       	ldi	r19, 0x02	; 2
    5632:	c8 01       	movw	r24, r16
    5634:	b9 01       	movw	r22, r18
    5636:	0e 94 43 38 	call	0x7086	; 0x7086 <__divmodhi4>
    563a:	29 01       	movw	r4, r18
    563c:	48 1a       	sub	r4, r24
    563e:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5640:	30 e0       	ldi	r19, 0x00	; 0
    5642:	43 16       	cp	r4, r19
    5644:	32 e0       	ldi	r19, 0x02	; 2
    5646:	53 06       	cpc	r5, r19
    5648:	31 f0       	breq	.+12     	; 0x5656 <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    564a:	8b 81       	ldd	r24, Y+3	; 0x03
    564c:	9c 81       	ldd	r25, Y+4	; 0x04
    564e:	01 96       	adiw	r24, 0x01	; 1
    5650:	8b 83       	std	Y+3, r24	; 0x03
    5652:	9c 83       	std	Y+4, r25	; 0x04
    5654:	02 c0       	rjmp	.+4      	; 0x565a <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5656:	44 24       	eor	r4, r4
    5658:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    565a:	89 e1       	ldi	r24, 0x19	; 25
    565c:	b7 01       	movw	r22, r14
    565e:	a6 01       	movw	r20, r12
    5660:	2f ef       	ldi	r18, 0xFF	; 255
    5662:	08 e0       	ldi	r16, 0x08	; 8
    5664:	10 e0       	ldi	r17, 0x00	; 0
    5666:	0e 94 8e 28 	call	0x511c	; 0x511c <SD_command>
    566a:	88 23       	and	r24, r24
    566c:	b1 f7       	brne	.-20     	; 0x565a <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    566e:	eb 81       	ldd	r30, Y+3	; 0x03
    5670:	fc 81       	ldd	r31, Y+4	; 0x04
    5672:	1e 16       	cp	r1, r30
    5674:	1f 06       	cpc	r1, r31
    5676:	0c f0       	brlt	.+2      	; 0x567a <SD_write_multiple_blocks+0xb0>
    5678:	ac c0       	rjmp	.+344    	; 0x57d2 <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    567a:	31 97       	sbiw	r30, 0x01	; 1
    567c:	ed 83       	std	Y+5, r30	; 0x05
    567e:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5680:	9f 01       	movw	r18, r30
    5682:	32 2f       	mov	r19, r18
    5684:	22 27       	eor	r18, r18
    5686:	33 0f       	add	r19, r19
    5688:	8f 81       	ldd	r24, Y+7	; 0x07
    568a:	98 85       	ldd	r25, Y+8	; 0x08
    568c:	89 83       	std	Y+1, r24	; 0x01
    568e:	9a 83       	std	Y+2, r25	; 0x02
    5690:	66 24       	eor	r6, r6
    5692:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    5694:	0f 2e       	mov	r0, r31
    5696:	fa e3       	ldi	r31, 0x3A	; 58
    5698:	8f 2e       	mov	r8, r31
    569a:	fe e3       	ldi	r31, 0x3E	; 62
    569c:	9f 2e       	mov	r9, r31
    569e:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    56a0:	0f 2e       	mov	r0, r31
    56a2:	fc e0       	ldi	r31, 0x0C	; 12
    56a4:	cf 2e       	mov	r12, r31
    56a6:	dd 24       	eor	r13, r13
    56a8:	f0 2d       	mov	r31, r0
    56aa:	0f 2e       	mov	r0, r31
    56ac:	f9 e3       	ldi	r31, 0x39	; 57
    56ae:	af 2e       	mov	r10, r31
    56b0:	fe e3       	ldi	r31, 0x3E	; 62
    56b2:	bf 2e       	mov	r11, r31
    56b4:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    56b6:	80 e0       	ldi	r24, 0x00	; 0
    56b8:	92 e0       	ldi	r25, 0x02	; 2
    56ba:	1c 01       	movw	r2, r24
    56bc:	24 18       	sub	r2, r4
    56be:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    56c0:	ef 81       	ldd	r30, Y+7	; 0x07
    56c2:	f8 85       	ldd	r31, Y+8	; 0x08
    56c4:	e2 0f       	add	r30, r18
    56c6:	f3 1f       	adc	r31, r19
    56c8:	ef 83       	std	Y+7, r30	; 0x07
    56ca:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    56cc:	8f ef       	ldi	r24, 0xFF	; 255
    56ce:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    56d2:	f4 01       	movw	r30, r8
    56d4:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    56d6:	8c ef       	ldi	r24, 0xFC	; 252
    56d8:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    56dc:	f4 01       	movw	r30, r8
    56de:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    56e0:	2d 81       	ldd	r18, Y+5	; 0x05
    56e2:	3e 81       	ldd	r19, Y+6	; 0x06
    56e4:	26 15       	cp	r18, r6
    56e6:	37 05       	cpc	r19, r7
    56e8:	09 f0       	breq	.+2      	; 0x56ec <SD_write_multiple_blocks+0x122>
    56ea:	41 c0       	rjmp	.+130    	; 0x576e <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    56ec:	12 14       	cp	r1, r2
    56ee:	13 04       	cpc	r1, r3
    56f0:	cc f4       	brge	.+50     	; 0x5724 <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    56f2:	ef 80       	ldd	r14, Y+7	; 0x07
    56f4:	f8 84       	ldd	r15, Y+8	; 0x08
    56f6:	00 e0       	ldi	r16, 0x00	; 0
    56f8:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    56fa:	c8 01       	movw	r24, r16
    56fc:	b6 01       	movw	r22, r12
    56fe:	0e 94 43 38 	call	0x7086	; 0x7086 <__divmodhi4>
    5702:	89 87       	std	Y+9, r24	; 0x09
    5704:	9a 87       	std	Y+10, r25	; 0x0a
    5706:	f7 01       	movw	r30, r14
    5708:	81 91       	ld	r24, Z+
    570a:	7f 01       	movw	r14, r30
    570c:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    5710:	e9 85       	ldd	r30, Y+9	; 0x09
    5712:	fa 85       	ldd	r31, Y+10	; 0x0a
    5714:	ea 0d       	add	r30, r10
    5716:	fb 1d       	adc	r31, r11
    5718:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    571a:	0f 5f       	subi	r16, 0xFF	; 255
    571c:	1f 4f       	sbci	r17, 0xFF	; 255
    571e:	02 15       	cp	r16, r2
    5720:	13 05       	cpc	r17, r3
    5722:	59 f7       	brne	.-42     	; 0x56fa <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5724:	14 14       	cp	r1, r4
    5726:	15 04       	cpc	r1, r5
    5728:	9c f4       	brge	.+38     	; 0x5750 <SD_write_multiple_blocks+0x186>
    572a:	00 e0       	ldi	r16, 0x00	; 0
    572c:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    572e:	c8 01       	movw	r24, r16
    5730:	b6 01       	movw	r22, r12
    5732:	0e 94 43 38 	call	0x7086	; 0x7086 <__divmodhi4>
    5736:	7c 01       	movw	r14, r24
    5738:	80 e0       	ldi	r24, 0x00	; 0
    573a:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    573e:	f5 01       	movw	r30, r10
    5740:	ee 0d       	add	r30, r14
    5742:	ff 1d       	adc	r31, r15
    5744:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5746:	0f 5f       	subi	r16, 0xFF	; 255
    5748:	1f 4f       	sbci	r17, 0xFF	; 255
    574a:	04 15       	cp	r16, r4
    574c:	15 05       	cpc	r17, r5
    574e:	79 f7       	brne	.-34     	; 0x572e <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    5750:	8f ef       	ldi	r24, 0xFF	; 255
    5752:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    5756:	f4 01       	movw	r30, r8
    5758:	80 83       	st	Z, r24
    575a:	8f ef       	ldi	r24, 0xFF	; 255
    575c:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    5760:	f4 01       	movw	r30, r8
    5762:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    5764:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5766:	80 81       	ld	r24, Z
    5768:	8f 3f       	cpi	r24, 0xFF	; 255
    576a:	e1 f4       	brne	.+56     	; 0x57a4 <SD_write_multiple_blocks+0x1da>
    576c:	23 c0       	rjmp	.+70     	; 0x57b4 <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    576e:	e9 80       	ldd	r14, Y+1	; 0x01
    5770:	fa 80       	ldd	r15, Y+2	; 0x02
    5772:	00 e0       	ldi	r16, 0x00	; 0
    5774:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5776:	c8 01       	movw	r24, r16
    5778:	b6 01       	movw	r22, r12
    577a:	0e 94 43 38 	call	0x7086	; 0x7086 <__divmodhi4>
    577e:	89 87       	std	Y+9, r24	; 0x09
    5780:	9a 87       	std	Y+10, r25	; 0x0a
    5782:	f7 01       	movw	r30, r14
    5784:	81 91       	ld	r24, Z+
    5786:	7f 01       	movw	r14, r30
    5788:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    578c:	e9 85       	ldd	r30, Y+9	; 0x09
    578e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5790:	ea 0d       	add	r30, r10
    5792:	fb 1d       	adc	r31, r11
    5794:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5796:	0f 5f       	subi	r16, 0xFF	; 255
    5798:	1f 4f       	sbci	r17, 0xFF	; 255
    579a:	f2 e0       	ldi	r31, 0x02	; 2
    579c:	00 30       	cpi	r16, 0x00	; 0
    579e:	1f 07       	cpc	r17, r31
    57a0:	51 f7       	brne	.-44     	; 0x5776 <SD_write_multiple_blocks+0x1ac>
    57a2:	d6 cf       	rjmp	.-84     	; 0x5750 <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    57a4:	8f ef       	ldi	r24, 0xFF	; 255
    57a6:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    57aa:	f4 01       	movw	r30, r8
    57ac:	80 83       	st	Z, r24
    57ae:	80 81       	ld	r24, Z
    57b0:	8f 3f       	cpi	r24, 0xFF	; 255
    57b2:	c1 f7       	brne	.-16     	; 0x57a4 <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    57b4:	08 94       	sec
    57b6:	61 1c       	adc	r6, r1
    57b8:	71 1c       	adc	r7, r1
    57ba:	29 81       	ldd	r18, Y+1	; 0x01
    57bc:	3a 81       	ldd	r19, Y+2	; 0x02
    57be:	20 50       	subi	r18, 0x00	; 0
    57c0:	3e 4f       	sbci	r19, 0xFE	; 254
    57c2:	29 83       	std	Y+1, r18	; 0x01
    57c4:	3a 83       	std	Y+2, r19	; 0x02
    57c6:	8b 81       	ldd	r24, Y+3	; 0x03
    57c8:	9c 81       	ldd	r25, Y+4	; 0x04
    57ca:	68 16       	cp	r6, r24
    57cc:	79 06       	cpc	r7, r25
    57ce:	09 f0       	breq	.+2      	; 0x57d2 <SD_write_multiple_blocks+0x208>
    57d0:	7d cf       	rjmp	.-262    	; 0x56cc <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    57d2:	ee 24       	eor	r14, r14
    57d4:	ff 24       	eor	r15, r15
    57d6:	68 94       	set
    57d8:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    57da:	0a e3       	ldi	r16, 0x3A	; 58
    57dc:	1e e3       	ldi	r17, 0x3E	; 62
    57de:	8f ef       	ldi	r24, 0xFF	; 255
    57e0:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    57e4:	f8 01       	movw	r30, r16
    57e6:	80 83       	st	Z, r24
    57e8:	08 94       	sec
    57ea:	e1 08       	sbc	r14, r1
    57ec:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    57ee:	e1 14       	cp	r14, r1
    57f0:	f1 04       	cpc	r15, r1
    57f2:	a9 f7       	brne	.-22     	; 0x57de <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    57f4:	8d ef       	ldi	r24, 0xFD	; 253
    57f6:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    57fa:	80 93 3a 3e 	sts	0x3E3A, r24
    57fe:	ee 24       	eor	r14, r14
    5800:	ff 24       	eor	r15, r15
    5802:	68 94       	set
    5804:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    5806:	0a e3       	ldi	r16, 0x3A	; 58
    5808:	1e e3       	ldi	r17, 0x3E	; 62
    580a:	8f ef       	ldi	r24, 0xFF	; 255
    580c:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    5810:	f8 01       	movw	r30, r16
    5812:	80 83       	st	Z, r24
    5814:	08 94       	sec
    5816:	e1 08       	sbc	r14, r1
    5818:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    581a:	e1 14       	cp	r14, r1
    581c:	f1 04       	cpc	r15, r1
    581e:	a9 f7       	brne	.-22     	; 0x580a <SD_write_multiple_blocks+0x240>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    5820:	10 92 3a 3e 	sts	0x3E3A, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5824:	80 91 3a 3e 	lds	r24, 0x3E3A
    5828:	8f 3f       	cpi	r24, 0xFF	; 255
    582a:	51 f0       	breq	.+20     	; 0x5840 <SD_write_multiple_blocks+0x276>
    582c:	0a e3       	ldi	r16, 0x3A	; 58
    582e:	1e e3       	ldi	r17, 0x3E	; 62
    5830:	8f ef       	ldi	r24, 0xFF	; 255
    5832:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    5836:	f8 01       	movw	r30, r16
    5838:	80 83       	st	Z, r24
    583a:	80 81       	ld	r24, Z
    583c:	8f 3f       	cpi	r24, 0xFF	; 255
    583e:	c1 f7       	brne	.-16     	; 0x5830 <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    5840:	80 e0       	ldi	r24, 0x00	; 0
    5842:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	SPIDisable();
    5846:	0e 94 45 05 	call	0xa8a	; 0xa8a <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    584a:	88 e0       	ldi	r24, 0x08	; 8
    584c:	60 e0       	ldi	r22, 0x00	; 0
    584e:	0e 94 09 06 	call	0xc12	; 0xc12 <PortEx_OUTSET>
}
    5852:	2a 96       	adiw	r28, 0x0a	; 10
    5854:	cd bf       	out	0x3d, r28	; 61
    5856:	de bf       	out	0x3e, r29	; 62
    5858:	df 91       	pop	r29
    585a:	cf 91       	pop	r28
    585c:	1f 91       	pop	r17
    585e:	0f 91       	pop	r16
    5860:	ff 90       	pop	r15
    5862:	ef 90       	pop	r14
    5864:	df 90       	pop	r13
    5866:	cf 90       	pop	r12
    5868:	bf 90       	pop	r11
    586a:	af 90       	pop	r10
    586c:	9f 90       	pop	r9
    586e:	8f 90       	pop	r8
    5870:	7f 90       	pop	r7
    5872:	6f 90       	pop	r6
    5874:	5f 90       	pop	r5
    5876:	4f 90       	pop	r4
    5878:	3f 90       	pop	r3
    587a:	2f 90       	pop	r2
    587c:	08 95       	ret

0000587e <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    587e:	2f 92       	push	r2
    5880:	3f 92       	push	r3
    5882:	4f 92       	push	r4
    5884:	5f 92       	push	r5
    5886:	6f 92       	push	r6
    5888:	7f 92       	push	r7
    588a:	8f 92       	push	r8
    588c:	9f 92       	push	r9
    588e:	af 92       	push	r10
    5890:	bf 92       	push	r11
    5892:	cf 92       	push	r12
    5894:	df 92       	push	r13
    5896:	ef 92       	push	r14
    5898:	ff 92       	push	r15
    589a:	0f 93       	push	r16
    589c:	1f 93       	push	r17
    589e:	cf 93       	push	r28
    58a0:	df 93       	push	r29
    58a2:	6b 01       	movw	r12, r22
    58a4:	7c 01       	movw	r14, r24
    58a6:	c4 2f       	mov	r28, r20
    58a8:	85 2e       	mov	r8, r21
    58aa:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    58ac:	88 e0       	ldi	r24, 0x08	; 8
    58ae:	60 e0       	ldi	r22, 0x00	; 0
    58b0:	0e 94 b2 05 	call	0xb64	; 0xb64 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    58b4:	80 e0       	ldi	r24, 0x00	; 0
    58b6:	0e 94 16 05 	call	0xa2c	; 0xa2c <SPIInit>
	SPICS(TRUE);
    58ba:	81 e0       	ldi	r24, 0x01	; 1
    58bc:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    58c0:	82 e1       	ldi	r24, 0x12	; 18
    58c2:	b7 01       	movw	r22, r14
    58c4:	a6 01       	movw	r20, r12
    58c6:	2f ef       	ldi	r18, 0xFF	; 255
    58c8:	08 e0       	ldi	r16, 0x08	; 8
    58ca:	10 e0       	ldi	r17, 0x00	; 0
    58cc:	0e 94 8e 28 	call	0x511c	; 0x511c <SD_command>
    58d0:	88 23       	and	r24, r24
    58d2:	b1 f7       	brne	.-20     	; 0x58c0 <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    58d4:	16 14       	cp	r1, r6
    58d6:	17 04       	cpc	r1, r7
    58d8:	0c f0       	brlt	.+2      	; 0x58dc <SD_read_multiple_blocks+0x5e>
    58da:	46 c0       	rjmp	.+140    	; 0x5968 <SD_read_multiple_blocks+0xea>
    58dc:	ac 2e       	mov	r10, r28
    58de:	b8 2c       	mov	r11, r8
    58e0:	88 24       	eor	r8, r8
    58e2:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    58e4:	0f 2e       	mov	r0, r31
    58e6:	fa e3       	ldi	r31, 0x3A	; 58
    58e8:	cf 2e       	mov	r12, r31
    58ea:	fe e3       	ldi	r31, 0x3E	; 62
    58ec:	df 2e       	mov	r13, r31
    58ee:	f0 2d       	mov	r31, r0
    58f0:	ff 24       	eor	r15, r15
    58f2:	fa 94       	dec	r15
    58f4:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    58f6:	0f 2e       	mov	r0, r31
    58f8:	f9 e3       	ldi	r31, 0x39	; 57
    58fa:	4f 2e       	mov	r4, r31
    58fc:	fe e3       	ldi	r31, 0x3E	; 62
    58fe:	5f 2e       	mov	r5, r31
    5900:	f0 2d       	mov	r31, r0
    5902:	12 01       	movw	r2, r4
    5904:	08 94       	sec
    5906:	21 1c       	adc	r2, r1
    5908:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    590a:	f6 01       	movw	r30, r12
    590c:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){
    590e:	80 81       	ld	r24, Z
    5910:	8e 3f       	cpi	r24, 0xFE	; 254
    5912:	41 f0       	breq	.+16     	; 0x5924 <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    5914:	8f 2d       	mov	r24, r15
    5916:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    591a:	f6 01       	movw	r30, r12
    591c:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    591e:	80 81       	ld	r24, Z
    5920:	8e 3f       	cpi	r24, 0xFE	; 254
    5922:	c1 f7       	brne	.-16     	; 0x5914 <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5924:	85 01       	movw	r16, r10
    5926:	c0 e0       	ldi	r28, 0x00	; 0
    5928:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    592a:	8f 2d       	mov	r24, r15
    592c:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    5930:	f8 01       	movw	r30, r16
    5932:	81 93       	st	Z+, r24
    5934:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5936:	21 96       	adiw	r28, 0x01	; 1
    5938:	f2 e0       	ldi	r31, 0x02	; 2
    593a:	c0 30       	cpi	r28, 0x00	; 0
    593c:	df 07       	cpc	r29, r31
    593e:	a9 f7       	brne	.-22     	; 0x592a <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    5940:	8f 2d       	mov	r24, r15
    5942:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    5946:	f2 01       	movw	r30, r4
    5948:	80 83       	st	Z, r24
    594a:	8f 2d       	mov	r24, r15
    594c:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    5950:	f1 01       	movw	r30, r2
    5952:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    5954:	08 94       	sec
    5956:	81 1c       	adc	r8, r1
    5958:	91 1c       	adc	r9, r1
    595a:	80 e0       	ldi	r24, 0x00	; 0
    595c:	92 e0       	ldi	r25, 0x02	; 2
    595e:	a8 0e       	add	r10, r24
    5960:	b9 1e       	adc	r11, r25
    5962:	86 14       	cp	r8, r6
    5964:	97 04       	cpc	r9, r7
    5966:	89 f6       	brne	.-94     	; 0x590a <SD_read_multiple_blocks+0x8c>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    5968:	8c e0       	ldi	r24, 0x0C	; 12
    596a:	40 e0       	ldi	r20, 0x00	; 0
    596c:	50 e0       	ldi	r21, 0x00	; 0
    596e:	ba 01       	movw	r22, r20
    5970:	2f ef       	ldi	r18, 0xFF	; 255
    5972:	08 e0       	ldi	r16, 0x08	; 8
    5974:	10 e0       	ldi	r17, 0x00	; 0
    5976:	0e 94 8e 28 	call	0x511c	; 0x511c <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    597a:	8f ef       	ldi	r24, 0xFF	; 255
    597c:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    5980:	80 93 39 3e 	sts	0x3E39, r24
	Buffer[1] = FILLER_BYTE;
    5984:	10 92 3a 3e 	sts	0x3E3A, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5988:	80 91 3a 3e 	lds	r24, 0x3E3A
    598c:	8f 3f       	cpi	r24, 0xFF	; 255
    598e:	49 f0       	breq	.+18     	; 0x59a2 <SD_read_multiple_blocks+0x124>
    5990:	ca e3       	ldi	r28, 0x3A	; 58
    5992:	de e3       	ldi	r29, 0x3E	; 62
    5994:	8f ef       	ldi	r24, 0xFF	; 255
    5996:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
    599a:	88 83       	st	Y, r24
    599c:	88 81       	ld	r24, Y
    599e:	8f 3f       	cpi	r24, 0xFF	; 255
    59a0:	c9 f7       	brne	.-14     	; 0x5994 <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    59a2:	80 e0       	ldi	r24, 0x00	; 0
    59a4:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	SPIDisable();
    59a8:	0e 94 45 05 	call	0xa8a	; 0xa8a <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    59ac:	88 e0       	ldi	r24, 0x08	; 8
    59ae:	60 e0       	ldi	r22, 0x00	; 0
    59b0:	0e 94 09 06 	call	0xc12	; 0xc12 <PortEx_OUTSET>
}
    59b4:	df 91       	pop	r29
    59b6:	cf 91       	pop	r28
    59b8:	1f 91       	pop	r17
    59ba:	0f 91       	pop	r16
    59bc:	ff 90       	pop	r15
    59be:	ef 90       	pop	r14
    59c0:	df 90       	pop	r13
    59c2:	cf 90       	pop	r12
    59c4:	bf 90       	pop	r11
    59c6:	af 90       	pop	r10
    59c8:	9f 90       	pop	r9
    59ca:	8f 90       	pop	r8
    59cc:	7f 90       	pop	r7
    59ce:	6f 90       	pop	r6
    59d0:	5f 90       	pop	r5
    59d2:	4f 90       	pop	r4
    59d4:	3f 90       	pop	r3
    59d6:	2f 90       	pop	r2
    59d8:	08 95       	ret

000059da <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    59da:	88 e0       	ldi	r24, 0x08	; 8
    59dc:	60 e0       	ldi	r22, 0x00	; 0
    59de:	0e 94 b6 06 	call	0xd6c	; 0xd6c <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    59e2:	88 e0       	ldi	r24, 0x08	; 8
    59e4:	60 e0       	ldi	r22, 0x00	; 0
    59e6:	0e 94 09 06 	call	0xc12	; 0xc12 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    59ea:	80 e0       	ldi	r24, 0x00	; 0
    59ec:	0e 94 16 05 	call	0xa2c	; 0xa2c <SPIInit>
	SPICS(TRUE);
    59f0:	81 e0       	ldi	r24, 0x01	; 1
    59f2:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    59f6:	8f ef       	ldi	r24, 0xFF	; 255
    59f8:	0e 94 23 08 	call	0x1046	; 0x1046 <SPI_write>
	SPICS(FALSE);	//stop spi
    59fc:	80 e0       	ldi	r24, 0x00	; 0
    59fe:	0e 94 39 05 	call	0xa72	; 0xa72 <SPICS>
	SPIDisable();
    5a02:	0e 94 45 05 	call	0xa8a	; 0xa8a <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    5a06:	80 e0       	ldi	r24, 0x00	; 0
    5a08:	0e 94 0c 07 	call	0xe18	; 0xe18 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    5a0c:	80 e0       	ldi	r24, 0x00	; 0
    5a0e:	0e 94 b3 04 	call	0x966	; 0x966 <Ext1Power>
}
    5a12:	08 95       	ret

00005a14 <__muldi3>:
    5a14:	a0 e3       	ldi	r26, 0x30	; 48
    5a16:	b0 e0       	ldi	r27, 0x00	; 0
    5a18:	e0 e1       	ldi	r30, 0x10	; 16
    5a1a:	fd e2       	ldi	r31, 0x2D	; 45
    5a1c:	0c 94 a9 38 	jmp	0x7152	; 0x7152 <__prologue_saves__+0x4>
    5a20:	29 8f       	std	Y+25, r18	; 0x19
    5a22:	3a 8f       	std	Y+26, r19	; 0x1a
    5a24:	4b 8f       	std	Y+27, r20	; 0x1b
    5a26:	5c 8f       	std	Y+28, r21	; 0x1c
    5a28:	6d 8f       	std	Y+29, r22	; 0x1d
    5a2a:	7e 8f       	std	Y+30, r23	; 0x1e
    5a2c:	8f 8f       	std	Y+31, r24	; 0x1f
    5a2e:	98 a3       	lds	r25, 0x58
    5a30:	a9 8a       	std	Y+17, r10	; 0x11
    5a32:	ba 8a       	std	Y+18, r11	; 0x12
    5a34:	cb 8a       	std	Y+19, r12	; 0x13
    5a36:	dc 8a       	std	Y+20, r13	; 0x14
    5a38:	ed 8a       	std	Y+21, r14	; 0x15
    5a3a:	fe 8a       	std	Y+22, r15	; 0x16
    5a3c:	0f 8b       	std	Y+23, r16	; 0x17
    5a3e:	18 8f       	std	Y+24, r17	; 0x18
    5a40:	09 8d       	ldd	r16, Y+25	; 0x19
    5a42:	1a 8d       	ldd	r17, Y+26	; 0x1a
    5a44:	2b 8d       	ldd	r18, Y+27	; 0x1b
    5a46:	3c 8d       	ldd	r19, Y+28	; 0x1c
    5a48:	09 a3       	lds	r16, 0x59
    5a4a:	1a a3       	lds	r17, 0x5a
    5a4c:	2b a3       	lds	r18, 0x5b
    5a4e:	3c a3       	lds	r19, 0x5c
    5a50:	68 01       	movw	r12, r16
    5a52:	79 01       	movw	r14, r18
    5a54:	8f ef       	ldi	r24, 0xFF	; 255
    5a56:	9f ef       	ldi	r25, 0xFF	; 255
    5a58:	a0 e0       	ldi	r26, 0x00	; 0
    5a5a:	b0 e0       	ldi	r27, 0x00	; 0
    5a5c:	c8 22       	and	r12, r24
    5a5e:	d9 22       	and	r13, r25
    5a60:	ea 22       	and	r14, r26
    5a62:	fb 22       	and	r15, r27
    5a64:	89 01       	movw	r16, r18
    5a66:	22 27       	eor	r18, r18
    5a68:	33 27       	eor	r19, r19
    5a6a:	09 a7       	lds	r16, 0x79
    5a6c:	1a a7       	lds	r17, 0x7a
    5a6e:	2b a7       	lds	r18, 0x7b
    5a70:	3c a7       	lds	r19, 0x7c
    5a72:	09 89       	ldd	r16, Y+17	; 0x11
    5a74:	1a 89       	ldd	r17, Y+18	; 0x12
    5a76:	2b 89       	ldd	r18, Y+19	; 0x13
    5a78:	3c 89       	ldd	r19, Y+20	; 0x14
    5a7a:	0d a3       	lds	r16, 0x5d
    5a7c:	1e a3       	lds	r17, 0x5e
    5a7e:	2f a3       	lds	r18, 0x5f
    5a80:	38 a7       	lds	r19, 0x78
    5a82:	48 01       	movw	r8, r16
    5a84:	59 01       	movw	r10, r18
    5a86:	88 22       	and	r8, r24
    5a88:	99 22       	and	r9, r25
    5a8a:	aa 22       	and	r10, r26
    5a8c:	bb 22       	and	r11, r27
    5a8e:	29 01       	movw	r4, r18
    5a90:	66 24       	eor	r6, r6
    5a92:	77 24       	eor	r7, r7
    5a94:	c5 01       	movw	r24, r10
    5a96:	b4 01       	movw	r22, r8
    5a98:	a7 01       	movw	r20, r14
    5a9a:	96 01       	movw	r18, r12
    5a9c:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    5aa0:	6d a7       	lds	r22, 0x7d
    5aa2:	7e a7       	lds	r23, 0x7e
    5aa4:	8f a7       	lds	r24, 0x7f
    5aa6:	98 ab       	sts	0x58, r25
    5aa8:	c3 01       	movw	r24, r6
    5aaa:	b2 01       	movw	r22, r4
    5aac:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    5ab0:	6b 01       	movw	r12, r22
    5ab2:	7c 01       	movw	r14, r24
    5ab4:	c5 01       	movw	r24, r10
    5ab6:	b4 01       	movw	r22, r8
    5ab8:	29 a5       	lds	r18, 0x69
    5aba:	3a a5       	lds	r19, 0x6a
    5abc:	4b a5       	lds	r20, 0x6b
    5abe:	5c a5       	lds	r21, 0x6c
    5ac0:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    5ac4:	4b 01       	movw	r8, r22
    5ac6:	5c 01       	movw	r10, r24
    5ac8:	c3 01       	movw	r24, r6
    5aca:	b2 01       	movw	r22, r4
    5acc:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    5ad0:	ab 01       	movw	r20, r22
    5ad2:	bc 01       	movw	r22, r24
    5ad4:	c8 0c       	add	r12, r8
    5ad6:	d9 1c       	adc	r13, r9
    5ad8:	ea 1c       	adc	r14, r10
    5ada:	fb 1c       	adc	r15, r11
    5adc:	0d a5       	lds	r16, 0x6d
    5ade:	1e a5       	lds	r17, 0x6e
    5ae0:	2f a5       	lds	r18, 0x6f
    5ae2:	38 a9       	sts	0x48, r19
    5ae4:	c9 01       	movw	r24, r18
    5ae6:	aa 27       	eor	r26, r26
    5ae8:	bb 27       	eor	r27, r27
    5aea:	c8 0e       	add	r12, r24
    5aec:	d9 1e       	adc	r13, r25
    5aee:	ea 1e       	adc	r14, r26
    5af0:	fb 1e       	adc	r15, r27
    5af2:	c8 14       	cp	r12, r8
    5af4:	d9 04       	cpc	r13, r9
    5af6:	ea 04       	cpc	r14, r10
    5af8:	fb 04       	cpc	r15, r11
    5afa:	20 f4       	brcc	.+8      	; 0x5b04 <__muldi3+0xf0>
    5afc:	40 50       	subi	r20, 0x00	; 0
    5afe:	50 40       	sbci	r21, 0x00	; 0
    5b00:	6f 4f       	sbci	r22, 0xFF	; 255
    5b02:	7f 4f       	sbci	r23, 0xFF	; 255
    5b04:	c7 01       	movw	r24, r14
    5b06:	aa 27       	eor	r26, r26
    5b08:	bb 27       	eor	r27, r27
    5b0a:	84 0f       	add	r24, r20
    5b0c:	95 1f       	adc	r25, r21
    5b0e:	a6 1f       	adc	r26, r22
    5b10:	b7 1f       	adc	r27, r23
    5b12:	8d 83       	std	Y+5, r24	; 0x05
    5b14:	9e 83       	std	Y+6, r25	; 0x06
    5b16:	af 83       	std	Y+7, r26	; 0x07
    5b18:	b8 87       	std	Y+8, r27	; 0x08
    5b1a:	76 01       	movw	r14, r12
    5b1c:	dd 24       	eor	r13, r13
    5b1e:	cc 24       	eor	r12, r12
    5b20:	4d a5       	lds	r20, 0x6d
    5b22:	5e a5       	lds	r21, 0x6e
    5b24:	6f a5       	lds	r22, 0x6f
    5b26:	78 a9       	sts	0x48, r23
    5b28:	60 70       	andi	r22, 0x00	; 0
    5b2a:	70 70       	andi	r23, 0x00	; 0
    5b2c:	c4 0e       	add	r12, r20
    5b2e:	d5 1e       	adc	r13, r21
    5b30:	e6 1e       	adc	r14, r22
    5b32:	f7 1e       	adc	r15, r23
    5b34:	c9 82       	std	Y+1, r12	; 0x01
    5b36:	da 82       	std	Y+2, r13	; 0x02
    5b38:	eb 82       	std	Y+3, r14	; 0x03
    5b3a:	fc 82       	std	Y+4, r15	; 0x04
    5b3c:	1c 2d       	mov	r17, r12
    5b3e:	0a 81       	ldd	r16, Y+2	; 0x02
    5b40:	8b 80       	ldd	r8, Y+3	; 0x03
    5b42:	4c 80       	ldd	r4, Y+4	; 0x04
    5b44:	8d 87       	std	Y+13, r24	; 0x0d
    5b46:	8e 81       	ldd	r24, Y+6	; 0x06
    5b48:	8e 87       	std	Y+14, r24	; 0x0e
    5b4a:	8f 81       	ldd	r24, Y+7	; 0x07
    5b4c:	8f 87       	std	Y+15, r24	; 0x0f
    5b4e:	88 85       	ldd	r24, Y+8	; 0x08
    5b50:	88 8b       	std	Y+16, r24	; 0x10
    5b52:	2d 89       	ldd	r18, Y+21	; 0x15
    5b54:	3e 89       	ldd	r19, Y+22	; 0x16
    5b56:	4f 89       	ldd	r20, Y+23	; 0x17
    5b58:	58 8d       	ldd	r21, Y+24	; 0x18
    5b5a:	69 a1       	lds	r22, 0x49
    5b5c:	7a a1       	lds	r23, 0x4a
    5b5e:	8b a1       	lds	r24, 0x4b
    5b60:	9c a1       	lds	r25, 0x4c
    5b62:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    5b66:	6b 01       	movw	r12, r22
    5b68:	7c 01       	movw	r14, r24
    5b6a:	2d 8d       	ldd	r18, Y+29	; 0x1d
    5b6c:	3e 8d       	ldd	r19, Y+30	; 0x1e
    5b6e:	4f 8d       	ldd	r20, Y+31	; 0x1f
    5b70:	58 a1       	lds	r21, 0x48
    5b72:	6d a1       	lds	r22, 0x4d
    5b74:	7e a1       	lds	r23, 0x4e
    5b76:	8f a1       	lds	r24, 0x4f
    5b78:	98 a5       	lds	r25, 0x68
    5b7a:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    5b7e:	dc 01       	movw	r26, r24
    5b80:	cb 01       	movw	r24, r22
    5b82:	c8 0e       	add	r12, r24
    5b84:	d9 1e       	adc	r13, r25
    5b86:	ea 1e       	adc	r14, r26
    5b88:	fb 1e       	adc	r15, r27
    5b8a:	8d 85       	ldd	r24, Y+13	; 0x0d
    5b8c:	9e 85       	ldd	r25, Y+14	; 0x0e
    5b8e:	af 85       	ldd	r26, Y+15	; 0x0f
    5b90:	b8 89       	ldd	r27, Y+16	; 0x10
    5b92:	8c 0d       	add	r24, r12
    5b94:	9d 1d       	adc	r25, r13
    5b96:	ae 1d       	adc	r26, r14
    5b98:	bf 1d       	adc	r27, r15
    5b9a:	8d 87       	std	Y+13, r24	; 0x0d
    5b9c:	9e 87       	std	Y+14, r25	; 0x0e
    5b9e:	af 87       	std	Y+15, r26	; 0x0f
    5ba0:	b8 8b       	std	Y+16, r27	; 0x10
    5ba2:	68 2f       	mov	r22, r24
    5ba4:	7e 85       	ldd	r23, Y+14	; 0x0e
    5ba6:	21 2f       	mov	r18, r17
    5ba8:	30 2f       	mov	r19, r16
    5baa:	48 2d       	mov	r20, r8
    5bac:	54 2d       	mov	r21, r4
    5bae:	8f 85       	ldd	r24, Y+15	; 0x0f
    5bb0:	98 89       	ldd	r25, Y+16	; 0x10
    5bb2:	e0 96       	adiw	r28, 0x30	; 48
    5bb4:	e0 e1       	ldi	r30, 0x10	; 16
    5bb6:	0c 94 c2 38 	jmp	0x7184	; 0x7184 <__epilogue_restores__+0x4>

00005bba <__ashldi3>:
    5bba:	cf 92       	push	r12
    5bbc:	df 92       	push	r13
    5bbe:	ef 92       	push	r14
    5bc0:	ff 92       	push	r15
    5bc2:	0f 93       	push	r16
    5bc4:	cf 93       	push	r28
    5bc6:	df 93       	push	r29
    5bc8:	cd b7       	in	r28, 0x3d	; 61
    5bca:	de b7       	in	r29, 0x3e	; 62
    5bcc:	60 97       	sbiw	r28, 0x10	; 16
    5bce:	cd bf       	out	0x3d, r28	; 61
    5bd0:	de bf       	out	0x3e, r29	; 62
    5bd2:	00 23       	and	r16, r16
    5bd4:	09 f4       	brne	.+2      	; 0x5bd8 <__ashldi3+0x1e>
    5bd6:	5a c0       	rjmp	.+180    	; 0x5c8c <__ashldi3+0xd2>
    5bd8:	29 87       	std	Y+9, r18	; 0x09
    5bda:	3a 87       	std	Y+10, r19	; 0x0a
    5bdc:	4b 87       	std	Y+11, r20	; 0x0b
    5bde:	5c 87       	std	Y+12, r21	; 0x0c
    5be0:	6d 87       	std	Y+13, r22	; 0x0d
    5be2:	7e 87       	std	Y+14, r23	; 0x0e
    5be4:	8f 87       	std	Y+15, r24	; 0x0f
    5be6:	98 8b       	std	Y+16, r25	; 0x10
    5be8:	80 e2       	ldi	r24, 0x20	; 32
    5bea:	80 1b       	sub	r24, r16
    5bec:	49 85       	ldd	r20, Y+9	; 0x09
    5bee:	5a 85       	ldd	r21, Y+10	; 0x0a
    5bf0:	6b 85       	ldd	r22, Y+11	; 0x0b
    5bf2:	7c 85       	ldd	r23, Y+12	; 0x0c
    5bf4:	18 16       	cp	r1, r24
    5bf6:	b4 f0       	brlt	.+44     	; 0x5c24 <__ashldi3+0x6a>
    5bf8:	19 82       	std	Y+1, r1	; 0x01
    5bfa:	1a 82       	std	Y+2, r1	; 0x02
    5bfc:	1b 82       	std	Y+3, r1	; 0x03
    5bfe:	1c 82       	std	Y+4, r1	; 0x04
    5c00:	99 27       	eor	r25, r25
    5c02:	87 fd       	sbrc	r24, 7
    5c04:	90 95       	com	r25
    5c06:	90 95       	com	r25
    5c08:	81 95       	neg	r24
    5c0a:	9f 4f       	sbci	r25, 0xFF	; 255
    5c0c:	04 c0       	rjmp	.+8      	; 0x5c16 <__ashldi3+0x5c>
    5c0e:	44 0f       	add	r20, r20
    5c10:	55 1f       	adc	r21, r21
    5c12:	66 1f       	adc	r22, r22
    5c14:	77 1f       	adc	r23, r23
    5c16:	8a 95       	dec	r24
    5c18:	d2 f7       	brpl	.-12     	; 0x5c0e <__ashldi3+0x54>
    5c1a:	4d 83       	std	Y+5, r20	; 0x05
    5c1c:	5e 83       	std	Y+6, r21	; 0x06
    5c1e:	6f 83       	std	Y+7, r22	; 0x07
    5c20:	78 87       	std	Y+8, r23	; 0x08
    5c22:	2c c0       	rjmp	.+88     	; 0x5c7c <__ashldi3+0xc2>
    5c24:	6a 01       	movw	r12, r20
    5c26:	7b 01       	movw	r14, r22
    5c28:	00 2e       	mov	r0, r16
    5c2a:	04 c0       	rjmp	.+8      	; 0x5c34 <__ashldi3+0x7a>
    5c2c:	cc 0c       	add	r12, r12
    5c2e:	dd 1c       	adc	r13, r13
    5c30:	ee 1c       	adc	r14, r14
    5c32:	ff 1c       	adc	r15, r15
    5c34:	0a 94       	dec	r0
    5c36:	d2 f7       	brpl	.-12     	; 0x5c2c <__ashldi3+0x72>
    5c38:	c9 82       	std	Y+1, r12	; 0x01
    5c3a:	da 82       	std	Y+2, r13	; 0x02
    5c3c:	eb 82       	std	Y+3, r14	; 0x03
    5c3e:	fc 82       	std	Y+4, r15	; 0x04
    5c40:	6a 01       	movw	r12, r20
    5c42:	7b 01       	movw	r14, r22
    5c44:	04 c0       	rjmp	.+8      	; 0x5c4e <__ashldi3+0x94>
    5c46:	f6 94       	lsr	r15
    5c48:	e7 94       	ror	r14
    5c4a:	d7 94       	ror	r13
    5c4c:	c7 94       	ror	r12
    5c4e:	8a 95       	dec	r24
    5c50:	d2 f7       	brpl	.-12     	; 0x5c46 <__ashldi3+0x8c>
    5c52:	d7 01       	movw	r26, r14
    5c54:	c6 01       	movw	r24, r12
    5c56:	4d 85       	ldd	r20, Y+13	; 0x0d
    5c58:	5e 85       	ldd	r21, Y+14	; 0x0e
    5c5a:	6f 85       	ldd	r22, Y+15	; 0x0f
    5c5c:	78 89       	ldd	r23, Y+16	; 0x10
    5c5e:	04 c0       	rjmp	.+8      	; 0x5c68 <__ashldi3+0xae>
    5c60:	44 0f       	add	r20, r20
    5c62:	55 1f       	adc	r21, r21
    5c64:	66 1f       	adc	r22, r22
    5c66:	77 1f       	adc	r23, r23
    5c68:	0a 95       	dec	r16
    5c6a:	d2 f7       	brpl	.-12     	; 0x5c60 <__ashldi3+0xa6>
    5c6c:	84 2b       	or	r24, r20
    5c6e:	95 2b       	or	r25, r21
    5c70:	a6 2b       	or	r26, r22
    5c72:	b7 2b       	or	r27, r23
    5c74:	8d 83       	std	Y+5, r24	; 0x05
    5c76:	9e 83       	std	Y+6, r25	; 0x06
    5c78:	af 83       	std	Y+7, r26	; 0x07
    5c7a:	b8 87       	std	Y+8, r27	; 0x08
    5c7c:	29 81       	ldd	r18, Y+1	; 0x01
    5c7e:	3a 81       	ldd	r19, Y+2	; 0x02
    5c80:	4b 81       	ldd	r20, Y+3	; 0x03
    5c82:	5c 81       	ldd	r21, Y+4	; 0x04
    5c84:	6d 81       	ldd	r22, Y+5	; 0x05
    5c86:	7e 81       	ldd	r23, Y+6	; 0x06
    5c88:	8f 81       	ldd	r24, Y+7	; 0x07
    5c8a:	98 85       	ldd	r25, Y+8	; 0x08
    5c8c:	60 96       	adiw	r28, 0x10	; 16
    5c8e:	cd bf       	out	0x3d, r28	; 61
    5c90:	de bf       	out	0x3e, r29	; 62
    5c92:	df 91       	pop	r29
    5c94:	cf 91       	pop	r28
    5c96:	0f 91       	pop	r16
    5c98:	ff 90       	pop	r15
    5c9a:	ef 90       	pop	r14
    5c9c:	df 90       	pop	r13
    5c9e:	cf 90       	pop	r12
    5ca0:	08 95       	ret

00005ca2 <__ashrdi3>:
    5ca2:	0f 93       	push	r16
    5ca4:	cf 93       	push	r28
    5ca6:	df 93       	push	r29
    5ca8:	cd b7       	in	r28, 0x3d	; 61
    5caa:	de b7       	in	r29, 0x3e	; 62
    5cac:	60 97       	sbiw	r28, 0x10	; 16
    5cae:	cd bf       	out	0x3d, r28	; 61
    5cb0:	de bf       	out	0x3e, r29	; 62
    5cb2:	00 23       	and	r16, r16
    5cb4:	09 f4       	brne	.+2      	; 0x5cb8 <__ashrdi3+0x16>
    5cb6:	56 c0       	rjmp	.+172    	; 0x5d64 <__ashrdi3+0xc2>
    5cb8:	29 87       	std	Y+9, r18	; 0x09
    5cba:	3a 87       	std	Y+10, r19	; 0x0a
    5cbc:	4b 87       	std	Y+11, r20	; 0x0b
    5cbe:	5c 87       	std	Y+12, r21	; 0x0c
    5cc0:	6d 87       	std	Y+13, r22	; 0x0d
    5cc2:	7e 87       	std	Y+14, r23	; 0x0e
    5cc4:	8f 87       	std	Y+15, r24	; 0x0f
    5cc6:	98 8b       	std	Y+16, r25	; 0x10
    5cc8:	20 e2       	ldi	r18, 0x20	; 32
    5cca:	20 1b       	sub	r18, r16
    5ccc:	8d 85       	ldd	r24, Y+13	; 0x0d
    5cce:	9e 85       	ldd	r25, Y+14	; 0x0e
    5cd0:	af 85       	ldd	r26, Y+15	; 0x0f
    5cd2:	b8 89       	ldd	r27, Y+16	; 0x10
    5cd4:	ac 01       	movw	r20, r24
    5cd6:	bd 01       	movw	r22, r26
    5cd8:	12 16       	cp	r1, r18
    5cda:	b4 f0       	brlt	.+44     	; 0x5d08 <__ashrdi3+0x66>
    5cdc:	77 0f       	add	r23, r23
    5cde:	44 0b       	sbc	r20, r20
    5ce0:	54 2f       	mov	r21, r20
    5ce2:	ba 01       	movw	r22, r20
    5ce4:	4d 83       	std	Y+5, r20	; 0x05
    5ce6:	5e 83       	std	Y+6, r21	; 0x06
    5ce8:	6f 83       	std	Y+7, r22	; 0x07
    5cea:	78 87       	std	Y+8, r23	; 0x08
    5cec:	33 27       	eor	r19, r19
    5cee:	27 fd       	sbrc	r18, 7
    5cf0:	30 95       	com	r19
    5cf2:	30 95       	com	r19
    5cf4:	21 95       	neg	r18
    5cf6:	3f 4f       	sbci	r19, 0xFF	; 255
    5cf8:	04 c0       	rjmp	.+8      	; 0x5d02 <__ashrdi3+0x60>
    5cfa:	b5 95       	asr	r27
    5cfc:	a7 95       	ror	r26
    5cfe:	97 95       	ror	r25
    5d00:	87 95       	ror	r24
    5d02:	2a 95       	dec	r18
    5d04:	d2 f7       	brpl	.-12     	; 0x5cfa <__ashrdi3+0x58>
    5d06:	22 c0       	rjmp	.+68     	; 0x5d4c <__ashrdi3+0xaa>
    5d08:	00 2e       	mov	r0, r16
    5d0a:	04 c0       	rjmp	.+8      	; 0x5d14 <__ashrdi3+0x72>
    5d0c:	75 95       	asr	r23
    5d0e:	67 95       	ror	r22
    5d10:	57 95       	ror	r21
    5d12:	47 95       	ror	r20
    5d14:	0a 94       	dec	r0
    5d16:	d2 f7       	brpl	.-12     	; 0x5d0c <__ashrdi3+0x6a>
    5d18:	4d 83       	std	Y+5, r20	; 0x05
    5d1a:	5e 83       	std	Y+6, r21	; 0x06
    5d1c:	6f 83       	std	Y+7, r22	; 0x07
    5d1e:	78 87       	std	Y+8, r23	; 0x08
    5d20:	04 c0       	rjmp	.+8      	; 0x5d2a <__ashrdi3+0x88>
    5d22:	88 0f       	add	r24, r24
    5d24:	99 1f       	adc	r25, r25
    5d26:	aa 1f       	adc	r26, r26
    5d28:	bb 1f       	adc	r27, r27
    5d2a:	2a 95       	dec	r18
    5d2c:	d2 f7       	brpl	.-12     	; 0x5d22 <__ashrdi3+0x80>
    5d2e:	49 85       	ldd	r20, Y+9	; 0x09
    5d30:	5a 85       	ldd	r21, Y+10	; 0x0a
    5d32:	6b 85       	ldd	r22, Y+11	; 0x0b
    5d34:	7c 85       	ldd	r23, Y+12	; 0x0c
    5d36:	04 c0       	rjmp	.+8      	; 0x5d40 <__ashrdi3+0x9e>
    5d38:	76 95       	lsr	r23
    5d3a:	67 95       	ror	r22
    5d3c:	57 95       	ror	r21
    5d3e:	47 95       	ror	r20
    5d40:	0a 95       	dec	r16
    5d42:	d2 f7       	brpl	.-12     	; 0x5d38 <__ashrdi3+0x96>
    5d44:	84 2b       	or	r24, r20
    5d46:	95 2b       	or	r25, r21
    5d48:	a6 2b       	or	r26, r22
    5d4a:	b7 2b       	or	r27, r23
    5d4c:	89 83       	std	Y+1, r24	; 0x01
    5d4e:	9a 83       	std	Y+2, r25	; 0x02
    5d50:	ab 83       	std	Y+3, r26	; 0x03
    5d52:	bc 83       	std	Y+4, r27	; 0x04
    5d54:	29 81       	ldd	r18, Y+1	; 0x01
    5d56:	3a 81       	ldd	r19, Y+2	; 0x02
    5d58:	4b 81       	ldd	r20, Y+3	; 0x03
    5d5a:	5c 81       	ldd	r21, Y+4	; 0x04
    5d5c:	6d 81       	ldd	r22, Y+5	; 0x05
    5d5e:	7e 81       	ldd	r23, Y+6	; 0x06
    5d60:	8f 81       	ldd	r24, Y+7	; 0x07
    5d62:	98 85       	ldd	r25, Y+8	; 0x08
    5d64:	60 96       	adiw	r28, 0x10	; 16
    5d66:	cd bf       	out	0x3d, r28	; 61
    5d68:	de bf       	out	0x3e, r29	; 62
    5d6a:	df 91       	pop	r29
    5d6c:	cf 91       	pop	r28
    5d6e:	0f 91       	pop	r16
    5d70:	08 95       	ret

00005d72 <__divdi3>:
    5d72:	a8 e4       	ldi	r26, 0x48	; 72
    5d74:	b0 e0       	ldi	r27, 0x00	; 0
    5d76:	ef eb       	ldi	r30, 0xBF	; 191
    5d78:	fe e2       	ldi	r31, 0x2E	; 46
    5d7a:	0c 94 a8 38 	jmp	0x7150	; 0x7150 <__prologue_saves__+0x2>
    5d7e:	f5 01       	movw	r30, r10
    5d80:	29 a3       	lds	r18, 0x59
    5d82:	3a a3       	lds	r19, 0x5a
    5d84:	4b a3       	lds	r20, 0x5b
    5d86:	5c a3       	lds	r21, 0x5c
    5d88:	6d a3       	lds	r22, 0x5d
    5d8a:	7e a3       	lds	r23, 0x5e
    5d8c:	8f a3       	lds	r24, 0x5f
    5d8e:	98 a7       	lds	r25, 0x78
    5d90:	a9 8e       	std	Y+25, r10	; 0x19
    5d92:	fa 8f       	std	Y+26, r31	; 0x1a
    5d94:	cb 8e       	std	Y+27, r12	; 0x1b
    5d96:	dc 8e       	std	Y+28, r13	; 0x1c
    5d98:	ed 8e       	std	Y+29, r14	; 0x1d
    5d9a:	fe 8e       	std	Y+30, r15	; 0x1e
    5d9c:	0f 8f       	std	Y+31, r16	; 0x1f
    5d9e:	18 a3       	lds	r17, 0x58
    5da0:	8d a0       	lds	r24, 0x8d
    5da2:	9e a0       	lds	r25, 0x8e
    5da4:	af a0       	lds	r26, 0x8f
    5da6:	b8 a4       	lds	r27, 0xa8
    5da8:	b7 fe       	sbrs	r11, 7
    5daa:	67 c0       	rjmp	.+206    	; 0x5e7a <__divdi3+0x108>
    5dac:	21 95       	neg	r18
    5dae:	b1 e0       	ldi	r27, 0x01	; 1
    5db0:	12 16       	cp	r1, r18
    5db2:	08 f0       	brcs	.+2      	; 0x5db6 <__divdi3+0x44>
    5db4:	b0 e0       	ldi	r27, 0x00	; 0
    5db6:	31 95       	neg	r19
    5db8:	a1 e0       	ldi	r26, 0x01	; 1
    5dba:	13 16       	cp	r1, r19
    5dbc:	08 f0       	brcs	.+2      	; 0x5dc0 <__divdi3+0x4e>
    5dbe:	a0 e0       	ldi	r26, 0x00	; 0
    5dc0:	b3 2e       	mov	r11, r19
    5dc2:	bb 1a       	sub	r11, r27
    5dc4:	bb 2d       	mov	r27, r11
    5dc6:	88 24       	eor	r8, r8
    5dc8:	83 94       	inc	r8
    5dca:	3b 15       	cp	r19, r11
    5dcc:	08 f0       	brcs	.+2      	; 0x5dd0 <__divdi3+0x5e>
    5dce:	88 24       	eor	r8, r8
    5dd0:	a8 29       	or	r26, r8
    5dd2:	41 95       	neg	r20
    5dd4:	31 e0       	ldi	r19, 0x01	; 1
    5dd6:	14 16       	cp	r1, r20
    5dd8:	08 f0       	brcs	.+2      	; 0x5ddc <__divdi3+0x6a>
    5dda:	30 e0       	ldi	r19, 0x00	; 0
    5ddc:	b4 2e       	mov	r11, r20
    5dde:	ba 1a       	sub	r11, r26
    5de0:	ab 2d       	mov	r26, r11
    5de2:	88 24       	eor	r8, r8
    5de4:	83 94       	inc	r8
    5de6:	4b 15       	cp	r20, r11
    5de8:	08 f0       	brcs	.+2      	; 0x5dec <__divdi3+0x7a>
    5dea:	88 24       	eor	r8, r8
    5dec:	38 29       	or	r19, r8
    5dee:	51 95       	neg	r21
    5df0:	41 e0       	ldi	r20, 0x01	; 1
    5df2:	15 16       	cp	r1, r21
    5df4:	08 f0       	brcs	.+2      	; 0x5df8 <__divdi3+0x86>
    5df6:	40 e0       	ldi	r20, 0x00	; 0
    5df8:	45 2e       	mov	r4, r21
    5dfa:	43 1a       	sub	r4, r19
    5dfc:	31 e0       	ldi	r19, 0x01	; 1
    5dfe:	54 15       	cp	r21, r4
    5e00:	08 f0       	brcs	.+2      	; 0x5e04 <__divdi3+0x92>
    5e02:	30 e0       	ldi	r19, 0x00	; 0
    5e04:	43 2b       	or	r20, r19
    5e06:	61 95       	neg	r22
    5e08:	31 e0       	ldi	r19, 0x01	; 1
    5e0a:	16 16       	cp	r1, r22
    5e0c:	08 f0       	brcs	.+2      	; 0x5e10 <__divdi3+0x9e>
    5e0e:	30 e0       	ldi	r19, 0x00	; 0
    5e10:	86 2e       	mov	r8, r22
    5e12:	84 1a       	sub	r8, r20
    5e14:	41 e0       	ldi	r20, 0x01	; 1
    5e16:	68 15       	cp	r22, r8
    5e18:	08 f0       	brcs	.+2      	; 0x5e1c <__divdi3+0xaa>
    5e1a:	40 e0       	ldi	r20, 0x00	; 0
    5e1c:	34 2b       	or	r19, r20
    5e1e:	71 95       	neg	r23
    5e20:	41 e0       	ldi	r20, 0x01	; 1
    5e22:	17 16       	cp	r1, r23
    5e24:	08 f0       	brcs	.+2      	; 0x5e28 <__divdi3+0xb6>
    5e26:	40 e0       	ldi	r20, 0x00	; 0
    5e28:	57 2f       	mov	r21, r23
    5e2a:	53 1b       	sub	r21, r19
    5e2c:	31 e0       	ldi	r19, 0x01	; 1
    5e2e:	75 17       	cp	r23, r21
    5e30:	08 f0       	brcs	.+2      	; 0x5e34 <__divdi3+0xc2>
    5e32:	30 e0       	ldi	r19, 0x00	; 0
    5e34:	43 2b       	or	r20, r19
    5e36:	81 95       	neg	r24
    5e38:	31 e0       	ldi	r19, 0x01	; 1
    5e3a:	18 16       	cp	r1, r24
    5e3c:	08 f0       	brcs	.+2      	; 0x5e40 <__divdi3+0xce>
    5e3e:	30 e0       	ldi	r19, 0x00	; 0
    5e40:	68 2f       	mov	r22, r24
    5e42:	64 1b       	sub	r22, r20
    5e44:	46 2f       	mov	r20, r22
    5e46:	61 e0       	ldi	r22, 0x01	; 1
    5e48:	84 17       	cp	r24, r20
    5e4a:	08 f0       	brcs	.+2      	; 0x5e4e <__divdi3+0xdc>
    5e4c:	60 e0       	ldi	r22, 0x00	; 0
    5e4e:	36 2b       	or	r19, r22
    5e50:	91 95       	neg	r25
    5e52:	93 1b       	sub	r25, r19
    5e54:	29 a3       	lds	r18, 0x59
    5e56:	ba a3       	lds	r27, 0x5a
    5e58:	ab a3       	lds	r26, 0x5b
    5e5a:	4c a2       	lds	r20, 0x9c
    5e5c:	8d a2       	lds	r24, 0x9d
    5e5e:	5e a3       	lds	r21, 0x5e
    5e60:	4f a3       	lds	r20, 0x5f
    5e62:	98 a7       	lds	r25, 0x78
    5e64:	8f ef       	ldi	r24, 0xFF	; 255
    5e66:	9f ef       	ldi	r25, 0xFF	; 255
    5e68:	af ef       	ldi	r26, 0xFF	; 255
    5e6a:	bf ef       	ldi	r27, 0xFF	; 255
    5e6c:	25 96       	adiw	r28, 0x05	; 5
    5e6e:	8c af       	sts	0x7c, r24
    5e70:	9d af       	sts	0x7d, r25
    5e72:	ae af       	sts	0x7e, r26
    5e74:	bf af       	sts	0x7f, r27
    5e76:	25 97       	sbiw	r28, 0x05	; 5
    5e78:	06 c0       	rjmp	.+12     	; 0x5e86 <__divdi3+0x114>
    5e7a:	25 96       	adiw	r28, 0x05	; 5
    5e7c:	1c ae       	sts	0xbc, r17
    5e7e:	1d ae       	sts	0xbd, r17
    5e80:	1e ae       	sts	0xbe, r17
    5e82:	1f ae       	sts	0xbf, r17
    5e84:	25 97       	sbiw	r28, 0x05	; 5
    5e86:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5e88:	9e 8d       	ldd	r25, Y+30	; 0x1e
    5e8a:	af 8d       	ldd	r26, Y+31	; 0x1f
    5e8c:	b8 a1       	lds	r27, 0x48
    5e8e:	b7 ff       	sbrs	r27, 7
    5e90:	68 c0       	rjmp	.+208    	; 0x5f62 <__divdi3+0x1f0>
    5e92:	25 96       	adiw	r28, 0x05	; 5
    5e94:	2c ad       	sts	0x6c, r18
    5e96:	3d ad       	sts	0x6d, r19
    5e98:	4e ad       	sts	0x6e, r20
    5e9a:	5f ad       	sts	0x6f, r21
    5e9c:	25 97       	sbiw	r28, 0x05	; 5
    5e9e:	20 95       	com	r18
    5ea0:	30 95       	com	r19
    5ea2:	40 95       	com	r20
    5ea4:	50 95       	com	r21
    5ea6:	25 96       	adiw	r28, 0x05	; 5
    5ea8:	2c af       	sts	0x7c, r18
    5eaa:	3d af       	sts	0x7d, r19
    5eac:	4e af       	sts	0x7e, r20
    5eae:	5f af       	sts	0x7f, r21
    5eb0:	25 97       	sbiw	r28, 0x05	; 5
    5eb2:	e1 95       	neg	r30
    5eb4:	81 e0       	ldi	r24, 0x01	; 1
    5eb6:	1e 16       	cp	r1, r30
    5eb8:	08 f0       	brcs	.+2      	; 0x5ebc <__divdi3+0x14a>
    5eba:	80 e0       	ldi	r24, 0x00	; 0
    5ebc:	f1 95       	neg	r31
    5ebe:	91 e0       	ldi	r25, 0x01	; 1
    5ec0:	1f 16       	cp	r1, r31
    5ec2:	08 f0       	brcs	.+2      	; 0x5ec6 <__divdi3+0x154>
    5ec4:	90 e0       	ldi	r25, 0x00	; 0
    5ec6:	4f 2f       	mov	r20, r31
    5ec8:	48 1b       	sub	r20, r24
    5eca:	81 e0       	ldi	r24, 0x01	; 1
    5ecc:	f4 17       	cp	r31, r20
    5ece:	08 f0       	brcs	.+2      	; 0x5ed2 <__divdi3+0x160>
    5ed0:	80 e0       	ldi	r24, 0x00	; 0
    5ed2:	98 2b       	or	r25, r24
    5ed4:	c1 94       	neg	r12
    5ed6:	81 e0       	ldi	r24, 0x01	; 1
    5ed8:	1c 14       	cp	r1, r12
    5eda:	08 f0       	brcs	.+2      	; 0x5ede <__divdi3+0x16c>
    5edc:	80 e0       	ldi	r24, 0x00	; 0
    5ede:	6c 2d       	mov	r22, r12
    5ee0:	69 1b       	sub	r22, r25
    5ee2:	91 e0       	ldi	r25, 0x01	; 1
    5ee4:	c6 16       	cp	r12, r22
    5ee6:	08 f0       	brcs	.+2      	; 0x5eea <__divdi3+0x178>
    5ee8:	90 e0       	ldi	r25, 0x00	; 0
    5eea:	89 2b       	or	r24, r25
    5eec:	d1 94       	neg	r13
    5eee:	91 e0       	ldi	r25, 0x01	; 1
    5ef0:	1d 14       	cp	r1, r13
    5ef2:	08 f0       	brcs	.+2      	; 0x5ef6 <__divdi3+0x184>
    5ef4:	90 e0       	ldi	r25, 0x00	; 0
    5ef6:	5d 2d       	mov	r21, r13
    5ef8:	58 1b       	sub	r21, r24
    5efa:	81 e0       	ldi	r24, 0x01	; 1
    5efc:	d5 16       	cp	r13, r21
    5efe:	08 f0       	brcs	.+2      	; 0x5f02 <__divdi3+0x190>
    5f00:	80 e0       	ldi	r24, 0x00	; 0
    5f02:	98 2b       	or	r25, r24
    5f04:	e1 94       	neg	r14
    5f06:	81 e0       	ldi	r24, 0x01	; 1
    5f08:	1e 14       	cp	r1, r14
    5f0a:	08 f0       	brcs	.+2      	; 0x5f0e <__divdi3+0x19c>
    5f0c:	80 e0       	ldi	r24, 0x00	; 0
    5f0e:	3e 2d       	mov	r19, r14
    5f10:	39 1b       	sub	r19, r25
    5f12:	91 e0       	ldi	r25, 0x01	; 1
    5f14:	e3 16       	cp	r14, r19
    5f16:	08 f0       	brcs	.+2      	; 0x5f1a <__divdi3+0x1a8>
    5f18:	90 e0       	ldi	r25, 0x00	; 0
    5f1a:	89 2b       	or	r24, r25
    5f1c:	f1 94       	neg	r15
    5f1e:	91 e0       	ldi	r25, 0x01	; 1
    5f20:	1f 14       	cp	r1, r15
    5f22:	08 f0       	brcs	.+2      	; 0x5f26 <__divdi3+0x1b4>
    5f24:	90 e0       	ldi	r25, 0x00	; 0
    5f26:	2f 2d       	mov	r18, r15
    5f28:	28 1b       	sub	r18, r24
    5f2a:	81 e0       	ldi	r24, 0x01	; 1
    5f2c:	f2 16       	cp	r15, r18
    5f2e:	08 f0       	brcs	.+2      	; 0x5f32 <__divdi3+0x1c0>
    5f30:	80 e0       	ldi	r24, 0x00	; 0
    5f32:	98 2b       	or	r25, r24
    5f34:	01 95       	neg	r16
    5f36:	81 e0       	ldi	r24, 0x01	; 1
    5f38:	10 16       	cp	r1, r16
    5f3a:	08 f0       	brcs	.+2      	; 0x5f3e <__divdi3+0x1cc>
    5f3c:	80 e0       	ldi	r24, 0x00	; 0
    5f3e:	70 2f       	mov	r23, r16
    5f40:	79 1b       	sub	r23, r25
    5f42:	97 2f       	mov	r25, r23
    5f44:	71 e0       	ldi	r23, 0x01	; 1
    5f46:	09 17       	cp	r16, r25
    5f48:	08 f0       	brcs	.+2      	; 0x5f4c <__divdi3+0x1da>
    5f4a:	70 e0       	ldi	r23, 0x00	; 0
    5f4c:	87 2b       	or	r24, r23
    5f4e:	11 95       	neg	r17
    5f50:	18 1b       	sub	r17, r24
    5f52:	e9 8f       	std	Y+25, r30	; 0x19
    5f54:	4a 8f       	std	Y+26, r20	; 0x1a
    5f56:	6b 8f       	std	Y+27, r22	; 0x1b
    5f58:	5c 8f       	std	Y+28, r21	; 0x1c
    5f5a:	3d 8f       	std	Y+29, r19	; 0x1d
    5f5c:	2e 8f       	std	Y+30, r18	; 0x1e
    5f5e:	9f 8f       	std	Y+31, r25	; 0x1f
    5f60:	18 a3       	lds	r17, 0x58
    5f62:	79 8d       	ldd	r23, Y+25	; 0x19
    5f64:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5f66:	5b 8d       	ldd	r21, Y+27	; 0x1b
    5f68:	4c 8d       	ldd	r20, Y+28	; 0x1c
    5f6a:	3d 8d       	ldd	r19, Y+29	; 0x1d
    5f6c:	2e 8d       	ldd	r18, Y+30	; 0x1e
    5f6e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    5f70:	88 a1       	lds	r24, 0x48
    5f72:	e9 a1       	lds	r30, 0x49
    5f74:	e9 8b       	std	Y+17, r30	; 0x11
    5f76:	ea a1       	lds	r30, 0x4a
    5f78:	ea 8b       	std	Y+18, r30	; 0x12
    5f7a:	eb a1       	lds	r30, 0x4b
    5f7c:	eb 8b       	std	Y+19, r30	; 0x13
    5f7e:	ec a1       	lds	r30, 0x4c
    5f80:	ec 8b       	std	Y+20, r30	; 0x14
    5f82:	ed a1       	lds	r30, 0x4d
    5f84:	ed 8b       	std	Y+21, r30	; 0x15
    5f86:	ee a1       	lds	r30, 0x4e
    5f88:	ee 8b       	std	Y+22, r30	; 0x16
    5f8a:	ef a1       	lds	r30, 0x4f
    5f8c:	ef 8b       	std	Y+23, r30	; 0x17
    5f8e:	e8 a5       	lds	r30, 0x68
    5f90:	e8 8f       	std	Y+24, r30	; 0x18
    5f92:	79 87       	std	Y+9, r23	; 0x09
    5f94:	6a 87       	std	Y+10, r22	; 0x0a
    5f96:	5b 87       	std	Y+11, r21	; 0x0b
    5f98:	4c 87       	std	Y+12, r20	; 0x0c
    5f9a:	3d 87       	std	Y+13, r19	; 0x0d
    5f9c:	2e 87       	std	Y+14, r18	; 0x0e
    5f9e:	9f 87       	std	Y+15, r25	; 0x0f
    5fa0:	88 8b       	std	Y+16, r24	; 0x10
    5fa2:	89 84       	ldd	r8, Y+9	; 0x09
    5fa4:	9a 84       	ldd	r9, Y+10	; 0x0a
    5fa6:	ab 84       	ldd	r10, Y+11	; 0x0b
    5fa8:	bc 84       	ldd	r11, Y+12	; 0x0c
    5faa:	8d 85       	ldd	r24, Y+13	; 0x0d
    5fac:	9e 85       	ldd	r25, Y+14	; 0x0e
    5fae:	af 85       	ldd	r26, Y+15	; 0x0f
    5fb0:	b8 89       	ldd	r27, Y+16	; 0x10
    5fb2:	e9 88       	ldd	r14, Y+17	; 0x11
    5fb4:	fa 88       	ldd	r15, Y+18	; 0x12
    5fb6:	0b 89       	ldd	r16, Y+19	; 0x13
    5fb8:	1c 89       	ldd	r17, Y+20	; 0x14
    5fba:	ed aa       	sts	0x9d, r30
    5fbc:	fe aa       	sts	0x9e, r31
    5fbe:	0f ab       	sts	0x5f, r16
    5fc0:	18 af       	sts	0x78, r17
    5fc2:	cd 88       	ldd	r12, Y+21	; 0x15
    5fc4:	de 88       	ldd	r13, Y+22	; 0x16
    5fc6:	ef 88       	ldd	r14, Y+23	; 0x17
    5fc8:	f8 8c       	ldd	r15, Y+24	; 0x18
    5fca:	00 97       	sbiw	r24, 0x00	; 0
    5fcc:	a1 05       	cpc	r26, r1
    5fce:	b1 05       	cpc	r27, r1
    5fd0:	09 f0       	breq	.+2      	; 0x5fd4 <__divdi3+0x262>
    5fd2:	bd c3       	rjmp	.+1914   	; 0x674e <__stack+0x74f>
    5fd4:	c8 14       	cp	r12, r8
    5fd6:	d9 04       	cpc	r13, r9
    5fd8:	ea 04       	cpc	r14, r10
    5fda:	fb 04       	cpc	r15, r11
    5fdc:	08 f0       	brcs	.+2      	; 0x5fe0 <__divdi3+0x26e>
    5fde:	4d c1       	rjmp	.+666    	; 0x627a <__stack+0x27b>
    5fe0:	00 e0       	ldi	r16, 0x00	; 0
    5fe2:	80 16       	cp	r8, r16
    5fe4:	00 e0       	ldi	r16, 0x00	; 0
    5fe6:	90 06       	cpc	r9, r16
    5fe8:	01 e0       	ldi	r16, 0x01	; 1
    5fea:	a0 06       	cpc	r10, r16
    5fec:	00 e0       	ldi	r16, 0x00	; 0
    5fee:	b0 06       	cpc	r11, r16
    5ff0:	58 f4       	brcc	.+22     	; 0x6008 <__stack+0x9>
    5ff2:	1f ef       	ldi	r17, 0xFF	; 255
    5ff4:	81 16       	cp	r8, r17
    5ff6:	91 04       	cpc	r9, r1
    5ff8:	a1 04       	cpc	r10, r1
    5ffa:	b1 04       	cpc	r11, r1
    5ffc:	09 f0       	breq	.+2      	; 0x6000 <__stack+0x1>
    5ffe:	90 f4       	brcc	.+36     	; 0x6024 <__stack+0x25>
    6000:	80 e0       	ldi	r24, 0x00	; 0
    6002:	90 e0       	ldi	r25, 0x00	; 0
    6004:	dc 01       	movw	r26, r24
    6006:	17 c0       	rjmp	.+46     	; 0x6036 <__stack+0x37>
    6008:	20 e0       	ldi	r18, 0x00	; 0
    600a:	82 16       	cp	r8, r18
    600c:	20 e0       	ldi	r18, 0x00	; 0
    600e:	92 06       	cpc	r9, r18
    6010:	20 e0       	ldi	r18, 0x00	; 0
    6012:	a2 06       	cpc	r10, r18
    6014:	21 e0       	ldi	r18, 0x01	; 1
    6016:	b2 06       	cpc	r11, r18
    6018:	50 f4       	brcc	.+20     	; 0x602e <__stack+0x2f>
    601a:	80 e1       	ldi	r24, 0x10	; 16
    601c:	90 e0       	ldi	r25, 0x00	; 0
    601e:	a0 e0       	ldi	r26, 0x00	; 0
    6020:	b0 e0       	ldi	r27, 0x00	; 0
    6022:	09 c0       	rjmp	.+18     	; 0x6036 <__stack+0x37>
    6024:	88 e0       	ldi	r24, 0x08	; 8
    6026:	90 e0       	ldi	r25, 0x00	; 0
    6028:	a0 e0       	ldi	r26, 0x00	; 0
    602a:	b0 e0       	ldi	r27, 0x00	; 0
    602c:	04 c0       	rjmp	.+8      	; 0x6036 <__stack+0x37>
    602e:	88 e1       	ldi	r24, 0x18	; 24
    6030:	90 e0       	ldi	r25, 0x00	; 0
    6032:	a0 e0       	ldi	r26, 0x00	; 0
    6034:	b0 e0       	ldi	r27, 0x00	; 0
    6036:	b5 01       	movw	r22, r10
    6038:	a4 01       	movw	r20, r8
    603a:	08 2e       	mov	r0, r24
    603c:	04 c0       	rjmp	.+8      	; 0x6046 <__stack+0x47>
    603e:	76 95       	lsr	r23
    6040:	67 95       	ror	r22
    6042:	57 95       	ror	r21
    6044:	47 95       	ror	r20
    6046:	0a 94       	dec	r0
    6048:	d2 f7       	brpl	.-12     	; 0x603e <__stack+0x3f>
    604a:	fa 01       	movw	r30, r20
    604c:	e3 5f       	subi	r30, 0xF3	; 243
    604e:	ff 4d       	sbci	r31, 0xDF	; 223
    6050:	20 81       	ld	r18, Z
    6052:	40 e2       	ldi	r20, 0x20	; 32
    6054:	50 e0       	ldi	r21, 0x00	; 0
    6056:	60 e0       	ldi	r22, 0x00	; 0
    6058:	70 e0       	ldi	r23, 0x00	; 0
    605a:	48 1b       	sub	r20, r24
    605c:	59 0b       	sbc	r21, r25
    605e:	6a 0b       	sbc	r22, r26
    6060:	7b 0b       	sbc	r23, r27
    6062:	42 1b       	sub	r20, r18
    6064:	51 09       	sbc	r21, r1
    6066:	61 09       	sbc	r22, r1
    6068:	71 09       	sbc	r23, r1
    606a:	41 15       	cp	r20, r1
    606c:	51 05       	cpc	r21, r1
    606e:	61 05       	cpc	r22, r1
    6070:	71 05       	cpc	r23, r1
    6072:	a1 f1       	breq	.+104    	; 0x60dc <__stack+0xdd>
    6074:	04 2e       	mov	r0, r20
    6076:	04 c0       	rjmp	.+8      	; 0x6080 <__stack+0x81>
    6078:	88 0c       	add	r8, r8
    607a:	99 1c       	adc	r9, r9
    607c:	aa 1c       	adc	r10, r10
    607e:	bb 1c       	adc	r11, r11
    6080:	0a 94       	dec	r0
    6082:	d2 f7       	brpl	.-12     	; 0x6078 <__stack+0x79>
    6084:	97 01       	movw	r18, r14
    6086:	86 01       	movw	r16, r12
    6088:	04 2e       	mov	r0, r20
    608a:	04 c0       	rjmp	.+8      	; 0x6094 <__stack+0x95>
    608c:	00 0f       	add	r16, r16
    608e:	11 1f       	adc	r17, r17
    6090:	22 1f       	adc	r18, r18
    6092:	33 1f       	adc	r19, r19
    6094:	0a 94       	dec	r0
    6096:	d2 f7       	brpl	.-12     	; 0x608c <__stack+0x8d>
    6098:	80 e2       	ldi	r24, 0x20	; 32
    609a:	90 e0       	ldi	r25, 0x00	; 0
    609c:	84 1b       	sub	r24, r20
    609e:	95 0b       	sbc	r25, r21
    60a0:	cd a8       	sts	0x8d, r28
    60a2:	de a8       	sts	0x8e, r29
    60a4:	ef a8       	sts	0x8f, r30
    60a6:	f8 ac       	sts	0xa8, r31
    60a8:	04 c0       	rjmp	.+8      	; 0x60b2 <__stack+0xb3>
    60aa:	f6 94       	lsr	r15
    60ac:	e7 94       	ror	r14
    60ae:	d7 94       	ror	r13
    60b0:	c7 94       	ror	r12
    60b2:	8a 95       	dec	r24
    60b4:	d2 f7       	brpl	.-12     	; 0x60aa <__stack+0xab>
    60b6:	c0 2a       	or	r12, r16
    60b8:	d1 2a       	or	r13, r17
    60ba:	e2 2a       	or	r14, r18
    60bc:	f3 2a       	or	r15, r19
    60be:	0d a9       	sts	0x4d, r16
    60c0:	1e a9       	sts	0x4e, r17
    60c2:	2f a9       	sts	0x4f, r18
    60c4:	38 ad       	sts	0x68, r19
    60c6:	04 c0       	rjmp	.+8      	; 0x60d0 <__stack+0xd1>
    60c8:	00 0f       	add	r16, r16
    60ca:	11 1f       	adc	r17, r17
    60cc:	22 1f       	adc	r18, r18
    60ce:	33 1f       	adc	r19, r19
    60d0:	4a 95       	dec	r20
    60d2:	d2 f7       	brpl	.-12     	; 0x60c8 <__stack+0xc9>
    60d4:	0d ab       	sts	0x5d, r16
    60d6:	1e ab       	sts	0x5e, r17
    60d8:	2f ab       	sts	0x5f, r18
    60da:	38 af       	sts	0x78, r19
    60dc:	25 01       	movw	r4, r10
    60de:	66 24       	eor	r6, r6
    60e0:	77 24       	eor	r7, r7
    60e2:	95 01       	movw	r18, r10
    60e4:	84 01       	movw	r16, r8
    60e6:	20 70       	andi	r18, 0x00	; 0
    60e8:	30 70       	andi	r19, 0x00	; 0
    60ea:	09 ab       	sts	0x59, r16
    60ec:	1a ab       	sts	0x5a, r17
    60ee:	2b ab       	sts	0x5b, r18
    60f0:	3c ab       	sts	0x5c, r19
    60f2:	c7 01       	movw	r24, r14
    60f4:	b6 01       	movw	r22, r12
    60f6:	a3 01       	movw	r20, r6
    60f8:	92 01       	movw	r18, r4
    60fa:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    60fe:	2d a7       	lds	r18, 0x7d
    6100:	3e a7       	lds	r19, 0x7e
    6102:	4f a7       	lds	r20, 0x7f
    6104:	58 ab       	sts	0x58, r21
    6106:	69 a7       	lds	r22, 0x79
    6108:	7a a7       	lds	r23, 0x7a
    610a:	8b a7       	lds	r24, 0x7b
    610c:	9c a7       	lds	r25, 0x7c
    610e:	c7 01       	movw	r24, r14
    6110:	b6 01       	movw	r22, r12
    6112:	a3 01       	movw	r20, r6
    6114:	92 01       	movw	r18, r4
    6116:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    611a:	ca 01       	movw	r24, r20
    611c:	b9 01       	movw	r22, r18
    611e:	29 a9       	sts	0x49, r18
    6120:	3a a9       	sts	0x4a, r19
    6122:	4b a9       	sts	0x4b, r20
    6124:	5c a9       	sts	0x4c, r21
    6126:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    612a:	ab 01       	movw	r20, r22
    612c:	bc 01       	movw	r22, r24
    612e:	09 a5       	lds	r16, 0x69
    6130:	1a a5       	lds	r17, 0x6a
    6132:	2b a5       	lds	r18, 0x6b
    6134:	3c a5       	lds	r19, 0x6c
    6136:	78 01       	movw	r14, r16
    6138:	dd 24       	eor	r13, r13
    613a:	cc 24       	eor	r12, r12
    613c:	0d a9       	sts	0x4d, r16
    613e:	1e a9       	sts	0x4e, r17
    6140:	2f a9       	sts	0x4f, r18
    6142:	38 ad       	sts	0x68, r19
    6144:	c9 01       	movw	r24, r18
    6146:	aa 27       	eor	r26, r26
    6148:	bb 27       	eor	r27, r27
    614a:	c8 2a       	or	r12, r24
    614c:	d9 2a       	or	r13, r25
    614e:	ea 2a       	or	r14, r26
    6150:	fb 2a       	or	r15, r27
    6152:	0d a5       	lds	r16, 0x6d
    6154:	1e a5       	lds	r17, 0x6e
    6156:	2f a5       	lds	r18, 0x6f
    6158:	38 a9       	sts	0x48, r19
    615a:	c4 16       	cp	r12, r20
    615c:	d5 06       	cpc	r13, r21
    615e:	e6 06       	cpc	r14, r22
    6160:	f7 06       	cpc	r15, r23
    6162:	38 f5       	brcc	.+78     	; 0x61b2 <__stack+0x1b3>
    6164:	01 50       	subi	r16, 0x01	; 1
    6166:	10 40       	sbci	r17, 0x00	; 0
    6168:	20 40       	sbci	r18, 0x00	; 0
    616a:	30 40       	sbci	r19, 0x00	; 0
    616c:	09 a7       	lds	r16, 0x79
    616e:	1a a7       	lds	r17, 0x7a
    6170:	2b a7       	lds	r18, 0x7b
    6172:	3c a7       	lds	r19, 0x7c
    6174:	c8 0c       	add	r12, r8
    6176:	d9 1c       	adc	r13, r9
    6178:	ea 1c       	adc	r14, r10
    617a:	fb 1c       	adc	r15, r11
    617c:	c8 14       	cp	r12, r8
    617e:	d9 04       	cpc	r13, r9
    6180:	ea 04       	cpc	r14, r10
    6182:	fb 04       	cpc	r15, r11
    6184:	d0 f0       	brcs	.+52     	; 0x61ba <__stack+0x1bb>
    6186:	c4 16       	cp	r12, r20
    6188:	d5 06       	cpc	r13, r21
    618a:	e6 06       	cpc	r14, r22
    618c:	f7 06       	cpc	r15, r23
    618e:	a8 f4       	brcc	.+42     	; 0x61ba <__stack+0x1bb>
    6190:	0d a5       	lds	r16, 0x6d
    6192:	1e a5       	lds	r17, 0x6e
    6194:	2f a5       	lds	r18, 0x6f
    6196:	38 a9       	sts	0x48, r19
    6198:	02 50       	subi	r16, 0x02	; 2
    619a:	10 40       	sbci	r17, 0x00	; 0
    619c:	20 40       	sbci	r18, 0x00	; 0
    619e:	30 40       	sbci	r19, 0x00	; 0
    61a0:	09 a7       	lds	r16, 0x79
    61a2:	1a a7       	lds	r17, 0x7a
    61a4:	2b a7       	lds	r18, 0x7b
    61a6:	3c a7       	lds	r19, 0x7c
    61a8:	c8 0c       	add	r12, r8
    61aa:	d9 1c       	adc	r13, r9
    61ac:	ea 1c       	adc	r14, r10
    61ae:	fb 1c       	adc	r15, r11
    61b0:	04 c0       	rjmp	.+8      	; 0x61ba <__stack+0x1bb>
    61b2:	09 a7       	lds	r16, 0x79
    61b4:	1a a7       	lds	r17, 0x7a
    61b6:	2b a7       	lds	r18, 0x7b
    61b8:	3c a7       	lds	r19, 0x7c
    61ba:	c4 1a       	sub	r12, r20
    61bc:	d5 0a       	sbc	r13, r21
    61be:	e6 0a       	sbc	r14, r22
    61c0:	f7 0a       	sbc	r15, r23
    61c2:	c7 01       	movw	r24, r14
    61c4:	b6 01       	movw	r22, r12
    61c6:	a3 01       	movw	r20, r6
    61c8:	92 01       	movw	r18, r4
    61ca:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    61ce:	2d a7       	lds	r18, 0x7d
    61d0:	3e a7       	lds	r19, 0x7e
    61d2:	4f a7       	lds	r20, 0x7f
    61d4:	58 ab       	sts	0x58, r21
    61d6:	69 af       	sts	0x79, r22
    61d8:	7a af       	sts	0x7a, r23
    61da:	8b af       	sts	0x7b, r24
    61dc:	9c af       	sts	0x7c, r25
    61de:	c7 01       	movw	r24, r14
    61e0:	b6 01       	movw	r22, r12
    61e2:	a3 01       	movw	r20, r6
    61e4:	92 01       	movw	r18, r4
    61e6:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    61ea:	ca 01       	movw	r24, r20
    61ec:	b9 01       	movw	r22, r18
    61ee:	29 a9       	sts	0x49, r18
    61f0:	3a a9       	sts	0x4a, r19
    61f2:	4b a9       	sts	0x4b, r20
    61f4:	5c a9       	sts	0x4c, r21
    61f6:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    61fa:	6b 01       	movw	r12, r22
    61fc:	7c 01       	movw	r14, r24
    61fe:	49 ad       	sts	0x69, r20
    6200:	5a ad       	sts	0x6a, r21
    6202:	6b ad       	sts	0x6b, r22
    6204:	7c ad       	sts	0x6c, r23
    6206:	9a 01       	movw	r18, r20
    6208:	11 27       	eor	r17, r17
    620a:	00 27       	eor	r16, r16
    620c:	4d a9       	sts	0x4d, r20
    620e:	5e a9       	sts	0x4e, r21
    6210:	6f a9       	sts	0x4f, r22
    6212:	78 ad       	sts	0x68, r23
    6214:	60 70       	andi	r22, 0x00	; 0
    6216:	70 70       	andi	r23, 0x00	; 0
    6218:	04 2b       	or	r16, r20
    621a:	15 2b       	or	r17, r21
    621c:	26 2b       	or	r18, r22
    621e:	37 2b       	or	r19, r23
    6220:	8d a5       	lds	r24, 0x6d
    6222:	9e a5       	lds	r25, 0x6e
    6224:	af a5       	lds	r26, 0x6f
    6226:	b8 a9       	sts	0x48, r27
    6228:	0c 15       	cp	r16, r12
    622a:	1d 05       	cpc	r17, r13
    622c:	2e 05       	cpc	r18, r14
    622e:	3f 05       	cpc	r19, r15
    6230:	c0 f4       	brcc	.+48     	; 0x6262 <__stack+0x263>
    6232:	01 97       	sbiw	r24, 0x01	; 1
    6234:	a1 09       	sbc	r26, r1
    6236:	b1 09       	sbc	r27, r1
    6238:	08 0d       	add	r16, r8
    623a:	19 1d       	adc	r17, r9
    623c:	2a 1d       	adc	r18, r10
    623e:	3b 1d       	adc	r19, r11
    6240:	08 15       	cp	r16, r8
    6242:	19 05       	cpc	r17, r9
    6244:	2a 05       	cpc	r18, r10
    6246:	3b 05       	cpc	r19, r11
    6248:	60 f0       	brcs	.+24     	; 0x6262 <__stack+0x263>
    624a:	0c 15       	cp	r16, r12
    624c:	1d 05       	cpc	r17, r13
    624e:	2e 05       	cpc	r18, r14
    6250:	3f 05       	cpc	r19, r15
    6252:	38 f4       	brcc	.+14     	; 0x6262 <__stack+0x263>
    6254:	8d a5       	lds	r24, 0x6d
    6256:	9e a5       	lds	r25, 0x6e
    6258:	af a5       	lds	r26, 0x6f
    625a:	b8 a9       	sts	0x48, r27
    625c:	02 97       	sbiw	r24, 0x02	; 2
    625e:	a1 09       	sbc	r26, r1
    6260:	b1 09       	sbc	r27, r1
    6262:	09 a5       	lds	r16, 0x69
    6264:	1a a5       	lds	r17, 0x6a
    6266:	2b a5       	lds	r18, 0x6b
    6268:	3c a5       	lds	r19, 0x6c
    626a:	78 01       	movw	r14, r16
    626c:	dd 24       	eor	r13, r13
    626e:	cc 24       	eor	r12, r12
    6270:	c8 2a       	or	r12, r24
    6272:	d9 2a       	or	r13, r25
    6274:	ea 2a       	or	r14, r26
    6276:	fb 2a       	or	r15, r27
    6278:	b7 c4       	rjmp	.+2414   	; 0x6be8 <__stack+0xbe9>
    627a:	81 14       	cp	r8, r1
    627c:	91 04       	cpc	r9, r1
    627e:	a1 04       	cpc	r10, r1
    6280:	b1 04       	cpc	r11, r1
    6282:	51 f4       	brne	.+20     	; 0x6298 <__stack+0x299>
    6284:	61 e0       	ldi	r22, 0x01	; 1
    6286:	70 e0       	ldi	r23, 0x00	; 0
    6288:	80 e0       	ldi	r24, 0x00	; 0
    628a:	90 e0       	ldi	r25, 0x00	; 0
    628c:	a5 01       	movw	r20, r10
    628e:	94 01       	movw	r18, r8
    6290:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    6294:	49 01       	movw	r8, r18
    6296:	5a 01       	movw	r10, r20
    6298:	10 e0       	ldi	r17, 0x00	; 0
    629a:	81 16       	cp	r8, r17
    629c:	10 e0       	ldi	r17, 0x00	; 0
    629e:	91 06       	cpc	r9, r17
    62a0:	11 e0       	ldi	r17, 0x01	; 1
    62a2:	a1 06       	cpc	r10, r17
    62a4:	10 e0       	ldi	r17, 0x00	; 0
    62a6:	b1 06       	cpc	r11, r17
    62a8:	58 f4       	brcc	.+22     	; 0x62c0 <__stack+0x2c1>
    62aa:	2f ef       	ldi	r18, 0xFF	; 255
    62ac:	82 16       	cp	r8, r18
    62ae:	91 04       	cpc	r9, r1
    62b0:	a1 04       	cpc	r10, r1
    62b2:	b1 04       	cpc	r11, r1
    62b4:	09 f0       	breq	.+2      	; 0x62b8 <__stack+0x2b9>
    62b6:	90 f4       	brcc	.+36     	; 0x62dc <__stack+0x2dd>
    62b8:	80 e0       	ldi	r24, 0x00	; 0
    62ba:	90 e0       	ldi	r25, 0x00	; 0
    62bc:	dc 01       	movw	r26, r24
    62be:	17 c0       	rjmp	.+46     	; 0x62ee <__stack+0x2ef>
    62c0:	30 e0       	ldi	r19, 0x00	; 0
    62c2:	83 16       	cp	r8, r19
    62c4:	30 e0       	ldi	r19, 0x00	; 0
    62c6:	93 06       	cpc	r9, r19
    62c8:	30 e0       	ldi	r19, 0x00	; 0
    62ca:	a3 06       	cpc	r10, r19
    62cc:	31 e0       	ldi	r19, 0x01	; 1
    62ce:	b3 06       	cpc	r11, r19
    62d0:	50 f4       	brcc	.+20     	; 0x62e6 <__stack+0x2e7>
    62d2:	80 e1       	ldi	r24, 0x10	; 16
    62d4:	90 e0       	ldi	r25, 0x00	; 0
    62d6:	a0 e0       	ldi	r26, 0x00	; 0
    62d8:	b0 e0       	ldi	r27, 0x00	; 0
    62da:	09 c0       	rjmp	.+18     	; 0x62ee <__stack+0x2ef>
    62dc:	88 e0       	ldi	r24, 0x08	; 8
    62de:	90 e0       	ldi	r25, 0x00	; 0
    62e0:	a0 e0       	ldi	r26, 0x00	; 0
    62e2:	b0 e0       	ldi	r27, 0x00	; 0
    62e4:	04 c0       	rjmp	.+8      	; 0x62ee <__stack+0x2ef>
    62e6:	88 e1       	ldi	r24, 0x18	; 24
    62e8:	90 e0       	ldi	r25, 0x00	; 0
    62ea:	a0 e0       	ldi	r26, 0x00	; 0
    62ec:	b0 e0       	ldi	r27, 0x00	; 0
    62ee:	b5 01       	movw	r22, r10
    62f0:	a4 01       	movw	r20, r8
    62f2:	08 2e       	mov	r0, r24
    62f4:	04 c0       	rjmp	.+8      	; 0x62fe <__stack+0x2ff>
    62f6:	76 95       	lsr	r23
    62f8:	67 95       	ror	r22
    62fa:	57 95       	ror	r21
    62fc:	47 95       	ror	r20
    62fe:	0a 94       	dec	r0
    6300:	d2 f7       	brpl	.-12     	; 0x62f6 <__stack+0x2f7>
    6302:	fa 01       	movw	r30, r20
    6304:	e3 5f       	subi	r30, 0xF3	; 243
    6306:	ff 4d       	sbci	r31, 0xDF	; 223
    6308:	20 81       	ld	r18, Z
    630a:	ac 01       	movw	r20, r24
    630c:	bd 01       	movw	r22, r26
    630e:	42 0f       	add	r20, r18
    6310:	51 1d       	adc	r21, r1
    6312:	61 1d       	adc	r22, r1
    6314:	71 1d       	adc	r23, r1
    6316:	80 e2       	ldi	r24, 0x20	; 32
    6318:	90 e0       	ldi	r25, 0x00	; 0
    631a:	a0 e0       	ldi	r26, 0x00	; 0
    631c:	b0 e0       	ldi	r27, 0x00	; 0
    631e:	84 1b       	sub	r24, r20
    6320:	95 0b       	sbc	r25, r21
    6322:	a6 0b       	sbc	r26, r22
    6324:	b7 0b       	sbc	r27, r23
    6326:	51 f4       	brne	.+20     	; 0x633c <__stack+0x33d>
    6328:	c8 18       	sub	r12, r8
    632a:	d9 08       	sbc	r13, r9
    632c:	ea 08       	sbc	r14, r10
    632e:	fb 08       	sbc	r15, r11
    6330:	f1 e0       	ldi	r31, 0x01	; 1
    6332:	4f 2e       	mov	r4, r31
    6334:	51 2c       	mov	r5, r1
    6336:	61 2c       	mov	r6, r1
    6338:	71 2c       	mov	r7, r1
    633a:	28 c1       	rjmp	.+592    	; 0x658c <__stack+0x58d>
    633c:	08 2e       	mov	r0, r24
    633e:	04 c0       	rjmp	.+8      	; 0x6348 <__stack+0x349>
    6340:	88 0c       	add	r8, r8
    6342:	99 1c       	adc	r9, r9
    6344:	aa 1c       	adc	r10, r10
    6346:	bb 1c       	adc	r11, r11
    6348:	0a 94       	dec	r0
    634a:	d2 f7       	brpl	.-12     	; 0x6340 <__stack+0x341>
    634c:	97 01       	movw	r18, r14
    634e:	86 01       	movw	r16, r12
    6350:	04 2e       	mov	r0, r20
    6352:	04 c0       	rjmp	.+8      	; 0x635c <__stack+0x35d>
    6354:	36 95       	lsr	r19
    6356:	27 95       	ror	r18
    6358:	17 95       	ror	r17
    635a:	07 95       	ror	r16
    635c:	0a 94       	dec	r0
    635e:	d2 f7       	brpl	.-12     	; 0x6354 <__stack+0x355>
    6360:	09 ab       	sts	0x59, r16
    6362:	1a ab       	sts	0x5a, r17
    6364:	2b ab       	sts	0x5b, r18
    6366:	3c ab       	sts	0x5c, r19
    6368:	97 01       	movw	r18, r14
    636a:	86 01       	movw	r16, r12
    636c:	08 2e       	mov	r0, r24
    636e:	04 c0       	rjmp	.+8      	; 0x6378 <__stack+0x379>
    6370:	00 0f       	add	r16, r16
    6372:	11 1f       	adc	r17, r17
    6374:	22 1f       	adc	r18, r18
    6376:	33 1f       	adc	r19, r19
    6378:	0a 94       	dec	r0
    637a:	d2 f7       	brpl	.-12     	; 0x6370 <__stack+0x371>
    637c:	0d a7       	lds	r16, 0x7d
    637e:	1e a7       	lds	r17, 0x7e
    6380:	2f a7       	lds	r18, 0x7f
    6382:	38 ab       	sts	0x58, r19
    6384:	ed a8       	sts	0x8d, r30
    6386:	fe a8       	sts	0x8e, r31
    6388:	0f a9       	sts	0x4f, r16
    638a:	18 ad       	sts	0x68, r17
    638c:	04 c0       	rjmp	.+8      	; 0x6396 <__stack+0x397>
    638e:	16 95       	lsr	r17
    6390:	07 95       	ror	r16
    6392:	f7 94       	ror	r15
    6394:	e7 94       	ror	r14
    6396:	4a 95       	dec	r20
    6398:	d2 f7       	brpl	.-12     	; 0x638e <__stack+0x38f>
    639a:	b8 01       	movw	r22, r16
    639c:	a7 01       	movw	r20, r14
    639e:	0d a5       	lds	r16, 0x6d
    63a0:	1e a5       	lds	r17, 0x6e
    63a2:	2f a5       	lds	r18, 0x6f
    63a4:	38 a9       	sts	0x48, r19
    63a6:	04 2b       	or	r16, r20
    63a8:	15 2b       	or	r17, r21
    63aa:	26 2b       	or	r18, r22
    63ac:	37 2b       	or	r19, r23
    63ae:	0d a7       	lds	r16, 0x7d
    63b0:	1e a7       	lds	r17, 0x7e
    63b2:	2f a7       	lds	r18, 0x7f
    63b4:	38 ab       	sts	0x58, r19
    63b6:	ed a8       	sts	0x8d, r30
    63b8:	fe a8       	sts	0x8e, r31
    63ba:	0f a9       	sts	0x4f, r16
    63bc:	18 ad       	sts	0x68, r17
    63be:	04 c0       	rjmp	.+8      	; 0x63c8 <__stack+0x3c9>
    63c0:	ee 0c       	add	r14, r14
    63c2:	ff 1c       	adc	r15, r15
    63c4:	00 1f       	adc	r16, r16
    63c6:	11 1f       	adc	r17, r17
    63c8:	8a 95       	dec	r24
    63ca:	d2 f7       	brpl	.-12     	; 0x63c0 <__stack+0x3c1>
    63cc:	ed aa       	sts	0x9d, r30
    63ce:	fe aa       	sts	0x9e, r31
    63d0:	0f ab       	sts	0x5f, r16
    63d2:	18 af       	sts	0x78, r17
    63d4:	25 01       	movw	r4, r10
    63d6:	66 24       	eor	r6, r6
    63d8:	77 24       	eor	r7, r7
    63da:	95 01       	movw	r18, r10
    63dc:	84 01       	movw	r16, r8
    63de:	20 70       	andi	r18, 0x00	; 0
    63e0:	30 70       	andi	r19, 0x00	; 0
    63e2:	09 af       	sts	0x79, r16
    63e4:	1a af       	sts	0x7a, r17
    63e6:	2b af       	sts	0x7b, r18
    63e8:	3c af       	sts	0x7c, r19
    63ea:	69 a9       	sts	0x49, r22
    63ec:	7a a9       	sts	0x4a, r23
    63ee:	8b a9       	sts	0x4b, r24
    63f0:	9c a9       	sts	0x4c, r25
    63f2:	a3 01       	movw	r20, r6
    63f4:	92 01       	movw	r18, r4
    63f6:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    63fa:	29 a7       	lds	r18, 0x79
    63fc:	3a a7       	lds	r19, 0x7a
    63fe:	4b a7       	lds	r20, 0x7b
    6400:	5c a7       	lds	r21, 0x7c
    6402:	6b 01       	movw	r12, r22
    6404:	7c 01       	movw	r14, r24
    6406:	69 a9       	sts	0x49, r22
    6408:	7a a9       	sts	0x4a, r23
    640a:	8b a9       	sts	0x4b, r24
    640c:	9c a9       	sts	0x4c, r25
    640e:	a3 01       	movw	r20, r6
    6410:	92 01       	movw	r18, r4
    6412:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    6416:	ca 01       	movw	r24, r20
    6418:	b9 01       	movw	r22, r18
    641a:	29 ad       	sts	0x69, r18
    641c:	3a ad       	sts	0x6a, r19
    641e:	4b ad       	sts	0x6b, r20
    6420:	5c ad       	sts	0x6c, r21
    6422:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    6426:	ab 01       	movw	r20, r22
    6428:	bc 01       	movw	r22, r24
    642a:	76 01       	movw	r14, r12
    642c:	dd 24       	eor	r13, r13
    642e:	cc 24       	eor	r12, r12
    6430:	0d a5       	lds	r16, 0x6d
    6432:	1e a5       	lds	r17, 0x6e
    6434:	2f a5       	lds	r18, 0x6f
    6436:	38 a9       	sts	0x48, r19
    6438:	c9 01       	movw	r24, r18
    643a:	aa 27       	eor	r26, r26
    643c:	bb 27       	eor	r27, r27
    643e:	c8 2a       	or	r12, r24
    6440:	d9 2a       	or	r13, r25
    6442:	ea 2a       	or	r14, r26
    6444:	fb 2a       	or	r15, r27
    6446:	09 a5       	lds	r16, 0x69
    6448:	1a a5       	lds	r17, 0x6a
    644a:	2b a5       	lds	r18, 0x6b
    644c:	3c a5       	lds	r19, 0x6c
    644e:	c4 16       	cp	r12, r20
    6450:	d5 06       	cpc	r13, r21
    6452:	e6 06       	cpc	r14, r22
    6454:	f7 06       	cpc	r15, r23
    6456:	38 f5       	brcc	.+78     	; 0x64a6 <__stack+0x4a7>
    6458:	01 50       	subi	r16, 0x01	; 1
    645a:	10 40       	sbci	r17, 0x00	; 0
    645c:	20 40       	sbci	r18, 0x00	; 0
    645e:	30 40       	sbci	r19, 0x00	; 0
    6460:	09 ab       	sts	0x59, r16
    6462:	1a ab       	sts	0x5a, r17
    6464:	2b ab       	sts	0x5b, r18
    6466:	3c ab       	sts	0x5c, r19
    6468:	c8 0c       	add	r12, r8
    646a:	d9 1c       	adc	r13, r9
    646c:	ea 1c       	adc	r14, r10
    646e:	fb 1c       	adc	r15, r11
    6470:	c8 14       	cp	r12, r8
    6472:	d9 04       	cpc	r13, r9
    6474:	ea 04       	cpc	r14, r10
    6476:	fb 04       	cpc	r15, r11
    6478:	d0 f0       	brcs	.+52     	; 0x64ae <__stack+0x4af>
    647a:	c4 16       	cp	r12, r20
    647c:	d5 06       	cpc	r13, r21
    647e:	e6 06       	cpc	r14, r22
    6480:	f7 06       	cpc	r15, r23
    6482:	a8 f4       	brcc	.+42     	; 0x64ae <__stack+0x4af>
    6484:	09 a5       	lds	r16, 0x69
    6486:	1a a5       	lds	r17, 0x6a
    6488:	2b a5       	lds	r18, 0x6b
    648a:	3c a5       	lds	r19, 0x6c
    648c:	02 50       	subi	r16, 0x02	; 2
    648e:	10 40       	sbci	r17, 0x00	; 0
    6490:	20 40       	sbci	r18, 0x00	; 0
    6492:	30 40       	sbci	r19, 0x00	; 0
    6494:	09 ab       	sts	0x59, r16
    6496:	1a ab       	sts	0x5a, r17
    6498:	2b ab       	sts	0x5b, r18
    649a:	3c ab       	sts	0x5c, r19
    649c:	c8 0c       	add	r12, r8
    649e:	d9 1c       	adc	r13, r9
    64a0:	ea 1c       	adc	r14, r10
    64a2:	fb 1c       	adc	r15, r11
    64a4:	04 c0       	rjmp	.+8      	; 0x64ae <__stack+0x4af>
    64a6:	09 ab       	sts	0x59, r16
    64a8:	1a ab       	sts	0x5a, r17
    64aa:	2b ab       	sts	0x5b, r18
    64ac:	3c ab       	sts	0x5c, r19
    64ae:	c4 1a       	sub	r12, r20
    64b0:	d5 0a       	sbc	r13, r21
    64b2:	e6 0a       	sbc	r14, r22
    64b4:	f7 0a       	sbc	r15, r23
    64b6:	c7 01       	movw	r24, r14
    64b8:	b6 01       	movw	r22, r12
    64ba:	a3 01       	movw	r20, r6
    64bc:	92 01       	movw	r18, r4
    64be:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    64c2:	29 a7       	lds	r18, 0x79
    64c4:	3a a7       	lds	r19, 0x7a
    64c6:	4b a7       	lds	r20, 0x7b
    64c8:	5c a7       	lds	r21, 0x7c
    64ca:	21 96       	adiw	r28, 0x01	; 1
    64cc:	6c af       	sts	0x7c, r22
    64ce:	7d af       	sts	0x7d, r23
    64d0:	8e af       	sts	0x7e, r24
    64d2:	9f af       	sts	0x7f, r25
    64d4:	21 97       	sbiw	r28, 0x01	; 1
    64d6:	c7 01       	movw	r24, r14
    64d8:	b6 01       	movw	r22, r12
    64da:	a3 01       	movw	r20, r6
    64dc:	92 01       	movw	r18, r4
    64de:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    64e2:	ca 01       	movw	r24, r20
    64e4:	b9 01       	movw	r22, r18
    64e6:	29 ad       	sts	0x69, r18
    64e8:	3a ad       	sts	0x6a, r19
    64ea:	4b ad       	sts	0x6b, r20
    64ec:	5c ad       	sts	0x6c, r21
    64ee:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    64f2:	8b 01       	movw	r16, r22
    64f4:	9c 01       	movw	r18, r24
    64f6:	21 96       	adiw	r28, 0x01	; 1
    64f8:	4c ad       	sts	0x6c, r20
    64fa:	5d ad       	sts	0x6d, r21
    64fc:	6e ad       	sts	0x6e, r22
    64fe:	7f ad       	sts	0x6f, r23
    6500:	21 97       	sbiw	r28, 0x01	; 1
    6502:	da 01       	movw	r26, r20
    6504:	99 27       	eor	r25, r25
    6506:	88 27       	eor	r24, r24
    6508:	4d a5       	lds	r20, 0x6d
    650a:	5e a5       	lds	r21, 0x6e
    650c:	6f a5       	lds	r22, 0x6f
    650e:	78 a9       	sts	0x48, r23
    6510:	60 70       	andi	r22, 0x00	; 0
    6512:	70 70       	andi	r23, 0x00	; 0
    6514:	84 2b       	or	r24, r20
    6516:	95 2b       	or	r25, r21
    6518:	a6 2b       	or	r26, r22
    651a:	b7 2b       	or	r27, r23
    651c:	49 a5       	lds	r20, 0x69
    651e:	5a a5       	lds	r21, 0x6a
    6520:	6b a5       	lds	r22, 0x6b
    6522:	7c a5       	lds	r23, 0x6c
    6524:	80 17       	cp	r24, r16
    6526:	91 07       	cpc	r25, r17
    6528:	a2 07       	cpc	r26, r18
    652a:	b3 07       	cpc	r27, r19
    652c:	f0 f4       	brcc	.+60     	; 0x656a <__stack+0x56b>
    652e:	41 50       	subi	r20, 0x01	; 1
    6530:	50 40       	sbci	r21, 0x00	; 0
    6532:	60 40       	sbci	r22, 0x00	; 0
    6534:	70 40       	sbci	r23, 0x00	; 0
    6536:	88 0d       	add	r24, r8
    6538:	99 1d       	adc	r25, r9
    653a:	aa 1d       	adc	r26, r10
    653c:	bb 1d       	adc	r27, r11
    653e:	88 15       	cp	r24, r8
    6540:	99 05       	cpc	r25, r9
    6542:	aa 05       	cpc	r26, r10
    6544:	bb 05       	cpc	r27, r11
    6546:	88 f0       	brcs	.+34     	; 0x656a <__stack+0x56b>
    6548:	80 17       	cp	r24, r16
    654a:	91 07       	cpc	r25, r17
    654c:	a2 07       	cpc	r26, r18
    654e:	b3 07       	cpc	r27, r19
    6550:	60 f4       	brcc	.+24     	; 0x656a <__stack+0x56b>
    6552:	49 a5       	lds	r20, 0x69
    6554:	5a a5       	lds	r21, 0x6a
    6556:	6b a5       	lds	r22, 0x6b
    6558:	7c a5       	lds	r23, 0x6c
    655a:	42 50       	subi	r20, 0x02	; 2
    655c:	50 40       	sbci	r21, 0x00	; 0
    655e:	60 40       	sbci	r22, 0x00	; 0
    6560:	70 40       	sbci	r23, 0x00	; 0
    6562:	88 0d       	add	r24, r8
    6564:	99 1d       	adc	r25, r9
    6566:	aa 1d       	adc	r26, r10
    6568:	bb 1d       	adc	r27, r11
    656a:	6c 01       	movw	r12, r24
    656c:	7d 01       	movw	r14, r26
    656e:	c0 1a       	sub	r12, r16
    6570:	d1 0a       	sbc	r13, r17
    6572:	e2 0a       	sbc	r14, r18
    6574:	f3 0a       	sbc	r15, r19
    6576:	09 a9       	sts	0x49, r16
    6578:	1a a9       	sts	0x4a, r17
    657a:	2b a9       	sts	0x4b, r18
    657c:	3c a9       	sts	0x4c, r19
    657e:	38 01       	movw	r6, r16
    6580:	55 24       	eor	r5, r5
    6582:	44 24       	eor	r4, r4
    6584:	44 2a       	or	r4, r20
    6586:	55 2a       	or	r5, r21
    6588:	66 2a       	or	r6, r22
    658a:	77 2a       	or	r7, r23
    658c:	85 01       	movw	r16, r10
    658e:	22 27       	eor	r18, r18
    6590:	33 27       	eor	r19, r19
    6592:	0d a7       	lds	r16, 0x7d
    6594:	1e a7       	lds	r17, 0x7e
    6596:	2f a7       	lds	r18, 0x7f
    6598:	38 ab       	sts	0x58, r19
    659a:	95 01       	movw	r18, r10
    659c:	84 01       	movw	r16, r8
    659e:	20 70       	andi	r18, 0x00	; 0
    65a0:	30 70       	andi	r19, 0x00	; 0
    65a2:	09 af       	sts	0x79, r16
    65a4:	1a af       	sts	0x7a, r17
    65a6:	2b af       	sts	0x7b, r18
    65a8:	3c af       	sts	0x7c, r19
    65aa:	c7 01       	movw	r24, r14
    65ac:	b6 01       	movw	r22, r12
    65ae:	2d a5       	lds	r18, 0x6d
    65b0:	3e a5       	lds	r19, 0x6e
    65b2:	4f a5       	lds	r20, 0x6f
    65b4:	58 a9       	sts	0x48, r21
    65b6:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    65ba:	29 a7       	lds	r18, 0x79
    65bc:	3a a7       	lds	r19, 0x7a
    65be:	4b a7       	lds	r20, 0x7b
    65c0:	5c a7       	lds	r21, 0x7c
    65c2:	69 ab       	sts	0x59, r22
    65c4:	7a ab       	sts	0x5a, r23
    65c6:	8b ab       	sts	0x5b, r24
    65c8:	9c ab       	sts	0x5c, r25
    65ca:	c7 01       	movw	r24, r14
    65cc:	b6 01       	movw	r22, r12
    65ce:	2d a5       	lds	r18, 0x6d
    65d0:	3e a5       	lds	r19, 0x6e
    65d2:	4f a5       	lds	r20, 0x6f
    65d4:	58 a9       	sts	0x48, r21
    65d6:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    65da:	ca 01       	movw	r24, r20
    65dc:	b9 01       	movw	r22, r18
    65de:	29 ad       	sts	0x69, r18
    65e0:	3a ad       	sts	0x6a, r19
    65e2:	4b ad       	sts	0x6b, r20
    65e4:	5c ad       	sts	0x6c, r21
    65e6:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    65ea:	ab 01       	movw	r20, r22
    65ec:	bc 01       	movw	r22, r24
    65ee:	09 a9       	sts	0x49, r16
    65f0:	1a a9       	sts	0x4a, r17
    65f2:	2b a9       	sts	0x4b, r18
    65f4:	3c a9       	sts	0x4c, r19
    65f6:	78 01       	movw	r14, r16
    65f8:	dd 24       	eor	r13, r13
    65fa:	cc 24       	eor	r12, r12
    65fc:	0d a9       	sts	0x4d, r16
    65fe:	1e a9       	sts	0x4e, r17
    6600:	2f a9       	sts	0x4f, r18
    6602:	38 ad       	sts	0x68, r19
    6604:	c9 01       	movw	r24, r18
    6606:	aa 27       	eor	r26, r26
    6608:	bb 27       	eor	r27, r27
    660a:	c8 2a       	or	r12, r24
    660c:	d9 2a       	or	r13, r25
    660e:	ea 2a       	or	r14, r26
    6610:	fb 2a       	or	r15, r27
    6612:	09 a5       	lds	r16, 0x69
    6614:	1a a5       	lds	r17, 0x6a
    6616:	2b a5       	lds	r18, 0x6b
    6618:	3c a5       	lds	r19, 0x6c
    661a:	c4 16       	cp	r12, r20
    661c:	d5 06       	cpc	r13, r21
    661e:	e6 06       	cpc	r14, r22
    6620:	f7 06       	cpc	r15, r23
    6622:	38 f5       	brcc	.+78     	; 0x6672 <__stack+0x673>
    6624:	01 50       	subi	r16, 0x01	; 1
    6626:	10 40       	sbci	r17, 0x00	; 0
    6628:	20 40       	sbci	r18, 0x00	; 0
    662a:	30 40       	sbci	r19, 0x00	; 0
    662c:	09 ab       	sts	0x59, r16
    662e:	1a ab       	sts	0x5a, r17
    6630:	2b ab       	sts	0x5b, r18
    6632:	3c ab       	sts	0x5c, r19
    6634:	c8 0c       	add	r12, r8
    6636:	d9 1c       	adc	r13, r9
    6638:	ea 1c       	adc	r14, r10
    663a:	fb 1c       	adc	r15, r11
    663c:	c8 14       	cp	r12, r8
    663e:	d9 04       	cpc	r13, r9
    6640:	ea 04       	cpc	r14, r10
    6642:	fb 04       	cpc	r15, r11
    6644:	d0 f0       	brcs	.+52     	; 0x667a <__stack+0x67b>
    6646:	c4 16       	cp	r12, r20
    6648:	d5 06       	cpc	r13, r21
    664a:	e6 06       	cpc	r14, r22
    664c:	f7 06       	cpc	r15, r23
    664e:	a8 f4       	brcc	.+42     	; 0x667a <__stack+0x67b>
    6650:	09 a5       	lds	r16, 0x69
    6652:	1a a5       	lds	r17, 0x6a
    6654:	2b a5       	lds	r18, 0x6b
    6656:	3c a5       	lds	r19, 0x6c
    6658:	02 50       	subi	r16, 0x02	; 2
    665a:	10 40       	sbci	r17, 0x00	; 0
    665c:	20 40       	sbci	r18, 0x00	; 0
    665e:	30 40       	sbci	r19, 0x00	; 0
    6660:	09 ab       	sts	0x59, r16
    6662:	1a ab       	sts	0x5a, r17
    6664:	2b ab       	sts	0x5b, r18
    6666:	3c ab       	sts	0x5c, r19
    6668:	c8 0c       	add	r12, r8
    666a:	d9 1c       	adc	r13, r9
    666c:	ea 1c       	adc	r14, r10
    666e:	fb 1c       	adc	r15, r11
    6670:	04 c0       	rjmp	.+8      	; 0x667a <__stack+0x67b>
    6672:	09 ab       	sts	0x59, r16
    6674:	1a ab       	sts	0x5a, r17
    6676:	2b ab       	sts	0x5b, r18
    6678:	3c ab       	sts	0x5c, r19
    667a:	c4 1a       	sub	r12, r20
    667c:	d5 0a       	sbc	r13, r21
    667e:	e6 0a       	sbc	r14, r22
    6680:	f7 0a       	sbc	r15, r23
    6682:	c7 01       	movw	r24, r14
    6684:	b6 01       	movw	r22, r12
    6686:	2d a5       	lds	r18, 0x6d
    6688:	3e a5       	lds	r19, 0x6e
    668a:	4f a5       	lds	r20, 0x6f
    668c:	58 a9       	sts	0x48, r21
    668e:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    6692:	29 a7       	lds	r18, 0x79
    6694:	3a a7       	lds	r19, 0x7a
    6696:	4b a7       	lds	r20, 0x7b
    6698:	5c a7       	lds	r21, 0x7c
    669a:	21 96       	adiw	r28, 0x01	; 1
    669c:	6c af       	sts	0x7c, r22
    669e:	7d af       	sts	0x7d, r23
    66a0:	8e af       	sts	0x7e, r24
    66a2:	9f af       	sts	0x7f, r25
    66a4:	21 97       	sbiw	r28, 0x01	; 1
    66a6:	c7 01       	movw	r24, r14
    66a8:	b6 01       	movw	r22, r12
    66aa:	2d a5       	lds	r18, 0x6d
    66ac:	3e a5       	lds	r19, 0x6e
    66ae:	4f a5       	lds	r20, 0x6f
    66b0:	58 a9       	sts	0x48, r21
    66b2:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    66b6:	ca 01       	movw	r24, r20
    66b8:	b9 01       	movw	r22, r18
    66ba:	29 ad       	sts	0x69, r18
    66bc:	3a ad       	sts	0x6a, r19
    66be:	4b ad       	sts	0x6b, r20
    66c0:	5c ad       	sts	0x6c, r21
    66c2:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    66c6:	8b 01       	movw	r16, r22
    66c8:	9c 01       	movw	r18, r24
    66ca:	21 96       	adiw	r28, 0x01	; 1
    66cc:	4c ad       	sts	0x6c, r20
    66ce:	5d ad       	sts	0x6d, r21
    66d0:	6e ad       	sts	0x6e, r22
    66d2:	7f ad       	sts	0x6f, r23
    66d4:	21 97       	sbiw	r28, 0x01	; 1
    66d6:	da 01       	movw	r26, r20
    66d8:	99 27       	eor	r25, r25
    66da:	88 27       	eor	r24, r24
    66dc:	4d a9       	sts	0x4d, r20
    66de:	5e a9       	sts	0x4e, r21
    66e0:	6f a9       	sts	0x4f, r22
    66e2:	78 ad       	sts	0x68, r23
    66e4:	60 70       	andi	r22, 0x00	; 0
    66e6:	70 70       	andi	r23, 0x00	; 0
    66e8:	84 2b       	or	r24, r20
    66ea:	95 2b       	or	r25, r21
    66ec:	a6 2b       	or	r26, r22
    66ee:	b7 2b       	or	r27, r23
    66f0:	49 a5       	lds	r20, 0x69
    66f2:	5a a5       	lds	r21, 0x6a
    66f4:	6b a5       	lds	r22, 0x6b
    66f6:	7c a5       	lds	r23, 0x6c
    66f8:	80 17       	cp	r24, r16
    66fa:	91 07       	cpc	r25, r17
    66fc:	a2 07       	cpc	r26, r18
    66fe:	b3 07       	cpc	r27, r19
    6700:	d0 f4       	brcc	.+52     	; 0x6736 <__stack+0x737>
    6702:	41 50       	subi	r20, 0x01	; 1
    6704:	50 40       	sbci	r21, 0x00	; 0
    6706:	60 40       	sbci	r22, 0x00	; 0
    6708:	70 40       	sbci	r23, 0x00	; 0
    670a:	88 0d       	add	r24, r8
    670c:	99 1d       	adc	r25, r9
    670e:	aa 1d       	adc	r26, r10
    6710:	bb 1d       	adc	r27, r11
    6712:	88 15       	cp	r24, r8
    6714:	99 05       	cpc	r25, r9
    6716:	aa 05       	cpc	r26, r10
    6718:	bb 05       	cpc	r27, r11
    671a:	68 f0       	brcs	.+26     	; 0x6736 <__stack+0x737>
    671c:	80 17       	cp	r24, r16
    671e:	91 07       	cpc	r25, r17
    6720:	a2 07       	cpc	r26, r18
    6722:	b3 07       	cpc	r27, r19
    6724:	40 f4       	brcc	.+16     	; 0x6736 <__stack+0x737>
    6726:	49 a5       	lds	r20, 0x69
    6728:	5a a5       	lds	r21, 0x6a
    672a:	6b a5       	lds	r22, 0x6b
    672c:	7c a5       	lds	r23, 0x6c
    672e:	42 50       	subi	r20, 0x02	; 2
    6730:	50 40       	sbci	r21, 0x00	; 0
    6732:	60 40       	sbci	r22, 0x00	; 0
    6734:	70 40       	sbci	r23, 0x00	; 0
    6736:	09 a9       	sts	0x49, r16
    6738:	1a a9       	sts	0x4a, r17
    673a:	2b a9       	sts	0x4b, r18
    673c:	3c a9       	sts	0x4c, r19
    673e:	78 01       	movw	r14, r16
    6740:	dd 24       	eor	r13, r13
    6742:	cc 24       	eor	r12, r12
    6744:	c4 2a       	or	r12, r20
    6746:	d5 2a       	or	r13, r21
    6748:	e6 2a       	or	r14, r22
    674a:	f7 2a       	or	r15, r23
    674c:	50 c2       	rjmp	.+1184   	; 0x6bee <__stack+0xbef>
    674e:	c8 16       	cp	r12, r24
    6750:	d9 06       	cpc	r13, r25
    6752:	ea 06       	cpc	r14, r26
    6754:	fb 06       	cpc	r15, r27
    6756:	08 f4       	brcc	.+2      	; 0x675a <__stack+0x75b>
    6758:	37 c2       	rjmp	.+1134   	; 0x6bc8 <__stack+0xbc9>
    675a:	80 30       	cpi	r24, 0x00	; 0
    675c:	10 e0       	ldi	r17, 0x00	; 0
    675e:	91 07       	cpc	r25, r17
    6760:	11 e0       	ldi	r17, 0x01	; 1
    6762:	a1 07       	cpc	r26, r17
    6764:	10 e0       	ldi	r17, 0x00	; 0
    6766:	b1 07       	cpc	r27, r17
    6768:	50 f4       	brcc	.+20     	; 0x677e <__stack+0x77f>
    676a:	8f 3f       	cpi	r24, 0xFF	; 255
    676c:	91 05       	cpc	r25, r1
    676e:	a1 05       	cpc	r26, r1
    6770:	b1 05       	cpc	r27, r1
    6772:	09 f0       	breq	.+2      	; 0x6776 <__stack+0x777>
    6774:	88 f4       	brcc	.+34     	; 0x6798 <__stack+0x799>
    6776:	00 e0       	ldi	r16, 0x00	; 0
    6778:	10 e0       	ldi	r17, 0x00	; 0
    677a:	98 01       	movw	r18, r16
    677c:	16 c0       	rjmp	.+44     	; 0x67aa <__stack+0x7ab>
    677e:	80 30       	cpi	r24, 0x00	; 0
    6780:	20 e0       	ldi	r18, 0x00	; 0
    6782:	92 07       	cpc	r25, r18
    6784:	20 e0       	ldi	r18, 0x00	; 0
    6786:	a2 07       	cpc	r26, r18
    6788:	21 e0       	ldi	r18, 0x01	; 1
    678a:	b2 07       	cpc	r27, r18
    678c:	50 f4       	brcc	.+20     	; 0x67a2 <__stack+0x7a3>
    678e:	00 e1       	ldi	r16, 0x10	; 16
    6790:	10 e0       	ldi	r17, 0x00	; 0
    6792:	20 e0       	ldi	r18, 0x00	; 0
    6794:	30 e0       	ldi	r19, 0x00	; 0
    6796:	09 c0       	rjmp	.+18     	; 0x67aa <__stack+0x7ab>
    6798:	08 e0       	ldi	r16, 0x08	; 8
    679a:	10 e0       	ldi	r17, 0x00	; 0
    679c:	20 e0       	ldi	r18, 0x00	; 0
    679e:	30 e0       	ldi	r19, 0x00	; 0
    67a0:	04 c0       	rjmp	.+8      	; 0x67aa <__stack+0x7ab>
    67a2:	08 e1       	ldi	r16, 0x18	; 24
    67a4:	10 e0       	ldi	r17, 0x00	; 0
    67a6:	20 e0       	ldi	r18, 0x00	; 0
    67a8:	30 e0       	ldi	r19, 0x00	; 0
    67aa:	ac 01       	movw	r20, r24
    67ac:	bd 01       	movw	r22, r26
    67ae:	00 2e       	mov	r0, r16
    67b0:	04 c0       	rjmp	.+8      	; 0x67ba <__stack+0x7bb>
    67b2:	76 95       	lsr	r23
    67b4:	67 95       	ror	r22
    67b6:	57 95       	ror	r21
    67b8:	47 95       	ror	r20
    67ba:	0a 94       	dec	r0
    67bc:	d2 f7       	brpl	.-12     	; 0x67b2 <__stack+0x7b3>
    67be:	fa 01       	movw	r30, r20
    67c0:	e3 5f       	subi	r30, 0xF3	; 243
    67c2:	ff 4d       	sbci	r31, 0xDF	; 223
    67c4:	40 81       	ld	r20, Z
    67c6:	04 0f       	add	r16, r20
    67c8:	11 1d       	adc	r17, r1
    67ca:	21 1d       	adc	r18, r1
    67cc:	31 1d       	adc	r19, r1
    67ce:	40 e2       	ldi	r20, 0x20	; 32
    67d0:	50 e0       	ldi	r21, 0x00	; 0
    67d2:	60 e0       	ldi	r22, 0x00	; 0
    67d4:	70 e0       	ldi	r23, 0x00	; 0
    67d6:	40 1b       	sub	r20, r16
    67d8:	51 0b       	sbc	r21, r17
    67da:	62 0b       	sbc	r22, r18
    67dc:	73 0b       	sbc	r23, r19
    67de:	a1 f4       	brne	.+40     	; 0x6808 <__stack+0x809>
    67e0:	8c 15       	cp	r24, r12
    67e2:	9d 05       	cpc	r25, r13
    67e4:	ae 05       	cpc	r26, r14
    67e6:	bf 05       	cpc	r27, r15
    67e8:	08 f4       	brcc	.+2      	; 0x67ec <__stack+0x7ed>
    67ea:	f5 c1       	rjmp	.+1002   	; 0x6bd6 <__stack+0xbd7>
    67ec:	ed a8       	sts	0x8d, r30
    67ee:	fe a8       	sts	0x8e, r31
    67f0:	0f a9       	sts	0x4f, r16
    67f2:	18 ad       	sts	0x68, r17
    67f4:	44 24       	eor	r4, r4
    67f6:	55 24       	eor	r5, r5
    67f8:	32 01       	movw	r6, r4
    67fa:	e8 14       	cp	r14, r8
    67fc:	f9 04       	cpc	r15, r9
    67fe:	0a 05       	cpc	r16, r10
    6800:	1b 05       	cpc	r17, r11
    6802:	08 f0       	brcs	.+2      	; 0x6806 <__stack+0x807>
    6804:	eb c1       	rjmp	.+982    	; 0x6bdc <__stack+0xbdd>
    6806:	e3 c1       	rjmp	.+966    	; 0x6bce <__stack+0xbcf>
    6808:	34 2e       	mov	r3, r20
    680a:	2c 01       	movw	r4, r24
    680c:	3d 01       	movw	r6, r26
    680e:	04 c0       	rjmp	.+8      	; 0x6818 <__stack+0x819>
    6810:	44 0c       	add	r4, r4
    6812:	55 1c       	adc	r5, r5
    6814:	66 1c       	adc	r6, r6
    6816:	77 1c       	adc	r7, r7
    6818:	4a 95       	dec	r20
    681a:	d2 f7       	brpl	.-12     	; 0x6810 <__stack+0x811>
    681c:	d5 01       	movw	r26, r10
    681e:	c4 01       	movw	r24, r8
    6820:	00 2e       	mov	r0, r16
    6822:	04 c0       	rjmp	.+8      	; 0x682c <__stack+0x82d>
    6824:	b6 95       	lsr	r27
    6826:	a7 95       	ror	r26
    6828:	97 95       	ror	r25
    682a:	87 95       	ror	r24
    682c:	0a 94       	dec	r0
    682e:	d2 f7       	brpl	.-12     	; 0x6824 <__stack+0x825>
    6830:	48 2a       	or	r4, r24
    6832:	59 2a       	or	r5, r25
    6834:	6a 2a       	or	r6, r26
    6836:	7b 2a       	or	r7, r27
    6838:	a5 01       	movw	r20, r10
    683a:	94 01       	movw	r18, r8
    683c:	03 2c       	mov	r0, r3
    683e:	04 c0       	rjmp	.+8      	; 0x6848 <__stack+0x849>
    6840:	22 0f       	add	r18, r18
    6842:	33 1f       	adc	r19, r19
    6844:	44 1f       	adc	r20, r20
    6846:	55 1f       	adc	r21, r21
    6848:	0a 94       	dec	r0
    684a:	d2 f7       	brpl	.-12     	; 0x6840 <__stack+0x841>
    684c:	29 af       	sts	0x79, r18
    684e:	3a af       	sts	0x7a, r19
    6850:	4b af       	sts	0x7b, r20
    6852:	5c af       	sts	0x7c, r21
    6854:	b7 01       	movw	r22, r14
    6856:	a6 01       	movw	r20, r12
    6858:	00 2e       	mov	r0, r16
    685a:	04 c0       	rjmp	.+8      	; 0x6864 <__stack+0x865>
    685c:	76 95       	lsr	r23
    685e:	67 95       	ror	r22
    6860:	57 95       	ror	r21
    6862:	47 95       	ror	r20
    6864:	0a 94       	dec	r0
    6866:	d2 f7       	brpl	.-12     	; 0x685c <__stack+0x85d>
    6868:	49 ab       	sts	0x59, r20
    686a:	5a ab       	sts	0x5a, r21
    686c:	6b ab       	sts	0x5b, r22
    686e:	7c ab       	sts	0x5c, r23
    6870:	c7 01       	movw	r24, r14
    6872:	b6 01       	movw	r22, r12
    6874:	03 2c       	mov	r0, r3
    6876:	04 c0       	rjmp	.+8      	; 0x6880 <__stack+0x881>
    6878:	66 0f       	add	r22, r22
    687a:	77 1f       	adc	r23, r23
    687c:	88 1f       	adc	r24, r24
    687e:	99 1f       	adc	r25, r25
    6880:	0a 94       	dec	r0
    6882:	d2 f7       	brpl	.-12     	; 0x6878 <__stack+0x879>
    6884:	6d a7       	lds	r22, 0x7d
    6886:	7e a7       	lds	r23, 0x7e
    6888:	8f a7       	lds	r24, 0x7f
    688a:	98 ab       	sts	0x58, r25
    688c:	8d a9       	sts	0x4d, r24
    688e:	9e a9       	sts	0x4e, r25
    6890:	af a9       	sts	0x4f, r26
    6892:	b8 ad       	sts	0x68, r27
    6894:	04 c0       	rjmp	.+8      	; 0x689e <__stack+0x89f>
    6896:	b6 95       	lsr	r27
    6898:	a7 95       	ror	r26
    689a:	97 95       	ror	r25
    689c:	87 95       	ror	r24
    689e:	0a 95       	dec	r16
    68a0:	d2 f7       	brpl	.-12     	; 0x6896 <__stack+0x897>
    68a2:	4d a5       	lds	r20, 0x6d
    68a4:	5e a5       	lds	r21, 0x6e
    68a6:	6f a5       	lds	r22, 0x6f
    68a8:	78 a9       	sts	0x48, r23
    68aa:	48 2b       	or	r20, r24
    68ac:	59 2b       	or	r21, r25
    68ae:	6a 2b       	or	r22, r26
    68b0:	7b 2b       	or	r23, r27
    68b2:	4d a7       	lds	r20, 0x7d
    68b4:	5e a7       	lds	r21, 0x7e
    68b6:	6f a7       	lds	r22, 0x7f
    68b8:	78 ab       	sts	0x58, r23
    68ba:	43 01       	movw	r8, r6
    68bc:	aa 24       	eor	r10, r10
    68be:	bb 24       	eor	r11, r11
    68c0:	93 01       	movw	r18, r6
    68c2:	82 01       	movw	r16, r4
    68c4:	20 70       	andi	r18, 0x00	; 0
    68c6:	30 70       	andi	r19, 0x00	; 0
    68c8:	21 96       	adiw	r28, 0x01	; 1
    68ca:	0c af       	sts	0x7c, r16
    68cc:	1d af       	sts	0x7d, r17
    68ce:	2e af       	sts	0x7e, r18
    68d0:	3f af       	sts	0x7f, r19
    68d2:	21 97       	sbiw	r28, 0x01	; 1
    68d4:	69 a9       	sts	0x49, r22
    68d6:	7a a9       	sts	0x4a, r23
    68d8:	8b a9       	sts	0x4b, r24
    68da:	9c a9       	sts	0x4c, r25
    68dc:	a5 01       	movw	r20, r10
    68de:	94 01       	movw	r18, r8
    68e0:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    68e4:	29 a7       	lds	r18, 0x79
    68e6:	3a a7       	lds	r19, 0x7a
    68e8:	4b a7       	lds	r20, 0x7b
    68ea:	5c a7       	lds	r21, 0x7c
    68ec:	6b 01       	movw	r12, r22
    68ee:	7c 01       	movw	r14, r24
    68f0:	69 a9       	sts	0x49, r22
    68f2:	7a a9       	sts	0x4a, r23
    68f4:	8b a9       	sts	0x4b, r24
    68f6:	9c a9       	sts	0x4c, r25
    68f8:	a5 01       	movw	r20, r10
    68fa:	94 01       	movw	r18, r8
    68fc:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    6900:	ca 01       	movw	r24, r20
    6902:	b9 01       	movw	r22, r18
    6904:	21 96       	adiw	r28, 0x01	; 1
    6906:	2c ad       	sts	0x6c, r18
    6908:	3d ad       	sts	0x6d, r19
    690a:	4e ad       	sts	0x6e, r20
    690c:	5f ad       	sts	0x6f, r21
    690e:	21 97       	sbiw	r28, 0x01	; 1
    6910:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    6914:	dc 01       	movw	r26, r24
    6916:	cb 01       	movw	r24, r22
    6918:	76 01       	movw	r14, r12
    691a:	dd 24       	eor	r13, r13
    691c:	cc 24       	eor	r12, r12
    691e:	0d a5       	lds	r16, 0x6d
    6920:	1e a5       	lds	r17, 0x6e
    6922:	2f a5       	lds	r18, 0x6f
    6924:	38 a9       	sts	0x48, r19
    6926:	a9 01       	movw	r20, r18
    6928:	66 27       	eor	r22, r22
    692a:	77 27       	eor	r23, r23
    692c:	c4 2a       	or	r12, r20
    692e:	d5 2a       	or	r13, r21
    6930:	e6 2a       	or	r14, r22
    6932:	f7 2a       	or	r15, r23
    6934:	09 a5       	lds	r16, 0x69
    6936:	1a a5       	lds	r17, 0x6a
    6938:	2b a5       	lds	r18, 0x6b
    693a:	3c a5       	lds	r19, 0x6c
    693c:	c8 16       	cp	r12, r24
    693e:	d9 06       	cpc	r13, r25
    6940:	ea 06       	cpc	r14, r26
    6942:	fb 06       	cpc	r15, r27
    6944:	38 f5       	brcc	.+78     	; 0x6994 <__stack+0x995>
    6946:	01 50       	subi	r16, 0x01	; 1
    6948:	10 40       	sbci	r17, 0x00	; 0
    694a:	20 40       	sbci	r18, 0x00	; 0
    694c:	30 40       	sbci	r19, 0x00	; 0
    694e:	09 ab       	sts	0x59, r16
    6950:	1a ab       	sts	0x5a, r17
    6952:	2b ab       	sts	0x5b, r18
    6954:	3c ab       	sts	0x5c, r19
    6956:	c4 0c       	add	r12, r4
    6958:	d5 1c       	adc	r13, r5
    695a:	e6 1c       	adc	r14, r6
    695c:	f7 1c       	adc	r15, r7
    695e:	c4 14       	cp	r12, r4
    6960:	d5 04       	cpc	r13, r5
    6962:	e6 04       	cpc	r14, r6
    6964:	f7 04       	cpc	r15, r7
    6966:	d0 f0       	brcs	.+52     	; 0x699c <__stack+0x99d>
    6968:	c8 16       	cp	r12, r24
    696a:	d9 06       	cpc	r13, r25
    696c:	ea 06       	cpc	r14, r26
    696e:	fb 06       	cpc	r15, r27
    6970:	a8 f4       	brcc	.+42     	; 0x699c <__stack+0x99d>
    6972:	09 a5       	lds	r16, 0x69
    6974:	1a a5       	lds	r17, 0x6a
    6976:	2b a5       	lds	r18, 0x6b
    6978:	3c a5       	lds	r19, 0x6c
    697a:	02 50       	subi	r16, 0x02	; 2
    697c:	10 40       	sbci	r17, 0x00	; 0
    697e:	20 40       	sbci	r18, 0x00	; 0
    6980:	30 40       	sbci	r19, 0x00	; 0
    6982:	09 ab       	sts	0x59, r16
    6984:	1a ab       	sts	0x5a, r17
    6986:	2b ab       	sts	0x5b, r18
    6988:	3c ab       	sts	0x5c, r19
    698a:	c4 0c       	add	r12, r4
    698c:	d5 1c       	adc	r13, r5
    698e:	e6 1c       	adc	r14, r6
    6990:	f7 1c       	adc	r15, r7
    6992:	04 c0       	rjmp	.+8      	; 0x699c <__stack+0x99d>
    6994:	09 ab       	sts	0x59, r16
    6996:	1a ab       	sts	0x5a, r17
    6998:	2b ab       	sts	0x5b, r18
    699a:	3c ab       	sts	0x5c, r19
    699c:	c8 1a       	sub	r12, r24
    699e:	d9 0a       	sbc	r13, r25
    69a0:	ea 0a       	sbc	r14, r26
    69a2:	fb 0a       	sbc	r15, r27
    69a4:	c7 01       	movw	r24, r14
    69a6:	b6 01       	movw	r22, r12
    69a8:	a5 01       	movw	r20, r10
    69aa:	94 01       	movw	r18, r8
    69ac:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    69b0:	29 a7       	lds	r18, 0x79
    69b2:	3a a7       	lds	r19, 0x7a
    69b4:	4b a7       	lds	r20, 0x7b
    69b6:	5c a7       	lds	r21, 0x7c
    69b8:	29 96       	adiw	r28, 0x09	; 9
    69ba:	6c af       	sts	0x7c, r22
    69bc:	7d af       	sts	0x7d, r23
    69be:	8e af       	sts	0x7e, r24
    69c0:	9f af       	sts	0x7f, r25
    69c2:	29 97       	sbiw	r28, 0x09	; 9
    69c4:	c7 01       	movw	r24, r14
    69c6:	b6 01       	movw	r22, r12
    69c8:	a5 01       	movw	r20, r10
    69ca:	94 01       	movw	r18, r8
    69cc:	0e 94 56 38 	call	0x70ac	; 0x70ac <__udivmodsi4>
    69d0:	ca 01       	movw	r24, r20
    69d2:	b9 01       	movw	r22, r18
    69d4:	21 96       	adiw	r28, 0x01	; 1
    69d6:	2c ad       	sts	0x6c, r18
    69d8:	3d ad       	sts	0x6d, r19
    69da:	4e ad       	sts	0x6e, r20
    69dc:	5f ad       	sts	0x6f, r21
    69de:	21 97       	sbiw	r28, 0x01	; 1
    69e0:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    69e4:	4b 01       	movw	r8, r22
    69e6:	5c 01       	movw	r10, r24
    69e8:	29 96       	adiw	r28, 0x09	; 9
    69ea:	4c ad       	sts	0x6c, r20
    69ec:	5d ad       	sts	0x6d, r21
    69ee:	6e ad       	sts	0x6e, r22
    69f0:	7f ad       	sts	0x6f, r23
    69f2:	29 97       	sbiw	r28, 0x09	; 9
    69f4:	9a 01       	movw	r18, r20
    69f6:	11 27       	eor	r17, r17
    69f8:	00 27       	eor	r16, r16
    69fa:	8d a5       	lds	r24, 0x6d
    69fc:	9e a5       	lds	r25, 0x6e
    69fe:	af a5       	lds	r26, 0x6f
    6a00:	b8 a9       	sts	0x48, r27
    6a02:	a0 70       	andi	r26, 0x00	; 0
    6a04:	b0 70       	andi	r27, 0x00	; 0
    6a06:	08 2b       	or	r16, r24
    6a08:	19 2b       	or	r17, r25
    6a0a:	2a 2b       	or	r18, r26
    6a0c:	3b 2b       	or	r19, r27
    6a0e:	89 a5       	lds	r24, 0x69
    6a10:	9a a5       	lds	r25, 0x6a
    6a12:	ab a5       	lds	r26, 0x6b
    6a14:	bc a5       	lds	r27, 0x6c
    6a16:	08 15       	cp	r16, r8
    6a18:	19 05       	cpc	r17, r9
    6a1a:	2a 05       	cpc	r18, r10
    6a1c:	3b 05       	cpc	r19, r11
    6a1e:	e0 f4       	brcc	.+56     	; 0x6a58 <__stack+0xa59>
    6a20:	01 97       	sbiw	r24, 0x01	; 1
    6a22:	a1 09       	sbc	r26, r1
    6a24:	b1 09       	sbc	r27, r1
    6a26:	04 0d       	add	r16, r4
    6a28:	15 1d       	adc	r17, r5
    6a2a:	26 1d       	adc	r18, r6
    6a2c:	37 1d       	adc	r19, r7
    6a2e:	04 15       	cp	r16, r4
    6a30:	15 05       	cpc	r17, r5
    6a32:	26 05       	cpc	r18, r6
    6a34:	37 05       	cpc	r19, r7
    6a36:	80 f0       	brcs	.+32     	; 0x6a58 <__stack+0xa59>
    6a38:	08 15       	cp	r16, r8
    6a3a:	19 05       	cpc	r17, r9
    6a3c:	2a 05       	cpc	r18, r10
    6a3e:	3b 05       	cpc	r19, r11
    6a40:	58 f4       	brcc	.+22     	; 0x6a58 <__stack+0xa59>
    6a42:	89 a5       	lds	r24, 0x69
    6a44:	9a a5       	lds	r25, 0x6a
    6a46:	ab a5       	lds	r26, 0x6b
    6a48:	bc a5       	lds	r27, 0x6c
    6a4a:	02 97       	sbiw	r24, 0x02	; 2
    6a4c:	a1 09       	sbc	r26, r1
    6a4e:	b1 09       	sbc	r27, r1
    6a50:	04 0d       	add	r16, r4
    6a52:	15 1d       	adc	r17, r5
    6a54:	26 1d       	adc	r18, r6
    6a56:	37 1d       	adc	r19, r7
    6a58:	b9 01       	movw	r22, r18
    6a5a:	a8 01       	movw	r20, r16
    6a5c:	48 19       	sub	r20, r8
    6a5e:	59 09       	sbc	r21, r9
    6a60:	6a 09       	sbc	r22, r10
    6a62:	7b 09       	sbc	r23, r11
    6a64:	4d a7       	lds	r20, 0x7d
    6a66:	5e a7       	lds	r21, 0x7e
    6a68:	6f a7       	lds	r22, 0x7f
    6a6a:	78 ab       	sts	0x58, r23
    6a6c:	09 a9       	sts	0x49, r16
    6a6e:	1a a9       	sts	0x4a, r17
    6a70:	2b a9       	sts	0x4b, r18
    6a72:	3c a9       	sts	0x4c, r19
    6a74:	78 01       	movw	r14, r16
    6a76:	dd 24       	eor	r13, r13
    6a78:	cc 24       	eor	r12, r12
    6a7a:	c8 2a       	or	r12, r24
    6a7c:	d9 2a       	or	r13, r25
    6a7e:	ea 2a       	or	r14, r26
    6a80:	fb 2a       	or	r15, r27
    6a82:	ff ef       	ldi	r31, 0xFF	; 255
    6a84:	8f 2e       	mov	r8, r31
    6a86:	ff ef       	ldi	r31, 0xFF	; 255
    6a88:	9f 2e       	mov	r9, r31
    6a8a:	a1 2c       	mov	r10, r1
    6a8c:	b1 2c       	mov	r11, r1
    6a8e:	8c 20       	and	r8, r12
    6a90:	9d 20       	and	r9, r13
    6a92:	ae 20       	and	r10, r14
    6a94:	bf 20       	and	r11, r15
    6a96:	87 01       	movw	r16, r14
    6a98:	22 27       	eor	r18, r18
    6a9a:	33 27       	eor	r19, r19
    6a9c:	09 a7       	lds	r16, 0x79
    6a9e:	1a a7       	lds	r17, 0x7a
    6aa0:	2b a7       	lds	r18, 0x7b
    6aa2:	3c a7       	lds	r19, 0x7c
    6aa4:	49 ac       	sts	0xa9, r20
    6aa6:	5a ac       	sts	0xaa, r21
    6aa8:	6b ac       	sts	0xab, r22
    6aaa:	7c ac       	sts	0xac, r23
    6aac:	2f ef       	ldi	r18, 0xFF	; 255
    6aae:	3f ef       	ldi	r19, 0xFF	; 255
    6ab0:	40 e0       	ldi	r20, 0x00	; 0
    6ab2:	50 e0       	ldi	r21, 0x00	; 0
    6ab4:	42 22       	and	r4, r18
    6ab6:	53 22       	and	r5, r19
    6ab8:	64 22       	and	r6, r20
    6aba:	75 22       	and	r7, r21
    6abc:	29 ad       	sts	0x69, r18
    6abe:	3a ad       	sts	0x6a, r19
    6ac0:	4b ad       	sts	0x6b, r20
    6ac2:	5c ad       	sts	0x6c, r21
    6ac4:	8a 01       	movw	r16, r20
    6ac6:	22 27       	eor	r18, r18
    6ac8:	33 27       	eor	r19, r19
    6aca:	09 ab       	sts	0x59, r16
    6acc:	1a ab       	sts	0x5a, r17
    6ace:	2b ab       	sts	0x5b, r18
    6ad0:	3c ab       	sts	0x5c, r19
    6ad2:	c5 01       	movw	r24, r10
    6ad4:	b4 01       	movw	r22, r8
    6ad6:	a3 01       	movw	r20, r6
    6ad8:	92 01       	movw	r18, r4
    6ada:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    6ade:	69 af       	sts	0x79, r22
    6ae0:	7a af       	sts	0x7a, r23
    6ae2:	8b af       	sts	0x7b, r24
    6ae4:	9c af       	sts	0x7c, r25
    6ae6:	c5 01       	movw	r24, r10
    6ae8:	b4 01       	movw	r22, r8
    6aea:	29 a9       	sts	0x49, r18
    6aec:	3a a9       	sts	0x4a, r19
    6aee:	4b a9       	sts	0x4b, r20
    6af0:	5c a9       	sts	0x4c, r21
    6af2:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    6af6:	4b 01       	movw	r8, r22
    6af8:	5c 01       	movw	r10, r24
    6afa:	69 a5       	lds	r22, 0x69
    6afc:	7a a5       	lds	r23, 0x6a
    6afe:	8b a5       	lds	r24, 0x6b
    6b00:	9c a5       	lds	r25, 0x6c
    6b02:	a3 01       	movw	r20, r6
    6b04:	92 01       	movw	r18, r4
    6b06:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    6b0a:	2b 01       	movw	r4, r22
    6b0c:	3c 01       	movw	r6, r24
    6b0e:	69 a5       	lds	r22, 0x69
    6b10:	7a a5       	lds	r23, 0x6a
    6b12:	8b a5       	lds	r24, 0x6b
    6b14:	9c a5       	lds	r25, 0x6c
    6b16:	29 a9       	sts	0x49, r18
    6b18:	3a a9       	sts	0x4a, r19
    6b1a:	4b a9       	sts	0x4b, r20
    6b1c:	5c a9       	sts	0x4c, r21
    6b1e:	0e 94 24 38 	call	0x7048	; 0x7048 <__mulsi3>
    6b22:	ab 01       	movw	r20, r22
    6b24:	bc 01       	movw	r22, r24
    6b26:	84 0c       	add	r8, r4
    6b28:	95 1c       	adc	r9, r5
    6b2a:	a6 1c       	adc	r10, r6
    6b2c:	b7 1c       	adc	r11, r7
    6b2e:	09 ad       	sts	0x69, r16
    6b30:	1a ad       	sts	0x6a, r17
    6b32:	2b ad       	sts	0x6b, r18
    6b34:	3c ad       	sts	0x6c, r19
    6b36:	c9 01       	movw	r24, r18
    6b38:	aa 27       	eor	r26, r26
    6b3a:	bb 27       	eor	r27, r27
    6b3c:	88 0e       	add	r8, r24
    6b3e:	99 1e       	adc	r9, r25
    6b40:	aa 1e       	adc	r10, r26
    6b42:	bb 1e       	adc	r11, r27
    6b44:	84 14       	cp	r8, r4
    6b46:	95 04       	cpc	r9, r5
    6b48:	a6 04       	cpc	r10, r6
    6b4a:	b7 04       	cpc	r11, r7
    6b4c:	20 f4       	brcc	.+8      	; 0x6b56 <__stack+0xb57>
    6b4e:	40 50       	subi	r20, 0x00	; 0
    6b50:	50 40       	sbci	r21, 0x00	; 0
    6b52:	6f 4f       	sbci	r22, 0xFF	; 255
    6b54:	7f 4f       	sbci	r23, 0xFF	; 255
    6b56:	c5 01       	movw	r24, r10
    6b58:	aa 27       	eor	r26, r26
    6b5a:	bb 27       	eor	r27, r27
    6b5c:	84 0f       	add	r24, r20
    6b5e:	95 1f       	adc	r25, r21
    6b60:	a6 1f       	adc	r26, r22
    6b62:	b7 1f       	adc	r27, r23
    6b64:	0d a5       	lds	r16, 0x6d
    6b66:	1e a5       	lds	r17, 0x6e
    6b68:	2f a5       	lds	r18, 0x6f
    6b6a:	38 a9       	sts	0x48, r19
    6b6c:	08 17       	cp	r16, r24
    6b6e:	19 07       	cpc	r17, r25
    6b70:	2a 07       	cpc	r18, r26
    6b72:	3b 07       	cpc	r19, r27
    6b74:	18 f1       	brcs	.+70     	; 0x6bbc <__stack+0xbbd>
    6b76:	80 17       	cp	r24, r16
    6b78:	91 07       	cpc	r25, r17
    6b7a:	a2 07       	cpc	r26, r18
    6b7c:	b3 07       	cpc	r27, r19
    6b7e:	a1 f5       	brne	.+104    	; 0x6be8 <__stack+0xbe9>
    6b80:	54 01       	movw	r10, r8
    6b82:	99 24       	eor	r9, r9
    6b84:	88 24       	eor	r8, r8
    6b86:	89 ad       	sts	0x69, r24
    6b88:	9a ad       	sts	0x6a, r25
    6b8a:	ab ad       	sts	0x6b, r26
    6b8c:	bc ad       	sts	0x6c, r27
    6b8e:	a0 70       	andi	r26, 0x00	; 0
    6b90:	b0 70       	andi	r27, 0x00	; 0
    6b92:	88 0e       	add	r8, r24
    6b94:	99 1e       	adc	r9, r25
    6b96:	aa 1e       	adc	r10, r26
    6b98:	bb 1e       	adc	r11, r27
    6b9a:	4d a9       	sts	0x4d, r20
    6b9c:	5e a9       	sts	0x4e, r21
    6b9e:	6f a9       	sts	0x4f, r22
    6ba0:	78 ad       	sts	0x68, r23
    6ba2:	03 2c       	mov	r0, r3
    6ba4:	04 c0       	rjmp	.+8      	; 0x6bae <__stack+0xbaf>
    6ba6:	44 0f       	add	r20, r20
    6ba8:	55 1f       	adc	r21, r21
    6baa:	66 1f       	adc	r22, r22
    6bac:	77 1f       	adc	r23, r23
    6bae:	0a 94       	dec	r0
    6bb0:	d2 f7       	brpl	.-12     	; 0x6ba6 <__stack+0xba7>
    6bb2:	48 15       	cp	r20, r8
    6bb4:	59 05       	cpc	r21, r9
    6bb6:	6a 05       	cpc	r22, r10
    6bb8:	7b 05       	cpc	r23, r11
    6bba:	b0 f4       	brcc	.+44     	; 0x6be8 <__stack+0xbe9>
    6bbc:	08 94       	sec
    6bbe:	c1 08       	sbc	r12, r1
    6bc0:	d1 08       	sbc	r13, r1
    6bc2:	e1 08       	sbc	r14, r1
    6bc4:	f1 08       	sbc	r15, r1
    6bc6:	10 c0       	rjmp	.+32     	; 0x6be8 <__stack+0xbe9>
    6bc8:	44 24       	eor	r4, r4
    6bca:	55 24       	eor	r5, r5
    6bcc:	32 01       	movw	r6, r4
    6bce:	cc 24       	eor	r12, r12
    6bd0:	dd 24       	eor	r13, r13
    6bd2:	76 01       	movw	r14, r12
    6bd4:	0c c0       	rjmp	.+24     	; 0x6bee <__stack+0xbef>
    6bd6:	44 24       	eor	r4, r4
    6bd8:	55 24       	eor	r5, r5
    6bda:	32 01       	movw	r6, r4
    6bdc:	81 e0       	ldi	r24, 0x01	; 1
    6bde:	c8 2e       	mov	r12, r24
    6be0:	d1 2c       	mov	r13, r1
    6be2:	e1 2c       	mov	r14, r1
    6be4:	f1 2c       	mov	r15, r1
    6be6:	03 c0       	rjmp	.+6      	; 0x6bee <__stack+0xbef>
    6be8:	44 24       	eor	r4, r4
    6bea:	55 24       	eor	r5, r5
    6bec:	32 01       	movw	r6, r4
    6bee:	fe 01       	movw	r30, r28
    6bf0:	31 96       	adiw	r30, 0x01	; 1
    6bf2:	88 e0       	ldi	r24, 0x08	; 8
    6bf4:	df 01       	movw	r26, r30
    6bf6:	1d 92       	st	X+, r1
    6bf8:	8a 95       	dec	r24
    6bfa:	e9 f7       	brne	.-6      	; 0x6bf6 <__stack+0xbf7>
    6bfc:	c9 82       	std	Y+1, r12	; 0x01
    6bfe:	da 82       	std	Y+2, r13	; 0x02
    6c00:	eb 82       	std	Y+3, r14	; 0x03
    6c02:	fc 82       	std	Y+4, r15	; 0x04
    6c04:	4d 82       	std	Y+5, r4	; 0x05
    6c06:	5e 82       	std	Y+6, r5	; 0x06
    6c08:	6f 82       	std	Y+7, r6	; 0x07
    6c0a:	78 86       	std	Y+8, r7	; 0x08
    6c0c:	2c 2d       	mov	r18, r12
    6c0e:	3a 81       	ldd	r19, Y+2	; 0x02
    6c10:	4b 81       	ldd	r20, Y+3	; 0x03
    6c12:	5c 81       	ldd	r21, Y+4	; 0x04
    6c14:	64 2d       	mov	r22, r4
    6c16:	7e 81       	ldd	r23, Y+6	; 0x06
    6c18:	8f 81       	ldd	r24, Y+7	; 0x07
    6c1a:	98 85       	ldd	r25, Y+8	; 0x08
    6c1c:	25 96       	adiw	r28, 0x05	; 5
    6c1e:	ec ac       	sts	0xac, r30
    6c20:	fd ac       	sts	0xad, r31
    6c22:	0e ad       	sts	0x6e, r16
    6c24:	1f ad       	sts	0x6f, r17
    6c26:	25 97       	sbiw	r28, 0x05	; 5
    6c28:	e1 14       	cp	r14, r1
    6c2a:	f1 04       	cpc	r15, r1
    6c2c:	01 05       	cpc	r16, r1
    6c2e:	11 05       	cpc	r17, r1
    6c30:	09 f4       	brne	.+2      	; 0x6c34 <__stack+0xc35>
    6c32:	56 c0       	rjmp	.+172    	; 0x6ce0 <__stack+0xce1>
    6c34:	21 95       	neg	r18
    6c36:	e1 e0       	ldi	r30, 0x01	; 1
    6c38:	12 16       	cp	r1, r18
    6c3a:	08 f0       	brcs	.+2      	; 0x6c3e <__stack+0xc3f>
    6c3c:	e0 e0       	ldi	r30, 0x00	; 0
    6c3e:	31 95       	neg	r19
    6c40:	f1 e0       	ldi	r31, 0x01	; 1
    6c42:	13 16       	cp	r1, r19
    6c44:	08 f0       	brcs	.+2      	; 0x6c48 <__stack+0xc49>
    6c46:	f0 e0       	ldi	r31, 0x00	; 0
    6c48:	03 2f       	mov	r16, r19
    6c4a:	0e 1b       	sub	r16, r30
    6c4c:	e1 e0       	ldi	r30, 0x01	; 1
    6c4e:	30 17       	cp	r19, r16
    6c50:	08 f0       	brcs	.+2      	; 0x6c54 <__stack+0xc55>
    6c52:	e0 e0       	ldi	r30, 0x00	; 0
    6c54:	fe 2b       	or	r31, r30
    6c56:	41 95       	neg	r20
    6c58:	e1 e0       	ldi	r30, 0x01	; 1
    6c5a:	14 16       	cp	r1, r20
    6c5c:	08 f0       	brcs	.+2      	; 0x6c60 <__stack+0xc61>
    6c5e:	e0 e0       	ldi	r30, 0x00	; 0
    6c60:	14 2f       	mov	r17, r20
    6c62:	1f 1b       	sub	r17, r31
    6c64:	31 e0       	ldi	r19, 0x01	; 1
    6c66:	41 17       	cp	r20, r17
    6c68:	08 f0       	brcs	.+2      	; 0x6c6c <__stack+0xc6d>
    6c6a:	30 e0       	ldi	r19, 0x00	; 0
    6c6c:	e3 2b       	or	r30, r19
    6c6e:	51 95       	neg	r21
    6c70:	f1 e0       	ldi	r31, 0x01	; 1
    6c72:	15 16       	cp	r1, r21
    6c74:	08 f0       	brcs	.+2      	; 0x6c78 <__stack+0xc79>
    6c76:	f0 e0       	ldi	r31, 0x00	; 0
    6c78:	b5 2f       	mov	r27, r21
    6c7a:	be 1b       	sub	r27, r30
    6c7c:	31 e0       	ldi	r19, 0x01	; 1
    6c7e:	5b 17       	cp	r21, r27
    6c80:	08 f0       	brcs	.+2      	; 0x6c84 <__stack+0xc85>
    6c82:	30 e0       	ldi	r19, 0x00	; 0
    6c84:	f3 2b       	or	r31, r19
    6c86:	61 95       	neg	r22
    6c88:	e1 e0       	ldi	r30, 0x01	; 1
    6c8a:	16 16       	cp	r1, r22
    6c8c:	08 f0       	brcs	.+2      	; 0x6c90 <__stack+0xc91>
    6c8e:	e0 e0       	ldi	r30, 0x00	; 0
    6c90:	46 2e       	mov	r4, r22
    6c92:	4f 1a       	sub	r4, r31
    6c94:	31 e0       	ldi	r19, 0x01	; 1
    6c96:	64 15       	cp	r22, r4
    6c98:	08 f0       	brcs	.+2      	; 0x6c9c <__stack+0xc9d>
    6c9a:	30 e0       	ldi	r19, 0x00	; 0
    6c9c:	e3 2b       	or	r30, r19
    6c9e:	71 95       	neg	r23
    6ca0:	f1 e0       	ldi	r31, 0x01	; 1
    6ca2:	17 16       	cp	r1, r23
    6ca4:	08 f0       	brcs	.+2      	; 0x6ca8 <__stack+0xca9>
    6ca6:	f0 e0       	ldi	r31, 0x00	; 0
    6ca8:	a7 2f       	mov	r26, r23
    6caa:	ae 1b       	sub	r26, r30
    6cac:	31 e0       	ldi	r19, 0x01	; 1
    6cae:	7a 17       	cp	r23, r26
    6cb0:	08 f0       	brcs	.+2      	; 0x6cb4 <__stack+0xcb5>
    6cb2:	30 e0       	ldi	r19, 0x00	; 0
    6cb4:	f3 2b       	or	r31, r19
    6cb6:	81 95       	neg	r24
    6cb8:	e1 e0       	ldi	r30, 0x01	; 1
    6cba:	18 16       	cp	r1, r24
    6cbc:	08 f0       	brcs	.+2      	; 0x6cc0 <__stack+0xcc1>
    6cbe:	e0 e0       	ldi	r30, 0x00	; 0
    6cc0:	f8 2e       	mov	r15, r24
    6cc2:	ff 1a       	sub	r15, r31
    6cc4:	ff 2d       	mov	r31, r15
    6cc6:	31 e0       	ldi	r19, 0x01	; 1
    6cc8:	8f 15       	cp	r24, r15
    6cca:	08 f0       	brcs	.+2      	; 0x6cce <__stack+0xccf>
    6ccc:	30 e0       	ldi	r19, 0x00	; 0
    6cce:	e3 2b       	or	r30, r19
    6cd0:	91 95       	neg	r25
    6cd2:	30 2f       	mov	r19, r16
    6cd4:	41 2f       	mov	r20, r17
    6cd6:	5b 2f       	mov	r21, r27
    6cd8:	64 2d       	mov	r22, r4
    6cda:	7a 2f       	mov	r23, r26
    6cdc:	8f 2f       	mov	r24, r31
    6cde:	9e 1b       	sub	r25, r30
    6ce0:	c8 5b       	subi	r28, 0xB8	; 184
    6ce2:	df 4f       	sbci	r29, 0xFF	; 255
    6ce4:	e1 e1       	ldi	r30, 0x11	; 17
    6ce6:	0c 94 c1 38 	jmp	0x7182	; 0x7182 <__epilogue_restores__+0x2>

00006cea <__subsf3>:
    6cea:	50 58       	subi	r21, 0x80	; 128

00006cec <__addsf3>:
    6cec:	bb 27       	eor	r27, r27
    6cee:	aa 27       	eor	r26, r26
    6cf0:	0e d0       	rcall	.+28     	; 0x6d0e <__addsf3x>
    6cf2:	48 c1       	rjmp	.+656    	; 0x6f84 <__fp_round>
    6cf4:	39 d1       	rcall	.+626    	; 0x6f68 <__fp_pscA>
    6cf6:	30 f0       	brcs	.+12     	; 0x6d04 <__addsf3+0x18>
    6cf8:	3e d1       	rcall	.+636    	; 0x6f76 <__fp_pscB>
    6cfa:	20 f0       	brcs	.+8      	; 0x6d04 <__addsf3+0x18>
    6cfc:	31 f4       	brne	.+12     	; 0x6d0a <__addsf3+0x1e>
    6cfe:	9f 3f       	cpi	r25, 0xFF	; 255
    6d00:	11 f4       	brne	.+4      	; 0x6d06 <__addsf3+0x1a>
    6d02:	1e f4       	brtc	.+6      	; 0x6d0a <__addsf3+0x1e>
    6d04:	2e c1       	rjmp	.+604    	; 0x6f62 <__fp_nan>
    6d06:	0e f4       	brtc	.+2      	; 0x6d0a <__addsf3+0x1e>
    6d08:	e0 95       	com	r30
    6d0a:	e7 fb       	bst	r30, 7
    6d0c:	24 c1       	rjmp	.+584    	; 0x6f56 <__fp_inf>

00006d0e <__addsf3x>:
    6d0e:	e9 2f       	mov	r30, r25
    6d10:	4a d1       	rcall	.+660    	; 0x6fa6 <__fp_split3>
    6d12:	80 f3       	brcs	.-32     	; 0x6cf4 <__addsf3+0x8>
    6d14:	ba 17       	cp	r27, r26
    6d16:	62 07       	cpc	r22, r18
    6d18:	73 07       	cpc	r23, r19
    6d1a:	84 07       	cpc	r24, r20
    6d1c:	95 07       	cpc	r25, r21
    6d1e:	18 f0       	brcs	.+6      	; 0x6d26 <__addsf3x+0x18>
    6d20:	71 f4       	brne	.+28     	; 0x6d3e <__addsf3x+0x30>
    6d22:	9e f5       	brtc	.+102    	; 0x6d8a <__addsf3x+0x7c>
    6d24:	62 c1       	rjmp	.+708    	; 0x6fea <__fp_zero>
    6d26:	0e f4       	brtc	.+2      	; 0x6d2a <__addsf3x+0x1c>
    6d28:	e0 95       	com	r30
    6d2a:	0b 2e       	mov	r0, r27
    6d2c:	ba 2f       	mov	r27, r26
    6d2e:	a0 2d       	mov	r26, r0
    6d30:	0b 01       	movw	r0, r22
    6d32:	b9 01       	movw	r22, r18
    6d34:	90 01       	movw	r18, r0
    6d36:	0c 01       	movw	r0, r24
    6d38:	ca 01       	movw	r24, r20
    6d3a:	a0 01       	movw	r20, r0
    6d3c:	11 24       	eor	r1, r1
    6d3e:	ff 27       	eor	r31, r31
    6d40:	59 1b       	sub	r21, r25
    6d42:	99 f0       	breq	.+38     	; 0x6d6a <__addsf3x+0x5c>
    6d44:	59 3f       	cpi	r21, 0xF9	; 249
    6d46:	50 f4       	brcc	.+20     	; 0x6d5c <__addsf3x+0x4e>
    6d48:	50 3e       	cpi	r21, 0xE0	; 224
    6d4a:	68 f1       	brcs	.+90     	; 0x6da6 <__addsf3x+0x98>
    6d4c:	1a 16       	cp	r1, r26
    6d4e:	f0 40       	sbci	r31, 0x00	; 0
    6d50:	a2 2f       	mov	r26, r18
    6d52:	23 2f       	mov	r18, r19
    6d54:	34 2f       	mov	r19, r20
    6d56:	44 27       	eor	r20, r20
    6d58:	58 5f       	subi	r21, 0xF8	; 248
    6d5a:	f3 cf       	rjmp	.-26     	; 0x6d42 <__addsf3x+0x34>
    6d5c:	46 95       	lsr	r20
    6d5e:	37 95       	ror	r19
    6d60:	27 95       	ror	r18
    6d62:	a7 95       	ror	r26
    6d64:	f0 40       	sbci	r31, 0x00	; 0
    6d66:	53 95       	inc	r21
    6d68:	c9 f7       	brne	.-14     	; 0x6d5c <__addsf3x+0x4e>
    6d6a:	7e f4       	brtc	.+30     	; 0x6d8a <__addsf3x+0x7c>
    6d6c:	1f 16       	cp	r1, r31
    6d6e:	ba 0b       	sbc	r27, r26
    6d70:	62 0b       	sbc	r22, r18
    6d72:	73 0b       	sbc	r23, r19
    6d74:	84 0b       	sbc	r24, r20
    6d76:	ba f0       	brmi	.+46     	; 0x6da6 <__addsf3x+0x98>
    6d78:	91 50       	subi	r25, 0x01	; 1
    6d7a:	a1 f0       	breq	.+40     	; 0x6da4 <__addsf3x+0x96>
    6d7c:	ff 0f       	add	r31, r31
    6d7e:	bb 1f       	adc	r27, r27
    6d80:	66 1f       	adc	r22, r22
    6d82:	77 1f       	adc	r23, r23
    6d84:	88 1f       	adc	r24, r24
    6d86:	c2 f7       	brpl	.-16     	; 0x6d78 <__addsf3x+0x6a>
    6d88:	0e c0       	rjmp	.+28     	; 0x6da6 <__addsf3x+0x98>
    6d8a:	ba 0f       	add	r27, r26
    6d8c:	62 1f       	adc	r22, r18
    6d8e:	73 1f       	adc	r23, r19
    6d90:	84 1f       	adc	r24, r20
    6d92:	48 f4       	brcc	.+18     	; 0x6da6 <__addsf3x+0x98>
    6d94:	87 95       	ror	r24
    6d96:	77 95       	ror	r23
    6d98:	67 95       	ror	r22
    6d9a:	b7 95       	ror	r27
    6d9c:	f7 95       	ror	r31
    6d9e:	9e 3f       	cpi	r25, 0xFE	; 254
    6da0:	08 f0       	brcs	.+2      	; 0x6da4 <__addsf3x+0x96>
    6da2:	b3 cf       	rjmp	.-154    	; 0x6d0a <__addsf3+0x1e>
    6da4:	93 95       	inc	r25
    6da6:	88 0f       	add	r24, r24
    6da8:	08 f0       	brcs	.+2      	; 0x6dac <__addsf3x+0x9e>
    6daa:	99 27       	eor	r25, r25
    6dac:	ee 0f       	add	r30, r30
    6dae:	97 95       	ror	r25
    6db0:	87 95       	ror	r24
    6db2:	08 95       	ret

00006db4 <__divsf3>:
    6db4:	0c d0       	rcall	.+24     	; 0x6dce <__divsf3x>
    6db6:	e6 c0       	rjmp	.+460    	; 0x6f84 <__fp_round>
    6db8:	de d0       	rcall	.+444    	; 0x6f76 <__fp_pscB>
    6dba:	40 f0       	brcs	.+16     	; 0x6dcc <__divsf3+0x18>
    6dbc:	d5 d0       	rcall	.+426    	; 0x6f68 <__fp_pscA>
    6dbe:	30 f0       	brcs	.+12     	; 0x6dcc <__divsf3+0x18>
    6dc0:	21 f4       	brne	.+8      	; 0x6dca <__divsf3+0x16>
    6dc2:	5f 3f       	cpi	r21, 0xFF	; 255
    6dc4:	19 f0       	breq	.+6      	; 0x6dcc <__divsf3+0x18>
    6dc6:	c7 c0       	rjmp	.+398    	; 0x6f56 <__fp_inf>
    6dc8:	51 11       	cpse	r21, r1
    6dca:	10 c1       	rjmp	.+544    	; 0x6fec <__fp_szero>
    6dcc:	ca c0       	rjmp	.+404    	; 0x6f62 <__fp_nan>

00006dce <__divsf3x>:
    6dce:	eb d0       	rcall	.+470    	; 0x6fa6 <__fp_split3>
    6dd0:	98 f3       	brcs	.-26     	; 0x6db8 <__divsf3+0x4>

00006dd2 <__divsf3_pse>:
    6dd2:	99 23       	and	r25, r25
    6dd4:	c9 f3       	breq	.-14     	; 0x6dc8 <__divsf3+0x14>
    6dd6:	55 23       	and	r21, r21
    6dd8:	b1 f3       	breq	.-20     	; 0x6dc6 <__divsf3+0x12>
    6dda:	95 1b       	sub	r25, r21
    6ddc:	55 0b       	sbc	r21, r21
    6dde:	bb 27       	eor	r27, r27
    6de0:	aa 27       	eor	r26, r26
    6de2:	62 17       	cp	r22, r18
    6de4:	73 07       	cpc	r23, r19
    6de6:	84 07       	cpc	r24, r20
    6de8:	38 f0       	brcs	.+14     	; 0x6df8 <__divsf3_pse+0x26>
    6dea:	9f 5f       	subi	r25, 0xFF	; 255
    6dec:	5f 4f       	sbci	r21, 0xFF	; 255
    6dee:	22 0f       	add	r18, r18
    6df0:	33 1f       	adc	r19, r19
    6df2:	44 1f       	adc	r20, r20
    6df4:	aa 1f       	adc	r26, r26
    6df6:	a9 f3       	breq	.-22     	; 0x6de2 <__divsf3_pse+0x10>
    6df8:	33 d0       	rcall	.+102    	; 0x6e60 <__divsf3_pse+0x8e>
    6dfa:	0e 2e       	mov	r0, r30
    6dfc:	3a f0       	brmi	.+14     	; 0x6e0c <__divsf3_pse+0x3a>
    6dfe:	e0 e8       	ldi	r30, 0x80	; 128
    6e00:	30 d0       	rcall	.+96     	; 0x6e62 <__divsf3_pse+0x90>
    6e02:	91 50       	subi	r25, 0x01	; 1
    6e04:	50 40       	sbci	r21, 0x00	; 0
    6e06:	e6 95       	lsr	r30
    6e08:	00 1c       	adc	r0, r0
    6e0a:	ca f7       	brpl	.-14     	; 0x6dfe <__divsf3_pse+0x2c>
    6e0c:	29 d0       	rcall	.+82     	; 0x6e60 <__divsf3_pse+0x8e>
    6e0e:	fe 2f       	mov	r31, r30
    6e10:	27 d0       	rcall	.+78     	; 0x6e60 <__divsf3_pse+0x8e>
    6e12:	66 0f       	add	r22, r22
    6e14:	77 1f       	adc	r23, r23
    6e16:	88 1f       	adc	r24, r24
    6e18:	bb 1f       	adc	r27, r27
    6e1a:	26 17       	cp	r18, r22
    6e1c:	37 07       	cpc	r19, r23
    6e1e:	48 07       	cpc	r20, r24
    6e20:	ab 07       	cpc	r26, r27
    6e22:	b0 e8       	ldi	r27, 0x80	; 128
    6e24:	09 f0       	breq	.+2      	; 0x6e28 <__divsf3_pse+0x56>
    6e26:	bb 0b       	sbc	r27, r27
    6e28:	80 2d       	mov	r24, r0
    6e2a:	bf 01       	movw	r22, r30
    6e2c:	ff 27       	eor	r31, r31
    6e2e:	93 58       	subi	r25, 0x83	; 131
    6e30:	5f 4f       	sbci	r21, 0xFF	; 255
    6e32:	2a f0       	brmi	.+10     	; 0x6e3e <__divsf3_pse+0x6c>
    6e34:	9e 3f       	cpi	r25, 0xFE	; 254
    6e36:	51 05       	cpc	r21, r1
    6e38:	68 f0       	brcs	.+26     	; 0x6e54 <__divsf3_pse+0x82>
    6e3a:	8d c0       	rjmp	.+282    	; 0x6f56 <__fp_inf>
    6e3c:	d7 c0       	rjmp	.+430    	; 0x6fec <__fp_szero>
    6e3e:	5f 3f       	cpi	r21, 0xFF	; 255
    6e40:	ec f3       	brlt	.-6      	; 0x6e3c <__divsf3_pse+0x6a>
    6e42:	98 3e       	cpi	r25, 0xE8	; 232
    6e44:	dc f3       	brlt	.-10     	; 0x6e3c <__divsf3_pse+0x6a>
    6e46:	86 95       	lsr	r24
    6e48:	77 95       	ror	r23
    6e4a:	67 95       	ror	r22
    6e4c:	b7 95       	ror	r27
    6e4e:	f7 95       	ror	r31
    6e50:	9f 5f       	subi	r25, 0xFF	; 255
    6e52:	c9 f7       	brne	.-14     	; 0x6e46 <__divsf3_pse+0x74>
    6e54:	88 0f       	add	r24, r24
    6e56:	91 1d       	adc	r25, r1
    6e58:	96 95       	lsr	r25
    6e5a:	87 95       	ror	r24
    6e5c:	97 f9       	bld	r25, 7
    6e5e:	08 95       	ret
    6e60:	e1 e0       	ldi	r30, 0x01	; 1
    6e62:	66 0f       	add	r22, r22
    6e64:	77 1f       	adc	r23, r23
    6e66:	88 1f       	adc	r24, r24
    6e68:	bb 1f       	adc	r27, r27
    6e6a:	62 17       	cp	r22, r18
    6e6c:	73 07       	cpc	r23, r19
    6e6e:	84 07       	cpc	r24, r20
    6e70:	ba 07       	cpc	r27, r26
    6e72:	20 f0       	brcs	.+8      	; 0x6e7c <__divsf3_pse+0xaa>
    6e74:	62 1b       	sub	r22, r18
    6e76:	73 0b       	sbc	r23, r19
    6e78:	84 0b       	sbc	r24, r20
    6e7a:	ba 0b       	sbc	r27, r26
    6e7c:	ee 1f       	adc	r30, r30
    6e7e:	88 f7       	brcc	.-30     	; 0x6e62 <__divsf3_pse+0x90>
    6e80:	e0 95       	com	r30
    6e82:	08 95       	ret

00006e84 <__fixunssfsi>:
    6e84:	98 d0       	rcall	.+304    	; 0x6fb6 <__fp_splitA>
    6e86:	88 f0       	brcs	.+34     	; 0x6eaa <__fixunssfsi+0x26>
    6e88:	9f 57       	subi	r25, 0x7F	; 127
    6e8a:	90 f0       	brcs	.+36     	; 0x6eb0 <__fixunssfsi+0x2c>
    6e8c:	b9 2f       	mov	r27, r25
    6e8e:	99 27       	eor	r25, r25
    6e90:	b7 51       	subi	r27, 0x17	; 23
    6e92:	a0 f0       	brcs	.+40     	; 0x6ebc <__fixunssfsi+0x38>
    6e94:	d1 f0       	breq	.+52     	; 0x6eca <__fixunssfsi+0x46>
    6e96:	66 0f       	add	r22, r22
    6e98:	77 1f       	adc	r23, r23
    6e9a:	88 1f       	adc	r24, r24
    6e9c:	99 1f       	adc	r25, r25
    6e9e:	1a f0       	brmi	.+6      	; 0x6ea6 <__fixunssfsi+0x22>
    6ea0:	ba 95       	dec	r27
    6ea2:	c9 f7       	brne	.-14     	; 0x6e96 <__fixunssfsi+0x12>
    6ea4:	12 c0       	rjmp	.+36     	; 0x6eca <__fixunssfsi+0x46>
    6ea6:	b1 30       	cpi	r27, 0x01	; 1
    6ea8:	81 f0       	breq	.+32     	; 0x6eca <__fixunssfsi+0x46>
    6eaa:	9f d0       	rcall	.+318    	; 0x6fea <__fp_zero>
    6eac:	b1 e0       	ldi	r27, 0x01	; 1
    6eae:	08 95       	ret
    6eb0:	9c c0       	rjmp	.+312    	; 0x6fea <__fp_zero>
    6eb2:	67 2f       	mov	r22, r23
    6eb4:	78 2f       	mov	r23, r24
    6eb6:	88 27       	eor	r24, r24
    6eb8:	b8 5f       	subi	r27, 0xF8	; 248
    6eba:	39 f0       	breq	.+14     	; 0x6eca <__fixunssfsi+0x46>
    6ebc:	b9 3f       	cpi	r27, 0xF9	; 249
    6ebe:	cc f3       	brlt	.-14     	; 0x6eb2 <__fixunssfsi+0x2e>
    6ec0:	86 95       	lsr	r24
    6ec2:	77 95       	ror	r23
    6ec4:	67 95       	ror	r22
    6ec6:	b3 95       	inc	r27
    6ec8:	d9 f7       	brne	.-10     	; 0x6ec0 <__fixunssfsi+0x3c>
    6eca:	3e f4       	brtc	.+14     	; 0x6eda <__fixunssfsi+0x56>
    6ecc:	90 95       	com	r25
    6ece:	80 95       	com	r24
    6ed0:	70 95       	com	r23
    6ed2:	61 95       	neg	r22
    6ed4:	7f 4f       	sbci	r23, 0xFF	; 255
    6ed6:	8f 4f       	sbci	r24, 0xFF	; 255
    6ed8:	9f 4f       	sbci	r25, 0xFF	; 255
    6eda:	08 95       	ret

00006edc <__floatunsisf>:
    6edc:	e8 94       	clt
    6ede:	09 c0       	rjmp	.+18     	; 0x6ef2 <__floatsisf+0x12>

00006ee0 <__floatsisf>:
    6ee0:	97 fb       	bst	r25, 7
    6ee2:	3e f4       	brtc	.+14     	; 0x6ef2 <__floatsisf+0x12>
    6ee4:	90 95       	com	r25
    6ee6:	80 95       	com	r24
    6ee8:	70 95       	com	r23
    6eea:	61 95       	neg	r22
    6eec:	7f 4f       	sbci	r23, 0xFF	; 255
    6eee:	8f 4f       	sbci	r24, 0xFF	; 255
    6ef0:	9f 4f       	sbci	r25, 0xFF	; 255
    6ef2:	99 23       	and	r25, r25
    6ef4:	a9 f0       	breq	.+42     	; 0x6f20 <__floatsisf+0x40>
    6ef6:	f9 2f       	mov	r31, r25
    6ef8:	96 e9       	ldi	r25, 0x96	; 150
    6efa:	bb 27       	eor	r27, r27
    6efc:	93 95       	inc	r25
    6efe:	f6 95       	lsr	r31
    6f00:	87 95       	ror	r24
    6f02:	77 95       	ror	r23
    6f04:	67 95       	ror	r22
    6f06:	b7 95       	ror	r27
    6f08:	f1 11       	cpse	r31, r1
    6f0a:	f8 cf       	rjmp	.-16     	; 0x6efc <__floatsisf+0x1c>
    6f0c:	fa f4       	brpl	.+62     	; 0x6f4c <__floatsisf+0x6c>
    6f0e:	bb 0f       	add	r27, r27
    6f10:	11 f4       	brne	.+4      	; 0x6f16 <__floatsisf+0x36>
    6f12:	60 ff       	sbrs	r22, 0
    6f14:	1b c0       	rjmp	.+54     	; 0x6f4c <__floatsisf+0x6c>
    6f16:	6f 5f       	subi	r22, 0xFF	; 255
    6f18:	7f 4f       	sbci	r23, 0xFF	; 255
    6f1a:	8f 4f       	sbci	r24, 0xFF	; 255
    6f1c:	9f 4f       	sbci	r25, 0xFF	; 255
    6f1e:	16 c0       	rjmp	.+44     	; 0x6f4c <__floatsisf+0x6c>
    6f20:	88 23       	and	r24, r24
    6f22:	11 f0       	breq	.+4      	; 0x6f28 <__floatsisf+0x48>
    6f24:	96 e9       	ldi	r25, 0x96	; 150
    6f26:	11 c0       	rjmp	.+34     	; 0x6f4a <__floatsisf+0x6a>
    6f28:	77 23       	and	r23, r23
    6f2a:	21 f0       	breq	.+8      	; 0x6f34 <__floatsisf+0x54>
    6f2c:	9e e8       	ldi	r25, 0x8E	; 142
    6f2e:	87 2f       	mov	r24, r23
    6f30:	76 2f       	mov	r23, r22
    6f32:	05 c0       	rjmp	.+10     	; 0x6f3e <__floatsisf+0x5e>
    6f34:	66 23       	and	r22, r22
    6f36:	71 f0       	breq	.+28     	; 0x6f54 <__floatsisf+0x74>
    6f38:	96 e8       	ldi	r25, 0x86	; 134
    6f3a:	86 2f       	mov	r24, r22
    6f3c:	70 e0       	ldi	r23, 0x00	; 0
    6f3e:	60 e0       	ldi	r22, 0x00	; 0
    6f40:	2a f0       	brmi	.+10     	; 0x6f4c <__floatsisf+0x6c>
    6f42:	9a 95       	dec	r25
    6f44:	66 0f       	add	r22, r22
    6f46:	77 1f       	adc	r23, r23
    6f48:	88 1f       	adc	r24, r24
    6f4a:	da f7       	brpl	.-10     	; 0x6f42 <__floatsisf+0x62>
    6f4c:	88 0f       	add	r24, r24
    6f4e:	96 95       	lsr	r25
    6f50:	87 95       	ror	r24
    6f52:	97 f9       	bld	r25, 7
    6f54:	08 95       	ret

00006f56 <__fp_inf>:
    6f56:	97 f9       	bld	r25, 7
    6f58:	9f 67       	ori	r25, 0x7F	; 127
    6f5a:	80 e8       	ldi	r24, 0x80	; 128
    6f5c:	70 e0       	ldi	r23, 0x00	; 0
    6f5e:	60 e0       	ldi	r22, 0x00	; 0
    6f60:	08 95       	ret

00006f62 <__fp_nan>:
    6f62:	9f ef       	ldi	r25, 0xFF	; 255
    6f64:	80 ec       	ldi	r24, 0xC0	; 192
    6f66:	08 95       	ret

00006f68 <__fp_pscA>:
    6f68:	00 24       	eor	r0, r0
    6f6a:	0a 94       	dec	r0
    6f6c:	16 16       	cp	r1, r22
    6f6e:	17 06       	cpc	r1, r23
    6f70:	18 06       	cpc	r1, r24
    6f72:	09 06       	cpc	r0, r25
    6f74:	08 95       	ret

00006f76 <__fp_pscB>:
    6f76:	00 24       	eor	r0, r0
    6f78:	0a 94       	dec	r0
    6f7a:	12 16       	cp	r1, r18
    6f7c:	13 06       	cpc	r1, r19
    6f7e:	14 06       	cpc	r1, r20
    6f80:	05 06       	cpc	r0, r21
    6f82:	08 95       	ret

00006f84 <__fp_round>:
    6f84:	09 2e       	mov	r0, r25
    6f86:	03 94       	inc	r0
    6f88:	00 0c       	add	r0, r0
    6f8a:	11 f4       	brne	.+4      	; 0x6f90 <__fp_round+0xc>
    6f8c:	88 23       	and	r24, r24
    6f8e:	52 f0       	brmi	.+20     	; 0x6fa4 <__fp_round+0x20>
    6f90:	bb 0f       	add	r27, r27
    6f92:	40 f4       	brcc	.+16     	; 0x6fa4 <__fp_round+0x20>
    6f94:	bf 2b       	or	r27, r31
    6f96:	11 f4       	brne	.+4      	; 0x6f9c <__fp_round+0x18>
    6f98:	60 ff       	sbrs	r22, 0
    6f9a:	04 c0       	rjmp	.+8      	; 0x6fa4 <__fp_round+0x20>
    6f9c:	6f 5f       	subi	r22, 0xFF	; 255
    6f9e:	7f 4f       	sbci	r23, 0xFF	; 255
    6fa0:	8f 4f       	sbci	r24, 0xFF	; 255
    6fa2:	9f 4f       	sbci	r25, 0xFF	; 255
    6fa4:	08 95       	ret

00006fa6 <__fp_split3>:
    6fa6:	57 fd       	sbrc	r21, 7
    6fa8:	90 58       	subi	r25, 0x80	; 128
    6faa:	44 0f       	add	r20, r20
    6fac:	55 1f       	adc	r21, r21
    6fae:	59 f0       	breq	.+22     	; 0x6fc6 <__fp_splitA+0x10>
    6fb0:	5f 3f       	cpi	r21, 0xFF	; 255
    6fb2:	71 f0       	breq	.+28     	; 0x6fd0 <__fp_splitA+0x1a>
    6fb4:	47 95       	ror	r20

00006fb6 <__fp_splitA>:
    6fb6:	88 0f       	add	r24, r24
    6fb8:	97 fb       	bst	r25, 7
    6fba:	99 1f       	adc	r25, r25
    6fbc:	61 f0       	breq	.+24     	; 0x6fd6 <__fp_splitA+0x20>
    6fbe:	9f 3f       	cpi	r25, 0xFF	; 255
    6fc0:	79 f0       	breq	.+30     	; 0x6fe0 <__fp_splitA+0x2a>
    6fc2:	87 95       	ror	r24
    6fc4:	08 95       	ret
    6fc6:	12 16       	cp	r1, r18
    6fc8:	13 06       	cpc	r1, r19
    6fca:	14 06       	cpc	r1, r20
    6fcc:	55 1f       	adc	r21, r21
    6fce:	f2 cf       	rjmp	.-28     	; 0x6fb4 <__fp_split3+0xe>
    6fd0:	46 95       	lsr	r20
    6fd2:	f1 df       	rcall	.-30     	; 0x6fb6 <__fp_splitA>
    6fd4:	08 c0       	rjmp	.+16     	; 0x6fe6 <__fp_splitA+0x30>
    6fd6:	16 16       	cp	r1, r22
    6fd8:	17 06       	cpc	r1, r23
    6fda:	18 06       	cpc	r1, r24
    6fdc:	99 1f       	adc	r25, r25
    6fde:	f1 cf       	rjmp	.-30     	; 0x6fc2 <__fp_splitA+0xc>
    6fe0:	86 95       	lsr	r24
    6fe2:	71 05       	cpc	r23, r1
    6fe4:	61 05       	cpc	r22, r1
    6fe6:	08 94       	sec
    6fe8:	08 95       	ret

00006fea <__fp_zero>:
    6fea:	e8 94       	clt

00006fec <__fp_szero>:
    6fec:	bb 27       	eor	r27, r27
    6fee:	66 27       	eor	r22, r22
    6ff0:	77 27       	eor	r23, r23
    6ff2:	cb 01       	movw	r24, r22
    6ff4:	97 f9       	bld	r25, 7
    6ff6:	08 95       	ret

00006ff8 <__gesf2>:
    6ff8:	03 d0       	rcall	.+6      	; 0x7000 <__fp_cmp>
    6ffa:	08 f4       	brcc	.+2      	; 0x6ffe <__gesf2+0x6>
    6ffc:	8f ef       	ldi	r24, 0xFF	; 255
    6ffe:	08 95       	ret

00007000 <__fp_cmp>:
    7000:	99 0f       	add	r25, r25
    7002:	00 08       	sbc	r0, r0
    7004:	55 0f       	add	r21, r21
    7006:	aa 0b       	sbc	r26, r26
    7008:	e0 e8       	ldi	r30, 0x80	; 128
    700a:	fe ef       	ldi	r31, 0xFE	; 254
    700c:	16 16       	cp	r1, r22
    700e:	17 06       	cpc	r1, r23
    7010:	e8 07       	cpc	r30, r24
    7012:	f9 07       	cpc	r31, r25
    7014:	c0 f0       	brcs	.+48     	; 0x7046 <__fp_cmp+0x46>
    7016:	12 16       	cp	r1, r18
    7018:	13 06       	cpc	r1, r19
    701a:	e4 07       	cpc	r30, r20
    701c:	f5 07       	cpc	r31, r21
    701e:	98 f0       	brcs	.+38     	; 0x7046 <__fp_cmp+0x46>
    7020:	62 1b       	sub	r22, r18
    7022:	73 0b       	sbc	r23, r19
    7024:	84 0b       	sbc	r24, r20
    7026:	95 0b       	sbc	r25, r21
    7028:	39 f4       	brne	.+14     	; 0x7038 <__fp_cmp+0x38>
    702a:	0a 26       	eor	r0, r26
    702c:	61 f0       	breq	.+24     	; 0x7046 <__fp_cmp+0x46>
    702e:	23 2b       	or	r18, r19
    7030:	24 2b       	or	r18, r20
    7032:	25 2b       	or	r18, r21
    7034:	21 f4       	brne	.+8      	; 0x703e <__fp_cmp+0x3e>
    7036:	08 95       	ret
    7038:	0a 26       	eor	r0, r26
    703a:	09 f4       	brne	.+2      	; 0x703e <__fp_cmp+0x3e>
    703c:	a1 40       	sbci	r26, 0x01	; 1
    703e:	a6 95       	lsr	r26
    7040:	8f ef       	ldi	r24, 0xFF	; 255
    7042:	81 1d       	adc	r24, r1
    7044:	81 1d       	adc	r24, r1
    7046:	08 95       	ret

00007048 <__mulsi3>:
    7048:	62 9f       	mul	r22, r18
    704a:	d0 01       	movw	r26, r0
    704c:	73 9f       	mul	r23, r19
    704e:	f0 01       	movw	r30, r0
    7050:	82 9f       	mul	r24, r18
    7052:	e0 0d       	add	r30, r0
    7054:	f1 1d       	adc	r31, r1
    7056:	64 9f       	mul	r22, r20
    7058:	e0 0d       	add	r30, r0
    705a:	f1 1d       	adc	r31, r1
    705c:	92 9f       	mul	r25, r18
    705e:	f0 0d       	add	r31, r0
    7060:	83 9f       	mul	r24, r19
    7062:	f0 0d       	add	r31, r0
    7064:	74 9f       	mul	r23, r20
    7066:	f0 0d       	add	r31, r0
    7068:	65 9f       	mul	r22, r21
    706a:	f0 0d       	add	r31, r0
    706c:	99 27       	eor	r25, r25
    706e:	72 9f       	mul	r23, r18
    7070:	b0 0d       	add	r27, r0
    7072:	e1 1d       	adc	r30, r1
    7074:	f9 1f       	adc	r31, r25
    7076:	63 9f       	mul	r22, r19
    7078:	b0 0d       	add	r27, r0
    707a:	e1 1d       	adc	r30, r1
    707c:	f9 1f       	adc	r31, r25
    707e:	bd 01       	movw	r22, r26
    7080:	cf 01       	movw	r24, r30
    7082:	11 24       	eor	r1, r1
    7084:	08 95       	ret

00007086 <__divmodhi4>:
    7086:	97 fb       	bst	r25, 7
    7088:	09 2e       	mov	r0, r25
    708a:	07 26       	eor	r0, r23
    708c:	0a d0       	rcall	.+20     	; 0x70a2 <__divmodhi4_neg1>
    708e:	77 fd       	sbrc	r23, 7
    7090:	04 d0       	rcall	.+8      	; 0x709a <__divmodhi4_neg2>
    7092:	49 d0       	rcall	.+146    	; 0x7126 <__udivmodhi4>
    7094:	06 d0       	rcall	.+12     	; 0x70a2 <__divmodhi4_neg1>
    7096:	00 20       	and	r0, r0
    7098:	1a f4       	brpl	.+6      	; 0x70a0 <__divmodhi4_exit>

0000709a <__divmodhi4_neg2>:
    709a:	70 95       	com	r23
    709c:	61 95       	neg	r22
    709e:	7f 4f       	sbci	r23, 0xFF	; 255

000070a0 <__divmodhi4_exit>:
    70a0:	08 95       	ret

000070a2 <__divmodhi4_neg1>:
    70a2:	f6 f7       	brtc	.-4      	; 0x70a0 <__divmodhi4_exit>
    70a4:	90 95       	com	r25
    70a6:	81 95       	neg	r24
    70a8:	9f 4f       	sbci	r25, 0xFF	; 255
    70aa:	08 95       	ret

000070ac <__udivmodsi4>:
    70ac:	a1 e2       	ldi	r26, 0x21	; 33
    70ae:	1a 2e       	mov	r1, r26
    70b0:	aa 1b       	sub	r26, r26
    70b2:	bb 1b       	sub	r27, r27
    70b4:	fd 01       	movw	r30, r26
    70b6:	0d c0       	rjmp	.+26     	; 0x70d2 <__udivmodsi4_ep>

000070b8 <__udivmodsi4_loop>:
    70b8:	aa 1f       	adc	r26, r26
    70ba:	bb 1f       	adc	r27, r27
    70bc:	ee 1f       	adc	r30, r30
    70be:	ff 1f       	adc	r31, r31
    70c0:	a2 17       	cp	r26, r18
    70c2:	b3 07       	cpc	r27, r19
    70c4:	e4 07       	cpc	r30, r20
    70c6:	f5 07       	cpc	r31, r21
    70c8:	20 f0       	brcs	.+8      	; 0x70d2 <__udivmodsi4_ep>
    70ca:	a2 1b       	sub	r26, r18
    70cc:	b3 0b       	sbc	r27, r19
    70ce:	e4 0b       	sbc	r30, r20
    70d0:	f5 0b       	sbc	r31, r21

000070d2 <__udivmodsi4_ep>:
    70d2:	66 1f       	adc	r22, r22
    70d4:	77 1f       	adc	r23, r23
    70d6:	88 1f       	adc	r24, r24
    70d8:	99 1f       	adc	r25, r25
    70da:	1a 94       	dec	r1
    70dc:	69 f7       	brne	.-38     	; 0x70b8 <__udivmodsi4_loop>
    70de:	60 95       	com	r22
    70e0:	70 95       	com	r23
    70e2:	80 95       	com	r24
    70e4:	90 95       	com	r25
    70e6:	9b 01       	movw	r18, r22
    70e8:	ac 01       	movw	r20, r24
    70ea:	bd 01       	movw	r22, r26
    70ec:	cf 01       	movw	r24, r30
    70ee:	08 95       	ret

000070f0 <__divmodsi4>:
    70f0:	97 fb       	bst	r25, 7
    70f2:	09 2e       	mov	r0, r25
    70f4:	05 26       	eor	r0, r21
    70f6:	0e d0       	rcall	.+28     	; 0x7114 <__divmodsi4_neg1>
    70f8:	57 fd       	sbrc	r21, 7
    70fa:	04 d0       	rcall	.+8      	; 0x7104 <__divmodsi4_neg2>
    70fc:	d7 df       	rcall	.-82     	; 0x70ac <__udivmodsi4>
    70fe:	0a d0       	rcall	.+20     	; 0x7114 <__divmodsi4_neg1>
    7100:	00 1c       	adc	r0, r0
    7102:	38 f4       	brcc	.+14     	; 0x7112 <__divmodsi4_exit>

00007104 <__divmodsi4_neg2>:
    7104:	50 95       	com	r21
    7106:	40 95       	com	r20
    7108:	30 95       	com	r19
    710a:	21 95       	neg	r18
    710c:	3f 4f       	sbci	r19, 0xFF	; 255
    710e:	4f 4f       	sbci	r20, 0xFF	; 255
    7110:	5f 4f       	sbci	r21, 0xFF	; 255

00007112 <__divmodsi4_exit>:
    7112:	08 95       	ret

00007114 <__divmodsi4_neg1>:
    7114:	f6 f7       	brtc	.-4      	; 0x7112 <__divmodsi4_exit>
    7116:	90 95       	com	r25
    7118:	80 95       	com	r24
    711a:	70 95       	com	r23
    711c:	61 95       	neg	r22
    711e:	7f 4f       	sbci	r23, 0xFF	; 255
    7120:	8f 4f       	sbci	r24, 0xFF	; 255
    7122:	9f 4f       	sbci	r25, 0xFF	; 255
    7124:	08 95       	ret

00007126 <__udivmodhi4>:
    7126:	aa 1b       	sub	r26, r26
    7128:	bb 1b       	sub	r27, r27
    712a:	51 e1       	ldi	r21, 0x11	; 17
    712c:	07 c0       	rjmp	.+14     	; 0x713c <__udivmodhi4_ep>

0000712e <__udivmodhi4_loop>:
    712e:	aa 1f       	adc	r26, r26
    7130:	bb 1f       	adc	r27, r27
    7132:	a6 17       	cp	r26, r22
    7134:	b7 07       	cpc	r27, r23
    7136:	10 f0       	brcs	.+4      	; 0x713c <__udivmodhi4_ep>
    7138:	a6 1b       	sub	r26, r22
    713a:	b7 0b       	sbc	r27, r23

0000713c <__udivmodhi4_ep>:
    713c:	88 1f       	adc	r24, r24
    713e:	99 1f       	adc	r25, r25
    7140:	5a 95       	dec	r21
    7142:	a9 f7       	brne	.-22     	; 0x712e <__udivmodhi4_loop>
    7144:	80 95       	com	r24
    7146:	90 95       	com	r25
    7148:	bc 01       	movw	r22, r24
    714a:	cd 01       	movw	r24, r26
    714c:	08 95       	ret

0000714e <__prologue_saves__>:
    714e:	2f 92       	push	r2
    7150:	3f 92       	push	r3
    7152:	4f 92       	push	r4
    7154:	5f 92       	push	r5
    7156:	6f 92       	push	r6
    7158:	7f 92       	push	r7
    715a:	8f 92       	push	r8
    715c:	9f 92       	push	r9
    715e:	af 92       	push	r10
    7160:	bf 92       	push	r11
    7162:	cf 92       	push	r12
    7164:	df 92       	push	r13
    7166:	ef 92       	push	r14
    7168:	ff 92       	push	r15
    716a:	0f 93       	push	r16
    716c:	1f 93       	push	r17
    716e:	cf 93       	push	r28
    7170:	df 93       	push	r29
    7172:	cd b7       	in	r28, 0x3d	; 61
    7174:	de b7       	in	r29, 0x3e	; 62
    7176:	ca 1b       	sub	r28, r26
    7178:	db 0b       	sbc	r29, r27
    717a:	cd bf       	out	0x3d, r28	; 61
    717c:	de bf       	out	0x3e, r29	; 62
    717e:	19 94       	eijmp

00007180 <__epilogue_restores__>:
    7180:	2a 88       	ldd	r2, Y+18	; 0x12
    7182:	39 88       	ldd	r3, Y+17	; 0x11
    7184:	48 88       	ldd	r4, Y+16	; 0x10
    7186:	5f 84       	ldd	r5, Y+15	; 0x0f
    7188:	6e 84       	ldd	r6, Y+14	; 0x0e
    718a:	7d 84       	ldd	r7, Y+13	; 0x0d
    718c:	8c 84       	ldd	r8, Y+12	; 0x0c
    718e:	9b 84       	ldd	r9, Y+11	; 0x0b
    7190:	aa 84       	ldd	r10, Y+10	; 0x0a
    7192:	b9 84       	ldd	r11, Y+9	; 0x09
    7194:	c8 84       	ldd	r12, Y+8	; 0x08
    7196:	df 80       	ldd	r13, Y+7	; 0x07
    7198:	ee 80       	ldd	r14, Y+6	; 0x06
    719a:	fd 80       	ldd	r15, Y+5	; 0x05
    719c:	0c 81       	ldd	r16, Y+4	; 0x04
    719e:	1b 81       	ldd	r17, Y+3	; 0x03
    71a0:	aa 81       	ldd	r26, Y+2	; 0x02
    71a2:	b9 81       	ldd	r27, Y+1	; 0x01
    71a4:	ce 0f       	add	r28, r30
    71a6:	d1 1d       	adc	r29, r1
    71a8:	cd bf       	out	0x3d, r28	; 61
    71aa:	de bf       	out	0x3e, r29	; 62
    71ac:	ed 01       	movw	r28, r26
    71ae:	08 95       	ret

000071b0 <strcpy_P>:
    71b0:	fb 01       	movw	r30, r22
    71b2:	dc 01       	movw	r26, r24
    71b4:	05 90       	lpm	r0, Z+
    71b6:	0d 92       	st	X+, r0
    71b8:	00 20       	and	r0, r0
    71ba:	e1 f7       	brne	.-8      	; 0x71b4 <strcpy_P+0x4>
    71bc:	08 95       	ret

000071be <memmove>:
    71be:	68 17       	cp	r22, r24
    71c0:	79 07       	cpc	r23, r25
    71c2:	68 f4       	brcc	.+26     	; 0x71de <memmove+0x20>
    71c4:	fb 01       	movw	r30, r22
    71c6:	dc 01       	movw	r26, r24
    71c8:	e4 0f       	add	r30, r20
    71ca:	f5 1f       	adc	r31, r21
    71cc:	a4 0f       	add	r26, r20
    71ce:	b5 1f       	adc	r27, r21
    71d0:	02 c0       	rjmp	.+4      	; 0x71d6 <memmove+0x18>
    71d2:	02 90       	ld	r0, -Z
    71d4:	0e 92       	st	-X, r0
    71d6:	41 50       	subi	r20, 0x01	; 1
    71d8:	50 40       	sbci	r21, 0x00	; 0
    71da:	d8 f7       	brcc	.-10     	; 0x71d2 <memmove+0x14>
    71dc:	08 95       	ret
    71de:	0c 94 64 3b 	jmp	0x76c8	; 0x76c8 <memcpy>

000071e2 <strcat>:
    71e2:	fb 01       	movw	r30, r22
    71e4:	dc 01       	movw	r26, r24
    71e6:	0d 90       	ld	r0, X+
    71e8:	00 20       	and	r0, r0
    71ea:	e9 f7       	brne	.-6      	; 0x71e6 <strcat+0x4>
    71ec:	11 97       	sbiw	r26, 0x01	; 1
    71ee:	01 90       	ld	r0, Z+
    71f0:	0d 92       	st	X+, r0
    71f2:	00 20       	and	r0, r0
    71f4:	e1 f7       	brne	.-8      	; 0x71ee <strcat+0xc>
    71f6:	08 95       	ret

000071f8 <itoa>:
    71f8:	fb 01       	movw	r30, r22
    71fa:	9f 01       	movw	r18, r30
    71fc:	e8 94       	clt
    71fe:	42 30       	cpi	r20, 0x02	; 2
    7200:	c4 f0       	brlt	.+48     	; 0x7232 <itoa+0x3a>
    7202:	45 32       	cpi	r20, 0x25	; 37
    7204:	b4 f4       	brge	.+44     	; 0x7232 <itoa+0x3a>
    7206:	4a 30       	cpi	r20, 0x0A	; 10
    7208:	29 f4       	brne	.+10     	; 0x7214 <itoa+0x1c>
    720a:	97 fb       	bst	r25, 7
    720c:	1e f4       	brtc	.+6      	; 0x7214 <itoa+0x1c>
    720e:	90 95       	com	r25
    7210:	81 95       	neg	r24
    7212:	9f 4f       	sbci	r25, 0xFF	; 255
    7214:	64 2f       	mov	r22, r20
    7216:	77 27       	eor	r23, r23
    7218:	0e 94 93 38 	call	0x7126	; 0x7126 <__udivmodhi4>
    721c:	80 5d       	subi	r24, 0xD0	; 208
    721e:	8a 33       	cpi	r24, 0x3A	; 58
    7220:	0c f0       	brlt	.+2      	; 0x7224 <itoa+0x2c>
    7222:	89 5d       	subi	r24, 0xD9	; 217
    7224:	81 93       	st	Z+, r24
    7226:	cb 01       	movw	r24, r22
    7228:	00 97       	sbiw	r24, 0x00	; 0
    722a:	a1 f7       	brne	.-24     	; 0x7214 <itoa+0x1c>
    722c:	16 f4       	brtc	.+4      	; 0x7232 <itoa+0x3a>
    722e:	5d e2       	ldi	r21, 0x2D	; 45
    7230:	51 93       	st	Z+, r21
    7232:	10 82       	st	Z, r1
    7234:	c9 01       	movw	r24, r18
    7236:	0c 94 78 3b 	jmp	0x76f0	; 0x76f0 <strrev>

0000723a <printf>:
    723a:	cf 93       	push	r28
    723c:	df 93       	push	r29
    723e:	cd b7       	in	r28, 0x3d	; 61
    7240:	de b7       	in	r29, 0x3e	; 62
    7242:	fe 01       	movw	r30, r28
    7244:	36 96       	adiw	r30, 0x06	; 6
    7246:	61 91       	ld	r22, Z+
    7248:	71 91       	ld	r23, Z+
    724a:	80 91 b8 50 	lds	r24, 0x50B8
    724e:	90 91 b9 50 	lds	r25, 0x50B9
    7252:	af 01       	movw	r20, r30
    7254:	0e 94 58 39 	call	0x72b0	; 0x72b0 <vfprintf>
    7258:	df 91       	pop	r29
    725a:	cf 91       	pop	r28
    725c:	08 95       	ret

0000725e <sprintf>:
    725e:	0f 93       	push	r16
    7260:	1f 93       	push	r17
    7262:	cf 93       	push	r28
    7264:	df 93       	push	r29
    7266:	cd b7       	in	r28, 0x3d	; 61
    7268:	de b7       	in	r29, 0x3e	; 62
    726a:	2e 97       	sbiw	r28, 0x0e	; 14
    726c:	cd bf       	out	0x3d, r28	; 61
    726e:	de bf       	out	0x3e, r29	; 62
    7270:	0e 89       	ldd	r16, Y+22	; 0x16
    7272:	1f 89       	ldd	r17, Y+23	; 0x17
    7274:	86 e0       	ldi	r24, 0x06	; 6
    7276:	8c 83       	std	Y+4, r24	; 0x04
    7278:	09 83       	std	Y+1, r16	; 0x01
    727a:	1a 83       	std	Y+2, r17	; 0x02
    727c:	8f ef       	ldi	r24, 0xFF	; 255
    727e:	9f e7       	ldi	r25, 0x7F	; 127
    7280:	8d 83       	std	Y+5, r24	; 0x05
    7282:	9e 83       	std	Y+6, r25	; 0x06
    7284:	ae 01       	movw	r20, r28
    7286:	46 5e       	subi	r20, 0xE6	; 230
    7288:	5f 4f       	sbci	r21, 0xFF	; 255
    728a:	ce 01       	movw	r24, r28
    728c:	01 96       	adiw	r24, 0x01	; 1
    728e:	68 8d       	ldd	r22, Y+24	; 0x18
    7290:	79 8d       	ldd	r23, Y+25	; 0x19
    7292:	0e 94 58 39 	call	0x72b0	; 0x72b0 <vfprintf>
    7296:	ef 81       	ldd	r30, Y+7	; 0x07
    7298:	f8 85       	ldd	r31, Y+8	; 0x08
    729a:	e0 0f       	add	r30, r16
    729c:	f1 1f       	adc	r31, r17
    729e:	10 82       	st	Z, r1
    72a0:	2e 96       	adiw	r28, 0x0e	; 14
    72a2:	cd bf       	out	0x3d, r28	; 61
    72a4:	de bf       	out	0x3e, r29	; 62
    72a6:	df 91       	pop	r29
    72a8:	cf 91       	pop	r28
    72aa:	1f 91       	pop	r17
    72ac:	0f 91       	pop	r16
    72ae:	08 95       	ret

000072b0 <vfprintf>:
    72b0:	2f 92       	push	r2
    72b2:	3f 92       	push	r3
    72b4:	4f 92       	push	r4
    72b6:	5f 92       	push	r5
    72b8:	6f 92       	push	r6
    72ba:	7f 92       	push	r7
    72bc:	8f 92       	push	r8
    72be:	9f 92       	push	r9
    72c0:	af 92       	push	r10
    72c2:	bf 92       	push	r11
    72c4:	cf 92       	push	r12
    72c6:	df 92       	push	r13
    72c8:	ef 92       	push	r14
    72ca:	ff 92       	push	r15
    72cc:	0f 93       	push	r16
    72ce:	1f 93       	push	r17
    72d0:	cf 93       	push	r28
    72d2:	df 93       	push	r29
    72d4:	cd b7       	in	r28, 0x3d	; 61
    72d6:	de b7       	in	r29, 0x3e	; 62
    72d8:	2d 97       	sbiw	r28, 0x0d	; 13
    72da:	cd bf       	out	0x3d, r28	; 61
    72dc:	de bf       	out	0x3e, r29	; 62
    72de:	3c 01       	movw	r6, r24
    72e0:	6c 87       	std	Y+12, r22	; 0x0c
    72e2:	7d 87       	std	Y+13, r23	; 0x0d
    72e4:	5a 01       	movw	r10, r20
    72e6:	fc 01       	movw	r30, r24
    72e8:	16 82       	std	Z+6, r1	; 0x06
    72ea:	17 82       	std	Z+7, r1	; 0x07
    72ec:	83 81       	ldd	r24, Z+3	; 0x03
    72ee:	81 ff       	sbrs	r24, 1
    72f0:	c8 c1       	rjmp	.+912    	; 0x7682 <vfprintf+0x3d2>
    72f2:	2e 01       	movw	r4, r28
    72f4:	08 94       	sec
    72f6:	41 1c       	adc	r4, r1
    72f8:	51 1c       	adc	r5, r1
    72fa:	f3 01       	movw	r30, r6
    72fc:	93 81       	ldd	r25, Z+3	; 0x03
    72fe:	ec 85       	ldd	r30, Y+12	; 0x0c
    7300:	fd 85       	ldd	r31, Y+13	; 0x0d
    7302:	93 fd       	sbrc	r25, 3
    7304:	85 91       	lpm	r24, Z+
    7306:	93 ff       	sbrs	r25, 3
    7308:	81 91       	ld	r24, Z+
    730a:	ec 87       	std	Y+12, r30	; 0x0c
    730c:	fd 87       	std	Y+13, r31	; 0x0d
    730e:	88 23       	and	r24, r24
    7310:	09 f4       	brne	.+2      	; 0x7314 <vfprintf+0x64>
    7312:	b3 c1       	rjmp	.+870    	; 0x767a <vfprintf+0x3ca>
    7314:	85 32       	cpi	r24, 0x25	; 37
    7316:	41 f4       	brne	.+16     	; 0x7328 <vfprintf+0x78>
    7318:	93 fd       	sbrc	r25, 3
    731a:	85 91       	lpm	r24, Z+
    731c:	93 ff       	sbrs	r25, 3
    731e:	81 91       	ld	r24, Z+
    7320:	ec 87       	std	Y+12, r30	; 0x0c
    7322:	fd 87       	std	Y+13, r31	; 0x0d
    7324:	85 32       	cpi	r24, 0x25	; 37
    7326:	29 f4       	brne	.+10     	; 0x7332 <vfprintf+0x82>
    7328:	90 e0       	ldi	r25, 0x00	; 0
    732a:	b3 01       	movw	r22, r6
    732c:	0e 94 88 3b 	call	0x7710	; 0x7710 <fputc>
    7330:	e4 cf       	rjmp	.-56     	; 0x72fa <vfprintf+0x4a>
    7332:	ff 24       	eor	r15, r15
    7334:	ee 24       	eor	r14, r14
    7336:	10 e0       	ldi	r17, 0x00	; 0
    7338:	10 32       	cpi	r17, 0x20	; 32
    733a:	b0 f4       	brcc	.+44     	; 0x7368 <vfprintf+0xb8>
    733c:	8b 32       	cpi	r24, 0x2B	; 43
    733e:	69 f0       	breq	.+26     	; 0x735a <vfprintf+0xaa>
    7340:	8c 32       	cpi	r24, 0x2C	; 44
    7342:	28 f4       	brcc	.+10     	; 0x734e <vfprintf+0x9e>
    7344:	80 32       	cpi	r24, 0x20	; 32
    7346:	51 f0       	breq	.+20     	; 0x735c <vfprintf+0xac>
    7348:	83 32       	cpi	r24, 0x23	; 35
    734a:	71 f4       	brne	.+28     	; 0x7368 <vfprintf+0xb8>
    734c:	0b c0       	rjmp	.+22     	; 0x7364 <vfprintf+0xb4>
    734e:	8d 32       	cpi	r24, 0x2D	; 45
    7350:	39 f0       	breq	.+14     	; 0x7360 <vfprintf+0xb0>
    7352:	80 33       	cpi	r24, 0x30	; 48
    7354:	49 f4       	brne	.+18     	; 0x7368 <vfprintf+0xb8>
    7356:	11 60       	ori	r17, 0x01	; 1
    7358:	2c c0       	rjmp	.+88     	; 0x73b2 <vfprintf+0x102>
    735a:	12 60       	ori	r17, 0x02	; 2
    735c:	14 60       	ori	r17, 0x04	; 4
    735e:	29 c0       	rjmp	.+82     	; 0x73b2 <vfprintf+0x102>
    7360:	18 60       	ori	r17, 0x08	; 8
    7362:	27 c0       	rjmp	.+78     	; 0x73b2 <vfprintf+0x102>
    7364:	10 61       	ori	r17, 0x10	; 16
    7366:	25 c0       	rjmp	.+74     	; 0x73b2 <vfprintf+0x102>
    7368:	17 fd       	sbrc	r17, 7
    736a:	2e c0       	rjmp	.+92     	; 0x73c8 <vfprintf+0x118>
    736c:	28 2f       	mov	r18, r24
    736e:	20 53       	subi	r18, 0x30	; 48
    7370:	2a 30       	cpi	r18, 0x0A	; 10
    7372:	98 f4       	brcc	.+38     	; 0x739a <vfprintf+0xea>
    7374:	16 ff       	sbrs	r17, 6
    7376:	08 c0       	rjmp	.+16     	; 0x7388 <vfprintf+0xd8>
    7378:	8f 2d       	mov	r24, r15
    737a:	88 0f       	add	r24, r24
    737c:	f8 2e       	mov	r15, r24
    737e:	ff 0c       	add	r15, r15
    7380:	ff 0c       	add	r15, r15
    7382:	f8 0e       	add	r15, r24
    7384:	f2 0e       	add	r15, r18
    7386:	15 c0       	rjmp	.+42     	; 0x73b2 <vfprintf+0x102>
    7388:	8e 2d       	mov	r24, r14
    738a:	88 0f       	add	r24, r24
    738c:	e8 2e       	mov	r14, r24
    738e:	ee 0c       	add	r14, r14
    7390:	ee 0c       	add	r14, r14
    7392:	e8 0e       	add	r14, r24
    7394:	e2 0e       	add	r14, r18
    7396:	10 62       	ori	r17, 0x20	; 32
    7398:	0c c0       	rjmp	.+24     	; 0x73b2 <vfprintf+0x102>
    739a:	8e 32       	cpi	r24, 0x2E	; 46
    739c:	21 f4       	brne	.+8      	; 0x73a6 <vfprintf+0xf6>
    739e:	16 fd       	sbrc	r17, 6
    73a0:	6c c1       	rjmp	.+728    	; 0x767a <vfprintf+0x3ca>
    73a2:	10 64       	ori	r17, 0x40	; 64
    73a4:	06 c0       	rjmp	.+12     	; 0x73b2 <vfprintf+0x102>
    73a6:	8c 36       	cpi	r24, 0x6C	; 108
    73a8:	11 f4       	brne	.+4      	; 0x73ae <vfprintf+0xfe>
    73aa:	10 68       	ori	r17, 0x80	; 128
    73ac:	02 c0       	rjmp	.+4      	; 0x73b2 <vfprintf+0x102>
    73ae:	88 36       	cpi	r24, 0x68	; 104
    73b0:	59 f4       	brne	.+22     	; 0x73c8 <vfprintf+0x118>
    73b2:	ec 85       	ldd	r30, Y+12	; 0x0c
    73b4:	fd 85       	ldd	r31, Y+13	; 0x0d
    73b6:	93 fd       	sbrc	r25, 3
    73b8:	85 91       	lpm	r24, Z+
    73ba:	93 ff       	sbrs	r25, 3
    73bc:	81 91       	ld	r24, Z+
    73be:	ec 87       	std	Y+12, r30	; 0x0c
    73c0:	fd 87       	std	Y+13, r31	; 0x0d
    73c2:	88 23       	and	r24, r24
    73c4:	09 f0       	breq	.+2      	; 0x73c8 <vfprintf+0x118>
    73c6:	b8 cf       	rjmp	.-144    	; 0x7338 <vfprintf+0x88>
    73c8:	98 2f       	mov	r25, r24
    73ca:	95 54       	subi	r25, 0x45	; 69
    73cc:	93 30       	cpi	r25, 0x03	; 3
    73ce:	18 f0       	brcs	.+6      	; 0x73d6 <vfprintf+0x126>
    73d0:	90 52       	subi	r25, 0x20	; 32
    73d2:	93 30       	cpi	r25, 0x03	; 3
    73d4:	38 f4       	brcc	.+14     	; 0x73e4 <vfprintf+0x134>
    73d6:	24 e0       	ldi	r18, 0x04	; 4
    73d8:	30 e0       	ldi	r19, 0x00	; 0
    73da:	a2 0e       	add	r10, r18
    73dc:	b3 1e       	adc	r11, r19
    73de:	3f e3       	ldi	r19, 0x3F	; 63
    73e0:	39 83       	std	Y+1, r19	; 0x01
    73e2:	0f c0       	rjmp	.+30     	; 0x7402 <vfprintf+0x152>
    73e4:	83 36       	cpi	r24, 0x63	; 99
    73e6:	31 f0       	breq	.+12     	; 0x73f4 <vfprintf+0x144>
    73e8:	83 37       	cpi	r24, 0x73	; 115
    73ea:	81 f0       	breq	.+32     	; 0x740c <vfprintf+0x15c>
    73ec:	83 35       	cpi	r24, 0x53	; 83
    73ee:	09 f0       	breq	.+2      	; 0x73f2 <vfprintf+0x142>
    73f0:	5a c0       	rjmp	.+180    	; 0x74a6 <vfprintf+0x1f6>
    73f2:	22 c0       	rjmp	.+68     	; 0x7438 <vfprintf+0x188>
    73f4:	f5 01       	movw	r30, r10
    73f6:	80 81       	ld	r24, Z
    73f8:	89 83       	std	Y+1, r24	; 0x01
    73fa:	22 e0       	ldi	r18, 0x02	; 2
    73fc:	30 e0       	ldi	r19, 0x00	; 0
    73fe:	a2 0e       	add	r10, r18
    7400:	b3 1e       	adc	r11, r19
    7402:	21 e0       	ldi	r18, 0x01	; 1
    7404:	c2 2e       	mov	r12, r18
    7406:	d1 2c       	mov	r13, r1
    7408:	42 01       	movw	r8, r4
    740a:	14 c0       	rjmp	.+40     	; 0x7434 <vfprintf+0x184>
    740c:	92 e0       	ldi	r25, 0x02	; 2
    740e:	29 2e       	mov	r2, r25
    7410:	31 2c       	mov	r3, r1
    7412:	2a 0c       	add	r2, r10
    7414:	3b 1c       	adc	r3, r11
    7416:	f5 01       	movw	r30, r10
    7418:	80 80       	ld	r8, Z
    741a:	91 80       	ldd	r9, Z+1	; 0x01
    741c:	16 ff       	sbrs	r17, 6
    741e:	03 c0       	rjmp	.+6      	; 0x7426 <vfprintf+0x176>
    7420:	6f 2d       	mov	r22, r15
    7422:	70 e0       	ldi	r23, 0x00	; 0
    7424:	02 c0       	rjmp	.+4      	; 0x742a <vfprintf+0x17a>
    7426:	6f ef       	ldi	r22, 0xFF	; 255
    7428:	7f ef       	ldi	r23, 0xFF	; 255
    742a:	c4 01       	movw	r24, r8
    742c:	0e 94 6d 3b 	call	0x76da	; 0x76da <strnlen>
    7430:	6c 01       	movw	r12, r24
    7432:	51 01       	movw	r10, r2
    7434:	1f 77       	andi	r17, 0x7F	; 127
    7436:	15 c0       	rjmp	.+42     	; 0x7462 <vfprintf+0x1b2>
    7438:	82 e0       	ldi	r24, 0x02	; 2
    743a:	28 2e       	mov	r2, r24
    743c:	31 2c       	mov	r3, r1
    743e:	2a 0c       	add	r2, r10
    7440:	3b 1c       	adc	r3, r11
    7442:	f5 01       	movw	r30, r10
    7444:	80 80       	ld	r8, Z
    7446:	91 80       	ldd	r9, Z+1	; 0x01
    7448:	16 ff       	sbrs	r17, 6
    744a:	03 c0       	rjmp	.+6      	; 0x7452 <vfprintf+0x1a2>
    744c:	6f 2d       	mov	r22, r15
    744e:	70 e0       	ldi	r23, 0x00	; 0
    7450:	02 c0       	rjmp	.+4      	; 0x7456 <vfprintf+0x1a6>
    7452:	6f ef       	ldi	r22, 0xFF	; 255
    7454:	7f ef       	ldi	r23, 0xFF	; 255
    7456:	c4 01       	movw	r24, r8
    7458:	0e 94 59 3b 	call	0x76b2	; 0x76b2 <strnlen_P>
    745c:	6c 01       	movw	r12, r24
    745e:	10 68       	ori	r17, 0x80	; 128
    7460:	51 01       	movw	r10, r2
    7462:	13 fd       	sbrc	r17, 3
    7464:	1c c0       	rjmp	.+56     	; 0x749e <vfprintf+0x1ee>
    7466:	06 c0       	rjmp	.+12     	; 0x7474 <vfprintf+0x1c4>
    7468:	80 e2       	ldi	r24, 0x20	; 32
    746a:	90 e0       	ldi	r25, 0x00	; 0
    746c:	b3 01       	movw	r22, r6
    746e:	0e 94 88 3b 	call	0x7710	; 0x7710 <fputc>
    7472:	ea 94       	dec	r14
    7474:	8e 2d       	mov	r24, r14
    7476:	90 e0       	ldi	r25, 0x00	; 0
    7478:	c8 16       	cp	r12, r24
    747a:	d9 06       	cpc	r13, r25
    747c:	a8 f3       	brcs	.-22     	; 0x7468 <vfprintf+0x1b8>
    747e:	0f c0       	rjmp	.+30     	; 0x749e <vfprintf+0x1ee>
    7480:	f4 01       	movw	r30, r8
    7482:	17 fd       	sbrc	r17, 7
    7484:	85 91       	lpm	r24, Z+
    7486:	17 ff       	sbrs	r17, 7
    7488:	81 91       	ld	r24, Z+
    748a:	4f 01       	movw	r8, r30
    748c:	90 e0       	ldi	r25, 0x00	; 0
    748e:	b3 01       	movw	r22, r6
    7490:	0e 94 88 3b 	call	0x7710	; 0x7710 <fputc>
    7494:	e1 10       	cpse	r14, r1
    7496:	ea 94       	dec	r14
    7498:	08 94       	sec
    749a:	c1 08       	sbc	r12, r1
    749c:	d1 08       	sbc	r13, r1
    749e:	c1 14       	cp	r12, r1
    74a0:	d1 04       	cpc	r13, r1
    74a2:	71 f7       	brne	.-36     	; 0x7480 <vfprintf+0x1d0>
    74a4:	e7 c0       	rjmp	.+462    	; 0x7674 <vfprintf+0x3c4>
    74a6:	84 36       	cpi	r24, 0x64	; 100
    74a8:	11 f0       	breq	.+4      	; 0x74ae <vfprintf+0x1fe>
    74aa:	89 36       	cpi	r24, 0x69	; 105
    74ac:	51 f5       	brne	.+84     	; 0x7502 <vfprintf+0x252>
    74ae:	f5 01       	movw	r30, r10
    74b0:	17 ff       	sbrs	r17, 7
    74b2:	07 c0       	rjmp	.+14     	; 0x74c2 <vfprintf+0x212>
    74b4:	80 81       	ld	r24, Z
    74b6:	91 81       	ldd	r25, Z+1	; 0x01
    74b8:	a2 81       	ldd	r26, Z+2	; 0x02
    74ba:	b3 81       	ldd	r27, Z+3	; 0x03
    74bc:	24 e0       	ldi	r18, 0x04	; 4
    74be:	30 e0       	ldi	r19, 0x00	; 0
    74c0:	08 c0       	rjmp	.+16     	; 0x74d2 <vfprintf+0x222>
    74c2:	80 81       	ld	r24, Z
    74c4:	91 81       	ldd	r25, Z+1	; 0x01
    74c6:	aa 27       	eor	r26, r26
    74c8:	97 fd       	sbrc	r25, 7
    74ca:	a0 95       	com	r26
    74cc:	ba 2f       	mov	r27, r26
    74ce:	22 e0       	ldi	r18, 0x02	; 2
    74d0:	30 e0       	ldi	r19, 0x00	; 0
    74d2:	a2 0e       	add	r10, r18
    74d4:	b3 1e       	adc	r11, r19
    74d6:	01 2f       	mov	r16, r17
    74d8:	0f 76       	andi	r16, 0x6F	; 111
    74da:	b7 ff       	sbrs	r27, 7
    74dc:	08 c0       	rjmp	.+16     	; 0x74ee <vfprintf+0x23e>
    74de:	b0 95       	com	r27
    74e0:	a0 95       	com	r26
    74e2:	90 95       	com	r25
    74e4:	81 95       	neg	r24
    74e6:	9f 4f       	sbci	r25, 0xFF	; 255
    74e8:	af 4f       	sbci	r26, 0xFF	; 255
    74ea:	bf 4f       	sbci	r27, 0xFF	; 255
    74ec:	00 68       	ori	r16, 0x80	; 128
    74ee:	bc 01       	movw	r22, r24
    74f0:	cd 01       	movw	r24, r26
    74f2:	a2 01       	movw	r20, r4
    74f4:	2a e0       	ldi	r18, 0x0A	; 10
    74f6:	30 e0       	ldi	r19, 0x00	; 0
    74f8:	0e 94 b4 3b 	call	0x7768	; 0x7768 <__ultoa_invert>
    74fc:	d8 2e       	mov	r13, r24
    74fe:	d4 18       	sub	r13, r4
    7500:	3f c0       	rjmp	.+126    	; 0x7580 <vfprintf+0x2d0>
    7502:	85 37       	cpi	r24, 0x75	; 117
    7504:	21 f4       	brne	.+8      	; 0x750e <vfprintf+0x25e>
    7506:	1f 7e       	andi	r17, 0xEF	; 239
    7508:	2a e0       	ldi	r18, 0x0A	; 10
    750a:	30 e0       	ldi	r19, 0x00	; 0
    750c:	20 c0       	rjmp	.+64     	; 0x754e <vfprintf+0x29e>
    750e:	19 7f       	andi	r17, 0xF9	; 249
    7510:	8f 36       	cpi	r24, 0x6F	; 111
    7512:	a9 f0       	breq	.+42     	; 0x753e <vfprintf+0x28e>
    7514:	80 37       	cpi	r24, 0x70	; 112
    7516:	20 f4       	brcc	.+8      	; 0x7520 <vfprintf+0x270>
    7518:	88 35       	cpi	r24, 0x58	; 88
    751a:	09 f0       	breq	.+2      	; 0x751e <vfprintf+0x26e>
    751c:	ae c0       	rjmp	.+348    	; 0x767a <vfprintf+0x3ca>
    751e:	0b c0       	rjmp	.+22     	; 0x7536 <vfprintf+0x286>
    7520:	80 37       	cpi	r24, 0x70	; 112
    7522:	21 f0       	breq	.+8      	; 0x752c <vfprintf+0x27c>
    7524:	88 37       	cpi	r24, 0x78	; 120
    7526:	09 f0       	breq	.+2      	; 0x752a <vfprintf+0x27a>
    7528:	a8 c0       	rjmp	.+336    	; 0x767a <vfprintf+0x3ca>
    752a:	01 c0       	rjmp	.+2      	; 0x752e <vfprintf+0x27e>
    752c:	10 61       	ori	r17, 0x10	; 16
    752e:	14 ff       	sbrs	r17, 4
    7530:	09 c0       	rjmp	.+18     	; 0x7544 <vfprintf+0x294>
    7532:	14 60       	ori	r17, 0x04	; 4
    7534:	07 c0       	rjmp	.+14     	; 0x7544 <vfprintf+0x294>
    7536:	14 ff       	sbrs	r17, 4
    7538:	08 c0       	rjmp	.+16     	; 0x754a <vfprintf+0x29a>
    753a:	16 60       	ori	r17, 0x06	; 6
    753c:	06 c0       	rjmp	.+12     	; 0x754a <vfprintf+0x29a>
    753e:	28 e0       	ldi	r18, 0x08	; 8
    7540:	30 e0       	ldi	r19, 0x00	; 0
    7542:	05 c0       	rjmp	.+10     	; 0x754e <vfprintf+0x29e>
    7544:	20 e1       	ldi	r18, 0x10	; 16
    7546:	30 e0       	ldi	r19, 0x00	; 0
    7548:	02 c0       	rjmp	.+4      	; 0x754e <vfprintf+0x29e>
    754a:	20 e1       	ldi	r18, 0x10	; 16
    754c:	32 e0       	ldi	r19, 0x02	; 2
    754e:	f5 01       	movw	r30, r10
    7550:	17 ff       	sbrs	r17, 7
    7552:	07 c0       	rjmp	.+14     	; 0x7562 <vfprintf+0x2b2>
    7554:	60 81       	ld	r22, Z
    7556:	71 81       	ldd	r23, Z+1	; 0x01
    7558:	82 81       	ldd	r24, Z+2	; 0x02
    755a:	93 81       	ldd	r25, Z+3	; 0x03
    755c:	44 e0       	ldi	r20, 0x04	; 4
    755e:	50 e0       	ldi	r21, 0x00	; 0
    7560:	06 c0       	rjmp	.+12     	; 0x756e <vfprintf+0x2be>
    7562:	60 81       	ld	r22, Z
    7564:	71 81       	ldd	r23, Z+1	; 0x01
    7566:	80 e0       	ldi	r24, 0x00	; 0
    7568:	90 e0       	ldi	r25, 0x00	; 0
    756a:	42 e0       	ldi	r20, 0x02	; 2
    756c:	50 e0       	ldi	r21, 0x00	; 0
    756e:	a4 0e       	add	r10, r20
    7570:	b5 1e       	adc	r11, r21
    7572:	a2 01       	movw	r20, r4
    7574:	0e 94 b4 3b 	call	0x7768	; 0x7768 <__ultoa_invert>
    7578:	d8 2e       	mov	r13, r24
    757a:	d4 18       	sub	r13, r4
    757c:	01 2f       	mov	r16, r17
    757e:	0f 77       	andi	r16, 0x7F	; 127
    7580:	06 ff       	sbrs	r16, 6
    7582:	09 c0       	rjmp	.+18     	; 0x7596 <vfprintf+0x2e6>
    7584:	0e 7f       	andi	r16, 0xFE	; 254
    7586:	df 14       	cp	r13, r15
    7588:	30 f4       	brcc	.+12     	; 0x7596 <vfprintf+0x2e6>
    758a:	04 ff       	sbrs	r16, 4
    758c:	06 c0       	rjmp	.+12     	; 0x759a <vfprintf+0x2ea>
    758e:	02 fd       	sbrc	r16, 2
    7590:	04 c0       	rjmp	.+8      	; 0x759a <vfprintf+0x2ea>
    7592:	0f 7e       	andi	r16, 0xEF	; 239
    7594:	02 c0       	rjmp	.+4      	; 0x759a <vfprintf+0x2ea>
    7596:	1d 2d       	mov	r17, r13
    7598:	01 c0       	rjmp	.+2      	; 0x759c <vfprintf+0x2ec>
    759a:	1f 2d       	mov	r17, r15
    759c:	80 2f       	mov	r24, r16
    759e:	90 e0       	ldi	r25, 0x00	; 0
    75a0:	04 ff       	sbrs	r16, 4
    75a2:	0c c0       	rjmp	.+24     	; 0x75bc <vfprintf+0x30c>
    75a4:	fe 01       	movw	r30, r28
    75a6:	ed 0d       	add	r30, r13
    75a8:	f1 1d       	adc	r31, r1
    75aa:	20 81       	ld	r18, Z
    75ac:	20 33       	cpi	r18, 0x30	; 48
    75ae:	11 f4       	brne	.+4      	; 0x75b4 <vfprintf+0x304>
    75b0:	09 7e       	andi	r16, 0xE9	; 233
    75b2:	09 c0       	rjmp	.+18     	; 0x75c6 <vfprintf+0x316>
    75b4:	02 ff       	sbrs	r16, 2
    75b6:	06 c0       	rjmp	.+12     	; 0x75c4 <vfprintf+0x314>
    75b8:	1e 5f       	subi	r17, 0xFE	; 254
    75ba:	05 c0       	rjmp	.+10     	; 0x75c6 <vfprintf+0x316>
    75bc:	86 78       	andi	r24, 0x86	; 134
    75be:	90 70       	andi	r25, 0x00	; 0
    75c0:	00 97       	sbiw	r24, 0x00	; 0
    75c2:	09 f0       	breq	.+2      	; 0x75c6 <vfprintf+0x316>
    75c4:	1f 5f       	subi	r17, 0xFF	; 255
    75c6:	80 2e       	mov	r8, r16
    75c8:	99 24       	eor	r9, r9
    75ca:	03 fd       	sbrc	r16, 3
    75cc:	12 c0       	rjmp	.+36     	; 0x75f2 <vfprintf+0x342>
    75ce:	00 ff       	sbrs	r16, 0
    75d0:	0d c0       	rjmp	.+26     	; 0x75ec <vfprintf+0x33c>
    75d2:	fd 2c       	mov	r15, r13
    75d4:	1e 15       	cp	r17, r14
    75d6:	50 f4       	brcc	.+20     	; 0x75ec <vfprintf+0x33c>
    75d8:	fe 0c       	add	r15, r14
    75da:	f1 1a       	sub	r15, r17
    75dc:	1e 2d       	mov	r17, r14
    75de:	06 c0       	rjmp	.+12     	; 0x75ec <vfprintf+0x33c>
    75e0:	80 e2       	ldi	r24, 0x20	; 32
    75e2:	90 e0       	ldi	r25, 0x00	; 0
    75e4:	b3 01       	movw	r22, r6
    75e6:	0e 94 88 3b 	call	0x7710	; 0x7710 <fputc>
    75ea:	1f 5f       	subi	r17, 0xFF	; 255
    75ec:	1e 15       	cp	r17, r14
    75ee:	c0 f3       	brcs	.-16     	; 0x75e0 <vfprintf+0x330>
    75f0:	04 c0       	rjmp	.+8      	; 0x75fa <vfprintf+0x34a>
    75f2:	1e 15       	cp	r17, r14
    75f4:	10 f4       	brcc	.+4      	; 0x75fa <vfprintf+0x34a>
    75f6:	e1 1a       	sub	r14, r17
    75f8:	01 c0       	rjmp	.+2      	; 0x75fc <vfprintf+0x34c>
    75fa:	ee 24       	eor	r14, r14
    75fc:	84 fe       	sbrs	r8, 4
    75fe:	0f c0       	rjmp	.+30     	; 0x761e <vfprintf+0x36e>
    7600:	80 e3       	ldi	r24, 0x30	; 48
    7602:	90 e0       	ldi	r25, 0x00	; 0
    7604:	b3 01       	movw	r22, r6
    7606:	0e 94 88 3b 	call	0x7710	; 0x7710 <fputc>
    760a:	82 fe       	sbrs	r8, 2
    760c:	1f c0       	rjmp	.+62     	; 0x764c <vfprintf+0x39c>
    760e:	81 fe       	sbrs	r8, 1
    7610:	03 c0       	rjmp	.+6      	; 0x7618 <vfprintf+0x368>
    7612:	88 e5       	ldi	r24, 0x58	; 88
    7614:	90 e0       	ldi	r25, 0x00	; 0
    7616:	10 c0       	rjmp	.+32     	; 0x7638 <vfprintf+0x388>
    7618:	88 e7       	ldi	r24, 0x78	; 120
    761a:	90 e0       	ldi	r25, 0x00	; 0
    761c:	0d c0       	rjmp	.+26     	; 0x7638 <vfprintf+0x388>
    761e:	c4 01       	movw	r24, r8
    7620:	86 78       	andi	r24, 0x86	; 134
    7622:	90 70       	andi	r25, 0x00	; 0
    7624:	00 97       	sbiw	r24, 0x00	; 0
    7626:	91 f0       	breq	.+36     	; 0x764c <vfprintf+0x39c>
    7628:	81 fc       	sbrc	r8, 1
    762a:	02 c0       	rjmp	.+4      	; 0x7630 <vfprintf+0x380>
    762c:	80 e2       	ldi	r24, 0x20	; 32
    762e:	01 c0       	rjmp	.+2      	; 0x7632 <vfprintf+0x382>
    7630:	8b e2       	ldi	r24, 0x2B	; 43
    7632:	07 fd       	sbrc	r16, 7
    7634:	8d e2       	ldi	r24, 0x2D	; 45
    7636:	90 e0       	ldi	r25, 0x00	; 0
    7638:	b3 01       	movw	r22, r6
    763a:	0e 94 88 3b 	call	0x7710	; 0x7710 <fputc>
    763e:	06 c0       	rjmp	.+12     	; 0x764c <vfprintf+0x39c>
    7640:	80 e3       	ldi	r24, 0x30	; 48
    7642:	90 e0       	ldi	r25, 0x00	; 0
    7644:	b3 01       	movw	r22, r6
    7646:	0e 94 88 3b 	call	0x7710	; 0x7710 <fputc>
    764a:	fa 94       	dec	r15
    764c:	df 14       	cp	r13, r15
    764e:	c0 f3       	brcs	.-16     	; 0x7640 <vfprintf+0x390>
    7650:	da 94       	dec	r13
    7652:	f2 01       	movw	r30, r4
    7654:	ed 0d       	add	r30, r13
    7656:	f1 1d       	adc	r31, r1
    7658:	80 81       	ld	r24, Z
    765a:	90 e0       	ldi	r25, 0x00	; 0
    765c:	b3 01       	movw	r22, r6
    765e:	0e 94 88 3b 	call	0x7710	; 0x7710 <fputc>
    7662:	dd 20       	and	r13, r13
    7664:	a9 f7       	brne	.-22     	; 0x7650 <vfprintf+0x3a0>
    7666:	06 c0       	rjmp	.+12     	; 0x7674 <vfprintf+0x3c4>
    7668:	80 e2       	ldi	r24, 0x20	; 32
    766a:	90 e0       	ldi	r25, 0x00	; 0
    766c:	b3 01       	movw	r22, r6
    766e:	0e 94 88 3b 	call	0x7710	; 0x7710 <fputc>
    7672:	ea 94       	dec	r14
    7674:	ee 20       	and	r14, r14
    7676:	c1 f7       	brne	.-16     	; 0x7668 <vfprintf+0x3b8>
    7678:	40 ce       	rjmp	.-896    	; 0x72fa <vfprintf+0x4a>
    767a:	f3 01       	movw	r30, r6
    767c:	86 81       	ldd	r24, Z+6	; 0x06
    767e:	97 81       	ldd	r25, Z+7	; 0x07
    7680:	02 c0       	rjmp	.+4      	; 0x7686 <vfprintf+0x3d6>
    7682:	8f ef       	ldi	r24, 0xFF	; 255
    7684:	9f ef       	ldi	r25, 0xFF	; 255
    7686:	2d 96       	adiw	r28, 0x0d	; 13
    7688:	cd bf       	out	0x3d, r28	; 61
    768a:	de bf       	out	0x3e, r29	; 62
    768c:	df 91       	pop	r29
    768e:	cf 91       	pop	r28
    7690:	1f 91       	pop	r17
    7692:	0f 91       	pop	r16
    7694:	ff 90       	pop	r15
    7696:	ef 90       	pop	r14
    7698:	df 90       	pop	r13
    769a:	cf 90       	pop	r12
    769c:	bf 90       	pop	r11
    769e:	af 90       	pop	r10
    76a0:	9f 90       	pop	r9
    76a2:	8f 90       	pop	r8
    76a4:	7f 90       	pop	r7
    76a6:	6f 90       	pop	r6
    76a8:	5f 90       	pop	r5
    76aa:	4f 90       	pop	r4
    76ac:	3f 90       	pop	r3
    76ae:	2f 90       	pop	r2
    76b0:	08 95       	ret

000076b2 <strnlen_P>:
    76b2:	fc 01       	movw	r30, r24
    76b4:	05 90       	lpm	r0, Z+
    76b6:	61 50       	subi	r22, 0x01	; 1
    76b8:	70 40       	sbci	r23, 0x00	; 0
    76ba:	01 10       	cpse	r0, r1
    76bc:	d8 f7       	brcc	.-10     	; 0x76b4 <strnlen_P+0x2>
    76be:	80 95       	com	r24
    76c0:	90 95       	com	r25
    76c2:	8e 0f       	add	r24, r30
    76c4:	9f 1f       	adc	r25, r31
    76c6:	08 95       	ret

000076c8 <memcpy>:
    76c8:	fb 01       	movw	r30, r22
    76ca:	dc 01       	movw	r26, r24
    76cc:	02 c0       	rjmp	.+4      	; 0x76d2 <memcpy+0xa>
    76ce:	01 90       	ld	r0, Z+
    76d0:	0d 92       	st	X+, r0
    76d2:	41 50       	subi	r20, 0x01	; 1
    76d4:	50 40       	sbci	r21, 0x00	; 0
    76d6:	d8 f7       	brcc	.-10     	; 0x76ce <memcpy+0x6>
    76d8:	08 95       	ret

000076da <strnlen>:
    76da:	fc 01       	movw	r30, r24
    76dc:	61 50       	subi	r22, 0x01	; 1
    76de:	70 40       	sbci	r23, 0x00	; 0
    76e0:	01 90       	ld	r0, Z+
    76e2:	01 10       	cpse	r0, r1
    76e4:	d8 f7       	brcc	.-10     	; 0x76dc <strnlen+0x2>
    76e6:	80 95       	com	r24
    76e8:	90 95       	com	r25
    76ea:	8e 0f       	add	r24, r30
    76ec:	9f 1f       	adc	r25, r31
    76ee:	08 95       	ret

000076f0 <strrev>:
    76f0:	dc 01       	movw	r26, r24
    76f2:	fc 01       	movw	r30, r24
    76f4:	67 2f       	mov	r22, r23
    76f6:	71 91       	ld	r23, Z+
    76f8:	77 23       	and	r23, r23
    76fa:	e1 f7       	brne	.-8      	; 0x76f4 <strrev+0x4>
    76fc:	32 97       	sbiw	r30, 0x02	; 2
    76fe:	04 c0       	rjmp	.+8      	; 0x7708 <strrev+0x18>
    7700:	7c 91       	ld	r23, X
    7702:	6d 93       	st	X+, r22
    7704:	70 83       	st	Z, r23
    7706:	62 91       	ld	r22, -Z
    7708:	ae 17       	cp	r26, r30
    770a:	bf 07       	cpc	r27, r31
    770c:	c8 f3       	brcs	.-14     	; 0x7700 <strrev+0x10>
    770e:	08 95       	ret

00007710 <fputc>:
    7710:	0f 93       	push	r16
    7712:	1f 93       	push	r17
    7714:	cf 93       	push	r28
    7716:	df 93       	push	r29
    7718:	8c 01       	movw	r16, r24
    771a:	eb 01       	movw	r28, r22
    771c:	8b 81       	ldd	r24, Y+3	; 0x03
    771e:	81 ff       	sbrs	r24, 1
    7720:	1b c0       	rjmp	.+54     	; 0x7758 <fputc+0x48>
    7722:	82 ff       	sbrs	r24, 2
    7724:	0d c0       	rjmp	.+26     	; 0x7740 <fputc+0x30>
    7726:	2e 81       	ldd	r18, Y+6	; 0x06
    7728:	3f 81       	ldd	r19, Y+7	; 0x07
    772a:	8c 81       	ldd	r24, Y+4	; 0x04
    772c:	9d 81       	ldd	r25, Y+5	; 0x05
    772e:	28 17       	cp	r18, r24
    7730:	39 07       	cpc	r19, r25
    7732:	64 f4       	brge	.+24     	; 0x774c <fputc+0x3c>
    7734:	e8 81       	ld	r30, Y
    7736:	f9 81       	ldd	r31, Y+1	; 0x01
    7738:	01 93       	st	Z+, r16
    773a:	e8 83       	st	Y, r30
    773c:	f9 83       	std	Y+1, r31	; 0x01
    773e:	06 c0       	rjmp	.+12     	; 0x774c <fputc+0x3c>
    7740:	e8 85       	ldd	r30, Y+8	; 0x08
    7742:	f9 85       	ldd	r31, Y+9	; 0x09
    7744:	80 2f       	mov	r24, r16
    7746:	19 95       	eicall
    7748:	00 97       	sbiw	r24, 0x00	; 0
    774a:	31 f4       	brne	.+12     	; 0x7758 <fputc+0x48>
    774c:	8e 81       	ldd	r24, Y+6	; 0x06
    774e:	9f 81       	ldd	r25, Y+7	; 0x07
    7750:	01 96       	adiw	r24, 0x01	; 1
    7752:	8e 83       	std	Y+6, r24	; 0x06
    7754:	9f 83       	std	Y+7, r25	; 0x07
    7756:	02 c0       	rjmp	.+4      	; 0x775c <fputc+0x4c>
    7758:	0f ef       	ldi	r16, 0xFF	; 255
    775a:	1f ef       	ldi	r17, 0xFF	; 255
    775c:	c8 01       	movw	r24, r16
    775e:	df 91       	pop	r29
    7760:	cf 91       	pop	r28
    7762:	1f 91       	pop	r17
    7764:	0f 91       	pop	r16
    7766:	08 95       	ret

00007768 <__ultoa_invert>:
    7768:	fa 01       	movw	r30, r20
    776a:	aa 27       	eor	r26, r26
    776c:	28 30       	cpi	r18, 0x08	; 8
    776e:	51 f1       	breq	.+84     	; 0x77c4 <__ultoa_invert+0x5c>
    7770:	20 31       	cpi	r18, 0x10	; 16
    7772:	81 f1       	breq	.+96     	; 0x77d4 <__ultoa_invert+0x6c>
    7774:	e8 94       	clt
    7776:	6f 93       	push	r22
    7778:	6e 7f       	andi	r22, 0xFE	; 254
    777a:	6e 5f       	subi	r22, 0xFE	; 254
    777c:	7f 4f       	sbci	r23, 0xFF	; 255
    777e:	8f 4f       	sbci	r24, 0xFF	; 255
    7780:	9f 4f       	sbci	r25, 0xFF	; 255
    7782:	af 4f       	sbci	r26, 0xFF	; 255
    7784:	b1 e0       	ldi	r27, 0x01	; 1
    7786:	3e d0       	rcall	.+124    	; 0x7804 <__ultoa_invert+0x9c>
    7788:	b4 e0       	ldi	r27, 0x04	; 4
    778a:	3c d0       	rcall	.+120    	; 0x7804 <__ultoa_invert+0x9c>
    778c:	67 0f       	add	r22, r23
    778e:	78 1f       	adc	r23, r24
    7790:	89 1f       	adc	r24, r25
    7792:	9a 1f       	adc	r25, r26
    7794:	a1 1d       	adc	r26, r1
    7796:	68 0f       	add	r22, r24
    7798:	79 1f       	adc	r23, r25
    779a:	8a 1f       	adc	r24, r26
    779c:	91 1d       	adc	r25, r1
    779e:	a1 1d       	adc	r26, r1
    77a0:	6a 0f       	add	r22, r26
    77a2:	71 1d       	adc	r23, r1
    77a4:	81 1d       	adc	r24, r1
    77a6:	91 1d       	adc	r25, r1
    77a8:	a1 1d       	adc	r26, r1
    77aa:	20 d0       	rcall	.+64     	; 0x77ec <__ultoa_invert+0x84>
    77ac:	09 f4       	brne	.+2      	; 0x77b0 <__ultoa_invert+0x48>
    77ae:	68 94       	set
    77b0:	3f 91       	pop	r19
    77b2:	2a e0       	ldi	r18, 0x0A	; 10
    77b4:	26 9f       	mul	r18, r22
    77b6:	11 24       	eor	r1, r1
    77b8:	30 19       	sub	r19, r0
    77ba:	30 5d       	subi	r19, 0xD0	; 208
    77bc:	31 93       	st	Z+, r19
    77be:	de f6       	brtc	.-74     	; 0x7776 <__ultoa_invert+0xe>
    77c0:	cf 01       	movw	r24, r30
    77c2:	08 95       	ret
    77c4:	46 2f       	mov	r20, r22
    77c6:	47 70       	andi	r20, 0x07	; 7
    77c8:	40 5d       	subi	r20, 0xD0	; 208
    77ca:	41 93       	st	Z+, r20
    77cc:	b3 e0       	ldi	r27, 0x03	; 3
    77ce:	0f d0       	rcall	.+30     	; 0x77ee <__ultoa_invert+0x86>
    77d0:	c9 f7       	brne	.-14     	; 0x77c4 <__ultoa_invert+0x5c>
    77d2:	f6 cf       	rjmp	.-20     	; 0x77c0 <__ultoa_invert+0x58>
    77d4:	46 2f       	mov	r20, r22
    77d6:	4f 70       	andi	r20, 0x0F	; 15
    77d8:	40 5d       	subi	r20, 0xD0	; 208
    77da:	4a 33       	cpi	r20, 0x3A	; 58
    77dc:	18 f0       	brcs	.+6      	; 0x77e4 <__ultoa_invert+0x7c>
    77de:	49 5d       	subi	r20, 0xD9	; 217
    77e0:	31 fd       	sbrc	r19, 1
    77e2:	40 52       	subi	r20, 0x20	; 32
    77e4:	41 93       	st	Z+, r20
    77e6:	02 d0       	rcall	.+4      	; 0x77ec <__ultoa_invert+0x84>
    77e8:	a9 f7       	brne	.-22     	; 0x77d4 <__ultoa_invert+0x6c>
    77ea:	ea cf       	rjmp	.-44     	; 0x77c0 <__ultoa_invert+0x58>
    77ec:	b4 e0       	ldi	r27, 0x04	; 4
    77ee:	a6 95       	lsr	r26
    77f0:	97 95       	ror	r25
    77f2:	87 95       	ror	r24
    77f4:	77 95       	ror	r23
    77f6:	67 95       	ror	r22
    77f8:	ba 95       	dec	r27
    77fa:	c9 f7       	brne	.-14     	; 0x77ee <__ultoa_invert+0x86>
    77fc:	00 97       	sbiw	r24, 0x00	; 0
    77fe:	61 05       	cpc	r22, r1
    7800:	71 05       	cpc	r23, r1
    7802:	08 95       	ret
    7804:	9b 01       	movw	r18, r22
    7806:	ac 01       	movw	r20, r24
    7808:	0a 2e       	mov	r0, r26
    780a:	06 94       	lsr	r0
    780c:	57 95       	ror	r21
    780e:	47 95       	ror	r20
    7810:	37 95       	ror	r19
    7812:	27 95       	ror	r18
    7814:	ba 95       	dec	r27
    7816:	c9 f7       	brne	.-14     	; 0x780a <__ultoa_invert+0xa2>
    7818:	62 0f       	add	r22, r18
    781a:	73 1f       	adc	r23, r19
    781c:	84 1f       	adc	r24, r20
    781e:	95 1f       	adc	r25, r21
    7820:	a0 1d       	adc	r26, r0
    7822:	08 95       	ret

00007824 <_exit>:
    7824:	f8 94       	cli

00007826 <__stop_program>:
    7826:	ff cf       	rjmp	.-2      	; 0x7826 <__stop_program>
