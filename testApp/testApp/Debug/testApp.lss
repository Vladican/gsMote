
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000bf38  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000012a  00802000  0000bf38  0000bfcc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fab  0080212a  0080212a  0000c0f6  2**0
                  ALLOC
  3 .stab         00002718  00000000  00000000  0000c0f8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a2a  00000000  00000000  0000e810  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000003c0  00000000  00000000  0000f240  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000c957  00000000  00000000  0000f600  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000020a3  00000000  00000000  0001bf57  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005597  00000000  00000000  0001dffa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001bac  00000000  00000000  00023594  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000045c2  00000000  00000000  00025140  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004fe9  00000000  00000000  00029702  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0013f76a  00000000  00000000  0002e6eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000100  00000000  00000000  0016de55  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 67 10 	jmp	0x20ce	; 0x20ce <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 7b 0f 	jmp	0x1ef6	; 0x1ef6 <__vector_16>
      44:	0c 94 ab 0f 	jmp	0x1f56	; 0x1f56 <__vector_17>
      48:	0c 94 db 0f 	jmp	0x1fb6	; 0x1fb6 <__vector_18>
      4c:	0c 94 0b 10 	jmp	0x2016	; 0x2016 <__vector_19>
      50:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 ca 3d 	jmp	0x7b94	; 0x7b94 <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 93 2d 	jmp	0x5b26	; 0x5b26 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 1a 13 	jmp	0x2634	; 0x2634 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 58 12 	jmp	0x24b0	; 0x24b0 <__vector_79>
     140:	0c 94 88 12 	jmp	0x2510	; 0x2510 <__vector_80>
     144:	0c 94 b8 12 	jmp	0x2570	; 0x2570 <__vector_81>
     148:	0c 94 e8 12 	jmp	0x25d0	; 0x25d0 <__vector_82>
     14c:	0c 94 df 01 	jmp	0x3be	; 0x3be <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 74 0c 	jmp	0x18e8	; 0x18e8 <__vector_104>
     1a4:	0c 94 69 0a 	jmp	0x14d2	; 0x14d2 <__vector_105>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_overflow>:
     1e8:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     1f8:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     208:	54 41 0a 00                                         TA..

0000020c <chb_err_init>:
     20c:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     21c:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e8 e3       	ldi	r30, 0x38	; 56
     244:	ff eb       	ldi	r31, 0xBF	; 191
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	aa 32       	cpi	r26, 0x2A	; 42
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	aa e2       	ldi	r26, 0x2A	; 42
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a5 3d       	cpi	r26, 0xD5	; 213
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 39 01 	call	0x272	; 0x272 <main>
     26a:	0c 94 9a 5f 	jmp	0xbf34	; 0xbf34 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <main>:
 * Created: 1/29/2013 2:50:50 PM
 *  Author: Vlad
 */ 
# include "E-000001-000009_firmware_rev_1_0.h"

int main(){
     272:	cf 93       	push	r28
     274:	df 93       	push	r29
     276:	0f 92       	push	r0
     278:	cd b7       	in	r28, 0x3d	; 61
     27a:	de b7       	in	r29, 0x3e	; 62
		chb_write(0xFFFF,message,strlen(message));
	}	
	*/
	uint8_t data_byte;
	//set F_CPU/F_PER to 32 MHz
	set_32MHz();
     27c:	0e 94 84 31 	call	0x6308	; 0x6308 <set_32MHz>
	//set output on transmit pin
	PORTC.DIRSET = PIN3_bm;
     280:	80 e4       	ldi	r24, 0x40	; 64
     282:	96 e0       	ldi	r25, 0x06	; 6
     284:	28 e0       	ldi	r18, 0x08	; 8
     286:	fc 01       	movw	r30, r24
     288:	21 83       	std	Z+1, r18	; 0x01
	PORTC.OUTSET = PIN3_bm;
     28a:	80 e4       	ldi	r24, 0x40	; 64
     28c:	96 e0       	ldi	r25, 0x06	; 6
     28e:	28 e0       	ldi	r18, 0x08	; 8
     290:	fc 01       	movw	r30, r24
     292:	25 83       	std	Z+5, r18	; 0x05
	//set input on receive pin
	PORTC.DIRCLR = PIN2_bm;
     294:	80 e4       	ldi	r24, 0x40	; 64
     296:	96 e0       	ldi	r25, 0x06	; 6
     298:	24 e0       	ldi	r18, 0x04	; 4
     29a:	fc 01       	movw	r30, r24
     29c:	22 83       	std	Z+2, r18	; 0x02
	//prescalar of 15: baud = F_CPU/((2^bscale)*16*(scaler+1)) = 125000 (almost 128000)
	USARTC0.BAUDCTRLA = 15;
     29e:	80 ea       	ldi	r24, 0xA0	; 160
     2a0:	98 e0       	ldi	r25, 0x08	; 8
     2a2:	2f e0       	ldi	r18, 0x0F	; 15
     2a4:	fc 01       	movw	r30, r24
     2a6:	26 83       	std	Z+6, r18	; 0x06
	//8 data bits no parity 1 stop bit
	USARTC0.CTRLC = 3;
     2a8:	80 ea       	ldi	r24, 0xA0	; 160
     2aa:	98 e0       	ldi	r25, 0x08	; 8
     2ac:	23 e0       	ldi	r18, 0x03	; 3
     2ae:	fc 01       	movw	r30, r24
     2b0:	25 83       	std	Z+5, r18	; 0x05
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
     2b2:	80 ea       	ldi	r24, 0xA0	; 160
     2b4:	98 e0       	ldi	r25, 0x08	; 8
     2b6:	28 e1       	ldi	r18, 0x18	; 24
     2b8:	fc 01       	movw	r30, r24
     2ba:	24 83       	std	Z+4, r18	; 0x04
     2bc:	01 c0       	rjmp	.+2      	; 0x2c0 <main+0x4e>
			//wait for transmit to finish
			while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
			//wait
			}
		}
	}
     2be:	00 00       	nop
	USARTC0.CTRLC = 3;
	//turn on Rx and Tx for USART
	USARTC0.CTRLB = BIT4_bm | BIT3_bm;
	while(1){
		//wait for reception of message
		if ((USARTC0.STATUS & BIT7_bm) == BIT7_bm){
     2c0:	80 ea       	ldi	r24, 0xA0	; 160
     2c2:	98 e0       	ldi	r25, 0x08	; 8
     2c4:	fc 01       	movw	r30, r24
     2c6:	81 81       	ldd	r24, Z+1	; 0x01
     2c8:	88 23       	and	r24, r24
     2ca:	cc f7       	brge	.-14     	; 0x2be <main+0x4c>
			//read in byte
			data_byte = USARTC0.DATA;
     2cc:	80 ea       	ldi	r24, 0xA0	; 160
     2ce:	98 e0       	ldi	r25, 0x08	; 8
     2d0:	fc 01       	movw	r30, r24
     2d2:	80 81       	ld	r24, Z
     2d4:	89 83       	std	Y+1, r24	; 0x01
			//increment byte
			data_byte++;
     2d6:	89 81       	ldd	r24, Y+1	; 0x01
     2d8:	8f 5f       	subi	r24, 0xFF	; 255
     2da:	89 83       	std	Y+1, r24	; 0x01
			//wait for transmit buffer to become available
			while((USARTC0.STATUS & BIT5_bm) != BIT5_bm){
     2dc:	00 00       	nop
     2de:	80 ea       	ldi	r24, 0xA0	; 160
     2e0:	98 e0       	ldi	r25, 0x08	; 8
     2e2:	fc 01       	movw	r30, r24
     2e4:	81 81       	ldd	r24, Z+1	; 0x01
     2e6:	88 2f       	mov	r24, r24
     2e8:	90 e0       	ldi	r25, 0x00	; 0
     2ea:	80 72       	andi	r24, 0x20	; 32
     2ec:	90 70       	andi	r25, 0x00	; 0
     2ee:	00 97       	sbiw	r24, 0x00	; 0
     2f0:	b1 f3       	breq	.-20     	; 0x2de <main+0x6c>
				//wait
			}				
			//transmit incremented byte
			USARTC0.DATA = data_byte;
     2f2:	80 ea       	ldi	r24, 0xA0	; 160
     2f4:	98 e0       	ldi	r25, 0x08	; 8
     2f6:	29 81       	ldd	r18, Y+1	; 0x01
     2f8:	fc 01       	movw	r30, r24
     2fa:	20 83       	st	Z, r18
			//wait for transmit to finish
			while((USARTC0.STATUS & BIT6_bm) != BIT6_bm) {
     2fc:	00 00       	nop
     2fe:	80 ea       	ldi	r24, 0xA0	; 160
     300:	98 e0       	ldi	r25, 0x08	; 8
     302:	fc 01       	movw	r30, r24
     304:	81 81       	ldd	r24, Z+1	; 0x01
     306:	88 2f       	mov	r24, r24
     308:	90 e0       	ldi	r25, 0x00	; 0
     30a:	80 74       	andi	r24, 0x40	; 64
     30c:	90 70       	andi	r25, 0x00	; 0
     30e:	00 97       	sbiw	r24, 0x00	; 0
     310:	b1 f3       	breq	.-20     	; 0x2fe <main+0x8c>
			//wait
			}
		}
	}
     312:	d5 cf       	rjmp	.-86     	; 0x2be <main+0x4c>

00000314 <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     314:	cf 93       	push	r28
     316:	df 93       	push	r29
     318:	0f 92       	push	r0
     31a:	0f 92       	push	r0
     31c:	cd b7       	in	r28, 0x3d	; 61
     31e:	de b7       	in	r29, 0x3e	; 62
     320:	89 83       	std	Y+1, r24	; 0x01
     322:	9a 83       	std	Y+2, r25	; 0x02
	moteID = 1;
     324:	81 e0       	ldi	r24, 0x01	; 1
     326:	80 93 c1 50 	sts	0x50C1, r24
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     32a:	83 e0       	ldi	r24, 0x03	; 3
     32c:	80 93 4f 40 	sts	0x404F, r24
	chb_init();
     330:	0e 94 be 1d 	call	0x3b7c	; 0x3b7c <chb_init>
	chb_set_short_addr(moteID);
     334:	80 91 c1 50 	lds	r24, 0x50C1
     338:	88 2f       	mov	r24, r24
     33a:	90 e0       	ldi	r25, 0x00	; 0
     33c:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     340:	80 e8       	ldi	r24, 0x80	; 128
     342:	91 e0       	ldi	r25, 0x01	; 1
     344:	28 ec       	ldi	r18, 0xC8	; 200
     346:	fc 01       	movw	r30, r24
     348:	21 83       	std	Z+1, r18	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     34a:	80 e4       	ldi	r24, 0x40	; 64
     34c:	99 e0       	ldi	r25, 0x09	; 9
     34e:	29 e0       	ldi	r18, 0x09	; 9
     350:	fc 01       	movw	r30, r24
     352:	20 83       	st	Z, r18
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     354:	80 e4       	ldi	r24, 0x40	; 64
     356:	99 e0       	ldi	r25, 0x09	; 9
     358:	22 e0       	ldi	r18, 0x02	; 2
     35a:	fc 01       	movw	r30, r24
     35c:	26 83       	std	Z+6, r18	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     35e:	80 e4       	ldi	r24, 0x40	; 64
     360:	99 e0       	ldi	r25, 0x09	; 9
     362:	69 81       	ldd	r22, Y+1	; 0x01
     364:	7a 81       	ldd	r23, Y+2	; 0x02
     366:	44 ef       	ldi	r20, 0xF4	; 244
     368:	51 e0       	ldi	r21, 0x01	; 1
     36a:	64 9f       	mul	r22, r20
     36c:	90 01       	movw	r18, r0
     36e:	65 9f       	mul	r22, r21
     370:	30 0d       	add	r19, r0
     372:	74 9f       	mul	r23, r20
     374:	30 0d       	add	r19, r0
     376:	11 24       	eor	r1, r1
     378:	fc 01       	movw	r30, r24
     37a:	26 a3       	lds	r18, 0x56
     37c:	37 a3       	lds	r19, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     37e:	80 e4       	ldi	r24, 0x40	; 64
     380:	98 e0       	ldi	r25, 0x08	; 8
     382:	20 e0       	ldi	r18, 0x00	; 0
     384:	3a ef       	ldi	r19, 0xFA	; 250
     386:	fc 01       	movw	r30, r24
     388:	26 a3       	lds	r18, 0x56
     38a:	37 a3       	lds	r19, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     38c:	80 e4       	ldi	r24, 0x40	; 64
     38e:	98 e0       	ldi	r25, 0x08	; 8
     390:	21 e0       	ldi	r18, 0x01	; 1
     392:	fc 01       	movw	r30, r24
     394:	26 83       	std	Z+6, r18	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     396:	80 e4       	ldi	r24, 0x40	; 64
     398:	98 e0       	ldi	r25, 0x08	; 8
     39a:	21 e0       	ldi	r18, 0x01	; 1
     39c:	fc 01       	movw	r30, r24
     39e:	20 83       	st	Z, r18
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     3a0:	80 ea       	ldi	r24, 0xA0	; 160
     3a2:	90 e0       	ldi	r25, 0x00	; 0
     3a4:	20 ea       	ldi	r18, 0xA0	; 160
     3a6:	30 e0       	ldi	r19, 0x00	; 0
     3a8:	f9 01       	movw	r30, r18
     3aa:	22 81       	ldd	r18, Z+2	; 0x02
     3ac:	27 60       	ori	r18, 0x07	; 7
     3ae:	fc 01       	movw	r30, r24
     3b0:	22 83       	std	Z+2, r18	; 0x02
	sei(); //  Enable global interrupts
     3b2:	78 94       	sei
}
     3b4:	0f 90       	pop	r0
     3b6:	0f 90       	pop	r0
     3b8:	df 91       	pop	r29
     3ba:	cf 91       	pop	r28
     3bc:	08 95       	ret

000003be <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     3be:	78 94       	sei
     3c0:	1f 92       	push	r1
     3c2:	0f 92       	push	r0
     3c4:	0f b6       	in	r0, 0x3f	; 63
     3c6:	0f 92       	push	r0
     3c8:	00 90 3b 00 	lds	r0, 0x003B
     3cc:	0f 92       	push	r0
     3ce:	11 24       	eor	r1, r1
     3d0:	2f 93       	push	r18
     3d2:	3f 93       	push	r19
     3d4:	4f 93       	push	r20
     3d6:	5f 93       	push	r21
     3d8:	6f 93       	push	r22
     3da:	7f 93       	push	r23
     3dc:	8f 93       	push	r24
     3de:	9f 93       	push	r25
     3e0:	af 93       	push	r26
     3e2:	bf 93       	push	r27
     3e4:	ef 93       	push	r30
     3e6:	ff 93       	push	r31
     3e8:	cf 93       	push	r28
     3ea:	df 93       	push	r29
     3ec:	cd b7       	in	r28, 0x3d	; 61
     3ee:	de b7       	in	r29, 0x3e	; 62
     3f0:	28 97       	sbiw	r28, 0x08	; 8
     3f2:	cd bf       	out	0x3d, r28	; 61
     3f4:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     3f6:	80 e4       	ldi	r24, 0x40	; 64
     3f8:	98 e0       	ldi	r25, 0x08	; 8
     3fa:	fc 01       	movw	r30, r24
     3fc:	10 82       	st	Z, r1
	TCD1.CTRLA = 0x00;
     3fe:	80 e4       	ldi	r24, 0x40	; 64
     400:	99 e0       	ldi	r25, 0x09	; 9
     402:	fc 01       	movw	r30, r24
     404:	10 82       	st	Z, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
     406:	82 e0       	ldi	r24, 0x02	; 2
     408:	80 93 4f 40 	sts	0x404F, r24
	char message[8];
	strcpy(message,"reset");
     40c:	ce 01       	movw	r24, r28
     40e:	01 96       	adiw	r24, 0x01	; 1
     410:	20 e0       	ldi	r18, 0x00	; 0
     412:	30 e2       	ldi	r19, 0x20	; 32
     414:	46 e0       	ldi	r20, 0x06	; 6
     416:	f9 01       	movw	r30, r18
     418:	00 80       	ld	r0, Z
     41a:	2f 5f       	subi	r18, 0xFF	; 255
     41c:	3f 4f       	sbci	r19, 0xFF	; 255
     41e:	fc 01       	movw	r30, r24
     420:	00 82       	st	Z, r0
     422:	01 96       	adiw	r24, 0x01	; 1
     424:	41 50       	subi	r20, 0x01	; 1
     426:	44 23       	and	r20, r20
     428:	b1 f7       	brne	.-20     	; 0x416 <__vector_83+0x58>
	itoa((int)(moteID),buff,10);
     42a:	80 91 c1 50 	lds	r24, 0x50C1
     42e:	88 2f       	mov	r24, r24
     430:	90 e0       	ldi	r25, 0x00	; 0
     432:	27 ec       	ldi	r18, 0xC7	; 199
     434:	30 e5       	ldi	r19, 0x50	; 80
     436:	b9 01       	movw	r22, r18
     438:	4a e0       	ldi	r20, 0x0A	; 10
     43a:	50 e0       	ldi	r21, 0x00	; 0
     43c:	0e 94 84 5c 	call	0xb908	; 0xb908 <itoa>
	strcat(message,buff);
     440:	27 ec       	ldi	r18, 0xC7	; 199
     442:	30 e5       	ldi	r19, 0x50	; 80
     444:	ce 01       	movw	r24, r28
     446:	01 96       	adiw	r24, 0x01	; 1
     448:	b9 01       	movw	r22, r18
     44a:	0e 94 6b 5c 	call	0xb8d6	; 0xb8d6 <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
     44e:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <ADC_Pause_Sampling>
	chb_write(0x0000,(unsigned char*)message,strlen(message));
     452:	ce 01       	movw	r24, r28
     454:	01 96       	adiw	r24, 0x01	; 1
     456:	9c 01       	movw	r18, r24
     458:	f9 01       	movw	r30, r18
     45a:	01 90       	ld	r0, Z+
     45c:	00 20       	and	r0, r0
     45e:	e9 f7       	brne	.-6      	; 0x45a <__vector_83+0x9c>
     460:	cf 01       	movw	r24, r30
     462:	01 97       	sbiw	r24, 0x01	; 1
     464:	82 1b       	sub	r24, r18
     466:	93 0b       	sbc	r25, r19
     468:	9c 01       	movw	r18, r24
     46a:	40 e0       	ldi	r20, 0x00	; 0
     46c:	50 e0       	ldi	r21, 0x00	; 0
     46e:	80 e0       	ldi	r24, 0x00	; 0
     470:	90 e0       	ldi	r25, 0x00	; 0
     472:	be 01       	movw	r22, r28
     474:	6f 5f       	subi	r22, 0xFF	; 255
     476:	7f 4f       	sbci	r23, 0xFF	; 255
     478:	0e 94 85 1e 	call	0x3d0a	; 0x3d0a <chb_write>
}	
     47c:	28 96       	adiw	r28, 0x08	; 8
     47e:	cd bf       	out	0x3d, r28	; 61
     480:	de bf       	out	0x3e, r29	; 62
     482:	df 91       	pop	r29
     484:	cf 91       	pop	r28
     486:	ff 91       	pop	r31
     488:	ef 91       	pop	r30
     48a:	bf 91       	pop	r27
     48c:	af 91       	pop	r26
     48e:	9f 91       	pop	r25
     490:	8f 91       	pop	r24
     492:	7f 91       	pop	r23
     494:	6f 91       	pop	r22
     496:	5f 91       	pop	r21
     498:	4f 91       	pop	r20
     49a:	3f 91       	pop	r19
     49c:	2f 91       	pop	r18
     49e:	0f 90       	pop	r0
     4a0:	00 92 3b 00 	sts	0x003B, r0
     4a4:	0f 90       	pop	r0
     4a6:	0f be       	out	0x3f, r0	; 63
     4a8:	0f 90       	pop	r0
     4aa:	1f 90       	pop	r1
     4ac:	18 95       	reti

000004ae <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     4ae:	cf 93       	push	r28
     4b0:	df 93       	push	r29
     4b2:	cd b7       	in	r28, 0x3d	; 61
     4b4:	de b7       	in	r29, 0x3e	; 62
     4b6:	6b 97       	sbiw	r28, 0x1b	; 27
     4b8:	cd bf       	out	0x3d, r28	; 61
     4ba:	de bf       	out	0x3e, r29	; 62
     4bc:	8e 8b       	std	Y+22, r24	; 0x16
     4be:	9f 8b       	std	Y+23, r25	; 0x17
     4c0:	68 8f       	std	Y+24, r22	; 0x18
     4c2:	79 8f       	std	Y+25, r23	; 0x19
     4c4:	4a 8f       	std	Y+26, r20	; 0x1a
     4c6:	5b 8f       	std	Y+27, r21	; 0x1b
	
	uint32_t sum = 0;
     4c8:	19 82       	std	Y+1, r1	; 0x01
     4ca:	1a 82       	std	Y+2, r1	; 0x02
     4cc:	1b 82       	std	Y+3, r1	; 0x03
     4ce:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     4d0:	80 e0       	ldi	r24, 0x00	; 0
     4d2:	90 e1       	ldi	r25, 0x10	; 16
     4d4:	a0 e0       	ldi	r26, 0x00	; 0
     4d6:	b0 e0       	ldi	r27, 0x00	; 0
     4d8:	8d 83       	std	Y+5, r24	; 0x05
     4da:	9e 83       	std	Y+6, r25	; 0x06
     4dc:	af 83       	std	Y+7, r26	; 0x07
     4de:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     4e0:	19 86       	std	Y+9, r1	; 0x09
     4e2:	1a 86       	std	Y+10, r1	; 0x0a
     4e4:	1b 86       	std	Y+11, r1	; 0x0b
     4e6:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     4e8:	81 e0       	ldi	r24, 0x01	; 1
     4ea:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     4ee:	80 e0       	ldi	r24, 0x00	; 0
     4f0:	92 e0       	ldi	r25, 0x02	; 2
     4f2:	0e 94 1b 1a 	call	0x3436	; 0x3436 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     4f6:	80 e0       	ldi	r24, 0x00	; 0
     4f8:	92 e0       	ldi	r25, 0x02	; 2
     4fa:	20 e0       	ldi	r18, 0x00	; 0
     4fc:	32 e0       	ldi	r19, 0x02	; 2
     4fe:	f9 01       	movw	r30, r18
     500:	21 81       	ldd	r18, Z+1	; 0x01
     502:	29 7e       	andi	r18, 0xE9	; 233
     504:	fc 01       	movw	r30, r24
     506:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     508:	80 e0       	ldi	r24, 0x00	; 0
     50a:	92 e0       	ldi	r25, 0x02	; 2
     50c:	20 e0       	ldi	r18, 0x00	; 0
     50e:	32 e0       	ldi	r19, 0x02	; 2
     510:	f9 01       	movw	r30, r18
     512:	24 81       	ldd	r18, Z+4	; 0x04
     514:	28 7f       	andi	r18, 0xF8	; 248
     516:	23 60       	ori	r18, 0x03	; 3
     518:	fc 01       	movw	r30, r24
     51a:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     51c:	80 e0       	ldi	r24, 0x00	; 0
     51e:	92 e0       	ldi	r25, 0x02	; 2
     520:	20 e0       	ldi	r18, 0x00	; 0
     522:	32 e0       	ldi	r19, 0x02	; 2
     524:	f9 01       	movw	r30, r18
     526:	22 81       	ldd	r18, Z+2	; 0x02
     528:	2f 7c       	andi	r18, 0xCF	; 207
     52a:	fc 01       	movw	r30, r24
     52c:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     52e:	80 e2       	ldi	r24, 0x20	; 32
     530:	92 e0       	ldi	r25, 0x02	; 2
     532:	20 e2       	ldi	r18, 0x20	; 32
     534:	32 e0       	ldi	r19, 0x02	; 2
     536:	f9 01       	movw	r30, r18
     538:	20 81       	ld	r18, Z
     53a:	20 7e       	andi	r18, 0xE0	; 224
     53c:	21 60       	ori	r18, 0x01	; 1
     53e:	fc 01       	movw	r30, r24
     540:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     542:	80 e2       	ldi	r24, 0x20	; 32
     544:	92 e0       	ldi	r25, 0x02	; 2
     546:	29 e0       	ldi	r18, 0x09	; 9
     548:	fc 01       	movw	r30, r24
     54a:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCA);
     54c:	80 e0       	ldi	r24, 0x00	; 0
     54e:	92 e0       	ldi	r25, 0x02	; 2
     550:	20 e0       	ldi	r18, 0x00	; 0
     552:	32 e0       	ldi	r19, 0x02	; 2
     554:	f9 01       	movw	r30, r18
     556:	20 81       	ld	r18, Z
     558:	21 60       	ori	r18, 0x01	; 1
     55a:	fc 01       	movw	r30, r24
     55c:	20 83       	st	Z, r18
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     55e:	80 e0       	ldi	r24, 0x00	; 0
     560:	92 e0       	ldi	r25, 0x02	; 2
     562:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     566:	80 e0       	ldi	r24, 0x00	; 0
     568:	92 e0       	ldi	r25, 0x02	; 2
     56a:	60 e2       	ldi	r22, 0x20	; 32
     56c:	72 e0       	ldi	r23, 0x02	; 2
     56e:	40 e0       	ldi	r20, 0x00	; 0
     570:	0e 94 ca 1c 	call	0x3994	; 0x3994 <ADC_Offset_Get_Unsigned>
     574:	8d 8b       	std	Y+21, r24	; 0x15
    ADC_Disable(&ADCA);
     576:	80 e0       	ldi	r24, 0x00	; 0
     578:	92 e0       	ldi	r25, 0x02	; 2
     57a:	20 e0       	ldi	r18, 0x00	; 0
     57c:	32 e0       	ldi	r19, 0x02	; 2
     57e:	f9 01       	movw	r30, r18
     580:	20 81       	ld	r18, Z
     582:	2e 7f       	andi	r18, 0xFE	; 254
     584:	fc 01       	movw	r30, r24
     586:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     588:	80 e2       	ldi	r24, 0x20	; 32
     58a:	92 e0       	ldi	r25, 0x02	; 2
     58c:	fc 01       	movw	r30, r24
     58e:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	92 e0       	ldi	r25, 0x02	; 2
     594:	20 e0       	ldi	r18, 0x00	; 0
     596:	32 e0       	ldi	r19, 0x02	; 2
     598:	f9 01       	movw	r30, r18
     59a:	23 81       	ldd	r18, Z+3	; 0x03
     59c:	2f 73       	andi	r18, 0x3F	; 63
     59e:	fc 01       	movw	r30, r24
     5a0:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     5a2:	80 e0       	ldi	r24, 0x00	; 0
     5a4:	92 e0       	ldi	r25, 0x02	; 2
     5a6:	20 e0       	ldi	r18, 0x00	; 0
     5a8:	32 e0       	ldi	r19, 0x02	; 2
     5aa:	f9 01       	movw	r30, r18
     5ac:	20 81       	ld	r18, Z
     5ae:	21 60       	ori	r18, 0x01	; 1
     5b0:	fc 01       	movw	r30, r24
     5b2:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     5b4:	80 e0       	ldi	r24, 0x00	; 0
     5b6:	92 e0       	ldi	r25, 0x02	; 2
     5b8:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     5bc:	80 e0       	ldi	r24, 0x00	; 0
     5be:	92 e0       	ldi	r25, 0x02	; 2
     5c0:	20 e0       	ldi	r18, 0x00	; 0
     5c2:	32 e0       	ldi	r19, 0x02	; 2
     5c4:	f9 01       	movw	r30, r18
     5c6:	21 81       	ldd	r18, Z+1	; 0x01
     5c8:	28 60       	ori	r18, 0x08	; 8
     5ca:	fc 01       	movw	r30, r24
     5cc:	21 83       	std	Z+1, r18	; 0x01

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     5ce:	1d 86       	std	Y+13, r1	; 0x0d
     5d0:	1e 86       	std	Y+14, r1	; 0x0e
     5d2:	56 c0       	rjmp	.+172    	; 0x680 <CO_collectTemp+0x1d2>

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     5d4:	80 e2       	ldi	r24, 0x20	; 32
     5d6:	92 e0       	ldi	r25, 0x02	; 2
     5d8:	fc 01       	movw	r30, r24
     5da:	83 81       	ldd	r24, Z+3	; 0x03
     5dc:	88 2f       	mov	r24, r24
     5de:	90 e0       	ldi	r25, 0x00	; 0
     5e0:	81 70       	andi	r24, 0x01	; 1
     5e2:	90 70       	andi	r25, 0x00	; 0
     5e4:	00 97       	sbiw	r24, 0x00	; 0
     5e6:	b1 f3       	breq	.-20     	; 0x5d4 <CO_collectTemp+0x126>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     5e8:	2d 89       	ldd	r18, Y+21	; 0x15
     5ea:	80 e2       	ldi	r24, 0x20	; 32
     5ec:	92 e0       	ldi	r25, 0x02	; 2
     5ee:	62 2f       	mov	r22, r18
     5f0:	0e 94 74 1a 	call	0x34e8	; 0x34e8 <ADC_ResultCh_GetWord_Signed>
     5f4:	8f 87       	std	Y+15, r24	; 0x0f
     5f6:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResult;
     5f8:	8f 85       	ldd	r24, Y+15	; 0x0f
     5fa:	98 89       	ldd	r25, Y+16	; 0x10
     5fc:	cc 01       	movw	r24, r24
     5fe:	a0 e0       	ldi	r26, 0x00	; 0
     600:	b0 e0       	ldi	r27, 0x00	; 0
     602:	29 81       	ldd	r18, Y+1	; 0x01
     604:	3a 81       	ldd	r19, Y+2	; 0x02
     606:	4b 81       	ldd	r20, Y+3	; 0x03
     608:	5c 81       	ldd	r21, Y+4	; 0x04
     60a:	82 0f       	add	r24, r18
     60c:	93 1f       	adc	r25, r19
     60e:	a4 1f       	adc	r26, r20
     610:	b5 1f       	adc	r27, r21
     612:	89 83       	std	Y+1, r24	; 0x01
     614:	9a 83       	std	Y+2, r25	; 0x02
     616:	ab 83       	std	Y+3, r26	; 0x03
     618:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResult) { max = tempResult;}
     61a:	8f 85       	ldd	r24, Y+15	; 0x0f
     61c:	98 89       	ldd	r25, Y+16	; 0x10
     61e:	9c 01       	movw	r18, r24
     620:	40 e0       	ldi	r20, 0x00	; 0
     622:	50 e0       	ldi	r21, 0x00	; 0
     624:	89 85       	ldd	r24, Y+9	; 0x09
     626:	9a 85       	ldd	r25, Y+10	; 0x0a
     628:	ab 85       	ldd	r26, Y+11	; 0x0b
     62a:	bc 85       	ldd	r27, Y+12	; 0x0c
     62c:	82 17       	cp	r24, r18
     62e:	93 07       	cpc	r25, r19
     630:	a4 07       	cpc	r26, r20
     632:	b5 07       	cpc	r27, r21
     634:	48 f4       	brcc	.+18     	; 0x648 <CO_collectTemp+0x19a>
     636:	8f 85       	ldd	r24, Y+15	; 0x0f
     638:	98 89       	ldd	r25, Y+16	; 0x10
     63a:	cc 01       	movw	r24, r24
     63c:	a0 e0       	ldi	r26, 0x00	; 0
     63e:	b0 e0       	ldi	r27, 0x00	; 0
     640:	89 87       	std	Y+9, r24	; 0x09
     642:	9a 87       	std	Y+10, r25	; 0x0a
     644:	ab 87       	std	Y+11, r26	; 0x0b
     646:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResult) { min = tempResult;}
     648:	8f 85       	ldd	r24, Y+15	; 0x0f
     64a:	98 89       	ldd	r25, Y+16	; 0x10
     64c:	9c 01       	movw	r18, r24
     64e:	40 e0       	ldi	r20, 0x00	; 0
     650:	50 e0       	ldi	r21, 0x00	; 0
     652:	8d 81       	ldd	r24, Y+5	; 0x05
     654:	9e 81       	ldd	r25, Y+6	; 0x06
     656:	af 81       	ldd	r26, Y+7	; 0x07
     658:	b8 85       	ldd	r27, Y+8	; 0x08
     65a:	28 17       	cp	r18, r24
     65c:	39 07       	cpc	r19, r25
     65e:	4a 07       	cpc	r20, r26
     660:	5b 07       	cpc	r21, r27
     662:	48 f4       	brcc	.+18     	; 0x676 <CO_collectTemp+0x1c8>
     664:	8f 85       	ldd	r24, Y+15	; 0x0f
     666:	98 89       	ldd	r25, Y+16	; 0x10
     668:	cc 01       	movw	r24, r24
     66a:	a0 e0       	ldi	r26, 0x00	; 0
     66c:	b0 e0       	ldi	r27, 0x00	; 0
     66e:	8d 83       	std	Y+5, r24	; 0x05
     670:	9e 83       	std	Y+6, r25	; 0x06
     672:	af 83       	std	Y+7, r26	; 0x07
     674:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     676:	8d 85       	ldd	r24, Y+13	; 0x0d
     678:	9e 85       	ldd	r25, Y+14	; 0x0e
     67a:	01 96       	adiw	r24, 0x01	; 1
     67c:	8d 87       	std	Y+13, r24	; 0x0d
     67e:	9e 87       	std	Y+14, r25	; 0x0e
     680:	8d 85       	ldd	r24, Y+13	; 0x0d
     682:	9e 85       	ldd	r25, Y+14	; 0x0e
     684:	f4 e0       	ldi	r31, 0x04	; 4
     686:	80 30       	cpi	r24, 0x00	; 0
     688:	9f 07       	cpc	r25, r31
     68a:	08 f4       	brcc	.+2      	; 0x68e <CO_collectTemp+0x1e0>
     68c:	a3 cf       	rjmp	.-186    	; 0x5d4 <CO_collectTemp+0x126>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     68e:	80 e0       	ldi	r24, 0x00	; 0
     690:	92 e0       	ldi	r25, 0x02	; 2
     692:	20 e0       	ldi	r18, 0x00	; 0
     694:	32 e0       	ldi	r19, 0x02	; 2
     696:	f9 01       	movw	r30, r18
     698:	21 81       	ldd	r18, Z+1	; 0x01
     69a:	27 7f       	andi	r18, 0xF7	; 247
     69c:	fc 01       	movw	r30, r24
     69e:	21 83       	std	Z+1, r18	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     6a0:	80 e0       	ldi	r24, 0x00	; 0
     6a2:	92 e0       	ldi	r25, 0x02	; 2
     6a4:	20 e0       	ldi	r18, 0x00	; 0
     6a6:	32 e0       	ldi	r19, 0x02	; 2
     6a8:	f9 01       	movw	r30, r18
     6aa:	20 81       	ld	r18, Z
     6ac:	22 60       	ori	r18, 0x02	; 2
     6ae:	fc 01       	movw	r30, r24
     6b0:	20 83       	st	Z, r18
	ADC_Disable(&ADCA);
     6b2:	80 e0       	ldi	r24, 0x00	; 0
     6b4:	92 e0       	ldi	r25, 0x02	; 2
     6b6:	20 e0       	ldi	r18, 0x00	; 0
     6b8:	32 e0       	ldi	r19, 0x02	; 2
     6ba:	f9 01       	movw	r30, r18
     6bc:	20 81       	ld	r18, Z
     6be:	2e 7f       	andi	r18, 0xFE	; 254
     6c0:	fc 01       	movw	r30, r24
     6c2:	20 83       	st	Z, r18

	ADCPower(FALSE);
     6c4:	80 e0       	ldi	r24, 0x00	; 0
     6c6:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>

	average = sum / NUM_SAMPLES;
     6ca:	89 81       	ldd	r24, Y+1	; 0x01
     6cc:	9a 81       	ldd	r25, Y+2	; 0x02
     6ce:	ab 81       	ldd	r26, Y+3	; 0x03
     6d0:	bc 81       	ldd	r27, Y+4	; 0x04
     6d2:	07 2e       	mov	r0, r23
     6d4:	7a e0       	ldi	r23, 0x0A	; 10
     6d6:	b6 95       	lsr	r27
     6d8:	a7 95       	ror	r26
     6da:	97 95       	ror	r25
     6dc:	87 95       	ror	r24
     6de:	7a 95       	dec	r23
     6e0:	d1 f7       	brne	.-12     	; 0x6d6 <CO_collectTemp+0x228>
     6e2:	70 2d       	mov	r23, r0
     6e4:	89 8b       	std	Y+17, r24	; 0x11
     6e6:	9a 8b       	std	Y+18, r25	; 0x12
     6e8:	ab 8b       	std	Y+19, r26	; 0x13
     6ea:	bc 8b       	std	Y+20, r27	; 0x14

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     6ec:	89 89       	ldd	r24, Y+17	; 0x11
     6ee:	9a 89       	ldd	r25, Y+18	; 0x12
     6f0:	ab 89       	ldd	r26, Y+19	; 0x13
     6f2:	bc 89       	ldd	r27, Y+20	; 0x14
     6f4:	28 ee       	ldi	r18, 0xE8	; 232
     6f6:	33 e0       	ldi	r19, 0x03	; 3
     6f8:	40 e0       	ldi	r20, 0x00	; 0
     6fa:	50 e0       	ldi	r21, 0x00	; 0
     6fc:	bc 01       	movw	r22, r24
     6fe:	cd 01       	movw	r24, r26
     700:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
     704:	dc 01       	movw	r26, r24
     706:	cb 01       	movw	r24, r22
     708:	2f ef       	ldi	r18, 0xFF	; 255
     70a:	3f e0       	ldi	r19, 0x0F	; 15
     70c:	40 e0       	ldi	r20, 0x00	; 0
     70e:	50 e0       	ldi	r21, 0x00	; 0
     710:	bc 01       	movw	r22, r24
     712:	cd 01       	movw	r24, r26
     714:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
     718:	da 01       	movw	r26, r20
     71a:	c9 01       	movw	r24, r18
     71c:	9c 01       	movw	r18, r24
     71e:	22 53       	subi	r18, 0x32	; 50
     720:	30 40       	sbci	r19, 0x00	; 0
     722:	8e 89       	ldd	r24, Y+22	; 0x16
     724:	9f 89       	ldd	r25, Y+23	; 0x17
     726:	fc 01       	movw	r30, r24
     728:	20 83       	st	Z, r18
     72a:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     72c:	89 85       	ldd	r24, Y+9	; 0x09
     72e:	9a 85       	ldd	r25, Y+10	; 0x0a
     730:	ab 85       	ldd	r26, Y+11	; 0x0b
     732:	bc 85       	ldd	r27, Y+12	; 0x0c
     734:	28 ee       	ldi	r18, 0xE8	; 232
     736:	33 e0       	ldi	r19, 0x03	; 3
     738:	40 e0       	ldi	r20, 0x00	; 0
     73a:	50 e0       	ldi	r21, 0x00	; 0
     73c:	bc 01       	movw	r22, r24
     73e:	cd 01       	movw	r24, r26
     740:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
     744:	dc 01       	movw	r26, r24
     746:	cb 01       	movw	r24, r22
     748:	2f ef       	ldi	r18, 0xFF	; 255
     74a:	3f e0       	ldi	r19, 0x0F	; 15
     74c:	40 e0       	ldi	r20, 0x00	; 0
     74e:	50 e0       	ldi	r21, 0x00	; 0
     750:	bc 01       	movw	r22, r24
     752:	cd 01       	movw	r24, r26
     754:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
     758:	da 01       	movw	r26, r20
     75a:	c9 01       	movw	r24, r18
     75c:	9c 01       	movw	r18, r24
     75e:	22 53       	subi	r18, 0x32	; 50
     760:	30 40       	sbci	r19, 0x00	; 0
     762:	8a 8d       	ldd	r24, Y+26	; 0x1a
     764:	9b 8d       	ldd	r25, Y+27	; 0x1b
     766:	fc 01       	movw	r30, r24
     768:	20 83       	st	Z, r18
     76a:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     76c:	8d 81       	ldd	r24, Y+5	; 0x05
     76e:	9e 81       	ldd	r25, Y+6	; 0x06
     770:	af 81       	ldd	r26, Y+7	; 0x07
     772:	b8 85       	ldd	r27, Y+8	; 0x08
     774:	28 ee       	ldi	r18, 0xE8	; 232
     776:	33 e0       	ldi	r19, 0x03	; 3
     778:	40 e0       	ldi	r20, 0x00	; 0
     77a:	50 e0       	ldi	r21, 0x00	; 0
     77c:	bc 01       	movw	r22, r24
     77e:	cd 01       	movw	r24, r26
     780:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
     784:	dc 01       	movw	r26, r24
     786:	cb 01       	movw	r24, r22
     788:	2f ef       	ldi	r18, 0xFF	; 255
     78a:	3f e0       	ldi	r19, 0x0F	; 15
     78c:	40 e0       	ldi	r20, 0x00	; 0
     78e:	50 e0       	ldi	r21, 0x00	; 0
     790:	bc 01       	movw	r22, r24
     792:	cd 01       	movw	r24, r26
     794:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
     798:	da 01       	movw	r26, r20
     79a:	c9 01       	movw	r24, r18
     79c:	9c 01       	movw	r18, r24
     79e:	22 53       	subi	r18, 0x32	; 50
     7a0:	30 40       	sbci	r19, 0x00	; 0
     7a2:	88 8d       	ldd	r24, Y+24	; 0x18
     7a4:	99 8d       	ldd	r25, Y+25	; 0x19
     7a6:	fc 01       	movw	r30, r24
     7a8:	20 83       	st	Z, r18
     7aa:	31 83       	std	Z+1, r19	; 0x01
}
     7ac:	6b 96       	adiw	r28, 0x1b	; 27
     7ae:	cd bf       	out	0x3d, r28	; 61
     7b0:	de bf       	out	0x3e, r29	; 62
     7b2:	df 91       	pop	r29
     7b4:	cf 91       	pop	r28
     7b6:	08 95       	ret

000007b8 <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     7b8:	0f 93       	push	r16
     7ba:	1f 93       	push	r17
     7bc:	cf 93       	push	r28
     7be:	df 93       	push	r29
     7c0:	cd b7       	in	r28, 0x3d	; 61
     7c2:	de b7       	in	r29, 0x3e	; 62
     7c4:	a9 97       	sbiw	r28, 0x29	; 41
     7c6:	cd bf       	out	0x3d, r28	; 61
     7c8:	de bf       	out	0x3e, r29	; 62
     7ca:	8c a3       	lds	r24, 0x5c
     7cc:	9d a3       	lds	r25, 0x5d
     7ce:	6e a3       	lds	r22, 0x5e
     7d0:	7f a3       	lds	r23, 0x5f
     7d2:	48 a7       	lds	r20, 0x78
     7d4:	59 a7       	lds	r21, 0x79
	
	uint32_t sum = 0;
     7d6:	19 82       	std	Y+1, r1	; 0x01
     7d8:	1a 82       	std	Y+2, r1	; 0x02
     7da:	1b 82       	std	Y+3, r1	; 0x03
     7dc:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     7de:	80 e0       	ldi	r24, 0x00	; 0
     7e0:	90 e1       	ldi	r25, 0x10	; 16
     7e2:	a0 e0       	ldi	r26, 0x00	; 0
     7e4:	b0 e0       	ldi	r27, 0x00	; 0
     7e6:	8d 83       	std	Y+5, r24	; 0x05
     7e8:	9e 83       	std	Y+6, r25	; 0x06
     7ea:	af 83       	std	Y+7, r26	; 0x07
     7ec:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     7ee:	19 86       	std	Y+9, r1	; 0x09
     7f0:	1a 86       	std	Y+10, r1	; 0x0a
     7f2:	1b 86       	std	Y+11, r1	; 0x0b
     7f4:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     7f6:	81 e0       	ldi	r24, 0x01	; 1
     7f8:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     7fc:	84 e0       	ldi	r24, 0x04	; 4
     7fe:	60 e0       	ldi	r22, 0x00	; 0
     800:	0e 94 9d 32 	call	0x653a	; 0x653a <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     804:	84 e0       	ldi	r24, 0x04	; 4
     806:	60 e0       	ldi	r22, 0x00	; 0
     808:	0e 94 69 33 	call	0x66d2	; 0x66d2 <PortEx_OUTSET>
     80c:	80 e0       	ldi	r24, 0x00	; 0
     80e:	90 e0       	ldi	r25, 0x00	; 0
     810:	a8 ec       	ldi	r26, 0xC8	; 200
     812:	b2 e4       	ldi	r27, 0x42	; 66
     814:	8d 8b       	std	Y+21, r24	; 0x15
     816:	9e 8b       	std	Y+22, r25	; 0x16
     818:	af 8b       	std	Y+23, r26	; 0x17
     81a:	b8 8f       	std	Y+24, r27	; 0x18
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     81c:	6d 89       	ldd	r22, Y+21	; 0x15
     81e:	7e 89       	ldd	r23, Y+22	; 0x16
     820:	8f 89       	ldd	r24, Y+23	; 0x17
     822:	98 8d       	ldd	r25, Y+24	; 0x18
     824:	20 e0       	ldi	r18, 0x00	; 0
     826:	30 e0       	ldi	r19, 0x00	; 0
     828:	4a ef       	ldi	r20, 0xFA	; 250
     82a:	55 e4       	ldi	r21, 0x45	; 69
     82c:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
     830:	dc 01       	movw	r26, r24
     832:	cb 01       	movw	r24, r22
     834:	89 8f       	std	Y+25, r24	; 0x19
     836:	9a 8f       	std	Y+26, r25	; 0x1a
     838:	ab 8f       	std	Y+27, r26	; 0x1b
     83a:	bc 8f       	std	Y+28, r27	; 0x1c
	if (__tmp < 1.0)
     83c:	11 e0       	ldi	r17, 0x01	; 1
     83e:	69 8d       	ldd	r22, Y+25	; 0x19
     840:	7a 8d       	ldd	r23, Y+26	; 0x1a
     842:	8b 8d       	ldd	r24, Y+27	; 0x1b
     844:	9c 8d       	ldd	r25, Y+28	; 0x1c
     846:	20 e0       	ldi	r18, 0x00	; 0
     848:	30 e0       	ldi	r19, 0x00	; 0
     84a:	40 e8       	ldi	r20, 0x80	; 128
     84c:	5f e3       	ldi	r21, 0x3F	; 63
     84e:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
     852:	88 23       	and	r24, r24
     854:	0c f0       	brlt	.+2      	; 0x858 <CO_collectBatt+0xa0>
     856:	10 e0       	ldi	r17, 0x00	; 0
     858:	11 23       	and	r17, r17
     85a:	29 f0       	breq	.+10     	; 0x866 <CO_collectBatt+0xae>
		__ticks = 1;
     85c:	81 e0       	ldi	r24, 0x01	; 1
     85e:	90 e0       	ldi	r25, 0x00	; 0
     860:	8d 8f       	std	Y+29, r24	; 0x1d
     862:	9e 8f       	std	Y+30, r25	; 0x1e
     864:	46 c0       	rjmp	.+140    	; 0x8f2 <CO_collectBatt+0x13a>
	else if (__tmp > 65535)
     866:	11 e0       	ldi	r17, 0x01	; 1
     868:	69 8d       	ldd	r22, Y+25	; 0x19
     86a:	7a 8d       	ldd	r23, Y+26	; 0x1a
     86c:	8b 8d       	ldd	r24, Y+27	; 0x1b
     86e:	9c 8d       	ldd	r25, Y+28	; 0x1c
     870:	20 e0       	ldi	r18, 0x00	; 0
     872:	3f ef       	ldi	r19, 0xFF	; 255
     874:	4f e7       	ldi	r20, 0x7F	; 127
     876:	57 e4       	ldi	r21, 0x47	; 71
     878:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
     87c:	18 16       	cp	r1, r24
     87e:	0c f0       	brlt	.+2      	; 0x882 <CO_collectBatt+0xca>
     880:	10 e0       	ldi	r17, 0x00	; 0
     882:	11 23       	and	r17, r17
     884:	61 f1       	breq	.+88     	; 0x8de <CO_collectBatt+0x126>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     886:	6d 89       	ldd	r22, Y+21	; 0x15
     888:	7e 89       	ldd	r23, Y+22	; 0x16
     88a:	8f 89       	ldd	r24, Y+23	; 0x17
     88c:	98 8d       	ldd	r25, Y+24	; 0x18
     88e:	20 e0       	ldi	r18, 0x00	; 0
     890:	30 e0       	ldi	r19, 0x00	; 0
     892:	40 e2       	ldi	r20, 0x20	; 32
     894:	51 e4       	ldi	r21, 0x41	; 65
     896:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
     89a:	dc 01       	movw	r26, r24
     89c:	cb 01       	movw	r24, r22
     89e:	bc 01       	movw	r22, r24
     8a0:	cd 01       	movw	r24, r26
     8a2:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
     8a6:	dc 01       	movw	r26, r24
     8a8:	cb 01       	movw	r24, r22
     8aa:	8d 8f       	std	Y+29, r24	; 0x1d
     8ac:	9e 8f       	std	Y+30, r25	; 0x1e
     8ae:	12 c0       	rjmp	.+36     	; 0x8d4 <CO_collectBatt+0x11c>
     8b0:	80 e2       	ldi	r24, 0x20	; 32
     8b2:	93 e0       	ldi	r25, 0x03	; 3
     8b4:	8f 8f       	std	Y+31, r24	; 0x1f
     8b6:	98 a3       	lds	r25, 0x58
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     8b8:	8f 8d       	ldd	r24, Y+31	; 0x1f
     8ba:	98 a1       	lds	r25, 0x48
     8bc:	8c 01       	movw	r16, r24
     8be:	c8 01       	movw	r24, r16
     8c0:	01 97       	sbiw	r24, 0x01	; 1
     8c2:	f1 f7       	brne	.-4      	; 0x8c0 <CO_collectBatt+0x108>
     8c4:	8c 01       	movw	r16, r24
     8c6:	0f 8f       	std	Y+31, r16	; 0x1f
     8c8:	18 a3       	lds	r17, 0x58
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     8ca:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8cc:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8ce:	01 97       	sbiw	r24, 0x01	; 1
     8d0:	8d 8f       	std	Y+29, r24	; 0x1d
     8d2:	9e 8f       	std	Y+30, r25	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8d4:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8d6:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8d8:	00 97       	sbiw	r24, 0x00	; 0
     8da:	51 f7       	brne	.-44     	; 0x8b0 <CO_collectBatt+0xf8>
     8dc:	17 c0       	rjmp	.+46     	; 0x90c <CO_collectBatt+0x154>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     8de:	69 8d       	ldd	r22, Y+25	; 0x19
     8e0:	7a 8d       	ldd	r23, Y+26	; 0x1a
     8e2:	8b 8d       	ldd	r24, Y+27	; 0x1b
     8e4:	9c 8d       	ldd	r25, Y+28	; 0x1c
     8e6:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
     8ea:	dc 01       	movw	r26, r24
     8ec:	cb 01       	movw	r24, r22
     8ee:	8d 8f       	std	Y+29, r24	; 0x1d
     8f0:	9e 8f       	std	Y+30, r25	; 0x1e
     8f2:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8f4:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8f6:	89 a3       	lds	r24, 0x59
     8f8:	9a a3       	lds	r25, 0x5a
     8fa:	89 a1       	lds	r24, 0x49
     8fc:	9a a1       	lds	r25, 0x4a
     8fe:	8c 01       	movw	r16, r24
     900:	f8 01       	movw	r30, r16
     902:	31 97       	sbiw	r30, 0x01	; 1
     904:	f1 f7       	brne	.-4      	; 0x902 <CO_collectBatt+0x14a>
     906:	8f 01       	movw	r16, r30
     908:	09 a3       	lds	r16, 0x59
     90a:	1a a3       	lds	r17, 0x5a
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     90c:	80 e4       	ldi	r24, 0x40	; 64
     90e:	92 e0       	ldi	r25, 0x02	; 2
     910:	0e 94 1b 1a 	call	0x3436	; 0x3436 <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     914:	80 e4       	ldi	r24, 0x40	; 64
     916:	92 e0       	ldi	r25, 0x02	; 2
     918:	20 e4       	ldi	r18, 0x40	; 64
     91a:	32 e0       	ldi	r19, 0x02	; 2
     91c:	f9 01       	movw	r30, r18
     91e:	21 81       	ldd	r18, Z+1	; 0x01
     920:	29 7e       	andi	r18, 0xE9	; 233
     922:	fc 01       	movw	r30, r24
     924:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     926:	80 e4       	ldi	r24, 0x40	; 64
     928:	92 e0       	ldi	r25, 0x02	; 2
     92a:	20 e4       	ldi	r18, 0x40	; 64
     92c:	32 e0       	ldi	r19, 0x02	; 2
     92e:	f9 01       	movw	r30, r18
     930:	24 81       	ldd	r18, Z+4	; 0x04
     932:	28 7f       	andi	r18, 0xF8	; 248
     934:	23 60       	ori	r18, 0x03	; 3
     936:	fc 01       	movw	r30, r24
     938:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     93a:	80 e4       	ldi	r24, 0x40	; 64
     93c:	92 e0       	ldi	r25, 0x02	; 2
     93e:	20 e4       	ldi	r18, 0x40	; 64
     940:	32 e0       	ldi	r19, 0x02	; 2
     942:	f9 01       	movw	r30, r18
     944:	22 81       	ldd	r18, Z+2	; 0x02
     946:	2f 7c       	andi	r18, 0xCF	; 207
     948:	fc 01       	movw	r30, r24
     94a:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     94c:	80 e6       	ldi	r24, 0x60	; 96
     94e:	92 e0       	ldi	r25, 0x02	; 2
     950:	20 e6       	ldi	r18, 0x60	; 96
     952:	32 e0       	ldi	r19, 0x02	; 2
     954:	f9 01       	movw	r30, r18
     956:	20 81       	ld	r18, Z
     958:	20 7e       	andi	r18, 0xE0	; 224
     95a:	21 60       	ori	r18, 0x01	; 1
     95c:	fc 01       	movw	r30, r24
     95e:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     960:	80 e6       	ldi	r24, 0x60	; 96
     962:	92 e0       	ldi	r25, 0x02	; 2
     964:	29 e0       	ldi	r18, 0x09	; 9
     966:	fc 01       	movw	r30, r24
     968:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCB);
     96a:	80 e4       	ldi	r24, 0x40	; 64
     96c:	92 e0       	ldi	r25, 0x02	; 2
     96e:	20 e4       	ldi	r18, 0x40	; 64
     970:	32 e0       	ldi	r19, 0x02	; 2
     972:	f9 01       	movw	r30, r18
     974:	20 81       	ld	r18, Z
     976:	21 60       	ori	r18, 0x01	; 1
     978:	fc 01       	movw	r30, r24
     97a:	20 83       	st	Z, r18
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     97c:	80 e4       	ldi	r24, 0x40	; 64
     97e:	92 e0       	ldi	r25, 0x02	; 2
     980:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     984:	80 e4       	ldi	r24, 0x40	; 64
     986:	92 e0       	ldi	r25, 0x02	; 2
     988:	60 e6       	ldi	r22, 0x60	; 96
     98a:	72 e0       	ldi	r23, 0x02	; 2
     98c:	40 e0       	ldi	r20, 0x00	; 0
     98e:	0e 94 ca 1c 	call	0x3994	; 0x3994 <ADC_Offset_Get_Unsigned>
     992:	8b a3       	lds	r24, 0x5b
    ADC_Disable(&ADCB);
     994:	80 e4       	ldi	r24, 0x40	; 64
     996:	92 e0       	ldi	r25, 0x02	; 2
     998:	20 e4       	ldi	r18, 0x40	; 64
     99a:	32 e0       	ldi	r19, 0x02	; 2
     99c:	f9 01       	movw	r30, r18
     99e:	20 81       	ld	r18, Z
     9a0:	2e 7f       	andi	r18, 0xFE	; 254
     9a2:	fc 01       	movw	r30, r24
     9a4:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     9a6:	80 e6       	ldi	r24, 0x60	; 96
     9a8:	92 e0       	ldi	r25, 0x02	; 2
     9aa:	fc 01       	movw	r30, r24
     9ac:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     9ae:	80 e4       	ldi	r24, 0x40	; 64
     9b0:	92 e0       	ldi	r25, 0x02	; 2
     9b2:	20 e4       	ldi	r18, 0x40	; 64
     9b4:	32 e0       	ldi	r19, 0x02	; 2
     9b6:	f9 01       	movw	r30, r18
     9b8:	23 81       	ldd	r18, Z+3	; 0x03
     9ba:	2f 73       	andi	r18, 0x3F	; 63
     9bc:	fc 01       	movw	r30, r24
     9be:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     9c0:	80 e4       	ldi	r24, 0x40	; 64
     9c2:	92 e0       	ldi	r25, 0x02	; 2
     9c4:	20 e4       	ldi	r18, 0x40	; 64
     9c6:	32 e0       	ldi	r19, 0x02	; 2
     9c8:	f9 01       	movw	r30, r18
     9ca:	20 81       	ld	r18, Z
     9cc:	21 60       	ori	r18, 0x01	; 1
     9ce:	fc 01       	movw	r30, r24
     9d0:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     9d2:	80 e4       	ldi	r24, 0x40	; 64
     9d4:	92 e0       	ldi	r25, 0x02	; 2
     9d6:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     9da:	80 e4       	ldi	r24, 0x40	; 64
     9dc:	92 e0       	ldi	r25, 0x02	; 2
     9de:	20 e4       	ldi	r18, 0x40	; 64
     9e0:	32 e0       	ldi	r19, 0x02	; 2
     9e2:	f9 01       	movw	r30, r18
     9e4:	21 81       	ldd	r18, Z+1	; 0x01
     9e6:	28 60       	ori	r18, 0x08	; 8
     9e8:	fc 01       	movw	r30, r24
     9ea:	21 83       	std	Z+1, r18	; 0x01

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     9ec:	1d 86       	std	Y+13, r1	; 0x0d
     9ee:	1e 86       	std	Y+14, r1	; 0x0e
     9f0:	56 c0       	rjmp	.+172    	; 0xa9e <CO_collectBatt+0x2e6>

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     9f2:	80 e6       	ldi	r24, 0x60	; 96
     9f4:	92 e0       	ldi	r25, 0x02	; 2
     9f6:	fc 01       	movw	r30, r24
     9f8:	83 81       	ldd	r24, Z+3	; 0x03
     9fa:	88 2f       	mov	r24, r24
     9fc:	90 e0       	ldi	r25, 0x00	; 0
     9fe:	81 70       	andi	r24, 0x01	; 1
     a00:	90 70       	andi	r25, 0x00	; 0
     a02:	00 97       	sbiw	r24, 0x00	; 0
     a04:	b1 f3       	breq	.-20     	; 0x9f2 <CO_collectBatt+0x23a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     a06:	2b a1       	lds	r18, 0x4b
     a08:	80 e6       	ldi	r24, 0x60	; 96
     a0a:	92 e0       	ldi	r25, 0x02	; 2
     a0c:	62 2f       	mov	r22, r18
     a0e:	0e 94 74 1a 	call	0x34e8	; 0x34e8 <ADC_ResultCh_GetWord_Signed>
     a12:	8f 87       	std	Y+15, r24	; 0x0f
     a14:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResultB;
     a16:	8f 85       	ldd	r24, Y+15	; 0x0f
     a18:	98 89       	ldd	r25, Y+16	; 0x10
     a1a:	cc 01       	movw	r24, r24
     a1c:	a0 e0       	ldi	r26, 0x00	; 0
     a1e:	b0 e0       	ldi	r27, 0x00	; 0
     a20:	29 81       	ldd	r18, Y+1	; 0x01
     a22:	3a 81       	ldd	r19, Y+2	; 0x02
     a24:	4b 81       	ldd	r20, Y+3	; 0x03
     a26:	5c 81       	ldd	r21, Y+4	; 0x04
     a28:	82 0f       	add	r24, r18
     a2a:	93 1f       	adc	r25, r19
     a2c:	a4 1f       	adc	r26, r20
     a2e:	b5 1f       	adc	r27, r21
     a30:	89 83       	std	Y+1, r24	; 0x01
     a32:	9a 83       	std	Y+2, r25	; 0x02
     a34:	ab 83       	std	Y+3, r26	; 0x03
     a36:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResultB) { max = tempResultB;}
     a38:	8f 85       	ldd	r24, Y+15	; 0x0f
     a3a:	98 89       	ldd	r25, Y+16	; 0x10
     a3c:	9c 01       	movw	r18, r24
     a3e:	40 e0       	ldi	r20, 0x00	; 0
     a40:	50 e0       	ldi	r21, 0x00	; 0
     a42:	89 85       	ldd	r24, Y+9	; 0x09
     a44:	9a 85       	ldd	r25, Y+10	; 0x0a
     a46:	ab 85       	ldd	r26, Y+11	; 0x0b
     a48:	bc 85       	ldd	r27, Y+12	; 0x0c
     a4a:	82 17       	cp	r24, r18
     a4c:	93 07       	cpc	r25, r19
     a4e:	a4 07       	cpc	r26, r20
     a50:	b5 07       	cpc	r27, r21
     a52:	48 f4       	brcc	.+18     	; 0xa66 <CO_collectBatt+0x2ae>
     a54:	8f 85       	ldd	r24, Y+15	; 0x0f
     a56:	98 89       	ldd	r25, Y+16	; 0x10
     a58:	cc 01       	movw	r24, r24
     a5a:	a0 e0       	ldi	r26, 0x00	; 0
     a5c:	b0 e0       	ldi	r27, 0x00	; 0
     a5e:	89 87       	std	Y+9, r24	; 0x09
     a60:	9a 87       	std	Y+10, r25	; 0x0a
     a62:	ab 87       	std	Y+11, r26	; 0x0b
     a64:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResultB) { min = tempResultB;}
     a66:	8f 85       	ldd	r24, Y+15	; 0x0f
     a68:	98 89       	ldd	r25, Y+16	; 0x10
     a6a:	9c 01       	movw	r18, r24
     a6c:	40 e0       	ldi	r20, 0x00	; 0
     a6e:	50 e0       	ldi	r21, 0x00	; 0
     a70:	8d 81       	ldd	r24, Y+5	; 0x05
     a72:	9e 81       	ldd	r25, Y+6	; 0x06
     a74:	af 81       	ldd	r26, Y+7	; 0x07
     a76:	b8 85       	ldd	r27, Y+8	; 0x08
     a78:	28 17       	cp	r18, r24
     a7a:	39 07       	cpc	r19, r25
     a7c:	4a 07       	cpc	r20, r26
     a7e:	5b 07       	cpc	r21, r27
     a80:	48 f4       	brcc	.+18     	; 0xa94 <CO_collectBatt+0x2dc>
     a82:	8f 85       	ldd	r24, Y+15	; 0x0f
     a84:	98 89       	ldd	r25, Y+16	; 0x10
     a86:	cc 01       	movw	r24, r24
     a88:	a0 e0       	ldi	r26, 0x00	; 0
     a8a:	b0 e0       	ldi	r27, 0x00	; 0
     a8c:	8d 83       	std	Y+5, r24	; 0x05
     a8e:	9e 83       	std	Y+6, r25	; 0x06
     a90:	af 83       	std	Y+7, r26	; 0x07
     a92:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     a94:	8d 85       	ldd	r24, Y+13	; 0x0d
     a96:	9e 85       	ldd	r25, Y+14	; 0x0e
     a98:	01 96       	adiw	r24, 0x01	; 1
     a9a:	8d 87       	std	Y+13, r24	; 0x0d
     a9c:	9e 87       	std	Y+14, r25	; 0x0e
     a9e:	8d 85       	ldd	r24, Y+13	; 0x0d
     aa0:	9e 85       	ldd	r25, Y+14	; 0x0e
     aa2:	f4 e0       	ldi	r31, 0x04	; 4
     aa4:	80 30       	cpi	r24, 0x00	; 0
     aa6:	9f 07       	cpc	r25, r31
     aa8:	08 f4       	brcc	.+2      	; 0xaac <CO_collectBatt+0x2f4>
     aaa:	a3 cf       	rjmp	.-186    	; 0x9f2 <CO_collectBatt+0x23a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     aac:	80 e4       	ldi	r24, 0x40	; 64
     aae:	92 e0       	ldi	r25, 0x02	; 2
     ab0:	20 e4       	ldi	r18, 0x40	; 64
     ab2:	32 e0       	ldi	r19, 0x02	; 2
     ab4:	f9 01       	movw	r30, r18
     ab6:	21 81       	ldd	r18, Z+1	; 0x01
     ab8:	27 7f       	andi	r18, 0xF7	; 247
     aba:	fc 01       	movw	r30, r24
     abc:	21 83       	std	Z+1, r18	; 0x01
	ADC_Disable(&ADCB);
     abe:	80 e4       	ldi	r24, 0x40	; 64
     ac0:	92 e0       	ldi	r25, 0x02	; 2
     ac2:	20 e4       	ldi	r18, 0x40	; 64
     ac4:	32 e0       	ldi	r19, 0x02	; 2
     ac6:	f9 01       	movw	r30, r18
     ac8:	20 81       	ld	r18, Z
     aca:	2e 7f       	andi	r18, 0xFE	; 254
     acc:	fc 01       	movw	r30, r24
     ace:	20 83       	st	Z, r18

	average = sum / NUM_SAMPLES;
     ad0:	89 81       	ldd	r24, Y+1	; 0x01
     ad2:	9a 81       	ldd	r25, Y+2	; 0x02
     ad4:	ab 81       	ldd	r26, Y+3	; 0x03
     ad6:	bc 81       	ldd	r27, Y+4	; 0x04
     ad8:	07 2e       	mov	r0, r23
     ada:	7a e0       	ldi	r23, 0x0A	; 10
     adc:	b6 95       	lsr	r27
     ade:	a7 95       	ror	r26
     ae0:	97 95       	ror	r25
     ae2:	87 95       	ror	r24
     ae4:	7a 95       	dec	r23
     ae6:	d1 f7       	brne	.-12     	; 0xadc <CO_collectBatt+0x324>
     ae8:	70 2d       	mov	r23, r0
     aea:	89 8b       	std	Y+17, r24	; 0x11
     aec:	9a 8b       	std	Y+18, r25	; 0x12
     aee:	ab 8b       	std	Y+19, r26	; 0x13
     af0:	bc 8b       	std	Y+20, r27	; 0x14
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     af2:	84 e0       	ldi	r24, 0x04	; 4
     af4:	60 e0       	ldi	r22, 0x00	; 0
     af6:	0e 94 01 33 	call	0x6602	; 0x6602 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     afa:	80 e0       	ldi	r24, 0x00	; 0
     afc:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     b00:	89 89       	ldd	r24, Y+17	; 0x11
     b02:	9a 89       	ldd	r25, Y+18	; 0x12
     b04:	ab 89       	ldd	r26, Y+19	; 0x13
     b06:	bc 89       	ldd	r27, Y+20	; 0x14
     b08:	28 ee       	ldi	r18, 0xE8	; 232
     b0a:	33 e0       	ldi	r19, 0x03	; 3
     b0c:	40 e0       	ldi	r20, 0x00	; 0
     b0e:	50 e0       	ldi	r21, 0x00	; 0
     b10:	bc 01       	movw	r22, r24
     b12:	cd 01       	movw	r24, r26
     b14:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
     b18:	dc 01       	movw	r26, r24
     b1a:	cb 01       	movw	r24, r22
     b1c:	2f ef       	ldi	r18, 0xFF	; 255
     b1e:	3f e0       	ldi	r19, 0x0F	; 15
     b20:	40 e0       	ldi	r20, 0x00	; 0
     b22:	50 e0       	ldi	r21, 0x00	; 0
     b24:	bc 01       	movw	r22, r24
     b26:	cd 01       	movw	r24, r26
     b28:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
     b2c:	da 01       	movw	r26, r20
     b2e:	c9 01       	movw	r24, r18
     b30:	9c 01       	movw	r18, r24
     b32:	22 53       	subi	r18, 0x32	; 50
     b34:	30 40       	sbci	r19, 0x00	; 0
     b36:	8c a1       	lds	r24, 0x4c
     b38:	9d a1       	lds	r25, 0x4d
     b3a:	fc 01       	movw	r30, r24
     b3c:	20 83       	st	Z, r18
     b3e:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     b40:	89 85       	ldd	r24, Y+9	; 0x09
     b42:	9a 85       	ldd	r25, Y+10	; 0x0a
     b44:	ab 85       	ldd	r26, Y+11	; 0x0b
     b46:	bc 85       	ldd	r27, Y+12	; 0x0c
     b48:	28 ee       	ldi	r18, 0xE8	; 232
     b4a:	33 e0       	ldi	r19, 0x03	; 3
     b4c:	40 e0       	ldi	r20, 0x00	; 0
     b4e:	50 e0       	ldi	r21, 0x00	; 0
     b50:	bc 01       	movw	r22, r24
     b52:	cd 01       	movw	r24, r26
     b54:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
     b58:	dc 01       	movw	r26, r24
     b5a:	cb 01       	movw	r24, r22
     b5c:	2f ef       	ldi	r18, 0xFF	; 255
     b5e:	3f e0       	ldi	r19, 0x0F	; 15
     b60:	40 e0       	ldi	r20, 0x00	; 0
     b62:	50 e0       	ldi	r21, 0x00	; 0
     b64:	bc 01       	movw	r22, r24
     b66:	cd 01       	movw	r24, r26
     b68:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
     b6c:	da 01       	movw	r26, r20
     b6e:	c9 01       	movw	r24, r18
     b70:	9c 01       	movw	r18, r24
     b72:	22 53       	subi	r18, 0x32	; 50
     b74:	30 40       	sbci	r19, 0x00	; 0
     b76:	88 a5       	lds	r24, 0x68
     b78:	99 a5       	lds	r25, 0x69
     b7a:	fc 01       	movw	r30, r24
     b7c:	20 83       	st	Z, r18
     b7e:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     b80:	8d 81       	ldd	r24, Y+5	; 0x05
     b82:	9e 81       	ldd	r25, Y+6	; 0x06
     b84:	af 81       	ldd	r26, Y+7	; 0x07
     b86:	b8 85       	ldd	r27, Y+8	; 0x08
     b88:	28 ee       	ldi	r18, 0xE8	; 232
     b8a:	33 e0       	ldi	r19, 0x03	; 3
     b8c:	40 e0       	ldi	r20, 0x00	; 0
     b8e:	50 e0       	ldi	r21, 0x00	; 0
     b90:	bc 01       	movw	r22, r24
     b92:	cd 01       	movw	r24, r26
     b94:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
     b98:	dc 01       	movw	r26, r24
     b9a:	cb 01       	movw	r24, r22
     b9c:	2f ef       	ldi	r18, 0xFF	; 255
     b9e:	3f e0       	ldi	r19, 0x0F	; 15
     ba0:	40 e0       	ldi	r20, 0x00	; 0
     ba2:	50 e0       	ldi	r21, 0x00	; 0
     ba4:	bc 01       	movw	r22, r24
     ba6:	cd 01       	movw	r24, r26
     ba8:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
     bac:	da 01       	movw	r26, r20
     bae:	c9 01       	movw	r24, r18
     bb0:	9c 01       	movw	r18, r24
     bb2:	22 53       	subi	r18, 0x32	; 50
     bb4:	30 40       	sbci	r19, 0x00	; 0
     bb6:	8e a1       	lds	r24, 0x4e
     bb8:	9f a1       	lds	r25, 0x4f
     bba:	fc 01       	movw	r30, r24
     bbc:	20 83       	st	Z, r18
     bbe:	31 83       	std	Z+1, r19	; 0x01
}
     bc0:	a9 96       	adiw	r28, 0x29	; 41
     bc2:	cd bf       	out	0x3d, r28	; 61
     bc4:	de bf       	out	0x3e, r29	; 62
     bc6:	df 91       	pop	r29
     bc8:	cf 91       	pop	r28
     bca:	1f 91       	pop	r17
     bcc:	0f 91       	pop	r16
     bce:	08 95       	ret

00000bd0 <ADCPower>:

void ADCPower(uint8_t on) {
     bd0:	0f 93       	push	r16
     bd2:	1f 93       	push	r17
     bd4:	cf 93       	push	r28
     bd6:	df 93       	push	r29
     bd8:	cd b7       	in	r28, 0x3d	; 61
     bda:	de b7       	in	r29, 0x3e	; 62
     bdc:	2f 97       	sbiw	r28, 0x0f	; 15
     bde:	cd bf       	out	0x3d, r28	; 61
     be0:	de bf       	out	0x3e, r29	; 62
     be2:	8f 87       	std	Y+15, r24	; 0x0f
	
	if (on) {
     be4:	8f 85       	ldd	r24, Y+15	; 0x0f
     be6:	88 23       	and	r24, r24
     be8:	09 f4       	brne	.+2      	; 0xbec <ADCPower+0x1c>
     bea:	ce c0       	rjmp	.+412    	; 0xd88 <ADCPower+0x1b8>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     bec:	80 e0       	ldi	r24, 0x00	; 0
     bee:	96 e0       	ldi	r25, 0x06	; 6
     bf0:	2e ed       	ldi	r18, 0xDE	; 222
     bf2:	fc 01       	movw	r30, r24
     bf4:	21 83       	std	Z+1, r18	; 0x01
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     bf6:	80 e2       	ldi	r24, 0x20	; 32
     bf8:	96 e0       	ldi	r25, 0x06	; 6
     bfa:	2e e0       	ldi	r18, 0x0E	; 14
     bfc:	fc 01       	movw	r30, r24
     bfe:	21 83       	std	Z+1, r18	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     c00:	80 e4       	ldi	r24, 0x40	; 64
     c02:	96 e0       	ldi	r25, 0x06	; 6
     c04:	23 e0       	ldi	r18, 0x03	; 3
     c06:	fc 01       	movw	r30, r24
     c08:	21 83       	std	Z+1, r18	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     c0a:	80 e8       	ldi	r24, 0x80	; 128
     c0c:	96 e0       	ldi	r25, 0x06	; 6
     c0e:	20 e1       	ldi	r18, 0x10	; 16
     c10:	fc 01       	movw	r30, r24
     c12:	21 83       	std	Z+1, r18	; 0x01
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     c14:	80 ea       	ldi	r24, 0xA0	; 160
     c16:	96 e0       	ldi	r25, 0x06	; 6
     c18:	2e e0       	ldi	r18, 0x0E	; 14
     c1a:	fc 01       	movw	r30, r24
     c1c:	21 83       	std	Z+1, r18	; 0x01

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     c1e:	80 e0       	ldi	r24, 0x00	; 0
     c20:	96 e0       	ldi	r25, 0x06	; 6
     c22:	2e e9       	ldi	r18, 0x9E	; 158
     c24:	fc 01       	movw	r30, r24
     c26:	25 83       	std	Z+5, r18	; 0x05
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     c28:	80 e2       	ldi	r24, 0x20	; 32
     c2a:	96 e0       	ldi	r25, 0x06	; 6
     c2c:	28 e0       	ldi	r18, 0x08	; 8
     c2e:	fc 01       	movw	r30, r24
     c30:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     c32:	80 e4       	ldi	r24, 0x40	; 64
     c34:	96 e0       	ldi	r25, 0x06	; 6
     c36:	23 e0       	ldi	r18, 0x03	; 3
     c38:	fc 01       	movw	r30, r24
     c3a:	25 83       	std	Z+5, r18	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     c3c:	80 e8       	ldi	r24, 0x80	; 128
     c3e:	96 e0       	ldi	r25, 0x06	; 6
     c40:	20 e1       	ldi	r18, 0x10	; 16
     c42:	fc 01       	movw	r30, r24
     c44:	25 83       	std	Z+5, r18	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     c46:	80 ea       	ldi	r24, 0xA0	; 160
     c48:	96 e0       	ldi	r25, 0x06	; 6
     c4a:	2e e0       	ldi	r18, 0x0E	; 14
     c4c:	fc 01       	movw	r30, r24
     c4e:	25 83       	std	Z+5, r18	; 0x05
		channelStatus = 0x00; // POR to zeros
     c50:	10 92 72 50 	sts	0x5072, r1
     c54:	80 e0       	ldi	r24, 0x00	; 0
     c56:	90 e0       	ldi	r25, 0x00	; 0
     c58:	a8 ec       	ldi	r26, 0xC8	; 200
     c5a:	b2 e4       	ldi	r27, 0x42	; 66
     c5c:	89 83       	std	Y+1, r24	; 0x01
     c5e:	9a 83       	std	Y+2, r25	; 0x02
     c60:	ab 83       	std	Y+3, r26	; 0x03
     c62:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     c64:	69 81       	ldd	r22, Y+1	; 0x01
     c66:	7a 81       	ldd	r23, Y+2	; 0x02
     c68:	8b 81       	ldd	r24, Y+3	; 0x03
     c6a:	9c 81       	ldd	r25, Y+4	; 0x04
     c6c:	20 e0       	ldi	r18, 0x00	; 0
     c6e:	30 e0       	ldi	r19, 0x00	; 0
     c70:	4a ef       	ldi	r20, 0xFA	; 250
     c72:	55 e4       	ldi	r21, 0x45	; 69
     c74:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
     c78:	dc 01       	movw	r26, r24
     c7a:	cb 01       	movw	r24, r22
     c7c:	8d 83       	std	Y+5, r24	; 0x05
     c7e:	9e 83       	std	Y+6, r25	; 0x06
     c80:	af 83       	std	Y+7, r26	; 0x07
     c82:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     c84:	11 e0       	ldi	r17, 0x01	; 1
     c86:	6d 81       	ldd	r22, Y+5	; 0x05
     c88:	7e 81       	ldd	r23, Y+6	; 0x06
     c8a:	8f 81       	ldd	r24, Y+7	; 0x07
     c8c:	98 85       	ldd	r25, Y+8	; 0x08
     c8e:	20 e0       	ldi	r18, 0x00	; 0
     c90:	30 e0       	ldi	r19, 0x00	; 0
     c92:	40 e8       	ldi	r20, 0x80	; 128
     c94:	5f e3       	ldi	r21, 0x3F	; 63
     c96:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
     c9a:	88 23       	and	r24, r24
     c9c:	0c f0       	brlt	.+2      	; 0xca0 <ADCPower+0xd0>
     c9e:	10 e0       	ldi	r17, 0x00	; 0
     ca0:	11 23       	and	r17, r17
     ca2:	29 f0       	breq	.+10     	; 0xcae <ADCPower+0xde>
		__ticks = 1;
     ca4:	81 e0       	ldi	r24, 0x01	; 1
     ca6:	90 e0       	ldi	r25, 0x00	; 0
     ca8:	89 87       	std	Y+9, r24	; 0x09
     caa:	9a 87       	std	Y+10, r25	; 0x0a
     cac:	46 c0       	rjmp	.+140    	; 0xd3a <ADCPower+0x16a>
	else if (__tmp > 65535)
     cae:	11 e0       	ldi	r17, 0x01	; 1
     cb0:	6d 81       	ldd	r22, Y+5	; 0x05
     cb2:	7e 81       	ldd	r23, Y+6	; 0x06
     cb4:	8f 81       	ldd	r24, Y+7	; 0x07
     cb6:	98 85       	ldd	r25, Y+8	; 0x08
     cb8:	20 e0       	ldi	r18, 0x00	; 0
     cba:	3f ef       	ldi	r19, 0xFF	; 255
     cbc:	4f e7       	ldi	r20, 0x7F	; 127
     cbe:	57 e4       	ldi	r21, 0x47	; 71
     cc0:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
     cc4:	18 16       	cp	r1, r24
     cc6:	0c f0       	brlt	.+2      	; 0xcca <ADCPower+0xfa>
     cc8:	10 e0       	ldi	r17, 0x00	; 0
     cca:	11 23       	and	r17, r17
     ccc:	61 f1       	breq	.+88     	; 0xd26 <ADCPower+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     cce:	69 81       	ldd	r22, Y+1	; 0x01
     cd0:	7a 81       	ldd	r23, Y+2	; 0x02
     cd2:	8b 81       	ldd	r24, Y+3	; 0x03
     cd4:	9c 81       	ldd	r25, Y+4	; 0x04
     cd6:	20 e0       	ldi	r18, 0x00	; 0
     cd8:	30 e0       	ldi	r19, 0x00	; 0
     cda:	40 e2       	ldi	r20, 0x20	; 32
     cdc:	51 e4       	ldi	r21, 0x41	; 65
     cde:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
     ce2:	dc 01       	movw	r26, r24
     ce4:	cb 01       	movw	r24, r22
     ce6:	bc 01       	movw	r22, r24
     ce8:	cd 01       	movw	r24, r26
     cea:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
     cee:	dc 01       	movw	r26, r24
     cf0:	cb 01       	movw	r24, r22
     cf2:	89 87       	std	Y+9, r24	; 0x09
     cf4:	9a 87       	std	Y+10, r25	; 0x0a
     cf6:	12 c0       	rjmp	.+36     	; 0xd1c <ADCPower+0x14c>
     cf8:	80 e2       	ldi	r24, 0x20	; 32
     cfa:	93 e0       	ldi	r25, 0x03	; 3
     cfc:	8b 87       	std	Y+11, r24	; 0x0b
     cfe:	9c 87       	std	Y+12, r25	; 0x0c
     d00:	8b 85       	ldd	r24, Y+11	; 0x0b
     d02:	9c 85       	ldd	r25, Y+12	; 0x0c
     d04:	8c 01       	movw	r16, r24
     d06:	c8 01       	movw	r24, r16
     d08:	01 97       	sbiw	r24, 0x01	; 1
     d0a:	f1 f7       	brne	.-4      	; 0xd08 <ADCPower+0x138>
     d0c:	8c 01       	movw	r16, r24
     d0e:	0b 87       	std	Y+11, r16	; 0x0b
     d10:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     d12:	89 85       	ldd	r24, Y+9	; 0x09
     d14:	9a 85       	ldd	r25, Y+10	; 0x0a
     d16:	01 97       	sbiw	r24, 0x01	; 1
     d18:	89 87       	std	Y+9, r24	; 0x09
     d1a:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     d1c:	89 85       	ldd	r24, Y+9	; 0x09
     d1e:	9a 85       	ldd	r25, Y+10	; 0x0a
     d20:	00 97       	sbiw	r24, 0x00	; 0
     d22:	51 f7       	brne	.-44     	; 0xcf8 <ADCPower+0x128>
     d24:	17 c0       	rjmp	.+46     	; 0xd54 <ADCPower+0x184>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     d26:	6d 81       	ldd	r22, Y+5	; 0x05
     d28:	7e 81       	ldd	r23, Y+6	; 0x06
     d2a:	8f 81       	ldd	r24, Y+7	; 0x07
     d2c:	98 85       	ldd	r25, Y+8	; 0x08
     d2e:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
     d32:	dc 01       	movw	r26, r24
     d34:	cb 01       	movw	r24, r22
     d36:	89 87       	std	Y+9, r24	; 0x09
     d38:	9a 87       	std	Y+10, r25	; 0x0a
     d3a:	89 85       	ldd	r24, Y+9	; 0x09
     d3c:	9a 85       	ldd	r25, Y+10	; 0x0a
     d3e:	8d 87       	std	Y+13, r24	; 0x0d
     d40:	9e 87       	std	Y+14, r25	; 0x0e
     d42:	8d 85       	ldd	r24, Y+13	; 0x0d
     d44:	9e 85       	ldd	r25, Y+14	; 0x0e
     d46:	8c 01       	movw	r16, r24
     d48:	f8 01       	movw	r30, r16
     d4a:	31 97       	sbiw	r30, 0x01	; 1
     d4c:	f1 f7       	brne	.-4      	; 0xd4a <ADCPower+0x17a>
     d4e:	8f 01       	movw	r16, r30
     d50:	0d 87       	std	Y+13, r16	; 0x0d
     d52:	1e 87       	std	Y+14, r17	; 0x0e
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     d54:	80 e4       	ldi	r24, 0x40	; 64
     d56:	96 e0       	ldi	r25, 0x06	; 6
     d58:	20 e4       	ldi	r18, 0x40	; 64
     d5a:	fc 01       	movw	r30, r24
     d5c:	22 83       	std	Z+2, r18	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     d5e:	80 e0       	ldi	r24, 0x00	; 0
     d60:	80 93 73 50 	sts	0x5073, r24
     d64:	80 93 c6 50 	sts	0x50C6, r24
     d68:	80 93 c7 23 	sts	0x23C7, r24
     d6c:	80 93 6b 50 	sts	0x506B, r24
		PortEx_DIRSET(0xFF, PS_BANKA);
     d70:	8f ef       	ldi	r24, 0xFF	; 255
     d72:	61 e0       	ldi	r22, 0x01	; 1
     d74:	0e 94 9d 32 	call	0x653a	; 0x653a <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     d78:	8f ef       	ldi	r24, 0xFF	; 255
     d7a:	61 e0       	ldi	r22, 0x01	; 1
     d7c:	0e 94 69 33 	call	0x66d2	; 0x66d2 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     d80:	8f ef       	ldi	r24, 0xFF	; 255
     d82:	0e 94 3d 08 	call	0x107a	; 0x107a <set_filter>
     d86:	42 c0       	rjmp	.+132    	; 0xe0c <ADCPower+0x23c>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     d88:	80 e0       	ldi	r24, 0x00	; 0
     d8a:	96 e0       	ldi	r25, 0x06	; 6
     d8c:	2e ed       	ldi	r18, 0xDE	; 222
     d8e:	fc 01       	movw	r30, r24
     d90:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     d92:	80 e2       	ldi	r24, 0x20	; 32
     d94:	96 e0       	ldi	r25, 0x06	; 6
     d96:	2e e0       	ldi	r18, 0x0E	; 14
     d98:	fc 01       	movw	r30, r24
     d9a:	26 83       	std	Z+6, r18	; 0x06
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     d9c:	80 e4       	ldi	r24, 0x40	; 64
     d9e:	96 e0       	ldi	r25, 0x06	; 6
     da0:	23 e0       	ldi	r18, 0x03	; 3
     da2:	fc 01       	movw	r30, r24
     da4:	26 83       	std	Z+6, r18	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     da6:	80 e8       	ldi	r24, 0x80	; 128
     da8:	96 e0       	ldi	r25, 0x06	; 6
     daa:	20 e1       	ldi	r18, 0x10	; 16
     dac:	fc 01       	movw	r30, r24
     dae:	26 83       	std	Z+6, r18	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     db0:	80 ea       	ldi	r24, 0xA0	; 160
     db2:	96 e0       	ldi	r25, 0x06	; 6
     db4:	2e e0       	ldi	r18, 0x0E	; 14
     db6:	fc 01       	movw	r30, r24
     db8:	26 83       	std	Z+6, r18	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     dba:	80 e0       	ldi	r24, 0x00	; 0
     dbc:	96 e0       	ldi	r25, 0x06	; 6
     dbe:	2e ed       	ldi	r18, 0xDE	; 222
     dc0:	fc 01       	movw	r30, r24
     dc2:	22 83       	std	Z+2, r18	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     dc4:	80 e2       	ldi	r24, 0x20	; 32
     dc6:	96 e0       	ldi	r25, 0x06	; 6
     dc8:	2e e0       	ldi	r18, 0x0E	; 14
     dca:	fc 01       	movw	r30, r24
     dcc:	22 83       	std	Z+2, r18	; 0x02
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     dce:	80 e4       	ldi	r24, 0x40	; 64
     dd0:	96 e0       	ldi	r25, 0x06	; 6
     dd2:	23 e0       	ldi	r18, 0x03	; 3
     dd4:	fc 01       	movw	r30, r24
     dd6:	22 83       	std	Z+2, r18	; 0x02
		PORTE.DIRCLR = PIN4_bm;
     dd8:	80 e8       	ldi	r24, 0x80	; 128
     dda:	96 e0       	ldi	r25, 0x06	; 6
     ddc:	20 e1       	ldi	r18, 0x10	; 16
     dde:	fc 01       	movw	r30, r24
     de0:	22 83       	std	Z+2, r18	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     de2:	80 ea       	ldi	r24, 0xA0	; 160
     de4:	96 e0       	ldi	r25, 0x06	; 6
     de6:	2e e0       	ldi	r18, 0x0E	; 14
     de8:	fc 01       	movw	r30, r24
     dea:	22 83       	std	Z+2, r18	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     dec:	80 e4       	ldi	r24, 0x40	; 64
     dee:	96 e0       	ldi	r25, 0x06	; 6
     df0:	20 e4       	ldi	r18, 0x40	; 64
     df2:	fc 01       	movw	r30, r24
     df4:	22 83       	std	Z+2, r18	; 0x02
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     df6:	80 e0       	ldi	r24, 0x00	; 0
     df8:	80 93 73 50 	sts	0x5073, r24
     dfc:	80 93 c6 50 	sts	0x50C6, r24
     e00:	80 93 c7 23 	sts	0x23C7, r24
     e04:	80 93 6b 50 	sts	0x506B, r24
		channelStatus = 0x00;
     e08:	10 92 72 50 	sts	0x5072, r1
		
	}
}
     e0c:	2f 96       	adiw	r28, 0x0f	; 15
     e0e:	cd bf       	out	0x3d, r28	; 61
     e10:	de bf       	out	0x3e, r29	; 62
     e12:	df 91       	pop	r29
     e14:	cf 91       	pop	r28
     e16:	1f 91       	pop	r17
     e18:	0f 91       	pop	r16
     e1a:	08 95       	ret

00000e1c <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     e1c:	0f 93       	push	r16
     e1e:	1f 93       	push	r17
     e20:	cf 93       	push	r28
     e22:	df 93       	push	r29
     e24:	cd b7       	in	r28, 0x3d	; 61
     e26:	de b7       	in	r29, 0x3e	; 62
     e28:	6a 97       	sbiw	r28, 0x1a	; 26
     e2a:	cd bf       	out	0x3d, r28	; 61
     e2c:	de bf       	out	0x3e, r29	; 62
     e2e:	89 8f       	std	Y+25, r24	; 0x19
     e30:	6a 8f       	std	Y+26, r22	; 0x1a
	
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     e32:	89 8d       	ldd	r24, Y+25	; 0x19
     e34:	28 2f       	mov	r18, r24
     e36:	30 e0       	ldi	r19, 0x00	; 0
     e38:	81 e0       	ldi	r24, 0x01	; 1
     e3a:	90 e0       	ldi	r25, 0x00	; 0
     e3c:	02 c0       	rjmp	.+4      	; 0xe42 <set_ampGain+0x26>
     e3e:	88 0f       	add	r24, r24
     e40:	99 1f       	adc	r25, r25
     e42:	2a 95       	dec	r18
     e44:	e2 f7       	brpl	.-8      	; 0xe3e <set_ampGain+0x22>
     e46:	61 e0       	ldi	r22, 0x01	; 1
     e48:	0e 94 cc 33 	call	0x6798	; 0x6798 <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     e4c:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e4e:	88 2f       	mov	r24, r24
     e50:	90 e0       	ldi	r25, 0x00	; 0
     e52:	81 70       	andi	r24, 0x01	; 1
     e54:	90 70       	andi	r25, 0x00	; 0
     e56:	88 23       	and	r24, r24
     e58:	31 f0       	breq	.+12     	; 0xe66 <set_ampGain+0x4a>
     e5a:	80 e0       	ldi	r24, 0x00	; 0
     e5c:	96 e0       	ldi	r25, 0x06	; 6
     e5e:	20 e4       	ldi	r18, 0x40	; 64
     e60:	fc 01       	movw	r30, r24
     e62:	25 83       	std	Z+5, r18	; 0x05
     e64:	05 c0       	rjmp	.+10     	; 0xe70 <set_ampGain+0x54>
	else {PORTA.OUTCLR = PIN6_bm;}
     e66:	80 e0       	ldi	r24, 0x00	; 0
     e68:	96 e0       	ldi	r25, 0x06	; 6
     e6a:	20 e4       	ldi	r18, 0x40	; 64
     e6c:	fc 01       	movw	r30, r24
     e6e:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     e70:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e72:	88 2f       	mov	r24, r24
     e74:	90 e0       	ldi	r25, 0x00	; 0
     e76:	82 70       	andi	r24, 0x02	; 2
     e78:	90 70       	andi	r25, 0x00	; 0
     e7a:	00 97       	sbiw	r24, 0x00	; 0
     e7c:	31 f0       	breq	.+12     	; 0xe8a <set_ampGain+0x6e>
     e7e:	80 e2       	ldi	r24, 0x20	; 32
     e80:	96 e0       	ldi	r25, 0x06	; 6
     e82:	22 e0       	ldi	r18, 0x02	; 2
     e84:	fc 01       	movw	r30, r24
     e86:	25 83       	std	Z+5, r18	; 0x05
     e88:	05 c0       	rjmp	.+10     	; 0xe94 <set_ampGain+0x78>
	else {PORTB.OUTCLR = PIN1_bm;}
     e8a:	80 e2       	ldi	r24, 0x20	; 32
     e8c:	96 e0       	ldi	r25, 0x06	; 6
     e8e:	22 e0       	ldi	r18, 0x02	; 2
     e90:	fc 01       	movw	r30, r24
     e92:	26 83       	std	Z+6, r18	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     e94:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e96:	88 2f       	mov	r24, r24
     e98:	90 e0       	ldi	r25, 0x00	; 0
     e9a:	84 70       	andi	r24, 0x04	; 4
     e9c:	90 70       	andi	r25, 0x00	; 0
     e9e:	00 97       	sbiw	r24, 0x00	; 0
     ea0:	31 f0       	breq	.+12     	; 0xeae <set_ampGain+0x92>
     ea2:	80 e2       	ldi	r24, 0x20	; 32
     ea4:	96 e0       	ldi	r25, 0x06	; 6
     ea6:	24 e0       	ldi	r18, 0x04	; 4
     ea8:	fc 01       	movw	r30, r24
     eaa:	25 83       	std	Z+5, r18	; 0x05
     eac:	05 c0       	rjmp	.+10     	; 0xeb8 <set_ampGain+0x9c>
	else {PORTB.OUTCLR = PIN2_bm;}
     eae:	80 e2       	ldi	r24, 0x20	; 32
     eb0:	96 e0       	ldi	r25, 0x06	; 6
     eb2:	24 e0       	ldi	r18, 0x04	; 4
     eb4:	fc 01       	movw	r30, r24
     eb6:	26 83       	std	Z+6, r18	; 0x06
     eb8:	80 e0       	ldi	r24, 0x00	; 0
     eba:	90 e0       	ldi	r25, 0x00	; 0
     ebc:	a0 e8       	ldi	r26, 0x80	; 128
     ebe:	bf e3       	ldi	r27, 0x3F	; 63
     ec0:	89 83       	std	Y+1, r24	; 0x01
     ec2:	9a 83       	std	Y+2, r25	; 0x02
     ec4:	ab 83       	std	Y+3, r26	; 0x03
     ec6:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
     ec8:	69 81       	ldd	r22, Y+1	; 0x01
     eca:	7a 81       	ldd	r23, Y+2	; 0x02
     ecc:	8b 81       	ldd	r24, Y+3	; 0x03
     ece:	9c 81       	ldd	r25, Y+4	; 0x04
     ed0:	2b ea       	ldi	r18, 0xAB	; 171
     ed2:	3a ea       	ldi	r19, 0xAA	; 170
     ed4:	4a e2       	ldi	r20, 0x2A	; 42
     ed6:	51 e4       	ldi	r21, 0x41	; 65
     ed8:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
     edc:	dc 01       	movw	r26, r24
     ede:	cb 01       	movw	r24, r22
     ee0:	8d 83       	std	Y+5, r24	; 0x05
     ee2:	9e 83       	std	Y+6, r25	; 0x06
     ee4:	af 83       	std	Y+7, r26	; 0x07
     ee6:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     ee8:	11 e0       	ldi	r17, 0x01	; 1
     eea:	6d 81       	ldd	r22, Y+5	; 0x05
     eec:	7e 81       	ldd	r23, Y+6	; 0x06
     eee:	8f 81       	ldd	r24, Y+7	; 0x07
     ef0:	98 85       	ldd	r25, Y+8	; 0x08
     ef2:	20 e0       	ldi	r18, 0x00	; 0
     ef4:	30 e0       	ldi	r19, 0x00	; 0
     ef6:	40 e8       	ldi	r20, 0x80	; 128
     ef8:	5f e3       	ldi	r21, 0x3F	; 63
     efa:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
     efe:	88 23       	and	r24, r24
     f00:	0c f0       	brlt	.+2      	; 0xf04 <set_ampGain+0xe8>
     f02:	10 e0       	ldi	r17, 0x00	; 0
     f04:	11 23       	and	r17, r17
     f06:	19 f0       	breq	.+6      	; 0xf0e <set_ampGain+0xf2>
		__ticks = 1;
     f08:	81 e0       	ldi	r24, 0x01	; 1
     f0a:	89 87       	std	Y+9, r24	; 0x09
     f0c:	a3 c0       	rjmp	.+326    	; 0x1054 <set_ampGain+0x238>
	else if (__tmp > 255)
     f0e:	11 e0       	ldi	r17, 0x01	; 1
     f10:	6d 81       	ldd	r22, Y+5	; 0x05
     f12:	7e 81       	ldd	r23, Y+6	; 0x06
     f14:	8f 81       	ldd	r24, Y+7	; 0x07
     f16:	98 85       	ldd	r25, Y+8	; 0x08
     f18:	20 e0       	ldi	r18, 0x00	; 0
     f1a:	30 e0       	ldi	r19, 0x00	; 0
     f1c:	4f e7       	ldi	r20, 0x7F	; 127
     f1e:	53 e4       	ldi	r21, 0x43	; 67
     f20:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
     f24:	18 16       	cp	r1, r24
     f26:	0c f0       	brlt	.+2      	; 0xf2a <set_ampGain+0x10e>
     f28:	10 e0       	ldi	r17, 0x00	; 0
     f2a:	11 23       	and	r17, r17
     f2c:	09 f4       	brne	.+2      	; 0xf30 <set_ampGain+0x114>
     f2e:	89 c0       	rjmp	.+274    	; 0x1042 <set_ampGain+0x226>
	{
		_delay_ms(__us / 1000.0);
     f30:	69 81       	ldd	r22, Y+1	; 0x01
     f32:	7a 81       	ldd	r23, Y+2	; 0x02
     f34:	8b 81       	ldd	r24, Y+3	; 0x03
     f36:	9c 81       	ldd	r25, Y+4	; 0x04
     f38:	20 e0       	ldi	r18, 0x00	; 0
     f3a:	30 e0       	ldi	r19, 0x00	; 0
     f3c:	4a e7       	ldi	r20, 0x7A	; 122
     f3e:	54 e4       	ldi	r21, 0x44	; 68
     f40:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
     f44:	dc 01       	movw	r26, r24
     f46:	cb 01       	movw	r24, r22
     f48:	8a 87       	std	Y+10, r24	; 0x0a
     f4a:	9b 87       	std	Y+11, r25	; 0x0b
     f4c:	ac 87       	std	Y+12, r26	; 0x0c
     f4e:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     f50:	6a 85       	ldd	r22, Y+10	; 0x0a
     f52:	7b 85       	ldd	r23, Y+11	; 0x0b
     f54:	8c 85       	ldd	r24, Y+12	; 0x0c
     f56:	9d 85       	ldd	r25, Y+13	; 0x0d
     f58:	20 e0       	ldi	r18, 0x00	; 0
     f5a:	30 e0       	ldi	r19, 0x00	; 0
     f5c:	4a ef       	ldi	r20, 0xFA	; 250
     f5e:	55 e4       	ldi	r21, 0x45	; 69
     f60:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
     f64:	dc 01       	movw	r26, r24
     f66:	cb 01       	movw	r24, r22
     f68:	8e 87       	std	Y+14, r24	; 0x0e
     f6a:	9f 87       	std	Y+15, r25	; 0x0f
     f6c:	a8 8b       	std	Y+16, r26	; 0x10
     f6e:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
     f70:	11 e0       	ldi	r17, 0x01	; 1
     f72:	6e 85       	ldd	r22, Y+14	; 0x0e
     f74:	7f 85       	ldd	r23, Y+15	; 0x0f
     f76:	88 89       	ldd	r24, Y+16	; 0x10
     f78:	99 89       	ldd	r25, Y+17	; 0x11
     f7a:	20 e0       	ldi	r18, 0x00	; 0
     f7c:	30 e0       	ldi	r19, 0x00	; 0
     f7e:	40 e8       	ldi	r20, 0x80	; 128
     f80:	5f e3       	ldi	r21, 0x3F	; 63
     f82:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
     f86:	88 23       	and	r24, r24
     f88:	0c f0       	brlt	.+2      	; 0xf8c <set_ampGain+0x170>
     f8a:	10 e0       	ldi	r17, 0x00	; 0
     f8c:	11 23       	and	r17, r17
     f8e:	29 f0       	breq	.+10     	; 0xf9a <set_ampGain+0x17e>
		__ticks = 1;
     f90:	81 e0       	ldi	r24, 0x01	; 1
     f92:	90 e0       	ldi	r25, 0x00	; 0
     f94:	8a 8b       	std	Y+18, r24	; 0x12
     f96:	9b 8b       	std	Y+19, r25	; 0x13
     f98:	46 c0       	rjmp	.+140    	; 0x1026 <set_ampGain+0x20a>
	else if (__tmp > 65535)
     f9a:	11 e0       	ldi	r17, 0x01	; 1
     f9c:	6e 85       	ldd	r22, Y+14	; 0x0e
     f9e:	7f 85       	ldd	r23, Y+15	; 0x0f
     fa0:	88 89       	ldd	r24, Y+16	; 0x10
     fa2:	99 89       	ldd	r25, Y+17	; 0x11
     fa4:	20 e0       	ldi	r18, 0x00	; 0
     fa6:	3f ef       	ldi	r19, 0xFF	; 255
     fa8:	4f e7       	ldi	r20, 0x7F	; 127
     faa:	57 e4       	ldi	r21, 0x47	; 71
     fac:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
     fb0:	18 16       	cp	r1, r24
     fb2:	0c f0       	brlt	.+2      	; 0xfb6 <set_ampGain+0x19a>
     fb4:	10 e0       	ldi	r17, 0x00	; 0
     fb6:	11 23       	and	r17, r17
     fb8:	61 f1       	breq	.+88     	; 0x1012 <set_ampGain+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     fba:	6a 85       	ldd	r22, Y+10	; 0x0a
     fbc:	7b 85       	ldd	r23, Y+11	; 0x0b
     fbe:	8c 85       	ldd	r24, Y+12	; 0x0c
     fc0:	9d 85       	ldd	r25, Y+13	; 0x0d
     fc2:	20 e0       	ldi	r18, 0x00	; 0
     fc4:	30 e0       	ldi	r19, 0x00	; 0
     fc6:	40 e2       	ldi	r20, 0x20	; 32
     fc8:	51 e4       	ldi	r21, 0x41	; 65
     fca:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
     fce:	dc 01       	movw	r26, r24
     fd0:	cb 01       	movw	r24, r22
     fd2:	bc 01       	movw	r22, r24
     fd4:	cd 01       	movw	r24, r26
     fd6:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
     fda:	dc 01       	movw	r26, r24
     fdc:	cb 01       	movw	r24, r22
     fde:	8a 8b       	std	Y+18, r24	; 0x12
     fe0:	9b 8b       	std	Y+19, r25	; 0x13
     fe2:	12 c0       	rjmp	.+36     	; 0x1008 <set_ampGain+0x1ec>
     fe4:	80 e2       	ldi	r24, 0x20	; 32
     fe6:	93 e0       	ldi	r25, 0x03	; 3
     fe8:	8c 8b       	std	Y+20, r24	; 0x14
     fea:	9d 8b       	std	Y+21, r25	; 0x15
     fec:	8c 89       	ldd	r24, Y+20	; 0x14
     fee:	9d 89       	ldd	r25, Y+21	; 0x15
     ff0:	8c 01       	movw	r16, r24
     ff2:	c8 01       	movw	r24, r16
     ff4:	01 97       	sbiw	r24, 0x01	; 1
     ff6:	f1 f7       	brne	.-4      	; 0xff4 <set_ampGain+0x1d8>
     ff8:	8c 01       	movw	r16, r24
     ffa:	0c 8b       	std	Y+20, r16	; 0x14
     ffc:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     ffe:	8a 89       	ldd	r24, Y+18	; 0x12
    1000:	9b 89       	ldd	r25, Y+19	; 0x13
    1002:	01 97       	sbiw	r24, 0x01	; 1
    1004:	8a 8b       	std	Y+18, r24	; 0x12
    1006:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1008:	8a 89       	ldd	r24, Y+18	; 0x12
    100a:	9b 89       	ldd	r25, Y+19	; 0x13
    100c:	00 97       	sbiw	r24, 0x00	; 0
    100e:	51 f7       	brne	.-44     	; 0xfe4 <set_ampGain+0x1c8>
    1010:	28 c0       	rjmp	.+80     	; 0x1062 <set_ampGain+0x246>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1012:	6e 85       	ldd	r22, Y+14	; 0x0e
    1014:	7f 85       	ldd	r23, Y+15	; 0x0f
    1016:	88 89       	ldd	r24, Y+16	; 0x10
    1018:	99 89       	ldd	r25, Y+17	; 0x11
    101a:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    101e:	dc 01       	movw	r26, r24
    1020:	cb 01       	movw	r24, r22
    1022:	8a 8b       	std	Y+18, r24	; 0x12
    1024:	9b 8b       	std	Y+19, r25	; 0x13
    1026:	8a 89       	ldd	r24, Y+18	; 0x12
    1028:	9b 89       	ldd	r25, Y+19	; 0x13
    102a:	8e 8b       	std	Y+22, r24	; 0x16
    102c:	9f 8b       	std	Y+23, r25	; 0x17
    102e:	8e 89       	ldd	r24, Y+22	; 0x16
    1030:	9f 89       	ldd	r25, Y+23	; 0x17
    1032:	8c 01       	movw	r16, r24
    1034:	f8 01       	movw	r30, r16
    1036:	31 97       	sbiw	r30, 0x01	; 1
    1038:	f1 f7       	brne	.-4      	; 0x1036 <set_ampGain+0x21a>
    103a:	8f 01       	movw	r16, r30
    103c:	0e 8b       	std	Y+22, r16	; 0x16
    103e:	1f 8b       	std	Y+23, r17	; 0x17
    1040:	10 c0       	rjmp	.+32     	; 0x1062 <set_ampGain+0x246>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1042:	6d 81       	ldd	r22, Y+5	; 0x05
    1044:	7e 81       	ldd	r23, Y+6	; 0x06
    1046:	8f 81       	ldd	r24, Y+7	; 0x07
    1048:	98 85       	ldd	r25, Y+8	; 0x08
    104a:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    104e:	dc 01       	movw	r26, r24
    1050:	cb 01       	movw	r24, r22
    1052:	89 87       	std	Y+9, r24	; 0x09
    1054:	89 85       	ldd	r24, Y+9	; 0x09
    1056:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1058:	88 8d       	ldd	r24, Y+24	; 0x18
    105a:	18 2f       	mov	r17, r24
    105c:	1a 95       	dec	r17
    105e:	f1 f7       	brne	.-4      	; 0x105c <set_ampGain+0x240>
    1060:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    1062:	8f ef       	ldi	r24, 0xFF	; 255
    1064:	61 e0       	ldi	r22, 0x01	; 1
    1066:	0e 94 69 33 	call	0x66d2	; 0x66d2 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    106a:	6a 96       	adiw	r28, 0x1a	; 26
    106c:	cd bf       	out	0x3d, r28	; 61
    106e:	de bf       	out	0x3e, r29	; 62
    1070:	df 91       	pop	r29
    1072:	cf 91       	pop	r28
    1074:	1f 91       	pop	r17
    1076:	0f 91       	pop	r16
    1078:	08 95       	ret

0000107a <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
    107a:	cf 93       	push	r28
    107c:	df 93       	push	r29
    107e:	00 d0       	rcall	.+0      	; 0x1080 <set_filter+0x6>
    1080:	cd b7       	in	r28, 0x3d	; 61
    1082:	de b7       	in	r29, 0x3e	; 62
    1084:	8b 83       	std	Y+3, r24	; 0x03
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
    1086:	8b 81       	ldd	r24, Y+3	; 0x03
    1088:	83 70       	andi	r24, 0x03	; 3
    108a:	89 83       	std	Y+1, r24	; 0x01
	uint8_t upperCS = filterConfig & 0x0C;
    108c:	8b 81       	ldd	r24, Y+3	; 0x03
    108e:	8c 70       	andi	r24, 0x0C	; 12
    1090:	8a 83       	std	Y+2, r24	; 0x02

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
    1092:	8b 81       	ldd	r24, Y+3	; 0x03
    1094:	88 2f       	mov	r24, r24
    1096:	90 e0       	ldi	r25, 0x00	; 0
    1098:	85 70       	andi	r24, 0x05	; 5
    109a:	90 70       	andi	r25, 0x00	; 0
    109c:	00 97       	sbiw	r24, 0x00	; 0
    109e:	51 f0       	breq	.+20     	; 0x10b4 <set_filter+0x3a>
    10a0:	80 91 72 50 	lds	r24, 0x5072
    10a4:	98 2f       	mov	r25, r24
    10a6:	90 7f       	andi	r25, 0xF0	; 240
    10a8:	8b 81       	ldd	r24, Y+3	; 0x03
    10aa:	82 95       	swap	r24
    10ac:	8f 70       	andi	r24, 0x0F	; 15
    10ae:	89 2b       	or	r24, r25
    10b0:	80 93 72 50 	sts	0x5072, r24
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
    10b4:	8b 81       	ldd	r24, Y+3	; 0x03
    10b6:	88 2f       	mov	r24, r24
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	8a 70       	andi	r24, 0x0A	; 10
    10bc:	90 70       	andi	r25, 0x00	; 0
    10be:	00 97       	sbiw	r24, 0x00	; 0
    10c0:	49 f0       	breq	.+18     	; 0x10d4 <set_filter+0x5a>
    10c2:	8b 81       	ldd	r24, Y+3	; 0x03
    10c4:	98 2f       	mov	r25, r24
    10c6:	90 7f       	andi	r25, 0xF0	; 240
    10c8:	80 91 72 50 	lds	r24, 0x5072
    10cc:	8f 70       	andi	r24, 0x0F	; 15
    10ce:	89 2b       	or	r24, r25
    10d0:	80 93 72 50 	sts	0x5072, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
    10d4:	84 e0       	ldi	r24, 0x04	; 4
    10d6:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
    10da:	80 91 72 50 	lds	r24, 0x5072
    10de:	80 93 56 50 	sts	0x5056, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
    10e2:	89 81       	ldd	r24, Y+1	; 0x01
    10e4:	88 23       	and	r24, r24
    10e6:	19 f0       	breq	.+6      	; 0x10ee <set_filter+0x74>
    10e8:	81 e0       	ldi	r24, 0x01	; 1
    10ea:	0e 94 09 37 	call	0x6e12	; 0x6e12 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
    10ee:	8a 81       	ldd	r24, Y+2	; 0x02
    10f0:	88 23       	and	r24, r24
    10f2:	19 f0       	breq	.+6      	; 0x10fa <set_filter+0x80>
    10f4:	81 e0       	ldi	r24, 0x01	; 1
    10f6:	0e 94 21 37 	call	0x6e42	; 0x6e42 <upperMuxCS>

	SPICS(TRUE);
    10fa:	81 e0       	ldi	r24, 0x01	; 1
    10fc:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
    1100:	80 ec       	ldi	r24, 0xC0	; 192
    1102:	98 e0       	ldi	r25, 0x08	; 8
    1104:	2f ef       	ldi	r18, 0xFF	; 255
    1106:	fc 01       	movw	r30, r24
    1108:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    110a:	00 00       	nop
    110c:	80 ec       	ldi	r24, 0xC0	; 192
    110e:	98 e0       	ldi	r25, 0x08	; 8
    1110:	fc 01       	movw	r30, r24
    1112:	82 81       	ldd	r24, Z+2	; 0x02
    1114:	88 23       	and	r24, r24
    1116:	d4 f7       	brge	.-12     	; 0x110c <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
    1118:	80 ec       	ldi	r24, 0xC0	; 192
    111a:	98 e0       	ldi	r25, 0x08	; 8
    111c:	fc 01       	movw	r30, r24
    111e:	83 81       	ldd	r24, Z+3	; 0x03
    1120:	80 93 62 50 	sts	0x5062, r24

	nop();
    1124:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
    1126:	80 ec       	ldi	r24, 0xC0	; 192
    1128:	98 e0       	ldi	r25, 0x08	; 8
    112a:	20 91 56 50 	lds	r18, 0x5056
    112e:	fc 01       	movw	r30, r24
    1130:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1132:	00 00       	nop
    1134:	80 ec       	ldi	r24, 0xC0	; 192
    1136:	98 e0       	ldi	r25, 0x08	; 8
    1138:	fc 01       	movw	r30, r24
    113a:	82 81       	ldd	r24, Z+2	; 0x02
    113c:	88 23       	and	r24, r24
    113e:	d4 f7       	brge	.-12     	; 0x1134 <set_filter+0xba>
	SPIBuffer[12] = SPIC.DATA;
    1140:	80 ec       	ldi	r24, 0xC0	; 192
    1142:	98 e0       	ldi	r25, 0x08	; 8
    1144:	fc 01       	movw	r30, r24
    1146:	83 81       	ldd	r24, Z+3	; 0x03
    1148:	80 93 62 50 	sts	0x5062, r24
	SPICS(FALSE);
    114c:	80 e0       	ldi	r24, 0x00	; 0
    114e:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
    1152:	89 81       	ldd	r24, Y+1	; 0x01
    1154:	88 23       	and	r24, r24
    1156:	19 f0       	breq	.+6      	; 0x115e <set_filter+0xe4>
    1158:	80 e0       	ldi	r24, 0x00	; 0
    115a:	0e 94 09 37 	call	0x6e12	; 0x6e12 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
    115e:	8a 81       	ldd	r24, Y+2	; 0x02
    1160:	88 23       	and	r24, r24
    1162:	19 f0       	breq	.+6      	; 0x116a <set_filter+0xf0>
    1164:	80 e0       	ldi	r24, 0x00	; 0
    1166:	0e 94 21 37 	call	0x6e42	; 0x6e42 <upperMuxCS>
	SPIDisable();
    116a:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>
}
    116e:	23 96       	adiw	r28, 0x03	; 3
    1170:	cd bf       	out	0x3d, r28	; 61
    1172:	de bf       	out	0x3e, r29	; 62
    1174:	df 91       	pop	r29
    1176:	cf 91       	pop	r28
    1178:	08 95       	ret

0000117a <enableADCMUX>:

void enableADCMUX(uint8_t on) {
    117a:	cf 93       	push	r28
    117c:	df 93       	push	r29
    117e:	0f 92       	push	r0
    1180:	cd b7       	in	r28, 0x3d	; 61
    1182:	de b7       	in	r29, 0x3e	; 62
    1184:	89 83       	std	Y+1, r24	; 0x01
	
	if(on) {
    1186:	89 81       	ldd	r24, Y+1	; 0x01
    1188:	88 23       	and	r24, r24
    118a:	59 f0       	breq	.+22     	; 0x11a2 <enableADCMUX+0x28>
		PORTA.DIRSET = PIN5_bm;
    118c:	80 e0       	ldi	r24, 0x00	; 0
    118e:	96 e0       	ldi	r25, 0x06	; 6
    1190:	20 e2       	ldi	r18, 0x20	; 32
    1192:	fc 01       	movw	r30, r24
    1194:	21 83       	std	Z+1, r18	; 0x01
		PORTA.OUTSET = PIN5_bm;
    1196:	80 e0       	ldi	r24, 0x00	; 0
    1198:	96 e0       	ldi	r25, 0x06	; 6
    119a:	20 e2       	ldi	r18, 0x20	; 32
    119c:	fc 01       	movw	r30, r24
    119e:	25 83       	std	Z+5, r18	; 0x05
    11a0:	0a c0       	rjmp	.+20     	; 0x11b6 <enableADCMUX+0x3c>
	} else {
		PORTA.OUTCLR = PIN5_bm;
    11a2:	80 e0       	ldi	r24, 0x00	; 0
    11a4:	96 e0       	ldi	r25, 0x06	; 6
    11a6:	20 e2       	ldi	r18, 0x20	; 32
    11a8:	fc 01       	movw	r30, r24
    11aa:	26 83       	std	Z+6, r18	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    11ac:	80 e0       	ldi	r24, 0x00	; 0
    11ae:	96 e0       	ldi	r25, 0x06	; 6
    11b0:	20 e2       	ldi	r18, 0x20	; 32
    11b2:	fc 01       	movw	r30, r24
    11b4:	22 83       	std	Z+2, r18	; 0x02
	}
}
    11b6:	0f 90       	pop	r0
    11b8:	df 91       	pop	r29
    11ba:	cf 91       	pop	r28
    11bc:	08 95       	ret

000011be <CO_collectADC>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint16_t SPS, uint32_t numOfSamples, int32_t* DataArray) {
    11be:	cf 92       	push	r12
    11c0:	df 92       	push	r13
    11c2:	ef 92       	push	r14
    11c4:	ff 92       	push	r15
    11c6:	0f 93       	push	r16
    11c8:	1f 93       	push	r17
    11ca:	cf 93       	push	r28
    11cc:	df 93       	push	r29
    11ce:	cd b7       	in	r28, 0x3d	; 61
    11d0:	de b7       	in	r29, 0x3e	; 62
    11d2:	2d 97       	sbiw	r28, 0x0d	; 13
    11d4:	cd bf       	out	0x3d, r28	; 61
    11d6:	de bf       	out	0x3e, r29	; 62
    11d8:	8b 83       	std	Y+3, r24	; 0x03
    11da:	6c 83       	std	Y+4, r22	; 0x04
    11dc:	4d 83       	std	Y+5, r20	; 0x05
    11de:	2e 83       	std	Y+6, r18	; 0x06
    11e0:	3f 83       	std	Y+7, r19	; 0x07
    11e2:	e8 86       	std	Y+8, r14	; 0x08
    11e4:	f9 86       	std	Y+9, r15	; 0x09
    11e6:	0a 87       	std	Y+10, r16	; 0x0a
    11e8:	1b 87       	std	Y+11, r17	; 0x0b
    11ea:	cc 86       	std	Y+12, r12	; 0x0c
    11ec:	dd 86       	std	Y+13, r13	; 0x0d


	uint16_t period;
	ADC_BUFFER = DataArray;
    11ee:	8c 85       	ldd	r24, Y+12	; 0x0c
    11f0:	9d 85       	ldd	r25, Y+13	; 0x0d
    11f2:	80 93 63 50 	sts	0x5063, r24
    11f6:	90 93 64 50 	sts	0x5064, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    11fa:	81 e0       	ldi	r24, 0x01	; 1
    11fc:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    1200:	8b 81       	ldd	r24, Y+3	; 0x03
    1202:	6d 81       	ldd	r22, Y+5	; 0x05
    1204:	0e 94 0e 07 	call	0xe1c	; 0xe1c <set_ampGain>
	set_filter(filterConfig);
    1208:	8c 81       	ldd	r24, Y+4	; 0x04
    120a:	0e 94 3d 08 	call	0x107a	; 0x107a <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    120e:	8b 81       	ldd	r24, Y+3	; 0x03
    1210:	85 30       	cpi	r24, 0x05	; 5
    1212:	31 f0       	breq	.+12     	; 0x1220 <CO_collectADC+0x62>
    1214:	8b 81       	ldd	r24, Y+3	; 0x03
    1216:	86 30       	cpi	r24, 0x06	; 6
    1218:	19 f0       	breq	.+6      	; 0x1220 <CO_collectADC+0x62>
    121a:	8b 81       	ldd	r24, Y+3	; 0x03
    121c:	87 30       	cpi	r24, 0x07	; 7
    121e:	19 f4       	brne	.+6      	; 0x1226 <CO_collectADC+0x68>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    1220:	81 e0       	ldi	r24, 0x01	; 1
    1222:	0e 94 1c 0e 	call	0x1c38	; 0x1c38 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    1226:	81 e0       	ldi	r24, 0x01	; 1
    1228:	0e 94 bd 08 	call	0x117a	; 0x117a <enableADCMUX>
	setADCInput(channel);
    122c:	8b 81       	ldd	r24, Y+3	; 0x03
    122e:	0e 94 db 19 	call	0x33b6	; 0x33b6 <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    1232:	84 e0       	ldi	r24, 0x04	; 4
    1234:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1238:	80 ec       	ldi	r24, 0xC0	; 192
    123a:	98 e0       	ldi	r25, 0x08	; 8
    123c:	24 e5       	ldi	r18, 0x54	; 84
    123e:	fc 01       	movw	r30, r24
    1240:	20 83       	st	Z, r18
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    1242:	80 ea       	ldi	r24, 0xA0	; 160
    1244:	96 e0       	ldi	r25, 0x06	; 6
    1246:	21 e0       	ldi	r18, 0x01	; 1
    1248:	fc 01       	movw	r30, r24
    124a:	22 83       	std	Z+2, r18	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    124c:	80 ea       	ldi	r24, 0xA0	; 160
    124e:	96 e0       	ldi	r25, 0x06	; 6
    1250:	22 e0       	ldi	r18, 0x02	; 2
    1252:	fc 01       	movw	r30, r24
    1254:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    1256:	80 ea       	ldi	r24, 0xA0	; 160
    1258:	96 e0       	ldi	r25, 0x06	; 6
    125a:	21 e0       	ldi	r18, 0x01	; 1
    125c:	fc 01       	movw	r30, r24
    125e:	22 87       	std	Z+10, r18	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_LO_gc;				
    1260:	80 ea       	ldi	r24, 0xA0	; 160
    1262:	96 e0       	ldi	r25, 0x06	; 6
    1264:	21 e0       	ldi	r18, 0x01	; 1
    1266:	fc 01       	movw	r30, r24
    1268:	21 87       	std	Z+9, r18	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    126a:	80 e8       	ldi	r24, 0x80	; 128
    126c:	96 e0       	ldi	r25, 0x06	; 6
    126e:	20 e2       	ldi	r18, 0x20	; 32
    1270:	fc 01       	movw	r30, r24
    1272:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1274:	80 e4       	ldi	r24, 0x40	; 64
    1276:	9a e0       	ldi	r25, 0x0A	; 10
    1278:	23 e2       	ldi	r18, 0x23	; 35
    127a:	fc 01       	movw	r30, r24
    127c:	21 83       	std	Z+1, r18	; 0x01
	// set period
	//period = (1 << (21 - spsExponent)) - 1;
	period = (F_CPU/16)/SPS;
    127e:	8e 81       	ldd	r24, Y+6	; 0x06
    1280:	9f 81       	ldd	r25, Y+7	; 0x07
    1282:	9c 01       	movw	r18, r24
    1284:	40 e0       	ldi	r20, 0x00	; 0
    1286:	50 e0       	ldi	r21, 0x00	; 0
    1288:	80 e8       	ldi	r24, 0x80	; 128
    128a:	94 e8       	ldi	r25, 0x84	; 132
    128c:	ae e1       	ldi	r26, 0x1E	; 30
    128e:	b0 e0       	ldi	r27, 0x00	; 0
    1290:	bc 01       	movw	r22, r24
    1292:	cd 01       	movw	r24, r26
    1294:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    1298:	da 01       	movw	r26, r20
    129a:	c9 01       	movw	r24, r18
    129c:	89 83       	std	Y+1, r24	; 0x01
    129e:	9a 83       	std	Y+2, r25	; 0x02
	TCE1.PER = period;
    12a0:	80 e4       	ldi	r24, 0x40	; 64
    12a2:	9a e0       	ldi	r25, 0x0A	; 10
    12a4:	29 81       	ldd	r18, Y+1	; 0x01
    12a6:	3a 81       	ldd	r19, Y+2	; 0x02
    12a8:	fc 01       	movw	r30, r24
    12aa:	26 a3       	lds	r18, 0x56
    12ac:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = period / 2;
    12ae:	80 e4       	ldi	r24, 0x40	; 64
    12b0:	9a e0       	ldi	r25, 0x0A	; 10
    12b2:	29 81       	ldd	r18, Y+1	; 0x01
    12b4:	3a 81       	ldd	r19, Y+2	; 0x02
    12b6:	36 95       	lsr	r19
    12b8:	27 95       	ror	r18
    12ba:	fc 01       	movw	r30, r24
    12bc:	22 af       	sts	0x72, r18
    12be:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    12c0:	80 e4       	ldi	r24, 0x40	; 64
    12c2:	9a e0       	ldi	r25, 0x0A	; 10
    12c4:	20 e4       	ldi	r18, 0x40	; 64
    12c6:	3a e0       	ldi	r19, 0x0A	; 10
    12c8:	f9 01       	movw	r30, r18
    12ca:	20 81       	ld	r18, Z
    12cc:	20 7f       	andi	r18, 0xF0	; 240
    12ce:	21 60       	ori	r18, 0x01	; 1
    12d0:	fc 01       	movw	r30, r24
    12d2:	20 83       	st	Z, r18
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    12d4:	80 ea       	ldi	r24, 0xA0	; 160
    12d6:	90 e0       	ldi	r25, 0x00	; 0
    12d8:	20 ea       	ldi	r18, 0xA0	; 160
    12da:	30 e0       	ldi	r19, 0x00	; 0
    12dc:	f9 01       	movw	r30, r18
    12de:	22 81       	ldd	r18, Z+2	; 0x02
    12e0:	21 60       	ori	r18, 0x01	; 1
    12e2:	fc 01       	movw	r30, r24
    12e4:	22 83       	std	Z+2, r18	; 0x02
	sei();
    12e6:	78 94       	sei

	sampleCount = 0;
    12e8:	10 92 65 50 	sts	0x5065, r1
    12ec:	10 92 66 50 	sts	0x5066, r1
    12f0:	10 92 67 50 	sts	0x5067, r1
    12f4:	10 92 68 50 	sts	0x5068, r1
	discardCount = 0;
    12f8:	10 92 4e 40 	sts	0x404E, r1
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    12fc:	00 00       	nop
    12fe:	20 91 65 50 	lds	r18, 0x5065
    1302:	30 91 66 50 	lds	r19, 0x5066
    1306:	40 91 67 50 	lds	r20, 0x5067
    130a:	50 91 68 50 	lds	r21, 0x5068
    130e:	88 85       	ldd	r24, Y+8	; 0x08
    1310:	99 85       	ldd	r25, Y+9	; 0x09
    1312:	aa 85       	ldd	r26, Y+10	; 0x0a
    1314:	bb 85       	ldd	r27, Y+11	; 0x0b
    1316:	28 17       	cp	r18, r24
    1318:	39 07       	cpc	r19, r25
    131a:	4a 07       	cpc	r20, r26
    131c:	5b 07       	cpc	r21, r27
    131e:	78 f3       	brcs	.-34     	; 0x12fe <CO_collectADC+0x140>

	// turn off timer and interupts
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1320:	80 e4       	ldi	r24, 0x40	; 64
    1322:	9a e0       	ldi	r25, 0x0A	; 10
    1324:	20 e4       	ldi	r18, 0x40	; 64
    1326:	3a e0       	ldi	r19, 0x0A	; 10
    1328:	f9 01       	movw	r30, r18
    132a:	20 81       	ld	r18, Z
    132c:	20 7f       	andi	r18, 0xF0	; 240
    132e:	fc 01       	movw	r30, r24
    1330:	20 83       	st	Z, r18
	PMIC.CTRL &= ~PMIC_LOLVLEN_bm;	
    1332:	80 ea       	ldi	r24, 0xA0	; 160
    1334:	90 e0       	ldi	r25, 0x00	; 0
    1336:	20 ea       	ldi	r18, 0xA0	; 160
    1338:	30 e0       	ldi	r19, 0x00	; 0
    133a:	f9 01       	movw	r30, r18
    133c:	22 81       	ldd	r18, Z+2	; 0x02
    133e:	2e 7f       	andi	r18, 0xFE	; 254
    1340:	fc 01       	movw	r30, r24
    1342:	22 83       	std	Z+2, r18	; 0x02
	cli();
    1344:	f8 94       	cli

	SPIDisable();	
    1346:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>
	enableADCMUX(FALSE);
    134a:	80 e0       	ldi	r24, 0x00	; 0
    134c:	0e 94 bd 08 	call	0x117a	; 0x117a <enableADCMUX>
	//ADCPower(FALSE);
}
    1350:	2d 96       	adiw	r28, 0x0d	; 13
    1352:	cd bf       	out	0x3d, r28	; 61
    1354:	de bf       	out	0x3e, r29	; 62
    1356:	df 91       	pop	r29
    1358:	cf 91       	pop	r28
    135a:	1f 91       	pop	r17
    135c:	0f 91       	pop	r16
    135e:	ff 90       	pop	r15
    1360:	ef 90       	pop	r14
    1362:	df 90       	pop	r13
    1364:	cf 90       	pop	r12
    1366:	08 95       	ret

00001368 <CO_collectADC_cont>:

//continuously take samples and send them via radio. NOT RECOMMENDET
void CO_collectADC_cont(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent) {
    1368:	cf 93       	push	r28
    136a:	df 93       	push	r29
    136c:	00 d0       	rcall	.+0      	; 0x136e <CO_collectADC_cont+0x6>
    136e:	00 d0       	rcall	.+0      	; 0x1370 <CO_collectADC_cont+0x8>
    1370:	cd b7       	in	r28, 0x3d	; 61
    1372:	de b7       	in	r29, 0x3e	; 62
    1374:	8b 83       	std	Y+3, r24	; 0x03
    1376:	6c 83       	std	Y+4, r22	; 0x04
    1378:	4d 83       	std	Y+5, r20	; 0x05
    137a:	2e 83       	std	Y+6, r18	; 0x06

uint16_t period;

// Turn on power to ADC and PortEx
ADCPower(TRUE);
    137c:	81 e0       	ldi	r24, 0x01	; 1
    137e:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>
//get data to write files to SD card
//getBootSectorData();
// set gain, filters, and ADC input for appropriate VIN
set_ampGain(channel, gainExponent);
    1382:	8b 81       	ldd	r24, Y+3	; 0x03
    1384:	6d 81       	ldd	r22, Y+5	; 0x05
    1386:	0e 94 0e 07 	call	0xe1c	; 0xe1c <set_ampGain>
set_filter(filterConfig);
    138a:	8c 81       	ldd	r24, Y+4	; 0x04
    138c:	0e 94 3d 08 	call	0x107a	; 0x107a <set_filter>

// if acc channel then enable DC Pass
// it is assumed that if not using high frequency acc specific function then
// DC Pass is wanted.
if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) ||
    1390:	8b 81       	ldd	r24, Y+3	; 0x03
    1392:	85 30       	cpi	r24, 0x05	; 5
    1394:	31 f0       	breq	.+12     	; 0x13a2 <CO_collectADC_cont+0x3a>
    1396:	8b 81       	ldd	r24, Y+3	; 0x03
    1398:	86 30       	cpi	r24, 0x06	; 6
    139a:	19 f0       	breq	.+6      	; 0x13a2 <CO_collectADC_cont+0x3a>
    139c:	8b 81       	ldd	r24, Y+3	; 0x03
    139e:	87 30       	cpi	r24, 0x07	; 7
    13a0:	19 f4       	brne	.+6      	; 0x13a8 <CO_collectADC_cont+0x40>
(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    13a2:	81 e0       	ldi	r24, 0x01	; 1
    13a4:	0e 94 1c 0e 	call	0x1c38	; 0x1c38 <ACC_DCPassEnable>

enableADCMUX(TRUE);
    13a8:	81 e0       	ldi	r24, 0x01	; 1
    13aa:	0e 94 bd 08 	call	0x117a	; 0x117a <enableADCMUX>
setADCInput(channel);
    13ae:	8b 81       	ldd	r24, Y+3	; 0x03
    13b0:	0e 94 db 19 	call	0x33b6	; 0x33b6 <setADCInput>
SPIInit(SPI_MODE_1_gc);
    13b4:	84 e0       	ldi	r24, 0x04	; 4
    13b6:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>
SPIC.CTRL = ADC_SPI_CONFIG_gc;
    13ba:	80 ec       	ldi	r24, 0xC0	; 192
    13bc:	98 e0       	ldi	r25, 0x08	; 8
    13be:	24 e5       	ldi	r18, 0x54	; 84
    13c0:	fc 01       	movw	r30, r24
    13c2:	20 83       	st	Z, r18

// Configure IO13 (PF0) to capture ADC DRDY signal
PORTF.DIRCLR = PIN0_bm;
    13c4:	80 ea       	ldi	r24, 0xA0	; 160
    13c6:	96 e0       	ldi	r25, 0x06	; 6
    13c8:	21 e0       	ldi	r18, 0x01	; 1
    13ca:	fc 01       	movw	r30, r24
    13cc:	22 83       	std	Z+2, r18	; 0x02
PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    13ce:	80 ea       	ldi	r24, 0xA0	; 160
    13d0:	96 e0       	ldi	r25, 0x06	; 6
    13d2:	22 e0       	ldi	r18, 0x02	; 2
    13d4:	fc 01       	movw	r30, r24
    13d6:	20 8b       	std	Z+16, r18	; 0x10
//PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_PULLUP_gc;
PORTF.INT1MASK = PIN0_bm;
    13d8:	80 ea       	ldi	r24, 0xA0	; 160
    13da:	96 e0       	ldi	r25, 0x06	; 6
    13dc:	21 e0       	ldi	r18, 0x01	; 1
    13de:	fc 01       	movw	r30, r24
    13e0:	23 87       	std	Z+11, r18	; 0x0b
PORTF.INTCTRL = PORT_INT1LVL_MED_gc;
    13e2:	80 ea       	ldi	r24, 0xA0	; 160
    13e4:	96 e0       	ldi	r25, 0x06	; 6
    13e6:	28 e0       	ldi	r18, 0x08	; 8
    13e8:	fc 01       	movw	r30, r24
    13ea:	21 87       	std	Z+9, r18	; 0x09
//f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
//the TCE1 counter increments every pulse of the system clock and once it reaches a certain value it 
//toggles pin 5 (clock input to ADC). This effectively divides the system clock into a desired clock rate for 
//the ADC. 
// Set IO14 (PE5) to output
PORTE.DIRSET = PIN5_bm;
    13ec:	80 e8       	ldi	r24, 0x80	; 128
    13ee:	96 e0       	ldi	r25, 0x06	; 6
    13f0:	20 e2       	ldi	r18, 0x20	; 32
    13f2:	fc 01       	movw	r30, r24
    13f4:	21 83       	std	Z+1, r18	; 0x01
// Set Waveform generator mode(single slope) and enable the CCx output to IO14 (PE5)
TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    13f6:	80 e4       	ldi	r24, 0x40	; 64
    13f8:	9a e0       	ldi	r25, 0x0A	; 10
    13fa:	23 e2       	ldi	r18, 0x23	; 35
    13fc:	fc 01       	movw	r30, r24
    13fe:	21 83       	std	Z+1, r18	; 0x01
// set period
period = (1 << (21 - spsExponent)) - 1;
    1400:	8e 81       	ldd	r24, Y+6	; 0x06
    1402:	88 2f       	mov	r24, r24
    1404:	90 e0       	ldi	r25, 0x00	; 0
    1406:	25 e1       	ldi	r18, 0x15	; 21
    1408:	30 e0       	ldi	r19, 0x00	; 0
    140a:	28 1b       	sub	r18, r24
    140c:	39 0b       	sbc	r19, r25
    140e:	81 e0       	ldi	r24, 0x01	; 1
    1410:	90 e0       	ldi	r25, 0x00	; 0
    1412:	02 c0       	rjmp	.+4      	; 0x1418 <CO_collectADC_cont+0xb0>
    1414:	88 0f       	add	r24, r24
    1416:	99 1f       	adc	r25, r25
    1418:	2a 95       	dec	r18
    141a:	e2 f7       	brpl	.-8      	; 0x1414 <CO_collectADC_cont+0xac>
    141c:	01 97       	sbiw	r24, 0x01	; 1
    141e:	89 83       	std	Y+1, r24	; 0x01
    1420:	9a 83       	std	Y+2, r25	; 0x02
TCE1.PER = period;
    1422:	80 e4       	ldi	r24, 0x40	; 64
    1424:	9a e0       	ldi	r25, 0x0A	; 10
    1426:	29 81       	ldd	r18, Y+1	; 0x01
    1428:	3a 81       	ldd	r19, Y+2	; 0x02
    142a:	fc 01       	movw	r30, r24
    142c:	26 a3       	lds	r18, 0x56
    142e:	37 a3       	lds	r19, 0x57
TCE1.CCBBUF = period / 2;
    1430:	80 e4       	ldi	r24, 0x40	; 64
    1432:	9a e0       	ldi	r25, 0x0A	; 10
    1434:	29 81       	ldd	r18, Y+1	; 0x01
    1436:	3a 81       	ldd	r19, Y+2	; 0x02
    1438:	36 95       	lsr	r19
    143a:	27 95       	ror	r18
    143c:	fc 01       	movw	r30, r24
    143e:	22 af       	sts	0x72, r18
    1440:	33 af       	sts	0x73, r19
// Set oscillator source and frequency and start
TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1442:	80 e4       	ldi	r24, 0x40	; 64
    1444:	9a e0       	ldi	r25, 0x0A	; 10
    1446:	20 e4       	ldi	r18, 0x40	; 64
    1448:	3a e0       	ldi	r19, 0x0A	; 10
    144a:	f9 01       	movw	r30, r18
    144c:	20 81       	ld	r18, Z
    144e:	20 7f       	andi	r18, 0xF0	; 240
    1450:	21 60       	ori	r18, 0x01	; 1
    1452:	fc 01       	movw	r30, r24
    1454:	20 83       	st	Z, r18

// Enable interrupts.
PMIC.CTRL |= PMIC_MEDLVLEN_bm;
    1456:	80 ea       	ldi	r24, 0xA0	; 160
    1458:	90 e0       	ldi	r25, 0x00	; 0
    145a:	20 ea       	ldi	r18, 0xA0	; 160
    145c:	30 e0       	ldi	r19, 0x00	; 0
    145e:	f9 01       	movw	r30, r18
    1460:	22 81       	ldd	r18, Z+2	; 0x02
    1462:	22 60       	ori	r18, 0x02	; 2
    1464:	fc 01       	movw	r30, r24
    1466:	22 83       	std	Z+2, r18	; 0x02
//enable RR of lowlvl interrupts
PMIC.CTRL |= PMIC_RREN_bm; 
    1468:	80 ea       	ldi	r24, 0xA0	; 160
    146a:	90 e0       	ldi	r25, 0x00	; 0
    146c:	20 ea       	ldi	r18, 0xA0	; 160
    146e:	30 e0       	ldi	r19, 0x00	; 0
    1470:	f9 01       	movw	r30, r18
    1472:	22 81       	ldd	r18, Z+2	; 0x02
    1474:	20 68       	ori	r18, 0x80	; 128
    1476:	fc 01       	movw	r30, r24
    1478:	22 83       	std	Z+2, r18	; 0x02
//perhaps next two lines are redundant...
// chb_init();
// chb_set_short_addr(moteID);

sampleCount = 0;
    147a:	10 92 65 50 	sts	0x5065, r1
    147e:	10 92 66 50 	sts	0x5066, r1
    1482:	10 92 67 50 	sts	0x5067, r1
    1486:	10 92 68 50 	sts	0x5068, r1
TotalSampleCount = 0;
    148a:	10 92 95 50 	sts	0x5095, r1
    148e:	10 92 96 50 	sts	0x5096, r1
discardCount = 0;
    1492:	10 92 4e 40 	sts	0x404E, r1
sei();
    1496:	78 94       	sei
}
    1498:	26 96       	adiw	r28, 0x06	; 6
    149a:	cd bf       	out	0x3d, r28	; 61
    149c:	de bf       	out	0x3e, r29	; 62
    149e:	df 91       	pop	r29
    14a0:	cf 91       	pop	r28
    14a2:	08 95       	ret

000014a4 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
    14a4:	cf 93       	push	r28
    14a6:	df 93       	push	r29
    14a8:	cd b7       	in	r28, 0x3d	; 61
    14aa:	de b7       	in	r29, 0x3e	; 62
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    14ac:	80 ea       	ldi	r24, 0xA0	; 160
    14ae:	96 e0       	ldi	r25, 0x06	; 6
    14b0:	fc 01       	movw	r30, r24
    14b2:	13 86       	std	Z+11, r1	; 0x0b
}
    14b4:	df 91       	pop	r29
    14b6:	cf 91       	pop	r28
    14b8:	08 95       	ret

000014ba <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
    14ba:	cf 93       	push	r28
    14bc:	df 93       	push	r29
    14be:	cd b7       	in	r28, 0x3d	; 61
    14c0:	de b7       	in	r29, 0x3e	; 62
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    14c2:	80 ea       	ldi	r24, 0xA0	; 160
    14c4:	96 e0       	ldi	r25, 0x06	; 6
    14c6:	21 e0       	ldi	r18, 0x01	; 1
    14c8:	fc 01       	movw	r30, r24
    14ca:	23 87       	std	Z+11, r18	; 0x0b
}	
    14cc:	df 91       	pop	r29
    14ce:	cf 91       	pop	r28
    14d0:	08 95       	ret

000014d2 <__vector_105>:

//ISR used by CO_collectADC_cont function
ISR(PORTF_INT1_vect) {
    14d2:	1f 92       	push	r1
    14d4:	0f 92       	push	r0
    14d6:	0f b6       	in	r0, 0x3f	; 63
    14d8:	0f 92       	push	r0
    14da:	00 90 3b 00 	lds	r0, 0x003B
    14de:	0f 92       	push	r0
    14e0:	11 24       	eor	r1, r1
    14e2:	2f 92       	push	r2
    14e4:	3f 92       	push	r3
    14e6:	4f 92       	push	r4
    14e8:	5f 92       	push	r5
    14ea:	6f 92       	push	r6
    14ec:	7f 92       	push	r7
    14ee:	8f 92       	push	r8
    14f0:	9f 92       	push	r9
    14f2:	af 92       	push	r10
    14f4:	bf 92       	push	r11
    14f6:	cf 92       	push	r12
    14f8:	df 92       	push	r13
    14fa:	ef 92       	push	r14
    14fc:	ff 92       	push	r15
    14fe:	0f 93       	push	r16
    1500:	1f 93       	push	r17
    1502:	2f 93       	push	r18
    1504:	3f 93       	push	r19
    1506:	4f 93       	push	r20
    1508:	5f 93       	push	r21
    150a:	6f 93       	push	r22
    150c:	7f 93       	push	r23
    150e:	8f 93       	push	r24
    1510:	9f 93       	push	r25
    1512:	af 93       	push	r26
    1514:	bf 93       	push	r27
    1516:	ef 93       	push	r30
    1518:	ff 93       	push	r31
    151a:	cf 93       	push	r28
    151c:	df 93       	push	r29
    151e:	00 d0       	rcall	.+0      	; 0x1520 <__vector_105+0x4e>
    1520:	cd b7       	in	r28, 0x3d	; 61
    1522:	de b7       	in	r29, 0x3e	; 62
			nop();
		}		
	}
	*/		
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    1524:	80 91 4e 40 	lds	r24, 0x404E
    1528:	88 23       	and	r24, r24
    152a:	34 f0       	brlt	.+12     	; 0x1538 <__vector_105+0x66>
		discardCount++;
    152c:	80 91 4e 40 	lds	r24, 0x404E
    1530:	8f 5f       	subi	r24, 0xFF	; 255
    1532:	80 93 4e 40 	sts	0x404E, r24
    1536:	af c1       	rjmp	.+862    	; 0x1896 <__vector_105+0x3c4>
	}		
	else {
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
    1538:	84 e0       	ldi	r24, 0x04	; 4
    153a:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
    153e:	80 ec       	ldi	r24, 0xC0	; 192
    1540:	98 e0       	ldi	r25, 0x08	; 8
    1542:	24 e5       	ldi	r18, 0x54	; 84
    1544:	fc 01       	movw	r30, r24
    1546:	20 83       	st	Z, r18
		SPICS(TRUE); // CS SPI-SS
    1548:	81 e0       	ldi	r24, 0x01	; 1
    154a:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    154e:	80 ea       	ldi	r24, 0xA0	; 160
    1550:	96 e0       	ldi	r25, 0x06	; 6
    1552:	22 e0       	ldi	r18, 0x02	; 2
    1554:	fc 01       	movw	r30, r24
    1556:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1558:	19 82       	std	Y+1, r1	; 0x01
    155a:	1a c0       	rjmp	.+52     	; 0x1590 <__vector_105+0xbe>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    155c:	80 ec       	ldi	r24, 0xC0	; 192
    155e:	98 e0       	ldi	r25, 0x08	; 8
    1560:	2a ea       	ldi	r18, 0xAA	; 170
    1562:	fc 01       	movw	r30, r24
    1564:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1566:	00 00       	nop
    1568:	80 ec       	ldi	r24, 0xC0	; 192
    156a:	98 e0       	ldi	r25, 0x08	; 8
    156c:	fc 01       	movw	r30, r24
    156e:	82 81       	ldd	r24, Z+2	; 0x02
    1570:	88 23       	and	r24, r24
    1572:	d4 f7       	brge	.-12     	; 0x1568 <__vector_105+0x96>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1574:	89 81       	ldd	r24, Y+1	; 0x01
    1576:	88 2f       	mov	r24, r24
    1578:	90 e0       	ldi	r25, 0x00	; 0
    157a:	20 ec       	ldi	r18, 0xC0	; 192
    157c:	38 e0       	ldi	r19, 0x08	; 8
    157e:	f9 01       	movw	r30, r18
    1580:	23 81       	ldd	r18, Z+3	; 0x03
    1582:	8a 5a       	subi	r24, 0xAA	; 170
    1584:	9f 4a       	sbci	r25, 0xAF	; 175
    1586:	fc 01       	movw	r30, r24
    1588:	20 83       	st	Z, r18
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    158a:	89 81       	ldd	r24, Y+1	; 0x01
    158c:	8f 5f       	subi	r24, 0xFF	; 255
    158e:	89 83       	std	Y+1, r24	; 0x01
    1590:	89 81       	ldd	r24, Y+1	; 0x01
    1592:	83 30       	cpi	r24, 0x03	; 3
    1594:	18 f3       	brcs	.-58     	; 0x155c <__vector_105+0x8a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1596:	80 ea       	ldi	r24, 0xA0	; 160
    1598:	96 e0       	ldi	r25, 0x06	; 6
    159a:	22 e0       	ldi	r18, 0x02	; 2
    159c:	fc 01       	movw	r30, r24
    159e:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    15a0:	80 e0       	ldi	r24, 0x00	; 0
    15a2:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>

		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[0]) + 3) = 0xFF; // sign extension if negative
    15a6:	80 91 56 50 	lds	r24, 0x5056
    15aa:	88 23       	and	r24, r24
    15ac:	34 f4       	brge	.+12     	; 0x15ba <__vector_105+0xe8>
    15ae:	87 e5       	ldi	r24, 0x57	; 87
    15b0:	90 e4       	ldi	r25, 0x40	; 64
    15b2:	2f ef       	ldi	r18, 0xFF	; 255
    15b4:	fc 01       	movw	r30, r24
    15b6:	20 83       	st	Z, r18
    15b8:	04 c0       	rjmp	.+8      	; 0x15c2 <__vector_105+0xf0>
		else *(((uint8_t*)&data24Bit[0]) + 3) = 0x00;				
    15ba:	87 e5       	ldi	r24, 0x57	; 87
    15bc:	90 e4       	ldi	r25, 0x40	; 64
    15be:	fc 01       	movw	r30, r24
    15c0:	10 82       	st	Z, r1
		*(((uint8_t*)&data24Bit[0]) + 2) = SPIBuffer[0];
    15c2:	86 e5       	ldi	r24, 0x56	; 86
    15c4:	90 e4       	ldi	r25, 0x40	; 64
    15c6:	20 91 56 50 	lds	r18, 0x5056
    15ca:	fc 01       	movw	r30, r24
    15cc:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 1) = SPIBuffer[1];
    15ce:	85 e5       	ldi	r24, 0x55	; 85
    15d0:	90 e4       	ldi	r25, 0x40	; 64
    15d2:	20 91 57 50 	lds	r18, 0x5057
    15d6:	fc 01       	movw	r30, r24
    15d8:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 0) = SPIBuffer[2];
    15da:	84 e5       	ldi	r24, 0x54	; 84
    15dc:	90 e4       	ldi	r25, 0x40	; 64
    15de:	20 91 58 50 	lds	r18, 0x5058
    15e2:	fc 01       	movw	r30, r24
    15e4:	20 83       	st	Z, r18
		
		//convert ADC reading to voltage here (in uV)
		var = data24Bit[0];
    15e6:	80 91 54 40 	lds	r24, 0x4054
    15ea:	90 91 55 40 	lds	r25, 0x4055
    15ee:	a0 91 56 40 	lds	r26, 0x4056
    15f2:	b0 91 57 40 	lds	r27, 0x4057
    15f6:	5c 01       	movw	r10, r24
    15f8:	6d 01       	movw	r12, r26
    15fa:	bb 0f       	add	r27, r27
    15fc:	88 0b       	sbc	r24, r24
    15fe:	98 2f       	mov	r25, r24
    1600:	dc 01       	movw	r26, r24
    1602:	e8 2e       	mov	r14, r24
    1604:	f8 2e       	mov	r15, r24
    1606:	08 2f       	mov	r16, r24
    1608:	18 2f       	mov	r17, r24
    160a:	a0 92 97 50 	sts	0x5097, r10
    160e:	b0 92 98 50 	sts	0x5098, r11
    1612:	c0 92 99 50 	sts	0x5099, r12
    1616:	d0 92 9a 50 	sts	0x509A, r13
    161a:	e0 92 9b 50 	sts	0x509B, r14
    161e:	f0 92 9c 50 	sts	0x509C, r15
    1622:	00 93 9d 50 	sts	0x509D, r16
    1626:	10 93 9e 50 	sts	0x509E, r17
		*((int32_t*)&FRAMReadBuffer[sampleCount*4]) = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    162a:	80 91 65 50 	lds	r24, 0x5065
    162e:	90 91 66 50 	lds	r25, 0x5066
    1632:	a0 91 67 50 	lds	r26, 0x5067
    1636:	b0 91 68 50 	lds	r27, 0x5068
    163a:	88 0f       	add	r24, r24
    163c:	99 1f       	adc	r25, r25
    163e:	88 0f       	add	r24, r24
    1640:	99 1f       	adc	r25, r25
    1642:	9c 01       	movw	r18, r24
    1644:	20 53       	subi	r18, 0x30	; 48
    1646:	3c 4d       	sbci	r19, 0xDC	; 220
    1648:	2a 83       	std	Y+2, r18	; 0x02
    164a:	3b 83       	std	Y+3, r19	; 0x03
    164c:	a0 90 97 50 	lds	r10, 0x5097
    1650:	b0 90 98 50 	lds	r11, 0x5098
    1654:	c0 90 99 50 	lds	r12, 0x5099
    1658:	d0 90 9a 50 	lds	r13, 0x509A
    165c:	e0 90 9b 50 	lds	r14, 0x509B
    1660:	f0 90 9c 50 	lds	r15, 0x509C
    1664:	00 91 9d 50 	lds	r16, 0x509D
    1668:	10 91 9e 50 	lds	r17, 0x509E
    166c:	2a 2d       	mov	r18, r10
    166e:	3b 2d       	mov	r19, r11
    1670:	4c 2d       	mov	r20, r12
    1672:	5d 2d       	mov	r21, r13
    1674:	6e 2d       	mov	r22, r14
    1676:	7f 2d       	mov	r23, r15
    1678:	80 2f       	mov	r24, r16
    167a:	91 2f       	mov	r25, r17
    167c:	0f 2e       	mov	r0, r31
    167e:	f0 ea       	ldi	r31, 0xA0	; 160
    1680:	af 2e       	mov	r10, r31
    1682:	f0 2d       	mov	r31, r0
    1684:	0f 2e       	mov	r0, r31
    1686:	f5 e2       	ldi	r31, 0x25	; 37
    1688:	bf 2e       	mov	r11, r31
    168a:	f0 2d       	mov	r31, r0
    168c:	0f 2e       	mov	r0, r31
    168e:	f6 e2       	ldi	r31, 0x26	; 38
    1690:	cf 2e       	mov	r12, r31
    1692:	f0 2d       	mov	r31, r0
    1694:	dd 24       	eor	r13, r13
    1696:	ee 24       	eor	r14, r14
    1698:	ff 24       	eor	r15, r15
    169a:	00 e0       	ldi	r16, 0x00	; 0
    169c:	10 e0       	ldi	r17, 0x00	; 0
    169e:	0e 94 27 51 	call	0xa24e	; 0xa24e <__muldi3>
    16a2:	22 2e       	mov	r2, r18
    16a4:	33 2e       	mov	r3, r19
    16a6:	44 2e       	mov	r4, r20
    16a8:	55 2e       	mov	r5, r21
    16aa:	66 2e       	mov	r6, r22
    16ac:	77 2e       	mov	r7, r23
    16ae:	88 2e       	mov	r8, r24
    16b0:	99 2e       	mov	r9, r25
    16b2:	a2 2c       	mov	r10, r2
    16b4:	b3 2c       	mov	r11, r3
    16b6:	c4 2c       	mov	r12, r4
    16b8:	d5 2c       	mov	r13, r5
    16ba:	e6 2c       	mov	r14, r6
    16bc:	f7 2c       	mov	r15, r7
    16be:	08 2d       	mov	r16, r8
    16c0:	19 2d       	mov	r17, r9
    16c2:	2a 2d       	mov	r18, r10
    16c4:	3b 2d       	mov	r19, r11
    16c6:	4c 2d       	mov	r20, r12
    16c8:	5d 2d       	mov	r21, r13
    16ca:	6e 2d       	mov	r22, r14
    16cc:	7f 2d       	mov	r23, r15
    16ce:	80 2f       	mov	r24, r16
    16d0:	91 2f       	mov	r25, r17
    16d2:	aa 24       	eor	r10, r10
    16d4:	aa 94       	dec	r10
    16d6:	bb 24       	eor	r11, r11
    16d8:	ba 94       	dec	r11
    16da:	0f 2e       	mov	r0, r31
    16dc:	ff e7       	ldi	r31, 0x7F	; 127
    16de:	cf 2e       	mov	r12, r31
    16e0:	f0 2d       	mov	r31, r0
    16e2:	dd 24       	eor	r13, r13
    16e4:	ee 24       	eor	r14, r14
    16e6:	ff 24       	eor	r15, r15
    16e8:	00 e0       	ldi	r16, 0x00	; 0
    16ea:	10 e0       	ldi	r17, 0x00	; 0
    16ec:	0e 94 6e 52 	call	0xa4dc	; 0xa4dc <__divdi3>
    16f0:	22 2e       	mov	r2, r18
    16f2:	33 2e       	mov	r3, r19
    16f4:	44 2e       	mov	r4, r20
    16f6:	55 2e       	mov	r5, r21
    16f8:	66 2e       	mov	r6, r22
    16fa:	77 2e       	mov	r7, r23
    16fc:	88 2e       	mov	r8, r24
    16fe:	99 2e       	mov	r9, r25
    1700:	a2 2c       	mov	r10, r2
    1702:	b3 2c       	mov	r11, r3
    1704:	c4 2c       	mov	r12, r4
    1706:	d5 2c       	mov	r13, r5
    1708:	e6 2c       	mov	r14, r6
    170a:	f7 2c       	mov	r15, r7
    170c:	08 2d       	mov	r16, r8
    170e:	19 2d       	mov	r17, r9
    1710:	2a 2d       	mov	r18, r10
    1712:	3b 2d       	mov	r19, r11
    1714:	4c 2d       	mov	r20, r12
    1716:	5d 2d       	mov	r21, r13
    1718:	6e 2d       	mov	r22, r14
    171a:	7f 2d       	mov	r23, r15
    171c:	80 2f       	mov	r24, r16
    171e:	91 2f       	mov	r25, r17
    1720:	01 e0       	ldi	r16, 0x01	; 1
    1722:	0e 94 fa 51 	call	0xa3f4	; 0xa3f4 <__ashldi3>
    1726:	22 2e       	mov	r2, r18
    1728:	33 2e       	mov	r3, r19
    172a:	44 2e       	mov	r4, r20
    172c:	55 2e       	mov	r5, r21
    172e:	66 2e       	mov	r6, r22
    1730:	77 2e       	mov	r7, r23
    1732:	88 2e       	mov	r8, r24
    1734:	99 2e       	mov	r9, r25
    1736:	a2 2c       	mov	r10, r2
    1738:	b3 2c       	mov	r11, r3
    173a:	c4 2c       	mov	r12, r4
    173c:	d5 2c       	mov	r13, r5
    173e:	e6 2c       	mov	r14, r6
    1740:	f7 2c       	mov	r15, r7
    1742:	08 2d       	mov	r16, r8
    1744:	19 2d       	mov	r17, r9
    1746:	2a 2d       	mov	r18, r10
    1748:	3b 2d       	mov	r19, r11
    174a:	4c 2d       	mov	r20, r12
    174c:	5d 2d       	mov	r21, r13
    174e:	6e 2d       	mov	r22, r14
    1750:	7f 2d       	mov	r23, r15
    1752:	80 2f       	mov	r24, r16
    1754:	91 2f       	mov	r25, r17
    1756:	0f 2e       	mov	r0, r31
    1758:	f3 e0       	ldi	r31, 0x03	; 3
    175a:	af 2e       	mov	r10, r31
    175c:	f0 2d       	mov	r31, r0
    175e:	bb 24       	eor	r11, r11
    1760:	cc 24       	eor	r12, r12
    1762:	dd 24       	eor	r13, r13
    1764:	ee 24       	eor	r14, r14
    1766:	ff 24       	eor	r15, r15
    1768:	00 e0       	ldi	r16, 0x00	; 0
    176a:	10 e0       	ldi	r17, 0x00	; 0
    176c:	0e 94 6e 52 	call	0xa4dc	; 0xa4dc <__divdi3>
    1770:	a2 2e       	mov	r10, r18
    1772:	b3 2e       	mov	r11, r19
    1774:	c4 2e       	mov	r12, r20
    1776:	d5 2e       	mov	r13, r21
    1778:	e6 2e       	mov	r14, r22
    177a:	f7 2e       	mov	r15, r23
    177c:	08 2f       	mov	r16, r24
    177e:	19 2f       	mov	r17, r25
    1780:	2a 2d       	mov	r18, r10
    1782:	3b 2d       	mov	r19, r11
    1784:	4c 2d       	mov	r20, r12
    1786:	5d 2d       	mov	r21, r13
    1788:	6e 2d       	mov	r22, r14
    178a:	7f 2d       	mov	r23, r15
    178c:	80 2f       	mov	r24, r16
    178e:	91 2f       	mov	r25, r17
    1790:	da 01       	movw	r26, r20
    1792:	c9 01       	movw	r24, r18
    1794:	b0 95       	com	r27
    1796:	a0 95       	com	r26
    1798:	90 95       	com	r25
    179a:	81 95       	neg	r24
    179c:	9f 4f       	sbci	r25, 0xFF	; 255
    179e:	af 4f       	sbci	r26, 0xFF	; 255
    17a0:	bf 4f       	sbci	r27, 0xFF	; 255
    17a2:	ea 81       	ldd	r30, Y+2	; 0x02
    17a4:	fb 81       	ldd	r31, Y+3	; 0x03
    17a6:	80 83       	st	Z, r24
    17a8:	91 83       	std	Z+1, r25	; 0x01
    17aa:	a2 83       	std	Z+2, r26	; 0x02
    17ac:	b3 83       	std	Z+3, r27	; 0x03
		
		sampleCount++;
    17ae:	80 91 65 50 	lds	r24, 0x5065
    17b2:	90 91 66 50 	lds	r25, 0x5066
    17b6:	a0 91 67 50 	lds	r26, 0x5067
    17ba:	b0 91 68 50 	lds	r27, 0x5068
    17be:	01 96       	adiw	r24, 0x01	; 1
    17c0:	a1 1d       	adc	r26, r1
    17c2:	b1 1d       	adc	r27, r1
    17c4:	80 93 65 50 	sts	0x5065, r24
    17c8:	90 93 66 50 	sts	0x5066, r25
    17cc:	a0 93 67 50 	sts	0x5067, r26
    17d0:	b0 93 68 50 	sts	0x5068, r27
	//after 128 samples, store the data into sd card and reset sample buffer
	//after 30 samples, send the data over the radio
	if (sampleCount >= 30) { 
    17d4:	80 91 65 50 	lds	r24, 0x5065
    17d8:	90 91 66 50 	lds	r25, 0x5066
    17dc:	a0 91 67 50 	lds	r26, 0x5067
    17e0:	b0 91 68 50 	lds	r27, 0x5068
    17e4:	8e 31       	cpi	r24, 0x1E	; 30
    17e6:	91 05       	cpc	r25, r1
    17e8:	a1 05       	cpc	r26, r1
    17ea:	b1 05       	cpc	r27, r1
    17ec:	08 f4       	brcc	.+2      	; 0x17f0 <__vector_105+0x31e>
    17ee:	53 c0       	rjmp	.+166    	; 0x1896 <__vector_105+0x3c4>
		/*
		SD_write_block(10,FRAMReadBuffer,512);
		for (int i=0;i<512;i++) FRAMReadBuffer[i] = 0;
		SD_read_block(10,FRAMReadBuffer);
		*/
		sampleCount=0;
    17f0:	10 92 65 50 	sts	0x5065, r1
    17f4:	10 92 66 50 	sts	0x5066, r1
    17f8:	10 92 67 50 	sts	0x5067, r1
    17fc:	10 92 68 50 	sts	0x5068, r1
		TotalSampleCount++;
    1800:	80 91 95 50 	lds	r24, 0x5095
    1804:	90 91 96 50 	lds	r25, 0x5096
    1808:	01 96       	adiw	r24, 0x01	; 1
    180a:	80 93 95 50 	sts	0x5095, r24
    180e:	90 93 96 50 	sts	0x5096, r25
		discardCount = ADC_DISCARD -1; //discard the next sample after pausing the sampling to send/store data since the sample ready flag will be outdated and the value might be bad
    1812:	8f e7       	ldi	r24, 0x7F	; 127
    1814:	80 93 4e 40 	sts	0x404E, r24
		//PORTF.OUTSET = PIN1_bm; //re-enable ADC for further sampling
		
		//write code to send the data over radio instead. Include some identifying info (like mote number) with the data.
		memmove((void*)FRAMReadBuffer+2,(const void*)FRAMReadBuffer,sampleCount*4); //move the data in the FRAM buffer up by 1 byte to make room for metadata
    1818:	80 91 65 50 	lds	r24, 0x5065
    181c:	90 91 66 50 	lds	r25, 0x5066
    1820:	a0 91 67 50 	lds	r26, 0x5067
    1824:	b0 91 68 50 	lds	r27, 0x5068
    1828:	9c 01       	movw	r18, r24
    182a:	22 0f       	add	r18, r18
    182c:	33 1f       	adc	r19, r19
    182e:	22 0f       	add	r18, r18
    1830:	33 1f       	adc	r19, r19
    1832:	82 ed       	ldi	r24, 0xD2	; 210
    1834:	93 e2       	ldi	r25, 0x23	; 35
    1836:	40 ed       	ldi	r20, 0xD0	; 208
    1838:	53 e2       	ldi	r21, 0x23	; 35
    183a:	ba 01       	movw	r22, r20
    183c:	a9 01       	movw	r20, r18
    183e:	0e 94 59 5c 	call	0xb8b2	; 0xb8b2 <memmove>
		FRAMReadBuffer[0] = moteID;		//send moteID of the mote that gathered the data
    1842:	80 91 c1 50 	lds	r24, 0x50C1
    1846:	80 93 d0 23 	sts	0x23D0, r24
		FRAMReadBuffer[1] = (uint8_t)sampleCount;	//send the number of data samples gathered cast as a byte since no more than 30/31 samples should be send at a time
    184a:	80 91 65 50 	lds	r24, 0x5065
    184e:	90 91 66 50 	lds	r25, 0x5066
    1852:	a0 91 67 50 	lds	r26, 0x5067
    1856:	b0 91 68 50 	lds	r27, 0x5068
    185a:	80 93 d1 23 	sts	0x23D1, r24
		chb_write(0x0000,FRAMReadBuffer,sampleCount*4+2);	//send the samples and the metadata (for now just 1 byte containing moteID) to the base station
    185e:	80 91 65 50 	lds	r24, 0x5065
    1862:	90 91 66 50 	lds	r25, 0x5066
    1866:	a0 91 67 50 	lds	r26, 0x5067
    186a:	b0 91 68 50 	lds	r27, 0x5068
    186e:	88 0f       	add	r24, r24
    1870:	99 1f       	adc	r25, r25
    1872:	aa 1f       	adc	r26, r26
    1874:	bb 1f       	adc	r27, r27
    1876:	88 0f       	add	r24, r24
    1878:	99 1f       	adc	r25, r25
    187a:	aa 1f       	adc	r26, r26
    187c:	bb 1f       	adc	r27, r27
    187e:	9c 01       	movw	r18, r24
    1880:	ad 01       	movw	r20, r26
    1882:	2e 5f       	subi	r18, 0xFE	; 254
    1884:	3f 4f       	sbci	r19, 0xFF	; 255
    1886:	4f 4f       	sbci	r20, 0xFF	; 255
    1888:	5f 4f       	sbci	r21, 0xFF	; 255
    188a:	60 ed       	ldi	r22, 0xD0	; 208
    188c:	73 e2       	ldi	r23, 0x23	; 35
    188e:	80 e0       	ldi	r24, 0x00	; 0
    1890:	90 e0       	ldi	r25, 0x00	; 0
    1892:	0e 94 85 1e 	call	0x3d0a	; 0x3d0a <chb_write>
	}	
	}	
}
    1896:	23 96       	adiw	r28, 0x03	; 3
    1898:	cd bf       	out	0x3d, r28	; 61
    189a:	de bf       	out	0x3e, r29	; 62
    189c:	df 91       	pop	r29
    189e:	cf 91       	pop	r28
    18a0:	ff 91       	pop	r31
    18a2:	ef 91       	pop	r30
    18a4:	bf 91       	pop	r27
    18a6:	af 91       	pop	r26
    18a8:	9f 91       	pop	r25
    18aa:	8f 91       	pop	r24
    18ac:	7f 91       	pop	r23
    18ae:	6f 91       	pop	r22
    18b0:	5f 91       	pop	r21
    18b2:	4f 91       	pop	r20
    18b4:	3f 91       	pop	r19
    18b6:	2f 91       	pop	r18
    18b8:	1f 91       	pop	r17
    18ba:	0f 91       	pop	r16
    18bc:	ff 90       	pop	r15
    18be:	ef 90       	pop	r14
    18c0:	df 90       	pop	r13
    18c2:	cf 90       	pop	r12
    18c4:	bf 90       	pop	r11
    18c6:	af 90       	pop	r10
    18c8:	9f 90       	pop	r9
    18ca:	8f 90       	pop	r8
    18cc:	7f 90       	pop	r7
    18ce:	6f 90       	pop	r6
    18d0:	5f 90       	pop	r5
    18d2:	4f 90       	pop	r4
    18d4:	3f 90       	pop	r3
    18d6:	2f 90       	pop	r2
    18d8:	0f 90       	pop	r0
    18da:	00 92 3b 00 	sts	0x003B, r0
    18de:	0f 90       	pop	r0
    18e0:	0f be       	out	0x3f, r0	; 63
    18e2:	0f 90       	pop	r0
    18e4:	1f 90       	pop	r1
    18e6:	18 95       	reti

000018e8 <__vector_104>:

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    18e8:	1f 92       	push	r1
    18ea:	0f 92       	push	r0
    18ec:	0f b6       	in	r0, 0x3f	; 63
    18ee:	0f 92       	push	r0
    18f0:	00 90 3b 00 	lds	r0, 0x003B
    18f4:	0f 92       	push	r0
    18f6:	11 24       	eor	r1, r1
    18f8:	2f 92       	push	r2
    18fa:	3f 92       	push	r3
    18fc:	4f 92       	push	r4
    18fe:	5f 92       	push	r5
    1900:	6f 92       	push	r6
    1902:	7f 92       	push	r7
    1904:	8f 92       	push	r8
    1906:	9f 92       	push	r9
    1908:	af 92       	push	r10
    190a:	bf 92       	push	r11
    190c:	cf 92       	push	r12
    190e:	df 92       	push	r13
    1910:	ef 92       	push	r14
    1912:	ff 92       	push	r15
    1914:	0f 93       	push	r16
    1916:	1f 93       	push	r17
    1918:	2f 93       	push	r18
    191a:	3f 93       	push	r19
    191c:	4f 93       	push	r20
    191e:	5f 93       	push	r21
    1920:	6f 93       	push	r22
    1922:	7f 93       	push	r23
    1924:	8f 93       	push	r24
    1926:	9f 93       	push	r25
    1928:	af 93       	push	r26
    192a:	bf 93       	push	r27
    192c:	ef 93       	push	r30
    192e:	ff 93       	push	r31
    1930:	cf 93       	push	r28
    1932:	df 93       	push	r29
    1934:	cd b7       	in	r28, 0x3d	; 61
    1936:	de b7       	in	r29, 0x3e	; 62
    1938:	27 97       	sbiw	r28, 0x07	; 7
    193a:	cd bf       	out	0x3d, r28	; 61
    193c:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	if (discardCount < ADC_DISCARD) {
    193e:	80 91 4e 40 	lds	r24, 0x404E
    1942:	88 23       	and	r24, r24
    1944:	34 f0       	brlt	.+12     	; 0x1952 <__vector_104+0x6a>
		discardCount++;
    1946:	80 91 4e 40 	lds	r24, 0x404E
    194a:	8f 5f       	subi	r24, 0xFF	; 255
    194c:	80 93 4e 40 	sts	0x404E, r24
    1950:	4a c1       	rjmp	.+660    	; 0x1be6 <__vector_104+0x2fe>
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    1952:	81 e0       	ldi	r24, 0x01	; 1
    1954:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1958:	80 ea       	ldi	r24, 0xA0	; 160
    195a:	96 e0       	ldi	r25, 0x06	; 6
    195c:	22 e0       	ldi	r18, 0x02	; 2
    195e:	fc 01       	movw	r30, r24
    1960:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1962:	19 82       	std	Y+1, r1	; 0x01
    1964:	1a c0       	rjmp	.+52     	; 0x199a <__vector_104+0xb2>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1966:	80 ec       	ldi	r24, 0xC0	; 192
    1968:	98 e0       	ldi	r25, 0x08	; 8
    196a:	2a ea       	ldi	r18, 0xAA	; 170
    196c:	fc 01       	movw	r30, r24
    196e:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1970:	00 00       	nop
    1972:	80 ec       	ldi	r24, 0xC0	; 192
    1974:	98 e0       	ldi	r25, 0x08	; 8
    1976:	fc 01       	movw	r30, r24
    1978:	82 81       	ldd	r24, Z+2	; 0x02
    197a:	88 23       	and	r24, r24
    197c:	d4 f7       	brge	.-12     	; 0x1972 <__vector_104+0x8a>
			SPIBuffer[bufIndex] = SPIC.DATA;
    197e:	89 81       	ldd	r24, Y+1	; 0x01
    1980:	88 2f       	mov	r24, r24
    1982:	90 e0       	ldi	r25, 0x00	; 0
    1984:	20 ec       	ldi	r18, 0xC0	; 192
    1986:	38 e0       	ldi	r19, 0x08	; 8
    1988:	f9 01       	movw	r30, r18
    198a:	23 81       	ldd	r18, Z+3	; 0x03
    198c:	8a 5a       	subi	r24, 0xAA	; 170
    198e:	9f 4a       	sbci	r25, 0xAF	; 175
    1990:	fc 01       	movw	r30, r24
    1992:	20 83       	st	Z, r18
		discardCount++;
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1994:	89 81       	ldd	r24, Y+1	; 0x01
    1996:	8f 5f       	subi	r24, 0xFF	; 255
    1998:	89 83       	std	Y+1, r24	; 0x01
    199a:	89 81       	ldd	r24, Y+1	; 0x01
    199c:	83 30       	cpi	r24, 0x03	; 3
    199e:	18 f3       	brcs	.-58     	; 0x1966 <__vector_104+0x7e>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    19a0:	80 ea       	ldi	r24, 0xA0	; 160
    19a2:	96 e0       	ldi	r25, 0x06	; 6
    19a4:	22 e0       	ldi	r18, 0x02	; 2
    19a6:	fc 01       	movw	r30, r24
    19a8:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    19aa:	80 e0       	ldi	r24, 0x00	; 0
    19ac:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    19b0:	80 91 56 50 	lds	r24, 0x5056
    19b4:	88 23       	and	r24, r24
    19b6:	3c f4       	brge	.+14     	; 0x19c6 <__vector_104+0xde>
    19b8:	ce 01       	movw	r24, r28
    19ba:	02 96       	adiw	r24, 0x02	; 2
    19bc:	03 96       	adiw	r24, 0x03	; 3
    19be:	2f ef       	ldi	r18, 0xFF	; 255
    19c0:	fc 01       	movw	r30, r24
    19c2:	20 83       	st	Z, r18
    19c4:	05 c0       	rjmp	.+10     	; 0x19d0 <__vector_104+0xe8>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    19c6:	ce 01       	movw	r24, r28
    19c8:	02 96       	adiw	r24, 0x02	; 2
    19ca:	03 96       	adiw	r24, 0x03	; 3
    19cc:	fc 01       	movw	r30, r24
    19ce:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    19d0:	ce 01       	movw	r24, r28
    19d2:	02 96       	adiw	r24, 0x02	; 2
    19d4:	02 96       	adiw	r24, 0x02	; 2
    19d6:	20 91 56 50 	lds	r18, 0x5056
    19da:	fc 01       	movw	r30, r24
    19dc:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    19de:	ce 01       	movw	r24, r28
    19e0:	02 96       	adiw	r24, 0x02	; 2
    19e2:	01 96       	adiw	r24, 0x01	; 1
    19e4:	20 91 57 50 	lds	r18, 0x5057
    19e8:	fc 01       	movw	r30, r24
    19ea:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    19ec:	ce 01       	movw	r24, r28
    19ee:	02 96       	adiw	r24, 0x02	; 2
    19f0:	20 91 58 50 	lds	r18, 0x5058
    19f4:	fc 01       	movw	r30, r24
    19f6:	20 83       	st	Z, r18
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    19f8:	8a 81       	ldd	r24, Y+2	; 0x02
    19fa:	9b 81       	ldd	r25, Y+3	; 0x03
    19fc:	ac 81       	ldd	r26, Y+4	; 0x04
    19fe:	bd 81       	ldd	r27, Y+5	; 0x05
    1a00:	5c 01       	movw	r10, r24
    1a02:	6d 01       	movw	r12, r26
    1a04:	bb 0f       	add	r27, r27
    1a06:	88 0b       	sbc	r24, r24
    1a08:	98 2f       	mov	r25, r24
    1a0a:	dc 01       	movw	r26, r24
    1a0c:	e8 2e       	mov	r14, r24
    1a0e:	f8 2e       	mov	r15, r24
    1a10:	08 2f       	mov	r16, r24
    1a12:	18 2f       	mov	r17, r24
    1a14:	a0 92 97 50 	sts	0x5097, r10
    1a18:	b0 92 98 50 	sts	0x5098, r11
    1a1c:	c0 92 99 50 	sts	0x5099, r12
    1a20:	d0 92 9a 50 	sts	0x509A, r13
    1a24:	e0 92 9b 50 	sts	0x509B, r14
    1a28:	f0 92 9c 50 	sts	0x509C, r15
    1a2c:	00 93 9d 50 	sts	0x509D, r16
    1a30:	10 93 9e 50 	sts	0x509E, r17
		ADC_BUFFER[sampleCount] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1a34:	20 91 63 50 	lds	r18, 0x5063
    1a38:	30 91 64 50 	lds	r19, 0x5064
    1a3c:	80 91 65 50 	lds	r24, 0x5065
    1a40:	90 91 66 50 	lds	r25, 0x5066
    1a44:	a0 91 67 50 	lds	r26, 0x5067
    1a48:	b0 91 68 50 	lds	r27, 0x5068
    1a4c:	88 0f       	add	r24, r24
    1a4e:	99 1f       	adc	r25, r25
    1a50:	88 0f       	add	r24, r24
    1a52:	99 1f       	adc	r25, r25
    1a54:	a9 01       	movw	r20, r18
    1a56:	48 0f       	add	r20, r24
    1a58:	59 1f       	adc	r21, r25
    1a5a:	4e 83       	std	Y+6, r20	; 0x06
    1a5c:	5f 83       	std	Y+7, r21	; 0x07
    1a5e:	a0 90 97 50 	lds	r10, 0x5097
    1a62:	b0 90 98 50 	lds	r11, 0x5098
    1a66:	c0 90 99 50 	lds	r12, 0x5099
    1a6a:	d0 90 9a 50 	lds	r13, 0x509A
    1a6e:	e0 90 9b 50 	lds	r14, 0x509B
    1a72:	f0 90 9c 50 	lds	r15, 0x509C
    1a76:	00 91 9d 50 	lds	r16, 0x509D
    1a7a:	10 91 9e 50 	lds	r17, 0x509E
    1a7e:	2a 2d       	mov	r18, r10
    1a80:	3b 2d       	mov	r19, r11
    1a82:	4c 2d       	mov	r20, r12
    1a84:	5d 2d       	mov	r21, r13
    1a86:	6e 2d       	mov	r22, r14
    1a88:	7f 2d       	mov	r23, r15
    1a8a:	80 2f       	mov	r24, r16
    1a8c:	91 2f       	mov	r25, r17
    1a8e:	0f 2e       	mov	r0, r31
    1a90:	f0 ea       	ldi	r31, 0xA0	; 160
    1a92:	af 2e       	mov	r10, r31
    1a94:	f0 2d       	mov	r31, r0
    1a96:	0f 2e       	mov	r0, r31
    1a98:	f5 e2       	ldi	r31, 0x25	; 37
    1a9a:	bf 2e       	mov	r11, r31
    1a9c:	f0 2d       	mov	r31, r0
    1a9e:	0f 2e       	mov	r0, r31
    1aa0:	f6 e2       	ldi	r31, 0x26	; 38
    1aa2:	cf 2e       	mov	r12, r31
    1aa4:	f0 2d       	mov	r31, r0
    1aa6:	dd 24       	eor	r13, r13
    1aa8:	ee 24       	eor	r14, r14
    1aaa:	ff 24       	eor	r15, r15
    1aac:	00 e0       	ldi	r16, 0x00	; 0
    1aae:	10 e0       	ldi	r17, 0x00	; 0
    1ab0:	0e 94 27 51 	call	0xa24e	; 0xa24e <__muldi3>
    1ab4:	22 2e       	mov	r2, r18
    1ab6:	33 2e       	mov	r3, r19
    1ab8:	44 2e       	mov	r4, r20
    1aba:	55 2e       	mov	r5, r21
    1abc:	66 2e       	mov	r6, r22
    1abe:	77 2e       	mov	r7, r23
    1ac0:	88 2e       	mov	r8, r24
    1ac2:	99 2e       	mov	r9, r25
    1ac4:	a2 2c       	mov	r10, r2
    1ac6:	b3 2c       	mov	r11, r3
    1ac8:	c4 2c       	mov	r12, r4
    1aca:	d5 2c       	mov	r13, r5
    1acc:	e6 2c       	mov	r14, r6
    1ace:	f7 2c       	mov	r15, r7
    1ad0:	08 2d       	mov	r16, r8
    1ad2:	19 2d       	mov	r17, r9
    1ad4:	2a 2d       	mov	r18, r10
    1ad6:	3b 2d       	mov	r19, r11
    1ad8:	4c 2d       	mov	r20, r12
    1ada:	5d 2d       	mov	r21, r13
    1adc:	6e 2d       	mov	r22, r14
    1ade:	7f 2d       	mov	r23, r15
    1ae0:	80 2f       	mov	r24, r16
    1ae2:	91 2f       	mov	r25, r17
    1ae4:	aa 24       	eor	r10, r10
    1ae6:	aa 94       	dec	r10
    1ae8:	bb 24       	eor	r11, r11
    1aea:	ba 94       	dec	r11
    1aec:	0f 2e       	mov	r0, r31
    1aee:	ff e7       	ldi	r31, 0x7F	; 127
    1af0:	cf 2e       	mov	r12, r31
    1af2:	f0 2d       	mov	r31, r0
    1af4:	dd 24       	eor	r13, r13
    1af6:	ee 24       	eor	r14, r14
    1af8:	ff 24       	eor	r15, r15
    1afa:	00 e0       	ldi	r16, 0x00	; 0
    1afc:	10 e0       	ldi	r17, 0x00	; 0
    1afe:	0e 94 6e 52 	call	0xa4dc	; 0xa4dc <__divdi3>
    1b02:	22 2e       	mov	r2, r18
    1b04:	33 2e       	mov	r3, r19
    1b06:	44 2e       	mov	r4, r20
    1b08:	55 2e       	mov	r5, r21
    1b0a:	66 2e       	mov	r6, r22
    1b0c:	77 2e       	mov	r7, r23
    1b0e:	88 2e       	mov	r8, r24
    1b10:	99 2e       	mov	r9, r25
    1b12:	a2 2c       	mov	r10, r2
    1b14:	b3 2c       	mov	r11, r3
    1b16:	c4 2c       	mov	r12, r4
    1b18:	d5 2c       	mov	r13, r5
    1b1a:	e6 2c       	mov	r14, r6
    1b1c:	f7 2c       	mov	r15, r7
    1b1e:	08 2d       	mov	r16, r8
    1b20:	19 2d       	mov	r17, r9
    1b22:	2a 2d       	mov	r18, r10
    1b24:	3b 2d       	mov	r19, r11
    1b26:	4c 2d       	mov	r20, r12
    1b28:	5d 2d       	mov	r21, r13
    1b2a:	6e 2d       	mov	r22, r14
    1b2c:	7f 2d       	mov	r23, r15
    1b2e:	80 2f       	mov	r24, r16
    1b30:	91 2f       	mov	r25, r17
    1b32:	01 e0       	ldi	r16, 0x01	; 1
    1b34:	0e 94 fa 51 	call	0xa3f4	; 0xa3f4 <__ashldi3>
    1b38:	22 2e       	mov	r2, r18
    1b3a:	33 2e       	mov	r3, r19
    1b3c:	44 2e       	mov	r4, r20
    1b3e:	55 2e       	mov	r5, r21
    1b40:	66 2e       	mov	r6, r22
    1b42:	77 2e       	mov	r7, r23
    1b44:	88 2e       	mov	r8, r24
    1b46:	99 2e       	mov	r9, r25
    1b48:	a2 2c       	mov	r10, r2
    1b4a:	b3 2c       	mov	r11, r3
    1b4c:	c4 2c       	mov	r12, r4
    1b4e:	d5 2c       	mov	r13, r5
    1b50:	e6 2c       	mov	r14, r6
    1b52:	f7 2c       	mov	r15, r7
    1b54:	08 2d       	mov	r16, r8
    1b56:	19 2d       	mov	r17, r9
    1b58:	2a 2d       	mov	r18, r10
    1b5a:	3b 2d       	mov	r19, r11
    1b5c:	4c 2d       	mov	r20, r12
    1b5e:	5d 2d       	mov	r21, r13
    1b60:	6e 2d       	mov	r22, r14
    1b62:	7f 2d       	mov	r23, r15
    1b64:	80 2f       	mov	r24, r16
    1b66:	91 2f       	mov	r25, r17
    1b68:	0f 2e       	mov	r0, r31
    1b6a:	f3 e0       	ldi	r31, 0x03	; 3
    1b6c:	af 2e       	mov	r10, r31
    1b6e:	f0 2d       	mov	r31, r0
    1b70:	bb 24       	eor	r11, r11
    1b72:	cc 24       	eor	r12, r12
    1b74:	dd 24       	eor	r13, r13
    1b76:	ee 24       	eor	r14, r14
    1b78:	ff 24       	eor	r15, r15
    1b7a:	00 e0       	ldi	r16, 0x00	; 0
    1b7c:	10 e0       	ldi	r17, 0x00	; 0
    1b7e:	0e 94 6e 52 	call	0xa4dc	; 0xa4dc <__divdi3>
    1b82:	a2 2e       	mov	r10, r18
    1b84:	b3 2e       	mov	r11, r19
    1b86:	c4 2e       	mov	r12, r20
    1b88:	d5 2e       	mov	r13, r21
    1b8a:	e6 2e       	mov	r14, r22
    1b8c:	f7 2e       	mov	r15, r23
    1b8e:	08 2f       	mov	r16, r24
    1b90:	19 2f       	mov	r17, r25
    1b92:	2a 2d       	mov	r18, r10
    1b94:	3b 2d       	mov	r19, r11
    1b96:	4c 2d       	mov	r20, r12
    1b98:	5d 2d       	mov	r21, r13
    1b9a:	6e 2d       	mov	r22, r14
    1b9c:	7f 2d       	mov	r23, r15
    1b9e:	80 2f       	mov	r24, r16
    1ba0:	91 2f       	mov	r25, r17
    1ba2:	da 01       	movw	r26, r20
    1ba4:	c9 01       	movw	r24, r18
    1ba6:	b0 95       	com	r27
    1ba8:	a0 95       	com	r26
    1baa:	90 95       	com	r25
    1bac:	81 95       	neg	r24
    1bae:	9f 4f       	sbci	r25, 0xFF	; 255
    1bb0:	af 4f       	sbci	r26, 0xFF	; 255
    1bb2:	bf 4f       	sbci	r27, 0xFF	; 255
    1bb4:	ee 81       	ldd	r30, Y+6	; 0x06
    1bb6:	ff 81       	ldd	r31, Y+7	; 0x07
    1bb8:	80 83       	st	Z, r24
    1bba:	91 83       	std	Z+1, r25	; 0x01
    1bbc:	a2 83       	std	Z+2, r26	; 0x02
    1bbe:	b3 83       	std	Z+3, r27	; 0x03
		sampleCount++;
    1bc0:	80 91 65 50 	lds	r24, 0x5065
    1bc4:	90 91 66 50 	lds	r25, 0x5066
    1bc8:	a0 91 67 50 	lds	r26, 0x5067
    1bcc:	b0 91 68 50 	lds	r27, 0x5068
    1bd0:	01 96       	adiw	r24, 0x01	; 1
    1bd2:	a1 1d       	adc	r26, r1
    1bd4:	b1 1d       	adc	r27, r1
    1bd6:	80 93 65 50 	sts	0x5065, r24
    1bda:	90 93 66 50 	sts	0x5066, r25
    1bde:	a0 93 67 50 	sts	0x5067, r26
    1be2:	b0 93 68 50 	sts	0x5068, r27
	}
}
    1be6:	27 96       	adiw	r28, 0x07	; 7
    1be8:	cd bf       	out	0x3d, r28	; 61
    1bea:	de bf       	out	0x3e, r29	; 62
    1bec:	df 91       	pop	r29
    1bee:	cf 91       	pop	r28
    1bf0:	ff 91       	pop	r31
    1bf2:	ef 91       	pop	r30
    1bf4:	bf 91       	pop	r27
    1bf6:	af 91       	pop	r26
    1bf8:	9f 91       	pop	r25
    1bfa:	8f 91       	pop	r24
    1bfc:	7f 91       	pop	r23
    1bfe:	6f 91       	pop	r22
    1c00:	5f 91       	pop	r21
    1c02:	4f 91       	pop	r20
    1c04:	3f 91       	pop	r19
    1c06:	2f 91       	pop	r18
    1c08:	1f 91       	pop	r17
    1c0a:	0f 91       	pop	r16
    1c0c:	ff 90       	pop	r15
    1c0e:	ef 90       	pop	r14
    1c10:	df 90       	pop	r13
    1c12:	cf 90       	pop	r12
    1c14:	bf 90       	pop	r11
    1c16:	af 90       	pop	r10
    1c18:	9f 90       	pop	r9
    1c1a:	8f 90       	pop	r8
    1c1c:	7f 90       	pop	r7
    1c1e:	6f 90       	pop	r6
    1c20:	5f 90       	pop	r5
    1c22:	4f 90       	pop	r4
    1c24:	3f 90       	pop	r3
    1c26:	2f 90       	pop	r2
    1c28:	0f 90       	pop	r0
    1c2a:	00 92 3b 00 	sts	0x003B, r0
    1c2e:	0f 90       	pop	r0
    1c30:	0f be       	out	0x3f, r0	; 63
    1c32:	0f 90       	pop	r0
    1c34:	1f 90       	pop	r1
    1c36:	18 95       	reti

00001c38 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
    1c38:	cf 93       	push	r28
    1c3a:	df 93       	push	r29
    1c3c:	0f 92       	push	r0
    1c3e:	cd b7       	in	r28, 0x3d	; 61
    1c40:	de b7       	in	r29, 0x3e	; 62
    1c42:	89 83       	std	Y+1, r24	; 0x01
	if (enable) {
    1c44:	89 81       	ldd	r24, Y+1	; 0x01
    1c46:	88 23       	and	r24, r24
    1c48:	49 f0       	breq	.+18     	; 0x1c5c <ACC_DCPassEnable+0x24>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1c4a:	80 e2       	ldi	r24, 0x20	; 32
    1c4c:	60 e0       	ldi	r22, 0x00	; 0
    1c4e:	0e 94 9d 32 	call	0x653a	; 0x653a <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1c52:	80 e2       	ldi	r24, 0x20	; 32
    1c54:	60 e0       	ldi	r22, 0x00	; 0
    1c56:	0e 94 69 33 	call	0x66d2	; 0x66d2 <PortEx_OUTSET>
    1c5a:	04 c0       	rjmp	.+8      	; 0x1c64 <ACC_DCPassEnable+0x2c>
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1c5c:	80 e2       	ldi	r24, 0x20	; 32
    1c5e:	60 e0       	ldi	r22, 0x00	; 0
    1c60:	0e 94 01 33 	call	0x6602	; 0x6602 <PortEx_DIRCLR>
		//setPortEx(0x00, PS_BANKB);
	}
}
    1c64:	0f 90       	pop	r0
    1c66:	df 91       	pop	r29
    1c68:	cf 91       	pop	r28
    1c6a:	08 95       	ret

00001c6c <CO_collectSeismic3Axises>:
	
}*/

void CO_collectSeismic3Axises(uint8_t filterConfig, uint8_t gain[], uint16_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint32_t numOfSamples, int32_t* DataArray) {
    1c6c:	8f 92       	push	r8
    1c6e:	9f 92       	push	r9
    1c70:	af 92       	push	r10
    1c72:	bf 92       	push	r11
    1c74:	cf 92       	push	r12
    1c76:	df 92       	push	r13
    1c78:	ef 92       	push	r14
    1c7a:	ff 92       	push	r15
    1c7c:	0f 93       	push	r16
    1c7e:	1f 93       	push	r17
    1c80:	cf 93       	push	r28
    1c82:	df 93       	push	r29
    1c84:	cd b7       	in	r28, 0x3d	; 61
    1c86:	de b7       	in	r29, 0x3e	; 62
    1c88:	2f 97       	sbiw	r28, 0x0f	; 15
    1c8a:	cd bf       	out	0x3d, r28	; 61
    1c8c:	de bf       	out	0x3e, r29	; 62
    1c8e:	89 83       	std	Y+1, r24	; 0x01
    1c90:	6a 83       	std	Y+2, r22	; 0x02
    1c92:	7b 83       	std	Y+3, r23	; 0x03
    1c94:	4c 83       	std	Y+4, r20	; 0x04
    1c96:	5d 83       	std	Y+5, r21	; 0x05
    1c98:	2e 83       	std	Y+6, r18	; 0x06
    1c9a:	0f 83       	std	Y+7, r16	; 0x07
    1c9c:	e8 86       	std	Y+8, r14	; 0x08
    1c9e:	f9 86       	std	Y+9, r15	; 0x09
    1ca0:	ca 86       	std	Y+10, r12	; 0x0a
    1ca2:	db 86       	std	Y+11, r13	; 0x0b
    1ca4:	ac 86       	std	Y+12, r10	; 0x0c
    1ca6:	bd 86       	std	Y+13, r11	; 0x0d
    1ca8:	8e 86       	std	Y+14, r8	; 0x0e
    1caa:	9f 86       	std	Y+15, r9	; 0x0f
	
	ADC_BUFFER = DataArray;
    1cac:	8b a1       	lds	r24, 0x4b
    1cae:	9c a1       	lds	r25, 0x4c
    1cb0:	80 93 63 50 	sts	0x5063, r24
    1cb4:	90 93 64 50 	sts	0x5064, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1cb8:	81 e0       	ldi	r24, 0x01	; 1
    1cba:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    1cbe:	8a 81       	ldd	r24, Y+2	; 0x02
    1cc0:	9b 81       	ldd	r25, Y+3	; 0x03
    1cc2:	fc 01       	movw	r30, r24
    1cc4:	90 81       	ld	r25, Z
    1cc6:	85 e0       	ldi	r24, 0x05	; 5
    1cc8:	69 2f       	mov	r22, r25
    1cca:	0e 94 0e 07 	call	0xe1c	; 0xe1c <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    1cce:	8a 81       	ldd	r24, Y+2	; 0x02
    1cd0:	9b 81       	ldd	r25, Y+3	; 0x03
    1cd2:	01 96       	adiw	r24, 0x01	; 1
    1cd4:	fc 01       	movw	r30, r24
    1cd6:	90 81       	ld	r25, Z
    1cd8:	86 e0       	ldi	r24, 0x06	; 6
    1cda:	69 2f       	mov	r22, r25
    1cdc:	0e 94 0e 07 	call	0xe1c	; 0xe1c <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    1ce0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ce2:	9b 81       	ldd	r25, Y+3	; 0x03
    1ce4:	02 96       	adiw	r24, 0x02	; 2
    1ce6:	fc 01       	movw	r30, r24
    1ce8:	90 81       	ld	r25, Z
    1cea:	87 e0       	ldi	r24, 0x07	; 7
    1cec:	69 2f       	mov	r22, r25
    1cee:	0e 94 0e 07 	call	0xe1c	; 0xe1c <set_ampGain>
	set_filter(filterConfig);
    1cf2:	89 81       	ldd	r24, Y+1	; 0x01
    1cf4:	0e 94 3d 08 	call	0x107a	; 0x107a <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    1cf8:	8f 81       	ldd	r24, Y+7	; 0x07
    1cfa:	0e 94 1c 0e 	call	0x1c38	; 0x1c38 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    1cfe:	84 e0       	ldi	r24, 0x04	; 4
    1d00:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1d04:	80 ec       	ldi	r24, 0xC0	; 192
    1d06:	98 e0       	ldi	r25, 0x08	; 8
    1d08:	24 e5       	ldi	r18, 0x54	; 84
    1d0a:	fc 01       	movw	r30, r24
    1d0c:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    1d0e:	81 e0       	ldi	r24, 0x01	; 1
    1d10:	0e 94 bd 08 	call	0x117a	; 0x117a <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    1d14:	85 e0       	ldi	r24, 0x05	; 5
    1d16:	0e 94 db 19 	call	0x33b6	; 0x33b6 <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    1d1a:	80 ea       	ldi	r24, 0xA0	; 160
    1d1c:	96 e0       	ldi	r25, 0x06	; 6
    1d1e:	22 e0       	ldi	r18, 0x02	; 2
    1d20:	fc 01       	movw	r30, r24
    1d22:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    1d24:	80 ea       	ldi	r24, 0xA0	; 160
    1d26:	96 e0       	ldi	r25, 0x06	; 6
    1d28:	21 e0       	ldi	r18, 0x01	; 1
    1d2a:	fc 01       	movw	r30, r24
    1d2c:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    1d2e:	80 e8       	ldi	r24, 0x80	; 128
    1d30:	91 e0       	ldi	r25, 0x01	; 1
    1d32:	28 e7       	ldi	r18, 0x78	; 120
    1d34:	fc 01       	movw	r30, r24
    1d36:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    1d38:	80 e0       	ldi	r24, 0x00	; 0
    1d3a:	98 e0       	ldi	r25, 0x08	; 8
    1d3c:	20 ef       	ldi	r18, 0xF0	; 240
    1d3e:	fc 01       	movw	r30, r24
    1d40:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    1d42:	80 e0       	ldi	r24, 0x00	; 0
    1d44:	98 e0       	ldi	r25, 0x08	; 8
    1d46:	28 85       	ldd	r18, Y+8	; 0x08
    1d48:	39 85       	ldd	r19, Y+9	; 0x09
    1d4a:	fc 01       	movw	r30, r24
    1d4c:	20 a7       	lds	r18, 0x70
    1d4e:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    1d50:	80 e0       	ldi	r24, 0x00	; 0
    1d52:	98 e0       	ldi	r25, 0x08	; 8
    1d54:	2a 85       	ldd	r18, Y+10	; 0x0a
    1d56:	3b 85       	ldd	r19, Y+11	; 0x0b
    1d58:	fc 01       	movw	r30, r24
    1d5a:	22 a7       	lds	r18, 0x72
    1d5c:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    1d5e:	80 e0       	ldi	r24, 0x00	; 0
    1d60:	98 e0       	ldi	r25, 0x08	; 8
    1d62:	2c 85       	ldd	r18, Y+12	; 0x0c
    1d64:	3d 85       	ldd	r19, Y+13	; 0x0d
    1d66:	fc 01       	movw	r30, r24
    1d68:	24 a7       	lds	r18, 0x74
    1d6a:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    1d6c:	80 e0       	ldi	r24, 0x00	; 0
    1d6e:	98 e0       	ldi	r25, 0x08	; 8
    1d70:	2e 85       	ldd	r18, Y+14	; 0x0e
    1d72:	3f 85       	ldd	r19, Y+15	; 0x0f
    1d74:	fc 01       	movw	r30, r24
    1d76:	26 a7       	lds	r18, 0x76
    1d78:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    1d7a:	80 e0       	ldi	r24, 0x00	; 0
    1d7c:	98 e0       	ldi	r25, 0x08	; 8
    1d7e:	2e 81       	ldd	r18, Y+6	; 0x06
    1d80:	22 2f       	mov	r18, r18
    1d82:	30 e0       	ldi	r19, 0x00	; 0
    1d84:	21 50       	subi	r18, 0x01	; 1
    1d86:	30 40       	sbci	r19, 0x00	; 0
    1d88:	fc 01       	movw	r30, r24
    1d8a:	26 a3       	lds	r18, 0x56
    1d8c:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    1d8e:	80 e0       	ldi	r24, 0x00	; 0
    1d90:	98 e0       	ldi	r25, 0x08	; 8
    1d92:	22 e0       	ldi	r18, 0x02	; 2
    1d94:	fc 01       	movw	r30, r24
    1d96:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    1d98:	80 e0       	ldi	r24, 0x00	; 0
    1d9a:	98 e0       	ldi	r25, 0x08	; 8
    1d9c:	2f ef       	ldi	r18, 0xFF	; 255
    1d9e:	fc 01       	movw	r30, r24
    1da0:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    1da2:	80 e0       	ldi	r24, 0x00	; 0
    1da4:	98 e0       	ldi	r25, 0x08	; 8
    1da6:	20 e0       	ldi	r18, 0x00	; 0
    1da8:	38 e0       	ldi	r19, 0x08	; 8
    1daa:	f9 01       	movw	r30, r18
    1dac:	20 81       	ld	r18, Z
    1dae:	20 7f       	andi	r18, 0xF0	; 240
    1db0:	28 60       	ori	r18, 0x08	; 8
    1db2:	fc 01       	movw	r30, r24
    1db4:	20 83       	st	Z, r18

	sampleCount = 0;
    1db6:	10 92 65 50 	sts	0x5065, r1
    1dba:	10 92 66 50 	sts	0x5066, r1
    1dbe:	10 92 67 50 	sts	0x5067, r1
    1dc2:	10 92 68 50 	sts	0x5068, r1
	SPICount = 0;
    1dc6:	10 92 bf 50 	sts	0x50BF, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    1dca:	80 e0       	ldi	r24, 0x00	; 0
    1dcc:	80 93 2c 21 	sts	0x212C, r24
    1dd0:	80 93 2b 21 	sts	0x212B, r24
    1dd4:	80 93 2a 21 	sts	0x212A, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    1dd8:	80 ea       	ldi	r24, 0xA0	; 160
    1dda:	90 e0       	ldi	r25, 0x00	; 0
    1ddc:	20 ea       	ldi	r18, 0xA0	; 160
    1dde:	30 e0       	ldi	r19, 0x00	; 0
    1de0:	f9 01       	movw	r30, r18
    1de2:	22 81       	ldd	r18, Z+2	; 0x02
    1de4:	26 60       	ori	r18, 0x06	; 6
    1de6:	fc 01       	movw	r30, r24
    1de8:	22 83       	std	Z+2, r18	; 0x02
	sei();
    1dea:	78 94       	sei

	SPICS(TRUE);
    1dec:	81 e0       	ldi	r24, 0x01	; 1
    1dee:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    1df2:	80 e8       	ldi	r24, 0x80	; 128
    1df4:	96 e0       	ldi	r25, 0x06	; 6
    1df6:	20 e2       	ldi	r18, 0x20	; 32
    1df8:	fc 01       	movw	r30, r24
    1dfa:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1dfc:	80 e4       	ldi	r24, 0x40	; 64
    1dfe:	9a e0       	ldi	r25, 0x0A	; 10
    1e00:	23 e2       	ldi	r18, 0x23	; 35
    1e02:	fc 01       	movw	r30, r24
    1e04:	21 83       	std	Z+1, r18	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    1e06:	00 e4       	ldi	r16, 0x40	; 64
    1e08:	1a e0       	ldi	r17, 0x0A	; 10
    1e0a:	8c 81       	ldd	r24, Y+4	; 0x04
    1e0c:	9d 81       	ldd	r25, Y+5	; 0x05
    1e0e:	9c 01       	movw	r18, r24
    1e10:	40 e0       	ldi	r20, 0x00	; 0
    1e12:	50 e0       	ldi	r21, 0x00	; 0
    1e14:	80 e8       	ldi	r24, 0x80	; 128
    1e16:	94 e8       	ldi	r25, 0x84	; 132
    1e18:	ae e1       	ldi	r26, 0x1E	; 30
    1e1a:	b0 e0       	ldi	r27, 0x00	; 0
    1e1c:	bc 01       	movw	r22, r24
    1e1e:	cd 01       	movw	r24, r26
    1e20:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    1e24:	da 01       	movw	r26, r20
    1e26:	c9 01       	movw	r24, r18
    1e28:	f8 01       	movw	r30, r16
    1e2a:	86 a3       	lds	r24, 0x56
    1e2c:	97 a3       	lds	r25, 0x57
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    1e2e:	00 e4       	ldi	r16, 0x40	; 64
    1e30:	1a e0       	ldi	r17, 0x0A	; 10
    1e32:	8c 81       	ldd	r24, Y+4	; 0x04
    1e34:	9d 81       	ldd	r25, Y+5	; 0x05
    1e36:	9c 01       	movw	r18, r24
    1e38:	40 e0       	ldi	r20, 0x00	; 0
    1e3a:	50 e0       	ldi	r21, 0x00	; 0
    1e3c:	80 e4       	ldi	r24, 0x40	; 64
    1e3e:	92 e4       	ldi	r25, 0x42	; 66
    1e40:	af e0       	ldi	r26, 0x0F	; 15
    1e42:	b0 e0       	ldi	r27, 0x00	; 0
    1e44:	bc 01       	movw	r22, r24
    1e46:	cd 01       	movw	r24, r26
    1e48:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    1e4c:	da 01       	movw	r26, r20
    1e4e:	c9 01       	movw	r24, r18
    1e50:	f8 01       	movw	r30, r16
    1e52:	82 af       	sts	0x72, r24
    1e54:	93 af       	sts	0x73, r25
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1e56:	80 e4       	ldi	r24, 0x40	; 64
    1e58:	9a e0       	ldi	r25, 0x0A	; 10
    1e5a:	20 e4       	ldi	r18, 0x40	; 64
    1e5c:	3a e0       	ldi	r19, 0x0A	; 10
    1e5e:	f9 01       	movw	r30, r18
    1e60:	20 81       	ld	r18, Z
    1e62:	20 7f       	andi	r18, 0xF0	; 240
    1e64:	21 60       	ori	r18, 0x01	; 1
    1e66:	fc 01       	movw	r30, r24
    1e68:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    1e6a:	00 00       	nop
    1e6c:	20 91 65 50 	lds	r18, 0x5065
    1e70:	30 91 66 50 	lds	r19, 0x5066
    1e74:	40 91 67 50 	lds	r20, 0x5067
    1e78:	50 91 68 50 	lds	r21, 0x5068
    1e7c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1e7e:	98 a1       	lds	r25, 0x48
    1e80:	a9 a1       	lds	r26, 0x49
    1e82:	ba a1       	lds	r27, 0x4a
    1e84:	28 17       	cp	r18, r24
    1e86:	39 07       	cpc	r19, r25
    1e88:	4a 07       	cpc	r20, r26
    1e8a:	5b 07       	cpc	r21, r27
    1e8c:	78 f3       	brcs	.-34     	; 0x1e6c <CO_collectSeismic3Axises+0x200>

	// turn off timer and interrupts
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1e8e:	80 e0       	ldi	r24, 0x00	; 0
    1e90:	98 e0       	ldi	r25, 0x08	; 8
    1e92:	20 e0       	ldi	r18, 0x00	; 0
    1e94:	38 e0       	ldi	r19, 0x08	; 8
    1e96:	f9 01       	movw	r30, r18
    1e98:	20 81       	ld	r18, Z
    1e9a:	20 7f       	andi	r18, 0xF0	; 240
    1e9c:	fc 01       	movw	r30, r24
    1e9e:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1ea0:	80 e4       	ldi	r24, 0x40	; 64
    1ea2:	9a e0       	ldi	r25, 0x0A	; 10
    1ea4:	20 e4       	ldi	r18, 0x40	; 64
    1ea6:	3a e0       	ldi	r19, 0x0A	; 10
    1ea8:	f9 01       	movw	r30, r18
    1eaa:	20 81       	ld	r18, Z
    1eac:	20 7f       	andi	r18, 0xF0	; 240
    1eae:	fc 01       	movw	r30, r24
    1eb0:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    1eb2:	80 ea       	ldi	r24, 0xA0	; 160
    1eb4:	90 e0       	ldi	r25, 0x00	; 0
    1eb6:	20 ea       	ldi	r18, 0xA0	; 160
    1eb8:	30 e0       	ldi	r19, 0x00	; 0
    1eba:	f9 01       	movw	r30, r18
    1ebc:	22 81       	ldd	r18, Z+2	; 0x02
    1ebe:	29 7f       	andi	r18, 0xF9	; 249
    1ec0:	fc 01       	movw	r30, r24
    1ec2:	22 83       	std	Z+2, r18	; 0x02
	cli();
    1ec4:	f8 94       	cli

	SPICS(FALSE);
    1ec6:	80 e0       	ldi	r24, 0x00	; 0
    1ec8:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	SPIDisable();
    1ecc:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>
	enableADCMUX(FALSE);
    1ed0:	80 e0       	ldi	r24, 0x00	; 0
    1ed2:	0e 94 bd 08 	call	0x117a	; 0x117a <enableADCMUX>
	//ADCPower(FALSE);
}
    1ed6:	2f 96       	adiw	r28, 0x0f	; 15
    1ed8:	cd bf       	out	0x3d, r28	; 61
    1eda:	de bf       	out	0x3e, r29	; 62
    1edc:	df 91       	pop	r29
    1ede:	cf 91       	pop	r28
    1ee0:	1f 91       	pop	r17
    1ee2:	0f 91       	pop	r16
    1ee4:	ff 90       	pop	r15
    1ee6:	ef 90       	pop	r14
    1ee8:	df 90       	pop	r13
    1eea:	cf 90       	pop	r12
    1eec:	bf 90       	pop	r11
    1eee:	af 90       	pop	r10
    1ef0:	9f 90       	pop	r9
    1ef2:	8f 90       	pop	r8
    1ef4:	08 95       	ret

00001ef6 <__vector_16>:

//first averaging point
ISR(TCC0_CCA_vect) {
    1ef6:	1f 92       	push	r1
    1ef8:	0f 92       	push	r0
    1efa:	0f b6       	in	r0, 0x3f	; 63
    1efc:	0f 92       	push	r0
    1efe:	00 90 3b 00 	lds	r0, 0x003B
    1f02:	0f 92       	push	r0
    1f04:	11 24       	eor	r1, r1
    1f06:	2f 93       	push	r18
    1f08:	3f 93       	push	r19
    1f0a:	4f 93       	push	r20
    1f0c:	5f 93       	push	r21
    1f0e:	6f 93       	push	r22
    1f10:	7f 93       	push	r23
    1f12:	8f 93       	push	r24
    1f14:	9f 93       	push	r25
    1f16:	af 93       	push	r26
    1f18:	bf 93       	push	r27
    1f1a:	ef 93       	push	r30
    1f1c:	ff 93       	push	r31
    1f1e:	cf 93       	push	r28
    1f20:	df 93       	push	r29
    1f22:	cd b7       	in	r28, 0x3d	; 61
    1f24:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    1f26:	0e 94 e7 13 	call	0x27ce	; 0x27ce <sampleCurrentChannel>
}
    1f2a:	df 91       	pop	r29
    1f2c:	cf 91       	pop	r28
    1f2e:	ff 91       	pop	r31
    1f30:	ef 91       	pop	r30
    1f32:	bf 91       	pop	r27
    1f34:	af 91       	pop	r26
    1f36:	9f 91       	pop	r25
    1f38:	8f 91       	pop	r24
    1f3a:	7f 91       	pop	r23
    1f3c:	6f 91       	pop	r22
    1f3e:	5f 91       	pop	r21
    1f40:	4f 91       	pop	r20
    1f42:	3f 91       	pop	r19
    1f44:	2f 91       	pop	r18
    1f46:	0f 90       	pop	r0
    1f48:	00 92 3b 00 	sts	0x003B, r0
    1f4c:	0f 90       	pop	r0
    1f4e:	0f be       	out	0x3f, r0	; 63
    1f50:	0f 90       	pop	r0
    1f52:	1f 90       	pop	r1
    1f54:	18 95       	reti

00001f56 <__vector_17>:

//second averaging point
ISR(TCC0_CCB_vect) {
    1f56:	1f 92       	push	r1
    1f58:	0f 92       	push	r0
    1f5a:	0f b6       	in	r0, 0x3f	; 63
    1f5c:	0f 92       	push	r0
    1f5e:	00 90 3b 00 	lds	r0, 0x003B
    1f62:	0f 92       	push	r0
    1f64:	11 24       	eor	r1, r1
    1f66:	2f 93       	push	r18
    1f68:	3f 93       	push	r19
    1f6a:	4f 93       	push	r20
    1f6c:	5f 93       	push	r21
    1f6e:	6f 93       	push	r22
    1f70:	7f 93       	push	r23
    1f72:	8f 93       	push	r24
    1f74:	9f 93       	push	r25
    1f76:	af 93       	push	r26
    1f78:	bf 93       	push	r27
    1f7a:	ef 93       	push	r30
    1f7c:	ff 93       	push	r31
    1f7e:	cf 93       	push	r28
    1f80:	df 93       	push	r29
    1f82:	cd b7       	in	r28, 0x3d	; 61
    1f84:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    1f86:	0e 94 e7 13 	call	0x27ce	; 0x27ce <sampleCurrentChannel>
}
    1f8a:	df 91       	pop	r29
    1f8c:	cf 91       	pop	r28
    1f8e:	ff 91       	pop	r31
    1f90:	ef 91       	pop	r30
    1f92:	bf 91       	pop	r27
    1f94:	af 91       	pop	r26
    1f96:	9f 91       	pop	r25
    1f98:	8f 91       	pop	r24
    1f9a:	7f 91       	pop	r23
    1f9c:	6f 91       	pop	r22
    1f9e:	5f 91       	pop	r21
    1fa0:	4f 91       	pop	r20
    1fa2:	3f 91       	pop	r19
    1fa4:	2f 91       	pop	r18
    1fa6:	0f 90       	pop	r0
    1fa8:	00 92 3b 00 	sts	0x003B, r0
    1fac:	0f 90       	pop	r0
    1fae:	0f be       	out	0x3f, r0	; 63
    1fb0:	0f 90       	pop	r0
    1fb2:	1f 90       	pop	r1
    1fb4:	18 95       	reti

00001fb6 <__vector_18>:

//third averaging point
ISR(TCC0_CCC_vect) {
    1fb6:	1f 92       	push	r1
    1fb8:	0f 92       	push	r0
    1fba:	0f b6       	in	r0, 0x3f	; 63
    1fbc:	0f 92       	push	r0
    1fbe:	00 90 3b 00 	lds	r0, 0x003B
    1fc2:	0f 92       	push	r0
    1fc4:	11 24       	eor	r1, r1
    1fc6:	2f 93       	push	r18
    1fc8:	3f 93       	push	r19
    1fca:	4f 93       	push	r20
    1fcc:	5f 93       	push	r21
    1fce:	6f 93       	push	r22
    1fd0:	7f 93       	push	r23
    1fd2:	8f 93       	push	r24
    1fd4:	9f 93       	push	r25
    1fd6:	af 93       	push	r26
    1fd8:	bf 93       	push	r27
    1fda:	ef 93       	push	r30
    1fdc:	ff 93       	push	r31
    1fde:	cf 93       	push	r28
    1fe0:	df 93       	push	r29
    1fe2:	cd b7       	in	r28, 0x3d	; 61
    1fe4:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    1fe6:	0e 94 e7 13 	call	0x27ce	; 0x27ce <sampleCurrentChannel>
}
    1fea:	df 91       	pop	r29
    1fec:	cf 91       	pop	r28
    1fee:	ff 91       	pop	r31
    1ff0:	ef 91       	pop	r30
    1ff2:	bf 91       	pop	r27
    1ff4:	af 91       	pop	r26
    1ff6:	9f 91       	pop	r25
    1ff8:	8f 91       	pop	r24
    1ffa:	7f 91       	pop	r23
    1ffc:	6f 91       	pop	r22
    1ffe:	5f 91       	pop	r21
    2000:	4f 91       	pop	r20
    2002:	3f 91       	pop	r19
    2004:	2f 91       	pop	r18
    2006:	0f 90       	pop	r0
    2008:	00 92 3b 00 	sts	0x003B, r0
    200c:	0f 90       	pop	r0
    200e:	0f be       	out	0x3f, r0	; 63
    2010:	0f 90       	pop	r0
    2012:	1f 90       	pop	r1
    2014:	18 95       	reti

00002016 <__vector_19>:

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    2016:	1f 92       	push	r1
    2018:	0f 92       	push	r0
    201a:	0f b6       	in	r0, 0x3f	; 63
    201c:	0f 92       	push	r0
    201e:	00 90 3b 00 	lds	r0, 0x003B
    2022:	0f 92       	push	r0
    2024:	11 24       	eor	r1, r1
    2026:	2f 93       	push	r18
    2028:	3f 93       	push	r19
    202a:	4f 93       	push	r20
    202c:	5f 93       	push	r21
    202e:	6f 93       	push	r22
    2030:	7f 93       	push	r23
    2032:	8f 93       	push	r24
    2034:	9f 93       	push	r25
    2036:	af 93       	push	r26
    2038:	bf 93       	push	r27
    203a:	ef 93       	push	r30
    203c:	ff 93       	push	r31
    203e:	cf 93       	push	r28
    2040:	df 93       	push	r29
    2042:	cd b7       	in	r28, 0x3d	; 61
    2044:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2046:	0e 94 e7 13 	call	0x27ce	; 0x27ce <sampleCurrentChannel>
	SPICount = 0;
    204a:	10 92 bf 50 	sts	0x50BF, r1
	if(PORTB.OUT & PIN1_bm) {
    204e:	80 e2       	ldi	r24, 0x20	; 32
    2050:	96 e0       	ldi	r25, 0x06	; 6
    2052:	fc 01       	movw	r30, r24
    2054:	84 81       	ldd	r24, Z+4	; 0x04
    2056:	88 2f       	mov	r24, r24
    2058:	90 e0       	ldi	r25, 0x00	; 0
    205a:	82 70       	andi	r24, 0x02	; 2
    205c:	90 70       	andi	r25, 0x00	; 0
    205e:	00 97       	sbiw	r24, 0x00	; 0
    2060:	b1 f0       	breq	.+44     	; 0x208e <__vector_19+0x78>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    2062:	80 e0       	ldi	r24, 0x00	; 0
    2064:	96 e0       	ldi	r25, 0x06	; 6
    2066:	fc 01       	movw	r30, r24
    2068:	84 81       	ldd	r24, Z+4	; 0x04
    206a:	88 2f       	mov	r24, r24
    206c:	90 e0       	ldi	r25, 0x00	; 0
    206e:	80 74       	andi	r24, 0x40	; 64
    2070:	90 70       	andi	r25, 0x00	; 0
    2072:	00 97       	sbiw	r24, 0x00	; 0
    2074:	31 f0       	breq	.+12     	; 0x2082 <__vector_19+0x6c>
    2076:	80 e2       	ldi	r24, 0x20	; 32
    2078:	96 e0       	ldi	r25, 0x06	; 6
    207a:	22 e0       	ldi	r18, 0x02	; 2
    207c:	fc 01       	movw	r30, r24
    207e:	27 83       	std	Z+7, r18	; 0x07
    2080:	10 c0       	rjmp	.+32     	; 0x20a2 <__vector_19+0x8c>
		else PORTA.OUTTGL = PIN6_bm;
    2082:	80 e0       	ldi	r24, 0x00	; 0
    2084:	96 e0       	ldi	r25, 0x06	; 6
    2086:	20 e4       	ldi	r18, 0x40	; 64
    2088:	fc 01       	movw	r30, r24
    208a:	27 83       	std	Z+7, r18	; 0x07
    208c:	0a c0       	rjmp	.+20     	; 0x20a2 <__vector_19+0x8c>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    208e:	80 e0       	ldi	r24, 0x00	; 0
    2090:	96 e0       	ldi	r25, 0x06	; 6
    2092:	20 e4       	ldi	r18, 0x40	; 64
    2094:	fc 01       	movw	r30, r24
    2096:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTSET = PIN1_bm;
    2098:	80 e2       	ldi	r24, 0x20	; 32
    209a:	96 e0       	ldi	r25, 0x06	; 6
    209c:	22 e0       	ldi	r18, 0x02	; 2
    209e:	fc 01       	movw	r30, r24
    20a0:	25 83       	std	Z+5, r18	; 0x05
	}
	
}
    20a2:	df 91       	pop	r29
    20a4:	cf 91       	pop	r28
    20a6:	ff 91       	pop	r31
    20a8:	ef 91       	pop	r30
    20aa:	bf 91       	pop	r27
    20ac:	af 91       	pop	r26
    20ae:	9f 91       	pop	r25
    20b0:	8f 91       	pop	r24
    20b2:	7f 91       	pop	r23
    20b4:	6f 91       	pop	r22
    20b6:	5f 91       	pop	r21
    20b8:	4f 91       	pop	r20
    20ba:	3f 91       	pop	r19
    20bc:	2f 91       	pop	r18
    20be:	0f 90       	pop	r0
    20c0:	00 92 3b 00 	sts	0x003B, r0
    20c4:	0f 90       	pop	r0
    20c6:	0f be       	out	0x3f, r0	; 63
    20c8:	0f 90       	pop	r0
    20ca:	1f 90       	pop	r1
    20cc:	18 95       	reti

000020ce <__vector_14>:

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    20ce:	1f 92       	push	r1
    20d0:	0f 92       	push	r0
    20d2:	0f b6       	in	r0, 0x3f	; 63
    20d4:	0f 92       	push	r0
    20d6:	00 90 3b 00 	lds	r0, 0x003B
    20da:	0f 92       	push	r0
    20dc:	11 24       	eor	r1, r1
    20de:	2f 93       	push	r18
    20e0:	3f 93       	push	r19
    20e2:	4f 93       	push	r20
    20e4:	5f 93       	push	r21
    20e6:	6f 93       	push	r22
    20e8:	7f 93       	push	r23
    20ea:	8f 93       	push	r24
    20ec:	9f 93       	push	r25
    20ee:	af 93       	push	r26
    20f0:	bf 93       	push	r27
    20f2:	ef 93       	push	r30
    20f4:	ff 93       	push	r31
    20f6:	cf 93       	push	r28
    20f8:	df 93       	push	r29
    20fa:	cd b7       	in	r28, 0x3d	; 61
    20fc:	de b7       	in	r29, 0x3e	; 62
    20fe:	29 97       	sbiw	r28, 0x09	; 9
    2100:	cd bf       	out	0x3d, r28	; 61
    2102:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    2104:	1a 82       	std	Y+2, r1	; 0x02
    2106:	1b 82       	std	Y+3, r1	; 0x03
    2108:	1c 82       	std	Y+4, r1	; 0x04
    210a:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    210c:	19 82       	std	Y+1, r1	; 0x01
    210e:	4f c0       	rjmp	.+158    	; 0x21ae <__vector_14+0xe0>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2110:	89 81       	ldd	r24, Y+1	; 0x01
    2112:	88 2f       	mov	r24, r24
    2114:	90 e0       	ldi	r25, 0x00	; 0
    2116:	8a 5a       	subi	r24, 0xAA	; 170
    2118:	9f 4a       	sbci	r25, 0xAF	; 175
    211a:	fc 01       	movw	r30, r24
    211c:	80 81       	ld	r24, Z
    211e:	88 23       	and	r24, r24
    2120:	3c f4       	brge	.+14     	; 0x2130 <__vector_14+0x62>
    2122:	ce 01       	movw	r24, r28
    2124:	06 96       	adiw	r24, 0x06	; 6
    2126:	03 96       	adiw	r24, 0x03	; 3
    2128:	2f ef       	ldi	r18, 0xFF	; 255
    212a:	fc 01       	movw	r30, r24
    212c:	20 83       	st	Z, r18
    212e:	05 c0       	rjmp	.+10     	; 0x213a <__vector_14+0x6c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    2130:	ce 01       	movw	r24, r28
    2132:	06 96       	adiw	r24, 0x06	; 6
    2134:	03 96       	adiw	r24, 0x03	; 3
    2136:	fc 01       	movw	r30, r24
    2138:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    213a:	ce 01       	movw	r24, r28
    213c:	06 96       	adiw	r24, 0x06	; 6
    213e:	02 96       	adiw	r24, 0x02	; 2
    2140:	29 81       	ldd	r18, Y+1	; 0x01
    2142:	22 2f       	mov	r18, r18
    2144:	30 e0       	ldi	r19, 0x00	; 0
    2146:	2a 5a       	subi	r18, 0xAA	; 170
    2148:	3f 4a       	sbci	r19, 0xAF	; 175
    214a:	f9 01       	movw	r30, r18
    214c:	20 81       	ld	r18, Z
    214e:	fc 01       	movw	r30, r24
    2150:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    2152:	ce 01       	movw	r24, r28
    2154:	06 96       	adiw	r24, 0x06	; 6
    2156:	01 96       	adiw	r24, 0x01	; 1
    2158:	29 81       	ldd	r18, Y+1	; 0x01
    215a:	22 2f       	mov	r18, r18
    215c:	30 e0       	ldi	r19, 0x00	; 0
    215e:	2f 5f       	subi	r18, 0xFF	; 255
    2160:	3f 4f       	sbci	r19, 0xFF	; 255
    2162:	2a 5a       	subi	r18, 0xAA	; 170
    2164:	3f 4a       	sbci	r19, 0xAF	; 175
    2166:	f9 01       	movw	r30, r18
    2168:	20 81       	ld	r18, Z
    216a:	fc 01       	movw	r30, r24
    216c:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    216e:	ce 01       	movw	r24, r28
    2170:	06 96       	adiw	r24, 0x06	; 6
    2172:	29 81       	ldd	r18, Y+1	; 0x01
    2174:	22 2f       	mov	r18, r18
    2176:	30 e0       	ldi	r19, 0x00	; 0
    2178:	2e 5f       	subi	r18, 0xFE	; 254
    217a:	3f 4f       	sbci	r19, 0xFF	; 255
    217c:	2a 5a       	subi	r18, 0xAA	; 170
    217e:	3f 4a       	sbci	r19, 0xAF	; 175
    2180:	f9 01       	movw	r30, r18
    2182:	20 81       	ld	r18, Z
    2184:	fc 01       	movw	r30, r24
    2186:	20 83       	st	Z, r18
		sum += currentSample;
    2188:	2a 81       	ldd	r18, Y+2	; 0x02
    218a:	3b 81       	ldd	r19, Y+3	; 0x03
    218c:	4c 81       	ldd	r20, Y+4	; 0x04
    218e:	5d 81       	ldd	r21, Y+5	; 0x05
    2190:	8e 81       	ldd	r24, Y+6	; 0x06
    2192:	9f 81       	ldd	r25, Y+7	; 0x07
    2194:	a8 85       	ldd	r26, Y+8	; 0x08
    2196:	b9 85       	ldd	r27, Y+9	; 0x09
    2198:	82 0f       	add	r24, r18
    219a:	93 1f       	adc	r25, r19
    219c:	a4 1f       	adc	r26, r20
    219e:	b5 1f       	adc	r27, r21
    21a0:	8a 83       	std	Y+2, r24	; 0x02
    21a2:	9b 83       	std	Y+3, r25	; 0x03
    21a4:	ac 83       	std	Y+4, r26	; 0x04
    21a6:	bd 83       	std	Y+5, r27	; 0x05
//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
	volatile int32_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    21a8:	89 81       	ldd	r24, Y+1	; 0x01
    21aa:	8d 5f       	subi	r24, 0xFD	; 253
    21ac:	89 83       	std	Y+1, r24	; 0x01
    21ae:	89 81       	ldd	r24, Y+1	; 0x01
    21b0:	8c 30       	cpi	r24, 0x0C	; 12
    21b2:	08 f4       	brcc	.+2      	; 0x21b6 <__vector_14+0xe8>
    21b4:	ad cf       	rjmp	.-166    	; 0x2110 <__vector_14+0x42>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    21b6:	8a 81       	ldd	r24, Y+2	; 0x02
    21b8:	9b 81       	ldd	r25, Y+3	; 0x03
    21ba:	ac 81       	ldd	r26, Y+4	; 0x04
    21bc:	bd 81       	ldd	r27, Y+5	; 0x05
    21be:	24 e0       	ldi	r18, 0x04	; 4
    21c0:	30 e0       	ldi	r19, 0x00	; 0
    21c2:	40 e0       	ldi	r20, 0x00	; 0
    21c4:	50 e0       	ldi	r21, 0x00	; 0
    21c6:	bc 01       	movw	r22, r24
    21c8:	cd 01       	movw	r24, r26
    21ca:	0e 94 06 5c 	call	0xb80c	; 0xb80c <__divmodsi4>
    21ce:	da 01       	movw	r26, r20
    21d0:	c9 01       	movw	r24, r18
    21d2:	8a 83       	std	Y+2, r24	; 0x02
    21d4:	9b 83       	std	Y+3, r25	; 0x03
    21d6:	ac 83       	std	Y+4, r26	; 0x04
    21d8:	bd 83       	std	Y+5, r27	; 0x05
	ADC_BUFFER[sampleCount] = currentSample;
    21da:	20 91 63 50 	lds	r18, 0x5063
    21de:	30 91 64 50 	lds	r19, 0x5064
    21e2:	80 91 65 50 	lds	r24, 0x5065
    21e6:	90 91 66 50 	lds	r25, 0x5066
    21ea:	a0 91 67 50 	lds	r26, 0x5067
    21ee:	b0 91 68 50 	lds	r27, 0x5068
    21f2:	88 0f       	add	r24, r24
    21f4:	99 1f       	adc	r25, r25
    21f6:	88 0f       	add	r24, r24
    21f8:	99 1f       	adc	r25, r25
    21fa:	28 0f       	add	r18, r24
    21fc:	39 1f       	adc	r19, r25
    21fe:	8e 81       	ldd	r24, Y+6	; 0x06
    2200:	9f 81       	ldd	r25, Y+7	; 0x07
    2202:	a8 85       	ldd	r26, Y+8	; 0x08
    2204:	b9 85       	ldd	r27, Y+9	; 0x09
    2206:	f9 01       	movw	r30, r18
    2208:	80 83       	st	Z, r24
    220a:	91 83       	std	Z+1, r25	; 0x01
    220c:	a2 83       	std	Z+2, r26	; 0x02
    220e:	b3 83       	std	Z+3, r27	; 0x03
	sampleCount++;
    2210:	80 91 65 50 	lds	r24, 0x5065
    2214:	90 91 66 50 	lds	r25, 0x5066
    2218:	a0 91 67 50 	lds	r26, 0x5067
    221c:	b0 91 68 50 	lds	r27, 0x5068
    2220:	01 96       	adiw	r24, 0x01	; 1
    2222:	a1 1d       	adc	r26, r1
    2224:	b1 1d       	adc	r27, r1
    2226:	80 93 65 50 	sts	0x5065, r24
    222a:	90 93 66 50 	sts	0x5066, r25
    222e:	a0 93 67 50 	sts	0x5067, r26
    2232:	b0 93 68 50 	sts	0x5068, r27

}
    2236:	29 96       	adiw	r28, 0x09	; 9
    2238:	cd bf       	out	0x3d, r28	; 61
    223a:	de bf       	out	0x3e, r29	; 62
    223c:	df 91       	pop	r29
    223e:	cf 91       	pop	r28
    2240:	ff 91       	pop	r31
    2242:	ef 91       	pop	r30
    2244:	bf 91       	pop	r27
    2246:	af 91       	pop	r26
    2248:	9f 91       	pop	r25
    224a:	8f 91       	pop	r24
    224c:	7f 91       	pop	r23
    224e:	6f 91       	pop	r22
    2250:	5f 91       	pop	r21
    2252:	4f 91       	pop	r20
    2254:	3f 91       	pop	r19
    2256:	2f 91       	pop	r18
    2258:	0f 90       	pop	r0
    225a:	00 92 3b 00 	sts	0x003B, r0
    225e:	0f 90       	pop	r0
    2260:	0f be       	out	0x3f, r0	; 63
    2262:	0f 90       	pop	r0
    2264:	1f 90       	pop	r1
    2266:	18 95       	reti

00002268 <CO_collectSeismic1Channel>:

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint16_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint32_t numOfSamples, int32_t* DataArray) {
    2268:	8f 92       	push	r8
    226a:	9f 92       	push	r9
    226c:	af 92       	push	r10
    226e:	bf 92       	push	r11
    2270:	cf 92       	push	r12
    2272:	df 92       	push	r13
    2274:	ef 92       	push	r14
    2276:	0f 93       	push	r16
    2278:	1f 93       	push	r17
    227a:	cf 93       	push	r28
    227c:	df 93       	push	r29
    227e:	cd b7       	in	r28, 0x3d	; 61
    2280:	de b7       	in	r29, 0x3e	; 62
    2282:	2d 97       	sbiw	r28, 0x0d	; 13
    2284:	cd bf       	out	0x3d, r28	; 61
    2286:	de bf       	out	0x3e, r29	; 62
    2288:	89 83       	std	Y+1, r24	; 0x01
    228a:	6a 83       	std	Y+2, r22	; 0x02
    228c:	4b 83       	std	Y+3, r20	; 0x03
    228e:	2c 83       	std	Y+4, r18	; 0x04
    2290:	3d 83       	std	Y+5, r19	; 0x05
    2292:	0e 83       	std	Y+6, r16	; 0x06
    2294:	ef 82       	std	Y+7, r14	; 0x07
    2296:	c8 86       	std	Y+8, r12	; 0x08
    2298:	d9 86       	std	Y+9, r13	; 0x09
    229a:	aa 86       	std	Y+10, r10	; 0x0a
    229c:	bb 86       	std	Y+11, r11	; 0x0b
    229e:	8c 86       	std	Y+12, r8	; 0x0c
    22a0:	9d 86       	std	Y+13, r9	; 0x0d
	
	ADC_BUFFER=DataArray;
    22a2:	8a a1       	lds	r24, 0x4a
    22a4:	9b a1       	lds	r25, 0x4b
    22a6:	80 93 63 50 	sts	0x5063, r24
    22aa:	90 93 64 50 	sts	0x5064, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    22ae:	81 e0       	ldi	r24, 0x01	; 1
    22b0:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    22b4:	89 81       	ldd	r24, Y+1	; 0x01
    22b6:	6b 81       	ldd	r22, Y+3	; 0x03
    22b8:	0e 94 0e 07 	call	0xe1c	; 0xe1c <set_ampGain>
	set_filter(filterConfig);
    22bc:	8a 81       	ldd	r24, Y+2	; 0x02
    22be:	0e 94 3d 08 	call	0x107a	; 0x107a <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    22c2:	8f 81       	ldd	r24, Y+7	; 0x07
    22c4:	0e 94 1c 0e 	call	0x1c38	; 0x1c38 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    22c8:	84 e0       	ldi	r24, 0x04	; 4
    22ca:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    22ce:	80 ec       	ldi	r24, 0xC0	; 192
    22d0:	98 e0       	ldi	r25, 0x08	; 8
    22d2:	24 e5       	ldi	r18, 0x54	; 84
    22d4:	fc 01       	movw	r30, r24
    22d6:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    22d8:	81 e0       	ldi	r24, 0x01	; 1
    22da:	0e 94 bd 08 	call	0x117a	; 0x117a <enableADCMUX>
	setADCInput(channel);
    22de:	89 81       	ldd	r24, Y+1	; 0x01
    22e0:	0e 94 db 19 	call	0x33b6	; 0x33b6 <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    22e4:	80 ea       	ldi	r24, 0xA0	; 160
    22e6:	96 e0       	ldi	r25, 0x06	; 6
    22e8:	22 e0       	ldi	r18, 0x02	; 2
    22ea:	fc 01       	movw	r30, r24
    22ec:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    22ee:	80 ea       	ldi	r24, 0xA0	; 160
    22f0:	96 e0       	ldi	r25, 0x06	; 6
    22f2:	21 e0       	ldi	r18, 0x01	; 1
    22f4:	fc 01       	movw	r30, r24
    22f6:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    22f8:	80 e8       	ldi	r24, 0x80	; 128
    22fa:	91 e0       	ldi	r25, 0x01	; 1
    22fc:	28 e7       	ldi	r18, 0x78	; 120
    22fe:	fc 01       	movw	r30, r24
    2300:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    2302:	80 e0       	ldi	r24, 0x00	; 0
    2304:	99 e0       	ldi	r25, 0x09	; 9
    2306:	20 ef       	ldi	r18, 0xF0	; 240
    2308:	fc 01       	movw	r30, r24
    230a:	21 83       	std	Z+1, r18	; 0x01
	TCD0.CCA = averagingPtA;
    230c:	80 e0       	ldi	r24, 0x00	; 0
    230e:	99 e0       	ldi	r25, 0x09	; 9
    2310:	28 85       	ldd	r18, Y+8	; 0x08
    2312:	39 85       	ldd	r19, Y+9	; 0x09
    2314:	fc 01       	movw	r30, r24
    2316:	20 a7       	lds	r18, 0x70
    2318:	31 a7       	lds	r19, 0x71
	TCD0.CCB = averagingPtB;
    231a:	80 e0       	ldi	r24, 0x00	; 0
    231c:	99 e0       	ldi	r25, 0x09	; 9
    231e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2320:	3b 85       	ldd	r19, Y+11	; 0x0b
    2322:	fc 01       	movw	r30, r24
    2324:	22 a7       	lds	r18, 0x72
    2326:	33 a7       	lds	r19, 0x73
	TCD0.CCC = averagingPtC;
    2328:	80 e0       	ldi	r24, 0x00	; 0
    232a:	99 e0       	ldi	r25, 0x09	; 9
    232c:	2c 85       	ldd	r18, Y+12	; 0x0c
    232e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2330:	fc 01       	movw	r30, r24
    2332:	24 a7       	lds	r18, 0x74
    2334:	35 a7       	lds	r19, 0x75
	TCD0.CCD = averagingPtD;
    2336:	80 e0       	ldi	r24, 0x00	; 0
    2338:	99 e0       	ldi	r25, 0x09	; 9
    233a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    233c:	3d 8d       	ldd	r19, Y+29	; 0x1d
    233e:	fc 01       	movw	r30, r24
    2340:	26 a7       	lds	r18, 0x76
    2342:	37 a7       	lds	r19, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    2344:	80 e0       	ldi	r24, 0x00	; 0
    2346:	99 e0       	ldi	r25, 0x09	; 9
    2348:	2e 81       	ldd	r18, Y+6	; 0x06
    234a:	22 2f       	mov	r18, r18
    234c:	30 e0       	ldi	r19, 0x00	; 0
    234e:	21 50       	subi	r18, 0x01	; 1
    2350:	30 40       	sbci	r19, 0x00	; 0
    2352:	fc 01       	movw	r30, r24
    2354:	26 a3       	lds	r18, 0x56
    2356:	37 a3       	lds	r19, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2358:	80 e0       	ldi	r24, 0x00	; 0
    235a:	99 e0       	ldi	r25, 0x09	; 9
    235c:	22 e0       	ldi	r18, 0x02	; 2
    235e:	fc 01       	movw	r30, r24
    2360:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    2362:	80 e0       	ldi	r24, 0x00	; 0
    2364:	99 e0       	ldi	r25, 0x09	; 9
    2366:	2f ef       	ldi	r18, 0xFF	; 255
    2368:	fc 01       	movw	r30, r24
    236a:	27 83       	std	Z+7, r18	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    236c:	80 e0       	ldi	r24, 0x00	; 0
    236e:	99 e0       	ldi	r25, 0x09	; 9
    2370:	20 e0       	ldi	r18, 0x00	; 0
    2372:	39 e0       	ldi	r19, 0x09	; 9
    2374:	f9 01       	movw	r30, r18
    2376:	20 81       	ld	r18, Z
    2378:	20 7f       	andi	r18, 0xF0	; 240
    237a:	28 60       	ori	r18, 0x08	; 8
    237c:	fc 01       	movw	r30, r24
    237e:	20 83       	st	Z, r18

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    2380:	10 92 65 50 	sts	0x5065, r1
    2384:	10 92 66 50 	sts	0x5066, r1
    2388:	10 92 67 50 	sts	0x5067, r1
    238c:	10 92 68 50 	sts	0x5068, r1
	SPICount = 0;
    2390:	10 92 bf 50 	sts	0x50BF, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm;
    2394:	80 ea       	ldi	r24, 0xA0	; 160
    2396:	90 e0       	ldi	r25, 0x00	; 0
    2398:	20 ea       	ldi	r18, 0xA0	; 160
    239a:	30 e0       	ldi	r19, 0x00	; 0
    239c:	f9 01       	movw	r30, r18
    239e:	22 81       	ldd	r18, Z+2	; 0x02
    23a0:	26 60       	ori	r18, 0x06	; 6
    23a2:	fc 01       	movw	r30, r24
    23a4:	22 83       	std	Z+2, r18	; 0x02
	sei();
    23a6:	78 94       	sei

	SPICS(TRUE);
    23a8:	81 e0       	ldi	r24, 0x01	; 1
    23aa:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    23ae:	80 e8       	ldi	r24, 0x80	; 128
    23b0:	96 e0       	ldi	r25, 0x06	; 6
    23b2:	20 e2       	ldi	r18, 0x20	; 32
    23b4:	fc 01       	movw	r30, r24
    23b6:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    23b8:	80 e4       	ldi	r24, 0x40	; 64
    23ba:	9a e0       	ldi	r25, 0x0A	; 10
    23bc:	23 e2       	ldi	r18, 0x23	; 35
    23be:	fc 01       	movw	r30, r24
    23c0:	21 83       	std	Z+1, r18	; 0x01
	// set period
	//TCE1.PER = (0x20 << subsamplesPerSecond);
	//TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
	TCE1.PER = (F_CPU/16)/subsamplesPerSecond;
    23c2:	00 e4       	ldi	r16, 0x40	; 64
    23c4:	1a e0       	ldi	r17, 0x0A	; 10
    23c6:	8c 81       	ldd	r24, Y+4	; 0x04
    23c8:	9d 81       	ldd	r25, Y+5	; 0x05
    23ca:	9c 01       	movw	r18, r24
    23cc:	40 e0       	ldi	r20, 0x00	; 0
    23ce:	50 e0       	ldi	r21, 0x00	; 0
    23d0:	80 e8       	ldi	r24, 0x80	; 128
    23d2:	94 e8       	ldi	r25, 0x84	; 132
    23d4:	ae e1       	ldi	r26, 0x1E	; 30
    23d6:	b0 e0       	ldi	r27, 0x00	; 0
    23d8:	bc 01       	movw	r22, r24
    23da:	cd 01       	movw	r24, r26
    23dc:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    23e0:	da 01       	movw	r26, r20
    23e2:	c9 01       	movw	r24, r18
    23e4:	f8 01       	movw	r30, r16
    23e6:	86 a3       	lds	r24, 0x56
    23e8:	97 a3       	lds	r25, 0x57
	TCE1.CCBBUF = ((F_CPU/16)/subsamplesPerSecond)/2;
    23ea:	00 e4       	ldi	r16, 0x40	; 64
    23ec:	1a e0       	ldi	r17, 0x0A	; 10
    23ee:	8c 81       	ldd	r24, Y+4	; 0x04
    23f0:	9d 81       	ldd	r25, Y+5	; 0x05
    23f2:	9c 01       	movw	r18, r24
    23f4:	40 e0       	ldi	r20, 0x00	; 0
    23f6:	50 e0       	ldi	r21, 0x00	; 0
    23f8:	80 e4       	ldi	r24, 0x40	; 64
    23fa:	92 e4       	ldi	r25, 0x42	; 66
    23fc:	af e0       	ldi	r26, 0x0F	; 15
    23fe:	b0 e0       	ldi	r27, 0x00	; 0
    2400:	bc 01       	movw	r22, r24
    2402:	cd 01       	movw	r24, r26
    2404:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    2408:	da 01       	movw	r26, r20
    240a:	c9 01       	movw	r24, r18
    240c:	f8 01       	movw	r30, r16
    240e:	82 af       	sts	0x72, r24
    2410:	93 af       	sts	0x73, r25
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    2412:	80 e4       	ldi	r24, 0x40	; 64
    2414:	9a e0       	ldi	r25, 0x0A	; 10
    2416:	20 e4       	ldi	r18, 0x40	; 64
    2418:	3a e0       	ldi	r19, 0x0A	; 10
    241a:	f9 01       	movw	r30, r18
    241c:	20 81       	ld	r18, Z
    241e:	20 7f       	andi	r18, 0xF0	; 240
    2420:	21 60       	ori	r18, 0x01	; 1
    2422:	fc 01       	movw	r30, r24
    2424:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    2426:	00 00       	nop
    2428:	20 91 65 50 	lds	r18, 0x5065
    242c:	30 91 66 50 	lds	r19, 0x5066
    2430:	40 91 67 50 	lds	r20, 0x5067
    2434:	50 91 68 50 	lds	r21, 0x5068
    2438:	8e 8d       	ldd	r24, Y+30	; 0x1e
    243a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    243c:	a8 a1       	lds	r26, 0x48
    243e:	b9 a1       	lds	r27, 0x49
    2440:	28 17       	cp	r18, r24
    2442:	39 07       	cpc	r19, r25
    2444:	4a 07       	cpc	r20, r26
    2446:	5b 07       	cpc	r21, r27
    2448:	78 f3       	brcs	.-34     	; 0x2428 <CO_collectSeismic1Channel+0x1c0>

	// turn off timer and interrupts
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    244a:	80 e0       	ldi	r24, 0x00	; 0
    244c:	99 e0       	ldi	r25, 0x09	; 9
    244e:	20 e0       	ldi	r18, 0x00	; 0
    2450:	39 e0       	ldi	r19, 0x09	; 9
    2452:	f9 01       	movw	r30, r18
    2454:	20 81       	ld	r18, Z
    2456:	20 7f       	andi	r18, 0xF0	; 240
    2458:	fc 01       	movw	r30, r24
    245a:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    245c:	80 e4       	ldi	r24, 0x40	; 64
    245e:	9a e0       	ldi	r25, 0x0A	; 10
    2460:	20 e4       	ldi	r18, 0x40	; 64
    2462:	3a e0       	ldi	r19, 0x0A	; 10
    2464:	f9 01       	movw	r30, r18
    2466:	20 81       	ld	r18, Z
    2468:	20 7f       	andi	r18, 0xF0	; 240
    246a:	fc 01       	movw	r30, r24
    246c:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    246e:	80 ea       	ldi	r24, 0xA0	; 160
    2470:	90 e0       	ldi	r25, 0x00	; 0
    2472:	20 ea       	ldi	r18, 0xA0	; 160
    2474:	30 e0       	ldi	r19, 0x00	; 0
    2476:	f9 01       	movw	r30, r18
    2478:	22 81       	ldd	r18, Z+2	; 0x02
    247a:	29 7f       	andi	r18, 0xF9	; 249
    247c:	fc 01       	movw	r30, r24
    247e:	22 83       	std	Z+2, r18	; 0x02
	cli();
    2480:	f8 94       	cli

	SPICS(FALSE);
    2482:	80 e0       	ldi	r24, 0x00	; 0
    2484:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	SPIDisable();
    2488:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>
	enableADCMUX(FALSE);
    248c:	80 e0       	ldi	r24, 0x00	; 0
    248e:	0e 94 bd 08 	call	0x117a	; 0x117a <enableADCMUX>
	
}
    2492:	2d 96       	adiw	r28, 0x0d	; 13
    2494:	cd bf       	out	0x3d, r28	; 61
    2496:	de bf       	out	0x3e, r29	; 62
    2498:	df 91       	pop	r29
    249a:	cf 91       	pop	r28
    249c:	1f 91       	pop	r17
    249e:	0f 91       	pop	r16
    24a0:	ef 90       	pop	r14
    24a2:	df 90       	pop	r13
    24a4:	cf 90       	pop	r12
    24a6:	bf 90       	pop	r11
    24a8:	af 90       	pop	r10
    24aa:	9f 90       	pop	r9
    24ac:	8f 90       	pop	r8
    24ae:	08 95       	ret

000024b0 <__vector_79>:

//first averaging point
ISR(TCD0_CCA_vect) {
    24b0:	1f 92       	push	r1
    24b2:	0f 92       	push	r0
    24b4:	0f b6       	in	r0, 0x3f	; 63
    24b6:	0f 92       	push	r0
    24b8:	00 90 3b 00 	lds	r0, 0x003B
    24bc:	0f 92       	push	r0
    24be:	11 24       	eor	r1, r1
    24c0:	2f 93       	push	r18
    24c2:	3f 93       	push	r19
    24c4:	4f 93       	push	r20
    24c6:	5f 93       	push	r21
    24c8:	6f 93       	push	r22
    24ca:	7f 93       	push	r23
    24cc:	8f 93       	push	r24
    24ce:	9f 93       	push	r25
    24d0:	af 93       	push	r26
    24d2:	bf 93       	push	r27
    24d4:	ef 93       	push	r30
    24d6:	ff 93       	push	r31
    24d8:	cf 93       	push	r28
    24da:	df 93       	push	r29
    24dc:	cd b7       	in	r28, 0x3d	; 61
    24de:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    24e0:	0e 94 e7 13 	call	0x27ce	; 0x27ce <sampleCurrentChannel>
}
    24e4:	df 91       	pop	r29
    24e6:	cf 91       	pop	r28
    24e8:	ff 91       	pop	r31
    24ea:	ef 91       	pop	r30
    24ec:	bf 91       	pop	r27
    24ee:	af 91       	pop	r26
    24f0:	9f 91       	pop	r25
    24f2:	8f 91       	pop	r24
    24f4:	7f 91       	pop	r23
    24f6:	6f 91       	pop	r22
    24f8:	5f 91       	pop	r21
    24fa:	4f 91       	pop	r20
    24fc:	3f 91       	pop	r19
    24fe:	2f 91       	pop	r18
    2500:	0f 90       	pop	r0
    2502:	00 92 3b 00 	sts	0x003B, r0
    2506:	0f 90       	pop	r0
    2508:	0f be       	out	0x3f, r0	; 63
    250a:	0f 90       	pop	r0
    250c:	1f 90       	pop	r1
    250e:	18 95       	reti

00002510 <__vector_80>:
//second averaging point
ISR(TCD0_CCB_vect) {
    2510:	1f 92       	push	r1
    2512:	0f 92       	push	r0
    2514:	0f b6       	in	r0, 0x3f	; 63
    2516:	0f 92       	push	r0
    2518:	00 90 3b 00 	lds	r0, 0x003B
    251c:	0f 92       	push	r0
    251e:	11 24       	eor	r1, r1
    2520:	2f 93       	push	r18
    2522:	3f 93       	push	r19
    2524:	4f 93       	push	r20
    2526:	5f 93       	push	r21
    2528:	6f 93       	push	r22
    252a:	7f 93       	push	r23
    252c:	8f 93       	push	r24
    252e:	9f 93       	push	r25
    2530:	af 93       	push	r26
    2532:	bf 93       	push	r27
    2534:	ef 93       	push	r30
    2536:	ff 93       	push	r31
    2538:	cf 93       	push	r28
    253a:	df 93       	push	r29
    253c:	cd b7       	in	r28, 0x3d	; 61
    253e:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2540:	0e 94 e7 13 	call	0x27ce	; 0x27ce <sampleCurrentChannel>
}
    2544:	df 91       	pop	r29
    2546:	cf 91       	pop	r28
    2548:	ff 91       	pop	r31
    254a:	ef 91       	pop	r30
    254c:	bf 91       	pop	r27
    254e:	af 91       	pop	r26
    2550:	9f 91       	pop	r25
    2552:	8f 91       	pop	r24
    2554:	7f 91       	pop	r23
    2556:	6f 91       	pop	r22
    2558:	5f 91       	pop	r21
    255a:	4f 91       	pop	r20
    255c:	3f 91       	pop	r19
    255e:	2f 91       	pop	r18
    2560:	0f 90       	pop	r0
    2562:	00 92 3b 00 	sts	0x003B, r0
    2566:	0f 90       	pop	r0
    2568:	0f be       	out	0x3f, r0	; 63
    256a:	0f 90       	pop	r0
    256c:	1f 90       	pop	r1
    256e:	18 95       	reti

00002570 <__vector_81>:

//third averaging point
ISR(TCD0_CCC_vect) {
    2570:	1f 92       	push	r1
    2572:	0f 92       	push	r0
    2574:	0f b6       	in	r0, 0x3f	; 63
    2576:	0f 92       	push	r0
    2578:	00 90 3b 00 	lds	r0, 0x003B
    257c:	0f 92       	push	r0
    257e:	11 24       	eor	r1, r1
    2580:	2f 93       	push	r18
    2582:	3f 93       	push	r19
    2584:	4f 93       	push	r20
    2586:	5f 93       	push	r21
    2588:	6f 93       	push	r22
    258a:	7f 93       	push	r23
    258c:	8f 93       	push	r24
    258e:	9f 93       	push	r25
    2590:	af 93       	push	r26
    2592:	bf 93       	push	r27
    2594:	ef 93       	push	r30
    2596:	ff 93       	push	r31
    2598:	cf 93       	push	r28
    259a:	df 93       	push	r29
    259c:	cd b7       	in	r28, 0x3d	; 61
    259e:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    25a0:	0e 94 e7 13 	call	0x27ce	; 0x27ce <sampleCurrentChannel>
}
    25a4:	df 91       	pop	r29
    25a6:	cf 91       	pop	r28
    25a8:	ff 91       	pop	r31
    25aa:	ef 91       	pop	r30
    25ac:	bf 91       	pop	r27
    25ae:	af 91       	pop	r26
    25b0:	9f 91       	pop	r25
    25b2:	8f 91       	pop	r24
    25b4:	7f 91       	pop	r23
    25b6:	6f 91       	pop	r22
    25b8:	5f 91       	pop	r21
    25ba:	4f 91       	pop	r20
    25bc:	3f 91       	pop	r19
    25be:	2f 91       	pop	r18
    25c0:	0f 90       	pop	r0
    25c2:	00 92 3b 00 	sts	0x003B, r0
    25c6:	0f 90       	pop	r0
    25c8:	0f be       	out	0x3f, r0	; 63
    25ca:	0f 90       	pop	r0
    25cc:	1f 90       	pop	r1
    25ce:	18 95       	reti

000025d0 <__vector_82>:

//final averaging point
ISR(TCD0_CCD_vect) {
    25d0:	1f 92       	push	r1
    25d2:	0f 92       	push	r0
    25d4:	0f b6       	in	r0, 0x3f	; 63
    25d6:	0f 92       	push	r0
    25d8:	00 90 3b 00 	lds	r0, 0x003B
    25dc:	0f 92       	push	r0
    25de:	11 24       	eor	r1, r1
    25e0:	2f 93       	push	r18
    25e2:	3f 93       	push	r19
    25e4:	4f 93       	push	r20
    25e6:	5f 93       	push	r21
    25e8:	6f 93       	push	r22
    25ea:	7f 93       	push	r23
    25ec:	8f 93       	push	r24
    25ee:	9f 93       	push	r25
    25f0:	af 93       	push	r26
    25f2:	bf 93       	push	r27
    25f4:	ef 93       	push	r30
    25f6:	ff 93       	push	r31
    25f8:	cf 93       	push	r28
    25fa:	df 93       	push	r29
    25fc:	cd b7       	in	r28, 0x3d	; 61
    25fe:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2600:	0e 94 e7 13 	call	0x27ce	; 0x27ce <sampleCurrentChannel>
	SPICount = 0;
    2604:	10 92 bf 50 	sts	0x50BF, r1
}
    2608:	df 91       	pop	r29
    260a:	cf 91       	pop	r28
    260c:	ff 91       	pop	r31
    260e:	ef 91       	pop	r30
    2610:	bf 91       	pop	r27
    2612:	af 91       	pop	r26
    2614:	9f 91       	pop	r25
    2616:	8f 91       	pop	r24
    2618:	7f 91       	pop	r23
    261a:	6f 91       	pop	r22
    261c:	5f 91       	pop	r21
    261e:	4f 91       	pop	r20
    2620:	3f 91       	pop	r19
    2622:	2f 91       	pop	r18
    2624:	0f 90       	pop	r0
    2626:	00 92 3b 00 	sts	0x003B, r0
    262a:	0f 90       	pop	r0
    262c:	0f be       	out	0x3f, r0	; 63
    262e:	0f 90       	pop	r0
    2630:	1f 90       	pop	r1
    2632:	18 95       	reti

00002634 <__vector_77>:

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    2634:	1f 92       	push	r1
    2636:	0f 92       	push	r0
    2638:	0f b6       	in	r0, 0x3f	; 63
    263a:	0f 92       	push	r0
    263c:	00 90 3b 00 	lds	r0, 0x003B
    2640:	0f 92       	push	r0
    2642:	11 24       	eor	r1, r1
    2644:	2f 93       	push	r18
    2646:	3f 93       	push	r19
    2648:	4f 93       	push	r20
    264a:	5f 93       	push	r21
    264c:	6f 93       	push	r22
    264e:	7f 93       	push	r23
    2650:	8f 93       	push	r24
    2652:	9f 93       	push	r25
    2654:	af 93       	push	r26
    2656:	bf 93       	push	r27
    2658:	ef 93       	push	r30
    265a:	ff 93       	push	r31
    265c:	cf 93       	push	r28
    265e:	df 93       	push	r29
    2660:	cd b7       	in	r28, 0x3d	; 61
    2662:	de b7       	in	r29, 0x3e	; 62
    2664:	29 97       	sbiw	r28, 0x09	; 9
    2666:	cd bf       	out	0x3d, r28	; 61
    2668:	de bf       	out	0x3e, r29	; 62

	volatile int32_t sum = 0;
    266a:	1a 82       	std	Y+2, r1	; 0x02
    266c:	1b 82       	std	Y+3, r1	; 0x03
    266e:	1c 82       	std	Y+4, r1	; 0x04
    2670:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2672:	19 82       	std	Y+1, r1	; 0x01
    2674:	4f c0       	rjmp	.+158    	; 0x2714 <__vector_77+0xe0>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    2676:	89 81       	ldd	r24, Y+1	; 0x01
    2678:	88 2f       	mov	r24, r24
    267a:	90 e0       	ldi	r25, 0x00	; 0
    267c:	8a 5a       	subi	r24, 0xAA	; 170
    267e:	9f 4a       	sbci	r25, 0xAF	; 175
    2680:	fc 01       	movw	r30, r24
    2682:	80 81       	ld	r24, Z
    2684:	88 23       	and	r24, r24
    2686:	3c f4       	brge	.+14     	; 0x2696 <__vector_77+0x62>
    2688:	ce 01       	movw	r24, r28
    268a:	06 96       	adiw	r24, 0x06	; 6
    268c:	03 96       	adiw	r24, 0x03	; 3
    268e:	2f ef       	ldi	r18, 0xFF	; 255
    2690:	fc 01       	movw	r30, r24
    2692:	20 83       	st	Z, r18
    2694:	05 c0       	rjmp	.+10     	; 0x26a0 <__vector_77+0x6c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    2696:	ce 01       	movw	r24, r28
    2698:	06 96       	adiw	r24, 0x06	; 6
    269a:	03 96       	adiw	r24, 0x03	; 3
    269c:	fc 01       	movw	r30, r24
    269e:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    26a0:	ce 01       	movw	r24, r28
    26a2:	06 96       	adiw	r24, 0x06	; 6
    26a4:	02 96       	adiw	r24, 0x02	; 2
    26a6:	29 81       	ldd	r18, Y+1	; 0x01
    26a8:	22 2f       	mov	r18, r18
    26aa:	30 e0       	ldi	r19, 0x00	; 0
    26ac:	2a 5a       	subi	r18, 0xAA	; 170
    26ae:	3f 4a       	sbci	r19, 0xAF	; 175
    26b0:	f9 01       	movw	r30, r18
    26b2:	20 81       	ld	r18, Z
    26b4:	fc 01       	movw	r30, r24
    26b6:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    26b8:	ce 01       	movw	r24, r28
    26ba:	06 96       	adiw	r24, 0x06	; 6
    26bc:	01 96       	adiw	r24, 0x01	; 1
    26be:	29 81       	ldd	r18, Y+1	; 0x01
    26c0:	22 2f       	mov	r18, r18
    26c2:	30 e0       	ldi	r19, 0x00	; 0
    26c4:	2f 5f       	subi	r18, 0xFF	; 255
    26c6:	3f 4f       	sbci	r19, 0xFF	; 255
    26c8:	2a 5a       	subi	r18, 0xAA	; 170
    26ca:	3f 4a       	sbci	r19, 0xAF	; 175
    26cc:	f9 01       	movw	r30, r18
    26ce:	20 81       	ld	r18, Z
    26d0:	fc 01       	movw	r30, r24
    26d2:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    26d4:	ce 01       	movw	r24, r28
    26d6:	06 96       	adiw	r24, 0x06	; 6
    26d8:	29 81       	ldd	r18, Y+1	; 0x01
    26da:	22 2f       	mov	r18, r18
    26dc:	30 e0       	ldi	r19, 0x00	; 0
    26de:	2e 5f       	subi	r18, 0xFE	; 254
    26e0:	3f 4f       	sbci	r19, 0xFF	; 255
    26e2:	2a 5a       	subi	r18, 0xAA	; 170
    26e4:	3f 4a       	sbci	r19, 0xAF	; 175
    26e6:	f9 01       	movw	r30, r18
    26e8:	20 81       	ld	r18, Z
    26ea:	fc 01       	movw	r30, r24
    26ec:	20 83       	st	Z, r18
		sum += currentSample;
    26ee:	2a 81       	ldd	r18, Y+2	; 0x02
    26f0:	3b 81       	ldd	r19, Y+3	; 0x03
    26f2:	4c 81       	ldd	r20, Y+4	; 0x04
    26f4:	5d 81       	ldd	r21, Y+5	; 0x05
    26f6:	8e 81       	ldd	r24, Y+6	; 0x06
    26f8:	9f 81       	ldd	r25, Y+7	; 0x07
    26fa:	a8 85       	ldd	r26, Y+8	; 0x08
    26fc:	b9 85       	ldd	r27, Y+9	; 0x09
    26fe:	82 0f       	add	r24, r18
    2700:	93 1f       	adc	r25, r19
    2702:	a4 1f       	adc	r26, r20
    2704:	b5 1f       	adc	r27, r21
    2706:	8a 83       	std	Y+2, r24	; 0x02
    2708:	9b 83       	std	Y+3, r25	; 0x03
    270a:	ac 83       	std	Y+4, r26	; 0x04
    270c:	bd 83       	std	Y+5, r27	; 0x05
ISR(TCD0_OVF_vect) {

	volatile int32_t sum = 0;
	volatile int32_t currentSample;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    270e:	89 81       	ldd	r24, Y+1	; 0x01
    2710:	8d 5f       	subi	r24, 0xFD	; 253
    2712:	89 83       	std	Y+1, r24	; 0x01
    2714:	89 81       	ldd	r24, Y+1	; 0x01
    2716:	8c 30       	cpi	r24, 0x0C	; 12
    2718:	08 f4       	brcc	.+2      	; 0x271c <__vector_77+0xe8>
    271a:	ad cf       	rjmp	.-166    	; 0x2676 <__vector_77+0x42>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    271c:	8a 81       	ldd	r24, Y+2	; 0x02
    271e:	9b 81       	ldd	r25, Y+3	; 0x03
    2720:	ac 81       	ldd	r26, Y+4	; 0x04
    2722:	bd 81       	ldd	r27, Y+5	; 0x05
    2724:	24 e0       	ldi	r18, 0x04	; 4
    2726:	30 e0       	ldi	r19, 0x00	; 0
    2728:	40 e0       	ldi	r20, 0x00	; 0
    272a:	50 e0       	ldi	r21, 0x00	; 0
    272c:	bc 01       	movw	r22, r24
    272e:	cd 01       	movw	r24, r26
    2730:	0e 94 06 5c 	call	0xb80c	; 0xb80c <__divmodsi4>
    2734:	da 01       	movw	r26, r20
    2736:	c9 01       	movw	r24, r18
    2738:	8a 83       	std	Y+2, r24	; 0x02
    273a:	9b 83       	std	Y+3, r25	; 0x03
    273c:	ac 83       	std	Y+4, r26	; 0x04
    273e:	bd 83       	std	Y+5, r27	; 0x05
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount] = sum;
    2740:	20 91 63 50 	lds	r18, 0x5063
    2744:	30 91 64 50 	lds	r19, 0x5064
    2748:	80 91 65 50 	lds	r24, 0x5065
    274c:	90 91 66 50 	lds	r25, 0x5066
    2750:	a0 91 67 50 	lds	r26, 0x5067
    2754:	b0 91 68 50 	lds	r27, 0x5068
    2758:	88 0f       	add	r24, r24
    275a:	99 1f       	adc	r25, r25
    275c:	88 0f       	add	r24, r24
    275e:	99 1f       	adc	r25, r25
    2760:	28 0f       	add	r18, r24
    2762:	39 1f       	adc	r19, r25
    2764:	8a 81       	ldd	r24, Y+2	; 0x02
    2766:	9b 81       	ldd	r25, Y+3	; 0x03
    2768:	ac 81       	ldd	r26, Y+4	; 0x04
    276a:	bd 81       	ldd	r27, Y+5	; 0x05
    276c:	f9 01       	movw	r30, r18
    276e:	80 83       	st	Z, r24
    2770:	91 83       	std	Z+1, r25	; 0x01
    2772:	a2 83       	std	Z+2, r26	; 0x02
    2774:	b3 83       	std	Z+3, r27	; 0x03
	sampleCount++;
    2776:	80 91 65 50 	lds	r24, 0x5065
    277a:	90 91 66 50 	lds	r25, 0x5066
    277e:	a0 91 67 50 	lds	r26, 0x5067
    2782:	b0 91 68 50 	lds	r27, 0x5068
    2786:	01 96       	adiw	r24, 0x01	; 1
    2788:	a1 1d       	adc	r26, r1
    278a:	b1 1d       	adc	r27, r1
    278c:	80 93 65 50 	sts	0x5065, r24
    2790:	90 93 66 50 	sts	0x5066, r25
    2794:	a0 93 67 50 	sts	0x5067, r26
    2798:	b0 93 68 50 	sts	0x5068, r27
}
    279c:	29 96       	adiw	r28, 0x09	; 9
    279e:	cd bf       	out	0x3d, r28	; 61
    27a0:	de bf       	out	0x3e, r29	; 62
    27a2:	df 91       	pop	r29
    27a4:	cf 91       	pop	r28
    27a6:	ff 91       	pop	r31
    27a8:	ef 91       	pop	r30
    27aa:	bf 91       	pop	r27
    27ac:	af 91       	pop	r26
    27ae:	9f 91       	pop	r25
    27b0:	8f 91       	pop	r24
    27b2:	7f 91       	pop	r23
    27b4:	6f 91       	pop	r22
    27b6:	5f 91       	pop	r21
    27b8:	4f 91       	pop	r20
    27ba:	3f 91       	pop	r19
    27bc:	2f 91       	pop	r18
    27be:	0f 90       	pop	r0
    27c0:	00 92 3b 00 	sts	0x003B, r0
    27c4:	0f 90       	pop	r0
    27c6:	0f be       	out	0x3f, r0	; 63
    27c8:	0f 90       	pop	r0
    27ca:	1f 90       	pop	r1
    27cc:	18 95       	reti

000027ce <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
    27ce:	cf 93       	push	r28
    27d0:	df 93       	push	r29
    27d2:	cd b7       	in	r28, 0x3d	; 61
    27d4:	de b7       	in	r29, 0x3e	; 62
	
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    27d6:	80 ea       	ldi	r24, 0xA0	; 160
    27d8:	96 e0       	ldi	r25, 0x06	; 6
    27da:	22 e0       	ldi	r18, 0x02	; 2
    27dc:	fc 01       	movw	r30, r24
    27de:	26 83       	std	Z+6, r18	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    27e0:	80 ec       	ldi	r24, 0xC0	; 192
    27e2:	98 e0       	ldi	r25, 0x08	; 8
    27e4:	2a ea       	ldi	r18, 0xAA	; 170
    27e6:	fc 01       	movw	r30, r24
    27e8:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    27ea:	00 00       	nop
    27ec:	80 ec       	ldi	r24, 0xC0	; 192
    27ee:	98 e0       	ldi	r25, 0x08	; 8
    27f0:	fc 01       	movw	r30, r24
    27f2:	82 81       	ldd	r24, Z+2	; 0x02
    27f4:	88 23       	and	r24, r24
    27f6:	d4 f7       	brge	.-12     	; 0x27ec <sampleCurrentChannel+0x1e>
	SPIBuffer[SPICount] = SPIC.DATA;
    27f8:	80 91 bf 50 	lds	r24, 0x50BF
    27fc:	88 2f       	mov	r24, r24
    27fe:	90 e0       	ldi	r25, 0x00	; 0
    2800:	20 ec       	ldi	r18, 0xC0	; 192
    2802:	38 e0       	ldi	r19, 0x08	; 8
    2804:	f9 01       	movw	r30, r18
    2806:	23 81       	ldd	r18, Z+3	; 0x03
    2808:	8a 5a       	subi	r24, 0xAA	; 170
    280a:	9f 4a       	sbci	r25, 0xAF	; 175
    280c:	fc 01       	movw	r30, r24
    280e:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2810:	80 ec       	ldi	r24, 0xC0	; 192
    2812:	98 e0       	ldi	r25, 0x08	; 8
    2814:	2a ea       	ldi	r18, 0xAA	; 170
    2816:	fc 01       	movw	r30, r24
    2818:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    281a:	00 00       	nop
    281c:	80 ec       	ldi	r24, 0xC0	; 192
    281e:	98 e0       	ldi	r25, 0x08	; 8
    2820:	fc 01       	movw	r30, r24
    2822:	82 81       	ldd	r24, Z+2	; 0x02
    2824:	88 23       	and	r24, r24
    2826:	d4 f7       	brge	.-12     	; 0x281c <sampleCurrentChannel+0x4e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    2828:	80 91 bf 50 	lds	r24, 0x50BF
    282c:	88 2f       	mov	r24, r24
    282e:	90 e0       	ldi	r25, 0x00	; 0
    2830:	01 96       	adiw	r24, 0x01	; 1
    2832:	20 ec       	ldi	r18, 0xC0	; 192
    2834:	38 e0       	ldi	r19, 0x08	; 8
    2836:	f9 01       	movw	r30, r18
    2838:	23 81       	ldd	r18, Z+3	; 0x03
    283a:	8a 5a       	subi	r24, 0xAA	; 170
    283c:	9f 4a       	sbci	r25, 0xAF	; 175
    283e:	fc 01       	movw	r30, r24
    2840:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2842:	80 ec       	ldi	r24, 0xC0	; 192
    2844:	98 e0       	ldi	r25, 0x08	; 8
    2846:	2a ea       	ldi	r18, 0xAA	; 170
    2848:	fc 01       	movw	r30, r24
    284a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    284c:	00 00       	nop
    284e:	80 ec       	ldi	r24, 0xC0	; 192
    2850:	98 e0       	ldi	r25, 0x08	; 8
    2852:	fc 01       	movw	r30, r24
    2854:	82 81       	ldd	r24, Z+2	; 0x02
    2856:	88 23       	and	r24, r24
    2858:	d4 f7       	brge	.-12     	; 0x284e <sampleCurrentChannel+0x80>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    285a:	80 91 bf 50 	lds	r24, 0x50BF
    285e:	88 2f       	mov	r24, r24
    2860:	90 e0       	ldi	r25, 0x00	; 0
    2862:	02 96       	adiw	r24, 0x02	; 2
    2864:	20 ec       	ldi	r18, 0xC0	; 192
    2866:	38 e0       	ldi	r19, 0x08	; 8
    2868:	f9 01       	movw	r30, r18
    286a:	23 81       	ldd	r18, Z+3	; 0x03
    286c:	8a 5a       	subi	r24, 0xAA	; 170
    286e:	9f 4a       	sbci	r25, 0xAF	; 175
    2870:	fc 01       	movw	r30, r24
    2872:	20 83       	st	Z, r18
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2874:	80 ea       	ldi	r24, 0xA0	; 160
    2876:	96 e0       	ldi	r25, 0x06	; 6
    2878:	22 e0       	ldi	r18, 0x02	; 2
    287a:	fc 01       	movw	r30, r24
    287c:	25 83       	std	Z+5, r18	; 0x05
	SPICount +=3;
    287e:	80 91 bf 50 	lds	r24, 0x50BF
    2882:	8d 5f       	subi	r24, 0xFD	; 253
    2884:	80 93 bf 50 	sts	0x50BF, r24
}
    2888:	df 91       	pop	r29
    288a:	cf 91       	pop	r28
    288c:	08 95       	ret

0000288e <writeSE2FRAM>:

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    288e:	cf 93       	push	r28
    2890:	df 93       	push	r29
    2892:	cd b7       	in	r28, 0x3d	; 61
    2894:	de b7       	in	r29, 0x3e	; 62
    2896:	29 97       	sbiw	r28, 0x09	; 9
    2898:	cd bf       	out	0x3d, r28	; 61
    289a:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    289c:	1a 82       	std	Y+2, r1	; 0x02
    289e:	1b 82       	std	Y+3, r1	; 0x03
    28a0:	1c 82       	std	Y+4, r1	; 0x04
    28a2:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
    28a4:	80 91 65 50 	lds	r24, 0x5065
    28a8:	90 91 66 50 	lds	r25, 0x5066
    28ac:	a0 91 67 50 	lds	r26, 0x5067
    28b0:	b0 91 68 50 	lds	r27, 0x5068
    28b4:	01 96       	adiw	r24, 0x01	; 1
    28b6:	a1 1d       	adc	r26, r1
    28b8:	b1 1d       	adc	r27, r1
    28ba:	80 93 65 50 	sts	0x5065, r24
    28be:	90 93 66 50 	sts	0x5066, r25
    28c2:	a0 93 67 50 	sts	0x5067, r26
    28c6:	b0 93 68 50 	sts	0x5068, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    28ca:	80 ec       	ldi	r24, 0xC0	; 192
    28cc:	98 e0       	ldi	r25, 0x08	; 8
    28ce:	20 ed       	ldi	r18, 0xD0	; 208
    28d0:	fc 01       	movw	r30, r24
    28d2:	20 83       	st	Z, r18
	
	for(uint8_t i = 0; i < 12; i+=3) {
    28d4:	19 82       	std	Y+1, r1	; 0x01
    28d6:	4f c0       	rjmp	.+158    	; 0x2976 <writeSE2FRAM+0xe8>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    28d8:	89 81       	ldd	r24, Y+1	; 0x01
    28da:	88 2f       	mov	r24, r24
    28dc:	90 e0       	ldi	r25, 0x00	; 0
    28de:	8a 5a       	subi	r24, 0xAA	; 170
    28e0:	9f 4a       	sbci	r25, 0xAF	; 175
    28e2:	fc 01       	movw	r30, r24
    28e4:	80 81       	ld	r24, Z
    28e6:	88 23       	and	r24, r24
    28e8:	3c f4       	brge	.+14     	; 0x28f8 <writeSE2FRAM+0x6a>
    28ea:	ce 01       	movw	r24, r28
    28ec:	06 96       	adiw	r24, 0x06	; 6
    28ee:	03 96       	adiw	r24, 0x03	; 3
    28f0:	2f ef       	ldi	r18, 0xFF	; 255
    28f2:	fc 01       	movw	r30, r24
    28f4:	20 83       	st	Z, r18
    28f6:	05 c0       	rjmp	.+10     	; 0x2902 <writeSE2FRAM+0x74>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    28f8:	ce 01       	movw	r24, r28
    28fa:	06 96       	adiw	r24, 0x06	; 6
    28fc:	03 96       	adiw	r24, 0x03	; 3
    28fe:	fc 01       	movw	r30, r24
    2900:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2902:	ce 01       	movw	r24, r28
    2904:	06 96       	adiw	r24, 0x06	; 6
    2906:	02 96       	adiw	r24, 0x02	; 2
    2908:	29 81       	ldd	r18, Y+1	; 0x01
    290a:	22 2f       	mov	r18, r18
    290c:	30 e0       	ldi	r19, 0x00	; 0
    290e:	2a 5a       	subi	r18, 0xAA	; 170
    2910:	3f 4a       	sbci	r19, 0xAF	; 175
    2912:	f9 01       	movw	r30, r18
    2914:	20 81       	ld	r18, Z
    2916:	fc 01       	movw	r30, r24
    2918:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    291a:	ce 01       	movw	r24, r28
    291c:	06 96       	adiw	r24, 0x06	; 6
    291e:	01 96       	adiw	r24, 0x01	; 1
    2920:	29 81       	ldd	r18, Y+1	; 0x01
    2922:	22 2f       	mov	r18, r18
    2924:	30 e0       	ldi	r19, 0x00	; 0
    2926:	2f 5f       	subi	r18, 0xFF	; 255
    2928:	3f 4f       	sbci	r19, 0xFF	; 255
    292a:	2a 5a       	subi	r18, 0xAA	; 170
    292c:	3f 4a       	sbci	r19, 0xAF	; 175
    292e:	f9 01       	movw	r30, r18
    2930:	20 81       	ld	r18, Z
    2932:	fc 01       	movw	r30, r24
    2934:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2936:	ce 01       	movw	r24, r28
    2938:	06 96       	adiw	r24, 0x06	; 6
    293a:	29 81       	ldd	r18, Y+1	; 0x01
    293c:	22 2f       	mov	r18, r18
    293e:	30 e0       	ldi	r19, 0x00	; 0
    2940:	2e 5f       	subi	r18, 0xFE	; 254
    2942:	3f 4f       	sbci	r19, 0xFF	; 255
    2944:	2a 5a       	subi	r18, 0xAA	; 170
    2946:	3f 4a       	sbci	r19, 0xAF	; 175
    2948:	f9 01       	movw	r30, r18
    294a:	20 81       	ld	r18, Z
    294c:	fc 01       	movw	r30, r24
    294e:	20 83       	st	Z, r18
		sum += currentSample;
    2950:	2a 81       	ldd	r18, Y+2	; 0x02
    2952:	3b 81       	ldd	r19, Y+3	; 0x03
    2954:	4c 81       	ldd	r20, Y+4	; 0x04
    2956:	5d 81       	ldd	r21, Y+5	; 0x05
    2958:	8e 81       	ldd	r24, Y+6	; 0x06
    295a:	9f 81       	ldd	r25, Y+7	; 0x07
    295c:	a8 85       	ldd	r26, Y+8	; 0x08
    295e:	b9 85       	ldd	r27, Y+9	; 0x09
    2960:	82 0f       	add	r24, r18
    2962:	93 1f       	adc	r25, r19
    2964:	a4 1f       	adc	r26, r20
    2966:	b5 1f       	adc	r27, r21
    2968:	8a 83       	std	Y+2, r24	; 0x02
    296a:	9b 83       	std	Y+3, r25	; 0x03
    296c:	ac 83       	std	Y+4, r26	; 0x04
    296e:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2970:	89 81       	ldd	r24, Y+1	; 0x01
    2972:	8d 5f       	subi	r24, 0xFD	; 253
    2974:	89 83       	std	Y+1, r24	; 0x01
    2976:	89 81       	ldd	r24, Y+1	; 0x01
    2978:	8c 30       	cpi	r24, 0x0C	; 12
    297a:	08 f4       	brcc	.+2      	; 0x297e <writeSE2FRAM+0xf0>
    297c:	ad cf       	rjmp	.-166    	; 0x28d8 <writeSE2FRAM+0x4a>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    297e:	8a 81       	ldd	r24, Y+2	; 0x02
    2980:	9b 81       	ldd	r25, Y+3	; 0x03
    2982:	ac 81       	ldd	r26, Y+4	; 0x04
    2984:	bd 81       	ldd	r27, Y+5	; 0x05
    2986:	24 e0       	ldi	r18, 0x04	; 4
    2988:	30 e0       	ldi	r19, 0x00	; 0
    298a:	40 e0       	ldi	r20, 0x00	; 0
    298c:	50 e0       	ldi	r21, 0x00	; 0
    298e:	bc 01       	movw	r22, r24
    2990:	cd 01       	movw	r24, r26
    2992:	0e 94 06 5c 	call	0xb80c	; 0xb80c <__divmodsi4>
    2996:	da 01       	movw	r26, r20
    2998:	c9 01       	movw	r24, r18
    299a:	8a 83       	std	Y+2, r24	; 0x02
    299c:	9b 83       	std	Y+3, r25	; 0x03
    299e:	ac 83       	std	Y+4, r26	; 0x04
    29a0:	bd 83       	std	Y+5, r27	; 0x05
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    29a2:	ce 01       	movw	r24, r28
    29a4:	02 96       	adiw	r24, 0x02	; 2
    29a6:	fc 01       	movw	r30, r24
    29a8:	80 81       	ld	r24, Z
    29aa:	80 93 58 50 	sts	0x5058, r24
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    29ae:	ce 01       	movw	r24, r28
    29b0:	02 96       	adiw	r24, 0x02	; 2
    29b2:	fc 01       	movw	r30, r24
    29b4:	81 81       	ldd	r24, Z+1	; 0x01
    29b6:	80 93 57 50 	sts	0x5057, r24
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    29ba:	ce 01       	movw	r24, r28
    29bc:	02 96       	adiw	r24, 0x02	; 2
    29be:	fc 01       	movw	r30, r24
    29c0:	82 81       	ldd	r24, Z+2	; 0x02
    29c2:	80 93 56 50 	sts	0x5056, r24


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    29c6:	80 e4       	ldi	r24, 0x40	; 64
    29c8:	96 e0       	ldi	r25, 0x06	; 6
    29ca:	20 e1       	ldi	r18, 0x10	; 16
    29cc:	fc 01       	movw	r30, r24
    29ce:	26 83       	std	Z+6, r18	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    29d0:	80 e2       	ldi	r24, 0x20	; 32
    29d2:	96 e0       	ldi	r25, 0x06	; 6
    29d4:	28 e0       	ldi	r18, 0x08	; 8
    29d6:	fc 01       	movw	r30, r24
    29d8:	26 83       	std	Z+6, r18	; 0x06
	nop();
    29da:	00 00       	nop
	SPIC.DATA = FR_WREN;
    29dc:	80 ec       	ldi	r24, 0xC0	; 192
    29de:	98 e0       	ldi	r25, 0x08	; 8
    29e0:	26 e0       	ldi	r18, 0x06	; 6
    29e2:	fc 01       	movw	r30, r24
    29e4:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    29e6:	00 00       	nop
    29e8:	80 ec       	ldi	r24, 0xC0	; 192
    29ea:	98 e0       	ldi	r25, 0x08	; 8
    29ec:	fc 01       	movw	r30, r24
    29ee:	82 81       	ldd	r24, Z+2	; 0x02
    29f0:	88 23       	and	r24, r24
    29f2:	d4 f7       	brge	.-12     	; 0x29e8 <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    29f4:	80 ec       	ldi	r24, 0xC0	; 192
    29f6:	98 e0       	ldi	r25, 0x08	; 8
    29f8:	fc 01       	movw	r30, r24
    29fa:	83 81       	ldd	r24, Z+3	; 0x03
    29fc:	80 93 62 50 	sts	0x5062, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    2a00:	80 e2       	ldi	r24, 0x20	; 32
    2a02:	96 e0       	ldi	r25, 0x06	; 6
    2a04:	28 e0       	ldi	r18, 0x08	; 8
    2a06:	fc 01       	movw	r30, r24
    2a08:	25 83       	std	Z+5, r18	; 0x05
	nop(); // time for CS_FRAM to accept high signal
    2a0a:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2a0c:	80 e2       	ldi	r24, 0x20	; 32
    2a0e:	96 e0       	ldi	r25, 0x06	; 6
    2a10:	28 e0       	ldi	r18, 0x08	; 8
    2a12:	fc 01       	movw	r30, r24
    2a14:	26 83       	std	Z+6, r18	; 0x06
	nop();
    2a16:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    2a18:	80 ec       	ldi	r24, 0xC0	; 192
    2a1a:	98 e0       	ldi	r25, 0x08	; 8
    2a1c:	22 e0       	ldi	r18, 0x02	; 2
    2a1e:	fc 01       	movw	r30, r24
    2a20:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a22:	00 00       	nop
    2a24:	80 ec       	ldi	r24, 0xC0	; 192
    2a26:	98 e0       	ldi	r25, 0x08	; 8
    2a28:	fc 01       	movw	r30, r24
    2a2a:	82 81       	ldd	r24, Z+2	; 0x02
    2a2c:	88 23       	and	r24, r24
    2a2e:	d4 f7       	brge	.-12     	; 0x2a24 <writeSE2FRAM+0x196>
	SPIBuffer[12] = SPIC.DATA;
    2a30:	80 ec       	ldi	r24, 0xC0	; 192
    2a32:	98 e0       	ldi	r25, 0x08	; 8
    2a34:	fc 01       	movw	r30, r24
    2a36:	83 81       	ldd	r24, Z+3	; 0x03
    2a38:	80 93 62 50 	sts	0x5062, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    2a3c:	80 ec       	ldi	r24, 0xC0	; 192
    2a3e:	98 e0       	ldi	r25, 0x08	; 8
    2a40:	20 91 49 40 	lds	r18, 0x4049
    2a44:	fc 01       	movw	r30, r24
    2a46:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a48:	00 00       	nop
    2a4a:	80 ec       	ldi	r24, 0xC0	; 192
    2a4c:	98 e0       	ldi	r25, 0x08	; 8
    2a4e:	fc 01       	movw	r30, r24
    2a50:	82 81       	ldd	r24, Z+2	; 0x02
    2a52:	88 23       	and	r24, r24
    2a54:	d4 f7       	brge	.-12     	; 0x2a4a <writeSE2FRAM+0x1bc>
	SPIBuffer[12] = SPIC.DATA;
    2a56:	80 ec       	ldi	r24, 0xC0	; 192
    2a58:	98 e0       	ldi	r25, 0x08	; 8
    2a5a:	fc 01       	movw	r30, r24
    2a5c:	83 81       	ldd	r24, Z+3	; 0x03
    2a5e:	80 93 62 50 	sts	0x5062, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2a62:	80 ec       	ldi	r24, 0xC0	; 192
    2a64:	98 e0       	ldi	r25, 0x08	; 8
    2a66:	28 e4       	ldi	r18, 0x48	; 72
    2a68:	30 e4       	ldi	r19, 0x40	; 64
    2a6a:	f9 01       	movw	r30, r18
    2a6c:	20 81       	ld	r18, Z
    2a6e:	fc 01       	movw	r30, r24
    2a70:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a72:	00 00       	nop
    2a74:	80 ec       	ldi	r24, 0xC0	; 192
    2a76:	98 e0       	ldi	r25, 0x08	; 8
    2a78:	fc 01       	movw	r30, r24
    2a7a:	82 81       	ldd	r24, Z+2	; 0x02
    2a7c:	88 23       	and	r24, r24
    2a7e:	d4 f7       	brge	.-12     	; 0x2a74 <writeSE2FRAM+0x1e6>
	SPIBuffer[12] = SPIC.DATA;
    2a80:	80 ec       	ldi	r24, 0xC0	; 192
    2a82:	98 e0       	ldi	r25, 0x08	; 8
    2a84:	fc 01       	movw	r30, r24
    2a86:	83 81       	ldd	r24, Z+3	; 0x03
    2a88:	80 93 62 50 	sts	0x5062, r24
	SPIC.DATA = SPIBuffer[0];
    2a8c:	80 ec       	ldi	r24, 0xC0	; 192
    2a8e:	98 e0       	ldi	r25, 0x08	; 8
    2a90:	20 91 56 50 	lds	r18, 0x5056
    2a94:	fc 01       	movw	r30, r24
    2a96:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a98:	00 00       	nop
    2a9a:	80 ec       	ldi	r24, 0xC0	; 192
    2a9c:	98 e0       	ldi	r25, 0x08	; 8
    2a9e:	fc 01       	movw	r30, r24
    2aa0:	82 81       	ldd	r24, Z+2	; 0x02
    2aa2:	88 23       	and	r24, r24
    2aa4:	d4 f7       	brge	.-12     	; 0x2a9a <writeSE2FRAM+0x20c>
	SPIBuffer[12] = SPIC.DATA;
    2aa6:	80 ec       	ldi	r24, 0xC0	; 192
    2aa8:	98 e0       	ldi	r25, 0x08	; 8
    2aaa:	fc 01       	movw	r30, r24
    2aac:	83 81       	ldd	r24, Z+3	; 0x03
    2aae:	80 93 62 50 	sts	0x5062, r24
	SPIC.DATA = SPIBuffer[1];
    2ab2:	80 ec       	ldi	r24, 0xC0	; 192
    2ab4:	98 e0       	ldi	r25, 0x08	; 8
    2ab6:	20 91 57 50 	lds	r18, 0x5057
    2aba:	fc 01       	movw	r30, r24
    2abc:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2abe:	00 00       	nop
    2ac0:	80 ec       	ldi	r24, 0xC0	; 192
    2ac2:	98 e0       	ldi	r25, 0x08	; 8
    2ac4:	fc 01       	movw	r30, r24
    2ac6:	82 81       	ldd	r24, Z+2	; 0x02
    2ac8:	88 23       	and	r24, r24
    2aca:	d4 f7       	brge	.-12     	; 0x2ac0 <writeSE2FRAM+0x232>
	SPIBuffer[12] = SPIC.DATA;
    2acc:	80 ec       	ldi	r24, 0xC0	; 192
    2ace:	98 e0       	ldi	r25, 0x08	; 8
    2ad0:	fc 01       	movw	r30, r24
    2ad2:	83 81       	ldd	r24, Z+3	; 0x03
    2ad4:	80 93 62 50 	sts	0x5062, r24
	SPIC.DATA = SPIBuffer[2];
    2ad8:	80 ec       	ldi	r24, 0xC0	; 192
    2ada:	98 e0       	ldi	r25, 0x08	; 8
    2adc:	20 91 58 50 	lds	r18, 0x5058
    2ae0:	fc 01       	movw	r30, r24
    2ae2:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2ae4:	00 00       	nop
    2ae6:	80 ec       	ldi	r24, 0xC0	; 192
    2ae8:	98 e0       	ldi	r25, 0x08	; 8
    2aea:	fc 01       	movw	r30, r24
    2aec:	82 81       	ldd	r24, Z+2	; 0x02
    2aee:	88 23       	and	r24, r24
    2af0:	d4 f7       	brge	.-12     	; 0x2ae6 <writeSE2FRAM+0x258>
	SPIBuffer[12] = SPIC.DATA;
    2af2:	80 ec       	ldi	r24, 0xC0	; 192
    2af4:	98 e0       	ldi	r25, 0x08	; 8
    2af6:	fc 01       	movw	r30, r24
    2af8:	83 81       	ldd	r24, Z+3	; 0x03
    2afa:	80 93 62 50 	sts	0x5062, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2afe:	80 e2       	ldi	r24, 0x20	; 32
    2b00:	96 e0       	ldi	r25, 0x06	; 6
    2b02:	28 e0       	ldi	r18, 0x08	; 8
    2b04:	fc 01       	movw	r30, r24
    2b06:	25 83       	std	Z+5, r18	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2b08:	80 e4       	ldi	r24, 0x40	; 64
    2b0a:	96 e0       	ldi	r25, 0x06	; 6
    2b0c:	20 e1       	ldi	r18, 0x10	; 16
    2b0e:	fc 01       	movw	r30, r24
    2b10:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2b12:	80 ec       	ldi	r24, 0xC0	; 192
    2b14:	98 e0       	ldi	r25, 0x08	; 8
    2b16:	24 e5       	ldi	r18, 0x54	; 84
    2b18:	fc 01       	movw	r30, r24
    2b1a:	20 83       	st	Z, r18
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2b1c:	80 e4       	ldi	r24, 0x40	; 64
    2b1e:	96 e0       	ldi	r25, 0x06	; 6
    2b20:	20 e1       	ldi	r18, 0x10	; 16
    2b22:	fc 01       	movw	r30, r24
    2b24:	26 83       	std	Z+6, r18	; 0x06
	
	FRAMAddress +=3;
    2b26:	80 91 48 40 	lds	r24, 0x4048
    2b2a:	90 91 49 40 	lds	r25, 0x4049
    2b2e:	03 96       	adiw	r24, 0x03	; 3
    2b30:	80 93 48 40 	sts	0x4048, r24
    2b34:	90 93 49 40 	sts	0x4049, r25
	checksumADC[0] += SPIBuffer[0];
    2b38:	90 91 2a 21 	lds	r25, 0x212A
    2b3c:	80 91 56 50 	lds	r24, 0x5056
    2b40:	89 0f       	add	r24, r25
    2b42:	80 93 2a 21 	sts	0x212A, r24
	checksumADC[1] += SPIBuffer[1];
    2b46:	90 91 2b 21 	lds	r25, 0x212B
    2b4a:	80 91 57 50 	lds	r24, 0x5057
    2b4e:	89 0f       	add	r24, r25
    2b50:	80 93 2b 21 	sts	0x212B, r24
	checksumADC[2] += SPIBuffer[2];
    2b54:	90 91 2c 21 	lds	r25, 0x212C
    2b58:	80 91 58 50 	lds	r24, 0x5058
    2b5c:	89 0f       	add	r24, r25
    2b5e:	80 93 2c 21 	sts	0x212C, r24
}
    2b62:	29 96       	adiw	r28, 0x09	; 9
    2b64:	cd bf       	out	0x3d, r28	; 61
    2b66:	de bf       	out	0x3e, r29	; 62
    2b68:	df 91       	pop	r29
    2b6a:	cf 91       	pop	r28
    2b6c:	08 95       	ret

00002b6e <calcChecksumFRAM>:

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    2b6e:	2f 92       	push	r2
    2b70:	3f 92       	push	r3
    2b72:	4f 92       	push	r4
    2b74:	5f 92       	push	r5
    2b76:	6f 92       	push	r6
    2b78:	7f 92       	push	r7
    2b7a:	8f 92       	push	r8
    2b7c:	9f 92       	push	r9
    2b7e:	af 92       	push	r10
    2b80:	bf 92       	push	r11
    2b82:	cf 92       	push	r12
    2b84:	df 92       	push	r13
    2b86:	ef 92       	push	r14
    2b88:	ff 92       	push	r15
    2b8a:	0f 93       	push	r16
    2b8c:	1f 93       	push	r17
    2b8e:	cf 93       	push	r28
    2b90:	df 93       	push	r29
    2b92:	00 d0       	rcall	.+0      	; 0x2b94 <calcChecksumFRAM+0x26>
    2b94:	0f 92       	push	r0
    2b96:	cd b7       	in	r28, 0x3d	; 61
    2b98:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    2b9a:	aa 24       	eor	r10, r10
    2b9c:	bb 24       	eor	r11, r11
    2b9e:	cc 24       	eor	r12, r12
    2ba0:	dd 24       	eor	r13, r13
    2ba2:	ee 24       	eor	r14, r14
    2ba4:	ff 24       	eor	r15, r15
    2ba6:	00 e0       	ldi	r16, 0x00	; 0
    2ba8:	10 e0       	ldi	r17, 0x00	; 0
    2baa:	a0 92 8c 50 	sts	0x508C, r10
    2bae:	b0 92 8d 50 	sts	0x508D, r11
    2bb2:	c0 92 8e 50 	sts	0x508E, r12
    2bb6:	d0 92 8f 50 	sts	0x508F, r13
    2bba:	e0 92 90 50 	sts	0x5090, r14
    2bbe:	f0 92 91 50 	sts	0x5091, r15
    2bc2:	00 93 92 50 	sts	0x5092, r16
    2bc6:	10 93 93 50 	sts	0x5093, r17
    2bca:	2a 2d       	mov	r18, r10
    2bcc:	3b 2d       	mov	r19, r11
    2bce:	4c 2d       	mov	r20, r12
    2bd0:	5d 2d       	mov	r21, r13
    2bd2:	6e 2d       	mov	r22, r14
    2bd4:	7f 2d       	mov	r23, r15
    2bd6:	80 2f       	mov	r24, r16
    2bd8:	91 2f       	mov	r25, r17
    2bda:	20 93 84 50 	sts	0x5084, r18
    2bde:	30 93 85 50 	sts	0x5085, r19
    2be2:	40 93 86 50 	sts	0x5086, r20
    2be6:	50 93 87 50 	sts	0x5087, r21
    2bea:	60 93 88 50 	sts	0x5088, r22
    2bee:	70 93 89 50 	sts	0x5089, r23
    2bf2:	80 93 8a 50 	sts	0x508A, r24
    2bf6:	90 93 8b 50 	sts	0x508B, r25
    2bfa:	20 93 7c 50 	sts	0x507C, r18
    2bfe:	30 93 7d 50 	sts	0x507D, r19
    2c02:	40 93 7e 50 	sts	0x507E, r20
    2c06:	50 93 7f 50 	sts	0x507F, r21
    2c0a:	60 93 80 50 	sts	0x5080, r22
    2c0e:	70 93 81 50 	sts	0x5081, r23
    2c12:	80 93 82 50 	sts	0x5082, r24
    2c16:	90 93 83 50 	sts	0x5083, r25
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    2c1a:	80 e0       	ldi	r24, 0x00	; 0
    2c1c:	80 93 2f 21 	sts	0x212F, r24
    2c20:	80 93 2e 21 	sts	0x212E, r24
    2c24:	80 93 2d 21 	sts	0x212D, r24
	FRAMAddress = FR_BASEADD;
    2c28:	10 92 48 40 	sts	0x4048, r1
    2c2c:	10 92 49 40 	sts	0x4049, r1
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    2c30:	19 82       	std	Y+1, r1	; 0x01
    2c32:	1a 82       	std	Y+2, r1	; 0x02
    2c34:	88 c2       	rjmp	.+1296   	; 0x3146 <calcChecksumFRAM+0x5d8>
		readFRAM(FR_READ_BUFFER_SIZE);
    2c36:	81 e7       	ldi	r24, 0x71	; 113
    2c38:	9c e1       	ldi	r25, 0x1C	; 28
    2c3a:	0e 94 c0 37 	call	0x6f80	; 0x6f80 <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    2c3e:	80 91 48 40 	lds	r24, 0x4048
    2c42:	90 91 49 40 	lds	r25, 0x4049
    2c46:	8f 58       	subi	r24, 0x8F	; 143
    2c48:	93 4e       	sbci	r25, 0xE3	; 227
    2c4a:	80 93 48 40 	sts	0x4048, r24
    2c4e:	90 93 49 40 	sts	0x4049, r25
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    2c52:	1b 82       	std	Y+3, r1	; 0x03
    2c54:	1c 82       	std	Y+4, r1	; 0x04
    2c56:	6b c2       	rjmp	.+1238   	; 0x312e <calcChecksumFRAM+0x5c0>
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    2c58:	8b 81       	ldd	r24, Y+3	; 0x03
    2c5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c5c:	23 e0       	ldi	r18, 0x03	; 3
    2c5e:	30 e0       	ldi	r19, 0x00	; 0
    2c60:	b9 01       	movw	r22, r18
    2c62:	0e 94 bd 5b 	call	0xb77a	; 0xb77a <__udivmodhi4>
    2c66:	9c 01       	movw	r18, r24
    2c68:	23 5d       	subi	r18, 0xD3	; 211
    2c6a:	3e 4d       	sbci	r19, 0xDE	; 222
    2c6c:	f9 01       	movw	r30, r18
    2c6e:	40 81       	ld	r20, Z
    2c70:	2b 81       	ldd	r18, Y+3	; 0x03
    2c72:	3c 81       	ldd	r19, Y+4	; 0x04
    2c74:	20 53       	subi	r18, 0x30	; 48
    2c76:	3c 4d       	sbci	r19, 0xDC	; 220
    2c78:	f9 01       	movw	r30, r18
    2c7a:	20 81       	ld	r18, Z
    2c7c:	24 0f       	add	r18, r20
    2c7e:	83 5d       	subi	r24, 0xD3	; 211
    2c80:	9e 4d       	sbci	r25, 0xDE	; 222
    2c82:	fc 01       	movw	r30, r24
    2c84:	20 83       	st	Z, r18
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    2c86:	8b 81       	ldd	r24, Y+3	; 0x03
    2c88:	9c 81       	ldd	r25, Y+4	; 0x04
    2c8a:	23 e0       	ldi	r18, 0x03	; 3
    2c8c:	30 e0       	ldi	r19, 0x00	; 0
    2c8e:	b9 01       	movw	r22, r18
    2c90:	0e 94 bd 5b 	call	0xb77a	; 0xb77a <__udivmodhi4>
    2c94:	00 97       	sbiw	r24, 0x00	; 0
    2c96:	09 f0       	breq	.+2      	; 0x2c9a <calcChecksumFRAM+0x12c>
    2c98:	44 c0       	rjmp	.+136    	; 0x2d22 <calcChecksumFRAM+0x1b4>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    2c9a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c9c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c9e:	80 53       	subi	r24, 0x30	; 48
    2ca0:	9c 4d       	sbci	r25, 0xDC	; 220
    2ca2:	fc 01       	movw	r30, r24
    2ca4:	80 81       	ld	r24, Z
    2ca6:	88 23       	and	r24, r24
    2ca8:	d4 f4       	brge	.+52     	; 0x2cde <calcChecksumFRAM+0x170>
    2caa:	80 91 54 50 	lds	r24, 0x5054
    2cae:	90 91 55 50 	lds	r25, 0x5055
    2cb2:	fc 01       	movw	r30, r24
    2cb4:	10 82       	st	Z, r1
    2cb6:	fc 01       	movw	r30, r24
    2cb8:	11 82       	std	Z+1, r1	; 0x01
    2cba:	fc 01       	movw	r30, r24
    2cbc:	12 82       	std	Z+2, r1	; 0x02
    2cbe:	2f ef       	ldi	r18, 0xFF	; 255
    2cc0:	fc 01       	movw	r30, r24
    2cc2:	23 83       	std	Z+3, r18	; 0x03
    2cc4:	2f ef       	ldi	r18, 0xFF	; 255
    2cc6:	fc 01       	movw	r30, r24
    2cc8:	24 83       	std	Z+4, r18	; 0x04
    2cca:	2f ef       	ldi	r18, 0xFF	; 255
    2ccc:	fc 01       	movw	r30, r24
    2cce:	25 83       	std	Z+5, r18	; 0x05
    2cd0:	2f ef       	ldi	r18, 0xFF	; 255
    2cd2:	fc 01       	movw	r30, r24
    2cd4:	26 83       	std	Z+6, r18	; 0x06
    2cd6:	2f ef       	ldi	r18, 0xFF	; 255
    2cd8:	fc 01       	movw	r30, r24
    2cda:	27 83       	std	Z+7, r18	; 0x07
    2cdc:	14 c0       	rjmp	.+40     	; 0x2d06 <calcChecksumFRAM+0x198>
				else *temp64 = 0x0000000000000000;
    2cde:	80 91 54 50 	lds	r24, 0x5054
    2ce2:	90 91 55 50 	lds	r25, 0x5055
    2ce6:	fc 01       	movw	r30, r24
    2ce8:	10 82       	st	Z, r1
    2cea:	fc 01       	movw	r30, r24
    2cec:	11 82       	std	Z+1, r1	; 0x01
    2cee:	fc 01       	movw	r30, r24
    2cf0:	12 82       	std	Z+2, r1	; 0x02
    2cf2:	fc 01       	movw	r30, r24
    2cf4:	13 82       	std	Z+3, r1	; 0x03
    2cf6:	fc 01       	movw	r30, r24
    2cf8:	14 82       	std	Z+4, r1	; 0x04
    2cfa:	fc 01       	movw	r30, r24
    2cfc:	15 82       	std	Z+5, r1	; 0x05
    2cfe:	fc 01       	movw	r30, r24
    2d00:	16 82       	std	Z+6, r1	; 0x06
    2d02:	fc 01       	movw	r30, r24
    2d04:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    2d06:	80 91 54 50 	lds	r24, 0x5054
    2d0a:	90 91 55 50 	lds	r25, 0x5055
    2d0e:	02 96       	adiw	r24, 0x02	; 2
    2d10:	2b 81       	ldd	r18, Y+3	; 0x03
    2d12:	3c 81       	ldd	r19, Y+4	; 0x04
    2d14:	20 53       	subi	r18, 0x30	; 48
    2d16:	3c 4d       	sbci	r19, 0xDC	; 220
    2d18:	f9 01       	movw	r30, r18
    2d1a:	20 81       	ld	r18, Z
    2d1c:	fc 01       	movw	r30, r24
    2d1e:	20 83       	st	Z, r18
    2d20:	24 c0       	rjmp	.+72     	; 0x2d6a <calcChecksumFRAM+0x1fc>
			} else if(k%3 == 1) {
    2d22:	8b 81       	ldd	r24, Y+3	; 0x03
    2d24:	9c 81       	ldd	r25, Y+4	; 0x04
    2d26:	23 e0       	ldi	r18, 0x03	; 3
    2d28:	30 e0       	ldi	r19, 0x00	; 0
    2d2a:	b9 01       	movw	r22, r18
    2d2c:	0e 94 bd 5b 	call	0xb77a	; 0xb77a <__udivmodhi4>
    2d30:	81 30       	cpi	r24, 0x01	; 1
    2d32:	91 05       	cpc	r25, r1
    2d34:	71 f4       	brne	.+28     	; 0x2d52 <calcChecksumFRAM+0x1e4>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    2d36:	80 91 54 50 	lds	r24, 0x5054
    2d3a:	90 91 55 50 	lds	r25, 0x5055
    2d3e:	01 96       	adiw	r24, 0x01	; 1
    2d40:	2b 81       	ldd	r18, Y+3	; 0x03
    2d42:	3c 81       	ldd	r19, Y+4	; 0x04
    2d44:	20 53       	subi	r18, 0x30	; 48
    2d46:	3c 4d       	sbci	r19, 0xDC	; 220
    2d48:	f9 01       	movw	r30, r18
    2d4a:	20 81       	ld	r18, Z
    2d4c:	fc 01       	movw	r30, r24
    2d4e:	20 83       	st	Z, r18
    2d50:	0c c0       	rjmp	.+24     	; 0x2d6a <calcChecksumFRAM+0x1fc>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    2d52:	80 91 54 50 	lds	r24, 0x5054
    2d56:	90 91 55 50 	lds	r25, 0x5055
    2d5a:	2b 81       	ldd	r18, Y+3	; 0x03
    2d5c:	3c 81       	ldd	r19, Y+4	; 0x04
    2d5e:	20 53       	subi	r18, 0x30	; 48
    2d60:	3c 4d       	sbci	r19, 0xDC	; 220
    2d62:	f9 01       	movw	r30, r18
    2d64:	20 81       	ld	r18, Z
    2d66:	fc 01       	movw	r30, r24
    2d68:	20 83       	st	Z, r18
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    2d6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d6e:	29 e0       	ldi	r18, 0x09	; 9
    2d70:	30 e0       	ldi	r19, 0x00	; 0
    2d72:	b9 01       	movw	r22, r18
    2d74:	0e 94 bd 5b 	call	0xb77a	; 0xb77a <__udivmodhi4>
    2d78:	82 30       	cpi	r24, 0x02	; 2
    2d7a:	91 05       	cpc	r25, r1
    2d7c:	09 f0       	breq	.+2      	; 0x2d80 <calcChecksumFRAM+0x212>
    2d7e:	94 c0       	rjmp	.+296    	; 0x2ea8 <calcChecksumFRAM+0x33a>
    2d80:	a0 90 7c 50 	lds	r10, 0x507C
    2d84:	b0 90 7d 50 	lds	r11, 0x507D
    2d88:	c0 90 7e 50 	lds	r12, 0x507E
    2d8c:	d0 90 7f 50 	lds	r13, 0x507F
    2d90:	e0 90 80 50 	lds	r14, 0x5080
    2d94:	f0 90 81 50 	lds	r15, 0x5081
    2d98:	00 91 82 50 	lds	r16, 0x5082
    2d9c:	10 91 83 50 	lds	r17, 0x5083
    2da0:	80 91 54 50 	lds	r24, 0x5054
    2da4:	90 91 55 50 	lds	r25, 0x5055
    2da8:	fc 01       	movw	r30, r24
    2daa:	20 80       	ld	r2, Z
    2dac:	fc 01       	movw	r30, r24
    2dae:	31 80       	ldd	r3, Z+1	; 0x01
    2db0:	fc 01       	movw	r30, r24
    2db2:	42 80       	ldd	r4, Z+2	; 0x02
    2db4:	fc 01       	movw	r30, r24
    2db6:	53 80       	ldd	r5, Z+3	; 0x03
    2db8:	fc 01       	movw	r30, r24
    2dba:	64 80       	ldd	r6, Z+4	; 0x04
    2dbc:	fc 01       	movw	r30, r24
    2dbe:	75 80       	ldd	r7, Z+5	; 0x05
    2dc0:	fc 01       	movw	r30, r24
    2dc2:	86 80       	ldd	r8, Z+6	; 0x06
    2dc4:	fc 01       	movw	r30, r24
    2dc6:	97 80       	ldd	r9, Z+7	; 0x07
    2dc8:	2a 2d       	mov	r18, r10
    2dca:	22 0d       	add	r18, r2
    2dcc:	e1 e0       	ldi	r30, 0x01	; 1
    2dce:	2a 15       	cp	r18, r10
    2dd0:	08 f0       	brcs	.+2      	; 0x2dd4 <calcChecksumFRAM+0x266>
    2dd2:	e0 e0       	ldi	r30, 0x00	; 0
    2dd4:	3b 2d       	mov	r19, r11
    2dd6:	33 0d       	add	r19, r3
    2dd8:	f1 e0       	ldi	r31, 0x01	; 1
    2dda:	3b 15       	cp	r19, r11
    2ddc:	08 f0       	brcs	.+2      	; 0x2de0 <calcChecksumFRAM+0x272>
    2dde:	f0 e0       	ldi	r31, 0x00	; 0
    2de0:	e3 0f       	add	r30, r19
    2de2:	a1 e0       	ldi	r26, 0x01	; 1
    2de4:	e3 17       	cp	r30, r19
    2de6:	08 f0       	brcs	.+2      	; 0x2dea <calcChecksumFRAM+0x27c>
    2de8:	a0 e0       	ldi	r26, 0x00	; 0
    2dea:	fa 2b       	or	r31, r26
    2dec:	3e 2f       	mov	r19, r30
    2dee:	4c 2d       	mov	r20, r12
    2df0:	44 0d       	add	r20, r4
    2df2:	e1 e0       	ldi	r30, 0x01	; 1
    2df4:	4c 15       	cp	r20, r12
    2df6:	08 f0       	brcs	.+2      	; 0x2dfa <calcChecksumFRAM+0x28c>
    2df8:	e0 e0       	ldi	r30, 0x00	; 0
    2dfa:	f4 0f       	add	r31, r20
    2dfc:	a1 e0       	ldi	r26, 0x01	; 1
    2dfe:	f4 17       	cp	r31, r20
    2e00:	08 f0       	brcs	.+2      	; 0x2e04 <calcChecksumFRAM+0x296>
    2e02:	a0 e0       	ldi	r26, 0x00	; 0
    2e04:	ea 2b       	or	r30, r26
    2e06:	4f 2f       	mov	r20, r31
    2e08:	5d 2d       	mov	r21, r13
    2e0a:	55 0d       	add	r21, r5
    2e0c:	f1 e0       	ldi	r31, 0x01	; 1
    2e0e:	5d 15       	cp	r21, r13
    2e10:	08 f0       	brcs	.+2      	; 0x2e14 <calcChecksumFRAM+0x2a6>
    2e12:	f0 e0       	ldi	r31, 0x00	; 0
    2e14:	e5 0f       	add	r30, r21
    2e16:	a1 e0       	ldi	r26, 0x01	; 1
    2e18:	e5 17       	cp	r30, r21
    2e1a:	08 f0       	brcs	.+2      	; 0x2e1e <calcChecksumFRAM+0x2b0>
    2e1c:	a0 e0       	ldi	r26, 0x00	; 0
    2e1e:	fa 2b       	or	r31, r26
    2e20:	5e 2f       	mov	r21, r30
    2e22:	6e 2d       	mov	r22, r14
    2e24:	66 0d       	add	r22, r6
    2e26:	e1 e0       	ldi	r30, 0x01	; 1
    2e28:	6e 15       	cp	r22, r14
    2e2a:	08 f0       	brcs	.+2      	; 0x2e2e <calcChecksumFRAM+0x2c0>
    2e2c:	e0 e0       	ldi	r30, 0x00	; 0
    2e2e:	f6 0f       	add	r31, r22
    2e30:	a1 e0       	ldi	r26, 0x01	; 1
    2e32:	f6 17       	cp	r31, r22
    2e34:	08 f0       	brcs	.+2      	; 0x2e38 <calcChecksumFRAM+0x2ca>
    2e36:	a0 e0       	ldi	r26, 0x00	; 0
    2e38:	ea 2b       	or	r30, r26
    2e3a:	6f 2f       	mov	r22, r31
    2e3c:	7f 2d       	mov	r23, r15
    2e3e:	77 0d       	add	r23, r7
    2e40:	f1 e0       	ldi	r31, 0x01	; 1
    2e42:	7f 15       	cp	r23, r15
    2e44:	08 f0       	brcs	.+2      	; 0x2e48 <calcChecksumFRAM+0x2da>
    2e46:	f0 e0       	ldi	r31, 0x00	; 0
    2e48:	e7 0f       	add	r30, r23
    2e4a:	a1 e0       	ldi	r26, 0x01	; 1
    2e4c:	e7 17       	cp	r30, r23
    2e4e:	08 f0       	brcs	.+2      	; 0x2e52 <calcChecksumFRAM+0x2e4>
    2e50:	a0 e0       	ldi	r26, 0x00	; 0
    2e52:	fa 2b       	or	r31, r26
    2e54:	7e 2f       	mov	r23, r30
    2e56:	80 2f       	mov	r24, r16
    2e58:	88 0d       	add	r24, r8
    2e5a:	e1 e0       	ldi	r30, 0x01	; 1
    2e5c:	80 17       	cp	r24, r16
    2e5e:	08 f0       	brcs	.+2      	; 0x2e62 <calcChecksumFRAM+0x2f4>
    2e60:	e0 e0       	ldi	r30, 0x00	; 0
    2e62:	f8 0f       	add	r31, r24
    2e64:	a1 e0       	ldi	r26, 0x01	; 1
    2e66:	f8 17       	cp	r31, r24
    2e68:	08 f0       	brcs	.+2      	; 0x2e6c <calcChecksumFRAM+0x2fe>
    2e6a:	a0 e0       	ldi	r26, 0x00	; 0
    2e6c:	ea 2b       	or	r30, r26
    2e6e:	8f 2f       	mov	r24, r31
    2e70:	91 2f       	mov	r25, r17
    2e72:	99 0d       	add	r25, r9
    2e74:	e9 0f       	add	r30, r25
    2e76:	9e 2f       	mov	r25, r30
    2e78:	a2 2e       	mov	r10, r18
    2e7a:	b3 2e       	mov	r11, r19
    2e7c:	c4 2e       	mov	r12, r20
    2e7e:	d5 2e       	mov	r13, r21
    2e80:	e6 2e       	mov	r14, r22
    2e82:	f7 2e       	mov	r15, r23
    2e84:	08 2f       	mov	r16, r24
    2e86:	19 2f       	mov	r17, r25
    2e88:	a0 92 7c 50 	sts	0x507C, r10
    2e8c:	b0 92 7d 50 	sts	0x507D, r11
    2e90:	c0 92 7e 50 	sts	0x507E, r12
    2e94:	d0 92 7f 50 	sts	0x507F, r13
    2e98:	e0 92 80 50 	sts	0x5080, r14
    2e9c:	f0 92 81 50 	sts	0x5081, r15
    2ea0:	00 93 82 50 	sts	0x5082, r16
    2ea4:	10 93 83 50 	sts	0x5083, r17
			if(k%9 == 5) sumFRAM[1] += *temp64;
    2ea8:	8b 81       	ldd	r24, Y+3	; 0x03
    2eaa:	9c 81       	ldd	r25, Y+4	; 0x04
    2eac:	29 e0       	ldi	r18, 0x09	; 9
    2eae:	30 e0       	ldi	r19, 0x00	; 0
    2eb0:	b9 01       	movw	r22, r18
    2eb2:	0e 94 bd 5b 	call	0xb77a	; 0xb77a <__udivmodhi4>
    2eb6:	85 30       	cpi	r24, 0x05	; 5
    2eb8:	91 05       	cpc	r25, r1
    2eba:	09 f0       	breq	.+2      	; 0x2ebe <calcChecksumFRAM+0x350>
    2ebc:	94 c0       	rjmp	.+296    	; 0x2fe6 <calcChecksumFRAM+0x478>
    2ebe:	a0 90 84 50 	lds	r10, 0x5084
    2ec2:	b0 90 85 50 	lds	r11, 0x5085
    2ec6:	c0 90 86 50 	lds	r12, 0x5086
    2eca:	d0 90 87 50 	lds	r13, 0x5087
    2ece:	e0 90 88 50 	lds	r14, 0x5088
    2ed2:	f0 90 89 50 	lds	r15, 0x5089
    2ed6:	00 91 8a 50 	lds	r16, 0x508A
    2eda:	10 91 8b 50 	lds	r17, 0x508B
    2ede:	80 91 54 50 	lds	r24, 0x5054
    2ee2:	90 91 55 50 	lds	r25, 0x5055
    2ee6:	fc 01       	movw	r30, r24
    2ee8:	20 80       	ld	r2, Z
    2eea:	fc 01       	movw	r30, r24
    2eec:	31 80       	ldd	r3, Z+1	; 0x01
    2eee:	fc 01       	movw	r30, r24
    2ef0:	42 80       	ldd	r4, Z+2	; 0x02
    2ef2:	fc 01       	movw	r30, r24
    2ef4:	53 80       	ldd	r5, Z+3	; 0x03
    2ef6:	fc 01       	movw	r30, r24
    2ef8:	64 80       	ldd	r6, Z+4	; 0x04
    2efa:	fc 01       	movw	r30, r24
    2efc:	75 80       	ldd	r7, Z+5	; 0x05
    2efe:	fc 01       	movw	r30, r24
    2f00:	86 80       	ldd	r8, Z+6	; 0x06
    2f02:	fc 01       	movw	r30, r24
    2f04:	97 80       	ldd	r9, Z+7	; 0x07
    2f06:	2a 2d       	mov	r18, r10
    2f08:	22 0d       	add	r18, r2
    2f0a:	e1 e0       	ldi	r30, 0x01	; 1
    2f0c:	2a 15       	cp	r18, r10
    2f0e:	08 f0       	brcs	.+2      	; 0x2f12 <calcChecksumFRAM+0x3a4>
    2f10:	e0 e0       	ldi	r30, 0x00	; 0
    2f12:	3b 2d       	mov	r19, r11
    2f14:	33 0d       	add	r19, r3
    2f16:	f1 e0       	ldi	r31, 0x01	; 1
    2f18:	3b 15       	cp	r19, r11
    2f1a:	08 f0       	brcs	.+2      	; 0x2f1e <calcChecksumFRAM+0x3b0>
    2f1c:	f0 e0       	ldi	r31, 0x00	; 0
    2f1e:	e3 0f       	add	r30, r19
    2f20:	a1 e0       	ldi	r26, 0x01	; 1
    2f22:	e3 17       	cp	r30, r19
    2f24:	08 f0       	brcs	.+2      	; 0x2f28 <calcChecksumFRAM+0x3ba>
    2f26:	a0 e0       	ldi	r26, 0x00	; 0
    2f28:	fa 2b       	or	r31, r26
    2f2a:	3e 2f       	mov	r19, r30
    2f2c:	4c 2d       	mov	r20, r12
    2f2e:	44 0d       	add	r20, r4
    2f30:	e1 e0       	ldi	r30, 0x01	; 1
    2f32:	4c 15       	cp	r20, r12
    2f34:	08 f0       	brcs	.+2      	; 0x2f38 <calcChecksumFRAM+0x3ca>
    2f36:	e0 e0       	ldi	r30, 0x00	; 0
    2f38:	f4 0f       	add	r31, r20
    2f3a:	a1 e0       	ldi	r26, 0x01	; 1
    2f3c:	f4 17       	cp	r31, r20
    2f3e:	08 f0       	brcs	.+2      	; 0x2f42 <calcChecksumFRAM+0x3d4>
    2f40:	a0 e0       	ldi	r26, 0x00	; 0
    2f42:	ea 2b       	or	r30, r26
    2f44:	4f 2f       	mov	r20, r31
    2f46:	5d 2d       	mov	r21, r13
    2f48:	55 0d       	add	r21, r5
    2f4a:	f1 e0       	ldi	r31, 0x01	; 1
    2f4c:	5d 15       	cp	r21, r13
    2f4e:	08 f0       	brcs	.+2      	; 0x2f52 <calcChecksumFRAM+0x3e4>
    2f50:	f0 e0       	ldi	r31, 0x00	; 0
    2f52:	e5 0f       	add	r30, r21
    2f54:	a1 e0       	ldi	r26, 0x01	; 1
    2f56:	e5 17       	cp	r30, r21
    2f58:	08 f0       	brcs	.+2      	; 0x2f5c <calcChecksumFRAM+0x3ee>
    2f5a:	a0 e0       	ldi	r26, 0x00	; 0
    2f5c:	fa 2b       	or	r31, r26
    2f5e:	5e 2f       	mov	r21, r30
    2f60:	6e 2d       	mov	r22, r14
    2f62:	66 0d       	add	r22, r6
    2f64:	e1 e0       	ldi	r30, 0x01	; 1
    2f66:	6e 15       	cp	r22, r14
    2f68:	08 f0       	brcs	.+2      	; 0x2f6c <calcChecksumFRAM+0x3fe>
    2f6a:	e0 e0       	ldi	r30, 0x00	; 0
    2f6c:	f6 0f       	add	r31, r22
    2f6e:	a1 e0       	ldi	r26, 0x01	; 1
    2f70:	f6 17       	cp	r31, r22
    2f72:	08 f0       	brcs	.+2      	; 0x2f76 <calcChecksumFRAM+0x408>
    2f74:	a0 e0       	ldi	r26, 0x00	; 0
    2f76:	ea 2b       	or	r30, r26
    2f78:	6f 2f       	mov	r22, r31
    2f7a:	7f 2d       	mov	r23, r15
    2f7c:	77 0d       	add	r23, r7
    2f7e:	f1 e0       	ldi	r31, 0x01	; 1
    2f80:	7f 15       	cp	r23, r15
    2f82:	08 f0       	brcs	.+2      	; 0x2f86 <calcChecksumFRAM+0x418>
    2f84:	f0 e0       	ldi	r31, 0x00	; 0
    2f86:	e7 0f       	add	r30, r23
    2f88:	a1 e0       	ldi	r26, 0x01	; 1
    2f8a:	e7 17       	cp	r30, r23
    2f8c:	08 f0       	brcs	.+2      	; 0x2f90 <calcChecksumFRAM+0x422>
    2f8e:	a0 e0       	ldi	r26, 0x00	; 0
    2f90:	fa 2b       	or	r31, r26
    2f92:	7e 2f       	mov	r23, r30
    2f94:	80 2f       	mov	r24, r16
    2f96:	88 0d       	add	r24, r8
    2f98:	e1 e0       	ldi	r30, 0x01	; 1
    2f9a:	80 17       	cp	r24, r16
    2f9c:	08 f0       	brcs	.+2      	; 0x2fa0 <calcChecksumFRAM+0x432>
    2f9e:	e0 e0       	ldi	r30, 0x00	; 0
    2fa0:	f8 0f       	add	r31, r24
    2fa2:	a1 e0       	ldi	r26, 0x01	; 1
    2fa4:	f8 17       	cp	r31, r24
    2fa6:	08 f0       	brcs	.+2      	; 0x2faa <calcChecksumFRAM+0x43c>
    2fa8:	a0 e0       	ldi	r26, 0x00	; 0
    2faa:	ea 2b       	or	r30, r26
    2fac:	8f 2f       	mov	r24, r31
    2fae:	91 2f       	mov	r25, r17
    2fb0:	99 0d       	add	r25, r9
    2fb2:	e9 0f       	add	r30, r25
    2fb4:	9e 2f       	mov	r25, r30
    2fb6:	a2 2e       	mov	r10, r18
    2fb8:	b3 2e       	mov	r11, r19
    2fba:	c4 2e       	mov	r12, r20
    2fbc:	d5 2e       	mov	r13, r21
    2fbe:	e6 2e       	mov	r14, r22
    2fc0:	f7 2e       	mov	r15, r23
    2fc2:	08 2f       	mov	r16, r24
    2fc4:	19 2f       	mov	r17, r25
    2fc6:	a0 92 84 50 	sts	0x5084, r10
    2fca:	b0 92 85 50 	sts	0x5085, r11
    2fce:	c0 92 86 50 	sts	0x5086, r12
    2fd2:	d0 92 87 50 	sts	0x5087, r13
    2fd6:	e0 92 88 50 	sts	0x5088, r14
    2fda:	f0 92 89 50 	sts	0x5089, r15
    2fde:	00 93 8a 50 	sts	0x508A, r16
    2fe2:	10 93 8b 50 	sts	0x508B, r17
			if(k%9 == 8) sumFRAM[2] += *temp64;
    2fe6:	8b 81       	ldd	r24, Y+3	; 0x03
    2fe8:	9c 81       	ldd	r25, Y+4	; 0x04
    2fea:	29 e0       	ldi	r18, 0x09	; 9
    2fec:	30 e0       	ldi	r19, 0x00	; 0
    2fee:	b9 01       	movw	r22, r18
    2ff0:	0e 94 bd 5b 	call	0xb77a	; 0xb77a <__udivmodhi4>
    2ff4:	88 30       	cpi	r24, 0x08	; 8
    2ff6:	91 05       	cpc	r25, r1
    2ff8:	09 f0       	breq	.+2      	; 0x2ffc <calcChecksumFRAM+0x48e>
    2ffa:	94 c0       	rjmp	.+296    	; 0x3124 <calcChecksumFRAM+0x5b6>
    2ffc:	a0 90 8c 50 	lds	r10, 0x508C
    3000:	b0 90 8d 50 	lds	r11, 0x508D
    3004:	c0 90 8e 50 	lds	r12, 0x508E
    3008:	d0 90 8f 50 	lds	r13, 0x508F
    300c:	e0 90 90 50 	lds	r14, 0x5090
    3010:	f0 90 91 50 	lds	r15, 0x5091
    3014:	00 91 92 50 	lds	r16, 0x5092
    3018:	10 91 93 50 	lds	r17, 0x5093
    301c:	80 91 54 50 	lds	r24, 0x5054
    3020:	90 91 55 50 	lds	r25, 0x5055
    3024:	fc 01       	movw	r30, r24
    3026:	20 80       	ld	r2, Z
    3028:	fc 01       	movw	r30, r24
    302a:	31 80       	ldd	r3, Z+1	; 0x01
    302c:	fc 01       	movw	r30, r24
    302e:	42 80       	ldd	r4, Z+2	; 0x02
    3030:	fc 01       	movw	r30, r24
    3032:	53 80       	ldd	r5, Z+3	; 0x03
    3034:	fc 01       	movw	r30, r24
    3036:	64 80       	ldd	r6, Z+4	; 0x04
    3038:	fc 01       	movw	r30, r24
    303a:	75 80       	ldd	r7, Z+5	; 0x05
    303c:	fc 01       	movw	r30, r24
    303e:	86 80       	ldd	r8, Z+6	; 0x06
    3040:	fc 01       	movw	r30, r24
    3042:	97 80       	ldd	r9, Z+7	; 0x07
    3044:	2a 2d       	mov	r18, r10
    3046:	22 0d       	add	r18, r2
    3048:	e1 e0       	ldi	r30, 0x01	; 1
    304a:	2a 15       	cp	r18, r10
    304c:	08 f0       	brcs	.+2      	; 0x3050 <calcChecksumFRAM+0x4e2>
    304e:	e0 e0       	ldi	r30, 0x00	; 0
    3050:	3b 2d       	mov	r19, r11
    3052:	33 0d       	add	r19, r3
    3054:	f1 e0       	ldi	r31, 0x01	; 1
    3056:	3b 15       	cp	r19, r11
    3058:	08 f0       	brcs	.+2      	; 0x305c <calcChecksumFRAM+0x4ee>
    305a:	f0 e0       	ldi	r31, 0x00	; 0
    305c:	e3 0f       	add	r30, r19
    305e:	a1 e0       	ldi	r26, 0x01	; 1
    3060:	e3 17       	cp	r30, r19
    3062:	08 f0       	brcs	.+2      	; 0x3066 <calcChecksumFRAM+0x4f8>
    3064:	a0 e0       	ldi	r26, 0x00	; 0
    3066:	fa 2b       	or	r31, r26
    3068:	3e 2f       	mov	r19, r30
    306a:	4c 2d       	mov	r20, r12
    306c:	44 0d       	add	r20, r4
    306e:	e1 e0       	ldi	r30, 0x01	; 1
    3070:	4c 15       	cp	r20, r12
    3072:	08 f0       	brcs	.+2      	; 0x3076 <calcChecksumFRAM+0x508>
    3074:	e0 e0       	ldi	r30, 0x00	; 0
    3076:	f4 0f       	add	r31, r20
    3078:	a1 e0       	ldi	r26, 0x01	; 1
    307a:	f4 17       	cp	r31, r20
    307c:	08 f0       	brcs	.+2      	; 0x3080 <calcChecksumFRAM+0x512>
    307e:	a0 e0       	ldi	r26, 0x00	; 0
    3080:	ea 2b       	or	r30, r26
    3082:	4f 2f       	mov	r20, r31
    3084:	5d 2d       	mov	r21, r13
    3086:	55 0d       	add	r21, r5
    3088:	f1 e0       	ldi	r31, 0x01	; 1
    308a:	5d 15       	cp	r21, r13
    308c:	08 f0       	brcs	.+2      	; 0x3090 <calcChecksumFRAM+0x522>
    308e:	f0 e0       	ldi	r31, 0x00	; 0
    3090:	e5 0f       	add	r30, r21
    3092:	a1 e0       	ldi	r26, 0x01	; 1
    3094:	e5 17       	cp	r30, r21
    3096:	08 f0       	brcs	.+2      	; 0x309a <calcChecksumFRAM+0x52c>
    3098:	a0 e0       	ldi	r26, 0x00	; 0
    309a:	fa 2b       	or	r31, r26
    309c:	5e 2f       	mov	r21, r30
    309e:	6e 2d       	mov	r22, r14
    30a0:	66 0d       	add	r22, r6
    30a2:	e1 e0       	ldi	r30, 0x01	; 1
    30a4:	6e 15       	cp	r22, r14
    30a6:	08 f0       	brcs	.+2      	; 0x30aa <calcChecksumFRAM+0x53c>
    30a8:	e0 e0       	ldi	r30, 0x00	; 0
    30aa:	f6 0f       	add	r31, r22
    30ac:	a1 e0       	ldi	r26, 0x01	; 1
    30ae:	f6 17       	cp	r31, r22
    30b0:	08 f0       	brcs	.+2      	; 0x30b4 <calcChecksumFRAM+0x546>
    30b2:	a0 e0       	ldi	r26, 0x00	; 0
    30b4:	ea 2b       	or	r30, r26
    30b6:	6f 2f       	mov	r22, r31
    30b8:	7f 2d       	mov	r23, r15
    30ba:	77 0d       	add	r23, r7
    30bc:	f1 e0       	ldi	r31, 0x01	; 1
    30be:	7f 15       	cp	r23, r15
    30c0:	08 f0       	brcs	.+2      	; 0x30c4 <calcChecksumFRAM+0x556>
    30c2:	f0 e0       	ldi	r31, 0x00	; 0
    30c4:	e7 0f       	add	r30, r23
    30c6:	a1 e0       	ldi	r26, 0x01	; 1
    30c8:	e7 17       	cp	r30, r23
    30ca:	08 f0       	brcs	.+2      	; 0x30ce <calcChecksumFRAM+0x560>
    30cc:	a0 e0       	ldi	r26, 0x00	; 0
    30ce:	fa 2b       	or	r31, r26
    30d0:	7e 2f       	mov	r23, r30
    30d2:	80 2f       	mov	r24, r16
    30d4:	88 0d       	add	r24, r8
    30d6:	e1 e0       	ldi	r30, 0x01	; 1
    30d8:	80 17       	cp	r24, r16
    30da:	08 f0       	brcs	.+2      	; 0x30de <calcChecksumFRAM+0x570>
    30dc:	e0 e0       	ldi	r30, 0x00	; 0
    30de:	f8 0f       	add	r31, r24
    30e0:	a1 e0       	ldi	r26, 0x01	; 1
    30e2:	f8 17       	cp	r31, r24
    30e4:	08 f0       	brcs	.+2      	; 0x30e8 <calcChecksumFRAM+0x57a>
    30e6:	a0 e0       	ldi	r26, 0x00	; 0
    30e8:	ea 2b       	or	r30, r26
    30ea:	8f 2f       	mov	r24, r31
    30ec:	91 2f       	mov	r25, r17
    30ee:	99 0d       	add	r25, r9
    30f0:	e9 0f       	add	r30, r25
    30f2:	9e 2f       	mov	r25, r30
    30f4:	a2 2e       	mov	r10, r18
    30f6:	b3 2e       	mov	r11, r19
    30f8:	c4 2e       	mov	r12, r20
    30fa:	d5 2e       	mov	r13, r21
    30fc:	e6 2e       	mov	r14, r22
    30fe:	f7 2e       	mov	r15, r23
    3100:	08 2f       	mov	r16, r24
    3102:	19 2f       	mov	r17, r25
    3104:	a0 92 8c 50 	sts	0x508C, r10
    3108:	b0 92 8d 50 	sts	0x508D, r11
    310c:	c0 92 8e 50 	sts	0x508E, r12
    3110:	d0 92 8f 50 	sts	0x508F, r13
    3114:	e0 92 90 50 	sts	0x5090, r14
    3118:	f0 92 91 50 	sts	0x5091, r15
    311c:	00 93 92 50 	sts	0x5092, r16
    3120:	10 93 93 50 	sts	0x5093, r17
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    3124:	8b 81       	ldd	r24, Y+3	; 0x03
    3126:	9c 81       	ldd	r25, Y+4	; 0x04
    3128:	01 96       	adiw	r24, 0x01	; 1
    312a:	8b 83       	std	Y+3, r24	; 0x03
    312c:	9c 83       	std	Y+4, r25	; 0x04
    312e:	8b 81       	ldd	r24, Y+3	; 0x03
    3130:	9c 81       	ldd	r25, Y+4	; 0x04
    3132:	fc e1       	ldi	r31, 0x1C	; 28
    3134:	81 37       	cpi	r24, 0x71	; 113
    3136:	9f 07       	cpc	r25, r31
    3138:	08 f4       	brcc	.+2      	; 0x313c <calcChecksumFRAM+0x5ce>
    313a:	8e cd       	rjmp	.-1252   	; 0x2c58 <calcChecksumFRAM+0xea>
//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    313c:	89 81       	ldd	r24, Y+1	; 0x01
    313e:	9a 81       	ldd	r25, Y+2	; 0x02
    3140:	01 96       	adiw	r24, 0x01	; 1
    3142:	89 83       	std	Y+1, r24	; 0x01
    3144:	9a 83       	std	Y+2, r25	; 0x02
    3146:	89 81       	ldd	r24, Y+1	; 0x01
    3148:	9a 81       	ldd	r25, Y+2	; 0x02
    314a:	89 30       	cpi	r24, 0x09	; 9
    314c:	91 05       	cpc	r25, r1
    314e:	08 f4       	brcc	.+2      	; 0x3152 <calcChecksumFRAM+0x5e4>
    3150:	72 cd       	rjmp	.-1308   	; 0x2c36 <calcChecksumFRAM+0xc8>
			
		}
		
	}
	
}
    3152:	24 96       	adiw	r28, 0x04	; 4
    3154:	cd bf       	out	0x3d, r28	; 61
    3156:	de bf       	out	0x3e, r29	; 62
    3158:	df 91       	pop	r29
    315a:	cf 91       	pop	r28
    315c:	1f 91       	pop	r17
    315e:	0f 91       	pop	r16
    3160:	ff 90       	pop	r15
    3162:	ef 90       	pop	r14
    3164:	df 90       	pop	r13
    3166:	cf 90       	pop	r12
    3168:	bf 90       	pop	r11
    316a:	af 90       	pop	r10
    316c:	9f 90       	pop	r9
    316e:	8f 90       	pop	r8
    3170:	7f 90       	pop	r7
    3172:	6f 90       	pop	r6
    3174:	5f 90       	pop	r5
    3176:	4f 90       	pop	r4
    3178:	3f 90       	pop	r3
    317a:	2f 90       	pop	r2
    317c:	08 95       	ret

0000317e <FRAMWriteKnowns>:

//test function for FRAM
void FRAMWriteKnowns() {
    317e:	cf 93       	push	r28
    3180:	df 93       	push	r29
    3182:	cd b7       	in	r28, 0x3d	; 61
    3184:	de b7       	in	r29, 0x3e	; 62
	FRAMAddress = FR_BASEADD;
    3186:	10 92 48 40 	sts	0x4048, r1
    318a:	10 92 49 40 	sts	0x4049, r1
	sampleCount = 0;
    318e:	10 92 65 50 	sts	0x5065, r1
    3192:	10 92 66 50 	sts	0x5066, r1
    3196:	10 92 67 50 	sts	0x5067, r1
    319a:	10 92 68 50 	sts	0x5068, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    319e:	80 e0       	ldi	r24, 0x00	; 0
    31a0:	80 93 2c 21 	sts	0x212C, r24
    31a4:	80 93 2b 21 	sts	0x212B, r24
    31a8:	80 93 2a 21 	sts	0x212A, r24
	
	ADCPower(TRUE);
    31ac:	81 e0       	ldi	r24, 0x01	; 1
    31ae:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    31b2:	84 e0       	ldi	r24, 0x04	; 4
    31b4:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    31b8:	80 ec       	ldi	r24, 0xC0	; 192
    31ba:	98 e0       	ldi	r25, 0x08	; 8
    31bc:	20 ed       	ldi	r18, 0xD0	; 208
    31be:	fc 01       	movw	r30, r24
    31c0:	20 83       	st	Z, r18
	SPIBuffer[0] = 0x0D;
    31c2:	8d e0       	ldi	r24, 0x0D	; 13
    31c4:	80 93 56 50 	sts	0x5056, r24
	SPIBuffer[1] = 0xF3;
    31c8:	83 ef       	ldi	r24, 0xF3	; 243
    31ca:	80 93 57 50 	sts	0x5057, r24
	SPIBuffer[2] = 0x57;
    31ce:	87 e5       	ldi	r24, 0x57	; 87
    31d0:	80 93 58 50 	sts	0x5058, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    31d4:	d7 c0       	rjmp	.+430    	; 0x3384 <FRAMWriteKnowns+0x206>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    31d6:	80 e4       	ldi	r24, 0x40	; 64
    31d8:	96 e0       	ldi	r25, 0x06	; 6
    31da:	20 e1       	ldi	r18, 0x10	; 16
    31dc:	fc 01       	movw	r30, r24
    31de:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    31e0:	80 e2       	ldi	r24, 0x20	; 32
    31e2:	96 e0       	ldi	r25, 0x06	; 6
    31e4:	28 e0       	ldi	r18, 0x08	; 8
    31e6:	fc 01       	movw	r30, r24
    31e8:	26 83       	std	Z+6, r18	; 0x06
		nop();
    31ea:	00 00       	nop
		SPIC.DATA = FR_WREN;
    31ec:	80 ec       	ldi	r24, 0xC0	; 192
    31ee:	98 e0       	ldi	r25, 0x08	; 8
    31f0:	26 e0       	ldi	r18, 0x06	; 6
    31f2:	fc 01       	movw	r30, r24
    31f4:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    31f6:	00 00       	nop
    31f8:	80 ec       	ldi	r24, 0xC0	; 192
    31fa:	98 e0       	ldi	r25, 0x08	; 8
    31fc:	fc 01       	movw	r30, r24
    31fe:	82 81       	ldd	r24, Z+2	; 0x02
    3200:	88 23       	and	r24, r24
    3202:	d4 f7       	brge	.-12     	; 0x31f8 <FRAMWriteKnowns+0x7a>
		SPIBuffer[12] = SPIC.DATA;
    3204:	80 ec       	ldi	r24, 0xC0	; 192
    3206:	98 e0       	ldi	r25, 0x08	; 8
    3208:	fc 01       	movw	r30, r24
    320a:	83 81       	ldd	r24, Z+3	; 0x03
    320c:	80 93 62 50 	sts	0x5062, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    3210:	80 e2       	ldi	r24, 0x20	; 32
    3212:	96 e0       	ldi	r25, 0x06	; 6
    3214:	28 e0       	ldi	r18, 0x08	; 8
    3216:	fc 01       	movw	r30, r24
    3218:	25 83       	std	Z+5, r18	; 0x05
		nop(); // time for CS_FRAM to accept high signal
    321a:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    321c:	80 e2       	ldi	r24, 0x20	; 32
    321e:	96 e0       	ldi	r25, 0x06	; 6
    3220:	28 e0       	ldi	r18, 0x08	; 8
    3222:	fc 01       	movw	r30, r24
    3224:	26 83       	std	Z+6, r18	; 0x06
		nop();
    3226:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    3228:	80 ec       	ldi	r24, 0xC0	; 192
    322a:	98 e0       	ldi	r25, 0x08	; 8
    322c:	22 e0       	ldi	r18, 0x02	; 2
    322e:	fc 01       	movw	r30, r24
    3230:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3232:	00 00       	nop
    3234:	80 ec       	ldi	r24, 0xC0	; 192
    3236:	98 e0       	ldi	r25, 0x08	; 8
    3238:	fc 01       	movw	r30, r24
    323a:	82 81       	ldd	r24, Z+2	; 0x02
    323c:	88 23       	and	r24, r24
    323e:	d4 f7       	brge	.-12     	; 0x3234 <FRAMWriteKnowns+0xb6>
		SPIBuffer[12] = SPIC.DATA;
    3240:	80 ec       	ldi	r24, 0xC0	; 192
    3242:	98 e0       	ldi	r25, 0x08	; 8
    3244:	fc 01       	movw	r30, r24
    3246:	83 81       	ldd	r24, Z+3	; 0x03
    3248:	80 93 62 50 	sts	0x5062, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    324c:	80 ec       	ldi	r24, 0xC0	; 192
    324e:	98 e0       	ldi	r25, 0x08	; 8
    3250:	20 91 49 40 	lds	r18, 0x4049
    3254:	fc 01       	movw	r30, r24
    3256:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3258:	00 00       	nop
    325a:	80 ec       	ldi	r24, 0xC0	; 192
    325c:	98 e0       	ldi	r25, 0x08	; 8
    325e:	fc 01       	movw	r30, r24
    3260:	82 81       	ldd	r24, Z+2	; 0x02
    3262:	88 23       	and	r24, r24
    3264:	d4 f7       	brge	.-12     	; 0x325a <FRAMWriteKnowns+0xdc>
		SPIBuffer[12] = SPIC.DATA;
    3266:	80 ec       	ldi	r24, 0xC0	; 192
    3268:	98 e0       	ldi	r25, 0x08	; 8
    326a:	fc 01       	movw	r30, r24
    326c:	83 81       	ldd	r24, Z+3	; 0x03
    326e:	80 93 62 50 	sts	0x5062, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    3272:	80 ec       	ldi	r24, 0xC0	; 192
    3274:	98 e0       	ldi	r25, 0x08	; 8
    3276:	28 e4       	ldi	r18, 0x48	; 72
    3278:	30 e4       	ldi	r19, 0x40	; 64
    327a:	f9 01       	movw	r30, r18
    327c:	20 81       	ld	r18, Z
    327e:	fc 01       	movw	r30, r24
    3280:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3282:	00 00       	nop
    3284:	80 ec       	ldi	r24, 0xC0	; 192
    3286:	98 e0       	ldi	r25, 0x08	; 8
    3288:	fc 01       	movw	r30, r24
    328a:	82 81       	ldd	r24, Z+2	; 0x02
    328c:	88 23       	and	r24, r24
    328e:	d4 f7       	brge	.-12     	; 0x3284 <FRAMWriteKnowns+0x106>
		SPIBuffer[12] = SPIC.DATA;
    3290:	80 ec       	ldi	r24, 0xC0	; 192
    3292:	98 e0       	ldi	r25, 0x08	; 8
    3294:	fc 01       	movw	r30, r24
    3296:	83 81       	ldd	r24, Z+3	; 0x03
    3298:	80 93 62 50 	sts	0x5062, r24
		SPIC.DATA = SPIBuffer[0];
    329c:	80 ec       	ldi	r24, 0xC0	; 192
    329e:	98 e0       	ldi	r25, 0x08	; 8
    32a0:	20 91 56 50 	lds	r18, 0x5056
    32a4:	fc 01       	movw	r30, r24
    32a6:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    32a8:	00 00       	nop
    32aa:	80 ec       	ldi	r24, 0xC0	; 192
    32ac:	98 e0       	ldi	r25, 0x08	; 8
    32ae:	fc 01       	movw	r30, r24
    32b0:	82 81       	ldd	r24, Z+2	; 0x02
    32b2:	88 23       	and	r24, r24
    32b4:	d4 f7       	brge	.-12     	; 0x32aa <FRAMWriteKnowns+0x12c>
		SPIBuffer[12] = SPIC.DATA;
    32b6:	80 ec       	ldi	r24, 0xC0	; 192
    32b8:	98 e0       	ldi	r25, 0x08	; 8
    32ba:	fc 01       	movw	r30, r24
    32bc:	83 81       	ldd	r24, Z+3	; 0x03
    32be:	80 93 62 50 	sts	0x5062, r24
		SPIC.DATA = SPIBuffer[1];
    32c2:	80 ec       	ldi	r24, 0xC0	; 192
    32c4:	98 e0       	ldi	r25, 0x08	; 8
    32c6:	20 91 57 50 	lds	r18, 0x5057
    32ca:	fc 01       	movw	r30, r24
    32cc:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    32ce:	00 00       	nop
    32d0:	80 ec       	ldi	r24, 0xC0	; 192
    32d2:	98 e0       	ldi	r25, 0x08	; 8
    32d4:	fc 01       	movw	r30, r24
    32d6:	82 81       	ldd	r24, Z+2	; 0x02
    32d8:	88 23       	and	r24, r24
    32da:	d4 f7       	brge	.-12     	; 0x32d0 <FRAMWriteKnowns+0x152>
		SPIBuffer[12] = SPIC.DATA;
    32dc:	80 ec       	ldi	r24, 0xC0	; 192
    32de:	98 e0       	ldi	r25, 0x08	; 8
    32e0:	fc 01       	movw	r30, r24
    32e2:	83 81       	ldd	r24, Z+3	; 0x03
    32e4:	80 93 62 50 	sts	0x5062, r24
		SPIC.DATA = SPIBuffer[2];
    32e8:	80 ec       	ldi	r24, 0xC0	; 192
    32ea:	98 e0       	ldi	r25, 0x08	; 8
    32ec:	20 91 58 50 	lds	r18, 0x5058
    32f0:	fc 01       	movw	r30, r24
    32f2:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    32f4:	00 00       	nop
    32f6:	80 ec       	ldi	r24, 0xC0	; 192
    32f8:	98 e0       	ldi	r25, 0x08	; 8
    32fa:	fc 01       	movw	r30, r24
    32fc:	82 81       	ldd	r24, Z+2	; 0x02
    32fe:	88 23       	and	r24, r24
    3300:	d4 f7       	brge	.-12     	; 0x32f6 <FRAMWriteKnowns+0x178>
		SPIBuffer[12] = SPIC.DATA;
    3302:	80 ec       	ldi	r24, 0xC0	; 192
    3304:	98 e0       	ldi	r25, 0x08	; 8
    3306:	fc 01       	movw	r30, r24
    3308:	83 81       	ldd	r24, Z+3	; 0x03
    330a:	80 93 62 50 	sts	0x5062, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    330e:	80 e2       	ldi	r24, 0x20	; 32
    3310:	96 e0       	ldi	r25, 0x06	; 6
    3312:	28 e0       	ldi	r18, 0x08	; 8
    3314:	fc 01       	movw	r30, r24
    3316:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    3318:	80 e4       	ldi	r24, 0x40	; 64
    331a:	96 e0       	ldi	r25, 0x06	; 6
    331c:	20 e1       	ldi	r18, 0x10	; 16
    331e:	fc 01       	movw	r30, r24
    3320:	25 83       	std	Z+5, r18	; 0x05
		
		FRAMAddress +=3;
    3322:	80 91 48 40 	lds	r24, 0x4048
    3326:	90 91 49 40 	lds	r25, 0x4049
    332a:	03 96       	adiw	r24, 0x03	; 3
    332c:	80 93 48 40 	sts	0x4048, r24
    3330:	90 93 49 40 	sts	0x4049, r25
		checksumADC[0] += SPIBuffer[0];
    3334:	90 91 2a 21 	lds	r25, 0x212A
    3338:	80 91 56 50 	lds	r24, 0x5056
    333c:	89 0f       	add	r24, r25
    333e:	80 93 2a 21 	sts	0x212A, r24
		checksumADC[1] += SPIBuffer[1];
    3342:	90 91 2b 21 	lds	r25, 0x212B
    3346:	80 91 57 50 	lds	r24, 0x5057
    334a:	89 0f       	add	r24, r25
    334c:	80 93 2b 21 	sts	0x212B, r24
		checksumADC[2] += SPIBuffer[2];
    3350:	90 91 2c 21 	lds	r25, 0x212C
    3354:	80 91 58 50 	lds	r24, 0x5058
    3358:	89 0f       	add	r24, r25
    335a:	80 93 2c 21 	sts	0x212C, r24
		
		sampleCount++;
    335e:	80 91 65 50 	lds	r24, 0x5065
    3362:	90 91 66 50 	lds	r25, 0x5066
    3366:	a0 91 67 50 	lds	r26, 0x5067
    336a:	b0 91 68 50 	lds	r27, 0x5068
    336e:	01 96       	adiw	r24, 0x01	; 1
    3370:	a1 1d       	adc	r26, r1
    3372:	b1 1d       	adc	r27, r1
    3374:	80 93 65 50 	sts	0x5065, r24
    3378:	90 93 66 50 	sts	0x5066, r25
    337c:	a0 93 67 50 	sts	0x5067, r26
    3380:	b0 93 68 50 	sts	0x5068, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    3384:	80 91 65 50 	lds	r24, 0x5065
    3388:	90 91 66 50 	lds	r25, 0x5066
    338c:	a0 91 67 50 	lds	r26, 0x5067
    3390:	b0 91 68 50 	lds	r27, 0x5068
    3394:	83 35       	cpi	r24, 0x53	; 83
    3396:	f5 e5       	ldi	r31, 0x55	; 85
    3398:	9f 07       	cpc	r25, r31
    339a:	f0 e0       	ldi	r31, 0x00	; 0
    339c:	af 07       	cpc	r26, r31
    339e:	f0 e0       	ldi	r31, 0x00	; 0
    33a0:	bf 07       	cpc	r27, r31
    33a2:	08 f4       	brcc	.+2      	; 0x33a6 <FRAMWriteKnowns+0x228>
    33a4:	18 cf       	rjmp	.-464    	; 0x31d6 <FRAMWriteKnowns+0x58>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    33a6:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>
	ADCPower(FALSE);
    33aa:	80 e0       	ldi	r24, 0x00	; 0
    33ac:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>
}
    33b0:	df 91       	pop	r29
    33b2:	cf 91       	pop	r28
    33b4:	08 95       	ret

000033b6 <setADCInput>:



/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
    33b6:	cf 93       	push	r28
    33b8:	df 93       	push	r29
    33ba:	0f 92       	push	r0
    33bc:	cd b7       	in	r28, 0x3d	; 61
    33be:	de b7       	in	r29, 0x3e	; 62
    33c0:	89 83       	std	Y+1, r24	; 0x01
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    33c2:	89 81       	ldd	r24, Y+1	; 0x01
    33c4:	88 2f       	mov	r24, r24
    33c6:	90 e0       	ldi	r25, 0x00	; 0
    33c8:	81 70       	andi	r24, 0x01	; 1
    33ca:	90 70       	andi	r25, 0x00	; 0
    33cc:	88 23       	and	r24, r24
    33ce:	31 f0       	breq	.+12     	; 0x33dc <setADCInput+0x26>
    33d0:	80 e0       	ldi	r24, 0x00	; 0
    33d2:	96 e0       	ldi	r25, 0x06	; 6
    33d4:	20 e4       	ldi	r18, 0x40	; 64
    33d6:	fc 01       	movw	r30, r24
    33d8:	25 83       	std	Z+5, r18	; 0x05
    33da:	05 c0       	rjmp	.+10     	; 0x33e6 <setADCInput+0x30>
	else {PORTA.OUTCLR = PIN6_bm;}
    33dc:	80 e0       	ldi	r24, 0x00	; 0
    33de:	96 e0       	ldi	r25, 0x06	; 6
    33e0:	20 e4       	ldi	r18, 0x40	; 64
    33e2:	fc 01       	movw	r30, r24
    33e4:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    33e6:	89 81       	ldd	r24, Y+1	; 0x01
    33e8:	88 2f       	mov	r24, r24
    33ea:	90 e0       	ldi	r25, 0x00	; 0
    33ec:	82 70       	andi	r24, 0x02	; 2
    33ee:	90 70       	andi	r25, 0x00	; 0
    33f0:	00 97       	sbiw	r24, 0x00	; 0
    33f2:	31 f0       	breq	.+12     	; 0x3400 <setADCInput+0x4a>
    33f4:	80 e2       	ldi	r24, 0x20	; 32
    33f6:	96 e0       	ldi	r25, 0x06	; 6
    33f8:	22 e0       	ldi	r18, 0x02	; 2
    33fa:	fc 01       	movw	r30, r24
    33fc:	25 83       	std	Z+5, r18	; 0x05
    33fe:	05 c0       	rjmp	.+10     	; 0x340a <setADCInput+0x54>
	else {PORTB.OUTCLR = PIN1_bm;}
    3400:	80 e2       	ldi	r24, 0x20	; 32
    3402:	96 e0       	ldi	r25, 0x06	; 6
    3404:	22 e0       	ldi	r18, 0x02	; 2
    3406:	fc 01       	movw	r30, r24
    3408:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    340a:	89 81       	ldd	r24, Y+1	; 0x01
    340c:	88 2f       	mov	r24, r24
    340e:	90 e0       	ldi	r25, 0x00	; 0
    3410:	84 70       	andi	r24, 0x04	; 4
    3412:	90 70       	andi	r25, 0x00	; 0
    3414:	00 97       	sbiw	r24, 0x00	; 0
    3416:	31 f0       	breq	.+12     	; 0x3424 <setADCInput+0x6e>
    3418:	80 e2       	ldi	r24, 0x20	; 32
    341a:	96 e0       	ldi	r25, 0x06	; 6
    341c:	24 e0       	ldi	r18, 0x04	; 4
    341e:	fc 01       	movw	r30, r24
    3420:	25 83       	std	Z+5, r18	; 0x05
    3422:	05 c0       	rjmp	.+10     	; 0x342e <setADCInput+0x78>
	else {PORTB.OUTCLR = PIN2_bm;}
    3424:	80 e2       	ldi	r24, 0x20	; 32
    3426:	96 e0       	ldi	r25, 0x06	; 6
    3428:	24 e0       	ldi	r18, 0x04	; 4
    342a:	fc 01       	movw	r30, r24
    342c:	26 83       	std	Z+6, r18	; 0x06

}
    342e:	0f 90       	pop	r0
    3430:	df 91       	pop	r29
    3432:	cf 91       	pop	r28
    3434:	08 95       	ret

00003436 <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    3436:	cf 93       	push	r28
    3438:	df 93       	push	r29
    343a:	0f 92       	push	r0
    343c:	0f 92       	push	r0
    343e:	cd b7       	in	r28, 0x3d	; 61
    3440:	de b7       	in	r29, 0x3e	; 62
    3442:	89 83       	std	Y+1, r24	; 0x01
    3444:	9a 83       	std	Y+2, r25	; 0x02
	if(&ADCA == adc){
    3446:	89 81       	ldd	r24, Y+1	; 0x01
    3448:	9a 81       	ldd	r25, Y+2	; 0x02
    344a:	22 e0       	ldi	r18, 0x02	; 2
    344c:	80 30       	cpi	r24, 0x00	; 0
    344e:	92 07       	cpc	r25, r18
    3450:	89 f4       	brne	.+34     	; 0x3474 <ADC_CalibrationValues_Load+0x3e>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    3452:	80 e2       	ldi	r24, 0x20	; 32
    3454:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <SP_ReadCalibrationByte>
    3458:	28 2f       	mov	r18, r24
    345a:	89 81       	ldd	r24, Y+1	; 0x01
    345c:	9a 81       	ldd	r25, Y+2	; 0x02
    345e:	fc 01       	movw	r30, r24
    3460:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    3462:	81 e2       	ldi	r24, 0x21	; 33
    3464:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <SP_ReadCalibrationByte>
    3468:	28 2f       	mov	r18, r24
    346a:	89 81       	ldd	r24, Y+1	; 0x01
    346c:	9a 81       	ldd	r25, Y+2	; 0x02
    346e:	fc 01       	movw	r30, r24
    3470:	25 87       	std	Z+13, r18	; 0x0d
    3472:	10 c0       	rjmp	.+32     	; 0x3494 <ADC_CalibrationValues_Load+0x5e>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    3474:	84 e2       	ldi	r24, 0x24	; 36
    3476:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <SP_ReadCalibrationByte>
    347a:	28 2f       	mov	r18, r24
    347c:	89 81       	ldd	r24, Y+1	; 0x01
    347e:	9a 81       	ldd	r25, Y+2	; 0x02
    3480:	fc 01       	movw	r30, r24
    3482:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    3484:	85 e2       	ldi	r24, 0x25	; 37
    3486:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <SP_ReadCalibrationByte>
    348a:	28 2f       	mov	r18, r24
    348c:	89 81       	ldd	r24, Y+1	; 0x01
    348e:	9a 81       	ldd	r25, Y+2	; 0x02
    3490:	fc 01       	movw	r30, r24
    3492:	25 87       	std	Z+13, r18	; 0x0d
	}
}
    3494:	0f 90       	pop	r0
    3496:	0f 90       	pop	r0
    3498:	df 91       	pop	r29
    349a:	cf 91       	pop	r28
    349c:	08 95       	ret

0000349e <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    349e:	cf 93       	push	r28
    34a0:	df 93       	push	r29
    34a2:	cd b7       	in	r28, 0x3d	; 61
    34a4:	de b7       	in	r29, 0x3e	; 62
    34a6:	25 97       	sbiw	r28, 0x05	; 5
    34a8:	cd bf       	out	0x3d, r28	; 61
    34aa:	de bf       	out	0x3e, r29	; 62
    34ac:	8b 83       	std	Y+3, r24	; 0x03
    34ae:	9c 83       	std	Y+4, r25	; 0x04
    34b0:	6d 83       	std	Y+5, r22	; 0x05
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    34b2:	8b 81       	ldd	r24, Y+3	; 0x03
    34b4:	9c 81       	ldd	r25, Y+4	; 0x04
    34b6:	21 e0       	ldi	r18, 0x01	; 1
    34b8:	fc 01       	movw	r30, r24
    34ba:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    34bc:	8b 81       	ldd	r24, Y+3	; 0x03
    34be:	9c 81       	ldd	r25, Y+4	; 0x04
    34c0:	fc 01       	movw	r30, r24
    34c2:	24 81       	ldd	r18, Z+4	; 0x04
    34c4:	35 81       	ldd	r19, Z+5	; 0x05
    34c6:	8d 81       	ldd	r24, Y+5	; 0x05
    34c8:	88 2f       	mov	r24, r24
    34ca:	90 e0       	ldi	r25, 0x00	; 0
    34cc:	a9 01       	movw	r20, r18
    34ce:	48 1b       	sub	r20, r24
    34d0:	59 0b       	sbc	r21, r25
    34d2:	ca 01       	movw	r24, r20
    34d4:	89 83       	std	Y+1, r24	; 0x01
    34d6:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    34d8:	89 81       	ldd	r24, Y+1	; 0x01
    34da:	9a 81       	ldd	r25, Y+2	; 0x02
}
    34dc:	25 96       	adiw	r28, 0x05	; 5
    34de:	cd bf       	out	0x3d, r28	; 61
    34e0:	de bf       	out	0x3e, r29	; 62
    34e2:	df 91       	pop	r29
    34e4:	cf 91       	pop	r28
    34e6:	08 95       	ret

000034e8 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    34e8:	cf 93       	push	r28
    34ea:	df 93       	push	r29
    34ec:	cd b7       	in	r28, 0x3d	; 61
    34ee:	de b7       	in	r29, 0x3e	; 62
    34f0:	25 97       	sbiw	r28, 0x05	; 5
    34f2:	cd bf       	out	0x3d, r28	; 61
    34f4:	de bf       	out	0x3e, r29	; 62
    34f6:	8b 83       	std	Y+3, r24	; 0x03
    34f8:	9c 83       	std	Y+4, r25	; 0x04
    34fa:	6d 83       	std	Y+5, r22	; 0x05
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    34fc:	8b 81       	ldd	r24, Y+3	; 0x03
    34fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3500:	21 e0       	ldi	r18, 0x01	; 1
    3502:	fc 01       	movw	r30, r24
    3504:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    3506:	8b 81       	ldd	r24, Y+3	; 0x03
    3508:	9c 81       	ldd	r25, Y+4	; 0x04
    350a:	fc 01       	movw	r30, r24
    350c:	24 81       	ldd	r18, Z+4	; 0x04
    350e:	35 81       	ldd	r19, Z+5	; 0x05
    3510:	8d 81       	ldd	r24, Y+5	; 0x05
    3512:	99 27       	eor	r25, r25
    3514:	87 fd       	sbrc	r24, 7
    3516:	90 95       	com	r25
    3518:	a9 01       	movw	r20, r18
    351a:	48 1b       	sub	r20, r24
    351c:	59 0b       	sbc	r21, r25
    351e:	ca 01       	movw	r24, r20
    3520:	89 83       	std	Y+1, r24	; 0x01
    3522:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    3524:	89 81       	ldd	r24, Y+1	; 0x01
    3526:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3528:	25 96       	adiw	r28, 0x05	; 5
    352a:	cd bf       	out	0x3d, r28	; 61
    352c:	de bf       	out	0x3e, r29	; 62
    352e:	df 91       	pop	r29
    3530:	cf 91       	pop	r28
    3532:	08 95       	ret

00003534 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    3534:	cf 93       	push	r28
    3536:	df 93       	push	r29
    3538:	0f 92       	push	r0
    353a:	0f 92       	push	r0
    353c:	cd b7       	in	r28, 0x3d	; 61
    353e:	de b7       	in	r29, 0x3e	; 62
    3540:	89 83       	std	Y+1, r24	; 0x01
    3542:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3544:	89 81       	ldd	r24, Y+1	; 0x01
    3546:	9a 81       	ldd	r25, Y+2	; 0x02
    3548:	21 e0       	ldi	r18, 0x01	; 1
    354a:	fc 01       	movw	r30, r24
    354c:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    354e:	89 81       	ldd	r24, Y+1	; 0x01
    3550:	9a 81       	ldd	r25, Y+2	; 0x02
    3552:	fc 01       	movw	r30, r24
    3554:	84 81       	ldd	r24, Z+4	; 0x04
    3556:	95 81       	ldd	r25, Z+5	; 0x05
}
    3558:	0f 90       	pop	r0
    355a:	0f 90       	pop	r0
    355c:	df 91       	pop	r29
    355e:	cf 91       	pop	r28
    3560:	08 95       	ret

00003562 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    3562:	cf 93       	push	r28
    3564:	df 93       	push	r29
    3566:	0f 92       	push	r0
    3568:	0f 92       	push	r0
    356a:	cd b7       	in	r28, 0x3d	; 61
    356c:	de b7       	in	r29, 0x3e	; 62
    356e:	89 83       	std	Y+1, r24	; 0x01
    3570:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3572:	89 81       	ldd	r24, Y+1	; 0x01
    3574:	9a 81       	ldd	r25, Y+2	; 0x02
    3576:	21 e0       	ldi	r18, 0x01	; 1
    3578:	fc 01       	movw	r30, r24
    357a:	23 83       	std	Z+3, r18	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    357c:	89 81       	ldd	r24, Y+1	; 0x01
    357e:	9a 81       	ldd	r25, Y+2	; 0x02
    3580:	fc 01       	movw	r30, r24
    3582:	84 81       	ldd	r24, Z+4	; 0x04
}
    3584:	0f 90       	pop	r0
    3586:	0f 90       	pop	r0
    3588:	df 91       	pop	r29
    358a:	cf 91       	pop	r28
    358c:	08 95       	ret

0000358e <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    358e:	cf 93       	push	r28
    3590:	df 93       	push	r29
    3592:	0f 92       	push	r0
    3594:	0f 92       	push	r0
    3596:	cd b7       	in	r28, 0x3d	; 61
    3598:	de b7       	in	r29, 0x3e	; 62
    359a:	89 83       	std	Y+1, r24	; 0x01
    359c:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    359e:	89 81       	ldd	r24, Y+1	; 0x01
    35a0:	9a 81       	ldd	r25, Y+2	; 0x02
    35a2:	21 e0       	ldi	r18, 0x01	; 1
    35a4:	fc 01       	movw	r30, r24
    35a6:	23 83       	std	Z+3, r18	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    35a8:	89 81       	ldd	r24, Y+1	; 0x01
    35aa:	9a 81       	ldd	r25, Y+2	; 0x02
    35ac:	fc 01       	movw	r30, r24
    35ae:	85 81       	ldd	r24, Z+5	; 0x05
}
    35b0:	0f 90       	pop	r0
    35b2:	0f 90       	pop	r0
    35b4:	df 91       	pop	r29
    35b6:	cf 91       	pop	r28
    35b8:	08 95       	ret

000035ba <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    35ba:	0f 93       	push	r16
    35bc:	1f 93       	push	r17
    35be:	cf 93       	push	r28
    35c0:	df 93       	push	r29
    35c2:	cd b7       	in	r28, 0x3d	; 61
    35c4:	de b7       	in	r29, 0x3e	; 62
    35c6:	6b 97       	sbiw	r28, 0x1b	; 27
    35c8:	cd bf       	out	0x3d, r28	; 61
    35ca:	de bf       	out	0x3e, r29	; 62
    35cc:	8a 8f       	std	Y+26, r24	; 0x1a
    35ce:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    35d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    35d2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    35d4:	fc 01       	movw	r30, r24
    35d6:	84 81       	ldd	r24, Z+4	; 0x04
    35d8:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    35da:	8a 8d       	ldd	r24, Y+26	; 0x1a
    35dc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    35de:	fc 01       	movw	r30, r24
    35e0:	14 82       	std	Z+4, r1	; 0x04
    35e2:	80 e0       	ldi	r24, 0x00	; 0
    35e4:	90 e0       	ldi	r25, 0x00	; 0
    35e6:	a0 e8       	ldi	r26, 0x80	; 128
    35e8:	b2 e4       	ldi	r27, 0x42	; 66
    35ea:	8a 83       	std	Y+2, r24	; 0x02
    35ec:	9b 83       	std	Y+3, r25	; 0x03
    35ee:	ac 83       	std	Y+4, r26	; 0x04
    35f0:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    35f2:	6a 81       	ldd	r22, Y+2	; 0x02
    35f4:	7b 81       	ldd	r23, Y+3	; 0x03
    35f6:	8c 81       	ldd	r24, Y+4	; 0x04
    35f8:	9d 81       	ldd	r25, Y+5	; 0x05
    35fa:	2b ea       	ldi	r18, 0xAB	; 171
    35fc:	3a ea       	ldi	r19, 0xAA	; 170
    35fe:	4a e2       	ldi	r20, 0x2A	; 42
    3600:	5f e3       	ldi	r21, 0x3F	; 63
    3602:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    3606:	dc 01       	movw	r26, r24
    3608:	cb 01       	movw	r24, r22
    360a:	8e 83       	std	Y+6, r24	; 0x06
    360c:	9f 83       	std	Y+7, r25	; 0x07
    360e:	a8 87       	std	Y+8, r26	; 0x08
    3610:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3612:	11 e0       	ldi	r17, 0x01	; 1
    3614:	6e 81       	ldd	r22, Y+6	; 0x06
    3616:	7f 81       	ldd	r23, Y+7	; 0x07
    3618:	88 85       	ldd	r24, Y+8	; 0x08
    361a:	99 85       	ldd	r25, Y+9	; 0x09
    361c:	20 e0       	ldi	r18, 0x00	; 0
    361e:	30 e0       	ldi	r19, 0x00	; 0
    3620:	40 e8       	ldi	r20, 0x80	; 128
    3622:	5f e3       	ldi	r21, 0x3F	; 63
    3624:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    3628:	88 23       	and	r24, r24
    362a:	0c f0       	brlt	.+2      	; 0x362e <ADC_Wait_8MHz+0x74>
    362c:	10 e0       	ldi	r17, 0x00	; 0
    362e:	11 23       	and	r17, r17
    3630:	19 f0       	breq	.+6      	; 0x3638 <ADC_Wait_8MHz+0x7e>
		__ticks = 1;
    3632:	81 e0       	ldi	r24, 0x01	; 1
    3634:	8a 87       	std	Y+10, r24	; 0x0a
    3636:	a3 c0       	rjmp	.+326    	; 0x377e <ADC_Wait_8MHz+0x1c4>
	else if (__tmp > 255)
    3638:	11 e0       	ldi	r17, 0x01	; 1
    363a:	6e 81       	ldd	r22, Y+6	; 0x06
    363c:	7f 81       	ldd	r23, Y+7	; 0x07
    363e:	88 85       	ldd	r24, Y+8	; 0x08
    3640:	99 85       	ldd	r25, Y+9	; 0x09
    3642:	20 e0       	ldi	r18, 0x00	; 0
    3644:	30 e0       	ldi	r19, 0x00	; 0
    3646:	4f e7       	ldi	r20, 0x7F	; 127
    3648:	53 e4       	ldi	r21, 0x43	; 67
    364a:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    364e:	18 16       	cp	r1, r24
    3650:	0c f0       	brlt	.+2      	; 0x3654 <ADC_Wait_8MHz+0x9a>
    3652:	10 e0       	ldi	r17, 0x00	; 0
    3654:	11 23       	and	r17, r17
    3656:	09 f4       	brne	.+2      	; 0x365a <ADC_Wait_8MHz+0xa0>
    3658:	89 c0       	rjmp	.+274    	; 0x376c <ADC_Wait_8MHz+0x1b2>
	{
		_delay_ms(__us / 1000.0);
    365a:	6a 81       	ldd	r22, Y+2	; 0x02
    365c:	7b 81       	ldd	r23, Y+3	; 0x03
    365e:	8c 81       	ldd	r24, Y+4	; 0x04
    3660:	9d 81       	ldd	r25, Y+5	; 0x05
    3662:	20 e0       	ldi	r18, 0x00	; 0
    3664:	30 e0       	ldi	r19, 0x00	; 0
    3666:	4a e7       	ldi	r20, 0x7A	; 122
    3668:	54 e4       	ldi	r21, 0x44	; 68
    366a:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
    366e:	dc 01       	movw	r26, r24
    3670:	cb 01       	movw	r24, r22
    3672:	8b 87       	std	Y+11, r24	; 0x0b
    3674:	9c 87       	std	Y+12, r25	; 0x0c
    3676:	ad 87       	std	Y+13, r26	; 0x0d
    3678:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    367a:	6b 85       	ldd	r22, Y+11	; 0x0b
    367c:	7c 85       	ldd	r23, Y+12	; 0x0c
    367e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3680:	9e 85       	ldd	r25, Y+14	; 0x0e
    3682:	20 e0       	ldi	r18, 0x00	; 0
    3684:	30 e0       	ldi	r19, 0x00	; 0
    3686:	4a ef       	ldi	r20, 0xFA	; 250
    3688:	53 e4       	ldi	r21, 0x43	; 67
    368a:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    368e:	dc 01       	movw	r26, r24
    3690:	cb 01       	movw	r24, r22
    3692:	8f 87       	std	Y+15, r24	; 0x0f
    3694:	98 8b       	std	Y+16, r25	; 0x10
    3696:	a9 8b       	std	Y+17, r26	; 0x11
    3698:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    369a:	11 e0       	ldi	r17, 0x01	; 1
    369c:	6f 85       	ldd	r22, Y+15	; 0x0f
    369e:	78 89       	ldd	r23, Y+16	; 0x10
    36a0:	89 89       	ldd	r24, Y+17	; 0x11
    36a2:	9a 89       	ldd	r25, Y+18	; 0x12
    36a4:	20 e0       	ldi	r18, 0x00	; 0
    36a6:	30 e0       	ldi	r19, 0x00	; 0
    36a8:	40 e8       	ldi	r20, 0x80	; 128
    36aa:	5f e3       	ldi	r21, 0x3F	; 63
    36ac:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    36b0:	88 23       	and	r24, r24
    36b2:	0c f0       	brlt	.+2      	; 0x36b6 <ADC_Wait_8MHz+0xfc>
    36b4:	10 e0       	ldi	r17, 0x00	; 0
    36b6:	11 23       	and	r17, r17
    36b8:	29 f0       	breq	.+10     	; 0x36c4 <ADC_Wait_8MHz+0x10a>
		__ticks = 1;
    36ba:	81 e0       	ldi	r24, 0x01	; 1
    36bc:	90 e0       	ldi	r25, 0x00	; 0
    36be:	8b 8b       	std	Y+19, r24	; 0x13
    36c0:	9c 8b       	std	Y+20, r25	; 0x14
    36c2:	46 c0       	rjmp	.+140    	; 0x3750 <ADC_Wait_8MHz+0x196>
	else if (__tmp > 65535)
    36c4:	11 e0       	ldi	r17, 0x01	; 1
    36c6:	6f 85       	ldd	r22, Y+15	; 0x0f
    36c8:	78 89       	ldd	r23, Y+16	; 0x10
    36ca:	89 89       	ldd	r24, Y+17	; 0x11
    36cc:	9a 89       	ldd	r25, Y+18	; 0x12
    36ce:	20 e0       	ldi	r18, 0x00	; 0
    36d0:	3f ef       	ldi	r19, 0xFF	; 255
    36d2:	4f e7       	ldi	r20, 0x7F	; 127
    36d4:	57 e4       	ldi	r21, 0x47	; 71
    36d6:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    36da:	18 16       	cp	r1, r24
    36dc:	0c f0       	brlt	.+2      	; 0x36e0 <ADC_Wait_8MHz+0x126>
    36de:	10 e0       	ldi	r17, 0x00	; 0
    36e0:	11 23       	and	r17, r17
    36e2:	61 f1       	breq	.+88     	; 0x373c <ADC_Wait_8MHz+0x182>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    36e4:	6b 85       	ldd	r22, Y+11	; 0x0b
    36e6:	7c 85       	ldd	r23, Y+12	; 0x0c
    36e8:	8d 85       	ldd	r24, Y+13	; 0x0d
    36ea:	9e 85       	ldd	r25, Y+14	; 0x0e
    36ec:	20 e0       	ldi	r18, 0x00	; 0
    36ee:	30 e0       	ldi	r19, 0x00	; 0
    36f0:	40 e2       	ldi	r20, 0x20	; 32
    36f2:	51 e4       	ldi	r21, 0x41	; 65
    36f4:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    36f8:	dc 01       	movw	r26, r24
    36fa:	cb 01       	movw	r24, r22
    36fc:	bc 01       	movw	r22, r24
    36fe:	cd 01       	movw	r24, r26
    3700:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    3704:	dc 01       	movw	r26, r24
    3706:	cb 01       	movw	r24, r22
    3708:	8b 8b       	std	Y+19, r24	; 0x13
    370a:	9c 8b       	std	Y+20, r25	; 0x14
    370c:	12 c0       	rjmp	.+36     	; 0x3732 <ADC_Wait_8MHz+0x178>
    370e:	82 e3       	ldi	r24, 0x32	; 50
    3710:	90 e0       	ldi	r25, 0x00	; 0
    3712:	8d 8b       	std	Y+21, r24	; 0x15
    3714:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3716:	8d 89       	ldd	r24, Y+21	; 0x15
    3718:	9e 89       	ldd	r25, Y+22	; 0x16
    371a:	8c 01       	movw	r16, r24
    371c:	c8 01       	movw	r24, r16
    371e:	01 97       	sbiw	r24, 0x01	; 1
    3720:	f1 f7       	brne	.-4      	; 0x371e <ADC_Wait_8MHz+0x164>
    3722:	8c 01       	movw	r16, r24
    3724:	0d 8b       	std	Y+21, r16	; 0x15
    3726:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3728:	8b 89       	ldd	r24, Y+19	; 0x13
    372a:	9c 89       	ldd	r25, Y+20	; 0x14
    372c:	01 97       	sbiw	r24, 0x01	; 1
    372e:	8b 8b       	std	Y+19, r24	; 0x13
    3730:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3732:	8b 89       	ldd	r24, Y+19	; 0x13
    3734:	9c 89       	ldd	r25, Y+20	; 0x14
    3736:	00 97       	sbiw	r24, 0x00	; 0
    3738:	51 f7       	brne	.-44     	; 0x370e <ADC_Wait_8MHz+0x154>
    373a:	28 c0       	rjmp	.+80     	; 0x378c <ADC_Wait_8MHz+0x1d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    373c:	6f 85       	ldd	r22, Y+15	; 0x0f
    373e:	78 89       	ldd	r23, Y+16	; 0x10
    3740:	89 89       	ldd	r24, Y+17	; 0x11
    3742:	9a 89       	ldd	r25, Y+18	; 0x12
    3744:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    3748:	dc 01       	movw	r26, r24
    374a:	cb 01       	movw	r24, r22
    374c:	8b 8b       	std	Y+19, r24	; 0x13
    374e:	9c 8b       	std	Y+20, r25	; 0x14
    3750:	8b 89       	ldd	r24, Y+19	; 0x13
    3752:	9c 89       	ldd	r25, Y+20	; 0x14
    3754:	8f 8b       	std	Y+23, r24	; 0x17
    3756:	98 8f       	std	Y+24, r25	; 0x18
    3758:	8f 89       	ldd	r24, Y+23	; 0x17
    375a:	98 8d       	ldd	r25, Y+24	; 0x18
    375c:	8c 01       	movw	r16, r24
    375e:	f8 01       	movw	r30, r16
    3760:	31 97       	sbiw	r30, 0x01	; 1
    3762:	f1 f7       	brne	.-4      	; 0x3760 <ADC_Wait_8MHz+0x1a6>
    3764:	8f 01       	movw	r16, r30
    3766:	0f 8b       	std	Y+23, r16	; 0x17
    3768:	18 8f       	std	Y+24, r17	; 0x18
    376a:	10 c0       	rjmp	.+32     	; 0x378c <ADC_Wait_8MHz+0x1d2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    376c:	6e 81       	ldd	r22, Y+6	; 0x06
    376e:	7f 81       	ldd	r23, Y+7	; 0x07
    3770:	88 85       	ldd	r24, Y+8	; 0x08
    3772:	99 85       	ldd	r25, Y+9	; 0x09
    3774:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    3778:	dc 01       	movw	r26, r24
    377a:	cb 01       	movw	r24, r22
    377c:	8a 87       	std	Y+10, r24	; 0x0a
    377e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3780:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3782:	89 8d       	ldd	r24, Y+25	; 0x19
    3784:	18 2f       	mov	r17, r24
    3786:	1a 95       	dec	r17
    3788:	f1 f7       	brne	.-4      	; 0x3786 <ADC_Wait_8MHz+0x1cc>
    378a:	19 8f       	std	Y+25, r17	; 0x19

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    378c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    378e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3790:	29 81       	ldd	r18, Y+1	; 0x01
    3792:	fc 01       	movw	r30, r24
    3794:	24 83       	std	Z+4, r18	; 0x04
}
    3796:	6b 96       	adiw	r28, 0x1b	; 27
    3798:	cd bf       	out	0x3d, r28	; 61
    379a:	de bf       	out	0x3e, r29	; 62
    379c:	df 91       	pop	r29
    379e:	cf 91       	pop	r28
    37a0:	1f 91       	pop	r17
    37a2:	0f 91       	pop	r16
    37a4:	08 95       	ret

000037a6 <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    37a6:	0f 93       	push	r16
    37a8:	1f 93       	push	r17
    37aa:	cf 93       	push	r28
    37ac:	df 93       	push	r29
    37ae:	cd b7       	in	r28, 0x3d	; 61
    37b0:	de b7       	in	r29, 0x3e	; 62
    37b2:	6b 97       	sbiw	r28, 0x1b	; 27
    37b4:	cd bf       	out	0x3d, r28	; 61
    37b6:	de bf       	out	0x3e, r29	; 62
    37b8:	8a 8f       	std	Y+26, r24	; 0x1a
    37ba:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    37bc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    37be:	9b 8d       	ldd	r25, Y+27	; 0x1b
    37c0:	fc 01       	movw	r30, r24
    37c2:	84 81       	ldd	r24, Z+4	; 0x04
    37c4:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    37c6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    37c8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    37ca:	21 e0       	ldi	r18, 0x01	; 1
    37cc:	fc 01       	movw	r30, r24
    37ce:	24 83       	std	Z+4, r18	; 0x04
    37d0:	80 e0       	ldi	r24, 0x00	; 0
    37d2:	90 e0       	ldi	r25, 0x00	; 0
    37d4:	a0 e0       	ldi	r26, 0x00	; 0
    37d6:	b3 e4       	ldi	r27, 0x43	; 67
    37d8:	8a 83       	std	Y+2, r24	; 0x02
    37da:	9b 83       	std	Y+3, r25	; 0x03
    37dc:	ac 83       	std	Y+4, r26	; 0x04
    37de:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    37e0:	6a 81       	ldd	r22, Y+2	; 0x02
    37e2:	7b 81       	ldd	r23, Y+3	; 0x03
    37e4:	8c 81       	ldd	r24, Y+4	; 0x04
    37e6:	9d 81       	ldd	r25, Y+5	; 0x05
    37e8:	2b ea       	ldi	r18, 0xAB	; 171
    37ea:	3a ea       	ldi	r19, 0xAA	; 170
    37ec:	4a e2       	ldi	r20, 0x2A	; 42
    37ee:	5f e3       	ldi	r21, 0x3F	; 63
    37f0:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    37f4:	dc 01       	movw	r26, r24
    37f6:	cb 01       	movw	r24, r22
    37f8:	8e 83       	std	Y+6, r24	; 0x06
    37fa:	9f 83       	std	Y+7, r25	; 0x07
    37fc:	a8 87       	std	Y+8, r26	; 0x08
    37fe:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    3800:	11 e0       	ldi	r17, 0x01	; 1
    3802:	6e 81       	ldd	r22, Y+6	; 0x06
    3804:	7f 81       	ldd	r23, Y+7	; 0x07
    3806:	88 85       	ldd	r24, Y+8	; 0x08
    3808:	99 85       	ldd	r25, Y+9	; 0x09
    380a:	20 e0       	ldi	r18, 0x00	; 0
    380c:	30 e0       	ldi	r19, 0x00	; 0
    380e:	40 e8       	ldi	r20, 0x80	; 128
    3810:	5f e3       	ldi	r21, 0x3F	; 63
    3812:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    3816:	88 23       	and	r24, r24
    3818:	0c f0       	brlt	.+2      	; 0x381c <ADC_Wait_32MHz+0x76>
    381a:	10 e0       	ldi	r17, 0x00	; 0
    381c:	11 23       	and	r17, r17
    381e:	19 f0       	breq	.+6      	; 0x3826 <ADC_Wait_32MHz+0x80>
		__ticks = 1;
    3820:	81 e0       	ldi	r24, 0x01	; 1
    3822:	8a 87       	std	Y+10, r24	; 0x0a
    3824:	a3 c0       	rjmp	.+326    	; 0x396c <ADC_Wait_32MHz+0x1c6>
	else if (__tmp > 255)
    3826:	11 e0       	ldi	r17, 0x01	; 1
    3828:	6e 81       	ldd	r22, Y+6	; 0x06
    382a:	7f 81       	ldd	r23, Y+7	; 0x07
    382c:	88 85       	ldd	r24, Y+8	; 0x08
    382e:	99 85       	ldd	r25, Y+9	; 0x09
    3830:	20 e0       	ldi	r18, 0x00	; 0
    3832:	30 e0       	ldi	r19, 0x00	; 0
    3834:	4f e7       	ldi	r20, 0x7F	; 127
    3836:	53 e4       	ldi	r21, 0x43	; 67
    3838:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    383c:	18 16       	cp	r1, r24
    383e:	0c f0       	brlt	.+2      	; 0x3842 <ADC_Wait_32MHz+0x9c>
    3840:	10 e0       	ldi	r17, 0x00	; 0
    3842:	11 23       	and	r17, r17
    3844:	09 f4       	brne	.+2      	; 0x3848 <ADC_Wait_32MHz+0xa2>
    3846:	89 c0       	rjmp	.+274    	; 0x395a <ADC_Wait_32MHz+0x1b4>
	{
		_delay_ms(__us / 1000.0);
    3848:	6a 81       	ldd	r22, Y+2	; 0x02
    384a:	7b 81       	ldd	r23, Y+3	; 0x03
    384c:	8c 81       	ldd	r24, Y+4	; 0x04
    384e:	9d 81       	ldd	r25, Y+5	; 0x05
    3850:	20 e0       	ldi	r18, 0x00	; 0
    3852:	30 e0       	ldi	r19, 0x00	; 0
    3854:	4a e7       	ldi	r20, 0x7A	; 122
    3856:	54 e4       	ldi	r21, 0x44	; 68
    3858:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
    385c:	dc 01       	movw	r26, r24
    385e:	cb 01       	movw	r24, r22
    3860:	8b 87       	std	Y+11, r24	; 0x0b
    3862:	9c 87       	std	Y+12, r25	; 0x0c
    3864:	ad 87       	std	Y+13, r26	; 0x0d
    3866:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3868:	6b 85       	ldd	r22, Y+11	; 0x0b
    386a:	7c 85       	ldd	r23, Y+12	; 0x0c
    386c:	8d 85       	ldd	r24, Y+13	; 0x0d
    386e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3870:	20 e0       	ldi	r18, 0x00	; 0
    3872:	30 e0       	ldi	r19, 0x00	; 0
    3874:	4a ef       	ldi	r20, 0xFA	; 250
    3876:	53 e4       	ldi	r21, 0x43	; 67
    3878:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    387c:	dc 01       	movw	r26, r24
    387e:	cb 01       	movw	r24, r22
    3880:	8f 87       	std	Y+15, r24	; 0x0f
    3882:	98 8b       	std	Y+16, r25	; 0x10
    3884:	a9 8b       	std	Y+17, r26	; 0x11
    3886:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    3888:	11 e0       	ldi	r17, 0x01	; 1
    388a:	6f 85       	ldd	r22, Y+15	; 0x0f
    388c:	78 89       	ldd	r23, Y+16	; 0x10
    388e:	89 89       	ldd	r24, Y+17	; 0x11
    3890:	9a 89       	ldd	r25, Y+18	; 0x12
    3892:	20 e0       	ldi	r18, 0x00	; 0
    3894:	30 e0       	ldi	r19, 0x00	; 0
    3896:	40 e8       	ldi	r20, 0x80	; 128
    3898:	5f e3       	ldi	r21, 0x3F	; 63
    389a:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    389e:	88 23       	and	r24, r24
    38a0:	0c f0       	brlt	.+2      	; 0x38a4 <ADC_Wait_32MHz+0xfe>
    38a2:	10 e0       	ldi	r17, 0x00	; 0
    38a4:	11 23       	and	r17, r17
    38a6:	29 f0       	breq	.+10     	; 0x38b2 <ADC_Wait_32MHz+0x10c>
		__ticks = 1;
    38a8:	81 e0       	ldi	r24, 0x01	; 1
    38aa:	90 e0       	ldi	r25, 0x00	; 0
    38ac:	8b 8b       	std	Y+19, r24	; 0x13
    38ae:	9c 8b       	std	Y+20, r25	; 0x14
    38b0:	46 c0       	rjmp	.+140    	; 0x393e <ADC_Wait_32MHz+0x198>
	else if (__tmp > 65535)
    38b2:	11 e0       	ldi	r17, 0x01	; 1
    38b4:	6f 85       	ldd	r22, Y+15	; 0x0f
    38b6:	78 89       	ldd	r23, Y+16	; 0x10
    38b8:	89 89       	ldd	r24, Y+17	; 0x11
    38ba:	9a 89       	ldd	r25, Y+18	; 0x12
    38bc:	20 e0       	ldi	r18, 0x00	; 0
    38be:	3f ef       	ldi	r19, 0xFF	; 255
    38c0:	4f e7       	ldi	r20, 0x7F	; 127
    38c2:	57 e4       	ldi	r21, 0x47	; 71
    38c4:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    38c8:	18 16       	cp	r1, r24
    38ca:	0c f0       	brlt	.+2      	; 0x38ce <ADC_Wait_32MHz+0x128>
    38cc:	10 e0       	ldi	r17, 0x00	; 0
    38ce:	11 23       	and	r17, r17
    38d0:	61 f1       	breq	.+88     	; 0x392a <ADC_Wait_32MHz+0x184>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    38d2:	6b 85       	ldd	r22, Y+11	; 0x0b
    38d4:	7c 85       	ldd	r23, Y+12	; 0x0c
    38d6:	8d 85       	ldd	r24, Y+13	; 0x0d
    38d8:	9e 85       	ldd	r25, Y+14	; 0x0e
    38da:	20 e0       	ldi	r18, 0x00	; 0
    38dc:	30 e0       	ldi	r19, 0x00	; 0
    38de:	40 e2       	ldi	r20, 0x20	; 32
    38e0:	51 e4       	ldi	r21, 0x41	; 65
    38e2:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    38e6:	dc 01       	movw	r26, r24
    38e8:	cb 01       	movw	r24, r22
    38ea:	bc 01       	movw	r22, r24
    38ec:	cd 01       	movw	r24, r26
    38ee:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    38f2:	dc 01       	movw	r26, r24
    38f4:	cb 01       	movw	r24, r22
    38f6:	8b 8b       	std	Y+19, r24	; 0x13
    38f8:	9c 8b       	std	Y+20, r25	; 0x14
    38fa:	12 c0       	rjmp	.+36     	; 0x3920 <ADC_Wait_32MHz+0x17a>
    38fc:	82 e3       	ldi	r24, 0x32	; 50
    38fe:	90 e0       	ldi	r25, 0x00	; 0
    3900:	8d 8b       	std	Y+21, r24	; 0x15
    3902:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3904:	8d 89       	ldd	r24, Y+21	; 0x15
    3906:	9e 89       	ldd	r25, Y+22	; 0x16
    3908:	8c 01       	movw	r16, r24
    390a:	c8 01       	movw	r24, r16
    390c:	01 97       	sbiw	r24, 0x01	; 1
    390e:	f1 f7       	brne	.-4      	; 0x390c <ADC_Wait_32MHz+0x166>
    3910:	8c 01       	movw	r16, r24
    3912:	0d 8b       	std	Y+21, r16	; 0x15
    3914:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3916:	8b 89       	ldd	r24, Y+19	; 0x13
    3918:	9c 89       	ldd	r25, Y+20	; 0x14
    391a:	01 97       	sbiw	r24, 0x01	; 1
    391c:	8b 8b       	std	Y+19, r24	; 0x13
    391e:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3920:	8b 89       	ldd	r24, Y+19	; 0x13
    3922:	9c 89       	ldd	r25, Y+20	; 0x14
    3924:	00 97       	sbiw	r24, 0x00	; 0
    3926:	51 f7       	brne	.-44     	; 0x38fc <ADC_Wait_32MHz+0x156>
    3928:	28 c0       	rjmp	.+80     	; 0x397a <ADC_Wait_32MHz+0x1d4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    392a:	6f 85       	ldd	r22, Y+15	; 0x0f
    392c:	78 89       	ldd	r23, Y+16	; 0x10
    392e:	89 89       	ldd	r24, Y+17	; 0x11
    3930:	9a 89       	ldd	r25, Y+18	; 0x12
    3932:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    3936:	dc 01       	movw	r26, r24
    3938:	cb 01       	movw	r24, r22
    393a:	8b 8b       	std	Y+19, r24	; 0x13
    393c:	9c 8b       	std	Y+20, r25	; 0x14
    393e:	8b 89       	ldd	r24, Y+19	; 0x13
    3940:	9c 89       	ldd	r25, Y+20	; 0x14
    3942:	8f 8b       	std	Y+23, r24	; 0x17
    3944:	98 8f       	std	Y+24, r25	; 0x18
    3946:	8f 89       	ldd	r24, Y+23	; 0x17
    3948:	98 8d       	ldd	r25, Y+24	; 0x18
    394a:	8c 01       	movw	r16, r24
    394c:	f8 01       	movw	r30, r16
    394e:	31 97       	sbiw	r30, 0x01	; 1
    3950:	f1 f7       	brne	.-4      	; 0x394e <ADC_Wait_32MHz+0x1a8>
    3952:	8f 01       	movw	r16, r30
    3954:	0f 8b       	std	Y+23, r16	; 0x17
    3956:	18 8f       	std	Y+24, r17	; 0x18
    3958:	10 c0       	rjmp	.+32     	; 0x397a <ADC_Wait_32MHz+0x1d4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    395a:	6e 81       	ldd	r22, Y+6	; 0x06
    395c:	7f 81       	ldd	r23, Y+7	; 0x07
    395e:	88 85       	ldd	r24, Y+8	; 0x08
    3960:	99 85       	ldd	r25, Y+9	; 0x09
    3962:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    3966:	dc 01       	movw	r26, r24
    3968:	cb 01       	movw	r24, r22
    396a:	8a 87       	std	Y+10, r24	; 0x0a
    396c:	8a 85       	ldd	r24, Y+10	; 0x0a
    396e:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3970:	89 8d       	ldd	r24, Y+25	; 0x19
    3972:	18 2f       	mov	r17, r24
    3974:	1a 95       	dec	r17
    3976:	f1 f7       	brne	.-4      	; 0x3974 <ADC_Wait_32MHz+0x1ce>
    3978:	19 8f       	std	Y+25, r17	; 0x19

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    397a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    397c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    397e:	29 81       	ldd	r18, Y+1	; 0x01
    3980:	fc 01       	movw	r30, r24
    3982:	24 83       	std	Z+4, r18	; 0x04
}
    3984:	6b 96       	adiw	r28, 0x1b	; 27
    3986:	cd bf       	out	0x3d, r28	; 61
    3988:	de bf       	out	0x3e, r29	; 62
    398a:	df 91       	pop	r29
    398c:	cf 91       	pop	r28
    398e:	1f 91       	pop	r17
    3990:	0f 91       	pop	r16
    3992:	08 95       	ret

00003994 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3994:	cf 93       	push	r28
    3996:	df 93       	push	r29
    3998:	cd b7       	in	r28, 0x3d	; 61
    399a:	de b7       	in	r29, 0x3e	; 62
    399c:	2a 97       	sbiw	r28, 0x0a	; 10
    399e:	cd bf       	out	0x3d, r28	; 61
    39a0:	de bf       	out	0x3e, r29	; 62
    39a2:	8e 83       	std	Y+6, r24	; 0x06
    39a4:	9f 83       	std	Y+7, r25	; 0x07
    39a6:	68 87       	std	Y+8, r22	; 0x08
    39a8:	79 87       	std	Y+9, r23	; 0x09
    39aa:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    39ac:	8a 85       	ldd	r24, Y+10	; 0x0a
    39ae:	88 23       	and	r24, r24
    39b0:	a9 f1       	breq	.+106    	; 0x3a1c <ADC_Offset_Get_Unsigned+0x88>
    {
      uint16_t offset=0;
    39b2:	19 82       	std	Y+1, r1	; 0x01
    39b4:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    39b6:	1b 82       	std	Y+3, r1	; 0x03
    39b8:	1c 82       	std	Y+4, r1	; 0x04
    39ba:	24 c0       	rjmp	.+72     	; 0x3a04 <ADC_Offset_Get_Unsigned+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    39bc:	88 85       	ldd	r24, Y+8	; 0x08
    39be:	99 85       	ldd	r25, Y+9	; 0x09
    39c0:	fc 01       	movw	r30, r24
    39c2:	80 81       	ld	r24, Z
    39c4:	28 2f       	mov	r18, r24
    39c6:	20 68       	ori	r18, 0x80	; 128
    39c8:	88 85       	ldd	r24, Y+8	; 0x08
    39ca:	99 85       	ldd	r25, Y+9	; 0x09
    39cc:	fc 01       	movw	r30, r24
    39ce:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    39d0:	88 85       	ldd	r24, Y+8	; 0x08
    39d2:	99 85       	ldd	r25, Y+9	; 0x09
    39d4:	fc 01       	movw	r30, r24
    39d6:	83 81       	ldd	r24, Z+3	; 0x03
    39d8:	88 2f       	mov	r24, r24
    39da:	90 e0       	ldi	r25, 0x00	; 0
    39dc:	81 70       	andi	r24, 0x01	; 1
    39de:	90 70       	andi	r25, 0x00	; 0
    39e0:	00 97       	sbiw	r24, 0x00	; 0
    39e2:	b1 f3       	breq	.-20     	; 0x39d0 <ADC_Offset_Get_Unsigned+0x3c>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    39e4:	88 85       	ldd	r24, Y+8	; 0x08
    39e6:	99 85       	ldd	r25, Y+9	; 0x09
    39e8:	60 e0       	ldi	r22, 0x00	; 0
    39ea:	0e 94 4f 1a 	call	0x349e	; 0x349e <ADC_ResultCh_GetWord_Unsigned>
    39ee:	29 81       	ldd	r18, Y+1	; 0x01
    39f0:	3a 81       	ldd	r19, Y+2	; 0x02
    39f2:	82 0f       	add	r24, r18
    39f4:	93 1f       	adc	r25, r19
    39f6:	89 83       	std	Y+1, r24	; 0x01
    39f8:	9a 83       	std	Y+2, r25	; 0x02
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    39fa:	8b 81       	ldd	r24, Y+3	; 0x03
    39fc:	9c 81       	ldd	r25, Y+4	; 0x04
    39fe:	01 96       	adiw	r24, 0x01	; 1
    3a00:	8b 83       	std	Y+3, r24	; 0x03
    3a02:	9c 83       	std	Y+4, r25	; 0x04
    3a04:	8b 81       	ldd	r24, Y+3	; 0x03
    3a06:	9c 81       	ldd	r25, Y+4	; 0x04
    3a08:	84 30       	cpi	r24, 0x04	; 4
    3a0a:	91 05       	cpc	r25, r1
    3a0c:	bc f2       	brlt	.-82     	; 0x39bc <ADC_Offset_Get_Unsigned+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    3a0e:	89 81       	ldd	r24, Y+1	; 0x01
    3a10:	9a 81       	ldd	r25, Y+2	; 0x02
    3a12:	96 95       	lsr	r25
    3a14:	87 95       	ror	r24
    3a16:	96 95       	lsr	r25
    3a18:	87 95       	ror	r24
    3a1a:	1b c0       	rjmp	.+54     	; 0x3a52 <ADC_Offset_Get_Unsigned+0xbe>
    }
    else
    {        
      uint8_t offset=0;
    3a1c:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3a1e:	88 85       	ldd	r24, Y+8	; 0x08
    3a20:	99 85       	ldd	r25, Y+9	; 0x09
    3a22:	fc 01       	movw	r30, r24
    3a24:	80 81       	ld	r24, Z
    3a26:	28 2f       	mov	r18, r24
    3a28:	20 68       	ori	r18, 0x80	; 128
    3a2a:	88 85       	ldd	r24, Y+8	; 0x08
    3a2c:	99 85       	ldd	r25, Y+9	; 0x09
    3a2e:	fc 01       	movw	r30, r24
    3a30:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3a32:	88 85       	ldd	r24, Y+8	; 0x08
    3a34:	99 85       	ldd	r25, Y+9	; 0x09
    3a36:	fc 01       	movw	r30, r24
    3a38:	83 81       	ldd	r24, Z+3	; 0x03
    3a3a:	88 2f       	mov	r24, r24
    3a3c:	90 e0       	ldi	r25, 0x00	; 0
    3a3e:	81 70       	andi	r24, 0x01	; 1
    3a40:	90 70       	andi	r25, 0x00	; 0
    3a42:	00 97       	sbiw	r24, 0x00	; 0
    3a44:	b1 f3       	breq	.-20     	; 0x3a32 <ADC_Offset_Get_Unsigned+0x9e>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    3a46:	88 85       	ldd	r24, Y+8	; 0x08
    3a48:	99 85       	ldd	r25, Y+9	; 0x09
    3a4a:	0e 94 9a 1a 	call	0x3534	; 0x3534 <ADC_ResultCh_GetWord>
    3a4e:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3a50:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3a52:	2a 96       	adiw	r28, 0x0a	; 10
    3a54:	cd bf       	out	0x3d, r28	; 61
    3a56:	de bf       	out	0x3e, r29	; 62
    3a58:	df 91       	pop	r29
    3a5a:	cf 91       	pop	r28
    3a5c:	08 95       	ret

00003a5e <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3a5e:	cf 93       	push	r28
    3a60:	df 93       	push	r29
    3a62:	cd b7       	in	r28, 0x3d	; 61
    3a64:	de b7       	in	r29, 0x3e	; 62
    3a66:	2a 97       	sbiw	r28, 0x0a	; 10
    3a68:	cd bf       	out	0x3d, r28	; 61
    3a6a:	de bf       	out	0x3e, r29	; 62
    3a6c:	8e 83       	std	Y+6, r24	; 0x06
    3a6e:	9f 83       	std	Y+7, r25	; 0x07
    3a70:	68 87       	std	Y+8, r22	; 0x08
    3a72:	79 87       	std	Y+9, r23	; 0x09
    3a74:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3a76:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a78:	88 23       	and	r24, r24
    3a7a:	c1 f1       	breq	.+112    	; 0x3aec <ADC_Offset_Get_Signed+0x8e>
    {
      int16_t offset=0;
    3a7c:	19 82       	std	Y+1, r1	; 0x01
    3a7e:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3a80:	1b 82       	std	Y+3, r1	; 0x03
    3a82:	1c 82       	std	Y+4, r1	; 0x04
    3a84:	24 c0       	rjmp	.+72     	; 0x3ace <ADC_Offset_Get_Signed+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3a86:	88 85       	ldd	r24, Y+8	; 0x08
    3a88:	99 85       	ldd	r25, Y+9	; 0x09
    3a8a:	fc 01       	movw	r30, r24
    3a8c:	80 81       	ld	r24, Z
    3a8e:	28 2f       	mov	r18, r24
    3a90:	20 68       	ori	r18, 0x80	; 128
    3a92:	88 85       	ldd	r24, Y+8	; 0x08
    3a94:	99 85       	ldd	r25, Y+9	; 0x09
    3a96:	fc 01       	movw	r30, r24
    3a98:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3a9a:	88 85       	ldd	r24, Y+8	; 0x08
    3a9c:	99 85       	ldd	r25, Y+9	; 0x09
    3a9e:	fc 01       	movw	r30, r24
    3aa0:	83 81       	ldd	r24, Z+3	; 0x03
    3aa2:	88 2f       	mov	r24, r24
    3aa4:	90 e0       	ldi	r25, 0x00	; 0
    3aa6:	81 70       	andi	r24, 0x01	; 1
    3aa8:	90 70       	andi	r25, 0x00	; 0
    3aaa:	00 97       	sbiw	r24, 0x00	; 0
    3aac:	b1 f3       	breq	.-20     	; 0x3a9a <ADC_Offset_Get_Signed+0x3c>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3aae:	88 85       	ldd	r24, Y+8	; 0x08
    3ab0:	99 85       	ldd	r25, Y+9	; 0x09
    3ab2:	60 e0       	ldi	r22, 0x00	; 0
    3ab4:	0e 94 74 1a 	call	0x34e8	; 0x34e8 <ADC_ResultCh_GetWord_Signed>
    3ab8:	29 81       	ldd	r18, Y+1	; 0x01
    3aba:	3a 81       	ldd	r19, Y+2	; 0x02
    3abc:	82 0f       	add	r24, r18
    3abe:	93 1f       	adc	r25, r19
    3ac0:	89 83       	std	Y+1, r24	; 0x01
    3ac2:	9a 83       	std	Y+2, r25	; 0x02
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    3ac4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ac6:	9c 81       	ldd	r25, Y+4	; 0x04
    3ac8:	01 96       	adiw	r24, 0x01	; 1
    3aca:	8b 83       	std	Y+3, r24	; 0x03
    3acc:	9c 83       	std	Y+4, r25	; 0x04
    3ace:	8b 81       	ldd	r24, Y+3	; 0x03
    3ad0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ad2:	84 30       	cpi	r24, 0x04	; 4
    3ad4:	91 05       	cpc	r25, r1
    3ad6:	bc f2       	brlt	.-82     	; 0x3a86 <ADC_Offset_Get_Signed+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    3ad8:	89 81       	ldd	r24, Y+1	; 0x01
    3ada:	9a 81       	ldd	r25, Y+2	; 0x02
    3adc:	99 23       	and	r25, r25
    3ade:	0c f4       	brge	.+2      	; 0x3ae2 <ADC_Offset_Get_Signed+0x84>
    3ae0:	03 96       	adiw	r24, 0x03	; 3
    3ae2:	95 95       	asr	r25
    3ae4:	87 95       	ror	r24
    3ae6:	95 95       	asr	r25
    3ae8:	87 95       	ror	r24
    3aea:	1c c0       	rjmp	.+56     	; 0x3b24 <ADC_Offset_Get_Signed+0xc6>
    }
    else
    {        
      int8_t offset=0;
    3aec:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3aee:	88 85       	ldd	r24, Y+8	; 0x08
    3af0:	99 85       	ldd	r25, Y+9	; 0x09
    3af2:	fc 01       	movw	r30, r24
    3af4:	80 81       	ld	r24, Z
    3af6:	28 2f       	mov	r18, r24
    3af8:	20 68       	ori	r18, 0x80	; 128
    3afa:	88 85       	ldd	r24, Y+8	; 0x08
    3afc:	99 85       	ldd	r25, Y+9	; 0x09
    3afe:	fc 01       	movw	r30, r24
    3b00:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3b02:	88 85       	ldd	r24, Y+8	; 0x08
    3b04:	99 85       	ldd	r25, Y+9	; 0x09
    3b06:	fc 01       	movw	r30, r24
    3b08:	83 81       	ldd	r24, Z+3	; 0x03
    3b0a:	88 2f       	mov	r24, r24
    3b0c:	90 e0       	ldi	r25, 0x00	; 0
    3b0e:	81 70       	andi	r24, 0x01	; 1
    3b10:	90 70       	andi	r25, 0x00	; 0
    3b12:	00 97       	sbiw	r24, 0x00	; 0
    3b14:	b1 f3       	breq	.-20     	; 0x3b02 <ADC_Offset_Get_Signed+0xa4>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3b16:	88 85       	ldd	r24, Y+8	; 0x08
    3b18:	99 85       	ldd	r25, Y+9	; 0x09
    3b1a:	60 e0       	ldi	r22, 0x00	; 0
    3b1c:	0e 94 74 1a 	call	0x34e8	; 0x34e8 <ADC_ResultCh_GetWord_Signed>
    3b20:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3b22:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3b24:	2a 96       	adiw	r28, 0x0a	; 10
    3b26:	cd bf       	out	0x3d, r28	; 61
    3b28:	de bf       	out	0x3e, r29	; 62
    3b2a:	df 91       	pop	r29
    3b2c:	cf 91       	pop	r28
    3b2e:	08 95       	ret

00003b30 <SP_ReadCalibrationByte>:
 *  \param index The index to the calibration byte.
 *
 *  \return Calibration byte.
 */
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
    3b30:	1f 93       	push	r17
    3b32:	cf 93       	push	r28
    3b34:	df 93       	push	r29
    3b36:	cd b7       	in	r28, 0x3d	; 61
    3b38:	de b7       	in	r29, 0x3e	; 62
    3b3a:	25 97       	sbiw	r28, 0x05	; 5
    3b3c:	cd bf       	out	0x3d, r28	; 61
    3b3e:	de bf       	out	0x3e, r29	; 62
    3b40:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    3b42:	8a ec       	ldi	r24, 0xCA	; 202
    3b44:	91 e0       	ldi	r25, 0x01	; 1
    3b46:	22 e0       	ldi	r18, 0x02	; 2
    3b48:	fc 01       	movw	r30, r24
    3b4a:	20 83       	st	Z, r18
 	result = pgm_read_byte(index);
    3b4c:	8d 81       	ldd	r24, Y+5	; 0x05
    3b4e:	88 2f       	mov	r24, r24
    3b50:	90 e0       	ldi	r25, 0x00	; 0
    3b52:	89 83       	std	Y+1, r24	; 0x01
    3b54:	9a 83       	std	Y+2, r25	; 0x02
    3b56:	89 81       	ldd	r24, Y+1	; 0x01
    3b58:	9a 81       	ldd	r25, Y+2	; 0x02
    3b5a:	fc 01       	movw	r30, r24
    3b5c:	14 91       	lpm	r17, Z
    3b5e:	1b 83       	std	Y+3, r17	; 0x03
    3b60:	8b 81       	ldd	r24, Y+3	; 0x03
    3b62:	8c 83       	std	Y+4, r24	; 0x04

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    3b64:	8a ec       	ldi	r24, 0xCA	; 202
    3b66:	91 e0       	ldi	r25, 0x01	; 1
    3b68:	fc 01       	movw	r30, r24
    3b6a:	10 82       	st	Z, r1

	return result;
    3b6c:	8c 81       	ldd	r24, Y+4	; 0x04
}
    3b6e:	25 96       	adiw	r28, 0x05	; 5
    3b70:	cd bf       	out	0x3d, r28	; 61
    3b72:	de bf       	out	0x3e, r29	; 62
    3b74:	df 91       	pop	r29
    3b76:	cf 91       	pop	r28
    3b78:	1f 91       	pop	r17
    3b7a:	08 95       	ret

00003b7c <chb_init>:
/*!

*/
/**************************************************************************/
void chb_init()
{
    3b7c:	cf 93       	push	r28
    3b7e:	df 93       	push	r29
    3b80:	cd b7       	in	r28, 0x3d	; 61
    3b82:	de b7       	in	r29, 0x3e	; 62
    memset(&pcb, 0, sizeof(pcb_t));
    3b84:	24 e1       	ldi	r18, 0x14	; 20
    3b86:	80 e3       	ldi	r24, 0x30	; 48
    3b88:	91 e2       	ldi	r25, 0x21	; 33
    3b8a:	fc 01       	movw	r30, r24
    3b8c:	32 2f       	mov	r19, r18
    3b8e:	11 92       	st	Z+, r1
    3b90:	3a 95       	dec	r19
    3b92:	e9 f7       	brne	.-6      	; 0x3b8e <chb_init+0x12>
    pcb.src_addr = chb_get_short_addr();
    3b94:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <chb_get_short_addr>
    3b98:	80 93 30 21 	sts	0x2130, r24
    3b9c:	90 93 31 21 	sts	0x2131, r25
    chb_drvr_init();
    3ba0:	0e 94 76 2d 	call	0x5aec	; 0x5aec <chb_drvr_init>
	radio_msg_received_int_enable();
    3ba4:	0e 94 d7 1d 	call	0x3bae	; 0x3bae <radio_msg_received_int_enable>
}
    3ba8:	df 91       	pop	r29
    3baa:	cf 91       	pop	r28
    3bac:	08 95       	ret

00003bae <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
    3bae:	cf 93       	push	r28
    3bb0:	df 93       	push	r29
    3bb2:	cd b7       	in	r28, 0x3d	; 61
    3bb4:	de b7       	in	r29, 0x3e	; 62
	PORTE.DIRSET = PIN2_bm;
    3bb6:	80 e8       	ldi	r24, 0x80	; 128
    3bb8:	96 e0       	ldi	r25, 0x06	; 6
    3bba:	24 e0       	ldi	r18, 0x04	; 4
    3bbc:	fc 01       	movw	r30, r24
    3bbe:	21 83       	std	Z+1, r18	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    3bc0:	80 e8       	ldi	r24, 0x80	; 128
    3bc2:	96 e0       	ldi	r25, 0x06	; 6
    3bc4:	24 e0       	ldi	r18, 0x04	; 4
    3bc6:	fc 01       	movw	r30, r24
    3bc8:	26 83       	std	Z+6, r18	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    3bca:	80 e8       	ldi	r24, 0x80	; 128
    3bcc:	96 e0       	ldi	r25, 0x06	; 6
    3bce:	22 e0       	ldi	r18, 0x02	; 2
    3bd0:	fc 01       	movw	r30, r24
    3bd2:	20 8b       	std	Z+16, r18	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    3bd4:	80 e8       	ldi	r24, 0x80	; 128
    3bd6:	96 e0       	ldi	r25, 0x06	; 6
    3bd8:	24 e0       	ldi	r18, 0x04	; 4
    3bda:	fc 01       	movw	r30, r24
    3bdc:	22 87       	std	Z+10, r18	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    3bde:	80 e8       	ldi	r24, 0x80	; 128
    3be0:	96 e0       	ldi	r25, 0x06	; 6
    3be2:	23 e0       	ldi	r18, 0x03	; 3
    3be4:	fc 01       	movw	r30, r24
    3be6:	21 87       	std	Z+9, r18	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    3be8:	80 ea       	ldi	r24, 0xA0	; 160
    3bea:	90 e0       	ldi	r25, 0x00	; 0
    3bec:	20 ea       	ldi	r18, 0xA0	; 160
    3bee:	30 e0       	ldi	r19, 0x00	; 0
    3bf0:	f9 01       	movw	r30, r18
    3bf2:	22 81       	ldd	r18, Z+2	; 0x02
    3bf4:	24 60       	ori	r18, 0x04	; 4
    3bf6:	fc 01       	movw	r30, r24
    3bf8:	22 83       	std	Z+2, r18	; 0x02
	sei();
    3bfa:	78 94       	sei
}
    3bfc:	df 91       	pop	r29
    3bfe:	cf 91       	pop	r28
    3c00:	08 95       	ret

00003c02 <chb_get_pcb>:
/*!

*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    3c02:	cf 93       	push	r28
    3c04:	df 93       	push	r29
    3c06:	cd b7       	in	r28, 0x3d	; 61
    3c08:	de b7       	in	r29, 0x3e	; 62
    return &pcb;
    3c0a:	80 e3       	ldi	r24, 0x30	; 48
    3c0c:	91 e2       	ldi	r25, 0x21	; 33
}
    3c0e:	df 91       	pop	r29
    3c10:	cf 91       	pop	r28
    3c12:	08 95       	ret

00003c14 <chb_gen_hdr>:
    Requires the dest addr, location to store data, and len of payload.
    Returns the length of the hdr. 
*/
/**************************************************************************/
static U8 chb_gen_hdr(U8 *hdr, U16 addr, U8 len)
{
    3c14:	cf 93       	push	r28
    3c16:	df 93       	push	r29
    3c18:	cd b7       	in	r28, 0x3d	; 61
    3c1a:	de b7       	in	r29, 0x3e	; 62
    3c1c:	27 97       	sbiw	r28, 0x07	; 7
    3c1e:	cd bf       	out	0x3d, r28	; 61
    3c20:	de bf       	out	0x3e, r29	; 62
    3c22:	8b 83       	std	Y+3, r24	; 0x03
    3c24:	9c 83       	std	Y+4, r25	; 0x04
    3c26:	6d 83       	std	Y+5, r22	; 0x05
    3c28:	7e 83       	std	Y+6, r23	; 0x06
    3c2a:	4f 83       	std	Y+7, r20	; 0x07
    U8 *hdr_ptr = hdr;
    3c2c:	8b 81       	ldd	r24, Y+3	; 0x03
    3c2e:	9c 81       	ldd	r25, Y+4	; 0x04
    3c30:	89 83       	std	Y+1, r24	; 0x01
    3c32:	9a 83       	std	Y+2, r25	; 0x02

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    3c34:	8f 81       	ldd	r24, Y+7	; 0x07
    3c36:	28 2f       	mov	r18, r24
    3c38:	25 5f       	subi	r18, 0xF5	; 245
    3c3a:	89 81       	ldd	r24, Y+1	; 0x01
    3c3c:	9a 81       	ldd	r25, Y+2	; 0x02
    3c3e:	fc 01       	movw	r30, r24
    3c40:	20 83       	st	Z, r18
    3c42:	89 81       	ldd	r24, Y+1	; 0x01
    3c44:	9a 81       	ldd	r25, Y+2	; 0x02
    3c46:	01 96       	adiw	r24, 0x01	; 1
    3c48:	89 83       	std	Y+1, r24	; 0x01
    3c4a:	9a 83       	std	Y+2, r25	; 0x02

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    3c4c:	8d 81       	ldd	r24, Y+5	; 0x05
    3c4e:	9e 81       	ldd	r25, Y+6	; 0x06
    3c50:	ff ef       	ldi	r31, 0xFF	; 255
    3c52:	8f 3f       	cpi	r24, 0xFF	; 255
    3c54:	9f 07       	cpc	r25, r31
    3c56:	11 f0       	breq	.+4      	; 0x3c5c <chb_gen_hdr+0x48>
    3c58:	21 e6       	ldi	r18, 0x61	; 97
    3c5a:	01 c0       	rjmp	.+2      	; 0x3c5e <chb_gen_hdr+0x4a>
    3c5c:	21 e4       	ldi	r18, 0x41	; 65
    3c5e:	89 81       	ldd	r24, Y+1	; 0x01
    3c60:	9a 81       	ldd	r25, Y+2	; 0x02
    3c62:	fc 01       	movw	r30, r24
    3c64:	20 83       	st	Z, r18
    3c66:	89 81       	ldd	r24, Y+1	; 0x01
    3c68:	9a 81       	ldd	r25, Y+2	; 0x02
    3c6a:	01 96       	adiw	r24, 0x01	; 1
    3c6c:	89 83       	std	Y+1, r24	; 0x01
    3c6e:	9a 83       	std	Y+2, r25	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    3c70:	89 81       	ldd	r24, Y+1	; 0x01
    3c72:	9a 81       	ldd	r25, Y+2	; 0x02
    3c74:	28 e9       	ldi	r18, 0x98	; 152
    3c76:	fc 01       	movw	r30, r24
    3c78:	20 83       	st	Z, r18
    3c7a:	89 81       	ldd	r24, Y+1	; 0x01
    3c7c:	9a 81       	ldd	r25, Y+2	; 0x02
    3c7e:	01 96       	adiw	r24, 0x01	; 1
    3c80:	89 83       	std	Y+1, r24	; 0x01
    3c82:	9a 83       	std	Y+2, r25	; 0x02

    *hdr_ptr++ = pcb.seq++;
    3c84:	20 91 32 21 	lds	r18, 0x2132
    3c88:	89 81       	ldd	r24, Y+1	; 0x01
    3c8a:	9a 81       	ldd	r25, Y+2	; 0x02
    3c8c:	fc 01       	movw	r30, r24
    3c8e:	20 83       	st	Z, r18
    3c90:	89 81       	ldd	r24, Y+1	; 0x01
    3c92:	9a 81       	ldd	r25, Y+2	; 0x02
    3c94:	01 96       	adiw	r24, 0x01	; 1
    3c96:	89 83       	std	Y+1, r24	; 0x01
    3c98:	9a 83       	std	Y+2, r25	; 0x02
    3c9a:	82 2f       	mov	r24, r18
    3c9c:	8f 5f       	subi	r24, 0xFF	; 255
    3c9e:	80 93 32 21 	sts	0x2132, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    3ca2:	89 81       	ldd	r24, Y+1	; 0x01
    3ca4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ca6:	24 e3       	ldi	r18, 0x34	; 52
    3ca8:	32 e1       	ldi	r19, 0x12	; 18
    3caa:	fc 01       	movw	r30, r24
    3cac:	20 83       	st	Z, r18
    3cae:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3cb0:	89 81       	ldd	r24, Y+1	; 0x01
    3cb2:	9a 81       	ldd	r25, Y+2	; 0x02
    3cb4:	02 96       	adiw	r24, 0x02	; 2
    3cb6:	89 83       	std	Y+1, r24	; 0x01
    3cb8:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = addr;
    3cba:	89 81       	ldd	r24, Y+1	; 0x01
    3cbc:	9a 81       	ldd	r25, Y+2	; 0x02
    3cbe:	2d 81       	ldd	r18, Y+5	; 0x05
    3cc0:	3e 81       	ldd	r19, Y+6	; 0x06
    3cc2:	fc 01       	movw	r30, r24
    3cc4:	20 83       	st	Z, r18
    3cc6:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3cc8:	89 81       	ldd	r24, Y+1	; 0x01
    3cca:	9a 81       	ldd	r25, Y+2	; 0x02
    3ccc:	02 96       	adiw	r24, 0x02	; 2
    3cce:	89 83       	std	Y+1, r24	; 0x01
    3cd0:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = pcb.src_addr;
    3cd2:	20 91 30 21 	lds	r18, 0x2130
    3cd6:	30 91 31 21 	lds	r19, 0x2131
    3cda:	89 81       	ldd	r24, Y+1	; 0x01
    3cdc:	9a 81       	ldd	r25, Y+2	; 0x02
    3cde:	fc 01       	movw	r30, r24
    3ce0:	20 83       	st	Z, r18
    3ce2:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3ce4:	89 81       	ldd	r24, Y+1	; 0x01
    3ce6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ce8:	02 96       	adiw	r24, 0x02	; 2
    3cea:	89 83       	std	Y+1, r24	; 0x01
    3cec:	9a 83       	std	Y+2, r25	; 0x02
    
    // return the len of the header
    return hdr_ptr - hdr;
    3cee:	29 81       	ldd	r18, Y+1	; 0x01
    3cf0:	3a 81       	ldd	r19, Y+2	; 0x02
    3cf2:	8b 81       	ldd	r24, Y+3	; 0x03
    3cf4:	9c 81       	ldd	r25, Y+4	; 0x04
    3cf6:	a9 01       	movw	r20, r18
    3cf8:	48 1b       	sub	r20, r24
    3cfa:	59 0b       	sbc	r21, r25
    3cfc:	ca 01       	movw	r24, r20
}
    3cfe:	27 96       	adiw	r28, 0x07	; 7
    3d00:	cd bf       	out	0x3d, r28	; 61
    3d02:	de bf       	out	0x3e, r29	; 62
    3d04:	df 91       	pop	r29
    3d06:	cf 91       	pop	r28
    3d08:	08 95       	ret

00003d0a <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    3d0a:	ef 92       	push	r14
    3d0c:	ff 92       	push	r15
    3d0e:	0f 93       	push	r16
    3d10:	1f 93       	push	r17
    3d12:	cf 93       	push	r28
    3d14:	df 93       	push	r29
    3d16:	cd b7       	in	r28, 0x3d	; 61
    3d18:	de b7       	in	r29, 0x3e	; 62
    3d1a:	af 97       	sbiw	r28, 0x2f	; 47
    3d1c:	cd bf       	out	0x3d, r28	; 61
    3d1e:	de bf       	out	0x3e, r29	; 62
    3d20:	88 a7       	lds	r24, 0x78
    3d22:	99 a7       	lds	r25, 0x79
    3d24:	6a a7       	lds	r22, 0x7a
    3d26:	7b a7       	lds	r23, 0x7b
    3d28:	2c a7       	lds	r18, 0x7c
    3d2a:	3d a7       	lds	r19, 0x7d
    3d2c:	4e a7       	lds	r20, 0x7e
    3d2e:	5f a7       	lds	r21, 0x7f
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    3d30:	19 82       	std	Y+1, r1	; 0x01
    while (len > 0)
    3d32:	61 c1       	rjmp	.+706    	; 0x3ff6 <chb_write+0x2ec>
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    3d34:	8c a5       	lds	r24, 0x6c
    3d36:	9d a5       	lds	r25, 0x6d
    3d38:	ae a5       	lds	r26, 0x6e
    3d3a:	bf a5       	lds	r27, 0x6f
    3d3c:	85 36       	cpi	r24, 0x65	; 101
    3d3e:	91 05       	cpc	r25, r1
    3d40:	a1 05       	cpc	r26, r1
    3d42:	b1 05       	cpc	r27, r1
    3d44:	20 f0       	brcs	.+8      	; 0x3d4e <chb_write+0x44>
    3d46:	84 e6       	ldi	r24, 0x64	; 100
    3d48:	90 e0       	ldi	r25, 0x00	; 0
    3d4a:	a0 e0       	ldi	r26, 0x00	; 0
    3d4c:	b0 e0       	ldi	r27, 0x00	; 0
    3d4e:	8c 83       	std	Y+4, r24	; 0x04

        // gen frame header
        //hdr_len = chb_gen_hdr(hdr, addr, frm_len);
		chb_gen_hdr(hdr, addr, frm_len);
    3d50:	ce 01       	movw	r24, r28
    3d52:	4e 96       	adiw	r24, 0x1e	; 30
    3d54:	28 a5       	lds	r18, 0x68
    3d56:	39 a5       	lds	r19, 0x69
    3d58:	b9 01       	movw	r22, r18
    3d5a:	4c 81       	ldd	r20, Y+4	; 0x04
    3d5c:	0e 94 0a 1e 	call	0x3c14	; 0x3c14 <chb_gen_hdr>

        // send data to chip
		rtry = 0;
    3d60:	1a 82       	std	Y+2, r1	; 0x02
    3d62:	1b 82       	std	Y+3, r1	; 0x03
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    3d64:	89 81       	ldd	r24, Y+1	; 0x01
    3d66:	88 2f       	mov	r24, r24
    3d68:	90 e0       	ldi	r25, 0x00	; 0
    3d6a:	2a a5       	lds	r18, 0x6a
    3d6c:	3b a5       	lds	r19, 0x6b
    3d6e:	28 0f       	add	r18, r24
    3d70:	39 1f       	adc	r19, r25
    3d72:	ce 01       	movw	r24, r28
    3d74:	4e 96       	adiw	r24, 0x1e	; 30
    3d76:	b9 01       	movw	r22, r18
    3d78:	4c 81       	ldd	r20, Y+4	; 0x04
    3d7a:	0e 94 98 2b 	call	0x5730	; 0x5730 <chb_tx>
    3d7e:	8d 83       	std	Y+5, r24	; 0x05

             switch (status)
    3d80:	8d 81       	ldd	r24, Y+5	; 0x05
    3d82:	88 2f       	mov	r24, r24
    3d84:	90 e0       	ldi	r25, 0x00	; 0
    3d86:	83 30       	cpi	r24, 0x03	; 3
    3d88:	91 05       	cpc	r25, r1
    3d8a:	31 f1       	breq	.+76     	; 0x3dd8 <chb_write+0xce>
    3d8c:	84 30       	cpi	r24, 0x04	; 4
    3d8e:	91 05       	cpc	r25, r1
    3d90:	24 f4       	brge	.+8      	; 0x3d9a <chb_write+0x90>
    3d92:	81 30       	cpi	r24, 0x01	; 1
    3d94:	91 05       	cpc	r25, r1
    3d96:	39 f0       	breq	.+14     	; 0x3da6 <chb_write+0x9c>
    3d98:	2e c0       	rjmp	.+92     	; 0x3df6 <chb_write+0xec>
    3d9a:	85 30       	cpi	r24, 0x05	; 5
    3d9c:	91 05       	cpc	r25, r1
    3d9e:	69 f0       	breq	.+26     	; 0x3dba <chb_write+0xb0>
    3da0:	80 34       	cpi	r24, 0x40	; 64
    3da2:	91 05       	cpc	r25, r1
    3da4:	41 f5       	brne	.+80     	; 0x3df6 <chb_write+0xec>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    3da6:	80 91 37 21 	lds	r24, 0x2137
    3daa:	90 91 38 21 	lds	r25, 0x2138
    3dae:	01 96       	adiw	r24, 0x01	; 1
    3db0:	80 93 37 21 	sts	0x2137, r24
    3db4:	90 93 38 21 	sts	0x2138, r25
                 break;
    3db8:	1f c0       	rjmp	.+62     	; 0x3df8 <chb_write+0xee>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    3dba:	80 91 39 21 	lds	r24, 0x2139
    3dbe:	90 91 3a 21 	lds	r25, 0x213A
    3dc2:	01 96       	adiw	r24, 0x01	; 1
    3dc4:	80 93 39 21 	sts	0x2139, r24
    3dc8:	90 93 3a 21 	sts	0x213A, r25
				 rtry++;
    3dcc:	8a 81       	ldd	r24, Y+2	; 0x02
    3dce:	9b 81       	ldd	r25, Y+3	; 0x03
    3dd0:	01 96       	adiw	r24, 0x01	; 1
    3dd2:	8a 83       	std	Y+2, r24	; 0x02
    3dd4:	9b 83       	std	Y+3, r25	; 0x03
                 break;
    3dd6:	10 c0       	rjmp	.+32     	; 0x3df8 <chb_write+0xee>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    3dd8:	80 91 3b 21 	lds	r24, 0x213B
    3ddc:	90 91 3c 21 	lds	r25, 0x213C
    3de0:	01 96       	adiw	r24, 0x01	; 1
    3de2:	80 93 3b 21 	sts	0x213B, r24
    3de6:	90 93 3c 21 	sts	0x213C, r25
				 rtry++;
    3dea:	8a 81       	ldd	r24, Y+2	; 0x02
    3dec:	9b 81       	ldd	r25, Y+3	; 0x03
    3dee:	01 96       	adiw	r24, 0x01	; 1
    3df0:	8a 83       	std	Y+2, r24	; 0x02
    3df2:	9b 83       	std	Y+3, r25	; 0x03
                 break;
    3df4:	01 c0       	rjmp	.+2      	; 0x3df8 <chb_write+0xee>
 
             default:
                 break;
    3df6:	00 00       	nop
             }
			if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
    3df8:	8a 81       	ldd	r24, Y+2	; 0x02
    3dfa:	9b 81       	ldd	r25, Y+3	; 0x03
    3dfc:	18 16       	cp	r1, r24
    3dfe:	19 06       	cpc	r1, r25
    3e00:	0c f0       	brlt	.+2      	; 0x3e04 <chb_write+0xfa>
    3e02:	d5 c0       	rjmp	.+426    	; 0x3fae <chb_write+0x2a4>
    3e04:	80 e0       	ldi	r24, 0x00	; 0
    3e06:	90 e0       	ldi	r25, 0x00	; 0
    3e08:	a0 e2       	ldi	r26, 0x20	; 32
    3e0a:	b1 e4       	ldi	r27, 0x41	; 65
    3e0c:	8e 83       	std	Y+6, r24	; 0x06
    3e0e:	9f 83       	std	Y+7, r25	; 0x07
    3e10:	a8 87       	std	Y+8, r26	; 0x08
    3e12:	b9 87       	std	Y+9, r27	; 0x09
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3e14:	6e 81       	ldd	r22, Y+6	; 0x06
    3e16:	7f 81       	ldd	r23, Y+7	; 0x07
    3e18:	88 85       	ldd	r24, Y+8	; 0x08
    3e1a:	99 85       	ldd	r25, Y+9	; 0x09
    3e1c:	2b ea       	ldi	r18, 0xAB	; 171
    3e1e:	3a ea       	ldi	r19, 0xAA	; 170
    3e20:	4a e2       	ldi	r20, 0x2A	; 42
    3e22:	51 e4       	ldi	r21, 0x41	; 65
    3e24:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    3e28:	dc 01       	movw	r26, r24
    3e2a:	cb 01       	movw	r24, r22
    3e2c:	8a 87       	std	Y+10, r24	; 0x0a
    3e2e:	9b 87       	std	Y+11, r25	; 0x0b
    3e30:	ac 87       	std	Y+12, r26	; 0x0c
    3e32:	bd 87       	std	Y+13, r27	; 0x0d
	if (__tmp < 1.0)
    3e34:	11 e0       	ldi	r17, 0x01	; 1
    3e36:	6a 85       	ldd	r22, Y+10	; 0x0a
    3e38:	7b 85       	ldd	r23, Y+11	; 0x0b
    3e3a:	8c 85       	ldd	r24, Y+12	; 0x0c
    3e3c:	9d 85       	ldd	r25, Y+13	; 0x0d
    3e3e:	20 e0       	ldi	r18, 0x00	; 0
    3e40:	30 e0       	ldi	r19, 0x00	; 0
    3e42:	40 e8       	ldi	r20, 0x80	; 128
    3e44:	5f e3       	ldi	r21, 0x3F	; 63
    3e46:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    3e4a:	88 23       	and	r24, r24
    3e4c:	0c f0       	brlt	.+2      	; 0x3e50 <chb_write+0x146>
    3e4e:	10 e0       	ldi	r17, 0x00	; 0
    3e50:	11 23       	and	r17, r17
    3e52:	19 f0       	breq	.+6      	; 0x3e5a <chb_write+0x150>
		__ticks = 1;
    3e54:	81 e0       	ldi	r24, 0x01	; 1
    3e56:	8e 87       	std	Y+14, r24	; 0x0e
    3e58:	a3 c0       	rjmp	.+326    	; 0x3fa0 <chb_write+0x296>
	else if (__tmp > 255)
    3e5a:	11 e0       	ldi	r17, 0x01	; 1
    3e5c:	6a 85       	ldd	r22, Y+10	; 0x0a
    3e5e:	7b 85       	ldd	r23, Y+11	; 0x0b
    3e60:	8c 85       	ldd	r24, Y+12	; 0x0c
    3e62:	9d 85       	ldd	r25, Y+13	; 0x0d
    3e64:	20 e0       	ldi	r18, 0x00	; 0
    3e66:	30 e0       	ldi	r19, 0x00	; 0
    3e68:	4f e7       	ldi	r20, 0x7F	; 127
    3e6a:	53 e4       	ldi	r21, 0x43	; 67
    3e6c:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    3e70:	18 16       	cp	r1, r24
    3e72:	0c f0       	brlt	.+2      	; 0x3e76 <chb_write+0x16c>
    3e74:	10 e0       	ldi	r17, 0x00	; 0
    3e76:	11 23       	and	r17, r17
    3e78:	09 f4       	brne	.+2      	; 0x3e7c <chb_write+0x172>
    3e7a:	89 c0       	rjmp	.+274    	; 0x3f8e <chb_write+0x284>
	{
		_delay_ms(__us / 1000.0);
    3e7c:	6e 81       	ldd	r22, Y+6	; 0x06
    3e7e:	7f 81       	ldd	r23, Y+7	; 0x07
    3e80:	88 85       	ldd	r24, Y+8	; 0x08
    3e82:	99 85       	ldd	r25, Y+9	; 0x09
    3e84:	20 e0       	ldi	r18, 0x00	; 0
    3e86:	30 e0       	ldi	r19, 0x00	; 0
    3e88:	4a e7       	ldi	r20, 0x7A	; 122
    3e8a:	54 e4       	ldi	r21, 0x44	; 68
    3e8c:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
    3e90:	dc 01       	movw	r26, r24
    3e92:	cb 01       	movw	r24, r22
    3e94:	8f 87       	std	Y+15, r24	; 0x0f
    3e96:	98 8b       	std	Y+16, r25	; 0x10
    3e98:	a9 8b       	std	Y+17, r26	; 0x11
    3e9a:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3e9c:	6f 85       	ldd	r22, Y+15	; 0x0f
    3e9e:	78 89       	ldd	r23, Y+16	; 0x10
    3ea0:	89 89       	ldd	r24, Y+17	; 0x11
    3ea2:	9a 89       	ldd	r25, Y+18	; 0x12
    3ea4:	20 e0       	ldi	r18, 0x00	; 0
    3ea6:	30 e0       	ldi	r19, 0x00	; 0
    3ea8:	4a ef       	ldi	r20, 0xFA	; 250
    3eaa:	55 e4       	ldi	r21, 0x45	; 69
    3eac:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    3eb0:	dc 01       	movw	r26, r24
    3eb2:	cb 01       	movw	r24, r22
    3eb4:	8b 8b       	std	Y+19, r24	; 0x13
    3eb6:	9c 8b       	std	Y+20, r25	; 0x14
    3eb8:	ad 8b       	std	Y+21, r26	; 0x15
    3eba:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    3ebc:	11 e0       	ldi	r17, 0x01	; 1
    3ebe:	6b 89       	ldd	r22, Y+19	; 0x13
    3ec0:	7c 89       	ldd	r23, Y+20	; 0x14
    3ec2:	8d 89       	ldd	r24, Y+21	; 0x15
    3ec4:	9e 89       	ldd	r25, Y+22	; 0x16
    3ec6:	20 e0       	ldi	r18, 0x00	; 0
    3ec8:	30 e0       	ldi	r19, 0x00	; 0
    3eca:	40 e8       	ldi	r20, 0x80	; 128
    3ecc:	5f e3       	ldi	r21, 0x3F	; 63
    3ece:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    3ed2:	88 23       	and	r24, r24
    3ed4:	0c f0       	brlt	.+2      	; 0x3ed8 <chb_write+0x1ce>
    3ed6:	10 e0       	ldi	r17, 0x00	; 0
    3ed8:	11 23       	and	r17, r17
    3eda:	29 f0       	breq	.+10     	; 0x3ee6 <chb_write+0x1dc>
		__ticks = 1;
    3edc:	81 e0       	ldi	r24, 0x01	; 1
    3ede:	90 e0       	ldi	r25, 0x00	; 0
    3ee0:	8f 8b       	std	Y+23, r24	; 0x17
    3ee2:	98 8f       	std	Y+24, r25	; 0x18
    3ee4:	46 c0       	rjmp	.+140    	; 0x3f72 <chb_write+0x268>
	else if (__tmp > 65535)
    3ee6:	11 e0       	ldi	r17, 0x01	; 1
    3ee8:	6b 89       	ldd	r22, Y+19	; 0x13
    3eea:	7c 89       	ldd	r23, Y+20	; 0x14
    3eec:	8d 89       	ldd	r24, Y+21	; 0x15
    3eee:	9e 89       	ldd	r25, Y+22	; 0x16
    3ef0:	20 e0       	ldi	r18, 0x00	; 0
    3ef2:	3f ef       	ldi	r19, 0xFF	; 255
    3ef4:	4f e7       	ldi	r20, 0x7F	; 127
    3ef6:	57 e4       	ldi	r21, 0x47	; 71
    3ef8:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    3efc:	18 16       	cp	r1, r24
    3efe:	0c f0       	brlt	.+2      	; 0x3f02 <chb_write+0x1f8>
    3f00:	10 e0       	ldi	r17, 0x00	; 0
    3f02:	11 23       	and	r17, r17
    3f04:	61 f1       	breq	.+88     	; 0x3f5e <chb_write+0x254>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3f06:	6f 85       	ldd	r22, Y+15	; 0x0f
    3f08:	78 89       	ldd	r23, Y+16	; 0x10
    3f0a:	89 89       	ldd	r24, Y+17	; 0x11
    3f0c:	9a 89       	ldd	r25, Y+18	; 0x12
    3f0e:	20 e0       	ldi	r18, 0x00	; 0
    3f10:	30 e0       	ldi	r19, 0x00	; 0
    3f12:	40 e2       	ldi	r20, 0x20	; 32
    3f14:	51 e4       	ldi	r21, 0x41	; 65
    3f16:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    3f1a:	dc 01       	movw	r26, r24
    3f1c:	cb 01       	movw	r24, r22
    3f1e:	bc 01       	movw	r22, r24
    3f20:	cd 01       	movw	r24, r26
    3f22:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    3f26:	dc 01       	movw	r26, r24
    3f28:	cb 01       	movw	r24, r22
    3f2a:	8f 8b       	std	Y+23, r24	; 0x17
    3f2c:	98 8f       	std	Y+24, r25	; 0x18
    3f2e:	12 c0       	rjmp	.+36     	; 0x3f54 <chb_write+0x24a>
    3f30:	80 e2       	ldi	r24, 0x20	; 32
    3f32:	93 e0       	ldi	r25, 0x03	; 3
    3f34:	89 8f       	std	Y+25, r24	; 0x19
    3f36:	9a 8f       	std	Y+26, r25	; 0x1a
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3f38:	89 8d       	ldd	r24, Y+25	; 0x19
    3f3a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3f3c:	8c 01       	movw	r16, r24
    3f3e:	c8 01       	movw	r24, r16
    3f40:	01 97       	sbiw	r24, 0x01	; 1
    3f42:	f1 f7       	brne	.-4      	; 0x3f40 <chb_write+0x236>
    3f44:	8c 01       	movw	r16, r24
    3f46:	09 8f       	std	Y+25, r16	; 0x19
    3f48:	1a 8f       	std	Y+26, r17	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3f4a:	8f 89       	ldd	r24, Y+23	; 0x17
    3f4c:	98 8d       	ldd	r25, Y+24	; 0x18
    3f4e:	01 97       	sbiw	r24, 0x01	; 1
    3f50:	8f 8b       	std	Y+23, r24	; 0x17
    3f52:	98 8f       	std	Y+24, r25	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3f54:	8f 89       	ldd	r24, Y+23	; 0x17
    3f56:	98 8d       	ldd	r25, Y+24	; 0x18
    3f58:	00 97       	sbiw	r24, 0x00	; 0
    3f5a:	51 f7       	brne	.-44     	; 0x3f30 <chb_write+0x226>
    3f5c:	28 c0       	rjmp	.+80     	; 0x3fae <chb_write+0x2a4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3f5e:	6b 89       	ldd	r22, Y+19	; 0x13
    3f60:	7c 89       	ldd	r23, Y+20	; 0x14
    3f62:	8d 89       	ldd	r24, Y+21	; 0x15
    3f64:	9e 89       	ldd	r25, Y+22	; 0x16
    3f66:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    3f6a:	dc 01       	movw	r26, r24
    3f6c:	cb 01       	movw	r24, r22
    3f6e:	8f 8b       	std	Y+23, r24	; 0x17
    3f70:	98 8f       	std	Y+24, r25	; 0x18
    3f72:	8f 89       	ldd	r24, Y+23	; 0x17
    3f74:	98 8d       	ldd	r25, Y+24	; 0x18
    3f76:	8b 8f       	std	Y+27, r24	; 0x1b
    3f78:	9c 8f       	std	Y+28, r25	; 0x1c
    3f7a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3f7c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3f7e:	8c 01       	movw	r16, r24
    3f80:	c8 01       	movw	r24, r16
    3f82:	01 97       	sbiw	r24, 0x01	; 1
    3f84:	f1 f7       	brne	.-4      	; 0x3f82 <chb_write+0x278>
    3f86:	8c 01       	movw	r16, r24
    3f88:	0b 8f       	std	Y+27, r16	; 0x1b
    3f8a:	1c 8f       	std	Y+28, r17	; 0x1c
    3f8c:	10 c0       	rjmp	.+32     	; 0x3fae <chb_write+0x2a4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3f8e:	6a 85       	ldd	r22, Y+10	; 0x0a
    3f90:	7b 85       	ldd	r23, Y+11	; 0x0b
    3f92:	8c 85       	ldd	r24, Y+12	; 0x0c
    3f94:	9d 85       	ldd	r25, Y+13	; 0x0d
    3f96:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    3f9a:	dc 01       	movw	r26, r24
    3f9c:	cb 01       	movw	r24, r22
    3f9e:	8e 87       	std	Y+14, r24	; 0x0e
    3fa0:	8e 85       	ldd	r24, Y+14	; 0x0e
    3fa2:	8d 8f       	std	Y+29, r24	; 0x1d
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3fa4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3fa6:	18 2f       	mov	r17, r24
    3fa8:	1a 95       	dec	r17
    3faa:	f1 f7       	brne	.-4      	; 0x3fa8 <chb_write+0x29e>
    3fac:	1d 8f       	std	Y+29, r17	; 0x1d
			if(rtry==20) return status;;		//after 20 tries give up on sending the message	
    3fae:	8a 81       	ldd	r24, Y+2	; 0x02
    3fb0:	9b 81       	ldd	r25, Y+3	; 0x03
    3fb2:	84 31       	cpi	r24, 0x14	; 20
    3fb4:	91 05       	cpc	r25, r1
    3fb6:	11 f4       	brne	.+4      	; 0x3fbc <chb_write+0x2b2>
    3fb8:	8d 81       	ldd	r24, Y+5	; 0x05
    3fba:	27 c0       	rjmp	.+78     	; 0x400a <chb_write+0x300>
		} while(status != CHB_SUCCESS);			
    3fbc:	8d 81       	ldd	r24, Y+5	; 0x05
    3fbe:	88 23       	and	r24, r24
    3fc0:	09 f0       	breq	.+2      	; 0x3fc4 <chb_write+0x2ba>
    3fc2:	d0 ce       	rjmp	.-608    	; 0x3d64 <chb_write+0x5a>
        // adjust len and restart
		frm_offset += frm_len;
    3fc4:	99 81       	ldd	r25, Y+1	; 0x01
    3fc6:	8c 81       	ldd	r24, Y+4	; 0x04
    3fc8:	89 0f       	add	r24, r25
    3fca:	89 83       	std	Y+1, r24	; 0x01
        len = len - frm_len;
    3fcc:	8c 81       	ldd	r24, Y+4	; 0x04
    3fce:	88 2f       	mov	r24, r24
    3fd0:	90 e0       	ldi	r25, 0x00	; 0
    3fd2:	a0 e0       	ldi	r26, 0x00	; 0
    3fd4:	b0 e0       	ldi	r27, 0x00	; 0
    3fd6:	2c a5       	lds	r18, 0x6c
    3fd8:	3d a5       	lds	r19, 0x6d
    3fda:	4e a5       	lds	r20, 0x6e
    3fdc:	5f a5       	lds	r21, 0x6f
    3fde:	79 01       	movw	r14, r18
    3fe0:	8a 01       	movw	r16, r20
    3fe2:	e8 1a       	sub	r14, r24
    3fe4:	f9 0a       	sbc	r15, r25
    3fe6:	0a 0b       	sbc	r16, r26
    3fe8:	1b 0b       	sbc	r17, r27
    3fea:	d8 01       	movw	r26, r16
    3fec:	c7 01       	movw	r24, r14
    3fee:	8c a7       	lds	r24, 0x7c
    3ff0:	9d a7       	lds	r25, 0x7d
    3ff2:	ae a7       	lds	r26, 0x7e
    3ff4:	bf a7       	lds	r27, 0x7f
    U8 status, frm_len, frm_offset, hdr[CHB_HDR_SZ + 1];
	//U8 hdr_len;
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    3ff6:	8c a5       	lds	r24, 0x6c
    3ff8:	9d a5       	lds	r25, 0x6d
    3ffa:	ae a5       	lds	r26, 0x6e
    3ffc:	bf a5       	lds	r27, 0x6f
    3ffe:	00 97       	sbiw	r24, 0x00	; 0
    4000:	a1 05       	cpc	r26, r1
    4002:	b1 05       	cpc	r27, r1
    4004:	09 f0       	breq	.+2      	; 0x4008 <chb_write+0x2fe>
    4006:	96 ce       	rjmp	.-724    	; 0x3d34 <chb_write+0x2a>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    4008:	80 e0       	ldi	r24, 0x00	; 0
}
    400a:	af 96       	adiw	r28, 0x2f	; 47
    400c:	cd bf       	out	0x3d, r28	; 61
    400e:	de bf       	out	0x3e, r29	; 62
    4010:	df 91       	pop	r29
    4012:	cf 91       	pop	r28
    4014:	1f 91       	pop	r17
    4016:	0f 91       	pop	r16
    4018:	ff 90       	pop	r15
    401a:	ef 90       	pop	r14
    401c:	08 95       	ret

0000401e <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    401e:	cf 93       	push	r28
    4020:	df 93       	push	r29
    4022:	cd b7       	in	r28, 0x3d	; 61
    4024:	de b7       	in	r29, 0x3e	; 62
    4026:	27 97       	sbiw	r28, 0x07	; 7
    4028:	cd bf       	out	0x3d, r28	; 61
    402a:	de bf       	out	0x3e, r29	; 62
    402c:	8e 83       	std	Y+6, r24	; 0x06
    402e:	9f 83       	std	Y+7, r25	; 0x07
    U8 i, len, seq, *data_ptr;

    data_ptr = rx->data;
    4030:	8e 81       	ldd	r24, Y+6	; 0x06
    4032:	9f 81       	ldd	r25, Y+7	; 0x07
    4034:	05 96       	adiw	r24, 0x05	; 5
    4036:	8a 83       	std	Y+2, r24	; 0x02
    4038:	9b 83       	std	Y+3, r25	; 0x03

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    403a:	0e 94 dc 20 	call	0x41b8	; 0x41b8 <chb_buf_read>
    403e:	8c 83       	std	Y+4, r24	; 0x04
    4040:	8c 81       	ldd	r24, Y+4	; 0x04
    4042:	88 23       	and	r24, r24
    4044:	14 f4       	brge	.+4      	; 0x404a <chb_read+0x2c>
    {
        return 0;
    4046:	80 e0       	ldi	r24, 0x00	; 0
    4048:	80 c0       	rjmp	.+256    	; 0x414a <chb_read+0x12c>
    }
    *data_ptr++ = len;
    404a:	8a 81       	ldd	r24, Y+2	; 0x02
    404c:	9b 81       	ldd	r25, Y+3	; 0x03
    404e:	2c 81       	ldd	r18, Y+4	; 0x04
    4050:	fc 01       	movw	r30, r24
    4052:	20 83       	st	Z, r18
    4054:	8a 81       	ldd	r24, Y+2	; 0x02
    4056:	9b 81       	ldd	r25, Y+3	; 0x03
    4058:	01 96       	adiw	r24, 0x01	; 1
    405a:	8a 83       	std	Y+2, r24	; 0x02
    405c:	9b 83       	std	Y+3, r25	; 0x03

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    405e:	19 82       	std	Y+1, r1	; 0x01
    4060:	0f c0       	rjmp	.+30     	; 0x4080 <chb_read+0x62>
    {
        *data_ptr++ = chb_buf_read();
    4062:	0e 94 dc 20 	call	0x41b8	; 0x41b8 <chb_buf_read>
    4066:	28 2f       	mov	r18, r24
    4068:	8a 81       	ldd	r24, Y+2	; 0x02
    406a:	9b 81       	ldd	r25, Y+3	; 0x03
    406c:	fc 01       	movw	r30, r24
    406e:	20 83       	st	Z, r18
    4070:	8a 81       	ldd	r24, Y+2	; 0x02
    4072:	9b 81       	ldd	r25, Y+3	; 0x03
    4074:	01 96       	adiw	r24, 0x01	; 1
    4076:	8a 83       	std	Y+2, r24	; 0x02
    4078:	9b 83       	std	Y+3, r25	; 0x03
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    407a:	89 81       	ldd	r24, Y+1	; 0x01
    407c:	8f 5f       	subi	r24, 0xFF	; 255
    407e:	89 83       	std	Y+1, r24	; 0x01
    4080:	99 81       	ldd	r25, Y+1	; 0x01
    4082:	8c 81       	ldd	r24, Y+4	; 0x04
    4084:	98 17       	cp	r25, r24
    4086:	68 f3       	brcs	.-38     	; 0x4062 <chb_read+0x44>
    // buffer as well to save resources.
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    4088:	8e 81       	ldd	r24, Y+6	; 0x06
    408a:	9f 81       	ldd	r25, Y+7	; 0x07
    408c:	08 96       	adiw	r24, 0x08	; 8
    408e:	8a 83       	std	Y+2, r24	; 0x02
    4090:	9b 83       	std	Y+3, r25	; 0x03
    seq = *data_ptr;
    4092:	8a 81       	ldd	r24, Y+2	; 0x02
    4094:	9b 81       	ldd	r25, Y+3	; 0x03
    4096:	fc 01       	movw	r30, r24
    4098:	80 81       	ld	r24, Z
    409a:	8d 83       	std	Y+5, r24	; 0x05

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    409c:	8e 81       	ldd	r24, Y+6	; 0x06
    409e:	9f 81       	ldd	r25, Y+7	; 0x07
    40a0:	0b 96       	adiw	r24, 0x0b	; 11
    40a2:	8a 83       	std	Y+2, r24	; 0x02
    40a4:	9b 83       	std	Y+3, r25	; 0x03
    rx->dest_addr = *(U16 *)data_ptr;
    40a6:	8a 81       	ldd	r24, Y+2	; 0x02
    40a8:	9b 81       	ldd	r25, Y+3	; 0x03
    40aa:	fc 01       	movw	r30, r24
    40ac:	20 81       	ld	r18, Z
    40ae:	31 81       	ldd	r19, Z+1	; 0x01
    40b0:	8e 81       	ldd	r24, Y+6	; 0x06
    40b2:	9f 81       	ldd	r25, Y+7	; 0x07
    40b4:	fc 01       	movw	r30, r24
    40b6:	23 83       	std	Z+3, r18	; 0x03
    40b8:	34 83       	std	Z+4, r19	; 0x04
    data_ptr += sizeof(U16);
    40ba:	8a 81       	ldd	r24, Y+2	; 0x02
    40bc:	9b 81       	ldd	r25, Y+3	; 0x03
    40be:	02 96       	adiw	r24, 0x02	; 2
    40c0:	8a 83       	std	Y+2, r24	; 0x02
    40c2:	9b 83       	std	Y+3, r25	; 0x03
    rx->src_addr = *(U16 *)data_ptr;
    40c4:	8a 81       	ldd	r24, Y+2	; 0x02
    40c6:	9b 81       	ldd	r25, Y+3	; 0x03
    40c8:	fc 01       	movw	r30, r24
    40ca:	20 81       	ld	r18, Z
    40cc:	31 81       	ldd	r19, Z+1	; 0x01
    40ce:	8e 81       	ldd	r24, Y+6	; 0x06
    40d0:	9f 81       	ldd	r25, Y+7	; 0x07
    40d2:	fc 01       	movw	r30, r24
    40d4:	21 83       	std	Z+1, r18	; 0x01
    40d6:	32 83       	std	Z+2, r19	; 0x02
    data_ptr += sizeof(U16);
    40d8:	8a 81       	ldd	r24, Y+2	; 0x02
    40da:	9b 81       	ldd	r25, Y+3	; 0x03
    40dc:	02 96       	adiw	r24, 0x02	; 2
    40de:	8a 83       	std	Y+2, r24	; 0x02
    40e0:	9b 83       	std	Y+3, r25	; 0x03

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    40e2:	0e 94 00 21 	call	0x4200	; 0x4200 <chb_buf_get_len>
    40e6:	88 23       	and	r24, r24
    40e8:	11 f4       	brne	.+4      	; 0x40ee <chb_read+0xd0>
    {
        pcb.data_rcv = false;
    40ea:	10 92 33 21 	sts	0x2133, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    40ee:	80 91 06 20 	lds	r24, 0x2006
    40f2:	9d 81       	ldd	r25, Y+5	; 0x05
    40f4:	98 17       	cp	r25, r24
    40f6:	71 f4       	brne	.+28     	; 0x4114 <chb_read+0xf6>
    40f8:	8e 81       	ldd	r24, Y+6	; 0x06
    40fa:	9f 81       	ldd	r25, Y+7	; 0x07
    40fc:	fc 01       	movw	r30, r24
    40fe:	21 81       	ldd	r18, Z+1	; 0x01
    4100:	32 81       	ldd	r19, Z+2	; 0x02
    4102:	80 91 07 20 	lds	r24, 0x2007
    4106:	90 91 08 20 	lds	r25, 0x2008
    410a:	28 17       	cp	r18, r24
    410c:	39 07       	cpc	r19, r25
    410e:	11 f4       	brne	.+4      	; 0x4114 <chb_read+0xf6>
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    4110:	80 e0       	ldi	r24, 0x00	; 0
    4112:	1b c0       	rjmp	.+54     	; 0x414a <chb_read+0x12c>
    }
    else
    {
        prev_seq = seq;
    4114:	8d 81       	ldd	r24, Y+5	; 0x05
    4116:	80 93 06 20 	sts	0x2006, r24
        prev_src_addr = rx->src_addr;
    411a:	8e 81       	ldd	r24, Y+6	; 0x06
    411c:	9f 81       	ldd	r25, Y+7	; 0x07
    411e:	fc 01       	movw	r30, r24
    4120:	81 81       	ldd	r24, Z+1	; 0x01
    4122:	92 81       	ldd	r25, Z+2	; 0x02
    4124:	80 93 07 20 	sts	0x2007, r24
    4128:	90 93 08 20 	sts	0x2008, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    412c:	8c 81       	ldd	r24, Y+4	; 0x04
    412e:	88 2f       	mov	r24, r24
    4130:	90 e0       	ldi	r25, 0x00	; 0
    4132:	09 97       	sbiw	r24, 0x09	; 9
    4134:	9c 01       	movw	r18, r24
    4136:	8e 81       	ldd	r24, Y+6	; 0x06
    4138:	9f 81       	ldd	r25, Y+7	; 0x07
    413a:	4a 81       	ldd	r20, Y+2	; 0x02
    413c:	5b 81       	ldd	r21, Y+3	; 0x03
    413e:	ba 01       	movw	r22, r20
    4140:	a9 01       	movw	r20, r18
    4142:	0e 94 59 5c 	call	0xb8b2	; 0xb8b2 <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    4146:	8c 81       	ldd	r24, Y+4	; 0x04
    4148:	8b 50       	subi	r24, 0x0B	; 11
#endif
}
    414a:	27 96       	adiw	r28, 0x07	; 7
    414c:	cd bf       	out	0x3d, r28	; 61
    414e:	de bf       	out	0x3e, r29	; 62
    4150:	df 91       	pop	r29
    4152:	cf 91       	pop	r28
    4154:	08 95       	ret

00004156 <chb_buf_init>:
/*!

*/
/**************************************************************************/
void chb_buf_init()
{
    4156:	cf 93       	push	r28
    4158:	df 93       	push	r29
    415a:	cd b7       	in	r28, 0x3d	; 61
    415c:	de b7       	in	r29, 0x3e	; 62
    rd_ptr = 0;
    415e:	10 92 c4 21 	sts	0x21C4, r1
    wr_ptr = 0;
    4162:	10 92 c5 21 	sts	0x21C5, r1
    len = 0;
    4166:	10 92 c6 21 	sts	0x21C6, r1
}
    416a:	df 91       	pop	r29
    416c:	cf 91       	pop	r28
    416e:	08 95       	ret

00004170 <chb_buf_write>:
/*!

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    4170:	cf 93       	push	r28
    4172:	df 93       	push	r29
    4174:	0f 92       	push	r0
    4176:	cd b7       	in	r28, 0x3d	; 61
    4178:	de b7       	in	r29, 0x3e	; 62
    417a:	89 83       	std	Y+1, r24	; 0x01
    chb_buf[wr_ptr] = data;
    417c:	80 91 c5 21 	lds	r24, 0x21C5
    4180:	88 2f       	mov	r24, r24
    4182:	90 e0       	ldi	r25, 0x00	; 0
    4184:	8c 5b       	subi	r24, 0xBC	; 188
    4186:	9e 4d       	sbci	r25, 0xDE	; 222
    4188:	29 81       	ldd	r18, Y+1	; 0x01
    418a:	fc 01       	movw	r30, r24
    418c:	20 83       	st	Z, r18
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    418e:	80 91 c5 21 	lds	r24, 0x21C5
    4192:	88 2f       	mov	r24, r24
    4194:	90 e0       	ldi	r25, 0x00	; 0
    4196:	01 96       	adiw	r24, 0x01	; 1
    4198:	20 e8       	ldi	r18, 0x80	; 128
    419a:	30 e0       	ldi	r19, 0x00	; 0
    419c:	b9 01       	movw	r22, r18
    419e:	0e 94 d1 5b 	call	0xb7a2	; 0xb7a2 <__divmodhi4>
    41a2:	80 93 c5 21 	sts	0x21C5, r24
    len++;
    41a6:	80 91 c6 21 	lds	r24, 0x21C6
    41aa:	8f 5f       	subi	r24, 0xFF	; 255
    41ac:	80 93 c6 21 	sts	0x21C6, r24
}
    41b0:	0f 90       	pop	r0
    41b2:	df 91       	pop	r29
    41b4:	cf 91       	pop	r28
    41b6:	08 95       	ret

000041b8 <chb_buf_read>:
/*!

*/
/**************************************************************************/
U8 chb_buf_read()
{
    41b8:	cf 93       	push	r28
    41ba:	df 93       	push	r29
    41bc:	0f 92       	push	r0
    41be:	cd b7       	in	r28, 0x3d	; 61
    41c0:	de b7       	in	r29, 0x3e	; 62
    U8 data;

    data = chb_buf[rd_ptr];
    41c2:	80 91 c4 21 	lds	r24, 0x21C4
    41c6:	88 2f       	mov	r24, r24
    41c8:	90 e0       	ldi	r25, 0x00	; 0
    41ca:	8c 5b       	subi	r24, 0xBC	; 188
    41cc:	9e 4d       	sbci	r25, 0xDE	; 222
    41ce:	fc 01       	movw	r30, r24
    41d0:	80 81       	ld	r24, Z
    41d2:	89 83       	std	Y+1, r24	; 0x01
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    41d4:	80 91 c4 21 	lds	r24, 0x21C4
    41d8:	88 2f       	mov	r24, r24
    41da:	90 e0       	ldi	r25, 0x00	; 0
    41dc:	01 96       	adiw	r24, 0x01	; 1
    41de:	20 e8       	ldi	r18, 0x80	; 128
    41e0:	30 e0       	ldi	r19, 0x00	; 0
    41e2:	b9 01       	movw	r22, r18
    41e4:	0e 94 d1 5b 	call	0xb7a2	; 0xb7a2 <__divmodhi4>
    41e8:	80 93 c4 21 	sts	0x21C4, r24
    len--;
    41ec:	80 91 c6 21 	lds	r24, 0x21C6
    41f0:	81 50       	subi	r24, 0x01	; 1
    41f2:	80 93 c6 21 	sts	0x21C6, r24
    return data;
    41f6:	89 81       	ldd	r24, Y+1	; 0x01
}
    41f8:	0f 90       	pop	r0
    41fa:	df 91       	pop	r29
    41fc:	cf 91       	pop	r28
    41fe:	08 95       	ret

00004200 <chb_buf_get_len>:
/*!

*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    4200:	cf 93       	push	r28
    4202:	df 93       	push	r29
    4204:	cd b7       	in	r28, 0x3d	; 61
    4206:	de b7       	in	r29, 0x3e	; 62
    return len;
    4208:	80 91 c6 21 	lds	r24, 0x21C6
}
    420c:	df 91       	pop	r29
    420e:	cf 91       	pop	r28
    4210:	08 95       	ret

00004212 <chb_get_state>:
/*!

*/
/**************************************************************************/
static U8 chb_get_state()
{
    4212:	cf 93       	push	r28
    4214:	df 93       	push	r29
    4216:	cd b7       	in	r28, 0x3d	; 61
    4218:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATUS) & 0x1f;
    421a:	81 e0       	ldi	r24, 0x01	; 1
    421c:	0e 94 0d 23 	call	0x461a	; 0x461a <chb_reg_read>
    4220:	8f 71       	andi	r24, 0x1F	; 31
}
    4222:	df 91       	pop	r29
    4224:	cf 91       	pop	r28
    4226:	08 95       	ret

00004228 <chb_get_status>:
/*!

*/
/**************************************************************************/
static U8 chb_get_status()
{
    4228:	cf 93       	push	r28
    422a:	df 93       	push	r29
    422c:	cd b7       	in	r28, 0x3d	; 61
    422e:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    4230:	82 e0       	ldi	r24, 0x02	; 2
    4232:	0e 94 0d 23 	call	0x461a	; 0x461a <chb_reg_read>
    4236:	82 95       	swap	r24
    4238:	86 95       	lsr	r24
    423a:	87 70       	andi	r24, 0x07	; 7
}
    423c:	df 91       	pop	r29
    423e:	cf 91       	pop	r28
    4240:	08 95       	ret

00004242 <chb_reset>:
/*!

*/
/**************************************************************************/
void chb_reset()
{
    4242:	0f 93       	push	r16
    4244:	1f 93       	push	r17
    4246:	cf 93       	push	r28
    4248:	df 93       	push	r29
    424a:	cd b7       	in	r28, 0x3d	; 61
    424c:	de b7       	in	r29, 0x3e	; 62
    424e:	e0 97       	sbiw	r28, 0x30	; 48
    4250:	cd bf       	out	0x3d, r28	; 61
    4252:	de bf       	out	0x3e, r29	; 62
    CHB_RST_DISABLE();
    4254:	84 e6       	ldi	r24, 0x64	; 100
    4256:	96 e0       	ldi	r25, 0x06	; 6
    4258:	24 e6       	ldi	r18, 0x64	; 100
    425a:	36 e0       	ldi	r19, 0x06	; 6
    425c:	f9 01       	movw	r30, r18
    425e:	20 81       	ld	r18, Z
    4260:	21 60       	ori	r18, 0x01	; 1
    4262:	fc 01       	movw	r30, r24
    4264:	20 83       	st	Z, r18
    CHB_SLPTR_DISABLE();
    4266:	84 e6       	ldi	r24, 0x64	; 100
    4268:	96 e0       	ldi	r25, 0x06	; 6
    426a:	24 e6       	ldi	r18, 0x64	; 100
    426c:	36 e0       	ldi	r19, 0x06	; 6
    426e:	f9 01       	movw	r30, r18
    4270:	20 81       	ld	r18, Z
    4272:	2d 7f       	andi	r18, 0xFD	; 253
    4274:	fc 01       	movw	r30, r24
    4276:	20 83       	st	Z, r18
    4278:	80 e0       	ldi	r24, 0x00	; 0
    427a:	90 e0       	ldi	r25, 0x00	; 0
    427c:	ae eb       	ldi	r26, 0xBE	; 190
    427e:	b3 e4       	ldi	r27, 0x43	; 67
    4280:	89 83       	std	Y+1, r24	; 0x01
    4282:	9a 83       	std	Y+2, r25	; 0x02
    4284:	ab 83       	std	Y+3, r26	; 0x03
    4286:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4288:	69 81       	ldd	r22, Y+1	; 0x01
    428a:	7a 81       	ldd	r23, Y+2	; 0x02
    428c:	8b 81       	ldd	r24, Y+3	; 0x03
    428e:	9c 81       	ldd	r25, Y+4	; 0x04
    4290:	2b ea       	ldi	r18, 0xAB	; 171
    4292:	3a ea       	ldi	r19, 0xAA	; 170
    4294:	4a e2       	ldi	r20, 0x2A	; 42
    4296:	51 e4       	ldi	r21, 0x41	; 65
    4298:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    429c:	dc 01       	movw	r26, r24
    429e:	cb 01       	movw	r24, r22
    42a0:	8d 83       	std	Y+5, r24	; 0x05
    42a2:	9e 83       	std	Y+6, r25	; 0x06
    42a4:	af 83       	std	Y+7, r26	; 0x07
    42a6:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    42a8:	11 e0       	ldi	r17, 0x01	; 1
    42aa:	6d 81       	ldd	r22, Y+5	; 0x05
    42ac:	7e 81       	ldd	r23, Y+6	; 0x06
    42ae:	8f 81       	ldd	r24, Y+7	; 0x07
    42b0:	98 85       	ldd	r25, Y+8	; 0x08
    42b2:	20 e0       	ldi	r18, 0x00	; 0
    42b4:	30 e0       	ldi	r19, 0x00	; 0
    42b6:	40 e8       	ldi	r20, 0x80	; 128
    42b8:	5f e3       	ldi	r21, 0x3F	; 63
    42ba:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    42be:	88 23       	and	r24, r24
    42c0:	0c f0       	brlt	.+2      	; 0x42c4 <chb_reset+0x82>
    42c2:	10 e0       	ldi	r17, 0x00	; 0
    42c4:	11 23       	and	r17, r17
    42c6:	19 f0       	breq	.+6      	; 0x42ce <chb_reset+0x8c>
		__ticks = 1;
    42c8:	81 e0       	ldi	r24, 0x01	; 1
    42ca:	89 87       	std	Y+9, r24	; 0x09
    42cc:	a3 c0       	rjmp	.+326    	; 0x4414 <chb_reset+0x1d2>
	else if (__tmp > 255)
    42ce:	11 e0       	ldi	r17, 0x01	; 1
    42d0:	6d 81       	ldd	r22, Y+5	; 0x05
    42d2:	7e 81       	ldd	r23, Y+6	; 0x06
    42d4:	8f 81       	ldd	r24, Y+7	; 0x07
    42d6:	98 85       	ldd	r25, Y+8	; 0x08
    42d8:	20 e0       	ldi	r18, 0x00	; 0
    42da:	30 e0       	ldi	r19, 0x00	; 0
    42dc:	4f e7       	ldi	r20, 0x7F	; 127
    42de:	53 e4       	ldi	r21, 0x43	; 67
    42e0:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    42e4:	18 16       	cp	r1, r24
    42e6:	0c f0       	brlt	.+2      	; 0x42ea <chb_reset+0xa8>
    42e8:	10 e0       	ldi	r17, 0x00	; 0
    42ea:	11 23       	and	r17, r17
    42ec:	09 f4       	brne	.+2      	; 0x42f0 <chb_reset+0xae>
    42ee:	89 c0       	rjmp	.+274    	; 0x4402 <chb_reset+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    42f0:	69 81       	ldd	r22, Y+1	; 0x01
    42f2:	7a 81       	ldd	r23, Y+2	; 0x02
    42f4:	8b 81       	ldd	r24, Y+3	; 0x03
    42f6:	9c 81       	ldd	r25, Y+4	; 0x04
    42f8:	20 e0       	ldi	r18, 0x00	; 0
    42fa:	30 e0       	ldi	r19, 0x00	; 0
    42fc:	4a e7       	ldi	r20, 0x7A	; 122
    42fe:	54 e4       	ldi	r21, 0x44	; 68
    4300:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
    4304:	dc 01       	movw	r26, r24
    4306:	cb 01       	movw	r24, r22
    4308:	8a 87       	std	Y+10, r24	; 0x0a
    430a:	9b 87       	std	Y+11, r25	; 0x0b
    430c:	ac 87       	std	Y+12, r26	; 0x0c
    430e:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4310:	6a 85       	ldd	r22, Y+10	; 0x0a
    4312:	7b 85       	ldd	r23, Y+11	; 0x0b
    4314:	8c 85       	ldd	r24, Y+12	; 0x0c
    4316:	9d 85       	ldd	r25, Y+13	; 0x0d
    4318:	20 e0       	ldi	r18, 0x00	; 0
    431a:	30 e0       	ldi	r19, 0x00	; 0
    431c:	4a ef       	ldi	r20, 0xFA	; 250
    431e:	55 e4       	ldi	r21, 0x45	; 69
    4320:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    4324:	dc 01       	movw	r26, r24
    4326:	cb 01       	movw	r24, r22
    4328:	8e 87       	std	Y+14, r24	; 0x0e
    432a:	9f 87       	std	Y+15, r25	; 0x0f
    432c:	a8 8b       	std	Y+16, r26	; 0x10
    432e:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    4330:	11 e0       	ldi	r17, 0x01	; 1
    4332:	6e 85       	ldd	r22, Y+14	; 0x0e
    4334:	7f 85       	ldd	r23, Y+15	; 0x0f
    4336:	88 89       	ldd	r24, Y+16	; 0x10
    4338:	99 89       	ldd	r25, Y+17	; 0x11
    433a:	20 e0       	ldi	r18, 0x00	; 0
    433c:	30 e0       	ldi	r19, 0x00	; 0
    433e:	40 e8       	ldi	r20, 0x80	; 128
    4340:	5f e3       	ldi	r21, 0x3F	; 63
    4342:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    4346:	88 23       	and	r24, r24
    4348:	0c f0       	brlt	.+2      	; 0x434c <chb_reset+0x10a>
    434a:	10 e0       	ldi	r17, 0x00	; 0
    434c:	11 23       	and	r17, r17
    434e:	29 f0       	breq	.+10     	; 0x435a <chb_reset+0x118>
		__ticks = 1;
    4350:	81 e0       	ldi	r24, 0x01	; 1
    4352:	90 e0       	ldi	r25, 0x00	; 0
    4354:	8a 8b       	std	Y+18, r24	; 0x12
    4356:	9b 8b       	std	Y+19, r25	; 0x13
    4358:	46 c0       	rjmp	.+140    	; 0x43e6 <chb_reset+0x1a4>
	else if (__tmp > 65535)
    435a:	11 e0       	ldi	r17, 0x01	; 1
    435c:	6e 85       	ldd	r22, Y+14	; 0x0e
    435e:	7f 85       	ldd	r23, Y+15	; 0x0f
    4360:	88 89       	ldd	r24, Y+16	; 0x10
    4362:	99 89       	ldd	r25, Y+17	; 0x11
    4364:	20 e0       	ldi	r18, 0x00	; 0
    4366:	3f ef       	ldi	r19, 0xFF	; 255
    4368:	4f e7       	ldi	r20, 0x7F	; 127
    436a:	57 e4       	ldi	r21, 0x47	; 71
    436c:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    4370:	18 16       	cp	r1, r24
    4372:	0c f0       	brlt	.+2      	; 0x4376 <chb_reset+0x134>
    4374:	10 e0       	ldi	r17, 0x00	; 0
    4376:	11 23       	and	r17, r17
    4378:	61 f1       	breq	.+88     	; 0x43d2 <chb_reset+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    437a:	6a 85       	ldd	r22, Y+10	; 0x0a
    437c:	7b 85       	ldd	r23, Y+11	; 0x0b
    437e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4380:	9d 85       	ldd	r25, Y+13	; 0x0d
    4382:	20 e0       	ldi	r18, 0x00	; 0
    4384:	30 e0       	ldi	r19, 0x00	; 0
    4386:	40 e2       	ldi	r20, 0x20	; 32
    4388:	51 e4       	ldi	r21, 0x41	; 65
    438a:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    438e:	dc 01       	movw	r26, r24
    4390:	cb 01       	movw	r24, r22
    4392:	bc 01       	movw	r22, r24
    4394:	cd 01       	movw	r24, r26
    4396:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    439a:	dc 01       	movw	r26, r24
    439c:	cb 01       	movw	r24, r22
    439e:	8a 8b       	std	Y+18, r24	; 0x12
    43a0:	9b 8b       	std	Y+19, r25	; 0x13
    43a2:	12 c0       	rjmp	.+36     	; 0x43c8 <chb_reset+0x186>
    43a4:	80 e2       	ldi	r24, 0x20	; 32
    43a6:	93 e0       	ldi	r25, 0x03	; 3
    43a8:	8c 8b       	std	Y+20, r24	; 0x14
    43aa:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    43ac:	8c 89       	ldd	r24, Y+20	; 0x14
    43ae:	9d 89       	ldd	r25, Y+21	; 0x15
    43b0:	8c 01       	movw	r16, r24
    43b2:	c8 01       	movw	r24, r16
    43b4:	01 97       	sbiw	r24, 0x01	; 1
    43b6:	f1 f7       	brne	.-4      	; 0x43b4 <chb_reset+0x172>
    43b8:	8c 01       	movw	r16, r24
    43ba:	0c 8b       	std	Y+20, r16	; 0x14
    43bc:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    43be:	8a 89       	ldd	r24, Y+18	; 0x12
    43c0:	9b 89       	ldd	r25, Y+19	; 0x13
    43c2:	01 97       	sbiw	r24, 0x01	; 1
    43c4:	8a 8b       	std	Y+18, r24	; 0x12
    43c6:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    43c8:	8a 89       	ldd	r24, Y+18	; 0x12
    43ca:	9b 89       	ldd	r25, Y+19	; 0x13
    43cc:	00 97       	sbiw	r24, 0x00	; 0
    43ce:	51 f7       	brne	.-44     	; 0x43a4 <chb_reset+0x162>
    43d0:	28 c0       	rjmp	.+80     	; 0x4422 <chb_reset+0x1e0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    43d2:	6e 85       	ldd	r22, Y+14	; 0x0e
    43d4:	7f 85       	ldd	r23, Y+15	; 0x0f
    43d6:	88 89       	ldd	r24, Y+16	; 0x10
    43d8:	99 89       	ldd	r25, Y+17	; 0x11
    43da:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    43de:	dc 01       	movw	r26, r24
    43e0:	cb 01       	movw	r24, r22
    43e2:	8a 8b       	std	Y+18, r24	; 0x12
    43e4:	9b 8b       	std	Y+19, r25	; 0x13
    43e6:	8a 89       	ldd	r24, Y+18	; 0x12
    43e8:	9b 89       	ldd	r25, Y+19	; 0x13
    43ea:	8e 8b       	std	Y+22, r24	; 0x16
    43ec:	9f 8b       	std	Y+23, r25	; 0x17
    43ee:	8e 89       	ldd	r24, Y+22	; 0x16
    43f0:	9f 89       	ldd	r25, Y+23	; 0x17
    43f2:	8c 01       	movw	r16, r24
    43f4:	f8 01       	movw	r30, r16
    43f6:	31 97       	sbiw	r30, 0x01	; 1
    43f8:	f1 f7       	brne	.-4      	; 0x43f6 <chb_reset+0x1b4>
    43fa:	8f 01       	movw	r16, r30
    43fc:	0e 8b       	std	Y+22, r16	; 0x16
    43fe:	1f 8b       	std	Y+23, r17	; 0x17
    4400:	10 c0       	rjmp	.+32     	; 0x4422 <chb_reset+0x1e0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4402:	6d 81       	ldd	r22, Y+5	; 0x05
    4404:	7e 81       	ldd	r23, Y+6	; 0x06
    4406:	8f 81       	ldd	r24, Y+7	; 0x07
    4408:	98 85       	ldd	r25, Y+8	; 0x08
    440a:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    440e:	dc 01       	movw	r26, r24
    4410:	cb 01       	movw	r24, r22
    4412:	89 87       	std	Y+9, r24	; 0x09
    4414:	89 85       	ldd	r24, Y+9	; 0x09
    4416:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4418:	88 8d       	ldd	r24, Y+24	; 0x18
    441a:	18 2f       	mov	r17, r24
    441c:	1a 95       	dec	r17
    441e:	f1 f7       	brne	.-4      	; 0x441c <chb_reset+0x1da>
    4420:	18 8f       	std	Y+24, r17	; 0x18

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    4422:	84 e6       	ldi	r24, 0x64	; 100
    4424:	96 e0       	ldi	r25, 0x06	; 6
    4426:	24 e6       	ldi	r18, 0x64	; 100
    4428:	36 e0       	ldi	r19, 0x06	; 6
    442a:	f9 01       	movw	r30, r18
    442c:	20 81       	ld	r18, Z
    442e:	2e 7f       	andi	r18, 0xFE	; 254
    4430:	fc 01       	movw	r30, r24
    4432:	20 83       	st	Z, r18
    4434:	80 e0       	ldi	r24, 0x00	; 0
    4436:	90 e0       	ldi	r25, 0x00	; 0
    4438:	a0 e8       	ldi	r26, 0x80	; 128
    443a:	bf e3       	ldi	r27, 0x3F	; 63
    443c:	89 8f       	std	Y+25, r24	; 0x19
    443e:	9a 8f       	std	Y+26, r25	; 0x1a
    4440:	ab 8f       	std	Y+27, r26	; 0x1b
    4442:	bc 8f       	std	Y+28, r27	; 0x1c
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4444:	69 8d       	ldd	r22, Y+25	; 0x19
    4446:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4448:	8b 8d       	ldd	r24, Y+27	; 0x1b
    444a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    444c:	2b ea       	ldi	r18, 0xAB	; 171
    444e:	3a ea       	ldi	r19, 0xAA	; 170
    4450:	4a e2       	ldi	r20, 0x2A	; 42
    4452:	51 e4       	ldi	r21, 0x41	; 65
    4454:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    4458:	dc 01       	movw	r26, r24
    445a:	cb 01       	movw	r24, r22
    445c:	8d 8f       	std	Y+29, r24	; 0x1d
    445e:	9e 8f       	std	Y+30, r25	; 0x1e
    4460:	af 8f       	std	Y+31, r26	; 0x1f
    4462:	b8 a3       	lds	r27, 0x58
	if (__tmp < 1.0)
    4464:	11 e0       	ldi	r17, 0x01	; 1
    4466:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4468:	7e 8d       	ldd	r23, Y+30	; 0x1e
    446a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    446c:	98 a1       	lds	r25, 0x48
    446e:	20 e0       	ldi	r18, 0x00	; 0
    4470:	30 e0       	ldi	r19, 0x00	; 0
    4472:	40 e8       	ldi	r20, 0x80	; 128
    4474:	5f e3       	ldi	r21, 0x3F	; 63
    4476:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    447a:	88 23       	and	r24, r24
    447c:	0c f0       	brlt	.+2      	; 0x4480 <chb_reset+0x23e>
    447e:	10 e0       	ldi	r17, 0x00	; 0
    4480:	11 23       	and	r17, r17
    4482:	19 f0       	breq	.+6      	; 0x448a <chb_reset+0x248>
		__ticks = 1;
    4484:	81 e0       	ldi	r24, 0x01	; 1
    4486:	89 a3       	lds	r24, 0x59
    4488:	a3 c0       	rjmp	.+326    	; 0x45d0 <chb_reset+0x38e>
	else if (__tmp > 255)
    448a:	11 e0       	ldi	r17, 0x01	; 1
    448c:	6d 8d       	ldd	r22, Y+29	; 0x1d
    448e:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4490:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4492:	98 a1       	lds	r25, 0x48
    4494:	20 e0       	ldi	r18, 0x00	; 0
    4496:	30 e0       	ldi	r19, 0x00	; 0
    4498:	4f e7       	ldi	r20, 0x7F	; 127
    449a:	53 e4       	ldi	r21, 0x43	; 67
    449c:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    44a0:	18 16       	cp	r1, r24
    44a2:	0c f0       	brlt	.+2      	; 0x44a6 <chb_reset+0x264>
    44a4:	10 e0       	ldi	r17, 0x00	; 0
    44a6:	11 23       	and	r17, r17
    44a8:	09 f4       	brne	.+2      	; 0x44ac <chb_reset+0x26a>
    44aa:	89 c0       	rjmp	.+274    	; 0x45be <chb_reset+0x37c>
	{
		_delay_ms(__us / 1000.0);
    44ac:	69 8d       	ldd	r22, Y+25	; 0x19
    44ae:	7a 8d       	ldd	r23, Y+26	; 0x1a
    44b0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    44b2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    44b4:	20 e0       	ldi	r18, 0x00	; 0
    44b6:	30 e0       	ldi	r19, 0x00	; 0
    44b8:	4a e7       	ldi	r20, 0x7A	; 122
    44ba:	54 e4       	ldi	r21, 0x44	; 68
    44bc:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
    44c0:	dc 01       	movw	r26, r24
    44c2:	cb 01       	movw	r24, r22
    44c4:	8a a3       	lds	r24, 0x5a
    44c6:	9b a3       	lds	r25, 0x5b
    44c8:	ac a3       	lds	r26, 0x5c
    44ca:	bd a3       	lds	r27, 0x5d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    44cc:	6a a1       	lds	r22, 0x4a
    44ce:	7b a1       	lds	r23, 0x4b
    44d0:	8c a1       	lds	r24, 0x4c
    44d2:	9d a1       	lds	r25, 0x4d
    44d4:	20 e0       	ldi	r18, 0x00	; 0
    44d6:	30 e0       	ldi	r19, 0x00	; 0
    44d8:	4a ef       	ldi	r20, 0xFA	; 250
    44da:	55 e4       	ldi	r21, 0x45	; 69
    44dc:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    44e0:	dc 01       	movw	r26, r24
    44e2:	cb 01       	movw	r24, r22
    44e4:	8e a3       	lds	r24, 0x5e
    44e6:	9f a3       	lds	r25, 0x5f
    44e8:	a8 a7       	lds	r26, 0x78
    44ea:	b9 a7       	lds	r27, 0x79
	if (__tmp < 1.0)
    44ec:	11 e0       	ldi	r17, 0x01	; 1
    44ee:	6e a1       	lds	r22, 0x4e
    44f0:	7f a1       	lds	r23, 0x4f
    44f2:	88 a5       	lds	r24, 0x68
    44f4:	99 a5       	lds	r25, 0x69
    44f6:	20 e0       	ldi	r18, 0x00	; 0
    44f8:	30 e0       	ldi	r19, 0x00	; 0
    44fa:	40 e8       	ldi	r20, 0x80	; 128
    44fc:	5f e3       	ldi	r21, 0x3F	; 63
    44fe:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    4502:	88 23       	and	r24, r24
    4504:	0c f0       	brlt	.+2      	; 0x4508 <chb_reset+0x2c6>
    4506:	10 e0       	ldi	r17, 0x00	; 0
    4508:	11 23       	and	r17, r17
    450a:	29 f0       	breq	.+10     	; 0x4516 <chb_reset+0x2d4>
		__ticks = 1;
    450c:	81 e0       	ldi	r24, 0x01	; 1
    450e:	90 e0       	ldi	r25, 0x00	; 0
    4510:	8a a7       	lds	r24, 0x7a
    4512:	9b a7       	lds	r25, 0x7b
    4514:	46 c0       	rjmp	.+140    	; 0x45a2 <chb_reset+0x360>
	else if (__tmp > 65535)
    4516:	11 e0       	ldi	r17, 0x01	; 1
    4518:	6e a1       	lds	r22, 0x4e
    451a:	7f a1       	lds	r23, 0x4f
    451c:	88 a5       	lds	r24, 0x68
    451e:	99 a5       	lds	r25, 0x69
    4520:	20 e0       	ldi	r18, 0x00	; 0
    4522:	3f ef       	ldi	r19, 0xFF	; 255
    4524:	4f e7       	ldi	r20, 0x7F	; 127
    4526:	57 e4       	ldi	r21, 0x47	; 71
    4528:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    452c:	18 16       	cp	r1, r24
    452e:	0c f0       	brlt	.+2      	; 0x4532 <chb_reset+0x2f0>
    4530:	10 e0       	ldi	r17, 0x00	; 0
    4532:	11 23       	and	r17, r17
    4534:	61 f1       	breq	.+88     	; 0x458e <chb_reset+0x34c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4536:	6a a1       	lds	r22, 0x4a
    4538:	7b a1       	lds	r23, 0x4b
    453a:	8c a1       	lds	r24, 0x4c
    453c:	9d a1       	lds	r25, 0x4d
    453e:	20 e0       	ldi	r18, 0x00	; 0
    4540:	30 e0       	ldi	r19, 0x00	; 0
    4542:	40 e2       	ldi	r20, 0x20	; 32
    4544:	51 e4       	ldi	r21, 0x41	; 65
    4546:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    454a:	dc 01       	movw	r26, r24
    454c:	cb 01       	movw	r24, r22
    454e:	bc 01       	movw	r22, r24
    4550:	cd 01       	movw	r24, r26
    4552:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    4556:	dc 01       	movw	r26, r24
    4558:	cb 01       	movw	r24, r22
    455a:	8a a7       	lds	r24, 0x7a
    455c:	9b a7       	lds	r25, 0x7b
    455e:	12 c0       	rjmp	.+36     	; 0x4584 <chb_reset+0x342>
    4560:	80 e2       	ldi	r24, 0x20	; 32
    4562:	93 e0       	ldi	r25, 0x03	; 3
    4564:	8c a7       	lds	r24, 0x7c
    4566:	9d a7       	lds	r25, 0x7d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4568:	8c a5       	lds	r24, 0x6c
    456a:	9d a5       	lds	r25, 0x6d
    456c:	8c 01       	movw	r16, r24
    456e:	c8 01       	movw	r24, r16
    4570:	01 97       	sbiw	r24, 0x01	; 1
    4572:	f1 f7       	brne	.-4      	; 0x4570 <chb_reset+0x32e>
    4574:	8c 01       	movw	r16, r24
    4576:	0c a7       	lds	r16, 0x7c
    4578:	1d a7       	lds	r17, 0x7d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    457a:	8a a5       	lds	r24, 0x6a
    457c:	9b a5       	lds	r25, 0x6b
    457e:	01 97       	sbiw	r24, 0x01	; 1
    4580:	8a a7       	lds	r24, 0x7a
    4582:	9b a7       	lds	r25, 0x7b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4584:	8a a5       	lds	r24, 0x6a
    4586:	9b a5       	lds	r25, 0x6b
    4588:	00 97       	sbiw	r24, 0x00	; 0
    458a:	51 f7       	brne	.-44     	; 0x4560 <chb_reset+0x31e>
    458c:	28 c0       	rjmp	.+80     	; 0x45de <chb_reset+0x39c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    458e:	6e a1       	lds	r22, 0x4e
    4590:	7f a1       	lds	r23, 0x4f
    4592:	88 a5       	lds	r24, 0x68
    4594:	99 a5       	lds	r25, 0x69
    4596:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    459a:	dc 01       	movw	r26, r24
    459c:	cb 01       	movw	r24, r22
    459e:	8a a7       	lds	r24, 0x7a
    45a0:	9b a7       	lds	r25, 0x7b
    45a2:	8a a5       	lds	r24, 0x6a
    45a4:	9b a5       	lds	r25, 0x6b
    45a6:	8e a7       	lds	r24, 0x7e
    45a8:	9f a7       	lds	r25, 0x7f
    45aa:	8e a5       	lds	r24, 0x6e
    45ac:	9f a5       	lds	r25, 0x6f
    45ae:	8c 01       	movw	r16, r24
    45b0:	f8 01       	movw	r30, r16
    45b2:	31 97       	sbiw	r30, 0x01	; 1
    45b4:	f1 f7       	brne	.-4      	; 0x45b2 <chb_reset+0x370>
    45b6:	8f 01       	movw	r16, r30
    45b8:	0e a7       	lds	r16, 0x7e
    45ba:	1f a7       	lds	r17, 0x7f
    45bc:	10 c0       	rjmp	.+32     	; 0x45de <chb_reset+0x39c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    45be:	6d 8d       	ldd	r22, Y+29	; 0x1d
    45c0:	7e 8d       	ldd	r23, Y+30	; 0x1e
    45c2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    45c4:	98 a1       	lds	r25, 0x48
    45c6:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    45ca:	dc 01       	movw	r26, r24
    45cc:	cb 01       	movw	r24, r22
    45ce:	89 a3       	lds	r24, 0x59
    45d0:	89 a1       	lds	r24, 0x49
    45d2:	88 ab       	sts	0x58, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    45d4:	88 a9       	sts	0x48, r24
    45d6:	18 2f       	mov	r17, r24
    45d8:	1a 95       	dec	r17
    45da:	f1 f7       	brne	.-4      	; 0x45d8 <chb_reset+0x396>
    45dc:	18 ab       	sts	0x58, r17
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    45de:	84 e6       	ldi	r24, 0x64	; 100
    45e0:	96 e0       	ldi	r25, 0x06	; 6
    45e2:	24 e6       	ldi	r18, 0x64	; 100
    45e4:	36 e0       	ldi	r19, 0x06	; 6
    45e6:	f9 01       	movw	r30, r18
    45e8:	20 81       	ld	r18, Z
    45ea:	21 60       	ori	r18, 0x01	; 1
    45ec:	fc 01       	movw	r30, r24
    45ee:	20 83       	st	Z, r18
    45f0:	01 c0       	rjmp	.+2      	; 0x45f4 <chb_reset+0x3b2>
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
        {
            break;
        }
    }
    45f2:	00 00       	nop
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    45f4:	8d e1       	ldi	r24, 0x1D	; 29
    45f6:	0e 94 0d 23 	call	0x461a	; 0x461a <chb_reg_read>
    45fa:	81 30       	cpi	r24, 0x01	; 1
    45fc:	d1 f7       	brne	.-12     	; 0x45f2 <chb_reset+0x3b0>
    45fe:	8c e1       	ldi	r24, 0x1C	; 28
    4600:	0e 94 0d 23 	call	0x461a	; 0x461a <chb_reg_read>
    4604:	87 30       	cpi	r24, 0x07	; 7
    4606:	a9 f7       	brne	.-22     	; 0x45f2 <chb_reset+0x3b0>
        {
            break;
    4608:	00 00       	nop
        }
    }
	

}
    460a:	e0 96       	adiw	r28, 0x30	; 48
    460c:	cd bf       	out	0x3d, r28	; 61
    460e:	de bf       	out	0x3e, r29	; 62
    4610:	df 91       	pop	r29
    4612:	cf 91       	pop	r28
    4614:	1f 91       	pop	r17
    4616:	0f 91       	pop	r16
    4618:	08 95       	ret

0000461a <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    461a:	cf 93       	push	r28
    461c:	df 93       	push	r29
    461e:	0f 92       	push	r0
    4620:	0f 92       	push	r0
    4622:	cd b7       	in	r28, 0x3d	; 61
    4624:	de b7       	in	r29, 0x3e	; 62
    4626:	8a 83       	std	Y+2, r24	; 0x02
    U8 val = 0;
    4628:	19 82       	std	Y+1, r1	; 0x01

    /* Add the register read command to the register address. */
    addr |= 0x80;
    462a:	8a 81       	ldd	r24, Y+2	; 0x02
    462c:	80 68       	ori	r24, 0x80	; 128
    462e:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    4630:	8f e3       	ldi	r24, 0x3F	; 63
    4632:	90 e0       	ldi	r25, 0x00	; 0
    4634:	fc 01       	movw	r30, r24
    4636:	80 81       	ld	r24, Z
    4638:	80 93 47 40 	sts	0x4047, r24
    463c:	f8 94       	cli
    RadioCS(TRUE);
    463e:	81 e0       	ldi	r24, 0x01	; 1
    4640:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    4644:	8a 81       	ldd	r24, Y+2	; 0x02
    4646:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <SPID_write>
    464a:	89 83       	std	Y+1, r24	; 0x01
    val = SPID_write(val);
    464c:	89 81       	ldd	r24, Y+1	; 0x01
    464e:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <SPID_write>
    4652:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    4654:	80 e0       	ldi	r24, 0x00	; 0
    4656:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <RadioCS>
    CHB_LEAVE_CRIT();
    465a:	8f e3       	ldi	r24, 0x3F	; 63
    465c:	90 e0       	ldi	r25, 0x00	; 0
    465e:	20 91 47 40 	lds	r18, 0x4047
    4662:	fc 01       	movw	r30, r24
    4664:	20 83       	st	Z, r18
    4666:	78 94       	sei

    return val;
    4668:	89 81       	ldd	r24, Y+1	; 0x01
}
    466a:	0f 90       	pop	r0
    466c:	0f 90       	pop	r0
    466e:	df 91       	pop	r29
    4670:	cf 91       	pop	r28
    4672:	08 95       	ret

00004674 <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    4674:	cf 93       	push	r28
    4676:	df 93       	push	r29
    4678:	00 d0       	rcall	.+0      	; 0x467a <chb_reg_read16+0x6>
    467a:	0f 92       	push	r0
    467c:	cd b7       	in	r28, 0x3d	; 61
    467e:	de b7       	in	r29, 0x3e	; 62
    4680:	8c 83       	std	Y+4, r24	; 0x04
    U8 i;
    U16 val = 0;
    4682:	1a 82       	std	Y+2, r1	; 0x02
    4684:	1b 82       	std	Y+3, r1	; 0x03

    for (i=0; i<2; i++)
    4686:	19 82       	std	Y+1, r1	; 0x01
    4688:	1d c0       	rjmp	.+58     	; 0x46c4 <chb_reg_read16+0x50>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    468a:	9c 81       	ldd	r25, Y+4	; 0x04
    468c:	89 81       	ldd	r24, Y+1	; 0x01
    468e:	89 0f       	add	r24, r25
    4690:	0e 94 0d 23 	call	0x461a	; 0x461a <chb_reg_read>
    4694:	88 2f       	mov	r24, r24
    4696:	90 e0       	ldi	r25, 0x00	; 0
    4698:	29 81       	ldd	r18, Y+1	; 0x01
    469a:	22 2f       	mov	r18, r18
    469c:	30 e0       	ldi	r19, 0x00	; 0
    469e:	22 0f       	add	r18, r18
    46a0:	33 1f       	adc	r19, r19
    46a2:	22 0f       	add	r18, r18
    46a4:	33 1f       	adc	r19, r19
    46a6:	22 0f       	add	r18, r18
    46a8:	33 1f       	adc	r19, r19
    46aa:	02 2e       	mov	r0, r18
    46ac:	02 c0       	rjmp	.+4      	; 0x46b2 <chb_reg_read16+0x3e>
    46ae:	88 0f       	add	r24, r24
    46b0:	99 1f       	adc	r25, r25
    46b2:	0a 94       	dec	r0
    46b4:	e2 f7       	brpl	.-8      	; 0x46ae <chb_reg_read16+0x3a>
    46b6:	98 2f       	mov	r25, r24
    46b8:	8c 81       	ldd	r24, Y+4	; 0x04
    46ba:	89 2b       	or	r24, r25
    46bc:	8c 83       	std	Y+4, r24	; 0x04
U16 chb_reg_read16(U8 addr)
{
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    46be:	89 81       	ldd	r24, Y+1	; 0x01
    46c0:	8f 5f       	subi	r24, 0xFF	; 255
    46c2:	89 83       	std	Y+1, r24	; 0x01
    46c4:	89 81       	ldd	r24, Y+1	; 0x01
    46c6:	82 30       	cpi	r24, 0x02	; 2
    46c8:	00 f3       	brcs	.-64     	; 0x468a <chb_reg_read16+0x16>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    }
    return val;
    46ca:	8a 81       	ldd	r24, Y+2	; 0x02
    46cc:	9b 81       	ldd	r25, Y+3	; 0x03
}
    46ce:	24 96       	adiw	r28, 0x04	; 4
    46d0:	cd bf       	out	0x3d, r28	; 61
    46d2:	de bf       	out	0x3e, r29	; 62
    46d4:	df 91       	pop	r29
    46d6:	cf 91       	pop	r28
    46d8:	08 95       	ret

000046da <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    46da:	cf 93       	push	r28
    46dc:	df 93       	push	r29
    46de:	0f 92       	push	r0
    46e0:	0f 92       	push	r0
    46e2:	cd b7       	in	r28, 0x3d	; 61
    46e4:	de b7       	in	r29, 0x3e	; 62
    46e6:	89 83       	std	Y+1, r24	; 0x01
    46e8:	6a 83       	std	Y+2, r22	; 0x02
    //U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;
    46ea:	89 81       	ldd	r24, Y+1	; 0x01
    46ec:	80 6c       	ori	r24, 0xC0	; 192
    46ee:	89 83       	std	Y+1, r24	; 0x01

    CHB_ENTER_CRIT();
    46f0:	8f e3       	ldi	r24, 0x3F	; 63
    46f2:	90 e0       	ldi	r25, 0x00	; 0
    46f4:	fc 01       	movw	r30, r24
    46f6:	80 81       	ld	r24, Z
    46f8:	80 93 47 40 	sts	0x4047, r24
    46fc:	f8 94       	cli
    RadioCS(TRUE);
    46fe:	81 e0       	ldi	r24, 0x01	; 1
    4700:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <RadioCS>

    /*Send Register address and write register content.*/
    //dummy = SPID_write(addr);
	SPID_write(addr);
    4704:	89 81       	ldd	r24, Y+1	; 0x01
    4706:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <SPID_write>
    //dummy = SPID_write(val);
	SPID_write(val);
    470a:	8a 81       	ldd	r24, Y+2	; 0x02
    470c:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <SPID_write>

    RadioCS(FALSE);
    4710:	80 e0       	ldi	r24, 0x00	; 0
    4712:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <RadioCS>
    CHB_LEAVE_CRIT();
    4716:	8f e3       	ldi	r24, 0x3F	; 63
    4718:	90 e0       	ldi	r25, 0x00	; 0
    471a:	20 91 47 40 	lds	r18, 0x4047
    471e:	fc 01       	movw	r30, r24
    4720:	20 83       	st	Z, r18
    4722:	78 94       	sei
}
    4724:	0f 90       	pop	r0
    4726:	0f 90       	pop	r0
    4728:	df 91       	pop	r29
    472a:	cf 91       	pop	r28
    472c:	08 95       	ret

0000472e <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    472e:	cf 93       	push	r28
    4730:	df 93       	push	r29
    4732:	00 d0       	rcall	.+0      	; 0x4734 <chb_reg_write16+0x6>
    4734:	0f 92       	push	r0
    4736:	cd b7       	in	r28, 0x3d	; 61
    4738:	de b7       	in	r29, 0x3e	; 62
    473a:	8a 83       	std	Y+2, r24	; 0x02
    473c:	6b 83       	std	Y+3, r22	; 0x03
    473e:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<2; i++)
    4740:	19 82       	std	Y+1, r1	; 0x01
    4742:	1d c0       	rjmp	.+58     	; 0x477e <chb_reg_write16+0x50>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    4744:	9a 81       	ldd	r25, Y+2	; 0x02
    4746:	89 81       	ldd	r24, Y+1	; 0x01
    4748:	49 2f       	mov	r20, r25
    474a:	48 0f       	add	r20, r24
    474c:	89 81       	ldd	r24, Y+1	; 0x01
    474e:	88 2f       	mov	r24, r24
    4750:	90 e0       	ldi	r25, 0x00	; 0
    4752:	9c 01       	movw	r18, r24
    4754:	22 0f       	add	r18, r18
    4756:	33 1f       	adc	r19, r19
    4758:	22 0f       	add	r18, r18
    475a:	33 1f       	adc	r19, r19
    475c:	22 0f       	add	r18, r18
    475e:	33 1f       	adc	r19, r19
    4760:	8b 81       	ldd	r24, Y+3	; 0x03
    4762:	9c 81       	ldd	r25, Y+4	; 0x04
    4764:	02 c0       	rjmp	.+4      	; 0x476a <chb_reg_write16+0x3c>
    4766:	96 95       	lsr	r25
    4768:	87 95       	ror	r24
    476a:	2a 95       	dec	r18
    476c:	e2 f7       	brpl	.-8      	; 0x4766 <chb_reg_write16+0x38>
    476e:	98 2f       	mov	r25, r24
    4770:	84 2f       	mov	r24, r20
    4772:	69 2f       	mov	r22, r25
    4774:	0e 94 6d 23 	call	0x46da	; 0x46da <chb_reg_write>
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    U8 i;

    for (i=0; i<2; i++)
    4778:	89 81       	ldd	r24, Y+1	; 0x01
    477a:	8f 5f       	subi	r24, 0xFF	; 255
    477c:	89 83       	std	Y+1, r24	; 0x01
    477e:	89 81       	ldd	r24, Y+1	; 0x01
    4780:	82 30       	cpi	r24, 0x02	; 2
    4782:	00 f3       	brcs	.-64     	; 0x4744 <chb_reg_write16+0x16>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    }
}
    4784:	24 96       	adiw	r28, 0x04	; 4
    4786:	cd bf       	out	0x3d, r28	; 61
    4788:	de bf       	out	0x3e, r29	; 62
    478a:	df 91       	pop	r29
    478c:	cf 91       	pop	r28
    478e:	08 95       	ret

00004790 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    4790:	cf 93       	push	r28
    4792:	df 93       	push	r29
    4794:	00 d0       	rcall	.+0      	; 0x4796 <chb_reg_write64+0x6>
    4796:	0f 92       	push	r0
    4798:	cd b7       	in	r28, 0x3d	; 61
    479a:	de b7       	in	r29, 0x3e	; 62
    479c:	8a 83       	std	Y+2, r24	; 0x02
    479e:	6b 83       	std	Y+3, r22	; 0x03
    47a0:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<8; i++)
    47a2:	19 82       	std	Y+1, r1	; 0x01
    47a4:	14 c0       	rjmp	.+40     	; 0x47ce <chb_reg_write64+0x3e>
    {
        chb_reg_write(addr + i, *(val + i));
    47a6:	9a 81       	ldd	r25, Y+2	; 0x02
    47a8:	89 81       	ldd	r24, Y+1	; 0x01
    47aa:	49 2f       	mov	r20, r25
    47ac:	48 0f       	add	r20, r24
    47ae:	89 81       	ldd	r24, Y+1	; 0x01
    47b0:	88 2f       	mov	r24, r24
    47b2:	90 e0       	ldi	r25, 0x00	; 0
    47b4:	2b 81       	ldd	r18, Y+3	; 0x03
    47b6:	3c 81       	ldd	r19, Y+4	; 0x04
    47b8:	82 0f       	add	r24, r18
    47ba:	93 1f       	adc	r25, r19
    47bc:	fc 01       	movw	r30, r24
    47be:	90 81       	ld	r25, Z
    47c0:	84 2f       	mov	r24, r20
    47c2:	69 2f       	mov	r22, r25
    47c4:	0e 94 6d 23 	call	0x46da	; 0x46da <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    47c8:	89 81       	ldd	r24, Y+1	; 0x01
    47ca:	8f 5f       	subi	r24, 0xFF	; 255
    47cc:	89 83       	std	Y+1, r24	; 0x01
    47ce:	89 81       	ldd	r24, Y+1	; 0x01
    47d0:	88 30       	cpi	r24, 0x08	; 8
    47d2:	48 f3       	brcs	.-46     	; 0x47a6 <chb_reg_write64+0x16>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    47d4:	24 96       	adiw	r28, 0x04	; 4
    47d6:	cd bf       	out	0x3d, r28	; 61
    47d8:	de bf       	out	0x3e, r29	; 62
    47da:	df 91       	pop	r29
    47dc:	cf 91       	pop	r28
    47de:	08 95       	ret

000047e0 <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    47e0:	cf 93       	push	r28
    47e2:	df 93       	push	r29
    47e4:	00 d0       	rcall	.+0      	; 0x47e6 <chb_reg_read_mod_write+0x6>
    47e6:	0f 92       	push	r0
    47e8:	cd b7       	in	r28, 0x3d	; 61
    47ea:	de b7       	in	r29, 0x3e	; 62
    47ec:	8a 83       	std	Y+2, r24	; 0x02
    47ee:	6b 83       	std	Y+3, r22	; 0x03
    47f0:	4c 83       	std	Y+4, r20	; 0x04
    U8 tmp;

    tmp = chb_reg_read(addr);
    47f2:	8a 81       	ldd	r24, Y+2	; 0x02
    47f4:	0e 94 0d 23 	call	0x461a	; 0x461a <chb_reg_read>
    47f8:	89 83       	std	Y+1, r24	; 0x01
    val &= mask;                // mask off stray bits from val
    47fa:	9b 81       	ldd	r25, Y+3	; 0x03
    47fc:	8c 81       	ldd	r24, Y+4	; 0x04
    47fe:	89 23       	and	r24, r25
    4800:	8b 83       	std	Y+3, r24	; 0x03
    tmp &= ~mask;               // mask off bits in reg val
    4802:	8c 81       	ldd	r24, Y+4	; 0x04
    4804:	98 2f       	mov	r25, r24
    4806:	90 95       	com	r25
    4808:	89 81       	ldd	r24, Y+1	; 0x01
    480a:	89 23       	and	r24, r25
    480c:	89 83       	std	Y+1, r24	; 0x01
    tmp |= val;                 // copy val into reg val
    480e:	99 81       	ldd	r25, Y+1	; 0x01
    4810:	8b 81       	ldd	r24, Y+3	; 0x03
    4812:	89 2b       	or	r24, r25
    4814:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(addr, tmp);   // write back to reg
    4816:	8a 81       	ldd	r24, Y+2	; 0x02
    4818:	69 81       	ldd	r22, Y+1	; 0x01
    481a:	0e 94 6d 23 	call	0x46da	; 0x46da <chb_reg_write>
}
    481e:	24 96       	adiw	r28, 0x04	; 4
    4820:	cd bf       	out	0x3d, r28	; 61
    4822:	de bf       	out	0x3e, r29	; 62
    4824:	df 91       	pop	r29
    4826:	cf 91       	pop	r28
    4828:	08 95       	ret

0000482a <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    482a:	cf 93       	push	r28
    482c:	df 93       	push	r29
    482e:	cd b7       	in	r28, 0x3d	; 61
    4830:	de b7       	in	r29, 0x3e	; 62
    4832:	27 97       	sbiw	r28, 0x07	; 7
    4834:	cd bf       	out	0x3d, r28	; 61
    4836:	de bf       	out	0x3e, r29	; 62
    4838:	8a 83       	std	Y+2, r24	; 0x02
    483a:	9b 83       	std	Y+3, r25	; 0x03
    483c:	6c 83       	std	Y+4, r22	; 0x04
    483e:	4d 83       	std	Y+5, r20	; 0x05
    4840:	5e 83       	std	Y+6, r21	; 0x06
    4842:	2f 83       	std	Y+7, r18	; 0x07
    U8 i;
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    4844:	8c 81       	ldd	r24, Y+4	; 0x04
    4846:	28 2f       	mov	r18, r24
    4848:	30 e0       	ldi	r19, 0x00	; 0
    484a:	8f 81       	ldd	r24, Y+7	; 0x07
    484c:	88 2f       	mov	r24, r24
    484e:	90 e0       	ldi	r25, 0x00	; 0
    4850:	82 0f       	add	r24, r18
    4852:	93 1f       	adc	r25, r19
    4854:	80 38       	cpi	r24, 0x80	; 128
    4856:	91 05       	cpc	r25, r1
    4858:	0c f0       	brlt	.+2      	; 0x485c <chb_frame_write+0x32>
    485a:	42 c0       	rjmp	.+132    	; 0x48e0 <chb_frame_write+0xb6>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    485c:	8f e3       	ldi	r24, 0x3F	; 63
    485e:	90 e0       	ldi	r25, 0x00	; 0
    4860:	fc 01       	movw	r30, r24
    4862:	80 81       	ld	r24, Z
    4864:	80 93 47 40 	sts	0x4047, r24
    4868:	f8 94       	cli
    RadioCS(TRUE); 
    486a:	81 e0       	ldi	r24, 0x01	; 1
    486c:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <RadioCS>

    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);
    4870:	80 e6       	ldi	r24, 0x60	; 96
    4872:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4876:	19 82       	std	Y+1, r1	; 0x01
    4878:	0f c0       	rjmp	.+30     	; 0x4898 <chb_frame_write+0x6e>
    {
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    487a:	8a 81       	ldd	r24, Y+2	; 0x02
    487c:	9b 81       	ldd	r25, Y+3	; 0x03
    487e:	fc 01       	movw	r30, r24
    4880:	20 81       	ld	r18, Z
    4882:	8a 81       	ldd	r24, Y+2	; 0x02
    4884:	9b 81       	ldd	r25, Y+3	; 0x03
    4886:	01 96       	adiw	r24, 0x01	; 1
    4888:	8a 83       	std	Y+2, r24	; 0x02
    488a:	9b 83       	std	Y+3, r25	; 0x03
    488c:	82 2f       	mov	r24, r18
    488e:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <SPID_write>
    // send fifo write command
    //dummy = SPID_write(CHB_SPI_CMD_FW);
	SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4892:	89 81       	ldd	r24, Y+1	; 0x01
    4894:	8f 5f       	subi	r24, 0xFF	; 255
    4896:	89 83       	std	Y+1, r24	; 0x01
    4898:	99 81       	ldd	r25, Y+1	; 0x01
    489a:	8c 81       	ldd	r24, Y+4	; 0x04
    489c:	98 17       	cp	r25, r24
    489e:	68 f3       	brcs	.-38     	; 0x487a <chb_frame_write+0x50>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    48a0:	19 82       	std	Y+1, r1	; 0x01
    48a2:	0f c0       	rjmp	.+30     	; 0x48c2 <chb_frame_write+0x98>
    {
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    48a4:	8d 81       	ldd	r24, Y+5	; 0x05
    48a6:	9e 81       	ldd	r25, Y+6	; 0x06
    48a8:	fc 01       	movw	r30, r24
    48aa:	20 81       	ld	r18, Z
    48ac:	8d 81       	ldd	r24, Y+5	; 0x05
    48ae:	9e 81       	ldd	r25, Y+6	; 0x06
    48b0:	01 96       	adiw	r24, 0x01	; 1
    48b2:	8d 83       	std	Y+5, r24	; 0x05
    48b4:	9e 83       	std	Y+6, r25	; 0x06
    48b6:	82 2f       	mov	r24, r18
    48b8:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <SPID_write>
        //dummy = SPID_write(*hdr++);
		SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    48bc:	89 81       	ldd	r24, Y+1	; 0x01
    48be:	8f 5f       	subi	r24, 0xFF	; 255
    48c0:	89 83       	std	Y+1, r24	; 0x01
    48c2:	99 81       	ldd	r25, Y+1	; 0x01
    48c4:	8f 81       	ldd	r24, Y+7	; 0x07
    48c6:	98 17       	cp	r25, r24
    48c8:	68 f3       	brcs	.-38     	; 0x48a4 <chb_frame_write+0x7a>
        //dummy = SPID_write(*data++);
		SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    48ca:	80 e0       	ldi	r24, 0x00	; 0
    48cc:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <RadioCS>
    CHB_LEAVE_CRIT();
    48d0:	8f e3       	ldi	r24, 0x3F	; 63
    48d2:	90 e0       	ldi	r25, 0x00	; 0
    48d4:	20 91 47 40 	lds	r18, 0x4047
    48d8:	fc 01       	movw	r30, r24
    48da:	20 83       	st	Z, r18
    48dc:	78 94       	sei
    48de:	01 c0       	rjmp	.+2      	; 0x48e2 <chb_frame_write+0xb8>
	//U8 dummy;
	
    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    {
        return;
    48e0:	00 00       	nop
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    CHB_LEAVE_CRIT();
}
    48e2:	27 96       	adiw	r28, 0x07	; 7
    48e4:	cd bf       	out	0x3d, r28	; 61
    48e6:	de bf       	out	0x3e, r29	; 62
    48e8:	df 91       	pop	r29
    48ea:	cf 91       	pop	r28
    48ec:	08 95       	ret

000048ee <chb_frame_read>:
/*!

*/
/**************************************************************************/
static void chb_frame_read()
{
    48ee:	0f 93       	push	r16
    48f0:	1f 93       	push	r17
    48f2:	cf 93       	push	r28
    48f4:	df 93       	push	r29
    48f6:	cd b7       	in	r28, 0x3d	; 61
    48f8:	de b7       	in	r29, 0x3e	; 62
    48fa:	e7 97       	sbiw	r28, 0x37	; 55
    48fc:	cd bf       	out	0x3d, r28	; 61
    48fe:	de bf       	out	0x3e, r29	; 62
    U8 i, len, data;

    CHB_ENTER_CRIT();
    4900:	8f e3       	ldi	r24, 0x3F	; 63
    4902:	90 e0       	ldi	r25, 0x00	; 0
    4904:	fc 01       	movw	r30, r24
    4906:	80 81       	ld	r24, Z
    4908:	80 93 47 40 	sts	0x4047, r24
    490c:	f8 94       	cli
    RadioCS(TRUE);
    490e:	81 e0       	ldi	r24, 0x01	; 1
    4910:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    4914:	80 e2       	ldi	r24, 0x20	; 32
    4916:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <SPID_write>
    len = SPID_write(0);
    491a:	80 e0       	ldi	r24, 0x00	; 0
    491c:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <SPID_write>
    4920:	8a 83       	std	Y+2, r24	; 0x02

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    4922:	8a 81       	ldd	r24, Y+2	; 0x02
    4924:	83 30       	cpi	r24, 0x03	; 3
    4926:	08 f4       	brcc	.+2      	; 0x492a <chb_frame_read+0x3c>
    4928:	66 c0       	rjmp	.+204    	; 0x49f6 <chb_frame_read+0x108>
    492a:	8a 81       	ldd	r24, Y+2	; 0x02
    492c:	88 23       	and	r24, r24
    492e:	0c f4       	brge	.+2      	; 0x4932 <chb_frame_read+0x44>
    4930:	62 c0       	rjmp	.+196    	; 0x49f6 <chb_frame_read+0x108>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    4932:	8a 81       	ldd	r24, Y+2	; 0x02
    4934:	08 2f       	mov	r16, r24
    4936:	10 e0       	ldi	r17, 0x00	; 0
    4938:	0e 94 00 21 	call	0x4200	; 0x4200 <chb_buf_get_len>
    493c:	88 2f       	mov	r24, r24
    493e:	90 e0       	ldi	r25, 0x00	; 0
    4940:	20 e8       	ldi	r18, 0x80	; 128
    4942:	30 e0       	ldi	r19, 0x00	; 0
    4944:	a9 01       	movw	r20, r18
    4946:	48 1b       	sub	r20, r24
    4948:	59 0b       	sbc	r21, r25
    494a:	ca 01       	movw	r24, r20
    494c:	08 17       	cp	r16, r24
    494e:	19 07       	cpc	r17, r25
    4950:	f4 f4       	brge	.+60     	; 0x498e <chb_frame_read+0xa0>
        {
            chb_buf_write(len);
    4952:	8a 81       	ldd	r24, Y+2	; 0x02
    4954:	0e 94 b8 20 	call	0x4170	; 0x4170 <chb_buf_write>
            
            for (i=0; i<len; i++)
    4958:	19 82       	std	Y+1, r1	; 0x01
    495a:	0a c0       	rjmp	.+20     	; 0x4970 <chb_frame_read+0x82>
            {
                data = SPID_write(0);
    495c:	80 e0       	ldi	r24, 0x00	; 0
    495e:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <SPID_write>
    4962:	8b 83       	std	Y+3, r24	; 0x03
                chb_buf_write(data);
    4964:	8b 81       	ldd	r24, Y+3	; 0x03
    4966:	0e 94 b8 20 	call	0x4170	; 0x4170 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    496a:	89 81       	ldd	r24, Y+1	; 0x01
    496c:	8f 5f       	subi	r24, 0xFF	; 255
    496e:	89 83       	std	Y+1, r24	; 0x01
    4970:	99 81       	ldd	r25, Y+1	; 0x01
    4972:	8a 81       	ldd	r24, Y+2	; 0x02
    4974:	98 17       	cp	r25, r24
    4976:	90 f3       	brcs	.-28     	; 0x495c <chb_frame_read+0x6e>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    4978:	80 e8       	ldi	r24, 0x80	; 128
    497a:	96 e0       	ldi	r25, 0x06	; 6
    497c:	24 e0       	ldi	r18, 0x04	; 4
    497e:	fc 01       	movw	r30, r24
    4980:	25 83       	std	Z+5, r18	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    4982:	80 e8       	ldi	r24, 0x80	; 128
    4984:	96 e0       	ldi	r25, 0x06	; 6
    4986:	24 e0       	ldi	r18, 0x04	; 4
    4988:	fc 01       	movw	r30, r24
    498a:	26 83       	std	Z+6, r18	; 0x06
    498c:	34 c0       	rjmp	.+104    	; 0x49f6 <chb_frame_read+0x108>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    498e:	0e 94 01 1e 	call	0x3c02	; 0x3c02 <chb_get_pcb>
    4992:	8c 83       	std	Y+4, r24	; 0x04
    4994:	9d 83       	std	Y+5, r25	; 0x05
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4996:	19 82       	std	Y+1, r1	; 0x01
    4998:	07 c0       	rjmp	.+14     	; 0x49a8 <chb_frame_read+0xba>
            {
                data = SPID_write(0);
    499a:	80 e0       	ldi	r24, 0x00	; 0
    499c:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <SPID_write>
    49a0:	8b 83       	std	Y+3, r24	; 0x03
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    49a2:	89 81       	ldd	r24, Y+1	; 0x01
    49a4:	8f 5f       	subi	r24, 0xFF	; 255
    49a6:	89 83       	std	Y+1, r24	; 0x01
    49a8:	99 81       	ldd	r25, Y+1	; 0x01
    49aa:	8a 81       	ldd	r24, Y+2	; 0x02
    49ac:	98 17       	cp	r25, r24
    49ae:	a8 f3       	brcs	.-22     	; 0x499a <chb_frame_read+0xac>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    49b0:	8c 81       	ldd	r24, Y+4	; 0x04
    49b2:	9d 81       	ldd	r25, Y+5	; 0x05
    49b4:	fc 01       	movw	r30, r24
    49b6:	85 85       	ldd	r24, Z+13	; 0x0d
    49b8:	96 85       	ldd	r25, Z+14	; 0x0e
    49ba:	9c 01       	movw	r18, r24
    49bc:	2f 5f       	subi	r18, 0xFF	; 255
    49be:	3f 4f       	sbci	r19, 0xFF	; 255
    49c0:	8c 81       	ldd	r24, Y+4	; 0x04
    49c2:	9d 81       	ldd	r25, Y+5	; 0x05
    49c4:	fc 01       	movw	r30, r24
    49c6:	25 87       	std	Z+13, r18	; 0x0d
    49c8:	36 87       	std	Z+14, r19	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    49ca:	ce 01       	movw	r24, r28
    49cc:	06 96       	adiw	r24, 0x06	; 6
    49ce:	28 ee       	ldi	r18, 0xE8	; 232
    49d0:	31 e0       	ldi	r19, 0x01	; 1
    49d2:	b9 01       	movw	r22, r18
    49d4:	0e 94 52 5c 	call	0xb8a4	; 0xb8a4 <strcpy_P>
            printf(buf);
    49d8:	0f 92       	push	r0
    49da:	0f 92       	push	r0
    49dc:	8d b7       	in	r24, 0x3d	; 61
    49de:	9e b7       	in	r25, 0x3e	; 62
    49e0:	01 96       	adiw	r24, 0x01	; 1
    49e2:	9e 01       	movw	r18, r28
    49e4:	2a 5f       	subi	r18, 0xFA	; 250
    49e6:	3f 4f       	sbci	r19, 0xFF	; 255
    49e8:	fc 01       	movw	r30, r24
    49ea:	20 83       	st	Z, r18
    49ec:	31 83       	std	Z+1, r19	; 0x01
    49ee:	0e 94 a5 5c 	call	0xb94a	; 0xb94a <printf>
    49f2:	0f 90       	pop	r0
    49f4:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    49f6:	80 e0       	ldi	r24, 0x00	; 0
    49f8:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <RadioCS>
    CHB_LEAVE_CRIT();
    49fc:	8f e3       	ldi	r24, 0x3F	; 63
    49fe:	90 e0       	ldi	r25, 0x00	; 0
    4a00:	20 91 47 40 	lds	r18, 0x4047
    4a04:	fc 01       	movw	r30, r24
    4a06:	20 83       	st	Z, r18
    4a08:	78 94       	sei
}
    4a0a:	e7 96       	adiw	r28, 0x37	; 55
    4a0c:	cd bf       	out	0x3d, r28	; 61
    4a0e:	de bf       	out	0x3e, r29	; 62
    4a10:	df 91       	pop	r29
    4a12:	cf 91       	pop	r28
    4a14:	1f 91       	pop	r17
    4a16:	0f 91       	pop	r16
    4a18:	08 95       	ret

00004a1a <chb_set_mode>:
/*!
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    4a1a:	cf 93       	push	r28
    4a1c:	df 93       	push	r29
    4a1e:	0f 92       	push	r0
    4a20:	cd b7       	in	r28, 0x3d	; 61
    4a22:	de b7       	in	r29, 0x3e	; 62
    4a24:	89 83       	std	Y+1, r24	; 0x01
    switch (mode)
    4a26:	89 81       	ldd	r24, Y+1	; 0x01
    4a28:	88 2f       	mov	r24, r24
    4a2a:	90 e0       	ldi	r25, 0x00	; 0
    4a2c:	81 30       	cpi	r24, 0x01	; 1
    4a2e:	91 05       	cpc	r25, r1
    4a30:	c1 f0       	breq	.+48     	; 0x4a62 <chb_set_mode+0x48>
    4a32:	82 30       	cpi	r24, 0x02	; 2
    4a34:	91 05       	cpc	r25, r1
    4a36:	1c f4       	brge	.+6      	; 0x4a3e <chb_set_mode+0x24>
    4a38:	00 97       	sbiw	r24, 0x00	; 0
    4a3a:	41 f0       	breq	.+16     	; 0x4a4c <chb_set_mode+0x32>
    4a3c:	33 c0       	rjmp	.+102    	; 0x4aa4 <chb_set_mode+0x8a>
    4a3e:	82 30       	cpi	r24, 0x02	; 2
    4a40:	91 05       	cpc	r25, r1
    4a42:	d1 f0       	breq	.+52     	; 0x4a78 <chb_set_mode+0x5e>
    4a44:	83 30       	cpi	r24, 0x03	; 3
    4a46:	91 05       	cpc	r25, r1
    4a48:	11 f1       	breq	.+68     	; 0x4a8e <chb_set_mode+0x74>
    4a4a:	2c c0       	rjmp	.+88     	; 0x4aa4 <chb_set_mode+0x8a>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    4a4c:	8c e0       	ldi	r24, 0x0C	; 12
    4a4e:	68 e0       	ldi	r22, 0x08	; 8
    4a50:	4f e3       	ldi	r20, 0x3F	; 63
    4a52:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4a56:	86 e1       	ldi	r24, 0x16	; 22
    4a58:	62 e0       	ldi	r22, 0x02	; 2
    4a5a:	43 e0       	ldi	r20, 0x03	; 3
    4a5c:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>
        break;
    4a60:	21 c0       	rjmp	.+66     	; 0x4aa4 <chb_set_mode+0x8a>
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    4a62:	8c e0       	ldi	r24, 0x0C	; 12
    4a64:	6c e0       	ldi	r22, 0x0C	; 12
    4a66:	4f e3       	ldi	r20, 0x3F	; 63
    4a68:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4a6c:	86 e1       	ldi	r24, 0x16	; 22
    4a6e:	62 e0       	ldi	r22, 0x02	; 2
    4a70:	43 e0       	ldi	r20, 0x03	; 3
    4a72:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>
        break;
    4a76:	16 c0       	rjmp	.+44     	; 0x4aa4 <chb_set_mode+0x8a>
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    4a78:	8c e0       	ldi	r24, 0x0C	; 12
    4a7a:	6c e1       	ldi	r22, 0x1C	; 28
    4a7c:	4f e3       	ldi	r20, 0x3F	; 63
    4a7e:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4a82:	86 e1       	ldi	r24, 0x16	; 22
    4a84:	62 e0       	ldi	r22, 0x02	; 2
    4a86:	43 e0       	ldi	r20, 0x03	; 3
    4a88:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>
        break;
    4a8c:	0b c0       	rjmp	.+22     	; 0x4aa4 <chb_set_mode+0x8a>
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    4a8e:	8c e0       	ldi	r24, 0x0C	; 12
    4a90:	60 e0       	ldi	r22, 0x00	; 0
    4a92:	4f e3       	ldi	r20, 0x3F	; 63
    4a94:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    4a98:	86 e1       	ldi	r24, 0x16	; 22
    4a9a:	63 e0       	ldi	r22, 0x03	; 3
    4a9c:	43 e0       	ldi	r20, 0x03	; 3
    4a9e:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>
        break;
    4aa2:	00 00       	nop
    }
}
    4aa4:	0f 90       	pop	r0
    4aa6:	df 91       	pop	r29
    4aa8:	cf 91       	pop	r28
    4aaa:	08 95       	ret

00004aac <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    4aac:	0f 93       	push	r16
    4aae:	1f 93       	push	r17
    4ab0:	cf 93       	push	r28
    4ab2:	df 93       	push	r29
    4ab4:	cd b7       	in	r28, 0x3d	; 61
    4ab6:	de b7       	in	r29, 0x3e	; 62
    4ab8:	6a 97       	sbiw	r28, 0x1a	; 26
    4aba:	cd bf       	out	0x3d, r28	; 61
    4abc:	de bf       	out	0x3e, r29	; 62
    4abe:	8a 8f       	std	Y+26, r24	; 0x1a
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    4ac0:	88 e0       	ldi	r24, 0x08	; 8
    4ac2:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4ac4:	4f e1       	ldi	r20, 0x1F	; 31
    4ac6:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    4aca:	0e 94 09 21 	call	0x4212	; 0x4212 <chb_get_state>
    4ace:	89 83       	std	Y+1, r24	; 0x01
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    4ad0:	89 81       	ldd	r24, Y+1	; 0x01
    4ad2:	86 30       	cpi	r24, 0x06	; 6
    4ad4:	21 f0       	breq	.+8      	; 0x4ade <chb_set_channel+0x32>
    4ad6:	89 81       	ldd	r24, Y+1	; 0x01
    4ad8:	89 30       	cpi	r24, 0x09	; 9
    4ada:	09 f0       	breq	.+2      	; 0x4ade <chb_set_channel+0x32>
    4adc:	d5 c0       	rjmp	.+426    	; 0x4c88 <chb_set_channel+0x1dc>
    4ade:	80 e0       	ldi	r24, 0x00	; 0
    4ae0:	90 e0       	ldi	r25, 0x00	; 0
    4ae2:	ac ed       	ldi	r26, 0xDC	; 220
    4ae4:	b2 e4       	ldi	r27, 0x42	; 66
    4ae6:	8a 83       	std	Y+2, r24	; 0x02
    4ae8:	9b 83       	std	Y+3, r25	; 0x03
    4aea:	ac 83       	std	Y+4, r26	; 0x04
    4aec:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4aee:	6a 81       	ldd	r22, Y+2	; 0x02
    4af0:	7b 81       	ldd	r23, Y+3	; 0x03
    4af2:	8c 81       	ldd	r24, Y+4	; 0x04
    4af4:	9d 81       	ldd	r25, Y+5	; 0x05
    4af6:	2b ea       	ldi	r18, 0xAB	; 171
    4af8:	3a ea       	ldi	r19, 0xAA	; 170
    4afa:	4a e2       	ldi	r20, 0x2A	; 42
    4afc:	51 e4       	ldi	r21, 0x41	; 65
    4afe:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    4b02:	dc 01       	movw	r26, r24
    4b04:	cb 01       	movw	r24, r22
    4b06:	8e 83       	std	Y+6, r24	; 0x06
    4b08:	9f 83       	std	Y+7, r25	; 0x07
    4b0a:	a8 87       	std	Y+8, r26	; 0x08
    4b0c:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    4b0e:	11 e0       	ldi	r17, 0x01	; 1
    4b10:	6e 81       	ldd	r22, Y+6	; 0x06
    4b12:	7f 81       	ldd	r23, Y+7	; 0x07
    4b14:	88 85       	ldd	r24, Y+8	; 0x08
    4b16:	99 85       	ldd	r25, Y+9	; 0x09
    4b18:	20 e0       	ldi	r18, 0x00	; 0
    4b1a:	30 e0       	ldi	r19, 0x00	; 0
    4b1c:	40 e8       	ldi	r20, 0x80	; 128
    4b1e:	5f e3       	ldi	r21, 0x3F	; 63
    4b20:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    4b24:	88 23       	and	r24, r24
    4b26:	0c f0       	brlt	.+2      	; 0x4b2a <chb_set_channel+0x7e>
    4b28:	10 e0       	ldi	r17, 0x00	; 0
    4b2a:	11 23       	and	r17, r17
    4b2c:	19 f0       	breq	.+6      	; 0x4b34 <chb_set_channel+0x88>
		__ticks = 1;
    4b2e:	81 e0       	ldi	r24, 0x01	; 1
    4b30:	8a 87       	std	Y+10, r24	; 0x0a
    4b32:	a3 c0       	rjmp	.+326    	; 0x4c7a <chb_set_channel+0x1ce>
	else if (__tmp > 255)
    4b34:	11 e0       	ldi	r17, 0x01	; 1
    4b36:	6e 81       	ldd	r22, Y+6	; 0x06
    4b38:	7f 81       	ldd	r23, Y+7	; 0x07
    4b3a:	88 85       	ldd	r24, Y+8	; 0x08
    4b3c:	99 85       	ldd	r25, Y+9	; 0x09
    4b3e:	20 e0       	ldi	r18, 0x00	; 0
    4b40:	30 e0       	ldi	r19, 0x00	; 0
    4b42:	4f e7       	ldi	r20, 0x7F	; 127
    4b44:	53 e4       	ldi	r21, 0x43	; 67
    4b46:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    4b4a:	18 16       	cp	r1, r24
    4b4c:	0c f0       	brlt	.+2      	; 0x4b50 <chb_set_channel+0xa4>
    4b4e:	10 e0       	ldi	r17, 0x00	; 0
    4b50:	11 23       	and	r17, r17
    4b52:	09 f4       	brne	.+2      	; 0x4b56 <chb_set_channel+0xaa>
    4b54:	89 c0       	rjmp	.+274    	; 0x4c68 <chb_set_channel+0x1bc>
	{
		_delay_ms(__us / 1000.0);
    4b56:	6a 81       	ldd	r22, Y+2	; 0x02
    4b58:	7b 81       	ldd	r23, Y+3	; 0x03
    4b5a:	8c 81       	ldd	r24, Y+4	; 0x04
    4b5c:	9d 81       	ldd	r25, Y+5	; 0x05
    4b5e:	20 e0       	ldi	r18, 0x00	; 0
    4b60:	30 e0       	ldi	r19, 0x00	; 0
    4b62:	4a e7       	ldi	r20, 0x7A	; 122
    4b64:	54 e4       	ldi	r21, 0x44	; 68
    4b66:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
    4b6a:	dc 01       	movw	r26, r24
    4b6c:	cb 01       	movw	r24, r22
    4b6e:	8b 87       	std	Y+11, r24	; 0x0b
    4b70:	9c 87       	std	Y+12, r25	; 0x0c
    4b72:	ad 87       	std	Y+13, r26	; 0x0d
    4b74:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4b76:	6b 85       	ldd	r22, Y+11	; 0x0b
    4b78:	7c 85       	ldd	r23, Y+12	; 0x0c
    4b7a:	8d 85       	ldd	r24, Y+13	; 0x0d
    4b7c:	9e 85       	ldd	r25, Y+14	; 0x0e
    4b7e:	20 e0       	ldi	r18, 0x00	; 0
    4b80:	30 e0       	ldi	r19, 0x00	; 0
    4b82:	4a ef       	ldi	r20, 0xFA	; 250
    4b84:	55 e4       	ldi	r21, 0x45	; 69
    4b86:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    4b8a:	dc 01       	movw	r26, r24
    4b8c:	cb 01       	movw	r24, r22
    4b8e:	8f 87       	std	Y+15, r24	; 0x0f
    4b90:	98 8b       	std	Y+16, r25	; 0x10
    4b92:	a9 8b       	std	Y+17, r26	; 0x11
    4b94:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    4b96:	11 e0       	ldi	r17, 0x01	; 1
    4b98:	6f 85       	ldd	r22, Y+15	; 0x0f
    4b9a:	78 89       	ldd	r23, Y+16	; 0x10
    4b9c:	89 89       	ldd	r24, Y+17	; 0x11
    4b9e:	9a 89       	ldd	r25, Y+18	; 0x12
    4ba0:	20 e0       	ldi	r18, 0x00	; 0
    4ba2:	30 e0       	ldi	r19, 0x00	; 0
    4ba4:	40 e8       	ldi	r20, 0x80	; 128
    4ba6:	5f e3       	ldi	r21, 0x3F	; 63
    4ba8:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    4bac:	88 23       	and	r24, r24
    4bae:	0c f0       	brlt	.+2      	; 0x4bb2 <chb_set_channel+0x106>
    4bb0:	10 e0       	ldi	r17, 0x00	; 0
    4bb2:	11 23       	and	r17, r17
    4bb4:	29 f0       	breq	.+10     	; 0x4bc0 <chb_set_channel+0x114>
		__ticks = 1;
    4bb6:	81 e0       	ldi	r24, 0x01	; 1
    4bb8:	90 e0       	ldi	r25, 0x00	; 0
    4bba:	8b 8b       	std	Y+19, r24	; 0x13
    4bbc:	9c 8b       	std	Y+20, r25	; 0x14
    4bbe:	46 c0       	rjmp	.+140    	; 0x4c4c <chb_set_channel+0x1a0>
	else if (__tmp > 65535)
    4bc0:	11 e0       	ldi	r17, 0x01	; 1
    4bc2:	6f 85       	ldd	r22, Y+15	; 0x0f
    4bc4:	78 89       	ldd	r23, Y+16	; 0x10
    4bc6:	89 89       	ldd	r24, Y+17	; 0x11
    4bc8:	9a 89       	ldd	r25, Y+18	; 0x12
    4bca:	20 e0       	ldi	r18, 0x00	; 0
    4bcc:	3f ef       	ldi	r19, 0xFF	; 255
    4bce:	4f e7       	ldi	r20, 0x7F	; 127
    4bd0:	57 e4       	ldi	r21, 0x47	; 71
    4bd2:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    4bd6:	18 16       	cp	r1, r24
    4bd8:	0c f0       	brlt	.+2      	; 0x4bdc <chb_set_channel+0x130>
    4bda:	10 e0       	ldi	r17, 0x00	; 0
    4bdc:	11 23       	and	r17, r17
    4bde:	61 f1       	breq	.+88     	; 0x4c38 <chb_set_channel+0x18c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4be0:	6b 85       	ldd	r22, Y+11	; 0x0b
    4be2:	7c 85       	ldd	r23, Y+12	; 0x0c
    4be4:	8d 85       	ldd	r24, Y+13	; 0x0d
    4be6:	9e 85       	ldd	r25, Y+14	; 0x0e
    4be8:	20 e0       	ldi	r18, 0x00	; 0
    4bea:	30 e0       	ldi	r19, 0x00	; 0
    4bec:	40 e2       	ldi	r20, 0x20	; 32
    4bee:	51 e4       	ldi	r21, 0x41	; 65
    4bf0:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    4bf4:	dc 01       	movw	r26, r24
    4bf6:	cb 01       	movw	r24, r22
    4bf8:	bc 01       	movw	r22, r24
    4bfa:	cd 01       	movw	r24, r26
    4bfc:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    4c00:	dc 01       	movw	r26, r24
    4c02:	cb 01       	movw	r24, r22
    4c04:	8b 8b       	std	Y+19, r24	; 0x13
    4c06:	9c 8b       	std	Y+20, r25	; 0x14
    4c08:	12 c0       	rjmp	.+36     	; 0x4c2e <chb_set_channel+0x182>
    4c0a:	80 e2       	ldi	r24, 0x20	; 32
    4c0c:	93 e0       	ldi	r25, 0x03	; 3
    4c0e:	8d 8b       	std	Y+21, r24	; 0x15
    4c10:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4c12:	8d 89       	ldd	r24, Y+21	; 0x15
    4c14:	9e 89       	ldd	r25, Y+22	; 0x16
    4c16:	8c 01       	movw	r16, r24
    4c18:	c8 01       	movw	r24, r16
    4c1a:	01 97       	sbiw	r24, 0x01	; 1
    4c1c:	f1 f7       	brne	.-4      	; 0x4c1a <chb_set_channel+0x16e>
    4c1e:	8c 01       	movw	r16, r24
    4c20:	0d 8b       	std	Y+21, r16	; 0x15
    4c22:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4c24:	8b 89       	ldd	r24, Y+19	; 0x13
    4c26:	9c 89       	ldd	r25, Y+20	; 0x14
    4c28:	01 97       	sbiw	r24, 0x01	; 1
    4c2a:	8b 8b       	std	Y+19, r24	; 0x13
    4c2c:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4c2e:	8b 89       	ldd	r24, Y+19	; 0x13
    4c30:	9c 89       	ldd	r25, Y+20	; 0x14
    4c32:	00 97       	sbiw	r24, 0x00	; 0
    4c34:	51 f7       	brne	.-44     	; 0x4c0a <chb_set_channel+0x15e>
    4c36:	28 c0       	rjmp	.+80     	; 0x4c88 <chb_set_channel+0x1dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4c38:	6f 85       	ldd	r22, Y+15	; 0x0f
    4c3a:	78 89       	ldd	r23, Y+16	; 0x10
    4c3c:	89 89       	ldd	r24, Y+17	; 0x11
    4c3e:	9a 89       	ldd	r25, Y+18	; 0x12
    4c40:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    4c44:	dc 01       	movw	r26, r24
    4c46:	cb 01       	movw	r24, r22
    4c48:	8b 8b       	std	Y+19, r24	; 0x13
    4c4a:	9c 8b       	std	Y+20, r25	; 0x14
    4c4c:	8b 89       	ldd	r24, Y+19	; 0x13
    4c4e:	9c 89       	ldd	r25, Y+20	; 0x14
    4c50:	8f 8b       	std	Y+23, r24	; 0x17
    4c52:	98 8f       	std	Y+24, r25	; 0x18
    4c54:	8f 89       	ldd	r24, Y+23	; 0x17
    4c56:	98 8d       	ldd	r25, Y+24	; 0x18
    4c58:	8c 01       	movw	r16, r24
    4c5a:	c8 01       	movw	r24, r16
    4c5c:	01 97       	sbiw	r24, 0x01	; 1
    4c5e:	f1 f7       	brne	.-4      	; 0x4c5c <chb_set_channel+0x1b0>
    4c60:	8c 01       	movw	r16, r24
    4c62:	0f 8b       	std	Y+23, r16	; 0x17
    4c64:	18 8f       	std	Y+24, r17	; 0x18
    4c66:	10 c0       	rjmp	.+32     	; 0x4c88 <chb_set_channel+0x1dc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4c68:	6e 81       	ldd	r22, Y+6	; 0x06
    4c6a:	7f 81       	ldd	r23, Y+7	; 0x07
    4c6c:	88 85       	ldd	r24, Y+8	; 0x08
    4c6e:	99 85       	ldd	r25, Y+9	; 0x09
    4c70:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    4c74:	dc 01       	movw	r26, r24
    4c76:	cb 01       	movw	r24, r22
    4c78:	8a 87       	std	Y+10, r24	; 0x0a
    4c7a:	8a 85       	ldd	r24, Y+10	; 0x0a
    4c7c:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4c7e:	89 8d       	ldd	r24, Y+25	; 0x19
    4c80:	18 2f       	mov	r17, r24
    4c82:	1a 95       	dec	r17
    4c84:	f1 f7       	brne	.-4      	; 0x4c82 <chb_set_channel+0x1d6>
    4c86:	19 8f       	std	Y+25, r17	; 0x19
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    4c88:	88 e0       	ldi	r24, 0x08	; 8
    4c8a:	0e 94 0d 23 	call	0x461a	; 0x461a <chb_reg_read>
    4c8e:	88 2f       	mov	r24, r24
    4c90:	90 e0       	ldi	r25, 0x00	; 0
    4c92:	9c 01       	movw	r18, r24
    4c94:	2f 71       	andi	r18, 0x1F	; 31
    4c96:	30 70       	andi	r19, 0x00	; 0
    4c98:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4c9a:	88 2f       	mov	r24, r24
    4c9c:	90 e0       	ldi	r25, 0x00	; 0
    4c9e:	28 17       	cp	r18, r24
    4ca0:	39 07       	cpc	r19, r25
    4ca2:	11 f4       	brne	.+4      	; 0x4ca8 <chb_set_channel+0x1fc>
    4ca4:	80 e4       	ldi	r24, 0x40	; 64
    4ca6:	01 c0       	rjmp	.+2      	; 0x4caa <chb_set_channel+0x1fe>
    4ca8:	83 e4       	ldi	r24, 0x43	; 67
}
    4caa:	6a 96       	adiw	r28, 0x1a	; 26
    4cac:	cd bf       	out	0x3d, r28	; 61
    4cae:	de bf       	out	0x3e, r29	; 62
    4cb0:	df 91       	pop	r29
    4cb2:	cf 91       	pop	r28
    4cb4:	1f 91       	pop	r17
    4cb6:	0f 91       	pop	r16
    4cb8:	08 95       	ret

00004cba <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    4cba:	cf 93       	push	r28
    4cbc:	df 93       	push	r29
    4cbe:	0f 92       	push	r0
    4cc0:	cd b7       	in	r28, 0x3d	; 61
    4cc2:	de b7       	in	r29, 0x3e	; 62
    4cc4:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(PHY_TX_PWR, val);
    4cc6:	85 e0       	ldi	r24, 0x05	; 5
    4cc8:	69 81       	ldd	r22, Y+1	; 0x01
    4cca:	0e 94 6d 23 	call	0x46da	; 0x46da <chb_reg_write>
}
    4cce:	0f 90       	pop	r0
    4cd0:	df 91       	pop	r29
    4cd2:	cf 91       	pop	r28
    4cd4:	08 95       	ret

00004cd6 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    4cd6:	0f 93       	push	r16
    4cd8:	1f 93       	push	r17
    4cda:	cf 93       	push	r28
    4cdc:	df 93       	push	r29
    4cde:	cd b7       	in	r28, 0x3d	; 61
    4ce0:	de b7       	in	r29, 0x3e	; 62
    4ce2:	c2 56       	subi	r28, 0x62	; 98
    4ce4:	d0 40       	sbci	r29, 0x00	; 0
    4ce6:	cd bf       	out	0x3d, r28	; 61
    4ce8:	de bf       	out	0x3e, r29	; 62
    4cea:	9e 01       	movw	r18, r28
    4cec:	2e 59       	subi	r18, 0x9E	; 158
    4cee:	3f 4f       	sbci	r19, 0xFF	; 255
    4cf0:	f9 01       	movw	r30, r18
    4cf2:	80 83       	st	Z, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    4cf4:	84 e6       	ldi	r24, 0x64	; 100
    4cf6:	96 e0       	ldi	r25, 0x06	; 6
    4cf8:	fc 01       	movw	r30, r24
    4cfa:	80 81       	ld	r24, Z
    4cfc:	88 2f       	mov	r24, r24
    4cfe:	90 e0       	ldi	r25, 0x00	; 0
    4d00:	82 70       	andi	r24, 0x02	; 2
    4d02:	90 70       	andi	r25, 0x00	; 0
    4d04:	00 97       	sbiw	r24, 0x00	; 0
    4d06:	11 f0       	breq	.+4      	; 0x4d0c <chb_set_state+0x36>
    {
        return RADIO_WRONG_STATE;
    4d08:	84 e4       	ldi	r24, 0x44	; 68
    4d0a:	91 c4       	rjmp	.+2338   	; 0x562e <chb_set_state+0x958>
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    4d0c:	0e 94 09 21 	call	0x4212	; 0x4212 <chb_get_state>
    4d10:	89 83       	std	Y+1, r24	; 0x01
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    4d12:	89 81       	ldd	r24, Y+1	; 0x01
    4d14:	82 31       	cpi	r24, 0x12	; 18
    4d16:	49 f0       	breq	.+18     	; 0x4d2a <chb_set_state+0x54>
    4d18:	89 81       	ldd	r24, Y+1	; 0x01
    4d1a:	81 31       	cpi	r24, 0x11	; 17
    4d1c:	31 f0       	breq	.+12     	; 0x4d2a <chb_set_state+0x54>
    4d1e:	89 81       	ldd	r24, Y+1	; 0x01
    4d20:	81 30       	cpi	r24, 0x01	; 1
    4d22:	19 f0       	breq	.+6      	; 0x4d2a <chb_set_state+0x54>
    4d24:	89 81       	ldd	r24, Y+1	; 0x01
    4d26:	82 30       	cpi	r24, 0x02	; 2
    4d28:	39 f4       	brne	.+14     	; 0x4d38 <chb_set_state+0x62>
    {
        while (chb_get_state() == curr_state);
    4d2a:	00 00       	nop
    4d2c:	0e 94 09 21 	call	0x4212	; 0x4212 <chb_get_state>
    4d30:	98 2f       	mov	r25, r24
    4d32:	89 81       	ldd	r24, Y+1	; 0x01
    4d34:	98 17       	cp	r25, r24
    4d36:	d1 f3       	breq	.-12     	; 0x4d2c <chb_set_state+0x56>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    4d38:	ce 01       	movw	r24, r28
    4d3a:	8e 59       	subi	r24, 0x9E	; 158
    4d3c:	9f 4f       	sbci	r25, 0xFF	; 255
    4d3e:	fc 01       	movw	r30, r24
    4d40:	80 81       	ld	r24, Z
    4d42:	88 2f       	mov	r24, r24
    4d44:	90 e0       	ldi	r25, 0x00	; 0
    4d46:	86 31       	cpi	r24, 0x16	; 22
    4d48:	91 05       	cpc	r25, r1
    4d4a:	09 f4       	brne	.+2      	; 0x4d4e <chb_set_state+0x78>
    4d4c:	cd c1       	rjmp	.+922    	; 0x50e8 <chb_set_state+0x412>
    4d4e:	89 31       	cpi	r24, 0x19	; 25
    4d50:	91 05       	cpc	r25, r1
    4d52:	09 f4       	brne	.+2      	; 0x4d56 <chb_set_state+0x80>
    4d54:	e9 c0       	rjmp	.+466    	; 0x4f28 <chb_set_state+0x252>
    4d56:	88 30       	cpi	r24, 0x08	; 8
    4d58:	91 05       	cpc	r25, r1
    4d5a:	09 f0       	breq	.+2      	; 0x4d5e <chb_set_state+0x88>
    4d5c:	f7 c2       	rjmp	.+1518   	; 0x534c <chb_set_state+0x676>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    4d5e:	84 e6       	ldi	r24, 0x64	; 100
    4d60:	96 e0       	ldi	r25, 0x06	; 6
    4d62:	24 e6       	ldi	r18, 0x64	; 100
    4d64:	36 e0       	ldi	r19, 0x06	; 6
    4d66:	f9 01       	movw	r30, r18
    4d68:	20 81       	ld	r18, Z
    4d6a:	2d 7f       	andi	r18, 0xFD	; 253
    4d6c:	fc 01       	movw	r30, r24
    4d6e:	20 83       	st	Z, r18
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    4d70:	82 e0       	ldi	r24, 0x02	; 2
    4d72:	63 e0       	ldi	r22, 0x03	; 3
    4d74:	4f e1       	ldi	r20, 0x1F	; 31
    4d76:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>
    4d7a:	80 e0       	ldi	r24, 0x00	; 0
    4d7c:	90 e0       	ldi	r25, 0x00	; 0
    4d7e:	a0 e8       	ldi	r26, 0x80	; 128
    4d80:	bf e3       	ldi	r27, 0x3F	; 63
    4d82:	8a 83       	std	Y+2, r24	; 0x02
    4d84:	9b 83       	std	Y+3, r25	; 0x03
    4d86:	ac 83       	std	Y+4, r26	; 0x04
    4d88:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4d8a:	6a 81       	ldd	r22, Y+2	; 0x02
    4d8c:	7b 81       	ldd	r23, Y+3	; 0x03
    4d8e:	8c 81       	ldd	r24, Y+4	; 0x04
    4d90:	9d 81       	ldd	r25, Y+5	; 0x05
    4d92:	2b ea       	ldi	r18, 0xAB	; 171
    4d94:	3a ea       	ldi	r19, 0xAA	; 170
    4d96:	4a e2       	ldi	r20, 0x2A	; 42
    4d98:	51 e4       	ldi	r21, 0x41	; 65
    4d9a:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    4d9e:	dc 01       	movw	r26, r24
    4da0:	cb 01       	movw	r24, r22
    4da2:	8e 83       	std	Y+6, r24	; 0x06
    4da4:	9f 83       	std	Y+7, r25	; 0x07
    4da6:	a8 87       	std	Y+8, r26	; 0x08
    4da8:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    4daa:	11 e0       	ldi	r17, 0x01	; 1
    4dac:	6e 81       	ldd	r22, Y+6	; 0x06
    4dae:	7f 81       	ldd	r23, Y+7	; 0x07
    4db0:	88 85       	ldd	r24, Y+8	; 0x08
    4db2:	99 85       	ldd	r25, Y+9	; 0x09
    4db4:	20 e0       	ldi	r18, 0x00	; 0
    4db6:	30 e0       	ldi	r19, 0x00	; 0
    4db8:	40 e8       	ldi	r20, 0x80	; 128
    4dba:	5f e3       	ldi	r21, 0x3F	; 63
    4dbc:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    4dc0:	88 23       	and	r24, r24
    4dc2:	0c f0       	brlt	.+2      	; 0x4dc6 <chb_set_state+0xf0>
    4dc4:	10 e0       	ldi	r17, 0x00	; 0
    4dc6:	11 23       	and	r17, r17
    4dc8:	19 f0       	breq	.+6      	; 0x4dd0 <chb_set_state+0xfa>
		__ticks = 1;
    4dca:	81 e0       	ldi	r24, 0x01	; 1
    4dcc:	8a 87       	std	Y+10, r24	; 0x0a
    4dce:	a3 c0       	rjmp	.+326    	; 0x4f16 <chb_set_state+0x240>
	else if (__tmp > 255)
    4dd0:	11 e0       	ldi	r17, 0x01	; 1
    4dd2:	6e 81       	ldd	r22, Y+6	; 0x06
    4dd4:	7f 81       	ldd	r23, Y+7	; 0x07
    4dd6:	88 85       	ldd	r24, Y+8	; 0x08
    4dd8:	99 85       	ldd	r25, Y+9	; 0x09
    4dda:	20 e0       	ldi	r18, 0x00	; 0
    4ddc:	30 e0       	ldi	r19, 0x00	; 0
    4dde:	4f e7       	ldi	r20, 0x7F	; 127
    4de0:	53 e4       	ldi	r21, 0x43	; 67
    4de2:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    4de6:	18 16       	cp	r1, r24
    4de8:	0c f0       	brlt	.+2      	; 0x4dec <chb_set_state+0x116>
    4dea:	10 e0       	ldi	r17, 0x00	; 0
    4dec:	11 23       	and	r17, r17
    4dee:	09 f4       	brne	.+2      	; 0x4df2 <chb_set_state+0x11c>
    4df0:	89 c0       	rjmp	.+274    	; 0x4f04 <chb_set_state+0x22e>
	{
		_delay_ms(__us / 1000.0);
    4df2:	6a 81       	ldd	r22, Y+2	; 0x02
    4df4:	7b 81       	ldd	r23, Y+3	; 0x03
    4df6:	8c 81       	ldd	r24, Y+4	; 0x04
    4df8:	9d 81       	ldd	r25, Y+5	; 0x05
    4dfa:	20 e0       	ldi	r18, 0x00	; 0
    4dfc:	30 e0       	ldi	r19, 0x00	; 0
    4dfe:	4a e7       	ldi	r20, 0x7A	; 122
    4e00:	54 e4       	ldi	r21, 0x44	; 68
    4e02:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
    4e06:	dc 01       	movw	r26, r24
    4e08:	cb 01       	movw	r24, r22
    4e0a:	8b 87       	std	Y+11, r24	; 0x0b
    4e0c:	9c 87       	std	Y+12, r25	; 0x0c
    4e0e:	ad 87       	std	Y+13, r26	; 0x0d
    4e10:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4e12:	6b 85       	ldd	r22, Y+11	; 0x0b
    4e14:	7c 85       	ldd	r23, Y+12	; 0x0c
    4e16:	8d 85       	ldd	r24, Y+13	; 0x0d
    4e18:	9e 85       	ldd	r25, Y+14	; 0x0e
    4e1a:	20 e0       	ldi	r18, 0x00	; 0
    4e1c:	30 e0       	ldi	r19, 0x00	; 0
    4e1e:	4a ef       	ldi	r20, 0xFA	; 250
    4e20:	55 e4       	ldi	r21, 0x45	; 69
    4e22:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    4e26:	dc 01       	movw	r26, r24
    4e28:	cb 01       	movw	r24, r22
    4e2a:	8f 87       	std	Y+15, r24	; 0x0f
    4e2c:	98 8b       	std	Y+16, r25	; 0x10
    4e2e:	a9 8b       	std	Y+17, r26	; 0x11
    4e30:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    4e32:	11 e0       	ldi	r17, 0x01	; 1
    4e34:	6f 85       	ldd	r22, Y+15	; 0x0f
    4e36:	78 89       	ldd	r23, Y+16	; 0x10
    4e38:	89 89       	ldd	r24, Y+17	; 0x11
    4e3a:	9a 89       	ldd	r25, Y+18	; 0x12
    4e3c:	20 e0       	ldi	r18, 0x00	; 0
    4e3e:	30 e0       	ldi	r19, 0x00	; 0
    4e40:	40 e8       	ldi	r20, 0x80	; 128
    4e42:	5f e3       	ldi	r21, 0x3F	; 63
    4e44:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    4e48:	88 23       	and	r24, r24
    4e4a:	0c f0       	brlt	.+2      	; 0x4e4e <chb_set_state+0x178>
    4e4c:	10 e0       	ldi	r17, 0x00	; 0
    4e4e:	11 23       	and	r17, r17
    4e50:	29 f0       	breq	.+10     	; 0x4e5c <chb_set_state+0x186>
		__ticks = 1;
    4e52:	81 e0       	ldi	r24, 0x01	; 1
    4e54:	90 e0       	ldi	r25, 0x00	; 0
    4e56:	8b 8b       	std	Y+19, r24	; 0x13
    4e58:	9c 8b       	std	Y+20, r25	; 0x14
    4e5a:	46 c0       	rjmp	.+140    	; 0x4ee8 <chb_set_state+0x212>
	else if (__tmp > 65535)
    4e5c:	11 e0       	ldi	r17, 0x01	; 1
    4e5e:	6f 85       	ldd	r22, Y+15	; 0x0f
    4e60:	78 89       	ldd	r23, Y+16	; 0x10
    4e62:	89 89       	ldd	r24, Y+17	; 0x11
    4e64:	9a 89       	ldd	r25, Y+18	; 0x12
    4e66:	20 e0       	ldi	r18, 0x00	; 0
    4e68:	3f ef       	ldi	r19, 0xFF	; 255
    4e6a:	4f e7       	ldi	r20, 0x7F	; 127
    4e6c:	57 e4       	ldi	r21, 0x47	; 71
    4e6e:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    4e72:	18 16       	cp	r1, r24
    4e74:	0c f0       	brlt	.+2      	; 0x4e78 <chb_set_state+0x1a2>
    4e76:	10 e0       	ldi	r17, 0x00	; 0
    4e78:	11 23       	and	r17, r17
    4e7a:	61 f1       	breq	.+88     	; 0x4ed4 <chb_set_state+0x1fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4e7c:	6b 85       	ldd	r22, Y+11	; 0x0b
    4e7e:	7c 85       	ldd	r23, Y+12	; 0x0c
    4e80:	8d 85       	ldd	r24, Y+13	; 0x0d
    4e82:	9e 85       	ldd	r25, Y+14	; 0x0e
    4e84:	20 e0       	ldi	r18, 0x00	; 0
    4e86:	30 e0       	ldi	r19, 0x00	; 0
    4e88:	40 e2       	ldi	r20, 0x20	; 32
    4e8a:	51 e4       	ldi	r21, 0x41	; 65
    4e8c:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    4e90:	dc 01       	movw	r26, r24
    4e92:	cb 01       	movw	r24, r22
    4e94:	bc 01       	movw	r22, r24
    4e96:	cd 01       	movw	r24, r26
    4e98:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    4e9c:	dc 01       	movw	r26, r24
    4e9e:	cb 01       	movw	r24, r22
    4ea0:	8b 8b       	std	Y+19, r24	; 0x13
    4ea2:	9c 8b       	std	Y+20, r25	; 0x14
    4ea4:	12 c0       	rjmp	.+36     	; 0x4eca <chb_set_state+0x1f4>
    4ea6:	80 e2       	ldi	r24, 0x20	; 32
    4ea8:	93 e0       	ldi	r25, 0x03	; 3
    4eaa:	8d 8b       	std	Y+21, r24	; 0x15
    4eac:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4eae:	8d 89       	ldd	r24, Y+21	; 0x15
    4eb0:	9e 89       	ldd	r25, Y+22	; 0x16
    4eb2:	8c 01       	movw	r16, r24
    4eb4:	c8 01       	movw	r24, r16
    4eb6:	01 97       	sbiw	r24, 0x01	; 1
    4eb8:	f1 f7       	brne	.-4      	; 0x4eb6 <chb_set_state+0x1e0>
    4eba:	8c 01       	movw	r16, r24
    4ebc:	0d 8b       	std	Y+21, r16	; 0x15
    4ebe:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4ec0:	8b 89       	ldd	r24, Y+19	; 0x13
    4ec2:	9c 89       	ldd	r25, Y+20	; 0x14
    4ec4:	01 97       	sbiw	r24, 0x01	; 1
    4ec6:	8b 8b       	std	Y+19, r24	; 0x13
    4ec8:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4eca:	8b 89       	ldd	r24, Y+19	; 0x13
    4ecc:	9c 89       	ldd	r25, Y+20	; 0x14
    4ece:	00 97       	sbiw	r24, 0x00	; 0
    4ed0:	51 f7       	brne	.-44     	; 0x4ea6 <chb_set_state+0x1d0>
    4ed2:	29 c0       	rjmp	.+82     	; 0x4f26 <chb_set_state+0x250>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4ed4:	6f 85       	ldd	r22, Y+15	; 0x0f
    4ed6:	78 89       	ldd	r23, Y+16	; 0x10
    4ed8:	89 89       	ldd	r24, Y+17	; 0x11
    4eda:	9a 89       	ldd	r25, Y+18	; 0x12
    4edc:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    4ee0:	dc 01       	movw	r26, r24
    4ee2:	cb 01       	movw	r24, r22
    4ee4:	8b 8b       	std	Y+19, r24	; 0x13
    4ee6:	9c 8b       	std	Y+20, r25	; 0x14
    4ee8:	8b 89       	ldd	r24, Y+19	; 0x13
    4eea:	9c 89       	ldd	r25, Y+20	; 0x14
    4eec:	8f 8b       	std	Y+23, r24	; 0x17
    4eee:	98 8f       	std	Y+24, r25	; 0x18
    4ef0:	8f 89       	ldd	r24, Y+23	; 0x17
    4ef2:	98 8d       	ldd	r25, Y+24	; 0x18
    4ef4:	8c 01       	movw	r16, r24
    4ef6:	f8 01       	movw	r30, r16
    4ef8:	31 97       	sbiw	r30, 0x01	; 1
    4efa:	f1 f7       	brne	.-4      	; 0x4ef8 <chb_set_state+0x222>
    4efc:	8f 01       	movw	r16, r30
    4efe:	0f 8b       	std	Y+23, r16	; 0x17
    4f00:	18 8f       	std	Y+24, r17	; 0x18
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;
    4f02:	24 c2       	rjmp	.+1096   	; 0x534c <chb_set_state+0x676>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4f04:	6e 81       	ldd	r22, Y+6	; 0x06
    4f06:	7f 81       	ldd	r23, Y+7	; 0x07
    4f08:	88 85       	ldd	r24, Y+8	; 0x08
    4f0a:	99 85       	ldd	r25, Y+9	; 0x09
    4f0c:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    4f10:	dc 01       	movw	r26, r24
    4f12:	cb 01       	movw	r24, r22
    4f14:	8a 87       	std	Y+10, r24	; 0x0a
    4f16:	8a 85       	ldd	r24, Y+10	; 0x0a
    4f18:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4f1a:	89 8d       	ldd	r24, Y+25	; 0x19
    4f1c:	18 2f       	mov	r17, r24
    4f1e:	1a 95       	dec	r17
    4f20:	f1 f7       	brne	.-4      	; 0x4f1e <chb_set_state+0x248>
    4f22:	19 8f       	std	Y+25, r17	; 0x19
    4f24:	13 c2       	rjmp	.+1062   	; 0x534c <chb_set_state+0x676>
    4f26:	12 c2       	rjmp	.+1060   	; 0x534c <chb_set_state+0x676>

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    4f28:	89 81       	ldd	r24, Y+1	; 0x01
    4f2a:	86 31       	cpi	r24, 0x16	; 22
    4f2c:	09 f0       	breq	.+2      	; 0x4f30 <chb_set_state+0x25a>
    4f2e:	0b c2       	rjmp	.+1046   	; 0x5346 <chb_set_state+0x670>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    4f30:	82 e0       	ldi	r24, 0x02	; 2
    4f32:	69 e0       	ldi	r22, 0x09	; 9
    4f34:	4f e1       	ldi	r20, 0x1F	; 31
    4f36:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>
    4f3a:	80 e0       	ldi	r24, 0x00	; 0
    4f3c:	90 e0       	ldi	r25, 0x00	; 0
    4f3e:	a0 e8       	ldi	r26, 0x80	; 128
    4f40:	bf e3       	ldi	r27, 0x3F	; 63
    4f42:	8a 8f       	std	Y+26, r24	; 0x1a
    4f44:	9b 8f       	std	Y+27, r25	; 0x1b
    4f46:	ac 8f       	std	Y+28, r26	; 0x1c
    4f48:	bd 8f       	std	Y+29, r27	; 0x1d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4f4a:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4f4c:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4f4e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4f50:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4f52:	2b ea       	ldi	r18, 0xAB	; 171
    4f54:	3a ea       	ldi	r19, 0xAA	; 170
    4f56:	4a e2       	ldi	r20, 0x2A	; 42
    4f58:	51 e4       	ldi	r21, 0x41	; 65
    4f5a:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    4f5e:	dc 01       	movw	r26, r24
    4f60:	cb 01       	movw	r24, r22
    4f62:	8e 8f       	std	Y+30, r24	; 0x1e
    4f64:	9f 8f       	std	Y+31, r25	; 0x1f
    4f66:	a8 a3       	lds	r26, 0x58
    4f68:	b9 a3       	lds	r27, 0x59
	if (__tmp < 1.0)
    4f6a:	11 e0       	ldi	r17, 0x01	; 1
    4f6c:	6e 8d       	ldd	r22, Y+30	; 0x1e
    4f6e:	7f 8d       	ldd	r23, Y+31	; 0x1f
    4f70:	88 a1       	lds	r24, 0x48
    4f72:	99 a1       	lds	r25, 0x49
    4f74:	20 e0       	ldi	r18, 0x00	; 0
    4f76:	30 e0       	ldi	r19, 0x00	; 0
    4f78:	40 e8       	ldi	r20, 0x80	; 128
    4f7a:	5f e3       	ldi	r21, 0x3F	; 63
    4f7c:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    4f80:	88 23       	and	r24, r24
    4f82:	0c f0       	brlt	.+2      	; 0x4f86 <chb_set_state+0x2b0>
    4f84:	10 e0       	ldi	r17, 0x00	; 0
    4f86:	11 23       	and	r17, r17
    4f88:	19 f0       	breq	.+6      	; 0x4f90 <chb_set_state+0x2ba>
		__ticks = 1;
    4f8a:	81 e0       	ldi	r24, 0x01	; 1
    4f8c:	8a a3       	lds	r24, 0x5a
    4f8e:	a3 c0       	rjmp	.+326    	; 0x50d6 <chb_set_state+0x400>
	else if (__tmp > 255)
    4f90:	11 e0       	ldi	r17, 0x01	; 1
    4f92:	6e 8d       	ldd	r22, Y+30	; 0x1e
    4f94:	7f 8d       	ldd	r23, Y+31	; 0x1f
    4f96:	88 a1       	lds	r24, 0x48
    4f98:	99 a1       	lds	r25, 0x49
    4f9a:	20 e0       	ldi	r18, 0x00	; 0
    4f9c:	30 e0       	ldi	r19, 0x00	; 0
    4f9e:	4f e7       	ldi	r20, 0x7F	; 127
    4fa0:	53 e4       	ldi	r21, 0x43	; 67
    4fa2:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    4fa6:	18 16       	cp	r1, r24
    4fa8:	0c f0       	brlt	.+2      	; 0x4fac <chb_set_state+0x2d6>
    4faa:	10 e0       	ldi	r17, 0x00	; 0
    4fac:	11 23       	and	r17, r17
    4fae:	09 f4       	brne	.+2      	; 0x4fb2 <chb_set_state+0x2dc>
    4fb0:	89 c0       	rjmp	.+274    	; 0x50c4 <chb_set_state+0x3ee>
	{
		_delay_ms(__us / 1000.0);
    4fb2:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4fb4:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4fb6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4fb8:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4fba:	20 e0       	ldi	r18, 0x00	; 0
    4fbc:	30 e0       	ldi	r19, 0x00	; 0
    4fbe:	4a e7       	ldi	r20, 0x7A	; 122
    4fc0:	54 e4       	ldi	r21, 0x44	; 68
    4fc2:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
    4fc6:	dc 01       	movw	r26, r24
    4fc8:	cb 01       	movw	r24, r22
    4fca:	8b a3       	lds	r24, 0x5b
    4fcc:	9c a3       	lds	r25, 0x5c
    4fce:	ad a3       	lds	r26, 0x5d
    4fd0:	be a3       	lds	r27, 0x5e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4fd2:	6b a1       	lds	r22, 0x4b
    4fd4:	7c a1       	lds	r23, 0x4c
    4fd6:	8d a1       	lds	r24, 0x4d
    4fd8:	9e a1       	lds	r25, 0x4e
    4fda:	20 e0       	ldi	r18, 0x00	; 0
    4fdc:	30 e0       	ldi	r19, 0x00	; 0
    4fde:	4a ef       	ldi	r20, 0xFA	; 250
    4fe0:	55 e4       	ldi	r21, 0x45	; 69
    4fe2:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    4fe6:	dc 01       	movw	r26, r24
    4fe8:	cb 01       	movw	r24, r22
    4fea:	8f a3       	lds	r24, 0x5f
    4fec:	98 a7       	lds	r25, 0x78
    4fee:	a9 a7       	lds	r26, 0x79
    4ff0:	ba a7       	lds	r27, 0x7a
	if (__tmp < 1.0)
    4ff2:	11 e0       	ldi	r17, 0x01	; 1
    4ff4:	6f a1       	lds	r22, 0x4f
    4ff6:	78 a5       	lds	r23, 0x68
    4ff8:	89 a5       	lds	r24, 0x69
    4ffa:	9a a5       	lds	r25, 0x6a
    4ffc:	20 e0       	ldi	r18, 0x00	; 0
    4ffe:	30 e0       	ldi	r19, 0x00	; 0
    5000:	40 e8       	ldi	r20, 0x80	; 128
    5002:	5f e3       	ldi	r21, 0x3F	; 63
    5004:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    5008:	88 23       	and	r24, r24
    500a:	0c f0       	brlt	.+2      	; 0x500e <chb_set_state+0x338>
    500c:	10 e0       	ldi	r17, 0x00	; 0
    500e:	11 23       	and	r17, r17
    5010:	29 f0       	breq	.+10     	; 0x501c <chb_set_state+0x346>
		__ticks = 1;
    5012:	81 e0       	ldi	r24, 0x01	; 1
    5014:	90 e0       	ldi	r25, 0x00	; 0
    5016:	8b a7       	lds	r24, 0x7b
    5018:	9c a7       	lds	r25, 0x7c
    501a:	46 c0       	rjmp	.+140    	; 0x50a8 <chb_set_state+0x3d2>
	else if (__tmp > 65535)
    501c:	11 e0       	ldi	r17, 0x01	; 1
    501e:	6f a1       	lds	r22, 0x4f
    5020:	78 a5       	lds	r23, 0x68
    5022:	89 a5       	lds	r24, 0x69
    5024:	9a a5       	lds	r25, 0x6a
    5026:	20 e0       	ldi	r18, 0x00	; 0
    5028:	3f ef       	ldi	r19, 0xFF	; 255
    502a:	4f e7       	ldi	r20, 0x7F	; 127
    502c:	57 e4       	ldi	r21, 0x47	; 71
    502e:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    5032:	18 16       	cp	r1, r24
    5034:	0c f0       	brlt	.+2      	; 0x5038 <chb_set_state+0x362>
    5036:	10 e0       	ldi	r17, 0x00	; 0
    5038:	11 23       	and	r17, r17
    503a:	61 f1       	breq	.+88     	; 0x5094 <chb_set_state+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    503c:	6b a1       	lds	r22, 0x4b
    503e:	7c a1       	lds	r23, 0x4c
    5040:	8d a1       	lds	r24, 0x4d
    5042:	9e a1       	lds	r25, 0x4e
    5044:	20 e0       	ldi	r18, 0x00	; 0
    5046:	30 e0       	ldi	r19, 0x00	; 0
    5048:	40 e2       	ldi	r20, 0x20	; 32
    504a:	51 e4       	ldi	r21, 0x41	; 65
    504c:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    5050:	dc 01       	movw	r26, r24
    5052:	cb 01       	movw	r24, r22
    5054:	bc 01       	movw	r22, r24
    5056:	cd 01       	movw	r24, r26
    5058:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    505c:	dc 01       	movw	r26, r24
    505e:	cb 01       	movw	r24, r22
    5060:	8b a7       	lds	r24, 0x7b
    5062:	9c a7       	lds	r25, 0x7c
    5064:	12 c0       	rjmp	.+36     	; 0x508a <chb_set_state+0x3b4>
    5066:	80 e2       	ldi	r24, 0x20	; 32
    5068:	93 e0       	ldi	r25, 0x03	; 3
    506a:	8d a7       	lds	r24, 0x7d
    506c:	9e a7       	lds	r25, 0x7e
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    506e:	8d a5       	lds	r24, 0x6d
    5070:	9e a5       	lds	r25, 0x6e
    5072:	8c 01       	movw	r16, r24
    5074:	c8 01       	movw	r24, r16
    5076:	01 97       	sbiw	r24, 0x01	; 1
    5078:	f1 f7       	brne	.-4      	; 0x5076 <chb_set_state+0x3a0>
    507a:	8c 01       	movw	r16, r24
    507c:	0d a7       	lds	r16, 0x7d
    507e:	1e a7       	lds	r17, 0x7e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5080:	8b a5       	lds	r24, 0x6b
    5082:	9c a5       	lds	r25, 0x6c
    5084:	01 97       	sbiw	r24, 0x01	; 1
    5086:	8b a7       	lds	r24, 0x7b
    5088:	9c a7       	lds	r25, 0x7c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    508a:	8b a5       	lds	r24, 0x6b
    508c:	9c a5       	lds	r25, 0x6c
    508e:	00 97       	sbiw	r24, 0x00	; 0
    5090:	51 f7       	brne	.-44     	; 0x5066 <chb_set_state+0x390>
    5092:	29 c0       	rjmp	.+82     	; 0x50e6 <chb_set_state+0x410>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5094:	6f a1       	lds	r22, 0x4f
    5096:	78 a5       	lds	r23, 0x68
    5098:	89 a5       	lds	r24, 0x69
    509a:	9a a5       	lds	r25, 0x6a
    509c:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    50a0:	dc 01       	movw	r26, r24
    50a2:	cb 01       	movw	r24, r22
    50a4:	8b a7       	lds	r24, 0x7b
    50a6:	9c a7       	lds	r25, 0x7c
    50a8:	8b a5       	lds	r24, 0x6b
    50aa:	9c a5       	lds	r25, 0x6c
    50ac:	8f a7       	lds	r24, 0x7f
    50ae:	98 ab       	sts	0x58, r25
    50b0:	8f a5       	lds	r24, 0x6f
    50b2:	98 a9       	sts	0x48, r25
    50b4:	8c 01       	movw	r16, r24
    50b6:	f8 01       	movw	r30, r16
    50b8:	31 97       	sbiw	r30, 0x01	; 1
    50ba:	f1 f7       	brne	.-4      	; 0x50b8 <chb_set_state+0x3e2>
    50bc:	8f 01       	movw	r16, r30
    50be:	0f a7       	lds	r16, 0x7f
    50c0:	18 ab       	sts	0x58, r17
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    50c2:	41 c1       	rjmp	.+642    	; 0x5346 <chb_set_state+0x670>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    50c4:	6e 8d       	ldd	r22, Y+30	; 0x1e
    50c6:	7f 8d       	ldd	r23, Y+31	; 0x1f
    50c8:	88 a1       	lds	r24, 0x48
    50ca:	99 a1       	lds	r25, 0x49
    50cc:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    50d0:	dc 01       	movw	r26, r24
    50d2:	cb 01       	movw	r24, r22
    50d4:	8a a3       	lds	r24, 0x5a
    50d6:	8a a1       	lds	r24, 0x4a
    50d8:	89 ab       	sts	0x59, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    50da:	89 a9       	sts	0x49, r24
    50dc:	18 2f       	mov	r17, r24
    50de:	1a 95       	dec	r17
    50e0:	f1 f7       	brne	.-4      	; 0x50de <chb_set_state+0x408>
    50e2:	19 ab       	sts	0x59, r17
    50e4:	30 c1       	rjmp	.+608    	; 0x5346 <chb_set_state+0x670>
    50e6:	2f c1       	rjmp	.+606    	; 0x5346 <chb_set_state+0x670>

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    50e8:	89 81       	ldd	r24, Y+1	; 0x01
    50ea:	89 31       	cpi	r24, 0x19	; 25
    50ec:	09 f0       	breq	.+2      	; 0x50f0 <chb_set_state+0x41a>
    50ee:	2d c1       	rjmp	.+602    	; 0x534a <chb_set_state+0x674>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    50f0:	82 e0       	ldi	r24, 0x02	; 2
    50f2:	69 e0       	ldi	r22, 0x09	; 9
    50f4:	4f e1       	ldi	r20, 0x1F	; 31
    50f6:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>
    50fa:	80 e0       	ldi	r24, 0x00	; 0
    50fc:	90 e0       	ldi	r25, 0x00	; 0
    50fe:	a0 e8       	ldi	r26, 0x80	; 128
    5100:	bf e3       	ldi	r27, 0x3F	; 63
    5102:	8a ab       	sts	0x5a, r24
    5104:	9b ab       	sts	0x5b, r25
    5106:	ac ab       	sts	0x5c, r26
    5108:	bd ab       	sts	0x5d, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    510a:	6a a9       	sts	0x4a, r22
    510c:	7b a9       	sts	0x4b, r23
    510e:	8c a9       	sts	0x4c, r24
    5110:	9d a9       	sts	0x4d, r25
    5112:	2b ea       	ldi	r18, 0xAB	; 171
    5114:	3a ea       	ldi	r19, 0xAA	; 170
    5116:	4a e2       	ldi	r20, 0x2A	; 42
    5118:	51 e4       	ldi	r21, 0x41	; 65
    511a:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    511e:	dc 01       	movw	r26, r24
    5120:	cb 01       	movw	r24, r22
    5122:	8e ab       	sts	0x5e, r24
    5124:	9f ab       	sts	0x5f, r25
    5126:	a8 af       	sts	0x78, r26
    5128:	b9 af       	sts	0x79, r27
	if (__tmp < 1.0)
    512a:	11 e0       	ldi	r17, 0x01	; 1
    512c:	6e a9       	sts	0x4e, r22
    512e:	7f a9       	sts	0x4f, r23
    5130:	88 ad       	sts	0x68, r24
    5132:	99 ad       	sts	0x69, r25
    5134:	20 e0       	ldi	r18, 0x00	; 0
    5136:	30 e0       	ldi	r19, 0x00	; 0
    5138:	40 e8       	ldi	r20, 0x80	; 128
    513a:	5f e3       	ldi	r21, 0x3F	; 63
    513c:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    5140:	88 23       	and	r24, r24
    5142:	0c f0       	brlt	.+2      	; 0x5146 <chb_set_state+0x470>
    5144:	10 e0       	ldi	r17, 0x00	; 0
    5146:	11 23       	and	r17, r17
    5148:	19 f0       	breq	.+6      	; 0x5150 <chb_set_state+0x47a>
		__ticks = 1;
    514a:	81 e0       	ldi	r24, 0x01	; 1
    514c:	8a af       	sts	0x7a, r24
    514e:	e6 c0       	rjmp	.+460    	; 0x531c <chb_set_state+0x646>
	else if (__tmp > 255)
    5150:	11 e0       	ldi	r17, 0x01	; 1
    5152:	6e a9       	sts	0x4e, r22
    5154:	7f a9       	sts	0x4f, r23
    5156:	88 ad       	sts	0x68, r24
    5158:	99 ad       	sts	0x69, r25
    515a:	20 e0       	ldi	r18, 0x00	; 0
    515c:	30 e0       	ldi	r19, 0x00	; 0
    515e:	4f e7       	ldi	r20, 0x7F	; 127
    5160:	53 e4       	ldi	r21, 0x43	; 67
    5162:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    5166:	18 16       	cp	r1, r24
    5168:	0c f0       	brlt	.+2      	; 0x516c <chb_set_state+0x496>
    516a:	10 e0       	ldi	r17, 0x00	; 0
    516c:	11 23       	and	r17, r17
    516e:	09 f4       	brne	.+2      	; 0x5172 <chb_set_state+0x49c>
    5170:	cc c0       	rjmp	.+408    	; 0x530a <chb_set_state+0x634>
	{
		_delay_ms(__us / 1000.0);
    5172:	6a a9       	sts	0x4a, r22
    5174:	7b a9       	sts	0x4b, r23
    5176:	8c a9       	sts	0x4c, r24
    5178:	9d a9       	sts	0x4d, r25
    517a:	20 e0       	ldi	r18, 0x00	; 0
    517c:	30 e0       	ldi	r19, 0x00	; 0
    517e:	4a e7       	ldi	r20, 0x7A	; 122
    5180:	54 e4       	ldi	r21, 0x44	; 68
    5182:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
    5186:	dc 01       	movw	r26, r24
    5188:	cb 01       	movw	r24, r22
    518a:	8b af       	sts	0x7b, r24
    518c:	9c af       	sts	0x7c, r25
    518e:	ad af       	sts	0x7d, r26
    5190:	be af       	sts	0x7e, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5192:	8e 01       	movw	r16, r28
    5194:	01 5c       	subi	r16, 0xC1	; 193
    5196:	1f 4f       	sbci	r17, 0xFF	; 255
    5198:	6b ad       	sts	0x6b, r22
    519a:	7c ad       	sts	0x6c, r23
    519c:	8d ad       	sts	0x6d, r24
    519e:	9e ad       	sts	0x6e, r25
    51a0:	20 e0       	ldi	r18, 0x00	; 0
    51a2:	30 e0       	ldi	r19, 0x00	; 0
    51a4:	4a ef       	ldi	r20, 0xFA	; 250
    51a6:	55 e4       	ldi	r21, 0x45	; 69
    51a8:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    51ac:	dc 01       	movw	r26, r24
    51ae:	cb 01       	movw	r24, r22
    51b0:	f8 01       	movw	r30, r16
    51b2:	80 83       	st	Z, r24
    51b4:	91 83       	std	Z+1, r25	; 0x01
    51b6:	a2 83       	std	Z+2, r26	; 0x02
    51b8:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    51ba:	ce 01       	movw	r24, r28
    51bc:	cf 96       	adiw	r24, 0x3f	; 63
    51be:	11 e0       	ldi	r17, 0x01	; 1
    51c0:	fc 01       	movw	r30, r24
    51c2:	60 81       	ld	r22, Z
    51c4:	71 81       	ldd	r23, Z+1	; 0x01
    51c6:	82 81       	ldd	r24, Z+2	; 0x02
    51c8:	93 81       	ldd	r25, Z+3	; 0x03
    51ca:	20 e0       	ldi	r18, 0x00	; 0
    51cc:	30 e0       	ldi	r19, 0x00	; 0
    51ce:	40 e8       	ldi	r20, 0x80	; 128
    51d0:	5f e3       	ldi	r21, 0x3F	; 63
    51d2:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    51d6:	88 23       	and	r24, r24
    51d8:	0c f0       	brlt	.+2      	; 0x51dc <chb_set_state+0x506>
    51da:	10 e0       	ldi	r17, 0x00	; 0
    51dc:	11 23       	and	r17, r17
    51de:	49 f0       	breq	.+18     	; 0x51f2 <chb_set_state+0x51c>
		__ticks = 1;
    51e0:	ce 01       	movw	r24, r28
    51e2:	8d 5b       	subi	r24, 0xBD	; 189
    51e4:	9f 4f       	sbci	r25, 0xFF	; 255
    51e6:	21 e0       	ldi	r18, 0x01	; 1
    51e8:	30 e0       	ldi	r19, 0x00	; 0
    51ea:	fc 01       	movw	r30, r24
    51ec:	20 83       	st	Z, r18
    51ee:	31 83       	std	Z+1, r19	; 0x01
    51f0:	6e c0       	rjmp	.+220    	; 0x52ce <chb_set_state+0x5f8>
	else if (__tmp > 65535)
    51f2:	ce 01       	movw	r24, r28
    51f4:	cf 96       	adiw	r24, 0x3f	; 63
    51f6:	11 e0       	ldi	r17, 0x01	; 1
    51f8:	fc 01       	movw	r30, r24
    51fa:	60 81       	ld	r22, Z
    51fc:	71 81       	ldd	r23, Z+1	; 0x01
    51fe:	82 81       	ldd	r24, Z+2	; 0x02
    5200:	93 81       	ldd	r25, Z+3	; 0x03
    5202:	20 e0       	ldi	r18, 0x00	; 0
    5204:	3f ef       	ldi	r19, 0xFF	; 255
    5206:	4f e7       	ldi	r20, 0x7F	; 127
    5208:	57 e4       	ldi	r21, 0x47	; 71
    520a:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    520e:	18 16       	cp	r1, r24
    5210:	0c f0       	brlt	.+2      	; 0x5214 <chb_set_state+0x53e>
    5212:	10 e0       	ldi	r17, 0x00	; 0
    5214:	11 23       	and	r17, r17
    5216:	09 f4       	brne	.+2      	; 0x521a <chb_set_state+0x544>
    5218:	49 c0       	rjmp	.+146    	; 0x52ac <chb_set_state+0x5d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    521a:	6b ad       	sts	0x6b, r22
    521c:	7c ad       	sts	0x6c, r23
    521e:	8d ad       	sts	0x6d, r24
    5220:	9e ad       	sts	0x6e, r25
    5222:	20 e0       	ldi	r18, 0x00	; 0
    5224:	30 e0       	ldi	r19, 0x00	; 0
    5226:	40 e2       	ldi	r20, 0x20	; 32
    5228:	51 e4       	ldi	r21, 0x41	; 65
    522a:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    522e:	dc 01       	movw	r26, r24
    5230:	cb 01       	movw	r24, r22
    5232:	8e 01       	movw	r16, r28
    5234:	0d 5b       	subi	r16, 0xBD	; 189
    5236:	1f 4f       	sbci	r17, 0xFF	; 255
    5238:	bc 01       	movw	r22, r24
    523a:	cd 01       	movw	r24, r26
    523c:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    5240:	dc 01       	movw	r26, r24
    5242:	cb 01       	movw	r24, r22
    5244:	f8 01       	movw	r30, r16
    5246:	80 83       	st	Z, r24
    5248:	91 83       	std	Z+1, r25	; 0x01
    524a:	27 c0       	rjmp	.+78     	; 0x529a <chb_set_state+0x5c4>
    524c:	ce 01       	movw	r24, r28
    524e:	8b 5b       	subi	r24, 0xBB	; 187
    5250:	9f 4f       	sbci	r25, 0xFF	; 255
    5252:	20 e2       	ldi	r18, 0x20	; 32
    5254:	33 e0       	ldi	r19, 0x03	; 3
    5256:	fc 01       	movw	r30, r24
    5258:	20 83       	st	Z, r18
    525a:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    525c:	ce 01       	movw	r24, r28
    525e:	8b 5b       	subi	r24, 0xBB	; 187
    5260:	9f 4f       	sbci	r25, 0xFF	; 255
    5262:	fc 01       	movw	r30, r24
    5264:	80 81       	ld	r24, Z
    5266:	91 81       	ldd	r25, Z+1	; 0x01
    5268:	8c 01       	movw	r16, r24
    526a:	c8 01       	movw	r24, r16
    526c:	01 97       	sbiw	r24, 0x01	; 1
    526e:	f1 f7       	brne	.-4      	; 0x526c <chb_set_state+0x596>
    5270:	8c 01       	movw	r16, r24
    5272:	ce 01       	movw	r24, r28
    5274:	8b 5b       	subi	r24, 0xBB	; 187
    5276:	9f 4f       	sbci	r25, 0xFF	; 255
    5278:	fc 01       	movw	r30, r24
    527a:	00 83       	st	Z, r16
    527c:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    527e:	ce 01       	movw	r24, r28
    5280:	8d 5b       	subi	r24, 0xBD	; 189
    5282:	9f 4f       	sbci	r25, 0xFF	; 255
    5284:	9e 01       	movw	r18, r28
    5286:	2d 5b       	subi	r18, 0xBD	; 189
    5288:	3f 4f       	sbci	r19, 0xFF	; 255
    528a:	f9 01       	movw	r30, r18
    528c:	20 81       	ld	r18, Z
    528e:	31 81       	ldd	r19, Z+1	; 0x01
    5290:	21 50       	subi	r18, 0x01	; 1
    5292:	30 40       	sbci	r19, 0x00	; 0
    5294:	fc 01       	movw	r30, r24
    5296:	20 83       	st	Z, r18
    5298:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    529a:	ce 01       	movw	r24, r28
    529c:	8d 5b       	subi	r24, 0xBD	; 189
    529e:	9f 4f       	sbci	r25, 0xFF	; 255
    52a0:	fc 01       	movw	r30, r24
    52a2:	80 81       	ld	r24, Z
    52a4:	91 81       	ldd	r25, Z+1	; 0x01
    52a6:	00 97       	sbiw	r24, 0x00	; 0
    52a8:	89 f6       	brne	.-94     	; 0x524c <chb_set_state+0x576>
    52aa:	4c c0       	rjmp	.+152    	; 0x5344 <chb_set_state+0x66e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    52ac:	8e 01       	movw	r16, r28
    52ae:	0d 5b       	subi	r16, 0xBD	; 189
    52b0:	1f 4f       	sbci	r17, 0xFF	; 255
    52b2:	ce 01       	movw	r24, r28
    52b4:	cf 96       	adiw	r24, 0x3f	; 63
    52b6:	fc 01       	movw	r30, r24
    52b8:	60 81       	ld	r22, Z
    52ba:	71 81       	ldd	r23, Z+1	; 0x01
    52bc:	82 81       	ldd	r24, Z+2	; 0x02
    52be:	93 81       	ldd	r25, Z+3	; 0x03
    52c0:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    52c4:	dc 01       	movw	r26, r24
    52c6:	cb 01       	movw	r24, r22
    52c8:	f8 01       	movw	r30, r16
    52ca:	80 83       	st	Z, r24
    52cc:	91 83       	std	Z+1, r25	; 0x01
    52ce:	ce 01       	movw	r24, r28
    52d0:	89 5b       	subi	r24, 0xB9	; 185
    52d2:	9f 4f       	sbci	r25, 0xFF	; 255
    52d4:	9e 01       	movw	r18, r28
    52d6:	2d 5b       	subi	r18, 0xBD	; 189
    52d8:	3f 4f       	sbci	r19, 0xFF	; 255
    52da:	f9 01       	movw	r30, r18
    52dc:	20 81       	ld	r18, Z
    52de:	31 81       	ldd	r19, Z+1	; 0x01
    52e0:	fc 01       	movw	r30, r24
    52e2:	20 83       	st	Z, r18
    52e4:	31 83       	std	Z+1, r19	; 0x01
    52e6:	ce 01       	movw	r24, r28
    52e8:	89 5b       	subi	r24, 0xB9	; 185
    52ea:	9f 4f       	sbci	r25, 0xFF	; 255
    52ec:	fc 01       	movw	r30, r24
    52ee:	80 81       	ld	r24, Z
    52f0:	91 81       	ldd	r25, Z+1	; 0x01
    52f2:	8c 01       	movw	r16, r24
    52f4:	c8 01       	movw	r24, r16
    52f6:	01 97       	sbiw	r24, 0x01	; 1
    52f8:	f1 f7       	brne	.-4      	; 0x52f6 <chb_set_state+0x620>
    52fa:	8c 01       	movw	r16, r24
    52fc:	ce 01       	movw	r24, r28
    52fe:	89 5b       	subi	r24, 0xB9	; 185
    5300:	9f 4f       	sbci	r25, 0xFF	; 255
    5302:	fc 01       	movw	r30, r24
    5304:	00 83       	st	Z, r16
    5306:	11 83       	std	Z+1, r17	; 0x01
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5308:	20 c0       	rjmp	.+64     	; 0x534a <chb_set_state+0x674>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    530a:	6e a9       	sts	0x4e, r22
    530c:	7f a9       	sts	0x4f, r23
    530e:	88 ad       	sts	0x68, r24
    5310:	99 ad       	sts	0x69, r25
    5312:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    5316:	dc 01       	movw	r26, r24
    5318:	cb 01       	movw	r24, r22
    531a:	8a af       	sts	0x7a, r24
    531c:	ce 01       	movw	r24, r28
    531e:	87 5b       	subi	r24, 0xB7	; 183
    5320:	9f 4f       	sbci	r25, 0xFF	; 255
    5322:	2a ad       	sts	0x6a, r18
    5324:	fc 01       	movw	r30, r24
    5326:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5328:	ce 01       	movw	r24, r28
    532a:	87 5b       	subi	r24, 0xB7	; 183
    532c:	9f 4f       	sbci	r25, 0xFF	; 255
    532e:	fc 01       	movw	r30, r24
    5330:	80 81       	ld	r24, Z
    5332:	18 2f       	mov	r17, r24
    5334:	1a 95       	dec	r17
    5336:	f1 f7       	brne	.-4      	; 0x5334 <chb_set_state+0x65e>
    5338:	ce 01       	movw	r24, r28
    533a:	87 5b       	subi	r24, 0xB7	; 183
    533c:	9f 4f       	sbci	r25, 0xFF	; 255
    533e:	fc 01       	movw	r30, r24
    5340:	10 83       	st	Z, r17
    5342:	03 c0       	rjmp	.+6      	; 0x534a <chb_set_state+0x674>
    5344:	02 c0       	rjmp	.+4      	; 0x534a <chb_set_state+0x674>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5346:	00 00       	nop
    5348:	01 c0       	rjmp	.+2      	; 0x534c <chb_set_state+0x676>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    534a:	00 00       	nop
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    534c:	9e 01       	movw	r18, r28
    534e:	2e 59       	subi	r18, 0x9E	; 158
    5350:	3f 4f       	sbci	r19, 0xFF	; 255
    5352:	82 e0       	ldi	r24, 0x02	; 2
    5354:	f9 01       	movw	r30, r18
    5356:	60 81       	ld	r22, Z
    5358:	4f e1       	ldi	r20, 0x1F	; 31
    535a:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>
    535e:	9e 01       	movw	r18, r28
    5360:	26 5b       	subi	r18, 0xB6	; 182
    5362:	3f 4f       	sbci	r19, 0xFF	; 255
    5364:	80 e0       	ldi	r24, 0x00	; 0
    5366:	90 e0       	ldi	r25, 0x00	; 0
    5368:	ac ed       	ldi	r26, 0xDC	; 220
    536a:	b2 e4       	ldi	r27, 0x42	; 66
    536c:	f9 01       	movw	r30, r18
    536e:	80 83       	st	Z, r24
    5370:	91 83       	std	Z+1, r25	; 0x01
    5372:	a2 83       	std	Z+2, r26	; 0x02
    5374:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5376:	8e 01       	movw	r16, r28
    5378:	02 5b       	subi	r16, 0xB2	; 178
    537a:	1f 4f       	sbci	r17, 0xFF	; 255
    537c:	ce 01       	movw	r24, r28
    537e:	86 5b       	subi	r24, 0xB6	; 182
    5380:	9f 4f       	sbci	r25, 0xFF	; 255
    5382:	fc 01       	movw	r30, r24
    5384:	60 81       	ld	r22, Z
    5386:	71 81       	ldd	r23, Z+1	; 0x01
    5388:	82 81       	ldd	r24, Z+2	; 0x02
    538a:	93 81       	ldd	r25, Z+3	; 0x03
    538c:	2b ea       	ldi	r18, 0xAB	; 171
    538e:	3a ea       	ldi	r19, 0xAA	; 170
    5390:	4a e2       	ldi	r20, 0x2A	; 42
    5392:	51 e4       	ldi	r21, 0x41	; 65
    5394:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    5398:	dc 01       	movw	r26, r24
    539a:	cb 01       	movw	r24, r22
    539c:	f8 01       	movw	r30, r16
    539e:	80 83       	st	Z, r24
    53a0:	91 83       	std	Z+1, r25	; 0x01
    53a2:	a2 83       	std	Z+2, r26	; 0x02
    53a4:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    53a6:	ce 01       	movw	r24, r28
    53a8:	82 5b       	subi	r24, 0xB2	; 178
    53aa:	9f 4f       	sbci	r25, 0xFF	; 255
    53ac:	11 e0       	ldi	r17, 0x01	; 1
    53ae:	fc 01       	movw	r30, r24
    53b0:	60 81       	ld	r22, Z
    53b2:	71 81       	ldd	r23, Z+1	; 0x01
    53b4:	82 81       	ldd	r24, Z+2	; 0x02
    53b6:	93 81       	ldd	r25, Z+3	; 0x03
    53b8:	20 e0       	ldi	r18, 0x00	; 0
    53ba:	30 e0       	ldi	r19, 0x00	; 0
    53bc:	40 e8       	ldi	r20, 0x80	; 128
    53be:	5f e3       	ldi	r21, 0x3F	; 63
    53c0:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    53c4:	88 23       	and	r24, r24
    53c6:	0c f0       	brlt	.+2      	; 0x53ca <chb_set_state+0x6f4>
    53c8:	10 e0       	ldi	r17, 0x00	; 0
    53ca:	11 23       	and	r17, r17
    53cc:	39 f0       	breq	.+14     	; 0x53dc <chb_set_state+0x706>
		__ticks = 1;
    53ce:	ce 01       	movw	r24, r28
    53d0:	8e 5a       	subi	r24, 0xAE	; 174
    53d2:	9f 4f       	sbci	r25, 0xFF	; 255
    53d4:	21 e0       	ldi	r18, 0x01	; 1
    53d6:	fc 01       	movw	r30, r24
    53d8:	20 83       	st	Z, r18
    53da:	05 c1       	rjmp	.+522    	; 0x55e6 <chb_set_state+0x910>
	else if (__tmp > 255)
    53dc:	ce 01       	movw	r24, r28
    53de:	82 5b       	subi	r24, 0xB2	; 178
    53e0:	9f 4f       	sbci	r25, 0xFF	; 255
    53e2:	11 e0       	ldi	r17, 0x01	; 1
    53e4:	fc 01       	movw	r30, r24
    53e6:	60 81       	ld	r22, Z
    53e8:	71 81       	ldd	r23, Z+1	; 0x01
    53ea:	82 81       	ldd	r24, Z+2	; 0x02
    53ec:	93 81       	ldd	r25, Z+3	; 0x03
    53ee:	20 e0       	ldi	r18, 0x00	; 0
    53f0:	30 e0       	ldi	r19, 0x00	; 0
    53f2:	4f e7       	ldi	r20, 0x7F	; 127
    53f4:	53 e4       	ldi	r21, 0x43	; 67
    53f6:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    53fa:	18 16       	cp	r1, r24
    53fc:	0c f0       	brlt	.+2      	; 0x5400 <chb_set_state+0x72a>
    53fe:	10 e0       	ldi	r17, 0x00	; 0
    5400:	11 23       	and	r17, r17
    5402:	09 f4       	brne	.+2      	; 0x5406 <chb_set_state+0x730>
    5404:	df c0       	rjmp	.+446    	; 0x55c4 <chb_set_state+0x8ee>
	{
		_delay_ms(__us / 1000.0);
    5406:	ce 01       	movw	r24, r28
    5408:	86 5b       	subi	r24, 0xB6	; 182
    540a:	9f 4f       	sbci	r25, 0xFF	; 255
    540c:	fc 01       	movw	r30, r24
    540e:	60 81       	ld	r22, Z
    5410:	71 81       	ldd	r23, Z+1	; 0x01
    5412:	82 81       	ldd	r24, Z+2	; 0x02
    5414:	93 81       	ldd	r25, Z+3	; 0x03
    5416:	20 e0       	ldi	r18, 0x00	; 0
    5418:	30 e0       	ldi	r19, 0x00	; 0
    541a:	4a e7       	ldi	r20, 0x7A	; 122
    541c:	54 e4       	ldi	r21, 0x44	; 68
    541e:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
    5422:	dc 01       	movw	r26, r24
    5424:	cb 01       	movw	r24, r22
    5426:	9e 01       	movw	r18, r28
    5428:	2d 5a       	subi	r18, 0xAD	; 173
    542a:	3f 4f       	sbci	r19, 0xFF	; 255
    542c:	f9 01       	movw	r30, r18
    542e:	80 83       	st	Z, r24
    5430:	91 83       	std	Z+1, r25	; 0x01
    5432:	a2 83       	std	Z+2, r26	; 0x02
    5434:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5436:	8e 01       	movw	r16, r28
    5438:	09 5a       	subi	r16, 0xA9	; 169
    543a:	1f 4f       	sbci	r17, 0xFF	; 255
    543c:	ce 01       	movw	r24, r28
    543e:	8d 5a       	subi	r24, 0xAD	; 173
    5440:	9f 4f       	sbci	r25, 0xFF	; 255
    5442:	fc 01       	movw	r30, r24
    5444:	60 81       	ld	r22, Z
    5446:	71 81       	ldd	r23, Z+1	; 0x01
    5448:	82 81       	ldd	r24, Z+2	; 0x02
    544a:	93 81       	ldd	r25, Z+3	; 0x03
    544c:	20 e0       	ldi	r18, 0x00	; 0
    544e:	30 e0       	ldi	r19, 0x00	; 0
    5450:	4a ef       	ldi	r20, 0xFA	; 250
    5452:	55 e4       	ldi	r21, 0x45	; 69
    5454:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    5458:	dc 01       	movw	r26, r24
    545a:	cb 01       	movw	r24, r22
    545c:	f8 01       	movw	r30, r16
    545e:	80 83       	st	Z, r24
    5460:	91 83       	std	Z+1, r25	; 0x01
    5462:	a2 83       	std	Z+2, r26	; 0x02
    5464:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    5466:	ce 01       	movw	r24, r28
    5468:	89 5a       	subi	r24, 0xA9	; 169
    546a:	9f 4f       	sbci	r25, 0xFF	; 255
    546c:	11 e0       	ldi	r17, 0x01	; 1
    546e:	fc 01       	movw	r30, r24
    5470:	60 81       	ld	r22, Z
    5472:	71 81       	ldd	r23, Z+1	; 0x01
    5474:	82 81       	ldd	r24, Z+2	; 0x02
    5476:	93 81       	ldd	r25, Z+3	; 0x03
    5478:	20 e0       	ldi	r18, 0x00	; 0
    547a:	30 e0       	ldi	r19, 0x00	; 0
    547c:	40 e8       	ldi	r20, 0x80	; 128
    547e:	5f e3       	ldi	r21, 0x3F	; 63
    5480:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    5484:	88 23       	and	r24, r24
    5486:	0c f0       	brlt	.+2      	; 0x548a <chb_set_state+0x7b4>
    5488:	10 e0       	ldi	r17, 0x00	; 0
    548a:	11 23       	and	r17, r17
    548c:	49 f0       	breq	.+18     	; 0x54a0 <chb_set_state+0x7ca>
		__ticks = 1;
    548e:	ce 01       	movw	r24, r28
    5490:	85 5a       	subi	r24, 0xA5	; 165
    5492:	9f 4f       	sbci	r25, 0xFF	; 255
    5494:	21 e0       	ldi	r18, 0x01	; 1
    5496:	30 e0       	ldi	r19, 0x00	; 0
    5498:	fc 01       	movw	r30, r24
    549a:	20 83       	st	Z, r18
    549c:	31 83       	std	Z+1, r19	; 0x01
    549e:	74 c0       	rjmp	.+232    	; 0x5588 <chb_set_state+0x8b2>
	else if (__tmp > 65535)
    54a0:	ce 01       	movw	r24, r28
    54a2:	89 5a       	subi	r24, 0xA9	; 169
    54a4:	9f 4f       	sbci	r25, 0xFF	; 255
    54a6:	11 e0       	ldi	r17, 0x01	; 1
    54a8:	fc 01       	movw	r30, r24
    54aa:	60 81       	ld	r22, Z
    54ac:	71 81       	ldd	r23, Z+1	; 0x01
    54ae:	82 81       	ldd	r24, Z+2	; 0x02
    54b0:	93 81       	ldd	r25, Z+3	; 0x03
    54b2:	20 e0       	ldi	r18, 0x00	; 0
    54b4:	3f ef       	ldi	r19, 0xFF	; 255
    54b6:	4f e7       	ldi	r20, 0x7F	; 127
    54b8:	57 e4       	ldi	r21, 0x47	; 71
    54ba:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    54be:	18 16       	cp	r1, r24
    54c0:	0c f0       	brlt	.+2      	; 0x54c4 <chb_set_state+0x7ee>
    54c2:	10 e0       	ldi	r17, 0x00	; 0
    54c4:	11 23       	and	r17, r17
    54c6:	09 f4       	brne	.+2      	; 0x54ca <chb_set_state+0x7f4>
    54c8:	4d c0       	rjmp	.+154    	; 0x5564 <chb_set_state+0x88e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    54ca:	ce 01       	movw	r24, r28
    54cc:	8d 5a       	subi	r24, 0xAD	; 173
    54ce:	9f 4f       	sbci	r25, 0xFF	; 255
    54d0:	fc 01       	movw	r30, r24
    54d2:	60 81       	ld	r22, Z
    54d4:	71 81       	ldd	r23, Z+1	; 0x01
    54d6:	82 81       	ldd	r24, Z+2	; 0x02
    54d8:	93 81       	ldd	r25, Z+3	; 0x03
    54da:	20 e0       	ldi	r18, 0x00	; 0
    54dc:	30 e0       	ldi	r19, 0x00	; 0
    54de:	40 e2       	ldi	r20, 0x20	; 32
    54e0:	51 e4       	ldi	r21, 0x41	; 65
    54e2:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    54e6:	dc 01       	movw	r26, r24
    54e8:	cb 01       	movw	r24, r22
    54ea:	8e 01       	movw	r16, r28
    54ec:	05 5a       	subi	r16, 0xA5	; 165
    54ee:	1f 4f       	sbci	r17, 0xFF	; 255
    54f0:	bc 01       	movw	r22, r24
    54f2:	cd 01       	movw	r24, r26
    54f4:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    54f8:	dc 01       	movw	r26, r24
    54fa:	cb 01       	movw	r24, r22
    54fc:	f8 01       	movw	r30, r16
    54fe:	80 83       	st	Z, r24
    5500:	91 83       	std	Z+1, r25	; 0x01
    5502:	27 c0       	rjmp	.+78     	; 0x5552 <chb_set_state+0x87c>
    5504:	ce 01       	movw	r24, r28
    5506:	83 5a       	subi	r24, 0xA3	; 163
    5508:	9f 4f       	sbci	r25, 0xFF	; 255
    550a:	20 e2       	ldi	r18, 0x20	; 32
    550c:	33 e0       	ldi	r19, 0x03	; 3
    550e:	fc 01       	movw	r30, r24
    5510:	20 83       	st	Z, r18
    5512:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5514:	ce 01       	movw	r24, r28
    5516:	83 5a       	subi	r24, 0xA3	; 163
    5518:	9f 4f       	sbci	r25, 0xFF	; 255
    551a:	fc 01       	movw	r30, r24
    551c:	80 81       	ld	r24, Z
    551e:	91 81       	ldd	r25, Z+1	; 0x01
    5520:	8c 01       	movw	r16, r24
    5522:	c8 01       	movw	r24, r16
    5524:	01 97       	sbiw	r24, 0x01	; 1
    5526:	f1 f7       	brne	.-4      	; 0x5524 <chb_set_state+0x84e>
    5528:	8c 01       	movw	r16, r24
    552a:	ce 01       	movw	r24, r28
    552c:	83 5a       	subi	r24, 0xA3	; 163
    552e:	9f 4f       	sbci	r25, 0xFF	; 255
    5530:	fc 01       	movw	r30, r24
    5532:	00 83       	st	Z, r16
    5534:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5536:	ce 01       	movw	r24, r28
    5538:	85 5a       	subi	r24, 0xA5	; 165
    553a:	9f 4f       	sbci	r25, 0xFF	; 255
    553c:	9e 01       	movw	r18, r28
    553e:	25 5a       	subi	r18, 0xA5	; 165
    5540:	3f 4f       	sbci	r19, 0xFF	; 255
    5542:	f9 01       	movw	r30, r18
    5544:	20 81       	ld	r18, Z
    5546:	31 81       	ldd	r19, Z+1	; 0x01
    5548:	21 50       	subi	r18, 0x01	; 1
    554a:	30 40       	sbci	r19, 0x00	; 0
    554c:	fc 01       	movw	r30, r24
    554e:	20 83       	st	Z, r18
    5550:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5552:	ce 01       	movw	r24, r28
    5554:	85 5a       	subi	r24, 0xA5	; 165
    5556:	9f 4f       	sbci	r25, 0xFF	; 255
    5558:	fc 01       	movw	r30, r24
    555a:	80 81       	ld	r24, Z
    555c:	91 81       	ldd	r25, Z+1	; 0x01
    555e:	00 97       	sbiw	r24, 0x00	; 0
    5560:	89 f6       	brne	.-94     	; 0x5504 <chb_set_state+0x82e>
    5562:	58 c0       	rjmp	.+176    	; 0x5614 <chb_set_state+0x93e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5564:	8e 01       	movw	r16, r28
    5566:	05 5a       	subi	r16, 0xA5	; 165
    5568:	1f 4f       	sbci	r17, 0xFF	; 255
    556a:	ce 01       	movw	r24, r28
    556c:	89 5a       	subi	r24, 0xA9	; 169
    556e:	9f 4f       	sbci	r25, 0xFF	; 255
    5570:	fc 01       	movw	r30, r24
    5572:	60 81       	ld	r22, Z
    5574:	71 81       	ldd	r23, Z+1	; 0x01
    5576:	82 81       	ldd	r24, Z+2	; 0x02
    5578:	93 81       	ldd	r25, Z+3	; 0x03
    557a:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    557e:	dc 01       	movw	r26, r24
    5580:	cb 01       	movw	r24, r22
    5582:	f8 01       	movw	r30, r16
    5584:	80 83       	st	Z, r24
    5586:	91 83       	std	Z+1, r25	; 0x01
    5588:	ce 01       	movw	r24, r28
    558a:	81 5a       	subi	r24, 0xA1	; 161
    558c:	9f 4f       	sbci	r25, 0xFF	; 255
    558e:	9e 01       	movw	r18, r28
    5590:	25 5a       	subi	r18, 0xA5	; 165
    5592:	3f 4f       	sbci	r19, 0xFF	; 255
    5594:	f9 01       	movw	r30, r18
    5596:	20 81       	ld	r18, Z
    5598:	31 81       	ldd	r19, Z+1	; 0x01
    559a:	fc 01       	movw	r30, r24
    559c:	20 83       	st	Z, r18
    559e:	31 83       	std	Z+1, r19	; 0x01
    55a0:	ce 01       	movw	r24, r28
    55a2:	81 5a       	subi	r24, 0xA1	; 161
    55a4:	9f 4f       	sbci	r25, 0xFF	; 255
    55a6:	fc 01       	movw	r30, r24
    55a8:	80 81       	ld	r24, Z
    55aa:	91 81       	ldd	r25, Z+1	; 0x01
    55ac:	8c 01       	movw	r16, r24
    55ae:	c8 01       	movw	r24, r16
    55b0:	01 97       	sbiw	r24, 0x01	; 1
    55b2:	f1 f7       	brne	.-4      	; 0x55b0 <chb_set_state+0x8da>
    55b4:	8c 01       	movw	r16, r24
    55b6:	ce 01       	movw	r24, r28
    55b8:	81 5a       	subi	r24, 0xA1	; 161
    55ba:	9f 4f       	sbci	r25, 0xFF	; 255
    55bc:	fc 01       	movw	r30, r24
    55be:	00 83       	st	Z, r16
    55c0:	11 83       	std	Z+1, r17	; 0x01
    55c2:	28 c0       	rjmp	.+80     	; 0x5614 <chb_set_state+0x93e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    55c4:	8e 01       	movw	r16, r28
    55c6:	0e 5a       	subi	r16, 0xAE	; 174
    55c8:	1f 4f       	sbci	r17, 0xFF	; 255
    55ca:	ce 01       	movw	r24, r28
    55cc:	82 5b       	subi	r24, 0xB2	; 178
    55ce:	9f 4f       	sbci	r25, 0xFF	; 255
    55d0:	fc 01       	movw	r30, r24
    55d2:	60 81       	ld	r22, Z
    55d4:	71 81       	ldd	r23, Z+1	; 0x01
    55d6:	82 81       	ldd	r24, Z+2	; 0x02
    55d8:	93 81       	ldd	r25, Z+3	; 0x03
    55da:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    55de:	dc 01       	movw	r26, r24
    55e0:	cb 01       	movw	r24, r22
    55e2:	f8 01       	movw	r30, r16
    55e4:	80 83       	st	Z, r24
    55e6:	ce 01       	movw	r24, r28
    55e8:	8f 59       	subi	r24, 0x9F	; 159
    55ea:	9f 4f       	sbci	r25, 0xFF	; 255
    55ec:	9e 01       	movw	r18, r28
    55ee:	2e 5a       	subi	r18, 0xAE	; 174
    55f0:	3f 4f       	sbci	r19, 0xFF	; 255
    55f2:	f9 01       	movw	r30, r18
    55f4:	20 81       	ld	r18, Z
    55f6:	fc 01       	movw	r30, r24
    55f8:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    55fa:	ce 01       	movw	r24, r28
    55fc:	8f 59       	subi	r24, 0x9F	; 159
    55fe:	9f 4f       	sbci	r25, 0xFF	; 255
    5600:	fc 01       	movw	r30, r24
    5602:	80 81       	ld	r24, Z
    5604:	18 2f       	mov	r17, r24
    5606:	1a 95       	dec	r17
    5608:	f1 f7       	brne	.-4      	; 0x5606 <chb_set_state+0x930>
    560a:	ce 01       	movw	r24, r28
    560c:	8f 59       	subi	r24, 0x9F	; 159
    560e:	9f 4f       	sbci	r25, 0xFF	; 255
    5610:	fc 01       	movw	r30, r24
    5612:	10 83       	st	Z, r17

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    5614:	0e 94 09 21 	call	0x4212	; 0x4212 <chb_get_state>
    5618:	28 2f       	mov	r18, r24
    561a:	ce 01       	movw	r24, r28
    561c:	8e 59       	subi	r24, 0x9E	; 158
    561e:	9f 4f       	sbci	r25, 0xFF	; 255
    5620:	fc 01       	movw	r30, r24
    5622:	80 81       	ld	r24, Z
    5624:	28 17       	cp	r18, r24
    5626:	11 f4       	brne	.+4      	; 0x562c <chb_set_state+0x956>
    {
        return RADIO_SUCCESS;
    5628:	80 e4       	ldi	r24, 0x40	; 64
    562a:	01 c0       	rjmp	.+2      	; 0x562e <chb_set_state+0x958>
    }
    return RADIO_TIMED_OUT;
    562c:	83 e4       	ldi	r24, 0x43	; 67
}
    562e:	ce 59       	subi	r28, 0x9E	; 158
    5630:	df 4f       	sbci	r29, 0xFF	; 255
    5632:	cd bf       	out	0x3d, r28	; 61
    5634:	de bf       	out	0x3e, r29	; 62
    5636:	df 91       	pop	r29
    5638:	cf 91       	pop	r28
    563a:	1f 91       	pop	r17
    563c:	0f 91       	pop	r16
    563e:	08 95       	ret

00005640 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    5640:	cf 93       	push	r28
    5642:	df 93       	push	r29
    5644:	0f 92       	push	r0
    5646:	0f 92       	push	r0
    5648:	cd b7       	in	r28, 0x3d	; 61
    564a:	de b7       	in	r29, 0x3e	; 62
    564c:	89 83       	std	Y+1, r24	; 0x01
    564e:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    5650:	29 81       	ldd	r18, Y+1	; 0x01
    5652:	3a 81       	ldd	r19, Y+2	; 0x02
    5654:	80 e0       	ldi	r24, 0x00	; 0
    5656:	90 e0       	ldi	r25, 0x00	; 0
    5658:	b9 01       	movw	r22, r18
    565a:	48 e0       	ldi	r20, 0x08	; 8
    565c:	50 e0       	ldi	r21, 0x00	; 0
    565e:	0e 94 41 2f 	call	0x5e82	; 0x5e82 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    5662:	29 81       	ldd	r18, Y+1	; 0x01
    5664:	3a 81       	ldd	r19, Y+2	; 0x02
    5666:	84 e2       	ldi	r24, 0x24	; 36
    5668:	b9 01       	movw	r22, r18
    566a:	0e 94 c8 23 	call	0x4790	; 0x4790 <chb_reg_write64>
}
    566e:	0f 90       	pop	r0
    5670:	0f 90       	pop	r0
    5672:	df 91       	pop	r29
    5674:	cf 91       	pop	r28
    5676:	08 95       	ret

00005678 <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    5678:	cf 93       	push	r28
    567a:	df 93       	push	r29
    567c:	0f 92       	push	r0
    567e:	0f 92       	push	r0
    5680:	cd b7       	in	r28, 0x3d	; 61
    5682:	de b7       	in	r29, 0x3e	; 62
    5684:	89 83       	std	Y+1, r24	; 0x01
    5686:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    5688:	29 81       	ldd	r18, Y+1	; 0x01
    568a:	3a 81       	ldd	r19, Y+2	; 0x02
    568c:	80 e0       	ldi	r24, 0x00	; 0
    568e:	90 e0       	ldi	r25, 0x00	; 0
    5690:	b9 01       	movw	r22, r18
    5692:	48 e0       	ldi	r20, 0x08	; 8
    5694:	50 e0       	ldi	r21, 0x00	; 0
    5696:	0e 94 7d 2f 	call	0x5efa	; 0x5efa <chb_eeprom_read>
}
    569a:	0f 90       	pop	r0
    569c:	0f 90       	pop	r0
    569e:	df 91       	pop	r29
    56a0:	cf 91       	pop	r28
    56a2:	08 95       	ret

000056a4 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    56a4:	cf 93       	push	r28
    56a6:	df 93       	push	r29
    56a8:	00 d0       	rcall	.+0      	; 0x56aa <chb_set_short_addr+0x6>
    56aa:	00 d0       	rcall	.+0      	; 0x56ac <chb_set_short_addr+0x8>
    56ac:	cd b7       	in	r28, 0x3d	; 61
    56ae:	de b7       	in	r29, 0x3e	; 62
    56b0:	8d 83       	std	Y+5, r24	; 0x05
    56b2:	9e 83       	std	Y+6, r25	; 0x06
    U8 *addr_ptr = (U8 *)&addr;
    56b4:	ce 01       	movw	r24, r28
    56b6:	05 96       	adiw	r24, 0x05	; 5
    56b8:	89 83       	std	Y+1, r24	; 0x01
    56ba:	9a 83       	std	Y+2, r25	; 0x02
    pcb_t *pcb = chb_get_pcb();
    56bc:	0e 94 01 1e 	call	0x3c02	; 0x3c02 <chb_get_pcb>
    56c0:	8b 83       	std	Y+3, r24	; 0x03
    56c2:	9c 83       	std	Y+4, r25	; 0x04

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    56c4:	29 81       	ldd	r18, Y+1	; 0x01
    56c6:	3a 81       	ldd	r19, Y+2	; 0x02
    56c8:	89 e0       	ldi	r24, 0x09	; 9
    56ca:	90 e0       	ldi	r25, 0x00	; 0
    56cc:	b9 01       	movw	r22, r18
    56ce:	42 e0       	ldi	r20, 0x02	; 2
    56d0:	50 e0       	ldi	r21, 0x00	; 0
    56d2:	0e 94 41 2f 	call	0x5e82	; 0x5e82 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    56d6:	2d 81       	ldd	r18, Y+5	; 0x05
    56d8:	3e 81       	ldd	r19, Y+6	; 0x06
    56da:	80 e2       	ldi	r24, 0x20	; 32
    56dc:	b9 01       	movw	r22, r18
    56de:	0e 94 97 23 	call	0x472e	; 0x472e <chb_reg_write16>
    pcb->src_addr = addr;
    56e2:	2d 81       	ldd	r18, Y+5	; 0x05
    56e4:	3e 81       	ldd	r19, Y+6	; 0x06
    56e6:	8b 81       	ldd	r24, Y+3	; 0x03
    56e8:	9c 81       	ldd	r25, Y+4	; 0x04
    56ea:	fc 01       	movw	r30, r24
    56ec:	20 83       	st	Z, r18
    56ee:	31 83       	std	Z+1, r19	; 0x01
}
    56f0:	26 96       	adiw	r28, 0x06	; 6
    56f2:	cd bf       	out	0x3d, r28	; 61
    56f4:	de bf       	out	0x3e, r29	; 62
    56f6:	df 91       	pop	r29
    56f8:	cf 91       	pop	r28
    56fa:	08 95       	ret

000056fc <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    56fc:	cf 93       	push	r28
    56fe:	df 93       	push	r29
    5700:	0f 92       	push	r0
    5702:	0f 92       	push	r0
    5704:	cd b7       	in	r28, 0x3d	; 61
    5706:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    5708:	89 e0       	ldi	r24, 0x09	; 9
    570a:	90 e0       	ldi	r25, 0x00	; 0
    570c:	9e 01       	movw	r18, r28
    570e:	2f 5f       	subi	r18, 0xFF	; 255
    5710:	3f 4f       	sbci	r19, 0xFF	; 255
    5712:	b9 01       	movw	r22, r18
    5714:	42 e0       	ldi	r20, 0x02	; 2
    5716:	50 e0       	ldi	r21, 0x00	; 0
    5718:	0e 94 7d 2f 	call	0x5efa	; 0x5efa <chb_eeprom_read>
    return *(U16 *)addr;
    571c:	ce 01       	movw	r24, r28
    571e:	01 96       	adiw	r24, 0x01	; 1
    5720:	fc 01       	movw	r30, r24
    5722:	80 81       	ld	r24, Z
    5724:	91 81       	ldd	r25, Z+1	; 0x01
}
    5726:	0f 90       	pop	r0
    5728:	0f 90       	pop	r0
    572a:	df 91       	pop	r29
    572c:	cf 91       	pop	r28
    572e:	08 95       	ret

00005730 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    5730:	cf 93       	push	r28
    5732:	df 93       	push	r29
    5734:	cd b7       	in	r28, 0x3d	; 61
    5736:	de b7       	in	r29, 0x3e	; 62
    5738:	28 97       	sbiw	r28, 0x08	; 8
    573a:	cd bf       	out	0x3d, r28	; 61
    573c:	de bf       	out	0x3e, r29	; 62
    573e:	8c 83       	std	Y+4, r24	; 0x04
    5740:	9d 83       	std	Y+5, r25	; 0x05
    5742:	6e 83       	std	Y+6, r22	; 0x06
    5744:	7f 83       	std	Y+7, r23	; 0x07
    5746:	48 87       	std	Y+8, r20	; 0x08
    U8 state = chb_get_state();
    5748:	0e 94 09 21 	call	0x4212	; 0x4212 <chb_get_state>
    574c:	89 83       	std	Y+1, r24	; 0x01
    pcb_t *pcb = chb_get_pcb();
    574e:	0e 94 01 1e 	call	0x3c02	; 0x3c02 <chb_get_pcb>
    5752:	8a 83       	std	Y+2, r24	; 0x02
    5754:	9b 83       	std	Y+3, r25	; 0x03

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    5756:	89 81       	ldd	r24, Y+1	; 0x01
    5758:	82 30       	cpi	r24, 0x02	; 2
    575a:	19 f0       	breq	.+6      	; 0x5762 <chb_tx+0x32>
    575c:	89 81       	ldd	r24, Y+1	; 0x01
    575e:	82 31       	cpi	r24, 0x12	; 18
    5760:	11 f4       	brne	.+4      	; 0x5766 <chb_tx+0x36>
    {
        return RADIO_WRONG_STATE;
    5762:	84 e4       	ldi	r24, 0x44	; 68
    5764:	23 c0       	rjmp	.+70     	; 0x57ac <chb_tx+0x7c>
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    5766:	88 e0       	ldi	r24, 0x08	; 8
    5768:	0e 94 6b 26 	call	0x4cd6	; 0x4cd6 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    576c:	89 e1       	ldi	r24, 0x19	; 25
    576e:	0e 94 6b 26 	call	0x4cd6	; 0x4cd6 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    5772:	8c 81       	ldd	r24, Y+4	; 0x04
    5774:	9d 81       	ldd	r25, Y+5	; 0x05
    5776:	2e 81       	ldd	r18, Y+6	; 0x06
    5778:	3f 81       	ldd	r19, Y+7	; 0x07
    577a:	6a e0       	ldi	r22, 0x0A	; 10
    577c:	a9 01       	movw	r20, r18
    577e:	28 85       	ldd	r18, Y+8	; 0x08
    5780:	0e 94 15 24 	call	0x482a	; 0x482a <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    5784:	82 e0       	ldi	r24, 0x02	; 2
    5786:	62 e0       	ldi	r22, 0x02	; 2
    5788:	4f e1       	ldi	r20, 0x1F	; 31
    578a:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    578e:	00 00       	nop
    5790:	8a 81       	ldd	r24, Y+2	; 0x02
    5792:	9b 81       	ldd	r25, Y+3	; 0x03
    5794:	fc 01       	movw	r30, r24
    5796:	94 81       	ldd	r25, Z+4	; 0x04
    5798:	81 e0       	ldi	r24, 0x01	; 1
    579a:	89 27       	eor	r24, r25
    579c:	88 23       	and	r24, r24
    579e:	c1 f7       	brne	.-16     	; 0x5790 <chb_tx+0x60>
    pcb->tx_end = false;
    57a0:	8a 81       	ldd	r24, Y+2	; 0x02
    57a2:	9b 81       	ldd	r25, Y+3	; 0x03
    57a4:	fc 01       	movw	r30, r24
    57a6:	14 82       	std	Z+4, r1	; 0x04

    // check the status of the transmission
    return chb_get_status();
    57a8:	0e 94 14 21 	call	0x4228	; 0x4228 <chb_get_status>
}
    57ac:	28 96       	adiw	r28, 0x08	; 8
    57ae:	cd bf       	out	0x3d, r28	; 61
    57b0:	de bf       	out	0x3e, r29	; 62
    57b2:	df 91       	pop	r29
    57b4:	cf 91       	pop	r28
    57b6:	08 95       	ret

000057b8 <chb_sleep>:
/*!
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    57b8:	0f 93       	push	r16
    57ba:	1f 93       	push	r17
    57bc:	cf 93       	push	r28
    57be:	df 93       	push	r29
    57c0:	cd b7       	in	r28, 0x3d	; 61
    57c2:	de b7       	in	r29, 0x3e	; 62
    57c4:	69 97       	sbiw	r28, 0x19	; 25
    57c6:	cd bf       	out	0x3d, r28	; 61
    57c8:	de bf       	out	0x3e, r29	; 62
    57ca:	89 8f       	std	Y+25, r24	; 0x19
    if (enb)
    57cc:	89 8d       	ldd	r24, Y+25	; 0x19
    57ce:	88 23       	and	r24, r24
    57d0:	69 f0       	breq	.+26     	; 0x57ec <chb_sleep+0x34>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    57d2:	88 e0       	ldi	r24, 0x08	; 8
    57d4:	0e 94 6b 26 	call	0x4cd6	; 0x4cd6 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    57d8:	84 e6       	ldi	r24, 0x64	; 100
    57da:	96 e0       	ldi	r25, 0x06	; 6
    57dc:	24 e6       	ldi	r18, 0x64	; 100
    57de:	36 e0       	ldi	r19, 0x06	; 6
    57e0:	f9 01       	movw	r30, r18
    57e2:	20 81       	ld	r18, Z
    57e4:	22 60       	ori	r18, 0x02	; 2
    57e6:	fc 01       	movw	r30, r24
    57e8:	20 83       	st	Z, r18
    57ea:	e1 c0       	rjmp	.+450    	; 0x59ae <chb_sleep+0x1f6>
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    57ec:	84 e6       	ldi	r24, 0x64	; 100
    57ee:	96 e0       	ldi	r25, 0x06	; 6
    57f0:	24 e6       	ldi	r18, 0x64	; 100
    57f2:	36 e0       	ldi	r19, 0x06	; 6
    57f4:	f9 01       	movw	r30, r18
    57f6:	20 81       	ld	r18, Z
    57f8:	2d 7f       	andi	r18, 0xFD	; 253
    57fa:	fc 01       	movw	r30, r24
    57fc:	20 83       	st	Z, r18
    57fe:	80 e0       	ldi	r24, 0x00	; 0
    5800:	90 e0       	ldi	r25, 0x00	; 0
    5802:	a0 e7       	ldi	r26, 0x70	; 112
    5804:	b3 e4       	ldi	r27, 0x43	; 67
    5806:	89 83       	std	Y+1, r24	; 0x01
    5808:	9a 83       	std	Y+2, r25	; 0x02
    580a:	ab 83       	std	Y+3, r26	; 0x03
    580c:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    580e:	69 81       	ldd	r22, Y+1	; 0x01
    5810:	7a 81       	ldd	r23, Y+2	; 0x02
    5812:	8b 81       	ldd	r24, Y+3	; 0x03
    5814:	9c 81       	ldd	r25, Y+4	; 0x04
    5816:	2b ea       	ldi	r18, 0xAB	; 171
    5818:	3a ea       	ldi	r19, 0xAA	; 170
    581a:	4a e2       	ldi	r20, 0x2A	; 42
    581c:	51 e4       	ldi	r21, 0x41	; 65
    581e:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    5822:	dc 01       	movw	r26, r24
    5824:	cb 01       	movw	r24, r22
    5826:	8d 83       	std	Y+5, r24	; 0x05
    5828:	9e 83       	std	Y+6, r25	; 0x06
    582a:	af 83       	std	Y+7, r26	; 0x07
    582c:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    582e:	11 e0       	ldi	r17, 0x01	; 1
    5830:	6d 81       	ldd	r22, Y+5	; 0x05
    5832:	7e 81       	ldd	r23, Y+6	; 0x06
    5834:	8f 81       	ldd	r24, Y+7	; 0x07
    5836:	98 85       	ldd	r25, Y+8	; 0x08
    5838:	20 e0       	ldi	r18, 0x00	; 0
    583a:	30 e0       	ldi	r19, 0x00	; 0
    583c:	40 e8       	ldi	r20, 0x80	; 128
    583e:	5f e3       	ldi	r21, 0x3F	; 63
    5840:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    5844:	88 23       	and	r24, r24
    5846:	0c f0       	brlt	.+2      	; 0x584a <chb_sleep+0x92>
    5848:	10 e0       	ldi	r17, 0x00	; 0
    584a:	11 23       	and	r17, r17
    584c:	19 f0       	breq	.+6      	; 0x5854 <chb_sleep+0x9c>
		__ticks = 1;
    584e:	81 e0       	ldi	r24, 0x01	; 1
    5850:	89 87       	std	Y+9, r24	; 0x09
    5852:	a3 c0       	rjmp	.+326    	; 0x599a <chb_sleep+0x1e2>
	else if (__tmp > 255)
    5854:	11 e0       	ldi	r17, 0x01	; 1
    5856:	6d 81       	ldd	r22, Y+5	; 0x05
    5858:	7e 81       	ldd	r23, Y+6	; 0x06
    585a:	8f 81       	ldd	r24, Y+7	; 0x07
    585c:	98 85       	ldd	r25, Y+8	; 0x08
    585e:	20 e0       	ldi	r18, 0x00	; 0
    5860:	30 e0       	ldi	r19, 0x00	; 0
    5862:	4f e7       	ldi	r20, 0x7F	; 127
    5864:	53 e4       	ldi	r21, 0x43	; 67
    5866:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    586a:	18 16       	cp	r1, r24
    586c:	0c f0       	brlt	.+2      	; 0x5870 <chb_sleep+0xb8>
    586e:	10 e0       	ldi	r17, 0x00	; 0
    5870:	11 23       	and	r17, r17
    5872:	09 f4       	brne	.+2      	; 0x5876 <chb_sleep+0xbe>
    5874:	89 c0       	rjmp	.+274    	; 0x5988 <chb_sleep+0x1d0>
	{
		_delay_ms(__us / 1000.0);
    5876:	69 81       	ldd	r22, Y+1	; 0x01
    5878:	7a 81       	ldd	r23, Y+2	; 0x02
    587a:	8b 81       	ldd	r24, Y+3	; 0x03
    587c:	9c 81       	ldd	r25, Y+4	; 0x04
    587e:	20 e0       	ldi	r18, 0x00	; 0
    5880:	30 e0       	ldi	r19, 0x00	; 0
    5882:	4a e7       	ldi	r20, 0x7A	; 122
    5884:	54 e4       	ldi	r21, 0x44	; 68
    5886:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
    588a:	dc 01       	movw	r26, r24
    588c:	cb 01       	movw	r24, r22
    588e:	8a 87       	std	Y+10, r24	; 0x0a
    5890:	9b 87       	std	Y+11, r25	; 0x0b
    5892:	ac 87       	std	Y+12, r26	; 0x0c
    5894:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5896:	6a 85       	ldd	r22, Y+10	; 0x0a
    5898:	7b 85       	ldd	r23, Y+11	; 0x0b
    589a:	8c 85       	ldd	r24, Y+12	; 0x0c
    589c:	9d 85       	ldd	r25, Y+13	; 0x0d
    589e:	20 e0       	ldi	r18, 0x00	; 0
    58a0:	30 e0       	ldi	r19, 0x00	; 0
    58a2:	4a ef       	ldi	r20, 0xFA	; 250
    58a4:	55 e4       	ldi	r21, 0x45	; 69
    58a6:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    58aa:	dc 01       	movw	r26, r24
    58ac:	cb 01       	movw	r24, r22
    58ae:	8e 87       	std	Y+14, r24	; 0x0e
    58b0:	9f 87       	std	Y+15, r25	; 0x0f
    58b2:	a8 8b       	std	Y+16, r26	; 0x10
    58b4:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    58b6:	11 e0       	ldi	r17, 0x01	; 1
    58b8:	6e 85       	ldd	r22, Y+14	; 0x0e
    58ba:	7f 85       	ldd	r23, Y+15	; 0x0f
    58bc:	88 89       	ldd	r24, Y+16	; 0x10
    58be:	99 89       	ldd	r25, Y+17	; 0x11
    58c0:	20 e0       	ldi	r18, 0x00	; 0
    58c2:	30 e0       	ldi	r19, 0x00	; 0
    58c4:	40 e8       	ldi	r20, 0x80	; 128
    58c6:	5f e3       	ldi	r21, 0x3F	; 63
    58c8:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    58cc:	88 23       	and	r24, r24
    58ce:	0c f0       	brlt	.+2      	; 0x58d2 <chb_sleep+0x11a>
    58d0:	10 e0       	ldi	r17, 0x00	; 0
    58d2:	11 23       	and	r17, r17
    58d4:	29 f0       	breq	.+10     	; 0x58e0 <chb_sleep+0x128>
		__ticks = 1;
    58d6:	81 e0       	ldi	r24, 0x01	; 1
    58d8:	90 e0       	ldi	r25, 0x00	; 0
    58da:	8a 8b       	std	Y+18, r24	; 0x12
    58dc:	9b 8b       	std	Y+19, r25	; 0x13
    58de:	46 c0       	rjmp	.+140    	; 0x596c <chb_sleep+0x1b4>
	else if (__tmp > 65535)
    58e0:	11 e0       	ldi	r17, 0x01	; 1
    58e2:	6e 85       	ldd	r22, Y+14	; 0x0e
    58e4:	7f 85       	ldd	r23, Y+15	; 0x0f
    58e6:	88 89       	ldd	r24, Y+16	; 0x10
    58e8:	99 89       	ldd	r25, Y+17	; 0x11
    58ea:	20 e0       	ldi	r18, 0x00	; 0
    58ec:	3f ef       	ldi	r19, 0xFF	; 255
    58ee:	4f e7       	ldi	r20, 0x7F	; 127
    58f0:	57 e4       	ldi	r21, 0x47	; 71
    58f2:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    58f6:	18 16       	cp	r1, r24
    58f8:	0c f0       	brlt	.+2      	; 0x58fc <chb_sleep+0x144>
    58fa:	10 e0       	ldi	r17, 0x00	; 0
    58fc:	11 23       	and	r17, r17
    58fe:	61 f1       	breq	.+88     	; 0x5958 <chb_sleep+0x1a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5900:	6a 85       	ldd	r22, Y+10	; 0x0a
    5902:	7b 85       	ldd	r23, Y+11	; 0x0b
    5904:	8c 85       	ldd	r24, Y+12	; 0x0c
    5906:	9d 85       	ldd	r25, Y+13	; 0x0d
    5908:	20 e0       	ldi	r18, 0x00	; 0
    590a:	30 e0       	ldi	r19, 0x00	; 0
    590c:	40 e2       	ldi	r20, 0x20	; 32
    590e:	51 e4       	ldi	r21, 0x41	; 65
    5910:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    5914:	dc 01       	movw	r26, r24
    5916:	cb 01       	movw	r24, r22
    5918:	bc 01       	movw	r22, r24
    591a:	cd 01       	movw	r24, r26
    591c:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    5920:	dc 01       	movw	r26, r24
    5922:	cb 01       	movw	r24, r22
    5924:	8a 8b       	std	Y+18, r24	; 0x12
    5926:	9b 8b       	std	Y+19, r25	; 0x13
    5928:	12 c0       	rjmp	.+36     	; 0x594e <chb_sleep+0x196>
    592a:	80 e2       	ldi	r24, 0x20	; 32
    592c:	93 e0       	ldi	r25, 0x03	; 3
    592e:	8c 8b       	std	Y+20, r24	; 0x14
    5930:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5932:	8c 89       	ldd	r24, Y+20	; 0x14
    5934:	9d 89       	ldd	r25, Y+21	; 0x15
    5936:	8c 01       	movw	r16, r24
    5938:	c8 01       	movw	r24, r16
    593a:	01 97       	sbiw	r24, 0x01	; 1
    593c:	f1 f7       	brne	.-4      	; 0x593a <chb_sleep+0x182>
    593e:	8c 01       	movw	r16, r24
    5940:	0c 8b       	std	Y+20, r16	; 0x14
    5942:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5944:	8a 89       	ldd	r24, Y+18	; 0x12
    5946:	9b 89       	ldd	r25, Y+19	; 0x13
    5948:	01 97       	sbiw	r24, 0x01	; 1
    594a:	8a 8b       	std	Y+18, r24	; 0x12
    594c:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    594e:	8a 89       	ldd	r24, Y+18	; 0x12
    5950:	9b 89       	ldd	r25, Y+19	; 0x13
    5952:	00 97       	sbiw	r24, 0x00	; 0
    5954:	51 f7       	brne	.-44     	; 0x592a <chb_sleep+0x172>
    5956:	28 c0       	rjmp	.+80     	; 0x59a8 <chb_sleep+0x1f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5958:	6e 85       	ldd	r22, Y+14	; 0x0e
    595a:	7f 85       	ldd	r23, Y+15	; 0x0f
    595c:	88 89       	ldd	r24, Y+16	; 0x10
    595e:	99 89       	ldd	r25, Y+17	; 0x11
    5960:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    5964:	dc 01       	movw	r26, r24
    5966:	cb 01       	movw	r24, r22
    5968:	8a 8b       	std	Y+18, r24	; 0x12
    596a:	9b 8b       	std	Y+19, r25	; 0x13
    596c:	8a 89       	ldd	r24, Y+18	; 0x12
    596e:	9b 89       	ldd	r25, Y+19	; 0x13
    5970:	8e 8b       	std	Y+22, r24	; 0x16
    5972:	9f 8b       	std	Y+23, r25	; 0x17
    5974:	8e 89       	ldd	r24, Y+22	; 0x16
    5976:	9f 89       	ldd	r25, Y+23	; 0x17
    5978:	8c 01       	movw	r16, r24
    597a:	f8 01       	movw	r30, r16
    597c:	31 97       	sbiw	r30, 0x01	; 1
    597e:	f1 f7       	brne	.-4      	; 0x597c <chb_sleep+0x1c4>
    5980:	8f 01       	movw	r16, r30
    5982:	0e 8b       	std	Y+22, r16	; 0x16
    5984:	1f 8b       	std	Y+23, r17	; 0x17
    5986:	10 c0       	rjmp	.+32     	; 0x59a8 <chb_sleep+0x1f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5988:	6d 81       	ldd	r22, Y+5	; 0x05
    598a:	7e 81       	ldd	r23, Y+6	; 0x06
    598c:	8f 81       	ldd	r24, Y+7	; 0x07
    598e:	98 85       	ldd	r25, Y+8	; 0x08
    5990:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    5994:	dc 01       	movw	r26, r24
    5996:	cb 01       	movw	r24, r22
    5998:	89 87       	std	Y+9, r24	; 0x09
    599a:	89 85       	ldd	r24, Y+9	; 0x09
    599c:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    599e:	88 8d       	ldd	r24, Y+24	; 0x18
    59a0:	18 2f       	mov	r17, r24
    59a2:	1a 95       	dec	r17
    59a4:	f1 f7       	brne	.-4      	; 0x59a2 <chb_sleep+0x1ea>
    59a6:	18 8f       	std	Y+24, r17	; 0x18

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    59a8:	86 e1       	ldi	r24, 0x16	; 22
    59aa:	0e 94 6b 26 	call	0x4cd6	; 0x4cd6 <chb_set_state>
    }
}
    59ae:	69 96       	adiw	r28, 0x19	; 25
    59b0:	cd bf       	out	0x3d, r28	; 61
    59b2:	de bf       	out	0x3e, r29	; 62
    59b4:	df 91       	pop	r29
    59b6:	cf 91       	pop	r28
    59b8:	1f 91       	pop	r17
    59ba:	0f 91       	pop	r16
    59bc:	08 95       	ret

000059be <chb_radio_init>:
/*!

*/
/**************************************************************************/
static void chb_radio_init()
{
    59be:	cf 93       	push	r28
    59c0:	df 93       	push	r29
    59c2:	cd b7       	in	r28, 0x3d	; 61
    59c4:	de b7       	in	r29, 0x3e	; 62
    59c6:	ea 97       	sbiw	r28, 0x3a	; 58
    59c8:	cd bf       	out	0x3d, r28	; 61
    59ca:	de bf       	out	0x3e, r29	; 62
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    59cc:	0e 94 21 21 	call	0x4242	; 0x4242 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    59d0:	8e e0       	ldi	r24, 0x0E	; 14
    59d2:	60 e0       	ldi	r22, 0x00	; 0
    59d4:	0e 94 6d 23 	call	0x46da	; 0x46da <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    59d8:	82 e0       	ldi	r24, 0x02	; 2
    59da:	63 e0       	ldi	r22, 0x03	; 3
    59dc:	4f e1       	ldi	r20, 0x1F	; 31
    59de:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    59e2:	00 00       	nop
    59e4:	81 e0       	ldi	r24, 0x01	; 1
    59e6:	0e 94 0d 23 	call	0x461a	; 0x461a <chb_reg_read>
    59ea:	88 2f       	mov	r24, r24
    59ec:	90 e0       	ldi	r25, 0x00	; 0
    59ee:	8f 71       	andi	r24, 0x1F	; 31
    59f0:	90 70       	andi	r25, 0x00	; 0
    59f2:	88 30       	cpi	r24, 0x08	; 8
    59f4:	91 05       	cpc	r25, r1
    59f6:	b1 f7       	brne	.-20     	; 0x59e4 <chb_radio_init+0x26>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    59f8:	8e e2       	ldi	r24, 0x2E	; 46
    59fa:	60 e4       	ldi	r22, 0x40	; 64
    59fc:	40 ec       	ldi	r20, 0xC0	; 192
    59fe:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    5a02:	8e e0       	ldi	r24, 0x0E	; 14
    5a04:	6c e0       	ldi	r22, 0x0C	; 12
    5a06:	0e 94 6d 23 	call	0x46da	; 0x46da <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    5a0a:	84 e0       	ldi	r24, 0x04	; 4
    5a0c:	60 e2       	ldi	r22, 0x20	; 32
    5a0e:	40 e2       	ldi	r20, 0x20	; 32
    5a10:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    5a14:	81 e0       	ldi	r24, 0x01	; 1
    5a16:	0e 94 0d 25 	call	0x4a1a	; 0x4a1a <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    5a1a:	81 e0       	ldi	r24, 0x01	; 1
    5a1c:	0e 94 56 25 	call	0x4aac	; 0x4aac <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    5a20:	86 e1       	ldi	r24, 0x16	; 22
    5a22:	0e 94 6b 26 	call	0x4cd6	; 0x4cd6 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    5a26:	82 e2       	ldi	r24, 0x22	; 34
    5a28:	64 e3       	ldi	r22, 0x34	; 52
    5a2a:	72 e1       	ldi	r23, 0x12	; 18
    5a2c:	0e 94 97 23 	call	0x472e	; 0x472e <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    5a30:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <chb_get_short_addr>
    5a34:	9c 01       	movw	r18, r24
    5a36:	80 e2       	ldi	r24, 0x20	; 32
    5a38:	b9 01       	movw	r22, r18
    5a3a:	0e 94 97 23 	call	0x472e	; 0x472e <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    5a3e:	ce 01       	movw	r24, r28
    5a40:	01 96       	adiw	r24, 0x01	; 1
    5a42:	0e 94 3c 2b 	call	0x5678	; 0x5678 <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    5a46:	84 e2       	ldi	r24, 0x24	; 36
    5a48:	9e 01       	movw	r18, r28
    5a4a:	2f 5f       	subi	r18, 0xFF	; 255
    5a4c:	3f 4f       	sbci	r19, 0xFF	; 255
    5a4e:	b9 01       	movw	r22, r18
    5a50:	0e 94 c8 23 	call	0x4790	; 0x4790 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    5a54:	82 e7       	ldi	r24, 0x72	; 114
    5a56:	96 e0       	ldi	r25, 0x06	; 6
    5a58:	22 e7       	ldi	r18, 0x72	; 114
    5a5a:	36 e0       	ldi	r19, 0x06	; 6
    5a5c:	f9 01       	movw	r30, r18
    5a5e:	20 81       	ld	r18, Z
    5a60:	21 60       	ori	r18, 0x01	; 1
    5a62:	fc 01       	movw	r30, r24
    5a64:	20 83       	st	Z, r18
    5a66:	89 e6       	ldi	r24, 0x69	; 105
    5a68:	96 e0       	ldi	r25, 0x06	; 6
    5a6a:	29 e6       	ldi	r18, 0x69	; 105
    5a6c:	36 e0       	ldi	r19, 0x06	; 6
    5a6e:	f9 01       	movw	r30, r18
    5a70:	20 81       	ld	r18, Z
    5a72:	23 60       	ori	r18, 0x03	; 3
    5a74:	fc 01       	movw	r30, r24
    5a76:	20 83       	st	Z, r18
    5a78:	8a e6       	ldi	r24, 0x6A	; 106
    5a7a:	96 e0       	ldi	r25, 0x06	; 6
    5a7c:	2a e6       	ldi	r18, 0x6A	; 106
    5a7e:	36 e0       	ldi	r19, 0x06	; 6
    5a80:	f9 01       	movw	r30, r18
    5a82:	20 81       	ld	r18, Z
    5a84:	24 60       	ori	r18, 0x04	; 4
    5a86:	fc 01       	movw	r30, r24
    5a88:	20 83       	st	Z, r18
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    5a8a:	80 ea       	ldi	r24, 0xA0	; 160
    5a8c:	90 e0       	ldi	r25, 0x00	; 0
    5a8e:	20 ea       	ldi	r18, 0xA0	; 160
    5a90:	30 e0       	ldi	r19, 0x00	; 0
    5a92:	f9 01       	movw	r30, r18
    5a94:	22 81       	ldd	r18, Z+2	; 0x02
    5a96:	27 60       	ori	r18, 0x07	; 7
    5a98:	fc 01       	movw	r30, r24
    5a9a:	22 83       	std	Z+2, r18	; 0x02

    if (chb_get_state() != RX_STATE)
    5a9c:	0e 94 09 21 	call	0x4212	; 0x4212 <chb_get_state>
    5aa0:	86 31       	cpi	r24, 0x16	; 22
    5aa2:	b1 f0       	breq	.+44     	; 0x5ad0 <chb_radio_init+0x112>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    5aa4:	ce 01       	movw	r24, r28
    5aa6:	09 96       	adiw	r24, 0x09	; 9
    5aa8:	2c e0       	ldi	r18, 0x0C	; 12
    5aaa:	32 e0       	ldi	r19, 0x02	; 2
    5aac:	b9 01       	movw	r22, r18
    5aae:	0e 94 52 5c 	call	0xb8a4	; 0xb8a4 <strcpy_P>
        printf(buf);
    5ab2:	0f 92       	push	r0
    5ab4:	0f 92       	push	r0
    5ab6:	8d b7       	in	r24, 0x3d	; 61
    5ab8:	9e b7       	in	r25, 0x3e	; 62
    5aba:	01 96       	adiw	r24, 0x01	; 1
    5abc:	9e 01       	movw	r18, r28
    5abe:	27 5f       	subi	r18, 0xF7	; 247
    5ac0:	3f 4f       	sbci	r19, 0xFF	; 255
    5ac2:	fc 01       	movw	r30, r24
    5ac4:	20 83       	st	Z, r18
    5ac6:	31 83       	std	Z+1, r19	; 0x01
    5ac8:	0e 94 a5 5c 	call	0xb94a	; 0xb94a <printf>
    5acc:	0f 90       	pop	r0
    5ace:	0f 90       	pop	r0
    }
	StartOfFreeSpace = 0; //set location in FRAM Buffer at which to start storing radio messages to the start of the buffer
    5ad0:	10 92 bb 50 	sts	0x50BB, r1
    5ad4:	10 92 bc 50 	sts	0x50BC, r1
    5ad8:	10 92 bd 50 	sts	0x50BD, r1
    5adc:	10 92 be 50 	sts	0x50BE, r1
}
    5ae0:	ea 96       	adiw	r28, 0x3a	; 58
    5ae2:	cd bf       	out	0x3d, r28	; 61
    5ae4:	de bf       	out	0x3e, r29	; 62
    5ae6:	df 91       	pop	r29
    5ae8:	cf 91       	pop	r28
    5aea:	08 95       	ret

00005aec <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    5aec:	cf 93       	push	r28
    5aee:	df 93       	push	r29
    5af0:	cd b7       	in	r28, 0x3d	; 61
    5af2:	de b7       	in	r29, 0x3e	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    5af4:	0e 94 bd 2f 	call	0x5f7a	; 0x5f7a <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    5af8:	80 e6       	ldi	r24, 0x60	; 96
    5afa:	96 e0       	ldi	r25, 0x06	; 6
    5afc:	20 e6       	ldi	r18, 0x60	; 96
    5afe:	36 e0       	ldi	r19, 0x06	; 6
    5b00:	f9 01       	movw	r30, r18
    5b02:	20 81       	ld	r18, Z
    5b04:	22 60       	ori	r18, 0x02	; 2
    5b06:	fc 01       	movw	r30, r24
    5b08:	20 83       	st	Z, r18
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    5b0a:	80 e6       	ldi	r24, 0x60	; 96
    5b0c:	96 e0       	ldi	r25, 0x06	; 6
    5b0e:	20 e6       	ldi	r18, 0x60	; 96
    5b10:	36 e0       	ldi	r19, 0x06	; 6
    5b12:	f9 01       	movw	r30, r18
    5b14:	20 81       	ld	r18, Z
    5b16:	21 60       	ori	r18, 0x01	; 1
    5b18:	fc 01       	movw	r30, r24
    5b1a:	20 83       	st	Z, r18

    // config radio
    chb_radio_init();
    5b1c:	0e 94 df 2c 	call	0x59be	; 0x59be <chb_radio_init>
}
    5b20:	df 91       	pop	r29
    5b22:	cf 91       	pop	r28
    5b24:	08 95       	ret

00005b26 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    5b26:	1f 92       	push	r1
    5b28:	0f 92       	push	r0
    5b2a:	0f b6       	in	r0, 0x3f	; 63
    5b2c:	0f 92       	push	r0
    5b2e:	00 90 3b 00 	lds	r0, 0x003B
    5b32:	0f 92       	push	r0
    5b34:	11 24       	eor	r1, r1
    5b36:	2f 93       	push	r18
    5b38:	3f 93       	push	r19
    5b3a:	4f 93       	push	r20
    5b3c:	5f 93       	push	r21
    5b3e:	6f 93       	push	r22
    5b40:	7f 93       	push	r23
    5b42:	8f 93       	push	r24
    5b44:	9f 93       	push	r25
    5b46:	af 93       	push	r26
    5b48:	bf 93       	push	r27
    5b4a:	ef 93       	push	r30
    5b4c:	ff 93       	push	r31
    5b4e:	cf 93       	push	r28
    5b50:	df 93       	push	r29
    5b52:	00 d0       	rcall	.+0      	; 0x5b54 <__vector_64+0x2e>
    5b54:	0f 92       	push	r0
    5b56:	cd b7       	in	r28, 0x3d	; 61
    5b58:	de b7       	in	r29, 0x3e	; 62
    U8 state, intp_src = 0;
    5b5a:	19 82       	std	Y+1, r1	; 0x01
	//U8 dummy;
    pcb_t *pcb = chb_get_pcb();
    5b5c:	0e 94 01 1e 	call	0x3c02	; 0x3c02 <chb_get_pcb>
    5b60:	8a 83       	std	Y+2, r24	; 0x02
    5b62:	9b 83       	std	Y+3, r25	; 0x03

    CHB_ENTER_CRIT();
    5b64:	8f e3       	ldi	r24, 0x3F	; 63
    5b66:	90 e0       	ldi	r25, 0x00	; 0
    5b68:	fc 01       	movw	r30, r24
    5b6a:	80 81       	ld	r24, Z
    5b6c:	80 93 47 40 	sts	0x4047, r24
    5b70:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    5b72:	81 e0       	ldi	r24, 0x01	; 1
    5b74:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <RadioCS>

    /*Send Register address and read register content.*/
    //dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    5b78:	8f e8       	ldi	r24, 0x8F	; 143
    5b7a:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <SPID_write>
    intp_src = SPID_write(0);
    5b7e:	80 e0       	ldi	r24, 0x00	; 0
    5b80:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <SPID_write>
    5b84:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    5b86:	80 e0       	ldi	r24, 0x00	; 0
    5b88:	0e 94 8b 2e 	call	0x5d16	; 0x5d16 <RadioCS>

    while (intp_src)
    5b8c:	9d c0       	rjmp	.+314    	; 0x5cc8 <__vector_64+0x1a2>
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    5b8e:	89 81       	ldd	r24, Y+1	; 0x01
    5b90:	88 2f       	mov	r24, r24
    5b92:	90 e0       	ldi	r25, 0x00	; 0
    5b94:	84 70       	andi	r24, 0x04	; 4
    5b96:	90 70       	andi	r25, 0x00	; 0
    5b98:	00 97       	sbiw	r24, 0x00	; 0
    5b9a:	21 f0       	breq	.+8      	; 0x5ba4 <__vector_64+0x7e>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    5b9c:	89 81       	ldd	r24, Y+1	; 0x01
    5b9e:	8b 7f       	andi	r24, 0xFB	; 251
    5ba0:	89 83       	std	Y+1, r24	; 0x01
    5ba2:	92 c0       	rjmp	.+292    	; 0x5cc8 <__vector_64+0x1a2>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    5ba4:	89 81       	ldd	r24, Y+1	; 0x01
    5ba6:	88 2f       	mov	r24, r24
    5ba8:	90 e0       	ldi	r25, 0x00	; 0
    5baa:	88 70       	andi	r24, 0x08	; 8
    5bac:	90 70       	andi	r25, 0x00	; 0
    5bae:	00 97       	sbiw	r24, 0x00	; 0
    5bb0:	09 f4       	brne	.+2      	; 0x5bb4 <__vector_64+0x8e>
    5bb2:	4c c0       	rjmp	.+152    	; 0x5c4c <__vector_64+0x126>
        {
            state = chb_get_state();
    5bb4:	0e 94 09 21 	call	0x4212	; 0x4212 <chb_get_state>
    5bb8:	8c 83       	std	Y+4, r24	; 0x04

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    5bba:	8c 81       	ldd	r24, Y+4	; 0x04
    5bbc:	86 30       	cpi	r24, 0x06	; 6
    5bbe:	31 f0       	breq	.+12     	; 0x5bcc <__vector_64+0xa6>
    5bc0:	8c 81       	ldd	r24, Y+4	; 0x04
    5bc2:	86 31       	cpi	r24, 0x16	; 22
    5bc4:	19 f0       	breq	.+6      	; 0x5bcc <__vector_64+0xa6>
    5bc6:	8c 81       	ldd	r24, Y+4	; 0x04
    5bc8:	81 31       	cpi	r24, 0x11	; 17
    5bca:	89 f5       	brne	.+98     	; 0x5c2e <__vector_64+0x108>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    5bcc:	88 e0       	ldi	r24, 0x08	; 8
    5bce:	0e 94 6b 26 	call	0x4cd6	; 0x4cd6 <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    5bd2:	87 e0       	ldi	r24, 0x07	; 7
    5bd4:	0e 94 0d 23 	call	0x461a	; 0x461a <chb_reg_read>
    5bd8:	28 2f       	mov	r18, r24
    5bda:	8a 81       	ldd	r24, Y+2	; 0x02
    5bdc:	9b 81       	ldd	r25, Y+3	; 0x03
    5bde:	fc 01       	movw	r30, r24
    5be0:	22 8b       	std	Z+18, r18	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    5be2:	86 e0       	ldi	r24, 0x06	; 6
    5be4:	0e 94 0d 23 	call	0x461a	; 0x461a <chb_reg_read>
    5be8:	28 2f       	mov	r18, r24
    5bea:	22 1f       	adc	r18, r18
    5bec:	22 27       	eor	r18, r18
    5bee:	22 1f       	adc	r18, r18
    5bf0:	8a 81       	ldd	r24, Y+2	; 0x02
    5bf2:	9b 81       	ldd	r25, Y+3	; 0x03
    5bf4:	fc 01       	movw	r30, r24
    5bf6:	23 8b       	std	Z+19, r18	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5bf8:	8a 81       	ldd	r24, Y+2	; 0x02
    5bfa:	9b 81       	ldd	r25, Y+3	; 0x03
    5bfc:	fc 01       	movw	r30, r24
    5bfe:	83 89       	ldd	r24, Z+19	; 0x13
    5c00:	88 23       	and	r24, r24
    5c02:	d1 f0       	breq	.+52     	; 0x5c38 <__vector_64+0x112>
                    // get the data
                    chb_frame_read();
    5c04:	0e 94 77 24 	call	0x48ee	; 0x48ee <chb_frame_read>
                    pcb->rcvd_xfers++;
    5c08:	8a 81       	ldd	r24, Y+2	; 0x02
    5c0a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c0c:	fc 01       	movw	r30, r24
    5c0e:	85 81       	ldd	r24, Z+5	; 0x05
    5c10:	96 81       	ldd	r25, Z+6	; 0x06
    5c12:	9c 01       	movw	r18, r24
    5c14:	2f 5f       	subi	r18, 0xFF	; 255
    5c16:	3f 4f       	sbci	r19, 0xFF	; 255
    5c18:	8a 81       	ldd	r24, Y+2	; 0x02
    5c1a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c1c:	fc 01       	movw	r30, r24
    5c1e:	25 83       	std	Z+5, r18	; 0x05
    5c20:	36 83       	std	Z+6, r19	; 0x06
                    pcb->data_rcv = true;
    5c22:	8a 81       	ldd	r24, Y+2	; 0x02
    5c24:	9b 81       	ldd	r25, Y+3	; 0x03
    5c26:	21 e0       	ldi	r18, 0x01	; 1
    5c28:	fc 01       	movw	r30, r24
    5c2a:	23 83       	std	Z+3, r18	; 0x03

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5c2c:	05 c0       	rjmp	.+10     	; 0x5c38 <__vector_64+0x112>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    5c2e:	8a 81       	ldd	r24, Y+2	; 0x02
    5c30:	9b 81       	ldd	r25, Y+3	; 0x03
    5c32:	21 e0       	ldi	r18, 0x01	; 1
    5c34:	fc 01       	movw	r30, r24
    5c36:	24 83       	std	Z+4, r18	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    5c38:	89 81       	ldd	r24, Y+1	; 0x01
    5c3a:	87 7f       	andi	r24, 0xF7	; 247
    5c3c:	89 83       	std	Y+1, r24	; 0x01
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    5c3e:	00 00       	nop
    5c40:	86 e1       	ldi	r24, 0x16	; 22
    5c42:	0e 94 6b 26 	call	0x4cd6	; 0x4cd6 <chb_set_state>
    5c46:	80 34       	cpi	r24, 0x40	; 64
    5c48:	d9 f7       	brne	.-10     	; 0x5c40 <__vector_64+0x11a>
    5c4a:	3e c0       	rjmp	.+124    	; 0x5cc8 <__vector_64+0x1a2>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    5c4c:	89 81       	ldd	r24, Y+1	; 0x01
    5c4e:	88 2f       	mov	r24, r24
    5c50:	90 e0       	ldi	r25, 0x00	; 0
    5c52:	80 74       	andi	r24, 0x40	; 64
    5c54:	90 70       	andi	r25, 0x00	; 0
    5c56:	00 97       	sbiw	r24, 0x00	; 0
    5c58:	89 f0       	breq	.+34     	; 0x5c7c <__vector_64+0x156>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    5c5a:	89 81       	ldd	r24, Y+1	; 0x01
    5c5c:	8f 7b       	andi	r24, 0xBF	; 191
    5c5e:	89 83       	std	Y+1, r24	; 0x01
            pcb->underrun++;
    5c60:	8a 81       	ldd	r24, Y+2	; 0x02
    5c62:	9b 81       	ldd	r25, Y+3	; 0x03
    5c64:	fc 01       	movw	r30, r24
    5c66:	87 85       	ldd	r24, Z+15	; 0x0f
    5c68:	90 89       	ldd	r25, Z+16	; 0x10
    5c6a:	9c 01       	movw	r18, r24
    5c6c:	2f 5f       	subi	r18, 0xFF	; 255
    5c6e:	3f 4f       	sbci	r19, 0xFF	; 255
    5c70:	8a 81       	ldd	r24, Y+2	; 0x02
    5c72:	9b 81       	ldd	r25, Y+3	; 0x03
    5c74:	fc 01       	movw	r30, r24
    5c76:	27 87       	std	Z+15, r18	; 0x0f
    5c78:	30 8b       	std	Z+16, r19	; 0x10
    5c7a:	26 c0       	rjmp	.+76     	; 0x5cc8 <__vector_64+0x1a2>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    5c7c:	89 81       	ldd	r24, Y+1	; 0x01
    5c7e:	88 2f       	mov	r24, r24
    5c80:	90 e0       	ldi	r25, 0x00	; 0
    5c82:	82 70       	andi	r24, 0x02	; 2
    5c84:	90 70       	andi	r25, 0x00	; 0
    5c86:	00 97       	sbiw	r24, 0x00	; 0
    5c88:	21 f0       	breq	.+8      	; 0x5c92 <__vector_64+0x16c>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    5c8a:	89 81       	ldd	r24, Y+1	; 0x01
    5c8c:	8d 7f       	andi	r24, 0xFD	; 253
    5c8e:	89 83       	std	Y+1, r24	; 0x01
    5c90:	1b c0       	rjmp	.+54     	; 0x5cc8 <__vector_64+0x1a2>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    5c92:	89 81       	ldd	r24, Y+1	; 0x01
    5c94:	88 2f       	mov	r24, r24
    5c96:	90 e0       	ldi	r25, 0x00	; 0
    5c98:	81 70       	andi	r24, 0x01	; 1
    5c9a:	90 70       	andi	r25, 0x00	; 0
    5c9c:	88 23       	and	r24, r24
    5c9e:	21 f0       	breq	.+8      	; 0x5ca8 <__vector_64+0x182>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    5ca0:	89 81       	ldd	r24, Y+1	; 0x01
    5ca2:	8e 7f       	andi	r24, 0xFE	; 254
    5ca4:	89 83       	std	Y+1, r24	; 0x01
    5ca6:	10 c0       	rjmp	.+32     	; 0x5cc8 <__vector_64+0x1a2>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    5ca8:	89 81       	ldd	r24, Y+1	; 0x01
    5caa:	88 23       	and	r24, r24
    5cac:	6c f4       	brge	.+26     	; 0x5cc8 <__vector_64+0x1a2>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    5cae:	89 81       	ldd	r24, Y+1	; 0x01
    5cb0:	8f 77       	andi	r24, 0x7F	; 127
    5cb2:	89 83       	std	Y+1, r24	; 0x01
            pcb->battlow++;
    5cb4:	8a 81       	ldd	r24, Y+2	; 0x02
    5cb6:	9b 81       	ldd	r25, Y+3	; 0x03
    5cb8:	fc 01       	movw	r30, r24
    5cba:	81 89       	ldd	r24, Z+17	; 0x11
    5cbc:	28 2f       	mov	r18, r24
    5cbe:	2f 5f       	subi	r18, 0xFF	; 255
    5cc0:	8a 81       	ldd	r24, Y+2	; 0x02
    5cc2:	9b 81       	ldd	r25, Y+3	; 0x03
    5cc4:	fc 01       	movw	r30, r24
    5cc6:	21 8b       	std	Z+17, r18	; 0x11
	SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    5cc8:	89 81       	ldd	r24, Y+1	; 0x01
    5cca:	88 23       	and	r24, r24
    5ccc:	09 f0       	breq	.+2      	; 0x5cd0 <__vector_64+0x1aa>
    5cce:	5f cf       	rjmp	.-322    	; 0x5b8e <__vector_64+0x68>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    5cd0:	8f e3       	ldi	r24, 0x3F	; 63
    5cd2:	90 e0       	ldi	r25, 0x00	; 0
    5cd4:	20 91 47 40 	lds	r18, 0x4047
    5cd8:	fc 01       	movw	r30, r24
    5cda:	20 83       	st	Z, r18
    5cdc:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    5cde:	8f e0       	ldi	r24, 0x0F	; 15
    5ce0:	0e 94 0d 23 	call	0x461a	; 0x461a <chb_reg_read>
}
    5ce4:	24 96       	adiw	r28, 0x04	; 4
    5ce6:	cd bf       	out	0x3d, r28	; 61
    5ce8:	de bf       	out	0x3e, r29	; 62
    5cea:	df 91       	pop	r29
    5cec:	cf 91       	pop	r28
    5cee:	ff 91       	pop	r31
    5cf0:	ef 91       	pop	r30
    5cf2:	bf 91       	pop	r27
    5cf4:	af 91       	pop	r26
    5cf6:	9f 91       	pop	r25
    5cf8:	8f 91       	pop	r24
    5cfa:	7f 91       	pop	r23
    5cfc:	6f 91       	pop	r22
    5cfe:	5f 91       	pop	r21
    5d00:	4f 91       	pop	r20
    5d02:	3f 91       	pop	r19
    5d04:	2f 91       	pop	r18
    5d06:	0f 90       	pop	r0
    5d08:	00 92 3b 00 	sts	0x003B, r0
    5d0c:	0f 90       	pop	r0
    5d0e:	0f be       	out	0x3f, r0	; 63
    5d10:	0f 90       	pop	r0
    5d12:	1f 90       	pop	r1
    5d14:	18 95       	reti

00005d16 <RadioCS>:

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
    5d16:	cf 93       	push	r28
    5d18:	df 93       	push	r29
    5d1a:	0f 92       	push	r0
    5d1c:	cd b7       	in	r28, 0x3d	; 61
    5d1e:	de b7       	in	r29, 0x3e	; 62
    5d20:	89 83       	std	Y+1, r24	; 0x01
	if (status) PORTD.OUTCLR = PIN4_bm;
    5d22:	89 81       	ldd	r24, Y+1	; 0x01
    5d24:	88 23       	and	r24, r24
    5d26:	31 f0       	breq	.+12     	; 0x5d34 <RadioCS+0x1e>
    5d28:	80 e6       	ldi	r24, 0x60	; 96
    5d2a:	96 e0       	ldi	r25, 0x06	; 6
    5d2c:	20 e1       	ldi	r18, 0x10	; 16
    5d2e:	fc 01       	movw	r30, r24
    5d30:	26 83       	std	Z+6, r18	; 0x06
    5d32:	05 c0       	rjmp	.+10     	; 0x5d3e <RadioCS+0x28>
	else {
		PORTD.OUTSET = PIN4_bm;
    5d34:	80 e6       	ldi	r24, 0x60	; 96
    5d36:	96 e0       	ldi	r25, 0x06	; 6
    5d38:	20 e1       	ldi	r18, 0x10	; 16
    5d3a:	fc 01       	movw	r30, r24
    5d3c:	25 83       	std	Z+5, r18	; 0x05
	}
    5d3e:	0f 90       	pop	r0
    5d40:	df 91       	pop	r29
    5d42:	cf 91       	pop	r28
    5d44:	08 95       	ret

00005d46 <chb_eep_write_byte>:
/*!

*/
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    5d46:	cf 93       	push	r28
    5d48:	df 93       	push	r29
    5d4a:	00 d0       	rcall	.+0      	; 0x5d4c <chb_eep_write_byte+0x6>
    5d4c:	cd b7       	in	r28, 0x3d	; 61
    5d4e:	de b7       	in	r29, 0x3e	; 62
    5d50:	89 83       	std	Y+1, r24	; 0x01
    5d52:	9a 83       	std	Y+2, r25	; 0x02
    5d54:	6b 83       	std	Y+3, r22	; 0x03
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    5d56:	00 00       	nop
    5d58:	80 ec       	ldi	r24, 0xC0	; 192
    5d5a:	91 e0       	ldi	r25, 0x01	; 1
    5d5c:	fc 01       	movw	r30, r24
    5d5e:	87 85       	ldd	r24, Z+15	; 0x0f
    5d60:	88 23       	and	r24, r24
    5d62:	d4 f3       	brlt	.-12     	; 0x5d58 <chb_eep_write_byte+0x12>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    5d64:	80 ec       	ldi	r24, 0xC0	; 192
    5d66:	91 e0       	ldi	r25, 0x01	; 1
    5d68:	fc 01       	movw	r30, r24
    5d6a:	87 85       	ldd	r24, Z+15	; 0x0f
    5d6c:	88 2f       	mov	r24, r24
    5d6e:	90 e0       	ldi	r25, 0x00	; 0
    5d70:	82 70       	andi	r24, 0x02	; 2
    5d72:	90 70       	andi	r25, 0x00	; 0
    5d74:	00 97       	sbiw	r24, 0x00	; 0
    5d76:	99 f0       	breq	.+38     	; 0x5d9e <chb_eep_write_byte+0x58>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    5d78:	80 ec       	ldi	r24, 0xC0	; 192
    5d7a:	91 e0       	ldi	r25, 0x01	; 1
    5d7c:	26 e3       	ldi	r18, 0x36	; 54
    5d7e:	fc 01       	movw	r30, r24
    5d80:	22 87       	std	Z+10, r18	; 0x0a
        NVM_EXEC();
    5d82:	ef 93       	push	r30
    5d84:	ff 93       	push	r31
    5d86:	0f 93       	push	r16
    5d88:	2f 93       	push	r18
    5d8a:	eb ec       	ldi	r30, 0xCB	; 203
    5d8c:	f1 e0       	ldi	r31, 0x01	; 1
    5d8e:	08 ed       	ldi	r16, 0xD8	; 216
    5d90:	21 e0       	ldi	r18, 0x01	; 1
    5d92:	04 bf       	out	0x34, r16	; 52
    5d94:	20 83       	st	Z, r18
    5d96:	2f 91       	pop	r18
    5d98:	0f 91       	pop	r16
    5d9a:	ff 91       	pop	r31
    5d9c:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    5d9e:	80 ec       	ldi	r24, 0xC0	; 192
    5da0:	91 e0       	ldi	r25, 0x01	; 1
    5da2:	23 e3       	ldi	r18, 0x33	; 51
    5da4:	fc 01       	movw	r30, r24
    5da6:	22 87       	std	Z+10, r18	; 0x0a

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    5da8:	80 ec       	ldi	r24, 0xC0	; 192
    5daa:	91 e0       	ldi	r25, 0x01	; 1
    5dac:	29 81       	ldd	r18, Y+1	; 0x01
    5dae:	fc 01       	movw	r30, r24
    5db0:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    5db2:	80 ec       	ldi	r24, 0xC0	; 192
    5db4:	91 e0       	ldi	r25, 0x01	; 1
    5db6:	29 81       	ldd	r18, Y+1	; 0x01
    5db8:	3a 81       	ldd	r19, Y+2	; 0x02
    5dba:	23 2f       	mov	r18, r19
    5dbc:	33 27       	eor	r19, r19
    5dbe:	2f 71       	andi	r18, 0x1F	; 31
    5dc0:	fc 01       	movw	r30, r24
    5dc2:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    5dc4:	80 ec       	ldi	r24, 0xC0	; 192
    5dc6:	91 e0       	ldi	r25, 0x01	; 1
    5dc8:	fc 01       	movw	r30, r24
    5dca:	12 82       	std	Z+2, r1	; 0x02

    // load the data to write
    NVM.DATA0 = value;
    5dcc:	80 ec       	ldi	r24, 0xC0	; 192
    5dce:	91 e0       	ldi	r25, 0x01	; 1
    5dd0:	2b 81       	ldd	r18, Y+3	; 0x03
    5dd2:	fc 01       	movw	r30, r24
    5dd4:	24 83       	std	Z+4, r18	; 0x04

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    5dd6:	80 ec       	ldi	r24, 0xC0	; 192
    5dd8:	91 e0       	ldi	r25, 0x01	; 1
    5dda:	25 e3       	ldi	r18, 0x35	; 53
    5ddc:	fc 01       	movw	r30, r24
    5dde:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    5de0:	ef 93       	push	r30
    5de2:	ff 93       	push	r31
    5de4:	0f 93       	push	r16
    5de6:	2f 93       	push	r18
    5de8:	eb ec       	ldi	r30, 0xCB	; 203
    5dea:	f1 e0       	ldi	r31, 0x01	; 1
    5dec:	08 ed       	ldi	r16, 0xD8	; 216
    5dee:	21 e0       	ldi	r18, 0x01	; 1
    5df0:	04 bf       	out	0x34, r16	; 52
    5df2:	20 83       	st	Z, r18
    5df4:	2f 91       	pop	r18
    5df6:	0f 91       	pop	r16
    5df8:	ff 91       	pop	r31
    5dfa:	ef 91       	pop	r30
}
    5dfc:	23 96       	adiw	r28, 0x03	; 3
    5dfe:	cd bf       	out	0x3d, r28	; 61
    5e00:	de bf       	out	0x3e, r29	; 62
    5e02:	df 91       	pop	r29
    5e04:	cf 91       	pop	r28
    5e06:	08 95       	ret

00005e08 <chb_eep_read_byte>:
/*!

*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    5e08:	cf 93       	push	r28
    5e0a:	df 93       	push	r29
    5e0c:	0f 92       	push	r0
    5e0e:	0f 92       	push	r0
    5e10:	cd b7       	in	r28, 0x3d	; 61
    5e12:	de b7       	in	r29, 0x3e	; 62
    5e14:	89 83       	std	Y+1, r24	; 0x01
    5e16:	9a 83       	std	Y+2, r25	; 0x02
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    5e18:	00 00       	nop
    5e1a:	80 ec       	ldi	r24, 0xC0	; 192
    5e1c:	91 e0       	ldi	r25, 0x01	; 1
    5e1e:	fc 01       	movw	r30, r24
    5e20:	87 85       	ldd	r24, Z+15	; 0x0f
    5e22:	88 23       	and	r24, r24
    5e24:	d4 f3       	brlt	.-12     	; 0x5e1a <chb_eep_read_byte+0x12>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    5e26:	80 ec       	ldi	r24, 0xC0	; 192
    5e28:	91 e0       	ldi	r25, 0x01	; 1
    5e2a:	29 81       	ldd	r18, Y+1	; 0x01
    5e2c:	fc 01       	movw	r30, r24
    5e2e:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    5e30:	80 ec       	ldi	r24, 0xC0	; 192
    5e32:	91 e0       	ldi	r25, 0x01	; 1
    5e34:	29 81       	ldd	r18, Y+1	; 0x01
    5e36:	3a 81       	ldd	r19, Y+2	; 0x02
    5e38:	23 2f       	mov	r18, r19
    5e3a:	33 27       	eor	r19, r19
    5e3c:	2f 71       	andi	r18, 0x1F	; 31
    5e3e:	fc 01       	movw	r30, r24
    5e40:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    5e42:	80 ec       	ldi	r24, 0xC0	; 192
    5e44:	91 e0       	ldi	r25, 0x01	; 1
    5e46:	fc 01       	movw	r30, r24
    5e48:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    5e4a:	80 ec       	ldi	r24, 0xC0	; 192
    5e4c:	91 e0       	ldi	r25, 0x01	; 1
    5e4e:	26 e0       	ldi	r18, 0x06	; 6
    5e50:	fc 01       	movw	r30, r24
    5e52:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    5e54:	ef 93       	push	r30
    5e56:	ff 93       	push	r31
    5e58:	0f 93       	push	r16
    5e5a:	2f 93       	push	r18
    5e5c:	eb ec       	ldi	r30, 0xCB	; 203
    5e5e:	f1 e0       	ldi	r31, 0x01	; 1
    5e60:	08 ed       	ldi	r16, 0xD8	; 216
    5e62:	21 e0       	ldi	r18, 0x01	; 1
    5e64:	04 bf       	out	0x34, r16	; 52
    5e66:	20 83       	st	Z, r18
    5e68:	2f 91       	pop	r18
    5e6a:	0f 91       	pop	r16
    5e6c:	ff 91       	pop	r31
    5e6e:	ef 91       	pop	r30

    return NVM.DATA0;
    5e70:	80 ec       	ldi	r24, 0xC0	; 192
    5e72:	91 e0       	ldi	r25, 0x01	; 1
    5e74:	fc 01       	movw	r30, r24
    5e76:	84 81       	ldd	r24, Z+4	; 0x04
}
    5e78:	0f 90       	pop	r0
    5e7a:	0f 90       	pop	r0
    5e7c:	df 91       	pop	r29
    5e7e:	cf 91       	pop	r28
    5e80:	08 95       	ret

00005e82 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    5e82:	cf 93       	push	r28
    5e84:	df 93       	push	r29
    5e86:	cd b7       	in	r28, 0x3d	; 61
    5e88:	de b7       	in	r29, 0x3e	; 62
    5e8a:	27 97       	sbiw	r28, 0x07	; 7
    5e8c:	cd bf       	out	0x3d, r28	; 61
    5e8e:	de bf       	out	0x3e, r29	; 62
    5e90:	8a 83       	std	Y+2, r24	; 0x02
    5e92:	9b 83       	std	Y+3, r25	; 0x03
    5e94:	6c 83       	std	Y+4, r22	; 0x04
    5e96:	7d 83       	std	Y+5, r23	; 0x05
    5e98:	4e 83       	std	Y+6, r20	; 0x06
    5e9a:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    5e9c:	80 ec       	ldi	r24, 0xC0	; 192
    5e9e:	91 e0       	ldi	r25, 0x01	; 1
    5ea0:	20 ec       	ldi	r18, 0xC0	; 192
    5ea2:	31 e0       	ldi	r19, 0x01	; 1
    5ea4:	f9 01       	movw	r30, r18
    5ea6:	24 85       	ldd	r18, Z+12	; 0x0c
    5ea8:	27 7f       	andi	r18, 0xF7	; 247
    5eaa:	fc 01       	movw	r30, r24
    5eac:	24 87       	std	Z+12, r18	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    5eae:	19 82       	std	Y+1, r1	; 0x01
    5eb0:	16 c0       	rjmp	.+44     	; 0x5ede <chb_eeprom_write+0x5c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    5eb2:	89 81       	ldd	r24, Y+1	; 0x01
    5eb4:	28 2f       	mov	r18, r24
    5eb6:	30 e0       	ldi	r19, 0x00	; 0
    5eb8:	8a 81       	ldd	r24, Y+2	; 0x02
    5eba:	9b 81       	ldd	r25, Y+3	; 0x03
    5ebc:	82 0f       	add	r24, r18
    5ebe:	93 1f       	adc	r25, r19
    5ec0:	29 81       	ldd	r18, Y+1	; 0x01
    5ec2:	22 2f       	mov	r18, r18
    5ec4:	30 e0       	ldi	r19, 0x00	; 0
    5ec6:	4c 81       	ldd	r20, Y+4	; 0x04
    5ec8:	5d 81       	ldd	r21, Y+5	; 0x05
    5eca:	24 0f       	add	r18, r20
    5ecc:	35 1f       	adc	r19, r21
    5ece:	f9 01       	movw	r30, r18
    5ed0:	20 81       	ld	r18, Z
    5ed2:	62 2f       	mov	r22, r18
    5ed4:	0e 94 a3 2e 	call	0x5d46	; 0x5d46 <chb_eep_write_byte>
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    5ed8:	89 81       	ldd	r24, Y+1	; 0x01
    5eda:	8f 5f       	subi	r24, 0xFF	; 255
    5edc:	89 83       	std	Y+1, r24	; 0x01
    5ede:	89 81       	ldd	r24, Y+1	; 0x01
    5ee0:	28 2f       	mov	r18, r24
    5ee2:	30 e0       	ldi	r19, 0x00	; 0
    5ee4:	8e 81       	ldd	r24, Y+6	; 0x06
    5ee6:	9f 81       	ldd	r25, Y+7	; 0x07
    5ee8:	28 17       	cp	r18, r24
    5eea:	39 07       	cpc	r19, r25
    5eec:	10 f3       	brcs	.-60     	; 0x5eb2 <chb_eeprom_write+0x30>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    5eee:	27 96       	adiw	r28, 0x07	; 7
    5ef0:	cd bf       	out	0x3d, r28	; 61
    5ef2:	de bf       	out	0x3e, r29	; 62
    5ef4:	df 91       	pop	r29
    5ef6:	cf 91       	pop	r28
    5ef8:	08 95       	ret

00005efa <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    5efa:	0f 93       	push	r16
    5efc:	1f 93       	push	r17
    5efe:	cf 93       	push	r28
    5f00:	df 93       	push	r29
    5f02:	cd b7       	in	r28, 0x3d	; 61
    5f04:	de b7       	in	r29, 0x3e	; 62
    5f06:	27 97       	sbiw	r28, 0x07	; 7
    5f08:	cd bf       	out	0x3d, r28	; 61
    5f0a:	de bf       	out	0x3e, r29	; 62
    5f0c:	8a 83       	std	Y+2, r24	; 0x02
    5f0e:	9b 83       	std	Y+3, r25	; 0x03
    5f10:	6c 83       	std	Y+4, r22	; 0x04
    5f12:	7d 83       	std	Y+5, r23	; 0x05
    5f14:	4e 83       	std	Y+6, r20	; 0x06
    5f16:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    5f18:	80 ec       	ldi	r24, 0xC0	; 192
    5f1a:	91 e0       	ldi	r25, 0x01	; 1
    5f1c:	20 ec       	ldi	r18, 0xC0	; 192
    5f1e:	31 e0       	ldi	r19, 0x01	; 1
    5f20:	f9 01       	movw	r30, r18
    5f22:	24 85       	ldd	r18, Z+12	; 0x0c
    5f24:	27 7f       	andi	r18, 0xF7	; 247
    5f26:	fc 01       	movw	r30, r24
    5f28:	24 87       	std	Z+12, r18	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    5f2a:	19 82       	std	Y+1, r1	; 0x01
    5f2c:	16 c0       	rjmp	.+44     	; 0x5f5a <chb_eeprom_read+0x60>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    5f2e:	89 81       	ldd	r24, Y+1	; 0x01
    5f30:	88 2f       	mov	r24, r24
    5f32:	90 e0       	ldi	r25, 0x00	; 0
    5f34:	2c 81       	ldd	r18, Y+4	; 0x04
    5f36:	3d 81       	ldd	r19, Y+5	; 0x05
    5f38:	89 01       	movw	r16, r18
    5f3a:	08 0f       	add	r16, r24
    5f3c:	19 1f       	adc	r17, r25
    5f3e:	89 81       	ldd	r24, Y+1	; 0x01
    5f40:	28 2f       	mov	r18, r24
    5f42:	30 e0       	ldi	r19, 0x00	; 0
    5f44:	8a 81       	ldd	r24, Y+2	; 0x02
    5f46:	9b 81       	ldd	r25, Y+3	; 0x03
    5f48:	82 0f       	add	r24, r18
    5f4a:	93 1f       	adc	r25, r19
    5f4c:	0e 94 04 2f 	call	0x5e08	; 0x5e08 <chb_eep_read_byte>
    5f50:	f8 01       	movw	r30, r16
    5f52:	80 83       	st	Z, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    5f54:	89 81       	ldd	r24, Y+1	; 0x01
    5f56:	8f 5f       	subi	r24, 0xFF	; 255
    5f58:	89 83       	std	Y+1, r24	; 0x01
    5f5a:	89 81       	ldd	r24, Y+1	; 0x01
    5f5c:	28 2f       	mov	r18, r24
    5f5e:	30 e0       	ldi	r19, 0x00	; 0
    5f60:	8e 81       	ldd	r24, Y+6	; 0x06
    5f62:	9f 81       	ldd	r25, Y+7	; 0x07
    5f64:	28 17       	cp	r18, r24
    5f66:	39 07       	cpc	r19, r25
    5f68:	10 f3       	brcs	.-60     	; 0x5f2e <chb_eeprom_read+0x34>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    5f6a:	27 96       	adiw	r28, 0x07	; 7
    5f6c:	cd bf       	out	0x3d, r28	; 61
    5f6e:	de bf       	out	0x3e, r29	; 62
    5f70:	df 91       	pop	r29
    5f72:	cf 91       	pop	r28
    5f74:	1f 91       	pop	r17
    5f76:	0f 91       	pop	r16
    5f78:	08 95       	ret

00005f7a <chb_spi_init>:

*/
/**************************************************************************/

void chb_spi_init()
{
    5f7a:	cf 93       	push	r28
    5f7c:	df 93       	push	r29
    5f7e:	cd b7       	in	r28, 0x3d	; 61
    5f80:	de b7       	in	r29, 0x3e	; 62
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    5f82:	80 e6       	ldi	r24, 0x60	; 96
    5f84:	96 e0       	ldi	r25, 0x06	; 6
    5f86:	20 e6       	ldi	r18, 0x60	; 96
    5f88:	36 e0       	ldi	r19, 0x06	; 6
    5f8a:	f9 01       	movw	r30, r18
    5f8c:	20 81       	ld	r18, Z
    5f8e:	20 6b       	ori	r18, 0xB0	; 176
    5f90:	fc 01       	movw	r30, r24
    5f92:	20 83       	st	Z, r18
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    5f94:	84 e6       	ldi	r24, 0x64	; 100
    5f96:	96 e0       	ldi	r25, 0x06	; 6
    5f98:	24 e6       	ldi	r18, 0x64	; 100
    5f9a:	36 e0       	ldi	r19, 0x06	; 6
    5f9c:	f9 01       	movw	r30, r18
    5f9e:	20 81       	ld	r18, Z
    5fa0:	20 61       	ori	r18, 0x10	; 16
    5fa2:	fc 01       	movw	r30, r24
    5fa4:	20 83       	st	Z, r18

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    5fa6:	80 ec       	ldi	r24, 0xC0	; 192
    5fa8:	99 e0       	ldi	r25, 0x09	; 9
    5faa:	20 ec       	ldi	r18, 0xC0	; 192
    5fac:	39 e0       	ldi	r19, 0x09	; 9
    5fae:	f9 01       	movw	r30, r18
    5fb0:	20 81       	ld	r18, Z
    5fb2:	21 65       	ori	r18, 0x51	; 81
    5fb4:	fc 01       	movw	r30, r24
    5fb6:	20 83       	st	Z, r18

    // set the slave select to idle
    CHB_SPI_DISABLE();
    5fb8:	84 e6       	ldi	r24, 0x64	; 100
    5fba:	96 e0       	ldi	r25, 0x06	; 6
    5fbc:	24 e6       	ldi	r18, 0x64	; 100
    5fbe:	36 e0       	ldi	r19, 0x06	; 6
    5fc0:	f9 01       	movw	r30, r18
    5fc2:	20 81       	ld	r18, Z
    5fc4:	20 61       	ori	r18, 0x10	; 16
    5fc6:	fc 01       	movw	r30, r24
    5fc8:	20 83       	st	Z, r18
}
    5fca:	df 91       	pop	r29
    5fcc:	cf 91       	pop	r28
    5fce:	08 95       	ret

00005fd0 <SPID_write>:
    This function both reads and writes data. For write operations, include data
    to be written as argument. For read ops, use dummy data as arg. Returned
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
    5fd0:	cf 93       	push	r28
    5fd2:	df 93       	push	r29
    5fd4:	0f 92       	push	r0
    5fd6:	0f 92       	push	r0
    5fd8:	cd b7       	in	r28, 0x3d	; 61
    5fda:	de b7       	in	r29, 0x3e	; 62
    5fdc:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPID.DATA = byteToSend;
    5fde:	80 ec       	ldi	r24, 0xC0	; 192
    5fe0:	99 e0       	ldi	r25, 0x09	; 9
    5fe2:	2a 81       	ldd	r18, Y+2	; 0x02
    5fe4:	fc 01       	movw	r30, r24
    5fe6:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    5fe8:	00 00       	nop
    5fea:	80 ec       	ldi	r24, 0xC0	; 192
    5fec:	99 e0       	ldi	r25, 0x09	; 9
    5fee:	fc 01       	movw	r30, r24
    5ff0:	82 81       	ldd	r24, Z+2	; 0x02
    5ff2:	88 23       	and	r24, r24
    5ff4:	d4 f7       	brge	.-12     	; 0x5fea <SPID_write+0x1a>
	data = SPID.DATA; //read SPI data register to reset status flag
    5ff6:	80 ec       	ldi	r24, 0xC0	; 192
    5ff8:	99 e0       	ldi	r25, 0x09	; 9
    5ffa:	fc 01       	movw	r30, r24
    5ffc:	83 81       	ldd	r24, Z+3	; 0x03
    5ffe:	89 83       	std	Y+1, r24	; 0x01
	return data;
    6000:	89 81       	ldd	r24, Y+1	; 0x01
    6002:	0f 90       	pop	r0
    6004:	0f 90       	pop	r0
    6006:	df 91       	pop	r29
    6008:	cf 91       	pop	r28
    600a:	08 95       	ret

0000600c <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    600c:	0f 93       	push	r16
    600e:	cf 93       	push	r28
    6010:	df 93       	push	r29
    6012:	00 d0       	rcall	.+0      	; 0x6014 <CCPWrite+0x8>
    6014:	00 d0       	rcall	.+0      	; 0x6016 <CCPWrite+0xa>
    6016:	cd b7       	in	r28, 0x3d	; 61
    6018:	de b7       	in	r29, 0x3e	; 62
    601a:	8c 83       	std	Y+4, r24	; 0x04
    601c:	9d 83       	std	Y+5, r25	; 0x05
    601e:	6e 83       	std	Y+6, r22	; 0x06

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    6020:	8f e3       	ldi	r24, 0x3F	; 63
    6022:	90 e0       	ldi	r25, 0x00	; 0
    6024:	fc 01       	movw	r30, r24
    6026:	80 81       	ld	r24, Z
    6028:	8b 83       	std	Y+3, r24	; 0x03
    602a:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
    602c:	8c 81       	ldd	r24, Y+4	; 0x04
    602e:	9d 81       	ldd	r25, Y+5	; 0x05
    6030:	89 83       	std	Y+1, r24	; 0x01
    6032:	9a 83       	std	Y+2, r25	; 0x02
#ifdef RAMPZ
	RAMPZ = 0;
    6034:	8b e3       	ldi	r24, 0x3B	; 59
    6036:	90 e0       	ldi	r25, 0x00	; 0
    6038:	fc 01       	movw	r30, r24
    603a:	10 82       	st	Z, r1
#endif
	asm volatile(
    603c:	89 81       	ldd	r24, Y+1	; 0x01
    603e:	9a 81       	ldd	r25, Y+2	; 0x02
    6040:	2e 81       	ldd	r18, Y+6	; 0x06
    6042:	fc 01       	movw	r30, r24
    6044:	08 ed       	ldi	r16, 0xD8	; 216
    6046:	04 bf       	out	0x34, r16	; 52
    6048:	20 83       	st	Z, r18
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    604a:	8f e3       	ldi	r24, 0x3F	; 63
    604c:	90 e0       	ldi	r25, 0x00	; 0
    604e:	2b 81       	ldd	r18, Y+3	; 0x03
    6050:	fc 01       	movw	r30, r24
    6052:	20 83       	st	Z, r18
#endif
}
    6054:	26 96       	adiw	r28, 0x06	; 6
    6056:	cd bf       	out	0x3d, r28	; 61
    6058:	de bf       	out	0x3e, r29	; 62
    605a:	df 91       	pop	r29
    605c:	cf 91       	pop	r28
    605e:	0f 91       	pop	r16
    6060:	08 95       	ret

00006062 <CLKSYS_XOSC_Config>:
 *                             external clock) and startup times.
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
    6062:	cf 93       	push	r28
    6064:	df 93       	push	r29
    6066:	00 d0       	rcall	.+0      	; 0x6068 <CLKSYS_XOSC_Config+0x6>
    6068:	cd b7       	in	r28, 0x3d	; 61
    606a:	de b7       	in	r29, 0x3e	; 62
    606c:	89 83       	std	Y+1, r24	; 0x01
    606e:	6a 83       	std	Y+2, r22	; 0x02
    6070:	4b 83       	std	Y+3, r20	; 0x03
	OSC.XOSCCTRL = (uint8_t) freqRange |
    6072:	80 e5       	ldi	r24, 0x50	; 80
    6074:	90 e0       	ldi	r25, 0x00	; 0
    6076:	2a 81       	ldd	r18, Y+2	; 0x02
    6078:	22 23       	and	r18, r18
    607a:	11 f0       	breq	.+4      	; 0x6080 <CLKSYS_XOSC_Config+0x1e>
    607c:	20 e2       	ldi	r18, 0x20	; 32
    607e:	01 c0       	rjmp	.+2      	; 0x6082 <CLKSYS_XOSC_Config+0x20>
    6080:	20 e0       	ldi	r18, 0x00	; 0
    6082:	39 81       	ldd	r19, Y+1	; 0x01
    6084:	32 2b       	or	r19, r18
    6086:	2b 81       	ldd	r18, Y+3	; 0x03
    6088:	23 2b       	or	r18, r19
    608a:	fc 01       	movw	r30, r24
    608c:	22 83       	std	Z+2, r18	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    608e:	23 96       	adiw	r28, 0x03	; 3
    6090:	cd bf       	out	0x3d, r28	; 61
    6092:	de bf       	out	0x3e, r29	; 62
    6094:	df 91       	pop	r29
    6096:	cf 91       	pop	r28
    6098:	08 95       	ret

0000609a <CLKSYS_PLL_Config>:
 *                      must be above 0.4MHz.
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
    609a:	cf 93       	push	r28
    609c:	df 93       	push	r29
    609e:	0f 92       	push	r0
    60a0:	0f 92       	push	r0
    60a2:	cd b7       	in	r28, 0x3d	; 61
    60a4:	de b7       	in	r29, 0x3e	; 62
    60a6:	89 83       	std	Y+1, r24	; 0x01
    60a8:	6a 83       	std	Y+2, r22	; 0x02
	factor &= OSC_PLLFAC_gm;
    60aa:	8a 81       	ldd	r24, Y+2	; 0x02
    60ac:	8f 71       	andi	r24, 0x1F	; 31
    60ae:	8a 83       	std	Y+2, r24	; 0x02
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    60b0:	80 e5       	ldi	r24, 0x50	; 80
    60b2:	90 e0       	ldi	r25, 0x00	; 0
    60b4:	39 81       	ldd	r19, Y+1	; 0x01
    60b6:	2a 81       	ldd	r18, Y+2	; 0x02
    60b8:	23 2b       	or	r18, r19
    60ba:	fc 01       	movw	r30, r24
    60bc:	25 83       	std	Z+5, r18	; 0x05
}
    60be:	0f 90       	pop	r0
    60c0:	0f 90       	pop	r0
    60c2:	df 91       	pop	r29
    60c4:	cf 91       	pop	r28
    60c6:	08 95       	ret

000060c8 <CLKSYS_Disable>:
 *                 OSC_XOSCEN_bm, OSC_PLLEN_bm.
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
    60c8:	cf 93       	push	r28
    60ca:	df 93       	push	r29
    60cc:	0f 92       	push	r0
    60ce:	0f 92       	push	r0
    60d0:	cd b7       	in	r28, 0x3d	; 61
    60d2:	de b7       	in	r29, 0x3e	; 62
    60d4:	8a 83       	std	Y+2, r24	; 0x02
	OSC.CTRL &= ~oscSel;
    60d6:	80 e5       	ldi	r24, 0x50	; 80
    60d8:	90 e0       	ldi	r25, 0x00	; 0
    60da:	20 e5       	ldi	r18, 0x50	; 80
    60dc:	30 e0       	ldi	r19, 0x00	; 0
    60de:	f9 01       	movw	r30, r18
    60e0:	20 81       	ld	r18, Z
    60e2:	32 2f       	mov	r19, r18
    60e4:	2a 81       	ldd	r18, Y+2	; 0x02
    60e6:	20 95       	com	r18
    60e8:	23 23       	and	r18, r19
    60ea:	fc 01       	movw	r30, r24
    60ec:	20 83       	st	Z, r18
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    60ee:	80 e5       	ldi	r24, 0x50	; 80
    60f0:	90 e0       	ldi	r25, 0x00	; 0
    60f2:	fc 01       	movw	r30, r24
    60f4:	90 81       	ld	r25, Z
    60f6:	8a 81       	ldd	r24, Y+2	; 0x02
    60f8:	89 23       	and	r24, r25
    60fa:	89 83       	std	Y+1, r24	; 0x01
	return clkEnabled;
    60fc:	89 81       	ldd	r24, Y+1	; 0x01
}
    60fe:	0f 90       	pop	r0
    6100:	0f 90       	pop	r0
    6102:	df 91       	pop	r29
    6104:	cf 91       	pop	r28
    6106:	08 95       	ret

00006108 <CLKSYS_Prescalers_Config>:
 *  \param  PSBCfactor  Prescaler B and C division factor, in the combination
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
    6108:	cf 93       	push	r28
    610a:	df 93       	push	r29
    610c:	00 d0       	rcall	.+0      	; 0x610e <CLKSYS_Prescalers_Config+0x6>
    610e:	cd b7       	in	r28, 0x3d	; 61
    6110:	de b7       	in	r29, 0x3e	; 62
    6112:	8a 83       	std	Y+2, r24	; 0x02
    6114:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    6116:	9a 81       	ldd	r25, Y+2	; 0x02
    6118:	8b 81       	ldd	r24, Y+3	; 0x03
    611a:	89 2b       	or	r24, r25
    611c:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.PSCTRL, PSconfig );
    611e:	81 e4       	ldi	r24, 0x41	; 65
    6120:	90 e0       	ldi	r25, 0x00	; 0
    6122:	69 81       	ldd	r22, Y+1	; 0x01
    6124:	0e 94 06 30 	call	0x600c	; 0x600c <CCPWrite>
}
    6128:	23 96       	adiw	r28, 0x03	; 3
    612a:	cd bf       	out	0x3d, r28	; 61
    612c:	de bf       	out	0x3e, r29	; 62
    612e:	df 91       	pop	r29
    6130:	cf 91       	pop	r28
    6132:	08 95       	ret

00006134 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    6134:	cf 93       	push	r28
    6136:	df 93       	push	r29
    6138:	0f 92       	push	r0
    613a:	0f 92       	push	r0
    613c:	cd b7       	in	r28, 0x3d	; 61
    613e:	de b7       	in	r29, 0x3e	; 62
    6140:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    6142:	80 e4       	ldi	r24, 0x40	; 64
    6144:	90 e0       	ldi	r25, 0x00	; 0
    6146:	fc 01       	movw	r30, r24
    6148:	80 81       	ld	r24, Z
    614a:	98 2f       	mov	r25, r24
    614c:	98 7f       	andi	r25, 0xF8	; 248
    614e:	8a 81       	ldd	r24, Y+2	; 0x02
    6150:	89 2b       	or	r24, r25
    6152:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.CTRL, clkCtrl );
    6154:	80 e4       	ldi	r24, 0x40	; 64
    6156:	90 e0       	ldi	r25, 0x00	; 0
    6158:	69 81       	ldd	r22, Y+1	; 0x01
    615a:	0e 94 06 30 	call	0x600c	; 0x600c <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    615e:	80 e4       	ldi	r24, 0x40	; 64
    6160:	90 e0       	ldi	r25, 0x00	; 0
    6162:	fc 01       	movw	r30, r24
    6164:	90 81       	ld	r25, Z
    6166:	8a 81       	ldd	r24, Y+2	; 0x02
    6168:	89 23       	and	r24, r25
    616a:	89 83       	std	Y+1, r24	; 0x01
	return clkCtrl;
    616c:	89 81       	ldd	r24, Y+1	; 0x01
}
    616e:	0f 90       	pop	r0
    6170:	0f 90       	pop	r0
    6172:	df 91       	pop	r29
    6174:	cf 91       	pop	r28
    6176:	08 95       	ret

00006178 <CLKSYS_RTC_ClockSource_Enable>:
 *  and enables clock signal routing to the RTC module.
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
    6178:	cf 93       	push	r28
    617a:	df 93       	push	r29
    617c:	0f 92       	push	r0
    617e:	cd b7       	in	r28, 0x3d	; 61
    6180:	de b7       	in	r29, 0x3e	; 62
    6182:	89 83       	std	Y+1, r24	; 0x01
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    6184:	80 e4       	ldi	r24, 0x40	; 64
    6186:	90 e0       	ldi	r25, 0x00	; 0
    6188:	20 e4       	ldi	r18, 0x40	; 64
    618a:	30 e0       	ldi	r19, 0x00	; 0
    618c:	f9 01       	movw	r30, r18
    618e:	23 81       	ldd	r18, Z+3	; 0x03
    6190:	32 2f       	mov	r19, r18
    6192:	31 7f       	andi	r19, 0xF1	; 241
    6194:	29 81       	ldd	r18, Y+1	; 0x01
    6196:	23 2b       	or	r18, r19
    6198:	21 60       	ori	r18, 0x01	; 1
    619a:	fc 01       	movw	r30, r24
    619c:	23 83       	std	Z+3, r18	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    619e:	0f 90       	pop	r0
    61a0:	df 91       	pop	r29
    61a2:	cf 91       	pop	r28
    61a4:	08 95       	ret

000061a6 <CLKSYS_AutoCalibration_Enable>:
 *  \param  clkSource    Clock source to calibrate, either OSC_RC2MCREF_bm or
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
    61a6:	cf 93       	push	r28
    61a8:	df 93       	push	r29
    61aa:	0f 92       	push	r0
    61ac:	0f 92       	push	r0
    61ae:	cd b7       	in	r28, 0x3d	; 61
    61b0:	de b7       	in	r29, 0x3e	; 62
    61b2:	89 83       	std	Y+1, r24	; 0x01
    61b4:	6a 83       	std	Y+2, r22	; 0x02
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    61b6:	80 e5       	ldi	r24, 0x50	; 80
    61b8:	90 e0       	ldi	r25, 0x00	; 0
    61ba:	20 e5       	ldi	r18, 0x50	; 80
    61bc:	30 e0       	ldi	r19, 0x00	; 0
    61be:	f9 01       	movw	r30, r18
    61c0:	26 81       	ldd	r18, Z+6	; 0x06
    61c2:	32 2f       	mov	r19, r18
    61c4:	29 81       	ldd	r18, Y+1	; 0x01
    61c6:	20 95       	com	r18
    61c8:	32 23       	and	r19, r18
    61ca:	2a 81       	ldd	r18, Y+2	; 0x02
    61cc:	22 23       	and	r18, r18
    61ce:	11 f0       	breq	.+4      	; 0x61d4 <CLKSYS_AutoCalibration_Enable+0x2e>
    61d0:	29 81       	ldd	r18, Y+1	; 0x01
    61d2:	01 c0       	rjmp	.+2      	; 0x61d6 <CLKSYS_AutoCalibration_Enable+0x30>
    61d4:	20 e0       	ldi	r18, 0x00	; 0
    61d6:	23 2b       	or	r18, r19
    61d8:	fc 01       	movw	r30, r24
    61da:	26 83       	std	Z+6, r18	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    61dc:	89 81       	ldd	r24, Y+1	; 0x01
    61de:	81 30       	cpi	r24, 0x01	; 1
    61e0:	51 f4       	brne	.+20     	; 0x61f6 <CLKSYS_AutoCalibration_Enable+0x50>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    61e2:	88 e6       	ldi	r24, 0x68	; 104
    61e4:	90 e0       	ldi	r25, 0x00	; 0
    61e6:	28 e6       	ldi	r18, 0x68	; 104
    61e8:	30 e0       	ldi	r19, 0x00	; 0
    61ea:	f9 01       	movw	r30, r18
    61ec:	20 81       	ld	r18, Z
    61ee:	21 60       	ori	r18, 0x01	; 1
    61f0:	fc 01       	movw	r30, r24
    61f2:	20 83       	st	Z, r18
    61f4:	0c c0       	rjmp	.+24     	; 0x620e <CLKSYS_AutoCalibration_Enable+0x68>
	} else if (clkSource == OSC_RC32MCREF_bm) {
    61f6:	89 81       	ldd	r24, Y+1	; 0x01
    61f8:	82 30       	cpi	r24, 0x02	; 2
    61fa:	49 f4       	brne	.+18     	; 0x620e <CLKSYS_AutoCalibration_Enable+0x68>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    61fc:	80 e6       	ldi	r24, 0x60	; 96
    61fe:	90 e0       	ldi	r25, 0x00	; 0
    6200:	20 e6       	ldi	r18, 0x60	; 96
    6202:	30 e0       	ldi	r19, 0x00	; 0
    6204:	f9 01       	movw	r30, r18
    6206:	20 81       	ld	r18, Z
    6208:	21 60       	ori	r18, 0x01	; 1
    620a:	fc 01       	movw	r30, r24
    620c:	20 83       	st	Z, r18
	}
}
    620e:	0f 90       	pop	r0
    6210:	0f 90       	pop	r0
    6212:	df 91       	pop	r29
    6214:	cf 91       	pop	r28
    6216:	08 95       	ret

00006218 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  XOSCFD _will_ issue the XOSCF Non-maskable Interrupt (NMI) regardless of
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
    6218:	cf 93       	push	r28
    621a:	df 93       	push	r29
    621c:	cd b7       	in	r28, 0x3d	; 61
    621e:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    6220:	83 e5       	ldi	r24, 0x53	; 83
    6222:	90 e0       	ldi	r25, 0x00	; 0
    6224:	63 e0       	ldi	r22, 0x03	; 3
    6226:	0e 94 06 30 	call	0x600c	; 0x600c <CCPWrite>
}
    622a:	df 91       	pop	r29
    622c:	cf 91       	pop	r28
    622e:	08 95       	ret

00006230 <CLKSYS_Configuration_Lock>:
 *  This will lock the configuration until the next reset, or until the
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
    6230:	cf 93       	push	r28
    6232:	df 93       	push	r29
    6234:	cd b7       	in	r28, 0x3d	; 61
    6236:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    6238:	82 e4       	ldi	r24, 0x42	; 66
    623a:	90 e0       	ldi	r25, 0x00	; 0
    623c:	61 e0       	ldi	r22, 0x01	; 1
    623e:	0e 94 06 30 	call	0x600c	; 0x600c <CCPWrite>
}
    6242:	df 91       	pop	r29
    6244:	cf 91       	pop	r28
    6246:	08 95       	ret

00006248 <setXOSC_32MHz>:
// so this function will fail until the oscillator is installed.
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
    6248:	cf 93       	push	r28
    624a:	df 93       	push	r29
    624c:	cd b7       	in	r28, 0x3d	; 61
    624e:	de b7       	in	r29, 0x3e	; 62
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    6250:	80 ec       	ldi	r24, 0xC0	; 192
    6252:	60 e0       	ldi	r22, 0x00	; 0
    6254:	4b e0       	ldi	r20, 0x0B	; 11
    6256:	0e 94 31 30 	call	0x6062	; 0x6062 <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    625a:	80 e5       	ldi	r24, 0x50	; 80
    625c:	90 e0       	ldi	r25, 0x00	; 0
    625e:	20 e5       	ldi	r18, 0x50	; 80
    6260:	30 e0       	ldi	r19, 0x00	; 0
    6262:	f9 01       	movw	r30, r18
    6264:	20 81       	ld	r18, Z
    6266:	28 60       	ori	r18, 0x08	; 8
    6268:	fc 01       	movw	r30, r24
    626a:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    626c:	80 e5       	ldi	r24, 0x50	; 80
    626e:	90 e0       	ldi	r25, 0x00	; 0
    6270:	fc 01       	movw	r30, r24
    6272:	81 81       	ldd	r24, Z+1	; 0x01
    6274:	88 2f       	mov	r24, r24
    6276:	90 e0       	ldi	r25, 0x00	; 0
    6278:	88 70       	andi	r24, 0x08	; 8
    627a:	90 70       	andi	r25, 0x00	; 0
    627c:	00 97       	sbiw	r24, 0x00	; 0
    627e:	b1 f3       	breq	.-20     	; 0x626c <setXOSC_32MHz+0x24>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    6280:	80 ec       	ldi	r24, 0xC0	; 192
    6282:	62 e0       	ldi	r22, 0x02	; 2
    6284:	0e 94 4d 30 	call	0x609a	; 0x609a <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    6288:	80 e5       	ldi	r24, 0x50	; 80
    628a:	90 e0       	ldi	r25, 0x00	; 0
    628c:	20 e5       	ldi	r18, 0x50	; 80
    628e:	30 e0       	ldi	r19, 0x00	; 0
    6290:	f9 01       	movw	r30, r18
    6292:	20 81       	ld	r18, Z
    6294:	20 61       	ori	r18, 0x10	; 16
    6296:	fc 01       	movw	r30, r24
    6298:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    629a:	80 e5       	ldi	r24, 0x50	; 80
    629c:	90 e0       	ldi	r25, 0x00	; 0
    629e:	fc 01       	movw	r30, r24
    62a0:	81 81       	ldd	r24, Z+1	; 0x01
    62a2:	88 2f       	mov	r24, r24
    62a4:	90 e0       	ldi	r25, 0x00	; 0
    62a6:	80 71       	andi	r24, 0x10	; 16
    62a8:	90 70       	andi	r25, 0x00	; 0
    62aa:	00 97       	sbiw	r24, 0x00	; 0
    62ac:	b1 f3       	breq	.-20     	; 0x629a <setXOSC_32MHz+0x52>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    62ae:	84 e0       	ldi	r24, 0x04	; 4
    62b0:	0e 94 9a 30 	call	0x6134	; 0x6134 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    62b4:	81 e0       	ldi	r24, 0x01	; 1
    62b6:	0e 94 64 30 	call	0x60c8	; 0x60c8 <CLKSYS_Disable>
}
    62ba:	df 91       	pop	r29
    62bc:	cf 91       	pop	r28
    62be:	08 95       	ret

000062c0 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
    62c0:	cf 93       	push	r28
    62c2:	df 93       	push	r29
    62c4:	cd b7       	in	r28, 0x3d	; 61
    62c6:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    62c8:	80 e5       	ldi	r24, 0x50	; 80
    62ca:	90 e0       	ldi	r25, 0x00	; 0
    62cc:	20 e5       	ldi	r18, 0x50	; 80
    62ce:	30 e0       	ldi	r19, 0x00	; 0
    62d0:	f9 01       	movw	r30, r18
    62d2:	20 81       	ld	r18, Z
    62d4:	22 60       	ori	r18, 0x02	; 2
    62d6:	fc 01       	movw	r30, r24
    62d8:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    62da:	80 e0       	ldi	r24, 0x00	; 0
    62dc:	61 e0       	ldi	r22, 0x01	; 1
    62de:	0e 94 84 30 	call	0x6108	; 0x6108 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    62e2:	80 e5       	ldi	r24, 0x50	; 80
    62e4:	90 e0       	ldi	r25, 0x00	; 0
    62e6:	fc 01       	movw	r30, r24
    62e8:	81 81       	ldd	r24, Z+1	; 0x01
    62ea:	88 2f       	mov	r24, r24
    62ec:	90 e0       	ldi	r25, 0x00	; 0
    62ee:	82 70       	andi	r24, 0x02	; 2
    62f0:	90 70       	andi	r25, 0x00	; 0
    62f2:	00 97       	sbiw	r24, 0x00	; 0
    62f4:	b1 f3       	breq	.-20     	; 0x62e2 <set_16MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    62f6:	81 e0       	ldi	r24, 0x01	; 1
    62f8:	0e 94 9a 30 	call	0x6134	; 0x6134 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    62fc:	81 e0       	ldi	r24, 0x01	; 1
    62fe:	0e 94 64 30 	call	0x60c8	; 0x60c8 <CLKSYS_Disable>
	
}
    6302:	df 91       	pop	r29
    6304:	cf 91       	pop	r28
    6306:	08 95       	ret

00006308 <set_32MHz>:


// produces consistent but inaccurate clock period.
void set_32MHz() {
    6308:	cf 93       	push	r28
    630a:	df 93       	push	r29
    630c:	cd b7       	in	r28, 0x3d	; 61
    630e:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    6310:	80 e5       	ldi	r24, 0x50	; 80
    6312:	90 e0       	ldi	r25, 0x00	; 0
    6314:	20 e5       	ldi	r18, 0x50	; 80
    6316:	30 e0       	ldi	r19, 0x00	; 0
    6318:	f9 01       	movw	r30, r18
    631a:	20 81       	ld	r18, Z
    631c:	22 60       	ori	r18, 0x02	; 2
    631e:	fc 01       	movw	r30, r24
    6320:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    6322:	80 e0       	ldi	r24, 0x00	; 0
    6324:	60 e0       	ldi	r22, 0x00	; 0
    6326:	0e 94 84 30 	call	0x6108	; 0x6108 <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    632a:	80 e5       	ldi	r24, 0x50	; 80
    632c:	90 e0       	ldi	r25, 0x00	; 0
    632e:	fc 01       	movw	r30, r24
    6330:	81 81       	ldd	r24, Z+1	; 0x01
    6332:	88 2f       	mov	r24, r24
    6334:	90 e0       	ldi	r25, 0x00	; 0
    6336:	82 70       	andi	r24, 0x02	; 2
    6338:	90 70       	andi	r25, 0x00	; 0
    633a:	00 97       	sbiw	r24, 0x00	; 0
    633c:	b1 f3       	breq	.-20     	; 0x632a <set_32MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    633e:	81 e0       	ldi	r24, 0x01	; 1
    6340:	0e 94 9a 30 	call	0x6134	; 0x6134 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6344:	81 e0       	ldi	r24, 0x01	; 1
    6346:	0e 94 64 30 	call	0x60c8	; 0x60c8 <CLKSYS_Disable>
	
}
    634a:	df 91       	pop	r29
    634c:	cf 91       	pop	r28
    634e:	08 95       	ret

00006350 <portExCS>:


void portExCS(uint8_t write) {
    6350:	0f 93       	push	r16
    6352:	1f 93       	push	r17
    6354:	cf 93       	push	r28
    6356:	df 93       	push	r29
    6358:	cd b7       	in	r28, 0x3d	; 61
    635a:	de b7       	in	r29, 0x3e	; 62
    635c:	69 97       	sbiw	r28, 0x19	; 25
    635e:	cd bf       	out	0x3d, r28	; 61
    6360:	de bf       	out	0x3e, r29	; 62
    6362:	89 8f       	std	Y+25, r24	; 0x19
	if (write) PORTA.OUTCLR = PIN3_bm;
    6364:	89 8d       	ldd	r24, Y+25	; 0x19
    6366:	88 23       	and	r24, r24
    6368:	31 f0       	breq	.+12     	; 0x6376 <portExCS+0x26>
    636a:	80 e0       	ldi	r24, 0x00	; 0
    636c:	96 e0       	ldi	r25, 0x06	; 6
    636e:	28 e0       	ldi	r18, 0x08	; 8
    6370:	fc 01       	movw	r30, r24
    6372:	26 83       	std	Z+6, r18	; 0x06
    6374:	05 c0       	rjmp	.+10     	; 0x6380 <portExCS+0x30>
	else {
		PORTA.OUTSET = PIN3_bm;
    6376:	80 e0       	ldi	r24, 0x00	; 0
    6378:	96 e0       	ldi	r25, 0x06	; 6
    637a:	28 e0       	ldi	r18, 0x08	; 8
    637c:	fc 01       	movw	r30, r24
    637e:	25 83       	std	Z+5, r18	; 0x05
    6380:	80 e0       	ldi	r24, 0x00	; 0
    6382:	90 e0       	ldi	r25, 0x00	; 0
    6384:	a0 e2       	ldi	r26, 0x20	; 32
    6386:	b1 e4       	ldi	r27, 0x41	; 65
    6388:	89 83       	std	Y+1, r24	; 0x01
    638a:	9a 83       	std	Y+2, r25	; 0x02
    638c:	ab 83       	std	Y+3, r26	; 0x03
    638e:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    6390:	69 81       	ldd	r22, Y+1	; 0x01
    6392:	7a 81       	ldd	r23, Y+2	; 0x02
    6394:	8b 81       	ldd	r24, Y+3	; 0x03
    6396:	9c 81       	ldd	r25, Y+4	; 0x04
    6398:	2b ea       	ldi	r18, 0xAB	; 171
    639a:	3a ea       	ldi	r19, 0xAA	; 170
    639c:	4a e2       	ldi	r20, 0x2A	; 42
    639e:	51 e4       	ldi	r21, 0x41	; 65
    63a0:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    63a4:	dc 01       	movw	r26, r24
    63a6:	cb 01       	movw	r24, r22
    63a8:	8d 83       	std	Y+5, r24	; 0x05
    63aa:	9e 83       	std	Y+6, r25	; 0x06
    63ac:	af 83       	std	Y+7, r26	; 0x07
    63ae:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    63b0:	11 e0       	ldi	r17, 0x01	; 1
    63b2:	6d 81       	ldd	r22, Y+5	; 0x05
    63b4:	7e 81       	ldd	r23, Y+6	; 0x06
    63b6:	8f 81       	ldd	r24, Y+7	; 0x07
    63b8:	98 85       	ldd	r25, Y+8	; 0x08
    63ba:	20 e0       	ldi	r18, 0x00	; 0
    63bc:	30 e0       	ldi	r19, 0x00	; 0
    63be:	40 e8       	ldi	r20, 0x80	; 128
    63c0:	5f e3       	ldi	r21, 0x3F	; 63
    63c2:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    63c6:	88 23       	and	r24, r24
    63c8:	0c f0       	brlt	.+2      	; 0x63cc <portExCS+0x7c>
    63ca:	10 e0       	ldi	r17, 0x00	; 0
    63cc:	11 23       	and	r17, r17
    63ce:	19 f0       	breq	.+6      	; 0x63d6 <portExCS+0x86>
		__ticks = 1;
    63d0:	81 e0       	ldi	r24, 0x01	; 1
    63d2:	89 87       	std	Y+9, r24	; 0x09
    63d4:	a3 c0       	rjmp	.+326    	; 0x651c <portExCS+0x1cc>
	else if (__tmp > 255)
    63d6:	11 e0       	ldi	r17, 0x01	; 1
    63d8:	6d 81       	ldd	r22, Y+5	; 0x05
    63da:	7e 81       	ldd	r23, Y+6	; 0x06
    63dc:	8f 81       	ldd	r24, Y+7	; 0x07
    63de:	98 85       	ldd	r25, Y+8	; 0x08
    63e0:	20 e0       	ldi	r18, 0x00	; 0
    63e2:	30 e0       	ldi	r19, 0x00	; 0
    63e4:	4f e7       	ldi	r20, 0x7F	; 127
    63e6:	53 e4       	ldi	r21, 0x43	; 67
    63e8:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    63ec:	18 16       	cp	r1, r24
    63ee:	0c f0       	brlt	.+2      	; 0x63f2 <portExCS+0xa2>
    63f0:	10 e0       	ldi	r17, 0x00	; 0
    63f2:	11 23       	and	r17, r17
    63f4:	09 f4       	brne	.+2      	; 0x63f8 <portExCS+0xa8>
    63f6:	89 c0       	rjmp	.+274    	; 0x650a <portExCS+0x1ba>
	{
		_delay_ms(__us / 1000.0);
    63f8:	69 81       	ldd	r22, Y+1	; 0x01
    63fa:	7a 81       	ldd	r23, Y+2	; 0x02
    63fc:	8b 81       	ldd	r24, Y+3	; 0x03
    63fe:	9c 81       	ldd	r25, Y+4	; 0x04
    6400:	20 e0       	ldi	r18, 0x00	; 0
    6402:	30 e0       	ldi	r19, 0x00	; 0
    6404:	4a e7       	ldi	r20, 0x7A	; 122
    6406:	54 e4       	ldi	r21, 0x44	; 68
    6408:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
    640c:	dc 01       	movw	r26, r24
    640e:	cb 01       	movw	r24, r22
    6410:	8a 87       	std	Y+10, r24	; 0x0a
    6412:	9b 87       	std	Y+11, r25	; 0x0b
    6414:	ac 87       	std	Y+12, r26	; 0x0c
    6416:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6418:	6a 85       	ldd	r22, Y+10	; 0x0a
    641a:	7b 85       	ldd	r23, Y+11	; 0x0b
    641c:	8c 85       	ldd	r24, Y+12	; 0x0c
    641e:	9d 85       	ldd	r25, Y+13	; 0x0d
    6420:	20 e0       	ldi	r18, 0x00	; 0
    6422:	30 e0       	ldi	r19, 0x00	; 0
    6424:	4a ef       	ldi	r20, 0xFA	; 250
    6426:	55 e4       	ldi	r21, 0x45	; 69
    6428:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    642c:	dc 01       	movw	r26, r24
    642e:	cb 01       	movw	r24, r22
    6430:	8e 87       	std	Y+14, r24	; 0x0e
    6432:	9f 87       	std	Y+15, r25	; 0x0f
    6434:	a8 8b       	std	Y+16, r26	; 0x10
    6436:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    6438:	11 e0       	ldi	r17, 0x01	; 1
    643a:	6e 85       	ldd	r22, Y+14	; 0x0e
    643c:	7f 85       	ldd	r23, Y+15	; 0x0f
    643e:	88 89       	ldd	r24, Y+16	; 0x10
    6440:	99 89       	ldd	r25, Y+17	; 0x11
    6442:	20 e0       	ldi	r18, 0x00	; 0
    6444:	30 e0       	ldi	r19, 0x00	; 0
    6446:	40 e8       	ldi	r20, 0x80	; 128
    6448:	5f e3       	ldi	r21, 0x3F	; 63
    644a:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    644e:	88 23       	and	r24, r24
    6450:	0c f0       	brlt	.+2      	; 0x6454 <portExCS+0x104>
    6452:	10 e0       	ldi	r17, 0x00	; 0
    6454:	11 23       	and	r17, r17
    6456:	29 f0       	breq	.+10     	; 0x6462 <portExCS+0x112>
		__ticks = 1;
    6458:	81 e0       	ldi	r24, 0x01	; 1
    645a:	90 e0       	ldi	r25, 0x00	; 0
    645c:	8a 8b       	std	Y+18, r24	; 0x12
    645e:	9b 8b       	std	Y+19, r25	; 0x13
    6460:	46 c0       	rjmp	.+140    	; 0x64ee <portExCS+0x19e>
	else if (__tmp > 65535)
    6462:	11 e0       	ldi	r17, 0x01	; 1
    6464:	6e 85       	ldd	r22, Y+14	; 0x0e
    6466:	7f 85       	ldd	r23, Y+15	; 0x0f
    6468:	88 89       	ldd	r24, Y+16	; 0x10
    646a:	99 89       	ldd	r25, Y+17	; 0x11
    646c:	20 e0       	ldi	r18, 0x00	; 0
    646e:	3f ef       	ldi	r19, 0xFF	; 255
    6470:	4f e7       	ldi	r20, 0x7F	; 127
    6472:	57 e4       	ldi	r21, 0x47	; 71
    6474:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    6478:	18 16       	cp	r1, r24
    647a:	0c f0       	brlt	.+2      	; 0x647e <portExCS+0x12e>
    647c:	10 e0       	ldi	r17, 0x00	; 0
    647e:	11 23       	and	r17, r17
    6480:	61 f1       	breq	.+88     	; 0x64da <portExCS+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6482:	6a 85       	ldd	r22, Y+10	; 0x0a
    6484:	7b 85       	ldd	r23, Y+11	; 0x0b
    6486:	8c 85       	ldd	r24, Y+12	; 0x0c
    6488:	9d 85       	ldd	r25, Y+13	; 0x0d
    648a:	20 e0       	ldi	r18, 0x00	; 0
    648c:	30 e0       	ldi	r19, 0x00	; 0
    648e:	40 e2       	ldi	r20, 0x20	; 32
    6490:	51 e4       	ldi	r21, 0x41	; 65
    6492:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    6496:	dc 01       	movw	r26, r24
    6498:	cb 01       	movw	r24, r22
    649a:	bc 01       	movw	r22, r24
    649c:	cd 01       	movw	r24, r26
    649e:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    64a2:	dc 01       	movw	r26, r24
    64a4:	cb 01       	movw	r24, r22
    64a6:	8a 8b       	std	Y+18, r24	; 0x12
    64a8:	9b 8b       	std	Y+19, r25	; 0x13
    64aa:	12 c0       	rjmp	.+36     	; 0x64d0 <portExCS+0x180>
    64ac:	80 e2       	ldi	r24, 0x20	; 32
    64ae:	93 e0       	ldi	r25, 0x03	; 3
    64b0:	8c 8b       	std	Y+20, r24	; 0x14
    64b2:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    64b4:	8c 89       	ldd	r24, Y+20	; 0x14
    64b6:	9d 89       	ldd	r25, Y+21	; 0x15
    64b8:	8c 01       	movw	r16, r24
    64ba:	c8 01       	movw	r24, r16
    64bc:	01 97       	sbiw	r24, 0x01	; 1
    64be:	f1 f7       	brne	.-4      	; 0x64bc <portExCS+0x16c>
    64c0:	8c 01       	movw	r16, r24
    64c2:	0c 8b       	std	Y+20, r16	; 0x14
    64c4:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    64c6:	8a 89       	ldd	r24, Y+18	; 0x12
    64c8:	9b 89       	ldd	r25, Y+19	; 0x13
    64ca:	01 97       	sbiw	r24, 0x01	; 1
    64cc:	8a 8b       	std	Y+18, r24	; 0x12
    64ce:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    64d0:	8a 89       	ldd	r24, Y+18	; 0x12
    64d2:	9b 89       	ldd	r25, Y+19	; 0x13
    64d4:	00 97       	sbiw	r24, 0x00	; 0
    64d6:	51 f7       	brne	.-44     	; 0x64ac <portExCS+0x15c>
    64d8:	28 c0       	rjmp	.+80     	; 0x652a <portExCS+0x1da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    64da:	6e 85       	ldd	r22, Y+14	; 0x0e
    64dc:	7f 85       	ldd	r23, Y+15	; 0x0f
    64de:	88 89       	ldd	r24, Y+16	; 0x10
    64e0:	99 89       	ldd	r25, Y+17	; 0x11
    64e2:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    64e6:	dc 01       	movw	r26, r24
    64e8:	cb 01       	movw	r24, r22
    64ea:	8a 8b       	std	Y+18, r24	; 0x12
    64ec:	9b 8b       	std	Y+19, r25	; 0x13
    64ee:	8a 89       	ldd	r24, Y+18	; 0x12
    64f0:	9b 89       	ldd	r25, Y+19	; 0x13
    64f2:	8e 8b       	std	Y+22, r24	; 0x16
    64f4:	9f 8b       	std	Y+23, r25	; 0x17
    64f6:	8e 89       	ldd	r24, Y+22	; 0x16
    64f8:	9f 89       	ldd	r25, Y+23	; 0x17
    64fa:	8c 01       	movw	r16, r24
    64fc:	f8 01       	movw	r30, r16
    64fe:	31 97       	sbiw	r30, 0x01	; 1
    6500:	f1 f7       	brne	.-4      	; 0x64fe <portExCS+0x1ae>
    6502:	8f 01       	movw	r16, r30
    6504:	0e 8b       	std	Y+22, r16	; 0x16
    6506:	1f 8b       	std	Y+23, r17	; 0x17
    6508:	10 c0       	rjmp	.+32     	; 0x652a <portExCS+0x1da>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    650a:	6d 81       	ldd	r22, Y+5	; 0x05
    650c:	7e 81       	ldd	r23, Y+6	; 0x06
    650e:	8f 81       	ldd	r24, Y+7	; 0x07
    6510:	98 85       	ldd	r25, Y+8	; 0x08
    6512:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    6516:	dc 01       	movw	r26, r24
    6518:	cb 01       	movw	r24, r22
    651a:	89 87       	std	Y+9, r24	; 0x09
    651c:	89 85       	ldd	r24, Y+9	; 0x09
    651e:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6520:	88 8d       	ldd	r24, Y+24	; 0x18
    6522:	18 2f       	mov	r17, r24
    6524:	1a 95       	dec	r17
    6526:	f1 f7       	brne	.-4      	; 0x6524 <portExCS+0x1d4>
    6528:	18 8f       	std	Y+24, r17	; 0x18
	}
	_delay_us(10);
}
    652a:	69 96       	adiw	r28, 0x19	; 25
    652c:	cd bf       	out	0x3d, r28	; 61
    652e:	de bf       	out	0x3e, r29	; 62
    6530:	df 91       	pop	r29
    6532:	cf 91       	pop	r28
    6534:	1f 91       	pop	r17
    6536:	0f 91       	pop	r16
    6538:	08 95       	ret

0000653a <PortEx_DIRSET>:

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    653a:	cf 93       	push	r28
    653c:	df 93       	push	r29
    653e:	00 d0       	rcall	.+0      	; 0x6540 <PortEx_DIRSET+0x6>
    6540:	cd b7       	in	r28, 0x3d	; 61
    6542:	de b7       	in	r29, 0x3e	; 62
    6544:	8a 83       	std	Y+2, r24	; 0x02
    6546:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6548:	80 e0       	ldi	r24, 0x00	; 0
    654a:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>
	SPICS(TRUE);
    654e:	81 e0       	ldi	r24, 0x01	; 1
    6550:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	portExCS(TRUE);
    6554:	81 e0       	ldi	r24, 0x01	; 1
    6556:	0e 94 a8 31 	call	0x6350	; 0x6350 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    655a:	8b 81       	ldd	r24, Y+3	; 0x03
    655c:	88 23       	and	r24, r24
    655e:	39 f0       	breq	.+14     	; 0x656e <PortEx_DIRSET+0x34>
    6560:	90 91 6b 50 	lds	r25, 0x506B
    6564:	8a 81       	ldd	r24, Y+2	; 0x02
    6566:	89 2b       	or	r24, r25
    6568:	80 93 6b 50 	sts	0x506B, r24
    656c:	06 c0       	rjmp	.+12     	; 0x657a <PortEx_DIRSET+0x40>
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    656e:	90 91 c6 50 	lds	r25, 0x50C6
    6572:	8a 81       	ldd	r24, Y+2	; 0x02
    6574:	89 2b       	or	r24, r25
    6576:	80 93 c6 50 	sts	0x50C6, r24
	
	SPIBuffer[0] = PS_WRITE;
    657a:	80 e4       	ldi	r24, 0x40	; 64
    657c:	80 93 56 50 	sts	0x5056, r24
	if(bank) {
    6580:	8b 81       	ldd	r24, Y+3	; 0x03
    6582:	88 23       	and	r24, r24
    6584:	41 f0       	breq	.+16     	; 0x6596 <PortEx_DIRSET+0x5c>
		SPIBuffer[1]=PS_IODIRA;
    6586:	10 92 57 50 	sts	0x5057, r1
		SPIBuffer[2] = ~bankA_DIR; 
    658a:	80 91 6b 50 	lds	r24, 0x506B
    658e:	80 95       	com	r24
    6590:	80 93 58 50 	sts	0x5058, r24
    6594:	08 c0       	rjmp	.+16     	; 0x65a6 <PortEx_DIRSET+0x6c>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    6596:	81 e0       	ldi	r24, 0x01	; 1
    6598:	80 93 57 50 	sts	0x5057, r24
		SPIBuffer[2] = ~bankB_DIR;
    659c:	80 91 c6 50 	lds	r24, 0x50C6
    65a0:	80 95       	com	r24
    65a2:	80 93 58 50 	sts	0x5058, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    65a6:	19 82       	std	Y+1, r1	; 0x01
    65a8:	1b c0       	rjmp	.+54     	; 0x65e0 <PortEx_DIRSET+0xa6>
		SPIC.DATA = SPIBuffer[bufIndex];
    65aa:	80 ec       	ldi	r24, 0xC0	; 192
    65ac:	98 e0       	ldi	r25, 0x08	; 8
    65ae:	29 81       	ldd	r18, Y+1	; 0x01
    65b0:	22 2f       	mov	r18, r18
    65b2:	30 e0       	ldi	r19, 0x00	; 0
    65b4:	2a 5a       	subi	r18, 0xAA	; 170
    65b6:	3f 4a       	sbci	r19, 0xAF	; 175
    65b8:	f9 01       	movw	r30, r18
    65ba:	20 81       	ld	r18, Z
    65bc:	fc 01       	movw	r30, r24
    65be:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    65c0:	00 00       	nop
    65c2:	80 ec       	ldi	r24, 0xC0	; 192
    65c4:	98 e0       	ldi	r25, 0x08	; 8
    65c6:	fc 01       	movw	r30, r24
    65c8:	82 81       	ldd	r24, Z+2	; 0x02
    65ca:	88 23       	and	r24, r24
    65cc:	d4 f7       	brge	.-12     	; 0x65c2 <PortEx_DIRSET+0x88>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    65ce:	80 ec       	ldi	r24, 0xC0	; 192
    65d0:	98 e0       	ldi	r25, 0x08	; 8
    65d2:	fc 01       	movw	r30, r24
    65d4:	83 81       	ldd	r24, Z+3	; 0x03
    65d6:	80 93 62 50 	sts	0x5062, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    65da:	89 81       	ldd	r24, Y+1	; 0x01
    65dc:	8f 5f       	subi	r24, 0xFF	; 255
    65de:	89 83       	std	Y+1, r24	; 0x01
    65e0:	89 81       	ldd	r24, Y+1	; 0x01
    65e2:	83 30       	cpi	r24, 0x03	; 3
    65e4:	10 f3       	brcs	.-60     	; 0x65aa <PortEx_DIRSET+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    65e6:	80 e0       	ldi	r24, 0x00	; 0
    65e8:	0e 94 a8 31 	call	0x6350	; 0x6350 <portExCS>
	SPICS(FALSE);
    65ec:	80 e0       	ldi	r24, 0x00	; 0
    65ee:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	SPIDisable();
    65f2:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>


}
    65f6:	23 96       	adiw	r28, 0x03	; 3
    65f8:	cd bf       	out	0x3d, r28	; 61
    65fa:	de bf       	out	0x3e, r29	; 62
    65fc:	df 91       	pop	r29
    65fe:	cf 91       	pop	r28
    6600:	08 95       	ret

00006602 <PortEx_DIRCLR>:

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    6602:	cf 93       	push	r28
    6604:	df 93       	push	r29
    6606:	00 d0       	rcall	.+0      	; 0x6608 <PortEx_DIRCLR+0x6>
    6608:	cd b7       	in	r28, 0x3d	; 61
    660a:	de b7       	in	r29, 0x3e	; 62
    660c:	8a 83       	std	Y+2, r24	; 0x02
    660e:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6610:	80 e0       	ldi	r24, 0x00	; 0
    6612:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>
	SPICS(TRUE);
    6616:	81 e0       	ldi	r24, 0x01	; 1
    6618:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	portExCS(TRUE);
    661c:	81 e0       	ldi	r24, 0x01	; 1
    661e:	0e 94 a8 31 	call	0x6350	; 0x6350 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    6622:	8b 81       	ldd	r24, Y+3	; 0x03
    6624:	88 23       	and	r24, r24
    6626:	49 f0       	breq	.+18     	; 0x663a <PortEx_DIRCLR+0x38>
    6628:	80 91 6b 50 	lds	r24, 0x506B
    662c:	98 2f       	mov	r25, r24
    662e:	90 95       	com	r25
    6630:	8a 81       	ldd	r24, Y+2	; 0x02
    6632:	89 23       	and	r24, r25
    6634:	80 93 6b 50 	sts	0x506B, r24
    6638:	08 c0       	rjmp	.+16     	; 0x664a <PortEx_DIRCLR+0x48>
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    663a:	80 91 c6 50 	lds	r24, 0x50C6
    663e:	98 2f       	mov	r25, r24
    6640:	90 95       	com	r25
    6642:	8a 81       	ldd	r24, Y+2	; 0x02
    6644:	89 23       	and	r24, r25
    6646:	80 93 c6 50 	sts	0x50C6, r24
	
	SPIBuffer[0] = PS_WRITE;
    664a:	80 e4       	ldi	r24, 0x40	; 64
    664c:	80 93 56 50 	sts	0x5056, r24
	if(bank) {
    6650:	8b 81       	ldd	r24, Y+3	; 0x03
    6652:	88 23       	and	r24, r24
    6654:	41 f0       	breq	.+16     	; 0x6666 <PortEx_DIRCLR+0x64>
		SPIBuffer[1]=PS_IODIRA;
    6656:	10 92 57 50 	sts	0x5057, r1
		SPIBuffer[2] = ~bankA_DIR; 
    665a:	80 91 6b 50 	lds	r24, 0x506B
    665e:	80 95       	com	r24
    6660:	80 93 58 50 	sts	0x5058, r24
    6664:	08 c0       	rjmp	.+16     	; 0x6676 <PortEx_DIRCLR+0x74>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    6666:	81 e0       	ldi	r24, 0x01	; 1
    6668:	80 93 57 50 	sts	0x5057, r24
		SPIBuffer[2] = ~bankB_DIR;
    666c:	80 91 c6 50 	lds	r24, 0x50C6
    6670:	80 95       	com	r24
    6672:	80 93 58 50 	sts	0x5058, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6676:	19 82       	std	Y+1, r1	; 0x01
    6678:	1b c0       	rjmp	.+54     	; 0x66b0 <PortEx_DIRCLR+0xae>
		SPIC.DATA = SPIBuffer[bufIndex];
    667a:	80 ec       	ldi	r24, 0xC0	; 192
    667c:	98 e0       	ldi	r25, 0x08	; 8
    667e:	29 81       	ldd	r18, Y+1	; 0x01
    6680:	22 2f       	mov	r18, r18
    6682:	30 e0       	ldi	r19, 0x00	; 0
    6684:	2a 5a       	subi	r18, 0xAA	; 170
    6686:	3f 4a       	sbci	r19, 0xAF	; 175
    6688:	f9 01       	movw	r30, r18
    668a:	20 81       	ld	r18, Z
    668c:	fc 01       	movw	r30, r24
    668e:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6690:	00 00       	nop
    6692:	80 ec       	ldi	r24, 0xC0	; 192
    6694:	98 e0       	ldi	r25, 0x08	; 8
    6696:	fc 01       	movw	r30, r24
    6698:	82 81       	ldd	r24, Z+2	; 0x02
    669a:	88 23       	and	r24, r24
    669c:	d4 f7       	brge	.-12     	; 0x6692 <PortEx_DIRCLR+0x90>
		SPIBuffer[12] = SPIC.DATA;
    669e:	80 ec       	ldi	r24, 0xC0	; 192
    66a0:	98 e0       	ldi	r25, 0x08	; 8
    66a2:	fc 01       	movw	r30, r24
    66a4:	83 81       	ldd	r24, Z+3	; 0x03
    66a6:	80 93 62 50 	sts	0x5062, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    66aa:	89 81       	ldd	r24, Y+1	; 0x01
    66ac:	8f 5f       	subi	r24, 0xFF	; 255
    66ae:	89 83       	std	Y+1, r24	; 0x01
    66b0:	89 81       	ldd	r24, Y+1	; 0x01
    66b2:	83 30       	cpi	r24, 0x03	; 3
    66b4:	10 f3       	brcs	.-60     	; 0x667a <PortEx_DIRCLR+0x78>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    66b6:	80 e0       	ldi	r24, 0x00	; 0
    66b8:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	portExCS(FALSE);
    66bc:	80 e0       	ldi	r24, 0x00	; 0
    66be:	0e 94 a8 31 	call	0x6350	; 0x6350 <portExCS>
	SPIDisable();
    66c2:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>
}
    66c6:	23 96       	adiw	r28, 0x03	; 3
    66c8:	cd bf       	out	0x3d, r28	; 61
    66ca:	de bf       	out	0x3e, r29	; 62
    66cc:	df 91       	pop	r29
    66ce:	cf 91       	pop	r28
    66d0:	08 95       	ret

000066d2 <PortEx_OUTSET>:

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    66d2:	cf 93       	push	r28
    66d4:	df 93       	push	r29
    66d6:	00 d0       	rcall	.+0      	; 0x66d8 <PortEx_OUTSET+0x6>
    66d8:	cd b7       	in	r28, 0x3d	; 61
    66da:	de b7       	in	r29, 0x3e	; 62
    66dc:	8a 83       	std	Y+2, r24	; 0x02
    66de:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    66e0:	80 e0       	ldi	r24, 0x00	; 0
    66e2:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>
	SPICS(TRUE);
    66e6:	81 e0       	ldi	r24, 0x01	; 1
    66e8:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	portExCS(TRUE);
    66ec:	81 e0       	ldi	r24, 0x01	; 1
    66ee:	0e 94 a8 31 	call	0x6350	; 0x6350 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    66f2:	8b 81       	ldd	r24, Y+3	; 0x03
    66f4:	88 23       	and	r24, r24
    66f6:	39 f0       	breq	.+14     	; 0x6706 <PortEx_OUTSET+0x34>
    66f8:	90 91 c7 23 	lds	r25, 0x23C7
    66fc:	8a 81       	ldd	r24, Y+2	; 0x02
    66fe:	89 2b       	or	r24, r25
    6700:	80 93 c7 23 	sts	0x23C7, r24
    6704:	06 c0       	rjmp	.+12     	; 0x6712 <PortEx_OUTSET+0x40>
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    6706:	90 91 73 50 	lds	r25, 0x5073
    670a:	8a 81       	ldd	r24, Y+2	; 0x02
    670c:	89 2b       	or	r24, r25
    670e:	80 93 73 50 	sts	0x5073, r24
	
	SPIBuffer[0] = PS_WRITE;
    6712:	80 e4       	ldi	r24, 0x40	; 64
    6714:	80 93 56 50 	sts	0x5056, r24
	if(bank) {
    6718:	8b 81       	ldd	r24, Y+3	; 0x03
    671a:	88 23       	and	r24, r24
    671c:	41 f0       	breq	.+16     	; 0x672e <PortEx_OUTSET+0x5c>
		SPIBuffer[1]=PS_OLATA;
    671e:	84 e1       	ldi	r24, 0x14	; 20
    6720:	80 93 57 50 	sts	0x5057, r24
		SPIBuffer[2] = bankA_OUT;
    6724:	80 91 c7 23 	lds	r24, 0x23C7
    6728:	80 93 58 50 	sts	0x5058, r24
    672c:	07 c0       	rjmp	.+14     	; 0x673c <PortEx_OUTSET+0x6a>
	} else {
		SPIBuffer[1]=PS_OLATB;
    672e:	85 e1       	ldi	r24, 0x15	; 21
    6730:	80 93 57 50 	sts	0x5057, r24
		SPIBuffer[2] = bankB_OUT; 
    6734:	80 91 73 50 	lds	r24, 0x5073
    6738:	80 93 58 50 	sts	0x5058, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    673c:	19 82       	std	Y+1, r1	; 0x01
    673e:	1b c0       	rjmp	.+54     	; 0x6776 <PortEx_OUTSET+0xa4>
		SPIC.DATA = SPIBuffer[bufIndex];
    6740:	80 ec       	ldi	r24, 0xC0	; 192
    6742:	98 e0       	ldi	r25, 0x08	; 8
    6744:	29 81       	ldd	r18, Y+1	; 0x01
    6746:	22 2f       	mov	r18, r18
    6748:	30 e0       	ldi	r19, 0x00	; 0
    674a:	2a 5a       	subi	r18, 0xAA	; 170
    674c:	3f 4a       	sbci	r19, 0xAF	; 175
    674e:	f9 01       	movw	r30, r18
    6750:	20 81       	ld	r18, Z
    6752:	fc 01       	movw	r30, r24
    6754:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6756:	00 00       	nop
    6758:	80 ec       	ldi	r24, 0xC0	; 192
    675a:	98 e0       	ldi	r25, 0x08	; 8
    675c:	fc 01       	movw	r30, r24
    675e:	82 81       	ldd	r24, Z+2	; 0x02
    6760:	88 23       	and	r24, r24
    6762:	d4 f7       	brge	.-12     	; 0x6758 <PortEx_OUTSET+0x86>
		SPIBuffer[12] = SPIC.DATA;
    6764:	80 ec       	ldi	r24, 0xC0	; 192
    6766:	98 e0       	ldi	r25, 0x08	; 8
    6768:	fc 01       	movw	r30, r24
    676a:	83 81       	ldd	r24, Z+3	; 0x03
    676c:	80 93 62 50 	sts	0x5062, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6770:	89 81       	ldd	r24, Y+1	; 0x01
    6772:	8f 5f       	subi	r24, 0xFF	; 255
    6774:	89 83       	std	Y+1, r24	; 0x01
    6776:	89 81       	ldd	r24, Y+1	; 0x01
    6778:	83 30       	cpi	r24, 0x03	; 3
    677a:	10 f3       	brcs	.-60     	; 0x6740 <PortEx_OUTSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    677c:	80 e0       	ldi	r24, 0x00	; 0
    677e:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	portExCS(FALSE);
    6782:	80 e0       	ldi	r24, 0x00	; 0
    6784:	0e 94 a8 31 	call	0x6350	; 0x6350 <portExCS>
	SPIDisable();
    6788:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>
}
    678c:	23 96       	adiw	r28, 0x03	; 3
    678e:	cd bf       	out	0x3d, r28	; 61
    6790:	de bf       	out	0x3e, r29	; 62
    6792:	df 91       	pop	r29
    6794:	cf 91       	pop	r28
    6796:	08 95       	ret

00006798 <PortEx_OUTCLR>:


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    6798:	cf 93       	push	r28
    679a:	df 93       	push	r29
    679c:	00 d0       	rcall	.+0      	; 0x679e <PortEx_OUTCLR+0x6>
    679e:	cd b7       	in	r28, 0x3d	; 61
    67a0:	de b7       	in	r29, 0x3e	; 62
    67a2:	8a 83       	std	Y+2, r24	; 0x02
    67a4:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    67a6:	80 e0       	ldi	r24, 0x00	; 0
    67a8:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>
	SPICS(TRUE);
    67ac:	81 e0       	ldi	r24, 0x01	; 1
    67ae:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	portExCS(TRUE);
    67b2:	81 e0       	ldi	r24, 0x01	; 1
    67b4:	0e 94 a8 31 	call	0x6350	; 0x6350 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    67b8:	8b 81       	ldd	r24, Y+3	; 0x03
    67ba:	88 23       	and	r24, r24
    67bc:	49 f0       	breq	.+18     	; 0x67d0 <PortEx_OUTCLR+0x38>
    67be:	8a 81       	ldd	r24, Y+2	; 0x02
    67c0:	98 2f       	mov	r25, r24
    67c2:	90 95       	com	r25
    67c4:	80 91 c7 23 	lds	r24, 0x23C7
    67c8:	89 23       	and	r24, r25
    67ca:	80 93 c7 23 	sts	0x23C7, r24
    67ce:	08 c0       	rjmp	.+16     	; 0x67e0 <PortEx_OUTCLR+0x48>
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    67d0:	8a 81       	ldd	r24, Y+2	; 0x02
    67d2:	98 2f       	mov	r25, r24
    67d4:	90 95       	com	r25
    67d6:	80 91 73 50 	lds	r24, 0x5073
    67da:	89 23       	and	r24, r25
    67dc:	80 93 73 50 	sts	0x5073, r24
	
	SPIBuffer[0] = PS_WRITE;
    67e0:	80 e4       	ldi	r24, 0x40	; 64
    67e2:	80 93 56 50 	sts	0x5056, r24
	if(bank) {
    67e6:	8b 81       	ldd	r24, Y+3	; 0x03
    67e8:	88 23       	and	r24, r24
    67ea:	41 f0       	breq	.+16     	; 0x67fc <PortEx_OUTCLR+0x64>
		SPIBuffer[1]=PS_OLATA;
    67ec:	84 e1       	ldi	r24, 0x14	; 20
    67ee:	80 93 57 50 	sts	0x5057, r24
		SPIBuffer[2] = bankA_OUT;
    67f2:	80 91 c7 23 	lds	r24, 0x23C7
    67f6:	80 93 58 50 	sts	0x5058, r24
    67fa:	07 c0       	rjmp	.+14     	; 0x680a <PortEx_OUTCLR+0x72>
	} else {
		SPIBuffer[1]=PS_OLATB;
    67fc:	85 e1       	ldi	r24, 0x15	; 21
    67fe:	80 93 57 50 	sts	0x5057, r24
		SPIBuffer[2] = bankB_OUT; 
    6802:	80 91 73 50 	lds	r24, 0x5073
    6806:	80 93 58 50 	sts	0x5058, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    680a:	19 82       	std	Y+1, r1	; 0x01
    680c:	1b c0       	rjmp	.+54     	; 0x6844 <PortEx_OUTCLR+0xac>
		SPIC.DATA = SPIBuffer[bufIndex];
    680e:	80 ec       	ldi	r24, 0xC0	; 192
    6810:	98 e0       	ldi	r25, 0x08	; 8
    6812:	29 81       	ldd	r18, Y+1	; 0x01
    6814:	22 2f       	mov	r18, r18
    6816:	30 e0       	ldi	r19, 0x00	; 0
    6818:	2a 5a       	subi	r18, 0xAA	; 170
    681a:	3f 4a       	sbci	r19, 0xAF	; 175
    681c:	f9 01       	movw	r30, r18
    681e:	20 81       	ld	r18, Z
    6820:	fc 01       	movw	r30, r24
    6822:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6824:	00 00       	nop
    6826:	80 ec       	ldi	r24, 0xC0	; 192
    6828:	98 e0       	ldi	r25, 0x08	; 8
    682a:	fc 01       	movw	r30, r24
    682c:	82 81       	ldd	r24, Z+2	; 0x02
    682e:	88 23       	and	r24, r24
    6830:	d4 f7       	brge	.-12     	; 0x6826 <PortEx_OUTCLR+0x8e>
		SPIBuffer[12] = SPIC.DATA;
    6832:	80 ec       	ldi	r24, 0xC0	; 192
    6834:	98 e0       	ldi	r25, 0x08	; 8
    6836:	fc 01       	movw	r30, r24
    6838:	83 81       	ldd	r24, Z+3	; 0x03
    683a:	80 93 62 50 	sts	0x5062, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    683e:	89 81       	ldd	r24, Y+1	; 0x01
    6840:	8f 5f       	subi	r24, 0xFF	; 255
    6842:	89 83       	std	Y+1, r24	; 0x01
    6844:	89 81       	ldd	r24, Y+1	; 0x01
    6846:	83 30       	cpi	r24, 0x03	; 3
    6848:	10 f3       	brcs	.-60     	; 0x680e <PortEx_OUTCLR+0x76>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    684a:	80 e0       	ldi	r24, 0x00	; 0
    684c:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	portExCS(FALSE);
    6850:	80 e0       	ldi	r24, 0x00	; 0
    6852:	0e 94 a8 31 	call	0x6350	; 0x6350 <portExCS>
	SPIDisable();
    6856:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>
}
    685a:	23 96       	adiw	r28, 0x03	; 3
    685c:	cd bf       	out	0x3d, r28	; 61
    685e:	de bf       	out	0x3e, r29	; 62
    6860:	df 91       	pop	r29
    6862:	cf 91       	pop	r28
    6864:	08 95       	ret

00006866 <Ext1Power>:
	SPIDisable();
}
*/


void Ext1Power(uint8_t on) {
    6866:	0f 93       	push	r16
    6868:	1f 93       	push	r17
    686a:	cf 93       	push	r28
    686c:	df 93       	push	r29
    686e:	cd b7       	in	r28, 0x3d	; 61
    6870:	de b7       	in	r29, 0x3e	; 62
    6872:	2f 97       	sbiw	r28, 0x0f	; 15
    6874:	cd bf       	out	0x3d, r28	; 61
    6876:	de bf       	out	0x3e, r29	; 62
    6878:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    687a:	8f 85       	ldd	r24, Y+15	; 0x0f
    687c:	88 23       	and	r24, r24
    687e:	09 f4       	brne	.+2      	; 0x6882 <Ext1Power+0x1c>
    6880:	8b c0       	rjmp	.+278    	; 0x6998 <Ext1Power+0x132>
		PORTF.DIRSET = PIN5_bm;
    6882:	80 ea       	ldi	r24, 0xA0	; 160
    6884:	96 e0       	ldi	r25, 0x06	; 6
    6886:	20 e2       	ldi	r18, 0x20	; 32
    6888:	fc 01       	movw	r30, r24
    688a:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN5_bm;
    688c:	80 ea       	ldi	r24, 0xA0	; 160
    688e:	96 e0       	ldi	r25, 0x06	; 6
    6890:	20 e2       	ldi	r18, 0x20	; 32
    6892:	fc 01       	movw	r30, r24
    6894:	25 83       	std	Z+5, r18	; 0x05
    6896:	80 e0       	ldi	r24, 0x00	; 0
    6898:	90 e0       	ldi	r25, 0x00	; 0
    689a:	a8 ec       	ldi	r26, 0xC8	; 200
    689c:	b2 e4       	ldi	r27, 0x42	; 66
    689e:	89 83       	std	Y+1, r24	; 0x01
    68a0:	9a 83       	std	Y+2, r25	; 0x02
    68a2:	ab 83       	std	Y+3, r26	; 0x03
    68a4:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    68a6:	69 81       	ldd	r22, Y+1	; 0x01
    68a8:	7a 81       	ldd	r23, Y+2	; 0x02
    68aa:	8b 81       	ldd	r24, Y+3	; 0x03
    68ac:	9c 81       	ldd	r25, Y+4	; 0x04
    68ae:	20 e0       	ldi	r18, 0x00	; 0
    68b0:	30 e0       	ldi	r19, 0x00	; 0
    68b2:	4a ef       	ldi	r20, 0xFA	; 250
    68b4:	55 e4       	ldi	r21, 0x45	; 69
    68b6:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    68ba:	dc 01       	movw	r26, r24
    68bc:	cb 01       	movw	r24, r22
    68be:	8d 83       	std	Y+5, r24	; 0x05
    68c0:	9e 83       	std	Y+6, r25	; 0x06
    68c2:	af 83       	std	Y+7, r26	; 0x07
    68c4:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    68c6:	11 e0       	ldi	r17, 0x01	; 1
    68c8:	6d 81       	ldd	r22, Y+5	; 0x05
    68ca:	7e 81       	ldd	r23, Y+6	; 0x06
    68cc:	8f 81       	ldd	r24, Y+7	; 0x07
    68ce:	98 85       	ldd	r25, Y+8	; 0x08
    68d0:	20 e0       	ldi	r18, 0x00	; 0
    68d2:	30 e0       	ldi	r19, 0x00	; 0
    68d4:	40 e8       	ldi	r20, 0x80	; 128
    68d6:	5f e3       	ldi	r21, 0x3F	; 63
    68d8:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    68dc:	88 23       	and	r24, r24
    68de:	0c f0       	brlt	.+2      	; 0x68e2 <Ext1Power+0x7c>
    68e0:	10 e0       	ldi	r17, 0x00	; 0
    68e2:	11 23       	and	r17, r17
    68e4:	29 f0       	breq	.+10     	; 0x68f0 <Ext1Power+0x8a>
		__ticks = 1;
    68e6:	81 e0       	ldi	r24, 0x01	; 1
    68e8:	90 e0       	ldi	r25, 0x00	; 0
    68ea:	89 87       	std	Y+9, r24	; 0x09
    68ec:	9a 87       	std	Y+10, r25	; 0x0a
    68ee:	46 c0       	rjmp	.+140    	; 0x697c <Ext1Power+0x116>
	else if (__tmp > 65535)
    68f0:	11 e0       	ldi	r17, 0x01	; 1
    68f2:	6d 81       	ldd	r22, Y+5	; 0x05
    68f4:	7e 81       	ldd	r23, Y+6	; 0x06
    68f6:	8f 81       	ldd	r24, Y+7	; 0x07
    68f8:	98 85       	ldd	r25, Y+8	; 0x08
    68fa:	20 e0       	ldi	r18, 0x00	; 0
    68fc:	3f ef       	ldi	r19, 0xFF	; 255
    68fe:	4f e7       	ldi	r20, 0x7F	; 127
    6900:	57 e4       	ldi	r21, 0x47	; 71
    6902:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    6906:	18 16       	cp	r1, r24
    6908:	0c f0       	brlt	.+2      	; 0x690c <Ext1Power+0xa6>
    690a:	10 e0       	ldi	r17, 0x00	; 0
    690c:	11 23       	and	r17, r17
    690e:	61 f1       	breq	.+88     	; 0x6968 <Ext1Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6910:	69 81       	ldd	r22, Y+1	; 0x01
    6912:	7a 81       	ldd	r23, Y+2	; 0x02
    6914:	8b 81       	ldd	r24, Y+3	; 0x03
    6916:	9c 81       	ldd	r25, Y+4	; 0x04
    6918:	20 e0       	ldi	r18, 0x00	; 0
    691a:	30 e0       	ldi	r19, 0x00	; 0
    691c:	40 e2       	ldi	r20, 0x20	; 32
    691e:	51 e4       	ldi	r21, 0x41	; 65
    6920:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    6924:	dc 01       	movw	r26, r24
    6926:	cb 01       	movw	r24, r22
    6928:	bc 01       	movw	r22, r24
    692a:	cd 01       	movw	r24, r26
    692c:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    6930:	dc 01       	movw	r26, r24
    6932:	cb 01       	movw	r24, r22
    6934:	89 87       	std	Y+9, r24	; 0x09
    6936:	9a 87       	std	Y+10, r25	; 0x0a
    6938:	12 c0       	rjmp	.+36     	; 0x695e <Ext1Power+0xf8>
    693a:	80 e2       	ldi	r24, 0x20	; 32
    693c:	93 e0       	ldi	r25, 0x03	; 3
    693e:	8b 87       	std	Y+11, r24	; 0x0b
    6940:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6942:	8b 85       	ldd	r24, Y+11	; 0x0b
    6944:	9c 85       	ldd	r25, Y+12	; 0x0c
    6946:	8c 01       	movw	r16, r24
    6948:	c8 01       	movw	r24, r16
    694a:	01 97       	sbiw	r24, 0x01	; 1
    694c:	f1 f7       	brne	.-4      	; 0x694a <Ext1Power+0xe4>
    694e:	8c 01       	movw	r16, r24
    6950:	0b 87       	std	Y+11, r16	; 0x0b
    6952:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6954:	89 85       	ldd	r24, Y+9	; 0x09
    6956:	9a 85       	ldd	r25, Y+10	; 0x0a
    6958:	01 97       	sbiw	r24, 0x01	; 1
    695a:	89 87       	std	Y+9, r24	; 0x09
    695c:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    695e:	89 85       	ldd	r24, Y+9	; 0x09
    6960:	9a 85       	ldd	r25, Y+10	; 0x0a
    6962:	00 97       	sbiw	r24, 0x00	; 0
    6964:	51 f7       	brne	.-44     	; 0x693a <Ext1Power+0xd4>
    6966:	22 c0       	rjmp	.+68     	; 0x69ac <Ext1Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6968:	6d 81       	ldd	r22, Y+5	; 0x05
    696a:	7e 81       	ldd	r23, Y+6	; 0x06
    696c:	8f 81       	ldd	r24, Y+7	; 0x07
    696e:	98 85       	ldd	r25, Y+8	; 0x08
    6970:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    6974:	dc 01       	movw	r26, r24
    6976:	cb 01       	movw	r24, r22
    6978:	89 87       	std	Y+9, r24	; 0x09
    697a:	9a 87       	std	Y+10, r25	; 0x0a
    697c:	89 85       	ldd	r24, Y+9	; 0x09
    697e:	9a 85       	ldd	r25, Y+10	; 0x0a
    6980:	8d 87       	std	Y+13, r24	; 0x0d
    6982:	9e 87       	std	Y+14, r25	; 0x0e
    6984:	8d 85       	ldd	r24, Y+13	; 0x0d
    6986:	9e 85       	ldd	r25, Y+14	; 0x0e
    6988:	8c 01       	movw	r16, r24
    698a:	f8 01       	movw	r30, r16
    698c:	31 97       	sbiw	r30, 0x01	; 1
    698e:	f1 f7       	brne	.-4      	; 0x698c <Ext1Power+0x126>
    6990:	8f 01       	movw	r16, r30
    6992:	0d 87       	std	Y+13, r16	; 0x0d
    6994:	1e 87       	std	Y+14, r17	; 0x0e
    6996:	0a c0       	rjmp	.+20     	; 0x69ac <Ext1Power+0x146>
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    6998:	80 ea       	ldi	r24, 0xA0	; 160
    699a:	96 e0       	ldi	r25, 0x06	; 6
    699c:	20 e2       	ldi	r18, 0x20	; 32
    699e:	fc 01       	movw	r30, r24
    69a0:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    69a2:	80 ea       	ldi	r24, 0xA0	; 160
    69a4:	96 e0       	ldi	r25, 0x06	; 6
    69a6:	20 e2       	ldi	r18, 0x20	; 32
    69a8:	fc 01       	movw	r30, r24
    69aa:	22 83       	std	Z+2, r18	; 0x02
		//PortEx_OUTCLR(PIN3_bm, PS_BANKB);  //no need to write protect SDHC
	}
}
    69ac:	2f 96       	adiw	r28, 0x0f	; 15
    69ae:	cd bf       	out	0x3d, r28	; 61
    69b0:	de bf       	out	0x3e, r29	; 62
    69b2:	df 91       	pop	r29
    69b4:	cf 91       	pop	r28
    69b6:	1f 91       	pop	r17
    69b8:	0f 91       	pop	r16
    69ba:	08 95       	ret

000069bc <Ext2Power>:

void Ext2Power(uint8_t on) {
    69bc:	0f 93       	push	r16
    69be:	1f 93       	push	r17
    69c0:	cf 93       	push	r28
    69c2:	df 93       	push	r29
    69c4:	cd b7       	in	r28, 0x3d	; 61
    69c6:	de b7       	in	r29, 0x3e	; 62
    69c8:	2f 97       	sbiw	r28, 0x0f	; 15
    69ca:	cd bf       	out	0x3d, r28	; 61
    69cc:	de bf       	out	0x3e, r29	; 62
    69ce:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    69d0:	8f 85       	ldd	r24, Y+15	; 0x0f
    69d2:	88 23       	and	r24, r24
    69d4:	09 f4       	brne	.+2      	; 0x69d8 <Ext2Power+0x1c>
    69d6:	8b c0       	rjmp	.+278    	; 0x6aee <Ext2Power+0x132>
		PORTF.DIRSET = PIN6_bm;
    69d8:	80 ea       	ldi	r24, 0xA0	; 160
    69da:	96 e0       	ldi	r25, 0x06	; 6
    69dc:	20 e4       	ldi	r18, 0x40	; 64
    69de:	fc 01       	movw	r30, r24
    69e0:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN6_bm;
    69e2:	80 ea       	ldi	r24, 0xA0	; 160
    69e4:	96 e0       	ldi	r25, 0x06	; 6
    69e6:	20 e4       	ldi	r18, 0x40	; 64
    69e8:	fc 01       	movw	r30, r24
    69ea:	25 83       	std	Z+5, r18	; 0x05
    69ec:	80 e0       	ldi	r24, 0x00	; 0
    69ee:	90 e0       	ldi	r25, 0x00	; 0
    69f0:	a8 ec       	ldi	r26, 0xC8	; 200
    69f2:	b2 e4       	ldi	r27, 0x42	; 66
    69f4:	89 83       	std	Y+1, r24	; 0x01
    69f6:	9a 83       	std	Y+2, r25	; 0x02
    69f8:	ab 83       	std	Y+3, r26	; 0x03
    69fa:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    69fc:	69 81       	ldd	r22, Y+1	; 0x01
    69fe:	7a 81       	ldd	r23, Y+2	; 0x02
    6a00:	8b 81       	ldd	r24, Y+3	; 0x03
    6a02:	9c 81       	ldd	r25, Y+4	; 0x04
    6a04:	20 e0       	ldi	r18, 0x00	; 0
    6a06:	30 e0       	ldi	r19, 0x00	; 0
    6a08:	4a ef       	ldi	r20, 0xFA	; 250
    6a0a:	55 e4       	ldi	r21, 0x45	; 69
    6a0c:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    6a10:	dc 01       	movw	r26, r24
    6a12:	cb 01       	movw	r24, r22
    6a14:	8d 83       	std	Y+5, r24	; 0x05
    6a16:	9e 83       	std	Y+6, r25	; 0x06
    6a18:	af 83       	std	Y+7, r26	; 0x07
    6a1a:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6a1c:	11 e0       	ldi	r17, 0x01	; 1
    6a1e:	6d 81       	ldd	r22, Y+5	; 0x05
    6a20:	7e 81       	ldd	r23, Y+6	; 0x06
    6a22:	8f 81       	ldd	r24, Y+7	; 0x07
    6a24:	98 85       	ldd	r25, Y+8	; 0x08
    6a26:	20 e0       	ldi	r18, 0x00	; 0
    6a28:	30 e0       	ldi	r19, 0x00	; 0
    6a2a:	40 e8       	ldi	r20, 0x80	; 128
    6a2c:	5f e3       	ldi	r21, 0x3F	; 63
    6a2e:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    6a32:	88 23       	and	r24, r24
    6a34:	0c f0       	brlt	.+2      	; 0x6a38 <Ext2Power+0x7c>
    6a36:	10 e0       	ldi	r17, 0x00	; 0
    6a38:	11 23       	and	r17, r17
    6a3a:	29 f0       	breq	.+10     	; 0x6a46 <Ext2Power+0x8a>
		__ticks = 1;
    6a3c:	81 e0       	ldi	r24, 0x01	; 1
    6a3e:	90 e0       	ldi	r25, 0x00	; 0
    6a40:	89 87       	std	Y+9, r24	; 0x09
    6a42:	9a 87       	std	Y+10, r25	; 0x0a
    6a44:	46 c0       	rjmp	.+140    	; 0x6ad2 <Ext2Power+0x116>
	else if (__tmp > 65535)
    6a46:	11 e0       	ldi	r17, 0x01	; 1
    6a48:	6d 81       	ldd	r22, Y+5	; 0x05
    6a4a:	7e 81       	ldd	r23, Y+6	; 0x06
    6a4c:	8f 81       	ldd	r24, Y+7	; 0x07
    6a4e:	98 85       	ldd	r25, Y+8	; 0x08
    6a50:	20 e0       	ldi	r18, 0x00	; 0
    6a52:	3f ef       	ldi	r19, 0xFF	; 255
    6a54:	4f e7       	ldi	r20, 0x7F	; 127
    6a56:	57 e4       	ldi	r21, 0x47	; 71
    6a58:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    6a5c:	18 16       	cp	r1, r24
    6a5e:	0c f0       	brlt	.+2      	; 0x6a62 <Ext2Power+0xa6>
    6a60:	10 e0       	ldi	r17, 0x00	; 0
    6a62:	11 23       	and	r17, r17
    6a64:	61 f1       	breq	.+88     	; 0x6abe <Ext2Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6a66:	69 81       	ldd	r22, Y+1	; 0x01
    6a68:	7a 81       	ldd	r23, Y+2	; 0x02
    6a6a:	8b 81       	ldd	r24, Y+3	; 0x03
    6a6c:	9c 81       	ldd	r25, Y+4	; 0x04
    6a6e:	20 e0       	ldi	r18, 0x00	; 0
    6a70:	30 e0       	ldi	r19, 0x00	; 0
    6a72:	40 e2       	ldi	r20, 0x20	; 32
    6a74:	51 e4       	ldi	r21, 0x41	; 65
    6a76:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    6a7a:	dc 01       	movw	r26, r24
    6a7c:	cb 01       	movw	r24, r22
    6a7e:	bc 01       	movw	r22, r24
    6a80:	cd 01       	movw	r24, r26
    6a82:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    6a86:	dc 01       	movw	r26, r24
    6a88:	cb 01       	movw	r24, r22
    6a8a:	89 87       	std	Y+9, r24	; 0x09
    6a8c:	9a 87       	std	Y+10, r25	; 0x0a
    6a8e:	12 c0       	rjmp	.+36     	; 0x6ab4 <Ext2Power+0xf8>
    6a90:	80 e2       	ldi	r24, 0x20	; 32
    6a92:	93 e0       	ldi	r25, 0x03	; 3
    6a94:	8b 87       	std	Y+11, r24	; 0x0b
    6a96:	9c 87       	std	Y+12, r25	; 0x0c
    6a98:	8b 85       	ldd	r24, Y+11	; 0x0b
    6a9a:	9c 85       	ldd	r25, Y+12	; 0x0c
    6a9c:	8c 01       	movw	r16, r24
    6a9e:	c8 01       	movw	r24, r16
    6aa0:	01 97       	sbiw	r24, 0x01	; 1
    6aa2:	f1 f7       	brne	.-4      	; 0x6aa0 <Ext2Power+0xe4>
    6aa4:	8c 01       	movw	r16, r24
    6aa6:	0b 87       	std	Y+11, r16	; 0x0b
    6aa8:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6aaa:	89 85       	ldd	r24, Y+9	; 0x09
    6aac:	9a 85       	ldd	r25, Y+10	; 0x0a
    6aae:	01 97       	sbiw	r24, 0x01	; 1
    6ab0:	89 87       	std	Y+9, r24	; 0x09
    6ab2:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6ab4:	89 85       	ldd	r24, Y+9	; 0x09
    6ab6:	9a 85       	ldd	r25, Y+10	; 0x0a
    6ab8:	00 97       	sbiw	r24, 0x00	; 0
    6aba:	51 f7       	brne	.-44     	; 0x6a90 <Ext2Power+0xd4>
    6abc:	22 c0       	rjmp	.+68     	; 0x6b02 <Ext2Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6abe:	6d 81       	ldd	r22, Y+5	; 0x05
    6ac0:	7e 81       	ldd	r23, Y+6	; 0x06
    6ac2:	8f 81       	ldd	r24, Y+7	; 0x07
    6ac4:	98 85       	ldd	r25, Y+8	; 0x08
    6ac6:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    6aca:	dc 01       	movw	r26, r24
    6acc:	cb 01       	movw	r24, r22
    6ace:	89 87       	std	Y+9, r24	; 0x09
    6ad0:	9a 87       	std	Y+10, r25	; 0x0a
    6ad2:	89 85       	ldd	r24, Y+9	; 0x09
    6ad4:	9a 85       	ldd	r25, Y+10	; 0x0a
    6ad6:	8d 87       	std	Y+13, r24	; 0x0d
    6ad8:	9e 87       	std	Y+14, r25	; 0x0e
    6ada:	8d 85       	ldd	r24, Y+13	; 0x0d
    6adc:	9e 85       	ldd	r25, Y+14	; 0x0e
    6ade:	8c 01       	movw	r16, r24
    6ae0:	f8 01       	movw	r30, r16
    6ae2:	31 97       	sbiw	r30, 0x01	; 1
    6ae4:	f1 f7       	brne	.-4      	; 0x6ae2 <Ext2Power+0x126>
    6ae6:	8f 01       	movw	r16, r30
    6ae8:	0d 87       	std	Y+13, r16	; 0x0d
    6aea:	1e 87       	std	Y+14, r17	; 0x0e
    6aec:	0a c0       	rjmp	.+20     	; 0x6b02 <Ext2Power+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    6aee:	80 ea       	ldi	r24, 0xA0	; 160
    6af0:	96 e0       	ldi	r25, 0x06	; 6
    6af2:	20 e4       	ldi	r18, 0x40	; 64
    6af4:	fc 01       	movw	r30, r24
    6af6:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    6af8:	80 ea       	ldi	r24, 0xA0	; 160
    6afa:	96 e0       	ldi	r25, 0x06	; 6
    6afc:	20 e4       	ldi	r18, 0x40	; 64
    6afe:	fc 01       	movw	r30, r24
    6b00:	22 83       	std	Z+2, r18	; 0x02
	}
}
    6b02:	2f 96       	adiw	r28, 0x0f	; 15
    6b04:	cd bf       	out	0x3d, r28	; 61
    6b06:	de bf       	out	0x3e, r29	; 62
    6b08:	df 91       	pop	r29
    6b0a:	cf 91       	pop	r28
    6b0c:	1f 91       	pop	r17
    6b0e:	0f 91       	pop	r16
    6b10:	08 95       	ret

00006b12 <HVPower>:

void HVPower(uint8_t on) {
    6b12:	0f 93       	push	r16
    6b14:	1f 93       	push	r17
    6b16:	cf 93       	push	r28
    6b18:	df 93       	push	r29
    6b1a:	cd b7       	in	r28, 0x3d	; 61
    6b1c:	de b7       	in	r29, 0x3e	; 62
    6b1e:	a7 97       	sbiw	r28, 0x27	; 39
    6b20:	cd bf       	out	0x3d, r28	; 61
    6b22:	de bf       	out	0x3e, r29	; 62
    6b24:	8f a3       	lds	r24, 0x5f
	if (on) {
    6b26:	8f a1       	lds	r24, 0x4f
    6b28:	88 23       	and	r24, r24
    6b2a:	09 f4       	brne	.+2      	; 0x6b2e <HVPower+0x1c>
    6b2c:	8b c0       	rjmp	.+278    	; 0x6c44 <HVPower+0x132>
		PORTF.DIRSET = PIN7_bm;
    6b2e:	80 ea       	ldi	r24, 0xA0	; 160
    6b30:	96 e0       	ldi	r25, 0x06	; 6
    6b32:	20 e8       	ldi	r18, 0x80	; 128
    6b34:	fc 01       	movw	r30, r24
    6b36:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN7_bm;
    6b38:	80 ea       	ldi	r24, 0xA0	; 160
    6b3a:	96 e0       	ldi	r25, 0x06	; 6
    6b3c:	20 e8       	ldi	r18, 0x80	; 128
    6b3e:	fc 01       	movw	r30, r24
    6b40:	25 83       	std	Z+5, r18	; 0x05
    6b42:	80 e0       	ldi	r24, 0x00	; 0
    6b44:	90 e0       	ldi	r25, 0x00	; 0
    6b46:	a8 ec       	ldi	r26, 0xC8	; 200
    6b48:	b2 e4       	ldi	r27, 0x42	; 66
    6b4a:	89 83       	std	Y+1, r24	; 0x01
    6b4c:	9a 83       	std	Y+2, r25	; 0x02
    6b4e:	ab 83       	std	Y+3, r26	; 0x03
    6b50:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6b52:	69 81       	ldd	r22, Y+1	; 0x01
    6b54:	7a 81       	ldd	r23, Y+2	; 0x02
    6b56:	8b 81       	ldd	r24, Y+3	; 0x03
    6b58:	9c 81       	ldd	r25, Y+4	; 0x04
    6b5a:	20 e0       	ldi	r18, 0x00	; 0
    6b5c:	30 e0       	ldi	r19, 0x00	; 0
    6b5e:	4a ef       	ldi	r20, 0xFA	; 250
    6b60:	55 e4       	ldi	r21, 0x45	; 69
    6b62:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    6b66:	dc 01       	movw	r26, r24
    6b68:	cb 01       	movw	r24, r22
    6b6a:	8d 83       	std	Y+5, r24	; 0x05
    6b6c:	9e 83       	std	Y+6, r25	; 0x06
    6b6e:	af 83       	std	Y+7, r26	; 0x07
    6b70:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6b72:	11 e0       	ldi	r17, 0x01	; 1
    6b74:	6d 81       	ldd	r22, Y+5	; 0x05
    6b76:	7e 81       	ldd	r23, Y+6	; 0x06
    6b78:	8f 81       	ldd	r24, Y+7	; 0x07
    6b7a:	98 85       	ldd	r25, Y+8	; 0x08
    6b7c:	20 e0       	ldi	r18, 0x00	; 0
    6b7e:	30 e0       	ldi	r19, 0x00	; 0
    6b80:	40 e8       	ldi	r20, 0x80	; 128
    6b82:	5f e3       	ldi	r21, 0x3F	; 63
    6b84:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    6b88:	88 23       	and	r24, r24
    6b8a:	0c f0       	brlt	.+2      	; 0x6b8e <HVPower+0x7c>
    6b8c:	10 e0       	ldi	r17, 0x00	; 0
    6b8e:	11 23       	and	r17, r17
    6b90:	29 f0       	breq	.+10     	; 0x6b9c <HVPower+0x8a>
		__ticks = 1;
    6b92:	81 e0       	ldi	r24, 0x01	; 1
    6b94:	90 e0       	ldi	r25, 0x00	; 0
    6b96:	89 87       	std	Y+9, r24	; 0x09
    6b98:	9a 87       	std	Y+10, r25	; 0x0a
    6b9a:	46 c0       	rjmp	.+140    	; 0x6c28 <HVPower+0x116>
	else if (__tmp > 65535)
    6b9c:	11 e0       	ldi	r17, 0x01	; 1
    6b9e:	6d 81       	ldd	r22, Y+5	; 0x05
    6ba0:	7e 81       	ldd	r23, Y+6	; 0x06
    6ba2:	8f 81       	ldd	r24, Y+7	; 0x07
    6ba4:	98 85       	ldd	r25, Y+8	; 0x08
    6ba6:	20 e0       	ldi	r18, 0x00	; 0
    6ba8:	3f ef       	ldi	r19, 0xFF	; 255
    6baa:	4f e7       	ldi	r20, 0x7F	; 127
    6bac:	57 e4       	ldi	r21, 0x47	; 71
    6bae:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    6bb2:	18 16       	cp	r1, r24
    6bb4:	0c f0       	brlt	.+2      	; 0x6bb8 <HVPower+0xa6>
    6bb6:	10 e0       	ldi	r17, 0x00	; 0
    6bb8:	11 23       	and	r17, r17
    6bba:	61 f1       	breq	.+88     	; 0x6c14 <HVPower+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6bbc:	69 81       	ldd	r22, Y+1	; 0x01
    6bbe:	7a 81       	ldd	r23, Y+2	; 0x02
    6bc0:	8b 81       	ldd	r24, Y+3	; 0x03
    6bc2:	9c 81       	ldd	r25, Y+4	; 0x04
    6bc4:	20 e0       	ldi	r18, 0x00	; 0
    6bc6:	30 e0       	ldi	r19, 0x00	; 0
    6bc8:	40 e2       	ldi	r20, 0x20	; 32
    6bca:	51 e4       	ldi	r21, 0x41	; 65
    6bcc:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    6bd0:	dc 01       	movw	r26, r24
    6bd2:	cb 01       	movw	r24, r22
    6bd4:	bc 01       	movw	r22, r24
    6bd6:	cd 01       	movw	r24, r26
    6bd8:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    6bdc:	dc 01       	movw	r26, r24
    6bde:	cb 01       	movw	r24, r22
    6be0:	89 87       	std	Y+9, r24	; 0x09
    6be2:	9a 87       	std	Y+10, r25	; 0x0a
    6be4:	12 c0       	rjmp	.+36     	; 0x6c0a <HVPower+0xf8>
    6be6:	80 e2       	ldi	r24, 0x20	; 32
    6be8:	93 e0       	ldi	r25, 0x03	; 3
    6bea:	8b 87       	std	Y+11, r24	; 0x0b
    6bec:	9c 87       	std	Y+12, r25	; 0x0c
    6bee:	8b 85       	ldd	r24, Y+11	; 0x0b
    6bf0:	9c 85       	ldd	r25, Y+12	; 0x0c
    6bf2:	8c 01       	movw	r16, r24
    6bf4:	c8 01       	movw	r24, r16
    6bf6:	01 97       	sbiw	r24, 0x01	; 1
    6bf8:	f1 f7       	brne	.-4      	; 0x6bf6 <HVPower+0xe4>
    6bfa:	8c 01       	movw	r16, r24
    6bfc:	0b 87       	std	Y+11, r16	; 0x0b
    6bfe:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6c00:	89 85       	ldd	r24, Y+9	; 0x09
    6c02:	9a 85       	ldd	r25, Y+10	; 0x0a
    6c04:	01 97       	sbiw	r24, 0x01	; 1
    6c06:	89 87       	std	Y+9, r24	; 0x09
    6c08:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6c0a:	89 85       	ldd	r24, Y+9	; 0x09
    6c0c:	9a 85       	ldd	r25, Y+10	; 0x0a
    6c0e:	00 97       	sbiw	r24, 0x00	; 0
    6c10:	51 f7       	brne	.-44     	; 0x6be6 <HVPower+0xd4>
    6c12:	22 c0       	rjmp	.+68     	; 0x6c58 <HVPower+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6c14:	6d 81       	ldd	r22, Y+5	; 0x05
    6c16:	7e 81       	ldd	r23, Y+6	; 0x06
    6c18:	8f 81       	ldd	r24, Y+7	; 0x07
    6c1a:	98 85       	ldd	r25, Y+8	; 0x08
    6c1c:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    6c20:	dc 01       	movw	r26, r24
    6c22:	cb 01       	movw	r24, r22
    6c24:	89 87       	std	Y+9, r24	; 0x09
    6c26:	9a 87       	std	Y+10, r25	; 0x0a
    6c28:	89 85       	ldd	r24, Y+9	; 0x09
    6c2a:	9a 85       	ldd	r25, Y+10	; 0x0a
    6c2c:	8d 87       	std	Y+13, r24	; 0x0d
    6c2e:	9e 87       	std	Y+14, r25	; 0x0e
    6c30:	8d 85       	ldd	r24, Y+13	; 0x0d
    6c32:	9e 85       	ldd	r25, Y+14	; 0x0e
    6c34:	8c 01       	movw	r16, r24
    6c36:	f8 01       	movw	r30, r16
    6c38:	31 97       	sbiw	r30, 0x01	; 1
    6c3a:	f1 f7       	brne	.-4      	; 0x6c38 <HVPower+0x126>
    6c3c:	8f 01       	movw	r16, r30
    6c3e:	0d 87       	std	Y+13, r16	; 0x0d
    6c40:	1e 87       	std	Y+14, r17	; 0x0e
    6c42:	0a c0       	rjmp	.+20     	; 0x6c58 <HVPower+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    6c44:	80 ea       	ldi	r24, 0xA0	; 160
    6c46:	96 e0       	ldi	r25, 0x06	; 6
    6c48:	20 e8       	ldi	r18, 0x80	; 128
    6c4a:	fc 01       	movw	r30, r24
    6c4c:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    6c4e:	80 ea       	ldi	r24, 0xA0	; 160
    6c50:	96 e0       	ldi	r25, 0x06	; 6
    6c52:	20 e8       	ldi	r18, 0x80	; 128
    6c54:	fc 01       	movw	r30, r24
    6c56:	22 83       	std	Z+2, r18	; 0x02
    6c58:	80 e0       	ldi	r24, 0x00	; 0
    6c5a:	90 e0       	ldi	r25, 0x00	; 0
    6c5c:	aa e7       	ldi	r26, 0x7A	; 122
    6c5e:	b4 e4       	ldi	r27, 0x44	; 68
    6c60:	8f 87       	std	Y+15, r24	; 0x0f
    6c62:	98 8b       	std	Y+16, r25	; 0x10
    6c64:	a9 8b       	std	Y+17, r26	; 0x11
    6c66:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    6c68:	6f 85       	ldd	r22, Y+15	; 0x0f
    6c6a:	78 89       	ldd	r23, Y+16	; 0x10
    6c6c:	89 89       	ldd	r24, Y+17	; 0x11
    6c6e:	9a 89       	ldd	r25, Y+18	; 0x12
    6c70:	2b ea       	ldi	r18, 0xAB	; 171
    6c72:	3a ea       	ldi	r19, 0xAA	; 170
    6c74:	4a e2       	ldi	r20, 0x2A	; 42
    6c76:	51 e4       	ldi	r21, 0x41	; 65
    6c78:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    6c7c:	dc 01       	movw	r26, r24
    6c7e:	cb 01       	movw	r24, r22
    6c80:	8b 8b       	std	Y+19, r24	; 0x13
    6c82:	9c 8b       	std	Y+20, r25	; 0x14
    6c84:	ad 8b       	std	Y+21, r26	; 0x15
    6c86:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    6c88:	11 e0       	ldi	r17, 0x01	; 1
    6c8a:	6b 89       	ldd	r22, Y+19	; 0x13
    6c8c:	7c 89       	ldd	r23, Y+20	; 0x14
    6c8e:	8d 89       	ldd	r24, Y+21	; 0x15
    6c90:	9e 89       	ldd	r25, Y+22	; 0x16
    6c92:	20 e0       	ldi	r18, 0x00	; 0
    6c94:	30 e0       	ldi	r19, 0x00	; 0
    6c96:	40 e8       	ldi	r20, 0x80	; 128
    6c98:	5f e3       	ldi	r21, 0x3F	; 63
    6c9a:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    6c9e:	88 23       	and	r24, r24
    6ca0:	0c f0       	brlt	.+2      	; 0x6ca4 <HVPower+0x192>
    6ca2:	10 e0       	ldi	r17, 0x00	; 0
    6ca4:	11 23       	and	r17, r17
    6ca6:	19 f0       	breq	.+6      	; 0x6cae <HVPower+0x19c>
		__ticks = 1;
    6ca8:	81 e0       	ldi	r24, 0x01	; 1
    6caa:	8f 8b       	std	Y+23, r24	; 0x17
    6cac:	a3 c0       	rjmp	.+326    	; 0x6df4 <HVPower+0x2e2>
	else if (__tmp > 255)
    6cae:	11 e0       	ldi	r17, 0x01	; 1
    6cb0:	6b 89       	ldd	r22, Y+19	; 0x13
    6cb2:	7c 89       	ldd	r23, Y+20	; 0x14
    6cb4:	8d 89       	ldd	r24, Y+21	; 0x15
    6cb6:	9e 89       	ldd	r25, Y+22	; 0x16
    6cb8:	20 e0       	ldi	r18, 0x00	; 0
    6cba:	30 e0       	ldi	r19, 0x00	; 0
    6cbc:	4f e7       	ldi	r20, 0x7F	; 127
    6cbe:	53 e4       	ldi	r21, 0x43	; 67
    6cc0:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    6cc4:	18 16       	cp	r1, r24
    6cc6:	0c f0       	brlt	.+2      	; 0x6cca <HVPower+0x1b8>
    6cc8:	10 e0       	ldi	r17, 0x00	; 0
    6cca:	11 23       	and	r17, r17
    6ccc:	09 f4       	brne	.+2      	; 0x6cd0 <HVPower+0x1be>
    6cce:	89 c0       	rjmp	.+274    	; 0x6de2 <HVPower+0x2d0>
	{
		_delay_ms(__us / 1000.0);
    6cd0:	6f 85       	ldd	r22, Y+15	; 0x0f
    6cd2:	78 89       	ldd	r23, Y+16	; 0x10
    6cd4:	89 89       	ldd	r24, Y+17	; 0x11
    6cd6:	9a 89       	ldd	r25, Y+18	; 0x12
    6cd8:	20 e0       	ldi	r18, 0x00	; 0
    6cda:	30 e0       	ldi	r19, 0x00	; 0
    6cdc:	4a e7       	ldi	r20, 0x7A	; 122
    6cde:	54 e4       	ldi	r21, 0x44	; 68
    6ce0:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
    6ce4:	dc 01       	movw	r26, r24
    6ce6:	cb 01       	movw	r24, r22
    6ce8:	88 8f       	std	Y+24, r24	; 0x18
    6cea:	99 8f       	std	Y+25, r25	; 0x19
    6cec:	aa 8f       	std	Y+26, r26	; 0x1a
    6cee:	bb 8f       	std	Y+27, r27	; 0x1b
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6cf0:	68 8d       	ldd	r22, Y+24	; 0x18
    6cf2:	79 8d       	ldd	r23, Y+25	; 0x19
    6cf4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6cf6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6cf8:	20 e0       	ldi	r18, 0x00	; 0
    6cfa:	30 e0       	ldi	r19, 0x00	; 0
    6cfc:	4a ef       	ldi	r20, 0xFA	; 250
    6cfe:	55 e4       	ldi	r21, 0x45	; 69
    6d00:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    6d04:	dc 01       	movw	r26, r24
    6d06:	cb 01       	movw	r24, r22
    6d08:	8c 8f       	std	Y+28, r24	; 0x1c
    6d0a:	9d 8f       	std	Y+29, r25	; 0x1d
    6d0c:	ae 8f       	std	Y+30, r26	; 0x1e
    6d0e:	bf 8f       	std	Y+31, r27	; 0x1f
	if (__tmp < 1.0)
    6d10:	11 e0       	ldi	r17, 0x01	; 1
    6d12:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6d14:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6d16:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6d18:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6d1a:	20 e0       	ldi	r18, 0x00	; 0
    6d1c:	30 e0       	ldi	r19, 0x00	; 0
    6d1e:	40 e8       	ldi	r20, 0x80	; 128
    6d20:	5f e3       	ldi	r21, 0x3F	; 63
    6d22:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    6d26:	88 23       	and	r24, r24
    6d28:	0c f0       	brlt	.+2      	; 0x6d2c <HVPower+0x21a>
    6d2a:	10 e0       	ldi	r17, 0x00	; 0
    6d2c:	11 23       	and	r17, r17
    6d2e:	29 f0       	breq	.+10     	; 0x6d3a <HVPower+0x228>
		__ticks = 1;
    6d30:	81 e0       	ldi	r24, 0x01	; 1
    6d32:	90 e0       	ldi	r25, 0x00	; 0
    6d34:	88 a3       	lds	r24, 0x58
    6d36:	99 a3       	lds	r25, 0x59
    6d38:	46 c0       	rjmp	.+140    	; 0x6dc6 <HVPower+0x2b4>
	else if (__tmp > 65535)
    6d3a:	11 e0       	ldi	r17, 0x01	; 1
    6d3c:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6d3e:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6d40:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6d42:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6d44:	20 e0       	ldi	r18, 0x00	; 0
    6d46:	3f ef       	ldi	r19, 0xFF	; 255
    6d48:	4f e7       	ldi	r20, 0x7F	; 127
    6d4a:	57 e4       	ldi	r21, 0x47	; 71
    6d4c:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    6d50:	18 16       	cp	r1, r24
    6d52:	0c f0       	brlt	.+2      	; 0x6d56 <HVPower+0x244>
    6d54:	10 e0       	ldi	r17, 0x00	; 0
    6d56:	11 23       	and	r17, r17
    6d58:	61 f1       	breq	.+88     	; 0x6db2 <HVPower+0x2a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6d5a:	68 8d       	ldd	r22, Y+24	; 0x18
    6d5c:	79 8d       	ldd	r23, Y+25	; 0x19
    6d5e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6d60:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6d62:	20 e0       	ldi	r18, 0x00	; 0
    6d64:	30 e0       	ldi	r19, 0x00	; 0
    6d66:	40 e2       	ldi	r20, 0x20	; 32
    6d68:	51 e4       	ldi	r21, 0x41	; 65
    6d6a:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    6d6e:	dc 01       	movw	r26, r24
    6d70:	cb 01       	movw	r24, r22
    6d72:	bc 01       	movw	r22, r24
    6d74:	cd 01       	movw	r24, r26
    6d76:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    6d7a:	dc 01       	movw	r26, r24
    6d7c:	cb 01       	movw	r24, r22
    6d7e:	88 a3       	lds	r24, 0x58
    6d80:	99 a3       	lds	r25, 0x59
    6d82:	12 c0       	rjmp	.+36     	; 0x6da8 <HVPower+0x296>
    6d84:	80 e2       	ldi	r24, 0x20	; 32
    6d86:	93 e0       	ldi	r25, 0x03	; 3
    6d88:	8a a3       	lds	r24, 0x5a
    6d8a:	9b a3       	lds	r25, 0x5b
    6d8c:	8a a1       	lds	r24, 0x4a
    6d8e:	9b a1       	lds	r25, 0x4b
    6d90:	8c 01       	movw	r16, r24
    6d92:	c8 01       	movw	r24, r16
    6d94:	01 97       	sbiw	r24, 0x01	; 1
    6d96:	f1 f7       	brne	.-4      	; 0x6d94 <HVPower+0x282>
    6d98:	8c 01       	movw	r16, r24
    6d9a:	0a a3       	lds	r16, 0x5a
    6d9c:	1b a3       	lds	r17, 0x5b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6d9e:	88 a1       	lds	r24, 0x48
    6da0:	99 a1       	lds	r25, 0x49
    6da2:	01 97       	sbiw	r24, 0x01	; 1
    6da4:	88 a3       	lds	r24, 0x58
    6da6:	99 a3       	lds	r25, 0x59
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6da8:	88 a1       	lds	r24, 0x48
    6daa:	99 a1       	lds	r25, 0x49
    6dac:	00 97       	sbiw	r24, 0x00	; 0
    6dae:	51 f7       	brne	.-44     	; 0x6d84 <HVPower+0x272>
    6db0:	28 c0       	rjmp	.+80     	; 0x6e02 <HVPower+0x2f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6db2:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6db4:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6db6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6db8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6dba:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    6dbe:	dc 01       	movw	r26, r24
    6dc0:	cb 01       	movw	r24, r22
    6dc2:	88 a3       	lds	r24, 0x58
    6dc4:	99 a3       	lds	r25, 0x59
    6dc6:	88 a1       	lds	r24, 0x48
    6dc8:	99 a1       	lds	r25, 0x49
    6dca:	8c a3       	lds	r24, 0x5c
    6dcc:	9d a3       	lds	r25, 0x5d
    6dce:	8c a1       	lds	r24, 0x4c
    6dd0:	9d a1       	lds	r25, 0x4d
    6dd2:	8c 01       	movw	r16, r24
    6dd4:	f8 01       	movw	r30, r16
    6dd6:	31 97       	sbiw	r30, 0x01	; 1
    6dd8:	f1 f7       	brne	.-4      	; 0x6dd6 <HVPower+0x2c4>
    6dda:	8f 01       	movw	r16, r30
    6ddc:	0c a3       	lds	r16, 0x5c
    6dde:	1d a3       	lds	r17, 0x5d
    6de0:	10 c0       	rjmp	.+32     	; 0x6e02 <HVPower+0x2f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6de2:	6b 89       	ldd	r22, Y+19	; 0x13
    6de4:	7c 89       	ldd	r23, Y+20	; 0x14
    6de6:	8d 89       	ldd	r24, Y+21	; 0x15
    6de8:	9e 89       	ldd	r25, Y+22	; 0x16
    6dea:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    6dee:	dc 01       	movw	r26, r24
    6df0:	cb 01       	movw	r24, r22
    6df2:	8f 8b       	std	Y+23, r24	; 0x17
    6df4:	8f 89       	ldd	r24, Y+23	; 0x17
    6df6:	8e a3       	lds	r24, 0x5e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6df8:	8e a1       	lds	r24, 0x4e
    6dfa:	18 2f       	mov	r17, r24
    6dfc:	1a 95       	dec	r17
    6dfe:	f1 f7       	brne	.-4      	; 0x6dfc <HVPower+0x2ea>
    6e00:	1e a3       	lds	r17, 0x5e
	}
	_delay_us(1000);
}
    6e02:	a7 96       	adiw	r28, 0x27	; 39
    6e04:	cd bf       	out	0x3d, r28	; 61
    6e06:	de bf       	out	0x3e, r29	; 62
    6e08:	df 91       	pop	r29
    6e0a:	cf 91       	pop	r28
    6e0c:	1f 91       	pop	r17
    6e0e:	0f 91       	pop	r16
    6e10:	08 95       	ret

00006e12 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
    6e12:	cf 93       	push	r28
    6e14:	df 93       	push	r29
    6e16:	0f 92       	push	r0
    6e18:	cd b7       	in	r28, 0x3d	; 61
    6e1a:	de b7       	in	r29, 0x3e	; 62
    6e1c:	89 83       	std	Y+1, r24	; 0x01
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    6e1e:	89 81       	ldd	r24, Y+1	; 0x01
    6e20:	88 23       	and	r24, r24
    6e22:	31 f0       	breq	.+12     	; 0x6e30 <lowerMuxCS+0x1e>
    6e24:	80 e8       	ldi	r24, 0x80	; 128
    6e26:	96 e0       	ldi	r25, 0x06	; 6
    6e28:	20 e1       	ldi	r18, 0x10	; 16
    6e2a:	fc 01       	movw	r30, r24
    6e2c:	26 83       	std	Z+6, r18	; 0x06
    6e2e:	05 c0       	rjmp	.+10     	; 0x6e3a <lowerMuxCS+0x28>
	else PORTE.OUTSET = PIN4_bm;
    6e30:	80 e8       	ldi	r24, 0x80	; 128
    6e32:	96 e0       	ldi	r25, 0x06	; 6
    6e34:	20 e1       	ldi	r18, 0x10	; 16
    6e36:	fc 01       	movw	r30, r24
    6e38:	25 83       	std	Z+5, r18	; 0x05
}
    6e3a:	0f 90       	pop	r0
    6e3c:	df 91       	pop	r29
    6e3e:	cf 91       	pop	r28
    6e40:	08 95       	ret

00006e42 <upperMuxCS>:
void upperMuxCS(uint8_t write) {
    6e42:	cf 93       	push	r28
    6e44:	df 93       	push	r29
    6e46:	0f 92       	push	r0
    6e48:	cd b7       	in	r28, 0x3d	; 61
    6e4a:	de b7       	in	r29, 0x3e	; 62
    6e4c:	89 83       	std	Y+1, r24	; 0x01
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    6e4e:	89 81       	ldd	r24, Y+1	; 0x01
    6e50:	88 23       	and	r24, r24
    6e52:	31 f0       	breq	.+12     	; 0x6e60 <upperMuxCS+0x1e>
    6e54:	80 e4       	ldi	r24, 0x40	; 64
    6e56:	96 e0       	ldi	r25, 0x06	; 6
    6e58:	22 e0       	ldi	r18, 0x02	; 2
    6e5a:	fc 01       	movw	r30, r24
    6e5c:	26 83       	std	Z+6, r18	; 0x06
    6e5e:	05 c0       	rjmp	.+10     	; 0x6e6a <upperMuxCS+0x28>
	else PORTC.OUTSET = PIN1_bm;
    6e60:	80 e4       	ldi	r24, 0x40	; 64
    6e62:	96 e0       	ldi	r25, 0x06	; 6
    6e64:	22 e0       	ldi	r18, 0x02	; 2
    6e66:	fc 01       	movw	r30, r24
    6e68:	25 83       	std	Z+5, r18	; 0x05
}
    6e6a:	0f 90       	pop	r0
    6e6c:	df 91       	pop	r29
    6e6e:	cf 91       	pop	r28
    6e70:	08 95       	ret

00006e72 <SPIInit>:

void SPIInit(uint8_t mode) {
    6e72:	cf 93       	push	r28
    6e74:	df 93       	push	r29
    6e76:	0f 92       	push	r0
    6e78:	cd b7       	in	r28, 0x3d	; 61
    6e7a:	de b7       	in	r29, 0x3e	; 62
    6e7c:	89 83       	std	Y+1, r24	; 0x01
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    6e7e:	80 e4       	ldi	r24, 0x40	; 64
    6e80:	96 e0       	ldi	r25, 0x06	; 6
    6e82:	20 e1       	ldi	r18, 0x10	; 16
    6e84:	fc 01       	movw	r30, r24
    6e86:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    6e88:	80 e4       	ldi	r24, 0x40	; 64
    6e8a:	96 e0       	ldi	r25, 0x06	; 6
    6e8c:	28 e3       	ldi	r18, 0x38	; 56
    6e8e:	fc 01       	movw	r30, r24
    6e90:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    6e92:	80 e4       	ldi	r24, 0x40	; 64
    6e94:	96 e0       	ldi	r25, 0x06	; 6
    6e96:	20 e1       	ldi	r18, 0x10	; 16
    6e98:	fc 01       	movw	r30, r24
    6e9a:	25 83       	std	Z+5, r18	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    6e9c:	80 ec       	ldi	r24, 0xC0	; 192
    6e9e:	98 e0       	ldi	r25, 0x08	; 8
    6ea0:	29 81       	ldd	r18, Y+1	; 0x01
    6ea2:	21 65       	ori	r18, 0x51	; 81
    6ea4:	fc 01       	movw	r30, r24
    6ea6:	20 83       	st	Z, r18
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    6ea8:	80 ec       	ldi	r24, 0xC0	; 192
    6eaa:	98 e0       	ldi	r25, 0x08	; 8
    6eac:	fc 01       	movw	r30, r24
    6eae:	11 82       	std	Z+1, r1	; 0x01

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    6eb0:	80 e4       	ldi	r24, 0x40	; 64
    6eb2:	96 e0       	ldi	r25, 0x06	; 6
    6eb4:	20 ea       	ldi	r18, 0xA0	; 160
    6eb6:	fc 01       	movw	r30, r24
    6eb8:	21 83       	std	Z+1, r18	; 0x01

	
}
    6eba:	0f 90       	pop	r0
    6ebc:	df 91       	pop	r29
    6ebe:	cf 91       	pop	r28
    6ec0:	08 95       	ret

00006ec2 <SPIInit2>:
//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
    6ec2:	cf 93       	push	r28
    6ec4:	df 93       	push	r29
    6ec6:	0f 92       	push	r0
    6ec8:	0f 92       	push	r0
    6eca:	cd b7       	in	r28, 0x3d	; 61
    6ecc:	de b7       	in	r29, 0x3e	; 62
    6ece:	89 83       	std	Y+1, r24	; 0x01
    6ed0:	6a 83       	std	Y+2, r22	; 0x02
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    6ed2:	80 e4       	ldi	r24, 0x40	; 64
    6ed4:	96 e0       	ldi	r25, 0x06	; 6
    6ed6:	20 e1       	ldi	r18, 0x10	; 16
    6ed8:	fc 01       	movw	r30, r24
    6eda:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    6edc:	80 e4       	ldi	r24, 0x40	; 64
    6ede:	96 e0       	ldi	r25, 0x06	; 6
    6ee0:	28 e3       	ldi	r18, 0x38	; 56
    6ee2:	fc 01       	movw	r30, r24
    6ee4:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    6ee6:	80 e4       	ldi	r24, 0x40	; 64
    6ee8:	96 e0       	ldi	r25, 0x06	; 6
    6eea:	20 e1       	ldi	r18, 0x10	; 16
    6eec:	fc 01       	movw	r30, r24
    6eee:	25 83       	std	Z+5, r18	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    6ef0:	80 ec       	ldi	r24, 0xC0	; 192
    6ef2:	98 e0       	ldi	r25, 0x08	; 8
    6ef4:	3a 81       	ldd	r19, Y+2	; 0x02
    6ef6:	29 81       	ldd	r18, Y+1	; 0x01
    6ef8:	23 2b       	or	r18, r19
    6efa:	20 65       	ori	r18, 0x50	; 80
    6efc:	fc 01       	movw	r30, r24
    6efe:	20 83       	st	Z, r18
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    6f00:	80 ec       	ldi	r24, 0xC0	; 192
    6f02:	98 e0       	ldi	r25, 0x08	; 8
    6f04:	fc 01       	movw	r30, r24
    6f06:	11 82       	std	Z+1, r1	; 0x01

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    6f08:	80 e4       	ldi	r24, 0x40	; 64
    6f0a:	96 e0       	ldi	r25, 0x06	; 6
    6f0c:	20 ea       	ldi	r18, 0xA0	; 160
    6f0e:	fc 01       	movw	r30, r24
    6f10:	21 83       	std	Z+1, r18	; 0x01
}
    6f12:	0f 90       	pop	r0
    6f14:	0f 90       	pop	r0
    6f16:	df 91       	pop	r29
    6f18:	cf 91       	pop	r28
    6f1a:	08 95       	ret

00006f1c <SPICS>:

void SPICS(uint8_t enable) {
    6f1c:	cf 93       	push	r28
    6f1e:	df 93       	push	r29
    6f20:	0f 92       	push	r0
    6f22:	cd b7       	in	r28, 0x3d	; 61
    6f24:	de b7       	in	r29, 0x3e	; 62
    6f26:	89 83       	std	Y+1, r24	; 0x01
	if (enable) PORTC.OUTCLR = PIN4_bm;
    6f28:	89 81       	ldd	r24, Y+1	; 0x01
    6f2a:	88 23       	and	r24, r24
    6f2c:	31 f0       	breq	.+12     	; 0x6f3a <SPICS+0x1e>
    6f2e:	80 e4       	ldi	r24, 0x40	; 64
    6f30:	96 e0       	ldi	r25, 0x06	; 6
    6f32:	20 e1       	ldi	r18, 0x10	; 16
    6f34:	fc 01       	movw	r30, r24
    6f36:	26 83       	std	Z+6, r18	; 0x06
    6f38:	05 c0       	rjmp	.+10     	; 0x6f44 <SPICS+0x28>
	else {
		PORTC.OUTSET = PIN4_bm;
    6f3a:	80 e4       	ldi	r24, 0x40	; 64
    6f3c:	96 e0       	ldi	r25, 0x06	; 6
    6f3e:	20 e1       	ldi	r18, 0x10	; 16
    6f40:	fc 01       	movw	r30, r24
    6f42:	25 83       	std	Z+5, r18	; 0x05
	}	
}
    6f44:	0f 90       	pop	r0
    6f46:	df 91       	pop	r29
    6f48:	cf 91       	pop	r28
    6f4a:	08 95       	ret

00006f4c <SPIDisable>:

void SPIDisable() {
    6f4c:	cf 93       	push	r28
    6f4e:	df 93       	push	r29
    6f50:	cd b7       	in	r28, 0x3d	; 61
    6f52:	de b7       	in	r29, 0x3e	; 62
	PORTC.OUTSET = PIN4_bm;
    6f54:	80 e4       	ldi	r24, 0x40	; 64
    6f56:	96 e0       	ldi	r25, 0x06	; 6
    6f58:	20 e1       	ldi	r18, 0x10	; 16
    6f5a:	fc 01       	movw	r30, r24
    6f5c:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = 0x00;
    6f5e:	80 ec       	ldi	r24, 0xC0	; 192
    6f60:	98 e0       	ldi	r25, 0x08	; 8
    6f62:	fc 01       	movw	r30, r24
    6f64:	10 82       	st	Z, r1
	PORTC.OUTCLR = PIN4_bm;
    6f66:	80 e4       	ldi	r24, 0x40	; 64
    6f68:	96 e0       	ldi	r25, 0x06	; 6
    6f6a:	20 e1       	ldi	r18, 0x10	; 16
    6f6c:	fc 01       	movw	r30, r24
    6f6e:	26 83       	std	Z+6, r18	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    6f70:	80 e4       	ldi	r24, 0x40	; 64
    6f72:	96 e0       	ldi	r25, 0x06	; 6
    6f74:	20 eb       	ldi	r18, 0xB0	; 176
    6f76:	fc 01       	movw	r30, r24
    6f78:	22 83       	std	Z+2, r18	; 0x02

}
    6f7a:	df 91       	pop	r29
    6f7c:	cf 91       	pop	r28
    6f7e:	08 95       	ret

00006f80 <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    6f80:	cf 93       	push	r28
    6f82:	df 93       	push	r29
    6f84:	00 d0       	rcall	.+0      	; 0x6f86 <readFRAM+0x6>
    6f86:	0f 92       	push	r0
    6f88:	cd b7       	in	r28, 0x3d	; 61
    6f8a:	de b7       	in	r29, 0x3e	; 62
    6f8c:	8b 83       	std	Y+3, r24	; 0x03
    6f8e:	9c 83       	std	Y+4, r25	; 0x04
	SPIInit(SPI_MODE_0_gc);
    6f90:	80 e0       	ldi	r24, 0x00	; 0
    6f92:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    6f96:	80 ec       	ldi	r24, 0xC0	; 192
    6f98:	98 e0       	ldi	r25, 0x08	; 8
    6f9a:	20 ed       	ldi	r18, 0xD0	; 208
    6f9c:	fc 01       	movw	r30, r24
    6f9e:	20 83       	st	Z, r18
	SPICS(TRUE);
    6fa0:	81 e0       	ldi	r24, 0x01	; 1
    6fa2:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    6fa6:	80 e2       	ldi	r24, 0x20	; 32
    6fa8:	96 e0       	ldi	r25, 0x06	; 6
    6faa:	28 e0       	ldi	r18, 0x08	; 8
    6fac:	fc 01       	movw	r30, r24
    6fae:	26 83       	std	Z+6, r18	; 0x06
	nop();
    6fb0:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    6fb2:	80 ec       	ldi	r24, 0xC0	; 192
    6fb4:	98 e0       	ldi	r25, 0x08	; 8
    6fb6:	23 e0       	ldi	r18, 0x03	; 3
    6fb8:	fc 01       	movw	r30, r24
    6fba:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    6fbc:	00 00       	nop
    6fbe:	80 ec       	ldi	r24, 0xC0	; 192
    6fc0:	98 e0       	ldi	r25, 0x08	; 8
    6fc2:	fc 01       	movw	r30, r24
    6fc4:	82 81       	ldd	r24, Z+2	; 0x02
    6fc6:	88 23       	and	r24, r24
    6fc8:	d4 f7       	brge	.-12     	; 0x6fbe <readFRAM+0x3e>
	SPIBuffer[12] = SPIC.DATA;
    6fca:	80 ec       	ldi	r24, 0xC0	; 192
    6fcc:	98 e0       	ldi	r25, 0x08	; 8
    6fce:	fc 01       	movw	r30, r24
    6fd0:	83 81       	ldd	r24, Z+3	; 0x03
    6fd2:	80 93 62 50 	sts	0x5062, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    6fd6:	80 ec       	ldi	r24, 0xC0	; 192
    6fd8:	98 e0       	ldi	r25, 0x08	; 8
    6fda:	20 91 49 40 	lds	r18, 0x4049
    6fde:	fc 01       	movw	r30, r24
    6fe0:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    6fe2:	00 00       	nop
    6fe4:	80 ec       	ldi	r24, 0xC0	; 192
    6fe6:	98 e0       	ldi	r25, 0x08	; 8
    6fe8:	fc 01       	movw	r30, r24
    6fea:	82 81       	ldd	r24, Z+2	; 0x02
    6fec:	88 23       	and	r24, r24
    6fee:	d4 f7       	brge	.-12     	; 0x6fe4 <readFRAM+0x64>
	SPIBuffer[12] = SPIC.DATA;
    6ff0:	80 ec       	ldi	r24, 0xC0	; 192
    6ff2:	98 e0       	ldi	r25, 0x08	; 8
    6ff4:	fc 01       	movw	r30, r24
    6ff6:	83 81       	ldd	r24, Z+3	; 0x03
    6ff8:	80 93 62 50 	sts	0x5062, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    6ffc:	80 ec       	ldi	r24, 0xC0	; 192
    6ffe:	98 e0       	ldi	r25, 0x08	; 8
    7000:	28 e4       	ldi	r18, 0x48	; 72
    7002:	30 e4       	ldi	r19, 0x40	; 64
    7004:	f9 01       	movw	r30, r18
    7006:	20 81       	ld	r18, Z
    7008:	fc 01       	movw	r30, r24
    700a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    700c:	00 00       	nop
    700e:	80 ec       	ldi	r24, 0xC0	; 192
    7010:	98 e0       	ldi	r25, 0x08	; 8
    7012:	fc 01       	movw	r30, r24
    7014:	82 81       	ldd	r24, Z+2	; 0x02
    7016:	88 23       	and	r24, r24
    7018:	d4 f7       	brge	.-12     	; 0x700e <readFRAM+0x8e>
	SPIBuffer[12] = SPIC.DATA;
    701a:	80 ec       	ldi	r24, 0xC0	; 192
    701c:	98 e0       	ldi	r25, 0x08	; 8
    701e:	fc 01       	movw	r30, r24
    7020:	83 81       	ldd	r24, Z+3	; 0x03
    7022:	80 93 62 50 	sts	0x5062, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    7026:	19 82       	std	Y+1, r1	; 0x01
    7028:	1a 82       	std	Y+2, r1	; 0x02
    702a:	1b c0       	rjmp	.+54     	; 0x7062 <readFRAM+0xe2>
		SPIC.DATA = 0xAA;
    702c:	80 ec       	ldi	r24, 0xC0	; 192
    702e:	98 e0       	ldi	r25, 0x08	; 8
    7030:	2a ea       	ldi	r18, 0xAA	; 170
    7032:	fc 01       	movw	r30, r24
    7034:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    7036:	00 00       	nop
    7038:	80 ec       	ldi	r24, 0xC0	; 192
    703a:	98 e0       	ldi	r25, 0x08	; 8
    703c:	fc 01       	movw	r30, r24
    703e:	82 81       	ldd	r24, Z+2	; 0x02
    7040:	88 23       	and	r24, r24
    7042:	d4 f7       	brge	.-12     	; 0x7038 <readFRAM+0xb8>
		FRAMReadBuffer[i] = SPIC.DATA;
    7044:	80 ec       	ldi	r24, 0xC0	; 192
    7046:	98 e0       	ldi	r25, 0x08	; 8
    7048:	fc 01       	movw	r30, r24
    704a:	23 81       	ldd	r18, Z+3	; 0x03
    704c:	89 81       	ldd	r24, Y+1	; 0x01
    704e:	9a 81       	ldd	r25, Y+2	; 0x02
    7050:	80 53       	subi	r24, 0x30	; 48
    7052:	9c 4d       	sbci	r25, 0xDC	; 220
    7054:	fc 01       	movw	r30, r24
    7056:	20 83       	st	Z, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    7058:	89 81       	ldd	r24, Y+1	; 0x01
    705a:	9a 81       	ldd	r25, Y+2	; 0x02
    705c:	01 96       	adiw	r24, 0x01	; 1
    705e:	89 83       	std	Y+1, r24	; 0x01
    7060:	9a 83       	std	Y+2, r25	; 0x02
    7062:	29 81       	ldd	r18, Y+1	; 0x01
    7064:	3a 81       	ldd	r19, Y+2	; 0x02
    7066:	8b 81       	ldd	r24, Y+3	; 0x03
    7068:	9c 81       	ldd	r25, Y+4	; 0x04
    706a:	28 17       	cp	r18, r24
    706c:	39 07       	cpc	r19, r25
    706e:	f0 f2       	brcs	.-68     	; 0x702c <readFRAM+0xac>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    7070:	80 e2       	ldi	r24, 0x20	; 32
    7072:	96 e0       	ldi	r25, 0x06	; 6
    7074:	28 e0       	ldi	r18, 0x08	; 8
    7076:	fc 01       	movw	r30, r24
    7078:	25 83       	std	Z+5, r18	; 0x05
	SPICS(FALSE);
    707a:	80 e0       	ldi	r24, 0x00	; 0
    707c:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	SPIDisable();
    7080:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>

}
    7084:	24 96       	adiw	r28, 0x04	; 4
    7086:	cd bf       	out	0x3d, r28	; 61
    7088:	de bf       	out	0x3e, r29	; 62
    708a:	df 91       	pop	r29
    708c:	cf 91       	pop	r28
    708e:	08 95       	ret

00007090 <FRAMTest3Channel>:

//test 3 channel sampling of accelerometer. OBSOLETE
void FRAMTest3Channel(void) {
    7090:	0f 93       	push	r16
    7092:	1f 93       	push	r17
    7094:	cf 93       	push	r28
    7096:	df 93       	push	r29
    7098:	cd b7       	in	r28, 0x3d	; 61
    709a:	de b7       	in	r29, 0x3e	; 62
    709c:	68 97       	sbiw	r28, 0x18	; 24
    709e:	cd bf       	out	0x3d, r28	; 61
    70a0:	de bf       	out	0x3e, r29	; 62
	//uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
			
	//CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |	FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,	gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    70a2:	81 e0       	ldi	r24, 0x01	; 1
    70a4:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>
    70a8:	80 e0       	ldi	r24, 0x00	; 0
    70aa:	90 e0       	ldi	r25, 0x00	; 0
    70ac:	aa e7       	ldi	r26, 0x7A	; 122
    70ae:	b3 e4       	ldi	r27, 0x43	; 67
    70b0:	89 83       	std	Y+1, r24	; 0x01
    70b2:	9a 83       	std	Y+2, r25	; 0x02
    70b4:	ab 83       	std	Y+3, r26	; 0x03
    70b6:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    70b8:	69 81       	ldd	r22, Y+1	; 0x01
    70ba:	7a 81       	ldd	r23, Y+2	; 0x02
    70bc:	8b 81       	ldd	r24, Y+3	; 0x03
    70be:	9c 81       	ldd	r25, Y+4	; 0x04
    70c0:	2b ea       	ldi	r18, 0xAB	; 171
    70c2:	3a ea       	ldi	r19, 0xAA	; 170
    70c4:	4a e2       	ldi	r20, 0x2A	; 42
    70c6:	51 e4       	ldi	r21, 0x41	; 65
    70c8:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    70cc:	dc 01       	movw	r26, r24
    70ce:	cb 01       	movw	r24, r22
    70d0:	8d 83       	std	Y+5, r24	; 0x05
    70d2:	9e 83       	std	Y+6, r25	; 0x06
    70d4:	af 83       	std	Y+7, r26	; 0x07
    70d6:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    70d8:	11 e0       	ldi	r17, 0x01	; 1
    70da:	6d 81       	ldd	r22, Y+5	; 0x05
    70dc:	7e 81       	ldd	r23, Y+6	; 0x06
    70de:	8f 81       	ldd	r24, Y+7	; 0x07
    70e0:	98 85       	ldd	r25, Y+8	; 0x08
    70e2:	20 e0       	ldi	r18, 0x00	; 0
    70e4:	30 e0       	ldi	r19, 0x00	; 0
    70e6:	40 e8       	ldi	r20, 0x80	; 128
    70e8:	5f e3       	ldi	r21, 0x3F	; 63
    70ea:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    70ee:	88 23       	and	r24, r24
    70f0:	0c f0       	brlt	.+2      	; 0x70f4 <FRAMTest3Channel+0x64>
    70f2:	10 e0       	ldi	r17, 0x00	; 0
    70f4:	11 23       	and	r17, r17
    70f6:	19 f0       	breq	.+6      	; 0x70fe <FRAMTest3Channel+0x6e>
		__ticks = 1;
    70f8:	81 e0       	ldi	r24, 0x01	; 1
    70fa:	89 87       	std	Y+9, r24	; 0x09
    70fc:	a3 c0       	rjmp	.+326    	; 0x7244 <FRAMTest3Channel+0x1b4>
	else if (__tmp > 255)
    70fe:	11 e0       	ldi	r17, 0x01	; 1
    7100:	6d 81       	ldd	r22, Y+5	; 0x05
    7102:	7e 81       	ldd	r23, Y+6	; 0x06
    7104:	8f 81       	ldd	r24, Y+7	; 0x07
    7106:	98 85       	ldd	r25, Y+8	; 0x08
    7108:	20 e0       	ldi	r18, 0x00	; 0
    710a:	30 e0       	ldi	r19, 0x00	; 0
    710c:	4f e7       	ldi	r20, 0x7F	; 127
    710e:	53 e4       	ldi	r21, 0x43	; 67
    7110:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    7114:	18 16       	cp	r1, r24
    7116:	0c f0       	brlt	.+2      	; 0x711a <FRAMTest3Channel+0x8a>
    7118:	10 e0       	ldi	r17, 0x00	; 0
    711a:	11 23       	and	r17, r17
    711c:	09 f4       	brne	.+2      	; 0x7120 <FRAMTest3Channel+0x90>
    711e:	89 c0       	rjmp	.+274    	; 0x7232 <FRAMTest3Channel+0x1a2>
	{
		_delay_ms(__us / 1000.0);
    7120:	69 81       	ldd	r22, Y+1	; 0x01
    7122:	7a 81       	ldd	r23, Y+2	; 0x02
    7124:	8b 81       	ldd	r24, Y+3	; 0x03
    7126:	9c 81       	ldd	r25, Y+4	; 0x04
    7128:	20 e0       	ldi	r18, 0x00	; 0
    712a:	30 e0       	ldi	r19, 0x00	; 0
    712c:	4a e7       	ldi	r20, 0x7A	; 122
    712e:	54 e4       	ldi	r21, 0x44	; 68
    7130:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
    7134:	dc 01       	movw	r26, r24
    7136:	cb 01       	movw	r24, r22
    7138:	8a 87       	std	Y+10, r24	; 0x0a
    713a:	9b 87       	std	Y+11, r25	; 0x0b
    713c:	ac 87       	std	Y+12, r26	; 0x0c
    713e:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7140:	6a 85       	ldd	r22, Y+10	; 0x0a
    7142:	7b 85       	ldd	r23, Y+11	; 0x0b
    7144:	8c 85       	ldd	r24, Y+12	; 0x0c
    7146:	9d 85       	ldd	r25, Y+13	; 0x0d
    7148:	20 e0       	ldi	r18, 0x00	; 0
    714a:	30 e0       	ldi	r19, 0x00	; 0
    714c:	4a ef       	ldi	r20, 0xFA	; 250
    714e:	55 e4       	ldi	r21, 0x45	; 69
    7150:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    7154:	dc 01       	movw	r26, r24
    7156:	cb 01       	movw	r24, r22
    7158:	8e 87       	std	Y+14, r24	; 0x0e
    715a:	9f 87       	std	Y+15, r25	; 0x0f
    715c:	a8 8b       	std	Y+16, r26	; 0x10
    715e:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    7160:	11 e0       	ldi	r17, 0x01	; 1
    7162:	6e 85       	ldd	r22, Y+14	; 0x0e
    7164:	7f 85       	ldd	r23, Y+15	; 0x0f
    7166:	88 89       	ldd	r24, Y+16	; 0x10
    7168:	99 89       	ldd	r25, Y+17	; 0x11
    716a:	20 e0       	ldi	r18, 0x00	; 0
    716c:	30 e0       	ldi	r19, 0x00	; 0
    716e:	40 e8       	ldi	r20, 0x80	; 128
    7170:	5f e3       	ldi	r21, 0x3F	; 63
    7172:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    7176:	88 23       	and	r24, r24
    7178:	0c f0       	brlt	.+2      	; 0x717c <FRAMTest3Channel+0xec>
    717a:	10 e0       	ldi	r17, 0x00	; 0
    717c:	11 23       	and	r17, r17
    717e:	29 f0       	breq	.+10     	; 0x718a <FRAMTest3Channel+0xfa>
		__ticks = 1;
    7180:	81 e0       	ldi	r24, 0x01	; 1
    7182:	90 e0       	ldi	r25, 0x00	; 0
    7184:	8a 8b       	std	Y+18, r24	; 0x12
    7186:	9b 8b       	std	Y+19, r25	; 0x13
    7188:	46 c0       	rjmp	.+140    	; 0x7216 <FRAMTest3Channel+0x186>
	else if (__tmp > 65535)
    718a:	11 e0       	ldi	r17, 0x01	; 1
    718c:	6e 85       	ldd	r22, Y+14	; 0x0e
    718e:	7f 85       	ldd	r23, Y+15	; 0x0f
    7190:	88 89       	ldd	r24, Y+16	; 0x10
    7192:	99 89       	ldd	r25, Y+17	; 0x11
    7194:	20 e0       	ldi	r18, 0x00	; 0
    7196:	3f ef       	ldi	r19, 0xFF	; 255
    7198:	4f e7       	ldi	r20, 0x7F	; 127
    719a:	57 e4       	ldi	r21, 0x47	; 71
    719c:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    71a0:	18 16       	cp	r1, r24
    71a2:	0c f0       	brlt	.+2      	; 0x71a6 <FRAMTest3Channel+0x116>
    71a4:	10 e0       	ldi	r17, 0x00	; 0
    71a6:	11 23       	and	r17, r17
    71a8:	61 f1       	breq	.+88     	; 0x7202 <FRAMTest3Channel+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    71aa:	6a 85       	ldd	r22, Y+10	; 0x0a
    71ac:	7b 85       	ldd	r23, Y+11	; 0x0b
    71ae:	8c 85       	ldd	r24, Y+12	; 0x0c
    71b0:	9d 85       	ldd	r25, Y+13	; 0x0d
    71b2:	20 e0       	ldi	r18, 0x00	; 0
    71b4:	30 e0       	ldi	r19, 0x00	; 0
    71b6:	40 e2       	ldi	r20, 0x20	; 32
    71b8:	51 e4       	ldi	r21, 0x41	; 65
    71ba:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    71be:	dc 01       	movw	r26, r24
    71c0:	cb 01       	movw	r24, r22
    71c2:	bc 01       	movw	r22, r24
    71c4:	cd 01       	movw	r24, r26
    71c6:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    71ca:	dc 01       	movw	r26, r24
    71cc:	cb 01       	movw	r24, r22
    71ce:	8a 8b       	std	Y+18, r24	; 0x12
    71d0:	9b 8b       	std	Y+19, r25	; 0x13
    71d2:	12 c0       	rjmp	.+36     	; 0x71f8 <FRAMTest3Channel+0x168>
    71d4:	80 e2       	ldi	r24, 0x20	; 32
    71d6:	93 e0       	ldi	r25, 0x03	; 3
    71d8:	8c 8b       	std	Y+20, r24	; 0x14
    71da:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    71dc:	8c 89       	ldd	r24, Y+20	; 0x14
    71de:	9d 89       	ldd	r25, Y+21	; 0x15
    71e0:	8c 01       	movw	r16, r24
    71e2:	c8 01       	movw	r24, r16
    71e4:	01 97       	sbiw	r24, 0x01	; 1
    71e6:	f1 f7       	brne	.-4      	; 0x71e4 <FRAMTest3Channel+0x154>
    71e8:	8c 01       	movw	r16, r24
    71ea:	0c 8b       	std	Y+20, r16	; 0x14
    71ec:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    71ee:	8a 89       	ldd	r24, Y+18	; 0x12
    71f0:	9b 89       	ldd	r25, Y+19	; 0x13
    71f2:	01 97       	sbiw	r24, 0x01	; 1
    71f4:	8a 8b       	std	Y+18, r24	; 0x12
    71f6:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    71f8:	8a 89       	ldd	r24, Y+18	; 0x12
    71fa:	9b 89       	ldd	r25, Y+19	; 0x13
    71fc:	00 97       	sbiw	r24, 0x00	; 0
    71fe:	51 f7       	brne	.-44     	; 0x71d4 <FRAMTest3Channel+0x144>
    7200:	28 c0       	rjmp	.+80     	; 0x7252 <FRAMTest3Channel+0x1c2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7202:	6e 85       	ldd	r22, Y+14	; 0x0e
    7204:	7f 85       	ldd	r23, Y+15	; 0x0f
    7206:	88 89       	ldd	r24, Y+16	; 0x10
    7208:	99 89       	ldd	r25, Y+17	; 0x11
    720a:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    720e:	dc 01       	movw	r26, r24
    7210:	cb 01       	movw	r24, r22
    7212:	8a 8b       	std	Y+18, r24	; 0x12
    7214:	9b 8b       	std	Y+19, r25	; 0x13
    7216:	8a 89       	ldd	r24, Y+18	; 0x12
    7218:	9b 89       	ldd	r25, Y+19	; 0x13
    721a:	8e 8b       	std	Y+22, r24	; 0x16
    721c:	9f 8b       	std	Y+23, r25	; 0x17
    721e:	8e 89       	ldd	r24, Y+22	; 0x16
    7220:	9f 89       	ldd	r25, Y+23	; 0x17
    7222:	8c 01       	movw	r16, r24
    7224:	c8 01       	movw	r24, r16
    7226:	01 97       	sbiw	r24, 0x01	; 1
    7228:	f1 f7       	brne	.-4      	; 0x7226 <FRAMTest3Channel+0x196>
    722a:	8c 01       	movw	r16, r24
    722c:	0e 8b       	std	Y+22, r16	; 0x16
    722e:	1f 8b       	std	Y+23, r17	; 0x17
    7230:	10 c0       	rjmp	.+32     	; 0x7252 <FRAMTest3Channel+0x1c2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    7232:	6d 81       	ldd	r22, Y+5	; 0x05
    7234:	7e 81       	ldd	r23, Y+6	; 0x06
    7236:	8f 81       	ldd	r24, Y+7	; 0x07
    7238:	98 85       	ldd	r25, Y+8	; 0x08
    723a:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    723e:	dc 01       	movw	r26, r24
    7240:	cb 01       	movw	r24, r22
    7242:	89 87       	std	Y+9, r24	; 0x09
    7244:	89 85       	ldd	r24, Y+9	; 0x09
    7246:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7248:	88 8d       	ldd	r24, Y+24	; 0x18
    724a:	18 2f       	mov	r17, r24
    724c:	1a 95       	dec	r17
    724e:	f1 f7       	brne	.-4      	; 0x724c <FRAMTest3Channel+0x1bc>
    7250:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    7252:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <calcChecksumFRAM>

	ADCPower(FALSE);
    7256:	80 e0       	ldi	r24, 0x00	; 0
    7258:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>
	
}
    725c:	68 96       	adiw	r28, 0x18	; 24
    725e:	cd bf       	out	0x3d, r28	; 61
    7260:	de bf       	out	0x3e, r29	; 62
    7262:	df 91       	pop	r29
    7264:	cf 91       	pop	r28
    7266:	1f 91       	pop	r17
    7268:	0f 91       	pop	r16
    726a:	08 95       	ret

0000726c <FRAMTest1Channel>:
//test 1 channel sampling of accelerometer. OBSOLETE
void FRAMTest1Channel(void) {
    726c:	0f 93       	push	r16
    726e:	1f 93       	push	r17
    7270:	cf 93       	push	r28
    7272:	df 93       	push	r29
    7274:	cd b7       	in	r28, 0x3d	; 61
    7276:	de b7       	in	r29, 0x3e	; 62
    7278:	68 97       	sbiw	r28, 0x18	; 24
    727a:	cd bf       	out	0x3d, r28	; 61
    727c:	de bf       	out	0x3e, r29	; 62

	//CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc, GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    727e:	81 e0       	ldi	r24, 0x01	; 1
    7280:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>
    7284:	80 e0       	ldi	r24, 0x00	; 0
    7286:	90 e0       	ldi	r25, 0x00	; 0
    7288:	aa e7       	ldi	r26, 0x7A	; 122
    728a:	b3 e4       	ldi	r27, 0x43	; 67
    728c:	89 83       	std	Y+1, r24	; 0x01
    728e:	9a 83       	std	Y+2, r25	; 0x02
    7290:	ab 83       	std	Y+3, r26	; 0x03
    7292:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7294:	69 81       	ldd	r22, Y+1	; 0x01
    7296:	7a 81       	ldd	r23, Y+2	; 0x02
    7298:	8b 81       	ldd	r24, Y+3	; 0x03
    729a:	9c 81       	ldd	r25, Y+4	; 0x04
    729c:	2b ea       	ldi	r18, 0xAB	; 171
    729e:	3a ea       	ldi	r19, 0xAA	; 170
    72a0:	4a e2       	ldi	r20, 0x2A	; 42
    72a2:	51 e4       	ldi	r21, 0x41	; 65
    72a4:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    72a8:	dc 01       	movw	r26, r24
    72aa:	cb 01       	movw	r24, r22
    72ac:	8d 83       	std	Y+5, r24	; 0x05
    72ae:	9e 83       	std	Y+6, r25	; 0x06
    72b0:	af 83       	std	Y+7, r26	; 0x07
    72b2:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    72b4:	11 e0       	ldi	r17, 0x01	; 1
    72b6:	6d 81       	ldd	r22, Y+5	; 0x05
    72b8:	7e 81       	ldd	r23, Y+6	; 0x06
    72ba:	8f 81       	ldd	r24, Y+7	; 0x07
    72bc:	98 85       	ldd	r25, Y+8	; 0x08
    72be:	20 e0       	ldi	r18, 0x00	; 0
    72c0:	30 e0       	ldi	r19, 0x00	; 0
    72c2:	40 e8       	ldi	r20, 0x80	; 128
    72c4:	5f e3       	ldi	r21, 0x3F	; 63
    72c6:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    72ca:	88 23       	and	r24, r24
    72cc:	0c f0       	brlt	.+2      	; 0x72d0 <FRAMTest1Channel+0x64>
    72ce:	10 e0       	ldi	r17, 0x00	; 0
    72d0:	11 23       	and	r17, r17
    72d2:	19 f0       	breq	.+6      	; 0x72da <FRAMTest1Channel+0x6e>
		__ticks = 1;
    72d4:	81 e0       	ldi	r24, 0x01	; 1
    72d6:	89 87       	std	Y+9, r24	; 0x09
    72d8:	a3 c0       	rjmp	.+326    	; 0x7420 <FRAMTest1Channel+0x1b4>
	else if (__tmp > 255)
    72da:	11 e0       	ldi	r17, 0x01	; 1
    72dc:	6d 81       	ldd	r22, Y+5	; 0x05
    72de:	7e 81       	ldd	r23, Y+6	; 0x06
    72e0:	8f 81       	ldd	r24, Y+7	; 0x07
    72e2:	98 85       	ldd	r25, Y+8	; 0x08
    72e4:	20 e0       	ldi	r18, 0x00	; 0
    72e6:	30 e0       	ldi	r19, 0x00	; 0
    72e8:	4f e7       	ldi	r20, 0x7F	; 127
    72ea:	53 e4       	ldi	r21, 0x43	; 67
    72ec:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    72f0:	18 16       	cp	r1, r24
    72f2:	0c f0       	brlt	.+2      	; 0x72f6 <FRAMTest1Channel+0x8a>
    72f4:	10 e0       	ldi	r17, 0x00	; 0
    72f6:	11 23       	and	r17, r17
    72f8:	09 f4       	brne	.+2      	; 0x72fc <FRAMTest1Channel+0x90>
    72fa:	89 c0       	rjmp	.+274    	; 0x740e <FRAMTest1Channel+0x1a2>
	{
		_delay_ms(__us / 1000.0);
    72fc:	69 81       	ldd	r22, Y+1	; 0x01
    72fe:	7a 81       	ldd	r23, Y+2	; 0x02
    7300:	8b 81       	ldd	r24, Y+3	; 0x03
    7302:	9c 81       	ldd	r25, Y+4	; 0x04
    7304:	20 e0       	ldi	r18, 0x00	; 0
    7306:	30 e0       	ldi	r19, 0x00	; 0
    7308:	4a e7       	ldi	r20, 0x7A	; 122
    730a:	54 e4       	ldi	r21, 0x44	; 68
    730c:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
    7310:	dc 01       	movw	r26, r24
    7312:	cb 01       	movw	r24, r22
    7314:	8a 87       	std	Y+10, r24	; 0x0a
    7316:	9b 87       	std	Y+11, r25	; 0x0b
    7318:	ac 87       	std	Y+12, r26	; 0x0c
    731a:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    731c:	6a 85       	ldd	r22, Y+10	; 0x0a
    731e:	7b 85       	ldd	r23, Y+11	; 0x0b
    7320:	8c 85       	ldd	r24, Y+12	; 0x0c
    7322:	9d 85       	ldd	r25, Y+13	; 0x0d
    7324:	20 e0       	ldi	r18, 0x00	; 0
    7326:	30 e0       	ldi	r19, 0x00	; 0
    7328:	4a ef       	ldi	r20, 0xFA	; 250
    732a:	55 e4       	ldi	r21, 0x45	; 69
    732c:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    7330:	dc 01       	movw	r26, r24
    7332:	cb 01       	movw	r24, r22
    7334:	8e 87       	std	Y+14, r24	; 0x0e
    7336:	9f 87       	std	Y+15, r25	; 0x0f
    7338:	a8 8b       	std	Y+16, r26	; 0x10
    733a:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    733c:	11 e0       	ldi	r17, 0x01	; 1
    733e:	6e 85       	ldd	r22, Y+14	; 0x0e
    7340:	7f 85       	ldd	r23, Y+15	; 0x0f
    7342:	88 89       	ldd	r24, Y+16	; 0x10
    7344:	99 89       	ldd	r25, Y+17	; 0x11
    7346:	20 e0       	ldi	r18, 0x00	; 0
    7348:	30 e0       	ldi	r19, 0x00	; 0
    734a:	40 e8       	ldi	r20, 0x80	; 128
    734c:	5f e3       	ldi	r21, 0x3F	; 63
    734e:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    7352:	88 23       	and	r24, r24
    7354:	0c f0       	brlt	.+2      	; 0x7358 <FRAMTest1Channel+0xec>
    7356:	10 e0       	ldi	r17, 0x00	; 0
    7358:	11 23       	and	r17, r17
    735a:	29 f0       	breq	.+10     	; 0x7366 <FRAMTest1Channel+0xfa>
		__ticks = 1;
    735c:	81 e0       	ldi	r24, 0x01	; 1
    735e:	90 e0       	ldi	r25, 0x00	; 0
    7360:	8a 8b       	std	Y+18, r24	; 0x12
    7362:	9b 8b       	std	Y+19, r25	; 0x13
    7364:	46 c0       	rjmp	.+140    	; 0x73f2 <FRAMTest1Channel+0x186>
	else if (__tmp > 65535)
    7366:	11 e0       	ldi	r17, 0x01	; 1
    7368:	6e 85       	ldd	r22, Y+14	; 0x0e
    736a:	7f 85       	ldd	r23, Y+15	; 0x0f
    736c:	88 89       	ldd	r24, Y+16	; 0x10
    736e:	99 89       	ldd	r25, Y+17	; 0x11
    7370:	20 e0       	ldi	r18, 0x00	; 0
    7372:	3f ef       	ldi	r19, 0xFF	; 255
    7374:	4f e7       	ldi	r20, 0x7F	; 127
    7376:	57 e4       	ldi	r21, 0x47	; 71
    7378:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    737c:	18 16       	cp	r1, r24
    737e:	0c f0       	brlt	.+2      	; 0x7382 <FRAMTest1Channel+0x116>
    7380:	10 e0       	ldi	r17, 0x00	; 0
    7382:	11 23       	and	r17, r17
    7384:	61 f1       	breq	.+88     	; 0x73de <FRAMTest1Channel+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7386:	6a 85       	ldd	r22, Y+10	; 0x0a
    7388:	7b 85       	ldd	r23, Y+11	; 0x0b
    738a:	8c 85       	ldd	r24, Y+12	; 0x0c
    738c:	9d 85       	ldd	r25, Y+13	; 0x0d
    738e:	20 e0       	ldi	r18, 0x00	; 0
    7390:	30 e0       	ldi	r19, 0x00	; 0
    7392:	40 e2       	ldi	r20, 0x20	; 32
    7394:	51 e4       	ldi	r21, 0x41	; 65
    7396:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    739a:	dc 01       	movw	r26, r24
    739c:	cb 01       	movw	r24, r22
    739e:	bc 01       	movw	r22, r24
    73a0:	cd 01       	movw	r24, r26
    73a2:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    73a6:	dc 01       	movw	r26, r24
    73a8:	cb 01       	movw	r24, r22
    73aa:	8a 8b       	std	Y+18, r24	; 0x12
    73ac:	9b 8b       	std	Y+19, r25	; 0x13
    73ae:	12 c0       	rjmp	.+36     	; 0x73d4 <FRAMTest1Channel+0x168>
    73b0:	80 e2       	ldi	r24, 0x20	; 32
    73b2:	93 e0       	ldi	r25, 0x03	; 3
    73b4:	8c 8b       	std	Y+20, r24	; 0x14
    73b6:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    73b8:	8c 89       	ldd	r24, Y+20	; 0x14
    73ba:	9d 89       	ldd	r25, Y+21	; 0x15
    73bc:	8c 01       	movw	r16, r24
    73be:	c8 01       	movw	r24, r16
    73c0:	01 97       	sbiw	r24, 0x01	; 1
    73c2:	f1 f7       	brne	.-4      	; 0x73c0 <FRAMTest1Channel+0x154>
    73c4:	8c 01       	movw	r16, r24
    73c6:	0c 8b       	std	Y+20, r16	; 0x14
    73c8:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    73ca:	8a 89       	ldd	r24, Y+18	; 0x12
    73cc:	9b 89       	ldd	r25, Y+19	; 0x13
    73ce:	01 97       	sbiw	r24, 0x01	; 1
    73d0:	8a 8b       	std	Y+18, r24	; 0x12
    73d2:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    73d4:	8a 89       	ldd	r24, Y+18	; 0x12
    73d6:	9b 89       	ldd	r25, Y+19	; 0x13
    73d8:	00 97       	sbiw	r24, 0x00	; 0
    73da:	51 f7       	brne	.-44     	; 0x73b0 <FRAMTest1Channel+0x144>
    73dc:	28 c0       	rjmp	.+80     	; 0x742e <FRAMTest1Channel+0x1c2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    73de:	6e 85       	ldd	r22, Y+14	; 0x0e
    73e0:	7f 85       	ldd	r23, Y+15	; 0x0f
    73e2:	88 89       	ldd	r24, Y+16	; 0x10
    73e4:	99 89       	ldd	r25, Y+17	; 0x11
    73e6:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    73ea:	dc 01       	movw	r26, r24
    73ec:	cb 01       	movw	r24, r22
    73ee:	8a 8b       	std	Y+18, r24	; 0x12
    73f0:	9b 8b       	std	Y+19, r25	; 0x13
    73f2:	8a 89       	ldd	r24, Y+18	; 0x12
    73f4:	9b 89       	ldd	r25, Y+19	; 0x13
    73f6:	8e 8b       	std	Y+22, r24	; 0x16
    73f8:	9f 8b       	std	Y+23, r25	; 0x17
    73fa:	8e 89       	ldd	r24, Y+22	; 0x16
    73fc:	9f 89       	ldd	r25, Y+23	; 0x17
    73fe:	8c 01       	movw	r16, r24
    7400:	c8 01       	movw	r24, r16
    7402:	01 97       	sbiw	r24, 0x01	; 1
    7404:	f1 f7       	brne	.-4      	; 0x7402 <FRAMTest1Channel+0x196>
    7406:	8c 01       	movw	r16, r24
    7408:	0e 8b       	std	Y+22, r16	; 0x16
    740a:	1f 8b       	std	Y+23, r17	; 0x17
    740c:	10 c0       	rjmp	.+32     	; 0x742e <FRAMTest1Channel+0x1c2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    740e:	6d 81       	ldd	r22, Y+5	; 0x05
    7410:	7e 81       	ldd	r23, Y+6	; 0x06
    7412:	8f 81       	ldd	r24, Y+7	; 0x07
    7414:	98 85       	ldd	r25, Y+8	; 0x08
    7416:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    741a:	dc 01       	movw	r26, r24
    741c:	cb 01       	movw	r24, r22
    741e:	89 87       	std	Y+9, r24	; 0x09
    7420:	89 85       	ldd	r24, Y+9	; 0x09
    7422:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7424:	88 8d       	ldd	r24, Y+24	; 0x18
    7426:	18 2f       	mov	r17, r24
    7428:	1a 95       	dec	r17
    742a:	f1 f7       	brne	.-4      	; 0x7428 <FRAMTest1Channel+0x1bc>
    742c:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    742e:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <calcChecksumFRAM>

	ADCPower(FALSE);
    7432:	80 e0       	ldi	r24, 0x00	; 0
    7434:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>

}
    7438:	68 96       	adiw	r28, 0x18	; 24
    743a:	cd bf       	out	0x3d, r28	; 61
    743c:	de bf       	out	0x3e, r29	; 62
    743e:	df 91       	pop	r29
    7440:	cf 91       	pop	r28
    7442:	1f 91       	pop	r17
    7444:	0f 91       	pop	r16
    7446:	08 95       	ret

00007448 <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
    7448:	0f 93       	push	r16
    744a:	1f 93       	push	r17
    744c:	cf 93       	push	r28
    744e:	df 93       	push	r29
    7450:	cd b7       	in	r28, 0x3d	; 61
    7452:	de b7       	in	r29, 0x3e	; 62
    7454:	68 97       	sbiw	r28, 0x18	; 24
    7456:	cd bf       	out	0x3d, r28	; 61
    7458:	de bf       	out	0x3e, r29	; 62
	FRAMWriteKnowns();
    745a:	0e 94 bf 18 	call	0x317e	; 0x317e <FRAMWriteKnowns>
	ADCPower(TRUE);
    745e:	81 e0       	ldi	r24, 0x01	; 1
    7460:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>
    7464:	80 e0       	ldi	r24, 0x00	; 0
    7466:	90 e0       	ldi	r25, 0x00	; 0
    7468:	aa e7       	ldi	r26, 0x7A	; 122
    746a:	b3 e4       	ldi	r27, 0x43	; 67
    746c:	89 83       	std	Y+1, r24	; 0x01
    746e:	9a 83       	std	Y+2, r25	; 0x02
    7470:	ab 83       	std	Y+3, r26	; 0x03
    7472:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7474:	69 81       	ldd	r22, Y+1	; 0x01
    7476:	7a 81       	ldd	r23, Y+2	; 0x02
    7478:	8b 81       	ldd	r24, Y+3	; 0x03
    747a:	9c 81       	ldd	r25, Y+4	; 0x04
    747c:	2b ea       	ldi	r18, 0xAB	; 171
    747e:	3a ea       	ldi	r19, 0xAA	; 170
    7480:	4a e2       	ldi	r20, 0x2A	; 42
    7482:	51 e4       	ldi	r21, 0x41	; 65
    7484:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    7488:	dc 01       	movw	r26, r24
    748a:	cb 01       	movw	r24, r22
    748c:	8d 83       	std	Y+5, r24	; 0x05
    748e:	9e 83       	std	Y+6, r25	; 0x06
    7490:	af 83       	std	Y+7, r26	; 0x07
    7492:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7494:	11 e0       	ldi	r17, 0x01	; 1
    7496:	6d 81       	ldd	r22, Y+5	; 0x05
    7498:	7e 81       	ldd	r23, Y+6	; 0x06
    749a:	8f 81       	ldd	r24, Y+7	; 0x07
    749c:	98 85       	ldd	r25, Y+8	; 0x08
    749e:	20 e0       	ldi	r18, 0x00	; 0
    74a0:	30 e0       	ldi	r19, 0x00	; 0
    74a2:	40 e8       	ldi	r20, 0x80	; 128
    74a4:	5f e3       	ldi	r21, 0x3F	; 63
    74a6:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    74aa:	88 23       	and	r24, r24
    74ac:	0c f0       	brlt	.+2      	; 0x74b0 <FRAMWriteKnownsCheck+0x68>
    74ae:	10 e0       	ldi	r17, 0x00	; 0
    74b0:	11 23       	and	r17, r17
    74b2:	19 f0       	breq	.+6      	; 0x74ba <FRAMWriteKnownsCheck+0x72>
		__ticks = 1;
    74b4:	81 e0       	ldi	r24, 0x01	; 1
    74b6:	89 87       	std	Y+9, r24	; 0x09
    74b8:	a3 c0       	rjmp	.+326    	; 0x7600 <FRAMWriteKnownsCheck+0x1b8>
	else if (__tmp > 255)
    74ba:	11 e0       	ldi	r17, 0x01	; 1
    74bc:	6d 81       	ldd	r22, Y+5	; 0x05
    74be:	7e 81       	ldd	r23, Y+6	; 0x06
    74c0:	8f 81       	ldd	r24, Y+7	; 0x07
    74c2:	98 85       	ldd	r25, Y+8	; 0x08
    74c4:	20 e0       	ldi	r18, 0x00	; 0
    74c6:	30 e0       	ldi	r19, 0x00	; 0
    74c8:	4f e7       	ldi	r20, 0x7F	; 127
    74ca:	53 e4       	ldi	r21, 0x43	; 67
    74cc:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    74d0:	18 16       	cp	r1, r24
    74d2:	0c f0       	brlt	.+2      	; 0x74d6 <FRAMWriteKnownsCheck+0x8e>
    74d4:	10 e0       	ldi	r17, 0x00	; 0
    74d6:	11 23       	and	r17, r17
    74d8:	09 f4       	brne	.+2      	; 0x74dc <FRAMWriteKnownsCheck+0x94>
    74da:	89 c0       	rjmp	.+274    	; 0x75ee <FRAMWriteKnownsCheck+0x1a6>
	{
		_delay_ms(__us / 1000.0);
    74dc:	69 81       	ldd	r22, Y+1	; 0x01
    74de:	7a 81       	ldd	r23, Y+2	; 0x02
    74e0:	8b 81       	ldd	r24, Y+3	; 0x03
    74e2:	9c 81       	ldd	r25, Y+4	; 0x04
    74e4:	20 e0       	ldi	r18, 0x00	; 0
    74e6:	30 e0       	ldi	r19, 0x00	; 0
    74e8:	4a e7       	ldi	r20, 0x7A	; 122
    74ea:	54 e4       	ldi	r21, 0x44	; 68
    74ec:	0e 94 2e 5a 	call	0xb45c	; 0xb45c <__divsf3>
    74f0:	dc 01       	movw	r26, r24
    74f2:	cb 01       	movw	r24, r22
    74f4:	8a 87       	std	Y+10, r24	; 0x0a
    74f6:	9b 87       	std	Y+11, r25	; 0x0b
    74f8:	ac 87       	std	Y+12, r26	; 0x0c
    74fa:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    74fc:	6a 85       	ldd	r22, Y+10	; 0x0a
    74fe:	7b 85       	ldd	r23, Y+11	; 0x0b
    7500:	8c 85       	ldd	r24, Y+12	; 0x0c
    7502:	9d 85       	ldd	r25, Y+13	; 0x0d
    7504:	20 e0       	ldi	r18, 0x00	; 0
    7506:	30 e0       	ldi	r19, 0x00	; 0
    7508:	4a ef       	ldi	r20, 0xFA	; 250
    750a:	55 e4       	ldi	r21, 0x45	; 69
    750c:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    7510:	dc 01       	movw	r26, r24
    7512:	cb 01       	movw	r24, r22
    7514:	8e 87       	std	Y+14, r24	; 0x0e
    7516:	9f 87       	std	Y+15, r25	; 0x0f
    7518:	a8 8b       	std	Y+16, r26	; 0x10
    751a:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    751c:	11 e0       	ldi	r17, 0x01	; 1
    751e:	6e 85       	ldd	r22, Y+14	; 0x0e
    7520:	7f 85       	ldd	r23, Y+15	; 0x0f
    7522:	88 89       	ldd	r24, Y+16	; 0x10
    7524:	99 89       	ldd	r25, Y+17	; 0x11
    7526:	20 e0       	ldi	r18, 0x00	; 0
    7528:	30 e0       	ldi	r19, 0x00	; 0
    752a:	40 e8       	ldi	r20, 0x80	; 128
    752c:	5f e3       	ldi	r21, 0x3F	; 63
    752e:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    7532:	88 23       	and	r24, r24
    7534:	0c f0       	brlt	.+2      	; 0x7538 <FRAMWriteKnownsCheck+0xf0>
    7536:	10 e0       	ldi	r17, 0x00	; 0
    7538:	11 23       	and	r17, r17
    753a:	29 f0       	breq	.+10     	; 0x7546 <FRAMWriteKnownsCheck+0xfe>
		__ticks = 1;
    753c:	81 e0       	ldi	r24, 0x01	; 1
    753e:	90 e0       	ldi	r25, 0x00	; 0
    7540:	8a 8b       	std	Y+18, r24	; 0x12
    7542:	9b 8b       	std	Y+19, r25	; 0x13
    7544:	46 c0       	rjmp	.+140    	; 0x75d2 <FRAMWriteKnownsCheck+0x18a>
	else if (__tmp > 65535)
    7546:	11 e0       	ldi	r17, 0x01	; 1
    7548:	6e 85       	ldd	r22, Y+14	; 0x0e
    754a:	7f 85       	ldd	r23, Y+15	; 0x0f
    754c:	88 89       	ldd	r24, Y+16	; 0x10
    754e:	99 89       	ldd	r25, Y+17	; 0x11
    7550:	20 e0       	ldi	r18, 0x00	; 0
    7552:	3f ef       	ldi	r19, 0xFF	; 255
    7554:	4f e7       	ldi	r20, 0x7F	; 127
    7556:	57 e4       	ldi	r21, 0x47	; 71
    7558:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    755c:	18 16       	cp	r1, r24
    755e:	0c f0       	brlt	.+2      	; 0x7562 <FRAMWriteKnownsCheck+0x11a>
    7560:	10 e0       	ldi	r17, 0x00	; 0
    7562:	11 23       	and	r17, r17
    7564:	61 f1       	breq	.+88     	; 0x75be <FRAMWriteKnownsCheck+0x176>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7566:	6a 85       	ldd	r22, Y+10	; 0x0a
    7568:	7b 85       	ldd	r23, Y+11	; 0x0b
    756a:	8c 85       	ldd	r24, Y+12	; 0x0c
    756c:	9d 85       	ldd	r25, Y+13	; 0x0d
    756e:	20 e0       	ldi	r18, 0x00	; 0
    7570:	30 e0       	ldi	r19, 0x00	; 0
    7572:	40 e2       	ldi	r20, 0x20	; 32
    7574:	51 e4       	ldi	r21, 0x41	; 65
    7576:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    757a:	dc 01       	movw	r26, r24
    757c:	cb 01       	movw	r24, r22
    757e:	bc 01       	movw	r22, r24
    7580:	cd 01       	movw	r24, r26
    7582:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    7586:	dc 01       	movw	r26, r24
    7588:	cb 01       	movw	r24, r22
    758a:	8a 8b       	std	Y+18, r24	; 0x12
    758c:	9b 8b       	std	Y+19, r25	; 0x13
    758e:	12 c0       	rjmp	.+36     	; 0x75b4 <FRAMWriteKnownsCheck+0x16c>
    7590:	80 e2       	ldi	r24, 0x20	; 32
    7592:	93 e0       	ldi	r25, 0x03	; 3
    7594:	8c 8b       	std	Y+20, r24	; 0x14
    7596:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7598:	8c 89       	ldd	r24, Y+20	; 0x14
    759a:	9d 89       	ldd	r25, Y+21	; 0x15
    759c:	8c 01       	movw	r16, r24
    759e:	c8 01       	movw	r24, r16
    75a0:	01 97       	sbiw	r24, 0x01	; 1
    75a2:	f1 f7       	brne	.-4      	; 0x75a0 <FRAMWriteKnownsCheck+0x158>
    75a4:	8c 01       	movw	r16, r24
    75a6:	0c 8b       	std	Y+20, r16	; 0x14
    75a8:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    75aa:	8a 89       	ldd	r24, Y+18	; 0x12
    75ac:	9b 89       	ldd	r25, Y+19	; 0x13
    75ae:	01 97       	sbiw	r24, 0x01	; 1
    75b0:	8a 8b       	std	Y+18, r24	; 0x12
    75b2:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    75b4:	8a 89       	ldd	r24, Y+18	; 0x12
    75b6:	9b 89       	ldd	r25, Y+19	; 0x13
    75b8:	00 97       	sbiw	r24, 0x00	; 0
    75ba:	51 f7       	brne	.-44     	; 0x7590 <FRAMWriteKnownsCheck+0x148>
    75bc:	28 c0       	rjmp	.+80     	; 0x760e <FRAMWriteKnownsCheck+0x1c6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    75be:	6e 85       	ldd	r22, Y+14	; 0x0e
    75c0:	7f 85       	ldd	r23, Y+15	; 0x0f
    75c2:	88 89       	ldd	r24, Y+16	; 0x10
    75c4:	99 89       	ldd	r25, Y+17	; 0x11
    75c6:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    75ca:	dc 01       	movw	r26, r24
    75cc:	cb 01       	movw	r24, r22
    75ce:	8a 8b       	std	Y+18, r24	; 0x12
    75d0:	9b 8b       	std	Y+19, r25	; 0x13
    75d2:	8a 89       	ldd	r24, Y+18	; 0x12
    75d4:	9b 89       	ldd	r25, Y+19	; 0x13
    75d6:	8e 8b       	std	Y+22, r24	; 0x16
    75d8:	9f 8b       	std	Y+23, r25	; 0x17
    75da:	8e 89       	ldd	r24, Y+22	; 0x16
    75dc:	9f 89       	ldd	r25, Y+23	; 0x17
    75de:	8c 01       	movw	r16, r24
    75e0:	c8 01       	movw	r24, r16
    75e2:	01 97       	sbiw	r24, 0x01	; 1
    75e4:	f1 f7       	brne	.-4      	; 0x75e2 <FRAMWriteKnownsCheck+0x19a>
    75e6:	8c 01       	movw	r16, r24
    75e8:	0e 8b       	std	Y+22, r16	; 0x16
    75ea:	1f 8b       	std	Y+23, r17	; 0x17
    75ec:	10 c0       	rjmp	.+32     	; 0x760e <FRAMWriteKnownsCheck+0x1c6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    75ee:	6d 81       	ldd	r22, Y+5	; 0x05
    75f0:	7e 81       	ldd	r23, Y+6	; 0x06
    75f2:	8f 81       	ldd	r24, Y+7	; 0x07
    75f4:	98 85       	ldd	r25, Y+8	; 0x08
    75f6:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    75fa:	dc 01       	movw	r26, r24
    75fc:	cb 01       	movw	r24, r22
    75fe:	89 87       	std	Y+9, r24	; 0x09
    7600:	89 85       	ldd	r24, Y+9	; 0x09
    7602:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7604:	88 8d       	ldd	r24, Y+24	; 0x18
    7606:	18 2f       	mov	r17, r24
    7608:	1a 95       	dec	r17
    760a:	f1 f7       	brne	.-4      	; 0x7608 <FRAMWriteKnownsCheck+0x1c0>
    760c:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(250);
	calcChecksumFRAM();
    760e:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <calcChecksumFRAM>

	ADCPower(FALSE);
    7612:	80 e0       	ldi	r24, 0x00	; 0
    7614:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>

}
    7618:	68 96       	adiw	r28, 0x18	; 24
    761a:	cd bf       	out	0x3d, r28	; 61
    761c:	de bf       	out	0x3e, r29	; 62
    761e:	df 91       	pop	r29
    7620:	cf 91       	pop	r28
    7622:	1f 91       	pop	r17
    7624:	0f 91       	pop	r16
    7626:	08 95       	ret

00007628 <checkMote>:

//random function for testing stuff	
void checkMote(){
    7628:	0f 93       	push	r16
    762a:	1f 93       	push	r17
    762c:	cf 93       	push	r28
    762e:	df 93       	push	r29
    7630:	cd b7       	in	r28, 0x3d	; 61
    7632:	de b7       	in	r29, 0x3e	; 62
    7634:	aa 97       	sbiw	r28, 0x2a	; 42
    7636:	cd bf       	out	0x3d, r28	; 61
    7638:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);
    763a:	81 e0       	ldi	r24, 0x01	; 1
    763c:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>
	Ext1Power(TRUE);
    7640:	81 e0       	ldi	r24, 0x01	; 1
    7642:	0e 94 33 34 	call	0x6866	; 0x6866 <Ext1Power>
    7646:	80 e0       	ldi	r24, 0x00	; 0
    7648:	90 e0       	ldi	r25, 0x00	; 0
    764a:	a8 ec       	ldi	r26, 0xC8	; 200
    764c:	b2 e4       	ldi	r27, 0x42	; 66
    764e:	89 83       	std	Y+1, r24	; 0x01
    7650:	9a 83       	std	Y+2, r25	; 0x02
    7652:	ab 83       	std	Y+3, r26	; 0x03
    7654:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7656:	69 81       	ldd	r22, Y+1	; 0x01
    7658:	7a 81       	ldd	r23, Y+2	; 0x02
    765a:	8b 81       	ldd	r24, Y+3	; 0x03
    765c:	9c 81       	ldd	r25, Y+4	; 0x04
    765e:	20 e0       	ldi	r18, 0x00	; 0
    7660:	30 e0       	ldi	r19, 0x00	; 0
    7662:	4a ef       	ldi	r20, 0xFA	; 250
    7664:	55 e4       	ldi	r21, 0x45	; 69
    7666:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    766a:	dc 01       	movw	r26, r24
    766c:	cb 01       	movw	r24, r22
    766e:	8d 83       	std	Y+5, r24	; 0x05
    7670:	9e 83       	std	Y+6, r25	; 0x06
    7672:	af 83       	std	Y+7, r26	; 0x07
    7674:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7676:	11 e0       	ldi	r17, 0x01	; 1
    7678:	6d 81       	ldd	r22, Y+5	; 0x05
    767a:	7e 81       	ldd	r23, Y+6	; 0x06
    767c:	8f 81       	ldd	r24, Y+7	; 0x07
    767e:	98 85       	ldd	r25, Y+8	; 0x08
    7680:	20 e0       	ldi	r18, 0x00	; 0
    7682:	30 e0       	ldi	r19, 0x00	; 0
    7684:	40 e8       	ldi	r20, 0x80	; 128
    7686:	5f e3       	ldi	r21, 0x3F	; 63
    7688:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    768c:	88 23       	and	r24, r24
    768e:	0c f0       	brlt	.+2      	; 0x7692 <checkMote+0x6a>
    7690:	10 e0       	ldi	r17, 0x00	; 0
    7692:	11 23       	and	r17, r17
    7694:	29 f0       	breq	.+10     	; 0x76a0 <checkMote+0x78>
		__ticks = 1;
    7696:	81 e0       	ldi	r24, 0x01	; 1
    7698:	90 e0       	ldi	r25, 0x00	; 0
    769a:	89 87       	std	Y+9, r24	; 0x09
    769c:	9a 87       	std	Y+10, r25	; 0x0a
    769e:	46 c0       	rjmp	.+140    	; 0x772c <checkMote+0x104>
	else if (__tmp > 65535)
    76a0:	11 e0       	ldi	r17, 0x01	; 1
    76a2:	6d 81       	ldd	r22, Y+5	; 0x05
    76a4:	7e 81       	ldd	r23, Y+6	; 0x06
    76a6:	8f 81       	ldd	r24, Y+7	; 0x07
    76a8:	98 85       	ldd	r25, Y+8	; 0x08
    76aa:	20 e0       	ldi	r18, 0x00	; 0
    76ac:	3f ef       	ldi	r19, 0xFF	; 255
    76ae:	4f e7       	ldi	r20, 0x7F	; 127
    76b0:	57 e4       	ldi	r21, 0x47	; 71
    76b2:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    76b6:	18 16       	cp	r1, r24
    76b8:	0c f0       	brlt	.+2      	; 0x76bc <checkMote+0x94>
    76ba:	10 e0       	ldi	r17, 0x00	; 0
    76bc:	11 23       	and	r17, r17
    76be:	61 f1       	breq	.+88     	; 0x7718 <checkMote+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    76c0:	69 81       	ldd	r22, Y+1	; 0x01
    76c2:	7a 81       	ldd	r23, Y+2	; 0x02
    76c4:	8b 81       	ldd	r24, Y+3	; 0x03
    76c6:	9c 81       	ldd	r25, Y+4	; 0x04
    76c8:	20 e0       	ldi	r18, 0x00	; 0
    76ca:	30 e0       	ldi	r19, 0x00	; 0
    76cc:	40 e2       	ldi	r20, 0x20	; 32
    76ce:	51 e4       	ldi	r21, 0x41	; 65
    76d0:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    76d4:	dc 01       	movw	r26, r24
    76d6:	cb 01       	movw	r24, r22
    76d8:	bc 01       	movw	r22, r24
    76da:	cd 01       	movw	r24, r26
    76dc:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    76e0:	dc 01       	movw	r26, r24
    76e2:	cb 01       	movw	r24, r22
    76e4:	89 87       	std	Y+9, r24	; 0x09
    76e6:	9a 87       	std	Y+10, r25	; 0x0a
    76e8:	12 c0       	rjmp	.+36     	; 0x770e <checkMote+0xe6>
    76ea:	80 e2       	ldi	r24, 0x20	; 32
    76ec:	93 e0       	ldi	r25, 0x03	; 3
    76ee:	8b 87       	std	Y+11, r24	; 0x0b
    76f0:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    76f2:	8b 85       	ldd	r24, Y+11	; 0x0b
    76f4:	9c 85       	ldd	r25, Y+12	; 0x0c
    76f6:	8c 01       	movw	r16, r24
    76f8:	c8 01       	movw	r24, r16
    76fa:	01 97       	sbiw	r24, 0x01	; 1
    76fc:	f1 f7       	brne	.-4      	; 0x76fa <checkMote+0xd2>
    76fe:	8c 01       	movw	r16, r24
    7700:	0b 87       	std	Y+11, r16	; 0x0b
    7702:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7704:	89 85       	ldd	r24, Y+9	; 0x09
    7706:	9a 85       	ldd	r25, Y+10	; 0x0a
    7708:	01 97       	sbiw	r24, 0x01	; 1
    770a:	89 87       	std	Y+9, r24	; 0x09
    770c:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    770e:	89 85       	ldd	r24, Y+9	; 0x09
    7710:	9a 85       	ldd	r25, Y+10	; 0x0a
    7712:	00 97       	sbiw	r24, 0x00	; 0
    7714:	51 f7       	brne	.-44     	; 0x76ea <checkMote+0xc2>
    7716:	17 c0       	rjmp	.+46     	; 0x7746 <checkMote+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7718:	6d 81       	ldd	r22, Y+5	; 0x05
    771a:	7e 81       	ldd	r23, Y+6	; 0x06
    771c:	8f 81       	ldd	r24, Y+7	; 0x07
    771e:	98 85       	ldd	r25, Y+8	; 0x08
    7720:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    7724:	dc 01       	movw	r26, r24
    7726:	cb 01       	movw	r24, r22
    7728:	89 87       	std	Y+9, r24	; 0x09
    772a:	9a 87       	std	Y+10, r25	; 0x0a
    772c:	89 85       	ldd	r24, Y+9	; 0x09
    772e:	9a 85       	ldd	r25, Y+10	; 0x0a
    7730:	8d 87       	std	Y+13, r24	; 0x0d
    7732:	9e 87       	std	Y+14, r25	; 0x0e
    7734:	8d 85       	ldd	r24, Y+13	; 0x0d
    7736:	9e 85       	ldd	r25, Y+14	; 0x0e
    7738:	8c 01       	movw	r16, r24
    773a:	c8 01       	movw	r24, r16
    773c:	01 97       	sbiw	r24, 0x01	; 1
    773e:	f1 f7       	brne	.-4      	; 0x773c <checkMote+0x114>
    7740:	8c 01       	movw	r16, r24
    7742:	0d 87       	std	Y+13, r16	; 0x0d
    7744:	1e 87       	std	Y+14, r17	; 0x0e
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    7746:	88 e0       	ldi	r24, 0x08	; 8
    7748:	60 e0       	ldi	r22, 0x00	; 0
    774a:	0e 94 9d 32 	call	0x653a	; 0x653a <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    774e:	88 e0       	ldi	r24, 0x08	; 8
    7750:	60 e0       	ldi	r22, 0x00	; 0
    7752:	0e 94 69 33 	call	0x66d2	; 0x66d2 <PortEx_OUTSET>
    7756:	80 e0       	ldi	r24, 0x00	; 0
    7758:	90 e4       	ldi	r25, 0x40	; 64
    775a:	ac e9       	ldi	r26, 0x9C	; 156
    775c:	b5 e4       	ldi	r27, 0x45	; 69
    775e:	8f 87       	std	Y+15, r24	; 0x0f
    7760:	98 8b       	std	Y+16, r25	; 0x10
    7762:	a9 8b       	std	Y+17, r26	; 0x11
    7764:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7766:	6f 85       	ldd	r22, Y+15	; 0x0f
    7768:	78 89       	ldd	r23, Y+16	; 0x10
    776a:	89 89       	ldd	r24, Y+17	; 0x11
    776c:	9a 89       	ldd	r25, Y+18	; 0x12
    776e:	20 e0       	ldi	r18, 0x00	; 0
    7770:	30 e0       	ldi	r19, 0x00	; 0
    7772:	4a ef       	ldi	r20, 0xFA	; 250
    7774:	55 e4       	ldi	r21, 0x45	; 69
    7776:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    777a:	dc 01       	movw	r26, r24
    777c:	cb 01       	movw	r24, r22
    777e:	8b 8b       	std	Y+19, r24	; 0x13
    7780:	9c 8b       	std	Y+20, r25	; 0x14
    7782:	ad 8b       	std	Y+21, r26	; 0x15
    7784:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    7786:	11 e0       	ldi	r17, 0x01	; 1
    7788:	6b 89       	ldd	r22, Y+19	; 0x13
    778a:	7c 89       	ldd	r23, Y+20	; 0x14
    778c:	8d 89       	ldd	r24, Y+21	; 0x15
    778e:	9e 89       	ldd	r25, Y+22	; 0x16
    7790:	20 e0       	ldi	r18, 0x00	; 0
    7792:	30 e0       	ldi	r19, 0x00	; 0
    7794:	40 e8       	ldi	r20, 0x80	; 128
    7796:	5f e3       	ldi	r21, 0x3F	; 63
    7798:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    779c:	88 23       	and	r24, r24
    779e:	0c f0       	brlt	.+2      	; 0x77a2 <checkMote+0x17a>
    77a0:	10 e0       	ldi	r17, 0x00	; 0
    77a2:	11 23       	and	r17, r17
    77a4:	29 f0       	breq	.+10     	; 0x77b0 <checkMote+0x188>
		__ticks = 1;
    77a6:	81 e0       	ldi	r24, 0x01	; 1
    77a8:	90 e0       	ldi	r25, 0x00	; 0
    77aa:	8f 8b       	std	Y+23, r24	; 0x17
    77ac:	98 8f       	std	Y+24, r25	; 0x18
    77ae:	46 c0       	rjmp	.+140    	; 0x783c <checkMote+0x214>
	else if (__tmp > 65535)
    77b0:	11 e0       	ldi	r17, 0x01	; 1
    77b2:	6b 89       	ldd	r22, Y+19	; 0x13
    77b4:	7c 89       	ldd	r23, Y+20	; 0x14
    77b6:	8d 89       	ldd	r24, Y+21	; 0x15
    77b8:	9e 89       	ldd	r25, Y+22	; 0x16
    77ba:	20 e0       	ldi	r18, 0x00	; 0
    77bc:	3f ef       	ldi	r19, 0xFF	; 255
    77be:	4f e7       	ldi	r20, 0x7F	; 127
    77c0:	57 e4       	ldi	r21, 0x47	; 71
    77c2:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    77c6:	18 16       	cp	r1, r24
    77c8:	0c f0       	brlt	.+2      	; 0x77cc <checkMote+0x1a4>
    77ca:	10 e0       	ldi	r17, 0x00	; 0
    77cc:	11 23       	and	r17, r17
    77ce:	61 f1       	breq	.+88     	; 0x7828 <checkMote+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    77d0:	6f 85       	ldd	r22, Y+15	; 0x0f
    77d2:	78 89       	ldd	r23, Y+16	; 0x10
    77d4:	89 89       	ldd	r24, Y+17	; 0x11
    77d6:	9a 89       	ldd	r25, Y+18	; 0x12
    77d8:	20 e0       	ldi	r18, 0x00	; 0
    77da:	30 e0       	ldi	r19, 0x00	; 0
    77dc:	40 e2       	ldi	r20, 0x20	; 32
    77de:	51 e4       	ldi	r21, 0x41	; 65
    77e0:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    77e4:	dc 01       	movw	r26, r24
    77e6:	cb 01       	movw	r24, r22
    77e8:	bc 01       	movw	r22, r24
    77ea:	cd 01       	movw	r24, r26
    77ec:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    77f0:	dc 01       	movw	r26, r24
    77f2:	cb 01       	movw	r24, r22
    77f4:	8f 8b       	std	Y+23, r24	; 0x17
    77f6:	98 8f       	std	Y+24, r25	; 0x18
    77f8:	12 c0       	rjmp	.+36     	; 0x781e <checkMote+0x1f6>
    77fa:	80 e2       	ldi	r24, 0x20	; 32
    77fc:	93 e0       	ldi	r25, 0x03	; 3
    77fe:	89 8f       	std	Y+25, r24	; 0x19
    7800:	9a 8f       	std	Y+26, r25	; 0x1a
    7802:	89 8d       	ldd	r24, Y+25	; 0x19
    7804:	9a 8d       	ldd	r25, Y+26	; 0x1a
    7806:	8c 01       	movw	r16, r24
    7808:	c8 01       	movw	r24, r16
    780a:	01 97       	sbiw	r24, 0x01	; 1
    780c:	f1 f7       	brne	.-4      	; 0x780a <checkMote+0x1e2>
    780e:	8c 01       	movw	r16, r24
    7810:	09 8f       	std	Y+25, r16	; 0x19
    7812:	1a 8f       	std	Y+26, r17	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7814:	8f 89       	ldd	r24, Y+23	; 0x17
    7816:	98 8d       	ldd	r25, Y+24	; 0x18
    7818:	01 97       	sbiw	r24, 0x01	; 1
    781a:	8f 8b       	std	Y+23, r24	; 0x17
    781c:	98 8f       	std	Y+24, r25	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    781e:	8f 89       	ldd	r24, Y+23	; 0x17
    7820:	98 8d       	ldd	r25, Y+24	; 0x18
    7822:	00 97       	sbiw	r24, 0x00	; 0
    7824:	51 f7       	brne	.-44     	; 0x77fa <checkMote+0x1d2>
    7826:	17 c0       	rjmp	.+46     	; 0x7856 <checkMote+0x22e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7828:	6b 89       	ldd	r22, Y+19	; 0x13
    782a:	7c 89       	ldd	r23, Y+20	; 0x14
    782c:	8d 89       	ldd	r24, Y+21	; 0x15
    782e:	9e 89       	ldd	r25, Y+22	; 0x16
    7830:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    7834:	dc 01       	movw	r26, r24
    7836:	cb 01       	movw	r24, r22
    7838:	8f 8b       	std	Y+23, r24	; 0x17
    783a:	98 8f       	std	Y+24, r25	; 0x18
    783c:	8f 89       	ldd	r24, Y+23	; 0x17
    783e:	98 8d       	ldd	r25, Y+24	; 0x18
    7840:	8b 8f       	std	Y+27, r24	; 0x1b
    7842:	9c 8f       	std	Y+28, r25	; 0x1c
    7844:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7846:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7848:	8c 01       	movw	r16, r24
    784a:	c8 01       	movw	r24, r16
    784c:	01 97       	sbiw	r24, 0x01	; 1
    784e:	f1 f7       	brne	.-4      	; 0x784c <checkMote+0x224>
    7850:	8c 01       	movw	r16, r24
    7852:	0b 8f       	std	Y+27, r16	; 0x1b
    7854:	1c 8f       	std	Y+28, r17	; 0x1c
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    7856:	88 e0       	ldi	r24, 0x08	; 8
    7858:	60 e0       	ldi	r22, 0x00	; 0
    785a:	0e 94 cc 33 	call	0x6798	; 0x6798 <PortEx_OUTCLR>
    785e:	80 e0       	ldi	r24, 0x00	; 0
    7860:	90 e4       	ldi	r25, 0x40	; 64
    7862:	ac e9       	ldi	r26, 0x9C	; 156
    7864:	b5 e4       	ldi	r27, 0x45	; 69
    7866:	8d 8f       	std	Y+29, r24	; 0x1d
    7868:	9e 8f       	std	Y+30, r25	; 0x1e
    786a:	af 8f       	std	Y+31, r26	; 0x1f
    786c:	b8 a3       	lds	r27, 0x58
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    786e:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7870:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7872:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7874:	98 a1       	lds	r25, 0x48
    7876:	20 e0       	ldi	r18, 0x00	; 0
    7878:	30 e0       	ldi	r19, 0x00	; 0
    787a:	4a ef       	ldi	r20, 0xFA	; 250
    787c:	55 e4       	ldi	r21, 0x45	; 69
    787e:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    7882:	dc 01       	movw	r26, r24
    7884:	cb 01       	movw	r24, r22
    7886:	89 a3       	lds	r24, 0x59
    7888:	9a a3       	lds	r25, 0x5a
    788a:	ab a3       	lds	r26, 0x5b
    788c:	bc a3       	lds	r27, 0x5c
	if (__tmp < 1.0)
    788e:	11 e0       	ldi	r17, 0x01	; 1
    7890:	69 a1       	lds	r22, 0x49
    7892:	7a a1       	lds	r23, 0x4a
    7894:	8b a1       	lds	r24, 0x4b
    7896:	9c a1       	lds	r25, 0x4c
    7898:	20 e0       	ldi	r18, 0x00	; 0
    789a:	30 e0       	ldi	r19, 0x00	; 0
    789c:	40 e8       	ldi	r20, 0x80	; 128
    789e:	5f e3       	ldi	r21, 0x3F	; 63
    78a0:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    78a4:	88 23       	and	r24, r24
    78a6:	0c f0       	brlt	.+2      	; 0x78aa <checkMote+0x282>
    78a8:	10 e0       	ldi	r17, 0x00	; 0
    78aa:	11 23       	and	r17, r17
    78ac:	29 f0       	breq	.+10     	; 0x78b8 <checkMote+0x290>
		__ticks = 1;
    78ae:	81 e0       	ldi	r24, 0x01	; 1
    78b0:	90 e0       	ldi	r25, 0x00	; 0
    78b2:	8d a3       	lds	r24, 0x5d
    78b4:	9e a3       	lds	r25, 0x5e
    78b6:	46 c0       	rjmp	.+140    	; 0x7944 <checkMote+0x31c>
	else if (__tmp > 65535)
    78b8:	11 e0       	ldi	r17, 0x01	; 1
    78ba:	69 a1       	lds	r22, 0x49
    78bc:	7a a1       	lds	r23, 0x4a
    78be:	8b a1       	lds	r24, 0x4b
    78c0:	9c a1       	lds	r25, 0x4c
    78c2:	20 e0       	ldi	r18, 0x00	; 0
    78c4:	3f ef       	ldi	r19, 0xFF	; 255
    78c6:	4f e7       	ldi	r20, 0x7F	; 127
    78c8:	57 e4       	ldi	r21, 0x47	; 71
    78ca:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    78ce:	18 16       	cp	r1, r24
    78d0:	0c f0       	brlt	.+2      	; 0x78d4 <checkMote+0x2ac>
    78d2:	10 e0       	ldi	r17, 0x00	; 0
    78d4:	11 23       	and	r17, r17
    78d6:	61 f1       	breq	.+88     	; 0x7930 <checkMote+0x308>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    78d8:	6d 8d       	ldd	r22, Y+29	; 0x1d
    78da:	7e 8d       	ldd	r23, Y+30	; 0x1e
    78dc:	8f 8d       	ldd	r24, Y+31	; 0x1f
    78de:	98 a1       	lds	r25, 0x48
    78e0:	20 e0       	ldi	r18, 0x00	; 0
    78e2:	30 e0       	ldi	r19, 0x00	; 0
    78e4:	40 e2       	ldi	r20, 0x20	; 32
    78e6:	51 e4       	ldi	r21, 0x41	; 65
    78e8:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    78ec:	dc 01       	movw	r26, r24
    78ee:	cb 01       	movw	r24, r22
    78f0:	bc 01       	movw	r22, r24
    78f2:	cd 01       	movw	r24, r26
    78f4:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    78f8:	dc 01       	movw	r26, r24
    78fa:	cb 01       	movw	r24, r22
    78fc:	8d a3       	lds	r24, 0x5d
    78fe:	9e a3       	lds	r25, 0x5e
    7900:	12 c0       	rjmp	.+36     	; 0x7926 <checkMote+0x2fe>
    7902:	80 e2       	ldi	r24, 0x20	; 32
    7904:	93 e0       	ldi	r25, 0x03	; 3
    7906:	8f a3       	lds	r24, 0x5f
    7908:	98 a7       	lds	r25, 0x78
    790a:	8f a1       	lds	r24, 0x4f
    790c:	98 a5       	lds	r25, 0x68
    790e:	8c 01       	movw	r16, r24
    7910:	c8 01       	movw	r24, r16
    7912:	01 97       	sbiw	r24, 0x01	; 1
    7914:	f1 f7       	brne	.-4      	; 0x7912 <checkMote+0x2ea>
    7916:	8c 01       	movw	r16, r24
    7918:	0f a3       	lds	r16, 0x5f
    791a:	18 a7       	lds	r17, 0x78
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    791c:	8d a1       	lds	r24, 0x4d
    791e:	9e a1       	lds	r25, 0x4e
    7920:	01 97       	sbiw	r24, 0x01	; 1
    7922:	8d a3       	lds	r24, 0x5d
    7924:	9e a3       	lds	r25, 0x5e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7926:	8d a1       	lds	r24, 0x4d
    7928:	9e a1       	lds	r25, 0x4e
    792a:	00 97       	sbiw	r24, 0x00	; 0
    792c:	51 f7       	brne	.-44     	; 0x7902 <checkMote+0x2da>
    792e:	18 c0       	rjmp	.+48     	; 0x7960 <checkMote+0x338>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7930:	69 a1       	lds	r22, 0x49
    7932:	7a a1       	lds	r23, 0x4a
    7934:	8b a1       	lds	r24, 0x4b
    7936:	9c a1       	lds	r25, 0x4c
    7938:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    793c:	dc 01       	movw	r26, r24
    793e:	cb 01       	movw	r24, r22
    7940:	8d a3       	lds	r24, 0x5d
    7942:	9e a3       	lds	r25, 0x5e
    7944:	8d a1       	lds	r24, 0x4d
    7946:	9e a1       	lds	r25, 0x4e
    7948:	89 a7       	lds	r24, 0x79
    794a:	9a a7       	lds	r25, 0x7a
    794c:	89 a5       	lds	r24, 0x69
    794e:	9a a5       	lds	r25, 0x6a
    7950:	8c 01       	movw	r16, r24
    7952:	c8 01       	movw	r24, r16
    7954:	01 97       	sbiw	r24, 0x01	; 1
    7956:	f1 f7       	brne	.-4      	; 0x7954 <checkMote+0x32c>
    7958:	8c 01       	movw	r16, r24
    795a:	09 a7       	lds	r16, 0x79
    795c:	1a a7       	lds	r17, 0x7a
		_delay_ms(5000);
	}
    795e:	f7 ce       	rjmp	.-530    	; 0x774e <checkMote+0x126>
    7960:	f6 ce       	rjmp	.-532    	; 0x774e <checkMote+0x126>

00007962 <SD_write_and_read_knowns>:
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    7962:	cf 93       	push	r28
    7964:	df 93       	push	r29
    7966:	cd b7       	in	r28, 0x3d	; 61
    7968:	de b7       	in	r29, 0x3e	; 62
    796a:	28 97       	sbiw	r28, 0x08	; 8
    796c:	cd bf       	out	0x3d, r28	; 61
    796e:	de bf       	out	0x3e, r29	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7970:	19 82       	std	Y+1, r1	; 0x01
    7972:	1a 82       	std	Y+2, r1	; 0x02
    7974:	0c c0       	rjmp	.+24     	; 0x798e <SD_write_and_read_knowns+0x2c>
    7976:	29 81       	ldd	r18, Y+1	; 0x01
    7978:	89 81       	ldd	r24, Y+1	; 0x01
    797a:	9a 81       	ldd	r25, Y+2	; 0x02
    797c:	80 53       	subi	r24, 0x30	; 48
    797e:	9c 4d       	sbci	r25, 0xDC	; 220
    7980:	fc 01       	movw	r30, r24
    7982:	20 83       	st	Z, r18
    7984:	89 81       	ldd	r24, Y+1	; 0x01
    7986:	9a 81       	ldd	r25, Y+2	; 0x02
    7988:	01 96       	adiw	r24, 0x01	; 1
    798a:	89 83       	std	Y+1, r24	; 0x01
    798c:	9a 83       	std	Y+2, r25	; 0x02
    798e:	89 81       	ldd	r24, Y+1	; 0x01
    7990:	9a 81       	ldd	r25, Y+2	; 0x02
    7992:	88 31       	cpi	r24, 0x18	; 24
    7994:	91 05       	cpc	r25, r1
    7996:	7c f3       	brlt	.-34     	; 0x7976 <SD_write_and_read_knowns+0x14>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    7998:	20 ed       	ldi	r18, 0xD0	; 208
    799a:	33 e2       	ldi	r19, 0x23	; 35
    799c:	64 e1       	ldi	r22, 0x14	; 20
    799e:	70 e0       	ldi	r23, 0x00	; 0
    79a0:	80 e0       	ldi	r24, 0x00	; 0
    79a2:	90 e0       	ldi	r25, 0x00	; 0
    79a4:	a9 01       	movw	r20, r18
    79a6:	28 e1       	ldi	r18, 0x18	; 24
    79a8:	30 e0       	ldi	r19, 0x00	; 0
    79aa:	0e 94 b7 4d 	call	0x9b6e	; 0x9b6e <SD_write_block>
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    79ae:	1b 82       	std	Y+3, r1	; 0x03
    79b0:	1c 82       	std	Y+4, r1	; 0x04
    79b2:	0b c0       	rjmp	.+22     	; 0x79ca <SD_write_and_read_knowns+0x68>
    79b4:	8b 81       	ldd	r24, Y+3	; 0x03
    79b6:	9c 81       	ldd	r25, Y+4	; 0x04
    79b8:	80 53       	subi	r24, 0x30	; 48
    79ba:	9c 4d       	sbci	r25, 0xDC	; 220
    79bc:	fc 01       	movw	r30, r24
    79be:	10 82       	st	Z, r1
    79c0:	8b 81       	ldd	r24, Y+3	; 0x03
    79c2:	9c 81       	ldd	r25, Y+4	; 0x04
    79c4:	01 96       	adiw	r24, 0x01	; 1
    79c6:	8b 83       	std	Y+3, r24	; 0x03
    79c8:	9c 83       	std	Y+4, r25	; 0x04
    79ca:	8b 81       	ldd	r24, Y+3	; 0x03
    79cc:	9c 81       	ldd	r25, Y+4	; 0x04
    79ce:	88 31       	cpi	r24, 0x18	; 24
    79d0:	91 05       	cpc	r25, r1
    79d2:	84 f3       	brlt	.-32     	; 0x79b4 <SD_write_and_read_knowns+0x52>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    79d4:	20 ed       	ldi	r18, 0xD0	; 208
    79d6:	33 e2       	ldi	r19, 0x23	; 35
    79d8:	64 e1       	ldi	r22, 0x14	; 20
    79da:	70 e0       	ldi	r23, 0x00	; 0
    79dc:	80 e0       	ldi	r24, 0x00	; 0
    79de:	90 e0       	ldi	r25, 0x00	; 0
    79e0:	a9 01       	movw	r20, r18
    79e2:	0e 94 85 4e 	call	0x9d0a	; 0x9d0a <SD_read_block>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    79e6:	1d 82       	std	Y+5, r1	; 0x05
    79e8:	1e 82       	std	Y+6, r1	; 0x06
    79ea:	13 c0       	rjmp	.+38     	; 0x7a12 <SD_write_and_read_knowns+0xb0>
    79ec:	8d 81       	ldd	r24, Y+5	; 0x05
    79ee:	9e 81       	ldd	r25, Y+6	; 0x06
    79f0:	24 e6       	ldi	r18, 0x64	; 100
    79f2:	30 e0       	ldi	r19, 0x00	; 0
    79f4:	b9 01       	movw	r22, r18
    79f6:	0e 94 d1 5b 	call	0xb7a2	; 0xb7a2 <__divmodhi4>
    79fa:	28 2f       	mov	r18, r24
    79fc:	8d 81       	ldd	r24, Y+5	; 0x05
    79fe:	9e 81       	ldd	r25, Y+6	; 0x06
    7a00:	80 53       	subi	r24, 0x30	; 48
    7a02:	9c 4d       	sbci	r25, 0xDC	; 220
    7a04:	fc 01       	movw	r30, r24
    7a06:	20 83       	st	Z, r18
    7a08:	8d 81       	ldd	r24, Y+5	; 0x05
    7a0a:	9e 81       	ldd	r25, Y+6	; 0x06
    7a0c:	01 96       	adiw	r24, 0x01	; 1
    7a0e:	8d 83       	std	Y+5, r24	; 0x05
    7a10:	9e 83       	std	Y+6, r25	; 0x06
    7a12:	8d 81       	ldd	r24, Y+5	; 0x05
    7a14:	9e 81       	ldd	r25, Y+6	; 0x06
    7a16:	f4 e0       	ldi	r31, 0x04	; 4
    7a18:	82 3e       	cpi	r24, 0xE2	; 226
    7a1a:	9f 07       	cpc	r25, r31
    7a1c:	3c f3       	brlt	.-50     	; 0x79ec <SD_write_and_read_knowns+0x8a>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    7a1e:	20 ed       	ldi	r18, 0xD0	; 208
    7a20:	33 e2       	ldi	r19, 0x23	; 35
    7a22:	60 e5       	ldi	r22, 0x50	; 80
    7a24:	70 e0       	ldi	r23, 0x00	; 0
    7a26:	80 e0       	ldi	r24, 0x00	; 0
    7a28:	90 e0       	ldi	r25, 0x00	; 0
    7a2a:	a9 01       	movw	r20, r18
    7a2c:	22 ee       	ldi	r18, 0xE2	; 226
    7a2e:	34 e0       	ldi	r19, 0x04	; 4
    7a30:	0e 94 fb 4e 	call	0x9df6	; 0x9df6 <SD_write_multiple_blocks>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    7a34:	1f 82       	std	Y+7, r1	; 0x07
    7a36:	18 86       	std	Y+8, r1	; 0x08
    7a38:	0b c0       	rjmp	.+22     	; 0x7a50 <SD_write_and_read_knowns+0xee>
    7a3a:	8f 81       	ldd	r24, Y+7	; 0x07
    7a3c:	98 85       	ldd	r25, Y+8	; 0x08
    7a3e:	80 53       	subi	r24, 0x30	; 48
    7a40:	9c 4d       	sbci	r25, 0xDC	; 220
    7a42:	fc 01       	movw	r30, r24
    7a44:	10 82       	st	Z, r1
    7a46:	8f 81       	ldd	r24, Y+7	; 0x07
    7a48:	98 85       	ldd	r25, Y+8	; 0x08
    7a4a:	01 96       	adiw	r24, 0x01	; 1
    7a4c:	8f 83       	std	Y+7, r24	; 0x07
    7a4e:	98 87       	std	Y+8, r25	; 0x08
    7a50:	8f 81       	ldd	r24, Y+7	; 0x07
    7a52:	98 85       	ldd	r25, Y+8	; 0x08
    7a54:	f4 e0       	ldi	r31, 0x04	; 4
    7a56:	82 3e       	cpi	r24, 0xE2	; 226
    7a58:	9f 07       	cpc	r25, r31
    7a5a:	7c f3       	brlt	.-34     	; 0x7a3a <SD_write_and_read_knowns+0xd8>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    7a5c:	20 ed       	ldi	r18, 0xD0	; 208
    7a5e:	33 e2       	ldi	r19, 0x23	; 35
    7a60:	60 e5       	ldi	r22, 0x50	; 80
    7a62:	70 e0       	ldi	r23, 0x00	; 0
    7a64:	80 e0       	ldi	r24, 0x00	; 0
    7a66:	90 e0       	ldi	r25, 0x00	; 0
    7a68:	a9 01       	movw	r20, r18
    7a6a:	23 e0       	ldi	r18, 0x03	; 3
    7a6c:	30 e0       	ldi	r19, 0x00	; 0
    7a6e:	0e 94 59 50 	call	0xa0b2	; 0xa0b2 <SD_read_multiple_blocks>
}
    7a72:	28 96       	adiw	r28, 0x08	; 8
    7a74:	cd bf       	out	0x3d, r28	; 61
    7a76:	de bf       	out	0x3e, r29	; 62
    7a78:	df 91       	pop	r29
    7a7a:	cf 91       	pop	r28
    7a7c:	08 95       	ret

00007a7e <SD_write_and_read_knowns_FAT>:
//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    7a7e:	cf 93       	push	r28
    7a80:	df 93       	push	r29
    7a82:	00 d0       	rcall	.+0      	; 0x7a84 <SD_write_and_read_knowns_FAT+0x6>
    7a84:	0f 92       	push	r0
    7a86:	cd b7       	in	r28, 0x3d	; 61
    7a88:	de b7       	in	r29, 0x3e	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7a8a:	19 82       	std	Y+1, r1	; 0x01
    7a8c:	1a 82       	std	Y+2, r1	; 0x02
    7a8e:	0c c0       	rjmp	.+24     	; 0x7aa8 <SD_write_and_read_knowns_FAT+0x2a>
    7a90:	29 81       	ldd	r18, Y+1	; 0x01
    7a92:	89 81       	ldd	r24, Y+1	; 0x01
    7a94:	9a 81       	ldd	r25, Y+2	; 0x02
    7a96:	80 53       	subi	r24, 0x30	; 48
    7a98:	9c 4d       	sbci	r25, 0xDC	; 220
    7a9a:	fc 01       	movw	r30, r24
    7a9c:	20 83       	st	Z, r18
    7a9e:	89 81       	ldd	r24, Y+1	; 0x01
    7aa0:	9a 81       	ldd	r25, Y+2	; 0x02
    7aa2:	01 96       	adiw	r24, 0x01	; 1
    7aa4:	89 83       	std	Y+1, r24	; 0x01
    7aa6:	9a 83       	std	Y+2, r25	; 0x02
    7aa8:	89 81       	ldd	r24, Y+1	; 0x01
    7aaa:	9a 81       	ldd	r25, Y+2	; 0x02
    7aac:	88 31       	cpi	r24, 0x18	; 24
    7aae:	91 05       	cpc	r25, r1
    7ab0:	7c f3       	brlt	.-34     	; 0x7a90 <SD_write_and_read_knowns_FAT+0x12>
	error = writeFile((unsigned char*)"testing",FRAMReadBuffer,512);
    7ab2:	89 e0       	ldi	r24, 0x09	; 9
    7ab4:	90 e2       	ldi	r25, 0x20	; 32
    7ab6:	20 ed       	ldi	r18, 0xD0	; 208
    7ab8:	33 e2       	ldi	r19, 0x23	; 35
    7aba:	b9 01       	movw	r22, r18
    7abc:	20 e0       	ldi	r18, 0x00	; 0
    7abe:	32 e0       	ldi	r19, 0x02	; 2
    7ac0:	40 e0       	ldi	r20, 0x00	; 0
    7ac2:	50 e0       	ldi	r21, 0x00	; 0
    7ac4:	0e 94 ac 45 	call	0x8b58	; 0x8b58 <writeFile>
    7ac8:	80 93 94 50 	sts	0x5094, r24
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7acc:	1b 82       	std	Y+3, r1	; 0x03
    7ace:	1c 82       	std	Y+4, r1	; 0x04
    7ad0:	0b c0       	rjmp	.+22     	; 0x7ae8 <SD_write_and_read_knowns_FAT+0x6a>
    7ad2:	8b 81       	ldd	r24, Y+3	; 0x03
    7ad4:	9c 81       	ldd	r25, Y+4	; 0x04
    7ad6:	80 53       	subi	r24, 0x30	; 48
    7ad8:	9c 4d       	sbci	r25, 0xDC	; 220
    7ada:	fc 01       	movw	r30, r24
    7adc:	10 82       	st	Z, r1
    7ade:	8b 81       	ldd	r24, Y+3	; 0x03
    7ae0:	9c 81       	ldd	r25, Y+4	; 0x04
    7ae2:	01 96       	adiw	r24, 0x01	; 1
    7ae4:	8b 83       	std	Y+3, r24	; 0x03
    7ae6:	9c 83       	std	Y+4, r25	; 0x04
    7ae8:	8b 81       	ldd	r24, Y+3	; 0x03
    7aea:	9c 81       	ldd	r25, Y+4	; 0x04
    7aec:	88 31       	cpi	r24, 0x18	; 24
    7aee:	91 05       	cpc	r25, r1
    7af0:	84 f3       	brlt	.-32     	; 0x7ad2 <SD_write_and_read_knowns_FAT+0x54>
	error = readFile(READ,(unsigned char*)"testing");		//read the data into the buffer from file
    7af2:	29 e0       	ldi	r18, 0x09	; 9
    7af4:	30 e2       	ldi	r19, 0x20	; 32
    7af6:	80 e0       	ldi	r24, 0x00	; 0
    7af8:	b9 01       	movw	r22, r18
    7afa:	0e 94 d6 43 	call	0x87ac	; 0x87ac <readFile>
    7afe:	80 93 94 50 	sts	0x5094, r24
}
    7b02:	24 96       	adiw	r28, 0x04	; 4
    7b04:	cd bf       	out	0x3d, r28	; 61
    7b06:	de bf       	out	0x3e, r29	; 62
    7b08:	df 91       	pop	r29
    7b0a:	cf 91       	pop	r28
    7b0c:	08 95       	ret

00007b0e <chibi_test_radio>:




//function for testing radio transmission
void chibi_test_radio(){
    7b0e:	cf 93       	push	r28
    7b10:	df 93       	push	r29
    7b12:	cd b7       	in	r28, 0x3d	; 61
    7b14:	de b7       	in	r29, 0x3e	; 62
		
	chb_init();
    7b16:	0e 94 be 1d 	call	0x3b7c	; 0x3b7c <chb_init>
	chb_set_short_addr(0x0002);
    7b1a:	82 e0       	ldi	r24, 0x02	; 2
    7b1c:	90 e0       	ldi	r25, 0x00	; 0
    7b1e:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    7b22:	00 00       	nop
    7b24:	fe cf       	rjmp	.-4      	; 0x7b22 <chibi_test_radio+0x14>

00007b26 <TestCard>:
	for (int i=0;i<10;i++) FRAMReadBuffer[i] = 0;
	chb_read(FRAMReadBuffer);
	*/
}
//another testing function for sd card
void TestCard(){
    7b26:	cf 93       	push	r28
    7b28:	df 93       	push	r29
    7b2a:	0f 92       	push	r0
    7b2c:	0f 92       	push	r0
    7b2e:	cd b7       	in	r28, 0x3d	; 61
    7b30:	de b7       	in	r29, 0x3e	; 62
	SD_init();
    7b32:	0e 94 14 4b 	call	0x9628	; 0x9628 <SD_init>
	getBootSectorData();
    7b36:	0e 94 27 3f 	call	0x7e4e	; 0x7e4e <getBootSectorData>
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    7b3a:	19 82       	std	Y+1, r1	; 0x01
    7b3c:	1a 82       	std	Y+2, r1	; 0x02
    7b3e:	13 c0       	rjmp	.+38     	; 0x7b66 <TestCard+0x40>
    7b40:	89 81       	ldd	r24, Y+1	; 0x01
    7b42:	9a 81       	ldd	r25, Y+2	; 0x02
    7b44:	29 e7       	ldi	r18, 0x79	; 121
    7b46:	30 e0       	ldi	r19, 0x00	; 0
    7b48:	b9 01       	movw	r22, r18
    7b4a:	0e 94 d1 5b 	call	0xb7a2	; 0xb7a2 <__divmodhi4>
    7b4e:	28 2f       	mov	r18, r24
    7b50:	89 81       	ldd	r24, Y+1	; 0x01
    7b52:	9a 81       	ldd	r25, Y+2	; 0x02
    7b54:	80 53       	subi	r24, 0x30	; 48
    7b56:	9c 4d       	sbci	r25, 0xDC	; 220
    7b58:	fc 01       	movw	r30, r24
    7b5a:	20 83       	st	Z, r18
    7b5c:	89 81       	ldd	r24, Y+1	; 0x01
    7b5e:	9a 81       	ldd	r25, Y+2	; 0x02
    7b60:	01 96       	adiw	r24, 0x01	; 1
    7b62:	89 83       	std	Y+1, r24	; 0x01
    7b64:	9a 83       	std	Y+2, r25	; 0x02
    7b66:	89 81       	ldd	r24, Y+1	; 0x01
    7b68:	9a 81       	ldd	r25, Y+2	; 0x02
    7b6a:	f2 e0       	ldi	r31, 0x02	; 2
    7b6c:	80 30       	cpi	r24, 0x00	; 0
    7b6e:	9f 07       	cpc	r25, r31
    7b70:	3c f3       	brlt	.-50     	; 0x7b40 <TestCard+0x1a>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile((unsigned char*)"testing",FRAMReadBuffer,512);//}
    7b72:	89 e0       	ldi	r24, 0x09	; 9
    7b74:	90 e2       	ldi	r25, 0x20	; 32
    7b76:	20 ed       	ldi	r18, 0xD0	; 208
    7b78:	33 e2       	ldi	r19, 0x23	; 35
    7b7a:	b9 01       	movw	r22, r18
    7b7c:	20 e0       	ldi	r18, 0x00	; 0
    7b7e:	32 e0       	ldi	r19, 0x02	; 2
    7b80:	40 e0       	ldi	r20, 0x00	; 0
    7b82:	50 e0       	ldi	r21, 0x00	; 0
    7b84:	0e 94 ac 45 	call	0x8b58	; 0x8b58 <writeFile>
	nop();
    7b88:	00 00       	nop
}
    7b8a:	0f 90       	pop	r0
    7b8c:	0f 90       	pop	r0
    7b8e:	df 91       	pop	r29
    7b90:	cf 91       	pop	r28
    7b92:	08 95       	ret

00007b94 <__vector_43>:

//interrupt service routine for handling received data over radio. Gets called when data received by the mote. Has cases for synching right now.
ISR(PORTE_INT0_vect){
    7b94:	1f 92       	push	r1
    7b96:	0f 92       	push	r0
    7b98:	0f b6       	in	r0, 0x3f	; 63
    7b9a:	0f 92       	push	r0
    7b9c:	00 90 3b 00 	lds	r0, 0x003B
    7ba0:	0f 92       	push	r0
    7ba2:	11 24       	eor	r1, r1
    7ba4:	2f 93       	push	r18
    7ba6:	3f 93       	push	r19
    7ba8:	4f 93       	push	r20
    7baa:	5f 93       	push	r21
    7bac:	6f 93       	push	r22
    7bae:	7f 93       	push	r23
    7bb0:	8f 93       	push	r24
    7bb2:	9f 93       	push	r25
    7bb4:	af 93       	push	r26
    7bb6:	bf 93       	push	r27
    7bb8:	ef 93       	push	r30
    7bba:	ff 93       	push	r31
    7bbc:	cf 93       	push	r28
    7bbe:	df 93       	push	r29
    7bc0:	00 d0       	rcall	.+0      	; 0x7bc2 <__vector_43+0x2e>
    7bc2:	00 d0       	rcall	.+0      	; 0x7bc4 <__vector_43+0x30>
    7bc4:	cd b7       	in	r28, 0x3d	; 61
    7bc6:	de b7       	in	r29, 0x3e	; 62
	chb_rx_data_t* msg = NULL;
    7bc8:	1d 82       	std	Y+5, r1	; 0x05
    7bca:	1e 82       	std	Y+6, r1	; 0x06
	switch (RadioMonitorMode) {
    7bcc:	80 91 4f 40 	lds	r24, 0x404F
    7bd0:	88 2f       	mov	r24, r24
    7bd2:	90 e0       	ldi	r25, 0x00	; 0
    7bd4:	81 30       	cpi	r24, 0x01	; 1
    7bd6:	91 05       	cpc	r25, r1
    7bd8:	29 f0       	breq	.+10     	; 0x7be4 <__vector_43+0x50>
    7bda:	82 30       	cpi	r24, 0x02	; 2
    7bdc:	91 05       	cpc	r25, r1
    7bde:	09 f4       	brne	.+2      	; 0x7be2 <__vector_43+0x4e>
    7be0:	74 c0       	rjmp	.+232    	; 0x7cca <__vector_43+0x136>
    7be2:	93 c0       	rjmp	.+294    	; 0x7d0a <__vector_43+0x176>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    7be4:	8d 81       	ldd	r24, Y+5	; 0x05
    7be6:	9e 81       	ldd	r25, Y+6	; 0x06
    7be8:	0e 94 0f 20 	call	0x401e	; 0x401e <chb_read>
			if(!strncmp((const char*)(msg->data),"reset",5)){
    7bec:	8d 81       	ldd	r24, Y+5	; 0x05
    7bee:	9e 81       	ldd	r25, Y+6	; 0x06
    7bf0:	05 96       	adiw	r24, 0x05	; 5
    7bf2:	21 e1       	ldi	r18, 0x11	; 17
    7bf4:	30 e2       	ldi	r19, 0x20	; 32
    7bf6:	b9 01       	movw	r22, r18
    7bf8:	45 e0       	ldi	r20, 0x05	; 5
    7bfa:	50 e0       	ldi	r21, 0x00	; 0
    7bfc:	0e 94 76 5c 	call	0xb8ec	; 0xb8ec <strncmp>
    7c00:	00 97       	sbiw	r24, 0x00	; 0
    7c02:	51 f4       	brne	.+20     	; 0x7c18 <__vector_43+0x84>
				MotesReadyToSynch++;
    7c04:	80 91 69 50 	lds	r24, 0x5069
    7c08:	90 91 6a 50 	lds	r25, 0x506A
    7c0c:	01 96       	adiw	r24, 0x01	; 1
    7c0e:	80 93 69 50 	sts	0x5069, r24
    7c12:	90 93 6a 50 	sts	0x506A, r25
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    7c16:	7b c0       	rjmp	.+246    	; 0x7d0e <__vector_43+0x17a>
			if(!strncmp((const char*)(msg->data),"reset",5)){
				MotesReadyToSynch++;
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
    7c18:	19 82       	std	Y+1, r1	; 0x01
    7c1a:	1a 82       	std	Y+2, r1	; 0x02
    7c1c:	1b 82       	std	Y+3, r1	; 0x03
    7c1e:	1c 82       	std	Y+4, r1	; 0x04
    7c20:	1a c0       	rjmp	.+52     	; 0x7c56 <__vector_43+0xc2>
    7c22:	2d 81       	ldd	r18, Y+5	; 0x05
    7c24:	3e 81       	ldd	r19, Y+6	; 0x06
    7c26:	89 81       	ldd	r24, Y+1	; 0x01
    7c28:	9a 81       	ldd	r25, Y+2	; 0x02
    7c2a:	82 0f       	add	r24, r18
    7c2c:	93 1f       	adc	r25, r19
    7c2e:	05 96       	adiw	r24, 0x05	; 5
    7c30:	fc 01       	movw	r30, r24
    7c32:	20 81       	ld	r18, Z
    7c34:	89 81       	ldd	r24, Y+1	; 0x01
    7c36:	9a 81       	ldd	r25, Y+2	; 0x02
    7c38:	80 53       	subi	r24, 0x30	; 48
    7c3a:	9c 4d       	sbci	r25, 0xDC	; 220
    7c3c:	fc 01       	movw	r30, r24
    7c3e:	20 83       	st	Z, r18
    7c40:	89 81       	ldd	r24, Y+1	; 0x01
    7c42:	9a 81       	ldd	r25, Y+2	; 0x02
    7c44:	ab 81       	ldd	r26, Y+3	; 0x03
    7c46:	bc 81       	ldd	r27, Y+4	; 0x04
    7c48:	01 96       	adiw	r24, 0x01	; 1
    7c4a:	a1 1d       	adc	r26, r1
    7c4c:	b1 1d       	adc	r27, r1
    7c4e:	89 83       	std	Y+1, r24	; 0x01
    7c50:	9a 83       	std	Y+2, r25	; 0x02
    7c52:	ab 83       	std	Y+3, r26	; 0x03
    7c54:	bc 83       	std	Y+4, r27	; 0x04
    7c56:	89 81       	ldd	r24, Y+1	; 0x01
    7c58:	9a 81       	ldd	r25, Y+2	; 0x02
    7c5a:	ab 81       	ldd	r26, Y+3	; 0x03
    7c5c:	bc 81       	ldd	r27, Y+4	; 0x04
    7c5e:	80 38       	cpi	r24, 0x80	; 128
    7c60:	91 05       	cpc	r25, r1
    7c62:	a1 05       	cpc	r26, r1
    7c64:	b1 05       	cpc	r27, r1
    7c66:	e8 f2       	brcs	.-70     	; 0x7c22 <__vector_43+0x8e>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    7c68:	80 91 bb 50 	lds	r24, 0x50BB
    7c6c:	90 91 bc 50 	lds	r25, 0x50BC
    7c70:	a0 91 bd 50 	lds	r26, 0x50BD
    7c74:	b0 91 be 50 	lds	r27, 0x50BE
    7c78:	80 58       	subi	r24, 0x80	; 128
    7c7a:	9f 4f       	sbci	r25, 0xFF	; 255
    7c7c:	af 4f       	sbci	r26, 0xFF	; 255
    7c7e:	bf 4f       	sbci	r27, 0xFF	; 255
    7c80:	80 93 bb 50 	sts	0x50BB, r24
    7c84:	90 93 bc 50 	sts	0x50BC, r25
    7c88:	a0 93 bd 50 	sts	0x50BD, r26
    7c8c:	b0 93 be 50 	sts	0x50BE, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    7c90:	80 91 bb 50 	lds	r24, 0x50BB
    7c94:	90 91 bc 50 	lds	r25, 0x50BC
    7c98:	a0 91 bd 50 	lds	r26, 0x50BD
    7c9c:	b0 91 be 50 	lds	r27, 0x50BE
    7ca0:	80 58       	subi	r24, 0x80	; 128
    7ca2:	9f 4f       	sbci	r25, 0xFF	; 255
    7ca4:	af 4f       	sbci	r26, 0xFF	; 255
    7ca6:	bf 4f       	sbci	r27, 0xFF	; 255
    7ca8:	81 37       	cpi	r24, 0x71	; 113
    7caa:	fc e1       	ldi	r31, 0x1C	; 28
    7cac:	9f 07       	cpc	r25, r31
    7cae:	f0 e0       	ldi	r31, 0x00	; 0
    7cb0:	af 07       	cpc	r26, r31
    7cb2:	f0 e0       	ldi	r31, 0x00	; 0
    7cb4:	bf 07       	cpc	r27, r31
    7cb6:	58 f1       	brcs	.+86     	; 0x7d0e <__vector_43+0x17a>
    7cb8:	10 92 bb 50 	sts	0x50BB, r1
    7cbc:	10 92 bc 50 	sts	0x50BC, r1
    7cc0:	10 92 bd 50 	sts	0x50BD, r1
    7cc4:	10 92 be 50 	sts	0x50BE, r1
			}			
			break;
    7cc8:	22 c0       	rjmp	.+68     	; 0x7d0e <__vector_43+0x17a>
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    7cca:	8d 81       	ldd	r24, Y+5	; 0x05
    7ccc:	9e 81       	ldd	r25, Y+6	; 0x06
    7cce:	0e 94 0f 20 	call	0x401e	; 0x401e <chb_read>
			if(!strncmp((const char*)(msg->data),"start sampling",14)){	//if basestation synch response message received, do the following
    7cd2:	8d 81       	ldd	r24, Y+5	; 0x05
    7cd4:	9e 81       	ldd	r25, Y+6	; 0x06
    7cd6:	05 96       	adiw	r24, 0x05	; 5
    7cd8:	27 e1       	ldi	r18, 0x17	; 23
    7cda:	30 e2       	ldi	r19, 0x20	; 32
    7cdc:	b9 01       	movw	r22, r18
    7cde:	4e e0       	ldi	r20, 0x0E	; 14
    7ce0:	50 e0       	ldi	r21, 0x00	; 0
    7ce2:	0e 94 76 5c 	call	0xb8ec	; 0xb8ec <strncmp>
    7ce6:	00 97       	sbiw	r24, 0x00	; 0
    7ce8:	a1 f4       	brne	.+40     	; 0x7d12 <__vector_43+0x17e>
				RadioMonitorMode = SYNCHED;
    7cea:	83 e0       	ldi	r24, 0x03	; 3
    7cec:	80 93 4f 40 	sts	0x404F, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    7cf0:	80 e4       	ldi	r24, 0x40	; 64
    7cf2:	99 e0       	ldi	r25, 0x09	; 9
    7cf4:	29 e0       	ldi	r18, 0x09	; 9
    7cf6:	fc 01       	movw	r30, r24
    7cf8:	20 83       	st	Z, r18
				TCC1.CTRLA = 0x01;  
    7cfa:	80 e4       	ldi	r24, 0x40	; 64
    7cfc:	98 e0       	ldi	r25, 0x08	; 8
    7cfe:	21 e0       	ldi	r18, 0x01	; 1
    7d00:	fc 01       	movw	r30, r24
    7d02:	20 83       	st	Z, r18
				ADC_Resume_Sampling();	//resume sampling with the adc
    7d04:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <ADC_Resume_Sampling>
			}
			break;
    7d08:	04 c0       	rjmp	.+8      	; 0x7d12 <__vector_43+0x17e>
		default:
			break;
    7d0a:	00 00       	nop
    7d0c:	03 c0       	rjmp	.+6      	; 0x7d14 <__vector_43+0x180>
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg->data[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    7d0e:	00 00       	nop
    7d10:	01 c0       	rjmp	.+2      	; 0x7d14 <__vector_43+0x180>
				RadioMonitorMode = SYNCHED;
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
				TCC1.CTRLA = 0x01;  
				ADC_Resume_Sampling();	//resume sampling with the adc
			}
			break;
    7d12:	00 00       	nop
		default:
			break;
	}
}
    7d14:	26 96       	adiw	r28, 0x06	; 6
    7d16:	cd bf       	out	0x3d, r28	; 61
    7d18:	de bf       	out	0x3e, r29	; 62
    7d1a:	df 91       	pop	r29
    7d1c:	cf 91       	pop	r28
    7d1e:	ff 91       	pop	r31
    7d20:	ef 91       	pop	r30
    7d22:	bf 91       	pop	r27
    7d24:	af 91       	pop	r26
    7d26:	9f 91       	pop	r25
    7d28:	8f 91       	pop	r24
    7d2a:	7f 91       	pop	r23
    7d2c:	6f 91       	pop	r22
    7d2e:	5f 91       	pop	r21
    7d30:	4f 91       	pop	r20
    7d32:	3f 91       	pop	r19
    7d34:	2f 91       	pop	r18
    7d36:	0f 90       	pop	r0
    7d38:	00 92 3b 00 	sts	0x003B, r0
    7d3c:	0f 90       	pop	r0
    7d3e:	0f be       	out	0x3f, r0	; 63
    7d40:	0f 90       	pop	r0
    7d42:	1f 90       	pop	r1
    7d44:	18 95       	reti

00007d46 <DeciToString>:

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
    7d46:	cf 93       	push	r28
    7d48:	df 93       	push	r29
    7d4a:	cd b7       	in	r28, 0x3d	; 61
    7d4c:	de b7       	in	r29, 0x3e	; 62
    7d4e:	a0 97       	sbiw	r28, 0x20	; 32
    7d50:	cd bf       	out	0x3d, r28	; 61
    7d52:	de bf       	out	0x3e, r29	; 62
    7d54:	89 8f       	std	Y+25, r24	; 0x19
    7d56:	9a 8f       	std	Y+26, r25	; 0x1a
    7d58:	4b 8f       	std	Y+27, r20	; 0x1b
    7d5a:	5c 8f       	std	Y+28, r21	; 0x1c
    7d5c:	6d 8f       	std	Y+29, r22	; 0x1d
    7d5e:	7e 8f       	std	Y+30, r23	; 0x1e
    7d60:	2f 8f       	std	Y+31, r18	; 0x1f
    7d62:	38 a3       	lds	r19, 0x58
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
    7d64:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7d66:	98 a1       	lds	r25, 0x48
    7d68:	fc 01       	movw	r30, r24
    7d6a:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
    7d6c:	19 82       	std	Y+1, r1	; 0x01
    7d6e:	1a 82       	std	Y+2, r1	; 0x02
    7d70:	1b 82       	std	Y+3, r1	; 0x03
    7d72:	1c 82       	std	Y+4, r1	; 0x04
    7d74:	58 c0       	rjmp	.+176    	; 0x7e26 <DeciToString+0xe0>
		//written = sprintf(b,"%ld",DecimalArray[i]);
		sprintf(b,"%ld",DecimalArray[i]);
    7d76:	89 81       	ldd	r24, Y+1	; 0x01
    7d78:	9a 81       	ldd	r25, Y+2	; 0x02
    7d7a:	88 0f       	add	r24, r24
    7d7c:	99 1f       	adc	r25, r25
    7d7e:	88 0f       	add	r24, r24
    7d80:	99 1f       	adc	r25, r25
    7d82:	29 8d       	ldd	r18, Y+25	; 0x19
    7d84:	3a 8d       	ldd	r19, Y+26	; 0x1a
    7d86:	82 0f       	add	r24, r18
    7d88:	93 1f       	adc	r25, r19
    7d8a:	fc 01       	movw	r30, r24
    7d8c:	80 81       	ld	r24, Z
    7d8e:	91 81       	ldd	r25, Z+1	; 0x01
    7d90:	a2 81       	ldd	r26, Z+2	; 0x02
    7d92:	b3 81       	ldd	r27, Z+3	; 0x03
    7d94:	2d b7       	in	r18, 0x3d	; 61
    7d96:	3e b7       	in	r19, 0x3e	; 62
    7d98:	28 50       	subi	r18, 0x08	; 8
    7d9a:	30 40       	sbci	r19, 0x00	; 0
    7d9c:	2d bf       	out	0x3d, r18	; 61
    7d9e:	3e bf       	out	0x3e, r19	; 62
    7da0:	2d b7       	in	r18, 0x3d	; 61
    7da2:	3e b7       	in	r19, 0x3e	; 62
    7da4:	2f 5f       	subi	r18, 0xFF	; 255
    7da6:	3f 4f       	sbci	r19, 0xFF	; 255
    7da8:	ae 01       	movw	r20, r28
    7daa:	4b 5f       	subi	r20, 0xFB	; 251
    7dac:	5f 4f       	sbci	r21, 0xFF	; 255
    7dae:	f9 01       	movw	r30, r18
    7db0:	40 83       	st	Z, r20
    7db2:	51 83       	std	Z+1, r21	; 0x01
    7db4:	46 e2       	ldi	r20, 0x26	; 38
    7db6:	50 e2       	ldi	r21, 0x20	; 32
    7db8:	f9 01       	movw	r30, r18
    7dba:	42 83       	std	Z+2, r20	; 0x02
    7dbc:	53 83       	std	Z+3, r21	; 0x03
    7dbe:	f9 01       	movw	r30, r18
    7dc0:	84 83       	std	Z+4, r24	; 0x04
    7dc2:	95 83       	std	Z+5, r25	; 0x05
    7dc4:	a6 83       	std	Z+6, r26	; 0x06
    7dc6:	b7 83       	std	Z+7, r27	; 0x07
    7dc8:	0e 94 b7 5c 	call	0xb96e	; 0xb96e <sprintf>
    7dcc:	2d b7       	in	r18, 0x3d	; 61
    7dce:	3e b7       	in	r19, 0x3e	; 62
    7dd0:	28 5f       	subi	r18, 0xF8	; 248
    7dd2:	3f 4f       	sbci	r19, 0xFF	; 255
    7dd4:	2d bf       	out	0x3d, r18	; 61
    7dd6:	3e bf       	out	0x3e, r19	; 62
		strcat(ReturnString,b);
    7dd8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7dda:	98 a1       	lds	r25, 0x48
    7ddc:	9e 01       	movw	r18, r28
    7dde:	2b 5f       	subi	r18, 0xFB	; 251
    7de0:	3f 4f       	sbci	r19, 0xFF	; 255
    7de2:	b9 01       	movw	r22, r18
    7de4:	0e 94 6b 5c 	call	0xb8d6	; 0xb8d6 <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
    7de8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7dea:	98 a1       	lds	r25, 0x48
    7dec:	9c 01       	movw	r18, r24
    7dee:	f9 01       	movw	r30, r18
    7df0:	01 90       	ld	r0, Z+
    7df2:	00 20       	and	r0, r0
    7df4:	e9 f7       	brne	.-6      	; 0x7df0 <DeciToString+0xaa>
    7df6:	cf 01       	movw	r24, r30
    7df8:	01 97       	sbiw	r24, 0x01	; 1
    7dfa:	82 1b       	sub	r24, r18
    7dfc:	93 0b       	sbc	r25, r19
    7dfe:	2f 8d       	ldd	r18, Y+31	; 0x1f
    7e00:	38 a1       	lds	r19, 0x48
    7e02:	82 0f       	add	r24, r18
    7e04:	93 1f       	adc	r25, r19
    7e06:	2a e0       	ldi	r18, 0x0A	; 10
    7e08:	30 e0       	ldi	r19, 0x00	; 0
    7e0a:	fc 01       	movw	r30, r24
    7e0c:	20 83       	st	Z, r18
    7e0e:	31 83       	std	Z+1, r19	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	//int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
    7e10:	89 81       	ldd	r24, Y+1	; 0x01
    7e12:	9a 81       	ldd	r25, Y+2	; 0x02
    7e14:	ab 81       	ldd	r26, Y+3	; 0x03
    7e16:	bc 81       	ldd	r27, Y+4	; 0x04
    7e18:	01 96       	adiw	r24, 0x01	; 1
    7e1a:	a1 1d       	adc	r26, r1
    7e1c:	b1 1d       	adc	r27, r1
    7e1e:	89 83       	std	Y+1, r24	; 0x01
    7e20:	9a 83       	std	Y+2, r25	; 0x02
    7e22:	ab 83       	std	Y+3, r26	; 0x03
    7e24:	bc 83       	std	Y+4, r27	; 0x04
    7e26:	29 81       	ldd	r18, Y+1	; 0x01
    7e28:	3a 81       	ldd	r19, Y+2	; 0x02
    7e2a:	4b 81       	ldd	r20, Y+3	; 0x03
    7e2c:	5c 81       	ldd	r21, Y+4	; 0x04
    7e2e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7e30:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7e32:	ad 8d       	ldd	r26, Y+29	; 0x1d
    7e34:	be 8d       	ldd	r27, Y+30	; 0x1e
    7e36:	28 17       	cp	r18, r24
    7e38:	39 07       	cpc	r19, r25
    7e3a:	4a 07       	cpc	r20, r26
    7e3c:	5b 07       	cpc	r21, r27
    7e3e:	08 f4       	brcc	.+2      	; 0x7e42 <DeciToString+0xfc>
    7e40:	9a cf       	rjmp	.-204    	; 0x7d76 <DeciToString+0x30>
		sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}		
    7e42:	a0 96       	adiw	r28, 0x20	; 32
    7e44:	cd bf       	out	0x3d, r28	; 61
    7e46:	de bf       	out	0x3e, r29	; 62
    7e48:	df 91       	pop	r29
    7e4a:	cf 91       	pop	r28
    7e4c:	08 95       	ret

00007e4e <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    7e4e:	ef 92       	push	r14
    7e50:	ff 92       	push	r15
    7e52:	0f 93       	push	r16
    7e54:	1f 93       	push	r17
    7e56:	cf 93       	push	r28
    7e58:	df 93       	push	r29
    7e5a:	cd b7       	in	r28, 0x3d	; 61
    7e5c:	de b7       	in	r29, 0x3e	; 62
    7e5e:	2a 97       	sbiw	r28, 0x0a	; 10
    7e60:	cd bf       	out	0x3d, r28	; 61
    7e62:	de bf       	out	0x3e, r29	; 62
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    7e64:	10 92 6e 50 	sts	0x506E, r1
    7e68:	10 92 6f 50 	sts	0x506F, r1
    7e6c:	10 92 70 50 	sts	0x5070, r1
    7e70:	10 92 71 50 	sts	0x5071, r1

SD_read_block(0,SDBuffer);
    7e74:	27 ec       	ldi	r18, 0xC7	; 199
    7e76:	31 e2       	ldi	r19, 0x21	; 33
    7e78:	60 e0       	ldi	r22, 0x00	; 0
    7e7a:	70 e0       	ldi	r23, 0x00	; 0
    7e7c:	cb 01       	movw	r24, r22
    7e7e:	a9 01       	movw	r20, r18
    7e80:	0e 94 85 4e 	call	0x9d0a	; 0x9d0a <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;
    7e84:	87 ec       	ldi	r24, 0xC7	; 199
    7e86:	91 e2       	ldi	r25, 0x21	; 33
    7e88:	89 83       	std	Y+1, r24	; 0x01
    7e8a:	9a 83       	std	Y+2, r25	; 0x02

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    7e8c:	89 81       	ldd	r24, Y+1	; 0x01
    7e8e:	9a 81       	ldd	r25, Y+2	; 0x02
    7e90:	fc 01       	movw	r30, r24
    7e92:	80 81       	ld	r24, Z
    7e94:	89 3e       	cpi	r24, 0xE9	; 233
    7e96:	09 f4       	brne	.+2      	; 0x7e9a <getBootSectorData+0x4c>
    7e98:	4d c0       	rjmp	.+154    	; 0x7f34 <getBootSectorData+0xe6>
    7e9a:	89 81       	ldd	r24, Y+1	; 0x01
    7e9c:	9a 81       	ldd	r25, Y+2	; 0x02
    7e9e:	fc 01       	movw	r30, r24
    7ea0:	80 81       	ld	r24, Z
    7ea2:	8b 3e       	cpi	r24, 0xEB	; 235
    7ea4:	09 f4       	brne	.+2      	; 0x7ea8 <getBootSectorData+0x5a>
    7ea6:	46 c0       	rjmp	.+140    	; 0x7f34 <getBootSectorData+0xe6>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
    7ea8:	87 ec       	ldi	r24, 0xC7	; 199
    7eaa:	91 e2       	ldi	r25, 0x21	; 33
    7eac:	8b 83       	std	Y+3, r24	; 0x03
    7eae:	9c 83       	std	Y+4, r25	; 0x04
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    7eb0:	8b 81       	ldd	r24, Y+3	; 0x03
    7eb2:	9c 81       	ldd	r25, Y+4	; 0x04
    7eb4:	82 50       	subi	r24, 0x02	; 2
    7eb6:	9e 4f       	sbci	r25, 0xFE	; 254
    7eb8:	fc 01       	movw	r30, r24
    7eba:	80 81       	ld	r24, Z
    7ebc:	91 81       	ldd	r25, Z+1	; 0x01
    7ebe:	fa ea       	ldi	r31, 0xAA	; 170
    7ec0:	85 35       	cpi	r24, 0x55	; 85
    7ec2:	9f 07       	cpc	r25, r31
    7ec4:	11 f0       	breq	.+4      	; 0x7eca <getBootSectorData+0x7c>
    7ec6:	81 e0       	ldi	r24, 0x01	; 1
    7ec8:	01 c1       	rjmp	.+514    	; 0x80cc <getBootSectorData+0x27e>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
    7eca:	8b 81       	ldd	r24, Y+3	; 0x03
    7ecc:	9c 81       	ldd	r25, Y+4	; 0x04
    7ece:	82 54       	subi	r24, 0x42	; 66
    7ed0:	9e 4f       	sbci	r25, 0xFE	; 254
    7ed2:	8d 83       	std	Y+5, r24	; 0x05
    7ed4:	9e 83       	std	Y+6, r25	; 0x06
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    7ed6:	8d 81       	ldd	r24, Y+5	; 0x05
    7ed8:	9e 81       	ldd	r25, Y+6	; 0x06
    7eda:	fc 01       	movw	r30, r24
    7edc:	80 85       	ldd	r24, Z+8	; 0x08
    7ede:	91 85       	ldd	r25, Z+9	; 0x09
    7ee0:	a2 85       	ldd	r26, Z+10	; 0x0a
    7ee2:	b3 85       	ldd	r27, Z+11	; 0x0b
    7ee4:	80 93 6e 50 	sts	0x506E, r24
    7ee8:	90 93 6f 50 	sts	0x506F, r25
    7eec:	a0 93 70 50 	sts	0x5070, r26
    7ef0:	b0 93 71 50 	sts	0x5071, r27
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    7ef4:	8d 81       	ldd	r24, Y+5	; 0x05
    7ef6:	9e 81       	ldd	r25, Y+6	; 0x06
    7ef8:	fc 01       	movw	r30, r24
    7efa:	80 85       	ldd	r24, Z+8	; 0x08
    7efc:	91 85       	ldd	r25, Z+9	; 0x09
    7efe:	a2 85       	ldd	r26, Z+10	; 0x0a
    7f00:	b3 85       	ldd	r27, Z+11	; 0x0b
    7f02:	27 ec       	ldi	r18, 0xC7	; 199
    7f04:	31 e2       	ldi	r19, 0x21	; 33
    7f06:	bc 01       	movw	r22, r24
    7f08:	cd 01       	movw	r24, r26
    7f0a:	a9 01       	movw	r20, r18
    7f0c:	0e 94 85 4e 	call	0x9d0a	; 0x9d0a <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
    7f10:	87 ec       	ldi	r24, 0xC7	; 199
    7f12:	91 e2       	ldi	r25, 0x21	; 33
    7f14:	89 83       	std	Y+1, r24	; 0x01
    7f16:	9a 83       	std	Y+2, r25	; 0x02
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    7f18:	89 81       	ldd	r24, Y+1	; 0x01
    7f1a:	9a 81       	ldd	r25, Y+2	; 0x02
    7f1c:	fc 01       	movw	r30, r24
    7f1e:	80 81       	ld	r24, Z
    7f20:	89 3e       	cpi	r24, 0xE9	; 233
    7f22:	41 f0       	breq	.+16     	; 0x7f34 <getBootSectorData+0xe6>
    7f24:	89 81       	ldd	r24, Y+1	; 0x01
    7f26:	9a 81       	ldd	r25, Y+2	; 0x02
    7f28:	fc 01       	movw	r30, r24
    7f2a:	80 81       	ld	r24, Z
    7f2c:	8b 3e       	cpi	r24, 0xEB	; 235
    7f2e:	11 f0       	breq	.+4      	; 0x7f34 <getBootSectorData+0xe6>
    7f30:	81 e0       	ldi	r24, 0x01	; 1
    7f32:	cc c0       	rjmp	.+408    	; 0x80cc <getBootSectorData+0x27e>
}

bytesPerSector = bpb->bytesPerSector;
    7f34:	89 81       	ldd	r24, Y+1	; 0x01
    7f36:	9a 81       	ldd	r25, Y+2	; 0x02
    7f38:	fc 01       	movw	r30, r24
    7f3a:	83 85       	ldd	r24, Z+11	; 0x0b
    7f3c:	94 85       	ldd	r25, Z+12	; 0x0c
    7f3e:	80 93 45 40 	sts	0x4045, r24
    7f42:	90 93 46 40 	sts	0x4046, r25
sectorPerCluster = bpb->sectorPerCluster;
    7f46:	89 81       	ldd	r24, Y+1	; 0x01
    7f48:	9a 81       	ldd	r25, Y+2	; 0x02
    7f4a:	fc 01       	movw	r30, r24
    7f4c:	85 85       	ldd	r24, Z+13	; 0x0d
    7f4e:	88 2f       	mov	r24, r24
    7f50:	90 e0       	ldi	r25, 0x00	; 0
    7f52:	80 93 6c 50 	sts	0x506C, r24
    7f56:	90 93 6d 50 	sts	0x506D, r25
reservedSectorCount = bpb->reservedSectorCount;
    7f5a:	89 81       	ldd	r24, Y+1	; 0x01
    7f5c:	9a 81       	ldd	r25, Y+2	; 0x02
    7f5e:	fc 01       	movw	r30, r24
    7f60:	86 85       	ldd	r24, Z+14	; 0x0e
    7f62:	97 85       	ldd	r25, Z+15	; 0x0f
    7f64:	80 93 74 50 	sts	0x5074, r24
    7f68:	90 93 75 50 	sts	0x5075, r25
rootCluster = bpb->rootCluster;
    7f6c:	89 81       	ldd	r24, Y+1	; 0x01
    7f6e:	9a 81       	ldd	r25, Y+2	; 0x02
    7f70:	fc 01       	movw	r30, r24
    7f72:	84 a5       	lds	r24, 0x64
    7f74:	95 a5       	lds	r25, 0x65
    7f76:	a6 a5       	lds	r26, 0x66
    7f78:	b7 a5       	lds	r27, 0x67
    7f7a:	80 93 50 40 	sts	0x4050, r24
    7f7e:	90 93 51 40 	sts	0x4051, r25
    7f82:	a0 93 52 40 	sts	0x4052, r26
    7f86:	b0 93 53 40 	sts	0x4053, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    7f8a:	89 81       	ldd	r24, Y+1	; 0x01
    7f8c:	9a 81       	ldd	r25, Y+2	; 0x02
    7f8e:	fc 01       	movw	r30, r24
    7f90:	24 8d       	ldd	r18, Z+28	; 0x1c
    7f92:	35 8d       	ldd	r19, Z+29	; 0x1d
    7f94:	46 8d       	ldd	r20, Z+30	; 0x1e
    7f96:	57 8d       	ldd	r21, Z+31	; 0x1f
    7f98:	80 91 74 50 	lds	r24, 0x5074
    7f9c:	90 91 75 50 	lds	r25, 0x5075
    7fa0:	cc 01       	movw	r24, r24
    7fa2:	a0 e0       	ldi	r26, 0x00	; 0
    7fa4:	b0 e0       	ldi	r27, 0x00	; 0
    7fa6:	79 01       	movw	r14, r18
    7fa8:	8a 01       	movw	r16, r20
    7faa:	e8 0e       	add	r14, r24
    7fac:	f9 1e       	adc	r15, r25
    7fae:	0a 1f       	adc	r16, r26
    7fb0:	1b 1f       	adc	r17, r27
    7fb2:	89 81       	ldd	r24, Y+1	; 0x01
    7fb4:	9a 81       	ldd	r25, Y+2	; 0x02
    7fb6:	fc 01       	movw	r30, r24
    7fb8:	80 89       	ldd	r24, Z+16	; 0x10
    7fba:	88 2f       	mov	r24, r24
    7fbc:	90 e0       	ldi	r25, 0x00	; 0
    7fbe:	a0 e0       	ldi	r26, 0x00	; 0
    7fc0:	b0 e0       	ldi	r27, 0x00	; 0
    7fc2:	29 81       	ldd	r18, Y+1	; 0x01
    7fc4:	3a 81       	ldd	r19, Y+2	; 0x02
    7fc6:	f9 01       	movw	r30, r18
    7fc8:	24 a1       	lds	r18, 0x44
    7fca:	35 a1       	lds	r19, 0x45
    7fcc:	46 a1       	lds	r20, 0x46
    7fce:	57 a1       	lds	r21, 0x47
    7fd0:	bc 01       	movw	r22, r24
    7fd2:	cd 01       	movw	r24, r26
    7fd4:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    7fd8:	dc 01       	movw	r26, r24
    7fda:	cb 01       	movw	r24, r22
    7fdc:	8e 0d       	add	r24, r14
    7fde:	9f 1d       	adc	r25, r15
    7fe0:	a0 1f       	adc	r26, r16
    7fe2:	b1 1f       	adc	r27, r17
    7fe4:	80 93 cc 23 	sts	0x23CC, r24
    7fe8:	90 93 cd 23 	sts	0x23CD, r25
    7fec:	a0 93 ce 23 	sts	0x23CE, r26
    7ff0:	b0 93 cf 23 	sts	0x23CF, r27

dataSectors = bpb->totalSectors_F32
    7ff4:	89 81       	ldd	r24, Y+1	; 0x01
    7ff6:	9a 81       	ldd	r25, Y+2	; 0x02
    7ff8:	fc 01       	movw	r30, r24
    7ffa:	20 a1       	lds	r18, 0x40
    7ffc:	31 a1       	lds	r19, 0x41
    7ffe:	42 a1       	lds	r20, 0x42
    8000:	53 a1       	lds	r21, 0x43
              - bpb->reservedSectorCount
    8002:	89 81       	ldd	r24, Y+1	; 0x01
    8004:	9a 81       	ldd	r25, Y+2	; 0x02
    8006:	fc 01       	movw	r30, r24
    8008:	86 85       	ldd	r24, Z+14	; 0x0e
    800a:	97 85       	ldd	r25, Z+15	; 0x0f
    800c:	cc 01       	movw	r24, r24
    800e:	a0 e0       	ldi	r26, 0x00	; 0
    8010:	b0 e0       	ldi	r27, 0x00	; 0
    8012:	79 01       	movw	r14, r18
    8014:	8a 01       	movw	r16, r20
    8016:	e8 1a       	sub	r14, r24
    8018:	f9 0a       	sbc	r15, r25
    801a:	0a 0b       	sbc	r16, r26
    801c:	1b 0b       	sbc	r17, r27
              - ( bpb->numberofFATs * bpb->FATsize_F32);
    801e:	89 81       	ldd	r24, Y+1	; 0x01
    8020:	9a 81       	ldd	r25, Y+2	; 0x02
    8022:	fc 01       	movw	r30, r24
    8024:	80 89       	ldd	r24, Z+16	; 0x10
    8026:	88 2f       	mov	r24, r24
    8028:	90 e0       	ldi	r25, 0x00	; 0
    802a:	a0 e0       	ldi	r26, 0x00	; 0
    802c:	b0 e0       	ldi	r27, 0x00	; 0
    802e:	29 81       	ldd	r18, Y+1	; 0x01
    8030:	3a 81       	ldd	r19, Y+2	; 0x02
    8032:	f9 01       	movw	r30, r18
    8034:	24 a1       	lds	r18, 0x44
    8036:	35 a1       	lds	r19, 0x45
    8038:	46 a1       	lds	r20, 0x46
    803a:	57 a1       	lds	r21, 0x47
    803c:	bc 01       	movw	r22, r24
    803e:	cd 01       	movw	r24, r26
    8040:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    8044:	dc 01       	movw	r26, r24
    8046:	cb 01       	movw	r24, r22
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    8048:	a8 01       	movw	r20, r16
    804a:	97 01       	movw	r18, r14
    804c:	28 1b       	sub	r18, r24
    804e:	39 0b       	sbc	r19, r25
    8050:	4a 0b       	sbc	r20, r26
    8052:	5b 0b       	sbc	r21, r27
    8054:	da 01       	movw	r26, r20
    8056:	c9 01       	movw	r24, r18
    8058:	8f 83       	std	Y+7, r24	; 0x07
    805a:	98 87       	std	Y+8, r25	; 0x08
    805c:	a9 87       	std	Y+9, r26	; 0x09
    805e:	ba 87       	std	Y+10, r27	; 0x0a
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    8060:	80 91 6c 50 	lds	r24, 0x506C
    8064:	90 91 6d 50 	lds	r25, 0x506D
    8068:	9c 01       	movw	r18, r24
    806a:	40 e0       	ldi	r20, 0x00	; 0
    806c:	50 e0       	ldi	r21, 0x00	; 0
    806e:	8f 81       	ldd	r24, Y+7	; 0x07
    8070:	98 85       	ldd	r25, Y+8	; 0x08
    8072:	a9 85       	ldd	r26, Y+9	; 0x09
    8074:	ba 85       	ldd	r27, Y+10	; 0x0a
    8076:	bc 01       	movw	r22, r24
    8078:	cd 01       	movw	r24, r26
    807a:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    807e:	da 01       	movw	r26, r20
    8080:	c9 01       	movw	r24, r18
    8082:	80 93 4a 40 	sts	0x404A, r24
    8086:	90 93 4b 40 	sts	0x404B, r25
    808a:	a0 93 4c 40 	sts	0x404C, r26
    808e:	b0 93 4d 40 	sts	0x404D, r27


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    8092:	81 e0       	ldi	r24, 0x01	; 1
    8094:	60 e0       	ldi	r22, 0x00	; 0
    8096:	20 e0       	ldi	r18, 0x00	; 0
    8098:	30 e0       	ldi	r19, 0x00	; 0
    809a:	a9 01       	movw	r20, r18
    809c:	0e 94 4b 41 	call	0x8296	; 0x8296 <getSetFreeCluster>
    80a0:	9b 01       	movw	r18, r22
    80a2:	ac 01       	movw	r20, r24
    80a4:	80 91 4a 40 	lds	r24, 0x404A
    80a8:	90 91 4b 40 	lds	r25, 0x404B
    80ac:	a0 91 4c 40 	lds	r26, 0x404C
    80b0:	b0 91 4d 40 	lds	r27, 0x404D
    80b4:	82 17       	cp	r24, r18
    80b6:	93 07       	cpc	r25, r19
    80b8:	a4 07       	cpc	r26, r20
    80ba:	b5 07       	cpc	r27, r21
    80bc:	18 f4       	brcc	.+6      	; 0x80c4 <getBootSectorData+0x276>
     freeClusterCountUpdated = 0;
    80be:	10 92 c0 50 	sts	0x50C0, r1
    80c2:	03 c0       	rjmp	.+6      	; 0x80ca <getBootSectorData+0x27c>
else
	 freeClusterCountUpdated = 1;
    80c4:	81 e0       	ldi	r24, 0x01	; 1
    80c6:	80 93 c0 50 	sts	0x50C0, r24
return 0;
    80ca:	80 e0       	ldi	r24, 0x00	; 0
}
    80cc:	2a 96       	adiw	r28, 0x0a	; 10
    80ce:	cd bf       	out	0x3d, r28	; 61
    80d0:	de bf       	out	0x3e, r29	; 62
    80d2:	df 91       	pop	r29
    80d4:	cf 91       	pop	r28
    80d6:	1f 91       	pop	r17
    80d8:	0f 91       	pop	r16
    80da:	ff 90       	pop	r15
    80dc:	ef 90       	pop	r14
    80de:	08 95       	ret

000080e0 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    80e0:	cf 93       	push	r28
    80e2:	df 93       	push	r29
    80e4:	00 d0       	rcall	.+0      	; 0x80e6 <getFirstSector+0x6>
    80e6:	0f 92       	push	r0
    80e8:	cd b7       	in	r28, 0x3d	; 61
    80ea:	de b7       	in	r29, 0x3e	; 62
    80ec:	69 83       	std	Y+1, r22	; 0x01
    80ee:	7a 83       	std	Y+2, r23	; 0x02
    80f0:	8b 83       	std	Y+3, r24	; 0x03
    80f2:	9c 83       	std	Y+4, r25	; 0x04
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    80f4:	89 81       	ldd	r24, Y+1	; 0x01
    80f6:	9a 81       	ldd	r25, Y+2	; 0x02
    80f8:	ab 81       	ldd	r26, Y+3	; 0x03
    80fa:	bc 81       	ldd	r27, Y+4	; 0x04
    80fc:	02 97       	sbiw	r24, 0x02	; 2
    80fe:	a1 09       	sbc	r26, r1
    8100:	b1 09       	sbc	r27, r1
    8102:	20 91 6c 50 	lds	r18, 0x506C
    8106:	30 91 6d 50 	lds	r19, 0x506D
    810a:	99 01       	movw	r18, r18
    810c:	40 e0       	ldi	r20, 0x00	; 0
    810e:	50 e0       	ldi	r21, 0x00	; 0
    8110:	bc 01       	movw	r22, r24
    8112:	cd 01       	movw	r24, r26
    8114:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    8118:	9b 01       	movw	r18, r22
    811a:	ac 01       	movw	r20, r24
    811c:	80 91 cc 23 	lds	r24, 0x23CC
    8120:	90 91 cd 23 	lds	r25, 0x23CD
    8124:	a0 91 ce 23 	lds	r26, 0x23CE
    8128:	b0 91 cf 23 	lds	r27, 0x23CF
    812c:	82 0f       	add	r24, r18
    812e:	93 1f       	adc	r25, r19
    8130:	a4 1f       	adc	r26, r20
    8132:	b5 1f       	adc	r27, r21
}
    8134:	bc 01       	movw	r22, r24
    8136:	cd 01       	movw	r24, r26
    8138:	24 96       	adiw	r28, 0x04	; 4
    813a:	cd bf       	out	0x3d, r28	; 61
    813c:	de bf       	out	0x3e, r29	; 62
    813e:	df 91       	pop	r29
    8140:	cf 91       	pop	r28
    8142:	08 95       	ret

00008144 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    8144:	ef 92       	push	r14
    8146:	ff 92       	push	r15
    8148:	0f 93       	push	r16
    814a:	1f 93       	push	r17
    814c:	cf 93       	push	r28
    814e:	df 93       	push	r29
    8150:	cd b7       	in	r28, 0x3d	; 61
    8152:	de b7       	in	r29, 0x3e	; 62
    8154:	61 97       	sbiw	r28, 0x11	; 17
    8156:	cd bf       	out	0x3d, r28	; 61
    8158:	de bf       	out	0x3e, r29	; 62
    815a:	69 87       	std	Y+9, r22	; 0x09
    815c:	7a 87       	std	Y+10, r23	; 0x0a
    815e:	8b 87       	std	Y+11, r24	; 0x0b
    8160:	9c 87       	std	Y+12, r25	; 0x0c
    8162:	4d 87       	std	Y+13, r20	; 0x0d
    8164:	0e 87       	std	Y+14, r16	; 0x0e
    8166:	1f 87       	std	Y+15, r17	; 0x0f
    8168:	28 8b       	std	Y+16, r18	; 0x10
    816a:	39 8b       	std	Y+17, r19	; 0x11
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
//unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    816c:	80 91 74 50 	lds	r24, 0x5074
    8170:	90 91 75 50 	lds	r25, 0x5075
    8174:	9c 01       	movw	r18, r24
    8176:	40 e0       	ldi	r20, 0x00	; 0
    8178:	50 e0       	ldi	r21, 0x00	; 0
    817a:	80 91 6e 50 	lds	r24, 0x506E
    817e:	90 91 6f 50 	lds	r25, 0x506F
    8182:	a0 91 70 50 	lds	r26, 0x5070
    8186:	b0 91 71 50 	lds	r27, 0x5071
    818a:	79 01       	movw	r14, r18
    818c:	8a 01       	movw	r16, r20
    818e:	e8 0e       	add	r14, r24
    8190:	f9 1e       	adc	r15, r25
    8192:	0a 1f       	adc	r16, r26
    8194:	1b 1f       	adc	r17, r27
    8196:	89 85       	ldd	r24, Y+9	; 0x09
    8198:	9a 85       	ldd	r25, Y+10	; 0x0a
    819a:	ab 85       	ldd	r26, Y+11	; 0x0b
    819c:	bc 85       	ldd	r27, Y+12	; 0x0c
    819e:	88 0f       	add	r24, r24
    81a0:	99 1f       	adc	r25, r25
    81a2:	aa 1f       	adc	r26, r26
    81a4:	bb 1f       	adc	r27, r27
    81a6:	88 0f       	add	r24, r24
    81a8:	99 1f       	adc	r25, r25
    81aa:	aa 1f       	adc	r26, r26
    81ac:	bb 1f       	adc	r27, r27
    81ae:	20 91 45 40 	lds	r18, 0x4045
    81b2:	30 91 46 40 	lds	r19, 0x4046
    81b6:	99 01       	movw	r18, r18
    81b8:	40 e0       	ldi	r20, 0x00	; 0
    81ba:	50 e0       	ldi	r21, 0x00	; 0
    81bc:	bc 01       	movw	r22, r24
    81be:	cd 01       	movw	r24, r26
    81c0:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    81c4:	da 01       	movw	r26, r20
    81c6:	c9 01       	movw	r24, r18
    81c8:	8e 0d       	add	r24, r14
    81ca:	9f 1d       	adc	r25, r15
    81cc:	a0 1f       	adc	r26, r16
    81ce:	b1 1f       	adc	r27, r17
    81d0:	89 83       	std	Y+1, r24	; 0x01
    81d2:	9a 83       	std	Y+2, r25	; 0x02
    81d4:	ab 83       	std	Y+3, r26	; 0x03
    81d6:	bc 83       	std	Y+4, r27	; 0x04

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    81d8:	89 85       	ldd	r24, Y+9	; 0x09
    81da:	9a 85       	ldd	r25, Y+10	; 0x0a
    81dc:	ab 85       	ldd	r26, Y+11	; 0x0b
    81de:	bc 85       	ldd	r27, Y+12	; 0x0c
    81e0:	88 0f       	add	r24, r24
    81e2:	99 1f       	adc	r25, r25
    81e4:	aa 1f       	adc	r26, r26
    81e6:	bb 1f       	adc	r27, r27
    81e8:	88 0f       	add	r24, r24
    81ea:	99 1f       	adc	r25, r25
    81ec:	aa 1f       	adc	r26, r26
    81ee:	bb 1f       	adc	r27, r27
    81f0:	20 91 45 40 	lds	r18, 0x4045
    81f4:	30 91 46 40 	lds	r19, 0x4046
    81f8:	99 01       	movw	r18, r18
    81fa:	40 e0       	ldi	r20, 0x00	; 0
    81fc:	50 e0       	ldi	r21, 0x00	; 0
    81fe:	bc 01       	movw	r22, r24
    8200:	cd 01       	movw	r24, r26
    8202:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    8206:	dc 01       	movw	r26, r24
    8208:	cb 01       	movw	r24, r22
    820a:	8d 83       	std	Y+5, r24	; 0x05
    820c:	9e 83       	std	Y+6, r25	; 0x06

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    820e:	89 81       	ldd	r24, Y+1	; 0x01
    8210:	9a 81       	ldd	r25, Y+2	; 0x02
    8212:	ab 81       	ldd	r26, Y+3	; 0x03
    8214:	bc 81       	ldd	r27, Y+4	; 0x04
    8216:	27 ec       	ldi	r18, 0xC7	; 199
    8218:	31 e2       	ldi	r19, 0x21	; 33
    821a:	bc 01       	movw	r22, r24
    821c:	cd 01       	movw	r24, r26
    821e:	a9 01       	movw	r20, r18
    8220:	0e 94 85 4e 	call	0x9d0a	; 0x9d0a <SD_read_block>

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    8224:	8d 81       	ldd	r24, Y+5	; 0x05
    8226:	9e 81       	ldd	r25, Y+6	; 0x06
    8228:	89 53       	subi	r24, 0x39	; 57
    822a:	9e 4d       	sbci	r25, 0xDE	; 222
    822c:	8f 83       	std	Y+7, r24	; 0x07
    822e:	98 87       	std	Y+8, r25	; 0x08

if(get_set == GET)
    8230:	8d 85       	ldd	r24, Y+13	; 0x0d
    8232:	88 23       	and	r24, r24
    8234:	49 f4       	brne	.+18     	; 0x8248 <getSetNextCluster+0x104>
  return ((*FATEntryValue) & 0x0fffffff);
    8236:	8f 81       	ldd	r24, Y+7	; 0x07
    8238:	98 85       	ldd	r25, Y+8	; 0x08
    823a:	fc 01       	movw	r30, r24
    823c:	80 81       	ld	r24, Z
    823e:	91 81       	ldd	r25, Z+1	; 0x01
    8240:	a2 81       	ldd	r26, Z+2	; 0x02
    8242:	b3 81       	ldd	r27, Z+3	; 0x03
    8244:	bf 70       	andi	r27, 0x0F	; 15
    8246:	1b c0       	rjmp	.+54     	; 0x827e <getSetNextCluster+0x13a>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    8248:	2f 81       	ldd	r18, Y+7	; 0x07
    824a:	38 85       	ldd	r19, Y+8	; 0x08
    824c:	8e 85       	ldd	r24, Y+14	; 0x0e
    824e:	9f 85       	ldd	r25, Y+15	; 0x0f
    8250:	a8 89       	ldd	r26, Y+16	; 0x10
    8252:	b9 89       	ldd	r27, Y+17	; 0x11
    8254:	f9 01       	movw	r30, r18
    8256:	80 83       	st	Z, r24
    8258:	91 83       	std	Z+1, r25	; 0x01
    825a:	a2 83       	std	Z+2, r26	; 0x02
    825c:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    825e:	89 81       	ldd	r24, Y+1	; 0x01
    8260:	9a 81       	ldd	r25, Y+2	; 0x02
    8262:	ab 81       	ldd	r26, Y+3	; 0x03
    8264:	bc 81       	ldd	r27, Y+4	; 0x04
    8266:	27 ec       	ldi	r18, 0xC7	; 199
    8268:	31 e2       	ldi	r19, 0x21	; 33
    826a:	bc 01       	movw	r22, r24
    826c:	cd 01       	movw	r24, r26
    826e:	a9 01       	movw	r20, r18
    8270:	20 e0       	ldi	r18, 0x00	; 0
    8272:	32 e0       	ldi	r19, 0x02	; 2
    8274:	0e 94 b7 4d 	call	0x9b6e	; 0x9b6e <SD_write_block>

return (0);
    8278:	80 e0       	ldi	r24, 0x00	; 0
    827a:	90 e0       	ldi	r25, 0x00	; 0
    827c:	dc 01       	movw	r26, r24
}
    827e:	bc 01       	movw	r22, r24
    8280:	cd 01       	movw	r24, r26
    8282:	61 96       	adiw	r28, 0x11	; 17
    8284:	cd bf       	out	0x3d, r28	; 61
    8286:	de bf       	out	0x3e, r29	; 62
    8288:	df 91       	pop	r29
    828a:	cf 91       	pop	r28
    828c:	1f 91       	pop	r17
    828e:	0f 91       	pop	r16
    8290:	ff 90       	pop	r15
    8292:	ef 90       	pop	r14
    8294:	08 95       	ret

00008296 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    8296:	cf 93       	push	r28
    8298:	df 93       	push	r29
    829a:	cd b7       	in	r28, 0x3d	; 61
    829c:	de b7       	in	r29, 0x3e	; 62
    829e:	28 97       	sbiw	r28, 0x08	; 8
    82a0:	cd bf       	out	0x3d, r28	; 61
    82a2:	de bf       	out	0x3e, r29	; 62
    82a4:	8b 83       	std	Y+3, r24	; 0x03
    82a6:	6c 83       	std	Y+4, r22	; 0x04
    82a8:	2d 83       	std	Y+5, r18	; 0x05
    82aa:	3e 83       	std	Y+6, r19	; 0x06
    82ac:	4f 83       	std	Y+7, r20	; 0x07
    82ae:	58 87       	std	Y+8, r21	; 0x08
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;
    82b0:	87 ec       	ldi	r24, 0xC7	; 199
    82b2:	91 e2       	ldi	r25, 0x21	; 33
    82b4:	89 83       	std	Y+1, r24	; 0x01
    82b6:	9a 83       	std	Y+2, r25	; 0x02

SD_read_block(unusedSectors + 1,SDBuffer);
    82b8:	80 91 6e 50 	lds	r24, 0x506E
    82bc:	90 91 6f 50 	lds	r25, 0x506F
    82c0:	a0 91 70 50 	lds	r26, 0x5070
    82c4:	b0 91 71 50 	lds	r27, 0x5071
    82c8:	01 96       	adiw	r24, 0x01	; 1
    82ca:	a1 1d       	adc	r26, r1
    82cc:	b1 1d       	adc	r27, r1
    82ce:	27 ec       	ldi	r18, 0xC7	; 199
    82d0:	31 e2       	ldi	r19, 0x21	; 33
    82d2:	bc 01       	movw	r22, r24
    82d4:	cd 01       	movw	r24, r26
    82d6:	a9 01       	movw	r20, r18
    82d8:	0e 94 85 4e 	call	0x9d0a	; 0x9d0a <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    82dc:	89 81       	ldd	r24, Y+1	; 0x01
    82de:	9a 81       	ldd	r25, Y+2	; 0x02
    82e0:	fc 01       	movw	r30, r24
    82e2:	80 81       	ld	r24, Z
    82e4:	91 81       	ldd	r25, Z+1	; 0x01
    82e6:	a2 81       	ldd	r26, Z+2	; 0x02
    82e8:	b3 81       	ldd	r27, Z+3	; 0x03
    82ea:	82 35       	cpi	r24, 0x52	; 82
    82ec:	f2 e5       	ldi	r31, 0x52	; 82
    82ee:	9f 07       	cpc	r25, r31
    82f0:	f1 e6       	ldi	r31, 0x61	; 97
    82f2:	af 07       	cpc	r26, r31
    82f4:	f1 e4       	ldi	r31, 0x41	; 65
    82f6:	bf 07       	cpc	r27, r31
    82f8:	11 f5       	brne	.+68     	; 0x833e <getSetFreeCluster+0xa8>
    82fa:	89 81       	ldd	r24, Y+1	; 0x01
    82fc:	9a 81       	ldd	r25, Y+2	; 0x02
    82fe:	8c 51       	subi	r24, 0x1C	; 28
    8300:	9e 4f       	sbci	r25, 0xFE	; 254
    8302:	fc 01       	movw	r30, r24
    8304:	80 81       	ld	r24, Z
    8306:	91 81       	ldd	r25, Z+1	; 0x01
    8308:	a2 81       	ldd	r26, Z+2	; 0x02
    830a:	b3 81       	ldd	r27, Z+3	; 0x03
    830c:	82 37       	cpi	r24, 0x72	; 114
    830e:	f2 e7       	ldi	r31, 0x72	; 114
    8310:	9f 07       	cpc	r25, r31
    8312:	f1 e4       	ldi	r31, 0x41	; 65
    8314:	af 07       	cpc	r26, r31
    8316:	f1 e6       	ldi	r31, 0x61	; 97
    8318:	bf 07       	cpc	r27, r31
    831a:	89 f4       	brne	.+34     	; 0x833e <getSetFreeCluster+0xa8>
    831c:	89 81       	ldd	r24, Y+1	; 0x01
    831e:	9a 81       	ldd	r25, Y+2	; 0x02
    8320:	84 50       	subi	r24, 0x04	; 4
    8322:	9e 4f       	sbci	r25, 0xFE	; 254
    8324:	fc 01       	movw	r30, r24
    8326:	80 81       	ld	r24, Z
    8328:	91 81       	ldd	r25, Z+1	; 0x01
    832a:	a2 81       	ldd	r26, Z+2	; 0x02
    832c:	b3 81       	ldd	r27, Z+3	; 0x03
    832e:	80 30       	cpi	r24, 0x00	; 0
    8330:	f0 e0       	ldi	r31, 0x00	; 0
    8332:	9f 07       	cpc	r25, r31
    8334:	f5 e5       	ldi	r31, 0x55	; 85
    8336:	af 07       	cpc	r26, r31
    8338:	fa ea       	ldi	r31, 0xAA	; 170
    833a:	bf 07       	cpc	r27, r31
    833c:	21 f0       	breq	.+8      	; 0x8346 <getSetFreeCluster+0xb0>
  return 0xffffffff;
    833e:	8f ef       	ldi	r24, 0xFF	; 255
    8340:	9f ef       	ldi	r25, 0xFF	; 255
    8342:	dc 01       	movw	r26, r24
    8344:	51 c0       	rjmp	.+162    	; 0x83e8 <getSetFreeCluster+0x152>

 if(get_set == GET)
    8346:	8c 81       	ldd	r24, Y+4	; 0x04
    8348:	88 23       	and	r24, r24
    834a:	b9 f4       	brne	.+46     	; 0x837a <getSetFreeCluster+0xe4>
 {
   if(totOrNext == TOTAL_FREE)
    834c:	8b 81       	ldd	r24, Y+3	; 0x03
    834e:	81 30       	cpi	r24, 0x01	; 1
    8350:	51 f4       	brne	.+20     	; 0x8366 <getSetFreeCluster+0xd0>
      return(FS->freeClusterCount);
    8352:	89 81       	ldd	r24, Y+1	; 0x01
    8354:	9a 81       	ldd	r25, Y+2	; 0x02
    8356:	88 51       	subi	r24, 0x18	; 24
    8358:	9e 4f       	sbci	r25, 0xFE	; 254
    835a:	fc 01       	movw	r30, r24
    835c:	80 81       	ld	r24, Z
    835e:	91 81       	ldd	r25, Z+1	; 0x01
    8360:	a2 81       	ldd	r26, Z+2	; 0x02
    8362:	b3 81       	ldd	r27, Z+3	; 0x03
    8364:	41 c0       	rjmp	.+130    	; 0x83e8 <getSetFreeCluster+0x152>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    8366:	89 81       	ldd	r24, Y+1	; 0x01
    8368:	9a 81       	ldd	r25, Y+2	; 0x02
    836a:	84 51       	subi	r24, 0x14	; 20
    836c:	9e 4f       	sbci	r25, 0xFE	; 254
    836e:	fc 01       	movw	r30, r24
    8370:	80 81       	ld	r24, Z
    8372:	91 81       	ldd	r25, Z+1	; 0x01
    8374:	a2 81       	ldd	r26, Z+2	; 0x02
    8376:	b3 81       	ldd	r27, Z+3	; 0x03
    8378:	37 c0       	rjmp	.+110    	; 0x83e8 <getSetFreeCluster+0x152>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    837a:	8b 81       	ldd	r24, Y+3	; 0x03
    837c:	81 30       	cpi	r24, 0x01	; 1
    837e:	79 f4       	brne	.+30     	; 0x839e <getSetFreeCluster+0x108>
      FS->freeClusterCount = FSEntry;
    8380:	89 81       	ldd	r24, Y+1	; 0x01
    8382:	9a 81       	ldd	r25, Y+2	; 0x02
    8384:	9c 01       	movw	r18, r24
    8386:	28 51       	subi	r18, 0x18	; 24
    8388:	3e 4f       	sbci	r19, 0xFE	; 254
    838a:	8d 81       	ldd	r24, Y+5	; 0x05
    838c:	9e 81       	ldd	r25, Y+6	; 0x06
    838e:	af 81       	ldd	r26, Y+7	; 0x07
    8390:	b8 85       	ldd	r27, Y+8	; 0x08
    8392:	f9 01       	movw	r30, r18
    8394:	80 83       	st	Z, r24
    8396:	91 83       	std	Z+1, r25	; 0x01
    8398:	a2 83       	std	Z+2, r26	; 0x02
    839a:	b3 83       	std	Z+3, r27	; 0x03
    839c:	0e c0       	rjmp	.+28     	; 0x83ba <getSetFreeCluster+0x124>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    839e:	89 81       	ldd	r24, Y+1	; 0x01
    83a0:	9a 81       	ldd	r25, Y+2	; 0x02
    83a2:	9c 01       	movw	r18, r24
    83a4:	24 51       	subi	r18, 0x14	; 20
    83a6:	3e 4f       	sbci	r19, 0xFE	; 254
    83a8:	8d 81       	ldd	r24, Y+5	; 0x05
    83aa:	9e 81       	ldd	r25, Y+6	; 0x06
    83ac:	af 81       	ldd	r26, Y+7	; 0x07
    83ae:	b8 85       	ldd	r27, Y+8	; 0x08
    83b0:	f9 01       	movw	r30, r18
    83b2:	80 83       	st	Z, r24
    83b4:	91 83       	std	Z+1, r25	; 0x01
    83b6:	a2 83       	std	Z+2, r26	; 0x02
    83b8:	b3 83       	std	Z+3, r27	; 0x03
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    83ba:	80 91 6e 50 	lds	r24, 0x506E
    83be:	90 91 6f 50 	lds	r25, 0x506F
    83c2:	a0 91 70 50 	lds	r26, 0x5070
    83c6:	b0 91 71 50 	lds	r27, 0x5071
    83ca:	01 96       	adiw	r24, 0x01	; 1
    83cc:	a1 1d       	adc	r26, r1
    83ce:	b1 1d       	adc	r27, r1
    83d0:	27 ec       	ldi	r18, 0xC7	; 199
    83d2:	31 e2       	ldi	r19, 0x21	; 33
    83d4:	bc 01       	movw	r22, r24
    83d6:	cd 01       	movw	r24, r26
    83d8:	a9 01       	movw	r20, r18
    83da:	20 e0       	ldi	r18, 0x00	; 0
    83dc:	32 e0       	ldi	r19, 0x02	; 2
    83de:	0e 94 b7 4d 	call	0x9b6e	; 0x9b6e <SD_write_block>
 }
 return 0xffffffff;
    83e2:	8f ef       	ldi	r24, 0xFF	; 255
    83e4:	9f ef       	ldi	r25, 0xFF	; 255
    83e6:	dc 01       	movw	r26, r24
}
    83e8:	bc 01       	movw	r22, r24
    83ea:	cd 01       	movw	r24, r26
    83ec:	28 96       	adiw	r28, 0x08	; 8
    83ee:	cd bf       	out	0x3d, r28	; 61
    83f0:	de bf       	out	0x3e, r29	; 62
    83f2:	df 91       	pop	r29
    83f4:	cf 91       	pop	r28
    83f6:	08 95       	ret

000083f8 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    83f8:	0f 93       	push	r16
    83fa:	1f 93       	push	r17
    83fc:	cf 93       	push	r28
    83fe:	df 93       	push	r29
    8400:	cd b7       	in	r28, 0x3d	; 61
    8402:	de b7       	in	r29, 0x3e	; 62
    8404:	6c 97       	sbiw	r28, 0x1c	; 28
    8406:	cd bf       	out	0x3d, r28	; 61
    8408:	de bf       	out	0x3e, r29	; 62
    840a:	8a 8f       	std	Y+26, r24	; 0x1a
    840c:	6b 8f       	std	Y+27, r22	; 0x1b
    840e:	7c 8f       	std	Y+28, r23	; 0x1c
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    8410:	80 91 50 40 	lds	r24, 0x4050
    8414:	90 91 51 40 	lds	r25, 0x4051
    8418:	a0 91 52 40 	lds	r26, 0x4052
    841c:	b0 91 53 40 	lds	r27, 0x4053
    8420:	89 83       	std	Y+1, r24	; 0x01
    8422:	9a 83       	std	Y+2, r25	; 0x02
    8424:	ab 83       	std	Y+3, r26	; 0x03
    8426:	bc 83       	std	Y+4, r27	; 0x04
    8428:	01 c0       	rjmp	.+2      	; 0x842c <findFiles+0x34>
   if(cluster > 0x0ffffff6)
   	 return 0;
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
    842a:	00 00       	nop

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    842c:	89 81       	ldd	r24, Y+1	; 0x01
    842e:	9a 81       	ldd	r25, Y+2	; 0x02
    8430:	ab 81       	ldd	r26, Y+3	; 0x03
    8432:	bc 81       	ldd	r27, Y+4	; 0x04
    8434:	bc 01       	movw	r22, r24
    8436:	cd 01       	movw	r24, r26
    8438:	0e 94 70 40 	call	0x80e0	; 0x80e0 <getFirstSector>
    843c:	dc 01       	movw	r26, r24
    843e:	cb 01       	movw	r24, r22
    8440:	88 8b       	std	Y+16, r24	; 0x10
    8442:	99 8b       	std	Y+17, r25	; 0x11
    8444:	aa 8b       	std	Y+18, r26	; 0x12
    8446:	bb 8b       	std	Y+19, r27	; 0x13

   for(sector = 0; sector < sectorPerCluster; sector++)
    8448:	1d 82       	std	Y+5, r1	; 0x05
    844a:	1e 82       	std	Y+6, r1	; 0x06
    844c:	1f 82       	std	Y+7, r1	; 0x07
    844e:	18 86       	std	Y+8, r1	; 0x08
    8450:	68 c1       	rjmp	.+720    	; 0x8722 <findFiles+0x32a>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    8452:	28 89       	ldd	r18, Y+16	; 0x10
    8454:	39 89       	ldd	r19, Y+17	; 0x11
    8456:	4a 89       	ldd	r20, Y+18	; 0x12
    8458:	5b 89       	ldd	r21, Y+19	; 0x13
    845a:	8d 81       	ldd	r24, Y+5	; 0x05
    845c:	9e 81       	ldd	r25, Y+6	; 0x06
    845e:	af 81       	ldd	r26, Y+7	; 0x07
    8460:	b8 85       	ldd	r27, Y+8	; 0x08
    8462:	82 0f       	add	r24, r18
    8464:	93 1f       	adc	r25, r19
    8466:	a4 1f       	adc	r26, r20
    8468:	b5 1f       	adc	r27, r21
    846a:	27 ec       	ldi	r18, 0xC7	; 199
    846c:	31 e2       	ldi	r19, 0x21	; 33
    846e:	bc 01       	movw	r22, r24
    8470:	cd 01       	movw	r24, r26
    8472:	a9 01       	movw	r20, r18
    8474:	0e 94 85 4e 	call	0x9d0a	; 0x9d0a <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    8478:	1d 86       	std	Y+13, r1	; 0x0d
    847a:	1e 86       	std	Y+14, r1	; 0x0e
    847c:	3d c1       	rjmp	.+634    	; 0x86f8 <findFiles+0x300>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    847e:	8d 85       	ldd	r24, Y+13	; 0x0d
    8480:	9e 85       	ldd	r25, Y+14	; 0x0e
    8482:	89 53       	subi	r24, 0x39	; 57
    8484:	9e 4d       	sbci	r25, 0xDE	; 222
    8486:	8c 8b       	std	Y+20, r24	; 0x14
    8488:	9d 8b       	std	Y+21, r25	; 0x15

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    848a:	8c 89       	ldd	r24, Y+20	; 0x14
    848c:	9d 89       	ldd	r25, Y+21	; 0x15
    848e:	fc 01       	movw	r30, r24
    8490:	80 81       	ld	r24, Z
    8492:	88 23       	and	r24, r24
    8494:	19 f4       	brne	.+6      	; 0x849c <findFiles+0xa4>
		{
		  return 0;   
    8496:	80 e0       	ldi	r24, 0x00	; 0
    8498:	90 e0       	ldi	r25, 0x00	; 0
    849a:	80 c1       	rjmp	.+768    	; 0x879c <findFiles+0x3a4>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    849c:	8c 89       	ldd	r24, Y+20	; 0x14
    849e:	9d 89       	ldd	r25, Y+21	; 0x15
    84a0:	fc 01       	movw	r30, r24
    84a2:	80 81       	ld	r24, Z
    84a4:	85 3e       	cpi	r24, 0xE5	; 229
    84a6:	09 f4       	brne	.+2      	; 0x84aa <findFiles+0xb2>
    84a8:	22 c1       	rjmp	.+580    	; 0x86ee <findFiles+0x2f6>
    84aa:	8c 89       	ldd	r24, Y+20	; 0x14
    84ac:	9d 89       	ldd	r25, Y+21	; 0x15
    84ae:	fc 01       	movw	r30, r24
    84b0:	83 85       	ldd	r24, Z+11	; 0x0b
    84b2:	8f 30       	cpi	r24, 0x0F	; 15
    84b4:	09 f4       	brne	.+2      	; 0x84b8 <findFiles+0xc0>
    84b6:	1b c1       	rjmp	.+566    	; 0x86ee <findFiles+0x2f6>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    84b8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    84ba:	81 30       	cpi	r24, 0x01	; 1
    84bc:	21 f0       	breq	.+8      	; 0x84c6 <findFiles+0xce>
    84be:	8a 8d       	ldd	r24, Y+26	; 0x1a
    84c0:	82 30       	cpi	r24, 0x02	; 2
    84c2:	09 f0       	breq	.+2      	; 0x84c6 <findFiles+0xce>
    84c4:	11 c1       	rjmp	.+546    	; 0x86e8 <findFiles+0x2f0>
          {
            for(j=0; j<11; j++)
    84c6:	1f 86       	std	Y+15, r1	; 0x0f
    84c8:	17 c0       	rjmp	.+46     	; 0x84f8 <findFiles+0x100>
            if(dir->name[j] != fileName[j]) break;
    84ca:	8f 85       	ldd	r24, Y+15	; 0x0f
    84cc:	88 2f       	mov	r24, r24
    84ce:	90 e0       	ldi	r25, 0x00	; 0
    84d0:	2c 89       	ldd	r18, Y+20	; 0x14
    84d2:	3d 89       	ldd	r19, Y+21	; 0x15
    84d4:	82 0f       	add	r24, r18
    84d6:	93 1f       	adc	r25, r19
    84d8:	fc 01       	movw	r30, r24
    84da:	40 81       	ld	r20, Z
    84dc:	8f 85       	ldd	r24, Y+15	; 0x0f
    84de:	88 2f       	mov	r24, r24
    84e0:	90 e0       	ldi	r25, 0x00	; 0
    84e2:	2b 8d       	ldd	r18, Y+27	; 0x1b
    84e4:	3c 8d       	ldd	r19, Y+28	; 0x1c
    84e6:	82 0f       	add	r24, r18
    84e8:	93 1f       	adc	r25, r19
    84ea:	fc 01       	movw	r30, r24
    84ec:	80 81       	ld	r24, Z
    84ee:	48 17       	cp	r20, r24
    84f0:	39 f4       	brne	.+14     	; 0x8500 <findFiles+0x108>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    84f2:	8f 85       	ldd	r24, Y+15	; 0x0f
    84f4:	8f 5f       	subi	r24, 0xFF	; 255
    84f6:	8f 87       	std	Y+15, r24	; 0x0f
    84f8:	8f 85       	ldd	r24, Y+15	; 0x0f
    84fa:	8b 30       	cpi	r24, 0x0B	; 11
    84fc:	30 f3       	brcs	.-52     	; 0x84ca <findFiles+0xd2>
    84fe:	01 c0       	rjmp	.+2      	; 0x8502 <findFiles+0x10a>
            if(dir->name[j] != fileName[j]) break;
    8500:	00 00       	nop
            if(j == 11)
    8502:	8f 85       	ldd	r24, Y+15	; 0x0f
    8504:	8b 30       	cpi	r24, 0x0B	; 11
    8506:	09 f0       	breq	.+2      	; 0x850a <findFiles+0x112>
    8508:	f2 c0       	rjmp	.+484    	; 0x86ee <findFiles+0x2f6>
			{
			  if(flag == GET_FILE)
    850a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    850c:	81 30       	cpi	r24, 0x01	; 1
    850e:	09 f0       	breq	.+2      	; 0x8512 <findFiles+0x11a>
    8510:	52 c0       	rjmp	.+164    	; 0x85b6 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    8512:	28 89       	ldd	r18, Y+16	; 0x10
    8514:	39 89       	ldd	r19, Y+17	; 0x11
    8516:	4a 89       	ldd	r20, Y+18	; 0x12
    8518:	5b 89       	ldd	r21, Y+19	; 0x13
    851a:	8d 81       	ldd	r24, Y+5	; 0x05
    851c:	9e 81       	ldd	r25, Y+6	; 0x06
    851e:	af 81       	ldd	r26, Y+7	; 0x07
    8520:	b8 85       	ldd	r27, Y+8	; 0x08
    8522:	82 0f       	add	r24, r18
    8524:	93 1f       	adc	r25, r19
    8526:	a4 1f       	adc	r26, r20
    8528:	b5 1f       	adc	r27, r21
    852a:	80 93 c2 50 	sts	0x50C2, r24
    852e:	90 93 c3 50 	sts	0x50C3, r25
    8532:	a0 93 c4 50 	sts	0x50C4, r26
    8536:	b0 93 c5 50 	sts	0x50C5, r27
				appendFileLocation = i;
    853a:	8d 85       	ldd	r24, Y+13	; 0x0d
    853c:	9e 85       	ldd	r25, Y+14	; 0x0e
    853e:	cc 01       	movw	r24, r24
    8540:	a0 e0       	ldi	r26, 0x00	; 0
    8542:	b0 e0       	ldi	r27, 0x00	; 0
    8544:	80 93 c8 23 	sts	0x23C8, r24
    8548:	90 93 c9 23 	sts	0x23C9, r25
    854c:	a0 93 ca 23 	sts	0x23CA, r26
    8550:	b0 93 cb 23 	sts	0x23CB, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8554:	8c 89       	ldd	r24, Y+20	; 0x14
    8556:	9d 89       	ldd	r25, Y+21	; 0x15
    8558:	fc 01       	movw	r30, r24
    855a:	84 89       	ldd	r24, Z+20	; 0x14
    855c:	95 89       	ldd	r25, Z+21	; 0x15
    855e:	cc 01       	movw	r24, r24
    8560:	a0 e0       	ldi	r26, 0x00	; 0
    8562:	b0 e0       	ldi	r27, 0x00	; 0
    8564:	ac 01       	movw	r20, r24
    8566:	33 27       	eor	r19, r19
    8568:	22 27       	eor	r18, r18
    856a:	8c 89       	ldd	r24, Y+20	; 0x14
    856c:	9d 89       	ldd	r25, Y+21	; 0x15
    856e:	fc 01       	movw	r30, r24
    8570:	82 8d       	ldd	r24, Z+26	; 0x1a
    8572:	93 8d       	ldd	r25, Z+27	; 0x1b
    8574:	cc 01       	movw	r24, r24
    8576:	a0 e0       	ldi	r26, 0x00	; 0
    8578:	b0 e0       	ldi	r27, 0x00	; 0
    857a:	82 2b       	or	r24, r18
    857c:	93 2b       	or	r25, r19
    857e:	a4 2b       	or	r26, r20
    8580:	b5 2b       	or	r27, r21
    8582:	80 93 78 50 	sts	0x5078, r24
    8586:	90 93 79 50 	sts	0x5079, r25
    858a:	a0 93 7a 50 	sts	0x507A, r26
    858e:	b0 93 7b 50 	sts	0x507B, r27
				fileSize = dir->fileSize;
    8592:	8c 89       	ldd	r24, Y+20	; 0x14
    8594:	9d 89       	ldd	r25, Y+21	; 0x15
    8596:	fc 01       	movw	r30, r24
    8598:	84 8d       	ldd	r24, Z+28	; 0x1c
    859a:	95 8d       	ldd	r25, Z+29	; 0x1d
    859c:	a6 8d       	ldd	r26, Z+30	; 0x1e
    859e:	b7 8d       	ldd	r27, Z+31	; 0x1f
    85a0:	80 93 41 40 	sts	0x4041, r24
    85a4:	90 93 42 40 	sts	0x4042, r25
    85a8:	a0 93 43 40 	sts	0x4043, r26
    85ac:	b0 93 44 40 	sts	0x4044, r27
			    return (dir);
    85b0:	8c 89       	ldd	r24, Y+20	; 0x14
    85b2:	9d 89       	ldd	r25, Y+21	; 0x15
    85b4:	f3 c0       	rjmp	.+486    	; 0x879c <findFiles+0x3a4>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    85b6:	8c 89       	ldd	r24, Y+20	; 0x14
    85b8:	9d 89       	ldd	r25, Y+21	; 0x15
    85ba:	fc 01       	movw	r30, r24
    85bc:	84 89       	ldd	r24, Z+20	; 0x14
    85be:	95 89       	ldd	r25, Z+21	; 0x15
    85c0:	cc 01       	movw	r24, r24
    85c2:	a0 e0       	ldi	r26, 0x00	; 0
    85c4:	b0 e0       	ldi	r27, 0x00	; 0
    85c6:	ac 01       	movw	r20, r24
    85c8:	33 27       	eor	r19, r19
    85ca:	22 27       	eor	r18, r18
    85cc:	8c 89       	ldd	r24, Y+20	; 0x14
    85ce:	9d 89       	ldd	r25, Y+21	; 0x15
    85d0:	fc 01       	movw	r30, r24
    85d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    85d4:	93 8d       	ldd	r25, Z+27	; 0x1b
    85d6:	cc 01       	movw	r24, r24
    85d8:	a0 e0       	ldi	r26, 0x00	; 0
    85da:	b0 e0       	ldi	r27, 0x00	; 0
    85dc:	82 2b       	or	r24, r18
    85de:	93 2b       	or	r25, r19
    85e0:	a4 2b       	or	r26, r20
    85e2:	b5 2b       	or	r27, r21
    85e4:	89 87       	std	Y+9, r24	; 0x09
    85e6:	9a 87       	std	Y+10, r25	; 0x0a
    85e8:	ab 87       	std	Y+11, r26	; 0x0b
    85ea:	bc 87       	std	Y+12, r27	; 0x0c
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    85ec:	8c 89       	ldd	r24, Y+20	; 0x14
    85ee:	9d 89       	ldd	r25, Y+21	; 0x15
    85f0:	25 ee       	ldi	r18, 0xE5	; 229
    85f2:	fc 01       	movw	r30, r24
    85f4:	20 83       	st	Z, r18
				 SD_write_block (firstSector+sector,SDBuffer,512);
    85f6:	28 89       	ldd	r18, Y+16	; 0x10
    85f8:	39 89       	ldd	r19, Y+17	; 0x11
    85fa:	4a 89       	ldd	r20, Y+18	; 0x12
    85fc:	5b 89       	ldd	r21, Y+19	; 0x13
    85fe:	8d 81       	ldd	r24, Y+5	; 0x05
    8600:	9e 81       	ldd	r25, Y+6	; 0x06
    8602:	af 81       	ldd	r26, Y+7	; 0x07
    8604:	b8 85       	ldd	r27, Y+8	; 0x08
    8606:	82 0f       	add	r24, r18
    8608:	93 1f       	adc	r25, r19
    860a:	a4 1f       	adc	r26, r20
    860c:	b5 1f       	adc	r27, r21
    860e:	27 ec       	ldi	r18, 0xC7	; 199
    8610:	31 e2       	ldi	r19, 0x21	; 33
    8612:	bc 01       	movw	r22, r24
    8614:	cd 01       	movw	r24, r26
    8616:	a9 01       	movw	r20, r18
    8618:	20 e0       	ldi	r18, 0x00	; 0
    861a:	32 e0       	ldi	r19, 0x02	; 2
    861c:	0e 94 b7 4d 	call	0x9b6e	; 0x9b6e <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    8620:	8c 89       	ldd	r24, Y+20	; 0x14
    8622:	9d 89       	ldd	r25, Y+21	; 0x15
    8624:	fc 01       	movw	r30, r24
    8626:	24 8d       	ldd	r18, Z+28	; 0x1c
    8628:	35 8d       	ldd	r19, Z+29	; 0x1d
    862a:	46 8d       	ldd	r20, Z+30	; 0x1e
    862c:	57 8d       	ldd	r21, Z+31	; 0x1f
    862e:	80 e0       	ldi	r24, 0x00	; 0
    8630:	ba 01       	movw	r22, r20
    8632:	a9 01       	movw	r20, r18
    8634:	0e 94 58 4a 	call	0x94b0	; 0x94b0 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    8638:	82 e0       	ldi	r24, 0x02	; 2
    863a:	60 e0       	ldi	r22, 0x00	; 0
    863c:	20 e0       	ldi	r18, 0x00	; 0
    863e:	30 e0       	ldi	r19, 0x00	; 0
    8640:	a9 01       	movw	r20, r18
    8642:	0e 94 4b 41 	call	0x8296	; 0x8296 <getSetFreeCluster>
    8646:	dc 01       	movw	r26, r24
    8648:	cb 01       	movw	r24, r22
    864a:	89 83       	std	Y+1, r24	; 0x01
    864c:	9a 83       	std	Y+2, r25	; 0x02
    864e:	ab 83       	std	Y+3, r26	; 0x03
    8650:	bc 83       	std	Y+4, r27	; 0x04
				 if(firstCluster < cluster)
    8652:	29 85       	ldd	r18, Y+9	; 0x09
    8654:	3a 85       	ldd	r19, Y+10	; 0x0a
    8656:	4b 85       	ldd	r20, Y+11	; 0x0b
    8658:	5c 85       	ldd	r21, Y+12	; 0x0c
    865a:	89 81       	ldd	r24, Y+1	; 0x01
    865c:	9a 81       	ldd	r25, Y+2	; 0x02
    865e:	ab 81       	ldd	r26, Y+3	; 0x03
    8660:	bc 81       	ldd	r27, Y+4	; 0x04
    8662:	28 17       	cp	r18, r24
    8664:	39 07       	cpc	r19, r25
    8666:	4a 07       	cpc	r20, r26
    8668:	5b 07       	cpc	r21, r27
    866a:	40 f4       	brcc	.+16     	; 0x867c <findFiles+0x284>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    866c:	29 85       	ldd	r18, Y+9	; 0x09
    866e:	3a 85       	ldd	r19, Y+10	; 0x0a
    8670:	4b 85       	ldd	r20, Y+11	; 0x0b
    8672:	5c 85       	ldd	r21, Y+12	; 0x0c
    8674:	82 e0       	ldi	r24, 0x02	; 2
    8676:	61 e0       	ldi	r22, 0x01	; 1
    8678:	0e 94 4b 41 	call	0x8296	; 0x8296 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    867c:	89 85       	ldd	r24, Y+9	; 0x09
    867e:	9a 85       	ldd	r25, Y+10	; 0x0a
    8680:	ab 85       	ldd	r26, Y+11	; 0x0b
    8682:	bc 85       	ldd	r27, Y+12	; 0x0c
    8684:	bc 01       	movw	r22, r24
    8686:	cd 01       	movw	r24, r26
    8688:	40 e0       	ldi	r20, 0x00	; 0
    868a:	00 e0       	ldi	r16, 0x00	; 0
    868c:	10 e0       	ldi	r17, 0x00	; 0
    868e:	98 01       	movw	r18, r16
    8690:	0e 94 a2 40 	call	0x8144	; 0x8144 <getSetNextCluster>
    8694:	dc 01       	movw	r26, r24
    8696:	cb 01       	movw	r24, r22
    8698:	8e 8b       	std	Y+22, r24	; 0x16
    869a:	9f 8b       	std	Y+23, r25	; 0x17
    869c:	a8 8f       	std	Y+24, r26	; 0x18
    869e:	b9 8f       	std	Y+25, r27	; 0x19
					getSetNextCluster (firstCluster, SET, 0);
    86a0:	89 85       	ldd	r24, Y+9	; 0x09
    86a2:	9a 85       	ldd	r25, Y+10	; 0x0a
    86a4:	ab 85       	ldd	r26, Y+11	; 0x0b
    86a6:	bc 85       	ldd	r27, Y+12	; 0x0c
    86a8:	bc 01       	movw	r22, r24
    86aa:	cd 01       	movw	r24, r26
    86ac:	41 e0       	ldi	r20, 0x01	; 1
    86ae:	00 e0       	ldi	r16, 0x00	; 0
    86b0:	10 e0       	ldi	r17, 0x00	; 0
    86b2:	98 01       	movw	r18, r16
    86b4:	0e 94 a2 40 	call	0x8144	; 0x8144 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    86b8:	8e 89       	ldd	r24, Y+22	; 0x16
    86ba:	9f 89       	ldd	r25, Y+23	; 0x17
    86bc:	a8 8d       	ldd	r26, Y+24	; 0x18
    86be:	b9 8d       	ldd	r27, Y+25	; 0x19
    86c0:	87 3f       	cpi	r24, 0xF7	; 247
    86c2:	ff ef       	ldi	r31, 0xFF	; 255
    86c4:	9f 07       	cpc	r25, r31
    86c6:	ff ef       	ldi	r31, 0xFF	; 255
    86c8:	af 07       	cpc	r26, r31
    86ca:	ff e0       	ldi	r31, 0x0F	; 15
    86cc:	bf 07       	cpc	r27, r31
    86ce:	18 f0       	brcs	.+6      	; 0x86d6 <findFiles+0x2de>
					   {//file deleted
						   return 0;}
    86d0:	80 e0       	ldi	r24, 0x00	; 0
    86d2:	90 e0       	ldi	r25, 0x00	; 0
    86d4:	63 c0       	rjmp	.+198    	; 0x879c <findFiles+0x3a4>
					firstCluster = nextCluster;
    86d6:	8e 89       	ldd	r24, Y+22	; 0x16
    86d8:	9f 89       	ldd	r25, Y+23	; 0x17
    86da:	a8 8d       	ldd	r26, Y+24	; 0x18
    86dc:	b9 8d       	ldd	r27, Y+25	; 0x19
    86de:	89 87       	std	Y+9, r24	; 0x09
    86e0:	9a 87       	std	Y+10, r25	; 0x0a
    86e2:	ab 87       	std	Y+11, r26	; 0x0b
    86e4:	bc 87       	std	Y+12, r27	; 0x0c
			  	 } 
    86e6:	ca cf       	rjmp	.-108    	; 0x867c <findFiles+0x284>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    86e8:	80 e0       	ldi	r24, 0x00	; 0
    86ea:	90 e0       	ldi	r25, 0x00	; 0
    86ec:	57 c0       	rjmp	.+174    	; 0x879c <findFiles+0x3a4>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    86ee:	8d 85       	ldd	r24, Y+13	; 0x0d
    86f0:	9e 85       	ldd	r25, Y+14	; 0x0e
    86f2:	80 96       	adiw	r24, 0x20	; 32
    86f4:	8d 87       	std	Y+13, r24	; 0x0d
    86f6:	9e 87       	std	Y+14, r25	; 0x0e
    86f8:	80 91 45 40 	lds	r24, 0x4045
    86fc:	90 91 46 40 	lds	r25, 0x4046
    8700:	2d 85       	ldd	r18, Y+13	; 0x0d
    8702:	3e 85       	ldd	r19, Y+14	; 0x0e
    8704:	28 17       	cp	r18, r24
    8706:	39 07       	cpc	r19, r25
    8708:	08 f4       	brcc	.+2      	; 0x870c <findFiles+0x314>
    870a:	b9 ce       	rjmp	.-654    	; 0x847e <findFiles+0x86>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    870c:	8d 81       	ldd	r24, Y+5	; 0x05
    870e:	9e 81       	ldd	r25, Y+6	; 0x06
    8710:	af 81       	ldd	r26, Y+7	; 0x07
    8712:	b8 85       	ldd	r27, Y+8	; 0x08
    8714:	01 96       	adiw	r24, 0x01	; 1
    8716:	a1 1d       	adc	r26, r1
    8718:	b1 1d       	adc	r27, r1
    871a:	8d 83       	std	Y+5, r24	; 0x05
    871c:	9e 83       	std	Y+6, r25	; 0x06
    871e:	af 83       	std	Y+7, r26	; 0x07
    8720:	b8 87       	std	Y+8, r27	; 0x08
    8722:	80 91 6c 50 	lds	r24, 0x506C
    8726:	90 91 6d 50 	lds	r25, 0x506D
    872a:	9c 01       	movw	r18, r24
    872c:	40 e0       	ldi	r20, 0x00	; 0
    872e:	50 e0       	ldi	r21, 0x00	; 0
    8730:	8d 81       	ldd	r24, Y+5	; 0x05
    8732:	9e 81       	ldd	r25, Y+6	; 0x06
    8734:	af 81       	ldd	r26, Y+7	; 0x07
    8736:	b8 85       	ldd	r27, Y+8	; 0x08
    8738:	82 17       	cp	r24, r18
    873a:	93 07       	cpc	r25, r19
    873c:	a4 07       	cpc	r26, r20
    873e:	b5 07       	cpc	r27, r21
    8740:	08 f4       	brcc	.+2      	; 0x8744 <findFiles+0x34c>
    8742:	87 ce       	rjmp	.-754    	; 0x8452 <findFiles+0x5a>
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    8744:	89 81       	ldd	r24, Y+1	; 0x01
    8746:	9a 81       	ldd	r25, Y+2	; 0x02
    8748:	ab 81       	ldd	r26, Y+3	; 0x03
    874a:	bc 81       	ldd	r27, Y+4	; 0x04
    874c:	bc 01       	movw	r22, r24
    874e:	cd 01       	movw	r24, r26
    8750:	40 e0       	ldi	r20, 0x00	; 0
    8752:	00 e0       	ldi	r16, 0x00	; 0
    8754:	10 e0       	ldi	r17, 0x00	; 0
    8756:	98 01       	movw	r18, r16
    8758:	0e 94 a2 40 	call	0x8144	; 0x8144 <getSetNextCluster>
    875c:	dc 01       	movw	r26, r24
    875e:	cb 01       	movw	r24, r22
    8760:	89 83       	std	Y+1, r24	; 0x01
    8762:	9a 83       	std	Y+2, r25	; 0x02
    8764:	ab 83       	std	Y+3, r26	; 0x03
    8766:	bc 83       	std	Y+4, r27	; 0x04

   if(cluster > 0x0ffffff6)
    8768:	89 81       	ldd	r24, Y+1	; 0x01
    876a:	9a 81       	ldd	r25, Y+2	; 0x02
    876c:	ab 81       	ldd	r26, Y+3	; 0x03
    876e:	bc 81       	ldd	r27, Y+4	; 0x04
    8770:	87 3f       	cpi	r24, 0xF7	; 247
    8772:	2f ef       	ldi	r18, 0xFF	; 255
    8774:	92 07       	cpc	r25, r18
    8776:	2f ef       	ldi	r18, 0xFF	; 255
    8778:	a2 07       	cpc	r26, r18
    877a:	2f e0       	ldi	r18, 0x0F	; 15
    877c:	b2 07       	cpc	r27, r18
    877e:	18 f0       	brcs	.+6      	; 0x8786 <findFiles+0x38e>
   	 return 0;
    8780:	80 e0       	ldi	r24, 0x00	; 0
    8782:	90 e0       	ldi	r25, 0x00	; 0
    8784:	0b c0       	rjmp	.+22     	; 0x879c <findFiles+0x3a4>
   if(cluster == 0) 
    8786:	89 81       	ldd	r24, Y+1	; 0x01
    8788:	9a 81       	ldd	r25, Y+2	; 0x02
    878a:	ab 81       	ldd	r26, Y+3	; 0x03
    878c:	bc 81       	ldd	r27, Y+4	; 0x04
    878e:	00 97       	sbiw	r24, 0x00	; 0
    8790:	a1 05       	cpc	r26, r1
    8792:	b1 05       	cpc	r27, r1
    8794:	09 f0       	breq	.+2      	; 0x8798 <findFiles+0x3a0>
    8796:	49 ce       	rjmp	.-878    	; 0x842a <findFiles+0x32>
   {//error in getting cluster
	   return 0;}
    8798:	80 e0       	ldi	r24, 0x00	; 0
    879a:	90 e0       	ldi	r25, 0x00	; 0
 }
return 0;
}
    879c:	6c 96       	adiw	r28, 0x1c	; 28
    879e:	cd bf       	out	0x3d, r28	; 61
    87a0:	de bf       	out	0x3e, r29	; 62
    87a2:	df 91       	pop	r29
    87a4:	cf 91       	pop	r28
    87a6:	1f 91       	pop	r17
    87a8:	0f 91       	pop	r16
    87aa:	08 95       	ret

000087ac <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    87ac:	0f 93       	push	r16
    87ae:	1f 93       	push	r17
    87b0:	cf 93       	push	r28
    87b2:	df 93       	push	r29
    87b4:	cd b7       	in	r28, 0x3d	; 61
    87b6:	de b7       	in	r29, 0x3e	; 62
    87b8:	2f 97       	sbiw	r28, 0x0f	; 15
    87ba:	cd bf       	out	0x3d, r28	; 61
    87bc:	de bf       	out	0x3e, r29	; 62
    87be:	8d 87       	std	Y+13, r24	; 0x0d
    87c0:	6e 87       	std	Y+14, r22	; 0x0e
    87c2:	7f 87       	std	Y+15, r23	; 0x0f
unsigned long cluster, firstSector;
//unsigned long byteCounter;
//unsigned long  fileSize;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    87c4:	8e 85       	ldd	r24, Y+14	; 0x0e
    87c6:	9f 85       	ldd	r25, Y+15	; 0x0f
    87c8:	0e 94 76 44 	call	0x88ec	; 0x88ec <convertFileName>
    87cc:	8e 83       	std	Y+6, r24	; 0x06
if(error) return 2;
    87ce:	8e 81       	ldd	r24, Y+6	; 0x06
    87d0:	88 23       	and	r24, r24
    87d2:	11 f0       	breq	.+4      	; 0x87d8 <readFile+0x2c>
    87d4:	82 e0       	ldi	r24, 0x02	; 2
    87d6:	82 c0       	rjmp	.+260    	; 0x88dc <readFile+0x130>

dir = findFiles (GET_FILE, Filename); //get the file location
    87d8:	2c ea       	ldi	r18, 0xAC	; 172
    87da:	30 e5       	ldi	r19, 0x50	; 80
    87dc:	81 e0       	ldi	r24, 0x01	; 1
    87de:	b9 01       	movw	r22, r18
    87e0:	0e 94 fc 41 	call	0x83f8	; 0x83f8 <findFiles>
    87e4:	8f 83       	std	Y+7, r24	; 0x07
    87e6:	98 87       	std	Y+8, r25	; 0x08
if(dir == 0) 
    87e8:	8f 81       	ldd	r24, Y+7	; 0x07
    87ea:	98 85       	ldd	r25, Y+8	; 0x08
    87ec:	00 97       	sbiw	r24, 0x00	; 0
    87ee:	39 f4       	brne	.+14     	; 0x87fe <readFile+0x52>
{
  if(flag == READ) return (1);
    87f0:	8d 85       	ldd	r24, Y+13	; 0x0d
    87f2:	88 23       	and	r24, r24
    87f4:	11 f4       	brne	.+4      	; 0x87fa <readFile+0x4e>
    87f6:	81 e0       	ldi	r24, 0x01	; 1
    87f8:	71 c0       	rjmp	.+226    	; 0x88dc <readFile+0x130>
  else return (0);
    87fa:	80 e0       	ldi	r24, 0x00	; 0
    87fc:	6f c0       	rjmp	.+222    	; 0x88dc <readFile+0x130>
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    87fe:	8d 85       	ldd	r24, Y+13	; 0x0d
    8800:	81 30       	cpi	r24, 0x01	; 1
    8802:	11 f4       	brne	.+4      	; 0x8808 <readFile+0x5c>
    8804:	81 e0       	ldi	r24, 0x01	; 1
    8806:	6a c0       	rjmp	.+212    	; 0x88dc <readFile+0x130>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8808:	8f 81       	ldd	r24, Y+7	; 0x07
    880a:	98 85       	ldd	r25, Y+8	; 0x08
    880c:	fc 01       	movw	r30, r24
    880e:	84 89       	ldd	r24, Z+20	; 0x14
    8810:	95 89       	ldd	r25, Z+21	; 0x15
    8812:	cc 01       	movw	r24, r24
    8814:	a0 e0       	ldi	r26, 0x00	; 0
    8816:	b0 e0       	ldi	r27, 0x00	; 0
    8818:	ac 01       	movw	r20, r24
    881a:	33 27       	eor	r19, r19
    881c:	22 27       	eor	r18, r18
    881e:	8f 81       	ldd	r24, Y+7	; 0x07
    8820:	98 85       	ldd	r25, Y+8	; 0x08
    8822:	fc 01       	movw	r30, r24
    8824:	82 8d       	ldd	r24, Z+26	; 0x1a
    8826:	93 8d       	ldd	r25, Z+27	; 0x1b
    8828:	cc 01       	movw	r24, r24
    882a:	a0 e0       	ldi	r26, 0x00	; 0
    882c:	b0 e0       	ldi	r27, 0x00	; 0
    882e:	82 2b       	or	r24, r18
    8830:	93 2b       	or	r25, r19
    8832:	a4 2b       	or	r26, r20
    8834:	b5 2b       	or	r27, r21
    8836:	89 83       	std	Y+1, r24	; 0x01
    8838:	9a 83       	std	Y+2, r25	; 0x02
    883a:	ab 83       	std	Y+3, r26	; 0x03
    883c:	bc 83       	std	Y+4, r27	; 0x04
    883e:	01 c0       	rjmp	.+2      	; 0x8842 <readFile+0x96>
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
    8840:	00 00       	nop
//fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    8842:	89 81       	ldd	r24, Y+1	; 0x01
    8844:	9a 81       	ldd	r25, Y+2	; 0x02
    8846:	ab 81       	ldd	r26, Y+3	; 0x03
    8848:	bc 81       	ldd	r27, Y+4	; 0x04
    884a:	bc 01       	movw	r22, r24
    884c:	cd 01       	movw	r24, r26
    884e:	0e 94 70 40 	call	0x80e0	; 0x80e0 <getFirstSector>
    8852:	dc 01       	movw	r26, r24
    8854:	cb 01       	movw	r24, r22
    8856:	89 87       	std	Y+9, r24	; 0x09
    8858:	9a 87       	std	Y+10, r25	; 0x0a
    885a:	ab 87       	std	Y+11, r26	; 0x0b
    885c:	bc 87       	std	Y+12, r27	; 0x0c

  for(j=0; j<sectorPerCluster; j++)
    885e:	1d 82       	std	Y+5, r1	; 0x05
    8860:	17 c0       	rjmp	.+46     	; 0x8890 <readFile+0xe4>
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    8862:	8d 81       	ldd	r24, Y+5	; 0x05
    8864:	28 2f       	mov	r18, r24
    8866:	30 e0       	ldi	r19, 0x00	; 0
    8868:	40 e0       	ldi	r20, 0x00	; 0
    886a:	50 e0       	ldi	r21, 0x00	; 0
    886c:	89 85       	ldd	r24, Y+9	; 0x09
    886e:	9a 85       	ldd	r25, Y+10	; 0x0a
    8870:	ab 85       	ldd	r26, Y+11	; 0x0b
    8872:	bc 85       	ldd	r27, Y+12	; 0x0c
    8874:	82 0f       	add	r24, r18
    8876:	93 1f       	adc	r25, r19
    8878:	a4 1f       	adc	r26, r20
    887a:	b5 1f       	adc	r27, r21
    887c:	20 ed       	ldi	r18, 0xD0	; 208
    887e:	33 e2       	ldi	r19, 0x23	; 35
    8880:	bc 01       	movw	r22, r24
    8882:	cd 01       	movw	r24, r26
    8884:	a9 01       	movw	r20, r18
    8886:	0e 94 85 4e 	call	0x9d0a	; 0x9d0a <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    888a:	8d 81       	ldd	r24, Y+5	; 0x05
    888c:	8f 5f       	subi	r24, 0xFF	; 255
    888e:	8d 83       	std	Y+5, r24	; 0x05
    8890:	8d 81       	ldd	r24, Y+5	; 0x05
    8892:	28 2f       	mov	r18, r24
    8894:	30 e0       	ldi	r19, 0x00	; 0
    8896:	80 91 6c 50 	lds	r24, 0x506C
    889a:	90 91 6d 50 	lds	r25, 0x506D
    889e:	28 17       	cp	r18, r24
    88a0:	39 07       	cpc	r19, r25
    88a2:	f8 f2       	brcs	.-66     	; 0x8862 <readFile+0xb6>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    88a4:	89 81       	ldd	r24, Y+1	; 0x01
    88a6:	9a 81       	ldd	r25, Y+2	; 0x02
    88a8:	ab 81       	ldd	r26, Y+3	; 0x03
    88aa:	bc 81       	ldd	r27, Y+4	; 0x04
    88ac:	bc 01       	movw	r22, r24
    88ae:	cd 01       	movw	r24, r26
    88b0:	40 e0       	ldi	r20, 0x00	; 0
    88b2:	00 e0       	ldi	r16, 0x00	; 0
    88b4:	10 e0       	ldi	r17, 0x00	; 0
    88b6:	98 01       	movw	r18, r16
    88b8:	0e 94 a2 40 	call	0x8144	; 0x8144 <getSetNextCluster>
    88bc:	dc 01       	movw	r26, r24
    88be:	cb 01       	movw	r24, r22
    88c0:	89 83       	std	Y+1, r24	; 0x01
    88c2:	9a 83       	std	Y+2, r25	; 0x02
    88c4:	ab 83       	std	Y+3, r26	; 0x03
    88c6:	bc 83       	std	Y+4, r27	; 0x04
  if(cluster == 0) {//Error in getting cluster
    88c8:	89 81       	ldd	r24, Y+1	; 0x01
    88ca:	9a 81       	ldd	r25, Y+2	; 0x02
    88cc:	ab 81       	ldd	r26, Y+3	; 0x03
    88ce:	bc 81       	ldd	r27, Y+4	; 0x04
    88d0:	00 97       	sbiw	r24, 0x00	; 0
    88d2:	a1 05       	cpc	r26, r1
    88d4:	b1 05       	cpc	r27, r1
    88d6:	09 f0       	breq	.+2      	; 0x88da <readFile+0x12e>
    88d8:	b3 cf       	rjmp	.-154    	; 0x8840 <readFile+0x94>
	  return 0;}
    88da:	80 e0       	ldi	r24, 0x00	; 0
}
return 0;
}
    88dc:	2f 96       	adiw	r28, 0x0f	; 15
    88de:	cd bf       	out	0x3d, r28	; 61
    88e0:	de bf       	out	0x3e, r29	; 62
    88e2:	df 91       	pop	r29
    88e4:	cf 91       	pop	r28
    88e6:	1f 91       	pop	r17
    88e8:	0f 91       	pop	r16
    88ea:	08 95       	ret

000088ec <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    88ec:	cf 93       	push	r28
    88ee:	df 93       	push	r29
    88f0:	cd b7       	in	r28, 0x3d	; 61
    88f2:	de b7       	in	r29, 0x3e	; 62
    88f4:	62 97       	sbiw	r28, 0x12	; 18
    88f6:	cd bf       	out	0x3d, r28	; 61
    88f8:	de bf       	out	0x3e, r29	; 62
    88fa:	89 8b       	std	Y+17, r24	; 0x11
    88fc:	9a 8b       	std	Y+18, r25	; 0x12
bool NoExtension = FALSE;
    88fe:	19 82       	std	Y+1, r1	; 0x01
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
    8900:	89 89       	ldd	r24, Y+17	; 0x11
    8902:	9a 89       	ldd	r25, Y+18	; 0x12
    8904:	9c 01       	movw	r18, r24
    8906:	f9 01       	movw	r30, r18
    8908:	01 90       	ld	r0, Z+
    890a:	00 20       	and	r0, r0
    890c:	e9 f7       	brne	.-6      	; 0x8908 <convertFileName+0x1c>
    890e:	cf 01       	movw	r24, r30
    8910:	01 97       	sbiw	r24, 0x01	; 1
    8912:	82 1b       	sub	r24, r18
    8914:	93 0b       	sbc	r25, r19
    8916:	80 31       	cpi	r24, 0x10	; 16
    8918:	91 05       	cpc	r25, r1
    891a:	10 f0       	brcs	.+4      	; 0x8920 <convertFileName+0x34>
    891c:	81 e0       	ldi	r24, 0x01	; 1
    891e:	16 c1       	rjmp	.+556    	; 0x8b4c <convertFileName+0x260>
int i=0;
    8920:	1c 82       	std	Y+4, r1	; 0x04
    8922:	1d 82       	std	Y+5, r1	; 0x05
for(; i < strlen((const char*)fileName); i++){
    8924:	13 c0       	rjmp	.+38     	; 0x894c <convertFileName+0x60>
	Filename[i] = fileName[i];
    8926:	8c 81       	ldd	r24, Y+4	; 0x04
    8928:	9d 81       	ldd	r25, Y+5	; 0x05
    892a:	29 89       	ldd	r18, Y+17	; 0x11
    892c:	3a 89       	ldd	r19, Y+18	; 0x12
    892e:	82 0f       	add	r24, r18
    8930:	93 1f       	adc	r25, r19
    8932:	fc 01       	movw	r30, r24
    8934:	20 81       	ld	r18, Z
    8936:	8c 81       	ldd	r24, Y+4	; 0x04
    8938:	9d 81       	ldd	r25, Y+5	; 0x05
    893a:	84 55       	subi	r24, 0x54	; 84
    893c:	9f 4a       	sbci	r25, 0xAF	; 175
    893e:	fc 01       	movw	r30, r24
    8940:	20 83       	st	Z, r18

//store the string variable into the file name array if it is of a proper length

if(strlen((const char*)fileName) > 15) return 1;
int i=0;
for(; i < strlen((const char*)fileName); i++){
    8942:	8c 81       	ldd	r24, Y+4	; 0x04
    8944:	9d 81       	ldd	r25, Y+5	; 0x05
    8946:	01 96       	adiw	r24, 0x01	; 1
    8948:	8c 83       	std	Y+4, r24	; 0x04
    894a:	9d 83       	std	Y+5, r25	; 0x05
    894c:	4c 81       	ldd	r20, Y+4	; 0x04
    894e:	5d 81       	ldd	r21, Y+5	; 0x05
    8950:	89 89       	ldd	r24, Y+17	; 0x11
    8952:	9a 89       	ldd	r25, Y+18	; 0x12
    8954:	9c 01       	movw	r18, r24
    8956:	f9 01       	movw	r30, r18
    8958:	01 90       	ld	r0, Z+
    895a:	00 20       	and	r0, r0
    895c:	e9 f7       	brne	.-6      	; 0x8958 <convertFileName+0x6c>
    895e:	cf 01       	movw	r24, r30
    8960:	01 97       	sbiw	r24, 0x01	; 1
    8962:	82 1b       	sub	r24, r18
    8964:	93 0b       	sbc	r25, r19
    8966:	48 17       	cp	r20, r24
    8968:	59 07       	cpc	r21, r25
    896a:	e8 f2       	brcs	.-70     	; 0x8926 <convertFileName+0x3a>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    896c:	0c c0       	rjmp	.+24     	; 0x8986 <convertFileName+0x9a>
    896e:	8c 81       	ldd	r24, Y+4	; 0x04
    8970:	9d 81       	ldd	r25, Y+5	; 0x05
    8972:	84 55       	subi	r24, 0x54	; 84
    8974:	9f 4a       	sbci	r25, 0xAF	; 175
    8976:	20 e2       	ldi	r18, 0x20	; 32
    8978:	fc 01       	movw	r30, r24
    897a:	20 83       	st	Z, r18
    897c:	8c 81       	ldd	r24, Y+4	; 0x04
    897e:	9d 81       	ldd	r25, Y+5	; 0x05
    8980:	01 96       	adiw	r24, 0x01	; 1
    8982:	8c 83       	std	Y+4, r24	; 0x04
    8984:	9d 83       	std	Y+5, r25	; 0x05
    8986:	8c 81       	ldd	r24, Y+4	; 0x04
    8988:	9d 81       	ldd	r25, Y+5	; 0x05
    898a:	8f 30       	cpi	r24, 0x0F	; 15
    898c:	91 05       	cpc	r25, r1
    898e:	7c f3       	brlt	.-34     	; 0x896e <convertFileName+0x82>


for(j=0; j<12; j++)
    8990:	1a 82       	std	Y+2, r1	; 0x02
    8992:	0c c0       	rjmp	.+24     	; 0x89ac <convertFileName+0xc0>
if(Filename[j] == '.') break;
    8994:	8a 81       	ldd	r24, Y+2	; 0x02
    8996:	88 2f       	mov	r24, r24
    8998:	90 e0       	ldi	r25, 0x00	; 0
    899a:	84 55       	subi	r24, 0x54	; 84
    899c:	9f 4a       	sbci	r25, 0xAF	; 175
    899e:	fc 01       	movw	r30, r24
    89a0:	80 81       	ld	r24, Z
    89a2:	8e 32       	cpi	r24, 0x2E	; 46
    89a4:	39 f0       	breq	.+14     	; 0x89b4 <convertFileName+0xc8>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    89a6:	8a 81       	ldd	r24, Y+2	; 0x02
    89a8:	8f 5f       	subi	r24, 0xFF	; 255
    89aa:	8a 83       	std	Y+2, r24	; 0x02
    89ac:	8a 81       	ldd	r24, Y+2	; 0x02
    89ae:	8c 30       	cpi	r24, 0x0C	; 12
    89b0:	88 f3       	brcs	.-30     	; 0x8994 <convertFileName+0xa8>
    89b2:	01 c0       	rjmp	.+2      	; 0x89b6 <convertFileName+0xca>
if(Filename[j] == '.') break;
    89b4:	00 00       	nop

if(j>8 && j<12) {//Invalid fileName
    89b6:	8a 81       	ldd	r24, Y+2	; 0x02
    89b8:	89 30       	cpi	r24, 0x09	; 9
    89ba:	28 f0       	brcs	.+10     	; 0x89c6 <convertFileName+0xda>
    89bc:	8a 81       	ldd	r24, Y+2	; 0x02
    89be:	8c 30       	cpi	r24, 0x0C	; 12
    89c0:	10 f4       	brcc	.+4      	; 0x89c6 <convertFileName+0xda>
	return 1;}
    89c2:	81 e0       	ldi	r24, 0x01	; 1
    89c4:	c3 c0       	rjmp	.+390    	; 0x8b4c <convertFileName+0x260>
else if (j==12) NoExtension=TRUE;	
    89c6:	8a 81       	ldd	r24, Y+2	; 0x02
    89c8:	8c 30       	cpi	r24, 0x0C	; 12
    89ca:	11 f4       	brne	.+4      	; 0x89d0 <convertFileName+0xe4>
    89cc:	81 e0       	ldi	r24, 0x01	; 1
    89ce:	89 83       	std	Y+1, r24	; 0x01

for(k=0; k<j; k++) //setting file name
    89d0:	1b 82       	std	Y+3, r1	; 0x03
    89d2:	14 c0       	rjmp	.+40     	; 0x89fc <convertFileName+0x110>
  fileNameFAT[k] = Filename[k];
    89d4:	8b 81       	ldd	r24, Y+3	; 0x03
    89d6:	88 2f       	mov	r24, r24
    89d8:	90 e0       	ldi	r25, 0x00	; 0
    89da:	2b 81       	ldd	r18, Y+3	; 0x03
    89dc:	22 2f       	mov	r18, r18
    89de:	30 e0       	ldi	r19, 0x00	; 0
    89e0:	24 55       	subi	r18, 0x54	; 84
    89e2:	3f 4a       	sbci	r19, 0xAF	; 175
    89e4:	f9 01       	movw	r30, r18
    89e6:	40 81       	ld	r20, Z
    89e8:	9e 01       	movw	r18, r28
    89ea:	2a 5f       	subi	r18, 0xFA	; 250
    89ec:	3f 4f       	sbci	r19, 0xFF	; 255
    89ee:	82 0f       	add	r24, r18
    89f0:	93 1f       	adc	r25, r19
    89f2:	fc 01       	movw	r30, r24
    89f4:	40 83       	st	Z, r20

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    89f6:	8b 81       	ldd	r24, Y+3	; 0x03
    89f8:	8f 5f       	subi	r24, 0xFF	; 255
    89fa:	8b 83       	std	Y+3, r24	; 0x03
    89fc:	9b 81       	ldd	r25, Y+3	; 0x03
    89fe:	8a 81       	ldd	r24, Y+2	; 0x02
    8a00:	98 17       	cp	r25, r24
    8a02:	40 f3       	brcs	.-48     	; 0x89d4 <convertFileName+0xe8>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8a04:	8a 81       	ldd	r24, Y+2	; 0x02
    8a06:	8b 83       	std	Y+3, r24	; 0x03
    8a08:	0e c0       	rjmp	.+28     	; 0x8a26 <convertFileName+0x13a>
  fileNameFAT[k] = ' ';
    8a0a:	8b 81       	ldd	r24, Y+3	; 0x03
    8a0c:	88 2f       	mov	r24, r24
    8a0e:	90 e0       	ldi	r25, 0x00	; 0
    8a10:	9e 01       	movw	r18, r28
    8a12:	2a 5f       	subi	r18, 0xFA	; 250
    8a14:	3f 4f       	sbci	r19, 0xFF	; 255
    8a16:	82 0f       	add	r24, r18
    8a18:	93 1f       	adc	r25, r19
    8a1a:	20 e2       	ldi	r18, 0x20	; 32
    8a1c:	fc 01       	movw	r30, r24
    8a1e:	20 83       	st	Z, r18
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    8a20:	8b 81       	ldd	r24, Y+3	; 0x03
    8a22:	8f 5f       	subi	r24, 0xFF	; 255
    8a24:	8b 83       	std	Y+3, r24	; 0x03
    8a26:	8b 81       	ldd	r24, Y+3	; 0x03
    8a28:	88 30       	cpi	r24, 0x08	; 8
    8a2a:	78 f3       	brcs	.-34     	; 0x8a0a <convertFileName+0x11e>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    8a2c:	99 81       	ldd	r25, Y+1	; 0x01
    8a2e:	81 e0       	ldi	r24, 0x01	; 1
    8a30:	89 27       	eor	r24, r25
    8a32:	88 23       	and	r24, r24
    8a34:	19 f0       	breq	.+6      	; 0x8a3c <convertFileName+0x150>
    8a36:	8a 81       	ldd	r24, Y+2	; 0x02
    8a38:	8f 5f       	subi	r24, 0xFF	; 255
    8a3a:	8a 83       	std	Y+2, r24	; 0x02
for(k=8; k<11; k++) //setting file extension
    8a3c:	88 e0       	ldi	r24, 0x08	; 8
    8a3e:	8b 83       	std	Y+3, r24	; 0x03
    8a40:	32 c0       	rjmp	.+100    	; 0x8aa6 <convertFileName+0x1ba>
{
  if(Filename[j] != 0)
    8a42:	8a 81       	ldd	r24, Y+2	; 0x02
    8a44:	88 2f       	mov	r24, r24
    8a46:	90 e0       	ldi	r25, 0x00	; 0
    8a48:	84 55       	subi	r24, 0x54	; 84
    8a4a:	9f 4a       	sbci	r25, 0xAF	; 175
    8a4c:	fc 01       	movw	r30, r24
    8a4e:	80 81       	ld	r24, Z
    8a50:	88 23       	and	r24, r24
    8a52:	19 f1       	breq	.+70     	; 0x8a9a <convertFileName+0x1ae>
    fileNameFAT[k] = Filename[j++];
    8a54:	8b 81       	ldd	r24, Y+3	; 0x03
    8a56:	88 2f       	mov	r24, r24
    8a58:	90 e0       	ldi	r25, 0x00	; 0
    8a5a:	2a 81       	ldd	r18, Y+2	; 0x02
    8a5c:	22 2f       	mov	r18, r18
    8a5e:	30 e0       	ldi	r19, 0x00	; 0
    8a60:	24 55       	subi	r18, 0x54	; 84
    8a62:	3f 4a       	sbci	r19, 0xAF	; 175
    8a64:	f9 01       	movw	r30, r18
    8a66:	40 81       	ld	r20, Z
    8a68:	9e 01       	movw	r18, r28
    8a6a:	2a 5f       	subi	r18, 0xFA	; 250
    8a6c:	3f 4f       	sbci	r19, 0xFF	; 255
    8a6e:	82 0f       	add	r24, r18
    8a70:	93 1f       	adc	r25, r19
    8a72:	fc 01       	movw	r30, r24
    8a74:	40 83       	st	Z, r20
    8a76:	8a 81       	ldd	r24, Y+2	; 0x02
    8a78:	8f 5f       	subi	r24, 0xFF	; 255
    8a7a:	8a 83       	std	Y+2, r24	; 0x02
    8a7c:	11 c0       	rjmp	.+34     	; 0x8aa0 <convertFileName+0x1b4>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    8a7e:	8b 81       	ldd	r24, Y+3	; 0x03
    8a80:	88 2f       	mov	r24, r24
    8a82:	90 e0       	ldi	r25, 0x00	; 0
    8a84:	9e 01       	movw	r18, r28
    8a86:	2a 5f       	subi	r18, 0xFA	; 250
    8a88:	3f 4f       	sbci	r19, 0xFF	; 255
    8a8a:	82 0f       	add	r24, r18
    8a8c:	93 1f       	adc	r25, r19
    8a8e:	20 e2       	ldi	r18, 0x20	; 32
    8a90:	fc 01       	movw	r30, r24
    8a92:	20 83       	st	Z, r18
    8a94:	8b 81       	ldd	r24, Y+3	; 0x03
    8a96:	8f 5f       	subi	r24, 0xFF	; 255
    8a98:	8b 83       	std	Y+3, r24	; 0x03
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    8a9a:	8b 81       	ldd	r24, Y+3	; 0x03
    8a9c:	8b 30       	cpi	r24, 0x0B	; 11
    8a9e:	78 f3       	brcs	.-34     	; 0x8a7e <convertFileName+0x192>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    8aa0:	8b 81       	ldd	r24, Y+3	; 0x03
    8aa2:	8f 5f       	subi	r24, 0xFF	; 255
    8aa4:	8b 83       	std	Y+3, r24	; 0x03
    8aa6:	8b 81       	ldd	r24, Y+3	; 0x03
    8aa8:	8b 30       	cpi	r24, 0x0B	; 11
    8aaa:	58 f2       	brcs	.-106    	; 0x8a42 <convertFileName+0x156>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8aac:	1a 82       	std	Y+2, r1	; 0x02
    8aae:	31 c0       	rjmp	.+98     	; 0x8b12 <convertFileName+0x226>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    8ab0:	8a 81       	ldd	r24, Y+2	; 0x02
    8ab2:	88 2f       	mov	r24, r24
    8ab4:	90 e0       	ldi	r25, 0x00	; 0
    8ab6:	9e 01       	movw	r18, r28
    8ab8:	2a 5f       	subi	r18, 0xFA	; 250
    8aba:	3f 4f       	sbci	r19, 0xFF	; 255
    8abc:	82 0f       	add	r24, r18
    8abe:	93 1f       	adc	r25, r19
    8ac0:	fc 01       	movw	r30, r24
    8ac2:	80 81       	ld	r24, Z
    8ac4:	81 36       	cpi	r24, 0x61	; 97
    8ac6:	10 f1       	brcs	.+68     	; 0x8b0c <convertFileName+0x220>
    8ac8:	8a 81       	ldd	r24, Y+2	; 0x02
    8aca:	88 2f       	mov	r24, r24
    8acc:	90 e0       	ldi	r25, 0x00	; 0
    8ace:	9e 01       	movw	r18, r28
    8ad0:	2a 5f       	subi	r18, 0xFA	; 250
    8ad2:	3f 4f       	sbci	r19, 0xFF	; 255
    8ad4:	82 0f       	add	r24, r18
    8ad6:	93 1f       	adc	r25, r19
    8ad8:	fc 01       	movw	r30, r24
    8ada:	80 81       	ld	r24, Z
    8adc:	8b 37       	cpi	r24, 0x7B	; 123
    8ade:	b0 f4       	brcc	.+44     	; 0x8b0c <convertFileName+0x220>
    fileNameFAT[j] -= 0x20;
    8ae0:	8a 81       	ldd	r24, Y+2	; 0x02
    8ae2:	88 2f       	mov	r24, r24
    8ae4:	90 e0       	ldi	r25, 0x00	; 0
    8ae6:	2a 81       	ldd	r18, Y+2	; 0x02
    8ae8:	22 2f       	mov	r18, r18
    8aea:	30 e0       	ldi	r19, 0x00	; 0
    8aec:	ae 01       	movw	r20, r28
    8aee:	4a 5f       	subi	r20, 0xFA	; 250
    8af0:	5f 4f       	sbci	r21, 0xFF	; 255
    8af2:	24 0f       	add	r18, r20
    8af4:	35 1f       	adc	r19, r21
    8af6:	f9 01       	movw	r30, r18
    8af8:	20 81       	ld	r18, Z
    8afa:	42 2f       	mov	r20, r18
    8afc:	40 52       	subi	r20, 0x20	; 32
    8afe:	9e 01       	movw	r18, r28
    8b00:	2a 5f       	subi	r18, 0xFA	; 250
    8b02:	3f 4f       	sbci	r19, 0xFF	; 255
    8b04:	82 0f       	add	r24, r18
    8b06:	93 1f       	adc	r25, r19
    8b08:	fc 01       	movw	r30, r24
    8b0a:	40 83       	st	Z, r20
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8b0c:	8a 81       	ldd	r24, Y+2	; 0x02
    8b0e:	8f 5f       	subi	r24, 0xFF	; 255
    8b10:	8a 83       	std	Y+2, r24	; 0x02
    8b12:	8a 81       	ldd	r24, Y+2	; 0x02
    8b14:	8b 30       	cpi	r24, 0x0B	; 11
    8b16:	60 f2       	brcs	.-104    	; 0x8ab0 <convertFileName+0x1c4>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8b18:	1a 82       	std	Y+2, r1	; 0x02
    8b1a:	14 c0       	rjmp	.+40     	; 0x8b44 <convertFileName+0x258>
  Filename[j] = fileNameFAT[j];
    8b1c:	8a 81       	ldd	r24, Y+2	; 0x02
    8b1e:	88 2f       	mov	r24, r24
    8b20:	90 e0       	ldi	r25, 0x00	; 0
    8b22:	2a 81       	ldd	r18, Y+2	; 0x02
    8b24:	22 2f       	mov	r18, r18
    8b26:	30 e0       	ldi	r19, 0x00	; 0
    8b28:	ae 01       	movw	r20, r28
    8b2a:	4a 5f       	subi	r20, 0xFA	; 250
    8b2c:	5f 4f       	sbci	r21, 0xFF	; 255
    8b2e:	24 0f       	add	r18, r20
    8b30:	35 1f       	adc	r19, r21
    8b32:	f9 01       	movw	r30, r18
    8b34:	20 81       	ld	r18, Z
    8b36:	84 55       	subi	r24, 0x54	; 84
    8b38:	9f 4a       	sbci	r25, 0xAF	; 175
    8b3a:	fc 01       	movw	r30, r24
    8b3c:	20 83       	st	Z, r18

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8b3e:	8a 81       	ldd	r24, Y+2	; 0x02
    8b40:	8f 5f       	subi	r24, 0xFF	; 255
    8b42:	8a 83       	std	Y+2, r24	; 0x02
    8b44:	8a 81       	ldd	r24, Y+2	; 0x02
    8b46:	8b 30       	cpi	r24, 0x0B	; 11
    8b48:	48 f3       	brcs	.-46     	; 0x8b1c <convertFileName+0x230>
  Filename[j] = fileNameFAT[j];

return 0;
    8b4a:	80 e0       	ldi	r24, 0x00	; 0
}
    8b4c:	62 96       	adiw	r28, 0x12	; 18
    8b4e:	cd bf       	out	0x3d, r28	; 61
    8b50:	de bf       	out	0x3e, r29	; 62
    8b52:	df 91       	pop	r29
    8b54:	cf 91       	pop	r28
    8b56:	08 95       	ret

00008b58 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    8b58:	ef 92       	push	r14
    8b5a:	ff 92       	push	r15
    8b5c:	0f 93       	push	r16
    8b5e:	1f 93       	push	r17
    8b60:	cf 93       	push	r28
    8b62:	df 93       	push	r29
    8b64:	cd b7       	in	r28, 0x3d	; 61
    8b66:	de b7       	in	r29, 0x3e	; 62
    8b68:	e7 97       	sbiw	r28, 0x37	; 55
    8b6a:	cd bf       	out	0x3d, r28	; 61
    8b6c:	de bf       	out	0x3e, r29	; 62
    8b6e:	88 ab       	sts	0x58, r24
    8b70:	99 ab       	sts	0x59, r25
    8b72:	6a ab       	sts	0x5a, r22
    8b74:	7b ab       	sts	0x5b, r23
    8b76:	2c ab       	sts	0x5c, r18
    8b78:	3d ab       	sts	0x5d, r19
    8b7a:	4e ab       	sts	0x5e, r20
    8b7c:	5f ab       	sts	0x5f, r21
unsigned char j, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    8b7e:	1a 82       	std	Y+2, r1	; 0x02
    8b80:	1b 82       	std	Y+3, r1	; 0x03
    8b82:	1c 82       	std	Y+4, r1	; 0x04
    8b84:	1d 82       	std	Y+5, r1	; 0x05
//unsigned char error, data;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    8b86:	1e 82       	std	Y+6, r1	; 0x06
    8b88:	1f 82       	std	Y+7, r1	; 0x07
    8b8a:	18 86       	std	Y+8, r1	; 0x08
    8b8c:	19 86       	std	Y+9, r1	; 0x09
    8b8e:	1a 86       	std	Y+10, r1	; 0x0a
    8b90:	1b 86       	std	Y+11, r1	; 0x0b
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    8b92:	28 a9       	sts	0x48, r18
    8b94:	39 a9       	sts	0x49, r19
    8b96:	81 e0       	ldi	r24, 0x01	; 1
    8b98:	b9 01       	movw	r22, r18
    8b9a:	0e 94 d6 43 	call	0x87ac	; 0x87ac <readFile>
    8b9e:	89 83       	std	Y+1, r24	; 0x01

if(j == 1) 
    8ba0:	89 81       	ldd	r24, Y+1	; 0x01
    8ba2:	81 30       	cpi	r24, 0x01	; 1
    8ba4:	09 f0       	breq	.+2      	; 0x8ba8 <writeFile+0x50>
    8ba6:	84 c0       	rjmp	.+264    	; 0x8cb0 <writeFile+0x158>
{
  //File already exists, appending data
  appendFile = 1;
    8ba8:	81 e0       	ldi	r24, 0x01	; 1
    8baa:	8c 83       	std	Y+4, r24	; 0x04
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    8bac:	80 91 78 50 	lds	r24, 0x5078
    8bb0:	90 91 79 50 	lds	r25, 0x5079
    8bb4:	a0 91 7a 50 	lds	r26, 0x507A
    8bb8:	b0 91 7b 50 	lds	r27, 0x507B
    8bbc:	8c 87       	std	Y+12, r24	; 0x0c
    8bbe:	9d 87       	std	Y+13, r25	; 0x0d
    8bc0:	ae 87       	std	Y+14, r26	; 0x0e
    8bc2:	bf 87       	std	Y+15, r27	; 0x0f
  clusterCount=0;
    8bc4:	1c 8a       	std	Y+20, r1	; 0x14
    8bc6:	1d 8a       	std	Y+21, r1	; 0x15
    8bc8:	1e 8a       	std	Y+22, r1	; 0x16
    8bca:	1f 8a       	std	Y+23, r1	; 0x17
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    8bcc:	8c 85       	ldd	r24, Y+12	; 0x0c
    8bce:	9d 85       	ldd	r25, Y+13	; 0x0d
    8bd0:	ae 85       	ldd	r26, Y+14	; 0x0e
    8bd2:	bf 85       	ldd	r27, Y+15	; 0x0f
    8bd4:	bc 01       	movw	r22, r24
    8bd6:	cd 01       	movw	r24, r26
    8bd8:	40 e0       	ldi	r20, 0x00	; 0
    8bda:	00 e0       	ldi	r16, 0x00	; 0
    8bdc:	10 e0       	ldi	r17, 0x00	; 0
    8bde:	98 01       	movw	r18, r16
    8be0:	0e 94 a2 40 	call	0x8144	; 0x8144 <getSetNextCluster>
    8be4:	dc 01       	movw	r26, r24
    8be6:	cb 01       	movw	r24, r22
    8be8:	8a a3       	lds	r24, 0x5a
    8bea:	9b a3       	lds	r25, 0x5b
    8bec:	ac a3       	lds	r26, 0x5c
    8bee:	bd a3       	lds	r27, 0x5d
    if(nextCluster == EOF) break;
    8bf0:	8a a1       	lds	r24, 0x4a
    8bf2:	9b a1       	lds	r25, 0x4b
    8bf4:	ac a1       	lds	r26, 0x4c
    8bf6:	bd a1       	lds	r27, 0x4d
    8bf8:	8f 3f       	cpi	r24, 0xFF	; 255
    8bfa:	0f ef       	ldi	r16, 0xFF	; 255
    8bfc:	90 07       	cpc	r25, r16
    8bfe:	0f ef       	ldi	r16, 0xFF	; 255
    8c00:	a0 07       	cpc	r26, r16
    8c02:	0f ef       	ldi	r16, 0xFF	; 255
    8c04:	b0 07       	cpc	r27, r16
    8c06:	a1 f0       	breq	.+40     	; 0x8c30 <writeFile+0xd8>
	cluster = nextCluster;
    8c08:	8a a1       	lds	r24, 0x4a
    8c0a:	9b a1       	lds	r25, 0x4b
    8c0c:	ac a1       	lds	r26, 0x4c
    8c0e:	bd a1       	lds	r27, 0x4d
    8c10:	8c 87       	std	Y+12, r24	; 0x0c
    8c12:	9d 87       	std	Y+13, r25	; 0x0d
    8c14:	ae 87       	std	Y+14, r26	; 0x0e
    8c16:	bf 87       	std	Y+15, r27	; 0x0f
	clusterCount++;
    8c18:	8c 89       	ldd	r24, Y+20	; 0x14
    8c1a:	9d 89       	ldd	r25, Y+21	; 0x15
    8c1c:	ae 89       	ldd	r26, Y+22	; 0x16
    8c1e:	bf 89       	ldd	r27, Y+23	; 0x17
    8c20:	01 96       	adiw	r24, 0x01	; 1
    8c22:	a1 1d       	adc	r26, r1
    8c24:	b1 1d       	adc	r27, r1
    8c26:	8c 8b       	std	Y+20, r24	; 0x14
    8c28:	9d 8b       	std	Y+21, r25	; 0x15
    8c2a:	ae 8b       	std	Y+22, r26	; 0x16
    8c2c:	bf 8b       	std	Y+23, r27	; 0x17
  }
    8c2e:	ce cf       	rjmp	.-100    	; 0x8bcc <writeFile+0x74>
  clusterCount=0;
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
    8c30:	00 00       	nop
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    8c32:	e0 90 41 40 	lds	r14, 0x4041
    8c36:	f0 90 42 40 	lds	r15, 0x4042
    8c3a:	00 91 43 40 	lds	r16, 0x4043
    8c3e:	10 91 44 40 	lds	r17, 0x4044
    8c42:	80 91 6c 50 	lds	r24, 0x506C
    8c46:	90 91 6d 50 	lds	r25, 0x506D
    8c4a:	cc 01       	movw	r24, r24
    8c4c:	a0 e0       	ldi	r26, 0x00	; 0
    8c4e:	b0 e0       	ldi	r27, 0x00	; 0
    8c50:	2c 89       	ldd	r18, Y+20	; 0x14
    8c52:	3d 89       	ldd	r19, Y+21	; 0x15
    8c54:	4e 89       	ldd	r20, Y+22	; 0x16
    8c56:	5f 89       	ldd	r21, Y+23	; 0x17
    8c58:	bc 01       	movw	r22, r24
    8c5a:	cd 01       	movw	r24, r26
    8c5c:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    8c60:	dc 01       	movw	r26, r24
    8c62:	cb 01       	movw	r24, r22
    8c64:	20 91 45 40 	lds	r18, 0x4045
    8c68:	30 91 46 40 	lds	r19, 0x4046
    8c6c:	99 01       	movw	r18, r18
    8c6e:	40 e0       	ldi	r20, 0x00	; 0
    8c70:	50 e0       	ldi	r21, 0x00	; 0
    8c72:	bc 01       	movw	r22, r24
    8c74:	cd 01       	movw	r24, r26
    8c76:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    8c7a:	dc 01       	movw	r26, r24
    8c7c:	cb 01       	movw	r24, r22
    8c7e:	a8 01       	movw	r20, r16
    8c80:	97 01       	movw	r18, r14
    8c82:	28 1b       	sub	r18, r24
    8c84:	39 0b       	sbc	r19, r25
    8c86:	4a 0b       	sbc	r20, r26
    8c88:	5b 0b       	sbc	r21, r27
    8c8a:	da 01       	movw	r26, r20
    8c8c:	c9 01       	movw	r24, r18
    8c8e:	20 91 45 40 	lds	r18, 0x4045
    8c92:	30 91 46 40 	lds	r19, 0x4046
    8c96:	99 01       	movw	r18, r18
    8c98:	40 e0       	ldi	r20, 0x00	; 0
    8c9a:	50 e0       	ldi	r21, 0x00	; 0
    8c9c:	bc 01       	movw	r22, r24
    8c9e:	cd 01       	movw	r24, r26
    8ca0:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    8ca4:	da 01       	movw	r26, r20
    8ca6:	c9 01       	movw	r24, r18
    8ca8:	8d 83       	std	Y+5, r24	; 0x05
  start = 1;
    8caa:	81 e0       	ldi	r24, 0x01	; 1
    8cac:	8b 83       	std	Y+3, r24	; 0x03
    8cae:	68 c0       	rjmp	.+208    	; 0x8d80 <writeFile+0x228>
}
else if(j == 2) 
    8cb0:	89 81       	ldd	r24, Y+1	; 0x01
    8cb2:	82 30       	cpi	r24, 0x02	; 2
    8cb4:	11 f4       	brne	.+4      	; 0x8cba <writeFile+0x162>
   return 1; //invalid file name
    8cb6:	81 e0       	ldi	r24, 0x01	; 1
    8cb8:	18 c3       	rjmp	.+1584   	; 0x92ea <writeFile+0x792>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    8cba:	82 e0       	ldi	r24, 0x02	; 2
    8cbc:	60 e0       	ldi	r22, 0x00	; 0
    8cbe:	20 e0       	ldi	r18, 0x00	; 0
    8cc0:	30 e0       	ldi	r19, 0x00	; 0
    8cc2:	a9 01       	movw	r20, r18
    8cc4:	0e 94 4b 41 	call	0x8296	; 0x8296 <getSetFreeCluster>
    8cc8:	dc 01       	movw	r26, r24
    8cca:	cb 01       	movw	r24, r22
    8ccc:	8c 87       	std	Y+12, r24	; 0x0c
    8cce:	9d 87       	std	Y+13, r25	; 0x0d
    8cd0:	ae 87       	std	Y+14, r26	; 0x0e
    8cd2:	bf 87       	std	Y+15, r27	; 0x0f
  if(cluster > totalClusters)
    8cd4:	80 91 4a 40 	lds	r24, 0x404A
    8cd8:	90 91 4b 40 	lds	r25, 0x404B
    8cdc:	a0 91 4c 40 	lds	r26, 0x404C
    8ce0:	b0 91 4d 40 	lds	r27, 0x404D
    8ce4:	2c 85       	ldd	r18, Y+12	; 0x0c
    8ce6:	3d 85       	ldd	r19, Y+13	; 0x0d
    8ce8:	4e 85       	ldd	r20, Y+14	; 0x0e
    8cea:	5f 85       	ldd	r21, Y+15	; 0x0f
    8cec:	82 17       	cp	r24, r18
    8cee:	93 07       	cpc	r25, r19
    8cf0:	a4 07       	cpc	r26, r20
    8cf2:	b5 07       	cpc	r27, r21
    8cf4:	60 f4       	brcc	.+24     	; 0x8d0e <writeFile+0x1b6>
     cluster = rootCluster;
    8cf6:	80 91 50 40 	lds	r24, 0x4050
    8cfa:	90 91 51 40 	lds	r25, 0x4051
    8cfe:	a0 91 52 40 	lds	r26, 0x4052
    8d02:	b0 91 53 40 	lds	r27, 0x4053
    8d06:	8c 87       	std	Y+12, r24	; 0x0c
    8d08:	9d 87       	std	Y+13, r25	; 0x0d
    8d0a:	ae 87       	std	Y+14, r26	; 0x0e
    8d0c:	bf 87       	std	Y+15, r27	; 0x0f

  cluster = searchNextFreeCluster(cluster);
    8d0e:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d10:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d12:	ae 85       	ldd	r26, Y+14	; 0x0e
    8d14:	bf 85       	ldd	r27, Y+15	; 0x0f
    8d16:	bc 01       	movw	r22, r24
    8d18:	cd 01       	movw	r24, r26
    8d1a:	0e 94 7f 49 	call	0x92fe	; 0x92fe <searchNextFreeCluster>
    8d1e:	dc 01       	movw	r26, r24
    8d20:	cb 01       	movw	r24, r22
    8d22:	8c 87       	std	Y+12, r24	; 0x0c
    8d24:	9d 87       	std	Y+13, r25	; 0x0d
    8d26:	ae 87       	std	Y+14, r26	; 0x0e
    8d28:	bf 87       	std	Y+15, r27	; 0x0f
   if(cluster == 0)
    8d2a:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d2c:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d2e:	ae 85       	ldd	r26, Y+14	; 0x0e
    8d30:	bf 85       	ldd	r27, Y+15	; 0x0f
    8d32:	00 97       	sbiw	r24, 0x00	; 0
    8d34:	a1 05       	cpc	r26, r1
    8d36:	b1 05       	cpc	r27, r1
    8d38:	11 f4       	brne	.+4      	; 0x8d3e <writeFile+0x1e6>
   {
	   // No free cluster!
	  return 2;
    8d3a:	82 e0       	ldi	r24, 0x02	; 2
    8d3c:	d6 c2       	rjmp	.+1452   	; 0x92ea <writeFile+0x792>
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    8d3e:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d40:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d42:	ae 85       	ldd	r26, Y+14	; 0x0e
    8d44:	bf 85       	ldd	r27, Y+15	; 0x0f
    8d46:	bc 01       	movw	r22, r24
    8d48:	cd 01       	movw	r24, r26
    8d4a:	41 e0       	ldi	r20, 0x01	; 1
    8d4c:	0f ef       	ldi	r16, 0xFF	; 255
    8d4e:	1f ef       	ldi	r17, 0xFF	; 255
    8d50:	98 01       	movw	r18, r16
    8d52:	0e 94 a2 40 	call	0x8144	; 0x8144 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    8d56:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d58:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d5a:	ae 85       	ldd	r26, Y+14	; 0x0e
    8d5c:	bf 85       	ldd	r27, Y+15	; 0x0f
    8d5e:	cd 01       	movw	r24, r26
    8d60:	aa 27       	eor	r26, r26
    8d62:	bb 27       	eor	r27, r27
    8d64:	8e 83       	std	Y+6, r24	; 0x06
    8d66:	9f 83       	std	Y+7, r25	; 0x07
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    8d68:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d6a:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d6c:	88 87       	std	Y+8, r24	; 0x08
    8d6e:	99 87       	std	Y+9, r25	; 0x09
  fileSize = 0;
    8d70:	10 92 41 40 	sts	0x4041, r1
    8d74:	10 92 42 40 	sts	0x4042, r1
    8d78:	10 92 43 40 	sts	0x4043, r1
    8d7c:	10 92 44 40 	sts	0x4044, r1
}

//start writing data here

if(start){
    8d80:	8b 81       	ldd	r24, Y+3	; 0x03
    8d82:	88 23       	and	r24, r24
    8d84:	11 f1       	breq	.+68     	; 0x8dca <writeFile+0x272>
  start = 0;
    8d86:	1b 82       	std	Y+3, r1	; 0x03
  startBlock = getFirstSector (cluster) + sector;
    8d88:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d8a:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d8c:	ae 85       	ldd	r26, Y+14	; 0x0e
    8d8e:	bf 85       	ldd	r27, Y+15	; 0x0f
    8d90:	bc 01       	movw	r22, r24
    8d92:	cd 01       	movw	r24, r26
    8d94:	0e 94 70 40 	call	0x80e0	; 0x80e0 <getFirstSector>
    8d98:	dc 01       	movw	r26, r24
    8d9a:	cb 01       	movw	r24, r22
    8d9c:	9c 01       	movw	r18, r24
    8d9e:	8d 81       	ldd	r24, Y+5	; 0x05
    8da0:	88 2f       	mov	r24, r24
    8da2:	90 e0       	ldi	r25, 0x00	; 0
    8da4:	82 0f       	add	r24, r18
    8da6:	93 1f       	adc	r25, r19
    8da8:	8a 87       	std	Y+10, r24	; 0x0a
    8daa:	9b 87       	std	Y+11, r25	; 0x0b
  SD_read_block (startBlock,SDBuffer);
    8dac:	8a 85       	ldd	r24, Y+10	; 0x0a
    8dae:	9b 85       	ldd	r25, Y+11	; 0x0b
    8db0:	cc 01       	movw	r24, r24
    8db2:	a0 e0       	ldi	r26, 0x00	; 0
    8db4:	b0 e0       	ldi	r27, 0x00	; 0
    8db6:	27 ec       	ldi	r18, 0xC7	; 199
    8db8:	31 e2       	ldi	r19, 0x21	; 33
    8dba:	bc 01       	movw	r22, r24
    8dbc:	cd 01       	movw	r24, r26
    8dbe:	a9 01       	movw	r20, r18
    8dc0:	0e 94 85 4e 	call	0x9d0a	; 0x9d0a <SD_read_block>
  j = sector;
    8dc4:	8d 81       	ldd	r24, Y+5	; 0x05
    8dc6:	89 83       	std	Y+1, r24	; 0x01
    8dc8:	0d c0       	rjmp	.+26     	; 0x8de4 <writeFile+0x28c>
}
else{
  startBlock = getFirstSector (cluster);
    8dca:	8c 85       	ldd	r24, Y+12	; 0x0c
    8dcc:	9d 85       	ldd	r25, Y+13	; 0x0d
    8dce:	ae 85       	ldd	r26, Y+14	; 0x0e
    8dd0:	bf 85       	ldd	r27, Y+15	; 0x0f
    8dd2:	bc 01       	movw	r22, r24
    8dd4:	cd 01       	movw	r24, r26
    8dd6:	0e 94 70 40 	call	0x80e0	; 0x80e0 <getFirstSector>
    8dda:	dc 01       	movw	r26, r24
    8ddc:	cb 01       	movw	r24, r22
    8dde:	8a 87       	std	Y+10, r24	; 0x0a
    8de0:	9b 87       	std	Y+11, r25	; 0x0b
  j=0;
    8de2:	19 82       	std	Y+1, r1	; 0x01
}
uint32_t writtenData = 0;
    8de4:	18 8e       	std	Y+24, r1	; 0x18
    8de6:	19 8e       	std	Y+25, r1	; 0x19
    8de8:	1a 8e       	std	Y+26, r1	; 0x1a
    8dea:	1b 8e       	std	Y+27, r1	; 0x1b
uint32_t dataToWrite = 0;
    8dec:	1c 8e       	std	Y+28, r1	; 0x1c
    8dee:	1d 8e       	std	Y+29, r1	; 0x1d
    8df0:	1e 8e       	std	Y+30, r1	; 0x1e
    8df2:	1f 8e       	std	Y+31, r1	; 0x1f
while(lengthOfData!=0){
    8df4:	cc c0       	rjmp	.+408    	; 0x8f8e <writeFile+0x436>
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    8df6:	8c a9       	sts	0x4c, r24
    8df8:	9d a9       	sts	0x4d, r25
    8dfa:	ae a9       	sts	0x4e, r26
    8dfc:	bf a9       	sts	0x4f, r27
    8dfe:	80 30       	cpi	r24, 0x00	; 0
    8e00:	32 e0       	ldi	r19, 0x02	; 2
    8e02:	93 07       	cpc	r25, r19
    8e04:	30 e0       	ldi	r19, 0x00	; 0
    8e06:	a3 07       	cpc	r26, r19
    8e08:	30 e0       	ldi	r19, 0x00	; 0
    8e0a:	b3 07       	cpc	r27, r19
    8e0c:	08 f1       	brcs	.+66     	; 0x8e50 <writeFile+0x2f8>
		 writtenData += 512;
    8e0e:	88 8d       	ldd	r24, Y+24	; 0x18
    8e10:	99 8d       	ldd	r25, Y+25	; 0x19
    8e12:	aa 8d       	ldd	r26, Y+26	; 0x1a
    8e14:	bb 8d       	ldd	r27, Y+27	; 0x1b
    8e16:	80 50       	subi	r24, 0x00	; 0
    8e18:	9e 4f       	sbci	r25, 0xFE	; 254
    8e1a:	af 4f       	sbci	r26, 0xFF	; 255
    8e1c:	bf 4f       	sbci	r27, 0xFF	; 255
    8e1e:	88 8f       	std	Y+24, r24	; 0x18
    8e20:	99 8f       	std	Y+25, r25	; 0x19
    8e22:	aa 8f       	std	Y+26, r26	; 0x1a
    8e24:	bb 8f       	std	Y+27, r27	; 0x1b
		 dataToWrite = 512;
    8e26:	80 e0       	ldi	r24, 0x00	; 0
    8e28:	92 e0       	ldi	r25, 0x02	; 2
    8e2a:	a0 e0       	ldi	r26, 0x00	; 0
    8e2c:	b0 e0       	ldi	r27, 0x00	; 0
    8e2e:	8c 8f       	std	Y+28, r24	; 0x1c
    8e30:	9d 8f       	std	Y+29, r25	; 0x1d
    8e32:	ae 8f       	std	Y+30, r26	; 0x1e
    8e34:	bf 8f       	std	Y+31, r27	; 0x1f
		 lengthOfData -= 512;
    8e36:	8c a9       	sts	0x4c, r24
    8e38:	9d a9       	sts	0x4d, r25
    8e3a:	ae a9       	sts	0x4e, r26
    8e3c:	bf a9       	sts	0x4f, r27
    8e3e:	80 50       	subi	r24, 0x00	; 0
    8e40:	92 40       	sbci	r25, 0x02	; 2
    8e42:	a0 40       	sbci	r26, 0x00	; 0
    8e44:	b0 40       	sbci	r27, 0x00	; 0
    8e46:	8c ab       	sts	0x5c, r24
    8e48:	9d ab       	sts	0x5d, r25
    8e4a:	ae ab       	sts	0x5e, r26
    8e4c:	bf ab       	sts	0x5f, r27
    8e4e:	1f c0       	rjmp	.+62     	; 0x8e8e <writeFile+0x336>
	}
	else{
		writtenData += lengthOfData;
    8e50:	28 8d       	ldd	r18, Y+24	; 0x18
    8e52:	39 8d       	ldd	r19, Y+25	; 0x19
    8e54:	4a 8d       	ldd	r20, Y+26	; 0x1a
    8e56:	5b 8d       	ldd	r21, Y+27	; 0x1b
    8e58:	8c a9       	sts	0x4c, r24
    8e5a:	9d a9       	sts	0x4d, r25
    8e5c:	ae a9       	sts	0x4e, r26
    8e5e:	bf a9       	sts	0x4f, r27
    8e60:	82 0f       	add	r24, r18
    8e62:	93 1f       	adc	r25, r19
    8e64:	a4 1f       	adc	r26, r20
    8e66:	b5 1f       	adc	r27, r21
    8e68:	88 8f       	std	Y+24, r24	; 0x18
    8e6a:	99 8f       	std	Y+25, r25	; 0x19
    8e6c:	aa 8f       	std	Y+26, r26	; 0x1a
    8e6e:	bb 8f       	std	Y+27, r27	; 0x1b
		dataToWrite = lengthOfData%512;
    8e70:	8c a9       	sts	0x4c, r24
    8e72:	9d a9       	sts	0x4d, r25
    8e74:	ae a9       	sts	0x4e, r26
    8e76:	bf a9       	sts	0x4f, r27
    8e78:	91 70       	andi	r25, 0x01	; 1
    8e7a:	a0 70       	andi	r26, 0x00	; 0
    8e7c:	b0 70       	andi	r27, 0x00	; 0
    8e7e:	8c 8f       	std	Y+28, r24	; 0x1c
    8e80:	9d 8f       	std	Y+29, r25	; 0x1d
    8e82:	ae 8f       	std	Y+30, r26	; 0x1e
    8e84:	bf 8f       	std	Y+31, r27	; 0x1f
		lengthOfData = 0;
    8e86:	1c aa       	sts	0x9c, r17
    8e88:	1d aa       	sts	0x9d, r17
    8e8a:	1e aa       	sts	0x9e, r17
    8e8c:	1f aa       	sts	0x9f, r17
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    8e8e:	80 91 41 40 	lds	r24, 0x4041
    8e92:	90 91 42 40 	lds	r25, 0x4042
    8e96:	a0 91 43 40 	lds	r26, 0x4043
    8e9a:	b0 91 44 40 	lds	r27, 0x4044
    8e9e:	80 50       	subi	r24, 0x00	; 0
    8ea0:	9e 4f       	sbci	r25, 0xFE	; 254
    8ea2:	af 4f       	sbci	r26, 0xFF	; 255
    8ea4:	bf 4f       	sbci	r27, 0xFF	; 255
    8ea6:	80 93 41 40 	sts	0x4041, r24
    8eaa:	90 93 42 40 	sts	0x4042, r25
    8eae:	a0 93 43 40 	sts	0x4043, r26
    8eb2:	b0 93 44 40 	sts	0x4044, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    8eb6:	8a 85       	ldd	r24, Y+10	; 0x0a
    8eb8:	9b 85       	ldd	r25, Y+11	; 0x0b
    8eba:	cc 01       	movw	r24, r24
    8ebc:	a0 e0       	ldi	r26, 0x00	; 0
    8ebe:	b0 e0       	ldi	r27, 0x00	; 0
    8ec0:	48 8d       	ldd	r20, Y+24	; 0x18
    8ec2:	59 8d       	ldd	r21, Y+25	; 0x19
    8ec4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    8ec6:	3d 8d       	ldd	r19, Y+29	; 0x1d
    8ec8:	ba 01       	movw	r22, r20
    8eca:	62 1b       	sub	r22, r18
    8ecc:	73 0b       	sbc	r23, r19
    8ece:	9b 01       	movw	r18, r22
    8ed0:	4a a9       	sts	0x4a, r20
    8ed2:	5b a9       	sts	0x4b, r21
    8ed4:	42 0f       	add	r20, r18
    8ed6:	53 1f       	adc	r21, r19
    8ed8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    8eda:	3d 8d       	ldd	r19, Y+29	; 0x1d
    8edc:	bc 01       	movw	r22, r24
    8ede:	cd 01       	movw	r24, r26
    8ee0:	0e 94 b7 4d 	call	0x9b6e	; 0x9b6e <SD_write_block>
	j++;
    8ee4:	89 81       	ldd	r24, Y+1	; 0x01
    8ee6:	8f 5f       	subi	r24, 0xFF	; 255
    8ee8:	89 83       	std	Y+1, r24	; 0x01
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    8eea:	89 81       	ldd	r24, Y+1	; 0x01
    8eec:	28 2f       	mov	r18, r24
    8eee:	30 e0       	ldi	r19, 0x00	; 0
    8ef0:	80 91 6c 50 	lds	r24, 0x506C
    8ef4:	90 91 6d 50 	lds	r25, 0x506D
    8ef8:	28 17       	cp	r18, r24
    8efa:	39 07       	cpc	r19, r25
    8efc:	d9 f5       	brne	.+118    	; 0x8f74 <writeFile+0x41c>
		j = 0; 
    8efe:	19 82       	std	Y+1, r1	; 0x01
 
		prevCluster = cluster;
    8f00:	8c 85       	ldd	r24, Y+12	; 0x0c
    8f02:	9d 85       	ldd	r25, Y+13	; 0x0d
    8f04:	ae 85       	ldd	r26, Y+14	; 0x0e
    8f06:	bf 85       	ldd	r27, Y+15	; 0x0f
    8f08:	88 8b       	std	Y+16, r24	; 0x10
    8f0a:	99 8b       	std	Y+17, r25	; 0x11
    8f0c:	aa 8b       	std	Y+18, r26	; 0x12
    8f0e:	bb 8b       	std	Y+19, r27	; 0x13
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    8f10:	88 89       	ldd	r24, Y+16	; 0x10
    8f12:	99 89       	ldd	r25, Y+17	; 0x11
    8f14:	aa 89       	ldd	r26, Y+18	; 0x12
    8f16:	bb 89       	ldd	r27, Y+19	; 0x13
    8f18:	bc 01       	movw	r22, r24
    8f1a:	cd 01       	movw	r24, r26
    8f1c:	0e 94 7f 49 	call	0x92fe	; 0x92fe <searchNextFreeCluster>
    8f20:	dc 01       	movw	r26, r24
    8f22:	cb 01       	movw	r24, r22
    8f24:	8c 87       	std	Y+12, r24	; 0x0c
    8f26:	9d 87       	std	Y+13, r25	; 0x0d
    8f28:	ae 87       	std	Y+14, r26	; 0x0e
    8f2a:	bf 87       	std	Y+15, r27	; 0x0f
		if(cluster == 0){
    8f2c:	8c 85       	ldd	r24, Y+12	; 0x0c
    8f2e:	9d 85       	ldd	r25, Y+13	; 0x0d
    8f30:	ae 85       	ldd	r26, Y+14	; 0x0e
    8f32:	bf 85       	ldd	r27, Y+15	; 0x0f
    8f34:	00 97       	sbiw	r24, 0x00	; 0
    8f36:	a1 05       	cpc	r26, r1
    8f38:	b1 05       	cpc	r27, r1
    8f3a:	11 f4       	brne	.+4      	; 0x8f40 <writeFile+0x3e8>
		  //No free cluster!
		  return 2;
    8f3c:	82 e0       	ldi	r24, 0x02	; 2
    8f3e:	d5 c1       	rjmp	.+938    	; 0x92ea <writeFile+0x792>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    8f40:	88 89       	ldd	r24, Y+16	; 0x10
    8f42:	99 89       	ldd	r25, Y+17	; 0x11
    8f44:	aa 89       	ldd	r26, Y+18	; 0x12
    8f46:	bb 89       	ldd	r27, Y+19	; 0x13
    8f48:	0c 85       	ldd	r16, Y+12	; 0x0c
    8f4a:	1d 85       	ldd	r17, Y+13	; 0x0d
    8f4c:	2e 85       	ldd	r18, Y+14	; 0x0e
    8f4e:	3f 85       	ldd	r19, Y+15	; 0x0f
    8f50:	bc 01       	movw	r22, r24
    8f52:	cd 01       	movw	r24, r26
    8f54:	41 e0       	ldi	r20, 0x01	; 1
    8f56:	0e 94 a2 40 	call	0x8144	; 0x8144 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    8f5a:	8c 85       	ldd	r24, Y+12	; 0x0c
    8f5c:	9d 85       	ldd	r25, Y+13	; 0x0d
    8f5e:	ae 85       	ldd	r26, Y+14	; 0x0e
    8f60:	bf 85       	ldd	r27, Y+15	; 0x0f
    8f62:	bc 01       	movw	r22, r24
    8f64:	cd 01       	movw	r24, r26
    8f66:	41 e0       	ldi	r20, 0x01	; 1
    8f68:	0f ef       	ldi	r16, 0xFF	; 255
    8f6a:	1f ef       	ldi	r17, 0xFF	; 255
    8f6c:	98 01       	movw	r18, r16
    8f6e:	0e 94 a2 40 	call	0x8144	; 0x8144 <getSetNextCluster>
    8f72:	05 c0       	rjmp	.+10     	; 0x8f7e <writeFile+0x426>
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    8f74:	8a 85       	ldd	r24, Y+10	; 0x0a
    8f76:	9b 85       	ldd	r25, Y+11	; 0x0b
    8f78:	01 96       	adiw	r24, 0x01	; 1
    8f7a:	8a 87       	std	Y+10, r24	; 0x0a
    8f7c:	9b 87       	std	Y+11, r25	; 0x0b
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    8f7e:	2c 85       	ldd	r18, Y+12	; 0x0c
    8f80:	3d 85       	ldd	r19, Y+13	; 0x0d
    8f82:	4e 85       	ldd	r20, Y+14	; 0x0e
    8f84:	5f 85       	ldd	r21, Y+15	; 0x0f
    8f86:	82 e0       	ldi	r24, 0x02	; 2
    8f88:	61 e0       	ldi	r22, 0x01	; 1
    8f8a:	0e 94 4b 41 	call	0x8296	; 0x8296 <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    8f8e:	8c a9       	sts	0x4c, r24
    8f90:	9d a9       	sts	0x4d, r25
    8f92:	ae a9       	sts	0x4e, r26
    8f94:	bf a9       	sts	0x4f, r27
    8f96:	00 97       	sbiw	r24, 0x00	; 0
    8f98:	a1 05       	cpc	r26, r1
    8f9a:	b1 05       	cpc	r27, r1
    8f9c:	09 f0       	breq	.+2      	; 0x8fa0 <writeFile+0x448>
    8f9e:	2b cf       	rjmp	.-426    	; 0x8df6 <writeFile+0x29e>
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    8fa0:	8c 81       	ldd	r24, Y+4	; 0x04
    8fa2:	88 23       	and	r24, r24
    8fa4:	09 f4       	brne	.+2      	; 0x8fa8 <writeFile+0x450>
    8fa6:	66 c0       	rjmp	.+204    	; 0x9074 <writeFile+0x51c>
{
  SD_read_block (appendFileSector,SDBuffer);    
    8fa8:	80 91 c2 50 	lds	r24, 0x50C2
    8fac:	90 91 c3 50 	lds	r25, 0x50C3
    8fb0:	a0 91 c4 50 	lds	r26, 0x50C4
    8fb4:	b0 91 c5 50 	lds	r27, 0x50C5
    8fb8:	27 ec       	ldi	r18, 0xC7	; 199
    8fba:	31 e2       	ldi	r19, 0x21	; 33
    8fbc:	bc 01       	movw	r22, r24
    8fbe:	cd 01       	movw	r24, r26
    8fc0:	a9 01       	movw	r20, r18
    8fc2:	0e 94 85 4e 	call	0x9d0a	; 0x9d0a <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    8fc6:	80 91 c8 23 	lds	r24, 0x23C8
    8fca:	90 91 c9 23 	lds	r25, 0x23C9
    8fce:	a0 91 ca 23 	lds	r26, 0x23CA
    8fd2:	b0 91 cb 23 	lds	r27, 0x23CB
    8fd6:	89 53       	subi	r24, 0x39	; 57
    8fd8:	9e 4d       	sbci	r25, 0xDE	; 222
    8fda:	8e a3       	lds	r24, 0x5e
    8fdc:	9f a3       	lds	r25, 0x5f

  dir->lastAccessDate = 0;   //date of last access ignored
    8fde:	8e a1       	lds	r24, 0x4e
    8fe0:	9f a1       	lds	r25, 0x4f
    8fe2:	fc 01       	movw	r30, r24
    8fe4:	12 8a       	std	Z+18, r1	; 0x12
    8fe6:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    8fe8:	20 91 41 40 	lds	r18, 0x4041
    8fec:	30 91 42 40 	lds	r19, 0x4042
    8ff0:	40 91 43 40 	lds	r20, 0x4043
    8ff4:	50 91 44 40 	lds	r21, 0x4044
    8ff8:	8e a1       	lds	r24, 0x4e
    8ffa:	9f a1       	lds	r25, 0x4f
    8ffc:	fc 01       	movw	r30, r24
    8ffe:	84 8d       	ldd	r24, Z+28	; 0x1c
    9000:	95 8d       	ldd	r25, Z+29	; 0x1d
    9002:	a6 8d       	ldd	r26, Z+30	; 0x1e
    9004:	b7 8d       	ldd	r27, Z+31	; 0x1f
    9006:	79 01       	movw	r14, r18
    9008:	8a 01       	movw	r16, r20
    900a:	e8 1a       	sub	r14, r24
    900c:	f9 0a       	sbc	r15, r25
    900e:	0a 0b       	sbc	r16, r26
    9010:	1b 0b       	sbc	r17, r27
    9012:	d8 01       	movw	r26, r16
    9014:	c7 01       	movw	r24, r14
    9016:	88 a7       	lds	r24, 0x78
    9018:	99 a7       	lds	r25, 0x79
    901a:	aa a7       	lds	r26, 0x7a
    901c:	bb a7       	lds	r27, 0x7b
  dir->fileSize = fileSize;
    901e:	80 91 41 40 	lds	r24, 0x4041
    9022:	90 91 42 40 	lds	r25, 0x4042
    9026:	a0 91 43 40 	lds	r26, 0x4043
    902a:	b0 91 44 40 	lds	r27, 0x4044
    902e:	2e a1       	lds	r18, 0x4e
    9030:	3f a1       	lds	r19, 0x4f
    9032:	f9 01       	movw	r30, r18
    9034:	84 8f       	std	Z+28, r24	; 0x1c
    9036:	95 8f       	std	Z+29, r25	; 0x1d
    9038:	a6 8f       	std	Z+30, r26	; 0x1e
    903a:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    903c:	80 91 c2 50 	lds	r24, 0x50C2
    9040:	90 91 c3 50 	lds	r25, 0x50C3
    9044:	a0 91 c4 50 	lds	r26, 0x50C4
    9048:	b0 91 c5 50 	lds	r27, 0x50C5
    904c:	27 ec       	ldi	r18, 0xC7	; 199
    904e:	31 e2       	ldi	r19, 0x21	; 33
    9050:	bc 01       	movw	r22, r24
    9052:	cd 01       	movw	r24, r26
    9054:	a9 01       	movw	r20, r18
    9056:	20 e0       	ldi	r18, 0x00	; 0
    9058:	32 e0       	ldi	r19, 0x02	; 2
    905a:	0e 94 b7 4d 	call	0x9b6e	; 0x9b6e <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    905e:	28 a5       	lds	r18, 0x68
    9060:	39 a5       	lds	r19, 0x69
    9062:	4a a5       	lds	r20, 0x6a
    9064:	5b a5       	lds	r21, 0x6b
    9066:	81 e0       	ldi	r24, 0x01	; 1
    9068:	ba 01       	movw	r22, r20
    906a:	a9 01       	movw	r20, r18
    906c:	0e 94 58 4a 	call	0x94b0	; 0x94b0 <freeMemoryUpdate>

 //File appended!
  return 0;
    9070:	80 e0       	ldi	r24, 0x00	; 0
    9072:	3b c1       	rjmp	.+630    	; 0x92ea <writeFile+0x792>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    9074:	80 91 50 40 	lds	r24, 0x4050
    9078:	90 91 51 40 	lds	r25, 0x4051
    907c:	a0 91 52 40 	lds	r26, 0x4052
    9080:	b0 91 53 40 	lds	r27, 0x4053
    9084:	88 8b       	std	Y+16, r24	; 0x10
    9086:	99 8b       	std	Y+17, r25	; 0x11
    9088:	aa 8b       	std	Y+18, r26	; 0x12
    908a:	bb 8b       	std	Y+19, r27	; 0x13

while(1)
{
   firstSector = getFirstSector (prevCluster);
    908c:	88 89       	ldd	r24, Y+16	; 0x10
    908e:	99 89       	ldd	r25, Y+17	; 0x11
    9090:	aa 89       	ldd	r26, Y+18	; 0x12
    9092:	bb 89       	ldd	r27, Y+19	; 0x13
    9094:	bc 01       	movw	r22, r24
    9096:	cd 01       	movw	r24, r26
    9098:	0e 94 70 40 	call	0x80e0	; 0x80e0 <getFirstSector>
    909c:	dc 01       	movw	r26, r24
    909e:	cb 01       	movw	r24, r22
    90a0:	8c a7       	lds	r24, 0x7c
    90a2:	9d a7       	lds	r25, 0x7d
    90a4:	ae a7       	lds	r26, 0x7e
    90a6:	bf a7       	lds	r27, 0x7f

   for(sector = 0; sector < sectorPerCluster; sector++)
    90a8:	1d 82       	std	Y+5, r1	; 0x05
    90aa:	ad c0       	rjmp	.+346    	; 0x9206 <writeFile+0x6ae>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    90ac:	8d 81       	ldd	r24, Y+5	; 0x05
    90ae:	28 2f       	mov	r18, r24
    90b0:	30 e0       	ldi	r19, 0x00	; 0
    90b2:	40 e0       	ldi	r20, 0x00	; 0
    90b4:	50 e0       	ldi	r21, 0x00	; 0
    90b6:	8c a5       	lds	r24, 0x6c
    90b8:	9d a5       	lds	r25, 0x6d
    90ba:	ae a5       	lds	r26, 0x6e
    90bc:	bf a5       	lds	r27, 0x6f
    90be:	82 0f       	add	r24, r18
    90c0:	93 1f       	adc	r25, r19
    90c2:	a4 1f       	adc	r26, r20
    90c4:	b5 1f       	adc	r27, r21
    90c6:	27 ec       	ldi	r18, 0xC7	; 199
    90c8:	31 e2       	ldi	r19, 0x21	; 33
    90ca:	bc 01       	movw	r22, r24
    90cc:	cd 01       	movw	r24, r26
    90ce:	a9 01       	movw	r20, r18
    90d0:	0e 94 85 4e 	call	0x9d0a	; 0x9d0a <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    90d4:	18 a2       	lds	r17, 0x98
    90d6:	19 a2       	lds	r17, 0x99
    90d8:	89 c0       	rjmp	.+274    	; 0x91ec <writeFile+0x694>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    90da:	88 a1       	lds	r24, 0x48
    90dc:	99 a1       	lds	r25, 0x49
    90de:	89 53       	subi	r24, 0x39	; 57
    90e0:	9e 4d       	sbci	r25, 0xDE	; 222
    90e2:	8e a3       	lds	r24, 0x5e
    90e4:	9f a3       	lds	r25, 0x5f
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    90e6:	8a 81       	ldd	r24, Y+2	; 0x02
    90e8:	88 23       	and	r24, r24
    90ea:	11 f0       	breq	.+4      	; 0x90f0 <writeFile+0x598>
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    90ec:	80 e0       	ldi	r24, 0x00	; 0
    90ee:	fd c0       	rjmp	.+506    	; 0x92ea <writeFile+0x792>
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    90f0:	8e a1       	lds	r24, 0x4e
    90f2:	9f a1       	lds	r25, 0x4f
    90f4:	fc 01       	movw	r30, r24
    90f6:	80 81       	ld	r24, Z
    90f8:	88 23       	and	r24, r24
    90fa:	39 f0       	breq	.+14     	; 0x910a <writeFile+0x5b2>
    90fc:	8e a1       	lds	r24, 0x4e
    90fe:	9f a1       	lds	r25, 0x4f
    9100:	fc 01       	movw	r30, r24
    9102:	80 81       	ld	r24, Z
    9104:	85 3e       	cpi	r24, 0xE5	; 229
    9106:	09 f0       	breq	.+2      	; 0x910a <writeFile+0x5b2>
    9108:	6c c0       	rjmp	.+216    	; 0x91e2 <writeFile+0x68a>
		{
		  for(j=0; j<11; j++)
    910a:	19 82       	std	Y+1, r1	; 0x01
    910c:	13 c0       	rjmp	.+38     	; 0x9134 <writeFile+0x5dc>
  			dir->name[j] = Filename[j];
    910e:	89 81       	ldd	r24, Y+1	; 0x01
    9110:	88 2f       	mov	r24, r24
    9112:	90 e0       	ldi	r25, 0x00	; 0
    9114:	29 81       	ldd	r18, Y+1	; 0x01
    9116:	22 2f       	mov	r18, r18
    9118:	30 e0       	ldi	r19, 0x00	; 0
    911a:	24 55       	subi	r18, 0x54	; 84
    911c:	3f 4a       	sbci	r19, 0xAF	; 175
    911e:	f9 01       	movw	r30, r18
    9120:	40 81       	ld	r20, Z
    9122:	2e a1       	lds	r18, 0x4e
    9124:	3f a1       	lds	r19, 0x4f
    9126:	82 0f       	add	r24, r18
    9128:	93 1f       	adc	r25, r19
    912a:	fc 01       	movw	r30, r24
    912c:	40 83       	st	Z, r20
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    912e:	89 81       	ldd	r24, Y+1	; 0x01
    9130:	8f 5f       	subi	r24, 0xFF	; 255
    9132:	89 83       	std	Y+1, r24	; 0x01
    9134:	89 81       	ldd	r24, Y+1	; 0x01
    9136:	8b 30       	cpi	r24, 0x0B	; 11
    9138:	50 f3       	brcs	.-44     	; 0x910e <writeFile+0x5b6>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    913a:	8e a1       	lds	r24, 0x4e
    913c:	9f a1       	lds	r25, 0x4f
    913e:	20 e2       	ldi	r18, 0x20	; 32
    9140:	fc 01       	movw	r30, r24
    9142:	23 87       	std	Z+11, r18	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    9144:	8e a1       	lds	r24, 0x4e
    9146:	9f a1       	lds	r25, 0x4f
    9148:	fc 01       	movw	r30, r24
    914a:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    914c:	8e a1       	lds	r24, 0x4e
    914e:	9f a1       	lds	r25, 0x4f
    9150:	fc 01       	movw	r30, r24
    9152:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    9154:	8e a1       	lds	r24, 0x4e
    9156:	9f a1       	lds	r25, 0x4f
    9158:	fc 01       	movw	r30, r24
    915a:	12 8a       	std	Z+18, r1	; 0x12
    915c:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    915e:	8e a1       	lds	r24, 0x4e
    9160:	9f a1       	lds	r25, 0x4f
    9162:	2e 81       	ldd	r18, Y+6	; 0x06
    9164:	3f 81       	ldd	r19, Y+7	; 0x07
    9166:	fc 01       	movw	r30, r24
    9168:	24 8b       	std	Z+20, r18	; 0x14
    916a:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    916c:	8e a1       	lds	r24, 0x4e
    916e:	9f a1       	lds	r25, 0x4f
    9170:	28 85       	ldd	r18, Y+8	; 0x08
    9172:	39 85       	ldd	r19, Y+9	; 0x09
    9174:	fc 01       	movw	r30, r24
    9176:	22 8f       	std	Z+26, r18	; 0x1a
    9178:	33 8f       	std	Z+27, r19	; 0x1b
		  dir->fileSize = fileSize;
    917a:	80 91 41 40 	lds	r24, 0x4041
    917e:	90 91 42 40 	lds	r25, 0x4042
    9182:	a0 91 43 40 	lds	r26, 0x4043
    9186:	b0 91 44 40 	lds	r27, 0x4044
    918a:	2e a1       	lds	r18, 0x4e
    918c:	3f a1       	lds	r19, 0x4f
    918e:	f9 01       	movw	r30, r18
    9190:	84 8f       	std	Z+28, r24	; 0x1c
    9192:	95 8f       	std	Z+29, r25	; 0x1d
    9194:	a6 8f       	std	Z+30, r26	; 0x1e
    9196:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    9198:	8d 81       	ldd	r24, Y+5	; 0x05
    919a:	28 2f       	mov	r18, r24
    919c:	30 e0       	ldi	r19, 0x00	; 0
    919e:	40 e0       	ldi	r20, 0x00	; 0
    91a0:	50 e0       	ldi	r21, 0x00	; 0
    91a2:	8c a5       	lds	r24, 0x6c
    91a4:	9d a5       	lds	r25, 0x6d
    91a6:	ae a5       	lds	r26, 0x6e
    91a8:	bf a5       	lds	r27, 0x6f
    91aa:	82 0f       	add	r24, r18
    91ac:	93 1f       	adc	r25, r19
    91ae:	a4 1f       	adc	r26, r20
    91b0:	b5 1f       	adc	r27, r21
    91b2:	27 ec       	ldi	r18, 0xC7	; 199
    91b4:	31 e2       	ldi	r19, 0x21	; 33
    91b6:	bc 01       	movw	r22, r24
    91b8:	cd 01       	movw	r24, r26
    91ba:	a9 01       	movw	r20, r18
    91bc:	20 e0       	ldi	r18, 0x00	; 0
    91be:	32 e0       	ldi	r19, 0x02	; 2
    91c0:	0e 94 b7 4d 	call	0x9b6e	; 0x9b6e <SD_write_block>
		  fileCreatedFlag = 1;
    91c4:	81 e0       	ldi	r24, 0x01	; 1
    91c6:	8a 83       	std	Y+2, r24	; 0x02

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    91c8:	20 91 41 40 	lds	r18, 0x4041
    91cc:	30 91 42 40 	lds	r19, 0x4042
    91d0:	40 91 43 40 	lds	r20, 0x4043
    91d4:	50 91 44 40 	lds	r21, 0x4044
    91d8:	81 e0       	ldi	r24, 0x01	; 1
    91da:	ba 01       	movw	r22, r20
    91dc:	a9 01       	movw	r20, r18
    91de:	0e 94 58 4a 	call	0x94b0	; 0x94b0 <freeMemoryUpdate>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    91e2:	88 a1       	lds	r24, 0x48
    91e4:	99 a1       	lds	r25, 0x49
    91e6:	80 96       	adiw	r24, 0x20	; 32
    91e8:	88 a3       	lds	r24, 0x58
    91ea:	99 a3       	lds	r25, 0x59
    91ec:	28 a1       	lds	r18, 0x48
    91ee:	39 a1       	lds	r19, 0x49
    91f0:	80 91 45 40 	lds	r24, 0x4045
    91f4:	90 91 46 40 	lds	r25, 0x4046
    91f8:	28 17       	cp	r18, r24
    91fa:	39 07       	cpc	r19, r25
    91fc:	08 f4       	brcc	.+2      	; 0x9200 <writeFile+0x6a8>
    91fe:	6d cf       	rjmp	.-294    	; 0x90da <writeFile+0x582>

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    9200:	8d 81       	ldd	r24, Y+5	; 0x05
    9202:	8f 5f       	subi	r24, 0xFF	; 255
    9204:	8d 83       	std	Y+5, r24	; 0x05
    9206:	8d 81       	ldd	r24, Y+5	; 0x05
    9208:	28 2f       	mov	r18, r24
    920a:	30 e0       	ldi	r19, 0x00	; 0
    920c:	80 91 6c 50 	lds	r24, 0x506C
    9210:	90 91 6d 50 	lds	r25, 0x506D
    9214:	28 17       	cp	r18, r24
    9216:	39 07       	cpc	r19, r25
    9218:	08 f4       	brcc	.+2      	; 0x921c <writeFile+0x6c4>
    921a:	48 cf       	rjmp	.-368    	; 0x90ac <writeFile+0x554>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    921c:	88 89       	ldd	r24, Y+16	; 0x10
    921e:	99 89       	ldd	r25, Y+17	; 0x11
    9220:	aa 89       	ldd	r26, Y+18	; 0x12
    9222:	bb 89       	ldd	r27, Y+19	; 0x13
    9224:	bc 01       	movw	r22, r24
    9226:	cd 01       	movw	r24, r26
    9228:	40 e0       	ldi	r20, 0x00	; 0
    922a:	00 e0       	ldi	r16, 0x00	; 0
    922c:	10 e0       	ldi	r17, 0x00	; 0
    922e:	98 01       	movw	r18, r16
    9230:	0e 94 a2 40 	call	0x8144	; 0x8144 <getSetNextCluster>
    9234:	dc 01       	movw	r26, r24
    9236:	cb 01       	movw	r24, r22
    9238:	8c 87       	std	Y+12, r24	; 0x0c
    923a:	9d 87       	std	Y+13, r25	; 0x0d
    923c:	ae 87       	std	Y+14, r26	; 0x0e
    923e:	bf 87       	std	Y+15, r27	; 0x0f

   if(cluster > 0x0ffffff6)
    9240:	8c 85       	ldd	r24, Y+12	; 0x0c
    9242:	9d 85       	ldd	r25, Y+13	; 0x0d
    9244:	ae 85       	ldd	r26, Y+14	; 0x0e
    9246:	bf 85       	ldd	r27, Y+15	; 0x0f
    9248:	87 3f       	cpi	r24, 0xF7	; 247
    924a:	ff ef       	ldi	r31, 0xFF	; 255
    924c:	9f 07       	cpc	r25, r31
    924e:	ff ef       	ldi	r31, 0xFF	; 255
    9250:	af 07       	cpc	r26, r31
    9252:	ff e0       	ldi	r31, 0x0F	; 15
    9254:	bf 07       	cpc	r27, r31
    9256:	b0 f1       	brcs	.+108    	; 0x92c4 <writeFile+0x76c>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    9258:	8c 85       	ldd	r24, Y+12	; 0x0c
    925a:	9d 85       	ldd	r25, Y+13	; 0x0d
    925c:	ae 85       	ldd	r26, Y+14	; 0x0e
    925e:	bf 85       	ldd	r27, Y+15	; 0x0f
    9260:	8f 3f       	cpi	r24, 0xFF	; 255
    9262:	0f ef       	ldi	r16, 0xFF	; 255
    9264:	90 07       	cpc	r25, r16
    9266:	0f ef       	ldi	r16, 0xFF	; 255
    9268:	a0 07       	cpc	r26, r16
    926a:	0f ef       	ldi	r16, 0xFF	; 255
    926c:	b0 07       	cpc	r27, r16
    926e:	41 f5       	brne	.+80     	; 0x92c0 <writeFile+0x768>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    9270:	88 89       	ldd	r24, Y+16	; 0x10
    9272:	99 89       	ldd	r25, Y+17	; 0x11
    9274:	aa 89       	ldd	r26, Y+18	; 0x12
    9276:	bb 89       	ldd	r27, Y+19	; 0x13
    9278:	bc 01       	movw	r22, r24
    927a:	cd 01       	movw	r24, r26
    927c:	0e 94 7f 49 	call	0x92fe	; 0x92fe <searchNextFreeCluster>
    9280:	dc 01       	movw	r26, r24
    9282:	cb 01       	movw	r24, r22
    9284:	8c 87       	std	Y+12, r24	; 0x0c
    9286:	9d 87       	std	Y+13, r25	; 0x0d
    9288:	ae 87       	std	Y+14, r26	; 0x0e
    928a:	bf 87       	std	Y+15, r27	; 0x0f
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    928c:	88 89       	ldd	r24, Y+16	; 0x10
    928e:	99 89       	ldd	r25, Y+17	; 0x11
    9290:	aa 89       	ldd	r26, Y+18	; 0x12
    9292:	bb 89       	ldd	r27, Y+19	; 0x13
    9294:	0c 85       	ldd	r16, Y+12	; 0x0c
    9296:	1d 85       	ldd	r17, Y+13	; 0x0d
    9298:	2e 85       	ldd	r18, Y+14	; 0x0e
    929a:	3f 85       	ldd	r19, Y+15	; 0x0f
    929c:	bc 01       	movw	r22, r24
    929e:	cd 01       	movw	r24, r26
    92a0:	41 e0       	ldi	r20, 0x01	; 1
    92a2:	0e 94 a2 40 	call	0x8144	; 0x8144 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    92a6:	8c 85       	ldd	r24, Y+12	; 0x0c
    92a8:	9d 85       	ldd	r25, Y+13	; 0x0d
    92aa:	ae 85       	ldd	r26, Y+14	; 0x0e
    92ac:	bf 85       	ldd	r27, Y+15	; 0x0f
    92ae:	bc 01       	movw	r22, r24
    92b0:	cd 01       	movw	r24, r26
    92b2:	41 e0       	ldi	r20, 0x01	; 1
    92b4:	0f ef       	ldi	r16, 0xFF	; 255
    92b6:	1f ef       	ldi	r17, 0xFF	; 255
    92b8:	98 01       	movw	r18, r16
    92ba:	0e 94 a2 40 	call	0x8144	; 0x8144 <getSetNextCluster>
    92be:	02 c0       	rjmp	.+4      	; 0x92c4 <writeFile+0x76c>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    92c0:	83 e0       	ldi	r24, 0x03	; 3
    92c2:	13 c0       	rjmp	.+38     	; 0x92ea <writeFile+0x792>
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    92c4:	8c 85       	ldd	r24, Y+12	; 0x0c
    92c6:	9d 85       	ldd	r25, Y+13	; 0x0d
    92c8:	ae 85       	ldd	r26, Y+14	; 0x0e
    92ca:	bf 85       	ldd	r27, Y+15	; 0x0f
    92cc:	00 97       	sbiw	r24, 0x00	; 0
    92ce:	a1 05       	cpc	r26, r1
    92d0:	b1 05       	cpc	r27, r1
    92d2:	11 f4       	brne	.+4      	; 0x92d8 <writeFile+0x780>
	   return 4;
    92d4:	84 e0       	ldi	r24, 0x04	; 4
    92d6:	09 c0       	rjmp	.+18     	; 0x92ea <writeFile+0x792>
	}
   
   prevCluster = cluster;
    92d8:	8c 85       	ldd	r24, Y+12	; 0x0c
    92da:	9d 85       	ldd	r25, Y+13	; 0x0d
    92dc:	ae 85       	ldd	r26, Y+14	; 0x0e
    92de:	bf 85       	ldd	r27, Y+15	; 0x0f
    92e0:	88 8b       	std	Y+16, r24	; 0x10
    92e2:	99 8b       	std	Y+17, r25	; 0x11
    92e4:	aa 8b       	std	Y+18, r26	; 0x12
    92e6:	bb 8b       	std	Y+19, r27	; 0x13
 }
    92e8:	d1 ce       	rjmp	.-606    	; 0x908c <writeFile+0x534>
 
 return 0;
}
    92ea:	e7 96       	adiw	r28, 0x37	; 55
    92ec:	cd bf       	out	0x3d, r28	; 61
    92ee:	de bf       	out	0x3e, r29	; 62
    92f0:	df 91       	pop	r29
    92f2:	cf 91       	pop	r28
    92f4:	1f 91       	pop	r17
    92f6:	0f 91       	pop	r16
    92f8:	ff 90       	pop	r15
    92fa:	ef 90       	pop	r14
    92fc:	08 95       	ret

000092fe <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    92fe:	ef 92       	push	r14
    9300:	ff 92       	push	r15
    9302:	0f 93       	push	r16
    9304:	1f 93       	push	r17
    9306:	cf 93       	push	r28
    9308:	df 93       	push	r29
    930a:	cd b7       	in	r28, 0x3d	; 61
    930c:	de b7       	in	r29, 0x3e	; 62
    930e:	2f 97       	sbiw	r28, 0x0f	; 15
    9310:	cd bf       	out	0x3d, r28	; 61
    9312:	de bf       	out	0x3e, r29	; 62
    9314:	6c 87       	std	Y+12, r22	; 0x0c
    9316:	7d 87       	std	Y+13, r23	; 0x0d
    9318:	8e 87       	std	Y+14, r24	; 0x0e
    931a:	9f 87       	std	Y+15, r25	; 0x0f
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    931c:	8c 85       	ldd	r24, Y+12	; 0x0c
    931e:	9d 85       	ldd	r25, Y+13	; 0x0d
    9320:	ae 85       	ldd	r26, Y+14	; 0x0e
    9322:	bf 85       	ldd	r27, Y+15	; 0x0f
    9324:	80 78       	andi	r24, 0x80	; 128
    9326:	8c 87       	std	Y+12, r24	; 0x0c
    9328:	9d 87       	std	Y+13, r25	; 0x0d
    932a:	ae 87       	std	Y+14, r26	; 0x0e
    932c:	bf 87       	std	Y+15, r27	; 0x0f
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    932e:	8c 85       	ldd	r24, Y+12	; 0x0c
    9330:	9d 85       	ldd	r25, Y+13	; 0x0d
    9332:	ae 85       	ldd	r26, Y+14	; 0x0e
    9334:	bf 85       	ldd	r27, Y+15	; 0x0f
    9336:	89 83       	std	Y+1, r24	; 0x01
    9338:	9a 83       	std	Y+2, r25	; 0x02
    933a:	ab 83       	std	Y+3, r26	; 0x03
    933c:	bc 83       	std	Y+4, r27	; 0x04
    933e:	7a c0       	rjmp	.+244    	; 0x9434 <searchNextFreeCluster+0x136>
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    9340:	80 91 74 50 	lds	r24, 0x5074
    9344:	90 91 75 50 	lds	r25, 0x5075
    9348:	9c 01       	movw	r18, r24
    934a:	40 e0       	ldi	r20, 0x00	; 0
    934c:	50 e0       	ldi	r21, 0x00	; 0
    934e:	80 91 6e 50 	lds	r24, 0x506E
    9352:	90 91 6f 50 	lds	r25, 0x506F
    9356:	a0 91 70 50 	lds	r26, 0x5070
    935a:	b0 91 71 50 	lds	r27, 0x5071
    935e:	79 01       	movw	r14, r18
    9360:	8a 01       	movw	r16, r20
    9362:	e8 0e       	add	r14, r24
    9364:	f9 1e       	adc	r15, r25
    9366:	0a 1f       	adc	r16, r26
    9368:	1b 1f       	adc	r17, r27
    936a:	89 81       	ldd	r24, Y+1	; 0x01
    936c:	9a 81       	ldd	r25, Y+2	; 0x02
    936e:	ab 81       	ldd	r26, Y+3	; 0x03
    9370:	bc 81       	ldd	r27, Y+4	; 0x04
    9372:	88 0f       	add	r24, r24
    9374:	99 1f       	adc	r25, r25
    9376:	aa 1f       	adc	r26, r26
    9378:	bb 1f       	adc	r27, r27
    937a:	88 0f       	add	r24, r24
    937c:	99 1f       	adc	r25, r25
    937e:	aa 1f       	adc	r26, r26
    9380:	bb 1f       	adc	r27, r27
    9382:	20 91 45 40 	lds	r18, 0x4045
    9386:	30 91 46 40 	lds	r19, 0x4046
    938a:	99 01       	movw	r18, r18
    938c:	40 e0       	ldi	r20, 0x00	; 0
    938e:	50 e0       	ldi	r21, 0x00	; 0
    9390:	bc 01       	movw	r22, r24
    9392:	cd 01       	movw	r24, r26
    9394:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    9398:	da 01       	movw	r26, r20
    939a:	c9 01       	movw	r24, r18
    939c:	8e 0d       	add	r24, r14
    939e:	9f 1d       	adc	r25, r15
    93a0:	a0 1f       	adc	r26, r16
    93a2:	b1 1f       	adc	r27, r17
    93a4:	8e 83       	std	Y+6, r24	; 0x06
    93a6:	9f 83       	std	Y+7, r25	; 0x07
    93a8:	a8 87       	std	Y+8, r26	; 0x08
    93aa:	b9 87       	std	Y+9, r27	; 0x09
      SD_read_block(sector,SDBuffer);
    93ac:	8e 81       	ldd	r24, Y+6	; 0x06
    93ae:	9f 81       	ldd	r25, Y+7	; 0x07
    93b0:	a8 85       	ldd	r26, Y+8	; 0x08
    93b2:	b9 85       	ldd	r27, Y+9	; 0x09
    93b4:	27 ec       	ldi	r18, 0xC7	; 199
    93b6:	31 e2       	ldi	r19, 0x21	; 33
    93b8:	bc 01       	movw	r22, r24
    93ba:	cd 01       	movw	r24, r26
    93bc:	a9 01       	movw	r20, r18
    93be:	0e 94 85 4e 	call	0x9d0a	; 0x9d0a <SD_read_block>
      for(i=0; i<128; i++)
    93c2:	1d 82       	std	Y+5, r1	; 0x05
    93c4:	28 c0       	rjmp	.+80     	; 0x9416 <searchNextFreeCluster+0x118>
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    93c6:	8d 81       	ldd	r24, Y+5	; 0x05
    93c8:	88 2f       	mov	r24, r24
    93ca:	90 e0       	ldi	r25, 0x00	; 0
    93cc:	88 0f       	add	r24, r24
    93ce:	99 1f       	adc	r25, r25
    93d0:	88 0f       	add	r24, r24
    93d2:	99 1f       	adc	r25, r25
    93d4:	89 53       	subi	r24, 0x39	; 57
    93d6:	9e 4d       	sbci	r25, 0xDE	; 222
    93d8:	8a 87       	std	Y+10, r24	; 0x0a
    93da:	9b 87       	std	Y+11, r25	; 0x0b
         if(((*value) & 0x0fffffff) == 0)
    93dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    93de:	9b 85       	ldd	r25, Y+11	; 0x0b
    93e0:	fc 01       	movw	r30, r24
    93e2:	80 81       	ld	r24, Z
    93e4:	91 81       	ldd	r25, Z+1	; 0x01
    93e6:	a2 81       	ldd	r26, Z+2	; 0x02
    93e8:	b3 81       	ldd	r27, Z+3	; 0x03
    93ea:	bf 70       	andi	r27, 0x0F	; 15
    93ec:	00 97       	sbiw	r24, 0x00	; 0
    93ee:	a1 05       	cpc	r26, r1
    93f0:	b1 05       	cpc	r27, r1
    93f2:	71 f4       	brne	.+28     	; 0x9410 <searchNextFreeCluster+0x112>
            return(cluster+i);
    93f4:	8d 81       	ldd	r24, Y+5	; 0x05
    93f6:	28 2f       	mov	r18, r24
    93f8:	30 e0       	ldi	r19, 0x00	; 0
    93fa:	40 e0       	ldi	r20, 0x00	; 0
    93fc:	50 e0       	ldi	r21, 0x00	; 0
    93fe:	89 81       	ldd	r24, Y+1	; 0x01
    9400:	9a 81       	ldd	r25, Y+2	; 0x02
    9402:	ab 81       	ldd	r26, Y+3	; 0x03
    9404:	bc 81       	ldd	r27, Y+4	; 0x04
    9406:	82 0f       	add	r24, r18
    9408:	93 1f       	adc	r25, r19
    940a:	a4 1f       	adc	r26, r20
    940c:	b5 1f       	adc	r27, r21
    940e:	27 c0       	rjmp	.+78     	; 0x945e <searchNextFreeCluster+0x160>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    9410:	8d 81       	ldd	r24, Y+5	; 0x05
    9412:	8f 5f       	subi	r24, 0xFF	; 255
    9414:	8d 83       	std	Y+5, r24	; 0x05
    9416:	8d 81       	ldd	r24, Y+5	; 0x05
    9418:	88 23       	and	r24, r24
    941a:	ac f6       	brge	.-86     	; 0x93c6 <searchNextFreeCluster+0xc8>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    941c:	89 81       	ldd	r24, Y+1	; 0x01
    941e:	9a 81       	ldd	r25, Y+2	; 0x02
    9420:	ab 81       	ldd	r26, Y+3	; 0x03
    9422:	bc 81       	ldd	r27, Y+4	; 0x04
    9424:	80 58       	subi	r24, 0x80	; 128
    9426:	9f 4f       	sbci	r25, 0xFF	; 255
    9428:	af 4f       	sbci	r26, 0xFF	; 255
    942a:	bf 4f       	sbci	r27, 0xFF	; 255
    942c:	89 83       	std	Y+1, r24	; 0x01
    942e:	9a 83       	std	Y+2, r25	; 0x02
    9430:	ab 83       	std	Y+3, r26	; 0x03
    9432:	bc 83       	std	Y+4, r27	; 0x04
    9434:	80 91 4a 40 	lds	r24, 0x404A
    9438:	90 91 4b 40 	lds	r25, 0x404B
    943c:	a0 91 4c 40 	lds	r26, 0x404C
    9440:	b0 91 4d 40 	lds	r27, 0x404D
    9444:	29 81       	ldd	r18, Y+1	; 0x01
    9446:	3a 81       	ldd	r19, Y+2	; 0x02
    9448:	4b 81       	ldd	r20, Y+3	; 0x03
    944a:	5c 81       	ldd	r21, Y+4	; 0x04
    944c:	28 17       	cp	r18, r24
    944e:	39 07       	cpc	r19, r25
    9450:	4a 07       	cpc	r20, r26
    9452:	5b 07       	cpc	r21, r27
    9454:	08 f4       	brcc	.+2      	; 0x9458 <searchNextFreeCluster+0x15a>
    9456:	74 cf       	rjmp	.-280    	; 0x9340 <searchNextFreeCluster+0x42>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    9458:	80 e0       	ldi	r24, 0x00	; 0
    945a:	90 e0       	ldi	r25, 0x00	; 0
    945c:	dc 01       	movw	r26, r24
}
    945e:	bc 01       	movw	r22, r24
    9460:	cd 01       	movw	r24, r26
    9462:	2f 96       	adiw	r28, 0x0f	; 15
    9464:	cd bf       	out	0x3d, r28	; 61
    9466:	de bf       	out	0x3e, r29	; 62
    9468:	df 91       	pop	r29
    946a:	cf 91       	pop	r28
    946c:	1f 91       	pop	r17
    946e:	0f 91       	pop	r16
    9470:	ff 90       	pop	r15
    9472:	ef 90       	pop	r14
    9474:	08 95       	ret

00009476 <deleteFile>:
//Function: to delete a specified file from the root directory
//Arguments: pointer to the file name
//return: none
//********************************************************************
void deleteFile (unsigned char *fileName)
{
    9476:	cf 93       	push	r28
    9478:	df 93       	push	r29
    947a:	00 d0       	rcall	.+0      	; 0x947c <deleteFile+0x6>
    947c:	cd b7       	in	r28, 0x3d	; 61
    947e:	de b7       	in	r29, 0x3e	; 62
    9480:	8a 83       	std	Y+2, r24	; 0x02
    9482:	9b 83       	std	Y+3, r25	; 0x03
  unsigned char error;

  error = convertFileName (fileName);
    9484:	8a 81       	ldd	r24, Y+2	; 0x02
    9486:	9b 81       	ldd	r25, Y+3	; 0x03
    9488:	0e 94 76 44 	call	0x88ec	; 0x88ec <convertFileName>
    948c:	89 83       	std	Y+1, r24	; 0x01
  if(error) return;
    948e:	89 81       	ldd	r24, Y+1	; 0x01
    9490:	88 23       	and	r24, r24
    9492:	39 f4       	brne	.+14     	; 0x94a2 <deleteFile+0x2c>

  findFiles (DELETE, Filename);
    9494:	2c ea       	ldi	r18, 0xAC	; 172
    9496:	30 e5       	ldi	r19, 0x50	; 80
    9498:	82 e0       	ldi	r24, 0x02	; 2
    949a:	b9 01       	movw	r22, r18
    949c:	0e 94 fc 41 	call	0x83f8	; 0x83f8 <findFiles>
    94a0:	01 c0       	rjmp	.+2      	; 0x94a4 <deleteFile+0x2e>
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
  if(error) return;
    94a2:	00 00       	nop

  findFiles (DELETE, Filename);
}
    94a4:	23 96       	adiw	r28, 0x03	; 3
    94a6:	cd bf       	out	0x3d, r28	; 61
    94a8:	de bf       	out	0x3e, r29	; 62
    94aa:	df 91       	pop	r29
    94ac:	cf 91       	pop	r28
    94ae:	08 95       	ret

000094b0 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    94b0:	ef 92       	push	r14
    94b2:	ff 92       	push	r15
    94b4:	0f 93       	push	r16
    94b6:	1f 93       	push	r17
    94b8:	cf 93       	push	r28
    94ba:	df 93       	push	r29
    94bc:	cd b7       	in	r28, 0x3d	; 61
    94be:	de b7       	in	r29, 0x3e	; 62
    94c0:	29 97       	sbiw	r28, 0x09	; 9
    94c2:	cd bf       	out	0x3d, r28	; 61
    94c4:	de bf       	out	0x3e, r29	; 62
    94c6:	8d 83       	std	Y+5, r24	; 0x05
    94c8:	4e 83       	std	Y+6, r20	; 0x06
    94ca:	5f 83       	std	Y+7, r21	; 0x07
    94cc:	68 87       	std	Y+8, r22	; 0x08
    94ce:	79 87       	std	Y+9, r23	; 0x09
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    94d0:	8e 81       	ldd	r24, Y+6	; 0x06
    94d2:	9f 81       	ldd	r25, Y+7	; 0x07
    94d4:	a8 85       	ldd	r26, Y+8	; 0x08
    94d6:	b9 85       	ldd	r27, Y+9	; 0x09
    94d8:	91 70       	andi	r25, 0x01	; 1
    94da:	a0 70       	andi	r26, 0x00	; 0
    94dc:	b0 70       	andi	r27, 0x00	; 0
    94de:	00 97       	sbiw	r24, 0x00	; 0
    94e0:	a1 05       	cpc	r26, r1
    94e2:	b1 05       	cpc	r27, r1
    94e4:	91 f4       	brne	.+36     	; 0x950a <freeMemoryUpdate+0x5a>
    94e6:	8e 81       	ldd	r24, Y+6	; 0x06
    94e8:	9f 81       	ldd	r25, Y+7	; 0x07
    94ea:	a8 85       	ldd	r26, Y+8	; 0x08
    94ec:	b9 85       	ldd	r27, Y+9	; 0x09
    94ee:	07 2e       	mov	r0, r23
    94f0:	79 e0       	ldi	r23, 0x09	; 9
    94f2:	b6 95       	lsr	r27
    94f4:	a7 95       	ror	r26
    94f6:	97 95       	ror	r25
    94f8:	87 95       	ror	r24
    94fa:	7a 95       	dec	r23
    94fc:	d1 f7       	brne	.-12     	; 0x94f2 <freeMemoryUpdate+0x42>
    94fe:	70 2d       	mov	r23, r0
    9500:	8e 83       	std	Y+6, r24	; 0x06
    9502:	9f 83       	std	Y+7, r25	; 0x07
    9504:	a8 87       	std	Y+8, r26	; 0x08
    9506:	b9 87       	std	Y+9, r27	; 0x09
    9508:	14 c0       	rjmp	.+40     	; 0x9532 <freeMemoryUpdate+0x82>
  else size = (size / 512) +1;
    950a:	8e 81       	ldd	r24, Y+6	; 0x06
    950c:	9f 81       	ldd	r25, Y+7	; 0x07
    950e:	a8 85       	ldd	r26, Y+8	; 0x08
    9510:	b9 85       	ldd	r27, Y+9	; 0x09
    9512:	07 2e       	mov	r0, r23
    9514:	79 e0       	ldi	r23, 0x09	; 9
    9516:	b6 95       	lsr	r27
    9518:	a7 95       	ror	r26
    951a:	97 95       	ror	r25
    951c:	87 95       	ror	r24
    951e:	7a 95       	dec	r23
    9520:	d1 f7       	brne	.-12     	; 0x9516 <freeMemoryUpdate+0x66>
    9522:	70 2d       	mov	r23, r0
    9524:	01 96       	adiw	r24, 0x01	; 1
    9526:	a1 1d       	adc	r26, r1
    9528:	b1 1d       	adc	r27, r1
    952a:	8e 83       	std	Y+6, r24	; 0x06
    952c:	9f 83       	std	Y+7, r25	; 0x07
    952e:	a8 87       	std	Y+8, r26	; 0x08
    9530:	b9 87       	std	Y+9, r27	; 0x09
  if((size % 8) == 0) size = size / 8;
    9532:	8e 81       	ldd	r24, Y+6	; 0x06
    9534:	9f 81       	ldd	r25, Y+7	; 0x07
    9536:	a8 85       	ldd	r26, Y+8	; 0x08
    9538:	b9 85       	ldd	r27, Y+9	; 0x09
    953a:	87 70       	andi	r24, 0x07	; 7
    953c:	90 70       	andi	r25, 0x00	; 0
    953e:	a0 70       	andi	r26, 0x00	; 0
    9540:	b0 70       	andi	r27, 0x00	; 0
    9542:	00 97       	sbiw	r24, 0x00	; 0
    9544:	a1 05       	cpc	r26, r1
    9546:	b1 05       	cpc	r27, r1
    9548:	89 f4       	brne	.+34     	; 0x956c <freeMemoryUpdate+0xbc>
    954a:	8e 81       	ldd	r24, Y+6	; 0x06
    954c:	9f 81       	ldd	r25, Y+7	; 0x07
    954e:	a8 85       	ldd	r26, Y+8	; 0x08
    9550:	b9 85       	ldd	r27, Y+9	; 0x09
    9552:	68 94       	set
    9554:	12 f8       	bld	r1, 2
    9556:	b6 95       	lsr	r27
    9558:	a7 95       	ror	r26
    955a:	97 95       	ror	r25
    955c:	87 95       	ror	r24
    955e:	16 94       	lsr	r1
    9560:	d1 f7       	brne	.-12     	; 0x9556 <freeMemoryUpdate+0xa6>
    9562:	8e 83       	std	Y+6, r24	; 0x06
    9564:	9f 83       	std	Y+7, r25	; 0x07
    9566:	a8 87       	std	Y+8, r26	; 0x08
    9568:	b9 87       	std	Y+9, r27	; 0x09
    956a:	13 c0       	rjmp	.+38     	; 0x9592 <freeMemoryUpdate+0xe2>
  else size = (size / 8) +1;
    956c:	8e 81       	ldd	r24, Y+6	; 0x06
    956e:	9f 81       	ldd	r25, Y+7	; 0x07
    9570:	a8 85       	ldd	r26, Y+8	; 0x08
    9572:	b9 85       	ldd	r27, Y+9	; 0x09
    9574:	68 94       	set
    9576:	12 f8       	bld	r1, 2
    9578:	b6 95       	lsr	r27
    957a:	a7 95       	ror	r26
    957c:	97 95       	ror	r25
    957e:	87 95       	ror	r24
    9580:	16 94       	lsr	r1
    9582:	d1 f7       	brne	.-12     	; 0x9578 <freeMemoryUpdate+0xc8>
    9584:	01 96       	adiw	r24, 0x01	; 1
    9586:	a1 1d       	adc	r26, r1
    9588:	b1 1d       	adc	r27, r1
    958a:	8e 83       	std	Y+6, r24	; 0x06
    958c:	9f 83       	std	Y+7, r25	; 0x07
    958e:	a8 87       	std	Y+8, r26	; 0x08
    9590:	b9 87       	std	Y+9, r27	; 0x09

  if(freeClusterCountUpdated)
    9592:	80 91 c0 50 	lds	r24, 0x50C0
    9596:	88 23       	and	r24, r24
    9598:	e9 f1       	breq	.+122    	; 0x9614 <freeMemoryUpdate+0x164>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    959a:	81 e0       	ldi	r24, 0x01	; 1
    959c:	60 e0       	ldi	r22, 0x00	; 0
    959e:	20 e0       	ldi	r18, 0x00	; 0
    95a0:	30 e0       	ldi	r19, 0x00	; 0
    95a2:	a9 01       	movw	r20, r18
    95a4:	0e 94 4b 41 	call	0x8296	; 0x8296 <getSetFreeCluster>
    95a8:	dc 01       	movw	r26, r24
    95aa:	cb 01       	movw	r24, r22
    95ac:	89 83       	std	Y+1, r24	; 0x01
    95ae:	9a 83       	std	Y+2, r25	; 0x02
    95b0:	ab 83       	std	Y+3, r26	; 0x03
    95b2:	bc 83       	std	Y+4, r27	; 0x04
	if(flag == ADD)
    95b4:	8d 81       	ldd	r24, Y+5	; 0x05
    95b6:	88 23       	and	r24, r24
    95b8:	89 f4       	brne	.+34     	; 0x95dc <freeMemoryUpdate+0x12c>
  	   freeClusters = freeClusters + size;
    95ba:	29 81       	ldd	r18, Y+1	; 0x01
    95bc:	3a 81       	ldd	r19, Y+2	; 0x02
    95be:	4b 81       	ldd	r20, Y+3	; 0x03
    95c0:	5c 81       	ldd	r21, Y+4	; 0x04
    95c2:	8e 81       	ldd	r24, Y+6	; 0x06
    95c4:	9f 81       	ldd	r25, Y+7	; 0x07
    95c6:	a8 85       	ldd	r26, Y+8	; 0x08
    95c8:	b9 85       	ldd	r27, Y+9	; 0x09
    95ca:	82 0f       	add	r24, r18
    95cc:	93 1f       	adc	r25, r19
    95ce:	a4 1f       	adc	r26, r20
    95d0:	b5 1f       	adc	r27, r21
    95d2:	89 83       	std	Y+1, r24	; 0x01
    95d4:	9a 83       	std	Y+2, r25	; 0x02
    95d6:	ab 83       	std	Y+3, r26	; 0x03
    95d8:	bc 83       	std	Y+4, r27	; 0x04
    95da:	14 c0       	rjmp	.+40     	; 0x9604 <freeMemoryUpdate+0x154>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    95dc:	29 81       	ldd	r18, Y+1	; 0x01
    95de:	3a 81       	ldd	r19, Y+2	; 0x02
    95e0:	4b 81       	ldd	r20, Y+3	; 0x03
    95e2:	5c 81       	ldd	r21, Y+4	; 0x04
    95e4:	8e 81       	ldd	r24, Y+6	; 0x06
    95e6:	9f 81       	ldd	r25, Y+7	; 0x07
    95e8:	a8 85       	ldd	r26, Y+8	; 0x08
    95ea:	b9 85       	ldd	r27, Y+9	; 0x09
    95ec:	79 01       	movw	r14, r18
    95ee:	8a 01       	movw	r16, r20
    95f0:	e8 1a       	sub	r14, r24
    95f2:	f9 0a       	sbc	r15, r25
    95f4:	0a 0b       	sbc	r16, r26
    95f6:	1b 0b       	sbc	r17, r27
    95f8:	d8 01       	movw	r26, r16
    95fa:	c7 01       	movw	r24, r14
    95fc:	89 83       	std	Y+1, r24	; 0x01
    95fe:	9a 83       	std	Y+2, r25	; 0x02
    9600:	ab 83       	std	Y+3, r26	; 0x03
    9602:	bc 83       	std	Y+4, r27	; 0x04
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    9604:	29 81       	ldd	r18, Y+1	; 0x01
    9606:	3a 81       	ldd	r19, Y+2	; 0x02
    9608:	4b 81       	ldd	r20, Y+3	; 0x03
    960a:	5c 81       	ldd	r21, Y+4	; 0x04
    960c:	81 e0       	ldi	r24, 0x01	; 1
    960e:	61 e0       	ldi	r22, 0x01	; 1
    9610:	0e 94 4b 41 	call	0x8296	; 0x8296 <getSetFreeCluster>
  }
}
    9614:	29 96       	adiw	r28, 0x09	; 9
    9616:	cd bf       	out	0x3d, r28	; 61
    9618:	de bf       	out	0x3e, r29	; 62
    961a:	df 91       	pop	r29
    961c:	cf 91       	pop	r28
    961e:	1f 91       	pop	r17
    9620:	0f 91       	pop	r16
    9622:	ff 90       	pop	r15
    9624:	ef 90       	pop	r14
    9626:	08 95       	ret

00009628 <SD_init>:
# include "E-000001-000009_firmware_rev_1_0.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    9628:	0f 93       	push	r16
    962a:	1f 93       	push	r17
    962c:	cf 93       	push	r28
    962e:	df 93       	push	r29
    9630:	cd b7       	in	r28, 0x3d	; 61
    9632:	de b7       	in	r29, 0x3e	; 62
    9634:	a9 97       	sbiw	r28, 0x29	; 41
    9636:	cd bf       	out	0x3d, r28	; 61
    9638:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);				//power up portEX
    963a:	81 e0       	ldi	r24, 0x01	; 1
    963c:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    9640:	81 e0       	ldi	r24, 0x01	; 1
    9642:	0e 94 33 34 	call	0x6866	; 0x6866 <Ext1Power>
    9646:	80 e0       	ldi	r24, 0x00	; 0
    9648:	90 e0       	ldi	r25, 0x00	; 0
    964a:	a8 ec       	ldi	r26, 0xC8	; 200
    964c:	b2 e4       	ldi	r27, 0x42	; 66
    964e:	8e 87       	std	Y+14, r24	; 0x0e
    9650:	9f 87       	std	Y+15, r25	; 0x0f
    9652:	a8 8b       	std	Y+16, r26	; 0x10
    9654:	b9 8b       	std	Y+17, r27	; 0x11
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    9656:	6e 85       	ldd	r22, Y+14	; 0x0e
    9658:	7f 85       	ldd	r23, Y+15	; 0x0f
    965a:	88 89       	ldd	r24, Y+16	; 0x10
    965c:	99 89       	ldd	r25, Y+17	; 0x11
    965e:	20 e0       	ldi	r18, 0x00	; 0
    9660:	30 e0       	ldi	r19, 0x00	; 0
    9662:	4a ef       	ldi	r20, 0xFA	; 250
    9664:	55 e4       	ldi	r21, 0x45	; 69
    9666:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    966a:	dc 01       	movw	r26, r24
    966c:	cb 01       	movw	r24, r22
    966e:	8a 8b       	std	Y+18, r24	; 0x12
    9670:	9b 8b       	std	Y+19, r25	; 0x13
    9672:	ac 8b       	std	Y+20, r26	; 0x14
    9674:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
    9676:	11 e0       	ldi	r17, 0x01	; 1
    9678:	6a 89       	ldd	r22, Y+18	; 0x12
    967a:	7b 89       	ldd	r23, Y+19	; 0x13
    967c:	8c 89       	ldd	r24, Y+20	; 0x14
    967e:	9d 89       	ldd	r25, Y+21	; 0x15
    9680:	20 e0       	ldi	r18, 0x00	; 0
    9682:	30 e0       	ldi	r19, 0x00	; 0
    9684:	40 e8       	ldi	r20, 0x80	; 128
    9686:	5f e3       	ldi	r21, 0x3F	; 63
    9688:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    968c:	88 23       	and	r24, r24
    968e:	0c f0       	brlt	.+2      	; 0x9692 <SD_init+0x6a>
    9690:	10 e0       	ldi	r17, 0x00	; 0
    9692:	11 23       	and	r17, r17
    9694:	29 f0       	breq	.+10     	; 0x96a0 <SD_init+0x78>
		__ticks = 1;
    9696:	81 e0       	ldi	r24, 0x01	; 1
    9698:	90 e0       	ldi	r25, 0x00	; 0
    969a:	8e 8b       	std	Y+22, r24	; 0x16
    969c:	9f 8b       	std	Y+23, r25	; 0x17
    969e:	46 c0       	rjmp	.+140    	; 0x972c <SD_init+0x104>
	else if (__tmp > 65535)
    96a0:	11 e0       	ldi	r17, 0x01	; 1
    96a2:	6a 89       	ldd	r22, Y+18	; 0x12
    96a4:	7b 89       	ldd	r23, Y+19	; 0x13
    96a6:	8c 89       	ldd	r24, Y+20	; 0x14
    96a8:	9d 89       	ldd	r25, Y+21	; 0x15
    96aa:	20 e0       	ldi	r18, 0x00	; 0
    96ac:	3f ef       	ldi	r19, 0xFF	; 255
    96ae:	4f e7       	ldi	r20, 0x7F	; 127
    96b0:	57 e4       	ldi	r21, 0x47	; 71
    96b2:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    96b6:	18 16       	cp	r1, r24
    96b8:	0c f0       	brlt	.+2      	; 0x96bc <SD_init+0x94>
    96ba:	10 e0       	ldi	r17, 0x00	; 0
    96bc:	11 23       	and	r17, r17
    96be:	61 f1       	breq	.+88     	; 0x9718 <SD_init+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    96c0:	6e 85       	ldd	r22, Y+14	; 0x0e
    96c2:	7f 85       	ldd	r23, Y+15	; 0x0f
    96c4:	88 89       	ldd	r24, Y+16	; 0x10
    96c6:	99 89       	ldd	r25, Y+17	; 0x11
    96c8:	20 e0       	ldi	r18, 0x00	; 0
    96ca:	30 e0       	ldi	r19, 0x00	; 0
    96cc:	40 e2       	ldi	r20, 0x20	; 32
    96ce:	51 e4       	ldi	r21, 0x41	; 65
    96d0:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    96d4:	dc 01       	movw	r26, r24
    96d6:	cb 01       	movw	r24, r22
    96d8:	bc 01       	movw	r22, r24
    96da:	cd 01       	movw	r24, r26
    96dc:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    96e0:	dc 01       	movw	r26, r24
    96e2:	cb 01       	movw	r24, r22
    96e4:	8e 8b       	std	Y+22, r24	; 0x16
    96e6:	9f 8b       	std	Y+23, r25	; 0x17
    96e8:	12 c0       	rjmp	.+36     	; 0x970e <SD_init+0xe6>
    96ea:	80 e2       	ldi	r24, 0x20	; 32
    96ec:	93 e0       	ldi	r25, 0x03	; 3
    96ee:	88 8f       	std	Y+24, r24	; 0x18
    96f0:	99 8f       	std	Y+25, r25	; 0x19
    96f2:	88 8d       	ldd	r24, Y+24	; 0x18
    96f4:	99 8d       	ldd	r25, Y+25	; 0x19
    96f6:	8c 01       	movw	r16, r24
    96f8:	c8 01       	movw	r24, r16
    96fa:	01 97       	sbiw	r24, 0x01	; 1
    96fc:	f1 f7       	brne	.-4      	; 0x96fa <SD_init+0xd2>
    96fe:	8c 01       	movw	r16, r24
    9700:	08 8f       	std	Y+24, r16	; 0x18
    9702:	19 8f       	std	Y+25, r17	; 0x19
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    9704:	8e 89       	ldd	r24, Y+22	; 0x16
    9706:	9f 89       	ldd	r25, Y+23	; 0x17
    9708:	01 97       	sbiw	r24, 0x01	; 1
    970a:	8e 8b       	std	Y+22, r24	; 0x16
    970c:	9f 8b       	std	Y+23, r25	; 0x17
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    970e:	8e 89       	ldd	r24, Y+22	; 0x16
    9710:	9f 89       	ldd	r25, Y+23	; 0x17
    9712:	00 97       	sbiw	r24, 0x00	; 0
    9714:	51 f7       	brne	.-44     	; 0x96ea <SD_init+0xc2>
    9716:	17 c0       	rjmp	.+46     	; 0x9746 <SD_init+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    9718:	6a 89       	ldd	r22, Y+18	; 0x12
    971a:	7b 89       	ldd	r23, Y+19	; 0x13
    971c:	8c 89       	ldd	r24, Y+20	; 0x14
    971e:	9d 89       	ldd	r25, Y+21	; 0x15
    9720:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    9724:	dc 01       	movw	r26, r24
    9726:	cb 01       	movw	r24, r22
    9728:	8e 8b       	std	Y+22, r24	; 0x16
    972a:	9f 8b       	std	Y+23, r25	; 0x17
    972c:	8e 89       	ldd	r24, Y+22	; 0x16
    972e:	9f 89       	ldd	r25, Y+23	; 0x17
    9730:	8a 8f       	std	Y+26, r24	; 0x1a
    9732:	9b 8f       	std	Y+27, r25	; 0x1b
    9734:	8a 8d       	ldd	r24, Y+26	; 0x1a
    9736:	9b 8d       	ldd	r25, Y+27	; 0x1b
    9738:	8c 01       	movw	r16, r24
    973a:	f8 01       	movw	r30, r16
    973c:	31 97       	sbiw	r30, 0x01	; 1
    973e:	f1 f7       	brne	.-4      	; 0x973c <SD_init+0x114>
    9740:	8f 01       	movw	r16, r30
    9742:	0a 8f       	std	Y+26, r16	; 0x1a
    9744:	1b 8f       	std	Y+27, r17	; 0x1b
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    9746:	19 82       	std	Y+1, r1	; 0x01

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    9748:	88 e0       	ldi	r24, 0x08	; 8
    974a:	60 e0       	ldi	r22, 0x00	; 0
    974c:	0e 94 9d 32 	call	0x653a	; 0x653a <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9750:	88 e0       	ldi	r24, 0x08	; 8
    9752:	60 e0       	ldi	r22, 0x00	; 0
    9754:	0e 94 69 33 	call	0x66d2	; 0x66d2 <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    9758:	80 e0       	ldi	r24, 0x00	; 0
    975a:	63 e0       	ldi	r22, 0x03	; 3
    975c:	0e 94 61 37 	call	0x6ec2	; 0x6ec2 <SPIInit2>
	SPICS(TRUE);
    9760:	81 e0       	ldi	r24, 0x01	; 1
    9762:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9766:	1a 82       	std	Y+2, r1	; 0x02
    9768:	1b 82       	std	Y+3, r1	; 0x03
    976a:	17 c0       	rjmp	.+46     	; 0x979a <SD_init+0x172>
		SPIC.DATA=SDHC_DUMMY_BYTE;
    976c:	80 ec       	ldi	r24, 0xC0	; 192
    976e:	98 e0       	ldi	r25, 0x08	; 8
    9770:	2f ef       	ldi	r18, 0xFF	; 255
    9772:	fc 01       	movw	r30, r24
    9774:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9776:	00 00       	nop
    9778:	80 ec       	ldi	r24, 0xC0	; 192
    977a:	98 e0       	ldi	r25, 0x08	; 8
    977c:	fc 01       	movw	r30, r24
    977e:	82 81       	ldd	r24, Z+2	; 0x02
    9780:	88 23       	and	r24, r24
    9782:	d4 f7       	brge	.-12     	; 0x9778 <SD_init+0x150>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    9784:	80 ec       	ldi	r24, 0xC0	; 192
    9786:	98 e0       	ldi	r25, 0x08	; 8
    9788:	fc 01       	movw	r30, r24
    978a:	83 81       	ldd	r24, Z+3	; 0x03
    978c:	80 93 ab 50 	sts	0x50AB, r24
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9790:	8a 81       	ldd	r24, Y+2	; 0x02
    9792:	9b 81       	ldd	r25, Y+3	; 0x03
    9794:	01 96       	adiw	r24, 0x01	; 1
    9796:	8a 83       	std	Y+2, r24	; 0x02
    9798:	9b 83       	std	Y+3, r25	; 0x03
    979a:	8a 81       	ldd	r24, Y+2	; 0x02
    979c:	9b 81       	ldd	r25, Y+3	; 0x03
    979e:	8a 30       	cpi	r24, 0x0A	; 10
    97a0:	91 05       	cpc	r25, r1
    97a2:	24 f3       	brlt	.-56     	; 0x976c <SD_init+0x144>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    97a4:	80 e0       	ldi	r24, 0x00	; 0
    97a6:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	SPIDisable();
    97aa:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    97ae:	88 e0       	ldi	r24, 0x08	; 8
    97b0:	60 e0       	ldi	r22, 0x00	; 0
    97b2:	0e 94 cc 33 	call	0x6798	; 0x6798 <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    97b6:	80 e0       	ldi	r24, 0x00	; 0
    97b8:	63 e0       	ldi	r22, 0x03	; 3
    97ba:	0e 94 61 37 	call	0x6ec2	; 0x6ec2 <SPIInit2>
	SPICS(TRUE);
    97be:	81 e0       	ldi	r24, 0x01	; 1
    97c0:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    97c4:	1c 82       	std	Y+4, r1	; 0x04
    97c6:	1d 82       	std	Y+5, r1	; 0x05
    97c8:	0d c0       	rjmp	.+26     	; 0x97e4 <SD_init+0x1bc>
		if (i >= 10) {												//try command 10 times before timing out
    97ca:	8c 81       	ldd	r24, Y+4	; 0x04
    97cc:	9d 81       	ldd	r25, Y+5	; 0x05
    97ce:	8a 30       	cpi	r24, 0x0A	; 10
    97d0:	91 05       	cpc	r25, r1
    97d2:	1c f0       	brlt	.+6      	; 0x97da <SD_init+0x1b2>
			//there was no response to the first command
			errorCode = 1;
    97d4:	81 e0       	ldi	r24, 0x01	; 1
    97d6:	89 83       	std	Y+1, r24	; 0x01
			break;
    97d8:	10 c0       	rjmp	.+32     	; 0x97fa <SD_init+0x1d2>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    97da:	8c 81       	ldd	r24, Y+4	; 0x04
    97dc:	9d 81       	ldd	r25, Y+5	; 0x05
    97de:	01 96       	adiw	r24, 0x01	; 1
    97e0:	8c 83       	std	Y+4, r24	; 0x04
    97e2:	9d 83       	std	Y+5, r25	; 0x05
    97e4:	80 e0       	ldi	r24, 0x00	; 0
    97e6:	40 e0       	ldi	r20, 0x00	; 0
    97e8:	50 e0       	ldi	r21, 0x00	; 0
    97ea:	ba 01       	movw	r22, r20
    97ec:	25 e9       	ldi	r18, 0x95	; 149
    97ee:	08 e0       	ldi	r16, 0x08	; 8
    97f0:	10 e0       	ldi	r17, 0x00	; 0
    97f2:	0e 94 39 4d 	call	0x9a72	; 0x9a72 <SD_command>
    97f6:	81 30       	cpi	r24, 0x01	; 1
    97f8:	41 f7       	brne	.-48     	; 0x97ca <SD_init+0x1a2>
    97fa:	80 e0       	ldi	r24, 0x00	; 0
    97fc:	90 e0       	ldi	r25, 0x00	; 0
    97fe:	a8 ec       	ldi	r26, 0xC8	; 200
    9800:	b2 e4       	ldi	r27, 0x42	; 66
    9802:	8c 8f       	std	Y+28, r24	; 0x1c
    9804:	9d 8f       	std	Y+29, r25	; 0x1d
    9806:	ae 8f       	std	Y+30, r26	; 0x1e
    9808:	bf 8f       	std	Y+31, r27	; 0x1f
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    980a:	6c 8d       	ldd	r22, Y+28	; 0x1c
    980c:	7d 8d       	ldd	r23, Y+29	; 0x1d
    980e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9810:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9812:	20 e0       	ldi	r18, 0x00	; 0
    9814:	30 e0       	ldi	r19, 0x00	; 0
    9816:	4a ef       	ldi	r20, 0xFA	; 250
    9818:	55 e4       	ldi	r21, 0x45	; 69
    981a:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    981e:	dc 01       	movw	r26, r24
    9820:	cb 01       	movw	r24, r22
    9822:	88 a3       	lds	r24, 0x58
    9824:	99 a3       	lds	r25, 0x59
    9826:	aa a3       	lds	r26, 0x5a
    9828:	bb a3       	lds	r27, 0x5b
	if (__tmp < 1.0)
    982a:	11 e0       	ldi	r17, 0x01	; 1
    982c:	68 a1       	lds	r22, 0x48
    982e:	79 a1       	lds	r23, 0x49
    9830:	8a a1       	lds	r24, 0x4a
    9832:	9b a1       	lds	r25, 0x4b
    9834:	20 e0       	ldi	r18, 0x00	; 0
    9836:	30 e0       	ldi	r19, 0x00	; 0
    9838:	40 e8       	ldi	r20, 0x80	; 128
    983a:	5f e3       	ldi	r21, 0x3F	; 63
    983c:	0e 94 2a 5a 	call	0xb454	; 0xb454 <__cmpsf2>
    9840:	88 23       	and	r24, r24
    9842:	0c f0       	brlt	.+2      	; 0x9846 <SD_init+0x21e>
    9844:	10 e0       	ldi	r17, 0x00	; 0
    9846:	11 23       	and	r17, r17
    9848:	29 f0       	breq	.+10     	; 0x9854 <SD_init+0x22c>
		__ticks = 1;
    984a:	81 e0       	ldi	r24, 0x01	; 1
    984c:	90 e0       	ldi	r25, 0x00	; 0
    984e:	8c a3       	lds	r24, 0x5c
    9850:	9d a3       	lds	r25, 0x5d
    9852:	46 c0       	rjmp	.+140    	; 0x98e0 <SD_init+0x2b8>
	else if (__tmp > 65535)
    9854:	11 e0       	ldi	r17, 0x01	; 1
    9856:	68 a1       	lds	r22, 0x48
    9858:	79 a1       	lds	r23, 0x49
    985a:	8a a1       	lds	r24, 0x4a
    985c:	9b a1       	lds	r25, 0x4b
    985e:	20 e0       	ldi	r18, 0x00	; 0
    9860:	3f ef       	ldi	r19, 0xFF	; 255
    9862:	4f e7       	ldi	r20, 0x7F	; 127
    9864:	57 e4       	ldi	r21, 0x47	; 71
    9866:	0e 94 37 5b 	call	0xb66e	; 0xb66e <__gesf2>
    986a:	18 16       	cp	r1, r24
    986c:	0c f0       	brlt	.+2      	; 0x9870 <SD_init+0x248>
    986e:	10 e0       	ldi	r17, 0x00	; 0
    9870:	11 23       	and	r17, r17
    9872:	61 f1       	breq	.+88     	; 0x98cc <SD_init+0x2a4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    9874:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9876:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9878:	8e 8d       	ldd	r24, Y+30	; 0x1e
    987a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    987c:	20 e0       	ldi	r18, 0x00	; 0
    987e:	30 e0       	ldi	r19, 0x00	; 0
    9880:	40 e2       	ldi	r20, 0x20	; 32
    9882:	51 e4       	ldi	r21, 0x41	; 65
    9884:	0e 94 3b 5b 	call	0xb676	; 0xb676 <__mulsf3>
    9888:	dc 01       	movw	r26, r24
    988a:	cb 01       	movw	r24, r22
    988c:	bc 01       	movw	r22, r24
    988e:	cd 01       	movw	r24, r26
    9890:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    9894:	dc 01       	movw	r26, r24
    9896:	cb 01       	movw	r24, r22
    9898:	8c a3       	lds	r24, 0x5c
    989a:	9d a3       	lds	r25, 0x5d
    989c:	12 c0       	rjmp	.+36     	; 0x98c2 <SD_init+0x29a>
    989e:	80 e2       	ldi	r24, 0x20	; 32
    98a0:	93 e0       	ldi	r25, 0x03	; 3
    98a2:	8e a3       	lds	r24, 0x5e
    98a4:	9f a3       	lds	r25, 0x5f
    98a6:	8e a1       	lds	r24, 0x4e
    98a8:	9f a1       	lds	r25, 0x4f
    98aa:	8c 01       	movw	r16, r24
    98ac:	c8 01       	movw	r24, r16
    98ae:	01 97       	sbiw	r24, 0x01	; 1
    98b0:	f1 f7       	brne	.-4      	; 0x98ae <SD_init+0x286>
    98b2:	8c 01       	movw	r16, r24
    98b4:	0e a3       	lds	r16, 0x5e
    98b6:	1f a3       	lds	r17, 0x5f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    98b8:	8c a1       	lds	r24, 0x4c
    98ba:	9d a1       	lds	r25, 0x4d
    98bc:	01 97       	sbiw	r24, 0x01	; 1
    98be:	8c a3       	lds	r24, 0x5c
    98c0:	9d a3       	lds	r25, 0x5d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    98c2:	8c a1       	lds	r24, 0x4c
    98c4:	9d a1       	lds	r25, 0x4d
    98c6:	00 97       	sbiw	r24, 0x00	; 0
    98c8:	51 f7       	brne	.-44     	; 0x989e <SD_init+0x276>
    98ca:	17 c0       	rjmp	.+46     	; 0x98fa <SD_init+0x2d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    98cc:	68 a1       	lds	r22, 0x48
    98ce:	79 a1       	lds	r23, 0x49
    98d0:	8a a1       	lds	r24, 0x4a
    98d2:	9b a1       	lds	r25, 0x4b
    98d4:	0e 94 96 5a 	call	0xb52c	; 0xb52c <__fixunssfsi>
    98d8:	dc 01       	movw	r26, r24
    98da:	cb 01       	movw	r24, r22
    98dc:	8c a3       	lds	r24, 0x5c
    98de:	9d a3       	lds	r25, 0x5d
    98e0:	8c a1       	lds	r24, 0x4c
    98e2:	9d a1       	lds	r25, 0x4d
    98e4:	88 a7       	lds	r24, 0x78
    98e6:	99 a7       	lds	r25, 0x79
    98e8:	88 a5       	lds	r24, 0x68
    98ea:	99 a5       	lds	r25, 0x69
    98ec:	8c 01       	movw	r16, r24
    98ee:	f8 01       	movw	r30, r16
    98f0:	31 97       	sbiw	r30, 0x01	; 1
    98f2:	f1 f7       	brne	.-4      	; 0x98f0 <SD_init+0x2c8>
    98f4:	8f 01       	movw	r16, r30
    98f6:	08 a7       	lds	r16, 0x78
    98f8:	19 a7       	lds	r17, 0x79
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    98fa:	1e 82       	std	Y+6, r1	; 0x06
    98fc:	1f 82       	std	Y+7, r1	; 0x07
    98fe:	0d c0       	rjmp	.+26     	; 0x991a <SD_init+0x2f2>
		if (i >= 10) {
    9900:	8e 81       	ldd	r24, Y+6	; 0x06
    9902:	9f 81       	ldd	r25, Y+7	; 0x07
    9904:	8a 30       	cpi	r24, 0x0A	; 10
    9906:	91 05       	cpc	r25, r1
    9908:	1c f0       	brlt	.+6      	; 0x9910 <SD_init+0x2e8>
			//there was no response to the command
			errorCode = 1;
    990a:	81 e0       	ldi	r24, 0x01	; 1
    990c:	89 83       	std	Y+1, r24	; 0x01
			break;
    990e:	11 c0       	rjmp	.+34     	; 0x9932 <SD_init+0x30a>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    9910:	8e 81       	ldd	r24, Y+6	; 0x06
    9912:	9f 81       	ldd	r25, Y+7	; 0x07
    9914:	01 96       	adiw	r24, 0x01	; 1
    9916:	8e 83       	std	Y+6, r24	; 0x06
    9918:	9f 83       	std	Y+7, r25	; 0x07
    991a:	88 e0       	ldi	r24, 0x08	; 8
    991c:	4a ea       	ldi	r20, 0xAA	; 170
    991e:	51 e0       	ldi	r21, 0x01	; 1
    9920:	60 e0       	ldi	r22, 0x00	; 0
    9922:	70 e0       	ldi	r23, 0x00	; 0
    9924:	27 e8       	ldi	r18, 0x87	; 135
    9926:	08 e0       	ldi	r16, 0x08	; 8
    9928:	10 e0       	ldi	r17, 0x00	; 0
    992a:	0e 94 39 4d 	call	0x9a72	; 0x9a72 <SD_command>
    992e:	81 30       	cpi	r24, 0x01	; 1
    9930:	39 f7       	brne	.-50     	; 0x9900 <SD_init+0x2d8>
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9932:	18 86       	std	Y+8, r1	; 0x08
    9934:	19 86       	std	Y+9, r1	; 0x09
    9936:	13 c0       	rjmp	.+38     	; 0x995e <SD_init+0x336>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    9938:	88 85       	ldd	r24, Y+8	; 0x08
    993a:	99 85       	ldd	r25, Y+9	; 0x09
    993c:	8c 01       	movw	r16, r24
    993e:	0e 5f       	subi	r16, 0xFE	; 254
    9940:	1f 4f       	sbci	r17, 0xFF	; 255
    9942:	8f ef       	ldi	r24, 0xFF	; 255
    9944:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    9948:	28 2f       	mov	r18, r24
    994a:	c8 01       	movw	r24, r16
    994c:	81 56       	subi	r24, 0x61	; 97
    994e:	9f 4a       	sbci	r25, 0xAF	; 175
    9950:	fc 01       	movw	r30, r24
    9952:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    9954:	88 85       	ldd	r24, Y+8	; 0x08
    9956:	99 85       	ldd	r25, Y+9	; 0x09
    9958:	01 96       	adiw	r24, 0x01	; 1
    995a:	88 87       	std	Y+8, r24	; 0x08
    995c:	99 87       	std	Y+9, r25	; 0x09
    995e:	88 85       	ldd	r24, Y+8	; 0x08
    9960:	99 85       	ldd	r25, Y+9	; 0x09
    9962:	84 30       	cpi	r24, 0x04	; 4
    9964:	91 05       	cpc	r25, r1
    9966:	44 f3       	brlt	.-48     	; 0x9938 <SD_init+0x310>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    9968:	80 91 a3 50 	lds	r24, 0x50A3
    996c:	81 30       	cpi	r24, 0x01	; 1
    996e:	21 f4       	brne	.+8      	; 0x9978 <SD_init+0x350>
    9970:	80 91 a4 50 	lds	r24, 0x50A4
    9974:	8a 3a       	cpi	r24, 0xAA	; 170
    9976:	11 f0       	breq	.+4      	; 0x997c <SD_init+0x354>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    9978:	81 e0       	ldi	r24, 0x01	; 1
    997a:	89 83       	std	Y+1, r24	; 0x01
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    997c:	87 e3       	ldi	r24, 0x37	; 55
    997e:	40 e0       	ldi	r20, 0x00	; 0
    9980:	50 e0       	ldi	r21, 0x00	; 0
    9982:	ba 01       	movw	r22, r20
    9984:	2f ef       	ldi	r18, 0xFF	; 255
    9986:	08 e0       	ldi	r16, 0x08	; 8
    9988:	10 e0       	ldi	r17, 0x00	; 0
    998a:	0e 94 39 4d 	call	0x9a72	; 0x9a72 <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    998e:	81 e0       	ldi	r24, 0x01	; 1
    9990:	40 e0       	ldi	r20, 0x00	; 0
    9992:	50 e0       	ldi	r21, 0x00	; 0
    9994:	60 e0       	ldi	r22, 0x00	; 0
    9996:	70 e4       	ldi	r23, 0x40	; 64
    9998:	2f ef       	ldi	r18, 0xFF	; 255
    999a:	08 e0       	ldi	r16, 0x08	; 8
    999c:	10 e0       	ldi	r17, 0x00	; 0
    999e:	0e 94 39 4d 	call	0x9a72	; 0x9a72 <SD_command>
	} while(Buffer[1]!= 0x00);
    99a2:	80 91 a0 50 	lds	r24, 0x50A0
    99a6:	88 23       	and	r24, r24
    99a8:	49 f7       	brne	.-46     	; 0x997c <SD_init+0x354>
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    99aa:	1a 86       	std	Y+10, r1	; 0x0a
    99ac:	1b 86       	std	Y+11, r1	; 0x0b
    99ae:	0d c0       	rjmp	.+26     	; 0x99ca <SD_init+0x3a2>
		if (i >= 10) {
    99b0:	8a 85       	ldd	r24, Y+10	; 0x0a
    99b2:	9b 85       	ldd	r25, Y+11	; 0x0b
    99b4:	8a 30       	cpi	r24, 0x0A	; 10
    99b6:	91 05       	cpc	r25, r1
    99b8:	1c f0       	brlt	.+6      	; 0x99c0 <SD_init+0x398>
			//there was no response to the command
			errorCode = 1;
    99ba:	81 e0       	ldi	r24, 0x01	; 1
    99bc:	89 83       	std	Y+1, r24	; 0x01
			break;
    99be:	10 c0       	rjmp	.+32     	; 0x99e0 <SD_init+0x3b8>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    99c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    99c2:	9b 85       	ldd	r25, Y+11	; 0x0b
    99c4:	01 96       	adiw	r24, 0x01	; 1
    99c6:	8a 87       	std	Y+10, r24	; 0x0a
    99c8:	9b 87       	std	Y+11, r25	; 0x0b
    99ca:	8a e3       	ldi	r24, 0x3A	; 58
    99cc:	40 e0       	ldi	r20, 0x00	; 0
    99ce:	50 e0       	ldi	r21, 0x00	; 0
    99d0:	ba 01       	movw	r22, r20
    99d2:	2f ef       	ldi	r18, 0xFF	; 255
    99d4:	08 e0       	ldi	r16, 0x08	; 8
    99d6:	10 e0       	ldi	r17, 0x00	; 0
    99d8:	0e 94 39 4d 	call	0x9a72	; 0x9a72 <SD_command>
    99dc:	88 23       	and	r24, r24
    99de:	41 f7       	brne	.-48     	; 0x99b0 <SD_init+0x388>
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    99e0:	1c 86       	std	Y+12, r1	; 0x0c
    99e2:	1d 86       	std	Y+13, r1	; 0x0d
    99e4:	0f c0       	rjmp	.+30     	; 0x9a04 <SD_init+0x3dc>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    99e6:	8f ef       	ldi	r24, 0xFF	; 255
    99e8:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    99ec:	28 2f       	mov	r18, r24
    99ee:	8c 85       	ldd	r24, Y+12	; 0x0c
    99f0:	9d 85       	ldd	r25, Y+13	; 0x0d
    99f2:	81 56       	subi	r24, 0x61	; 97
    99f4:	9f 4a       	sbci	r25, 0xAF	; 175
    99f6:	fc 01       	movw	r30, r24
    99f8:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    99fa:	8c 85       	ldd	r24, Y+12	; 0x0c
    99fc:	9d 85       	ldd	r25, Y+13	; 0x0d
    99fe:	01 96       	adiw	r24, 0x01	; 1
    9a00:	8c 87       	std	Y+12, r24	; 0x0c
    9a02:	9d 87       	std	Y+13, r25	; 0x0d
    9a04:	8c 85       	ldd	r24, Y+12	; 0x0c
    9a06:	9d 85       	ldd	r25, Y+13	; 0x0d
    9a08:	84 30       	cpi	r24, 0x04	; 4
    9a0a:	91 05       	cpc	r25, r1
    9a0c:	64 f3       	brlt	.-40     	; 0x99e6 <SD_init+0x3be>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    9a0e:	80 91 9f 50 	lds	r24, 0x509F
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    9a12:	80 e0       	ldi	r24, 0x00	; 0
    9a14:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	SPIDisable();
    9a18:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9a1c:	88 e0       	ldi	r24, 0x08	; 8
    9a1e:	60 e0       	ldi	r22, 0x00	; 0
    9a20:	0e 94 69 33 	call	0x66d2	; 0x66d2 <PortEx_OUTSET>
	return errorCode;	
    9a24:	89 81       	ldd	r24, Y+1	; 0x01
}	
    9a26:	a9 96       	adiw	r28, 0x29	; 41
    9a28:	cd bf       	out	0x3d, r28	; 61
    9a2a:	de bf       	out	0x3e, r29	; 62
    9a2c:	df 91       	pop	r29
    9a2e:	cf 91       	pop	r28
    9a30:	1f 91       	pop	r17
    9a32:	0f 91       	pop	r16
    9a34:	08 95       	ret

00009a36 <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
    9a36:	cf 93       	push	r28
    9a38:	df 93       	push	r29
    9a3a:	0f 92       	push	r0
    9a3c:	0f 92       	push	r0
    9a3e:	cd b7       	in	r28, 0x3d	; 61
    9a40:	de b7       	in	r29, 0x3e	; 62
    9a42:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPIC.DATA = byteToSend;
    9a44:	80 ec       	ldi	r24, 0xC0	; 192
    9a46:	98 e0       	ldi	r25, 0x08	; 8
    9a48:	2a 81       	ldd	r18, Y+2	; 0x02
    9a4a:	fc 01       	movw	r30, r24
    9a4c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9a4e:	00 00       	nop
    9a50:	80 ec       	ldi	r24, 0xC0	; 192
    9a52:	98 e0       	ldi	r25, 0x08	; 8
    9a54:	fc 01       	movw	r30, r24
    9a56:	82 81       	ldd	r24, Z+2	; 0x02
    9a58:	88 23       	and	r24, r24
    9a5a:	d4 f7       	brge	.-12     	; 0x9a50 <SPI_write+0x1a>
	data = SPIC.DATA; //read SPI data register to reset status flag
    9a5c:	80 ec       	ldi	r24, 0xC0	; 192
    9a5e:	98 e0       	ldi	r25, 0x08	; 8
    9a60:	fc 01       	movw	r30, r24
    9a62:	83 81       	ldd	r24, Z+3	; 0x03
    9a64:	89 83       	std	Y+1, r24	; 0x01
	return data;
    9a66:	89 81       	ldd	r24, Y+1	; 0x01
}
    9a68:	0f 90       	pop	r0
    9a6a:	0f 90       	pop	r0
    9a6c:	df 91       	pop	r29
    9a6e:	cf 91       	pop	r28
    9a70:	08 95       	ret

00009a72 <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    9a72:	0f 93       	push	r16
    9a74:	1f 93       	push	r17
    9a76:	cf 93       	push	r28
    9a78:	df 93       	push	r29
    9a7a:	cd b7       	in	r28, 0x3d	; 61
    9a7c:	de b7       	in	r29, 0x3e	; 62
    9a7e:	2a 97       	sbiw	r28, 0x0a	; 10
    9a80:	cd bf       	out	0x3d, r28	; 61
    9a82:	de bf       	out	0x3e, r29	; 62
    9a84:	8b 83       	std	Y+3, r24	; 0x03
    9a86:	4c 83       	std	Y+4, r20	; 0x04
    9a88:	5d 83       	std	Y+5, r21	; 0x05
    9a8a:	6e 83       	std	Y+6, r22	; 0x06
    9a8c:	7f 83       	std	Y+7, r23	; 0x07
    9a8e:	28 87       	std	Y+8, r18	; 0x08
    9a90:	09 87       	std	Y+9, r16	; 0x09
    9a92:	1a 87       	std	Y+10, r17	; 0x0a
	
	SPI_write(SDHC_COMMAND_START | cmd);
    9a94:	8b 81       	ldd	r24, Y+3	; 0x03
    9a96:	80 64       	ori	r24, 0x40	; 64
    9a98:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    9a9c:	8c 81       	ldd	r24, Y+4	; 0x04
    9a9e:	9d 81       	ldd	r25, Y+5	; 0x05
    9aa0:	ae 81       	ldd	r26, Y+6	; 0x06
    9aa2:	bf 81       	ldd	r27, Y+7	; 0x07
    9aa4:	8b 2f       	mov	r24, r27
    9aa6:	99 27       	eor	r25, r25
    9aa8:	aa 27       	eor	r26, r26
    9aaa:	bb 27       	eor	r27, r27
    9aac:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    9ab0:	8c 81       	ldd	r24, Y+4	; 0x04
    9ab2:	9d 81       	ldd	r25, Y+5	; 0x05
    9ab4:	ae 81       	ldd	r26, Y+6	; 0x06
    9ab6:	bf 81       	ldd	r27, Y+7	; 0x07
    9ab8:	cd 01       	movw	r24, r26
    9aba:	aa 27       	eor	r26, r26
    9abc:	bb 27       	eor	r27, r27
    9abe:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    9ac2:	8c 81       	ldd	r24, Y+4	; 0x04
    9ac4:	9d 81       	ldd	r25, Y+5	; 0x05
    9ac6:	ae 81       	ldd	r26, Y+6	; 0x06
    9ac8:	bf 81       	ldd	r27, Y+7	; 0x07
    9aca:	89 2f       	mov	r24, r25
    9acc:	9a 2f       	mov	r25, r26
    9ace:	ab 2f       	mov	r26, r27
    9ad0:	bb 27       	eor	r27, r27
    9ad2:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    9ad6:	8c 81       	ldd	r24, Y+4	; 0x04
    9ad8:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
	SPI_write(crc);
    9adc:	88 85       	ldd	r24, Y+8	; 0x08
    9ade:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
	
	for(int i=0; i<read; i++){
    9ae2:	19 82       	std	Y+1, r1	; 0x01
    9ae4:	1a 82       	std	Y+2, r1	; 0x02
    9ae6:	33 c0       	rjmp	.+102    	; 0x9b4e <SD_command+0xdc>
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    9ae8:	89 81       	ldd	r24, Y+1	; 0x01
    9aea:	9a 81       	ldd	r25, Y+2	; 0x02
    9aec:	2d e0       	ldi	r18, 0x0D	; 13
    9aee:	30 e0       	ldi	r19, 0x00	; 0
    9af0:	b9 01       	movw	r22, r18
    9af2:	0e 94 d1 5b 	call	0xb7a2	; 0xb7a2 <__divmodhi4>
    9af6:	8c 01       	movw	r16, r24
    9af8:	8f ef       	ldi	r24, 0xFF	; 255
    9afa:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    9afe:	28 2f       	mov	r18, r24
    9b00:	c8 01       	movw	r24, r16
    9b02:	81 56       	subi	r24, 0x61	; 97
    9b04:	9f 4a       	sbci	r25, 0xAF	; 175
    9b06:	fc 01       	movw	r30, r24
    9b08:	20 83       	st	Z, r18
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    9b0a:	89 81       	ldd	r24, Y+1	; 0x01
    9b0c:	9a 81       	ldd	r25, Y+2	; 0x02
    9b0e:	2d e0       	ldi	r18, 0x0D	; 13
    9b10:	30 e0       	ldi	r19, 0x00	; 0
    9b12:	b9 01       	movw	r22, r18
    9b14:	0e 94 d1 5b 	call	0xb7a2	; 0xb7a2 <__divmodhi4>
    9b18:	81 56       	subi	r24, 0x61	; 97
    9b1a:	9f 4a       	sbci	r25, 0xAF	; 175
    9b1c:	fc 01       	movw	r30, r24
    9b1e:	80 81       	ld	r24, Z
    9b20:	8f 3f       	cpi	r24, 0xFF	; 255
    9b22:	81 f0       	breq	.+32     	; 0x9b44 <SD_command+0xd2>
			Buffer[1] = Buffer[i%13];
    9b24:	89 81       	ldd	r24, Y+1	; 0x01
    9b26:	9a 81       	ldd	r25, Y+2	; 0x02
    9b28:	2d e0       	ldi	r18, 0x0D	; 13
    9b2a:	30 e0       	ldi	r19, 0x00	; 0
    9b2c:	b9 01       	movw	r22, r18
    9b2e:	0e 94 d1 5b 	call	0xb7a2	; 0xb7a2 <__divmodhi4>
    9b32:	81 56       	subi	r24, 0x61	; 97
    9b34:	9f 4a       	sbci	r25, 0xAF	; 175
    9b36:	fc 01       	movw	r30, r24
    9b38:	80 81       	ld	r24, Z
    9b3a:	80 93 a0 50 	sts	0x50A0, r24
			return Buffer[1];
    9b3e:	80 91 a0 50 	lds	r24, 0x50A0
    9b42:	0d c0       	rjmp	.+26     	; 0x9b5e <SD_command+0xec>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    9b44:	89 81       	ldd	r24, Y+1	; 0x01
    9b46:	9a 81       	ldd	r25, Y+2	; 0x02
    9b48:	01 96       	adiw	r24, 0x01	; 1
    9b4a:	89 83       	std	Y+1, r24	; 0x01
    9b4c:	9a 83       	std	Y+2, r25	; 0x02
    9b4e:	29 81       	ldd	r18, Y+1	; 0x01
    9b50:	3a 81       	ldd	r19, Y+2	; 0x02
    9b52:	89 85       	ldd	r24, Y+9	; 0x09
    9b54:	9a 85       	ldd	r25, Y+10	; 0x0a
    9b56:	28 17       	cp	r18, r24
    9b58:	39 07       	cpc	r19, r25
    9b5a:	34 f2       	brlt	.-116    	; 0x9ae8 <SD_command+0x76>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    9b5c:	8f ef       	ldi	r24, 0xFF	; 255
}
    9b5e:	2a 96       	adiw	r28, 0x0a	; 10
    9b60:	cd bf       	out	0x3d, r28	; 61
    9b62:	de bf       	out	0x3e, r29	; 62
    9b64:	df 91       	pop	r29
    9b66:	cf 91       	pop	r28
    9b68:	1f 91       	pop	r17
    9b6a:	0f 91       	pop	r16
    9b6c:	08 95       	ret

00009b6e <SD_write_block>:

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    9b6e:	0f 93       	push	r16
    9b70:	1f 93       	push	r17
    9b72:	cf 93       	push	r28
    9b74:	df 93       	push	r29
    9b76:	cd b7       	in	r28, 0x3d	; 61
    9b78:	de b7       	in	r29, 0x3e	; 62
    9b7a:	62 97       	sbiw	r28, 0x12	; 18
    9b7c:	cd bf       	out	0x3d, r28	; 61
    9b7e:	de bf       	out	0x3e, r29	; 62
    9b80:	6b 87       	std	Y+11, r22	; 0x0b
    9b82:	7c 87       	std	Y+12, r23	; 0x0c
    9b84:	8d 87       	std	Y+13, r24	; 0x0d
    9b86:	9e 87       	std	Y+14, r25	; 0x0e
    9b88:	4f 87       	std	Y+15, r20	; 0x0f
    9b8a:	58 8b       	std	Y+16, r21	; 0x10
    9b8c:	29 8b       	std	Y+17, r18	; 0x11
    9b8e:	3a 8b       	std	Y+18, r19	; 0x12
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9b90:	88 e0       	ldi	r24, 0x08	; 8
    9b92:	60 e0       	ldi	r22, 0x00	; 0
    9b94:	0e 94 cc 33 	call	0x6798	; 0x6798 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9b98:	80 e0       	ldi	r24, 0x00	; 0
    9b9a:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>
	SPICS(TRUE);
    9b9e:	81 e0       	ldi	r24, 0x01	; 1
    9ba0:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    9ba4:	20 e0       	ldi	r18, 0x00	; 0
    9ba6:	32 e0       	ldi	r19, 0x02	; 2
    9ba8:	89 89       	ldd	r24, Y+17	; 0x11
    9baa:	9a 89       	ldd	r25, Y+18	; 0x12
    9bac:	a9 01       	movw	r20, r18
    9bae:	48 1b       	sub	r20, r24
    9bb0:	59 0b       	sbc	r21, r25
    9bb2:	ca 01       	movw	r24, r20
    9bb4:	89 83       	std	Y+1, r24	; 0x01
    9bb6:	9a 83       	std	Y+2, r25	; 0x02
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    9bb8:	89 81       	ldd	r24, Y+1	; 0x01
    9bba:	9a 81       	ldd	r25, Y+2	; 0x02
    9bbc:	52 e0       	ldi	r21, 0x02	; 2
    9bbe:	80 30       	cpi	r24, 0x00	; 0
    9bc0:	95 07       	cpc	r25, r21
    9bc2:	11 f4       	brne	.+4      	; 0x9bc8 <SD_write_block+0x5a>
    9bc4:	19 82       	std	Y+1, r1	; 0x01
    9bc6:	1a 82       	std	Y+2, r1	; 0x02
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9bc8:	1b 82       	std	Y+3, r1	; 0x03
    9bca:	1c 82       	std	Y+4, r1	; 0x04
    9bcc:	0b c0       	rjmp	.+22     	; 0x9be4 <SD_write_block+0x76>
	if (i >= 10) {
    9bce:	8b 81       	ldd	r24, Y+3	; 0x03
    9bd0:	9c 81       	ldd	r25, Y+4	; 0x04
    9bd2:	8a 30       	cpi	r24, 0x0A	; 10
    9bd4:	91 05       	cpc	r25, r1
    9bd6:	0c f0       	brlt	.+2      	; 0x9bda <SD_write_block+0x6c>
		//there was no response to the command
		while(1);
    9bd8:	ff cf       	rjmp	.-2      	; 0x9bd8 <SD_write_block+0x6a>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9bda:	8b 81       	ldd	r24, Y+3	; 0x03
    9bdc:	9c 81       	ldd	r25, Y+4	; 0x04
    9bde:	01 96       	adiw	r24, 0x01	; 1
    9be0:	8b 83       	std	Y+3, r24	; 0x03
    9be2:	9c 83       	std	Y+4, r25	; 0x04
    9be4:	2b 85       	ldd	r18, Y+11	; 0x0b
    9be6:	3c 85       	ldd	r19, Y+12	; 0x0c
    9be8:	4d 85       	ldd	r20, Y+13	; 0x0d
    9bea:	5e 85       	ldd	r21, Y+14	; 0x0e
    9bec:	88 e1       	ldi	r24, 0x18	; 24
    9bee:	ba 01       	movw	r22, r20
    9bf0:	a9 01       	movw	r20, r18
    9bf2:	2f ef       	ldi	r18, 0xFF	; 255
    9bf4:	08 e0       	ldi	r16, 0x08	; 8
    9bf6:	10 e0       	ldi	r17, 0x00	; 0
    9bf8:	0e 94 39 4d 	call	0x9a72	; 0x9a72 <SD_command>
    9bfc:	88 23       	and	r24, r24
    9bfe:	39 f7       	brne	.-50     	; 0x9bce <SD_write_block+0x60>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    9c00:	8f ef       	ldi	r24, 0xFF	; 255
    9c02:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    9c06:	80 93 9f 50 	sts	0x509F, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    9c0a:	8e ef       	ldi	r24, 0xFE	; 254
    9c0c:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    9c10:	1d 82       	std	Y+5, r1	; 0x05
    9c12:	1e 82       	std	Y+6, r1	; 0x06
    9c14:	1d c0       	rjmp	.+58     	; 0x9c50 <SD_write_block+0xe2>
Buffer[i%13] = SPI_write(data[i]);
    9c16:	8d 81       	ldd	r24, Y+5	; 0x05
    9c18:	9e 81       	ldd	r25, Y+6	; 0x06
    9c1a:	2d e0       	ldi	r18, 0x0D	; 13
    9c1c:	30 e0       	ldi	r19, 0x00	; 0
    9c1e:	b9 01       	movw	r22, r18
    9c20:	0e 94 d1 5b 	call	0xb7a2	; 0xb7a2 <__divmodhi4>
    9c24:	8c 01       	movw	r16, r24
    9c26:	8d 81       	ldd	r24, Y+5	; 0x05
    9c28:	9e 81       	ldd	r25, Y+6	; 0x06
    9c2a:	2f 85       	ldd	r18, Y+15	; 0x0f
    9c2c:	38 89       	ldd	r19, Y+16	; 0x10
    9c2e:	82 0f       	add	r24, r18
    9c30:	93 1f       	adc	r25, r19
    9c32:	fc 01       	movw	r30, r24
    9c34:	80 81       	ld	r24, Z
    9c36:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    9c3a:	28 2f       	mov	r18, r24
    9c3c:	c8 01       	movw	r24, r16
    9c3e:	81 56       	subi	r24, 0x61	; 97
    9c40:	9f 4a       	sbci	r25, 0xAF	; 175
    9c42:	fc 01       	movw	r30, r24
    9c44:	20 83       	st	Z, r18
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    9c46:	8d 81       	ldd	r24, Y+5	; 0x05
    9c48:	9e 81       	ldd	r25, Y+6	; 0x06
    9c4a:	01 96       	adiw	r24, 0x01	; 1
    9c4c:	8d 83       	std	Y+5, r24	; 0x05
    9c4e:	9e 83       	std	Y+6, r25	; 0x06
    9c50:	2d 81       	ldd	r18, Y+5	; 0x05
    9c52:	3e 81       	ldd	r19, Y+6	; 0x06
    9c54:	89 89       	ldd	r24, Y+17	; 0x11
    9c56:	9a 89       	ldd	r25, Y+18	; 0x12
    9c58:	28 17       	cp	r18, r24
    9c5a:	39 07       	cpc	r19, r25
    9c5c:	e4 f2       	brlt	.-72     	; 0x9c16 <SD_write_block+0xa8>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    9c5e:	1f 82       	std	Y+7, r1	; 0x07
    9c60:	18 86       	std	Y+8, r1	; 0x08
    9c62:	16 c0       	rjmp	.+44     	; 0x9c90 <SD_write_block+0x122>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    9c64:	8f 81       	ldd	r24, Y+7	; 0x07
    9c66:	98 85       	ldd	r25, Y+8	; 0x08
    9c68:	2d e0       	ldi	r18, 0x0D	; 13
    9c6a:	30 e0       	ldi	r19, 0x00	; 0
    9c6c:	b9 01       	movw	r22, r18
    9c6e:	0e 94 d1 5b 	call	0xb7a2	; 0xb7a2 <__divmodhi4>
    9c72:	8c 01       	movw	r16, r24
    9c74:	80 e0       	ldi	r24, 0x00	; 0
    9c76:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    9c7a:	28 2f       	mov	r18, r24
    9c7c:	c8 01       	movw	r24, r16
    9c7e:	81 56       	subi	r24, 0x61	; 97
    9c80:	9f 4a       	sbci	r25, 0xAF	; 175
    9c82:	fc 01       	movw	r30, r24
    9c84:	20 83       	st	Z, r18
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    9c86:	8f 81       	ldd	r24, Y+7	; 0x07
    9c88:	98 85       	ldd	r25, Y+8	; 0x08
    9c8a:	01 96       	adiw	r24, 0x01	; 1
    9c8c:	8f 83       	std	Y+7, r24	; 0x07
    9c8e:	98 87       	std	Y+8, r25	; 0x08
    9c90:	2f 81       	ldd	r18, Y+7	; 0x07
    9c92:	38 85       	ldd	r19, Y+8	; 0x08
    9c94:	89 81       	ldd	r24, Y+1	; 0x01
    9c96:	9a 81       	ldd	r25, Y+2	; 0x02
    9c98:	28 17       	cp	r18, r24
    9c9a:	39 07       	cpc	r19, r25
    9c9c:	1c f3       	brlt	.-58     	; 0x9c64 <SD_write_block+0xf6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    9c9e:	8f ef       	ldi	r24, 0xFF	; 255
    9ca0:	80 93 9f 50 	sts	0x509F, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    9ca4:	19 86       	std	Y+9, r1	; 0x09
    9ca6:	1a 86       	std	Y+10, r1	; 0x0a
    9ca8:	0a c0       	rjmp	.+20     	; 0x9cbe <SD_write_block+0x150>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    9caa:	8f ef       	ldi	r24, 0xFF	; 255
    9cac:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    9cb0:	80 93 9f 50 	sts	0x509F, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    9cb4:	89 85       	ldd	r24, Y+9	; 0x09
    9cb6:	9a 85       	ldd	r25, Y+10	; 0x0a
    9cb8:	01 96       	adiw	r24, 0x01	; 1
    9cba:	89 87       	std	Y+9, r24	; 0x09
    9cbc:	9a 87       	std	Y+10, r25	; 0x0a
    9cbe:	89 85       	ldd	r24, Y+9	; 0x09
    9cc0:	9a 85       	ldd	r25, Y+10	; 0x0a
    9cc2:	82 30       	cpi	r24, 0x02	; 2
    9cc4:	91 05       	cpc	r25, r1
    9cc6:	8c f3       	brlt	.-30     	; 0x9caa <SD_write_block+0x13c>
    9cc8:	80 91 9f 50 	lds	r24, 0x509F
    9ccc:	8f 3f       	cpi	r24, 0xFF	; 255
    9cce:	69 f3       	breq	.-38     	; 0x9caa <SD_write_block+0x13c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    9cd0:	80 91 9f 50 	lds	r24, 0x509F
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    9cd4:	05 c0       	rjmp	.+10     	; 0x9ce0 <SD_write_block+0x172>
    9cd6:	8f ef       	ldi	r24, 0xFF	; 255
    9cd8:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    9cdc:	80 93 9f 50 	sts	0x509F, r24
    9ce0:	80 91 9f 50 	lds	r24, 0x509F
    9ce4:	8f 3f       	cpi	r24, 0xFF	; 255
    9ce6:	b9 f7       	brne	.-18     	; 0x9cd6 <SD_write_block+0x168>
	SPICS(FALSE);
    9ce8:	80 e0       	ldi	r24, 0x00	; 0
    9cea:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	SPIDisable();
    9cee:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    9cf2:	88 e0       	ldi	r24, 0x08	; 8
    9cf4:	60 e0       	ldi	r22, 0x00	; 0
    9cf6:	0e 94 69 33 	call	0x66d2	; 0x66d2 <PortEx_OUTSET>
}
    9cfa:	62 96       	adiw	r28, 0x12	; 18
    9cfc:	cd bf       	out	0x3d, r28	; 61
    9cfe:	de bf       	out	0x3e, r29	; 62
    9d00:	df 91       	pop	r29
    9d02:	cf 91       	pop	r28
    9d04:	1f 91       	pop	r17
    9d06:	0f 91       	pop	r16
    9d08:	08 95       	ret

00009d0a <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    9d0a:	0f 93       	push	r16
    9d0c:	1f 93       	push	r17
    9d0e:	cf 93       	push	r28
    9d10:	df 93       	push	r29
    9d12:	cd b7       	in	r28, 0x3d	; 61
    9d14:	de b7       	in	r29, 0x3e	; 62
    9d16:	2a 97       	sbiw	r28, 0x0a	; 10
    9d18:	cd bf       	out	0x3d, r28	; 61
    9d1a:	de bf       	out	0x3e, r29	; 62
    9d1c:	6d 83       	std	Y+5, r22	; 0x05
    9d1e:	7e 83       	std	Y+6, r23	; 0x06
    9d20:	8f 83       	std	Y+7, r24	; 0x07
    9d22:	98 87       	std	Y+8, r25	; 0x08
    9d24:	49 87       	std	Y+9, r20	; 0x09
    9d26:	5a 87       	std	Y+10, r21	; 0x0a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9d28:	88 e0       	ldi	r24, 0x08	; 8
    9d2a:	60 e0       	ldi	r22, 0x00	; 0
    9d2c:	0e 94 cc 33 	call	0x6798	; 0x6798 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9d30:	80 e0       	ldi	r24, 0x00	; 0
    9d32:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>
	SPICS(TRUE);
    9d36:	81 e0       	ldi	r24, 0x01	; 1
    9d38:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    9d3c:	19 82       	std	Y+1, r1	; 0x01
    9d3e:	1a 82       	std	Y+2, r1	; 0x02
    9d40:	0b c0       	rjmp	.+22     	; 0x9d58 <SD_read_block+0x4e>
		if (i >= 10) {
    9d42:	89 81       	ldd	r24, Y+1	; 0x01
    9d44:	9a 81       	ldd	r25, Y+2	; 0x02
    9d46:	8a 30       	cpi	r24, 0x0A	; 10
    9d48:	91 05       	cpc	r25, r1
    9d4a:	0c f0       	brlt	.+2      	; 0x9d4e <SD_read_block+0x44>
			//there was no response to the command
			while(1);
    9d4c:	ff cf       	rjmp	.-2      	; 0x9d4c <SD_read_block+0x42>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    9d4e:	89 81       	ldd	r24, Y+1	; 0x01
    9d50:	9a 81       	ldd	r25, Y+2	; 0x02
    9d52:	01 96       	adiw	r24, 0x01	; 1
    9d54:	89 83       	std	Y+1, r24	; 0x01
    9d56:	9a 83       	std	Y+2, r25	; 0x02
    9d58:	2d 81       	ldd	r18, Y+5	; 0x05
    9d5a:	3e 81       	ldd	r19, Y+6	; 0x06
    9d5c:	4f 81       	ldd	r20, Y+7	; 0x07
    9d5e:	58 85       	ldd	r21, Y+8	; 0x08
    9d60:	81 e1       	ldi	r24, 0x11	; 17
    9d62:	ba 01       	movw	r22, r20
    9d64:	a9 01       	movw	r20, r18
    9d66:	2f ef       	ldi	r18, 0xFF	; 255
    9d68:	08 e0       	ldi	r16, 0x08	; 8
    9d6a:	10 e0       	ldi	r17, 0x00	; 0
    9d6c:	0e 94 39 4d 	call	0x9a72	; 0x9a72 <SD_command>
    9d70:	88 23       	and	r24, r24
    9d72:	39 f7       	brne	.-50     	; 0x9d42 <SD_read_block+0x38>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    9d74:	05 c0       	rjmp	.+10     	; 0x9d80 <SD_read_block+0x76>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    9d76:	8f ef       	ldi	r24, 0xFF	; 255
    9d78:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    9d7c:	80 93 9f 50 	sts	0x509F, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    9d80:	80 91 9f 50 	lds	r24, 0x509F
    9d84:	8e 3f       	cpi	r24, 0xFE	; 254
    9d86:	b9 f7       	brne	.-18     	; 0x9d76 <SD_read_block+0x6c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9d88:	1b 82       	std	Y+3, r1	; 0x03
    9d8a:	1c 82       	std	Y+4, r1	; 0x04
    9d8c:	11 c0       	rjmp	.+34     	; 0x9db0 <SD_read_block+0xa6>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    9d8e:	8b 81       	ldd	r24, Y+3	; 0x03
    9d90:	9c 81       	ldd	r25, Y+4	; 0x04
    9d92:	29 85       	ldd	r18, Y+9	; 0x09
    9d94:	3a 85       	ldd	r19, Y+10	; 0x0a
    9d96:	89 01       	movw	r16, r18
    9d98:	08 0f       	add	r16, r24
    9d9a:	19 1f       	adc	r17, r25
    9d9c:	8f ef       	ldi	r24, 0xFF	; 255
    9d9e:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    9da2:	f8 01       	movw	r30, r16
    9da4:	80 83       	st	Z, r24
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9da6:	8b 81       	ldd	r24, Y+3	; 0x03
    9da8:	9c 81       	ldd	r25, Y+4	; 0x04
    9daa:	01 96       	adiw	r24, 0x01	; 1
    9dac:	8b 83       	std	Y+3, r24	; 0x03
    9dae:	9c 83       	std	Y+4, r25	; 0x04
    9db0:	8b 81       	ldd	r24, Y+3	; 0x03
    9db2:	9c 81       	ldd	r25, Y+4	; 0x04
    9db4:	f2 e0       	ldi	r31, 0x02	; 2
    9db6:	80 30       	cpi	r24, 0x00	; 0
    9db8:	9f 07       	cpc	r25, r31
    9dba:	4c f3       	brlt	.-46     	; 0x9d8e <SD_read_block+0x84>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    9dbc:	10 92 ab 50 	sts	0x50AB, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    9dc0:	05 c0       	rjmp	.+10     	; 0x9dcc <SD_read_block+0xc2>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    9dc2:	8f ef       	ldi	r24, 0xFF	; 255
    9dc4:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    9dc8:	80 93 ab 50 	sts	0x50AB, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    9dcc:	80 91 ab 50 	lds	r24, 0x50AB
    9dd0:	8f 3f       	cpi	r24, 0xFF	; 255
    9dd2:	b9 f7       	brne	.-18     	; 0x9dc2 <SD_read_block+0xb8>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    9dd4:	80 e0       	ldi	r24, 0x00	; 0
    9dd6:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	SPIDisable();
    9dda:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9dde:	88 e0       	ldi	r24, 0x08	; 8
    9de0:	60 e0       	ldi	r22, 0x00	; 0
    9de2:	0e 94 69 33 	call	0x66d2	; 0x66d2 <PortEx_OUTSET>
}
    9de6:	2a 96       	adiw	r28, 0x0a	; 10
    9de8:	cd bf       	out	0x3d, r28	; 61
    9dea:	de bf       	out	0x3e, r29	; 62
    9dec:	df 91       	pop	r29
    9dee:	cf 91       	pop	r28
    9df0:	1f 91       	pop	r17
    9df2:	0f 91       	pop	r16
    9df4:	08 95       	ret

00009df6 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    9df6:	0f 93       	push	r16
    9df8:	1f 93       	push	r17
    9dfa:	cf 93       	push	r28
    9dfc:	df 93       	push	r29
    9dfe:	cd b7       	in	r28, 0x3d	; 61
    9e00:	de b7       	in	r29, 0x3e	; 62
    9e02:	6a 97       	sbiw	r28, 0x1a	; 26
    9e04:	cd bf       	out	0x3d, r28	; 61
    9e06:	de bf       	out	0x3e, r29	; 62
    9e08:	6b 8b       	std	Y+19, r22	; 0x13
    9e0a:	7c 8b       	std	Y+20, r23	; 0x14
    9e0c:	8d 8b       	std	Y+21, r24	; 0x15
    9e0e:	9e 8b       	std	Y+22, r25	; 0x16
    9e10:	4f 8b       	std	Y+23, r20	; 0x17
    9e12:	58 8f       	std	Y+24, r21	; 0x18
    9e14:	29 8f       	std	Y+25, r18	; 0x19
    9e16:	3a 8f       	std	Y+26, r19	; 0x1a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9e18:	88 e0       	ldi	r24, 0x08	; 8
    9e1a:	60 e0       	ldi	r22, 0x00	; 0
    9e1c:	0e 94 cc 33 	call	0x6798	; 0x6798 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9e20:	80 e0       	ldi	r24, 0x00	; 0
    9e22:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>
	SPICS(TRUE);
    9e26:	81 e0       	ldi	r24, 0x01	; 1
    9e28:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    9e2c:	89 8d       	ldd	r24, Y+25	; 0x19
    9e2e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9e30:	99 23       	and	r25, r25
    9e32:	14 f4       	brge	.+4      	; 0x9e38 <SD_write_multiple_blocks+0x42>
    9e34:	81 50       	subi	r24, 0x01	; 1
    9e36:	9e 4f       	sbci	r25, 0xFE	; 254
    9e38:	89 2f       	mov	r24, r25
    9e3a:	99 0f       	add	r25, r25
    9e3c:	99 0b       	sbc	r25, r25
    9e3e:	85 95       	asr	r24
    9e40:	89 83       	std	Y+1, r24	; 0x01
    9e42:	9a 83       	std	Y+2, r25	; 0x02
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    9e44:	89 8d       	ldd	r24, Y+25	; 0x19
    9e46:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9e48:	20 e0       	ldi	r18, 0x00	; 0
    9e4a:	32 e0       	ldi	r19, 0x02	; 2
    9e4c:	b9 01       	movw	r22, r18
    9e4e:	0e 94 d1 5b 	call	0xb7a2	; 0xb7a2 <__divmodhi4>
    9e52:	20 e0       	ldi	r18, 0x00	; 0
    9e54:	32 e0       	ldi	r19, 0x02	; 2
    9e56:	a9 01       	movw	r20, r18
    9e58:	48 1b       	sub	r20, r24
    9e5a:	59 0b       	sbc	r21, r25
    9e5c:	ca 01       	movw	r24, r20
    9e5e:	8b 83       	std	Y+3, r24	; 0x03
    9e60:	9c 83       	std	Y+4, r25	; 0x04
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    9e62:	8b 81       	ldd	r24, Y+3	; 0x03
    9e64:	9c 81       	ldd	r25, Y+4	; 0x04
    9e66:	52 e0       	ldi	r21, 0x02	; 2
    9e68:	80 30       	cpi	r24, 0x00	; 0
    9e6a:	95 07       	cpc	r25, r21
    9e6c:	19 f4       	brne	.+6      	; 0x9e74 <SD_write_multiple_blocks+0x7e>
    9e6e:	1b 82       	std	Y+3, r1	; 0x03
    9e70:	1c 82       	std	Y+4, r1	; 0x04
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    9e72:	05 c0       	rjmp	.+10     	; 0x9e7e <SD_write_multiple_blocks+0x88>
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
    9e74:	89 81       	ldd	r24, Y+1	; 0x01
    9e76:	9a 81       	ldd	r25, Y+2	; 0x02
    9e78:	01 96       	adiw	r24, 0x01	; 1
    9e7a:	89 83       	std	Y+1, r24	; 0x01
    9e7c:	9a 83       	std	Y+2, r25	; 0x02
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    9e7e:	00 00       	nop
    9e80:	2b 89       	ldd	r18, Y+19	; 0x13
    9e82:	3c 89       	ldd	r19, Y+20	; 0x14
    9e84:	4d 89       	ldd	r20, Y+21	; 0x15
    9e86:	5e 89       	ldd	r21, Y+22	; 0x16
    9e88:	89 e1       	ldi	r24, 0x19	; 25
    9e8a:	ba 01       	movw	r22, r20
    9e8c:	a9 01       	movw	r20, r18
    9e8e:	2f ef       	ldi	r18, 0xFF	; 255
    9e90:	08 e0       	ldi	r16, 0x08	; 8
    9e92:	10 e0       	ldi	r17, 0x00	; 0
    9e94:	0e 94 39 4d 	call	0x9a72	; 0x9a72 <SD_command>
    9e98:	88 23       	and	r24, r24
    9e9a:	91 f7       	brne	.-28     	; 0x9e80 <SD_write_multiple_blocks+0x8a>
	for (int j=0;j<numSectors;j++){
    9e9c:	1d 82       	std	Y+5, r1	; 0x05
    9e9e:	1e 82       	std	Y+6, r1	; 0x06
    9ea0:	ba c0       	rjmp	.+372    	; 0xa016 <SD_write_multiple_blocks+0x220>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    9ea2:	8f ef       	ldi	r24, 0xFF	; 255
    9ea4:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    9ea8:	80 93 a0 50 	sts	0x50A0, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    9eac:	8c ef       	ldi	r24, 0xFC	; 252
    9eae:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    9eb2:	80 93 a0 50 	sts	0x50A0, r24
		if(j == (numSectors-1)){
    9eb6:	89 81       	ldd	r24, Y+1	; 0x01
    9eb8:	9a 81       	ldd	r25, Y+2	; 0x02
    9eba:	9c 01       	movw	r18, r24
    9ebc:	21 50       	subi	r18, 0x01	; 1
    9ebe:	30 40       	sbci	r19, 0x00	; 0
    9ec0:	8d 81       	ldd	r24, Y+5	; 0x05
    9ec2:	9e 81       	ldd	r25, Y+6	; 0x06
    9ec4:	28 17       	cp	r18, r24
    9ec6:	39 07       	cpc	r19, r25
    9ec8:	09 f0       	breq	.+2      	; 0x9ecc <SD_write_multiple_blocks+0xd6>
    9eca:	54 c0       	rjmp	.+168    	; 0x9f74 <SD_write_multiple_blocks+0x17e>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    9ecc:	1f 82       	std	Y+7, r1	; 0x07
    9ece:	18 86       	std	Y+8, r1	; 0x08
    9ed0:	25 c0       	rjmp	.+74     	; 0x9f1c <SD_write_multiple_blocks+0x126>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    9ed2:	8f 81       	ldd	r24, Y+7	; 0x07
    9ed4:	98 85       	ldd	r25, Y+8	; 0x08
    9ed6:	2c e0       	ldi	r18, 0x0C	; 12
    9ed8:	30 e0       	ldi	r19, 0x00	; 0
    9eda:	b9 01       	movw	r22, r18
    9edc:	0e 94 d1 5b 	call	0xb7a2	; 0xb7a2 <__divmodhi4>
    9ee0:	8c 01       	movw	r16, r24
    9ee2:	8d 81       	ldd	r24, Y+5	; 0x05
    9ee4:	9e 81       	ldd	r25, Y+6	; 0x06
    9ee6:	9c 01       	movw	r18, r24
    9ee8:	32 2f       	mov	r19, r18
    9eea:	22 27       	eor	r18, r18
    9eec:	33 0f       	add	r19, r19
    9eee:	8f 81       	ldd	r24, Y+7	; 0x07
    9ef0:	98 85       	ldd	r25, Y+8	; 0x08
    9ef2:	82 0f       	add	r24, r18
    9ef4:	93 1f       	adc	r25, r19
    9ef6:	2f 89       	ldd	r18, Y+23	; 0x17
    9ef8:	38 8d       	ldd	r19, Y+24	; 0x18
    9efa:	82 0f       	add	r24, r18
    9efc:	93 1f       	adc	r25, r19
    9efe:	fc 01       	movw	r30, r24
    9f00:	80 81       	ld	r24, Z
    9f02:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    9f06:	28 2f       	mov	r18, r24
    9f08:	c8 01       	movw	r24, r16
    9f0a:	81 56       	subi	r24, 0x61	; 97
    9f0c:	9f 4a       	sbci	r25, 0xAF	; 175
    9f0e:	fc 01       	movw	r30, r24
    9f10:	20 83       	st	Z, r18
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    9f12:	8f 81       	ldd	r24, Y+7	; 0x07
    9f14:	98 85       	ldd	r25, Y+8	; 0x08
    9f16:	01 96       	adiw	r24, 0x01	; 1
    9f18:	8f 83       	std	Y+7, r24	; 0x07
    9f1a:	98 87       	std	Y+8, r25	; 0x08
    9f1c:	20 e0       	ldi	r18, 0x00	; 0
    9f1e:	32 e0       	ldi	r19, 0x02	; 2
    9f20:	8b 81       	ldd	r24, Y+3	; 0x03
    9f22:	9c 81       	ldd	r25, Y+4	; 0x04
    9f24:	28 1b       	sub	r18, r24
    9f26:	39 0b       	sbc	r19, r25
    9f28:	8f 81       	ldd	r24, Y+7	; 0x07
    9f2a:	98 85       	ldd	r25, Y+8	; 0x08
    9f2c:	82 17       	cp	r24, r18
    9f2e:	93 07       	cpc	r25, r19
    9f30:	84 f2       	brlt	.-96     	; 0x9ed2 <SD_write_multiple_blocks+0xdc>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    9f32:	19 86       	std	Y+9, r1	; 0x09
    9f34:	1a 86       	std	Y+10, r1	; 0x0a
    9f36:	16 c0       	rjmp	.+44     	; 0x9f64 <SD_write_multiple_blocks+0x16e>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    9f38:	89 85       	ldd	r24, Y+9	; 0x09
    9f3a:	9a 85       	ldd	r25, Y+10	; 0x0a
    9f3c:	2c e0       	ldi	r18, 0x0C	; 12
    9f3e:	30 e0       	ldi	r19, 0x00	; 0
    9f40:	b9 01       	movw	r22, r18
    9f42:	0e 94 d1 5b 	call	0xb7a2	; 0xb7a2 <__divmodhi4>
    9f46:	8c 01       	movw	r16, r24
    9f48:	80 e0       	ldi	r24, 0x00	; 0
    9f4a:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    9f4e:	28 2f       	mov	r18, r24
    9f50:	c8 01       	movw	r24, r16
    9f52:	81 56       	subi	r24, 0x61	; 97
    9f54:	9f 4a       	sbci	r25, 0xAF	; 175
    9f56:	fc 01       	movw	r30, r24
    9f58:	20 83       	st	Z, r18
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    9f5a:	89 85       	ldd	r24, Y+9	; 0x09
    9f5c:	9a 85       	ldd	r25, Y+10	; 0x0a
    9f5e:	01 96       	adiw	r24, 0x01	; 1
    9f60:	89 87       	std	Y+9, r24	; 0x09
    9f62:	9a 87       	std	Y+10, r25	; 0x0a
    9f64:	29 85       	ldd	r18, Y+9	; 0x09
    9f66:	3a 85       	ldd	r19, Y+10	; 0x0a
    9f68:	8b 81       	ldd	r24, Y+3	; 0x03
    9f6a:	9c 81       	ldd	r25, Y+4	; 0x04
    9f6c:	28 17       	cp	r18, r24
    9f6e:	39 07       	cpc	r19, r25
    9f70:	1c f3       	brlt	.-58     	; 0x9f38 <SD_write_multiple_blocks+0x142>
    9f72:	2e c0       	rjmp	.+92     	; 0x9fd0 <SD_write_multiple_blocks+0x1da>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9f74:	1b 86       	std	Y+11, r1	; 0x0b
    9f76:	1c 86       	std	Y+12, r1	; 0x0c
    9f78:	25 c0       	rjmp	.+74     	; 0x9fc4 <SD_write_multiple_blocks+0x1ce>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    9f7a:	8b 85       	ldd	r24, Y+11	; 0x0b
    9f7c:	9c 85       	ldd	r25, Y+12	; 0x0c
    9f7e:	2c e0       	ldi	r18, 0x0C	; 12
    9f80:	30 e0       	ldi	r19, 0x00	; 0
    9f82:	b9 01       	movw	r22, r18
    9f84:	0e 94 d1 5b 	call	0xb7a2	; 0xb7a2 <__divmodhi4>
    9f88:	8c 01       	movw	r16, r24
    9f8a:	8d 81       	ldd	r24, Y+5	; 0x05
    9f8c:	9e 81       	ldd	r25, Y+6	; 0x06
    9f8e:	9c 01       	movw	r18, r24
    9f90:	32 2f       	mov	r19, r18
    9f92:	22 27       	eor	r18, r18
    9f94:	33 0f       	add	r19, r19
    9f96:	8b 85       	ldd	r24, Y+11	; 0x0b
    9f98:	9c 85       	ldd	r25, Y+12	; 0x0c
    9f9a:	82 0f       	add	r24, r18
    9f9c:	93 1f       	adc	r25, r19
    9f9e:	2f 89       	ldd	r18, Y+23	; 0x17
    9fa0:	38 8d       	ldd	r19, Y+24	; 0x18
    9fa2:	82 0f       	add	r24, r18
    9fa4:	93 1f       	adc	r25, r19
    9fa6:	fc 01       	movw	r30, r24
    9fa8:	80 81       	ld	r24, Z
    9faa:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    9fae:	28 2f       	mov	r18, r24
    9fb0:	c8 01       	movw	r24, r16
    9fb2:	81 56       	subi	r24, 0x61	; 97
    9fb4:	9f 4a       	sbci	r25, 0xAF	; 175
    9fb6:	fc 01       	movw	r30, r24
    9fb8:	20 83       	st	Z, r18
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9fba:	8b 85       	ldd	r24, Y+11	; 0x0b
    9fbc:	9c 85       	ldd	r25, Y+12	; 0x0c
    9fbe:	01 96       	adiw	r24, 0x01	; 1
    9fc0:	8b 87       	std	Y+11, r24	; 0x0b
    9fc2:	9c 87       	std	Y+12, r25	; 0x0c
    9fc4:	8b 85       	ldd	r24, Y+11	; 0x0b
    9fc6:	9c 85       	ldd	r25, Y+12	; 0x0c
    9fc8:	f2 e0       	ldi	r31, 0x02	; 2
    9fca:	80 30       	cpi	r24, 0x00	; 0
    9fcc:	9f 07       	cpc	r25, r31
    9fce:	ac f2       	brlt	.-86     	; 0x9f7a <SD_write_multiple_blocks+0x184>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    9fd0:	1d 86       	std	Y+13, r1	; 0x0d
    9fd2:	1e 86       	std	Y+14, r1	; 0x0e
    9fd4:	0a c0       	rjmp	.+20     	; 0x9fea <SD_write_multiple_blocks+0x1f4>
    9fd6:	8f ef       	ldi	r24, 0xFF	; 255
    9fd8:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    9fdc:	80 93 a0 50 	sts	0x50A0, r24
    9fe0:	8d 85       	ldd	r24, Y+13	; 0x0d
    9fe2:	9e 85       	ldd	r25, Y+14	; 0x0e
    9fe4:	01 96       	adiw	r24, 0x01	; 1
    9fe6:	8d 87       	std	Y+13, r24	; 0x0d
    9fe8:	9e 87       	std	Y+14, r25	; 0x0e
    9fea:	8d 85       	ldd	r24, Y+13	; 0x0d
    9fec:	9e 85       	ldd	r25, Y+14	; 0x0e
    9fee:	82 30       	cpi	r24, 0x02	; 2
    9ff0:	91 05       	cpc	r25, r1
    9ff2:	8c f3       	brlt	.-30     	; 0x9fd6 <SD_write_multiple_blocks+0x1e0>
		Buffer[1] = FILLER_BYTE;
    9ff4:	10 92 a0 50 	sts	0x50A0, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    9ff8:	05 c0       	rjmp	.+10     	; 0xa004 <SD_write_multiple_blocks+0x20e>
    9ffa:	8f ef       	ldi	r24, 0xFF	; 255
    9ffc:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    a000:	80 93 a0 50 	sts	0x50A0, r24
    a004:	80 91 a0 50 	lds	r24, 0x50A0
    a008:	8f 3f       	cpi	r24, 0xFF	; 255
    a00a:	b9 f7       	brne	.-18     	; 0x9ffa <SD_write_multiple_blocks+0x204>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    a00c:	8d 81       	ldd	r24, Y+5	; 0x05
    a00e:	9e 81       	ldd	r25, Y+6	; 0x06
    a010:	01 96       	adiw	r24, 0x01	; 1
    a012:	8d 83       	std	Y+5, r24	; 0x05
    a014:	9e 83       	std	Y+6, r25	; 0x06
    a016:	2d 81       	ldd	r18, Y+5	; 0x05
    a018:	3e 81       	ldd	r19, Y+6	; 0x06
    a01a:	89 81       	ldd	r24, Y+1	; 0x01
    a01c:	9a 81       	ldd	r25, Y+2	; 0x02
    a01e:	28 17       	cp	r18, r24
    a020:	39 07       	cpc	r19, r25
    a022:	0c f4       	brge	.+2      	; 0xa026 <SD_write_multiple_blocks+0x230>
    a024:	3e cf       	rjmp	.-388    	; 0x9ea2 <SD_write_multiple_blocks+0xac>
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a026:	1f 86       	std	Y+15, r1	; 0x0f
    a028:	18 8a       	std	Y+16, r1	; 0x10
    a02a:	0a c0       	rjmp	.+20     	; 0xa040 <SD_write_multiple_blocks+0x24a>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a02c:	8f ef       	ldi	r24, 0xFF	; 255
    a02e:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    a032:	80 93 a0 50 	sts	0x50A0, r24
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a036:	8f 85       	ldd	r24, Y+15	; 0x0f
    a038:	98 89       	ldd	r25, Y+16	; 0x10
    a03a:	01 96       	adiw	r24, 0x01	; 1
    a03c:	8f 87       	std	Y+15, r24	; 0x0f
    a03e:	98 8b       	std	Y+16, r25	; 0x10
    a040:	8f 85       	ldd	r24, Y+15	; 0x0f
    a042:	98 89       	ldd	r25, Y+16	; 0x10
    a044:	84 30       	cpi	r24, 0x04	; 4
    a046:	91 05       	cpc	r25, r1
    a048:	8c f3       	brlt	.-30     	; 0xa02c <SD_write_multiple_blocks+0x236>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    a04a:	8d ef       	ldi	r24, 0xFD	; 253
    a04c:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    a050:	80 93 a0 50 	sts	0x50A0, r24
	for(int i=0;i<4;i++){
    a054:	19 8a       	std	Y+17, r1	; 0x11
    a056:	1a 8a       	std	Y+18, r1	; 0x12
    a058:	0a c0       	rjmp	.+20     	; 0xa06e <SD_write_multiple_blocks+0x278>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a05a:	8f ef       	ldi	r24, 0xFF	; 255
    a05c:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    a060:	80 93 a0 50 	sts	0x50A0, r24
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    a064:	89 89       	ldd	r24, Y+17	; 0x11
    a066:	9a 89       	ldd	r25, Y+18	; 0x12
    a068:	01 96       	adiw	r24, 0x01	; 1
    a06a:	89 8b       	std	Y+17, r24	; 0x11
    a06c:	9a 8b       	std	Y+18, r25	; 0x12
    a06e:	89 89       	ldd	r24, Y+17	; 0x11
    a070:	9a 89       	ldd	r25, Y+18	; 0x12
    a072:	84 30       	cpi	r24, 0x04	; 4
    a074:	91 05       	cpc	r25, r1
    a076:	8c f3       	brlt	.-30     	; 0xa05a <SD_write_multiple_blocks+0x264>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    a078:	10 92 a0 50 	sts	0x50A0, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a07c:	05 c0       	rjmp	.+10     	; 0xa088 <SD_write_multiple_blocks+0x292>
    a07e:	8f ef       	ldi	r24, 0xFF	; 255
    a080:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    a084:	80 93 a0 50 	sts	0x50A0, r24
    a088:	80 91 a0 50 	lds	r24, 0x50A0
    a08c:	8f 3f       	cpi	r24, 0xFF	; 255
    a08e:	b9 f7       	brne	.-18     	; 0xa07e <SD_write_multiple_blocks+0x288>
	SPICS(FALSE);
    a090:	80 e0       	ldi	r24, 0x00	; 0
    a092:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	SPIDisable();
    a096:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a09a:	88 e0       	ldi	r24, 0x08	; 8
    a09c:	60 e0       	ldi	r22, 0x00	; 0
    a09e:	0e 94 69 33 	call	0x66d2	; 0x66d2 <PortEx_OUTSET>
}
    a0a2:	6a 96       	adiw	r28, 0x1a	; 26
    a0a4:	cd bf       	out	0x3d, r28	; 61
    a0a6:	de bf       	out	0x3e, r29	; 62
    a0a8:	df 91       	pop	r29
    a0aa:	cf 91       	pop	r28
    a0ac:	1f 91       	pop	r17
    a0ae:	0f 91       	pop	r16
    a0b0:	08 95       	ret

0000a0b2 <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    a0b2:	0f 93       	push	r16
    a0b4:	1f 93       	push	r17
    a0b6:	cf 93       	push	r28
    a0b8:	df 93       	push	r29
    a0ba:	cd b7       	in	r28, 0x3d	; 61
    a0bc:	de b7       	in	r29, 0x3e	; 62
    a0be:	2e 97       	sbiw	r28, 0x0e	; 14
    a0c0:	cd bf       	out	0x3d, r28	; 61
    a0c2:	de bf       	out	0x3e, r29	; 62
    a0c4:	6f 83       	std	Y+7, r22	; 0x07
    a0c6:	78 87       	std	Y+8, r23	; 0x08
    a0c8:	89 87       	std	Y+9, r24	; 0x09
    a0ca:	9a 87       	std	Y+10, r25	; 0x0a
    a0cc:	4b 87       	std	Y+11, r20	; 0x0b
    a0ce:	5c 87       	std	Y+12, r21	; 0x0c
    a0d0:	2d 87       	std	Y+13, r18	; 0x0d
    a0d2:	3e 87       	std	Y+14, r19	; 0x0e
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a0d4:	88 e0       	ldi	r24, 0x08	; 8
    a0d6:	60 e0       	ldi	r22, 0x00	; 0
    a0d8:	0e 94 cc 33 	call	0x6798	; 0x6798 <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a0dc:	80 e0       	ldi	r24, 0x00	; 0
    a0de:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>
	SPICS(TRUE);
    a0e2:	81 e0       	ldi	r24, 0x01	; 1
    a0e4:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    a0e8:	00 00       	nop
    a0ea:	2f 81       	ldd	r18, Y+7	; 0x07
    a0ec:	38 85       	ldd	r19, Y+8	; 0x08
    a0ee:	49 85       	ldd	r20, Y+9	; 0x09
    a0f0:	5a 85       	ldd	r21, Y+10	; 0x0a
    a0f2:	82 e1       	ldi	r24, 0x12	; 18
    a0f4:	ba 01       	movw	r22, r20
    a0f6:	a9 01       	movw	r20, r18
    a0f8:	2f ef       	ldi	r18, 0xFF	; 255
    a0fa:	08 e0       	ldi	r16, 0x08	; 8
    a0fc:	10 e0       	ldi	r17, 0x00	; 0
    a0fe:	0e 94 39 4d 	call	0x9a72	; 0x9a72 <SD_command>
    a102:	88 23       	and	r24, r24
    a104:	91 f7       	brne	.-28     	; 0xa0ea <SD_read_multiple_blocks+0x38>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a106:	19 82       	std	Y+1, r1	; 0x01
    a108:	1a 82       	std	Y+2, r1	; 0x02
    a10a:	4b c0       	rjmp	.+150    	; 0xa1a2 <SD_read_multiple_blocks+0xf0>
		Buffer[1]=SDHC_DUMMY_BYTE;
    a10c:	8f ef       	ldi	r24, 0xFF	; 255
    a10e:	80 93 a0 50 	sts	0x50A0, r24
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a112:	05 c0       	rjmp	.+10     	; 0xa11e <SD_read_multiple_blocks+0x6c>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    a114:	8f ef       	ldi	r24, 0xFF	; 255
    a116:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    a11a:	80 93 a0 50 	sts	0x50A0, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a11e:	80 91 a0 50 	lds	r24, 0x50A0
    a122:	8e 3f       	cpi	r24, 0xFE	; 254
    a124:	b9 f7       	brne	.-18     	; 0xa114 <SD_read_multiple_blocks+0x62>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a126:	1b 82       	std	Y+3, r1	; 0x03
    a128:	1c 82       	std	Y+4, r1	; 0x04
    a12a:	19 c0       	rjmp	.+50     	; 0xa15e <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a12c:	89 81       	ldd	r24, Y+1	; 0x01
    a12e:	9a 81       	ldd	r25, Y+2	; 0x02
    a130:	9c 01       	movw	r18, r24
    a132:	32 2f       	mov	r19, r18
    a134:	22 27       	eor	r18, r18
    a136:	33 0f       	add	r19, r19
    a138:	8b 81       	ldd	r24, Y+3	; 0x03
    a13a:	9c 81       	ldd	r25, Y+4	; 0x04
    a13c:	82 0f       	add	r24, r18
    a13e:	93 1f       	adc	r25, r19
    a140:	2b 85       	ldd	r18, Y+11	; 0x0b
    a142:	3c 85       	ldd	r19, Y+12	; 0x0c
    a144:	89 01       	movw	r16, r18
    a146:	08 0f       	add	r16, r24
    a148:	19 1f       	adc	r17, r25
    a14a:	8f ef       	ldi	r24, 0xFF	; 255
    a14c:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    a150:	f8 01       	movw	r30, r16
    a152:	80 83       	st	Z, r24
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a154:	8b 81       	ldd	r24, Y+3	; 0x03
    a156:	9c 81       	ldd	r25, Y+4	; 0x04
    a158:	01 96       	adiw	r24, 0x01	; 1
    a15a:	8b 83       	std	Y+3, r24	; 0x03
    a15c:	9c 83       	std	Y+4, r25	; 0x04
    a15e:	8b 81       	ldd	r24, Y+3	; 0x03
    a160:	9c 81       	ldd	r25, Y+4	; 0x04
    a162:	f2 e0       	ldi	r31, 0x02	; 2
    a164:	80 30       	cpi	r24, 0x00	; 0
    a166:	9f 07       	cpc	r25, r31
    a168:	0c f3       	brlt	.-62     	; 0xa12c <SD_read_multiple_blocks+0x7a>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a16a:	1d 82       	std	Y+5, r1	; 0x05
    a16c:	1e 82       	std	Y+6, r1	; 0x06
    a16e:	0f c0       	rjmp	.+30     	; 0xa18e <SD_read_multiple_blocks+0xdc>
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    a170:	8f ef       	ldi	r24, 0xFF	; 255
    a172:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    a176:	28 2f       	mov	r18, r24
    a178:	8d 81       	ldd	r24, Y+5	; 0x05
    a17a:	9e 81       	ldd	r25, Y+6	; 0x06
    a17c:	81 56       	subi	r24, 0x61	; 97
    a17e:	9f 4a       	sbci	r25, 0xAF	; 175
    a180:	fc 01       	movw	r30, r24
    a182:	20 83       	st	Z, r18
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a184:	8d 81       	ldd	r24, Y+5	; 0x05
    a186:	9e 81       	ldd	r25, Y+6	; 0x06
    a188:	01 96       	adiw	r24, 0x01	; 1
    a18a:	8d 83       	std	Y+5, r24	; 0x05
    a18c:	9e 83       	std	Y+6, r25	; 0x06
    a18e:	8d 81       	ldd	r24, Y+5	; 0x05
    a190:	9e 81       	ldd	r25, Y+6	; 0x06
    a192:	82 30       	cpi	r24, 0x02	; 2
    a194:	91 05       	cpc	r25, r1
    a196:	64 f3       	brlt	.-40     	; 0xa170 <SD_read_multiple_blocks+0xbe>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a198:	89 81       	ldd	r24, Y+1	; 0x01
    a19a:	9a 81       	ldd	r25, Y+2	; 0x02
    a19c:	01 96       	adiw	r24, 0x01	; 1
    a19e:	89 83       	std	Y+1, r24	; 0x01
    a1a0:	9a 83       	std	Y+2, r25	; 0x02
    a1a2:	29 81       	ldd	r18, Y+1	; 0x01
    a1a4:	3a 81       	ldd	r19, Y+2	; 0x02
    a1a6:	8d 85       	ldd	r24, Y+13	; 0x0d
    a1a8:	9e 85       	ldd	r25, Y+14	; 0x0e
    a1aa:	28 17       	cp	r18, r24
    a1ac:	39 07       	cpc	r19, r25
    a1ae:	0c f4       	brge	.+2      	; 0xa1b2 <SD_read_multiple_blocks+0x100>
    a1b0:	ad cf       	rjmp	.-166    	; 0xa10c <SD_read_multiple_blocks+0x5a>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    a1b2:	8c e0       	ldi	r24, 0x0C	; 12
    a1b4:	40 e0       	ldi	r20, 0x00	; 0
    a1b6:	50 e0       	ldi	r21, 0x00	; 0
    a1b8:	ba 01       	movw	r22, r20
    a1ba:	2f ef       	ldi	r18, 0xFF	; 255
    a1bc:	08 e0       	ldi	r16, 0x08	; 8
    a1be:	10 e0       	ldi	r17, 0x00	; 0
    a1c0:	0e 94 39 4d 	call	0x9a72	; 0x9a72 <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    a1c4:	8f ef       	ldi	r24, 0xFF	; 255
    a1c6:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    a1ca:	80 93 9f 50 	sts	0x509F, r24
	Buffer[1] = FILLER_BYTE;
    a1ce:	10 92 a0 50 	sts	0x50A0, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a1d2:	05 c0       	rjmp	.+10     	; 0xa1de <SD_read_multiple_blocks+0x12c>
    a1d4:	8f ef       	ldi	r24, 0xFF	; 255
    a1d6:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
    a1da:	80 93 a0 50 	sts	0x50A0, r24
    a1de:	80 91 a0 50 	lds	r24, 0x50A0
    a1e2:	8f 3f       	cpi	r24, 0xFF	; 255
    a1e4:	b9 f7       	brne	.-18     	; 0xa1d4 <SD_read_multiple_blocks+0x122>
	SPICS(FALSE);
    a1e6:	80 e0       	ldi	r24, 0x00	; 0
    a1e8:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	SPIDisable();
    a1ec:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a1f0:	88 e0       	ldi	r24, 0x08	; 8
    a1f2:	60 e0       	ldi	r22, 0x00	; 0
    a1f4:	0e 94 69 33 	call	0x66d2	; 0x66d2 <PortEx_OUTSET>
}
    a1f8:	2e 96       	adiw	r28, 0x0e	; 14
    a1fa:	cd bf       	out	0x3d, r28	; 61
    a1fc:	de bf       	out	0x3e, r29	; 62
    a1fe:	df 91       	pop	r29
    a200:	cf 91       	pop	r28
    a202:	1f 91       	pop	r17
    a204:	0f 91       	pop	r16
    a206:	08 95       	ret

0000a208 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
    a208:	cf 93       	push	r28
    a20a:	df 93       	push	r29
    a20c:	cd b7       	in	r28, 0x3d	; 61
    a20e:	de b7       	in	r29, 0x3e	; 62
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    a210:	88 e0       	ldi	r24, 0x08	; 8
    a212:	60 e0       	ldi	r22, 0x00	; 0
    a214:	0e 94 9d 32 	call	0x653a	; 0x653a <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    a218:	88 e0       	ldi	r24, 0x08	; 8
    a21a:	60 e0       	ldi	r22, 0x00	; 0
    a21c:	0e 94 69 33 	call	0x66d2	; 0x66d2 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    a220:	80 e0       	ldi	r24, 0x00	; 0
    a222:	0e 94 39 37 	call	0x6e72	; 0x6e72 <SPIInit>
	SPICS(TRUE);
    a226:	81 e0       	ldi	r24, 0x01	; 1
    a228:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    a22c:	8f ef       	ldi	r24, 0xFF	; 255
    a22e:	0e 94 1b 4d 	call	0x9a36	; 0x9a36 <SPI_write>
	SPICS(FALSE);	//stop spi
    a232:	80 e0       	ldi	r24, 0x00	; 0
    a234:	0e 94 8e 37 	call	0x6f1c	; 0x6f1c <SPICS>
	SPIDisable();
    a238:	0e 94 a6 37 	call	0x6f4c	; 0x6f4c <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    a23c:	80 e0       	ldi	r24, 0x00	; 0
    a23e:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    a242:	80 e0       	ldi	r24, 0x00	; 0
    a244:	0e 94 33 34 	call	0x6866	; 0x6866 <Ext1Power>
}
    a248:	df 91       	pop	r29
    a24a:	cf 91       	pop	r28
    a24c:	08 95       	ret

0000a24e <__muldi3>:
    a24e:	a0 e3       	ldi	r26, 0x30	; 48
    a250:	b0 e0       	ldi	r27, 0x00	; 0
    a252:	ed e2       	ldi	r30, 0x2D	; 45
    a254:	f1 e5       	ldi	r31, 0x51	; 81
    a256:	0c 94 23 5c 	jmp	0xb846	; 0xb846 <__prologue_saves__+0x4>
    a25a:	29 8f       	std	Y+25, r18	; 0x19
    a25c:	3a 8f       	std	Y+26, r19	; 0x1a
    a25e:	4b 8f       	std	Y+27, r20	; 0x1b
    a260:	5c 8f       	std	Y+28, r21	; 0x1c
    a262:	6d 8f       	std	Y+29, r22	; 0x1d
    a264:	7e 8f       	std	Y+30, r23	; 0x1e
    a266:	8f 8f       	std	Y+31, r24	; 0x1f
    a268:	98 a3       	lds	r25, 0x58
    a26a:	a9 8a       	std	Y+17, r10	; 0x11
    a26c:	ba 8a       	std	Y+18, r11	; 0x12
    a26e:	cb 8a       	std	Y+19, r12	; 0x13
    a270:	dc 8a       	std	Y+20, r13	; 0x14
    a272:	ed 8a       	std	Y+21, r14	; 0x15
    a274:	fe 8a       	std	Y+22, r15	; 0x16
    a276:	0f 8b       	std	Y+23, r16	; 0x17
    a278:	18 8f       	std	Y+24, r17	; 0x18
    a27a:	09 8d       	ldd	r16, Y+25	; 0x19
    a27c:	1a 8d       	ldd	r17, Y+26	; 0x1a
    a27e:	2b 8d       	ldd	r18, Y+27	; 0x1b
    a280:	3c 8d       	ldd	r19, Y+28	; 0x1c
    a282:	09 a3       	lds	r16, 0x59
    a284:	1a a3       	lds	r17, 0x5a
    a286:	2b a3       	lds	r18, 0x5b
    a288:	3c a3       	lds	r19, 0x5c
    a28a:	68 01       	movw	r12, r16
    a28c:	79 01       	movw	r14, r18
    a28e:	8f ef       	ldi	r24, 0xFF	; 255
    a290:	9f ef       	ldi	r25, 0xFF	; 255
    a292:	a0 e0       	ldi	r26, 0x00	; 0
    a294:	b0 e0       	ldi	r27, 0x00	; 0
    a296:	c8 22       	and	r12, r24
    a298:	d9 22       	and	r13, r25
    a29a:	ea 22       	and	r14, r26
    a29c:	fb 22       	and	r15, r27
    a29e:	89 01       	movw	r16, r18
    a2a0:	22 27       	eor	r18, r18
    a2a2:	33 27       	eor	r19, r19
    a2a4:	09 a7       	lds	r16, 0x79
    a2a6:	1a a7       	lds	r17, 0x7a
    a2a8:	2b a7       	lds	r18, 0x7b
    a2aa:	3c a7       	lds	r19, 0x7c
    a2ac:	09 89       	ldd	r16, Y+17	; 0x11
    a2ae:	1a 89       	ldd	r17, Y+18	; 0x12
    a2b0:	2b 89       	ldd	r18, Y+19	; 0x13
    a2b2:	3c 89       	ldd	r19, Y+20	; 0x14
    a2b4:	0d a3       	lds	r16, 0x5d
    a2b6:	1e a3       	lds	r17, 0x5e
    a2b8:	2f a3       	lds	r18, 0x5f
    a2ba:	38 a7       	lds	r19, 0x78
    a2bc:	48 01       	movw	r8, r16
    a2be:	59 01       	movw	r10, r18
    a2c0:	88 22       	and	r8, r24
    a2c2:	99 22       	and	r9, r25
    a2c4:	aa 22       	and	r10, r26
    a2c6:	bb 22       	and	r11, r27
    a2c8:	29 01       	movw	r4, r18
    a2ca:	66 24       	eor	r6, r6
    a2cc:	77 24       	eor	r7, r7
    a2ce:	c5 01       	movw	r24, r10
    a2d0:	b4 01       	movw	r22, r8
    a2d2:	a7 01       	movw	r20, r14
    a2d4:	96 01       	movw	r18, r12
    a2d6:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    a2da:	6d a7       	lds	r22, 0x7d
    a2dc:	7e a7       	lds	r23, 0x7e
    a2de:	8f a7       	lds	r24, 0x7f
    a2e0:	98 ab       	sts	0x58, r25
    a2e2:	c3 01       	movw	r24, r6
    a2e4:	b2 01       	movw	r22, r4
    a2e6:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    a2ea:	6b 01       	movw	r12, r22
    a2ec:	7c 01       	movw	r14, r24
    a2ee:	c5 01       	movw	r24, r10
    a2f0:	b4 01       	movw	r22, r8
    a2f2:	29 a5       	lds	r18, 0x69
    a2f4:	3a a5       	lds	r19, 0x6a
    a2f6:	4b a5       	lds	r20, 0x6b
    a2f8:	5c a5       	lds	r21, 0x6c
    a2fa:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    a2fe:	4b 01       	movw	r8, r22
    a300:	5c 01       	movw	r10, r24
    a302:	c3 01       	movw	r24, r6
    a304:	b2 01       	movw	r22, r4
    a306:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    a30a:	ab 01       	movw	r20, r22
    a30c:	bc 01       	movw	r22, r24
    a30e:	c8 0c       	add	r12, r8
    a310:	d9 1c       	adc	r13, r9
    a312:	ea 1c       	adc	r14, r10
    a314:	fb 1c       	adc	r15, r11
    a316:	0d a5       	lds	r16, 0x6d
    a318:	1e a5       	lds	r17, 0x6e
    a31a:	2f a5       	lds	r18, 0x6f
    a31c:	38 a9       	sts	0x48, r19
    a31e:	c9 01       	movw	r24, r18
    a320:	aa 27       	eor	r26, r26
    a322:	bb 27       	eor	r27, r27
    a324:	c8 0e       	add	r12, r24
    a326:	d9 1e       	adc	r13, r25
    a328:	ea 1e       	adc	r14, r26
    a32a:	fb 1e       	adc	r15, r27
    a32c:	c8 14       	cp	r12, r8
    a32e:	d9 04       	cpc	r13, r9
    a330:	ea 04       	cpc	r14, r10
    a332:	fb 04       	cpc	r15, r11
    a334:	20 f4       	brcc	.+8      	; 0xa33e <__muldi3+0xf0>
    a336:	40 50       	subi	r20, 0x00	; 0
    a338:	50 40       	sbci	r21, 0x00	; 0
    a33a:	6f 4f       	sbci	r22, 0xFF	; 255
    a33c:	7f 4f       	sbci	r23, 0xFF	; 255
    a33e:	c7 01       	movw	r24, r14
    a340:	aa 27       	eor	r26, r26
    a342:	bb 27       	eor	r27, r27
    a344:	84 0f       	add	r24, r20
    a346:	95 1f       	adc	r25, r21
    a348:	a6 1f       	adc	r26, r22
    a34a:	b7 1f       	adc	r27, r23
    a34c:	8d 83       	std	Y+5, r24	; 0x05
    a34e:	9e 83       	std	Y+6, r25	; 0x06
    a350:	af 83       	std	Y+7, r26	; 0x07
    a352:	b8 87       	std	Y+8, r27	; 0x08
    a354:	76 01       	movw	r14, r12
    a356:	dd 24       	eor	r13, r13
    a358:	cc 24       	eor	r12, r12
    a35a:	4d a5       	lds	r20, 0x6d
    a35c:	5e a5       	lds	r21, 0x6e
    a35e:	6f a5       	lds	r22, 0x6f
    a360:	78 a9       	sts	0x48, r23
    a362:	60 70       	andi	r22, 0x00	; 0
    a364:	70 70       	andi	r23, 0x00	; 0
    a366:	c4 0e       	add	r12, r20
    a368:	d5 1e       	adc	r13, r21
    a36a:	e6 1e       	adc	r14, r22
    a36c:	f7 1e       	adc	r15, r23
    a36e:	c9 82       	std	Y+1, r12	; 0x01
    a370:	da 82       	std	Y+2, r13	; 0x02
    a372:	eb 82       	std	Y+3, r14	; 0x03
    a374:	fc 82       	std	Y+4, r15	; 0x04
    a376:	1c 2d       	mov	r17, r12
    a378:	0a 81       	ldd	r16, Y+2	; 0x02
    a37a:	8b 80       	ldd	r8, Y+3	; 0x03
    a37c:	4c 80       	ldd	r4, Y+4	; 0x04
    a37e:	8d 87       	std	Y+13, r24	; 0x0d
    a380:	8e 81       	ldd	r24, Y+6	; 0x06
    a382:	8e 87       	std	Y+14, r24	; 0x0e
    a384:	8f 81       	ldd	r24, Y+7	; 0x07
    a386:	8f 87       	std	Y+15, r24	; 0x0f
    a388:	88 85       	ldd	r24, Y+8	; 0x08
    a38a:	88 8b       	std	Y+16, r24	; 0x10
    a38c:	2d 89       	ldd	r18, Y+21	; 0x15
    a38e:	3e 89       	ldd	r19, Y+22	; 0x16
    a390:	4f 89       	ldd	r20, Y+23	; 0x17
    a392:	58 8d       	ldd	r21, Y+24	; 0x18
    a394:	69 a1       	lds	r22, 0x49
    a396:	7a a1       	lds	r23, 0x4a
    a398:	8b a1       	lds	r24, 0x4b
    a39a:	9c a1       	lds	r25, 0x4c
    a39c:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    a3a0:	6b 01       	movw	r12, r22
    a3a2:	7c 01       	movw	r14, r24
    a3a4:	2d 8d       	ldd	r18, Y+29	; 0x1d
    a3a6:	3e 8d       	ldd	r19, Y+30	; 0x1e
    a3a8:	4f 8d       	ldd	r20, Y+31	; 0x1f
    a3aa:	58 a1       	lds	r21, 0x48
    a3ac:	6d a1       	lds	r22, 0x4d
    a3ae:	7e a1       	lds	r23, 0x4e
    a3b0:	8f a1       	lds	r24, 0x4f
    a3b2:	98 a5       	lds	r25, 0x68
    a3b4:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    a3b8:	dc 01       	movw	r26, r24
    a3ba:	cb 01       	movw	r24, r22
    a3bc:	c8 0e       	add	r12, r24
    a3be:	d9 1e       	adc	r13, r25
    a3c0:	ea 1e       	adc	r14, r26
    a3c2:	fb 1e       	adc	r15, r27
    a3c4:	8d 85       	ldd	r24, Y+13	; 0x0d
    a3c6:	9e 85       	ldd	r25, Y+14	; 0x0e
    a3c8:	af 85       	ldd	r26, Y+15	; 0x0f
    a3ca:	b8 89       	ldd	r27, Y+16	; 0x10
    a3cc:	8c 0d       	add	r24, r12
    a3ce:	9d 1d       	adc	r25, r13
    a3d0:	ae 1d       	adc	r26, r14
    a3d2:	bf 1d       	adc	r27, r15
    a3d4:	8d 87       	std	Y+13, r24	; 0x0d
    a3d6:	9e 87       	std	Y+14, r25	; 0x0e
    a3d8:	af 87       	std	Y+15, r26	; 0x0f
    a3da:	b8 8b       	std	Y+16, r27	; 0x10
    a3dc:	68 2f       	mov	r22, r24
    a3de:	7e 85       	ldd	r23, Y+14	; 0x0e
    a3e0:	21 2f       	mov	r18, r17
    a3e2:	30 2f       	mov	r19, r16
    a3e4:	48 2d       	mov	r20, r8
    a3e6:	54 2d       	mov	r21, r4
    a3e8:	8f 85       	ldd	r24, Y+15	; 0x0f
    a3ea:	98 89       	ldd	r25, Y+16	; 0x10
    a3ec:	e0 96       	adiw	r28, 0x30	; 48
    a3ee:	e0 e1       	ldi	r30, 0x10	; 16
    a3f0:	0c 94 3c 5c 	jmp	0xb878	; 0xb878 <__epilogue_restores__+0x4>

0000a3f4 <__ashldi3>:
    a3f4:	cf 92       	push	r12
    a3f6:	df 92       	push	r13
    a3f8:	ef 92       	push	r14
    a3fa:	ff 92       	push	r15
    a3fc:	0f 93       	push	r16
    a3fe:	cf 93       	push	r28
    a400:	df 93       	push	r29
    a402:	cd b7       	in	r28, 0x3d	; 61
    a404:	de b7       	in	r29, 0x3e	; 62
    a406:	60 97       	sbiw	r28, 0x10	; 16
    a408:	cd bf       	out	0x3d, r28	; 61
    a40a:	de bf       	out	0x3e, r29	; 62
    a40c:	00 23       	and	r16, r16
    a40e:	09 f4       	brne	.+2      	; 0xa412 <__ashldi3+0x1e>
    a410:	5a c0       	rjmp	.+180    	; 0xa4c6 <__ashldi3+0xd2>
    a412:	29 87       	std	Y+9, r18	; 0x09
    a414:	3a 87       	std	Y+10, r19	; 0x0a
    a416:	4b 87       	std	Y+11, r20	; 0x0b
    a418:	5c 87       	std	Y+12, r21	; 0x0c
    a41a:	6d 87       	std	Y+13, r22	; 0x0d
    a41c:	7e 87       	std	Y+14, r23	; 0x0e
    a41e:	8f 87       	std	Y+15, r24	; 0x0f
    a420:	98 8b       	std	Y+16, r25	; 0x10
    a422:	80 e2       	ldi	r24, 0x20	; 32
    a424:	80 1b       	sub	r24, r16
    a426:	49 85       	ldd	r20, Y+9	; 0x09
    a428:	5a 85       	ldd	r21, Y+10	; 0x0a
    a42a:	6b 85       	ldd	r22, Y+11	; 0x0b
    a42c:	7c 85       	ldd	r23, Y+12	; 0x0c
    a42e:	18 16       	cp	r1, r24
    a430:	b4 f0       	brlt	.+44     	; 0xa45e <__ashldi3+0x6a>
    a432:	19 82       	std	Y+1, r1	; 0x01
    a434:	1a 82       	std	Y+2, r1	; 0x02
    a436:	1b 82       	std	Y+3, r1	; 0x03
    a438:	1c 82       	std	Y+4, r1	; 0x04
    a43a:	99 27       	eor	r25, r25
    a43c:	87 fd       	sbrc	r24, 7
    a43e:	90 95       	com	r25
    a440:	90 95       	com	r25
    a442:	81 95       	neg	r24
    a444:	9f 4f       	sbci	r25, 0xFF	; 255
    a446:	04 c0       	rjmp	.+8      	; 0xa450 <__ashldi3+0x5c>
    a448:	44 0f       	add	r20, r20
    a44a:	55 1f       	adc	r21, r21
    a44c:	66 1f       	adc	r22, r22
    a44e:	77 1f       	adc	r23, r23
    a450:	8a 95       	dec	r24
    a452:	d2 f7       	brpl	.-12     	; 0xa448 <__ashldi3+0x54>
    a454:	4d 83       	std	Y+5, r20	; 0x05
    a456:	5e 83       	std	Y+6, r21	; 0x06
    a458:	6f 83       	std	Y+7, r22	; 0x07
    a45a:	78 87       	std	Y+8, r23	; 0x08
    a45c:	2c c0       	rjmp	.+88     	; 0xa4b6 <__ashldi3+0xc2>
    a45e:	6a 01       	movw	r12, r20
    a460:	7b 01       	movw	r14, r22
    a462:	00 2e       	mov	r0, r16
    a464:	04 c0       	rjmp	.+8      	; 0xa46e <__ashldi3+0x7a>
    a466:	cc 0c       	add	r12, r12
    a468:	dd 1c       	adc	r13, r13
    a46a:	ee 1c       	adc	r14, r14
    a46c:	ff 1c       	adc	r15, r15
    a46e:	0a 94       	dec	r0
    a470:	d2 f7       	brpl	.-12     	; 0xa466 <__ashldi3+0x72>
    a472:	c9 82       	std	Y+1, r12	; 0x01
    a474:	da 82       	std	Y+2, r13	; 0x02
    a476:	eb 82       	std	Y+3, r14	; 0x03
    a478:	fc 82       	std	Y+4, r15	; 0x04
    a47a:	6a 01       	movw	r12, r20
    a47c:	7b 01       	movw	r14, r22
    a47e:	04 c0       	rjmp	.+8      	; 0xa488 <__ashldi3+0x94>
    a480:	f6 94       	lsr	r15
    a482:	e7 94       	ror	r14
    a484:	d7 94       	ror	r13
    a486:	c7 94       	ror	r12
    a488:	8a 95       	dec	r24
    a48a:	d2 f7       	brpl	.-12     	; 0xa480 <__ashldi3+0x8c>
    a48c:	d7 01       	movw	r26, r14
    a48e:	c6 01       	movw	r24, r12
    a490:	4d 85       	ldd	r20, Y+13	; 0x0d
    a492:	5e 85       	ldd	r21, Y+14	; 0x0e
    a494:	6f 85       	ldd	r22, Y+15	; 0x0f
    a496:	78 89       	ldd	r23, Y+16	; 0x10
    a498:	04 c0       	rjmp	.+8      	; 0xa4a2 <__ashldi3+0xae>
    a49a:	44 0f       	add	r20, r20
    a49c:	55 1f       	adc	r21, r21
    a49e:	66 1f       	adc	r22, r22
    a4a0:	77 1f       	adc	r23, r23
    a4a2:	0a 95       	dec	r16
    a4a4:	d2 f7       	brpl	.-12     	; 0xa49a <__ashldi3+0xa6>
    a4a6:	84 2b       	or	r24, r20
    a4a8:	95 2b       	or	r25, r21
    a4aa:	a6 2b       	or	r26, r22
    a4ac:	b7 2b       	or	r27, r23
    a4ae:	8d 83       	std	Y+5, r24	; 0x05
    a4b0:	9e 83       	std	Y+6, r25	; 0x06
    a4b2:	af 83       	std	Y+7, r26	; 0x07
    a4b4:	b8 87       	std	Y+8, r27	; 0x08
    a4b6:	29 81       	ldd	r18, Y+1	; 0x01
    a4b8:	3a 81       	ldd	r19, Y+2	; 0x02
    a4ba:	4b 81       	ldd	r20, Y+3	; 0x03
    a4bc:	5c 81       	ldd	r21, Y+4	; 0x04
    a4be:	6d 81       	ldd	r22, Y+5	; 0x05
    a4c0:	7e 81       	ldd	r23, Y+6	; 0x06
    a4c2:	8f 81       	ldd	r24, Y+7	; 0x07
    a4c4:	98 85       	ldd	r25, Y+8	; 0x08
    a4c6:	60 96       	adiw	r28, 0x10	; 16
    a4c8:	cd bf       	out	0x3d, r28	; 61
    a4ca:	de bf       	out	0x3e, r29	; 62
    a4cc:	df 91       	pop	r29
    a4ce:	cf 91       	pop	r28
    a4d0:	0f 91       	pop	r16
    a4d2:	ff 90       	pop	r15
    a4d4:	ef 90       	pop	r14
    a4d6:	df 90       	pop	r13
    a4d8:	cf 90       	pop	r12
    a4da:	08 95       	ret

0000a4dc <__divdi3>:
    a4dc:	a8 e4       	ldi	r26, 0x48	; 72
    a4de:	b0 e0       	ldi	r27, 0x00	; 0
    a4e0:	e4 e7       	ldi	r30, 0x74	; 116
    a4e2:	f2 e5       	ldi	r31, 0x52	; 82
    a4e4:	0c 94 22 5c 	jmp	0xb844	; 0xb844 <__prologue_saves__+0x2>
    a4e8:	f5 01       	movw	r30, r10
    a4ea:	29 a3       	lds	r18, 0x59
    a4ec:	3a a3       	lds	r19, 0x5a
    a4ee:	4b a3       	lds	r20, 0x5b
    a4f0:	5c a3       	lds	r21, 0x5c
    a4f2:	6d a3       	lds	r22, 0x5d
    a4f4:	7e a3       	lds	r23, 0x5e
    a4f6:	8f a3       	lds	r24, 0x5f
    a4f8:	98 a7       	lds	r25, 0x78
    a4fa:	a9 8e       	std	Y+25, r10	; 0x19
    a4fc:	fa 8f       	std	Y+26, r31	; 0x1a
    a4fe:	cb 8e       	std	Y+27, r12	; 0x1b
    a500:	dc 8e       	std	Y+28, r13	; 0x1c
    a502:	ed 8e       	std	Y+29, r14	; 0x1d
    a504:	fe 8e       	std	Y+30, r15	; 0x1e
    a506:	0f 8f       	std	Y+31, r16	; 0x1f
    a508:	18 a3       	lds	r17, 0x58
    a50a:	8d a0       	lds	r24, 0x8d
    a50c:	9e a0       	lds	r25, 0x8e
    a50e:	af a0       	lds	r26, 0x8f
    a510:	b8 a4       	lds	r27, 0xa8
    a512:	b7 fe       	sbrs	r11, 7
    a514:	67 c0       	rjmp	.+206    	; 0xa5e4 <__divdi3+0x108>
    a516:	21 95       	neg	r18
    a518:	b1 e0       	ldi	r27, 0x01	; 1
    a51a:	12 16       	cp	r1, r18
    a51c:	08 f0       	brcs	.+2      	; 0xa520 <__divdi3+0x44>
    a51e:	b0 e0       	ldi	r27, 0x00	; 0
    a520:	31 95       	neg	r19
    a522:	a1 e0       	ldi	r26, 0x01	; 1
    a524:	13 16       	cp	r1, r19
    a526:	08 f0       	brcs	.+2      	; 0xa52a <__divdi3+0x4e>
    a528:	a0 e0       	ldi	r26, 0x00	; 0
    a52a:	b3 2e       	mov	r11, r19
    a52c:	bb 1a       	sub	r11, r27
    a52e:	bb 2d       	mov	r27, r11
    a530:	88 24       	eor	r8, r8
    a532:	83 94       	inc	r8
    a534:	3b 15       	cp	r19, r11
    a536:	08 f0       	brcs	.+2      	; 0xa53a <__divdi3+0x5e>
    a538:	88 24       	eor	r8, r8
    a53a:	a8 29       	or	r26, r8
    a53c:	41 95       	neg	r20
    a53e:	31 e0       	ldi	r19, 0x01	; 1
    a540:	14 16       	cp	r1, r20
    a542:	08 f0       	brcs	.+2      	; 0xa546 <__divdi3+0x6a>
    a544:	30 e0       	ldi	r19, 0x00	; 0
    a546:	b4 2e       	mov	r11, r20
    a548:	ba 1a       	sub	r11, r26
    a54a:	ab 2d       	mov	r26, r11
    a54c:	88 24       	eor	r8, r8
    a54e:	83 94       	inc	r8
    a550:	4b 15       	cp	r20, r11
    a552:	08 f0       	brcs	.+2      	; 0xa556 <__divdi3+0x7a>
    a554:	88 24       	eor	r8, r8
    a556:	38 29       	or	r19, r8
    a558:	51 95       	neg	r21
    a55a:	41 e0       	ldi	r20, 0x01	; 1
    a55c:	15 16       	cp	r1, r21
    a55e:	08 f0       	brcs	.+2      	; 0xa562 <__divdi3+0x86>
    a560:	40 e0       	ldi	r20, 0x00	; 0
    a562:	45 2e       	mov	r4, r21
    a564:	43 1a       	sub	r4, r19
    a566:	31 e0       	ldi	r19, 0x01	; 1
    a568:	54 15       	cp	r21, r4
    a56a:	08 f0       	brcs	.+2      	; 0xa56e <__divdi3+0x92>
    a56c:	30 e0       	ldi	r19, 0x00	; 0
    a56e:	43 2b       	or	r20, r19
    a570:	61 95       	neg	r22
    a572:	31 e0       	ldi	r19, 0x01	; 1
    a574:	16 16       	cp	r1, r22
    a576:	08 f0       	brcs	.+2      	; 0xa57a <__divdi3+0x9e>
    a578:	30 e0       	ldi	r19, 0x00	; 0
    a57a:	86 2e       	mov	r8, r22
    a57c:	84 1a       	sub	r8, r20
    a57e:	41 e0       	ldi	r20, 0x01	; 1
    a580:	68 15       	cp	r22, r8
    a582:	08 f0       	brcs	.+2      	; 0xa586 <__divdi3+0xaa>
    a584:	40 e0       	ldi	r20, 0x00	; 0
    a586:	34 2b       	or	r19, r20
    a588:	71 95       	neg	r23
    a58a:	41 e0       	ldi	r20, 0x01	; 1
    a58c:	17 16       	cp	r1, r23
    a58e:	08 f0       	brcs	.+2      	; 0xa592 <__divdi3+0xb6>
    a590:	40 e0       	ldi	r20, 0x00	; 0
    a592:	57 2f       	mov	r21, r23
    a594:	53 1b       	sub	r21, r19
    a596:	31 e0       	ldi	r19, 0x01	; 1
    a598:	75 17       	cp	r23, r21
    a59a:	08 f0       	brcs	.+2      	; 0xa59e <__divdi3+0xc2>
    a59c:	30 e0       	ldi	r19, 0x00	; 0
    a59e:	43 2b       	or	r20, r19
    a5a0:	81 95       	neg	r24
    a5a2:	31 e0       	ldi	r19, 0x01	; 1
    a5a4:	18 16       	cp	r1, r24
    a5a6:	08 f0       	brcs	.+2      	; 0xa5aa <__divdi3+0xce>
    a5a8:	30 e0       	ldi	r19, 0x00	; 0
    a5aa:	68 2f       	mov	r22, r24
    a5ac:	64 1b       	sub	r22, r20
    a5ae:	46 2f       	mov	r20, r22
    a5b0:	61 e0       	ldi	r22, 0x01	; 1
    a5b2:	84 17       	cp	r24, r20
    a5b4:	08 f0       	brcs	.+2      	; 0xa5b8 <__divdi3+0xdc>
    a5b6:	60 e0       	ldi	r22, 0x00	; 0
    a5b8:	36 2b       	or	r19, r22
    a5ba:	91 95       	neg	r25
    a5bc:	93 1b       	sub	r25, r19
    a5be:	29 a3       	lds	r18, 0x59
    a5c0:	ba a3       	lds	r27, 0x5a
    a5c2:	ab a3       	lds	r26, 0x5b
    a5c4:	4c a2       	lds	r20, 0x9c
    a5c6:	8d a2       	lds	r24, 0x9d
    a5c8:	5e a3       	lds	r21, 0x5e
    a5ca:	4f a3       	lds	r20, 0x5f
    a5cc:	98 a7       	lds	r25, 0x78
    a5ce:	8f ef       	ldi	r24, 0xFF	; 255
    a5d0:	9f ef       	ldi	r25, 0xFF	; 255
    a5d2:	af ef       	ldi	r26, 0xFF	; 255
    a5d4:	bf ef       	ldi	r27, 0xFF	; 255
    a5d6:	25 96       	adiw	r28, 0x05	; 5
    a5d8:	8c af       	sts	0x7c, r24
    a5da:	9d af       	sts	0x7d, r25
    a5dc:	ae af       	sts	0x7e, r26
    a5de:	bf af       	sts	0x7f, r27
    a5e0:	25 97       	sbiw	r28, 0x05	; 5
    a5e2:	06 c0       	rjmp	.+12     	; 0xa5f0 <__divdi3+0x114>
    a5e4:	25 96       	adiw	r28, 0x05	; 5
    a5e6:	1c ae       	sts	0xbc, r17
    a5e8:	1d ae       	sts	0xbd, r17
    a5ea:	1e ae       	sts	0xbe, r17
    a5ec:	1f ae       	sts	0xbf, r17
    a5ee:	25 97       	sbiw	r28, 0x05	; 5
    a5f0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    a5f2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    a5f4:	af 8d       	ldd	r26, Y+31	; 0x1f
    a5f6:	b8 a1       	lds	r27, 0x48
    a5f8:	b7 ff       	sbrs	r27, 7
    a5fa:	68 c0       	rjmp	.+208    	; 0xa6cc <__divdi3+0x1f0>
    a5fc:	25 96       	adiw	r28, 0x05	; 5
    a5fe:	2c ad       	sts	0x6c, r18
    a600:	3d ad       	sts	0x6d, r19
    a602:	4e ad       	sts	0x6e, r20
    a604:	5f ad       	sts	0x6f, r21
    a606:	25 97       	sbiw	r28, 0x05	; 5
    a608:	20 95       	com	r18
    a60a:	30 95       	com	r19
    a60c:	40 95       	com	r20
    a60e:	50 95       	com	r21
    a610:	25 96       	adiw	r28, 0x05	; 5
    a612:	2c af       	sts	0x7c, r18
    a614:	3d af       	sts	0x7d, r19
    a616:	4e af       	sts	0x7e, r20
    a618:	5f af       	sts	0x7f, r21
    a61a:	25 97       	sbiw	r28, 0x05	; 5
    a61c:	e1 95       	neg	r30
    a61e:	81 e0       	ldi	r24, 0x01	; 1
    a620:	1e 16       	cp	r1, r30
    a622:	08 f0       	brcs	.+2      	; 0xa626 <__divdi3+0x14a>
    a624:	80 e0       	ldi	r24, 0x00	; 0
    a626:	f1 95       	neg	r31
    a628:	91 e0       	ldi	r25, 0x01	; 1
    a62a:	1f 16       	cp	r1, r31
    a62c:	08 f0       	brcs	.+2      	; 0xa630 <__divdi3+0x154>
    a62e:	90 e0       	ldi	r25, 0x00	; 0
    a630:	4f 2f       	mov	r20, r31
    a632:	48 1b       	sub	r20, r24
    a634:	81 e0       	ldi	r24, 0x01	; 1
    a636:	f4 17       	cp	r31, r20
    a638:	08 f0       	brcs	.+2      	; 0xa63c <__divdi3+0x160>
    a63a:	80 e0       	ldi	r24, 0x00	; 0
    a63c:	98 2b       	or	r25, r24
    a63e:	c1 94       	neg	r12
    a640:	81 e0       	ldi	r24, 0x01	; 1
    a642:	1c 14       	cp	r1, r12
    a644:	08 f0       	brcs	.+2      	; 0xa648 <__divdi3+0x16c>
    a646:	80 e0       	ldi	r24, 0x00	; 0
    a648:	6c 2d       	mov	r22, r12
    a64a:	69 1b       	sub	r22, r25
    a64c:	91 e0       	ldi	r25, 0x01	; 1
    a64e:	c6 16       	cp	r12, r22
    a650:	08 f0       	brcs	.+2      	; 0xa654 <__divdi3+0x178>
    a652:	90 e0       	ldi	r25, 0x00	; 0
    a654:	89 2b       	or	r24, r25
    a656:	d1 94       	neg	r13
    a658:	91 e0       	ldi	r25, 0x01	; 1
    a65a:	1d 14       	cp	r1, r13
    a65c:	08 f0       	brcs	.+2      	; 0xa660 <__divdi3+0x184>
    a65e:	90 e0       	ldi	r25, 0x00	; 0
    a660:	5d 2d       	mov	r21, r13
    a662:	58 1b       	sub	r21, r24
    a664:	81 e0       	ldi	r24, 0x01	; 1
    a666:	d5 16       	cp	r13, r21
    a668:	08 f0       	brcs	.+2      	; 0xa66c <__divdi3+0x190>
    a66a:	80 e0       	ldi	r24, 0x00	; 0
    a66c:	98 2b       	or	r25, r24
    a66e:	e1 94       	neg	r14
    a670:	81 e0       	ldi	r24, 0x01	; 1
    a672:	1e 14       	cp	r1, r14
    a674:	08 f0       	brcs	.+2      	; 0xa678 <__divdi3+0x19c>
    a676:	80 e0       	ldi	r24, 0x00	; 0
    a678:	3e 2d       	mov	r19, r14
    a67a:	39 1b       	sub	r19, r25
    a67c:	91 e0       	ldi	r25, 0x01	; 1
    a67e:	e3 16       	cp	r14, r19
    a680:	08 f0       	brcs	.+2      	; 0xa684 <__divdi3+0x1a8>
    a682:	90 e0       	ldi	r25, 0x00	; 0
    a684:	89 2b       	or	r24, r25
    a686:	f1 94       	neg	r15
    a688:	91 e0       	ldi	r25, 0x01	; 1
    a68a:	1f 14       	cp	r1, r15
    a68c:	08 f0       	brcs	.+2      	; 0xa690 <__divdi3+0x1b4>
    a68e:	90 e0       	ldi	r25, 0x00	; 0
    a690:	2f 2d       	mov	r18, r15
    a692:	28 1b       	sub	r18, r24
    a694:	81 e0       	ldi	r24, 0x01	; 1
    a696:	f2 16       	cp	r15, r18
    a698:	08 f0       	brcs	.+2      	; 0xa69c <__divdi3+0x1c0>
    a69a:	80 e0       	ldi	r24, 0x00	; 0
    a69c:	98 2b       	or	r25, r24
    a69e:	01 95       	neg	r16
    a6a0:	81 e0       	ldi	r24, 0x01	; 1
    a6a2:	10 16       	cp	r1, r16
    a6a4:	08 f0       	brcs	.+2      	; 0xa6a8 <__divdi3+0x1cc>
    a6a6:	80 e0       	ldi	r24, 0x00	; 0
    a6a8:	70 2f       	mov	r23, r16
    a6aa:	79 1b       	sub	r23, r25
    a6ac:	97 2f       	mov	r25, r23
    a6ae:	71 e0       	ldi	r23, 0x01	; 1
    a6b0:	09 17       	cp	r16, r25
    a6b2:	08 f0       	brcs	.+2      	; 0xa6b6 <__divdi3+0x1da>
    a6b4:	70 e0       	ldi	r23, 0x00	; 0
    a6b6:	87 2b       	or	r24, r23
    a6b8:	11 95       	neg	r17
    a6ba:	18 1b       	sub	r17, r24
    a6bc:	e9 8f       	std	Y+25, r30	; 0x19
    a6be:	4a 8f       	std	Y+26, r20	; 0x1a
    a6c0:	6b 8f       	std	Y+27, r22	; 0x1b
    a6c2:	5c 8f       	std	Y+28, r21	; 0x1c
    a6c4:	3d 8f       	std	Y+29, r19	; 0x1d
    a6c6:	2e 8f       	std	Y+30, r18	; 0x1e
    a6c8:	9f 8f       	std	Y+31, r25	; 0x1f
    a6ca:	18 a3       	lds	r17, 0x58
    a6cc:	79 8d       	ldd	r23, Y+25	; 0x19
    a6ce:	6a 8d       	ldd	r22, Y+26	; 0x1a
    a6d0:	5b 8d       	ldd	r21, Y+27	; 0x1b
    a6d2:	4c 8d       	ldd	r20, Y+28	; 0x1c
    a6d4:	3d 8d       	ldd	r19, Y+29	; 0x1d
    a6d6:	2e 8d       	ldd	r18, Y+30	; 0x1e
    a6d8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    a6da:	88 a1       	lds	r24, 0x48
    a6dc:	e9 a1       	lds	r30, 0x49
    a6de:	e9 8b       	std	Y+17, r30	; 0x11
    a6e0:	ea a1       	lds	r30, 0x4a
    a6e2:	ea 8b       	std	Y+18, r30	; 0x12
    a6e4:	eb a1       	lds	r30, 0x4b
    a6e6:	eb 8b       	std	Y+19, r30	; 0x13
    a6e8:	ec a1       	lds	r30, 0x4c
    a6ea:	ec 8b       	std	Y+20, r30	; 0x14
    a6ec:	ed a1       	lds	r30, 0x4d
    a6ee:	ed 8b       	std	Y+21, r30	; 0x15
    a6f0:	ee a1       	lds	r30, 0x4e
    a6f2:	ee 8b       	std	Y+22, r30	; 0x16
    a6f4:	ef a1       	lds	r30, 0x4f
    a6f6:	ef 8b       	std	Y+23, r30	; 0x17
    a6f8:	e8 a5       	lds	r30, 0x68
    a6fa:	e8 8f       	std	Y+24, r30	; 0x18
    a6fc:	79 87       	std	Y+9, r23	; 0x09
    a6fe:	6a 87       	std	Y+10, r22	; 0x0a
    a700:	5b 87       	std	Y+11, r21	; 0x0b
    a702:	4c 87       	std	Y+12, r20	; 0x0c
    a704:	3d 87       	std	Y+13, r19	; 0x0d
    a706:	2e 87       	std	Y+14, r18	; 0x0e
    a708:	9f 87       	std	Y+15, r25	; 0x0f
    a70a:	88 8b       	std	Y+16, r24	; 0x10
    a70c:	89 84       	ldd	r8, Y+9	; 0x09
    a70e:	9a 84       	ldd	r9, Y+10	; 0x0a
    a710:	ab 84       	ldd	r10, Y+11	; 0x0b
    a712:	bc 84       	ldd	r11, Y+12	; 0x0c
    a714:	8d 85       	ldd	r24, Y+13	; 0x0d
    a716:	9e 85       	ldd	r25, Y+14	; 0x0e
    a718:	af 85       	ldd	r26, Y+15	; 0x0f
    a71a:	b8 89       	ldd	r27, Y+16	; 0x10
    a71c:	e9 88       	ldd	r14, Y+17	; 0x11
    a71e:	fa 88       	ldd	r15, Y+18	; 0x12
    a720:	0b 89       	ldd	r16, Y+19	; 0x13
    a722:	1c 89       	ldd	r17, Y+20	; 0x14
    a724:	ed aa       	sts	0x9d, r30
    a726:	fe aa       	sts	0x9e, r31
    a728:	0f ab       	sts	0x5f, r16
    a72a:	18 af       	sts	0x78, r17
    a72c:	cd 88       	ldd	r12, Y+21	; 0x15
    a72e:	de 88       	ldd	r13, Y+22	; 0x16
    a730:	ef 88       	ldd	r14, Y+23	; 0x17
    a732:	f8 8c       	ldd	r15, Y+24	; 0x18
    a734:	00 97       	sbiw	r24, 0x00	; 0
    a736:	a1 05       	cpc	r26, r1
    a738:	b1 05       	cpc	r27, r1
    a73a:	09 f0       	breq	.+2      	; 0xa73e <__divdi3+0x262>
    a73c:	bd c3       	rjmp	.+1914   	; 0xaeb8 <__divdi3+0x9dc>
    a73e:	c8 14       	cp	r12, r8
    a740:	d9 04       	cpc	r13, r9
    a742:	ea 04       	cpc	r14, r10
    a744:	fb 04       	cpc	r15, r11
    a746:	08 f0       	brcs	.+2      	; 0xa74a <__divdi3+0x26e>
    a748:	4d c1       	rjmp	.+666    	; 0xa9e4 <__divdi3+0x508>
    a74a:	00 e0       	ldi	r16, 0x00	; 0
    a74c:	80 16       	cp	r8, r16
    a74e:	00 e0       	ldi	r16, 0x00	; 0
    a750:	90 06       	cpc	r9, r16
    a752:	01 e0       	ldi	r16, 0x01	; 1
    a754:	a0 06       	cpc	r10, r16
    a756:	00 e0       	ldi	r16, 0x00	; 0
    a758:	b0 06       	cpc	r11, r16
    a75a:	58 f4       	brcc	.+22     	; 0xa772 <__divdi3+0x296>
    a75c:	1f ef       	ldi	r17, 0xFF	; 255
    a75e:	81 16       	cp	r8, r17
    a760:	91 04       	cpc	r9, r1
    a762:	a1 04       	cpc	r10, r1
    a764:	b1 04       	cpc	r11, r1
    a766:	09 f0       	breq	.+2      	; 0xa76a <__divdi3+0x28e>
    a768:	90 f4       	brcc	.+36     	; 0xa78e <__divdi3+0x2b2>
    a76a:	80 e0       	ldi	r24, 0x00	; 0
    a76c:	90 e0       	ldi	r25, 0x00	; 0
    a76e:	dc 01       	movw	r26, r24
    a770:	17 c0       	rjmp	.+46     	; 0xa7a0 <__divdi3+0x2c4>
    a772:	20 e0       	ldi	r18, 0x00	; 0
    a774:	82 16       	cp	r8, r18
    a776:	20 e0       	ldi	r18, 0x00	; 0
    a778:	92 06       	cpc	r9, r18
    a77a:	20 e0       	ldi	r18, 0x00	; 0
    a77c:	a2 06       	cpc	r10, r18
    a77e:	21 e0       	ldi	r18, 0x01	; 1
    a780:	b2 06       	cpc	r11, r18
    a782:	50 f4       	brcc	.+20     	; 0xa798 <__divdi3+0x2bc>
    a784:	80 e1       	ldi	r24, 0x10	; 16
    a786:	90 e0       	ldi	r25, 0x00	; 0
    a788:	a0 e0       	ldi	r26, 0x00	; 0
    a78a:	b0 e0       	ldi	r27, 0x00	; 0
    a78c:	09 c0       	rjmp	.+18     	; 0xa7a0 <__divdi3+0x2c4>
    a78e:	88 e0       	ldi	r24, 0x08	; 8
    a790:	90 e0       	ldi	r25, 0x00	; 0
    a792:	a0 e0       	ldi	r26, 0x00	; 0
    a794:	b0 e0       	ldi	r27, 0x00	; 0
    a796:	04 c0       	rjmp	.+8      	; 0xa7a0 <__divdi3+0x2c4>
    a798:	88 e1       	ldi	r24, 0x18	; 24
    a79a:	90 e0       	ldi	r25, 0x00	; 0
    a79c:	a0 e0       	ldi	r26, 0x00	; 0
    a79e:	b0 e0       	ldi	r27, 0x00	; 0
    a7a0:	b5 01       	movw	r22, r10
    a7a2:	a4 01       	movw	r20, r8
    a7a4:	08 2e       	mov	r0, r24
    a7a6:	04 c0       	rjmp	.+8      	; 0xa7b0 <__divdi3+0x2d4>
    a7a8:	76 95       	lsr	r23
    a7aa:	67 95       	ror	r22
    a7ac:	57 95       	ror	r21
    a7ae:	47 95       	ror	r20
    a7b0:	0a 94       	dec	r0
    a7b2:	d2 f7       	brpl	.-12     	; 0xa7a8 <__divdi3+0x2cc>
    a7b4:	fa 01       	movw	r30, r20
    a7b6:	e6 5d       	subi	r30, 0xD6	; 214
    a7b8:	ff 4d       	sbci	r31, 0xDF	; 223
    a7ba:	20 81       	ld	r18, Z
    a7bc:	40 e2       	ldi	r20, 0x20	; 32
    a7be:	50 e0       	ldi	r21, 0x00	; 0
    a7c0:	60 e0       	ldi	r22, 0x00	; 0
    a7c2:	70 e0       	ldi	r23, 0x00	; 0
    a7c4:	48 1b       	sub	r20, r24
    a7c6:	59 0b       	sbc	r21, r25
    a7c8:	6a 0b       	sbc	r22, r26
    a7ca:	7b 0b       	sbc	r23, r27
    a7cc:	42 1b       	sub	r20, r18
    a7ce:	51 09       	sbc	r21, r1
    a7d0:	61 09       	sbc	r22, r1
    a7d2:	71 09       	sbc	r23, r1
    a7d4:	41 15       	cp	r20, r1
    a7d6:	51 05       	cpc	r21, r1
    a7d8:	61 05       	cpc	r22, r1
    a7da:	71 05       	cpc	r23, r1
    a7dc:	a1 f1       	breq	.+104    	; 0xa846 <__divdi3+0x36a>
    a7de:	04 2e       	mov	r0, r20
    a7e0:	04 c0       	rjmp	.+8      	; 0xa7ea <__divdi3+0x30e>
    a7e2:	88 0c       	add	r8, r8
    a7e4:	99 1c       	adc	r9, r9
    a7e6:	aa 1c       	adc	r10, r10
    a7e8:	bb 1c       	adc	r11, r11
    a7ea:	0a 94       	dec	r0
    a7ec:	d2 f7       	brpl	.-12     	; 0xa7e2 <__divdi3+0x306>
    a7ee:	97 01       	movw	r18, r14
    a7f0:	86 01       	movw	r16, r12
    a7f2:	04 2e       	mov	r0, r20
    a7f4:	04 c0       	rjmp	.+8      	; 0xa7fe <__divdi3+0x322>
    a7f6:	00 0f       	add	r16, r16
    a7f8:	11 1f       	adc	r17, r17
    a7fa:	22 1f       	adc	r18, r18
    a7fc:	33 1f       	adc	r19, r19
    a7fe:	0a 94       	dec	r0
    a800:	d2 f7       	brpl	.-12     	; 0xa7f6 <__divdi3+0x31a>
    a802:	80 e2       	ldi	r24, 0x20	; 32
    a804:	90 e0       	ldi	r25, 0x00	; 0
    a806:	84 1b       	sub	r24, r20
    a808:	95 0b       	sbc	r25, r21
    a80a:	cd a8       	sts	0x8d, r28
    a80c:	de a8       	sts	0x8e, r29
    a80e:	ef a8       	sts	0x8f, r30
    a810:	f8 ac       	sts	0xa8, r31
    a812:	04 c0       	rjmp	.+8      	; 0xa81c <__divdi3+0x340>
    a814:	f6 94       	lsr	r15
    a816:	e7 94       	ror	r14
    a818:	d7 94       	ror	r13
    a81a:	c7 94       	ror	r12
    a81c:	8a 95       	dec	r24
    a81e:	d2 f7       	brpl	.-12     	; 0xa814 <__divdi3+0x338>
    a820:	c0 2a       	or	r12, r16
    a822:	d1 2a       	or	r13, r17
    a824:	e2 2a       	or	r14, r18
    a826:	f3 2a       	or	r15, r19
    a828:	0d a9       	sts	0x4d, r16
    a82a:	1e a9       	sts	0x4e, r17
    a82c:	2f a9       	sts	0x4f, r18
    a82e:	38 ad       	sts	0x68, r19
    a830:	04 c0       	rjmp	.+8      	; 0xa83a <__divdi3+0x35e>
    a832:	00 0f       	add	r16, r16
    a834:	11 1f       	adc	r17, r17
    a836:	22 1f       	adc	r18, r18
    a838:	33 1f       	adc	r19, r19
    a83a:	4a 95       	dec	r20
    a83c:	d2 f7       	brpl	.-12     	; 0xa832 <__divdi3+0x356>
    a83e:	0d ab       	sts	0x5d, r16
    a840:	1e ab       	sts	0x5e, r17
    a842:	2f ab       	sts	0x5f, r18
    a844:	38 af       	sts	0x78, r19
    a846:	25 01       	movw	r4, r10
    a848:	66 24       	eor	r6, r6
    a84a:	77 24       	eor	r7, r7
    a84c:	95 01       	movw	r18, r10
    a84e:	84 01       	movw	r16, r8
    a850:	20 70       	andi	r18, 0x00	; 0
    a852:	30 70       	andi	r19, 0x00	; 0
    a854:	09 ab       	sts	0x59, r16
    a856:	1a ab       	sts	0x5a, r17
    a858:	2b ab       	sts	0x5b, r18
    a85a:	3c ab       	sts	0x5c, r19
    a85c:	c7 01       	movw	r24, r14
    a85e:	b6 01       	movw	r22, r12
    a860:	a3 01       	movw	r20, r6
    a862:	92 01       	movw	r18, r4
    a864:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    a868:	2d a7       	lds	r18, 0x7d
    a86a:	3e a7       	lds	r19, 0x7e
    a86c:	4f a7       	lds	r20, 0x7f
    a86e:	58 ab       	sts	0x58, r21
    a870:	69 a7       	lds	r22, 0x79
    a872:	7a a7       	lds	r23, 0x7a
    a874:	8b a7       	lds	r24, 0x7b
    a876:	9c a7       	lds	r25, 0x7c
    a878:	c7 01       	movw	r24, r14
    a87a:	b6 01       	movw	r22, r12
    a87c:	a3 01       	movw	r20, r6
    a87e:	92 01       	movw	r18, r4
    a880:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    a884:	ca 01       	movw	r24, r20
    a886:	b9 01       	movw	r22, r18
    a888:	29 a9       	sts	0x49, r18
    a88a:	3a a9       	sts	0x4a, r19
    a88c:	4b a9       	sts	0x4b, r20
    a88e:	5c a9       	sts	0x4c, r21
    a890:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    a894:	ab 01       	movw	r20, r22
    a896:	bc 01       	movw	r22, r24
    a898:	09 a5       	lds	r16, 0x69
    a89a:	1a a5       	lds	r17, 0x6a
    a89c:	2b a5       	lds	r18, 0x6b
    a89e:	3c a5       	lds	r19, 0x6c
    a8a0:	78 01       	movw	r14, r16
    a8a2:	dd 24       	eor	r13, r13
    a8a4:	cc 24       	eor	r12, r12
    a8a6:	0d a9       	sts	0x4d, r16
    a8a8:	1e a9       	sts	0x4e, r17
    a8aa:	2f a9       	sts	0x4f, r18
    a8ac:	38 ad       	sts	0x68, r19
    a8ae:	c9 01       	movw	r24, r18
    a8b0:	aa 27       	eor	r26, r26
    a8b2:	bb 27       	eor	r27, r27
    a8b4:	c8 2a       	or	r12, r24
    a8b6:	d9 2a       	or	r13, r25
    a8b8:	ea 2a       	or	r14, r26
    a8ba:	fb 2a       	or	r15, r27
    a8bc:	0d a5       	lds	r16, 0x6d
    a8be:	1e a5       	lds	r17, 0x6e
    a8c0:	2f a5       	lds	r18, 0x6f
    a8c2:	38 a9       	sts	0x48, r19
    a8c4:	c4 16       	cp	r12, r20
    a8c6:	d5 06       	cpc	r13, r21
    a8c8:	e6 06       	cpc	r14, r22
    a8ca:	f7 06       	cpc	r15, r23
    a8cc:	38 f5       	brcc	.+78     	; 0xa91c <__divdi3+0x440>
    a8ce:	01 50       	subi	r16, 0x01	; 1
    a8d0:	10 40       	sbci	r17, 0x00	; 0
    a8d2:	20 40       	sbci	r18, 0x00	; 0
    a8d4:	30 40       	sbci	r19, 0x00	; 0
    a8d6:	09 a7       	lds	r16, 0x79
    a8d8:	1a a7       	lds	r17, 0x7a
    a8da:	2b a7       	lds	r18, 0x7b
    a8dc:	3c a7       	lds	r19, 0x7c
    a8de:	c8 0c       	add	r12, r8
    a8e0:	d9 1c       	adc	r13, r9
    a8e2:	ea 1c       	adc	r14, r10
    a8e4:	fb 1c       	adc	r15, r11
    a8e6:	c8 14       	cp	r12, r8
    a8e8:	d9 04       	cpc	r13, r9
    a8ea:	ea 04       	cpc	r14, r10
    a8ec:	fb 04       	cpc	r15, r11
    a8ee:	d0 f0       	brcs	.+52     	; 0xa924 <__divdi3+0x448>
    a8f0:	c4 16       	cp	r12, r20
    a8f2:	d5 06       	cpc	r13, r21
    a8f4:	e6 06       	cpc	r14, r22
    a8f6:	f7 06       	cpc	r15, r23
    a8f8:	a8 f4       	brcc	.+42     	; 0xa924 <__divdi3+0x448>
    a8fa:	0d a5       	lds	r16, 0x6d
    a8fc:	1e a5       	lds	r17, 0x6e
    a8fe:	2f a5       	lds	r18, 0x6f
    a900:	38 a9       	sts	0x48, r19
    a902:	02 50       	subi	r16, 0x02	; 2
    a904:	10 40       	sbci	r17, 0x00	; 0
    a906:	20 40       	sbci	r18, 0x00	; 0
    a908:	30 40       	sbci	r19, 0x00	; 0
    a90a:	09 a7       	lds	r16, 0x79
    a90c:	1a a7       	lds	r17, 0x7a
    a90e:	2b a7       	lds	r18, 0x7b
    a910:	3c a7       	lds	r19, 0x7c
    a912:	c8 0c       	add	r12, r8
    a914:	d9 1c       	adc	r13, r9
    a916:	ea 1c       	adc	r14, r10
    a918:	fb 1c       	adc	r15, r11
    a91a:	04 c0       	rjmp	.+8      	; 0xa924 <__divdi3+0x448>
    a91c:	09 a7       	lds	r16, 0x79
    a91e:	1a a7       	lds	r17, 0x7a
    a920:	2b a7       	lds	r18, 0x7b
    a922:	3c a7       	lds	r19, 0x7c
    a924:	c4 1a       	sub	r12, r20
    a926:	d5 0a       	sbc	r13, r21
    a928:	e6 0a       	sbc	r14, r22
    a92a:	f7 0a       	sbc	r15, r23
    a92c:	c7 01       	movw	r24, r14
    a92e:	b6 01       	movw	r22, r12
    a930:	a3 01       	movw	r20, r6
    a932:	92 01       	movw	r18, r4
    a934:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    a938:	2d a7       	lds	r18, 0x7d
    a93a:	3e a7       	lds	r19, 0x7e
    a93c:	4f a7       	lds	r20, 0x7f
    a93e:	58 ab       	sts	0x58, r21
    a940:	69 af       	sts	0x79, r22
    a942:	7a af       	sts	0x7a, r23
    a944:	8b af       	sts	0x7b, r24
    a946:	9c af       	sts	0x7c, r25
    a948:	c7 01       	movw	r24, r14
    a94a:	b6 01       	movw	r22, r12
    a94c:	a3 01       	movw	r20, r6
    a94e:	92 01       	movw	r18, r4
    a950:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    a954:	ca 01       	movw	r24, r20
    a956:	b9 01       	movw	r22, r18
    a958:	29 a9       	sts	0x49, r18
    a95a:	3a a9       	sts	0x4a, r19
    a95c:	4b a9       	sts	0x4b, r20
    a95e:	5c a9       	sts	0x4c, r21
    a960:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    a964:	6b 01       	movw	r12, r22
    a966:	7c 01       	movw	r14, r24
    a968:	49 ad       	sts	0x69, r20
    a96a:	5a ad       	sts	0x6a, r21
    a96c:	6b ad       	sts	0x6b, r22
    a96e:	7c ad       	sts	0x6c, r23
    a970:	9a 01       	movw	r18, r20
    a972:	11 27       	eor	r17, r17
    a974:	00 27       	eor	r16, r16
    a976:	4d a9       	sts	0x4d, r20
    a978:	5e a9       	sts	0x4e, r21
    a97a:	6f a9       	sts	0x4f, r22
    a97c:	78 ad       	sts	0x68, r23
    a97e:	60 70       	andi	r22, 0x00	; 0
    a980:	70 70       	andi	r23, 0x00	; 0
    a982:	04 2b       	or	r16, r20
    a984:	15 2b       	or	r17, r21
    a986:	26 2b       	or	r18, r22
    a988:	37 2b       	or	r19, r23
    a98a:	8d a5       	lds	r24, 0x6d
    a98c:	9e a5       	lds	r25, 0x6e
    a98e:	af a5       	lds	r26, 0x6f
    a990:	b8 a9       	sts	0x48, r27
    a992:	0c 15       	cp	r16, r12
    a994:	1d 05       	cpc	r17, r13
    a996:	2e 05       	cpc	r18, r14
    a998:	3f 05       	cpc	r19, r15
    a99a:	c0 f4       	brcc	.+48     	; 0xa9cc <__divdi3+0x4f0>
    a99c:	01 97       	sbiw	r24, 0x01	; 1
    a99e:	a1 09       	sbc	r26, r1
    a9a0:	b1 09       	sbc	r27, r1
    a9a2:	08 0d       	add	r16, r8
    a9a4:	19 1d       	adc	r17, r9
    a9a6:	2a 1d       	adc	r18, r10
    a9a8:	3b 1d       	adc	r19, r11
    a9aa:	08 15       	cp	r16, r8
    a9ac:	19 05       	cpc	r17, r9
    a9ae:	2a 05       	cpc	r18, r10
    a9b0:	3b 05       	cpc	r19, r11
    a9b2:	60 f0       	brcs	.+24     	; 0xa9cc <__divdi3+0x4f0>
    a9b4:	0c 15       	cp	r16, r12
    a9b6:	1d 05       	cpc	r17, r13
    a9b8:	2e 05       	cpc	r18, r14
    a9ba:	3f 05       	cpc	r19, r15
    a9bc:	38 f4       	brcc	.+14     	; 0xa9cc <__divdi3+0x4f0>
    a9be:	8d a5       	lds	r24, 0x6d
    a9c0:	9e a5       	lds	r25, 0x6e
    a9c2:	af a5       	lds	r26, 0x6f
    a9c4:	b8 a9       	sts	0x48, r27
    a9c6:	02 97       	sbiw	r24, 0x02	; 2
    a9c8:	a1 09       	sbc	r26, r1
    a9ca:	b1 09       	sbc	r27, r1
    a9cc:	09 a5       	lds	r16, 0x69
    a9ce:	1a a5       	lds	r17, 0x6a
    a9d0:	2b a5       	lds	r18, 0x6b
    a9d2:	3c a5       	lds	r19, 0x6c
    a9d4:	78 01       	movw	r14, r16
    a9d6:	dd 24       	eor	r13, r13
    a9d8:	cc 24       	eor	r12, r12
    a9da:	c8 2a       	or	r12, r24
    a9dc:	d9 2a       	or	r13, r25
    a9de:	ea 2a       	or	r14, r26
    a9e0:	fb 2a       	or	r15, r27
    a9e2:	b7 c4       	rjmp	.+2414   	; 0xb352 <__divdi3+0xe76>
    a9e4:	81 14       	cp	r8, r1
    a9e6:	91 04       	cpc	r9, r1
    a9e8:	a1 04       	cpc	r10, r1
    a9ea:	b1 04       	cpc	r11, r1
    a9ec:	51 f4       	brne	.+20     	; 0xaa02 <__divdi3+0x526>
    a9ee:	61 e0       	ldi	r22, 0x01	; 1
    a9f0:	70 e0       	ldi	r23, 0x00	; 0
    a9f2:	80 e0       	ldi	r24, 0x00	; 0
    a9f4:	90 e0       	ldi	r25, 0x00	; 0
    a9f6:	a5 01       	movw	r20, r10
    a9f8:	94 01       	movw	r18, r8
    a9fa:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    a9fe:	49 01       	movw	r8, r18
    aa00:	5a 01       	movw	r10, r20
    aa02:	10 e0       	ldi	r17, 0x00	; 0
    aa04:	81 16       	cp	r8, r17
    aa06:	10 e0       	ldi	r17, 0x00	; 0
    aa08:	91 06       	cpc	r9, r17
    aa0a:	11 e0       	ldi	r17, 0x01	; 1
    aa0c:	a1 06       	cpc	r10, r17
    aa0e:	10 e0       	ldi	r17, 0x00	; 0
    aa10:	b1 06       	cpc	r11, r17
    aa12:	58 f4       	brcc	.+22     	; 0xaa2a <__divdi3+0x54e>
    aa14:	2f ef       	ldi	r18, 0xFF	; 255
    aa16:	82 16       	cp	r8, r18
    aa18:	91 04       	cpc	r9, r1
    aa1a:	a1 04       	cpc	r10, r1
    aa1c:	b1 04       	cpc	r11, r1
    aa1e:	09 f0       	breq	.+2      	; 0xaa22 <__divdi3+0x546>
    aa20:	90 f4       	brcc	.+36     	; 0xaa46 <__divdi3+0x56a>
    aa22:	80 e0       	ldi	r24, 0x00	; 0
    aa24:	90 e0       	ldi	r25, 0x00	; 0
    aa26:	dc 01       	movw	r26, r24
    aa28:	17 c0       	rjmp	.+46     	; 0xaa58 <__divdi3+0x57c>
    aa2a:	30 e0       	ldi	r19, 0x00	; 0
    aa2c:	83 16       	cp	r8, r19
    aa2e:	30 e0       	ldi	r19, 0x00	; 0
    aa30:	93 06       	cpc	r9, r19
    aa32:	30 e0       	ldi	r19, 0x00	; 0
    aa34:	a3 06       	cpc	r10, r19
    aa36:	31 e0       	ldi	r19, 0x01	; 1
    aa38:	b3 06       	cpc	r11, r19
    aa3a:	50 f4       	brcc	.+20     	; 0xaa50 <__divdi3+0x574>
    aa3c:	80 e1       	ldi	r24, 0x10	; 16
    aa3e:	90 e0       	ldi	r25, 0x00	; 0
    aa40:	a0 e0       	ldi	r26, 0x00	; 0
    aa42:	b0 e0       	ldi	r27, 0x00	; 0
    aa44:	09 c0       	rjmp	.+18     	; 0xaa58 <__divdi3+0x57c>
    aa46:	88 e0       	ldi	r24, 0x08	; 8
    aa48:	90 e0       	ldi	r25, 0x00	; 0
    aa4a:	a0 e0       	ldi	r26, 0x00	; 0
    aa4c:	b0 e0       	ldi	r27, 0x00	; 0
    aa4e:	04 c0       	rjmp	.+8      	; 0xaa58 <__divdi3+0x57c>
    aa50:	88 e1       	ldi	r24, 0x18	; 24
    aa52:	90 e0       	ldi	r25, 0x00	; 0
    aa54:	a0 e0       	ldi	r26, 0x00	; 0
    aa56:	b0 e0       	ldi	r27, 0x00	; 0
    aa58:	b5 01       	movw	r22, r10
    aa5a:	a4 01       	movw	r20, r8
    aa5c:	08 2e       	mov	r0, r24
    aa5e:	04 c0       	rjmp	.+8      	; 0xaa68 <__divdi3+0x58c>
    aa60:	76 95       	lsr	r23
    aa62:	67 95       	ror	r22
    aa64:	57 95       	ror	r21
    aa66:	47 95       	ror	r20
    aa68:	0a 94       	dec	r0
    aa6a:	d2 f7       	brpl	.-12     	; 0xaa60 <__divdi3+0x584>
    aa6c:	fa 01       	movw	r30, r20
    aa6e:	e6 5d       	subi	r30, 0xD6	; 214
    aa70:	ff 4d       	sbci	r31, 0xDF	; 223
    aa72:	20 81       	ld	r18, Z
    aa74:	ac 01       	movw	r20, r24
    aa76:	bd 01       	movw	r22, r26
    aa78:	42 0f       	add	r20, r18
    aa7a:	51 1d       	adc	r21, r1
    aa7c:	61 1d       	adc	r22, r1
    aa7e:	71 1d       	adc	r23, r1
    aa80:	80 e2       	ldi	r24, 0x20	; 32
    aa82:	90 e0       	ldi	r25, 0x00	; 0
    aa84:	a0 e0       	ldi	r26, 0x00	; 0
    aa86:	b0 e0       	ldi	r27, 0x00	; 0
    aa88:	84 1b       	sub	r24, r20
    aa8a:	95 0b       	sbc	r25, r21
    aa8c:	a6 0b       	sbc	r26, r22
    aa8e:	b7 0b       	sbc	r27, r23
    aa90:	51 f4       	brne	.+20     	; 0xaaa6 <__divdi3+0x5ca>
    aa92:	c8 18       	sub	r12, r8
    aa94:	d9 08       	sbc	r13, r9
    aa96:	ea 08       	sbc	r14, r10
    aa98:	fb 08       	sbc	r15, r11
    aa9a:	f1 e0       	ldi	r31, 0x01	; 1
    aa9c:	4f 2e       	mov	r4, r31
    aa9e:	51 2c       	mov	r5, r1
    aaa0:	61 2c       	mov	r6, r1
    aaa2:	71 2c       	mov	r7, r1
    aaa4:	28 c1       	rjmp	.+592    	; 0xacf6 <__divdi3+0x81a>
    aaa6:	08 2e       	mov	r0, r24
    aaa8:	04 c0       	rjmp	.+8      	; 0xaab2 <__divdi3+0x5d6>
    aaaa:	88 0c       	add	r8, r8
    aaac:	99 1c       	adc	r9, r9
    aaae:	aa 1c       	adc	r10, r10
    aab0:	bb 1c       	adc	r11, r11
    aab2:	0a 94       	dec	r0
    aab4:	d2 f7       	brpl	.-12     	; 0xaaaa <__divdi3+0x5ce>
    aab6:	97 01       	movw	r18, r14
    aab8:	86 01       	movw	r16, r12
    aaba:	04 2e       	mov	r0, r20
    aabc:	04 c0       	rjmp	.+8      	; 0xaac6 <__divdi3+0x5ea>
    aabe:	36 95       	lsr	r19
    aac0:	27 95       	ror	r18
    aac2:	17 95       	ror	r17
    aac4:	07 95       	ror	r16
    aac6:	0a 94       	dec	r0
    aac8:	d2 f7       	brpl	.-12     	; 0xaabe <__divdi3+0x5e2>
    aaca:	09 ab       	sts	0x59, r16
    aacc:	1a ab       	sts	0x5a, r17
    aace:	2b ab       	sts	0x5b, r18
    aad0:	3c ab       	sts	0x5c, r19
    aad2:	97 01       	movw	r18, r14
    aad4:	86 01       	movw	r16, r12
    aad6:	08 2e       	mov	r0, r24
    aad8:	04 c0       	rjmp	.+8      	; 0xaae2 <__divdi3+0x606>
    aada:	00 0f       	add	r16, r16
    aadc:	11 1f       	adc	r17, r17
    aade:	22 1f       	adc	r18, r18
    aae0:	33 1f       	adc	r19, r19
    aae2:	0a 94       	dec	r0
    aae4:	d2 f7       	brpl	.-12     	; 0xaada <__divdi3+0x5fe>
    aae6:	0d a7       	lds	r16, 0x7d
    aae8:	1e a7       	lds	r17, 0x7e
    aaea:	2f a7       	lds	r18, 0x7f
    aaec:	38 ab       	sts	0x58, r19
    aaee:	ed a8       	sts	0x8d, r30
    aaf0:	fe a8       	sts	0x8e, r31
    aaf2:	0f a9       	sts	0x4f, r16
    aaf4:	18 ad       	sts	0x68, r17
    aaf6:	04 c0       	rjmp	.+8      	; 0xab00 <__divdi3+0x624>
    aaf8:	16 95       	lsr	r17
    aafa:	07 95       	ror	r16
    aafc:	f7 94       	ror	r15
    aafe:	e7 94       	ror	r14
    ab00:	4a 95       	dec	r20
    ab02:	d2 f7       	brpl	.-12     	; 0xaaf8 <__divdi3+0x61c>
    ab04:	b8 01       	movw	r22, r16
    ab06:	a7 01       	movw	r20, r14
    ab08:	0d a5       	lds	r16, 0x6d
    ab0a:	1e a5       	lds	r17, 0x6e
    ab0c:	2f a5       	lds	r18, 0x6f
    ab0e:	38 a9       	sts	0x48, r19
    ab10:	04 2b       	or	r16, r20
    ab12:	15 2b       	or	r17, r21
    ab14:	26 2b       	or	r18, r22
    ab16:	37 2b       	or	r19, r23
    ab18:	0d a7       	lds	r16, 0x7d
    ab1a:	1e a7       	lds	r17, 0x7e
    ab1c:	2f a7       	lds	r18, 0x7f
    ab1e:	38 ab       	sts	0x58, r19
    ab20:	ed a8       	sts	0x8d, r30
    ab22:	fe a8       	sts	0x8e, r31
    ab24:	0f a9       	sts	0x4f, r16
    ab26:	18 ad       	sts	0x68, r17
    ab28:	04 c0       	rjmp	.+8      	; 0xab32 <__divdi3+0x656>
    ab2a:	ee 0c       	add	r14, r14
    ab2c:	ff 1c       	adc	r15, r15
    ab2e:	00 1f       	adc	r16, r16
    ab30:	11 1f       	adc	r17, r17
    ab32:	8a 95       	dec	r24
    ab34:	d2 f7       	brpl	.-12     	; 0xab2a <__divdi3+0x64e>
    ab36:	ed aa       	sts	0x9d, r30
    ab38:	fe aa       	sts	0x9e, r31
    ab3a:	0f ab       	sts	0x5f, r16
    ab3c:	18 af       	sts	0x78, r17
    ab3e:	25 01       	movw	r4, r10
    ab40:	66 24       	eor	r6, r6
    ab42:	77 24       	eor	r7, r7
    ab44:	95 01       	movw	r18, r10
    ab46:	84 01       	movw	r16, r8
    ab48:	20 70       	andi	r18, 0x00	; 0
    ab4a:	30 70       	andi	r19, 0x00	; 0
    ab4c:	09 af       	sts	0x79, r16
    ab4e:	1a af       	sts	0x7a, r17
    ab50:	2b af       	sts	0x7b, r18
    ab52:	3c af       	sts	0x7c, r19
    ab54:	69 a9       	sts	0x49, r22
    ab56:	7a a9       	sts	0x4a, r23
    ab58:	8b a9       	sts	0x4b, r24
    ab5a:	9c a9       	sts	0x4c, r25
    ab5c:	a3 01       	movw	r20, r6
    ab5e:	92 01       	movw	r18, r4
    ab60:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    ab64:	29 a7       	lds	r18, 0x79
    ab66:	3a a7       	lds	r19, 0x7a
    ab68:	4b a7       	lds	r20, 0x7b
    ab6a:	5c a7       	lds	r21, 0x7c
    ab6c:	6b 01       	movw	r12, r22
    ab6e:	7c 01       	movw	r14, r24
    ab70:	69 a9       	sts	0x49, r22
    ab72:	7a a9       	sts	0x4a, r23
    ab74:	8b a9       	sts	0x4b, r24
    ab76:	9c a9       	sts	0x4c, r25
    ab78:	a3 01       	movw	r20, r6
    ab7a:	92 01       	movw	r18, r4
    ab7c:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    ab80:	ca 01       	movw	r24, r20
    ab82:	b9 01       	movw	r22, r18
    ab84:	29 ad       	sts	0x69, r18
    ab86:	3a ad       	sts	0x6a, r19
    ab88:	4b ad       	sts	0x6b, r20
    ab8a:	5c ad       	sts	0x6c, r21
    ab8c:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    ab90:	ab 01       	movw	r20, r22
    ab92:	bc 01       	movw	r22, r24
    ab94:	76 01       	movw	r14, r12
    ab96:	dd 24       	eor	r13, r13
    ab98:	cc 24       	eor	r12, r12
    ab9a:	0d a5       	lds	r16, 0x6d
    ab9c:	1e a5       	lds	r17, 0x6e
    ab9e:	2f a5       	lds	r18, 0x6f
    aba0:	38 a9       	sts	0x48, r19
    aba2:	c9 01       	movw	r24, r18
    aba4:	aa 27       	eor	r26, r26
    aba6:	bb 27       	eor	r27, r27
    aba8:	c8 2a       	or	r12, r24
    abaa:	d9 2a       	or	r13, r25
    abac:	ea 2a       	or	r14, r26
    abae:	fb 2a       	or	r15, r27
    abb0:	09 a5       	lds	r16, 0x69
    abb2:	1a a5       	lds	r17, 0x6a
    abb4:	2b a5       	lds	r18, 0x6b
    abb6:	3c a5       	lds	r19, 0x6c
    abb8:	c4 16       	cp	r12, r20
    abba:	d5 06       	cpc	r13, r21
    abbc:	e6 06       	cpc	r14, r22
    abbe:	f7 06       	cpc	r15, r23
    abc0:	38 f5       	brcc	.+78     	; 0xac10 <__divdi3+0x734>
    abc2:	01 50       	subi	r16, 0x01	; 1
    abc4:	10 40       	sbci	r17, 0x00	; 0
    abc6:	20 40       	sbci	r18, 0x00	; 0
    abc8:	30 40       	sbci	r19, 0x00	; 0
    abca:	09 ab       	sts	0x59, r16
    abcc:	1a ab       	sts	0x5a, r17
    abce:	2b ab       	sts	0x5b, r18
    abd0:	3c ab       	sts	0x5c, r19
    abd2:	c8 0c       	add	r12, r8
    abd4:	d9 1c       	adc	r13, r9
    abd6:	ea 1c       	adc	r14, r10
    abd8:	fb 1c       	adc	r15, r11
    abda:	c8 14       	cp	r12, r8
    abdc:	d9 04       	cpc	r13, r9
    abde:	ea 04       	cpc	r14, r10
    abe0:	fb 04       	cpc	r15, r11
    abe2:	d0 f0       	brcs	.+52     	; 0xac18 <__divdi3+0x73c>
    abe4:	c4 16       	cp	r12, r20
    abe6:	d5 06       	cpc	r13, r21
    abe8:	e6 06       	cpc	r14, r22
    abea:	f7 06       	cpc	r15, r23
    abec:	a8 f4       	brcc	.+42     	; 0xac18 <__divdi3+0x73c>
    abee:	09 a5       	lds	r16, 0x69
    abf0:	1a a5       	lds	r17, 0x6a
    abf2:	2b a5       	lds	r18, 0x6b
    abf4:	3c a5       	lds	r19, 0x6c
    abf6:	02 50       	subi	r16, 0x02	; 2
    abf8:	10 40       	sbci	r17, 0x00	; 0
    abfa:	20 40       	sbci	r18, 0x00	; 0
    abfc:	30 40       	sbci	r19, 0x00	; 0
    abfe:	09 ab       	sts	0x59, r16
    ac00:	1a ab       	sts	0x5a, r17
    ac02:	2b ab       	sts	0x5b, r18
    ac04:	3c ab       	sts	0x5c, r19
    ac06:	c8 0c       	add	r12, r8
    ac08:	d9 1c       	adc	r13, r9
    ac0a:	ea 1c       	adc	r14, r10
    ac0c:	fb 1c       	adc	r15, r11
    ac0e:	04 c0       	rjmp	.+8      	; 0xac18 <__divdi3+0x73c>
    ac10:	09 ab       	sts	0x59, r16
    ac12:	1a ab       	sts	0x5a, r17
    ac14:	2b ab       	sts	0x5b, r18
    ac16:	3c ab       	sts	0x5c, r19
    ac18:	c4 1a       	sub	r12, r20
    ac1a:	d5 0a       	sbc	r13, r21
    ac1c:	e6 0a       	sbc	r14, r22
    ac1e:	f7 0a       	sbc	r15, r23
    ac20:	c7 01       	movw	r24, r14
    ac22:	b6 01       	movw	r22, r12
    ac24:	a3 01       	movw	r20, r6
    ac26:	92 01       	movw	r18, r4
    ac28:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    ac2c:	29 a7       	lds	r18, 0x79
    ac2e:	3a a7       	lds	r19, 0x7a
    ac30:	4b a7       	lds	r20, 0x7b
    ac32:	5c a7       	lds	r21, 0x7c
    ac34:	21 96       	adiw	r28, 0x01	; 1
    ac36:	6c af       	sts	0x7c, r22
    ac38:	7d af       	sts	0x7d, r23
    ac3a:	8e af       	sts	0x7e, r24
    ac3c:	9f af       	sts	0x7f, r25
    ac3e:	21 97       	sbiw	r28, 0x01	; 1
    ac40:	c7 01       	movw	r24, r14
    ac42:	b6 01       	movw	r22, r12
    ac44:	a3 01       	movw	r20, r6
    ac46:	92 01       	movw	r18, r4
    ac48:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    ac4c:	ca 01       	movw	r24, r20
    ac4e:	b9 01       	movw	r22, r18
    ac50:	29 ad       	sts	0x69, r18
    ac52:	3a ad       	sts	0x6a, r19
    ac54:	4b ad       	sts	0x6b, r20
    ac56:	5c ad       	sts	0x6c, r21
    ac58:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    ac5c:	8b 01       	movw	r16, r22
    ac5e:	9c 01       	movw	r18, r24
    ac60:	21 96       	adiw	r28, 0x01	; 1
    ac62:	4c ad       	sts	0x6c, r20
    ac64:	5d ad       	sts	0x6d, r21
    ac66:	6e ad       	sts	0x6e, r22
    ac68:	7f ad       	sts	0x6f, r23
    ac6a:	21 97       	sbiw	r28, 0x01	; 1
    ac6c:	da 01       	movw	r26, r20
    ac6e:	99 27       	eor	r25, r25
    ac70:	88 27       	eor	r24, r24
    ac72:	4d a5       	lds	r20, 0x6d
    ac74:	5e a5       	lds	r21, 0x6e
    ac76:	6f a5       	lds	r22, 0x6f
    ac78:	78 a9       	sts	0x48, r23
    ac7a:	60 70       	andi	r22, 0x00	; 0
    ac7c:	70 70       	andi	r23, 0x00	; 0
    ac7e:	84 2b       	or	r24, r20
    ac80:	95 2b       	or	r25, r21
    ac82:	a6 2b       	or	r26, r22
    ac84:	b7 2b       	or	r27, r23
    ac86:	49 a5       	lds	r20, 0x69
    ac88:	5a a5       	lds	r21, 0x6a
    ac8a:	6b a5       	lds	r22, 0x6b
    ac8c:	7c a5       	lds	r23, 0x6c
    ac8e:	80 17       	cp	r24, r16
    ac90:	91 07       	cpc	r25, r17
    ac92:	a2 07       	cpc	r26, r18
    ac94:	b3 07       	cpc	r27, r19
    ac96:	f0 f4       	brcc	.+60     	; 0xacd4 <__divdi3+0x7f8>
    ac98:	41 50       	subi	r20, 0x01	; 1
    ac9a:	50 40       	sbci	r21, 0x00	; 0
    ac9c:	60 40       	sbci	r22, 0x00	; 0
    ac9e:	70 40       	sbci	r23, 0x00	; 0
    aca0:	88 0d       	add	r24, r8
    aca2:	99 1d       	adc	r25, r9
    aca4:	aa 1d       	adc	r26, r10
    aca6:	bb 1d       	adc	r27, r11
    aca8:	88 15       	cp	r24, r8
    acaa:	99 05       	cpc	r25, r9
    acac:	aa 05       	cpc	r26, r10
    acae:	bb 05       	cpc	r27, r11
    acb0:	88 f0       	brcs	.+34     	; 0xacd4 <__divdi3+0x7f8>
    acb2:	80 17       	cp	r24, r16
    acb4:	91 07       	cpc	r25, r17
    acb6:	a2 07       	cpc	r26, r18
    acb8:	b3 07       	cpc	r27, r19
    acba:	60 f4       	brcc	.+24     	; 0xacd4 <__divdi3+0x7f8>
    acbc:	49 a5       	lds	r20, 0x69
    acbe:	5a a5       	lds	r21, 0x6a
    acc0:	6b a5       	lds	r22, 0x6b
    acc2:	7c a5       	lds	r23, 0x6c
    acc4:	42 50       	subi	r20, 0x02	; 2
    acc6:	50 40       	sbci	r21, 0x00	; 0
    acc8:	60 40       	sbci	r22, 0x00	; 0
    acca:	70 40       	sbci	r23, 0x00	; 0
    accc:	88 0d       	add	r24, r8
    acce:	99 1d       	adc	r25, r9
    acd0:	aa 1d       	adc	r26, r10
    acd2:	bb 1d       	adc	r27, r11
    acd4:	6c 01       	movw	r12, r24
    acd6:	7d 01       	movw	r14, r26
    acd8:	c0 1a       	sub	r12, r16
    acda:	d1 0a       	sbc	r13, r17
    acdc:	e2 0a       	sbc	r14, r18
    acde:	f3 0a       	sbc	r15, r19
    ace0:	09 a9       	sts	0x49, r16
    ace2:	1a a9       	sts	0x4a, r17
    ace4:	2b a9       	sts	0x4b, r18
    ace6:	3c a9       	sts	0x4c, r19
    ace8:	38 01       	movw	r6, r16
    acea:	55 24       	eor	r5, r5
    acec:	44 24       	eor	r4, r4
    acee:	44 2a       	or	r4, r20
    acf0:	55 2a       	or	r5, r21
    acf2:	66 2a       	or	r6, r22
    acf4:	77 2a       	or	r7, r23
    acf6:	85 01       	movw	r16, r10
    acf8:	22 27       	eor	r18, r18
    acfa:	33 27       	eor	r19, r19
    acfc:	0d a7       	lds	r16, 0x7d
    acfe:	1e a7       	lds	r17, 0x7e
    ad00:	2f a7       	lds	r18, 0x7f
    ad02:	38 ab       	sts	0x58, r19
    ad04:	95 01       	movw	r18, r10
    ad06:	84 01       	movw	r16, r8
    ad08:	20 70       	andi	r18, 0x00	; 0
    ad0a:	30 70       	andi	r19, 0x00	; 0
    ad0c:	09 af       	sts	0x79, r16
    ad0e:	1a af       	sts	0x7a, r17
    ad10:	2b af       	sts	0x7b, r18
    ad12:	3c af       	sts	0x7c, r19
    ad14:	c7 01       	movw	r24, r14
    ad16:	b6 01       	movw	r22, r12
    ad18:	2d a5       	lds	r18, 0x6d
    ad1a:	3e a5       	lds	r19, 0x6e
    ad1c:	4f a5       	lds	r20, 0x6f
    ad1e:	58 a9       	sts	0x48, r21
    ad20:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    ad24:	29 a7       	lds	r18, 0x79
    ad26:	3a a7       	lds	r19, 0x7a
    ad28:	4b a7       	lds	r20, 0x7b
    ad2a:	5c a7       	lds	r21, 0x7c
    ad2c:	69 ab       	sts	0x59, r22
    ad2e:	7a ab       	sts	0x5a, r23
    ad30:	8b ab       	sts	0x5b, r24
    ad32:	9c ab       	sts	0x5c, r25
    ad34:	c7 01       	movw	r24, r14
    ad36:	b6 01       	movw	r22, r12
    ad38:	2d a5       	lds	r18, 0x6d
    ad3a:	3e a5       	lds	r19, 0x6e
    ad3c:	4f a5       	lds	r20, 0x6f
    ad3e:	58 a9       	sts	0x48, r21
    ad40:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    ad44:	ca 01       	movw	r24, r20
    ad46:	b9 01       	movw	r22, r18
    ad48:	29 ad       	sts	0x69, r18
    ad4a:	3a ad       	sts	0x6a, r19
    ad4c:	4b ad       	sts	0x6b, r20
    ad4e:	5c ad       	sts	0x6c, r21
    ad50:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    ad54:	ab 01       	movw	r20, r22
    ad56:	bc 01       	movw	r22, r24
    ad58:	09 a9       	sts	0x49, r16
    ad5a:	1a a9       	sts	0x4a, r17
    ad5c:	2b a9       	sts	0x4b, r18
    ad5e:	3c a9       	sts	0x4c, r19
    ad60:	78 01       	movw	r14, r16
    ad62:	dd 24       	eor	r13, r13
    ad64:	cc 24       	eor	r12, r12
    ad66:	0d a9       	sts	0x4d, r16
    ad68:	1e a9       	sts	0x4e, r17
    ad6a:	2f a9       	sts	0x4f, r18
    ad6c:	38 ad       	sts	0x68, r19
    ad6e:	c9 01       	movw	r24, r18
    ad70:	aa 27       	eor	r26, r26
    ad72:	bb 27       	eor	r27, r27
    ad74:	c8 2a       	or	r12, r24
    ad76:	d9 2a       	or	r13, r25
    ad78:	ea 2a       	or	r14, r26
    ad7a:	fb 2a       	or	r15, r27
    ad7c:	09 a5       	lds	r16, 0x69
    ad7e:	1a a5       	lds	r17, 0x6a
    ad80:	2b a5       	lds	r18, 0x6b
    ad82:	3c a5       	lds	r19, 0x6c
    ad84:	c4 16       	cp	r12, r20
    ad86:	d5 06       	cpc	r13, r21
    ad88:	e6 06       	cpc	r14, r22
    ad8a:	f7 06       	cpc	r15, r23
    ad8c:	38 f5       	brcc	.+78     	; 0xaddc <__divdi3+0x900>
    ad8e:	01 50       	subi	r16, 0x01	; 1
    ad90:	10 40       	sbci	r17, 0x00	; 0
    ad92:	20 40       	sbci	r18, 0x00	; 0
    ad94:	30 40       	sbci	r19, 0x00	; 0
    ad96:	09 ab       	sts	0x59, r16
    ad98:	1a ab       	sts	0x5a, r17
    ad9a:	2b ab       	sts	0x5b, r18
    ad9c:	3c ab       	sts	0x5c, r19
    ad9e:	c8 0c       	add	r12, r8
    ada0:	d9 1c       	adc	r13, r9
    ada2:	ea 1c       	adc	r14, r10
    ada4:	fb 1c       	adc	r15, r11
    ada6:	c8 14       	cp	r12, r8
    ada8:	d9 04       	cpc	r13, r9
    adaa:	ea 04       	cpc	r14, r10
    adac:	fb 04       	cpc	r15, r11
    adae:	d0 f0       	brcs	.+52     	; 0xade4 <__divdi3+0x908>
    adb0:	c4 16       	cp	r12, r20
    adb2:	d5 06       	cpc	r13, r21
    adb4:	e6 06       	cpc	r14, r22
    adb6:	f7 06       	cpc	r15, r23
    adb8:	a8 f4       	brcc	.+42     	; 0xade4 <__divdi3+0x908>
    adba:	09 a5       	lds	r16, 0x69
    adbc:	1a a5       	lds	r17, 0x6a
    adbe:	2b a5       	lds	r18, 0x6b
    adc0:	3c a5       	lds	r19, 0x6c
    adc2:	02 50       	subi	r16, 0x02	; 2
    adc4:	10 40       	sbci	r17, 0x00	; 0
    adc6:	20 40       	sbci	r18, 0x00	; 0
    adc8:	30 40       	sbci	r19, 0x00	; 0
    adca:	09 ab       	sts	0x59, r16
    adcc:	1a ab       	sts	0x5a, r17
    adce:	2b ab       	sts	0x5b, r18
    add0:	3c ab       	sts	0x5c, r19
    add2:	c8 0c       	add	r12, r8
    add4:	d9 1c       	adc	r13, r9
    add6:	ea 1c       	adc	r14, r10
    add8:	fb 1c       	adc	r15, r11
    adda:	04 c0       	rjmp	.+8      	; 0xade4 <__divdi3+0x908>
    addc:	09 ab       	sts	0x59, r16
    adde:	1a ab       	sts	0x5a, r17
    ade0:	2b ab       	sts	0x5b, r18
    ade2:	3c ab       	sts	0x5c, r19
    ade4:	c4 1a       	sub	r12, r20
    ade6:	d5 0a       	sbc	r13, r21
    ade8:	e6 0a       	sbc	r14, r22
    adea:	f7 0a       	sbc	r15, r23
    adec:	c7 01       	movw	r24, r14
    adee:	b6 01       	movw	r22, r12
    adf0:	2d a5       	lds	r18, 0x6d
    adf2:	3e a5       	lds	r19, 0x6e
    adf4:	4f a5       	lds	r20, 0x6f
    adf6:	58 a9       	sts	0x48, r21
    adf8:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    adfc:	29 a7       	lds	r18, 0x79
    adfe:	3a a7       	lds	r19, 0x7a
    ae00:	4b a7       	lds	r20, 0x7b
    ae02:	5c a7       	lds	r21, 0x7c
    ae04:	21 96       	adiw	r28, 0x01	; 1
    ae06:	6c af       	sts	0x7c, r22
    ae08:	7d af       	sts	0x7d, r23
    ae0a:	8e af       	sts	0x7e, r24
    ae0c:	9f af       	sts	0x7f, r25
    ae0e:	21 97       	sbiw	r28, 0x01	; 1
    ae10:	c7 01       	movw	r24, r14
    ae12:	b6 01       	movw	r22, r12
    ae14:	2d a5       	lds	r18, 0x6d
    ae16:	3e a5       	lds	r19, 0x6e
    ae18:	4f a5       	lds	r20, 0x6f
    ae1a:	58 a9       	sts	0x48, r21
    ae1c:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    ae20:	ca 01       	movw	r24, r20
    ae22:	b9 01       	movw	r22, r18
    ae24:	29 ad       	sts	0x69, r18
    ae26:	3a ad       	sts	0x6a, r19
    ae28:	4b ad       	sts	0x6b, r20
    ae2a:	5c ad       	sts	0x6c, r21
    ae2c:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    ae30:	8b 01       	movw	r16, r22
    ae32:	9c 01       	movw	r18, r24
    ae34:	21 96       	adiw	r28, 0x01	; 1
    ae36:	4c ad       	sts	0x6c, r20
    ae38:	5d ad       	sts	0x6d, r21
    ae3a:	6e ad       	sts	0x6e, r22
    ae3c:	7f ad       	sts	0x6f, r23
    ae3e:	21 97       	sbiw	r28, 0x01	; 1
    ae40:	da 01       	movw	r26, r20
    ae42:	99 27       	eor	r25, r25
    ae44:	88 27       	eor	r24, r24
    ae46:	4d a9       	sts	0x4d, r20
    ae48:	5e a9       	sts	0x4e, r21
    ae4a:	6f a9       	sts	0x4f, r22
    ae4c:	78 ad       	sts	0x68, r23
    ae4e:	60 70       	andi	r22, 0x00	; 0
    ae50:	70 70       	andi	r23, 0x00	; 0
    ae52:	84 2b       	or	r24, r20
    ae54:	95 2b       	or	r25, r21
    ae56:	a6 2b       	or	r26, r22
    ae58:	b7 2b       	or	r27, r23
    ae5a:	49 a5       	lds	r20, 0x69
    ae5c:	5a a5       	lds	r21, 0x6a
    ae5e:	6b a5       	lds	r22, 0x6b
    ae60:	7c a5       	lds	r23, 0x6c
    ae62:	80 17       	cp	r24, r16
    ae64:	91 07       	cpc	r25, r17
    ae66:	a2 07       	cpc	r26, r18
    ae68:	b3 07       	cpc	r27, r19
    ae6a:	d0 f4       	brcc	.+52     	; 0xaea0 <__divdi3+0x9c4>
    ae6c:	41 50       	subi	r20, 0x01	; 1
    ae6e:	50 40       	sbci	r21, 0x00	; 0
    ae70:	60 40       	sbci	r22, 0x00	; 0
    ae72:	70 40       	sbci	r23, 0x00	; 0
    ae74:	88 0d       	add	r24, r8
    ae76:	99 1d       	adc	r25, r9
    ae78:	aa 1d       	adc	r26, r10
    ae7a:	bb 1d       	adc	r27, r11
    ae7c:	88 15       	cp	r24, r8
    ae7e:	99 05       	cpc	r25, r9
    ae80:	aa 05       	cpc	r26, r10
    ae82:	bb 05       	cpc	r27, r11
    ae84:	68 f0       	brcs	.+26     	; 0xaea0 <__divdi3+0x9c4>
    ae86:	80 17       	cp	r24, r16
    ae88:	91 07       	cpc	r25, r17
    ae8a:	a2 07       	cpc	r26, r18
    ae8c:	b3 07       	cpc	r27, r19
    ae8e:	40 f4       	brcc	.+16     	; 0xaea0 <__divdi3+0x9c4>
    ae90:	49 a5       	lds	r20, 0x69
    ae92:	5a a5       	lds	r21, 0x6a
    ae94:	6b a5       	lds	r22, 0x6b
    ae96:	7c a5       	lds	r23, 0x6c
    ae98:	42 50       	subi	r20, 0x02	; 2
    ae9a:	50 40       	sbci	r21, 0x00	; 0
    ae9c:	60 40       	sbci	r22, 0x00	; 0
    ae9e:	70 40       	sbci	r23, 0x00	; 0
    aea0:	09 a9       	sts	0x49, r16
    aea2:	1a a9       	sts	0x4a, r17
    aea4:	2b a9       	sts	0x4b, r18
    aea6:	3c a9       	sts	0x4c, r19
    aea8:	78 01       	movw	r14, r16
    aeaa:	dd 24       	eor	r13, r13
    aeac:	cc 24       	eor	r12, r12
    aeae:	c4 2a       	or	r12, r20
    aeb0:	d5 2a       	or	r13, r21
    aeb2:	e6 2a       	or	r14, r22
    aeb4:	f7 2a       	or	r15, r23
    aeb6:	50 c2       	rjmp	.+1184   	; 0xb358 <__divdi3+0xe7c>
    aeb8:	c8 16       	cp	r12, r24
    aeba:	d9 06       	cpc	r13, r25
    aebc:	ea 06       	cpc	r14, r26
    aebe:	fb 06       	cpc	r15, r27
    aec0:	08 f4       	brcc	.+2      	; 0xaec4 <__divdi3+0x9e8>
    aec2:	37 c2       	rjmp	.+1134   	; 0xb332 <__divdi3+0xe56>
    aec4:	80 30       	cpi	r24, 0x00	; 0
    aec6:	10 e0       	ldi	r17, 0x00	; 0
    aec8:	91 07       	cpc	r25, r17
    aeca:	11 e0       	ldi	r17, 0x01	; 1
    aecc:	a1 07       	cpc	r26, r17
    aece:	10 e0       	ldi	r17, 0x00	; 0
    aed0:	b1 07       	cpc	r27, r17
    aed2:	50 f4       	brcc	.+20     	; 0xaee8 <__divdi3+0xa0c>
    aed4:	8f 3f       	cpi	r24, 0xFF	; 255
    aed6:	91 05       	cpc	r25, r1
    aed8:	a1 05       	cpc	r26, r1
    aeda:	b1 05       	cpc	r27, r1
    aedc:	09 f0       	breq	.+2      	; 0xaee0 <__divdi3+0xa04>
    aede:	88 f4       	brcc	.+34     	; 0xaf02 <__divdi3+0xa26>
    aee0:	00 e0       	ldi	r16, 0x00	; 0
    aee2:	10 e0       	ldi	r17, 0x00	; 0
    aee4:	98 01       	movw	r18, r16
    aee6:	16 c0       	rjmp	.+44     	; 0xaf14 <__divdi3+0xa38>
    aee8:	80 30       	cpi	r24, 0x00	; 0
    aeea:	20 e0       	ldi	r18, 0x00	; 0
    aeec:	92 07       	cpc	r25, r18
    aeee:	20 e0       	ldi	r18, 0x00	; 0
    aef0:	a2 07       	cpc	r26, r18
    aef2:	21 e0       	ldi	r18, 0x01	; 1
    aef4:	b2 07       	cpc	r27, r18
    aef6:	50 f4       	brcc	.+20     	; 0xaf0c <__divdi3+0xa30>
    aef8:	00 e1       	ldi	r16, 0x10	; 16
    aefa:	10 e0       	ldi	r17, 0x00	; 0
    aefc:	20 e0       	ldi	r18, 0x00	; 0
    aefe:	30 e0       	ldi	r19, 0x00	; 0
    af00:	09 c0       	rjmp	.+18     	; 0xaf14 <__divdi3+0xa38>
    af02:	08 e0       	ldi	r16, 0x08	; 8
    af04:	10 e0       	ldi	r17, 0x00	; 0
    af06:	20 e0       	ldi	r18, 0x00	; 0
    af08:	30 e0       	ldi	r19, 0x00	; 0
    af0a:	04 c0       	rjmp	.+8      	; 0xaf14 <__divdi3+0xa38>
    af0c:	08 e1       	ldi	r16, 0x18	; 24
    af0e:	10 e0       	ldi	r17, 0x00	; 0
    af10:	20 e0       	ldi	r18, 0x00	; 0
    af12:	30 e0       	ldi	r19, 0x00	; 0
    af14:	ac 01       	movw	r20, r24
    af16:	bd 01       	movw	r22, r26
    af18:	00 2e       	mov	r0, r16
    af1a:	04 c0       	rjmp	.+8      	; 0xaf24 <__divdi3+0xa48>
    af1c:	76 95       	lsr	r23
    af1e:	67 95       	ror	r22
    af20:	57 95       	ror	r21
    af22:	47 95       	ror	r20
    af24:	0a 94       	dec	r0
    af26:	d2 f7       	brpl	.-12     	; 0xaf1c <__divdi3+0xa40>
    af28:	fa 01       	movw	r30, r20
    af2a:	e6 5d       	subi	r30, 0xD6	; 214
    af2c:	ff 4d       	sbci	r31, 0xDF	; 223
    af2e:	40 81       	ld	r20, Z
    af30:	04 0f       	add	r16, r20
    af32:	11 1d       	adc	r17, r1
    af34:	21 1d       	adc	r18, r1
    af36:	31 1d       	adc	r19, r1
    af38:	40 e2       	ldi	r20, 0x20	; 32
    af3a:	50 e0       	ldi	r21, 0x00	; 0
    af3c:	60 e0       	ldi	r22, 0x00	; 0
    af3e:	70 e0       	ldi	r23, 0x00	; 0
    af40:	40 1b       	sub	r20, r16
    af42:	51 0b       	sbc	r21, r17
    af44:	62 0b       	sbc	r22, r18
    af46:	73 0b       	sbc	r23, r19
    af48:	a1 f4       	brne	.+40     	; 0xaf72 <__divdi3+0xa96>
    af4a:	8c 15       	cp	r24, r12
    af4c:	9d 05       	cpc	r25, r13
    af4e:	ae 05       	cpc	r26, r14
    af50:	bf 05       	cpc	r27, r15
    af52:	08 f4       	brcc	.+2      	; 0xaf56 <__divdi3+0xa7a>
    af54:	f5 c1       	rjmp	.+1002   	; 0xb340 <__divdi3+0xe64>
    af56:	ed a8       	sts	0x8d, r30
    af58:	fe a8       	sts	0x8e, r31
    af5a:	0f a9       	sts	0x4f, r16
    af5c:	18 ad       	sts	0x68, r17
    af5e:	44 24       	eor	r4, r4
    af60:	55 24       	eor	r5, r5
    af62:	32 01       	movw	r6, r4
    af64:	e8 14       	cp	r14, r8
    af66:	f9 04       	cpc	r15, r9
    af68:	0a 05       	cpc	r16, r10
    af6a:	1b 05       	cpc	r17, r11
    af6c:	08 f0       	brcs	.+2      	; 0xaf70 <__divdi3+0xa94>
    af6e:	eb c1       	rjmp	.+982    	; 0xb346 <__divdi3+0xe6a>
    af70:	e3 c1       	rjmp	.+966    	; 0xb338 <__divdi3+0xe5c>
    af72:	34 2e       	mov	r3, r20
    af74:	2c 01       	movw	r4, r24
    af76:	3d 01       	movw	r6, r26
    af78:	04 c0       	rjmp	.+8      	; 0xaf82 <__divdi3+0xaa6>
    af7a:	44 0c       	add	r4, r4
    af7c:	55 1c       	adc	r5, r5
    af7e:	66 1c       	adc	r6, r6
    af80:	77 1c       	adc	r7, r7
    af82:	4a 95       	dec	r20
    af84:	d2 f7       	brpl	.-12     	; 0xaf7a <__divdi3+0xa9e>
    af86:	d5 01       	movw	r26, r10
    af88:	c4 01       	movw	r24, r8
    af8a:	00 2e       	mov	r0, r16
    af8c:	04 c0       	rjmp	.+8      	; 0xaf96 <__divdi3+0xaba>
    af8e:	b6 95       	lsr	r27
    af90:	a7 95       	ror	r26
    af92:	97 95       	ror	r25
    af94:	87 95       	ror	r24
    af96:	0a 94       	dec	r0
    af98:	d2 f7       	brpl	.-12     	; 0xaf8e <__divdi3+0xab2>
    af9a:	48 2a       	or	r4, r24
    af9c:	59 2a       	or	r5, r25
    af9e:	6a 2a       	or	r6, r26
    afa0:	7b 2a       	or	r7, r27
    afa2:	a5 01       	movw	r20, r10
    afa4:	94 01       	movw	r18, r8
    afa6:	03 2c       	mov	r0, r3
    afa8:	04 c0       	rjmp	.+8      	; 0xafb2 <__divdi3+0xad6>
    afaa:	22 0f       	add	r18, r18
    afac:	33 1f       	adc	r19, r19
    afae:	44 1f       	adc	r20, r20
    afb0:	55 1f       	adc	r21, r21
    afb2:	0a 94       	dec	r0
    afb4:	d2 f7       	brpl	.-12     	; 0xafaa <__divdi3+0xace>
    afb6:	29 af       	sts	0x79, r18
    afb8:	3a af       	sts	0x7a, r19
    afba:	4b af       	sts	0x7b, r20
    afbc:	5c af       	sts	0x7c, r21
    afbe:	b7 01       	movw	r22, r14
    afc0:	a6 01       	movw	r20, r12
    afc2:	00 2e       	mov	r0, r16
    afc4:	04 c0       	rjmp	.+8      	; 0xafce <__divdi3+0xaf2>
    afc6:	76 95       	lsr	r23
    afc8:	67 95       	ror	r22
    afca:	57 95       	ror	r21
    afcc:	47 95       	ror	r20
    afce:	0a 94       	dec	r0
    afd0:	d2 f7       	brpl	.-12     	; 0xafc6 <__divdi3+0xaea>
    afd2:	49 ab       	sts	0x59, r20
    afd4:	5a ab       	sts	0x5a, r21
    afd6:	6b ab       	sts	0x5b, r22
    afd8:	7c ab       	sts	0x5c, r23
    afda:	c7 01       	movw	r24, r14
    afdc:	b6 01       	movw	r22, r12
    afde:	03 2c       	mov	r0, r3
    afe0:	04 c0       	rjmp	.+8      	; 0xafea <__divdi3+0xb0e>
    afe2:	66 0f       	add	r22, r22
    afe4:	77 1f       	adc	r23, r23
    afe6:	88 1f       	adc	r24, r24
    afe8:	99 1f       	adc	r25, r25
    afea:	0a 94       	dec	r0
    afec:	d2 f7       	brpl	.-12     	; 0xafe2 <__divdi3+0xb06>
    afee:	6d a7       	lds	r22, 0x7d
    aff0:	7e a7       	lds	r23, 0x7e
    aff2:	8f a7       	lds	r24, 0x7f
    aff4:	98 ab       	sts	0x58, r25
    aff6:	8d a9       	sts	0x4d, r24
    aff8:	9e a9       	sts	0x4e, r25
    affa:	af a9       	sts	0x4f, r26
    affc:	b8 ad       	sts	0x68, r27
    affe:	04 c0       	rjmp	.+8      	; 0xb008 <__divdi3+0xb2c>
    b000:	b6 95       	lsr	r27
    b002:	a7 95       	ror	r26
    b004:	97 95       	ror	r25
    b006:	87 95       	ror	r24
    b008:	0a 95       	dec	r16
    b00a:	d2 f7       	brpl	.-12     	; 0xb000 <__divdi3+0xb24>
    b00c:	4d a5       	lds	r20, 0x6d
    b00e:	5e a5       	lds	r21, 0x6e
    b010:	6f a5       	lds	r22, 0x6f
    b012:	78 a9       	sts	0x48, r23
    b014:	48 2b       	or	r20, r24
    b016:	59 2b       	or	r21, r25
    b018:	6a 2b       	or	r22, r26
    b01a:	7b 2b       	or	r23, r27
    b01c:	4d a7       	lds	r20, 0x7d
    b01e:	5e a7       	lds	r21, 0x7e
    b020:	6f a7       	lds	r22, 0x7f
    b022:	78 ab       	sts	0x58, r23
    b024:	43 01       	movw	r8, r6
    b026:	aa 24       	eor	r10, r10
    b028:	bb 24       	eor	r11, r11
    b02a:	93 01       	movw	r18, r6
    b02c:	82 01       	movw	r16, r4
    b02e:	20 70       	andi	r18, 0x00	; 0
    b030:	30 70       	andi	r19, 0x00	; 0
    b032:	21 96       	adiw	r28, 0x01	; 1
    b034:	0c af       	sts	0x7c, r16
    b036:	1d af       	sts	0x7d, r17
    b038:	2e af       	sts	0x7e, r18
    b03a:	3f af       	sts	0x7f, r19
    b03c:	21 97       	sbiw	r28, 0x01	; 1
    b03e:	69 a9       	sts	0x49, r22
    b040:	7a a9       	sts	0x4a, r23
    b042:	8b a9       	sts	0x4b, r24
    b044:	9c a9       	sts	0x4c, r25
    b046:	a5 01       	movw	r20, r10
    b048:	94 01       	movw	r18, r8
    b04a:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    b04e:	29 a7       	lds	r18, 0x79
    b050:	3a a7       	lds	r19, 0x7a
    b052:	4b a7       	lds	r20, 0x7b
    b054:	5c a7       	lds	r21, 0x7c
    b056:	6b 01       	movw	r12, r22
    b058:	7c 01       	movw	r14, r24
    b05a:	69 a9       	sts	0x49, r22
    b05c:	7a a9       	sts	0x4a, r23
    b05e:	8b a9       	sts	0x4b, r24
    b060:	9c a9       	sts	0x4c, r25
    b062:	a5 01       	movw	r20, r10
    b064:	94 01       	movw	r18, r8
    b066:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    b06a:	ca 01       	movw	r24, r20
    b06c:	b9 01       	movw	r22, r18
    b06e:	21 96       	adiw	r28, 0x01	; 1
    b070:	2c ad       	sts	0x6c, r18
    b072:	3d ad       	sts	0x6d, r19
    b074:	4e ad       	sts	0x6e, r20
    b076:	5f ad       	sts	0x6f, r21
    b078:	21 97       	sbiw	r28, 0x01	; 1
    b07a:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    b07e:	dc 01       	movw	r26, r24
    b080:	cb 01       	movw	r24, r22
    b082:	76 01       	movw	r14, r12
    b084:	dd 24       	eor	r13, r13
    b086:	cc 24       	eor	r12, r12
    b088:	0d a5       	lds	r16, 0x6d
    b08a:	1e a5       	lds	r17, 0x6e
    b08c:	2f a5       	lds	r18, 0x6f
    b08e:	38 a9       	sts	0x48, r19
    b090:	a9 01       	movw	r20, r18
    b092:	66 27       	eor	r22, r22
    b094:	77 27       	eor	r23, r23
    b096:	c4 2a       	or	r12, r20
    b098:	d5 2a       	or	r13, r21
    b09a:	e6 2a       	or	r14, r22
    b09c:	f7 2a       	or	r15, r23
    b09e:	09 a5       	lds	r16, 0x69
    b0a0:	1a a5       	lds	r17, 0x6a
    b0a2:	2b a5       	lds	r18, 0x6b
    b0a4:	3c a5       	lds	r19, 0x6c
    b0a6:	c8 16       	cp	r12, r24
    b0a8:	d9 06       	cpc	r13, r25
    b0aa:	ea 06       	cpc	r14, r26
    b0ac:	fb 06       	cpc	r15, r27
    b0ae:	38 f5       	brcc	.+78     	; 0xb0fe <__divdi3+0xc22>
    b0b0:	01 50       	subi	r16, 0x01	; 1
    b0b2:	10 40       	sbci	r17, 0x00	; 0
    b0b4:	20 40       	sbci	r18, 0x00	; 0
    b0b6:	30 40       	sbci	r19, 0x00	; 0
    b0b8:	09 ab       	sts	0x59, r16
    b0ba:	1a ab       	sts	0x5a, r17
    b0bc:	2b ab       	sts	0x5b, r18
    b0be:	3c ab       	sts	0x5c, r19
    b0c0:	c4 0c       	add	r12, r4
    b0c2:	d5 1c       	adc	r13, r5
    b0c4:	e6 1c       	adc	r14, r6
    b0c6:	f7 1c       	adc	r15, r7
    b0c8:	c4 14       	cp	r12, r4
    b0ca:	d5 04       	cpc	r13, r5
    b0cc:	e6 04       	cpc	r14, r6
    b0ce:	f7 04       	cpc	r15, r7
    b0d0:	d0 f0       	brcs	.+52     	; 0xb106 <__divdi3+0xc2a>
    b0d2:	c8 16       	cp	r12, r24
    b0d4:	d9 06       	cpc	r13, r25
    b0d6:	ea 06       	cpc	r14, r26
    b0d8:	fb 06       	cpc	r15, r27
    b0da:	a8 f4       	brcc	.+42     	; 0xb106 <__divdi3+0xc2a>
    b0dc:	09 a5       	lds	r16, 0x69
    b0de:	1a a5       	lds	r17, 0x6a
    b0e0:	2b a5       	lds	r18, 0x6b
    b0e2:	3c a5       	lds	r19, 0x6c
    b0e4:	02 50       	subi	r16, 0x02	; 2
    b0e6:	10 40       	sbci	r17, 0x00	; 0
    b0e8:	20 40       	sbci	r18, 0x00	; 0
    b0ea:	30 40       	sbci	r19, 0x00	; 0
    b0ec:	09 ab       	sts	0x59, r16
    b0ee:	1a ab       	sts	0x5a, r17
    b0f0:	2b ab       	sts	0x5b, r18
    b0f2:	3c ab       	sts	0x5c, r19
    b0f4:	c4 0c       	add	r12, r4
    b0f6:	d5 1c       	adc	r13, r5
    b0f8:	e6 1c       	adc	r14, r6
    b0fa:	f7 1c       	adc	r15, r7
    b0fc:	04 c0       	rjmp	.+8      	; 0xb106 <__divdi3+0xc2a>
    b0fe:	09 ab       	sts	0x59, r16
    b100:	1a ab       	sts	0x5a, r17
    b102:	2b ab       	sts	0x5b, r18
    b104:	3c ab       	sts	0x5c, r19
    b106:	c8 1a       	sub	r12, r24
    b108:	d9 0a       	sbc	r13, r25
    b10a:	ea 0a       	sbc	r14, r26
    b10c:	fb 0a       	sbc	r15, r27
    b10e:	c7 01       	movw	r24, r14
    b110:	b6 01       	movw	r22, r12
    b112:	a5 01       	movw	r20, r10
    b114:	94 01       	movw	r18, r8
    b116:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    b11a:	29 a7       	lds	r18, 0x79
    b11c:	3a a7       	lds	r19, 0x7a
    b11e:	4b a7       	lds	r20, 0x7b
    b120:	5c a7       	lds	r21, 0x7c
    b122:	29 96       	adiw	r28, 0x09	; 9
    b124:	6c af       	sts	0x7c, r22
    b126:	7d af       	sts	0x7d, r23
    b128:	8e af       	sts	0x7e, r24
    b12a:	9f af       	sts	0x7f, r25
    b12c:	29 97       	sbiw	r28, 0x09	; 9
    b12e:	c7 01       	movw	r24, r14
    b130:	b6 01       	movw	r22, r12
    b132:	a5 01       	movw	r20, r10
    b134:	94 01       	movw	r18, r8
    b136:	0e 94 e4 5b 	call	0xb7c8	; 0xb7c8 <__udivmodsi4>
    b13a:	ca 01       	movw	r24, r20
    b13c:	b9 01       	movw	r22, r18
    b13e:	21 96       	adiw	r28, 0x01	; 1
    b140:	2c ad       	sts	0x6c, r18
    b142:	3d ad       	sts	0x6d, r19
    b144:	4e ad       	sts	0x6e, r20
    b146:	5f ad       	sts	0x6f, r21
    b148:	21 97       	sbiw	r28, 0x01	; 1
    b14a:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    b14e:	4b 01       	movw	r8, r22
    b150:	5c 01       	movw	r10, r24
    b152:	29 96       	adiw	r28, 0x09	; 9
    b154:	4c ad       	sts	0x6c, r20
    b156:	5d ad       	sts	0x6d, r21
    b158:	6e ad       	sts	0x6e, r22
    b15a:	7f ad       	sts	0x6f, r23
    b15c:	29 97       	sbiw	r28, 0x09	; 9
    b15e:	9a 01       	movw	r18, r20
    b160:	11 27       	eor	r17, r17
    b162:	00 27       	eor	r16, r16
    b164:	8d a5       	lds	r24, 0x6d
    b166:	9e a5       	lds	r25, 0x6e
    b168:	af a5       	lds	r26, 0x6f
    b16a:	b8 a9       	sts	0x48, r27
    b16c:	a0 70       	andi	r26, 0x00	; 0
    b16e:	b0 70       	andi	r27, 0x00	; 0
    b170:	08 2b       	or	r16, r24
    b172:	19 2b       	or	r17, r25
    b174:	2a 2b       	or	r18, r26
    b176:	3b 2b       	or	r19, r27
    b178:	89 a5       	lds	r24, 0x69
    b17a:	9a a5       	lds	r25, 0x6a
    b17c:	ab a5       	lds	r26, 0x6b
    b17e:	bc a5       	lds	r27, 0x6c
    b180:	08 15       	cp	r16, r8
    b182:	19 05       	cpc	r17, r9
    b184:	2a 05       	cpc	r18, r10
    b186:	3b 05       	cpc	r19, r11
    b188:	e0 f4       	brcc	.+56     	; 0xb1c2 <__divdi3+0xce6>
    b18a:	01 97       	sbiw	r24, 0x01	; 1
    b18c:	a1 09       	sbc	r26, r1
    b18e:	b1 09       	sbc	r27, r1
    b190:	04 0d       	add	r16, r4
    b192:	15 1d       	adc	r17, r5
    b194:	26 1d       	adc	r18, r6
    b196:	37 1d       	adc	r19, r7
    b198:	04 15       	cp	r16, r4
    b19a:	15 05       	cpc	r17, r5
    b19c:	26 05       	cpc	r18, r6
    b19e:	37 05       	cpc	r19, r7
    b1a0:	80 f0       	brcs	.+32     	; 0xb1c2 <__divdi3+0xce6>
    b1a2:	08 15       	cp	r16, r8
    b1a4:	19 05       	cpc	r17, r9
    b1a6:	2a 05       	cpc	r18, r10
    b1a8:	3b 05       	cpc	r19, r11
    b1aa:	58 f4       	brcc	.+22     	; 0xb1c2 <__divdi3+0xce6>
    b1ac:	89 a5       	lds	r24, 0x69
    b1ae:	9a a5       	lds	r25, 0x6a
    b1b0:	ab a5       	lds	r26, 0x6b
    b1b2:	bc a5       	lds	r27, 0x6c
    b1b4:	02 97       	sbiw	r24, 0x02	; 2
    b1b6:	a1 09       	sbc	r26, r1
    b1b8:	b1 09       	sbc	r27, r1
    b1ba:	04 0d       	add	r16, r4
    b1bc:	15 1d       	adc	r17, r5
    b1be:	26 1d       	adc	r18, r6
    b1c0:	37 1d       	adc	r19, r7
    b1c2:	b9 01       	movw	r22, r18
    b1c4:	a8 01       	movw	r20, r16
    b1c6:	48 19       	sub	r20, r8
    b1c8:	59 09       	sbc	r21, r9
    b1ca:	6a 09       	sbc	r22, r10
    b1cc:	7b 09       	sbc	r23, r11
    b1ce:	4d a7       	lds	r20, 0x7d
    b1d0:	5e a7       	lds	r21, 0x7e
    b1d2:	6f a7       	lds	r22, 0x7f
    b1d4:	78 ab       	sts	0x58, r23
    b1d6:	09 a9       	sts	0x49, r16
    b1d8:	1a a9       	sts	0x4a, r17
    b1da:	2b a9       	sts	0x4b, r18
    b1dc:	3c a9       	sts	0x4c, r19
    b1de:	78 01       	movw	r14, r16
    b1e0:	dd 24       	eor	r13, r13
    b1e2:	cc 24       	eor	r12, r12
    b1e4:	c8 2a       	or	r12, r24
    b1e6:	d9 2a       	or	r13, r25
    b1e8:	ea 2a       	or	r14, r26
    b1ea:	fb 2a       	or	r15, r27
    b1ec:	ff ef       	ldi	r31, 0xFF	; 255
    b1ee:	8f 2e       	mov	r8, r31
    b1f0:	ff ef       	ldi	r31, 0xFF	; 255
    b1f2:	9f 2e       	mov	r9, r31
    b1f4:	a1 2c       	mov	r10, r1
    b1f6:	b1 2c       	mov	r11, r1
    b1f8:	8c 20       	and	r8, r12
    b1fa:	9d 20       	and	r9, r13
    b1fc:	ae 20       	and	r10, r14
    b1fe:	bf 20       	and	r11, r15
    b200:	87 01       	movw	r16, r14
    b202:	22 27       	eor	r18, r18
    b204:	33 27       	eor	r19, r19
    b206:	09 a7       	lds	r16, 0x79
    b208:	1a a7       	lds	r17, 0x7a
    b20a:	2b a7       	lds	r18, 0x7b
    b20c:	3c a7       	lds	r19, 0x7c
    b20e:	49 ac       	sts	0xa9, r20
    b210:	5a ac       	sts	0xaa, r21
    b212:	6b ac       	sts	0xab, r22
    b214:	7c ac       	sts	0xac, r23
    b216:	2f ef       	ldi	r18, 0xFF	; 255
    b218:	3f ef       	ldi	r19, 0xFF	; 255
    b21a:	40 e0       	ldi	r20, 0x00	; 0
    b21c:	50 e0       	ldi	r21, 0x00	; 0
    b21e:	42 22       	and	r4, r18
    b220:	53 22       	and	r5, r19
    b222:	64 22       	and	r6, r20
    b224:	75 22       	and	r7, r21
    b226:	29 ad       	sts	0x69, r18
    b228:	3a ad       	sts	0x6a, r19
    b22a:	4b ad       	sts	0x6b, r20
    b22c:	5c ad       	sts	0x6c, r21
    b22e:	8a 01       	movw	r16, r20
    b230:	22 27       	eor	r18, r18
    b232:	33 27       	eor	r19, r19
    b234:	09 ab       	sts	0x59, r16
    b236:	1a ab       	sts	0x5a, r17
    b238:	2b ab       	sts	0x5b, r18
    b23a:	3c ab       	sts	0x5c, r19
    b23c:	c5 01       	movw	r24, r10
    b23e:	b4 01       	movw	r22, r8
    b240:	a3 01       	movw	r20, r6
    b242:	92 01       	movw	r18, r4
    b244:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    b248:	69 af       	sts	0x79, r22
    b24a:	7a af       	sts	0x7a, r23
    b24c:	8b af       	sts	0x7b, r24
    b24e:	9c af       	sts	0x7c, r25
    b250:	c5 01       	movw	r24, r10
    b252:	b4 01       	movw	r22, r8
    b254:	29 a9       	sts	0x49, r18
    b256:	3a a9       	sts	0x4a, r19
    b258:	4b a9       	sts	0x4b, r20
    b25a:	5c a9       	sts	0x4c, r21
    b25c:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    b260:	4b 01       	movw	r8, r22
    b262:	5c 01       	movw	r10, r24
    b264:	69 a5       	lds	r22, 0x69
    b266:	7a a5       	lds	r23, 0x6a
    b268:	8b a5       	lds	r24, 0x6b
    b26a:	9c a5       	lds	r25, 0x6c
    b26c:	a3 01       	movw	r20, r6
    b26e:	92 01       	movw	r18, r4
    b270:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    b274:	2b 01       	movw	r4, r22
    b276:	3c 01       	movw	r6, r24
    b278:	69 a5       	lds	r22, 0x69
    b27a:	7a a5       	lds	r23, 0x6a
    b27c:	8b a5       	lds	r24, 0x6b
    b27e:	9c a5       	lds	r25, 0x6c
    b280:	29 a9       	sts	0x49, r18
    b282:	3a a9       	sts	0x4a, r19
    b284:	4b a9       	sts	0x4b, r20
    b286:	5c a9       	sts	0x4c, r21
    b288:	0e 94 9e 5b 	call	0xb73c	; 0xb73c <__mulsi3>
    b28c:	ab 01       	movw	r20, r22
    b28e:	bc 01       	movw	r22, r24
    b290:	84 0c       	add	r8, r4
    b292:	95 1c       	adc	r9, r5
    b294:	a6 1c       	adc	r10, r6
    b296:	b7 1c       	adc	r11, r7
    b298:	09 ad       	sts	0x69, r16
    b29a:	1a ad       	sts	0x6a, r17
    b29c:	2b ad       	sts	0x6b, r18
    b29e:	3c ad       	sts	0x6c, r19
    b2a0:	c9 01       	movw	r24, r18
    b2a2:	aa 27       	eor	r26, r26
    b2a4:	bb 27       	eor	r27, r27
    b2a6:	88 0e       	add	r8, r24
    b2a8:	99 1e       	adc	r9, r25
    b2aa:	aa 1e       	adc	r10, r26
    b2ac:	bb 1e       	adc	r11, r27
    b2ae:	84 14       	cp	r8, r4
    b2b0:	95 04       	cpc	r9, r5
    b2b2:	a6 04       	cpc	r10, r6
    b2b4:	b7 04       	cpc	r11, r7
    b2b6:	20 f4       	brcc	.+8      	; 0xb2c0 <__divdi3+0xde4>
    b2b8:	40 50       	subi	r20, 0x00	; 0
    b2ba:	50 40       	sbci	r21, 0x00	; 0
    b2bc:	6f 4f       	sbci	r22, 0xFF	; 255
    b2be:	7f 4f       	sbci	r23, 0xFF	; 255
    b2c0:	c5 01       	movw	r24, r10
    b2c2:	aa 27       	eor	r26, r26
    b2c4:	bb 27       	eor	r27, r27
    b2c6:	84 0f       	add	r24, r20
    b2c8:	95 1f       	adc	r25, r21
    b2ca:	a6 1f       	adc	r26, r22
    b2cc:	b7 1f       	adc	r27, r23
    b2ce:	0d a5       	lds	r16, 0x6d
    b2d0:	1e a5       	lds	r17, 0x6e
    b2d2:	2f a5       	lds	r18, 0x6f
    b2d4:	38 a9       	sts	0x48, r19
    b2d6:	08 17       	cp	r16, r24
    b2d8:	19 07       	cpc	r17, r25
    b2da:	2a 07       	cpc	r18, r26
    b2dc:	3b 07       	cpc	r19, r27
    b2de:	18 f1       	brcs	.+70     	; 0xb326 <__divdi3+0xe4a>
    b2e0:	80 17       	cp	r24, r16
    b2e2:	91 07       	cpc	r25, r17
    b2e4:	a2 07       	cpc	r26, r18
    b2e6:	b3 07       	cpc	r27, r19
    b2e8:	a1 f5       	brne	.+104    	; 0xb352 <__divdi3+0xe76>
    b2ea:	54 01       	movw	r10, r8
    b2ec:	99 24       	eor	r9, r9
    b2ee:	88 24       	eor	r8, r8
    b2f0:	89 ad       	sts	0x69, r24
    b2f2:	9a ad       	sts	0x6a, r25
    b2f4:	ab ad       	sts	0x6b, r26
    b2f6:	bc ad       	sts	0x6c, r27
    b2f8:	a0 70       	andi	r26, 0x00	; 0
    b2fa:	b0 70       	andi	r27, 0x00	; 0
    b2fc:	88 0e       	add	r8, r24
    b2fe:	99 1e       	adc	r9, r25
    b300:	aa 1e       	adc	r10, r26
    b302:	bb 1e       	adc	r11, r27
    b304:	4d a9       	sts	0x4d, r20
    b306:	5e a9       	sts	0x4e, r21
    b308:	6f a9       	sts	0x4f, r22
    b30a:	78 ad       	sts	0x68, r23
    b30c:	03 2c       	mov	r0, r3
    b30e:	04 c0       	rjmp	.+8      	; 0xb318 <__divdi3+0xe3c>
    b310:	44 0f       	add	r20, r20
    b312:	55 1f       	adc	r21, r21
    b314:	66 1f       	adc	r22, r22
    b316:	77 1f       	adc	r23, r23
    b318:	0a 94       	dec	r0
    b31a:	d2 f7       	brpl	.-12     	; 0xb310 <__divdi3+0xe34>
    b31c:	48 15       	cp	r20, r8
    b31e:	59 05       	cpc	r21, r9
    b320:	6a 05       	cpc	r22, r10
    b322:	7b 05       	cpc	r23, r11
    b324:	b0 f4       	brcc	.+44     	; 0xb352 <__divdi3+0xe76>
    b326:	08 94       	sec
    b328:	c1 08       	sbc	r12, r1
    b32a:	d1 08       	sbc	r13, r1
    b32c:	e1 08       	sbc	r14, r1
    b32e:	f1 08       	sbc	r15, r1
    b330:	10 c0       	rjmp	.+32     	; 0xb352 <__divdi3+0xe76>
    b332:	44 24       	eor	r4, r4
    b334:	55 24       	eor	r5, r5
    b336:	32 01       	movw	r6, r4
    b338:	cc 24       	eor	r12, r12
    b33a:	dd 24       	eor	r13, r13
    b33c:	76 01       	movw	r14, r12
    b33e:	0c c0       	rjmp	.+24     	; 0xb358 <__divdi3+0xe7c>
    b340:	44 24       	eor	r4, r4
    b342:	55 24       	eor	r5, r5
    b344:	32 01       	movw	r6, r4
    b346:	81 e0       	ldi	r24, 0x01	; 1
    b348:	c8 2e       	mov	r12, r24
    b34a:	d1 2c       	mov	r13, r1
    b34c:	e1 2c       	mov	r14, r1
    b34e:	f1 2c       	mov	r15, r1
    b350:	03 c0       	rjmp	.+6      	; 0xb358 <__divdi3+0xe7c>
    b352:	44 24       	eor	r4, r4
    b354:	55 24       	eor	r5, r5
    b356:	32 01       	movw	r6, r4
    b358:	fe 01       	movw	r30, r28
    b35a:	31 96       	adiw	r30, 0x01	; 1
    b35c:	88 e0       	ldi	r24, 0x08	; 8
    b35e:	df 01       	movw	r26, r30
    b360:	1d 92       	st	X+, r1
    b362:	8a 95       	dec	r24
    b364:	e9 f7       	brne	.-6      	; 0xb360 <__divdi3+0xe84>
    b366:	c9 82       	std	Y+1, r12	; 0x01
    b368:	da 82       	std	Y+2, r13	; 0x02
    b36a:	eb 82       	std	Y+3, r14	; 0x03
    b36c:	fc 82       	std	Y+4, r15	; 0x04
    b36e:	4d 82       	std	Y+5, r4	; 0x05
    b370:	5e 82       	std	Y+6, r5	; 0x06
    b372:	6f 82       	std	Y+7, r6	; 0x07
    b374:	78 86       	std	Y+8, r7	; 0x08
    b376:	2c 2d       	mov	r18, r12
    b378:	3a 81       	ldd	r19, Y+2	; 0x02
    b37a:	4b 81       	ldd	r20, Y+3	; 0x03
    b37c:	5c 81       	ldd	r21, Y+4	; 0x04
    b37e:	64 2d       	mov	r22, r4
    b380:	7e 81       	ldd	r23, Y+6	; 0x06
    b382:	8f 81       	ldd	r24, Y+7	; 0x07
    b384:	98 85       	ldd	r25, Y+8	; 0x08
    b386:	25 96       	adiw	r28, 0x05	; 5
    b388:	ec ac       	sts	0xac, r30
    b38a:	fd ac       	sts	0xad, r31
    b38c:	0e ad       	sts	0x6e, r16
    b38e:	1f ad       	sts	0x6f, r17
    b390:	25 97       	sbiw	r28, 0x05	; 5
    b392:	e1 14       	cp	r14, r1
    b394:	f1 04       	cpc	r15, r1
    b396:	01 05       	cpc	r16, r1
    b398:	11 05       	cpc	r17, r1
    b39a:	09 f4       	brne	.+2      	; 0xb39e <__divdi3+0xec2>
    b39c:	56 c0       	rjmp	.+172    	; 0xb44a <__divdi3+0xf6e>
    b39e:	21 95       	neg	r18
    b3a0:	e1 e0       	ldi	r30, 0x01	; 1
    b3a2:	12 16       	cp	r1, r18
    b3a4:	08 f0       	brcs	.+2      	; 0xb3a8 <__divdi3+0xecc>
    b3a6:	e0 e0       	ldi	r30, 0x00	; 0
    b3a8:	31 95       	neg	r19
    b3aa:	f1 e0       	ldi	r31, 0x01	; 1
    b3ac:	13 16       	cp	r1, r19
    b3ae:	08 f0       	brcs	.+2      	; 0xb3b2 <__divdi3+0xed6>
    b3b0:	f0 e0       	ldi	r31, 0x00	; 0
    b3b2:	03 2f       	mov	r16, r19
    b3b4:	0e 1b       	sub	r16, r30
    b3b6:	e1 e0       	ldi	r30, 0x01	; 1
    b3b8:	30 17       	cp	r19, r16
    b3ba:	08 f0       	brcs	.+2      	; 0xb3be <__divdi3+0xee2>
    b3bc:	e0 e0       	ldi	r30, 0x00	; 0
    b3be:	fe 2b       	or	r31, r30
    b3c0:	41 95       	neg	r20
    b3c2:	e1 e0       	ldi	r30, 0x01	; 1
    b3c4:	14 16       	cp	r1, r20
    b3c6:	08 f0       	brcs	.+2      	; 0xb3ca <__divdi3+0xeee>
    b3c8:	e0 e0       	ldi	r30, 0x00	; 0
    b3ca:	14 2f       	mov	r17, r20
    b3cc:	1f 1b       	sub	r17, r31
    b3ce:	31 e0       	ldi	r19, 0x01	; 1
    b3d0:	41 17       	cp	r20, r17
    b3d2:	08 f0       	brcs	.+2      	; 0xb3d6 <__divdi3+0xefa>
    b3d4:	30 e0       	ldi	r19, 0x00	; 0
    b3d6:	e3 2b       	or	r30, r19
    b3d8:	51 95       	neg	r21
    b3da:	f1 e0       	ldi	r31, 0x01	; 1
    b3dc:	15 16       	cp	r1, r21
    b3de:	08 f0       	brcs	.+2      	; 0xb3e2 <__divdi3+0xf06>
    b3e0:	f0 e0       	ldi	r31, 0x00	; 0
    b3e2:	b5 2f       	mov	r27, r21
    b3e4:	be 1b       	sub	r27, r30
    b3e6:	31 e0       	ldi	r19, 0x01	; 1
    b3e8:	5b 17       	cp	r21, r27
    b3ea:	08 f0       	brcs	.+2      	; 0xb3ee <__divdi3+0xf12>
    b3ec:	30 e0       	ldi	r19, 0x00	; 0
    b3ee:	f3 2b       	or	r31, r19
    b3f0:	61 95       	neg	r22
    b3f2:	e1 e0       	ldi	r30, 0x01	; 1
    b3f4:	16 16       	cp	r1, r22
    b3f6:	08 f0       	brcs	.+2      	; 0xb3fa <__divdi3+0xf1e>
    b3f8:	e0 e0       	ldi	r30, 0x00	; 0
    b3fa:	46 2e       	mov	r4, r22
    b3fc:	4f 1a       	sub	r4, r31
    b3fe:	31 e0       	ldi	r19, 0x01	; 1
    b400:	64 15       	cp	r22, r4
    b402:	08 f0       	brcs	.+2      	; 0xb406 <__divdi3+0xf2a>
    b404:	30 e0       	ldi	r19, 0x00	; 0
    b406:	e3 2b       	or	r30, r19
    b408:	71 95       	neg	r23
    b40a:	f1 e0       	ldi	r31, 0x01	; 1
    b40c:	17 16       	cp	r1, r23
    b40e:	08 f0       	brcs	.+2      	; 0xb412 <__divdi3+0xf36>
    b410:	f0 e0       	ldi	r31, 0x00	; 0
    b412:	a7 2f       	mov	r26, r23
    b414:	ae 1b       	sub	r26, r30
    b416:	31 e0       	ldi	r19, 0x01	; 1
    b418:	7a 17       	cp	r23, r26
    b41a:	08 f0       	brcs	.+2      	; 0xb41e <__divdi3+0xf42>
    b41c:	30 e0       	ldi	r19, 0x00	; 0
    b41e:	f3 2b       	or	r31, r19
    b420:	81 95       	neg	r24
    b422:	e1 e0       	ldi	r30, 0x01	; 1
    b424:	18 16       	cp	r1, r24
    b426:	08 f0       	brcs	.+2      	; 0xb42a <__divdi3+0xf4e>
    b428:	e0 e0       	ldi	r30, 0x00	; 0
    b42a:	f8 2e       	mov	r15, r24
    b42c:	ff 1a       	sub	r15, r31
    b42e:	ff 2d       	mov	r31, r15
    b430:	31 e0       	ldi	r19, 0x01	; 1
    b432:	8f 15       	cp	r24, r15
    b434:	08 f0       	brcs	.+2      	; 0xb438 <__divdi3+0xf5c>
    b436:	30 e0       	ldi	r19, 0x00	; 0
    b438:	e3 2b       	or	r30, r19
    b43a:	91 95       	neg	r25
    b43c:	30 2f       	mov	r19, r16
    b43e:	41 2f       	mov	r20, r17
    b440:	5b 2f       	mov	r21, r27
    b442:	64 2d       	mov	r22, r4
    b444:	7a 2f       	mov	r23, r26
    b446:	8f 2f       	mov	r24, r31
    b448:	9e 1b       	sub	r25, r30
    b44a:	c8 5b       	subi	r28, 0xB8	; 184
    b44c:	df 4f       	sbci	r29, 0xFF	; 255
    b44e:	e1 e1       	ldi	r30, 0x11	; 17
    b450:	0c 94 3b 5c 	jmp	0xb876	; 0xb876 <__epilogue_restores__+0x2>

0000b454 <__cmpsf2>:
    b454:	97 d0       	rcall	.+302    	; 0xb584 <__fp_cmp>
    b456:	08 f4       	brcc	.+2      	; 0xb45a <__cmpsf2+0x6>
    b458:	81 e0       	ldi	r24, 0x01	; 1
    b45a:	08 95       	ret

0000b45c <__divsf3>:
    b45c:	0c d0       	rcall	.+24     	; 0xb476 <__divsf3x>
    b45e:	cd c0       	rjmp	.+410    	; 0xb5fa <__fp_round>
    b460:	c5 d0       	rcall	.+394    	; 0xb5ec <__fp_pscB>
    b462:	40 f0       	brcs	.+16     	; 0xb474 <__divsf3+0x18>
    b464:	bc d0       	rcall	.+376    	; 0xb5de <__fp_pscA>
    b466:	30 f0       	brcs	.+12     	; 0xb474 <__divsf3+0x18>
    b468:	21 f4       	brne	.+8      	; 0xb472 <__divsf3+0x16>
    b46a:	5f 3f       	cpi	r21, 0xFF	; 255
    b46c:	19 f0       	breq	.+6      	; 0xb474 <__divsf3+0x18>
    b46e:	ae c0       	rjmp	.+348    	; 0xb5cc <__fp_inf>
    b470:	51 11       	cpse	r21, r1
    b472:	f7 c0       	rjmp	.+494    	; 0xb662 <__fp_szero>
    b474:	b1 c0       	rjmp	.+354    	; 0xb5d8 <__fp_nan>

0000b476 <__divsf3x>:
    b476:	d2 d0       	rcall	.+420    	; 0xb61c <__fp_split3>
    b478:	98 f3       	brcs	.-26     	; 0xb460 <__divsf3+0x4>

0000b47a <__divsf3_pse>:
    b47a:	99 23       	and	r25, r25
    b47c:	c9 f3       	breq	.-14     	; 0xb470 <__divsf3+0x14>
    b47e:	55 23       	and	r21, r21
    b480:	b1 f3       	breq	.-20     	; 0xb46e <__divsf3+0x12>
    b482:	95 1b       	sub	r25, r21
    b484:	55 0b       	sbc	r21, r21
    b486:	bb 27       	eor	r27, r27
    b488:	aa 27       	eor	r26, r26
    b48a:	62 17       	cp	r22, r18
    b48c:	73 07       	cpc	r23, r19
    b48e:	84 07       	cpc	r24, r20
    b490:	38 f0       	brcs	.+14     	; 0xb4a0 <__divsf3_pse+0x26>
    b492:	9f 5f       	subi	r25, 0xFF	; 255
    b494:	5f 4f       	sbci	r21, 0xFF	; 255
    b496:	22 0f       	add	r18, r18
    b498:	33 1f       	adc	r19, r19
    b49a:	44 1f       	adc	r20, r20
    b49c:	aa 1f       	adc	r26, r26
    b49e:	a9 f3       	breq	.-22     	; 0xb48a <__divsf3_pse+0x10>
    b4a0:	33 d0       	rcall	.+102    	; 0xb508 <__divsf3_pse+0x8e>
    b4a2:	0e 2e       	mov	r0, r30
    b4a4:	3a f0       	brmi	.+14     	; 0xb4b4 <__divsf3_pse+0x3a>
    b4a6:	e0 e8       	ldi	r30, 0x80	; 128
    b4a8:	30 d0       	rcall	.+96     	; 0xb50a <__divsf3_pse+0x90>
    b4aa:	91 50       	subi	r25, 0x01	; 1
    b4ac:	50 40       	sbci	r21, 0x00	; 0
    b4ae:	e6 95       	lsr	r30
    b4b0:	00 1c       	adc	r0, r0
    b4b2:	ca f7       	brpl	.-14     	; 0xb4a6 <__divsf3_pse+0x2c>
    b4b4:	29 d0       	rcall	.+82     	; 0xb508 <__divsf3_pse+0x8e>
    b4b6:	fe 2f       	mov	r31, r30
    b4b8:	27 d0       	rcall	.+78     	; 0xb508 <__divsf3_pse+0x8e>
    b4ba:	66 0f       	add	r22, r22
    b4bc:	77 1f       	adc	r23, r23
    b4be:	88 1f       	adc	r24, r24
    b4c0:	bb 1f       	adc	r27, r27
    b4c2:	26 17       	cp	r18, r22
    b4c4:	37 07       	cpc	r19, r23
    b4c6:	48 07       	cpc	r20, r24
    b4c8:	ab 07       	cpc	r26, r27
    b4ca:	b0 e8       	ldi	r27, 0x80	; 128
    b4cc:	09 f0       	breq	.+2      	; 0xb4d0 <__divsf3_pse+0x56>
    b4ce:	bb 0b       	sbc	r27, r27
    b4d0:	80 2d       	mov	r24, r0
    b4d2:	bf 01       	movw	r22, r30
    b4d4:	ff 27       	eor	r31, r31
    b4d6:	93 58       	subi	r25, 0x83	; 131
    b4d8:	5f 4f       	sbci	r21, 0xFF	; 255
    b4da:	2a f0       	brmi	.+10     	; 0xb4e6 <__divsf3_pse+0x6c>
    b4dc:	9e 3f       	cpi	r25, 0xFE	; 254
    b4de:	51 05       	cpc	r21, r1
    b4e0:	68 f0       	brcs	.+26     	; 0xb4fc <__divsf3_pse+0x82>
    b4e2:	74 c0       	rjmp	.+232    	; 0xb5cc <__fp_inf>
    b4e4:	be c0       	rjmp	.+380    	; 0xb662 <__fp_szero>
    b4e6:	5f 3f       	cpi	r21, 0xFF	; 255
    b4e8:	ec f3       	brlt	.-6      	; 0xb4e4 <__divsf3_pse+0x6a>
    b4ea:	98 3e       	cpi	r25, 0xE8	; 232
    b4ec:	dc f3       	brlt	.-10     	; 0xb4e4 <__divsf3_pse+0x6a>
    b4ee:	86 95       	lsr	r24
    b4f0:	77 95       	ror	r23
    b4f2:	67 95       	ror	r22
    b4f4:	b7 95       	ror	r27
    b4f6:	f7 95       	ror	r31
    b4f8:	9f 5f       	subi	r25, 0xFF	; 255
    b4fa:	c9 f7       	brne	.-14     	; 0xb4ee <__divsf3_pse+0x74>
    b4fc:	88 0f       	add	r24, r24
    b4fe:	91 1d       	adc	r25, r1
    b500:	96 95       	lsr	r25
    b502:	87 95       	ror	r24
    b504:	97 f9       	bld	r25, 7
    b506:	08 95       	ret
    b508:	e1 e0       	ldi	r30, 0x01	; 1
    b50a:	66 0f       	add	r22, r22
    b50c:	77 1f       	adc	r23, r23
    b50e:	88 1f       	adc	r24, r24
    b510:	bb 1f       	adc	r27, r27
    b512:	62 17       	cp	r22, r18
    b514:	73 07       	cpc	r23, r19
    b516:	84 07       	cpc	r24, r20
    b518:	ba 07       	cpc	r27, r26
    b51a:	20 f0       	brcs	.+8      	; 0xb524 <__divsf3_pse+0xaa>
    b51c:	62 1b       	sub	r22, r18
    b51e:	73 0b       	sbc	r23, r19
    b520:	84 0b       	sbc	r24, r20
    b522:	ba 0b       	sbc	r27, r26
    b524:	ee 1f       	adc	r30, r30
    b526:	88 f7       	brcc	.-30     	; 0xb50a <__divsf3_pse+0x90>
    b528:	e0 95       	com	r30
    b52a:	08 95       	ret

0000b52c <__fixunssfsi>:
    b52c:	7f d0       	rcall	.+254    	; 0xb62c <__fp_splitA>
    b52e:	88 f0       	brcs	.+34     	; 0xb552 <__fixunssfsi+0x26>
    b530:	9f 57       	subi	r25, 0x7F	; 127
    b532:	90 f0       	brcs	.+36     	; 0xb558 <__fixunssfsi+0x2c>
    b534:	b9 2f       	mov	r27, r25
    b536:	99 27       	eor	r25, r25
    b538:	b7 51       	subi	r27, 0x17	; 23
    b53a:	a0 f0       	brcs	.+40     	; 0xb564 <__fixunssfsi+0x38>
    b53c:	d1 f0       	breq	.+52     	; 0xb572 <__fixunssfsi+0x46>
    b53e:	66 0f       	add	r22, r22
    b540:	77 1f       	adc	r23, r23
    b542:	88 1f       	adc	r24, r24
    b544:	99 1f       	adc	r25, r25
    b546:	1a f0       	brmi	.+6      	; 0xb54e <__fixunssfsi+0x22>
    b548:	ba 95       	dec	r27
    b54a:	c9 f7       	brne	.-14     	; 0xb53e <__fixunssfsi+0x12>
    b54c:	12 c0       	rjmp	.+36     	; 0xb572 <__fixunssfsi+0x46>
    b54e:	b1 30       	cpi	r27, 0x01	; 1
    b550:	81 f0       	breq	.+32     	; 0xb572 <__fixunssfsi+0x46>
    b552:	86 d0       	rcall	.+268    	; 0xb660 <__fp_zero>
    b554:	b1 e0       	ldi	r27, 0x01	; 1
    b556:	08 95       	ret
    b558:	83 c0       	rjmp	.+262    	; 0xb660 <__fp_zero>
    b55a:	67 2f       	mov	r22, r23
    b55c:	78 2f       	mov	r23, r24
    b55e:	88 27       	eor	r24, r24
    b560:	b8 5f       	subi	r27, 0xF8	; 248
    b562:	39 f0       	breq	.+14     	; 0xb572 <__fixunssfsi+0x46>
    b564:	b9 3f       	cpi	r27, 0xF9	; 249
    b566:	cc f3       	brlt	.-14     	; 0xb55a <__fixunssfsi+0x2e>
    b568:	86 95       	lsr	r24
    b56a:	77 95       	ror	r23
    b56c:	67 95       	ror	r22
    b56e:	b3 95       	inc	r27
    b570:	d9 f7       	brne	.-10     	; 0xb568 <__fixunssfsi+0x3c>
    b572:	3e f4       	brtc	.+14     	; 0xb582 <__fixunssfsi+0x56>
    b574:	90 95       	com	r25
    b576:	80 95       	com	r24
    b578:	70 95       	com	r23
    b57a:	61 95       	neg	r22
    b57c:	7f 4f       	sbci	r23, 0xFF	; 255
    b57e:	8f 4f       	sbci	r24, 0xFF	; 255
    b580:	9f 4f       	sbci	r25, 0xFF	; 255
    b582:	08 95       	ret

0000b584 <__fp_cmp>:
    b584:	99 0f       	add	r25, r25
    b586:	00 08       	sbc	r0, r0
    b588:	55 0f       	add	r21, r21
    b58a:	aa 0b       	sbc	r26, r26
    b58c:	e0 e8       	ldi	r30, 0x80	; 128
    b58e:	fe ef       	ldi	r31, 0xFE	; 254
    b590:	16 16       	cp	r1, r22
    b592:	17 06       	cpc	r1, r23
    b594:	e8 07       	cpc	r30, r24
    b596:	f9 07       	cpc	r31, r25
    b598:	c0 f0       	brcs	.+48     	; 0xb5ca <__fp_cmp+0x46>
    b59a:	12 16       	cp	r1, r18
    b59c:	13 06       	cpc	r1, r19
    b59e:	e4 07       	cpc	r30, r20
    b5a0:	f5 07       	cpc	r31, r21
    b5a2:	98 f0       	brcs	.+38     	; 0xb5ca <__fp_cmp+0x46>
    b5a4:	62 1b       	sub	r22, r18
    b5a6:	73 0b       	sbc	r23, r19
    b5a8:	84 0b       	sbc	r24, r20
    b5aa:	95 0b       	sbc	r25, r21
    b5ac:	39 f4       	brne	.+14     	; 0xb5bc <__fp_cmp+0x38>
    b5ae:	0a 26       	eor	r0, r26
    b5b0:	61 f0       	breq	.+24     	; 0xb5ca <__fp_cmp+0x46>
    b5b2:	23 2b       	or	r18, r19
    b5b4:	24 2b       	or	r18, r20
    b5b6:	25 2b       	or	r18, r21
    b5b8:	21 f4       	brne	.+8      	; 0xb5c2 <__fp_cmp+0x3e>
    b5ba:	08 95       	ret
    b5bc:	0a 26       	eor	r0, r26
    b5be:	09 f4       	brne	.+2      	; 0xb5c2 <__fp_cmp+0x3e>
    b5c0:	a1 40       	sbci	r26, 0x01	; 1
    b5c2:	a6 95       	lsr	r26
    b5c4:	8f ef       	ldi	r24, 0xFF	; 255
    b5c6:	81 1d       	adc	r24, r1
    b5c8:	81 1d       	adc	r24, r1
    b5ca:	08 95       	ret

0000b5cc <__fp_inf>:
    b5cc:	97 f9       	bld	r25, 7
    b5ce:	9f 67       	ori	r25, 0x7F	; 127
    b5d0:	80 e8       	ldi	r24, 0x80	; 128
    b5d2:	70 e0       	ldi	r23, 0x00	; 0
    b5d4:	60 e0       	ldi	r22, 0x00	; 0
    b5d6:	08 95       	ret

0000b5d8 <__fp_nan>:
    b5d8:	9f ef       	ldi	r25, 0xFF	; 255
    b5da:	80 ec       	ldi	r24, 0xC0	; 192
    b5dc:	08 95       	ret

0000b5de <__fp_pscA>:
    b5de:	00 24       	eor	r0, r0
    b5e0:	0a 94       	dec	r0
    b5e2:	16 16       	cp	r1, r22
    b5e4:	17 06       	cpc	r1, r23
    b5e6:	18 06       	cpc	r1, r24
    b5e8:	09 06       	cpc	r0, r25
    b5ea:	08 95       	ret

0000b5ec <__fp_pscB>:
    b5ec:	00 24       	eor	r0, r0
    b5ee:	0a 94       	dec	r0
    b5f0:	12 16       	cp	r1, r18
    b5f2:	13 06       	cpc	r1, r19
    b5f4:	14 06       	cpc	r1, r20
    b5f6:	05 06       	cpc	r0, r21
    b5f8:	08 95       	ret

0000b5fa <__fp_round>:
    b5fa:	09 2e       	mov	r0, r25
    b5fc:	03 94       	inc	r0
    b5fe:	00 0c       	add	r0, r0
    b600:	11 f4       	brne	.+4      	; 0xb606 <__fp_round+0xc>
    b602:	88 23       	and	r24, r24
    b604:	52 f0       	brmi	.+20     	; 0xb61a <__fp_round+0x20>
    b606:	bb 0f       	add	r27, r27
    b608:	40 f4       	brcc	.+16     	; 0xb61a <__fp_round+0x20>
    b60a:	bf 2b       	or	r27, r31
    b60c:	11 f4       	brne	.+4      	; 0xb612 <__fp_round+0x18>
    b60e:	60 ff       	sbrs	r22, 0
    b610:	04 c0       	rjmp	.+8      	; 0xb61a <__fp_round+0x20>
    b612:	6f 5f       	subi	r22, 0xFF	; 255
    b614:	7f 4f       	sbci	r23, 0xFF	; 255
    b616:	8f 4f       	sbci	r24, 0xFF	; 255
    b618:	9f 4f       	sbci	r25, 0xFF	; 255
    b61a:	08 95       	ret

0000b61c <__fp_split3>:
    b61c:	57 fd       	sbrc	r21, 7
    b61e:	90 58       	subi	r25, 0x80	; 128
    b620:	44 0f       	add	r20, r20
    b622:	55 1f       	adc	r21, r21
    b624:	59 f0       	breq	.+22     	; 0xb63c <__fp_splitA+0x10>
    b626:	5f 3f       	cpi	r21, 0xFF	; 255
    b628:	71 f0       	breq	.+28     	; 0xb646 <__fp_splitA+0x1a>
    b62a:	47 95       	ror	r20

0000b62c <__fp_splitA>:
    b62c:	88 0f       	add	r24, r24
    b62e:	97 fb       	bst	r25, 7
    b630:	99 1f       	adc	r25, r25
    b632:	61 f0       	breq	.+24     	; 0xb64c <__fp_splitA+0x20>
    b634:	9f 3f       	cpi	r25, 0xFF	; 255
    b636:	79 f0       	breq	.+30     	; 0xb656 <__fp_splitA+0x2a>
    b638:	87 95       	ror	r24
    b63a:	08 95       	ret
    b63c:	12 16       	cp	r1, r18
    b63e:	13 06       	cpc	r1, r19
    b640:	14 06       	cpc	r1, r20
    b642:	55 1f       	adc	r21, r21
    b644:	f2 cf       	rjmp	.-28     	; 0xb62a <__fp_split3+0xe>
    b646:	46 95       	lsr	r20
    b648:	f1 df       	rcall	.-30     	; 0xb62c <__fp_splitA>
    b64a:	08 c0       	rjmp	.+16     	; 0xb65c <__fp_splitA+0x30>
    b64c:	16 16       	cp	r1, r22
    b64e:	17 06       	cpc	r1, r23
    b650:	18 06       	cpc	r1, r24
    b652:	99 1f       	adc	r25, r25
    b654:	f1 cf       	rjmp	.-30     	; 0xb638 <__fp_splitA+0xc>
    b656:	86 95       	lsr	r24
    b658:	71 05       	cpc	r23, r1
    b65a:	61 05       	cpc	r22, r1
    b65c:	08 94       	sec
    b65e:	08 95       	ret

0000b660 <__fp_zero>:
    b660:	e8 94       	clt

0000b662 <__fp_szero>:
    b662:	bb 27       	eor	r27, r27
    b664:	66 27       	eor	r22, r22
    b666:	77 27       	eor	r23, r23
    b668:	cb 01       	movw	r24, r22
    b66a:	97 f9       	bld	r25, 7
    b66c:	08 95       	ret

0000b66e <__gesf2>:
    b66e:	8a df       	rcall	.-236    	; 0xb584 <__fp_cmp>
    b670:	08 f4       	brcc	.+2      	; 0xb674 <__gesf2+0x6>
    b672:	8f ef       	ldi	r24, 0xFF	; 255
    b674:	08 95       	ret

0000b676 <__mulsf3>:
    b676:	0b d0       	rcall	.+22     	; 0xb68e <__mulsf3x>
    b678:	c0 cf       	rjmp	.-128    	; 0xb5fa <__fp_round>
    b67a:	b1 df       	rcall	.-158    	; 0xb5de <__fp_pscA>
    b67c:	28 f0       	brcs	.+10     	; 0xb688 <__mulsf3+0x12>
    b67e:	b6 df       	rcall	.-148    	; 0xb5ec <__fp_pscB>
    b680:	18 f0       	brcs	.+6      	; 0xb688 <__mulsf3+0x12>
    b682:	95 23       	and	r25, r21
    b684:	09 f0       	breq	.+2      	; 0xb688 <__mulsf3+0x12>
    b686:	a2 cf       	rjmp	.-188    	; 0xb5cc <__fp_inf>
    b688:	a7 cf       	rjmp	.-178    	; 0xb5d8 <__fp_nan>
    b68a:	11 24       	eor	r1, r1
    b68c:	ea cf       	rjmp	.-44     	; 0xb662 <__fp_szero>

0000b68e <__mulsf3x>:
    b68e:	c6 df       	rcall	.-116    	; 0xb61c <__fp_split3>
    b690:	a0 f3       	brcs	.-24     	; 0xb67a <__mulsf3+0x4>

0000b692 <__mulsf3_pse>:
    b692:	95 9f       	mul	r25, r21
    b694:	d1 f3       	breq	.-12     	; 0xb68a <__mulsf3+0x14>
    b696:	95 0f       	add	r25, r21
    b698:	50 e0       	ldi	r21, 0x00	; 0
    b69a:	55 1f       	adc	r21, r21
    b69c:	62 9f       	mul	r22, r18
    b69e:	f0 01       	movw	r30, r0
    b6a0:	72 9f       	mul	r23, r18
    b6a2:	bb 27       	eor	r27, r27
    b6a4:	f0 0d       	add	r31, r0
    b6a6:	b1 1d       	adc	r27, r1
    b6a8:	63 9f       	mul	r22, r19
    b6aa:	aa 27       	eor	r26, r26
    b6ac:	f0 0d       	add	r31, r0
    b6ae:	b1 1d       	adc	r27, r1
    b6b0:	aa 1f       	adc	r26, r26
    b6b2:	64 9f       	mul	r22, r20
    b6b4:	66 27       	eor	r22, r22
    b6b6:	b0 0d       	add	r27, r0
    b6b8:	a1 1d       	adc	r26, r1
    b6ba:	66 1f       	adc	r22, r22
    b6bc:	82 9f       	mul	r24, r18
    b6be:	22 27       	eor	r18, r18
    b6c0:	b0 0d       	add	r27, r0
    b6c2:	a1 1d       	adc	r26, r1
    b6c4:	62 1f       	adc	r22, r18
    b6c6:	73 9f       	mul	r23, r19
    b6c8:	b0 0d       	add	r27, r0
    b6ca:	a1 1d       	adc	r26, r1
    b6cc:	62 1f       	adc	r22, r18
    b6ce:	83 9f       	mul	r24, r19
    b6d0:	a0 0d       	add	r26, r0
    b6d2:	61 1d       	adc	r22, r1
    b6d4:	22 1f       	adc	r18, r18
    b6d6:	74 9f       	mul	r23, r20
    b6d8:	33 27       	eor	r19, r19
    b6da:	a0 0d       	add	r26, r0
    b6dc:	61 1d       	adc	r22, r1
    b6de:	23 1f       	adc	r18, r19
    b6e0:	84 9f       	mul	r24, r20
    b6e2:	60 0d       	add	r22, r0
    b6e4:	21 1d       	adc	r18, r1
    b6e6:	82 2f       	mov	r24, r18
    b6e8:	76 2f       	mov	r23, r22
    b6ea:	6a 2f       	mov	r22, r26
    b6ec:	11 24       	eor	r1, r1
    b6ee:	9f 57       	subi	r25, 0x7F	; 127
    b6f0:	50 40       	sbci	r21, 0x00	; 0
    b6f2:	8a f0       	brmi	.+34     	; 0xb716 <__mulsf3_pse+0x84>
    b6f4:	e1 f0       	breq	.+56     	; 0xb72e <__mulsf3_pse+0x9c>
    b6f6:	88 23       	and	r24, r24
    b6f8:	4a f0       	brmi	.+18     	; 0xb70c <__mulsf3_pse+0x7a>
    b6fa:	ee 0f       	add	r30, r30
    b6fc:	ff 1f       	adc	r31, r31
    b6fe:	bb 1f       	adc	r27, r27
    b700:	66 1f       	adc	r22, r22
    b702:	77 1f       	adc	r23, r23
    b704:	88 1f       	adc	r24, r24
    b706:	91 50       	subi	r25, 0x01	; 1
    b708:	50 40       	sbci	r21, 0x00	; 0
    b70a:	a9 f7       	brne	.-22     	; 0xb6f6 <__mulsf3_pse+0x64>
    b70c:	9e 3f       	cpi	r25, 0xFE	; 254
    b70e:	51 05       	cpc	r21, r1
    b710:	70 f0       	brcs	.+28     	; 0xb72e <__mulsf3_pse+0x9c>
    b712:	5c cf       	rjmp	.-328    	; 0xb5cc <__fp_inf>
    b714:	a6 cf       	rjmp	.-180    	; 0xb662 <__fp_szero>
    b716:	5f 3f       	cpi	r21, 0xFF	; 255
    b718:	ec f3       	brlt	.-6      	; 0xb714 <__mulsf3_pse+0x82>
    b71a:	98 3e       	cpi	r25, 0xE8	; 232
    b71c:	dc f3       	brlt	.-10     	; 0xb714 <__mulsf3_pse+0x82>
    b71e:	86 95       	lsr	r24
    b720:	77 95       	ror	r23
    b722:	67 95       	ror	r22
    b724:	b7 95       	ror	r27
    b726:	f7 95       	ror	r31
    b728:	e7 95       	ror	r30
    b72a:	9f 5f       	subi	r25, 0xFF	; 255
    b72c:	c1 f7       	brne	.-16     	; 0xb71e <__mulsf3_pse+0x8c>
    b72e:	fe 2b       	or	r31, r30
    b730:	88 0f       	add	r24, r24
    b732:	91 1d       	adc	r25, r1
    b734:	96 95       	lsr	r25
    b736:	87 95       	ror	r24
    b738:	97 f9       	bld	r25, 7
    b73a:	08 95       	ret

0000b73c <__mulsi3>:
    b73c:	62 9f       	mul	r22, r18
    b73e:	d0 01       	movw	r26, r0
    b740:	73 9f       	mul	r23, r19
    b742:	f0 01       	movw	r30, r0
    b744:	82 9f       	mul	r24, r18
    b746:	e0 0d       	add	r30, r0
    b748:	f1 1d       	adc	r31, r1
    b74a:	64 9f       	mul	r22, r20
    b74c:	e0 0d       	add	r30, r0
    b74e:	f1 1d       	adc	r31, r1
    b750:	92 9f       	mul	r25, r18
    b752:	f0 0d       	add	r31, r0
    b754:	83 9f       	mul	r24, r19
    b756:	f0 0d       	add	r31, r0
    b758:	74 9f       	mul	r23, r20
    b75a:	f0 0d       	add	r31, r0
    b75c:	65 9f       	mul	r22, r21
    b75e:	f0 0d       	add	r31, r0
    b760:	99 27       	eor	r25, r25
    b762:	72 9f       	mul	r23, r18
    b764:	b0 0d       	add	r27, r0
    b766:	e1 1d       	adc	r30, r1
    b768:	f9 1f       	adc	r31, r25
    b76a:	63 9f       	mul	r22, r19
    b76c:	b0 0d       	add	r27, r0
    b76e:	e1 1d       	adc	r30, r1
    b770:	f9 1f       	adc	r31, r25
    b772:	bd 01       	movw	r22, r26
    b774:	cf 01       	movw	r24, r30
    b776:	11 24       	eor	r1, r1
    b778:	08 95       	ret

0000b77a <__udivmodhi4>:
    b77a:	aa 1b       	sub	r26, r26
    b77c:	bb 1b       	sub	r27, r27
    b77e:	51 e1       	ldi	r21, 0x11	; 17
    b780:	07 c0       	rjmp	.+14     	; 0xb790 <__udivmodhi4_ep>

0000b782 <__udivmodhi4_loop>:
    b782:	aa 1f       	adc	r26, r26
    b784:	bb 1f       	adc	r27, r27
    b786:	a6 17       	cp	r26, r22
    b788:	b7 07       	cpc	r27, r23
    b78a:	10 f0       	brcs	.+4      	; 0xb790 <__udivmodhi4_ep>
    b78c:	a6 1b       	sub	r26, r22
    b78e:	b7 0b       	sbc	r27, r23

0000b790 <__udivmodhi4_ep>:
    b790:	88 1f       	adc	r24, r24
    b792:	99 1f       	adc	r25, r25
    b794:	5a 95       	dec	r21
    b796:	a9 f7       	brne	.-22     	; 0xb782 <__udivmodhi4_loop>
    b798:	80 95       	com	r24
    b79a:	90 95       	com	r25
    b79c:	bc 01       	movw	r22, r24
    b79e:	cd 01       	movw	r24, r26
    b7a0:	08 95       	ret

0000b7a2 <__divmodhi4>:
    b7a2:	97 fb       	bst	r25, 7
    b7a4:	09 2e       	mov	r0, r25
    b7a6:	07 26       	eor	r0, r23
    b7a8:	0a d0       	rcall	.+20     	; 0xb7be <__divmodhi4_neg1>
    b7aa:	77 fd       	sbrc	r23, 7
    b7ac:	04 d0       	rcall	.+8      	; 0xb7b6 <__divmodhi4_neg2>
    b7ae:	e5 df       	rcall	.-54     	; 0xb77a <__udivmodhi4>
    b7b0:	06 d0       	rcall	.+12     	; 0xb7be <__divmodhi4_neg1>
    b7b2:	00 20       	and	r0, r0
    b7b4:	1a f4       	brpl	.+6      	; 0xb7bc <__divmodhi4_exit>

0000b7b6 <__divmodhi4_neg2>:
    b7b6:	70 95       	com	r23
    b7b8:	61 95       	neg	r22
    b7ba:	7f 4f       	sbci	r23, 0xFF	; 255

0000b7bc <__divmodhi4_exit>:
    b7bc:	08 95       	ret

0000b7be <__divmodhi4_neg1>:
    b7be:	f6 f7       	brtc	.-4      	; 0xb7bc <__divmodhi4_exit>
    b7c0:	90 95       	com	r25
    b7c2:	81 95       	neg	r24
    b7c4:	9f 4f       	sbci	r25, 0xFF	; 255
    b7c6:	08 95       	ret

0000b7c8 <__udivmodsi4>:
    b7c8:	a1 e2       	ldi	r26, 0x21	; 33
    b7ca:	1a 2e       	mov	r1, r26
    b7cc:	aa 1b       	sub	r26, r26
    b7ce:	bb 1b       	sub	r27, r27
    b7d0:	fd 01       	movw	r30, r26
    b7d2:	0d c0       	rjmp	.+26     	; 0xb7ee <__udivmodsi4_ep>

0000b7d4 <__udivmodsi4_loop>:
    b7d4:	aa 1f       	adc	r26, r26
    b7d6:	bb 1f       	adc	r27, r27
    b7d8:	ee 1f       	adc	r30, r30
    b7da:	ff 1f       	adc	r31, r31
    b7dc:	a2 17       	cp	r26, r18
    b7de:	b3 07       	cpc	r27, r19
    b7e0:	e4 07       	cpc	r30, r20
    b7e2:	f5 07       	cpc	r31, r21
    b7e4:	20 f0       	brcs	.+8      	; 0xb7ee <__udivmodsi4_ep>
    b7e6:	a2 1b       	sub	r26, r18
    b7e8:	b3 0b       	sbc	r27, r19
    b7ea:	e4 0b       	sbc	r30, r20
    b7ec:	f5 0b       	sbc	r31, r21

0000b7ee <__udivmodsi4_ep>:
    b7ee:	66 1f       	adc	r22, r22
    b7f0:	77 1f       	adc	r23, r23
    b7f2:	88 1f       	adc	r24, r24
    b7f4:	99 1f       	adc	r25, r25
    b7f6:	1a 94       	dec	r1
    b7f8:	69 f7       	brne	.-38     	; 0xb7d4 <__udivmodsi4_loop>
    b7fa:	60 95       	com	r22
    b7fc:	70 95       	com	r23
    b7fe:	80 95       	com	r24
    b800:	90 95       	com	r25
    b802:	9b 01       	movw	r18, r22
    b804:	ac 01       	movw	r20, r24
    b806:	bd 01       	movw	r22, r26
    b808:	cf 01       	movw	r24, r30
    b80a:	08 95       	ret

0000b80c <__divmodsi4>:
    b80c:	97 fb       	bst	r25, 7
    b80e:	09 2e       	mov	r0, r25
    b810:	05 26       	eor	r0, r21
    b812:	0e d0       	rcall	.+28     	; 0xb830 <__divmodsi4_neg1>
    b814:	57 fd       	sbrc	r21, 7
    b816:	04 d0       	rcall	.+8      	; 0xb820 <__divmodsi4_neg2>
    b818:	d7 df       	rcall	.-82     	; 0xb7c8 <__udivmodsi4>
    b81a:	0a d0       	rcall	.+20     	; 0xb830 <__divmodsi4_neg1>
    b81c:	00 1c       	adc	r0, r0
    b81e:	38 f4       	brcc	.+14     	; 0xb82e <__divmodsi4_exit>

0000b820 <__divmodsi4_neg2>:
    b820:	50 95       	com	r21
    b822:	40 95       	com	r20
    b824:	30 95       	com	r19
    b826:	21 95       	neg	r18
    b828:	3f 4f       	sbci	r19, 0xFF	; 255
    b82a:	4f 4f       	sbci	r20, 0xFF	; 255
    b82c:	5f 4f       	sbci	r21, 0xFF	; 255

0000b82e <__divmodsi4_exit>:
    b82e:	08 95       	ret

0000b830 <__divmodsi4_neg1>:
    b830:	f6 f7       	brtc	.-4      	; 0xb82e <__divmodsi4_exit>
    b832:	90 95       	com	r25
    b834:	80 95       	com	r24
    b836:	70 95       	com	r23
    b838:	61 95       	neg	r22
    b83a:	7f 4f       	sbci	r23, 0xFF	; 255
    b83c:	8f 4f       	sbci	r24, 0xFF	; 255
    b83e:	9f 4f       	sbci	r25, 0xFF	; 255
    b840:	08 95       	ret

0000b842 <__prologue_saves__>:
    b842:	2f 92       	push	r2
    b844:	3f 92       	push	r3
    b846:	4f 92       	push	r4
    b848:	5f 92       	push	r5
    b84a:	6f 92       	push	r6
    b84c:	7f 92       	push	r7
    b84e:	8f 92       	push	r8
    b850:	9f 92       	push	r9
    b852:	af 92       	push	r10
    b854:	bf 92       	push	r11
    b856:	cf 92       	push	r12
    b858:	df 92       	push	r13
    b85a:	ef 92       	push	r14
    b85c:	ff 92       	push	r15
    b85e:	0f 93       	push	r16
    b860:	1f 93       	push	r17
    b862:	cf 93       	push	r28
    b864:	df 93       	push	r29
    b866:	cd b7       	in	r28, 0x3d	; 61
    b868:	de b7       	in	r29, 0x3e	; 62
    b86a:	ca 1b       	sub	r28, r26
    b86c:	db 0b       	sbc	r29, r27
    b86e:	cd bf       	out	0x3d, r28	; 61
    b870:	de bf       	out	0x3e, r29	; 62
    b872:	19 94       	eijmp

0000b874 <__epilogue_restores__>:
    b874:	2a 88       	ldd	r2, Y+18	; 0x12
    b876:	39 88       	ldd	r3, Y+17	; 0x11
    b878:	48 88       	ldd	r4, Y+16	; 0x10
    b87a:	5f 84       	ldd	r5, Y+15	; 0x0f
    b87c:	6e 84       	ldd	r6, Y+14	; 0x0e
    b87e:	7d 84       	ldd	r7, Y+13	; 0x0d
    b880:	8c 84       	ldd	r8, Y+12	; 0x0c
    b882:	9b 84       	ldd	r9, Y+11	; 0x0b
    b884:	aa 84       	ldd	r10, Y+10	; 0x0a
    b886:	b9 84       	ldd	r11, Y+9	; 0x09
    b888:	c8 84       	ldd	r12, Y+8	; 0x08
    b88a:	df 80       	ldd	r13, Y+7	; 0x07
    b88c:	ee 80       	ldd	r14, Y+6	; 0x06
    b88e:	fd 80       	ldd	r15, Y+5	; 0x05
    b890:	0c 81       	ldd	r16, Y+4	; 0x04
    b892:	1b 81       	ldd	r17, Y+3	; 0x03
    b894:	aa 81       	ldd	r26, Y+2	; 0x02
    b896:	b9 81       	ldd	r27, Y+1	; 0x01
    b898:	ce 0f       	add	r28, r30
    b89a:	d1 1d       	adc	r29, r1
    b89c:	cd bf       	out	0x3d, r28	; 61
    b89e:	de bf       	out	0x3e, r29	; 62
    b8a0:	ed 01       	movw	r28, r26
    b8a2:	08 95       	ret

0000b8a4 <strcpy_P>:
    b8a4:	fb 01       	movw	r30, r22
    b8a6:	dc 01       	movw	r26, r24
    b8a8:	05 90       	lpm	r0, Z+
    b8aa:	0d 92       	st	X+, r0
    b8ac:	00 20       	and	r0, r0
    b8ae:	e1 f7       	brne	.-8      	; 0xb8a8 <strcpy_P+0x4>
    b8b0:	08 95       	ret

0000b8b2 <memmove>:
    b8b2:	68 17       	cp	r22, r24
    b8b4:	79 07       	cpc	r23, r25
    b8b6:	68 f4       	brcc	.+26     	; 0xb8d2 <memmove+0x20>
    b8b8:	fb 01       	movw	r30, r22
    b8ba:	dc 01       	movw	r26, r24
    b8bc:	e4 0f       	add	r30, r20
    b8be:	f5 1f       	adc	r31, r21
    b8c0:	a4 0f       	add	r26, r20
    b8c2:	b5 1f       	adc	r27, r21
    b8c4:	02 c0       	rjmp	.+4      	; 0xb8ca <memmove+0x18>
    b8c6:	02 90       	ld	r0, -Z
    b8c8:	0e 92       	st	-X, r0
    b8ca:	41 50       	subi	r20, 0x01	; 1
    b8cc:	50 40       	sbci	r21, 0x00	; 0
    b8ce:	d8 f7       	brcc	.-10     	; 0xb8c6 <memmove+0x14>
    b8d0:	08 95       	ret
    b8d2:	0c 94 ec 5e 	jmp	0xbdd8	; 0xbdd8 <memcpy>

0000b8d6 <strcat>:
    b8d6:	fb 01       	movw	r30, r22
    b8d8:	dc 01       	movw	r26, r24
    b8da:	0d 90       	ld	r0, X+
    b8dc:	00 20       	and	r0, r0
    b8de:	e9 f7       	brne	.-6      	; 0xb8da <strcat+0x4>
    b8e0:	11 97       	sbiw	r26, 0x01	; 1
    b8e2:	01 90       	ld	r0, Z+
    b8e4:	0d 92       	st	X+, r0
    b8e6:	00 20       	and	r0, r0
    b8e8:	e1 f7       	brne	.-8      	; 0xb8e2 <strcat+0xc>
    b8ea:	08 95       	ret

0000b8ec <strncmp>:
    b8ec:	fb 01       	movw	r30, r22
    b8ee:	dc 01       	movw	r26, r24
    b8f0:	41 50       	subi	r20, 0x01	; 1
    b8f2:	50 40       	sbci	r21, 0x00	; 0
    b8f4:	30 f0       	brcs	.+12     	; 0xb902 <strncmp+0x16>
    b8f6:	8d 91       	ld	r24, X+
    b8f8:	01 90       	ld	r0, Z+
    b8fa:	80 19       	sub	r24, r0
    b8fc:	19 f4       	brne	.+6      	; 0xb904 <strncmp+0x18>
    b8fe:	00 20       	and	r0, r0
    b900:	b9 f7       	brne	.-18     	; 0xb8f0 <strncmp+0x4>
    b902:	88 1b       	sub	r24, r24
    b904:	99 0b       	sbc	r25, r25
    b906:	08 95       	ret

0000b908 <itoa>:
    b908:	fb 01       	movw	r30, r22
    b90a:	9f 01       	movw	r18, r30
    b90c:	e8 94       	clt
    b90e:	42 30       	cpi	r20, 0x02	; 2
    b910:	c4 f0       	brlt	.+48     	; 0xb942 <itoa+0x3a>
    b912:	45 32       	cpi	r20, 0x25	; 37
    b914:	b4 f4       	brge	.+44     	; 0xb942 <itoa+0x3a>
    b916:	4a 30       	cpi	r20, 0x0A	; 10
    b918:	29 f4       	brne	.+10     	; 0xb924 <itoa+0x1c>
    b91a:	97 fb       	bst	r25, 7
    b91c:	1e f4       	brtc	.+6      	; 0xb924 <itoa+0x1c>
    b91e:	90 95       	com	r25
    b920:	81 95       	neg	r24
    b922:	9f 4f       	sbci	r25, 0xFF	; 255
    b924:	64 2f       	mov	r22, r20
    b926:	77 27       	eor	r23, r23
    b928:	0e 94 bd 5b 	call	0xb77a	; 0xb77a <__udivmodhi4>
    b92c:	80 5d       	subi	r24, 0xD0	; 208
    b92e:	8a 33       	cpi	r24, 0x3A	; 58
    b930:	0c f0       	brlt	.+2      	; 0xb934 <itoa+0x2c>
    b932:	89 5d       	subi	r24, 0xD9	; 217
    b934:	81 93       	st	Z+, r24
    b936:	cb 01       	movw	r24, r22
    b938:	00 97       	sbiw	r24, 0x00	; 0
    b93a:	a1 f7       	brne	.-24     	; 0xb924 <itoa+0x1c>
    b93c:	16 f4       	brtc	.+4      	; 0xb942 <itoa+0x3a>
    b93e:	5d e2       	ldi	r21, 0x2D	; 45
    b940:	51 93       	st	Z+, r21
    b942:	10 82       	st	Z, r1
    b944:	c9 01       	movw	r24, r18
    b946:	0c 94 00 5f 	jmp	0xbe00	; 0xbe00 <strrev>

0000b94a <printf>:
    b94a:	cf 93       	push	r28
    b94c:	df 93       	push	r29
    b94e:	cd b7       	in	r28, 0x3d	; 61
    b950:	de b7       	in	r29, 0x3e	; 62
    b952:	fe 01       	movw	r30, r28
    b954:	36 96       	adiw	r30, 0x06	; 6
    b956:	61 91       	ld	r22, Z+
    b958:	71 91       	ld	r23, Z+
    b95a:	80 91 d1 50 	lds	r24, 0x50D1
    b95e:	90 91 d2 50 	lds	r25, 0x50D2
    b962:	af 01       	movw	r20, r30
    b964:	0e 94 e0 5c 	call	0xb9c0	; 0xb9c0 <vfprintf>
    b968:	df 91       	pop	r29
    b96a:	cf 91       	pop	r28
    b96c:	08 95       	ret

0000b96e <sprintf>:
    b96e:	0f 93       	push	r16
    b970:	1f 93       	push	r17
    b972:	cf 93       	push	r28
    b974:	df 93       	push	r29
    b976:	cd b7       	in	r28, 0x3d	; 61
    b978:	de b7       	in	r29, 0x3e	; 62
    b97a:	2e 97       	sbiw	r28, 0x0e	; 14
    b97c:	cd bf       	out	0x3d, r28	; 61
    b97e:	de bf       	out	0x3e, r29	; 62
    b980:	0e 89       	ldd	r16, Y+22	; 0x16
    b982:	1f 89       	ldd	r17, Y+23	; 0x17
    b984:	86 e0       	ldi	r24, 0x06	; 6
    b986:	8c 83       	std	Y+4, r24	; 0x04
    b988:	09 83       	std	Y+1, r16	; 0x01
    b98a:	1a 83       	std	Y+2, r17	; 0x02
    b98c:	8f ef       	ldi	r24, 0xFF	; 255
    b98e:	9f e7       	ldi	r25, 0x7F	; 127
    b990:	8d 83       	std	Y+5, r24	; 0x05
    b992:	9e 83       	std	Y+6, r25	; 0x06
    b994:	ae 01       	movw	r20, r28
    b996:	46 5e       	subi	r20, 0xE6	; 230
    b998:	5f 4f       	sbci	r21, 0xFF	; 255
    b99a:	ce 01       	movw	r24, r28
    b99c:	01 96       	adiw	r24, 0x01	; 1
    b99e:	68 8d       	ldd	r22, Y+24	; 0x18
    b9a0:	79 8d       	ldd	r23, Y+25	; 0x19
    b9a2:	0e 94 e0 5c 	call	0xb9c0	; 0xb9c0 <vfprintf>
    b9a6:	ef 81       	ldd	r30, Y+7	; 0x07
    b9a8:	f8 85       	ldd	r31, Y+8	; 0x08
    b9aa:	e0 0f       	add	r30, r16
    b9ac:	f1 1f       	adc	r31, r17
    b9ae:	10 82       	st	Z, r1
    b9b0:	2e 96       	adiw	r28, 0x0e	; 14
    b9b2:	cd bf       	out	0x3d, r28	; 61
    b9b4:	de bf       	out	0x3e, r29	; 62
    b9b6:	df 91       	pop	r29
    b9b8:	cf 91       	pop	r28
    b9ba:	1f 91       	pop	r17
    b9bc:	0f 91       	pop	r16
    b9be:	08 95       	ret

0000b9c0 <vfprintf>:
    b9c0:	2f 92       	push	r2
    b9c2:	3f 92       	push	r3
    b9c4:	4f 92       	push	r4
    b9c6:	5f 92       	push	r5
    b9c8:	6f 92       	push	r6
    b9ca:	7f 92       	push	r7
    b9cc:	8f 92       	push	r8
    b9ce:	9f 92       	push	r9
    b9d0:	af 92       	push	r10
    b9d2:	bf 92       	push	r11
    b9d4:	cf 92       	push	r12
    b9d6:	df 92       	push	r13
    b9d8:	ef 92       	push	r14
    b9da:	ff 92       	push	r15
    b9dc:	0f 93       	push	r16
    b9de:	1f 93       	push	r17
    b9e0:	cf 93       	push	r28
    b9e2:	df 93       	push	r29
    b9e4:	cd b7       	in	r28, 0x3d	; 61
    b9e6:	de b7       	in	r29, 0x3e	; 62
    b9e8:	2d 97       	sbiw	r28, 0x0d	; 13
    b9ea:	cd bf       	out	0x3d, r28	; 61
    b9ec:	de bf       	out	0x3e, r29	; 62
    b9ee:	3c 01       	movw	r6, r24
    b9f0:	6c 87       	std	Y+12, r22	; 0x0c
    b9f2:	7d 87       	std	Y+13, r23	; 0x0d
    b9f4:	5a 01       	movw	r10, r20
    b9f6:	fc 01       	movw	r30, r24
    b9f8:	16 82       	std	Z+6, r1	; 0x06
    b9fa:	17 82       	std	Z+7, r1	; 0x07
    b9fc:	83 81       	ldd	r24, Z+3	; 0x03
    b9fe:	81 ff       	sbrs	r24, 1
    ba00:	c8 c1       	rjmp	.+912    	; 0xbd92 <vfprintf+0x3d2>
    ba02:	2e 01       	movw	r4, r28
    ba04:	08 94       	sec
    ba06:	41 1c       	adc	r4, r1
    ba08:	51 1c       	adc	r5, r1
    ba0a:	f3 01       	movw	r30, r6
    ba0c:	93 81       	ldd	r25, Z+3	; 0x03
    ba0e:	ec 85       	ldd	r30, Y+12	; 0x0c
    ba10:	fd 85       	ldd	r31, Y+13	; 0x0d
    ba12:	93 fd       	sbrc	r25, 3
    ba14:	85 91       	lpm	r24, Z+
    ba16:	93 ff       	sbrs	r25, 3
    ba18:	81 91       	ld	r24, Z+
    ba1a:	ec 87       	std	Y+12, r30	; 0x0c
    ba1c:	fd 87       	std	Y+13, r31	; 0x0d
    ba1e:	88 23       	and	r24, r24
    ba20:	09 f4       	brne	.+2      	; 0xba24 <vfprintf+0x64>
    ba22:	b3 c1       	rjmp	.+870    	; 0xbd8a <vfprintf+0x3ca>
    ba24:	85 32       	cpi	r24, 0x25	; 37
    ba26:	41 f4       	brne	.+16     	; 0xba38 <vfprintf+0x78>
    ba28:	93 fd       	sbrc	r25, 3
    ba2a:	85 91       	lpm	r24, Z+
    ba2c:	93 ff       	sbrs	r25, 3
    ba2e:	81 91       	ld	r24, Z+
    ba30:	ec 87       	std	Y+12, r30	; 0x0c
    ba32:	fd 87       	std	Y+13, r31	; 0x0d
    ba34:	85 32       	cpi	r24, 0x25	; 37
    ba36:	29 f4       	brne	.+10     	; 0xba42 <vfprintf+0x82>
    ba38:	90 e0       	ldi	r25, 0x00	; 0
    ba3a:	b3 01       	movw	r22, r6
    ba3c:	0e 94 10 5f 	call	0xbe20	; 0xbe20 <fputc>
    ba40:	e4 cf       	rjmp	.-56     	; 0xba0a <vfprintf+0x4a>
    ba42:	ff 24       	eor	r15, r15
    ba44:	ee 24       	eor	r14, r14
    ba46:	10 e0       	ldi	r17, 0x00	; 0
    ba48:	10 32       	cpi	r17, 0x20	; 32
    ba4a:	b0 f4       	brcc	.+44     	; 0xba78 <vfprintf+0xb8>
    ba4c:	8b 32       	cpi	r24, 0x2B	; 43
    ba4e:	69 f0       	breq	.+26     	; 0xba6a <vfprintf+0xaa>
    ba50:	8c 32       	cpi	r24, 0x2C	; 44
    ba52:	28 f4       	brcc	.+10     	; 0xba5e <vfprintf+0x9e>
    ba54:	80 32       	cpi	r24, 0x20	; 32
    ba56:	51 f0       	breq	.+20     	; 0xba6c <vfprintf+0xac>
    ba58:	83 32       	cpi	r24, 0x23	; 35
    ba5a:	71 f4       	brne	.+28     	; 0xba78 <vfprintf+0xb8>
    ba5c:	0b c0       	rjmp	.+22     	; 0xba74 <vfprintf+0xb4>
    ba5e:	8d 32       	cpi	r24, 0x2D	; 45
    ba60:	39 f0       	breq	.+14     	; 0xba70 <vfprintf+0xb0>
    ba62:	80 33       	cpi	r24, 0x30	; 48
    ba64:	49 f4       	brne	.+18     	; 0xba78 <vfprintf+0xb8>
    ba66:	11 60       	ori	r17, 0x01	; 1
    ba68:	2c c0       	rjmp	.+88     	; 0xbac2 <vfprintf+0x102>
    ba6a:	12 60       	ori	r17, 0x02	; 2
    ba6c:	14 60       	ori	r17, 0x04	; 4
    ba6e:	29 c0       	rjmp	.+82     	; 0xbac2 <vfprintf+0x102>
    ba70:	18 60       	ori	r17, 0x08	; 8
    ba72:	27 c0       	rjmp	.+78     	; 0xbac2 <vfprintf+0x102>
    ba74:	10 61       	ori	r17, 0x10	; 16
    ba76:	25 c0       	rjmp	.+74     	; 0xbac2 <vfprintf+0x102>
    ba78:	17 fd       	sbrc	r17, 7
    ba7a:	2e c0       	rjmp	.+92     	; 0xbad8 <vfprintf+0x118>
    ba7c:	28 2f       	mov	r18, r24
    ba7e:	20 53       	subi	r18, 0x30	; 48
    ba80:	2a 30       	cpi	r18, 0x0A	; 10
    ba82:	98 f4       	brcc	.+38     	; 0xbaaa <vfprintf+0xea>
    ba84:	16 ff       	sbrs	r17, 6
    ba86:	08 c0       	rjmp	.+16     	; 0xba98 <vfprintf+0xd8>
    ba88:	8f 2d       	mov	r24, r15
    ba8a:	88 0f       	add	r24, r24
    ba8c:	f8 2e       	mov	r15, r24
    ba8e:	ff 0c       	add	r15, r15
    ba90:	ff 0c       	add	r15, r15
    ba92:	f8 0e       	add	r15, r24
    ba94:	f2 0e       	add	r15, r18
    ba96:	15 c0       	rjmp	.+42     	; 0xbac2 <vfprintf+0x102>
    ba98:	8e 2d       	mov	r24, r14
    ba9a:	88 0f       	add	r24, r24
    ba9c:	e8 2e       	mov	r14, r24
    ba9e:	ee 0c       	add	r14, r14
    baa0:	ee 0c       	add	r14, r14
    baa2:	e8 0e       	add	r14, r24
    baa4:	e2 0e       	add	r14, r18
    baa6:	10 62       	ori	r17, 0x20	; 32
    baa8:	0c c0       	rjmp	.+24     	; 0xbac2 <vfprintf+0x102>
    baaa:	8e 32       	cpi	r24, 0x2E	; 46
    baac:	21 f4       	brne	.+8      	; 0xbab6 <vfprintf+0xf6>
    baae:	16 fd       	sbrc	r17, 6
    bab0:	6c c1       	rjmp	.+728    	; 0xbd8a <vfprintf+0x3ca>
    bab2:	10 64       	ori	r17, 0x40	; 64
    bab4:	06 c0       	rjmp	.+12     	; 0xbac2 <vfprintf+0x102>
    bab6:	8c 36       	cpi	r24, 0x6C	; 108
    bab8:	11 f4       	brne	.+4      	; 0xbabe <vfprintf+0xfe>
    baba:	10 68       	ori	r17, 0x80	; 128
    babc:	02 c0       	rjmp	.+4      	; 0xbac2 <vfprintf+0x102>
    babe:	88 36       	cpi	r24, 0x68	; 104
    bac0:	59 f4       	brne	.+22     	; 0xbad8 <vfprintf+0x118>
    bac2:	ec 85       	ldd	r30, Y+12	; 0x0c
    bac4:	fd 85       	ldd	r31, Y+13	; 0x0d
    bac6:	93 fd       	sbrc	r25, 3
    bac8:	85 91       	lpm	r24, Z+
    baca:	93 ff       	sbrs	r25, 3
    bacc:	81 91       	ld	r24, Z+
    bace:	ec 87       	std	Y+12, r30	; 0x0c
    bad0:	fd 87       	std	Y+13, r31	; 0x0d
    bad2:	88 23       	and	r24, r24
    bad4:	09 f0       	breq	.+2      	; 0xbad8 <vfprintf+0x118>
    bad6:	b8 cf       	rjmp	.-144    	; 0xba48 <vfprintf+0x88>
    bad8:	98 2f       	mov	r25, r24
    bada:	95 54       	subi	r25, 0x45	; 69
    badc:	93 30       	cpi	r25, 0x03	; 3
    bade:	18 f0       	brcs	.+6      	; 0xbae6 <vfprintf+0x126>
    bae0:	90 52       	subi	r25, 0x20	; 32
    bae2:	93 30       	cpi	r25, 0x03	; 3
    bae4:	38 f4       	brcc	.+14     	; 0xbaf4 <vfprintf+0x134>
    bae6:	24 e0       	ldi	r18, 0x04	; 4
    bae8:	30 e0       	ldi	r19, 0x00	; 0
    baea:	a2 0e       	add	r10, r18
    baec:	b3 1e       	adc	r11, r19
    baee:	3f e3       	ldi	r19, 0x3F	; 63
    baf0:	39 83       	std	Y+1, r19	; 0x01
    baf2:	0f c0       	rjmp	.+30     	; 0xbb12 <vfprintf+0x152>
    baf4:	83 36       	cpi	r24, 0x63	; 99
    baf6:	31 f0       	breq	.+12     	; 0xbb04 <vfprintf+0x144>
    baf8:	83 37       	cpi	r24, 0x73	; 115
    bafa:	81 f0       	breq	.+32     	; 0xbb1c <vfprintf+0x15c>
    bafc:	83 35       	cpi	r24, 0x53	; 83
    bafe:	09 f0       	breq	.+2      	; 0xbb02 <vfprintf+0x142>
    bb00:	5a c0       	rjmp	.+180    	; 0xbbb6 <vfprintf+0x1f6>
    bb02:	22 c0       	rjmp	.+68     	; 0xbb48 <vfprintf+0x188>
    bb04:	f5 01       	movw	r30, r10
    bb06:	80 81       	ld	r24, Z
    bb08:	89 83       	std	Y+1, r24	; 0x01
    bb0a:	22 e0       	ldi	r18, 0x02	; 2
    bb0c:	30 e0       	ldi	r19, 0x00	; 0
    bb0e:	a2 0e       	add	r10, r18
    bb10:	b3 1e       	adc	r11, r19
    bb12:	21 e0       	ldi	r18, 0x01	; 1
    bb14:	c2 2e       	mov	r12, r18
    bb16:	d1 2c       	mov	r13, r1
    bb18:	42 01       	movw	r8, r4
    bb1a:	14 c0       	rjmp	.+40     	; 0xbb44 <vfprintf+0x184>
    bb1c:	92 e0       	ldi	r25, 0x02	; 2
    bb1e:	29 2e       	mov	r2, r25
    bb20:	31 2c       	mov	r3, r1
    bb22:	2a 0c       	add	r2, r10
    bb24:	3b 1c       	adc	r3, r11
    bb26:	f5 01       	movw	r30, r10
    bb28:	80 80       	ld	r8, Z
    bb2a:	91 80       	ldd	r9, Z+1	; 0x01
    bb2c:	16 ff       	sbrs	r17, 6
    bb2e:	03 c0       	rjmp	.+6      	; 0xbb36 <vfprintf+0x176>
    bb30:	6f 2d       	mov	r22, r15
    bb32:	70 e0       	ldi	r23, 0x00	; 0
    bb34:	02 c0       	rjmp	.+4      	; 0xbb3a <vfprintf+0x17a>
    bb36:	6f ef       	ldi	r22, 0xFF	; 255
    bb38:	7f ef       	ldi	r23, 0xFF	; 255
    bb3a:	c4 01       	movw	r24, r8
    bb3c:	0e 94 f5 5e 	call	0xbdea	; 0xbdea <strnlen>
    bb40:	6c 01       	movw	r12, r24
    bb42:	51 01       	movw	r10, r2
    bb44:	1f 77       	andi	r17, 0x7F	; 127
    bb46:	15 c0       	rjmp	.+42     	; 0xbb72 <vfprintf+0x1b2>
    bb48:	82 e0       	ldi	r24, 0x02	; 2
    bb4a:	28 2e       	mov	r2, r24
    bb4c:	31 2c       	mov	r3, r1
    bb4e:	2a 0c       	add	r2, r10
    bb50:	3b 1c       	adc	r3, r11
    bb52:	f5 01       	movw	r30, r10
    bb54:	80 80       	ld	r8, Z
    bb56:	91 80       	ldd	r9, Z+1	; 0x01
    bb58:	16 ff       	sbrs	r17, 6
    bb5a:	03 c0       	rjmp	.+6      	; 0xbb62 <vfprintf+0x1a2>
    bb5c:	6f 2d       	mov	r22, r15
    bb5e:	70 e0       	ldi	r23, 0x00	; 0
    bb60:	02 c0       	rjmp	.+4      	; 0xbb66 <vfprintf+0x1a6>
    bb62:	6f ef       	ldi	r22, 0xFF	; 255
    bb64:	7f ef       	ldi	r23, 0xFF	; 255
    bb66:	c4 01       	movw	r24, r8
    bb68:	0e 94 e1 5e 	call	0xbdc2	; 0xbdc2 <strnlen_P>
    bb6c:	6c 01       	movw	r12, r24
    bb6e:	10 68       	ori	r17, 0x80	; 128
    bb70:	51 01       	movw	r10, r2
    bb72:	13 fd       	sbrc	r17, 3
    bb74:	1c c0       	rjmp	.+56     	; 0xbbae <vfprintf+0x1ee>
    bb76:	06 c0       	rjmp	.+12     	; 0xbb84 <vfprintf+0x1c4>
    bb78:	80 e2       	ldi	r24, 0x20	; 32
    bb7a:	90 e0       	ldi	r25, 0x00	; 0
    bb7c:	b3 01       	movw	r22, r6
    bb7e:	0e 94 10 5f 	call	0xbe20	; 0xbe20 <fputc>
    bb82:	ea 94       	dec	r14
    bb84:	8e 2d       	mov	r24, r14
    bb86:	90 e0       	ldi	r25, 0x00	; 0
    bb88:	c8 16       	cp	r12, r24
    bb8a:	d9 06       	cpc	r13, r25
    bb8c:	a8 f3       	brcs	.-22     	; 0xbb78 <vfprintf+0x1b8>
    bb8e:	0f c0       	rjmp	.+30     	; 0xbbae <vfprintf+0x1ee>
    bb90:	f4 01       	movw	r30, r8
    bb92:	17 fd       	sbrc	r17, 7
    bb94:	85 91       	lpm	r24, Z+
    bb96:	17 ff       	sbrs	r17, 7
    bb98:	81 91       	ld	r24, Z+
    bb9a:	4f 01       	movw	r8, r30
    bb9c:	90 e0       	ldi	r25, 0x00	; 0
    bb9e:	b3 01       	movw	r22, r6
    bba0:	0e 94 10 5f 	call	0xbe20	; 0xbe20 <fputc>
    bba4:	e1 10       	cpse	r14, r1
    bba6:	ea 94       	dec	r14
    bba8:	08 94       	sec
    bbaa:	c1 08       	sbc	r12, r1
    bbac:	d1 08       	sbc	r13, r1
    bbae:	c1 14       	cp	r12, r1
    bbb0:	d1 04       	cpc	r13, r1
    bbb2:	71 f7       	brne	.-36     	; 0xbb90 <vfprintf+0x1d0>
    bbb4:	e7 c0       	rjmp	.+462    	; 0xbd84 <vfprintf+0x3c4>
    bbb6:	84 36       	cpi	r24, 0x64	; 100
    bbb8:	11 f0       	breq	.+4      	; 0xbbbe <vfprintf+0x1fe>
    bbba:	89 36       	cpi	r24, 0x69	; 105
    bbbc:	51 f5       	brne	.+84     	; 0xbc12 <vfprintf+0x252>
    bbbe:	f5 01       	movw	r30, r10
    bbc0:	17 ff       	sbrs	r17, 7
    bbc2:	07 c0       	rjmp	.+14     	; 0xbbd2 <vfprintf+0x212>
    bbc4:	80 81       	ld	r24, Z
    bbc6:	91 81       	ldd	r25, Z+1	; 0x01
    bbc8:	a2 81       	ldd	r26, Z+2	; 0x02
    bbca:	b3 81       	ldd	r27, Z+3	; 0x03
    bbcc:	24 e0       	ldi	r18, 0x04	; 4
    bbce:	30 e0       	ldi	r19, 0x00	; 0
    bbd0:	08 c0       	rjmp	.+16     	; 0xbbe2 <vfprintf+0x222>
    bbd2:	80 81       	ld	r24, Z
    bbd4:	91 81       	ldd	r25, Z+1	; 0x01
    bbd6:	aa 27       	eor	r26, r26
    bbd8:	97 fd       	sbrc	r25, 7
    bbda:	a0 95       	com	r26
    bbdc:	ba 2f       	mov	r27, r26
    bbde:	22 e0       	ldi	r18, 0x02	; 2
    bbe0:	30 e0       	ldi	r19, 0x00	; 0
    bbe2:	a2 0e       	add	r10, r18
    bbe4:	b3 1e       	adc	r11, r19
    bbe6:	01 2f       	mov	r16, r17
    bbe8:	0f 76       	andi	r16, 0x6F	; 111
    bbea:	b7 ff       	sbrs	r27, 7
    bbec:	08 c0       	rjmp	.+16     	; 0xbbfe <vfprintf+0x23e>
    bbee:	b0 95       	com	r27
    bbf0:	a0 95       	com	r26
    bbf2:	90 95       	com	r25
    bbf4:	81 95       	neg	r24
    bbf6:	9f 4f       	sbci	r25, 0xFF	; 255
    bbf8:	af 4f       	sbci	r26, 0xFF	; 255
    bbfa:	bf 4f       	sbci	r27, 0xFF	; 255
    bbfc:	00 68       	ori	r16, 0x80	; 128
    bbfe:	bc 01       	movw	r22, r24
    bc00:	cd 01       	movw	r24, r26
    bc02:	a2 01       	movw	r20, r4
    bc04:	2a e0       	ldi	r18, 0x0A	; 10
    bc06:	30 e0       	ldi	r19, 0x00	; 0
    bc08:	0e 94 3c 5f 	call	0xbe78	; 0xbe78 <__ultoa_invert>
    bc0c:	d8 2e       	mov	r13, r24
    bc0e:	d4 18       	sub	r13, r4
    bc10:	3f c0       	rjmp	.+126    	; 0xbc90 <vfprintf+0x2d0>
    bc12:	85 37       	cpi	r24, 0x75	; 117
    bc14:	21 f4       	brne	.+8      	; 0xbc1e <vfprintf+0x25e>
    bc16:	1f 7e       	andi	r17, 0xEF	; 239
    bc18:	2a e0       	ldi	r18, 0x0A	; 10
    bc1a:	30 e0       	ldi	r19, 0x00	; 0
    bc1c:	20 c0       	rjmp	.+64     	; 0xbc5e <vfprintf+0x29e>
    bc1e:	19 7f       	andi	r17, 0xF9	; 249
    bc20:	8f 36       	cpi	r24, 0x6F	; 111
    bc22:	a9 f0       	breq	.+42     	; 0xbc4e <vfprintf+0x28e>
    bc24:	80 37       	cpi	r24, 0x70	; 112
    bc26:	20 f4       	brcc	.+8      	; 0xbc30 <vfprintf+0x270>
    bc28:	88 35       	cpi	r24, 0x58	; 88
    bc2a:	09 f0       	breq	.+2      	; 0xbc2e <vfprintf+0x26e>
    bc2c:	ae c0       	rjmp	.+348    	; 0xbd8a <vfprintf+0x3ca>
    bc2e:	0b c0       	rjmp	.+22     	; 0xbc46 <vfprintf+0x286>
    bc30:	80 37       	cpi	r24, 0x70	; 112
    bc32:	21 f0       	breq	.+8      	; 0xbc3c <vfprintf+0x27c>
    bc34:	88 37       	cpi	r24, 0x78	; 120
    bc36:	09 f0       	breq	.+2      	; 0xbc3a <vfprintf+0x27a>
    bc38:	a8 c0       	rjmp	.+336    	; 0xbd8a <vfprintf+0x3ca>
    bc3a:	01 c0       	rjmp	.+2      	; 0xbc3e <vfprintf+0x27e>
    bc3c:	10 61       	ori	r17, 0x10	; 16
    bc3e:	14 ff       	sbrs	r17, 4
    bc40:	09 c0       	rjmp	.+18     	; 0xbc54 <vfprintf+0x294>
    bc42:	14 60       	ori	r17, 0x04	; 4
    bc44:	07 c0       	rjmp	.+14     	; 0xbc54 <vfprintf+0x294>
    bc46:	14 ff       	sbrs	r17, 4
    bc48:	08 c0       	rjmp	.+16     	; 0xbc5a <vfprintf+0x29a>
    bc4a:	16 60       	ori	r17, 0x06	; 6
    bc4c:	06 c0       	rjmp	.+12     	; 0xbc5a <vfprintf+0x29a>
    bc4e:	28 e0       	ldi	r18, 0x08	; 8
    bc50:	30 e0       	ldi	r19, 0x00	; 0
    bc52:	05 c0       	rjmp	.+10     	; 0xbc5e <vfprintf+0x29e>
    bc54:	20 e1       	ldi	r18, 0x10	; 16
    bc56:	30 e0       	ldi	r19, 0x00	; 0
    bc58:	02 c0       	rjmp	.+4      	; 0xbc5e <vfprintf+0x29e>
    bc5a:	20 e1       	ldi	r18, 0x10	; 16
    bc5c:	32 e0       	ldi	r19, 0x02	; 2
    bc5e:	f5 01       	movw	r30, r10
    bc60:	17 ff       	sbrs	r17, 7
    bc62:	07 c0       	rjmp	.+14     	; 0xbc72 <vfprintf+0x2b2>
    bc64:	60 81       	ld	r22, Z
    bc66:	71 81       	ldd	r23, Z+1	; 0x01
    bc68:	82 81       	ldd	r24, Z+2	; 0x02
    bc6a:	93 81       	ldd	r25, Z+3	; 0x03
    bc6c:	44 e0       	ldi	r20, 0x04	; 4
    bc6e:	50 e0       	ldi	r21, 0x00	; 0
    bc70:	06 c0       	rjmp	.+12     	; 0xbc7e <vfprintf+0x2be>
    bc72:	60 81       	ld	r22, Z
    bc74:	71 81       	ldd	r23, Z+1	; 0x01
    bc76:	80 e0       	ldi	r24, 0x00	; 0
    bc78:	90 e0       	ldi	r25, 0x00	; 0
    bc7a:	42 e0       	ldi	r20, 0x02	; 2
    bc7c:	50 e0       	ldi	r21, 0x00	; 0
    bc7e:	a4 0e       	add	r10, r20
    bc80:	b5 1e       	adc	r11, r21
    bc82:	a2 01       	movw	r20, r4
    bc84:	0e 94 3c 5f 	call	0xbe78	; 0xbe78 <__ultoa_invert>
    bc88:	d8 2e       	mov	r13, r24
    bc8a:	d4 18       	sub	r13, r4
    bc8c:	01 2f       	mov	r16, r17
    bc8e:	0f 77       	andi	r16, 0x7F	; 127
    bc90:	06 ff       	sbrs	r16, 6
    bc92:	09 c0       	rjmp	.+18     	; 0xbca6 <vfprintf+0x2e6>
    bc94:	0e 7f       	andi	r16, 0xFE	; 254
    bc96:	df 14       	cp	r13, r15
    bc98:	30 f4       	brcc	.+12     	; 0xbca6 <vfprintf+0x2e6>
    bc9a:	04 ff       	sbrs	r16, 4
    bc9c:	06 c0       	rjmp	.+12     	; 0xbcaa <vfprintf+0x2ea>
    bc9e:	02 fd       	sbrc	r16, 2
    bca0:	04 c0       	rjmp	.+8      	; 0xbcaa <vfprintf+0x2ea>
    bca2:	0f 7e       	andi	r16, 0xEF	; 239
    bca4:	02 c0       	rjmp	.+4      	; 0xbcaa <vfprintf+0x2ea>
    bca6:	1d 2d       	mov	r17, r13
    bca8:	01 c0       	rjmp	.+2      	; 0xbcac <vfprintf+0x2ec>
    bcaa:	1f 2d       	mov	r17, r15
    bcac:	80 2f       	mov	r24, r16
    bcae:	90 e0       	ldi	r25, 0x00	; 0
    bcb0:	04 ff       	sbrs	r16, 4
    bcb2:	0c c0       	rjmp	.+24     	; 0xbccc <vfprintf+0x30c>
    bcb4:	fe 01       	movw	r30, r28
    bcb6:	ed 0d       	add	r30, r13
    bcb8:	f1 1d       	adc	r31, r1
    bcba:	20 81       	ld	r18, Z
    bcbc:	20 33       	cpi	r18, 0x30	; 48
    bcbe:	11 f4       	brne	.+4      	; 0xbcc4 <vfprintf+0x304>
    bcc0:	09 7e       	andi	r16, 0xE9	; 233
    bcc2:	09 c0       	rjmp	.+18     	; 0xbcd6 <vfprintf+0x316>
    bcc4:	02 ff       	sbrs	r16, 2
    bcc6:	06 c0       	rjmp	.+12     	; 0xbcd4 <vfprintf+0x314>
    bcc8:	1e 5f       	subi	r17, 0xFE	; 254
    bcca:	05 c0       	rjmp	.+10     	; 0xbcd6 <vfprintf+0x316>
    bccc:	86 78       	andi	r24, 0x86	; 134
    bcce:	90 70       	andi	r25, 0x00	; 0
    bcd0:	00 97       	sbiw	r24, 0x00	; 0
    bcd2:	09 f0       	breq	.+2      	; 0xbcd6 <vfprintf+0x316>
    bcd4:	1f 5f       	subi	r17, 0xFF	; 255
    bcd6:	80 2e       	mov	r8, r16
    bcd8:	99 24       	eor	r9, r9
    bcda:	03 fd       	sbrc	r16, 3
    bcdc:	12 c0       	rjmp	.+36     	; 0xbd02 <vfprintf+0x342>
    bcde:	00 ff       	sbrs	r16, 0
    bce0:	0d c0       	rjmp	.+26     	; 0xbcfc <vfprintf+0x33c>
    bce2:	fd 2c       	mov	r15, r13
    bce4:	1e 15       	cp	r17, r14
    bce6:	50 f4       	brcc	.+20     	; 0xbcfc <vfprintf+0x33c>
    bce8:	fe 0c       	add	r15, r14
    bcea:	f1 1a       	sub	r15, r17
    bcec:	1e 2d       	mov	r17, r14
    bcee:	06 c0       	rjmp	.+12     	; 0xbcfc <vfprintf+0x33c>
    bcf0:	80 e2       	ldi	r24, 0x20	; 32
    bcf2:	90 e0       	ldi	r25, 0x00	; 0
    bcf4:	b3 01       	movw	r22, r6
    bcf6:	0e 94 10 5f 	call	0xbe20	; 0xbe20 <fputc>
    bcfa:	1f 5f       	subi	r17, 0xFF	; 255
    bcfc:	1e 15       	cp	r17, r14
    bcfe:	c0 f3       	brcs	.-16     	; 0xbcf0 <vfprintf+0x330>
    bd00:	04 c0       	rjmp	.+8      	; 0xbd0a <vfprintf+0x34a>
    bd02:	1e 15       	cp	r17, r14
    bd04:	10 f4       	brcc	.+4      	; 0xbd0a <vfprintf+0x34a>
    bd06:	e1 1a       	sub	r14, r17
    bd08:	01 c0       	rjmp	.+2      	; 0xbd0c <vfprintf+0x34c>
    bd0a:	ee 24       	eor	r14, r14
    bd0c:	84 fe       	sbrs	r8, 4
    bd0e:	0f c0       	rjmp	.+30     	; 0xbd2e <vfprintf+0x36e>
    bd10:	80 e3       	ldi	r24, 0x30	; 48
    bd12:	90 e0       	ldi	r25, 0x00	; 0
    bd14:	b3 01       	movw	r22, r6
    bd16:	0e 94 10 5f 	call	0xbe20	; 0xbe20 <fputc>
    bd1a:	82 fe       	sbrs	r8, 2
    bd1c:	1f c0       	rjmp	.+62     	; 0xbd5c <vfprintf+0x39c>
    bd1e:	81 fe       	sbrs	r8, 1
    bd20:	03 c0       	rjmp	.+6      	; 0xbd28 <vfprintf+0x368>
    bd22:	88 e5       	ldi	r24, 0x58	; 88
    bd24:	90 e0       	ldi	r25, 0x00	; 0
    bd26:	10 c0       	rjmp	.+32     	; 0xbd48 <vfprintf+0x388>
    bd28:	88 e7       	ldi	r24, 0x78	; 120
    bd2a:	90 e0       	ldi	r25, 0x00	; 0
    bd2c:	0d c0       	rjmp	.+26     	; 0xbd48 <vfprintf+0x388>
    bd2e:	c4 01       	movw	r24, r8
    bd30:	86 78       	andi	r24, 0x86	; 134
    bd32:	90 70       	andi	r25, 0x00	; 0
    bd34:	00 97       	sbiw	r24, 0x00	; 0
    bd36:	91 f0       	breq	.+36     	; 0xbd5c <vfprintf+0x39c>
    bd38:	81 fc       	sbrc	r8, 1
    bd3a:	02 c0       	rjmp	.+4      	; 0xbd40 <vfprintf+0x380>
    bd3c:	80 e2       	ldi	r24, 0x20	; 32
    bd3e:	01 c0       	rjmp	.+2      	; 0xbd42 <vfprintf+0x382>
    bd40:	8b e2       	ldi	r24, 0x2B	; 43
    bd42:	07 fd       	sbrc	r16, 7
    bd44:	8d e2       	ldi	r24, 0x2D	; 45
    bd46:	90 e0       	ldi	r25, 0x00	; 0
    bd48:	b3 01       	movw	r22, r6
    bd4a:	0e 94 10 5f 	call	0xbe20	; 0xbe20 <fputc>
    bd4e:	06 c0       	rjmp	.+12     	; 0xbd5c <vfprintf+0x39c>
    bd50:	80 e3       	ldi	r24, 0x30	; 48
    bd52:	90 e0       	ldi	r25, 0x00	; 0
    bd54:	b3 01       	movw	r22, r6
    bd56:	0e 94 10 5f 	call	0xbe20	; 0xbe20 <fputc>
    bd5a:	fa 94       	dec	r15
    bd5c:	df 14       	cp	r13, r15
    bd5e:	c0 f3       	brcs	.-16     	; 0xbd50 <vfprintf+0x390>
    bd60:	da 94       	dec	r13
    bd62:	f2 01       	movw	r30, r4
    bd64:	ed 0d       	add	r30, r13
    bd66:	f1 1d       	adc	r31, r1
    bd68:	80 81       	ld	r24, Z
    bd6a:	90 e0       	ldi	r25, 0x00	; 0
    bd6c:	b3 01       	movw	r22, r6
    bd6e:	0e 94 10 5f 	call	0xbe20	; 0xbe20 <fputc>
    bd72:	dd 20       	and	r13, r13
    bd74:	a9 f7       	brne	.-22     	; 0xbd60 <vfprintf+0x3a0>
    bd76:	06 c0       	rjmp	.+12     	; 0xbd84 <vfprintf+0x3c4>
    bd78:	80 e2       	ldi	r24, 0x20	; 32
    bd7a:	90 e0       	ldi	r25, 0x00	; 0
    bd7c:	b3 01       	movw	r22, r6
    bd7e:	0e 94 10 5f 	call	0xbe20	; 0xbe20 <fputc>
    bd82:	ea 94       	dec	r14
    bd84:	ee 20       	and	r14, r14
    bd86:	c1 f7       	brne	.-16     	; 0xbd78 <vfprintf+0x3b8>
    bd88:	40 ce       	rjmp	.-896    	; 0xba0a <vfprintf+0x4a>
    bd8a:	f3 01       	movw	r30, r6
    bd8c:	86 81       	ldd	r24, Z+6	; 0x06
    bd8e:	97 81       	ldd	r25, Z+7	; 0x07
    bd90:	02 c0       	rjmp	.+4      	; 0xbd96 <vfprintf+0x3d6>
    bd92:	8f ef       	ldi	r24, 0xFF	; 255
    bd94:	9f ef       	ldi	r25, 0xFF	; 255
    bd96:	2d 96       	adiw	r28, 0x0d	; 13
    bd98:	cd bf       	out	0x3d, r28	; 61
    bd9a:	de bf       	out	0x3e, r29	; 62
    bd9c:	df 91       	pop	r29
    bd9e:	cf 91       	pop	r28
    bda0:	1f 91       	pop	r17
    bda2:	0f 91       	pop	r16
    bda4:	ff 90       	pop	r15
    bda6:	ef 90       	pop	r14
    bda8:	df 90       	pop	r13
    bdaa:	cf 90       	pop	r12
    bdac:	bf 90       	pop	r11
    bdae:	af 90       	pop	r10
    bdb0:	9f 90       	pop	r9
    bdb2:	8f 90       	pop	r8
    bdb4:	7f 90       	pop	r7
    bdb6:	6f 90       	pop	r6
    bdb8:	5f 90       	pop	r5
    bdba:	4f 90       	pop	r4
    bdbc:	3f 90       	pop	r3
    bdbe:	2f 90       	pop	r2
    bdc0:	08 95       	ret

0000bdc2 <strnlen_P>:
    bdc2:	fc 01       	movw	r30, r24
    bdc4:	05 90       	lpm	r0, Z+
    bdc6:	61 50       	subi	r22, 0x01	; 1
    bdc8:	70 40       	sbci	r23, 0x00	; 0
    bdca:	01 10       	cpse	r0, r1
    bdcc:	d8 f7       	brcc	.-10     	; 0xbdc4 <strnlen_P+0x2>
    bdce:	80 95       	com	r24
    bdd0:	90 95       	com	r25
    bdd2:	8e 0f       	add	r24, r30
    bdd4:	9f 1f       	adc	r25, r31
    bdd6:	08 95       	ret

0000bdd8 <memcpy>:
    bdd8:	fb 01       	movw	r30, r22
    bdda:	dc 01       	movw	r26, r24
    bddc:	02 c0       	rjmp	.+4      	; 0xbde2 <memcpy+0xa>
    bdde:	01 90       	ld	r0, Z+
    bde0:	0d 92       	st	X+, r0
    bde2:	41 50       	subi	r20, 0x01	; 1
    bde4:	50 40       	sbci	r21, 0x00	; 0
    bde6:	d8 f7       	brcc	.-10     	; 0xbdde <memcpy+0x6>
    bde8:	08 95       	ret

0000bdea <strnlen>:
    bdea:	fc 01       	movw	r30, r24
    bdec:	61 50       	subi	r22, 0x01	; 1
    bdee:	70 40       	sbci	r23, 0x00	; 0
    bdf0:	01 90       	ld	r0, Z+
    bdf2:	01 10       	cpse	r0, r1
    bdf4:	d8 f7       	brcc	.-10     	; 0xbdec <strnlen+0x2>
    bdf6:	80 95       	com	r24
    bdf8:	90 95       	com	r25
    bdfa:	8e 0f       	add	r24, r30
    bdfc:	9f 1f       	adc	r25, r31
    bdfe:	08 95       	ret

0000be00 <strrev>:
    be00:	dc 01       	movw	r26, r24
    be02:	fc 01       	movw	r30, r24
    be04:	67 2f       	mov	r22, r23
    be06:	71 91       	ld	r23, Z+
    be08:	77 23       	and	r23, r23
    be0a:	e1 f7       	brne	.-8      	; 0xbe04 <strrev+0x4>
    be0c:	32 97       	sbiw	r30, 0x02	; 2
    be0e:	04 c0       	rjmp	.+8      	; 0xbe18 <strrev+0x18>
    be10:	7c 91       	ld	r23, X
    be12:	6d 93       	st	X+, r22
    be14:	70 83       	st	Z, r23
    be16:	62 91       	ld	r22, -Z
    be18:	ae 17       	cp	r26, r30
    be1a:	bf 07       	cpc	r27, r31
    be1c:	c8 f3       	brcs	.-14     	; 0xbe10 <strrev+0x10>
    be1e:	08 95       	ret

0000be20 <fputc>:
    be20:	0f 93       	push	r16
    be22:	1f 93       	push	r17
    be24:	cf 93       	push	r28
    be26:	df 93       	push	r29
    be28:	8c 01       	movw	r16, r24
    be2a:	eb 01       	movw	r28, r22
    be2c:	8b 81       	ldd	r24, Y+3	; 0x03
    be2e:	81 ff       	sbrs	r24, 1
    be30:	1b c0       	rjmp	.+54     	; 0xbe68 <fputc+0x48>
    be32:	82 ff       	sbrs	r24, 2
    be34:	0d c0       	rjmp	.+26     	; 0xbe50 <fputc+0x30>
    be36:	2e 81       	ldd	r18, Y+6	; 0x06
    be38:	3f 81       	ldd	r19, Y+7	; 0x07
    be3a:	8c 81       	ldd	r24, Y+4	; 0x04
    be3c:	9d 81       	ldd	r25, Y+5	; 0x05
    be3e:	28 17       	cp	r18, r24
    be40:	39 07       	cpc	r19, r25
    be42:	64 f4       	brge	.+24     	; 0xbe5c <fputc+0x3c>
    be44:	e8 81       	ld	r30, Y
    be46:	f9 81       	ldd	r31, Y+1	; 0x01
    be48:	01 93       	st	Z+, r16
    be4a:	e8 83       	st	Y, r30
    be4c:	f9 83       	std	Y+1, r31	; 0x01
    be4e:	06 c0       	rjmp	.+12     	; 0xbe5c <fputc+0x3c>
    be50:	e8 85       	ldd	r30, Y+8	; 0x08
    be52:	f9 85       	ldd	r31, Y+9	; 0x09
    be54:	80 2f       	mov	r24, r16
    be56:	19 95       	eicall
    be58:	00 97       	sbiw	r24, 0x00	; 0
    be5a:	31 f4       	brne	.+12     	; 0xbe68 <fputc+0x48>
    be5c:	8e 81       	ldd	r24, Y+6	; 0x06
    be5e:	9f 81       	ldd	r25, Y+7	; 0x07
    be60:	01 96       	adiw	r24, 0x01	; 1
    be62:	8e 83       	std	Y+6, r24	; 0x06
    be64:	9f 83       	std	Y+7, r25	; 0x07
    be66:	02 c0       	rjmp	.+4      	; 0xbe6c <fputc+0x4c>
    be68:	0f ef       	ldi	r16, 0xFF	; 255
    be6a:	1f ef       	ldi	r17, 0xFF	; 255
    be6c:	c8 01       	movw	r24, r16
    be6e:	df 91       	pop	r29
    be70:	cf 91       	pop	r28
    be72:	1f 91       	pop	r17
    be74:	0f 91       	pop	r16
    be76:	08 95       	ret

0000be78 <__ultoa_invert>:
    be78:	fa 01       	movw	r30, r20
    be7a:	aa 27       	eor	r26, r26
    be7c:	28 30       	cpi	r18, 0x08	; 8
    be7e:	51 f1       	breq	.+84     	; 0xbed4 <__ultoa_invert+0x5c>
    be80:	20 31       	cpi	r18, 0x10	; 16
    be82:	81 f1       	breq	.+96     	; 0xbee4 <__ultoa_invert+0x6c>
    be84:	e8 94       	clt
    be86:	6f 93       	push	r22
    be88:	6e 7f       	andi	r22, 0xFE	; 254
    be8a:	6e 5f       	subi	r22, 0xFE	; 254
    be8c:	7f 4f       	sbci	r23, 0xFF	; 255
    be8e:	8f 4f       	sbci	r24, 0xFF	; 255
    be90:	9f 4f       	sbci	r25, 0xFF	; 255
    be92:	af 4f       	sbci	r26, 0xFF	; 255
    be94:	b1 e0       	ldi	r27, 0x01	; 1
    be96:	3e d0       	rcall	.+124    	; 0xbf14 <__ultoa_invert+0x9c>
    be98:	b4 e0       	ldi	r27, 0x04	; 4
    be9a:	3c d0       	rcall	.+120    	; 0xbf14 <__ultoa_invert+0x9c>
    be9c:	67 0f       	add	r22, r23
    be9e:	78 1f       	adc	r23, r24
    bea0:	89 1f       	adc	r24, r25
    bea2:	9a 1f       	adc	r25, r26
    bea4:	a1 1d       	adc	r26, r1
    bea6:	68 0f       	add	r22, r24
    bea8:	79 1f       	adc	r23, r25
    beaa:	8a 1f       	adc	r24, r26
    beac:	91 1d       	adc	r25, r1
    beae:	a1 1d       	adc	r26, r1
    beb0:	6a 0f       	add	r22, r26
    beb2:	71 1d       	adc	r23, r1
    beb4:	81 1d       	adc	r24, r1
    beb6:	91 1d       	adc	r25, r1
    beb8:	a1 1d       	adc	r26, r1
    beba:	20 d0       	rcall	.+64     	; 0xbefc <__ultoa_invert+0x84>
    bebc:	09 f4       	brne	.+2      	; 0xbec0 <__ultoa_invert+0x48>
    bebe:	68 94       	set
    bec0:	3f 91       	pop	r19
    bec2:	2a e0       	ldi	r18, 0x0A	; 10
    bec4:	26 9f       	mul	r18, r22
    bec6:	11 24       	eor	r1, r1
    bec8:	30 19       	sub	r19, r0
    beca:	30 5d       	subi	r19, 0xD0	; 208
    becc:	31 93       	st	Z+, r19
    bece:	de f6       	brtc	.-74     	; 0xbe86 <__ultoa_invert+0xe>
    bed0:	cf 01       	movw	r24, r30
    bed2:	08 95       	ret
    bed4:	46 2f       	mov	r20, r22
    bed6:	47 70       	andi	r20, 0x07	; 7
    bed8:	40 5d       	subi	r20, 0xD0	; 208
    beda:	41 93       	st	Z+, r20
    bedc:	b3 e0       	ldi	r27, 0x03	; 3
    bede:	0f d0       	rcall	.+30     	; 0xbefe <__ultoa_invert+0x86>
    bee0:	c9 f7       	brne	.-14     	; 0xbed4 <__ultoa_invert+0x5c>
    bee2:	f6 cf       	rjmp	.-20     	; 0xbed0 <__ultoa_invert+0x58>
    bee4:	46 2f       	mov	r20, r22
    bee6:	4f 70       	andi	r20, 0x0F	; 15
    bee8:	40 5d       	subi	r20, 0xD0	; 208
    beea:	4a 33       	cpi	r20, 0x3A	; 58
    beec:	18 f0       	brcs	.+6      	; 0xbef4 <__ultoa_invert+0x7c>
    beee:	49 5d       	subi	r20, 0xD9	; 217
    bef0:	31 fd       	sbrc	r19, 1
    bef2:	40 52       	subi	r20, 0x20	; 32
    bef4:	41 93       	st	Z+, r20
    bef6:	02 d0       	rcall	.+4      	; 0xbefc <__ultoa_invert+0x84>
    bef8:	a9 f7       	brne	.-22     	; 0xbee4 <__ultoa_invert+0x6c>
    befa:	ea cf       	rjmp	.-44     	; 0xbed0 <__ultoa_invert+0x58>
    befc:	b4 e0       	ldi	r27, 0x04	; 4
    befe:	a6 95       	lsr	r26
    bf00:	97 95       	ror	r25
    bf02:	87 95       	ror	r24
    bf04:	77 95       	ror	r23
    bf06:	67 95       	ror	r22
    bf08:	ba 95       	dec	r27
    bf0a:	c9 f7       	brne	.-14     	; 0xbefe <__ultoa_invert+0x86>
    bf0c:	00 97       	sbiw	r24, 0x00	; 0
    bf0e:	61 05       	cpc	r22, r1
    bf10:	71 05       	cpc	r23, r1
    bf12:	08 95       	ret
    bf14:	9b 01       	movw	r18, r22
    bf16:	ac 01       	movw	r20, r24
    bf18:	0a 2e       	mov	r0, r26
    bf1a:	06 94       	lsr	r0
    bf1c:	57 95       	ror	r21
    bf1e:	47 95       	ror	r20
    bf20:	37 95       	ror	r19
    bf22:	27 95       	ror	r18
    bf24:	ba 95       	dec	r27
    bf26:	c9 f7       	brne	.-14     	; 0xbf1a <__ultoa_invert+0xa2>
    bf28:	62 0f       	add	r22, r18
    bf2a:	73 1f       	adc	r23, r19
    bf2c:	84 1f       	adc	r24, r20
    bf2e:	95 1f       	adc	r25, r21
    bf30:	a0 1d       	adc	r26, r0
    bf32:	08 95       	ret

0000bf34 <_exit>:
    bf34:	f8 94       	cli

0000bf36 <__stop_program>:
    bf36:	ff cf       	rjmp	.-2      	; 0xbf36 <__stop_program>
