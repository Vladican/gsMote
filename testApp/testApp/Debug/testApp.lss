
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000bf22  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000132  00802000  0000bf22  0000bfb6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002fab  00802132  00802132  0000c0e8  2**0
                  ALLOC
  3 .stab         00002718  00000000  00000000  0000c0e8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a2a  00000000  00000000  0000e800  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000003c0  00000000  00000000  0000f230  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000c5e4  00000000  00000000  0000f5f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002155  00000000  00000000  0001bbd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003f16  00000000  00000000  0001dd29  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001bc0  00000000  00000000  00021c40  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000045ed  00000000  00000000  00023800  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004ff8  00000000  00000000  00027ded  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000118  00000000  00000000  0002cde5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 46 10 	jmp	0x208c	; 0x208c <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 5a 0f 	jmp	0x1eb4	; 0x1eb4 <__vector_16>
      44:	0c 94 8a 0f 	jmp	0x1f14	; 0x1f14 <__vector_17>
      48:	0c 94 ba 0f 	jmp	0x1f74	; 0x1f74 <__vector_18>
      4c:	0c 94 ea 0f 	jmp	0x1fd4	; 0x1fd4 <__vector_19>
      50:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 a7 3d 	jmp	0x7b4e	; 0x7b4e <__vector_43>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 6b 2d 	jmp	0x5ad6	; 0x5ad6 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 ec 12 	jmp	0x25d8	; 0x25d8 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 2a 12 	jmp	0x2454	; 0x2454 <__vector_79>
     140:	0c 94 5a 12 	jmp	0x24b4	; 0x24b4 <__vector_80>
     144:	0c 94 8a 12 	jmp	0x2514	; 0x2514 <__vector_81>
     148:	0c 94 ba 12 	jmp	0x2574	; 0x2574 <__vector_82>
     14c:	0c 94 8e 01 	jmp	0x31c	; 0x31c <__vector_83>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 5c 0c 	jmp	0x18b8	; 0x18b8 <__vector_104>
     1a4:	0c 94 51 0a 	jmp	0x14a2	; 0x14a2 <__vector_105>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_overflow>:
     1e8:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     1f8:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     208:	54 41 0a 00                                         TA..

0000020c <chb_err_init>:
     20c:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     21c:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	e2 e2       	ldi	r30, 0x22	; 34
     244:	ff eb       	ldi	r31, 0xBF	; 191
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	a2 33       	cpi	r26, 0x32	; 50
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	a2 e3       	ldi	r26, 0x32	; 50
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	ad 3d       	cpi	r26, 0xDD	; 221
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 06 02 	call	0x40c	; 0x40c <main>
     26a:	0c 94 8f 5f 	jmp	0xbf1e	; 0xbf1e <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <synch>:
#include "E-000001-000009_firmware_rev_1_0.h"


char buff[8];
//creates a system for syncing ADC sampling with other motes through the base station every SynchPer seconds
void synch(int SynchPer){
     272:	cf 93       	push	r28
     274:	df 93       	push	r29
     276:	0f 92       	push	r0
     278:	0f 92       	push	r0
     27a:	cd b7       	in	r28, 0x3d	; 61
     27c:	de b7       	in	r29, 0x3e	; 62
     27e:	89 83       	std	Y+1, r24	; 0x01
     280:	9a 83       	std	Y+2, r25	; 0x02
	moteID = 1;
     282:	81 e0       	ldi	r24, 0x01	; 1
     284:	80 93 d1 50 	sts	0x50D1, r24
	RadioMonitorMode = SYNCHED;		//initialize the RadioMonitorMode to synched 
     288:	83 e0       	ldi	r24, 0x03	; 3
     28a:	80 93 5f 40 	sts	0x405F, r24
	chb_init();
     28e:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <chb_init>
	chb_set_short_addr(moteID);
     292:	80 91 d1 50 	lds	r24, 0x50D1
     296:	88 2f       	mov	r24, r24
     298:	90 e0       	ldi	r25, 0x00	; 0
     29a:	0e 94 2a 2b 	call	0x5654	; 0x5654 <chb_set_short_addr>
	EVSYS.CH1MUX = EVSYS_CHMUX_TCC1_OVF_gc;	//set overflow of lower 16 bits of the counter as event on channel 1
     29e:	80 e8       	ldi	r24, 0x80	; 128
     2a0:	91 e0       	ldi	r25, 0x01	; 1
     2a2:	28 ec       	ldi	r18, 0xC8	; 200
     2a4:	fc 01       	movw	r30, r24
     2a6:	21 83       	std	Z+1, r18	; 0x01
	TCD1.CTRLA = TC_CLKSEL_EVCH1_gc; //select event channel 1 as input clock to the upper 16 bits of the counter
     2a8:	80 e4       	ldi	r24, 0x40	; 64
     2aa:	99 e0       	ldi	r25, 0x09	; 9
     2ac:	29 e0       	ldi	r18, 0x09	; 9
     2ae:	fc 01       	movw	r30, r24
     2b0:	20 83       	st	Z, r18
	TCD1.INTCTRLA = 0x02;	//enable timer overflow interrupt as high priority interrupt
     2b2:	80 e4       	ldi	r24, 0x40	; 64
     2b4:	99 e0       	ldi	r25, 0x09	; 9
     2b6:	22 e0       	ldi	r18, 0x02	; 2
     2b8:	fc 01       	movw	r30, r24
     2ba:	26 83       	std	Z+6, r18	; 0x06
	TCD1.PER = SynchPer*500; //upper 16 bits of the 32-bit joint timer
     2bc:	80 e4       	ldi	r24, 0x40	; 64
     2be:	99 e0       	ldi	r25, 0x09	; 9
     2c0:	69 81       	ldd	r22, Y+1	; 0x01
     2c2:	7a 81       	ldd	r23, Y+2	; 0x02
     2c4:	44 ef       	ldi	r20, 0xF4	; 244
     2c6:	51 e0       	ldi	r21, 0x01	; 1
     2c8:	64 9f       	mul	r22, r20
     2ca:	90 01       	movw	r18, r0
     2cc:	65 9f       	mul	r22, r21
     2ce:	30 0d       	add	r19, r0
     2d0:	74 9f       	mul	r23, r20
     2d2:	30 0d       	add	r19, r0
     2d4:	11 24       	eor	r1, r1
     2d6:	fc 01       	movw	r30, r24
     2d8:	26 a3       	lds	r18, 0x56
     2da:	37 a3       	lds	r19, 0x57
		
	TCC1.PER = 64000;	//64000 cycles of cpu at 32MHz equals one 500 Hz interval
     2dc:	80 e4       	ldi	r24, 0x40	; 64
     2de:	98 e0       	ldi	r25, 0x08	; 8
     2e0:	20 e0       	ldi	r18, 0x00	; 0
     2e2:	3a ef       	ldi	r19, 0xFA	; 250
     2e4:	fc 01       	movw	r30, r24
     2e6:	26 a3       	lds	r18, 0x56
     2e8:	37 a3       	lds	r19, 0x57
	TCC1.INTCTRLA = 0x01;  //enable timer overflow interrupt as medium priority interrupt
     2ea:	80 e4       	ldi	r24, 0x40	; 64
     2ec:	98 e0       	ldi	r25, 0x08	; 8
     2ee:	21 e0       	ldi	r18, 0x01	; 1
     2f0:	fc 01       	movw	r30, r24
     2f2:	26 83       	std	Z+6, r18	; 0x06
	TCC1.CTRLA = 0x01;  //start timer with clock precision of cpu clock (32MHz)
     2f4:	80 e4       	ldi	r24, 0x40	; 64
     2f6:	98 e0       	ldi	r25, 0x08	; 8
     2f8:	21 e0       	ldi	r18, 0x01	; 1
     2fa:	fc 01       	movw	r30, r24
     2fc:	20 83       	st	Z, r18
	PMIC.CTRL |= ENABLE_ALL_INTERRUPT_LEVELS;
     2fe:	80 ea       	ldi	r24, 0xA0	; 160
     300:	90 e0       	ldi	r25, 0x00	; 0
     302:	20 ea       	ldi	r18, 0xA0	; 160
     304:	30 e0       	ldi	r19, 0x00	; 0
     306:	f9 01       	movw	r30, r18
     308:	22 81       	ldd	r18, Z+2	; 0x02
     30a:	27 60       	ori	r18, 0x07	; 7
     30c:	fc 01       	movw	r30, r24
     30e:	22 83       	std	Z+2, r18	; 0x02
	sei(); //  Enable global interrupts
     310:	78 94       	sei
}
     312:	0f 90       	pop	r0
     314:	0f 90       	pop	r0
     316:	df 91       	pop	r29
     318:	cf 91       	pop	r28
     31a:	08 95       	ret

0000031c <__vector_83>:

ISR(TCD1_OVF_vect, ISR_NOBLOCK) {
     31c:	78 94       	sei
     31e:	1f 92       	push	r1
     320:	0f 92       	push	r0
     322:	0f b6       	in	r0, 0x3f	; 63
     324:	0f 92       	push	r0
     326:	00 90 3b 00 	lds	r0, 0x003B
     32a:	0f 92       	push	r0
     32c:	11 24       	eor	r1, r1
     32e:	2f 93       	push	r18
     330:	3f 93       	push	r19
     332:	4f 93       	push	r20
     334:	5f 93       	push	r21
     336:	6f 93       	push	r22
     338:	7f 93       	push	r23
     33a:	8f 93       	push	r24
     33c:	9f 93       	push	r25
     33e:	af 93       	push	r26
     340:	bf 93       	push	r27
     342:	ef 93       	push	r30
     344:	ff 93       	push	r31
     346:	cf 93       	push	r28
     348:	df 93       	push	r29
     34a:	cd b7       	in	r28, 0x3d	; 61
     34c:	de b7       	in	r29, 0x3e	; 62
     34e:	28 97       	sbiw	r28, 0x08	; 8
     350:	cd bf       	out	0x3d, r28	; 61
     352:	de bf       	out	0x3e, r29	; 62
	TCC1.CTRLA = 0x00; //turn off the counter while synching
     354:	80 e4       	ldi	r24, 0x40	; 64
     356:	98 e0       	ldi	r25, 0x08	; 8
     358:	fc 01       	movw	r30, r24
     35a:	10 82       	st	Z, r1
	TCD1.CTRLA = 0x00;
     35c:	80 e4       	ldi	r24, 0x40	; 64
     35e:	99 e0       	ldi	r25, 0x09	; 9
     360:	fc 01       	movw	r30, r24
     362:	10 82       	st	Z, r1
	//TCC1.CTRLFSET = 0x0C;	//reset the value of the counter to 0
	//TCD1.CTRLFSET = 0x0C;
	RadioMonitorMode = TIME_SYNCH;
     364:	82 e0       	ldi	r24, 0x02	; 2
     366:	80 93 5f 40 	sts	0x405F, r24
	unsigned char message[8];
	strcpy(message,"reset");
     36a:	ce 01       	movw	r24, r28
     36c:	01 96       	adiw	r24, 0x01	; 1
     36e:	20 e0       	ldi	r18, 0x00	; 0
     370:	30 e2       	ldi	r19, 0x20	; 32
     372:	46 e0       	ldi	r20, 0x06	; 6
     374:	f9 01       	movw	r30, r18
     376:	00 80       	ld	r0, Z
     378:	2f 5f       	subi	r18, 0xFF	; 255
     37a:	3f 4f       	sbci	r19, 0xFF	; 255
     37c:	fc 01       	movw	r30, r24
     37e:	00 82       	st	Z, r0
     380:	01 96       	adiw	r24, 0x01	; 1
     382:	41 50       	subi	r20, 0x01	; 1
     384:	44 23       	and	r20, r20
     386:	b1 f7       	brne	.-20     	; 0x374 <__vector_83+0x58>
	itoa((int)(moteID),buff,10);
     388:	80 91 d1 50 	lds	r24, 0x50D1
     38c:	88 2f       	mov	r24, r24
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	22 e5       	ldi	r18, 0x52	; 82
     392:	30 e4       	ldi	r19, 0x40	; 64
     394:	b9 01       	movw	r22, r18
     396:	4a e0       	ldi	r20, 0x0A	; 10
     398:	50 e0       	ldi	r21, 0x00	; 0
     39a:	0e 94 82 5c 	call	0xb904	; 0xb904 <itoa>
	strcat(message,buff);
     39e:	22 e5       	ldi	r18, 0x52	; 82
     3a0:	30 e4       	ldi	r19, 0x40	; 64
     3a2:	ce 01       	movw	r24, r28
     3a4:	01 96       	adiw	r24, 0x01	; 1
     3a6:	b9 01       	movw	r22, r18
     3a8:	0e 94 69 5c 	call	0xb8d2	; 0xb8d2 <strcat>
	ADC_Pause_Sampling();	//pause the ADC while synching
     3ac:	0e 94 3a 0a 	call	0x1474	; 0x1474 <ADC_Pause_Sampling>
	chb_write(0x0000,message,strlen(message));
     3b0:	ce 01       	movw	r24, r28
     3b2:	01 96       	adiw	r24, 0x01	; 1
     3b4:	9c 01       	movw	r18, r24
     3b6:	f9 01       	movw	r30, r18
     3b8:	01 90       	ld	r0, Z+
     3ba:	00 20       	and	r0, r0
     3bc:	e9 f7       	brne	.-6      	; 0x3b8 <__vector_83+0x9c>
     3be:	cf 01       	movw	r24, r30
     3c0:	01 97       	sbiw	r24, 0x01	; 1
     3c2:	82 1b       	sub	r24, r18
     3c4:	93 0b       	sbc	r25, r19
     3c6:	9c 01       	movw	r18, r24
     3c8:	40 e0       	ldi	r20, 0x00	; 0
     3ca:	50 e0       	ldi	r21, 0x00	; 0
     3cc:	80 e0       	ldi	r24, 0x00	; 0
     3ce:	90 e0       	ldi	r25, 0x00	; 0
     3d0:	be 01       	movw	r22, r28
     3d2:	6f 5f       	subi	r22, 0xFF	; 255
     3d4:	7f 4f       	sbci	r23, 0xFF	; 255
     3d6:	0e 94 57 1e 	call	0x3cae	; 0x3cae <chb_write>
}	
     3da:	28 96       	adiw	r28, 0x08	; 8
     3dc:	cd bf       	out	0x3d, r28	; 61
     3de:	de bf       	out	0x3e, r29	; 62
     3e0:	df 91       	pop	r29
     3e2:	cf 91       	pop	r28
     3e4:	ff 91       	pop	r31
     3e6:	ef 91       	pop	r30
     3e8:	bf 91       	pop	r27
     3ea:	af 91       	pop	r26
     3ec:	9f 91       	pop	r25
     3ee:	8f 91       	pop	r24
     3f0:	7f 91       	pop	r23
     3f2:	6f 91       	pop	r22
     3f4:	5f 91       	pop	r21
     3f6:	4f 91       	pop	r20
     3f8:	3f 91       	pop	r19
     3fa:	2f 91       	pop	r18
     3fc:	0f 90       	pop	r0
     3fe:	00 92 3b 00 	sts	0x003B, r0
     402:	0f 90       	pop	r0
     404:	0f be       	out	0x3f, r0	; 63
     406:	0f 90       	pop	r0
     408:	1f 90       	pop	r1
     40a:	18 95       	reti

0000040c <main>:

#include "E-000001-000009_firmware_rev_1_0.h"



int main(){
     40c:	cf 92       	push	r12
     40e:	df 92       	push	r13
     410:	ef 92       	push	r14
     412:	ff 92       	push	r15
     414:	0f 93       	push	r16
     416:	1f 93       	push	r17
     418:	cf 93       	push	r28
     41a:	df 93       	push	r29
     41c:	cd b7       	in	r28, 0x3d	; 61
     41e:	de b7       	in	r29, 0x3e	; 62
     420:	cc 5a       	subi	r28, 0xAC	; 172
     422:	d8 40       	sbci	r29, 0x08	; 8
     424:	cd bf       	out	0x3d, r28	; 61
     426:	de bf       	out	0x3e, r29	; 62
	while(1){
		//if(RadioMonitorMode == TIME_SYNCH) chb_write(0x0000,message,strlen(message));
		nop();
	}
	*/
	SD_init();
     428:	0e 94 05 4b 	call	0x960a	; 0x960a <SD_init>
	getBootSectorData();
     42c:	0e 94 05 3f 	call	0x7e0a	; 0x7e0a <getBootSectorData>
	set_32MHz();
     430:	0e 94 5e 31 	call	0x62bc	; 0x62bc <set_32MHz>
	while(1){
		CO_collectADC(ADC_CH_1_gc,(uint8_t) (FILTER_CH_1AND5_bm | FILTER_HP_0_bm | FILTER_LP_600_gc),GAIN_1_gc,SPS_1K_gc,128,SampledData);
     434:	80 e0       	ldi	r24, 0x00	; 0
     436:	61 ec       	ldi	r22, 0xC1	; 193
     438:	40 e0       	ldi	r20, 0x00	; 0
     43a:	2a e0       	ldi	r18, 0x0A	; 10
     43c:	ee 24       	eor	r14, r14
     43e:	ff 24       	eor	r15, r15
     440:	87 01       	movw	r16, r14
     442:	68 94       	set
     444:	e7 f8       	bld	r14, 7
     446:	fe 01       	movw	r30, r28
     448:	31 96       	adiw	r30, 0x01	; 1
     44a:	6f 01       	movw	r12, r30
     44c:	0e 94 c8 08 	call	0x1190	; 0x1190 <CO_collectADC>
		DeciToString(SampledData,128,SampledDataInChars);
     450:	9e 01       	movw	r18, r28
     452:	27 5f       	subi	r18, 0xF7	; 247
     454:	3d 4f       	sbci	r19, 0xFD	; 253
     456:	ce 01       	movw	r24, r28
     458:	01 96       	adiw	r24, 0x01	; 1
     45a:	40 e8       	ldi	r20, 0x80	; 128
     45c:	50 e0       	ldi	r21, 0x00	; 0
     45e:	60 e0       	ldi	r22, 0x00	; 0
     460:	70 e0       	ldi	r23, 0x00	; 0
     462:	0e 94 7f 3e 	call	0x7cfe	; 0x7cfe <DeciToString>
		writeFile("samples",SampledDataInChars,1700);	
     466:	86 e0       	ldi	r24, 0x06	; 6
     468:	90 e2       	ldi	r25, 0x20	; 32
     46a:	9e 01       	movw	r18, r28
     46c:	27 5f       	subi	r18, 0xF7	; 247
     46e:	3d 4f       	sbci	r19, 0xFD	; 253
     470:	b9 01       	movw	r22, r18
     472:	24 ea       	ldi	r18, 0xA4	; 164
     474:	36 e0       	ldi	r19, 0x06	; 6
     476:	40 e0       	ldi	r20, 0x00	; 0
     478:	50 e0       	ldi	r21, 0x00	; 0
     47a:	0e 94 9a 45 	call	0x8b34	; 0x8b34 <writeFile>
	}		
     47e:	da cf       	rjmp	.-76     	; 0x434 <main+0x28>

00000480 <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test


void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     480:	cf 93       	push	r28
     482:	df 93       	push	r29
     484:	cd b7       	in	r28, 0x3d	; 61
     486:	de b7       	in	r29, 0x3e	; 62
     488:	6b 97       	sbiw	r28, 0x1b	; 27
     48a:	cd bf       	out	0x3d, r28	; 61
     48c:	de bf       	out	0x3e, r29	; 62
     48e:	8e 8b       	std	Y+22, r24	; 0x16
     490:	9f 8b       	std	Y+23, r25	; 0x17
     492:	68 8f       	std	Y+24, r22	; 0x18
     494:	79 8f       	std	Y+25, r23	; 0x19
     496:	4a 8f       	std	Y+26, r20	; 0x1a
     498:	5b 8f       	std	Y+27, r21	; 0x1b
	uint32_t sum = 0;
     49a:	19 82       	std	Y+1, r1	; 0x01
     49c:	1a 82       	std	Y+2, r1	; 0x02
     49e:	1b 82       	std	Y+3, r1	; 0x03
     4a0:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     4a2:	80 e0       	ldi	r24, 0x00	; 0
     4a4:	90 e1       	ldi	r25, 0x10	; 16
     4a6:	a0 e0       	ldi	r26, 0x00	; 0
     4a8:	b0 e0       	ldi	r27, 0x00	; 0
     4aa:	8d 83       	std	Y+5, r24	; 0x05
     4ac:	9e 83       	std	Y+6, r25	; 0x06
     4ae:	af 83       	std	Y+7, r26	; 0x07
     4b0:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     4b2:	19 86       	std	Y+9, r1	; 0x09
     4b4:	1a 86       	std	Y+10, r1	; 0x0a
     4b6:	1b 86       	std	Y+11, r1	; 0x0b
     4b8:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     4ba:	81 e0       	ldi	r24, 0x01	; 1
     4bc:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     4c0:	80 e0       	ldi	r24, 0x00	; 0
     4c2:	92 e0       	ldi	r25, 0x02	; 2
     4c4:	0e 94 ed 19 	call	0x33da	; 0x33da <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     4c8:	80 e0       	ldi	r24, 0x00	; 0
     4ca:	92 e0       	ldi	r25, 0x02	; 2
     4cc:	20 e0       	ldi	r18, 0x00	; 0
     4ce:	32 e0       	ldi	r19, 0x02	; 2
     4d0:	f9 01       	movw	r30, r18
     4d2:	21 81       	ldd	r18, Z+1	; 0x01
     4d4:	29 7e       	andi	r18, 0xE9	; 233
     4d6:	fc 01       	movw	r30, r24
     4d8:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     4da:	80 e0       	ldi	r24, 0x00	; 0
     4dc:	92 e0       	ldi	r25, 0x02	; 2
     4de:	20 e0       	ldi	r18, 0x00	; 0
     4e0:	32 e0       	ldi	r19, 0x02	; 2
     4e2:	f9 01       	movw	r30, r18
     4e4:	24 81       	ldd	r18, Z+4	; 0x04
     4e6:	28 7f       	andi	r18, 0xF8	; 248
     4e8:	23 60       	ori	r18, 0x03	; 3
     4ea:	fc 01       	movw	r30, r24
     4ec:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     4ee:	80 e0       	ldi	r24, 0x00	; 0
     4f0:	92 e0       	ldi	r25, 0x02	; 2
     4f2:	20 e0       	ldi	r18, 0x00	; 0
     4f4:	32 e0       	ldi	r19, 0x02	; 2
     4f6:	f9 01       	movw	r30, r18
     4f8:	22 81       	ldd	r18, Z+2	; 0x02
     4fa:	2f 7c       	andi	r18, 0xCF	; 207
     4fc:	fc 01       	movw	r30, r24
     4fe:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     500:	80 e2       	ldi	r24, 0x20	; 32
     502:	92 e0       	ldi	r25, 0x02	; 2
     504:	20 e2       	ldi	r18, 0x20	; 32
     506:	32 e0       	ldi	r19, 0x02	; 2
     508:	f9 01       	movw	r30, r18
     50a:	20 81       	ld	r18, Z
     50c:	20 7e       	andi	r18, 0xE0	; 224
     50e:	21 60       	ori	r18, 0x01	; 1
     510:	fc 01       	movw	r30, r24
     512:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     514:	80 e2       	ldi	r24, 0x20	; 32
     516:	92 e0       	ldi	r25, 0x02	; 2
     518:	29 e0       	ldi	r18, 0x09	; 9
     51a:	fc 01       	movw	r30, r24
     51c:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCA);
     51e:	80 e0       	ldi	r24, 0x00	; 0
     520:	92 e0       	ldi	r25, 0x02	; 2
     522:	20 e0       	ldi	r18, 0x00	; 0
     524:	32 e0       	ldi	r19, 0x02	; 2
     526:	f9 01       	movw	r30, r18
     528:	20 81       	ld	r18, Z
     52a:	21 60       	ori	r18, 0x01	; 1
     52c:	fc 01       	movw	r30, r24
     52e:	20 83       	st	Z, r18
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     530:	80 e0       	ldi	r24, 0x00	; 0
     532:	92 e0       	ldi	r25, 0x02	; 2
     534:	0e 94 a5 1b 	call	0x374a	; 0x374a <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     538:	80 e0       	ldi	r24, 0x00	; 0
     53a:	92 e0       	ldi	r25, 0x02	; 2
     53c:	60 e2       	ldi	r22, 0x20	; 32
     53e:	72 e0       	ldi	r23, 0x02	; 2
     540:	40 e0       	ldi	r20, 0x00	; 0
     542:	0e 94 9c 1c 	call	0x3938	; 0x3938 <ADC_Offset_Get_Unsigned>
     546:	8d 8b       	std	Y+21, r24	; 0x15
    ADC_Disable(&ADCA);
     548:	80 e0       	ldi	r24, 0x00	; 0
     54a:	92 e0       	ldi	r25, 0x02	; 2
     54c:	20 e0       	ldi	r18, 0x00	; 0
     54e:	32 e0       	ldi	r19, 0x02	; 2
     550:	f9 01       	movw	r30, r18
     552:	20 81       	ld	r18, Z
     554:	2e 7f       	andi	r18, 0xFE	; 254
     556:	fc 01       	movw	r30, r24
     558:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     55a:	80 e2       	ldi	r24, 0x20	; 32
     55c:	92 e0       	ldi	r25, 0x02	; 2
     55e:	fc 01       	movw	r30, r24
     560:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     562:	80 e0       	ldi	r24, 0x00	; 0
     564:	92 e0       	ldi	r25, 0x02	; 2
     566:	20 e0       	ldi	r18, 0x00	; 0
     568:	32 e0       	ldi	r19, 0x02	; 2
     56a:	f9 01       	movw	r30, r18
     56c:	23 81       	ldd	r18, Z+3	; 0x03
     56e:	2f 73       	andi	r18, 0x3F	; 63
     570:	fc 01       	movw	r30, r24
     572:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     574:	80 e0       	ldi	r24, 0x00	; 0
     576:	92 e0       	ldi	r25, 0x02	; 2
     578:	20 e0       	ldi	r18, 0x00	; 0
     57a:	32 e0       	ldi	r19, 0x02	; 2
     57c:	f9 01       	movw	r30, r18
     57e:	20 81       	ld	r18, Z
     580:	21 60       	ori	r18, 0x01	; 1
     582:	fc 01       	movw	r30, r24
     584:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     586:	80 e0       	ldi	r24, 0x00	; 0
     588:	92 e0       	ldi	r25, 0x02	; 2
     58a:	0e 94 a5 1b 	call	0x374a	; 0x374a <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     58e:	80 e0       	ldi	r24, 0x00	; 0
     590:	92 e0       	ldi	r25, 0x02	; 2
     592:	20 e0       	ldi	r18, 0x00	; 0
     594:	32 e0       	ldi	r19, 0x02	; 2
     596:	f9 01       	movw	r30, r18
     598:	21 81       	ldd	r18, Z+1	; 0x01
     59a:	28 60       	ori	r18, 0x08	; 8
     59c:	fc 01       	movw	r30, r24
     59e:	21 83       	std	Z+1, r18	; 0x01

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     5a0:	1d 86       	std	Y+13, r1	; 0x0d
     5a2:	1e 86       	std	Y+14, r1	; 0x0e
     5a4:	56 c0       	rjmp	.+172    	; 0x652 <CO_collectTemp+0x1d2>

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     5a6:	80 e2       	ldi	r24, 0x20	; 32
     5a8:	92 e0       	ldi	r25, 0x02	; 2
     5aa:	fc 01       	movw	r30, r24
     5ac:	83 81       	ldd	r24, Z+3	; 0x03
     5ae:	88 2f       	mov	r24, r24
     5b0:	90 e0       	ldi	r25, 0x00	; 0
     5b2:	81 70       	andi	r24, 0x01	; 1
     5b4:	90 70       	andi	r25, 0x00	; 0
     5b6:	00 97       	sbiw	r24, 0x00	; 0
     5b8:	b1 f3       	breq	.-20     	; 0x5a6 <CO_collectTemp+0x126>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     5ba:	2d 89       	ldd	r18, Y+21	; 0x15
     5bc:	80 e2       	ldi	r24, 0x20	; 32
     5be:	92 e0       	ldi	r25, 0x02	; 2
     5c0:	62 2f       	mov	r22, r18
     5c2:	0e 94 46 1a 	call	0x348c	; 0x348c <ADC_ResultCh_GetWord_Signed>
     5c6:	8f 87       	std	Y+15, r24	; 0x0f
     5c8:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResult;
     5ca:	8f 85       	ldd	r24, Y+15	; 0x0f
     5cc:	98 89       	ldd	r25, Y+16	; 0x10
     5ce:	cc 01       	movw	r24, r24
     5d0:	a0 e0       	ldi	r26, 0x00	; 0
     5d2:	b0 e0       	ldi	r27, 0x00	; 0
     5d4:	29 81       	ldd	r18, Y+1	; 0x01
     5d6:	3a 81       	ldd	r19, Y+2	; 0x02
     5d8:	4b 81       	ldd	r20, Y+3	; 0x03
     5da:	5c 81       	ldd	r21, Y+4	; 0x04
     5dc:	82 0f       	add	r24, r18
     5de:	93 1f       	adc	r25, r19
     5e0:	a4 1f       	adc	r26, r20
     5e2:	b5 1f       	adc	r27, r21
     5e4:	89 83       	std	Y+1, r24	; 0x01
     5e6:	9a 83       	std	Y+2, r25	; 0x02
     5e8:	ab 83       	std	Y+3, r26	; 0x03
     5ea:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResult) { max = tempResult;}
     5ec:	8f 85       	ldd	r24, Y+15	; 0x0f
     5ee:	98 89       	ldd	r25, Y+16	; 0x10
     5f0:	9c 01       	movw	r18, r24
     5f2:	40 e0       	ldi	r20, 0x00	; 0
     5f4:	50 e0       	ldi	r21, 0x00	; 0
     5f6:	89 85       	ldd	r24, Y+9	; 0x09
     5f8:	9a 85       	ldd	r25, Y+10	; 0x0a
     5fa:	ab 85       	ldd	r26, Y+11	; 0x0b
     5fc:	bc 85       	ldd	r27, Y+12	; 0x0c
     5fe:	82 17       	cp	r24, r18
     600:	93 07       	cpc	r25, r19
     602:	a4 07       	cpc	r26, r20
     604:	b5 07       	cpc	r27, r21
     606:	48 f4       	brcc	.+18     	; 0x61a <CO_collectTemp+0x19a>
     608:	8f 85       	ldd	r24, Y+15	; 0x0f
     60a:	98 89       	ldd	r25, Y+16	; 0x10
     60c:	cc 01       	movw	r24, r24
     60e:	a0 e0       	ldi	r26, 0x00	; 0
     610:	b0 e0       	ldi	r27, 0x00	; 0
     612:	89 87       	std	Y+9, r24	; 0x09
     614:	9a 87       	std	Y+10, r25	; 0x0a
     616:	ab 87       	std	Y+11, r26	; 0x0b
     618:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResult) { min = tempResult;}
     61a:	8f 85       	ldd	r24, Y+15	; 0x0f
     61c:	98 89       	ldd	r25, Y+16	; 0x10
     61e:	9c 01       	movw	r18, r24
     620:	40 e0       	ldi	r20, 0x00	; 0
     622:	50 e0       	ldi	r21, 0x00	; 0
     624:	8d 81       	ldd	r24, Y+5	; 0x05
     626:	9e 81       	ldd	r25, Y+6	; 0x06
     628:	af 81       	ldd	r26, Y+7	; 0x07
     62a:	b8 85       	ldd	r27, Y+8	; 0x08
     62c:	28 17       	cp	r18, r24
     62e:	39 07       	cpc	r19, r25
     630:	4a 07       	cpc	r20, r26
     632:	5b 07       	cpc	r21, r27
     634:	48 f4       	brcc	.+18     	; 0x648 <CO_collectTemp+0x1c8>
     636:	8f 85       	ldd	r24, Y+15	; 0x0f
     638:	98 89       	ldd	r25, Y+16	; 0x10
     63a:	cc 01       	movw	r24, r24
     63c:	a0 e0       	ldi	r26, 0x00	; 0
     63e:	b0 e0       	ldi	r27, 0x00	; 0
     640:	8d 83       	std	Y+5, r24	; 0x05
     642:	9e 83       	std	Y+6, r25	; 0x06
     644:	af 83       	std	Y+7, r26	; 0x07
     646:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     648:	8d 85       	ldd	r24, Y+13	; 0x0d
     64a:	9e 85       	ldd	r25, Y+14	; 0x0e
     64c:	01 96       	adiw	r24, 0x01	; 1
     64e:	8d 87       	std	Y+13, r24	; 0x0d
     650:	9e 87       	std	Y+14, r25	; 0x0e
     652:	8d 85       	ldd	r24, Y+13	; 0x0d
     654:	9e 85       	ldd	r25, Y+14	; 0x0e
     656:	f4 e0       	ldi	r31, 0x04	; 4
     658:	80 30       	cpi	r24, 0x00	; 0
     65a:	9f 07       	cpc	r25, r31
     65c:	08 f4       	brcc	.+2      	; 0x660 <CO_collectTemp+0x1e0>
     65e:	a3 cf       	rjmp	.-186    	; 0x5a6 <CO_collectTemp+0x126>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     660:	80 e0       	ldi	r24, 0x00	; 0
     662:	92 e0       	ldi	r25, 0x02	; 2
     664:	20 e0       	ldi	r18, 0x00	; 0
     666:	32 e0       	ldi	r19, 0x02	; 2
     668:	f9 01       	movw	r30, r18
     66a:	21 81       	ldd	r18, Z+1	; 0x01
     66c:	27 7f       	andi	r18, 0xF7	; 247
     66e:	fc 01       	movw	r30, r24
     670:	21 83       	std	Z+1, r18	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     672:	80 e0       	ldi	r24, 0x00	; 0
     674:	92 e0       	ldi	r25, 0x02	; 2
     676:	20 e0       	ldi	r18, 0x00	; 0
     678:	32 e0       	ldi	r19, 0x02	; 2
     67a:	f9 01       	movw	r30, r18
     67c:	20 81       	ld	r18, Z
     67e:	22 60       	ori	r18, 0x02	; 2
     680:	fc 01       	movw	r30, r24
     682:	20 83       	st	Z, r18
	ADC_Disable(&ADCA);
     684:	80 e0       	ldi	r24, 0x00	; 0
     686:	92 e0       	ldi	r25, 0x02	; 2
     688:	20 e0       	ldi	r18, 0x00	; 0
     68a:	32 e0       	ldi	r19, 0x02	; 2
     68c:	f9 01       	movw	r30, r18
     68e:	20 81       	ld	r18, Z
     690:	2e 7f       	andi	r18, 0xFE	; 254
     692:	fc 01       	movw	r30, r24
     694:	20 83       	st	Z, r18

	ADCPower(FALSE);
     696:	80 e0       	ldi	r24, 0x00	; 0
     698:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>

	average = sum / NUM_SAMPLES;
     69c:	89 81       	ldd	r24, Y+1	; 0x01
     69e:	9a 81       	ldd	r25, Y+2	; 0x02
     6a0:	ab 81       	ldd	r26, Y+3	; 0x03
     6a2:	bc 81       	ldd	r27, Y+4	; 0x04
     6a4:	07 2e       	mov	r0, r23
     6a6:	7a e0       	ldi	r23, 0x0A	; 10
     6a8:	b6 95       	lsr	r27
     6aa:	a7 95       	ror	r26
     6ac:	97 95       	ror	r25
     6ae:	87 95       	ror	r24
     6b0:	7a 95       	dec	r23
     6b2:	d1 f7       	brne	.-12     	; 0x6a8 <CO_collectTemp+0x228>
     6b4:	70 2d       	mov	r23, r0
     6b6:	89 8b       	std	Y+17, r24	; 0x11
     6b8:	9a 8b       	std	Y+18, r25	; 0x12
     6ba:	ab 8b       	std	Y+19, r26	; 0x13
     6bc:	bc 8b       	std	Y+20, r27	; 0x14

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     6be:	89 89       	ldd	r24, Y+17	; 0x11
     6c0:	9a 89       	ldd	r25, Y+18	; 0x12
     6c2:	ab 89       	ldd	r26, Y+19	; 0x13
     6c4:	bc 89       	ldd	r27, Y+20	; 0x14
     6c6:	28 ee       	ldi	r18, 0xE8	; 232
     6c8:	33 e0       	ldi	r19, 0x03	; 3
     6ca:	40 e0       	ldi	r20, 0x00	; 0
     6cc:	50 e0       	ldi	r21, 0x00	; 0
     6ce:	bc 01       	movw	r22, r24
     6d0:	cd 01       	movw	r24, r26
     6d2:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
     6d6:	dc 01       	movw	r26, r24
     6d8:	cb 01       	movw	r24, r22
     6da:	2f ef       	ldi	r18, 0xFF	; 255
     6dc:	3f e0       	ldi	r19, 0x0F	; 15
     6de:	40 e0       	ldi	r20, 0x00	; 0
     6e0:	50 e0       	ldi	r21, 0x00	; 0
     6e2:	bc 01       	movw	r22, r24
     6e4:	cd 01       	movw	r24, r26
     6e6:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
     6ea:	da 01       	movw	r26, r20
     6ec:	c9 01       	movw	r24, r18
     6ee:	9c 01       	movw	r18, r24
     6f0:	22 53       	subi	r18, 0x32	; 50
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	8e 89       	ldd	r24, Y+22	; 0x16
     6f6:	9f 89       	ldd	r25, Y+23	; 0x17
     6f8:	fc 01       	movw	r30, r24
     6fa:	20 83       	st	Z, r18
     6fc:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     6fe:	89 85       	ldd	r24, Y+9	; 0x09
     700:	9a 85       	ldd	r25, Y+10	; 0x0a
     702:	ab 85       	ldd	r26, Y+11	; 0x0b
     704:	bc 85       	ldd	r27, Y+12	; 0x0c
     706:	28 ee       	ldi	r18, 0xE8	; 232
     708:	33 e0       	ldi	r19, 0x03	; 3
     70a:	40 e0       	ldi	r20, 0x00	; 0
     70c:	50 e0       	ldi	r21, 0x00	; 0
     70e:	bc 01       	movw	r22, r24
     710:	cd 01       	movw	r24, r26
     712:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
     716:	dc 01       	movw	r26, r24
     718:	cb 01       	movw	r24, r22
     71a:	2f ef       	ldi	r18, 0xFF	; 255
     71c:	3f e0       	ldi	r19, 0x0F	; 15
     71e:	40 e0       	ldi	r20, 0x00	; 0
     720:	50 e0       	ldi	r21, 0x00	; 0
     722:	bc 01       	movw	r22, r24
     724:	cd 01       	movw	r24, r26
     726:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
     72a:	da 01       	movw	r26, r20
     72c:	c9 01       	movw	r24, r18
     72e:	9c 01       	movw	r18, r24
     730:	22 53       	subi	r18, 0x32	; 50
     732:	30 40       	sbci	r19, 0x00	; 0
     734:	8a 8d       	ldd	r24, Y+26	; 0x1a
     736:	9b 8d       	ldd	r25, Y+27	; 0x1b
     738:	fc 01       	movw	r30, r24
     73a:	20 83       	st	Z, r18
     73c:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     73e:	8d 81       	ldd	r24, Y+5	; 0x05
     740:	9e 81       	ldd	r25, Y+6	; 0x06
     742:	af 81       	ldd	r26, Y+7	; 0x07
     744:	b8 85       	ldd	r27, Y+8	; 0x08
     746:	28 ee       	ldi	r18, 0xE8	; 232
     748:	33 e0       	ldi	r19, 0x03	; 3
     74a:	40 e0       	ldi	r20, 0x00	; 0
     74c:	50 e0       	ldi	r21, 0x00	; 0
     74e:	bc 01       	movw	r22, r24
     750:	cd 01       	movw	r24, r26
     752:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
     756:	dc 01       	movw	r26, r24
     758:	cb 01       	movw	r24, r22
     75a:	2f ef       	ldi	r18, 0xFF	; 255
     75c:	3f e0       	ldi	r19, 0x0F	; 15
     75e:	40 e0       	ldi	r20, 0x00	; 0
     760:	50 e0       	ldi	r21, 0x00	; 0
     762:	bc 01       	movw	r22, r24
     764:	cd 01       	movw	r24, r26
     766:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
     76a:	da 01       	movw	r26, r20
     76c:	c9 01       	movw	r24, r18
     76e:	9c 01       	movw	r18, r24
     770:	22 53       	subi	r18, 0x32	; 50
     772:	30 40       	sbci	r19, 0x00	; 0
     774:	88 8d       	ldd	r24, Y+24	; 0x18
     776:	99 8d       	ldd	r25, Y+25	; 0x19
     778:	fc 01       	movw	r30, r24
     77a:	20 83       	st	Z, r18
     77c:	31 83       	std	Z+1, r19	; 0x01
}
     77e:	6b 96       	adiw	r28, 0x1b	; 27
     780:	cd bf       	out	0x3d, r28	; 61
     782:	de bf       	out	0x3e, r29	; 62
     784:	df 91       	pop	r29
     786:	cf 91       	pop	r28
     788:	08 95       	ret

0000078a <CO_collectBatt>:

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     78a:	0f 93       	push	r16
     78c:	1f 93       	push	r17
     78e:	cf 93       	push	r28
     790:	df 93       	push	r29
     792:	cd b7       	in	r28, 0x3d	; 61
     794:	de b7       	in	r29, 0x3e	; 62
     796:	a9 97       	sbiw	r28, 0x29	; 41
     798:	cd bf       	out	0x3d, r28	; 61
     79a:	de bf       	out	0x3e, r29	; 62
     79c:	8c a3       	lds	r24, 0x5c
     79e:	9d a3       	lds	r25, 0x5d
     7a0:	6e a3       	lds	r22, 0x5e
     7a2:	7f a3       	lds	r23, 0x5f
     7a4:	48 a7       	lds	r20, 0x78
     7a6:	59 a7       	lds	r21, 0x79
	uint32_t sum = 0;
     7a8:	19 82       	std	Y+1, r1	; 0x01
     7aa:	1a 82       	std	Y+2, r1	; 0x02
     7ac:	1b 82       	std	Y+3, r1	; 0x03
     7ae:	1c 82       	std	Y+4, r1	; 0x04
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     7b0:	80 e0       	ldi	r24, 0x00	; 0
     7b2:	90 e1       	ldi	r25, 0x10	; 16
     7b4:	a0 e0       	ldi	r26, 0x00	; 0
     7b6:	b0 e0       	ldi	r27, 0x00	; 0
     7b8:	8d 83       	std	Y+5, r24	; 0x05
     7ba:	9e 83       	std	Y+6, r25	; 0x06
     7bc:	af 83       	std	Y+7, r26	; 0x07
     7be:	b8 87       	std	Y+8, r27	; 0x08
	uint32_t max = 0;
     7c0:	19 86       	std	Y+9, r1	; 0x09
     7c2:	1a 86       	std	Y+10, r1	; 0x0a
     7c4:	1b 86       	std	Y+11, r1	; 0x0b
     7c6:	1c 86       	std	Y+12, r1	; 0x0c
	volatile int8_t offset;	

	ADCPower(TRUE);
     7c8:	81 e0       	ldi	r24, 0x01	; 1
     7ca:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     7ce:	84 e0       	ldi	r24, 0x04	; 4
     7d0:	60 e0       	ldi	r22, 0x00	; 0
     7d2:	0e 94 77 32 	call	0x64ee	; 0x64ee <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     7d6:	84 e0       	ldi	r24, 0x04	; 4
     7d8:	60 e0       	ldi	r22, 0x00	; 0
     7da:	0e 94 43 33 	call	0x6686	; 0x6686 <PortEx_OUTSET>
     7de:	80 e0       	ldi	r24, 0x00	; 0
     7e0:	90 e0       	ldi	r25, 0x00	; 0
     7e2:	a8 ec       	ldi	r26, 0xC8	; 200
     7e4:	b2 e4       	ldi	r27, 0x42	; 66
     7e6:	8d 8b       	std	Y+21, r24	; 0x15
     7e8:	9e 8b       	std	Y+22, r25	; 0x16
     7ea:	af 8b       	std	Y+23, r26	; 0x17
     7ec:	b8 8f       	std	Y+24, r27	; 0x18
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     7ee:	6d 89       	ldd	r22, Y+21	; 0x15
     7f0:	7e 89       	ldd	r23, Y+22	; 0x16
     7f2:	8f 89       	ldd	r24, Y+23	; 0x17
     7f4:	98 8d       	ldd	r25, Y+24	; 0x18
     7f6:	20 e0       	ldi	r18, 0x00	; 0
     7f8:	30 e0       	ldi	r19, 0x00	; 0
     7fa:	4a ef       	ldi	r20, 0xFA	; 250
     7fc:	55 e4       	ldi	r21, 0x45	; 69
     7fe:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
     802:	dc 01       	movw	r26, r24
     804:	cb 01       	movw	r24, r22
     806:	89 8f       	std	Y+25, r24	; 0x19
     808:	9a 8f       	std	Y+26, r25	; 0x1a
     80a:	ab 8f       	std	Y+27, r26	; 0x1b
     80c:	bc 8f       	std	Y+28, r27	; 0x1c
	if (__tmp < 1.0)
     80e:	11 e0       	ldi	r17, 0x01	; 1
     810:	69 8d       	ldd	r22, Y+25	; 0x19
     812:	7a 8d       	ldd	r23, Y+26	; 0x1a
     814:	8b 8d       	ldd	r24, Y+27	; 0x1b
     816:	9c 8d       	ldd	r25, Y+28	; 0x1c
     818:	20 e0       	ldi	r18, 0x00	; 0
     81a:	30 e0       	ldi	r19, 0x00	; 0
     81c:	40 e8       	ldi	r20, 0x80	; 128
     81e:	5f e3       	ldi	r21, 0x3F	; 63
     820:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
     824:	88 23       	and	r24, r24
     826:	0c f0       	brlt	.+2      	; 0x82a <CO_collectBatt+0xa0>
     828:	10 e0       	ldi	r17, 0x00	; 0
     82a:	11 23       	and	r17, r17
     82c:	29 f0       	breq	.+10     	; 0x838 <CO_collectBatt+0xae>
		__ticks = 1;
     82e:	81 e0       	ldi	r24, 0x01	; 1
     830:	90 e0       	ldi	r25, 0x00	; 0
     832:	8d 8f       	std	Y+29, r24	; 0x1d
     834:	9e 8f       	std	Y+30, r25	; 0x1e
     836:	46 c0       	rjmp	.+140    	; 0x8c4 <CO_collectBatt+0x13a>
	else if (__tmp > 65535)
     838:	11 e0       	ldi	r17, 0x01	; 1
     83a:	69 8d       	ldd	r22, Y+25	; 0x19
     83c:	7a 8d       	ldd	r23, Y+26	; 0x1a
     83e:	8b 8d       	ldd	r24, Y+27	; 0x1b
     840:	9c 8d       	ldd	r25, Y+28	; 0x1c
     842:	20 e0       	ldi	r18, 0x00	; 0
     844:	3f ef       	ldi	r19, 0xFF	; 255
     846:	4f e7       	ldi	r20, 0x7F	; 127
     848:	57 e4       	ldi	r21, 0x47	; 71
     84a:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
     84e:	18 16       	cp	r1, r24
     850:	0c f0       	brlt	.+2      	; 0x854 <CO_collectBatt+0xca>
     852:	10 e0       	ldi	r17, 0x00	; 0
     854:	11 23       	and	r17, r17
     856:	61 f1       	breq	.+88     	; 0x8b0 <CO_collectBatt+0x126>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     858:	6d 89       	ldd	r22, Y+21	; 0x15
     85a:	7e 89       	ldd	r23, Y+22	; 0x16
     85c:	8f 89       	ldd	r24, Y+23	; 0x17
     85e:	98 8d       	ldd	r25, Y+24	; 0x18
     860:	20 e0       	ldi	r18, 0x00	; 0
     862:	30 e0       	ldi	r19, 0x00	; 0
     864:	40 e2       	ldi	r20, 0x20	; 32
     866:	51 e4       	ldi	r21, 0x41	; 65
     868:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
     86c:	dc 01       	movw	r26, r24
     86e:	cb 01       	movw	r24, r22
     870:	bc 01       	movw	r22, r24
     872:	cd 01       	movw	r24, r26
     874:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
     878:	dc 01       	movw	r26, r24
     87a:	cb 01       	movw	r24, r22
     87c:	8d 8f       	std	Y+29, r24	; 0x1d
     87e:	9e 8f       	std	Y+30, r25	; 0x1e
     880:	12 c0       	rjmp	.+36     	; 0x8a6 <CO_collectBatt+0x11c>
     882:	80 e2       	ldi	r24, 0x20	; 32
     884:	93 e0       	ldi	r25, 0x03	; 3
     886:	8f 8f       	std	Y+31, r24	; 0x1f
     888:	98 a3       	lds	r25, 0x58
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     88a:	8f 8d       	ldd	r24, Y+31	; 0x1f
     88c:	98 a1       	lds	r25, 0x48
     88e:	8c 01       	movw	r16, r24
     890:	c8 01       	movw	r24, r16
     892:	01 97       	sbiw	r24, 0x01	; 1
     894:	f1 f7       	brne	.-4      	; 0x892 <CO_collectBatt+0x108>
     896:	8c 01       	movw	r16, r24
     898:	0f 8f       	std	Y+31, r16	; 0x1f
     89a:	18 a3       	lds	r17, 0x58
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     89c:	8d 8d       	ldd	r24, Y+29	; 0x1d
     89e:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8a0:	01 97       	sbiw	r24, 0x01	; 1
     8a2:	8d 8f       	std	Y+29, r24	; 0x1d
     8a4:	9e 8f       	std	Y+30, r25	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8a6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8a8:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8aa:	00 97       	sbiw	r24, 0x00	; 0
     8ac:	51 f7       	brne	.-44     	; 0x882 <CO_collectBatt+0xf8>
     8ae:	17 c0       	rjmp	.+46     	; 0x8de <CO_collectBatt+0x154>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     8b0:	69 8d       	ldd	r22, Y+25	; 0x19
     8b2:	7a 8d       	ldd	r23, Y+26	; 0x1a
     8b4:	8b 8d       	ldd	r24, Y+27	; 0x1b
     8b6:	9c 8d       	ldd	r25, Y+28	; 0x1c
     8b8:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
     8bc:	dc 01       	movw	r26, r24
     8be:	cb 01       	movw	r24, r22
     8c0:	8d 8f       	std	Y+29, r24	; 0x1d
     8c2:	9e 8f       	std	Y+30, r25	; 0x1e
     8c4:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8c6:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8c8:	89 a3       	lds	r24, 0x59
     8ca:	9a a3       	lds	r25, 0x5a
     8cc:	89 a1       	lds	r24, 0x49
     8ce:	9a a1       	lds	r25, 0x4a
     8d0:	8c 01       	movw	r16, r24
     8d2:	f8 01       	movw	r30, r16
     8d4:	31 97       	sbiw	r30, 0x01	; 1
     8d6:	f1 f7       	brne	.-4      	; 0x8d4 <CO_collectBatt+0x14a>
     8d8:	8f 01       	movw	r16, r30
     8da:	09 a3       	lds	r16, 0x59
     8dc:	1a a3       	lds	r17, 0x5a
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     8de:	80 e4       	ldi	r24, 0x40	; 64
     8e0:	92 e0       	ldi	r25, 0x02	; 2
     8e2:	0e 94 ed 19 	call	0x33da	; 0x33da <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     8e6:	80 e4       	ldi	r24, 0x40	; 64
     8e8:	92 e0       	ldi	r25, 0x02	; 2
     8ea:	20 e4       	ldi	r18, 0x40	; 64
     8ec:	32 e0       	ldi	r19, 0x02	; 2
     8ee:	f9 01       	movw	r30, r18
     8f0:	21 81       	ldd	r18, Z+1	; 0x01
     8f2:	29 7e       	andi	r18, 0xE9	; 233
     8f4:	fc 01       	movw	r30, r24
     8f6:	21 83       	std	Z+1, r18	; 0x01

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     8f8:	80 e4       	ldi	r24, 0x40	; 64
     8fa:	92 e0       	ldi	r25, 0x02	; 2
     8fc:	20 e4       	ldi	r18, 0x40	; 64
     8fe:	32 e0       	ldi	r19, 0x02	; 2
     900:	f9 01       	movw	r30, r18
     902:	24 81       	ldd	r18, Z+4	; 0x04
     904:	28 7f       	andi	r18, 0xF8	; 248
     906:	23 60       	ori	r18, 0x03	; 3
     908:	fc 01       	movw	r30, r24
     90a:	24 83       	std	Z+4, r18	; 0x04

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     90c:	80 e4       	ldi	r24, 0x40	; 64
     90e:	92 e0       	ldi	r25, 0x02	; 2
     910:	20 e4       	ldi	r18, 0x40	; 64
     912:	32 e0       	ldi	r19, 0x02	; 2
     914:	f9 01       	movw	r30, r18
     916:	22 81       	ldd	r18, Z+2	; 0x02
     918:	2f 7c       	andi	r18, 0xCF	; 207
     91a:	fc 01       	movw	r30, r24
     91c:	22 83       	std	Z+2, r18	; 0x02

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     91e:	80 e6       	ldi	r24, 0x60	; 96
     920:	92 e0       	ldi	r25, 0x02	; 2
     922:	20 e6       	ldi	r18, 0x60	; 96
     924:	32 e0       	ldi	r19, 0x02	; 2
     926:	f9 01       	movw	r30, r18
     928:	20 81       	ld	r18, Z
     92a:	20 7e       	andi	r18, 0xE0	; 224
     92c:	21 60       	ori	r18, 0x01	; 1
     92e:	fc 01       	movw	r30, r24
     930:	20 83       	st	Z, r18
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     932:	80 e6       	ldi	r24, 0x60	; 96
     934:	92 e0       	ldi	r25, 0x02	; 2
     936:	29 e0       	ldi	r18, 0x09	; 9
     938:	fc 01       	movw	r30, r24
     93a:	21 83       	std	Z+1, r18	; 0x01

	ADC_Enable(&ADCB);
     93c:	80 e4       	ldi	r24, 0x40	; 64
     93e:	92 e0       	ldi	r25, 0x02	; 2
     940:	20 e4       	ldi	r18, 0x40	; 64
     942:	32 e0       	ldi	r19, 0x02	; 2
     944:	f9 01       	movw	r30, r18
     946:	20 81       	ld	r18, Z
     948:	21 60       	ori	r18, 0x01	; 1
     94a:	fc 01       	movw	r30, r24
     94c:	20 83       	st	Z, r18
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     94e:	80 e4       	ldi	r24, 0x40	; 64
     950:	92 e0       	ldi	r25, 0x02	; 2
     952:	0e 94 a5 1b 	call	0x374a	; 0x374a <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     956:	80 e4       	ldi	r24, 0x40	; 64
     958:	92 e0       	ldi	r25, 0x02	; 2
     95a:	60 e6       	ldi	r22, 0x60	; 96
     95c:	72 e0       	ldi	r23, 0x02	; 2
     95e:	40 e0       	ldi	r20, 0x00	; 0
     960:	0e 94 9c 1c 	call	0x3938	; 0x3938 <ADC_Offset_Get_Unsigned>
     964:	8b a3       	lds	r24, 0x5b
    ADC_Disable(&ADCB);
     966:	80 e4       	ldi	r24, 0x40	; 64
     968:	92 e0       	ldi	r25, 0x02	; 2
     96a:	20 e4       	ldi	r18, 0x40	; 64
     96c:	32 e0       	ldi	r19, 0x02	; 2
     96e:	f9 01       	movw	r30, r18
     970:	20 81       	ld	r18, Z
     972:	2e 7f       	andi	r18, 0xFE	; 254
     974:	fc 01       	movw	r30, r24
     976:	20 83       	st	Z, r18
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     978:	80 e6       	ldi	r24, 0x60	; 96
     97a:	92 e0       	ldi	r25, 0x02	; 2
     97c:	fc 01       	movw	r30, r24
     97e:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     980:	80 e4       	ldi	r24, 0x40	; 64
     982:	92 e0       	ldi	r25, 0x02	; 2
     984:	20 e4       	ldi	r18, 0x40	; 64
     986:	32 e0       	ldi	r19, 0x02	; 2
     988:	f9 01       	movw	r30, r18
     98a:	23 81       	ldd	r18, Z+3	; 0x03
     98c:	2f 73       	andi	r18, 0x3F	; 63
     98e:	fc 01       	movw	r30, r24
     990:	23 83       	std	Z+3, r18	; 0x03

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     992:	80 e4       	ldi	r24, 0x40	; 64
     994:	92 e0       	ldi	r25, 0x02	; 2
     996:	20 e4       	ldi	r18, 0x40	; 64
     998:	32 e0       	ldi	r19, 0x02	; 2
     99a:	f9 01       	movw	r30, r18
     99c:	20 81       	ld	r18, Z
     99e:	21 60       	ori	r18, 0x01	; 1
     9a0:	fc 01       	movw	r30, r24
     9a2:	20 83       	st	Z, r18

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     9a4:	80 e4       	ldi	r24, 0x40	; 64
     9a6:	92 e0       	ldi	r25, 0x02	; 2
     9a8:	0e 94 a5 1b 	call	0x374a	; 0x374a <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     9ac:	80 e4       	ldi	r24, 0x40	; 64
     9ae:	92 e0       	ldi	r25, 0x02	; 2
     9b0:	20 e4       	ldi	r18, 0x40	; 64
     9b2:	32 e0       	ldi	r19, 0x02	; 2
     9b4:	f9 01       	movw	r30, r18
     9b6:	21 81       	ldd	r18, Z+1	; 0x01
     9b8:	28 60       	ori	r18, 0x08	; 8
     9ba:	fc 01       	movw	r30, r24
     9bc:	21 83       	std	Z+1, r18	; 0x01

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     9be:	1d 86       	std	Y+13, r1	; 0x0d
     9c0:	1e 86       	std	Y+14, r1	; 0x0e
     9c2:	56 c0       	rjmp	.+172    	; 0xa70 <CO_collectBatt+0x2e6>

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     9c4:	80 e6       	ldi	r24, 0x60	; 96
     9c6:	92 e0       	ldi	r25, 0x02	; 2
     9c8:	fc 01       	movw	r30, r24
     9ca:	83 81       	ldd	r24, Z+3	; 0x03
     9cc:	88 2f       	mov	r24, r24
     9ce:	90 e0       	ldi	r25, 0x00	; 0
     9d0:	81 70       	andi	r24, 0x01	; 1
     9d2:	90 70       	andi	r25, 0x00	; 0
     9d4:	00 97       	sbiw	r24, 0x00	; 0
     9d6:	b1 f3       	breq	.-20     	; 0x9c4 <CO_collectBatt+0x23a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     9d8:	2b a1       	lds	r18, 0x4b
     9da:	80 e6       	ldi	r24, 0x60	; 96
     9dc:	92 e0       	ldi	r25, 0x02	; 2
     9de:	62 2f       	mov	r22, r18
     9e0:	0e 94 46 1a 	call	0x348c	; 0x348c <ADC_ResultCh_GetWord_Signed>
     9e4:	8f 87       	std	Y+15, r24	; 0x0f
     9e6:	98 8b       	std	Y+16, r25	; 0x10
		sum+=tempResultB;
     9e8:	8f 85       	ldd	r24, Y+15	; 0x0f
     9ea:	98 89       	ldd	r25, Y+16	; 0x10
     9ec:	cc 01       	movw	r24, r24
     9ee:	a0 e0       	ldi	r26, 0x00	; 0
     9f0:	b0 e0       	ldi	r27, 0x00	; 0
     9f2:	29 81       	ldd	r18, Y+1	; 0x01
     9f4:	3a 81       	ldd	r19, Y+2	; 0x02
     9f6:	4b 81       	ldd	r20, Y+3	; 0x03
     9f8:	5c 81       	ldd	r21, Y+4	; 0x04
     9fa:	82 0f       	add	r24, r18
     9fc:	93 1f       	adc	r25, r19
     9fe:	a4 1f       	adc	r26, r20
     a00:	b5 1f       	adc	r27, r21
     a02:	89 83       	std	Y+1, r24	; 0x01
     a04:	9a 83       	std	Y+2, r25	; 0x02
     a06:	ab 83       	std	Y+3, r26	; 0x03
     a08:	bc 83       	std	Y+4, r27	; 0x04
		if (max < tempResultB) { max = tempResultB;}
     a0a:	8f 85       	ldd	r24, Y+15	; 0x0f
     a0c:	98 89       	ldd	r25, Y+16	; 0x10
     a0e:	9c 01       	movw	r18, r24
     a10:	40 e0       	ldi	r20, 0x00	; 0
     a12:	50 e0       	ldi	r21, 0x00	; 0
     a14:	89 85       	ldd	r24, Y+9	; 0x09
     a16:	9a 85       	ldd	r25, Y+10	; 0x0a
     a18:	ab 85       	ldd	r26, Y+11	; 0x0b
     a1a:	bc 85       	ldd	r27, Y+12	; 0x0c
     a1c:	82 17       	cp	r24, r18
     a1e:	93 07       	cpc	r25, r19
     a20:	a4 07       	cpc	r26, r20
     a22:	b5 07       	cpc	r27, r21
     a24:	48 f4       	brcc	.+18     	; 0xa38 <CO_collectBatt+0x2ae>
     a26:	8f 85       	ldd	r24, Y+15	; 0x0f
     a28:	98 89       	ldd	r25, Y+16	; 0x10
     a2a:	cc 01       	movw	r24, r24
     a2c:	a0 e0       	ldi	r26, 0x00	; 0
     a2e:	b0 e0       	ldi	r27, 0x00	; 0
     a30:	89 87       	std	Y+9, r24	; 0x09
     a32:	9a 87       	std	Y+10, r25	; 0x0a
     a34:	ab 87       	std	Y+11, r26	; 0x0b
     a36:	bc 87       	std	Y+12, r27	; 0x0c
		if (min > tempResultB) { min = tempResultB;}
     a38:	8f 85       	ldd	r24, Y+15	; 0x0f
     a3a:	98 89       	ldd	r25, Y+16	; 0x10
     a3c:	9c 01       	movw	r18, r24
     a3e:	40 e0       	ldi	r20, 0x00	; 0
     a40:	50 e0       	ldi	r21, 0x00	; 0
     a42:	8d 81       	ldd	r24, Y+5	; 0x05
     a44:	9e 81       	ldd	r25, Y+6	; 0x06
     a46:	af 81       	ldd	r26, Y+7	; 0x07
     a48:	b8 85       	ldd	r27, Y+8	; 0x08
     a4a:	28 17       	cp	r18, r24
     a4c:	39 07       	cpc	r19, r25
     a4e:	4a 07       	cpc	r20, r26
     a50:	5b 07       	cpc	r21, r27
     a52:	48 f4       	brcc	.+18     	; 0xa66 <CO_collectBatt+0x2dc>
     a54:	8f 85       	ldd	r24, Y+15	; 0x0f
     a56:	98 89       	ldd	r25, Y+16	; 0x10
     a58:	cc 01       	movw	r24, r24
     a5a:	a0 e0       	ldi	r26, 0x00	; 0
     a5c:	b0 e0       	ldi	r27, 0x00	; 0
     a5e:	8d 83       	std	Y+5, r24	; 0x05
     a60:	9e 83       	std	Y+6, r25	; 0x06
     a62:	af 83       	std	Y+7, r26	; 0x07
     a64:	b8 87       	std	Y+8, r27	; 0x08

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     a66:	8d 85       	ldd	r24, Y+13	; 0x0d
     a68:	9e 85       	ldd	r25, Y+14	; 0x0e
     a6a:	01 96       	adiw	r24, 0x01	; 1
     a6c:	8d 87       	std	Y+13, r24	; 0x0d
     a6e:	9e 87       	std	Y+14, r25	; 0x0e
     a70:	8d 85       	ldd	r24, Y+13	; 0x0d
     a72:	9e 85       	ldd	r25, Y+14	; 0x0e
     a74:	f4 e0       	ldi	r31, 0x04	; 4
     a76:	80 30       	cpi	r24, 0x00	; 0
     a78:	9f 07       	cpc	r25, r31
     a7a:	08 f4       	brcc	.+2      	; 0xa7e <CO_collectBatt+0x2f4>
     a7c:	a3 cf       	rjmp	.-186    	; 0x9c4 <CO_collectBatt+0x23a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     a7e:	80 e4       	ldi	r24, 0x40	; 64
     a80:	92 e0       	ldi	r25, 0x02	; 2
     a82:	20 e4       	ldi	r18, 0x40	; 64
     a84:	32 e0       	ldi	r19, 0x02	; 2
     a86:	f9 01       	movw	r30, r18
     a88:	21 81       	ldd	r18, Z+1	; 0x01
     a8a:	27 7f       	andi	r18, 0xF7	; 247
     a8c:	fc 01       	movw	r30, r24
     a8e:	21 83       	std	Z+1, r18	; 0x01
	ADC_Disable(&ADCB);
     a90:	80 e4       	ldi	r24, 0x40	; 64
     a92:	92 e0       	ldi	r25, 0x02	; 2
     a94:	20 e4       	ldi	r18, 0x40	; 64
     a96:	32 e0       	ldi	r19, 0x02	; 2
     a98:	f9 01       	movw	r30, r18
     a9a:	20 81       	ld	r18, Z
     a9c:	2e 7f       	andi	r18, 0xFE	; 254
     a9e:	fc 01       	movw	r30, r24
     aa0:	20 83       	st	Z, r18

	average = sum / NUM_SAMPLES;
     aa2:	89 81       	ldd	r24, Y+1	; 0x01
     aa4:	9a 81       	ldd	r25, Y+2	; 0x02
     aa6:	ab 81       	ldd	r26, Y+3	; 0x03
     aa8:	bc 81       	ldd	r27, Y+4	; 0x04
     aaa:	07 2e       	mov	r0, r23
     aac:	7a e0       	ldi	r23, 0x0A	; 10
     aae:	b6 95       	lsr	r27
     ab0:	a7 95       	ror	r26
     ab2:	97 95       	ror	r25
     ab4:	87 95       	ror	r24
     ab6:	7a 95       	dec	r23
     ab8:	d1 f7       	brne	.-12     	; 0xaae <CO_collectBatt+0x324>
     aba:	70 2d       	mov	r23, r0
     abc:	89 8b       	std	Y+17, r24	; 0x11
     abe:	9a 8b       	std	Y+18, r25	; 0x12
     ac0:	ab 8b       	std	Y+19, r26	; 0x13
     ac2:	bc 8b       	std	Y+20, r27	; 0x14
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     ac4:	84 e0       	ldi	r24, 0x04	; 4
     ac6:	60 e0       	ldi	r22, 0x00	; 0
     ac8:	0e 94 db 32 	call	0x65b6	; 0x65b6 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     acc:	80 e0       	ldi	r24, 0x00	; 0
     ace:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     ad2:	89 89       	ldd	r24, Y+17	; 0x11
     ad4:	9a 89       	ldd	r25, Y+18	; 0x12
     ad6:	ab 89       	ldd	r26, Y+19	; 0x13
     ad8:	bc 89       	ldd	r27, Y+20	; 0x14
     ada:	28 ee       	ldi	r18, 0xE8	; 232
     adc:	33 e0       	ldi	r19, 0x03	; 3
     ade:	40 e0       	ldi	r20, 0x00	; 0
     ae0:	50 e0       	ldi	r21, 0x00	; 0
     ae2:	bc 01       	movw	r22, r24
     ae4:	cd 01       	movw	r24, r26
     ae6:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
     aea:	dc 01       	movw	r26, r24
     aec:	cb 01       	movw	r24, r22
     aee:	2f ef       	ldi	r18, 0xFF	; 255
     af0:	3f e0       	ldi	r19, 0x0F	; 15
     af2:	40 e0       	ldi	r20, 0x00	; 0
     af4:	50 e0       	ldi	r21, 0x00	; 0
     af6:	bc 01       	movw	r22, r24
     af8:	cd 01       	movw	r24, r26
     afa:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
     afe:	da 01       	movw	r26, r20
     b00:	c9 01       	movw	r24, r18
     b02:	9c 01       	movw	r18, r24
     b04:	22 53       	subi	r18, 0x32	; 50
     b06:	30 40       	sbci	r19, 0x00	; 0
     b08:	8c a1       	lds	r24, 0x4c
     b0a:	9d a1       	lds	r25, 0x4d
     b0c:	fc 01       	movw	r30, r24
     b0e:	20 83       	st	Z, r18
     b10:	31 83       	std	Z+1, r19	; 0x01
	*maxV = (max * 1000 / 4095) - 50;
     b12:	89 85       	ldd	r24, Y+9	; 0x09
     b14:	9a 85       	ldd	r25, Y+10	; 0x0a
     b16:	ab 85       	ldd	r26, Y+11	; 0x0b
     b18:	bc 85       	ldd	r27, Y+12	; 0x0c
     b1a:	28 ee       	ldi	r18, 0xE8	; 232
     b1c:	33 e0       	ldi	r19, 0x03	; 3
     b1e:	40 e0       	ldi	r20, 0x00	; 0
     b20:	50 e0       	ldi	r21, 0x00	; 0
     b22:	bc 01       	movw	r22, r24
     b24:	cd 01       	movw	r24, r26
     b26:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
     b2a:	dc 01       	movw	r26, r24
     b2c:	cb 01       	movw	r24, r22
     b2e:	2f ef       	ldi	r18, 0xFF	; 255
     b30:	3f e0       	ldi	r19, 0x0F	; 15
     b32:	40 e0       	ldi	r20, 0x00	; 0
     b34:	50 e0       	ldi	r21, 0x00	; 0
     b36:	bc 01       	movw	r22, r24
     b38:	cd 01       	movw	r24, r26
     b3a:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
     b3e:	da 01       	movw	r26, r20
     b40:	c9 01       	movw	r24, r18
     b42:	9c 01       	movw	r18, r24
     b44:	22 53       	subi	r18, 0x32	; 50
     b46:	30 40       	sbci	r19, 0x00	; 0
     b48:	88 a5       	lds	r24, 0x68
     b4a:	99 a5       	lds	r25, 0x69
     b4c:	fc 01       	movw	r30, r24
     b4e:	20 83       	st	Z, r18
     b50:	31 83       	std	Z+1, r19	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     b52:	8d 81       	ldd	r24, Y+5	; 0x05
     b54:	9e 81       	ldd	r25, Y+6	; 0x06
     b56:	af 81       	ldd	r26, Y+7	; 0x07
     b58:	b8 85       	ldd	r27, Y+8	; 0x08
     b5a:	28 ee       	ldi	r18, 0xE8	; 232
     b5c:	33 e0       	ldi	r19, 0x03	; 3
     b5e:	40 e0       	ldi	r20, 0x00	; 0
     b60:	50 e0       	ldi	r21, 0x00	; 0
     b62:	bc 01       	movw	r22, r24
     b64:	cd 01       	movw	r24, r26
     b66:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
     b6a:	dc 01       	movw	r26, r24
     b6c:	cb 01       	movw	r24, r22
     b6e:	2f ef       	ldi	r18, 0xFF	; 255
     b70:	3f e0       	ldi	r19, 0x0F	; 15
     b72:	40 e0       	ldi	r20, 0x00	; 0
     b74:	50 e0       	ldi	r21, 0x00	; 0
     b76:	bc 01       	movw	r22, r24
     b78:	cd 01       	movw	r24, r26
     b7a:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
     b7e:	da 01       	movw	r26, r20
     b80:	c9 01       	movw	r24, r18
     b82:	9c 01       	movw	r18, r24
     b84:	22 53       	subi	r18, 0x32	; 50
     b86:	30 40       	sbci	r19, 0x00	; 0
     b88:	8e a1       	lds	r24, 0x4e
     b8a:	9f a1       	lds	r25, 0x4f
     b8c:	fc 01       	movw	r30, r24
     b8e:	20 83       	st	Z, r18
     b90:	31 83       	std	Z+1, r19	; 0x01
}
     b92:	a9 96       	adiw	r28, 0x29	; 41
     b94:	cd bf       	out	0x3d, r28	; 61
     b96:	de bf       	out	0x3e, r29	; 62
     b98:	df 91       	pop	r29
     b9a:	cf 91       	pop	r28
     b9c:	1f 91       	pop	r17
     b9e:	0f 91       	pop	r16
     ba0:	08 95       	ret

00000ba2 <ADCPower>:

void ADCPower(uint8_t on) {
     ba2:	0f 93       	push	r16
     ba4:	1f 93       	push	r17
     ba6:	cf 93       	push	r28
     ba8:	df 93       	push	r29
     baa:	cd b7       	in	r28, 0x3d	; 61
     bac:	de b7       	in	r29, 0x3e	; 62
     bae:	2f 97       	sbiw	r28, 0x0f	; 15
     bb0:	cd bf       	out	0x3d, r28	; 61
     bb2:	de bf       	out	0x3e, r29	; 62
     bb4:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
     bb6:	8f 85       	ldd	r24, Y+15	; 0x0f
     bb8:	88 23       	and	r24, r24
     bba:	09 f4       	brne	.+2      	; 0xbbe <ADCPower+0x1c>
     bbc:	ce c0       	rjmp	.+412    	; 0xd5a <ADCPower+0x1b8>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     bbe:	80 e0       	ldi	r24, 0x00	; 0
     bc0:	96 e0       	ldi	r25, 0x06	; 6
     bc2:	2e ed       	ldi	r18, 0xDE	; 222
     bc4:	fc 01       	movw	r30, r24
     bc6:	21 83       	std	Z+1, r18	; 0x01
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     bc8:	80 e2       	ldi	r24, 0x20	; 32
     bca:	96 e0       	ldi	r25, 0x06	; 6
     bcc:	2e e0       	ldi	r18, 0x0E	; 14
     bce:	fc 01       	movw	r30, r24
     bd0:	21 83       	std	Z+1, r18	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     bd2:	80 e4       	ldi	r24, 0x40	; 64
     bd4:	96 e0       	ldi	r25, 0x06	; 6
     bd6:	23 e0       	ldi	r18, 0x03	; 3
     bd8:	fc 01       	movw	r30, r24
     bda:	21 83       	std	Z+1, r18	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     bdc:	80 e8       	ldi	r24, 0x80	; 128
     bde:	96 e0       	ldi	r25, 0x06	; 6
     be0:	20 e1       	ldi	r18, 0x10	; 16
     be2:	fc 01       	movw	r30, r24
     be4:	21 83       	std	Z+1, r18	; 0x01
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     be6:	80 ea       	ldi	r24, 0xA0	; 160
     be8:	96 e0       	ldi	r25, 0x06	; 6
     bea:	2e e0       	ldi	r18, 0x0E	; 14
     bec:	fc 01       	movw	r30, r24
     bee:	21 83       	std	Z+1, r18	; 0x01

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     bf0:	80 e0       	ldi	r24, 0x00	; 0
     bf2:	96 e0       	ldi	r25, 0x06	; 6
     bf4:	2e e9       	ldi	r18, 0x9E	; 158
     bf6:	fc 01       	movw	r30, r24
     bf8:	25 83       	std	Z+5, r18	; 0x05
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     bfa:	80 e2       	ldi	r24, 0x20	; 32
     bfc:	96 e0       	ldi	r25, 0x06	; 6
     bfe:	28 e0       	ldi	r18, 0x08	; 8
     c00:	fc 01       	movw	r30, r24
     c02:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     c04:	80 e4       	ldi	r24, 0x40	; 64
     c06:	96 e0       	ldi	r25, 0x06	; 6
     c08:	23 e0       	ldi	r18, 0x03	; 3
     c0a:	fc 01       	movw	r30, r24
     c0c:	25 83       	std	Z+5, r18	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     c0e:	80 e8       	ldi	r24, 0x80	; 128
     c10:	96 e0       	ldi	r25, 0x06	; 6
     c12:	20 e1       	ldi	r18, 0x10	; 16
     c14:	fc 01       	movw	r30, r24
     c16:	25 83       	std	Z+5, r18	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     c18:	80 ea       	ldi	r24, 0xA0	; 160
     c1a:	96 e0       	ldi	r25, 0x06	; 6
     c1c:	2e e0       	ldi	r18, 0x0E	; 14
     c1e:	fc 01       	movw	r30, r24
     c20:	25 83       	std	Z+5, r18	; 0x05
		channelStatus = 0x00; // POR to zeros
     c22:	10 92 82 50 	sts	0x5082, r1
     c26:	80 e0       	ldi	r24, 0x00	; 0
     c28:	90 e0       	ldi	r25, 0x00	; 0
     c2a:	a8 ec       	ldi	r26, 0xC8	; 200
     c2c:	b2 e4       	ldi	r27, 0x42	; 66
     c2e:	89 83       	std	Y+1, r24	; 0x01
     c30:	9a 83       	std	Y+2, r25	; 0x02
     c32:	ab 83       	std	Y+3, r26	; 0x03
     c34:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     c36:	69 81       	ldd	r22, Y+1	; 0x01
     c38:	7a 81       	ldd	r23, Y+2	; 0x02
     c3a:	8b 81       	ldd	r24, Y+3	; 0x03
     c3c:	9c 81       	ldd	r25, Y+4	; 0x04
     c3e:	20 e0       	ldi	r18, 0x00	; 0
     c40:	30 e0       	ldi	r19, 0x00	; 0
     c42:	4a ef       	ldi	r20, 0xFA	; 250
     c44:	55 e4       	ldi	r21, 0x45	; 69
     c46:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
     c4a:	dc 01       	movw	r26, r24
     c4c:	cb 01       	movw	r24, r22
     c4e:	8d 83       	std	Y+5, r24	; 0x05
     c50:	9e 83       	std	Y+6, r25	; 0x06
     c52:	af 83       	std	Y+7, r26	; 0x07
     c54:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     c56:	11 e0       	ldi	r17, 0x01	; 1
     c58:	6d 81       	ldd	r22, Y+5	; 0x05
     c5a:	7e 81       	ldd	r23, Y+6	; 0x06
     c5c:	8f 81       	ldd	r24, Y+7	; 0x07
     c5e:	98 85       	ldd	r25, Y+8	; 0x08
     c60:	20 e0       	ldi	r18, 0x00	; 0
     c62:	30 e0       	ldi	r19, 0x00	; 0
     c64:	40 e8       	ldi	r20, 0x80	; 128
     c66:	5f e3       	ldi	r21, 0x3F	; 63
     c68:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
     c6c:	88 23       	and	r24, r24
     c6e:	0c f0       	brlt	.+2      	; 0xc72 <ADCPower+0xd0>
     c70:	10 e0       	ldi	r17, 0x00	; 0
     c72:	11 23       	and	r17, r17
     c74:	29 f0       	breq	.+10     	; 0xc80 <ADCPower+0xde>
		__ticks = 1;
     c76:	81 e0       	ldi	r24, 0x01	; 1
     c78:	90 e0       	ldi	r25, 0x00	; 0
     c7a:	89 87       	std	Y+9, r24	; 0x09
     c7c:	9a 87       	std	Y+10, r25	; 0x0a
     c7e:	46 c0       	rjmp	.+140    	; 0xd0c <ADCPower+0x16a>
	else if (__tmp > 65535)
     c80:	11 e0       	ldi	r17, 0x01	; 1
     c82:	6d 81       	ldd	r22, Y+5	; 0x05
     c84:	7e 81       	ldd	r23, Y+6	; 0x06
     c86:	8f 81       	ldd	r24, Y+7	; 0x07
     c88:	98 85       	ldd	r25, Y+8	; 0x08
     c8a:	20 e0       	ldi	r18, 0x00	; 0
     c8c:	3f ef       	ldi	r19, 0xFF	; 255
     c8e:	4f e7       	ldi	r20, 0x7F	; 127
     c90:	57 e4       	ldi	r21, 0x47	; 71
     c92:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
     c96:	18 16       	cp	r1, r24
     c98:	0c f0       	brlt	.+2      	; 0xc9c <ADCPower+0xfa>
     c9a:	10 e0       	ldi	r17, 0x00	; 0
     c9c:	11 23       	and	r17, r17
     c9e:	61 f1       	breq	.+88     	; 0xcf8 <ADCPower+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     ca0:	69 81       	ldd	r22, Y+1	; 0x01
     ca2:	7a 81       	ldd	r23, Y+2	; 0x02
     ca4:	8b 81       	ldd	r24, Y+3	; 0x03
     ca6:	9c 81       	ldd	r25, Y+4	; 0x04
     ca8:	20 e0       	ldi	r18, 0x00	; 0
     caa:	30 e0       	ldi	r19, 0x00	; 0
     cac:	40 e2       	ldi	r20, 0x20	; 32
     cae:	51 e4       	ldi	r21, 0x41	; 65
     cb0:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
     cb4:	dc 01       	movw	r26, r24
     cb6:	cb 01       	movw	r24, r22
     cb8:	bc 01       	movw	r22, r24
     cba:	cd 01       	movw	r24, r26
     cbc:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
     cc0:	dc 01       	movw	r26, r24
     cc2:	cb 01       	movw	r24, r22
     cc4:	89 87       	std	Y+9, r24	; 0x09
     cc6:	9a 87       	std	Y+10, r25	; 0x0a
     cc8:	12 c0       	rjmp	.+36     	; 0xcee <ADCPower+0x14c>
     cca:	80 e2       	ldi	r24, 0x20	; 32
     ccc:	93 e0       	ldi	r25, 0x03	; 3
     cce:	8b 87       	std	Y+11, r24	; 0x0b
     cd0:	9c 87       	std	Y+12, r25	; 0x0c
     cd2:	8b 85       	ldd	r24, Y+11	; 0x0b
     cd4:	9c 85       	ldd	r25, Y+12	; 0x0c
     cd6:	8c 01       	movw	r16, r24
     cd8:	c8 01       	movw	r24, r16
     cda:	01 97       	sbiw	r24, 0x01	; 1
     cdc:	f1 f7       	brne	.-4      	; 0xcda <ADCPower+0x138>
     cde:	8c 01       	movw	r16, r24
     ce0:	0b 87       	std	Y+11, r16	; 0x0b
     ce2:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     ce4:	89 85       	ldd	r24, Y+9	; 0x09
     ce6:	9a 85       	ldd	r25, Y+10	; 0x0a
     ce8:	01 97       	sbiw	r24, 0x01	; 1
     cea:	89 87       	std	Y+9, r24	; 0x09
     cec:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     cee:	89 85       	ldd	r24, Y+9	; 0x09
     cf0:	9a 85       	ldd	r25, Y+10	; 0x0a
     cf2:	00 97       	sbiw	r24, 0x00	; 0
     cf4:	51 f7       	brne	.-44     	; 0xcca <ADCPower+0x128>
     cf6:	17 c0       	rjmp	.+46     	; 0xd26 <ADCPower+0x184>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     cf8:	6d 81       	ldd	r22, Y+5	; 0x05
     cfa:	7e 81       	ldd	r23, Y+6	; 0x06
     cfc:	8f 81       	ldd	r24, Y+7	; 0x07
     cfe:	98 85       	ldd	r25, Y+8	; 0x08
     d00:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
     d04:	dc 01       	movw	r26, r24
     d06:	cb 01       	movw	r24, r22
     d08:	89 87       	std	Y+9, r24	; 0x09
     d0a:	9a 87       	std	Y+10, r25	; 0x0a
     d0c:	89 85       	ldd	r24, Y+9	; 0x09
     d0e:	9a 85       	ldd	r25, Y+10	; 0x0a
     d10:	8d 87       	std	Y+13, r24	; 0x0d
     d12:	9e 87       	std	Y+14, r25	; 0x0e
     d14:	8d 85       	ldd	r24, Y+13	; 0x0d
     d16:	9e 85       	ldd	r25, Y+14	; 0x0e
     d18:	8c 01       	movw	r16, r24
     d1a:	f8 01       	movw	r30, r16
     d1c:	31 97       	sbiw	r30, 0x01	; 1
     d1e:	f1 f7       	brne	.-4      	; 0xd1c <ADCPower+0x17a>
     d20:	8f 01       	movw	r16, r30
     d22:	0d 87       	std	Y+13, r16	; 0x0d
     d24:	1e 87       	std	Y+14, r17	; 0x0e
		_delay_ms(100);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     d26:	80 e4       	ldi	r24, 0x40	; 64
     d28:	96 e0       	ldi	r25, 0x06	; 6
     d2a:	20 e4       	ldi	r18, 0x40	; 64
     d2c:	fc 01       	movw	r30, r24
     d2e:	22 83       	std	Z+2, r18	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     d30:	80 e0       	ldi	r24, 0x00	; 0
     d32:	80 93 83 50 	sts	0x5083, r24
     d36:	80 93 d6 50 	sts	0x50D6, r24
     d3a:	80 93 cf 23 	sts	0x23CF, r24
     d3e:	80 93 7b 50 	sts	0x507B, r24
		PortEx_DIRSET(0xFF, PS_BANKA);
     d42:	8f ef       	ldi	r24, 0xFF	; 255
     d44:	61 e0       	ldi	r22, 0x01	; 1
     d46:	0e 94 77 32 	call	0x64ee	; 0x64ee <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     d4a:	8f ef       	ldi	r24, 0xFF	; 255
     d4c:	61 e0       	ldi	r22, 0x01	; 1
     d4e:	0e 94 43 33 	call	0x6686	; 0x6686 <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     d52:	8f ef       	ldi	r24, 0xFF	; 255
     d54:	0e 94 26 08 	call	0x104c	; 0x104c <set_filter>
     d58:	42 c0       	rjmp	.+132    	; 0xdde <ADCPower+0x23c>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     d5a:	80 e0       	ldi	r24, 0x00	; 0
     d5c:	96 e0       	ldi	r25, 0x06	; 6
     d5e:	2e ed       	ldi	r18, 0xDE	; 222
     d60:	fc 01       	movw	r30, r24
     d62:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     d64:	80 e2       	ldi	r24, 0x20	; 32
     d66:	96 e0       	ldi	r25, 0x06	; 6
     d68:	2e e0       	ldi	r18, 0x0E	; 14
     d6a:	fc 01       	movw	r30, r24
     d6c:	26 83       	std	Z+6, r18	; 0x06
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     d6e:	80 e4       	ldi	r24, 0x40	; 64
     d70:	96 e0       	ldi	r25, 0x06	; 6
     d72:	23 e0       	ldi	r18, 0x03	; 3
     d74:	fc 01       	movw	r30, r24
     d76:	26 83       	std	Z+6, r18	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     d78:	80 e8       	ldi	r24, 0x80	; 128
     d7a:	96 e0       	ldi	r25, 0x06	; 6
     d7c:	20 e1       	ldi	r18, 0x10	; 16
     d7e:	fc 01       	movw	r30, r24
     d80:	26 83       	std	Z+6, r18	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     d82:	80 ea       	ldi	r24, 0xA0	; 160
     d84:	96 e0       	ldi	r25, 0x06	; 6
     d86:	2e e0       	ldi	r18, 0x0E	; 14
     d88:	fc 01       	movw	r30, r24
     d8a:	26 83       	std	Z+6, r18	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     d8c:	80 e0       	ldi	r24, 0x00	; 0
     d8e:	96 e0       	ldi	r25, 0x06	; 6
     d90:	2e ed       	ldi	r18, 0xDE	; 222
     d92:	fc 01       	movw	r30, r24
     d94:	22 83       	std	Z+2, r18	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     d96:	80 e2       	ldi	r24, 0x20	; 32
     d98:	96 e0       	ldi	r25, 0x06	; 6
     d9a:	2e e0       	ldi	r18, 0x0E	; 14
     d9c:	fc 01       	movw	r30, r24
     d9e:	22 83       	std	Z+2, r18	; 0x02
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     da0:	80 e4       	ldi	r24, 0x40	; 64
     da2:	96 e0       	ldi	r25, 0x06	; 6
     da4:	23 e0       	ldi	r18, 0x03	; 3
     da6:	fc 01       	movw	r30, r24
     da8:	22 83       	std	Z+2, r18	; 0x02
		PORTE.DIRCLR = PIN4_bm;
     daa:	80 e8       	ldi	r24, 0x80	; 128
     dac:	96 e0       	ldi	r25, 0x06	; 6
     dae:	20 e1       	ldi	r18, 0x10	; 16
     db0:	fc 01       	movw	r30, r24
     db2:	22 83       	std	Z+2, r18	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     db4:	80 ea       	ldi	r24, 0xA0	; 160
     db6:	96 e0       	ldi	r25, 0x06	; 6
     db8:	2e e0       	ldi	r18, 0x0E	; 14
     dba:	fc 01       	movw	r30, r24
     dbc:	22 83       	std	Z+2, r18	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     dbe:	80 e4       	ldi	r24, 0x40	; 64
     dc0:	96 e0       	ldi	r25, 0x06	; 6
     dc2:	20 e4       	ldi	r18, 0x40	; 64
     dc4:	fc 01       	movw	r30, r24
     dc6:	22 83       	std	Z+2, r18	; 0x02
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     dc8:	80 e0       	ldi	r24, 0x00	; 0
     dca:	80 93 83 50 	sts	0x5083, r24
     dce:	80 93 d6 50 	sts	0x50D6, r24
     dd2:	80 93 cf 23 	sts	0x23CF, r24
     dd6:	80 93 7b 50 	sts	0x507B, r24
		channelStatus = 0x00;
     dda:	10 92 82 50 	sts	0x5082, r1
		
	}
}
     dde:	2f 96       	adiw	r28, 0x0f	; 15
     de0:	cd bf       	out	0x3d, r28	; 61
     de2:	de bf       	out	0x3e, r29	; 62
     de4:	df 91       	pop	r29
     de6:	cf 91       	pop	r28
     de8:	1f 91       	pop	r17
     dea:	0f 91       	pop	r16
     dec:	08 95       	ret

00000dee <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     dee:	0f 93       	push	r16
     df0:	1f 93       	push	r17
     df2:	cf 93       	push	r28
     df4:	df 93       	push	r29
     df6:	cd b7       	in	r28, 0x3d	; 61
     df8:	de b7       	in	r29, 0x3e	; 62
     dfa:	6a 97       	sbiw	r28, 0x1a	; 26
     dfc:	cd bf       	out	0x3d, r28	; 61
     dfe:	de bf       	out	0x3e, r29	; 62
     e00:	89 8f       	std	Y+25, r24	; 0x19
     e02:	6a 8f       	std	Y+26, r22	; 0x1a
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     e04:	89 8d       	ldd	r24, Y+25	; 0x19
     e06:	28 2f       	mov	r18, r24
     e08:	30 e0       	ldi	r19, 0x00	; 0
     e0a:	81 e0       	ldi	r24, 0x01	; 1
     e0c:	90 e0       	ldi	r25, 0x00	; 0
     e0e:	02 c0       	rjmp	.+4      	; 0xe14 <set_ampGain+0x26>
     e10:	88 0f       	add	r24, r24
     e12:	99 1f       	adc	r25, r25
     e14:	2a 95       	dec	r18
     e16:	e2 f7       	brpl	.-8      	; 0xe10 <set_ampGain+0x22>
     e18:	61 e0       	ldi	r22, 0x01	; 1
     e1a:	0e 94 a6 33 	call	0x674c	; 0x674c <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     e1e:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e20:	88 2f       	mov	r24, r24
     e22:	90 e0       	ldi	r25, 0x00	; 0
     e24:	81 70       	andi	r24, 0x01	; 1
     e26:	90 70       	andi	r25, 0x00	; 0
     e28:	88 23       	and	r24, r24
     e2a:	31 f0       	breq	.+12     	; 0xe38 <set_ampGain+0x4a>
     e2c:	80 e0       	ldi	r24, 0x00	; 0
     e2e:	96 e0       	ldi	r25, 0x06	; 6
     e30:	20 e4       	ldi	r18, 0x40	; 64
     e32:	fc 01       	movw	r30, r24
     e34:	25 83       	std	Z+5, r18	; 0x05
     e36:	05 c0       	rjmp	.+10     	; 0xe42 <set_ampGain+0x54>
	else {PORTA.OUTCLR = PIN6_bm;}
     e38:	80 e0       	ldi	r24, 0x00	; 0
     e3a:	96 e0       	ldi	r25, 0x06	; 6
     e3c:	20 e4       	ldi	r18, 0x40	; 64
     e3e:	fc 01       	movw	r30, r24
     e40:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     e42:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e44:	88 2f       	mov	r24, r24
     e46:	90 e0       	ldi	r25, 0x00	; 0
     e48:	82 70       	andi	r24, 0x02	; 2
     e4a:	90 70       	andi	r25, 0x00	; 0
     e4c:	00 97       	sbiw	r24, 0x00	; 0
     e4e:	31 f0       	breq	.+12     	; 0xe5c <set_ampGain+0x6e>
     e50:	80 e2       	ldi	r24, 0x20	; 32
     e52:	96 e0       	ldi	r25, 0x06	; 6
     e54:	22 e0       	ldi	r18, 0x02	; 2
     e56:	fc 01       	movw	r30, r24
     e58:	25 83       	std	Z+5, r18	; 0x05
     e5a:	05 c0       	rjmp	.+10     	; 0xe66 <set_ampGain+0x78>
	else {PORTB.OUTCLR = PIN1_bm;}
     e5c:	80 e2       	ldi	r24, 0x20	; 32
     e5e:	96 e0       	ldi	r25, 0x06	; 6
     e60:	22 e0       	ldi	r18, 0x02	; 2
     e62:	fc 01       	movw	r30, r24
     e64:	26 83       	std	Z+6, r18	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     e66:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e68:	88 2f       	mov	r24, r24
     e6a:	90 e0       	ldi	r25, 0x00	; 0
     e6c:	84 70       	andi	r24, 0x04	; 4
     e6e:	90 70       	andi	r25, 0x00	; 0
     e70:	00 97       	sbiw	r24, 0x00	; 0
     e72:	31 f0       	breq	.+12     	; 0xe80 <set_ampGain+0x92>
     e74:	80 e2       	ldi	r24, 0x20	; 32
     e76:	96 e0       	ldi	r25, 0x06	; 6
     e78:	24 e0       	ldi	r18, 0x04	; 4
     e7a:	fc 01       	movw	r30, r24
     e7c:	25 83       	std	Z+5, r18	; 0x05
     e7e:	05 c0       	rjmp	.+10     	; 0xe8a <set_ampGain+0x9c>
	else {PORTB.OUTCLR = PIN2_bm;}
     e80:	80 e2       	ldi	r24, 0x20	; 32
     e82:	96 e0       	ldi	r25, 0x06	; 6
     e84:	24 e0       	ldi	r18, 0x04	; 4
     e86:	fc 01       	movw	r30, r24
     e88:	26 83       	std	Z+6, r18	; 0x06
     e8a:	80 e0       	ldi	r24, 0x00	; 0
     e8c:	90 e0       	ldi	r25, 0x00	; 0
     e8e:	a0 e8       	ldi	r26, 0x80	; 128
     e90:	bf e3       	ldi	r27, 0x3F	; 63
     e92:	89 83       	std	Y+1, r24	; 0x01
     e94:	9a 83       	std	Y+2, r25	; 0x02
     e96:	ab 83       	std	Y+3, r26	; 0x03
     e98:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
     e9a:	69 81       	ldd	r22, Y+1	; 0x01
     e9c:	7a 81       	ldd	r23, Y+2	; 0x02
     e9e:	8b 81       	ldd	r24, Y+3	; 0x03
     ea0:	9c 81       	ldd	r25, Y+4	; 0x04
     ea2:	2b ea       	ldi	r18, 0xAB	; 171
     ea4:	3a ea       	ldi	r19, 0xAA	; 170
     ea6:	4a e2       	ldi	r20, 0x2A	; 42
     ea8:	51 e4       	ldi	r21, 0x41	; 65
     eaa:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
     eae:	dc 01       	movw	r26, r24
     eb0:	cb 01       	movw	r24, r22
     eb2:	8d 83       	std	Y+5, r24	; 0x05
     eb4:	9e 83       	std	Y+6, r25	; 0x06
     eb6:	af 83       	std	Y+7, r26	; 0x07
     eb8:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     eba:	11 e0       	ldi	r17, 0x01	; 1
     ebc:	6d 81       	ldd	r22, Y+5	; 0x05
     ebe:	7e 81       	ldd	r23, Y+6	; 0x06
     ec0:	8f 81       	ldd	r24, Y+7	; 0x07
     ec2:	98 85       	ldd	r25, Y+8	; 0x08
     ec4:	20 e0       	ldi	r18, 0x00	; 0
     ec6:	30 e0       	ldi	r19, 0x00	; 0
     ec8:	40 e8       	ldi	r20, 0x80	; 128
     eca:	5f e3       	ldi	r21, 0x3F	; 63
     ecc:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
     ed0:	88 23       	and	r24, r24
     ed2:	0c f0       	brlt	.+2      	; 0xed6 <set_ampGain+0xe8>
     ed4:	10 e0       	ldi	r17, 0x00	; 0
     ed6:	11 23       	and	r17, r17
     ed8:	19 f0       	breq	.+6      	; 0xee0 <set_ampGain+0xf2>
		__ticks = 1;
     eda:	81 e0       	ldi	r24, 0x01	; 1
     edc:	89 87       	std	Y+9, r24	; 0x09
     ede:	a3 c0       	rjmp	.+326    	; 0x1026 <set_ampGain+0x238>
	else if (__tmp > 255)
     ee0:	11 e0       	ldi	r17, 0x01	; 1
     ee2:	6d 81       	ldd	r22, Y+5	; 0x05
     ee4:	7e 81       	ldd	r23, Y+6	; 0x06
     ee6:	8f 81       	ldd	r24, Y+7	; 0x07
     ee8:	98 85       	ldd	r25, Y+8	; 0x08
     eea:	20 e0       	ldi	r18, 0x00	; 0
     eec:	30 e0       	ldi	r19, 0x00	; 0
     eee:	4f e7       	ldi	r20, 0x7F	; 127
     ef0:	53 e4       	ldi	r21, 0x43	; 67
     ef2:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
     ef6:	18 16       	cp	r1, r24
     ef8:	0c f0       	brlt	.+2      	; 0xefc <set_ampGain+0x10e>
     efa:	10 e0       	ldi	r17, 0x00	; 0
     efc:	11 23       	and	r17, r17
     efe:	09 f4       	brne	.+2      	; 0xf02 <set_ampGain+0x114>
     f00:	89 c0       	rjmp	.+274    	; 0x1014 <set_ampGain+0x226>
	{
		_delay_ms(__us / 1000.0);
     f02:	69 81       	ldd	r22, Y+1	; 0x01
     f04:	7a 81       	ldd	r23, Y+2	; 0x02
     f06:	8b 81       	ldd	r24, Y+3	; 0x03
     f08:	9c 81       	ldd	r25, Y+4	; 0x04
     f0a:	20 e0       	ldi	r18, 0x00	; 0
     f0c:	30 e0       	ldi	r19, 0x00	; 0
     f0e:	4a e7       	ldi	r20, 0x7A	; 122
     f10:	54 e4       	ldi	r21, 0x44	; 68
     f12:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
     f16:	dc 01       	movw	r26, r24
     f18:	cb 01       	movw	r24, r22
     f1a:	8a 87       	std	Y+10, r24	; 0x0a
     f1c:	9b 87       	std	Y+11, r25	; 0x0b
     f1e:	ac 87       	std	Y+12, r26	; 0x0c
     f20:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
     f22:	6a 85       	ldd	r22, Y+10	; 0x0a
     f24:	7b 85       	ldd	r23, Y+11	; 0x0b
     f26:	8c 85       	ldd	r24, Y+12	; 0x0c
     f28:	9d 85       	ldd	r25, Y+13	; 0x0d
     f2a:	20 e0       	ldi	r18, 0x00	; 0
     f2c:	30 e0       	ldi	r19, 0x00	; 0
     f2e:	4a ef       	ldi	r20, 0xFA	; 250
     f30:	55 e4       	ldi	r21, 0x45	; 69
     f32:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
     f36:	dc 01       	movw	r26, r24
     f38:	cb 01       	movw	r24, r22
     f3a:	8e 87       	std	Y+14, r24	; 0x0e
     f3c:	9f 87       	std	Y+15, r25	; 0x0f
     f3e:	a8 8b       	std	Y+16, r26	; 0x10
     f40:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
     f42:	11 e0       	ldi	r17, 0x01	; 1
     f44:	6e 85       	ldd	r22, Y+14	; 0x0e
     f46:	7f 85       	ldd	r23, Y+15	; 0x0f
     f48:	88 89       	ldd	r24, Y+16	; 0x10
     f4a:	99 89       	ldd	r25, Y+17	; 0x11
     f4c:	20 e0       	ldi	r18, 0x00	; 0
     f4e:	30 e0       	ldi	r19, 0x00	; 0
     f50:	40 e8       	ldi	r20, 0x80	; 128
     f52:	5f e3       	ldi	r21, 0x3F	; 63
     f54:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
     f58:	88 23       	and	r24, r24
     f5a:	0c f0       	brlt	.+2      	; 0xf5e <set_ampGain+0x170>
     f5c:	10 e0       	ldi	r17, 0x00	; 0
     f5e:	11 23       	and	r17, r17
     f60:	29 f0       	breq	.+10     	; 0xf6c <set_ampGain+0x17e>
		__ticks = 1;
     f62:	81 e0       	ldi	r24, 0x01	; 1
     f64:	90 e0       	ldi	r25, 0x00	; 0
     f66:	8a 8b       	std	Y+18, r24	; 0x12
     f68:	9b 8b       	std	Y+19, r25	; 0x13
     f6a:	46 c0       	rjmp	.+140    	; 0xff8 <set_ampGain+0x20a>
	else if (__tmp > 65535)
     f6c:	11 e0       	ldi	r17, 0x01	; 1
     f6e:	6e 85       	ldd	r22, Y+14	; 0x0e
     f70:	7f 85       	ldd	r23, Y+15	; 0x0f
     f72:	88 89       	ldd	r24, Y+16	; 0x10
     f74:	99 89       	ldd	r25, Y+17	; 0x11
     f76:	20 e0       	ldi	r18, 0x00	; 0
     f78:	3f ef       	ldi	r19, 0xFF	; 255
     f7a:	4f e7       	ldi	r20, 0x7F	; 127
     f7c:	57 e4       	ldi	r21, 0x47	; 71
     f7e:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
     f82:	18 16       	cp	r1, r24
     f84:	0c f0       	brlt	.+2      	; 0xf88 <set_ampGain+0x19a>
     f86:	10 e0       	ldi	r17, 0x00	; 0
     f88:	11 23       	and	r17, r17
     f8a:	61 f1       	breq	.+88     	; 0xfe4 <set_ampGain+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     f8c:	6a 85       	ldd	r22, Y+10	; 0x0a
     f8e:	7b 85       	ldd	r23, Y+11	; 0x0b
     f90:	8c 85       	ldd	r24, Y+12	; 0x0c
     f92:	9d 85       	ldd	r25, Y+13	; 0x0d
     f94:	20 e0       	ldi	r18, 0x00	; 0
     f96:	30 e0       	ldi	r19, 0x00	; 0
     f98:	40 e2       	ldi	r20, 0x20	; 32
     f9a:	51 e4       	ldi	r21, 0x41	; 65
     f9c:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
     fa0:	dc 01       	movw	r26, r24
     fa2:	cb 01       	movw	r24, r22
     fa4:	bc 01       	movw	r22, r24
     fa6:	cd 01       	movw	r24, r26
     fa8:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
     fac:	dc 01       	movw	r26, r24
     fae:	cb 01       	movw	r24, r22
     fb0:	8a 8b       	std	Y+18, r24	; 0x12
     fb2:	9b 8b       	std	Y+19, r25	; 0x13
     fb4:	12 c0       	rjmp	.+36     	; 0xfda <set_ampGain+0x1ec>
     fb6:	80 e2       	ldi	r24, 0x20	; 32
     fb8:	93 e0       	ldi	r25, 0x03	; 3
     fba:	8c 8b       	std	Y+20, r24	; 0x14
     fbc:	9d 8b       	std	Y+21, r25	; 0x15
     fbe:	8c 89       	ldd	r24, Y+20	; 0x14
     fc0:	9d 89       	ldd	r25, Y+21	; 0x15
     fc2:	8c 01       	movw	r16, r24
     fc4:	c8 01       	movw	r24, r16
     fc6:	01 97       	sbiw	r24, 0x01	; 1
     fc8:	f1 f7       	brne	.-4      	; 0xfc6 <set_ampGain+0x1d8>
     fca:	8c 01       	movw	r16, r24
     fcc:	0c 8b       	std	Y+20, r16	; 0x14
     fce:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     fd0:	8a 89       	ldd	r24, Y+18	; 0x12
     fd2:	9b 89       	ldd	r25, Y+19	; 0x13
     fd4:	01 97       	sbiw	r24, 0x01	; 1
     fd6:	8a 8b       	std	Y+18, r24	; 0x12
     fd8:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     fda:	8a 89       	ldd	r24, Y+18	; 0x12
     fdc:	9b 89       	ldd	r25, Y+19	; 0x13
     fde:	00 97       	sbiw	r24, 0x00	; 0
     fe0:	51 f7       	brne	.-44     	; 0xfb6 <set_ampGain+0x1c8>
     fe2:	28 c0       	rjmp	.+80     	; 0x1034 <set_ampGain+0x246>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     fe4:	6e 85       	ldd	r22, Y+14	; 0x0e
     fe6:	7f 85       	ldd	r23, Y+15	; 0x0f
     fe8:	88 89       	ldd	r24, Y+16	; 0x10
     fea:	99 89       	ldd	r25, Y+17	; 0x11
     fec:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
     ff0:	dc 01       	movw	r26, r24
     ff2:	cb 01       	movw	r24, r22
     ff4:	8a 8b       	std	Y+18, r24	; 0x12
     ff6:	9b 8b       	std	Y+19, r25	; 0x13
     ff8:	8a 89       	ldd	r24, Y+18	; 0x12
     ffa:	9b 89       	ldd	r25, Y+19	; 0x13
     ffc:	8e 8b       	std	Y+22, r24	; 0x16
     ffe:	9f 8b       	std	Y+23, r25	; 0x17
    1000:	8e 89       	ldd	r24, Y+22	; 0x16
    1002:	9f 89       	ldd	r25, Y+23	; 0x17
    1004:	8c 01       	movw	r16, r24
    1006:	f8 01       	movw	r30, r16
    1008:	31 97       	sbiw	r30, 0x01	; 1
    100a:	f1 f7       	brne	.-4      	; 0x1008 <set_ampGain+0x21a>
    100c:	8f 01       	movw	r16, r30
    100e:	0e 8b       	std	Y+22, r16	; 0x16
    1010:	1f 8b       	std	Y+23, r17	; 0x17
    1012:	10 c0       	rjmp	.+32     	; 0x1034 <set_ampGain+0x246>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1014:	6d 81       	ldd	r22, Y+5	; 0x05
    1016:	7e 81       	ldd	r23, Y+6	; 0x06
    1018:	8f 81       	ldd	r24, Y+7	; 0x07
    101a:	98 85       	ldd	r25, Y+8	; 0x08
    101c:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    1020:	dc 01       	movw	r26, r24
    1022:	cb 01       	movw	r24, r22
    1024:	89 87       	std	Y+9, r24	; 0x09
    1026:	89 85       	ldd	r24, Y+9	; 0x09
    1028:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    102a:	88 8d       	ldd	r24, Y+24	; 0x18
    102c:	18 2f       	mov	r17, r24
    102e:	1a 95       	dec	r17
    1030:	f1 f7       	brne	.-4      	; 0x102e <set_ampGain+0x240>
    1032:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
    1034:	8f ef       	ldi	r24, 0xFF	; 255
    1036:	61 e0       	ldi	r22, 0x01	; 1
    1038:	0e 94 43 33 	call	0x6686	; 0x6686 <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
    103c:	6a 96       	adiw	r28, 0x1a	; 26
    103e:	cd bf       	out	0x3d, r28	; 61
    1040:	de bf       	out	0x3e, r29	; 62
    1042:	df 91       	pop	r29
    1044:	cf 91       	pop	r28
    1046:	1f 91       	pop	r17
    1048:	0f 91       	pop	r16
    104a:	08 95       	ret

0000104c <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
    104c:	cf 93       	push	r28
    104e:	df 93       	push	r29
    1050:	00 d0       	rcall	.+0      	; 0x1052 <set_filter+0x6>
    1052:	cd b7       	in	r28, 0x3d	; 61
    1054:	de b7       	in	r29, 0x3e	; 62
    1056:	8b 83       	std	Y+3, r24	; 0x03
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
    1058:	8b 81       	ldd	r24, Y+3	; 0x03
    105a:	83 70       	andi	r24, 0x03	; 3
    105c:	89 83       	std	Y+1, r24	; 0x01
	uint8_t upperCS = filterConfig & 0x0C;
    105e:	8b 81       	ldd	r24, Y+3	; 0x03
    1060:	8c 70       	andi	r24, 0x0C	; 12
    1062:	8a 83       	std	Y+2, r24	; 0x02

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
    1064:	8b 81       	ldd	r24, Y+3	; 0x03
    1066:	88 2f       	mov	r24, r24
    1068:	90 e0       	ldi	r25, 0x00	; 0
    106a:	85 70       	andi	r24, 0x05	; 5
    106c:	90 70       	andi	r25, 0x00	; 0
    106e:	00 97       	sbiw	r24, 0x00	; 0
    1070:	51 f0       	breq	.+20     	; 0x1086 <set_filter+0x3a>
    1072:	80 91 82 50 	lds	r24, 0x5082
    1076:	98 2f       	mov	r25, r24
    1078:	90 7f       	andi	r25, 0xF0	; 240
    107a:	8b 81       	ldd	r24, Y+3	; 0x03
    107c:	82 95       	swap	r24
    107e:	8f 70       	andi	r24, 0x0F	; 15
    1080:	89 2b       	or	r24, r25
    1082:	80 93 82 50 	sts	0x5082, r24
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
    1086:	8b 81       	ldd	r24, Y+3	; 0x03
    1088:	88 2f       	mov	r24, r24
    108a:	90 e0       	ldi	r25, 0x00	; 0
    108c:	8a 70       	andi	r24, 0x0A	; 10
    108e:	90 70       	andi	r25, 0x00	; 0
    1090:	00 97       	sbiw	r24, 0x00	; 0
    1092:	49 f0       	breq	.+18     	; 0x10a6 <set_filter+0x5a>
    1094:	8b 81       	ldd	r24, Y+3	; 0x03
    1096:	98 2f       	mov	r25, r24
    1098:	90 7f       	andi	r25, 0xF0	; 240
    109a:	80 91 82 50 	lds	r24, 0x5082
    109e:	8f 70       	andi	r24, 0x0F	; 15
    10a0:	89 2b       	or	r24, r25
    10a2:	80 93 82 50 	sts	0x5082, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
    10a6:	84 e0       	ldi	r24, 0x04	; 4
    10a8:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>

	
	SPIBuffer[0] = channelStatus;
    10ac:	80 91 82 50 	lds	r24, 0x5082
    10b0:	80 93 66 50 	sts	0x5066, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
    10b4:	89 81       	ldd	r24, Y+1	; 0x01
    10b6:	88 23       	and	r24, r24
    10b8:	19 f0       	breq	.+6      	; 0x10c0 <set_filter+0x74>
    10ba:	81 e0       	ldi	r24, 0x01	; 1
    10bc:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
    10c0:	8a 81       	ldd	r24, Y+2	; 0x02
    10c2:	88 23       	and	r24, r24
    10c4:	19 f0       	breq	.+6      	; 0x10cc <set_filter+0x80>
    10c6:	81 e0       	ldi	r24, 0x01	; 1
    10c8:	0e 94 fb 36 	call	0x6df6	; 0x6df6 <upperMuxCS>

	SPICS(TRUE);
    10cc:	81 e0       	ldi	r24, 0x01	; 1
    10ce:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
    10d2:	80 ec       	ldi	r24, 0xC0	; 192
    10d4:	98 e0       	ldi	r25, 0x08	; 8
    10d6:	2f ef       	ldi	r18, 0xFF	; 255
    10d8:	fc 01       	movw	r30, r24
    10da:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    10dc:	00 00       	nop
    10de:	80 ec       	ldi	r24, 0xC0	; 192
    10e0:	98 e0       	ldi	r25, 0x08	; 8
    10e2:	fc 01       	movw	r30, r24
    10e4:	82 81       	ldd	r24, Z+2	; 0x02
    10e6:	88 23       	and	r24, r24
    10e8:	d4 f7       	brge	.-12     	; 0x10de <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
    10ea:	80 ec       	ldi	r24, 0xC0	; 192
    10ec:	98 e0       	ldi	r25, 0x08	; 8
    10ee:	fc 01       	movw	r30, r24
    10f0:	83 81       	ldd	r24, Z+3	; 0x03
    10f2:	80 93 72 50 	sts	0x5072, r24

	nop();
    10f6:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
    10f8:	80 ec       	ldi	r24, 0xC0	; 192
    10fa:	98 e0       	ldi	r25, 0x08	; 8
    10fc:	20 91 66 50 	lds	r18, 0x5066
    1100:	fc 01       	movw	r30, r24
    1102:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1104:	00 00       	nop
    1106:	80 ec       	ldi	r24, 0xC0	; 192
    1108:	98 e0       	ldi	r25, 0x08	; 8
    110a:	fc 01       	movw	r30, r24
    110c:	82 81       	ldd	r24, Z+2	; 0x02
    110e:	88 23       	and	r24, r24
    1110:	d4 f7       	brge	.-12     	; 0x1106 <set_filter+0xba>
	SPIBuffer[12] = SPIC.DATA;
    1112:	80 ec       	ldi	r24, 0xC0	; 192
    1114:	98 e0       	ldi	r25, 0x08	; 8
    1116:	fc 01       	movw	r30, r24
    1118:	83 81       	ldd	r24, Z+3	; 0x03
    111a:	80 93 72 50 	sts	0x5072, r24
	SPICS(FALSE);
    111e:	80 e0       	ldi	r24, 0x00	; 0
    1120:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
    1124:	89 81       	ldd	r24, Y+1	; 0x01
    1126:	88 23       	and	r24, r24
    1128:	19 f0       	breq	.+6      	; 0x1130 <set_filter+0xe4>
    112a:	80 e0       	ldi	r24, 0x00	; 0
    112c:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
    1130:	8a 81       	ldd	r24, Y+2	; 0x02
    1132:	88 23       	and	r24, r24
    1134:	19 f0       	breq	.+6      	; 0x113c <set_filter+0xf0>
    1136:	80 e0       	ldi	r24, 0x00	; 0
    1138:	0e 94 fb 36 	call	0x6df6	; 0x6df6 <upperMuxCS>
	SPIDisable();
    113c:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>
}
    1140:	23 96       	adiw	r28, 0x03	; 3
    1142:	cd bf       	out	0x3d, r28	; 61
    1144:	de bf       	out	0x3e, r29	; 62
    1146:	df 91       	pop	r29
    1148:	cf 91       	pop	r28
    114a:	08 95       	ret

0000114c <enableADCMUX>:

void enableADCMUX(uint8_t on) {
    114c:	cf 93       	push	r28
    114e:	df 93       	push	r29
    1150:	0f 92       	push	r0
    1152:	cd b7       	in	r28, 0x3d	; 61
    1154:	de b7       	in	r29, 0x3e	; 62
    1156:	89 83       	std	Y+1, r24	; 0x01
	if(on) {
    1158:	89 81       	ldd	r24, Y+1	; 0x01
    115a:	88 23       	and	r24, r24
    115c:	59 f0       	breq	.+22     	; 0x1174 <enableADCMUX+0x28>
		PORTA.DIRSET = PIN5_bm;
    115e:	80 e0       	ldi	r24, 0x00	; 0
    1160:	96 e0       	ldi	r25, 0x06	; 6
    1162:	20 e2       	ldi	r18, 0x20	; 32
    1164:	fc 01       	movw	r30, r24
    1166:	21 83       	std	Z+1, r18	; 0x01
		PORTA.OUTSET = PIN5_bm;
    1168:	80 e0       	ldi	r24, 0x00	; 0
    116a:	96 e0       	ldi	r25, 0x06	; 6
    116c:	20 e2       	ldi	r18, 0x20	; 32
    116e:	fc 01       	movw	r30, r24
    1170:	25 83       	std	Z+5, r18	; 0x05
    1172:	0a c0       	rjmp	.+20     	; 0x1188 <enableADCMUX+0x3c>
	} else {
		PORTA.OUTCLR = PIN5_bm;
    1174:	80 e0       	ldi	r24, 0x00	; 0
    1176:	96 e0       	ldi	r25, 0x06	; 6
    1178:	20 e2       	ldi	r18, 0x20	; 32
    117a:	fc 01       	movw	r30, r24
    117c:	26 83       	std	Z+6, r18	; 0x06
		PORTA.DIRCLR = PIN5_bm;
    117e:	80 e0       	ldi	r24, 0x00	; 0
    1180:	96 e0       	ldi	r25, 0x06	; 6
    1182:	20 e2       	ldi	r18, 0x20	; 32
    1184:	fc 01       	movw	r30, r24
    1186:	22 83       	std	Z+2, r18	; 0x02
	}
}
    1188:	0f 90       	pop	r0
    118a:	df 91       	pop	r29
    118c:	cf 91       	pop	r28
    118e:	08 95       	ret

00001190 <CO_collectADC>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent, uint32_t numOfSamples, int32_t* DataArray) {
    1190:	cf 92       	push	r12
    1192:	df 92       	push	r13
    1194:	ef 92       	push	r14
    1196:	ff 92       	push	r15
    1198:	0f 93       	push	r16
    119a:	1f 93       	push	r17
    119c:	cf 93       	push	r28
    119e:	df 93       	push	r29
    11a0:	cd b7       	in	r28, 0x3d	; 61
    11a2:	de b7       	in	r29, 0x3e	; 62
    11a4:	2c 97       	sbiw	r28, 0x0c	; 12
    11a6:	cd bf       	out	0x3d, r28	; 61
    11a8:	de bf       	out	0x3e, r29	; 62
    11aa:	8b 83       	std	Y+3, r24	; 0x03
    11ac:	6c 83       	std	Y+4, r22	; 0x04
    11ae:	4d 83       	std	Y+5, r20	; 0x05
    11b0:	2e 83       	std	Y+6, r18	; 0x06
    11b2:	ef 82       	std	Y+7, r14	; 0x07
    11b4:	f8 86       	std	Y+8, r15	; 0x08
    11b6:	09 87       	std	Y+9, r16	; 0x09
    11b8:	1a 87       	std	Y+10, r17	; 0x0a
    11ba:	cb 86       	std	Y+11, r12	; 0x0b
    11bc:	dc 86       	std	Y+12, r13	; 0x0c


	uint16_t period;
	ADC_BUFFER = DataArray;
    11be:	8b 85       	ldd	r24, Y+11	; 0x0b
    11c0:	9c 85       	ldd	r25, Y+12	; 0x0c
    11c2:	80 93 73 50 	sts	0x5073, r24
    11c6:	90 93 74 50 	sts	0x5074, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    11ca:	81 e0       	ldi	r24, 0x01	; 1
    11cc:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    11d0:	8b 81       	ldd	r24, Y+3	; 0x03
    11d2:	6d 81       	ldd	r22, Y+5	; 0x05
    11d4:	0e 94 f7 06 	call	0xdee	; 0xdee <set_ampGain>
	set_filter(filterConfig);
    11d8:	8c 81       	ldd	r24, Y+4	; 0x04
    11da:	0e 94 26 08 	call	0x104c	; 0x104c <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    11de:	8b 81       	ldd	r24, Y+3	; 0x03
    11e0:	85 30       	cpi	r24, 0x05	; 5
    11e2:	31 f0       	breq	.+12     	; 0x11f0 <CO_collectADC+0x60>
    11e4:	8b 81       	ldd	r24, Y+3	; 0x03
    11e6:	86 30       	cpi	r24, 0x06	; 6
    11e8:	19 f0       	breq	.+6      	; 0x11f0 <CO_collectADC+0x60>
    11ea:	8b 81       	ldd	r24, Y+3	; 0x03
    11ec:	87 30       	cpi	r24, 0x07	; 7
    11ee:	19 f4       	brne	.+6      	; 0x11f6 <CO_collectADC+0x66>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    11f0:	81 e0       	ldi	r24, 0x01	; 1
    11f2:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    11f6:	81 e0       	ldi	r24, 0x01	; 1
    11f8:	0e 94 a6 08 	call	0x114c	; 0x114c <enableADCMUX>
	setADCInput(channel);
    11fc:	8b 81       	ldd	r24, Y+3	; 0x03
    11fe:	0e 94 ad 19 	call	0x335a	; 0x335a <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    1202:	84 e0       	ldi	r24, 0x04	; 4
    1204:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1208:	80 ec       	ldi	r24, 0xC0	; 192
    120a:	98 e0       	ldi	r25, 0x08	; 8
    120c:	24 e5       	ldi	r18, 0x54	; 84
    120e:	fc 01       	movw	r30, r24
    1210:	20 83       	st	Z, r18
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    1212:	80 ea       	ldi	r24, 0xA0	; 160
    1214:	96 e0       	ldi	r25, 0x06	; 6
    1216:	21 e0       	ldi	r18, 0x01	; 1
    1218:	fc 01       	movw	r30, r24
    121a:	22 83       	std	Z+2, r18	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    121c:	80 ea       	ldi	r24, 0xA0	; 160
    121e:	96 e0       	ldi	r25, 0x06	; 6
    1220:	22 e0       	ldi	r18, 0x02	; 2
    1222:	fc 01       	movw	r30, r24
    1224:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    1226:	80 ea       	ldi	r24, 0xA0	; 160
    1228:	96 e0       	ldi	r25, 0x06	; 6
    122a:	21 e0       	ldi	r18, 0x01	; 1
    122c:	fc 01       	movw	r30, r24
    122e:	22 87       	std	Z+10, r18	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_LO_gc;				
    1230:	80 ea       	ldi	r24, 0xA0	; 160
    1232:	96 e0       	ldi	r25, 0x06	; 6
    1234:	21 e0       	ldi	r18, 0x01	; 1
    1236:	fc 01       	movw	r30, r24
    1238:	21 87       	std	Z+9, r18	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    123a:	80 e8       	ldi	r24, 0x80	; 128
    123c:	96 e0       	ldi	r25, 0x06	; 6
    123e:	20 e2       	ldi	r18, 0x20	; 32
    1240:	fc 01       	movw	r30, r24
    1242:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1244:	80 e4       	ldi	r24, 0x40	; 64
    1246:	9a e0       	ldi	r25, 0x0A	; 10
    1248:	23 e2       	ldi	r18, 0x23	; 35
    124a:	fc 01       	movw	r30, r24
    124c:	21 83       	std	Z+1, r18	; 0x01
	// set period
	period = (1 << (21 - spsExponent)) - 1;
    124e:	8e 81       	ldd	r24, Y+6	; 0x06
    1250:	88 2f       	mov	r24, r24
    1252:	90 e0       	ldi	r25, 0x00	; 0
    1254:	25 e1       	ldi	r18, 0x15	; 21
    1256:	30 e0       	ldi	r19, 0x00	; 0
    1258:	28 1b       	sub	r18, r24
    125a:	39 0b       	sbc	r19, r25
    125c:	81 e0       	ldi	r24, 0x01	; 1
    125e:	90 e0       	ldi	r25, 0x00	; 0
    1260:	02 c0       	rjmp	.+4      	; 0x1266 <CO_collectADC+0xd6>
    1262:	88 0f       	add	r24, r24
    1264:	99 1f       	adc	r25, r25
    1266:	2a 95       	dec	r18
    1268:	e2 f7       	brpl	.-8      	; 0x1262 <CO_collectADC+0xd2>
    126a:	01 97       	sbiw	r24, 0x01	; 1
    126c:	89 83       	std	Y+1, r24	; 0x01
    126e:	9a 83       	std	Y+2, r25	; 0x02
	TCE1.PER = period;
    1270:	80 e4       	ldi	r24, 0x40	; 64
    1272:	9a e0       	ldi	r25, 0x0A	; 10
    1274:	29 81       	ldd	r18, Y+1	; 0x01
    1276:	3a 81       	ldd	r19, Y+2	; 0x02
    1278:	fc 01       	movw	r30, r24
    127a:	26 a3       	lds	r18, 0x56
    127c:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = period / 2;
    127e:	80 e4       	ldi	r24, 0x40	; 64
    1280:	9a e0       	ldi	r25, 0x0A	; 10
    1282:	29 81       	ldd	r18, Y+1	; 0x01
    1284:	3a 81       	ldd	r19, Y+2	; 0x02
    1286:	36 95       	lsr	r19
    1288:	27 95       	ror	r18
    128a:	fc 01       	movw	r30, r24
    128c:	22 af       	sts	0x72, r18
    128e:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1290:	80 e4       	ldi	r24, 0x40	; 64
    1292:	9a e0       	ldi	r25, 0x0A	; 10
    1294:	20 e4       	ldi	r18, 0x40	; 64
    1296:	3a e0       	ldi	r19, 0x0A	; 10
    1298:	f9 01       	movw	r30, r18
    129a:	20 81       	ld	r18, Z
    129c:	20 7f       	andi	r18, 0xF0	; 240
    129e:	21 60       	ori	r18, 0x01	; 1
    12a0:	fc 01       	movw	r30, r24
    12a2:	20 83       	st	Z, r18
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    12a4:	80 ea       	ldi	r24, 0xA0	; 160
    12a6:	90 e0       	ldi	r25, 0x00	; 0
    12a8:	20 ea       	ldi	r18, 0xA0	; 160
    12aa:	30 e0       	ldi	r19, 0x00	; 0
    12ac:	f9 01       	movw	r30, r18
    12ae:	22 81       	ldd	r18, Z+2	; 0x02
    12b0:	21 60       	ori	r18, 0x01	; 1
    12b2:	fc 01       	movw	r30, r24
    12b4:	22 83       	std	Z+2, r18	; 0x02
	sei();
    12b6:	78 94       	sei

	sampleCount = 0;
    12b8:	10 92 75 50 	sts	0x5075, r1
    12bc:	10 92 76 50 	sts	0x5076, r1
    12c0:	10 92 77 50 	sts	0x5077, r1
    12c4:	10 92 78 50 	sts	0x5078, r1
	discardCount = 0;
    12c8:	10 92 5e 40 	sts	0x405E, r1
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    12cc:	00 00       	nop
    12ce:	20 91 75 50 	lds	r18, 0x5075
    12d2:	30 91 76 50 	lds	r19, 0x5076
    12d6:	40 91 77 50 	lds	r20, 0x5077
    12da:	50 91 78 50 	lds	r21, 0x5078
    12de:	8f 81       	ldd	r24, Y+7	; 0x07
    12e0:	98 85       	ldd	r25, Y+8	; 0x08
    12e2:	a9 85       	ldd	r26, Y+9	; 0x09
    12e4:	ba 85       	ldd	r27, Y+10	; 0x0a
    12e6:	28 17       	cp	r18, r24
    12e8:	39 07       	cpc	r19, r25
    12ea:	4a 07       	cpc	r20, r26
    12ec:	5b 07       	cpc	r21, r27
    12ee:	78 f3       	brcs	.-34     	; 0x12ce <CO_collectADC+0x13e>

	// turn off timer and interupts
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    12f0:	80 e4       	ldi	r24, 0x40	; 64
    12f2:	9a e0       	ldi	r25, 0x0A	; 10
    12f4:	20 e4       	ldi	r18, 0x40	; 64
    12f6:	3a e0       	ldi	r19, 0x0A	; 10
    12f8:	f9 01       	movw	r30, r18
    12fa:	20 81       	ld	r18, Z
    12fc:	20 7f       	andi	r18, 0xF0	; 240
    12fe:	fc 01       	movw	r30, r24
    1300:	20 83       	st	Z, r18
	PMIC.CTRL &= ~PMIC_LOLVLEN_bm;	
    1302:	80 ea       	ldi	r24, 0xA0	; 160
    1304:	90 e0       	ldi	r25, 0x00	; 0
    1306:	20 ea       	ldi	r18, 0xA0	; 160
    1308:	30 e0       	ldi	r19, 0x00	; 0
    130a:	f9 01       	movw	r30, r18
    130c:	22 81       	ldd	r18, Z+2	; 0x02
    130e:	2e 7f       	andi	r18, 0xFE	; 254
    1310:	fc 01       	movw	r30, r24
    1312:	22 83       	std	Z+2, r18	; 0x02
	cli();
    1314:	f8 94       	cli

	SPIDisable();	
    1316:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>
	enableADCMUX(FALSE);
    131a:	80 e0       	ldi	r24, 0x00	; 0
    131c:	0e 94 a6 08 	call	0x114c	; 0x114c <enableADCMUX>
	//ADCPower(FALSE);
}
    1320:	2c 96       	adiw	r28, 0x0c	; 12
    1322:	cd bf       	out	0x3d, r28	; 61
    1324:	de bf       	out	0x3e, r29	; 62
    1326:	df 91       	pop	r29
    1328:	cf 91       	pop	r28
    132a:	1f 91       	pop	r17
    132c:	0f 91       	pop	r16
    132e:	ff 90       	pop	r15
    1330:	ef 90       	pop	r14
    1332:	df 90       	pop	r13
    1334:	cf 90       	pop	r12
    1336:	08 95       	ret

00001338 <CO_collectADC_cont>:

//continuously take samples and send them via radio. NOT RECOMMENDET
void CO_collectADC_cont(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent) {
    1338:	cf 93       	push	r28
    133a:	df 93       	push	r29
    133c:	00 d0       	rcall	.+0      	; 0x133e <CO_collectADC_cont+0x6>
    133e:	00 d0       	rcall	.+0      	; 0x1340 <CO_collectADC_cont+0x8>
    1340:	cd b7       	in	r28, 0x3d	; 61
    1342:	de b7       	in	r29, 0x3e	; 62
    1344:	8b 83       	std	Y+3, r24	; 0x03
    1346:	6c 83       	std	Y+4, r22	; 0x04
    1348:	4d 83       	std	Y+5, r20	; 0x05
    134a:	2e 83       	std	Y+6, r18	; 0x06

uint16_t period;

// Turn on power to ADC and PortEx
ADCPower(TRUE);
    134c:	81 e0       	ldi	r24, 0x01	; 1
    134e:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
//get data to write files to SD card
//getBootSectorData();
// set gain, filters, and ADC input for appropriate VIN
set_ampGain(channel, gainExponent);
    1352:	8b 81       	ldd	r24, Y+3	; 0x03
    1354:	6d 81       	ldd	r22, Y+5	; 0x05
    1356:	0e 94 f7 06 	call	0xdee	; 0xdee <set_ampGain>
set_filter(filterConfig);
    135a:	8c 81       	ldd	r24, Y+4	; 0x04
    135c:	0e 94 26 08 	call	0x104c	; 0x104c <set_filter>

// if acc channel then enable DC Pass
// it is assumed that if not using high frequency acc specific function then
// DC Pass is wanted.
if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) ||
    1360:	8b 81       	ldd	r24, Y+3	; 0x03
    1362:	85 30       	cpi	r24, 0x05	; 5
    1364:	31 f0       	breq	.+12     	; 0x1372 <CO_collectADC_cont+0x3a>
    1366:	8b 81       	ldd	r24, Y+3	; 0x03
    1368:	86 30       	cpi	r24, 0x06	; 6
    136a:	19 f0       	breq	.+6      	; 0x1372 <CO_collectADC_cont+0x3a>
    136c:	8b 81       	ldd	r24, Y+3	; 0x03
    136e:	87 30       	cpi	r24, 0x07	; 7
    1370:	19 f4       	brne	.+6      	; 0x1378 <CO_collectADC_cont+0x40>
(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    1372:	81 e0       	ldi	r24, 0x01	; 1
    1374:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <ACC_DCPassEnable>

enableADCMUX(TRUE);
    1378:	81 e0       	ldi	r24, 0x01	; 1
    137a:	0e 94 a6 08 	call	0x114c	; 0x114c <enableADCMUX>
setADCInput(channel);
    137e:	8b 81       	ldd	r24, Y+3	; 0x03
    1380:	0e 94 ad 19 	call	0x335a	; 0x335a <setADCInput>
SPIInit(SPI_MODE_1_gc);
    1384:	84 e0       	ldi	r24, 0x04	; 4
    1386:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>
SPIC.CTRL = ADC_SPI_CONFIG_gc;
    138a:	80 ec       	ldi	r24, 0xC0	; 192
    138c:	98 e0       	ldi	r25, 0x08	; 8
    138e:	24 e5       	ldi	r18, 0x54	; 84
    1390:	fc 01       	movw	r30, r24
    1392:	20 83       	st	Z, r18

// Configure IO13 (PF0) to capture ADC DRDY signal
PORTF.DIRCLR = PIN0_bm;
    1394:	80 ea       	ldi	r24, 0xA0	; 160
    1396:	96 e0       	ldi	r25, 0x06	; 6
    1398:	21 e0       	ldi	r18, 0x01	; 1
    139a:	fc 01       	movw	r30, r24
    139c:	22 83       	std	Z+2, r18	; 0x02
PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    139e:	80 ea       	ldi	r24, 0xA0	; 160
    13a0:	96 e0       	ldi	r25, 0x06	; 6
    13a2:	22 e0       	ldi	r18, 0x02	; 2
    13a4:	fc 01       	movw	r30, r24
    13a6:	20 8b       	std	Z+16, r18	; 0x10
//PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_PULLUP_gc;
PORTF.INT1MASK = PIN0_bm;
    13a8:	80 ea       	ldi	r24, 0xA0	; 160
    13aa:	96 e0       	ldi	r25, 0x06	; 6
    13ac:	21 e0       	ldi	r18, 0x01	; 1
    13ae:	fc 01       	movw	r30, r24
    13b0:	23 87       	std	Z+11, r18	; 0x0b
PORTF.INTCTRL = PORT_INT1LVL_MED_gc;
    13b2:	80 ea       	ldi	r24, 0xA0	; 160
    13b4:	96 e0       	ldi	r25, 0x06	; 6
    13b6:	28 e0       	ldi	r18, 0x08	; 8
    13b8:	fc 01       	movw	r30, r24
    13ba:	21 87       	std	Z+9, r18	; 0x09
//f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
//the TCE1 counter increments every pulse of the system clock and once it reaches a certain value it 
//toggles pin 5 (clock input to ADC). This effectively divides the system clock into a desired clock rate for 
//the ADC. 
// Set IO14 (PE5) to output
PORTE.DIRSET = PIN5_bm;
    13bc:	80 e8       	ldi	r24, 0x80	; 128
    13be:	96 e0       	ldi	r25, 0x06	; 6
    13c0:	20 e2       	ldi	r18, 0x20	; 32
    13c2:	fc 01       	movw	r30, r24
    13c4:	21 83       	std	Z+1, r18	; 0x01
// Set Waveform generator mode(single slope) and enable the CCx output to IO14 (PE5)
TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    13c6:	80 e4       	ldi	r24, 0x40	; 64
    13c8:	9a e0       	ldi	r25, 0x0A	; 10
    13ca:	23 e2       	ldi	r18, 0x23	; 35
    13cc:	fc 01       	movw	r30, r24
    13ce:	21 83       	std	Z+1, r18	; 0x01
// set period
period = (1 << (21 - spsExponent)) - 1;
    13d0:	8e 81       	ldd	r24, Y+6	; 0x06
    13d2:	88 2f       	mov	r24, r24
    13d4:	90 e0       	ldi	r25, 0x00	; 0
    13d6:	25 e1       	ldi	r18, 0x15	; 21
    13d8:	30 e0       	ldi	r19, 0x00	; 0
    13da:	28 1b       	sub	r18, r24
    13dc:	39 0b       	sbc	r19, r25
    13de:	81 e0       	ldi	r24, 0x01	; 1
    13e0:	90 e0       	ldi	r25, 0x00	; 0
    13e2:	02 c0       	rjmp	.+4      	; 0x13e8 <CO_collectADC_cont+0xb0>
    13e4:	88 0f       	add	r24, r24
    13e6:	99 1f       	adc	r25, r25
    13e8:	2a 95       	dec	r18
    13ea:	e2 f7       	brpl	.-8      	; 0x13e4 <CO_collectADC_cont+0xac>
    13ec:	01 97       	sbiw	r24, 0x01	; 1
    13ee:	89 83       	std	Y+1, r24	; 0x01
    13f0:	9a 83       	std	Y+2, r25	; 0x02
TCE1.PER = period;
    13f2:	80 e4       	ldi	r24, 0x40	; 64
    13f4:	9a e0       	ldi	r25, 0x0A	; 10
    13f6:	29 81       	ldd	r18, Y+1	; 0x01
    13f8:	3a 81       	ldd	r19, Y+2	; 0x02
    13fa:	fc 01       	movw	r30, r24
    13fc:	26 a3       	lds	r18, 0x56
    13fe:	37 a3       	lds	r19, 0x57
TCE1.CCBBUF = period / 2;
    1400:	80 e4       	ldi	r24, 0x40	; 64
    1402:	9a e0       	ldi	r25, 0x0A	; 10
    1404:	29 81       	ldd	r18, Y+1	; 0x01
    1406:	3a 81       	ldd	r19, Y+2	; 0x02
    1408:	36 95       	lsr	r19
    140a:	27 95       	ror	r18
    140c:	fc 01       	movw	r30, r24
    140e:	22 af       	sts	0x72, r18
    1410:	33 af       	sts	0x73, r19
// Set oscillator source and frequency and start
TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1412:	80 e4       	ldi	r24, 0x40	; 64
    1414:	9a e0       	ldi	r25, 0x0A	; 10
    1416:	20 e4       	ldi	r18, 0x40	; 64
    1418:	3a e0       	ldi	r19, 0x0A	; 10
    141a:	f9 01       	movw	r30, r18
    141c:	20 81       	ld	r18, Z
    141e:	20 7f       	andi	r18, 0xF0	; 240
    1420:	21 60       	ori	r18, 0x01	; 1
    1422:	fc 01       	movw	r30, r24
    1424:	20 83       	st	Z, r18

// Enable interrupts.
PMIC.CTRL |= PMIC_MEDLVLEN_bm;
    1426:	80 ea       	ldi	r24, 0xA0	; 160
    1428:	90 e0       	ldi	r25, 0x00	; 0
    142a:	20 ea       	ldi	r18, 0xA0	; 160
    142c:	30 e0       	ldi	r19, 0x00	; 0
    142e:	f9 01       	movw	r30, r18
    1430:	22 81       	ldd	r18, Z+2	; 0x02
    1432:	22 60       	ori	r18, 0x02	; 2
    1434:	fc 01       	movw	r30, r24
    1436:	22 83       	std	Z+2, r18	; 0x02
//enable RR of lowlvl interrupts
PMIC.CTRL |= PMIC_RREN_bm; 
    1438:	80 ea       	ldi	r24, 0xA0	; 160
    143a:	90 e0       	ldi	r25, 0x00	; 0
    143c:	20 ea       	ldi	r18, 0xA0	; 160
    143e:	30 e0       	ldi	r19, 0x00	; 0
    1440:	f9 01       	movw	r30, r18
    1442:	22 81       	ldd	r18, Z+2	; 0x02
    1444:	20 68       	ori	r18, 0x80	; 128
    1446:	fc 01       	movw	r30, r24
    1448:	22 83       	std	Z+2, r18	; 0x02
//perhaps next two lines are redundant...
// chb_init();
// chb_set_short_addr(moteID);

sampleCount = 0;
    144a:	10 92 75 50 	sts	0x5075, r1
    144e:	10 92 76 50 	sts	0x5076, r1
    1452:	10 92 77 50 	sts	0x5077, r1
    1456:	10 92 78 50 	sts	0x5078, r1
TotalSampleCount = 0;
    145a:	10 92 a5 50 	sts	0x50A5, r1
    145e:	10 92 a6 50 	sts	0x50A6, r1
discardCount = 0;
    1462:	10 92 5e 40 	sts	0x405E, r1
sei();
    1466:	78 94       	sei
}
    1468:	26 96       	adiw	r28, 0x06	; 6
    146a:	cd bf       	out	0x3d, r28	; 61
    146c:	de bf       	out	0x3e, r29	; 62
    146e:	df 91       	pop	r29
    1470:	cf 91       	pop	r28
    1472:	08 95       	ret

00001474 <ADC_Pause_Sampling>:

void ADC_Pause_Sampling(){
    1474:	cf 93       	push	r28
    1476:	df 93       	push	r29
    1478:	cd b7       	in	r28, 0x3d	; 61
    147a:	de b7       	in	r29, 0x3e	; 62
		//ignore interrupts from the ADC...don't turn it off to avoid the boot up time
	PORTF.INT1MASK = 0x00;
    147c:	80 ea       	ldi	r24, 0xA0	; 160
    147e:	96 e0       	ldi	r25, 0x06	; 6
    1480:	fc 01       	movw	r30, r24
    1482:	13 86       	std	Z+11, r1	; 0x0b
}
    1484:	df 91       	pop	r29
    1486:	cf 91       	pop	r28
    1488:	08 95       	ret

0000148a <ADC_Resume_Sampling>:

void ADC_Resume_Sampling(){
    148a:	cf 93       	push	r28
    148c:	df 93       	push	r29
    148e:	cd b7       	in	r28, 0x3d	; 61
    1490:	de b7       	in	r29, 0x3e	; 62
	//re-enable interrupt on port F which the ADC uses
	PORTF.INT1MASK = PIN0_bm;
    1492:	80 ea       	ldi	r24, 0xA0	; 160
    1494:	96 e0       	ldi	r25, 0x06	; 6
    1496:	21 e0       	ldi	r18, 0x01	; 1
    1498:	fc 01       	movw	r30, r24
    149a:	23 87       	std	Z+11, r18	; 0x0b
}	
    149c:	df 91       	pop	r29
    149e:	cf 91       	pop	r28
    14a0:	08 95       	ret

000014a2 <__vector_105>:

//ISR used by CO_collectADC_cont function
ISR(PORTF_INT1_vect) {
    14a2:	1f 92       	push	r1
    14a4:	0f 92       	push	r0
    14a6:	0f b6       	in	r0, 0x3f	; 63
    14a8:	0f 92       	push	r0
    14aa:	00 90 3b 00 	lds	r0, 0x003B
    14ae:	0f 92       	push	r0
    14b0:	11 24       	eor	r1, r1
    14b2:	2f 92       	push	r2
    14b4:	3f 92       	push	r3
    14b6:	4f 92       	push	r4
    14b8:	5f 92       	push	r5
    14ba:	6f 92       	push	r6
    14bc:	7f 92       	push	r7
    14be:	8f 92       	push	r8
    14c0:	9f 92       	push	r9
    14c2:	af 92       	push	r10
    14c4:	bf 92       	push	r11
    14c6:	cf 92       	push	r12
    14c8:	df 92       	push	r13
    14ca:	ef 92       	push	r14
    14cc:	ff 92       	push	r15
    14ce:	0f 93       	push	r16
    14d0:	1f 93       	push	r17
    14d2:	2f 93       	push	r18
    14d4:	3f 93       	push	r19
    14d6:	4f 93       	push	r20
    14d8:	5f 93       	push	r21
    14da:	6f 93       	push	r22
    14dc:	7f 93       	push	r23
    14de:	8f 93       	push	r24
    14e0:	9f 93       	push	r25
    14e2:	af 93       	push	r26
    14e4:	bf 93       	push	r27
    14e6:	ef 93       	push	r30
    14e8:	ff 93       	push	r31
    14ea:	cf 93       	push	r28
    14ec:	df 93       	push	r29
    14ee:	00 d0       	rcall	.+0      	; 0x14f0 <__vector_105+0x4e>
    14f0:	cd b7       	in	r28, 0x3d	; 61
    14f2:	de b7       	in	r29, 0x3e	; 62
			nop();
		}		
	}
	*/		
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
    14f4:	80 91 5e 40 	lds	r24, 0x405E
    14f8:	88 23       	and	r24, r24
    14fa:	34 f0       	brlt	.+12     	; 0x1508 <__vector_105+0x66>
		discardCount++;
    14fc:	80 91 5e 40 	lds	r24, 0x405E
    1500:	8f 5f       	subi	r24, 0xFF	; 255
    1502:	80 93 5e 40 	sts	0x405E, r24
    1506:	af c1       	rjmp	.+862    	; 0x1866 <__vector_105+0x3c4>
	}		
	else {
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
    1508:	84 e0       	ldi	r24, 0x04	; 4
    150a:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
    150e:	80 ec       	ldi	r24, 0xC0	; 192
    1510:	98 e0       	ldi	r25, 0x08	; 8
    1512:	24 e5       	ldi	r18, 0x54	; 84
    1514:	fc 01       	movw	r30, r24
    1516:	20 83       	st	Z, r18
		SPICS(TRUE); // CS SPI-SS
    1518:	81 e0       	ldi	r24, 0x01	; 1
    151a:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    151e:	80 ea       	ldi	r24, 0xA0	; 160
    1520:	96 e0       	ldi	r25, 0x06	; 6
    1522:	22 e0       	ldi	r18, 0x02	; 2
    1524:	fc 01       	movw	r30, r24
    1526:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1528:	19 82       	std	Y+1, r1	; 0x01
    152a:	1a c0       	rjmp	.+52     	; 0x1560 <__vector_105+0xbe>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    152c:	80 ec       	ldi	r24, 0xC0	; 192
    152e:	98 e0       	ldi	r25, 0x08	; 8
    1530:	2a ea       	ldi	r18, 0xAA	; 170
    1532:	fc 01       	movw	r30, r24
    1534:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1536:	00 00       	nop
    1538:	80 ec       	ldi	r24, 0xC0	; 192
    153a:	98 e0       	ldi	r25, 0x08	; 8
    153c:	fc 01       	movw	r30, r24
    153e:	82 81       	ldd	r24, Z+2	; 0x02
    1540:	88 23       	and	r24, r24
    1542:	d4 f7       	brge	.-12     	; 0x1538 <__vector_105+0x96>
			SPIBuffer[bufIndex] = SPIC.DATA;
    1544:	89 81       	ldd	r24, Y+1	; 0x01
    1546:	88 2f       	mov	r24, r24
    1548:	90 e0       	ldi	r25, 0x00	; 0
    154a:	20 ec       	ldi	r18, 0xC0	; 192
    154c:	38 e0       	ldi	r19, 0x08	; 8
    154e:	f9 01       	movw	r30, r18
    1550:	23 81       	ldd	r18, Z+3	; 0x03
    1552:	8a 59       	subi	r24, 0x9A	; 154
    1554:	9f 4a       	sbci	r25, 0xAF	; 175
    1556:	fc 01       	movw	r30, r24
    1558:	20 83       	st	Z, r18
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    155a:	89 81       	ldd	r24, Y+1	; 0x01
    155c:	8f 5f       	subi	r24, 0xFF	; 255
    155e:	89 83       	std	Y+1, r24	; 0x01
    1560:	89 81       	ldd	r24, Y+1	; 0x01
    1562:	83 30       	cpi	r24, 0x03	; 3
    1564:	18 f3       	brcs	.-58     	; 0x152c <__vector_105+0x8a>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1566:	80 ea       	ldi	r24, 0xA0	; 160
    1568:	96 e0       	ldi	r25, 0x06	; 6
    156a:	22 e0       	ldi	r18, 0x02	; 2
    156c:	fc 01       	movw	r30, r24
    156e:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    1570:	80 e0       	ldi	r24, 0x00	; 0
    1572:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>

		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[0]) + 3) = 0xFF; // sign extension if negative
    1576:	80 91 66 50 	lds	r24, 0x5066
    157a:	88 23       	and	r24, r24
    157c:	34 f4       	brge	.+12     	; 0x158a <__vector_105+0xe8>
    157e:	87 e6       	ldi	r24, 0x67	; 103
    1580:	90 e4       	ldi	r25, 0x40	; 64
    1582:	2f ef       	ldi	r18, 0xFF	; 255
    1584:	fc 01       	movw	r30, r24
    1586:	20 83       	st	Z, r18
    1588:	04 c0       	rjmp	.+8      	; 0x1592 <__vector_105+0xf0>
		else *(((uint8_t*)&data24Bit[0]) + 3) = 0x00;				
    158a:	87 e6       	ldi	r24, 0x67	; 103
    158c:	90 e4       	ldi	r25, 0x40	; 64
    158e:	fc 01       	movw	r30, r24
    1590:	10 82       	st	Z, r1
		*(((uint8_t*)&data24Bit[0]) + 2) = SPIBuffer[0];
    1592:	86 e6       	ldi	r24, 0x66	; 102
    1594:	90 e4       	ldi	r25, 0x40	; 64
    1596:	20 91 66 50 	lds	r18, 0x5066
    159a:	fc 01       	movw	r30, r24
    159c:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 1) = SPIBuffer[1];
    159e:	85 e6       	ldi	r24, 0x65	; 101
    15a0:	90 e4       	ldi	r25, 0x40	; 64
    15a2:	20 91 67 50 	lds	r18, 0x5067
    15a6:	fc 01       	movw	r30, r24
    15a8:	20 83       	st	Z, r18
		*(((uint8_t*)&data24Bit[0]) + 0) = SPIBuffer[2];
    15aa:	84 e6       	ldi	r24, 0x64	; 100
    15ac:	90 e4       	ldi	r25, 0x40	; 64
    15ae:	20 91 68 50 	lds	r18, 0x5068
    15b2:	fc 01       	movw	r30, r24
    15b4:	20 83       	st	Z, r18
		
		//convert ADC reading to voltage here (in uV)
		var = data24Bit[0];
    15b6:	80 91 64 40 	lds	r24, 0x4064
    15ba:	90 91 65 40 	lds	r25, 0x4065
    15be:	a0 91 66 40 	lds	r26, 0x4066
    15c2:	b0 91 67 40 	lds	r27, 0x4067
    15c6:	5c 01       	movw	r10, r24
    15c8:	6d 01       	movw	r12, r26
    15ca:	bb 0f       	add	r27, r27
    15cc:	88 0b       	sbc	r24, r24
    15ce:	98 2f       	mov	r25, r24
    15d0:	dc 01       	movw	r26, r24
    15d2:	e8 2e       	mov	r14, r24
    15d4:	f8 2e       	mov	r15, r24
    15d6:	08 2f       	mov	r16, r24
    15d8:	18 2f       	mov	r17, r24
    15da:	a0 92 a7 50 	sts	0x50A7, r10
    15de:	b0 92 a8 50 	sts	0x50A8, r11
    15e2:	c0 92 a9 50 	sts	0x50A9, r12
    15e6:	d0 92 aa 50 	sts	0x50AA, r13
    15ea:	e0 92 ab 50 	sts	0x50AB, r14
    15ee:	f0 92 ac 50 	sts	0x50AC, r15
    15f2:	00 93 ad 50 	sts	0x50AD, r16
    15f6:	10 93 ae 50 	sts	0x50AE, r17
		*((int32_t*)&FRAMReadBuffer[sampleCount*4]) = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    15fa:	80 91 75 50 	lds	r24, 0x5075
    15fe:	90 91 76 50 	lds	r25, 0x5076
    1602:	a0 91 77 50 	lds	r26, 0x5077
    1606:	b0 91 78 50 	lds	r27, 0x5078
    160a:	88 0f       	add	r24, r24
    160c:	99 1f       	adc	r25, r25
    160e:	88 0f       	add	r24, r24
    1610:	99 1f       	adc	r25, r25
    1612:	9c 01       	movw	r18, r24
    1614:	28 52       	subi	r18, 0x28	; 40
    1616:	3c 4d       	sbci	r19, 0xDC	; 220
    1618:	2a 83       	std	Y+2, r18	; 0x02
    161a:	3b 83       	std	Y+3, r19	; 0x03
    161c:	a0 90 a7 50 	lds	r10, 0x50A7
    1620:	b0 90 a8 50 	lds	r11, 0x50A8
    1624:	c0 90 a9 50 	lds	r12, 0x50A9
    1628:	d0 90 aa 50 	lds	r13, 0x50AA
    162c:	e0 90 ab 50 	lds	r14, 0x50AB
    1630:	f0 90 ac 50 	lds	r15, 0x50AC
    1634:	00 91 ad 50 	lds	r16, 0x50AD
    1638:	10 91 ae 50 	lds	r17, 0x50AE
    163c:	2a 2d       	mov	r18, r10
    163e:	3b 2d       	mov	r19, r11
    1640:	4c 2d       	mov	r20, r12
    1642:	5d 2d       	mov	r21, r13
    1644:	6e 2d       	mov	r22, r14
    1646:	7f 2d       	mov	r23, r15
    1648:	80 2f       	mov	r24, r16
    164a:	91 2f       	mov	r25, r17
    164c:	0f 2e       	mov	r0, r31
    164e:	f0 ea       	ldi	r31, 0xA0	; 160
    1650:	af 2e       	mov	r10, r31
    1652:	f0 2d       	mov	r31, r0
    1654:	0f 2e       	mov	r0, r31
    1656:	f5 e2       	ldi	r31, 0x25	; 37
    1658:	bf 2e       	mov	r11, r31
    165a:	f0 2d       	mov	r31, r0
    165c:	0f 2e       	mov	r0, r31
    165e:	f6 e2       	ldi	r31, 0x26	; 38
    1660:	cf 2e       	mov	r12, r31
    1662:	f0 2d       	mov	r31, r0
    1664:	dd 24       	eor	r13, r13
    1666:	ee 24       	eor	r14, r14
    1668:	ff 24       	eor	r15, r15
    166a:	00 e0       	ldi	r16, 0x00	; 0
    166c:	10 e0       	ldi	r17, 0x00	; 0
    166e:	0e 94 1c 51 	call	0xa238	; 0xa238 <__muldi3>
    1672:	22 2e       	mov	r2, r18
    1674:	33 2e       	mov	r3, r19
    1676:	44 2e       	mov	r4, r20
    1678:	55 2e       	mov	r5, r21
    167a:	66 2e       	mov	r6, r22
    167c:	77 2e       	mov	r7, r23
    167e:	88 2e       	mov	r8, r24
    1680:	99 2e       	mov	r9, r25
    1682:	a2 2c       	mov	r10, r2
    1684:	b3 2c       	mov	r11, r3
    1686:	c4 2c       	mov	r12, r4
    1688:	d5 2c       	mov	r13, r5
    168a:	e6 2c       	mov	r14, r6
    168c:	f7 2c       	mov	r15, r7
    168e:	08 2d       	mov	r16, r8
    1690:	19 2d       	mov	r17, r9
    1692:	2a 2d       	mov	r18, r10
    1694:	3b 2d       	mov	r19, r11
    1696:	4c 2d       	mov	r20, r12
    1698:	5d 2d       	mov	r21, r13
    169a:	6e 2d       	mov	r22, r14
    169c:	7f 2d       	mov	r23, r15
    169e:	80 2f       	mov	r24, r16
    16a0:	91 2f       	mov	r25, r17
    16a2:	aa 24       	eor	r10, r10
    16a4:	aa 94       	dec	r10
    16a6:	bb 24       	eor	r11, r11
    16a8:	ba 94       	dec	r11
    16aa:	0f 2e       	mov	r0, r31
    16ac:	ff e7       	ldi	r31, 0x7F	; 127
    16ae:	cf 2e       	mov	r12, r31
    16b0:	f0 2d       	mov	r31, r0
    16b2:	dd 24       	eor	r13, r13
    16b4:	ee 24       	eor	r14, r14
    16b6:	ff 24       	eor	r15, r15
    16b8:	00 e0       	ldi	r16, 0x00	; 0
    16ba:	10 e0       	ldi	r17, 0x00	; 0
    16bc:	0e 94 63 52 	call	0xa4c6	; 0xa4c6 <__divdi3>
    16c0:	22 2e       	mov	r2, r18
    16c2:	33 2e       	mov	r3, r19
    16c4:	44 2e       	mov	r4, r20
    16c6:	55 2e       	mov	r5, r21
    16c8:	66 2e       	mov	r6, r22
    16ca:	77 2e       	mov	r7, r23
    16cc:	88 2e       	mov	r8, r24
    16ce:	99 2e       	mov	r9, r25
    16d0:	a2 2c       	mov	r10, r2
    16d2:	b3 2c       	mov	r11, r3
    16d4:	c4 2c       	mov	r12, r4
    16d6:	d5 2c       	mov	r13, r5
    16d8:	e6 2c       	mov	r14, r6
    16da:	f7 2c       	mov	r15, r7
    16dc:	08 2d       	mov	r16, r8
    16de:	19 2d       	mov	r17, r9
    16e0:	2a 2d       	mov	r18, r10
    16e2:	3b 2d       	mov	r19, r11
    16e4:	4c 2d       	mov	r20, r12
    16e6:	5d 2d       	mov	r21, r13
    16e8:	6e 2d       	mov	r22, r14
    16ea:	7f 2d       	mov	r23, r15
    16ec:	80 2f       	mov	r24, r16
    16ee:	91 2f       	mov	r25, r17
    16f0:	01 e0       	ldi	r16, 0x01	; 1
    16f2:	0e 94 ef 51 	call	0xa3de	; 0xa3de <__ashldi3>
    16f6:	22 2e       	mov	r2, r18
    16f8:	33 2e       	mov	r3, r19
    16fa:	44 2e       	mov	r4, r20
    16fc:	55 2e       	mov	r5, r21
    16fe:	66 2e       	mov	r6, r22
    1700:	77 2e       	mov	r7, r23
    1702:	88 2e       	mov	r8, r24
    1704:	99 2e       	mov	r9, r25
    1706:	a2 2c       	mov	r10, r2
    1708:	b3 2c       	mov	r11, r3
    170a:	c4 2c       	mov	r12, r4
    170c:	d5 2c       	mov	r13, r5
    170e:	e6 2c       	mov	r14, r6
    1710:	f7 2c       	mov	r15, r7
    1712:	08 2d       	mov	r16, r8
    1714:	19 2d       	mov	r17, r9
    1716:	2a 2d       	mov	r18, r10
    1718:	3b 2d       	mov	r19, r11
    171a:	4c 2d       	mov	r20, r12
    171c:	5d 2d       	mov	r21, r13
    171e:	6e 2d       	mov	r22, r14
    1720:	7f 2d       	mov	r23, r15
    1722:	80 2f       	mov	r24, r16
    1724:	91 2f       	mov	r25, r17
    1726:	0f 2e       	mov	r0, r31
    1728:	f3 e0       	ldi	r31, 0x03	; 3
    172a:	af 2e       	mov	r10, r31
    172c:	f0 2d       	mov	r31, r0
    172e:	bb 24       	eor	r11, r11
    1730:	cc 24       	eor	r12, r12
    1732:	dd 24       	eor	r13, r13
    1734:	ee 24       	eor	r14, r14
    1736:	ff 24       	eor	r15, r15
    1738:	00 e0       	ldi	r16, 0x00	; 0
    173a:	10 e0       	ldi	r17, 0x00	; 0
    173c:	0e 94 63 52 	call	0xa4c6	; 0xa4c6 <__divdi3>
    1740:	a2 2e       	mov	r10, r18
    1742:	b3 2e       	mov	r11, r19
    1744:	c4 2e       	mov	r12, r20
    1746:	d5 2e       	mov	r13, r21
    1748:	e6 2e       	mov	r14, r22
    174a:	f7 2e       	mov	r15, r23
    174c:	08 2f       	mov	r16, r24
    174e:	19 2f       	mov	r17, r25
    1750:	2a 2d       	mov	r18, r10
    1752:	3b 2d       	mov	r19, r11
    1754:	4c 2d       	mov	r20, r12
    1756:	5d 2d       	mov	r21, r13
    1758:	6e 2d       	mov	r22, r14
    175a:	7f 2d       	mov	r23, r15
    175c:	80 2f       	mov	r24, r16
    175e:	91 2f       	mov	r25, r17
    1760:	da 01       	movw	r26, r20
    1762:	c9 01       	movw	r24, r18
    1764:	b0 95       	com	r27
    1766:	a0 95       	com	r26
    1768:	90 95       	com	r25
    176a:	81 95       	neg	r24
    176c:	9f 4f       	sbci	r25, 0xFF	; 255
    176e:	af 4f       	sbci	r26, 0xFF	; 255
    1770:	bf 4f       	sbci	r27, 0xFF	; 255
    1772:	ea 81       	ldd	r30, Y+2	; 0x02
    1774:	fb 81       	ldd	r31, Y+3	; 0x03
    1776:	80 83       	st	Z, r24
    1778:	91 83       	std	Z+1, r25	; 0x01
    177a:	a2 83       	std	Z+2, r26	; 0x02
    177c:	b3 83       	std	Z+3, r27	; 0x03
		
		sampleCount++;
    177e:	80 91 75 50 	lds	r24, 0x5075
    1782:	90 91 76 50 	lds	r25, 0x5076
    1786:	a0 91 77 50 	lds	r26, 0x5077
    178a:	b0 91 78 50 	lds	r27, 0x5078
    178e:	01 96       	adiw	r24, 0x01	; 1
    1790:	a1 1d       	adc	r26, r1
    1792:	b1 1d       	adc	r27, r1
    1794:	80 93 75 50 	sts	0x5075, r24
    1798:	90 93 76 50 	sts	0x5076, r25
    179c:	a0 93 77 50 	sts	0x5077, r26
    17a0:	b0 93 78 50 	sts	0x5078, r27
	//after 128 samples, store the data into sd card and reset sample buffer
	//after 30 samples, send the data over the radio
	if (sampleCount >= 30) { 
    17a4:	80 91 75 50 	lds	r24, 0x5075
    17a8:	90 91 76 50 	lds	r25, 0x5076
    17ac:	a0 91 77 50 	lds	r26, 0x5077
    17b0:	b0 91 78 50 	lds	r27, 0x5078
    17b4:	8e 31       	cpi	r24, 0x1E	; 30
    17b6:	91 05       	cpc	r25, r1
    17b8:	a1 05       	cpc	r26, r1
    17ba:	b1 05       	cpc	r27, r1
    17bc:	08 f4       	brcc	.+2      	; 0x17c0 <__vector_105+0x31e>
    17be:	53 c0       	rjmp	.+166    	; 0x1866 <__vector_105+0x3c4>
		/*
		SD_write_block(10,FRAMReadBuffer,512);
		for (int i=0;i<512;i++) FRAMReadBuffer[i] = 0;
		SD_read_block(10,FRAMReadBuffer);
		*/
		sampleCount=0;
    17c0:	10 92 75 50 	sts	0x5075, r1
    17c4:	10 92 76 50 	sts	0x5076, r1
    17c8:	10 92 77 50 	sts	0x5077, r1
    17cc:	10 92 78 50 	sts	0x5078, r1
		TotalSampleCount++;
    17d0:	80 91 a5 50 	lds	r24, 0x50A5
    17d4:	90 91 a6 50 	lds	r25, 0x50A6
    17d8:	01 96       	adiw	r24, 0x01	; 1
    17da:	80 93 a5 50 	sts	0x50A5, r24
    17de:	90 93 a6 50 	sts	0x50A6, r25
		discardCount = ADC_DISCARD -1; //discard the next sample after pausing the sampling to send/store data since the sample ready flag will be outdated and the value might be bad
    17e2:	8f e7       	ldi	r24, 0x7F	; 127
    17e4:	80 93 5e 40 	sts	0x405E, r24
		//PORTF.OUTSET = PIN1_bm; //re-enable ADC for further sampling
		
		//write code to send the data over radio instead. Include some identifying info (like mote number) with the data.
		memmove(FRAMReadBuffer+2,FRAMReadBuffer,sampleCount*4); //move the data in the FRAM buffer up by 1 byte to make room for metadata
    17e8:	80 91 75 50 	lds	r24, 0x5075
    17ec:	90 91 76 50 	lds	r25, 0x5076
    17f0:	a0 91 77 50 	lds	r26, 0x5077
    17f4:	b0 91 78 50 	lds	r27, 0x5078
    17f8:	9c 01       	movw	r18, r24
    17fa:	22 0f       	add	r18, r18
    17fc:	33 1f       	adc	r19, r19
    17fe:	22 0f       	add	r18, r18
    1800:	33 1f       	adc	r19, r19
    1802:	8a ed       	ldi	r24, 0xDA	; 218
    1804:	93 e2       	ldi	r25, 0x23	; 35
    1806:	48 ed       	ldi	r20, 0xD8	; 216
    1808:	53 e2       	ldi	r21, 0x23	; 35
    180a:	ba 01       	movw	r22, r20
    180c:	a9 01       	movw	r20, r18
    180e:	0e 94 4e 5c 	call	0xb89c	; 0xb89c <memcpy>
		FRAMReadBuffer[0] = moteID;		//send moteID of the mote that gathered the data
    1812:	80 91 d1 50 	lds	r24, 0x50D1
    1816:	80 93 d8 23 	sts	0x23D8, r24
		FRAMReadBuffer[1] = (uint8_t)sampleCount;	//send the number of data samples gathered cast as a byte since no more than 30/31 samples should be send at a time
    181a:	80 91 75 50 	lds	r24, 0x5075
    181e:	90 91 76 50 	lds	r25, 0x5076
    1822:	a0 91 77 50 	lds	r26, 0x5077
    1826:	b0 91 78 50 	lds	r27, 0x5078
    182a:	80 93 d9 23 	sts	0x23D9, r24
		chb_write(0x0000,FRAMReadBuffer,sampleCount*4+2);	//send the samples and the metadata (for now just 1 byte containing moteID) to the base station
    182e:	80 91 75 50 	lds	r24, 0x5075
    1832:	90 91 76 50 	lds	r25, 0x5076
    1836:	a0 91 77 50 	lds	r26, 0x5077
    183a:	b0 91 78 50 	lds	r27, 0x5078
    183e:	88 0f       	add	r24, r24
    1840:	99 1f       	adc	r25, r25
    1842:	aa 1f       	adc	r26, r26
    1844:	bb 1f       	adc	r27, r27
    1846:	88 0f       	add	r24, r24
    1848:	99 1f       	adc	r25, r25
    184a:	aa 1f       	adc	r26, r26
    184c:	bb 1f       	adc	r27, r27
    184e:	9c 01       	movw	r18, r24
    1850:	ad 01       	movw	r20, r26
    1852:	2e 5f       	subi	r18, 0xFE	; 254
    1854:	3f 4f       	sbci	r19, 0xFF	; 255
    1856:	4f 4f       	sbci	r20, 0xFF	; 255
    1858:	5f 4f       	sbci	r21, 0xFF	; 255
    185a:	68 ed       	ldi	r22, 0xD8	; 216
    185c:	73 e2       	ldi	r23, 0x23	; 35
    185e:	80 e0       	ldi	r24, 0x00	; 0
    1860:	90 e0       	ldi	r25, 0x00	; 0
    1862:	0e 94 57 1e 	call	0x3cae	; 0x3cae <chb_write>
	}	
	}	
}
    1866:	23 96       	adiw	r28, 0x03	; 3
    1868:	cd bf       	out	0x3d, r28	; 61
    186a:	de bf       	out	0x3e, r29	; 62
    186c:	df 91       	pop	r29
    186e:	cf 91       	pop	r28
    1870:	ff 91       	pop	r31
    1872:	ef 91       	pop	r30
    1874:	bf 91       	pop	r27
    1876:	af 91       	pop	r26
    1878:	9f 91       	pop	r25
    187a:	8f 91       	pop	r24
    187c:	7f 91       	pop	r23
    187e:	6f 91       	pop	r22
    1880:	5f 91       	pop	r21
    1882:	4f 91       	pop	r20
    1884:	3f 91       	pop	r19
    1886:	2f 91       	pop	r18
    1888:	1f 91       	pop	r17
    188a:	0f 91       	pop	r16
    188c:	ff 90       	pop	r15
    188e:	ef 90       	pop	r14
    1890:	df 90       	pop	r13
    1892:	cf 90       	pop	r12
    1894:	bf 90       	pop	r11
    1896:	af 90       	pop	r10
    1898:	9f 90       	pop	r9
    189a:	8f 90       	pop	r8
    189c:	7f 90       	pop	r7
    189e:	6f 90       	pop	r6
    18a0:	5f 90       	pop	r5
    18a2:	4f 90       	pop	r4
    18a4:	3f 90       	pop	r3
    18a6:	2f 90       	pop	r2
    18a8:	0f 90       	pop	r0
    18aa:	00 92 3b 00 	sts	0x003B, r0
    18ae:	0f 90       	pop	r0
    18b0:	0f be       	out	0x3f, r0	; 63
    18b2:	0f 90       	pop	r0
    18b4:	1f 90       	pop	r1
    18b6:	18 95       	reti

000018b8 <__vector_104>:

//ISR used by CO_collectADC function
ISR(PORTF_INT0_vect) {
    18b8:	1f 92       	push	r1
    18ba:	0f 92       	push	r0
    18bc:	0f b6       	in	r0, 0x3f	; 63
    18be:	0f 92       	push	r0
    18c0:	00 90 3b 00 	lds	r0, 0x003B
    18c4:	0f 92       	push	r0
    18c6:	11 24       	eor	r1, r1
    18c8:	2f 92       	push	r2
    18ca:	3f 92       	push	r3
    18cc:	4f 92       	push	r4
    18ce:	5f 92       	push	r5
    18d0:	6f 92       	push	r6
    18d2:	7f 92       	push	r7
    18d4:	8f 92       	push	r8
    18d6:	9f 92       	push	r9
    18d8:	af 92       	push	r10
    18da:	bf 92       	push	r11
    18dc:	cf 92       	push	r12
    18de:	df 92       	push	r13
    18e0:	ef 92       	push	r14
    18e2:	ff 92       	push	r15
    18e4:	0f 93       	push	r16
    18e6:	1f 93       	push	r17
    18e8:	2f 93       	push	r18
    18ea:	3f 93       	push	r19
    18ec:	4f 93       	push	r20
    18ee:	5f 93       	push	r21
    18f0:	6f 93       	push	r22
    18f2:	7f 93       	push	r23
    18f4:	8f 93       	push	r24
    18f6:	9f 93       	push	r25
    18f8:	af 93       	push	r26
    18fa:	bf 93       	push	r27
    18fc:	ef 93       	push	r30
    18fe:	ff 93       	push	r31
    1900:	cf 93       	push	r28
    1902:	df 93       	push	r29
    1904:	cd b7       	in	r28, 0x3d	; 61
    1906:	de b7       	in	r29, 0x3e	; 62
    1908:	27 97       	sbiw	r28, 0x07	; 7
    190a:	cd bf       	out	0x3d, r28	; 61
    190c:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	volatile int32_t currentSample;
	if (discardCount < ADC_DISCARD) {
    190e:	80 91 5e 40 	lds	r24, 0x405E
    1912:	88 23       	and	r24, r24
    1914:	34 f0       	brlt	.+12     	; 0x1922 <__vector_104+0x6a>
		discardCount++;
    1916:	80 91 5e 40 	lds	r24, 0x405E
    191a:	8f 5f       	subi	r24, 0xFF	; 255
    191c:	80 93 5e 40 	sts	0x405E, r24
    1920:	4a c1       	rjmp	.+660    	; 0x1bb6 <__vector_104+0x2fe>
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
    1922:	81 e0       	ldi	r24, 0x01	; 1
    1924:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    1928:	80 ea       	ldi	r24, 0xA0	; 160
    192a:	96 e0       	ldi	r25, 0x06	; 6
    192c:	22 e0       	ldi	r18, 0x02	; 2
    192e:	fc 01       	movw	r30, r24
    1930:	26 83       	std	Z+6, r18	; 0x06
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1932:	19 82       	std	Y+1, r1	; 0x01
    1934:	1a c0       	rjmp	.+52     	; 0x196a <__vector_104+0xb2>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
    1936:	80 ec       	ldi	r24, 0xC0	; 192
    1938:	98 e0       	ldi	r25, 0x08	; 8
    193a:	2a ea       	ldi	r18, 0xAA	; 170
    193c:	fc 01       	movw	r30, r24
    193e:	23 83       	std	Z+3, r18	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
    1940:	00 00       	nop
    1942:	80 ec       	ldi	r24, 0xC0	; 192
    1944:	98 e0       	ldi	r25, 0x08	; 8
    1946:	fc 01       	movw	r30, r24
    1948:	82 81       	ldd	r24, Z+2	; 0x02
    194a:	88 23       	and	r24, r24
    194c:	d4 f7       	brge	.-12     	; 0x1942 <__vector_104+0x8a>
			SPIBuffer[bufIndex] = SPIC.DATA;
    194e:	89 81       	ldd	r24, Y+1	; 0x01
    1950:	88 2f       	mov	r24, r24
    1952:	90 e0       	ldi	r25, 0x00	; 0
    1954:	20 ec       	ldi	r18, 0xC0	; 192
    1956:	38 e0       	ldi	r19, 0x08	; 8
    1958:	f9 01       	movw	r30, r18
    195a:	23 81       	ldd	r18, Z+3	; 0x03
    195c:	8a 59       	subi	r24, 0x9A	; 154
    195e:	9f 4a       	sbci	r25, 0xAF	; 175
    1960:	fc 01       	movw	r30, r24
    1962:	20 83       	st	Z, r18
		discardCount++;
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    1964:	89 81       	ldd	r24, Y+1	; 0x01
    1966:	8f 5f       	subi	r24, 0xFF	; 255
    1968:	89 83       	std	Y+1, r24	; 0x01
    196a:	89 81       	ldd	r24, Y+1	; 0x01
    196c:	83 30       	cpi	r24, 0x03	; 3
    196e:	18 f3       	brcs	.-58     	; 0x1936 <__vector_104+0x7e>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    1970:	80 ea       	ldi	r24, 0xA0	; 160
    1972:	96 e0       	ldi	r25, 0x06	; 6
    1974:	22 e0       	ldi	r18, 0x02	; 2
    1976:	fc 01       	movw	r30, r24
    1978:	25 83       	std	Z+5, r18	; 0x05
		SPICS(FALSE);
    197a:	80 e0       	ldi	r24, 0x00	; 0
    197c:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    1980:	80 91 66 50 	lds	r24, 0x5066
    1984:	88 23       	and	r24, r24
    1986:	3c f4       	brge	.+14     	; 0x1996 <__vector_104+0xde>
    1988:	ce 01       	movw	r24, r28
    198a:	02 96       	adiw	r24, 0x02	; 2
    198c:	03 96       	adiw	r24, 0x03	; 3
    198e:	2f ef       	ldi	r18, 0xFF	; 255
    1990:	fc 01       	movw	r30, r24
    1992:	20 83       	st	Z, r18
    1994:	05 c0       	rjmp	.+10     	; 0x19a0 <__vector_104+0xe8>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    1996:	ce 01       	movw	r24, r28
    1998:	02 96       	adiw	r24, 0x02	; 2
    199a:	03 96       	adiw	r24, 0x03	; 3
    199c:	fc 01       	movw	r30, r24
    199e:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[0];
    19a0:	ce 01       	movw	r24, r28
    19a2:	02 96       	adiw	r24, 0x02	; 2
    19a4:	02 96       	adiw	r24, 0x02	; 2
    19a6:	20 91 66 50 	lds	r18, 0x5066
    19aa:	fc 01       	movw	r30, r24
    19ac:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[1];
    19ae:	ce 01       	movw	r24, r28
    19b0:	02 96       	adiw	r24, 0x02	; 2
    19b2:	01 96       	adiw	r24, 0x01	; 1
    19b4:	20 91 67 50 	lds	r18, 0x5067
    19b8:	fc 01       	movw	r30, r24
    19ba:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[2];
    19bc:	ce 01       	movw	r24, r28
    19be:	02 96       	adiw	r24, 0x02	; 2
    19c0:	20 91 68 50 	lds	r18, 0x5068
    19c4:	fc 01       	movw	r30, r24
    19c6:	20 83       	st	Z, r18
		
		//ADC_BUFFER[sampleCount] = (int32_t) -((uint64_t)currentSample * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
		var = currentSample;
    19c8:	8a 81       	ldd	r24, Y+2	; 0x02
    19ca:	9b 81       	ldd	r25, Y+3	; 0x03
    19cc:	ac 81       	ldd	r26, Y+4	; 0x04
    19ce:	bd 81       	ldd	r27, Y+5	; 0x05
    19d0:	5c 01       	movw	r10, r24
    19d2:	6d 01       	movw	r12, r26
    19d4:	bb 0f       	add	r27, r27
    19d6:	88 0b       	sbc	r24, r24
    19d8:	98 2f       	mov	r25, r24
    19da:	dc 01       	movw	r26, r24
    19dc:	e8 2e       	mov	r14, r24
    19de:	f8 2e       	mov	r15, r24
    19e0:	08 2f       	mov	r16, r24
    19e2:	18 2f       	mov	r17, r24
    19e4:	a0 92 a7 50 	sts	0x50A7, r10
    19e8:	b0 92 a8 50 	sts	0x50A8, r11
    19ec:	c0 92 a9 50 	sts	0x50A9, r12
    19f0:	d0 92 aa 50 	sts	0x50AA, r13
    19f4:	e0 92 ab 50 	sts	0x50AB, r14
    19f8:	f0 92 ac 50 	sts	0x50AC, r15
    19fc:	00 93 ad 50 	sts	0x50AD, r16
    1a00:	10 93 ae 50 	sts	0x50AE, r17
		ADC_BUFFER[sampleCount] = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    1a04:	20 91 73 50 	lds	r18, 0x5073
    1a08:	30 91 74 50 	lds	r19, 0x5074
    1a0c:	80 91 75 50 	lds	r24, 0x5075
    1a10:	90 91 76 50 	lds	r25, 0x5076
    1a14:	a0 91 77 50 	lds	r26, 0x5077
    1a18:	b0 91 78 50 	lds	r27, 0x5078
    1a1c:	88 0f       	add	r24, r24
    1a1e:	99 1f       	adc	r25, r25
    1a20:	88 0f       	add	r24, r24
    1a22:	99 1f       	adc	r25, r25
    1a24:	a9 01       	movw	r20, r18
    1a26:	48 0f       	add	r20, r24
    1a28:	59 1f       	adc	r21, r25
    1a2a:	4e 83       	std	Y+6, r20	; 0x06
    1a2c:	5f 83       	std	Y+7, r21	; 0x07
    1a2e:	a0 90 a7 50 	lds	r10, 0x50A7
    1a32:	b0 90 a8 50 	lds	r11, 0x50A8
    1a36:	c0 90 a9 50 	lds	r12, 0x50A9
    1a3a:	d0 90 aa 50 	lds	r13, 0x50AA
    1a3e:	e0 90 ab 50 	lds	r14, 0x50AB
    1a42:	f0 90 ac 50 	lds	r15, 0x50AC
    1a46:	00 91 ad 50 	lds	r16, 0x50AD
    1a4a:	10 91 ae 50 	lds	r17, 0x50AE
    1a4e:	2a 2d       	mov	r18, r10
    1a50:	3b 2d       	mov	r19, r11
    1a52:	4c 2d       	mov	r20, r12
    1a54:	5d 2d       	mov	r21, r13
    1a56:	6e 2d       	mov	r22, r14
    1a58:	7f 2d       	mov	r23, r15
    1a5a:	80 2f       	mov	r24, r16
    1a5c:	91 2f       	mov	r25, r17
    1a5e:	0f 2e       	mov	r0, r31
    1a60:	f0 ea       	ldi	r31, 0xA0	; 160
    1a62:	af 2e       	mov	r10, r31
    1a64:	f0 2d       	mov	r31, r0
    1a66:	0f 2e       	mov	r0, r31
    1a68:	f5 e2       	ldi	r31, 0x25	; 37
    1a6a:	bf 2e       	mov	r11, r31
    1a6c:	f0 2d       	mov	r31, r0
    1a6e:	0f 2e       	mov	r0, r31
    1a70:	f6 e2       	ldi	r31, 0x26	; 38
    1a72:	cf 2e       	mov	r12, r31
    1a74:	f0 2d       	mov	r31, r0
    1a76:	dd 24       	eor	r13, r13
    1a78:	ee 24       	eor	r14, r14
    1a7a:	ff 24       	eor	r15, r15
    1a7c:	00 e0       	ldi	r16, 0x00	; 0
    1a7e:	10 e0       	ldi	r17, 0x00	; 0
    1a80:	0e 94 1c 51 	call	0xa238	; 0xa238 <__muldi3>
    1a84:	22 2e       	mov	r2, r18
    1a86:	33 2e       	mov	r3, r19
    1a88:	44 2e       	mov	r4, r20
    1a8a:	55 2e       	mov	r5, r21
    1a8c:	66 2e       	mov	r6, r22
    1a8e:	77 2e       	mov	r7, r23
    1a90:	88 2e       	mov	r8, r24
    1a92:	99 2e       	mov	r9, r25
    1a94:	a2 2c       	mov	r10, r2
    1a96:	b3 2c       	mov	r11, r3
    1a98:	c4 2c       	mov	r12, r4
    1a9a:	d5 2c       	mov	r13, r5
    1a9c:	e6 2c       	mov	r14, r6
    1a9e:	f7 2c       	mov	r15, r7
    1aa0:	08 2d       	mov	r16, r8
    1aa2:	19 2d       	mov	r17, r9
    1aa4:	2a 2d       	mov	r18, r10
    1aa6:	3b 2d       	mov	r19, r11
    1aa8:	4c 2d       	mov	r20, r12
    1aaa:	5d 2d       	mov	r21, r13
    1aac:	6e 2d       	mov	r22, r14
    1aae:	7f 2d       	mov	r23, r15
    1ab0:	80 2f       	mov	r24, r16
    1ab2:	91 2f       	mov	r25, r17
    1ab4:	aa 24       	eor	r10, r10
    1ab6:	aa 94       	dec	r10
    1ab8:	bb 24       	eor	r11, r11
    1aba:	ba 94       	dec	r11
    1abc:	0f 2e       	mov	r0, r31
    1abe:	ff e7       	ldi	r31, 0x7F	; 127
    1ac0:	cf 2e       	mov	r12, r31
    1ac2:	f0 2d       	mov	r31, r0
    1ac4:	dd 24       	eor	r13, r13
    1ac6:	ee 24       	eor	r14, r14
    1ac8:	ff 24       	eor	r15, r15
    1aca:	00 e0       	ldi	r16, 0x00	; 0
    1acc:	10 e0       	ldi	r17, 0x00	; 0
    1ace:	0e 94 63 52 	call	0xa4c6	; 0xa4c6 <__divdi3>
    1ad2:	22 2e       	mov	r2, r18
    1ad4:	33 2e       	mov	r3, r19
    1ad6:	44 2e       	mov	r4, r20
    1ad8:	55 2e       	mov	r5, r21
    1ada:	66 2e       	mov	r6, r22
    1adc:	77 2e       	mov	r7, r23
    1ade:	88 2e       	mov	r8, r24
    1ae0:	99 2e       	mov	r9, r25
    1ae2:	a2 2c       	mov	r10, r2
    1ae4:	b3 2c       	mov	r11, r3
    1ae6:	c4 2c       	mov	r12, r4
    1ae8:	d5 2c       	mov	r13, r5
    1aea:	e6 2c       	mov	r14, r6
    1aec:	f7 2c       	mov	r15, r7
    1aee:	08 2d       	mov	r16, r8
    1af0:	19 2d       	mov	r17, r9
    1af2:	2a 2d       	mov	r18, r10
    1af4:	3b 2d       	mov	r19, r11
    1af6:	4c 2d       	mov	r20, r12
    1af8:	5d 2d       	mov	r21, r13
    1afa:	6e 2d       	mov	r22, r14
    1afc:	7f 2d       	mov	r23, r15
    1afe:	80 2f       	mov	r24, r16
    1b00:	91 2f       	mov	r25, r17
    1b02:	01 e0       	ldi	r16, 0x01	; 1
    1b04:	0e 94 ef 51 	call	0xa3de	; 0xa3de <__ashldi3>
    1b08:	22 2e       	mov	r2, r18
    1b0a:	33 2e       	mov	r3, r19
    1b0c:	44 2e       	mov	r4, r20
    1b0e:	55 2e       	mov	r5, r21
    1b10:	66 2e       	mov	r6, r22
    1b12:	77 2e       	mov	r7, r23
    1b14:	88 2e       	mov	r8, r24
    1b16:	99 2e       	mov	r9, r25
    1b18:	a2 2c       	mov	r10, r2
    1b1a:	b3 2c       	mov	r11, r3
    1b1c:	c4 2c       	mov	r12, r4
    1b1e:	d5 2c       	mov	r13, r5
    1b20:	e6 2c       	mov	r14, r6
    1b22:	f7 2c       	mov	r15, r7
    1b24:	08 2d       	mov	r16, r8
    1b26:	19 2d       	mov	r17, r9
    1b28:	2a 2d       	mov	r18, r10
    1b2a:	3b 2d       	mov	r19, r11
    1b2c:	4c 2d       	mov	r20, r12
    1b2e:	5d 2d       	mov	r21, r13
    1b30:	6e 2d       	mov	r22, r14
    1b32:	7f 2d       	mov	r23, r15
    1b34:	80 2f       	mov	r24, r16
    1b36:	91 2f       	mov	r25, r17
    1b38:	0f 2e       	mov	r0, r31
    1b3a:	f3 e0       	ldi	r31, 0x03	; 3
    1b3c:	af 2e       	mov	r10, r31
    1b3e:	f0 2d       	mov	r31, r0
    1b40:	bb 24       	eor	r11, r11
    1b42:	cc 24       	eor	r12, r12
    1b44:	dd 24       	eor	r13, r13
    1b46:	ee 24       	eor	r14, r14
    1b48:	ff 24       	eor	r15, r15
    1b4a:	00 e0       	ldi	r16, 0x00	; 0
    1b4c:	10 e0       	ldi	r17, 0x00	; 0
    1b4e:	0e 94 63 52 	call	0xa4c6	; 0xa4c6 <__divdi3>
    1b52:	a2 2e       	mov	r10, r18
    1b54:	b3 2e       	mov	r11, r19
    1b56:	c4 2e       	mov	r12, r20
    1b58:	d5 2e       	mov	r13, r21
    1b5a:	e6 2e       	mov	r14, r22
    1b5c:	f7 2e       	mov	r15, r23
    1b5e:	08 2f       	mov	r16, r24
    1b60:	19 2f       	mov	r17, r25
    1b62:	2a 2d       	mov	r18, r10
    1b64:	3b 2d       	mov	r19, r11
    1b66:	4c 2d       	mov	r20, r12
    1b68:	5d 2d       	mov	r21, r13
    1b6a:	6e 2d       	mov	r22, r14
    1b6c:	7f 2d       	mov	r23, r15
    1b6e:	80 2f       	mov	r24, r16
    1b70:	91 2f       	mov	r25, r17
    1b72:	da 01       	movw	r26, r20
    1b74:	c9 01       	movw	r24, r18
    1b76:	b0 95       	com	r27
    1b78:	a0 95       	com	r26
    1b7a:	90 95       	com	r25
    1b7c:	81 95       	neg	r24
    1b7e:	9f 4f       	sbci	r25, 0xFF	; 255
    1b80:	af 4f       	sbci	r26, 0xFF	; 255
    1b82:	bf 4f       	sbci	r27, 0xFF	; 255
    1b84:	ee 81       	ldd	r30, Y+6	; 0x06
    1b86:	ff 81       	ldd	r31, Y+7	; 0x07
    1b88:	80 83       	st	Z, r24
    1b8a:	91 83       	std	Z+1, r25	; 0x01
    1b8c:	a2 83       	std	Z+2, r26	; 0x02
    1b8e:	b3 83       	std	Z+3, r27	; 0x03
		sampleCount++;
    1b90:	80 91 75 50 	lds	r24, 0x5075
    1b94:	90 91 76 50 	lds	r25, 0x5076
    1b98:	a0 91 77 50 	lds	r26, 0x5077
    1b9c:	b0 91 78 50 	lds	r27, 0x5078
    1ba0:	01 96       	adiw	r24, 0x01	; 1
    1ba2:	a1 1d       	adc	r26, r1
    1ba4:	b1 1d       	adc	r27, r1
    1ba6:	80 93 75 50 	sts	0x5075, r24
    1baa:	90 93 76 50 	sts	0x5076, r25
    1bae:	a0 93 77 50 	sts	0x5077, r26
    1bb2:	b0 93 78 50 	sts	0x5078, r27
	}
}
    1bb6:	27 96       	adiw	r28, 0x07	; 7
    1bb8:	cd bf       	out	0x3d, r28	; 61
    1bba:	de bf       	out	0x3e, r29	; 62
    1bbc:	df 91       	pop	r29
    1bbe:	cf 91       	pop	r28
    1bc0:	ff 91       	pop	r31
    1bc2:	ef 91       	pop	r30
    1bc4:	bf 91       	pop	r27
    1bc6:	af 91       	pop	r26
    1bc8:	9f 91       	pop	r25
    1bca:	8f 91       	pop	r24
    1bcc:	7f 91       	pop	r23
    1bce:	6f 91       	pop	r22
    1bd0:	5f 91       	pop	r21
    1bd2:	4f 91       	pop	r20
    1bd4:	3f 91       	pop	r19
    1bd6:	2f 91       	pop	r18
    1bd8:	1f 91       	pop	r17
    1bda:	0f 91       	pop	r16
    1bdc:	ff 90       	pop	r15
    1bde:	ef 90       	pop	r14
    1be0:	df 90       	pop	r13
    1be2:	cf 90       	pop	r12
    1be4:	bf 90       	pop	r11
    1be6:	af 90       	pop	r10
    1be8:	9f 90       	pop	r9
    1bea:	8f 90       	pop	r8
    1bec:	7f 90       	pop	r7
    1bee:	6f 90       	pop	r6
    1bf0:	5f 90       	pop	r5
    1bf2:	4f 90       	pop	r4
    1bf4:	3f 90       	pop	r3
    1bf6:	2f 90       	pop	r2
    1bf8:	0f 90       	pop	r0
    1bfa:	00 92 3b 00 	sts	0x003B, r0
    1bfe:	0f 90       	pop	r0
    1c00:	0f be       	out	0x3f, r0	; 63
    1c02:	0f 90       	pop	r0
    1c04:	1f 90       	pop	r1
    1c06:	18 95       	reti

00001c08 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
    1c08:	cf 93       	push	r28
    1c0a:	df 93       	push	r29
    1c0c:	0f 92       	push	r0
    1c0e:	cd b7       	in	r28, 0x3d	; 61
    1c10:	de b7       	in	r29, 0x3e	; 62
    1c12:	89 83       	std	Y+1, r24	; 0x01
	if (enable) {
    1c14:	89 81       	ldd	r24, Y+1	; 0x01
    1c16:	88 23       	and	r24, r24
    1c18:	49 f0       	breq	.+18     	; 0x1c2c <ACC_DCPassEnable+0x24>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
    1c1a:	80 e2       	ldi	r24, 0x20	; 32
    1c1c:	60 e0       	ldi	r22, 0x00	; 0
    1c1e:	0e 94 77 32 	call	0x64ee	; 0x64ee <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
    1c22:	80 e2       	ldi	r24, 0x20	; 32
    1c24:	60 e0       	ldi	r22, 0x00	; 0
    1c26:	0e 94 43 33 	call	0x6686	; 0x6686 <PortEx_OUTSET>
    1c2a:	04 c0       	rjmp	.+8      	; 0x1c34 <ACC_DCPassEnable+0x2c>
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
    1c2c:	80 e2       	ldi	r24, 0x20	; 32
    1c2e:	60 e0       	ldi	r22, 0x00	; 0
    1c30:	0e 94 db 32 	call	0x65b6	; 0x65b6 <PortEx_DIRCLR>
		//setPortEx(0x00, PS_BANKB);
	}
}
    1c34:	0f 90       	pop	r0
    1c36:	df 91       	pop	r29
    1c38:	cf 91       	pop	r28
    1c3a:	08 95       	ret

00001c3c <CO_collectSeismic3Axises>:
	
}*/

void CO_collectSeismic3Axises(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD, uint32_t numOfSamples, uint32_t* DataArray) {
    1c3c:	8f 92       	push	r8
    1c3e:	9f 92       	push	r9
    1c40:	af 92       	push	r10
    1c42:	bf 92       	push	r11
    1c44:	cf 92       	push	r12
    1c46:	df 92       	push	r13
    1c48:	ef 92       	push	r14
    1c4a:	ff 92       	push	r15
    1c4c:	0f 93       	push	r16
    1c4e:	cf 93       	push	r28
    1c50:	df 93       	push	r29
    1c52:	cd b7       	in	r28, 0x3d	; 61
    1c54:	de b7       	in	r29, 0x3e	; 62
    1c56:	2e 97       	sbiw	r28, 0x0e	; 14
    1c58:	cd bf       	out	0x3d, r28	; 61
    1c5a:	de bf       	out	0x3e, r29	; 62
    1c5c:	89 83       	std	Y+1, r24	; 0x01
    1c5e:	6a 83       	std	Y+2, r22	; 0x02
    1c60:	7b 83       	std	Y+3, r23	; 0x03
    1c62:	4c 83       	std	Y+4, r20	; 0x04
    1c64:	2d 83       	std	Y+5, r18	; 0x05
    1c66:	0e 83       	std	Y+6, r16	; 0x06
    1c68:	ef 82       	std	Y+7, r14	; 0x07
    1c6a:	f8 86       	std	Y+8, r15	; 0x08
    1c6c:	c9 86       	std	Y+9, r12	; 0x09
    1c6e:	da 86       	std	Y+10, r13	; 0x0a
    1c70:	ab 86       	std	Y+11, r10	; 0x0b
    1c72:	bc 86       	std	Y+12, r11	; 0x0c
    1c74:	8d 86       	std	Y+13, r8	; 0x0d
    1c76:	9e 86       	std	Y+14, r9	; 0x0e
	
	ADC_BUFFER = DataArray;
    1c78:	89 a1       	lds	r24, 0x49
    1c7a:	9a a1       	lds	r25, 0x4a
    1c7c:	80 93 73 50 	sts	0x5073, r24
    1c80:	90 93 74 50 	sts	0x5074, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1c84:	81 e0       	ldi	r24, 0x01	; 1
    1c86:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    1c8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c8c:	9b 81       	ldd	r25, Y+3	; 0x03
    1c8e:	fc 01       	movw	r30, r24
    1c90:	90 81       	ld	r25, Z
    1c92:	85 e0       	ldi	r24, 0x05	; 5
    1c94:	69 2f       	mov	r22, r25
    1c96:	0e 94 f7 06 	call	0xdee	; 0xdee <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    1c9a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c9c:	9b 81       	ldd	r25, Y+3	; 0x03
    1c9e:	01 96       	adiw	r24, 0x01	; 1
    1ca0:	fc 01       	movw	r30, r24
    1ca2:	90 81       	ld	r25, Z
    1ca4:	86 e0       	ldi	r24, 0x06	; 6
    1ca6:	69 2f       	mov	r22, r25
    1ca8:	0e 94 f7 06 	call	0xdee	; 0xdee <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    1cac:	8a 81       	ldd	r24, Y+2	; 0x02
    1cae:	9b 81       	ldd	r25, Y+3	; 0x03
    1cb0:	02 96       	adiw	r24, 0x02	; 2
    1cb2:	fc 01       	movw	r30, r24
    1cb4:	90 81       	ld	r25, Z
    1cb6:	87 e0       	ldi	r24, 0x07	; 7
    1cb8:	69 2f       	mov	r22, r25
    1cba:	0e 94 f7 06 	call	0xdee	; 0xdee <set_ampGain>
	set_filter(filterConfig);
    1cbe:	89 81       	ldd	r24, Y+1	; 0x01
    1cc0:	0e 94 26 08 	call	0x104c	; 0x104c <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    1cc4:	8e 81       	ldd	r24, Y+6	; 0x06
    1cc6:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    1cca:	84 e0       	ldi	r24, 0x04	; 4
    1ccc:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1cd0:	80 ec       	ldi	r24, 0xC0	; 192
    1cd2:	98 e0       	ldi	r25, 0x08	; 8
    1cd4:	24 e5       	ldi	r18, 0x54	; 84
    1cd6:	fc 01       	movw	r30, r24
    1cd8:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    1cda:	81 e0       	ldi	r24, 0x01	; 1
    1cdc:	0e 94 a6 08 	call	0x114c	; 0x114c <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    1ce0:	85 e0       	ldi	r24, 0x05	; 5
    1ce2:	0e 94 ad 19 	call	0x335a	; 0x335a <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    1ce6:	80 ea       	ldi	r24, 0xA0	; 160
    1ce8:	96 e0       	ldi	r25, 0x06	; 6
    1cea:	22 e0       	ldi	r18, 0x02	; 2
    1cec:	fc 01       	movw	r30, r24
    1cee:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    1cf0:	80 ea       	ldi	r24, 0xA0	; 160
    1cf2:	96 e0       	ldi	r25, 0x06	; 6
    1cf4:	21 e0       	ldi	r18, 0x01	; 1
    1cf6:	fc 01       	movw	r30, r24
    1cf8:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    1cfa:	80 e8       	ldi	r24, 0x80	; 128
    1cfc:	91 e0       	ldi	r25, 0x01	; 1
    1cfe:	28 e7       	ldi	r18, 0x78	; 120
    1d00:	fc 01       	movw	r30, r24
    1d02:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    1d04:	80 e0       	ldi	r24, 0x00	; 0
    1d06:	98 e0       	ldi	r25, 0x08	; 8
    1d08:	20 ef       	ldi	r18, 0xF0	; 240
    1d0a:	fc 01       	movw	r30, r24
    1d0c:	21 83       	std	Z+1, r18	; 0x01
	TCC0.CCA = averagingPtA;
    1d0e:	80 e0       	ldi	r24, 0x00	; 0
    1d10:	98 e0       	ldi	r25, 0x08	; 8
    1d12:	2f 81       	ldd	r18, Y+7	; 0x07
    1d14:	38 85       	ldd	r19, Y+8	; 0x08
    1d16:	fc 01       	movw	r30, r24
    1d18:	20 a7       	lds	r18, 0x70
    1d1a:	31 a7       	lds	r19, 0x71
	TCC0.CCB = averagingPtB;
    1d1c:	80 e0       	ldi	r24, 0x00	; 0
    1d1e:	98 e0       	ldi	r25, 0x08	; 8
    1d20:	29 85       	ldd	r18, Y+9	; 0x09
    1d22:	3a 85       	ldd	r19, Y+10	; 0x0a
    1d24:	fc 01       	movw	r30, r24
    1d26:	22 a7       	lds	r18, 0x72
    1d28:	33 a7       	lds	r19, 0x73
	TCC0.CCC = averagingPtC;
    1d2a:	80 e0       	ldi	r24, 0x00	; 0
    1d2c:	98 e0       	ldi	r25, 0x08	; 8
    1d2e:	2b 85       	ldd	r18, Y+11	; 0x0b
    1d30:	3c 85       	ldd	r19, Y+12	; 0x0c
    1d32:	fc 01       	movw	r30, r24
    1d34:	24 a7       	lds	r18, 0x74
    1d36:	35 a7       	lds	r19, 0x75
	TCC0.CCD = averagingPtD;
    1d38:	80 e0       	ldi	r24, 0x00	; 0
    1d3a:	98 e0       	ldi	r25, 0x08	; 8
    1d3c:	2d 85       	ldd	r18, Y+13	; 0x0d
    1d3e:	3e 85       	ldd	r19, Y+14	; 0x0e
    1d40:	fc 01       	movw	r30, r24
    1d42:	26 a7       	lds	r18, 0x76
    1d44:	37 a7       	lds	r19, 0x77
	TCC0.PER = subsamplesPerChannel - 1;
    1d46:	80 e0       	ldi	r24, 0x00	; 0
    1d48:	98 e0       	ldi	r25, 0x08	; 8
    1d4a:	2d 81       	ldd	r18, Y+5	; 0x05
    1d4c:	22 2f       	mov	r18, r18
    1d4e:	30 e0       	ldi	r19, 0x00	; 0
    1d50:	21 50       	subi	r18, 0x01	; 1
    1d52:	30 40       	sbci	r19, 0x00	; 0
    1d54:	fc 01       	movw	r30, r24
    1d56:	26 a3       	lds	r18, 0x56
    1d58:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    1d5a:	80 e0       	ldi	r24, 0x00	; 0
    1d5c:	98 e0       	ldi	r25, 0x08	; 8
    1d5e:	22 e0       	ldi	r18, 0x02	; 2
    1d60:	fc 01       	movw	r30, r24
    1d62:	26 83       	std	Z+6, r18	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    1d64:	80 e0       	ldi	r24, 0x00	; 0
    1d66:	98 e0       	ldi	r25, 0x08	; 8
    1d68:	2f ef       	ldi	r18, 0xFF	; 255
    1d6a:	fc 01       	movw	r30, r24
    1d6c:	27 83       	std	Z+7, r18	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    1d6e:	80 e0       	ldi	r24, 0x00	; 0
    1d70:	98 e0       	ldi	r25, 0x08	; 8
    1d72:	20 e0       	ldi	r18, 0x00	; 0
    1d74:	38 e0       	ldi	r19, 0x08	; 8
    1d76:	f9 01       	movw	r30, r18
    1d78:	20 81       	ld	r18, Z
    1d7a:	20 7f       	andi	r18, 0xF0	; 240
    1d7c:	28 60       	ori	r18, 0x08	; 8
    1d7e:	fc 01       	movw	r30, r24
    1d80:	20 83       	st	Z, r18

	FRAMAddress = FR_BASEADD;
    1d82:	10 92 50 40 	sts	0x4050, r1
    1d86:	10 92 51 40 	sts	0x4051, r1
	sampleCount = 0;
    1d8a:	10 92 75 50 	sts	0x5075, r1
    1d8e:	10 92 76 50 	sts	0x5076, r1
    1d92:	10 92 77 50 	sts	0x5077, r1
    1d96:	10 92 78 50 	sts	0x5078, r1
	SPICount = 0;
    1d9a:	10 92 cf 50 	sts	0x50CF, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    1d9e:	80 e0       	ldi	r24, 0x00	; 0
    1da0:	80 93 34 21 	sts	0x2134, r24
    1da4:	80 93 33 21 	sts	0x2133, r24
    1da8:	80 93 32 21 	sts	0x2132, r24

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    1dac:	80 ea       	ldi	r24, 0xA0	; 160
    1dae:	90 e0       	ldi	r25, 0x00	; 0
    1db0:	20 ea       	ldi	r18, 0xA0	; 160
    1db2:	30 e0       	ldi	r19, 0x00	; 0
    1db4:	f9 01       	movw	r30, r18
    1db6:	22 81       	ldd	r18, Z+2	; 0x02
    1db8:	26 60       	ori	r18, 0x06	; 6
    1dba:	fc 01       	movw	r30, r24
    1dbc:	22 83       	std	Z+2, r18	; 0x02
	sei();
    1dbe:	78 94       	sei

	SPICS(TRUE);
    1dc0:	81 e0       	ldi	r24, 0x01	; 1
    1dc2:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    1dc6:	80 e8       	ldi	r24, 0x80	; 128
    1dc8:	96 e0       	ldi	r25, 0x06	; 6
    1dca:	20 e2       	ldi	r18, 0x20	; 32
    1dcc:	fc 01       	movw	r30, r24
    1dce:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1dd0:	80 e4       	ldi	r24, 0x40	; 64
    1dd2:	9a e0       	ldi	r25, 0x0A	; 10
    1dd4:	23 e2       	ldi	r18, 0x23	; 35
    1dd6:	fc 01       	movw	r30, r24
    1dd8:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    1dda:	80 e4       	ldi	r24, 0x40	; 64
    1ddc:	9a e0       	ldi	r25, 0x0A	; 10
    1dde:	2c 81       	ldd	r18, Y+4	; 0x04
    1de0:	42 2f       	mov	r20, r18
    1de2:	50 e0       	ldi	r21, 0x00	; 0
    1de4:	20 e2       	ldi	r18, 0x20	; 32
    1de6:	30 e0       	ldi	r19, 0x00	; 0
    1de8:	02 c0       	rjmp	.+4      	; 0x1dee <CO_collectSeismic3Axises+0x1b2>
    1dea:	22 0f       	add	r18, r18
    1dec:	33 1f       	adc	r19, r19
    1dee:	4a 95       	dec	r20
    1df0:	e2 f7       	brpl	.-8      	; 0x1dea <CO_collectSeismic3Axises+0x1ae>
    1df2:	fc 01       	movw	r30, r24
    1df4:	26 a3       	lds	r18, 0x56
    1df6:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    1df8:	80 e4       	ldi	r24, 0x40	; 64
    1dfa:	9a e0       	ldi	r25, 0x0A	; 10
    1dfc:	2c 81       	ldd	r18, Y+4	; 0x04
    1dfe:	42 2f       	mov	r20, r18
    1e00:	50 e0       	ldi	r21, 0x00	; 0
    1e02:	20 e1       	ldi	r18, 0x10	; 16
    1e04:	30 e0       	ldi	r19, 0x00	; 0
    1e06:	02 c0       	rjmp	.+4      	; 0x1e0c <CO_collectSeismic3Axises+0x1d0>
    1e08:	22 0f       	add	r18, r18
    1e0a:	33 1f       	adc	r19, r19
    1e0c:	4a 95       	dec	r20
    1e0e:	e2 f7       	brpl	.-8      	; 0x1e08 <CO_collectSeismic3Axises+0x1cc>
    1e10:	fc 01       	movw	r30, r24
    1e12:	22 af       	sts	0x72, r18
    1e14:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1e16:	80 e4       	ldi	r24, 0x40	; 64
    1e18:	9a e0       	ldi	r25, 0x0A	; 10
    1e1a:	20 e4       	ldi	r18, 0x40	; 64
    1e1c:	3a e0       	ldi	r19, 0x0A	; 10
    1e1e:	f9 01       	movw	r30, r18
    1e20:	20 81       	ld	r18, Z
    1e22:	20 7f       	andi	r18, 0xF0	; 240
    1e24:	21 60       	ori	r18, 0x01	; 1
    1e26:	fc 01       	movw	r30, r24
    1e28:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    1e2a:	00 00       	nop
    1e2c:	20 91 75 50 	lds	r18, 0x5075
    1e30:	30 91 76 50 	lds	r19, 0x5076
    1e34:	40 91 77 50 	lds	r20, 0x5077
    1e38:	50 91 78 50 	lds	r21, 0x5078
    1e3c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1e3e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1e40:	af 8d       	ldd	r26, Y+31	; 0x1f
    1e42:	b8 a1       	lds	r27, 0x48
    1e44:	28 17       	cp	r18, r24
    1e46:	39 07       	cpc	r19, r25
    1e48:	4a 07       	cpc	r20, r26
    1e4a:	5b 07       	cpc	r21, r27
    1e4c:	78 f3       	brcs	.-34     	; 0x1e2c <CO_collectSeismic3Axises+0x1f0>

	// turn off timer and interrupts
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1e4e:	80 e0       	ldi	r24, 0x00	; 0
    1e50:	98 e0       	ldi	r25, 0x08	; 8
    1e52:	20 e0       	ldi	r18, 0x00	; 0
    1e54:	38 e0       	ldi	r19, 0x08	; 8
    1e56:	f9 01       	movw	r30, r18
    1e58:	20 81       	ld	r18, Z
    1e5a:	20 7f       	andi	r18, 0xF0	; 240
    1e5c:	fc 01       	movw	r30, r24
    1e5e:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1e60:	80 e4       	ldi	r24, 0x40	; 64
    1e62:	9a e0       	ldi	r25, 0x0A	; 10
    1e64:	20 e4       	ldi	r18, 0x40	; 64
    1e66:	3a e0       	ldi	r19, 0x0A	; 10
    1e68:	f9 01       	movw	r30, r18
    1e6a:	20 81       	ld	r18, Z
    1e6c:	20 7f       	andi	r18, 0xF0	; 240
    1e6e:	fc 01       	movw	r30, r24
    1e70:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    1e72:	80 ea       	ldi	r24, 0xA0	; 160
    1e74:	90 e0       	ldi	r25, 0x00	; 0
    1e76:	20 ea       	ldi	r18, 0xA0	; 160
    1e78:	30 e0       	ldi	r19, 0x00	; 0
    1e7a:	f9 01       	movw	r30, r18
    1e7c:	22 81       	ldd	r18, Z+2	; 0x02
    1e7e:	29 7f       	andi	r18, 0xF9	; 249
    1e80:	fc 01       	movw	r30, r24
    1e82:	22 83       	std	Z+2, r18	; 0x02
	cli();
    1e84:	f8 94       	cli

	SPICS(FALSE);
    1e86:	80 e0       	ldi	r24, 0x00	; 0
    1e88:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	SPIDisable();
    1e8c:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>
	enableADCMUX(FALSE);
    1e90:	80 e0       	ldi	r24, 0x00	; 0
    1e92:	0e 94 a6 08 	call	0x114c	; 0x114c <enableADCMUX>
	//ADCPower(FALSE);
}
    1e96:	2e 96       	adiw	r28, 0x0e	; 14
    1e98:	cd bf       	out	0x3d, r28	; 61
    1e9a:	de bf       	out	0x3e, r29	; 62
    1e9c:	df 91       	pop	r29
    1e9e:	cf 91       	pop	r28
    1ea0:	0f 91       	pop	r16
    1ea2:	ff 90       	pop	r15
    1ea4:	ef 90       	pop	r14
    1ea6:	df 90       	pop	r13
    1ea8:	cf 90       	pop	r12
    1eaa:	bf 90       	pop	r11
    1eac:	af 90       	pop	r10
    1eae:	9f 90       	pop	r9
    1eb0:	8f 90       	pop	r8
    1eb2:	08 95       	ret

00001eb4 <__vector_16>:

//first averaging point
ISR(TCC0_CCA_vect) {
    1eb4:	1f 92       	push	r1
    1eb6:	0f 92       	push	r0
    1eb8:	0f b6       	in	r0, 0x3f	; 63
    1eba:	0f 92       	push	r0
    1ebc:	00 90 3b 00 	lds	r0, 0x003B
    1ec0:	0f 92       	push	r0
    1ec2:	11 24       	eor	r1, r1
    1ec4:	2f 93       	push	r18
    1ec6:	3f 93       	push	r19
    1ec8:	4f 93       	push	r20
    1eca:	5f 93       	push	r21
    1ecc:	6f 93       	push	r22
    1ece:	7f 93       	push	r23
    1ed0:	8f 93       	push	r24
    1ed2:	9f 93       	push	r25
    1ed4:	af 93       	push	r26
    1ed6:	bf 93       	push	r27
    1ed8:	ef 93       	push	r30
    1eda:	ff 93       	push	r31
    1edc:	cf 93       	push	r28
    1ede:	df 93       	push	r29
    1ee0:	cd b7       	in	r28, 0x3d	; 61
    1ee2:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    1ee4:	0e 94 b9 13 	call	0x2772	; 0x2772 <sampleCurrentChannel>
}
    1ee8:	df 91       	pop	r29
    1eea:	cf 91       	pop	r28
    1eec:	ff 91       	pop	r31
    1eee:	ef 91       	pop	r30
    1ef0:	bf 91       	pop	r27
    1ef2:	af 91       	pop	r26
    1ef4:	9f 91       	pop	r25
    1ef6:	8f 91       	pop	r24
    1ef8:	7f 91       	pop	r23
    1efa:	6f 91       	pop	r22
    1efc:	5f 91       	pop	r21
    1efe:	4f 91       	pop	r20
    1f00:	3f 91       	pop	r19
    1f02:	2f 91       	pop	r18
    1f04:	0f 90       	pop	r0
    1f06:	00 92 3b 00 	sts	0x003B, r0
    1f0a:	0f 90       	pop	r0
    1f0c:	0f be       	out	0x3f, r0	; 63
    1f0e:	0f 90       	pop	r0
    1f10:	1f 90       	pop	r1
    1f12:	18 95       	reti

00001f14 <__vector_17>:

//second averaging point
ISR(TCC0_CCB_vect) {
    1f14:	1f 92       	push	r1
    1f16:	0f 92       	push	r0
    1f18:	0f b6       	in	r0, 0x3f	; 63
    1f1a:	0f 92       	push	r0
    1f1c:	00 90 3b 00 	lds	r0, 0x003B
    1f20:	0f 92       	push	r0
    1f22:	11 24       	eor	r1, r1
    1f24:	2f 93       	push	r18
    1f26:	3f 93       	push	r19
    1f28:	4f 93       	push	r20
    1f2a:	5f 93       	push	r21
    1f2c:	6f 93       	push	r22
    1f2e:	7f 93       	push	r23
    1f30:	8f 93       	push	r24
    1f32:	9f 93       	push	r25
    1f34:	af 93       	push	r26
    1f36:	bf 93       	push	r27
    1f38:	ef 93       	push	r30
    1f3a:	ff 93       	push	r31
    1f3c:	cf 93       	push	r28
    1f3e:	df 93       	push	r29
    1f40:	cd b7       	in	r28, 0x3d	; 61
    1f42:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    1f44:	0e 94 b9 13 	call	0x2772	; 0x2772 <sampleCurrentChannel>
}
    1f48:	df 91       	pop	r29
    1f4a:	cf 91       	pop	r28
    1f4c:	ff 91       	pop	r31
    1f4e:	ef 91       	pop	r30
    1f50:	bf 91       	pop	r27
    1f52:	af 91       	pop	r26
    1f54:	9f 91       	pop	r25
    1f56:	8f 91       	pop	r24
    1f58:	7f 91       	pop	r23
    1f5a:	6f 91       	pop	r22
    1f5c:	5f 91       	pop	r21
    1f5e:	4f 91       	pop	r20
    1f60:	3f 91       	pop	r19
    1f62:	2f 91       	pop	r18
    1f64:	0f 90       	pop	r0
    1f66:	00 92 3b 00 	sts	0x003B, r0
    1f6a:	0f 90       	pop	r0
    1f6c:	0f be       	out	0x3f, r0	; 63
    1f6e:	0f 90       	pop	r0
    1f70:	1f 90       	pop	r1
    1f72:	18 95       	reti

00001f74 <__vector_18>:

//third averaging point
ISR(TCC0_CCC_vect) {
    1f74:	1f 92       	push	r1
    1f76:	0f 92       	push	r0
    1f78:	0f b6       	in	r0, 0x3f	; 63
    1f7a:	0f 92       	push	r0
    1f7c:	00 90 3b 00 	lds	r0, 0x003B
    1f80:	0f 92       	push	r0
    1f82:	11 24       	eor	r1, r1
    1f84:	2f 93       	push	r18
    1f86:	3f 93       	push	r19
    1f88:	4f 93       	push	r20
    1f8a:	5f 93       	push	r21
    1f8c:	6f 93       	push	r22
    1f8e:	7f 93       	push	r23
    1f90:	8f 93       	push	r24
    1f92:	9f 93       	push	r25
    1f94:	af 93       	push	r26
    1f96:	bf 93       	push	r27
    1f98:	ef 93       	push	r30
    1f9a:	ff 93       	push	r31
    1f9c:	cf 93       	push	r28
    1f9e:	df 93       	push	r29
    1fa0:	cd b7       	in	r28, 0x3d	; 61
    1fa2:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    1fa4:	0e 94 b9 13 	call	0x2772	; 0x2772 <sampleCurrentChannel>
}
    1fa8:	df 91       	pop	r29
    1faa:	cf 91       	pop	r28
    1fac:	ff 91       	pop	r31
    1fae:	ef 91       	pop	r30
    1fb0:	bf 91       	pop	r27
    1fb2:	af 91       	pop	r26
    1fb4:	9f 91       	pop	r25
    1fb6:	8f 91       	pop	r24
    1fb8:	7f 91       	pop	r23
    1fba:	6f 91       	pop	r22
    1fbc:	5f 91       	pop	r21
    1fbe:	4f 91       	pop	r20
    1fc0:	3f 91       	pop	r19
    1fc2:	2f 91       	pop	r18
    1fc4:	0f 90       	pop	r0
    1fc6:	00 92 3b 00 	sts	0x003B, r0
    1fca:	0f 90       	pop	r0
    1fcc:	0f be       	out	0x3f, r0	; 63
    1fce:	0f 90       	pop	r0
    1fd0:	1f 90       	pop	r1
    1fd2:	18 95       	reti

00001fd4 <__vector_19>:

//final averaging point. Also change ADC channel to sample the next accelerometer axis
ISR(TCC0_CCD_vect) {
    1fd4:	1f 92       	push	r1
    1fd6:	0f 92       	push	r0
    1fd8:	0f b6       	in	r0, 0x3f	; 63
    1fda:	0f 92       	push	r0
    1fdc:	00 90 3b 00 	lds	r0, 0x003B
    1fe0:	0f 92       	push	r0
    1fe2:	11 24       	eor	r1, r1
    1fe4:	2f 93       	push	r18
    1fe6:	3f 93       	push	r19
    1fe8:	4f 93       	push	r20
    1fea:	5f 93       	push	r21
    1fec:	6f 93       	push	r22
    1fee:	7f 93       	push	r23
    1ff0:	8f 93       	push	r24
    1ff2:	9f 93       	push	r25
    1ff4:	af 93       	push	r26
    1ff6:	bf 93       	push	r27
    1ff8:	ef 93       	push	r30
    1ffa:	ff 93       	push	r31
    1ffc:	cf 93       	push	r28
    1ffe:	df 93       	push	r29
    2000:	cd b7       	in	r28, 0x3d	; 61
    2002:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2004:	0e 94 b9 13 	call	0x2772	; 0x2772 <sampleCurrentChannel>
	SPICount = 0;
    2008:	10 92 cf 50 	sts	0x50CF, r1
	if(PORTB.OUT & PIN1_bm) {
    200c:	80 e2       	ldi	r24, 0x20	; 32
    200e:	96 e0       	ldi	r25, 0x06	; 6
    2010:	fc 01       	movw	r30, r24
    2012:	84 81       	ldd	r24, Z+4	; 0x04
    2014:	88 2f       	mov	r24, r24
    2016:	90 e0       	ldi	r25, 0x00	; 0
    2018:	82 70       	andi	r24, 0x02	; 2
    201a:	90 70       	andi	r25, 0x00	; 0
    201c:	00 97       	sbiw	r24, 0x00	; 0
    201e:	b1 f0       	breq	.+44     	; 0x204c <__vector_19+0x78>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
    2020:	80 e0       	ldi	r24, 0x00	; 0
    2022:	96 e0       	ldi	r25, 0x06	; 6
    2024:	fc 01       	movw	r30, r24
    2026:	84 81       	ldd	r24, Z+4	; 0x04
    2028:	88 2f       	mov	r24, r24
    202a:	90 e0       	ldi	r25, 0x00	; 0
    202c:	80 74       	andi	r24, 0x40	; 64
    202e:	90 70       	andi	r25, 0x00	; 0
    2030:	00 97       	sbiw	r24, 0x00	; 0
    2032:	31 f0       	breq	.+12     	; 0x2040 <__vector_19+0x6c>
    2034:	80 e2       	ldi	r24, 0x20	; 32
    2036:	96 e0       	ldi	r25, 0x06	; 6
    2038:	22 e0       	ldi	r18, 0x02	; 2
    203a:	fc 01       	movw	r30, r24
    203c:	27 83       	std	Z+7, r18	; 0x07
    203e:	10 c0       	rjmp	.+32     	; 0x2060 <__vector_19+0x8c>
		else PORTA.OUTTGL = PIN6_bm;
    2040:	80 e0       	ldi	r24, 0x00	; 0
    2042:	96 e0       	ldi	r25, 0x06	; 6
    2044:	20 e4       	ldi	r18, 0x40	; 64
    2046:	fc 01       	movw	r30, r24
    2048:	27 83       	std	Z+7, r18	; 0x07
    204a:	0a c0       	rjmp	.+20     	; 0x2060 <__vector_19+0x8c>
	} else {
		PORTA.OUTCLR = PIN6_bm;
    204c:	80 e0       	ldi	r24, 0x00	; 0
    204e:	96 e0       	ldi	r25, 0x06	; 6
    2050:	20 e4       	ldi	r18, 0x40	; 64
    2052:	fc 01       	movw	r30, r24
    2054:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTSET = PIN1_bm;
    2056:	80 e2       	ldi	r24, 0x20	; 32
    2058:	96 e0       	ldi	r25, 0x06	; 6
    205a:	22 e0       	ldi	r18, 0x02	; 2
    205c:	fc 01       	movw	r30, r24
    205e:	25 83       	std	Z+5, r18	; 0x05
	}
	
}
    2060:	df 91       	pop	r29
    2062:	cf 91       	pop	r28
    2064:	ff 91       	pop	r31
    2066:	ef 91       	pop	r30
    2068:	bf 91       	pop	r27
    206a:	af 91       	pop	r26
    206c:	9f 91       	pop	r25
    206e:	8f 91       	pop	r24
    2070:	7f 91       	pop	r23
    2072:	6f 91       	pop	r22
    2074:	5f 91       	pop	r21
    2076:	4f 91       	pop	r20
    2078:	3f 91       	pop	r19
    207a:	2f 91       	pop	r18
    207c:	0f 90       	pop	r0
    207e:	00 92 3b 00 	sts	0x003B, r0
    2082:	0f 90       	pop	r0
    2084:	0f be       	out	0x3f, r0	; 63
    2086:	0f 90       	pop	r0
    2088:	1f 90       	pop	r1
    208a:	18 95       	reti

0000208c <__vector_14>:

//consolidate the 4 averaging points
ISR(TCC0_OVF_vect) {
    208c:	1f 92       	push	r1
    208e:	0f 92       	push	r0
    2090:	0f b6       	in	r0, 0x3f	; 63
    2092:	0f 92       	push	r0
    2094:	00 90 3b 00 	lds	r0, 0x003B
    2098:	0f 92       	push	r0
    209a:	11 24       	eor	r1, r1
    209c:	2f 93       	push	r18
    209e:	3f 93       	push	r19
    20a0:	4f 93       	push	r20
    20a2:	5f 93       	push	r21
    20a4:	6f 93       	push	r22
    20a6:	7f 93       	push	r23
    20a8:	8f 93       	push	r24
    20aa:	9f 93       	push	r25
    20ac:	af 93       	push	r26
    20ae:	bf 93       	push	r27
    20b0:	ef 93       	push	r30
    20b2:	ff 93       	push	r31
    20b4:	cf 93       	push	r28
    20b6:	df 93       	push	r29
    20b8:	cd b7       	in	r28, 0x3d	; 61
    20ba:	de b7       	in	r29, 0x3e	; 62
    20bc:	29 97       	sbiw	r28, 0x09	; 9
    20be:	cd bf       	out	0x3d, r28	; 61
    20c0:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    20c2:	1a 82       	std	Y+2, r1	; 0x02
    20c4:	1b 82       	std	Y+3, r1	; 0x03
    20c6:	1c 82       	std	Y+4, r1	; 0x04
    20c8:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	//sampleCount++;
		
	//SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    20ca:	19 82       	std	Y+1, r1	; 0x01
    20cc:	4f c0       	rjmp	.+158    	; 0x216c <__vector_14+0xe0>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    20ce:	89 81       	ldd	r24, Y+1	; 0x01
    20d0:	88 2f       	mov	r24, r24
    20d2:	90 e0       	ldi	r25, 0x00	; 0
    20d4:	8a 59       	subi	r24, 0x9A	; 154
    20d6:	9f 4a       	sbci	r25, 0xAF	; 175
    20d8:	fc 01       	movw	r30, r24
    20da:	80 81       	ld	r24, Z
    20dc:	88 23       	and	r24, r24
    20de:	3c f4       	brge	.+14     	; 0x20ee <__vector_14+0x62>
    20e0:	ce 01       	movw	r24, r28
    20e2:	06 96       	adiw	r24, 0x06	; 6
    20e4:	03 96       	adiw	r24, 0x03	; 3
    20e6:	2f ef       	ldi	r18, 0xFF	; 255
    20e8:	fc 01       	movw	r30, r24
    20ea:	20 83       	st	Z, r18
    20ec:	05 c0       	rjmp	.+10     	; 0x20f8 <__vector_14+0x6c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    20ee:	ce 01       	movw	r24, r28
    20f0:	06 96       	adiw	r24, 0x06	; 6
    20f2:	03 96       	adiw	r24, 0x03	; 3
    20f4:	fc 01       	movw	r30, r24
    20f6:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    20f8:	ce 01       	movw	r24, r28
    20fa:	06 96       	adiw	r24, 0x06	; 6
    20fc:	02 96       	adiw	r24, 0x02	; 2
    20fe:	29 81       	ldd	r18, Y+1	; 0x01
    2100:	22 2f       	mov	r18, r18
    2102:	30 e0       	ldi	r19, 0x00	; 0
    2104:	2a 59       	subi	r18, 0x9A	; 154
    2106:	3f 4a       	sbci	r19, 0xAF	; 175
    2108:	f9 01       	movw	r30, r18
    210a:	20 81       	ld	r18, Z
    210c:	fc 01       	movw	r30, r24
    210e:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    2110:	ce 01       	movw	r24, r28
    2112:	06 96       	adiw	r24, 0x06	; 6
    2114:	01 96       	adiw	r24, 0x01	; 1
    2116:	29 81       	ldd	r18, Y+1	; 0x01
    2118:	22 2f       	mov	r18, r18
    211a:	30 e0       	ldi	r19, 0x00	; 0
    211c:	2f 5f       	subi	r18, 0xFF	; 255
    211e:	3f 4f       	sbci	r19, 0xFF	; 255
    2120:	2a 59       	subi	r18, 0x9A	; 154
    2122:	3f 4a       	sbci	r19, 0xAF	; 175
    2124:	f9 01       	movw	r30, r18
    2126:	20 81       	ld	r18, Z
    2128:	fc 01       	movw	r30, r24
    212a:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    212c:	ce 01       	movw	r24, r28
    212e:	06 96       	adiw	r24, 0x06	; 6
    2130:	29 81       	ldd	r18, Y+1	; 0x01
    2132:	22 2f       	mov	r18, r18
    2134:	30 e0       	ldi	r19, 0x00	; 0
    2136:	2e 5f       	subi	r18, 0xFE	; 254
    2138:	3f 4f       	sbci	r19, 0xFF	; 255
    213a:	2a 59       	subi	r18, 0x9A	; 154
    213c:	3f 4a       	sbci	r19, 0xAF	; 175
    213e:	f9 01       	movw	r30, r18
    2140:	20 81       	ld	r18, Z
    2142:	fc 01       	movw	r30, r24
    2144:	20 83       	st	Z, r18
		sum += currentSample;
    2146:	2a 81       	ldd	r18, Y+2	; 0x02
    2148:	3b 81       	ldd	r19, Y+3	; 0x03
    214a:	4c 81       	ldd	r20, Y+4	; 0x04
    214c:	5d 81       	ldd	r21, Y+5	; 0x05
    214e:	8e 81       	ldd	r24, Y+6	; 0x06
    2150:	9f 81       	ldd	r25, Y+7	; 0x07
    2152:	a8 85       	ldd	r26, Y+8	; 0x08
    2154:	b9 85       	ldd	r27, Y+9	; 0x09
    2156:	82 0f       	add	r24, r18
    2158:	93 1f       	adc	r25, r19
    215a:	a4 1f       	adc	r26, r20
    215c:	b5 1f       	adc	r27, r21
    215e:	8a 83       	std	Y+2, r24	; 0x02
    2160:	9b 83       	std	Y+3, r25	; 0x03
    2162:	ac 83       	std	Y+4, r26	; 0x04
    2164:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	//sampleCount++;
		
	//SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2166:	89 81       	ldd	r24, Y+1	; 0x01
    2168:	8d 5f       	subi	r24, 0xFD	; 253
    216a:	89 83       	std	Y+1, r24	; 0x01
    216c:	89 81       	ldd	r24, Y+1	; 0x01
    216e:	8c 30       	cpi	r24, 0x0C	; 12
    2170:	08 f4       	brcc	.+2      	; 0x2174 <__vector_14+0xe8>
    2172:	ad cf       	rjmp	.-166    	; 0x20ce <__vector_14+0x42>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    2174:	8a 81       	ldd	r24, Y+2	; 0x02
    2176:	9b 81       	ldd	r25, Y+3	; 0x03
    2178:	ac 81       	ldd	r26, Y+4	; 0x04
    217a:	bd 81       	ldd	r27, Y+5	; 0x05
    217c:	24 e0       	ldi	r18, 0x04	; 4
    217e:	30 e0       	ldi	r19, 0x00	; 0
    2180:	40 e0       	ldi	r20, 0x00	; 0
    2182:	50 e0       	ldi	r21, 0x00	; 0
    2184:	bc 01       	movw	r22, r24
    2186:	cd 01       	movw	r24, r26
    2188:	0e 94 fb 5b 	call	0xb7f6	; 0xb7f6 <__divmodsi4>
    218c:	da 01       	movw	r26, r20
    218e:	c9 01       	movw	r24, r18
    2190:	8a 83       	std	Y+2, r24	; 0x02
    2192:	9b 83       	std	Y+3, r25	; 0x03
    2194:	ac 83       	std	Y+4, r26	; 0x04
    2196:	bd 83       	std	Y+5, r27	; 0x05
	ADC_BUFFER[sampleCount] = currentSample;
    2198:	20 91 73 50 	lds	r18, 0x5073
    219c:	30 91 74 50 	lds	r19, 0x5074
    21a0:	80 91 75 50 	lds	r24, 0x5075
    21a4:	90 91 76 50 	lds	r25, 0x5076
    21a8:	a0 91 77 50 	lds	r26, 0x5077
    21ac:	b0 91 78 50 	lds	r27, 0x5078
    21b0:	88 0f       	add	r24, r24
    21b2:	99 1f       	adc	r25, r25
    21b4:	88 0f       	add	r24, r24
    21b6:	99 1f       	adc	r25, r25
    21b8:	28 0f       	add	r18, r24
    21ba:	39 1f       	adc	r19, r25
    21bc:	8e 81       	ldd	r24, Y+6	; 0x06
    21be:	9f 81       	ldd	r25, Y+7	; 0x07
    21c0:	a8 85       	ldd	r26, Y+8	; 0x08
    21c2:	b9 85       	ldd	r27, Y+9	; 0x09
    21c4:	f9 01       	movw	r30, r18
    21c6:	80 83       	st	Z, r24
    21c8:	91 83       	std	Z+1, r25	; 0x01
    21ca:	a2 83       	std	Z+2, r26	; 0x02
    21cc:	b3 83       	std	Z+3, r27	; 0x03
	sampleCount++;
    21ce:	80 91 75 50 	lds	r24, 0x5075
    21d2:	90 91 76 50 	lds	r25, 0x5076
    21d6:	a0 91 77 50 	lds	r26, 0x5077
    21da:	b0 91 78 50 	lds	r27, 0x5078
    21de:	01 96       	adiw	r24, 0x01	; 1
    21e0:	a1 1d       	adc	r26, r1
    21e2:	b1 1d       	adc	r27, r1
    21e4:	80 93 75 50 	sts	0x5075, r24
    21e8:	90 93 76 50 	sts	0x5076, r25
    21ec:	a0 93 77 50 	sts	0x5077, r26
    21f0:	b0 93 78 50 	sts	0x5078, r27

}
    21f4:	29 96       	adiw	r28, 0x09	; 9
    21f6:	cd bf       	out	0x3d, r28	; 61
    21f8:	de bf       	out	0x3e, r29	; 62
    21fa:	df 91       	pop	r29
    21fc:	cf 91       	pop	r28
    21fe:	ff 91       	pop	r31
    2200:	ef 91       	pop	r30
    2202:	bf 91       	pop	r27
    2204:	af 91       	pop	r26
    2206:	9f 91       	pop	r25
    2208:	8f 91       	pop	r24
    220a:	7f 91       	pop	r23
    220c:	6f 91       	pop	r22
    220e:	5f 91       	pop	r21
    2210:	4f 91       	pop	r20
    2212:	3f 91       	pop	r19
    2214:	2f 91       	pop	r18
    2216:	0f 90       	pop	r0
    2218:	00 92 3b 00 	sts	0x003B, r0
    221c:	0f 90       	pop	r0
    221e:	0f be       	out	0x3f, r0	; 63
    2220:	0f 90       	pop	r0
    2222:	1f 90       	pop	r1
    2224:	18 95       	reti

00002226 <CO_collectSeismic1Channel>:

//collect data from 1 axis of accelerometer
void CO_collectSeismic1Channel(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint8_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, 
								uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD, uint32_t numOfSamples, int32_t* DataArray) {
    2226:	8f 92       	push	r8
    2228:	9f 92       	push	r9
    222a:	af 92       	push	r10
    222c:	bf 92       	push	r11
    222e:	cf 92       	push	r12
    2230:	df 92       	push	r13
    2232:	ef 92       	push	r14
    2234:	0f 93       	push	r16
    2236:	cf 93       	push	r28
    2238:	df 93       	push	r29
    223a:	cd b7       	in	r28, 0x3d	; 61
    223c:	de b7       	in	r29, 0x3e	; 62
    223e:	2c 97       	sbiw	r28, 0x0c	; 12
    2240:	cd bf       	out	0x3d, r28	; 61
    2242:	de bf       	out	0x3e, r29	; 62
    2244:	89 83       	std	Y+1, r24	; 0x01
    2246:	6a 83       	std	Y+2, r22	; 0x02
    2248:	4b 83       	std	Y+3, r20	; 0x03
    224a:	2c 83       	std	Y+4, r18	; 0x04
    224c:	0d 83       	std	Y+5, r16	; 0x05
    224e:	ee 82       	std	Y+6, r14	; 0x06
    2250:	cf 82       	std	Y+7, r12	; 0x07
    2252:	d8 86       	std	Y+8, r13	; 0x08
    2254:	a9 86       	std	Y+9, r10	; 0x09
    2256:	ba 86       	std	Y+10, r11	; 0x0a
    2258:	8b 86       	std	Y+11, r8	; 0x0b
    225a:	9c 86       	std	Y+12, r9	; 0x0c
	
	uint16_t period;
	ADC_BUFFER=DataArray;
    225c:	88 a1       	lds	r24, 0x48
    225e:	99 a1       	lds	r25, 0x49
    2260:	80 93 73 50 	sts	0x5073, r24
    2264:	90 93 74 50 	sts	0x5074, r25
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    2268:	81 e0       	ldi	r24, 0x01	; 1
    226a:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    226e:	89 81       	ldd	r24, Y+1	; 0x01
    2270:	6b 81       	ldd	r22, Y+3	; 0x03
    2272:	0e 94 f7 06 	call	0xdee	; 0xdee <set_ampGain>
	set_filter(filterConfig);
    2276:	8a 81       	ldd	r24, Y+2	; 0x02
    2278:	0e 94 26 08 	call	0x104c	; 0x104c <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    227c:	8e 81       	ldd	r24, Y+6	; 0x06
    227e:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    2282:	84 e0       	ldi	r24, 0x04	; 4
    2284:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2288:	80 ec       	ldi	r24, 0xC0	; 192
    228a:	98 e0       	ldi	r25, 0x08	; 8
    228c:	24 e5       	ldi	r18, 0x54	; 84
    228e:	fc 01       	movw	r30, r24
    2290:	20 83       	st	Z, r18

	enableADCMUX(TRUE);
    2292:	81 e0       	ldi	r24, 0x01	; 1
    2294:	0e 94 a6 08 	call	0x114c	; 0x114c <enableADCMUX>
	setADCInput(channel);
    2298:	89 81       	ldd	r24, Y+1	; 0x01
    229a:	0e 94 ad 19 	call	0x335a	; 0x335a <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    229e:	80 ea       	ldi	r24, 0xA0	; 160
    22a0:	96 e0       	ldi	r25, 0x06	; 6
    22a2:	22 e0       	ldi	r18, 0x02	; 2
    22a4:	fc 01       	movw	r30, r24
    22a6:	20 8b       	std	Z+16, r18	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    22a8:	80 ea       	ldi	r24, 0xA0	; 160
    22aa:	96 e0       	ldi	r25, 0x06	; 6
    22ac:	21 e0       	ldi	r18, 0x01	; 1
    22ae:	fc 01       	movw	r30, r24
    22b0:	22 83       	std	Z+2, r18	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    22b2:	80 e8       	ldi	r24, 0x80	; 128
    22b4:	91 e0       	ldi	r25, 0x01	; 1
    22b6:	28 e7       	ldi	r18, 0x78	; 120
    22b8:	fc 01       	movw	r30, r24
    22ba:	20 83       	st	Z, r18

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    22bc:	80 e0       	ldi	r24, 0x00	; 0
    22be:	99 e0       	ldi	r25, 0x09	; 9
    22c0:	20 ef       	ldi	r18, 0xF0	; 240
    22c2:	fc 01       	movw	r30, r24
    22c4:	21 83       	std	Z+1, r18	; 0x01
	TCD0.CCA = averagingPtA;
    22c6:	80 e0       	ldi	r24, 0x00	; 0
    22c8:	99 e0       	ldi	r25, 0x09	; 9
    22ca:	2f 81       	ldd	r18, Y+7	; 0x07
    22cc:	38 85       	ldd	r19, Y+8	; 0x08
    22ce:	fc 01       	movw	r30, r24
    22d0:	20 a7       	lds	r18, 0x70
    22d2:	31 a7       	lds	r19, 0x71
	TCD0.CCB = averagingPtB;
    22d4:	80 e0       	ldi	r24, 0x00	; 0
    22d6:	99 e0       	ldi	r25, 0x09	; 9
    22d8:	29 85       	ldd	r18, Y+9	; 0x09
    22da:	3a 85       	ldd	r19, Y+10	; 0x0a
    22dc:	fc 01       	movw	r30, r24
    22de:	22 a7       	lds	r18, 0x72
    22e0:	33 a7       	lds	r19, 0x73
	TCD0.CCC = averagingPtC;
    22e2:	80 e0       	ldi	r24, 0x00	; 0
    22e4:	99 e0       	ldi	r25, 0x09	; 9
    22e6:	2b 85       	ldd	r18, Y+11	; 0x0b
    22e8:	3c 85       	ldd	r19, Y+12	; 0x0c
    22ea:	fc 01       	movw	r30, r24
    22ec:	24 a7       	lds	r18, 0x74
    22ee:	35 a7       	lds	r19, 0x75
	TCD0.CCD = averagingPtD;
    22f0:	80 e0       	ldi	r24, 0x00	; 0
    22f2:	99 e0       	ldi	r25, 0x09	; 9
    22f4:	2a 8d       	ldd	r18, Y+26	; 0x1a
    22f6:	3b 8d       	ldd	r19, Y+27	; 0x1b
    22f8:	fc 01       	movw	r30, r24
    22fa:	26 a7       	lds	r18, 0x76
    22fc:	37 a7       	lds	r19, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    22fe:	80 e0       	ldi	r24, 0x00	; 0
    2300:	99 e0       	ldi	r25, 0x09	; 9
    2302:	2d 81       	ldd	r18, Y+5	; 0x05
    2304:	22 2f       	mov	r18, r18
    2306:	30 e0       	ldi	r19, 0x00	; 0
    2308:	21 50       	subi	r18, 0x01	; 1
    230a:	30 40       	sbci	r19, 0x00	; 0
    230c:	fc 01       	movw	r30, r24
    230e:	26 a3       	lds	r18, 0x56
    2310:	37 a3       	lds	r19, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    2312:	80 e0       	ldi	r24, 0x00	; 0
    2314:	99 e0       	ldi	r25, 0x09	; 9
    2316:	22 e0       	ldi	r18, 0x02	; 2
    2318:	fc 01       	movw	r30, r24
    231a:	26 83       	std	Z+6, r18	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    231c:	80 e0       	ldi	r24, 0x00	; 0
    231e:	99 e0       	ldi	r25, 0x09	; 9
    2320:	2f ef       	ldi	r18, 0xFF	; 255
    2322:	fc 01       	movw	r30, r24
    2324:	27 83       	std	Z+7, r18	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    2326:	80 e0       	ldi	r24, 0x00	; 0
    2328:	99 e0       	ldi	r25, 0x09	; 9
    232a:	20 e0       	ldi	r18, 0x00	; 0
    232c:	39 e0       	ldi	r19, 0x09	; 9
    232e:	f9 01       	movw	r30, r18
    2330:	20 81       	ld	r18, Z
    2332:	20 7f       	andi	r18, 0xF0	; 240
    2334:	28 60       	ori	r18, 0x08	; 8
    2336:	fc 01       	movw	r30, r24
    2338:	20 83       	st	Z, r18

	//FRAMAddress = FR_BASEADD;
	sampleCount = 0;
    233a:	10 92 75 50 	sts	0x5075, r1
    233e:	10 92 76 50 	sts	0x5076, r1
    2342:	10 92 77 50 	sts	0x5077, r1
    2346:	10 92 78 50 	sts	0x5078, r1
	SPICount = 0;
    234a:	10 92 cf 50 	sts	0x50CF, r1
	//checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm;
    234e:	80 ea       	ldi	r24, 0xA0	; 160
    2350:	90 e0       	ldi	r25, 0x00	; 0
    2352:	20 ea       	ldi	r18, 0xA0	; 160
    2354:	30 e0       	ldi	r19, 0x00	; 0
    2356:	f9 01       	movw	r30, r18
    2358:	22 81       	ldd	r18, Z+2	; 0x02
    235a:	26 60       	ori	r18, 0x06	; 6
    235c:	fc 01       	movw	r30, r24
    235e:	22 83       	std	Z+2, r18	; 0x02
	sei();
    2360:	78 94       	sei

	SPICS(TRUE);
    2362:	81 e0       	ldi	r24, 0x01	; 1
    2364:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    2368:	80 e8       	ldi	r24, 0x80	; 128
    236a:	96 e0       	ldi	r25, 0x06	; 6
    236c:	20 e2       	ldi	r18, 0x20	; 32
    236e:	fc 01       	movw	r30, r24
    2370:	21 83       	std	Z+1, r18	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    2372:	80 e4       	ldi	r24, 0x40	; 64
    2374:	9a e0       	ldi	r25, 0x0A	; 10
    2376:	23 e2       	ldi	r18, 0x23	; 35
    2378:	fc 01       	movw	r30, r24
    237a:	21 83       	std	Z+1, r18	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    237c:	80 e4       	ldi	r24, 0x40	; 64
    237e:	9a e0       	ldi	r25, 0x0A	; 10
    2380:	2c 81       	ldd	r18, Y+4	; 0x04
    2382:	42 2f       	mov	r20, r18
    2384:	50 e0       	ldi	r21, 0x00	; 0
    2386:	20 e2       	ldi	r18, 0x20	; 32
    2388:	30 e0       	ldi	r19, 0x00	; 0
    238a:	02 c0       	rjmp	.+4      	; 0x2390 <CO_collectSeismic1Channel+0x16a>
    238c:	22 0f       	add	r18, r18
    238e:	33 1f       	adc	r19, r19
    2390:	4a 95       	dec	r20
    2392:	e2 f7       	brpl	.-8      	; 0x238c <CO_collectSeismic1Channel+0x166>
    2394:	fc 01       	movw	r30, r24
    2396:	26 a3       	lds	r18, 0x56
    2398:	37 a3       	lds	r19, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    239a:	80 e4       	ldi	r24, 0x40	; 64
    239c:	9a e0       	ldi	r25, 0x0A	; 10
    239e:	2c 81       	ldd	r18, Y+4	; 0x04
    23a0:	42 2f       	mov	r20, r18
    23a2:	50 e0       	ldi	r21, 0x00	; 0
    23a4:	20 e1       	ldi	r18, 0x10	; 16
    23a6:	30 e0       	ldi	r19, 0x00	; 0
    23a8:	02 c0       	rjmp	.+4      	; 0x23ae <CO_collectSeismic1Channel+0x188>
    23aa:	22 0f       	add	r18, r18
    23ac:	33 1f       	adc	r19, r19
    23ae:	4a 95       	dec	r20
    23b0:	e2 f7       	brpl	.-8      	; 0x23aa <CO_collectSeismic1Channel+0x184>
    23b2:	fc 01       	movw	r30, r24
    23b4:	22 af       	sts	0x72, r18
    23b6:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    23b8:	80 e4       	ldi	r24, 0x40	; 64
    23ba:	9a e0       	ldi	r25, 0x0A	; 10
    23bc:	20 e4       	ldi	r18, 0x40	; 64
    23be:	3a e0       	ldi	r19, 0x0A	; 10
    23c0:	f9 01       	movw	r30, r18
    23c2:	20 81       	ld	r18, Z
    23c4:	20 7f       	andi	r18, 0xF0	; 240
    23c6:	21 60       	ori	r18, 0x01	; 1
    23c8:	fc 01       	movw	r30, r24
    23ca:	20 83       	st	Z, r18
	
	// wait for ADC to collect samples
	while(sampleCount < numOfSamples);
    23cc:	00 00       	nop
    23ce:	20 91 75 50 	lds	r18, 0x5075
    23d2:	30 91 76 50 	lds	r19, 0x5076
    23d6:	40 91 77 50 	lds	r20, 0x5077
    23da:	50 91 78 50 	lds	r21, 0x5078
    23de:	8c 8d       	ldd	r24, Y+28	; 0x1c
    23e0:	9d 8d       	ldd	r25, Y+29	; 0x1d
    23e2:	ae 8d       	ldd	r26, Y+30	; 0x1e
    23e4:	bf 8d       	ldd	r27, Y+31	; 0x1f
    23e6:	28 17       	cp	r18, r24
    23e8:	39 07       	cpc	r19, r25
    23ea:	4a 07       	cpc	r20, r26
    23ec:	5b 07       	cpc	r21, r27
    23ee:	78 f3       	brcs	.-34     	; 0x23ce <CO_collectSeismic1Channel+0x1a8>

	// turn off timer and interrupts
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    23f0:	80 e0       	ldi	r24, 0x00	; 0
    23f2:	99 e0       	ldi	r25, 0x09	; 9
    23f4:	20 e0       	ldi	r18, 0x00	; 0
    23f6:	39 e0       	ldi	r19, 0x09	; 9
    23f8:	f9 01       	movw	r30, r18
    23fa:	20 81       	ld	r18, Z
    23fc:	20 7f       	andi	r18, 0xF0	; 240
    23fe:	fc 01       	movw	r30, r24
    2400:	20 83       	st	Z, r18
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2402:	80 e4       	ldi	r24, 0x40	; 64
    2404:	9a e0       	ldi	r25, 0x0A	; 10
    2406:	20 e4       	ldi	r18, 0x40	; 64
    2408:	3a e0       	ldi	r19, 0x0A	; 10
    240a:	f9 01       	movw	r30, r18
    240c:	20 81       	ld	r18, Z
    240e:	20 7f       	andi	r18, 0xF0	; 240
    2410:	fc 01       	movw	r30, r24
    2412:	20 83       	st	Z, r18
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    2414:	80 ea       	ldi	r24, 0xA0	; 160
    2416:	90 e0       	ldi	r25, 0x00	; 0
    2418:	20 ea       	ldi	r18, 0xA0	; 160
    241a:	30 e0       	ldi	r19, 0x00	; 0
    241c:	f9 01       	movw	r30, r18
    241e:	22 81       	ldd	r18, Z+2	; 0x02
    2420:	29 7f       	andi	r18, 0xF9	; 249
    2422:	fc 01       	movw	r30, r24
    2424:	22 83       	std	Z+2, r18	; 0x02
	cli();
    2426:	f8 94       	cli

	SPICS(FALSE);
    2428:	80 e0       	ldi	r24, 0x00	; 0
    242a:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	SPIDisable();
    242e:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>
	enableADCMUX(FALSE);
    2432:	80 e0       	ldi	r24, 0x00	; 0
    2434:	0e 94 a6 08 	call	0x114c	; 0x114c <enableADCMUX>
	//ADCPower(FALSE);
	
}
    2438:	2c 96       	adiw	r28, 0x0c	; 12
    243a:	cd bf       	out	0x3d, r28	; 61
    243c:	de bf       	out	0x3e, r29	; 62
    243e:	df 91       	pop	r29
    2440:	cf 91       	pop	r28
    2442:	0f 91       	pop	r16
    2444:	ef 90       	pop	r14
    2446:	df 90       	pop	r13
    2448:	cf 90       	pop	r12
    244a:	bf 90       	pop	r11
    244c:	af 90       	pop	r10
    244e:	9f 90       	pop	r9
    2450:	8f 90       	pop	r8
    2452:	08 95       	ret

00002454 <__vector_79>:

//first averaging point
ISR(TCD0_CCA_vect) {
    2454:	1f 92       	push	r1
    2456:	0f 92       	push	r0
    2458:	0f b6       	in	r0, 0x3f	; 63
    245a:	0f 92       	push	r0
    245c:	00 90 3b 00 	lds	r0, 0x003B
    2460:	0f 92       	push	r0
    2462:	11 24       	eor	r1, r1
    2464:	2f 93       	push	r18
    2466:	3f 93       	push	r19
    2468:	4f 93       	push	r20
    246a:	5f 93       	push	r21
    246c:	6f 93       	push	r22
    246e:	7f 93       	push	r23
    2470:	8f 93       	push	r24
    2472:	9f 93       	push	r25
    2474:	af 93       	push	r26
    2476:	bf 93       	push	r27
    2478:	ef 93       	push	r30
    247a:	ff 93       	push	r31
    247c:	cf 93       	push	r28
    247e:	df 93       	push	r29
    2480:	cd b7       	in	r28, 0x3d	; 61
    2482:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2484:	0e 94 b9 13 	call	0x2772	; 0x2772 <sampleCurrentChannel>
}
    2488:	df 91       	pop	r29
    248a:	cf 91       	pop	r28
    248c:	ff 91       	pop	r31
    248e:	ef 91       	pop	r30
    2490:	bf 91       	pop	r27
    2492:	af 91       	pop	r26
    2494:	9f 91       	pop	r25
    2496:	8f 91       	pop	r24
    2498:	7f 91       	pop	r23
    249a:	6f 91       	pop	r22
    249c:	5f 91       	pop	r21
    249e:	4f 91       	pop	r20
    24a0:	3f 91       	pop	r19
    24a2:	2f 91       	pop	r18
    24a4:	0f 90       	pop	r0
    24a6:	00 92 3b 00 	sts	0x003B, r0
    24aa:	0f 90       	pop	r0
    24ac:	0f be       	out	0x3f, r0	; 63
    24ae:	0f 90       	pop	r0
    24b0:	1f 90       	pop	r1
    24b2:	18 95       	reti

000024b4 <__vector_80>:
//second averaging point
ISR(TCD0_CCB_vect) {
    24b4:	1f 92       	push	r1
    24b6:	0f 92       	push	r0
    24b8:	0f b6       	in	r0, 0x3f	; 63
    24ba:	0f 92       	push	r0
    24bc:	00 90 3b 00 	lds	r0, 0x003B
    24c0:	0f 92       	push	r0
    24c2:	11 24       	eor	r1, r1
    24c4:	2f 93       	push	r18
    24c6:	3f 93       	push	r19
    24c8:	4f 93       	push	r20
    24ca:	5f 93       	push	r21
    24cc:	6f 93       	push	r22
    24ce:	7f 93       	push	r23
    24d0:	8f 93       	push	r24
    24d2:	9f 93       	push	r25
    24d4:	af 93       	push	r26
    24d6:	bf 93       	push	r27
    24d8:	ef 93       	push	r30
    24da:	ff 93       	push	r31
    24dc:	cf 93       	push	r28
    24de:	df 93       	push	r29
    24e0:	cd b7       	in	r28, 0x3d	; 61
    24e2:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    24e4:	0e 94 b9 13 	call	0x2772	; 0x2772 <sampleCurrentChannel>
}
    24e8:	df 91       	pop	r29
    24ea:	cf 91       	pop	r28
    24ec:	ff 91       	pop	r31
    24ee:	ef 91       	pop	r30
    24f0:	bf 91       	pop	r27
    24f2:	af 91       	pop	r26
    24f4:	9f 91       	pop	r25
    24f6:	8f 91       	pop	r24
    24f8:	7f 91       	pop	r23
    24fa:	6f 91       	pop	r22
    24fc:	5f 91       	pop	r21
    24fe:	4f 91       	pop	r20
    2500:	3f 91       	pop	r19
    2502:	2f 91       	pop	r18
    2504:	0f 90       	pop	r0
    2506:	00 92 3b 00 	sts	0x003B, r0
    250a:	0f 90       	pop	r0
    250c:	0f be       	out	0x3f, r0	; 63
    250e:	0f 90       	pop	r0
    2510:	1f 90       	pop	r1
    2512:	18 95       	reti

00002514 <__vector_81>:

//third averaging point
ISR(TCD0_CCC_vect) {
    2514:	1f 92       	push	r1
    2516:	0f 92       	push	r0
    2518:	0f b6       	in	r0, 0x3f	; 63
    251a:	0f 92       	push	r0
    251c:	00 90 3b 00 	lds	r0, 0x003B
    2520:	0f 92       	push	r0
    2522:	11 24       	eor	r1, r1
    2524:	2f 93       	push	r18
    2526:	3f 93       	push	r19
    2528:	4f 93       	push	r20
    252a:	5f 93       	push	r21
    252c:	6f 93       	push	r22
    252e:	7f 93       	push	r23
    2530:	8f 93       	push	r24
    2532:	9f 93       	push	r25
    2534:	af 93       	push	r26
    2536:	bf 93       	push	r27
    2538:	ef 93       	push	r30
    253a:	ff 93       	push	r31
    253c:	cf 93       	push	r28
    253e:	df 93       	push	r29
    2540:	cd b7       	in	r28, 0x3d	; 61
    2542:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    2544:	0e 94 b9 13 	call	0x2772	; 0x2772 <sampleCurrentChannel>
}
    2548:	df 91       	pop	r29
    254a:	cf 91       	pop	r28
    254c:	ff 91       	pop	r31
    254e:	ef 91       	pop	r30
    2550:	bf 91       	pop	r27
    2552:	af 91       	pop	r26
    2554:	9f 91       	pop	r25
    2556:	8f 91       	pop	r24
    2558:	7f 91       	pop	r23
    255a:	6f 91       	pop	r22
    255c:	5f 91       	pop	r21
    255e:	4f 91       	pop	r20
    2560:	3f 91       	pop	r19
    2562:	2f 91       	pop	r18
    2564:	0f 90       	pop	r0
    2566:	00 92 3b 00 	sts	0x003B, r0
    256a:	0f 90       	pop	r0
    256c:	0f be       	out	0x3f, r0	; 63
    256e:	0f 90       	pop	r0
    2570:	1f 90       	pop	r1
    2572:	18 95       	reti

00002574 <__vector_82>:

//final averaging point
ISR(TCD0_CCD_vect) {
    2574:	1f 92       	push	r1
    2576:	0f 92       	push	r0
    2578:	0f b6       	in	r0, 0x3f	; 63
    257a:	0f 92       	push	r0
    257c:	00 90 3b 00 	lds	r0, 0x003B
    2580:	0f 92       	push	r0
    2582:	11 24       	eor	r1, r1
    2584:	2f 93       	push	r18
    2586:	3f 93       	push	r19
    2588:	4f 93       	push	r20
    258a:	5f 93       	push	r21
    258c:	6f 93       	push	r22
    258e:	7f 93       	push	r23
    2590:	8f 93       	push	r24
    2592:	9f 93       	push	r25
    2594:	af 93       	push	r26
    2596:	bf 93       	push	r27
    2598:	ef 93       	push	r30
    259a:	ff 93       	push	r31
    259c:	cf 93       	push	r28
    259e:	df 93       	push	r29
    25a0:	cd b7       	in	r28, 0x3d	; 61
    25a2:	de b7       	in	r29, 0x3e	; 62
	sampleCurrentChannel();
    25a4:	0e 94 b9 13 	call	0x2772	; 0x2772 <sampleCurrentChannel>
	SPICount = 0;
    25a8:	10 92 cf 50 	sts	0x50CF, r1
}
    25ac:	df 91       	pop	r29
    25ae:	cf 91       	pop	r28
    25b0:	ff 91       	pop	r31
    25b2:	ef 91       	pop	r30
    25b4:	bf 91       	pop	r27
    25b6:	af 91       	pop	r26
    25b8:	9f 91       	pop	r25
    25ba:	8f 91       	pop	r24
    25bc:	7f 91       	pop	r23
    25be:	6f 91       	pop	r22
    25c0:	5f 91       	pop	r21
    25c2:	4f 91       	pop	r20
    25c4:	3f 91       	pop	r19
    25c6:	2f 91       	pop	r18
    25c8:	0f 90       	pop	r0
    25ca:	00 92 3b 00 	sts	0x003B, r0
    25ce:	0f 90       	pop	r0
    25d0:	0f be       	out	0x3f, r0	; 63
    25d2:	0f 90       	pop	r0
    25d4:	1f 90       	pop	r1
    25d6:	18 95       	reti

000025d8 <__vector_77>:

//consolidate the 4 averaging points
ISR(TCD0_OVF_vect) {
    25d8:	1f 92       	push	r1
    25da:	0f 92       	push	r0
    25dc:	0f b6       	in	r0, 0x3f	; 63
    25de:	0f 92       	push	r0
    25e0:	00 90 3b 00 	lds	r0, 0x003B
    25e4:	0f 92       	push	r0
    25e6:	11 24       	eor	r1, r1
    25e8:	2f 93       	push	r18
    25ea:	3f 93       	push	r19
    25ec:	4f 93       	push	r20
    25ee:	5f 93       	push	r21
    25f0:	6f 93       	push	r22
    25f2:	7f 93       	push	r23
    25f4:	8f 93       	push	r24
    25f6:	9f 93       	push	r25
    25f8:	af 93       	push	r26
    25fa:	bf 93       	push	r27
    25fc:	ef 93       	push	r30
    25fe:	ff 93       	push	r31
    2600:	cf 93       	push	r28
    2602:	df 93       	push	r29
    2604:	cd b7       	in	r28, 0x3d	; 61
    2606:	de b7       	in	r29, 0x3e	; 62
    2608:	29 97       	sbiw	r28, 0x09	; 9
    260a:	cd bf       	out	0x3d, r28	; 61
    260c:	de bf       	out	0x3e, r29	; 62
	//writeSE2FRAM();
	volatile int32_t sum = 0;
    260e:	1a 82       	std	Y+2, r1	; 0x02
    2610:	1b 82       	std	Y+3, r1	; 0x03
    2612:	1c 82       	std	Y+4, r1	; 0x04
    2614:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
		
	//SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    2616:	19 82       	std	Y+1, r1	; 0x01
    2618:	4f c0       	rjmp	.+158    	; 0x26b8 <__vector_77+0xe0>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    261a:	89 81       	ldd	r24, Y+1	; 0x01
    261c:	88 2f       	mov	r24, r24
    261e:	90 e0       	ldi	r25, 0x00	; 0
    2620:	8a 59       	subi	r24, 0x9A	; 154
    2622:	9f 4a       	sbci	r25, 0xAF	; 175
    2624:	fc 01       	movw	r30, r24
    2626:	80 81       	ld	r24, Z
    2628:	88 23       	and	r24, r24
    262a:	3c f4       	brge	.+14     	; 0x263a <__vector_77+0x62>
    262c:	ce 01       	movw	r24, r28
    262e:	06 96       	adiw	r24, 0x06	; 6
    2630:	03 96       	adiw	r24, 0x03	; 3
    2632:	2f ef       	ldi	r18, 0xFF	; 255
    2634:	fc 01       	movw	r30, r24
    2636:	20 83       	st	Z, r18
    2638:	05 c0       	rjmp	.+10     	; 0x2644 <__vector_77+0x6c>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    263a:	ce 01       	movw	r24, r28
    263c:	06 96       	adiw	r24, 0x06	; 6
    263e:	03 96       	adiw	r24, 0x03	; 3
    2640:	fc 01       	movw	r30, r24
    2642:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    2644:	ce 01       	movw	r24, r28
    2646:	06 96       	adiw	r24, 0x06	; 6
    2648:	02 96       	adiw	r24, 0x02	; 2
    264a:	29 81       	ldd	r18, Y+1	; 0x01
    264c:	22 2f       	mov	r18, r18
    264e:	30 e0       	ldi	r19, 0x00	; 0
    2650:	2a 59       	subi	r18, 0x9A	; 154
    2652:	3f 4a       	sbci	r19, 0xAF	; 175
    2654:	f9 01       	movw	r30, r18
    2656:	20 81       	ld	r18, Z
    2658:	fc 01       	movw	r30, r24
    265a:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    265c:	ce 01       	movw	r24, r28
    265e:	06 96       	adiw	r24, 0x06	; 6
    2660:	01 96       	adiw	r24, 0x01	; 1
    2662:	29 81       	ldd	r18, Y+1	; 0x01
    2664:	22 2f       	mov	r18, r18
    2666:	30 e0       	ldi	r19, 0x00	; 0
    2668:	2f 5f       	subi	r18, 0xFF	; 255
    266a:	3f 4f       	sbci	r19, 0xFF	; 255
    266c:	2a 59       	subi	r18, 0x9A	; 154
    266e:	3f 4a       	sbci	r19, 0xAF	; 175
    2670:	f9 01       	movw	r30, r18
    2672:	20 81       	ld	r18, Z
    2674:	fc 01       	movw	r30, r24
    2676:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    2678:	ce 01       	movw	r24, r28
    267a:	06 96       	adiw	r24, 0x06	; 6
    267c:	29 81       	ldd	r18, Y+1	; 0x01
    267e:	22 2f       	mov	r18, r18
    2680:	30 e0       	ldi	r19, 0x00	; 0
    2682:	2e 5f       	subi	r18, 0xFE	; 254
    2684:	3f 4f       	sbci	r19, 0xFF	; 255
    2686:	2a 59       	subi	r18, 0x9A	; 154
    2688:	3f 4a       	sbci	r19, 0xAF	; 175
    268a:	f9 01       	movw	r30, r18
    268c:	20 81       	ld	r18, Z
    268e:	fc 01       	movw	r30, r24
    2690:	20 83       	st	Z, r18
		sum += currentSample;
    2692:	2a 81       	ldd	r18, Y+2	; 0x02
    2694:	3b 81       	ldd	r19, Y+3	; 0x03
    2696:	4c 81       	ldd	r20, Y+4	; 0x04
    2698:	5d 81       	ldd	r21, Y+5	; 0x05
    269a:	8e 81       	ldd	r24, Y+6	; 0x06
    269c:	9f 81       	ldd	r25, Y+7	; 0x07
    269e:	a8 85       	ldd	r26, Y+8	; 0x08
    26a0:	b9 85       	ldd	r27, Y+9	; 0x09
    26a2:	82 0f       	add	r24, r18
    26a4:	93 1f       	adc	r25, r19
    26a6:	a4 1f       	adc	r26, r20
    26a8:	b5 1f       	adc	r27, r21
    26aa:	8a 83       	std	Y+2, r24	; 0x02
    26ac:	9b 83       	std	Y+3, r25	; 0x03
    26ae:	ac 83       	std	Y+4, r26	; 0x04
    26b0:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t sum = 0;
	volatile int32_t currentSample;
		
	//SPIC.CTRL = FR_SPI_CONFIG_gc;
		
	for(uint8_t i = 0; i < 12; i+=3) {
    26b2:	89 81       	ldd	r24, Y+1	; 0x01
    26b4:	8d 5f       	subi	r24, 0xFD	; 253
    26b6:	89 83       	std	Y+1, r24	; 0x01
    26b8:	89 81       	ldd	r24, Y+1	; 0x01
    26ba:	8c 30       	cpi	r24, 0x0C	; 12
    26bc:	08 f4       	brcc	.+2      	; 0x26c0 <__vector_77+0xe8>
    26be:	ad cf       	rjmp	.-166    	; 0x261a <__vector_77+0x42>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
		
	sum = sum / 4;
    26c0:	8a 81       	ldd	r24, Y+2	; 0x02
    26c2:	9b 81       	ldd	r25, Y+3	; 0x03
    26c4:	ac 81       	ldd	r26, Y+4	; 0x04
    26c6:	bd 81       	ldd	r27, Y+5	; 0x05
    26c8:	24 e0       	ldi	r18, 0x04	; 4
    26ca:	30 e0       	ldi	r19, 0x00	; 0
    26cc:	40 e0       	ldi	r20, 0x00	; 0
    26ce:	50 e0       	ldi	r21, 0x00	; 0
    26d0:	bc 01       	movw	r22, r24
    26d2:	cd 01       	movw	r24, r26
    26d4:	0e 94 fb 5b 	call	0xb7f6	; 0xb7f6 <__divmodsi4>
    26d8:	da 01       	movw	r26, r20
    26da:	c9 01       	movw	r24, r18
    26dc:	8a 83       	std	Y+2, r24	; 0x02
    26de:	9b 83       	std	Y+3, r25	; 0x03
    26e0:	ac 83       	std	Y+4, r26	; 0x04
    26e2:	bd 83       	std	Y+5, r27	; 0x05
	//get average of the 4 subsamples
	ADC_BUFFER[sampleCount] = sum;
    26e4:	20 91 73 50 	lds	r18, 0x5073
    26e8:	30 91 74 50 	lds	r19, 0x5074
    26ec:	80 91 75 50 	lds	r24, 0x5075
    26f0:	90 91 76 50 	lds	r25, 0x5076
    26f4:	a0 91 77 50 	lds	r26, 0x5077
    26f8:	b0 91 78 50 	lds	r27, 0x5078
    26fc:	88 0f       	add	r24, r24
    26fe:	99 1f       	adc	r25, r25
    2700:	88 0f       	add	r24, r24
    2702:	99 1f       	adc	r25, r25
    2704:	28 0f       	add	r18, r24
    2706:	39 1f       	adc	r19, r25
    2708:	8a 81       	ldd	r24, Y+2	; 0x02
    270a:	9b 81       	ldd	r25, Y+3	; 0x03
    270c:	ac 81       	ldd	r26, Y+4	; 0x04
    270e:	bd 81       	ldd	r27, Y+5	; 0x05
    2710:	f9 01       	movw	r30, r18
    2712:	80 83       	st	Z, r24
    2714:	91 83       	std	Z+1, r25	; 0x01
    2716:	a2 83       	std	Z+2, r26	; 0x02
    2718:	b3 83       	std	Z+3, r27	; 0x03
	sampleCount++;
    271a:	80 91 75 50 	lds	r24, 0x5075
    271e:	90 91 76 50 	lds	r25, 0x5076
    2722:	a0 91 77 50 	lds	r26, 0x5077
    2726:	b0 91 78 50 	lds	r27, 0x5078
    272a:	01 96       	adiw	r24, 0x01	; 1
    272c:	a1 1d       	adc	r26, r1
    272e:	b1 1d       	adc	r27, r1
    2730:	80 93 75 50 	sts	0x5075, r24
    2734:	90 93 76 50 	sts	0x5076, r25
    2738:	a0 93 77 50 	sts	0x5077, r26
    273c:	b0 93 78 50 	sts	0x5078, r27
}
    2740:	29 96       	adiw	r28, 0x09	; 9
    2742:	cd bf       	out	0x3d, r28	; 61
    2744:	de bf       	out	0x3e, r29	; 62
    2746:	df 91       	pop	r29
    2748:	cf 91       	pop	r28
    274a:	ff 91       	pop	r31
    274c:	ef 91       	pop	r30
    274e:	bf 91       	pop	r27
    2750:	af 91       	pop	r26
    2752:	9f 91       	pop	r25
    2754:	8f 91       	pop	r24
    2756:	7f 91       	pop	r23
    2758:	6f 91       	pop	r22
    275a:	5f 91       	pop	r21
    275c:	4f 91       	pop	r20
    275e:	3f 91       	pop	r19
    2760:	2f 91       	pop	r18
    2762:	0f 90       	pop	r0
    2764:	00 92 3b 00 	sts	0x003B, r0
    2768:	0f 90       	pop	r0
    276a:	0f be       	out	0x3f, r0	; 63
    276c:	0f 90       	pop	r0
    276e:	1f 90       	pop	r1
    2770:	18 95       	reti

00002772 <sampleCurrentChannel>:

//sample an axis of accelerometer with ADC
void sampleCurrentChannel() {
    2772:	cf 93       	push	r28
    2774:	df 93       	push	r29
    2776:	cd b7       	in	r28, 0x3d	; 61
    2778:	de b7       	in	r29, 0x3e	; 62
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
    277a:	80 ea       	ldi	r24, 0xA0	; 160
    277c:	96 e0       	ldi	r25, 0x06	; 6
    277e:	22 e0       	ldi	r18, 0x02	; 2
    2780:	fc 01       	movw	r30, r24
    2782:	26 83       	std	Z+6, r18	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    2784:	80 ec       	ldi	r24, 0xC0	; 192
    2786:	98 e0       	ldi	r25, 0x08	; 8
    2788:	2a ea       	ldi	r18, 0xAA	; 170
    278a:	fc 01       	movw	r30, r24
    278c:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    278e:	00 00       	nop
    2790:	80 ec       	ldi	r24, 0xC0	; 192
    2792:	98 e0       	ldi	r25, 0x08	; 8
    2794:	fc 01       	movw	r30, r24
    2796:	82 81       	ldd	r24, Z+2	; 0x02
    2798:	88 23       	and	r24, r24
    279a:	d4 f7       	brge	.-12     	; 0x2790 <sampleCurrentChannel+0x1e>
	SPIBuffer[SPICount] = SPIC.DATA;
    279c:	80 91 cf 50 	lds	r24, 0x50CF
    27a0:	88 2f       	mov	r24, r24
    27a2:	90 e0       	ldi	r25, 0x00	; 0
    27a4:	20 ec       	ldi	r18, 0xC0	; 192
    27a6:	38 e0       	ldi	r19, 0x08	; 8
    27a8:	f9 01       	movw	r30, r18
    27aa:	23 81       	ldd	r18, Z+3	; 0x03
    27ac:	8a 59       	subi	r24, 0x9A	; 154
    27ae:	9f 4a       	sbci	r25, 0xAF	; 175
    27b0:	fc 01       	movw	r30, r24
    27b2:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    27b4:	80 ec       	ldi	r24, 0xC0	; 192
    27b6:	98 e0       	ldi	r25, 0x08	; 8
    27b8:	2a ea       	ldi	r18, 0xAA	; 170
    27ba:	fc 01       	movw	r30, r24
    27bc:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    27be:	00 00       	nop
    27c0:	80 ec       	ldi	r24, 0xC0	; 192
    27c2:	98 e0       	ldi	r25, 0x08	; 8
    27c4:	fc 01       	movw	r30, r24
    27c6:	82 81       	ldd	r24, Z+2	; 0x02
    27c8:	88 23       	and	r24, r24
    27ca:	d4 f7       	brge	.-12     	; 0x27c0 <sampleCurrentChannel+0x4e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
    27cc:	80 91 cf 50 	lds	r24, 0x50CF
    27d0:	88 2f       	mov	r24, r24
    27d2:	90 e0       	ldi	r25, 0x00	; 0
    27d4:	01 96       	adiw	r24, 0x01	; 1
    27d6:	20 ec       	ldi	r18, 0xC0	; 192
    27d8:	38 e0       	ldi	r19, 0x08	; 8
    27da:	f9 01       	movw	r30, r18
    27dc:	23 81       	ldd	r18, Z+3	; 0x03
    27de:	8a 59       	subi	r24, 0x9A	; 154
    27e0:	9f 4a       	sbci	r25, 0xAF	; 175
    27e2:	fc 01       	movw	r30, r24
    27e4:	20 83       	st	Z, r18
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
    27e6:	80 ec       	ldi	r24, 0xC0	; 192
    27e8:	98 e0       	ldi	r25, 0x08	; 8
    27ea:	2a ea       	ldi	r18, 0xAA	; 170
    27ec:	fc 01       	movw	r30, r24
    27ee:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    27f0:	00 00       	nop
    27f2:	80 ec       	ldi	r24, 0xC0	; 192
    27f4:	98 e0       	ldi	r25, 0x08	; 8
    27f6:	fc 01       	movw	r30, r24
    27f8:	82 81       	ldd	r24, Z+2	; 0x02
    27fa:	88 23       	and	r24, r24
    27fc:	d4 f7       	brge	.-12     	; 0x27f2 <sampleCurrentChannel+0x80>
	SPIBuffer[SPICount+2] = SPIC.DATA;
    27fe:	80 91 cf 50 	lds	r24, 0x50CF
    2802:	88 2f       	mov	r24, r24
    2804:	90 e0       	ldi	r25, 0x00	; 0
    2806:	02 96       	adiw	r24, 0x02	; 2
    2808:	20 ec       	ldi	r18, 0xC0	; 192
    280a:	38 e0       	ldi	r19, 0x08	; 8
    280c:	f9 01       	movw	r30, r18
    280e:	23 81       	ldd	r18, Z+3	; 0x03
    2810:	8a 59       	subi	r24, 0x9A	; 154
    2812:	9f 4a       	sbci	r25, 0xAF	; 175
    2814:	fc 01       	movw	r30, r24
    2816:	20 83       	st	Z, r18
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
    2818:	80 ea       	ldi	r24, 0xA0	; 160
    281a:	96 e0       	ldi	r25, 0x06	; 6
    281c:	22 e0       	ldi	r18, 0x02	; 2
    281e:	fc 01       	movw	r30, r24
    2820:	25 83       	std	Z+5, r18	; 0x05
	SPICount +=3;
    2822:	80 91 cf 50 	lds	r24, 0x50CF
    2826:	8d 5f       	subi	r24, 0xFD	; 253
    2828:	80 93 cf 50 	sts	0x50CF, r24
}
    282c:	df 91       	pop	r29
    282e:	cf 91       	pop	r28
    2830:	08 95       	ret

00002832 <writeSE2FRAM>:

//write collected accelerometer samples to FRAM. OBSOLETE
void writeSE2FRAM() {
    2832:	cf 93       	push	r28
    2834:	df 93       	push	r29
    2836:	cd b7       	in	r28, 0x3d	; 61
    2838:	de b7       	in	r29, 0x3e	; 62
    283a:	29 97       	sbiw	r28, 0x09	; 9
    283c:	cd bf       	out	0x3d, r28	; 61
    283e:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    2840:	1a 82       	std	Y+2, r1	; 0x02
    2842:	1b 82       	std	Y+3, r1	; 0x03
    2844:	1c 82       	std	Y+4, r1	; 0x04
    2846:	1d 82       	std	Y+5, r1	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
    2848:	80 91 75 50 	lds	r24, 0x5075
    284c:	90 91 76 50 	lds	r25, 0x5076
    2850:	a0 91 77 50 	lds	r26, 0x5077
    2854:	b0 91 78 50 	lds	r27, 0x5078
    2858:	01 96       	adiw	r24, 0x01	; 1
    285a:	a1 1d       	adc	r26, r1
    285c:	b1 1d       	adc	r27, r1
    285e:	80 93 75 50 	sts	0x5075, r24
    2862:	90 93 76 50 	sts	0x5076, r25
    2866:	a0 93 77 50 	sts	0x5077, r26
    286a:	b0 93 78 50 	sts	0x5078, r27
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    286e:	80 ec       	ldi	r24, 0xC0	; 192
    2870:	98 e0       	ldi	r25, 0x08	; 8
    2872:	20 ed       	ldi	r18, 0xD0	; 208
    2874:	fc 01       	movw	r30, r24
    2876:	20 83       	st	Z, r18
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2878:	19 82       	std	Y+1, r1	; 0x01
    287a:	4f c0       	rjmp	.+158    	; 0x291a <writeSE2FRAM+0xe8>
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    287c:	89 81       	ldd	r24, Y+1	; 0x01
    287e:	88 2f       	mov	r24, r24
    2880:	90 e0       	ldi	r25, 0x00	; 0
    2882:	8a 59       	subi	r24, 0x9A	; 154
    2884:	9f 4a       	sbci	r25, 0xAF	; 175
    2886:	fc 01       	movw	r30, r24
    2888:	80 81       	ld	r24, Z
    288a:	88 23       	and	r24, r24
    288c:	3c f4       	brge	.+14     	; 0x289c <writeSE2FRAM+0x6a>
    288e:	ce 01       	movw	r24, r28
    2890:	06 96       	adiw	r24, 0x06	; 6
    2892:	03 96       	adiw	r24, 0x03	; 3
    2894:	2f ef       	ldi	r18, 0xFF	; 255
    2896:	fc 01       	movw	r30, r24
    2898:	20 83       	st	Z, r18
    289a:	05 c0       	rjmp	.+10     	; 0x28a6 <writeSE2FRAM+0x74>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    289c:	ce 01       	movw	r24, r28
    289e:	06 96       	adiw	r24, 0x06	; 6
    28a0:	03 96       	adiw	r24, 0x03	; 3
    28a2:	fc 01       	movw	r30, r24
    28a4:	10 82       	st	Z, r1
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    28a6:	ce 01       	movw	r24, r28
    28a8:	06 96       	adiw	r24, 0x06	; 6
    28aa:	02 96       	adiw	r24, 0x02	; 2
    28ac:	29 81       	ldd	r18, Y+1	; 0x01
    28ae:	22 2f       	mov	r18, r18
    28b0:	30 e0       	ldi	r19, 0x00	; 0
    28b2:	2a 59       	subi	r18, 0x9A	; 154
    28b4:	3f 4a       	sbci	r19, 0xAF	; 175
    28b6:	f9 01       	movw	r30, r18
    28b8:	20 81       	ld	r18, Z
    28ba:	fc 01       	movw	r30, r24
    28bc:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    28be:	ce 01       	movw	r24, r28
    28c0:	06 96       	adiw	r24, 0x06	; 6
    28c2:	01 96       	adiw	r24, 0x01	; 1
    28c4:	29 81       	ldd	r18, Y+1	; 0x01
    28c6:	22 2f       	mov	r18, r18
    28c8:	30 e0       	ldi	r19, 0x00	; 0
    28ca:	2f 5f       	subi	r18, 0xFF	; 255
    28cc:	3f 4f       	sbci	r19, 0xFF	; 255
    28ce:	2a 59       	subi	r18, 0x9A	; 154
    28d0:	3f 4a       	sbci	r19, 0xAF	; 175
    28d2:	f9 01       	movw	r30, r18
    28d4:	20 81       	ld	r18, Z
    28d6:	fc 01       	movw	r30, r24
    28d8:	20 83       	st	Z, r18
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    28da:	ce 01       	movw	r24, r28
    28dc:	06 96       	adiw	r24, 0x06	; 6
    28de:	29 81       	ldd	r18, Y+1	; 0x01
    28e0:	22 2f       	mov	r18, r18
    28e2:	30 e0       	ldi	r19, 0x00	; 0
    28e4:	2e 5f       	subi	r18, 0xFE	; 254
    28e6:	3f 4f       	sbci	r19, 0xFF	; 255
    28e8:	2a 59       	subi	r18, 0x9A	; 154
    28ea:	3f 4a       	sbci	r19, 0xAF	; 175
    28ec:	f9 01       	movw	r30, r18
    28ee:	20 81       	ld	r18, Z
    28f0:	fc 01       	movw	r30, r24
    28f2:	20 83       	st	Z, r18
		sum += currentSample;
    28f4:	2a 81       	ldd	r18, Y+2	; 0x02
    28f6:	3b 81       	ldd	r19, Y+3	; 0x03
    28f8:	4c 81       	ldd	r20, Y+4	; 0x04
    28fa:	5d 81       	ldd	r21, Y+5	; 0x05
    28fc:	8e 81       	ldd	r24, Y+6	; 0x06
    28fe:	9f 81       	ldd	r25, Y+7	; 0x07
    2900:	a8 85       	ldd	r26, Y+8	; 0x08
    2902:	b9 85       	ldd	r27, Y+9	; 0x09
    2904:	82 0f       	add	r24, r18
    2906:	93 1f       	adc	r25, r19
    2908:	a4 1f       	adc	r26, r20
    290a:	b5 1f       	adc	r27, r21
    290c:	8a 83       	std	Y+2, r24	; 0x02
    290e:	9b 83       	std	Y+3, r25	; 0x03
    2910:	ac 83       	std	Y+4, r26	; 0x04
    2912:	bd 83       	std	Y+5, r27	; 0x05
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    2914:	89 81       	ldd	r24, Y+1	; 0x01
    2916:	8d 5f       	subi	r24, 0xFD	; 253
    2918:	89 83       	std	Y+1, r24	; 0x01
    291a:	89 81       	ldd	r24, Y+1	; 0x01
    291c:	8c 30       	cpi	r24, 0x0C	; 12
    291e:	08 f4       	brcc	.+2      	; 0x2922 <writeSE2FRAM+0xf0>
    2920:	ad cf       	rjmp	.-166    	; 0x287c <writeSE2FRAM+0x4a>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    2922:	8a 81       	ldd	r24, Y+2	; 0x02
    2924:	9b 81       	ldd	r25, Y+3	; 0x03
    2926:	ac 81       	ldd	r26, Y+4	; 0x04
    2928:	bd 81       	ldd	r27, Y+5	; 0x05
    292a:	24 e0       	ldi	r18, 0x04	; 4
    292c:	30 e0       	ldi	r19, 0x00	; 0
    292e:	40 e0       	ldi	r20, 0x00	; 0
    2930:	50 e0       	ldi	r21, 0x00	; 0
    2932:	bc 01       	movw	r22, r24
    2934:	cd 01       	movw	r24, r26
    2936:	0e 94 fb 5b 	call	0xb7f6	; 0xb7f6 <__divmodsi4>
    293a:	da 01       	movw	r26, r20
    293c:	c9 01       	movw	r24, r18
    293e:	8a 83       	std	Y+2, r24	; 0x02
    2940:	9b 83       	std	Y+3, r25	; 0x03
    2942:	ac 83       	std	Y+4, r26	; 0x04
    2944:	bd 83       	std	Y+5, r27	; 0x05
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    2946:	ce 01       	movw	r24, r28
    2948:	02 96       	adiw	r24, 0x02	; 2
    294a:	fc 01       	movw	r30, r24
    294c:	80 81       	ld	r24, Z
    294e:	80 93 68 50 	sts	0x5068, r24
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    2952:	ce 01       	movw	r24, r28
    2954:	02 96       	adiw	r24, 0x02	; 2
    2956:	fc 01       	movw	r30, r24
    2958:	81 81       	ldd	r24, Z+1	; 0x01
    295a:	80 93 67 50 	sts	0x5067, r24
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    295e:	ce 01       	movw	r24, r28
    2960:	02 96       	adiw	r24, 0x02	; 2
    2962:	fc 01       	movw	r30, r24
    2964:	82 81       	ldd	r24, Z+2	; 0x02
    2966:	80 93 66 50 	sts	0x5066, r24


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    296a:	80 e4       	ldi	r24, 0x40	; 64
    296c:	96 e0       	ldi	r25, 0x06	; 6
    296e:	20 e1       	ldi	r18, 0x10	; 16
    2970:	fc 01       	movw	r30, r24
    2972:	26 83       	std	Z+6, r18	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    2974:	80 e2       	ldi	r24, 0x20	; 32
    2976:	96 e0       	ldi	r25, 0x06	; 6
    2978:	28 e0       	ldi	r18, 0x08	; 8
    297a:	fc 01       	movw	r30, r24
    297c:	26 83       	std	Z+6, r18	; 0x06
	nop();
    297e:	00 00       	nop
	SPIC.DATA = FR_WREN;
    2980:	80 ec       	ldi	r24, 0xC0	; 192
    2982:	98 e0       	ldi	r25, 0x08	; 8
    2984:	26 e0       	ldi	r18, 0x06	; 6
    2986:	fc 01       	movw	r30, r24
    2988:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    298a:	00 00       	nop
    298c:	80 ec       	ldi	r24, 0xC0	; 192
    298e:	98 e0       	ldi	r25, 0x08	; 8
    2990:	fc 01       	movw	r30, r24
    2992:	82 81       	ldd	r24, Z+2	; 0x02
    2994:	88 23       	and	r24, r24
    2996:	d4 f7       	brge	.-12     	; 0x298c <writeSE2FRAM+0x15a>
	SPIBuffer[12] = SPIC.DATA;
    2998:	80 ec       	ldi	r24, 0xC0	; 192
    299a:	98 e0       	ldi	r25, 0x08	; 8
    299c:	fc 01       	movw	r30, r24
    299e:	83 81       	ldd	r24, Z+3	; 0x03
    29a0:	80 93 72 50 	sts	0x5072, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    29a4:	80 e2       	ldi	r24, 0x20	; 32
    29a6:	96 e0       	ldi	r25, 0x06	; 6
    29a8:	28 e0       	ldi	r18, 0x08	; 8
    29aa:	fc 01       	movw	r30, r24
    29ac:	25 83       	std	Z+5, r18	; 0x05
	nop(); // time for CS_FRAM to accept high signal
    29ae:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    29b0:	80 e2       	ldi	r24, 0x20	; 32
    29b2:	96 e0       	ldi	r25, 0x06	; 6
    29b4:	28 e0       	ldi	r18, 0x08	; 8
    29b6:	fc 01       	movw	r30, r24
    29b8:	26 83       	std	Z+6, r18	; 0x06
	nop();
    29ba:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    29bc:	80 ec       	ldi	r24, 0xC0	; 192
    29be:	98 e0       	ldi	r25, 0x08	; 8
    29c0:	22 e0       	ldi	r18, 0x02	; 2
    29c2:	fc 01       	movw	r30, r24
    29c4:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    29c6:	00 00       	nop
    29c8:	80 ec       	ldi	r24, 0xC0	; 192
    29ca:	98 e0       	ldi	r25, 0x08	; 8
    29cc:	fc 01       	movw	r30, r24
    29ce:	82 81       	ldd	r24, Z+2	; 0x02
    29d0:	88 23       	and	r24, r24
    29d2:	d4 f7       	brge	.-12     	; 0x29c8 <writeSE2FRAM+0x196>
	SPIBuffer[12] = SPIC.DATA;
    29d4:	80 ec       	ldi	r24, 0xC0	; 192
    29d6:	98 e0       	ldi	r25, 0x08	; 8
    29d8:	fc 01       	movw	r30, r24
    29da:	83 81       	ldd	r24, Z+3	; 0x03
    29dc:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    29e0:	80 ec       	ldi	r24, 0xC0	; 192
    29e2:	98 e0       	ldi	r25, 0x08	; 8
    29e4:	20 91 51 40 	lds	r18, 0x4051
    29e8:	fc 01       	movw	r30, r24
    29ea:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    29ec:	00 00       	nop
    29ee:	80 ec       	ldi	r24, 0xC0	; 192
    29f0:	98 e0       	ldi	r25, 0x08	; 8
    29f2:	fc 01       	movw	r30, r24
    29f4:	82 81       	ldd	r24, Z+2	; 0x02
    29f6:	88 23       	and	r24, r24
    29f8:	d4 f7       	brge	.-12     	; 0x29ee <writeSE2FRAM+0x1bc>
	SPIBuffer[12] = SPIC.DATA;
    29fa:	80 ec       	ldi	r24, 0xC0	; 192
    29fc:	98 e0       	ldi	r25, 0x08	; 8
    29fe:	fc 01       	movw	r30, r24
    2a00:	83 81       	ldd	r24, Z+3	; 0x03
    2a02:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    2a06:	80 ec       	ldi	r24, 0xC0	; 192
    2a08:	98 e0       	ldi	r25, 0x08	; 8
    2a0a:	20 e5       	ldi	r18, 0x50	; 80
    2a0c:	30 e4       	ldi	r19, 0x40	; 64
    2a0e:	f9 01       	movw	r30, r18
    2a10:	20 81       	ld	r18, Z
    2a12:	fc 01       	movw	r30, r24
    2a14:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a16:	00 00       	nop
    2a18:	80 ec       	ldi	r24, 0xC0	; 192
    2a1a:	98 e0       	ldi	r25, 0x08	; 8
    2a1c:	fc 01       	movw	r30, r24
    2a1e:	82 81       	ldd	r24, Z+2	; 0x02
    2a20:	88 23       	and	r24, r24
    2a22:	d4 f7       	brge	.-12     	; 0x2a18 <writeSE2FRAM+0x1e6>
	SPIBuffer[12] = SPIC.DATA;
    2a24:	80 ec       	ldi	r24, 0xC0	; 192
    2a26:	98 e0       	ldi	r25, 0x08	; 8
    2a28:	fc 01       	movw	r30, r24
    2a2a:	83 81       	ldd	r24, Z+3	; 0x03
    2a2c:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = SPIBuffer[0];
    2a30:	80 ec       	ldi	r24, 0xC0	; 192
    2a32:	98 e0       	ldi	r25, 0x08	; 8
    2a34:	20 91 66 50 	lds	r18, 0x5066
    2a38:	fc 01       	movw	r30, r24
    2a3a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a3c:	00 00       	nop
    2a3e:	80 ec       	ldi	r24, 0xC0	; 192
    2a40:	98 e0       	ldi	r25, 0x08	; 8
    2a42:	fc 01       	movw	r30, r24
    2a44:	82 81       	ldd	r24, Z+2	; 0x02
    2a46:	88 23       	and	r24, r24
    2a48:	d4 f7       	brge	.-12     	; 0x2a3e <writeSE2FRAM+0x20c>
	SPIBuffer[12] = SPIC.DATA;
    2a4a:	80 ec       	ldi	r24, 0xC0	; 192
    2a4c:	98 e0       	ldi	r25, 0x08	; 8
    2a4e:	fc 01       	movw	r30, r24
    2a50:	83 81       	ldd	r24, Z+3	; 0x03
    2a52:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = SPIBuffer[1];
    2a56:	80 ec       	ldi	r24, 0xC0	; 192
    2a58:	98 e0       	ldi	r25, 0x08	; 8
    2a5a:	20 91 67 50 	lds	r18, 0x5067
    2a5e:	fc 01       	movw	r30, r24
    2a60:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a62:	00 00       	nop
    2a64:	80 ec       	ldi	r24, 0xC0	; 192
    2a66:	98 e0       	ldi	r25, 0x08	; 8
    2a68:	fc 01       	movw	r30, r24
    2a6a:	82 81       	ldd	r24, Z+2	; 0x02
    2a6c:	88 23       	and	r24, r24
    2a6e:	d4 f7       	brge	.-12     	; 0x2a64 <writeSE2FRAM+0x232>
	SPIBuffer[12] = SPIC.DATA;
    2a70:	80 ec       	ldi	r24, 0xC0	; 192
    2a72:	98 e0       	ldi	r25, 0x08	; 8
    2a74:	fc 01       	movw	r30, r24
    2a76:	83 81       	ldd	r24, Z+3	; 0x03
    2a78:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = SPIBuffer[2];
    2a7c:	80 ec       	ldi	r24, 0xC0	; 192
    2a7e:	98 e0       	ldi	r25, 0x08	; 8
    2a80:	20 91 68 50 	lds	r18, 0x5068
    2a84:	fc 01       	movw	r30, r24
    2a86:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    2a88:	00 00       	nop
    2a8a:	80 ec       	ldi	r24, 0xC0	; 192
    2a8c:	98 e0       	ldi	r25, 0x08	; 8
    2a8e:	fc 01       	movw	r30, r24
    2a90:	82 81       	ldd	r24, Z+2	; 0x02
    2a92:	88 23       	and	r24, r24
    2a94:	d4 f7       	brge	.-12     	; 0x2a8a <writeSE2FRAM+0x258>
	SPIBuffer[12] = SPIC.DATA;
    2a96:	80 ec       	ldi	r24, 0xC0	; 192
    2a98:	98 e0       	ldi	r25, 0x08	; 8
    2a9a:	fc 01       	movw	r30, r24
    2a9c:	83 81       	ldd	r24, Z+3	; 0x03
    2a9e:	80 93 72 50 	sts	0x5072, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    2aa2:	80 e2       	ldi	r24, 0x20	; 32
    2aa4:	96 e0       	ldi	r25, 0x06	; 6
    2aa6:	28 e0       	ldi	r18, 0x08	; 8
    2aa8:	fc 01       	movw	r30, r24
    2aaa:	25 83       	std	Z+5, r18	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    2aac:	80 e4       	ldi	r24, 0x40	; 64
    2aae:	96 e0       	ldi	r25, 0x06	; 6
    2ab0:	20 e1       	ldi	r18, 0x10	; 16
    2ab2:	fc 01       	movw	r30, r24
    2ab4:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    2ab6:	80 ec       	ldi	r24, 0xC0	; 192
    2ab8:	98 e0       	ldi	r25, 0x08	; 8
    2aba:	24 e5       	ldi	r18, 0x54	; 84
    2abc:	fc 01       	movw	r30, r24
    2abe:	20 83       	st	Z, r18
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    2ac0:	80 e4       	ldi	r24, 0x40	; 64
    2ac2:	96 e0       	ldi	r25, 0x06	; 6
    2ac4:	20 e1       	ldi	r18, 0x10	; 16
    2ac6:	fc 01       	movw	r30, r24
    2ac8:	26 83       	std	Z+6, r18	; 0x06
	
	FRAMAddress +=3;
    2aca:	80 91 50 40 	lds	r24, 0x4050
    2ace:	90 91 51 40 	lds	r25, 0x4051
    2ad2:	03 96       	adiw	r24, 0x03	; 3
    2ad4:	80 93 50 40 	sts	0x4050, r24
    2ad8:	90 93 51 40 	sts	0x4051, r25
	checksumADC[0] += SPIBuffer[0];
    2adc:	90 91 32 21 	lds	r25, 0x2132
    2ae0:	80 91 66 50 	lds	r24, 0x5066
    2ae4:	89 0f       	add	r24, r25
    2ae6:	80 93 32 21 	sts	0x2132, r24
	checksumADC[1] += SPIBuffer[1];
    2aea:	90 91 33 21 	lds	r25, 0x2133
    2aee:	80 91 67 50 	lds	r24, 0x5067
    2af2:	89 0f       	add	r24, r25
    2af4:	80 93 33 21 	sts	0x2133, r24
	checksumADC[2] += SPIBuffer[2];
    2af8:	90 91 34 21 	lds	r25, 0x2134
    2afc:	80 91 68 50 	lds	r24, 0x5068
    2b00:	89 0f       	add	r24, r25
    2b02:	80 93 34 21 	sts	0x2134, r24
}
    2b06:	29 96       	adiw	r28, 0x09	; 9
    2b08:	cd bf       	out	0x3d, r28	; 61
    2b0a:	de bf       	out	0x3e, r29	; 62
    2b0c:	df 91       	pop	r29
    2b0e:	cf 91       	pop	r28
    2b10:	08 95       	ret

00002b12 <calcChecksumFRAM>:

//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
    2b12:	2f 92       	push	r2
    2b14:	3f 92       	push	r3
    2b16:	4f 92       	push	r4
    2b18:	5f 92       	push	r5
    2b1a:	6f 92       	push	r6
    2b1c:	7f 92       	push	r7
    2b1e:	8f 92       	push	r8
    2b20:	9f 92       	push	r9
    2b22:	af 92       	push	r10
    2b24:	bf 92       	push	r11
    2b26:	cf 92       	push	r12
    2b28:	df 92       	push	r13
    2b2a:	ef 92       	push	r14
    2b2c:	ff 92       	push	r15
    2b2e:	0f 93       	push	r16
    2b30:	1f 93       	push	r17
    2b32:	cf 93       	push	r28
    2b34:	df 93       	push	r29
    2b36:	00 d0       	rcall	.+0      	; 0x2b38 <calcChecksumFRAM+0x26>
    2b38:	0f 92       	push	r0
    2b3a:	cd b7       	in	r28, 0x3d	; 61
    2b3c:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    2b3e:	aa 24       	eor	r10, r10
    2b40:	bb 24       	eor	r11, r11
    2b42:	cc 24       	eor	r12, r12
    2b44:	dd 24       	eor	r13, r13
    2b46:	ee 24       	eor	r14, r14
    2b48:	ff 24       	eor	r15, r15
    2b4a:	00 e0       	ldi	r16, 0x00	; 0
    2b4c:	10 e0       	ldi	r17, 0x00	; 0
    2b4e:	a0 92 9c 50 	sts	0x509C, r10
    2b52:	b0 92 9d 50 	sts	0x509D, r11
    2b56:	c0 92 9e 50 	sts	0x509E, r12
    2b5a:	d0 92 9f 50 	sts	0x509F, r13
    2b5e:	e0 92 a0 50 	sts	0x50A0, r14
    2b62:	f0 92 a1 50 	sts	0x50A1, r15
    2b66:	00 93 a2 50 	sts	0x50A2, r16
    2b6a:	10 93 a3 50 	sts	0x50A3, r17
    2b6e:	2a 2d       	mov	r18, r10
    2b70:	3b 2d       	mov	r19, r11
    2b72:	4c 2d       	mov	r20, r12
    2b74:	5d 2d       	mov	r21, r13
    2b76:	6e 2d       	mov	r22, r14
    2b78:	7f 2d       	mov	r23, r15
    2b7a:	80 2f       	mov	r24, r16
    2b7c:	91 2f       	mov	r25, r17
    2b7e:	20 93 94 50 	sts	0x5094, r18
    2b82:	30 93 95 50 	sts	0x5095, r19
    2b86:	40 93 96 50 	sts	0x5096, r20
    2b8a:	50 93 97 50 	sts	0x5097, r21
    2b8e:	60 93 98 50 	sts	0x5098, r22
    2b92:	70 93 99 50 	sts	0x5099, r23
    2b96:	80 93 9a 50 	sts	0x509A, r24
    2b9a:	90 93 9b 50 	sts	0x509B, r25
    2b9e:	20 93 8c 50 	sts	0x508C, r18
    2ba2:	30 93 8d 50 	sts	0x508D, r19
    2ba6:	40 93 8e 50 	sts	0x508E, r20
    2baa:	50 93 8f 50 	sts	0x508F, r21
    2bae:	60 93 90 50 	sts	0x5090, r22
    2bb2:	70 93 91 50 	sts	0x5091, r23
    2bb6:	80 93 92 50 	sts	0x5092, r24
    2bba:	90 93 93 50 	sts	0x5093, r25
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    2bbe:	80 e0       	ldi	r24, 0x00	; 0
    2bc0:	80 93 37 21 	sts	0x2137, r24
    2bc4:	80 93 36 21 	sts	0x2136, r24
    2bc8:	80 93 35 21 	sts	0x2135, r24
	FRAMAddress = FR_BASEADD;
    2bcc:	10 92 50 40 	sts	0x4050, r1
    2bd0:	10 92 51 40 	sts	0x4051, r1
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    2bd4:	19 82       	std	Y+1, r1	; 0x01
    2bd6:	1a 82       	std	Y+2, r1	; 0x02
    2bd8:	88 c2       	rjmp	.+1296   	; 0x30ea <calcChecksumFRAM+0x5d8>
		readFRAM(FR_READ_BUFFER_SIZE);
    2bda:	81 e7       	ldi	r24, 0x71	; 113
    2bdc:	9c e1       	ldi	r25, 0x1C	; 28
    2bde:	0e 94 9a 37 	call	0x6f34	; 0x6f34 <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    2be2:	80 91 50 40 	lds	r24, 0x4050
    2be6:	90 91 51 40 	lds	r25, 0x4051
    2bea:	8f 58       	subi	r24, 0x8F	; 143
    2bec:	93 4e       	sbci	r25, 0xE3	; 227
    2bee:	80 93 50 40 	sts	0x4050, r24
    2bf2:	90 93 51 40 	sts	0x4051, r25
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    2bf6:	1b 82       	std	Y+3, r1	; 0x03
    2bf8:	1c 82       	std	Y+4, r1	; 0x04
    2bfa:	6b c2       	rjmp	.+1238   	; 0x30d2 <calcChecksumFRAM+0x5c0>
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    2bfc:	8b 81       	ldd	r24, Y+3	; 0x03
    2bfe:	9c 81       	ldd	r25, Y+4	; 0x04
    2c00:	23 e0       	ldi	r18, 0x03	; 3
    2c02:	30 e0       	ldi	r19, 0x00	; 0
    2c04:	b9 01       	movw	r22, r18
    2c06:	0e 94 b2 5b 	call	0xb764	; 0xb764 <__udivmodhi4>
    2c0a:	9c 01       	movw	r18, r24
    2c0c:	2b 5c       	subi	r18, 0xCB	; 203
    2c0e:	3e 4d       	sbci	r19, 0xDE	; 222
    2c10:	f9 01       	movw	r30, r18
    2c12:	40 81       	ld	r20, Z
    2c14:	2b 81       	ldd	r18, Y+3	; 0x03
    2c16:	3c 81       	ldd	r19, Y+4	; 0x04
    2c18:	28 52       	subi	r18, 0x28	; 40
    2c1a:	3c 4d       	sbci	r19, 0xDC	; 220
    2c1c:	f9 01       	movw	r30, r18
    2c1e:	20 81       	ld	r18, Z
    2c20:	24 0f       	add	r18, r20
    2c22:	8b 5c       	subi	r24, 0xCB	; 203
    2c24:	9e 4d       	sbci	r25, 0xDE	; 222
    2c26:	fc 01       	movw	r30, r24
    2c28:	20 83       	st	Z, r18
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    2c2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c2e:	23 e0       	ldi	r18, 0x03	; 3
    2c30:	30 e0       	ldi	r19, 0x00	; 0
    2c32:	b9 01       	movw	r22, r18
    2c34:	0e 94 b2 5b 	call	0xb764	; 0xb764 <__udivmodhi4>
    2c38:	00 97       	sbiw	r24, 0x00	; 0
    2c3a:	09 f0       	breq	.+2      	; 0x2c3e <calcChecksumFRAM+0x12c>
    2c3c:	44 c0       	rjmp	.+136    	; 0x2cc6 <calcChecksumFRAM+0x1b4>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    2c3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c40:	9c 81       	ldd	r25, Y+4	; 0x04
    2c42:	88 52       	subi	r24, 0x28	; 40
    2c44:	9c 4d       	sbci	r25, 0xDC	; 220
    2c46:	fc 01       	movw	r30, r24
    2c48:	80 81       	ld	r24, Z
    2c4a:	88 23       	and	r24, r24
    2c4c:	d4 f4       	brge	.+52     	; 0x2c82 <calcChecksumFRAM+0x170>
    2c4e:	80 91 64 50 	lds	r24, 0x5064
    2c52:	90 91 65 50 	lds	r25, 0x5065
    2c56:	fc 01       	movw	r30, r24
    2c58:	10 82       	st	Z, r1
    2c5a:	fc 01       	movw	r30, r24
    2c5c:	11 82       	std	Z+1, r1	; 0x01
    2c5e:	fc 01       	movw	r30, r24
    2c60:	12 82       	std	Z+2, r1	; 0x02
    2c62:	2f ef       	ldi	r18, 0xFF	; 255
    2c64:	fc 01       	movw	r30, r24
    2c66:	23 83       	std	Z+3, r18	; 0x03
    2c68:	2f ef       	ldi	r18, 0xFF	; 255
    2c6a:	fc 01       	movw	r30, r24
    2c6c:	24 83       	std	Z+4, r18	; 0x04
    2c6e:	2f ef       	ldi	r18, 0xFF	; 255
    2c70:	fc 01       	movw	r30, r24
    2c72:	25 83       	std	Z+5, r18	; 0x05
    2c74:	2f ef       	ldi	r18, 0xFF	; 255
    2c76:	fc 01       	movw	r30, r24
    2c78:	26 83       	std	Z+6, r18	; 0x06
    2c7a:	2f ef       	ldi	r18, 0xFF	; 255
    2c7c:	fc 01       	movw	r30, r24
    2c7e:	27 83       	std	Z+7, r18	; 0x07
    2c80:	14 c0       	rjmp	.+40     	; 0x2caa <calcChecksumFRAM+0x198>
				else *temp64 = 0x0000000000000000;
    2c82:	80 91 64 50 	lds	r24, 0x5064
    2c86:	90 91 65 50 	lds	r25, 0x5065
    2c8a:	fc 01       	movw	r30, r24
    2c8c:	10 82       	st	Z, r1
    2c8e:	fc 01       	movw	r30, r24
    2c90:	11 82       	std	Z+1, r1	; 0x01
    2c92:	fc 01       	movw	r30, r24
    2c94:	12 82       	std	Z+2, r1	; 0x02
    2c96:	fc 01       	movw	r30, r24
    2c98:	13 82       	std	Z+3, r1	; 0x03
    2c9a:	fc 01       	movw	r30, r24
    2c9c:	14 82       	std	Z+4, r1	; 0x04
    2c9e:	fc 01       	movw	r30, r24
    2ca0:	15 82       	std	Z+5, r1	; 0x05
    2ca2:	fc 01       	movw	r30, r24
    2ca4:	16 82       	std	Z+6, r1	; 0x06
    2ca6:	fc 01       	movw	r30, r24
    2ca8:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    2caa:	80 91 64 50 	lds	r24, 0x5064
    2cae:	90 91 65 50 	lds	r25, 0x5065
    2cb2:	02 96       	adiw	r24, 0x02	; 2
    2cb4:	2b 81       	ldd	r18, Y+3	; 0x03
    2cb6:	3c 81       	ldd	r19, Y+4	; 0x04
    2cb8:	28 52       	subi	r18, 0x28	; 40
    2cba:	3c 4d       	sbci	r19, 0xDC	; 220
    2cbc:	f9 01       	movw	r30, r18
    2cbe:	20 81       	ld	r18, Z
    2cc0:	fc 01       	movw	r30, r24
    2cc2:	20 83       	st	Z, r18
    2cc4:	24 c0       	rjmp	.+72     	; 0x2d0e <calcChecksumFRAM+0x1fc>
			} else if(k%3 == 1) {
    2cc6:	8b 81       	ldd	r24, Y+3	; 0x03
    2cc8:	9c 81       	ldd	r25, Y+4	; 0x04
    2cca:	23 e0       	ldi	r18, 0x03	; 3
    2ccc:	30 e0       	ldi	r19, 0x00	; 0
    2cce:	b9 01       	movw	r22, r18
    2cd0:	0e 94 b2 5b 	call	0xb764	; 0xb764 <__udivmodhi4>
    2cd4:	81 30       	cpi	r24, 0x01	; 1
    2cd6:	91 05       	cpc	r25, r1
    2cd8:	71 f4       	brne	.+28     	; 0x2cf6 <calcChecksumFRAM+0x1e4>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    2cda:	80 91 64 50 	lds	r24, 0x5064
    2cde:	90 91 65 50 	lds	r25, 0x5065
    2ce2:	01 96       	adiw	r24, 0x01	; 1
    2ce4:	2b 81       	ldd	r18, Y+3	; 0x03
    2ce6:	3c 81       	ldd	r19, Y+4	; 0x04
    2ce8:	28 52       	subi	r18, 0x28	; 40
    2cea:	3c 4d       	sbci	r19, 0xDC	; 220
    2cec:	f9 01       	movw	r30, r18
    2cee:	20 81       	ld	r18, Z
    2cf0:	fc 01       	movw	r30, r24
    2cf2:	20 83       	st	Z, r18
    2cf4:	0c c0       	rjmp	.+24     	; 0x2d0e <calcChecksumFRAM+0x1fc>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    2cf6:	80 91 64 50 	lds	r24, 0x5064
    2cfa:	90 91 65 50 	lds	r25, 0x5065
    2cfe:	2b 81       	ldd	r18, Y+3	; 0x03
    2d00:	3c 81       	ldd	r19, Y+4	; 0x04
    2d02:	28 52       	subi	r18, 0x28	; 40
    2d04:	3c 4d       	sbci	r19, 0xDC	; 220
    2d06:	f9 01       	movw	r30, r18
    2d08:	20 81       	ld	r18, Z
    2d0a:	fc 01       	movw	r30, r24
    2d0c:	20 83       	st	Z, r18
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    2d0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d10:	9c 81       	ldd	r25, Y+4	; 0x04
    2d12:	29 e0       	ldi	r18, 0x09	; 9
    2d14:	30 e0       	ldi	r19, 0x00	; 0
    2d16:	b9 01       	movw	r22, r18
    2d18:	0e 94 b2 5b 	call	0xb764	; 0xb764 <__udivmodhi4>
    2d1c:	82 30       	cpi	r24, 0x02	; 2
    2d1e:	91 05       	cpc	r25, r1
    2d20:	09 f0       	breq	.+2      	; 0x2d24 <calcChecksumFRAM+0x212>
    2d22:	94 c0       	rjmp	.+296    	; 0x2e4c <calcChecksumFRAM+0x33a>
    2d24:	a0 90 8c 50 	lds	r10, 0x508C
    2d28:	b0 90 8d 50 	lds	r11, 0x508D
    2d2c:	c0 90 8e 50 	lds	r12, 0x508E
    2d30:	d0 90 8f 50 	lds	r13, 0x508F
    2d34:	e0 90 90 50 	lds	r14, 0x5090
    2d38:	f0 90 91 50 	lds	r15, 0x5091
    2d3c:	00 91 92 50 	lds	r16, 0x5092
    2d40:	10 91 93 50 	lds	r17, 0x5093
    2d44:	80 91 64 50 	lds	r24, 0x5064
    2d48:	90 91 65 50 	lds	r25, 0x5065
    2d4c:	fc 01       	movw	r30, r24
    2d4e:	20 80       	ld	r2, Z
    2d50:	fc 01       	movw	r30, r24
    2d52:	31 80       	ldd	r3, Z+1	; 0x01
    2d54:	fc 01       	movw	r30, r24
    2d56:	42 80       	ldd	r4, Z+2	; 0x02
    2d58:	fc 01       	movw	r30, r24
    2d5a:	53 80       	ldd	r5, Z+3	; 0x03
    2d5c:	fc 01       	movw	r30, r24
    2d5e:	64 80       	ldd	r6, Z+4	; 0x04
    2d60:	fc 01       	movw	r30, r24
    2d62:	75 80       	ldd	r7, Z+5	; 0x05
    2d64:	fc 01       	movw	r30, r24
    2d66:	86 80       	ldd	r8, Z+6	; 0x06
    2d68:	fc 01       	movw	r30, r24
    2d6a:	97 80       	ldd	r9, Z+7	; 0x07
    2d6c:	2a 2d       	mov	r18, r10
    2d6e:	22 0d       	add	r18, r2
    2d70:	e1 e0       	ldi	r30, 0x01	; 1
    2d72:	2a 15       	cp	r18, r10
    2d74:	08 f0       	brcs	.+2      	; 0x2d78 <calcChecksumFRAM+0x266>
    2d76:	e0 e0       	ldi	r30, 0x00	; 0
    2d78:	3b 2d       	mov	r19, r11
    2d7a:	33 0d       	add	r19, r3
    2d7c:	f1 e0       	ldi	r31, 0x01	; 1
    2d7e:	3b 15       	cp	r19, r11
    2d80:	08 f0       	brcs	.+2      	; 0x2d84 <calcChecksumFRAM+0x272>
    2d82:	f0 e0       	ldi	r31, 0x00	; 0
    2d84:	e3 0f       	add	r30, r19
    2d86:	a1 e0       	ldi	r26, 0x01	; 1
    2d88:	e3 17       	cp	r30, r19
    2d8a:	08 f0       	brcs	.+2      	; 0x2d8e <calcChecksumFRAM+0x27c>
    2d8c:	a0 e0       	ldi	r26, 0x00	; 0
    2d8e:	fa 2b       	or	r31, r26
    2d90:	3e 2f       	mov	r19, r30
    2d92:	4c 2d       	mov	r20, r12
    2d94:	44 0d       	add	r20, r4
    2d96:	e1 e0       	ldi	r30, 0x01	; 1
    2d98:	4c 15       	cp	r20, r12
    2d9a:	08 f0       	brcs	.+2      	; 0x2d9e <calcChecksumFRAM+0x28c>
    2d9c:	e0 e0       	ldi	r30, 0x00	; 0
    2d9e:	f4 0f       	add	r31, r20
    2da0:	a1 e0       	ldi	r26, 0x01	; 1
    2da2:	f4 17       	cp	r31, r20
    2da4:	08 f0       	brcs	.+2      	; 0x2da8 <calcChecksumFRAM+0x296>
    2da6:	a0 e0       	ldi	r26, 0x00	; 0
    2da8:	ea 2b       	or	r30, r26
    2daa:	4f 2f       	mov	r20, r31
    2dac:	5d 2d       	mov	r21, r13
    2dae:	55 0d       	add	r21, r5
    2db0:	f1 e0       	ldi	r31, 0x01	; 1
    2db2:	5d 15       	cp	r21, r13
    2db4:	08 f0       	brcs	.+2      	; 0x2db8 <calcChecksumFRAM+0x2a6>
    2db6:	f0 e0       	ldi	r31, 0x00	; 0
    2db8:	e5 0f       	add	r30, r21
    2dba:	a1 e0       	ldi	r26, 0x01	; 1
    2dbc:	e5 17       	cp	r30, r21
    2dbe:	08 f0       	brcs	.+2      	; 0x2dc2 <calcChecksumFRAM+0x2b0>
    2dc0:	a0 e0       	ldi	r26, 0x00	; 0
    2dc2:	fa 2b       	or	r31, r26
    2dc4:	5e 2f       	mov	r21, r30
    2dc6:	6e 2d       	mov	r22, r14
    2dc8:	66 0d       	add	r22, r6
    2dca:	e1 e0       	ldi	r30, 0x01	; 1
    2dcc:	6e 15       	cp	r22, r14
    2dce:	08 f0       	brcs	.+2      	; 0x2dd2 <calcChecksumFRAM+0x2c0>
    2dd0:	e0 e0       	ldi	r30, 0x00	; 0
    2dd2:	f6 0f       	add	r31, r22
    2dd4:	a1 e0       	ldi	r26, 0x01	; 1
    2dd6:	f6 17       	cp	r31, r22
    2dd8:	08 f0       	brcs	.+2      	; 0x2ddc <calcChecksumFRAM+0x2ca>
    2dda:	a0 e0       	ldi	r26, 0x00	; 0
    2ddc:	ea 2b       	or	r30, r26
    2dde:	6f 2f       	mov	r22, r31
    2de0:	7f 2d       	mov	r23, r15
    2de2:	77 0d       	add	r23, r7
    2de4:	f1 e0       	ldi	r31, 0x01	; 1
    2de6:	7f 15       	cp	r23, r15
    2de8:	08 f0       	brcs	.+2      	; 0x2dec <calcChecksumFRAM+0x2da>
    2dea:	f0 e0       	ldi	r31, 0x00	; 0
    2dec:	e7 0f       	add	r30, r23
    2dee:	a1 e0       	ldi	r26, 0x01	; 1
    2df0:	e7 17       	cp	r30, r23
    2df2:	08 f0       	brcs	.+2      	; 0x2df6 <calcChecksumFRAM+0x2e4>
    2df4:	a0 e0       	ldi	r26, 0x00	; 0
    2df6:	fa 2b       	or	r31, r26
    2df8:	7e 2f       	mov	r23, r30
    2dfa:	80 2f       	mov	r24, r16
    2dfc:	88 0d       	add	r24, r8
    2dfe:	e1 e0       	ldi	r30, 0x01	; 1
    2e00:	80 17       	cp	r24, r16
    2e02:	08 f0       	brcs	.+2      	; 0x2e06 <calcChecksumFRAM+0x2f4>
    2e04:	e0 e0       	ldi	r30, 0x00	; 0
    2e06:	f8 0f       	add	r31, r24
    2e08:	a1 e0       	ldi	r26, 0x01	; 1
    2e0a:	f8 17       	cp	r31, r24
    2e0c:	08 f0       	brcs	.+2      	; 0x2e10 <calcChecksumFRAM+0x2fe>
    2e0e:	a0 e0       	ldi	r26, 0x00	; 0
    2e10:	ea 2b       	or	r30, r26
    2e12:	8f 2f       	mov	r24, r31
    2e14:	91 2f       	mov	r25, r17
    2e16:	99 0d       	add	r25, r9
    2e18:	e9 0f       	add	r30, r25
    2e1a:	9e 2f       	mov	r25, r30
    2e1c:	a2 2e       	mov	r10, r18
    2e1e:	b3 2e       	mov	r11, r19
    2e20:	c4 2e       	mov	r12, r20
    2e22:	d5 2e       	mov	r13, r21
    2e24:	e6 2e       	mov	r14, r22
    2e26:	f7 2e       	mov	r15, r23
    2e28:	08 2f       	mov	r16, r24
    2e2a:	19 2f       	mov	r17, r25
    2e2c:	a0 92 8c 50 	sts	0x508C, r10
    2e30:	b0 92 8d 50 	sts	0x508D, r11
    2e34:	c0 92 8e 50 	sts	0x508E, r12
    2e38:	d0 92 8f 50 	sts	0x508F, r13
    2e3c:	e0 92 90 50 	sts	0x5090, r14
    2e40:	f0 92 91 50 	sts	0x5091, r15
    2e44:	00 93 92 50 	sts	0x5092, r16
    2e48:	10 93 93 50 	sts	0x5093, r17
			if(k%9 == 5) sumFRAM[1] += *temp64;
    2e4c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e4e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e50:	29 e0       	ldi	r18, 0x09	; 9
    2e52:	30 e0       	ldi	r19, 0x00	; 0
    2e54:	b9 01       	movw	r22, r18
    2e56:	0e 94 b2 5b 	call	0xb764	; 0xb764 <__udivmodhi4>
    2e5a:	85 30       	cpi	r24, 0x05	; 5
    2e5c:	91 05       	cpc	r25, r1
    2e5e:	09 f0       	breq	.+2      	; 0x2e62 <calcChecksumFRAM+0x350>
    2e60:	94 c0       	rjmp	.+296    	; 0x2f8a <calcChecksumFRAM+0x478>
    2e62:	a0 90 94 50 	lds	r10, 0x5094
    2e66:	b0 90 95 50 	lds	r11, 0x5095
    2e6a:	c0 90 96 50 	lds	r12, 0x5096
    2e6e:	d0 90 97 50 	lds	r13, 0x5097
    2e72:	e0 90 98 50 	lds	r14, 0x5098
    2e76:	f0 90 99 50 	lds	r15, 0x5099
    2e7a:	00 91 9a 50 	lds	r16, 0x509A
    2e7e:	10 91 9b 50 	lds	r17, 0x509B
    2e82:	80 91 64 50 	lds	r24, 0x5064
    2e86:	90 91 65 50 	lds	r25, 0x5065
    2e8a:	fc 01       	movw	r30, r24
    2e8c:	20 80       	ld	r2, Z
    2e8e:	fc 01       	movw	r30, r24
    2e90:	31 80       	ldd	r3, Z+1	; 0x01
    2e92:	fc 01       	movw	r30, r24
    2e94:	42 80       	ldd	r4, Z+2	; 0x02
    2e96:	fc 01       	movw	r30, r24
    2e98:	53 80       	ldd	r5, Z+3	; 0x03
    2e9a:	fc 01       	movw	r30, r24
    2e9c:	64 80       	ldd	r6, Z+4	; 0x04
    2e9e:	fc 01       	movw	r30, r24
    2ea0:	75 80       	ldd	r7, Z+5	; 0x05
    2ea2:	fc 01       	movw	r30, r24
    2ea4:	86 80       	ldd	r8, Z+6	; 0x06
    2ea6:	fc 01       	movw	r30, r24
    2ea8:	97 80       	ldd	r9, Z+7	; 0x07
    2eaa:	2a 2d       	mov	r18, r10
    2eac:	22 0d       	add	r18, r2
    2eae:	e1 e0       	ldi	r30, 0x01	; 1
    2eb0:	2a 15       	cp	r18, r10
    2eb2:	08 f0       	brcs	.+2      	; 0x2eb6 <calcChecksumFRAM+0x3a4>
    2eb4:	e0 e0       	ldi	r30, 0x00	; 0
    2eb6:	3b 2d       	mov	r19, r11
    2eb8:	33 0d       	add	r19, r3
    2eba:	f1 e0       	ldi	r31, 0x01	; 1
    2ebc:	3b 15       	cp	r19, r11
    2ebe:	08 f0       	brcs	.+2      	; 0x2ec2 <calcChecksumFRAM+0x3b0>
    2ec0:	f0 e0       	ldi	r31, 0x00	; 0
    2ec2:	e3 0f       	add	r30, r19
    2ec4:	a1 e0       	ldi	r26, 0x01	; 1
    2ec6:	e3 17       	cp	r30, r19
    2ec8:	08 f0       	brcs	.+2      	; 0x2ecc <calcChecksumFRAM+0x3ba>
    2eca:	a0 e0       	ldi	r26, 0x00	; 0
    2ecc:	fa 2b       	or	r31, r26
    2ece:	3e 2f       	mov	r19, r30
    2ed0:	4c 2d       	mov	r20, r12
    2ed2:	44 0d       	add	r20, r4
    2ed4:	e1 e0       	ldi	r30, 0x01	; 1
    2ed6:	4c 15       	cp	r20, r12
    2ed8:	08 f0       	brcs	.+2      	; 0x2edc <calcChecksumFRAM+0x3ca>
    2eda:	e0 e0       	ldi	r30, 0x00	; 0
    2edc:	f4 0f       	add	r31, r20
    2ede:	a1 e0       	ldi	r26, 0x01	; 1
    2ee0:	f4 17       	cp	r31, r20
    2ee2:	08 f0       	brcs	.+2      	; 0x2ee6 <calcChecksumFRAM+0x3d4>
    2ee4:	a0 e0       	ldi	r26, 0x00	; 0
    2ee6:	ea 2b       	or	r30, r26
    2ee8:	4f 2f       	mov	r20, r31
    2eea:	5d 2d       	mov	r21, r13
    2eec:	55 0d       	add	r21, r5
    2eee:	f1 e0       	ldi	r31, 0x01	; 1
    2ef0:	5d 15       	cp	r21, r13
    2ef2:	08 f0       	brcs	.+2      	; 0x2ef6 <calcChecksumFRAM+0x3e4>
    2ef4:	f0 e0       	ldi	r31, 0x00	; 0
    2ef6:	e5 0f       	add	r30, r21
    2ef8:	a1 e0       	ldi	r26, 0x01	; 1
    2efa:	e5 17       	cp	r30, r21
    2efc:	08 f0       	brcs	.+2      	; 0x2f00 <calcChecksumFRAM+0x3ee>
    2efe:	a0 e0       	ldi	r26, 0x00	; 0
    2f00:	fa 2b       	or	r31, r26
    2f02:	5e 2f       	mov	r21, r30
    2f04:	6e 2d       	mov	r22, r14
    2f06:	66 0d       	add	r22, r6
    2f08:	e1 e0       	ldi	r30, 0x01	; 1
    2f0a:	6e 15       	cp	r22, r14
    2f0c:	08 f0       	brcs	.+2      	; 0x2f10 <calcChecksumFRAM+0x3fe>
    2f0e:	e0 e0       	ldi	r30, 0x00	; 0
    2f10:	f6 0f       	add	r31, r22
    2f12:	a1 e0       	ldi	r26, 0x01	; 1
    2f14:	f6 17       	cp	r31, r22
    2f16:	08 f0       	brcs	.+2      	; 0x2f1a <calcChecksumFRAM+0x408>
    2f18:	a0 e0       	ldi	r26, 0x00	; 0
    2f1a:	ea 2b       	or	r30, r26
    2f1c:	6f 2f       	mov	r22, r31
    2f1e:	7f 2d       	mov	r23, r15
    2f20:	77 0d       	add	r23, r7
    2f22:	f1 e0       	ldi	r31, 0x01	; 1
    2f24:	7f 15       	cp	r23, r15
    2f26:	08 f0       	brcs	.+2      	; 0x2f2a <calcChecksumFRAM+0x418>
    2f28:	f0 e0       	ldi	r31, 0x00	; 0
    2f2a:	e7 0f       	add	r30, r23
    2f2c:	a1 e0       	ldi	r26, 0x01	; 1
    2f2e:	e7 17       	cp	r30, r23
    2f30:	08 f0       	brcs	.+2      	; 0x2f34 <calcChecksumFRAM+0x422>
    2f32:	a0 e0       	ldi	r26, 0x00	; 0
    2f34:	fa 2b       	or	r31, r26
    2f36:	7e 2f       	mov	r23, r30
    2f38:	80 2f       	mov	r24, r16
    2f3a:	88 0d       	add	r24, r8
    2f3c:	e1 e0       	ldi	r30, 0x01	; 1
    2f3e:	80 17       	cp	r24, r16
    2f40:	08 f0       	brcs	.+2      	; 0x2f44 <calcChecksumFRAM+0x432>
    2f42:	e0 e0       	ldi	r30, 0x00	; 0
    2f44:	f8 0f       	add	r31, r24
    2f46:	a1 e0       	ldi	r26, 0x01	; 1
    2f48:	f8 17       	cp	r31, r24
    2f4a:	08 f0       	brcs	.+2      	; 0x2f4e <calcChecksumFRAM+0x43c>
    2f4c:	a0 e0       	ldi	r26, 0x00	; 0
    2f4e:	ea 2b       	or	r30, r26
    2f50:	8f 2f       	mov	r24, r31
    2f52:	91 2f       	mov	r25, r17
    2f54:	99 0d       	add	r25, r9
    2f56:	e9 0f       	add	r30, r25
    2f58:	9e 2f       	mov	r25, r30
    2f5a:	a2 2e       	mov	r10, r18
    2f5c:	b3 2e       	mov	r11, r19
    2f5e:	c4 2e       	mov	r12, r20
    2f60:	d5 2e       	mov	r13, r21
    2f62:	e6 2e       	mov	r14, r22
    2f64:	f7 2e       	mov	r15, r23
    2f66:	08 2f       	mov	r16, r24
    2f68:	19 2f       	mov	r17, r25
    2f6a:	a0 92 94 50 	sts	0x5094, r10
    2f6e:	b0 92 95 50 	sts	0x5095, r11
    2f72:	c0 92 96 50 	sts	0x5096, r12
    2f76:	d0 92 97 50 	sts	0x5097, r13
    2f7a:	e0 92 98 50 	sts	0x5098, r14
    2f7e:	f0 92 99 50 	sts	0x5099, r15
    2f82:	00 93 9a 50 	sts	0x509A, r16
    2f86:	10 93 9b 50 	sts	0x509B, r17
			if(k%9 == 8) sumFRAM[2] += *temp64;
    2f8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f8e:	29 e0       	ldi	r18, 0x09	; 9
    2f90:	30 e0       	ldi	r19, 0x00	; 0
    2f92:	b9 01       	movw	r22, r18
    2f94:	0e 94 b2 5b 	call	0xb764	; 0xb764 <__udivmodhi4>
    2f98:	88 30       	cpi	r24, 0x08	; 8
    2f9a:	91 05       	cpc	r25, r1
    2f9c:	09 f0       	breq	.+2      	; 0x2fa0 <calcChecksumFRAM+0x48e>
    2f9e:	94 c0       	rjmp	.+296    	; 0x30c8 <calcChecksumFRAM+0x5b6>
    2fa0:	a0 90 9c 50 	lds	r10, 0x509C
    2fa4:	b0 90 9d 50 	lds	r11, 0x509D
    2fa8:	c0 90 9e 50 	lds	r12, 0x509E
    2fac:	d0 90 9f 50 	lds	r13, 0x509F
    2fb0:	e0 90 a0 50 	lds	r14, 0x50A0
    2fb4:	f0 90 a1 50 	lds	r15, 0x50A1
    2fb8:	00 91 a2 50 	lds	r16, 0x50A2
    2fbc:	10 91 a3 50 	lds	r17, 0x50A3
    2fc0:	80 91 64 50 	lds	r24, 0x5064
    2fc4:	90 91 65 50 	lds	r25, 0x5065
    2fc8:	fc 01       	movw	r30, r24
    2fca:	20 80       	ld	r2, Z
    2fcc:	fc 01       	movw	r30, r24
    2fce:	31 80       	ldd	r3, Z+1	; 0x01
    2fd0:	fc 01       	movw	r30, r24
    2fd2:	42 80       	ldd	r4, Z+2	; 0x02
    2fd4:	fc 01       	movw	r30, r24
    2fd6:	53 80       	ldd	r5, Z+3	; 0x03
    2fd8:	fc 01       	movw	r30, r24
    2fda:	64 80       	ldd	r6, Z+4	; 0x04
    2fdc:	fc 01       	movw	r30, r24
    2fde:	75 80       	ldd	r7, Z+5	; 0x05
    2fe0:	fc 01       	movw	r30, r24
    2fe2:	86 80       	ldd	r8, Z+6	; 0x06
    2fe4:	fc 01       	movw	r30, r24
    2fe6:	97 80       	ldd	r9, Z+7	; 0x07
    2fe8:	2a 2d       	mov	r18, r10
    2fea:	22 0d       	add	r18, r2
    2fec:	e1 e0       	ldi	r30, 0x01	; 1
    2fee:	2a 15       	cp	r18, r10
    2ff0:	08 f0       	brcs	.+2      	; 0x2ff4 <calcChecksumFRAM+0x4e2>
    2ff2:	e0 e0       	ldi	r30, 0x00	; 0
    2ff4:	3b 2d       	mov	r19, r11
    2ff6:	33 0d       	add	r19, r3
    2ff8:	f1 e0       	ldi	r31, 0x01	; 1
    2ffa:	3b 15       	cp	r19, r11
    2ffc:	08 f0       	brcs	.+2      	; 0x3000 <calcChecksumFRAM+0x4ee>
    2ffe:	f0 e0       	ldi	r31, 0x00	; 0
    3000:	e3 0f       	add	r30, r19
    3002:	a1 e0       	ldi	r26, 0x01	; 1
    3004:	e3 17       	cp	r30, r19
    3006:	08 f0       	brcs	.+2      	; 0x300a <calcChecksumFRAM+0x4f8>
    3008:	a0 e0       	ldi	r26, 0x00	; 0
    300a:	fa 2b       	or	r31, r26
    300c:	3e 2f       	mov	r19, r30
    300e:	4c 2d       	mov	r20, r12
    3010:	44 0d       	add	r20, r4
    3012:	e1 e0       	ldi	r30, 0x01	; 1
    3014:	4c 15       	cp	r20, r12
    3016:	08 f0       	brcs	.+2      	; 0x301a <calcChecksumFRAM+0x508>
    3018:	e0 e0       	ldi	r30, 0x00	; 0
    301a:	f4 0f       	add	r31, r20
    301c:	a1 e0       	ldi	r26, 0x01	; 1
    301e:	f4 17       	cp	r31, r20
    3020:	08 f0       	brcs	.+2      	; 0x3024 <calcChecksumFRAM+0x512>
    3022:	a0 e0       	ldi	r26, 0x00	; 0
    3024:	ea 2b       	or	r30, r26
    3026:	4f 2f       	mov	r20, r31
    3028:	5d 2d       	mov	r21, r13
    302a:	55 0d       	add	r21, r5
    302c:	f1 e0       	ldi	r31, 0x01	; 1
    302e:	5d 15       	cp	r21, r13
    3030:	08 f0       	brcs	.+2      	; 0x3034 <calcChecksumFRAM+0x522>
    3032:	f0 e0       	ldi	r31, 0x00	; 0
    3034:	e5 0f       	add	r30, r21
    3036:	a1 e0       	ldi	r26, 0x01	; 1
    3038:	e5 17       	cp	r30, r21
    303a:	08 f0       	brcs	.+2      	; 0x303e <calcChecksumFRAM+0x52c>
    303c:	a0 e0       	ldi	r26, 0x00	; 0
    303e:	fa 2b       	or	r31, r26
    3040:	5e 2f       	mov	r21, r30
    3042:	6e 2d       	mov	r22, r14
    3044:	66 0d       	add	r22, r6
    3046:	e1 e0       	ldi	r30, 0x01	; 1
    3048:	6e 15       	cp	r22, r14
    304a:	08 f0       	brcs	.+2      	; 0x304e <calcChecksumFRAM+0x53c>
    304c:	e0 e0       	ldi	r30, 0x00	; 0
    304e:	f6 0f       	add	r31, r22
    3050:	a1 e0       	ldi	r26, 0x01	; 1
    3052:	f6 17       	cp	r31, r22
    3054:	08 f0       	brcs	.+2      	; 0x3058 <calcChecksumFRAM+0x546>
    3056:	a0 e0       	ldi	r26, 0x00	; 0
    3058:	ea 2b       	or	r30, r26
    305a:	6f 2f       	mov	r22, r31
    305c:	7f 2d       	mov	r23, r15
    305e:	77 0d       	add	r23, r7
    3060:	f1 e0       	ldi	r31, 0x01	; 1
    3062:	7f 15       	cp	r23, r15
    3064:	08 f0       	brcs	.+2      	; 0x3068 <calcChecksumFRAM+0x556>
    3066:	f0 e0       	ldi	r31, 0x00	; 0
    3068:	e7 0f       	add	r30, r23
    306a:	a1 e0       	ldi	r26, 0x01	; 1
    306c:	e7 17       	cp	r30, r23
    306e:	08 f0       	brcs	.+2      	; 0x3072 <calcChecksumFRAM+0x560>
    3070:	a0 e0       	ldi	r26, 0x00	; 0
    3072:	fa 2b       	or	r31, r26
    3074:	7e 2f       	mov	r23, r30
    3076:	80 2f       	mov	r24, r16
    3078:	88 0d       	add	r24, r8
    307a:	e1 e0       	ldi	r30, 0x01	; 1
    307c:	80 17       	cp	r24, r16
    307e:	08 f0       	brcs	.+2      	; 0x3082 <calcChecksumFRAM+0x570>
    3080:	e0 e0       	ldi	r30, 0x00	; 0
    3082:	f8 0f       	add	r31, r24
    3084:	a1 e0       	ldi	r26, 0x01	; 1
    3086:	f8 17       	cp	r31, r24
    3088:	08 f0       	brcs	.+2      	; 0x308c <calcChecksumFRAM+0x57a>
    308a:	a0 e0       	ldi	r26, 0x00	; 0
    308c:	ea 2b       	or	r30, r26
    308e:	8f 2f       	mov	r24, r31
    3090:	91 2f       	mov	r25, r17
    3092:	99 0d       	add	r25, r9
    3094:	e9 0f       	add	r30, r25
    3096:	9e 2f       	mov	r25, r30
    3098:	a2 2e       	mov	r10, r18
    309a:	b3 2e       	mov	r11, r19
    309c:	c4 2e       	mov	r12, r20
    309e:	d5 2e       	mov	r13, r21
    30a0:	e6 2e       	mov	r14, r22
    30a2:	f7 2e       	mov	r15, r23
    30a4:	08 2f       	mov	r16, r24
    30a6:	19 2f       	mov	r17, r25
    30a8:	a0 92 9c 50 	sts	0x509C, r10
    30ac:	b0 92 9d 50 	sts	0x509D, r11
    30b0:	c0 92 9e 50 	sts	0x509E, r12
    30b4:	d0 92 9f 50 	sts	0x509F, r13
    30b8:	e0 92 a0 50 	sts	0x50A0, r14
    30bc:	f0 92 a1 50 	sts	0x50A1, r15
    30c0:	00 93 a2 50 	sts	0x50A2, r16
    30c4:	10 93 a3 50 	sts	0x50A3, r17
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    30c8:	8b 81       	ldd	r24, Y+3	; 0x03
    30ca:	9c 81       	ldd	r25, Y+4	; 0x04
    30cc:	01 96       	adiw	r24, 0x01	; 1
    30ce:	8b 83       	std	Y+3, r24	; 0x03
    30d0:	9c 83       	std	Y+4, r25	; 0x04
    30d2:	8b 81       	ldd	r24, Y+3	; 0x03
    30d4:	9c 81       	ldd	r25, Y+4	; 0x04
    30d6:	fc e1       	ldi	r31, 0x1C	; 28
    30d8:	81 37       	cpi	r24, 0x71	; 113
    30da:	9f 07       	cpc	r25, r31
    30dc:	08 f4       	brcc	.+2      	; 0x30e0 <calcChecksumFRAM+0x5ce>
    30de:	8e cd       	rjmp	.-1252   	; 0x2bfc <calcChecksumFRAM+0xea>
//calcuate checksum for FRAM. Not used
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    30e0:	89 81       	ldd	r24, Y+1	; 0x01
    30e2:	9a 81       	ldd	r25, Y+2	; 0x02
    30e4:	01 96       	adiw	r24, 0x01	; 1
    30e6:	89 83       	std	Y+1, r24	; 0x01
    30e8:	9a 83       	std	Y+2, r25	; 0x02
    30ea:	89 81       	ldd	r24, Y+1	; 0x01
    30ec:	9a 81       	ldd	r25, Y+2	; 0x02
    30ee:	89 30       	cpi	r24, 0x09	; 9
    30f0:	91 05       	cpc	r25, r1
    30f2:	08 f4       	brcc	.+2      	; 0x30f6 <calcChecksumFRAM+0x5e4>
    30f4:	72 cd       	rjmp	.-1308   	; 0x2bda <calcChecksumFRAM+0xc8>
			
		}
		
	}
	
}
    30f6:	24 96       	adiw	r28, 0x04	; 4
    30f8:	cd bf       	out	0x3d, r28	; 61
    30fa:	de bf       	out	0x3e, r29	; 62
    30fc:	df 91       	pop	r29
    30fe:	cf 91       	pop	r28
    3100:	1f 91       	pop	r17
    3102:	0f 91       	pop	r16
    3104:	ff 90       	pop	r15
    3106:	ef 90       	pop	r14
    3108:	df 90       	pop	r13
    310a:	cf 90       	pop	r12
    310c:	bf 90       	pop	r11
    310e:	af 90       	pop	r10
    3110:	9f 90       	pop	r9
    3112:	8f 90       	pop	r8
    3114:	7f 90       	pop	r7
    3116:	6f 90       	pop	r6
    3118:	5f 90       	pop	r5
    311a:	4f 90       	pop	r4
    311c:	3f 90       	pop	r3
    311e:	2f 90       	pop	r2
    3120:	08 95       	ret

00003122 <FRAMWriteKnowns>:

//test function for FRAM
void FRAMWriteKnowns() {
    3122:	cf 93       	push	r28
    3124:	df 93       	push	r29
    3126:	cd b7       	in	r28, 0x3d	; 61
    3128:	de b7       	in	r29, 0x3e	; 62
	FRAMAddress = FR_BASEADD;
    312a:	10 92 50 40 	sts	0x4050, r1
    312e:	10 92 51 40 	sts	0x4051, r1
	sampleCount = 0;
    3132:	10 92 75 50 	sts	0x5075, r1
    3136:	10 92 76 50 	sts	0x5076, r1
    313a:	10 92 77 50 	sts	0x5077, r1
    313e:	10 92 78 50 	sts	0x5078, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    3142:	80 e0       	ldi	r24, 0x00	; 0
    3144:	80 93 34 21 	sts	0x2134, r24
    3148:	80 93 33 21 	sts	0x2133, r24
    314c:	80 93 32 21 	sts	0x2132, r24
	
	ADCPower(TRUE);
    3150:	81 e0       	ldi	r24, 0x01	; 1
    3152:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    3156:	84 e0       	ldi	r24, 0x04	; 4
    3158:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    315c:	80 ec       	ldi	r24, 0xC0	; 192
    315e:	98 e0       	ldi	r25, 0x08	; 8
    3160:	20 ed       	ldi	r18, 0xD0	; 208
    3162:	fc 01       	movw	r30, r24
    3164:	20 83       	st	Z, r18
	SPIBuffer[0] = 0x0D;
    3166:	8d e0       	ldi	r24, 0x0D	; 13
    3168:	80 93 66 50 	sts	0x5066, r24
	SPIBuffer[1] = 0xF3;
    316c:	83 ef       	ldi	r24, 0xF3	; 243
    316e:	80 93 67 50 	sts	0x5067, r24
	SPIBuffer[2] = 0x57;
    3172:	87 e5       	ldi	r24, 0x57	; 87
    3174:	80 93 68 50 	sts	0x5068, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    3178:	d7 c0       	rjmp	.+430    	; 0x3328 <FRAMWriteKnowns+0x206>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    317a:	80 e4       	ldi	r24, 0x40	; 64
    317c:	96 e0       	ldi	r25, 0x06	; 6
    317e:	20 e1       	ldi	r18, 0x10	; 16
    3180:	fc 01       	movw	r30, r24
    3182:	26 83       	std	Z+6, r18	; 0x06
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3184:	80 e2       	ldi	r24, 0x20	; 32
    3186:	96 e0       	ldi	r25, 0x06	; 6
    3188:	28 e0       	ldi	r18, 0x08	; 8
    318a:	fc 01       	movw	r30, r24
    318c:	26 83       	std	Z+6, r18	; 0x06
		nop();
    318e:	00 00       	nop
		SPIC.DATA = FR_WREN;
    3190:	80 ec       	ldi	r24, 0xC0	; 192
    3192:	98 e0       	ldi	r25, 0x08	; 8
    3194:	26 e0       	ldi	r18, 0x06	; 6
    3196:	fc 01       	movw	r30, r24
    3198:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    319a:	00 00       	nop
    319c:	80 ec       	ldi	r24, 0xC0	; 192
    319e:	98 e0       	ldi	r25, 0x08	; 8
    31a0:	fc 01       	movw	r30, r24
    31a2:	82 81       	ldd	r24, Z+2	; 0x02
    31a4:	88 23       	and	r24, r24
    31a6:	d4 f7       	brge	.-12     	; 0x319c <FRAMWriteKnowns+0x7a>
		SPIBuffer[12] = SPIC.DATA;
    31a8:	80 ec       	ldi	r24, 0xC0	; 192
    31aa:	98 e0       	ldi	r25, 0x08	; 8
    31ac:	fc 01       	movw	r30, r24
    31ae:	83 81       	ldd	r24, Z+3	; 0x03
    31b0:	80 93 72 50 	sts	0x5072, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    31b4:	80 e2       	ldi	r24, 0x20	; 32
    31b6:	96 e0       	ldi	r25, 0x06	; 6
    31b8:	28 e0       	ldi	r18, 0x08	; 8
    31ba:	fc 01       	movw	r30, r24
    31bc:	25 83       	std	Z+5, r18	; 0x05
		nop(); // time for CS_FRAM to accept high signal
    31be:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    31c0:	80 e2       	ldi	r24, 0x20	; 32
    31c2:	96 e0       	ldi	r25, 0x06	; 6
    31c4:	28 e0       	ldi	r18, 0x08	; 8
    31c6:	fc 01       	movw	r30, r24
    31c8:	26 83       	std	Z+6, r18	; 0x06
		nop();
    31ca:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    31cc:	80 ec       	ldi	r24, 0xC0	; 192
    31ce:	98 e0       	ldi	r25, 0x08	; 8
    31d0:	22 e0       	ldi	r18, 0x02	; 2
    31d2:	fc 01       	movw	r30, r24
    31d4:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    31d6:	00 00       	nop
    31d8:	80 ec       	ldi	r24, 0xC0	; 192
    31da:	98 e0       	ldi	r25, 0x08	; 8
    31dc:	fc 01       	movw	r30, r24
    31de:	82 81       	ldd	r24, Z+2	; 0x02
    31e0:	88 23       	and	r24, r24
    31e2:	d4 f7       	brge	.-12     	; 0x31d8 <FRAMWriteKnowns+0xb6>
		SPIBuffer[12] = SPIC.DATA;
    31e4:	80 ec       	ldi	r24, 0xC0	; 192
    31e6:	98 e0       	ldi	r25, 0x08	; 8
    31e8:	fc 01       	movw	r30, r24
    31ea:	83 81       	ldd	r24, Z+3	; 0x03
    31ec:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    31f0:	80 ec       	ldi	r24, 0xC0	; 192
    31f2:	98 e0       	ldi	r25, 0x08	; 8
    31f4:	20 91 51 40 	lds	r18, 0x4051
    31f8:	fc 01       	movw	r30, r24
    31fa:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    31fc:	00 00       	nop
    31fe:	80 ec       	ldi	r24, 0xC0	; 192
    3200:	98 e0       	ldi	r25, 0x08	; 8
    3202:	fc 01       	movw	r30, r24
    3204:	82 81       	ldd	r24, Z+2	; 0x02
    3206:	88 23       	and	r24, r24
    3208:	d4 f7       	brge	.-12     	; 0x31fe <FRAMWriteKnowns+0xdc>
		SPIBuffer[12] = SPIC.DATA;
    320a:	80 ec       	ldi	r24, 0xC0	; 192
    320c:	98 e0       	ldi	r25, 0x08	; 8
    320e:	fc 01       	movw	r30, r24
    3210:	83 81       	ldd	r24, Z+3	; 0x03
    3212:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    3216:	80 ec       	ldi	r24, 0xC0	; 192
    3218:	98 e0       	ldi	r25, 0x08	; 8
    321a:	20 e5       	ldi	r18, 0x50	; 80
    321c:	30 e4       	ldi	r19, 0x40	; 64
    321e:	f9 01       	movw	r30, r18
    3220:	20 81       	ld	r18, Z
    3222:	fc 01       	movw	r30, r24
    3224:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3226:	00 00       	nop
    3228:	80 ec       	ldi	r24, 0xC0	; 192
    322a:	98 e0       	ldi	r25, 0x08	; 8
    322c:	fc 01       	movw	r30, r24
    322e:	82 81       	ldd	r24, Z+2	; 0x02
    3230:	88 23       	and	r24, r24
    3232:	d4 f7       	brge	.-12     	; 0x3228 <FRAMWriteKnowns+0x106>
		SPIBuffer[12] = SPIC.DATA;
    3234:	80 ec       	ldi	r24, 0xC0	; 192
    3236:	98 e0       	ldi	r25, 0x08	; 8
    3238:	fc 01       	movw	r30, r24
    323a:	83 81       	ldd	r24, Z+3	; 0x03
    323c:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = SPIBuffer[0];
    3240:	80 ec       	ldi	r24, 0xC0	; 192
    3242:	98 e0       	ldi	r25, 0x08	; 8
    3244:	20 91 66 50 	lds	r18, 0x5066
    3248:	fc 01       	movw	r30, r24
    324a:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    324c:	00 00       	nop
    324e:	80 ec       	ldi	r24, 0xC0	; 192
    3250:	98 e0       	ldi	r25, 0x08	; 8
    3252:	fc 01       	movw	r30, r24
    3254:	82 81       	ldd	r24, Z+2	; 0x02
    3256:	88 23       	and	r24, r24
    3258:	d4 f7       	brge	.-12     	; 0x324e <FRAMWriteKnowns+0x12c>
		SPIBuffer[12] = SPIC.DATA;
    325a:	80 ec       	ldi	r24, 0xC0	; 192
    325c:	98 e0       	ldi	r25, 0x08	; 8
    325e:	fc 01       	movw	r30, r24
    3260:	83 81       	ldd	r24, Z+3	; 0x03
    3262:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = SPIBuffer[1];
    3266:	80 ec       	ldi	r24, 0xC0	; 192
    3268:	98 e0       	ldi	r25, 0x08	; 8
    326a:	20 91 67 50 	lds	r18, 0x5067
    326e:	fc 01       	movw	r30, r24
    3270:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3272:	00 00       	nop
    3274:	80 ec       	ldi	r24, 0xC0	; 192
    3276:	98 e0       	ldi	r25, 0x08	; 8
    3278:	fc 01       	movw	r30, r24
    327a:	82 81       	ldd	r24, Z+2	; 0x02
    327c:	88 23       	and	r24, r24
    327e:	d4 f7       	brge	.-12     	; 0x3274 <FRAMWriteKnowns+0x152>
		SPIBuffer[12] = SPIC.DATA;
    3280:	80 ec       	ldi	r24, 0xC0	; 192
    3282:	98 e0       	ldi	r25, 0x08	; 8
    3284:	fc 01       	movw	r30, r24
    3286:	83 81       	ldd	r24, Z+3	; 0x03
    3288:	80 93 72 50 	sts	0x5072, r24
		SPIC.DATA = SPIBuffer[2];
    328c:	80 ec       	ldi	r24, 0xC0	; 192
    328e:	98 e0       	ldi	r25, 0x08	; 8
    3290:	20 91 68 50 	lds	r18, 0x5068
    3294:	fc 01       	movw	r30, r24
    3296:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    3298:	00 00       	nop
    329a:	80 ec       	ldi	r24, 0xC0	; 192
    329c:	98 e0       	ldi	r25, 0x08	; 8
    329e:	fc 01       	movw	r30, r24
    32a0:	82 81       	ldd	r24, Z+2	; 0x02
    32a2:	88 23       	and	r24, r24
    32a4:	d4 f7       	brge	.-12     	; 0x329a <FRAMWriteKnowns+0x178>
		SPIBuffer[12] = SPIC.DATA;
    32a6:	80 ec       	ldi	r24, 0xC0	; 192
    32a8:	98 e0       	ldi	r25, 0x08	; 8
    32aa:	fc 01       	movw	r30, r24
    32ac:	83 81       	ldd	r24, Z+3	; 0x03
    32ae:	80 93 72 50 	sts	0x5072, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    32b2:	80 e2       	ldi	r24, 0x20	; 32
    32b4:	96 e0       	ldi	r25, 0x06	; 6
    32b6:	28 e0       	ldi	r18, 0x08	; 8
    32b8:	fc 01       	movw	r30, r24
    32ba:	25 83       	std	Z+5, r18	; 0x05
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    32bc:	80 e4       	ldi	r24, 0x40	; 64
    32be:	96 e0       	ldi	r25, 0x06	; 6
    32c0:	20 e1       	ldi	r18, 0x10	; 16
    32c2:	fc 01       	movw	r30, r24
    32c4:	25 83       	std	Z+5, r18	; 0x05
		
		FRAMAddress +=3;
    32c6:	80 91 50 40 	lds	r24, 0x4050
    32ca:	90 91 51 40 	lds	r25, 0x4051
    32ce:	03 96       	adiw	r24, 0x03	; 3
    32d0:	80 93 50 40 	sts	0x4050, r24
    32d4:	90 93 51 40 	sts	0x4051, r25
		checksumADC[0] += SPIBuffer[0];
    32d8:	90 91 32 21 	lds	r25, 0x2132
    32dc:	80 91 66 50 	lds	r24, 0x5066
    32e0:	89 0f       	add	r24, r25
    32e2:	80 93 32 21 	sts	0x2132, r24
		checksumADC[1] += SPIBuffer[1];
    32e6:	90 91 33 21 	lds	r25, 0x2133
    32ea:	80 91 67 50 	lds	r24, 0x5067
    32ee:	89 0f       	add	r24, r25
    32f0:	80 93 33 21 	sts	0x2133, r24
		checksumADC[2] += SPIBuffer[2];
    32f4:	90 91 34 21 	lds	r25, 0x2134
    32f8:	80 91 68 50 	lds	r24, 0x5068
    32fc:	89 0f       	add	r24, r25
    32fe:	80 93 34 21 	sts	0x2134, r24
		
		sampleCount++;
    3302:	80 91 75 50 	lds	r24, 0x5075
    3306:	90 91 76 50 	lds	r25, 0x5076
    330a:	a0 91 77 50 	lds	r26, 0x5077
    330e:	b0 91 78 50 	lds	r27, 0x5078
    3312:	01 96       	adiw	r24, 0x01	; 1
    3314:	a1 1d       	adc	r26, r1
    3316:	b1 1d       	adc	r27, r1
    3318:	80 93 75 50 	sts	0x5075, r24
    331c:	90 93 76 50 	sts	0x5076, r25
    3320:	a0 93 77 50 	sts	0x5077, r26
    3324:	b0 93 78 50 	sts	0x5078, r27
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    3328:	80 91 75 50 	lds	r24, 0x5075
    332c:	90 91 76 50 	lds	r25, 0x5076
    3330:	a0 91 77 50 	lds	r26, 0x5077
    3334:	b0 91 78 50 	lds	r27, 0x5078
    3338:	83 35       	cpi	r24, 0x53	; 83
    333a:	f5 e5       	ldi	r31, 0x55	; 85
    333c:	9f 07       	cpc	r25, r31
    333e:	f0 e0       	ldi	r31, 0x00	; 0
    3340:	af 07       	cpc	r26, r31
    3342:	f0 e0       	ldi	r31, 0x00	; 0
    3344:	bf 07       	cpc	r27, r31
    3346:	08 f4       	brcc	.+2      	; 0x334a <FRAMWriteKnowns+0x228>
    3348:	18 cf       	rjmp	.-464    	; 0x317a <FRAMWriteKnowns+0x58>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    334a:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>
	ADCPower(FALSE);
    334e:	80 e0       	ldi	r24, 0x00	; 0
    3350:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
}
    3354:	df 91       	pop	r29
    3356:	cf 91       	pop	r28
    3358:	08 95       	ret

0000335a <setADCInput>:



/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
    335a:	cf 93       	push	r28
    335c:	df 93       	push	r29
    335e:	0f 92       	push	r0
    3360:	cd b7       	in	r28, 0x3d	; 61
    3362:	de b7       	in	r29, 0x3e	; 62
    3364:	89 83       	std	Y+1, r24	; 0x01
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    3366:	89 81       	ldd	r24, Y+1	; 0x01
    3368:	88 2f       	mov	r24, r24
    336a:	90 e0       	ldi	r25, 0x00	; 0
    336c:	81 70       	andi	r24, 0x01	; 1
    336e:	90 70       	andi	r25, 0x00	; 0
    3370:	88 23       	and	r24, r24
    3372:	31 f0       	breq	.+12     	; 0x3380 <setADCInput+0x26>
    3374:	80 e0       	ldi	r24, 0x00	; 0
    3376:	96 e0       	ldi	r25, 0x06	; 6
    3378:	20 e4       	ldi	r18, 0x40	; 64
    337a:	fc 01       	movw	r30, r24
    337c:	25 83       	std	Z+5, r18	; 0x05
    337e:	05 c0       	rjmp	.+10     	; 0x338a <setADCInput+0x30>
	else {PORTA.OUTCLR = PIN6_bm;}
    3380:	80 e0       	ldi	r24, 0x00	; 0
    3382:	96 e0       	ldi	r25, 0x06	; 6
    3384:	20 e4       	ldi	r18, 0x40	; 64
    3386:	fc 01       	movw	r30, r24
    3388:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    338a:	89 81       	ldd	r24, Y+1	; 0x01
    338c:	88 2f       	mov	r24, r24
    338e:	90 e0       	ldi	r25, 0x00	; 0
    3390:	82 70       	andi	r24, 0x02	; 2
    3392:	90 70       	andi	r25, 0x00	; 0
    3394:	00 97       	sbiw	r24, 0x00	; 0
    3396:	31 f0       	breq	.+12     	; 0x33a4 <setADCInput+0x4a>
    3398:	80 e2       	ldi	r24, 0x20	; 32
    339a:	96 e0       	ldi	r25, 0x06	; 6
    339c:	22 e0       	ldi	r18, 0x02	; 2
    339e:	fc 01       	movw	r30, r24
    33a0:	25 83       	std	Z+5, r18	; 0x05
    33a2:	05 c0       	rjmp	.+10     	; 0x33ae <setADCInput+0x54>
	else {PORTB.OUTCLR = PIN1_bm;}
    33a4:	80 e2       	ldi	r24, 0x20	; 32
    33a6:	96 e0       	ldi	r25, 0x06	; 6
    33a8:	22 e0       	ldi	r18, 0x02	; 2
    33aa:	fc 01       	movw	r30, r24
    33ac:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    33ae:	89 81       	ldd	r24, Y+1	; 0x01
    33b0:	88 2f       	mov	r24, r24
    33b2:	90 e0       	ldi	r25, 0x00	; 0
    33b4:	84 70       	andi	r24, 0x04	; 4
    33b6:	90 70       	andi	r25, 0x00	; 0
    33b8:	00 97       	sbiw	r24, 0x00	; 0
    33ba:	31 f0       	breq	.+12     	; 0x33c8 <setADCInput+0x6e>
    33bc:	80 e2       	ldi	r24, 0x20	; 32
    33be:	96 e0       	ldi	r25, 0x06	; 6
    33c0:	24 e0       	ldi	r18, 0x04	; 4
    33c2:	fc 01       	movw	r30, r24
    33c4:	25 83       	std	Z+5, r18	; 0x05
    33c6:	05 c0       	rjmp	.+10     	; 0x33d2 <setADCInput+0x78>
	else {PORTB.OUTCLR = PIN2_bm;}
    33c8:	80 e2       	ldi	r24, 0x20	; 32
    33ca:	96 e0       	ldi	r25, 0x06	; 6
    33cc:	24 e0       	ldi	r18, 0x04	; 4
    33ce:	fc 01       	movw	r30, r24
    33d0:	26 83       	std	Z+6, r18	; 0x06

}
    33d2:	0f 90       	pop	r0
    33d4:	df 91       	pop	r29
    33d6:	cf 91       	pop	r28
    33d8:	08 95       	ret

000033da <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    33da:	cf 93       	push	r28
    33dc:	df 93       	push	r29
    33de:	0f 92       	push	r0
    33e0:	0f 92       	push	r0
    33e2:	cd b7       	in	r28, 0x3d	; 61
    33e4:	de b7       	in	r29, 0x3e	; 62
    33e6:	89 83       	std	Y+1, r24	; 0x01
    33e8:	9a 83       	std	Y+2, r25	; 0x02
	if(&ADCA == adc){
    33ea:	89 81       	ldd	r24, Y+1	; 0x01
    33ec:	9a 81       	ldd	r25, Y+2	; 0x02
    33ee:	22 e0       	ldi	r18, 0x02	; 2
    33f0:	80 30       	cpi	r24, 0x00	; 0
    33f2:	92 07       	cpc	r25, r18
    33f4:	89 f4       	brne	.+34     	; 0x3418 <ADC_CalibrationValues_Load+0x3e>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    33f6:	80 e2       	ldi	r24, 0x20	; 32
    33f8:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <SP_ReadCalibrationByte>
    33fc:	28 2f       	mov	r18, r24
    33fe:	89 81       	ldd	r24, Y+1	; 0x01
    3400:	9a 81       	ldd	r25, Y+2	; 0x02
    3402:	fc 01       	movw	r30, r24
    3404:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    3406:	81 e2       	ldi	r24, 0x21	; 33
    3408:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <SP_ReadCalibrationByte>
    340c:	28 2f       	mov	r18, r24
    340e:	89 81       	ldd	r24, Y+1	; 0x01
    3410:	9a 81       	ldd	r25, Y+2	; 0x02
    3412:	fc 01       	movw	r30, r24
    3414:	25 87       	std	Z+13, r18	; 0x0d
    3416:	10 c0       	rjmp	.+32     	; 0x3438 <ADC_CalibrationValues_Load+0x5e>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    3418:	84 e2       	ldi	r24, 0x24	; 36
    341a:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <SP_ReadCalibrationByte>
    341e:	28 2f       	mov	r18, r24
    3420:	89 81       	ldd	r24, Y+1	; 0x01
    3422:	9a 81       	ldd	r25, Y+2	; 0x02
    3424:	fc 01       	movw	r30, r24
    3426:	24 87       	std	Z+12, r18	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    3428:	85 e2       	ldi	r24, 0x25	; 37
    342a:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <SP_ReadCalibrationByte>
    342e:	28 2f       	mov	r18, r24
    3430:	89 81       	ldd	r24, Y+1	; 0x01
    3432:	9a 81       	ldd	r25, Y+2	; 0x02
    3434:	fc 01       	movw	r30, r24
    3436:	25 87       	std	Z+13, r18	; 0x0d
	}
}
    3438:	0f 90       	pop	r0
    343a:	0f 90       	pop	r0
    343c:	df 91       	pop	r29
    343e:	cf 91       	pop	r28
    3440:	08 95       	ret

00003442 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    3442:	cf 93       	push	r28
    3444:	df 93       	push	r29
    3446:	cd b7       	in	r28, 0x3d	; 61
    3448:	de b7       	in	r29, 0x3e	; 62
    344a:	25 97       	sbiw	r28, 0x05	; 5
    344c:	cd bf       	out	0x3d, r28	; 61
    344e:	de bf       	out	0x3e, r29	; 62
    3450:	8b 83       	std	Y+3, r24	; 0x03
    3452:	9c 83       	std	Y+4, r25	; 0x04
    3454:	6d 83       	std	Y+5, r22	; 0x05
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3456:	8b 81       	ldd	r24, Y+3	; 0x03
    3458:	9c 81       	ldd	r25, Y+4	; 0x04
    345a:	21 e0       	ldi	r18, 0x01	; 1
    345c:	fc 01       	movw	r30, r24
    345e:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    3460:	8b 81       	ldd	r24, Y+3	; 0x03
    3462:	9c 81       	ldd	r25, Y+4	; 0x04
    3464:	fc 01       	movw	r30, r24
    3466:	24 81       	ldd	r18, Z+4	; 0x04
    3468:	35 81       	ldd	r19, Z+5	; 0x05
    346a:	8d 81       	ldd	r24, Y+5	; 0x05
    346c:	88 2f       	mov	r24, r24
    346e:	90 e0       	ldi	r25, 0x00	; 0
    3470:	a9 01       	movw	r20, r18
    3472:	48 1b       	sub	r20, r24
    3474:	59 0b       	sbc	r21, r25
    3476:	ca 01       	movw	r24, r20
    3478:	89 83       	std	Y+1, r24	; 0x01
    347a:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    347c:	89 81       	ldd	r24, Y+1	; 0x01
    347e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3480:	25 96       	adiw	r28, 0x05	; 5
    3482:	cd bf       	out	0x3d, r28	; 61
    3484:	de bf       	out	0x3e, r29	; 62
    3486:	df 91       	pop	r29
    3488:	cf 91       	pop	r28
    348a:	08 95       	ret

0000348c <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    348c:	cf 93       	push	r28
    348e:	df 93       	push	r29
    3490:	cd b7       	in	r28, 0x3d	; 61
    3492:	de b7       	in	r29, 0x3e	; 62
    3494:	25 97       	sbiw	r28, 0x05	; 5
    3496:	cd bf       	out	0x3d, r28	; 61
    3498:	de bf       	out	0x3e, r29	; 62
    349a:	8b 83       	std	Y+3, r24	; 0x03
    349c:	9c 83       	std	Y+4, r25	; 0x04
    349e:	6d 83       	std	Y+5, r22	; 0x05
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    34a0:	8b 81       	ldd	r24, Y+3	; 0x03
    34a2:	9c 81       	ldd	r25, Y+4	; 0x04
    34a4:	21 e0       	ldi	r18, 0x01	; 1
    34a6:	fc 01       	movw	r30, r24
    34a8:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    34aa:	8b 81       	ldd	r24, Y+3	; 0x03
    34ac:	9c 81       	ldd	r25, Y+4	; 0x04
    34ae:	fc 01       	movw	r30, r24
    34b0:	24 81       	ldd	r18, Z+4	; 0x04
    34b2:	35 81       	ldd	r19, Z+5	; 0x05
    34b4:	8d 81       	ldd	r24, Y+5	; 0x05
    34b6:	99 27       	eor	r25, r25
    34b8:	87 fd       	sbrc	r24, 7
    34ba:	90 95       	com	r25
    34bc:	a9 01       	movw	r20, r18
    34be:	48 1b       	sub	r20, r24
    34c0:	59 0b       	sbc	r21, r25
    34c2:	ca 01       	movw	r24, r20
    34c4:	89 83       	std	Y+1, r24	; 0x01
    34c6:	9a 83       	std	Y+2, r25	; 0x02

	return answer;
    34c8:	89 81       	ldd	r24, Y+1	; 0x01
    34ca:	9a 81       	ldd	r25, Y+2	; 0x02
}
    34cc:	25 96       	adiw	r28, 0x05	; 5
    34ce:	cd bf       	out	0x3d, r28	; 61
    34d0:	de bf       	out	0x3e, r29	; 62
    34d2:	df 91       	pop	r29
    34d4:	cf 91       	pop	r28
    34d6:	08 95       	ret

000034d8 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    34d8:	cf 93       	push	r28
    34da:	df 93       	push	r29
    34dc:	0f 92       	push	r0
    34de:	0f 92       	push	r0
    34e0:	cd b7       	in	r28, 0x3d	; 61
    34e2:	de b7       	in	r29, 0x3e	; 62
    34e4:	89 83       	std	Y+1, r24	; 0x01
    34e6:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    34e8:	89 81       	ldd	r24, Y+1	; 0x01
    34ea:	9a 81       	ldd	r25, Y+2	; 0x02
    34ec:	21 e0       	ldi	r18, 0x01	; 1
    34ee:	fc 01       	movw	r30, r24
    34f0:	23 83       	std	Z+3, r18	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    34f2:	89 81       	ldd	r24, Y+1	; 0x01
    34f4:	9a 81       	ldd	r25, Y+2	; 0x02
    34f6:	fc 01       	movw	r30, r24
    34f8:	84 81       	ldd	r24, Z+4	; 0x04
    34fa:	95 81       	ldd	r25, Z+5	; 0x05
}
    34fc:	0f 90       	pop	r0
    34fe:	0f 90       	pop	r0
    3500:	df 91       	pop	r29
    3502:	cf 91       	pop	r28
    3504:	08 95       	ret

00003506 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    3506:	cf 93       	push	r28
    3508:	df 93       	push	r29
    350a:	0f 92       	push	r0
    350c:	0f 92       	push	r0
    350e:	cd b7       	in	r28, 0x3d	; 61
    3510:	de b7       	in	r29, 0x3e	; 62
    3512:	89 83       	std	Y+1, r24	; 0x01
    3514:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3516:	89 81       	ldd	r24, Y+1	; 0x01
    3518:	9a 81       	ldd	r25, Y+2	; 0x02
    351a:	21 e0       	ldi	r18, 0x01	; 1
    351c:	fc 01       	movw	r30, r24
    351e:	23 83       	std	Z+3, r18	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    3520:	89 81       	ldd	r24, Y+1	; 0x01
    3522:	9a 81       	ldd	r25, Y+2	; 0x02
    3524:	fc 01       	movw	r30, r24
    3526:	84 81       	ldd	r24, Z+4	; 0x04
}
    3528:	0f 90       	pop	r0
    352a:	0f 90       	pop	r0
    352c:	df 91       	pop	r29
    352e:	cf 91       	pop	r28
    3530:	08 95       	ret

00003532 <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    3532:	cf 93       	push	r28
    3534:	df 93       	push	r29
    3536:	0f 92       	push	r0
    3538:	0f 92       	push	r0
    353a:	cd b7       	in	r28, 0x3d	; 61
    353c:	de b7       	in	r29, 0x3e	; 62
    353e:	89 83       	std	Y+1, r24	; 0x01
    3540:	9a 83       	std	Y+2, r25	; 0x02
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    3542:	89 81       	ldd	r24, Y+1	; 0x01
    3544:	9a 81       	ldd	r25, Y+2	; 0x02
    3546:	21 e0       	ldi	r18, 0x01	; 1
    3548:	fc 01       	movw	r30, r24
    354a:	23 83       	std	Z+3, r18	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    354c:	89 81       	ldd	r24, Y+1	; 0x01
    354e:	9a 81       	ldd	r25, Y+2	; 0x02
    3550:	fc 01       	movw	r30, r24
    3552:	85 81       	ldd	r24, Z+5	; 0x05
}
    3554:	0f 90       	pop	r0
    3556:	0f 90       	pop	r0
    3558:	df 91       	pop	r29
    355a:	cf 91       	pop	r28
    355c:	08 95       	ret

0000355e <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    355e:	0f 93       	push	r16
    3560:	1f 93       	push	r17
    3562:	cf 93       	push	r28
    3564:	df 93       	push	r29
    3566:	cd b7       	in	r28, 0x3d	; 61
    3568:	de b7       	in	r29, 0x3e	; 62
    356a:	6b 97       	sbiw	r28, 0x1b	; 27
    356c:	cd bf       	out	0x3d, r28	; 61
    356e:	de bf       	out	0x3e, r29	; 62
    3570:	8a 8f       	std	Y+26, r24	; 0x1a
    3572:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3574:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3576:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3578:	fc 01       	movw	r30, r24
    357a:	84 81       	ldd	r24, Z+4	; 0x04
    357c:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    357e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3580:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3582:	fc 01       	movw	r30, r24
    3584:	14 82       	std	Z+4, r1	; 0x04
    3586:	80 e0       	ldi	r24, 0x00	; 0
    3588:	90 e0       	ldi	r25, 0x00	; 0
    358a:	a0 e8       	ldi	r26, 0x80	; 128
    358c:	b2 e4       	ldi	r27, 0x42	; 66
    358e:	8a 83       	std	Y+2, r24	; 0x02
    3590:	9b 83       	std	Y+3, r25	; 0x03
    3592:	ac 83       	std	Y+4, r26	; 0x04
    3594:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3596:	6a 81       	ldd	r22, Y+2	; 0x02
    3598:	7b 81       	ldd	r23, Y+3	; 0x03
    359a:	8c 81       	ldd	r24, Y+4	; 0x04
    359c:	9d 81       	ldd	r25, Y+5	; 0x05
    359e:	2b ea       	ldi	r18, 0xAB	; 171
    35a0:	3a ea       	ldi	r19, 0xAA	; 170
    35a2:	4a e2       	ldi	r20, 0x2A	; 42
    35a4:	5f e3       	ldi	r21, 0x3F	; 63
    35a6:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    35aa:	dc 01       	movw	r26, r24
    35ac:	cb 01       	movw	r24, r22
    35ae:	8e 83       	std	Y+6, r24	; 0x06
    35b0:	9f 83       	std	Y+7, r25	; 0x07
    35b2:	a8 87       	std	Y+8, r26	; 0x08
    35b4:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    35b6:	11 e0       	ldi	r17, 0x01	; 1
    35b8:	6e 81       	ldd	r22, Y+6	; 0x06
    35ba:	7f 81       	ldd	r23, Y+7	; 0x07
    35bc:	88 85       	ldd	r24, Y+8	; 0x08
    35be:	99 85       	ldd	r25, Y+9	; 0x09
    35c0:	20 e0       	ldi	r18, 0x00	; 0
    35c2:	30 e0       	ldi	r19, 0x00	; 0
    35c4:	40 e8       	ldi	r20, 0x80	; 128
    35c6:	5f e3       	ldi	r21, 0x3F	; 63
    35c8:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    35cc:	88 23       	and	r24, r24
    35ce:	0c f0       	brlt	.+2      	; 0x35d2 <ADC_Wait_8MHz+0x74>
    35d0:	10 e0       	ldi	r17, 0x00	; 0
    35d2:	11 23       	and	r17, r17
    35d4:	19 f0       	breq	.+6      	; 0x35dc <ADC_Wait_8MHz+0x7e>
		__ticks = 1;
    35d6:	81 e0       	ldi	r24, 0x01	; 1
    35d8:	8a 87       	std	Y+10, r24	; 0x0a
    35da:	a3 c0       	rjmp	.+326    	; 0x3722 <ADC_Wait_8MHz+0x1c4>
	else if (__tmp > 255)
    35dc:	11 e0       	ldi	r17, 0x01	; 1
    35de:	6e 81       	ldd	r22, Y+6	; 0x06
    35e0:	7f 81       	ldd	r23, Y+7	; 0x07
    35e2:	88 85       	ldd	r24, Y+8	; 0x08
    35e4:	99 85       	ldd	r25, Y+9	; 0x09
    35e6:	20 e0       	ldi	r18, 0x00	; 0
    35e8:	30 e0       	ldi	r19, 0x00	; 0
    35ea:	4f e7       	ldi	r20, 0x7F	; 127
    35ec:	53 e4       	ldi	r21, 0x43	; 67
    35ee:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    35f2:	18 16       	cp	r1, r24
    35f4:	0c f0       	brlt	.+2      	; 0x35f8 <ADC_Wait_8MHz+0x9a>
    35f6:	10 e0       	ldi	r17, 0x00	; 0
    35f8:	11 23       	and	r17, r17
    35fa:	09 f4       	brne	.+2      	; 0x35fe <ADC_Wait_8MHz+0xa0>
    35fc:	89 c0       	rjmp	.+274    	; 0x3710 <ADC_Wait_8MHz+0x1b2>
	{
		_delay_ms(__us / 1000.0);
    35fe:	6a 81       	ldd	r22, Y+2	; 0x02
    3600:	7b 81       	ldd	r23, Y+3	; 0x03
    3602:	8c 81       	ldd	r24, Y+4	; 0x04
    3604:	9d 81       	ldd	r25, Y+5	; 0x05
    3606:	20 e0       	ldi	r18, 0x00	; 0
    3608:	30 e0       	ldi	r19, 0x00	; 0
    360a:	4a e7       	ldi	r20, 0x7A	; 122
    360c:	54 e4       	ldi	r21, 0x44	; 68
    360e:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
    3612:	dc 01       	movw	r26, r24
    3614:	cb 01       	movw	r24, r22
    3616:	8b 87       	std	Y+11, r24	; 0x0b
    3618:	9c 87       	std	Y+12, r25	; 0x0c
    361a:	ad 87       	std	Y+13, r26	; 0x0d
    361c:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    361e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3620:	7c 85       	ldd	r23, Y+12	; 0x0c
    3622:	8d 85       	ldd	r24, Y+13	; 0x0d
    3624:	9e 85       	ldd	r25, Y+14	; 0x0e
    3626:	20 e0       	ldi	r18, 0x00	; 0
    3628:	30 e0       	ldi	r19, 0x00	; 0
    362a:	4a ef       	ldi	r20, 0xFA	; 250
    362c:	53 e4       	ldi	r21, 0x43	; 67
    362e:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    3632:	dc 01       	movw	r26, r24
    3634:	cb 01       	movw	r24, r22
    3636:	8f 87       	std	Y+15, r24	; 0x0f
    3638:	98 8b       	std	Y+16, r25	; 0x10
    363a:	a9 8b       	std	Y+17, r26	; 0x11
    363c:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    363e:	11 e0       	ldi	r17, 0x01	; 1
    3640:	6f 85       	ldd	r22, Y+15	; 0x0f
    3642:	78 89       	ldd	r23, Y+16	; 0x10
    3644:	89 89       	ldd	r24, Y+17	; 0x11
    3646:	9a 89       	ldd	r25, Y+18	; 0x12
    3648:	20 e0       	ldi	r18, 0x00	; 0
    364a:	30 e0       	ldi	r19, 0x00	; 0
    364c:	40 e8       	ldi	r20, 0x80	; 128
    364e:	5f e3       	ldi	r21, 0x3F	; 63
    3650:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    3654:	88 23       	and	r24, r24
    3656:	0c f0       	brlt	.+2      	; 0x365a <ADC_Wait_8MHz+0xfc>
    3658:	10 e0       	ldi	r17, 0x00	; 0
    365a:	11 23       	and	r17, r17
    365c:	29 f0       	breq	.+10     	; 0x3668 <ADC_Wait_8MHz+0x10a>
		__ticks = 1;
    365e:	81 e0       	ldi	r24, 0x01	; 1
    3660:	90 e0       	ldi	r25, 0x00	; 0
    3662:	8b 8b       	std	Y+19, r24	; 0x13
    3664:	9c 8b       	std	Y+20, r25	; 0x14
    3666:	46 c0       	rjmp	.+140    	; 0x36f4 <ADC_Wait_8MHz+0x196>
	else if (__tmp > 65535)
    3668:	11 e0       	ldi	r17, 0x01	; 1
    366a:	6f 85       	ldd	r22, Y+15	; 0x0f
    366c:	78 89       	ldd	r23, Y+16	; 0x10
    366e:	89 89       	ldd	r24, Y+17	; 0x11
    3670:	9a 89       	ldd	r25, Y+18	; 0x12
    3672:	20 e0       	ldi	r18, 0x00	; 0
    3674:	3f ef       	ldi	r19, 0xFF	; 255
    3676:	4f e7       	ldi	r20, 0x7F	; 127
    3678:	57 e4       	ldi	r21, 0x47	; 71
    367a:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    367e:	18 16       	cp	r1, r24
    3680:	0c f0       	brlt	.+2      	; 0x3684 <ADC_Wait_8MHz+0x126>
    3682:	10 e0       	ldi	r17, 0x00	; 0
    3684:	11 23       	and	r17, r17
    3686:	61 f1       	breq	.+88     	; 0x36e0 <ADC_Wait_8MHz+0x182>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3688:	6b 85       	ldd	r22, Y+11	; 0x0b
    368a:	7c 85       	ldd	r23, Y+12	; 0x0c
    368c:	8d 85       	ldd	r24, Y+13	; 0x0d
    368e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3690:	20 e0       	ldi	r18, 0x00	; 0
    3692:	30 e0       	ldi	r19, 0x00	; 0
    3694:	40 e2       	ldi	r20, 0x20	; 32
    3696:	51 e4       	ldi	r21, 0x41	; 65
    3698:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    369c:	dc 01       	movw	r26, r24
    369e:	cb 01       	movw	r24, r22
    36a0:	bc 01       	movw	r22, r24
    36a2:	cd 01       	movw	r24, r26
    36a4:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    36a8:	dc 01       	movw	r26, r24
    36aa:	cb 01       	movw	r24, r22
    36ac:	8b 8b       	std	Y+19, r24	; 0x13
    36ae:	9c 8b       	std	Y+20, r25	; 0x14
    36b0:	12 c0       	rjmp	.+36     	; 0x36d6 <ADC_Wait_8MHz+0x178>
    36b2:	82 e3       	ldi	r24, 0x32	; 50
    36b4:	90 e0       	ldi	r25, 0x00	; 0
    36b6:	8d 8b       	std	Y+21, r24	; 0x15
    36b8:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    36ba:	8d 89       	ldd	r24, Y+21	; 0x15
    36bc:	9e 89       	ldd	r25, Y+22	; 0x16
    36be:	8c 01       	movw	r16, r24
    36c0:	c8 01       	movw	r24, r16
    36c2:	01 97       	sbiw	r24, 0x01	; 1
    36c4:	f1 f7       	brne	.-4      	; 0x36c2 <ADC_Wait_8MHz+0x164>
    36c6:	8c 01       	movw	r16, r24
    36c8:	0d 8b       	std	Y+21, r16	; 0x15
    36ca:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    36cc:	8b 89       	ldd	r24, Y+19	; 0x13
    36ce:	9c 89       	ldd	r25, Y+20	; 0x14
    36d0:	01 97       	sbiw	r24, 0x01	; 1
    36d2:	8b 8b       	std	Y+19, r24	; 0x13
    36d4:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    36d6:	8b 89       	ldd	r24, Y+19	; 0x13
    36d8:	9c 89       	ldd	r25, Y+20	; 0x14
    36da:	00 97       	sbiw	r24, 0x00	; 0
    36dc:	51 f7       	brne	.-44     	; 0x36b2 <ADC_Wait_8MHz+0x154>
    36de:	28 c0       	rjmp	.+80     	; 0x3730 <ADC_Wait_8MHz+0x1d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    36e0:	6f 85       	ldd	r22, Y+15	; 0x0f
    36e2:	78 89       	ldd	r23, Y+16	; 0x10
    36e4:	89 89       	ldd	r24, Y+17	; 0x11
    36e6:	9a 89       	ldd	r25, Y+18	; 0x12
    36e8:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    36ec:	dc 01       	movw	r26, r24
    36ee:	cb 01       	movw	r24, r22
    36f0:	8b 8b       	std	Y+19, r24	; 0x13
    36f2:	9c 8b       	std	Y+20, r25	; 0x14
    36f4:	8b 89       	ldd	r24, Y+19	; 0x13
    36f6:	9c 89       	ldd	r25, Y+20	; 0x14
    36f8:	8f 8b       	std	Y+23, r24	; 0x17
    36fa:	98 8f       	std	Y+24, r25	; 0x18
    36fc:	8f 89       	ldd	r24, Y+23	; 0x17
    36fe:	98 8d       	ldd	r25, Y+24	; 0x18
    3700:	8c 01       	movw	r16, r24
    3702:	f8 01       	movw	r30, r16
    3704:	31 97       	sbiw	r30, 0x01	; 1
    3706:	f1 f7       	brne	.-4      	; 0x3704 <ADC_Wait_8MHz+0x1a6>
    3708:	8f 01       	movw	r16, r30
    370a:	0f 8b       	std	Y+23, r16	; 0x17
    370c:	18 8f       	std	Y+24, r17	; 0x18
    370e:	10 c0       	rjmp	.+32     	; 0x3730 <ADC_Wait_8MHz+0x1d2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3710:	6e 81       	ldd	r22, Y+6	; 0x06
    3712:	7f 81       	ldd	r23, Y+7	; 0x07
    3714:	88 85       	ldd	r24, Y+8	; 0x08
    3716:	99 85       	ldd	r25, Y+9	; 0x09
    3718:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    371c:	dc 01       	movw	r26, r24
    371e:	cb 01       	movw	r24, r22
    3720:	8a 87       	std	Y+10, r24	; 0x0a
    3722:	8a 85       	ldd	r24, Y+10	; 0x0a
    3724:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3726:	89 8d       	ldd	r24, Y+25	; 0x19
    3728:	18 2f       	mov	r17, r24
    372a:	1a 95       	dec	r17
    372c:	f1 f7       	brne	.-4      	; 0x372a <ADC_Wait_8MHz+0x1cc>
    372e:	19 8f       	std	Y+25, r17	; 0x19

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    3730:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3732:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3734:	29 81       	ldd	r18, Y+1	; 0x01
    3736:	fc 01       	movw	r30, r24
    3738:	24 83       	std	Z+4, r18	; 0x04
}
    373a:	6b 96       	adiw	r28, 0x1b	; 27
    373c:	cd bf       	out	0x3d, r28	; 61
    373e:	de bf       	out	0x3e, r29	; 62
    3740:	df 91       	pop	r29
    3742:	cf 91       	pop	r28
    3744:	1f 91       	pop	r17
    3746:	0f 91       	pop	r16
    3748:	08 95       	ret

0000374a <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    374a:	0f 93       	push	r16
    374c:	1f 93       	push	r17
    374e:	cf 93       	push	r28
    3750:	df 93       	push	r29
    3752:	cd b7       	in	r28, 0x3d	; 61
    3754:	de b7       	in	r29, 0x3e	; 62
    3756:	6b 97       	sbiw	r28, 0x1b	; 27
    3758:	cd bf       	out	0x3d, r28	; 61
    375a:	de bf       	out	0x3e, r29	; 62
    375c:	8a 8f       	std	Y+26, r24	; 0x1a
    375e:	9b 8f       	std	Y+27, r25	; 0x1b
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    3760:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3762:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3764:	fc 01       	movw	r30, r24
    3766:	84 81       	ldd	r24, Z+4	; 0x04
    3768:	89 83       	std	Y+1, r24	; 0x01

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    376a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    376c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    376e:	21 e0       	ldi	r18, 0x01	; 1
    3770:	fc 01       	movw	r30, r24
    3772:	24 83       	std	Z+4, r18	; 0x04
    3774:	80 e0       	ldi	r24, 0x00	; 0
    3776:	90 e0       	ldi	r25, 0x00	; 0
    3778:	a0 e0       	ldi	r26, 0x00	; 0
    377a:	b3 e4       	ldi	r27, 0x43	; 67
    377c:	8a 83       	std	Y+2, r24	; 0x02
    377e:	9b 83       	std	Y+3, r25	; 0x03
    3780:	ac 83       	std	Y+4, r26	; 0x04
    3782:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3784:	6a 81       	ldd	r22, Y+2	; 0x02
    3786:	7b 81       	ldd	r23, Y+3	; 0x03
    3788:	8c 81       	ldd	r24, Y+4	; 0x04
    378a:	9d 81       	ldd	r25, Y+5	; 0x05
    378c:	2b ea       	ldi	r18, 0xAB	; 171
    378e:	3a ea       	ldi	r19, 0xAA	; 170
    3790:	4a e2       	ldi	r20, 0x2A	; 42
    3792:	5f e3       	ldi	r21, 0x3F	; 63
    3794:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    3798:	dc 01       	movw	r26, r24
    379a:	cb 01       	movw	r24, r22
    379c:	8e 83       	std	Y+6, r24	; 0x06
    379e:	9f 83       	std	Y+7, r25	; 0x07
    37a0:	a8 87       	std	Y+8, r26	; 0x08
    37a2:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    37a4:	11 e0       	ldi	r17, 0x01	; 1
    37a6:	6e 81       	ldd	r22, Y+6	; 0x06
    37a8:	7f 81       	ldd	r23, Y+7	; 0x07
    37aa:	88 85       	ldd	r24, Y+8	; 0x08
    37ac:	99 85       	ldd	r25, Y+9	; 0x09
    37ae:	20 e0       	ldi	r18, 0x00	; 0
    37b0:	30 e0       	ldi	r19, 0x00	; 0
    37b2:	40 e8       	ldi	r20, 0x80	; 128
    37b4:	5f e3       	ldi	r21, 0x3F	; 63
    37b6:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    37ba:	88 23       	and	r24, r24
    37bc:	0c f0       	brlt	.+2      	; 0x37c0 <ADC_Wait_32MHz+0x76>
    37be:	10 e0       	ldi	r17, 0x00	; 0
    37c0:	11 23       	and	r17, r17
    37c2:	19 f0       	breq	.+6      	; 0x37ca <ADC_Wait_32MHz+0x80>
		__ticks = 1;
    37c4:	81 e0       	ldi	r24, 0x01	; 1
    37c6:	8a 87       	std	Y+10, r24	; 0x0a
    37c8:	a3 c0       	rjmp	.+326    	; 0x3910 <ADC_Wait_32MHz+0x1c6>
	else if (__tmp > 255)
    37ca:	11 e0       	ldi	r17, 0x01	; 1
    37cc:	6e 81       	ldd	r22, Y+6	; 0x06
    37ce:	7f 81       	ldd	r23, Y+7	; 0x07
    37d0:	88 85       	ldd	r24, Y+8	; 0x08
    37d2:	99 85       	ldd	r25, Y+9	; 0x09
    37d4:	20 e0       	ldi	r18, 0x00	; 0
    37d6:	30 e0       	ldi	r19, 0x00	; 0
    37d8:	4f e7       	ldi	r20, 0x7F	; 127
    37da:	53 e4       	ldi	r21, 0x43	; 67
    37dc:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    37e0:	18 16       	cp	r1, r24
    37e2:	0c f0       	brlt	.+2      	; 0x37e6 <ADC_Wait_32MHz+0x9c>
    37e4:	10 e0       	ldi	r17, 0x00	; 0
    37e6:	11 23       	and	r17, r17
    37e8:	09 f4       	brne	.+2      	; 0x37ec <ADC_Wait_32MHz+0xa2>
    37ea:	89 c0       	rjmp	.+274    	; 0x38fe <ADC_Wait_32MHz+0x1b4>
	{
		_delay_ms(__us / 1000.0);
    37ec:	6a 81       	ldd	r22, Y+2	; 0x02
    37ee:	7b 81       	ldd	r23, Y+3	; 0x03
    37f0:	8c 81       	ldd	r24, Y+4	; 0x04
    37f2:	9d 81       	ldd	r25, Y+5	; 0x05
    37f4:	20 e0       	ldi	r18, 0x00	; 0
    37f6:	30 e0       	ldi	r19, 0x00	; 0
    37f8:	4a e7       	ldi	r20, 0x7A	; 122
    37fa:	54 e4       	ldi	r21, 0x44	; 68
    37fc:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
    3800:	dc 01       	movw	r26, r24
    3802:	cb 01       	movw	r24, r22
    3804:	8b 87       	std	Y+11, r24	; 0x0b
    3806:	9c 87       	std	Y+12, r25	; 0x0c
    3808:	ad 87       	std	Y+13, r26	; 0x0d
    380a:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    380c:	6b 85       	ldd	r22, Y+11	; 0x0b
    380e:	7c 85       	ldd	r23, Y+12	; 0x0c
    3810:	8d 85       	ldd	r24, Y+13	; 0x0d
    3812:	9e 85       	ldd	r25, Y+14	; 0x0e
    3814:	20 e0       	ldi	r18, 0x00	; 0
    3816:	30 e0       	ldi	r19, 0x00	; 0
    3818:	4a ef       	ldi	r20, 0xFA	; 250
    381a:	53 e4       	ldi	r21, 0x43	; 67
    381c:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    3820:	dc 01       	movw	r26, r24
    3822:	cb 01       	movw	r24, r22
    3824:	8f 87       	std	Y+15, r24	; 0x0f
    3826:	98 8b       	std	Y+16, r25	; 0x10
    3828:	a9 8b       	std	Y+17, r26	; 0x11
    382a:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    382c:	11 e0       	ldi	r17, 0x01	; 1
    382e:	6f 85       	ldd	r22, Y+15	; 0x0f
    3830:	78 89       	ldd	r23, Y+16	; 0x10
    3832:	89 89       	ldd	r24, Y+17	; 0x11
    3834:	9a 89       	ldd	r25, Y+18	; 0x12
    3836:	20 e0       	ldi	r18, 0x00	; 0
    3838:	30 e0       	ldi	r19, 0x00	; 0
    383a:	40 e8       	ldi	r20, 0x80	; 128
    383c:	5f e3       	ldi	r21, 0x3F	; 63
    383e:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    3842:	88 23       	and	r24, r24
    3844:	0c f0       	brlt	.+2      	; 0x3848 <ADC_Wait_32MHz+0xfe>
    3846:	10 e0       	ldi	r17, 0x00	; 0
    3848:	11 23       	and	r17, r17
    384a:	29 f0       	breq	.+10     	; 0x3856 <ADC_Wait_32MHz+0x10c>
		__ticks = 1;
    384c:	81 e0       	ldi	r24, 0x01	; 1
    384e:	90 e0       	ldi	r25, 0x00	; 0
    3850:	8b 8b       	std	Y+19, r24	; 0x13
    3852:	9c 8b       	std	Y+20, r25	; 0x14
    3854:	46 c0       	rjmp	.+140    	; 0x38e2 <ADC_Wait_32MHz+0x198>
	else if (__tmp > 65535)
    3856:	11 e0       	ldi	r17, 0x01	; 1
    3858:	6f 85       	ldd	r22, Y+15	; 0x0f
    385a:	78 89       	ldd	r23, Y+16	; 0x10
    385c:	89 89       	ldd	r24, Y+17	; 0x11
    385e:	9a 89       	ldd	r25, Y+18	; 0x12
    3860:	20 e0       	ldi	r18, 0x00	; 0
    3862:	3f ef       	ldi	r19, 0xFF	; 255
    3864:	4f e7       	ldi	r20, 0x7F	; 127
    3866:	57 e4       	ldi	r21, 0x47	; 71
    3868:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    386c:	18 16       	cp	r1, r24
    386e:	0c f0       	brlt	.+2      	; 0x3872 <ADC_Wait_32MHz+0x128>
    3870:	10 e0       	ldi	r17, 0x00	; 0
    3872:	11 23       	and	r17, r17
    3874:	61 f1       	breq	.+88     	; 0x38ce <ADC_Wait_32MHz+0x184>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3876:	6b 85       	ldd	r22, Y+11	; 0x0b
    3878:	7c 85       	ldd	r23, Y+12	; 0x0c
    387a:	8d 85       	ldd	r24, Y+13	; 0x0d
    387c:	9e 85       	ldd	r25, Y+14	; 0x0e
    387e:	20 e0       	ldi	r18, 0x00	; 0
    3880:	30 e0       	ldi	r19, 0x00	; 0
    3882:	40 e2       	ldi	r20, 0x20	; 32
    3884:	51 e4       	ldi	r21, 0x41	; 65
    3886:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    388a:	dc 01       	movw	r26, r24
    388c:	cb 01       	movw	r24, r22
    388e:	bc 01       	movw	r22, r24
    3890:	cd 01       	movw	r24, r26
    3892:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    3896:	dc 01       	movw	r26, r24
    3898:	cb 01       	movw	r24, r22
    389a:	8b 8b       	std	Y+19, r24	; 0x13
    389c:	9c 8b       	std	Y+20, r25	; 0x14
    389e:	12 c0       	rjmp	.+36     	; 0x38c4 <ADC_Wait_32MHz+0x17a>
    38a0:	82 e3       	ldi	r24, 0x32	; 50
    38a2:	90 e0       	ldi	r25, 0x00	; 0
    38a4:	8d 8b       	std	Y+21, r24	; 0x15
    38a6:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    38a8:	8d 89       	ldd	r24, Y+21	; 0x15
    38aa:	9e 89       	ldd	r25, Y+22	; 0x16
    38ac:	8c 01       	movw	r16, r24
    38ae:	c8 01       	movw	r24, r16
    38b0:	01 97       	sbiw	r24, 0x01	; 1
    38b2:	f1 f7       	brne	.-4      	; 0x38b0 <ADC_Wait_32MHz+0x166>
    38b4:	8c 01       	movw	r16, r24
    38b6:	0d 8b       	std	Y+21, r16	; 0x15
    38b8:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    38ba:	8b 89       	ldd	r24, Y+19	; 0x13
    38bc:	9c 89       	ldd	r25, Y+20	; 0x14
    38be:	01 97       	sbiw	r24, 0x01	; 1
    38c0:	8b 8b       	std	Y+19, r24	; 0x13
    38c2:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    38c4:	8b 89       	ldd	r24, Y+19	; 0x13
    38c6:	9c 89       	ldd	r25, Y+20	; 0x14
    38c8:	00 97       	sbiw	r24, 0x00	; 0
    38ca:	51 f7       	brne	.-44     	; 0x38a0 <ADC_Wait_32MHz+0x156>
    38cc:	28 c0       	rjmp	.+80     	; 0x391e <ADC_Wait_32MHz+0x1d4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    38ce:	6f 85       	ldd	r22, Y+15	; 0x0f
    38d0:	78 89       	ldd	r23, Y+16	; 0x10
    38d2:	89 89       	ldd	r24, Y+17	; 0x11
    38d4:	9a 89       	ldd	r25, Y+18	; 0x12
    38d6:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    38da:	dc 01       	movw	r26, r24
    38dc:	cb 01       	movw	r24, r22
    38de:	8b 8b       	std	Y+19, r24	; 0x13
    38e0:	9c 8b       	std	Y+20, r25	; 0x14
    38e2:	8b 89       	ldd	r24, Y+19	; 0x13
    38e4:	9c 89       	ldd	r25, Y+20	; 0x14
    38e6:	8f 8b       	std	Y+23, r24	; 0x17
    38e8:	98 8f       	std	Y+24, r25	; 0x18
    38ea:	8f 89       	ldd	r24, Y+23	; 0x17
    38ec:	98 8d       	ldd	r25, Y+24	; 0x18
    38ee:	8c 01       	movw	r16, r24
    38f0:	f8 01       	movw	r30, r16
    38f2:	31 97       	sbiw	r30, 0x01	; 1
    38f4:	f1 f7       	brne	.-4      	; 0x38f2 <ADC_Wait_32MHz+0x1a8>
    38f6:	8f 01       	movw	r16, r30
    38f8:	0f 8b       	std	Y+23, r16	; 0x17
    38fa:	18 8f       	std	Y+24, r17	; 0x18
    38fc:	10 c0       	rjmp	.+32     	; 0x391e <ADC_Wait_32MHz+0x1d4>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    38fe:	6e 81       	ldd	r22, Y+6	; 0x06
    3900:	7f 81       	ldd	r23, Y+7	; 0x07
    3902:	88 85       	ldd	r24, Y+8	; 0x08
    3904:	99 85       	ldd	r25, Y+9	; 0x09
    3906:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    390a:	dc 01       	movw	r26, r24
    390c:	cb 01       	movw	r24, r22
    390e:	8a 87       	std	Y+10, r24	; 0x0a
    3910:	8a 85       	ldd	r24, Y+10	; 0x0a
    3912:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3914:	89 8d       	ldd	r24, Y+25	; 0x19
    3916:	18 2f       	mov	r17, r24
    3918:	1a 95       	dec	r17
    391a:	f1 f7       	brne	.-4      	; 0x3918 <ADC_Wait_32MHz+0x1ce>
    391c:	19 8f       	std	Y+25, r17	; 0x19

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    391e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3920:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3922:	29 81       	ldd	r18, Y+1	; 0x01
    3924:	fc 01       	movw	r30, r24
    3926:	24 83       	std	Z+4, r18	; 0x04
}
    3928:	6b 96       	adiw	r28, 0x1b	; 27
    392a:	cd bf       	out	0x3d, r28	; 61
    392c:	de bf       	out	0x3e, r29	; 62
    392e:	df 91       	pop	r29
    3930:	cf 91       	pop	r28
    3932:	1f 91       	pop	r17
    3934:	0f 91       	pop	r16
    3936:	08 95       	ret

00003938 <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3938:	cf 93       	push	r28
    393a:	df 93       	push	r29
    393c:	cd b7       	in	r28, 0x3d	; 61
    393e:	de b7       	in	r29, 0x3e	; 62
    3940:	2a 97       	sbiw	r28, 0x0a	; 10
    3942:	cd bf       	out	0x3d, r28	; 61
    3944:	de bf       	out	0x3e, r29	; 62
    3946:	8e 83       	std	Y+6, r24	; 0x06
    3948:	9f 83       	std	Y+7, r25	; 0x07
    394a:	68 87       	std	Y+8, r22	; 0x08
    394c:	79 87       	std	Y+9, r23	; 0x09
    394e:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3950:	8a 85       	ldd	r24, Y+10	; 0x0a
    3952:	88 23       	and	r24, r24
    3954:	a9 f1       	breq	.+106    	; 0x39c0 <ADC_Offset_Get_Unsigned+0x88>
    {
      uint16_t offset=0;
    3956:	19 82       	std	Y+1, r1	; 0x01
    3958:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    395a:	1b 82       	std	Y+3, r1	; 0x03
    395c:	1c 82       	std	Y+4, r1	; 0x04
    395e:	24 c0       	rjmp	.+72     	; 0x39a8 <ADC_Offset_Get_Unsigned+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3960:	88 85       	ldd	r24, Y+8	; 0x08
    3962:	99 85       	ldd	r25, Y+9	; 0x09
    3964:	fc 01       	movw	r30, r24
    3966:	80 81       	ld	r24, Z
    3968:	28 2f       	mov	r18, r24
    396a:	20 68       	ori	r18, 0x80	; 128
    396c:	88 85       	ldd	r24, Y+8	; 0x08
    396e:	99 85       	ldd	r25, Y+9	; 0x09
    3970:	fc 01       	movw	r30, r24
    3972:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3974:	88 85       	ldd	r24, Y+8	; 0x08
    3976:	99 85       	ldd	r25, Y+9	; 0x09
    3978:	fc 01       	movw	r30, r24
    397a:	83 81       	ldd	r24, Z+3	; 0x03
    397c:	88 2f       	mov	r24, r24
    397e:	90 e0       	ldi	r25, 0x00	; 0
    3980:	81 70       	andi	r24, 0x01	; 1
    3982:	90 70       	andi	r25, 0x00	; 0
    3984:	00 97       	sbiw	r24, 0x00	; 0
    3986:	b1 f3       	breq	.-20     	; 0x3974 <ADC_Offset_Get_Unsigned+0x3c>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    3988:	88 85       	ldd	r24, Y+8	; 0x08
    398a:	99 85       	ldd	r25, Y+9	; 0x09
    398c:	60 e0       	ldi	r22, 0x00	; 0
    398e:	0e 94 21 1a 	call	0x3442	; 0x3442 <ADC_ResultCh_GetWord_Unsigned>
    3992:	29 81       	ldd	r18, Y+1	; 0x01
    3994:	3a 81       	ldd	r19, Y+2	; 0x02
    3996:	82 0f       	add	r24, r18
    3998:	93 1f       	adc	r25, r19
    399a:	89 83       	std	Y+1, r24	; 0x01
    399c:	9a 83       	std	Y+2, r25	; 0x02
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    399e:	8b 81       	ldd	r24, Y+3	; 0x03
    39a0:	9c 81       	ldd	r25, Y+4	; 0x04
    39a2:	01 96       	adiw	r24, 0x01	; 1
    39a4:	8b 83       	std	Y+3, r24	; 0x03
    39a6:	9c 83       	std	Y+4, r25	; 0x04
    39a8:	8b 81       	ldd	r24, Y+3	; 0x03
    39aa:	9c 81       	ldd	r25, Y+4	; 0x04
    39ac:	84 30       	cpi	r24, 0x04	; 4
    39ae:	91 05       	cpc	r25, r1
    39b0:	bc f2       	brlt	.-82     	; 0x3960 <ADC_Offset_Get_Unsigned+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    39b2:	89 81       	ldd	r24, Y+1	; 0x01
    39b4:	9a 81       	ldd	r25, Y+2	; 0x02
    39b6:	96 95       	lsr	r25
    39b8:	87 95       	ror	r24
    39ba:	96 95       	lsr	r25
    39bc:	87 95       	ror	r24
    39be:	1b c0       	rjmp	.+54     	; 0x39f6 <ADC_Offset_Get_Unsigned+0xbe>
    }
    else
    {        
      uint8_t offset=0;
    39c0:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    39c2:	88 85       	ldd	r24, Y+8	; 0x08
    39c4:	99 85       	ldd	r25, Y+9	; 0x09
    39c6:	fc 01       	movw	r30, r24
    39c8:	80 81       	ld	r24, Z
    39ca:	28 2f       	mov	r18, r24
    39cc:	20 68       	ori	r18, 0x80	; 128
    39ce:	88 85       	ldd	r24, Y+8	; 0x08
    39d0:	99 85       	ldd	r25, Y+9	; 0x09
    39d2:	fc 01       	movw	r30, r24
    39d4:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    39d6:	88 85       	ldd	r24, Y+8	; 0x08
    39d8:	99 85       	ldd	r25, Y+9	; 0x09
    39da:	fc 01       	movw	r30, r24
    39dc:	83 81       	ldd	r24, Z+3	; 0x03
    39de:	88 2f       	mov	r24, r24
    39e0:	90 e0       	ldi	r25, 0x00	; 0
    39e2:	81 70       	andi	r24, 0x01	; 1
    39e4:	90 70       	andi	r25, 0x00	; 0
    39e6:	00 97       	sbiw	r24, 0x00	; 0
    39e8:	b1 f3       	breq	.-20     	; 0x39d6 <ADC_Offset_Get_Unsigned+0x9e>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    39ea:	88 85       	ldd	r24, Y+8	; 0x08
    39ec:	99 85       	ldd	r25, Y+9	; 0x09
    39ee:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <ADC_ResultCh_GetWord>
    39f2:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    39f4:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    39f6:	2a 96       	adiw	r28, 0x0a	; 10
    39f8:	cd bf       	out	0x3d, r28	; 61
    39fa:	de bf       	out	0x3e, r29	; 62
    39fc:	df 91       	pop	r29
    39fe:	cf 91       	pop	r28
    3a00:	08 95       	ret

00003a02 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    3a02:	cf 93       	push	r28
    3a04:	df 93       	push	r29
    3a06:	cd b7       	in	r28, 0x3d	; 61
    3a08:	de b7       	in	r29, 0x3e	; 62
    3a0a:	2a 97       	sbiw	r28, 0x0a	; 10
    3a0c:	cd bf       	out	0x3d, r28	; 61
    3a0e:	de bf       	out	0x3e, r29	; 62
    3a10:	8e 83       	std	Y+6, r24	; 0x06
    3a12:	9f 83       	std	Y+7, r25	; 0x07
    3a14:	68 87       	std	Y+8, r22	; 0x08
    3a16:	79 87       	std	Y+9, r23	; 0x09
    3a18:	4a 87       	std	Y+10, r20	; 0x0a
    if (oversampling)
    3a1a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a1c:	88 23       	and	r24, r24
    3a1e:	c1 f1       	breq	.+112    	; 0x3a90 <ADC_Offset_Get_Signed+0x8e>
    {
      int16_t offset=0;
    3a20:	19 82       	std	Y+1, r1	; 0x01
    3a22:	1a 82       	std	Y+2, r1	; 0x02
      for (int i=0; i<4; i++)
    3a24:	1b 82       	std	Y+3, r1	; 0x03
    3a26:	1c 82       	std	Y+4, r1	; 0x04
    3a28:	24 c0       	rjmp	.+72     	; 0x3a72 <ADC_Offset_Get_Signed+0x70>
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    3a2a:	88 85       	ldd	r24, Y+8	; 0x08
    3a2c:	99 85       	ldd	r25, Y+9	; 0x09
    3a2e:	fc 01       	movw	r30, r24
    3a30:	80 81       	ld	r24, Z
    3a32:	28 2f       	mov	r18, r24
    3a34:	20 68       	ori	r18, 0x80	; 128
    3a36:	88 85       	ldd	r24, Y+8	; 0x08
    3a38:	99 85       	ldd	r25, Y+9	; 0x09
    3a3a:	fc 01       	movw	r30, r24
    3a3c:	20 83       	st	Z, r18
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    3a3e:	88 85       	ldd	r24, Y+8	; 0x08
    3a40:	99 85       	ldd	r25, Y+9	; 0x09
    3a42:	fc 01       	movw	r30, r24
    3a44:	83 81       	ldd	r24, Z+3	; 0x03
    3a46:	88 2f       	mov	r24, r24
    3a48:	90 e0       	ldi	r25, 0x00	; 0
    3a4a:	81 70       	andi	r24, 0x01	; 1
    3a4c:	90 70       	andi	r25, 0x00	; 0
    3a4e:	00 97       	sbiw	r24, 0x00	; 0
    3a50:	b1 f3       	breq	.-20     	; 0x3a3e <ADC_Offset_Get_Signed+0x3c>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3a52:	88 85       	ldd	r24, Y+8	; 0x08
    3a54:	99 85       	ldd	r25, Y+9	; 0x09
    3a56:	60 e0       	ldi	r22, 0x00	; 0
    3a58:	0e 94 46 1a 	call	0x348c	; 0x348c <ADC_ResultCh_GetWord_Signed>
    3a5c:	29 81       	ldd	r18, Y+1	; 0x01
    3a5e:	3a 81       	ldd	r19, Y+2	; 0x02
    3a60:	82 0f       	add	r24, r18
    3a62:	93 1f       	adc	r25, r19
    3a64:	89 83       	std	Y+1, r24	; 0x01
    3a66:	9a 83       	std	Y+2, r25	; 0x02
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    3a68:	8b 81       	ldd	r24, Y+3	; 0x03
    3a6a:	9c 81       	ldd	r25, Y+4	; 0x04
    3a6c:	01 96       	adiw	r24, 0x01	; 1
    3a6e:	8b 83       	std	Y+3, r24	; 0x03
    3a70:	9c 83       	std	Y+4, r25	; 0x04
    3a72:	8b 81       	ldd	r24, Y+3	; 0x03
    3a74:	9c 81       	ldd	r25, Y+4	; 0x04
    3a76:	84 30       	cpi	r24, 0x04	; 4
    3a78:	91 05       	cpc	r25, r1
    3a7a:	bc f2       	brlt	.-82     	; 0x3a2a <ADC_Offset_Get_Signed+0x28>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    3a7c:	89 81       	ldd	r24, Y+1	; 0x01
    3a7e:	9a 81       	ldd	r25, Y+2	; 0x02
    3a80:	99 23       	and	r25, r25
    3a82:	0c f4       	brge	.+2      	; 0x3a86 <ADC_Offset_Get_Signed+0x84>
    3a84:	03 96       	adiw	r24, 0x03	; 3
    3a86:	95 95       	asr	r25
    3a88:	87 95       	ror	r24
    3a8a:	95 95       	asr	r25
    3a8c:	87 95       	ror	r24
    3a8e:	1c c0       	rjmp	.+56     	; 0x3ac8 <ADC_Offset_Get_Signed+0xc6>
    }
    else
    {        
      int8_t offset=0;
    3a90:	1d 82       	std	Y+5, r1	; 0x05
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    3a92:	88 85       	ldd	r24, Y+8	; 0x08
    3a94:	99 85       	ldd	r25, Y+9	; 0x09
    3a96:	fc 01       	movw	r30, r24
    3a98:	80 81       	ld	r24, Z
    3a9a:	28 2f       	mov	r18, r24
    3a9c:	20 68       	ori	r18, 0x80	; 128
    3a9e:	88 85       	ldd	r24, Y+8	; 0x08
    3aa0:	99 85       	ldd	r25, Y+9	; 0x09
    3aa2:	fc 01       	movw	r30, r24
    3aa4:	20 83       	st	Z, r18
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    3aa6:	88 85       	ldd	r24, Y+8	; 0x08
    3aa8:	99 85       	ldd	r25, Y+9	; 0x09
    3aaa:	fc 01       	movw	r30, r24
    3aac:	83 81       	ldd	r24, Z+3	; 0x03
    3aae:	88 2f       	mov	r24, r24
    3ab0:	90 e0       	ldi	r25, 0x00	; 0
    3ab2:	81 70       	andi	r24, 0x01	; 1
    3ab4:	90 70       	andi	r25, 0x00	; 0
    3ab6:	00 97       	sbiw	r24, 0x00	; 0
    3ab8:	b1 f3       	breq	.-20     	; 0x3aa6 <ADC_Offset_Get_Signed+0xa4>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    3aba:	88 85       	ldd	r24, Y+8	; 0x08
    3abc:	99 85       	ldd	r25, Y+9	; 0x09
    3abe:	60 e0       	ldi	r22, 0x00	; 0
    3ac0:	0e 94 46 1a 	call	0x348c	; 0x348c <ADC_ResultCh_GetWord_Signed>
    3ac4:	8d 83       	std	Y+5, r24	; 0x05
      
      return offset;
    3ac6:	8d 81       	ldd	r24, Y+5	; 0x05
    }
}
    3ac8:	2a 96       	adiw	r28, 0x0a	; 10
    3aca:	cd bf       	out	0x3d, r28	; 61
    3acc:	de bf       	out	0x3e, r29	; 62
    3ace:	df 91       	pop	r29
    3ad0:	cf 91       	pop	r28
    3ad2:	08 95       	ret

00003ad4 <SP_ReadCalibrationByte>:
 *  \param index The index to the calibration byte.
 *
 *  \return Calibration byte.
 */
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
    3ad4:	1f 93       	push	r17
    3ad6:	cf 93       	push	r28
    3ad8:	df 93       	push	r29
    3ada:	cd b7       	in	r28, 0x3d	; 61
    3adc:	de b7       	in	r29, 0x3e	; 62
    3ade:	25 97       	sbiw	r28, 0x05	; 5
    3ae0:	cd bf       	out	0x3d, r28	; 61
    3ae2:	de bf       	out	0x3e, r29	; 62
    3ae4:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    3ae6:	8a ec       	ldi	r24, 0xCA	; 202
    3ae8:	91 e0       	ldi	r25, 0x01	; 1
    3aea:	22 e0       	ldi	r18, 0x02	; 2
    3aec:	fc 01       	movw	r30, r24
    3aee:	20 83       	st	Z, r18
 	result = pgm_read_byte(index);
    3af0:	8d 81       	ldd	r24, Y+5	; 0x05
    3af2:	88 2f       	mov	r24, r24
    3af4:	90 e0       	ldi	r25, 0x00	; 0
    3af6:	89 83       	std	Y+1, r24	; 0x01
    3af8:	9a 83       	std	Y+2, r25	; 0x02
    3afa:	89 81       	ldd	r24, Y+1	; 0x01
    3afc:	9a 81       	ldd	r25, Y+2	; 0x02
    3afe:	fc 01       	movw	r30, r24
    3b00:	14 91       	lpm	r17, Z
    3b02:	1b 83       	std	Y+3, r17	; 0x03
    3b04:	8b 81       	ldd	r24, Y+3	; 0x03
    3b06:	8c 83       	std	Y+4, r24	; 0x04

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    3b08:	8a ec       	ldi	r24, 0xCA	; 202
    3b0a:	91 e0       	ldi	r25, 0x01	; 1
    3b0c:	fc 01       	movw	r30, r24
    3b0e:	10 82       	st	Z, r1

	return result;
    3b10:	8c 81       	ldd	r24, Y+4	; 0x04
}
    3b12:	25 96       	adiw	r28, 0x05	; 5
    3b14:	cd bf       	out	0x3d, r28	; 61
    3b16:	de bf       	out	0x3e, r29	; 62
    3b18:	df 91       	pop	r29
    3b1a:	cf 91       	pop	r28
    3b1c:	1f 91       	pop	r17
    3b1e:	08 95       	ret

00003b20 <chb_init>:
/*!

*/
/**************************************************************************/
void chb_init()
{
    3b20:	cf 93       	push	r28
    3b22:	df 93       	push	r29
    3b24:	cd b7       	in	r28, 0x3d	; 61
    3b26:	de b7       	in	r29, 0x3e	; 62
    memset(&pcb, 0, sizeof(pcb_t));
    3b28:	24 e1       	ldi	r18, 0x14	; 20
    3b2a:	88 e3       	ldi	r24, 0x38	; 56
    3b2c:	91 e2       	ldi	r25, 0x21	; 33
    3b2e:	fc 01       	movw	r30, r24
    3b30:	32 2f       	mov	r19, r18
    3b32:	11 92       	st	Z+, r1
    3b34:	3a 95       	dec	r19
    3b36:	e9 f7       	brne	.-6      	; 0x3b32 <chb_init+0x12>
    pcb.src_addr = chb_get_short_addr();
    3b38:	0e 94 56 2b 	call	0x56ac	; 0x56ac <chb_get_short_addr>
    3b3c:	80 93 38 21 	sts	0x2138, r24
    3b40:	90 93 39 21 	sts	0x2139, r25
    chb_drvr_init();
    3b44:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <chb_drvr_init>
	radio_msg_received_int_enable();
    3b48:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <radio_msg_received_int_enable>
}
    3b4c:	df 91       	pop	r29
    3b4e:	cf 91       	pop	r28
    3b50:	08 95       	ret

00003b52 <radio_msg_received_int_enable>:

// Configure PE2 to use as proxy interrupt for data being stored in radio buffer
void radio_msg_received_int_enable(){
    3b52:	cf 93       	push	r28
    3b54:	df 93       	push	r29
    3b56:	cd b7       	in	r28, 0x3d	; 61
    3b58:	de b7       	in	r29, 0x3e	; 62
	PORTE.DIRSET = PIN2_bm;
    3b5a:	80 e8       	ldi	r24, 0x80	; 128
    3b5c:	96 e0       	ldi	r25, 0x06	; 6
    3b5e:	24 e0       	ldi	r18, 0x04	; 4
    3b60:	fc 01       	movw	r30, r24
    3b62:	21 83       	std	Z+1, r18	; 0x01
	PORTE.OUTCLR = PIN2_bm;
    3b64:	80 e8       	ldi	r24, 0x80	; 128
    3b66:	96 e0       	ldi	r25, 0x06	; 6
    3b68:	24 e0       	ldi	r18, 0x04	; 4
    3b6a:	fc 01       	movw	r30, r24
    3b6c:	26 83       	std	Z+6, r18	; 0x06
	PORTE.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    3b6e:	80 e8       	ldi	r24, 0x80	; 128
    3b70:	96 e0       	ldi	r25, 0x06	; 6
    3b72:	22 e0       	ldi	r18, 0x02	; 2
    3b74:	fc 01       	movw	r30, r24
    3b76:	20 8b       	std	Z+16, r18	; 0x10
	PORTE.INT0MASK = PIN2_bm;
    3b78:	80 e8       	ldi	r24, 0x80	; 128
    3b7a:	96 e0       	ldi	r25, 0x06	; 6
    3b7c:	24 e0       	ldi	r18, 0x04	; 4
    3b7e:	fc 01       	movw	r30, r24
    3b80:	22 87       	std	Z+10, r18	; 0x0a
	PORTE.INTCTRL = PORT_INT0LVL_HI_gc;
    3b82:	80 e8       	ldi	r24, 0x80	; 128
    3b84:	96 e0       	ldi	r25, 0x06	; 6
    3b86:	23 e0       	ldi	r18, 0x03	; 3
    3b88:	fc 01       	movw	r30, r24
    3b8a:	21 87       	std	Z+9, r18	; 0x09
	// Enable low level interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm;
    3b8c:	80 ea       	ldi	r24, 0xA0	; 160
    3b8e:	90 e0       	ldi	r25, 0x00	; 0
    3b90:	20 ea       	ldi	r18, 0xA0	; 160
    3b92:	30 e0       	ldi	r19, 0x00	; 0
    3b94:	f9 01       	movw	r30, r18
    3b96:	22 81       	ldd	r18, Z+2	; 0x02
    3b98:	24 60       	ori	r18, 0x04	; 4
    3b9a:	fc 01       	movw	r30, r24
    3b9c:	22 83       	std	Z+2, r18	; 0x02
	sei();
    3b9e:	78 94       	sei
}
    3ba0:	df 91       	pop	r29
    3ba2:	cf 91       	pop	r28
    3ba4:	08 95       	ret

00003ba6 <chb_get_pcb>:
/*!

*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    3ba6:	cf 93       	push	r28
    3ba8:	df 93       	push	r29
    3baa:	cd b7       	in	r28, 0x3d	; 61
    3bac:	de b7       	in	r29, 0x3e	; 62
    return &pcb;
    3bae:	88 e3       	ldi	r24, 0x38	; 56
    3bb0:	91 e2       	ldi	r25, 0x21	; 33
}
    3bb2:	df 91       	pop	r29
    3bb4:	cf 91       	pop	r28
    3bb6:	08 95       	ret

00003bb8 <chb_gen_hdr>:
    Requires the dest addr, location to store data, and len of payload.
    Returns the length of the hdr. 
*/
/**************************************************************************/
static U8 chb_gen_hdr(U8 *hdr, U16 addr, U8 len)
{
    3bb8:	cf 93       	push	r28
    3bba:	df 93       	push	r29
    3bbc:	cd b7       	in	r28, 0x3d	; 61
    3bbe:	de b7       	in	r29, 0x3e	; 62
    3bc0:	27 97       	sbiw	r28, 0x07	; 7
    3bc2:	cd bf       	out	0x3d, r28	; 61
    3bc4:	de bf       	out	0x3e, r29	; 62
    3bc6:	8b 83       	std	Y+3, r24	; 0x03
    3bc8:	9c 83       	std	Y+4, r25	; 0x04
    3bca:	6d 83       	std	Y+5, r22	; 0x05
    3bcc:	7e 83       	std	Y+6, r23	; 0x06
    3bce:	4f 83       	std	Y+7, r20	; 0x07
    U8 *hdr_ptr = hdr;
    3bd0:	8b 81       	ldd	r24, Y+3	; 0x03
    3bd2:	9c 81       	ldd	r25, Y+4	; 0x04
    3bd4:	89 83       	std	Y+1, r24	; 0x01
    3bd6:	9a 83       	std	Y+2, r25	; 0x02

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    3bd8:	8f 81       	ldd	r24, Y+7	; 0x07
    3bda:	28 2f       	mov	r18, r24
    3bdc:	25 5f       	subi	r18, 0xF5	; 245
    3bde:	89 81       	ldd	r24, Y+1	; 0x01
    3be0:	9a 81       	ldd	r25, Y+2	; 0x02
    3be2:	fc 01       	movw	r30, r24
    3be4:	20 83       	st	Z, r18
    3be6:	89 81       	ldd	r24, Y+1	; 0x01
    3be8:	9a 81       	ldd	r25, Y+2	; 0x02
    3bea:	01 96       	adiw	r24, 0x01	; 1
    3bec:	89 83       	std	Y+1, r24	; 0x01
    3bee:	9a 83       	std	Y+2, r25	; 0x02

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    3bf0:	8d 81       	ldd	r24, Y+5	; 0x05
    3bf2:	9e 81       	ldd	r25, Y+6	; 0x06
    3bf4:	ff ef       	ldi	r31, 0xFF	; 255
    3bf6:	8f 3f       	cpi	r24, 0xFF	; 255
    3bf8:	9f 07       	cpc	r25, r31
    3bfa:	11 f0       	breq	.+4      	; 0x3c00 <chb_gen_hdr+0x48>
    3bfc:	21 e6       	ldi	r18, 0x61	; 97
    3bfe:	01 c0       	rjmp	.+2      	; 0x3c02 <chb_gen_hdr+0x4a>
    3c00:	21 e4       	ldi	r18, 0x41	; 65
    3c02:	89 81       	ldd	r24, Y+1	; 0x01
    3c04:	9a 81       	ldd	r25, Y+2	; 0x02
    3c06:	fc 01       	movw	r30, r24
    3c08:	20 83       	st	Z, r18
    3c0a:	89 81       	ldd	r24, Y+1	; 0x01
    3c0c:	9a 81       	ldd	r25, Y+2	; 0x02
    3c0e:	01 96       	adiw	r24, 0x01	; 1
    3c10:	89 83       	std	Y+1, r24	; 0x01
    3c12:	9a 83       	std	Y+2, r25	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    3c14:	89 81       	ldd	r24, Y+1	; 0x01
    3c16:	9a 81       	ldd	r25, Y+2	; 0x02
    3c18:	28 e9       	ldi	r18, 0x98	; 152
    3c1a:	fc 01       	movw	r30, r24
    3c1c:	20 83       	st	Z, r18
    3c1e:	89 81       	ldd	r24, Y+1	; 0x01
    3c20:	9a 81       	ldd	r25, Y+2	; 0x02
    3c22:	01 96       	adiw	r24, 0x01	; 1
    3c24:	89 83       	std	Y+1, r24	; 0x01
    3c26:	9a 83       	std	Y+2, r25	; 0x02

    *hdr_ptr++ = pcb.seq++;
    3c28:	20 91 3a 21 	lds	r18, 0x213A
    3c2c:	89 81       	ldd	r24, Y+1	; 0x01
    3c2e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c30:	fc 01       	movw	r30, r24
    3c32:	20 83       	st	Z, r18
    3c34:	89 81       	ldd	r24, Y+1	; 0x01
    3c36:	9a 81       	ldd	r25, Y+2	; 0x02
    3c38:	01 96       	adiw	r24, 0x01	; 1
    3c3a:	89 83       	std	Y+1, r24	; 0x01
    3c3c:	9a 83       	std	Y+2, r25	; 0x02
    3c3e:	82 2f       	mov	r24, r18
    3c40:	8f 5f       	subi	r24, 0xFF	; 255
    3c42:	80 93 3a 21 	sts	0x213A, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    3c46:	89 81       	ldd	r24, Y+1	; 0x01
    3c48:	9a 81       	ldd	r25, Y+2	; 0x02
    3c4a:	24 e3       	ldi	r18, 0x34	; 52
    3c4c:	32 e1       	ldi	r19, 0x12	; 18
    3c4e:	fc 01       	movw	r30, r24
    3c50:	20 83       	st	Z, r18
    3c52:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3c54:	89 81       	ldd	r24, Y+1	; 0x01
    3c56:	9a 81       	ldd	r25, Y+2	; 0x02
    3c58:	02 96       	adiw	r24, 0x02	; 2
    3c5a:	89 83       	std	Y+1, r24	; 0x01
    3c5c:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = addr;
    3c5e:	89 81       	ldd	r24, Y+1	; 0x01
    3c60:	9a 81       	ldd	r25, Y+2	; 0x02
    3c62:	2d 81       	ldd	r18, Y+5	; 0x05
    3c64:	3e 81       	ldd	r19, Y+6	; 0x06
    3c66:	fc 01       	movw	r30, r24
    3c68:	20 83       	st	Z, r18
    3c6a:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3c6c:	89 81       	ldd	r24, Y+1	; 0x01
    3c6e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c70:	02 96       	adiw	r24, 0x02	; 2
    3c72:	89 83       	std	Y+1, r24	; 0x01
    3c74:	9a 83       	std	Y+2, r25	; 0x02
    *(U16 *)hdr_ptr = pcb.src_addr;
    3c76:	20 91 38 21 	lds	r18, 0x2138
    3c7a:	30 91 39 21 	lds	r19, 0x2139
    3c7e:	89 81       	ldd	r24, Y+1	; 0x01
    3c80:	9a 81       	ldd	r25, Y+2	; 0x02
    3c82:	fc 01       	movw	r30, r24
    3c84:	20 83       	st	Z, r18
    3c86:	31 83       	std	Z+1, r19	; 0x01
    hdr_ptr += sizeof(U16);
    3c88:	89 81       	ldd	r24, Y+1	; 0x01
    3c8a:	9a 81       	ldd	r25, Y+2	; 0x02
    3c8c:	02 96       	adiw	r24, 0x02	; 2
    3c8e:	89 83       	std	Y+1, r24	; 0x01
    3c90:	9a 83       	std	Y+2, r25	; 0x02
    
    // return the len of the header
    return hdr_ptr - hdr;
    3c92:	29 81       	ldd	r18, Y+1	; 0x01
    3c94:	3a 81       	ldd	r19, Y+2	; 0x02
    3c96:	8b 81       	ldd	r24, Y+3	; 0x03
    3c98:	9c 81       	ldd	r25, Y+4	; 0x04
    3c9a:	a9 01       	movw	r20, r18
    3c9c:	48 1b       	sub	r20, r24
    3c9e:	59 0b       	sbc	r21, r25
    3ca0:	ca 01       	movw	r24, r20
}
    3ca2:	27 96       	adiw	r28, 0x07	; 7
    3ca4:	cd bf       	out	0x3d, r28	; 61
    3ca6:	de bf       	out	0x3e, r29	; 62
    3ca8:	df 91       	pop	r29
    3caa:	cf 91       	pop	r28
    3cac:	08 95       	ret

00003cae <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    3cae:	ef 92       	push	r14
    3cb0:	ff 92       	push	r15
    3cb2:	0f 93       	push	r16
    3cb4:	1f 93       	push	r17
    3cb6:	cf 93       	push	r28
    3cb8:	df 93       	push	r29
    3cba:	cd b7       	in	r28, 0x3d	; 61
    3cbc:	de b7       	in	r29, 0x3e	; 62
    3cbe:	e0 97       	sbiw	r28, 0x30	; 48
    3cc0:	cd bf       	out	0x3d, r28	; 61
    3cc2:	de bf       	out	0x3e, r29	; 62
    3cc4:	89 a7       	lds	r24, 0x79
    3cc6:	9a a7       	lds	r25, 0x7a
    3cc8:	6b a7       	lds	r22, 0x7b
    3cca:	7c a7       	lds	r23, 0x7c
    3ccc:	2d a7       	lds	r18, 0x7d
    3cce:	3e a7       	lds	r19, 0x7e
    3cd0:	4f a7       	lds	r20, 0x7f
    3cd2:	58 ab       	sts	0x58, r21
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    3cd4:	19 82       	std	Y+1, r1	; 0x01
    while (len > 0)
    3cd6:	62 c1       	rjmp	.+708    	; 0x3f9c <chb_write+0x2ee>
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    3cd8:	8d a5       	lds	r24, 0x6d
    3cda:	9e a5       	lds	r25, 0x6e
    3cdc:	af a5       	lds	r26, 0x6f
    3cde:	b8 a9       	sts	0x48, r27
    3ce0:	85 36       	cpi	r24, 0x65	; 101
    3ce2:	91 05       	cpc	r25, r1
    3ce4:	a1 05       	cpc	r26, r1
    3ce6:	b1 05       	cpc	r27, r1
    3ce8:	20 f0       	brcs	.+8      	; 0x3cf2 <chb_write+0x44>
    3cea:	84 e6       	ldi	r24, 0x64	; 100
    3cec:	90 e0       	ldi	r25, 0x00	; 0
    3cee:	a0 e0       	ldi	r26, 0x00	; 0
    3cf0:	b0 e0       	ldi	r27, 0x00	; 0
    3cf2:	8c 83       	std	Y+4, r24	; 0x04

        // gen frame header
        hdr_len = chb_gen_hdr(hdr, addr, frm_len);
    3cf4:	ce 01       	movw	r24, r28
    3cf6:	4f 96       	adiw	r24, 0x1f	; 31
    3cf8:	29 a5       	lds	r18, 0x69
    3cfa:	3a a5       	lds	r19, 0x6a
    3cfc:	b9 01       	movw	r22, r18
    3cfe:	4c 81       	ldd	r20, Y+4	; 0x04
    3d00:	0e 94 dc 1d 	call	0x3bb8	; 0x3bb8 <chb_gen_hdr>
    3d04:	8d 83       	std	Y+5, r24	; 0x05

        // send data to chip
		rtry = 0;
    3d06:	1a 82       	std	Y+2, r1	; 0x02
    3d08:	1b 82       	std	Y+3, r1	; 0x03
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    3d0a:	89 81       	ldd	r24, Y+1	; 0x01
    3d0c:	88 2f       	mov	r24, r24
    3d0e:	90 e0       	ldi	r25, 0x00	; 0
    3d10:	2b a5       	lds	r18, 0x6b
    3d12:	3c a5       	lds	r19, 0x6c
    3d14:	28 0f       	add	r18, r24
    3d16:	39 1f       	adc	r19, r25
    3d18:	ce 01       	movw	r24, r28
    3d1a:	4f 96       	adiw	r24, 0x1f	; 31
    3d1c:	b9 01       	movw	r22, r18
    3d1e:	4c 81       	ldd	r20, Y+4	; 0x04
    3d20:	0e 94 70 2b 	call	0x56e0	; 0x56e0 <chb_tx>
    3d24:	8e 83       	std	Y+6, r24	; 0x06

             switch (status)
    3d26:	8e 81       	ldd	r24, Y+6	; 0x06
    3d28:	88 2f       	mov	r24, r24
    3d2a:	90 e0       	ldi	r25, 0x00	; 0
    3d2c:	83 30       	cpi	r24, 0x03	; 3
    3d2e:	91 05       	cpc	r25, r1
    3d30:	31 f1       	breq	.+76     	; 0x3d7e <chb_write+0xd0>
    3d32:	84 30       	cpi	r24, 0x04	; 4
    3d34:	91 05       	cpc	r25, r1
    3d36:	24 f4       	brge	.+8      	; 0x3d40 <chb_write+0x92>
    3d38:	81 30       	cpi	r24, 0x01	; 1
    3d3a:	91 05       	cpc	r25, r1
    3d3c:	39 f0       	breq	.+14     	; 0x3d4c <chb_write+0x9e>
    3d3e:	2e c0       	rjmp	.+92     	; 0x3d9c <chb_write+0xee>
    3d40:	85 30       	cpi	r24, 0x05	; 5
    3d42:	91 05       	cpc	r25, r1
    3d44:	69 f0       	breq	.+26     	; 0x3d60 <chb_write+0xb2>
    3d46:	80 34       	cpi	r24, 0x40	; 64
    3d48:	91 05       	cpc	r25, r1
    3d4a:	41 f5       	brne	.+80     	; 0x3d9c <chb_write+0xee>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    3d4c:	80 91 3f 21 	lds	r24, 0x213F
    3d50:	90 91 40 21 	lds	r25, 0x2140
    3d54:	01 96       	adiw	r24, 0x01	; 1
    3d56:	80 93 3f 21 	sts	0x213F, r24
    3d5a:	90 93 40 21 	sts	0x2140, r25
                 break;
    3d5e:	1f c0       	rjmp	.+62     	; 0x3d9e <chb_write+0xf0>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    3d60:	80 91 41 21 	lds	r24, 0x2141
    3d64:	90 91 42 21 	lds	r25, 0x2142
    3d68:	01 96       	adiw	r24, 0x01	; 1
    3d6a:	80 93 41 21 	sts	0x2141, r24
    3d6e:	90 93 42 21 	sts	0x2142, r25
				 rtry++;
    3d72:	8a 81       	ldd	r24, Y+2	; 0x02
    3d74:	9b 81       	ldd	r25, Y+3	; 0x03
    3d76:	01 96       	adiw	r24, 0x01	; 1
    3d78:	8a 83       	std	Y+2, r24	; 0x02
    3d7a:	9b 83       	std	Y+3, r25	; 0x03
                 break;
    3d7c:	10 c0       	rjmp	.+32     	; 0x3d9e <chb_write+0xf0>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    3d7e:	80 91 43 21 	lds	r24, 0x2143
    3d82:	90 91 44 21 	lds	r25, 0x2144
    3d86:	01 96       	adiw	r24, 0x01	; 1
    3d88:	80 93 43 21 	sts	0x2143, r24
    3d8c:	90 93 44 21 	sts	0x2144, r25
				 rtry++;
    3d90:	8a 81       	ldd	r24, Y+2	; 0x02
    3d92:	9b 81       	ldd	r25, Y+3	; 0x03
    3d94:	01 96       	adiw	r24, 0x01	; 1
    3d96:	8a 83       	std	Y+2, r24	; 0x02
    3d98:	9b 83       	std	Y+3, r25	; 0x03
                 break;
    3d9a:	01 c0       	rjmp	.+2      	; 0x3d9e <chb_write+0xf0>
 
             default:
                 break;
    3d9c:	00 00       	nop
             }
			if(rtry>0) _delay_us(10);		//if not successfully sent the first time, wait some time and try again
    3d9e:	8a 81       	ldd	r24, Y+2	; 0x02
    3da0:	9b 81       	ldd	r25, Y+3	; 0x03
    3da2:	18 16       	cp	r1, r24
    3da4:	19 06       	cpc	r1, r25
    3da6:	0c f0       	brlt	.+2      	; 0x3daa <chb_write+0xfc>
    3da8:	d5 c0       	rjmp	.+426    	; 0x3f54 <chb_write+0x2a6>
    3daa:	80 e0       	ldi	r24, 0x00	; 0
    3dac:	90 e0       	ldi	r25, 0x00	; 0
    3dae:	a0 e2       	ldi	r26, 0x20	; 32
    3db0:	b1 e4       	ldi	r27, 0x41	; 65
    3db2:	8f 83       	std	Y+7, r24	; 0x07
    3db4:	98 87       	std	Y+8, r25	; 0x08
    3db6:	a9 87       	std	Y+9, r26	; 0x09
    3db8:	ba 87       	std	Y+10, r27	; 0x0a
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    3dba:	6f 81       	ldd	r22, Y+7	; 0x07
    3dbc:	78 85       	ldd	r23, Y+8	; 0x08
    3dbe:	89 85       	ldd	r24, Y+9	; 0x09
    3dc0:	9a 85       	ldd	r25, Y+10	; 0x0a
    3dc2:	2b ea       	ldi	r18, 0xAB	; 171
    3dc4:	3a ea       	ldi	r19, 0xAA	; 170
    3dc6:	4a ea       	ldi	r20, 0xAA	; 170
    3dc8:	5e e3       	ldi	r21, 0x3E	; 62
    3dca:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    3dce:	dc 01       	movw	r26, r24
    3dd0:	cb 01       	movw	r24, r22
    3dd2:	8b 87       	std	Y+11, r24	; 0x0b
    3dd4:	9c 87       	std	Y+12, r25	; 0x0c
    3dd6:	ad 87       	std	Y+13, r26	; 0x0d
    3dd8:	be 87       	std	Y+14, r27	; 0x0e
	if (__tmp < 1.0)
    3dda:	11 e0       	ldi	r17, 0x01	; 1
    3ddc:	6b 85       	ldd	r22, Y+11	; 0x0b
    3dde:	7c 85       	ldd	r23, Y+12	; 0x0c
    3de0:	8d 85       	ldd	r24, Y+13	; 0x0d
    3de2:	9e 85       	ldd	r25, Y+14	; 0x0e
    3de4:	20 e0       	ldi	r18, 0x00	; 0
    3de6:	30 e0       	ldi	r19, 0x00	; 0
    3de8:	40 e8       	ldi	r20, 0x80	; 128
    3dea:	5f e3       	ldi	r21, 0x3F	; 63
    3dec:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    3df0:	88 23       	and	r24, r24
    3df2:	0c f0       	brlt	.+2      	; 0x3df6 <chb_write+0x148>
    3df4:	10 e0       	ldi	r17, 0x00	; 0
    3df6:	11 23       	and	r17, r17
    3df8:	19 f0       	breq	.+6      	; 0x3e00 <chb_write+0x152>
		__ticks = 1;
    3dfa:	81 e0       	ldi	r24, 0x01	; 1
    3dfc:	8f 87       	std	Y+15, r24	; 0x0f
    3dfe:	a3 c0       	rjmp	.+326    	; 0x3f46 <chb_write+0x298>
	else if (__tmp > 255)
    3e00:	11 e0       	ldi	r17, 0x01	; 1
    3e02:	6b 85       	ldd	r22, Y+11	; 0x0b
    3e04:	7c 85       	ldd	r23, Y+12	; 0x0c
    3e06:	8d 85       	ldd	r24, Y+13	; 0x0d
    3e08:	9e 85       	ldd	r25, Y+14	; 0x0e
    3e0a:	20 e0       	ldi	r18, 0x00	; 0
    3e0c:	30 e0       	ldi	r19, 0x00	; 0
    3e0e:	4f e7       	ldi	r20, 0x7F	; 127
    3e10:	53 e4       	ldi	r21, 0x43	; 67
    3e12:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    3e16:	18 16       	cp	r1, r24
    3e18:	0c f0       	brlt	.+2      	; 0x3e1c <chb_write+0x16e>
    3e1a:	10 e0       	ldi	r17, 0x00	; 0
    3e1c:	11 23       	and	r17, r17
    3e1e:	09 f4       	brne	.+2      	; 0x3e22 <chb_write+0x174>
    3e20:	89 c0       	rjmp	.+274    	; 0x3f34 <chb_write+0x286>
	{
		_delay_ms(__us / 1000.0);
    3e22:	6f 81       	ldd	r22, Y+7	; 0x07
    3e24:	78 85       	ldd	r23, Y+8	; 0x08
    3e26:	89 85       	ldd	r24, Y+9	; 0x09
    3e28:	9a 85       	ldd	r25, Y+10	; 0x0a
    3e2a:	20 e0       	ldi	r18, 0x00	; 0
    3e2c:	30 e0       	ldi	r19, 0x00	; 0
    3e2e:	4a e7       	ldi	r20, 0x7A	; 122
    3e30:	54 e4       	ldi	r21, 0x44	; 68
    3e32:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
    3e36:	dc 01       	movw	r26, r24
    3e38:	cb 01       	movw	r24, r22
    3e3a:	88 8b       	std	Y+16, r24	; 0x10
    3e3c:	99 8b       	std	Y+17, r25	; 0x11
    3e3e:	aa 8b       	std	Y+18, r26	; 0x12
    3e40:	bb 8b       	std	Y+19, r27	; 0x13
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    3e42:	68 89       	ldd	r22, Y+16	; 0x10
    3e44:	79 89       	ldd	r23, Y+17	; 0x11
    3e46:	8a 89       	ldd	r24, Y+18	; 0x12
    3e48:	9b 89       	ldd	r25, Y+19	; 0x13
    3e4a:	20 e0       	ldi	r18, 0x00	; 0
    3e4c:	30 e0       	ldi	r19, 0x00	; 0
    3e4e:	4a e7       	ldi	r20, 0x7A	; 122
    3e50:	53 e4       	ldi	r21, 0x43	; 67
    3e52:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    3e56:	dc 01       	movw	r26, r24
    3e58:	cb 01       	movw	r24, r22
    3e5a:	8c 8b       	std	Y+20, r24	; 0x14
    3e5c:	9d 8b       	std	Y+21, r25	; 0x15
    3e5e:	ae 8b       	std	Y+22, r26	; 0x16
    3e60:	bf 8b       	std	Y+23, r27	; 0x17
	if (__tmp < 1.0)
    3e62:	11 e0       	ldi	r17, 0x01	; 1
    3e64:	6c 89       	ldd	r22, Y+20	; 0x14
    3e66:	7d 89       	ldd	r23, Y+21	; 0x15
    3e68:	8e 89       	ldd	r24, Y+22	; 0x16
    3e6a:	9f 89       	ldd	r25, Y+23	; 0x17
    3e6c:	20 e0       	ldi	r18, 0x00	; 0
    3e6e:	30 e0       	ldi	r19, 0x00	; 0
    3e70:	40 e8       	ldi	r20, 0x80	; 128
    3e72:	5f e3       	ldi	r21, 0x3F	; 63
    3e74:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    3e78:	88 23       	and	r24, r24
    3e7a:	0c f0       	brlt	.+2      	; 0x3e7e <chb_write+0x1d0>
    3e7c:	10 e0       	ldi	r17, 0x00	; 0
    3e7e:	11 23       	and	r17, r17
    3e80:	29 f0       	breq	.+10     	; 0x3e8c <chb_write+0x1de>
		__ticks = 1;
    3e82:	81 e0       	ldi	r24, 0x01	; 1
    3e84:	90 e0       	ldi	r25, 0x00	; 0
    3e86:	88 8f       	std	Y+24, r24	; 0x18
    3e88:	99 8f       	std	Y+25, r25	; 0x19
    3e8a:	46 c0       	rjmp	.+140    	; 0x3f18 <chb_write+0x26a>
	else if (__tmp > 65535)
    3e8c:	11 e0       	ldi	r17, 0x01	; 1
    3e8e:	6c 89       	ldd	r22, Y+20	; 0x14
    3e90:	7d 89       	ldd	r23, Y+21	; 0x15
    3e92:	8e 89       	ldd	r24, Y+22	; 0x16
    3e94:	9f 89       	ldd	r25, Y+23	; 0x17
    3e96:	20 e0       	ldi	r18, 0x00	; 0
    3e98:	3f ef       	ldi	r19, 0xFF	; 255
    3e9a:	4f e7       	ldi	r20, 0x7F	; 127
    3e9c:	57 e4       	ldi	r21, 0x47	; 71
    3e9e:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    3ea2:	18 16       	cp	r1, r24
    3ea4:	0c f0       	brlt	.+2      	; 0x3ea8 <chb_write+0x1fa>
    3ea6:	10 e0       	ldi	r17, 0x00	; 0
    3ea8:	11 23       	and	r17, r17
    3eaa:	61 f1       	breq	.+88     	; 0x3f04 <chb_write+0x256>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3eac:	68 89       	ldd	r22, Y+16	; 0x10
    3eae:	79 89       	ldd	r23, Y+17	; 0x11
    3eb0:	8a 89       	ldd	r24, Y+18	; 0x12
    3eb2:	9b 89       	ldd	r25, Y+19	; 0x13
    3eb4:	20 e0       	ldi	r18, 0x00	; 0
    3eb6:	30 e0       	ldi	r19, 0x00	; 0
    3eb8:	40 e2       	ldi	r20, 0x20	; 32
    3eba:	51 e4       	ldi	r21, 0x41	; 65
    3ebc:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    3ec0:	dc 01       	movw	r26, r24
    3ec2:	cb 01       	movw	r24, r22
    3ec4:	bc 01       	movw	r22, r24
    3ec6:	cd 01       	movw	r24, r26
    3ec8:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    3ecc:	dc 01       	movw	r26, r24
    3ece:	cb 01       	movw	r24, r22
    3ed0:	88 8f       	std	Y+24, r24	; 0x18
    3ed2:	99 8f       	std	Y+25, r25	; 0x19
    3ed4:	12 c0       	rjmp	.+36     	; 0x3efa <chb_write+0x24c>
    3ed6:	89 e1       	ldi	r24, 0x19	; 25
    3ed8:	90 e0       	ldi	r25, 0x00	; 0
    3eda:	8a 8f       	std	Y+26, r24	; 0x1a
    3edc:	9b 8f       	std	Y+27, r25	; 0x1b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3ede:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3ee0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3ee2:	8c 01       	movw	r16, r24
    3ee4:	c8 01       	movw	r24, r16
    3ee6:	01 97       	sbiw	r24, 0x01	; 1
    3ee8:	f1 f7       	brne	.-4      	; 0x3ee6 <chb_write+0x238>
    3eea:	8c 01       	movw	r16, r24
    3eec:	0a 8f       	std	Y+26, r16	; 0x1a
    3eee:	1b 8f       	std	Y+27, r17	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3ef0:	88 8d       	ldd	r24, Y+24	; 0x18
    3ef2:	99 8d       	ldd	r25, Y+25	; 0x19
    3ef4:	01 97       	sbiw	r24, 0x01	; 1
    3ef6:	88 8f       	std	Y+24, r24	; 0x18
    3ef8:	99 8f       	std	Y+25, r25	; 0x19
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3efa:	88 8d       	ldd	r24, Y+24	; 0x18
    3efc:	99 8d       	ldd	r25, Y+25	; 0x19
    3efe:	00 97       	sbiw	r24, 0x00	; 0
    3f00:	51 f7       	brne	.-44     	; 0x3ed6 <chb_write+0x228>
    3f02:	28 c0       	rjmp	.+80     	; 0x3f54 <chb_write+0x2a6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3f04:	6c 89       	ldd	r22, Y+20	; 0x14
    3f06:	7d 89       	ldd	r23, Y+21	; 0x15
    3f08:	8e 89       	ldd	r24, Y+22	; 0x16
    3f0a:	9f 89       	ldd	r25, Y+23	; 0x17
    3f0c:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    3f10:	dc 01       	movw	r26, r24
    3f12:	cb 01       	movw	r24, r22
    3f14:	88 8f       	std	Y+24, r24	; 0x18
    3f16:	99 8f       	std	Y+25, r25	; 0x19
    3f18:	88 8d       	ldd	r24, Y+24	; 0x18
    3f1a:	99 8d       	ldd	r25, Y+25	; 0x19
    3f1c:	8c 8f       	std	Y+28, r24	; 0x1c
    3f1e:	9d 8f       	std	Y+29, r25	; 0x1d
    3f20:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3f22:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3f24:	8c 01       	movw	r16, r24
    3f26:	c8 01       	movw	r24, r16
    3f28:	01 97       	sbiw	r24, 0x01	; 1
    3f2a:	f1 f7       	brne	.-4      	; 0x3f28 <chb_write+0x27a>
    3f2c:	8c 01       	movw	r16, r24
    3f2e:	0c 8f       	std	Y+28, r16	; 0x1c
    3f30:	1d 8f       	std	Y+29, r17	; 0x1d
    3f32:	10 c0       	rjmp	.+32     	; 0x3f54 <chb_write+0x2a6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3f34:	6b 85       	ldd	r22, Y+11	; 0x0b
    3f36:	7c 85       	ldd	r23, Y+12	; 0x0c
    3f38:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f3a:	9e 85       	ldd	r25, Y+14	; 0x0e
    3f3c:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    3f40:	dc 01       	movw	r26, r24
    3f42:	cb 01       	movw	r24, r22
    3f44:	8f 87       	std	Y+15, r24	; 0x0f
    3f46:	8f 85       	ldd	r24, Y+15	; 0x0f
    3f48:	8e 8f       	std	Y+30, r24	; 0x1e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3f4a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3f4c:	18 2f       	mov	r17, r24
    3f4e:	1a 95       	dec	r17
    3f50:	f1 f7       	brne	.-4      	; 0x3f4e <chb_write+0x2a0>
    3f52:	1e 8f       	std	Y+30, r17	; 0x1e
			if(rtry==20) return status;;		//after 20 tries give up on sending the message	
    3f54:	8a 81       	ldd	r24, Y+2	; 0x02
    3f56:	9b 81       	ldd	r25, Y+3	; 0x03
    3f58:	84 31       	cpi	r24, 0x14	; 20
    3f5a:	91 05       	cpc	r25, r1
    3f5c:	11 f4       	brne	.+4      	; 0x3f62 <chb_write+0x2b4>
    3f5e:	8e 81       	ldd	r24, Y+6	; 0x06
    3f60:	27 c0       	rjmp	.+78     	; 0x3fb0 <chb_write+0x302>
		} while(status != CHB_SUCCESS);			
    3f62:	8e 81       	ldd	r24, Y+6	; 0x06
    3f64:	88 23       	and	r24, r24
    3f66:	09 f0       	breq	.+2      	; 0x3f6a <chb_write+0x2bc>
    3f68:	d0 ce       	rjmp	.-608    	; 0x3d0a <chb_write+0x5c>
        // adjust len and restart
		frm_offset += frm_len;
    3f6a:	99 81       	ldd	r25, Y+1	; 0x01
    3f6c:	8c 81       	ldd	r24, Y+4	; 0x04
    3f6e:	89 0f       	add	r24, r25
    3f70:	89 83       	std	Y+1, r24	; 0x01
        len = len - frm_len;
    3f72:	8c 81       	ldd	r24, Y+4	; 0x04
    3f74:	88 2f       	mov	r24, r24
    3f76:	90 e0       	ldi	r25, 0x00	; 0
    3f78:	a0 e0       	ldi	r26, 0x00	; 0
    3f7a:	b0 e0       	ldi	r27, 0x00	; 0
    3f7c:	2d a5       	lds	r18, 0x6d
    3f7e:	3e a5       	lds	r19, 0x6e
    3f80:	4f a5       	lds	r20, 0x6f
    3f82:	58 a9       	sts	0x48, r21
    3f84:	79 01       	movw	r14, r18
    3f86:	8a 01       	movw	r16, r20
    3f88:	e8 1a       	sub	r14, r24
    3f8a:	f9 0a       	sbc	r15, r25
    3f8c:	0a 0b       	sbc	r16, r26
    3f8e:	1b 0b       	sbc	r17, r27
    3f90:	d8 01       	movw	r26, r16
    3f92:	c7 01       	movw	r24, r14
    3f94:	8d a7       	lds	r24, 0x7d
    3f96:	9e a7       	lds	r25, 0x7e
    3f98:	af a7       	lds	r26, 0x7f
    3f9a:	b8 ab       	sts	0x58, r27
{
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    3f9c:	8d a5       	lds	r24, 0x6d
    3f9e:	9e a5       	lds	r25, 0x6e
    3fa0:	af a5       	lds	r26, 0x6f
    3fa2:	b8 a9       	sts	0x48, r27
    3fa4:	00 97       	sbiw	r24, 0x00	; 0
    3fa6:	a1 05       	cpc	r26, r1
    3fa8:	b1 05       	cpc	r27, r1
    3faa:	09 f0       	breq	.+2      	; 0x3fae <chb_write+0x300>
    3fac:	95 ce       	rjmp	.-726    	; 0x3cd8 <chb_write+0x2a>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    3fae:	80 e0       	ldi	r24, 0x00	; 0
}
    3fb0:	e0 96       	adiw	r28, 0x30	; 48
    3fb2:	cd bf       	out	0x3d, r28	; 61
    3fb4:	de bf       	out	0x3e, r29	; 62
    3fb6:	df 91       	pop	r29
    3fb8:	cf 91       	pop	r28
    3fba:	1f 91       	pop	r17
    3fbc:	0f 91       	pop	r16
    3fbe:	ff 90       	pop	r15
    3fc0:	ef 90       	pop	r14
    3fc2:	08 95       	ret

00003fc4 <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    3fc4:	cf 93       	push	r28
    3fc6:	df 93       	push	r29
    3fc8:	cd b7       	in	r28, 0x3d	; 61
    3fca:	de b7       	in	r29, 0x3e	; 62
    3fcc:	27 97       	sbiw	r28, 0x07	; 7
    3fce:	cd bf       	out	0x3d, r28	; 61
    3fd0:	de bf       	out	0x3e, r29	; 62
    3fd2:	8e 83       	std	Y+6, r24	; 0x06
    3fd4:	9f 83       	std	Y+7, r25	; 0x07
    U8 i, len, seq, *data_ptr;

    data_ptr = rx->data;
    3fd6:	8e 81       	ldd	r24, Y+6	; 0x06
    3fd8:	9f 81       	ldd	r25, Y+7	; 0x07
    3fda:	05 96       	adiw	r24, 0x05	; 5
    3fdc:	8a 83       	std	Y+2, r24	; 0x02
    3fde:	9b 83       	std	Y+3, r25	; 0x03

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    3fe0:	0e 94 af 20 	call	0x415e	; 0x415e <chb_buf_read>
    3fe4:	8c 83       	std	Y+4, r24	; 0x04
    3fe6:	8c 81       	ldd	r24, Y+4	; 0x04
    3fe8:	88 23       	and	r24, r24
    3fea:	14 f4       	brge	.+4      	; 0x3ff0 <chb_read+0x2c>
    {
        return 0;
    3fec:	80 e0       	ldi	r24, 0x00	; 0
    3fee:	80 c0       	rjmp	.+256    	; 0x40f0 <chb_read+0x12c>
    }
    *data_ptr++ = len;
    3ff0:	8a 81       	ldd	r24, Y+2	; 0x02
    3ff2:	9b 81       	ldd	r25, Y+3	; 0x03
    3ff4:	2c 81       	ldd	r18, Y+4	; 0x04
    3ff6:	fc 01       	movw	r30, r24
    3ff8:	20 83       	st	Z, r18
    3ffa:	8a 81       	ldd	r24, Y+2	; 0x02
    3ffc:	9b 81       	ldd	r25, Y+3	; 0x03
    3ffe:	01 96       	adiw	r24, 0x01	; 1
    4000:	8a 83       	std	Y+2, r24	; 0x02
    4002:	9b 83       	std	Y+3, r25	; 0x03

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    4004:	19 82       	std	Y+1, r1	; 0x01
    4006:	0f c0       	rjmp	.+30     	; 0x4026 <chb_read+0x62>
    {
        *data_ptr++ = chb_buf_read();
    4008:	0e 94 af 20 	call	0x415e	; 0x415e <chb_buf_read>
    400c:	28 2f       	mov	r18, r24
    400e:	8a 81       	ldd	r24, Y+2	; 0x02
    4010:	9b 81       	ldd	r25, Y+3	; 0x03
    4012:	fc 01       	movw	r30, r24
    4014:	20 83       	st	Z, r18
    4016:	8a 81       	ldd	r24, Y+2	; 0x02
    4018:	9b 81       	ldd	r25, Y+3	; 0x03
    401a:	01 96       	adiw	r24, 0x01	; 1
    401c:	8a 83       	std	Y+2, r24	; 0x02
    401e:	9b 83       	std	Y+3, r25	; 0x03
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    4020:	89 81       	ldd	r24, Y+1	; 0x01
    4022:	8f 5f       	subi	r24, 0xFF	; 255
    4024:	89 83       	std	Y+1, r24	; 0x01
    4026:	99 81       	ldd	r25, Y+1	; 0x01
    4028:	8c 81       	ldd	r24, Y+4	; 0x04
    402a:	98 17       	cp	r25, r24
    402c:	68 f3       	brcs	.-38     	; 0x4008 <chb_read+0x44>
    // buffer as well to save resources.
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    402e:	8e 81       	ldd	r24, Y+6	; 0x06
    4030:	9f 81       	ldd	r25, Y+7	; 0x07
    4032:	08 96       	adiw	r24, 0x08	; 8
    4034:	8a 83       	std	Y+2, r24	; 0x02
    4036:	9b 83       	std	Y+3, r25	; 0x03
    seq = *data_ptr;
    4038:	8a 81       	ldd	r24, Y+2	; 0x02
    403a:	9b 81       	ldd	r25, Y+3	; 0x03
    403c:	fc 01       	movw	r30, r24
    403e:	80 81       	ld	r24, Z
    4040:	8d 83       	std	Y+5, r24	; 0x05

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    4042:	8e 81       	ldd	r24, Y+6	; 0x06
    4044:	9f 81       	ldd	r25, Y+7	; 0x07
    4046:	0b 96       	adiw	r24, 0x0b	; 11
    4048:	8a 83       	std	Y+2, r24	; 0x02
    404a:	9b 83       	std	Y+3, r25	; 0x03
    rx->dest_addr = *(U16 *)data_ptr;
    404c:	8a 81       	ldd	r24, Y+2	; 0x02
    404e:	9b 81       	ldd	r25, Y+3	; 0x03
    4050:	fc 01       	movw	r30, r24
    4052:	20 81       	ld	r18, Z
    4054:	31 81       	ldd	r19, Z+1	; 0x01
    4056:	8e 81       	ldd	r24, Y+6	; 0x06
    4058:	9f 81       	ldd	r25, Y+7	; 0x07
    405a:	fc 01       	movw	r30, r24
    405c:	23 83       	std	Z+3, r18	; 0x03
    405e:	34 83       	std	Z+4, r19	; 0x04
    data_ptr += sizeof(U16);
    4060:	8a 81       	ldd	r24, Y+2	; 0x02
    4062:	9b 81       	ldd	r25, Y+3	; 0x03
    4064:	02 96       	adiw	r24, 0x02	; 2
    4066:	8a 83       	std	Y+2, r24	; 0x02
    4068:	9b 83       	std	Y+3, r25	; 0x03
    rx->src_addr = *(U16 *)data_ptr;
    406a:	8a 81       	ldd	r24, Y+2	; 0x02
    406c:	9b 81       	ldd	r25, Y+3	; 0x03
    406e:	fc 01       	movw	r30, r24
    4070:	20 81       	ld	r18, Z
    4072:	31 81       	ldd	r19, Z+1	; 0x01
    4074:	8e 81       	ldd	r24, Y+6	; 0x06
    4076:	9f 81       	ldd	r25, Y+7	; 0x07
    4078:	fc 01       	movw	r30, r24
    407a:	21 83       	std	Z+1, r18	; 0x01
    407c:	32 83       	std	Z+2, r19	; 0x02
    data_ptr += sizeof(U16);
    407e:	8a 81       	ldd	r24, Y+2	; 0x02
    4080:	9b 81       	ldd	r25, Y+3	; 0x03
    4082:	02 96       	adiw	r24, 0x02	; 2
    4084:	8a 83       	std	Y+2, r24	; 0x02
    4086:	9b 83       	std	Y+3, r25	; 0x03

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    4088:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <chb_buf_get_len>
    408c:	88 23       	and	r24, r24
    408e:	11 f4       	brne	.+4      	; 0x4094 <chb_read+0xd0>
    {
        pcb.data_rcv = false;
    4090:	10 92 3b 21 	sts	0x213B, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    4094:	80 91 0e 20 	lds	r24, 0x200E
    4098:	9d 81       	ldd	r25, Y+5	; 0x05
    409a:	98 17       	cp	r25, r24
    409c:	71 f4       	brne	.+28     	; 0x40ba <chb_read+0xf6>
    409e:	8e 81       	ldd	r24, Y+6	; 0x06
    40a0:	9f 81       	ldd	r25, Y+7	; 0x07
    40a2:	fc 01       	movw	r30, r24
    40a4:	21 81       	ldd	r18, Z+1	; 0x01
    40a6:	32 81       	ldd	r19, Z+2	; 0x02
    40a8:	80 91 0f 20 	lds	r24, 0x200F
    40ac:	90 91 10 20 	lds	r25, 0x2010
    40b0:	28 17       	cp	r18, r24
    40b2:	39 07       	cpc	r19, r25
    40b4:	11 f4       	brne	.+4      	; 0x40ba <chb_read+0xf6>
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    40b6:	80 e0       	ldi	r24, 0x00	; 0
    40b8:	1b c0       	rjmp	.+54     	; 0x40f0 <chb_read+0x12c>
    }
    else
    {
        prev_seq = seq;
    40ba:	8d 81       	ldd	r24, Y+5	; 0x05
    40bc:	80 93 0e 20 	sts	0x200E, r24
        prev_src_addr = rx->src_addr;
    40c0:	8e 81       	ldd	r24, Y+6	; 0x06
    40c2:	9f 81       	ldd	r25, Y+7	; 0x07
    40c4:	fc 01       	movw	r30, r24
    40c6:	81 81       	ldd	r24, Z+1	; 0x01
    40c8:	92 81       	ldd	r25, Z+2	; 0x02
    40ca:	80 93 0f 20 	sts	0x200F, r24
    40ce:	90 93 10 20 	sts	0x2010, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    40d2:	8c 81       	ldd	r24, Y+4	; 0x04
    40d4:	88 2f       	mov	r24, r24
    40d6:	90 e0       	ldi	r25, 0x00	; 0
    40d8:	09 97       	sbiw	r24, 0x09	; 9
    40da:	9c 01       	movw	r18, r24
    40dc:	8e 81       	ldd	r24, Y+6	; 0x06
    40de:	9f 81       	ldd	r25, Y+7	; 0x07
    40e0:	4a 81       	ldd	r20, Y+2	; 0x02
    40e2:	5b 81       	ldd	r21, Y+3	; 0x03
    40e4:	ba 01       	movw	r22, r20
    40e6:	a9 01       	movw	r20, r18
    40e8:	0e 94 57 5c 	call	0xb8ae	; 0xb8ae <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    40ec:	8c 81       	ldd	r24, Y+4	; 0x04
    40ee:	8b 50       	subi	r24, 0x0B	; 11
#endif
}
    40f0:	27 96       	adiw	r28, 0x07	; 7
    40f2:	cd bf       	out	0x3d, r28	; 61
    40f4:	de bf       	out	0x3e, r29	; 62
    40f6:	df 91       	pop	r29
    40f8:	cf 91       	pop	r28
    40fa:	08 95       	ret

000040fc <chb_buf_init>:
/*!

*/
/**************************************************************************/
void chb_buf_init()
{
    40fc:	cf 93       	push	r28
    40fe:	df 93       	push	r29
    4100:	cd b7       	in	r28, 0x3d	; 61
    4102:	de b7       	in	r29, 0x3e	; 62
    rd_ptr = 0;
    4104:	10 92 cc 21 	sts	0x21CC, r1
    wr_ptr = 0;
    4108:	10 92 cd 21 	sts	0x21CD, r1
    len = 0;
    410c:	10 92 ce 21 	sts	0x21CE, r1
}
    4110:	df 91       	pop	r29
    4112:	cf 91       	pop	r28
    4114:	08 95       	ret

00004116 <chb_buf_write>:
/*!

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    4116:	cf 93       	push	r28
    4118:	df 93       	push	r29
    411a:	0f 92       	push	r0
    411c:	cd b7       	in	r28, 0x3d	; 61
    411e:	de b7       	in	r29, 0x3e	; 62
    4120:	89 83       	std	Y+1, r24	; 0x01
    chb_buf[wr_ptr] = data;
    4122:	80 91 cd 21 	lds	r24, 0x21CD
    4126:	88 2f       	mov	r24, r24
    4128:	90 e0       	ldi	r25, 0x00	; 0
    412a:	84 5b       	subi	r24, 0xB4	; 180
    412c:	9e 4d       	sbci	r25, 0xDE	; 222
    412e:	29 81       	ldd	r18, Y+1	; 0x01
    4130:	fc 01       	movw	r30, r24
    4132:	20 83       	st	Z, r18
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    4134:	80 91 cd 21 	lds	r24, 0x21CD
    4138:	88 2f       	mov	r24, r24
    413a:	90 e0       	ldi	r25, 0x00	; 0
    413c:	01 96       	adiw	r24, 0x01	; 1
    413e:	20 e8       	ldi	r18, 0x80	; 128
    4140:	30 e0       	ldi	r19, 0x00	; 0
    4142:	b9 01       	movw	r22, r18
    4144:	0e 94 c6 5b 	call	0xb78c	; 0xb78c <__divmodhi4>
    4148:	80 93 cd 21 	sts	0x21CD, r24
    len++;
    414c:	80 91 ce 21 	lds	r24, 0x21CE
    4150:	8f 5f       	subi	r24, 0xFF	; 255
    4152:	80 93 ce 21 	sts	0x21CE, r24
}
    4156:	0f 90       	pop	r0
    4158:	df 91       	pop	r29
    415a:	cf 91       	pop	r28
    415c:	08 95       	ret

0000415e <chb_buf_read>:
/*!

*/
/**************************************************************************/
U8 chb_buf_read()
{
    415e:	cf 93       	push	r28
    4160:	df 93       	push	r29
    4162:	0f 92       	push	r0
    4164:	cd b7       	in	r28, 0x3d	; 61
    4166:	de b7       	in	r29, 0x3e	; 62
    U8 data;

    data = chb_buf[rd_ptr];
    4168:	80 91 cc 21 	lds	r24, 0x21CC
    416c:	88 2f       	mov	r24, r24
    416e:	90 e0       	ldi	r25, 0x00	; 0
    4170:	84 5b       	subi	r24, 0xB4	; 180
    4172:	9e 4d       	sbci	r25, 0xDE	; 222
    4174:	fc 01       	movw	r30, r24
    4176:	80 81       	ld	r24, Z
    4178:	89 83       	std	Y+1, r24	; 0x01
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    417a:	80 91 cc 21 	lds	r24, 0x21CC
    417e:	88 2f       	mov	r24, r24
    4180:	90 e0       	ldi	r25, 0x00	; 0
    4182:	01 96       	adiw	r24, 0x01	; 1
    4184:	20 e8       	ldi	r18, 0x80	; 128
    4186:	30 e0       	ldi	r19, 0x00	; 0
    4188:	b9 01       	movw	r22, r18
    418a:	0e 94 c6 5b 	call	0xb78c	; 0xb78c <__divmodhi4>
    418e:	80 93 cc 21 	sts	0x21CC, r24
    len--;
    4192:	80 91 ce 21 	lds	r24, 0x21CE
    4196:	81 50       	subi	r24, 0x01	; 1
    4198:	80 93 ce 21 	sts	0x21CE, r24
    return data;
    419c:	89 81       	ldd	r24, Y+1	; 0x01
}
    419e:	0f 90       	pop	r0
    41a0:	df 91       	pop	r29
    41a2:	cf 91       	pop	r28
    41a4:	08 95       	ret

000041a6 <chb_buf_get_len>:
/*!

*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    41a6:	cf 93       	push	r28
    41a8:	df 93       	push	r29
    41aa:	cd b7       	in	r28, 0x3d	; 61
    41ac:	de b7       	in	r29, 0x3e	; 62
    return len;
    41ae:	80 91 ce 21 	lds	r24, 0x21CE
}
    41b2:	df 91       	pop	r29
    41b4:	cf 91       	pop	r28
    41b6:	08 95       	ret

000041b8 <chb_get_state>:
/*!

*/
/**************************************************************************/
static U8 chb_get_state()
{
    41b8:	cf 93       	push	r28
    41ba:	df 93       	push	r29
    41bc:	cd b7       	in	r28, 0x3d	; 61
    41be:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATUS) & 0x1f;
    41c0:	81 e0       	ldi	r24, 0x01	; 1
    41c2:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <chb_reg_read>
    41c6:	8f 71       	andi	r24, 0x1F	; 31
}
    41c8:	df 91       	pop	r29
    41ca:	cf 91       	pop	r28
    41cc:	08 95       	ret

000041ce <chb_get_status>:
/*!

*/
/**************************************************************************/
static U8 chb_get_status()
{
    41ce:	cf 93       	push	r28
    41d0:	df 93       	push	r29
    41d2:	cd b7       	in	r28, 0x3d	; 61
    41d4:	de b7       	in	r29, 0x3e	; 62
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    41d6:	82 e0       	ldi	r24, 0x02	; 2
    41d8:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <chb_reg_read>
    41dc:	82 95       	swap	r24
    41de:	86 95       	lsr	r24
    41e0:	87 70       	andi	r24, 0x07	; 7
}
    41e2:	df 91       	pop	r29
    41e4:	cf 91       	pop	r28
    41e6:	08 95       	ret

000041e8 <chb_reset>:
/*!

*/
/**************************************************************************/
void chb_reset()
{
    41e8:	0f 93       	push	r16
    41ea:	1f 93       	push	r17
    41ec:	cf 93       	push	r28
    41ee:	df 93       	push	r29
    41f0:	cd b7       	in	r28, 0x3d	; 61
    41f2:	de b7       	in	r29, 0x3e	; 62
    41f4:	e0 97       	sbiw	r28, 0x30	; 48
    41f6:	cd bf       	out	0x3d, r28	; 61
    41f8:	de bf       	out	0x3e, r29	; 62
    CHB_RST_DISABLE();
    41fa:	84 e6       	ldi	r24, 0x64	; 100
    41fc:	96 e0       	ldi	r25, 0x06	; 6
    41fe:	24 e6       	ldi	r18, 0x64	; 100
    4200:	36 e0       	ldi	r19, 0x06	; 6
    4202:	f9 01       	movw	r30, r18
    4204:	20 81       	ld	r18, Z
    4206:	21 60       	ori	r18, 0x01	; 1
    4208:	fc 01       	movw	r30, r24
    420a:	20 83       	st	Z, r18
    CHB_SLPTR_DISABLE();
    420c:	84 e6       	ldi	r24, 0x64	; 100
    420e:	96 e0       	ldi	r25, 0x06	; 6
    4210:	24 e6       	ldi	r18, 0x64	; 100
    4212:	36 e0       	ldi	r19, 0x06	; 6
    4214:	f9 01       	movw	r30, r18
    4216:	20 81       	ld	r18, Z
    4218:	2d 7f       	andi	r18, 0xFD	; 253
    421a:	fc 01       	movw	r30, r24
    421c:	20 83       	st	Z, r18
    421e:	80 e0       	ldi	r24, 0x00	; 0
    4220:	90 e0       	ldi	r25, 0x00	; 0
    4222:	ae eb       	ldi	r26, 0xBE	; 190
    4224:	b3 e4       	ldi	r27, 0x43	; 67
    4226:	89 83       	std	Y+1, r24	; 0x01
    4228:	9a 83       	std	Y+2, r25	; 0x02
    422a:	ab 83       	std	Y+3, r26	; 0x03
    422c:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    422e:	69 81       	ldd	r22, Y+1	; 0x01
    4230:	7a 81       	ldd	r23, Y+2	; 0x02
    4232:	8b 81       	ldd	r24, Y+3	; 0x03
    4234:	9c 81       	ldd	r25, Y+4	; 0x04
    4236:	2b ea       	ldi	r18, 0xAB	; 171
    4238:	3a ea       	ldi	r19, 0xAA	; 170
    423a:	4a ea       	ldi	r20, 0xAA	; 170
    423c:	5e e3       	ldi	r21, 0x3E	; 62
    423e:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    4242:	dc 01       	movw	r26, r24
    4244:	cb 01       	movw	r24, r22
    4246:	8d 83       	std	Y+5, r24	; 0x05
    4248:	9e 83       	std	Y+6, r25	; 0x06
    424a:	af 83       	std	Y+7, r26	; 0x07
    424c:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    424e:	11 e0       	ldi	r17, 0x01	; 1
    4250:	6d 81       	ldd	r22, Y+5	; 0x05
    4252:	7e 81       	ldd	r23, Y+6	; 0x06
    4254:	8f 81       	ldd	r24, Y+7	; 0x07
    4256:	98 85       	ldd	r25, Y+8	; 0x08
    4258:	20 e0       	ldi	r18, 0x00	; 0
    425a:	30 e0       	ldi	r19, 0x00	; 0
    425c:	40 e8       	ldi	r20, 0x80	; 128
    425e:	5f e3       	ldi	r21, 0x3F	; 63
    4260:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    4264:	88 23       	and	r24, r24
    4266:	0c f0       	brlt	.+2      	; 0x426a <chb_reset+0x82>
    4268:	10 e0       	ldi	r17, 0x00	; 0
    426a:	11 23       	and	r17, r17
    426c:	19 f0       	breq	.+6      	; 0x4274 <chb_reset+0x8c>
		__ticks = 1;
    426e:	81 e0       	ldi	r24, 0x01	; 1
    4270:	89 87       	std	Y+9, r24	; 0x09
    4272:	a3 c0       	rjmp	.+326    	; 0x43ba <chb_reset+0x1d2>
	else if (__tmp > 255)
    4274:	11 e0       	ldi	r17, 0x01	; 1
    4276:	6d 81       	ldd	r22, Y+5	; 0x05
    4278:	7e 81       	ldd	r23, Y+6	; 0x06
    427a:	8f 81       	ldd	r24, Y+7	; 0x07
    427c:	98 85       	ldd	r25, Y+8	; 0x08
    427e:	20 e0       	ldi	r18, 0x00	; 0
    4280:	30 e0       	ldi	r19, 0x00	; 0
    4282:	4f e7       	ldi	r20, 0x7F	; 127
    4284:	53 e4       	ldi	r21, 0x43	; 67
    4286:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    428a:	18 16       	cp	r1, r24
    428c:	0c f0       	brlt	.+2      	; 0x4290 <chb_reset+0xa8>
    428e:	10 e0       	ldi	r17, 0x00	; 0
    4290:	11 23       	and	r17, r17
    4292:	09 f4       	brne	.+2      	; 0x4296 <chb_reset+0xae>
    4294:	89 c0       	rjmp	.+274    	; 0x43a8 <chb_reset+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    4296:	69 81       	ldd	r22, Y+1	; 0x01
    4298:	7a 81       	ldd	r23, Y+2	; 0x02
    429a:	8b 81       	ldd	r24, Y+3	; 0x03
    429c:	9c 81       	ldd	r25, Y+4	; 0x04
    429e:	20 e0       	ldi	r18, 0x00	; 0
    42a0:	30 e0       	ldi	r19, 0x00	; 0
    42a2:	4a e7       	ldi	r20, 0x7A	; 122
    42a4:	54 e4       	ldi	r21, 0x44	; 68
    42a6:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
    42aa:	dc 01       	movw	r26, r24
    42ac:	cb 01       	movw	r24, r22
    42ae:	8a 87       	std	Y+10, r24	; 0x0a
    42b0:	9b 87       	std	Y+11, r25	; 0x0b
    42b2:	ac 87       	std	Y+12, r26	; 0x0c
    42b4:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    42b6:	6a 85       	ldd	r22, Y+10	; 0x0a
    42b8:	7b 85       	ldd	r23, Y+11	; 0x0b
    42ba:	8c 85       	ldd	r24, Y+12	; 0x0c
    42bc:	9d 85       	ldd	r25, Y+13	; 0x0d
    42be:	20 e0       	ldi	r18, 0x00	; 0
    42c0:	30 e0       	ldi	r19, 0x00	; 0
    42c2:	4a e7       	ldi	r20, 0x7A	; 122
    42c4:	53 e4       	ldi	r21, 0x43	; 67
    42c6:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    42ca:	dc 01       	movw	r26, r24
    42cc:	cb 01       	movw	r24, r22
    42ce:	8e 87       	std	Y+14, r24	; 0x0e
    42d0:	9f 87       	std	Y+15, r25	; 0x0f
    42d2:	a8 8b       	std	Y+16, r26	; 0x10
    42d4:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    42d6:	11 e0       	ldi	r17, 0x01	; 1
    42d8:	6e 85       	ldd	r22, Y+14	; 0x0e
    42da:	7f 85       	ldd	r23, Y+15	; 0x0f
    42dc:	88 89       	ldd	r24, Y+16	; 0x10
    42de:	99 89       	ldd	r25, Y+17	; 0x11
    42e0:	20 e0       	ldi	r18, 0x00	; 0
    42e2:	30 e0       	ldi	r19, 0x00	; 0
    42e4:	40 e8       	ldi	r20, 0x80	; 128
    42e6:	5f e3       	ldi	r21, 0x3F	; 63
    42e8:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    42ec:	88 23       	and	r24, r24
    42ee:	0c f0       	brlt	.+2      	; 0x42f2 <chb_reset+0x10a>
    42f0:	10 e0       	ldi	r17, 0x00	; 0
    42f2:	11 23       	and	r17, r17
    42f4:	29 f0       	breq	.+10     	; 0x4300 <chb_reset+0x118>
		__ticks = 1;
    42f6:	81 e0       	ldi	r24, 0x01	; 1
    42f8:	90 e0       	ldi	r25, 0x00	; 0
    42fa:	8a 8b       	std	Y+18, r24	; 0x12
    42fc:	9b 8b       	std	Y+19, r25	; 0x13
    42fe:	46 c0       	rjmp	.+140    	; 0x438c <chb_reset+0x1a4>
	else if (__tmp > 65535)
    4300:	11 e0       	ldi	r17, 0x01	; 1
    4302:	6e 85       	ldd	r22, Y+14	; 0x0e
    4304:	7f 85       	ldd	r23, Y+15	; 0x0f
    4306:	88 89       	ldd	r24, Y+16	; 0x10
    4308:	99 89       	ldd	r25, Y+17	; 0x11
    430a:	20 e0       	ldi	r18, 0x00	; 0
    430c:	3f ef       	ldi	r19, 0xFF	; 255
    430e:	4f e7       	ldi	r20, 0x7F	; 127
    4310:	57 e4       	ldi	r21, 0x47	; 71
    4312:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    4316:	18 16       	cp	r1, r24
    4318:	0c f0       	brlt	.+2      	; 0x431c <chb_reset+0x134>
    431a:	10 e0       	ldi	r17, 0x00	; 0
    431c:	11 23       	and	r17, r17
    431e:	61 f1       	breq	.+88     	; 0x4378 <chb_reset+0x190>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4320:	6a 85       	ldd	r22, Y+10	; 0x0a
    4322:	7b 85       	ldd	r23, Y+11	; 0x0b
    4324:	8c 85       	ldd	r24, Y+12	; 0x0c
    4326:	9d 85       	ldd	r25, Y+13	; 0x0d
    4328:	20 e0       	ldi	r18, 0x00	; 0
    432a:	30 e0       	ldi	r19, 0x00	; 0
    432c:	40 e2       	ldi	r20, 0x20	; 32
    432e:	51 e4       	ldi	r21, 0x41	; 65
    4330:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    4334:	dc 01       	movw	r26, r24
    4336:	cb 01       	movw	r24, r22
    4338:	bc 01       	movw	r22, r24
    433a:	cd 01       	movw	r24, r26
    433c:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    4340:	dc 01       	movw	r26, r24
    4342:	cb 01       	movw	r24, r22
    4344:	8a 8b       	std	Y+18, r24	; 0x12
    4346:	9b 8b       	std	Y+19, r25	; 0x13
    4348:	12 c0       	rjmp	.+36     	; 0x436e <chb_reset+0x186>
    434a:	89 e1       	ldi	r24, 0x19	; 25
    434c:	90 e0       	ldi	r25, 0x00	; 0
    434e:	8c 8b       	std	Y+20, r24	; 0x14
    4350:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4352:	8c 89       	ldd	r24, Y+20	; 0x14
    4354:	9d 89       	ldd	r25, Y+21	; 0x15
    4356:	8c 01       	movw	r16, r24
    4358:	c8 01       	movw	r24, r16
    435a:	01 97       	sbiw	r24, 0x01	; 1
    435c:	f1 f7       	brne	.-4      	; 0x435a <chb_reset+0x172>
    435e:	8c 01       	movw	r16, r24
    4360:	0c 8b       	std	Y+20, r16	; 0x14
    4362:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4364:	8a 89       	ldd	r24, Y+18	; 0x12
    4366:	9b 89       	ldd	r25, Y+19	; 0x13
    4368:	01 97       	sbiw	r24, 0x01	; 1
    436a:	8a 8b       	std	Y+18, r24	; 0x12
    436c:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    436e:	8a 89       	ldd	r24, Y+18	; 0x12
    4370:	9b 89       	ldd	r25, Y+19	; 0x13
    4372:	00 97       	sbiw	r24, 0x00	; 0
    4374:	51 f7       	brne	.-44     	; 0x434a <chb_reset+0x162>
    4376:	28 c0       	rjmp	.+80     	; 0x43c8 <chb_reset+0x1e0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4378:	6e 85       	ldd	r22, Y+14	; 0x0e
    437a:	7f 85       	ldd	r23, Y+15	; 0x0f
    437c:	88 89       	ldd	r24, Y+16	; 0x10
    437e:	99 89       	ldd	r25, Y+17	; 0x11
    4380:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    4384:	dc 01       	movw	r26, r24
    4386:	cb 01       	movw	r24, r22
    4388:	8a 8b       	std	Y+18, r24	; 0x12
    438a:	9b 8b       	std	Y+19, r25	; 0x13
    438c:	8a 89       	ldd	r24, Y+18	; 0x12
    438e:	9b 89       	ldd	r25, Y+19	; 0x13
    4390:	8e 8b       	std	Y+22, r24	; 0x16
    4392:	9f 8b       	std	Y+23, r25	; 0x17
    4394:	8e 89       	ldd	r24, Y+22	; 0x16
    4396:	9f 89       	ldd	r25, Y+23	; 0x17
    4398:	8c 01       	movw	r16, r24
    439a:	f8 01       	movw	r30, r16
    439c:	31 97       	sbiw	r30, 0x01	; 1
    439e:	f1 f7       	brne	.-4      	; 0x439c <chb_reset+0x1b4>
    43a0:	8f 01       	movw	r16, r30
    43a2:	0e 8b       	std	Y+22, r16	; 0x16
    43a4:	1f 8b       	std	Y+23, r17	; 0x17
    43a6:	10 c0       	rjmp	.+32     	; 0x43c8 <chb_reset+0x1e0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    43a8:	6d 81       	ldd	r22, Y+5	; 0x05
    43aa:	7e 81       	ldd	r23, Y+6	; 0x06
    43ac:	8f 81       	ldd	r24, Y+7	; 0x07
    43ae:	98 85       	ldd	r25, Y+8	; 0x08
    43b0:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    43b4:	dc 01       	movw	r26, r24
    43b6:	cb 01       	movw	r24, r22
    43b8:	89 87       	std	Y+9, r24	; 0x09
    43ba:	89 85       	ldd	r24, Y+9	; 0x09
    43bc:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    43be:	88 8d       	ldd	r24, Y+24	; 0x18
    43c0:	18 2f       	mov	r17, r24
    43c2:	1a 95       	dec	r17
    43c4:	f1 f7       	brne	.-4      	; 0x43c2 <chb_reset+0x1da>
    43c6:	18 8f       	std	Y+24, r17	; 0x18

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    43c8:	84 e6       	ldi	r24, 0x64	; 100
    43ca:	96 e0       	ldi	r25, 0x06	; 6
    43cc:	24 e6       	ldi	r18, 0x64	; 100
    43ce:	36 e0       	ldi	r19, 0x06	; 6
    43d0:	f9 01       	movw	r30, r18
    43d2:	20 81       	ld	r18, Z
    43d4:	2e 7f       	andi	r18, 0xFE	; 254
    43d6:	fc 01       	movw	r30, r24
    43d8:	20 83       	st	Z, r18
    43da:	80 e0       	ldi	r24, 0x00	; 0
    43dc:	90 e0       	ldi	r25, 0x00	; 0
    43de:	a0 e8       	ldi	r26, 0x80	; 128
    43e0:	bf e3       	ldi	r27, 0x3F	; 63
    43e2:	89 8f       	std	Y+25, r24	; 0x19
    43e4:	9a 8f       	std	Y+26, r25	; 0x1a
    43e6:	ab 8f       	std	Y+27, r26	; 0x1b
    43e8:	bc 8f       	std	Y+28, r27	; 0x1c
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    43ea:	69 8d       	ldd	r22, Y+25	; 0x19
    43ec:	7a 8d       	ldd	r23, Y+26	; 0x1a
    43ee:	8b 8d       	ldd	r24, Y+27	; 0x1b
    43f0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    43f2:	2b ea       	ldi	r18, 0xAB	; 171
    43f4:	3a ea       	ldi	r19, 0xAA	; 170
    43f6:	4a ea       	ldi	r20, 0xAA	; 170
    43f8:	5e e3       	ldi	r21, 0x3E	; 62
    43fa:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    43fe:	dc 01       	movw	r26, r24
    4400:	cb 01       	movw	r24, r22
    4402:	8d 8f       	std	Y+29, r24	; 0x1d
    4404:	9e 8f       	std	Y+30, r25	; 0x1e
    4406:	af 8f       	std	Y+31, r26	; 0x1f
    4408:	b8 a3       	lds	r27, 0x58
	if (__tmp < 1.0)
    440a:	11 e0       	ldi	r17, 0x01	; 1
    440c:	6d 8d       	ldd	r22, Y+29	; 0x1d
    440e:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4410:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4412:	98 a1       	lds	r25, 0x48
    4414:	20 e0       	ldi	r18, 0x00	; 0
    4416:	30 e0       	ldi	r19, 0x00	; 0
    4418:	40 e8       	ldi	r20, 0x80	; 128
    441a:	5f e3       	ldi	r21, 0x3F	; 63
    441c:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    4420:	88 23       	and	r24, r24
    4422:	0c f0       	brlt	.+2      	; 0x4426 <chb_reset+0x23e>
    4424:	10 e0       	ldi	r17, 0x00	; 0
    4426:	11 23       	and	r17, r17
    4428:	19 f0       	breq	.+6      	; 0x4430 <chb_reset+0x248>
		__ticks = 1;
    442a:	81 e0       	ldi	r24, 0x01	; 1
    442c:	89 a3       	lds	r24, 0x59
    442e:	a3 c0       	rjmp	.+326    	; 0x4576 <chb_reset+0x38e>
	else if (__tmp > 255)
    4430:	11 e0       	ldi	r17, 0x01	; 1
    4432:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4434:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4436:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4438:	98 a1       	lds	r25, 0x48
    443a:	20 e0       	ldi	r18, 0x00	; 0
    443c:	30 e0       	ldi	r19, 0x00	; 0
    443e:	4f e7       	ldi	r20, 0x7F	; 127
    4440:	53 e4       	ldi	r21, 0x43	; 67
    4442:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    4446:	18 16       	cp	r1, r24
    4448:	0c f0       	brlt	.+2      	; 0x444c <chb_reset+0x264>
    444a:	10 e0       	ldi	r17, 0x00	; 0
    444c:	11 23       	and	r17, r17
    444e:	09 f4       	brne	.+2      	; 0x4452 <chb_reset+0x26a>
    4450:	89 c0       	rjmp	.+274    	; 0x4564 <chb_reset+0x37c>
	{
		_delay_ms(__us / 1000.0);
    4452:	69 8d       	ldd	r22, Y+25	; 0x19
    4454:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4456:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4458:	9c 8d       	ldd	r25, Y+28	; 0x1c
    445a:	20 e0       	ldi	r18, 0x00	; 0
    445c:	30 e0       	ldi	r19, 0x00	; 0
    445e:	4a e7       	ldi	r20, 0x7A	; 122
    4460:	54 e4       	ldi	r21, 0x44	; 68
    4462:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
    4466:	dc 01       	movw	r26, r24
    4468:	cb 01       	movw	r24, r22
    446a:	8a a3       	lds	r24, 0x5a
    446c:	9b a3       	lds	r25, 0x5b
    446e:	ac a3       	lds	r26, 0x5c
    4470:	bd a3       	lds	r27, 0x5d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4472:	6a a1       	lds	r22, 0x4a
    4474:	7b a1       	lds	r23, 0x4b
    4476:	8c a1       	lds	r24, 0x4c
    4478:	9d a1       	lds	r25, 0x4d
    447a:	20 e0       	ldi	r18, 0x00	; 0
    447c:	30 e0       	ldi	r19, 0x00	; 0
    447e:	4a e7       	ldi	r20, 0x7A	; 122
    4480:	53 e4       	ldi	r21, 0x43	; 67
    4482:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    4486:	dc 01       	movw	r26, r24
    4488:	cb 01       	movw	r24, r22
    448a:	8e a3       	lds	r24, 0x5e
    448c:	9f a3       	lds	r25, 0x5f
    448e:	a8 a7       	lds	r26, 0x78
    4490:	b9 a7       	lds	r27, 0x79
	if (__tmp < 1.0)
    4492:	11 e0       	ldi	r17, 0x01	; 1
    4494:	6e a1       	lds	r22, 0x4e
    4496:	7f a1       	lds	r23, 0x4f
    4498:	88 a5       	lds	r24, 0x68
    449a:	99 a5       	lds	r25, 0x69
    449c:	20 e0       	ldi	r18, 0x00	; 0
    449e:	30 e0       	ldi	r19, 0x00	; 0
    44a0:	40 e8       	ldi	r20, 0x80	; 128
    44a2:	5f e3       	ldi	r21, 0x3F	; 63
    44a4:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    44a8:	88 23       	and	r24, r24
    44aa:	0c f0       	brlt	.+2      	; 0x44ae <chb_reset+0x2c6>
    44ac:	10 e0       	ldi	r17, 0x00	; 0
    44ae:	11 23       	and	r17, r17
    44b0:	29 f0       	breq	.+10     	; 0x44bc <chb_reset+0x2d4>
		__ticks = 1;
    44b2:	81 e0       	ldi	r24, 0x01	; 1
    44b4:	90 e0       	ldi	r25, 0x00	; 0
    44b6:	8a a7       	lds	r24, 0x7a
    44b8:	9b a7       	lds	r25, 0x7b
    44ba:	46 c0       	rjmp	.+140    	; 0x4548 <chb_reset+0x360>
	else if (__tmp > 65535)
    44bc:	11 e0       	ldi	r17, 0x01	; 1
    44be:	6e a1       	lds	r22, 0x4e
    44c0:	7f a1       	lds	r23, 0x4f
    44c2:	88 a5       	lds	r24, 0x68
    44c4:	99 a5       	lds	r25, 0x69
    44c6:	20 e0       	ldi	r18, 0x00	; 0
    44c8:	3f ef       	ldi	r19, 0xFF	; 255
    44ca:	4f e7       	ldi	r20, 0x7F	; 127
    44cc:	57 e4       	ldi	r21, 0x47	; 71
    44ce:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    44d2:	18 16       	cp	r1, r24
    44d4:	0c f0       	brlt	.+2      	; 0x44d8 <chb_reset+0x2f0>
    44d6:	10 e0       	ldi	r17, 0x00	; 0
    44d8:	11 23       	and	r17, r17
    44da:	61 f1       	breq	.+88     	; 0x4534 <chb_reset+0x34c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    44dc:	6a a1       	lds	r22, 0x4a
    44de:	7b a1       	lds	r23, 0x4b
    44e0:	8c a1       	lds	r24, 0x4c
    44e2:	9d a1       	lds	r25, 0x4d
    44e4:	20 e0       	ldi	r18, 0x00	; 0
    44e6:	30 e0       	ldi	r19, 0x00	; 0
    44e8:	40 e2       	ldi	r20, 0x20	; 32
    44ea:	51 e4       	ldi	r21, 0x41	; 65
    44ec:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    44f0:	dc 01       	movw	r26, r24
    44f2:	cb 01       	movw	r24, r22
    44f4:	bc 01       	movw	r22, r24
    44f6:	cd 01       	movw	r24, r26
    44f8:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    44fc:	dc 01       	movw	r26, r24
    44fe:	cb 01       	movw	r24, r22
    4500:	8a a7       	lds	r24, 0x7a
    4502:	9b a7       	lds	r25, 0x7b
    4504:	12 c0       	rjmp	.+36     	; 0x452a <chb_reset+0x342>
    4506:	89 e1       	ldi	r24, 0x19	; 25
    4508:	90 e0       	ldi	r25, 0x00	; 0
    450a:	8c a7       	lds	r24, 0x7c
    450c:	9d a7       	lds	r25, 0x7d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    450e:	8c a5       	lds	r24, 0x6c
    4510:	9d a5       	lds	r25, 0x6d
    4512:	8c 01       	movw	r16, r24
    4514:	c8 01       	movw	r24, r16
    4516:	01 97       	sbiw	r24, 0x01	; 1
    4518:	f1 f7       	brne	.-4      	; 0x4516 <chb_reset+0x32e>
    451a:	8c 01       	movw	r16, r24
    451c:	0c a7       	lds	r16, 0x7c
    451e:	1d a7       	lds	r17, 0x7d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4520:	8a a5       	lds	r24, 0x6a
    4522:	9b a5       	lds	r25, 0x6b
    4524:	01 97       	sbiw	r24, 0x01	; 1
    4526:	8a a7       	lds	r24, 0x7a
    4528:	9b a7       	lds	r25, 0x7b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    452a:	8a a5       	lds	r24, 0x6a
    452c:	9b a5       	lds	r25, 0x6b
    452e:	00 97       	sbiw	r24, 0x00	; 0
    4530:	51 f7       	brne	.-44     	; 0x4506 <chb_reset+0x31e>
    4532:	28 c0       	rjmp	.+80     	; 0x4584 <chb_reset+0x39c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4534:	6e a1       	lds	r22, 0x4e
    4536:	7f a1       	lds	r23, 0x4f
    4538:	88 a5       	lds	r24, 0x68
    453a:	99 a5       	lds	r25, 0x69
    453c:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    4540:	dc 01       	movw	r26, r24
    4542:	cb 01       	movw	r24, r22
    4544:	8a a7       	lds	r24, 0x7a
    4546:	9b a7       	lds	r25, 0x7b
    4548:	8a a5       	lds	r24, 0x6a
    454a:	9b a5       	lds	r25, 0x6b
    454c:	8e a7       	lds	r24, 0x7e
    454e:	9f a7       	lds	r25, 0x7f
    4550:	8e a5       	lds	r24, 0x6e
    4552:	9f a5       	lds	r25, 0x6f
    4554:	8c 01       	movw	r16, r24
    4556:	f8 01       	movw	r30, r16
    4558:	31 97       	sbiw	r30, 0x01	; 1
    455a:	f1 f7       	brne	.-4      	; 0x4558 <chb_reset+0x370>
    455c:	8f 01       	movw	r16, r30
    455e:	0e a7       	lds	r16, 0x7e
    4560:	1f a7       	lds	r17, 0x7f
    4562:	10 c0       	rjmp	.+32     	; 0x4584 <chb_reset+0x39c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4564:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4566:	7e 8d       	ldd	r23, Y+30	; 0x1e
    4568:	8f 8d       	ldd	r24, Y+31	; 0x1f
    456a:	98 a1       	lds	r25, 0x48
    456c:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    4570:	dc 01       	movw	r26, r24
    4572:	cb 01       	movw	r24, r22
    4574:	89 a3       	lds	r24, 0x59
    4576:	89 a1       	lds	r24, 0x49
    4578:	88 ab       	sts	0x58, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    457a:	88 a9       	sts	0x48, r24
    457c:	18 2f       	mov	r17, r24
    457e:	1a 95       	dec	r17
    4580:	f1 f7       	brne	.-4      	; 0x457e <chb_reset+0x396>
    4582:	18 ab       	sts	0x58, r17
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    4584:	84 e6       	ldi	r24, 0x64	; 100
    4586:	96 e0       	ldi	r25, 0x06	; 6
    4588:	24 e6       	ldi	r18, 0x64	; 100
    458a:	36 e0       	ldi	r19, 0x06	; 6
    458c:	f9 01       	movw	r30, r18
    458e:	20 81       	ld	r18, Z
    4590:	21 60       	ori	r18, 0x01	; 1
    4592:	fc 01       	movw	r30, r24
    4594:	20 83       	st	Z, r18
    4596:	01 c0       	rjmp	.+2      	; 0x459a <chb_reset+0x3b2>
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
        {
            break;
        }
    }
    4598:	00 00       	nop
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    459a:	8d e1       	ldi	r24, 0x1D	; 29
    459c:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <chb_reg_read>
    45a0:	81 30       	cpi	r24, 0x01	; 1
    45a2:	d1 f7       	brne	.-12     	; 0x4598 <chb_reset+0x3b0>
    45a4:	8c e1       	ldi	r24, 0x1C	; 28
    45a6:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <chb_reg_read>
    45aa:	87 30       	cpi	r24, 0x07	; 7
    45ac:	a9 f7       	brne	.-22     	; 0x4598 <chb_reset+0x3b0>
        {
            break;
    45ae:	00 00       	nop
        }
    }
	

}
    45b0:	e0 96       	adiw	r28, 0x30	; 48
    45b2:	cd bf       	out	0x3d, r28	; 61
    45b4:	de bf       	out	0x3e, r29	; 62
    45b6:	df 91       	pop	r29
    45b8:	cf 91       	pop	r28
    45ba:	1f 91       	pop	r17
    45bc:	0f 91       	pop	r16
    45be:	08 95       	ret

000045c0 <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    45c0:	cf 93       	push	r28
    45c2:	df 93       	push	r29
    45c4:	0f 92       	push	r0
    45c6:	0f 92       	push	r0
    45c8:	cd b7       	in	r28, 0x3d	; 61
    45ca:	de b7       	in	r29, 0x3e	; 62
    45cc:	8a 83       	std	Y+2, r24	; 0x02
    U8 val = 0;
    45ce:	19 82       	std	Y+1, r1	; 0x01

    /* Add the register read command to the register address. */
    addr |= 0x80;
    45d0:	8a 81       	ldd	r24, Y+2	; 0x02
    45d2:	80 68       	ori	r24, 0x80	; 128
    45d4:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    45d6:	8f e3       	ldi	r24, 0x3F	; 63
    45d8:	90 e0       	ldi	r25, 0x00	; 0
    45da:	fc 01       	movw	r30, r24
    45dc:	80 81       	ld	r24, Z
    45de:	80 93 4f 40 	sts	0x404F, r24
    45e2:	f8 94       	cli
    RadioCS(TRUE);
    45e4:	81 e0       	ldi	r24, 0x01	; 1
    45e6:	0e 94 65 2e 	call	0x5cca	; 0x5cca <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    45ea:	8a 81       	ldd	r24, Y+2	; 0x02
    45ec:	0e 94 c2 2f 	call	0x5f84	; 0x5f84 <SPID_write>
    45f0:	89 83       	std	Y+1, r24	; 0x01
    val = SPID_write(val);
    45f2:	89 81       	ldd	r24, Y+1	; 0x01
    45f4:	0e 94 c2 2f 	call	0x5f84	; 0x5f84 <SPID_write>
    45f8:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    45fa:	80 e0       	ldi	r24, 0x00	; 0
    45fc:	0e 94 65 2e 	call	0x5cca	; 0x5cca <RadioCS>
    CHB_LEAVE_CRIT();
    4600:	8f e3       	ldi	r24, 0x3F	; 63
    4602:	90 e0       	ldi	r25, 0x00	; 0
    4604:	20 91 4f 40 	lds	r18, 0x404F
    4608:	fc 01       	movw	r30, r24
    460a:	20 83       	st	Z, r18
    460c:	78 94       	sei

    return val;
    460e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4610:	0f 90       	pop	r0
    4612:	0f 90       	pop	r0
    4614:	df 91       	pop	r29
    4616:	cf 91       	pop	r28
    4618:	08 95       	ret

0000461a <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    461a:	cf 93       	push	r28
    461c:	df 93       	push	r29
    461e:	00 d0       	rcall	.+0      	; 0x4620 <chb_reg_read16+0x6>
    4620:	0f 92       	push	r0
    4622:	cd b7       	in	r28, 0x3d	; 61
    4624:	de b7       	in	r29, 0x3e	; 62
    4626:	8c 83       	std	Y+4, r24	; 0x04
    U8 i;
    U16 val = 0;
    4628:	1a 82       	std	Y+2, r1	; 0x02
    462a:	1b 82       	std	Y+3, r1	; 0x03

    for (i=0; i<2; i++)
    462c:	19 82       	std	Y+1, r1	; 0x01
    462e:	1d c0       	rjmp	.+58     	; 0x466a <chb_reg_read16+0x50>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    4630:	9c 81       	ldd	r25, Y+4	; 0x04
    4632:	89 81       	ldd	r24, Y+1	; 0x01
    4634:	89 0f       	add	r24, r25
    4636:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <chb_reg_read>
    463a:	88 2f       	mov	r24, r24
    463c:	90 e0       	ldi	r25, 0x00	; 0
    463e:	29 81       	ldd	r18, Y+1	; 0x01
    4640:	22 2f       	mov	r18, r18
    4642:	30 e0       	ldi	r19, 0x00	; 0
    4644:	22 0f       	add	r18, r18
    4646:	33 1f       	adc	r19, r19
    4648:	22 0f       	add	r18, r18
    464a:	33 1f       	adc	r19, r19
    464c:	22 0f       	add	r18, r18
    464e:	33 1f       	adc	r19, r19
    4650:	02 2e       	mov	r0, r18
    4652:	02 c0       	rjmp	.+4      	; 0x4658 <chb_reg_read16+0x3e>
    4654:	88 0f       	add	r24, r24
    4656:	99 1f       	adc	r25, r25
    4658:	0a 94       	dec	r0
    465a:	e2 f7       	brpl	.-8      	; 0x4654 <chb_reg_read16+0x3a>
    465c:	98 2f       	mov	r25, r24
    465e:	8c 81       	ldd	r24, Y+4	; 0x04
    4660:	89 2b       	or	r24, r25
    4662:	8c 83       	std	Y+4, r24	; 0x04
U16 chb_reg_read16(U8 addr)
{
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    4664:	89 81       	ldd	r24, Y+1	; 0x01
    4666:	8f 5f       	subi	r24, 0xFF	; 255
    4668:	89 83       	std	Y+1, r24	; 0x01
    466a:	89 81       	ldd	r24, Y+1	; 0x01
    466c:	82 30       	cpi	r24, 0x02	; 2
    466e:	00 f3       	brcs	.-64     	; 0x4630 <chb_reg_read16+0x16>
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    }
    return val;
    4670:	8a 81       	ldd	r24, Y+2	; 0x02
    4672:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4674:	24 96       	adiw	r28, 0x04	; 4
    4676:	cd bf       	out	0x3d, r28	; 61
    4678:	de bf       	out	0x3e, r29	; 62
    467a:	df 91       	pop	r29
    467c:	cf 91       	pop	r28
    467e:	08 95       	ret

00004680 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    4680:	cf 93       	push	r28
    4682:	df 93       	push	r29
    4684:	00 d0       	rcall	.+0      	; 0x4686 <chb_reg_write+0x6>
    4686:	cd b7       	in	r28, 0x3d	; 61
    4688:	de b7       	in	r29, 0x3e	; 62
    468a:	8a 83       	std	Y+2, r24	; 0x02
    468c:	6b 83       	std	Y+3, r22	; 0x03
    U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;
    468e:	8a 81       	ldd	r24, Y+2	; 0x02
    4690:	80 6c       	ori	r24, 0xC0	; 192
    4692:	8a 83       	std	Y+2, r24	; 0x02

    CHB_ENTER_CRIT();
    4694:	8f e3       	ldi	r24, 0x3F	; 63
    4696:	90 e0       	ldi	r25, 0x00	; 0
    4698:	fc 01       	movw	r30, r24
    469a:	80 81       	ld	r24, Z
    469c:	80 93 4f 40 	sts	0x404F, r24
    46a0:	f8 94       	cli
    RadioCS(TRUE);
    46a2:	81 e0       	ldi	r24, 0x01	; 1
    46a4:	0e 94 65 2e 	call	0x5cca	; 0x5cca <RadioCS>

    /*Send Register address and write register content.*/
    dummy = SPID_write(addr);
    46a8:	8a 81       	ldd	r24, Y+2	; 0x02
    46aa:	0e 94 c2 2f 	call	0x5f84	; 0x5f84 <SPID_write>
    46ae:	89 83       	std	Y+1, r24	; 0x01
    dummy = SPID_write(val);
    46b0:	8b 81       	ldd	r24, Y+3	; 0x03
    46b2:	0e 94 c2 2f 	call	0x5f84	; 0x5f84 <SPID_write>
    46b6:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    46b8:	80 e0       	ldi	r24, 0x00	; 0
    46ba:	0e 94 65 2e 	call	0x5cca	; 0x5cca <RadioCS>
    CHB_LEAVE_CRIT();
    46be:	8f e3       	ldi	r24, 0x3F	; 63
    46c0:	90 e0       	ldi	r25, 0x00	; 0
    46c2:	20 91 4f 40 	lds	r18, 0x404F
    46c6:	fc 01       	movw	r30, r24
    46c8:	20 83       	st	Z, r18
    46ca:	78 94       	sei
}
    46cc:	23 96       	adiw	r28, 0x03	; 3
    46ce:	cd bf       	out	0x3d, r28	; 61
    46d0:	de bf       	out	0x3e, r29	; 62
    46d2:	df 91       	pop	r29
    46d4:	cf 91       	pop	r28
    46d6:	08 95       	ret

000046d8 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    46d8:	cf 93       	push	r28
    46da:	df 93       	push	r29
    46dc:	00 d0       	rcall	.+0      	; 0x46de <chb_reg_write16+0x6>
    46de:	0f 92       	push	r0
    46e0:	cd b7       	in	r28, 0x3d	; 61
    46e2:	de b7       	in	r29, 0x3e	; 62
    46e4:	8a 83       	std	Y+2, r24	; 0x02
    46e6:	6b 83       	std	Y+3, r22	; 0x03
    46e8:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<2; i++)
    46ea:	19 82       	std	Y+1, r1	; 0x01
    46ec:	1d c0       	rjmp	.+58     	; 0x4728 <chb_reg_write16+0x50>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    46ee:	9a 81       	ldd	r25, Y+2	; 0x02
    46f0:	89 81       	ldd	r24, Y+1	; 0x01
    46f2:	49 2f       	mov	r20, r25
    46f4:	48 0f       	add	r20, r24
    46f6:	89 81       	ldd	r24, Y+1	; 0x01
    46f8:	88 2f       	mov	r24, r24
    46fa:	90 e0       	ldi	r25, 0x00	; 0
    46fc:	9c 01       	movw	r18, r24
    46fe:	22 0f       	add	r18, r18
    4700:	33 1f       	adc	r19, r19
    4702:	22 0f       	add	r18, r18
    4704:	33 1f       	adc	r19, r19
    4706:	22 0f       	add	r18, r18
    4708:	33 1f       	adc	r19, r19
    470a:	8b 81       	ldd	r24, Y+3	; 0x03
    470c:	9c 81       	ldd	r25, Y+4	; 0x04
    470e:	02 c0       	rjmp	.+4      	; 0x4714 <chb_reg_write16+0x3c>
    4710:	96 95       	lsr	r25
    4712:	87 95       	ror	r24
    4714:	2a 95       	dec	r18
    4716:	e2 f7       	brpl	.-8      	; 0x4710 <chb_reg_write16+0x38>
    4718:	98 2f       	mov	r25, r24
    471a:	84 2f       	mov	r24, r20
    471c:	69 2f       	mov	r22, r25
    471e:	0e 94 40 23 	call	0x4680	; 0x4680 <chb_reg_write>
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    U8 i;

    for (i=0; i<2; i++)
    4722:	89 81       	ldd	r24, Y+1	; 0x01
    4724:	8f 5f       	subi	r24, 0xFF	; 255
    4726:	89 83       	std	Y+1, r24	; 0x01
    4728:	89 81       	ldd	r24, Y+1	; 0x01
    472a:	82 30       	cpi	r24, 0x02	; 2
    472c:	00 f3       	brcs	.-64     	; 0x46ee <chb_reg_write16+0x16>
    {
        chb_reg_write(addr + i, val >> (8 * i));
    }
}
    472e:	24 96       	adiw	r28, 0x04	; 4
    4730:	cd bf       	out	0x3d, r28	; 61
    4732:	de bf       	out	0x3e, r29	; 62
    4734:	df 91       	pop	r29
    4736:	cf 91       	pop	r28
    4738:	08 95       	ret

0000473a <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    473a:	cf 93       	push	r28
    473c:	df 93       	push	r29
    473e:	00 d0       	rcall	.+0      	; 0x4740 <chb_reg_write64+0x6>
    4740:	0f 92       	push	r0
    4742:	cd b7       	in	r28, 0x3d	; 61
    4744:	de b7       	in	r29, 0x3e	; 62
    4746:	8a 83       	std	Y+2, r24	; 0x02
    4748:	6b 83       	std	Y+3, r22	; 0x03
    474a:	7c 83       	std	Y+4, r23	; 0x04
    U8 i;

    for (i=0; i<8; i++)
    474c:	19 82       	std	Y+1, r1	; 0x01
    474e:	14 c0       	rjmp	.+40     	; 0x4778 <chb_reg_write64+0x3e>
    {
        chb_reg_write(addr + i, *(val + i));
    4750:	9a 81       	ldd	r25, Y+2	; 0x02
    4752:	89 81       	ldd	r24, Y+1	; 0x01
    4754:	49 2f       	mov	r20, r25
    4756:	48 0f       	add	r20, r24
    4758:	89 81       	ldd	r24, Y+1	; 0x01
    475a:	88 2f       	mov	r24, r24
    475c:	90 e0       	ldi	r25, 0x00	; 0
    475e:	2b 81       	ldd	r18, Y+3	; 0x03
    4760:	3c 81       	ldd	r19, Y+4	; 0x04
    4762:	82 0f       	add	r24, r18
    4764:	93 1f       	adc	r25, r19
    4766:	fc 01       	movw	r30, r24
    4768:	90 81       	ld	r25, Z
    476a:	84 2f       	mov	r24, r20
    476c:	69 2f       	mov	r22, r25
    476e:	0e 94 40 23 	call	0x4680	; 0x4680 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    4772:	89 81       	ldd	r24, Y+1	; 0x01
    4774:	8f 5f       	subi	r24, 0xFF	; 255
    4776:	89 83       	std	Y+1, r24	; 0x01
    4778:	89 81       	ldd	r24, Y+1	; 0x01
    477a:	88 30       	cpi	r24, 0x08	; 8
    477c:	48 f3       	brcs	.-46     	; 0x4750 <chb_reg_write64+0x16>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    477e:	24 96       	adiw	r28, 0x04	; 4
    4780:	cd bf       	out	0x3d, r28	; 61
    4782:	de bf       	out	0x3e, r29	; 62
    4784:	df 91       	pop	r29
    4786:	cf 91       	pop	r28
    4788:	08 95       	ret

0000478a <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    478a:	cf 93       	push	r28
    478c:	df 93       	push	r29
    478e:	00 d0       	rcall	.+0      	; 0x4790 <chb_reg_read_mod_write+0x6>
    4790:	0f 92       	push	r0
    4792:	cd b7       	in	r28, 0x3d	; 61
    4794:	de b7       	in	r29, 0x3e	; 62
    4796:	8a 83       	std	Y+2, r24	; 0x02
    4798:	6b 83       	std	Y+3, r22	; 0x03
    479a:	4c 83       	std	Y+4, r20	; 0x04
    U8 tmp;

    tmp = chb_reg_read(addr);
    479c:	8a 81       	ldd	r24, Y+2	; 0x02
    479e:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <chb_reg_read>
    47a2:	89 83       	std	Y+1, r24	; 0x01
    val &= mask;                // mask off stray bits from val
    47a4:	9b 81       	ldd	r25, Y+3	; 0x03
    47a6:	8c 81       	ldd	r24, Y+4	; 0x04
    47a8:	89 23       	and	r24, r25
    47aa:	8b 83       	std	Y+3, r24	; 0x03
    tmp &= ~mask;               // mask off bits in reg val
    47ac:	8c 81       	ldd	r24, Y+4	; 0x04
    47ae:	98 2f       	mov	r25, r24
    47b0:	90 95       	com	r25
    47b2:	89 81       	ldd	r24, Y+1	; 0x01
    47b4:	89 23       	and	r24, r25
    47b6:	89 83       	std	Y+1, r24	; 0x01
    tmp |= val;                 // copy val into reg val
    47b8:	99 81       	ldd	r25, Y+1	; 0x01
    47ba:	8b 81       	ldd	r24, Y+3	; 0x03
    47bc:	89 2b       	or	r24, r25
    47be:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(addr, tmp);   // write back to reg
    47c0:	8a 81       	ldd	r24, Y+2	; 0x02
    47c2:	69 81       	ldd	r22, Y+1	; 0x01
    47c4:	0e 94 40 23 	call	0x4680	; 0x4680 <chb_reg_write>
}
    47c8:	24 96       	adiw	r28, 0x04	; 4
    47ca:	cd bf       	out	0x3d, r28	; 61
    47cc:	de bf       	out	0x3e, r29	; 62
    47ce:	df 91       	pop	r29
    47d0:	cf 91       	pop	r28
    47d2:	08 95       	ret

000047d4 <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    47d4:	cf 93       	push	r28
    47d6:	df 93       	push	r29
    47d8:	cd b7       	in	r28, 0x3d	; 61
    47da:	de b7       	in	r29, 0x3e	; 62
    47dc:	28 97       	sbiw	r28, 0x08	; 8
    47de:	cd bf       	out	0x3d, r28	; 61
    47e0:	de bf       	out	0x3e, r29	; 62
    47e2:	8b 83       	std	Y+3, r24	; 0x03
    47e4:	9c 83       	std	Y+4, r25	; 0x04
    47e6:	6d 83       	std	Y+5, r22	; 0x05
    47e8:	4e 83       	std	Y+6, r20	; 0x06
    47ea:	5f 83       	std	Y+7, r21	; 0x07
    47ec:	28 87       	std	Y+8, r18	; 0x08
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    47ee:	8d 81       	ldd	r24, Y+5	; 0x05
    47f0:	28 2f       	mov	r18, r24
    47f2:	30 e0       	ldi	r19, 0x00	; 0
    47f4:	88 85       	ldd	r24, Y+8	; 0x08
    47f6:	88 2f       	mov	r24, r24
    47f8:	90 e0       	ldi	r25, 0x00	; 0
    47fa:	82 0f       	add	r24, r18
    47fc:	93 1f       	adc	r25, r19
    47fe:	80 38       	cpi	r24, 0x80	; 128
    4800:	91 05       	cpc	r25, r1
    4802:	0c f0       	brlt	.+2      	; 0x4806 <chb_frame_write+0x32>
    4804:	45 c0       	rjmp	.+138    	; 0x4890 <chb_frame_write+0xbc>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    4806:	8f e3       	ldi	r24, 0x3F	; 63
    4808:	90 e0       	ldi	r25, 0x00	; 0
    480a:	fc 01       	movw	r30, r24
    480c:	80 81       	ld	r24, Z
    480e:	80 93 4f 40 	sts	0x404F, r24
    4812:	f8 94       	cli
    RadioCS(TRUE); 
    4814:	81 e0       	ldi	r24, 0x01	; 1
    4816:	0e 94 65 2e 	call	0x5cca	; 0x5cca <RadioCS>

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);
    481a:	80 e6       	ldi	r24, 0x60	; 96
    481c:	0e 94 c2 2f 	call	0x5f84	; 0x5f84 <SPID_write>
    4820:	8a 83       	std	Y+2, r24	; 0x02

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4822:	19 82       	std	Y+1, r1	; 0x01
    4824:	10 c0       	rjmp	.+32     	; 0x4846 <chb_frame_write+0x72>
    {
        dummy = SPID_write(*hdr++);
    4826:	8b 81       	ldd	r24, Y+3	; 0x03
    4828:	9c 81       	ldd	r25, Y+4	; 0x04
    482a:	fc 01       	movw	r30, r24
    482c:	20 81       	ld	r18, Z
    482e:	8b 81       	ldd	r24, Y+3	; 0x03
    4830:	9c 81       	ldd	r25, Y+4	; 0x04
    4832:	01 96       	adiw	r24, 0x01	; 1
    4834:	8b 83       	std	Y+3, r24	; 0x03
    4836:	9c 83       	std	Y+4, r25	; 0x04
    4838:	82 2f       	mov	r24, r18
    483a:	0e 94 c2 2f 	call	0x5f84	; 0x5f84 <SPID_write>
    483e:	8a 83       	std	Y+2, r24	; 0x02

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    4840:	89 81       	ldd	r24, Y+1	; 0x01
    4842:	8f 5f       	subi	r24, 0xFF	; 255
    4844:	89 83       	std	Y+1, r24	; 0x01
    4846:	99 81       	ldd	r25, Y+1	; 0x01
    4848:	8d 81       	ldd	r24, Y+5	; 0x05
    484a:	98 17       	cp	r25, r24
    484c:	60 f3       	brcs	.-40     	; 0x4826 <chb_frame_write+0x52>
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    484e:	19 82       	std	Y+1, r1	; 0x01
    4850:	10 c0       	rjmp	.+32     	; 0x4872 <chb_frame_write+0x9e>
    {
        dummy = SPID_write(*data++);
    4852:	8e 81       	ldd	r24, Y+6	; 0x06
    4854:	9f 81       	ldd	r25, Y+7	; 0x07
    4856:	fc 01       	movw	r30, r24
    4858:	20 81       	ld	r18, Z
    485a:	8e 81       	ldd	r24, Y+6	; 0x06
    485c:	9f 81       	ldd	r25, Y+7	; 0x07
    485e:	01 96       	adiw	r24, 0x01	; 1
    4860:	8e 83       	std	Y+6, r24	; 0x06
    4862:	9f 83       	std	Y+7, r25	; 0x07
    4864:	82 2f       	mov	r24, r18
    4866:	0e 94 c2 2f 	call	0x5f84	; 0x5f84 <SPID_write>
    486a:	8a 83       	std	Y+2, r24	; 0x02
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    486c:	89 81       	ldd	r24, Y+1	; 0x01
    486e:	8f 5f       	subi	r24, 0xFF	; 255
    4870:	89 83       	std	Y+1, r24	; 0x01
    4872:	99 81       	ldd	r25, Y+1	; 0x01
    4874:	88 85       	ldd	r24, Y+8	; 0x08
    4876:	98 17       	cp	r25, r24
    4878:	60 f3       	brcs	.-40     	; 0x4852 <chb_frame_write+0x7e>
    {
        dummy = SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    487a:	80 e0       	ldi	r24, 0x00	; 0
    487c:	0e 94 65 2e 	call	0x5cca	; 0x5cca <RadioCS>
    CHB_LEAVE_CRIT();
    4880:	8f e3       	ldi	r24, 0x3F	; 63
    4882:	90 e0       	ldi	r25, 0x00	; 0
    4884:	20 91 4f 40 	lds	r18, 0x404F
    4888:	fc 01       	movw	r30, r24
    488a:	20 83       	st	Z, r18
    488c:	78 94       	sei
    488e:	01 c0       	rjmp	.+2      	; 0x4892 <chb_frame_write+0xbe>
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    {
        return;
    4890:	00 00       	nop
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    CHB_LEAVE_CRIT();
}
    4892:	28 96       	adiw	r28, 0x08	; 8
    4894:	cd bf       	out	0x3d, r28	; 61
    4896:	de bf       	out	0x3e, r29	; 62
    4898:	df 91       	pop	r29
    489a:	cf 91       	pop	r28
    489c:	08 95       	ret

0000489e <chb_frame_read>:
/*!

*/
/**************************************************************************/
static void chb_frame_read()
{
    489e:	0f 93       	push	r16
    48a0:	1f 93       	push	r17
    48a2:	cf 93       	push	r28
    48a4:	df 93       	push	r29
    48a6:	cd b7       	in	r28, 0x3d	; 61
    48a8:	de b7       	in	r29, 0x3e	; 62
    48aa:	e7 97       	sbiw	r28, 0x37	; 55
    48ac:	cd bf       	out	0x3d, r28	; 61
    48ae:	de bf       	out	0x3e, r29	; 62
    U8 i, len, data;

    CHB_ENTER_CRIT();
    48b0:	8f e3       	ldi	r24, 0x3F	; 63
    48b2:	90 e0       	ldi	r25, 0x00	; 0
    48b4:	fc 01       	movw	r30, r24
    48b6:	80 81       	ld	r24, Z
    48b8:	80 93 4f 40 	sts	0x404F, r24
    48bc:	f8 94       	cli
    RadioCS(TRUE);
    48be:	81 e0       	ldi	r24, 0x01	; 1
    48c0:	0e 94 65 2e 	call	0x5cca	; 0x5cca <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    48c4:	80 e2       	ldi	r24, 0x20	; 32
    48c6:	0e 94 c2 2f 	call	0x5f84	; 0x5f84 <SPID_write>
    len = SPID_write(0);
    48ca:	80 e0       	ldi	r24, 0x00	; 0
    48cc:	0e 94 c2 2f 	call	0x5f84	; 0x5f84 <SPID_write>
    48d0:	8a 83       	std	Y+2, r24	; 0x02

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    48d2:	8a 81       	ldd	r24, Y+2	; 0x02
    48d4:	83 30       	cpi	r24, 0x03	; 3
    48d6:	08 f4       	brcc	.+2      	; 0x48da <chb_frame_read+0x3c>
    48d8:	66 c0       	rjmp	.+204    	; 0x49a6 <chb_frame_read+0x108>
    48da:	8a 81       	ldd	r24, Y+2	; 0x02
    48dc:	88 23       	and	r24, r24
    48de:	0c f4       	brge	.+2      	; 0x48e2 <chb_frame_read+0x44>
    48e0:	62 c0       	rjmp	.+196    	; 0x49a6 <chb_frame_read+0x108>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    48e2:	8a 81       	ldd	r24, Y+2	; 0x02
    48e4:	08 2f       	mov	r16, r24
    48e6:	10 e0       	ldi	r17, 0x00	; 0
    48e8:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <chb_buf_get_len>
    48ec:	88 2f       	mov	r24, r24
    48ee:	90 e0       	ldi	r25, 0x00	; 0
    48f0:	20 e8       	ldi	r18, 0x80	; 128
    48f2:	30 e0       	ldi	r19, 0x00	; 0
    48f4:	a9 01       	movw	r20, r18
    48f6:	48 1b       	sub	r20, r24
    48f8:	59 0b       	sbc	r21, r25
    48fa:	ca 01       	movw	r24, r20
    48fc:	08 17       	cp	r16, r24
    48fe:	19 07       	cpc	r17, r25
    4900:	f4 f4       	brge	.+60     	; 0x493e <chb_frame_read+0xa0>
        {
            chb_buf_write(len);
    4902:	8a 81       	ldd	r24, Y+2	; 0x02
    4904:	0e 94 8b 20 	call	0x4116	; 0x4116 <chb_buf_write>
            
            for (i=0; i<len; i++)
    4908:	19 82       	std	Y+1, r1	; 0x01
    490a:	0a c0       	rjmp	.+20     	; 0x4920 <chb_frame_read+0x82>
            {
                data = SPID_write(0);
    490c:	80 e0       	ldi	r24, 0x00	; 0
    490e:	0e 94 c2 2f 	call	0x5f84	; 0x5f84 <SPID_write>
    4912:	8b 83       	std	Y+3, r24	; 0x03
                chb_buf_write(data);
    4914:	8b 81       	ldd	r24, Y+3	; 0x03
    4916:	0e 94 8b 20 	call	0x4116	; 0x4116 <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    491a:	89 81       	ldd	r24, Y+1	; 0x01
    491c:	8f 5f       	subi	r24, 0xFF	; 255
    491e:	89 83       	std	Y+1, r24	; 0x01
    4920:	99 81       	ldd	r25, Y+1	; 0x01
    4922:	8a 81       	ldd	r24, Y+2	; 0x02
    4924:	98 17       	cp	r25, r24
    4926:	90 f3       	brcs	.-28     	; 0x490c <chb_frame_read+0x6e>
                chb_buf_write(data);
            }
			//generate message received event here
			//EVSYS.STROBE = 0x04;  //generate event on channel 3
			//generate interrupt on port E by toggling pin 2
			PORTE.OUTSET = PIN2_bm;
    4928:	80 e8       	ldi	r24, 0x80	; 128
    492a:	96 e0       	ldi	r25, 0x06	; 6
    492c:	24 e0       	ldi	r18, 0x04	; 4
    492e:	fc 01       	movw	r30, r24
    4930:	25 83       	std	Z+5, r18	; 0x05
			PORTE.OUTCLR = PIN2_bm;
    4932:	80 e8       	ldi	r24, 0x80	; 128
    4934:	96 e0       	ldi	r25, 0x06	; 6
    4936:	24 e0       	ldi	r18, 0x04	; 4
    4938:	fc 01       	movw	r30, r24
    493a:	26 83       	std	Z+6, r18	; 0x06
    493c:	34 c0       	rjmp	.+104    	; 0x49a6 <chb_frame_read+0x108>
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    493e:	0e 94 d3 1d 	call	0x3ba6	; 0x3ba6 <chb_get_pcb>
    4942:	8c 83       	std	Y+4, r24	; 0x04
    4944:	9d 83       	std	Y+5, r25	; 0x05
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4946:	19 82       	std	Y+1, r1	; 0x01
    4948:	07 c0       	rjmp	.+14     	; 0x4958 <chb_frame_read+0xba>
            {
                data = SPID_write(0);
    494a:	80 e0       	ldi	r24, 0x00	; 0
    494c:	0e 94 c2 2f 	call	0x5f84	; 0x5f84 <SPID_write>
    4950:	8b 83       	std	Y+3, r24	; 0x03
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    4952:	89 81       	ldd	r24, Y+1	; 0x01
    4954:	8f 5f       	subi	r24, 0xFF	; 255
    4956:	89 83       	std	Y+1, r24	; 0x01
    4958:	99 81       	ldd	r25, Y+1	; 0x01
    495a:	8a 81       	ldd	r24, Y+2	; 0x02
    495c:	98 17       	cp	r25, r24
    495e:	a8 f3       	brcs	.-22     	; 0x494a <chb_frame_read+0xac>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    4960:	8c 81       	ldd	r24, Y+4	; 0x04
    4962:	9d 81       	ldd	r25, Y+5	; 0x05
    4964:	fc 01       	movw	r30, r24
    4966:	85 85       	ldd	r24, Z+13	; 0x0d
    4968:	96 85       	ldd	r25, Z+14	; 0x0e
    496a:	9c 01       	movw	r18, r24
    496c:	2f 5f       	subi	r18, 0xFF	; 255
    496e:	3f 4f       	sbci	r19, 0xFF	; 255
    4970:	8c 81       	ldd	r24, Y+4	; 0x04
    4972:	9d 81       	ldd	r25, Y+5	; 0x05
    4974:	fc 01       	movw	r30, r24
    4976:	25 87       	std	Z+13, r18	; 0x0d
    4978:	36 87       	std	Z+14, r19	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    497a:	ce 01       	movw	r24, r28
    497c:	06 96       	adiw	r24, 0x06	; 6
    497e:	28 ee       	ldi	r18, 0xE8	; 232
    4980:	31 e0       	ldi	r19, 0x01	; 1
    4982:	b9 01       	movw	r22, r18
    4984:	0e 94 47 5c 	call	0xb88e	; 0xb88e <strcpy_P>
            printf(buf);
    4988:	0f 92       	push	r0
    498a:	0f 92       	push	r0
    498c:	8d b7       	in	r24, 0x3d	; 61
    498e:	9e b7       	in	r25, 0x3e	; 62
    4990:	01 96       	adiw	r24, 0x01	; 1
    4992:	9e 01       	movw	r18, r28
    4994:	2a 5f       	subi	r18, 0xFA	; 250
    4996:	3f 4f       	sbci	r19, 0xFF	; 255
    4998:	fc 01       	movw	r30, r24
    499a:	20 83       	st	Z, r18
    499c:	31 83       	std	Z+1, r19	; 0x01
    499e:	0e 94 a3 5c 	call	0xb946	; 0xb946 <printf>
    49a2:	0f 90       	pop	r0
    49a4:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    49a6:	80 e0       	ldi	r24, 0x00	; 0
    49a8:	0e 94 65 2e 	call	0x5cca	; 0x5cca <RadioCS>
    CHB_LEAVE_CRIT();
    49ac:	8f e3       	ldi	r24, 0x3F	; 63
    49ae:	90 e0       	ldi	r25, 0x00	; 0
    49b0:	20 91 4f 40 	lds	r18, 0x404F
    49b4:	fc 01       	movw	r30, r24
    49b6:	20 83       	st	Z, r18
    49b8:	78 94       	sei
}
    49ba:	e7 96       	adiw	r28, 0x37	; 55
    49bc:	cd bf       	out	0x3d, r28	; 61
    49be:	de bf       	out	0x3e, r29	; 62
    49c0:	df 91       	pop	r29
    49c2:	cf 91       	pop	r28
    49c4:	1f 91       	pop	r17
    49c6:	0f 91       	pop	r16
    49c8:	08 95       	ret

000049ca <chb_set_mode>:
/*!
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    49ca:	cf 93       	push	r28
    49cc:	df 93       	push	r29
    49ce:	0f 92       	push	r0
    49d0:	cd b7       	in	r28, 0x3d	; 61
    49d2:	de b7       	in	r29, 0x3e	; 62
    49d4:	89 83       	std	Y+1, r24	; 0x01
    switch (mode)
    49d6:	89 81       	ldd	r24, Y+1	; 0x01
    49d8:	88 2f       	mov	r24, r24
    49da:	90 e0       	ldi	r25, 0x00	; 0
    49dc:	81 30       	cpi	r24, 0x01	; 1
    49de:	91 05       	cpc	r25, r1
    49e0:	c1 f0       	breq	.+48     	; 0x4a12 <chb_set_mode+0x48>
    49e2:	82 30       	cpi	r24, 0x02	; 2
    49e4:	91 05       	cpc	r25, r1
    49e6:	1c f4       	brge	.+6      	; 0x49ee <chb_set_mode+0x24>
    49e8:	00 97       	sbiw	r24, 0x00	; 0
    49ea:	41 f0       	breq	.+16     	; 0x49fc <chb_set_mode+0x32>
    49ec:	33 c0       	rjmp	.+102    	; 0x4a54 <chb_set_mode+0x8a>
    49ee:	82 30       	cpi	r24, 0x02	; 2
    49f0:	91 05       	cpc	r25, r1
    49f2:	d1 f0       	breq	.+52     	; 0x4a28 <chb_set_mode+0x5e>
    49f4:	83 30       	cpi	r24, 0x03	; 3
    49f6:	91 05       	cpc	r25, r1
    49f8:	11 f1       	breq	.+68     	; 0x4a3e <chb_set_mode+0x74>
    49fa:	2c c0       	rjmp	.+88     	; 0x4a54 <chb_set_mode+0x8a>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    49fc:	8c e0       	ldi	r24, 0x0C	; 12
    49fe:	68 e0       	ldi	r22, 0x08	; 8
    4a00:	4f e3       	ldi	r20, 0x3F	; 63
    4a02:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4a06:	86 e1       	ldi	r24, 0x16	; 22
    4a08:	62 e0       	ldi	r22, 0x02	; 2
    4a0a:	43 e0       	ldi	r20, 0x03	; 3
    4a0c:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>
        break;
    4a10:	21 c0       	rjmp	.+66     	; 0x4a54 <chb_set_mode+0x8a>
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    4a12:	8c e0       	ldi	r24, 0x0C	; 12
    4a14:	6c e0       	ldi	r22, 0x0C	; 12
    4a16:	4f e3       	ldi	r20, 0x3F	; 63
    4a18:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4a1c:	86 e1       	ldi	r24, 0x16	; 22
    4a1e:	62 e0       	ldi	r22, 0x02	; 2
    4a20:	43 e0       	ldi	r20, 0x03	; 3
    4a22:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>
        break;
    4a26:	16 c0       	rjmp	.+44     	; 0x4a54 <chb_set_mode+0x8a>
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    4a28:	8c e0       	ldi	r24, 0x0C	; 12
    4a2a:	6c e1       	ldi	r22, 0x1C	; 28
    4a2c:	4f e3       	ldi	r20, 0x3F	; 63
    4a2e:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    4a32:	86 e1       	ldi	r24, 0x16	; 22
    4a34:	62 e0       	ldi	r22, 0x02	; 2
    4a36:	43 e0       	ldi	r20, 0x03	; 3
    4a38:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>
        break;
    4a3c:	0b c0       	rjmp	.+22     	; 0x4a54 <chb_set_mode+0x8a>
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    4a3e:	8c e0       	ldi	r24, 0x0C	; 12
    4a40:	60 e0       	ldi	r22, 0x00	; 0
    4a42:	4f e3       	ldi	r20, 0x3F	; 63
    4a44:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    4a48:	86 e1       	ldi	r24, 0x16	; 22
    4a4a:	63 e0       	ldi	r22, 0x03	; 3
    4a4c:	43 e0       	ldi	r20, 0x03	; 3
    4a4e:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>
        break;
    4a52:	00 00       	nop
    }
}
    4a54:	0f 90       	pop	r0
    4a56:	df 91       	pop	r29
    4a58:	cf 91       	pop	r28
    4a5a:	08 95       	ret

00004a5c <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    4a5c:	0f 93       	push	r16
    4a5e:	1f 93       	push	r17
    4a60:	cf 93       	push	r28
    4a62:	df 93       	push	r29
    4a64:	cd b7       	in	r28, 0x3d	; 61
    4a66:	de b7       	in	r29, 0x3e	; 62
    4a68:	6a 97       	sbiw	r28, 0x1a	; 26
    4a6a:	cd bf       	out	0x3d, r28	; 61
    4a6c:	de bf       	out	0x3e, r29	; 62
    4a6e:	8a 8f       	std	Y+26, r24	; 0x1a
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    4a70:	88 e0       	ldi	r24, 0x08	; 8
    4a72:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4a74:	4f e1       	ldi	r20, 0x1F	; 31
    4a76:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    4a7a:	0e 94 dc 20 	call	0x41b8	; 0x41b8 <chb_get_state>
    4a7e:	89 83       	std	Y+1, r24	; 0x01
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    4a80:	89 81       	ldd	r24, Y+1	; 0x01
    4a82:	86 30       	cpi	r24, 0x06	; 6
    4a84:	21 f0       	breq	.+8      	; 0x4a8e <chb_set_channel+0x32>
    4a86:	89 81       	ldd	r24, Y+1	; 0x01
    4a88:	89 30       	cpi	r24, 0x09	; 9
    4a8a:	09 f0       	breq	.+2      	; 0x4a8e <chb_set_channel+0x32>
    4a8c:	d5 c0       	rjmp	.+426    	; 0x4c38 <chb_set_channel+0x1dc>
    4a8e:	80 e0       	ldi	r24, 0x00	; 0
    4a90:	90 e0       	ldi	r25, 0x00	; 0
    4a92:	ac ed       	ldi	r26, 0xDC	; 220
    4a94:	b2 e4       	ldi	r27, 0x42	; 66
    4a96:	8a 83       	std	Y+2, r24	; 0x02
    4a98:	9b 83       	std	Y+3, r25	; 0x03
    4a9a:	ac 83       	std	Y+4, r26	; 0x04
    4a9c:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4a9e:	6a 81       	ldd	r22, Y+2	; 0x02
    4aa0:	7b 81       	ldd	r23, Y+3	; 0x03
    4aa2:	8c 81       	ldd	r24, Y+4	; 0x04
    4aa4:	9d 81       	ldd	r25, Y+5	; 0x05
    4aa6:	2b ea       	ldi	r18, 0xAB	; 171
    4aa8:	3a ea       	ldi	r19, 0xAA	; 170
    4aaa:	4a ea       	ldi	r20, 0xAA	; 170
    4aac:	5e e3       	ldi	r21, 0x3E	; 62
    4aae:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    4ab2:	dc 01       	movw	r26, r24
    4ab4:	cb 01       	movw	r24, r22
    4ab6:	8e 83       	std	Y+6, r24	; 0x06
    4ab8:	9f 83       	std	Y+7, r25	; 0x07
    4aba:	a8 87       	std	Y+8, r26	; 0x08
    4abc:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    4abe:	11 e0       	ldi	r17, 0x01	; 1
    4ac0:	6e 81       	ldd	r22, Y+6	; 0x06
    4ac2:	7f 81       	ldd	r23, Y+7	; 0x07
    4ac4:	88 85       	ldd	r24, Y+8	; 0x08
    4ac6:	99 85       	ldd	r25, Y+9	; 0x09
    4ac8:	20 e0       	ldi	r18, 0x00	; 0
    4aca:	30 e0       	ldi	r19, 0x00	; 0
    4acc:	40 e8       	ldi	r20, 0x80	; 128
    4ace:	5f e3       	ldi	r21, 0x3F	; 63
    4ad0:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    4ad4:	88 23       	and	r24, r24
    4ad6:	0c f0       	brlt	.+2      	; 0x4ada <chb_set_channel+0x7e>
    4ad8:	10 e0       	ldi	r17, 0x00	; 0
    4ada:	11 23       	and	r17, r17
    4adc:	19 f0       	breq	.+6      	; 0x4ae4 <chb_set_channel+0x88>
		__ticks = 1;
    4ade:	81 e0       	ldi	r24, 0x01	; 1
    4ae0:	8a 87       	std	Y+10, r24	; 0x0a
    4ae2:	a3 c0       	rjmp	.+326    	; 0x4c2a <chb_set_channel+0x1ce>
	else if (__tmp > 255)
    4ae4:	11 e0       	ldi	r17, 0x01	; 1
    4ae6:	6e 81       	ldd	r22, Y+6	; 0x06
    4ae8:	7f 81       	ldd	r23, Y+7	; 0x07
    4aea:	88 85       	ldd	r24, Y+8	; 0x08
    4aec:	99 85       	ldd	r25, Y+9	; 0x09
    4aee:	20 e0       	ldi	r18, 0x00	; 0
    4af0:	30 e0       	ldi	r19, 0x00	; 0
    4af2:	4f e7       	ldi	r20, 0x7F	; 127
    4af4:	53 e4       	ldi	r21, 0x43	; 67
    4af6:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    4afa:	18 16       	cp	r1, r24
    4afc:	0c f0       	brlt	.+2      	; 0x4b00 <chb_set_channel+0xa4>
    4afe:	10 e0       	ldi	r17, 0x00	; 0
    4b00:	11 23       	and	r17, r17
    4b02:	09 f4       	brne	.+2      	; 0x4b06 <chb_set_channel+0xaa>
    4b04:	89 c0       	rjmp	.+274    	; 0x4c18 <chb_set_channel+0x1bc>
	{
		_delay_ms(__us / 1000.0);
    4b06:	6a 81       	ldd	r22, Y+2	; 0x02
    4b08:	7b 81       	ldd	r23, Y+3	; 0x03
    4b0a:	8c 81       	ldd	r24, Y+4	; 0x04
    4b0c:	9d 81       	ldd	r25, Y+5	; 0x05
    4b0e:	20 e0       	ldi	r18, 0x00	; 0
    4b10:	30 e0       	ldi	r19, 0x00	; 0
    4b12:	4a e7       	ldi	r20, 0x7A	; 122
    4b14:	54 e4       	ldi	r21, 0x44	; 68
    4b16:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
    4b1a:	dc 01       	movw	r26, r24
    4b1c:	cb 01       	movw	r24, r22
    4b1e:	8b 87       	std	Y+11, r24	; 0x0b
    4b20:	9c 87       	std	Y+12, r25	; 0x0c
    4b22:	ad 87       	std	Y+13, r26	; 0x0d
    4b24:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4b26:	6b 85       	ldd	r22, Y+11	; 0x0b
    4b28:	7c 85       	ldd	r23, Y+12	; 0x0c
    4b2a:	8d 85       	ldd	r24, Y+13	; 0x0d
    4b2c:	9e 85       	ldd	r25, Y+14	; 0x0e
    4b2e:	20 e0       	ldi	r18, 0x00	; 0
    4b30:	30 e0       	ldi	r19, 0x00	; 0
    4b32:	4a e7       	ldi	r20, 0x7A	; 122
    4b34:	53 e4       	ldi	r21, 0x43	; 67
    4b36:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    4b3a:	dc 01       	movw	r26, r24
    4b3c:	cb 01       	movw	r24, r22
    4b3e:	8f 87       	std	Y+15, r24	; 0x0f
    4b40:	98 8b       	std	Y+16, r25	; 0x10
    4b42:	a9 8b       	std	Y+17, r26	; 0x11
    4b44:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    4b46:	11 e0       	ldi	r17, 0x01	; 1
    4b48:	6f 85       	ldd	r22, Y+15	; 0x0f
    4b4a:	78 89       	ldd	r23, Y+16	; 0x10
    4b4c:	89 89       	ldd	r24, Y+17	; 0x11
    4b4e:	9a 89       	ldd	r25, Y+18	; 0x12
    4b50:	20 e0       	ldi	r18, 0x00	; 0
    4b52:	30 e0       	ldi	r19, 0x00	; 0
    4b54:	40 e8       	ldi	r20, 0x80	; 128
    4b56:	5f e3       	ldi	r21, 0x3F	; 63
    4b58:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    4b5c:	88 23       	and	r24, r24
    4b5e:	0c f0       	brlt	.+2      	; 0x4b62 <chb_set_channel+0x106>
    4b60:	10 e0       	ldi	r17, 0x00	; 0
    4b62:	11 23       	and	r17, r17
    4b64:	29 f0       	breq	.+10     	; 0x4b70 <chb_set_channel+0x114>
		__ticks = 1;
    4b66:	81 e0       	ldi	r24, 0x01	; 1
    4b68:	90 e0       	ldi	r25, 0x00	; 0
    4b6a:	8b 8b       	std	Y+19, r24	; 0x13
    4b6c:	9c 8b       	std	Y+20, r25	; 0x14
    4b6e:	46 c0       	rjmp	.+140    	; 0x4bfc <chb_set_channel+0x1a0>
	else if (__tmp > 65535)
    4b70:	11 e0       	ldi	r17, 0x01	; 1
    4b72:	6f 85       	ldd	r22, Y+15	; 0x0f
    4b74:	78 89       	ldd	r23, Y+16	; 0x10
    4b76:	89 89       	ldd	r24, Y+17	; 0x11
    4b78:	9a 89       	ldd	r25, Y+18	; 0x12
    4b7a:	20 e0       	ldi	r18, 0x00	; 0
    4b7c:	3f ef       	ldi	r19, 0xFF	; 255
    4b7e:	4f e7       	ldi	r20, 0x7F	; 127
    4b80:	57 e4       	ldi	r21, 0x47	; 71
    4b82:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    4b86:	18 16       	cp	r1, r24
    4b88:	0c f0       	brlt	.+2      	; 0x4b8c <chb_set_channel+0x130>
    4b8a:	10 e0       	ldi	r17, 0x00	; 0
    4b8c:	11 23       	and	r17, r17
    4b8e:	61 f1       	breq	.+88     	; 0x4be8 <chb_set_channel+0x18c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4b90:	6b 85       	ldd	r22, Y+11	; 0x0b
    4b92:	7c 85       	ldd	r23, Y+12	; 0x0c
    4b94:	8d 85       	ldd	r24, Y+13	; 0x0d
    4b96:	9e 85       	ldd	r25, Y+14	; 0x0e
    4b98:	20 e0       	ldi	r18, 0x00	; 0
    4b9a:	30 e0       	ldi	r19, 0x00	; 0
    4b9c:	40 e2       	ldi	r20, 0x20	; 32
    4b9e:	51 e4       	ldi	r21, 0x41	; 65
    4ba0:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    4ba4:	dc 01       	movw	r26, r24
    4ba6:	cb 01       	movw	r24, r22
    4ba8:	bc 01       	movw	r22, r24
    4baa:	cd 01       	movw	r24, r26
    4bac:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    4bb0:	dc 01       	movw	r26, r24
    4bb2:	cb 01       	movw	r24, r22
    4bb4:	8b 8b       	std	Y+19, r24	; 0x13
    4bb6:	9c 8b       	std	Y+20, r25	; 0x14
    4bb8:	12 c0       	rjmp	.+36     	; 0x4bde <chb_set_channel+0x182>
    4bba:	89 e1       	ldi	r24, 0x19	; 25
    4bbc:	90 e0       	ldi	r25, 0x00	; 0
    4bbe:	8d 8b       	std	Y+21, r24	; 0x15
    4bc0:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4bc2:	8d 89       	ldd	r24, Y+21	; 0x15
    4bc4:	9e 89       	ldd	r25, Y+22	; 0x16
    4bc6:	8c 01       	movw	r16, r24
    4bc8:	c8 01       	movw	r24, r16
    4bca:	01 97       	sbiw	r24, 0x01	; 1
    4bcc:	f1 f7       	brne	.-4      	; 0x4bca <chb_set_channel+0x16e>
    4bce:	8c 01       	movw	r16, r24
    4bd0:	0d 8b       	std	Y+21, r16	; 0x15
    4bd2:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4bd4:	8b 89       	ldd	r24, Y+19	; 0x13
    4bd6:	9c 89       	ldd	r25, Y+20	; 0x14
    4bd8:	01 97       	sbiw	r24, 0x01	; 1
    4bda:	8b 8b       	std	Y+19, r24	; 0x13
    4bdc:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4bde:	8b 89       	ldd	r24, Y+19	; 0x13
    4be0:	9c 89       	ldd	r25, Y+20	; 0x14
    4be2:	00 97       	sbiw	r24, 0x00	; 0
    4be4:	51 f7       	brne	.-44     	; 0x4bba <chb_set_channel+0x15e>
    4be6:	28 c0       	rjmp	.+80     	; 0x4c38 <chb_set_channel+0x1dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4be8:	6f 85       	ldd	r22, Y+15	; 0x0f
    4bea:	78 89       	ldd	r23, Y+16	; 0x10
    4bec:	89 89       	ldd	r24, Y+17	; 0x11
    4bee:	9a 89       	ldd	r25, Y+18	; 0x12
    4bf0:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    4bf4:	dc 01       	movw	r26, r24
    4bf6:	cb 01       	movw	r24, r22
    4bf8:	8b 8b       	std	Y+19, r24	; 0x13
    4bfa:	9c 8b       	std	Y+20, r25	; 0x14
    4bfc:	8b 89       	ldd	r24, Y+19	; 0x13
    4bfe:	9c 89       	ldd	r25, Y+20	; 0x14
    4c00:	8f 8b       	std	Y+23, r24	; 0x17
    4c02:	98 8f       	std	Y+24, r25	; 0x18
    4c04:	8f 89       	ldd	r24, Y+23	; 0x17
    4c06:	98 8d       	ldd	r25, Y+24	; 0x18
    4c08:	8c 01       	movw	r16, r24
    4c0a:	c8 01       	movw	r24, r16
    4c0c:	01 97       	sbiw	r24, 0x01	; 1
    4c0e:	f1 f7       	brne	.-4      	; 0x4c0c <chb_set_channel+0x1b0>
    4c10:	8c 01       	movw	r16, r24
    4c12:	0f 8b       	std	Y+23, r16	; 0x17
    4c14:	18 8f       	std	Y+24, r17	; 0x18
    4c16:	10 c0       	rjmp	.+32     	; 0x4c38 <chb_set_channel+0x1dc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4c18:	6e 81       	ldd	r22, Y+6	; 0x06
    4c1a:	7f 81       	ldd	r23, Y+7	; 0x07
    4c1c:	88 85       	ldd	r24, Y+8	; 0x08
    4c1e:	99 85       	ldd	r25, Y+9	; 0x09
    4c20:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    4c24:	dc 01       	movw	r26, r24
    4c26:	cb 01       	movw	r24, r22
    4c28:	8a 87       	std	Y+10, r24	; 0x0a
    4c2a:	8a 85       	ldd	r24, Y+10	; 0x0a
    4c2c:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4c2e:	89 8d       	ldd	r24, Y+25	; 0x19
    4c30:	18 2f       	mov	r17, r24
    4c32:	1a 95       	dec	r17
    4c34:	f1 f7       	brne	.-4      	; 0x4c32 <chb_set_channel+0x1d6>
    4c36:	19 8f       	std	Y+25, r17	; 0x19
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    4c38:	88 e0       	ldi	r24, 0x08	; 8
    4c3a:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <chb_reg_read>
    4c3e:	88 2f       	mov	r24, r24
    4c40:	90 e0       	ldi	r25, 0x00	; 0
    4c42:	9c 01       	movw	r18, r24
    4c44:	2f 71       	andi	r18, 0x1F	; 31
    4c46:	30 70       	andi	r19, 0x00	; 0
    4c48:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4c4a:	88 2f       	mov	r24, r24
    4c4c:	90 e0       	ldi	r25, 0x00	; 0
    4c4e:	28 17       	cp	r18, r24
    4c50:	39 07       	cpc	r19, r25
    4c52:	11 f4       	brne	.+4      	; 0x4c58 <chb_set_channel+0x1fc>
    4c54:	80 e4       	ldi	r24, 0x40	; 64
    4c56:	01 c0       	rjmp	.+2      	; 0x4c5a <chb_set_channel+0x1fe>
    4c58:	83 e4       	ldi	r24, 0x43	; 67
}
    4c5a:	6a 96       	adiw	r28, 0x1a	; 26
    4c5c:	cd bf       	out	0x3d, r28	; 61
    4c5e:	de bf       	out	0x3e, r29	; 62
    4c60:	df 91       	pop	r29
    4c62:	cf 91       	pop	r28
    4c64:	1f 91       	pop	r17
    4c66:	0f 91       	pop	r16
    4c68:	08 95       	ret

00004c6a <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    4c6a:	cf 93       	push	r28
    4c6c:	df 93       	push	r29
    4c6e:	0f 92       	push	r0
    4c70:	cd b7       	in	r28, 0x3d	; 61
    4c72:	de b7       	in	r29, 0x3e	; 62
    4c74:	89 83       	std	Y+1, r24	; 0x01
    chb_reg_write(PHY_TX_PWR, val);
    4c76:	85 e0       	ldi	r24, 0x05	; 5
    4c78:	69 81       	ldd	r22, Y+1	; 0x01
    4c7a:	0e 94 40 23 	call	0x4680	; 0x4680 <chb_reg_write>
}
    4c7e:	0f 90       	pop	r0
    4c80:	df 91       	pop	r29
    4c82:	cf 91       	pop	r28
    4c84:	08 95       	ret

00004c86 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    4c86:	0f 93       	push	r16
    4c88:	1f 93       	push	r17
    4c8a:	cf 93       	push	r28
    4c8c:	df 93       	push	r29
    4c8e:	cd b7       	in	r28, 0x3d	; 61
    4c90:	de b7       	in	r29, 0x3e	; 62
    4c92:	c2 56       	subi	r28, 0x62	; 98
    4c94:	d0 40       	sbci	r29, 0x00	; 0
    4c96:	cd bf       	out	0x3d, r28	; 61
    4c98:	de bf       	out	0x3e, r29	; 62
    4c9a:	9e 01       	movw	r18, r28
    4c9c:	2e 59       	subi	r18, 0x9E	; 158
    4c9e:	3f 4f       	sbci	r19, 0xFF	; 255
    4ca0:	f9 01       	movw	r30, r18
    4ca2:	80 83       	st	Z, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    4ca4:	84 e6       	ldi	r24, 0x64	; 100
    4ca6:	96 e0       	ldi	r25, 0x06	; 6
    4ca8:	fc 01       	movw	r30, r24
    4caa:	80 81       	ld	r24, Z
    4cac:	88 2f       	mov	r24, r24
    4cae:	90 e0       	ldi	r25, 0x00	; 0
    4cb0:	82 70       	andi	r24, 0x02	; 2
    4cb2:	90 70       	andi	r25, 0x00	; 0
    4cb4:	00 97       	sbiw	r24, 0x00	; 0
    4cb6:	11 f0       	breq	.+4      	; 0x4cbc <chb_set_state+0x36>
    {
        return RADIO_WRONG_STATE;
    4cb8:	84 e4       	ldi	r24, 0x44	; 68
    4cba:	91 c4       	rjmp	.+2338   	; 0x55de <chb_set_state+0x958>
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    4cbc:	0e 94 dc 20 	call	0x41b8	; 0x41b8 <chb_get_state>
    4cc0:	89 83       	std	Y+1, r24	; 0x01
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    4cc2:	89 81       	ldd	r24, Y+1	; 0x01
    4cc4:	82 31       	cpi	r24, 0x12	; 18
    4cc6:	49 f0       	breq	.+18     	; 0x4cda <chb_set_state+0x54>
    4cc8:	89 81       	ldd	r24, Y+1	; 0x01
    4cca:	81 31       	cpi	r24, 0x11	; 17
    4ccc:	31 f0       	breq	.+12     	; 0x4cda <chb_set_state+0x54>
    4cce:	89 81       	ldd	r24, Y+1	; 0x01
    4cd0:	81 30       	cpi	r24, 0x01	; 1
    4cd2:	19 f0       	breq	.+6      	; 0x4cda <chb_set_state+0x54>
    4cd4:	89 81       	ldd	r24, Y+1	; 0x01
    4cd6:	82 30       	cpi	r24, 0x02	; 2
    4cd8:	39 f4       	brne	.+14     	; 0x4ce8 <chb_set_state+0x62>
    {
        while (chb_get_state() == curr_state);
    4cda:	00 00       	nop
    4cdc:	0e 94 dc 20 	call	0x41b8	; 0x41b8 <chb_get_state>
    4ce0:	98 2f       	mov	r25, r24
    4ce2:	89 81       	ldd	r24, Y+1	; 0x01
    4ce4:	98 17       	cp	r25, r24
    4ce6:	d1 f3       	breq	.-12     	; 0x4cdc <chb_set_state+0x56>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    4ce8:	ce 01       	movw	r24, r28
    4cea:	8e 59       	subi	r24, 0x9E	; 158
    4cec:	9f 4f       	sbci	r25, 0xFF	; 255
    4cee:	fc 01       	movw	r30, r24
    4cf0:	80 81       	ld	r24, Z
    4cf2:	88 2f       	mov	r24, r24
    4cf4:	90 e0       	ldi	r25, 0x00	; 0
    4cf6:	86 31       	cpi	r24, 0x16	; 22
    4cf8:	91 05       	cpc	r25, r1
    4cfa:	09 f4       	brne	.+2      	; 0x4cfe <chb_set_state+0x78>
    4cfc:	cd c1       	rjmp	.+922    	; 0x5098 <chb_set_state+0x412>
    4cfe:	89 31       	cpi	r24, 0x19	; 25
    4d00:	91 05       	cpc	r25, r1
    4d02:	09 f4       	brne	.+2      	; 0x4d06 <chb_set_state+0x80>
    4d04:	e9 c0       	rjmp	.+466    	; 0x4ed8 <chb_set_state+0x252>
    4d06:	88 30       	cpi	r24, 0x08	; 8
    4d08:	91 05       	cpc	r25, r1
    4d0a:	09 f0       	breq	.+2      	; 0x4d0e <chb_set_state+0x88>
    4d0c:	f7 c2       	rjmp	.+1518   	; 0x52fc <chb_set_state+0x676>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    4d0e:	84 e6       	ldi	r24, 0x64	; 100
    4d10:	96 e0       	ldi	r25, 0x06	; 6
    4d12:	24 e6       	ldi	r18, 0x64	; 100
    4d14:	36 e0       	ldi	r19, 0x06	; 6
    4d16:	f9 01       	movw	r30, r18
    4d18:	20 81       	ld	r18, Z
    4d1a:	2d 7f       	andi	r18, 0xFD	; 253
    4d1c:	fc 01       	movw	r30, r24
    4d1e:	20 83       	st	Z, r18
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    4d20:	82 e0       	ldi	r24, 0x02	; 2
    4d22:	63 e0       	ldi	r22, 0x03	; 3
    4d24:	4f e1       	ldi	r20, 0x1F	; 31
    4d26:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>
    4d2a:	80 e0       	ldi	r24, 0x00	; 0
    4d2c:	90 e0       	ldi	r25, 0x00	; 0
    4d2e:	a0 e8       	ldi	r26, 0x80	; 128
    4d30:	bf e3       	ldi	r27, 0x3F	; 63
    4d32:	8a 83       	std	Y+2, r24	; 0x02
    4d34:	9b 83       	std	Y+3, r25	; 0x03
    4d36:	ac 83       	std	Y+4, r26	; 0x04
    4d38:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4d3a:	6a 81       	ldd	r22, Y+2	; 0x02
    4d3c:	7b 81       	ldd	r23, Y+3	; 0x03
    4d3e:	8c 81       	ldd	r24, Y+4	; 0x04
    4d40:	9d 81       	ldd	r25, Y+5	; 0x05
    4d42:	2b ea       	ldi	r18, 0xAB	; 171
    4d44:	3a ea       	ldi	r19, 0xAA	; 170
    4d46:	4a ea       	ldi	r20, 0xAA	; 170
    4d48:	5e e3       	ldi	r21, 0x3E	; 62
    4d4a:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    4d4e:	dc 01       	movw	r26, r24
    4d50:	cb 01       	movw	r24, r22
    4d52:	8e 83       	std	Y+6, r24	; 0x06
    4d54:	9f 83       	std	Y+7, r25	; 0x07
    4d56:	a8 87       	std	Y+8, r26	; 0x08
    4d58:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    4d5a:	11 e0       	ldi	r17, 0x01	; 1
    4d5c:	6e 81       	ldd	r22, Y+6	; 0x06
    4d5e:	7f 81       	ldd	r23, Y+7	; 0x07
    4d60:	88 85       	ldd	r24, Y+8	; 0x08
    4d62:	99 85       	ldd	r25, Y+9	; 0x09
    4d64:	20 e0       	ldi	r18, 0x00	; 0
    4d66:	30 e0       	ldi	r19, 0x00	; 0
    4d68:	40 e8       	ldi	r20, 0x80	; 128
    4d6a:	5f e3       	ldi	r21, 0x3F	; 63
    4d6c:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    4d70:	88 23       	and	r24, r24
    4d72:	0c f0       	brlt	.+2      	; 0x4d76 <chb_set_state+0xf0>
    4d74:	10 e0       	ldi	r17, 0x00	; 0
    4d76:	11 23       	and	r17, r17
    4d78:	19 f0       	breq	.+6      	; 0x4d80 <chb_set_state+0xfa>
		__ticks = 1;
    4d7a:	81 e0       	ldi	r24, 0x01	; 1
    4d7c:	8a 87       	std	Y+10, r24	; 0x0a
    4d7e:	a3 c0       	rjmp	.+326    	; 0x4ec6 <chb_set_state+0x240>
	else if (__tmp > 255)
    4d80:	11 e0       	ldi	r17, 0x01	; 1
    4d82:	6e 81       	ldd	r22, Y+6	; 0x06
    4d84:	7f 81       	ldd	r23, Y+7	; 0x07
    4d86:	88 85       	ldd	r24, Y+8	; 0x08
    4d88:	99 85       	ldd	r25, Y+9	; 0x09
    4d8a:	20 e0       	ldi	r18, 0x00	; 0
    4d8c:	30 e0       	ldi	r19, 0x00	; 0
    4d8e:	4f e7       	ldi	r20, 0x7F	; 127
    4d90:	53 e4       	ldi	r21, 0x43	; 67
    4d92:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    4d96:	18 16       	cp	r1, r24
    4d98:	0c f0       	brlt	.+2      	; 0x4d9c <chb_set_state+0x116>
    4d9a:	10 e0       	ldi	r17, 0x00	; 0
    4d9c:	11 23       	and	r17, r17
    4d9e:	09 f4       	brne	.+2      	; 0x4da2 <chb_set_state+0x11c>
    4da0:	89 c0       	rjmp	.+274    	; 0x4eb4 <chb_set_state+0x22e>
	{
		_delay_ms(__us / 1000.0);
    4da2:	6a 81       	ldd	r22, Y+2	; 0x02
    4da4:	7b 81       	ldd	r23, Y+3	; 0x03
    4da6:	8c 81       	ldd	r24, Y+4	; 0x04
    4da8:	9d 81       	ldd	r25, Y+5	; 0x05
    4daa:	20 e0       	ldi	r18, 0x00	; 0
    4dac:	30 e0       	ldi	r19, 0x00	; 0
    4dae:	4a e7       	ldi	r20, 0x7A	; 122
    4db0:	54 e4       	ldi	r21, 0x44	; 68
    4db2:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
    4db6:	dc 01       	movw	r26, r24
    4db8:	cb 01       	movw	r24, r22
    4dba:	8b 87       	std	Y+11, r24	; 0x0b
    4dbc:	9c 87       	std	Y+12, r25	; 0x0c
    4dbe:	ad 87       	std	Y+13, r26	; 0x0d
    4dc0:	be 87       	std	Y+14, r27	; 0x0e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4dc2:	6b 85       	ldd	r22, Y+11	; 0x0b
    4dc4:	7c 85       	ldd	r23, Y+12	; 0x0c
    4dc6:	8d 85       	ldd	r24, Y+13	; 0x0d
    4dc8:	9e 85       	ldd	r25, Y+14	; 0x0e
    4dca:	20 e0       	ldi	r18, 0x00	; 0
    4dcc:	30 e0       	ldi	r19, 0x00	; 0
    4dce:	4a e7       	ldi	r20, 0x7A	; 122
    4dd0:	53 e4       	ldi	r21, 0x43	; 67
    4dd2:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    4dd6:	dc 01       	movw	r26, r24
    4dd8:	cb 01       	movw	r24, r22
    4dda:	8f 87       	std	Y+15, r24	; 0x0f
    4ddc:	98 8b       	std	Y+16, r25	; 0x10
    4dde:	a9 8b       	std	Y+17, r26	; 0x11
    4de0:	ba 8b       	std	Y+18, r27	; 0x12
	if (__tmp < 1.0)
    4de2:	11 e0       	ldi	r17, 0x01	; 1
    4de4:	6f 85       	ldd	r22, Y+15	; 0x0f
    4de6:	78 89       	ldd	r23, Y+16	; 0x10
    4de8:	89 89       	ldd	r24, Y+17	; 0x11
    4dea:	9a 89       	ldd	r25, Y+18	; 0x12
    4dec:	20 e0       	ldi	r18, 0x00	; 0
    4dee:	30 e0       	ldi	r19, 0x00	; 0
    4df0:	40 e8       	ldi	r20, 0x80	; 128
    4df2:	5f e3       	ldi	r21, 0x3F	; 63
    4df4:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    4df8:	88 23       	and	r24, r24
    4dfa:	0c f0       	brlt	.+2      	; 0x4dfe <chb_set_state+0x178>
    4dfc:	10 e0       	ldi	r17, 0x00	; 0
    4dfe:	11 23       	and	r17, r17
    4e00:	29 f0       	breq	.+10     	; 0x4e0c <chb_set_state+0x186>
		__ticks = 1;
    4e02:	81 e0       	ldi	r24, 0x01	; 1
    4e04:	90 e0       	ldi	r25, 0x00	; 0
    4e06:	8b 8b       	std	Y+19, r24	; 0x13
    4e08:	9c 8b       	std	Y+20, r25	; 0x14
    4e0a:	46 c0       	rjmp	.+140    	; 0x4e98 <chb_set_state+0x212>
	else if (__tmp > 65535)
    4e0c:	11 e0       	ldi	r17, 0x01	; 1
    4e0e:	6f 85       	ldd	r22, Y+15	; 0x0f
    4e10:	78 89       	ldd	r23, Y+16	; 0x10
    4e12:	89 89       	ldd	r24, Y+17	; 0x11
    4e14:	9a 89       	ldd	r25, Y+18	; 0x12
    4e16:	20 e0       	ldi	r18, 0x00	; 0
    4e18:	3f ef       	ldi	r19, 0xFF	; 255
    4e1a:	4f e7       	ldi	r20, 0x7F	; 127
    4e1c:	57 e4       	ldi	r21, 0x47	; 71
    4e1e:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    4e22:	18 16       	cp	r1, r24
    4e24:	0c f0       	brlt	.+2      	; 0x4e28 <chb_set_state+0x1a2>
    4e26:	10 e0       	ldi	r17, 0x00	; 0
    4e28:	11 23       	and	r17, r17
    4e2a:	61 f1       	breq	.+88     	; 0x4e84 <chb_set_state+0x1fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4e2c:	6b 85       	ldd	r22, Y+11	; 0x0b
    4e2e:	7c 85       	ldd	r23, Y+12	; 0x0c
    4e30:	8d 85       	ldd	r24, Y+13	; 0x0d
    4e32:	9e 85       	ldd	r25, Y+14	; 0x0e
    4e34:	20 e0       	ldi	r18, 0x00	; 0
    4e36:	30 e0       	ldi	r19, 0x00	; 0
    4e38:	40 e2       	ldi	r20, 0x20	; 32
    4e3a:	51 e4       	ldi	r21, 0x41	; 65
    4e3c:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    4e40:	dc 01       	movw	r26, r24
    4e42:	cb 01       	movw	r24, r22
    4e44:	bc 01       	movw	r22, r24
    4e46:	cd 01       	movw	r24, r26
    4e48:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    4e4c:	dc 01       	movw	r26, r24
    4e4e:	cb 01       	movw	r24, r22
    4e50:	8b 8b       	std	Y+19, r24	; 0x13
    4e52:	9c 8b       	std	Y+20, r25	; 0x14
    4e54:	12 c0       	rjmp	.+36     	; 0x4e7a <chb_set_state+0x1f4>
    4e56:	89 e1       	ldi	r24, 0x19	; 25
    4e58:	90 e0       	ldi	r25, 0x00	; 0
    4e5a:	8d 8b       	std	Y+21, r24	; 0x15
    4e5c:	9e 8b       	std	Y+22, r25	; 0x16
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4e5e:	8d 89       	ldd	r24, Y+21	; 0x15
    4e60:	9e 89       	ldd	r25, Y+22	; 0x16
    4e62:	8c 01       	movw	r16, r24
    4e64:	c8 01       	movw	r24, r16
    4e66:	01 97       	sbiw	r24, 0x01	; 1
    4e68:	f1 f7       	brne	.-4      	; 0x4e66 <chb_set_state+0x1e0>
    4e6a:	8c 01       	movw	r16, r24
    4e6c:	0d 8b       	std	Y+21, r16	; 0x15
    4e6e:	1e 8b       	std	Y+22, r17	; 0x16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4e70:	8b 89       	ldd	r24, Y+19	; 0x13
    4e72:	9c 89       	ldd	r25, Y+20	; 0x14
    4e74:	01 97       	sbiw	r24, 0x01	; 1
    4e76:	8b 8b       	std	Y+19, r24	; 0x13
    4e78:	9c 8b       	std	Y+20, r25	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4e7a:	8b 89       	ldd	r24, Y+19	; 0x13
    4e7c:	9c 89       	ldd	r25, Y+20	; 0x14
    4e7e:	00 97       	sbiw	r24, 0x00	; 0
    4e80:	51 f7       	brne	.-44     	; 0x4e56 <chb_set_state+0x1d0>
    4e82:	29 c0       	rjmp	.+82     	; 0x4ed6 <chb_set_state+0x250>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4e84:	6f 85       	ldd	r22, Y+15	; 0x0f
    4e86:	78 89       	ldd	r23, Y+16	; 0x10
    4e88:	89 89       	ldd	r24, Y+17	; 0x11
    4e8a:	9a 89       	ldd	r25, Y+18	; 0x12
    4e8c:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    4e90:	dc 01       	movw	r26, r24
    4e92:	cb 01       	movw	r24, r22
    4e94:	8b 8b       	std	Y+19, r24	; 0x13
    4e96:	9c 8b       	std	Y+20, r25	; 0x14
    4e98:	8b 89       	ldd	r24, Y+19	; 0x13
    4e9a:	9c 89       	ldd	r25, Y+20	; 0x14
    4e9c:	8f 8b       	std	Y+23, r24	; 0x17
    4e9e:	98 8f       	std	Y+24, r25	; 0x18
    4ea0:	8f 89       	ldd	r24, Y+23	; 0x17
    4ea2:	98 8d       	ldd	r25, Y+24	; 0x18
    4ea4:	8c 01       	movw	r16, r24
    4ea6:	f8 01       	movw	r30, r16
    4ea8:	31 97       	sbiw	r30, 0x01	; 1
    4eaa:	f1 f7       	brne	.-4      	; 0x4ea8 <chb_set_state+0x222>
    4eac:	8f 01       	movw	r16, r30
    4eae:	0f 8b       	std	Y+23, r16	; 0x17
    4eb0:	18 8f       	std	Y+24, r17	; 0x18
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;
    4eb2:	24 c2       	rjmp	.+1096   	; 0x52fc <chb_set_state+0x676>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4eb4:	6e 81       	ldd	r22, Y+6	; 0x06
    4eb6:	7f 81       	ldd	r23, Y+7	; 0x07
    4eb8:	88 85       	ldd	r24, Y+8	; 0x08
    4eba:	99 85       	ldd	r25, Y+9	; 0x09
    4ebc:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    4ec0:	dc 01       	movw	r26, r24
    4ec2:	cb 01       	movw	r24, r22
    4ec4:	8a 87       	std	Y+10, r24	; 0x0a
    4ec6:	8a 85       	ldd	r24, Y+10	; 0x0a
    4ec8:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4eca:	89 8d       	ldd	r24, Y+25	; 0x19
    4ecc:	18 2f       	mov	r17, r24
    4ece:	1a 95       	dec	r17
    4ed0:	f1 f7       	brne	.-4      	; 0x4ece <chb_set_state+0x248>
    4ed2:	19 8f       	std	Y+25, r17	; 0x19
    4ed4:	13 c2       	rjmp	.+1062   	; 0x52fc <chb_set_state+0x676>
    4ed6:	12 c2       	rjmp	.+1060   	; 0x52fc <chb_set_state+0x676>

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    4ed8:	89 81       	ldd	r24, Y+1	; 0x01
    4eda:	86 31       	cpi	r24, 0x16	; 22
    4edc:	09 f0       	breq	.+2      	; 0x4ee0 <chb_set_state+0x25a>
    4ede:	0b c2       	rjmp	.+1046   	; 0x52f6 <chb_set_state+0x670>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    4ee0:	82 e0       	ldi	r24, 0x02	; 2
    4ee2:	69 e0       	ldi	r22, 0x09	; 9
    4ee4:	4f e1       	ldi	r20, 0x1F	; 31
    4ee6:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>
    4eea:	80 e0       	ldi	r24, 0x00	; 0
    4eec:	90 e0       	ldi	r25, 0x00	; 0
    4eee:	a0 e8       	ldi	r26, 0x80	; 128
    4ef0:	bf e3       	ldi	r27, 0x3F	; 63
    4ef2:	8a 8f       	std	Y+26, r24	; 0x1a
    4ef4:	9b 8f       	std	Y+27, r25	; 0x1b
    4ef6:	ac 8f       	std	Y+28, r26	; 0x1c
    4ef8:	bd 8f       	std	Y+29, r27	; 0x1d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    4efa:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4efc:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4efe:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4f00:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4f02:	2b ea       	ldi	r18, 0xAB	; 171
    4f04:	3a ea       	ldi	r19, 0xAA	; 170
    4f06:	4a ea       	ldi	r20, 0xAA	; 170
    4f08:	5e e3       	ldi	r21, 0x3E	; 62
    4f0a:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    4f0e:	dc 01       	movw	r26, r24
    4f10:	cb 01       	movw	r24, r22
    4f12:	8e 8f       	std	Y+30, r24	; 0x1e
    4f14:	9f 8f       	std	Y+31, r25	; 0x1f
    4f16:	a8 a3       	lds	r26, 0x58
    4f18:	b9 a3       	lds	r27, 0x59
	if (__tmp < 1.0)
    4f1a:	11 e0       	ldi	r17, 0x01	; 1
    4f1c:	6e 8d       	ldd	r22, Y+30	; 0x1e
    4f1e:	7f 8d       	ldd	r23, Y+31	; 0x1f
    4f20:	88 a1       	lds	r24, 0x48
    4f22:	99 a1       	lds	r25, 0x49
    4f24:	20 e0       	ldi	r18, 0x00	; 0
    4f26:	30 e0       	ldi	r19, 0x00	; 0
    4f28:	40 e8       	ldi	r20, 0x80	; 128
    4f2a:	5f e3       	ldi	r21, 0x3F	; 63
    4f2c:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    4f30:	88 23       	and	r24, r24
    4f32:	0c f0       	brlt	.+2      	; 0x4f36 <chb_set_state+0x2b0>
    4f34:	10 e0       	ldi	r17, 0x00	; 0
    4f36:	11 23       	and	r17, r17
    4f38:	19 f0       	breq	.+6      	; 0x4f40 <chb_set_state+0x2ba>
		__ticks = 1;
    4f3a:	81 e0       	ldi	r24, 0x01	; 1
    4f3c:	8a a3       	lds	r24, 0x5a
    4f3e:	a3 c0       	rjmp	.+326    	; 0x5086 <chb_set_state+0x400>
	else if (__tmp > 255)
    4f40:	11 e0       	ldi	r17, 0x01	; 1
    4f42:	6e 8d       	ldd	r22, Y+30	; 0x1e
    4f44:	7f 8d       	ldd	r23, Y+31	; 0x1f
    4f46:	88 a1       	lds	r24, 0x48
    4f48:	99 a1       	lds	r25, 0x49
    4f4a:	20 e0       	ldi	r18, 0x00	; 0
    4f4c:	30 e0       	ldi	r19, 0x00	; 0
    4f4e:	4f e7       	ldi	r20, 0x7F	; 127
    4f50:	53 e4       	ldi	r21, 0x43	; 67
    4f52:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    4f56:	18 16       	cp	r1, r24
    4f58:	0c f0       	brlt	.+2      	; 0x4f5c <chb_set_state+0x2d6>
    4f5a:	10 e0       	ldi	r17, 0x00	; 0
    4f5c:	11 23       	and	r17, r17
    4f5e:	09 f4       	brne	.+2      	; 0x4f62 <chb_set_state+0x2dc>
    4f60:	89 c0       	rjmp	.+274    	; 0x5074 <chb_set_state+0x3ee>
	{
		_delay_ms(__us / 1000.0);
    4f62:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4f64:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4f66:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4f68:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4f6a:	20 e0       	ldi	r18, 0x00	; 0
    4f6c:	30 e0       	ldi	r19, 0x00	; 0
    4f6e:	4a e7       	ldi	r20, 0x7A	; 122
    4f70:	54 e4       	ldi	r21, 0x44	; 68
    4f72:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
    4f76:	dc 01       	movw	r26, r24
    4f78:	cb 01       	movw	r24, r22
    4f7a:	8b a3       	lds	r24, 0x5b
    4f7c:	9c a3       	lds	r25, 0x5c
    4f7e:	ad a3       	lds	r26, 0x5d
    4f80:	be a3       	lds	r27, 0x5e
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    4f82:	6b a1       	lds	r22, 0x4b
    4f84:	7c a1       	lds	r23, 0x4c
    4f86:	8d a1       	lds	r24, 0x4d
    4f88:	9e a1       	lds	r25, 0x4e
    4f8a:	20 e0       	ldi	r18, 0x00	; 0
    4f8c:	30 e0       	ldi	r19, 0x00	; 0
    4f8e:	4a e7       	ldi	r20, 0x7A	; 122
    4f90:	53 e4       	ldi	r21, 0x43	; 67
    4f92:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    4f96:	dc 01       	movw	r26, r24
    4f98:	cb 01       	movw	r24, r22
    4f9a:	8f a3       	lds	r24, 0x5f
    4f9c:	98 a7       	lds	r25, 0x78
    4f9e:	a9 a7       	lds	r26, 0x79
    4fa0:	ba a7       	lds	r27, 0x7a
	if (__tmp < 1.0)
    4fa2:	11 e0       	ldi	r17, 0x01	; 1
    4fa4:	6f a1       	lds	r22, 0x4f
    4fa6:	78 a5       	lds	r23, 0x68
    4fa8:	89 a5       	lds	r24, 0x69
    4faa:	9a a5       	lds	r25, 0x6a
    4fac:	20 e0       	ldi	r18, 0x00	; 0
    4fae:	30 e0       	ldi	r19, 0x00	; 0
    4fb0:	40 e8       	ldi	r20, 0x80	; 128
    4fb2:	5f e3       	ldi	r21, 0x3F	; 63
    4fb4:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    4fb8:	88 23       	and	r24, r24
    4fba:	0c f0       	brlt	.+2      	; 0x4fbe <chb_set_state+0x338>
    4fbc:	10 e0       	ldi	r17, 0x00	; 0
    4fbe:	11 23       	and	r17, r17
    4fc0:	29 f0       	breq	.+10     	; 0x4fcc <chb_set_state+0x346>
		__ticks = 1;
    4fc2:	81 e0       	ldi	r24, 0x01	; 1
    4fc4:	90 e0       	ldi	r25, 0x00	; 0
    4fc6:	8b a7       	lds	r24, 0x7b
    4fc8:	9c a7       	lds	r25, 0x7c
    4fca:	46 c0       	rjmp	.+140    	; 0x5058 <chb_set_state+0x3d2>
	else if (__tmp > 65535)
    4fcc:	11 e0       	ldi	r17, 0x01	; 1
    4fce:	6f a1       	lds	r22, 0x4f
    4fd0:	78 a5       	lds	r23, 0x68
    4fd2:	89 a5       	lds	r24, 0x69
    4fd4:	9a a5       	lds	r25, 0x6a
    4fd6:	20 e0       	ldi	r18, 0x00	; 0
    4fd8:	3f ef       	ldi	r19, 0xFF	; 255
    4fda:	4f e7       	ldi	r20, 0x7F	; 127
    4fdc:	57 e4       	ldi	r21, 0x47	; 71
    4fde:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    4fe2:	18 16       	cp	r1, r24
    4fe4:	0c f0       	brlt	.+2      	; 0x4fe8 <chb_set_state+0x362>
    4fe6:	10 e0       	ldi	r17, 0x00	; 0
    4fe8:	11 23       	and	r17, r17
    4fea:	61 f1       	breq	.+88     	; 0x5044 <chb_set_state+0x3be>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4fec:	6b a1       	lds	r22, 0x4b
    4fee:	7c a1       	lds	r23, 0x4c
    4ff0:	8d a1       	lds	r24, 0x4d
    4ff2:	9e a1       	lds	r25, 0x4e
    4ff4:	20 e0       	ldi	r18, 0x00	; 0
    4ff6:	30 e0       	ldi	r19, 0x00	; 0
    4ff8:	40 e2       	ldi	r20, 0x20	; 32
    4ffa:	51 e4       	ldi	r21, 0x41	; 65
    4ffc:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    5000:	dc 01       	movw	r26, r24
    5002:	cb 01       	movw	r24, r22
    5004:	bc 01       	movw	r22, r24
    5006:	cd 01       	movw	r24, r26
    5008:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    500c:	dc 01       	movw	r26, r24
    500e:	cb 01       	movw	r24, r22
    5010:	8b a7       	lds	r24, 0x7b
    5012:	9c a7       	lds	r25, 0x7c
    5014:	12 c0       	rjmp	.+36     	; 0x503a <chb_set_state+0x3b4>
    5016:	89 e1       	ldi	r24, 0x19	; 25
    5018:	90 e0       	ldi	r25, 0x00	; 0
    501a:	8d a7       	lds	r24, 0x7d
    501c:	9e a7       	lds	r25, 0x7e
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    501e:	8d a5       	lds	r24, 0x6d
    5020:	9e a5       	lds	r25, 0x6e
    5022:	8c 01       	movw	r16, r24
    5024:	c8 01       	movw	r24, r16
    5026:	01 97       	sbiw	r24, 0x01	; 1
    5028:	f1 f7       	brne	.-4      	; 0x5026 <chb_set_state+0x3a0>
    502a:	8c 01       	movw	r16, r24
    502c:	0d a7       	lds	r16, 0x7d
    502e:	1e a7       	lds	r17, 0x7e
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5030:	8b a5       	lds	r24, 0x6b
    5032:	9c a5       	lds	r25, 0x6c
    5034:	01 97       	sbiw	r24, 0x01	; 1
    5036:	8b a7       	lds	r24, 0x7b
    5038:	9c a7       	lds	r25, 0x7c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    503a:	8b a5       	lds	r24, 0x6b
    503c:	9c a5       	lds	r25, 0x6c
    503e:	00 97       	sbiw	r24, 0x00	; 0
    5040:	51 f7       	brne	.-44     	; 0x5016 <chb_set_state+0x390>
    5042:	29 c0       	rjmp	.+82     	; 0x5096 <chb_set_state+0x410>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5044:	6f a1       	lds	r22, 0x4f
    5046:	78 a5       	lds	r23, 0x68
    5048:	89 a5       	lds	r24, 0x69
    504a:	9a a5       	lds	r25, 0x6a
    504c:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    5050:	dc 01       	movw	r26, r24
    5052:	cb 01       	movw	r24, r22
    5054:	8b a7       	lds	r24, 0x7b
    5056:	9c a7       	lds	r25, 0x7c
    5058:	8b a5       	lds	r24, 0x6b
    505a:	9c a5       	lds	r25, 0x6c
    505c:	8f a7       	lds	r24, 0x7f
    505e:	98 ab       	sts	0x58, r25
    5060:	8f a5       	lds	r24, 0x6f
    5062:	98 a9       	sts	0x48, r25
    5064:	8c 01       	movw	r16, r24
    5066:	f8 01       	movw	r30, r16
    5068:	31 97       	sbiw	r30, 0x01	; 1
    506a:	f1 f7       	brne	.-4      	; 0x5068 <chb_set_state+0x3e2>
    506c:	8f 01       	movw	r16, r30
    506e:	0f a7       	lds	r16, 0x7f
    5070:	18 ab       	sts	0x58, r17
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    5072:	41 c1       	rjmp	.+642    	; 0x52f6 <chb_set_state+0x670>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5074:	6e 8d       	ldd	r22, Y+30	; 0x1e
    5076:	7f 8d       	ldd	r23, Y+31	; 0x1f
    5078:	88 a1       	lds	r24, 0x48
    507a:	99 a1       	lds	r25, 0x49
    507c:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    5080:	dc 01       	movw	r26, r24
    5082:	cb 01       	movw	r24, r22
    5084:	8a a3       	lds	r24, 0x5a
    5086:	8a a1       	lds	r24, 0x4a
    5088:	89 ab       	sts	0x59, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    508a:	89 a9       	sts	0x49, r24
    508c:	18 2f       	mov	r17, r24
    508e:	1a 95       	dec	r17
    5090:	f1 f7       	brne	.-4      	; 0x508e <chb_set_state+0x408>
    5092:	19 ab       	sts	0x59, r17
    5094:	30 c1       	rjmp	.+608    	; 0x52f6 <chb_set_state+0x670>
    5096:	2f c1       	rjmp	.+606    	; 0x52f6 <chb_set_state+0x670>

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    5098:	89 81       	ldd	r24, Y+1	; 0x01
    509a:	89 31       	cpi	r24, 0x19	; 25
    509c:	09 f0       	breq	.+2      	; 0x50a0 <chb_set_state+0x41a>
    509e:	2d c1       	rjmp	.+602    	; 0x52fa <chb_set_state+0x674>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    50a0:	82 e0       	ldi	r24, 0x02	; 2
    50a2:	69 e0       	ldi	r22, 0x09	; 9
    50a4:	4f e1       	ldi	r20, 0x1F	; 31
    50a6:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>
    50aa:	80 e0       	ldi	r24, 0x00	; 0
    50ac:	90 e0       	ldi	r25, 0x00	; 0
    50ae:	a0 e8       	ldi	r26, 0x80	; 128
    50b0:	bf e3       	ldi	r27, 0x3F	; 63
    50b2:	8a ab       	sts	0x5a, r24
    50b4:	9b ab       	sts	0x5b, r25
    50b6:	ac ab       	sts	0x5c, r26
    50b8:	bd ab       	sts	0x5d, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    50ba:	6a a9       	sts	0x4a, r22
    50bc:	7b a9       	sts	0x4b, r23
    50be:	8c a9       	sts	0x4c, r24
    50c0:	9d a9       	sts	0x4d, r25
    50c2:	2b ea       	ldi	r18, 0xAB	; 171
    50c4:	3a ea       	ldi	r19, 0xAA	; 170
    50c6:	4a ea       	ldi	r20, 0xAA	; 170
    50c8:	5e e3       	ldi	r21, 0x3E	; 62
    50ca:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    50ce:	dc 01       	movw	r26, r24
    50d0:	cb 01       	movw	r24, r22
    50d2:	8e ab       	sts	0x5e, r24
    50d4:	9f ab       	sts	0x5f, r25
    50d6:	a8 af       	sts	0x78, r26
    50d8:	b9 af       	sts	0x79, r27
	if (__tmp < 1.0)
    50da:	11 e0       	ldi	r17, 0x01	; 1
    50dc:	6e a9       	sts	0x4e, r22
    50de:	7f a9       	sts	0x4f, r23
    50e0:	88 ad       	sts	0x68, r24
    50e2:	99 ad       	sts	0x69, r25
    50e4:	20 e0       	ldi	r18, 0x00	; 0
    50e6:	30 e0       	ldi	r19, 0x00	; 0
    50e8:	40 e8       	ldi	r20, 0x80	; 128
    50ea:	5f e3       	ldi	r21, 0x3F	; 63
    50ec:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    50f0:	88 23       	and	r24, r24
    50f2:	0c f0       	brlt	.+2      	; 0x50f6 <chb_set_state+0x470>
    50f4:	10 e0       	ldi	r17, 0x00	; 0
    50f6:	11 23       	and	r17, r17
    50f8:	19 f0       	breq	.+6      	; 0x5100 <chb_set_state+0x47a>
		__ticks = 1;
    50fa:	81 e0       	ldi	r24, 0x01	; 1
    50fc:	8a af       	sts	0x7a, r24
    50fe:	e6 c0       	rjmp	.+460    	; 0x52cc <chb_set_state+0x646>
	else if (__tmp > 255)
    5100:	11 e0       	ldi	r17, 0x01	; 1
    5102:	6e a9       	sts	0x4e, r22
    5104:	7f a9       	sts	0x4f, r23
    5106:	88 ad       	sts	0x68, r24
    5108:	99 ad       	sts	0x69, r25
    510a:	20 e0       	ldi	r18, 0x00	; 0
    510c:	30 e0       	ldi	r19, 0x00	; 0
    510e:	4f e7       	ldi	r20, 0x7F	; 127
    5110:	53 e4       	ldi	r21, 0x43	; 67
    5112:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    5116:	18 16       	cp	r1, r24
    5118:	0c f0       	brlt	.+2      	; 0x511c <chb_set_state+0x496>
    511a:	10 e0       	ldi	r17, 0x00	; 0
    511c:	11 23       	and	r17, r17
    511e:	09 f4       	brne	.+2      	; 0x5122 <chb_set_state+0x49c>
    5120:	cc c0       	rjmp	.+408    	; 0x52ba <chb_set_state+0x634>
	{
		_delay_ms(__us / 1000.0);
    5122:	6a a9       	sts	0x4a, r22
    5124:	7b a9       	sts	0x4b, r23
    5126:	8c a9       	sts	0x4c, r24
    5128:	9d a9       	sts	0x4d, r25
    512a:	20 e0       	ldi	r18, 0x00	; 0
    512c:	30 e0       	ldi	r19, 0x00	; 0
    512e:	4a e7       	ldi	r20, 0x7A	; 122
    5130:	54 e4       	ldi	r21, 0x44	; 68
    5132:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
    5136:	dc 01       	movw	r26, r24
    5138:	cb 01       	movw	r24, r22
    513a:	8b af       	sts	0x7b, r24
    513c:	9c af       	sts	0x7c, r25
    513e:	ad af       	sts	0x7d, r26
    5140:	be af       	sts	0x7e, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5142:	8e 01       	movw	r16, r28
    5144:	01 5c       	subi	r16, 0xC1	; 193
    5146:	1f 4f       	sbci	r17, 0xFF	; 255
    5148:	6b ad       	sts	0x6b, r22
    514a:	7c ad       	sts	0x6c, r23
    514c:	8d ad       	sts	0x6d, r24
    514e:	9e ad       	sts	0x6e, r25
    5150:	20 e0       	ldi	r18, 0x00	; 0
    5152:	30 e0       	ldi	r19, 0x00	; 0
    5154:	4a e7       	ldi	r20, 0x7A	; 122
    5156:	53 e4       	ldi	r21, 0x43	; 67
    5158:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    515c:	dc 01       	movw	r26, r24
    515e:	cb 01       	movw	r24, r22
    5160:	f8 01       	movw	r30, r16
    5162:	80 83       	st	Z, r24
    5164:	91 83       	std	Z+1, r25	; 0x01
    5166:	a2 83       	std	Z+2, r26	; 0x02
    5168:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    516a:	ce 01       	movw	r24, r28
    516c:	cf 96       	adiw	r24, 0x3f	; 63
    516e:	11 e0       	ldi	r17, 0x01	; 1
    5170:	fc 01       	movw	r30, r24
    5172:	60 81       	ld	r22, Z
    5174:	71 81       	ldd	r23, Z+1	; 0x01
    5176:	82 81       	ldd	r24, Z+2	; 0x02
    5178:	93 81       	ldd	r25, Z+3	; 0x03
    517a:	20 e0       	ldi	r18, 0x00	; 0
    517c:	30 e0       	ldi	r19, 0x00	; 0
    517e:	40 e8       	ldi	r20, 0x80	; 128
    5180:	5f e3       	ldi	r21, 0x3F	; 63
    5182:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    5186:	88 23       	and	r24, r24
    5188:	0c f0       	brlt	.+2      	; 0x518c <chb_set_state+0x506>
    518a:	10 e0       	ldi	r17, 0x00	; 0
    518c:	11 23       	and	r17, r17
    518e:	49 f0       	breq	.+18     	; 0x51a2 <chb_set_state+0x51c>
		__ticks = 1;
    5190:	ce 01       	movw	r24, r28
    5192:	8d 5b       	subi	r24, 0xBD	; 189
    5194:	9f 4f       	sbci	r25, 0xFF	; 255
    5196:	21 e0       	ldi	r18, 0x01	; 1
    5198:	30 e0       	ldi	r19, 0x00	; 0
    519a:	fc 01       	movw	r30, r24
    519c:	20 83       	st	Z, r18
    519e:	31 83       	std	Z+1, r19	; 0x01
    51a0:	6e c0       	rjmp	.+220    	; 0x527e <chb_set_state+0x5f8>
	else if (__tmp > 65535)
    51a2:	ce 01       	movw	r24, r28
    51a4:	cf 96       	adiw	r24, 0x3f	; 63
    51a6:	11 e0       	ldi	r17, 0x01	; 1
    51a8:	fc 01       	movw	r30, r24
    51aa:	60 81       	ld	r22, Z
    51ac:	71 81       	ldd	r23, Z+1	; 0x01
    51ae:	82 81       	ldd	r24, Z+2	; 0x02
    51b0:	93 81       	ldd	r25, Z+3	; 0x03
    51b2:	20 e0       	ldi	r18, 0x00	; 0
    51b4:	3f ef       	ldi	r19, 0xFF	; 255
    51b6:	4f e7       	ldi	r20, 0x7F	; 127
    51b8:	57 e4       	ldi	r21, 0x47	; 71
    51ba:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    51be:	18 16       	cp	r1, r24
    51c0:	0c f0       	brlt	.+2      	; 0x51c4 <chb_set_state+0x53e>
    51c2:	10 e0       	ldi	r17, 0x00	; 0
    51c4:	11 23       	and	r17, r17
    51c6:	09 f4       	brne	.+2      	; 0x51ca <chb_set_state+0x544>
    51c8:	49 c0       	rjmp	.+146    	; 0x525c <chb_set_state+0x5d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    51ca:	6b ad       	sts	0x6b, r22
    51cc:	7c ad       	sts	0x6c, r23
    51ce:	8d ad       	sts	0x6d, r24
    51d0:	9e ad       	sts	0x6e, r25
    51d2:	20 e0       	ldi	r18, 0x00	; 0
    51d4:	30 e0       	ldi	r19, 0x00	; 0
    51d6:	40 e2       	ldi	r20, 0x20	; 32
    51d8:	51 e4       	ldi	r21, 0x41	; 65
    51da:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    51de:	dc 01       	movw	r26, r24
    51e0:	cb 01       	movw	r24, r22
    51e2:	8e 01       	movw	r16, r28
    51e4:	0d 5b       	subi	r16, 0xBD	; 189
    51e6:	1f 4f       	sbci	r17, 0xFF	; 255
    51e8:	bc 01       	movw	r22, r24
    51ea:	cd 01       	movw	r24, r26
    51ec:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    51f0:	dc 01       	movw	r26, r24
    51f2:	cb 01       	movw	r24, r22
    51f4:	f8 01       	movw	r30, r16
    51f6:	80 83       	st	Z, r24
    51f8:	91 83       	std	Z+1, r25	; 0x01
    51fa:	27 c0       	rjmp	.+78     	; 0x524a <chb_set_state+0x5c4>
    51fc:	ce 01       	movw	r24, r28
    51fe:	8b 5b       	subi	r24, 0xBB	; 187
    5200:	9f 4f       	sbci	r25, 0xFF	; 255
    5202:	29 e1       	ldi	r18, 0x19	; 25
    5204:	30 e0       	ldi	r19, 0x00	; 0
    5206:	fc 01       	movw	r30, r24
    5208:	20 83       	st	Z, r18
    520a:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    520c:	ce 01       	movw	r24, r28
    520e:	8b 5b       	subi	r24, 0xBB	; 187
    5210:	9f 4f       	sbci	r25, 0xFF	; 255
    5212:	fc 01       	movw	r30, r24
    5214:	80 81       	ld	r24, Z
    5216:	91 81       	ldd	r25, Z+1	; 0x01
    5218:	8c 01       	movw	r16, r24
    521a:	c8 01       	movw	r24, r16
    521c:	01 97       	sbiw	r24, 0x01	; 1
    521e:	f1 f7       	brne	.-4      	; 0x521c <chb_set_state+0x596>
    5220:	8c 01       	movw	r16, r24
    5222:	ce 01       	movw	r24, r28
    5224:	8b 5b       	subi	r24, 0xBB	; 187
    5226:	9f 4f       	sbci	r25, 0xFF	; 255
    5228:	fc 01       	movw	r30, r24
    522a:	00 83       	st	Z, r16
    522c:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    522e:	ce 01       	movw	r24, r28
    5230:	8d 5b       	subi	r24, 0xBD	; 189
    5232:	9f 4f       	sbci	r25, 0xFF	; 255
    5234:	9e 01       	movw	r18, r28
    5236:	2d 5b       	subi	r18, 0xBD	; 189
    5238:	3f 4f       	sbci	r19, 0xFF	; 255
    523a:	f9 01       	movw	r30, r18
    523c:	20 81       	ld	r18, Z
    523e:	31 81       	ldd	r19, Z+1	; 0x01
    5240:	21 50       	subi	r18, 0x01	; 1
    5242:	30 40       	sbci	r19, 0x00	; 0
    5244:	fc 01       	movw	r30, r24
    5246:	20 83       	st	Z, r18
    5248:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    524a:	ce 01       	movw	r24, r28
    524c:	8d 5b       	subi	r24, 0xBD	; 189
    524e:	9f 4f       	sbci	r25, 0xFF	; 255
    5250:	fc 01       	movw	r30, r24
    5252:	80 81       	ld	r24, Z
    5254:	91 81       	ldd	r25, Z+1	; 0x01
    5256:	00 97       	sbiw	r24, 0x00	; 0
    5258:	89 f6       	brne	.-94     	; 0x51fc <chb_set_state+0x576>
    525a:	4c c0       	rjmp	.+152    	; 0x52f4 <chb_set_state+0x66e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    525c:	8e 01       	movw	r16, r28
    525e:	0d 5b       	subi	r16, 0xBD	; 189
    5260:	1f 4f       	sbci	r17, 0xFF	; 255
    5262:	ce 01       	movw	r24, r28
    5264:	cf 96       	adiw	r24, 0x3f	; 63
    5266:	fc 01       	movw	r30, r24
    5268:	60 81       	ld	r22, Z
    526a:	71 81       	ldd	r23, Z+1	; 0x01
    526c:	82 81       	ldd	r24, Z+2	; 0x02
    526e:	93 81       	ldd	r25, Z+3	; 0x03
    5270:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    5274:	dc 01       	movw	r26, r24
    5276:	cb 01       	movw	r24, r22
    5278:	f8 01       	movw	r30, r16
    527a:	80 83       	st	Z, r24
    527c:	91 83       	std	Z+1, r25	; 0x01
    527e:	ce 01       	movw	r24, r28
    5280:	89 5b       	subi	r24, 0xB9	; 185
    5282:	9f 4f       	sbci	r25, 0xFF	; 255
    5284:	9e 01       	movw	r18, r28
    5286:	2d 5b       	subi	r18, 0xBD	; 189
    5288:	3f 4f       	sbci	r19, 0xFF	; 255
    528a:	f9 01       	movw	r30, r18
    528c:	20 81       	ld	r18, Z
    528e:	31 81       	ldd	r19, Z+1	; 0x01
    5290:	fc 01       	movw	r30, r24
    5292:	20 83       	st	Z, r18
    5294:	31 83       	std	Z+1, r19	; 0x01
    5296:	ce 01       	movw	r24, r28
    5298:	89 5b       	subi	r24, 0xB9	; 185
    529a:	9f 4f       	sbci	r25, 0xFF	; 255
    529c:	fc 01       	movw	r30, r24
    529e:	80 81       	ld	r24, Z
    52a0:	91 81       	ldd	r25, Z+1	; 0x01
    52a2:	8c 01       	movw	r16, r24
    52a4:	c8 01       	movw	r24, r16
    52a6:	01 97       	sbiw	r24, 0x01	; 1
    52a8:	f1 f7       	brne	.-4      	; 0x52a6 <chb_set_state+0x620>
    52aa:	8c 01       	movw	r16, r24
    52ac:	ce 01       	movw	r24, r28
    52ae:	89 5b       	subi	r24, 0xB9	; 185
    52b0:	9f 4f       	sbci	r25, 0xFF	; 255
    52b2:	fc 01       	movw	r30, r24
    52b4:	00 83       	st	Z, r16
    52b6:	11 83       	std	Z+1, r17	; 0x01
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    52b8:	20 c0       	rjmp	.+64     	; 0x52fa <chb_set_state+0x674>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    52ba:	6e a9       	sts	0x4e, r22
    52bc:	7f a9       	sts	0x4f, r23
    52be:	88 ad       	sts	0x68, r24
    52c0:	99 ad       	sts	0x69, r25
    52c2:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    52c6:	dc 01       	movw	r26, r24
    52c8:	cb 01       	movw	r24, r22
    52ca:	8a af       	sts	0x7a, r24
    52cc:	ce 01       	movw	r24, r28
    52ce:	87 5b       	subi	r24, 0xB7	; 183
    52d0:	9f 4f       	sbci	r25, 0xFF	; 255
    52d2:	2a ad       	sts	0x6a, r18
    52d4:	fc 01       	movw	r30, r24
    52d6:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    52d8:	ce 01       	movw	r24, r28
    52da:	87 5b       	subi	r24, 0xB7	; 183
    52dc:	9f 4f       	sbci	r25, 0xFF	; 255
    52de:	fc 01       	movw	r30, r24
    52e0:	80 81       	ld	r24, Z
    52e2:	18 2f       	mov	r17, r24
    52e4:	1a 95       	dec	r17
    52e6:	f1 f7       	brne	.-4      	; 0x52e4 <chb_set_state+0x65e>
    52e8:	ce 01       	movw	r24, r28
    52ea:	87 5b       	subi	r24, 0xB7	; 183
    52ec:	9f 4f       	sbci	r25, 0xFF	; 255
    52ee:	fc 01       	movw	r30, r24
    52f0:	10 83       	st	Z, r17
    52f2:	03 c0       	rjmp	.+6      	; 0x52fa <chb_set_state+0x674>
    52f4:	02 c0       	rjmp	.+4      	; 0x52fa <chb_set_state+0x674>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    52f6:	00 00       	nop
    52f8:	01 c0       	rjmp	.+2      	; 0x52fc <chb_set_state+0x676>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;
    52fa:	00 00       	nop
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    52fc:	9e 01       	movw	r18, r28
    52fe:	2e 59       	subi	r18, 0x9E	; 158
    5300:	3f 4f       	sbci	r19, 0xFF	; 255
    5302:	82 e0       	ldi	r24, 0x02	; 2
    5304:	f9 01       	movw	r30, r18
    5306:	60 81       	ld	r22, Z
    5308:	4f e1       	ldi	r20, 0x1F	; 31
    530a:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>
    530e:	9e 01       	movw	r18, r28
    5310:	26 5b       	subi	r18, 0xB6	; 182
    5312:	3f 4f       	sbci	r19, 0xFF	; 255
    5314:	80 e0       	ldi	r24, 0x00	; 0
    5316:	90 e0       	ldi	r25, 0x00	; 0
    5318:	ac ed       	ldi	r26, 0xDC	; 220
    531a:	b2 e4       	ldi	r27, 0x42	; 66
    531c:	f9 01       	movw	r30, r18
    531e:	80 83       	st	Z, r24
    5320:	91 83       	std	Z+1, r25	; 0x01
    5322:	a2 83       	std	Z+2, r26	; 0x02
    5324:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    5326:	8e 01       	movw	r16, r28
    5328:	02 5b       	subi	r16, 0xB2	; 178
    532a:	1f 4f       	sbci	r17, 0xFF	; 255
    532c:	ce 01       	movw	r24, r28
    532e:	86 5b       	subi	r24, 0xB6	; 182
    5330:	9f 4f       	sbci	r25, 0xFF	; 255
    5332:	fc 01       	movw	r30, r24
    5334:	60 81       	ld	r22, Z
    5336:	71 81       	ldd	r23, Z+1	; 0x01
    5338:	82 81       	ldd	r24, Z+2	; 0x02
    533a:	93 81       	ldd	r25, Z+3	; 0x03
    533c:	2b ea       	ldi	r18, 0xAB	; 171
    533e:	3a ea       	ldi	r19, 0xAA	; 170
    5340:	4a ea       	ldi	r20, 0xAA	; 170
    5342:	5e e3       	ldi	r21, 0x3E	; 62
    5344:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    5348:	dc 01       	movw	r26, r24
    534a:	cb 01       	movw	r24, r22
    534c:	f8 01       	movw	r30, r16
    534e:	80 83       	st	Z, r24
    5350:	91 83       	std	Z+1, r25	; 0x01
    5352:	a2 83       	std	Z+2, r26	; 0x02
    5354:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    5356:	ce 01       	movw	r24, r28
    5358:	82 5b       	subi	r24, 0xB2	; 178
    535a:	9f 4f       	sbci	r25, 0xFF	; 255
    535c:	11 e0       	ldi	r17, 0x01	; 1
    535e:	fc 01       	movw	r30, r24
    5360:	60 81       	ld	r22, Z
    5362:	71 81       	ldd	r23, Z+1	; 0x01
    5364:	82 81       	ldd	r24, Z+2	; 0x02
    5366:	93 81       	ldd	r25, Z+3	; 0x03
    5368:	20 e0       	ldi	r18, 0x00	; 0
    536a:	30 e0       	ldi	r19, 0x00	; 0
    536c:	40 e8       	ldi	r20, 0x80	; 128
    536e:	5f e3       	ldi	r21, 0x3F	; 63
    5370:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    5374:	88 23       	and	r24, r24
    5376:	0c f0       	brlt	.+2      	; 0x537a <chb_set_state+0x6f4>
    5378:	10 e0       	ldi	r17, 0x00	; 0
    537a:	11 23       	and	r17, r17
    537c:	39 f0       	breq	.+14     	; 0x538c <chb_set_state+0x706>
		__ticks = 1;
    537e:	ce 01       	movw	r24, r28
    5380:	8e 5a       	subi	r24, 0xAE	; 174
    5382:	9f 4f       	sbci	r25, 0xFF	; 255
    5384:	21 e0       	ldi	r18, 0x01	; 1
    5386:	fc 01       	movw	r30, r24
    5388:	20 83       	st	Z, r18
    538a:	05 c1       	rjmp	.+522    	; 0x5596 <chb_set_state+0x910>
	else if (__tmp > 255)
    538c:	ce 01       	movw	r24, r28
    538e:	82 5b       	subi	r24, 0xB2	; 178
    5390:	9f 4f       	sbci	r25, 0xFF	; 255
    5392:	11 e0       	ldi	r17, 0x01	; 1
    5394:	fc 01       	movw	r30, r24
    5396:	60 81       	ld	r22, Z
    5398:	71 81       	ldd	r23, Z+1	; 0x01
    539a:	82 81       	ldd	r24, Z+2	; 0x02
    539c:	93 81       	ldd	r25, Z+3	; 0x03
    539e:	20 e0       	ldi	r18, 0x00	; 0
    53a0:	30 e0       	ldi	r19, 0x00	; 0
    53a2:	4f e7       	ldi	r20, 0x7F	; 127
    53a4:	53 e4       	ldi	r21, 0x43	; 67
    53a6:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    53aa:	18 16       	cp	r1, r24
    53ac:	0c f0       	brlt	.+2      	; 0x53b0 <chb_set_state+0x72a>
    53ae:	10 e0       	ldi	r17, 0x00	; 0
    53b0:	11 23       	and	r17, r17
    53b2:	09 f4       	brne	.+2      	; 0x53b6 <chb_set_state+0x730>
    53b4:	df c0       	rjmp	.+446    	; 0x5574 <chb_set_state+0x8ee>
	{
		_delay_ms(__us / 1000.0);
    53b6:	ce 01       	movw	r24, r28
    53b8:	86 5b       	subi	r24, 0xB6	; 182
    53ba:	9f 4f       	sbci	r25, 0xFF	; 255
    53bc:	fc 01       	movw	r30, r24
    53be:	60 81       	ld	r22, Z
    53c0:	71 81       	ldd	r23, Z+1	; 0x01
    53c2:	82 81       	ldd	r24, Z+2	; 0x02
    53c4:	93 81       	ldd	r25, Z+3	; 0x03
    53c6:	20 e0       	ldi	r18, 0x00	; 0
    53c8:	30 e0       	ldi	r19, 0x00	; 0
    53ca:	4a e7       	ldi	r20, 0x7A	; 122
    53cc:	54 e4       	ldi	r21, 0x44	; 68
    53ce:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
    53d2:	dc 01       	movw	r26, r24
    53d4:	cb 01       	movw	r24, r22
    53d6:	9e 01       	movw	r18, r28
    53d8:	2d 5a       	subi	r18, 0xAD	; 173
    53da:	3f 4f       	sbci	r19, 0xFF	; 255
    53dc:	f9 01       	movw	r30, r18
    53de:	80 83       	st	Z, r24
    53e0:	91 83       	std	Z+1, r25	; 0x01
    53e2:	a2 83       	std	Z+2, r26	; 0x02
    53e4:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    53e6:	8e 01       	movw	r16, r28
    53e8:	09 5a       	subi	r16, 0xA9	; 169
    53ea:	1f 4f       	sbci	r17, 0xFF	; 255
    53ec:	ce 01       	movw	r24, r28
    53ee:	8d 5a       	subi	r24, 0xAD	; 173
    53f0:	9f 4f       	sbci	r25, 0xFF	; 255
    53f2:	fc 01       	movw	r30, r24
    53f4:	60 81       	ld	r22, Z
    53f6:	71 81       	ldd	r23, Z+1	; 0x01
    53f8:	82 81       	ldd	r24, Z+2	; 0x02
    53fa:	93 81       	ldd	r25, Z+3	; 0x03
    53fc:	20 e0       	ldi	r18, 0x00	; 0
    53fe:	30 e0       	ldi	r19, 0x00	; 0
    5400:	4a e7       	ldi	r20, 0x7A	; 122
    5402:	53 e4       	ldi	r21, 0x43	; 67
    5404:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    5408:	dc 01       	movw	r26, r24
    540a:	cb 01       	movw	r24, r22
    540c:	f8 01       	movw	r30, r16
    540e:	80 83       	st	Z, r24
    5410:	91 83       	std	Z+1, r25	; 0x01
    5412:	a2 83       	std	Z+2, r26	; 0x02
    5414:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    5416:	ce 01       	movw	r24, r28
    5418:	89 5a       	subi	r24, 0xA9	; 169
    541a:	9f 4f       	sbci	r25, 0xFF	; 255
    541c:	11 e0       	ldi	r17, 0x01	; 1
    541e:	fc 01       	movw	r30, r24
    5420:	60 81       	ld	r22, Z
    5422:	71 81       	ldd	r23, Z+1	; 0x01
    5424:	82 81       	ldd	r24, Z+2	; 0x02
    5426:	93 81       	ldd	r25, Z+3	; 0x03
    5428:	20 e0       	ldi	r18, 0x00	; 0
    542a:	30 e0       	ldi	r19, 0x00	; 0
    542c:	40 e8       	ldi	r20, 0x80	; 128
    542e:	5f e3       	ldi	r21, 0x3F	; 63
    5430:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    5434:	88 23       	and	r24, r24
    5436:	0c f0       	brlt	.+2      	; 0x543a <chb_set_state+0x7b4>
    5438:	10 e0       	ldi	r17, 0x00	; 0
    543a:	11 23       	and	r17, r17
    543c:	49 f0       	breq	.+18     	; 0x5450 <chb_set_state+0x7ca>
		__ticks = 1;
    543e:	ce 01       	movw	r24, r28
    5440:	85 5a       	subi	r24, 0xA5	; 165
    5442:	9f 4f       	sbci	r25, 0xFF	; 255
    5444:	21 e0       	ldi	r18, 0x01	; 1
    5446:	30 e0       	ldi	r19, 0x00	; 0
    5448:	fc 01       	movw	r30, r24
    544a:	20 83       	st	Z, r18
    544c:	31 83       	std	Z+1, r19	; 0x01
    544e:	74 c0       	rjmp	.+232    	; 0x5538 <chb_set_state+0x8b2>
	else if (__tmp > 65535)
    5450:	ce 01       	movw	r24, r28
    5452:	89 5a       	subi	r24, 0xA9	; 169
    5454:	9f 4f       	sbci	r25, 0xFF	; 255
    5456:	11 e0       	ldi	r17, 0x01	; 1
    5458:	fc 01       	movw	r30, r24
    545a:	60 81       	ld	r22, Z
    545c:	71 81       	ldd	r23, Z+1	; 0x01
    545e:	82 81       	ldd	r24, Z+2	; 0x02
    5460:	93 81       	ldd	r25, Z+3	; 0x03
    5462:	20 e0       	ldi	r18, 0x00	; 0
    5464:	3f ef       	ldi	r19, 0xFF	; 255
    5466:	4f e7       	ldi	r20, 0x7F	; 127
    5468:	57 e4       	ldi	r21, 0x47	; 71
    546a:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    546e:	18 16       	cp	r1, r24
    5470:	0c f0       	brlt	.+2      	; 0x5474 <chb_set_state+0x7ee>
    5472:	10 e0       	ldi	r17, 0x00	; 0
    5474:	11 23       	and	r17, r17
    5476:	09 f4       	brne	.+2      	; 0x547a <chb_set_state+0x7f4>
    5478:	4d c0       	rjmp	.+154    	; 0x5514 <chb_set_state+0x88e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    547a:	ce 01       	movw	r24, r28
    547c:	8d 5a       	subi	r24, 0xAD	; 173
    547e:	9f 4f       	sbci	r25, 0xFF	; 255
    5480:	fc 01       	movw	r30, r24
    5482:	60 81       	ld	r22, Z
    5484:	71 81       	ldd	r23, Z+1	; 0x01
    5486:	82 81       	ldd	r24, Z+2	; 0x02
    5488:	93 81       	ldd	r25, Z+3	; 0x03
    548a:	20 e0       	ldi	r18, 0x00	; 0
    548c:	30 e0       	ldi	r19, 0x00	; 0
    548e:	40 e2       	ldi	r20, 0x20	; 32
    5490:	51 e4       	ldi	r21, 0x41	; 65
    5492:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    5496:	dc 01       	movw	r26, r24
    5498:	cb 01       	movw	r24, r22
    549a:	8e 01       	movw	r16, r28
    549c:	05 5a       	subi	r16, 0xA5	; 165
    549e:	1f 4f       	sbci	r17, 0xFF	; 255
    54a0:	bc 01       	movw	r22, r24
    54a2:	cd 01       	movw	r24, r26
    54a4:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    54a8:	dc 01       	movw	r26, r24
    54aa:	cb 01       	movw	r24, r22
    54ac:	f8 01       	movw	r30, r16
    54ae:	80 83       	st	Z, r24
    54b0:	91 83       	std	Z+1, r25	; 0x01
    54b2:	27 c0       	rjmp	.+78     	; 0x5502 <chb_set_state+0x87c>
    54b4:	ce 01       	movw	r24, r28
    54b6:	83 5a       	subi	r24, 0xA3	; 163
    54b8:	9f 4f       	sbci	r25, 0xFF	; 255
    54ba:	29 e1       	ldi	r18, 0x19	; 25
    54bc:	30 e0       	ldi	r19, 0x00	; 0
    54be:	fc 01       	movw	r30, r24
    54c0:	20 83       	st	Z, r18
    54c2:	31 83       	std	Z+1, r19	; 0x01
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    54c4:	ce 01       	movw	r24, r28
    54c6:	83 5a       	subi	r24, 0xA3	; 163
    54c8:	9f 4f       	sbci	r25, 0xFF	; 255
    54ca:	fc 01       	movw	r30, r24
    54cc:	80 81       	ld	r24, Z
    54ce:	91 81       	ldd	r25, Z+1	; 0x01
    54d0:	8c 01       	movw	r16, r24
    54d2:	c8 01       	movw	r24, r16
    54d4:	01 97       	sbiw	r24, 0x01	; 1
    54d6:	f1 f7       	brne	.-4      	; 0x54d4 <chb_set_state+0x84e>
    54d8:	8c 01       	movw	r16, r24
    54da:	ce 01       	movw	r24, r28
    54dc:	83 5a       	subi	r24, 0xA3	; 163
    54de:	9f 4f       	sbci	r25, 0xFF	; 255
    54e0:	fc 01       	movw	r30, r24
    54e2:	00 83       	st	Z, r16
    54e4:	11 83       	std	Z+1, r17	; 0x01
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    54e6:	ce 01       	movw	r24, r28
    54e8:	85 5a       	subi	r24, 0xA5	; 165
    54ea:	9f 4f       	sbci	r25, 0xFF	; 255
    54ec:	9e 01       	movw	r18, r28
    54ee:	25 5a       	subi	r18, 0xA5	; 165
    54f0:	3f 4f       	sbci	r19, 0xFF	; 255
    54f2:	f9 01       	movw	r30, r18
    54f4:	20 81       	ld	r18, Z
    54f6:	31 81       	ldd	r19, Z+1	; 0x01
    54f8:	21 50       	subi	r18, 0x01	; 1
    54fa:	30 40       	sbci	r19, 0x00	; 0
    54fc:	fc 01       	movw	r30, r24
    54fe:	20 83       	st	Z, r18
    5500:	31 83       	std	Z+1, r19	; 0x01
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5502:	ce 01       	movw	r24, r28
    5504:	85 5a       	subi	r24, 0xA5	; 165
    5506:	9f 4f       	sbci	r25, 0xFF	; 255
    5508:	fc 01       	movw	r30, r24
    550a:	80 81       	ld	r24, Z
    550c:	91 81       	ldd	r25, Z+1	; 0x01
    550e:	00 97       	sbiw	r24, 0x00	; 0
    5510:	89 f6       	brne	.-94     	; 0x54b4 <chb_set_state+0x82e>
    5512:	58 c0       	rjmp	.+176    	; 0x55c4 <chb_set_state+0x93e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5514:	8e 01       	movw	r16, r28
    5516:	05 5a       	subi	r16, 0xA5	; 165
    5518:	1f 4f       	sbci	r17, 0xFF	; 255
    551a:	ce 01       	movw	r24, r28
    551c:	89 5a       	subi	r24, 0xA9	; 169
    551e:	9f 4f       	sbci	r25, 0xFF	; 255
    5520:	fc 01       	movw	r30, r24
    5522:	60 81       	ld	r22, Z
    5524:	71 81       	ldd	r23, Z+1	; 0x01
    5526:	82 81       	ldd	r24, Z+2	; 0x02
    5528:	93 81       	ldd	r25, Z+3	; 0x03
    552a:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    552e:	dc 01       	movw	r26, r24
    5530:	cb 01       	movw	r24, r22
    5532:	f8 01       	movw	r30, r16
    5534:	80 83       	st	Z, r24
    5536:	91 83       	std	Z+1, r25	; 0x01
    5538:	ce 01       	movw	r24, r28
    553a:	81 5a       	subi	r24, 0xA1	; 161
    553c:	9f 4f       	sbci	r25, 0xFF	; 255
    553e:	9e 01       	movw	r18, r28
    5540:	25 5a       	subi	r18, 0xA5	; 165
    5542:	3f 4f       	sbci	r19, 0xFF	; 255
    5544:	f9 01       	movw	r30, r18
    5546:	20 81       	ld	r18, Z
    5548:	31 81       	ldd	r19, Z+1	; 0x01
    554a:	fc 01       	movw	r30, r24
    554c:	20 83       	st	Z, r18
    554e:	31 83       	std	Z+1, r19	; 0x01
    5550:	ce 01       	movw	r24, r28
    5552:	81 5a       	subi	r24, 0xA1	; 161
    5554:	9f 4f       	sbci	r25, 0xFF	; 255
    5556:	fc 01       	movw	r30, r24
    5558:	80 81       	ld	r24, Z
    555a:	91 81       	ldd	r25, Z+1	; 0x01
    555c:	8c 01       	movw	r16, r24
    555e:	c8 01       	movw	r24, r16
    5560:	01 97       	sbiw	r24, 0x01	; 1
    5562:	f1 f7       	brne	.-4      	; 0x5560 <chb_set_state+0x8da>
    5564:	8c 01       	movw	r16, r24
    5566:	ce 01       	movw	r24, r28
    5568:	81 5a       	subi	r24, 0xA1	; 161
    556a:	9f 4f       	sbci	r25, 0xFF	; 255
    556c:	fc 01       	movw	r30, r24
    556e:	00 83       	st	Z, r16
    5570:	11 83       	std	Z+1, r17	; 0x01
    5572:	28 c0       	rjmp	.+80     	; 0x55c4 <chb_set_state+0x93e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5574:	8e 01       	movw	r16, r28
    5576:	0e 5a       	subi	r16, 0xAE	; 174
    5578:	1f 4f       	sbci	r17, 0xFF	; 255
    557a:	ce 01       	movw	r24, r28
    557c:	82 5b       	subi	r24, 0xB2	; 178
    557e:	9f 4f       	sbci	r25, 0xFF	; 255
    5580:	fc 01       	movw	r30, r24
    5582:	60 81       	ld	r22, Z
    5584:	71 81       	ldd	r23, Z+1	; 0x01
    5586:	82 81       	ldd	r24, Z+2	; 0x02
    5588:	93 81       	ldd	r25, Z+3	; 0x03
    558a:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    558e:	dc 01       	movw	r26, r24
    5590:	cb 01       	movw	r24, r22
    5592:	f8 01       	movw	r30, r16
    5594:	80 83       	st	Z, r24
    5596:	ce 01       	movw	r24, r28
    5598:	8f 59       	subi	r24, 0x9F	; 159
    559a:	9f 4f       	sbci	r25, 0xFF	; 255
    559c:	9e 01       	movw	r18, r28
    559e:	2e 5a       	subi	r18, 0xAE	; 174
    55a0:	3f 4f       	sbci	r19, 0xFF	; 255
    55a2:	f9 01       	movw	r30, r18
    55a4:	20 81       	ld	r18, Z
    55a6:	fc 01       	movw	r30, r24
    55a8:	20 83       	st	Z, r18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    55aa:	ce 01       	movw	r24, r28
    55ac:	8f 59       	subi	r24, 0x9F	; 159
    55ae:	9f 4f       	sbci	r25, 0xFF	; 255
    55b0:	fc 01       	movw	r30, r24
    55b2:	80 81       	ld	r24, Z
    55b4:	18 2f       	mov	r17, r24
    55b6:	1a 95       	dec	r17
    55b8:	f1 f7       	brne	.-4      	; 0x55b6 <chb_set_state+0x930>
    55ba:	ce 01       	movw	r24, r28
    55bc:	8f 59       	subi	r24, 0x9F	; 159
    55be:	9f 4f       	sbci	r25, 0xFF	; 255
    55c0:	fc 01       	movw	r30, r24
    55c2:	10 83       	st	Z, r17

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    55c4:	0e 94 dc 20 	call	0x41b8	; 0x41b8 <chb_get_state>
    55c8:	28 2f       	mov	r18, r24
    55ca:	ce 01       	movw	r24, r28
    55cc:	8e 59       	subi	r24, 0x9E	; 158
    55ce:	9f 4f       	sbci	r25, 0xFF	; 255
    55d0:	fc 01       	movw	r30, r24
    55d2:	80 81       	ld	r24, Z
    55d4:	28 17       	cp	r18, r24
    55d6:	11 f4       	brne	.+4      	; 0x55dc <chb_set_state+0x956>
    {
        return RADIO_SUCCESS;
    55d8:	80 e4       	ldi	r24, 0x40	; 64
    55da:	01 c0       	rjmp	.+2      	; 0x55de <chb_set_state+0x958>
    }
    return RADIO_TIMED_OUT;
    55dc:	83 e4       	ldi	r24, 0x43	; 67
}
    55de:	ce 59       	subi	r28, 0x9E	; 158
    55e0:	df 4f       	sbci	r29, 0xFF	; 255
    55e2:	cd bf       	out	0x3d, r28	; 61
    55e4:	de bf       	out	0x3e, r29	; 62
    55e6:	df 91       	pop	r29
    55e8:	cf 91       	pop	r28
    55ea:	1f 91       	pop	r17
    55ec:	0f 91       	pop	r16
    55ee:	08 95       	ret

000055f0 <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    55f0:	cf 93       	push	r28
    55f2:	df 93       	push	r29
    55f4:	0f 92       	push	r0
    55f6:	0f 92       	push	r0
    55f8:	cd b7       	in	r28, 0x3d	; 61
    55fa:	de b7       	in	r29, 0x3e	; 62
    55fc:	89 83       	std	Y+1, r24	; 0x01
    55fe:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    5600:	29 81       	ldd	r18, Y+1	; 0x01
    5602:	3a 81       	ldd	r19, Y+2	; 0x02
    5604:	80 e0       	ldi	r24, 0x00	; 0
    5606:	90 e0       	ldi	r25, 0x00	; 0
    5608:	b9 01       	movw	r22, r18
    560a:	48 e0       	ldi	r20, 0x08	; 8
    560c:	50 e0       	ldi	r21, 0x00	; 0
    560e:	0e 94 1b 2f 	call	0x5e36	; 0x5e36 <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    5612:	29 81       	ldd	r18, Y+1	; 0x01
    5614:	3a 81       	ldd	r19, Y+2	; 0x02
    5616:	84 e2       	ldi	r24, 0x24	; 36
    5618:	b9 01       	movw	r22, r18
    561a:	0e 94 9d 23 	call	0x473a	; 0x473a <chb_reg_write64>
}
    561e:	0f 90       	pop	r0
    5620:	0f 90       	pop	r0
    5622:	df 91       	pop	r29
    5624:	cf 91       	pop	r28
    5626:	08 95       	ret

00005628 <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    5628:	cf 93       	push	r28
    562a:	df 93       	push	r29
    562c:	0f 92       	push	r0
    562e:	0f 92       	push	r0
    5630:	cd b7       	in	r28, 0x3d	; 61
    5632:	de b7       	in	r29, 0x3e	; 62
    5634:	89 83       	std	Y+1, r24	; 0x01
    5636:	9a 83       	std	Y+2, r25	; 0x02
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    5638:	29 81       	ldd	r18, Y+1	; 0x01
    563a:	3a 81       	ldd	r19, Y+2	; 0x02
    563c:	80 e0       	ldi	r24, 0x00	; 0
    563e:	90 e0       	ldi	r25, 0x00	; 0
    5640:	b9 01       	movw	r22, r18
    5642:	48 e0       	ldi	r20, 0x08	; 8
    5644:	50 e0       	ldi	r21, 0x00	; 0
    5646:	0e 94 57 2f 	call	0x5eae	; 0x5eae <chb_eeprom_read>
}
    564a:	0f 90       	pop	r0
    564c:	0f 90       	pop	r0
    564e:	df 91       	pop	r29
    5650:	cf 91       	pop	r28
    5652:	08 95       	ret

00005654 <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    5654:	cf 93       	push	r28
    5656:	df 93       	push	r29
    5658:	00 d0       	rcall	.+0      	; 0x565a <chb_set_short_addr+0x6>
    565a:	00 d0       	rcall	.+0      	; 0x565c <chb_set_short_addr+0x8>
    565c:	cd b7       	in	r28, 0x3d	; 61
    565e:	de b7       	in	r29, 0x3e	; 62
    5660:	8d 83       	std	Y+5, r24	; 0x05
    5662:	9e 83       	std	Y+6, r25	; 0x06
    U8 *addr_ptr = (U8 *)&addr;
    5664:	ce 01       	movw	r24, r28
    5666:	05 96       	adiw	r24, 0x05	; 5
    5668:	89 83       	std	Y+1, r24	; 0x01
    566a:	9a 83       	std	Y+2, r25	; 0x02
    pcb_t *pcb = chb_get_pcb();
    566c:	0e 94 d3 1d 	call	0x3ba6	; 0x3ba6 <chb_get_pcb>
    5670:	8b 83       	std	Y+3, r24	; 0x03
    5672:	9c 83       	std	Y+4, r25	; 0x04

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    5674:	29 81       	ldd	r18, Y+1	; 0x01
    5676:	3a 81       	ldd	r19, Y+2	; 0x02
    5678:	89 e0       	ldi	r24, 0x09	; 9
    567a:	90 e0       	ldi	r25, 0x00	; 0
    567c:	b9 01       	movw	r22, r18
    567e:	42 e0       	ldi	r20, 0x02	; 2
    5680:	50 e0       	ldi	r21, 0x00	; 0
    5682:	0e 94 1b 2f 	call	0x5e36	; 0x5e36 <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    5686:	2d 81       	ldd	r18, Y+5	; 0x05
    5688:	3e 81       	ldd	r19, Y+6	; 0x06
    568a:	80 e2       	ldi	r24, 0x20	; 32
    568c:	b9 01       	movw	r22, r18
    568e:	0e 94 6c 23 	call	0x46d8	; 0x46d8 <chb_reg_write16>
    pcb->src_addr = addr;
    5692:	2d 81       	ldd	r18, Y+5	; 0x05
    5694:	3e 81       	ldd	r19, Y+6	; 0x06
    5696:	8b 81       	ldd	r24, Y+3	; 0x03
    5698:	9c 81       	ldd	r25, Y+4	; 0x04
    569a:	fc 01       	movw	r30, r24
    569c:	20 83       	st	Z, r18
    569e:	31 83       	std	Z+1, r19	; 0x01
}
    56a0:	26 96       	adiw	r28, 0x06	; 6
    56a2:	cd bf       	out	0x3d, r28	; 61
    56a4:	de bf       	out	0x3e, r29	; 62
    56a6:	df 91       	pop	r29
    56a8:	cf 91       	pop	r28
    56aa:	08 95       	ret

000056ac <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    56ac:	cf 93       	push	r28
    56ae:	df 93       	push	r29
    56b0:	0f 92       	push	r0
    56b2:	0f 92       	push	r0
    56b4:	cd b7       	in	r28, 0x3d	; 61
    56b6:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    56b8:	89 e0       	ldi	r24, 0x09	; 9
    56ba:	90 e0       	ldi	r25, 0x00	; 0
    56bc:	9e 01       	movw	r18, r28
    56be:	2f 5f       	subi	r18, 0xFF	; 255
    56c0:	3f 4f       	sbci	r19, 0xFF	; 255
    56c2:	b9 01       	movw	r22, r18
    56c4:	42 e0       	ldi	r20, 0x02	; 2
    56c6:	50 e0       	ldi	r21, 0x00	; 0
    56c8:	0e 94 57 2f 	call	0x5eae	; 0x5eae <chb_eeprom_read>
    return *(U16 *)addr;
    56cc:	ce 01       	movw	r24, r28
    56ce:	01 96       	adiw	r24, 0x01	; 1
    56d0:	fc 01       	movw	r30, r24
    56d2:	80 81       	ld	r24, Z
    56d4:	91 81       	ldd	r25, Z+1	; 0x01
}
    56d6:	0f 90       	pop	r0
    56d8:	0f 90       	pop	r0
    56da:	df 91       	pop	r29
    56dc:	cf 91       	pop	r28
    56de:	08 95       	ret

000056e0 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    56e0:	cf 93       	push	r28
    56e2:	df 93       	push	r29
    56e4:	cd b7       	in	r28, 0x3d	; 61
    56e6:	de b7       	in	r29, 0x3e	; 62
    56e8:	28 97       	sbiw	r28, 0x08	; 8
    56ea:	cd bf       	out	0x3d, r28	; 61
    56ec:	de bf       	out	0x3e, r29	; 62
    56ee:	8c 83       	std	Y+4, r24	; 0x04
    56f0:	9d 83       	std	Y+5, r25	; 0x05
    56f2:	6e 83       	std	Y+6, r22	; 0x06
    56f4:	7f 83       	std	Y+7, r23	; 0x07
    56f6:	48 87       	std	Y+8, r20	; 0x08
    U8 state = chb_get_state();
    56f8:	0e 94 dc 20 	call	0x41b8	; 0x41b8 <chb_get_state>
    56fc:	89 83       	std	Y+1, r24	; 0x01
    pcb_t *pcb = chb_get_pcb();
    56fe:	0e 94 d3 1d 	call	0x3ba6	; 0x3ba6 <chb_get_pcb>
    5702:	8a 83       	std	Y+2, r24	; 0x02
    5704:	9b 83       	std	Y+3, r25	; 0x03

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    5706:	89 81       	ldd	r24, Y+1	; 0x01
    5708:	82 30       	cpi	r24, 0x02	; 2
    570a:	19 f0       	breq	.+6      	; 0x5712 <chb_tx+0x32>
    570c:	89 81       	ldd	r24, Y+1	; 0x01
    570e:	82 31       	cpi	r24, 0x12	; 18
    5710:	11 f4       	brne	.+4      	; 0x5716 <chb_tx+0x36>
    {
        return RADIO_WRONG_STATE;
    5712:	84 e4       	ldi	r24, 0x44	; 68
    5714:	23 c0       	rjmp	.+70     	; 0x575c <chb_tx+0x7c>
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    5716:	88 e0       	ldi	r24, 0x08	; 8
    5718:	0e 94 43 26 	call	0x4c86	; 0x4c86 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    571c:	89 e1       	ldi	r24, 0x19	; 25
    571e:	0e 94 43 26 	call	0x4c86	; 0x4c86 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    5722:	8c 81       	ldd	r24, Y+4	; 0x04
    5724:	9d 81       	ldd	r25, Y+5	; 0x05
    5726:	2e 81       	ldd	r18, Y+6	; 0x06
    5728:	3f 81       	ldd	r19, Y+7	; 0x07
    572a:	6a e0       	ldi	r22, 0x0A	; 10
    572c:	a9 01       	movw	r20, r18
    572e:	28 85       	ldd	r18, Y+8	; 0x08
    5730:	0e 94 ea 23 	call	0x47d4	; 0x47d4 <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    5734:	82 e0       	ldi	r24, 0x02	; 2
    5736:	62 e0       	ldi	r22, 0x02	; 2
    5738:	4f e1       	ldi	r20, 0x1F	; 31
    573a:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>

    // wait for the transmission to end, signaled by the TRX END flag
    while (!pcb->tx_end);
    573e:	00 00       	nop
    5740:	8a 81       	ldd	r24, Y+2	; 0x02
    5742:	9b 81       	ldd	r25, Y+3	; 0x03
    5744:	fc 01       	movw	r30, r24
    5746:	94 81       	ldd	r25, Z+4	; 0x04
    5748:	81 e0       	ldi	r24, 0x01	; 1
    574a:	89 27       	eor	r24, r25
    574c:	88 23       	and	r24, r24
    574e:	c1 f7       	brne	.-16     	; 0x5740 <chb_tx+0x60>
    pcb->tx_end = false;
    5750:	8a 81       	ldd	r24, Y+2	; 0x02
    5752:	9b 81       	ldd	r25, Y+3	; 0x03
    5754:	fc 01       	movw	r30, r24
    5756:	14 82       	std	Z+4, r1	; 0x04

    // check the status of the transmission
    return chb_get_status();
    5758:	0e 94 e7 20 	call	0x41ce	; 0x41ce <chb_get_status>
}
    575c:	28 96       	adiw	r28, 0x08	; 8
    575e:	cd bf       	out	0x3d, r28	; 61
    5760:	de bf       	out	0x3e, r29	; 62
    5762:	df 91       	pop	r29
    5764:	cf 91       	pop	r28
    5766:	08 95       	ret

00005768 <chb_sleep>:
/*!
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    5768:	0f 93       	push	r16
    576a:	1f 93       	push	r17
    576c:	cf 93       	push	r28
    576e:	df 93       	push	r29
    5770:	cd b7       	in	r28, 0x3d	; 61
    5772:	de b7       	in	r29, 0x3e	; 62
    5774:	69 97       	sbiw	r28, 0x19	; 25
    5776:	cd bf       	out	0x3d, r28	; 61
    5778:	de bf       	out	0x3e, r29	; 62
    577a:	89 8f       	std	Y+25, r24	; 0x19
    if (enb)
    577c:	89 8d       	ldd	r24, Y+25	; 0x19
    577e:	88 23       	and	r24, r24
    5780:	69 f0       	breq	.+26     	; 0x579c <chb_sleep+0x34>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    5782:	88 e0       	ldi	r24, 0x08	; 8
    5784:	0e 94 43 26 	call	0x4c86	; 0x4c86 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    5788:	84 e6       	ldi	r24, 0x64	; 100
    578a:	96 e0       	ldi	r25, 0x06	; 6
    578c:	24 e6       	ldi	r18, 0x64	; 100
    578e:	36 e0       	ldi	r19, 0x06	; 6
    5790:	f9 01       	movw	r30, r18
    5792:	20 81       	ld	r18, Z
    5794:	22 60       	ori	r18, 0x02	; 2
    5796:	fc 01       	movw	r30, r24
    5798:	20 83       	st	Z, r18
    579a:	e1 c0       	rjmp	.+450    	; 0x595e <chb_sleep+0x1f6>
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    579c:	84 e6       	ldi	r24, 0x64	; 100
    579e:	96 e0       	ldi	r25, 0x06	; 6
    57a0:	24 e6       	ldi	r18, 0x64	; 100
    57a2:	36 e0       	ldi	r19, 0x06	; 6
    57a4:	f9 01       	movw	r30, r18
    57a6:	20 81       	ld	r18, Z
    57a8:	2d 7f       	andi	r18, 0xFD	; 253
    57aa:	fc 01       	movw	r30, r24
    57ac:	20 83       	st	Z, r18
    57ae:	80 e0       	ldi	r24, 0x00	; 0
    57b0:	90 e0       	ldi	r25, 0x00	; 0
    57b2:	a0 e7       	ldi	r26, 0x70	; 112
    57b4:	b3 e4       	ldi	r27, 0x43	; 67
    57b6:	89 83       	std	Y+1, r24	; 0x01
    57b8:	9a 83       	std	Y+2, r25	; 0x02
    57ba:	ab 83       	std	Y+3, r26	; 0x03
    57bc:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    57be:	69 81       	ldd	r22, Y+1	; 0x01
    57c0:	7a 81       	ldd	r23, Y+2	; 0x02
    57c2:	8b 81       	ldd	r24, Y+3	; 0x03
    57c4:	9c 81       	ldd	r25, Y+4	; 0x04
    57c6:	2b ea       	ldi	r18, 0xAB	; 171
    57c8:	3a ea       	ldi	r19, 0xAA	; 170
    57ca:	4a ea       	ldi	r20, 0xAA	; 170
    57cc:	5e e3       	ldi	r21, 0x3E	; 62
    57ce:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    57d2:	dc 01       	movw	r26, r24
    57d4:	cb 01       	movw	r24, r22
    57d6:	8d 83       	std	Y+5, r24	; 0x05
    57d8:	9e 83       	std	Y+6, r25	; 0x06
    57da:	af 83       	std	Y+7, r26	; 0x07
    57dc:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    57de:	11 e0       	ldi	r17, 0x01	; 1
    57e0:	6d 81       	ldd	r22, Y+5	; 0x05
    57e2:	7e 81       	ldd	r23, Y+6	; 0x06
    57e4:	8f 81       	ldd	r24, Y+7	; 0x07
    57e6:	98 85       	ldd	r25, Y+8	; 0x08
    57e8:	20 e0       	ldi	r18, 0x00	; 0
    57ea:	30 e0       	ldi	r19, 0x00	; 0
    57ec:	40 e8       	ldi	r20, 0x80	; 128
    57ee:	5f e3       	ldi	r21, 0x3F	; 63
    57f0:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    57f4:	88 23       	and	r24, r24
    57f6:	0c f0       	brlt	.+2      	; 0x57fa <chb_sleep+0x92>
    57f8:	10 e0       	ldi	r17, 0x00	; 0
    57fa:	11 23       	and	r17, r17
    57fc:	19 f0       	breq	.+6      	; 0x5804 <chb_sleep+0x9c>
		__ticks = 1;
    57fe:	81 e0       	ldi	r24, 0x01	; 1
    5800:	89 87       	std	Y+9, r24	; 0x09
    5802:	a3 c0       	rjmp	.+326    	; 0x594a <chb_sleep+0x1e2>
	else if (__tmp > 255)
    5804:	11 e0       	ldi	r17, 0x01	; 1
    5806:	6d 81       	ldd	r22, Y+5	; 0x05
    5808:	7e 81       	ldd	r23, Y+6	; 0x06
    580a:	8f 81       	ldd	r24, Y+7	; 0x07
    580c:	98 85       	ldd	r25, Y+8	; 0x08
    580e:	20 e0       	ldi	r18, 0x00	; 0
    5810:	30 e0       	ldi	r19, 0x00	; 0
    5812:	4f e7       	ldi	r20, 0x7F	; 127
    5814:	53 e4       	ldi	r21, 0x43	; 67
    5816:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    581a:	18 16       	cp	r1, r24
    581c:	0c f0       	brlt	.+2      	; 0x5820 <chb_sleep+0xb8>
    581e:	10 e0       	ldi	r17, 0x00	; 0
    5820:	11 23       	and	r17, r17
    5822:	09 f4       	brne	.+2      	; 0x5826 <chb_sleep+0xbe>
    5824:	89 c0       	rjmp	.+274    	; 0x5938 <chb_sleep+0x1d0>
	{
		_delay_ms(__us / 1000.0);
    5826:	69 81       	ldd	r22, Y+1	; 0x01
    5828:	7a 81       	ldd	r23, Y+2	; 0x02
    582a:	8b 81       	ldd	r24, Y+3	; 0x03
    582c:	9c 81       	ldd	r25, Y+4	; 0x04
    582e:	20 e0       	ldi	r18, 0x00	; 0
    5830:	30 e0       	ldi	r19, 0x00	; 0
    5832:	4a e7       	ldi	r20, 0x7A	; 122
    5834:	54 e4       	ldi	r21, 0x44	; 68
    5836:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
    583a:	dc 01       	movw	r26, r24
    583c:	cb 01       	movw	r24, r22
    583e:	8a 87       	std	Y+10, r24	; 0x0a
    5840:	9b 87       	std	Y+11, r25	; 0x0b
    5842:	ac 87       	std	Y+12, r26	; 0x0c
    5844:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    5846:	6a 85       	ldd	r22, Y+10	; 0x0a
    5848:	7b 85       	ldd	r23, Y+11	; 0x0b
    584a:	8c 85       	ldd	r24, Y+12	; 0x0c
    584c:	9d 85       	ldd	r25, Y+13	; 0x0d
    584e:	20 e0       	ldi	r18, 0x00	; 0
    5850:	30 e0       	ldi	r19, 0x00	; 0
    5852:	4a e7       	ldi	r20, 0x7A	; 122
    5854:	53 e4       	ldi	r21, 0x43	; 67
    5856:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    585a:	dc 01       	movw	r26, r24
    585c:	cb 01       	movw	r24, r22
    585e:	8e 87       	std	Y+14, r24	; 0x0e
    5860:	9f 87       	std	Y+15, r25	; 0x0f
    5862:	a8 8b       	std	Y+16, r26	; 0x10
    5864:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    5866:	11 e0       	ldi	r17, 0x01	; 1
    5868:	6e 85       	ldd	r22, Y+14	; 0x0e
    586a:	7f 85       	ldd	r23, Y+15	; 0x0f
    586c:	88 89       	ldd	r24, Y+16	; 0x10
    586e:	99 89       	ldd	r25, Y+17	; 0x11
    5870:	20 e0       	ldi	r18, 0x00	; 0
    5872:	30 e0       	ldi	r19, 0x00	; 0
    5874:	40 e8       	ldi	r20, 0x80	; 128
    5876:	5f e3       	ldi	r21, 0x3F	; 63
    5878:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    587c:	88 23       	and	r24, r24
    587e:	0c f0       	brlt	.+2      	; 0x5882 <chb_sleep+0x11a>
    5880:	10 e0       	ldi	r17, 0x00	; 0
    5882:	11 23       	and	r17, r17
    5884:	29 f0       	breq	.+10     	; 0x5890 <chb_sleep+0x128>
		__ticks = 1;
    5886:	81 e0       	ldi	r24, 0x01	; 1
    5888:	90 e0       	ldi	r25, 0x00	; 0
    588a:	8a 8b       	std	Y+18, r24	; 0x12
    588c:	9b 8b       	std	Y+19, r25	; 0x13
    588e:	46 c0       	rjmp	.+140    	; 0x591c <chb_sleep+0x1b4>
	else if (__tmp > 65535)
    5890:	11 e0       	ldi	r17, 0x01	; 1
    5892:	6e 85       	ldd	r22, Y+14	; 0x0e
    5894:	7f 85       	ldd	r23, Y+15	; 0x0f
    5896:	88 89       	ldd	r24, Y+16	; 0x10
    5898:	99 89       	ldd	r25, Y+17	; 0x11
    589a:	20 e0       	ldi	r18, 0x00	; 0
    589c:	3f ef       	ldi	r19, 0xFF	; 255
    589e:	4f e7       	ldi	r20, 0x7F	; 127
    58a0:	57 e4       	ldi	r21, 0x47	; 71
    58a2:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    58a6:	18 16       	cp	r1, r24
    58a8:	0c f0       	brlt	.+2      	; 0x58ac <chb_sleep+0x144>
    58aa:	10 e0       	ldi	r17, 0x00	; 0
    58ac:	11 23       	and	r17, r17
    58ae:	61 f1       	breq	.+88     	; 0x5908 <chb_sleep+0x1a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    58b0:	6a 85       	ldd	r22, Y+10	; 0x0a
    58b2:	7b 85       	ldd	r23, Y+11	; 0x0b
    58b4:	8c 85       	ldd	r24, Y+12	; 0x0c
    58b6:	9d 85       	ldd	r25, Y+13	; 0x0d
    58b8:	20 e0       	ldi	r18, 0x00	; 0
    58ba:	30 e0       	ldi	r19, 0x00	; 0
    58bc:	40 e2       	ldi	r20, 0x20	; 32
    58be:	51 e4       	ldi	r21, 0x41	; 65
    58c0:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    58c4:	dc 01       	movw	r26, r24
    58c6:	cb 01       	movw	r24, r22
    58c8:	bc 01       	movw	r22, r24
    58ca:	cd 01       	movw	r24, r26
    58cc:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    58d0:	dc 01       	movw	r26, r24
    58d2:	cb 01       	movw	r24, r22
    58d4:	8a 8b       	std	Y+18, r24	; 0x12
    58d6:	9b 8b       	std	Y+19, r25	; 0x13
    58d8:	12 c0       	rjmp	.+36     	; 0x58fe <chb_sleep+0x196>
    58da:	89 e1       	ldi	r24, 0x19	; 25
    58dc:	90 e0       	ldi	r25, 0x00	; 0
    58de:	8c 8b       	std	Y+20, r24	; 0x14
    58e0:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    58e2:	8c 89       	ldd	r24, Y+20	; 0x14
    58e4:	9d 89       	ldd	r25, Y+21	; 0x15
    58e6:	8c 01       	movw	r16, r24
    58e8:	c8 01       	movw	r24, r16
    58ea:	01 97       	sbiw	r24, 0x01	; 1
    58ec:	f1 f7       	brne	.-4      	; 0x58ea <chb_sleep+0x182>
    58ee:	8c 01       	movw	r16, r24
    58f0:	0c 8b       	std	Y+20, r16	; 0x14
    58f2:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    58f4:	8a 89       	ldd	r24, Y+18	; 0x12
    58f6:	9b 89       	ldd	r25, Y+19	; 0x13
    58f8:	01 97       	sbiw	r24, 0x01	; 1
    58fa:	8a 8b       	std	Y+18, r24	; 0x12
    58fc:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    58fe:	8a 89       	ldd	r24, Y+18	; 0x12
    5900:	9b 89       	ldd	r25, Y+19	; 0x13
    5902:	00 97       	sbiw	r24, 0x00	; 0
    5904:	51 f7       	brne	.-44     	; 0x58da <chb_sleep+0x172>
    5906:	28 c0       	rjmp	.+80     	; 0x5958 <chb_sleep+0x1f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5908:	6e 85       	ldd	r22, Y+14	; 0x0e
    590a:	7f 85       	ldd	r23, Y+15	; 0x0f
    590c:	88 89       	ldd	r24, Y+16	; 0x10
    590e:	99 89       	ldd	r25, Y+17	; 0x11
    5910:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    5914:	dc 01       	movw	r26, r24
    5916:	cb 01       	movw	r24, r22
    5918:	8a 8b       	std	Y+18, r24	; 0x12
    591a:	9b 8b       	std	Y+19, r25	; 0x13
    591c:	8a 89       	ldd	r24, Y+18	; 0x12
    591e:	9b 89       	ldd	r25, Y+19	; 0x13
    5920:	8e 8b       	std	Y+22, r24	; 0x16
    5922:	9f 8b       	std	Y+23, r25	; 0x17
    5924:	8e 89       	ldd	r24, Y+22	; 0x16
    5926:	9f 89       	ldd	r25, Y+23	; 0x17
    5928:	8c 01       	movw	r16, r24
    592a:	f8 01       	movw	r30, r16
    592c:	31 97       	sbiw	r30, 0x01	; 1
    592e:	f1 f7       	brne	.-4      	; 0x592c <chb_sleep+0x1c4>
    5930:	8f 01       	movw	r16, r30
    5932:	0e 8b       	std	Y+22, r16	; 0x16
    5934:	1f 8b       	std	Y+23, r17	; 0x17
    5936:	10 c0       	rjmp	.+32     	; 0x5958 <chb_sleep+0x1f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    5938:	6d 81       	ldd	r22, Y+5	; 0x05
    593a:	7e 81       	ldd	r23, Y+6	; 0x06
    593c:	8f 81       	ldd	r24, Y+7	; 0x07
    593e:	98 85       	ldd	r25, Y+8	; 0x08
    5940:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    5944:	dc 01       	movw	r26, r24
    5946:	cb 01       	movw	r24, r22
    5948:	89 87       	std	Y+9, r24	; 0x09
    594a:	89 85       	ldd	r24, Y+9	; 0x09
    594c:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    594e:	88 8d       	ldd	r24, Y+24	; 0x18
    5950:	18 2f       	mov	r17, r24
    5952:	1a 95       	dec	r17
    5954:	f1 f7       	brne	.-4      	; 0x5952 <chb_sleep+0x1ea>
    5956:	18 8f       	std	Y+24, r17	; 0x18

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    5958:	86 e1       	ldi	r24, 0x16	; 22
    595a:	0e 94 43 26 	call	0x4c86	; 0x4c86 <chb_set_state>
    }
}
    595e:	69 96       	adiw	r28, 0x19	; 25
    5960:	cd bf       	out	0x3d, r28	; 61
    5962:	de bf       	out	0x3e, r29	; 62
    5964:	df 91       	pop	r29
    5966:	cf 91       	pop	r28
    5968:	1f 91       	pop	r17
    596a:	0f 91       	pop	r16
    596c:	08 95       	ret

0000596e <chb_radio_init>:
/*!

*/
/**************************************************************************/
static void chb_radio_init()
{
    596e:	cf 93       	push	r28
    5970:	df 93       	push	r29
    5972:	cd b7       	in	r28, 0x3d	; 61
    5974:	de b7       	in	r29, 0x3e	; 62
    5976:	ea 97       	sbiw	r28, 0x3a	; 58
    5978:	cd bf       	out	0x3d, r28	; 61
    597a:	de bf       	out	0x3e, r29	; 62
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    597c:	0e 94 f4 20 	call	0x41e8	; 0x41e8 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    5980:	8e e0       	ldi	r24, 0x0E	; 14
    5982:	60 e0       	ldi	r22, 0x00	; 0
    5984:	0e 94 40 23 	call	0x4680	; 0x4680 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    5988:	82 e0       	ldi	r24, 0x02	; 2
    598a:	63 e0       	ldi	r22, 0x03	; 3
    598c:	4f e1       	ldi	r20, 0x1F	; 31
    598e:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    5992:	00 00       	nop
    5994:	81 e0       	ldi	r24, 0x01	; 1
    5996:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <chb_reg_read>
    599a:	88 2f       	mov	r24, r24
    599c:	90 e0       	ldi	r25, 0x00	; 0
    599e:	8f 71       	andi	r24, 0x1F	; 31
    59a0:	90 70       	andi	r25, 0x00	; 0
    59a2:	88 30       	cpi	r24, 0x08	; 8
    59a4:	91 05       	cpc	r25, r1
    59a6:	b1 f7       	brne	.-20     	; 0x5994 <chb_radio_init+0x26>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    59a8:	8e e2       	ldi	r24, 0x2E	; 46
    59aa:	60 e4       	ldi	r22, 0x40	; 64
    59ac:	40 ec       	ldi	r20, 0xC0	; 192
    59ae:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    59b2:	8e e0       	ldi	r24, 0x0E	; 14
    59b4:	6c e0       	ldi	r22, 0x0C	; 12
    59b6:	0e 94 40 23 	call	0x4680	; 0x4680 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    59ba:	84 e0       	ldi	r24, 0x04	; 4
    59bc:	60 e2       	ldi	r22, 0x20	; 32
    59be:	40 e2       	ldi	r20, 0x20	; 32
    59c0:	0e 94 c5 23 	call	0x478a	; 0x478a <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    59c4:	81 e0       	ldi	r24, 0x01	; 1
    59c6:	0e 94 e5 24 	call	0x49ca	; 0x49ca <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    59ca:	81 e0       	ldi	r24, 0x01	; 1
    59cc:	0e 94 2e 25 	call	0x4a5c	; 0x4a5c <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    59d0:	86 e1       	ldi	r24, 0x16	; 22
    59d2:	0e 94 43 26 	call	0x4c86	; 0x4c86 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    59d6:	82 e2       	ldi	r24, 0x22	; 34
    59d8:	64 e3       	ldi	r22, 0x34	; 52
    59da:	72 e1       	ldi	r23, 0x12	; 18
    59dc:	0e 94 6c 23 	call	0x46d8	; 0x46d8 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    59e0:	0e 94 56 2b 	call	0x56ac	; 0x56ac <chb_get_short_addr>
    59e4:	9c 01       	movw	r18, r24
    59e6:	80 e2       	ldi	r24, 0x20	; 32
    59e8:	b9 01       	movw	r22, r18
    59ea:	0e 94 6c 23 	call	0x46d8	; 0x46d8 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    59ee:	ce 01       	movw	r24, r28
    59f0:	01 96       	adiw	r24, 0x01	; 1
    59f2:	0e 94 14 2b 	call	0x5628	; 0x5628 <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    59f6:	84 e2       	ldi	r24, 0x24	; 36
    59f8:	9e 01       	movw	r18, r28
    59fa:	2f 5f       	subi	r18, 0xFF	; 255
    59fc:	3f 4f       	sbci	r19, 0xFF	; 255
    59fe:	b9 01       	movw	r22, r18
    5a00:	0e 94 9d 23 	call	0x473a	; 0x473a <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    5a04:	82 e7       	ldi	r24, 0x72	; 114
    5a06:	96 e0       	ldi	r25, 0x06	; 6
    5a08:	22 e7       	ldi	r18, 0x72	; 114
    5a0a:	36 e0       	ldi	r19, 0x06	; 6
    5a0c:	f9 01       	movw	r30, r18
    5a0e:	20 81       	ld	r18, Z
    5a10:	21 60       	ori	r18, 0x01	; 1
    5a12:	fc 01       	movw	r30, r24
    5a14:	20 83       	st	Z, r18
    5a16:	89 e6       	ldi	r24, 0x69	; 105
    5a18:	96 e0       	ldi	r25, 0x06	; 6
    5a1a:	29 e6       	ldi	r18, 0x69	; 105
    5a1c:	36 e0       	ldi	r19, 0x06	; 6
    5a1e:	f9 01       	movw	r30, r18
    5a20:	20 81       	ld	r18, Z
    5a22:	23 60       	ori	r18, 0x03	; 3
    5a24:	fc 01       	movw	r30, r24
    5a26:	20 83       	st	Z, r18
    5a28:	8a e6       	ldi	r24, 0x6A	; 106
    5a2a:	96 e0       	ldi	r25, 0x06	; 6
    5a2c:	2a e6       	ldi	r18, 0x6A	; 106
    5a2e:	36 e0       	ldi	r19, 0x06	; 6
    5a30:	f9 01       	movw	r30, r18
    5a32:	20 81       	ld	r18, Z
    5a34:	24 60       	ori	r18, 0x04	; 4
    5a36:	fc 01       	movw	r30, r24
    5a38:	20 83       	st	Z, r18
	PMIC.CTRL |= 0x07;	//enable interrupts on MCU
    5a3a:	80 ea       	ldi	r24, 0xA0	; 160
    5a3c:	90 e0       	ldi	r25, 0x00	; 0
    5a3e:	20 ea       	ldi	r18, 0xA0	; 160
    5a40:	30 e0       	ldi	r19, 0x00	; 0
    5a42:	f9 01       	movw	r30, r18
    5a44:	22 81       	ldd	r18, Z+2	; 0x02
    5a46:	27 60       	ori	r18, 0x07	; 7
    5a48:	fc 01       	movw	r30, r24
    5a4a:	22 83       	std	Z+2, r18	; 0x02

    if (chb_get_state() != RX_STATE)
    5a4c:	0e 94 dc 20 	call	0x41b8	; 0x41b8 <chb_get_state>
    5a50:	86 31       	cpi	r24, 0x16	; 22
    5a52:	b1 f0       	breq	.+44     	; 0x5a80 <chb_radio_init+0x112>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    5a54:	ce 01       	movw	r24, r28
    5a56:	09 96       	adiw	r24, 0x09	; 9
    5a58:	2c e0       	ldi	r18, 0x0C	; 12
    5a5a:	32 e0       	ldi	r19, 0x02	; 2
    5a5c:	b9 01       	movw	r22, r18
    5a5e:	0e 94 47 5c 	call	0xb88e	; 0xb88e <strcpy_P>
        printf(buf);
    5a62:	0f 92       	push	r0
    5a64:	0f 92       	push	r0
    5a66:	8d b7       	in	r24, 0x3d	; 61
    5a68:	9e b7       	in	r25, 0x3e	; 62
    5a6a:	01 96       	adiw	r24, 0x01	; 1
    5a6c:	9e 01       	movw	r18, r28
    5a6e:	27 5f       	subi	r18, 0xF7	; 247
    5a70:	3f 4f       	sbci	r19, 0xFF	; 255
    5a72:	fc 01       	movw	r30, r24
    5a74:	20 83       	st	Z, r18
    5a76:	31 83       	std	Z+1, r19	; 0x01
    5a78:	0e 94 a3 5c 	call	0xb946	; 0xb946 <printf>
    5a7c:	0f 90       	pop	r0
    5a7e:	0f 90       	pop	r0
    }
	StartOfFreeSpace = 0; //set location in FRAM Buffer at which to start storing radio messages to the start of the buffer
    5a80:	10 92 cb 50 	sts	0x50CB, r1
    5a84:	10 92 cc 50 	sts	0x50CC, r1
    5a88:	10 92 cd 50 	sts	0x50CD, r1
    5a8c:	10 92 ce 50 	sts	0x50CE, r1
}
    5a90:	ea 96       	adiw	r28, 0x3a	; 58
    5a92:	cd bf       	out	0x3d, r28	; 61
    5a94:	de bf       	out	0x3e, r29	; 62
    5a96:	df 91       	pop	r29
    5a98:	cf 91       	pop	r28
    5a9a:	08 95       	ret

00005a9c <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    5a9c:	cf 93       	push	r28
    5a9e:	df 93       	push	r29
    5aa0:	cd b7       	in	r28, 0x3d	; 61
    5aa2:	de b7       	in	r29, 0x3e	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    5aa4:	0e 94 97 2f 	call	0x5f2e	; 0x5f2e <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    5aa8:	80 e6       	ldi	r24, 0x60	; 96
    5aaa:	96 e0       	ldi	r25, 0x06	; 6
    5aac:	20 e6       	ldi	r18, 0x60	; 96
    5aae:	36 e0       	ldi	r19, 0x06	; 6
    5ab0:	f9 01       	movw	r30, r18
    5ab2:	20 81       	ld	r18, Z
    5ab4:	22 60       	ori	r18, 0x02	; 2
    5ab6:	fc 01       	movw	r30, r24
    5ab8:	20 83       	st	Z, r18
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    5aba:	80 e6       	ldi	r24, 0x60	; 96
    5abc:	96 e0       	ldi	r25, 0x06	; 6
    5abe:	20 e6       	ldi	r18, 0x60	; 96
    5ac0:	36 e0       	ldi	r19, 0x06	; 6
    5ac2:	f9 01       	movw	r30, r18
    5ac4:	20 81       	ld	r18, Z
    5ac6:	21 60       	ori	r18, 0x01	; 1
    5ac8:	fc 01       	movw	r30, r24
    5aca:	20 83       	st	Z, r18

    // config radio
    chb_radio_init();
    5acc:	0e 94 b7 2c 	call	0x596e	; 0x596e <chb_radio_init>
}
    5ad0:	df 91       	pop	r29
    5ad2:	cf 91       	pop	r28
    5ad4:	08 95       	ret

00005ad6 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    5ad6:	1f 92       	push	r1
    5ad8:	0f 92       	push	r0
    5ada:	0f b6       	in	r0, 0x3f	; 63
    5adc:	0f 92       	push	r0
    5ade:	00 90 3b 00 	lds	r0, 0x003B
    5ae2:	0f 92       	push	r0
    5ae4:	11 24       	eor	r1, r1
    5ae6:	2f 93       	push	r18
    5ae8:	3f 93       	push	r19
    5aea:	4f 93       	push	r20
    5aec:	5f 93       	push	r21
    5aee:	6f 93       	push	r22
    5af0:	7f 93       	push	r23
    5af2:	8f 93       	push	r24
    5af4:	9f 93       	push	r25
    5af6:	af 93       	push	r26
    5af8:	bf 93       	push	r27
    5afa:	ef 93       	push	r30
    5afc:	ff 93       	push	r31
    5afe:	cf 93       	push	r28
    5b00:	df 93       	push	r29
    5b02:	cd b7       	in	r28, 0x3d	; 61
    5b04:	de b7       	in	r29, 0x3e	; 62
    5b06:	25 97       	sbiw	r28, 0x05	; 5
    5b08:	cd bf       	out	0x3d, r28	; 61
    5b0a:	de bf       	out	0x3e, r29	; 62
    U8 dummy, state, intp_src = 0;
    5b0c:	19 82       	std	Y+1, r1	; 0x01
    pcb_t *pcb = chb_get_pcb();
    5b0e:	0e 94 d3 1d 	call	0x3ba6	; 0x3ba6 <chb_get_pcb>
    5b12:	8a 83       	std	Y+2, r24	; 0x02
    5b14:	9b 83       	std	Y+3, r25	; 0x03

    CHB_ENTER_CRIT();
    5b16:	8f e3       	ldi	r24, 0x3F	; 63
    5b18:	90 e0       	ldi	r25, 0x00	; 0
    5b1a:	fc 01       	movw	r30, r24
    5b1c:	80 81       	ld	r24, Z
    5b1e:	80 93 4f 40 	sts	0x404F, r24
    5b22:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    5b24:	81 e0       	ldi	r24, 0x01	; 1
    5b26:	0e 94 65 2e 	call	0x5cca	; 0x5cca <RadioCS>

    /*Send Register address and read register content.*/
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    5b2a:	8f e8       	ldi	r24, 0x8F	; 143
    5b2c:	0e 94 c2 2f 	call	0x5f84	; 0x5f84 <SPID_write>
    5b30:	8c 83       	std	Y+4, r24	; 0x04
    intp_src = SPID_write(0);
    5b32:	80 e0       	ldi	r24, 0x00	; 0
    5b34:	0e 94 c2 2f 	call	0x5f84	; 0x5f84 <SPID_write>
    5b38:	89 83       	std	Y+1, r24	; 0x01

    RadioCS(FALSE);
    5b3a:	80 e0       	ldi	r24, 0x00	; 0
    5b3c:	0e 94 65 2e 	call	0x5cca	; 0x5cca <RadioCS>

    while (intp_src)
    5b40:	9d c0       	rjmp	.+314    	; 0x5c7c <__vector_64+0x1a6>
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    5b42:	89 81       	ldd	r24, Y+1	; 0x01
    5b44:	88 2f       	mov	r24, r24
    5b46:	90 e0       	ldi	r25, 0x00	; 0
    5b48:	84 70       	andi	r24, 0x04	; 4
    5b4a:	90 70       	andi	r25, 0x00	; 0
    5b4c:	00 97       	sbiw	r24, 0x00	; 0
    5b4e:	21 f0       	breq	.+8      	; 0x5b58 <__vector_64+0x82>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    5b50:	89 81       	ldd	r24, Y+1	; 0x01
    5b52:	8b 7f       	andi	r24, 0xFB	; 251
    5b54:	89 83       	std	Y+1, r24	; 0x01
    5b56:	92 c0       	rjmp	.+292    	; 0x5c7c <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    5b58:	89 81       	ldd	r24, Y+1	; 0x01
    5b5a:	88 2f       	mov	r24, r24
    5b5c:	90 e0       	ldi	r25, 0x00	; 0
    5b5e:	88 70       	andi	r24, 0x08	; 8
    5b60:	90 70       	andi	r25, 0x00	; 0
    5b62:	00 97       	sbiw	r24, 0x00	; 0
    5b64:	09 f4       	brne	.+2      	; 0x5b68 <__vector_64+0x92>
    5b66:	4c c0       	rjmp	.+152    	; 0x5c00 <__vector_64+0x12a>
        {
            state = chb_get_state();
    5b68:	0e 94 dc 20 	call	0x41b8	; 0x41b8 <chb_get_state>
    5b6c:	8d 83       	std	Y+5, r24	; 0x05

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    5b6e:	8d 81       	ldd	r24, Y+5	; 0x05
    5b70:	86 30       	cpi	r24, 0x06	; 6
    5b72:	31 f0       	breq	.+12     	; 0x5b80 <__vector_64+0xaa>
    5b74:	8d 81       	ldd	r24, Y+5	; 0x05
    5b76:	86 31       	cpi	r24, 0x16	; 22
    5b78:	19 f0       	breq	.+6      	; 0x5b80 <__vector_64+0xaa>
    5b7a:	8d 81       	ldd	r24, Y+5	; 0x05
    5b7c:	81 31       	cpi	r24, 0x11	; 17
    5b7e:	89 f5       	brne	.+98     	; 0x5be2 <__vector_64+0x10c>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    5b80:	88 e0       	ldi	r24, 0x08	; 8
    5b82:	0e 94 43 26 	call	0x4c86	; 0x4c86 <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    5b86:	87 e0       	ldi	r24, 0x07	; 7
    5b88:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <chb_reg_read>
    5b8c:	28 2f       	mov	r18, r24
    5b8e:	8a 81       	ldd	r24, Y+2	; 0x02
    5b90:	9b 81       	ldd	r25, Y+3	; 0x03
    5b92:	fc 01       	movw	r30, r24
    5b94:	22 8b       	std	Z+18, r18	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    5b96:	86 e0       	ldi	r24, 0x06	; 6
    5b98:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <chb_reg_read>
    5b9c:	28 2f       	mov	r18, r24
    5b9e:	22 1f       	adc	r18, r18
    5ba0:	22 27       	eor	r18, r18
    5ba2:	22 1f       	adc	r18, r18
    5ba4:	8a 81       	ldd	r24, Y+2	; 0x02
    5ba6:	9b 81       	ldd	r25, Y+3	; 0x03
    5ba8:	fc 01       	movw	r30, r24
    5baa:	23 8b       	std	Z+19, r18	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5bac:	8a 81       	ldd	r24, Y+2	; 0x02
    5bae:	9b 81       	ldd	r25, Y+3	; 0x03
    5bb0:	fc 01       	movw	r30, r24
    5bb2:	83 89       	ldd	r24, Z+19	; 0x13
    5bb4:	88 23       	and	r24, r24
    5bb6:	d1 f0       	breq	.+52     	; 0x5bec <__vector_64+0x116>
                    // get the data
                    chb_frame_read();
    5bb8:	0e 94 4f 24 	call	0x489e	; 0x489e <chb_frame_read>
                    pcb->rcvd_xfers++;
    5bbc:	8a 81       	ldd	r24, Y+2	; 0x02
    5bbe:	9b 81       	ldd	r25, Y+3	; 0x03
    5bc0:	fc 01       	movw	r30, r24
    5bc2:	85 81       	ldd	r24, Z+5	; 0x05
    5bc4:	96 81       	ldd	r25, Z+6	; 0x06
    5bc6:	9c 01       	movw	r18, r24
    5bc8:	2f 5f       	subi	r18, 0xFF	; 255
    5bca:	3f 4f       	sbci	r19, 0xFF	; 255
    5bcc:	8a 81       	ldd	r24, Y+2	; 0x02
    5bce:	9b 81       	ldd	r25, Y+3	; 0x03
    5bd0:	fc 01       	movw	r30, r24
    5bd2:	25 83       	std	Z+5, r18	; 0x05
    5bd4:	36 83       	std	Z+6, r19	; 0x06
                    pcb->data_rcv = true;
    5bd6:	8a 81       	ldd	r24, Y+2	; 0x02
    5bd8:	9b 81       	ldd	r25, Y+3	; 0x03
    5bda:	21 e0       	ldi	r18, 0x01	; 1
    5bdc:	fc 01       	movw	r30, r24
    5bde:	23 83       	std	Z+3, r18	; 0x03

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    5be0:	05 c0       	rjmp	.+10     	; 0x5bec <__vector_64+0x116>
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
					*/			
                }
            }
            else{
                pcb->tx_end = true;
    5be2:	8a 81       	ldd	r24, Y+2	; 0x02
    5be4:	9b 81       	ldd	r25, Y+3	; 0x03
    5be6:	21 e0       	ldi	r18, 0x01	; 1
    5be8:	fc 01       	movw	r30, r24
    5bea:	24 83       	std	Z+4, r18	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    5bec:	89 81       	ldd	r24, Y+1	; 0x01
    5bee:	87 7f       	andi	r24, 0xF7	; 247
    5bf0:	89 83       	std	Y+1, r24	; 0x01
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    5bf2:	00 00       	nop
    5bf4:	86 e1       	ldi	r24, 0x16	; 22
    5bf6:	0e 94 43 26 	call	0x4c86	; 0x4c86 <chb_set_state>
    5bfa:	80 34       	cpi	r24, 0x40	; 64
    5bfc:	d9 f7       	brne	.-10     	; 0x5bf4 <__vector_64+0x11e>
    5bfe:	3e c0       	rjmp	.+124    	; 0x5c7c <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    5c00:	89 81       	ldd	r24, Y+1	; 0x01
    5c02:	88 2f       	mov	r24, r24
    5c04:	90 e0       	ldi	r25, 0x00	; 0
    5c06:	80 74       	andi	r24, 0x40	; 64
    5c08:	90 70       	andi	r25, 0x00	; 0
    5c0a:	00 97       	sbiw	r24, 0x00	; 0
    5c0c:	89 f0       	breq	.+34     	; 0x5c30 <__vector_64+0x15a>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    5c0e:	89 81       	ldd	r24, Y+1	; 0x01
    5c10:	8f 7b       	andi	r24, 0xBF	; 191
    5c12:	89 83       	std	Y+1, r24	; 0x01
            pcb->underrun++;
    5c14:	8a 81       	ldd	r24, Y+2	; 0x02
    5c16:	9b 81       	ldd	r25, Y+3	; 0x03
    5c18:	fc 01       	movw	r30, r24
    5c1a:	87 85       	ldd	r24, Z+15	; 0x0f
    5c1c:	90 89       	ldd	r25, Z+16	; 0x10
    5c1e:	9c 01       	movw	r18, r24
    5c20:	2f 5f       	subi	r18, 0xFF	; 255
    5c22:	3f 4f       	sbci	r19, 0xFF	; 255
    5c24:	8a 81       	ldd	r24, Y+2	; 0x02
    5c26:	9b 81       	ldd	r25, Y+3	; 0x03
    5c28:	fc 01       	movw	r30, r24
    5c2a:	27 87       	std	Z+15, r18	; 0x0f
    5c2c:	30 8b       	std	Z+16, r19	; 0x10
    5c2e:	26 c0       	rjmp	.+76     	; 0x5c7c <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    5c30:	89 81       	ldd	r24, Y+1	; 0x01
    5c32:	88 2f       	mov	r24, r24
    5c34:	90 e0       	ldi	r25, 0x00	; 0
    5c36:	82 70       	andi	r24, 0x02	; 2
    5c38:	90 70       	andi	r25, 0x00	; 0
    5c3a:	00 97       	sbiw	r24, 0x00	; 0
    5c3c:	21 f0       	breq	.+8      	; 0x5c46 <__vector_64+0x170>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    5c3e:	89 81       	ldd	r24, Y+1	; 0x01
    5c40:	8d 7f       	andi	r24, 0xFD	; 253
    5c42:	89 83       	std	Y+1, r24	; 0x01
    5c44:	1b c0       	rjmp	.+54     	; 0x5c7c <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    5c46:	89 81       	ldd	r24, Y+1	; 0x01
    5c48:	88 2f       	mov	r24, r24
    5c4a:	90 e0       	ldi	r25, 0x00	; 0
    5c4c:	81 70       	andi	r24, 0x01	; 1
    5c4e:	90 70       	andi	r25, 0x00	; 0
    5c50:	88 23       	and	r24, r24
    5c52:	21 f0       	breq	.+8      	; 0x5c5c <__vector_64+0x186>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    5c54:	89 81       	ldd	r24, Y+1	; 0x01
    5c56:	8e 7f       	andi	r24, 0xFE	; 254
    5c58:	89 83       	std	Y+1, r24	; 0x01
    5c5a:	10 c0       	rjmp	.+32     	; 0x5c7c <__vector_64+0x1a6>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    5c5c:	89 81       	ldd	r24, Y+1	; 0x01
    5c5e:	88 23       	and	r24, r24
    5c60:	6c f4       	brge	.+26     	; 0x5c7c <__vector_64+0x1a6>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    5c62:	89 81       	ldd	r24, Y+1	; 0x01
    5c64:	8f 77       	andi	r24, 0x7F	; 127
    5c66:	89 83       	std	Y+1, r24	; 0x01
            pcb->battlow++;
    5c68:	8a 81       	ldd	r24, Y+2	; 0x02
    5c6a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c6c:	fc 01       	movw	r30, r24
    5c6e:	81 89       	ldd	r24, Z+17	; 0x11
    5c70:	28 2f       	mov	r18, r24
    5c72:	2f 5f       	subi	r18, 0xFF	; 255
    5c74:	8a 81       	ldd	r24, Y+2	; 0x02
    5c76:	9b 81       	ldd	r25, Y+3	; 0x03
    5c78:	fc 01       	movw	r30, r24
    5c7a:	21 8b       	std	Z+17, r18	; 0x11
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    5c7c:	89 81       	ldd	r24, Y+1	; 0x01
    5c7e:	88 23       	and	r24, r24
    5c80:	09 f0       	breq	.+2      	; 0x5c84 <__vector_64+0x1ae>
    5c82:	5f cf       	rjmp	.-322    	; 0x5b42 <__vector_64+0x6c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    5c84:	8f e3       	ldi	r24, 0x3F	; 63
    5c86:	90 e0       	ldi	r25, 0x00	; 0
    5c88:	20 91 4f 40 	lds	r18, 0x404F
    5c8c:	fc 01       	movw	r30, r24
    5c8e:	20 83       	st	Z, r18
    5c90:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    5c92:	8f e0       	ldi	r24, 0x0F	; 15
    5c94:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <chb_reg_read>
}
    5c98:	25 96       	adiw	r28, 0x05	; 5
    5c9a:	cd bf       	out	0x3d, r28	; 61
    5c9c:	de bf       	out	0x3e, r29	; 62
    5c9e:	df 91       	pop	r29
    5ca0:	cf 91       	pop	r28
    5ca2:	ff 91       	pop	r31
    5ca4:	ef 91       	pop	r30
    5ca6:	bf 91       	pop	r27
    5ca8:	af 91       	pop	r26
    5caa:	9f 91       	pop	r25
    5cac:	8f 91       	pop	r24
    5cae:	7f 91       	pop	r23
    5cb0:	6f 91       	pop	r22
    5cb2:	5f 91       	pop	r21
    5cb4:	4f 91       	pop	r20
    5cb6:	3f 91       	pop	r19
    5cb8:	2f 91       	pop	r18
    5cba:	0f 90       	pop	r0
    5cbc:	00 92 3b 00 	sts	0x003B, r0
    5cc0:	0f 90       	pop	r0
    5cc2:	0f be       	out	0x3f, r0	; 63
    5cc4:	0f 90       	pop	r0
    5cc6:	1f 90       	pop	r1
    5cc8:	18 95       	reti

00005cca <RadioCS>:

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
    5cca:	cf 93       	push	r28
    5ccc:	df 93       	push	r29
    5cce:	0f 92       	push	r0
    5cd0:	cd b7       	in	r28, 0x3d	; 61
    5cd2:	de b7       	in	r29, 0x3e	; 62
    5cd4:	89 83       	std	Y+1, r24	; 0x01
	if (status) PORTD.OUTCLR = PIN4_bm;
    5cd6:	89 81       	ldd	r24, Y+1	; 0x01
    5cd8:	88 23       	and	r24, r24
    5cda:	31 f0       	breq	.+12     	; 0x5ce8 <RadioCS+0x1e>
    5cdc:	80 e6       	ldi	r24, 0x60	; 96
    5cde:	96 e0       	ldi	r25, 0x06	; 6
    5ce0:	20 e1       	ldi	r18, 0x10	; 16
    5ce2:	fc 01       	movw	r30, r24
    5ce4:	26 83       	std	Z+6, r18	; 0x06
    5ce6:	05 c0       	rjmp	.+10     	; 0x5cf2 <RadioCS+0x28>
	else {
		PORTD.OUTSET = PIN4_bm;
    5ce8:	80 e6       	ldi	r24, 0x60	; 96
    5cea:	96 e0       	ldi	r25, 0x06	; 6
    5cec:	20 e1       	ldi	r18, 0x10	; 16
    5cee:	fc 01       	movw	r30, r24
    5cf0:	25 83       	std	Z+5, r18	; 0x05
	}
    5cf2:	0f 90       	pop	r0
    5cf4:	df 91       	pop	r29
    5cf6:	cf 91       	pop	r28
    5cf8:	08 95       	ret

00005cfa <chb_eep_write_byte>:
/*!

*/
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    5cfa:	cf 93       	push	r28
    5cfc:	df 93       	push	r29
    5cfe:	00 d0       	rcall	.+0      	; 0x5d00 <chb_eep_write_byte+0x6>
    5d00:	cd b7       	in	r28, 0x3d	; 61
    5d02:	de b7       	in	r29, 0x3e	; 62
    5d04:	89 83       	std	Y+1, r24	; 0x01
    5d06:	9a 83       	std	Y+2, r25	; 0x02
    5d08:	6b 83       	std	Y+3, r22	; 0x03
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    5d0a:	00 00       	nop
    5d0c:	80 ec       	ldi	r24, 0xC0	; 192
    5d0e:	91 e0       	ldi	r25, 0x01	; 1
    5d10:	fc 01       	movw	r30, r24
    5d12:	87 85       	ldd	r24, Z+15	; 0x0f
    5d14:	88 23       	and	r24, r24
    5d16:	d4 f3       	brlt	.-12     	; 0x5d0c <chb_eep_write_byte+0x12>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    5d18:	80 ec       	ldi	r24, 0xC0	; 192
    5d1a:	91 e0       	ldi	r25, 0x01	; 1
    5d1c:	fc 01       	movw	r30, r24
    5d1e:	87 85       	ldd	r24, Z+15	; 0x0f
    5d20:	88 2f       	mov	r24, r24
    5d22:	90 e0       	ldi	r25, 0x00	; 0
    5d24:	82 70       	andi	r24, 0x02	; 2
    5d26:	90 70       	andi	r25, 0x00	; 0
    5d28:	00 97       	sbiw	r24, 0x00	; 0
    5d2a:	99 f0       	breq	.+38     	; 0x5d52 <chb_eep_write_byte+0x58>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    5d2c:	80 ec       	ldi	r24, 0xC0	; 192
    5d2e:	91 e0       	ldi	r25, 0x01	; 1
    5d30:	26 e3       	ldi	r18, 0x36	; 54
    5d32:	fc 01       	movw	r30, r24
    5d34:	22 87       	std	Z+10, r18	; 0x0a
        NVM_EXEC();
    5d36:	ef 93       	push	r30
    5d38:	ff 93       	push	r31
    5d3a:	0f 93       	push	r16
    5d3c:	2f 93       	push	r18
    5d3e:	eb ec       	ldi	r30, 0xCB	; 203
    5d40:	f1 e0       	ldi	r31, 0x01	; 1
    5d42:	08 ed       	ldi	r16, 0xD8	; 216
    5d44:	21 e0       	ldi	r18, 0x01	; 1
    5d46:	04 bf       	out	0x34, r16	; 52
    5d48:	20 83       	st	Z, r18
    5d4a:	2f 91       	pop	r18
    5d4c:	0f 91       	pop	r16
    5d4e:	ff 91       	pop	r31
    5d50:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    5d52:	80 ec       	ldi	r24, 0xC0	; 192
    5d54:	91 e0       	ldi	r25, 0x01	; 1
    5d56:	23 e3       	ldi	r18, 0x33	; 51
    5d58:	fc 01       	movw	r30, r24
    5d5a:	22 87       	std	Z+10, r18	; 0x0a

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    5d5c:	80 ec       	ldi	r24, 0xC0	; 192
    5d5e:	91 e0       	ldi	r25, 0x01	; 1
    5d60:	29 81       	ldd	r18, Y+1	; 0x01
    5d62:	fc 01       	movw	r30, r24
    5d64:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    5d66:	80 ec       	ldi	r24, 0xC0	; 192
    5d68:	91 e0       	ldi	r25, 0x01	; 1
    5d6a:	29 81       	ldd	r18, Y+1	; 0x01
    5d6c:	3a 81       	ldd	r19, Y+2	; 0x02
    5d6e:	23 2f       	mov	r18, r19
    5d70:	33 27       	eor	r19, r19
    5d72:	2f 71       	andi	r18, 0x1F	; 31
    5d74:	fc 01       	movw	r30, r24
    5d76:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    5d78:	80 ec       	ldi	r24, 0xC0	; 192
    5d7a:	91 e0       	ldi	r25, 0x01	; 1
    5d7c:	fc 01       	movw	r30, r24
    5d7e:	12 82       	std	Z+2, r1	; 0x02

    // load the data to write
    NVM.DATA0 = value;
    5d80:	80 ec       	ldi	r24, 0xC0	; 192
    5d82:	91 e0       	ldi	r25, 0x01	; 1
    5d84:	2b 81       	ldd	r18, Y+3	; 0x03
    5d86:	fc 01       	movw	r30, r24
    5d88:	24 83       	std	Z+4, r18	; 0x04

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    5d8a:	80 ec       	ldi	r24, 0xC0	; 192
    5d8c:	91 e0       	ldi	r25, 0x01	; 1
    5d8e:	25 e3       	ldi	r18, 0x35	; 53
    5d90:	fc 01       	movw	r30, r24
    5d92:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    5d94:	ef 93       	push	r30
    5d96:	ff 93       	push	r31
    5d98:	0f 93       	push	r16
    5d9a:	2f 93       	push	r18
    5d9c:	eb ec       	ldi	r30, 0xCB	; 203
    5d9e:	f1 e0       	ldi	r31, 0x01	; 1
    5da0:	08 ed       	ldi	r16, 0xD8	; 216
    5da2:	21 e0       	ldi	r18, 0x01	; 1
    5da4:	04 bf       	out	0x34, r16	; 52
    5da6:	20 83       	st	Z, r18
    5da8:	2f 91       	pop	r18
    5daa:	0f 91       	pop	r16
    5dac:	ff 91       	pop	r31
    5dae:	ef 91       	pop	r30
}
    5db0:	23 96       	adiw	r28, 0x03	; 3
    5db2:	cd bf       	out	0x3d, r28	; 61
    5db4:	de bf       	out	0x3e, r29	; 62
    5db6:	df 91       	pop	r29
    5db8:	cf 91       	pop	r28
    5dba:	08 95       	ret

00005dbc <chb_eep_read_byte>:
/*!

*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    5dbc:	cf 93       	push	r28
    5dbe:	df 93       	push	r29
    5dc0:	0f 92       	push	r0
    5dc2:	0f 92       	push	r0
    5dc4:	cd b7       	in	r28, 0x3d	; 61
    5dc6:	de b7       	in	r29, 0x3e	; 62
    5dc8:	89 83       	std	Y+1, r24	; 0x01
    5dca:	9a 83       	std	Y+2, r25	; 0x02
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    5dcc:	00 00       	nop
    5dce:	80 ec       	ldi	r24, 0xC0	; 192
    5dd0:	91 e0       	ldi	r25, 0x01	; 1
    5dd2:	fc 01       	movw	r30, r24
    5dd4:	87 85       	ldd	r24, Z+15	; 0x0f
    5dd6:	88 23       	and	r24, r24
    5dd8:	d4 f3       	brlt	.-12     	; 0x5dce <chb_eep_read_byte+0x12>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    5dda:	80 ec       	ldi	r24, 0xC0	; 192
    5ddc:	91 e0       	ldi	r25, 0x01	; 1
    5dde:	29 81       	ldd	r18, Y+1	; 0x01
    5de0:	fc 01       	movw	r30, r24
    5de2:	20 83       	st	Z, r18
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    5de4:	80 ec       	ldi	r24, 0xC0	; 192
    5de6:	91 e0       	ldi	r25, 0x01	; 1
    5de8:	29 81       	ldd	r18, Y+1	; 0x01
    5dea:	3a 81       	ldd	r19, Y+2	; 0x02
    5dec:	23 2f       	mov	r18, r19
    5dee:	33 27       	eor	r19, r19
    5df0:	2f 71       	andi	r18, 0x1F	; 31
    5df2:	fc 01       	movw	r30, r24
    5df4:	21 83       	std	Z+1, r18	; 0x01
    NVM.ADDR2 = 0x00;
    5df6:	80 ec       	ldi	r24, 0xC0	; 192
    5df8:	91 e0       	ldi	r25, 0x01	; 1
    5dfa:	fc 01       	movw	r30, r24
    5dfc:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    5dfe:	80 ec       	ldi	r24, 0xC0	; 192
    5e00:	91 e0       	ldi	r25, 0x01	; 1
    5e02:	26 e0       	ldi	r18, 0x06	; 6
    5e04:	fc 01       	movw	r30, r24
    5e06:	22 87       	std	Z+10, r18	; 0x0a
    NVM_EXEC();
    5e08:	ef 93       	push	r30
    5e0a:	ff 93       	push	r31
    5e0c:	0f 93       	push	r16
    5e0e:	2f 93       	push	r18
    5e10:	eb ec       	ldi	r30, 0xCB	; 203
    5e12:	f1 e0       	ldi	r31, 0x01	; 1
    5e14:	08 ed       	ldi	r16, 0xD8	; 216
    5e16:	21 e0       	ldi	r18, 0x01	; 1
    5e18:	04 bf       	out	0x34, r16	; 52
    5e1a:	20 83       	st	Z, r18
    5e1c:	2f 91       	pop	r18
    5e1e:	0f 91       	pop	r16
    5e20:	ff 91       	pop	r31
    5e22:	ef 91       	pop	r30

    return NVM.DATA0;
    5e24:	80 ec       	ldi	r24, 0xC0	; 192
    5e26:	91 e0       	ldi	r25, 0x01	; 1
    5e28:	fc 01       	movw	r30, r24
    5e2a:	84 81       	ldd	r24, Z+4	; 0x04
}
    5e2c:	0f 90       	pop	r0
    5e2e:	0f 90       	pop	r0
    5e30:	df 91       	pop	r29
    5e32:	cf 91       	pop	r28
    5e34:	08 95       	ret

00005e36 <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    5e36:	cf 93       	push	r28
    5e38:	df 93       	push	r29
    5e3a:	cd b7       	in	r28, 0x3d	; 61
    5e3c:	de b7       	in	r29, 0x3e	; 62
    5e3e:	27 97       	sbiw	r28, 0x07	; 7
    5e40:	cd bf       	out	0x3d, r28	; 61
    5e42:	de bf       	out	0x3e, r29	; 62
    5e44:	8a 83       	std	Y+2, r24	; 0x02
    5e46:	9b 83       	std	Y+3, r25	; 0x03
    5e48:	6c 83       	std	Y+4, r22	; 0x04
    5e4a:	7d 83       	std	Y+5, r23	; 0x05
    5e4c:	4e 83       	std	Y+6, r20	; 0x06
    5e4e:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    5e50:	80 ec       	ldi	r24, 0xC0	; 192
    5e52:	91 e0       	ldi	r25, 0x01	; 1
    5e54:	20 ec       	ldi	r18, 0xC0	; 192
    5e56:	31 e0       	ldi	r19, 0x01	; 1
    5e58:	f9 01       	movw	r30, r18
    5e5a:	24 85       	ldd	r18, Z+12	; 0x0c
    5e5c:	27 7f       	andi	r18, 0xF7	; 247
    5e5e:	fc 01       	movw	r30, r24
    5e60:	24 87       	std	Z+12, r18	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    5e62:	19 82       	std	Y+1, r1	; 0x01
    5e64:	16 c0       	rjmp	.+44     	; 0x5e92 <chb_eeprom_write+0x5c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    5e66:	89 81       	ldd	r24, Y+1	; 0x01
    5e68:	28 2f       	mov	r18, r24
    5e6a:	30 e0       	ldi	r19, 0x00	; 0
    5e6c:	8a 81       	ldd	r24, Y+2	; 0x02
    5e6e:	9b 81       	ldd	r25, Y+3	; 0x03
    5e70:	82 0f       	add	r24, r18
    5e72:	93 1f       	adc	r25, r19
    5e74:	29 81       	ldd	r18, Y+1	; 0x01
    5e76:	22 2f       	mov	r18, r18
    5e78:	30 e0       	ldi	r19, 0x00	; 0
    5e7a:	4c 81       	ldd	r20, Y+4	; 0x04
    5e7c:	5d 81       	ldd	r21, Y+5	; 0x05
    5e7e:	24 0f       	add	r18, r20
    5e80:	35 1f       	adc	r19, r21
    5e82:	f9 01       	movw	r30, r18
    5e84:	20 81       	ld	r18, Z
    5e86:	62 2f       	mov	r22, r18
    5e88:	0e 94 7d 2e 	call	0x5cfa	; 0x5cfa <chb_eep_write_byte>
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    5e8c:	89 81       	ldd	r24, Y+1	; 0x01
    5e8e:	8f 5f       	subi	r24, 0xFF	; 255
    5e90:	89 83       	std	Y+1, r24	; 0x01
    5e92:	89 81       	ldd	r24, Y+1	; 0x01
    5e94:	28 2f       	mov	r18, r24
    5e96:	30 e0       	ldi	r19, 0x00	; 0
    5e98:	8e 81       	ldd	r24, Y+6	; 0x06
    5e9a:	9f 81       	ldd	r25, Y+7	; 0x07
    5e9c:	28 17       	cp	r18, r24
    5e9e:	39 07       	cpc	r19, r25
    5ea0:	10 f3       	brcs	.-60     	; 0x5e66 <chb_eeprom_write+0x30>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    5ea2:	27 96       	adiw	r28, 0x07	; 7
    5ea4:	cd bf       	out	0x3d, r28	; 61
    5ea6:	de bf       	out	0x3e, r29	; 62
    5ea8:	df 91       	pop	r29
    5eaa:	cf 91       	pop	r28
    5eac:	08 95       	ret

00005eae <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    5eae:	0f 93       	push	r16
    5eb0:	1f 93       	push	r17
    5eb2:	cf 93       	push	r28
    5eb4:	df 93       	push	r29
    5eb6:	cd b7       	in	r28, 0x3d	; 61
    5eb8:	de b7       	in	r29, 0x3e	; 62
    5eba:	27 97       	sbiw	r28, 0x07	; 7
    5ebc:	cd bf       	out	0x3d, r28	; 61
    5ebe:	de bf       	out	0x3e, r29	; 62
    5ec0:	8a 83       	std	Y+2, r24	; 0x02
    5ec2:	9b 83       	std	Y+3, r25	; 0x03
    5ec4:	6c 83       	std	Y+4, r22	; 0x04
    5ec6:	7d 83       	std	Y+5, r23	; 0x05
    5ec8:	4e 83       	std	Y+6, r20	; 0x06
    5eca:	5f 83       	std	Y+7, r21	; 0x07
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    5ecc:	80 ec       	ldi	r24, 0xC0	; 192
    5ece:	91 e0       	ldi	r25, 0x01	; 1
    5ed0:	20 ec       	ldi	r18, 0xC0	; 192
    5ed2:	31 e0       	ldi	r19, 0x01	; 1
    5ed4:	f9 01       	movw	r30, r18
    5ed6:	24 85       	ldd	r18, Z+12	; 0x0c
    5ed8:	27 7f       	andi	r18, 0xF7	; 247
    5eda:	fc 01       	movw	r30, r24
    5edc:	24 87       	std	Z+12, r18	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    5ede:	19 82       	std	Y+1, r1	; 0x01
    5ee0:	16 c0       	rjmp	.+44     	; 0x5f0e <chb_eeprom_read+0x60>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    5ee2:	89 81       	ldd	r24, Y+1	; 0x01
    5ee4:	88 2f       	mov	r24, r24
    5ee6:	90 e0       	ldi	r25, 0x00	; 0
    5ee8:	2c 81       	ldd	r18, Y+4	; 0x04
    5eea:	3d 81       	ldd	r19, Y+5	; 0x05
    5eec:	89 01       	movw	r16, r18
    5eee:	08 0f       	add	r16, r24
    5ef0:	19 1f       	adc	r17, r25
    5ef2:	89 81       	ldd	r24, Y+1	; 0x01
    5ef4:	28 2f       	mov	r18, r24
    5ef6:	30 e0       	ldi	r19, 0x00	; 0
    5ef8:	8a 81       	ldd	r24, Y+2	; 0x02
    5efa:	9b 81       	ldd	r25, Y+3	; 0x03
    5efc:	82 0f       	add	r24, r18
    5efe:	93 1f       	adc	r25, r19
    5f00:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <chb_eep_read_byte>
    5f04:	f8 01       	movw	r30, r16
    5f06:	80 83       	st	Z, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    5f08:	89 81       	ldd	r24, Y+1	; 0x01
    5f0a:	8f 5f       	subi	r24, 0xFF	; 255
    5f0c:	89 83       	std	Y+1, r24	; 0x01
    5f0e:	89 81       	ldd	r24, Y+1	; 0x01
    5f10:	28 2f       	mov	r18, r24
    5f12:	30 e0       	ldi	r19, 0x00	; 0
    5f14:	8e 81       	ldd	r24, Y+6	; 0x06
    5f16:	9f 81       	ldd	r25, Y+7	; 0x07
    5f18:	28 17       	cp	r18, r24
    5f1a:	39 07       	cpc	r19, r25
    5f1c:	10 f3       	brcs	.-60     	; 0x5ee2 <chb_eeprom_read+0x34>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    5f1e:	27 96       	adiw	r28, 0x07	; 7
    5f20:	cd bf       	out	0x3d, r28	; 61
    5f22:	de bf       	out	0x3e, r29	; 62
    5f24:	df 91       	pop	r29
    5f26:	cf 91       	pop	r28
    5f28:	1f 91       	pop	r17
    5f2a:	0f 91       	pop	r16
    5f2c:	08 95       	ret

00005f2e <chb_spi_init>:

*/
/**************************************************************************/

void chb_spi_init()
{
    5f2e:	cf 93       	push	r28
    5f30:	df 93       	push	r29
    5f32:	cd b7       	in	r28, 0x3d	; 61
    5f34:	de b7       	in	r29, 0x3e	; 62
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    5f36:	80 e6       	ldi	r24, 0x60	; 96
    5f38:	96 e0       	ldi	r25, 0x06	; 6
    5f3a:	20 e6       	ldi	r18, 0x60	; 96
    5f3c:	36 e0       	ldi	r19, 0x06	; 6
    5f3e:	f9 01       	movw	r30, r18
    5f40:	20 81       	ld	r18, Z
    5f42:	20 6b       	ori	r18, 0xB0	; 176
    5f44:	fc 01       	movw	r30, r24
    5f46:	20 83       	st	Z, r18
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    5f48:	84 e6       	ldi	r24, 0x64	; 100
    5f4a:	96 e0       	ldi	r25, 0x06	; 6
    5f4c:	24 e6       	ldi	r18, 0x64	; 100
    5f4e:	36 e0       	ldi	r19, 0x06	; 6
    5f50:	f9 01       	movw	r30, r18
    5f52:	20 81       	ld	r18, Z
    5f54:	20 61       	ori	r18, 0x10	; 16
    5f56:	fc 01       	movw	r30, r24
    5f58:	20 83       	st	Z, r18

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    5f5a:	80 ec       	ldi	r24, 0xC0	; 192
    5f5c:	99 e0       	ldi	r25, 0x09	; 9
    5f5e:	20 ec       	ldi	r18, 0xC0	; 192
    5f60:	39 e0       	ldi	r19, 0x09	; 9
    5f62:	f9 01       	movw	r30, r18
    5f64:	20 81       	ld	r18, Z
    5f66:	21 65       	ori	r18, 0x51	; 81
    5f68:	fc 01       	movw	r30, r24
    5f6a:	20 83       	st	Z, r18

    // set the slave select to idle
    CHB_SPI_DISABLE();
    5f6c:	84 e6       	ldi	r24, 0x64	; 100
    5f6e:	96 e0       	ldi	r25, 0x06	; 6
    5f70:	24 e6       	ldi	r18, 0x64	; 100
    5f72:	36 e0       	ldi	r19, 0x06	; 6
    5f74:	f9 01       	movw	r30, r18
    5f76:	20 81       	ld	r18, Z
    5f78:	20 61       	ori	r18, 0x10	; 16
    5f7a:	fc 01       	movw	r30, r24
    5f7c:	20 83       	st	Z, r18
}
    5f7e:	df 91       	pop	r29
    5f80:	cf 91       	pop	r28
    5f82:	08 95       	ret

00005f84 <SPID_write>:
    This function both reads and writes data. For write operations, include data
    to be written as argument. For read ops, use dummy data as arg. Returned
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
    5f84:	cf 93       	push	r28
    5f86:	df 93       	push	r29
    5f88:	0f 92       	push	r0
    5f8a:	0f 92       	push	r0
    5f8c:	cd b7       	in	r28, 0x3d	; 61
    5f8e:	de b7       	in	r29, 0x3e	; 62
    5f90:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPID.DATA = byteToSend;
    5f92:	80 ec       	ldi	r24, 0xC0	; 192
    5f94:	99 e0       	ldi	r25, 0x09	; 9
    5f96:	2a 81       	ldd	r18, Y+2	; 0x02
    5f98:	fc 01       	movw	r30, r24
    5f9a:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    5f9c:	00 00       	nop
    5f9e:	80 ec       	ldi	r24, 0xC0	; 192
    5fa0:	99 e0       	ldi	r25, 0x09	; 9
    5fa2:	fc 01       	movw	r30, r24
    5fa4:	82 81       	ldd	r24, Z+2	; 0x02
    5fa6:	88 23       	and	r24, r24
    5fa8:	d4 f7       	brge	.-12     	; 0x5f9e <SPID_write+0x1a>
	data = SPID.DATA; //read SPI data register to reset status flag
    5faa:	80 ec       	ldi	r24, 0xC0	; 192
    5fac:	99 e0       	ldi	r25, 0x09	; 9
    5fae:	fc 01       	movw	r30, r24
    5fb0:	83 81       	ldd	r24, Z+3	; 0x03
    5fb2:	89 83       	std	Y+1, r24	; 0x01
	return data;
    5fb4:	89 81       	ldd	r24, Y+1	; 0x01
    5fb6:	0f 90       	pop	r0
    5fb8:	0f 90       	pop	r0
    5fba:	df 91       	pop	r29
    5fbc:	cf 91       	pop	r28
    5fbe:	08 95       	ret

00005fc0 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    5fc0:	0f 93       	push	r16
    5fc2:	cf 93       	push	r28
    5fc4:	df 93       	push	r29
    5fc6:	00 d0       	rcall	.+0      	; 0x5fc8 <CCPWrite+0x8>
    5fc8:	00 d0       	rcall	.+0      	; 0x5fca <CCPWrite+0xa>
    5fca:	cd b7       	in	r28, 0x3d	; 61
    5fcc:	de b7       	in	r29, 0x3e	; 62
    5fce:	8c 83       	std	Y+4, r24	; 0x04
    5fd0:	9d 83       	std	Y+5, r25	; 0x05
    5fd2:	6e 83       	std	Y+6, r22	; 0x06

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    5fd4:	8f e3       	ldi	r24, 0x3F	; 63
    5fd6:	90 e0       	ldi	r25, 0x00	; 0
    5fd8:	fc 01       	movw	r30, r24
    5fda:	80 81       	ld	r24, Z
    5fdc:	8b 83       	std	Y+3, r24	; 0x03
    5fde:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
    5fe0:	8c 81       	ldd	r24, Y+4	; 0x04
    5fe2:	9d 81       	ldd	r25, Y+5	; 0x05
    5fe4:	89 83       	std	Y+1, r24	; 0x01
    5fe6:	9a 83       	std	Y+2, r25	; 0x02
#ifdef RAMPZ
	RAMPZ = 0;
    5fe8:	8b e3       	ldi	r24, 0x3B	; 59
    5fea:	90 e0       	ldi	r25, 0x00	; 0
    5fec:	fc 01       	movw	r30, r24
    5fee:	10 82       	st	Z, r1
#endif
	asm volatile(
    5ff0:	89 81       	ldd	r24, Y+1	; 0x01
    5ff2:	9a 81       	ldd	r25, Y+2	; 0x02
    5ff4:	2e 81       	ldd	r18, Y+6	; 0x06
    5ff6:	fc 01       	movw	r30, r24
    5ff8:	08 ed       	ldi	r16, 0xD8	; 216
    5ffa:	04 bf       	out	0x34, r16	; 52
    5ffc:	20 83       	st	Z, r18
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    5ffe:	8f e3       	ldi	r24, 0x3F	; 63
    6000:	90 e0       	ldi	r25, 0x00	; 0
    6002:	2b 81       	ldd	r18, Y+3	; 0x03
    6004:	fc 01       	movw	r30, r24
    6006:	20 83       	st	Z, r18
#endif
}
    6008:	26 96       	adiw	r28, 0x06	; 6
    600a:	cd bf       	out	0x3d, r28	; 61
    600c:	de bf       	out	0x3e, r29	; 62
    600e:	df 91       	pop	r29
    6010:	cf 91       	pop	r28
    6012:	0f 91       	pop	r16
    6014:	08 95       	ret

00006016 <CLKSYS_XOSC_Config>:
 *                             external clock) and startup times.
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
    6016:	cf 93       	push	r28
    6018:	df 93       	push	r29
    601a:	00 d0       	rcall	.+0      	; 0x601c <CLKSYS_XOSC_Config+0x6>
    601c:	cd b7       	in	r28, 0x3d	; 61
    601e:	de b7       	in	r29, 0x3e	; 62
    6020:	89 83       	std	Y+1, r24	; 0x01
    6022:	6a 83       	std	Y+2, r22	; 0x02
    6024:	4b 83       	std	Y+3, r20	; 0x03
	OSC.XOSCCTRL = (uint8_t) freqRange |
    6026:	80 e5       	ldi	r24, 0x50	; 80
    6028:	90 e0       	ldi	r25, 0x00	; 0
    602a:	2a 81       	ldd	r18, Y+2	; 0x02
    602c:	22 23       	and	r18, r18
    602e:	11 f0       	breq	.+4      	; 0x6034 <CLKSYS_XOSC_Config+0x1e>
    6030:	20 e2       	ldi	r18, 0x20	; 32
    6032:	01 c0       	rjmp	.+2      	; 0x6036 <CLKSYS_XOSC_Config+0x20>
    6034:	20 e0       	ldi	r18, 0x00	; 0
    6036:	39 81       	ldd	r19, Y+1	; 0x01
    6038:	32 2b       	or	r19, r18
    603a:	2b 81       	ldd	r18, Y+3	; 0x03
    603c:	23 2b       	or	r18, r19
    603e:	fc 01       	movw	r30, r24
    6040:	22 83       	std	Z+2, r18	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    6042:	23 96       	adiw	r28, 0x03	; 3
    6044:	cd bf       	out	0x3d, r28	; 61
    6046:	de bf       	out	0x3e, r29	; 62
    6048:	df 91       	pop	r29
    604a:	cf 91       	pop	r28
    604c:	08 95       	ret

0000604e <CLKSYS_PLL_Config>:
 *                      must be above 0.4MHz.
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
    604e:	cf 93       	push	r28
    6050:	df 93       	push	r29
    6052:	0f 92       	push	r0
    6054:	0f 92       	push	r0
    6056:	cd b7       	in	r28, 0x3d	; 61
    6058:	de b7       	in	r29, 0x3e	; 62
    605a:	89 83       	std	Y+1, r24	; 0x01
    605c:	6a 83       	std	Y+2, r22	; 0x02
	factor &= OSC_PLLFAC_gm;
    605e:	8a 81       	ldd	r24, Y+2	; 0x02
    6060:	8f 71       	andi	r24, 0x1F	; 31
    6062:	8a 83       	std	Y+2, r24	; 0x02
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    6064:	80 e5       	ldi	r24, 0x50	; 80
    6066:	90 e0       	ldi	r25, 0x00	; 0
    6068:	39 81       	ldd	r19, Y+1	; 0x01
    606a:	2a 81       	ldd	r18, Y+2	; 0x02
    606c:	23 2b       	or	r18, r19
    606e:	fc 01       	movw	r30, r24
    6070:	25 83       	std	Z+5, r18	; 0x05
}
    6072:	0f 90       	pop	r0
    6074:	0f 90       	pop	r0
    6076:	df 91       	pop	r29
    6078:	cf 91       	pop	r28
    607a:	08 95       	ret

0000607c <CLKSYS_Disable>:
 *                 OSC_XOSCEN_bm, OSC_PLLEN_bm.
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
    607c:	cf 93       	push	r28
    607e:	df 93       	push	r29
    6080:	0f 92       	push	r0
    6082:	0f 92       	push	r0
    6084:	cd b7       	in	r28, 0x3d	; 61
    6086:	de b7       	in	r29, 0x3e	; 62
    6088:	8a 83       	std	Y+2, r24	; 0x02
	OSC.CTRL &= ~oscSel;
    608a:	80 e5       	ldi	r24, 0x50	; 80
    608c:	90 e0       	ldi	r25, 0x00	; 0
    608e:	20 e5       	ldi	r18, 0x50	; 80
    6090:	30 e0       	ldi	r19, 0x00	; 0
    6092:	f9 01       	movw	r30, r18
    6094:	20 81       	ld	r18, Z
    6096:	32 2f       	mov	r19, r18
    6098:	2a 81       	ldd	r18, Y+2	; 0x02
    609a:	20 95       	com	r18
    609c:	23 23       	and	r18, r19
    609e:	fc 01       	movw	r30, r24
    60a0:	20 83       	st	Z, r18
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    60a2:	80 e5       	ldi	r24, 0x50	; 80
    60a4:	90 e0       	ldi	r25, 0x00	; 0
    60a6:	fc 01       	movw	r30, r24
    60a8:	90 81       	ld	r25, Z
    60aa:	8a 81       	ldd	r24, Y+2	; 0x02
    60ac:	89 23       	and	r24, r25
    60ae:	89 83       	std	Y+1, r24	; 0x01
	return clkEnabled;
    60b0:	89 81       	ldd	r24, Y+1	; 0x01
}
    60b2:	0f 90       	pop	r0
    60b4:	0f 90       	pop	r0
    60b6:	df 91       	pop	r29
    60b8:	cf 91       	pop	r28
    60ba:	08 95       	ret

000060bc <CLKSYS_Prescalers_Config>:
 *  \param  PSBCfactor  Prescaler B and C division factor, in the combination
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
    60bc:	cf 93       	push	r28
    60be:	df 93       	push	r29
    60c0:	00 d0       	rcall	.+0      	; 0x60c2 <CLKSYS_Prescalers_Config+0x6>
    60c2:	cd b7       	in	r28, 0x3d	; 61
    60c4:	de b7       	in	r29, 0x3e	; 62
    60c6:	8a 83       	std	Y+2, r24	; 0x02
    60c8:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    60ca:	9a 81       	ldd	r25, Y+2	; 0x02
    60cc:	8b 81       	ldd	r24, Y+3	; 0x03
    60ce:	89 2b       	or	r24, r25
    60d0:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.PSCTRL, PSconfig );
    60d2:	81 e4       	ldi	r24, 0x41	; 65
    60d4:	90 e0       	ldi	r25, 0x00	; 0
    60d6:	69 81       	ldd	r22, Y+1	; 0x01
    60d8:	0e 94 e0 2f 	call	0x5fc0	; 0x5fc0 <CCPWrite>
}
    60dc:	23 96       	adiw	r28, 0x03	; 3
    60de:	cd bf       	out	0x3d, r28	; 61
    60e0:	de bf       	out	0x3e, r29	; 62
    60e2:	df 91       	pop	r29
    60e4:	cf 91       	pop	r28
    60e6:	08 95       	ret

000060e8 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    60e8:	cf 93       	push	r28
    60ea:	df 93       	push	r29
    60ec:	0f 92       	push	r0
    60ee:	0f 92       	push	r0
    60f0:	cd b7       	in	r28, 0x3d	; 61
    60f2:	de b7       	in	r29, 0x3e	; 62
    60f4:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    60f6:	80 e4       	ldi	r24, 0x40	; 64
    60f8:	90 e0       	ldi	r25, 0x00	; 0
    60fa:	fc 01       	movw	r30, r24
    60fc:	80 81       	ld	r24, Z
    60fe:	98 2f       	mov	r25, r24
    6100:	98 7f       	andi	r25, 0xF8	; 248
    6102:	8a 81       	ldd	r24, Y+2	; 0x02
    6104:	89 2b       	or	r24, r25
    6106:	89 83       	std	Y+1, r24	; 0x01
	CCPWrite( &CLK.CTRL, clkCtrl );
    6108:	80 e4       	ldi	r24, 0x40	; 64
    610a:	90 e0       	ldi	r25, 0x00	; 0
    610c:	69 81       	ldd	r22, Y+1	; 0x01
    610e:	0e 94 e0 2f 	call	0x5fc0	; 0x5fc0 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    6112:	80 e4       	ldi	r24, 0x40	; 64
    6114:	90 e0       	ldi	r25, 0x00	; 0
    6116:	fc 01       	movw	r30, r24
    6118:	90 81       	ld	r25, Z
    611a:	8a 81       	ldd	r24, Y+2	; 0x02
    611c:	89 23       	and	r24, r25
    611e:	89 83       	std	Y+1, r24	; 0x01
	return clkCtrl;
    6120:	89 81       	ldd	r24, Y+1	; 0x01
}
    6122:	0f 90       	pop	r0
    6124:	0f 90       	pop	r0
    6126:	df 91       	pop	r29
    6128:	cf 91       	pop	r28
    612a:	08 95       	ret

0000612c <CLKSYS_RTC_ClockSource_Enable>:
 *  and enables clock signal routing to the RTC module.
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
    612c:	cf 93       	push	r28
    612e:	df 93       	push	r29
    6130:	0f 92       	push	r0
    6132:	cd b7       	in	r28, 0x3d	; 61
    6134:	de b7       	in	r29, 0x3e	; 62
    6136:	89 83       	std	Y+1, r24	; 0x01
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    6138:	80 e4       	ldi	r24, 0x40	; 64
    613a:	90 e0       	ldi	r25, 0x00	; 0
    613c:	20 e4       	ldi	r18, 0x40	; 64
    613e:	30 e0       	ldi	r19, 0x00	; 0
    6140:	f9 01       	movw	r30, r18
    6142:	23 81       	ldd	r18, Z+3	; 0x03
    6144:	32 2f       	mov	r19, r18
    6146:	31 7f       	andi	r19, 0xF1	; 241
    6148:	29 81       	ldd	r18, Y+1	; 0x01
    614a:	23 2b       	or	r18, r19
    614c:	21 60       	ori	r18, 0x01	; 1
    614e:	fc 01       	movw	r30, r24
    6150:	23 83       	std	Z+3, r18	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    6152:	0f 90       	pop	r0
    6154:	df 91       	pop	r29
    6156:	cf 91       	pop	r28
    6158:	08 95       	ret

0000615a <CLKSYS_AutoCalibration_Enable>:
 *  \param  clkSource    Clock source to calibrate, either OSC_RC2MCREF_bm or
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
    615a:	cf 93       	push	r28
    615c:	df 93       	push	r29
    615e:	0f 92       	push	r0
    6160:	0f 92       	push	r0
    6162:	cd b7       	in	r28, 0x3d	; 61
    6164:	de b7       	in	r29, 0x3e	; 62
    6166:	89 83       	std	Y+1, r24	; 0x01
    6168:	6a 83       	std	Y+2, r22	; 0x02
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    616a:	80 e5       	ldi	r24, 0x50	; 80
    616c:	90 e0       	ldi	r25, 0x00	; 0
    616e:	20 e5       	ldi	r18, 0x50	; 80
    6170:	30 e0       	ldi	r19, 0x00	; 0
    6172:	f9 01       	movw	r30, r18
    6174:	26 81       	ldd	r18, Z+6	; 0x06
    6176:	32 2f       	mov	r19, r18
    6178:	29 81       	ldd	r18, Y+1	; 0x01
    617a:	20 95       	com	r18
    617c:	32 23       	and	r19, r18
    617e:	2a 81       	ldd	r18, Y+2	; 0x02
    6180:	22 23       	and	r18, r18
    6182:	11 f0       	breq	.+4      	; 0x6188 <CLKSYS_AutoCalibration_Enable+0x2e>
    6184:	29 81       	ldd	r18, Y+1	; 0x01
    6186:	01 c0       	rjmp	.+2      	; 0x618a <CLKSYS_AutoCalibration_Enable+0x30>
    6188:	20 e0       	ldi	r18, 0x00	; 0
    618a:	23 2b       	or	r18, r19
    618c:	fc 01       	movw	r30, r24
    618e:	26 83       	std	Z+6, r18	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    6190:	89 81       	ldd	r24, Y+1	; 0x01
    6192:	81 30       	cpi	r24, 0x01	; 1
    6194:	51 f4       	brne	.+20     	; 0x61aa <CLKSYS_AutoCalibration_Enable+0x50>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    6196:	88 e6       	ldi	r24, 0x68	; 104
    6198:	90 e0       	ldi	r25, 0x00	; 0
    619a:	28 e6       	ldi	r18, 0x68	; 104
    619c:	30 e0       	ldi	r19, 0x00	; 0
    619e:	f9 01       	movw	r30, r18
    61a0:	20 81       	ld	r18, Z
    61a2:	21 60       	ori	r18, 0x01	; 1
    61a4:	fc 01       	movw	r30, r24
    61a6:	20 83       	st	Z, r18
    61a8:	0c c0       	rjmp	.+24     	; 0x61c2 <CLKSYS_AutoCalibration_Enable+0x68>
	} else if (clkSource == OSC_RC32MCREF_bm) {
    61aa:	89 81       	ldd	r24, Y+1	; 0x01
    61ac:	82 30       	cpi	r24, 0x02	; 2
    61ae:	49 f4       	brne	.+18     	; 0x61c2 <CLKSYS_AutoCalibration_Enable+0x68>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    61b0:	80 e6       	ldi	r24, 0x60	; 96
    61b2:	90 e0       	ldi	r25, 0x00	; 0
    61b4:	20 e6       	ldi	r18, 0x60	; 96
    61b6:	30 e0       	ldi	r19, 0x00	; 0
    61b8:	f9 01       	movw	r30, r18
    61ba:	20 81       	ld	r18, Z
    61bc:	21 60       	ori	r18, 0x01	; 1
    61be:	fc 01       	movw	r30, r24
    61c0:	20 83       	st	Z, r18
	}
}
    61c2:	0f 90       	pop	r0
    61c4:	0f 90       	pop	r0
    61c6:	df 91       	pop	r29
    61c8:	cf 91       	pop	r28
    61ca:	08 95       	ret

000061cc <CLKSYS_XOSC_FailureDetection_Enable>:
 *  XOSCFD _will_ issue the XOSCF Non-maskable Interrupt (NMI) regardless of
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
    61cc:	cf 93       	push	r28
    61ce:	df 93       	push	r29
    61d0:	cd b7       	in	r28, 0x3d	; 61
    61d2:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    61d4:	83 e5       	ldi	r24, 0x53	; 83
    61d6:	90 e0       	ldi	r25, 0x00	; 0
    61d8:	63 e0       	ldi	r22, 0x03	; 3
    61da:	0e 94 e0 2f 	call	0x5fc0	; 0x5fc0 <CCPWrite>
}
    61de:	df 91       	pop	r29
    61e0:	cf 91       	pop	r28
    61e2:	08 95       	ret

000061e4 <CLKSYS_Configuration_Lock>:
 *  This will lock the configuration until the next reset, or until the
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
    61e4:	cf 93       	push	r28
    61e6:	df 93       	push	r29
    61e8:	cd b7       	in	r28, 0x3d	; 61
    61ea:	de b7       	in	r29, 0x3e	; 62
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    61ec:	82 e4       	ldi	r24, 0x42	; 66
    61ee:	90 e0       	ldi	r25, 0x00	; 0
    61f0:	61 e0       	ldi	r22, 0x01	; 1
    61f2:	0e 94 e0 2f 	call	0x5fc0	; 0x5fc0 <CCPWrite>
}
    61f6:	df 91       	pop	r29
    61f8:	cf 91       	pop	r28
    61fa:	08 95       	ret

000061fc <setXOSC_32MHz>:
// so this function will fail until the oscillator is installed.
//  - LS900-SI-02 does not contain the crystal
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
    61fc:	cf 93       	push	r28
    61fe:	df 93       	push	r29
    6200:	cd b7       	in	r28, 0x3d	; 61
    6202:	de b7       	in	r29, 0x3e	; 62
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    6204:	80 ec       	ldi	r24, 0xC0	; 192
    6206:	60 e0       	ldi	r22, 0x00	; 0
    6208:	4b e0       	ldi	r20, 0x0B	; 11
    620a:	0e 94 0b 30 	call	0x6016	; 0x6016 <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    620e:	80 e5       	ldi	r24, 0x50	; 80
    6210:	90 e0       	ldi	r25, 0x00	; 0
    6212:	20 e5       	ldi	r18, 0x50	; 80
    6214:	30 e0       	ldi	r19, 0x00	; 0
    6216:	f9 01       	movw	r30, r18
    6218:	20 81       	ld	r18, Z
    621a:	28 60       	ori	r18, 0x08	; 8
    621c:	fc 01       	movw	r30, r24
    621e:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    6220:	80 e5       	ldi	r24, 0x50	; 80
    6222:	90 e0       	ldi	r25, 0x00	; 0
    6224:	fc 01       	movw	r30, r24
    6226:	81 81       	ldd	r24, Z+1	; 0x01
    6228:	88 2f       	mov	r24, r24
    622a:	90 e0       	ldi	r25, 0x00	; 0
    622c:	88 70       	andi	r24, 0x08	; 8
    622e:	90 70       	andi	r25, 0x00	; 0
    6230:	00 97       	sbiw	r24, 0x00	; 0
    6232:	b1 f3       	breq	.-20     	; 0x6220 <setXOSC_32MHz+0x24>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    6234:	80 ec       	ldi	r24, 0xC0	; 192
    6236:	62 e0       	ldi	r22, 0x02	; 2
    6238:	0e 94 27 30 	call	0x604e	; 0x604e <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    623c:	80 e5       	ldi	r24, 0x50	; 80
    623e:	90 e0       	ldi	r25, 0x00	; 0
    6240:	20 e5       	ldi	r18, 0x50	; 80
    6242:	30 e0       	ldi	r19, 0x00	; 0
    6244:	f9 01       	movw	r30, r18
    6246:	20 81       	ld	r18, Z
    6248:	20 61       	ori	r18, 0x10	; 16
    624a:	fc 01       	movw	r30, r24
    624c:	20 83       	st	Z, r18
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    624e:	80 e5       	ldi	r24, 0x50	; 80
    6250:	90 e0       	ldi	r25, 0x00	; 0
    6252:	fc 01       	movw	r30, r24
    6254:	81 81       	ldd	r24, Z+1	; 0x01
    6256:	88 2f       	mov	r24, r24
    6258:	90 e0       	ldi	r25, 0x00	; 0
    625a:	80 71       	andi	r24, 0x10	; 16
    625c:	90 70       	andi	r25, 0x00	; 0
    625e:	00 97       	sbiw	r24, 0x00	; 0
    6260:	b1 f3       	breq	.-20     	; 0x624e <setXOSC_32MHz+0x52>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    6262:	84 e0       	ldi	r24, 0x04	; 4
    6264:	0e 94 74 30 	call	0x60e8	; 0x60e8 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    6268:	81 e0       	ldi	r24, 0x01	; 1
    626a:	0e 94 3e 30 	call	0x607c	; 0x607c <CLKSYS_Disable>
}
    626e:	df 91       	pop	r29
    6270:	cf 91       	pop	r28
    6272:	08 95       	ret

00006274 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
    6274:	cf 93       	push	r28
    6276:	df 93       	push	r29
    6278:	cd b7       	in	r28, 0x3d	; 61
    627a:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    627c:	80 e5       	ldi	r24, 0x50	; 80
    627e:	90 e0       	ldi	r25, 0x00	; 0
    6280:	20 e5       	ldi	r18, 0x50	; 80
    6282:	30 e0       	ldi	r19, 0x00	; 0
    6284:	f9 01       	movw	r30, r18
    6286:	20 81       	ld	r18, Z
    6288:	22 60       	ori	r18, 0x02	; 2
    628a:	fc 01       	movw	r30, r24
    628c:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    628e:	80 e0       	ldi	r24, 0x00	; 0
    6290:	61 e0       	ldi	r22, 0x01	; 1
    6292:	0e 94 5e 30 	call	0x60bc	; 0x60bc <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    6296:	80 e5       	ldi	r24, 0x50	; 80
    6298:	90 e0       	ldi	r25, 0x00	; 0
    629a:	fc 01       	movw	r30, r24
    629c:	81 81       	ldd	r24, Z+1	; 0x01
    629e:	88 2f       	mov	r24, r24
    62a0:	90 e0       	ldi	r25, 0x00	; 0
    62a2:	82 70       	andi	r24, 0x02	; 2
    62a4:	90 70       	andi	r25, 0x00	; 0
    62a6:	00 97       	sbiw	r24, 0x00	; 0
    62a8:	b1 f3       	breq	.-20     	; 0x6296 <set_16MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    62aa:	81 e0       	ldi	r24, 0x01	; 1
    62ac:	0e 94 74 30 	call	0x60e8	; 0x60e8 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    62b0:	81 e0       	ldi	r24, 0x01	; 1
    62b2:	0e 94 3e 30 	call	0x607c	; 0x607c <CLKSYS_Disable>
	
}
    62b6:	df 91       	pop	r29
    62b8:	cf 91       	pop	r28
    62ba:	08 95       	ret

000062bc <set_32MHz>:


// produces consistent but inaccurate clock period.
void set_32MHz() {
    62bc:	cf 93       	push	r28
    62be:	df 93       	push	r29
    62c0:	cd b7       	in	r28, 0x3d	; 61
    62c2:	de b7       	in	r29, 0x3e	; 62
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    62c4:	80 e5       	ldi	r24, 0x50	; 80
    62c6:	90 e0       	ldi	r25, 0x00	; 0
    62c8:	20 e5       	ldi	r18, 0x50	; 80
    62ca:	30 e0       	ldi	r19, 0x00	; 0
    62cc:	f9 01       	movw	r30, r18
    62ce:	20 81       	ld	r18, Z
    62d0:	22 60       	ori	r18, 0x02	; 2
    62d2:	fc 01       	movw	r30, r24
    62d4:	20 83       	st	Z, r18
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    62d6:	80 e0       	ldi	r24, 0x00	; 0
    62d8:	60 e0       	ldi	r22, 0x00	; 0
    62da:	0e 94 5e 30 	call	0x60bc	; 0x60bc <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    62de:	80 e5       	ldi	r24, 0x50	; 80
    62e0:	90 e0       	ldi	r25, 0x00	; 0
    62e2:	fc 01       	movw	r30, r24
    62e4:	81 81       	ldd	r24, Z+1	; 0x01
    62e6:	88 2f       	mov	r24, r24
    62e8:	90 e0       	ldi	r25, 0x00	; 0
    62ea:	82 70       	andi	r24, 0x02	; 2
    62ec:	90 70       	andi	r25, 0x00	; 0
    62ee:	00 97       	sbiw	r24, 0x00	; 0
    62f0:	b1 f3       	breq	.-20     	; 0x62de <set_32MHz+0x22>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    62f2:	81 e0       	ldi	r24, 0x01	; 1
    62f4:	0e 94 74 30 	call	0x60e8	; 0x60e8 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    62f8:	81 e0       	ldi	r24, 0x01	; 1
    62fa:	0e 94 3e 30 	call	0x607c	; 0x607c <CLKSYS_Disable>
	
}
    62fe:	df 91       	pop	r29
    6300:	cf 91       	pop	r28
    6302:	08 95       	ret

00006304 <portExCS>:


void portExCS(uint8_t write) {
    6304:	0f 93       	push	r16
    6306:	1f 93       	push	r17
    6308:	cf 93       	push	r28
    630a:	df 93       	push	r29
    630c:	cd b7       	in	r28, 0x3d	; 61
    630e:	de b7       	in	r29, 0x3e	; 62
    6310:	69 97       	sbiw	r28, 0x19	; 25
    6312:	cd bf       	out	0x3d, r28	; 61
    6314:	de bf       	out	0x3e, r29	; 62
    6316:	89 8f       	std	Y+25, r24	; 0x19
	if (write) PORTA.OUTCLR = PIN3_bm;
    6318:	89 8d       	ldd	r24, Y+25	; 0x19
    631a:	88 23       	and	r24, r24
    631c:	31 f0       	breq	.+12     	; 0x632a <portExCS+0x26>
    631e:	80 e0       	ldi	r24, 0x00	; 0
    6320:	96 e0       	ldi	r25, 0x06	; 6
    6322:	28 e0       	ldi	r18, 0x08	; 8
    6324:	fc 01       	movw	r30, r24
    6326:	26 83       	std	Z+6, r18	; 0x06
    6328:	05 c0       	rjmp	.+10     	; 0x6334 <portExCS+0x30>
	else {
		PORTA.OUTSET = PIN3_bm;
    632a:	80 e0       	ldi	r24, 0x00	; 0
    632c:	96 e0       	ldi	r25, 0x06	; 6
    632e:	28 e0       	ldi	r18, 0x08	; 8
    6330:	fc 01       	movw	r30, r24
    6332:	25 83       	std	Z+5, r18	; 0x05
    6334:	80 e0       	ldi	r24, 0x00	; 0
    6336:	90 e0       	ldi	r25, 0x00	; 0
    6338:	a0 e2       	ldi	r26, 0x20	; 32
    633a:	b1 e4       	ldi	r27, 0x41	; 65
    633c:	89 83       	std	Y+1, r24	; 0x01
    633e:	9a 83       	std	Y+2, r25	; 0x02
    6340:	ab 83       	std	Y+3, r26	; 0x03
    6342:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    6344:	69 81       	ldd	r22, Y+1	; 0x01
    6346:	7a 81       	ldd	r23, Y+2	; 0x02
    6348:	8b 81       	ldd	r24, Y+3	; 0x03
    634a:	9c 81       	ldd	r25, Y+4	; 0x04
    634c:	2b ea       	ldi	r18, 0xAB	; 171
    634e:	3a ea       	ldi	r19, 0xAA	; 170
    6350:	4a e2       	ldi	r20, 0x2A	; 42
    6352:	51 e4       	ldi	r21, 0x41	; 65
    6354:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    6358:	dc 01       	movw	r26, r24
    635a:	cb 01       	movw	r24, r22
    635c:	8d 83       	std	Y+5, r24	; 0x05
    635e:	9e 83       	std	Y+6, r25	; 0x06
    6360:	af 83       	std	Y+7, r26	; 0x07
    6362:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6364:	11 e0       	ldi	r17, 0x01	; 1
    6366:	6d 81       	ldd	r22, Y+5	; 0x05
    6368:	7e 81       	ldd	r23, Y+6	; 0x06
    636a:	8f 81       	ldd	r24, Y+7	; 0x07
    636c:	98 85       	ldd	r25, Y+8	; 0x08
    636e:	20 e0       	ldi	r18, 0x00	; 0
    6370:	30 e0       	ldi	r19, 0x00	; 0
    6372:	40 e8       	ldi	r20, 0x80	; 128
    6374:	5f e3       	ldi	r21, 0x3F	; 63
    6376:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    637a:	88 23       	and	r24, r24
    637c:	0c f0       	brlt	.+2      	; 0x6380 <portExCS+0x7c>
    637e:	10 e0       	ldi	r17, 0x00	; 0
    6380:	11 23       	and	r17, r17
    6382:	19 f0       	breq	.+6      	; 0x638a <portExCS+0x86>
		__ticks = 1;
    6384:	81 e0       	ldi	r24, 0x01	; 1
    6386:	89 87       	std	Y+9, r24	; 0x09
    6388:	a3 c0       	rjmp	.+326    	; 0x64d0 <portExCS+0x1cc>
	else if (__tmp > 255)
    638a:	11 e0       	ldi	r17, 0x01	; 1
    638c:	6d 81       	ldd	r22, Y+5	; 0x05
    638e:	7e 81       	ldd	r23, Y+6	; 0x06
    6390:	8f 81       	ldd	r24, Y+7	; 0x07
    6392:	98 85       	ldd	r25, Y+8	; 0x08
    6394:	20 e0       	ldi	r18, 0x00	; 0
    6396:	30 e0       	ldi	r19, 0x00	; 0
    6398:	4f e7       	ldi	r20, 0x7F	; 127
    639a:	53 e4       	ldi	r21, 0x43	; 67
    639c:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    63a0:	18 16       	cp	r1, r24
    63a2:	0c f0       	brlt	.+2      	; 0x63a6 <portExCS+0xa2>
    63a4:	10 e0       	ldi	r17, 0x00	; 0
    63a6:	11 23       	and	r17, r17
    63a8:	09 f4       	brne	.+2      	; 0x63ac <portExCS+0xa8>
    63aa:	89 c0       	rjmp	.+274    	; 0x64be <portExCS+0x1ba>
	{
		_delay_ms(__us / 1000.0);
    63ac:	69 81       	ldd	r22, Y+1	; 0x01
    63ae:	7a 81       	ldd	r23, Y+2	; 0x02
    63b0:	8b 81       	ldd	r24, Y+3	; 0x03
    63b2:	9c 81       	ldd	r25, Y+4	; 0x04
    63b4:	20 e0       	ldi	r18, 0x00	; 0
    63b6:	30 e0       	ldi	r19, 0x00	; 0
    63b8:	4a e7       	ldi	r20, 0x7A	; 122
    63ba:	54 e4       	ldi	r21, 0x44	; 68
    63bc:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
    63c0:	dc 01       	movw	r26, r24
    63c2:	cb 01       	movw	r24, r22
    63c4:	8a 87       	std	Y+10, r24	; 0x0a
    63c6:	9b 87       	std	Y+11, r25	; 0x0b
    63c8:	ac 87       	std	Y+12, r26	; 0x0c
    63ca:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    63cc:	6a 85       	ldd	r22, Y+10	; 0x0a
    63ce:	7b 85       	ldd	r23, Y+11	; 0x0b
    63d0:	8c 85       	ldd	r24, Y+12	; 0x0c
    63d2:	9d 85       	ldd	r25, Y+13	; 0x0d
    63d4:	20 e0       	ldi	r18, 0x00	; 0
    63d6:	30 e0       	ldi	r19, 0x00	; 0
    63d8:	4a ef       	ldi	r20, 0xFA	; 250
    63da:	55 e4       	ldi	r21, 0x45	; 69
    63dc:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    63e0:	dc 01       	movw	r26, r24
    63e2:	cb 01       	movw	r24, r22
    63e4:	8e 87       	std	Y+14, r24	; 0x0e
    63e6:	9f 87       	std	Y+15, r25	; 0x0f
    63e8:	a8 8b       	std	Y+16, r26	; 0x10
    63ea:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    63ec:	11 e0       	ldi	r17, 0x01	; 1
    63ee:	6e 85       	ldd	r22, Y+14	; 0x0e
    63f0:	7f 85       	ldd	r23, Y+15	; 0x0f
    63f2:	88 89       	ldd	r24, Y+16	; 0x10
    63f4:	99 89       	ldd	r25, Y+17	; 0x11
    63f6:	20 e0       	ldi	r18, 0x00	; 0
    63f8:	30 e0       	ldi	r19, 0x00	; 0
    63fa:	40 e8       	ldi	r20, 0x80	; 128
    63fc:	5f e3       	ldi	r21, 0x3F	; 63
    63fe:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    6402:	88 23       	and	r24, r24
    6404:	0c f0       	brlt	.+2      	; 0x6408 <portExCS+0x104>
    6406:	10 e0       	ldi	r17, 0x00	; 0
    6408:	11 23       	and	r17, r17
    640a:	29 f0       	breq	.+10     	; 0x6416 <portExCS+0x112>
		__ticks = 1;
    640c:	81 e0       	ldi	r24, 0x01	; 1
    640e:	90 e0       	ldi	r25, 0x00	; 0
    6410:	8a 8b       	std	Y+18, r24	; 0x12
    6412:	9b 8b       	std	Y+19, r25	; 0x13
    6414:	46 c0       	rjmp	.+140    	; 0x64a2 <portExCS+0x19e>
	else if (__tmp > 65535)
    6416:	11 e0       	ldi	r17, 0x01	; 1
    6418:	6e 85       	ldd	r22, Y+14	; 0x0e
    641a:	7f 85       	ldd	r23, Y+15	; 0x0f
    641c:	88 89       	ldd	r24, Y+16	; 0x10
    641e:	99 89       	ldd	r25, Y+17	; 0x11
    6420:	20 e0       	ldi	r18, 0x00	; 0
    6422:	3f ef       	ldi	r19, 0xFF	; 255
    6424:	4f e7       	ldi	r20, 0x7F	; 127
    6426:	57 e4       	ldi	r21, 0x47	; 71
    6428:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    642c:	18 16       	cp	r1, r24
    642e:	0c f0       	brlt	.+2      	; 0x6432 <portExCS+0x12e>
    6430:	10 e0       	ldi	r17, 0x00	; 0
    6432:	11 23       	and	r17, r17
    6434:	61 f1       	breq	.+88     	; 0x648e <portExCS+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6436:	6a 85       	ldd	r22, Y+10	; 0x0a
    6438:	7b 85       	ldd	r23, Y+11	; 0x0b
    643a:	8c 85       	ldd	r24, Y+12	; 0x0c
    643c:	9d 85       	ldd	r25, Y+13	; 0x0d
    643e:	20 e0       	ldi	r18, 0x00	; 0
    6440:	30 e0       	ldi	r19, 0x00	; 0
    6442:	40 e2       	ldi	r20, 0x20	; 32
    6444:	51 e4       	ldi	r21, 0x41	; 65
    6446:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    644a:	dc 01       	movw	r26, r24
    644c:	cb 01       	movw	r24, r22
    644e:	bc 01       	movw	r22, r24
    6450:	cd 01       	movw	r24, r26
    6452:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    6456:	dc 01       	movw	r26, r24
    6458:	cb 01       	movw	r24, r22
    645a:	8a 8b       	std	Y+18, r24	; 0x12
    645c:	9b 8b       	std	Y+19, r25	; 0x13
    645e:	12 c0       	rjmp	.+36     	; 0x6484 <portExCS+0x180>
    6460:	80 e2       	ldi	r24, 0x20	; 32
    6462:	93 e0       	ldi	r25, 0x03	; 3
    6464:	8c 8b       	std	Y+20, r24	; 0x14
    6466:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6468:	8c 89       	ldd	r24, Y+20	; 0x14
    646a:	9d 89       	ldd	r25, Y+21	; 0x15
    646c:	8c 01       	movw	r16, r24
    646e:	c8 01       	movw	r24, r16
    6470:	01 97       	sbiw	r24, 0x01	; 1
    6472:	f1 f7       	brne	.-4      	; 0x6470 <portExCS+0x16c>
    6474:	8c 01       	movw	r16, r24
    6476:	0c 8b       	std	Y+20, r16	; 0x14
    6478:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    647a:	8a 89       	ldd	r24, Y+18	; 0x12
    647c:	9b 89       	ldd	r25, Y+19	; 0x13
    647e:	01 97       	sbiw	r24, 0x01	; 1
    6480:	8a 8b       	std	Y+18, r24	; 0x12
    6482:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6484:	8a 89       	ldd	r24, Y+18	; 0x12
    6486:	9b 89       	ldd	r25, Y+19	; 0x13
    6488:	00 97       	sbiw	r24, 0x00	; 0
    648a:	51 f7       	brne	.-44     	; 0x6460 <portExCS+0x15c>
    648c:	28 c0       	rjmp	.+80     	; 0x64de <portExCS+0x1da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    648e:	6e 85       	ldd	r22, Y+14	; 0x0e
    6490:	7f 85       	ldd	r23, Y+15	; 0x0f
    6492:	88 89       	ldd	r24, Y+16	; 0x10
    6494:	99 89       	ldd	r25, Y+17	; 0x11
    6496:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    649a:	dc 01       	movw	r26, r24
    649c:	cb 01       	movw	r24, r22
    649e:	8a 8b       	std	Y+18, r24	; 0x12
    64a0:	9b 8b       	std	Y+19, r25	; 0x13
    64a2:	8a 89       	ldd	r24, Y+18	; 0x12
    64a4:	9b 89       	ldd	r25, Y+19	; 0x13
    64a6:	8e 8b       	std	Y+22, r24	; 0x16
    64a8:	9f 8b       	std	Y+23, r25	; 0x17
    64aa:	8e 89       	ldd	r24, Y+22	; 0x16
    64ac:	9f 89       	ldd	r25, Y+23	; 0x17
    64ae:	8c 01       	movw	r16, r24
    64b0:	f8 01       	movw	r30, r16
    64b2:	31 97       	sbiw	r30, 0x01	; 1
    64b4:	f1 f7       	brne	.-4      	; 0x64b2 <portExCS+0x1ae>
    64b6:	8f 01       	movw	r16, r30
    64b8:	0e 8b       	std	Y+22, r16	; 0x16
    64ba:	1f 8b       	std	Y+23, r17	; 0x17
    64bc:	10 c0       	rjmp	.+32     	; 0x64de <portExCS+0x1da>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    64be:	6d 81       	ldd	r22, Y+5	; 0x05
    64c0:	7e 81       	ldd	r23, Y+6	; 0x06
    64c2:	8f 81       	ldd	r24, Y+7	; 0x07
    64c4:	98 85       	ldd	r25, Y+8	; 0x08
    64c6:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    64ca:	dc 01       	movw	r26, r24
    64cc:	cb 01       	movw	r24, r22
    64ce:	89 87       	std	Y+9, r24	; 0x09
    64d0:	89 85       	ldd	r24, Y+9	; 0x09
    64d2:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    64d4:	88 8d       	ldd	r24, Y+24	; 0x18
    64d6:	18 2f       	mov	r17, r24
    64d8:	1a 95       	dec	r17
    64da:	f1 f7       	brne	.-4      	; 0x64d8 <portExCS+0x1d4>
    64dc:	18 8f       	std	Y+24, r17	; 0x18
	}
	_delay_us(10);
}
    64de:	69 96       	adiw	r28, 0x19	; 25
    64e0:	cd bf       	out	0x3d, r28	; 61
    64e2:	de bf       	out	0x3e, r29	; 62
    64e4:	df 91       	pop	r29
    64e6:	cf 91       	pop	r28
    64e8:	1f 91       	pop	r17
    64ea:	0f 91       	pop	r16
    64ec:	08 95       	ret

000064ee <PortEx_DIRSET>:

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    64ee:	cf 93       	push	r28
    64f0:	df 93       	push	r29
    64f2:	00 d0       	rcall	.+0      	; 0x64f4 <PortEx_DIRSET+0x6>
    64f4:	cd b7       	in	r28, 0x3d	; 61
    64f6:	de b7       	in	r29, 0x3e	; 62
    64f8:	8a 83       	std	Y+2, r24	; 0x02
    64fa:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    64fc:	80 e0       	ldi	r24, 0x00	; 0
    64fe:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>
	SPICS(TRUE);
    6502:	81 e0       	ldi	r24, 0x01	; 1
    6504:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	portExCS(TRUE);
    6508:	81 e0       	ldi	r24, 0x01	; 1
    650a:	0e 94 82 31 	call	0x6304	; 0x6304 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    650e:	8b 81       	ldd	r24, Y+3	; 0x03
    6510:	88 23       	and	r24, r24
    6512:	39 f0       	breq	.+14     	; 0x6522 <PortEx_DIRSET+0x34>
    6514:	90 91 7b 50 	lds	r25, 0x507B
    6518:	8a 81       	ldd	r24, Y+2	; 0x02
    651a:	89 2b       	or	r24, r25
    651c:	80 93 7b 50 	sts	0x507B, r24
    6520:	06 c0       	rjmp	.+12     	; 0x652e <PortEx_DIRSET+0x40>
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    6522:	90 91 d6 50 	lds	r25, 0x50D6
    6526:	8a 81       	ldd	r24, Y+2	; 0x02
    6528:	89 2b       	or	r24, r25
    652a:	80 93 d6 50 	sts	0x50D6, r24
	
	SPIBuffer[0] = PS_WRITE;
    652e:	80 e4       	ldi	r24, 0x40	; 64
    6530:	80 93 66 50 	sts	0x5066, r24
	if(bank) {
    6534:	8b 81       	ldd	r24, Y+3	; 0x03
    6536:	88 23       	and	r24, r24
    6538:	41 f0       	breq	.+16     	; 0x654a <PortEx_DIRSET+0x5c>
		SPIBuffer[1]=PS_IODIRA;
    653a:	10 92 67 50 	sts	0x5067, r1
		SPIBuffer[2] = ~bankA_DIR; 
    653e:	80 91 7b 50 	lds	r24, 0x507B
    6542:	80 95       	com	r24
    6544:	80 93 68 50 	sts	0x5068, r24
    6548:	08 c0       	rjmp	.+16     	; 0x655a <PortEx_DIRSET+0x6c>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    654a:	81 e0       	ldi	r24, 0x01	; 1
    654c:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = ~bankB_DIR;
    6550:	80 91 d6 50 	lds	r24, 0x50D6
    6554:	80 95       	com	r24
    6556:	80 93 68 50 	sts	0x5068, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    655a:	19 82       	std	Y+1, r1	; 0x01
    655c:	1b c0       	rjmp	.+54     	; 0x6594 <PortEx_DIRSET+0xa6>
		SPIC.DATA = SPIBuffer[bufIndex];
    655e:	80 ec       	ldi	r24, 0xC0	; 192
    6560:	98 e0       	ldi	r25, 0x08	; 8
    6562:	29 81       	ldd	r18, Y+1	; 0x01
    6564:	22 2f       	mov	r18, r18
    6566:	30 e0       	ldi	r19, 0x00	; 0
    6568:	2a 59       	subi	r18, 0x9A	; 154
    656a:	3f 4a       	sbci	r19, 0xAF	; 175
    656c:	f9 01       	movw	r30, r18
    656e:	20 81       	ld	r18, Z
    6570:	fc 01       	movw	r30, r24
    6572:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    6574:	00 00       	nop
    6576:	80 ec       	ldi	r24, 0xC0	; 192
    6578:	98 e0       	ldi	r25, 0x08	; 8
    657a:	fc 01       	movw	r30, r24
    657c:	82 81       	ldd	r24, Z+2	; 0x02
    657e:	88 23       	and	r24, r24
    6580:	d4 f7       	brge	.-12     	; 0x6576 <PortEx_DIRSET+0x88>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    6582:	80 ec       	ldi	r24, 0xC0	; 192
    6584:	98 e0       	ldi	r25, 0x08	; 8
    6586:	fc 01       	movw	r30, r24
    6588:	83 81       	ldd	r24, Z+3	; 0x03
    658a:	80 93 72 50 	sts	0x5072, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    658e:	89 81       	ldd	r24, Y+1	; 0x01
    6590:	8f 5f       	subi	r24, 0xFF	; 255
    6592:	89 83       	std	Y+1, r24	; 0x01
    6594:	89 81       	ldd	r24, Y+1	; 0x01
    6596:	83 30       	cpi	r24, 0x03	; 3
    6598:	10 f3       	brcs	.-60     	; 0x655e <PortEx_DIRSET+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    659a:	80 e0       	ldi	r24, 0x00	; 0
    659c:	0e 94 82 31 	call	0x6304	; 0x6304 <portExCS>
	SPICS(FALSE);
    65a0:	80 e0       	ldi	r24, 0x00	; 0
    65a2:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	SPIDisable();
    65a6:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>


}
    65aa:	23 96       	adiw	r28, 0x03	; 3
    65ac:	cd bf       	out	0x3d, r28	; 61
    65ae:	de bf       	out	0x3e, r29	; 62
    65b0:	df 91       	pop	r29
    65b2:	cf 91       	pop	r28
    65b4:	08 95       	ret

000065b6 <PortEx_DIRCLR>:

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    65b6:	cf 93       	push	r28
    65b8:	df 93       	push	r29
    65ba:	00 d0       	rcall	.+0      	; 0x65bc <PortEx_DIRCLR+0x6>
    65bc:	cd b7       	in	r28, 0x3d	; 61
    65be:	de b7       	in	r29, 0x3e	; 62
    65c0:	8a 83       	std	Y+2, r24	; 0x02
    65c2:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    65c4:	80 e0       	ldi	r24, 0x00	; 0
    65c6:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>
	SPICS(TRUE);
    65ca:	81 e0       	ldi	r24, 0x01	; 1
    65cc:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	portExCS(TRUE);
    65d0:	81 e0       	ldi	r24, 0x01	; 1
    65d2:	0e 94 82 31 	call	0x6304	; 0x6304 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    65d6:	8b 81       	ldd	r24, Y+3	; 0x03
    65d8:	88 23       	and	r24, r24
    65da:	49 f0       	breq	.+18     	; 0x65ee <PortEx_DIRCLR+0x38>
    65dc:	80 91 7b 50 	lds	r24, 0x507B
    65e0:	98 2f       	mov	r25, r24
    65e2:	90 95       	com	r25
    65e4:	8a 81       	ldd	r24, Y+2	; 0x02
    65e6:	89 23       	and	r24, r25
    65e8:	80 93 7b 50 	sts	0x507B, r24
    65ec:	08 c0       	rjmp	.+16     	; 0x65fe <PortEx_DIRCLR+0x48>
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    65ee:	80 91 d6 50 	lds	r24, 0x50D6
    65f2:	98 2f       	mov	r25, r24
    65f4:	90 95       	com	r25
    65f6:	8a 81       	ldd	r24, Y+2	; 0x02
    65f8:	89 23       	and	r24, r25
    65fa:	80 93 d6 50 	sts	0x50D6, r24
	
	SPIBuffer[0] = PS_WRITE;
    65fe:	80 e4       	ldi	r24, 0x40	; 64
    6600:	80 93 66 50 	sts	0x5066, r24
	if(bank) {
    6604:	8b 81       	ldd	r24, Y+3	; 0x03
    6606:	88 23       	and	r24, r24
    6608:	41 f0       	breq	.+16     	; 0x661a <PortEx_DIRCLR+0x64>
		SPIBuffer[1]=PS_IODIRA;
    660a:	10 92 67 50 	sts	0x5067, r1
		SPIBuffer[2] = ~bankA_DIR; 
    660e:	80 91 7b 50 	lds	r24, 0x507B
    6612:	80 95       	com	r24
    6614:	80 93 68 50 	sts	0x5068, r24
    6618:	08 c0       	rjmp	.+16     	; 0x662a <PortEx_DIRCLR+0x74>
	} else {
		SPIBuffer[1]=PS_IODIRB;
    661a:	81 e0       	ldi	r24, 0x01	; 1
    661c:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = ~bankB_DIR;
    6620:	80 91 d6 50 	lds	r24, 0x50D6
    6624:	80 95       	com	r24
    6626:	80 93 68 50 	sts	0x5068, r24
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    662a:	19 82       	std	Y+1, r1	; 0x01
    662c:	1b c0       	rjmp	.+54     	; 0x6664 <PortEx_DIRCLR+0xae>
		SPIC.DATA = SPIBuffer[bufIndex];
    662e:	80 ec       	ldi	r24, 0xC0	; 192
    6630:	98 e0       	ldi	r25, 0x08	; 8
    6632:	29 81       	ldd	r18, Y+1	; 0x01
    6634:	22 2f       	mov	r18, r18
    6636:	30 e0       	ldi	r19, 0x00	; 0
    6638:	2a 59       	subi	r18, 0x9A	; 154
    663a:	3f 4a       	sbci	r19, 0xAF	; 175
    663c:	f9 01       	movw	r30, r18
    663e:	20 81       	ld	r18, Z
    6640:	fc 01       	movw	r30, r24
    6642:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6644:	00 00       	nop
    6646:	80 ec       	ldi	r24, 0xC0	; 192
    6648:	98 e0       	ldi	r25, 0x08	; 8
    664a:	fc 01       	movw	r30, r24
    664c:	82 81       	ldd	r24, Z+2	; 0x02
    664e:	88 23       	and	r24, r24
    6650:	d4 f7       	brge	.-12     	; 0x6646 <PortEx_DIRCLR+0x90>
		SPIBuffer[12] = SPIC.DATA;
    6652:	80 ec       	ldi	r24, 0xC0	; 192
    6654:	98 e0       	ldi	r25, 0x08	; 8
    6656:	fc 01       	movw	r30, r24
    6658:	83 81       	ldd	r24, Z+3	; 0x03
    665a:	80 93 72 50 	sts	0x5072, r24
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    665e:	89 81       	ldd	r24, Y+1	; 0x01
    6660:	8f 5f       	subi	r24, 0xFF	; 255
    6662:	89 83       	std	Y+1, r24	; 0x01
    6664:	89 81       	ldd	r24, Y+1	; 0x01
    6666:	83 30       	cpi	r24, 0x03	; 3
    6668:	10 f3       	brcs	.-60     	; 0x662e <PortEx_DIRCLR+0x78>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    666a:	80 e0       	ldi	r24, 0x00	; 0
    666c:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	portExCS(FALSE);
    6670:	80 e0       	ldi	r24, 0x00	; 0
    6672:	0e 94 82 31 	call	0x6304	; 0x6304 <portExCS>
	SPIDisable();
    6676:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>
}
    667a:	23 96       	adiw	r28, 0x03	; 3
    667c:	cd bf       	out	0x3d, r28	; 61
    667e:	de bf       	out	0x3e, r29	; 62
    6680:	df 91       	pop	r29
    6682:	cf 91       	pop	r28
    6684:	08 95       	ret

00006686 <PortEx_OUTSET>:

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    6686:	cf 93       	push	r28
    6688:	df 93       	push	r29
    668a:	00 d0       	rcall	.+0      	; 0x668c <PortEx_OUTSET+0x6>
    668c:	cd b7       	in	r28, 0x3d	; 61
    668e:	de b7       	in	r29, 0x3e	; 62
    6690:	8a 83       	std	Y+2, r24	; 0x02
    6692:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    6694:	80 e0       	ldi	r24, 0x00	; 0
    6696:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>
	SPICS(TRUE);
    669a:	81 e0       	ldi	r24, 0x01	; 1
    669c:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	portExCS(TRUE);
    66a0:	81 e0       	ldi	r24, 0x01	; 1
    66a2:	0e 94 82 31 	call	0x6304	; 0x6304 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    66a6:	8b 81       	ldd	r24, Y+3	; 0x03
    66a8:	88 23       	and	r24, r24
    66aa:	39 f0       	breq	.+14     	; 0x66ba <PortEx_OUTSET+0x34>
    66ac:	90 91 cf 23 	lds	r25, 0x23CF
    66b0:	8a 81       	ldd	r24, Y+2	; 0x02
    66b2:	89 2b       	or	r24, r25
    66b4:	80 93 cf 23 	sts	0x23CF, r24
    66b8:	06 c0       	rjmp	.+12     	; 0x66c6 <PortEx_OUTSET+0x40>
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    66ba:	90 91 83 50 	lds	r25, 0x5083
    66be:	8a 81       	ldd	r24, Y+2	; 0x02
    66c0:	89 2b       	or	r24, r25
    66c2:	80 93 83 50 	sts	0x5083, r24
	
	SPIBuffer[0] = PS_WRITE;
    66c6:	80 e4       	ldi	r24, 0x40	; 64
    66c8:	80 93 66 50 	sts	0x5066, r24
	if(bank) {
    66cc:	8b 81       	ldd	r24, Y+3	; 0x03
    66ce:	88 23       	and	r24, r24
    66d0:	41 f0       	breq	.+16     	; 0x66e2 <PortEx_OUTSET+0x5c>
		SPIBuffer[1]=PS_OLATA;
    66d2:	84 e1       	ldi	r24, 0x14	; 20
    66d4:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = bankA_OUT;
    66d8:	80 91 cf 23 	lds	r24, 0x23CF
    66dc:	80 93 68 50 	sts	0x5068, r24
    66e0:	07 c0       	rjmp	.+14     	; 0x66f0 <PortEx_OUTSET+0x6a>
	} else {
		SPIBuffer[1]=PS_OLATB;
    66e2:	85 e1       	ldi	r24, 0x15	; 21
    66e4:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = bankB_OUT; 
    66e8:	80 91 83 50 	lds	r24, 0x5083
    66ec:	80 93 68 50 	sts	0x5068, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    66f0:	19 82       	std	Y+1, r1	; 0x01
    66f2:	1b c0       	rjmp	.+54     	; 0x672a <PortEx_OUTSET+0xa4>
		SPIC.DATA = SPIBuffer[bufIndex];
    66f4:	80 ec       	ldi	r24, 0xC0	; 192
    66f6:	98 e0       	ldi	r25, 0x08	; 8
    66f8:	29 81       	ldd	r18, Y+1	; 0x01
    66fa:	22 2f       	mov	r18, r18
    66fc:	30 e0       	ldi	r19, 0x00	; 0
    66fe:	2a 59       	subi	r18, 0x9A	; 154
    6700:	3f 4a       	sbci	r19, 0xAF	; 175
    6702:	f9 01       	movw	r30, r18
    6704:	20 81       	ld	r18, Z
    6706:	fc 01       	movw	r30, r24
    6708:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    670a:	00 00       	nop
    670c:	80 ec       	ldi	r24, 0xC0	; 192
    670e:	98 e0       	ldi	r25, 0x08	; 8
    6710:	fc 01       	movw	r30, r24
    6712:	82 81       	ldd	r24, Z+2	; 0x02
    6714:	88 23       	and	r24, r24
    6716:	d4 f7       	brge	.-12     	; 0x670c <PortEx_OUTSET+0x86>
		SPIBuffer[12] = SPIC.DATA;
    6718:	80 ec       	ldi	r24, 0xC0	; 192
    671a:	98 e0       	ldi	r25, 0x08	; 8
    671c:	fc 01       	movw	r30, r24
    671e:	83 81       	ldd	r24, Z+3	; 0x03
    6720:	80 93 72 50 	sts	0x5072, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    6724:	89 81       	ldd	r24, Y+1	; 0x01
    6726:	8f 5f       	subi	r24, 0xFF	; 255
    6728:	89 83       	std	Y+1, r24	; 0x01
    672a:	89 81       	ldd	r24, Y+1	; 0x01
    672c:	83 30       	cpi	r24, 0x03	; 3
    672e:	10 f3       	brcs	.-60     	; 0x66f4 <PortEx_OUTSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    6730:	80 e0       	ldi	r24, 0x00	; 0
    6732:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	portExCS(FALSE);
    6736:	80 e0       	ldi	r24, 0x00	; 0
    6738:	0e 94 82 31 	call	0x6304	; 0x6304 <portExCS>
	SPIDisable();
    673c:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>
}
    6740:	23 96       	adiw	r28, 0x03	; 3
    6742:	cd bf       	out	0x3d, r28	; 61
    6744:	de bf       	out	0x3e, r29	; 62
    6746:	df 91       	pop	r29
    6748:	cf 91       	pop	r28
    674a:	08 95       	ret

0000674c <PortEx_OUTCLR>:


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    674c:	cf 93       	push	r28
    674e:	df 93       	push	r29
    6750:	00 d0       	rcall	.+0      	; 0x6752 <PortEx_OUTCLR+0x6>
    6752:	cd b7       	in	r28, 0x3d	; 61
    6754:	de b7       	in	r29, 0x3e	; 62
    6756:	8a 83       	std	Y+2, r24	; 0x02
    6758:	6b 83       	std	Y+3, r22	; 0x03
	SPIInit(PS_SPI_MODE);
    675a:	80 e0       	ldi	r24, 0x00	; 0
    675c:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>
	SPICS(TRUE);
    6760:	81 e0       	ldi	r24, 0x01	; 1
    6762:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	portExCS(TRUE);
    6766:	81 e0       	ldi	r24, 0x01	; 1
    6768:	0e 94 82 31 	call	0x6304	; 0x6304 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    676c:	8b 81       	ldd	r24, Y+3	; 0x03
    676e:	88 23       	and	r24, r24
    6770:	49 f0       	breq	.+18     	; 0x6784 <PortEx_OUTCLR+0x38>
    6772:	8a 81       	ldd	r24, Y+2	; 0x02
    6774:	98 2f       	mov	r25, r24
    6776:	90 95       	com	r25
    6778:	80 91 cf 23 	lds	r24, 0x23CF
    677c:	89 23       	and	r24, r25
    677e:	80 93 cf 23 	sts	0x23CF, r24
    6782:	08 c0       	rjmp	.+16     	; 0x6794 <PortEx_OUTCLR+0x48>
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    6784:	8a 81       	ldd	r24, Y+2	; 0x02
    6786:	98 2f       	mov	r25, r24
    6788:	90 95       	com	r25
    678a:	80 91 83 50 	lds	r24, 0x5083
    678e:	89 23       	and	r24, r25
    6790:	80 93 83 50 	sts	0x5083, r24
	
	SPIBuffer[0] = PS_WRITE;
    6794:	80 e4       	ldi	r24, 0x40	; 64
    6796:	80 93 66 50 	sts	0x5066, r24
	if(bank) {
    679a:	8b 81       	ldd	r24, Y+3	; 0x03
    679c:	88 23       	and	r24, r24
    679e:	41 f0       	breq	.+16     	; 0x67b0 <PortEx_OUTCLR+0x64>
		SPIBuffer[1]=PS_OLATA;
    67a0:	84 e1       	ldi	r24, 0x14	; 20
    67a2:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = bankA_OUT;
    67a6:	80 91 cf 23 	lds	r24, 0x23CF
    67aa:	80 93 68 50 	sts	0x5068, r24
    67ae:	07 c0       	rjmp	.+14     	; 0x67be <PortEx_OUTCLR+0x72>
	} else {
		SPIBuffer[1]=PS_OLATB;
    67b0:	85 e1       	ldi	r24, 0x15	; 21
    67b2:	80 93 67 50 	sts	0x5067, r24
		SPIBuffer[2] = bankB_OUT; 
    67b6:	80 91 83 50 	lds	r24, 0x5083
    67ba:	80 93 68 50 	sts	0x5068, r24
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    67be:	19 82       	std	Y+1, r1	; 0x01
    67c0:	1b c0       	rjmp	.+54     	; 0x67f8 <PortEx_OUTCLR+0xac>
		SPIC.DATA = SPIBuffer[bufIndex];
    67c2:	80 ec       	ldi	r24, 0xC0	; 192
    67c4:	98 e0       	ldi	r25, 0x08	; 8
    67c6:	29 81       	ldd	r18, Y+1	; 0x01
    67c8:	22 2f       	mov	r18, r18
    67ca:	30 e0       	ldi	r19, 0x00	; 0
    67cc:	2a 59       	subi	r18, 0x9A	; 154
    67ce:	3f 4a       	sbci	r19, 0xAF	; 175
    67d0:	f9 01       	movw	r30, r18
    67d2:	20 81       	ld	r18, Z
    67d4:	fc 01       	movw	r30, r24
    67d6:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    67d8:	00 00       	nop
    67da:	80 ec       	ldi	r24, 0xC0	; 192
    67dc:	98 e0       	ldi	r25, 0x08	; 8
    67de:	fc 01       	movw	r30, r24
    67e0:	82 81       	ldd	r24, Z+2	; 0x02
    67e2:	88 23       	and	r24, r24
    67e4:	d4 f7       	brge	.-12     	; 0x67da <PortEx_OUTCLR+0x8e>
		SPIBuffer[12] = SPIC.DATA;
    67e6:	80 ec       	ldi	r24, 0xC0	; 192
    67e8:	98 e0       	ldi	r25, 0x08	; 8
    67ea:	fc 01       	movw	r30, r24
    67ec:	83 81       	ldd	r24, Z+3	; 0x03
    67ee:	80 93 72 50 	sts	0x5072, r24
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    67f2:	89 81       	ldd	r24, Y+1	; 0x01
    67f4:	8f 5f       	subi	r24, 0xFF	; 255
    67f6:	89 83       	std	Y+1, r24	; 0x01
    67f8:	89 81       	ldd	r24, Y+1	; 0x01
    67fa:	83 30       	cpi	r24, 0x03	; 3
    67fc:	10 f3       	brcs	.-60     	; 0x67c2 <PortEx_OUTCLR+0x76>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    67fe:	80 e0       	ldi	r24, 0x00	; 0
    6800:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	portExCS(FALSE);
    6804:	80 e0       	ldi	r24, 0x00	; 0
    6806:	0e 94 82 31 	call	0x6304	; 0x6304 <portExCS>
	SPIDisable();
    680a:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>
}
    680e:	23 96       	adiw	r28, 0x03	; 3
    6810:	cd bf       	out	0x3d, r28	; 61
    6812:	de bf       	out	0x3e, r29	; 62
    6814:	df 91       	pop	r29
    6816:	cf 91       	pop	r28
    6818:	08 95       	ret

0000681a <Ext1Power>:
	SPIDisable();
}
*/


void Ext1Power(uint8_t on) {
    681a:	0f 93       	push	r16
    681c:	1f 93       	push	r17
    681e:	cf 93       	push	r28
    6820:	df 93       	push	r29
    6822:	cd b7       	in	r28, 0x3d	; 61
    6824:	de b7       	in	r29, 0x3e	; 62
    6826:	2f 97       	sbiw	r28, 0x0f	; 15
    6828:	cd bf       	out	0x3d, r28	; 61
    682a:	de bf       	out	0x3e, r29	; 62
    682c:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    682e:	8f 85       	ldd	r24, Y+15	; 0x0f
    6830:	88 23       	and	r24, r24
    6832:	09 f4       	brne	.+2      	; 0x6836 <Ext1Power+0x1c>
    6834:	8b c0       	rjmp	.+278    	; 0x694c <Ext1Power+0x132>
		PORTF.DIRSET = PIN5_bm;
    6836:	80 ea       	ldi	r24, 0xA0	; 160
    6838:	96 e0       	ldi	r25, 0x06	; 6
    683a:	20 e2       	ldi	r18, 0x20	; 32
    683c:	fc 01       	movw	r30, r24
    683e:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN5_bm;
    6840:	80 ea       	ldi	r24, 0xA0	; 160
    6842:	96 e0       	ldi	r25, 0x06	; 6
    6844:	20 e2       	ldi	r18, 0x20	; 32
    6846:	fc 01       	movw	r30, r24
    6848:	25 83       	std	Z+5, r18	; 0x05
    684a:	80 e0       	ldi	r24, 0x00	; 0
    684c:	90 e0       	ldi	r25, 0x00	; 0
    684e:	a8 ec       	ldi	r26, 0xC8	; 200
    6850:	b2 e4       	ldi	r27, 0x42	; 66
    6852:	89 83       	std	Y+1, r24	; 0x01
    6854:	9a 83       	std	Y+2, r25	; 0x02
    6856:	ab 83       	std	Y+3, r26	; 0x03
    6858:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    685a:	69 81       	ldd	r22, Y+1	; 0x01
    685c:	7a 81       	ldd	r23, Y+2	; 0x02
    685e:	8b 81       	ldd	r24, Y+3	; 0x03
    6860:	9c 81       	ldd	r25, Y+4	; 0x04
    6862:	20 e0       	ldi	r18, 0x00	; 0
    6864:	30 e0       	ldi	r19, 0x00	; 0
    6866:	4a ef       	ldi	r20, 0xFA	; 250
    6868:	55 e4       	ldi	r21, 0x45	; 69
    686a:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    686e:	dc 01       	movw	r26, r24
    6870:	cb 01       	movw	r24, r22
    6872:	8d 83       	std	Y+5, r24	; 0x05
    6874:	9e 83       	std	Y+6, r25	; 0x06
    6876:	af 83       	std	Y+7, r26	; 0x07
    6878:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    687a:	11 e0       	ldi	r17, 0x01	; 1
    687c:	6d 81       	ldd	r22, Y+5	; 0x05
    687e:	7e 81       	ldd	r23, Y+6	; 0x06
    6880:	8f 81       	ldd	r24, Y+7	; 0x07
    6882:	98 85       	ldd	r25, Y+8	; 0x08
    6884:	20 e0       	ldi	r18, 0x00	; 0
    6886:	30 e0       	ldi	r19, 0x00	; 0
    6888:	40 e8       	ldi	r20, 0x80	; 128
    688a:	5f e3       	ldi	r21, 0x3F	; 63
    688c:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    6890:	88 23       	and	r24, r24
    6892:	0c f0       	brlt	.+2      	; 0x6896 <Ext1Power+0x7c>
    6894:	10 e0       	ldi	r17, 0x00	; 0
    6896:	11 23       	and	r17, r17
    6898:	29 f0       	breq	.+10     	; 0x68a4 <Ext1Power+0x8a>
		__ticks = 1;
    689a:	81 e0       	ldi	r24, 0x01	; 1
    689c:	90 e0       	ldi	r25, 0x00	; 0
    689e:	89 87       	std	Y+9, r24	; 0x09
    68a0:	9a 87       	std	Y+10, r25	; 0x0a
    68a2:	46 c0       	rjmp	.+140    	; 0x6930 <Ext1Power+0x116>
	else if (__tmp > 65535)
    68a4:	11 e0       	ldi	r17, 0x01	; 1
    68a6:	6d 81       	ldd	r22, Y+5	; 0x05
    68a8:	7e 81       	ldd	r23, Y+6	; 0x06
    68aa:	8f 81       	ldd	r24, Y+7	; 0x07
    68ac:	98 85       	ldd	r25, Y+8	; 0x08
    68ae:	20 e0       	ldi	r18, 0x00	; 0
    68b0:	3f ef       	ldi	r19, 0xFF	; 255
    68b2:	4f e7       	ldi	r20, 0x7F	; 127
    68b4:	57 e4       	ldi	r21, 0x47	; 71
    68b6:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    68ba:	18 16       	cp	r1, r24
    68bc:	0c f0       	brlt	.+2      	; 0x68c0 <Ext1Power+0xa6>
    68be:	10 e0       	ldi	r17, 0x00	; 0
    68c0:	11 23       	and	r17, r17
    68c2:	61 f1       	breq	.+88     	; 0x691c <Ext1Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    68c4:	69 81       	ldd	r22, Y+1	; 0x01
    68c6:	7a 81       	ldd	r23, Y+2	; 0x02
    68c8:	8b 81       	ldd	r24, Y+3	; 0x03
    68ca:	9c 81       	ldd	r25, Y+4	; 0x04
    68cc:	20 e0       	ldi	r18, 0x00	; 0
    68ce:	30 e0       	ldi	r19, 0x00	; 0
    68d0:	40 e2       	ldi	r20, 0x20	; 32
    68d2:	51 e4       	ldi	r21, 0x41	; 65
    68d4:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    68d8:	dc 01       	movw	r26, r24
    68da:	cb 01       	movw	r24, r22
    68dc:	bc 01       	movw	r22, r24
    68de:	cd 01       	movw	r24, r26
    68e0:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    68e4:	dc 01       	movw	r26, r24
    68e6:	cb 01       	movw	r24, r22
    68e8:	89 87       	std	Y+9, r24	; 0x09
    68ea:	9a 87       	std	Y+10, r25	; 0x0a
    68ec:	12 c0       	rjmp	.+36     	; 0x6912 <Ext1Power+0xf8>
    68ee:	80 e2       	ldi	r24, 0x20	; 32
    68f0:	93 e0       	ldi	r25, 0x03	; 3
    68f2:	8b 87       	std	Y+11, r24	; 0x0b
    68f4:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    68f6:	8b 85       	ldd	r24, Y+11	; 0x0b
    68f8:	9c 85       	ldd	r25, Y+12	; 0x0c
    68fa:	8c 01       	movw	r16, r24
    68fc:	c8 01       	movw	r24, r16
    68fe:	01 97       	sbiw	r24, 0x01	; 1
    6900:	f1 f7       	brne	.-4      	; 0x68fe <Ext1Power+0xe4>
    6902:	8c 01       	movw	r16, r24
    6904:	0b 87       	std	Y+11, r16	; 0x0b
    6906:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6908:	89 85       	ldd	r24, Y+9	; 0x09
    690a:	9a 85       	ldd	r25, Y+10	; 0x0a
    690c:	01 97       	sbiw	r24, 0x01	; 1
    690e:	89 87       	std	Y+9, r24	; 0x09
    6910:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6912:	89 85       	ldd	r24, Y+9	; 0x09
    6914:	9a 85       	ldd	r25, Y+10	; 0x0a
    6916:	00 97       	sbiw	r24, 0x00	; 0
    6918:	51 f7       	brne	.-44     	; 0x68ee <Ext1Power+0xd4>
    691a:	22 c0       	rjmp	.+68     	; 0x6960 <Ext1Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    691c:	6d 81       	ldd	r22, Y+5	; 0x05
    691e:	7e 81       	ldd	r23, Y+6	; 0x06
    6920:	8f 81       	ldd	r24, Y+7	; 0x07
    6922:	98 85       	ldd	r25, Y+8	; 0x08
    6924:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    6928:	dc 01       	movw	r26, r24
    692a:	cb 01       	movw	r24, r22
    692c:	89 87       	std	Y+9, r24	; 0x09
    692e:	9a 87       	std	Y+10, r25	; 0x0a
    6930:	89 85       	ldd	r24, Y+9	; 0x09
    6932:	9a 85       	ldd	r25, Y+10	; 0x0a
    6934:	8d 87       	std	Y+13, r24	; 0x0d
    6936:	9e 87       	std	Y+14, r25	; 0x0e
    6938:	8d 85       	ldd	r24, Y+13	; 0x0d
    693a:	9e 85       	ldd	r25, Y+14	; 0x0e
    693c:	8c 01       	movw	r16, r24
    693e:	f8 01       	movw	r30, r16
    6940:	31 97       	sbiw	r30, 0x01	; 1
    6942:	f1 f7       	brne	.-4      	; 0x6940 <Ext1Power+0x126>
    6944:	8f 01       	movw	r16, r30
    6946:	0d 87       	std	Y+13, r16	; 0x0d
    6948:	1e 87       	std	Y+14, r17	; 0x0e
    694a:	0a c0       	rjmp	.+20     	; 0x6960 <Ext1Power+0x146>
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    694c:	80 ea       	ldi	r24, 0xA0	; 160
    694e:	96 e0       	ldi	r25, 0x06	; 6
    6950:	20 e2       	ldi	r18, 0x20	; 32
    6952:	fc 01       	movw	r30, r24
    6954:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    6956:	80 ea       	ldi	r24, 0xA0	; 160
    6958:	96 e0       	ldi	r25, 0x06	; 6
    695a:	20 e2       	ldi	r18, 0x20	; 32
    695c:	fc 01       	movw	r30, r24
    695e:	22 83       	std	Z+2, r18	; 0x02
		//PortEx_OUTCLR(PIN3_bm, PS_BANKB);  //no need to write protect SDHC
	}
}
    6960:	2f 96       	adiw	r28, 0x0f	; 15
    6962:	cd bf       	out	0x3d, r28	; 61
    6964:	de bf       	out	0x3e, r29	; 62
    6966:	df 91       	pop	r29
    6968:	cf 91       	pop	r28
    696a:	1f 91       	pop	r17
    696c:	0f 91       	pop	r16
    696e:	08 95       	ret

00006970 <Ext2Power>:

void Ext2Power(uint8_t on) {
    6970:	0f 93       	push	r16
    6972:	1f 93       	push	r17
    6974:	cf 93       	push	r28
    6976:	df 93       	push	r29
    6978:	cd b7       	in	r28, 0x3d	; 61
    697a:	de b7       	in	r29, 0x3e	; 62
    697c:	2f 97       	sbiw	r28, 0x0f	; 15
    697e:	cd bf       	out	0x3d, r28	; 61
    6980:	de bf       	out	0x3e, r29	; 62
    6982:	8f 87       	std	Y+15, r24	; 0x0f
	if (on) {
    6984:	8f 85       	ldd	r24, Y+15	; 0x0f
    6986:	88 23       	and	r24, r24
    6988:	09 f4       	brne	.+2      	; 0x698c <Ext2Power+0x1c>
    698a:	8b c0       	rjmp	.+278    	; 0x6aa2 <Ext2Power+0x132>
		PORTF.DIRSET = PIN6_bm;
    698c:	80 ea       	ldi	r24, 0xA0	; 160
    698e:	96 e0       	ldi	r25, 0x06	; 6
    6990:	20 e4       	ldi	r18, 0x40	; 64
    6992:	fc 01       	movw	r30, r24
    6994:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN6_bm;
    6996:	80 ea       	ldi	r24, 0xA0	; 160
    6998:	96 e0       	ldi	r25, 0x06	; 6
    699a:	20 e4       	ldi	r18, 0x40	; 64
    699c:	fc 01       	movw	r30, r24
    699e:	25 83       	std	Z+5, r18	; 0x05
    69a0:	80 e0       	ldi	r24, 0x00	; 0
    69a2:	90 e0       	ldi	r25, 0x00	; 0
    69a4:	a8 ec       	ldi	r26, 0xC8	; 200
    69a6:	b2 e4       	ldi	r27, 0x42	; 66
    69a8:	89 83       	std	Y+1, r24	; 0x01
    69aa:	9a 83       	std	Y+2, r25	; 0x02
    69ac:	ab 83       	std	Y+3, r26	; 0x03
    69ae:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    69b0:	69 81       	ldd	r22, Y+1	; 0x01
    69b2:	7a 81       	ldd	r23, Y+2	; 0x02
    69b4:	8b 81       	ldd	r24, Y+3	; 0x03
    69b6:	9c 81       	ldd	r25, Y+4	; 0x04
    69b8:	20 e0       	ldi	r18, 0x00	; 0
    69ba:	30 e0       	ldi	r19, 0x00	; 0
    69bc:	4a ef       	ldi	r20, 0xFA	; 250
    69be:	55 e4       	ldi	r21, 0x45	; 69
    69c0:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    69c4:	dc 01       	movw	r26, r24
    69c6:	cb 01       	movw	r24, r22
    69c8:	8d 83       	std	Y+5, r24	; 0x05
    69ca:	9e 83       	std	Y+6, r25	; 0x06
    69cc:	af 83       	std	Y+7, r26	; 0x07
    69ce:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    69d0:	11 e0       	ldi	r17, 0x01	; 1
    69d2:	6d 81       	ldd	r22, Y+5	; 0x05
    69d4:	7e 81       	ldd	r23, Y+6	; 0x06
    69d6:	8f 81       	ldd	r24, Y+7	; 0x07
    69d8:	98 85       	ldd	r25, Y+8	; 0x08
    69da:	20 e0       	ldi	r18, 0x00	; 0
    69dc:	30 e0       	ldi	r19, 0x00	; 0
    69de:	40 e8       	ldi	r20, 0x80	; 128
    69e0:	5f e3       	ldi	r21, 0x3F	; 63
    69e2:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    69e6:	88 23       	and	r24, r24
    69e8:	0c f0       	brlt	.+2      	; 0x69ec <Ext2Power+0x7c>
    69ea:	10 e0       	ldi	r17, 0x00	; 0
    69ec:	11 23       	and	r17, r17
    69ee:	29 f0       	breq	.+10     	; 0x69fa <Ext2Power+0x8a>
		__ticks = 1;
    69f0:	81 e0       	ldi	r24, 0x01	; 1
    69f2:	90 e0       	ldi	r25, 0x00	; 0
    69f4:	89 87       	std	Y+9, r24	; 0x09
    69f6:	9a 87       	std	Y+10, r25	; 0x0a
    69f8:	46 c0       	rjmp	.+140    	; 0x6a86 <Ext2Power+0x116>
	else if (__tmp > 65535)
    69fa:	11 e0       	ldi	r17, 0x01	; 1
    69fc:	6d 81       	ldd	r22, Y+5	; 0x05
    69fe:	7e 81       	ldd	r23, Y+6	; 0x06
    6a00:	8f 81       	ldd	r24, Y+7	; 0x07
    6a02:	98 85       	ldd	r25, Y+8	; 0x08
    6a04:	20 e0       	ldi	r18, 0x00	; 0
    6a06:	3f ef       	ldi	r19, 0xFF	; 255
    6a08:	4f e7       	ldi	r20, 0x7F	; 127
    6a0a:	57 e4       	ldi	r21, 0x47	; 71
    6a0c:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    6a10:	18 16       	cp	r1, r24
    6a12:	0c f0       	brlt	.+2      	; 0x6a16 <Ext2Power+0xa6>
    6a14:	10 e0       	ldi	r17, 0x00	; 0
    6a16:	11 23       	and	r17, r17
    6a18:	61 f1       	breq	.+88     	; 0x6a72 <Ext2Power+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6a1a:	69 81       	ldd	r22, Y+1	; 0x01
    6a1c:	7a 81       	ldd	r23, Y+2	; 0x02
    6a1e:	8b 81       	ldd	r24, Y+3	; 0x03
    6a20:	9c 81       	ldd	r25, Y+4	; 0x04
    6a22:	20 e0       	ldi	r18, 0x00	; 0
    6a24:	30 e0       	ldi	r19, 0x00	; 0
    6a26:	40 e2       	ldi	r20, 0x20	; 32
    6a28:	51 e4       	ldi	r21, 0x41	; 65
    6a2a:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    6a2e:	dc 01       	movw	r26, r24
    6a30:	cb 01       	movw	r24, r22
    6a32:	bc 01       	movw	r22, r24
    6a34:	cd 01       	movw	r24, r26
    6a36:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    6a3a:	dc 01       	movw	r26, r24
    6a3c:	cb 01       	movw	r24, r22
    6a3e:	89 87       	std	Y+9, r24	; 0x09
    6a40:	9a 87       	std	Y+10, r25	; 0x0a
    6a42:	12 c0       	rjmp	.+36     	; 0x6a68 <Ext2Power+0xf8>
    6a44:	80 e2       	ldi	r24, 0x20	; 32
    6a46:	93 e0       	ldi	r25, 0x03	; 3
    6a48:	8b 87       	std	Y+11, r24	; 0x0b
    6a4a:	9c 87       	std	Y+12, r25	; 0x0c
    6a4c:	8b 85       	ldd	r24, Y+11	; 0x0b
    6a4e:	9c 85       	ldd	r25, Y+12	; 0x0c
    6a50:	8c 01       	movw	r16, r24
    6a52:	c8 01       	movw	r24, r16
    6a54:	01 97       	sbiw	r24, 0x01	; 1
    6a56:	f1 f7       	brne	.-4      	; 0x6a54 <Ext2Power+0xe4>
    6a58:	8c 01       	movw	r16, r24
    6a5a:	0b 87       	std	Y+11, r16	; 0x0b
    6a5c:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6a5e:	89 85       	ldd	r24, Y+9	; 0x09
    6a60:	9a 85       	ldd	r25, Y+10	; 0x0a
    6a62:	01 97       	sbiw	r24, 0x01	; 1
    6a64:	89 87       	std	Y+9, r24	; 0x09
    6a66:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6a68:	89 85       	ldd	r24, Y+9	; 0x09
    6a6a:	9a 85       	ldd	r25, Y+10	; 0x0a
    6a6c:	00 97       	sbiw	r24, 0x00	; 0
    6a6e:	51 f7       	brne	.-44     	; 0x6a44 <Ext2Power+0xd4>
    6a70:	22 c0       	rjmp	.+68     	; 0x6ab6 <Ext2Power+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6a72:	6d 81       	ldd	r22, Y+5	; 0x05
    6a74:	7e 81       	ldd	r23, Y+6	; 0x06
    6a76:	8f 81       	ldd	r24, Y+7	; 0x07
    6a78:	98 85       	ldd	r25, Y+8	; 0x08
    6a7a:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    6a7e:	dc 01       	movw	r26, r24
    6a80:	cb 01       	movw	r24, r22
    6a82:	89 87       	std	Y+9, r24	; 0x09
    6a84:	9a 87       	std	Y+10, r25	; 0x0a
    6a86:	89 85       	ldd	r24, Y+9	; 0x09
    6a88:	9a 85       	ldd	r25, Y+10	; 0x0a
    6a8a:	8d 87       	std	Y+13, r24	; 0x0d
    6a8c:	9e 87       	std	Y+14, r25	; 0x0e
    6a8e:	8d 85       	ldd	r24, Y+13	; 0x0d
    6a90:	9e 85       	ldd	r25, Y+14	; 0x0e
    6a92:	8c 01       	movw	r16, r24
    6a94:	f8 01       	movw	r30, r16
    6a96:	31 97       	sbiw	r30, 0x01	; 1
    6a98:	f1 f7       	brne	.-4      	; 0x6a96 <Ext2Power+0x126>
    6a9a:	8f 01       	movw	r16, r30
    6a9c:	0d 87       	std	Y+13, r16	; 0x0d
    6a9e:	1e 87       	std	Y+14, r17	; 0x0e
    6aa0:	0a c0       	rjmp	.+20     	; 0x6ab6 <Ext2Power+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    6aa2:	80 ea       	ldi	r24, 0xA0	; 160
    6aa4:	96 e0       	ldi	r25, 0x06	; 6
    6aa6:	20 e4       	ldi	r18, 0x40	; 64
    6aa8:	fc 01       	movw	r30, r24
    6aaa:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    6aac:	80 ea       	ldi	r24, 0xA0	; 160
    6aae:	96 e0       	ldi	r25, 0x06	; 6
    6ab0:	20 e4       	ldi	r18, 0x40	; 64
    6ab2:	fc 01       	movw	r30, r24
    6ab4:	22 83       	std	Z+2, r18	; 0x02
	}
}
    6ab6:	2f 96       	adiw	r28, 0x0f	; 15
    6ab8:	cd bf       	out	0x3d, r28	; 61
    6aba:	de bf       	out	0x3e, r29	; 62
    6abc:	df 91       	pop	r29
    6abe:	cf 91       	pop	r28
    6ac0:	1f 91       	pop	r17
    6ac2:	0f 91       	pop	r16
    6ac4:	08 95       	ret

00006ac6 <HVPower>:

void HVPower(uint8_t on) {
    6ac6:	0f 93       	push	r16
    6ac8:	1f 93       	push	r17
    6aca:	cf 93       	push	r28
    6acc:	df 93       	push	r29
    6ace:	cd b7       	in	r28, 0x3d	; 61
    6ad0:	de b7       	in	r29, 0x3e	; 62
    6ad2:	a7 97       	sbiw	r28, 0x27	; 39
    6ad4:	cd bf       	out	0x3d, r28	; 61
    6ad6:	de bf       	out	0x3e, r29	; 62
    6ad8:	8f a3       	lds	r24, 0x5f
	if (on) {
    6ada:	8f a1       	lds	r24, 0x4f
    6adc:	88 23       	and	r24, r24
    6ade:	09 f4       	brne	.+2      	; 0x6ae2 <HVPower+0x1c>
    6ae0:	8b c0       	rjmp	.+278    	; 0x6bf8 <HVPower+0x132>
		PORTF.DIRSET = PIN7_bm;
    6ae2:	80 ea       	ldi	r24, 0xA0	; 160
    6ae4:	96 e0       	ldi	r25, 0x06	; 6
    6ae6:	20 e8       	ldi	r18, 0x80	; 128
    6ae8:	fc 01       	movw	r30, r24
    6aea:	21 83       	std	Z+1, r18	; 0x01
		PORTF.OUTSET = PIN7_bm;
    6aec:	80 ea       	ldi	r24, 0xA0	; 160
    6aee:	96 e0       	ldi	r25, 0x06	; 6
    6af0:	20 e8       	ldi	r18, 0x80	; 128
    6af2:	fc 01       	movw	r30, r24
    6af4:	25 83       	std	Z+5, r18	; 0x05
    6af6:	80 e0       	ldi	r24, 0x00	; 0
    6af8:	90 e0       	ldi	r25, 0x00	; 0
    6afa:	a8 ec       	ldi	r26, 0xC8	; 200
    6afc:	b2 e4       	ldi	r27, 0x42	; 66
    6afe:	89 83       	std	Y+1, r24	; 0x01
    6b00:	9a 83       	std	Y+2, r25	; 0x02
    6b02:	ab 83       	std	Y+3, r26	; 0x03
    6b04:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6b06:	69 81       	ldd	r22, Y+1	; 0x01
    6b08:	7a 81       	ldd	r23, Y+2	; 0x02
    6b0a:	8b 81       	ldd	r24, Y+3	; 0x03
    6b0c:	9c 81       	ldd	r25, Y+4	; 0x04
    6b0e:	20 e0       	ldi	r18, 0x00	; 0
    6b10:	30 e0       	ldi	r19, 0x00	; 0
    6b12:	4a ef       	ldi	r20, 0xFA	; 250
    6b14:	55 e4       	ldi	r21, 0x45	; 69
    6b16:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    6b1a:	dc 01       	movw	r26, r24
    6b1c:	cb 01       	movw	r24, r22
    6b1e:	8d 83       	std	Y+5, r24	; 0x05
    6b20:	9e 83       	std	Y+6, r25	; 0x06
    6b22:	af 83       	std	Y+7, r26	; 0x07
    6b24:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    6b26:	11 e0       	ldi	r17, 0x01	; 1
    6b28:	6d 81       	ldd	r22, Y+5	; 0x05
    6b2a:	7e 81       	ldd	r23, Y+6	; 0x06
    6b2c:	8f 81       	ldd	r24, Y+7	; 0x07
    6b2e:	98 85       	ldd	r25, Y+8	; 0x08
    6b30:	20 e0       	ldi	r18, 0x00	; 0
    6b32:	30 e0       	ldi	r19, 0x00	; 0
    6b34:	40 e8       	ldi	r20, 0x80	; 128
    6b36:	5f e3       	ldi	r21, 0x3F	; 63
    6b38:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    6b3c:	88 23       	and	r24, r24
    6b3e:	0c f0       	brlt	.+2      	; 0x6b42 <HVPower+0x7c>
    6b40:	10 e0       	ldi	r17, 0x00	; 0
    6b42:	11 23       	and	r17, r17
    6b44:	29 f0       	breq	.+10     	; 0x6b50 <HVPower+0x8a>
		__ticks = 1;
    6b46:	81 e0       	ldi	r24, 0x01	; 1
    6b48:	90 e0       	ldi	r25, 0x00	; 0
    6b4a:	89 87       	std	Y+9, r24	; 0x09
    6b4c:	9a 87       	std	Y+10, r25	; 0x0a
    6b4e:	46 c0       	rjmp	.+140    	; 0x6bdc <HVPower+0x116>
	else if (__tmp > 65535)
    6b50:	11 e0       	ldi	r17, 0x01	; 1
    6b52:	6d 81       	ldd	r22, Y+5	; 0x05
    6b54:	7e 81       	ldd	r23, Y+6	; 0x06
    6b56:	8f 81       	ldd	r24, Y+7	; 0x07
    6b58:	98 85       	ldd	r25, Y+8	; 0x08
    6b5a:	20 e0       	ldi	r18, 0x00	; 0
    6b5c:	3f ef       	ldi	r19, 0xFF	; 255
    6b5e:	4f e7       	ldi	r20, 0x7F	; 127
    6b60:	57 e4       	ldi	r21, 0x47	; 71
    6b62:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    6b66:	18 16       	cp	r1, r24
    6b68:	0c f0       	brlt	.+2      	; 0x6b6c <HVPower+0xa6>
    6b6a:	10 e0       	ldi	r17, 0x00	; 0
    6b6c:	11 23       	and	r17, r17
    6b6e:	61 f1       	breq	.+88     	; 0x6bc8 <HVPower+0x102>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6b70:	69 81       	ldd	r22, Y+1	; 0x01
    6b72:	7a 81       	ldd	r23, Y+2	; 0x02
    6b74:	8b 81       	ldd	r24, Y+3	; 0x03
    6b76:	9c 81       	ldd	r25, Y+4	; 0x04
    6b78:	20 e0       	ldi	r18, 0x00	; 0
    6b7a:	30 e0       	ldi	r19, 0x00	; 0
    6b7c:	40 e2       	ldi	r20, 0x20	; 32
    6b7e:	51 e4       	ldi	r21, 0x41	; 65
    6b80:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    6b84:	dc 01       	movw	r26, r24
    6b86:	cb 01       	movw	r24, r22
    6b88:	bc 01       	movw	r22, r24
    6b8a:	cd 01       	movw	r24, r26
    6b8c:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    6b90:	dc 01       	movw	r26, r24
    6b92:	cb 01       	movw	r24, r22
    6b94:	89 87       	std	Y+9, r24	; 0x09
    6b96:	9a 87       	std	Y+10, r25	; 0x0a
    6b98:	12 c0       	rjmp	.+36     	; 0x6bbe <HVPower+0xf8>
    6b9a:	80 e2       	ldi	r24, 0x20	; 32
    6b9c:	93 e0       	ldi	r25, 0x03	; 3
    6b9e:	8b 87       	std	Y+11, r24	; 0x0b
    6ba0:	9c 87       	std	Y+12, r25	; 0x0c
    6ba2:	8b 85       	ldd	r24, Y+11	; 0x0b
    6ba4:	9c 85       	ldd	r25, Y+12	; 0x0c
    6ba6:	8c 01       	movw	r16, r24
    6ba8:	c8 01       	movw	r24, r16
    6baa:	01 97       	sbiw	r24, 0x01	; 1
    6bac:	f1 f7       	brne	.-4      	; 0x6baa <HVPower+0xe4>
    6bae:	8c 01       	movw	r16, r24
    6bb0:	0b 87       	std	Y+11, r16	; 0x0b
    6bb2:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6bb4:	89 85       	ldd	r24, Y+9	; 0x09
    6bb6:	9a 85       	ldd	r25, Y+10	; 0x0a
    6bb8:	01 97       	sbiw	r24, 0x01	; 1
    6bba:	89 87       	std	Y+9, r24	; 0x09
    6bbc:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6bbe:	89 85       	ldd	r24, Y+9	; 0x09
    6bc0:	9a 85       	ldd	r25, Y+10	; 0x0a
    6bc2:	00 97       	sbiw	r24, 0x00	; 0
    6bc4:	51 f7       	brne	.-44     	; 0x6b9a <HVPower+0xd4>
    6bc6:	22 c0       	rjmp	.+68     	; 0x6c0c <HVPower+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6bc8:	6d 81       	ldd	r22, Y+5	; 0x05
    6bca:	7e 81       	ldd	r23, Y+6	; 0x06
    6bcc:	8f 81       	ldd	r24, Y+7	; 0x07
    6bce:	98 85       	ldd	r25, Y+8	; 0x08
    6bd0:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    6bd4:	dc 01       	movw	r26, r24
    6bd6:	cb 01       	movw	r24, r22
    6bd8:	89 87       	std	Y+9, r24	; 0x09
    6bda:	9a 87       	std	Y+10, r25	; 0x0a
    6bdc:	89 85       	ldd	r24, Y+9	; 0x09
    6bde:	9a 85       	ldd	r25, Y+10	; 0x0a
    6be0:	8d 87       	std	Y+13, r24	; 0x0d
    6be2:	9e 87       	std	Y+14, r25	; 0x0e
    6be4:	8d 85       	ldd	r24, Y+13	; 0x0d
    6be6:	9e 85       	ldd	r25, Y+14	; 0x0e
    6be8:	8c 01       	movw	r16, r24
    6bea:	f8 01       	movw	r30, r16
    6bec:	31 97       	sbiw	r30, 0x01	; 1
    6bee:	f1 f7       	brne	.-4      	; 0x6bec <HVPower+0x126>
    6bf0:	8f 01       	movw	r16, r30
    6bf2:	0d 87       	std	Y+13, r16	; 0x0d
    6bf4:	1e 87       	std	Y+14, r17	; 0x0e
    6bf6:	0a c0       	rjmp	.+20     	; 0x6c0c <HVPower+0x146>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    6bf8:	80 ea       	ldi	r24, 0xA0	; 160
    6bfa:	96 e0       	ldi	r25, 0x06	; 6
    6bfc:	20 e8       	ldi	r18, 0x80	; 128
    6bfe:	fc 01       	movw	r30, r24
    6c00:	26 83       	std	Z+6, r18	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    6c02:	80 ea       	ldi	r24, 0xA0	; 160
    6c04:	96 e0       	ldi	r25, 0x06	; 6
    6c06:	20 e8       	ldi	r18, 0x80	; 128
    6c08:	fc 01       	movw	r30, r24
    6c0a:	22 83       	std	Z+2, r18	; 0x02
    6c0c:	80 e0       	ldi	r24, 0x00	; 0
    6c0e:	90 e0       	ldi	r25, 0x00	; 0
    6c10:	aa e7       	ldi	r26, 0x7A	; 122
    6c12:	b4 e4       	ldi	r27, 0x44	; 68
    6c14:	8f 87       	std	Y+15, r24	; 0x0f
    6c16:	98 8b       	std	Y+16, r25	; 0x10
    6c18:	a9 8b       	std	Y+17, r26	; 0x11
    6c1a:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    6c1c:	6f 85       	ldd	r22, Y+15	; 0x0f
    6c1e:	78 89       	ldd	r23, Y+16	; 0x10
    6c20:	89 89       	ldd	r24, Y+17	; 0x11
    6c22:	9a 89       	ldd	r25, Y+18	; 0x12
    6c24:	2b ea       	ldi	r18, 0xAB	; 171
    6c26:	3a ea       	ldi	r19, 0xAA	; 170
    6c28:	4a e2       	ldi	r20, 0x2A	; 42
    6c2a:	51 e4       	ldi	r21, 0x41	; 65
    6c2c:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    6c30:	dc 01       	movw	r26, r24
    6c32:	cb 01       	movw	r24, r22
    6c34:	8b 8b       	std	Y+19, r24	; 0x13
    6c36:	9c 8b       	std	Y+20, r25	; 0x14
    6c38:	ad 8b       	std	Y+21, r26	; 0x15
    6c3a:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    6c3c:	11 e0       	ldi	r17, 0x01	; 1
    6c3e:	6b 89       	ldd	r22, Y+19	; 0x13
    6c40:	7c 89       	ldd	r23, Y+20	; 0x14
    6c42:	8d 89       	ldd	r24, Y+21	; 0x15
    6c44:	9e 89       	ldd	r25, Y+22	; 0x16
    6c46:	20 e0       	ldi	r18, 0x00	; 0
    6c48:	30 e0       	ldi	r19, 0x00	; 0
    6c4a:	40 e8       	ldi	r20, 0x80	; 128
    6c4c:	5f e3       	ldi	r21, 0x3F	; 63
    6c4e:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    6c52:	88 23       	and	r24, r24
    6c54:	0c f0       	brlt	.+2      	; 0x6c58 <HVPower+0x192>
    6c56:	10 e0       	ldi	r17, 0x00	; 0
    6c58:	11 23       	and	r17, r17
    6c5a:	19 f0       	breq	.+6      	; 0x6c62 <HVPower+0x19c>
		__ticks = 1;
    6c5c:	81 e0       	ldi	r24, 0x01	; 1
    6c5e:	8f 8b       	std	Y+23, r24	; 0x17
    6c60:	a3 c0       	rjmp	.+326    	; 0x6da8 <HVPower+0x2e2>
	else if (__tmp > 255)
    6c62:	11 e0       	ldi	r17, 0x01	; 1
    6c64:	6b 89       	ldd	r22, Y+19	; 0x13
    6c66:	7c 89       	ldd	r23, Y+20	; 0x14
    6c68:	8d 89       	ldd	r24, Y+21	; 0x15
    6c6a:	9e 89       	ldd	r25, Y+22	; 0x16
    6c6c:	20 e0       	ldi	r18, 0x00	; 0
    6c6e:	30 e0       	ldi	r19, 0x00	; 0
    6c70:	4f e7       	ldi	r20, 0x7F	; 127
    6c72:	53 e4       	ldi	r21, 0x43	; 67
    6c74:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    6c78:	18 16       	cp	r1, r24
    6c7a:	0c f0       	brlt	.+2      	; 0x6c7e <HVPower+0x1b8>
    6c7c:	10 e0       	ldi	r17, 0x00	; 0
    6c7e:	11 23       	and	r17, r17
    6c80:	09 f4       	brne	.+2      	; 0x6c84 <HVPower+0x1be>
    6c82:	89 c0       	rjmp	.+274    	; 0x6d96 <HVPower+0x2d0>
	{
		_delay_ms(__us / 1000.0);
    6c84:	6f 85       	ldd	r22, Y+15	; 0x0f
    6c86:	78 89       	ldd	r23, Y+16	; 0x10
    6c88:	89 89       	ldd	r24, Y+17	; 0x11
    6c8a:	9a 89       	ldd	r25, Y+18	; 0x12
    6c8c:	20 e0       	ldi	r18, 0x00	; 0
    6c8e:	30 e0       	ldi	r19, 0x00	; 0
    6c90:	4a e7       	ldi	r20, 0x7A	; 122
    6c92:	54 e4       	ldi	r21, 0x44	; 68
    6c94:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
    6c98:	dc 01       	movw	r26, r24
    6c9a:	cb 01       	movw	r24, r22
    6c9c:	88 8f       	std	Y+24, r24	; 0x18
    6c9e:	99 8f       	std	Y+25, r25	; 0x19
    6ca0:	aa 8f       	std	Y+26, r26	; 0x1a
    6ca2:	bb 8f       	std	Y+27, r27	; 0x1b
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    6ca4:	68 8d       	ldd	r22, Y+24	; 0x18
    6ca6:	79 8d       	ldd	r23, Y+25	; 0x19
    6ca8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6caa:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6cac:	20 e0       	ldi	r18, 0x00	; 0
    6cae:	30 e0       	ldi	r19, 0x00	; 0
    6cb0:	4a ef       	ldi	r20, 0xFA	; 250
    6cb2:	55 e4       	ldi	r21, 0x45	; 69
    6cb4:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    6cb8:	dc 01       	movw	r26, r24
    6cba:	cb 01       	movw	r24, r22
    6cbc:	8c 8f       	std	Y+28, r24	; 0x1c
    6cbe:	9d 8f       	std	Y+29, r25	; 0x1d
    6cc0:	ae 8f       	std	Y+30, r26	; 0x1e
    6cc2:	bf 8f       	std	Y+31, r27	; 0x1f
	if (__tmp < 1.0)
    6cc4:	11 e0       	ldi	r17, 0x01	; 1
    6cc6:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6cc8:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6cca:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6ccc:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6cce:	20 e0       	ldi	r18, 0x00	; 0
    6cd0:	30 e0       	ldi	r19, 0x00	; 0
    6cd2:	40 e8       	ldi	r20, 0x80	; 128
    6cd4:	5f e3       	ldi	r21, 0x3F	; 63
    6cd6:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    6cda:	88 23       	and	r24, r24
    6cdc:	0c f0       	brlt	.+2      	; 0x6ce0 <HVPower+0x21a>
    6cde:	10 e0       	ldi	r17, 0x00	; 0
    6ce0:	11 23       	and	r17, r17
    6ce2:	29 f0       	breq	.+10     	; 0x6cee <HVPower+0x228>
		__ticks = 1;
    6ce4:	81 e0       	ldi	r24, 0x01	; 1
    6ce6:	90 e0       	ldi	r25, 0x00	; 0
    6ce8:	88 a3       	lds	r24, 0x58
    6cea:	99 a3       	lds	r25, 0x59
    6cec:	46 c0       	rjmp	.+140    	; 0x6d7a <HVPower+0x2b4>
	else if (__tmp > 65535)
    6cee:	11 e0       	ldi	r17, 0x01	; 1
    6cf0:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6cf2:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6cf4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6cf6:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6cf8:	20 e0       	ldi	r18, 0x00	; 0
    6cfa:	3f ef       	ldi	r19, 0xFF	; 255
    6cfc:	4f e7       	ldi	r20, 0x7F	; 127
    6cfe:	57 e4       	ldi	r21, 0x47	; 71
    6d00:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    6d04:	18 16       	cp	r1, r24
    6d06:	0c f0       	brlt	.+2      	; 0x6d0a <HVPower+0x244>
    6d08:	10 e0       	ldi	r17, 0x00	; 0
    6d0a:	11 23       	and	r17, r17
    6d0c:	61 f1       	breq	.+88     	; 0x6d66 <HVPower+0x2a0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6d0e:	68 8d       	ldd	r22, Y+24	; 0x18
    6d10:	79 8d       	ldd	r23, Y+25	; 0x19
    6d12:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6d14:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6d16:	20 e0       	ldi	r18, 0x00	; 0
    6d18:	30 e0       	ldi	r19, 0x00	; 0
    6d1a:	40 e2       	ldi	r20, 0x20	; 32
    6d1c:	51 e4       	ldi	r21, 0x41	; 65
    6d1e:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    6d22:	dc 01       	movw	r26, r24
    6d24:	cb 01       	movw	r24, r22
    6d26:	bc 01       	movw	r22, r24
    6d28:	cd 01       	movw	r24, r26
    6d2a:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    6d2e:	dc 01       	movw	r26, r24
    6d30:	cb 01       	movw	r24, r22
    6d32:	88 a3       	lds	r24, 0x58
    6d34:	99 a3       	lds	r25, 0x59
    6d36:	12 c0       	rjmp	.+36     	; 0x6d5c <HVPower+0x296>
    6d38:	80 e2       	ldi	r24, 0x20	; 32
    6d3a:	93 e0       	ldi	r25, 0x03	; 3
    6d3c:	8a a3       	lds	r24, 0x5a
    6d3e:	9b a3       	lds	r25, 0x5b
    6d40:	8a a1       	lds	r24, 0x4a
    6d42:	9b a1       	lds	r25, 0x4b
    6d44:	8c 01       	movw	r16, r24
    6d46:	c8 01       	movw	r24, r16
    6d48:	01 97       	sbiw	r24, 0x01	; 1
    6d4a:	f1 f7       	brne	.-4      	; 0x6d48 <HVPower+0x282>
    6d4c:	8c 01       	movw	r16, r24
    6d4e:	0a a3       	lds	r16, 0x5a
    6d50:	1b a3       	lds	r17, 0x5b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6d52:	88 a1       	lds	r24, 0x48
    6d54:	99 a1       	lds	r25, 0x49
    6d56:	01 97       	sbiw	r24, 0x01	; 1
    6d58:	88 a3       	lds	r24, 0x58
    6d5a:	99 a3       	lds	r25, 0x59
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6d5c:	88 a1       	lds	r24, 0x48
    6d5e:	99 a1       	lds	r25, 0x49
    6d60:	00 97       	sbiw	r24, 0x00	; 0
    6d62:	51 f7       	brne	.-44     	; 0x6d38 <HVPower+0x272>
    6d64:	28 c0       	rjmp	.+80     	; 0x6db6 <HVPower+0x2f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6d66:	6c 8d       	ldd	r22, Y+28	; 0x1c
    6d68:	7d 8d       	ldd	r23, Y+29	; 0x1d
    6d6a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6d6c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    6d6e:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    6d72:	dc 01       	movw	r26, r24
    6d74:	cb 01       	movw	r24, r22
    6d76:	88 a3       	lds	r24, 0x58
    6d78:	99 a3       	lds	r25, 0x59
    6d7a:	88 a1       	lds	r24, 0x48
    6d7c:	99 a1       	lds	r25, 0x49
    6d7e:	8c a3       	lds	r24, 0x5c
    6d80:	9d a3       	lds	r25, 0x5d
    6d82:	8c a1       	lds	r24, 0x4c
    6d84:	9d a1       	lds	r25, 0x4d
    6d86:	8c 01       	movw	r16, r24
    6d88:	f8 01       	movw	r30, r16
    6d8a:	31 97       	sbiw	r30, 0x01	; 1
    6d8c:	f1 f7       	brne	.-4      	; 0x6d8a <HVPower+0x2c4>
    6d8e:	8f 01       	movw	r16, r30
    6d90:	0c a3       	lds	r16, 0x5c
    6d92:	1d a3       	lds	r17, 0x5d
    6d94:	10 c0       	rjmp	.+32     	; 0x6db6 <HVPower+0x2f0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    6d96:	6b 89       	ldd	r22, Y+19	; 0x13
    6d98:	7c 89       	ldd	r23, Y+20	; 0x14
    6d9a:	8d 89       	ldd	r24, Y+21	; 0x15
    6d9c:	9e 89       	ldd	r25, Y+22	; 0x16
    6d9e:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    6da2:	dc 01       	movw	r26, r24
    6da4:	cb 01       	movw	r24, r22
    6da6:	8f 8b       	std	Y+23, r24	; 0x17
    6da8:	8f 89       	ldd	r24, Y+23	; 0x17
    6daa:	8e a3       	lds	r24, 0x5e
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    6dac:	8e a1       	lds	r24, 0x4e
    6dae:	18 2f       	mov	r17, r24
    6db0:	1a 95       	dec	r17
    6db2:	f1 f7       	brne	.-4      	; 0x6db0 <HVPower+0x2ea>
    6db4:	1e a3       	lds	r17, 0x5e
	}
	_delay_us(1000);
}
    6db6:	a7 96       	adiw	r28, 0x27	; 39
    6db8:	cd bf       	out	0x3d, r28	; 61
    6dba:	de bf       	out	0x3e, r29	; 62
    6dbc:	df 91       	pop	r29
    6dbe:	cf 91       	pop	r28
    6dc0:	1f 91       	pop	r17
    6dc2:	0f 91       	pop	r16
    6dc4:	08 95       	ret

00006dc6 <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
    6dc6:	cf 93       	push	r28
    6dc8:	df 93       	push	r29
    6dca:	0f 92       	push	r0
    6dcc:	cd b7       	in	r28, 0x3d	; 61
    6dce:	de b7       	in	r29, 0x3e	; 62
    6dd0:	89 83       	std	Y+1, r24	; 0x01
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    6dd2:	89 81       	ldd	r24, Y+1	; 0x01
    6dd4:	88 23       	and	r24, r24
    6dd6:	31 f0       	breq	.+12     	; 0x6de4 <lowerMuxCS+0x1e>
    6dd8:	80 e8       	ldi	r24, 0x80	; 128
    6dda:	96 e0       	ldi	r25, 0x06	; 6
    6ddc:	20 e1       	ldi	r18, 0x10	; 16
    6dde:	fc 01       	movw	r30, r24
    6de0:	26 83       	std	Z+6, r18	; 0x06
    6de2:	05 c0       	rjmp	.+10     	; 0x6dee <lowerMuxCS+0x28>
	else PORTE.OUTSET = PIN4_bm;
    6de4:	80 e8       	ldi	r24, 0x80	; 128
    6de6:	96 e0       	ldi	r25, 0x06	; 6
    6de8:	20 e1       	ldi	r18, 0x10	; 16
    6dea:	fc 01       	movw	r30, r24
    6dec:	25 83       	std	Z+5, r18	; 0x05
}
    6dee:	0f 90       	pop	r0
    6df0:	df 91       	pop	r29
    6df2:	cf 91       	pop	r28
    6df4:	08 95       	ret

00006df6 <upperMuxCS>:
void upperMuxCS(uint8_t write) {
    6df6:	cf 93       	push	r28
    6df8:	df 93       	push	r29
    6dfa:	0f 92       	push	r0
    6dfc:	cd b7       	in	r28, 0x3d	; 61
    6dfe:	de b7       	in	r29, 0x3e	; 62
    6e00:	89 83       	std	Y+1, r24	; 0x01
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    6e02:	89 81       	ldd	r24, Y+1	; 0x01
    6e04:	88 23       	and	r24, r24
    6e06:	31 f0       	breq	.+12     	; 0x6e14 <upperMuxCS+0x1e>
    6e08:	80 e4       	ldi	r24, 0x40	; 64
    6e0a:	96 e0       	ldi	r25, 0x06	; 6
    6e0c:	22 e0       	ldi	r18, 0x02	; 2
    6e0e:	fc 01       	movw	r30, r24
    6e10:	26 83       	std	Z+6, r18	; 0x06
    6e12:	05 c0       	rjmp	.+10     	; 0x6e1e <upperMuxCS+0x28>
	else PORTC.OUTSET = PIN1_bm;
    6e14:	80 e4       	ldi	r24, 0x40	; 64
    6e16:	96 e0       	ldi	r25, 0x06	; 6
    6e18:	22 e0       	ldi	r18, 0x02	; 2
    6e1a:	fc 01       	movw	r30, r24
    6e1c:	25 83       	std	Z+5, r18	; 0x05
}
    6e1e:	0f 90       	pop	r0
    6e20:	df 91       	pop	r29
    6e22:	cf 91       	pop	r28
    6e24:	08 95       	ret

00006e26 <SPIInit>:

void SPIInit(uint8_t mode) {
    6e26:	cf 93       	push	r28
    6e28:	df 93       	push	r29
    6e2a:	0f 92       	push	r0
    6e2c:	cd b7       	in	r28, 0x3d	; 61
    6e2e:	de b7       	in	r29, 0x3e	; 62
    6e30:	89 83       	std	Y+1, r24	; 0x01
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    6e32:	80 e4       	ldi	r24, 0x40	; 64
    6e34:	96 e0       	ldi	r25, 0x06	; 6
    6e36:	20 e1       	ldi	r18, 0x10	; 16
    6e38:	fc 01       	movw	r30, r24
    6e3a:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    6e3c:	80 e4       	ldi	r24, 0x40	; 64
    6e3e:	96 e0       	ldi	r25, 0x06	; 6
    6e40:	28 e3       	ldi	r18, 0x38	; 56
    6e42:	fc 01       	movw	r30, r24
    6e44:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    6e46:	80 e4       	ldi	r24, 0x40	; 64
    6e48:	96 e0       	ldi	r25, 0x06	; 6
    6e4a:	20 e1       	ldi	r18, 0x10	; 16
    6e4c:	fc 01       	movw	r30, r24
    6e4e:	25 83       	std	Z+5, r18	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    6e50:	80 ec       	ldi	r24, 0xC0	; 192
    6e52:	98 e0       	ldi	r25, 0x08	; 8
    6e54:	29 81       	ldd	r18, Y+1	; 0x01
    6e56:	21 65       	ori	r18, 0x51	; 81
    6e58:	fc 01       	movw	r30, r24
    6e5a:	20 83       	st	Z, r18
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    6e5c:	80 ec       	ldi	r24, 0xC0	; 192
    6e5e:	98 e0       	ldi	r25, 0x08	; 8
    6e60:	fc 01       	movw	r30, r24
    6e62:	11 82       	std	Z+1, r1	; 0x01

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    6e64:	80 e4       	ldi	r24, 0x40	; 64
    6e66:	96 e0       	ldi	r25, 0x06	; 6
    6e68:	20 ea       	ldi	r18, 0xA0	; 160
    6e6a:	fc 01       	movw	r30, r24
    6e6c:	21 83       	std	Z+1, r18	; 0x01

	
}
    6e6e:	0f 90       	pop	r0
    6e70:	df 91       	pop	r29
    6e72:	cf 91       	pop	r28
    6e74:	08 95       	ret

00006e76 <SPIInit2>:
//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
    6e76:	cf 93       	push	r28
    6e78:	df 93       	push	r29
    6e7a:	0f 92       	push	r0
    6e7c:	0f 92       	push	r0
    6e7e:	cd b7       	in	r28, 0x3d	; 61
    6e80:	de b7       	in	r29, 0x3e	; 62
    6e82:	89 83       	std	Y+1, r24	; 0x01
    6e84:	6a 83       	std	Y+2, r22	; 0x02
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    6e86:	80 e4       	ldi	r24, 0x40	; 64
    6e88:	96 e0       	ldi	r25, 0x06	; 6
    6e8a:	20 e1       	ldi	r18, 0x10	; 16
    6e8c:	fc 01       	movw	r30, r24
    6e8e:	21 83       	std	Z+1, r18	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    6e90:	80 e4       	ldi	r24, 0x40	; 64
    6e92:	96 e0       	ldi	r25, 0x06	; 6
    6e94:	28 e3       	ldi	r18, 0x38	; 56
    6e96:	fc 01       	movw	r30, r24
    6e98:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    6e9a:	80 e4       	ldi	r24, 0x40	; 64
    6e9c:	96 e0       	ldi	r25, 0x06	; 6
    6e9e:	20 e1       	ldi	r18, 0x10	; 16
    6ea0:	fc 01       	movw	r30, r24
    6ea2:	25 83       	std	Z+5, r18	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    6ea4:	80 ec       	ldi	r24, 0xC0	; 192
    6ea6:	98 e0       	ldi	r25, 0x08	; 8
    6ea8:	3a 81       	ldd	r19, Y+2	; 0x02
    6eaa:	29 81       	ldd	r18, Y+1	; 0x01
    6eac:	23 2b       	or	r18, r19
    6eae:	20 65       	ori	r18, 0x50	; 80
    6eb0:	fc 01       	movw	r30, r24
    6eb2:	20 83       	st	Z, r18
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    6eb4:	80 ec       	ldi	r24, 0xC0	; 192
    6eb6:	98 e0       	ldi	r25, 0x08	; 8
    6eb8:	fc 01       	movw	r30, r24
    6eba:	11 82       	std	Z+1, r1	; 0x01

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    6ebc:	80 e4       	ldi	r24, 0x40	; 64
    6ebe:	96 e0       	ldi	r25, 0x06	; 6
    6ec0:	20 ea       	ldi	r18, 0xA0	; 160
    6ec2:	fc 01       	movw	r30, r24
    6ec4:	21 83       	std	Z+1, r18	; 0x01
}
    6ec6:	0f 90       	pop	r0
    6ec8:	0f 90       	pop	r0
    6eca:	df 91       	pop	r29
    6ecc:	cf 91       	pop	r28
    6ece:	08 95       	ret

00006ed0 <SPICS>:

void SPICS(uint8_t enable) {
    6ed0:	cf 93       	push	r28
    6ed2:	df 93       	push	r29
    6ed4:	0f 92       	push	r0
    6ed6:	cd b7       	in	r28, 0x3d	; 61
    6ed8:	de b7       	in	r29, 0x3e	; 62
    6eda:	89 83       	std	Y+1, r24	; 0x01
	if (enable) PORTC.OUTCLR = PIN4_bm;
    6edc:	89 81       	ldd	r24, Y+1	; 0x01
    6ede:	88 23       	and	r24, r24
    6ee0:	31 f0       	breq	.+12     	; 0x6eee <SPICS+0x1e>
    6ee2:	80 e4       	ldi	r24, 0x40	; 64
    6ee4:	96 e0       	ldi	r25, 0x06	; 6
    6ee6:	20 e1       	ldi	r18, 0x10	; 16
    6ee8:	fc 01       	movw	r30, r24
    6eea:	26 83       	std	Z+6, r18	; 0x06
    6eec:	05 c0       	rjmp	.+10     	; 0x6ef8 <SPICS+0x28>
	else {
		PORTC.OUTSET = PIN4_bm;
    6eee:	80 e4       	ldi	r24, 0x40	; 64
    6ef0:	96 e0       	ldi	r25, 0x06	; 6
    6ef2:	20 e1       	ldi	r18, 0x10	; 16
    6ef4:	fc 01       	movw	r30, r24
    6ef6:	25 83       	std	Z+5, r18	; 0x05
	}	
}
    6ef8:	0f 90       	pop	r0
    6efa:	df 91       	pop	r29
    6efc:	cf 91       	pop	r28
    6efe:	08 95       	ret

00006f00 <SPIDisable>:

void SPIDisable() {
    6f00:	cf 93       	push	r28
    6f02:	df 93       	push	r29
    6f04:	cd b7       	in	r28, 0x3d	; 61
    6f06:	de b7       	in	r29, 0x3e	; 62
	PORTC.OUTSET = PIN4_bm;
    6f08:	80 e4       	ldi	r24, 0x40	; 64
    6f0a:	96 e0       	ldi	r25, 0x06	; 6
    6f0c:	20 e1       	ldi	r18, 0x10	; 16
    6f0e:	fc 01       	movw	r30, r24
    6f10:	25 83       	std	Z+5, r18	; 0x05
	SPIC.CTRL = 0x00;
    6f12:	80 ec       	ldi	r24, 0xC0	; 192
    6f14:	98 e0       	ldi	r25, 0x08	; 8
    6f16:	fc 01       	movw	r30, r24
    6f18:	10 82       	st	Z, r1
	PORTC.OUTCLR = PIN4_bm;
    6f1a:	80 e4       	ldi	r24, 0x40	; 64
    6f1c:	96 e0       	ldi	r25, 0x06	; 6
    6f1e:	20 e1       	ldi	r18, 0x10	; 16
    6f20:	fc 01       	movw	r30, r24
    6f22:	26 83       	std	Z+6, r18	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    6f24:	80 e4       	ldi	r24, 0x40	; 64
    6f26:	96 e0       	ldi	r25, 0x06	; 6
    6f28:	20 eb       	ldi	r18, 0xB0	; 176
    6f2a:	fc 01       	movw	r30, r24
    6f2c:	22 83       	std	Z+2, r18	; 0x02

}
    6f2e:	df 91       	pop	r29
    6f30:	cf 91       	pop	r28
    6f32:	08 95       	ret

00006f34 <readFRAM>:

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    6f34:	cf 93       	push	r28
    6f36:	df 93       	push	r29
    6f38:	00 d0       	rcall	.+0      	; 0x6f3a <readFRAM+0x6>
    6f3a:	0f 92       	push	r0
    6f3c:	cd b7       	in	r28, 0x3d	; 61
    6f3e:	de b7       	in	r29, 0x3e	; 62
    6f40:	8b 83       	std	Y+3, r24	; 0x03
    6f42:	9c 83       	std	Y+4, r25	; 0x04
	SPIInit(SPI_MODE_0_gc);
    6f44:	80 e0       	ldi	r24, 0x00	; 0
    6f46:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    6f4a:	80 ec       	ldi	r24, 0xC0	; 192
    6f4c:	98 e0       	ldi	r25, 0x08	; 8
    6f4e:	20 ed       	ldi	r18, 0xD0	; 208
    6f50:	fc 01       	movw	r30, r24
    6f52:	20 83       	st	Z, r18
	SPICS(TRUE);
    6f54:	81 e0       	ldi	r24, 0x01	; 1
    6f56:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    6f5a:	80 e2       	ldi	r24, 0x20	; 32
    6f5c:	96 e0       	ldi	r25, 0x06	; 6
    6f5e:	28 e0       	ldi	r18, 0x08	; 8
    6f60:	fc 01       	movw	r30, r24
    6f62:	26 83       	std	Z+6, r18	; 0x06
	nop();
    6f64:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    6f66:	80 ec       	ldi	r24, 0xC0	; 192
    6f68:	98 e0       	ldi	r25, 0x08	; 8
    6f6a:	23 e0       	ldi	r18, 0x03	; 3
    6f6c:	fc 01       	movw	r30, r24
    6f6e:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    6f70:	00 00       	nop
    6f72:	80 ec       	ldi	r24, 0xC0	; 192
    6f74:	98 e0       	ldi	r25, 0x08	; 8
    6f76:	fc 01       	movw	r30, r24
    6f78:	82 81       	ldd	r24, Z+2	; 0x02
    6f7a:	88 23       	and	r24, r24
    6f7c:	d4 f7       	brge	.-12     	; 0x6f72 <readFRAM+0x3e>
	SPIBuffer[12] = SPIC.DATA;
    6f7e:	80 ec       	ldi	r24, 0xC0	; 192
    6f80:	98 e0       	ldi	r25, 0x08	; 8
    6f82:	fc 01       	movw	r30, r24
    6f84:	83 81       	ldd	r24, Z+3	; 0x03
    6f86:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    6f8a:	80 ec       	ldi	r24, 0xC0	; 192
    6f8c:	98 e0       	ldi	r25, 0x08	; 8
    6f8e:	20 91 51 40 	lds	r18, 0x4051
    6f92:	fc 01       	movw	r30, r24
    6f94:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    6f96:	00 00       	nop
    6f98:	80 ec       	ldi	r24, 0xC0	; 192
    6f9a:	98 e0       	ldi	r25, 0x08	; 8
    6f9c:	fc 01       	movw	r30, r24
    6f9e:	82 81       	ldd	r24, Z+2	; 0x02
    6fa0:	88 23       	and	r24, r24
    6fa2:	d4 f7       	brge	.-12     	; 0x6f98 <readFRAM+0x64>
	SPIBuffer[12] = SPIC.DATA;
    6fa4:	80 ec       	ldi	r24, 0xC0	; 192
    6fa6:	98 e0       	ldi	r25, 0x08	; 8
    6fa8:	fc 01       	movw	r30, r24
    6faa:	83 81       	ldd	r24, Z+3	; 0x03
    6fac:	80 93 72 50 	sts	0x5072, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    6fb0:	80 ec       	ldi	r24, 0xC0	; 192
    6fb2:	98 e0       	ldi	r25, 0x08	; 8
    6fb4:	20 e5       	ldi	r18, 0x50	; 80
    6fb6:	30 e4       	ldi	r19, 0x40	; 64
    6fb8:	f9 01       	movw	r30, r18
    6fba:	20 81       	ld	r18, Z
    6fbc:	fc 01       	movw	r30, r24
    6fbe:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    6fc0:	00 00       	nop
    6fc2:	80 ec       	ldi	r24, 0xC0	; 192
    6fc4:	98 e0       	ldi	r25, 0x08	; 8
    6fc6:	fc 01       	movw	r30, r24
    6fc8:	82 81       	ldd	r24, Z+2	; 0x02
    6fca:	88 23       	and	r24, r24
    6fcc:	d4 f7       	brge	.-12     	; 0x6fc2 <readFRAM+0x8e>
	SPIBuffer[12] = SPIC.DATA;
    6fce:	80 ec       	ldi	r24, 0xC0	; 192
    6fd0:	98 e0       	ldi	r25, 0x08	; 8
    6fd2:	fc 01       	movw	r30, r24
    6fd4:	83 81       	ldd	r24, Z+3	; 0x03
    6fd6:	80 93 72 50 	sts	0x5072, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    6fda:	19 82       	std	Y+1, r1	; 0x01
    6fdc:	1a 82       	std	Y+2, r1	; 0x02
    6fde:	1b c0       	rjmp	.+54     	; 0x7016 <readFRAM+0xe2>
		SPIC.DATA = 0xAA;
    6fe0:	80 ec       	ldi	r24, 0xC0	; 192
    6fe2:	98 e0       	ldi	r25, 0x08	; 8
    6fe4:	2a ea       	ldi	r18, 0xAA	; 170
    6fe6:	fc 01       	movw	r30, r24
    6fe8:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    6fea:	00 00       	nop
    6fec:	80 ec       	ldi	r24, 0xC0	; 192
    6fee:	98 e0       	ldi	r25, 0x08	; 8
    6ff0:	fc 01       	movw	r30, r24
    6ff2:	82 81       	ldd	r24, Z+2	; 0x02
    6ff4:	88 23       	and	r24, r24
    6ff6:	d4 f7       	brge	.-12     	; 0x6fec <readFRAM+0xb8>
		FRAMReadBuffer[i] = SPIC.DATA;
    6ff8:	80 ec       	ldi	r24, 0xC0	; 192
    6ffa:	98 e0       	ldi	r25, 0x08	; 8
    6ffc:	fc 01       	movw	r30, r24
    6ffe:	23 81       	ldd	r18, Z+3	; 0x03
    7000:	89 81       	ldd	r24, Y+1	; 0x01
    7002:	9a 81       	ldd	r25, Y+2	; 0x02
    7004:	88 52       	subi	r24, 0x28	; 40
    7006:	9c 4d       	sbci	r25, 0xDC	; 220
    7008:	fc 01       	movw	r30, r24
    700a:	20 83       	st	Z, r18
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    700c:	89 81       	ldd	r24, Y+1	; 0x01
    700e:	9a 81       	ldd	r25, Y+2	; 0x02
    7010:	01 96       	adiw	r24, 0x01	; 1
    7012:	89 83       	std	Y+1, r24	; 0x01
    7014:	9a 83       	std	Y+2, r25	; 0x02
    7016:	29 81       	ldd	r18, Y+1	; 0x01
    7018:	3a 81       	ldd	r19, Y+2	; 0x02
    701a:	8b 81       	ldd	r24, Y+3	; 0x03
    701c:	9c 81       	ldd	r25, Y+4	; 0x04
    701e:	28 17       	cp	r18, r24
    7020:	39 07       	cpc	r19, r25
    7022:	f0 f2       	brcs	.-68     	; 0x6fe0 <readFRAM+0xac>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    7024:	80 e2       	ldi	r24, 0x20	; 32
    7026:	96 e0       	ldi	r25, 0x06	; 6
    7028:	28 e0       	ldi	r18, 0x08	; 8
    702a:	fc 01       	movw	r30, r24
    702c:	25 83       	std	Z+5, r18	; 0x05
	SPICS(FALSE);
    702e:	80 e0       	ldi	r24, 0x00	; 0
    7030:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	SPIDisable();
    7034:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>

}
    7038:	24 96       	adiw	r28, 0x04	; 4
    703a:	cd bf       	out	0x3d, r28	; 61
    703c:	de bf       	out	0x3e, r29	; 62
    703e:	df 91       	pop	r29
    7040:	cf 91       	pop	r28
    7042:	08 95       	ret

00007044 <FRAMTest3Channel>:

//test 3 channel sampling of accelerometer. OBSOLETE
void FRAMTest3Channel(void) {
    7044:	0f 93       	push	r16
    7046:	1f 93       	push	r17
    7048:	cf 93       	push	r28
    704a:	df 93       	push	r29
    704c:	cd b7       	in	r28, 0x3d	; 61
    704e:	de b7       	in	r29, 0x3e	; 62
    7050:	6b 97       	sbiw	r28, 0x1b	; 27
    7052:	cd bf       	out	0x3d, r28	; 61
    7054:	de bf       	out	0x3e, r29	; 62
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
    7056:	19 8e       	std	Y+25, r1	; 0x19
    7058:	1a 8e       	std	Y+26, r1	; 0x1a
    705a:	1b 8e       	std	Y+27, r1	; 0x1b
			
	//CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |	FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,	gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    705c:	81 e0       	ldi	r24, 0x01	; 1
    705e:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
    7062:	80 e0       	ldi	r24, 0x00	; 0
    7064:	90 e0       	ldi	r25, 0x00	; 0
    7066:	aa e7       	ldi	r26, 0x7A	; 122
    7068:	b3 e4       	ldi	r27, 0x43	; 67
    706a:	89 83       	std	Y+1, r24	; 0x01
    706c:	9a 83       	std	Y+2, r25	; 0x02
    706e:	ab 83       	std	Y+3, r26	; 0x03
    7070:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    7072:	69 81       	ldd	r22, Y+1	; 0x01
    7074:	7a 81       	ldd	r23, Y+2	; 0x02
    7076:	8b 81       	ldd	r24, Y+3	; 0x03
    7078:	9c 81       	ldd	r25, Y+4	; 0x04
    707a:	2b ea       	ldi	r18, 0xAB	; 171
    707c:	3a ea       	ldi	r19, 0xAA	; 170
    707e:	4a e2       	ldi	r20, 0x2A	; 42
    7080:	51 e4       	ldi	r21, 0x41	; 65
    7082:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    7086:	dc 01       	movw	r26, r24
    7088:	cb 01       	movw	r24, r22
    708a:	8d 83       	std	Y+5, r24	; 0x05
    708c:	9e 83       	std	Y+6, r25	; 0x06
    708e:	af 83       	std	Y+7, r26	; 0x07
    7090:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7092:	11 e0       	ldi	r17, 0x01	; 1
    7094:	6d 81       	ldd	r22, Y+5	; 0x05
    7096:	7e 81       	ldd	r23, Y+6	; 0x06
    7098:	8f 81       	ldd	r24, Y+7	; 0x07
    709a:	98 85       	ldd	r25, Y+8	; 0x08
    709c:	20 e0       	ldi	r18, 0x00	; 0
    709e:	30 e0       	ldi	r19, 0x00	; 0
    70a0:	40 e8       	ldi	r20, 0x80	; 128
    70a2:	5f e3       	ldi	r21, 0x3F	; 63
    70a4:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    70a8:	88 23       	and	r24, r24
    70aa:	0c f0       	brlt	.+2      	; 0x70ae <FRAMTest3Channel+0x6a>
    70ac:	10 e0       	ldi	r17, 0x00	; 0
    70ae:	11 23       	and	r17, r17
    70b0:	19 f0       	breq	.+6      	; 0x70b8 <FRAMTest3Channel+0x74>
		__ticks = 1;
    70b2:	81 e0       	ldi	r24, 0x01	; 1
    70b4:	89 87       	std	Y+9, r24	; 0x09
    70b6:	a3 c0       	rjmp	.+326    	; 0x71fe <FRAMTest3Channel+0x1ba>
	else if (__tmp > 255)
    70b8:	11 e0       	ldi	r17, 0x01	; 1
    70ba:	6d 81       	ldd	r22, Y+5	; 0x05
    70bc:	7e 81       	ldd	r23, Y+6	; 0x06
    70be:	8f 81       	ldd	r24, Y+7	; 0x07
    70c0:	98 85       	ldd	r25, Y+8	; 0x08
    70c2:	20 e0       	ldi	r18, 0x00	; 0
    70c4:	30 e0       	ldi	r19, 0x00	; 0
    70c6:	4f e7       	ldi	r20, 0x7F	; 127
    70c8:	53 e4       	ldi	r21, 0x43	; 67
    70ca:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    70ce:	18 16       	cp	r1, r24
    70d0:	0c f0       	brlt	.+2      	; 0x70d4 <FRAMTest3Channel+0x90>
    70d2:	10 e0       	ldi	r17, 0x00	; 0
    70d4:	11 23       	and	r17, r17
    70d6:	09 f4       	brne	.+2      	; 0x70da <FRAMTest3Channel+0x96>
    70d8:	89 c0       	rjmp	.+274    	; 0x71ec <FRAMTest3Channel+0x1a8>
	{
		_delay_ms(__us / 1000.0);
    70da:	69 81       	ldd	r22, Y+1	; 0x01
    70dc:	7a 81       	ldd	r23, Y+2	; 0x02
    70de:	8b 81       	ldd	r24, Y+3	; 0x03
    70e0:	9c 81       	ldd	r25, Y+4	; 0x04
    70e2:	20 e0       	ldi	r18, 0x00	; 0
    70e4:	30 e0       	ldi	r19, 0x00	; 0
    70e6:	4a e7       	ldi	r20, 0x7A	; 122
    70e8:	54 e4       	ldi	r21, 0x44	; 68
    70ea:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
    70ee:	dc 01       	movw	r26, r24
    70f0:	cb 01       	movw	r24, r22
    70f2:	8a 87       	std	Y+10, r24	; 0x0a
    70f4:	9b 87       	std	Y+11, r25	; 0x0b
    70f6:	ac 87       	std	Y+12, r26	; 0x0c
    70f8:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    70fa:	6a 85       	ldd	r22, Y+10	; 0x0a
    70fc:	7b 85       	ldd	r23, Y+11	; 0x0b
    70fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    7100:	9d 85       	ldd	r25, Y+13	; 0x0d
    7102:	20 e0       	ldi	r18, 0x00	; 0
    7104:	30 e0       	ldi	r19, 0x00	; 0
    7106:	4a ef       	ldi	r20, 0xFA	; 250
    7108:	55 e4       	ldi	r21, 0x45	; 69
    710a:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    710e:	dc 01       	movw	r26, r24
    7110:	cb 01       	movw	r24, r22
    7112:	8e 87       	std	Y+14, r24	; 0x0e
    7114:	9f 87       	std	Y+15, r25	; 0x0f
    7116:	a8 8b       	std	Y+16, r26	; 0x10
    7118:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    711a:	11 e0       	ldi	r17, 0x01	; 1
    711c:	6e 85       	ldd	r22, Y+14	; 0x0e
    711e:	7f 85       	ldd	r23, Y+15	; 0x0f
    7120:	88 89       	ldd	r24, Y+16	; 0x10
    7122:	99 89       	ldd	r25, Y+17	; 0x11
    7124:	20 e0       	ldi	r18, 0x00	; 0
    7126:	30 e0       	ldi	r19, 0x00	; 0
    7128:	40 e8       	ldi	r20, 0x80	; 128
    712a:	5f e3       	ldi	r21, 0x3F	; 63
    712c:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    7130:	88 23       	and	r24, r24
    7132:	0c f0       	brlt	.+2      	; 0x7136 <FRAMTest3Channel+0xf2>
    7134:	10 e0       	ldi	r17, 0x00	; 0
    7136:	11 23       	and	r17, r17
    7138:	29 f0       	breq	.+10     	; 0x7144 <FRAMTest3Channel+0x100>
		__ticks = 1;
    713a:	81 e0       	ldi	r24, 0x01	; 1
    713c:	90 e0       	ldi	r25, 0x00	; 0
    713e:	8a 8b       	std	Y+18, r24	; 0x12
    7140:	9b 8b       	std	Y+19, r25	; 0x13
    7142:	46 c0       	rjmp	.+140    	; 0x71d0 <FRAMTest3Channel+0x18c>
	else if (__tmp > 65535)
    7144:	11 e0       	ldi	r17, 0x01	; 1
    7146:	6e 85       	ldd	r22, Y+14	; 0x0e
    7148:	7f 85       	ldd	r23, Y+15	; 0x0f
    714a:	88 89       	ldd	r24, Y+16	; 0x10
    714c:	99 89       	ldd	r25, Y+17	; 0x11
    714e:	20 e0       	ldi	r18, 0x00	; 0
    7150:	3f ef       	ldi	r19, 0xFF	; 255
    7152:	4f e7       	ldi	r20, 0x7F	; 127
    7154:	57 e4       	ldi	r21, 0x47	; 71
    7156:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    715a:	18 16       	cp	r1, r24
    715c:	0c f0       	brlt	.+2      	; 0x7160 <FRAMTest3Channel+0x11c>
    715e:	10 e0       	ldi	r17, 0x00	; 0
    7160:	11 23       	and	r17, r17
    7162:	61 f1       	breq	.+88     	; 0x71bc <FRAMTest3Channel+0x178>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7164:	6a 85       	ldd	r22, Y+10	; 0x0a
    7166:	7b 85       	ldd	r23, Y+11	; 0x0b
    7168:	8c 85       	ldd	r24, Y+12	; 0x0c
    716a:	9d 85       	ldd	r25, Y+13	; 0x0d
    716c:	20 e0       	ldi	r18, 0x00	; 0
    716e:	30 e0       	ldi	r19, 0x00	; 0
    7170:	40 e2       	ldi	r20, 0x20	; 32
    7172:	51 e4       	ldi	r21, 0x41	; 65
    7174:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    7178:	dc 01       	movw	r26, r24
    717a:	cb 01       	movw	r24, r22
    717c:	bc 01       	movw	r22, r24
    717e:	cd 01       	movw	r24, r26
    7180:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    7184:	dc 01       	movw	r26, r24
    7186:	cb 01       	movw	r24, r22
    7188:	8a 8b       	std	Y+18, r24	; 0x12
    718a:	9b 8b       	std	Y+19, r25	; 0x13
    718c:	12 c0       	rjmp	.+36     	; 0x71b2 <FRAMTest3Channel+0x16e>
    718e:	80 e2       	ldi	r24, 0x20	; 32
    7190:	93 e0       	ldi	r25, 0x03	; 3
    7192:	8c 8b       	std	Y+20, r24	; 0x14
    7194:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7196:	8c 89       	ldd	r24, Y+20	; 0x14
    7198:	9d 89       	ldd	r25, Y+21	; 0x15
    719a:	8c 01       	movw	r16, r24
    719c:	c8 01       	movw	r24, r16
    719e:	01 97       	sbiw	r24, 0x01	; 1
    71a0:	f1 f7       	brne	.-4      	; 0x719e <FRAMTest3Channel+0x15a>
    71a2:	8c 01       	movw	r16, r24
    71a4:	0c 8b       	std	Y+20, r16	; 0x14
    71a6:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    71a8:	8a 89       	ldd	r24, Y+18	; 0x12
    71aa:	9b 89       	ldd	r25, Y+19	; 0x13
    71ac:	01 97       	sbiw	r24, 0x01	; 1
    71ae:	8a 8b       	std	Y+18, r24	; 0x12
    71b0:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    71b2:	8a 89       	ldd	r24, Y+18	; 0x12
    71b4:	9b 89       	ldd	r25, Y+19	; 0x13
    71b6:	00 97       	sbiw	r24, 0x00	; 0
    71b8:	51 f7       	brne	.-44     	; 0x718e <FRAMTest3Channel+0x14a>
    71ba:	28 c0       	rjmp	.+80     	; 0x720c <FRAMTest3Channel+0x1c8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    71bc:	6e 85       	ldd	r22, Y+14	; 0x0e
    71be:	7f 85       	ldd	r23, Y+15	; 0x0f
    71c0:	88 89       	ldd	r24, Y+16	; 0x10
    71c2:	99 89       	ldd	r25, Y+17	; 0x11
    71c4:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    71c8:	dc 01       	movw	r26, r24
    71ca:	cb 01       	movw	r24, r22
    71cc:	8a 8b       	std	Y+18, r24	; 0x12
    71ce:	9b 8b       	std	Y+19, r25	; 0x13
    71d0:	8a 89       	ldd	r24, Y+18	; 0x12
    71d2:	9b 89       	ldd	r25, Y+19	; 0x13
    71d4:	8e 8b       	std	Y+22, r24	; 0x16
    71d6:	9f 8b       	std	Y+23, r25	; 0x17
    71d8:	8e 89       	ldd	r24, Y+22	; 0x16
    71da:	9f 89       	ldd	r25, Y+23	; 0x17
    71dc:	8c 01       	movw	r16, r24
    71de:	c8 01       	movw	r24, r16
    71e0:	01 97       	sbiw	r24, 0x01	; 1
    71e2:	f1 f7       	brne	.-4      	; 0x71e0 <FRAMTest3Channel+0x19c>
    71e4:	8c 01       	movw	r16, r24
    71e6:	0e 8b       	std	Y+22, r16	; 0x16
    71e8:	1f 8b       	std	Y+23, r17	; 0x17
    71ea:	10 c0       	rjmp	.+32     	; 0x720c <FRAMTest3Channel+0x1c8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    71ec:	6d 81       	ldd	r22, Y+5	; 0x05
    71ee:	7e 81       	ldd	r23, Y+6	; 0x06
    71f0:	8f 81       	ldd	r24, Y+7	; 0x07
    71f2:	98 85       	ldd	r25, Y+8	; 0x08
    71f4:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    71f8:	dc 01       	movw	r26, r24
    71fa:	cb 01       	movw	r24, r22
    71fc:	89 87       	std	Y+9, r24	; 0x09
    71fe:	89 85       	ldd	r24, Y+9	; 0x09
    7200:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7202:	88 8d       	ldd	r24, Y+24	; 0x18
    7204:	18 2f       	mov	r17, r24
    7206:	1a 95       	dec	r17
    7208:	f1 f7       	brne	.-4      	; 0x7206 <FRAMTest3Channel+0x1c2>
    720a:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    720c:	0e 94 89 15 	call	0x2b12	; 0x2b12 <calcChecksumFRAM>

	ADCPower(FALSE);
    7210:	80 e0       	ldi	r24, 0x00	; 0
    7212:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	
}
    7216:	6b 96       	adiw	r28, 0x1b	; 27
    7218:	cd bf       	out	0x3d, r28	; 61
    721a:	de bf       	out	0x3e, r29	; 62
    721c:	df 91       	pop	r29
    721e:	cf 91       	pop	r28
    7220:	1f 91       	pop	r17
    7222:	0f 91       	pop	r16
    7224:	08 95       	ret

00007226 <FRAMTest1Channel>:
//test 1 channel sampling of accelerometer. OBSOLETE
void FRAMTest1Channel(void) {
    7226:	0f 93       	push	r16
    7228:	1f 93       	push	r17
    722a:	cf 93       	push	r28
    722c:	df 93       	push	r29
    722e:	cd b7       	in	r28, 0x3d	; 61
    7230:	de b7       	in	r29, 0x3e	; 62
    7232:	68 97       	sbiw	r28, 0x18	; 24
    7234:	cd bf       	out	0x3d, r28	; 61
    7236:	de bf       	out	0x3e, r29	; 62

	//CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc, GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    7238:	81 e0       	ldi	r24, 0x01	; 1
    723a:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
    723e:	80 e0       	ldi	r24, 0x00	; 0
    7240:	90 e0       	ldi	r25, 0x00	; 0
    7242:	aa e7       	ldi	r26, 0x7A	; 122
    7244:	b3 e4       	ldi	r27, 0x43	; 67
    7246:	89 83       	std	Y+1, r24	; 0x01
    7248:	9a 83       	std	Y+2, r25	; 0x02
    724a:	ab 83       	std	Y+3, r26	; 0x03
    724c:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    724e:	69 81       	ldd	r22, Y+1	; 0x01
    7250:	7a 81       	ldd	r23, Y+2	; 0x02
    7252:	8b 81       	ldd	r24, Y+3	; 0x03
    7254:	9c 81       	ldd	r25, Y+4	; 0x04
    7256:	2b ea       	ldi	r18, 0xAB	; 171
    7258:	3a ea       	ldi	r19, 0xAA	; 170
    725a:	4a e2       	ldi	r20, 0x2A	; 42
    725c:	51 e4       	ldi	r21, 0x41	; 65
    725e:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    7262:	dc 01       	movw	r26, r24
    7264:	cb 01       	movw	r24, r22
    7266:	8d 83       	std	Y+5, r24	; 0x05
    7268:	9e 83       	std	Y+6, r25	; 0x06
    726a:	af 83       	std	Y+7, r26	; 0x07
    726c:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    726e:	11 e0       	ldi	r17, 0x01	; 1
    7270:	6d 81       	ldd	r22, Y+5	; 0x05
    7272:	7e 81       	ldd	r23, Y+6	; 0x06
    7274:	8f 81       	ldd	r24, Y+7	; 0x07
    7276:	98 85       	ldd	r25, Y+8	; 0x08
    7278:	20 e0       	ldi	r18, 0x00	; 0
    727a:	30 e0       	ldi	r19, 0x00	; 0
    727c:	40 e8       	ldi	r20, 0x80	; 128
    727e:	5f e3       	ldi	r21, 0x3F	; 63
    7280:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    7284:	88 23       	and	r24, r24
    7286:	0c f0       	brlt	.+2      	; 0x728a <FRAMTest1Channel+0x64>
    7288:	10 e0       	ldi	r17, 0x00	; 0
    728a:	11 23       	and	r17, r17
    728c:	19 f0       	breq	.+6      	; 0x7294 <FRAMTest1Channel+0x6e>
		__ticks = 1;
    728e:	81 e0       	ldi	r24, 0x01	; 1
    7290:	89 87       	std	Y+9, r24	; 0x09
    7292:	a3 c0       	rjmp	.+326    	; 0x73da <FRAMTest1Channel+0x1b4>
	else if (__tmp > 255)
    7294:	11 e0       	ldi	r17, 0x01	; 1
    7296:	6d 81       	ldd	r22, Y+5	; 0x05
    7298:	7e 81       	ldd	r23, Y+6	; 0x06
    729a:	8f 81       	ldd	r24, Y+7	; 0x07
    729c:	98 85       	ldd	r25, Y+8	; 0x08
    729e:	20 e0       	ldi	r18, 0x00	; 0
    72a0:	30 e0       	ldi	r19, 0x00	; 0
    72a2:	4f e7       	ldi	r20, 0x7F	; 127
    72a4:	53 e4       	ldi	r21, 0x43	; 67
    72a6:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    72aa:	18 16       	cp	r1, r24
    72ac:	0c f0       	brlt	.+2      	; 0x72b0 <FRAMTest1Channel+0x8a>
    72ae:	10 e0       	ldi	r17, 0x00	; 0
    72b0:	11 23       	and	r17, r17
    72b2:	09 f4       	brne	.+2      	; 0x72b6 <FRAMTest1Channel+0x90>
    72b4:	89 c0       	rjmp	.+274    	; 0x73c8 <FRAMTest1Channel+0x1a2>
	{
		_delay_ms(__us / 1000.0);
    72b6:	69 81       	ldd	r22, Y+1	; 0x01
    72b8:	7a 81       	ldd	r23, Y+2	; 0x02
    72ba:	8b 81       	ldd	r24, Y+3	; 0x03
    72bc:	9c 81       	ldd	r25, Y+4	; 0x04
    72be:	20 e0       	ldi	r18, 0x00	; 0
    72c0:	30 e0       	ldi	r19, 0x00	; 0
    72c2:	4a e7       	ldi	r20, 0x7A	; 122
    72c4:	54 e4       	ldi	r21, 0x44	; 68
    72c6:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
    72ca:	dc 01       	movw	r26, r24
    72cc:	cb 01       	movw	r24, r22
    72ce:	8a 87       	std	Y+10, r24	; 0x0a
    72d0:	9b 87       	std	Y+11, r25	; 0x0b
    72d2:	ac 87       	std	Y+12, r26	; 0x0c
    72d4:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    72d6:	6a 85       	ldd	r22, Y+10	; 0x0a
    72d8:	7b 85       	ldd	r23, Y+11	; 0x0b
    72da:	8c 85       	ldd	r24, Y+12	; 0x0c
    72dc:	9d 85       	ldd	r25, Y+13	; 0x0d
    72de:	20 e0       	ldi	r18, 0x00	; 0
    72e0:	30 e0       	ldi	r19, 0x00	; 0
    72e2:	4a ef       	ldi	r20, 0xFA	; 250
    72e4:	55 e4       	ldi	r21, 0x45	; 69
    72e6:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    72ea:	dc 01       	movw	r26, r24
    72ec:	cb 01       	movw	r24, r22
    72ee:	8e 87       	std	Y+14, r24	; 0x0e
    72f0:	9f 87       	std	Y+15, r25	; 0x0f
    72f2:	a8 8b       	std	Y+16, r26	; 0x10
    72f4:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    72f6:	11 e0       	ldi	r17, 0x01	; 1
    72f8:	6e 85       	ldd	r22, Y+14	; 0x0e
    72fa:	7f 85       	ldd	r23, Y+15	; 0x0f
    72fc:	88 89       	ldd	r24, Y+16	; 0x10
    72fe:	99 89       	ldd	r25, Y+17	; 0x11
    7300:	20 e0       	ldi	r18, 0x00	; 0
    7302:	30 e0       	ldi	r19, 0x00	; 0
    7304:	40 e8       	ldi	r20, 0x80	; 128
    7306:	5f e3       	ldi	r21, 0x3F	; 63
    7308:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    730c:	88 23       	and	r24, r24
    730e:	0c f0       	brlt	.+2      	; 0x7312 <FRAMTest1Channel+0xec>
    7310:	10 e0       	ldi	r17, 0x00	; 0
    7312:	11 23       	and	r17, r17
    7314:	29 f0       	breq	.+10     	; 0x7320 <FRAMTest1Channel+0xfa>
		__ticks = 1;
    7316:	81 e0       	ldi	r24, 0x01	; 1
    7318:	90 e0       	ldi	r25, 0x00	; 0
    731a:	8a 8b       	std	Y+18, r24	; 0x12
    731c:	9b 8b       	std	Y+19, r25	; 0x13
    731e:	46 c0       	rjmp	.+140    	; 0x73ac <FRAMTest1Channel+0x186>
	else if (__tmp > 65535)
    7320:	11 e0       	ldi	r17, 0x01	; 1
    7322:	6e 85       	ldd	r22, Y+14	; 0x0e
    7324:	7f 85       	ldd	r23, Y+15	; 0x0f
    7326:	88 89       	ldd	r24, Y+16	; 0x10
    7328:	99 89       	ldd	r25, Y+17	; 0x11
    732a:	20 e0       	ldi	r18, 0x00	; 0
    732c:	3f ef       	ldi	r19, 0xFF	; 255
    732e:	4f e7       	ldi	r20, 0x7F	; 127
    7330:	57 e4       	ldi	r21, 0x47	; 71
    7332:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    7336:	18 16       	cp	r1, r24
    7338:	0c f0       	brlt	.+2      	; 0x733c <FRAMTest1Channel+0x116>
    733a:	10 e0       	ldi	r17, 0x00	; 0
    733c:	11 23       	and	r17, r17
    733e:	61 f1       	breq	.+88     	; 0x7398 <FRAMTest1Channel+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7340:	6a 85       	ldd	r22, Y+10	; 0x0a
    7342:	7b 85       	ldd	r23, Y+11	; 0x0b
    7344:	8c 85       	ldd	r24, Y+12	; 0x0c
    7346:	9d 85       	ldd	r25, Y+13	; 0x0d
    7348:	20 e0       	ldi	r18, 0x00	; 0
    734a:	30 e0       	ldi	r19, 0x00	; 0
    734c:	40 e2       	ldi	r20, 0x20	; 32
    734e:	51 e4       	ldi	r21, 0x41	; 65
    7350:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    7354:	dc 01       	movw	r26, r24
    7356:	cb 01       	movw	r24, r22
    7358:	bc 01       	movw	r22, r24
    735a:	cd 01       	movw	r24, r26
    735c:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    7360:	dc 01       	movw	r26, r24
    7362:	cb 01       	movw	r24, r22
    7364:	8a 8b       	std	Y+18, r24	; 0x12
    7366:	9b 8b       	std	Y+19, r25	; 0x13
    7368:	12 c0       	rjmp	.+36     	; 0x738e <FRAMTest1Channel+0x168>
    736a:	80 e2       	ldi	r24, 0x20	; 32
    736c:	93 e0       	ldi	r25, 0x03	; 3
    736e:	8c 8b       	std	Y+20, r24	; 0x14
    7370:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7372:	8c 89       	ldd	r24, Y+20	; 0x14
    7374:	9d 89       	ldd	r25, Y+21	; 0x15
    7376:	8c 01       	movw	r16, r24
    7378:	c8 01       	movw	r24, r16
    737a:	01 97       	sbiw	r24, 0x01	; 1
    737c:	f1 f7       	brne	.-4      	; 0x737a <FRAMTest1Channel+0x154>
    737e:	8c 01       	movw	r16, r24
    7380:	0c 8b       	std	Y+20, r16	; 0x14
    7382:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7384:	8a 89       	ldd	r24, Y+18	; 0x12
    7386:	9b 89       	ldd	r25, Y+19	; 0x13
    7388:	01 97       	sbiw	r24, 0x01	; 1
    738a:	8a 8b       	std	Y+18, r24	; 0x12
    738c:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    738e:	8a 89       	ldd	r24, Y+18	; 0x12
    7390:	9b 89       	ldd	r25, Y+19	; 0x13
    7392:	00 97       	sbiw	r24, 0x00	; 0
    7394:	51 f7       	brne	.-44     	; 0x736a <FRAMTest1Channel+0x144>
    7396:	28 c0       	rjmp	.+80     	; 0x73e8 <FRAMTest1Channel+0x1c2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7398:	6e 85       	ldd	r22, Y+14	; 0x0e
    739a:	7f 85       	ldd	r23, Y+15	; 0x0f
    739c:	88 89       	ldd	r24, Y+16	; 0x10
    739e:	99 89       	ldd	r25, Y+17	; 0x11
    73a0:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    73a4:	dc 01       	movw	r26, r24
    73a6:	cb 01       	movw	r24, r22
    73a8:	8a 8b       	std	Y+18, r24	; 0x12
    73aa:	9b 8b       	std	Y+19, r25	; 0x13
    73ac:	8a 89       	ldd	r24, Y+18	; 0x12
    73ae:	9b 89       	ldd	r25, Y+19	; 0x13
    73b0:	8e 8b       	std	Y+22, r24	; 0x16
    73b2:	9f 8b       	std	Y+23, r25	; 0x17
    73b4:	8e 89       	ldd	r24, Y+22	; 0x16
    73b6:	9f 89       	ldd	r25, Y+23	; 0x17
    73b8:	8c 01       	movw	r16, r24
    73ba:	c8 01       	movw	r24, r16
    73bc:	01 97       	sbiw	r24, 0x01	; 1
    73be:	f1 f7       	brne	.-4      	; 0x73bc <FRAMTest1Channel+0x196>
    73c0:	8c 01       	movw	r16, r24
    73c2:	0e 8b       	std	Y+22, r16	; 0x16
    73c4:	1f 8b       	std	Y+23, r17	; 0x17
    73c6:	10 c0       	rjmp	.+32     	; 0x73e8 <FRAMTest1Channel+0x1c2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    73c8:	6d 81       	ldd	r22, Y+5	; 0x05
    73ca:	7e 81       	ldd	r23, Y+6	; 0x06
    73cc:	8f 81       	ldd	r24, Y+7	; 0x07
    73ce:	98 85       	ldd	r25, Y+8	; 0x08
    73d0:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    73d4:	dc 01       	movw	r26, r24
    73d6:	cb 01       	movw	r24, r22
    73d8:	89 87       	std	Y+9, r24	; 0x09
    73da:	89 85       	ldd	r24, Y+9	; 0x09
    73dc:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    73de:	88 8d       	ldd	r24, Y+24	; 0x18
    73e0:	18 2f       	mov	r17, r24
    73e2:	1a 95       	dec	r17
    73e4:	f1 f7       	brne	.-4      	; 0x73e2 <FRAMTest1Channel+0x1bc>
    73e6:	18 8f       	std	Y+24, r17	; 0x18
	_delay_us(250);
	
	calcChecksumFRAM();
    73e8:	0e 94 89 15 	call	0x2b12	; 0x2b12 <calcChecksumFRAM>

	ADCPower(FALSE);
    73ec:	80 e0       	ldi	r24, 0x00	; 0
    73ee:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>

}
    73f2:	68 96       	adiw	r28, 0x18	; 24
    73f4:	cd bf       	out	0x3d, r28	; 61
    73f6:	de bf       	out	0x3e, r29	; 62
    73f8:	df 91       	pop	r29
    73fa:	cf 91       	pop	r28
    73fc:	1f 91       	pop	r17
    73fe:	0f 91       	pop	r16
    7400:	08 95       	ret

00007402 <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
    7402:	0f 93       	push	r16
    7404:	1f 93       	push	r17
    7406:	cf 93       	push	r28
    7408:	df 93       	push	r29
    740a:	cd b7       	in	r28, 0x3d	; 61
    740c:	de b7       	in	r29, 0x3e	; 62
    740e:	68 97       	sbiw	r28, 0x18	; 24
    7410:	cd bf       	out	0x3d, r28	; 61
    7412:	de bf       	out	0x3e, r29	; 62
	FRAMWriteKnowns();
    7414:	0e 94 91 18 	call	0x3122	; 0x3122 <FRAMWriteKnowns>
	ADCPower(TRUE);
    7418:	81 e0       	ldi	r24, 0x01	; 1
    741a:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
    741e:	80 e0       	ldi	r24, 0x00	; 0
    7420:	90 e0       	ldi	r25, 0x00	; 0
    7422:	aa e7       	ldi	r26, 0x7A	; 122
    7424:	b3 e4       	ldi	r27, 0x43	; 67
    7426:	89 83       	std	Y+1, r24	; 0x01
    7428:	9a 83       	std	Y+2, r25	; 0x02
    742a:	ab 83       	std	Y+3, r26	; 0x03
    742c:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 3e6) * __us;
    742e:	69 81       	ldd	r22, Y+1	; 0x01
    7430:	7a 81       	ldd	r23, Y+2	; 0x02
    7432:	8b 81       	ldd	r24, Y+3	; 0x03
    7434:	9c 81       	ldd	r25, Y+4	; 0x04
    7436:	2b ea       	ldi	r18, 0xAB	; 171
    7438:	3a ea       	ldi	r19, 0xAA	; 170
    743a:	4a e2       	ldi	r20, 0x2A	; 42
    743c:	51 e4       	ldi	r21, 0x41	; 65
    743e:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    7442:	dc 01       	movw	r26, r24
    7444:	cb 01       	movw	r24, r22
    7446:	8d 83       	std	Y+5, r24	; 0x05
    7448:	9e 83       	std	Y+6, r25	; 0x06
    744a:	af 83       	std	Y+7, r26	; 0x07
    744c:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    744e:	11 e0       	ldi	r17, 0x01	; 1
    7450:	6d 81       	ldd	r22, Y+5	; 0x05
    7452:	7e 81       	ldd	r23, Y+6	; 0x06
    7454:	8f 81       	ldd	r24, Y+7	; 0x07
    7456:	98 85       	ldd	r25, Y+8	; 0x08
    7458:	20 e0       	ldi	r18, 0x00	; 0
    745a:	30 e0       	ldi	r19, 0x00	; 0
    745c:	40 e8       	ldi	r20, 0x80	; 128
    745e:	5f e3       	ldi	r21, 0x3F	; 63
    7460:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    7464:	88 23       	and	r24, r24
    7466:	0c f0       	brlt	.+2      	; 0x746a <FRAMWriteKnownsCheck+0x68>
    7468:	10 e0       	ldi	r17, 0x00	; 0
    746a:	11 23       	and	r17, r17
    746c:	19 f0       	breq	.+6      	; 0x7474 <FRAMWriteKnownsCheck+0x72>
		__ticks = 1;
    746e:	81 e0       	ldi	r24, 0x01	; 1
    7470:	89 87       	std	Y+9, r24	; 0x09
    7472:	a3 c0       	rjmp	.+326    	; 0x75ba <FRAMWriteKnownsCheck+0x1b8>
	else if (__tmp > 255)
    7474:	11 e0       	ldi	r17, 0x01	; 1
    7476:	6d 81       	ldd	r22, Y+5	; 0x05
    7478:	7e 81       	ldd	r23, Y+6	; 0x06
    747a:	8f 81       	ldd	r24, Y+7	; 0x07
    747c:	98 85       	ldd	r25, Y+8	; 0x08
    747e:	20 e0       	ldi	r18, 0x00	; 0
    7480:	30 e0       	ldi	r19, 0x00	; 0
    7482:	4f e7       	ldi	r20, 0x7F	; 127
    7484:	53 e4       	ldi	r21, 0x43	; 67
    7486:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    748a:	18 16       	cp	r1, r24
    748c:	0c f0       	brlt	.+2      	; 0x7490 <FRAMWriteKnownsCheck+0x8e>
    748e:	10 e0       	ldi	r17, 0x00	; 0
    7490:	11 23       	and	r17, r17
    7492:	09 f4       	brne	.+2      	; 0x7496 <FRAMWriteKnownsCheck+0x94>
    7494:	89 c0       	rjmp	.+274    	; 0x75a8 <FRAMWriteKnownsCheck+0x1a6>
	{
		_delay_ms(__us / 1000.0);
    7496:	69 81       	ldd	r22, Y+1	; 0x01
    7498:	7a 81       	ldd	r23, Y+2	; 0x02
    749a:	8b 81       	ldd	r24, Y+3	; 0x03
    749c:	9c 81       	ldd	r25, Y+4	; 0x04
    749e:	20 e0       	ldi	r18, 0x00	; 0
    74a0:	30 e0       	ldi	r19, 0x00	; 0
    74a2:	4a e7       	ldi	r20, 0x7A	; 122
    74a4:	54 e4       	ldi	r21, 0x44	; 68
    74a6:	0e 94 23 5a 	call	0xb446	; 0xb446 <__divsf3>
    74aa:	dc 01       	movw	r26, r24
    74ac:	cb 01       	movw	r24, r22
    74ae:	8a 87       	std	Y+10, r24	; 0x0a
    74b0:	9b 87       	std	Y+11, r25	; 0x0b
    74b2:	ac 87       	std	Y+12, r26	; 0x0c
    74b4:	bd 87       	std	Y+13, r27	; 0x0d
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    74b6:	6a 85       	ldd	r22, Y+10	; 0x0a
    74b8:	7b 85       	ldd	r23, Y+11	; 0x0b
    74ba:	8c 85       	ldd	r24, Y+12	; 0x0c
    74bc:	9d 85       	ldd	r25, Y+13	; 0x0d
    74be:	20 e0       	ldi	r18, 0x00	; 0
    74c0:	30 e0       	ldi	r19, 0x00	; 0
    74c2:	4a ef       	ldi	r20, 0xFA	; 250
    74c4:	55 e4       	ldi	r21, 0x45	; 69
    74c6:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    74ca:	dc 01       	movw	r26, r24
    74cc:	cb 01       	movw	r24, r22
    74ce:	8e 87       	std	Y+14, r24	; 0x0e
    74d0:	9f 87       	std	Y+15, r25	; 0x0f
    74d2:	a8 8b       	std	Y+16, r26	; 0x10
    74d4:	b9 8b       	std	Y+17, r27	; 0x11
	if (__tmp < 1.0)
    74d6:	11 e0       	ldi	r17, 0x01	; 1
    74d8:	6e 85       	ldd	r22, Y+14	; 0x0e
    74da:	7f 85       	ldd	r23, Y+15	; 0x0f
    74dc:	88 89       	ldd	r24, Y+16	; 0x10
    74de:	99 89       	ldd	r25, Y+17	; 0x11
    74e0:	20 e0       	ldi	r18, 0x00	; 0
    74e2:	30 e0       	ldi	r19, 0x00	; 0
    74e4:	40 e8       	ldi	r20, 0x80	; 128
    74e6:	5f e3       	ldi	r21, 0x3F	; 63
    74e8:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    74ec:	88 23       	and	r24, r24
    74ee:	0c f0       	brlt	.+2      	; 0x74f2 <FRAMWriteKnownsCheck+0xf0>
    74f0:	10 e0       	ldi	r17, 0x00	; 0
    74f2:	11 23       	and	r17, r17
    74f4:	29 f0       	breq	.+10     	; 0x7500 <FRAMWriteKnownsCheck+0xfe>
		__ticks = 1;
    74f6:	81 e0       	ldi	r24, 0x01	; 1
    74f8:	90 e0       	ldi	r25, 0x00	; 0
    74fa:	8a 8b       	std	Y+18, r24	; 0x12
    74fc:	9b 8b       	std	Y+19, r25	; 0x13
    74fe:	46 c0       	rjmp	.+140    	; 0x758c <FRAMWriteKnownsCheck+0x18a>
	else if (__tmp > 65535)
    7500:	11 e0       	ldi	r17, 0x01	; 1
    7502:	6e 85       	ldd	r22, Y+14	; 0x0e
    7504:	7f 85       	ldd	r23, Y+15	; 0x0f
    7506:	88 89       	ldd	r24, Y+16	; 0x10
    7508:	99 89       	ldd	r25, Y+17	; 0x11
    750a:	20 e0       	ldi	r18, 0x00	; 0
    750c:	3f ef       	ldi	r19, 0xFF	; 255
    750e:	4f e7       	ldi	r20, 0x7F	; 127
    7510:	57 e4       	ldi	r21, 0x47	; 71
    7512:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    7516:	18 16       	cp	r1, r24
    7518:	0c f0       	brlt	.+2      	; 0x751c <FRAMWriteKnownsCheck+0x11a>
    751a:	10 e0       	ldi	r17, 0x00	; 0
    751c:	11 23       	and	r17, r17
    751e:	61 f1       	breq	.+88     	; 0x7578 <FRAMWriteKnownsCheck+0x176>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7520:	6a 85       	ldd	r22, Y+10	; 0x0a
    7522:	7b 85       	ldd	r23, Y+11	; 0x0b
    7524:	8c 85       	ldd	r24, Y+12	; 0x0c
    7526:	9d 85       	ldd	r25, Y+13	; 0x0d
    7528:	20 e0       	ldi	r18, 0x00	; 0
    752a:	30 e0       	ldi	r19, 0x00	; 0
    752c:	40 e2       	ldi	r20, 0x20	; 32
    752e:	51 e4       	ldi	r21, 0x41	; 65
    7530:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    7534:	dc 01       	movw	r26, r24
    7536:	cb 01       	movw	r24, r22
    7538:	bc 01       	movw	r22, r24
    753a:	cd 01       	movw	r24, r26
    753c:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    7540:	dc 01       	movw	r26, r24
    7542:	cb 01       	movw	r24, r22
    7544:	8a 8b       	std	Y+18, r24	; 0x12
    7546:	9b 8b       	std	Y+19, r25	; 0x13
    7548:	12 c0       	rjmp	.+36     	; 0x756e <FRAMWriteKnownsCheck+0x16c>
    754a:	80 e2       	ldi	r24, 0x20	; 32
    754c:	93 e0       	ldi	r25, 0x03	; 3
    754e:	8c 8b       	std	Y+20, r24	; 0x14
    7550:	9d 8b       	std	Y+21, r25	; 0x15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7552:	8c 89       	ldd	r24, Y+20	; 0x14
    7554:	9d 89       	ldd	r25, Y+21	; 0x15
    7556:	8c 01       	movw	r16, r24
    7558:	c8 01       	movw	r24, r16
    755a:	01 97       	sbiw	r24, 0x01	; 1
    755c:	f1 f7       	brne	.-4      	; 0x755a <FRAMWriteKnownsCheck+0x158>
    755e:	8c 01       	movw	r16, r24
    7560:	0c 8b       	std	Y+20, r16	; 0x14
    7562:	1d 8b       	std	Y+21, r17	; 0x15
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7564:	8a 89       	ldd	r24, Y+18	; 0x12
    7566:	9b 89       	ldd	r25, Y+19	; 0x13
    7568:	01 97       	sbiw	r24, 0x01	; 1
    756a:	8a 8b       	std	Y+18, r24	; 0x12
    756c:	9b 8b       	std	Y+19, r25	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    756e:	8a 89       	ldd	r24, Y+18	; 0x12
    7570:	9b 89       	ldd	r25, Y+19	; 0x13
    7572:	00 97       	sbiw	r24, 0x00	; 0
    7574:	51 f7       	brne	.-44     	; 0x754a <FRAMWriteKnownsCheck+0x148>
    7576:	28 c0       	rjmp	.+80     	; 0x75c8 <FRAMWriteKnownsCheck+0x1c6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    7578:	6e 85       	ldd	r22, Y+14	; 0x0e
    757a:	7f 85       	ldd	r23, Y+15	; 0x0f
    757c:	88 89       	ldd	r24, Y+16	; 0x10
    757e:	99 89       	ldd	r25, Y+17	; 0x11
    7580:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    7584:	dc 01       	movw	r26, r24
    7586:	cb 01       	movw	r24, r22
    7588:	8a 8b       	std	Y+18, r24	; 0x12
    758a:	9b 8b       	std	Y+19, r25	; 0x13
    758c:	8a 89       	ldd	r24, Y+18	; 0x12
    758e:	9b 89       	ldd	r25, Y+19	; 0x13
    7590:	8e 8b       	std	Y+22, r24	; 0x16
    7592:	9f 8b       	std	Y+23, r25	; 0x17
    7594:	8e 89       	ldd	r24, Y+22	; 0x16
    7596:	9f 89       	ldd	r25, Y+23	; 0x17
    7598:	8c 01       	movw	r16, r24
    759a:	c8 01       	movw	r24, r16
    759c:	01 97       	sbiw	r24, 0x01	; 1
    759e:	f1 f7       	brne	.-4      	; 0x759c <FRAMWriteKnownsCheck+0x19a>
    75a0:	8c 01       	movw	r16, r24
    75a2:	0e 8b       	std	Y+22, r16	; 0x16
    75a4:	1f 8b       	std	Y+23, r17	; 0x17
    75a6:	10 c0       	rjmp	.+32     	; 0x75c8 <FRAMWriteKnownsCheck+0x1c6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    75a8:	6d 81       	ldd	r22, Y+5	; 0x05
    75aa:	7e 81       	ldd	r23, Y+6	; 0x06
    75ac:	8f 81       	ldd	r24, Y+7	; 0x07
    75ae:	98 85       	ldd	r25, Y+8	; 0x08
    75b0:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    75b4:	dc 01       	movw	r26, r24
    75b6:	cb 01       	movw	r24, r22
    75b8:	89 87       	std	Y+9, r24	; 0x09
    75ba:	89 85       	ldd	r24, Y+9	; 0x09
    75bc:	88 8f       	std	Y+24, r24	; 0x18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    75be:	88 8d       	ldd	r24, Y+24	; 0x18
    75c0:	18 2f       	mov	r17, r24
    75c2:	1a 95       	dec	r17
    75c4:	f1 f7       	brne	.-4      	; 0x75c2 <FRAMWriteKnownsCheck+0x1c0>
    75c6:	18 8f       	std	Y+24, r17	; 0x18

	_delay_us(250);
	calcChecksumFRAM();
    75c8:	0e 94 89 15 	call	0x2b12	; 0x2b12 <calcChecksumFRAM>

	ADCPower(FALSE);
    75cc:	80 e0       	ldi	r24, 0x00	; 0
    75ce:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>

}
    75d2:	68 96       	adiw	r28, 0x18	; 24
    75d4:	cd bf       	out	0x3d, r28	; 61
    75d6:	de bf       	out	0x3e, r29	; 62
    75d8:	df 91       	pop	r29
    75da:	cf 91       	pop	r28
    75dc:	1f 91       	pop	r17
    75de:	0f 91       	pop	r16
    75e0:	08 95       	ret

000075e2 <checkMote>:

//random function for testing stuff	
void checkMote(){
    75e2:	0f 93       	push	r16
    75e4:	1f 93       	push	r17
    75e6:	cf 93       	push	r28
    75e8:	df 93       	push	r29
    75ea:	cd b7       	in	r28, 0x3d	; 61
    75ec:	de b7       	in	r29, 0x3e	; 62
    75ee:	aa 97       	sbiw	r28, 0x2a	; 42
    75f0:	cd bf       	out	0x3d, r28	; 61
    75f2:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);
    75f4:	81 e0       	ldi	r24, 0x01	; 1
    75f6:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	Ext1Power(TRUE);
    75fa:	81 e0       	ldi	r24, 0x01	; 1
    75fc:	0e 94 0d 34 	call	0x681a	; 0x681a <Ext1Power>
    7600:	80 e0       	ldi	r24, 0x00	; 0
    7602:	90 e0       	ldi	r25, 0x00	; 0
    7604:	a8 ec       	ldi	r26, 0xC8	; 200
    7606:	b2 e4       	ldi	r27, 0x42	; 66
    7608:	89 83       	std	Y+1, r24	; 0x01
    760a:	9a 83       	std	Y+2, r25	; 0x02
    760c:	ab 83       	std	Y+3, r26	; 0x03
    760e:	bc 83       	std	Y+4, r27	; 0x04
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7610:	69 81       	ldd	r22, Y+1	; 0x01
    7612:	7a 81       	ldd	r23, Y+2	; 0x02
    7614:	8b 81       	ldd	r24, Y+3	; 0x03
    7616:	9c 81       	ldd	r25, Y+4	; 0x04
    7618:	20 e0       	ldi	r18, 0x00	; 0
    761a:	30 e0       	ldi	r19, 0x00	; 0
    761c:	4a ef       	ldi	r20, 0xFA	; 250
    761e:	55 e4       	ldi	r21, 0x45	; 69
    7620:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    7624:	dc 01       	movw	r26, r24
    7626:	cb 01       	movw	r24, r22
    7628:	8d 83       	std	Y+5, r24	; 0x05
    762a:	9e 83       	std	Y+6, r25	; 0x06
    762c:	af 83       	std	Y+7, r26	; 0x07
    762e:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
    7630:	11 e0       	ldi	r17, 0x01	; 1
    7632:	6d 81       	ldd	r22, Y+5	; 0x05
    7634:	7e 81       	ldd	r23, Y+6	; 0x06
    7636:	8f 81       	ldd	r24, Y+7	; 0x07
    7638:	98 85       	ldd	r25, Y+8	; 0x08
    763a:	20 e0       	ldi	r18, 0x00	; 0
    763c:	30 e0       	ldi	r19, 0x00	; 0
    763e:	40 e8       	ldi	r20, 0x80	; 128
    7640:	5f e3       	ldi	r21, 0x3F	; 63
    7642:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    7646:	88 23       	and	r24, r24
    7648:	0c f0       	brlt	.+2      	; 0x764c <checkMote+0x6a>
    764a:	10 e0       	ldi	r17, 0x00	; 0
    764c:	11 23       	and	r17, r17
    764e:	29 f0       	breq	.+10     	; 0x765a <checkMote+0x78>
		__ticks = 1;
    7650:	81 e0       	ldi	r24, 0x01	; 1
    7652:	90 e0       	ldi	r25, 0x00	; 0
    7654:	89 87       	std	Y+9, r24	; 0x09
    7656:	9a 87       	std	Y+10, r25	; 0x0a
    7658:	46 c0       	rjmp	.+140    	; 0x76e6 <checkMote+0x104>
	else if (__tmp > 65535)
    765a:	11 e0       	ldi	r17, 0x01	; 1
    765c:	6d 81       	ldd	r22, Y+5	; 0x05
    765e:	7e 81       	ldd	r23, Y+6	; 0x06
    7660:	8f 81       	ldd	r24, Y+7	; 0x07
    7662:	98 85       	ldd	r25, Y+8	; 0x08
    7664:	20 e0       	ldi	r18, 0x00	; 0
    7666:	3f ef       	ldi	r19, 0xFF	; 255
    7668:	4f e7       	ldi	r20, 0x7F	; 127
    766a:	57 e4       	ldi	r21, 0x47	; 71
    766c:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    7670:	18 16       	cp	r1, r24
    7672:	0c f0       	brlt	.+2      	; 0x7676 <checkMote+0x94>
    7674:	10 e0       	ldi	r17, 0x00	; 0
    7676:	11 23       	and	r17, r17
    7678:	61 f1       	breq	.+88     	; 0x76d2 <checkMote+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    767a:	69 81       	ldd	r22, Y+1	; 0x01
    767c:	7a 81       	ldd	r23, Y+2	; 0x02
    767e:	8b 81       	ldd	r24, Y+3	; 0x03
    7680:	9c 81       	ldd	r25, Y+4	; 0x04
    7682:	20 e0       	ldi	r18, 0x00	; 0
    7684:	30 e0       	ldi	r19, 0x00	; 0
    7686:	40 e2       	ldi	r20, 0x20	; 32
    7688:	51 e4       	ldi	r21, 0x41	; 65
    768a:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    768e:	dc 01       	movw	r26, r24
    7690:	cb 01       	movw	r24, r22
    7692:	bc 01       	movw	r22, r24
    7694:	cd 01       	movw	r24, r26
    7696:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    769a:	dc 01       	movw	r26, r24
    769c:	cb 01       	movw	r24, r22
    769e:	89 87       	std	Y+9, r24	; 0x09
    76a0:	9a 87       	std	Y+10, r25	; 0x0a
    76a2:	12 c0       	rjmp	.+36     	; 0x76c8 <checkMote+0xe6>
    76a4:	80 e2       	ldi	r24, 0x20	; 32
    76a6:	93 e0       	ldi	r25, 0x03	; 3
    76a8:	8b 87       	std	Y+11, r24	; 0x0b
    76aa:	9c 87       	std	Y+12, r25	; 0x0c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    76ac:	8b 85       	ldd	r24, Y+11	; 0x0b
    76ae:	9c 85       	ldd	r25, Y+12	; 0x0c
    76b0:	8c 01       	movw	r16, r24
    76b2:	c8 01       	movw	r24, r16
    76b4:	01 97       	sbiw	r24, 0x01	; 1
    76b6:	f1 f7       	brne	.-4      	; 0x76b4 <checkMote+0xd2>
    76b8:	8c 01       	movw	r16, r24
    76ba:	0b 87       	std	Y+11, r16	; 0x0b
    76bc:	1c 87       	std	Y+12, r17	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    76be:	89 85       	ldd	r24, Y+9	; 0x09
    76c0:	9a 85       	ldd	r25, Y+10	; 0x0a
    76c2:	01 97       	sbiw	r24, 0x01	; 1
    76c4:	89 87       	std	Y+9, r24	; 0x09
    76c6:	9a 87       	std	Y+10, r25	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    76c8:	89 85       	ldd	r24, Y+9	; 0x09
    76ca:	9a 85       	ldd	r25, Y+10	; 0x0a
    76cc:	00 97       	sbiw	r24, 0x00	; 0
    76ce:	51 f7       	brne	.-44     	; 0x76a4 <checkMote+0xc2>
    76d0:	17 c0       	rjmp	.+46     	; 0x7700 <checkMote+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    76d2:	6d 81       	ldd	r22, Y+5	; 0x05
    76d4:	7e 81       	ldd	r23, Y+6	; 0x06
    76d6:	8f 81       	ldd	r24, Y+7	; 0x07
    76d8:	98 85       	ldd	r25, Y+8	; 0x08
    76da:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    76de:	dc 01       	movw	r26, r24
    76e0:	cb 01       	movw	r24, r22
    76e2:	89 87       	std	Y+9, r24	; 0x09
    76e4:	9a 87       	std	Y+10, r25	; 0x0a
    76e6:	89 85       	ldd	r24, Y+9	; 0x09
    76e8:	9a 85       	ldd	r25, Y+10	; 0x0a
    76ea:	8d 87       	std	Y+13, r24	; 0x0d
    76ec:	9e 87       	std	Y+14, r25	; 0x0e
    76ee:	8d 85       	ldd	r24, Y+13	; 0x0d
    76f0:	9e 85       	ldd	r25, Y+14	; 0x0e
    76f2:	8c 01       	movw	r16, r24
    76f4:	c8 01       	movw	r24, r16
    76f6:	01 97       	sbiw	r24, 0x01	; 1
    76f8:	f1 f7       	brne	.-4      	; 0x76f6 <checkMote+0x114>
    76fa:	8c 01       	movw	r16, r24
    76fc:	0d 87       	std	Y+13, r16	; 0x0d
    76fe:	1e 87       	std	Y+14, r17	; 0x0e
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    7700:	88 e0       	ldi	r24, 0x08	; 8
    7702:	60 e0       	ldi	r22, 0x00	; 0
    7704:	0e 94 77 32 	call	0x64ee	; 0x64ee <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    7708:	88 e0       	ldi	r24, 0x08	; 8
    770a:	60 e0       	ldi	r22, 0x00	; 0
    770c:	0e 94 43 33 	call	0x6686	; 0x6686 <PortEx_OUTSET>
    7710:	80 e0       	ldi	r24, 0x00	; 0
    7712:	90 e4       	ldi	r25, 0x40	; 64
    7714:	ac e9       	ldi	r26, 0x9C	; 156
    7716:	b5 e4       	ldi	r27, 0x45	; 69
    7718:	8f 87       	std	Y+15, r24	; 0x0f
    771a:	98 8b       	std	Y+16, r25	; 0x10
    771c:	a9 8b       	std	Y+17, r26	; 0x11
    771e:	ba 8b       	std	Y+18, r27	; 0x12
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7720:	6f 85       	ldd	r22, Y+15	; 0x0f
    7722:	78 89       	ldd	r23, Y+16	; 0x10
    7724:	89 89       	ldd	r24, Y+17	; 0x11
    7726:	9a 89       	ldd	r25, Y+18	; 0x12
    7728:	20 e0       	ldi	r18, 0x00	; 0
    772a:	30 e0       	ldi	r19, 0x00	; 0
    772c:	4a ef       	ldi	r20, 0xFA	; 250
    772e:	55 e4       	ldi	r21, 0x45	; 69
    7730:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    7734:	dc 01       	movw	r26, r24
    7736:	cb 01       	movw	r24, r22
    7738:	8b 8b       	std	Y+19, r24	; 0x13
    773a:	9c 8b       	std	Y+20, r25	; 0x14
    773c:	ad 8b       	std	Y+21, r26	; 0x15
    773e:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
    7740:	11 e0       	ldi	r17, 0x01	; 1
    7742:	6b 89       	ldd	r22, Y+19	; 0x13
    7744:	7c 89       	ldd	r23, Y+20	; 0x14
    7746:	8d 89       	ldd	r24, Y+21	; 0x15
    7748:	9e 89       	ldd	r25, Y+22	; 0x16
    774a:	20 e0       	ldi	r18, 0x00	; 0
    774c:	30 e0       	ldi	r19, 0x00	; 0
    774e:	40 e8       	ldi	r20, 0x80	; 128
    7750:	5f e3       	ldi	r21, 0x3F	; 63
    7752:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    7756:	88 23       	and	r24, r24
    7758:	0c f0       	brlt	.+2      	; 0x775c <checkMote+0x17a>
    775a:	10 e0       	ldi	r17, 0x00	; 0
    775c:	11 23       	and	r17, r17
    775e:	29 f0       	breq	.+10     	; 0x776a <checkMote+0x188>
		__ticks = 1;
    7760:	81 e0       	ldi	r24, 0x01	; 1
    7762:	90 e0       	ldi	r25, 0x00	; 0
    7764:	8f 8b       	std	Y+23, r24	; 0x17
    7766:	98 8f       	std	Y+24, r25	; 0x18
    7768:	46 c0       	rjmp	.+140    	; 0x77f6 <checkMote+0x214>
	else if (__tmp > 65535)
    776a:	11 e0       	ldi	r17, 0x01	; 1
    776c:	6b 89       	ldd	r22, Y+19	; 0x13
    776e:	7c 89       	ldd	r23, Y+20	; 0x14
    7770:	8d 89       	ldd	r24, Y+21	; 0x15
    7772:	9e 89       	ldd	r25, Y+22	; 0x16
    7774:	20 e0       	ldi	r18, 0x00	; 0
    7776:	3f ef       	ldi	r19, 0xFF	; 255
    7778:	4f e7       	ldi	r20, 0x7F	; 127
    777a:	57 e4       	ldi	r21, 0x47	; 71
    777c:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    7780:	18 16       	cp	r1, r24
    7782:	0c f0       	brlt	.+2      	; 0x7786 <checkMote+0x1a4>
    7784:	10 e0       	ldi	r17, 0x00	; 0
    7786:	11 23       	and	r17, r17
    7788:	61 f1       	breq	.+88     	; 0x77e2 <checkMote+0x200>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    778a:	6f 85       	ldd	r22, Y+15	; 0x0f
    778c:	78 89       	ldd	r23, Y+16	; 0x10
    778e:	89 89       	ldd	r24, Y+17	; 0x11
    7790:	9a 89       	ldd	r25, Y+18	; 0x12
    7792:	20 e0       	ldi	r18, 0x00	; 0
    7794:	30 e0       	ldi	r19, 0x00	; 0
    7796:	40 e2       	ldi	r20, 0x20	; 32
    7798:	51 e4       	ldi	r21, 0x41	; 65
    779a:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    779e:	dc 01       	movw	r26, r24
    77a0:	cb 01       	movw	r24, r22
    77a2:	bc 01       	movw	r22, r24
    77a4:	cd 01       	movw	r24, r26
    77a6:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    77aa:	dc 01       	movw	r26, r24
    77ac:	cb 01       	movw	r24, r22
    77ae:	8f 8b       	std	Y+23, r24	; 0x17
    77b0:	98 8f       	std	Y+24, r25	; 0x18
    77b2:	12 c0       	rjmp	.+36     	; 0x77d8 <checkMote+0x1f6>
    77b4:	80 e2       	ldi	r24, 0x20	; 32
    77b6:	93 e0       	ldi	r25, 0x03	; 3
    77b8:	89 8f       	std	Y+25, r24	; 0x19
    77ba:	9a 8f       	std	Y+26, r25	; 0x1a
    77bc:	89 8d       	ldd	r24, Y+25	; 0x19
    77be:	9a 8d       	ldd	r25, Y+26	; 0x1a
    77c0:	8c 01       	movw	r16, r24
    77c2:	c8 01       	movw	r24, r16
    77c4:	01 97       	sbiw	r24, 0x01	; 1
    77c6:	f1 f7       	brne	.-4      	; 0x77c4 <checkMote+0x1e2>
    77c8:	8c 01       	movw	r16, r24
    77ca:	09 8f       	std	Y+25, r16	; 0x19
    77cc:	1a 8f       	std	Y+26, r17	; 0x1a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    77ce:	8f 89       	ldd	r24, Y+23	; 0x17
    77d0:	98 8d       	ldd	r25, Y+24	; 0x18
    77d2:	01 97       	sbiw	r24, 0x01	; 1
    77d4:	8f 8b       	std	Y+23, r24	; 0x17
    77d6:	98 8f       	std	Y+24, r25	; 0x18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    77d8:	8f 89       	ldd	r24, Y+23	; 0x17
    77da:	98 8d       	ldd	r25, Y+24	; 0x18
    77dc:	00 97       	sbiw	r24, 0x00	; 0
    77de:	51 f7       	brne	.-44     	; 0x77b4 <checkMote+0x1d2>
    77e0:	17 c0       	rjmp	.+46     	; 0x7810 <checkMote+0x22e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    77e2:	6b 89       	ldd	r22, Y+19	; 0x13
    77e4:	7c 89       	ldd	r23, Y+20	; 0x14
    77e6:	8d 89       	ldd	r24, Y+21	; 0x15
    77e8:	9e 89       	ldd	r25, Y+22	; 0x16
    77ea:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    77ee:	dc 01       	movw	r26, r24
    77f0:	cb 01       	movw	r24, r22
    77f2:	8f 8b       	std	Y+23, r24	; 0x17
    77f4:	98 8f       	std	Y+24, r25	; 0x18
    77f6:	8f 89       	ldd	r24, Y+23	; 0x17
    77f8:	98 8d       	ldd	r25, Y+24	; 0x18
    77fa:	8b 8f       	std	Y+27, r24	; 0x1b
    77fc:	9c 8f       	std	Y+28, r25	; 0x1c
    77fe:	8b 8d       	ldd	r24, Y+27	; 0x1b
    7800:	9c 8d       	ldd	r25, Y+28	; 0x1c
    7802:	8c 01       	movw	r16, r24
    7804:	c8 01       	movw	r24, r16
    7806:	01 97       	sbiw	r24, 0x01	; 1
    7808:	f1 f7       	brne	.-4      	; 0x7806 <checkMote+0x224>
    780a:	8c 01       	movw	r16, r24
    780c:	0b 8f       	std	Y+27, r16	; 0x1b
    780e:	1c 8f       	std	Y+28, r17	; 0x1c
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    7810:	88 e0       	ldi	r24, 0x08	; 8
    7812:	60 e0       	ldi	r22, 0x00	; 0
    7814:	0e 94 a6 33 	call	0x674c	; 0x674c <PortEx_OUTCLR>
    7818:	80 e0       	ldi	r24, 0x00	; 0
    781a:	90 e4       	ldi	r25, 0x40	; 64
    781c:	ac e9       	ldi	r26, 0x9C	; 156
    781e:	b5 e4       	ldi	r27, 0x45	; 69
    7820:	8d 8f       	std	Y+29, r24	; 0x1d
    7822:	9e 8f       	std	Y+30, r25	; 0x1e
    7824:	af 8f       	std	Y+31, r26	; 0x1f
    7826:	b8 a3       	lds	r27, 0x58
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    7828:	6d 8d       	ldd	r22, Y+29	; 0x1d
    782a:	7e 8d       	ldd	r23, Y+30	; 0x1e
    782c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    782e:	98 a1       	lds	r25, 0x48
    7830:	20 e0       	ldi	r18, 0x00	; 0
    7832:	30 e0       	ldi	r19, 0x00	; 0
    7834:	4a ef       	ldi	r20, 0xFA	; 250
    7836:	55 e4       	ldi	r21, 0x45	; 69
    7838:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    783c:	dc 01       	movw	r26, r24
    783e:	cb 01       	movw	r24, r22
    7840:	89 a3       	lds	r24, 0x59
    7842:	9a a3       	lds	r25, 0x5a
    7844:	ab a3       	lds	r26, 0x5b
    7846:	bc a3       	lds	r27, 0x5c
	if (__tmp < 1.0)
    7848:	11 e0       	ldi	r17, 0x01	; 1
    784a:	69 a1       	lds	r22, 0x49
    784c:	7a a1       	lds	r23, 0x4a
    784e:	8b a1       	lds	r24, 0x4b
    7850:	9c a1       	lds	r25, 0x4c
    7852:	20 e0       	ldi	r18, 0x00	; 0
    7854:	30 e0       	ldi	r19, 0x00	; 0
    7856:	40 e8       	ldi	r20, 0x80	; 128
    7858:	5f e3       	ldi	r21, 0x3F	; 63
    785a:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    785e:	88 23       	and	r24, r24
    7860:	0c f0       	brlt	.+2      	; 0x7864 <checkMote+0x282>
    7862:	10 e0       	ldi	r17, 0x00	; 0
    7864:	11 23       	and	r17, r17
    7866:	29 f0       	breq	.+10     	; 0x7872 <checkMote+0x290>
		__ticks = 1;
    7868:	81 e0       	ldi	r24, 0x01	; 1
    786a:	90 e0       	ldi	r25, 0x00	; 0
    786c:	8d a3       	lds	r24, 0x5d
    786e:	9e a3       	lds	r25, 0x5e
    7870:	46 c0       	rjmp	.+140    	; 0x78fe <checkMote+0x31c>
	else if (__tmp > 65535)
    7872:	11 e0       	ldi	r17, 0x01	; 1
    7874:	69 a1       	lds	r22, 0x49
    7876:	7a a1       	lds	r23, 0x4a
    7878:	8b a1       	lds	r24, 0x4b
    787a:	9c a1       	lds	r25, 0x4c
    787c:	20 e0       	ldi	r18, 0x00	; 0
    787e:	3f ef       	ldi	r19, 0xFF	; 255
    7880:	4f e7       	ldi	r20, 0x7F	; 127
    7882:	57 e4       	ldi	r21, 0x47	; 71
    7884:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    7888:	18 16       	cp	r1, r24
    788a:	0c f0       	brlt	.+2      	; 0x788e <checkMote+0x2ac>
    788c:	10 e0       	ldi	r17, 0x00	; 0
    788e:	11 23       	and	r17, r17
    7890:	61 f1       	breq	.+88     	; 0x78ea <checkMote+0x308>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    7892:	6d 8d       	ldd	r22, Y+29	; 0x1d
    7894:	7e 8d       	ldd	r23, Y+30	; 0x1e
    7896:	8f 8d       	ldd	r24, Y+31	; 0x1f
    7898:	98 a1       	lds	r25, 0x48
    789a:	20 e0       	ldi	r18, 0x00	; 0
    789c:	30 e0       	ldi	r19, 0x00	; 0
    789e:	40 e2       	ldi	r20, 0x20	; 32
    78a0:	51 e4       	ldi	r21, 0x41	; 65
    78a2:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    78a6:	dc 01       	movw	r26, r24
    78a8:	cb 01       	movw	r24, r22
    78aa:	bc 01       	movw	r22, r24
    78ac:	cd 01       	movw	r24, r26
    78ae:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    78b2:	dc 01       	movw	r26, r24
    78b4:	cb 01       	movw	r24, r22
    78b6:	8d a3       	lds	r24, 0x5d
    78b8:	9e a3       	lds	r25, 0x5e
    78ba:	12 c0       	rjmp	.+36     	; 0x78e0 <checkMote+0x2fe>
    78bc:	80 e2       	ldi	r24, 0x20	; 32
    78be:	93 e0       	ldi	r25, 0x03	; 3
    78c0:	8f a3       	lds	r24, 0x5f
    78c2:	98 a7       	lds	r25, 0x78
    78c4:	8f a1       	lds	r24, 0x4f
    78c6:	98 a5       	lds	r25, 0x68
    78c8:	8c 01       	movw	r16, r24
    78ca:	c8 01       	movw	r24, r16
    78cc:	01 97       	sbiw	r24, 0x01	; 1
    78ce:	f1 f7       	brne	.-4      	; 0x78cc <checkMote+0x2ea>
    78d0:	8c 01       	movw	r16, r24
    78d2:	0f a3       	lds	r16, 0x5f
    78d4:	18 a7       	lds	r17, 0x78
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    78d6:	8d a1       	lds	r24, 0x4d
    78d8:	9e a1       	lds	r25, 0x4e
    78da:	01 97       	sbiw	r24, 0x01	; 1
    78dc:	8d a3       	lds	r24, 0x5d
    78de:	9e a3       	lds	r25, 0x5e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    78e0:	8d a1       	lds	r24, 0x4d
    78e2:	9e a1       	lds	r25, 0x4e
    78e4:	00 97       	sbiw	r24, 0x00	; 0
    78e6:	51 f7       	brne	.-44     	; 0x78bc <checkMote+0x2da>
    78e8:	18 c0       	rjmp	.+48     	; 0x791a <checkMote+0x338>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    78ea:	69 a1       	lds	r22, 0x49
    78ec:	7a a1       	lds	r23, 0x4a
    78ee:	8b a1       	lds	r24, 0x4b
    78f0:	9c a1       	lds	r25, 0x4c
    78f2:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    78f6:	dc 01       	movw	r26, r24
    78f8:	cb 01       	movw	r24, r22
    78fa:	8d a3       	lds	r24, 0x5d
    78fc:	9e a3       	lds	r25, 0x5e
    78fe:	8d a1       	lds	r24, 0x4d
    7900:	9e a1       	lds	r25, 0x4e
    7902:	89 a7       	lds	r24, 0x79
    7904:	9a a7       	lds	r25, 0x7a
    7906:	89 a5       	lds	r24, 0x69
    7908:	9a a5       	lds	r25, 0x6a
    790a:	8c 01       	movw	r16, r24
    790c:	c8 01       	movw	r24, r16
    790e:	01 97       	sbiw	r24, 0x01	; 1
    7910:	f1 f7       	brne	.-4      	; 0x790e <checkMote+0x32c>
    7912:	8c 01       	movw	r16, r24
    7914:	09 a7       	lds	r16, 0x79
    7916:	1a a7       	lds	r17, 0x7a
		_delay_ms(5000);
	}
    7918:	f7 ce       	rjmp	.-530    	; 0x7708 <checkMote+0x126>
    791a:	f6 ce       	rjmp	.-532    	; 0x7708 <checkMote+0x126>

0000791c <SD_write_and_read_knowns>:
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    791c:	cf 93       	push	r28
    791e:	df 93       	push	r29
    7920:	cd b7       	in	r28, 0x3d	; 61
    7922:	de b7       	in	r29, 0x3e	; 62
    7924:	28 97       	sbiw	r28, 0x08	; 8
    7926:	cd bf       	out	0x3d, r28	; 61
    7928:	de bf       	out	0x3e, r29	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    792a:	19 82       	std	Y+1, r1	; 0x01
    792c:	1a 82       	std	Y+2, r1	; 0x02
    792e:	0c c0       	rjmp	.+24     	; 0x7948 <SD_write_and_read_knowns+0x2c>
    7930:	29 81       	ldd	r18, Y+1	; 0x01
    7932:	89 81       	ldd	r24, Y+1	; 0x01
    7934:	9a 81       	ldd	r25, Y+2	; 0x02
    7936:	88 52       	subi	r24, 0x28	; 40
    7938:	9c 4d       	sbci	r25, 0xDC	; 220
    793a:	fc 01       	movw	r30, r24
    793c:	20 83       	st	Z, r18
    793e:	89 81       	ldd	r24, Y+1	; 0x01
    7940:	9a 81       	ldd	r25, Y+2	; 0x02
    7942:	01 96       	adiw	r24, 0x01	; 1
    7944:	89 83       	std	Y+1, r24	; 0x01
    7946:	9a 83       	std	Y+2, r25	; 0x02
    7948:	89 81       	ldd	r24, Y+1	; 0x01
    794a:	9a 81       	ldd	r25, Y+2	; 0x02
    794c:	88 31       	cpi	r24, 0x18	; 24
    794e:	91 05       	cpc	r25, r1
    7950:	7c f3       	brlt	.-34     	; 0x7930 <SD_write_and_read_knowns+0x14>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    7952:	28 ed       	ldi	r18, 0xD8	; 216
    7954:	33 e2       	ldi	r19, 0x23	; 35
    7956:	64 e1       	ldi	r22, 0x14	; 20
    7958:	70 e0       	ldi	r23, 0x00	; 0
    795a:	80 e0       	ldi	r24, 0x00	; 0
    795c:	90 e0       	ldi	r25, 0x00	; 0
    795e:	a9 01       	movw	r20, r18
    7960:	28 e1       	ldi	r18, 0x18	; 24
    7962:	30 e0       	ldi	r19, 0x00	; 0
    7964:	0e 94 ac 4d 	call	0x9b58	; 0x9b58 <SD_write_block>
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7968:	1b 82       	std	Y+3, r1	; 0x03
    796a:	1c 82       	std	Y+4, r1	; 0x04
    796c:	0b c0       	rjmp	.+22     	; 0x7984 <SD_write_and_read_knowns+0x68>
    796e:	8b 81       	ldd	r24, Y+3	; 0x03
    7970:	9c 81       	ldd	r25, Y+4	; 0x04
    7972:	88 52       	subi	r24, 0x28	; 40
    7974:	9c 4d       	sbci	r25, 0xDC	; 220
    7976:	fc 01       	movw	r30, r24
    7978:	10 82       	st	Z, r1
    797a:	8b 81       	ldd	r24, Y+3	; 0x03
    797c:	9c 81       	ldd	r25, Y+4	; 0x04
    797e:	01 96       	adiw	r24, 0x01	; 1
    7980:	8b 83       	std	Y+3, r24	; 0x03
    7982:	9c 83       	std	Y+4, r25	; 0x04
    7984:	8b 81       	ldd	r24, Y+3	; 0x03
    7986:	9c 81       	ldd	r25, Y+4	; 0x04
    7988:	88 31       	cpi	r24, 0x18	; 24
    798a:	91 05       	cpc	r25, r1
    798c:	84 f3       	brlt	.-32     	; 0x796e <SD_write_and_read_knowns+0x52>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    798e:	28 ed       	ldi	r18, 0xD8	; 216
    7990:	33 e2       	ldi	r19, 0x23	; 35
    7992:	64 e1       	ldi	r22, 0x14	; 20
    7994:	70 e0       	ldi	r23, 0x00	; 0
    7996:	80 e0       	ldi	r24, 0x00	; 0
    7998:	90 e0       	ldi	r25, 0x00	; 0
    799a:	a9 01       	movw	r20, r18
    799c:	0e 94 7a 4e 	call	0x9cf4	; 0x9cf4 <SD_read_block>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    79a0:	1d 82       	std	Y+5, r1	; 0x05
    79a2:	1e 82       	std	Y+6, r1	; 0x06
    79a4:	13 c0       	rjmp	.+38     	; 0x79cc <SD_write_and_read_knowns+0xb0>
    79a6:	8d 81       	ldd	r24, Y+5	; 0x05
    79a8:	9e 81       	ldd	r25, Y+6	; 0x06
    79aa:	24 e6       	ldi	r18, 0x64	; 100
    79ac:	30 e0       	ldi	r19, 0x00	; 0
    79ae:	b9 01       	movw	r22, r18
    79b0:	0e 94 c6 5b 	call	0xb78c	; 0xb78c <__divmodhi4>
    79b4:	28 2f       	mov	r18, r24
    79b6:	8d 81       	ldd	r24, Y+5	; 0x05
    79b8:	9e 81       	ldd	r25, Y+6	; 0x06
    79ba:	88 52       	subi	r24, 0x28	; 40
    79bc:	9c 4d       	sbci	r25, 0xDC	; 220
    79be:	fc 01       	movw	r30, r24
    79c0:	20 83       	st	Z, r18
    79c2:	8d 81       	ldd	r24, Y+5	; 0x05
    79c4:	9e 81       	ldd	r25, Y+6	; 0x06
    79c6:	01 96       	adiw	r24, 0x01	; 1
    79c8:	8d 83       	std	Y+5, r24	; 0x05
    79ca:	9e 83       	std	Y+6, r25	; 0x06
    79cc:	8d 81       	ldd	r24, Y+5	; 0x05
    79ce:	9e 81       	ldd	r25, Y+6	; 0x06
    79d0:	f4 e0       	ldi	r31, 0x04	; 4
    79d2:	82 3e       	cpi	r24, 0xE2	; 226
    79d4:	9f 07       	cpc	r25, r31
    79d6:	3c f3       	brlt	.-50     	; 0x79a6 <SD_write_and_read_knowns+0x8a>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    79d8:	28 ed       	ldi	r18, 0xD8	; 216
    79da:	33 e2       	ldi	r19, 0x23	; 35
    79dc:	60 e5       	ldi	r22, 0x50	; 80
    79de:	70 e0       	ldi	r23, 0x00	; 0
    79e0:	80 e0       	ldi	r24, 0x00	; 0
    79e2:	90 e0       	ldi	r25, 0x00	; 0
    79e4:	a9 01       	movw	r20, r18
    79e6:	22 ee       	ldi	r18, 0xE2	; 226
    79e8:	34 e0       	ldi	r19, 0x04	; 4
    79ea:	0e 94 f0 4e 	call	0x9de0	; 0x9de0 <SD_write_multiple_blocks>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    79ee:	1f 82       	std	Y+7, r1	; 0x07
    79f0:	18 86       	std	Y+8, r1	; 0x08
    79f2:	0b c0       	rjmp	.+22     	; 0x7a0a <SD_write_and_read_knowns+0xee>
    79f4:	8f 81       	ldd	r24, Y+7	; 0x07
    79f6:	98 85       	ldd	r25, Y+8	; 0x08
    79f8:	88 52       	subi	r24, 0x28	; 40
    79fa:	9c 4d       	sbci	r25, 0xDC	; 220
    79fc:	fc 01       	movw	r30, r24
    79fe:	10 82       	st	Z, r1
    7a00:	8f 81       	ldd	r24, Y+7	; 0x07
    7a02:	98 85       	ldd	r25, Y+8	; 0x08
    7a04:	01 96       	adiw	r24, 0x01	; 1
    7a06:	8f 83       	std	Y+7, r24	; 0x07
    7a08:	98 87       	std	Y+8, r25	; 0x08
    7a0a:	8f 81       	ldd	r24, Y+7	; 0x07
    7a0c:	98 85       	ldd	r25, Y+8	; 0x08
    7a0e:	f4 e0       	ldi	r31, 0x04	; 4
    7a10:	82 3e       	cpi	r24, 0xE2	; 226
    7a12:	9f 07       	cpc	r25, r31
    7a14:	7c f3       	brlt	.-34     	; 0x79f4 <SD_write_and_read_knowns+0xd8>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    7a16:	28 ed       	ldi	r18, 0xD8	; 216
    7a18:	33 e2       	ldi	r19, 0x23	; 35
    7a1a:	60 e5       	ldi	r22, 0x50	; 80
    7a1c:	70 e0       	ldi	r23, 0x00	; 0
    7a1e:	80 e0       	ldi	r24, 0x00	; 0
    7a20:	90 e0       	ldi	r25, 0x00	; 0
    7a22:	a9 01       	movw	r20, r18
    7a24:	23 e0       	ldi	r18, 0x03	; 3
    7a26:	30 e0       	ldi	r19, 0x00	; 0
    7a28:	0e 94 4e 50 	call	0xa09c	; 0xa09c <SD_read_multiple_blocks>
}
    7a2c:	28 96       	adiw	r28, 0x08	; 8
    7a2e:	cd bf       	out	0x3d, r28	; 61
    7a30:	de bf       	out	0x3e, r29	; 62
    7a32:	df 91       	pop	r29
    7a34:	cf 91       	pop	r28
    7a36:	08 95       	ret

00007a38 <SD_write_and_read_knowns_FAT>:
//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
    7a38:	cf 93       	push	r28
    7a3a:	df 93       	push	r29
    7a3c:	00 d0       	rcall	.+0      	; 0x7a3e <SD_write_and_read_knowns_FAT+0x6>
    7a3e:	0f 92       	push	r0
    7a40:	cd b7       	in	r28, 0x3d	; 61
    7a42:	de b7       	in	r29, 0x3e	; 62
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    7a44:	19 82       	std	Y+1, r1	; 0x01
    7a46:	1a 82       	std	Y+2, r1	; 0x02
    7a48:	0c c0       	rjmp	.+24     	; 0x7a62 <SD_write_and_read_knowns_FAT+0x2a>
    7a4a:	29 81       	ldd	r18, Y+1	; 0x01
    7a4c:	89 81       	ldd	r24, Y+1	; 0x01
    7a4e:	9a 81       	ldd	r25, Y+2	; 0x02
    7a50:	88 52       	subi	r24, 0x28	; 40
    7a52:	9c 4d       	sbci	r25, 0xDC	; 220
    7a54:	fc 01       	movw	r30, r24
    7a56:	20 83       	st	Z, r18
    7a58:	89 81       	ldd	r24, Y+1	; 0x01
    7a5a:	9a 81       	ldd	r25, Y+2	; 0x02
    7a5c:	01 96       	adiw	r24, 0x01	; 1
    7a5e:	89 83       	std	Y+1, r24	; 0x01
    7a60:	9a 83       	std	Y+2, r25	; 0x02
    7a62:	89 81       	ldd	r24, Y+1	; 0x01
    7a64:	9a 81       	ldd	r25, Y+2	; 0x02
    7a66:	88 31       	cpi	r24, 0x18	; 24
    7a68:	91 05       	cpc	r25, r1
    7a6a:	7c f3       	brlt	.-34     	; 0x7a4a <SD_write_and_read_knowns_FAT+0x12>
	error = writeFile("testing",FRAMReadBuffer,512);
    7a6c:	81 e1       	ldi	r24, 0x11	; 17
    7a6e:	90 e2       	ldi	r25, 0x20	; 32
    7a70:	28 ed       	ldi	r18, 0xD8	; 216
    7a72:	33 e2       	ldi	r19, 0x23	; 35
    7a74:	b9 01       	movw	r22, r18
    7a76:	20 e0       	ldi	r18, 0x00	; 0
    7a78:	32 e0       	ldi	r19, 0x02	; 2
    7a7a:	40 e0       	ldi	r20, 0x00	; 0
    7a7c:	50 e0       	ldi	r21, 0x00	; 0
    7a7e:	0e 94 9a 45 	call	0x8b34	; 0x8b34 <writeFile>
    7a82:	80 93 a4 50 	sts	0x50A4, r24
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    7a86:	1b 82       	std	Y+3, r1	; 0x03
    7a88:	1c 82       	std	Y+4, r1	; 0x04
    7a8a:	0b c0       	rjmp	.+22     	; 0x7aa2 <SD_write_and_read_knowns_FAT+0x6a>
    7a8c:	8b 81       	ldd	r24, Y+3	; 0x03
    7a8e:	9c 81       	ldd	r25, Y+4	; 0x04
    7a90:	88 52       	subi	r24, 0x28	; 40
    7a92:	9c 4d       	sbci	r25, 0xDC	; 220
    7a94:	fc 01       	movw	r30, r24
    7a96:	10 82       	st	Z, r1
    7a98:	8b 81       	ldd	r24, Y+3	; 0x03
    7a9a:	9c 81       	ldd	r25, Y+4	; 0x04
    7a9c:	01 96       	adiw	r24, 0x01	; 1
    7a9e:	8b 83       	std	Y+3, r24	; 0x03
    7aa0:	9c 83       	std	Y+4, r25	; 0x04
    7aa2:	8b 81       	ldd	r24, Y+3	; 0x03
    7aa4:	9c 81       	ldd	r25, Y+4	; 0x04
    7aa6:	88 31       	cpi	r24, 0x18	; 24
    7aa8:	91 05       	cpc	r25, r1
    7aaa:	84 f3       	brlt	.-32     	; 0x7a8c <SD_write_and_read_knowns_FAT+0x54>
	error = readFile(READ,"testing");		//read the data into the buffer from file
    7aac:	21 e1       	ldi	r18, 0x11	; 17
    7aae:	30 e2       	ldi	r19, 0x20	; 32
    7ab0:	80 e0       	ldi	r24, 0x00	; 0
    7ab2:	b9 01       	movw	r22, r18
    7ab4:	0e 94 b5 43 	call	0x876a	; 0x876a <readFile>
    7ab8:	80 93 a4 50 	sts	0x50A4, r24
}
    7abc:	24 96       	adiw	r28, 0x04	; 4
    7abe:	cd bf       	out	0x3d, r28	; 61
    7ac0:	de bf       	out	0x3e, r29	; 62
    7ac2:	df 91       	pop	r29
    7ac4:	cf 91       	pop	r28
    7ac6:	08 95       	ret

00007ac8 <chibi_test_radio>:




//function for testing radio transmission
void chibi_test_radio(){
    7ac8:	cf 93       	push	r28
    7aca:	df 93       	push	r29
    7acc:	cd b7       	in	r28, 0x3d	; 61
    7ace:	de b7       	in	r29, 0x3e	; 62
		
	chb_init();
    7ad0:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <chb_init>
	chb_set_short_addr(0x0002);
    7ad4:	82 e0       	ldi	r24, 0x02	; 2
    7ad6:	90 e0       	ldi	r25, 0x00	; 0
    7ad8:	0e 94 2a 2b 	call	0x5654	; 0x5654 <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    7adc:	00 00       	nop
    7ade:	fe cf       	rjmp	.-4      	; 0x7adc <chibi_test_radio+0x14>

00007ae0 <TestCard>:
	for (int i=0;i<10;i++) FRAMReadBuffer[i] = 0;
	chb_read(FRAMReadBuffer);
	*/
}
//another testing function for sd card
void TestCard(){
    7ae0:	cf 93       	push	r28
    7ae2:	df 93       	push	r29
    7ae4:	0f 92       	push	r0
    7ae6:	0f 92       	push	r0
    7ae8:	cd b7       	in	r28, 0x3d	; 61
    7aea:	de b7       	in	r29, 0x3e	; 62
	SD_init();
    7aec:	0e 94 05 4b 	call	0x960a	; 0x960a <SD_init>
	getBootSectorData();
    7af0:	0e 94 05 3f 	call	0x7e0a	; 0x7e0a <getBootSectorData>
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    7af4:	19 82       	std	Y+1, r1	; 0x01
    7af6:	1a 82       	std	Y+2, r1	; 0x02
    7af8:	13 c0       	rjmp	.+38     	; 0x7b20 <TestCard+0x40>
    7afa:	89 81       	ldd	r24, Y+1	; 0x01
    7afc:	9a 81       	ldd	r25, Y+2	; 0x02
    7afe:	29 e7       	ldi	r18, 0x79	; 121
    7b00:	30 e0       	ldi	r19, 0x00	; 0
    7b02:	b9 01       	movw	r22, r18
    7b04:	0e 94 c6 5b 	call	0xb78c	; 0xb78c <__divmodhi4>
    7b08:	28 2f       	mov	r18, r24
    7b0a:	89 81       	ldd	r24, Y+1	; 0x01
    7b0c:	9a 81       	ldd	r25, Y+2	; 0x02
    7b0e:	88 52       	subi	r24, 0x28	; 40
    7b10:	9c 4d       	sbci	r25, 0xDC	; 220
    7b12:	fc 01       	movw	r30, r24
    7b14:	20 83       	st	Z, r18
    7b16:	89 81       	ldd	r24, Y+1	; 0x01
    7b18:	9a 81       	ldd	r25, Y+2	; 0x02
    7b1a:	01 96       	adiw	r24, 0x01	; 1
    7b1c:	89 83       	std	Y+1, r24	; 0x01
    7b1e:	9a 83       	std	Y+2, r25	; 0x02
    7b20:	89 81       	ldd	r24, Y+1	; 0x01
    7b22:	9a 81       	ldd	r25, Y+2	; 0x02
    7b24:	f2 e0       	ldi	r31, 0x02	; 2
    7b26:	80 30       	cpi	r24, 0x00	; 0
    7b28:	9f 07       	cpc	r25, r31
    7b2a:	3c f3       	brlt	.-50     	; 0x7afa <TestCard+0x1a>
//for (int i=0;i<1;i++) {
	//FRAMReadBuffer[0] = i; 
	writeFile("testing",FRAMReadBuffer,512);//}
    7b2c:	81 e1       	ldi	r24, 0x11	; 17
    7b2e:	90 e2       	ldi	r25, 0x20	; 32
    7b30:	28 ed       	ldi	r18, 0xD8	; 216
    7b32:	33 e2       	ldi	r19, 0x23	; 35
    7b34:	b9 01       	movw	r22, r18
    7b36:	20 e0       	ldi	r18, 0x00	; 0
    7b38:	32 e0       	ldi	r19, 0x02	; 2
    7b3a:	40 e0       	ldi	r20, 0x00	; 0
    7b3c:	50 e0       	ldi	r21, 0x00	; 0
    7b3e:	0e 94 9a 45 	call	0x8b34	; 0x8b34 <writeFile>
	nop();
    7b42:	00 00       	nop
}
    7b44:	0f 90       	pop	r0
    7b46:	0f 90       	pop	r0
    7b48:	df 91       	pop	r29
    7b4a:	cf 91       	pop	r28
    7b4c:	08 95       	ret

00007b4e <__vector_43>:

//interrupt service routine for handling received data over radio. Gets called when data received by the mote. Has cases for synching right now.
ISR(PORTE_INT0_vect){
    7b4e:	1f 92       	push	r1
    7b50:	0f 92       	push	r0
    7b52:	0f b6       	in	r0, 0x3f	; 63
    7b54:	0f 92       	push	r0
    7b56:	00 90 3b 00 	lds	r0, 0x003B
    7b5a:	0f 92       	push	r0
    7b5c:	11 24       	eor	r1, r1
    7b5e:	2f 93       	push	r18
    7b60:	3f 93       	push	r19
    7b62:	4f 93       	push	r20
    7b64:	5f 93       	push	r21
    7b66:	6f 93       	push	r22
    7b68:	7f 93       	push	r23
    7b6a:	8f 93       	push	r24
    7b6c:	9f 93       	push	r25
    7b6e:	af 93       	push	r26
    7b70:	bf 93       	push	r27
    7b72:	ef 93       	push	r30
    7b74:	ff 93       	push	r31
    7b76:	cf 93       	push	r28
    7b78:	df 93       	push	r29
    7b7a:	cd b7       	in	r28, 0x3d	; 61
    7b7c:	de b7       	in	r29, 0x3e	; 62
    7b7e:	c4 58       	subi	r28, 0x84	; 132
    7b80:	d0 40       	sbci	r29, 0x00	; 0
    7b82:	cd bf       	out	0x3d, r28	; 61
    7b84:	de bf       	out	0x3e, r29	; 62
	char msg[128];
	switch (RadioMonitorMode) {
    7b86:	80 91 5f 40 	lds	r24, 0x405F
    7b8a:	88 2f       	mov	r24, r24
    7b8c:	90 e0       	ldi	r25, 0x00	; 0
    7b8e:	81 30       	cpi	r24, 0x01	; 1
    7b90:	91 05       	cpc	r25, r1
    7b92:	29 f0       	breq	.+10     	; 0x7b9e <__vector_43+0x50>
    7b94:	82 30       	cpi	r24, 0x02	; 2
    7b96:	91 05       	cpc	r25, r1
    7b98:	09 f4       	brne	.+2      	; 0x7b9c <__vector_43+0x4e>
    7b9a:	73 c0       	rjmp	.+230    	; 0x7c82 <__vector_43+0x134>
    7b9c:	91 c0       	rjmp	.+290    	; 0x7cc0 <__vector_43+0x172>
		//case for reading sensor data - done by basestation
		case DATA_GATHERING:
			//check contents of the message first and if it is a synch message, increment MotesReadyToSynch variable
			chb_read(msg);
    7b9e:	ce 01       	movw	r24, r28
    7ba0:	05 96       	adiw	r24, 0x05	; 5
    7ba2:	0e 94 e2 1f 	call	0x3fc4	; 0x3fc4 <chb_read>
			if(!strncmp(msg,"reset",5)){
    7ba6:	ce 01       	movw	r24, r28
    7ba8:	05 96       	adiw	r24, 0x05	; 5
    7baa:	29 e1       	ldi	r18, 0x19	; 25
    7bac:	30 e2       	ldi	r19, 0x20	; 32
    7bae:	b9 01       	movw	r22, r18
    7bb0:	45 e0       	ldi	r20, 0x05	; 5
    7bb2:	50 e0       	ldi	r21, 0x00	; 0
    7bb4:	0e 94 74 5c 	call	0xb8e8	; 0xb8e8 <strncmp>
    7bb8:	00 97       	sbiw	r24, 0x00	; 0
    7bba:	51 f4       	brne	.+20     	; 0x7bd0 <__vector_43+0x82>
				MotesReadyToSynch++;
    7bbc:	80 91 79 50 	lds	r24, 0x5079
    7bc0:	90 91 7a 50 	lds	r25, 0x507A
    7bc4:	01 96       	adiw	r24, 0x01	; 1
    7bc6:	80 93 79 50 	sts	0x5079, r24
    7bca:	90 93 7a 50 	sts	0x507A, r25
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    7bce:	7a c0       	rjmp	.+244    	; 0x7cc4 <__vector_43+0x176>
			if(!strncmp(msg,"reset",5)){
				MotesReadyToSynch++;
			}
			//otherwise, store the message contents in the FRAM buffer
			else{		
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
    7bd0:	19 82       	std	Y+1, r1	; 0x01
    7bd2:	1a 82       	std	Y+2, r1	; 0x02
    7bd4:	1b 82       	std	Y+3, r1	; 0x03
    7bd6:	1c 82       	std	Y+4, r1	; 0x04
    7bd8:	1a c0       	rjmp	.+52     	; 0x7c0e <__vector_43+0xc0>
    7bda:	9e 01       	movw	r18, r28
    7bdc:	2b 5f       	subi	r18, 0xFB	; 251
    7bde:	3f 4f       	sbci	r19, 0xFF	; 255
    7be0:	89 81       	ldd	r24, Y+1	; 0x01
    7be2:	9a 81       	ldd	r25, Y+2	; 0x02
    7be4:	82 0f       	add	r24, r18
    7be6:	93 1f       	adc	r25, r19
    7be8:	fc 01       	movw	r30, r24
    7bea:	20 81       	ld	r18, Z
    7bec:	89 81       	ldd	r24, Y+1	; 0x01
    7bee:	9a 81       	ldd	r25, Y+2	; 0x02
    7bf0:	88 52       	subi	r24, 0x28	; 40
    7bf2:	9c 4d       	sbci	r25, 0xDC	; 220
    7bf4:	fc 01       	movw	r30, r24
    7bf6:	20 83       	st	Z, r18
    7bf8:	89 81       	ldd	r24, Y+1	; 0x01
    7bfa:	9a 81       	ldd	r25, Y+2	; 0x02
    7bfc:	ab 81       	ldd	r26, Y+3	; 0x03
    7bfe:	bc 81       	ldd	r27, Y+4	; 0x04
    7c00:	01 96       	adiw	r24, 0x01	; 1
    7c02:	a1 1d       	adc	r26, r1
    7c04:	b1 1d       	adc	r27, r1
    7c06:	89 83       	std	Y+1, r24	; 0x01
    7c08:	9a 83       	std	Y+2, r25	; 0x02
    7c0a:	ab 83       	std	Y+3, r26	; 0x03
    7c0c:	bc 83       	std	Y+4, r27	; 0x04
    7c0e:	89 81       	ldd	r24, Y+1	; 0x01
    7c10:	9a 81       	ldd	r25, Y+2	; 0x02
    7c12:	ab 81       	ldd	r26, Y+3	; 0x03
    7c14:	bc 81       	ldd	r27, Y+4	; 0x04
    7c16:	80 38       	cpi	r24, 0x80	; 128
    7c18:	91 05       	cpc	r25, r1
    7c1a:	a1 05       	cpc	r26, r1
    7c1c:	b1 05       	cpc	r27, r1
    7c1e:	e8 f2       	brcs	.-70     	; 0x7bda <__vector_43+0x8c>
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
    7c20:	80 91 cb 50 	lds	r24, 0x50CB
    7c24:	90 91 cc 50 	lds	r25, 0x50CC
    7c28:	a0 91 cd 50 	lds	r26, 0x50CD
    7c2c:	b0 91 ce 50 	lds	r27, 0x50CE
    7c30:	80 58       	subi	r24, 0x80	; 128
    7c32:	9f 4f       	sbci	r25, 0xFF	; 255
    7c34:	af 4f       	sbci	r26, 0xFF	; 255
    7c36:	bf 4f       	sbci	r27, 0xFF	; 255
    7c38:	80 93 cb 50 	sts	0x50CB, r24
    7c3c:	90 93 cc 50 	sts	0x50CC, r25
    7c40:	a0 93 cd 50 	sts	0x50CD, r26
    7c44:	b0 93 ce 50 	sts	0x50CE, r27
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
    7c48:	80 91 cb 50 	lds	r24, 0x50CB
    7c4c:	90 91 cc 50 	lds	r25, 0x50CC
    7c50:	a0 91 cd 50 	lds	r26, 0x50CD
    7c54:	b0 91 ce 50 	lds	r27, 0x50CE
    7c58:	80 58       	subi	r24, 0x80	; 128
    7c5a:	9f 4f       	sbci	r25, 0xFF	; 255
    7c5c:	af 4f       	sbci	r26, 0xFF	; 255
    7c5e:	bf 4f       	sbci	r27, 0xFF	; 255
    7c60:	81 37       	cpi	r24, 0x71	; 113
    7c62:	fc e1       	ldi	r31, 0x1C	; 28
    7c64:	9f 07       	cpc	r25, r31
    7c66:	f0 e0       	ldi	r31, 0x00	; 0
    7c68:	af 07       	cpc	r26, r31
    7c6a:	f0 e0       	ldi	r31, 0x00	; 0
    7c6c:	bf 07       	cpc	r27, r31
    7c6e:	50 f1       	brcs	.+84     	; 0x7cc4 <__vector_43+0x176>
    7c70:	10 92 cb 50 	sts	0x50CB, r1
    7c74:	10 92 cc 50 	sts	0x50CC, r1
    7c78:	10 92 cd 50 	sts	0x50CD, r1
    7c7c:	10 92 ce 50 	sts	0x50CE, r1
			}			
			break;
    7c80:	21 c0       	rjmp	.+66     	; 0x7cc4 <__vector_43+0x176>
		//case for synching sampling with basestation
		case TIME_SYNCH:
			chb_read(msg);
    7c82:	ce 01       	movw	r24, r28
    7c84:	05 96       	adiw	r24, 0x05	; 5
    7c86:	0e 94 e2 1f 	call	0x3fc4	; 0x3fc4 <chb_read>
			if(!strncmp(msg,"start sampling",14)){	//if basestation synch response message received, do the following
    7c8a:	ce 01       	movw	r24, r28
    7c8c:	05 96       	adiw	r24, 0x05	; 5
    7c8e:	2f e1       	ldi	r18, 0x1F	; 31
    7c90:	30 e2       	ldi	r19, 0x20	; 32
    7c92:	b9 01       	movw	r22, r18
    7c94:	4e e0       	ldi	r20, 0x0E	; 14
    7c96:	50 e0       	ldi	r21, 0x00	; 0
    7c98:	0e 94 74 5c 	call	0xb8e8	; 0xb8e8 <strncmp>
    7c9c:	00 97       	sbiw	r24, 0x00	; 0
    7c9e:	a1 f4       	brne	.+40     	; 0x7cc8 <__vector_43+0x17a>
				RadioMonitorMode = SYNCHED;
    7ca0:	83 e0       	ldi	r24, 0x03	; 3
    7ca2:	80 93 5f 40 	sts	0x405F, r24
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
    7ca6:	80 e4       	ldi	r24, 0x40	; 64
    7ca8:	99 e0       	ldi	r25, 0x09	; 9
    7caa:	29 e0       	ldi	r18, 0x09	; 9
    7cac:	fc 01       	movw	r30, r24
    7cae:	20 83       	st	Z, r18
				TCC1.CTRLA = 0x01;  
    7cb0:	80 e4       	ldi	r24, 0x40	; 64
    7cb2:	98 e0       	ldi	r25, 0x08	; 8
    7cb4:	21 e0       	ldi	r18, 0x01	; 1
    7cb6:	fc 01       	movw	r30, r24
    7cb8:	20 83       	st	Z, r18
				ADC_Resume_Sampling();	//resume sampling with the adc
    7cba:	0e 94 45 0a 	call	0x148a	; 0x148a <ADC_Resume_Sampling>
			}
			break;
    7cbe:	04 c0       	rjmp	.+8      	; 0x7cc8 <__vector_43+0x17a>
		default:
			break;
    7cc0:	00 00       	nop
    7cc2:	03 c0       	rjmp	.+6      	; 0x7cca <__vector_43+0x17c>
				for(uint32_t i=0;i<128;i++)	FRAMReadBuffer[i] = msg[i];		//copy the message to the FRAM buffer	
				StartOfFreeSpace += 128;	//increment start of free space in FRAM buffer
			//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).
				if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;
			}			
			break;
    7cc4:	00 00       	nop
    7cc6:	01 c0       	rjmp	.+2      	; 0x7cca <__vector_43+0x17c>
				RadioMonitorMode = SYNCHED;
				TCD1.CTRLA = TC_CLKSEL_EVCH1_gc;	//restart the synch timers
				TCC1.CTRLA = 0x01;  
				ADC_Resume_Sampling();	//resume sampling with the adc
			}
			break;
    7cc8:	00 00       	nop
		default:
			break;
	}
}
    7cca:	cc 57       	subi	r28, 0x7C	; 124
    7ccc:	df 4f       	sbci	r29, 0xFF	; 255
    7cce:	cd bf       	out	0x3d, r28	; 61
    7cd0:	de bf       	out	0x3e, r29	; 62
    7cd2:	df 91       	pop	r29
    7cd4:	cf 91       	pop	r28
    7cd6:	ff 91       	pop	r31
    7cd8:	ef 91       	pop	r30
    7cda:	bf 91       	pop	r27
    7cdc:	af 91       	pop	r26
    7cde:	9f 91       	pop	r25
    7ce0:	8f 91       	pop	r24
    7ce2:	7f 91       	pop	r23
    7ce4:	6f 91       	pop	r22
    7ce6:	5f 91       	pop	r21
    7ce8:	4f 91       	pop	r20
    7cea:	3f 91       	pop	r19
    7cec:	2f 91       	pop	r18
    7cee:	0f 90       	pop	r0
    7cf0:	00 92 3b 00 	sts	0x003B, r0
    7cf4:	0f 90       	pop	r0
    7cf6:	0f be       	out	0x3f, r0	; 63
    7cf8:	0f 90       	pop	r0
    7cfa:	1f 90       	pop	r1
    7cfc:	18 95       	reti

00007cfe <DeciToString>:

void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
    7cfe:	cf 93       	push	r28
    7d00:	df 93       	push	r29
    7d02:	cd b7       	in	r28, 0x3d	; 61
    7d04:	de b7       	in	r29, 0x3e	; 62
    7d06:	a2 97       	sbiw	r28, 0x22	; 34
    7d08:	cd bf       	out	0x3d, r28	; 61
    7d0a:	de bf       	out	0x3e, r29	; 62
    7d0c:	8b 8f       	std	Y+27, r24	; 0x1b
    7d0e:	9c 8f       	std	Y+28, r25	; 0x1c
    7d10:	4d 8f       	std	Y+29, r20	; 0x1d
    7d12:	5e 8f       	std	Y+30, r21	; 0x1e
    7d14:	6f 8f       	std	Y+31, r22	; 0x1f
    7d16:	78 a3       	lds	r23, 0x58
    7d18:	29 a3       	lds	r18, 0x59
    7d1a:	3a a3       	lds	r19, 0x5a
	char b[20];
	int written;
	uint32_t i;
	ReturnString[0] = 0;
    7d1c:	89 a1       	lds	r24, 0x49
    7d1e:	9a a1       	lds	r25, 0x4a
    7d20:	fc 01       	movw	r30, r24
    7d22:	10 82       	st	Z, r1
	for(i=0;i<length;i++){
    7d24:	19 82       	std	Y+1, r1	; 0x01
    7d26:	1a 82       	std	Y+2, r1	; 0x02
    7d28:	1b 82       	std	Y+3, r1	; 0x03
    7d2a:	1c 82       	std	Y+4, r1	; 0x04
    7d2c:	5a c0       	rjmp	.+180    	; 0x7de2 <DeciToString+0xe4>
		written = sprintf(b,"%ld",DecimalArray[i]);
    7d2e:	89 81       	ldd	r24, Y+1	; 0x01
    7d30:	9a 81       	ldd	r25, Y+2	; 0x02
    7d32:	88 0f       	add	r24, r24
    7d34:	99 1f       	adc	r25, r25
    7d36:	88 0f       	add	r24, r24
    7d38:	99 1f       	adc	r25, r25
    7d3a:	2b 8d       	ldd	r18, Y+27	; 0x1b
    7d3c:	3c 8d       	ldd	r19, Y+28	; 0x1c
    7d3e:	82 0f       	add	r24, r18
    7d40:	93 1f       	adc	r25, r19
    7d42:	fc 01       	movw	r30, r24
    7d44:	80 81       	ld	r24, Z
    7d46:	91 81       	ldd	r25, Z+1	; 0x01
    7d48:	a2 81       	ldd	r26, Z+2	; 0x02
    7d4a:	b3 81       	ldd	r27, Z+3	; 0x03
    7d4c:	2d b7       	in	r18, 0x3d	; 61
    7d4e:	3e b7       	in	r19, 0x3e	; 62
    7d50:	28 50       	subi	r18, 0x08	; 8
    7d52:	30 40       	sbci	r19, 0x00	; 0
    7d54:	2d bf       	out	0x3d, r18	; 61
    7d56:	3e bf       	out	0x3e, r19	; 62
    7d58:	2d b7       	in	r18, 0x3d	; 61
    7d5a:	3e b7       	in	r19, 0x3e	; 62
    7d5c:	2f 5f       	subi	r18, 0xFF	; 255
    7d5e:	3f 4f       	sbci	r19, 0xFF	; 255
    7d60:	ae 01       	movw	r20, r28
    7d62:	49 5f       	subi	r20, 0xF9	; 249
    7d64:	5f 4f       	sbci	r21, 0xFF	; 255
    7d66:	f9 01       	movw	r30, r18
    7d68:	40 83       	st	Z, r20
    7d6a:	51 83       	std	Z+1, r21	; 0x01
    7d6c:	4e e2       	ldi	r20, 0x2E	; 46
    7d6e:	50 e2       	ldi	r21, 0x20	; 32
    7d70:	f9 01       	movw	r30, r18
    7d72:	42 83       	std	Z+2, r20	; 0x02
    7d74:	53 83       	std	Z+3, r21	; 0x03
    7d76:	f9 01       	movw	r30, r18
    7d78:	84 83       	std	Z+4, r24	; 0x04
    7d7a:	95 83       	std	Z+5, r25	; 0x05
    7d7c:	a6 83       	std	Z+6, r26	; 0x06
    7d7e:	b7 83       	std	Z+7, r27	; 0x07
    7d80:	0e 94 b5 5c 	call	0xb96a	; 0xb96a <sprintf>
    7d84:	2d b7       	in	r18, 0x3d	; 61
    7d86:	3e b7       	in	r19, 0x3e	; 62
    7d88:	28 5f       	subi	r18, 0xF8	; 248
    7d8a:	3f 4f       	sbci	r19, 0xFF	; 255
    7d8c:	2d bf       	out	0x3d, r18	; 61
    7d8e:	3e bf       	out	0x3e, r19	; 62
    7d90:	8d 83       	std	Y+5, r24	; 0x05
    7d92:	9e 83       	std	Y+6, r25	; 0x06
		strcat(ReturnString,b);
    7d94:	89 a1       	lds	r24, 0x49
    7d96:	9a a1       	lds	r25, 0x4a
    7d98:	9e 01       	movw	r18, r28
    7d9a:	29 5f       	subi	r18, 0xF9	; 249
    7d9c:	3f 4f       	sbci	r19, 0xFF	; 255
    7d9e:	b9 01       	movw	r22, r18
    7da0:	0e 94 69 5c 	call	0xb8d2	; 0xb8d2 <strcat>
		//add a space between each value
		strcat(ReturnString,"\n");
    7da4:	89 a1       	lds	r24, 0x49
    7da6:	9a a1       	lds	r25, 0x4a
    7da8:	9c 01       	movw	r18, r24
    7daa:	f9 01       	movw	r30, r18
    7dac:	01 90       	ld	r0, Z+
    7dae:	00 20       	and	r0, r0
    7db0:	e9 f7       	brne	.-6      	; 0x7dac <DeciToString+0xae>
    7db2:	cf 01       	movw	r24, r30
    7db4:	01 97       	sbiw	r24, 0x01	; 1
    7db6:	82 1b       	sub	r24, r18
    7db8:	93 0b       	sbc	r25, r19
    7dba:	29 a1       	lds	r18, 0x49
    7dbc:	3a a1       	lds	r19, 0x4a
    7dbe:	82 0f       	add	r24, r18
    7dc0:	93 1f       	adc	r25, r19
    7dc2:	2a e0       	ldi	r18, 0x0A	; 10
    7dc4:	30 e0       	ldi	r19, 0x00	; 0
    7dc6:	fc 01       	movw	r30, r24
    7dc8:	20 83       	st	Z, r18
    7dca:	31 83       	std	Z+1, r19	; 0x01
void DeciToString(int32_t* DecimalArray, uint32_t length, char* ReturnString){
	char b[20];
	int written;
	uint32_t i;
	ReturnString[0] = 0;
	for(i=0;i<length;i++){
    7dcc:	89 81       	ldd	r24, Y+1	; 0x01
    7dce:	9a 81       	ldd	r25, Y+2	; 0x02
    7dd0:	ab 81       	ldd	r26, Y+3	; 0x03
    7dd2:	bc 81       	ldd	r27, Y+4	; 0x04
    7dd4:	01 96       	adiw	r24, 0x01	; 1
    7dd6:	a1 1d       	adc	r26, r1
    7dd8:	b1 1d       	adc	r27, r1
    7dda:	89 83       	std	Y+1, r24	; 0x01
    7ddc:	9a 83       	std	Y+2, r25	; 0x02
    7dde:	ab 83       	std	Y+3, r26	; 0x03
    7de0:	bc 83       	std	Y+4, r27	; 0x04
    7de2:	29 81       	ldd	r18, Y+1	; 0x01
    7de4:	3a 81       	ldd	r19, Y+2	; 0x02
    7de6:	4b 81       	ldd	r20, Y+3	; 0x03
    7de8:	5c 81       	ldd	r21, Y+4	; 0x04
    7dea:	8d 8d       	ldd	r24, Y+29	; 0x1d
    7dec:	9e 8d       	ldd	r25, Y+30	; 0x1e
    7dee:	af 8d       	ldd	r26, Y+31	; 0x1f
    7df0:	b8 a1       	lds	r27, 0x48
    7df2:	28 17       	cp	r18, r24
    7df4:	39 07       	cpc	r19, r25
    7df6:	4a 07       	cpc	r20, r26
    7df8:	5b 07       	cpc	r21, r27
    7dfa:	08 f4       	brcc	.+2      	; 0x7dfe <DeciToString+0x100>
    7dfc:	98 cf       	rjmp	.-208    	; 0x7d2e <DeciToString+0x30>
		written = sprintf(b,"%ld",DecimalArray[i]);
		strcat(ReturnString,b);
		//add a space between each value
		strcat(ReturnString,"\n");
	}		
    7dfe:	a2 96       	adiw	r28, 0x22	; 34
    7e00:	cd bf       	out	0x3d, r28	; 61
    7e02:	de bf       	out	0x3e, r29	; 62
    7e04:	df 91       	pop	r29
    7e06:	cf 91       	pop	r28
    7e08:	08 95       	ret

00007e0a <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    7e0a:	ef 92       	push	r14
    7e0c:	ff 92       	push	r15
    7e0e:	0f 93       	push	r16
    7e10:	1f 93       	push	r17
    7e12:	cf 93       	push	r28
    7e14:	df 93       	push	r29
    7e16:	cd b7       	in	r28, 0x3d	; 61
    7e18:	de b7       	in	r29, 0x3e	; 62
    7e1a:	2a 97       	sbiw	r28, 0x0a	; 10
    7e1c:	cd bf       	out	0x3d, r28	; 61
    7e1e:	de bf       	out	0x3e, r29	; 62
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    7e20:	10 92 7e 50 	sts	0x507E, r1
    7e24:	10 92 7f 50 	sts	0x507F, r1
    7e28:	10 92 80 50 	sts	0x5080, r1
    7e2c:	10 92 81 50 	sts	0x5081, r1

SD_read_block(0,SDBuffer);
    7e30:	2f ec       	ldi	r18, 0xCF	; 207
    7e32:	31 e2       	ldi	r19, 0x21	; 33
    7e34:	60 e0       	ldi	r22, 0x00	; 0
    7e36:	70 e0       	ldi	r23, 0x00	; 0
    7e38:	cb 01       	movw	r24, r22
    7e3a:	a9 01       	movw	r20, r18
    7e3c:	0e 94 7a 4e 	call	0x9cf4	; 0x9cf4 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;
    7e40:	8f ec       	ldi	r24, 0xCF	; 207
    7e42:	91 e2       	ldi	r25, 0x21	; 33
    7e44:	89 83       	std	Y+1, r24	; 0x01
    7e46:	9a 83       	std	Y+2, r25	; 0x02

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    7e48:	89 81       	ldd	r24, Y+1	; 0x01
    7e4a:	9a 81       	ldd	r25, Y+2	; 0x02
    7e4c:	fc 01       	movw	r30, r24
    7e4e:	80 81       	ld	r24, Z
    7e50:	89 3e       	cpi	r24, 0xE9	; 233
    7e52:	09 f4       	brne	.+2      	; 0x7e56 <getBootSectorData+0x4c>
    7e54:	4d c0       	rjmp	.+154    	; 0x7ef0 <getBootSectorData+0xe6>
    7e56:	89 81       	ldd	r24, Y+1	; 0x01
    7e58:	9a 81       	ldd	r25, Y+2	; 0x02
    7e5a:	fc 01       	movw	r30, r24
    7e5c:	80 81       	ld	r24, Z
    7e5e:	8b 3e       	cpi	r24, 0xEB	; 235
    7e60:	09 f4       	brne	.+2      	; 0x7e64 <getBootSectorData+0x5a>
    7e62:	46 c0       	rjmp	.+140    	; 0x7ef0 <getBootSectorData+0xe6>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
    7e64:	8f ec       	ldi	r24, 0xCF	; 207
    7e66:	91 e2       	ldi	r25, 0x21	; 33
    7e68:	8b 83       	std	Y+3, r24	; 0x03
    7e6a:	9c 83       	std	Y+4, r25	; 0x04
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    7e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    7e6e:	9c 81       	ldd	r25, Y+4	; 0x04
    7e70:	82 50       	subi	r24, 0x02	; 2
    7e72:	9e 4f       	sbci	r25, 0xFE	; 254
    7e74:	fc 01       	movw	r30, r24
    7e76:	80 81       	ld	r24, Z
    7e78:	91 81       	ldd	r25, Z+1	; 0x01
    7e7a:	fa ea       	ldi	r31, 0xAA	; 170
    7e7c:	85 35       	cpi	r24, 0x55	; 85
    7e7e:	9f 07       	cpc	r25, r31
    7e80:	11 f0       	breq	.+4      	; 0x7e86 <getBootSectorData+0x7c>
    7e82:	81 e0       	ldi	r24, 0x01	; 1
    7e84:	01 c1       	rjmp	.+514    	; 0x8088 <getBootSectorData+0x27e>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
    7e86:	8b 81       	ldd	r24, Y+3	; 0x03
    7e88:	9c 81       	ldd	r25, Y+4	; 0x04
    7e8a:	82 54       	subi	r24, 0x42	; 66
    7e8c:	9e 4f       	sbci	r25, 0xFE	; 254
    7e8e:	8d 83       	std	Y+5, r24	; 0x05
    7e90:	9e 83       	std	Y+6, r25	; 0x06
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    7e92:	8d 81       	ldd	r24, Y+5	; 0x05
    7e94:	9e 81       	ldd	r25, Y+6	; 0x06
    7e96:	fc 01       	movw	r30, r24
    7e98:	80 85       	ldd	r24, Z+8	; 0x08
    7e9a:	91 85       	ldd	r25, Z+9	; 0x09
    7e9c:	a2 85       	ldd	r26, Z+10	; 0x0a
    7e9e:	b3 85       	ldd	r27, Z+11	; 0x0b
    7ea0:	80 93 7e 50 	sts	0x507E, r24
    7ea4:	90 93 7f 50 	sts	0x507F, r25
    7ea8:	a0 93 80 50 	sts	0x5080, r26
    7eac:	b0 93 81 50 	sts	0x5081, r27
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    7eb0:	8d 81       	ldd	r24, Y+5	; 0x05
    7eb2:	9e 81       	ldd	r25, Y+6	; 0x06
    7eb4:	fc 01       	movw	r30, r24
    7eb6:	80 85       	ldd	r24, Z+8	; 0x08
    7eb8:	91 85       	ldd	r25, Z+9	; 0x09
    7eba:	a2 85       	ldd	r26, Z+10	; 0x0a
    7ebc:	b3 85       	ldd	r27, Z+11	; 0x0b
    7ebe:	2f ec       	ldi	r18, 0xCF	; 207
    7ec0:	31 e2       	ldi	r19, 0x21	; 33
    7ec2:	bc 01       	movw	r22, r24
    7ec4:	cd 01       	movw	r24, r26
    7ec6:	a9 01       	movw	r20, r18
    7ec8:	0e 94 7a 4e 	call	0x9cf4	; 0x9cf4 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
    7ecc:	8f ec       	ldi	r24, 0xCF	; 207
    7ece:	91 e2       	ldi	r25, 0x21	; 33
    7ed0:	89 83       	std	Y+1, r24	; 0x01
    7ed2:	9a 83       	std	Y+2, r25	; 0x02
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    7ed4:	89 81       	ldd	r24, Y+1	; 0x01
    7ed6:	9a 81       	ldd	r25, Y+2	; 0x02
    7ed8:	fc 01       	movw	r30, r24
    7eda:	80 81       	ld	r24, Z
    7edc:	89 3e       	cpi	r24, 0xE9	; 233
    7ede:	41 f0       	breq	.+16     	; 0x7ef0 <getBootSectorData+0xe6>
    7ee0:	89 81       	ldd	r24, Y+1	; 0x01
    7ee2:	9a 81       	ldd	r25, Y+2	; 0x02
    7ee4:	fc 01       	movw	r30, r24
    7ee6:	80 81       	ld	r24, Z
    7ee8:	8b 3e       	cpi	r24, 0xEB	; 235
    7eea:	11 f0       	breq	.+4      	; 0x7ef0 <getBootSectorData+0xe6>
    7eec:	81 e0       	ldi	r24, 0x01	; 1
    7eee:	cc c0       	rjmp	.+408    	; 0x8088 <getBootSectorData+0x27e>
}

bytesPerSector = bpb->bytesPerSector;
    7ef0:	89 81       	ldd	r24, Y+1	; 0x01
    7ef2:	9a 81       	ldd	r25, Y+2	; 0x02
    7ef4:	fc 01       	movw	r30, r24
    7ef6:	83 85       	ldd	r24, Z+11	; 0x0b
    7ef8:	94 85       	ldd	r25, Z+12	; 0x0c
    7efa:	80 93 4d 40 	sts	0x404D, r24
    7efe:	90 93 4e 40 	sts	0x404E, r25
sectorPerCluster = bpb->sectorPerCluster;
    7f02:	89 81       	ldd	r24, Y+1	; 0x01
    7f04:	9a 81       	ldd	r25, Y+2	; 0x02
    7f06:	fc 01       	movw	r30, r24
    7f08:	85 85       	ldd	r24, Z+13	; 0x0d
    7f0a:	88 2f       	mov	r24, r24
    7f0c:	90 e0       	ldi	r25, 0x00	; 0
    7f0e:	80 93 7c 50 	sts	0x507C, r24
    7f12:	90 93 7d 50 	sts	0x507D, r25
reservedSectorCount = bpb->reservedSectorCount;
    7f16:	89 81       	ldd	r24, Y+1	; 0x01
    7f18:	9a 81       	ldd	r25, Y+2	; 0x02
    7f1a:	fc 01       	movw	r30, r24
    7f1c:	86 85       	ldd	r24, Z+14	; 0x0e
    7f1e:	97 85       	ldd	r25, Z+15	; 0x0f
    7f20:	80 93 84 50 	sts	0x5084, r24
    7f24:	90 93 85 50 	sts	0x5085, r25
rootCluster = bpb->rootCluster;
    7f28:	89 81       	ldd	r24, Y+1	; 0x01
    7f2a:	9a 81       	ldd	r25, Y+2	; 0x02
    7f2c:	fc 01       	movw	r30, r24
    7f2e:	84 a5       	lds	r24, 0x64
    7f30:	95 a5       	lds	r25, 0x65
    7f32:	a6 a5       	lds	r26, 0x66
    7f34:	b7 a5       	lds	r27, 0x67
    7f36:	80 93 60 40 	sts	0x4060, r24
    7f3a:	90 93 61 40 	sts	0x4061, r25
    7f3e:	a0 93 62 40 	sts	0x4062, r26
    7f42:	b0 93 63 40 	sts	0x4063, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    7f46:	89 81       	ldd	r24, Y+1	; 0x01
    7f48:	9a 81       	ldd	r25, Y+2	; 0x02
    7f4a:	fc 01       	movw	r30, r24
    7f4c:	24 8d       	ldd	r18, Z+28	; 0x1c
    7f4e:	35 8d       	ldd	r19, Z+29	; 0x1d
    7f50:	46 8d       	ldd	r20, Z+30	; 0x1e
    7f52:	57 8d       	ldd	r21, Z+31	; 0x1f
    7f54:	80 91 84 50 	lds	r24, 0x5084
    7f58:	90 91 85 50 	lds	r25, 0x5085
    7f5c:	cc 01       	movw	r24, r24
    7f5e:	a0 e0       	ldi	r26, 0x00	; 0
    7f60:	b0 e0       	ldi	r27, 0x00	; 0
    7f62:	79 01       	movw	r14, r18
    7f64:	8a 01       	movw	r16, r20
    7f66:	e8 0e       	add	r14, r24
    7f68:	f9 1e       	adc	r15, r25
    7f6a:	0a 1f       	adc	r16, r26
    7f6c:	1b 1f       	adc	r17, r27
    7f6e:	89 81       	ldd	r24, Y+1	; 0x01
    7f70:	9a 81       	ldd	r25, Y+2	; 0x02
    7f72:	fc 01       	movw	r30, r24
    7f74:	80 89       	ldd	r24, Z+16	; 0x10
    7f76:	88 2f       	mov	r24, r24
    7f78:	90 e0       	ldi	r25, 0x00	; 0
    7f7a:	a0 e0       	ldi	r26, 0x00	; 0
    7f7c:	b0 e0       	ldi	r27, 0x00	; 0
    7f7e:	29 81       	ldd	r18, Y+1	; 0x01
    7f80:	3a 81       	ldd	r19, Y+2	; 0x02
    7f82:	f9 01       	movw	r30, r18
    7f84:	24 a1       	lds	r18, 0x44
    7f86:	35 a1       	lds	r19, 0x45
    7f88:	46 a1       	lds	r20, 0x46
    7f8a:	57 a1       	lds	r21, 0x47
    7f8c:	bc 01       	movw	r22, r24
    7f8e:	cd 01       	movw	r24, r26
    7f90:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    7f94:	dc 01       	movw	r26, r24
    7f96:	cb 01       	movw	r24, r22
    7f98:	8e 0d       	add	r24, r14
    7f9a:	9f 1d       	adc	r25, r15
    7f9c:	a0 1f       	adc	r26, r16
    7f9e:	b1 1f       	adc	r27, r17
    7fa0:	80 93 d4 23 	sts	0x23D4, r24
    7fa4:	90 93 d5 23 	sts	0x23D5, r25
    7fa8:	a0 93 d6 23 	sts	0x23D6, r26
    7fac:	b0 93 d7 23 	sts	0x23D7, r27

dataSectors = bpb->totalSectors_F32
    7fb0:	89 81       	ldd	r24, Y+1	; 0x01
    7fb2:	9a 81       	ldd	r25, Y+2	; 0x02
    7fb4:	fc 01       	movw	r30, r24
    7fb6:	20 a1       	lds	r18, 0x40
    7fb8:	31 a1       	lds	r19, 0x41
    7fba:	42 a1       	lds	r20, 0x42
    7fbc:	53 a1       	lds	r21, 0x43
              - bpb->reservedSectorCount
    7fbe:	89 81       	ldd	r24, Y+1	; 0x01
    7fc0:	9a 81       	ldd	r25, Y+2	; 0x02
    7fc2:	fc 01       	movw	r30, r24
    7fc4:	86 85       	ldd	r24, Z+14	; 0x0e
    7fc6:	97 85       	ldd	r25, Z+15	; 0x0f
    7fc8:	cc 01       	movw	r24, r24
    7fca:	a0 e0       	ldi	r26, 0x00	; 0
    7fcc:	b0 e0       	ldi	r27, 0x00	; 0
    7fce:	79 01       	movw	r14, r18
    7fd0:	8a 01       	movw	r16, r20
    7fd2:	e8 1a       	sub	r14, r24
    7fd4:	f9 0a       	sbc	r15, r25
    7fd6:	0a 0b       	sbc	r16, r26
    7fd8:	1b 0b       	sbc	r17, r27
              - ( bpb->numberofFATs * bpb->FATsize_F32);
    7fda:	89 81       	ldd	r24, Y+1	; 0x01
    7fdc:	9a 81       	ldd	r25, Y+2	; 0x02
    7fde:	fc 01       	movw	r30, r24
    7fe0:	80 89       	ldd	r24, Z+16	; 0x10
    7fe2:	88 2f       	mov	r24, r24
    7fe4:	90 e0       	ldi	r25, 0x00	; 0
    7fe6:	a0 e0       	ldi	r26, 0x00	; 0
    7fe8:	b0 e0       	ldi	r27, 0x00	; 0
    7fea:	29 81       	ldd	r18, Y+1	; 0x01
    7fec:	3a 81       	ldd	r19, Y+2	; 0x02
    7fee:	f9 01       	movw	r30, r18
    7ff0:	24 a1       	lds	r18, 0x44
    7ff2:	35 a1       	lds	r19, 0x45
    7ff4:	46 a1       	lds	r20, 0x46
    7ff6:	57 a1       	lds	r21, 0x47
    7ff8:	bc 01       	movw	r22, r24
    7ffa:	cd 01       	movw	r24, r26
    7ffc:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    8000:	dc 01       	movw	r26, r24
    8002:	cb 01       	movw	r24, r22
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    8004:	a8 01       	movw	r20, r16
    8006:	97 01       	movw	r18, r14
    8008:	28 1b       	sub	r18, r24
    800a:	39 0b       	sbc	r19, r25
    800c:	4a 0b       	sbc	r20, r26
    800e:	5b 0b       	sbc	r21, r27
    8010:	da 01       	movw	r26, r20
    8012:	c9 01       	movw	r24, r18
    8014:	8f 83       	std	Y+7, r24	; 0x07
    8016:	98 87       	std	Y+8, r25	; 0x08
    8018:	a9 87       	std	Y+9, r26	; 0x09
    801a:	ba 87       	std	Y+10, r27	; 0x0a
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    801c:	80 91 7c 50 	lds	r24, 0x507C
    8020:	90 91 7d 50 	lds	r25, 0x507D
    8024:	9c 01       	movw	r18, r24
    8026:	40 e0       	ldi	r20, 0x00	; 0
    8028:	50 e0       	ldi	r21, 0x00	; 0
    802a:	8f 81       	ldd	r24, Y+7	; 0x07
    802c:	98 85       	ldd	r25, Y+8	; 0x08
    802e:	a9 85       	ldd	r26, Y+9	; 0x09
    8030:	ba 85       	ldd	r27, Y+10	; 0x0a
    8032:	bc 01       	movw	r22, r24
    8034:	cd 01       	movw	r24, r26
    8036:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    803a:	da 01       	movw	r26, r20
    803c:	c9 01       	movw	r24, r18
    803e:	80 93 5a 40 	sts	0x405A, r24
    8042:	90 93 5b 40 	sts	0x405B, r25
    8046:	a0 93 5c 40 	sts	0x405C, r26
    804a:	b0 93 5d 40 	sts	0x405D, r27


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    804e:	81 e0       	ldi	r24, 0x01	; 1
    8050:	60 e0       	ldi	r22, 0x00	; 0
    8052:	20 e0       	ldi	r18, 0x00	; 0
    8054:	30 e0       	ldi	r19, 0x00	; 0
    8056:	a9 01       	movw	r20, r18
    8058:	0e 94 2a 41 	call	0x8254	; 0x8254 <getSetFreeCluster>
    805c:	9b 01       	movw	r18, r22
    805e:	ac 01       	movw	r20, r24
    8060:	80 91 5a 40 	lds	r24, 0x405A
    8064:	90 91 5b 40 	lds	r25, 0x405B
    8068:	a0 91 5c 40 	lds	r26, 0x405C
    806c:	b0 91 5d 40 	lds	r27, 0x405D
    8070:	82 17       	cp	r24, r18
    8072:	93 07       	cpc	r25, r19
    8074:	a4 07       	cpc	r26, r20
    8076:	b5 07       	cpc	r27, r21
    8078:	18 f4       	brcc	.+6      	; 0x8080 <getBootSectorData+0x276>
     freeClusterCountUpdated = 0;
    807a:	10 92 d0 50 	sts	0x50D0, r1
    807e:	03 c0       	rjmp	.+6      	; 0x8086 <getBootSectorData+0x27c>
else
	 freeClusterCountUpdated = 1;
    8080:	81 e0       	ldi	r24, 0x01	; 1
    8082:	80 93 d0 50 	sts	0x50D0, r24
return 0;
    8086:	80 e0       	ldi	r24, 0x00	; 0
}
    8088:	2a 96       	adiw	r28, 0x0a	; 10
    808a:	cd bf       	out	0x3d, r28	; 61
    808c:	de bf       	out	0x3e, r29	; 62
    808e:	df 91       	pop	r29
    8090:	cf 91       	pop	r28
    8092:	1f 91       	pop	r17
    8094:	0f 91       	pop	r16
    8096:	ff 90       	pop	r15
    8098:	ef 90       	pop	r14
    809a:	08 95       	ret

0000809c <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    809c:	cf 93       	push	r28
    809e:	df 93       	push	r29
    80a0:	00 d0       	rcall	.+0      	; 0x80a2 <getFirstSector+0x6>
    80a2:	0f 92       	push	r0
    80a4:	cd b7       	in	r28, 0x3d	; 61
    80a6:	de b7       	in	r29, 0x3e	; 62
    80a8:	69 83       	std	Y+1, r22	; 0x01
    80aa:	7a 83       	std	Y+2, r23	; 0x02
    80ac:	8b 83       	std	Y+3, r24	; 0x03
    80ae:	9c 83       	std	Y+4, r25	; 0x04
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    80b0:	89 81       	ldd	r24, Y+1	; 0x01
    80b2:	9a 81       	ldd	r25, Y+2	; 0x02
    80b4:	ab 81       	ldd	r26, Y+3	; 0x03
    80b6:	bc 81       	ldd	r27, Y+4	; 0x04
    80b8:	02 97       	sbiw	r24, 0x02	; 2
    80ba:	a1 09       	sbc	r26, r1
    80bc:	b1 09       	sbc	r27, r1
    80be:	20 91 7c 50 	lds	r18, 0x507C
    80c2:	30 91 7d 50 	lds	r19, 0x507D
    80c6:	99 01       	movw	r18, r18
    80c8:	40 e0       	ldi	r20, 0x00	; 0
    80ca:	50 e0       	ldi	r21, 0x00	; 0
    80cc:	bc 01       	movw	r22, r24
    80ce:	cd 01       	movw	r24, r26
    80d0:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    80d4:	9b 01       	movw	r18, r22
    80d6:	ac 01       	movw	r20, r24
    80d8:	80 91 d4 23 	lds	r24, 0x23D4
    80dc:	90 91 d5 23 	lds	r25, 0x23D5
    80e0:	a0 91 d6 23 	lds	r26, 0x23D6
    80e4:	b0 91 d7 23 	lds	r27, 0x23D7
    80e8:	82 0f       	add	r24, r18
    80ea:	93 1f       	adc	r25, r19
    80ec:	a4 1f       	adc	r26, r20
    80ee:	b5 1f       	adc	r27, r21
}
    80f0:	bc 01       	movw	r22, r24
    80f2:	cd 01       	movw	r24, r26
    80f4:	24 96       	adiw	r28, 0x04	; 4
    80f6:	cd bf       	out	0x3d, r28	; 61
    80f8:	de bf       	out	0x3e, r29	; 62
    80fa:	df 91       	pop	r29
    80fc:	cf 91       	pop	r28
    80fe:	08 95       	ret

00008100 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    8100:	ef 92       	push	r14
    8102:	ff 92       	push	r15
    8104:	0f 93       	push	r16
    8106:	1f 93       	push	r17
    8108:	cf 93       	push	r28
    810a:	df 93       	push	r29
    810c:	cd b7       	in	r28, 0x3d	; 61
    810e:	de b7       	in	r29, 0x3e	; 62
    8110:	62 97       	sbiw	r28, 0x12	; 18
    8112:	cd bf       	out	0x3d, r28	; 61
    8114:	de bf       	out	0x3e, r29	; 62
    8116:	6a 87       	std	Y+10, r22	; 0x0a
    8118:	7b 87       	std	Y+11, r23	; 0x0b
    811a:	8c 87       	std	Y+12, r24	; 0x0c
    811c:	9d 87       	std	Y+13, r25	; 0x0d
    811e:	4e 87       	std	Y+14, r20	; 0x0e
    8120:	0f 87       	std	Y+15, r16	; 0x0f
    8122:	18 8b       	std	Y+16, r17	; 0x10
    8124:	29 8b       	std	Y+17, r18	; 0x11
    8126:	3a 8b       	std	Y+18, r19	; 0x12
unsigned int FATEntryOffset;
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
unsigned char retry = 0;
    8128:	19 82       	std	Y+1, r1	; 0x01

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    812a:	80 91 84 50 	lds	r24, 0x5084
    812e:	90 91 85 50 	lds	r25, 0x5085
    8132:	9c 01       	movw	r18, r24
    8134:	40 e0       	ldi	r20, 0x00	; 0
    8136:	50 e0       	ldi	r21, 0x00	; 0
    8138:	80 91 7e 50 	lds	r24, 0x507E
    813c:	90 91 7f 50 	lds	r25, 0x507F
    8140:	a0 91 80 50 	lds	r26, 0x5080
    8144:	b0 91 81 50 	lds	r27, 0x5081
    8148:	79 01       	movw	r14, r18
    814a:	8a 01       	movw	r16, r20
    814c:	e8 0e       	add	r14, r24
    814e:	f9 1e       	adc	r15, r25
    8150:	0a 1f       	adc	r16, r26
    8152:	1b 1f       	adc	r17, r27
    8154:	8a 85       	ldd	r24, Y+10	; 0x0a
    8156:	9b 85       	ldd	r25, Y+11	; 0x0b
    8158:	ac 85       	ldd	r26, Y+12	; 0x0c
    815a:	bd 85       	ldd	r27, Y+13	; 0x0d
    815c:	88 0f       	add	r24, r24
    815e:	99 1f       	adc	r25, r25
    8160:	aa 1f       	adc	r26, r26
    8162:	bb 1f       	adc	r27, r27
    8164:	88 0f       	add	r24, r24
    8166:	99 1f       	adc	r25, r25
    8168:	aa 1f       	adc	r26, r26
    816a:	bb 1f       	adc	r27, r27
    816c:	20 91 4d 40 	lds	r18, 0x404D
    8170:	30 91 4e 40 	lds	r19, 0x404E
    8174:	99 01       	movw	r18, r18
    8176:	40 e0       	ldi	r20, 0x00	; 0
    8178:	50 e0       	ldi	r21, 0x00	; 0
    817a:	bc 01       	movw	r22, r24
    817c:	cd 01       	movw	r24, r26
    817e:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    8182:	da 01       	movw	r26, r20
    8184:	c9 01       	movw	r24, r18
    8186:	8e 0d       	add	r24, r14
    8188:	9f 1d       	adc	r25, r15
    818a:	a0 1f       	adc	r26, r16
    818c:	b1 1f       	adc	r27, r17
    818e:	8a 83       	std	Y+2, r24	; 0x02
    8190:	9b 83       	std	Y+3, r25	; 0x03
    8192:	ac 83       	std	Y+4, r26	; 0x04
    8194:	bd 83       	std	Y+5, r27	; 0x05

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    8196:	8a 85       	ldd	r24, Y+10	; 0x0a
    8198:	9b 85       	ldd	r25, Y+11	; 0x0b
    819a:	ac 85       	ldd	r26, Y+12	; 0x0c
    819c:	bd 85       	ldd	r27, Y+13	; 0x0d
    819e:	88 0f       	add	r24, r24
    81a0:	99 1f       	adc	r25, r25
    81a2:	aa 1f       	adc	r26, r26
    81a4:	bb 1f       	adc	r27, r27
    81a6:	88 0f       	add	r24, r24
    81a8:	99 1f       	adc	r25, r25
    81aa:	aa 1f       	adc	r26, r26
    81ac:	bb 1f       	adc	r27, r27
    81ae:	20 91 4d 40 	lds	r18, 0x404D
    81b2:	30 91 4e 40 	lds	r19, 0x404E
    81b6:	99 01       	movw	r18, r18
    81b8:	40 e0       	ldi	r20, 0x00	; 0
    81ba:	50 e0       	ldi	r21, 0x00	; 0
    81bc:	bc 01       	movw	r22, r24
    81be:	cd 01       	movw	r24, r26
    81c0:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    81c4:	dc 01       	movw	r26, r24
    81c6:	cb 01       	movw	r24, r22
    81c8:	8e 83       	std	Y+6, r24	; 0x06
    81ca:	9f 83       	std	Y+7, r25	; 0x07

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    81cc:	8a 81       	ldd	r24, Y+2	; 0x02
    81ce:	9b 81       	ldd	r25, Y+3	; 0x03
    81d0:	ac 81       	ldd	r26, Y+4	; 0x04
    81d2:	bd 81       	ldd	r27, Y+5	; 0x05
    81d4:	2f ec       	ldi	r18, 0xCF	; 207
    81d6:	31 e2       	ldi	r19, 0x21	; 33
    81d8:	bc 01       	movw	r22, r24
    81da:	cd 01       	movw	r24, r26
    81dc:	a9 01       	movw	r20, r18
    81de:	0e 94 7a 4e 	call	0x9cf4	; 0x9cf4 <SD_read_block>

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    81e2:	8e 81       	ldd	r24, Y+6	; 0x06
    81e4:	9f 81       	ldd	r25, Y+7	; 0x07
    81e6:	81 53       	subi	r24, 0x31	; 49
    81e8:	9e 4d       	sbci	r25, 0xDE	; 222
    81ea:	88 87       	std	Y+8, r24	; 0x08
    81ec:	99 87       	std	Y+9, r25	; 0x09

if(get_set == GET)
    81ee:	8e 85       	ldd	r24, Y+14	; 0x0e
    81f0:	88 23       	and	r24, r24
    81f2:	49 f4       	brne	.+18     	; 0x8206 <getSetNextCluster+0x106>
  return ((*FATEntryValue) & 0x0fffffff);
    81f4:	88 85       	ldd	r24, Y+8	; 0x08
    81f6:	99 85       	ldd	r25, Y+9	; 0x09
    81f8:	fc 01       	movw	r30, r24
    81fa:	80 81       	ld	r24, Z
    81fc:	91 81       	ldd	r25, Z+1	; 0x01
    81fe:	a2 81       	ldd	r26, Z+2	; 0x02
    8200:	b3 81       	ldd	r27, Z+3	; 0x03
    8202:	bf 70       	andi	r27, 0x0F	; 15
    8204:	1b c0       	rjmp	.+54     	; 0x823c <getSetNextCluster+0x13c>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    8206:	28 85       	ldd	r18, Y+8	; 0x08
    8208:	39 85       	ldd	r19, Y+9	; 0x09
    820a:	8f 85       	ldd	r24, Y+15	; 0x0f
    820c:	98 89       	ldd	r25, Y+16	; 0x10
    820e:	a9 89       	ldd	r26, Y+17	; 0x11
    8210:	ba 89       	ldd	r27, Y+18	; 0x12
    8212:	f9 01       	movw	r30, r18
    8214:	80 83       	st	Z, r24
    8216:	91 83       	std	Z+1, r25	; 0x01
    8218:	a2 83       	std	Z+2, r26	; 0x02
    821a:	b3 83       	std	Z+3, r27	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    821c:	8a 81       	ldd	r24, Y+2	; 0x02
    821e:	9b 81       	ldd	r25, Y+3	; 0x03
    8220:	ac 81       	ldd	r26, Y+4	; 0x04
    8222:	bd 81       	ldd	r27, Y+5	; 0x05
    8224:	2f ec       	ldi	r18, 0xCF	; 207
    8226:	31 e2       	ldi	r19, 0x21	; 33
    8228:	bc 01       	movw	r22, r24
    822a:	cd 01       	movw	r24, r26
    822c:	a9 01       	movw	r20, r18
    822e:	20 e0       	ldi	r18, 0x00	; 0
    8230:	32 e0       	ldi	r19, 0x02	; 2
    8232:	0e 94 ac 4d 	call	0x9b58	; 0x9b58 <SD_write_block>

return (0);
    8236:	80 e0       	ldi	r24, 0x00	; 0
    8238:	90 e0       	ldi	r25, 0x00	; 0
    823a:	dc 01       	movw	r26, r24
}
    823c:	bc 01       	movw	r22, r24
    823e:	cd 01       	movw	r24, r26
    8240:	62 96       	adiw	r28, 0x12	; 18
    8242:	cd bf       	out	0x3d, r28	; 61
    8244:	de bf       	out	0x3e, r29	; 62
    8246:	df 91       	pop	r29
    8248:	cf 91       	pop	r28
    824a:	1f 91       	pop	r17
    824c:	0f 91       	pop	r16
    824e:	ff 90       	pop	r15
    8250:	ef 90       	pop	r14
    8252:	08 95       	ret

00008254 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    8254:	cf 93       	push	r28
    8256:	df 93       	push	r29
    8258:	cd b7       	in	r28, 0x3d	; 61
    825a:	de b7       	in	r29, 0x3e	; 62
    825c:	28 97       	sbiw	r28, 0x08	; 8
    825e:	cd bf       	out	0x3d, r28	; 61
    8260:	de bf       	out	0x3e, r29	; 62
    8262:	8b 83       	std	Y+3, r24	; 0x03
    8264:	6c 83       	std	Y+4, r22	; 0x04
    8266:	2d 83       	std	Y+5, r18	; 0x05
    8268:	3e 83       	std	Y+6, r19	; 0x06
    826a:	4f 83       	std	Y+7, r20	; 0x07
    826c:	58 87       	std	Y+8, r21	; 0x08
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;
    826e:	8f ec       	ldi	r24, 0xCF	; 207
    8270:	91 e2       	ldi	r25, 0x21	; 33
    8272:	89 83       	std	Y+1, r24	; 0x01
    8274:	9a 83       	std	Y+2, r25	; 0x02

SD_read_block(unusedSectors + 1,SDBuffer);
    8276:	80 91 7e 50 	lds	r24, 0x507E
    827a:	90 91 7f 50 	lds	r25, 0x507F
    827e:	a0 91 80 50 	lds	r26, 0x5080
    8282:	b0 91 81 50 	lds	r27, 0x5081
    8286:	01 96       	adiw	r24, 0x01	; 1
    8288:	a1 1d       	adc	r26, r1
    828a:	b1 1d       	adc	r27, r1
    828c:	2f ec       	ldi	r18, 0xCF	; 207
    828e:	31 e2       	ldi	r19, 0x21	; 33
    8290:	bc 01       	movw	r22, r24
    8292:	cd 01       	movw	r24, r26
    8294:	a9 01       	movw	r20, r18
    8296:	0e 94 7a 4e 	call	0x9cf4	; 0x9cf4 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    829a:	89 81       	ldd	r24, Y+1	; 0x01
    829c:	9a 81       	ldd	r25, Y+2	; 0x02
    829e:	fc 01       	movw	r30, r24
    82a0:	80 81       	ld	r24, Z
    82a2:	91 81       	ldd	r25, Z+1	; 0x01
    82a4:	a2 81       	ldd	r26, Z+2	; 0x02
    82a6:	b3 81       	ldd	r27, Z+3	; 0x03
    82a8:	82 35       	cpi	r24, 0x52	; 82
    82aa:	f2 e5       	ldi	r31, 0x52	; 82
    82ac:	9f 07       	cpc	r25, r31
    82ae:	f1 e6       	ldi	r31, 0x61	; 97
    82b0:	af 07       	cpc	r26, r31
    82b2:	f1 e4       	ldi	r31, 0x41	; 65
    82b4:	bf 07       	cpc	r27, r31
    82b6:	11 f5       	brne	.+68     	; 0x82fc <getSetFreeCluster+0xa8>
    82b8:	89 81       	ldd	r24, Y+1	; 0x01
    82ba:	9a 81       	ldd	r25, Y+2	; 0x02
    82bc:	8c 51       	subi	r24, 0x1C	; 28
    82be:	9e 4f       	sbci	r25, 0xFE	; 254
    82c0:	fc 01       	movw	r30, r24
    82c2:	80 81       	ld	r24, Z
    82c4:	91 81       	ldd	r25, Z+1	; 0x01
    82c6:	a2 81       	ldd	r26, Z+2	; 0x02
    82c8:	b3 81       	ldd	r27, Z+3	; 0x03
    82ca:	82 37       	cpi	r24, 0x72	; 114
    82cc:	f2 e7       	ldi	r31, 0x72	; 114
    82ce:	9f 07       	cpc	r25, r31
    82d0:	f1 e4       	ldi	r31, 0x41	; 65
    82d2:	af 07       	cpc	r26, r31
    82d4:	f1 e6       	ldi	r31, 0x61	; 97
    82d6:	bf 07       	cpc	r27, r31
    82d8:	89 f4       	brne	.+34     	; 0x82fc <getSetFreeCluster+0xa8>
    82da:	89 81       	ldd	r24, Y+1	; 0x01
    82dc:	9a 81       	ldd	r25, Y+2	; 0x02
    82de:	84 50       	subi	r24, 0x04	; 4
    82e0:	9e 4f       	sbci	r25, 0xFE	; 254
    82e2:	fc 01       	movw	r30, r24
    82e4:	80 81       	ld	r24, Z
    82e6:	91 81       	ldd	r25, Z+1	; 0x01
    82e8:	a2 81       	ldd	r26, Z+2	; 0x02
    82ea:	b3 81       	ldd	r27, Z+3	; 0x03
    82ec:	80 30       	cpi	r24, 0x00	; 0
    82ee:	f0 e0       	ldi	r31, 0x00	; 0
    82f0:	9f 07       	cpc	r25, r31
    82f2:	f5 e5       	ldi	r31, 0x55	; 85
    82f4:	af 07       	cpc	r26, r31
    82f6:	fa ea       	ldi	r31, 0xAA	; 170
    82f8:	bf 07       	cpc	r27, r31
    82fa:	21 f0       	breq	.+8      	; 0x8304 <getSetFreeCluster+0xb0>
  return 0xffffffff;
    82fc:	8f ef       	ldi	r24, 0xFF	; 255
    82fe:	9f ef       	ldi	r25, 0xFF	; 255
    8300:	dc 01       	movw	r26, r24
    8302:	51 c0       	rjmp	.+162    	; 0x83a6 <getSetFreeCluster+0x152>

 if(get_set == GET)
    8304:	8c 81       	ldd	r24, Y+4	; 0x04
    8306:	88 23       	and	r24, r24
    8308:	b9 f4       	brne	.+46     	; 0x8338 <getSetFreeCluster+0xe4>
 {
   if(totOrNext == TOTAL_FREE)
    830a:	8b 81       	ldd	r24, Y+3	; 0x03
    830c:	81 30       	cpi	r24, 0x01	; 1
    830e:	51 f4       	brne	.+20     	; 0x8324 <getSetFreeCluster+0xd0>
      return(FS->freeClusterCount);
    8310:	89 81       	ldd	r24, Y+1	; 0x01
    8312:	9a 81       	ldd	r25, Y+2	; 0x02
    8314:	88 51       	subi	r24, 0x18	; 24
    8316:	9e 4f       	sbci	r25, 0xFE	; 254
    8318:	fc 01       	movw	r30, r24
    831a:	80 81       	ld	r24, Z
    831c:	91 81       	ldd	r25, Z+1	; 0x01
    831e:	a2 81       	ldd	r26, Z+2	; 0x02
    8320:	b3 81       	ldd	r27, Z+3	; 0x03
    8322:	41 c0       	rjmp	.+130    	; 0x83a6 <getSetFreeCluster+0x152>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    8324:	89 81       	ldd	r24, Y+1	; 0x01
    8326:	9a 81       	ldd	r25, Y+2	; 0x02
    8328:	84 51       	subi	r24, 0x14	; 20
    832a:	9e 4f       	sbci	r25, 0xFE	; 254
    832c:	fc 01       	movw	r30, r24
    832e:	80 81       	ld	r24, Z
    8330:	91 81       	ldd	r25, Z+1	; 0x01
    8332:	a2 81       	ldd	r26, Z+2	; 0x02
    8334:	b3 81       	ldd	r27, Z+3	; 0x03
    8336:	37 c0       	rjmp	.+110    	; 0x83a6 <getSetFreeCluster+0x152>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    8338:	8b 81       	ldd	r24, Y+3	; 0x03
    833a:	81 30       	cpi	r24, 0x01	; 1
    833c:	79 f4       	brne	.+30     	; 0x835c <getSetFreeCluster+0x108>
      FS->freeClusterCount = FSEntry;
    833e:	89 81       	ldd	r24, Y+1	; 0x01
    8340:	9a 81       	ldd	r25, Y+2	; 0x02
    8342:	9c 01       	movw	r18, r24
    8344:	28 51       	subi	r18, 0x18	; 24
    8346:	3e 4f       	sbci	r19, 0xFE	; 254
    8348:	8d 81       	ldd	r24, Y+5	; 0x05
    834a:	9e 81       	ldd	r25, Y+6	; 0x06
    834c:	af 81       	ldd	r26, Y+7	; 0x07
    834e:	b8 85       	ldd	r27, Y+8	; 0x08
    8350:	f9 01       	movw	r30, r18
    8352:	80 83       	st	Z, r24
    8354:	91 83       	std	Z+1, r25	; 0x01
    8356:	a2 83       	std	Z+2, r26	; 0x02
    8358:	b3 83       	std	Z+3, r27	; 0x03
    835a:	0e c0       	rjmp	.+28     	; 0x8378 <getSetFreeCluster+0x124>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    835c:	89 81       	ldd	r24, Y+1	; 0x01
    835e:	9a 81       	ldd	r25, Y+2	; 0x02
    8360:	9c 01       	movw	r18, r24
    8362:	24 51       	subi	r18, 0x14	; 20
    8364:	3e 4f       	sbci	r19, 0xFE	; 254
    8366:	8d 81       	ldd	r24, Y+5	; 0x05
    8368:	9e 81       	ldd	r25, Y+6	; 0x06
    836a:	af 81       	ldd	r26, Y+7	; 0x07
    836c:	b8 85       	ldd	r27, Y+8	; 0x08
    836e:	f9 01       	movw	r30, r18
    8370:	80 83       	st	Z, r24
    8372:	91 83       	std	Z+1, r25	; 0x01
    8374:	a2 83       	std	Z+2, r26	; 0x02
    8376:	b3 83       	std	Z+3, r27	; 0x03
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    8378:	80 91 7e 50 	lds	r24, 0x507E
    837c:	90 91 7f 50 	lds	r25, 0x507F
    8380:	a0 91 80 50 	lds	r26, 0x5080
    8384:	b0 91 81 50 	lds	r27, 0x5081
    8388:	01 96       	adiw	r24, 0x01	; 1
    838a:	a1 1d       	adc	r26, r1
    838c:	b1 1d       	adc	r27, r1
    838e:	2f ec       	ldi	r18, 0xCF	; 207
    8390:	31 e2       	ldi	r19, 0x21	; 33
    8392:	bc 01       	movw	r22, r24
    8394:	cd 01       	movw	r24, r26
    8396:	a9 01       	movw	r20, r18
    8398:	20 e0       	ldi	r18, 0x00	; 0
    839a:	32 e0       	ldi	r19, 0x02	; 2
    839c:	0e 94 ac 4d 	call	0x9b58	; 0x9b58 <SD_write_block>
 }
 return 0xffffffff;
    83a0:	8f ef       	ldi	r24, 0xFF	; 255
    83a2:	9f ef       	ldi	r25, 0xFF	; 255
    83a4:	dc 01       	movw	r26, r24
}
    83a6:	bc 01       	movw	r22, r24
    83a8:	cd 01       	movw	r24, r26
    83aa:	28 96       	adiw	r28, 0x08	; 8
    83ac:	cd bf       	out	0x3d, r28	; 61
    83ae:	de bf       	out	0x3e, r29	; 62
    83b0:	df 91       	pop	r29
    83b2:	cf 91       	pop	r28
    83b4:	08 95       	ret

000083b6 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    83b6:	0f 93       	push	r16
    83b8:	1f 93       	push	r17
    83ba:	cf 93       	push	r28
    83bc:	df 93       	push	r29
    83be:	cd b7       	in	r28, 0x3d	; 61
    83c0:	de b7       	in	r29, 0x3e	; 62
    83c2:	6c 97       	sbiw	r28, 0x1c	; 28
    83c4:	cd bf       	out	0x3d, r28	; 61
    83c6:	de bf       	out	0x3e, r29	; 62
    83c8:	8a 8f       	std	Y+26, r24	; 0x1a
    83ca:	6b 8f       	std	Y+27, r22	; 0x1b
    83cc:	7c 8f       	std	Y+28, r23	; 0x1c
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    83ce:	80 91 60 40 	lds	r24, 0x4060
    83d2:	90 91 61 40 	lds	r25, 0x4061
    83d6:	a0 91 62 40 	lds	r26, 0x4062
    83da:	b0 91 63 40 	lds	r27, 0x4063
    83de:	89 83       	std	Y+1, r24	; 0x01
    83e0:	9a 83       	std	Y+2, r25	; 0x02
    83e2:	ab 83       	std	Y+3, r26	; 0x03
    83e4:	bc 83       	std	Y+4, r27	; 0x04
    83e6:	01 c0       	rjmp	.+2      	; 0x83ea <findFiles+0x34>
   if(cluster > 0x0ffffff6)
   	 return 0;
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
    83e8:	00 00       	nop

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    83ea:	89 81       	ldd	r24, Y+1	; 0x01
    83ec:	9a 81       	ldd	r25, Y+2	; 0x02
    83ee:	ab 81       	ldd	r26, Y+3	; 0x03
    83f0:	bc 81       	ldd	r27, Y+4	; 0x04
    83f2:	bc 01       	movw	r22, r24
    83f4:	cd 01       	movw	r24, r26
    83f6:	0e 94 4e 40 	call	0x809c	; 0x809c <getFirstSector>
    83fa:	dc 01       	movw	r26, r24
    83fc:	cb 01       	movw	r24, r22
    83fe:	88 8b       	std	Y+16, r24	; 0x10
    8400:	99 8b       	std	Y+17, r25	; 0x11
    8402:	aa 8b       	std	Y+18, r26	; 0x12
    8404:	bb 8b       	std	Y+19, r27	; 0x13

   for(sector = 0; sector < sectorPerCluster; sector++)
    8406:	1d 82       	std	Y+5, r1	; 0x05
    8408:	1e 82       	std	Y+6, r1	; 0x06
    840a:	1f 82       	std	Y+7, r1	; 0x07
    840c:	18 86       	std	Y+8, r1	; 0x08
    840e:	68 c1       	rjmp	.+720    	; 0x86e0 <findFiles+0x32a>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    8410:	28 89       	ldd	r18, Y+16	; 0x10
    8412:	39 89       	ldd	r19, Y+17	; 0x11
    8414:	4a 89       	ldd	r20, Y+18	; 0x12
    8416:	5b 89       	ldd	r21, Y+19	; 0x13
    8418:	8d 81       	ldd	r24, Y+5	; 0x05
    841a:	9e 81       	ldd	r25, Y+6	; 0x06
    841c:	af 81       	ldd	r26, Y+7	; 0x07
    841e:	b8 85       	ldd	r27, Y+8	; 0x08
    8420:	82 0f       	add	r24, r18
    8422:	93 1f       	adc	r25, r19
    8424:	a4 1f       	adc	r26, r20
    8426:	b5 1f       	adc	r27, r21
    8428:	2f ec       	ldi	r18, 0xCF	; 207
    842a:	31 e2       	ldi	r19, 0x21	; 33
    842c:	bc 01       	movw	r22, r24
    842e:	cd 01       	movw	r24, r26
    8430:	a9 01       	movw	r20, r18
    8432:	0e 94 7a 4e 	call	0x9cf4	; 0x9cf4 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    8436:	1d 86       	std	Y+13, r1	; 0x0d
    8438:	1e 86       	std	Y+14, r1	; 0x0e
    843a:	3d c1       	rjmp	.+634    	; 0x86b6 <findFiles+0x300>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    843c:	8d 85       	ldd	r24, Y+13	; 0x0d
    843e:	9e 85       	ldd	r25, Y+14	; 0x0e
    8440:	81 53       	subi	r24, 0x31	; 49
    8442:	9e 4d       	sbci	r25, 0xDE	; 222
    8444:	8c 8b       	std	Y+20, r24	; 0x14
    8446:	9d 8b       	std	Y+21, r25	; 0x15

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    8448:	8c 89       	ldd	r24, Y+20	; 0x14
    844a:	9d 89       	ldd	r25, Y+21	; 0x15
    844c:	fc 01       	movw	r30, r24
    844e:	80 81       	ld	r24, Z
    8450:	88 23       	and	r24, r24
    8452:	19 f4       	brne	.+6      	; 0x845a <findFiles+0xa4>
		{
		  return 0;   
    8454:	80 e0       	ldi	r24, 0x00	; 0
    8456:	90 e0       	ldi	r25, 0x00	; 0
    8458:	80 c1       	rjmp	.+768    	; 0x875a <findFiles+0x3a4>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    845a:	8c 89       	ldd	r24, Y+20	; 0x14
    845c:	9d 89       	ldd	r25, Y+21	; 0x15
    845e:	fc 01       	movw	r30, r24
    8460:	80 81       	ld	r24, Z
    8462:	85 3e       	cpi	r24, 0xE5	; 229
    8464:	09 f4       	brne	.+2      	; 0x8468 <findFiles+0xb2>
    8466:	22 c1       	rjmp	.+580    	; 0x86ac <findFiles+0x2f6>
    8468:	8c 89       	ldd	r24, Y+20	; 0x14
    846a:	9d 89       	ldd	r25, Y+21	; 0x15
    846c:	fc 01       	movw	r30, r24
    846e:	83 85       	ldd	r24, Z+11	; 0x0b
    8470:	8f 30       	cpi	r24, 0x0F	; 15
    8472:	09 f4       	brne	.+2      	; 0x8476 <findFiles+0xc0>
    8474:	1b c1       	rjmp	.+566    	; 0x86ac <findFiles+0x2f6>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    8476:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8478:	81 30       	cpi	r24, 0x01	; 1
    847a:	21 f0       	breq	.+8      	; 0x8484 <findFiles+0xce>
    847c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    847e:	82 30       	cpi	r24, 0x02	; 2
    8480:	09 f0       	breq	.+2      	; 0x8484 <findFiles+0xce>
    8482:	11 c1       	rjmp	.+546    	; 0x86a6 <findFiles+0x2f0>
          {
            for(j=0; j<11; j++)
    8484:	1f 86       	std	Y+15, r1	; 0x0f
    8486:	17 c0       	rjmp	.+46     	; 0x84b6 <findFiles+0x100>
            if(dir->name[j] != fileName[j]) break;
    8488:	8f 85       	ldd	r24, Y+15	; 0x0f
    848a:	88 2f       	mov	r24, r24
    848c:	90 e0       	ldi	r25, 0x00	; 0
    848e:	2c 89       	ldd	r18, Y+20	; 0x14
    8490:	3d 89       	ldd	r19, Y+21	; 0x15
    8492:	82 0f       	add	r24, r18
    8494:	93 1f       	adc	r25, r19
    8496:	fc 01       	movw	r30, r24
    8498:	40 81       	ld	r20, Z
    849a:	8f 85       	ldd	r24, Y+15	; 0x0f
    849c:	88 2f       	mov	r24, r24
    849e:	90 e0       	ldi	r25, 0x00	; 0
    84a0:	2b 8d       	ldd	r18, Y+27	; 0x1b
    84a2:	3c 8d       	ldd	r19, Y+28	; 0x1c
    84a4:	82 0f       	add	r24, r18
    84a6:	93 1f       	adc	r25, r19
    84a8:	fc 01       	movw	r30, r24
    84aa:	80 81       	ld	r24, Z
    84ac:	48 17       	cp	r20, r24
    84ae:	39 f4       	brne	.+14     	; 0x84be <findFiles+0x108>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    84b0:	8f 85       	ldd	r24, Y+15	; 0x0f
    84b2:	8f 5f       	subi	r24, 0xFF	; 255
    84b4:	8f 87       	std	Y+15, r24	; 0x0f
    84b6:	8f 85       	ldd	r24, Y+15	; 0x0f
    84b8:	8b 30       	cpi	r24, 0x0B	; 11
    84ba:	30 f3       	brcs	.-52     	; 0x8488 <findFiles+0xd2>
    84bc:	01 c0       	rjmp	.+2      	; 0x84c0 <findFiles+0x10a>
            if(dir->name[j] != fileName[j]) break;
    84be:	00 00       	nop
            if(j == 11)
    84c0:	8f 85       	ldd	r24, Y+15	; 0x0f
    84c2:	8b 30       	cpi	r24, 0x0B	; 11
    84c4:	09 f0       	breq	.+2      	; 0x84c8 <findFiles+0x112>
    84c6:	f2 c0       	rjmp	.+484    	; 0x86ac <findFiles+0x2f6>
			{
			  if(flag == GET_FILE)
    84c8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    84ca:	81 30       	cpi	r24, 0x01	; 1
    84cc:	09 f0       	breq	.+2      	; 0x84d0 <findFiles+0x11a>
    84ce:	52 c0       	rjmp	.+164    	; 0x8574 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    84d0:	28 89       	ldd	r18, Y+16	; 0x10
    84d2:	39 89       	ldd	r19, Y+17	; 0x11
    84d4:	4a 89       	ldd	r20, Y+18	; 0x12
    84d6:	5b 89       	ldd	r21, Y+19	; 0x13
    84d8:	8d 81       	ldd	r24, Y+5	; 0x05
    84da:	9e 81       	ldd	r25, Y+6	; 0x06
    84dc:	af 81       	ldd	r26, Y+7	; 0x07
    84de:	b8 85       	ldd	r27, Y+8	; 0x08
    84e0:	82 0f       	add	r24, r18
    84e2:	93 1f       	adc	r25, r19
    84e4:	a4 1f       	adc	r26, r20
    84e6:	b5 1f       	adc	r27, r21
    84e8:	80 93 d2 50 	sts	0x50D2, r24
    84ec:	90 93 d3 50 	sts	0x50D3, r25
    84f0:	a0 93 d4 50 	sts	0x50D4, r26
    84f4:	b0 93 d5 50 	sts	0x50D5, r27
				appendFileLocation = i;
    84f8:	8d 85       	ldd	r24, Y+13	; 0x0d
    84fa:	9e 85       	ldd	r25, Y+14	; 0x0e
    84fc:	cc 01       	movw	r24, r24
    84fe:	a0 e0       	ldi	r26, 0x00	; 0
    8500:	b0 e0       	ldi	r27, 0x00	; 0
    8502:	80 93 d0 23 	sts	0x23D0, r24
    8506:	90 93 d1 23 	sts	0x23D1, r25
    850a:	a0 93 d2 23 	sts	0x23D2, r26
    850e:	b0 93 d3 23 	sts	0x23D3, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8512:	8c 89       	ldd	r24, Y+20	; 0x14
    8514:	9d 89       	ldd	r25, Y+21	; 0x15
    8516:	fc 01       	movw	r30, r24
    8518:	84 89       	ldd	r24, Z+20	; 0x14
    851a:	95 89       	ldd	r25, Z+21	; 0x15
    851c:	cc 01       	movw	r24, r24
    851e:	a0 e0       	ldi	r26, 0x00	; 0
    8520:	b0 e0       	ldi	r27, 0x00	; 0
    8522:	ac 01       	movw	r20, r24
    8524:	33 27       	eor	r19, r19
    8526:	22 27       	eor	r18, r18
    8528:	8c 89       	ldd	r24, Y+20	; 0x14
    852a:	9d 89       	ldd	r25, Y+21	; 0x15
    852c:	fc 01       	movw	r30, r24
    852e:	82 8d       	ldd	r24, Z+26	; 0x1a
    8530:	93 8d       	ldd	r25, Z+27	; 0x1b
    8532:	cc 01       	movw	r24, r24
    8534:	a0 e0       	ldi	r26, 0x00	; 0
    8536:	b0 e0       	ldi	r27, 0x00	; 0
    8538:	82 2b       	or	r24, r18
    853a:	93 2b       	or	r25, r19
    853c:	a4 2b       	or	r26, r20
    853e:	b5 2b       	or	r27, r21
    8540:	80 93 88 50 	sts	0x5088, r24
    8544:	90 93 89 50 	sts	0x5089, r25
    8548:	a0 93 8a 50 	sts	0x508A, r26
    854c:	b0 93 8b 50 	sts	0x508B, r27
				fileSize = dir->fileSize;
    8550:	8c 89       	ldd	r24, Y+20	; 0x14
    8552:	9d 89       	ldd	r25, Y+21	; 0x15
    8554:	fc 01       	movw	r30, r24
    8556:	84 8d       	ldd	r24, Z+28	; 0x1c
    8558:	95 8d       	ldd	r25, Z+29	; 0x1d
    855a:	a6 8d       	ldd	r26, Z+30	; 0x1e
    855c:	b7 8d       	ldd	r27, Z+31	; 0x1f
    855e:	80 93 49 40 	sts	0x4049, r24
    8562:	90 93 4a 40 	sts	0x404A, r25
    8566:	a0 93 4b 40 	sts	0x404B, r26
    856a:	b0 93 4c 40 	sts	0x404C, r27
			    return (dir);
    856e:	8c 89       	ldd	r24, Y+20	; 0x14
    8570:	9d 89       	ldd	r25, Y+21	; 0x15
    8572:	f3 c0       	rjmp	.+486    	; 0x875a <findFiles+0x3a4>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    8574:	8c 89       	ldd	r24, Y+20	; 0x14
    8576:	9d 89       	ldd	r25, Y+21	; 0x15
    8578:	fc 01       	movw	r30, r24
    857a:	84 89       	ldd	r24, Z+20	; 0x14
    857c:	95 89       	ldd	r25, Z+21	; 0x15
    857e:	cc 01       	movw	r24, r24
    8580:	a0 e0       	ldi	r26, 0x00	; 0
    8582:	b0 e0       	ldi	r27, 0x00	; 0
    8584:	ac 01       	movw	r20, r24
    8586:	33 27       	eor	r19, r19
    8588:	22 27       	eor	r18, r18
    858a:	8c 89       	ldd	r24, Y+20	; 0x14
    858c:	9d 89       	ldd	r25, Y+21	; 0x15
    858e:	fc 01       	movw	r30, r24
    8590:	82 8d       	ldd	r24, Z+26	; 0x1a
    8592:	93 8d       	ldd	r25, Z+27	; 0x1b
    8594:	cc 01       	movw	r24, r24
    8596:	a0 e0       	ldi	r26, 0x00	; 0
    8598:	b0 e0       	ldi	r27, 0x00	; 0
    859a:	82 2b       	or	r24, r18
    859c:	93 2b       	or	r25, r19
    859e:	a4 2b       	or	r26, r20
    85a0:	b5 2b       	or	r27, r21
    85a2:	89 87       	std	Y+9, r24	; 0x09
    85a4:	9a 87       	std	Y+10, r25	; 0x0a
    85a6:	ab 87       	std	Y+11, r26	; 0x0b
    85a8:	bc 87       	std	Y+12, r27	; 0x0c
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    85aa:	8c 89       	ldd	r24, Y+20	; 0x14
    85ac:	9d 89       	ldd	r25, Y+21	; 0x15
    85ae:	25 ee       	ldi	r18, 0xE5	; 229
    85b0:	fc 01       	movw	r30, r24
    85b2:	20 83       	st	Z, r18
				 SD_write_block (firstSector+sector,SDBuffer,512);
    85b4:	28 89       	ldd	r18, Y+16	; 0x10
    85b6:	39 89       	ldd	r19, Y+17	; 0x11
    85b8:	4a 89       	ldd	r20, Y+18	; 0x12
    85ba:	5b 89       	ldd	r21, Y+19	; 0x13
    85bc:	8d 81       	ldd	r24, Y+5	; 0x05
    85be:	9e 81       	ldd	r25, Y+6	; 0x06
    85c0:	af 81       	ldd	r26, Y+7	; 0x07
    85c2:	b8 85       	ldd	r27, Y+8	; 0x08
    85c4:	82 0f       	add	r24, r18
    85c6:	93 1f       	adc	r25, r19
    85c8:	a4 1f       	adc	r26, r20
    85ca:	b5 1f       	adc	r27, r21
    85cc:	2f ec       	ldi	r18, 0xCF	; 207
    85ce:	31 e2       	ldi	r19, 0x21	; 33
    85d0:	bc 01       	movw	r22, r24
    85d2:	cd 01       	movw	r24, r26
    85d4:	a9 01       	movw	r20, r18
    85d6:	20 e0       	ldi	r18, 0x00	; 0
    85d8:	32 e0       	ldi	r19, 0x02	; 2
    85da:	0e 94 ac 4d 	call	0x9b58	; 0x9b58 <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    85de:	8c 89       	ldd	r24, Y+20	; 0x14
    85e0:	9d 89       	ldd	r25, Y+21	; 0x15
    85e2:	fc 01       	movw	r30, r24
    85e4:	24 8d       	ldd	r18, Z+28	; 0x1c
    85e6:	35 8d       	ldd	r19, Z+29	; 0x1d
    85e8:	46 8d       	ldd	r20, Z+30	; 0x1e
    85ea:	57 8d       	ldd	r21, Z+31	; 0x1f
    85ec:	80 e0       	ldi	r24, 0x00	; 0
    85ee:	ba 01       	movw	r22, r20
    85f0:	a9 01       	movw	r20, r18
    85f2:	0e 94 49 4a 	call	0x9492	; 0x9492 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    85f6:	82 e0       	ldi	r24, 0x02	; 2
    85f8:	60 e0       	ldi	r22, 0x00	; 0
    85fa:	20 e0       	ldi	r18, 0x00	; 0
    85fc:	30 e0       	ldi	r19, 0x00	; 0
    85fe:	a9 01       	movw	r20, r18
    8600:	0e 94 2a 41 	call	0x8254	; 0x8254 <getSetFreeCluster>
    8604:	dc 01       	movw	r26, r24
    8606:	cb 01       	movw	r24, r22
    8608:	89 83       	std	Y+1, r24	; 0x01
    860a:	9a 83       	std	Y+2, r25	; 0x02
    860c:	ab 83       	std	Y+3, r26	; 0x03
    860e:	bc 83       	std	Y+4, r27	; 0x04
				 if(firstCluster < cluster)
    8610:	29 85       	ldd	r18, Y+9	; 0x09
    8612:	3a 85       	ldd	r19, Y+10	; 0x0a
    8614:	4b 85       	ldd	r20, Y+11	; 0x0b
    8616:	5c 85       	ldd	r21, Y+12	; 0x0c
    8618:	89 81       	ldd	r24, Y+1	; 0x01
    861a:	9a 81       	ldd	r25, Y+2	; 0x02
    861c:	ab 81       	ldd	r26, Y+3	; 0x03
    861e:	bc 81       	ldd	r27, Y+4	; 0x04
    8620:	28 17       	cp	r18, r24
    8622:	39 07       	cpc	r19, r25
    8624:	4a 07       	cpc	r20, r26
    8626:	5b 07       	cpc	r21, r27
    8628:	40 f4       	brcc	.+16     	; 0x863a <findFiles+0x284>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    862a:	29 85       	ldd	r18, Y+9	; 0x09
    862c:	3a 85       	ldd	r19, Y+10	; 0x0a
    862e:	4b 85       	ldd	r20, Y+11	; 0x0b
    8630:	5c 85       	ldd	r21, Y+12	; 0x0c
    8632:	82 e0       	ldi	r24, 0x02	; 2
    8634:	61 e0       	ldi	r22, 0x01	; 1
    8636:	0e 94 2a 41 	call	0x8254	; 0x8254 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    863a:	89 85       	ldd	r24, Y+9	; 0x09
    863c:	9a 85       	ldd	r25, Y+10	; 0x0a
    863e:	ab 85       	ldd	r26, Y+11	; 0x0b
    8640:	bc 85       	ldd	r27, Y+12	; 0x0c
    8642:	bc 01       	movw	r22, r24
    8644:	cd 01       	movw	r24, r26
    8646:	40 e0       	ldi	r20, 0x00	; 0
    8648:	00 e0       	ldi	r16, 0x00	; 0
    864a:	10 e0       	ldi	r17, 0x00	; 0
    864c:	98 01       	movw	r18, r16
    864e:	0e 94 80 40 	call	0x8100	; 0x8100 <getSetNextCluster>
    8652:	dc 01       	movw	r26, r24
    8654:	cb 01       	movw	r24, r22
    8656:	8e 8b       	std	Y+22, r24	; 0x16
    8658:	9f 8b       	std	Y+23, r25	; 0x17
    865a:	a8 8f       	std	Y+24, r26	; 0x18
    865c:	b9 8f       	std	Y+25, r27	; 0x19
					getSetNextCluster (firstCluster, SET, 0);
    865e:	89 85       	ldd	r24, Y+9	; 0x09
    8660:	9a 85       	ldd	r25, Y+10	; 0x0a
    8662:	ab 85       	ldd	r26, Y+11	; 0x0b
    8664:	bc 85       	ldd	r27, Y+12	; 0x0c
    8666:	bc 01       	movw	r22, r24
    8668:	cd 01       	movw	r24, r26
    866a:	41 e0       	ldi	r20, 0x01	; 1
    866c:	00 e0       	ldi	r16, 0x00	; 0
    866e:	10 e0       	ldi	r17, 0x00	; 0
    8670:	98 01       	movw	r18, r16
    8672:	0e 94 80 40 	call	0x8100	; 0x8100 <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    8676:	8e 89       	ldd	r24, Y+22	; 0x16
    8678:	9f 89       	ldd	r25, Y+23	; 0x17
    867a:	a8 8d       	ldd	r26, Y+24	; 0x18
    867c:	b9 8d       	ldd	r27, Y+25	; 0x19
    867e:	87 3f       	cpi	r24, 0xF7	; 247
    8680:	ff ef       	ldi	r31, 0xFF	; 255
    8682:	9f 07       	cpc	r25, r31
    8684:	ff ef       	ldi	r31, 0xFF	; 255
    8686:	af 07       	cpc	r26, r31
    8688:	ff e0       	ldi	r31, 0x0F	; 15
    868a:	bf 07       	cpc	r27, r31
    868c:	18 f0       	brcs	.+6      	; 0x8694 <findFiles+0x2de>
					   {//file deleted
						   return 0;}
    868e:	80 e0       	ldi	r24, 0x00	; 0
    8690:	90 e0       	ldi	r25, 0x00	; 0
    8692:	63 c0       	rjmp	.+198    	; 0x875a <findFiles+0x3a4>
					firstCluster = nextCluster;
    8694:	8e 89       	ldd	r24, Y+22	; 0x16
    8696:	9f 89       	ldd	r25, Y+23	; 0x17
    8698:	a8 8d       	ldd	r26, Y+24	; 0x18
    869a:	b9 8d       	ldd	r27, Y+25	; 0x19
    869c:	89 87       	std	Y+9, r24	; 0x09
    869e:	9a 87       	std	Y+10, r25	; 0x0a
    86a0:	ab 87       	std	Y+11, r26	; 0x0b
    86a2:	bc 87       	std	Y+12, r27	; 0x0c
			  	 } 
    86a4:	ca cf       	rjmp	.-108    	; 0x863a <findFiles+0x284>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    86a6:	80 e0       	ldi	r24, 0x00	; 0
    86a8:	90 e0       	ldi	r25, 0x00	; 0
    86aa:	57 c0       	rjmp	.+174    	; 0x875a <findFiles+0x3a4>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    86ac:	8d 85       	ldd	r24, Y+13	; 0x0d
    86ae:	9e 85       	ldd	r25, Y+14	; 0x0e
    86b0:	80 96       	adiw	r24, 0x20	; 32
    86b2:	8d 87       	std	Y+13, r24	; 0x0d
    86b4:	9e 87       	std	Y+14, r25	; 0x0e
    86b6:	80 91 4d 40 	lds	r24, 0x404D
    86ba:	90 91 4e 40 	lds	r25, 0x404E
    86be:	2d 85       	ldd	r18, Y+13	; 0x0d
    86c0:	3e 85       	ldd	r19, Y+14	; 0x0e
    86c2:	28 17       	cp	r18, r24
    86c4:	39 07       	cpc	r19, r25
    86c6:	08 f4       	brcc	.+2      	; 0x86ca <findFiles+0x314>
    86c8:	b9 ce       	rjmp	.-654    	; 0x843c <findFiles+0x86>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    86ca:	8d 81       	ldd	r24, Y+5	; 0x05
    86cc:	9e 81       	ldd	r25, Y+6	; 0x06
    86ce:	af 81       	ldd	r26, Y+7	; 0x07
    86d0:	b8 85       	ldd	r27, Y+8	; 0x08
    86d2:	01 96       	adiw	r24, 0x01	; 1
    86d4:	a1 1d       	adc	r26, r1
    86d6:	b1 1d       	adc	r27, r1
    86d8:	8d 83       	std	Y+5, r24	; 0x05
    86da:	9e 83       	std	Y+6, r25	; 0x06
    86dc:	af 83       	std	Y+7, r26	; 0x07
    86de:	b8 87       	std	Y+8, r27	; 0x08
    86e0:	80 91 7c 50 	lds	r24, 0x507C
    86e4:	90 91 7d 50 	lds	r25, 0x507D
    86e8:	9c 01       	movw	r18, r24
    86ea:	40 e0       	ldi	r20, 0x00	; 0
    86ec:	50 e0       	ldi	r21, 0x00	; 0
    86ee:	8d 81       	ldd	r24, Y+5	; 0x05
    86f0:	9e 81       	ldd	r25, Y+6	; 0x06
    86f2:	af 81       	ldd	r26, Y+7	; 0x07
    86f4:	b8 85       	ldd	r27, Y+8	; 0x08
    86f6:	82 17       	cp	r24, r18
    86f8:	93 07       	cpc	r25, r19
    86fa:	a4 07       	cpc	r26, r20
    86fc:	b5 07       	cpc	r27, r21
    86fe:	08 f4       	brcc	.+2      	; 0x8702 <findFiles+0x34c>
    8700:	87 ce       	rjmp	.-754    	; 0x8410 <findFiles+0x5a>
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    8702:	89 81       	ldd	r24, Y+1	; 0x01
    8704:	9a 81       	ldd	r25, Y+2	; 0x02
    8706:	ab 81       	ldd	r26, Y+3	; 0x03
    8708:	bc 81       	ldd	r27, Y+4	; 0x04
    870a:	bc 01       	movw	r22, r24
    870c:	cd 01       	movw	r24, r26
    870e:	40 e0       	ldi	r20, 0x00	; 0
    8710:	00 e0       	ldi	r16, 0x00	; 0
    8712:	10 e0       	ldi	r17, 0x00	; 0
    8714:	98 01       	movw	r18, r16
    8716:	0e 94 80 40 	call	0x8100	; 0x8100 <getSetNextCluster>
    871a:	dc 01       	movw	r26, r24
    871c:	cb 01       	movw	r24, r22
    871e:	89 83       	std	Y+1, r24	; 0x01
    8720:	9a 83       	std	Y+2, r25	; 0x02
    8722:	ab 83       	std	Y+3, r26	; 0x03
    8724:	bc 83       	std	Y+4, r27	; 0x04

   if(cluster > 0x0ffffff6)
    8726:	89 81       	ldd	r24, Y+1	; 0x01
    8728:	9a 81       	ldd	r25, Y+2	; 0x02
    872a:	ab 81       	ldd	r26, Y+3	; 0x03
    872c:	bc 81       	ldd	r27, Y+4	; 0x04
    872e:	87 3f       	cpi	r24, 0xF7	; 247
    8730:	2f ef       	ldi	r18, 0xFF	; 255
    8732:	92 07       	cpc	r25, r18
    8734:	2f ef       	ldi	r18, 0xFF	; 255
    8736:	a2 07       	cpc	r26, r18
    8738:	2f e0       	ldi	r18, 0x0F	; 15
    873a:	b2 07       	cpc	r27, r18
    873c:	18 f0       	brcs	.+6      	; 0x8744 <findFiles+0x38e>
   	 return 0;
    873e:	80 e0       	ldi	r24, 0x00	; 0
    8740:	90 e0       	ldi	r25, 0x00	; 0
    8742:	0b c0       	rjmp	.+22     	; 0x875a <findFiles+0x3a4>
   if(cluster == 0) 
    8744:	89 81       	ldd	r24, Y+1	; 0x01
    8746:	9a 81       	ldd	r25, Y+2	; 0x02
    8748:	ab 81       	ldd	r26, Y+3	; 0x03
    874a:	bc 81       	ldd	r27, Y+4	; 0x04
    874c:	00 97       	sbiw	r24, 0x00	; 0
    874e:	a1 05       	cpc	r26, r1
    8750:	b1 05       	cpc	r27, r1
    8752:	09 f0       	breq	.+2      	; 0x8756 <findFiles+0x3a0>
    8754:	49 ce       	rjmp	.-878    	; 0x83e8 <findFiles+0x32>
   {//error in getting cluster
	   return 0;}
    8756:	80 e0       	ldi	r24, 0x00	; 0
    8758:	90 e0       	ldi	r25, 0x00	; 0
 }
return 0;
}
    875a:	6c 96       	adiw	r28, 0x1c	; 28
    875c:	cd bf       	out	0x3d, r28	; 61
    875e:	de bf       	out	0x3e, r29	; 62
    8760:	df 91       	pop	r29
    8762:	cf 91       	pop	r28
    8764:	1f 91       	pop	r17
    8766:	0f 91       	pop	r16
    8768:	08 95       	ret

0000876a <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    876a:	0f 93       	push	r16
    876c:	1f 93       	push	r17
    876e:	cf 93       	push	r28
    8770:	df 93       	push	r29
    8772:	cd b7       	in	r28, 0x3d	; 61
    8774:	de b7       	in	r29, 0x3e	; 62
    8776:	67 97       	sbiw	r28, 0x17	; 23
    8778:	cd bf       	out	0x3d, r28	; 61
    877a:	de bf       	out	0x3e, r29	; 62
    877c:	8d 8b       	std	Y+21, r24	; 0x15
    877e:	6e 8b       	std	Y+22, r22	; 0x16
    8780:	7f 8b       	std	Y+23, r23	; 0x17
struct dir_Structure *dir;
unsigned long cluster, byteCounter = 0, fileSize, firstSector;
    8782:	1e 82       	std	Y+6, r1	; 0x06
    8784:	1f 82       	std	Y+7, r1	; 0x07
    8786:	18 86       	std	Y+8, r1	; 0x08
    8788:	19 86       	std	Y+9, r1	; 0x09
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    878a:	8e 89       	ldd	r24, Y+22	; 0x16
    878c:	9f 89       	ldd	r25, Y+23	; 0x17
    878e:	0e 94 64 44 	call	0x88c8	; 0x88c8 <convertFileName>
    8792:	8a 87       	std	Y+10, r24	; 0x0a
if(error) return 2;
    8794:	8a 85       	ldd	r24, Y+10	; 0x0a
    8796:	88 23       	and	r24, r24
    8798:	11 f0       	breq	.+4      	; 0x879e <readFile+0x34>
    879a:	82 e0       	ldi	r24, 0x02	; 2
    879c:	8d c0       	rjmp	.+282    	; 0x88b8 <readFile+0x14e>

dir = findFiles (GET_FILE, Filename); //get the file location
    879e:	2c eb       	ldi	r18, 0xBC	; 188
    87a0:	30 e5       	ldi	r19, 0x50	; 80
    87a2:	81 e0       	ldi	r24, 0x01	; 1
    87a4:	b9 01       	movw	r22, r18
    87a6:	0e 94 db 41 	call	0x83b6	; 0x83b6 <findFiles>
    87aa:	8b 87       	std	Y+11, r24	; 0x0b
    87ac:	9c 87       	std	Y+12, r25	; 0x0c
if(dir == 0) 
    87ae:	8b 85       	ldd	r24, Y+11	; 0x0b
    87b0:	9c 85       	ldd	r25, Y+12	; 0x0c
    87b2:	00 97       	sbiw	r24, 0x00	; 0
    87b4:	39 f4       	brne	.+14     	; 0x87c4 <readFile+0x5a>
{
  if(flag == READ) return (1);
    87b6:	8d 89       	ldd	r24, Y+21	; 0x15
    87b8:	88 23       	and	r24, r24
    87ba:	11 f4       	brne	.+4      	; 0x87c0 <readFile+0x56>
    87bc:	81 e0       	ldi	r24, 0x01	; 1
    87be:	7c c0       	rjmp	.+248    	; 0x88b8 <readFile+0x14e>
  else return (0);
    87c0:	80 e0       	ldi	r24, 0x00	; 0
    87c2:	7a c0       	rjmp	.+244    	; 0x88b8 <readFile+0x14e>
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    87c4:	8d 89       	ldd	r24, Y+21	; 0x15
    87c6:	81 30       	cpi	r24, 0x01	; 1
    87c8:	11 f4       	brne	.+4      	; 0x87ce <readFile+0x64>
    87ca:	81 e0       	ldi	r24, 0x01	; 1
    87cc:	75 c0       	rjmp	.+234    	; 0x88b8 <readFile+0x14e>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    87ce:	8b 85       	ldd	r24, Y+11	; 0x0b
    87d0:	9c 85       	ldd	r25, Y+12	; 0x0c
    87d2:	fc 01       	movw	r30, r24
    87d4:	84 89       	ldd	r24, Z+20	; 0x14
    87d6:	95 89       	ldd	r25, Z+21	; 0x15
    87d8:	cc 01       	movw	r24, r24
    87da:	a0 e0       	ldi	r26, 0x00	; 0
    87dc:	b0 e0       	ldi	r27, 0x00	; 0
    87de:	ac 01       	movw	r20, r24
    87e0:	33 27       	eor	r19, r19
    87e2:	22 27       	eor	r18, r18
    87e4:	8b 85       	ldd	r24, Y+11	; 0x0b
    87e6:	9c 85       	ldd	r25, Y+12	; 0x0c
    87e8:	fc 01       	movw	r30, r24
    87ea:	82 8d       	ldd	r24, Z+26	; 0x1a
    87ec:	93 8d       	ldd	r25, Z+27	; 0x1b
    87ee:	cc 01       	movw	r24, r24
    87f0:	a0 e0       	ldi	r26, 0x00	; 0
    87f2:	b0 e0       	ldi	r27, 0x00	; 0
    87f4:	82 2b       	or	r24, r18
    87f6:	93 2b       	or	r25, r19
    87f8:	a4 2b       	or	r26, r20
    87fa:	b5 2b       	or	r27, r21
    87fc:	89 83       	std	Y+1, r24	; 0x01
    87fe:	9a 83       	std	Y+2, r25	; 0x02
    8800:	ab 83       	std	Y+3, r26	; 0x03
    8802:	bc 83       	std	Y+4, r27	; 0x04

fileSize = dir->fileSize;
    8804:	8b 85       	ldd	r24, Y+11	; 0x0b
    8806:	9c 85       	ldd	r25, Y+12	; 0x0c
    8808:	fc 01       	movw	r30, r24
    880a:	84 8d       	ldd	r24, Z+28	; 0x1c
    880c:	95 8d       	ldd	r25, Z+29	; 0x1d
    880e:	a6 8d       	ldd	r26, Z+30	; 0x1e
    8810:	b7 8d       	ldd	r27, Z+31	; 0x1f
    8812:	8d 87       	std	Y+13, r24	; 0x0d
    8814:	9e 87       	std	Y+14, r25	; 0x0e
    8816:	af 87       	std	Y+15, r26	; 0x0f
    8818:	b8 8b       	std	Y+16, r27	; 0x10
    881a:	01 c0       	rjmp	.+2      	; 0x881e <readFile+0xb4>
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
    881c:	00 00       	nop
fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    881e:	89 81       	ldd	r24, Y+1	; 0x01
    8820:	9a 81       	ldd	r25, Y+2	; 0x02
    8822:	ab 81       	ldd	r26, Y+3	; 0x03
    8824:	bc 81       	ldd	r27, Y+4	; 0x04
    8826:	bc 01       	movw	r22, r24
    8828:	cd 01       	movw	r24, r26
    882a:	0e 94 4e 40 	call	0x809c	; 0x809c <getFirstSector>
    882e:	dc 01       	movw	r26, r24
    8830:	cb 01       	movw	r24, r22
    8832:	89 8b       	std	Y+17, r24	; 0x11
    8834:	9a 8b       	std	Y+18, r25	; 0x12
    8836:	ab 8b       	std	Y+19, r26	; 0x13
    8838:	bc 8b       	std	Y+20, r27	; 0x14

  for(j=0; j<sectorPerCluster; j++)
    883a:	1d 82       	std	Y+5, r1	; 0x05
    883c:	17 c0       	rjmp	.+46     	; 0x886c <readFile+0x102>
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    883e:	8d 81       	ldd	r24, Y+5	; 0x05
    8840:	28 2f       	mov	r18, r24
    8842:	30 e0       	ldi	r19, 0x00	; 0
    8844:	40 e0       	ldi	r20, 0x00	; 0
    8846:	50 e0       	ldi	r21, 0x00	; 0
    8848:	89 89       	ldd	r24, Y+17	; 0x11
    884a:	9a 89       	ldd	r25, Y+18	; 0x12
    884c:	ab 89       	ldd	r26, Y+19	; 0x13
    884e:	bc 89       	ldd	r27, Y+20	; 0x14
    8850:	82 0f       	add	r24, r18
    8852:	93 1f       	adc	r25, r19
    8854:	a4 1f       	adc	r26, r20
    8856:	b5 1f       	adc	r27, r21
    8858:	28 ed       	ldi	r18, 0xD8	; 216
    885a:	33 e2       	ldi	r19, 0x23	; 35
    885c:	bc 01       	movw	r22, r24
    885e:	cd 01       	movw	r24, r26
    8860:	a9 01       	movw	r20, r18
    8862:	0e 94 7a 4e 	call	0x9cf4	; 0x9cf4 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    8866:	8d 81       	ldd	r24, Y+5	; 0x05
    8868:	8f 5f       	subi	r24, 0xFF	; 255
    886a:	8d 83       	std	Y+5, r24	; 0x05
    886c:	8d 81       	ldd	r24, Y+5	; 0x05
    886e:	28 2f       	mov	r18, r24
    8870:	30 e0       	ldi	r19, 0x00	; 0
    8872:	80 91 7c 50 	lds	r24, 0x507C
    8876:	90 91 7d 50 	lds	r25, 0x507D
    887a:	28 17       	cp	r18, r24
    887c:	39 07       	cpc	r19, r25
    887e:	f8 f2       	brcs	.-66     	; 0x883e <readFile+0xd4>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    8880:	89 81       	ldd	r24, Y+1	; 0x01
    8882:	9a 81       	ldd	r25, Y+2	; 0x02
    8884:	ab 81       	ldd	r26, Y+3	; 0x03
    8886:	bc 81       	ldd	r27, Y+4	; 0x04
    8888:	bc 01       	movw	r22, r24
    888a:	cd 01       	movw	r24, r26
    888c:	40 e0       	ldi	r20, 0x00	; 0
    888e:	00 e0       	ldi	r16, 0x00	; 0
    8890:	10 e0       	ldi	r17, 0x00	; 0
    8892:	98 01       	movw	r18, r16
    8894:	0e 94 80 40 	call	0x8100	; 0x8100 <getSetNextCluster>
    8898:	dc 01       	movw	r26, r24
    889a:	cb 01       	movw	r24, r22
    889c:	89 83       	std	Y+1, r24	; 0x01
    889e:	9a 83       	std	Y+2, r25	; 0x02
    88a0:	ab 83       	std	Y+3, r26	; 0x03
    88a2:	bc 83       	std	Y+4, r27	; 0x04
  if(cluster == 0) {//Error in getting cluster
    88a4:	89 81       	ldd	r24, Y+1	; 0x01
    88a6:	9a 81       	ldd	r25, Y+2	; 0x02
    88a8:	ab 81       	ldd	r26, Y+3	; 0x03
    88aa:	bc 81       	ldd	r27, Y+4	; 0x04
    88ac:	00 97       	sbiw	r24, 0x00	; 0
    88ae:	a1 05       	cpc	r26, r1
    88b0:	b1 05       	cpc	r27, r1
    88b2:	09 f0       	breq	.+2      	; 0x88b6 <readFile+0x14c>
    88b4:	b3 cf       	rjmp	.-154    	; 0x881c <readFile+0xb2>
	  return 0;}
    88b6:	80 e0       	ldi	r24, 0x00	; 0
}
return 0;
}
    88b8:	67 96       	adiw	r28, 0x17	; 23
    88ba:	cd bf       	out	0x3d, r28	; 61
    88bc:	de bf       	out	0x3e, r29	; 62
    88be:	df 91       	pop	r29
    88c0:	cf 91       	pop	r28
    88c2:	1f 91       	pop	r17
    88c4:	0f 91       	pop	r16
    88c6:	08 95       	ret

000088c8 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    88c8:	cf 93       	push	r28
    88ca:	df 93       	push	r29
    88cc:	cd b7       	in	r28, 0x3d	; 61
    88ce:	de b7       	in	r29, 0x3e	; 62
    88d0:	62 97       	sbiw	r28, 0x12	; 18
    88d2:	cd bf       	out	0x3d, r28	; 61
    88d4:	de bf       	out	0x3e, r29	; 62
    88d6:	89 8b       	std	Y+17, r24	; 0x11
    88d8:	9a 8b       	std	Y+18, r25	; 0x12
bool NoExtension = FALSE;
    88da:	19 82       	std	Y+1, r1	; 0x01
unsigned char fileNameFAT[11];
unsigned char j, k;

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
    88dc:	89 89       	ldd	r24, Y+17	; 0x11
    88de:	9a 89       	ldd	r25, Y+18	; 0x12
    88e0:	9c 01       	movw	r18, r24
    88e2:	f9 01       	movw	r30, r18
    88e4:	01 90       	ld	r0, Z+
    88e6:	00 20       	and	r0, r0
    88e8:	e9 f7       	brne	.-6      	; 0x88e4 <convertFileName+0x1c>
    88ea:	cf 01       	movw	r24, r30
    88ec:	01 97       	sbiw	r24, 0x01	; 1
    88ee:	82 1b       	sub	r24, r18
    88f0:	93 0b       	sbc	r25, r19
    88f2:	80 31       	cpi	r24, 0x10	; 16
    88f4:	91 05       	cpc	r25, r1
    88f6:	10 f0       	brcs	.+4      	; 0x88fc <convertFileName+0x34>
    88f8:	81 e0       	ldi	r24, 0x01	; 1
    88fa:	16 c1       	rjmp	.+556    	; 0x8b28 <convertFileName+0x260>
int i=0;
    88fc:	1c 82       	std	Y+4, r1	; 0x04
    88fe:	1d 82       	std	Y+5, r1	; 0x05
for(; i < strlen(fileName); i++){
    8900:	13 c0       	rjmp	.+38     	; 0x8928 <convertFileName+0x60>
	Filename[i] = fileName[i];
    8902:	8c 81       	ldd	r24, Y+4	; 0x04
    8904:	9d 81       	ldd	r25, Y+5	; 0x05
    8906:	29 89       	ldd	r18, Y+17	; 0x11
    8908:	3a 89       	ldd	r19, Y+18	; 0x12
    890a:	82 0f       	add	r24, r18
    890c:	93 1f       	adc	r25, r19
    890e:	fc 01       	movw	r30, r24
    8910:	20 81       	ld	r18, Z
    8912:	8c 81       	ldd	r24, Y+4	; 0x04
    8914:	9d 81       	ldd	r25, Y+5	; 0x05
    8916:	84 54       	subi	r24, 0x44	; 68
    8918:	9f 4a       	sbci	r25, 0xAF	; 175
    891a:	fc 01       	movw	r30, r24
    891c:	20 83       	st	Z, r18

//store the string variable into the file name array if it is of a proper length

if(strlen(fileName) > 15) return 1;
int i=0;
for(; i < strlen(fileName); i++){
    891e:	8c 81       	ldd	r24, Y+4	; 0x04
    8920:	9d 81       	ldd	r25, Y+5	; 0x05
    8922:	01 96       	adiw	r24, 0x01	; 1
    8924:	8c 83       	std	Y+4, r24	; 0x04
    8926:	9d 83       	std	Y+5, r25	; 0x05
    8928:	4c 81       	ldd	r20, Y+4	; 0x04
    892a:	5d 81       	ldd	r21, Y+5	; 0x05
    892c:	89 89       	ldd	r24, Y+17	; 0x11
    892e:	9a 89       	ldd	r25, Y+18	; 0x12
    8930:	9c 01       	movw	r18, r24
    8932:	f9 01       	movw	r30, r18
    8934:	01 90       	ld	r0, Z+
    8936:	00 20       	and	r0, r0
    8938:	e9 f7       	brne	.-6      	; 0x8934 <convertFileName+0x6c>
    893a:	cf 01       	movw	r24, r30
    893c:	01 97       	sbiw	r24, 0x01	; 1
    893e:	82 1b       	sub	r24, r18
    8940:	93 0b       	sbc	r25, r19
    8942:	48 17       	cp	r20, r24
    8944:	59 07       	cpc	r21, r25
    8946:	e8 f2       	brcs	.-70     	; 0x8902 <convertFileName+0x3a>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';
    8948:	0c c0       	rjmp	.+24     	; 0x8962 <convertFileName+0x9a>
    894a:	8c 81       	ldd	r24, Y+4	; 0x04
    894c:	9d 81       	ldd	r25, Y+5	; 0x05
    894e:	84 54       	subi	r24, 0x44	; 68
    8950:	9f 4a       	sbci	r25, 0xAF	; 175
    8952:	20 e2       	ldi	r18, 0x20	; 32
    8954:	fc 01       	movw	r30, r24
    8956:	20 83       	st	Z, r18
    8958:	8c 81       	ldd	r24, Y+4	; 0x04
    895a:	9d 81       	ldd	r25, Y+5	; 0x05
    895c:	01 96       	adiw	r24, 0x01	; 1
    895e:	8c 83       	std	Y+4, r24	; 0x04
    8960:	9d 83       	std	Y+5, r25	; 0x05
    8962:	8c 81       	ldd	r24, Y+4	; 0x04
    8964:	9d 81       	ldd	r25, Y+5	; 0x05
    8966:	8f 30       	cpi	r24, 0x0F	; 15
    8968:	91 05       	cpc	r25, r1
    896a:	7c f3       	brlt	.-34     	; 0x894a <convertFileName+0x82>


for(j=0; j<12; j++)
    896c:	1a 82       	std	Y+2, r1	; 0x02
    896e:	0c c0       	rjmp	.+24     	; 0x8988 <convertFileName+0xc0>
if(Filename[j] == '.') break;
    8970:	8a 81       	ldd	r24, Y+2	; 0x02
    8972:	88 2f       	mov	r24, r24
    8974:	90 e0       	ldi	r25, 0x00	; 0
    8976:	84 54       	subi	r24, 0x44	; 68
    8978:	9f 4a       	sbci	r25, 0xAF	; 175
    897a:	fc 01       	movw	r30, r24
    897c:	80 81       	ld	r24, Z
    897e:	8e 32       	cpi	r24, 0x2E	; 46
    8980:	39 f0       	breq	.+14     	; 0x8990 <convertFileName+0xc8>
	Filename[i] = fileName[i];
}
for(; i < 15; i++) Filename[i] = ' ';


for(j=0; j<12; j++)
    8982:	8a 81       	ldd	r24, Y+2	; 0x02
    8984:	8f 5f       	subi	r24, 0xFF	; 255
    8986:	8a 83       	std	Y+2, r24	; 0x02
    8988:	8a 81       	ldd	r24, Y+2	; 0x02
    898a:	8c 30       	cpi	r24, 0x0C	; 12
    898c:	88 f3       	brcs	.-30     	; 0x8970 <convertFileName+0xa8>
    898e:	01 c0       	rjmp	.+2      	; 0x8992 <convertFileName+0xca>
if(Filename[j] == '.') break;
    8990:	00 00       	nop

if(j>8 && j<12) {//Invalid fileName
    8992:	8a 81       	ldd	r24, Y+2	; 0x02
    8994:	89 30       	cpi	r24, 0x09	; 9
    8996:	28 f0       	brcs	.+10     	; 0x89a2 <convertFileName+0xda>
    8998:	8a 81       	ldd	r24, Y+2	; 0x02
    899a:	8c 30       	cpi	r24, 0x0C	; 12
    899c:	10 f4       	brcc	.+4      	; 0x89a2 <convertFileName+0xda>
	return 1;}
    899e:	81 e0       	ldi	r24, 0x01	; 1
    89a0:	c3 c0       	rjmp	.+390    	; 0x8b28 <convertFileName+0x260>
else if (j==12) NoExtension=TRUE;	
    89a2:	8a 81       	ldd	r24, Y+2	; 0x02
    89a4:	8c 30       	cpi	r24, 0x0C	; 12
    89a6:	11 f4       	brne	.+4      	; 0x89ac <convertFileName+0xe4>
    89a8:	81 e0       	ldi	r24, 0x01	; 1
    89aa:	89 83       	std	Y+1, r24	; 0x01

for(k=0; k<j; k++) //setting file name
    89ac:	1b 82       	std	Y+3, r1	; 0x03
    89ae:	14 c0       	rjmp	.+40     	; 0x89d8 <convertFileName+0x110>
  fileNameFAT[k] = Filename[k];
    89b0:	8b 81       	ldd	r24, Y+3	; 0x03
    89b2:	88 2f       	mov	r24, r24
    89b4:	90 e0       	ldi	r25, 0x00	; 0
    89b6:	2b 81       	ldd	r18, Y+3	; 0x03
    89b8:	22 2f       	mov	r18, r18
    89ba:	30 e0       	ldi	r19, 0x00	; 0
    89bc:	24 54       	subi	r18, 0x44	; 68
    89be:	3f 4a       	sbci	r19, 0xAF	; 175
    89c0:	f9 01       	movw	r30, r18
    89c2:	40 81       	ld	r20, Z
    89c4:	9e 01       	movw	r18, r28
    89c6:	2a 5f       	subi	r18, 0xFA	; 250
    89c8:	3f 4f       	sbci	r19, 0xFF	; 255
    89ca:	82 0f       	add	r24, r18
    89cc:	93 1f       	adc	r25, r19
    89ce:	fc 01       	movw	r30, r24
    89d0:	40 83       	st	Z, r20

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    89d2:	8b 81       	ldd	r24, Y+3	; 0x03
    89d4:	8f 5f       	subi	r24, 0xFF	; 255
    89d6:	8b 83       	std	Y+3, r24	; 0x03
    89d8:	9b 81       	ldd	r25, Y+3	; 0x03
    89da:	8a 81       	ldd	r24, Y+2	; 0x02
    89dc:	98 17       	cp	r25, r24
    89de:	40 f3       	brcs	.-48     	; 0x89b0 <convertFileName+0xe8>
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    89e0:	8a 81       	ldd	r24, Y+2	; 0x02
    89e2:	8b 83       	std	Y+3, r24	; 0x03
    89e4:	0e c0       	rjmp	.+28     	; 0x8a02 <convertFileName+0x13a>
  fileNameFAT[k] = ' ';
    89e6:	8b 81       	ldd	r24, Y+3	; 0x03
    89e8:	88 2f       	mov	r24, r24
    89ea:	90 e0       	ldi	r25, 0x00	; 0
    89ec:	9e 01       	movw	r18, r28
    89ee:	2a 5f       	subi	r18, 0xFA	; 250
    89f0:	3f 4f       	sbci	r19, 0xFF	; 255
    89f2:	82 0f       	add	r24, r18
    89f4:	93 1f       	adc	r25, r19
    89f6:	20 e2       	ldi	r18, 0x20	; 32
    89f8:	fc 01       	movw	r30, r24
    89fa:	20 83       	st	Z, r18
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = Filename[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    89fc:	8b 81       	ldd	r24, Y+3	; 0x03
    89fe:	8f 5f       	subi	r24, 0xFF	; 255
    8a00:	8b 83       	std	Y+3, r24	; 0x03
    8a02:	8b 81       	ldd	r24, Y+3	; 0x03
    8a04:	88 30       	cpi	r24, 0x08	; 8
    8a06:	78 f3       	brcs	.-34     	; 0x89e6 <convertFileName+0x11e>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    8a08:	99 81       	ldd	r25, Y+1	; 0x01
    8a0a:	81 e0       	ldi	r24, 0x01	; 1
    8a0c:	89 27       	eor	r24, r25
    8a0e:	88 23       	and	r24, r24
    8a10:	19 f0       	breq	.+6      	; 0x8a18 <convertFileName+0x150>
    8a12:	8a 81       	ldd	r24, Y+2	; 0x02
    8a14:	8f 5f       	subi	r24, 0xFF	; 255
    8a16:	8a 83       	std	Y+2, r24	; 0x02
for(k=8; k<11; k++) //setting file extension
    8a18:	88 e0       	ldi	r24, 0x08	; 8
    8a1a:	8b 83       	std	Y+3, r24	; 0x03
    8a1c:	32 c0       	rjmp	.+100    	; 0x8a82 <convertFileName+0x1ba>
{
  if(Filename[j] != 0)
    8a1e:	8a 81       	ldd	r24, Y+2	; 0x02
    8a20:	88 2f       	mov	r24, r24
    8a22:	90 e0       	ldi	r25, 0x00	; 0
    8a24:	84 54       	subi	r24, 0x44	; 68
    8a26:	9f 4a       	sbci	r25, 0xAF	; 175
    8a28:	fc 01       	movw	r30, r24
    8a2a:	80 81       	ld	r24, Z
    8a2c:	88 23       	and	r24, r24
    8a2e:	19 f1       	breq	.+70     	; 0x8a76 <convertFileName+0x1ae>
    fileNameFAT[k] = Filename[j++];
    8a30:	8b 81       	ldd	r24, Y+3	; 0x03
    8a32:	88 2f       	mov	r24, r24
    8a34:	90 e0       	ldi	r25, 0x00	; 0
    8a36:	2a 81       	ldd	r18, Y+2	; 0x02
    8a38:	22 2f       	mov	r18, r18
    8a3a:	30 e0       	ldi	r19, 0x00	; 0
    8a3c:	24 54       	subi	r18, 0x44	; 68
    8a3e:	3f 4a       	sbci	r19, 0xAF	; 175
    8a40:	f9 01       	movw	r30, r18
    8a42:	40 81       	ld	r20, Z
    8a44:	9e 01       	movw	r18, r28
    8a46:	2a 5f       	subi	r18, 0xFA	; 250
    8a48:	3f 4f       	sbci	r19, 0xFF	; 255
    8a4a:	82 0f       	add	r24, r18
    8a4c:	93 1f       	adc	r25, r19
    8a4e:	fc 01       	movw	r30, r24
    8a50:	40 83       	st	Z, r20
    8a52:	8a 81       	ldd	r24, Y+2	; 0x02
    8a54:	8f 5f       	subi	r24, 0xFF	; 255
    8a56:	8a 83       	std	Y+2, r24	; 0x02
    8a58:	11 c0       	rjmp	.+34     	; 0x8a7c <convertFileName+0x1b4>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    8a5a:	8b 81       	ldd	r24, Y+3	; 0x03
    8a5c:	88 2f       	mov	r24, r24
    8a5e:	90 e0       	ldi	r25, 0x00	; 0
    8a60:	9e 01       	movw	r18, r28
    8a62:	2a 5f       	subi	r18, 0xFA	; 250
    8a64:	3f 4f       	sbci	r19, 0xFF	; 255
    8a66:	82 0f       	add	r24, r18
    8a68:	93 1f       	adc	r25, r19
    8a6a:	20 e2       	ldi	r18, 0x20	; 32
    8a6c:	fc 01       	movw	r30, r24
    8a6e:	20 83       	st	Z, r18
    8a70:	8b 81       	ldd	r24, Y+3	; 0x03
    8a72:	8f 5f       	subi	r24, 0xFF	; 255
    8a74:	8b 83       	std	Y+3, r24	; 0x03
for(k=8; k<11; k++) //setting file extension
{
  if(Filename[j] != 0)
    fileNameFAT[k] = Filename[j++];
  else //filling extension trail with blanks
    while(k<11)
    8a76:	8b 81       	ldd	r24, Y+3	; 0x03
    8a78:	8b 30       	cpi	r24, 0x0B	; 11
    8a7a:	78 f3       	brcs	.-34     	; 0x8a5a <convertFileName+0x192>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    8a7c:	8b 81       	ldd	r24, Y+3	; 0x03
    8a7e:	8f 5f       	subi	r24, 0xFF	; 255
    8a80:	8b 83       	std	Y+3, r24	; 0x03
    8a82:	8b 81       	ldd	r24, Y+3	; 0x03
    8a84:	8b 30       	cpi	r24, 0x0B	; 11
    8a86:	58 f2       	brcs	.-106    	; 0x8a1e <convertFileName+0x156>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8a88:	1a 82       	std	Y+2, r1	; 0x02
    8a8a:	31 c0       	rjmp	.+98     	; 0x8aee <convertFileName+0x226>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    8a8c:	8a 81       	ldd	r24, Y+2	; 0x02
    8a8e:	88 2f       	mov	r24, r24
    8a90:	90 e0       	ldi	r25, 0x00	; 0
    8a92:	9e 01       	movw	r18, r28
    8a94:	2a 5f       	subi	r18, 0xFA	; 250
    8a96:	3f 4f       	sbci	r19, 0xFF	; 255
    8a98:	82 0f       	add	r24, r18
    8a9a:	93 1f       	adc	r25, r19
    8a9c:	fc 01       	movw	r30, r24
    8a9e:	80 81       	ld	r24, Z
    8aa0:	81 36       	cpi	r24, 0x61	; 97
    8aa2:	10 f1       	brcs	.+68     	; 0x8ae8 <convertFileName+0x220>
    8aa4:	8a 81       	ldd	r24, Y+2	; 0x02
    8aa6:	88 2f       	mov	r24, r24
    8aa8:	90 e0       	ldi	r25, 0x00	; 0
    8aaa:	9e 01       	movw	r18, r28
    8aac:	2a 5f       	subi	r18, 0xFA	; 250
    8aae:	3f 4f       	sbci	r19, 0xFF	; 255
    8ab0:	82 0f       	add	r24, r18
    8ab2:	93 1f       	adc	r25, r19
    8ab4:	fc 01       	movw	r30, r24
    8ab6:	80 81       	ld	r24, Z
    8ab8:	8b 37       	cpi	r24, 0x7B	; 123
    8aba:	b0 f4       	brcc	.+44     	; 0x8ae8 <convertFileName+0x220>
    fileNameFAT[j] -= 0x20;
    8abc:	8a 81       	ldd	r24, Y+2	; 0x02
    8abe:	88 2f       	mov	r24, r24
    8ac0:	90 e0       	ldi	r25, 0x00	; 0
    8ac2:	2a 81       	ldd	r18, Y+2	; 0x02
    8ac4:	22 2f       	mov	r18, r18
    8ac6:	30 e0       	ldi	r19, 0x00	; 0
    8ac8:	ae 01       	movw	r20, r28
    8aca:	4a 5f       	subi	r20, 0xFA	; 250
    8acc:	5f 4f       	sbci	r21, 0xFF	; 255
    8ace:	24 0f       	add	r18, r20
    8ad0:	35 1f       	adc	r19, r21
    8ad2:	f9 01       	movw	r30, r18
    8ad4:	20 81       	ld	r18, Z
    8ad6:	42 2f       	mov	r20, r18
    8ad8:	40 52       	subi	r20, 0x20	; 32
    8ada:	9e 01       	movw	r18, r28
    8adc:	2a 5f       	subi	r18, 0xFA	; 250
    8ade:	3f 4f       	sbci	r19, 0xFF	; 255
    8ae0:	82 0f       	add	r24, r18
    8ae2:	93 1f       	adc	r25, r19
    8ae4:	fc 01       	movw	r30, r24
    8ae6:	40 83       	st	Z, r20
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    8ae8:	8a 81       	ldd	r24, Y+2	; 0x02
    8aea:	8f 5f       	subi	r24, 0xFF	; 255
    8aec:	8a 83       	std	Y+2, r24	; 0x02
    8aee:	8a 81       	ldd	r24, Y+2	; 0x02
    8af0:	8b 30       	cpi	r24, 0x0B	; 11
    8af2:	60 f2       	brcs	.-104    	; 0x8a8c <convertFileName+0x1c4>
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8af4:	1a 82       	std	Y+2, r1	; 0x02
    8af6:	14 c0       	rjmp	.+40     	; 0x8b20 <convertFileName+0x258>
  Filename[j] = fileNameFAT[j];
    8af8:	8a 81       	ldd	r24, Y+2	; 0x02
    8afa:	88 2f       	mov	r24, r24
    8afc:	90 e0       	ldi	r25, 0x00	; 0
    8afe:	2a 81       	ldd	r18, Y+2	; 0x02
    8b00:	22 2f       	mov	r18, r18
    8b02:	30 e0       	ldi	r19, 0x00	; 0
    8b04:	ae 01       	movw	r20, r28
    8b06:	4a 5f       	subi	r20, 0xFA	; 250
    8b08:	5f 4f       	sbci	r21, 0xFF	; 255
    8b0a:	24 0f       	add	r18, r20
    8b0c:	35 1f       	adc	r19, r21
    8b0e:	f9 01       	movw	r30, r18
    8b10:	20 81       	ld	r18, Z
    8b12:	84 54       	subi	r24, 0x44	; 68
    8b14:	9f 4a       	sbci	r25, 0xAF	; 175
    8b16:	fc 01       	movw	r30, r24
    8b18:	20 83       	st	Z, r18

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    8b1a:	8a 81       	ldd	r24, Y+2	; 0x02
    8b1c:	8f 5f       	subi	r24, 0xFF	; 255
    8b1e:	8a 83       	std	Y+2, r24	; 0x02
    8b20:	8a 81       	ldd	r24, Y+2	; 0x02
    8b22:	8b 30       	cpi	r24, 0x0B	; 11
    8b24:	48 f3       	brcs	.-46     	; 0x8af8 <convertFileName+0x230>
  Filename[j] = fileNameFAT[j];

return 0;
    8b26:	80 e0       	ldi	r24, 0x00	; 0
}
    8b28:	62 96       	adiw	r28, 0x12	; 18
    8b2a:	cd bf       	out	0x3d, r28	; 61
    8b2c:	de bf       	out	0x3e, r29	; 62
    8b2e:	df 91       	pop	r29
    8b30:	cf 91       	pop	r28
    8b32:	08 95       	ret

00008b34 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName,uint8_t* dataArray,uint32_t lengthOfData){
    8b34:	ef 92       	push	r14
    8b36:	ff 92       	push	r15
    8b38:	0f 93       	push	r16
    8b3a:	1f 93       	push	r17
    8b3c:	cf 93       	push	r28
    8b3e:	df 93       	push	r29
    8b40:	cd b7       	in	r28, 0x3d	; 61
    8b42:	de b7       	in	r29, 0x3e	; 62
    8b44:	e7 97       	sbiw	r28, 0x37	; 55
    8b46:	cd bf       	out	0x3d, r28	; 61
    8b48:	de bf       	out	0x3e, r29	; 62
    8b4a:	88 ab       	sts	0x58, r24
    8b4c:	99 ab       	sts	0x59, r25
    8b4e:	6a ab       	sts	0x5a, r22
    8b50:	7b ab       	sts	0x5b, r23
    8b52:	2c ab       	sts	0x5c, r18
    8b54:	3d ab       	sts	0x5d, r19
    8b56:	4e ab       	sts	0x5e, r20
    8b58:	5f ab       	sts	0x5f, r21
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    8b5a:	1a 82       	std	Y+2, r1	; 0x02
    8b5c:	1b 82       	std	Y+3, r1	; 0x03
    8b5e:	1c 82       	std	Y+4, r1	; 0x04
    8b60:	1d 82       	std	Y+5, r1	; 0x05
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    8b62:	1e 82       	std	Y+6, r1	; 0x06
    8b64:	1f 82       	std	Y+7, r1	; 0x07
    8b66:	18 86       	std	Y+8, r1	; 0x08
    8b68:	19 86       	std	Y+9, r1	; 0x09
    8b6a:	1a 86       	std	Y+10, r1	; 0x0a
    8b6c:	1b 86       	std	Y+11, r1	; 0x0b
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;


j = readFile (VERIFY, fileName);
    8b6e:	28 a9       	sts	0x48, r18
    8b70:	39 a9       	sts	0x49, r19
    8b72:	81 e0       	ldi	r24, 0x01	; 1
    8b74:	b9 01       	movw	r22, r18
    8b76:	0e 94 b5 43 	call	0x876a	; 0x876a <readFile>
    8b7a:	89 83       	std	Y+1, r24	; 0x01

if(j == 1) 
    8b7c:	89 81       	ldd	r24, Y+1	; 0x01
    8b7e:	81 30       	cpi	r24, 0x01	; 1
    8b80:	09 f0       	breq	.+2      	; 0x8b84 <writeFile+0x50>
    8b82:	84 c0       	rjmp	.+264    	; 0x8c8c <writeFile+0x158>
{
  //File already exists, appending data
  appendFile = 1;
    8b84:	81 e0       	ldi	r24, 0x01	; 1
    8b86:	8c 83       	std	Y+4, r24	; 0x04
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    8b88:	80 91 88 50 	lds	r24, 0x5088
    8b8c:	90 91 89 50 	lds	r25, 0x5089
    8b90:	a0 91 8a 50 	lds	r26, 0x508A
    8b94:	b0 91 8b 50 	lds	r27, 0x508B
    8b98:	8c 87       	std	Y+12, r24	; 0x0c
    8b9a:	9d 87       	std	Y+13, r25	; 0x0d
    8b9c:	ae 87       	std	Y+14, r26	; 0x0e
    8b9e:	bf 87       	std	Y+15, r27	; 0x0f
  clusterCount=0;
    8ba0:	1c 8a       	std	Y+20, r1	; 0x14
    8ba2:	1d 8a       	std	Y+21, r1	; 0x15
    8ba4:	1e 8a       	std	Y+22, r1	; 0x16
    8ba6:	1f 8a       	std	Y+23, r1	; 0x17
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    8ba8:	8c 85       	ldd	r24, Y+12	; 0x0c
    8baa:	9d 85       	ldd	r25, Y+13	; 0x0d
    8bac:	ae 85       	ldd	r26, Y+14	; 0x0e
    8bae:	bf 85       	ldd	r27, Y+15	; 0x0f
    8bb0:	bc 01       	movw	r22, r24
    8bb2:	cd 01       	movw	r24, r26
    8bb4:	40 e0       	ldi	r20, 0x00	; 0
    8bb6:	00 e0       	ldi	r16, 0x00	; 0
    8bb8:	10 e0       	ldi	r17, 0x00	; 0
    8bba:	98 01       	movw	r18, r16
    8bbc:	0e 94 80 40 	call	0x8100	; 0x8100 <getSetNextCluster>
    8bc0:	dc 01       	movw	r26, r24
    8bc2:	cb 01       	movw	r24, r22
    8bc4:	8a a3       	lds	r24, 0x5a
    8bc6:	9b a3       	lds	r25, 0x5b
    8bc8:	ac a3       	lds	r26, 0x5c
    8bca:	bd a3       	lds	r27, 0x5d
    if(nextCluster == EOF) break;
    8bcc:	8a a1       	lds	r24, 0x4a
    8bce:	9b a1       	lds	r25, 0x4b
    8bd0:	ac a1       	lds	r26, 0x4c
    8bd2:	bd a1       	lds	r27, 0x4d
    8bd4:	8f 3f       	cpi	r24, 0xFF	; 255
    8bd6:	0f ef       	ldi	r16, 0xFF	; 255
    8bd8:	90 07       	cpc	r25, r16
    8bda:	0f ef       	ldi	r16, 0xFF	; 255
    8bdc:	a0 07       	cpc	r26, r16
    8bde:	0f e0       	ldi	r16, 0x0F	; 15
    8be0:	b0 07       	cpc	r27, r16
    8be2:	a1 f0       	breq	.+40     	; 0x8c0c <writeFile+0xd8>
	cluster = nextCluster;
    8be4:	8a a1       	lds	r24, 0x4a
    8be6:	9b a1       	lds	r25, 0x4b
    8be8:	ac a1       	lds	r26, 0x4c
    8bea:	bd a1       	lds	r27, 0x4d
    8bec:	8c 87       	std	Y+12, r24	; 0x0c
    8bee:	9d 87       	std	Y+13, r25	; 0x0d
    8bf0:	ae 87       	std	Y+14, r26	; 0x0e
    8bf2:	bf 87       	std	Y+15, r27	; 0x0f
	clusterCount++;
    8bf4:	8c 89       	ldd	r24, Y+20	; 0x14
    8bf6:	9d 89       	ldd	r25, Y+21	; 0x15
    8bf8:	ae 89       	ldd	r26, Y+22	; 0x16
    8bfa:	bf 89       	ldd	r27, Y+23	; 0x17
    8bfc:	01 96       	adiw	r24, 0x01	; 1
    8bfe:	a1 1d       	adc	r26, r1
    8c00:	b1 1d       	adc	r27, r1
    8c02:	8c 8b       	std	Y+20, r24	; 0x14
    8c04:	9d 8b       	std	Y+21, r25	; 0x15
    8c06:	ae 8b       	std	Y+22, r26	; 0x16
    8c08:	bf 8b       	std	Y+23, r27	; 0x17
  }
    8c0a:	ce cf       	rjmp	.-100    	; 0x8ba8 <writeFile+0x74>
  clusterCount=0;
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
    8c0c:	00 00       	nop
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    8c0e:	e0 90 49 40 	lds	r14, 0x4049
    8c12:	f0 90 4a 40 	lds	r15, 0x404A
    8c16:	00 91 4b 40 	lds	r16, 0x404B
    8c1a:	10 91 4c 40 	lds	r17, 0x404C
    8c1e:	80 91 7c 50 	lds	r24, 0x507C
    8c22:	90 91 7d 50 	lds	r25, 0x507D
    8c26:	cc 01       	movw	r24, r24
    8c28:	a0 e0       	ldi	r26, 0x00	; 0
    8c2a:	b0 e0       	ldi	r27, 0x00	; 0
    8c2c:	2c 89       	ldd	r18, Y+20	; 0x14
    8c2e:	3d 89       	ldd	r19, Y+21	; 0x15
    8c30:	4e 89       	ldd	r20, Y+22	; 0x16
    8c32:	5f 89       	ldd	r21, Y+23	; 0x17
    8c34:	bc 01       	movw	r22, r24
    8c36:	cd 01       	movw	r24, r26
    8c38:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    8c3c:	dc 01       	movw	r26, r24
    8c3e:	cb 01       	movw	r24, r22
    8c40:	20 91 4d 40 	lds	r18, 0x404D
    8c44:	30 91 4e 40 	lds	r19, 0x404E
    8c48:	99 01       	movw	r18, r18
    8c4a:	40 e0       	ldi	r20, 0x00	; 0
    8c4c:	50 e0       	ldi	r21, 0x00	; 0
    8c4e:	bc 01       	movw	r22, r24
    8c50:	cd 01       	movw	r24, r26
    8c52:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    8c56:	dc 01       	movw	r26, r24
    8c58:	cb 01       	movw	r24, r22
    8c5a:	a8 01       	movw	r20, r16
    8c5c:	97 01       	movw	r18, r14
    8c5e:	28 1b       	sub	r18, r24
    8c60:	39 0b       	sbc	r19, r25
    8c62:	4a 0b       	sbc	r20, r26
    8c64:	5b 0b       	sbc	r21, r27
    8c66:	da 01       	movw	r26, r20
    8c68:	c9 01       	movw	r24, r18
    8c6a:	20 91 4d 40 	lds	r18, 0x404D
    8c6e:	30 91 4e 40 	lds	r19, 0x404E
    8c72:	99 01       	movw	r18, r18
    8c74:	40 e0       	ldi	r20, 0x00	; 0
    8c76:	50 e0       	ldi	r21, 0x00	; 0
    8c78:	bc 01       	movw	r22, r24
    8c7a:	cd 01       	movw	r24, r26
    8c7c:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    8c80:	da 01       	movw	r26, r20
    8c82:	c9 01       	movw	r24, r18
    8c84:	8d 83       	std	Y+5, r24	; 0x05
  start = 1;
    8c86:	81 e0       	ldi	r24, 0x01	; 1
    8c88:	8b 83       	std	Y+3, r24	; 0x03
    8c8a:	69 c0       	rjmp	.+210    	; 0x8d5e <writeFile+0x22a>
}
else if(j == 2) 
    8c8c:	89 81       	ldd	r24, Y+1	; 0x01
    8c8e:	82 30       	cpi	r24, 0x02	; 2
    8c90:	11 f4       	brne	.+4      	; 0x8c96 <writeFile+0x162>
   return 1; //invalid file name
    8c92:	81 e0       	ldi	r24, 0x01	; 1
    8c94:	1b c3       	rjmp	.+1590   	; 0x92cc <writeFile+0x798>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    8c96:	82 e0       	ldi	r24, 0x02	; 2
    8c98:	60 e0       	ldi	r22, 0x00	; 0
    8c9a:	20 e0       	ldi	r18, 0x00	; 0
    8c9c:	30 e0       	ldi	r19, 0x00	; 0
    8c9e:	a9 01       	movw	r20, r18
    8ca0:	0e 94 2a 41 	call	0x8254	; 0x8254 <getSetFreeCluster>
    8ca4:	dc 01       	movw	r26, r24
    8ca6:	cb 01       	movw	r24, r22
    8ca8:	8c 87       	std	Y+12, r24	; 0x0c
    8caa:	9d 87       	std	Y+13, r25	; 0x0d
    8cac:	ae 87       	std	Y+14, r26	; 0x0e
    8cae:	bf 87       	std	Y+15, r27	; 0x0f
  if(cluster > totalClusters)
    8cb0:	80 91 5a 40 	lds	r24, 0x405A
    8cb4:	90 91 5b 40 	lds	r25, 0x405B
    8cb8:	a0 91 5c 40 	lds	r26, 0x405C
    8cbc:	b0 91 5d 40 	lds	r27, 0x405D
    8cc0:	2c 85       	ldd	r18, Y+12	; 0x0c
    8cc2:	3d 85       	ldd	r19, Y+13	; 0x0d
    8cc4:	4e 85       	ldd	r20, Y+14	; 0x0e
    8cc6:	5f 85       	ldd	r21, Y+15	; 0x0f
    8cc8:	82 17       	cp	r24, r18
    8cca:	93 07       	cpc	r25, r19
    8ccc:	a4 07       	cpc	r26, r20
    8cce:	b5 07       	cpc	r27, r21
    8cd0:	60 f4       	brcc	.+24     	; 0x8cea <writeFile+0x1b6>
     cluster = rootCluster;
    8cd2:	80 91 60 40 	lds	r24, 0x4060
    8cd6:	90 91 61 40 	lds	r25, 0x4061
    8cda:	a0 91 62 40 	lds	r26, 0x4062
    8cde:	b0 91 63 40 	lds	r27, 0x4063
    8ce2:	8c 87       	std	Y+12, r24	; 0x0c
    8ce4:	9d 87       	std	Y+13, r25	; 0x0d
    8ce6:	ae 87       	std	Y+14, r26	; 0x0e
    8ce8:	bf 87       	std	Y+15, r27	; 0x0f

  cluster = searchNextFreeCluster(cluster);
    8cea:	8c 85       	ldd	r24, Y+12	; 0x0c
    8cec:	9d 85       	ldd	r25, Y+13	; 0x0d
    8cee:	ae 85       	ldd	r26, Y+14	; 0x0e
    8cf0:	bf 85       	ldd	r27, Y+15	; 0x0f
    8cf2:	bc 01       	movw	r22, r24
    8cf4:	cd 01       	movw	r24, r26
    8cf6:	0e 94 70 49 	call	0x92e0	; 0x92e0 <searchNextFreeCluster>
    8cfa:	dc 01       	movw	r26, r24
    8cfc:	cb 01       	movw	r24, r22
    8cfe:	8c 87       	std	Y+12, r24	; 0x0c
    8d00:	9d 87       	std	Y+13, r25	; 0x0d
    8d02:	ae 87       	std	Y+14, r26	; 0x0e
    8d04:	bf 87       	std	Y+15, r27	; 0x0f
   if(cluster == 0)
    8d06:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d08:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d0a:	ae 85       	ldd	r26, Y+14	; 0x0e
    8d0c:	bf 85       	ldd	r27, Y+15	; 0x0f
    8d0e:	00 97       	sbiw	r24, 0x00	; 0
    8d10:	a1 05       	cpc	r26, r1
    8d12:	b1 05       	cpc	r27, r1
    8d14:	11 f4       	brne	.+4      	; 0x8d1a <writeFile+0x1e6>
   {
	   // No free cluster!
	  return 2;
    8d16:	82 e0       	ldi	r24, 0x02	; 2
    8d18:	d9 c2       	rjmp	.+1458   	; 0x92cc <writeFile+0x798>
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    8d1a:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d1c:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d1e:	ae 85       	ldd	r26, Y+14	; 0x0e
    8d20:	bf 85       	ldd	r27, Y+15	; 0x0f
    8d22:	bc 01       	movw	r22, r24
    8d24:	cd 01       	movw	r24, r26
    8d26:	41 e0       	ldi	r20, 0x01	; 1
    8d28:	0f ef       	ldi	r16, 0xFF	; 255
    8d2a:	1f ef       	ldi	r17, 0xFF	; 255
    8d2c:	2f ef       	ldi	r18, 0xFF	; 255
    8d2e:	3f e0       	ldi	r19, 0x0F	; 15
    8d30:	0e 94 80 40 	call	0x8100	; 0x8100 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    8d34:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d36:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d38:	ae 85       	ldd	r26, Y+14	; 0x0e
    8d3a:	bf 85       	ldd	r27, Y+15	; 0x0f
    8d3c:	cd 01       	movw	r24, r26
    8d3e:	aa 27       	eor	r26, r26
    8d40:	bb 27       	eor	r27, r27
    8d42:	8e 83       	std	Y+6, r24	; 0x06
    8d44:	9f 83       	std	Y+7, r25	; 0x07
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    8d46:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d48:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d4a:	88 87       	std	Y+8, r24	; 0x08
    8d4c:	99 87       	std	Y+9, r25	; 0x09
  fileSize = 0;
    8d4e:	10 92 49 40 	sts	0x4049, r1
    8d52:	10 92 4a 40 	sts	0x404A, r1
    8d56:	10 92 4b 40 	sts	0x404B, r1
    8d5a:	10 92 4c 40 	sts	0x404C, r1
}

//start writing data here

if(start){
    8d5e:	8b 81       	ldd	r24, Y+3	; 0x03
    8d60:	88 23       	and	r24, r24
    8d62:	11 f1       	breq	.+68     	; 0x8da8 <writeFile+0x274>
  start = 0;
    8d64:	1b 82       	std	Y+3, r1	; 0x03
  startBlock = getFirstSector (cluster) + sector;
    8d66:	8c 85       	ldd	r24, Y+12	; 0x0c
    8d68:	9d 85       	ldd	r25, Y+13	; 0x0d
    8d6a:	ae 85       	ldd	r26, Y+14	; 0x0e
    8d6c:	bf 85       	ldd	r27, Y+15	; 0x0f
    8d6e:	bc 01       	movw	r22, r24
    8d70:	cd 01       	movw	r24, r26
    8d72:	0e 94 4e 40 	call	0x809c	; 0x809c <getFirstSector>
    8d76:	dc 01       	movw	r26, r24
    8d78:	cb 01       	movw	r24, r22
    8d7a:	9c 01       	movw	r18, r24
    8d7c:	8d 81       	ldd	r24, Y+5	; 0x05
    8d7e:	88 2f       	mov	r24, r24
    8d80:	90 e0       	ldi	r25, 0x00	; 0
    8d82:	82 0f       	add	r24, r18
    8d84:	93 1f       	adc	r25, r19
    8d86:	8a 87       	std	Y+10, r24	; 0x0a
    8d88:	9b 87       	std	Y+11, r25	; 0x0b
  SD_read_block (startBlock,SDBuffer);
    8d8a:	8a 85       	ldd	r24, Y+10	; 0x0a
    8d8c:	9b 85       	ldd	r25, Y+11	; 0x0b
    8d8e:	cc 01       	movw	r24, r24
    8d90:	a0 e0       	ldi	r26, 0x00	; 0
    8d92:	b0 e0       	ldi	r27, 0x00	; 0
    8d94:	2f ec       	ldi	r18, 0xCF	; 207
    8d96:	31 e2       	ldi	r19, 0x21	; 33
    8d98:	bc 01       	movw	r22, r24
    8d9a:	cd 01       	movw	r24, r26
    8d9c:	a9 01       	movw	r20, r18
    8d9e:	0e 94 7a 4e 	call	0x9cf4	; 0x9cf4 <SD_read_block>
  j = sector;
    8da2:	8d 81       	ldd	r24, Y+5	; 0x05
    8da4:	89 83       	std	Y+1, r24	; 0x01
    8da6:	0d c0       	rjmp	.+26     	; 0x8dc2 <writeFile+0x28e>
}
else{
  startBlock = getFirstSector (cluster);
    8da8:	8c 85       	ldd	r24, Y+12	; 0x0c
    8daa:	9d 85       	ldd	r25, Y+13	; 0x0d
    8dac:	ae 85       	ldd	r26, Y+14	; 0x0e
    8dae:	bf 85       	ldd	r27, Y+15	; 0x0f
    8db0:	bc 01       	movw	r22, r24
    8db2:	cd 01       	movw	r24, r26
    8db4:	0e 94 4e 40 	call	0x809c	; 0x809c <getFirstSector>
    8db8:	dc 01       	movw	r26, r24
    8dba:	cb 01       	movw	r24, r22
    8dbc:	8a 87       	std	Y+10, r24	; 0x0a
    8dbe:	9b 87       	std	Y+11, r25	; 0x0b
  j=0;
    8dc0:	19 82       	std	Y+1, r1	; 0x01
}
uint32_t writtenData = 0;
    8dc2:	18 8e       	std	Y+24, r1	; 0x18
    8dc4:	19 8e       	std	Y+25, r1	; 0x19
    8dc6:	1a 8e       	std	Y+26, r1	; 0x1a
    8dc8:	1b 8e       	std	Y+27, r1	; 0x1b
uint32_t dataToWrite = 0;
    8dca:	1c 8e       	std	Y+28, r1	; 0x1c
    8dcc:	1d 8e       	std	Y+29, r1	; 0x1d
    8dce:	1e 8e       	std	Y+30, r1	; 0x1e
    8dd0:	1f 8e       	std	Y+31, r1	; 0x1f
while(lengthOfData!=0){
    8dd2:	cd c0       	rjmp	.+410    	; 0x8f6e <writeFile+0x43a>
	//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes
	if(lengthOfData >= 512 ){
    8dd4:	8c a9       	sts	0x4c, r24
    8dd6:	9d a9       	sts	0x4d, r25
    8dd8:	ae a9       	sts	0x4e, r26
    8dda:	bf a9       	sts	0x4f, r27
    8ddc:	80 30       	cpi	r24, 0x00	; 0
    8dde:	32 e0       	ldi	r19, 0x02	; 2
    8de0:	93 07       	cpc	r25, r19
    8de2:	30 e0       	ldi	r19, 0x00	; 0
    8de4:	a3 07       	cpc	r26, r19
    8de6:	30 e0       	ldi	r19, 0x00	; 0
    8de8:	b3 07       	cpc	r27, r19
    8dea:	08 f1       	brcs	.+66     	; 0x8e2e <writeFile+0x2fa>
		 writtenData += 512;
    8dec:	88 8d       	ldd	r24, Y+24	; 0x18
    8dee:	99 8d       	ldd	r25, Y+25	; 0x19
    8df0:	aa 8d       	ldd	r26, Y+26	; 0x1a
    8df2:	bb 8d       	ldd	r27, Y+27	; 0x1b
    8df4:	80 50       	subi	r24, 0x00	; 0
    8df6:	9e 4f       	sbci	r25, 0xFE	; 254
    8df8:	af 4f       	sbci	r26, 0xFF	; 255
    8dfa:	bf 4f       	sbci	r27, 0xFF	; 255
    8dfc:	88 8f       	std	Y+24, r24	; 0x18
    8dfe:	99 8f       	std	Y+25, r25	; 0x19
    8e00:	aa 8f       	std	Y+26, r26	; 0x1a
    8e02:	bb 8f       	std	Y+27, r27	; 0x1b
		 dataToWrite = 512;
    8e04:	80 e0       	ldi	r24, 0x00	; 0
    8e06:	92 e0       	ldi	r25, 0x02	; 2
    8e08:	a0 e0       	ldi	r26, 0x00	; 0
    8e0a:	b0 e0       	ldi	r27, 0x00	; 0
    8e0c:	8c 8f       	std	Y+28, r24	; 0x1c
    8e0e:	9d 8f       	std	Y+29, r25	; 0x1d
    8e10:	ae 8f       	std	Y+30, r26	; 0x1e
    8e12:	bf 8f       	std	Y+31, r27	; 0x1f
		 lengthOfData -= 512;
    8e14:	8c a9       	sts	0x4c, r24
    8e16:	9d a9       	sts	0x4d, r25
    8e18:	ae a9       	sts	0x4e, r26
    8e1a:	bf a9       	sts	0x4f, r27
    8e1c:	80 50       	subi	r24, 0x00	; 0
    8e1e:	92 40       	sbci	r25, 0x02	; 2
    8e20:	a0 40       	sbci	r26, 0x00	; 0
    8e22:	b0 40       	sbci	r27, 0x00	; 0
    8e24:	8c ab       	sts	0x5c, r24
    8e26:	9d ab       	sts	0x5d, r25
    8e28:	ae ab       	sts	0x5e, r26
    8e2a:	bf ab       	sts	0x5f, r27
    8e2c:	1f c0       	rjmp	.+62     	; 0x8e6c <writeFile+0x338>
	}
	else{
		writtenData += lengthOfData;
    8e2e:	28 8d       	ldd	r18, Y+24	; 0x18
    8e30:	39 8d       	ldd	r19, Y+25	; 0x19
    8e32:	4a 8d       	ldd	r20, Y+26	; 0x1a
    8e34:	5b 8d       	ldd	r21, Y+27	; 0x1b
    8e36:	8c a9       	sts	0x4c, r24
    8e38:	9d a9       	sts	0x4d, r25
    8e3a:	ae a9       	sts	0x4e, r26
    8e3c:	bf a9       	sts	0x4f, r27
    8e3e:	82 0f       	add	r24, r18
    8e40:	93 1f       	adc	r25, r19
    8e42:	a4 1f       	adc	r26, r20
    8e44:	b5 1f       	adc	r27, r21
    8e46:	88 8f       	std	Y+24, r24	; 0x18
    8e48:	99 8f       	std	Y+25, r25	; 0x19
    8e4a:	aa 8f       	std	Y+26, r26	; 0x1a
    8e4c:	bb 8f       	std	Y+27, r27	; 0x1b
		dataToWrite = lengthOfData%512;
    8e4e:	8c a9       	sts	0x4c, r24
    8e50:	9d a9       	sts	0x4d, r25
    8e52:	ae a9       	sts	0x4e, r26
    8e54:	bf a9       	sts	0x4f, r27
    8e56:	91 70       	andi	r25, 0x01	; 1
    8e58:	a0 70       	andi	r26, 0x00	; 0
    8e5a:	b0 70       	andi	r27, 0x00	; 0
    8e5c:	8c 8f       	std	Y+28, r24	; 0x1c
    8e5e:	9d 8f       	std	Y+29, r25	; 0x1d
    8e60:	ae 8f       	std	Y+30, r26	; 0x1e
    8e62:	bf 8f       	std	Y+31, r27	; 0x1f
		lengthOfData = 0;
    8e64:	1c aa       	sts	0x9c, r17
    8e66:	1d aa       	sts	0x9d, r17
    8e68:	1e aa       	sts	0x9e, r17
    8e6a:	1f aa       	sts	0x9f, r17
	}		   
	fileSize += 512;	//always increment size of file by 512 to avoid losing data when appending to the file. Otherwise if there is data in an unfilled sector it will be overwritten.
    8e6c:	80 91 49 40 	lds	r24, 0x4049
    8e70:	90 91 4a 40 	lds	r25, 0x404A
    8e74:	a0 91 4b 40 	lds	r26, 0x404B
    8e78:	b0 91 4c 40 	lds	r27, 0x404C
    8e7c:	80 50       	subi	r24, 0x00	; 0
    8e7e:	9e 4f       	sbci	r25, 0xFE	; 254
    8e80:	af 4f       	sbci	r26, 0xFF	; 255
    8e82:	bf 4f       	sbci	r27, 0xFF	; 255
    8e84:	80 93 49 40 	sts	0x4049, r24
    8e88:	90 93 4a 40 	sts	0x404A, r25
    8e8c:	a0 93 4b 40 	sts	0x404B, r26
    8e90:	b0 93 4c 40 	sts	0x404C, r27
	SD_write_block (startBlock,dataArray+writtenData-dataToWrite,dataToWrite);
    8e94:	8a 85       	ldd	r24, Y+10	; 0x0a
    8e96:	9b 85       	ldd	r25, Y+11	; 0x0b
    8e98:	cc 01       	movw	r24, r24
    8e9a:	a0 e0       	ldi	r26, 0x00	; 0
    8e9c:	b0 e0       	ldi	r27, 0x00	; 0
    8e9e:	48 8d       	ldd	r20, Y+24	; 0x18
    8ea0:	59 8d       	ldd	r21, Y+25	; 0x19
    8ea2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    8ea4:	3d 8d       	ldd	r19, Y+29	; 0x1d
    8ea6:	ba 01       	movw	r22, r20
    8ea8:	62 1b       	sub	r22, r18
    8eaa:	73 0b       	sbc	r23, r19
    8eac:	9b 01       	movw	r18, r22
    8eae:	4a a9       	sts	0x4a, r20
    8eb0:	5b a9       	sts	0x4b, r21
    8eb2:	42 0f       	add	r20, r18
    8eb4:	53 1f       	adc	r21, r19
    8eb6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    8eb8:	3d 8d       	ldd	r19, Y+29	; 0x1d
    8eba:	bc 01       	movw	r22, r24
    8ebc:	cd 01       	movw	r24, r26
    8ebe:	0e 94 ac 4d 	call	0x9b58	; 0x9b58 <SD_write_block>
	j++;
    8ec2:	89 81       	ldd	r24, Y+1	; 0x01
    8ec4:	8f 5f       	subi	r24, 0xFF	; 255
    8ec6:	89 83       	std	Y+1, r24	; 0x01
	//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
	if(j == sectorPerCluster) {
    8ec8:	89 81       	ldd	r24, Y+1	; 0x01
    8eca:	28 2f       	mov	r18, r24
    8ecc:	30 e0       	ldi	r19, 0x00	; 0
    8ece:	80 91 7c 50 	lds	r24, 0x507C
    8ed2:	90 91 7d 50 	lds	r25, 0x507D
    8ed6:	28 17       	cp	r18, r24
    8ed8:	39 07       	cpc	r19, r25
    8eda:	e1 f5       	brne	.+120    	; 0x8f54 <writeFile+0x420>
		j = 0; 
    8edc:	19 82       	std	Y+1, r1	; 0x01
 
		prevCluster = cluster;
    8ede:	8c 85       	ldd	r24, Y+12	; 0x0c
    8ee0:	9d 85       	ldd	r25, Y+13	; 0x0d
    8ee2:	ae 85       	ldd	r26, Y+14	; 0x0e
    8ee4:	bf 85       	ldd	r27, Y+15	; 0x0f
    8ee6:	88 8b       	std	Y+16, r24	; 0x10
    8ee8:	99 8b       	std	Y+17, r25	; 0x11
    8eea:	aa 8b       	std	Y+18, r26	; 0x12
    8eec:	bb 8b       	std	Y+19, r27	; 0x13
		cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    8eee:	88 89       	ldd	r24, Y+16	; 0x10
    8ef0:	99 89       	ldd	r25, Y+17	; 0x11
    8ef2:	aa 89       	ldd	r26, Y+18	; 0x12
    8ef4:	bb 89       	ldd	r27, Y+19	; 0x13
    8ef6:	bc 01       	movw	r22, r24
    8ef8:	cd 01       	movw	r24, r26
    8efa:	0e 94 70 49 	call	0x92e0	; 0x92e0 <searchNextFreeCluster>
    8efe:	dc 01       	movw	r26, r24
    8f00:	cb 01       	movw	r24, r22
    8f02:	8c 87       	std	Y+12, r24	; 0x0c
    8f04:	9d 87       	std	Y+13, r25	; 0x0d
    8f06:	ae 87       	std	Y+14, r26	; 0x0e
    8f08:	bf 87       	std	Y+15, r27	; 0x0f
		if(cluster == 0){
    8f0a:	8c 85       	ldd	r24, Y+12	; 0x0c
    8f0c:	9d 85       	ldd	r25, Y+13	; 0x0d
    8f0e:	ae 85       	ldd	r26, Y+14	; 0x0e
    8f10:	bf 85       	ldd	r27, Y+15	; 0x0f
    8f12:	00 97       	sbiw	r24, 0x00	; 0
    8f14:	a1 05       	cpc	r26, r1
    8f16:	b1 05       	cpc	r27, r1
    8f18:	11 f4       	brne	.+4      	; 0x8f1e <writeFile+0x3ea>
		  //No free cluster!
		  return 2;
    8f1a:	82 e0       	ldi	r24, 0x02	; 2
    8f1c:	d7 c1       	rjmp	.+942    	; 0x92cc <writeFile+0x798>
	   }
		getSetNextCluster(prevCluster, SET, cluster);
    8f1e:	88 89       	ldd	r24, Y+16	; 0x10
    8f20:	99 89       	ldd	r25, Y+17	; 0x11
    8f22:	aa 89       	ldd	r26, Y+18	; 0x12
    8f24:	bb 89       	ldd	r27, Y+19	; 0x13
    8f26:	0c 85       	ldd	r16, Y+12	; 0x0c
    8f28:	1d 85       	ldd	r17, Y+13	; 0x0d
    8f2a:	2e 85       	ldd	r18, Y+14	; 0x0e
    8f2c:	3f 85       	ldd	r19, Y+15	; 0x0f
    8f2e:	bc 01       	movw	r22, r24
    8f30:	cd 01       	movw	r24, r26
    8f32:	41 e0       	ldi	r20, 0x01	; 1
    8f34:	0e 94 80 40 	call	0x8100	; 0x8100 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    8f38:	8c 85       	ldd	r24, Y+12	; 0x0c
    8f3a:	9d 85       	ldd	r25, Y+13	; 0x0d
    8f3c:	ae 85       	ldd	r26, Y+14	; 0x0e
    8f3e:	bf 85       	ldd	r27, Y+15	; 0x0f
    8f40:	bc 01       	movw	r22, r24
    8f42:	cd 01       	movw	r24, r26
    8f44:	41 e0       	ldi	r20, 0x01	; 1
    8f46:	0f ef       	ldi	r16, 0xFF	; 255
    8f48:	1f ef       	ldi	r17, 0xFF	; 255
    8f4a:	2f ef       	ldi	r18, 0xFF	; 255
    8f4c:	3f e0       	ldi	r19, 0x0F	; 15
    8f4e:	0e 94 80 40 	call	0x8100	; 0x8100 <getSetNextCluster>
    8f52:	05 c0       	rjmp	.+10     	; 0x8f5e <writeFile+0x42a>
	}
	//otherwise increment the sector offset 
	else startBlock++;       
    8f54:	8a 85       	ldd	r24, Y+10	; 0x0a
    8f56:	9b 85       	ldd	r25, Y+11	; 0x0b
    8f58:	01 96       	adiw	r24, 0x01	; 1
    8f5a:	8a 87       	std	Y+10, r24	; 0x0a
    8f5c:	9b 87       	std	Y+11, r25	; 0x0b
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    8f5e:	2c 85       	ldd	r18, Y+12	; 0x0c
    8f60:	3d 85       	ldd	r19, Y+13	; 0x0d
    8f62:	4e 85       	ldd	r20, Y+14	; 0x0e
    8f64:	5f 85       	ldd	r21, Y+15	; 0x0f
    8f66:	82 e0       	ldi	r24, 0x02	; 2
    8f68:	61 e0       	ldi	r22, 0x01	; 1
    8f6a:	0e 94 2a 41 	call	0x8254	; 0x8254 <getSetFreeCluster>
  startBlock = getFirstSector (cluster);
  j=0;
}
uint32_t writtenData = 0;
uint32_t dataToWrite = 0;
while(lengthOfData!=0){
    8f6e:	8c a9       	sts	0x4c, r24
    8f70:	9d a9       	sts	0x4d, r25
    8f72:	ae a9       	sts	0x4e, r26
    8f74:	bf a9       	sts	0x4f, r27
    8f76:	00 97       	sbiw	r24, 0x00	; 0
    8f78:	a1 05       	cpc	r26, r1
    8f7a:	b1 05       	cpc	r27, r1
    8f7c:	09 f0       	breq	.+2      	; 0x8f80 <writeFile+0x44c>
    8f7e:	2a cf       	rjmp	.-428    	; 0x8dd4 <writeFile+0x2a0>
	//otherwise increment the sector offset 
	else startBlock++;       
	getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
}

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    8f80:	8c 81       	ldd	r24, Y+4	; 0x04
    8f82:	88 23       	and	r24, r24
    8f84:	09 f4       	brne	.+2      	; 0x8f88 <writeFile+0x454>
    8f86:	66 c0       	rjmp	.+204    	; 0x9054 <writeFile+0x520>
{
  SD_read_block (appendFileSector,SDBuffer);    
    8f88:	80 91 d2 50 	lds	r24, 0x50D2
    8f8c:	90 91 d3 50 	lds	r25, 0x50D3
    8f90:	a0 91 d4 50 	lds	r26, 0x50D4
    8f94:	b0 91 d5 50 	lds	r27, 0x50D5
    8f98:	2f ec       	ldi	r18, 0xCF	; 207
    8f9a:	31 e2       	ldi	r19, 0x21	; 33
    8f9c:	bc 01       	movw	r22, r24
    8f9e:	cd 01       	movw	r24, r26
    8fa0:	a9 01       	movw	r20, r18
    8fa2:	0e 94 7a 4e 	call	0x9cf4	; 0x9cf4 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    8fa6:	80 91 d0 23 	lds	r24, 0x23D0
    8faa:	90 91 d1 23 	lds	r25, 0x23D1
    8fae:	a0 91 d2 23 	lds	r26, 0x23D2
    8fb2:	b0 91 d3 23 	lds	r27, 0x23D3
    8fb6:	81 53       	subi	r24, 0x31	; 49
    8fb8:	9e 4d       	sbci	r25, 0xDE	; 222
    8fba:	8e a3       	lds	r24, 0x5e
    8fbc:	9f a3       	lds	r25, 0x5f

  dir->lastAccessDate = 0;   //date of last access ignored
    8fbe:	8e a1       	lds	r24, 0x4e
    8fc0:	9f a1       	lds	r25, 0x4f
    8fc2:	fc 01       	movw	r30, r24
    8fc4:	12 8a       	std	Z+18, r1	; 0x12
    8fc6:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    8fc8:	20 91 49 40 	lds	r18, 0x4049
    8fcc:	30 91 4a 40 	lds	r19, 0x404A
    8fd0:	40 91 4b 40 	lds	r20, 0x404B
    8fd4:	50 91 4c 40 	lds	r21, 0x404C
    8fd8:	8e a1       	lds	r24, 0x4e
    8fda:	9f a1       	lds	r25, 0x4f
    8fdc:	fc 01       	movw	r30, r24
    8fde:	84 8d       	ldd	r24, Z+28	; 0x1c
    8fe0:	95 8d       	ldd	r25, Z+29	; 0x1d
    8fe2:	a6 8d       	ldd	r26, Z+30	; 0x1e
    8fe4:	b7 8d       	ldd	r27, Z+31	; 0x1f
    8fe6:	79 01       	movw	r14, r18
    8fe8:	8a 01       	movw	r16, r20
    8fea:	e8 1a       	sub	r14, r24
    8fec:	f9 0a       	sbc	r15, r25
    8fee:	0a 0b       	sbc	r16, r26
    8ff0:	1b 0b       	sbc	r17, r27
    8ff2:	d8 01       	movw	r26, r16
    8ff4:	c7 01       	movw	r24, r14
    8ff6:	88 a7       	lds	r24, 0x78
    8ff8:	99 a7       	lds	r25, 0x79
    8ffa:	aa a7       	lds	r26, 0x7a
    8ffc:	bb a7       	lds	r27, 0x7b
  dir->fileSize = fileSize;
    8ffe:	80 91 49 40 	lds	r24, 0x4049
    9002:	90 91 4a 40 	lds	r25, 0x404A
    9006:	a0 91 4b 40 	lds	r26, 0x404B
    900a:	b0 91 4c 40 	lds	r27, 0x404C
    900e:	2e a1       	lds	r18, 0x4e
    9010:	3f a1       	lds	r19, 0x4f
    9012:	f9 01       	movw	r30, r18
    9014:	84 8f       	std	Z+28, r24	; 0x1c
    9016:	95 8f       	std	Z+29, r25	; 0x1d
    9018:	a6 8f       	std	Z+30, r26	; 0x1e
    901a:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    901c:	80 91 d2 50 	lds	r24, 0x50D2
    9020:	90 91 d3 50 	lds	r25, 0x50D3
    9024:	a0 91 d4 50 	lds	r26, 0x50D4
    9028:	b0 91 d5 50 	lds	r27, 0x50D5
    902c:	2f ec       	ldi	r18, 0xCF	; 207
    902e:	31 e2       	ldi	r19, 0x21	; 33
    9030:	bc 01       	movw	r22, r24
    9032:	cd 01       	movw	r24, r26
    9034:	a9 01       	movw	r20, r18
    9036:	20 e0       	ldi	r18, 0x00	; 0
    9038:	32 e0       	ldi	r19, 0x02	; 2
    903a:	0e 94 ac 4d 	call	0x9b58	; 0x9b58 <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    903e:	28 a5       	lds	r18, 0x68
    9040:	39 a5       	lds	r19, 0x69
    9042:	4a a5       	lds	r20, 0x6a
    9044:	5b a5       	lds	r21, 0x6b
    9046:	81 e0       	ldi	r24, 0x01	; 1
    9048:	ba 01       	movw	r22, r20
    904a:	a9 01       	movw	r20, r18
    904c:	0e 94 49 4a 	call	0x9492	; 0x9492 <freeMemoryUpdate>

 //File appended!
  return 0;
    9050:	80 e0       	ldi	r24, 0x00	; 0
    9052:	3c c1       	rjmp	.+632    	; 0x92cc <writeFile+0x798>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    9054:	80 91 60 40 	lds	r24, 0x4060
    9058:	90 91 61 40 	lds	r25, 0x4061
    905c:	a0 91 62 40 	lds	r26, 0x4062
    9060:	b0 91 63 40 	lds	r27, 0x4063
    9064:	88 8b       	std	Y+16, r24	; 0x10
    9066:	99 8b       	std	Y+17, r25	; 0x11
    9068:	aa 8b       	std	Y+18, r26	; 0x12
    906a:	bb 8b       	std	Y+19, r27	; 0x13

while(1)
{
   firstSector = getFirstSector (prevCluster);
    906c:	88 89       	ldd	r24, Y+16	; 0x10
    906e:	99 89       	ldd	r25, Y+17	; 0x11
    9070:	aa 89       	ldd	r26, Y+18	; 0x12
    9072:	bb 89       	ldd	r27, Y+19	; 0x13
    9074:	bc 01       	movw	r22, r24
    9076:	cd 01       	movw	r24, r26
    9078:	0e 94 4e 40 	call	0x809c	; 0x809c <getFirstSector>
    907c:	dc 01       	movw	r26, r24
    907e:	cb 01       	movw	r24, r22
    9080:	8c a7       	lds	r24, 0x7c
    9082:	9d a7       	lds	r25, 0x7d
    9084:	ae a7       	lds	r26, 0x7e
    9086:	bf a7       	lds	r27, 0x7f

   for(sector = 0; sector < sectorPerCluster; sector++)
    9088:	1d 82       	std	Y+5, r1	; 0x05
    908a:	ad c0       	rjmp	.+346    	; 0x91e6 <writeFile+0x6b2>
   {
     SD_read_block (firstSector + sector,SDBuffer);
    908c:	8d 81       	ldd	r24, Y+5	; 0x05
    908e:	28 2f       	mov	r18, r24
    9090:	30 e0       	ldi	r19, 0x00	; 0
    9092:	40 e0       	ldi	r20, 0x00	; 0
    9094:	50 e0       	ldi	r21, 0x00	; 0
    9096:	8c a5       	lds	r24, 0x6c
    9098:	9d a5       	lds	r25, 0x6d
    909a:	ae a5       	lds	r26, 0x6e
    909c:	bf a5       	lds	r27, 0x6f
    909e:	82 0f       	add	r24, r18
    90a0:	93 1f       	adc	r25, r19
    90a2:	a4 1f       	adc	r26, r20
    90a4:	b5 1f       	adc	r27, r21
    90a6:	2f ec       	ldi	r18, 0xCF	; 207
    90a8:	31 e2       	ldi	r19, 0x21	; 33
    90aa:	bc 01       	movw	r22, r24
    90ac:	cd 01       	movw	r24, r26
    90ae:	a9 01       	movw	r20, r18
    90b0:	0e 94 7a 4e 	call	0x9cf4	; 0x9cf4 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    90b4:	18 a2       	lds	r17, 0x98
    90b6:	19 a2       	lds	r17, 0x99
    90b8:	89 c0       	rjmp	.+274    	; 0x91cc <writeFile+0x698>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    90ba:	88 a1       	lds	r24, 0x48
    90bc:	99 a1       	lds	r25, 0x49
    90be:	81 53       	subi	r24, 0x31	; 49
    90c0:	9e 4d       	sbci	r25, 0xDE	; 222
    90c2:	8e a3       	lds	r24, 0x5e
    90c4:	9f a3       	lds	r25, 0x5f
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    90c6:	8a 81       	ldd	r24, Y+2	; 0x02
    90c8:	88 23       	and	r24, r24
    90ca:	11 f0       	breq	.+4      	; 0x90d0 <writeFile+0x59c>
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    90cc:	80 e0       	ldi	r24, 0x00	; 0
    90ce:	fe c0       	rjmp	.+508    	; 0x92cc <writeFile+0x798>
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    90d0:	8e a1       	lds	r24, 0x4e
    90d2:	9f a1       	lds	r25, 0x4f
    90d4:	fc 01       	movw	r30, r24
    90d6:	80 81       	ld	r24, Z
    90d8:	88 23       	and	r24, r24
    90da:	39 f0       	breq	.+14     	; 0x90ea <writeFile+0x5b6>
    90dc:	8e a1       	lds	r24, 0x4e
    90de:	9f a1       	lds	r25, 0x4f
    90e0:	fc 01       	movw	r30, r24
    90e2:	80 81       	ld	r24, Z
    90e4:	85 3e       	cpi	r24, 0xE5	; 229
    90e6:	09 f0       	breq	.+2      	; 0x90ea <writeFile+0x5b6>
    90e8:	6c c0       	rjmp	.+216    	; 0x91c2 <writeFile+0x68e>
		{
		  for(j=0; j<11; j++)
    90ea:	19 82       	std	Y+1, r1	; 0x01
    90ec:	13 c0       	rjmp	.+38     	; 0x9114 <writeFile+0x5e0>
  			dir->name[j] = Filename[j];
    90ee:	89 81       	ldd	r24, Y+1	; 0x01
    90f0:	88 2f       	mov	r24, r24
    90f2:	90 e0       	ldi	r25, 0x00	; 0
    90f4:	29 81       	ldd	r18, Y+1	; 0x01
    90f6:	22 2f       	mov	r18, r18
    90f8:	30 e0       	ldi	r19, 0x00	; 0
    90fa:	24 54       	subi	r18, 0x44	; 68
    90fc:	3f 4a       	sbci	r19, 0xAF	; 175
    90fe:	f9 01       	movw	r30, r18
    9100:	40 81       	ld	r20, Z
    9102:	2e a1       	lds	r18, 0x4e
    9104:	3f a1       	lds	r19, 0x4f
    9106:	82 0f       	add	r24, r18
    9108:	93 1f       	adc	r25, r19
    910a:	fc 01       	movw	r30, r24
    910c:	40 83       	st	Z, r20
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    910e:	89 81       	ldd	r24, Y+1	; 0x01
    9110:	8f 5f       	subi	r24, 0xFF	; 255
    9112:	89 83       	std	Y+1, r24	; 0x01
    9114:	89 81       	ldd	r24, Y+1	; 0x01
    9116:	8b 30       	cpi	r24, 0x0B	; 11
    9118:	50 f3       	brcs	.-44     	; 0x90ee <writeFile+0x5ba>
  			dir->name[j] = Filename[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    911a:	8e a1       	lds	r24, 0x4e
    911c:	9f a1       	lds	r25, 0x4f
    911e:	20 e2       	ldi	r18, 0x20	; 32
    9120:	fc 01       	movw	r30, r24
    9122:	23 87       	std	Z+11, r18	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    9124:	8e a1       	lds	r24, 0x4e
    9126:	9f a1       	lds	r25, 0x4f
    9128:	fc 01       	movw	r30, r24
    912a:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    912c:	8e a1       	lds	r24, 0x4e
    912e:	9f a1       	lds	r25, 0x4f
    9130:	fc 01       	movw	r30, r24
    9132:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    9134:	8e a1       	lds	r24, 0x4e
    9136:	9f a1       	lds	r25, 0x4f
    9138:	fc 01       	movw	r30, r24
    913a:	12 8a       	std	Z+18, r1	; 0x12
    913c:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    913e:	8e a1       	lds	r24, 0x4e
    9140:	9f a1       	lds	r25, 0x4f
    9142:	2e 81       	ldd	r18, Y+6	; 0x06
    9144:	3f 81       	ldd	r19, Y+7	; 0x07
    9146:	fc 01       	movw	r30, r24
    9148:	24 8b       	std	Z+20, r18	; 0x14
    914a:	35 8b       	std	Z+21, r19	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    914c:	8e a1       	lds	r24, 0x4e
    914e:	9f a1       	lds	r25, 0x4f
    9150:	28 85       	ldd	r18, Y+8	; 0x08
    9152:	39 85       	ldd	r19, Y+9	; 0x09
    9154:	fc 01       	movw	r30, r24
    9156:	22 8f       	std	Z+26, r18	; 0x1a
    9158:	33 8f       	std	Z+27, r19	; 0x1b
		  dir->fileSize = fileSize;
    915a:	80 91 49 40 	lds	r24, 0x4049
    915e:	90 91 4a 40 	lds	r25, 0x404A
    9162:	a0 91 4b 40 	lds	r26, 0x404B
    9166:	b0 91 4c 40 	lds	r27, 0x404C
    916a:	2e a1       	lds	r18, 0x4e
    916c:	3f a1       	lds	r19, 0x4f
    916e:	f9 01       	movw	r30, r18
    9170:	84 8f       	std	Z+28, r24	; 0x1c
    9172:	95 8f       	std	Z+29, r25	; 0x1d
    9174:	a6 8f       	std	Z+30, r26	; 0x1e
    9176:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    9178:	8d 81       	ldd	r24, Y+5	; 0x05
    917a:	28 2f       	mov	r18, r24
    917c:	30 e0       	ldi	r19, 0x00	; 0
    917e:	40 e0       	ldi	r20, 0x00	; 0
    9180:	50 e0       	ldi	r21, 0x00	; 0
    9182:	8c a5       	lds	r24, 0x6c
    9184:	9d a5       	lds	r25, 0x6d
    9186:	ae a5       	lds	r26, 0x6e
    9188:	bf a5       	lds	r27, 0x6f
    918a:	82 0f       	add	r24, r18
    918c:	93 1f       	adc	r25, r19
    918e:	a4 1f       	adc	r26, r20
    9190:	b5 1f       	adc	r27, r21
    9192:	2f ec       	ldi	r18, 0xCF	; 207
    9194:	31 e2       	ldi	r19, 0x21	; 33
    9196:	bc 01       	movw	r22, r24
    9198:	cd 01       	movw	r24, r26
    919a:	a9 01       	movw	r20, r18
    919c:	20 e0       	ldi	r18, 0x00	; 0
    919e:	32 e0       	ldi	r19, 0x02	; 2
    91a0:	0e 94 ac 4d 	call	0x9b58	; 0x9b58 <SD_write_block>
		  fileCreatedFlag = 1;
    91a4:	81 e0       	ldi	r24, 0x01	; 1
    91a6:	8a 83       	std	Y+2, r24	; 0x02

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    91a8:	20 91 49 40 	lds	r18, 0x4049
    91ac:	30 91 4a 40 	lds	r19, 0x404A
    91b0:	40 91 4b 40 	lds	r20, 0x404B
    91b4:	50 91 4c 40 	lds	r21, 0x404C
    91b8:	81 e0       	ldi	r24, 0x01	; 1
    91ba:	ba 01       	movw	r22, r20
    91bc:	a9 01       	movw	r20, r18
    91be:	0e 94 49 4a 	call	0x9492	; 0x9492 <freeMemoryUpdate>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    91c2:	88 a1       	lds	r24, 0x48
    91c4:	99 a1       	lds	r25, 0x49
    91c6:	80 96       	adiw	r24, 0x20	; 32
    91c8:	88 a3       	lds	r24, 0x58
    91ca:	99 a3       	lds	r25, 0x59
    91cc:	28 a1       	lds	r18, 0x48
    91ce:	39 a1       	lds	r19, 0x49
    91d0:	80 91 4d 40 	lds	r24, 0x404D
    91d4:	90 91 4e 40 	lds	r25, 0x404E
    91d8:	28 17       	cp	r18, r24
    91da:	39 07       	cpc	r19, r25
    91dc:	08 f4       	brcc	.+2      	; 0x91e0 <writeFile+0x6ac>
    91de:	6d cf       	rjmp	.-294    	; 0x90ba <writeFile+0x586>

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    91e0:	8d 81       	ldd	r24, Y+5	; 0x05
    91e2:	8f 5f       	subi	r24, 0xFF	; 255
    91e4:	8d 83       	std	Y+5, r24	; 0x05
    91e6:	8d 81       	ldd	r24, Y+5	; 0x05
    91e8:	28 2f       	mov	r18, r24
    91ea:	30 e0       	ldi	r19, 0x00	; 0
    91ec:	80 91 7c 50 	lds	r24, 0x507C
    91f0:	90 91 7d 50 	lds	r25, 0x507D
    91f4:	28 17       	cp	r18, r24
    91f6:	39 07       	cpc	r19, r25
    91f8:	08 f4       	brcc	.+2      	; 0x91fc <writeFile+0x6c8>
    91fa:	48 cf       	rjmp	.-368    	; 0x908c <writeFile+0x558>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    91fc:	88 89       	ldd	r24, Y+16	; 0x10
    91fe:	99 89       	ldd	r25, Y+17	; 0x11
    9200:	aa 89       	ldd	r26, Y+18	; 0x12
    9202:	bb 89       	ldd	r27, Y+19	; 0x13
    9204:	bc 01       	movw	r22, r24
    9206:	cd 01       	movw	r24, r26
    9208:	40 e0       	ldi	r20, 0x00	; 0
    920a:	00 e0       	ldi	r16, 0x00	; 0
    920c:	10 e0       	ldi	r17, 0x00	; 0
    920e:	98 01       	movw	r18, r16
    9210:	0e 94 80 40 	call	0x8100	; 0x8100 <getSetNextCluster>
    9214:	dc 01       	movw	r26, r24
    9216:	cb 01       	movw	r24, r22
    9218:	8c 87       	std	Y+12, r24	; 0x0c
    921a:	9d 87       	std	Y+13, r25	; 0x0d
    921c:	ae 87       	std	Y+14, r26	; 0x0e
    921e:	bf 87       	std	Y+15, r27	; 0x0f

   if(cluster > 0x0ffffff6)
    9220:	8c 85       	ldd	r24, Y+12	; 0x0c
    9222:	9d 85       	ldd	r25, Y+13	; 0x0d
    9224:	ae 85       	ldd	r26, Y+14	; 0x0e
    9226:	bf 85       	ldd	r27, Y+15	; 0x0f
    9228:	87 3f       	cpi	r24, 0xF7	; 247
    922a:	ff ef       	ldi	r31, 0xFF	; 255
    922c:	9f 07       	cpc	r25, r31
    922e:	ff ef       	ldi	r31, 0xFF	; 255
    9230:	af 07       	cpc	r26, r31
    9232:	ff e0       	ldi	r31, 0x0F	; 15
    9234:	bf 07       	cpc	r27, r31
    9236:	b8 f1       	brcs	.+110    	; 0x92a6 <writeFile+0x772>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    9238:	8c 85       	ldd	r24, Y+12	; 0x0c
    923a:	9d 85       	ldd	r25, Y+13	; 0x0d
    923c:	ae 85       	ldd	r26, Y+14	; 0x0e
    923e:	bf 85       	ldd	r27, Y+15	; 0x0f
    9240:	8f 3f       	cpi	r24, 0xFF	; 255
    9242:	0f ef       	ldi	r16, 0xFF	; 255
    9244:	90 07       	cpc	r25, r16
    9246:	0f ef       	ldi	r16, 0xFF	; 255
    9248:	a0 07       	cpc	r26, r16
    924a:	0f e0       	ldi	r16, 0x0F	; 15
    924c:	b0 07       	cpc	r27, r16
    924e:	49 f5       	brne	.+82     	; 0x92a2 <writeFile+0x76e>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    9250:	88 89       	ldd	r24, Y+16	; 0x10
    9252:	99 89       	ldd	r25, Y+17	; 0x11
    9254:	aa 89       	ldd	r26, Y+18	; 0x12
    9256:	bb 89       	ldd	r27, Y+19	; 0x13
    9258:	bc 01       	movw	r22, r24
    925a:	cd 01       	movw	r24, r26
    925c:	0e 94 70 49 	call	0x92e0	; 0x92e0 <searchNextFreeCluster>
    9260:	dc 01       	movw	r26, r24
    9262:	cb 01       	movw	r24, r22
    9264:	8c 87       	std	Y+12, r24	; 0x0c
    9266:	9d 87       	std	Y+13, r25	; 0x0d
    9268:	ae 87       	std	Y+14, r26	; 0x0e
    926a:	bf 87       	std	Y+15, r27	; 0x0f
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    926c:	88 89       	ldd	r24, Y+16	; 0x10
    926e:	99 89       	ldd	r25, Y+17	; 0x11
    9270:	aa 89       	ldd	r26, Y+18	; 0x12
    9272:	bb 89       	ldd	r27, Y+19	; 0x13
    9274:	0c 85       	ldd	r16, Y+12	; 0x0c
    9276:	1d 85       	ldd	r17, Y+13	; 0x0d
    9278:	2e 85       	ldd	r18, Y+14	; 0x0e
    927a:	3f 85       	ldd	r19, Y+15	; 0x0f
    927c:	bc 01       	movw	r22, r24
    927e:	cd 01       	movw	r24, r26
    9280:	41 e0       	ldi	r20, 0x01	; 1
    9282:	0e 94 80 40 	call	0x8100	; 0x8100 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    9286:	8c 85       	ldd	r24, Y+12	; 0x0c
    9288:	9d 85       	ldd	r25, Y+13	; 0x0d
    928a:	ae 85       	ldd	r26, Y+14	; 0x0e
    928c:	bf 85       	ldd	r27, Y+15	; 0x0f
    928e:	bc 01       	movw	r22, r24
    9290:	cd 01       	movw	r24, r26
    9292:	41 e0       	ldi	r20, 0x01	; 1
    9294:	0f ef       	ldi	r16, 0xFF	; 255
    9296:	1f ef       	ldi	r17, 0xFF	; 255
    9298:	2f ef       	ldi	r18, 0xFF	; 255
    929a:	3f e0       	ldi	r19, 0x0F	; 15
    929c:	0e 94 80 40 	call	0x8100	; 0x8100 <getSetNextCluster>
    92a0:	02 c0       	rjmp	.+4      	; 0x92a6 <writeFile+0x772>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    92a2:	83 e0       	ldi	r24, 0x03	; 3
    92a4:	13 c0       	rjmp	.+38     	; 0x92cc <writeFile+0x798>
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    92a6:	8c 85       	ldd	r24, Y+12	; 0x0c
    92a8:	9d 85       	ldd	r25, Y+13	; 0x0d
    92aa:	ae 85       	ldd	r26, Y+14	; 0x0e
    92ac:	bf 85       	ldd	r27, Y+15	; 0x0f
    92ae:	00 97       	sbiw	r24, 0x00	; 0
    92b0:	a1 05       	cpc	r26, r1
    92b2:	b1 05       	cpc	r27, r1
    92b4:	11 f4       	brne	.+4      	; 0x92ba <writeFile+0x786>
	   return 4;
    92b6:	84 e0       	ldi	r24, 0x04	; 4
    92b8:	09 c0       	rjmp	.+18     	; 0x92cc <writeFile+0x798>
	}
   
   prevCluster = cluster;
    92ba:	8c 85       	ldd	r24, Y+12	; 0x0c
    92bc:	9d 85       	ldd	r25, Y+13	; 0x0d
    92be:	ae 85       	ldd	r26, Y+14	; 0x0e
    92c0:	bf 85       	ldd	r27, Y+15	; 0x0f
    92c2:	88 8b       	std	Y+16, r24	; 0x10
    92c4:	99 8b       	std	Y+17, r25	; 0x11
    92c6:	aa 8b       	std	Y+18, r26	; 0x12
    92c8:	bb 8b       	std	Y+19, r27	; 0x13
 }
    92ca:	d0 ce       	rjmp	.-608    	; 0x906c <writeFile+0x538>
 
 return 0;
}
    92cc:	e7 96       	adiw	r28, 0x37	; 55
    92ce:	cd bf       	out	0x3d, r28	; 61
    92d0:	de bf       	out	0x3e, r29	; 62
    92d2:	df 91       	pop	r29
    92d4:	cf 91       	pop	r28
    92d6:	1f 91       	pop	r17
    92d8:	0f 91       	pop	r16
    92da:	ff 90       	pop	r15
    92dc:	ef 90       	pop	r14
    92de:	08 95       	ret

000092e0 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    92e0:	ef 92       	push	r14
    92e2:	ff 92       	push	r15
    92e4:	0f 93       	push	r16
    92e6:	1f 93       	push	r17
    92e8:	cf 93       	push	r28
    92ea:	df 93       	push	r29
    92ec:	cd b7       	in	r28, 0x3d	; 61
    92ee:	de b7       	in	r29, 0x3e	; 62
    92f0:	2f 97       	sbiw	r28, 0x0f	; 15
    92f2:	cd bf       	out	0x3d, r28	; 61
    92f4:	de bf       	out	0x3e, r29	; 62
    92f6:	6c 87       	std	Y+12, r22	; 0x0c
    92f8:	7d 87       	std	Y+13, r23	; 0x0d
    92fa:	8e 87       	std	Y+14, r24	; 0x0e
    92fc:	9f 87       	std	Y+15, r25	; 0x0f
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    92fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    9300:	9d 85       	ldd	r25, Y+13	; 0x0d
    9302:	ae 85       	ldd	r26, Y+14	; 0x0e
    9304:	bf 85       	ldd	r27, Y+15	; 0x0f
    9306:	80 78       	andi	r24, 0x80	; 128
    9308:	8c 87       	std	Y+12, r24	; 0x0c
    930a:	9d 87       	std	Y+13, r25	; 0x0d
    930c:	ae 87       	std	Y+14, r26	; 0x0e
    930e:	bf 87       	std	Y+15, r27	; 0x0f
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    9310:	8c 85       	ldd	r24, Y+12	; 0x0c
    9312:	9d 85       	ldd	r25, Y+13	; 0x0d
    9314:	ae 85       	ldd	r26, Y+14	; 0x0e
    9316:	bf 85       	ldd	r27, Y+15	; 0x0f
    9318:	89 83       	std	Y+1, r24	; 0x01
    931a:	9a 83       	std	Y+2, r25	; 0x02
    931c:	ab 83       	std	Y+3, r26	; 0x03
    931e:	bc 83       	std	Y+4, r27	; 0x04
    9320:	7a c0       	rjmp	.+244    	; 0x9416 <searchNextFreeCluster+0x136>
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    9322:	80 91 84 50 	lds	r24, 0x5084
    9326:	90 91 85 50 	lds	r25, 0x5085
    932a:	9c 01       	movw	r18, r24
    932c:	40 e0       	ldi	r20, 0x00	; 0
    932e:	50 e0       	ldi	r21, 0x00	; 0
    9330:	80 91 7e 50 	lds	r24, 0x507E
    9334:	90 91 7f 50 	lds	r25, 0x507F
    9338:	a0 91 80 50 	lds	r26, 0x5080
    933c:	b0 91 81 50 	lds	r27, 0x5081
    9340:	79 01       	movw	r14, r18
    9342:	8a 01       	movw	r16, r20
    9344:	e8 0e       	add	r14, r24
    9346:	f9 1e       	adc	r15, r25
    9348:	0a 1f       	adc	r16, r26
    934a:	1b 1f       	adc	r17, r27
    934c:	89 81       	ldd	r24, Y+1	; 0x01
    934e:	9a 81       	ldd	r25, Y+2	; 0x02
    9350:	ab 81       	ldd	r26, Y+3	; 0x03
    9352:	bc 81       	ldd	r27, Y+4	; 0x04
    9354:	88 0f       	add	r24, r24
    9356:	99 1f       	adc	r25, r25
    9358:	aa 1f       	adc	r26, r26
    935a:	bb 1f       	adc	r27, r27
    935c:	88 0f       	add	r24, r24
    935e:	99 1f       	adc	r25, r25
    9360:	aa 1f       	adc	r26, r26
    9362:	bb 1f       	adc	r27, r27
    9364:	20 91 4d 40 	lds	r18, 0x404D
    9368:	30 91 4e 40 	lds	r19, 0x404E
    936c:	99 01       	movw	r18, r18
    936e:	40 e0       	ldi	r20, 0x00	; 0
    9370:	50 e0       	ldi	r21, 0x00	; 0
    9372:	bc 01       	movw	r22, r24
    9374:	cd 01       	movw	r24, r26
    9376:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    937a:	da 01       	movw	r26, r20
    937c:	c9 01       	movw	r24, r18
    937e:	8e 0d       	add	r24, r14
    9380:	9f 1d       	adc	r25, r15
    9382:	a0 1f       	adc	r26, r16
    9384:	b1 1f       	adc	r27, r17
    9386:	8e 83       	std	Y+6, r24	; 0x06
    9388:	9f 83       	std	Y+7, r25	; 0x07
    938a:	a8 87       	std	Y+8, r26	; 0x08
    938c:	b9 87       	std	Y+9, r27	; 0x09
      SD_read_block(sector,SDBuffer);
    938e:	8e 81       	ldd	r24, Y+6	; 0x06
    9390:	9f 81       	ldd	r25, Y+7	; 0x07
    9392:	a8 85       	ldd	r26, Y+8	; 0x08
    9394:	b9 85       	ldd	r27, Y+9	; 0x09
    9396:	2f ec       	ldi	r18, 0xCF	; 207
    9398:	31 e2       	ldi	r19, 0x21	; 33
    939a:	bc 01       	movw	r22, r24
    939c:	cd 01       	movw	r24, r26
    939e:	a9 01       	movw	r20, r18
    93a0:	0e 94 7a 4e 	call	0x9cf4	; 0x9cf4 <SD_read_block>
      for(i=0; i<128; i++)
    93a4:	1d 82       	std	Y+5, r1	; 0x05
    93a6:	28 c0       	rjmp	.+80     	; 0x93f8 <searchNextFreeCluster+0x118>
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    93a8:	8d 81       	ldd	r24, Y+5	; 0x05
    93aa:	88 2f       	mov	r24, r24
    93ac:	90 e0       	ldi	r25, 0x00	; 0
    93ae:	88 0f       	add	r24, r24
    93b0:	99 1f       	adc	r25, r25
    93b2:	88 0f       	add	r24, r24
    93b4:	99 1f       	adc	r25, r25
    93b6:	81 53       	subi	r24, 0x31	; 49
    93b8:	9e 4d       	sbci	r25, 0xDE	; 222
    93ba:	8a 87       	std	Y+10, r24	; 0x0a
    93bc:	9b 87       	std	Y+11, r25	; 0x0b
         if(((*value) & 0x0fffffff) == 0)
    93be:	8a 85       	ldd	r24, Y+10	; 0x0a
    93c0:	9b 85       	ldd	r25, Y+11	; 0x0b
    93c2:	fc 01       	movw	r30, r24
    93c4:	80 81       	ld	r24, Z
    93c6:	91 81       	ldd	r25, Z+1	; 0x01
    93c8:	a2 81       	ldd	r26, Z+2	; 0x02
    93ca:	b3 81       	ldd	r27, Z+3	; 0x03
    93cc:	bf 70       	andi	r27, 0x0F	; 15
    93ce:	00 97       	sbiw	r24, 0x00	; 0
    93d0:	a1 05       	cpc	r26, r1
    93d2:	b1 05       	cpc	r27, r1
    93d4:	71 f4       	brne	.+28     	; 0x93f2 <searchNextFreeCluster+0x112>
            return(cluster+i);
    93d6:	8d 81       	ldd	r24, Y+5	; 0x05
    93d8:	28 2f       	mov	r18, r24
    93da:	30 e0       	ldi	r19, 0x00	; 0
    93dc:	40 e0       	ldi	r20, 0x00	; 0
    93de:	50 e0       	ldi	r21, 0x00	; 0
    93e0:	89 81       	ldd	r24, Y+1	; 0x01
    93e2:	9a 81       	ldd	r25, Y+2	; 0x02
    93e4:	ab 81       	ldd	r26, Y+3	; 0x03
    93e6:	bc 81       	ldd	r27, Y+4	; 0x04
    93e8:	82 0f       	add	r24, r18
    93ea:	93 1f       	adc	r25, r19
    93ec:	a4 1f       	adc	r26, r20
    93ee:	b5 1f       	adc	r27, r21
    93f0:	27 c0       	rjmp	.+78     	; 0x9440 <searchNextFreeCluster+0x160>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    93f2:	8d 81       	ldd	r24, Y+5	; 0x05
    93f4:	8f 5f       	subi	r24, 0xFF	; 255
    93f6:	8d 83       	std	Y+5, r24	; 0x05
    93f8:	8d 81       	ldd	r24, Y+5	; 0x05
    93fa:	88 23       	and	r24, r24
    93fc:	ac f6       	brge	.-86     	; 0x93a8 <searchNextFreeCluster+0xc8>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    93fe:	89 81       	ldd	r24, Y+1	; 0x01
    9400:	9a 81       	ldd	r25, Y+2	; 0x02
    9402:	ab 81       	ldd	r26, Y+3	; 0x03
    9404:	bc 81       	ldd	r27, Y+4	; 0x04
    9406:	80 58       	subi	r24, 0x80	; 128
    9408:	9f 4f       	sbci	r25, 0xFF	; 255
    940a:	af 4f       	sbci	r26, 0xFF	; 255
    940c:	bf 4f       	sbci	r27, 0xFF	; 255
    940e:	89 83       	std	Y+1, r24	; 0x01
    9410:	9a 83       	std	Y+2, r25	; 0x02
    9412:	ab 83       	std	Y+3, r26	; 0x03
    9414:	bc 83       	std	Y+4, r27	; 0x04
    9416:	80 91 5a 40 	lds	r24, 0x405A
    941a:	90 91 5b 40 	lds	r25, 0x405B
    941e:	a0 91 5c 40 	lds	r26, 0x405C
    9422:	b0 91 5d 40 	lds	r27, 0x405D
    9426:	29 81       	ldd	r18, Y+1	; 0x01
    9428:	3a 81       	ldd	r19, Y+2	; 0x02
    942a:	4b 81       	ldd	r20, Y+3	; 0x03
    942c:	5c 81       	ldd	r21, Y+4	; 0x04
    942e:	28 17       	cp	r18, r24
    9430:	39 07       	cpc	r19, r25
    9432:	4a 07       	cpc	r20, r26
    9434:	5b 07       	cpc	r21, r27
    9436:	08 f4       	brcc	.+2      	; 0x943a <searchNextFreeCluster+0x15a>
    9438:	74 cf       	rjmp	.-280    	; 0x9322 <searchNextFreeCluster+0x42>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    943a:	80 e0       	ldi	r24, 0x00	; 0
    943c:	90 e0       	ldi	r25, 0x00	; 0
    943e:	dc 01       	movw	r26, r24
}
    9440:	bc 01       	movw	r22, r24
    9442:	cd 01       	movw	r24, r26
    9444:	2f 96       	adiw	r28, 0x0f	; 15
    9446:	cd bf       	out	0x3d, r28	; 61
    9448:	de bf       	out	0x3e, r29	; 62
    944a:	df 91       	pop	r29
    944c:	cf 91       	pop	r28
    944e:	1f 91       	pop	r17
    9450:	0f 91       	pop	r16
    9452:	ff 90       	pop	r15
    9454:	ef 90       	pop	r14
    9456:	08 95       	ret

00009458 <deleteFile>:
//Function: to delete a specified file from the root directory
//Arguments: pointer to the file name
//return: none
//********************************************************************
void deleteFile (unsigned char *fileName)
{
    9458:	cf 93       	push	r28
    945a:	df 93       	push	r29
    945c:	00 d0       	rcall	.+0      	; 0x945e <deleteFile+0x6>
    945e:	cd b7       	in	r28, 0x3d	; 61
    9460:	de b7       	in	r29, 0x3e	; 62
    9462:	8a 83       	std	Y+2, r24	; 0x02
    9464:	9b 83       	std	Y+3, r25	; 0x03
  unsigned char error;

  error = convertFileName (fileName);
    9466:	8a 81       	ldd	r24, Y+2	; 0x02
    9468:	9b 81       	ldd	r25, Y+3	; 0x03
    946a:	0e 94 64 44 	call	0x88c8	; 0x88c8 <convertFileName>
    946e:	89 83       	std	Y+1, r24	; 0x01
  if(error) return;
    9470:	89 81       	ldd	r24, Y+1	; 0x01
    9472:	88 23       	and	r24, r24
    9474:	39 f4       	brne	.+14     	; 0x9484 <deleteFile+0x2c>

  findFiles (DELETE, Filename);
    9476:	2c eb       	ldi	r18, 0xBC	; 188
    9478:	30 e5       	ldi	r19, 0x50	; 80
    947a:	82 e0       	ldi	r24, 0x02	; 2
    947c:	b9 01       	movw	r22, r18
    947e:	0e 94 db 41 	call	0x83b6	; 0x83b6 <findFiles>
    9482:	01 c0       	rjmp	.+2      	; 0x9486 <deleteFile+0x2e>
void deleteFile (unsigned char *fileName)
{
  unsigned char error;

  error = convertFileName (fileName);
  if(error) return;
    9484:	00 00       	nop

  findFiles (DELETE, Filename);
}
    9486:	23 96       	adiw	r28, 0x03	; 3
    9488:	cd bf       	out	0x3d, r28	; 61
    948a:	de bf       	out	0x3e, r29	; 62
    948c:	df 91       	pop	r29
    948e:	cf 91       	pop	r28
    9490:	08 95       	ret

00009492 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    9492:	ef 92       	push	r14
    9494:	ff 92       	push	r15
    9496:	0f 93       	push	r16
    9498:	1f 93       	push	r17
    949a:	cf 93       	push	r28
    949c:	df 93       	push	r29
    949e:	cd b7       	in	r28, 0x3d	; 61
    94a0:	de b7       	in	r29, 0x3e	; 62
    94a2:	29 97       	sbiw	r28, 0x09	; 9
    94a4:	cd bf       	out	0x3d, r28	; 61
    94a6:	de bf       	out	0x3e, r29	; 62
    94a8:	8d 83       	std	Y+5, r24	; 0x05
    94aa:	4e 83       	std	Y+6, r20	; 0x06
    94ac:	5f 83       	std	Y+7, r21	; 0x07
    94ae:	68 87       	std	Y+8, r22	; 0x08
    94b0:	79 87       	std	Y+9, r23	; 0x09
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    94b2:	8e 81       	ldd	r24, Y+6	; 0x06
    94b4:	9f 81       	ldd	r25, Y+7	; 0x07
    94b6:	a8 85       	ldd	r26, Y+8	; 0x08
    94b8:	b9 85       	ldd	r27, Y+9	; 0x09
    94ba:	91 70       	andi	r25, 0x01	; 1
    94bc:	a0 70       	andi	r26, 0x00	; 0
    94be:	b0 70       	andi	r27, 0x00	; 0
    94c0:	00 97       	sbiw	r24, 0x00	; 0
    94c2:	a1 05       	cpc	r26, r1
    94c4:	b1 05       	cpc	r27, r1
    94c6:	91 f4       	brne	.+36     	; 0x94ec <freeMemoryUpdate+0x5a>
    94c8:	8e 81       	ldd	r24, Y+6	; 0x06
    94ca:	9f 81       	ldd	r25, Y+7	; 0x07
    94cc:	a8 85       	ldd	r26, Y+8	; 0x08
    94ce:	b9 85       	ldd	r27, Y+9	; 0x09
    94d0:	07 2e       	mov	r0, r23
    94d2:	79 e0       	ldi	r23, 0x09	; 9
    94d4:	b6 95       	lsr	r27
    94d6:	a7 95       	ror	r26
    94d8:	97 95       	ror	r25
    94da:	87 95       	ror	r24
    94dc:	7a 95       	dec	r23
    94de:	d1 f7       	brne	.-12     	; 0x94d4 <freeMemoryUpdate+0x42>
    94e0:	70 2d       	mov	r23, r0
    94e2:	8e 83       	std	Y+6, r24	; 0x06
    94e4:	9f 83       	std	Y+7, r25	; 0x07
    94e6:	a8 87       	std	Y+8, r26	; 0x08
    94e8:	b9 87       	std	Y+9, r27	; 0x09
    94ea:	14 c0       	rjmp	.+40     	; 0x9514 <freeMemoryUpdate+0x82>
  else size = (size / 512) +1;
    94ec:	8e 81       	ldd	r24, Y+6	; 0x06
    94ee:	9f 81       	ldd	r25, Y+7	; 0x07
    94f0:	a8 85       	ldd	r26, Y+8	; 0x08
    94f2:	b9 85       	ldd	r27, Y+9	; 0x09
    94f4:	07 2e       	mov	r0, r23
    94f6:	79 e0       	ldi	r23, 0x09	; 9
    94f8:	b6 95       	lsr	r27
    94fa:	a7 95       	ror	r26
    94fc:	97 95       	ror	r25
    94fe:	87 95       	ror	r24
    9500:	7a 95       	dec	r23
    9502:	d1 f7       	brne	.-12     	; 0x94f8 <freeMemoryUpdate+0x66>
    9504:	70 2d       	mov	r23, r0
    9506:	01 96       	adiw	r24, 0x01	; 1
    9508:	a1 1d       	adc	r26, r1
    950a:	b1 1d       	adc	r27, r1
    950c:	8e 83       	std	Y+6, r24	; 0x06
    950e:	9f 83       	std	Y+7, r25	; 0x07
    9510:	a8 87       	std	Y+8, r26	; 0x08
    9512:	b9 87       	std	Y+9, r27	; 0x09
  if((size % 8) == 0) size = size / 8;
    9514:	8e 81       	ldd	r24, Y+6	; 0x06
    9516:	9f 81       	ldd	r25, Y+7	; 0x07
    9518:	a8 85       	ldd	r26, Y+8	; 0x08
    951a:	b9 85       	ldd	r27, Y+9	; 0x09
    951c:	87 70       	andi	r24, 0x07	; 7
    951e:	90 70       	andi	r25, 0x00	; 0
    9520:	a0 70       	andi	r26, 0x00	; 0
    9522:	b0 70       	andi	r27, 0x00	; 0
    9524:	00 97       	sbiw	r24, 0x00	; 0
    9526:	a1 05       	cpc	r26, r1
    9528:	b1 05       	cpc	r27, r1
    952a:	89 f4       	brne	.+34     	; 0x954e <freeMemoryUpdate+0xbc>
    952c:	8e 81       	ldd	r24, Y+6	; 0x06
    952e:	9f 81       	ldd	r25, Y+7	; 0x07
    9530:	a8 85       	ldd	r26, Y+8	; 0x08
    9532:	b9 85       	ldd	r27, Y+9	; 0x09
    9534:	68 94       	set
    9536:	12 f8       	bld	r1, 2
    9538:	b6 95       	lsr	r27
    953a:	a7 95       	ror	r26
    953c:	97 95       	ror	r25
    953e:	87 95       	ror	r24
    9540:	16 94       	lsr	r1
    9542:	d1 f7       	brne	.-12     	; 0x9538 <freeMemoryUpdate+0xa6>
    9544:	8e 83       	std	Y+6, r24	; 0x06
    9546:	9f 83       	std	Y+7, r25	; 0x07
    9548:	a8 87       	std	Y+8, r26	; 0x08
    954a:	b9 87       	std	Y+9, r27	; 0x09
    954c:	13 c0       	rjmp	.+38     	; 0x9574 <freeMemoryUpdate+0xe2>
  else size = (size / 8) +1;
    954e:	8e 81       	ldd	r24, Y+6	; 0x06
    9550:	9f 81       	ldd	r25, Y+7	; 0x07
    9552:	a8 85       	ldd	r26, Y+8	; 0x08
    9554:	b9 85       	ldd	r27, Y+9	; 0x09
    9556:	68 94       	set
    9558:	12 f8       	bld	r1, 2
    955a:	b6 95       	lsr	r27
    955c:	a7 95       	ror	r26
    955e:	97 95       	ror	r25
    9560:	87 95       	ror	r24
    9562:	16 94       	lsr	r1
    9564:	d1 f7       	brne	.-12     	; 0x955a <freeMemoryUpdate+0xc8>
    9566:	01 96       	adiw	r24, 0x01	; 1
    9568:	a1 1d       	adc	r26, r1
    956a:	b1 1d       	adc	r27, r1
    956c:	8e 83       	std	Y+6, r24	; 0x06
    956e:	9f 83       	std	Y+7, r25	; 0x07
    9570:	a8 87       	std	Y+8, r26	; 0x08
    9572:	b9 87       	std	Y+9, r27	; 0x09

  if(freeClusterCountUpdated)
    9574:	80 91 d0 50 	lds	r24, 0x50D0
    9578:	88 23       	and	r24, r24
    957a:	e9 f1       	breq	.+122    	; 0x95f6 <freeMemoryUpdate+0x164>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    957c:	81 e0       	ldi	r24, 0x01	; 1
    957e:	60 e0       	ldi	r22, 0x00	; 0
    9580:	20 e0       	ldi	r18, 0x00	; 0
    9582:	30 e0       	ldi	r19, 0x00	; 0
    9584:	a9 01       	movw	r20, r18
    9586:	0e 94 2a 41 	call	0x8254	; 0x8254 <getSetFreeCluster>
    958a:	dc 01       	movw	r26, r24
    958c:	cb 01       	movw	r24, r22
    958e:	89 83       	std	Y+1, r24	; 0x01
    9590:	9a 83       	std	Y+2, r25	; 0x02
    9592:	ab 83       	std	Y+3, r26	; 0x03
    9594:	bc 83       	std	Y+4, r27	; 0x04
	if(flag == ADD)
    9596:	8d 81       	ldd	r24, Y+5	; 0x05
    9598:	88 23       	and	r24, r24
    959a:	89 f4       	brne	.+34     	; 0x95be <freeMemoryUpdate+0x12c>
  	   freeClusters = freeClusters + size;
    959c:	29 81       	ldd	r18, Y+1	; 0x01
    959e:	3a 81       	ldd	r19, Y+2	; 0x02
    95a0:	4b 81       	ldd	r20, Y+3	; 0x03
    95a2:	5c 81       	ldd	r21, Y+4	; 0x04
    95a4:	8e 81       	ldd	r24, Y+6	; 0x06
    95a6:	9f 81       	ldd	r25, Y+7	; 0x07
    95a8:	a8 85       	ldd	r26, Y+8	; 0x08
    95aa:	b9 85       	ldd	r27, Y+9	; 0x09
    95ac:	82 0f       	add	r24, r18
    95ae:	93 1f       	adc	r25, r19
    95b0:	a4 1f       	adc	r26, r20
    95b2:	b5 1f       	adc	r27, r21
    95b4:	89 83       	std	Y+1, r24	; 0x01
    95b6:	9a 83       	std	Y+2, r25	; 0x02
    95b8:	ab 83       	std	Y+3, r26	; 0x03
    95ba:	bc 83       	std	Y+4, r27	; 0x04
    95bc:	14 c0       	rjmp	.+40     	; 0x95e6 <freeMemoryUpdate+0x154>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    95be:	29 81       	ldd	r18, Y+1	; 0x01
    95c0:	3a 81       	ldd	r19, Y+2	; 0x02
    95c2:	4b 81       	ldd	r20, Y+3	; 0x03
    95c4:	5c 81       	ldd	r21, Y+4	; 0x04
    95c6:	8e 81       	ldd	r24, Y+6	; 0x06
    95c8:	9f 81       	ldd	r25, Y+7	; 0x07
    95ca:	a8 85       	ldd	r26, Y+8	; 0x08
    95cc:	b9 85       	ldd	r27, Y+9	; 0x09
    95ce:	79 01       	movw	r14, r18
    95d0:	8a 01       	movw	r16, r20
    95d2:	e8 1a       	sub	r14, r24
    95d4:	f9 0a       	sbc	r15, r25
    95d6:	0a 0b       	sbc	r16, r26
    95d8:	1b 0b       	sbc	r17, r27
    95da:	d8 01       	movw	r26, r16
    95dc:	c7 01       	movw	r24, r14
    95de:	89 83       	std	Y+1, r24	; 0x01
    95e0:	9a 83       	std	Y+2, r25	; 0x02
    95e2:	ab 83       	std	Y+3, r26	; 0x03
    95e4:	bc 83       	std	Y+4, r27	; 0x04
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    95e6:	29 81       	ldd	r18, Y+1	; 0x01
    95e8:	3a 81       	ldd	r19, Y+2	; 0x02
    95ea:	4b 81       	ldd	r20, Y+3	; 0x03
    95ec:	5c 81       	ldd	r21, Y+4	; 0x04
    95ee:	81 e0       	ldi	r24, 0x01	; 1
    95f0:	61 e0       	ldi	r22, 0x01	; 1
    95f2:	0e 94 2a 41 	call	0x8254	; 0x8254 <getSetFreeCluster>
  }
}
    95f6:	29 96       	adiw	r28, 0x09	; 9
    95f8:	cd bf       	out	0x3d, r28	; 61
    95fa:	de bf       	out	0x3e, r29	; 62
    95fc:	df 91       	pop	r29
    95fe:	cf 91       	pop	r28
    9600:	1f 91       	pop	r17
    9602:	0f 91       	pop	r16
    9604:	ff 90       	pop	r15
    9606:	ef 90       	pop	r14
    9608:	08 95       	ret

0000960a <SD_init>:
# include "E-000001-000009_firmware_rev_1_0.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    960a:	0f 93       	push	r16
    960c:	1f 93       	push	r17
    960e:	cf 93       	push	r28
    9610:	df 93       	push	r29
    9612:	cd b7       	in	r28, 0x3d	; 61
    9614:	de b7       	in	r29, 0x3e	; 62
    9616:	a9 97       	sbiw	r28, 0x29	; 41
    9618:	cd bf       	out	0x3d, r28	; 61
    961a:	de bf       	out	0x3e, r29	; 62
	ADCPower(TRUE);				//power up portEX
    961c:	81 e0       	ldi	r24, 0x01	; 1
    961e:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    9622:	81 e0       	ldi	r24, 0x01	; 1
    9624:	0e 94 0d 34 	call	0x681a	; 0x681a <Ext1Power>
    9628:	80 e0       	ldi	r24, 0x00	; 0
    962a:	90 e0       	ldi	r25, 0x00	; 0
    962c:	a8 ec       	ldi	r26, 0xC8	; 200
    962e:	b2 e4       	ldi	r27, 0x42	; 66
    9630:	8e 87       	std	Y+14, r24	; 0x0e
    9632:	9f 87       	std	Y+15, r25	; 0x0f
    9634:	a8 8b       	std	Y+16, r26	; 0x10
    9636:	b9 8b       	std	Y+17, r27	; 0x11
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    9638:	6e 85       	ldd	r22, Y+14	; 0x0e
    963a:	7f 85       	ldd	r23, Y+15	; 0x0f
    963c:	88 89       	ldd	r24, Y+16	; 0x10
    963e:	99 89       	ldd	r25, Y+17	; 0x11
    9640:	20 e0       	ldi	r18, 0x00	; 0
    9642:	30 e0       	ldi	r19, 0x00	; 0
    9644:	4a ef       	ldi	r20, 0xFA	; 250
    9646:	55 e4       	ldi	r21, 0x45	; 69
    9648:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    964c:	dc 01       	movw	r26, r24
    964e:	cb 01       	movw	r24, r22
    9650:	8a 8b       	std	Y+18, r24	; 0x12
    9652:	9b 8b       	std	Y+19, r25	; 0x13
    9654:	ac 8b       	std	Y+20, r26	; 0x14
    9656:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
    9658:	11 e0       	ldi	r17, 0x01	; 1
    965a:	6a 89       	ldd	r22, Y+18	; 0x12
    965c:	7b 89       	ldd	r23, Y+19	; 0x13
    965e:	8c 89       	ldd	r24, Y+20	; 0x14
    9660:	9d 89       	ldd	r25, Y+21	; 0x15
    9662:	20 e0       	ldi	r18, 0x00	; 0
    9664:	30 e0       	ldi	r19, 0x00	; 0
    9666:	40 e8       	ldi	r20, 0x80	; 128
    9668:	5f e3       	ldi	r21, 0x3F	; 63
    966a:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    966e:	88 23       	and	r24, r24
    9670:	0c f0       	brlt	.+2      	; 0x9674 <SD_init+0x6a>
    9672:	10 e0       	ldi	r17, 0x00	; 0
    9674:	11 23       	and	r17, r17
    9676:	29 f0       	breq	.+10     	; 0x9682 <SD_init+0x78>
		__ticks = 1;
    9678:	81 e0       	ldi	r24, 0x01	; 1
    967a:	90 e0       	ldi	r25, 0x00	; 0
    967c:	8e 8b       	std	Y+22, r24	; 0x16
    967e:	9f 8b       	std	Y+23, r25	; 0x17
    9680:	46 c0       	rjmp	.+140    	; 0x970e <SD_init+0x104>
	else if (__tmp > 65535)
    9682:	11 e0       	ldi	r17, 0x01	; 1
    9684:	6a 89       	ldd	r22, Y+18	; 0x12
    9686:	7b 89       	ldd	r23, Y+19	; 0x13
    9688:	8c 89       	ldd	r24, Y+20	; 0x14
    968a:	9d 89       	ldd	r25, Y+21	; 0x15
    968c:	20 e0       	ldi	r18, 0x00	; 0
    968e:	3f ef       	ldi	r19, 0xFF	; 255
    9690:	4f e7       	ldi	r20, 0x7F	; 127
    9692:	57 e4       	ldi	r21, 0x47	; 71
    9694:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    9698:	18 16       	cp	r1, r24
    969a:	0c f0       	brlt	.+2      	; 0x969e <SD_init+0x94>
    969c:	10 e0       	ldi	r17, 0x00	; 0
    969e:	11 23       	and	r17, r17
    96a0:	61 f1       	breq	.+88     	; 0x96fa <SD_init+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    96a2:	6e 85       	ldd	r22, Y+14	; 0x0e
    96a4:	7f 85       	ldd	r23, Y+15	; 0x0f
    96a6:	88 89       	ldd	r24, Y+16	; 0x10
    96a8:	99 89       	ldd	r25, Y+17	; 0x11
    96aa:	20 e0       	ldi	r18, 0x00	; 0
    96ac:	30 e0       	ldi	r19, 0x00	; 0
    96ae:	40 e2       	ldi	r20, 0x20	; 32
    96b0:	51 e4       	ldi	r21, 0x41	; 65
    96b2:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    96b6:	dc 01       	movw	r26, r24
    96b8:	cb 01       	movw	r24, r22
    96ba:	bc 01       	movw	r22, r24
    96bc:	cd 01       	movw	r24, r26
    96be:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    96c2:	dc 01       	movw	r26, r24
    96c4:	cb 01       	movw	r24, r22
    96c6:	8e 8b       	std	Y+22, r24	; 0x16
    96c8:	9f 8b       	std	Y+23, r25	; 0x17
    96ca:	12 c0       	rjmp	.+36     	; 0x96f0 <SD_init+0xe6>
    96cc:	80 e2       	ldi	r24, 0x20	; 32
    96ce:	93 e0       	ldi	r25, 0x03	; 3
    96d0:	88 8f       	std	Y+24, r24	; 0x18
    96d2:	99 8f       	std	Y+25, r25	; 0x19
    96d4:	88 8d       	ldd	r24, Y+24	; 0x18
    96d6:	99 8d       	ldd	r25, Y+25	; 0x19
    96d8:	8c 01       	movw	r16, r24
    96da:	c8 01       	movw	r24, r16
    96dc:	01 97       	sbiw	r24, 0x01	; 1
    96de:	f1 f7       	brne	.-4      	; 0x96dc <SD_init+0xd2>
    96e0:	8c 01       	movw	r16, r24
    96e2:	08 8f       	std	Y+24, r16	; 0x18
    96e4:	19 8f       	std	Y+25, r17	; 0x19
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    96e6:	8e 89       	ldd	r24, Y+22	; 0x16
    96e8:	9f 89       	ldd	r25, Y+23	; 0x17
    96ea:	01 97       	sbiw	r24, 0x01	; 1
    96ec:	8e 8b       	std	Y+22, r24	; 0x16
    96ee:	9f 8b       	std	Y+23, r25	; 0x17
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    96f0:	8e 89       	ldd	r24, Y+22	; 0x16
    96f2:	9f 89       	ldd	r25, Y+23	; 0x17
    96f4:	00 97       	sbiw	r24, 0x00	; 0
    96f6:	51 f7       	brne	.-44     	; 0x96cc <SD_init+0xc2>
    96f8:	17 c0       	rjmp	.+46     	; 0x9728 <SD_init+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    96fa:	6a 89       	ldd	r22, Y+18	; 0x12
    96fc:	7b 89       	ldd	r23, Y+19	; 0x13
    96fe:	8c 89       	ldd	r24, Y+20	; 0x14
    9700:	9d 89       	ldd	r25, Y+21	; 0x15
    9702:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    9706:	dc 01       	movw	r26, r24
    9708:	cb 01       	movw	r24, r22
    970a:	8e 8b       	std	Y+22, r24	; 0x16
    970c:	9f 8b       	std	Y+23, r25	; 0x17
    970e:	8e 89       	ldd	r24, Y+22	; 0x16
    9710:	9f 89       	ldd	r25, Y+23	; 0x17
    9712:	8a 8f       	std	Y+26, r24	; 0x1a
    9714:	9b 8f       	std	Y+27, r25	; 0x1b
    9716:	8a 8d       	ldd	r24, Y+26	; 0x1a
    9718:	9b 8d       	ldd	r25, Y+27	; 0x1b
    971a:	8c 01       	movw	r16, r24
    971c:	f8 01       	movw	r30, r16
    971e:	31 97       	sbiw	r30, 0x01	; 1
    9720:	f1 f7       	brne	.-4      	; 0x971e <SD_init+0x114>
    9722:	8f 01       	movw	r16, r30
    9724:	0a 8f       	std	Y+26, r16	; 0x1a
    9726:	1b 8f       	std	Y+27, r17	; 0x1b
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    9728:	19 82       	std	Y+1, r1	; 0x01

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    972a:	88 e0       	ldi	r24, 0x08	; 8
    972c:	60 e0       	ldi	r22, 0x00	; 0
    972e:	0e 94 77 32 	call	0x64ee	; 0x64ee <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9732:	88 e0       	ldi	r24, 0x08	; 8
    9734:	60 e0       	ldi	r22, 0x00	; 0
    9736:	0e 94 43 33 	call	0x6686	; 0x6686 <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    973a:	80 e0       	ldi	r24, 0x00	; 0
    973c:	90 e0       	ldi	r25, 0x00	; 0
    973e:	63 e0       	ldi	r22, 0x03	; 3
    9740:	70 e0       	ldi	r23, 0x00	; 0
    9742:	0e 94 3b 37 	call	0x6e76	; 0x6e76 <SPIInit2>
	SPICS(TRUE);
    9746:	81 e0       	ldi	r24, 0x01	; 1
    9748:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    974c:	1a 82       	std	Y+2, r1	; 0x02
    974e:	1b 82       	std	Y+3, r1	; 0x03
    9750:	17 c0       	rjmp	.+46     	; 0x9780 <SD_init+0x176>
		SPIC.DATA=SDHC_DUMMY_BYTE;
    9752:	80 ec       	ldi	r24, 0xC0	; 192
    9754:	98 e0       	ldi	r25, 0x08	; 8
    9756:	2f ef       	ldi	r18, 0xFF	; 255
    9758:	fc 01       	movw	r30, r24
    975a:	23 83       	std	Z+3, r18	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    975c:	00 00       	nop
    975e:	80 ec       	ldi	r24, 0xC0	; 192
    9760:	98 e0       	ldi	r25, 0x08	; 8
    9762:	fc 01       	movw	r30, r24
    9764:	82 81       	ldd	r24, Z+2	; 0x02
    9766:	88 23       	and	r24, r24
    9768:	d4 f7       	brge	.-12     	; 0x975e <SD_init+0x154>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    976a:	80 ec       	ldi	r24, 0xC0	; 192
    976c:	98 e0       	ldi	r25, 0x08	; 8
    976e:	fc 01       	movw	r30, r24
    9770:	83 81       	ldd	r24, Z+3	; 0x03
    9772:	80 93 bb 50 	sts	0x50BB, r24
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    9776:	8a 81       	ldd	r24, Y+2	; 0x02
    9778:	9b 81       	ldd	r25, Y+3	; 0x03
    977a:	01 96       	adiw	r24, 0x01	; 1
    977c:	8a 83       	std	Y+2, r24	; 0x02
    977e:	9b 83       	std	Y+3, r25	; 0x03
    9780:	8a 81       	ldd	r24, Y+2	; 0x02
    9782:	9b 81       	ldd	r25, Y+3	; 0x03
    9784:	8a 30       	cpi	r24, 0x0A	; 10
    9786:	91 05       	cpc	r25, r1
    9788:	24 f3       	brlt	.-56     	; 0x9752 <SD_init+0x148>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    978a:	80 e0       	ldi	r24, 0x00	; 0
    978c:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	SPIDisable();
    9790:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9794:	88 e0       	ldi	r24, 0x08	; 8
    9796:	60 e0       	ldi	r22, 0x00	; 0
    9798:	0e 94 a6 33 	call	0x674c	; 0x674c <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    979c:	80 e0       	ldi	r24, 0x00	; 0
    979e:	90 e0       	ldi	r25, 0x00	; 0
    97a0:	63 e0       	ldi	r22, 0x03	; 3
    97a2:	70 e0       	ldi	r23, 0x00	; 0
    97a4:	0e 94 3b 37 	call	0x6e76	; 0x6e76 <SPIInit2>
	SPICS(TRUE);
    97a8:	81 e0       	ldi	r24, 0x01	; 1
    97aa:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    97ae:	1c 82       	std	Y+4, r1	; 0x04
    97b0:	1d 82       	std	Y+5, r1	; 0x05
    97b2:	0d c0       	rjmp	.+26     	; 0x97ce <SD_init+0x1c4>
		if (i >= 10) {												//try command 10 times before timing out
    97b4:	8c 81       	ldd	r24, Y+4	; 0x04
    97b6:	9d 81       	ldd	r25, Y+5	; 0x05
    97b8:	8a 30       	cpi	r24, 0x0A	; 10
    97ba:	91 05       	cpc	r25, r1
    97bc:	1c f0       	brlt	.+6      	; 0x97c4 <SD_init+0x1ba>
			//there was no response to the first command
			errorCode = 1;
    97be:	81 e0       	ldi	r24, 0x01	; 1
    97c0:	89 83       	std	Y+1, r24	; 0x01
			break;
    97c2:	10 c0       	rjmp	.+32     	; 0x97e4 <SD_init+0x1da>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    97c4:	8c 81       	ldd	r24, Y+4	; 0x04
    97c6:	9d 81       	ldd	r25, Y+5	; 0x05
    97c8:	01 96       	adiw	r24, 0x01	; 1
    97ca:	8c 83       	std	Y+4, r24	; 0x04
    97cc:	9d 83       	std	Y+5, r25	; 0x05
    97ce:	80 e0       	ldi	r24, 0x00	; 0
    97d0:	40 e0       	ldi	r20, 0x00	; 0
    97d2:	50 e0       	ldi	r21, 0x00	; 0
    97d4:	ba 01       	movw	r22, r20
    97d6:	25 e9       	ldi	r18, 0x95	; 149
    97d8:	08 e0       	ldi	r16, 0x08	; 8
    97da:	10 e0       	ldi	r17, 0x00	; 0
    97dc:	0e 94 2e 4d 	call	0x9a5c	; 0x9a5c <SD_command>
    97e0:	81 30       	cpi	r24, 0x01	; 1
    97e2:	41 f7       	brne	.-48     	; 0x97b4 <SD_init+0x1aa>
    97e4:	80 e0       	ldi	r24, 0x00	; 0
    97e6:	90 e0       	ldi	r25, 0x00	; 0
    97e8:	a8 ec       	ldi	r26, 0xC8	; 200
    97ea:	b2 e4       	ldi	r27, 0x42	; 66
    97ec:	8c 8f       	std	Y+28, r24	; 0x1c
    97ee:	9d 8f       	std	Y+29, r25	; 0x1d
    97f0:	ae 8f       	std	Y+30, r26	; 0x1e
    97f2:	bf 8f       	std	Y+31, r27	; 0x1f
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    97f4:	6c 8d       	ldd	r22, Y+28	; 0x1c
    97f6:	7d 8d       	ldd	r23, Y+29	; 0x1d
    97f8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    97fa:	9f 8d       	ldd	r25, Y+31	; 0x1f
    97fc:	20 e0       	ldi	r18, 0x00	; 0
    97fe:	30 e0       	ldi	r19, 0x00	; 0
    9800:	4a ef       	ldi	r20, 0xFA	; 250
    9802:	55 e4       	ldi	r21, 0x45	; 69
    9804:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    9808:	dc 01       	movw	r26, r24
    980a:	cb 01       	movw	r24, r22
    980c:	88 a3       	lds	r24, 0x58
    980e:	99 a3       	lds	r25, 0x59
    9810:	aa a3       	lds	r26, 0x5a
    9812:	bb a3       	lds	r27, 0x5b
	if (__tmp < 1.0)
    9814:	11 e0       	ldi	r17, 0x01	; 1
    9816:	68 a1       	lds	r22, 0x48
    9818:	79 a1       	lds	r23, 0x49
    981a:	8a a1       	lds	r24, 0x4a
    981c:	9b a1       	lds	r25, 0x4b
    981e:	20 e0       	ldi	r18, 0x00	; 0
    9820:	30 e0       	ldi	r19, 0x00	; 0
    9822:	40 e8       	ldi	r20, 0x80	; 128
    9824:	5f e3       	ldi	r21, 0x3F	; 63
    9826:	0e 94 1f 5a 	call	0xb43e	; 0xb43e <__cmpsf2>
    982a:	88 23       	and	r24, r24
    982c:	0c f0       	brlt	.+2      	; 0x9830 <SD_init+0x226>
    982e:	10 e0       	ldi	r17, 0x00	; 0
    9830:	11 23       	and	r17, r17
    9832:	29 f0       	breq	.+10     	; 0x983e <SD_init+0x234>
		__ticks = 1;
    9834:	81 e0       	ldi	r24, 0x01	; 1
    9836:	90 e0       	ldi	r25, 0x00	; 0
    9838:	8c a3       	lds	r24, 0x5c
    983a:	9d a3       	lds	r25, 0x5d
    983c:	46 c0       	rjmp	.+140    	; 0x98ca <SD_init+0x2c0>
	else if (__tmp > 65535)
    983e:	11 e0       	ldi	r17, 0x01	; 1
    9840:	68 a1       	lds	r22, 0x48
    9842:	79 a1       	lds	r23, 0x49
    9844:	8a a1       	lds	r24, 0x4a
    9846:	9b a1       	lds	r25, 0x4b
    9848:	20 e0       	ldi	r18, 0x00	; 0
    984a:	3f ef       	ldi	r19, 0xFF	; 255
    984c:	4f e7       	ldi	r20, 0x7F	; 127
    984e:	57 e4       	ldi	r21, 0x47	; 71
    9850:	0e 94 2c 5b 	call	0xb658	; 0xb658 <__gesf2>
    9854:	18 16       	cp	r1, r24
    9856:	0c f0       	brlt	.+2      	; 0x985a <SD_init+0x250>
    9858:	10 e0       	ldi	r17, 0x00	; 0
    985a:	11 23       	and	r17, r17
    985c:	61 f1       	breq	.+88     	; 0x98b6 <SD_init+0x2ac>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    985e:	6c 8d       	ldd	r22, Y+28	; 0x1c
    9860:	7d 8d       	ldd	r23, Y+29	; 0x1d
    9862:	8e 8d       	ldd	r24, Y+30	; 0x1e
    9864:	9f 8d       	ldd	r25, Y+31	; 0x1f
    9866:	20 e0       	ldi	r18, 0x00	; 0
    9868:	30 e0       	ldi	r19, 0x00	; 0
    986a:	40 e2       	ldi	r20, 0x20	; 32
    986c:	51 e4       	ldi	r21, 0x41	; 65
    986e:	0e 94 30 5b 	call	0xb660	; 0xb660 <__mulsf3>
    9872:	dc 01       	movw	r26, r24
    9874:	cb 01       	movw	r24, r22
    9876:	bc 01       	movw	r22, r24
    9878:	cd 01       	movw	r24, r26
    987a:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    987e:	dc 01       	movw	r26, r24
    9880:	cb 01       	movw	r24, r22
    9882:	8c a3       	lds	r24, 0x5c
    9884:	9d a3       	lds	r25, 0x5d
    9886:	12 c0       	rjmp	.+36     	; 0x98ac <SD_init+0x2a2>
    9888:	80 e2       	ldi	r24, 0x20	; 32
    988a:	93 e0       	ldi	r25, 0x03	; 3
    988c:	8e a3       	lds	r24, 0x5e
    988e:	9f a3       	lds	r25, 0x5f
    9890:	8e a1       	lds	r24, 0x4e
    9892:	9f a1       	lds	r25, 0x4f
    9894:	8c 01       	movw	r16, r24
    9896:	c8 01       	movw	r24, r16
    9898:	01 97       	sbiw	r24, 0x01	; 1
    989a:	f1 f7       	brne	.-4      	; 0x9898 <SD_init+0x28e>
    989c:	8c 01       	movw	r16, r24
    989e:	0e a3       	lds	r16, 0x5e
    98a0:	1f a3       	lds	r17, 0x5f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    98a2:	8c a1       	lds	r24, 0x4c
    98a4:	9d a1       	lds	r25, 0x4d
    98a6:	01 97       	sbiw	r24, 0x01	; 1
    98a8:	8c a3       	lds	r24, 0x5c
    98aa:	9d a3       	lds	r25, 0x5d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    98ac:	8c a1       	lds	r24, 0x4c
    98ae:	9d a1       	lds	r25, 0x4d
    98b0:	00 97       	sbiw	r24, 0x00	; 0
    98b2:	51 f7       	brne	.-44     	; 0x9888 <SD_init+0x27e>
    98b4:	17 c0       	rjmp	.+46     	; 0x98e4 <SD_init+0x2da>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    98b6:	68 a1       	lds	r22, 0x48
    98b8:	79 a1       	lds	r23, 0x49
    98ba:	8a a1       	lds	r24, 0x4a
    98bc:	9b a1       	lds	r25, 0x4b
    98be:	0e 94 8b 5a 	call	0xb516	; 0xb516 <__fixunssfsi>
    98c2:	dc 01       	movw	r26, r24
    98c4:	cb 01       	movw	r24, r22
    98c6:	8c a3       	lds	r24, 0x5c
    98c8:	9d a3       	lds	r25, 0x5d
    98ca:	8c a1       	lds	r24, 0x4c
    98cc:	9d a1       	lds	r25, 0x4d
    98ce:	88 a7       	lds	r24, 0x78
    98d0:	99 a7       	lds	r25, 0x79
    98d2:	88 a5       	lds	r24, 0x68
    98d4:	99 a5       	lds	r25, 0x69
    98d6:	8c 01       	movw	r16, r24
    98d8:	f8 01       	movw	r30, r16
    98da:	31 97       	sbiw	r30, 0x01	; 1
    98dc:	f1 f7       	brne	.-4      	; 0x98da <SD_init+0x2d0>
    98de:	8f 01       	movw	r16, r30
    98e0:	08 a7       	lds	r16, 0x78
    98e2:	19 a7       	lds	r17, 0x79
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    98e4:	1e 82       	std	Y+6, r1	; 0x06
    98e6:	1f 82       	std	Y+7, r1	; 0x07
    98e8:	0d c0       	rjmp	.+26     	; 0x9904 <SD_init+0x2fa>
		if (i >= 10) {
    98ea:	8e 81       	ldd	r24, Y+6	; 0x06
    98ec:	9f 81       	ldd	r25, Y+7	; 0x07
    98ee:	8a 30       	cpi	r24, 0x0A	; 10
    98f0:	91 05       	cpc	r25, r1
    98f2:	1c f0       	brlt	.+6      	; 0x98fa <SD_init+0x2f0>
			//there was no response to the command
			errorCode = 1;
    98f4:	81 e0       	ldi	r24, 0x01	; 1
    98f6:	89 83       	std	Y+1, r24	; 0x01
			break;
    98f8:	11 c0       	rjmp	.+34     	; 0x991c <SD_init+0x312>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    98fa:	8e 81       	ldd	r24, Y+6	; 0x06
    98fc:	9f 81       	ldd	r25, Y+7	; 0x07
    98fe:	01 96       	adiw	r24, 0x01	; 1
    9900:	8e 83       	std	Y+6, r24	; 0x06
    9902:	9f 83       	std	Y+7, r25	; 0x07
    9904:	88 e0       	ldi	r24, 0x08	; 8
    9906:	4a ea       	ldi	r20, 0xAA	; 170
    9908:	51 e0       	ldi	r21, 0x01	; 1
    990a:	60 e0       	ldi	r22, 0x00	; 0
    990c:	70 e0       	ldi	r23, 0x00	; 0
    990e:	27 e8       	ldi	r18, 0x87	; 135
    9910:	08 e0       	ldi	r16, 0x08	; 8
    9912:	10 e0       	ldi	r17, 0x00	; 0
    9914:	0e 94 2e 4d 	call	0x9a5c	; 0x9a5c <SD_command>
    9918:	81 30       	cpi	r24, 0x01	; 1
    991a:	39 f7       	brne	.-50     	; 0x98ea <SD_init+0x2e0>
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    991c:	18 86       	std	Y+8, r1	; 0x08
    991e:	19 86       	std	Y+9, r1	; 0x09
    9920:	13 c0       	rjmp	.+38     	; 0x9948 <SD_init+0x33e>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    9922:	88 85       	ldd	r24, Y+8	; 0x08
    9924:	99 85       	ldd	r25, Y+9	; 0x09
    9926:	8c 01       	movw	r16, r24
    9928:	0e 5f       	subi	r16, 0xFE	; 254
    992a:	1f 4f       	sbci	r17, 0xFF	; 255
    992c:	8f ef       	ldi	r24, 0xFF	; 255
    992e:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9932:	28 2f       	mov	r18, r24
    9934:	c8 01       	movw	r24, r16
    9936:	81 55       	subi	r24, 0x51	; 81
    9938:	9f 4a       	sbci	r25, 0xAF	; 175
    993a:	fc 01       	movw	r30, r24
    993c:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    993e:	88 85       	ldd	r24, Y+8	; 0x08
    9940:	99 85       	ldd	r25, Y+9	; 0x09
    9942:	01 96       	adiw	r24, 0x01	; 1
    9944:	88 87       	std	Y+8, r24	; 0x08
    9946:	99 87       	std	Y+9, r25	; 0x09
    9948:	88 85       	ldd	r24, Y+8	; 0x08
    994a:	99 85       	ldd	r25, Y+9	; 0x09
    994c:	84 30       	cpi	r24, 0x04	; 4
    994e:	91 05       	cpc	r25, r1
    9950:	44 f3       	brlt	.-48     	; 0x9922 <SD_init+0x318>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    9952:	80 91 b3 50 	lds	r24, 0x50B3
    9956:	81 30       	cpi	r24, 0x01	; 1
    9958:	21 f4       	brne	.+8      	; 0x9962 <SD_init+0x358>
    995a:	80 91 b4 50 	lds	r24, 0x50B4
    995e:	8a 3a       	cpi	r24, 0xAA	; 170
    9960:	11 f0       	breq	.+4      	; 0x9966 <SD_init+0x35c>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    9962:	81 e0       	ldi	r24, 0x01	; 1
    9964:	89 83       	std	Y+1, r24	; 0x01
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    9966:	87 e3       	ldi	r24, 0x37	; 55
    9968:	40 e0       	ldi	r20, 0x00	; 0
    996a:	50 e0       	ldi	r21, 0x00	; 0
    996c:	ba 01       	movw	r22, r20
    996e:	2f ef       	ldi	r18, 0xFF	; 255
    9970:	08 e0       	ldi	r16, 0x08	; 8
    9972:	10 e0       	ldi	r17, 0x00	; 0
    9974:	0e 94 2e 4d 	call	0x9a5c	; 0x9a5c <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    9978:	81 e0       	ldi	r24, 0x01	; 1
    997a:	40 e0       	ldi	r20, 0x00	; 0
    997c:	50 e0       	ldi	r21, 0x00	; 0
    997e:	60 e0       	ldi	r22, 0x00	; 0
    9980:	70 e4       	ldi	r23, 0x40	; 64
    9982:	2f ef       	ldi	r18, 0xFF	; 255
    9984:	08 e0       	ldi	r16, 0x08	; 8
    9986:	10 e0       	ldi	r17, 0x00	; 0
    9988:	0e 94 2e 4d 	call	0x9a5c	; 0x9a5c <SD_command>
	} while(Buffer[1]!= 0x00);
    998c:	80 91 b0 50 	lds	r24, 0x50B0
    9990:	88 23       	and	r24, r24
    9992:	49 f7       	brne	.-46     	; 0x9966 <SD_init+0x35c>
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    9994:	1a 86       	std	Y+10, r1	; 0x0a
    9996:	1b 86       	std	Y+11, r1	; 0x0b
    9998:	0d c0       	rjmp	.+26     	; 0x99b4 <SD_init+0x3aa>
		if (i >= 10) {
    999a:	8a 85       	ldd	r24, Y+10	; 0x0a
    999c:	9b 85       	ldd	r25, Y+11	; 0x0b
    999e:	8a 30       	cpi	r24, 0x0A	; 10
    99a0:	91 05       	cpc	r25, r1
    99a2:	1c f0       	brlt	.+6      	; 0x99aa <SD_init+0x3a0>
			//there was no response to the command
			errorCode = 1;
    99a4:	81 e0       	ldi	r24, 0x01	; 1
    99a6:	89 83       	std	Y+1, r24	; 0x01
			break;
    99a8:	10 c0       	rjmp	.+32     	; 0x99ca <SD_init+0x3c0>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    99aa:	8a 85       	ldd	r24, Y+10	; 0x0a
    99ac:	9b 85       	ldd	r25, Y+11	; 0x0b
    99ae:	01 96       	adiw	r24, 0x01	; 1
    99b0:	8a 87       	std	Y+10, r24	; 0x0a
    99b2:	9b 87       	std	Y+11, r25	; 0x0b
    99b4:	8a e3       	ldi	r24, 0x3A	; 58
    99b6:	40 e0       	ldi	r20, 0x00	; 0
    99b8:	50 e0       	ldi	r21, 0x00	; 0
    99ba:	ba 01       	movw	r22, r20
    99bc:	2f ef       	ldi	r18, 0xFF	; 255
    99be:	08 e0       	ldi	r16, 0x08	; 8
    99c0:	10 e0       	ldi	r17, 0x00	; 0
    99c2:	0e 94 2e 4d 	call	0x9a5c	; 0x9a5c <SD_command>
    99c6:	88 23       	and	r24, r24
    99c8:	41 f7       	brne	.-48     	; 0x999a <SD_init+0x390>
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    99ca:	1c 86       	std	Y+12, r1	; 0x0c
    99cc:	1d 86       	std	Y+13, r1	; 0x0d
    99ce:	0f c0       	rjmp	.+30     	; 0x99ee <SD_init+0x3e4>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    99d0:	8f ef       	ldi	r24, 0xFF	; 255
    99d2:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    99d6:	28 2f       	mov	r18, r24
    99d8:	8c 85       	ldd	r24, Y+12	; 0x0c
    99da:	9d 85       	ldd	r25, Y+13	; 0x0d
    99dc:	81 55       	subi	r24, 0x51	; 81
    99de:	9f 4a       	sbci	r25, 0xAF	; 175
    99e0:	fc 01       	movw	r30, r24
    99e2:	20 83       	st	Z, r18
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    99e4:	8c 85       	ldd	r24, Y+12	; 0x0c
    99e6:	9d 85       	ldd	r25, Y+13	; 0x0d
    99e8:	01 96       	adiw	r24, 0x01	; 1
    99ea:	8c 87       	std	Y+12, r24	; 0x0c
    99ec:	9d 87       	std	Y+13, r25	; 0x0d
    99ee:	8c 85       	ldd	r24, Y+12	; 0x0c
    99f0:	9d 85       	ldd	r25, Y+13	; 0x0d
    99f2:	84 30       	cpi	r24, 0x04	; 4
    99f4:	91 05       	cpc	r25, r1
    99f6:	64 f3       	brlt	.-40     	; 0x99d0 <SD_init+0x3c6>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    99f8:	80 91 af 50 	lds	r24, 0x50AF
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    99fc:	80 e0       	ldi	r24, 0x00	; 0
    99fe:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	SPIDisable();
    9a02:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9a06:	88 e0       	ldi	r24, 0x08	; 8
    9a08:	60 e0       	ldi	r22, 0x00	; 0
    9a0a:	0e 94 43 33 	call	0x6686	; 0x6686 <PortEx_OUTSET>
	return errorCode;	
    9a0e:	89 81       	ldd	r24, Y+1	; 0x01
}	
    9a10:	a9 96       	adiw	r28, 0x29	; 41
    9a12:	cd bf       	out	0x3d, r28	; 61
    9a14:	de bf       	out	0x3e, r29	; 62
    9a16:	df 91       	pop	r29
    9a18:	cf 91       	pop	r28
    9a1a:	1f 91       	pop	r17
    9a1c:	0f 91       	pop	r16
    9a1e:	08 95       	ret

00009a20 <SPI_write>:

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
    9a20:	cf 93       	push	r28
    9a22:	df 93       	push	r29
    9a24:	0f 92       	push	r0
    9a26:	0f 92       	push	r0
    9a28:	cd b7       	in	r28, 0x3d	; 61
    9a2a:	de b7       	in	r29, 0x3e	; 62
    9a2c:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t data;
	SPIC.DATA = byteToSend;
    9a2e:	80 ec       	ldi	r24, 0xC0	; 192
    9a30:	98 e0       	ldi	r25, 0x08	; 8
    9a32:	2a 81       	ldd	r18, Y+2	; 0x02
    9a34:	fc 01       	movw	r30, r24
    9a36:	23 83       	std	Z+3, r18	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    9a38:	00 00       	nop
    9a3a:	80 ec       	ldi	r24, 0xC0	; 192
    9a3c:	98 e0       	ldi	r25, 0x08	; 8
    9a3e:	fc 01       	movw	r30, r24
    9a40:	82 81       	ldd	r24, Z+2	; 0x02
    9a42:	88 23       	and	r24, r24
    9a44:	d4 f7       	brge	.-12     	; 0x9a3a <SPI_write+0x1a>
	data = SPIC.DATA; //read SPI data register to reset status flag
    9a46:	80 ec       	ldi	r24, 0xC0	; 192
    9a48:	98 e0       	ldi	r25, 0x08	; 8
    9a4a:	fc 01       	movw	r30, r24
    9a4c:	83 81       	ldd	r24, Z+3	; 0x03
    9a4e:	89 83       	std	Y+1, r24	; 0x01
	return data;
    9a50:	89 81       	ldd	r24, Y+1	; 0x01
}
    9a52:	0f 90       	pop	r0
    9a54:	0f 90       	pop	r0
    9a56:	df 91       	pop	r29
    9a58:	cf 91       	pop	r28
    9a5a:	08 95       	ret

00009a5c <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    9a5c:	0f 93       	push	r16
    9a5e:	1f 93       	push	r17
    9a60:	cf 93       	push	r28
    9a62:	df 93       	push	r29
    9a64:	cd b7       	in	r28, 0x3d	; 61
    9a66:	de b7       	in	r29, 0x3e	; 62
    9a68:	2a 97       	sbiw	r28, 0x0a	; 10
    9a6a:	cd bf       	out	0x3d, r28	; 61
    9a6c:	de bf       	out	0x3e, r29	; 62
    9a6e:	8b 83       	std	Y+3, r24	; 0x03
    9a70:	4c 83       	std	Y+4, r20	; 0x04
    9a72:	5d 83       	std	Y+5, r21	; 0x05
    9a74:	6e 83       	std	Y+6, r22	; 0x06
    9a76:	7f 83       	std	Y+7, r23	; 0x07
    9a78:	28 87       	std	Y+8, r18	; 0x08
    9a7a:	09 87       	std	Y+9, r16	; 0x09
    9a7c:	1a 87       	std	Y+10, r17	; 0x0a
	
	SPI_write(SDHC_COMMAND_START | cmd);
    9a7e:	8b 81       	ldd	r24, Y+3	; 0x03
    9a80:	80 64       	ori	r24, 0x40	; 64
    9a82:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    9a86:	8c 81       	ldd	r24, Y+4	; 0x04
    9a88:	9d 81       	ldd	r25, Y+5	; 0x05
    9a8a:	ae 81       	ldd	r26, Y+6	; 0x06
    9a8c:	bf 81       	ldd	r27, Y+7	; 0x07
    9a8e:	8b 2f       	mov	r24, r27
    9a90:	99 27       	eor	r25, r25
    9a92:	aa 27       	eor	r26, r26
    9a94:	bb 27       	eor	r27, r27
    9a96:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    9a9a:	8c 81       	ldd	r24, Y+4	; 0x04
    9a9c:	9d 81       	ldd	r25, Y+5	; 0x05
    9a9e:	ae 81       	ldd	r26, Y+6	; 0x06
    9aa0:	bf 81       	ldd	r27, Y+7	; 0x07
    9aa2:	cd 01       	movw	r24, r26
    9aa4:	aa 27       	eor	r26, r26
    9aa6:	bb 27       	eor	r27, r27
    9aa8:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    9aac:	8c 81       	ldd	r24, Y+4	; 0x04
    9aae:	9d 81       	ldd	r25, Y+5	; 0x05
    9ab0:	ae 81       	ldd	r26, Y+6	; 0x06
    9ab2:	bf 81       	ldd	r27, Y+7	; 0x07
    9ab4:	89 2f       	mov	r24, r25
    9ab6:	9a 2f       	mov	r25, r26
    9ab8:	ab 2f       	mov	r26, r27
    9aba:	bb 27       	eor	r27, r27
    9abc:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    9ac0:	8c 81       	ldd	r24, Y+4	; 0x04
    9ac2:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
	SPI_write(crc);
    9ac6:	88 85       	ldd	r24, Y+8	; 0x08
    9ac8:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
	
	for(int i=0; i<read; i++){
    9acc:	19 82       	std	Y+1, r1	; 0x01
    9ace:	1a 82       	std	Y+2, r1	; 0x02
    9ad0:	33 c0       	rjmp	.+102    	; 0x9b38 <SD_command+0xdc>
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    9ad2:	89 81       	ldd	r24, Y+1	; 0x01
    9ad4:	9a 81       	ldd	r25, Y+2	; 0x02
    9ad6:	2d e0       	ldi	r18, 0x0D	; 13
    9ad8:	30 e0       	ldi	r19, 0x00	; 0
    9ada:	b9 01       	movw	r22, r18
    9adc:	0e 94 c6 5b 	call	0xb78c	; 0xb78c <__divmodhi4>
    9ae0:	8c 01       	movw	r16, r24
    9ae2:	8f ef       	ldi	r24, 0xFF	; 255
    9ae4:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9ae8:	28 2f       	mov	r18, r24
    9aea:	c8 01       	movw	r24, r16
    9aec:	81 55       	subi	r24, 0x51	; 81
    9aee:	9f 4a       	sbci	r25, 0xAF	; 175
    9af0:	fc 01       	movw	r30, r24
    9af2:	20 83       	st	Z, r18
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    9af4:	89 81       	ldd	r24, Y+1	; 0x01
    9af6:	9a 81       	ldd	r25, Y+2	; 0x02
    9af8:	2d e0       	ldi	r18, 0x0D	; 13
    9afa:	30 e0       	ldi	r19, 0x00	; 0
    9afc:	b9 01       	movw	r22, r18
    9afe:	0e 94 c6 5b 	call	0xb78c	; 0xb78c <__divmodhi4>
    9b02:	81 55       	subi	r24, 0x51	; 81
    9b04:	9f 4a       	sbci	r25, 0xAF	; 175
    9b06:	fc 01       	movw	r30, r24
    9b08:	80 81       	ld	r24, Z
    9b0a:	8f 3f       	cpi	r24, 0xFF	; 255
    9b0c:	81 f0       	breq	.+32     	; 0x9b2e <SD_command+0xd2>
			Buffer[1] = Buffer[i%13];
    9b0e:	89 81       	ldd	r24, Y+1	; 0x01
    9b10:	9a 81       	ldd	r25, Y+2	; 0x02
    9b12:	2d e0       	ldi	r18, 0x0D	; 13
    9b14:	30 e0       	ldi	r19, 0x00	; 0
    9b16:	b9 01       	movw	r22, r18
    9b18:	0e 94 c6 5b 	call	0xb78c	; 0xb78c <__divmodhi4>
    9b1c:	81 55       	subi	r24, 0x51	; 81
    9b1e:	9f 4a       	sbci	r25, 0xAF	; 175
    9b20:	fc 01       	movw	r30, r24
    9b22:	80 81       	ld	r24, Z
    9b24:	80 93 b0 50 	sts	0x50B0, r24
			return Buffer[1];
    9b28:	80 91 b0 50 	lds	r24, 0x50B0
    9b2c:	0d c0       	rjmp	.+26     	; 0x9b48 <SD_command+0xec>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    9b2e:	89 81       	ldd	r24, Y+1	; 0x01
    9b30:	9a 81       	ldd	r25, Y+2	; 0x02
    9b32:	01 96       	adiw	r24, 0x01	; 1
    9b34:	89 83       	std	Y+1, r24	; 0x01
    9b36:	9a 83       	std	Y+2, r25	; 0x02
    9b38:	29 81       	ldd	r18, Y+1	; 0x01
    9b3a:	3a 81       	ldd	r19, Y+2	; 0x02
    9b3c:	89 85       	ldd	r24, Y+9	; 0x09
    9b3e:	9a 85       	ldd	r25, Y+10	; 0x0a
    9b40:	28 17       	cp	r18, r24
    9b42:	39 07       	cpc	r19, r25
    9b44:	34 f2       	brlt	.-116    	; 0x9ad2 <SD_command+0x76>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    9b46:	8f ef       	ldi	r24, 0xFF	; 255
}
    9b48:	2a 96       	adiw	r28, 0x0a	; 10
    9b4a:	cd bf       	out	0x3d, r28	; 61
    9b4c:	de bf       	out	0x3e, r29	; 62
    9b4e:	df 91       	pop	r29
    9b50:	cf 91       	pop	r28
    9b52:	1f 91       	pop	r17
    9b54:	0f 91       	pop	r16
    9b56:	08 95       	ret

00009b58 <SD_write_block>:

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    9b58:	0f 93       	push	r16
    9b5a:	1f 93       	push	r17
    9b5c:	cf 93       	push	r28
    9b5e:	df 93       	push	r29
    9b60:	cd b7       	in	r28, 0x3d	; 61
    9b62:	de b7       	in	r29, 0x3e	; 62
    9b64:	62 97       	sbiw	r28, 0x12	; 18
    9b66:	cd bf       	out	0x3d, r28	; 61
    9b68:	de bf       	out	0x3e, r29	; 62
    9b6a:	6b 87       	std	Y+11, r22	; 0x0b
    9b6c:	7c 87       	std	Y+12, r23	; 0x0c
    9b6e:	8d 87       	std	Y+13, r24	; 0x0d
    9b70:	9e 87       	std	Y+14, r25	; 0x0e
    9b72:	4f 87       	std	Y+15, r20	; 0x0f
    9b74:	58 8b       	std	Y+16, r21	; 0x10
    9b76:	29 8b       	std	Y+17, r18	; 0x11
    9b78:	3a 8b       	std	Y+18, r19	; 0x12
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9b7a:	88 e0       	ldi	r24, 0x08	; 8
    9b7c:	60 e0       	ldi	r22, 0x00	; 0
    9b7e:	0e 94 a6 33 	call	0x674c	; 0x674c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9b82:	80 e0       	ldi	r24, 0x00	; 0
    9b84:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>
	SPICS(TRUE);
    9b88:	81 e0       	ldi	r24, 0x01	; 1
    9b8a:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    9b8e:	20 e0       	ldi	r18, 0x00	; 0
    9b90:	32 e0       	ldi	r19, 0x02	; 2
    9b92:	89 89       	ldd	r24, Y+17	; 0x11
    9b94:	9a 89       	ldd	r25, Y+18	; 0x12
    9b96:	a9 01       	movw	r20, r18
    9b98:	48 1b       	sub	r20, r24
    9b9a:	59 0b       	sbc	r21, r25
    9b9c:	ca 01       	movw	r24, r20
    9b9e:	89 83       	std	Y+1, r24	; 0x01
    9ba0:	9a 83       	std	Y+2, r25	; 0x02
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    9ba2:	89 81       	ldd	r24, Y+1	; 0x01
    9ba4:	9a 81       	ldd	r25, Y+2	; 0x02
    9ba6:	52 e0       	ldi	r21, 0x02	; 2
    9ba8:	80 30       	cpi	r24, 0x00	; 0
    9baa:	95 07       	cpc	r25, r21
    9bac:	11 f4       	brne	.+4      	; 0x9bb2 <SD_write_block+0x5a>
    9bae:	19 82       	std	Y+1, r1	; 0x01
    9bb0:	1a 82       	std	Y+2, r1	; 0x02
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9bb2:	1b 82       	std	Y+3, r1	; 0x03
    9bb4:	1c 82       	std	Y+4, r1	; 0x04
    9bb6:	0b c0       	rjmp	.+22     	; 0x9bce <SD_write_block+0x76>
	if (i >= 10) {
    9bb8:	8b 81       	ldd	r24, Y+3	; 0x03
    9bba:	9c 81       	ldd	r25, Y+4	; 0x04
    9bbc:	8a 30       	cpi	r24, 0x0A	; 10
    9bbe:	91 05       	cpc	r25, r1
    9bc0:	0c f0       	brlt	.+2      	; 0x9bc4 <SD_write_block+0x6c>
		//there was no response to the command
		while(1);
    9bc2:	ff cf       	rjmp	.-2      	; 0x9bc2 <SD_write_block+0x6a>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    9bc4:	8b 81       	ldd	r24, Y+3	; 0x03
    9bc6:	9c 81       	ldd	r25, Y+4	; 0x04
    9bc8:	01 96       	adiw	r24, 0x01	; 1
    9bca:	8b 83       	std	Y+3, r24	; 0x03
    9bcc:	9c 83       	std	Y+4, r25	; 0x04
    9bce:	2b 85       	ldd	r18, Y+11	; 0x0b
    9bd0:	3c 85       	ldd	r19, Y+12	; 0x0c
    9bd2:	4d 85       	ldd	r20, Y+13	; 0x0d
    9bd4:	5e 85       	ldd	r21, Y+14	; 0x0e
    9bd6:	88 e1       	ldi	r24, 0x18	; 24
    9bd8:	ba 01       	movw	r22, r20
    9bda:	a9 01       	movw	r20, r18
    9bdc:	2f ef       	ldi	r18, 0xFF	; 255
    9bde:	08 e0       	ldi	r16, 0x08	; 8
    9be0:	10 e0       	ldi	r17, 0x00	; 0
    9be2:	0e 94 2e 4d 	call	0x9a5c	; 0x9a5c <SD_command>
    9be6:	88 23       	and	r24, r24
    9be8:	39 f7       	brne	.-50     	; 0x9bb8 <SD_write_block+0x60>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    9bea:	8f ef       	ldi	r24, 0xFF	; 255
    9bec:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9bf0:	80 93 af 50 	sts	0x50AF, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    9bf4:	8e ef       	ldi	r24, 0xFE	; 254
    9bf6:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    9bfa:	1d 82       	std	Y+5, r1	; 0x05
    9bfc:	1e 82       	std	Y+6, r1	; 0x06
    9bfe:	1d c0       	rjmp	.+58     	; 0x9c3a <SD_write_block+0xe2>
Buffer[i%13] = SPI_write(data[i]);
    9c00:	8d 81       	ldd	r24, Y+5	; 0x05
    9c02:	9e 81       	ldd	r25, Y+6	; 0x06
    9c04:	2d e0       	ldi	r18, 0x0D	; 13
    9c06:	30 e0       	ldi	r19, 0x00	; 0
    9c08:	b9 01       	movw	r22, r18
    9c0a:	0e 94 c6 5b 	call	0xb78c	; 0xb78c <__divmodhi4>
    9c0e:	8c 01       	movw	r16, r24
    9c10:	8d 81       	ldd	r24, Y+5	; 0x05
    9c12:	9e 81       	ldd	r25, Y+6	; 0x06
    9c14:	2f 85       	ldd	r18, Y+15	; 0x0f
    9c16:	38 89       	ldd	r19, Y+16	; 0x10
    9c18:	82 0f       	add	r24, r18
    9c1a:	93 1f       	adc	r25, r19
    9c1c:	fc 01       	movw	r30, r24
    9c1e:	80 81       	ld	r24, Z
    9c20:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9c24:	28 2f       	mov	r18, r24
    9c26:	c8 01       	movw	r24, r16
    9c28:	81 55       	subi	r24, 0x51	; 81
    9c2a:	9f 4a       	sbci	r25, 0xAF	; 175
    9c2c:	fc 01       	movw	r30, r24
    9c2e:	20 83       	st	Z, r18
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    9c30:	8d 81       	ldd	r24, Y+5	; 0x05
    9c32:	9e 81       	ldd	r25, Y+6	; 0x06
    9c34:	01 96       	adiw	r24, 0x01	; 1
    9c36:	8d 83       	std	Y+5, r24	; 0x05
    9c38:	9e 83       	std	Y+6, r25	; 0x06
    9c3a:	2d 81       	ldd	r18, Y+5	; 0x05
    9c3c:	3e 81       	ldd	r19, Y+6	; 0x06
    9c3e:	89 89       	ldd	r24, Y+17	; 0x11
    9c40:	9a 89       	ldd	r25, Y+18	; 0x12
    9c42:	28 17       	cp	r18, r24
    9c44:	39 07       	cpc	r19, r25
    9c46:	e4 f2       	brlt	.-72     	; 0x9c00 <SD_write_block+0xa8>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    9c48:	1f 82       	std	Y+7, r1	; 0x07
    9c4a:	18 86       	std	Y+8, r1	; 0x08
    9c4c:	16 c0       	rjmp	.+44     	; 0x9c7a <SD_write_block+0x122>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    9c4e:	8f 81       	ldd	r24, Y+7	; 0x07
    9c50:	98 85       	ldd	r25, Y+8	; 0x08
    9c52:	2d e0       	ldi	r18, 0x0D	; 13
    9c54:	30 e0       	ldi	r19, 0x00	; 0
    9c56:	b9 01       	movw	r22, r18
    9c58:	0e 94 c6 5b 	call	0xb78c	; 0xb78c <__divmodhi4>
    9c5c:	8c 01       	movw	r16, r24
    9c5e:	80 e0       	ldi	r24, 0x00	; 0
    9c60:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9c64:	28 2f       	mov	r18, r24
    9c66:	c8 01       	movw	r24, r16
    9c68:	81 55       	subi	r24, 0x51	; 81
    9c6a:	9f 4a       	sbci	r25, 0xAF	; 175
    9c6c:	fc 01       	movw	r30, r24
    9c6e:	20 83       	st	Z, r18
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    9c70:	8f 81       	ldd	r24, Y+7	; 0x07
    9c72:	98 85       	ldd	r25, Y+8	; 0x08
    9c74:	01 96       	adiw	r24, 0x01	; 1
    9c76:	8f 83       	std	Y+7, r24	; 0x07
    9c78:	98 87       	std	Y+8, r25	; 0x08
    9c7a:	2f 81       	ldd	r18, Y+7	; 0x07
    9c7c:	38 85       	ldd	r19, Y+8	; 0x08
    9c7e:	89 81       	ldd	r24, Y+1	; 0x01
    9c80:	9a 81       	ldd	r25, Y+2	; 0x02
    9c82:	28 17       	cp	r18, r24
    9c84:	39 07       	cpc	r19, r25
    9c86:	1c f3       	brlt	.-58     	; 0x9c4e <SD_write_block+0xf6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    9c88:	8f ef       	ldi	r24, 0xFF	; 255
    9c8a:	80 93 af 50 	sts	0x50AF, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    9c8e:	19 86       	std	Y+9, r1	; 0x09
    9c90:	1a 86       	std	Y+10, r1	; 0x0a
    9c92:	0a c0       	rjmp	.+20     	; 0x9ca8 <SD_write_block+0x150>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    9c94:	8f ef       	ldi	r24, 0xFF	; 255
    9c96:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9c9a:	80 93 af 50 	sts	0x50AF, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    9c9e:	89 85       	ldd	r24, Y+9	; 0x09
    9ca0:	9a 85       	ldd	r25, Y+10	; 0x0a
    9ca2:	01 96       	adiw	r24, 0x01	; 1
    9ca4:	89 87       	std	Y+9, r24	; 0x09
    9ca6:	9a 87       	std	Y+10, r25	; 0x0a
    9ca8:	89 85       	ldd	r24, Y+9	; 0x09
    9caa:	9a 85       	ldd	r25, Y+10	; 0x0a
    9cac:	82 30       	cpi	r24, 0x02	; 2
    9cae:	91 05       	cpc	r25, r1
    9cb0:	8c f3       	brlt	.-30     	; 0x9c94 <SD_write_block+0x13c>
    9cb2:	80 91 af 50 	lds	r24, 0x50AF
    9cb6:	8f 3f       	cpi	r24, 0xFF	; 255
    9cb8:	69 f3       	breq	.-38     	; 0x9c94 <SD_write_block+0x13c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    9cba:	80 91 af 50 	lds	r24, 0x50AF
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    9cbe:	05 c0       	rjmp	.+10     	; 0x9cca <SD_write_block+0x172>
    9cc0:	8f ef       	ldi	r24, 0xFF	; 255
    9cc2:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9cc6:	80 93 af 50 	sts	0x50AF, r24
    9cca:	80 91 af 50 	lds	r24, 0x50AF
    9cce:	8f 3f       	cpi	r24, 0xFF	; 255
    9cd0:	b9 f7       	brne	.-18     	; 0x9cc0 <SD_write_block+0x168>
	SPICS(FALSE);
    9cd2:	80 e0       	ldi	r24, 0x00	; 0
    9cd4:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	SPIDisable();
    9cd8:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    9cdc:	88 e0       	ldi	r24, 0x08	; 8
    9cde:	60 e0       	ldi	r22, 0x00	; 0
    9ce0:	0e 94 43 33 	call	0x6686	; 0x6686 <PortEx_OUTSET>
}
    9ce4:	62 96       	adiw	r28, 0x12	; 18
    9ce6:	cd bf       	out	0x3d, r28	; 61
    9ce8:	de bf       	out	0x3e, r29	; 62
    9cea:	df 91       	pop	r29
    9cec:	cf 91       	pop	r28
    9cee:	1f 91       	pop	r17
    9cf0:	0f 91       	pop	r16
    9cf2:	08 95       	ret

00009cf4 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    9cf4:	0f 93       	push	r16
    9cf6:	1f 93       	push	r17
    9cf8:	cf 93       	push	r28
    9cfa:	df 93       	push	r29
    9cfc:	cd b7       	in	r28, 0x3d	; 61
    9cfe:	de b7       	in	r29, 0x3e	; 62
    9d00:	2a 97       	sbiw	r28, 0x0a	; 10
    9d02:	cd bf       	out	0x3d, r28	; 61
    9d04:	de bf       	out	0x3e, r29	; 62
    9d06:	6d 83       	std	Y+5, r22	; 0x05
    9d08:	7e 83       	std	Y+6, r23	; 0x06
    9d0a:	8f 83       	std	Y+7, r24	; 0x07
    9d0c:	98 87       	std	Y+8, r25	; 0x08
    9d0e:	49 87       	std	Y+9, r20	; 0x09
    9d10:	5a 87       	std	Y+10, r21	; 0x0a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9d12:	88 e0       	ldi	r24, 0x08	; 8
    9d14:	60 e0       	ldi	r22, 0x00	; 0
    9d16:	0e 94 a6 33 	call	0x674c	; 0x674c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9d1a:	80 e0       	ldi	r24, 0x00	; 0
    9d1c:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>
	SPICS(TRUE);
    9d20:	81 e0       	ldi	r24, 0x01	; 1
    9d22:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    9d26:	19 82       	std	Y+1, r1	; 0x01
    9d28:	1a 82       	std	Y+2, r1	; 0x02
    9d2a:	0b c0       	rjmp	.+22     	; 0x9d42 <SD_read_block+0x4e>
		if (i >= 10) {
    9d2c:	89 81       	ldd	r24, Y+1	; 0x01
    9d2e:	9a 81       	ldd	r25, Y+2	; 0x02
    9d30:	8a 30       	cpi	r24, 0x0A	; 10
    9d32:	91 05       	cpc	r25, r1
    9d34:	0c f0       	brlt	.+2      	; 0x9d38 <SD_read_block+0x44>
			//there was no response to the command
			while(1);
    9d36:	ff cf       	rjmp	.-2      	; 0x9d36 <SD_read_block+0x42>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    9d38:	89 81       	ldd	r24, Y+1	; 0x01
    9d3a:	9a 81       	ldd	r25, Y+2	; 0x02
    9d3c:	01 96       	adiw	r24, 0x01	; 1
    9d3e:	89 83       	std	Y+1, r24	; 0x01
    9d40:	9a 83       	std	Y+2, r25	; 0x02
    9d42:	2d 81       	ldd	r18, Y+5	; 0x05
    9d44:	3e 81       	ldd	r19, Y+6	; 0x06
    9d46:	4f 81       	ldd	r20, Y+7	; 0x07
    9d48:	58 85       	ldd	r21, Y+8	; 0x08
    9d4a:	81 e1       	ldi	r24, 0x11	; 17
    9d4c:	ba 01       	movw	r22, r20
    9d4e:	a9 01       	movw	r20, r18
    9d50:	2f ef       	ldi	r18, 0xFF	; 255
    9d52:	08 e0       	ldi	r16, 0x08	; 8
    9d54:	10 e0       	ldi	r17, 0x00	; 0
    9d56:	0e 94 2e 4d 	call	0x9a5c	; 0x9a5c <SD_command>
    9d5a:	88 23       	and	r24, r24
    9d5c:	39 f7       	brne	.-50     	; 0x9d2c <SD_read_block+0x38>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    9d5e:	05 c0       	rjmp	.+10     	; 0x9d6a <SD_read_block+0x76>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    9d60:	8f ef       	ldi	r24, 0xFF	; 255
    9d62:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9d66:	80 93 af 50 	sts	0x50AF, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    9d6a:	80 91 af 50 	lds	r24, 0x50AF
    9d6e:	8e 3f       	cpi	r24, 0xFE	; 254
    9d70:	b9 f7       	brne	.-18     	; 0x9d60 <SD_read_block+0x6c>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9d72:	1b 82       	std	Y+3, r1	; 0x03
    9d74:	1c 82       	std	Y+4, r1	; 0x04
    9d76:	11 c0       	rjmp	.+34     	; 0x9d9a <SD_read_block+0xa6>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    9d78:	8b 81       	ldd	r24, Y+3	; 0x03
    9d7a:	9c 81       	ldd	r25, Y+4	; 0x04
    9d7c:	29 85       	ldd	r18, Y+9	; 0x09
    9d7e:	3a 85       	ldd	r19, Y+10	; 0x0a
    9d80:	89 01       	movw	r16, r18
    9d82:	08 0f       	add	r16, r24
    9d84:	19 1f       	adc	r17, r25
    9d86:	8f ef       	ldi	r24, 0xFF	; 255
    9d88:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9d8c:	f8 01       	movw	r30, r16
    9d8e:	80 83       	st	Z, r24
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9d90:	8b 81       	ldd	r24, Y+3	; 0x03
    9d92:	9c 81       	ldd	r25, Y+4	; 0x04
    9d94:	01 96       	adiw	r24, 0x01	; 1
    9d96:	8b 83       	std	Y+3, r24	; 0x03
    9d98:	9c 83       	std	Y+4, r25	; 0x04
    9d9a:	8b 81       	ldd	r24, Y+3	; 0x03
    9d9c:	9c 81       	ldd	r25, Y+4	; 0x04
    9d9e:	f2 e0       	ldi	r31, 0x02	; 2
    9da0:	80 30       	cpi	r24, 0x00	; 0
    9da2:	9f 07       	cpc	r25, r31
    9da4:	4c f3       	brlt	.-46     	; 0x9d78 <SD_read_block+0x84>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    9da6:	10 92 bb 50 	sts	0x50BB, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    9daa:	05 c0       	rjmp	.+10     	; 0x9db6 <SD_read_block+0xc2>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    9dac:	8f ef       	ldi	r24, 0xFF	; 255
    9dae:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9db2:	80 93 bb 50 	sts	0x50BB, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    9db6:	80 91 bb 50 	lds	r24, 0x50BB
    9dba:	8f 3f       	cpi	r24, 0xFF	; 255
    9dbc:	b9 f7       	brne	.-18     	; 0x9dac <SD_read_block+0xb8>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    9dbe:	80 e0       	ldi	r24, 0x00	; 0
    9dc0:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	SPIDisable();
    9dc4:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    9dc8:	88 e0       	ldi	r24, 0x08	; 8
    9dca:	60 e0       	ldi	r22, 0x00	; 0
    9dcc:	0e 94 43 33 	call	0x6686	; 0x6686 <PortEx_OUTSET>
}
    9dd0:	2a 96       	adiw	r28, 0x0a	; 10
    9dd2:	cd bf       	out	0x3d, r28	; 61
    9dd4:	de bf       	out	0x3e, r29	; 62
    9dd6:	df 91       	pop	r29
    9dd8:	cf 91       	pop	r28
    9dda:	1f 91       	pop	r17
    9ddc:	0f 91       	pop	r16
    9dde:	08 95       	ret

00009de0 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    9de0:	0f 93       	push	r16
    9de2:	1f 93       	push	r17
    9de4:	cf 93       	push	r28
    9de6:	df 93       	push	r29
    9de8:	cd b7       	in	r28, 0x3d	; 61
    9dea:	de b7       	in	r29, 0x3e	; 62
    9dec:	6a 97       	sbiw	r28, 0x1a	; 26
    9dee:	cd bf       	out	0x3d, r28	; 61
    9df0:	de bf       	out	0x3e, r29	; 62
    9df2:	6b 8b       	std	Y+19, r22	; 0x13
    9df4:	7c 8b       	std	Y+20, r23	; 0x14
    9df6:	8d 8b       	std	Y+21, r24	; 0x15
    9df8:	9e 8b       	std	Y+22, r25	; 0x16
    9dfa:	4f 8b       	std	Y+23, r20	; 0x17
    9dfc:	58 8f       	std	Y+24, r21	; 0x18
    9dfe:	29 8f       	std	Y+25, r18	; 0x19
    9e00:	3a 8f       	std	Y+26, r19	; 0x1a
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    9e02:	88 e0       	ldi	r24, 0x08	; 8
    9e04:	60 e0       	ldi	r22, 0x00	; 0
    9e06:	0e 94 a6 33 	call	0x674c	; 0x674c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    9e0a:	80 e0       	ldi	r24, 0x00	; 0
    9e0c:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>
	SPICS(TRUE);
    9e10:	81 e0       	ldi	r24, 0x01	; 1
    9e12:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    9e16:	89 8d       	ldd	r24, Y+25	; 0x19
    9e18:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9e1a:	99 23       	and	r25, r25
    9e1c:	14 f4       	brge	.+4      	; 0x9e22 <SD_write_multiple_blocks+0x42>
    9e1e:	81 50       	subi	r24, 0x01	; 1
    9e20:	9e 4f       	sbci	r25, 0xFE	; 254
    9e22:	89 2f       	mov	r24, r25
    9e24:	99 0f       	add	r25, r25
    9e26:	99 0b       	sbc	r25, r25
    9e28:	85 95       	asr	r24
    9e2a:	89 83       	std	Y+1, r24	; 0x01
    9e2c:	9a 83       	std	Y+2, r25	; 0x02
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    9e2e:	89 8d       	ldd	r24, Y+25	; 0x19
    9e30:	9a 8d       	ldd	r25, Y+26	; 0x1a
    9e32:	20 e0       	ldi	r18, 0x00	; 0
    9e34:	32 e0       	ldi	r19, 0x02	; 2
    9e36:	b9 01       	movw	r22, r18
    9e38:	0e 94 c6 5b 	call	0xb78c	; 0xb78c <__divmodhi4>
    9e3c:	20 e0       	ldi	r18, 0x00	; 0
    9e3e:	32 e0       	ldi	r19, 0x02	; 2
    9e40:	a9 01       	movw	r20, r18
    9e42:	48 1b       	sub	r20, r24
    9e44:	59 0b       	sbc	r21, r25
    9e46:	ca 01       	movw	r24, r20
    9e48:	8b 83       	std	Y+3, r24	; 0x03
    9e4a:	9c 83       	std	Y+4, r25	; 0x04
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    9e4c:	8b 81       	ldd	r24, Y+3	; 0x03
    9e4e:	9c 81       	ldd	r25, Y+4	; 0x04
    9e50:	52 e0       	ldi	r21, 0x02	; 2
    9e52:	80 30       	cpi	r24, 0x00	; 0
    9e54:	95 07       	cpc	r25, r21
    9e56:	19 f4       	brne	.+6      	; 0x9e5e <SD_write_multiple_blocks+0x7e>
    9e58:	1b 82       	std	Y+3, r1	; 0x03
    9e5a:	1c 82       	std	Y+4, r1	; 0x04
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    9e5c:	05 c0       	rjmp	.+10     	; 0x9e68 <SD_write_multiple_blocks+0x88>
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
    9e5e:	89 81       	ldd	r24, Y+1	; 0x01
    9e60:	9a 81       	ldd	r25, Y+2	; 0x02
    9e62:	01 96       	adiw	r24, 0x01	; 1
    9e64:	89 83       	std	Y+1, r24	; 0x01
    9e66:	9a 83       	std	Y+2, r25	; 0x02
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    9e68:	00 00       	nop
    9e6a:	2b 89       	ldd	r18, Y+19	; 0x13
    9e6c:	3c 89       	ldd	r19, Y+20	; 0x14
    9e6e:	4d 89       	ldd	r20, Y+21	; 0x15
    9e70:	5e 89       	ldd	r21, Y+22	; 0x16
    9e72:	89 e1       	ldi	r24, 0x19	; 25
    9e74:	ba 01       	movw	r22, r20
    9e76:	a9 01       	movw	r20, r18
    9e78:	2f ef       	ldi	r18, 0xFF	; 255
    9e7a:	08 e0       	ldi	r16, 0x08	; 8
    9e7c:	10 e0       	ldi	r17, 0x00	; 0
    9e7e:	0e 94 2e 4d 	call	0x9a5c	; 0x9a5c <SD_command>
    9e82:	88 23       	and	r24, r24
    9e84:	91 f7       	brne	.-28     	; 0x9e6a <SD_write_multiple_blocks+0x8a>
	for (int j=0;j<numSectors;j++){
    9e86:	1d 82       	std	Y+5, r1	; 0x05
    9e88:	1e 82       	std	Y+6, r1	; 0x06
    9e8a:	ba c0       	rjmp	.+372    	; 0xa000 <SD_write_multiple_blocks+0x220>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    9e8c:	8f ef       	ldi	r24, 0xFF	; 255
    9e8e:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9e92:	80 93 b0 50 	sts	0x50B0, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    9e96:	8c ef       	ldi	r24, 0xFC	; 252
    9e98:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9e9c:	80 93 b0 50 	sts	0x50B0, r24
		if(j == (numSectors-1)){
    9ea0:	89 81       	ldd	r24, Y+1	; 0x01
    9ea2:	9a 81       	ldd	r25, Y+2	; 0x02
    9ea4:	9c 01       	movw	r18, r24
    9ea6:	21 50       	subi	r18, 0x01	; 1
    9ea8:	30 40       	sbci	r19, 0x00	; 0
    9eaa:	8d 81       	ldd	r24, Y+5	; 0x05
    9eac:	9e 81       	ldd	r25, Y+6	; 0x06
    9eae:	28 17       	cp	r18, r24
    9eb0:	39 07       	cpc	r19, r25
    9eb2:	09 f0       	breq	.+2      	; 0x9eb6 <SD_write_multiple_blocks+0xd6>
    9eb4:	54 c0       	rjmp	.+168    	; 0x9f5e <SD_write_multiple_blocks+0x17e>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    9eb6:	1f 82       	std	Y+7, r1	; 0x07
    9eb8:	18 86       	std	Y+8, r1	; 0x08
    9eba:	25 c0       	rjmp	.+74     	; 0x9f06 <SD_write_multiple_blocks+0x126>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    9ebc:	8f 81       	ldd	r24, Y+7	; 0x07
    9ebe:	98 85       	ldd	r25, Y+8	; 0x08
    9ec0:	2c e0       	ldi	r18, 0x0C	; 12
    9ec2:	30 e0       	ldi	r19, 0x00	; 0
    9ec4:	b9 01       	movw	r22, r18
    9ec6:	0e 94 c6 5b 	call	0xb78c	; 0xb78c <__divmodhi4>
    9eca:	8c 01       	movw	r16, r24
    9ecc:	8d 81       	ldd	r24, Y+5	; 0x05
    9ece:	9e 81       	ldd	r25, Y+6	; 0x06
    9ed0:	9c 01       	movw	r18, r24
    9ed2:	32 2f       	mov	r19, r18
    9ed4:	22 27       	eor	r18, r18
    9ed6:	33 0f       	add	r19, r19
    9ed8:	8f 81       	ldd	r24, Y+7	; 0x07
    9eda:	98 85       	ldd	r25, Y+8	; 0x08
    9edc:	82 0f       	add	r24, r18
    9ede:	93 1f       	adc	r25, r19
    9ee0:	2f 89       	ldd	r18, Y+23	; 0x17
    9ee2:	38 8d       	ldd	r19, Y+24	; 0x18
    9ee4:	82 0f       	add	r24, r18
    9ee6:	93 1f       	adc	r25, r19
    9ee8:	fc 01       	movw	r30, r24
    9eea:	80 81       	ld	r24, Z
    9eec:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9ef0:	28 2f       	mov	r18, r24
    9ef2:	c8 01       	movw	r24, r16
    9ef4:	81 55       	subi	r24, 0x51	; 81
    9ef6:	9f 4a       	sbci	r25, 0xAF	; 175
    9ef8:	fc 01       	movw	r30, r24
    9efa:	20 83       	st	Z, r18
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    9efc:	8f 81       	ldd	r24, Y+7	; 0x07
    9efe:	98 85       	ldd	r25, Y+8	; 0x08
    9f00:	01 96       	adiw	r24, 0x01	; 1
    9f02:	8f 83       	std	Y+7, r24	; 0x07
    9f04:	98 87       	std	Y+8, r25	; 0x08
    9f06:	20 e0       	ldi	r18, 0x00	; 0
    9f08:	32 e0       	ldi	r19, 0x02	; 2
    9f0a:	8b 81       	ldd	r24, Y+3	; 0x03
    9f0c:	9c 81       	ldd	r25, Y+4	; 0x04
    9f0e:	28 1b       	sub	r18, r24
    9f10:	39 0b       	sbc	r19, r25
    9f12:	8f 81       	ldd	r24, Y+7	; 0x07
    9f14:	98 85       	ldd	r25, Y+8	; 0x08
    9f16:	82 17       	cp	r24, r18
    9f18:	93 07       	cpc	r25, r19
    9f1a:	84 f2       	brlt	.-96     	; 0x9ebc <SD_write_multiple_blocks+0xdc>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    9f1c:	19 86       	std	Y+9, r1	; 0x09
    9f1e:	1a 86       	std	Y+10, r1	; 0x0a
    9f20:	16 c0       	rjmp	.+44     	; 0x9f4e <SD_write_multiple_blocks+0x16e>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    9f22:	89 85       	ldd	r24, Y+9	; 0x09
    9f24:	9a 85       	ldd	r25, Y+10	; 0x0a
    9f26:	2c e0       	ldi	r18, 0x0C	; 12
    9f28:	30 e0       	ldi	r19, 0x00	; 0
    9f2a:	b9 01       	movw	r22, r18
    9f2c:	0e 94 c6 5b 	call	0xb78c	; 0xb78c <__divmodhi4>
    9f30:	8c 01       	movw	r16, r24
    9f32:	80 e0       	ldi	r24, 0x00	; 0
    9f34:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9f38:	28 2f       	mov	r18, r24
    9f3a:	c8 01       	movw	r24, r16
    9f3c:	81 55       	subi	r24, 0x51	; 81
    9f3e:	9f 4a       	sbci	r25, 0xAF	; 175
    9f40:	fc 01       	movw	r30, r24
    9f42:	20 83       	st	Z, r18
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    9f44:	89 85       	ldd	r24, Y+9	; 0x09
    9f46:	9a 85       	ldd	r25, Y+10	; 0x0a
    9f48:	01 96       	adiw	r24, 0x01	; 1
    9f4a:	89 87       	std	Y+9, r24	; 0x09
    9f4c:	9a 87       	std	Y+10, r25	; 0x0a
    9f4e:	29 85       	ldd	r18, Y+9	; 0x09
    9f50:	3a 85       	ldd	r19, Y+10	; 0x0a
    9f52:	8b 81       	ldd	r24, Y+3	; 0x03
    9f54:	9c 81       	ldd	r25, Y+4	; 0x04
    9f56:	28 17       	cp	r18, r24
    9f58:	39 07       	cpc	r19, r25
    9f5a:	1c f3       	brlt	.-58     	; 0x9f22 <SD_write_multiple_blocks+0x142>
    9f5c:	2e c0       	rjmp	.+92     	; 0x9fba <SD_write_multiple_blocks+0x1da>
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9f5e:	1b 86       	std	Y+11, r1	; 0x0b
    9f60:	1c 86       	std	Y+12, r1	; 0x0c
    9f62:	25 c0       	rjmp	.+74     	; 0x9fae <SD_write_multiple_blocks+0x1ce>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    9f64:	8b 85       	ldd	r24, Y+11	; 0x0b
    9f66:	9c 85       	ldd	r25, Y+12	; 0x0c
    9f68:	2c e0       	ldi	r18, 0x0C	; 12
    9f6a:	30 e0       	ldi	r19, 0x00	; 0
    9f6c:	b9 01       	movw	r22, r18
    9f6e:	0e 94 c6 5b 	call	0xb78c	; 0xb78c <__divmodhi4>
    9f72:	8c 01       	movw	r16, r24
    9f74:	8d 81       	ldd	r24, Y+5	; 0x05
    9f76:	9e 81       	ldd	r25, Y+6	; 0x06
    9f78:	9c 01       	movw	r18, r24
    9f7a:	32 2f       	mov	r19, r18
    9f7c:	22 27       	eor	r18, r18
    9f7e:	33 0f       	add	r19, r19
    9f80:	8b 85       	ldd	r24, Y+11	; 0x0b
    9f82:	9c 85       	ldd	r25, Y+12	; 0x0c
    9f84:	82 0f       	add	r24, r18
    9f86:	93 1f       	adc	r25, r19
    9f88:	2f 89       	ldd	r18, Y+23	; 0x17
    9f8a:	38 8d       	ldd	r19, Y+24	; 0x18
    9f8c:	82 0f       	add	r24, r18
    9f8e:	93 1f       	adc	r25, r19
    9f90:	fc 01       	movw	r30, r24
    9f92:	80 81       	ld	r24, Z
    9f94:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9f98:	28 2f       	mov	r18, r24
    9f9a:	c8 01       	movw	r24, r16
    9f9c:	81 55       	subi	r24, 0x51	; 81
    9f9e:	9f 4a       	sbci	r25, 0xAF	; 175
    9fa0:	fc 01       	movw	r30, r24
    9fa2:	20 83       	st	Z, r18
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    9fa4:	8b 85       	ldd	r24, Y+11	; 0x0b
    9fa6:	9c 85       	ldd	r25, Y+12	; 0x0c
    9fa8:	01 96       	adiw	r24, 0x01	; 1
    9faa:	8b 87       	std	Y+11, r24	; 0x0b
    9fac:	9c 87       	std	Y+12, r25	; 0x0c
    9fae:	8b 85       	ldd	r24, Y+11	; 0x0b
    9fb0:	9c 85       	ldd	r25, Y+12	; 0x0c
    9fb2:	f2 e0       	ldi	r31, 0x02	; 2
    9fb4:	80 30       	cpi	r24, 0x00	; 0
    9fb6:	9f 07       	cpc	r25, r31
    9fb8:	ac f2       	brlt	.-86     	; 0x9f64 <SD_write_multiple_blocks+0x184>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    9fba:	1d 86       	std	Y+13, r1	; 0x0d
    9fbc:	1e 86       	std	Y+14, r1	; 0x0e
    9fbe:	0a c0       	rjmp	.+20     	; 0x9fd4 <SD_write_multiple_blocks+0x1f4>
    9fc0:	8f ef       	ldi	r24, 0xFF	; 255
    9fc2:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9fc6:	80 93 b0 50 	sts	0x50B0, r24
    9fca:	8d 85       	ldd	r24, Y+13	; 0x0d
    9fcc:	9e 85       	ldd	r25, Y+14	; 0x0e
    9fce:	01 96       	adiw	r24, 0x01	; 1
    9fd0:	8d 87       	std	Y+13, r24	; 0x0d
    9fd2:	9e 87       	std	Y+14, r25	; 0x0e
    9fd4:	8d 85       	ldd	r24, Y+13	; 0x0d
    9fd6:	9e 85       	ldd	r25, Y+14	; 0x0e
    9fd8:	82 30       	cpi	r24, 0x02	; 2
    9fda:	91 05       	cpc	r25, r1
    9fdc:	8c f3       	brlt	.-30     	; 0x9fc0 <SD_write_multiple_blocks+0x1e0>
		Buffer[1] = FILLER_BYTE;
    9fde:	10 92 b0 50 	sts	0x50B0, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    9fe2:	05 c0       	rjmp	.+10     	; 0x9fee <SD_write_multiple_blocks+0x20e>
    9fe4:	8f ef       	ldi	r24, 0xFF	; 255
    9fe6:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    9fea:	80 93 b0 50 	sts	0x50B0, r24
    9fee:	80 91 b0 50 	lds	r24, 0x50B0
    9ff2:	8f 3f       	cpi	r24, 0xFF	; 255
    9ff4:	b9 f7       	brne	.-18     	; 0x9fe4 <SD_write_multiple_blocks+0x204>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    9ff6:	8d 81       	ldd	r24, Y+5	; 0x05
    9ff8:	9e 81       	ldd	r25, Y+6	; 0x06
    9ffa:	01 96       	adiw	r24, 0x01	; 1
    9ffc:	8d 83       	std	Y+5, r24	; 0x05
    9ffe:	9e 83       	std	Y+6, r25	; 0x06
    a000:	2d 81       	ldd	r18, Y+5	; 0x05
    a002:	3e 81       	ldd	r19, Y+6	; 0x06
    a004:	89 81       	ldd	r24, Y+1	; 0x01
    a006:	9a 81       	ldd	r25, Y+2	; 0x02
    a008:	28 17       	cp	r18, r24
    a00a:	39 07       	cpc	r19, r25
    a00c:	0c f4       	brge	.+2      	; 0xa010 <SD_write_multiple_blocks+0x230>
    a00e:	3e cf       	rjmp	.-388    	; 0x9e8c <SD_write_multiple_blocks+0xac>
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a010:	1f 86       	std	Y+15, r1	; 0x0f
    a012:	18 8a       	std	Y+16, r1	; 0x10
    a014:	0a c0       	rjmp	.+20     	; 0xa02a <SD_write_multiple_blocks+0x24a>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a016:	8f ef       	ldi	r24, 0xFF	; 255
    a018:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    a01c:	80 93 b0 50 	sts	0x50B0, r24
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    a020:	8f 85       	ldd	r24, Y+15	; 0x0f
    a022:	98 89       	ldd	r25, Y+16	; 0x10
    a024:	01 96       	adiw	r24, 0x01	; 1
    a026:	8f 87       	std	Y+15, r24	; 0x0f
    a028:	98 8b       	std	Y+16, r25	; 0x10
    a02a:	8f 85       	ldd	r24, Y+15	; 0x0f
    a02c:	98 89       	ldd	r25, Y+16	; 0x10
    a02e:	84 30       	cpi	r24, 0x04	; 4
    a030:	91 05       	cpc	r25, r1
    a032:	8c f3       	brlt	.-30     	; 0xa016 <SD_write_multiple_blocks+0x236>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    a034:	8d ef       	ldi	r24, 0xFD	; 253
    a036:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    a03a:	80 93 b0 50 	sts	0x50B0, r24
	for(int i=0;i<4;i++){
    a03e:	19 8a       	std	Y+17, r1	; 0x11
    a040:	1a 8a       	std	Y+18, r1	; 0x12
    a042:	0a c0       	rjmp	.+20     	; 0xa058 <SD_write_multiple_blocks+0x278>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    a044:	8f ef       	ldi	r24, 0xFF	; 255
    a046:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    a04a:	80 93 b0 50 	sts	0x50B0, r24
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    a04e:	89 89       	ldd	r24, Y+17	; 0x11
    a050:	9a 89       	ldd	r25, Y+18	; 0x12
    a052:	01 96       	adiw	r24, 0x01	; 1
    a054:	89 8b       	std	Y+17, r24	; 0x11
    a056:	9a 8b       	std	Y+18, r25	; 0x12
    a058:	89 89       	ldd	r24, Y+17	; 0x11
    a05a:	9a 89       	ldd	r25, Y+18	; 0x12
    a05c:	84 30       	cpi	r24, 0x04	; 4
    a05e:	91 05       	cpc	r25, r1
    a060:	8c f3       	brlt	.-30     	; 0xa044 <SD_write_multiple_blocks+0x264>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    a062:	10 92 b0 50 	sts	0x50B0, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a066:	05 c0       	rjmp	.+10     	; 0xa072 <SD_write_multiple_blocks+0x292>
    a068:	8f ef       	ldi	r24, 0xFF	; 255
    a06a:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    a06e:	80 93 b0 50 	sts	0x50B0, r24
    a072:	80 91 b0 50 	lds	r24, 0x50B0
    a076:	8f 3f       	cpi	r24, 0xFF	; 255
    a078:	b9 f7       	brne	.-18     	; 0xa068 <SD_write_multiple_blocks+0x288>
	SPICS(FALSE);
    a07a:	80 e0       	ldi	r24, 0x00	; 0
    a07c:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	SPIDisable();
    a080:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a084:	88 e0       	ldi	r24, 0x08	; 8
    a086:	60 e0       	ldi	r22, 0x00	; 0
    a088:	0e 94 43 33 	call	0x6686	; 0x6686 <PortEx_OUTSET>
}
    a08c:	6a 96       	adiw	r28, 0x1a	; 26
    a08e:	cd bf       	out	0x3d, r28	; 61
    a090:	de bf       	out	0x3e, r29	; 62
    a092:	df 91       	pop	r29
    a094:	cf 91       	pop	r28
    a096:	1f 91       	pop	r17
    a098:	0f 91       	pop	r16
    a09a:	08 95       	ret

0000a09c <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    a09c:	0f 93       	push	r16
    a09e:	1f 93       	push	r17
    a0a0:	cf 93       	push	r28
    a0a2:	df 93       	push	r29
    a0a4:	cd b7       	in	r28, 0x3d	; 61
    a0a6:	de b7       	in	r29, 0x3e	; 62
    a0a8:	2e 97       	sbiw	r28, 0x0e	; 14
    a0aa:	cd bf       	out	0x3d, r28	; 61
    a0ac:	de bf       	out	0x3e, r29	; 62
    a0ae:	6f 83       	std	Y+7, r22	; 0x07
    a0b0:	78 87       	std	Y+8, r23	; 0x08
    a0b2:	89 87       	std	Y+9, r24	; 0x09
    a0b4:	9a 87       	std	Y+10, r25	; 0x0a
    a0b6:	4b 87       	std	Y+11, r20	; 0x0b
    a0b8:	5c 87       	std	Y+12, r21	; 0x0c
    a0ba:	2d 87       	std	Y+13, r18	; 0x0d
    a0bc:	3e 87       	std	Y+14, r19	; 0x0e
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    a0be:	88 e0       	ldi	r24, 0x08	; 8
    a0c0:	60 e0       	ldi	r22, 0x00	; 0
    a0c2:	0e 94 a6 33 	call	0x674c	; 0x674c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    a0c6:	80 e0       	ldi	r24, 0x00	; 0
    a0c8:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>
	SPICS(TRUE);
    a0cc:	81 e0       	ldi	r24, 0x01	; 1
    a0ce:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    a0d2:	00 00       	nop
    a0d4:	2f 81       	ldd	r18, Y+7	; 0x07
    a0d6:	38 85       	ldd	r19, Y+8	; 0x08
    a0d8:	49 85       	ldd	r20, Y+9	; 0x09
    a0da:	5a 85       	ldd	r21, Y+10	; 0x0a
    a0dc:	82 e1       	ldi	r24, 0x12	; 18
    a0de:	ba 01       	movw	r22, r20
    a0e0:	a9 01       	movw	r20, r18
    a0e2:	2f ef       	ldi	r18, 0xFF	; 255
    a0e4:	08 e0       	ldi	r16, 0x08	; 8
    a0e6:	10 e0       	ldi	r17, 0x00	; 0
    a0e8:	0e 94 2e 4d 	call	0x9a5c	; 0x9a5c <SD_command>
    a0ec:	88 23       	and	r24, r24
    a0ee:	91 f7       	brne	.-28     	; 0xa0d4 <SD_read_multiple_blocks+0x38>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a0f0:	19 82       	std	Y+1, r1	; 0x01
    a0f2:	1a 82       	std	Y+2, r1	; 0x02
    a0f4:	4b c0       	rjmp	.+150    	; 0xa18c <SD_read_multiple_blocks+0xf0>
		Buffer[1]=SDHC_DUMMY_BYTE;
    a0f6:	8f ef       	ldi	r24, 0xFF	; 255
    a0f8:	80 93 b0 50 	sts	0x50B0, r24
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a0fc:	05 c0       	rjmp	.+10     	; 0xa108 <SD_read_multiple_blocks+0x6c>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    a0fe:	8f ef       	ldi	r24, 0xFF	; 255
    a100:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    a104:	80 93 b0 50 	sts	0x50B0, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    a108:	80 91 b0 50 	lds	r24, 0x50B0
    a10c:	8e 3f       	cpi	r24, 0xFE	; 254
    a10e:	b9 f7       	brne	.-18     	; 0xa0fe <SD_read_multiple_blocks+0x62>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a110:	1b 82       	std	Y+3, r1	; 0x03
    a112:	1c 82       	std	Y+4, r1	; 0x04
    a114:	19 c0       	rjmp	.+50     	; 0xa148 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    a116:	89 81       	ldd	r24, Y+1	; 0x01
    a118:	9a 81       	ldd	r25, Y+2	; 0x02
    a11a:	9c 01       	movw	r18, r24
    a11c:	32 2f       	mov	r19, r18
    a11e:	22 27       	eor	r18, r18
    a120:	33 0f       	add	r19, r19
    a122:	8b 81       	ldd	r24, Y+3	; 0x03
    a124:	9c 81       	ldd	r25, Y+4	; 0x04
    a126:	82 0f       	add	r24, r18
    a128:	93 1f       	adc	r25, r19
    a12a:	2b 85       	ldd	r18, Y+11	; 0x0b
    a12c:	3c 85       	ldd	r19, Y+12	; 0x0c
    a12e:	89 01       	movw	r16, r18
    a130:	08 0f       	add	r16, r24
    a132:	19 1f       	adc	r17, r25
    a134:	8f ef       	ldi	r24, 0xFF	; 255
    a136:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    a13a:	f8 01       	movw	r30, r16
    a13c:	80 83       	st	Z, r24
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    a13e:	8b 81       	ldd	r24, Y+3	; 0x03
    a140:	9c 81       	ldd	r25, Y+4	; 0x04
    a142:	01 96       	adiw	r24, 0x01	; 1
    a144:	8b 83       	std	Y+3, r24	; 0x03
    a146:	9c 83       	std	Y+4, r25	; 0x04
    a148:	8b 81       	ldd	r24, Y+3	; 0x03
    a14a:	9c 81       	ldd	r25, Y+4	; 0x04
    a14c:	f2 e0       	ldi	r31, 0x02	; 2
    a14e:	80 30       	cpi	r24, 0x00	; 0
    a150:	9f 07       	cpc	r25, r31
    a152:	0c f3       	brlt	.-62     	; 0xa116 <SD_read_multiple_blocks+0x7a>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a154:	1d 82       	std	Y+5, r1	; 0x05
    a156:	1e 82       	std	Y+6, r1	; 0x06
    a158:	0f c0       	rjmp	.+30     	; 0xa178 <SD_read_multiple_blocks+0xdc>
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    a15a:	8f ef       	ldi	r24, 0xFF	; 255
    a15c:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    a160:	28 2f       	mov	r18, r24
    a162:	8d 81       	ldd	r24, Y+5	; 0x05
    a164:	9e 81       	ldd	r25, Y+6	; 0x06
    a166:	81 55       	subi	r24, 0x51	; 81
    a168:	9f 4a       	sbci	r25, 0xAF	; 175
    a16a:	fc 01       	movw	r30, r24
    a16c:	20 83       	st	Z, r18
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
    a16e:	8d 81       	ldd	r24, Y+5	; 0x05
    a170:	9e 81       	ldd	r25, Y+6	; 0x06
    a172:	01 96       	adiw	r24, 0x01	; 1
    a174:	8d 83       	std	Y+5, r24	; 0x05
    a176:	9e 83       	std	Y+6, r25	; 0x06
    a178:	8d 81       	ldd	r24, Y+5	; 0x05
    a17a:	9e 81       	ldd	r25, Y+6	; 0x06
    a17c:	82 30       	cpi	r24, 0x02	; 2
    a17e:	91 05       	cpc	r25, r1
    a180:	64 f3       	brlt	.-40     	; 0xa15a <SD_read_multiple_blocks+0xbe>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    a182:	89 81       	ldd	r24, Y+1	; 0x01
    a184:	9a 81       	ldd	r25, Y+2	; 0x02
    a186:	01 96       	adiw	r24, 0x01	; 1
    a188:	89 83       	std	Y+1, r24	; 0x01
    a18a:	9a 83       	std	Y+2, r25	; 0x02
    a18c:	29 81       	ldd	r18, Y+1	; 0x01
    a18e:	3a 81       	ldd	r19, Y+2	; 0x02
    a190:	8d 85       	ldd	r24, Y+13	; 0x0d
    a192:	9e 85       	ldd	r25, Y+14	; 0x0e
    a194:	28 17       	cp	r18, r24
    a196:	39 07       	cpc	r19, r25
    a198:	0c f4       	brge	.+2      	; 0xa19c <SD_read_multiple_blocks+0x100>
    a19a:	ad cf       	rjmp	.-166    	; 0xa0f6 <SD_read_multiple_blocks+0x5a>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    a19c:	8c e0       	ldi	r24, 0x0C	; 12
    a19e:	40 e0       	ldi	r20, 0x00	; 0
    a1a0:	50 e0       	ldi	r21, 0x00	; 0
    a1a2:	ba 01       	movw	r22, r20
    a1a4:	2f ef       	ldi	r18, 0xFF	; 255
    a1a6:	08 e0       	ldi	r16, 0x08	; 8
    a1a8:	10 e0       	ldi	r17, 0x00	; 0
    a1aa:	0e 94 2e 4d 	call	0x9a5c	; 0x9a5c <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    a1ae:	8f ef       	ldi	r24, 0xFF	; 255
    a1b0:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    a1b4:	80 93 af 50 	sts	0x50AF, r24
	Buffer[1] = FILLER_BYTE;
    a1b8:	10 92 b0 50 	sts	0x50B0, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    a1bc:	05 c0       	rjmp	.+10     	; 0xa1c8 <SD_read_multiple_blocks+0x12c>
    a1be:	8f ef       	ldi	r24, 0xFF	; 255
    a1c0:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
    a1c4:	80 93 b0 50 	sts	0x50B0, r24
    a1c8:	80 91 b0 50 	lds	r24, 0x50B0
    a1cc:	8f 3f       	cpi	r24, 0xFF	; 255
    a1ce:	b9 f7       	brne	.-18     	; 0xa1be <SD_read_multiple_blocks+0x122>
	SPICS(FALSE);
    a1d0:	80 e0       	ldi	r24, 0x00	; 0
    a1d2:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	SPIDisable();
    a1d6:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    a1da:	88 e0       	ldi	r24, 0x08	; 8
    a1dc:	60 e0       	ldi	r22, 0x00	; 0
    a1de:	0e 94 43 33 	call	0x6686	; 0x6686 <PortEx_OUTSET>
}
    a1e2:	2e 96       	adiw	r28, 0x0e	; 14
    a1e4:	cd bf       	out	0x3d, r28	; 61
    a1e6:	de bf       	out	0x3e, r29	; 62
    a1e8:	df 91       	pop	r29
    a1ea:	cf 91       	pop	r28
    a1ec:	1f 91       	pop	r17
    a1ee:	0f 91       	pop	r16
    a1f0:	08 95       	ret

0000a1f2 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
    a1f2:	cf 93       	push	r28
    a1f4:	df 93       	push	r29
    a1f6:	cd b7       	in	r28, 0x3d	; 61
    a1f8:	de b7       	in	r29, 0x3e	; 62
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    a1fa:	88 e0       	ldi	r24, 0x08	; 8
    a1fc:	60 e0       	ldi	r22, 0x00	; 0
    a1fe:	0e 94 77 32 	call	0x64ee	; 0x64ee <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    a202:	88 e0       	ldi	r24, 0x08	; 8
    a204:	60 e0       	ldi	r22, 0x00	; 0
    a206:	0e 94 43 33 	call	0x6686	; 0x6686 <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    a20a:	80 e0       	ldi	r24, 0x00	; 0
    a20c:	0e 94 13 37 	call	0x6e26	; 0x6e26 <SPIInit>
	SPICS(TRUE);
    a210:	81 e0       	ldi	r24, 0x01	; 1
    a212:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    a216:	8f ef       	ldi	r24, 0xFF	; 255
    a218:	0e 94 10 4d 	call	0x9a20	; 0x9a20 <SPI_write>
	SPICS(FALSE);	//stop spi
    a21c:	80 e0       	ldi	r24, 0x00	; 0
    a21e:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <SPICS>
	SPIDisable();
    a222:	0e 94 80 37 	call	0x6f00	; 0x6f00 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    a226:	80 e0       	ldi	r24, 0x00	; 0
    a228:	0e 94 d1 05 	call	0xba2	; 0xba2 <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    a22c:	80 e0       	ldi	r24, 0x00	; 0
    a22e:	0e 94 0d 34 	call	0x681a	; 0x681a <Ext1Power>
}
    a232:	df 91       	pop	r29
    a234:	cf 91       	pop	r28
    a236:	08 95       	ret

0000a238 <__muldi3>:
    a238:	a0 e3       	ldi	r26, 0x30	; 48
    a23a:	b0 e0       	ldi	r27, 0x00	; 0
    a23c:	e2 e2       	ldi	r30, 0x22	; 34
    a23e:	f1 e5       	ldi	r31, 0x51	; 81
    a240:	0c 94 18 5c 	jmp	0xb830	; 0xb830 <__prologue_saves__+0x4>
    a244:	29 8f       	std	Y+25, r18	; 0x19
    a246:	3a 8f       	std	Y+26, r19	; 0x1a
    a248:	4b 8f       	std	Y+27, r20	; 0x1b
    a24a:	5c 8f       	std	Y+28, r21	; 0x1c
    a24c:	6d 8f       	std	Y+29, r22	; 0x1d
    a24e:	7e 8f       	std	Y+30, r23	; 0x1e
    a250:	8f 8f       	std	Y+31, r24	; 0x1f
    a252:	98 a3       	lds	r25, 0x58
    a254:	a9 8a       	std	Y+17, r10	; 0x11
    a256:	ba 8a       	std	Y+18, r11	; 0x12
    a258:	cb 8a       	std	Y+19, r12	; 0x13
    a25a:	dc 8a       	std	Y+20, r13	; 0x14
    a25c:	ed 8a       	std	Y+21, r14	; 0x15
    a25e:	fe 8a       	std	Y+22, r15	; 0x16
    a260:	0f 8b       	std	Y+23, r16	; 0x17
    a262:	18 8f       	std	Y+24, r17	; 0x18
    a264:	09 8d       	ldd	r16, Y+25	; 0x19
    a266:	1a 8d       	ldd	r17, Y+26	; 0x1a
    a268:	2b 8d       	ldd	r18, Y+27	; 0x1b
    a26a:	3c 8d       	ldd	r19, Y+28	; 0x1c
    a26c:	09 a3       	lds	r16, 0x59
    a26e:	1a a3       	lds	r17, 0x5a
    a270:	2b a3       	lds	r18, 0x5b
    a272:	3c a3       	lds	r19, 0x5c
    a274:	68 01       	movw	r12, r16
    a276:	79 01       	movw	r14, r18
    a278:	8f ef       	ldi	r24, 0xFF	; 255
    a27a:	9f ef       	ldi	r25, 0xFF	; 255
    a27c:	a0 e0       	ldi	r26, 0x00	; 0
    a27e:	b0 e0       	ldi	r27, 0x00	; 0
    a280:	c8 22       	and	r12, r24
    a282:	d9 22       	and	r13, r25
    a284:	ea 22       	and	r14, r26
    a286:	fb 22       	and	r15, r27
    a288:	89 01       	movw	r16, r18
    a28a:	22 27       	eor	r18, r18
    a28c:	33 27       	eor	r19, r19
    a28e:	09 a7       	lds	r16, 0x79
    a290:	1a a7       	lds	r17, 0x7a
    a292:	2b a7       	lds	r18, 0x7b
    a294:	3c a7       	lds	r19, 0x7c
    a296:	09 89       	ldd	r16, Y+17	; 0x11
    a298:	1a 89       	ldd	r17, Y+18	; 0x12
    a29a:	2b 89       	ldd	r18, Y+19	; 0x13
    a29c:	3c 89       	ldd	r19, Y+20	; 0x14
    a29e:	0d a3       	lds	r16, 0x5d
    a2a0:	1e a3       	lds	r17, 0x5e
    a2a2:	2f a3       	lds	r18, 0x5f
    a2a4:	38 a7       	lds	r19, 0x78
    a2a6:	48 01       	movw	r8, r16
    a2a8:	59 01       	movw	r10, r18
    a2aa:	88 22       	and	r8, r24
    a2ac:	99 22       	and	r9, r25
    a2ae:	aa 22       	and	r10, r26
    a2b0:	bb 22       	and	r11, r27
    a2b2:	29 01       	movw	r4, r18
    a2b4:	66 24       	eor	r6, r6
    a2b6:	77 24       	eor	r7, r7
    a2b8:	c5 01       	movw	r24, r10
    a2ba:	b4 01       	movw	r22, r8
    a2bc:	a7 01       	movw	r20, r14
    a2be:	96 01       	movw	r18, r12
    a2c0:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    a2c4:	6d a7       	lds	r22, 0x7d
    a2c6:	7e a7       	lds	r23, 0x7e
    a2c8:	8f a7       	lds	r24, 0x7f
    a2ca:	98 ab       	sts	0x58, r25
    a2cc:	c3 01       	movw	r24, r6
    a2ce:	b2 01       	movw	r22, r4
    a2d0:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    a2d4:	6b 01       	movw	r12, r22
    a2d6:	7c 01       	movw	r14, r24
    a2d8:	c5 01       	movw	r24, r10
    a2da:	b4 01       	movw	r22, r8
    a2dc:	29 a5       	lds	r18, 0x69
    a2de:	3a a5       	lds	r19, 0x6a
    a2e0:	4b a5       	lds	r20, 0x6b
    a2e2:	5c a5       	lds	r21, 0x6c
    a2e4:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    a2e8:	4b 01       	movw	r8, r22
    a2ea:	5c 01       	movw	r10, r24
    a2ec:	c3 01       	movw	r24, r6
    a2ee:	b2 01       	movw	r22, r4
    a2f0:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    a2f4:	ab 01       	movw	r20, r22
    a2f6:	bc 01       	movw	r22, r24
    a2f8:	c8 0c       	add	r12, r8
    a2fa:	d9 1c       	adc	r13, r9
    a2fc:	ea 1c       	adc	r14, r10
    a2fe:	fb 1c       	adc	r15, r11
    a300:	0d a5       	lds	r16, 0x6d
    a302:	1e a5       	lds	r17, 0x6e
    a304:	2f a5       	lds	r18, 0x6f
    a306:	38 a9       	sts	0x48, r19
    a308:	c9 01       	movw	r24, r18
    a30a:	aa 27       	eor	r26, r26
    a30c:	bb 27       	eor	r27, r27
    a30e:	c8 0e       	add	r12, r24
    a310:	d9 1e       	adc	r13, r25
    a312:	ea 1e       	adc	r14, r26
    a314:	fb 1e       	adc	r15, r27
    a316:	c8 14       	cp	r12, r8
    a318:	d9 04       	cpc	r13, r9
    a31a:	ea 04       	cpc	r14, r10
    a31c:	fb 04       	cpc	r15, r11
    a31e:	20 f4       	brcc	.+8      	; 0xa328 <__muldi3+0xf0>
    a320:	40 50       	subi	r20, 0x00	; 0
    a322:	50 40       	sbci	r21, 0x00	; 0
    a324:	6f 4f       	sbci	r22, 0xFF	; 255
    a326:	7f 4f       	sbci	r23, 0xFF	; 255
    a328:	c7 01       	movw	r24, r14
    a32a:	aa 27       	eor	r26, r26
    a32c:	bb 27       	eor	r27, r27
    a32e:	84 0f       	add	r24, r20
    a330:	95 1f       	adc	r25, r21
    a332:	a6 1f       	adc	r26, r22
    a334:	b7 1f       	adc	r27, r23
    a336:	8d 83       	std	Y+5, r24	; 0x05
    a338:	9e 83       	std	Y+6, r25	; 0x06
    a33a:	af 83       	std	Y+7, r26	; 0x07
    a33c:	b8 87       	std	Y+8, r27	; 0x08
    a33e:	76 01       	movw	r14, r12
    a340:	dd 24       	eor	r13, r13
    a342:	cc 24       	eor	r12, r12
    a344:	4d a5       	lds	r20, 0x6d
    a346:	5e a5       	lds	r21, 0x6e
    a348:	6f a5       	lds	r22, 0x6f
    a34a:	78 a9       	sts	0x48, r23
    a34c:	60 70       	andi	r22, 0x00	; 0
    a34e:	70 70       	andi	r23, 0x00	; 0
    a350:	c4 0e       	add	r12, r20
    a352:	d5 1e       	adc	r13, r21
    a354:	e6 1e       	adc	r14, r22
    a356:	f7 1e       	adc	r15, r23
    a358:	c9 82       	std	Y+1, r12	; 0x01
    a35a:	da 82       	std	Y+2, r13	; 0x02
    a35c:	eb 82       	std	Y+3, r14	; 0x03
    a35e:	fc 82       	std	Y+4, r15	; 0x04
    a360:	1c 2d       	mov	r17, r12
    a362:	0a 81       	ldd	r16, Y+2	; 0x02
    a364:	8b 80       	ldd	r8, Y+3	; 0x03
    a366:	4c 80       	ldd	r4, Y+4	; 0x04
    a368:	8d 87       	std	Y+13, r24	; 0x0d
    a36a:	8e 81       	ldd	r24, Y+6	; 0x06
    a36c:	8e 87       	std	Y+14, r24	; 0x0e
    a36e:	8f 81       	ldd	r24, Y+7	; 0x07
    a370:	8f 87       	std	Y+15, r24	; 0x0f
    a372:	88 85       	ldd	r24, Y+8	; 0x08
    a374:	88 8b       	std	Y+16, r24	; 0x10
    a376:	2d 89       	ldd	r18, Y+21	; 0x15
    a378:	3e 89       	ldd	r19, Y+22	; 0x16
    a37a:	4f 89       	ldd	r20, Y+23	; 0x17
    a37c:	58 8d       	ldd	r21, Y+24	; 0x18
    a37e:	69 a1       	lds	r22, 0x49
    a380:	7a a1       	lds	r23, 0x4a
    a382:	8b a1       	lds	r24, 0x4b
    a384:	9c a1       	lds	r25, 0x4c
    a386:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    a38a:	6b 01       	movw	r12, r22
    a38c:	7c 01       	movw	r14, r24
    a38e:	2d 8d       	ldd	r18, Y+29	; 0x1d
    a390:	3e 8d       	ldd	r19, Y+30	; 0x1e
    a392:	4f 8d       	ldd	r20, Y+31	; 0x1f
    a394:	58 a1       	lds	r21, 0x48
    a396:	6d a1       	lds	r22, 0x4d
    a398:	7e a1       	lds	r23, 0x4e
    a39a:	8f a1       	lds	r24, 0x4f
    a39c:	98 a5       	lds	r25, 0x68
    a39e:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    a3a2:	dc 01       	movw	r26, r24
    a3a4:	cb 01       	movw	r24, r22
    a3a6:	c8 0e       	add	r12, r24
    a3a8:	d9 1e       	adc	r13, r25
    a3aa:	ea 1e       	adc	r14, r26
    a3ac:	fb 1e       	adc	r15, r27
    a3ae:	8d 85       	ldd	r24, Y+13	; 0x0d
    a3b0:	9e 85       	ldd	r25, Y+14	; 0x0e
    a3b2:	af 85       	ldd	r26, Y+15	; 0x0f
    a3b4:	b8 89       	ldd	r27, Y+16	; 0x10
    a3b6:	8c 0d       	add	r24, r12
    a3b8:	9d 1d       	adc	r25, r13
    a3ba:	ae 1d       	adc	r26, r14
    a3bc:	bf 1d       	adc	r27, r15
    a3be:	8d 87       	std	Y+13, r24	; 0x0d
    a3c0:	9e 87       	std	Y+14, r25	; 0x0e
    a3c2:	af 87       	std	Y+15, r26	; 0x0f
    a3c4:	b8 8b       	std	Y+16, r27	; 0x10
    a3c6:	68 2f       	mov	r22, r24
    a3c8:	7e 85       	ldd	r23, Y+14	; 0x0e
    a3ca:	21 2f       	mov	r18, r17
    a3cc:	30 2f       	mov	r19, r16
    a3ce:	48 2d       	mov	r20, r8
    a3d0:	54 2d       	mov	r21, r4
    a3d2:	8f 85       	ldd	r24, Y+15	; 0x0f
    a3d4:	98 89       	ldd	r25, Y+16	; 0x10
    a3d6:	e0 96       	adiw	r28, 0x30	; 48
    a3d8:	e0 e1       	ldi	r30, 0x10	; 16
    a3da:	0c 94 31 5c 	jmp	0xb862	; 0xb862 <__epilogue_restores__+0x4>

0000a3de <__ashldi3>:
    a3de:	cf 92       	push	r12
    a3e0:	df 92       	push	r13
    a3e2:	ef 92       	push	r14
    a3e4:	ff 92       	push	r15
    a3e6:	0f 93       	push	r16
    a3e8:	cf 93       	push	r28
    a3ea:	df 93       	push	r29
    a3ec:	cd b7       	in	r28, 0x3d	; 61
    a3ee:	de b7       	in	r29, 0x3e	; 62
    a3f0:	60 97       	sbiw	r28, 0x10	; 16
    a3f2:	cd bf       	out	0x3d, r28	; 61
    a3f4:	de bf       	out	0x3e, r29	; 62
    a3f6:	00 23       	and	r16, r16
    a3f8:	09 f4       	brne	.+2      	; 0xa3fc <__ashldi3+0x1e>
    a3fa:	5a c0       	rjmp	.+180    	; 0xa4b0 <__ashldi3+0xd2>
    a3fc:	29 87       	std	Y+9, r18	; 0x09
    a3fe:	3a 87       	std	Y+10, r19	; 0x0a
    a400:	4b 87       	std	Y+11, r20	; 0x0b
    a402:	5c 87       	std	Y+12, r21	; 0x0c
    a404:	6d 87       	std	Y+13, r22	; 0x0d
    a406:	7e 87       	std	Y+14, r23	; 0x0e
    a408:	8f 87       	std	Y+15, r24	; 0x0f
    a40a:	98 8b       	std	Y+16, r25	; 0x10
    a40c:	80 e2       	ldi	r24, 0x20	; 32
    a40e:	80 1b       	sub	r24, r16
    a410:	49 85       	ldd	r20, Y+9	; 0x09
    a412:	5a 85       	ldd	r21, Y+10	; 0x0a
    a414:	6b 85       	ldd	r22, Y+11	; 0x0b
    a416:	7c 85       	ldd	r23, Y+12	; 0x0c
    a418:	18 16       	cp	r1, r24
    a41a:	b4 f0       	brlt	.+44     	; 0xa448 <__ashldi3+0x6a>
    a41c:	19 82       	std	Y+1, r1	; 0x01
    a41e:	1a 82       	std	Y+2, r1	; 0x02
    a420:	1b 82       	std	Y+3, r1	; 0x03
    a422:	1c 82       	std	Y+4, r1	; 0x04
    a424:	99 27       	eor	r25, r25
    a426:	87 fd       	sbrc	r24, 7
    a428:	90 95       	com	r25
    a42a:	90 95       	com	r25
    a42c:	81 95       	neg	r24
    a42e:	9f 4f       	sbci	r25, 0xFF	; 255
    a430:	04 c0       	rjmp	.+8      	; 0xa43a <__ashldi3+0x5c>
    a432:	44 0f       	add	r20, r20
    a434:	55 1f       	adc	r21, r21
    a436:	66 1f       	adc	r22, r22
    a438:	77 1f       	adc	r23, r23
    a43a:	8a 95       	dec	r24
    a43c:	d2 f7       	brpl	.-12     	; 0xa432 <__ashldi3+0x54>
    a43e:	4d 83       	std	Y+5, r20	; 0x05
    a440:	5e 83       	std	Y+6, r21	; 0x06
    a442:	6f 83       	std	Y+7, r22	; 0x07
    a444:	78 87       	std	Y+8, r23	; 0x08
    a446:	2c c0       	rjmp	.+88     	; 0xa4a0 <__ashldi3+0xc2>
    a448:	6a 01       	movw	r12, r20
    a44a:	7b 01       	movw	r14, r22
    a44c:	00 2e       	mov	r0, r16
    a44e:	04 c0       	rjmp	.+8      	; 0xa458 <__ashldi3+0x7a>
    a450:	cc 0c       	add	r12, r12
    a452:	dd 1c       	adc	r13, r13
    a454:	ee 1c       	adc	r14, r14
    a456:	ff 1c       	adc	r15, r15
    a458:	0a 94       	dec	r0
    a45a:	d2 f7       	brpl	.-12     	; 0xa450 <__ashldi3+0x72>
    a45c:	c9 82       	std	Y+1, r12	; 0x01
    a45e:	da 82       	std	Y+2, r13	; 0x02
    a460:	eb 82       	std	Y+3, r14	; 0x03
    a462:	fc 82       	std	Y+4, r15	; 0x04
    a464:	6a 01       	movw	r12, r20
    a466:	7b 01       	movw	r14, r22
    a468:	04 c0       	rjmp	.+8      	; 0xa472 <__ashldi3+0x94>
    a46a:	f6 94       	lsr	r15
    a46c:	e7 94       	ror	r14
    a46e:	d7 94       	ror	r13
    a470:	c7 94       	ror	r12
    a472:	8a 95       	dec	r24
    a474:	d2 f7       	brpl	.-12     	; 0xa46a <__ashldi3+0x8c>
    a476:	d7 01       	movw	r26, r14
    a478:	c6 01       	movw	r24, r12
    a47a:	4d 85       	ldd	r20, Y+13	; 0x0d
    a47c:	5e 85       	ldd	r21, Y+14	; 0x0e
    a47e:	6f 85       	ldd	r22, Y+15	; 0x0f
    a480:	78 89       	ldd	r23, Y+16	; 0x10
    a482:	04 c0       	rjmp	.+8      	; 0xa48c <__ashldi3+0xae>
    a484:	44 0f       	add	r20, r20
    a486:	55 1f       	adc	r21, r21
    a488:	66 1f       	adc	r22, r22
    a48a:	77 1f       	adc	r23, r23
    a48c:	0a 95       	dec	r16
    a48e:	d2 f7       	brpl	.-12     	; 0xa484 <__ashldi3+0xa6>
    a490:	84 2b       	or	r24, r20
    a492:	95 2b       	or	r25, r21
    a494:	a6 2b       	or	r26, r22
    a496:	b7 2b       	or	r27, r23
    a498:	8d 83       	std	Y+5, r24	; 0x05
    a49a:	9e 83       	std	Y+6, r25	; 0x06
    a49c:	af 83       	std	Y+7, r26	; 0x07
    a49e:	b8 87       	std	Y+8, r27	; 0x08
    a4a0:	29 81       	ldd	r18, Y+1	; 0x01
    a4a2:	3a 81       	ldd	r19, Y+2	; 0x02
    a4a4:	4b 81       	ldd	r20, Y+3	; 0x03
    a4a6:	5c 81       	ldd	r21, Y+4	; 0x04
    a4a8:	6d 81       	ldd	r22, Y+5	; 0x05
    a4aa:	7e 81       	ldd	r23, Y+6	; 0x06
    a4ac:	8f 81       	ldd	r24, Y+7	; 0x07
    a4ae:	98 85       	ldd	r25, Y+8	; 0x08
    a4b0:	60 96       	adiw	r28, 0x10	; 16
    a4b2:	cd bf       	out	0x3d, r28	; 61
    a4b4:	de bf       	out	0x3e, r29	; 62
    a4b6:	df 91       	pop	r29
    a4b8:	cf 91       	pop	r28
    a4ba:	0f 91       	pop	r16
    a4bc:	ff 90       	pop	r15
    a4be:	ef 90       	pop	r14
    a4c0:	df 90       	pop	r13
    a4c2:	cf 90       	pop	r12
    a4c4:	08 95       	ret

0000a4c6 <__divdi3>:
    a4c6:	a8 e4       	ldi	r26, 0x48	; 72
    a4c8:	b0 e0       	ldi	r27, 0x00	; 0
    a4ca:	e9 e6       	ldi	r30, 0x69	; 105
    a4cc:	f2 e5       	ldi	r31, 0x52	; 82
    a4ce:	0c 94 17 5c 	jmp	0xb82e	; 0xb82e <__prologue_saves__+0x2>
    a4d2:	f5 01       	movw	r30, r10
    a4d4:	29 a3       	lds	r18, 0x59
    a4d6:	3a a3       	lds	r19, 0x5a
    a4d8:	4b a3       	lds	r20, 0x5b
    a4da:	5c a3       	lds	r21, 0x5c
    a4dc:	6d a3       	lds	r22, 0x5d
    a4de:	7e a3       	lds	r23, 0x5e
    a4e0:	8f a3       	lds	r24, 0x5f
    a4e2:	98 a7       	lds	r25, 0x78
    a4e4:	a9 8e       	std	Y+25, r10	; 0x19
    a4e6:	fa 8f       	std	Y+26, r31	; 0x1a
    a4e8:	cb 8e       	std	Y+27, r12	; 0x1b
    a4ea:	dc 8e       	std	Y+28, r13	; 0x1c
    a4ec:	ed 8e       	std	Y+29, r14	; 0x1d
    a4ee:	fe 8e       	std	Y+30, r15	; 0x1e
    a4f0:	0f 8f       	std	Y+31, r16	; 0x1f
    a4f2:	18 a3       	lds	r17, 0x58
    a4f4:	8d a0       	lds	r24, 0x8d
    a4f6:	9e a0       	lds	r25, 0x8e
    a4f8:	af a0       	lds	r26, 0x8f
    a4fa:	b8 a4       	lds	r27, 0xa8
    a4fc:	b7 fe       	sbrs	r11, 7
    a4fe:	67 c0       	rjmp	.+206    	; 0xa5ce <__divdi3+0x108>
    a500:	21 95       	neg	r18
    a502:	b1 e0       	ldi	r27, 0x01	; 1
    a504:	12 16       	cp	r1, r18
    a506:	08 f0       	brcs	.+2      	; 0xa50a <__divdi3+0x44>
    a508:	b0 e0       	ldi	r27, 0x00	; 0
    a50a:	31 95       	neg	r19
    a50c:	a1 e0       	ldi	r26, 0x01	; 1
    a50e:	13 16       	cp	r1, r19
    a510:	08 f0       	brcs	.+2      	; 0xa514 <__divdi3+0x4e>
    a512:	a0 e0       	ldi	r26, 0x00	; 0
    a514:	b3 2e       	mov	r11, r19
    a516:	bb 1a       	sub	r11, r27
    a518:	bb 2d       	mov	r27, r11
    a51a:	88 24       	eor	r8, r8
    a51c:	83 94       	inc	r8
    a51e:	3b 15       	cp	r19, r11
    a520:	08 f0       	brcs	.+2      	; 0xa524 <__divdi3+0x5e>
    a522:	88 24       	eor	r8, r8
    a524:	a8 29       	or	r26, r8
    a526:	41 95       	neg	r20
    a528:	31 e0       	ldi	r19, 0x01	; 1
    a52a:	14 16       	cp	r1, r20
    a52c:	08 f0       	brcs	.+2      	; 0xa530 <__divdi3+0x6a>
    a52e:	30 e0       	ldi	r19, 0x00	; 0
    a530:	b4 2e       	mov	r11, r20
    a532:	ba 1a       	sub	r11, r26
    a534:	ab 2d       	mov	r26, r11
    a536:	88 24       	eor	r8, r8
    a538:	83 94       	inc	r8
    a53a:	4b 15       	cp	r20, r11
    a53c:	08 f0       	brcs	.+2      	; 0xa540 <__divdi3+0x7a>
    a53e:	88 24       	eor	r8, r8
    a540:	38 29       	or	r19, r8
    a542:	51 95       	neg	r21
    a544:	41 e0       	ldi	r20, 0x01	; 1
    a546:	15 16       	cp	r1, r21
    a548:	08 f0       	brcs	.+2      	; 0xa54c <__divdi3+0x86>
    a54a:	40 e0       	ldi	r20, 0x00	; 0
    a54c:	45 2e       	mov	r4, r21
    a54e:	43 1a       	sub	r4, r19
    a550:	31 e0       	ldi	r19, 0x01	; 1
    a552:	54 15       	cp	r21, r4
    a554:	08 f0       	brcs	.+2      	; 0xa558 <__divdi3+0x92>
    a556:	30 e0       	ldi	r19, 0x00	; 0
    a558:	43 2b       	or	r20, r19
    a55a:	61 95       	neg	r22
    a55c:	31 e0       	ldi	r19, 0x01	; 1
    a55e:	16 16       	cp	r1, r22
    a560:	08 f0       	brcs	.+2      	; 0xa564 <__divdi3+0x9e>
    a562:	30 e0       	ldi	r19, 0x00	; 0
    a564:	86 2e       	mov	r8, r22
    a566:	84 1a       	sub	r8, r20
    a568:	41 e0       	ldi	r20, 0x01	; 1
    a56a:	68 15       	cp	r22, r8
    a56c:	08 f0       	brcs	.+2      	; 0xa570 <__divdi3+0xaa>
    a56e:	40 e0       	ldi	r20, 0x00	; 0
    a570:	34 2b       	or	r19, r20
    a572:	71 95       	neg	r23
    a574:	41 e0       	ldi	r20, 0x01	; 1
    a576:	17 16       	cp	r1, r23
    a578:	08 f0       	brcs	.+2      	; 0xa57c <__divdi3+0xb6>
    a57a:	40 e0       	ldi	r20, 0x00	; 0
    a57c:	57 2f       	mov	r21, r23
    a57e:	53 1b       	sub	r21, r19
    a580:	31 e0       	ldi	r19, 0x01	; 1
    a582:	75 17       	cp	r23, r21
    a584:	08 f0       	brcs	.+2      	; 0xa588 <__divdi3+0xc2>
    a586:	30 e0       	ldi	r19, 0x00	; 0
    a588:	43 2b       	or	r20, r19
    a58a:	81 95       	neg	r24
    a58c:	31 e0       	ldi	r19, 0x01	; 1
    a58e:	18 16       	cp	r1, r24
    a590:	08 f0       	brcs	.+2      	; 0xa594 <__divdi3+0xce>
    a592:	30 e0       	ldi	r19, 0x00	; 0
    a594:	68 2f       	mov	r22, r24
    a596:	64 1b       	sub	r22, r20
    a598:	46 2f       	mov	r20, r22
    a59a:	61 e0       	ldi	r22, 0x01	; 1
    a59c:	84 17       	cp	r24, r20
    a59e:	08 f0       	brcs	.+2      	; 0xa5a2 <__divdi3+0xdc>
    a5a0:	60 e0       	ldi	r22, 0x00	; 0
    a5a2:	36 2b       	or	r19, r22
    a5a4:	91 95       	neg	r25
    a5a6:	93 1b       	sub	r25, r19
    a5a8:	29 a3       	lds	r18, 0x59
    a5aa:	ba a3       	lds	r27, 0x5a
    a5ac:	ab a3       	lds	r26, 0x5b
    a5ae:	4c a2       	lds	r20, 0x9c
    a5b0:	8d a2       	lds	r24, 0x9d
    a5b2:	5e a3       	lds	r21, 0x5e
    a5b4:	4f a3       	lds	r20, 0x5f
    a5b6:	98 a7       	lds	r25, 0x78
    a5b8:	8f ef       	ldi	r24, 0xFF	; 255
    a5ba:	9f ef       	ldi	r25, 0xFF	; 255
    a5bc:	af ef       	ldi	r26, 0xFF	; 255
    a5be:	bf ef       	ldi	r27, 0xFF	; 255
    a5c0:	25 96       	adiw	r28, 0x05	; 5
    a5c2:	8c af       	sts	0x7c, r24
    a5c4:	9d af       	sts	0x7d, r25
    a5c6:	ae af       	sts	0x7e, r26
    a5c8:	bf af       	sts	0x7f, r27
    a5ca:	25 97       	sbiw	r28, 0x05	; 5
    a5cc:	06 c0       	rjmp	.+12     	; 0xa5da <__divdi3+0x114>
    a5ce:	25 96       	adiw	r28, 0x05	; 5
    a5d0:	1c ae       	sts	0xbc, r17
    a5d2:	1d ae       	sts	0xbd, r17
    a5d4:	1e ae       	sts	0xbe, r17
    a5d6:	1f ae       	sts	0xbf, r17
    a5d8:	25 97       	sbiw	r28, 0x05	; 5
    a5da:	8d 8d       	ldd	r24, Y+29	; 0x1d
    a5dc:	9e 8d       	ldd	r25, Y+30	; 0x1e
    a5de:	af 8d       	ldd	r26, Y+31	; 0x1f
    a5e0:	b8 a1       	lds	r27, 0x48
    a5e2:	b7 ff       	sbrs	r27, 7
    a5e4:	68 c0       	rjmp	.+208    	; 0xa6b6 <__divdi3+0x1f0>
    a5e6:	25 96       	adiw	r28, 0x05	; 5
    a5e8:	2c ad       	sts	0x6c, r18
    a5ea:	3d ad       	sts	0x6d, r19
    a5ec:	4e ad       	sts	0x6e, r20
    a5ee:	5f ad       	sts	0x6f, r21
    a5f0:	25 97       	sbiw	r28, 0x05	; 5
    a5f2:	20 95       	com	r18
    a5f4:	30 95       	com	r19
    a5f6:	40 95       	com	r20
    a5f8:	50 95       	com	r21
    a5fa:	25 96       	adiw	r28, 0x05	; 5
    a5fc:	2c af       	sts	0x7c, r18
    a5fe:	3d af       	sts	0x7d, r19
    a600:	4e af       	sts	0x7e, r20
    a602:	5f af       	sts	0x7f, r21
    a604:	25 97       	sbiw	r28, 0x05	; 5
    a606:	e1 95       	neg	r30
    a608:	81 e0       	ldi	r24, 0x01	; 1
    a60a:	1e 16       	cp	r1, r30
    a60c:	08 f0       	brcs	.+2      	; 0xa610 <__divdi3+0x14a>
    a60e:	80 e0       	ldi	r24, 0x00	; 0
    a610:	f1 95       	neg	r31
    a612:	91 e0       	ldi	r25, 0x01	; 1
    a614:	1f 16       	cp	r1, r31
    a616:	08 f0       	brcs	.+2      	; 0xa61a <__divdi3+0x154>
    a618:	90 e0       	ldi	r25, 0x00	; 0
    a61a:	4f 2f       	mov	r20, r31
    a61c:	48 1b       	sub	r20, r24
    a61e:	81 e0       	ldi	r24, 0x01	; 1
    a620:	f4 17       	cp	r31, r20
    a622:	08 f0       	brcs	.+2      	; 0xa626 <__divdi3+0x160>
    a624:	80 e0       	ldi	r24, 0x00	; 0
    a626:	98 2b       	or	r25, r24
    a628:	c1 94       	neg	r12
    a62a:	81 e0       	ldi	r24, 0x01	; 1
    a62c:	1c 14       	cp	r1, r12
    a62e:	08 f0       	brcs	.+2      	; 0xa632 <__divdi3+0x16c>
    a630:	80 e0       	ldi	r24, 0x00	; 0
    a632:	6c 2d       	mov	r22, r12
    a634:	69 1b       	sub	r22, r25
    a636:	91 e0       	ldi	r25, 0x01	; 1
    a638:	c6 16       	cp	r12, r22
    a63a:	08 f0       	brcs	.+2      	; 0xa63e <__divdi3+0x178>
    a63c:	90 e0       	ldi	r25, 0x00	; 0
    a63e:	89 2b       	or	r24, r25
    a640:	d1 94       	neg	r13
    a642:	91 e0       	ldi	r25, 0x01	; 1
    a644:	1d 14       	cp	r1, r13
    a646:	08 f0       	brcs	.+2      	; 0xa64a <__divdi3+0x184>
    a648:	90 e0       	ldi	r25, 0x00	; 0
    a64a:	5d 2d       	mov	r21, r13
    a64c:	58 1b       	sub	r21, r24
    a64e:	81 e0       	ldi	r24, 0x01	; 1
    a650:	d5 16       	cp	r13, r21
    a652:	08 f0       	brcs	.+2      	; 0xa656 <__divdi3+0x190>
    a654:	80 e0       	ldi	r24, 0x00	; 0
    a656:	98 2b       	or	r25, r24
    a658:	e1 94       	neg	r14
    a65a:	81 e0       	ldi	r24, 0x01	; 1
    a65c:	1e 14       	cp	r1, r14
    a65e:	08 f0       	brcs	.+2      	; 0xa662 <__divdi3+0x19c>
    a660:	80 e0       	ldi	r24, 0x00	; 0
    a662:	3e 2d       	mov	r19, r14
    a664:	39 1b       	sub	r19, r25
    a666:	91 e0       	ldi	r25, 0x01	; 1
    a668:	e3 16       	cp	r14, r19
    a66a:	08 f0       	brcs	.+2      	; 0xa66e <__divdi3+0x1a8>
    a66c:	90 e0       	ldi	r25, 0x00	; 0
    a66e:	89 2b       	or	r24, r25
    a670:	f1 94       	neg	r15
    a672:	91 e0       	ldi	r25, 0x01	; 1
    a674:	1f 14       	cp	r1, r15
    a676:	08 f0       	brcs	.+2      	; 0xa67a <__divdi3+0x1b4>
    a678:	90 e0       	ldi	r25, 0x00	; 0
    a67a:	2f 2d       	mov	r18, r15
    a67c:	28 1b       	sub	r18, r24
    a67e:	81 e0       	ldi	r24, 0x01	; 1
    a680:	f2 16       	cp	r15, r18
    a682:	08 f0       	brcs	.+2      	; 0xa686 <__divdi3+0x1c0>
    a684:	80 e0       	ldi	r24, 0x00	; 0
    a686:	98 2b       	or	r25, r24
    a688:	01 95       	neg	r16
    a68a:	81 e0       	ldi	r24, 0x01	; 1
    a68c:	10 16       	cp	r1, r16
    a68e:	08 f0       	brcs	.+2      	; 0xa692 <__divdi3+0x1cc>
    a690:	80 e0       	ldi	r24, 0x00	; 0
    a692:	70 2f       	mov	r23, r16
    a694:	79 1b       	sub	r23, r25
    a696:	97 2f       	mov	r25, r23
    a698:	71 e0       	ldi	r23, 0x01	; 1
    a69a:	09 17       	cp	r16, r25
    a69c:	08 f0       	brcs	.+2      	; 0xa6a0 <__divdi3+0x1da>
    a69e:	70 e0       	ldi	r23, 0x00	; 0
    a6a0:	87 2b       	or	r24, r23
    a6a2:	11 95       	neg	r17
    a6a4:	18 1b       	sub	r17, r24
    a6a6:	e9 8f       	std	Y+25, r30	; 0x19
    a6a8:	4a 8f       	std	Y+26, r20	; 0x1a
    a6aa:	6b 8f       	std	Y+27, r22	; 0x1b
    a6ac:	5c 8f       	std	Y+28, r21	; 0x1c
    a6ae:	3d 8f       	std	Y+29, r19	; 0x1d
    a6b0:	2e 8f       	std	Y+30, r18	; 0x1e
    a6b2:	9f 8f       	std	Y+31, r25	; 0x1f
    a6b4:	18 a3       	lds	r17, 0x58
    a6b6:	79 8d       	ldd	r23, Y+25	; 0x19
    a6b8:	6a 8d       	ldd	r22, Y+26	; 0x1a
    a6ba:	5b 8d       	ldd	r21, Y+27	; 0x1b
    a6bc:	4c 8d       	ldd	r20, Y+28	; 0x1c
    a6be:	3d 8d       	ldd	r19, Y+29	; 0x1d
    a6c0:	2e 8d       	ldd	r18, Y+30	; 0x1e
    a6c2:	9f 8d       	ldd	r25, Y+31	; 0x1f
    a6c4:	88 a1       	lds	r24, 0x48
    a6c6:	e9 a1       	lds	r30, 0x49
    a6c8:	e9 8b       	std	Y+17, r30	; 0x11
    a6ca:	ea a1       	lds	r30, 0x4a
    a6cc:	ea 8b       	std	Y+18, r30	; 0x12
    a6ce:	eb a1       	lds	r30, 0x4b
    a6d0:	eb 8b       	std	Y+19, r30	; 0x13
    a6d2:	ec a1       	lds	r30, 0x4c
    a6d4:	ec 8b       	std	Y+20, r30	; 0x14
    a6d6:	ed a1       	lds	r30, 0x4d
    a6d8:	ed 8b       	std	Y+21, r30	; 0x15
    a6da:	ee a1       	lds	r30, 0x4e
    a6dc:	ee 8b       	std	Y+22, r30	; 0x16
    a6de:	ef a1       	lds	r30, 0x4f
    a6e0:	ef 8b       	std	Y+23, r30	; 0x17
    a6e2:	e8 a5       	lds	r30, 0x68
    a6e4:	e8 8f       	std	Y+24, r30	; 0x18
    a6e6:	79 87       	std	Y+9, r23	; 0x09
    a6e8:	6a 87       	std	Y+10, r22	; 0x0a
    a6ea:	5b 87       	std	Y+11, r21	; 0x0b
    a6ec:	4c 87       	std	Y+12, r20	; 0x0c
    a6ee:	3d 87       	std	Y+13, r19	; 0x0d
    a6f0:	2e 87       	std	Y+14, r18	; 0x0e
    a6f2:	9f 87       	std	Y+15, r25	; 0x0f
    a6f4:	88 8b       	std	Y+16, r24	; 0x10
    a6f6:	89 84       	ldd	r8, Y+9	; 0x09
    a6f8:	9a 84       	ldd	r9, Y+10	; 0x0a
    a6fa:	ab 84       	ldd	r10, Y+11	; 0x0b
    a6fc:	bc 84       	ldd	r11, Y+12	; 0x0c
    a6fe:	8d 85       	ldd	r24, Y+13	; 0x0d
    a700:	9e 85       	ldd	r25, Y+14	; 0x0e
    a702:	af 85       	ldd	r26, Y+15	; 0x0f
    a704:	b8 89       	ldd	r27, Y+16	; 0x10
    a706:	e9 88       	ldd	r14, Y+17	; 0x11
    a708:	fa 88       	ldd	r15, Y+18	; 0x12
    a70a:	0b 89       	ldd	r16, Y+19	; 0x13
    a70c:	1c 89       	ldd	r17, Y+20	; 0x14
    a70e:	ed aa       	sts	0x9d, r30
    a710:	fe aa       	sts	0x9e, r31
    a712:	0f ab       	sts	0x5f, r16
    a714:	18 af       	sts	0x78, r17
    a716:	cd 88       	ldd	r12, Y+21	; 0x15
    a718:	de 88       	ldd	r13, Y+22	; 0x16
    a71a:	ef 88       	ldd	r14, Y+23	; 0x17
    a71c:	f8 8c       	ldd	r15, Y+24	; 0x18
    a71e:	00 97       	sbiw	r24, 0x00	; 0
    a720:	a1 05       	cpc	r26, r1
    a722:	b1 05       	cpc	r27, r1
    a724:	09 f0       	breq	.+2      	; 0xa728 <__divdi3+0x262>
    a726:	bd c3       	rjmp	.+1914   	; 0xaea2 <__divdi3+0x9dc>
    a728:	c8 14       	cp	r12, r8
    a72a:	d9 04       	cpc	r13, r9
    a72c:	ea 04       	cpc	r14, r10
    a72e:	fb 04       	cpc	r15, r11
    a730:	08 f0       	brcs	.+2      	; 0xa734 <__divdi3+0x26e>
    a732:	4d c1       	rjmp	.+666    	; 0xa9ce <__divdi3+0x508>
    a734:	00 e0       	ldi	r16, 0x00	; 0
    a736:	80 16       	cp	r8, r16
    a738:	00 e0       	ldi	r16, 0x00	; 0
    a73a:	90 06       	cpc	r9, r16
    a73c:	01 e0       	ldi	r16, 0x01	; 1
    a73e:	a0 06       	cpc	r10, r16
    a740:	00 e0       	ldi	r16, 0x00	; 0
    a742:	b0 06       	cpc	r11, r16
    a744:	58 f4       	brcc	.+22     	; 0xa75c <__divdi3+0x296>
    a746:	1f ef       	ldi	r17, 0xFF	; 255
    a748:	81 16       	cp	r8, r17
    a74a:	91 04       	cpc	r9, r1
    a74c:	a1 04       	cpc	r10, r1
    a74e:	b1 04       	cpc	r11, r1
    a750:	09 f0       	breq	.+2      	; 0xa754 <__divdi3+0x28e>
    a752:	90 f4       	brcc	.+36     	; 0xa778 <__divdi3+0x2b2>
    a754:	80 e0       	ldi	r24, 0x00	; 0
    a756:	90 e0       	ldi	r25, 0x00	; 0
    a758:	dc 01       	movw	r26, r24
    a75a:	17 c0       	rjmp	.+46     	; 0xa78a <__divdi3+0x2c4>
    a75c:	20 e0       	ldi	r18, 0x00	; 0
    a75e:	82 16       	cp	r8, r18
    a760:	20 e0       	ldi	r18, 0x00	; 0
    a762:	92 06       	cpc	r9, r18
    a764:	20 e0       	ldi	r18, 0x00	; 0
    a766:	a2 06       	cpc	r10, r18
    a768:	21 e0       	ldi	r18, 0x01	; 1
    a76a:	b2 06       	cpc	r11, r18
    a76c:	50 f4       	brcc	.+20     	; 0xa782 <__divdi3+0x2bc>
    a76e:	80 e1       	ldi	r24, 0x10	; 16
    a770:	90 e0       	ldi	r25, 0x00	; 0
    a772:	a0 e0       	ldi	r26, 0x00	; 0
    a774:	b0 e0       	ldi	r27, 0x00	; 0
    a776:	09 c0       	rjmp	.+18     	; 0xa78a <__divdi3+0x2c4>
    a778:	88 e0       	ldi	r24, 0x08	; 8
    a77a:	90 e0       	ldi	r25, 0x00	; 0
    a77c:	a0 e0       	ldi	r26, 0x00	; 0
    a77e:	b0 e0       	ldi	r27, 0x00	; 0
    a780:	04 c0       	rjmp	.+8      	; 0xa78a <__divdi3+0x2c4>
    a782:	88 e1       	ldi	r24, 0x18	; 24
    a784:	90 e0       	ldi	r25, 0x00	; 0
    a786:	a0 e0       	ldi	r26, 0x00	; 0
    a788:	b0 e0       	ldi	r27, 0x00	; 0
    a78a:	b5 01       	movw	r22, r10
    a78c:	a4 01       	movw	r20, r8
    a78e:	08 2e       	mov	r0, r24
    a790:	04 c0       	rjmp	.+8      	; 0xa79a <__divdi3+0x2d4>
    a792:	76 95       	lsr	r23
    a794:	67 95       	ror	r22
    a796:	57 95       	ror	r21
    a798:	47 95       	ror	r20
    a79a:	0a 94       	dec	r0
    a79c:	d2 f7       	brpl	.-12     	; 0xa792 <__divdi3+0x2cc>
    a79e:	fa 01       	movw	r30, r20
    a7a0:	ee 5c       	subi	r30, 0xCE	; 206
    a7a2:	ff 4d       	sbci	r31, 0xDF	; 223
    a7a4:	20 81       	ld	r18, Z
    a7a6:	40 e2       	ldi	r20, 0x20	; 32
    a7a8:	50 e0       	ldi	r21, 0x00	; 0
    a7aa:	60 e0       	ldi	r22, 0x00	; 0
    a7ac:	70 e0       	ldi	r23, 0x00	; 0
    a7ae:	48 1b       	sub	r20, r24
    a7b0:	59 0b       	sbc	r21, r25
    a7b2:	6a 0b       	sbc	r22, r26
    a7b4:	7b 0b       	sbc	r23, r27
    a7b6:	42 1b       	sub	r20, r18
    a7b8:	51 09       	sbc	r21, r1
    a7ba:	61 09       	sbc	r22, r1
    a7bc:	71 09       	sbc	r23, r1
    a7be:	41 15       	cp	r20, r1
    a7c0:	51 05       	cpc	r21, r1
    a7c2:	61 05       	cpc	r22, r1
    a7c4:	71 05       	cpc	r23, r1
    a7c6:	a1 f1       	breq	.+104    	; 0xa830 <__divdi3+0x36a>
    a7c8:	04 2e       	mov	r0, r20
    a7ca:	04 c0       	rjmp	.+8      	; 0xa7d4 <__divdi3+0x30e>
    a7cc:	88 0c       	add	r8, r8
    a7ce:	99 1c       	adc	r9, r9
    a7d0:	aa 1c       	adc	r10, r10
    a7d2:	bb 1c       	adc	r11, r11
    a7d4:	0a 94       	dec	r0
    a7d6:	d2 f7       	brpl	.-12     	; 0xa7cc <__divdi3+0x306>
    a7d8:	97 01       	movw	r18, r14
    a7da:	86 01       	movw	r16, r12
    a7dc:	04 2e       	mov	r0, r20
    a7de:	04 c0       	rjmp	.+8      	; 0xa7e8 <__divdi3+0x322>
    a7e0:	00 0f       	add	r16, r16
    a7e2:	11 1f       	adc	r17, r17
    a7e4:	22 1f       	adc	r18, r18
    a7e6:	33 1f       	adc	r19, r19
    a7e8:	0a 94       	dec	r0
    a7ea:	d2 f7       	brpl	.-12     	; 0xa7e0 <__divdi3+0x31a>
    a7ec:	80 e2       	ldi	r24, 0x20	; 32
    a7ee:	90 e0       	ldi	r25, 0x00	; 0
    a7f0:	84 1b       	sub	r24, r20
    a7f2:	95 0b       	sbc	r25, r21
    a7f4:	cd a8       	sts	0x8d, r28
    a7f6:	de a8       	sts	0x8e, r29
    a7f8:	ef a8       	sts	0x8f, r30
    a7fa:	f8 ac       	sts	0xa8, r31
    a7fc:	04 c0       	rjmp	.+8      	; 0xa806 <__divdi3+0x340>
    a7fe:	f6 94       	lsr	r15
    a800:	e7 94       	ror	r14
    a802:	d7 94       	ror	r13
    a804:	c7 94       	ror	r12
    a806:	8a 95       	dec	r24
    a808:	d2 f7       	brpl	.-12     	; 0xa7fe <__divdi3+0x338>
    a80a:	c0 2a       	or	r12, r16
    a80c:	d1 2a       	or	r13, r17
    a80e:	e2 2a       	or	r14, r18
    a810:	f3 2a       	or	r15, r19
    a812:	0d a9       	sts	0x4d, r16
    a814:	1e a9       	sts	0x4e, r17
    a816:	2f a9       	sts	0x4f, r18
    a818:	38 ad       	sts	0x68, r19
    a81a:	04 c0       	rjmp	.+8      	; 0xa824 <__divdi3+0x35e>
    a81c:	00 0f       	add	r16, r16
    a81e:	11 1f       	adc	r17, r17
    a820:	22 1f       	adc	r18, r18
    a822:	33 1f       	adc	r19, r19
    a824:	4a 95       	dec	r20
    a826:	d2 f7       	brpl	.-12     	; 0xa81c <__divdi3+0x356>
    a828:	0d ab       	sts	0x5d, r16
    a82a:	1e ab       	sts	0x5e, r17
    a82c:	2f ab       	sts	0x5f, r18
    a82e:	38 af       	sts	0x78, r19
    a830:	25 01       	movw	r4, r10
    a832:	66 24       	eor	r6, r6
    a834:	77 24       	eor	r7, r7
    a836:	95 01       	movw	r18, r10
    a838:	84 01       	movw	r16, r8
    a83a:	20 70       	andi	r18, 0x00	; 0
    a83c:	30 70       	andi	r19, 0x00	; 0
    a83e:	09 ab       	sts	0x59, r16
    a840:	1a ab       	sts	0x5a, r17
    a842:	2b ab       	sts	0x5b, r18
    a844:	3c ab       	sts	0x5c, r19
    a846:	c7 01       	movw	r24, r14
    a848:	b6 01       	movw	r22, r12
    a84a:	a3 01       	movw	r20, r6
    a84c:	92 01       	movw	r18, r4
    a84e:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    a852:	2d a7       	lds	r18, 0x7d
    a854:	3e a7       	lds	r19, 0x7e
    a856:	4f a7       	lds	r20, 0x7f
    a858:	58 ab       	sts	0x58, r21
    a85a:	69 a7       	lds	r22, 0x79
    a85c:	7a a7       	lds	r23, 0x7a
    a85e:	8b a7       	lds	r24, 0x7b
    a860:	9c a7       	lds	r25, 0x7c
    a862:	c7 01       	movw	r24, r14
    a864:	b6 01       	movw	r22, r12
    a866:	a3 01       	movw	r20, r6
    a868:	92 01       	movw	r18, r4
    a86a:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    a86e:	ca 01       	movw	r24, r20
    a870:	b9 01       	movw	r22, r18
    a872:	29 a9       	sts	0x49, r18
    a874:	3a a9       	sts	0x4a, r19
    a876:	4b a9       	sts	0x4b, r20
    a878:	5c a9       	sts	0x4c, r21
    a87a:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    a87e:	ab 01       	movw	r20, r22
    a880:	bc 01       	movw	r22, r24
    a882:	09 a5       	lds	r16, 0x69
    a884:	1a a5       	lds	r17, 0x6a
    a886:	2b a5       	lds	r18, 0x6b
    a888:	3c a5       	lds	r19, 0x6c
    a88a:	78 01       	movw	r14, r16
    a88c:	dd 24       	eor	r13, r13
    a88e:	cc 24       	eor	r12, r12
    a890:	0d a9       	sts	0x4d, r16
    a892:	1e a9       	sts	0x4e, r17
    a894:	2f a9       	sts	0x4f, r18
    a896:	38 ad       	sts	0x68, r19
    a898:	c9 01       	movw	r24, r18
    a89a:	aa 27       	eor	r26, r26
    a89c:	bb 27       	eor	r27, r27
    a89e:	c8 2a       	or	r12, r24
    a8a0:	d9 2a       	or	r13, r25
    a8a2:	ea 2a       	or	r14, r26
    a8a4:	fb 2a       	or	r15, r27
    a8a6:	0d a5       	lds	r16, 0x6d
    a8a8:	1e a5       	lds	r17, 0x6e
    a8aa:	2f a5       	lds	r18, 0x6f
    a8ac:	38 a9       	sts	0x48, r19
    a8ae:	c4 16       	cp	r12, r20
    a8b0:	d5 06       	cpc	r13, r21
    a8b2:	e6 06       	cpc	r14, r22
    a8b4:	f7 06       	cpc	r15, r23
    a8b6:	38 f5       	brcc	.+78     	; 0xa906 <__divdi3+0x440>
    a8b8:	01 50       	subi	r16, 0x01	; 1
    a8ba:	10 40       	sbci	r17, 0x00	; 0
    a8bc:	20 40       	sbci	r18, 0x00	; 0
    a8be:	30 40       	sbci	r19, 0x00	; 0
    a8c0:	09 a7       	lds	r16, 0x79
    a8c2:	1a a7       	lds	r17, 0x7a
    a8c4:	2b a7       	lds	r18, 0x7b
    a8c6:	3c a7       	lds	r19, 0x7c
    a8c8:	c8 0c       	add	r12, r8
    a8ca:	d9 1c       	adc	r13, r9
    a8cc:	ea 1c       	adc	r14, r10
    a8ce:	fb 1c       	adc	r15, r11
    a8d0:	c8 14       	cp	r12, r8
    a8d2:	d9 04       	cpc	r13, r9
    a8d4:	ea 04       	cpc	r14, r10
    a8d6:	fb 04       	cpc	r15, r11
    a8d8:	d0 f0       	brcs	.+52     	; 0xa90e <__divdi3+0x448>
    a8da:	c4 16       	cp	r12, r20
    a8dc:	d5 06       	cpc	r13, r21
    a8de:	e6 06       	cpc	r14, r22
    a8e0:	f7 06       	cpc	r15, r23
    a8e2:	a8 f4       	brcc	.+42     	; 0xa90e <__divdi3+0x448>
    a8e4:	0d a5       	lds	r16, 0x6d
    a8e6:	1e a5       	lds	r17, 0x6e
    a8e8:	2f a5       	lds	r18, 0x6f
    a8ea:	38 a9       	sts	0x48, r19
    a8ec:	02 50       	subi	r16, 0x02	; 2
    a8ee:	10 40       	sbci	r17, 0x00	; 0
    a8f0:	20 40       	sbci	r18, 0x00	; 0
    a8f2:	30 40       	sbci	r19, 0x00	; 0
    a8f4:	09 a7       	lds	r16, 0x79
    a8f6:	1a a7       	lds	r17, 0x7a
    a8f8:	2b a7       	lds	r18, 0x7b
    a8fa:	3c a7       	lds	r19, 0x7c
    a8fc:	c8 0c       	add	r12, r8
    a8fe:	d9 1c       	adc	r13, r9
    a900:	ea 1c       	adc	r14, r10
    a902:	fb 1c       	adc	r15, r11
    a904:	04 c0       	rjmp	.+8      	; 0xa90e <__divdi3+0x448>
    a906:	09 a7       	lds	r16, 0x79
    a908:	1a a7       	lds	r17, 0x7a
    a90a:	2b a7       	lds	r18, 0x7b
    a90c:	3c a7       	lds	r19, 0x7c
    a90e:	c4 1a       	sub	r12, r20
    a910:	d5 0a       	sbc	r13, r21
    a912:	e6 0a       	sbc	r14, r22
    a914:	f7 0a       	sbc	r15, r23
    a916:	c7 01       	movw	r24, r14
    a918:	b6 01       	movw	r22, r12
    a91a:	a3 01       	movw	r20, r6
    a91c:	92 01       	movw	r18, r4
    a91e:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    a922:	2d a7       	lds	r18, 0x7d
    a924:	3e a7       	lds	r19, 0x7e
    a926:	4f a7       	lds	r20, 0x7f
    a928:	58 ab       	sts	0x58, r21
    a92a:	69 af       	sts	0x79, r22
    a92c:	7a af       	sts	0x7a, r23
    a92e:	8b af       	sts	0x7b, r24
    a930:	9c af       	sts	0x7c, r25
    a932:	c7 01       	movw	r24, r14
    a934:	b6 01       	movw	r22, r12
    a936:	a3 01       	movw	r20, r6
    a938:	92 01       	movw	r18, r4
    a93a:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    a93e:	ca 01       	movw	r24, r20
    a940:	b9 01       	movw	r22, r18
    a942:	29 a9       	sts	0x49, r18
    a944:	3a a9       	sts	0x4a, r19
    a946:	4b a9       	sts	0x4b, r20
    a948:	5c a9       	sts	0x4c, r21
    a94a:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    a94e:	6b 01       	movw	r12, r22
    a950:	7c 01       	movw	r14, r24
    a952:	49 ad       	sts	0x69, r20
    a954:	5a ad       	sts	0x6a, r21
    a956:	6b ad       	sts	0x6b, r22
    a958:	7c ad       	sts	0x6c, r23
    a95a:	9a 01       	movw	r18, r20
    a95c:	11 27       	eor	r17, r17
    a95e:	00 27       	eor	r16, r16
    a960:	4d a9       	sts	0x4d, r20
    a962:	5e a9       	sts	0x4e, r21
    a964:	6f a9       	sts	0x4f, r22
    a966:	78 ad       	sts	0x68, r23
    a968:	60 70       	andi	r22, 0x00	; 0
    a96a:	70 70       	andi	r23, 0x00	; 0
    a96c:	04 2b       	or	r16, r20
    a96e:	15 2b       	or	r17, r21
    a970:	26 2b       	or	r18, r22
    a972:	37 2b       	or	r19, r23
    a974:	8d a5       	lds	r24, 0x6d
    a976:	9e a5       	lds	r25, 0x6e
    a978:	af a5       	lds	r26, 0x6f
    a97a:	b8 a9       	sts	0x48, r27
    a97c:	0c 15       	cp	r16, r12
    a97e:	1d 05       	cpc	r17, r13
    a980:	2e 05       	cpc	r18, r14
    a982:	3f 05       	cpc	r19, r15
    a984:	c0 f4       	brcc	.+48     	; 0xa9b6 <__divdi3+0x4f0>
    a986:	01 97       	sbiw	r24, 0x01	; 1
    a988:	a1 09       	sbc	r26, r1
    a98a:	b1 09       	sbc	r27, r1
    a98c:	08 0d       	add	r16, r8
    a98e:	19 1d       	adc	r17, r9
    a990:	2a 1d       	adc	r18, r10
    a992:	3b 1d       	adc	r19, r11
    a994:	08 15       	cp	r16, r8
    a996:	19 05       	cpc	r17, r9
    a998:	2a 05       	cpc	r18, r10
    a99a:	3b 05       	cpc	r19, r11
    a99c:	60 f0       	brcs	.+24     	; 0xa9b6 <__divdi3+0x4f0>
    a99e:	0c 15       	cp	r16, r12
    a9a0:	1d 05       	cpc	r17, r13
    a9a2:	2e 05       	cpc	r18, r14
    a9a4:	3f 05       	cpc	r19, r15
    a9a6:	38 f4       	brcc	.+14     	; 0xa9b6 <__divdi3+0x4f0>
    a9a8:	8d a5       	lds	r24, 0x6d
    a9aa:	9e a5       	lds	r25, 0x6e
    a9ac:	af a5       	lds	r26, 0x6f
    a9ae:	b8 a9       	sts	0x48, r27
    a9b0:	02 97       	sbiw	r24, 0x02	; 2
    a9b2:	a1 09       	sbc	r26, r1
    a9b4:	b1 09       	sbc	r27, r1
    a9b6:	09 a5       	lds	r16, 0x69
    a9b8:	1a a5       	lds	r17, 0x6a
    a9ba:	2b a5       	lds	r18, 0x6b
    a9bc:	3c a5       	lds	r19, 0x6c
    a9be:	78 01       	movw	r14, r16
    a9c0:	dd 24       	eor	r13, r13
    a9c2:	cc 24       	eor	r12, r12
    a9c4:	c8 2a       	or	r12, r24
    a9c6:	d9 2a       	or	r13, r25
    a9c8:	ea 2a       	or	r14, r26
    a9ca:	fb 2a       	or	r15, r27
    a9cc:	b7 c4       	rjmp	.+2414   	; 0xb33c <__divdi3+0xe76>
    a9ce:	81 14       	cp	r8, r1
    a9d0:	91 04       	cpc	r9, r1
    a9d2:	a1 04       	cpc	r10, r1
    a9d4:	b1 04       	cpc	r11, r1
    a9d6:	51 f4       	brne	.+20     	; 0xa9ec <__divdi3+0x526>
    a9d8:	61 e0       	ldi	r22, 0x01	; 1
    a9da:	70 e0       	ldi	r23, 0x00	; 0
    a9dc:	80 e0       	ldi	r24, 0x00	; 0
    a9de:	90 e0       	ldi	r25, 0x00	; 0
    a9e0:	a5 01       	movw	r20, r10
    a9e2:	94 01       	movw	r18, r8
    a9e4:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    a9e8:	49 01       	movw	r8, r18
    a9ea:	5a 01       	movw	r10, r20
    a9ec:	10 e0       	ldi	r17, 0x00	; 0
    a9ee:	81 16       	cp	r8, r17
    a9f0:	10 e0       	ldi	r17, 0x00	; 0
    a9f2:	91 06       	cpc	r9, r17
    a9f4:	11 e0       	ldi	r17, 0x01	; 1
    a9f6:	a1 06       	cpc	r10, r17
    a9f8:	10 e0       	ldi	r17, 0x00	; 0
    a9fa:	b1 06       	cpc	r11, r17
    a9fc:	58 f4       	brcc	.+22     	; 0xaa14 <__divdi3+0x54e>
    a9fe:	2f ef       	ldi	r18, 0xFF	; 255
    aa00:	82 16       	cp	r8, r18
    aa02:	91 04       	cpc	r9, r1
    aa04:	a1 04       	cpc	r10, r1
    aa06:	b1 04       	cpc	r11, r1
    aa08:	09 f0       	breq	.+2      	; 0xaa0c <__divdi3+0x546>
    aa0a:	90 f4       	brcc	.+36     	; 0xaa30 <__divdi3+0x56a>
    aa0c:	80 e0       	ldi	r24, 0x00	; 0
    aa0e:	90 e0       	ldi	r25, 0x00	; 0
    aa10:	dc 01       	movw	r26, r24
    aa12:	17 c0       	rjmp	.+46     	; 0xaa42 <__divdi3+0x57c>
    aa14:	30 e0       	ldi	r19, 0x00	; 0
    aa16:	83 16       	cp	r8, r19
    aa18:	30 e0       	ldi	r19, 0x00	; 0
    aa1a:	93 06       	cpc	r9, r19
    aa1c:	30 e0       	ldi	r19, 0x00	; 0
    aa1e:	a3 06       	cpc	r10, r19
    aa20:	31 e0       	ldi	r19, 0x01	; 1
    aa22:	b3 06       	cpc	r11, r19
    aa24:	50 f4       	brcc	.+20     	; 0xaa3a <__divdi3+0x574>
    aa26:	80 e1       	ldi	r24, 0x10	; 16
    aa28:	90 e0       	ldi	r25, 0x00	; 0
    aa2a:	a0 e0       	ldi	r26, 0x00	; 0
    aa2c:	b0 e0       	ldi	r27, 0x00	; 0
    aa2e:	09 c0       	rjmp	.+18     	; 0xaa42 <__divdi3+0x57c>
    aa30:	88 e0       	ldi	r24, 0x08	; 8
    aa32:	90 e0       	ldi	r25, 0x00	; 0
    aa34:	a0 e0       	ldi	r26, 0x00	; 0
    aa36:	b0 e0       	ldi	r27, 0x00	; 0
    aa38:	04 c0       	rjmp	.+8      	; 0xaa42 <__divdi3+0x57c>
    aa3a:	88 e1       	ldi	r24, 0x18	; 24
    aa3c:	90 e0       	ldi	r25, 0x00	; 0
    aa3e:	a0 e0       	ldi	r26, 0x00	; 0
    aa40:	b0 e0       	ldi	r27, 0x00	; 0
    aa42:	b5 01       	movw	r22, r10
    aa44:	a4 01       	movw	r20, r8
    aa46:	08 2e       	mov	r0, r24
    aa48:	04 c0       	rjmp	.+8      	; 0xaa52 <__divdi3+0x58c>
    aa4a:	76 95       	lsr	r23
    aa4c:	67 95       	ror	r22
    aa4e:	57 95       	ror	r21
    aa50:	47 95       	ror	r20
    aa52:	0a 94       	dec	r0
    aa54:	d2 f7       	brpl	.-12     	; 0xaa4a <__divdi3+0x584>
    aa56:	fa 01       	movw	r30, r20
    aa58:	ee 5c       	subi	r30, 0xCE	; 206
    aa5a:	ff 4d       	sbci	r31, 0xDF	; 223
    aa5c:	20 81       	ld	r18, Z
    aa5e:	ac 01       	movw	r20, r24
    aa60:	bd 01       	movw	r22, r26
    aa62:	42 0f       	add	r20, r18
    aa64:	51 1d       	adc	r21, r1
    aa66:	61 1d       	adc	r22, r1
    aa68:	71 1d       	adc	r23, r1
    aa6a:	80 e2       	ldi	r24, 0x20	; 32
    aa6c:	90 e0       	ldi	r25, 0x00	; 0
    aa6e:	a0 e0       	ldi	r26, 0x00	; 0
    aa70:	b0 e0       	ldi	r27, 0x00	; 0
    aa72:	84 1b       	sub	r24, r20
    aa74:	95 0b       	sbc	r25, r21
    aa76:	a6 0b       	sbc	r26, r22
    aa78:	b7 0b       	sbc	r27, r23
    aa7a:	51 f4       	brne	.+20     	; 0xaa90 <__divdi3+0x5ca>
    aa7c:	c8 18       	sub	r12, r8
    aa7e:	d9 08       	sbc	r13, r9
    aa80:	ea 08       	sbc	r14, r10
    aa82:	fb 08       	sbc	r15, r11
    aa84:	f1 e0       	ldi	r31, 0x01	; 1
    aa86:	4f 2e       	mov	r4, r31
    aa88:	51 2c       	mov	r5, r1
    aa8a:	61 2c       	mov	r6, r1
    aa8c:	71 2c       	mov	r7, r1
    aa8e:	28 c1       	rjmp	.+592    	; 0xace0 <__divdi3+0x81a>
    aa90:	08 2e       	mov	r0, r24
    aa92:	04 c0       	rjmp	.+8      	; 0xaa9c <__divdi3+0x5d6>
    aa94:	88 0c       	add	r8, r8
    aa96:	99 1c       	adc	r9, r9
    aa98:	aa 1c       	adc	r10, r10
    aa9a:	bb 1c       	adc	r11, r11
    aa9c:	0a 94       	dec	r0
    aa9e:	d2 f7       	brpl	.-12     	; 0xaa94 <__divdi3+0x5ce>
    aaa0:	97 01       	movw	r18, r14
    aaa2:	86 01       	movw	r16, r12
    aaa4:	04 2e       	mov	r0, r20
    aaa6:	04 c0       	rjmp	.+8      	; 0xaab0 <__divdi3+0x5ea>
    aaa8:	36 95       	lsr	r19
    aaaa:	27 95       	ror	r18
    aaac:	17 95       	ror	r17
    aaae:	07 95       	ror	r16
    aab0:	0a 94       	dec	r0
    aab2:	d2 f7       	brpl	.-12     	; 0xaaa8 <__divdi3+0x5e2>
    aab4:	09 ab       	sts	0x59, r16
    aab6:	1a ab       	sts	0x5a, r17
    aab8:	2b ab       	sts	0x5b, r18
    aaba:	3c ab       	sts	0x5c, r19
    aabc:	97 01       	movw	r18, r14
    aabe:	86 01       	movw	r16, r12
    aac0:	08 2e       	mov	r0, r24
    aac2:	04 c0       	rjmp	.+8      	; 0xaacc <__divdi3+0x606>
    aac4:	00 0f       	add	r16, r16
    aac6:	11 1f       	adc	r17, r17
    aac8:	22 1f       	adc	r18, r18
    aaca:	33 1f       	adc	r19, r19
    aacc:	0a 94       	dec	r0
    aace:	d2 f7       	brpl	.-12     	; 0xaac4 <__divdi3+0x5fe>
    aad0:	0d a7       	lds	r16, 0x7d
    aad2:	1e a7       	lds	r17, 0x7e
    aad4:	2f a7       	lds	r18, 0x7f
    aad6:	38 ab       	sts	0x58, r19
    aad8:	ed a8       	sts	0x8d, r30
    aada:	fe a8       	sts	0x8e, r31
    aadc:	0f a9       	sts	0x4f, r16
    aade:	18 ad       	sts	0x68, r17
    aae0:	04 c0       	rjmp	.+8      	; 0xaaea <__divdi3+0x624>
    aae2:	16 95       	lsr	r17
    aae4:	07 95       	ror	r16
    aae6:	f7 94       	ror	r15
    aae8:	e7 94       	ror	r14
    aaea:	4a 95       	dec	r20
    aaec:	d2 f7       	brpl	.-12     	; 0xaae2 <__divdi3+0x61c>
    aaee:	b8 01       	movw	r22, r16
    aaf0:	a7 01       	movw	r20, r14
    aaf2:	0d a5       	lds	r16, 0x6d
    aaf4:	1e a5       	lds	r17, 0x6e
    aaf6:	2f a5       	lds	r18, 0x6f
    aaf8:	38 a9       	sts	0x48, r19
    aafa:	04 2b       	or	r16, r20
    aafc:	15 2b       	or	r17, r21
    aafe:	26 2b       	or	r18, r22
    ab00:	37 2b       	or	r19, r23
    ab02:	0d a7       	lds	r16, 0x7d
    ab04:	1e a7       	lds	r17, 0x7e
    ab06:	2f a7       	lds	r18, 0x7f
    ab08:	38 ab       	sts	0x58, r19
    ab0a:	ed a8       	sts	0x8d, r30
    ab0c:	fe a8       	sts	0x8e, r31
    ab0e:	0f a9       	sts	0x4f, r16
    ab10:	18 ad       	sts	0x68, r17
    ab12:	04 c0       	rjmp	.+8      	; 0xab1c <__divdi3+0x656>
    ab14:	ee 0c       	add	r14, r14
    ab16:	ff 1c       	adc	r15, r15
    ab18:	00 1f       	adc	r16, r16
    ab1a:	11 1f       	adc	r17, r17
    ab1c:	8a 95       	dec	r24
    ab1e:	d2 f7       	brpl	.-12     	; 0xab14 <__divdi3+0x64e>
    ab20:	ed aa       	sts	0x9d, r30
    ab22:	fe aa       	sts	0x9e, r31
    ab24:	0f ab       	sts	0x5f, r16
    ab26:	18 af       	sts	0x78, r17
    ab28:	25 01       	movw	r4, r10
    ab2a:	66 24       	eor	r6, r6
    ab2c:	77 24       	eor	r7, r7
    ab2e:	95 01       	movw	r18, r10
    ab30:	84 01       	movw	r16, r8
    ab32:	20 70       	andi	r18, 0x00	; 0
    ab34:	30 70       	andi	r19, 0x00	; 0
    ab36:	09 af       	sts	0x79, r16
    ab38:	1a af       	sts	0x7a, r17
    ab3a:	2b af       	sts	0x7b, r18
    ab3c:	3c af       	sts	0x7c, r19
    ab3e:	69 a9       	sts	0x49, r22
    ab40:	7a a9       	sts	0x4a, r23
    ab42:	8b a9       	sts	0x4b, r24
    ab44:	9c a9       	sts	0x4c, r25
    ab46:	a3 01       	movw	r20, r6
    ab48:	92 01       	movw	r18, r4
    ab4a:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    ab4e:	29 a7       	lds	r18, 0x79
    ab50:	3a a7       	lds	r19, 0x7a
    ab52:	4b a7       	lds	r20, 0x7b
    ab54:	5c a7       	lds	r21, 0x7c
    ab56:	6b 01       	movw	r12, r22
    ab58:	7c 01       	movw	r14, r24
    ab5a:	69 a9       	sts	0x49, r22
    ab5c:	7a a9       	sts	0x4a, r23
    ab5e:	8b a9       	sts	0x4b, r24
    ab60:	9c a9       	sts	0x4c, r25
    ab62:	a3 01       	movw	r20, r6
    ab64:	92 01       	movw	r18, r4
    ab66:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    ab6a:	ca 01       	movw	r24, r20
    ab6c:	b9 01       	movw	r22, r18
    ab6e:	29 ad       	sts	0x69, r18
    ab70:	3a ad       	sts	0x6a, r19
    ab72:	4b ad       	sts	0x6b, r20
    ab74:	5c ad       	sts	0x6c, r21
    ab76:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    ab7a:	ab 01       	movw	r20, r22
    ab7c:	bc 01       	movw	r22, r24
    ab7e:	76 01       	movw	r14, r12
    ab80:	dd 24       	eor	r13, r13
    ab82:	cc 24       	eor	r12, r12
    ab84:	0d a5       	lds	r16, 0x6d
    ab86:	1e a5       	lds	r17, 0x6e
    ab88:	2f a5       	lds	r18, 0x6f
    ab8a:	38 a9       	sts	0x48, r19
    ab8c:	c9 01       	movw	r24, r18
    ab8e:	aa 27       	eor	r26, r26
    ab90:	bb 27       	eor	r27, r27
    ab92:	c8 2a       	or	r12, r24
    ab94:	d9 2a       	or	r13, r25
    ab96:	ea 2a       	or	r14, r26
    ab98:	fb 2a       	or	r15, r27
    ab9a:	09 a5       	lds	r16, 0x69
    ab9c:	1a a5       	lds	r17, 0x6a
    ab9e:	2b a5       	lds	r18, 0x6b
    aba0:	3c a5       	lds	r19, 0x6c
    aba2:	c4 16       	cp	r12, r20
    aba4:	d5 06       	cpc	r13, r21
    aba6:	e6 06       	cpc	r14, r22
    aba8:	f7 06       	cpc	r15, r23
    abaa:	38 f5       	brcc	.+78     	; 0xabfa <__divdi3+0x734>
    abac:	01 50       	subi	r16, 0x01	; 1
    abae:	10 40       	sbci	r17, 0x00	; 0
    abb0:	20 40       	sbci	r18, 0x00	; 0
    abb2:	30 40       	sbci	r19, 0x00	; 0
    abb4:	09 ab       	sts	0x59, r16
    abb6:	1a ab       	sts	0x5a, r17
    abb8:	2b ab       	sts	0x5b, r18
    abba:	3c ab       	sts	0x5c, r19
    abbc:	c8 0c       	add	r12, r8
    abbe:	d9 1c       	adc	r13, r9
    abc0:	ea 1c       	adc	r14, r10
    abc2:	fb 1c       	adc	r15, r11
    abc4:	c8 14       	cp	r12, r8
    abc6:	d9 04       	cpc	r13, r9
    abc8:	ea 04       	cpc	r14, r10
    abca:	fb 04       	cpc	r15, r11
    abcc:	d0 f0       	brcs	.+52     	; 0xac02 <__divdi3+0x73c>
    abce:	c4 16       	cp	r12, r20
    abd0:	d5 06       	cpc	r13, r21
    abd2:	e6 06       	cpc	r14, r22
    abd4:	f7 06       	cpc	r15, r23
    abd6:	a8 f4       	brcc	.+42     	; 0xac02 <__divdi3+0x73c>
    abd8:	09 a5       	lds	r16, 0x69
    abda:	1a a5       	lds	r17, 0x6a
    abdc:	2b a5       	lds	r18, 0x6b
    abde:	3c a5       	lds	r19, 0x6c
    abe0:	02 50       	subi	r16, 0x02	; 2
    abe2:	10 40       	sbci	r17, 0x00	; 0
    abe4:	20 40       	sbci	r18, 0x00	; 0
    abe6:	30 40       	sbci	r19, 0x00	; 0
    abe8:	09 ab       	sts	0x59, r16
    abea:	1a ab       	sts	0x5a, r17
    abec:	2b ab       	sts	0x5b, r18
    abee:	3c ab       	sts	0x5c, r19
    abf0:	c8 0c       	add	r12, r8
    abf2:	d9 1c       	adc	r13, r9
    abf4:	ea 1c       	adc	r14, r10
    abf6:	fb 1c       	adc	r15, r11
    abf8:	04 c0       	rjmp	.+8      	; 0xac02 <__divdi3+0x73c>
    abfa:	09 ab       	sts	0x59, r16
    abfc:	1a ab       	sts	0x5a, r17
    abfe:	2b ab       	sts	0x5b, r18
    ac00:	3c ab       	sts	0x5c, r19
    ac02:	c4 1a       	sub	r12, r20
    ac04:	d5 0a       	sbc	r13, r21
    ac06:	e6 0a       	sbc	r14, r22
    ac08:	f7 0a       	sbc	r15, r23
    ac0a:	c7 01       	movw	r24, r14
    ac0c:	b6 01       	movw	r22, r12
    ac0e:	a3 01       	movw	r20, r6
    ac10:	92 01       	movw	r18, r4
    ac12:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    ac16:	29 a7       	lds	r18, 0x79
    ac18:	3a a7       	lds	r19, 0x7a
    ac1a:	4b a7       	lds	r20, 0x7b
    ac1c:	5c a7       	lds	r21, 0x7c
    ac1e:	21 96       	adiw	r28, 0x01	; 1
    ac20:	6c af       	sts	0x7c, r22
    ac22:	7d af       	sts	0x7d, r23
    ac24:	8e af       	sts	0x7e, r24
    ac26:	9f af       	sts	0x7f, r25
    ac28:	21 97       	sbiw	r28, 0x01	; 1
    ac2a:	c7 01       	movw	r24, r14
    ac2c:	b6 01       	movw	r22, r12
    ac2e:	a3 01       	movw	r20, r6
    ac30:	92 01       	movw	r18, r4
    ac32:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    ac36:	ca 01       	movw	r24, r20
    ac38:	b9 01       	movw	r22, r18
    ac3a:	29 ad       	sts	0x69, r18
    ac3c:	3a ad       	sts	0x6a, r19
    ac3e:	4b ad       	sts	0x6b, r20
    ac40:	5c ad       	sts	0x6c, r21
    ac42:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    ac46:	8b 01       	movw	r16, r22
    ac48:	9c 01       	movw	r18, r24
    ac4a:	21 96       	adiw	r28, 0x01	; 1
    ac4c:	4c ad       	sts	0x6c, r20
    ac4e:	5d ad       	sts	0x6d, r21
    ac50:	6e ad       	sts	0x6e, r22
    ac52:	7f ad       	sts	0x6f, r23
    ac54:	21 97       	sbiw	r28, 0x01	; 1
    ac56:	da 01       	movw	r26, r20
    ac58:	99 27       	eor	r25, r25
    ac5a:	88 27       	eor	r24, r24
    ac5c:	4d a5       	lds	r20, 0x6d
    ac5e:	5e a5       	lds	r21, 0x6e
    ac60:	6f a5       	lds	r22, 0x6f
    ac62:	78 a9       	sts	0x48, r23
    ac64:	60 70       	andi	r22, 0x00	; 0
    ac66:	70 70       	andi	r23, 0x00	; 0
    ac68:	84 2b       	or	r24, r20
    ac6a:	95 2b       	or	r25, r21
    ac6c:	a6 2b       	or	r26, r22
    ac6e:	b7 2b       	or	r27, r23
    ac70:	49 a5       	lds	r20, 0x69
    ac72:	5a a5       	lds	r21, 0x6a
    ac74:	6b a5       	lds	r22, 0x6b
    ac76:	7c a5       	lds	r23, 0x6c
    ac78:	80 17       	cp	r24, r16
    ac7a:	91 07       	cpc	r25, r17
    ac7c:	a2 07       	cpc	r26, r18
    ac7e:	b3 07       	cpc	r27, r19
    ac80:	f0 f4       	brcc	.+60     	; 0xacbe <__divdi3+0x7f8>
    ac82:	41 50       	subi	r20, 0x01	; 1
    ac84:	50 40       	sbci	r21, 0x00	; 0
    ac86:	60 40       	sbci	r22, 0x00	; 0
    ac88:	70 40       	sbci	r23, 0x00	; 0
    ac8a:	88 0d       	add	r24, r8
    ac8c:	99 1d       	adc	r25, r9
    ac8e:	aa 1d       	adc	r26, r10
    ac90:	bb 1d       	adc	r27, r11
    ac92:	88 15       	cp	r24, r8
    ac94:	99 05       	cpc	r25, r9
    ac96:	aa 05       	cpc	r26, r10
    ac98:	bb 05       	cpc	r27, r11
    ac9a:	88 f0       	brcs	.+34     	; 0xacbe <__divdi3+0x7f8>
    ac9c:	80 17       	cp	r24, r16
    ac9e:	91 07       	cpc	r25, r17
    aca0:	a2 07       	cpc	r26, r18
    aca2:	b3 07       	cpc	r27, r19
    aca4:	60 f4       	brcc	.+24     	; 0xacbe <__divdi3+0x7f8>
    aca6:	49 a5       	lds	r20, 0x69
    aca8:	5a a5       	lds	r21, 0x6a
    acaa:	6b a5       	lds	r22, 0x6b
    acac:	7c a5       	lds	r23, 0x6c
    acae:	42 50       	subi	r20, 0x02	; 2
    acb0:	50 40       	sbci	r21, 0x00	; 0
    acb2:	60 40       	sbci	r22, 0x00	; 0
    acb4:	70 40       	sbci	r23, 0x00	; 0
    acb6:	88 0d       	add	r24, r8
    acb8:	99 1d       	adc	r25, r9
    acba:	aa 1d       	adc	r26, r10
    acbc:	bb 1d       	adc	r27, r11
    acbe:	6c 01       	movw	r12, r24
    acc0:	7d 01       	movw	r14, r26
    acc2:	c0 1a       	sub	r12, r16
    acc4:	d1 0a       	sbc	r13, r17
    acc6:	e2 0a       	sbc	r14, r18
    acc8:	f3 0a       	sbc	r15, r19
    acca:	09 a9       	sts	0x49, r16
    accc:	1a a9       	sts	0x4a, r17
    acce:	2b a9       	sts	0x4b, r18
    acd0:	3c a9       	sts	0x4c, r19
    acd2:	38 01       	movw	r6, r16
    acd4:	55 24       	eor	r5, r5
    acd6:	44 24       	eor	r4, r4
    acd8:	44 2a       	or	r4, r20
    acda:	55 2a       	or	r5, r21
    acdc:	66 2a       	or	r6, r22
    acde:	77 2a       	or	r7, r23
    ace0:	85 01       	movw	r16, r10
    ace2:	22 27       	eor	r18, r18
    ace4:	33 27       	eor	r19, r19
    ace6:	0d a7       	lds	r16, 0x7d
    ace8:	1e a7       	lds	r17, 0x7e
    acea:	2f a7       	lds	r18, 0x7f
    acec:	38 ab       	sts	0x58, r19
    acee:	95 01       	movw	r18, r10
    acf0:	84 01       	movw	r16, r8
    acf2:	20 70       	andi	r18, 0x00	; 0
    acf4:	30 70       	andi	r19, 0x00	; 0
    acf6:	09 af       	sts	0x79, r16
    acf8:	1a af       	sts	0x7a, r17
    acfa:	2b af       	sts	0x7b, r18
    acfc:	3c af       	sts	0x7c, r19
    acfe:	c7 01       	movw	r24, r14
    ad00:	b6 01       	movw	r22, r12
    ad02:	2d a5       	lds	r18, 0x6d
    ad04:	3e a5       	lds	r19, 0x6e
    ad06:	4f a5       	lds	r20, 0x6f
    ad08:	58 a9       	sts	0x48, r21
    ad0a:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    ad0e:	29 a7       	lds	r18, 0x79
    ad10:	3a a7       	lds	r19, 0x7a
    ad12:	4b a7       	lds	r20, 0x7b
    ad14:	5c a7       	lds	r21, 0x7c
    ad16:	69 ab       	sts	0x59, r22
    ad18:	7a ab       	sts	0x5a, r23
    ad1a:	8b ab       	sts	0x5b, r24
    ad1c:	9c ab       	sts	0x5c, r25
    ad1e:	c7 01       	movw	r24, r14
    ad20:	b6 01       	movw	r22, r12
    ad22:	2d a5       	lds	r18, 0x6d
    ad24:	3e a5       	lds	r19, 0x6e
    ad26:	4f a5       	lds	r20, 0x6f
    ad28:	58 a9       	sts	0x48, r21
    ad2a:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    ad2e:	ca 01       	movw	r24, r20
    ad30:	b9 01       	movw	r22, r18
    ad32:	29 ad       	sts	0x69, r18
    ad34:	3a ad       	sts	0x6a, r19
    ad36:	4b ad       	sts	0x6b, r20
    ad38:	5c ad       	sts	0x6c, r21
    ad3a:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    ad3e:	ab 01       	movw	r20, r22
    ad40:	bc 01       	movw	r22, r24
    ad42:	09 a9       	sts	0x49, r16
    ad44:	1a a9       	sts	0x4a, r17
    ad46:	2b a9       	sts	0x4b, r18
    ad48:	3c a9       	sts	0x4c, r19
    ad4a:	78 01       	movw	r14, r16
    ad4c:	dd 24       	eor	r13, r13
    ad4e:	cc 24       	eor	r12, r12
    ad50:	0d a9       	sts	0x4d, r16
    ad52:	1e a9       	sts	0x4e, r17
    ad54:	2f a9       	sts	0x4f, r18
    ad56:	38 ad       	sts	0x68, r19
    ad58:	c9 01       	movw	r24, r18
    ad5a:	aa 27       	eor	r26, r26
    ad5c:	bb 27       	eor	r27, r27
    ad5e:	c8 2a       	or	r12, r24
    ad60:	d9 2a       	or	r13, r25
    ad62:	ea 2a       	or	r14, r26
    ad64:	fb 2a       	or	r15, r27
    ad66:	09 a5       	lds	r16, 0x69
    ad68:	1a a5       	lds	r17, 0x6a
    ad6a:	2b a5       	lds	r18, 0x6b
    ad6c:	3c a5       	lds	r19, 0x6c
    ad6e:	c4 16       	cp	r12, r20
    ad70:	d5 06       	cpc	r13, r21
    ad72:	e6 06       	cpc	r14, r22
    ad74:	f7 06       	cpc	r15, r23
    ad76:	38 f5       	brcc	.+78     	; 0xadc6 <__divdi3+0x900>
    ad78:	01 50       	subi	r16, 0x01	; 1
    ad7a:	10 40       	sbci	r17, 0x00	; 0
    ad7c:	20 40       	sbci	r18, 0x00	; 0
    ad7e:	30 40       	sbci	r19, 0x00	; 0
    ad80:	09 ab       	sts	0x59, r16
    ad82:	1a ab       	sts	0x5a, r17
    ad84:	2b ab       	sts	0x5b, r18
    ad86:	3c ab       	sts	0x5c, r19
    ad88:	c8 0c       	add	r12, r8
    ad8a:	d9 1c       	adc	r13, r9
    ad8c:	ea 1c       	adc	r14, r10
    ad8e:	fb 1c       	adc	r15, r11
    ad90:	c8 14       	cp	r12, r8
    ad92:	d9 04       	cpc	r13, r9
    ad94:	ea 04       	cpc	r14, r10
    ad96:	fb 04       	cpc	r15, r11
    ad98:	d0 f0       	brcs	.+52     	; 0xadce <__divdi3+0x908>
    ad9a:	c4 16       	cp	r12, r20
    ad9c:	d5 06       	cpc	r13, r21
    ad9e:	e6 06       	cpc	r14, r22
    ada0:	f7 06       	cpc	r15, r23
    ada2:	a8 f4       	brcc	.+42     	; 0xadce <__divdi3+0x908>
    ada4:	09 a5       	lds	r16, 0x69
    ada6:	1a a5       	lds	r17, 0x6a
    ada8:	2b a5       	lds	r18, 0x6b
    adaa:	3c a5       	lds	r19, 0x6c
    adac:	02 50       	subi	r16, 0x02	; 2
    adae:	10 40       	sbci	r17, 0x00	; 0
    adb0:	20 40       	sbci	r18, 0x00	; 0
    adb2:	30 40       	sbci	r19, 0x00	; 0
    adb4:	09 ab       	sts	0x59, r16
    adb6:	1a ab       	sts	0x5a, r17
    adb8:	2b ab       	sts	0x5b, r18
    adba:	3c ab       	sts	0x5c, r19
    adbc:	c8 0c       	add	r12, r8
    adbe:	d9 1c       	adc	r13, r9
    adc0:	ea 1c       	adc	r14, r10
    adc2:	fb 1c       	adc	r15, r11
    adc4:	04 c0       	rjmp	.+8      	; 0xadce <__divdi3+0x908>
    adc6:	09 ab       	sts	0x59, r16
    adc8:	1a ab       	sts	0x5a, r17
    adca:	2b ab       	sts	0x5b, r18
    adcc:	3c ab       	sts	0x5c, r19
    adce:	c4 1a       	sub	r12, r20
    add0:	d5 0a       	sbc	r13, r21
    add2:	e6 0a       	sbc	r14, r22
    add4:	f7 0a       	sbc	r15, r23
    add6:	c7 01       	movw	r24, r14
    add8:	b6 01       	movw	r22, r12
    adda:	2d a5       	lds	r18, 0x6d
    addc:	3e a5       	lds	r19, 0x6e
    adde:	4f a5       	lds	r20, 0x6f
    ade0:	58 a9       	sts	0x48, r21
    ade2:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    ade6:	29 a7       	lds	r18, 0x79
    ade8:	3a a7       	lds	r19, 0x7a
    adea:	4b a7       	lds	r20, 0x7b
    adec:	5c a7       	lds	r21, 0x7c
    adee:	21 96       	adiw	r28, 0x01	; 1
    adf0:	6c af       	sts	0x7c, r22
    adf2:	7d af       	sts	0x7d, r23
    adf4:	8e af       	sts	0x7e, r24
    adf6:	9f af       	sts	0x7f, r25
    adf8:	21 97       	sbiw	r28, 0x01	; 1
    adfa:	c7 01       	movw	r24, r14
    adfc:	b6 01       	movw	r22, r12
    adfe:	2d a5       	lds	r18, 0x6d
    ae00:	3e a5       	lds	r19, 0x6e
    ae02:	4f a5       	lds	r20, 0x6f
    ae04:	58 a9       	sts	0x48, r21
    ae06:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    ae0a:	ca 01       	movw	r24, r20
    ae0c:	b9 01       	movw	r22, r18
    ae0e:	29 ad       	sts	0x69, r18
    ae10:	3a ad       	sts	0x6a, r19
    ae12:	4b ad       	sts	0x6b, r20
    ae14:	5c ad       	sts	0x6c, r21
    ae16:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    ae1a:	8b 01       	movw	r16, r22
    ae1c:	9c 01       	movw	r18, r24
    ae1e:	21 96       	adiw	r28, 0x01	; 1
    ae20:	4c ad       	sts	0x6c, r20
    ae22:	5d ad       	sts	0x6d, r21
    ae24:	6e ad       	sts	0x6e, r22
    ae26:	7f ad       	sts	0x6f, r23
    ae28:	21 97       	sbiw	r28, 0x01	; 1
    ae2a:	da 01       	movw	r26, r20
    ae2c:	99 27       	eor	r25, r25
    ae2e:	88 27       	eor	r24, r24
    ae30:	4d a9       	sts	0x4d, r20
    ae32:	5e a9       	sts	0x4e, r21
    ae34:	6f a9       	sts	0x4f, r22
    ae36:	78 ad       	sts	0x68, r23
    ae38:	60 70       	andi	r22, 0x00	; 0
    ae3a:	70 70       	andi	r23, 0x00	; 0
    ae3c:	84 2b       	or	r24, r20
    ae3e:	95 2b       	or	r25, r21
    ae40:	a6 2b       	or	r26, r22
    ae42:	b7 2b       	or	r27, r23
    ae44:	49 a5       	lds	r20, 0x69
    ae46:	5a a5       	lds	r21, 0x6a
    ae48:	6b a5       	lds	r22, 0x6b
    ae4a:	7c a5       	lds	r23, 0x6c
    ae4c:	80 17       	cp	r24, r16
    ae4e:	91 07       	cpc	r25, r17
    ae50:	a2 07       	cpc	r26, r18
    ae52:	b3 07       	cpc	r27, r19
    ae54:	d0 f4       	brcc	.+52     	; 0xae8a <__divdi3+0x9c4>
    ae56:	41 50       	subi	r20, 0x01	; 1
    ae58:	50 40       	sbci	r21, 0x00	; 0
    ae5a:	60 40       	sbci	r22, 0x00	; 0
    ae5c:	70 40       	sbci	r23, 0x00	; 0
    ae5e:	88 0d       	add	r24, r8
    ae60:	99 1d       	adc	r25, r9
    ae62:	aa 1d       	adc	r26, r10
    ae64:	bb 1d       	adc	r27, r11
    ae66:	88 15       	cp	r24, r8
    ae68:	99 05       	cpc	r25, r9
    ae6a:	aa 05       	cpc	r26, r10
    ae6c:	bb 05       	cpc	r27, r11
    ae6e:	68 f0       	brcs	.+26     	; 0xae8a <__divdi3+0x9c4>
    ae70:	80 17       	cp	r24, r16
    ae72:	91 07       	cpc	r25, r17
    ae74:	a2 07       	cpc	r26, r18
    ae76:	b3 07       	cpc	r27, r19
    ae78:	40 f4       	brcc	.+16     	; 0xae8a <__divdi3+0x9c4>
    ae7a:	49 a5       	lds	r20, 0x69
    ae7c:	5a a5       	lds	r21, 0x6a
    ae7e:	6b a5       	lds	r22, 0x6b
    ae80:	7c a5       	lds	r23, 0x6c
    ae82:	42 50       	subi	r20, 0x02	; 2
    ae84:	50 40       	sbci	r21, 0x00	; 0
    ae86:	60 40       	sbci	r22, 0x00	; 0
    ae88:	70 40       	sbci	r23, 0x00	; 0
    ae8a:	09 a9       	sts	0x49, r16
    ae8c:	1a a9       	sts	0x4a, r17
    ae8e:	2b a9       	sts	0x4b, r18
    ae90:	3c a9       	sts	0x4c, r19
    ae92:	78 01       	movw	r14, r16
    ae94:	dd 24       	eor	r13, r13
    ae96:	cc 24       	eor	r12, r12
    ae98:	c4 2a       	or	r12, r20
    ae9a:	d5 2a       	or	r13, r21
    ae9c:	e6 2a       	or	r14, r22
    ae9e:	f7 2a       	or	r15, r23
    aea0:	50 c2       	rjmp	.+1184   	; 0xb342 <__divdi3+0xe7c>
    aea2:	c8 16       	cp	r12, r24
    aea4:	d9 06       	cpc	r13, r25
    aea6:	ea 06       	cpc	r14, r26
    aea8:	fb 06       	cpc	r15, r27
    aeaa:	08 f4       	brcc	.+2      	; 0xaeae <__divdi3+0x9e8>
    aeac:	37 c2       	rjmp	.+1134   	; 0xb31c <__divdi3+0xe56>
    aeae:	80 30       	cpi	r24, 0x00	; 0
    aeb0:	10 e0       	ldi	r17, 0x00	; 0
    aeb2:	91 07       	cpc	r25, r17
    aeb4:	11 e0       	ldi	r17, 0x01	; 1
    aeb6:	a1 07       	cpc	r26, r17
    aeb8:	10 e0       	ldi	r17, 0x00	; 0
    aeba:	b1 07       	cpc	r27, r17
    aebc:	50 f4       	brcc	.+20     	; 0xaed2 <__divdi3+0xa0c>
    aebe:	8f 3f       	cpi	r24, 0xFF	; 255
    aec0:	91 05       	cpc	r25, r1
    aec2:	a1 05       	cpc	r26, r1
    aec4:	b1 05       	cpc	r27, r1
    aec6:	09 f0       	breq	.+2      	; 0xaeca <__divdi3+0xa04>
    aec8:	88 f4       	brcc	.+34     	; 0xaeec <__divdi3+0xa26>
    aeca:	00 e0       	ldi	r16, 0x00	; 0
    aecc:	10 e0       	ldi	r17, 0x00	; 0
    aece:	98 01       	movw	r18, r16
    aed0:	16 c0       	rjmp	.+44     	; 0xaefe <__divdi3+0xa38>
    aed2:	80 30       	cpi	r24, 0x00	; 0
    aed4:	20 e0       	ldi	r18, 0x00	; 0
    aed6:	92 07       	cpc	r25, r18
    aed8:	20 e0       	ldi	r18, 0x00	; 0
    aeda:	a2 07       	cpc	r26, r18
    aedc:	21 e0       	ldi	r18, 0x01	; 1
    aede:	b2 07       	cpc	r27, r18
    aee0:	50 f4       	brcc	.+20     	; 0xaef6 <__divdi3+0xa30>
    aee2:	00 e1       	ldi	r16, 0x10	; 16
    aee4:	10 e0       	ldi	r17, 0x00	; 0
    aee6:	20 e0       	ldi	r18, 0x00	; 0
    aee8:	30 e0       	ldi	r19, 0x00	; 0
    aeea:	09 c0       	rjmp	.+18     	; 0xaefe <__divdi3+0xa38>
    aeec:	08 e0       	ldi	r16, 0x08	; 8
    aeee:	10 e0       	ldi	r17, 0x00	; 0
    aef0:	20 e0       	ldi	r18, 0x00	; 0
    aef2:	30 e0       	ldi	r19, 0x00	; 0
    aef4:	04 c0       	rjmp	.+8      	; 0xaefe <__divdi3+0xa38>
    aef6:	08 e1       	ldi	r16, 0x18	; 24
    aef8:	10 e0       	ldi	r17, 0x00	; 0
    aefa:	20 e0       	ldi	r18, 0x00	; 0
    aefc:	30 e0       	ldi	r19, 0x00	; 0
    aefe:	ac 01       	movw	r20, r24
    af00:	bd 01       	movw	r22, r26
    af02:	00 2e       	mov	r0, r16
    af04:	04 c0       	rjmp	.+8      	; 0xaf0e <__divdi3+0xa48>
    af06:	76 95       	lsr	r23
    af08:	67 95       	ror	r22
    af0a:	57 95       	ror	r21
    af0c:	47 95       	ror	r20
    af0e:	0a 94       	dec	r0
    af10:	d2 f7       	brpl	.-12     	; 0xaf06 <__divdi3+0xa40>
    af12:	fa 01       	movw	r30, r20
    af14:	ee 5c       	subi	r30, 0xCE	; 206
    af16:	ff 4d       	sbci	r31, 0xDF	; 223
    af18:	40 81       	ld	r20, Z
    af1a:	04 0f       	add	r16, r20
    af1c:	11 1d       	adc	r17, r1
    af1e:	21 1d       	adc	r18, r1
    af20:	31 1d       	adc	r19, r1
    af22:	40 e2       	ldi	r20, 0x20	; 32
    af24:	50 e0       	ldi	r21, 0x00	; 0
    af26:	60 e0       	ldi	r22, 0x00	; 0
    af28:	70 e0       	ldi	r23, 0x00	; 0
    af2a:	40 1b       	sub	r20, r16
    af2c:	51 0b       	sbc	r21, r17
    af2e:	62 0b       	sbc	r22, r18
    af30:	73 0b       	sbc	r23, r19
    af32:	a1 f4       	brne	.+40     	; 0xaf5c <__divdi3+0xa96>
    af34:	8c 15       	cp	r24, r12
    af36:	9d 05       	cpc	r25, r13
    af38:	ae 05       	cpc	r26, r14
    af3a:	bf 05       	cpc	r27, r15
    af3c:	08 f4       	brcc	.+2      	; 0xaf40 <__divdi3+0xa7a>
    af3e:	f5 c1       	rjmp	.+1002   	; 0xb32a <__divdi3+0xe64>
    af40:	ed a8       	sts	0x8d, r30
    af42:	fe a8       	sts	0x8e, r31
    af44:	0f a9       	sts	0x4f, r16
    af46:	18 ad       	sts	0x68, r17
    af48:	44 24       	eor	r4, r4
    af4a:	55 24       	eor	r5, r5
    af4c:	32 01       	movw	r6, r4
    af4e:	e8 14       	cp	r14, r8
    af50:	f9 04       	cpc	r15, r9
    af52:	0a 05       	cpc	r16, r10
    af54:	1b 05       	cpc	r17, r11
    af56:	08 f0       	brcs	.+2      	; 0xaf5a <__divdi3+0xa94>
    af58:	eb c1       	rjmp	.+982    	; 0xb330 <__divdi3+0xe6a>
    af5a:	e3 c1       	rjmp	.+966    	; 0xb322 <__divdi3+0xe5c>
    af5c:	34 2e       	mov	r3, r20
    af5e:	2c 01       	movw	r4, r24
    af60:	3d 01       	movw	r6, r26
    af62:	04 c0       	rjmp	.+8      	; 0xaf6c <__divdi3+0xaa6>
    af64:	44 0c       	add	r4, r4
    af66:	55 1c       	adc	r5, r5
    af68:	66 1c       	adc	r6, r6
    af6a:	77 1c       	adc	r7, r7
    af6c:	4a 95       	dec	r20
    af6e:	d2 f7       	brpl	.-12     	; 0xaf64 <__divdi3+0xa9e>
    af70:	d5 01       	movw	r26, r10
    af72:	c4 01       	movw	r24, r8
    af74:	00 2e       	mov	r0, r16
    af76:	04 c0       	rjmp	.+8      	; 0xaf80 <__divdi3+0xaba>
    af78:	b6 95       	lsr	r27
    af7a:	a7 95       	ror	r26
    af7c:	97 95       	ror	r25
    af7e:	87 95       	ror	r24
    af80:	0a 94       	dec	r0
    af82:	d2 f7       	brpl	.-12     	; 0xaf78 <__divdi3+0xab2>
    af84:	48 2a       	or	r4, r24
    af86:	59 2a       	or	r5, r25
    af88:	6a 2a       	or	r6, r26
    af8a:	7b 2a       	or	r7, r27
    af8c:	a5 01       	movw	r20, r10
    af8e:	94 01       	movw	r18, r8
    af90:	03 2c       	mov	r0, r3
    af92:	04 c0       	rjmp	.+8      	; 0xaf9c <__divdi3+0xad6>
    af94:	22 0f       	add	r18, r18
    af96:	33 1f       	adc	r19, r19
    af98:	44 1f       	adc	r20, r20
    af9a:	55 1f       	adc	r21, r21
    af9c:	0a 94       	dec	r0
    af9e:	d2 f7       	brpl	.-12     	; 0xaf94 <__divdi3+0xace>
    afa0:	29 af       	sts	0x79, r18
    afa2:	3a af       	sts	0x7a, r19
    afa4:	4b af       	sts	0x7b, r20
    afa6:	5c af       	sts	0x7c, r21
    afa8:	b7 01       	movw	r22, r14
    afaa:	a6 01       	movw	r20, r12
    afac:	00 2e       	mov	r0, r16
    afae:	04 c0       	rjmp	.+8      	; 0xafb8 <__divdi3+0xaf2>
    afb0:	76 95       	lsr	r23
    afb2:	67 95       	ror	r22
    afb4:	57 95       	ror	r21
    afb6:	47 95       	ror	r20
    afb8:	0a 94       	dec	r0
    afba:	d2 f7       	brpl	.-12     	; 0xafb0 <__divdi3+0xaea>
    afbc:	49 ab       	sts	0x59, r20
    afbe:	5a ab       	sts	0x5a, r21
    afc0:	6b ab       	sts	0x5b, r22
    afc2:	7c ab       	sts	0x5c, r23
    afc4:	c7 01       	movw	r24, r14
    afc6:	b6 01       	movw	r22, r12
    afc8:	03 2c       	mov	r0, r3
    afca:	04 c0       	rjmp	.+8      	; 0xafd4 <__divdi3+0xb0e>
    afcc:	66 0f       	add	r22, r22
    afce:	77 1f       	adc	r23, r23
    afd0:	88 1f       	adc	r24, r24
    afd2:	99 1f       	adc	r25, r25
    afd4:	0a 94       	dec	r0
    afd6:	d2 f7       	brpl	.-12     	; 0xafcc <__divdi3+0xb06>
    afd8:	6d a7       	lds	r22, 0x7d
    afda:	7e a7       	lds	r23, 0x7e
    afdc:	8f a7       	lds	r24, 0x7f
    afde:	98 ab       	sts	0x58, r25
    afe0:	8d a9       	sts	0x4d, r24
    afe2:	9e a9       	sts	0x4e, r25
    afe4:	af a9       	sts	0x4f, r26
    afe6:	b8 ad       	sts	0x68, r27
    afe8:	04 c0       	rjmp	.+8      	; 0xaff2 <__divdi3+0xb2c>
    afea:	b6 95       	lsr	r27
    afec:	a7 95       	ror	r26
    afee:	97 95       	ror	r25
    aff0:	87 95       	ror	r24
    aff2:	0a 95       	dec	r16
    aff4:	d2 f7       	brpl	.-12     	; 0xafea <__divdi3+0xb24>
    aff6:	4d a5       	lds	r20, 0x6d
    aff8:	5e a5       	lds	r21, 0x6e
    affa:	6f a5       	lds	r22, 0x6f
    affc:	78 a9       	sts	0x48, r23
    affe:	48 2b       	or	r20, r24
    b000:	59 2b       	or	r21, r25
    b002:	6a 2b       	or	r22, r26
    b004:	7b 2b       	or	r23, r27
    b006:	4d a7       	lds	r20, 0x7d
    b008:	5e a7       	lds	r21, 0x7e
    b00a:	6f a7       	lds	r22, 0x7f
    b00c:	78 ab       	sts	0x58, r23
    b00e:	43 01       	movw	r8, r6
    b010:	aa 24       	eor	r10, r10
    b012:	bb 24       	eor	r11, r11
    b014:	93 01       	movw	r18, r6
    b016:	82 01       	movw	r16, r4
    b018:	20 70       	andi	r18, 0x00	; 0
    b01a:	30 70       	andi	r19, 0x00	; 0
    b01c:	21 96       	adiw	r28, 0x01	; 1
    b01e:	0c af       	sts	0x7c, r16
    b020:	1d af       	sts	0x7d, r17
    b022:	2e af       	sts	0x7e, r18
    b024:	3f af       	sts	0x7f, r19
    b026:	21 97       	sbiw	r28, 0x01	; 1
    b028:	69 a9       	sts	0x49, r22
    b02a:	7a a9       	sts	0x4a, r23
    b02c:	8b a9       	sts	0x4b, r24
    b02e:	9c a9       	sts	0x4c, r25
    b030:	a5 01       	movw	r20, r10
    b032:	94 01       	movw	r18, r8
    b034:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    b038:	29 a7       	lds	r18, 0x79
    b03a:	3a a7       	lds	r19, 0x7a
    b03c:	4b a7       	lds	r20, 0x7b
    b03e:	5c a7       	lds	r21, 0x7c
    b040:	6b 01       	movw	r12, r22
    b042:	7c 01       	movw	r14, r24
    b044:	69 a9       	sts	0x49, r22
    b046:	7a a9       	sts	0x4a, r23
    b048:	8b a9       	sts	0x4b, r24
    b04a:	9c a9       	sts	0x4c, r25
    b04c:	a5 01       	movw	r20, r10
    b04e:	94 01       	movw	r18, r8
    b050:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    b054:	ca 01       	movw	r24, r20
    b056:	b9 01       	movw	r22, r18
    b058:	21 96       	adiw	r28, 0x01	; 1
    b05a:	2c ad       	sts	0x6c, r18
    b05c:	3d ad       	sts	0x6d, r19
    b05e:	4e ad       	sts	0x6e, r20
    b060:	5f ad       	sts	0x6f, r21
    b062:	21 97       	sbiw	r28, 0x01	; 1
    b064:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    b068:	dc 01       	movw	r26, r24
    b06a:	cb 01       	movw	r24, r22
    b06c:	76 01       	movw	r14, r12
    b06e:	dd 24       	eor	r13, r13
    b070:	cc 24       	eor	r12, r12
    b072:	0d a5       	lds	r16, 0x6d
    b074:	1e a5       	lds	r17, 0x6e
    b076:	2f a5       	lds	r18, 0x6f
    b078:	38 a9       	sts	0x48, r19
    b07a:	a9 01       	movw	r20, r18
    b07c:	66 27       	eor	r22, r22
    b07e:	77 27       	eor	r23, r23
    b080:	c4 2a       	or	r12, r20
    b082:	d5 2a       	or	r13, r21
    b084:	e6 2a       	or	r14, r22
    b086:	f7 2a       	or	r15, r23
    b088:	09 a5       	lds	r16, 0x69
    b08a:	1a a5       	lds	r17, 0x6a
    b08c:	2b a5       	lds	r18, 0x6b
    b08e:	3c a5       	lds	r19, 0x6c
    b090:	c8 16       	cp	r12, r24
    b092:	d9 06       	cpc	r13, r25
    b094:	ea 06       	cpc	r14, r26
    b096:	fb 06       	cpc	r15, r27
    b098:	38 f5       	brcc	.+78     	; 0xb0e8 <__divdi3+0xc22>
    b09a:	01 50       	subi	r16, 0x01	; 1
    b09c:	10 40       	sbci	r17, 0x00	; 0
    b09e:	20 40       	sbci	r18, 0x00	; 0
    b0a0:	30 40       	sbci	r19, 0x00	; 0
    b0a2:	09 ab       	sts	0x59, r16
    b0a4:	1a ab       	sts	0x5a, r17
    b0a6:	2b ab       	sts	0x5b, r18
    b0a8:	3c ab       	sts	0x5c, r19
    b0aa:	c4 0c       	add	r12, r4
    b0ac:	d5 1c       	adc	r13, r5
    b0ae:	e6 1c       	adc	r14, r6
    b0b0:	f7 1c       	adc	r15, r7
    b0b2:	c4 14       	cp	r12, r4
    b0b4:	d5 04       	cpc	r13, r5
    b0b6:	e6 04       	cpc	r14, r6
    b0b8:	f7 04       	cpc	r15, r7
    b0ba:	d0 f0       	brcs	.+52     	; 0xb0f0 <__divdi3+0xc2a>
    b0bc:	c8 16       	cp	r12, r24
    b0be:	d9 06       	cpc	r13, r25
    b0c0:	ea 06       	cpc	r14, r26
    b0c2:	fb 06       	cpc	r15, r27
    b0c4:	a8 f4       	brcc	.+42     	; 0xb0f0 <__divdi3+0xc2a>
    b0c6:	09 a5       	lds	r16, 0x69
    b0c8:	1a a5       	lds	r17, 0x6a
    b0ca:	2b a5       	lds	r18, 0x6b
    b0cc:	3c a5       	lds	r19, 0x6c
    b0ce:	02 50       	subi	r16, 0x02	; 2
    b0d0:	10 40       	sbci	r17, 0x00	; 0
    b0d2:	20 40       	sbci	r18, 0x00	; 0
    b0d4:	30 40       	sbci	r19, 0x00	; 0
    b0d6:	09 ab       	sts	0x59, r16
    b0d8:	1a ab       	sts	0x5a, r17
    b0da:	2b ab       	sts	0x5b, r18
    b0dc:	3c ab       	sts	0x5c, r19
    b0de:	c4 0c       	add	r12, r4
    b0e0:	d5 1c       	adc	r13, r5
    b0e2:	e6 1c       	adc	r14, r6
    b0e4:	f7 1c       	adc	r15, r7
    b0e6:	04 c0       	rjmp	.+8      	; 0xb0f0 <__divdi3+0xc2a>
    b0e8:	09 ab       	sts	0x59, r16
    b0ea:	1a ab       	sts	0x5a, r17
    b0ec:	2b ab       	sts	0x5b, r18
    b0ee:	3c ab       	sts	0x5c, r19
    b0f0:	c8 1a       	sub	r12, r24
    b0f2:	d9 0a       	sbc	r13, r25
    b0f4:	ea 0a       	sbc	r14, r26
    b0f6:	fb 0a       	sbc	r15, r27
    b0f8:	c7 01       	movw	r24, r14
    b0fa:	b6 01       	movw	r22, r12
    b0fc:	a5 01       	movw	r20, r10
    b0fe:	94 01       	movw	r18, r8
    b100:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    b104:	29 a7       	lds	r18, 0x79
    b106:	3a a7       	lds	r19, 0x7a
    b108:	4b a7       	lds	r20, 0x7b
    b10a:	5c a7       	lds	r21, 0x7c
    b10c:	29 96       	adiw	r28, 0x09	; 9
    b10e:	6c af       	sts	0x7c, r22
    b110:	7d af       	sts	0x7d, r23
    b112:	8e af       	sts	0x7e, r24
    b114:	9f af       	sts	0x7f, r25
    b116:	29 97       	sbiw	r28, 0x09	; 9
    b118:	c7 01       	movw	r24, r14
    b11a:	b6 01       	movw	r22, r12
    b11c:	a5 01       	movw	r20, r10
    b11e:	94 01       	movw	r18, r8
    b120:	0e 94 d9 5b 	call	0xb7b2	; 0xb7b2 <__udivmodsi4>
    b124:	ca 01       	movw	r24, r20
    b126:	b9 01       	movw	r22, r18
    b128:	21 96       	adiw	r28, 0x01	; 1
    b12a:	2c ad       	sts	0x6c, r18
    b12c:	3d ad       	sts	0x6d, r19
    b12e:	4e ad       	sts	0x6e, r20
    b130:	5f ad       	sts	0x6f, r21
    b132:	21 97       	sbiw	r28, 0x01	; 1
    b134:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    b138:	4b 01       	movw	r8, r22
    b13a:	5c 01       	movw	r10, r24
    b13c:	29 96       	adiw	r28, 0x09	; 9
    b13e:	4c ad       	sts	0x6c, r20
    b140:	5d ad       	sts	0x6d, r21
    b142:	6e ad       	sts	0x6e, r22
    b144:	7f ad       	sts	0x6f, r23
    b146:	29 97       	sbiw	r28, 0x09	; 9
    b148:	9a 01       	movw	r18, r20
    b14a:	11 27       	eor	r17, r17
    b14c:	00 27       	eor	r16, r16
    b14e:	8d a5       	lds	r24, 0x6d
    b150:	9e a5       	lds	r25, 0x6e
    b152:	af a5       	lds	r26, 0x6f
    b154:	b8 a9       	sts	0x48, r27
    b156:	a0 70       	andi	r26, 0x00	; 0
    b158:	b0 70       	andi	r27, 0x00	; 0
    b15a:	08 2b       	or	r16, r24
    b15c:	19 2b       	or	r17, r25
    b15e:	2a 2b       	or	r18, r26
    b160:	3b 2b       	or	r19, r27
    b162:	89 a5       	lds	r24, 0x69
    b164:	9a a5       	lds	r25, 0x6a
    b166:	ab a5       	lds	r26, 0x6b
    b168:	bc a5       	lds	r27, 0x6c
    b16a:	08 15       	cp	r16, r8
    b16c:	19 05       	cpc	r17, r9
    b16e:	2a 05       	cpc	r18, r10
    b170:	3b 05       	cpc	r19, r11
    b172:	e0 f4       	brcc	.+56     	; 0xb1ac <__divdi3+0xce6>
    b174:	01 97       	sbiw	r24, 0x01	; 1
    b176:	a1 09       	sbc	r26, r1
    b178:	b1 09       	sbc	r27, r1
    b17a:	04 0d       	add	r16, r4
    b17c:	15 1d       	adc	r17, r5
    b17e:	26 1d       	adc	r18, r6
    b180:	37 1d       	adc	r19, r7
    b182:	04 15       	cp	r16, r4
    b184:	15 05       	cpc	r17, r5
    b186:	26 05       	cpc	r18, r6
    b188:	37 05       	cpc	r19, r7
    b18a:	80 f0       	brcs	.+32     	; 0xb1ac <__divdi3+0xce6>
    b18c:	08 15       	cp	r16, r8
    b18e:	19 05       	cpc	r17, r9
    b190:	2a 05       	cpc	r18, r10
    b192:	3b 05       	cpc	r19, r11
    b194:	58 f4       	brcc	.+22     	; 0xb1ac <__divdi3+0xce6>
    b196:	89 a5       	lds	r24, 0x69
    b198:	9a a5       	lds	r25, 0x6a
    b19a:	ab a5       	lds	r26, 0x6b
    b19c:	bc a5       	lds	r27, 0x6c
    b19e:	02 97       	sbiw	r24, 0x02	; 2
    b1a0:	a1 09       	sbc	r26, r1
    b1a2:	b1 09       	sbc	r27, r1
    b1a4:	04 0d       	add	r16, r4
    b1a6:	15 1d       	adc	r17, r5
    b1a8:	26 1d       	adc	r18, r6
    b1aa:	37 1d       	adc	r19, r7
    b1ac:	b9 01       	movw	r22, r18
    b1ae:	a8 01       	movw	r20, r16
    b1b0:	48 19       	sub	r20, r8
    b1b2:	59 09       	sbc	r21, r9
    b1b4:	6a 09       	sbc	r22, r10
    b1b6:	7b 09       	sbc	r23, r11
    b1b8:	4d a7       	lds	r20, 0x7d
    b1ba:	5e a7       	lds	r21, 0x7e
    b1bc:	6f a7       	lds	r22, 0x7f
    b1be:	78 ab       	sts	0x58, r23
    b1c0:	09 a9       	sts	0x49, r16
    b1c2:	1a a9       	sts	0x4a, r17
    b1c4:	2b a9       	sts	0x4b, r18
    b1c6:	3c a9       	sts	0x4c, r19
    b1c8:	78 01       	movw	r14, r16
    b1ca:	dd 24       	eor	r13, r13
    b1cc:	cc 24       	eor	r12, r12
    b1ce:	c8 2a       	or	r12, r24
    b1d0:	d9 2a       	or	r13, r25
    b1d2:	ea 2a       	or	r14, r26
    b1d4:	fb 2a       	or	r15, r27
    b1d6:	ff ef       	ldi	r31, 0xFF	; 255
    b1d8:	8f 2e       	mov	r8, r31
    b1da:	ff ef       	ldi	r31, 0xFF	; 255
    b1dc:	9f 2e       	mov	r9, r31
    b1de:	a1 2c       	mov	r10, r1
    b1e0:	b1 2c       	mov	r11, r1
    b1e2:	8c 20       	and	r8, r12
    b1e4:	9d 20       	and	r9, r13
    b1e6:	ae 20       	and	r10, r14
    b1e8:	bf 20       	and	r11, r15
    b1ea:	87 01       	movw	r16, r14
    b1ec:	22 27       	eor	r18, r18
    b1ee:	33 27       	eor	r19, r19
    b1f0:	09 a7       	lds	r16, 0x79
    b1f2:	1a a7       	lds	r17, 0x7a
    b1f4:	2b a7       	lds	r18, 0x7b
    b1f6:	3c a7       	lds	r19, 0x7c
    b1f8:	49 ac       	sts	0xa9, r20
    b1fa:	5a ac       	sts	0xaa, r21
    b1fc:	6b ac       	sts	0xab, r22
    b1fe:	7c ac       	sts	0xac, r23
    b200:	2f ef       	ldi	r18, 0xFF	; 255
    b202:	3f ef       	ldi	r19, 0xFF	; 255
    b204:	40 e0       	ldi	r20, 0x00	; 0
    b206:	50 e0       	ldi	r21, 0x00	; 0
    b208:	42 22       	and	r4, r18
    b20a:	53 22       	and	r5, r19
    b20c:	64 22       	and	r6, r20
    b20e:	75 22       	and	r7, r21
    b210:	29 ad       	sts	0x69, r18
    b212:	3a ad       	sts	0x6a, r19
    b214:	4b ad       	sts	0x6b, r20
    b216:	5c ad       	sts	0x6c, r21
    b218:	8a 01       	movw	r16, r20
    b21a:	22 27       	eor	r18, r18
    b21c:	33 27       	eor	r19, r19
    b21e:	09 ab       	sts	0x59, r16
    b220:	1a ab       	sts	0x5a, r17
    b222:	2b ab       	sts	0x5b, r18
    b224:	3c ab       	sts	0x5c, r19
    b226:	c5 01       	movw	r24, r10
    b228:	b4 01       	movw	r22, r8
    b22a:	a3 01       	movw	r20, r6
    b22c:	92 01       	movw	r18, r4
    b22e:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    b232:	69 af       	sts	0x79, r22
    b234:	7a af       	sts	0x7a, r23
    b236:	8b af       	sts	0x7b, r24
    b238:	9c af       	sts	0x7c, r25
    b23a:	c5 01       	movw	r24, r10
    b23c:	b4 01       	movw	r22, r8
    b23e:	29 a9       	sts	0x49, r18
    b240:	3a a9       	sts	0x4a, r19
    b242:	4b a9       	sts	0x4b, r20
    b244:	5c a9       	sts	0x4c, r21
    b246:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    b24a:	4b 01       	movw	r8, r22
    b24c:	5c 01       	movw	r10, r24
    b24e:	69 a5       	lds	r22, 0x69
    b250:	7a a5       	lds	r23, 0x6a
    b252:	8b a5       	lds	r24, 0x6b
    b254:	9c a5       	lds	r25, 0x6c
    b256:	a3 01       	movw	r20, r6
    b258:	92 01       	movw	r18, r4
    b25a:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    b25e:	2b 01       	movw	r4, r22
    b260:	3c 01       	movw	r6, r24
    b262:	69 a5       	lds	r22, 0x69
    b264:	7a a5       	lds	r23, 0x6a
    b266:	8b a5       	lds	r24, 0x6b
    b268:	9c a5       	lds	r25, 0x6c
    b26a:	29 a9       	sts	0x49, r18
    b26c:	3a a9       	sts	0x4a, r19
    b26e:	4b a9       	sts	0x4b, r20
    b270:	5c a9       	sts	0x4c, r21
    b272:	0e 94 93 5b 	call	0xb726	; 0xb726 <__mulsi3>
    b276:	ab 01       	movw	r20, r22
    b278:	bc 01       	movw	r22, r24
    b27a:	84 0c       	add	r8, r4
    b27c:	95 1c       	adc	r9, r5
    b27e:	a6 1c       	adc	r10, r6
    b280:	b7 1c       	adc	r11, r7
    b282:	09 ad       	sts	0x69, r16
    b284:	1a ad       	sts	0x6a, r17
    b286:	2b ad       	sts	0x6b, r18
    b288:	3c ad       	sts	0x6c, r19
    b28a:	c9 01       	movw	r24, r18
    b28c:	aa 27       	eor	r26, r26
    b28e:	bb 27       	eor	r27, r27
    b290:	88 0e       	add	r8, r24
    b292:	99 1e       	adc	r9, r25
    b294:	aa 1e       	adc	r10, r26
    b296:	bb 1e       	adc	r11, r27
    b298:	84 14       	cp	r8, r4
    b29a:	95 04       	cpc	r9, r5
    b29c:	a6 04       	cpc	r10, r6
    b29e:	b7 04       	cpc	r11, r7
    b2a0:	20 f4       	brcc	.+8      	; 0xb2aa <__divdi3+0xde4>
    b2a2:	40 50       	subi	r20, 0x00	; 0
    b2a4:	50 40       	sbci	r21, 0x00	; 0
    b2a6:	6f 4f       	sbci	r22, 0xFF	; 255
    b2a8:	7f 4f       	sbci	r23, 0xFF	; 255
    b2aa:	c5 01       	movw	r24, r10
    b2ac:	aa 27       	eor	r26, r26
    b2ae:	bb 27       	eor	r27, r27
    b2b0:	84 0f       	add	r24, r20
    b2b2:	95 1f       	adc	r25, r21
    b2b4:	a6 1f       	adc	r26, r22
    b2b6:	b7 1f       	adc	r27, r23
    b2b8:	0d a5       	lds	r16, 0x6d
    b2ba:	1e a5       	lds	r17, 0x6e
    b2bc:	2f a5       	lds	r18, 0x6f
    b2be:	38 a9       	sts	0x48, r19
    b2c0:	08 17       	cp	r16, r24
    b2c2:	19 07       	cpc	r17, r25
    b2c4:	2a 07       	cpc	r18, r26
    b2c6:	3b 07       	cpc	r19, r27
    b2c8:	18 f1       	brcs	.+70     	; 0xb310 <__divdi3+0xe4a>
    b2ca:	80 17       	cp	r24, r16
    b2cc:	91 07       	cpc	r25, r17
    b2ce:	a2 07       	cpc	r26, r18
    b2d0:	b3 07       	cpc	r27, r19
    b2d2:	a1 f5       	brne	.+104    	; 0xb33c <__divdi3+0xe76>
    b2d4:	54 01       	movw	r10, r8
    b2d6:	99 24       	eor	r9, r9
    b2d8:	88 24       	eor	r8, r8
    b2da:	89 ad       	sts	0x69, r24
    b2dc:	9a ad       	sts	0x6a, r25
    b2de:	ab ad       	sts	0x6b, r26
    b2e0:	bc ad       	sts	0x6c, r27
    b2e2:	a0 70       	andi	r26, 0x00	; 0
    b2e4:	b0 70       	andi	r27, 0x00	; 0
    b2e6:	88 0e       	add	r8, r24
    b2e8:	99 1e       	adc	r9, r25
    b2ea:	aa 1e       	adc	r10, r26
    b2ec:	bb 1e       	adc	r11, r27
    b2ee:	4d a9       	sts	0x4d, r20
    b2f0:	5e a9       	sts	0x4e, r21
    b2f2:	6f a9       	sts	0x4f, r22
    b2f4:	78 ad       	sts	0x68, r23
    b2f6:	03 2c       	mov	r0, r3
    b2f8:	04 c0       	rjmp	.+8      	; 0xb302 <__divdi3+0xe3c>
    b2fa:	44 0f       	add	r20, r20
    b2fc:	55 1f       	adc	r21, r21
    b2fe:	66 1f       	adc	r22, r22
    b300:	77 1f       	adc	r23, r23
    b302:	0a 94       	dec	r0
    b304:	d2 f7       	brpl	.-12     	; 0xb2fa <__divdi3+0xe34>
    b306:	48 15       	cp	r20, r8
    b308:	59 05       	cpc	r21, r9
    b30a:	6a 05       	cpc	r22, r10
    b30c:	7b 05       	cpc	r23, r11
    b30e:	b0 f4       	brcc	.+44     	; 0xb33c <__divdi3+0xe76>
    b310:	08 94       	sec
    b312:	c1 08       	sbc	r12, r1
    b314:	d1 08       	sbc	r13, r1
    b316:	e1 08       	sbc	r14, r1
    b318:	f1 08       	sbc	r15, r1
    b31a:	10 c0       	rjmp	.+32     	; 0xb33c <__divdi3+0xe76>
    b31c:	44 24       	eor	r4, r4
    b31e:	55 24       	eor	r5, r5
    b320:	32 01       	movw	r6, r4
    b322:	cc 24       	eor	r12, r12
    b324:	dd 24       	eor	r13, r13
    b326:	76 01       	movw	r14, r12
    b328:	0c c0       	rjmp	.+24     	; 0xb342 <__divdi3+0xe7c>
    b32a:	44 24       	eor	r4, r4
    b32c:	55 24       	eor	r5, r5
    b32e:	32 01       	movw	r6, r4
    b330:	81 e0       	ldi	r24, 0x01	; 1
    b332:	c8 2e       	mov	r12, r24
    b334:	d1 2c       	mov	r13, r1
    b336:	e1 2c       	mov	r14, r1
    b338:	f1 2c       	mov	r15, r1
    b33a:	03 c0       	rjmp	.+6      	; 0xb342 <__divdi3+0xe7c>
    b33c:	44 24       	eor	r4, r4
    b33e:	55 24       	eor	r5, r5
    b340:	32 01       	movw	r6, r4
    b342:	fe 01       	movw	r30, r28
    b344:	31 96       	adiw	r30, 0x01	; 1
    b346:	88 e0       	ldi	r24, 0x08	; 8
    b348:	df 01       	movw	r26, r30
    b34a:	1d 92       	st	X+, r1
    b34c:	8a 95       	dec	r24
    b34e:	e9 f7       	brne	.-6      	; 0xb34a <__divdi3+0xe84>
    b350:	c9 82       	std	Y+1, r12	; 0x01
    b352:	da 82       	std	Y+2, r13	; 0x02
    b354:	eb 82       	std	Y+3, r14	; 0x03
    b356:	fc 82       	std	Y+4, r15	; 0x04
    b358:	4d 82       	std	Y+5, r4	; 0x05
    b35a:	5e 82       	std	Y+6, r5	; 0x06
    b35c:	6f 82       	std	Y+7, r6	; 0x07
    b35e:	78 86       	std	Y+8, r7	; 0x08
    b360:	2c 2d       	mov	r18, r12
    b362:	3a 81       	ldd	r19, Y+2	; 0x02
    b364:	4b 81       	ldd	r20, Y+3	; 0x03
    b366:	5c 81       	ldd	r21, Y+4	; 0x04
    b368:	64 2d       	mov	r22, r4
    b36a:	7e 81       	ldd	r23, Y+6	; 0x06
    b36c:	8f 81       	ldd	r24, Y+7	; 0x07
    b36e:	98 85       	ldd	r25, Y+8	; 0x08
    b370:	25 96       	adiw	r28, 0x05	; 5
    b372:	ec ac       	sts	0xac, r30
    b374:	fd ac       	sts	0xad, r31
    b376:	0e ad       	sts	0x6e, r16
    b378:	1f ad       	sts	0x6f, r17
    b37a:	25 97       	sbiw	r28, 0x05	; 5
    b37c:	e1 14       	cp	r14, r1
    b37e:	f1 04       	cpc	r15, r1
    b380:	01 05       	cpc	r16, r1
    b382:	11 05       	cpc	r17, r1
    b384:	09 f4       	brne	.+2      	; 0xb388 <__divdi3+0xec2>
    b386:	56 c0       	rjmp	.+172    	; 0xb434 <__divdi3+0xf6e>
    b388:	21 95       	neg	r18
    b38a:	e1 e0       	ldi	r30, 0x01	; 1
    b38c:	12 16       	cp	r1, r18
    b38e:	08 f0       	brcs	.+2      	; 0xb392 <__divdi3+0xecc>
    b390:	e0 e0       	ldi	r30, 0x00	; 0
    b392:	31 95       	neg	r19
    b394:	f1 e0       	ldi	r31, 0x01	; 1
    b396:	13 16       	cp	r1, r19
    b398:	08 f0       	brcs	.+2      	; 0xb39c <__divdi3+0xed6>
    b39a:	f0 e0       	ldi	r31, 0x00	; 0
    b39c:	03 2f       	mov	r16, r19
    b39e:	0e 1b       	sub	r16, r30
    b3a0:	e1 e0       	ldi	r30, 0x01	; 1
    b3a2:	30 17       	cp	r19, r16
    b3a4:	08 f0       	brcs	.+2      	; 0xb3a8 <__divdi3+0xee2>
    b3a6:	e0 e0       	ldi	r30, 0x00	; 0
    b3a8:	fe 2b       	or	r31, r30
    b3aa:	41 95       	neg	r20
    b3ac:	e1 e0       	ldi	r30, 0x01	; 1
    b3ae:	14 16       	cp	r1, r20
    b3b0:	08 f0       	brcs	.+2      	; 0xb3b4 <__divdi3+0xeee>
    b3b2:	e0 e0       	ldi	r30, 0x00	; 0
    b3b4:	14 2f       	mov	r17, r20
    b3b6:	1f 1b       	sub	r17, r31
    b3b8:	31 e0       	ldi	r19, 0x01	; 1
    b3ba:	41 17       	cp	r20, r17
    b3bc:	08 f0       	brcs	.+2      	; 0xb3c0 <__divdi3+0xefa>
    b3be:	30 e0       	ldi	r19, 0x00	; 0
    b3c0:	e3 2b       	or	r30, r19
    b3c2:	51 95       	neg	r21
    b3c4:	f1 e0       	ldi	r31, 0x01	; 1
    b3c6:	15 16       	cp	r1, r21
    b3c8:	08 f0       	brcs	.+2      	; 0xb3cc <__divdi3+0xf06>
    b3ca:	f0 e0       	ldi	r31, 0x00	; 0
    b3cc:	b5 2f       	mov	r27, r21
    b3ce:	be 1b       	sub	r27, r30
    b3d0:	31 e0       	ldi	r19, 0x01	; 1
    b3d2:	5b 17       	cp	r21, r27
    b3d4:	08 f0       	brcs	.+2      	; 0xb3d8 <__divdi3+0xf12>
    b3d6:	30 e0       	ldi	r19, 0x00	; 0
    b3d8:	f3 2b       	or	r31, r19
    b3da:	61 95       	neg	r22
    b3dc:	e1 e0       	ldi	r30, 0x01	; 1
    b3de:	16 16       	cp	r1, r22
    b3e0:	08 f0       	brcs	.+2      	; 0xb3e4 <__divdi3+0xf1e>
    b3e2:	e0 e0       	ldi	r30, 0x00	; 0
    b3e4:	46 2e       	mov	r4, r22
    b3e6:	4f 1a       	sub	r4, r31
    b3e8:	31 e0       	ldi	r19, 0x01	; 1
    b3ea:	64 15       	cp	r22, r4
    b3ec:	08 f0       	brcs	.+2      	; 0xb3f0 <__divdi3+0xf2a>
    b3ee:	30 e0       	ldi	r19, 0x00	; 0
    b3f0:	e3 2b       	or	r30, r19
    b3f2:	71 95       	neg	r23
    b3f4:	f1 e0       	ldi	r31, 0x01	; 1
    b3f6:	17 16       	cp	r1, r23
    b3f8:	08 f0       	brcs	.+2      	; 0xb3fc <__divdi3+0xf36>
    b3fa:	f0 e0       	ldi	r31, 0x00	; 0
    b3fc:	a7 2f       	mov	r26, r23
    b3fe:	ae 1b       	sub	r26, r30
    b400:	31 e0       	ldi	r19, 0x01	; 1
    b402:	7a 17       	cp	r23, r26
    b404:	08 f0       	brcs	.+2      	; 0xb408 <__divdi3+0xf42>
    b406:	30 e0       	ldi	r19, 0x00	; 0
    b408:	f3 2b       	or	r31, r19
    b40a:	81 95       	neg	r24
    b40c:	e1 e0       	ldi	r30, 0x01	; 1
    b40e:	18 16       	cp	r1, r24
    b410:	08 f0       	brcs	.+2      	; 0xb414 <__divdi3+0xf4e>
    b412:	e0 e0       	ldi	r30, 0x00	; 0
    b414:	f8 2e       	mov	r15, r24
    b416:	ff 1a       	sub	r15, r31
    b418:	ff 2d       	mov	r31, r15
    b41a:	31 e0       	ldi	r19, 0x01	; 1
    b41c:	8f 15       	cp	r24, r15
    b41e:	08 f0       	brcs	.+2      	; 0xb422 <__divdi3+0xf5c>
    b420:	30 e0       	ldi	r19, 0x00	; 0
    b422:	e3 2b       	or	r30, r19
    b424:	91 95       	neg	r25
    b426:	30 2f       	mov	r19, r16
    b428:	41 2f       	mov	r20, r17
    b42a:	5b 2f       	mov	r21, r27
    b42c:	64 2d       	mov	r22, r4
    b42e:	7a 2f       	mov	r23, r26
    b430:	8f 2f       	mov	r24, r31
    b432:	9e 1b       	sub	r25, r30
    b434:	c8 5b       	subi	r28, 0xB8	; 184
    b436:	df 4f       	sbci	r29, 0xFF	; 255
    b438:	e1 e1       	ldi	r30, 0x11	; 17
    b43a:	0c 94 30 5c 	jmp	0xb860	; 0xb860 <__epilogue_restores__+0x2>

0000b43e <__cmpsf2>:
    b43e:	97 d0       	rcall	.+302    	; 0xb56e <__fp_cmp>
    b440:	08 f4       	brcc	.+2      	; 0xb444 <__cmpsf2+0x6>
    b442:	81 e0       	ldi	r24, 0x01	; 1
    b444:	08 95       	ret

0000b446 <__divsf3>:
    b446:	0c d0       	rcall	.+24     	; 0xb460 <__divsf3x>
    b448:	cd c0       	rjmp	.+410    	; 0xb5e4 <__fp_round>
    b44a:	c5 d0       	rcall	.+394    	; 0xb5d6 <__fp_pscB>
    b44c:	40 f0       	brcs	.+16     	; 0xb45e <__divsf3+0x18>
    b44e:	bc d0       	rcall	.+376    	; 0xb5c8 <__fp_pscA>
    b450:	30 f0       	brcs	.+12     	; 0xb45e <__divsf3+0x18>
    b452:	21 f4       	brne	.+8      	; 0xb45c <__divsf3+0x16>
    b454:	5f 3f       	cpi	r21, 0xFF	; 255
    b456:	19 f0       	breq	.+6      	; 0xb45e <__divsf3+0x18>
    b458:	ae c0       	rjmp	.+348    	; 0xb5b6 <__fp_inf>
    b45a:	51 11       	cpse	r21, r1
    b45c:	f7 c0       	rjmp	.+494    	; 0xb64c <__fp_szero>
    b45e:	b1 c0       	rjmp	.+354    	; 0xb5c2 <__fp_nan>

0000b460 <__divsf3x>:
    b460:	d2 d0       	rcall	.+420    	; 0xb606 <__fp_split3>
    b462:	98 f3       	brcs	.-26     	; 0xb44a <__divsf3+0x4>

0000b464 <__divsf3_pse>:
    b464:	99 23       	and	r25, r25
    b466:	c9 f3       	breq	.-14     	; 0xb45a <__divsf3+0x14>
    b468:	55 23       	and	r21, r21
    b46a:	b1 f3       	breq	.-20     	; 0xb458 <__divsf3+0x12>
    b46c:	95 1b       	sub	r25, r21
    b46e:	55 0b       	sbc	r21, r21
    b470:	bb 27       	eor	r27, r27
    b472:	aa 27       	eor	r26, r26
    b474:	62 17       	cp	r22, r18
    b476:	73 07       	cpc	r23, r19
    b478:	84 07       	cpc	r24, r20
    b47a:	38 f0       	brcs	.+14     	; 0xb48a <__divsf3_pse+0x26>
    b47c:	9f 5f       	subi	r25, 0xFF	; 255
    b47e:	5f 4f       	sbci	r21, 0xFF	; 255
    b480:	22 0f       	add	r18, r18
    b482:	33 1f       	adc	r19, r19
    b484:	44 1f       	adc	r20, r20
    b486:	aa 1f       	adc	r26, r26
    b488:	a9 f3       	breq	.-22     	; 0xb474 <__divsf3_pse+0x10>
    b48a:	33 d0       	rcall	.+102    	; 0xb4f2 <__divsf3_pse+0x8e>
    b48c:	0e 2e       	mov	r0, r30
    b48e:	3a f0       	brmi	.+14     	; 0xb49e <__divsf3_pse+0x3a>
    b490:	e0 e8       	ldi	r30, 0x80	; 128
    b492:	30 d0       	rcall	.+96     	; 0xb4f4 <__divsf3_pse+0x90>
    b494:	91 50       	subi	r25, 0x01	; 1
    b496:	50 40       	sbci	r21, 0x00	; 0
    b498:	e6 95       	lsr	r30
    b49a:	00 1c       	adc	r0, r0
    b49c:	ca f7       	brpl	.-14     	; 0xb490 <__divsf3_pse+0x2c>
    b49e:	29 d0       	rcall	.+82     	; 0xb4f2 <__divsf3_pse+0x8e>
    b4a0:	fe 2f       	mov	r31, r30
    b4a2:	27 d0       	rcall	.+78     	; 0xb4f2 <__divsf3_pse+0x8e>
    b4a4:	66 0f       	add	r22, r22
    b4a6:	77 1f       	adc	r23, r23
    b4a8:	88 1f       	adc	r24, r24
    b4aa:	bb 1f       	adc	r27, r27
    b4ac:	26 17       	cp	r18, r22
    b4ae:	37 07       	cpc	r19, r23
    b4b0:	48 07       	cpc	r20, r24
    b4b2:	ab 07       	cpc	r26, r27
    b4b4:	b0 e8       	ldi	r27, 0x80	; 128
    b4b6:	09 f0       	breq	.+2      	; 0xb4ba <__divsf3_pse+0x56>
    b4b8:	bb 0b       	sbc	r27, r27
    b4ba:	80 2d       	mov	r24, r0
    b4bc:	bf 01       	movw	r22, r30
    b4be:	ff 27       	eor	r31, r31
    b4c0:	93 58       	subi	r25, 0x83	; 131
    b4c2:	5f 4f       	sbci	r21, 0xFF	; 255
    b4c4:	2a f0       	brmi	.+10     	; 0xb4d0 <__divsf3_pse+0x6c>
    b4c6:	9e 3f       	cpi	r25, 0xFE	; 254
    b4c8:	51 05       	cpc	r21, r1
    b4ca:	68 f0       	brcs	.+26     	; 0xb4e6 <__divsf3_pse+0x82>
    b4cc:	74 c0       	rjmp	.+232    	; 0xb5b6 <__fp_inf>
    b4ce:	be c0       	rjmp	.+380    	; 0xb64c <__fp_szero>
    b4d0:	5f 3f       	cpi	r21, 0xFF	; 255
    b4d2:	ec f3       	brlt	.-6      	; 0xb4ce <__divsf3_pse+0x6a>
    b4d4:	98 3e       	cpi	r25, 0xE8	; 232
    b4d6:	dc f3       	brlt	.-10     	; 0xb4ce <__divsf3_pse+0x6a>
    b4d8:	86 95       	lsr	r24
    b4da:	77 95       	ror	r23
    b4dc:	67 95       	ror	r22
    b4de:	b7 95       	ror	r27
    b4e0:	f7 95       	ror	r31
    b4e2:	9f 5f       	subi	r25, 0xFF	; 255
    b4e4:	c9 f7       	brne	.-14     	; 0xb4d8 <__divsf3_pse+0x74>
    b4e6:	88 0f       	add	r24, r24
    b4e8:	91 1d       	adc	r25, r1
    b4ea:	96 95       	lsr	r25
    b4ec:	87 95       	ror	r24
    b4ee:	97 f9       	bld	r25, 7
    b4f0:	08 95       	ret
    b4f2:	e1 e0       	ldi	r30, 0x01	; 1
    b4f4:	66 0f       	add	r22, r22
    b4f6:	77 1f       	adc	r23, r23
    b4f8:	88 1f       	adc	r24, r24
    b4fa:	bb 1f       	adc	r27, r27
    b4fc:	62 17       	cp	r22, r18
    b4fe:	73 07       	cpc	r23, r19
    b500:	84 07       	cpc	r24, r20
    b502:	ba 07       	cpc	r27, r26
    b504:	20 f0       	brcs	.+8      	; 0xb50e <__divsf3_pse+0xaa>
    b506:	62 1b       	sub	r22, r18
    b508:	73 0b       	sbc	r23, r19
    b50a:	84 0b       	sbc	r24, r20
    b50c:	ba 0b       	sbc	r27, r26
    b50e:	ee 1f       	adc	r30, r30
    b510:	88 f7       	brcc	.-30     	; 0xb4f4 <__divsf3_pse+0x90>
    b512:	e0 95       	com	r30
    b514:	08 95       	ret

0000b516 <__fixunssfsi>:
    b516:	7f d0       	rcall	.+254    	; 0xb616 <__fp_splitA>
    b518:	88 f0       	brcs	.+34     	; 0xb53c <__fixunssfsi+0x26>
    b51a:	9f 57       	subi	r25, 0x7F	; 127
    b51c:	90 f0       	brcs	.+36     	; 0xb542 <__fixunssfsi+0x2c>
    b51e:	b9 2f       	mov	r27, r25
    b520:	99 27       	eor	r25, r25
    b522:	b7 51       	subi	r27, 0x17	; 23
    b524:	a0 f0       	brcs	.+40     	; 0xb54e <__fixunssfsi+0x38>
    b526:	d1 f0       	breq	.+52     	; 0xb55c <__fixunssfsi+0x46>
    b528:	66 0f       	add	r22, r22
    b52a:	77 1f       	adc	r23, r23
    b52c:	88 1f       	adc	r24, r24
    b52e:	99 1f       	adc	r25, r25
    b530:	1a f0       	brmi	.+6      	; 0xb538 <__fixunssfsi+0x22>
    b532:	ba 95       	dec	r27
    b534:	c9 f7       	brne	.-14     	; 0xb528 <__fixunssfsi+0x12>
    b536:	12 c0       	rjmp	.+36     	; 0xb55c <__fixunssfsi+0x46>
    b538:	b1 30       	cpi	r27, 0x01	; 1
    b53a:	81 f0       	breq	.+32     	; 0xb55c <__fixunssfsi+0x46>
    b53c:	86 d0       	rcall	.+268    	; 0xb64a <__fp_zero>
    b53e:	b1 e0       	ldi	r27, 0x01	; 1
    b540:	08 95       	ret
    b542:	83 c0       	rjmp	.+262    	; 0xb64a <__fp_zero>
    b544:	67 2f       	mov	r22, r23
    b546:	78 2f       	mov	r23, r24
    b548:	88 27       	eor	r24, r24
    b54a:	b8 5f       	subi	r27, 0xF8	; 248
    b54c:	39 f0       	breq	.+14     	; 0xb55c <__fixunssfsi+0x46>
    b54e:	b9 3f       	cpi	r27, 0xF9	; 249
    b550:	cc f3       	brlt	.-14     	; 0xb544 <__fixunssfsi+0x2e>
    b552:	86 95       	lsr	r24
    b554:	77 95       	ror	r23
    b556:	67 95       	ror	r22
    b558:	b3 95       	inc	r27
    b55a:	d9 f7       	brne	.-10     	; 0xb552 <__fixunssfsi+0x3c>
    b55c:	3e f4       	brtc	.+14     	; 0xb56c <__fixunssfsi+0x56>
    b55e:	90 95       	com	r25
    b560:	80 95       	com	r24
    b562:	70 95       	com	r23
    b564:	61 95       	neg	r22
    b566:	7f 4f       	sbci	r23, 0xFF	; 255
    b568:	8f 4f       	sbci	r24, 0xFF	; 255
    b56a:	9f 4f       	sbci	r25, 0xFF	; 255
    b56c:	08 95       	ret

0000b56e <__fp_cmp>:
    b56e:	99 0f       	add	r25, r25
    b570:	00 08       	sbc	r0, r0
    b572:	55 0f       	add	r21, r21
    b574:	aa 0b       	sbc	r26, r26
    b576:	e0 e8       	ldi	r30, 0x80	; 128
    b578:	fe ef       	ldi	r31, 0xFE	; 254
    b57a:	16 16       	cp	r1, r22
    b57c:	17 06       	cpc	r1, r23
    b57e:	e8 07       	cpc	r30, r24
    b580:	f9 07       	cpc	r31, r25
    b582:	c0 f0       	brcs	.+48     	; 0xb5b4 <__fp_cmp+0x46>
    b584:	12 16       	cp	r1, r18
    b586:	13 06       	cpc	r1, r19
    b588:	e4 07       	cpc	r30, r20
    b58a:	f5 07       	cpc	r31, r21
    b58c:	98 f0       	brcs	.+38     	; 0xb5b4 <__fp_cmp+0x46>
    b58e:	62 1b       	sub	r22, r18
    b590:	73 0b       	sbc	r23, r19
    b592:	84 0b       	sbc	r24, r20
    b594:	95 0b       	sbc	r25, r21
    b596:	39 f4       	brne	.+14     	; 0xb5a6 <__fp_cmp+0x38>
    b598:	0a 26       	eor	r0, r26
    b59a:	61 f0       	breq	.+24     	; 0xb5b4 <__fp_cmp+0x46>
    b59c:	23 2b       	or	r18, r19
    b59e:	24 2b       	or	r18, r20
    b5a0:	25 2b       	or	r18, r21
    b5a2:	21 f4       	brne	.+8      	; 0xb5ac <__fp_cmp+0x3e>
    b5a4:	08 95       	ret
    b5a6:	0a 26       	eor	r0, r26
    b5a8:	09 f4       	brne	.+2      	; 0xb5ac <__fp_cmp+0x3e>
    b5aa:	a1 40       	sbci	r26, 0x01	; 1
    b5ac:	a6 95       	lsr	r26
    b5ae:	8f ef       	ldi	r24, 0xFF	; 255
    b5b0:	81 1d       	adc	r24, r1
    b5b2:	81 1d       	adc	r24, r1
    b5b4:	08 95       	ret

0000b5b6 <__fp_inf>:
    b5b6:	97 f9       	bld	r25, 7
    b5b8:	9f 67       	ori	r25, 0x7F	; 127
    b5ba:	80 e8       	ldi	r24, 0x80	; 128
    b5bc:	70 e0       	ldi	r23, 0x00	; 0
    b5be:	60 e0       	ldi	r22, 0x00	; 0
    b5c0:	08 95       	ret

0000b5c2 <__fp_nan>:
    b5c2:	9f ef       	ldi	r25, 0xFF	; 255
    b5c4:	80 ec       	ldi	r24, 0xC0	; 192
    b5c6:	08 95       	ret

0000b5c8 <__fp_pscA>:
    b5c8:	00 24       	eor	r0, r0
    b5ca:	0a 94       	dec	r0
    b5cc:	16 16       	cp	r1, r22
    b5ce:	17 06       	cpc	r1, r23
    b5d0:	18 06       	cpc	r1, r24
    b5d2:	09 06       	cpc	r0, r25
    b5d4:	08 95       	ret

0000b5d6 <__fp_pscB>:
    b5d6:	00 24       	eor	r0, r0
    b5d8:	0a 94       	dec	r0
    b5da:	12 16       	cp	r1, r18
    b5dc:	13 06       	cpc	r1, r19
    b5de:	14 06       	cpc	r1, r20
    b5e0:	05 06       	cpc	r0, r21
    b5e2:	08 95       	ret

0000b5e4 <__fp_round>:
    b5e4:	09 2e       	mov	r0, r25
    b5e6:	03 94       	inc	r0
    b5e8:	00 0c       	add	r0, r0
    b5ea:	11 f4       	brne	.+4      	; 0xb5f0 <__fp_round+0xc>
    b5ec:	88 23       	and	r24, r24
    b5ee:	52 f0       	brmi	.+20     	; 0xb604 <__fp_round+0x20>
    b5f0:	bb 0f       	add	r27, r27
    b5f2:	40 f4       	brcc	.+16     	; 0xb604 <__fp_round+0x20>
    b5f4:	bf 2b       	or	r27, r31
    b5f6:	11 f4       	brne	.+4      	; 0xb5fc <__fp_round+0x18>
    b5f8:	60 ff       	sbrs	r22, 0
    b5fa:	04 c0       	rjmp	.+8      	; 0xb604 <__fp_round+0x20>
    b5fc:	6f 5f       	subi	r22, 0xFF	; 255
    b5fe:	7f 4f       	sbci	r23, 0xFF	; 255
    b600:	8f 4f       	sbci	r24, 0xFF	; 255
    b602:	9f 4f       	sbci	r25, 0xFF	; 255
    b604:	08 95       	ret

0000b606 <__fp_split3>:
    b606:	57 fd       	sbrc	r21, 7
    b608:	90 58       	subi	r25, 0x80	; 128
    b60a:	44 0f       	add	r20, r20
    b60c:	55 1f       	adc	r21, r21
    b60e:	59 f0       	breq	.+22     	; 0xb626 <__fp_splitA+0x10>
    b610:	5f 3f       	cpi	r21, 0xFF	; 255
    b612:	71 f0       	breq	.+28     	; 0xb630 <__fp_splitA+0x1a>
    b614:	47 95       	ror	r20

0000b616 <__fp_splitA>:
    b616:	88 0f       	add	r24, r24
    b618:	97 fb       	bst	r25, 7
    b61a:	99 1f       	adc	r25, r25
    b61c:	61 f0       	breq	.+24     	; 0xb636 <__fp_splitA+0x20>
    b61e:	9f 3f       	cpi	r25, 0xFF	; 255
    b620:	79 f0       	breq	.+30     	; 0xb640 <__fp_splitA+0x2a>
    b622:	87 95       	ror	r24
    b624:	08 95       	ret
    b626:	12 16       	cp	r1, r18
    b628:	13 06       	cpc	r1, r19
    b62a:	14 06       	cpc	r1, r20
    b62c:	55 1f       	adc	r21, r21
    b62e:	f2 cf       	rjmp	.-28     	; 0xb614 <__fp_split3+0xe>
    b630:	46 95       	lsr	r20
    b632:	f1 df       	rcall	.-30     	; 0xb616 <__fp_splitA>
    b634:	08 c0       	rjmp	.+16     	; 0xb646 <__fp_splitA+0x30>
    b636:	16 16       	cp	r1, r22
    b638:	17 06       	cpc	r1, r23
    b63a:	18 06       	cpc	r1, r24
    b63c:	99 1f       	adc	r25, r25
    b63e:	f1 cf       	rjmp	.-30     	; 0xb622 <__fp_splitA+0xc>
    b640:	86 95       	lsr	r24
    b642:	71 05       	cpc	r23, r1
    b644:	61 05       	cpc	r22, r1
    b646:	08 94       	sec
    b648:	08 95       	ret

0000b64a <__fp_zero>:
    b64a:	e8 94       	clt

0000b64c <__fp_szero>:
    b64c:	bb 27       	eor	r27, r27
    b64e:	66 27       	eor	r22, r22
    b650:	77 27       	eor	r23, r23
    b652:	cb 01       	movw	r24, r22
    b654:	97 f9       	bld	r25, 7
    b656:	08 95       	ret

0000b658 <__gesf2>:
    b658:	8a df       	rcall	.-236    	; 0xb56e <__fp_cmp>
    b65a:	08 f4       	brcc	.+2      	; 0xb65e <__gesf2+0x6>
    b65c:	8f ef       	ldi	r24, 0xFF	; 255
    b65e:	08 95       	ret

0000b660 <__mulsf3>:
    b660:	0b d0       	rcall	.+22     	; 0xb678 <__mulsf3x>
    b662:	c0 cf       	rjmp	.-128    	; 0xb5e4 <__fp_round>
    b664:	b1 df       	rcall	.-158    	; 0xb5c8 <__fp_pscA>
    b666:	28 f0       	brcs	.+10     	; 0xb672 <__mulsf3+0x12>
    b668:	b6 df       	rcall	.-148    	; 0xb5d6 <__fp_pscB>
    b66a:	18 f0       	brcs	.+6      	; 0xb672 <__mulsf3+0x12>
    b66c:	95 23       	and	r25, r21
    b66e:	09 f0       	breq	.+2      	; 0xb672 <__mulsf3+0x12>
    b670:	a2 cf       	rjmp	.-188    	; 0xb5b6 <__fp_inf>
    b672:	a7 cf       	rjmp	.-178    	; 0xb5c2 <__fp_nan>
    b674:	11 24       	eor	r1, r1
    b676:	ea cf       	rjmp	.-44     	; 0xb64c <__fp_szero>

0000b678 <__mulsf3x>:
    b678:	c6 df       	rcall	.-116    	; 0xb606 <__fp_split3>
    b67a:	a0 f3       	brcs	.-24     	; 0xb664 <__mulsf3+0x4>

0000b67c <__mulsf3_pse>:
    b67c:	95 9f       	mul	r25, r21
    b67e:	d1 f3       	breq	.-12     	; 0xb674 <__mulsf3+0x14>
    b680:	95 0f       	add	r25, r21
    b682:	50 e0       	ldi	r21, 0x00	; 0
    b684:	55 1f       	adc	r21, r21
    b686:	62 9f       	mul	r22, r18
    b688:	f0 01       	movw	r30, r0
    b68a:	72 9f       	mul	r23, r18
    b68c:	bb 27       	eor	r27, r27
    b68e:	f0 0d       	add	r31, r0
    b690:	b1 1d       	adc	r27, r1
    b692:	63 9f       	mul	r22, r19
    b694:	aa 27       	eor	r26, r26
    b696:	f0 0d       	add	r31, r0
    b698:	b1 1d       	adc	r27, r1
    b69a:	aa 1f       	adc	r26, r26
    b69c:	64 9f       	mul	r22, r20
    b69e:	66 27       	eor	r22, r22
    b6a0:	b0 0d       	add	r27, r0
    b6a2:	a1 1d       	adc	r26, r1
    b6a4:	66 1f       	adc	r22, r22
    b6a6:	82 9f       	mul	r24, r18
    b6a8:	22 27       	eor	r18, r18
    b6aa:	b0 0d       	add	r27, r0
    b6ac:	a1 1d       	adc	r26, r1
    b6ae:	62 1f       	adc	r22, r18
    b6b0:	73 9f       	mul	r23, r19
    b6b2:	b0 0d       	add	r27, r0
    b6b4:	a1 1d       	adc	r26, r1
    b6b6:	62 1f       	adc	r22, r18
    b6b8:	83 9f       	mul	r24, r19
    b6ba:	a0 0d       	add	r26, r0
    b6bc:	61 1d       	adc	r22, r1
    b6be:	22 1f       	adc	r18, r18
    b6c0:	74 9f       	mul	r23, r20
    b6c2:	33 27       	eor	r19, r19
    b6c4:	a0 0d       	add	r26, r0
    b6c6:	61 1d       	adc	r22, r1
    b6c8:	23 1f       	adc	r18, r19
    b6ca:	84 9f       	mul	r24, r20
    b6cc:	60 0d       	add	r22, r0
    b6ce:	21 1d       	adc	r18, r1
    b6d0:	82 2f       	mov	r24, r18
    b6d2:	76 2f       	mov	r23, r22
    b6d4:	6a 2f       	mov	r22, r26
    b6d6:	11 24       	eor	r1, r1
    b6d8:	9f 57       	subi	r25, 0x7F	; 127
    b6da:	50 40       	sbci	r21, 0x00	; 0
    b6dc:	8a f0       	brmi	.+34     	; 0xb700 <__mulsf3_pse+0x84>
    b6de:	e1 f0       	breq	.+56     	; 0xb718 <__mulsf3_pse+0x9c>
    b6e0:	88 23       	and	r24, r24
    b6e2:	4a f0       	brmi	.+18     	; 0xb6f6 <__mulsf3_pse+0x7a>
    b6e4:	ee 0f       	add	r30, r30
    b6e6:	ff 1f       	adc	r31, r31
    b6e8:	bb 1f       	adc	r27, r27
    b6ea:	66 1f       	adc	r22, r22
    b6ec:	77 1f       	adc	r23, r23
    b6ee:	88 1f       	adc	r24, r24
    b6f0:	91 50       	subi	r25, 0x01	; 1
    b6f2:	50 40       	sbci	r21, 0x00	; 0
    b6f4:	a9 f7       	brne	.-22     	; 0xb6e0 <__mulsf3_pse+0x64>
    b6f6:	9e 3f       	cpi	r25, 0xFE	; 254
    b6f8:	51 05       	cpc	r21, r1
    b6fa:	70 f0       	brcs	.+28     	; 0xb718 <__mulsf3_pse+0x9c>
    b6fc:	5c cf       	rjmp	.-328    	; 0xb5b6 <__fp_inf>
    b6fe:	a6 cf       	rjmp	.-180    	; 0xb64c <__fp_szero>
    b700:	5f 3f       	cpi	r21, 0xFF	; 255
    b702:	ec f3       	brlt	.-6      	; 0xb6fe <__mulsf3_pse+0x82>
    b704:	98 3e       	cpi	r25, 0xE8	; 232
    b706:	dc f3       	brlt	.-10     	; 0xb6fe <__mulsf3_pse+0x82>
    b708:	86 95       	lsr	r24
    b70a:	77 95       	ror	r23
    b70c:	67 95       	ror	r22
    b70e:	b7 95       	ror	r27
    b710:	f7 95       	ror	r31
    b712:	e7 95       	ror	r30
    b714:	9f 5f       	subi	r25, 0xFF	; 255
    b716:	c1 f7       	brne	.-16     	; 0xb708 <__mulsf3_pse+0x8c>
    b718:	fe 2b       	or	r31, r30
    b71a:	88 0f       	add	r24, r24
    b71c:	91 1d       	adc	r25, r1
    b71e:	96 95       	lsr	r25
    b720:	87 95       	ror	r24
    b722:	97 f9       	bld	r25, 7
    b724:	08 95       	ret

0000b726 <__mulsi3>:
    b726:	62 9f       	mul	r22, r18
    b728:	d0 01       	movw	r26, r0
    b72a:	73 9f       	mul	r23, r19
    b72c:	f0 01       	movw	r30, r0
    b72e:	82 9f       	mul	r24, r18
    b730:	e0 0d       	add	r30, r0
    b732:	f1 1d       	adc	r31, r1
    b734:	64 9f       	mul	r22, r20
    b736:	e0 0d       	add	r30, r0
    b738:	f1 1d       	adc	r31, r1
    b73a:	92 9f       	mul	r25, r18
    b73c:	f0 0d       	add	r31, r0
    b73e:	83 9f       	mul	r24, r19
    b740:	f0 0d       	add	r31, r0
    b742:	74 9f       	mul	r23, r20
    b744:	f0 0d       	add	r31, r0
    b746:	65 9f       	mul	r22, r21
    b748:	f0 0d       	add	r31, r0
    b74a:	99 27       	eor	r25, r25
    b74c:	72 9f       	mul	r23, r18
    b74e:	b0 0d       	add	r27, r0
    b750:	e1 1d       	adc	r30, r1
    b752:	f9 1f       	adc	r31, r25
    b754:	63 9f       	mul	r22, r19
    b756:	b0 0d       	add	r27, r0
    b758:	e1 1d       	adc	r30, r1
    b75a:	f9 1f       	adc	r31, r25
    b75c:	bd 01       	movw	r22, r26
    b75e:	cf 01       	movw	r24, r30
    b760:	11 24       	eor	r1, r1
    b762:	08 95       	ret

0000b764 <__udivmodhi4>:
    b764:	aa 1b       	sub	r26, r26
    b766:	bb 1b       	sub	r27, r27
    b768:	51 e1       	ldi	r21, 0x11	; 17
    b76a:	07 c0       	rjmp	.+14     	; 0xb77a <__udivmodhi4_ep>

0000b76c <__udivmodhi4_loop>:
    b76c:	aa 1f       	adc	r26, r26
    b76e:	bb 1f       	adc	r27, r27
    b770:	a6 17       	cp	r26, r22
    b772:	b7 07       	cpc	r27, r23
    b774:	10 f0       	brcs	.+4      	; 0xb77a <__udivmodhi4_ep>
    b776:	a6 1b       	sub	r26, r22
    b778:	b7 0b       	sbc	r27, r23

0000b77a <__udivmodhi4_ep>:
    b77a:	88 1f       	adc	r24, r24
    b77c:	99 1f       	adc	r25, r25
    b77e:	5a 95       	dec	r21
    b780:	a9 f7       	brne	.-22     	; 0xb76c <__udivmodhi4_loop>
    b782:	80 95       	com	r24
    b784:	90 95       	com	r25
    b786:	bc 01       	movw	r22, r24
    b788:	cd 01       	movw	r24, r26
    b78a:	08 95       	ret

0000b78c <__divmodhi4>:
    b78c:	97 fb       	bst	r25, 7
    b78e:	09 2e       	mov	r0, r25
    b790:	07 26       	eor	r0, r23
    b792:	0a d0       	rcall	.+20     	; 0xb7a8 <__divmodhi4_neg1>
    b794:	77 fd       	sbrc	r23, 7
    b796:	04 d0       	rcall	.+8      	; 0xb7a0 <__divmodhi4_neg2>
    b798:	e5 df       	rcall	.-54     	; 0xb764 <__udivmodhi4>
    b79a:	06 d0       	rcall	.+12     	; 0xb7a8 <__divmodhi4_neg1>
    b79c:	00 20       	and	r0, r0
    b79e:	1a f4       	brpl	.+6      	; 0xb7a6 <__divmodhi4_exit>

0000b7a0 <__divmodhi4_neg2>:
    b7a0:	70 95       	com	r23
    b7a2:	61 95       	neg	r22
    b7a4:	7f 4f       	sbci	r23, 0xFF	; 255

0000b7a6 <__divmodhi4_exit>:
    b7a6:	08 95       	ret

0000b7a8 <__divmodhi4_neg1>:
    b7a8:	f6 f7       	brtc	.-4      	; 0xb7a6 <__divmodhi4_exit>
    b7aa:	90 95       	com	r25
    b7ac:	81 95       	neg	r24
    b7ae:	9f 4f       	sbci	r25, 0xFF	; 255
    b7b0:	08 95       	ret

0000b7b2 <__udivmodsi4>:
    b7b2:	a1 e2       	ldi	r26, 0x21	; 33
    b7b4:	1a 2e       	mov	r1, r26
    b7b6:	aa 1b       	sub	r26, r26
    b7b8:	bb 1b       	sub	r27, r27
    b7ba:	fd 01       	movw	r30, r26
    b7bc:	0d c0       	rjmp	.+26     	; 0xb7d8 <__udivmodsi4_ep>

0000b7be <__udivmodsi4_loop>:
    b7be:	aa 1f       	adc	r26, r26
    b7c0:	bb 1f       	adc	r27, r27
    b7c2:	ee 1f       	adc	r30, r30
    b7c4:	ff 1f       	adc	r31, r31
    b7c6:	a2 17       	cp	r26, r18
    b7c8:	b3 07       	cpc	r27, r19
    b7ca:	e4 07       	cpc	r30, r20
    b7cc:	f5 07       	cpc	r31, r21
    b7ce:	20 f0       	brcs	.+8      	; 0xb7d8 <__udivmodsi4_ep>
    b7d0:	a2 1b       	sub	r26, r18
    b7d2:	b3 0b       	sbc	r27, r19
    b7d4:	e4 0b       	sbc	r30, r20
    b7d6:	f5 0b       	sbc	r31, r21

0000b7d8 <__udivmodsi4_ep>:
    b7d8:	66 1f       	adc	r22, r22
    b7da:	77 1f       	adc	r23, r23
    b7dc:	88 1f       	adc	r24, r24
    b7de:	99 1f       	adc	r25, r25
    b7e0:	1a 94       	dec	r1
    b7e2:	69 f7       	brne	.-38     	; 0xb7be <__udivmodsi4_loop>
    b7e4:	60 95       	com	r22
    b7e6:	70 95       	com	r23
    b7e8:	80 95       	com	r24
    b7ea:	90 95       	com	r25
    b7ec:	9b 01       	movw	r18, r22
    b7ee:	ac 01       	movw	r20, r24
    b7f0:	bd 01       	movw	r22, r26
    b7f2:	cf 01       	movw	r24, r30
    b7f4:	08 95       	ret

0000b7f6 <__divmodsi4>:
    b7f6:	97 fb       	bst	r25, 7
    b7f8:	09 2e       	mov	r0, r25
    b7fa:	05 26       	eor	r0, r21
    b7fc:	0e d0       	rcall	.+28     	; 0xb81a <__divmodsi4_neg1>
    b7fe:	57 fd       	sbrc	r21, 7
    b800:	04 d0       	rcall	.+8      	; 0xb80a <__divmodsi4_neg2>
    b802:	d7 df       	rcall	.-82     	; 0xb7b2 <__udivmodsi4>
    b804:	0a d0       	rcall	.+20     	; 0xb81a <__divmodsi4_neg1>
    b806:	00 1c       	adc	r0, r0
    b808:	38 f4       	brcc	.+14     	; 0xb818 <__divmodsi4_exit>

0000b80a <__divmodsi4_neg2>:
    b80a:	50 95       	com	r21
    b80c:	40 95       	com	r20
    b80e:	30 95       	com	r19
    b810:	21 95       	neg	r18
    b812:	3f 4f       	sbci	r19, 0xFF	; 255
    b814:	4f 4f       	sbci	r20, 0xFF	; 255
    b816:	5f 4f       	sbci	r21, 0xFF	; 255

0000b818 <__divmodsi4_exit>:
    b818:	08 95       	ret

0000b81a <__divmodsi4_neg1>:
    b81a:	f6 f7       	brtc	.-4      	; 0xb818 <__divmodsi4_exit>
    b81c:	90 95       	com	r25
    b81e:	80 95       	com	r24
    b820:	70 95       	com	r23
    b822:	61 95       	neg	r22
    b824:	7f 4f       	sbci	r23, 0xFF	; 255
    b826:	8f 4f       	sbci	r24, 0xFF	; 255
    b828:	9f 4f       	sbci	r25, 0xFF	; 255
    b82a:	08 95       	ret

0000b82c <__prologue_saves__>:
    b82c:	2f 92       	push	r2
    b82e:	3f 92       	push	r3
    b830:	4f 92       	push	r4
    b832:	5f 92       	push	r5
    b834:	6f 92       	push	r6
    b836:	7f 92       	push	r7
    b838:	8f 92       	push	r8
    b83a:	9f 92       	push	r9
    b83c:	af 92       	push	r10
    b83e:	bf 92       	push	r11
    b840:	cf 92       	push	r12
    b842:	df 92       	push	r13
    b844:	ef 92       	push	r14
    b846:	ff 92       	push	r15
    b848:	0f 93       	push	r16
    b84a:	1f 93       	push	r17
    b84c:	cf 93       	push	r28
    b84e:	df 93       	push	r29
    b850:	cd b7       	in	r28, 0x3d	; 61
    b852:	de b7       	in	r29, 0x3e	; 62
    b854:	ca 1b       	sub	r28, r26
    b856:	db 0b       	sbc	r29, r27
    b858:	cd bf       	out	0x3d, r28	; 61
    b85a:	de bf       	out	0x3e, r29	; 62
    b85c:	19 94       	eijmp

0000b85e <__epilogue_restores__>:
    b85e:	2a 88       	ldd	r2, Y+18	; 0x12
    b860:	39 88       	ldd	r3, Y+17	; 0x11
    b862:	48 88       	ldd	r4, Y+16	; 0x10
    b864:	5f 84       	ldd	r5, Y+15	; 0x0f
    b866:	6e 84       	ldd	r6, Y+14	; 0x0e
    b868:	7d 84       	ldd	r7, Y+13	; 0x0d
    b86a:	8c 84       	ldd	r8, Y+12	; 0x0c
    b86c:	9b 84       	ldd	r9, Y+11	; 0x0b
    b86e:	aa 84       	ldd	r10, Y+10	; 0x0a
    b870:	b9 84       	ldd	r11, Y+9	; 0x09
    b872:	c8 84       	ldd	r12, Y+8	; 0x08
    b874:	df 80       	ldd	r13, Y+7	; 0x07
    b876:	ee 80       	ldd	r14, Y+6	; 0x06
    b878:	fd 80       	ldd	r15, Y+5	; 0x05
    b87a:	0c 81       	ldd	r16, Y+4	; 0x04
    b87c:	1b 81       	ldd	r17, Y+3	; 0x03
    b87e:	aa 81       	ldd	r26, Y+2	; 0x02
    b880:	b9 81       	ldd	r27, Y+1	; 0x01
    b882:	ce 0f       	add	r28, r30
    b884:	d1 1d       	adc	r29, r1
    b886:	cd bf       	out	0x3d, r28	; 61
    b888:	de bf       	out	0x3e, r29	; 62
    b88a:	ed 01       	movw	r28, r26
    b88c:	08 95       	ret

0000b88e <strcpy_P>:
    b88e:	fb 01       	movw	r30, r22
    b890:	dc 01       	movw	r26, r24
    b892:	05 90       	lpm	r0, Z+
    b894:	0d 92       	st	X+, r0
    b896:	00 20       	and	r0, r0
    b898:	e1 f7       	brne	.-8      	; 0xb892 <strcpy_P+0x4>
    b89a:	08 95       	ret

0000b89c <memcpy>:
    b89c:	fb 01       	movw	r30, r22
    b89e:	dc 01       	movw	r26, r24
    b8a0:	02 c0       	rjmp	.+4      	; 0xb8a6 <memcpy+0xa>
    b8a2:	01 90       	ld	r0, Z+
    b8a4:	0d 92       	st	X+, r0
    b8a6:	41 50       	subi	r20, 0x01	; 1
    b8a8:	50 40       	sbci	r21, 0x00	; 0
    b8aa:	d8 f7       	brcc	.-10     	; 0xb8a2 <memcpy+0x6>
    b8ac:	08 95       	ret

0000b8ae <memmove>:
    b8ae:	68 17       	cp	r22, r24
    b8b0:	79 07       	cpc	r23, r25
    b8b2:	68 f4       	brcc	.+26     	; 0xb8ce <memmove+0x20>
    b8b4:	fb 01       	movw	r30, r22
    b8b6:	dc 01       	movw	r26, r24
    b8b8:	e4 0f       	add	r30, r20
    b8ba:	f5 1f       	adc	r31, r21
    b8bc:	a4 0f       	add	r26, r20
    b8be:	b5 1f       	adc	r27, r21
    b8c0:	02 c0       	rjmp	.+4      	; 0xb8c6 <memmove+0x18>
    b8c2:	02 90       	ld	r0, -Z
    b8c4:	0e 92       	st	-X, r0
    b8c6:	41 50       	subi	r20, 0x01	; 1
    b8c8:	50 40       	sbci	r21, 0x00	; 0
    b8ca:	d8 f7       	brcc	.-10     	; 0xb8c2 <memmove+0x14>
    b8cc:	08 95       	ret
    b8ce:	0c 94 4e 5c 	jmp	0xb89c	; 0xb89c <memcpy>

0000b8d2 <strcat>:
    b8d2:	fb 01       	movw	r30, r22
    b8d4:	dc 01       	movw	r26, r24
    b8d6:	0d 90       	ld	r0, X+
    b8d8:	00 20       	and	r0, r0
    b8da:	e9 f7       	brne	.-6      	; 0xb8d6 <strcat+0x4>
    b8dc:	11 97       	sbiw	r26, 0x01	; 1
    b8de:	01 90       	ld	r0, Z+
    b8e0:	0d 92       	st	X+, r0
    b8e2:	00 20       	and	r0, r0
    b8e4:	e1 f7       	brne	.-8      	; 0xb8de <strcat+0xc>
    b8e6:	08 95       	ret

0000b8e8 <strncmp>:
    b8e8:	fb 01       	movw	r30, r22
    b8ea:	dc 01       	movw	r26, r24
    b8ec:	41 50       	subi	r20, 0x01	; 1
    b8ee:	50 40       	sbci	r21, 0x00	; 0
    b8f0:	30 f0       	brcs	.+12     	; 0xb8fe <strncmp+0x16>
    b8f2:	8d 91       	ld	r24, X+
    b8f4:	01 90       	ld	r0, Z+
    b8f6:	80 19       	sub	r24, r0
    b8f8:	19 f4       	brne	.+6      	; 0xb900 <strncmp+0x18>
    b8fa:	00 20       	and	r0, r0
    b8fc:	b9 f7       	brne	.-18     	; 0xb8ec <strncmp+0x4>
    b8fe:	88 1b       	sub	r24, r24
    b900:	99 0b       	sbc	r25, r25
    b902:	08 95       	ret

0000b904 <itoa>:
    b904:	fb 01       	movw	r30, r22
    b906:	9f 01       	movw	r18, r30
    b908:	e8 94       	clt
    b90a:	42 30       	cpi	r20, 0x02	; 2
    b90c:	c4 f0       	brlt	.+48     	; 0xb93e <itoa+0x3a>
    b90e:	45 32       	cpi	r20, 0x25	; 37
    b910:	b4 f4       	brge	.+44     	; 0xb93e <itoa+0x3a>
    b912:	4a 30       	cpi	r20, 0x0A	; 10
    b914:	29 f4       	brne	.+10     	; 0xb920 <itoa+0x1c>
    b916:	97 fb       	bst	r25, 7
    b918:	1e f4       	brtc	.+6      	; 0xb920 <itoa+0x1c>
    b91a:	90 95       	com	r25
    b91c:	81 95       	neg	r24
    b91e:	9f 4f       	sbci	r25, 0xFF	; 255
    b920:	64 2f       	mov	r22, r20
    b922:	77 27       	eor	r23, r23
    b924:	0e 94 b2 5b 	call	0xb764	; 0xb764 <__udivmodhi4>
    b928:	80 5d       	subi	r24, 0xD0	; 208
    b92a:	8a 33       	cpi	r24, 0x3A	; 58
    b92c:	0c f0       	brlt	.+2      	; 0xb930 <itoa+0x2c>
    b92e:	89 5d       	subi	r24, 0xD9	; 217
    b930:	81 93       	st	Z+, r24
    b932:	cb 01       	movw	r24, r22
    b934:	00 97       	sbiw	r24, 0x00	; 0
    b936:	a1 f7       	brne	.-24     	; 0xb920 <itoa+0x1c>
    b938:	16 f4       	brtc	.+4      	; 0xb93e <itoa+0x3a>
    b93a:	5d e2       	ldi	r21, 0x2D	; 45
    b93c:	51 93       	st	Z+, r21
    b93e:	10 82       	st	Z, r1
    b940:	c9 01       	movw	r24, r18
    b942:	0c 94 f5 5e 	jmp	0xbdea	; 0xbdea <strrev>

0000b946 <printf>:
    b946:	cf 93       	push	r28
    b948:	df 93       	push	r29
    b94a:	cd b7       	in	r28, 0x3d	; 61
    b94c:	de b7       	in	r29, 0x3e	; 62
    b94e:	fe 01       	movw	r30, r28
    b950:	36 96       	adiw	r30, 0x06	; 6
    b952:	61 91       	ld	r22, Z+
    b954:	71 91       	ld	r23, Z+
    b956:	80 91 d9 50 	lds	r24, 0x50D9
    b95a:	90 91 da 50 	lds	r25, 0x50DA
    b95e:	af 01       	movw	r20, r30
    b960:	0e 94 de 5c 	call	0xb9bc	; 0xb9bc <vfprintf>
    b964:	df 91       	pop	r29
    b966:	cf 91       	pop	r28
    b968:	08 95       	ret

0000b96a <sprintf>:
    b96a:	0f 93       	push	r16
    b96c:	1f 93       	push	r17
    b96e:	cf 93       	push	r28
    b970:	df 93       	push	r29
    b972:	cd b7       	in	r28, 0x3d	; 61
    b974:	de b7       	in	r29, 0x3e	; 62
    b976:	2e 97       	sbiw	r28, 0x0e	; 14
    b978:	cd bf       	out	0x3d, r28	; 61
    b97a:	de bf       	out	0x3e, r29	; 62
    b97c:	0e 89       	ldd	r16, Y+22	; 0x16
    b97e:	1f 89       	ldd	r17, Y+23	; 0x17
    b980:	86 e0       	ldi	r24, 0x06	; 6
    b982:	8c 83       	std	Y+4, r24	; 0x04
    b984:	09 83       	std	Y+1, r16	; 0x01
    b986:	1a 83       	std	Y+2, r17	; 0x02
    b988:	8f ef       	ldi	r24, 0xFF	; 255
    b98a:	9f e7       	ldi	r25, 0x7F	; 127
    b98c:	8d 83       	std	Y+5, r24	; 0x05
    b98e:	9e 83       	std	Y+6, r25	; 0x06
    b990:	ae 01       	movw	r20, r28
    b992:	46 5e       	subi	r20, 0xE6	; 230
    b994:	5f 4f       	sbci	r21, 0xFF	; 255
    b996:	ce 01       	movw	r24, r28
    b998:	01 96       	adiw	r24, 0x01	; 1
    b99a:	68 8d       	ldd	r22, Y+24	; 0x18
    b99c:	79 8d       	ldd	r23, Y+25	; 0x19
    b99e:	0e 94 de 5c 	call	0xb9bc	; 0xb9bc <vfprintf>
    b9a2:	ef 81       	ldd	r30, Y+7	; 0x07
    b9a4:	f8 85       	ldd	r31, Y+8	; 0x08
    b9a6:	e0 0f       	add	r30, r16
    b9a8:	f1 1f       	adc	r31, r17
    b9aa:	10 82       	st	Z, r1
    b9ac:	2e 96       	adiw	r28, 0x0e	; 14
    b9ae:	cd bf       	out	0x3d, r28	; 61
    b9b0:	de bf       	out	0x3e, r29	; 62
    b9b2:	df 91       	pop	r29
    b9b4:	cf 91       	pop	r28
    b9b6:	1f 91       	pop	r17
    b9b8:	0f 91       	pop	r16
    b9ba:	08 95       	ret

0000b9bc <vfprintf>:
    b9bc:	2f 92       	push	r2
    b9be:	3f 92       	push	r3
    b9c0:	4f 92       	push	r4
    b9c2:	5f 92       	push	r5
    b9c4:	6f 92       	push	r6
    b9c6:	7f 92       	push	r7
    b9c8:	8f 92       	push	r8
    b9ca:	9f 92       	push	r9
    b9cc:	af 92       	push	r10
    b9ce:	bf 92       	push	r11
    b9d0:	cf 92       	push	r12
    b9d2:	df 92       	push	r13
    b9d4:	ef 92       	push	r14
    b9d6:	ff 92       	push	r15
    b9d8:	0f 93       	push	r16
    b9da:	1f 93       	push	r17
    b9dc:	cf 93       	push	r28
    b9de:	df 93       	push	r29
    b9e0:	cd b7       	in	r28, 0x3d	; 61
    b9e2:	de b7       	in	r29, 0x3e	; 62
    b9e4:	2d 97       	sbiw	r28, 0x0d	; 13
    b9e6:	cd bf       	out	0x3d, r28	; 61
    b9e8:	de bf       	out	0x3e, r29	; 62
    b9ea:	3c 01       	movw	r6, r24
    b9ec:	6c 87       	std	Y+12, r22	; 0x0c
    b9ee:	7d 87       	std	Y+13, r23	; 0x0d
    b9f0:	5a 01       	movw	r10, r20
    b9f2:	fc 01       	movw	r30, r24
    b9f4:	16 82       	std	Z+6, r1	; 0x06
    b9f6:	17 82       	std	Z+7, r1	; 0x07
    b9f8:	83 81       	ldd	r24, Z+3	; 0x03
    b9fa:	81 ff       	sbrs	r24, 1
    b9fc:	c8 c1       	rjmp	.+912    	; 0xbd8e <vfprintf+0x3d2>
    b9fe:	2e 01       	movw	r4, r28
    ba00:	08 94       	sec
    ba02:	41 1c       	adc	r4, r1
    ba04:	51 1c       	adc	r5, r1
    ba06:	f3 01       	movw	r30, r6
    ba08:	93 81       	ldd	r25, Z+3	; 0x03
    ba0a:	ec 85       	ldd	r30, Y+12	; 0x0c
    ba0c:	fd 85       	ldd	r31, Y+13	; 0x0d
    ba0e:	93 fd       	sbrc	r25, 3
    ba10:	85 91       	lpm	r24, Z+
    ba12:	93 ff       	sbrs	r25, 3
    ba14:	81 91       	ld	r24, Z+
    ba16:	ec 87       	std	Y+12, r30	; 0x0c
    ba18:	fd 87       	std	Y+13, r31	; 0x0d
    ba1a:	88 23       	and	r24, r24
    ba1c:	09 f4       	brne	.+2      	; 0xba20 <vfprintf+0x64>
    ba1e:	b3 c1       	rjmp	.+870    	; 0xbd86 <vfprintf+0x3ca>
    ba20:	85 32       	cpi	r24, 0x25	; 37
    ba22:	41 f4       	brne	.+16     	; 0xba34 <vfprintf+0x78>
    ba24:	93 fd       	sbrc	r25, 3
    ba26:	85 91       	lpm	r24, Z+
    ba28:	93 ff       	sbrs	r25, 3
    ba2a:	81 91       	ld	r24, Z+
    ba2c:	ec 87       	std	Y+12, r30	; 0x0c
    ba2e:	fd 87       	std	Y+13, r31	; 0x0d
    ba30:	85 32       	cpi	r24, 0x25	; 37
    ba32:	29 f4       	brne	.+10     	; 0xba3e <vfprintf+0x82>
    ba34:	90 e0       	ldi	r25, 0x00	; 0
    ba36:	b3 01       	movw	r22, r6
    ba38:	0e 94 05 5f 	call	0xbe0a	; 0xbe0a <fputc>
    ba3c:	e4 cf       	rjmp	.-56     	; 0xba06 <vfprintf+0x4a>
    ba3e:	ff 24       	eor	r15, r15
    ba40:	ee 24       	eor	r14, r14
    ba42:	10 e0       	ldi	r17, 0x00	; 0
    ba44:	10 32       	cpi	r17, 0x20	; 32
    ba46:	b0 f4       	brcc	.+44     	; 0xba74 <vfprintf+0xb8>
    ba48:	8b 32       	cpi	r24, 0x2B	; 43
    ba4a:	69 f0       	breq	.+26     	; 0xba66 <vfprintf+0xaa>
    ba4c:	8c 32       	cpi	r24, 0x2C	; 44
    ba4e:	28 f4       	brcc	.+10     	; 0xba5a <vfprintf+0x9e>
    ba50:	80 32       	cpi	r24, 0x20	; 32
    ba52:	51 f0       	breq	.+20     	; 0xba68 <vfprintf+0xac>
    ba54:	83 32       	cpi	r24, 0x23	; 35
    ba56:	71 f4       	brne	.+28     	; 0xba74 <vfprintf+0xb8>
    ba58:	0b c0       	rjmp	.+22     	; 0xba70 <vfprintf+0xb4>
    ba5a:	8d 32       	cpi	r24, 0x2D	; 45
    ba5c:	39 f0       	breq	.+14     	; 0xba6c <vfprintf+0xb0>
    ba5e:	80 33       	cpi	r24, 0x30	; 48
    ba60:	49 f4       	brne	.+18     	; 0xba74 <vfprintf+0xb8>
    ba62:	11 60       	ori	r17, 0x01	; 1
    ba64:	2c c0       	rjmp	.+88     	; 0xbabe <vfprintf+0x102>
    ba66:	12 60       	ori	r17, 0x02	; 2
    ba68:	14 60       	ori	r17, 0x04	; 4
    ba6a:	29 c0       	rjmp	.+82     	; 0xbabe <vfprintf+0x102>
    ba6c:	18 60       	ori	r17, 0x08	; 8
    ba6e:	27 c0       	rjmp	.+78     	; 0xbabe <vfprintf+0x102>
    ba70:	10 61       	ori	r17, 0x10	; 16
    ba72:	25 c0       	rjmp	.+74     	; 0xbabe <vfprintf+0x102>
    ba74:	17 fd       	sbrc	r17, 7
    ba76:	2e c0       	rjmp	.+92     	; 0xbad4 <vfprintf+0x118>
    ba78:	28 2f       	mov	r18, r24
    ba7a:	20 53       	subi	r18, 0x30	; 48
    ba7c:	2a 30       	cpi	r18, 0x0A	; 10
    ba7e:	98 f4       	brcc	.+38     	; 0xbaa6 <vfprintf+0xea>
    ba80:	16 ff       	sbrs	r17, 6
    ba82:	08 c0       	rjmp	.+16     	; 0xba94 <vfprintf+0xd8>
    ba84:	8f 2d       	mov	r24, r15
    ba86:	88 0f       	add	r24, r24
    ba88:	f8 2e       	mov	r15, r24
    ba8a:	ff 0c       	add	r15, r15
    ba8c:	ff 0c       	add	r15, r15
    ba8e:	f8 0e       	add	r15, r24
    ba90:	f2 0e       	add	r15, r18
    ba92:	15 c0       	rjmp	.+42     	; 0xbabe <vfprintf+0x102>
    ba94:	8e 2d       	mov	r24, r14
    ba96:	88 0f       	add	r24, r24
    ba98:	e8 2e       	mov	r14, r24
    ba9a:	ee 0c       	add	r14, r14
    ba9c:	ee 0c       	add	r14, r14
    ba9e:	e8 0e       	add	r14, r24
    baa0:	e2 0e       	add	r14, r18
    baa2:	10 62       	ori	r17, 0x20	; 32
    baa4:	0c c0       	rjmp	.+24     	; 0xbabe <vfprintf+0x102>
    baa6:	8e 32       	cpi	r24, 0x2E	; 46
    baa8:	21 f4       	brne	.+8      	; 0xbab2 <vfprintf+0xf6>
    baaa:	16 fd       	sbrc	r17, 6
    baac:	6c c1       	rjmp	.+728    	; 0xbd86 <vfprintf+0x3ca>
    baae:	10 64       	ori	r17, 0x40	; 64
    bab0:	06 c0       	rjmp	.+12     	; 0xbabe <vfprintf+0x102>
    bab2:	8c 36       	cpi	r24, 0x6C	; 108
    bab4:	11 f4       	brne	.+4      	; 0xbaba <vfprintf+0xfe>
    bab6:	10 68       	ori	r17, 0x80	; 128
    bab8:	02 c0       	rjmp	.+4      	; 0xbabe <vfprintf+0x102>
    baba:	88 36       	cpi	r24, 0x68	; 104
    babc:	59 f4       	brne	.+22     	; 0xbad4 <vfprintf+0x118>
    babe:	ec 85       	ldd	r30, Y+12	; 0x0c
    bac0:	fd 85       	ldd	r31, Y+13	; 0x0d
    bac2:	93 fd       	sbrc	r25, 3
    bac4:	85 91       	lpm	r24, Z+
    bac6:	93 ff       	sbrs	r25, 3
    bac8:	81 91       	ld	r24, Z+
    baca:	ec 87       	std	Y+12, r30	; 0x0c
    bacc:	fd 87       	std	Y+13, r31	; 0x0d
    bace:	88 23       	and	r24, r24
    bad0:	09 f0       	breq	.+2      	; 0xbad4 <vfprintf+0x118>
    bad2:	b8 cf       	rjmp	.-144    	; 0xba44 <vfprintf+0x88>
    bad4:	98 2f       	mov	r25, r24
    bad6:	95 54       	subi	r25, 0x45	; 69
    bad8:	93 30       	cpi	r25, 0x03	; 3
    bada:	18 f0       	brcs	.+6      	; 0xbae2 <vfprintf+0x126>
    badc:	90 52       	subi	r25, 0x20	; 32
    bade:	93 30       	cpi	r25, 0x03	; 3
    bae0:	38 f4       	brcc	.+14     	; 0xbaf0 <vfprintf+0x134>
    bae2:	24 e0       	ldi	r18, 0x04	; 4
    bae4:	30 e0       	ldi	r19, 0x00	; 0
    bae6:	a2 0e       	add	r10, r18
    bae8:	b3 1e       	adc	r11, r19
    baea:	3f e3       	ldi	r19, 0x3F	; 63
    baec:	39 83       	std	Y+1, r19	; 0x01
    baee:	0f c0       	rjmp	.+30     	; 0xbb0e <vfprintf+0x152>
    baf0:	83 36       	cpi	r24, 0x63	; 99
    baf2:	31 f0       	breq	.+12     	; 0xbb00 <vfprintf+0x144>
    baf4:	83 37       	cpi	r24, 0x73	; 115
    baf6:	81 f0       	breq	.+32     	; 0xbb18 <vfprintf+0x15c>
    baf8:	83 35       	cpi	r24, 0x53	; 83
    bafa:	09 f0       	breq	.+2      	; 0xbafe <vfprintf+0x142>
    bafc:	5a c0       	rjmp	.+180    	; 0xbbb2 <vfprintf+0x1f6>
    bafe:	22 c0       	rjmp	.+68     	; 0xbb44 <vfprintf+0x188>
    bb00:	f5 01       	movw	r30, r10
    bb02:	80 81       	ld	r24, Z
    bb04:	89 83       	std	Y+1, r24	; 0x01
    bb06:	22 e0       	ldi	r18, 0x02	; 2
    bb08:	30 e0       	ldi	r19, 0x00	; 0
    bb0a:	a2 0e       	add	r10, r18
    bb0c:	b3 1e       	adc	r11, r19
    bb0e:	21 e0       	ldi	r18, 0x01	; 1
    bb10:	c2 2e       	mov	r12, r18
    bb12:	d1 2c       	mov	r13, r1
    bb14:	42 01       	movw	r8, r4
    bb16:	14 c0       	rjmp	.+40     	; 0xbb40 <vfprintf+0x184>
    bb18:	92 e0       	ldi	r25, 0x02	; 2
    bb1a:	29 2e       	mov	r2, r25
    bb1c:	31 2c       	mov	r3, r1
    bb1e:	2a 0c       	add	r2, r10
    bb20:	3b 1c       	adc	r3, r11
    bb22:	f5 01       	movw	r30, r10
    bb24:	80 80       	ld	r8, Z
    bb26:	91 80       	ldd	r9, Z+1	; 0x01
    bb28:	16 ff       	sbrs	r17, 6
    bb2a:	03 c0       	rjmp	.+6      	; 0xbb32 <vfprintf+0x176>
    bb2c:	6f 2d       	mov	r22, r15
    bb2e:	70 e0       	ldi	r23, 0x00	; 0
    bb30:	02 c0       	rjmp	.+4      	; 0xbb36 <vfprintf+0x17a>
    bb32:	6f ef       	ldi	r22, 0xFF	; 255
    bb34:	7f ef       	ldi	r23, 0xFF	; 255
    bb36:	c4 01       	movw	r24, r8
    bb38:	0e 94 ea 5e 	call	0xbdd4	; 0xbdd4 <strnlen>
    bb3c:	6c 01       	movw	r12, r24
    bb3e:	51 01       	movw	r10, r2
    bb40:	1f 77       	andi	r17, 0x7F	; 127
    bb42:	15 c0       	rjmp	.+42     	; 0xbb6e <vfprintf+0x1b2>
    bb44:	82 e0       	ldi	r24, 0x02	; 2
    bb46:	28 2e       	mov	r2, r24
    bb48:	31 2c       	mov	r3, r1
    bb4a:	2a 0c       	add	r2, r10
    bb4c:	3b 1c       	adc	r3, r11
    bb4e:	f5 01       	movw	r30, r10
    bb50:	80 80       	ld	r8, Z
    bb52:	91 80       	ldd	r9, Z+1	; 0x01
    bb54:	16 ff       	sbrs	r17, 6
    bb56:	03 c0       	rjmp	.+6      	; 0xbb5e <vfprintf+0x1a2>
    bb58:	6f 2d       	mov	r22, r15
    bb5a:	70 e0       	ldi	r23, 0x00	; 0
    bb5c:	02 c0       	rjmp	.+4      	; 0xbb62 <vfprintf+0x1a6>
    bb5e:	6f ef       	ldi	r22, 0xFF	; 255
    bb60:	7f ef       	ldi	r23, 0xFF	; 255
    bb62:	c4 01       	movw	r24, r8
    bb64:	0e 94 df 5e 	call	0xbdbe	; 0xbdbe <strnlen_P>
    bb68:	6c 01       	movw	r12, r24
    bb6a:	10 68       	ori	r17, 0x80	; 128
    bb6c:	51 01       	movw	r10, r2
    bb6e:	13 fd       	sbrc	r17, 3
    bb70:	1c c0       	rjmp	.+56     	; 0xbbaa <vfprintf+0x1ee>
    bb72:	06 c0       	rjmp	.+12     	; 0xbb80 <vfprintf+0x1c4>
    bb74:	80 e2       	ldi	r24, 0x20	; 32
    bb76:	90 e0       	ldi	r25, 0x00	; 0
    bb78:	b3 01       	movw	r22, r6
    bb7a:	0e 94 05 5f 	call	0xbe0a	; 0xbe0a <fputc>
    bb7e:	ea 94       	dec	r14
    bb80:	8e 2d       	mov	r24, r14
    bb82:	90 e0       	ldi	r25, 0x00	; 0
    bb84:	c8 16       	cp	r12, r24
    bb86:	d9 06       	cpc	r13, r25
    bb88:	a8 f3       	brcs	.-22     	; 0xbb74 <vfprintf+0x1b8>
    bb8a:	0f c0       	rjmp	.+30     	; 0xbbaa <vfprintf+0x1ee>
    bb8c:	f4 01       	movw	r30, r8
    bb8e:	17 fd       	sbrc	r17, 7
    bb90:	85 91       	lpm	r24, Z+
    bb92:	17 ff       	sbrs	r17, 7
    bb94:	81 91       	ld	r24, Z+
    bb96:	4f 01       	movw	r8, r30
    bb98:	90 e0       	ldi	r25, 0x00	; 0
    bb9a:	b3 01       	movw	r22, r6
    bb9c:	0e 94 05 5f 	call	0xbe0a	; 0xbe0a <fputc>
    bba0:	e1 10       	cpse	r14, r1
    bba2:	ea 94       	dec	r14
    bba4:	08 94       	sec
    bba6:	c1 08       	sbc	r12, r1
    bba8:	d1 08       	sbc	r13, r1
    bbaa:	c1 14       	cp	r12, r1
    bbac:	d1 04       	cpc	r13, r1
    bbae:	71 f7       	brne	.-36     	; 0xbb8c <vfprintf+0x1d0>
    bbb0:	e7 c0       	rjmp	.+462    	; 0xbd80 <vfprintf+0x3c4>
    bbb2:	84 36       	cpi	r24, 0x64	; 100
    bbb4:	11 f0       	breq	.+4      	; 0xbbba <vfprintf+0x1fe>
    bbb6:	89 36       	cpi	r24, 0x69	; 105
    bbb8:	51 f5       	brne	.+84     	; 0xbc0e <vfprintf+0x252>
    bbba:	f5 01       	movw	r30, r10
    bbbc:	17 ff       	sbrs	r17, 7
    bbbe:	07 c0       	rjmp	.+14     	; 0xbbce <vfprintf+0x212>
    bbc0:	80 81       	ld	r24, Z
    bbc2:	91 81       	ldd	r25, Z+1	; 0x01
    bbc4:	a2 81       	ldd	r26, Z+2	; 0x02
    bbc6:	b3 81       	ldd	r27, Z+3	; 0x03
    bbc8:	24 e0       	ldi	r18, 0x04	; 4
    bbca:	30 e0       	ldi	r19, 0x00	; 0
    bbcc:	08 c0       	rjmp	.+16     	; 0xbbde <vfprintf+0x222>
    bbce:	80 81       	ld	r24, Z
    bbd0:	91 81       	ldd	r25, Z+1	; 0x01
    bbd2:	aa 27       	eor	r26, r26
    bbd4:	97 fd       	sbrc	r25, 7
    bbd6:	a0 95       	com	r26
    bbd8:	ba 2f       	mov	r27, r26
    bbda:	22 e0       	ldi	r18, 0x02	; 2
    bbdc:	30 e0       	ldi	r19, 0x00	; 0
    bbde:	a2 0e       	add	r10, r18
    bbe0:	b3 1e       	adc	r11, r19
    bbe2:	01 2f       	mov	r16, r17
    bbe4:	0f 76       	andi	r16, 0x6F	; 111
    bbe6:	b7 ff       	sbrs	r27, 7
    bbe8:	08 c0       	rjmp	.+16     	; 0xbbfa <vfprintf+0x23e>
    bbea:	b0 95       	com	r27
    bbec:	a0 95       	com	r26
    bbee:	90 95       	com	r25
    bbf0:	81 95       	neg	r24
    bbf2:	9f 4f       	sbci	r25, 0xFF	; 255
    bbf4:	af 4f       	sbci	r26, 0xFF	; 255
    bbf6:	bf 4f       	sbci	r27, 0xFF	; 255
    bbf8:	00 68       	ori	r16, 0x80	; 128
    bbfa:	bc 01       	movw	r22, r24
    bbfc:	cd 01       	movw	r24, r26
    bbfe:	a2 01       	movw	r20, r4
    bc00:	2a e0       	ldi	r18, 0x0A	; 10
    bc02:	30 e0       	ldi	r19, 0x00	; 0
    bc04:	0e 94 31 5f 	call	0xbe62	; 0xbe62 <__ultoa_invert>
    bc08:	d8 2e       	mov	r13, r24
    bc0a:	d4 18       	sub	r13, r4
    bc0c:	3f c0       	rjmp	.+126    	; 0xbc8c <vfprintf+0x2d0>
    bc0e:	85 37       	cpi	r24, 0x75	; 117
    bc10:	21 f4       	brne	.+8      	; 0xbc1a <vfprintf+0x25e>
    bc12:	1f 7e       	andi	r17, 0xEF	; 239
    bc14:	2a e0       	ldi	r18, 0x0A	; 10
    bc16:	30 e0       	ldi	r19, 0x00	; 0
    bc18:	20 c0       	rjmp	.+64     	; 0xbc5a <vfprintf+0x29e>
    bc1a:	19 7f       	andi	r17, 0xF9	; 249
    bc1c:	8f 36       	cpi	r24, 0x6F	; 111
    bc1e:	a9 f0       	breq	.+42     	; 0xbc4a <vfprintf+0x28e>
    bc20:	80 37       	cpi	r24, 0x70	; 112
    bc22:	20 f4       	brcc	.+8      	; 0xbc2c <vfprintf+0x270>
    bc24:	88 35       	cpi	r24, 0x58	; 88
    bc26:	09 f0       	breq	.+2      	; 0xbc2a <vfprintf+0x26e>
    bc28:	ae c0       	rjmp	.+348    	; 0xbd86 <vfprintf+0x3ca>
    bc2a:	0b c0       	rjmp	.+22     	; 0xbc42 <vfprintf+0x286>
    bc2c:	80 37       	cpi	r24, 0x70	; 112
    bc2e:	21 f0       	breq	.+8      	; 0xbc38 <vfprintf+0x27c>
    bc30:	88 37       	cpi	r24, 0x78	; 120
    bc32:	09 f0       	breq	.+2      	; 0xbc36 <vfprintf+0x27a>
    bc34:	a8 c0       	rjmp	.+336    	; 0xbd86 <vfprintf+0x3ca>
    bc36:	01 c0       	rjmp	.+2      	; 0xbc3a <vfprintf+0x27e>
    bc38:	10 61       	ori	r17, 0x10	; 16
    bc3a:	14 ff       	sbrs	r17, 4
    bc3c:	09 c0       	rjmp	.+18     	; 0xbc50 <vfprintf+0x294>
    bc3e:	14 60       	ori	r17, 0x04	; 4
    bc40:	07 c0       	rjmp	.+14     	; 0xbc50 <vfprintf+0x294>
    bc42:	14 ff       	sbrs	r17, 4
    bc44:	08 c0       	rjmp	.+16     	; 0xbc56 <vfprintf+0x29a>
    bc46:	16 60       	ori	r17, 0x06	; 6
    bc48:	06 c0       	rjmp	.+12     	; 0xbc56 <vfprintf+0x29a>
    bc4a:	28 e0       	ldi	r18, 0x08	; 8
    bc4c:	30 e0       	ldi	r19, 0x00	; 0
    bc4e:	05 c0       	rjmp	.+10     	; 0xbc5a <vfprintf+0x29e>
    bc50:	20 e1       	ldi	r18, 0x10	; 16
    bc52:	30 e0       	ldi	r19, 0x00	; 0
    bc54:	02 c0       	rjmp	.+4      	; 0xbc5a <vfprintf+0x29e>
    bc56:	20 e1       	ldi	r18, 0x10	; 16
    bc58:	32 e0       	ldi	r19, 0x02	; 2
    bc5a:	f5 01       	movw	r30, r10
    bc5c:	17 ff       	sbrs	r17, 7
    bc5e:	07 c0       	rjmp	.+14     	; 0xbc6e <vfprintf+0x2b2>
    bc60:	60 81       	ld	r22, Z
    bc62:	71 81       	ldd	r23, Z+1	; 0x01
    bc64:	82 81       	ldd	r24, Z+2	; 0x02
    bc66:	93 81       	ldd	r25, Z+3	; 0x03
    bc68:	44 e0       	ldi	r20, 0x04	; 4
    bc6a:	50 e0       	ldi	r21, 0x00	; 0
    bc6c:	06 c0       	rjmp	.+12     	; 0xbc7a <vfprintf+0x2be>
    bc6e:	60 81       	ld	r22, Z
    bc70:	71 81       	ldd	r23, Z+1	; 0x01
    bc72:	80 e0       	ldi	r24, 0x00	; 0
    bc74:	90 e0       	ldi	r25, 0x00	; 0
    bc76:	42 e0       	ldi	r20, 0x02	; 2
    bc78:	50 e0       	ldi	r21, 0x00	; 0
    bc7a:	a4 0e       	add	r10, r20
    bc7c:	b5 1e       	adc	r11, r21
    bc7e:	a2 01       	movw	r20, r4
    bc80:	0e 94 31 5f 	call	0xbe62	; 0xbe62 <__ultoa_invert>
    bc84:	d8 2e       	mov	r13, r24
    bc86:	d4 18       	sub	r13, r4
    bc88:	01 2f       	mov	r16, r17
    bc8a:	0f 77       	andi	r16, 0x7F	; 127
    bc8c:	06 ff       	sbrs	r16, 6
    bc8e:	09 c0       	rjmp	.+18     	; 0xbca2 <vfprintf+0x2e6>
    bc90:	0e 7f       	andi	r16, 0xFE	; 254
    bc92:	df 14       	cp	r13, r15
    bc94:	30 f4       	brcc	.+12     	; 0xbca2 <vfprintf+0x2e6>
    bc96:	04 ff       	sbrs	r16, 4
    bc98:	06 c0       	rjmp	.+12     	; 0xbca6 <vfprintf+0x2ea>
    bc9a:	02 fd       	sbrc	r16, 2
    bc9c:	04 c0       	rjmp	.+8      	; 0xbca6 <vfprintf+0x2ea>
    bc9e:	0f 7e       	andi	r16, 0xEF	; 239
    bca0:	02 c0       	rjmp	.+4      	; 0xbca6 <vfprintf+0x2ea>
    bca2:	1d 2d       	mov	r17, r13
    bca4:	01 c0       	rjmp	.+2      	; 0xbca8 <vfprintf+0x2ec>
    bca6:	1f 2d       	mov	r17, r15
    bca8:	80 2f       	mov	r24, r16
    bcaa:	90 e0       	ldi	r25, 0x00	; 0
    bcac:	04 ff       	sbrs	r16, 4
    bcae:	0c c0       	rjmp	.+24     	; 0xbcc8 <vfprintf+0x30c>
    bcb0:	fe 01       	movw	r30, r28
    bcb2:	ed 0d       	add	r30, r13
    bcb4:	f1 1d       	adc	r31, r1
    bcb6:	20 81       	ld	r18, Z
    bcb8:	20 33       	cpi	r18, 0x30	; 48
    bcba:	11 f4       	brne	.+4      	; 0xbcc0 <vfprintf+0x304>
    bcbc:	09 7e       	andi	r16, 0xE9	; 233
    bcbe:	09 c0       	rjmp	.+18     	; 0xbcd2 <vfprintf+0x316>
    bcc0:	02 ff       	sbrs	r16, 2
    bcc2:	06 c0       	rjmp	.+12     	; 0xbcd0 <vfprintf+0x314>
    bcc4:	1e 5f       	subi	r17, 0xFE	; 254
    bcc6:	05 c0       	rjmp	.+10     	; 0xbcd2 <vfprintf+0x316>
    bcc8:	86 78       	andi	r24, 0x86	; 134
    bcca:	90 70       	andi	r25, 0x00	; 0
    bccc:	00 97       	sbiw	r24, 0x00	; 0
    bcce:	09 f0       	breq	.+2      	; 0xbcd2 <vfprintf+0x316>
    bcd0:	1f 5f       	subi	r17, 0xFF	; 255
    bcd2:	80 2e       	mov	r8, r16
    bcd4:	99 24       	eor	r9, r9
    bcd6:	03 fd       	sbrc	r16, 3
    bcd8:	12 c0       	rjmp	.+36     	; 0xbcfe <vfprintf+0x342>
    bcda:	00 ff       	sbrs	r16, 0
    bcdc:	0d c0       	rjmp	.+26     	; 0xbcf8 <vfprintf+0x33c>
    bcde:	fd 2c       	mov	r15, r13
    bce0:	1e 15       	cp	r17, r14
    bce2:	50 f4       	brcc	.+20     	; 0xbcf8 <vfprintf+0x33c>
    bce4:	fe 0c       	add	r15, r14
    bce6:	f1 1a       	sub	r15, r17
    bce8:	1e 2d       	mov	r17, r14
    bcea:	06 c0       	rjmp	.+12     	; 0xbcf8 <vfprintf+0x33c>
    bcec:	80 e2       	ldi	r24, 0x20	; 32
    bcee:	90 e0       	ldi	r25, 0x00	; 0
    bcf0:	b3 01       	movw	r22, r6
    bcf2:	0e 94 05 5f 	call	0xbe0a	; 0xbe0a <fputc>
    bcf6:	1f 5f       	subi	r17, 0xFF	; 255
    bcf8:	1e 15       	cp	r17, r14
    bcfa:	c0 f3       	brcs	.-16     	; 0xbcec <vfprintf+0x330>
    bcfc:	04 c0       	rjmp	.+8      	; 0xbd06 <vfprintf+0x34a>
    bcfe:	1e 15       	cp	r17, r14
    bd00:	10 f4       	brcc	.+4      	; 0xbd06 <vfprintf+0x34a>
    bd02:	e1 1a       	sub	r14, r17
    bd04:	01 c0       	rjmp	.+2      	; 0xbd08 <vfprintf+0x34c>
    bd06:	ee 24       	eor	r14, r14
    bd08:	84 fe       	sbrs	r8, 4
    bd0a:	0f c0       	rjmp	.+30     	; 0xbd2a <vfprintf+0x36e>
    bd0c:	80 e3       	ldi	r24, 0x30	; 48
    bd0e:	90 e0       	ldi	r25, 0x00	; 0
    bd10:	b3 01       	movw	r22, r6
    bd12:	0e 94 05 5f 	call	0xbe0a	; 0xbe0a <fputc>
    bd16:	82 fe       	sbrs	r8, 2
    bd18:	1f c0       	rjmp	.+62     	; 0xbd58 <vfprintf+0x39c>
    bd1a:	81 fe       	sbrs	r8, 1
    bd1c:	03 c0       	rjmp	.+6      	; 0xbd24 <vfprintf+0x368>
    bd1e:	88 e5       	ldi	r24, 0x58	; 88
    bd20:	90 e0       	ldi	r25, 0x00	; 0
    bd22:	10 c0       	rjmp	.+32     	; 0xbd44 <vfprintf+0x388>
    bd24:	88 e7       	ldi	r24, 0x78	; 120
    bd26:	90 e0       	ldi	r25, 0x00	; 0
    bd28:	0d c0       	rjmp	.+26     	; 0xbd44 <vfprintf+0x388>
    bd2a:	c4 01       	movw	r24, r8
    bd2c:	86 78       	andi	r24, 0x86	; 134
    bd2e:	90 70       	andi	r25, 0x00	; 0
    bd30:	00 97       	sbiw	r24, 0x00	; 0
    bd32:	91 f0       	breq	.+36     	; 0xbd58 <vfprintf+0x39c>
    bd34:	81 fc       	sbrc	r8, 1
    bd36:	02 c0       	rjmp	.+4      	; 0xbd3c <vfprintf+0x380>
    bd38:	80 e2       	ldi	r24, 0x20	; 32
    bd3a:	01 c0       	rjmp	.+2      	; 0xbd3e <vfprintf+0x382>
    bd3c:	8b e2       	ldi	r24, 0x2B	; 43
    bd3e:	07 fd       	sbrc	r16, 7
    bd40:	8d e2       	ldi	r24, 0x2D	; 45
    bd42:	90 e0       	ldi	r25, 0x00	; 0
    bd44:	b3 01       	movw	r22, r6
    bd46:	0e 94 05 5f 	call	0xbe0a	; 0xbe0a <fputc>
    bd4a:	06 c0       	rjmp	.+12     	; 0xbd58 <vfprintf+0x39c>
    bd4c:	80 e3       	ldi	r24, 0x30	; 48
    bd4e:	90 e0       	ldi	r25, 0x00	; 0
    bd50:	b3 01       	movw	r22, r6
    bd52:	0e 94 05 5f 	call	0xbe0a	; 0xbe0a <fputc>
    bd56:	fa 94       	dec	r15
    bd58:	df 14       	cp	r13, r15
    bd5a:	c0 f3       	brcs	.-16     	; 0xbd4c <vfprintf+0x390>
    bd5c:	da 94       	dec	r13
    bd5e:	f2 01       	movw	r30, r4
    bd60:	ed 0d       	add	r30, r13
    bd62:	f1 1d       	adc	r31, r1
    bd64:	80 81       	ld	r24, Z
    bd66:	90 e0       	ldi	r25, 0x00	; 0
    bd68:	b3 01       	movw	r22, r6
    bd6a:	0e 94 05 5f 	call	0xbe0a	; 0xbe0a <fputc>
    bd6e:	dd 20       	and	r13, r13
    bd70:	a9 f7       	brne	.-22     	; 0xbd5c <vfprintf+0x3a0>
    bd72:	06 c0       	rjmp	.+12     	; 0xbd80 <vfprintf+0x3c4>
    bd74:	80 e2       	ldi	r24, 0x20	; 32
    bd76:	90 e0       	ldi	r25, 0x00	; 0
    bd78:	b3 01       	movw	r22, r6
    bd7a:	0e 94 05 5f 	call	0xbe0a	; 0xbe0a <fputc>
    bd7e:	ea 94       	dec	r14
    bd80:	ee 20       	and	r14, r14
    bd82:	c1 f7       	brne	.-16     	; 0xbd74 <vfprintf+0x3b8>
    bd84:	40 ce       	rjmp	.-896    	; 0xba06 <vfprintf+0x4a>
    bd86:	f3 01       	movw	r30, r6
    bd88:	86 81       	ldd	r24, Z+6	; 0x06
    bd8a:	97 81       	ldd	r25, Z+7	; 0x07
    bd8c:	02 c0       	rjmp	.+4      	; 0xbd92 <vfprintf+0x3d6>
    bd8e:	8f ef       	ldi	r24, 0xFF	; 255
    bd90:	9f ef       	ldi	r25, 0xFF	; 255
    bd92:	2d 96       	adiw	r28, 0x0d	; 13
    bd94:	cd bf       	out	0x3d, r28	; 61
    bd96:	de bf       	out	0x3e, r29	; 62
    bd98:	df 91       	pop	r29
    bd9a:	cf 91       	pop	r28
    bd9c:	1f 91       	pop	r17
    bd9e:	0f 91       	pop	r16
    bda0:	ff 90       	pop	r15
    bda2:	ef 90       	pop	r14
    bda4:	df 90       	pop	r13
    bda6:	cf 90       	pop	r12
    bda8:	bf 90       	pop	r11
    bdaa:	af 90       	pop	r10
    bdac:	9f 90       	pop	r9
    bdae:	8f 90       	pop	r8
    bdb0:	7f 90       	pop	r7
    bdb2:	6f 90       	pop	r6
    bdb4:	5f 90       	pop	r5
    bdb6:	4f 90       	pop	r4
    bdb8:	3f 90       	pop	r3
    bdba:	2f 90       	pop	r2
    bdbc:	08 95       	ret

0000bdbe <strnlen_P>:
    bdbe:	fc 01       	movw	r30, r24
    bdc0:	05 90       	lpm	r0, Z+
    bdc2:	61 50       	subi	r22, 0x01	; 1
    bdc4:	70 40       	sbci	r23, 0x00	; 0
    bdc6:	01 10       	cpse	r0, r1
    bdc8:	d8 f7       	brcc	.-10     	; 0xbdc0 <strnlen_P+0x2>
    bdca:	80 95       	com	r24
    bdcc:	90 95       	com	r25
    bdce:	8e 0f       	add	r24, r30
    bdd0:	9f 1f       	adc	r25, r31
    bdd2:	08 95       	ret

0000bdd4 <strnlen>:
    bdd4:	fc 01       	movw	r30, r24
    bdd6:	61 50       	subi	r22, 0x01	; 1
    bdd8:	70 40       	sbci	r23, 0x00	; 0
    bdda:	01 90       	ld	r0, Z+
    bddc:	01 10       	cpse	r0, r1
    bdde:	d8 f7       	brcc	.-10     	; 0xbdd6 <strnlen+0x2>
    bde0:	80 95       	com	r24
    bde2:	90 95       	com	r25
    bde4:	8e 0f       	add	r24, r30
    bde6:	9f 1f       	adc	r25, r31
    bde8:	08 95       	ret

0000bdea <strrev>:
    bdea:	dc 01       	movw	r26, r24
    bdec:	fc 01       	movw	r30, r24
    bdee:	67 2f       	mov	r22, r23
    bdf0:	71 91       	ld	r23, Z+
    bdf2:	77 23       	and	r23, r23
    bdf4:	e1 f7       	brne	.-8      	; 0xbdee <strrev+0x4>
    bdf6:	32 97       	sbiw	r30, 0x02	; 2
    bdf8:	04 c0       	rjmp	.+8      	; 0xbe02 <strrev+0x18>
    bdfa:	7c 91       	ld	r23, X
    bdfc:	6d 93       	st	X+, r22
    bdfe:	70 83       	st	Z, r23
    be00:	62 91       	ld	r22, -Z
    be02:	ae 17       	cp	r26, r30
    be04:	bf 07       	cpc	r27, r31
    be06:	c8 f3       	brcs	.-14     	; 0xbdfa <strrev+0x10>
    be08:	08 95       	ret

0000be0a <fputc>:
    be0a:	0f 93       	push	r16
    be0c:	1f 93       	push	r17
    be0e:	cf 93       	push	r28
    be10:	df 93       	push	r29
    be12:	8c 01       	movw	r16, r24
    be14:	eb 01       	movw	r28, r22
    be16:	8b 81       	ldd	r24, Y+3	; 0x03
    be18:	81 ff       	sbrs	r24, 1
    be1a:	1b c0       	rjmp	.+54     	; 0xbe52 <fputc+0x48>
    be1c:	82 ff       	sbrs	r24, 2
    be1e:	0d c0       	rjmp	.+26     	; 0xbe3a <fputc+0x30>
    be20:	2e 81       	ldd	r18, Y+6	; 0x06
    be22:	3f 81       	ldd	r19, Y+7	; 0x07
    be24:	8c 81       	ldd	r24, Y+4	; 0x04
    be26:	9d 81       	ldd	r25, Y+5	; 0x05
    be28:	28 17       	cp	r18, r24
    be2a:	39 07       	cpc	r19, r25
    be2c:	64 f4       	brge	.+24     	; 0xbe46 <fputc+0x3c>
    be2e:	e8 81       	ld	r30, Y
    be30:	f9 81       	ldd	r31, Y+1	; 0x01
    be32:	01 93       	st	Z+, r16
    be34:	e8 83       	st	Y, r30
    be36:	f9 83       	std	Y+1, r31	; 0x01
    be38:	06 c0       	rjmp	.+12     	; 0xbe46 <fputc+0x3c>
    be3a:	e8 85       	ldd	r30, Y+8	; 0x08
    be3c:	f9 85       	ldd	r31, Y+9	; 0x09
    be3e:	80 2f       	mov	r24, r16
    be40:	19 95       	eicall
    be42:	00 97       	sbiw	r24, 0x00	; 0
    be44:	31 f4       	brne	.+12     	; 0xbe52 <fputc+0x48>
    be46:	8e 81       	ldd	r24, Y+6	; 0x06
    be48:	9f 81       	ldd	r25, Y+7	; 0x07
    be4a:	01 96       	adiw	r24, 0x01	; 1
    be4c:	8e 83       	std	Y+6, r24	; 0x06
    be4e:	9f 83       	std	Y+7, r25	; 0x07
    be50:	02 c0       	rjmp	.+4      	; 0xbe56 <fputc+0x4c>
    be52:	0f ef       	ldi	r16, 0xFF	; 255
    be54:	1f ef       	ldi	r17, 0xFF	; 255
    be56:	c8 01       	movw	r24, r16
    be58:	df 91       	pop	r29
    be5a:	cf 91       	pop	r28
    be5c:	1f 91       	pop	r17
    be5e:	0f 91       	pop	r16
    be60:	08 95       	ret

0000be62 <__ultoa_invert>:
    be62:	fa 01       	movw	r30, r20
    be64:	aa 27       	eor	r26, r26
    be66:	28 30       	cpi	r18, 0x08	; 8
    be68:	51 f1       	breq	.+84     	; 0xbebe <__ultoa_invert+0x5c>
    be6a:	20 31       	cpi	r18, 0x10	; 16
    be6c:	81 f1       	breq	.+96     	; 0xbece <__ultoa_invert+0x6c>
    be6e:	e8 94       	clt
    be70:	6f 93       	push	r22
    be72:	6e 7f       	andi	r22, 0xFE	; 254
    be74:	6e 5f       	subi	r22, 0xFE	; 254
    be76:	7f 4f       	sbci	r23, 0xFF	; 255
    be78:	8f 4f       	sbci	r24, 0xFF	; 255
    be7a:	9f 4f       	sbci	r25, 0xFF	; 255
    be7c:	af 4f       	sbci	r26, 0xFF	; 255
    be7e:	b1 e0       	ldi	r27, 0x01	; 1
    be80:	3e d0       	rcall	.+124    	; 0xbefe <__ultoa_invert+0x9c>
    be82:	b4 e0       	ldi	r27, 0x04	; 4
    be84:	3c d0       	rcall	.+120    	; 0xbefe <__ultoa_invert+0x9c>
    be86:	67 0f       	add	r22, r23
    be88:	78 1f       	adc	r23, r24
    be8a:	89 1f       	adc	r24, r25
    be8c:	9a 1f       	adc	r25, r26
    be8e:	a1 1d       	adc	r26, r1
    be90:	68 0f       	add	r22, r24
    be92:	79 1f       	adc	r23, r25
    be94:	8a 1f       	adc	r24, r26
    be96:	91 1d       	adc	r25, r1
    be98:	a1 1d       	adc	r26, r1
    be9a:	6a 0f       	add	r22, r26
    be9c:	71 1d       	adc	r23, r1
    be9e:	81 1d       	adc	r24, r1
    bea0:	91 1d       	adc	r25, r1
    bea2:	a1 1d       	adc	r26, r1
    bea4:	20 d0       	rcall	.+64     	; 0xbee6 <__ultoa_invert+0x84>
    bea6:	09 f4       	brne	.+2      	; 0xbeaa <__ultoa_invert+0x48>
    bea8:	68 94       	set
    beaa:	3f 91       	pop	r19
    beac:	2a e0       	ldi	r18, 0x0A	; 10
    beae:	26 9f       	mul	r18, r22
    beb0:	11 24       	eor	r1, r1
    beb2:	30 19       	sub	r19, r0
    beb4:	30 5d       	subi	r19, 0xD0	; 208
    beb6:	31 93       	st	Z+, r19
    beb8:	de f6       	brtc	.-74     	; 0xbe70 <__ultoa_invert+0xe>
    beba:	cf 01       	movw	r24, r30
    bebc:	08 95       	ret
    bebe:	46 2f       	mov	r20, r22
    bec0:	47 70       	andi	r20, 0x07	; 7
    bec2:	40 5d       	subi	r20, 0xD0	; 208
    bec4:	41 93       	st	Z+, r20
    bec6:	b3 e0       	ldi	r27, 0x03	; 3
    bec8:	0f d0       	rcall	.+30     	; 0xbee8 <__ultoa_invert+0x86>
    beca:	c9 f7       	brne	.-14     	; 0xbebe <__ultoa_invert+0x5c>
    becc:	f6 cf       	rjmp	.-20     	; 0xbeba <__ultoa_invert+0x58>
    bece:	46 2f       	mov	r20, r22
    bed0:	4f 70       	andi	r20, 0x0F	; 15
    bed2:	40 5d       	subi	r20, 0xD0	; 208
    bed4:	4a 33       	cpi	r20, 0x3A	; 58
    bed6:	18 f0       	brcs	.+6      	; 0xbede <__ultoa_invert+0x7c>
    bed8:	49 5d       	subi	r20, 0xD9	; 217
    beda:	31 fd       	sbrc	r19, 1
    bedc:	40 52       	subi	r20, 0x20	; 32
    bede:	41 93       	st	Z+, r20
    bee0:	02 d0       	rcall	.+4      	; 0xbee6 <__ultoa_invert+0x84>
    bee2:	a9 f7       	brne	.-22     	; 0xbece <__ultoa_invert+0x6c>
    bee4:	ea cf       	rjmp	.-44     	; 0xbeba <__ultoa_invert+0x58>
    bee6:	b4 e0       	ldi	r27, 0x04	; 4
    bee8:	a6 95       	lsr	r26
    beea:	97 95       	ror	r25
    beec:	87 95       	ror	r24
    beee:	77 95       	ror	r23
    bef0:	67 95       	ror	r22
    bef2:	ba 95       	dec	r27
    bef4:	c9 f7       	brne	.-14     	; 0xbee8 <__ultoa_invert+0x86>
    bef6:	00 97       	sbiw	r24, 0x00	; 0
    bef8:	61 05       	cpc	r22, r1
    befa:	71 05       	cpc	r23, r1
    befc:	08 95       	ret
    befe:	9b 01       	movw	r18, r22
    bf00:	ac 01       	movw	r20, r24
    bf02:	0a 2e       	mov	r0, r26
    bf04:	06 94       	lsr	r0
    bf06:	57 95       	ror	r21
    bf08:	47 95       	ror	r20
    bf0a:	37 95       	ror	r19
    bf0c:	27 95       	ror	r18
    bf0e:	ba 95       	dec	r27
    bf10:	c9 f7       	brne	.-14     	; 0xbf04 <__ultoa_invert+0xa2>
    bf12:	62 0f       	add	r22, r18
    bf14:	73 1f       	adc	r23, r19
    bf16:	84 1f       	adc	r24, r20
    bf18:	95 1f       	adc	r25, r21
    bf1a:	a0 1d       	adc	r26, r0
    bf1c:	08 95       	ret

0000bf1e <_exit>:
    bf1e:	f8 94       	cli

0000bf20 <__stop_program>:
    bf20:	ff cf       	rjmp	.-2      	; 0xbf20 <__stop_program>
