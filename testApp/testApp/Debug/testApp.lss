
testApp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000714a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000011c  00802000  0000714a  000071de  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002f9d  0080211c  0080211c  000072fa  2**0
                  ALLOC
  3 .stab         00000e70  00000000  00000000  000072fc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000002e1  00000000  00000000  0000816c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000003a0  00000000  00000000  00008450  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000a229  00000000  00000000  000087f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002204  00000000  00000000  00012a19  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003452  00000000  00000000  00014c1d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000018fc  00000000  00000000  00018070  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004490  00000000  00000000  0001996c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000761f  00000000  00000000  0001ddfc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000190  00000000  00000000  0002541b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__ctors_end>
       4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
       c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      10:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      14:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      18:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      1c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      20:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      24:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      28:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      2c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      30:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      34:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      38:	0c 94 60 09 	jmp	0x12c0	; 0x12c0 <__vector_14>
      3c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      40:	0c 94 11 08 	jmp	0x1022	; 0x1022 <__vector_16>
      44:	0c 94 e9 07 	jmp	0xfd2	; 0xfd2 <__vector_17>
      48:	0c 94 c1 07 	jmp	0xf82	; 0xf82 <__vector_18>
      4c:	0c 94 7b 07 	jmp	0xef6	; 0xef6 <__vector_19>
      50:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      54:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      58:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      5c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      60:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      64:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      68:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      6c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      70:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      74:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      78:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      7c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      80:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      84:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      88:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      8c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      90:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      94:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      98:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      9c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      e8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      ec:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      f8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
      fc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     100:	0c 94 ba 17 	jmp	0x2f74	; 0x2f74 <__vector_64>
     104:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     108:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     10c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     110:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     114:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     118:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     11c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     120:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     124:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     128:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     12c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     130:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     134:	0c 94 38 09 	jmp	0x1270	; 0x1270 <__vector_77>
     138:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     13c:	0c 94 53 07 	jmp	0xea6	; 0xea6 <__vector_79>
     140:	0c 94 2b 07 	jmp	0xe56	; 0xe56 <__vector_80>
     144:	0c 94 03 07 	jmp	0xe06	; 0xe06 <__vector_81>
     148:	0c 94 d9 06 	jmp	0xdb2	; 0xdb2 <__vector_82>
     14c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     150:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     154:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     158:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     15c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     160:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     164:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     168:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     16c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     170:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     174:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     178:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     17c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     180:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     184:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     188:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     18c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     190:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     194:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     198:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     19c:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1a0:	0c 94 ee 05 	jmp	0xbdc	; 0xbdc <__vector_104>
     1a4:	0c 94 b6 04 	jmp	0x96c	; 0x96c <__vector_105>
     1a8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1ac:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1b8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1bc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1c8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1cc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1d8:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1dc:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>
     1e4:	0c 94 37 01 	jmp	0x26e	; 0x26e <__bad_interrupt>

000001e8 <chb_err_init>:
     1e8:	52 41 44 49 4f 20 4e 4f 54 20 49 4e 49 54 49 41     RADIO NOT INITIA
     1f8:	4c 49 5a 45 44 20 50 52 4f 50 45 52 4c 59 0a 00     LIZED PROPERLY..

00000208 <chb_err_overflow>:
     208:	42 55 46 46 45 52 20 46 55 4c 4c 2e 20 54 4f 53     BUFFER FULL. TOS
     218:	53 49 4e 47 20 49 4e 43 4f 4d 49 4e 47 20 44 41     SING INCOMING DA
     228:	54 41 0a 00                                         TA..

0000022c <__ctors_end>:
     22c:	11 24       	eor	r1, r1
     22e:	1f be       	out	0x3f, r1	; 63
     230:	cf ef       	ldi	r28, 0xFF	; 255
     232:	df e5       	ldi	r29, 0x5F	; 95
     234:	de bf       	out	0x3e, r29	; 62
     236:	cd bf       	out	0x3d, r28	; 61
     238:	00 e0       	ldi	r16, 0x00	; 0
     23a:	0c bf       	out	0x3c, r16	; 60

0000023c <__do_copy_data>:
     23c:	11 e2       	ldi	r17, 0x21	; 33
     23e:	a0 e0       	ldi	r26, 0x00	; 0
     240:	b0 e2       	ldi	r27, 0x20	; 32
     242:	ea e4       	ldi	r30, 0x4A	; 74
     244:	f1 e7       	ldi	r31, 0x71	; 113
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	0b bf       	out	0x3b, r16	; 59
     24a:	02 c0       	rjmp	.+4      	; 0x250 <__do_copy_data+0x14>
     24c:	07 90       	elpm	r0, Z+
     24e:	0d 92       	st	X+, r0
     250:	ac 31       	cpi	r26, 0x1C	; 28
     252:	b1 07       	cpc	r27, r17
     254:	d9 f7       	brne	.-10     	; 0x24c <__do_copy_data+0x10>

00000256 <__do_clear_bss>:
     256:	10 e5       	ldi	r17, 0x50	; 80
     258:	ac e1       	ldi	r26, 0x1C	; 28
     25a:	b1 e2       	ldi	r27, 0x21	; 33
     25c:	01 c0       	rjmp	.+2      	; 0x260 <.do_clear_bss_start>

0000025e <.do_clear_bss_loop>:
     25e:	1d 92       	st	X+, r1

00000260 <.do_clear_bss_start>:
     260:	a9 3b       	cpi	r26, 0xB9	; 185
     262:	b1 07       	cpc	r27, r17
     264:	e1 f7       	brne	.-8      	; 0x25e <.do_clear_bss_loop>
     266:	0e 94 ab 2b 	call	0x5756	; 0x5756 <main>
     26a:	0c 94 a3 38 	jmp	0x7146	; 0x7146 <_exit>

0000026e <__bad_interrupt>:
     26e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000272 <set_ampGain>:
 *	All selected op-amps will be set to the same gain value.
 *
 *	\param channel	channel for gain to be set
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 */
void set_ampGain(uint8_t channel, uint8_t gainExponent) {
     272:	cf 93       	push	r28
     274:	c6 2f       	mov	r28, r22
	// set chip select.  note: AD8231 CS is select on low
	PortEx_OUTCLR((1 << channel), PS_BANKA);
     276:	21 e0       	ldi	r18, 0x01	; 1
     278:	30 e0       	ldi	r19, 0x00	; 0
     27a:	a9 01       	movw	r20, r18
     27c:	02 c0       	rjmp	.+4      	; 0x282 <set_ampGain+0x10>
     27e:	44 0f       	add	r20, r20
     280:	55 1f       	adc	r21, r21
     282:	8a 95       	dec	r24
     284:	e2 f7       	brpl	.-8      	; 0x27e <set_ampGain+0xc>
     286:	ca 01       	movw	r24, r20
     288:	61 e0       	ldi	r22, 0x01	; 1
     28a:	0e 94 36 1b 	call	0x366c	; 0x366c <PortEx_OUTCLR>
	//setPortEx(~(1 << channel), PS_BANKA);
	// set gain
	// set bit A0
	if(gainExponent & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
     28e:	c0 ff       	sbrs	r28, 0
     290:	05 c0       	rjmp	.+10     	; 0x29c <set_ampGain+0x2a>
     292:	80 e4       	ldi	r24, 0x40	; 64
     294:	e0 e0       	ldi	r30, 0x00	; 0
     296:	f6 e0       	ldi	r31, 0x06	; 6
     298:	85 83       	std	Z+5, r24	; 0x05
     29a:	04 c0       	rjmp	.+8      	; 0x2a4 <set_ampGain+0x32>
	else {PORTA.OUTCLR = PIN6_bm;}
     29c:	80 e4       	ldi	r24, 0x40	; 64
     29e:	e0 e0       	ldi	r30, 0x00	; 0
     2a0:	f6 e0       	ldi	r31, 0x06	; 6
     2a2:	86 83       	std	Z+6, r24	; 0x06
	// set bit A1
	if(gainExponent & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
     2a4:	c1 ff       	sbrs	r28, 1
     2a6:	05 c0       	rjmp	.+10     	; 0x2b2 <set_ampGain+0x40>
     2a8:	82 e0       	ldi	r24, 0x02	; 2
     2aa:	e0 e2       	ldi	r30, 0x20	; 32
     2ac:	f6 e0       	ldi	r31, 0x06	; 6
     2ae:	85 83       	std	Z+5, r24	; 0x05
     2b0:	04 c0       	rjmp	.+8      	; 0x2ba <set_ampGain+0x48>
	else {PORTB.OUTCLR = PIN1_bm;}
     2b2:	82 e0       	ldi	r24, 0x02	; 2
     2b4:	e0 e2       	ldi	r30, 0x20	; 32
     2b6:	f6 e0       	ldi	r31, 0x06	; 6
     2b8:	86 83       	std	Z+6, r24	; 0x06
	// set bit A2
	if(gainExponent & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
     2ba:	c2 ff       	sbrs	r28, 2
     2bc:	05 c0       	rjmp	.+10     	; 0x2c8 <set_ampGain+0x56>
     2be:	84 e0       	ldi	r24, 0x04	; 4
     2c0:	e0 e2       	ldi	r30, 0x20	; 32
     2c2:	f6 e0       	ldi	r31, 0x06	; 6
     2c4:	85 83       	std	Z+5, r24	; 0x05
     2c6:	04 c0       	rjmp	.+8      	; 0x2d0 <set_ampGain+0x5e>
	else {PORTB.OUTCLR = PIN2_bm;}
     2c8:	84 e0       	ldi	r24, 0x04	; 4
     2ca:	e0 e2       	ldi	r30, 0x20	; 32
     2cc:	f6 e0       	ldi	r31, 0x06	; 6
     2ce:	86 83       	std	Z+6, r24	; 0x06
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     2d0:	5a e0       	ldi	r21, 0x0A	; 10
     2d2:	5a 95       	dec	r21
     2d4:	f1 f7       	brne	.-4      	; 0x2d2 <set_ampGain+0x60>
     2d6:	00 c0       	rjmp	.+0      	; 0x2d8 <set_ampGain+0x66>

	_delay_us(1);

	PortEx_OUTSET(0xFF, PS_BANKA);	// write protect all AD8231 amps
     2d8:	8f ef       	ldi	r24, 0xFF	; 255
     2da:	61 e0       	ldi	r22, 0x01	; 1
     2dc:	0e 94 8d 1b 	call	0x371a	; 0x371a <PortEx_OUTSET>
	//setPortEx(0xFF, PS_BANKA);

}
     2e0:	cf 91       	pop	r28
     2e2:	08 95       	ret

000002e4 <set_filter>:
 *	filterConfig[2]	Channel 3 and 7 mask
 *	filterConfig[3]	Channel 4 and 8 mask
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
*/
void set_filter(uint8_t filterConfig) {
     2e4:	cf 93       	push	r28
     2e6:	df 93       	push	r29
	// hack to get ADC to work
	//filterConfig |= 0x0F;

	// boolean flags for upper/lower channels CS
	uint8_t lowerCS = filterConfig & 0x03; 
     2e8:	c8 2f       	mov	r28, r24
     2ea:	c3 70       	andi	r28, 0x03	; 3
	uint8_t upperCS = filterConfig & 0x0C;
     2ec:	d8 2f       	mov	r29, r24
     2ee:	dc 70       	andi	r29, 0x0C	; 12

	// update left and right channel status
	if (filterConfig & (BIT0_bm | BIT2_bm)) channelStatus = 
     2f0:	28 2f       	mov	r18, r24
     2f2:	30 e0       	ldi	r19, 0x00	; 0
     2f4:	a9 01       	movw	r20, r18
     2f6:	45 70       	andi	r20, 0x05	; 5
     2f8:	50 70       	andi	r21, 0x00	; 0
     2fa:	41 15       	cp	r20, r1
     2fc:	51 05       	cpc	r21, r1
     2fe:	49 f0       	breq	.+18     	; 0x312 <set_filter+0x2e>
     300:	90 91 5d 50 	lds	r25, 0x505D
     304:	48 2f       	mov	r20, r24
     306:	42 95       	swap	r20
     308:	4f 70       	andi	r20, 0x0F	; 15
     30a:	90 7f       	andi	r25, 0xF0	; 240
     30c:	94 2b       	or	r25, r20
     30e:	90 93 5d 50 	sts	0x505D, r25
		(0xF0 & channelStatus) | (filterConfig >> 4);  //right
	if (filterConfig & (BIT1_bm | BIT3_bm)) channelStatus =
     312:	2a 70       	andi	r18, 0x0A	; 10
     314:	30 70       	andi	r19, 0x00	; 0
     316:	21 15       	cp	r18, r1
     318:	31 05       	cpc	r19, r1
     31a:	39 f0       	breq	.+14     	; 0x32a <set_filter+0x46>
     31c:	90 91 5d 50 	lds	r25, 0x505D
     320:	80 7f       	andi	r24, 0xF0	; 240
     322:	9f 70       	andi	r25, 0x0F	; 15
     324:	89 2b       	or	r24, r25
     326:	80 93 5d 50 	sts	0x505D, r24
		(0xF0 & filterConfig) | (0x0F & channelStatus); //left
		
	SPIInit(SPI_MODE_1_gc);
     32a:	84 e0       	ldi	r24, 0x04	; 4
     32c:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>

	
	SPIBuffer[0] = channelStatus;
     330:	80 91 5d 50 	lds	r24, 0x505D
     334:	80 93 47 50 	sts	0x5047, r24
	
	// enable appropriate chip select
	if (lowerCS) lowerMuxCS(TRUE);
     338:	cc 23       	and	r28, r28
     33a:	19 f0       	breq	.+6      	; 0x342 <set_filter+0x5e>
     33c:	81 e0       	ldi	r24, 0x01	; 1
     33e:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <lowerMuxCS>
	if (upperCS) upperMuxCS(TRUE);
     342:	dd 23       	and	r29, r29
     344:	19 f0       	breq	.+6      	; 0x34c <set_filter+0x68>
     346:	81 e0       	ldi	r24, 0x01	; 1
     348:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <upperMuxCS>

	SPICS(TRUE);
     34c:	81 e0       	ldi	r24, 0x01	; 1
     34e:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>

	// Send all logic high to ensure that the SDO line on the chip is
	// left in high Z state after SPI transaction.
	// The t-1 SDI transaction is output on the SDO and the pin left in the configuration.
	// of the last bit
	SPIC.DATA = 0xFF;
     352:	8f ef       	ldi	r24, 0xFF	; 255
     354:	e0 ec       	ldi	r30, 0xC0	; 192
     356:	f8 e0       	ldi	r31, 0x08	; 8
     358:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     35a:	82 81       	ldd	r24, Z+2	; 0x02
     35c:	88 23       	and	r24, r24
     35e:	ec f7       	brge	.-6      	; 0x35a <set_filter+0x76>
	SPIBuffer[12] = SPIC.DATA;
     360:	e0 ec       	ldi	r30, 0xC0	; 192
     362:	f8 e0       	ldi	r31, 0x08	; 8
     364:	83 81       	ldd	r24, Z+3	; 0x03
     366:	80 93 53 50 	sts	0x5053, r24

	nop();
     36a:	00 00       	nop

	SPIC.DATA = SPIBuffer[0];
     36c:	a3 e5       	ldi	r26, 0x53	; 83
     36e:	b0 e5       	ldi	r27, 0x50	; 80
     370:	1c 97       	sbiw	r26, 0x0c	; 12
     372:	8c 91       	ld	r24, X
     374:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     376:	82 81       	ldd	r24, Z+2	; 0x02
     378:	88 23       	and	r24, r24
     37a:	ec f7       	brge	.-6      	; 0x376 <set_filter+0x92>
	SPIBuffer[12] = SPIC.DATA;
     37c:	e0 ec       	ldi	r30, 0xC0	; 192
     37e:	f8 e0       	ldi	r31, 0x08	; 8
     380:	83 81       	ldd	r24, Z+3	; 0x03
     382:	80 93 53 50 	sts	0x5053, r24
	SPICS(FALSE);
     386:	80 e0       	ldi	r24, 0x00	; 0
     388:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>

	if (lowerCS) lowerMuxCS(FALSE);
     38c:	cc 23       	and	r28, r28
     38e:	19 f0       	breq	.+6      	; 0x396 <set_filter+0xb2>
     390:	80 e0       	ldi	r24, 0x00	; 0
     392:	0e 94 e5 1a 	call	0x35ca	; 0x35ca <lowerMuxCS>
	if (upperCS) upperMuxCS(FALSE);
     396:	dd 23       	and	r29, r29
     398:	19 f0       	breq	.+6      	; 0x3a0 <set_filter+0xbc>
     39a:	80 e0       	ldi	r24, 0x00	; 0
     39c:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <upperMuxCS>
	SPIDisable();
     3a0:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>
}
     3a4:	df 91       	pop	r29
     3a6:	cf 91       	pop	r28
     3a8:	08 95       	ret

000003aa <ADCPower>:
	*avgV = (average * 1000 / 4095) - 50;
	*maxV = (max * 1000 / 4095) - 50;
	*minV = (min * 1000  / 4095) - 50;
}

void ADCPower(uint8_t on) {
     3aa:	0f 93       	push	r16
     3ac:	1f 93       	push	r17
     3ae:	cf 93       	push	r28
     3b0:	df 93       	push	r29
	if (on) {
     3b2:	88 23       	and	r24, r24
     3b4:	09 f4       	brne	.+2      	; 0x3b8 <ADCPower+0xe>
     3b6:	46 c0       	rjmp	.+140    	; 0x444 <ADCPower+0x9a>
		PORTA.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and HV1/HV2 and A0
     3b8:	00 e0       	ldi	r16, 0x00	; 0
     3ba:	16 e0       	ldi	r17, 0x06	; 6
     3bc:	8e ed       	ldi	r24, 0xDE	; 222
     3be:	d8 01       	movw	r26, r16
     3c0:	11 96       	adiw	r26, 0x01	; 1
     3c2:	8c 93       	st	X, r24
		PORTB.DIRSET = PIN1_bm| PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     3c4:	c0 e2       	ldi	r28, 0x20	; 32
     3c6:	d6 e0       	ldi	r29, 0x06	; 6
     3c8:	4e e0       	ldi	r20, 0x0E	; 14
     3ca:	49 83       	std	Y+1, r20	; 0x01
		PORTC.DIRSET = PIN0_bm | PIN1_bm;// VDCA and VDC-2 and MUX-SYNC1
     3cc:	e0 e4       	ldi	r30, 0x40	; 64
     3ce:	f6 e0       	ldi	r31, 0x06	; 6
     3d0:	63 e0       	ldi	r22, 0x03	; 3
     3d2:	61 83       	std	Z+1, r22	; 0x01
		PORTE.DIRSET = PIN4_bm; // MUX-SYNC2
     3d4:	80 e8       	ldi	r24, 0x80	; 128
     3d6:	96 e0       	ldi	r25, 0x06	; 6
     3d8:	50 e1       	ldi	r21, 0x10	; 16
     3da:	dc 01       	movw	r26, r24
     3dc:	11 96       	adiw	r26, 0x01	; 1
     3de:	5c 93       	st	X, r21
		PORTF.DIRSET = PIN1_bm | PIN2_bm | PIN3_bm; // DAC LDAC and CS
     3e0:	20 ea       	ldi	r18, 0xA0	; 160
     3e2:	36 e0       	ldi	r19, 0x06	; 6
     3e4:	d9 01       	movw	r26, r18
     3e6:	11 96       	adiw	r26, 0x01	; 1
     3e8:	4c 93       	st	X, r20

		// high signal to write protect
		PORTA.OUTSET = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm;; // portEx-CS
     3ea:	7e e9       	ldi	r23, 0x9E	; 158
     3ec:	d8 01       	movw	r26, r16
     3ee:	15 96       	adiw	r26, 0x05	; 5
     3f0:	7c 93       	st	X, r23
		PORTB.OUTSET = PIN3_bm; // FRAM-CS
     3f2:	78 e0       	ldi	r23, 0x08	; 8
     3f4:	7d 83       	std	Y+5, r23	; 0x05
		PORTC.OUTSET = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     3f6:	65 83       	std	Z+5, r22	; 0x05
		PORTE.OUTSET = PIN4_bm; // MUX-SYNC2
     3f8:	ec 01       	movw	r28, r24
     3fa:	5d 83       	std	Y+5, r21	; 0x05
		PORTF.OUTSET = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     3fc:	d9 01       	movw	r26, r18
     3fe:	15 96       	adiw	r26, 0x05	; 5
     400:	4c 93       	st	X, r20
		channelStatus = 0x00; // POR to zeros
     402:	10 92 5d 50 	sts	0x505D, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     406:	8f ef       	ldi	r24, 0xFF	; 255
     408:	97 e8       	ldi	r25, 0x87	; 135
     40a:	a3 e1       	ldi	r26, 0x13	; 19
     40c:	81 50       	subi	r24, 0x01	; 1
     40e:	90 40       	sbci	r25, 0x00	; 0
     410:	a0 40       	sbci	r26, 0x00	; 0
     412:	e1 f7       	brne	.-8      	; 0x40c <ADCPower+0x62>
     414:	00 c0       	rjmp	.+0      	; 0x416 <ADCPower+0x6c>
     416:	00 00       	nop
		_delay_ms(200);

		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     418:	80 e4       	ldi	r24, 0x40	; 64
     41a:	82 83       	std	Z+2, r24	; 0x02
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     41c:	10 92 5e 50 	sts	0x505E, r1
     420:	10 92 b0 50 	sts	0x50B0, r1
     424:	10 92 b9 23 	sts	0x23B9, r1
     428:	10 92 56 50 	sts	0x5056, r1
		PortEx_DIRSET(0xFF, PS_BANKA);
     42c:	8f ef       	ldi	r24, 0xFF	; 255
     42e:	61 e0       	ldi	r22, 0x01	; 1
     430:	0e 94 3a 1c 	call	0x3874	; 0x3874 <PortEx_DIRSET>
		PortEx_OUTSET(0xFF, PS_BANKA);  //write protect IN-AMP 1 thru 8
     434:	8f ef       	ldi	r24, 0xFF	; 255
     436:	61 e0       	ldi	r22, 0x01	; 1
     438:	0e 94 8d 1b 	call	0x371a	; 0x371a <PortEx_OUTSET>
		//setPortEx(0xFF, PS_BANKA);
		set_filter(0xFF);  // set filters initially to ensure data out pulled high
     43c:	8f ef       	ldi	r24, 0xFF	; 255
     43e:	0e 94 72 01 	call	0x2e4	; 0x2e4 <set_filter>
     442:	32 c0       	rjmp	.+100    	; 0x4a8 <ADCPower+0xfe>

	} else {
		// low signal for low power
		PORTA.OUTCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN6_bm | PIN7_bm; // portEx-CS and A0
     444:	00 e0       	ldi	r16, 0x00	; 0
     446:	16 e0       	ldi	r17, 0x06	; 6
     448:	7e ed       	ldi	r23, 0xDE	; 222
     44a:	d8 01       	movw	r26, r16
     44c:	16 96       	adiw	r26, 0x06	; 6
     44e:	7c 93       	st	X, r23
		PORTB.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm; // FRAM-CS and A1/A2
     450:	a0 e2       	ldi	r26, 0x20	; 32
     452:	b6 e0       	ldi	r27, 0x06	; 6
     454:	4e e0       	ldi	r20, 0x0E	; 14
     456:	16 96       	adiw	r26, 0x06	; 6
     458:	4c 93       	st	X, r20
     45a:	16 97       	sbiw	r26, 0x06	; 6
		PORTC.OUTCLR = PIN0_bm | PIN1_bm; // VDCA and VDC-2 on and MUX-SYNC1
     45c:	20 e4       	ldi	r18, 0x40	; 64
     45e:	36 e0       	ldi	r19, 0x06	; 6
     460:	63 e0       	ldi	r22, 0x03	; 3
     462:	e9 01       	movw	r28, r18
     464:	6e 83       	std	Y+6, r22	; 0x06
		PORTE.OUTCLR = PIN4_bm; // MUX-SYNC2
     466:	c0 e8       	ldi	r28, 0x80	; 128
     468:	d6 e0       	ldi	r29, 0x06	; 6
     46a:	50 e1       	ldi	r21, 0x10	; 16
     46c:	5e 83       	std	Y+6, r21	; 0x06
		PORTF.OUTCLR = PIN1_bm | PIN2_bm | PIN3_bm;  // ADC-CS and DAC write/latch
     46e:	80 ea       	ldi	r24, 0xA0	; 160
     470:	96 e0       	ldi	r25, 0x06	; 6
     472:	fc 01       	movw	r30, r24
     474:	46 83       	std	Z+6, r20	; 0x06


		PORTA.DIRCLR = PIN1_bm| PIN2_bm | PIN3_bm | PIN4_bm | PIN7_bm | PIN6_bm;
     476:	f8 01       	movw	r30, r16
     478:	72 83       	std	Z+2, r23	; 0x02
		PORTB.DIRCLR = PIN1_bm | PIN2_bm| PIN3_bm;
     47a:	12 96       	adiw	r26, 0x02	; 2
     47c:	4c 93       	st	X, r20
		PORTC.DIRCLR = PIN0_bm | PIN1_bm;
     47e:	d9 01       	movw	r26, r18
     480:	12 96       	adiw	r26, 0x02	; 2
     482:	6c 93       	st	X, r22
     484:	12 97       	sbiw	r26, 0x02	; 2
		PORTE.DIRCLR = PIN4_bm;
     486:	5a 83       	std	Y+2, r21	; 0x02
		PORTF.DIRCLR = PIN1_bm | PIN2_bm | PIN3_bm;
     488:	ec 01       	movw	r28, r24
     48a:	4a 83       	std	Y+2, r20	; 0x02
		
		// set SPI-MISO as input
		PORTC.DIRCLR = PIN6_bm;
     48c:	80 e4       	ldi	r24, 0x40	; 64
     48e:	12 96       	adiw	r26, 0x02	; 2
     490:	8c 93       	st	X, r24
     492:	12 97       	sbiw	r26, 0x02	; 2
		
		
		bankA_DIR = bankA_OUT = bankB_DIR = bankB_OUT = 0x00; // all pins input on reset
     494:	10 92 5e 50 	sts	0x505E, r1
     498:	10 92 b0 50 	sts	0x50B0, r1
     49c:	10 92 b9 23 	sts	0x23B9, r1
     4a0:	10 92 56 50 	sts	0x5056, r1
		channelStatus = 0x00;
     4a4:	10 92 5d 50 	sts	0x505D, r1
		
	}
}
     4a8:	df 91       	pop	r29
     4aa:	cf 91       	pop	r28
     4ac:	1f 91       	pop	r17
     4ae:	0f 91       	pop	r16
     4b0:	08 95       	ret

000004b2 <CO_collectBatt>:
	*avgV = (average * 1000 / 4095) - 50;
	*maxV = (max * 1000 / 4095) - 50;
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     4b2:	4f 92       	push	r4
     4b4:	5f 92       	push	r5
     4b6:	6f 92       	push	r6
     4b8:	7f 92       	push	r7
     4ba:	8f 92       	push	r8
     4bc:	9f 92       	push	r9
     4be:	af 92       	push	r10
     4c0:	bf 92       	push	r11
     4c2:	ef 92       	push	r14
     4c4:	ff 92       	push	r15
     4c6:	0f 93       	push	r16
     4c8:	1f 93       	push	r17
     4ca:	cf 93       	push	r28
     4cc:	df 93       	push	r29
     4ce:	cd b7       	in	r28, 0x3d	; 61
     4d0:	de b7       	in	r29, 0x3e	; 62
     4d2:	2b 97       	sbiw	r28, 0x0b	; 11
     4d4:	cd bf       	out	0x3d, r28	; 61
     4d6:	de bf       	out	0x3e, r29	; 62
     4d8:	8e 83       	std	Y+6, r24	; 0x06
     4da:	9f 83       	std	Y+7, r25	; 0x07
     4dc:	68 87       	std	Y+8, r22	; 0x08
     4de:	79 87       	std	Y+9, r23	; 0x09
     4e0:	4a 87       	std	Y+10, r20	; 0x0a
     4e2:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
     4e4:	81 e0       	ldi	r24, 0x01	; 1
     4e6:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
	PortEx_DIRSET(BIT2_bm, PS_BANKB);
     4ea:	84 e0       	ldi	r24, 0x04	; 4
     4ec:	60 e0       	ldi	r22, 0x00	; 0
     4ee:	0e 94 3a 1c 	call	0x3874	; 0x3874 <PortEx_DIRSET>
	PortEx_OUTSET(BIT2_bm, PS_BANKB); // activate PIO24 (VBATT)
     4f2:	84 e0       	ldi	r24, 0x04	; 4
     4f4:	60 e0       	ldi	r22, 0x00	; 0
     4f6:	0e 94 8d 1b 	call	0x371a	; 0x371a <PortEx_OUTSET>
     4fa:	2f ef       	ldi	r18, 0xFF	; 255
     4fc:	33 ec       	ldi	r19, 0xC3	; 195
     4fe:	49 e0       	ldi	r20, 0x09	; 9
     500:	21 50       	subi	r18, 0x01	; 1
     502:	30 40       	sbci	r19, 0x00	; 0
     504:	40 40       	sbci	r20, 0x00	; 0
     506:	e1 f7       	brne	.-8      	; 0x500 <CO_collectBatt+0x4e>
     508:	00 c0       	rjmp	.+0      	; 0x50a <CO_collectBatt+0x58>
     50a:	00 00       	nop
	_delay_ms(100);
	//setPortEx(BIT2_bm, PS_BANKB);
		
	/* Move stored calibration values to ADCB. */
	ADC_CalibrationValues_Load(&ADCB);
     50c:	80 e4       	ldi	r24, 0x40	; 64
     50e:	92 e0       	ldi	r25, 0x02	; 2
     510:	0e 94 67 13 	call	0x26ce	; 0x26ce <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCB, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     514:	00 e4       	ldi	r16, 0x40	; 64
     516:	12 e0       	ldi	r17, 0x02	; 2
     518:	d8 01       	movw	r26, r16
     51a:	11 96       	adiw	r26, 0x01	; 1
     51c:	8c 91       	ld	r24, X
     51e:	11 97       	sbiw	r26, 0x01	; 1
     520:	89 7e       	andi	r24, 0xE9	; 233
     522:	11 96       	adiw	r26, 0x01	; 1
     524:	8c 93       	st	X, r24
     526:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCB, ADC_PRESCALER_DIV32_gc);
     528:	14 96       	adiw	r26, 0x04	; 4
     52a:	8c 91       	ld	r24, X
     52c:	14 97       	sbiw	r26, 0x04	; 4
     52e:	88 7f       	andi	r24, 0xF8	; 248
     530:	83 60       	ori	r24, 0x03	; 3
     532:	14 96       	adiw	r26, 0x04	; 4
     534:	8c 93       	st	X, r24
     536:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCB to be 1.0 V.*/
	ADC_Reference_Config(&ADCB, ADC_REFSEL_INT1V_gc); 
     538:	12 96       	adiw	r26, 0x02	; 2
     53a:	8c 91       	ld	r24, X
     53c:	12 97       	sbiw	r26, 0x02	; 2
     53e:	8f 7c       	andi	r24, 0xCF	; 207
     540:	12 96       	adiw	r26, 0x02	; 2
     542:	8c 93       	st	X, r24
     544:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCB.CH0,
     546:	0f 2e       	mov	r0, r31
     548:	f0 e6       	ldi	r31, 0x60	; 96
     54a:	ef 2e       	mov	r14, r31
     54c:	f2 e0       	ldi	r31, 0x02	; 2
     54e:	ff 2e       	mov	r15, r31
     550:	f0 2d       	mov	r31, r0
     552:	f7 01       	movw	r30, r14
     554:	80 81       	ld	r24, Z
     556:	80 7e       	andi	r24, 0xE0	; 224
     558:	81 60       	ori	r24, 0x01	; 1
     55a:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	// Get offset value for ADCB.
   	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     55c:	89 e0       	ldi	r24, 0x09	; 9
     55e:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCB);
     560:	8c 91       	ld	r24, X
     562:	81 60       	ori	r24, 0x01	; 1
     564:	8c 93       	st	X, r24
	// Wait until common mode voltage is stable. Default clk is 16MHz
	ADC_Wait_32MHz(&ADCB);
     566:	80 e4       	ldi	r24, 0x40	; 64
     568:	92 e0       	ldi	r25, 0x02	; 2
     56a:	0e 94 ec 12 	call	0x25d8	; 0x25d8 <ADC_Wait_32MHz>
	offset = ADC_Offset_Get_Unsigned(&ADCB, &ADCB.CH0, false);
     56e:	80 e4       	ldi	r24, 0x40	; 64
     570:	92 e0       	ldi	r25, 0x02	; 2
     572:	60 e6       	ldi	r22, 0x60	; 96
     574:	72 e0       	ldi	r23, 0x02	; 2
     576:	40 e0       	ldi	r20, 0x00	; 0
     578:	0e 94 f6 12 	call	0x25ec	; 0x25ec <ADC_Offset_Get_Unsigned>
     57c:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCB);
     57e:	d8 01       	movw	r26, r16
     580:	8c 91       	ld	r24, X
     582:	8e 7f       	andi	r24, 0xFE	; 254
     584:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADC B */
	ADC_Ch_InputMux_Config(&ADCB.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     586:	f7 01       	movw	r30, r14
     588:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCB, ADC_SWEEP_0_gc);
     58a:	13 96       	adiw	r26, 0x03	; 3
     58c:	8c 91       	ld	r24, X
     58e:	13 97       	sbiw	r26, 0x03	; 3
     590:	8f 73       	andi	r24, 0x3F	; 63
     592:	13 96       	adiw	r26, 0x03	; 3
     594:	8c 93       	st	X, r24
     596:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCB);
     598:	8c 91       	ld	r24, X
     59a:	81 60       	ori	r24, 0x01	; 1
     59c:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCB);
     59e:	80 e4       	ldi	r24, 0x40	; 64
     5a0:	92 e0       	ldi	r25, 0x02	; 2
     5a2:	0e 94 ec 12 	call	0x25d8	; 0x25d8 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);
     5a6:	d8 01       	movw	r26, r16
     5a8:	11 96       	adiw	r26, 0x01	; 1
     5aa:	8c 91       	ld	r24, X
     5ac:	11 97       	sbiw	r26, 0x01	; 1
     5ae:	88 60       	ori	r24, 0x08	; 8
     5b0:	11 96       	adiw	r26, 0x01	; 1
     5b2:	8c 93       	st	X, r24
     5b4:	ee 24       	eor	r14, r14
     5b6:	ff 24       	eor	r15, r15
     5b8:	68 94       	set
     5ba:	f2 f8       	bld	r15, 2
void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
     5bc:	44 24       	eor	r4, r4
     5be:	55 24       	eor	r5, r5
     5c0:	32 01       	movw	r6, r4

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	uint32_t sum = 0;
	uint16_t tempResultB;
	uint32_t average;
	uint32_t min = 4096;
     5c2:	20 e0       	ldi	r18, 0x00	; 0
     5c4:	30 e1       	ldi	r19, 0x10	; 16
     5c6:	40 e0       	ldi	r20, 0x00	; 0
     5c8:	50 e0       	ldi	r21, 0x00	; 0
     5ca:	2a 83       	std	Y+2, r18	; 0x02
     5cc:	3b 83       	std	Y+3, r19	; 0x03
     5ce:	4c 83       	std	Y+4, r20	; 0x04
     5d0:	5d 83       	std	Y+5, r21	; 0x05
	*maxV = (max * 1000 / 4095) - 50;
	*minV = (min * 1000  / 4095) - 50;
}

void CO_collectBatt(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	uint32_t sum = 0;
     5d2:	88 24       	eor	r8, r8
     5d4:	99 24       	eor	r9, r9
     5d6:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCB channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCB.CH0));
     5d8:	00 e6       	ldi	r16, 0x60	; 96
     5da:	12 e0       	ldi	r17, 0x02	; 2
     5dc:	d8 01       	movw	r26, r16
     5de:	13 96       	adiw	r26, 0x03	; 3
     5e0:	8c 91       	ld	r24, X
     5e2:	13 97       	sbiw	r26, 0x03	; 3
     5e4:	80 ff       	sbrs	r24, 0
     5e6:	fa cf       	rjmp	.-12     	; 0x5dc <CO_collectBatt+0x12a>
		tempResultB = ADC_ResultCh_GetWord_Signed(&ADCB.CH0, offset);
     5e8:	69 81       	ldd	r22, Y+1	; 0x01
     5ea:	c8 01       	movw	r24, r16
     5ec:	0e 94 c8 12 	call	0x2590	; 0x2590 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResultB;
     5f0:	a0 e0       	ldi	r26, 0x00	; 0
     5f2:	b0 e0       	ldi	r27, 0x00	; 0
     5f4:	88 0e       	add	r8, r24
     5f6:	99 1e       	adc	r9, r25
     5f8:	aa 1e       	adc	r10, r26
     5fa:	bb 1e       	adc	r11, r27
     5fc:	48 16       	cp	r4, r24
     5fe:	59 06       	cpc	r5, r25
     600:	6a 06       	cpc	r6, r26
     602:	7b 06       	cpc	r7, r27
     604:	10 f4       	brcc	.+4      	; 0x60a <CO_collectBatt+0x158>
     606:	2c 01       	movw	r4, r24
     608:	3d 01       	movw	r6, r26
     60a:	2a 81       	ldd	r18, Y+2	; 0x02
     60c:	3b 81       	ldd	r19, Y+3	; 0x03
     60e:	4c 81       	ldd	r20, Y+4	; 0x04
     610:	5d 81       	ldd	r21, Y+5	; 0x05
     612:	82 17       	cp	r24, r18
     614:	93 07       	cpc	r25, r19
     616:	a4 07       	cpc	r26, r20
     618:	b5 07       	cpc	r27, r21
     61a:	20 f4       	brcc	.+8      	; 0x624 <CO_collectBatt+0x172>
     61c:	8a 83       	std	Y+2, r24	; 0x02
     61e:	9b 83       	std	Y+3, r25	; 0x03
     620:	ac 83       	std	Y+4, r26	; 0x04
     622:	bd 83       	std	Y+5, r27	; 0x05
     624:	08 94       	sec
     626:	e1 08       	sbc	r14, r1
     628:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCB);

	/* Store samples.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     62a:	e1 14       	cp	r14, r1
     62c:	f1 04       	cpc	r15, r1
     62e:	b1 f6       	brne	.-84     	; 0x5dc <CO_collectBatt+0x12a>
		if (min > tempResultB) { min = tempResultB;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
     630:	e0 e4       	ldi	r30, 0x40	; 64
     632:	f2 e0       	ldi	r31, 0x02	; 2
     634:	81 81       	ldd	r24, Z+1	; 0x01
     636:	87 7f       	andi	r24, 0xF7	; 247
     638:	81 83       	std	Z+1, r24	; 0x01
	ADC_Disable(&ADCB);
     63a:	80 81       	ld	r24, Z
     63c:	8e 7f       	andi	r24, 0xFE	; 254
     63e:	80 83       	st	Z, r24

	average = sum / NUM_SAMPLES;
	
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
     640:	84 e0       	ldi	r24, 0x04	; 4
     642:	60 e0       	ldi	r22, 0x00	; 0
     644:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <PortEx_DIRCLR>
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);
     648:	80 e0       	ldi	r24, 0x00	; 0
     64a:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCB);
	ADC_Disable(&ADCB);

	average = sum / NUM_SAMPLES;
     64e:	c5 01       	movw	r24, r10
     650:	b4 01       	movw	r22, r8
     652:	05 2e       	mov	r0, r21
     654:	5a e0       	ldi	r21, 0x0A	; 10
     656:	96 95       	lsr	r25
     658:	87 95       	ror	r24
     65a:	77 95       	ror	r23
     65c:	67 95       	ror	r22
     65e:	5a 95       	dec	r21
     660:	d1 f7       	brne	.-12     	; 0x656 <CO_collectBatt+0x1a4>
     662:	50 2d       	mov	r21, r0
	PortEx_DIRCLR(BIT2_bm, PS_BANKB);  // deactivate PIO24 (VBATT)
	//setPortEx(0x00, PS_BANKB);
  	ADCPower(FALSE);

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     664:	28 ee       	ldi	r18, 0xE8	; 232
     666:	33 e0       	ldi	r19, 0x03	; 3
     668:	40 e0       	ldi	r20, 0x00	; 0
     66a:	50 e0       	ldi	r21, 0x00	; 0
     66c:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
     670:	0f 2e       	mov	r0, r31
     672:	ff ef       	ldi	r31, 0xFF	; 255
     674:	8f 2e       	mov	r8, r31
     676:	ff e0       	ldi	r31, 0x0F	; 15
     678:	9f 2e       	mov	r9, r31
     67a:	f0 e0       	ldi	r31, 0x00	; 0
     67c:	af 2e       	mov	r10, r31
     67e:	f0 e0       	ldi	r31, 0x00	; 0
     680:	bf 2e       	mov	r11, r31
     682:	f0 2d       	mov	r31, r0
     684:	a5 01       	movw	r20, r10
     686:	94 01       	movw	r18, r8
     688:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
     68c:	c9 01       	movw	r24, r18
     68e:	c2 97       	sbiw	r24, 0x32	; 50
     690:	ae 81       	ldd	r26, Y+6	; 0x06
     692:	bf 81       	ldd	r27, Y+7	; 0x07
     694:	8d 93       	st	X+, r24
     696:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
     698:	c3 01       	movw	r24, r6
     69a:	b2 01       	movw	r22, r4
     69c:	28 ee       	ldi	r18, 0xE8	; 232
     69e:	33 e0       	ldi	r19, 0x03	; 3
     6a0:	40 e0       	ldi	r20, 0x00	; 0
     6a2:	50 e0       	ldi	r21, 0x00	; 0
     6a4:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
     6a8:	a5 01       	movw	r20, r10
     6aa:	94 01       	movw	r18, r8
     6ac:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
     6b0:	c9 01       	movw	r24, r18
     6b2:	c2 97       	sbiw	r24, 0x32	; 50
     6b4:	ea 85       	ldd	r30, Y+10	; 0x0a
     6b6:	fb 85       	ldd	r31, Y+11	; 0x0b
     6b8:	80 83       	st	Z, r24
     6ba:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     6bc:	6a 81       	ldd	r22, Y+2	; 0x02
     6be:	7b 81       	ldd	r23, Y+3	; 0x03
     6c0:	8c 81       	ldd	r24, Y+4	; 0x04
     6c2:	9d 81       	ldd	r25, Y+5	; 0x05
     6c4:	28 ee       	ldi	r18, 0xE8	; 232
     6c6:	33 e0       	ldi	r19, 0x03	; 3
     6c8:	40 e0       	ldi	r20, 0x00	; 0
     6ca:	50 e0       	ldi	r21, 0x00	; 0
     6cc:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
     6d0:	a5 01       	movw	r20, r10
     6d2:	94 01       	movw	r18, r8
     6d4:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
     6d8:	22 53       	subi	r18, 0x32	; 50
     6da:	30 40       	sbci	r19, 0x00	; 0
     6dc:	a8 85       	ldd	r26, Y+8	; 0x08
     6de:	b9 85       	ldd	r27, Y+9	; 0x09
     6e0:	2d 93       	st	X+, r18
     6e2:	3c 93       	st	X, r19
     6e4:	11 97       	sbiw	r26, 0x01	; 1
}
     6e6:	2b 96       	adiw	r28, 0x0b	; 11
     6e8:	cd bf       	out	0x3d, r28	; 61
     6ea:	de bf       	out	0x3e, r29	; 62
     6ec:	df 91       	pop	r29
     6ee:	cf 91       	pop	r28
     6f0:	1f 91       	pop	r17
     6f2:	0f 91       	pop	r16
     6f4:	ff 90       	pop	r15
     6f6:	ef 90       	pop	r14
     6f8:	bf 90       	pop	r11
     6fa:	af 90       	pop	r10
     6fc:	9f 90       	pop	r9
     6fe:	8f 90       	pop	r8
     700:	7f 90       	pop	r7
     702:	6f 90       	pop	r6
     704:	5f 90       	pop	r5
     706:	4f 90       	pop	r4
     708:	08 95       	ret

0000070a <CO_collectTemp>:

volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test
volatile uint8_t newFile[15] = {'n','e','w','F','I','L','E','.',' ',' ',' ',' ',' ',' ',' '}; //must be no more than 8 letters before the extension "." 

void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
     70a:	4f 92       	push	r4
     70c:	5f 92       	push	r5
     70e:	6f 92       	push	r6
     710:	7f 92       	push	r7
     712:	8f 92       	push	r8
     714:	9f 92       	push	r9
     716:	af 92       	push	r10
     718:	bf 92       	push	r11
     71a:	ef 92       	push	r14
     71c:	ff 92       	push	r15
     71e:	0f 93       	push	r16
     720:	1f 93       	push	r17
     722:	cf 93       	push	r28
     724:	df 93       	push	r29
     726:	cd b7       	in	r28, 0x3d	; 61
     728:	de b7       	in	r29, 0x3e	; 62
     72a:	2b 97       	sbiw	r28, 0x0b	; 11
     72c:	cd bf       	out	0x3d, r28	; 61
     72e:	de bf       	out	0x3e, r29	; 62
     730:	8e 83       	std	Y+6, r24	; 0x06
     732:	9f 83       	std	Y+7, r25	; 0x07
     734:	68 87       	std	Y+8, r22	; 0x08
     736:	79 87       	std	Y+9, r23	; 0x09
     738:	4a 87       	std	Y+10, r20	; 0x0a
     73a:	5b 87       	std	Y+11, r21	; 0x0b
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
	volatile int8_t offset;	

	ADCPower(TRUE);
     73c:	81 e0       	ldi	r24, 0x01	; 1
     73e:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>

	/* Move stored calibration values to ADCA. */
	ADC_CalibrationValues_Load(&ADCA);
     742:	80 e0       	ldi	r24, 0x00	; 0
     744:	92 e0       	ldi	r25, 0x02	; 2
     746:	0e 94 67 13 	call	0x26ce	; 0x26ce <ADC_CalibrationValues_Load>

	/* Set up ADC A to have unsigned conversion mode and 12 bit resolution. */
  	ADC_ConvMode_and_Resolution_Config(&ADCA, ADC_ConvMode_Unsigned, ADC_RESOLUTION_12BIT_gc);
     74a:	00 e0       	ldi	r16, 0x00	; 0
     74c:	12 e0       	ldi	r17, 0x02	; 2
     74e:	d8 01       	movw	r26, r16
     750:	11 96       	adiw	r26, 0x01	; 1
     752:	8c 91       	ld	r24, X
     754:	11 97       	sbiw	r26, 0x01	; 1
     756:	89 7e       	andi	r24, 0xE9	; 233
     758:	11 96       	adiw	r26, 0x01	; 1
     75a:	8c 93       	st	X, r24
     75c:	11 97       	sbiw	r26, 0x01	; 1

	/* Set sample rate. */
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV32_gc);
     75e:	14 96       	adiw	r26, 0x04	; 4
     760:	8c 91       	ld	r24, X
     762:	14 97       	sbiw	r26, 0x04	; 4
     764:	88 7f       	andi	r24, 0xF8	; 248
     766:	83 60       	ori	r24, 0x03	; 3
     768:	14 96       	adiw	r26, 0x04	; 4
     76a:	8c 93       	st	X, r24
     76c:	14 97       	sbiw	r26, 0x04	; 4

	/* Set reference voltage on ADCA to be 1.0 V.*/
	ADC_Reference_Config(&ADCA, ADC_REFSEL_INT1V_gc); 
     76e:	12 96       	adiw	r26, 0x02	; 2
     770:	8c 91       	ld	r24, X
     772:	12 97       	sbiw	r26, 0x02	; 2
     774:	8f 7c       	andi	r24, 0xCF	; 207
     776:	12 96       	adiw	r26, 0x02	; 2
     778:	8c 93       	st	X, r24
     77a:	12 97       	sbiw	r26, 0x02	; 2

	/* Setup channel 0, 1, 2 and 3 with different inputs. */
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
     77c:	0f 2e       	mov	r0, r31
     77e:	f0 e2       	ldi	r31, 0x20	; 32
     780:	ef 2e       	mov	r14, r31
     782:	f2 e0       	ldi	r31, 0x02	; 2
     784:	ff 2e       	mov	r15, r31
     786:	f0 2d       	mov	r31, r0
     788:	f7 01       	movw	r30, r14
     78a:	80 81       	ld	r24, Z
     78c:	80 7e       	andi	r24, 0xE0	; 224
     78e:	81 60       	ori	r24, 0x01	; 1
     790:	80 83       	st	Z, r24
	                                 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_DRIVER_CH_GAIN_NONE);

	
	/* Get offset value for ADCA. */
   	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN1_gc, ADC_CH_MUXNEG_PIN1_gc);
     792:	89 e0       	ldi	r24, 0x09	; 9
     794:	81 83       	std	Z+1, r24	; 0x01

	ADC_Enable(&ADCA);
     796:	8c 91       	ld	r24, X
     798:	81 60       	ori	r24, 0x01	; 1
     79a:	8c 93       	st	X, r24
	/* Wait until common mode voltage is stable. Default clk is 16MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     79c:	80 e0       	ldi	r24, 0x00	; 0
     79e:	92 e0       	ldi	r25, 0x02	; 2
     7a0:	0e 94 ec 12 	call	0x25d8	; 0x25d8 <ADC_Wait_32MHz>
 	offset = ADC_Offset_Get_Unsigned(&ADCA, &ADCA.CH0, false);
     7a4:	80 e0       	ldi	r24, 0x00	; 0
     7a6:	92 e0       	ldi	r25, 0x02	; 2
     7a8:	60 e2       	ldi	r22, 0x20	; 32
     7aa:	72 e0       	ldi	r23, 0x02	; 2
     7ac:	40 e0       	ldi	r20, 0x00	; 0
     7ae:	0e 94 f6 12 	call	0x25ec	; 0x25ec <ADC_Offset_Get_Unsigned>
     7b2:	89 83       	std	Y+1, r24	; 0x01
    ADC_Disable(&ADCA);
     7b4:	d8 01       	movw	r26, r16
     7b6:	8c 91       	ld	r24, X
     7b8:	8e 7f       	andi	r24, 0xFE	; 254
     7ba:	8c 93       	st	X, r24
    
	/* Set input to the channels in ADCA */
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN0_gc, 0);
     7bc:	f7 01       	movw	r30, r14
     7be:	11 82       	std	Z+1, r1	; 0x01
	
	/* Setup sweep. */
	ADC_SweepChannels_Config(&ADCA, ADC_SWEEP_0_gc);
     7c0:	13 96       	adiw	r26, 0x03	; 3
     7c2:	8c 91       	ld	r24, X
     7c4:	13 97       	sbiw	r26, 0x03	; 3
     7c6:	8f 73       	andi	r24, 0x3F	; 63
     7c8:	13 96       	adiw	r26, 0x03	; 3
     7ca:	8c 93       	st	X, r24
     7cc:	13 97       	sbiw	r26, 0x03	; 3

	/* Enable ADC .*/
	ADC_Enable(&ADCA);
     7ce:	8c 91       	ld	r24, X
     7d0:	81 60       	ori	r24, 0x01	; 1
     7d2:	8c 93       	st	X, r24

	/* Wait until common mode voltage is stable. Default clk is 2MHz and
	 * therefore below the maximum frequency to use this function. */
	ADC_Wait_32MHz(&ADCA);
     7d4:	80 e0       	ldi	r24, 0x00	; 0
     7d6:	92 e0       	ldi	r25, 0x02	; 2
     7d8:	0e 94 ec 12 	call	0x25d8	; 0x25d8 <ADC_Wait_32MHz>

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);
     7dc:	d8 01       	movw	r26, r16
     7de:	11 96       	adiw	r26, 0x01	; 1
     7e0:	8c 91       	ld	r24, X
     7e2:	11 97       	sbiw	r26, 0x01	; 1
     7e4:	88 60       	ori	r24, 0x08	; 8
     7e6:	11 96       	adiw	r26, 0x01	; 1
     7e8:	8c 93       	st	X, r24
     7ea:	ee 24       	eor	r14, r14
     7ec:	ff 24       	eor	r15, r15
     7ee:	68 94       	set
     7f0:	f2 f8       	bld	r15, 2
void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
	uint32_t max = 0;
     7f2:	44 24       	eor	r4, r4
     7f4:	55 24       	eor	r5, r5
     7f6:	32 01       	movw	r6, r4

void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	uint32_t sum = 0;
	uint16_t tempResult;
	uint32_t average;
	uint32_t min = 4096;
     7f8:	20 e0       	ldi	r18, 0x00	; 0
     7fa:	30 e1       	ldi	r19, 0x10	; 16
     7fc:	40 e0       	ldi	r20, 0x00	; 0
     7fe:	50 e0       	ldi	r21, 0x00	; 0
     800:	2a 83       	std	Y+2, r18	; 0x02
     802:	3b 83       	std	Y+3, r19	; 0x03
     804:	4c 83       	std	Y+4, r20	; 0x04
     806:	5d 83       	std	Y+5, r21	; 0x05
volatile uint8_t checksumADC[3] = {0};  // checksum for FRAM test
volatile uint8_t checksumFRAM[3] = {0};  // checksum for FRAM test
volatile uint8_t newFile[15] = {'n','e','w','F','I','L','E','.',' ',' ',' ',' ',' ',' ',' '}; //must be no more than 8 letters before the extension "." 

void CO_collectTemp(uint16_t *avgV, uint16_t *minV, uint16_t *maxV) {
	uint32_t sum = 0;
     808:	88 24       	eor	r8, r8
     80a:	99 24       	eor	r9, r9
     80c:	54 01       	movw	r10, r8
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {

	  	do{
			/* If the conversion on the ADCA channel 0 never is
			 * complete this will be a deadlock. */
		}while(!ADC_Ch_Conversion_Complete(&ADCA.CH0));
     80e:	00 e2       	ldi	r16, 0x20	; 32
     810:	12 e0       	ldi	r17, 0x02	; 2
     812:	d8 01       	movw	r26, r16
     814:	13 96       	adiw	r26, 0x03	; 3
     816:	8c 91       	ld	r24, X
     818:	13 97       	sbiw	r26, 0x03	; 3
     81a:	80 ff       	sbrs	r24, 0
     81c:	fa cf       	rjmp	.-12     	; 0x812 <CO_collectTemp+0x108>
		tempResult = ADC_ResultCh_GetWord_Signed(&ADCA.CH0, offset);
     81e:	69 81       	ldd	r22, Y+1	; 0x01
     820:	c8 01       	movw	r24, r16
     822:	0e 94 c8 12 	call	0x2590	; 0x2590 <ADC_ResultCh_GetWord_Signed>
		sum+=tempResult;
     826:	a0 e0       	ldi	r26, 0x00	; 0
     828:	b0 e0       	ldi	r27, 0x00	; 0
     82a:	88 0e       	add	r8, r24
     82c:	99 1e       	adc	r9, r25
     82e:	aa 1e       	adc	r10, r26
     830:	bb 1e       	adc	r11, r27
     832:	48 16       	cp	r4, r24
     834:	59 06       	cpc	r5, r25
     836:	6a 06       	cpc	r6, r26
     838:	7b 06       	cpc	r7, r27
     83a:	10 f4       	brcc	.+4      	; 0x840 <CO_collectTemp+0x136>
     83c:	2c 01       	movw	r4, r24
     83e:	3d 01       	movw	r6, r26
     840:	2a 81       	ldd	r18, Y+2	; 0x02
     842:	3b 81       	ldd	r19, Y+3	; 0x03
     844:	4c 81       	ldd	r20, Y+4	; 0x04
     846:	5d 81       	ldd	r21, Y+5	; 0x05
     848:	82 17       	cp	r24, r18
     84a:	93 07       	cpc	r25, r19
     84c:	a4 07       	cpc	r26, r20
     84e:	b5 07       	cpc	r27, r21
     850:	20 f4       	brcc	.+8      	; 0x85a <CO_collectTemp+0x150>
     852:	8a 83       	std	Y+2, r24	; 0x02
     854:	9b 83       	std	Y+3, r25	; 0x03
     856:	ac 83       	std	Y+4, r26	; 0x04
     858:	bd 83       	std	Y+5, r27	; 0x05
     85a:	08 94       	sec
     85c:	e1 08       	sbc	r14, r1
     85e:	f1 08       	sbc	r15, r1

	/* Enable free running mode. */
	ADC_FreeRunning_Enable(&ADCA);

	/* Sample onboard ADC.*/
	for (uint16_t i = 0; i < NUM_SAMPLES; ++i) {
     860:	e1 14       	cp	r14, r1
     862:	f1 04       	cpc	r15, r1
     864:	b1 f6       	brne	.-84     	; 0x812 <CO_collectTemp+0x108>
		if (min > tempResult) { min = tempResult;}

	}

	/* Turn off free running and disable ADC module.*/
	ADC_FreeRunning_Disable(&ADCA);
     866:	e0 e0       	ldi	r30, 0x00	; 0
     868:	f2 e0       	ldi	r31, 0x02	; 2
     86a:	81 81       	ldd	r24, Z+1	; 0x01
     86c:	87 7f       	andi	r24, 0xF7	; 247
     86e:	81 83       	std	Z+1, r24	; 0x01
	ADC_Pipeline_Flush(&ADCA);
     870:	80 81       	ld	r24, Z
     872:	82 60       	ori	r24, 0x02	; 2
     874:	80 83       	st	Z, r24
	ADC_Disable(&ADCA);
     876:	80 81       	ld	r24, Z
     878:	8e 7f       	andi	r24, 0xFE	; 254
     87a:	80 83       	st	Z, r24

	ADCPower(FALSE);
     87c:	80 e0       	ldi	r24, 0x00	; 0
     87e:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>

	average = sum / NUM_SAMPLES;
     882:	c5 01       	movw	r24, r10
     884:	b4 01       	movw	r22, r8
     886:	05 2e       	mov	r0, r21
     888:	5a e0       	ldi	r21, 0x0A	; 10
     88a:	96 95       	lsr	r25
     88c:	87 95       	ror	r24
     88e:	77 95       	ror	r23
     890:	67 95       	ror	r22
     892:	5a 95       	dec	r21
     894:	d1 f7       	brne	.-12     	; 0x88a <CO_collectTemp+0x180>
     896:	50 2d       	mov	r21, r0

	//convert to mV
	*avgV = (average * 1000 / 4095) - 50;
     898:	28 ee       	ldi	r18, 0xE8	; 232
     89a:	33 e0       	ldi	r19, 0x03	; 3
     89c:	40 e0       	ldi	r20, 0x00	; 0
     89e:	50 e0       	ldi	r21, 0x00	; 0
     8a0:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
     8a4:	0f 2e       	mov	r0, r31
     8a6:	ff ef       	ldi	r31, 0xFF	; 255
     8a8:	8f 2e       	mov	r8, r31
     8aa:	ff e0       	ldi	r31, 0x0F	; 15
     8ac:	9f 2e       	mov	r9, r31
     8ae:	f0 e0       	ldi	r31, 0x00	; 0
     8b0:	af 2e       	mov	r10, r31
     8b2:	f0 e0       	ldi	r31, 0x00	; 0
     8b4:	bf 2e       	mov	r11, r31
     8b6:	f0 2d       	mov	r31, r0
     8b8:	a5 01       	movw	r20, r10
     8ba:	94 01       	movw	r18, r8
     8bc:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
     8c0:	c9 01       	movw	r24, r18
     8c2:	c2 97       	sbiw	r24, 0x32	; 50
     8c4:	ae 81       	ldd	r26, Y+6	; 0x06
     8c6:	bf 81       	ldd	r27, Y+7	; 0x07
     8c8:	8d 93       	st	X+, r24
     8ca:	9c 93       	st	X, r25
	*maxV = (max * 1000 / 4095) - 50;
     8cc:	c3 01       	movw	r24, r6
     8ce:	b2 01       	movw	r22, r4
     8d0:	28 ee       	ldi	r18, 0xE8	; 232
     8d2:	33 e0       	ldi	r19, 0x03	; 3
     8d4:	40 e0       	ldi	r20, 0x00	; 0
     8d6:	50 e0       	ldi	r21, 0x00	; 0
     8d8:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
     8dc:	a5 01       	movw	r20, r10
     8de:	94 01       	movw	r18, r8
     8e0:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
     8e4:	c9 01       	movw	r24, r18
     8e6:	c2 97       	sbiw	r24, 0x32	; 50
     8e8:	ea 85       	ldd	r30, Y+10	; 0x0a
     8ea:	fb 85       	ldd	r31, Y+11	; 0x0b
     8ec:	80 83       	st	Z, r24
     8ee:	91 83       	std	Z+1, r25	; 0x01
	*minV = (min * 1000  / 4095) - 50;
     8f0:	6a 81       	ldd	r22, Y+2	; 0x02
     8f2:	7b 81       	ldd	r23, Y+3	; 0x03
     8f4:	8c 81       	ldd	r24, Y+4	; 0x04
     8f6:	9d 81       	ldd	r25, Y+5	; 0x05
     8f8:	28 ee       	ldi	r18, 0xE8	; 232
     8fa:	33 e0       	ldi	r19, 0x03	; 3
     8fc:	40 e0       	ldi	r20, 0x00	; 0
     8fe:	50 e0       	ldi	r21, 0x00	; 0
     900:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
     904:	a5 01       	movw	r20, r10
     906:	94 01       	movw	r18, r8
     908:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
     90c:	22 53       	subi	r18, 0x32	; 50
     90e:	30 40       	sbci	r19, 0x00	; 0
     910:	a8 85       	ldd	r26, Y+8	; 0x08
     912:	b9 85       	ldd	r27, Y+9	; 0x09
     914:	2d 93       	st	X+, r18
     916:	3c 93       	st	X, r19
     918:	11 97       	sbiw	r26, 0x01	; 1
}
     91a:	2b 96       	adiw	r28, 0x0b	; 11
     91c:	cd bf       	out	0x3d, r28	; 61
     91e:	de bf       	out	0x3e, r29	; 62
     920:	df 91       	pop	r29
     922:	cf 91       	pop	r28
     924:	1f 91       	pop	r17
     926:	0f 91       	pop	r16
     928:	ff 90       	pop	r15
     92a:	ef 90       	pop	r14
     92c:	bf 90       	pop	r11
     92e:	af 90       	pop	r10
     930:	9f 90       	pop	r9
     932:	8f 90       	pop	r8
     934:	7f 90       	pop	r7
     936:	6f 90       	pop	r6
     938:	5f 90       	pop	r5
     93a:	4f 90       	pop	r4
     93c:	08 95       	ret

0000093e <enableADCMUX>:
	if (upperCS) upperMuxCS(FALSE);
	SPIDisable();
}

void enableADCMUX(uint8_t on) {
	if(on) {
     93e:	88 23       	and	r24, r24
     940:	31 f0       	breq	.+12     	; 0x94e <enableADCMUX+0x10>
		PORTA.DIRSET = PIN5_bm;
     942:	e0 e0       	ldi	r30, 0x00	; 0
     944:	f6 e0       	ldi	r31, 0x06	; 6
     946:	80 e2       	ldi	r24, 0x20	; 32
     948:	81 83       	std	Z+1, r24	; 0x01
		PORTA.OUTSET = PIN5_bm;
     94a:	85 83       	std	Z+5, r24	; 0x05
     94c:	08 95       	ret
	} else {
		PORTA.OUTCLR = PIN5_bm;
     94e:	e0 e0       	ldi	r30, 0x00	; 0
     950:	f6 e0       	ldi	r31, 0x06	; 6
     952:	80 e2       	ldi	r24, 0x20	; 32
     954:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRCLR = PIN5_bm;
     956:	82 83       	std	Z+2, r24	; 0x02
     958:	08 95       	ret

0000095a <ADC_Stop_Sampling>:
discardCount = 0;
}


void ADC_Stop_Sampling(){
		PortEx_DIRCLR(BIT3_bm, PS_BANKB);  //pull SD card CS high
     95a:	88 e0       	ldi	r24, 0x08	; 8
     95c:	60 e0       	ldi	r22, 0x00	; 0
     95e:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <PortEx_DIRCLR>
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);
     962:	88 e0       	ldi	r24, 0x08	; 8
     964:	60 e0       	ldi	r22, 0x00	; 0
     966:	0e 94 36 1b 	call	0x366c	; 0x366c <PortEx_OUTCLR>
	
}
     96a:	08 95       	ret

0000096c <__vector_105>:
ISR(PORTF_INT1_vect) {
     96c:	1f 92       	push	r1
     96e:	0f 92       	push	r0
     970:	0f b6       	in	r0, 0x3f	; 63
     972:	0f 92       	push	r0
     974:	0b b6       	in	r0, 0x3b	; 59
     976:	0f 92       	push	r0
     978:	11 24       	eor	r1, r1
     97a:	af 92       	push	r10
     97c:	bf 92       	push	r11
     97e:	cf 92       	push	r12
     980:	df 92       	push	r13
     982:	ef 92       	push	r14
     984:	ff 92       	push	r15
     986:	0f 93       	push	r16
     988:	1f 93       	push	r17
     98a:	2f 93       	push	r18
     98c:	3f 93       	push	r19
     98e:	4f 93       	push	r20
     990:	5f 93       	push	r21
     992:	6f 93       	push	r22
     994:	7f 93       	push	r23
     996:	8f 93       	push	r24
     998:	9f 93       	push	r25
     99a:	af 93       	push	r26
     99c:	bf 93       	push	r27
     99e:	ef 93       	push	r30
     9a0:	ff 93       	push	r31
     9a2:	cf 93       	push	r28
     9a4:	df 93       	push	r29
     9a6:	cd b7       	in	r28, 0x3d	; 61
     9a8:	de b7       	in	r29, 0x3e	; 62
     9aa:	2a 97       	sbiw	r28, 0x0a	; 10
     9ac:	cd bf       	out	0x3d, r28	; 61
     9ae:	de bf       	out	0x3e, r29	; 62
	// skip first samples because cannot perform recommended reset
	if(TotalSampleCount>=10){
     9b0:	80 91 80 50 	lds	r24, 0x5080
     9b4:	90 91 81 50 	lds	r25, 0x5081
     9b8:	8a 30       	cpi	r24, 0x0A	; 10
     9ba:	91 05       	cpc	r25, r1
     9bc:	20 f0       	brcs	.+8      	; 0x9c6 <__vector_105+0x5a>
		SD_disable();
     9be:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <SD_disable>
		while(1){
			nop();
     9c2:	00 00       	nop
     9c4:	fe cf       	rjmp	.-4      	; 0x9c2 <__vector_105+0x56>
		}		
	}		
	if (discardCount < ADC_DISCARD) {
     9c6:	80 91 40 40 	lds	r24, 0x4040
     9ca:	88 23       	and	r24, r24
     9cc:	34 f0       	brlt	.+12     	; 0x9da <__vector_105+0x6e>
		discardCount++;
     9ce:	80 91 40 40 	lds	r24, 0x4040
     9d2:	8f 5f       	subi	r24, 0xFF	; 255
     9d4:	80 93 40 40 	sts	0x4040, r24
     9d8:	e1 c0       	rjmp	.+450    	; 0xb9c <__vector_105+0x230>
	}		
	else {
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
     9da:	84 e0       	ldi	r24, 0x04	; 4
     9dc:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
     9e0:	84 e5       	ldi	r24, 0x54	; 84
     9e2:	80 93 c0 08 	sts	0x08C0, r24
		SPICS(TRUE); // CS SPI-SS
     9e6:	81 e0       	ldi	r24, 0x01	; 1
     9e8:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
     9ec:	82 e0       	ldi	r24, 0x02	; 2
     9ee:	e0 ea       	ldi	r30, 0xA0	; 160
     9f0:	f6 e0       	ldi	r31, 0x06	; 6
     9f2:	86 83       	std	Z+6, r24	; 0x06
     9f4:	80 e0       	ldi	r24, 0x00	; 0
     9f6:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
     9f8:	a0 ec       	ldi	r26, 0xC0	; 192
     9fa:	b8 e0       	ldi	r27, 0x08	; 8
     9fc:	4a ea       	ldi	r20, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
     9fe:	27 e4       	ldi	r18, 0x47	; 71
     a00:	30 e5       	ldi	r19, 0x50	; 80
		SPIInit(SPI_MODE_1_gc);
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
     a02:	13 96       	adiw	r26, 0x03	; 3
     a04:	4c 93       	st	X, r20
     a06:	13 97       	sbiw	r26, 0x03	; 3
			while(!(SPIC.STATUS & SPI_IF_bm));
     a08:	12 96       	adiw	r26, 0x02	; 2
     a0a:	5c 91       	ld	r21, X
     a0c:	12 97       	sbiw	r26, 0x02	; 2
     a0e:	55 23       	and	r21, r21
     a10:	dc f7       	brge	.-10     	; 0xa08 <__vector_105+0x9c>
			SPIBuffer[bufIndex] = SPIC.DATA;
     a12:	13 96       	adiw	r26, 0x03	; 3
     a14:	5c 91       	ld	r21, X
     a16:	13 97       	sbiw	r26, 0x03	; 3
     a18:	f9 01       	movw	r30, r18
     a1a:	e8 0f       	add	r30, r24
     a1c:	f9 1f       	adc	r31, r25
     a1e:	50 83       	st	Z, r21
     a20:	01 96       	adiw	r24, 0x01	; 1
		// collect data from offchip ADC
		SPIInit(SPI_MODE_1_gc);
		SPIC.CTRL = ADC_SPI_CONFIG_gc;
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     a22:	83 30       	cpi	r24, 0x03	; 3
     a24:	91 05       	cpc	r25, r1
     a26:	69 f7       	brne	.-38     	; 0xa02 <__vector_105+0x96>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
     a28:	82 e0       	ldi	r24, 0x02	; 2
     a2a:	e0 ea       	ldi	r30, 0xA0	; 160
     a2c:	f6 e0       	ldi	r31, 0x06	; 6
     a2e:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
     a30:	80 e0       	ldi	r24, 0x00	; 0
     a32:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>

		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[0]) + 3) = 0xFF; // sign extension if negative
     a36:	80 91 47 50 	lds	r24, 0x5047
     a3a:	88 23       	and	r24, r24
     a3c:	24 f4       	brge	.+8      	; 0xa46 <__vector_105+0xda>
     a3e:	8f ef       	ldi	r24, 0xFF	; 255
     a40:	80 93 48 40 	sts	0x4048, r24
     a44:	02 c0       	rjmp	.+4      	; 0xa4a <__vector_105+0xde>
		else *(((uint8_t*)&data24Bit[0]) + 3) = 0x00;				
     a46:	10 92 48 40 	sts	0x4048, r1
		*(((uint8_t*)&data24Bit[0]) + 2) = SPIBuffer[0];
     a4a:	80 91 47 50 	lds	r24, 0x5047
     a4e:	e7 e4       	ldi	r30, 0x47	; 71
     a50:	f0 e4       	ldi	r31, 0x40	; 64
     a52:	80 93 47 40 	sts	0x4047, r24
		*(((uint8_t*)&data24Bit[0]) + 1) = SPIBuffer[1];
     a56:	80 91 48 50 	lds	r24, 0x5048
     a5a:	df 01       	movw	r26, r30
     a5c:	11 97       	sbiw	r26, 0x01	; 1
     a5e:	8c 93       	st	X, r24
		*(((uint8_t*)&data24Bit[0]) + 0) = SPIBuffer[2];
     a60:	80 91 49 50 	lds	r24, 0x5049
     a64:	32 97       	sbiw	r30, 0x02	; 2
     a66:	80 83       	st	Z, r24
		
		//convert ADC reading to voltage here (in uV)
		var = data24Bit[0];
     a68:	80 81       	ld	r24, Z
     a6a:	91 81       	ldd	r25, Z+1	; 0x01
     a6c:	a2 81       	ldd	r26, Z+2	; 0x02
     a6e:	b3 81       	ldd	r27, Z+3	; 0x03
     a70:	ac 01       	movw	r20, r24
     a72:	bd 01       	movw	r22, r26
     a74:	77 0f       	add	r23, r23
     a76:	44 0b       	sbc	r20, r20
     a78:	54 2f       	mov	r21, r20
     a7a:	ba 01       	movw	r22, r20
     a7c:	80 93 82 50 	sts	0x5082, r24
     a80:	90 93 83 50 	sts	0x5083, r25
     a84:	a0 93 84 50 	sts	0x5084, r26
     a88:	b0 93 85 50 	sts	0x5085, r27
     a8c:	40 93 86 50 	sts	0x5086, r20
     a90:	40 93 87 50 	sts	0x5087, r20
     a94:	40 93 88 50 	sts	0x5088, r20
     a98:	40 93 89 50 	sts	0x5089, r20
		*((int32_t*)&FRAMReadBuffer[sampleCount*4]) = (int32_t) -(var * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
     a9c:	e0 91 54 50 	lds	r30, 0x5054
     aa0:	f0 91 55 50 	lds	r31, 0x5055
     aa4:	20 91 82 50 	lds	r18, 0x5082
     aa8:	30 91 83 50 	lds	r19, 0x5083
     aac:	40 91 84 50 	lds	r20, 0x5084
     ab0:	50 91 85 50 	lds	r21, 0x5085
     ab4:	60 91 86 50 	lds	r22, 0x5086
     ab8:	70 91 87 50 	lds	r23, 0x5087
     abc:	80 91 88 50 	lds	r24, 0x5088
     ac0:	90 91 89 50 	lds	r25, 0x5089
     ac4:	ee 0f       	add	r30, r30
     ac6:	ff 1f       	adc	r31, r31
     ac8:	ee 0f       	add	r30, r30
     aca:	ff 1f       	adc	r31, r31
     acc:	df 01       	movw	r26, r30
     ace:	ae 53       	subi	r26, 0x3E	; 62
     ad0:	bc 4d       	sbci	r27, 0xDC	; 220
     ad2:	a9 87       	std	Y+9, r26	; 0x09
     ad4:	ba 87       	std	Y+10, r27	; 0x0a
     ad6:	0f 2e       	mov	r0, r31
     ad8:	f0 ea       	ldi	r31, 0xA0	; 160
     ada:	af 2e       	mov	r10, r31
     adc:	f0 2d       	mov	r31, r0
     ade:	0f 2e       	mov	r0, r31
     ae0:	f5 e2       	ldi	r31, 0x25	; 37
     ae2:	bf 2e       	mov	r11, r31
     ae4:	f0 2d       	mov	r31, r0
     ae6:	0f 2e       	mov	r0, r31
     ae8:	f6 e2       	ldi	r31, 0x26	; 38
     aea:	cf 2e       	mov	r12, r31
     aec:	f0 2d       	mov	r31, r0
     aee:	dd 24       	eor	r13, r13
     af0:	ee 24       	eor	r14, r14
     af2:	ff 24       	eor	r15, r15
     af4:	00 e0       	ldi	r16, 0x00	; 0
     af6:	10 e0       	ldi	r17, 0x00	; 0
     af8:	0e 94 af 2b 	call	0x575e	; 0x575e <__muldi3>
     afc:	aa 24       	eor	r10, r10
     afe:	aa 94       	dec	r10
     b00:	bb 24       	eor	r11, r11
     b02:	ba 94       	dec	r11
     b04:	0f 2e       	mov	r0, r31
     b06:	ff e7       	ldi	r31, 0x7F	; 127
     b08:	cf 2e       	mov	r12, r31
     b0a:	f0 2d       	mov	r31, r0
     b0c:	0e 94 5e 2d 	call	0x5abc	; 0x5abc <__divdi3>
     b10:	01 e0       	ldi	r16, 0x01	; 1
     b12:	0e 94 82 2c 	call	0x5904	; 0x5904 <__ashldi3>
     b16:	0f 2e       	mov	r0, r31
     b18:	f3 e0       	ldi	r31, 0x03	; 3
     b1a:	af 2e       	mov	r10, r31
     b1c:	f0 2d       	mov	r31, r0
     b1e:	bb 24       	eor	r11, r11
     b20:	cc 24       	eor	r12, r12
     b22:	00 e0       	ldi	r16, 0x00	; 0
     b24:	0e 94 5e 2d 	call	0x5abc	; 0x5abc <__divdi3>
     b28:	29 83       	std	Y+1, r18	; 0x01
     b2a:	3a 83       	std	Y+2, r19	; 0x02
     b2c:	4b 83       	std	Y+3, r20	; 0x03
     b2e:	5c 83       	std	Y+4, r21	; 0x04
     b30:	6d 83       	std	Y+5, r22	; 0x05
     b32:	7e 83       	std	Y+6, r23	; 0x06
     b34:	8f 83       	std	Y+7, r24	; 0x07
     b36:	98 87       	std	Y+8, r25	; 0x08
     b38:	89 81       	ldd	r24, Y+1	; 0x01
     b3a:	9a 81       	ldd	r25, Y+2	; 0x02
     b3c:	ab 81       	ldd	r26, Y+3	; 0x03
     b3e:	bc 81       	ldd	r27, Y+4	; 0x04
     b40:	b0 95       	com	r27
     b42:	a0 95       	com	r26
     b44:	90 95       	com	r25
     b46:	81 95       	neg	r24
     b48:	9f 4f       	sbci	r25, 0xFF	; 255
     b4a:	af 4f       	sbci	r26, 0xFF	; 255
     b4c:	bf 4f       	sbci	r27, 0xFF	; 255
     b4e:	e9 85       	ldd	r30, Y+9	; 0x09
     b50:	fa 85       	ldd	r31, Y+10	; 0x0a
     b52:	80 83       	st	Z, r24
     b54:	91 83       	std	Z+1, r25	; 0x01
     b56:	a2 83       	std	Z+2, r26	; 0x02
     b58:	b3 83       	std	Z+3, r27	; 0x03
		
		sampleCount++;
     b5a:	80 91 54 50 	lds	r24, 0x5054
     b5e:	90 91 55 50 	lds	r25, 0x5055
     b62:	01 96       	adiw	r24, 0x01	; 1
     b64:	80 93 54 50 	sts	0x5054, r24
     b68:	90 93 55 50 	sts	0x5055, r25
	//after 128 samples, store the data into sd card and reset sample buffer
	if (sampleCount >= 128) { 
     b6c:	80 91 54 50 	lds	r24, 0x5054
     b70:	90 91 55 50 	lds	r25, 0x5055
     b74:	80 38       	cpi	r24, 0x80	; 128
     b76:	91 05       	cpc	r25, r1
     b78:	88 f0       	brcs	.+34     	; 0xb9c <__vector_105+0x230>
		//SPIInit(SPI_MODE_0_gc);
		//SPICS(TRUE);
		//PortEx_DIRCLR(BIT3_bm, PS_BANKB);  //pull SD card CS low
		//PortEx_OUTCLR(BIT3_bm, PS_BANKB);
		//writeFile("samples");
		writeFile(newFile); 
     b7a:	80 e0       	ldi	r24, 0x00	; 0
     b7c:	90 e2       	ldi	r25, 0x20	; 32
     b7e:	0e 94 8a 24 	call	0x4914	; 0x4914 <writeFile>
		/*
		SD_write_block(10,FRAMReadBuffer,512);
		for (int i=0;i<512;i++) FRAMReadBuffer[i] = 0;
		SD_read_block(10,FRAMReadBuffer);
		*/
		sampleCount=0;
     b82:	10 92 54 50 	sts	0x5054, r1
     b86:	10 92 55 50 	sts	0x5055, r1
		TotalSampleCount++;
     b8a:	80 91 80 50 	lds	r24, 0x5080
     b8e:	90 91 81 50 	lds	r25, 0x5081
     b92:	01 96       	adiw	r24, 0x01	; 1
     b94:	80 93 80 50 	sts	0x5080, r24
     b98:	90 93 81 50 	sts	0x5081, r25
		//PORTF.OUTSET = PIN1_bm; //re-enable ADC for further sampling
	}	
	}	
}
     b9c:	2a 96       	adiw	r28, 0x0a	; 10
     b9e:	cd bf       	out	0x3d, r28	; 61
     ba0:	de bf       	out	0x3e, r29	; 62
     ba2:	df 91       	pop	r29
     ba4:	cf 91       	pop	r28
     ba6:	ff 91       	pop	r31
     ba8:	ef 91       	pop	r30
     baa:	bf 91       	pop	r27
     bac:	af 91       	pop	r26
     bae:	9f 91       	pop	r25
     bb0:	8f 91       	pop	r24
     bb2:	7f 91       	pop	r23
     bb4:	6f 91       	pop	r22
     bb6:	5f 91       	pop	r21
     bb8:	4f 91       	pop	r20
     bba:	3f 91       	pop	r19
     bbc:	2f 91       	pop	r18
     bbe:	1f 91       	pop	r17
     bc0:	0f 91       	pop	r16
     bc2:	ff 90       	pop	r15
     bc4:	ef 90       	pop	r14
     bc6:	df 90       	pop	r13
     bc8:	cf 90       	pop	r12
     bca:	bf 90       	pop	r11
     bcc:	af 90       	pop	r10
     bce:	0f 90       	pop	r0
     bd0:	0b be       	out	0x3b, r0	; 59
     bd2:	0f 90       	pop	r0
     bd4:	0f be       	out	0x3f, r0	; 63
     bd6:	0f 90       	pop	r0
     bd8:	1f 90       	pop	r1
     bda:	18 95       	reti

00000bdc <__vector_104>:

ISR(PORTF_INT0_vect) {
     bdc:	1f 92       	push	r1
     bde:	0f 92       	push	r0
     be0:	0f b6       	in	r0, 0x3f	; 63
     be2:	0f 92       	push	r0
     be4:	0b b6       	in	r0, 0x3b	; 59
     be6:	0f 92       	push	r0
     be8:	11 24       	eor	r1, r1
     bea:	2f 93       	push	r18
     bec:	3f 93       	push	r19
     bee:	4f 93       	push	r20
     bf0:	5f 93       	push	r21
     bf2:	6f 93       	push	r22
     bf4:	7f 93       	push	r23
     bf6:	8f 93       	push	r24
     bf8:	9f 93       	push	r25
     bfa:	af 93       	push	r26
     bfc:	bf 93       	push	r27
     bfe:	ef 93       	push	r30
     c00:	ff 93       	push	r31
	// skip first samples because cannot perform recommended reset
	if (discardCount < ADC_DISCARD) {
     c02:	80 91 40 40 	lds	r24, 0x4040
     c06:	88 23       	and	r24, r24
     c08:	34 f0       	brlt	.+12     	; 0xc16 <__vector_104+0x3a>
		discardCount++;
     c0a:	80 91 40 40 	lds	r24, 0x4040
     c0e:	8f 5f       	subi	r24, 0xFF	; 255
     c10:	80 93 40 40 	sts	0x4040, r24
     c14:	6e c0       	rjmp	.+220    	; 0xcf2 <__vector_104+0x116>
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
     c16:	81 e0       	ldi	r24, 0x01	; 1
     c18:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
     c1c:	82 e0       	ldi	r24, 0x02	; 2
     c1e:	e0 ea       	ldi	r30, 0xA0	; 160
     c20:	f6 e0       	ldi	r31, 0x06	; 6
     c22:	86 83       	std	Z+6, r24	; 0x06
     c24:	80 e0       	ldi	r24, 0x00	; 0
     c26:	90 e0       	ldi	r25, 0x00	; 0
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
     c28:	e0 ec       	ldi	r30, 0xC0	; 192
     c2a:	f8 e0       	ldi	r31, 0x08	; 8
     c2c:	5a ea       	ldi	r21, 0xAA	; 170
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
     c2e:	27 e4       	ldi	r18, 0x47	; 71
     c30:	30 e5       	ldi	r19, 0x50	; 80
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
     c32:	53 83       	std	Z+3, r21	; 0x03
			while(!(SPIC.STATUS & SPI_IF_bm));
     c34:	42 81       	ldd	r20, Z+2	; 0x02
     c36:	44 23       	and	r20, r20
     c38:	ec f7       	brge	.-6      	; 0xc34 <__vector_104+0x58>
			SPIBuffer[bufIndex] = SPIC.DATA;
     c3a:	43 81       	ldd	r20, Z+3	; 0x03
     c3c:	d9 01       	movw	r26, r18
     c3e:	a8 0f       	add	r26, r24
     c40:	b9 1f       	adc	r27, r25
     c42:	4c 93       	st	X, r20
     c44:	01 96       	adiw	r24, 0x01	; 1
		discardCount++;
	} else { 
		// collect data from offchip ADC
		SPICS(TRUE); // CS SPI-SS
		PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
		for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
     c46:	83 30       	cpi	r24, 0x03	; 3
     c48:	91 05       	cpc	r25, r1
     c4a:	99 f7       	brne	.-26     	; 0xc32 <__vector_104+0x56>
			SPIC.DATA = 0xAA; // dummy data to start SPI clock
			while(!(SPIC.STATUS & SPI_IF_bm));
			SPIBuffer[bufIndex] = SPIC.DATA;
		}
		PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
     c4c:	82 e0       	ldi	r24, 0x02	; 2
     c4e:	e0 ea       	ldi	r30, 0xA0	; 160
     c50:	f6 e0       	ldi	r31, 0x06	; 6
     c52:	85 83       	std	Z+5, r24	; 0x05
		SPICS(FALSE);
     c54:	80 e0       	ldi	r24, 0x00	; 0
     c56:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>

		// create 32 bits from SPIBuffer[0:2] with sign extension of SPIBuffer[0][7]
		if(SPIBuffer[0] & BIT7_bm) *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0xFF; // sign extension if negative
     c5a:	80 91 47 50 	lds	r24, 0x5047
     c5e:	88 23       	and	r24, r24
     c60:	6c f4       	brge	.+26     	; 0xc7c <__vector_104+0xa0>
     c62:	e0 91 54 50 	lds	r30, 0x5054
     c66:	f0 91 55 50 	lds	r31, 0x5055
     c6a:	ee 0f       	add	r30, r30
     c6c:	ff 1f       	adc	r31, r31
     c6e:	ee 0f       	add	r30, r30
     c70:	ff 1f       	adc	r31, r31
     c72:	e8 5b       	subi	r30, 0xB8	; 184
     c74:	ff 4b       	sbci	r31, 0xBF	; 191
     c76:	8f ef       	ldi	r24, 0xFF	; 255
     c78:	80 83       	st	Z, r24
     c7a:	0b c0       	rjmp	.+22     	; 0xc92 <__vector_104+0xb6>
		else *(((uint8_t*)&data24Bit[sampleCount]) + 3) = 0x00;
     c7c:	e0 91 54 50 	lds	r30, 0x5054
     c80:	f0 91 55 50 	lds	r31, 0x5055
     c84:	ee 0f       	add	r30, r30
     c86:	ff 1f       	adc	r31, r31
     c88:	ee 0f       	add	r30, r30
     c8a:	ff 1f       	adc	r31, r31
     c8c:	e8 5b       	subi	r30, 0xB8	; 184
     c8e:	ff 4b       	sbci	r31, 0xBF	; 191
     c90:	10 82       	st	Z, r1
	
		*(((uint8_t*)&data24Bit[sampleCount]) + 2) = SPIBuffer[0];
     c92:	e0 91 54 50 	lds	r30, 0x5054
     c96:	f0 91 55 50 	lds	r31, 0x5055
     c9a:	80 91 47 50 	lds	r24, 0x5047
     c9e:	ee 0f       	add	r30, r30
     ca0:	ff 1f       	adc	r31, r31
     ca2:	ee 0f       	add	r30, r30
     ca4:	ff 1f       	adc	r31, r31
     ca6:	e9 5b       	subi	r30, 0xB9	; 185
     ca8:	ff 4b       	sbci	r31, 0xBF	; 191
     caa:	80 83       	st	Z, r24
		*(((uint8_t*)&data24Bit[sampleCount]) + 1) = SPIBuffer[1];
     cac:	e0 91 54 50 	lds	r30, 0x5054
     cb0:	f0 91 55 50 	lds	r31, 0x5055
     cb4:	80 91 48 50 	lds	r24, 0x5048
     cb8:	ee 0f       	add	r30, r30
     cba:	ff 1f       	adc	r31, r31
     cbc:	ee 0f       	add	r30, r30
     cbe:	ff 1f       	adc	r31, r31
     cc0:	ea 5b       	subi	r30, 0xBA	; 186
     cc2:	ff 4b       	sbci	r31, 0xBF	; 191
     cc4:	80 83       	st	Z, r24
		*(((uint8_t*)&data24Bit[sampleCount]) + 0) = SPIBuffer[2];
     cc6:	e0 91 54 50 	lds	r30, 0x5054
     cca:	f0 91 55 50 	lds	r31, 0x5055
     cce:	ee 0f       	add	r30, r30
     cd0:	ff 1f       	adc	r31, r31
     cd2:	ee 0f       	add	r30, r30
     cd4:	ff 1f       	adc	r31, r31
     cd6:	eb 5b       	subi	r30, 0xBB	; 187
     cd8:	ff 4b       	sbci	r31, 0xBF	; 191
     cda:	80 91 49 50 	lds	r24, 0x5049
     cde:	80 83       	st	Z, r24

		sampleCount++;
     ce0:	80 91 54 50 	lds	r24, 0x5054
     ce4:	90 91 55 50 	lds	r25, 0x5055
     ce8:	01 96       	adiw	r24, 0x01	; 1
     cea:	80 93 54 50 	sts	0x5054, r24
     cee:	90 93 55 50 	sts	0x5055, r25
	}
}
     cf2:	ff 91       	pop	r31
     cf4:	ef 91       	pop	r30
     cf6:	bf 91       	pop	r27
     cf8:	af 91       	pop	r26
     cfa:	9f 91       	pop	r25
     cfc:	8f 91       	pop	r24
     cfe:	7f 91       	pop	r23
     d00:	6f 91       	pop	r22
     d02:	5f 91       	pop	r21
     d04:	4f 91       	pop	r20
     d06:	3f 91       	pop	r19
     d08:	2f 91       	pop	r18
     d0a:	0f 90       	pop	r0
     d0c:	0b be       	out	0x3b, r0	; 59
     d0e:	0f 90       	pop	r0
     d10:	0f be       	out	0x3f, r0	; 63
     d12:	0f 90       	pop	r0
     d14:	1f 90       	pop	r1
     d16:	18 95       	reti

00000d18 <ACC_DCPassEnable>:

// Enable DC Pass for acc
// Pull PIO27 high to enable
void ACC_DCPassEnable(uint8_t enable) {
	if (enable) {
     d18:	88 23       	and	r24, r24
     d1a:	49 f0       	breq	.+18     	; 0xd2e <ACC_DCPassEnable+0x16>
		PortEx_DIRSET(BIT5_bm, PS_BANKB);
     d1c:	80 e2       	ldi	r24, 0x20	; 32
     d1e:	60 e0       	ldi	r22, 0x00	; 0
     d20:	0e 94 3a 1c 	call	0x3874	; 0x3874 <PortEx_DIRSET>
		PortEx_OUTSET(BIT5_bm, PS_BANKB);
     d24:	80 e2       	ldi	r24, 0x20	; 32
     d26:	60 e0       	ldi	r22, 0x00	; 0
     d28:	0e 94 8d 1b 	call	0x371a	; 0x371a <PortEx_OUTSET>
     d2c:	08 95       	ret
		//setPortEx(BIT5_bm, PS_BANKB);
	} else {
		PortEx_DIRCLR(BIT5_bm, PS_BANKB);
     d2e:	80 e2       	ldi	r24, 0x20	; 32
     d30:	60 e0       	ldi	r22, 0x00	; 0
     d32:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <PortEx_DIRCLR>
     d36:	08 95       	ret

00000d38 <sampleCurrentChannel>:
ISR(TCD0_OVF_vect) {
	writeSE2FRAM();
}

void sampleCurrentChannel() {
	PORTF.OUTCLR = PIN1_bm; // pull ADC_CS down to enable data read
     d38:	82 e0       	ldi	r24, 0x02	; 2
     d3a:	e0 ea       	ldi	r30, 0xA0	; 160
     d3c:	f6 e0       	ldi	r31, 0x06	; 6
     d3e:	86 83       	std	Z+6, r24	; 0x06
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
     d40:	8a ea       	ldi	r24, 0xAA	; 170
     d42:	e0 ec       	ldi	r30, 0xC0	; 192
     d44:	f8 e0       	ldi	r31, 0x08	; 8
     d46:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     d48:	82 81       	ldd	r24, Z+2	; 0x02
     d4a:	88 23       	and	r24, r24
     d4c:	ec f7       	brge	.-6      	; 0xd48 <sampleCurrentChannel+0x10>
	SPIBuffer[SPICount] = SPIC.DATA;
     d4e:	90 91 aa 50 	lds	r25, 0x50AA
     d52:	e0 ec       	ldi	r30, 0xC0	; 192
     d54:	f8 e0       	ldi	r31, 0x08	; 8
     d56:	83 81       	ldd	r24, Z+3	; 0x03
     d58:	a7 e4       	ldi	r26, 0x47	; 71
     d5a:	b0 e5       	ldi	r27, 0x50	; 80
     d5c:	a9 0f       	add	r26, r25
     d5e:	b1 1d       	adc	r27, r1
     d60:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
     d62:	8a ea       	ldi	r24, 0xAA	; 170
     d64:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     d66:	82 81       	ldd	r24, Z+2	; 0x02
     d68:	88 23       	and	r24, r24
     d6a:	ec f7       	brge	.-6      	; 0xd66 <sampleCurrentChannel+0x2e>
	SPIBuffer[SPICount+1] = SPIC.DATA;
     d6c:	a0 91 aa 50 	lds	r26, 0x50AA
     d70:	b0 e0       	ldi	r27, 0x00	; 0
     d72:	e0 ec       	ldi	r30, 0xC0	; 192
     d74:	f8 e0       	ldi	r31, 0x08	; 8
     d76:	83 81       	ldd	r24, Z+3	; 0x03
     d78:	a8 5b       	subi	r26, 0xB8	; 184
     d7a:	bf 4a       	sbci	r27, 0xAF	; 175
     d7c:	8c 93       	st	X, r24
	SPIC.DATA = 0xAA; // dummy data to start SPI clock
     d7e:	8a ea       	ldi	r24, 0xAA	; 170
     d80:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
     d82:	82 81       	ldd	r24, Z+2	; 0x02
     d84:	88 23       	and	r24, r24
     d86:	ec f7       	brge	.-6      	; 0xd82 <sampleCurrentChannel+0x4a>
	SPIBuffer[SPICount+2] = SPIC.DATA;
     d88:	e0 91 aa 50 	lds	r30, 0x50AA
     d8c:	f0 e0       	ldi	r31, 0x00	; 0
     d8e:	a0 ec       	ldi	r26, 0xC0	; 192
     d90:	b8 e0       	ldi	r27, 0x08	; 8
     d92:	13 96       	adiw	r26, 0x03	; 3
     d94:	8c 91       	ld	r24, X
     d96:	13 97       	sbiw	r26, 0x03	; 3
     d98:	e7 5b       	subi	r30, 0xB7	; 183
     d9a:	ff 4a       	sbci	r31, 0xAF	; 175
     d9c:	80 83       	st	Z, r24
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
     d9e:	82 e0       	ldi	r24, 0x02	; 2
     da0:	e0 ea       	ldi	r30, 0xA0	; 160
     da2:	f6 e0       	ldi	r31, 0x06	; 6
     da4:	85 83       	std	Z+5, r24	; 0x05
	SPICount +=3;
     da6:	80 91 aa 50 	lds	r24, 0x50AA
     daa:	8d 5f       	subi	r24, 0xFD	; 253
     dac:	80 93 aa 50 	sts	0x50AA, r24
}
     db0:	08 95       	ret

00000db2 <__vector_82>:

ISR(TCD0_CCC_vect) {
	sampleCurrentChannel();
}

ISR(TCD0_CCD_vect) {
     db2:	1f 92       	push	r1
     db4:	0f 92       	push	r0
     db6:	0f b6       	in	r0, 0x3f	; 63
     db8:	0f 92       	push	r0
     dba:	0b b6       	in	r0, 0x3b	; 59
     dbc:	0f 92       	push	r0
     dbe:	11 24       	eor	r1, r1
     dc0:	2f 93       	push	r18
     dc2:	3f 93       	push	r19
     dc4:	4f 93       	push	r20
     dc6:	5f 93       	push	r21
     dc8:	6f 93       	push	r22
     dca:	7f 93       	push	r23
     dcc:	8f 93       	push	r24
     dce:	9f 93       	push	r25
     dd0:	af 93       	push	r26
     dd2:	bf 93       	push	r27
     dd4:	ef 93       	push	r30
     dd6:	ff 93       	push	r31
	sampleCurrentChannel();
     dd8:	0e 94 9c 06 	call	0xd38	; 0xd38 <sampleCurrentChannel>
	SPICount = 0;
     ddc:	10 92 aa 50 	sts	0x50AA, r1
}
     de0:	ff 91       	pop	r31
     de2:	ef 91       	pop	r30
     de4:	bf 91       	pop	r27
     de6:	af 91       	pop	r26
     de8:	9f 91       	pop	r25
     dea:	8f 91       	pop	r24
     dec:	7f 91       	pop	r23
     dee:	6f 91       	pop	r22
     df0:	5f 91       	pop	r21
     df2:	4f 91       	pop	r20
     df4:	3f 91       	pop	r19
     df6:	2f 91       	pop	r18
     df8:	0f 90       	pop	r0
     dfa:	0b be       	out	0x3b, r0	; 59
     dfc:	0f 90       	pop	r0
     dfe:	0f be       	out	0x3f, r0	; 63
     e00:	0f 90       	pop	r0
     e02:	1f 90       	pop	r1
     e04:	18 95       	reti

00000e06 <__vector_81>:

ISR(TCD0_CCB_vect) {
	sampleCurrentChannel();
}

ISR(TCD0_CCC_vect) {
     e06:	1f 92       	push	r1
     e08:	0f 92       	push	r0
     e0a:	0f b6       	in	r0, 0x3f	; 63
     e0c:	0f 92       	push	r0
     e0e:	0b b6       	in	r0, 0x3b	; 59
     e10:	0f 92       	push	r0
     e12:	11 24       	eor	r1, r1
     e14:	2f 93       	push	r18
     e16:	3f 93       	push	r19
     e18:	4f 93       	push	r20
     e1a:	5f 93       	push	r21
     e1c:	6f 93       	push	r22
     e1e:	7f 93       	push	r23
     e20:	8f 93       	push	r24
     e22:	9f 93       	push	r25
     e24:	af 93       	push	r26
     e26:	bf 93       	push	r27
     e28:	ef 93       	push	r30
     e2a:	ff 93       	push	r31
	sampleCurrentChannel();
     e2c:	0e 94 9c 06 	call	0xd38	; 0xd38 <sampleCurrentChannel>
}
     e30:	ff 91       	pop	r31
     e32:	ef 91       	pop	r30
     e34:	bf 91       	pop	r27
     e36:	af 91       	pop	r26
     e38:	9f 91       	pop	r25
     e3a:	8f 91       	pop	r24
     e3c:	7f 91       	pop	r23
     e3e:	6f 91       	pop	r22
     e40:	5f 91       	pop	r21
     e42:	4f 91       	pop	r20
     e44:	3f 91       	pop	r19
     e46:	2f 91       	pop	r18
     e48:	0f 90       	pop	r0
     e4a:	0b be       	out	0x3b, r0	; 59
     e4c:	0f 90       	pop	r0
     e4e:	0f be       	out	0x3f, r0	; 63
     e50:	0f 90       	pop	r0
     e52:	1f 90       	pop	r1
     e54:	18 95       	reti

00000e56 <__vector_80>:

ISR(TCD0_CCA_vect) {
	sampleCurrentChannel();
}

ISR(TCD0_CCB_vect) {
     e56:	1f 92       	push	r1
     e58:	0f 92       	push	r0
     e5a:	0f b6       	in	r0, 0x3f	; 63
     e5c:	0f 92       	push	r0
     e5e:	0b b6       	in	r0, 0x3b	; 59
     e60:	0f 92       	push	r0
     e62:	11 24       	eor	r1, r1
     e64:	2f 93       	push	r18
     e66:	3f 93       	push	r19
     e68:	4f 93       	push	r20
     e6a:	5f 93       	push	r21
     e6c:	6f 93       	push	r22
     e6e:	7f 93       	push	r23
     e70:	8f 93       	push	r24
     e72:	9f 93       	push	r25
     e74:	af 93       	push	r26
     e76:	bf 93       	push	r27
     e78:	ef 93       	push	r30
     e7a:	ff 93       	push	r31
	sampleCurrentChannel();
     e7c:	0e 94 9c 06 	call	0xd38	; 0xd38 <sampleCurrentChannel>
}
     e80:	ff 91       	pop	r31
     e82:	ef 91       	pop	r30
     e84:	bf 91       	pop	r27
     e86:	af 91       	pop	r26
     e88:	9f 91       	pop	r25
     e8a:	8f 91       	pop	r24
     e8c:	7f 91       	pop	r23
     e8e:	6f 91       	pop	r22
     e90:	5f 91       	pop	r21
     e92:	4f 91       	pop	r20
     e94:	3f 91       	pop	r19
     e96:	2f 91       	pop	r18
     e98:	0f 90       	pop	r0
     e9a:	0b be       	out	0x3b, r0	; 59
     e9c:	0f 90       	pop	r0
     e9e:	0f be       	out	0x3f, r0	; 63
     ea0:	0f 90       	pop	r0
     ea2:	1f 90       	pop	r1
     ea4:	18 95       	reti

00000ea6 <__vector_79>:
	enableADCMUX(FALSE);
	ADCPower(FALSE);
	
}

ISR(TCD0_CCA_vect) {
     ea6:	1f 92       	push	r1
     ea8:	0f 92       	push	r0
     eaa:	0f b6       	in	r0, 0x3f	; 63
     eac:	0f 92       	push	r0
     eae:	0b b6       	in	r0, 0x3b	; 59
     eb0:	0f 92       	push	r0
     eb2:	11 24       	eor	r1, r1
     eb4:	2f 93       	push	r18
     eb6:	3f 93       	push	r19
     eb8:	4f 93       	push	r20
     eba:	5f 93       	push	r21
     ebc:	6f 93       	push	r22
     ebe:	7f 93       	push	r23
     ec0:	8f 93       	push	r24
     ec2:	9f 93       	push	r25
     ec4:	af 93       	push	r26
     ec6:	bf 93       	push	r27
     ec8:	ef 93       	push	r30
     eca:	ff 93       	push	r31
	sampleCurrentChannel();
     ecc:	0e 94 9c 06 	call	0xd38	; 0xd38 <sampleCurrentChannel>
}
     ed0:	ff 91       	pop	r31
     ed2:	ef 91       	pop	r30
     ed4:	bf 91       	pop	r27
     ed6:	af 91       	pop	r26
     ed8:	9f 91       	pop	r25
     eda:	8f 91       	pop	r24
     edc:	7f 91       	pop	r23
     ede:	6f 91       	pop	r22
     ee0:	5f 91       	pop	r21
     ee2:	4f 91       	pop	r20
     ee4:	3f 91       	pop	r19
     ee6:	2f 91       	pop	r18
     ee8:	0f 90       	pop	r0
     eea:	0b be       	out	0x3b, r0	; 59
     eec:	0f 90       	pop	r0
     eee:	0f be       	out	0x3f, r0	; 63
     ef0:	0f 90       	pop	r0
     ef2:	1f 90       	pop	r1
     ef4:	18 95       	reti

00000ef6 <__vector_19>:

ISR(TCC0_CCC_vect) {
	sampleCurrentChannel();
}

ISR(TCC0_CCD_vect) {
     ef6:	1f 92       	push	r1
     ef8:	0f 92       	push	r0
     efa:	0f b6       	in	r0, 0x3f	; 63
     efc:	0f 92       	push	r0
     efe:	0b b6       	in	r0, 0x3b	; 59
     f00:	0f 92       	push	r0
     f02:	11 24       	eor	r1, r1
     f04:	2f 93       	push	r18
     f06:	3f 93       	push	r19
     f08:	4f 93       	push	r20
     f0a:	5f 93       	push	r21
     f0c:	6f 93       	push	r22
     f0e:	7f 93       	push	r23
     f10:	8f 93       	push	r24
     f12:	9f 93       	push	r25
     f14:	af 93       	push	r26
     f16:	bf 93       	push	r27
     f18:	ef 93       	push	r30
     f1a:	ff 93       	push	r31
	sampleCurrentChannel();
     f1c:	0e 94 9c 06 	call	0xd38	; 0xd38 <sampleCurrentChannel>
	SPICount = 0;
     f20:	10 92 aa 50 	sts	0x50AA, r1
	if(PORTB.OUT & PIN1_bm) {
     f24:	e0 e2       	ldi	r30, 0x20	; 32
     f26:	f6 e0       	ldi	r31, 0x06	; 6
     f28:	84 81       	ldd	r24, Z+4	; 0x04
     f2a:	81 ff       	sbrs	r24, 1
     f2c:	0f c0       	rjmp	.+30     	; 0xf4c <__vector_19+0x56>
		if (PORTA.OUT & PIN6_bm) PORTB.OUTTGL = PIN1_bm;
     f2e:	e0 e0       	ldi	r30, 0x00	; 0
     f30:	f6 e0       	ldi	r31, 0x06	; 6
     f32:	84 81       	ldd	r24, Z+4	; 0x04
     f34:	86 ff       	sbrs	r24, 6
     f36:	05 c0       	rjmp	.+10     	; 0xf42 <__vector_19+0x4c>
     f38:	82 e0       	ldi	r24, 0x02	; 2
     f3a:	e0 e2       	ldi	r30, 0x20	; 32
     f3c:	f6 e0       	ldi	r31, 0x06	; 6
     f3e:	87 83       	std	Z+7, r24	; 0x07
     f40:	0d c0       	rjmp	.+26     	; 0xf5c <__vector_19+0x66>
		else PORTA.OUTTGL = PIN6_bm;
     f42:	80 e4       	ldi	r24, 0x40	; 64
     f44:	e0 e0       	ldi	r30, 0x00	; 0
     f46:	f6 e0       	ldi	r31, 0x06	; 6
     f48:	87 83       	std	Z+7, r24	; 0x07
     f4a:	08 c0       	rjmp	.+16     	; 0xf5c <__vector_19+0x66>
	} else {
		PORTA.OUTCLR = PIN6_bm;
     f4c:	80 e4       	ldi	r24, 0x40	; 64
     f4e:	e0 e0       	ldi	r30, 0x00	; 0
     f50:	f6 e0       	ldi	r31, 0x06	; 6
     f52:	86 83       	std	Z+6, r24	; 0x06
		PORTB.OUTSET = PIN1_bm;
     f54:	82 e0       	ldi	r24, 0x02	; 2
     f56:	e0 e2       	ldi	r30, 0x20	; 32
     f58:	f6 e0       	ldi	r31, 0x06	; 6
     f5a:	85 83       	std	Z+5, r24	; 0x05
	}
	
}
     f5c:	ff 91       	pop	r31
     f5e:	ef 91       	pop	r30
     f60:	bf 91       	pop	r27
     f62:	af 91       	pop	r26
     f64:	9f 91       	pop	r25
     f66:	8f 91       	pop	r24
     f68:	7f 91       	pop	r23
     f6a:	6f 91       	pop	r22
     f6c:	5f 91       	pop	r21
     f6e:	4f 91       	pop	r20
     f70:	3f 91       	pop	r19
     f72:	2f 91       	pop	r18
     f74:	0f 90       	pop	r0
     f76:	0b be       	out	0x3b, r0	; 59
     f78:	0f 90       	pop	r0
     f7a:	0f be       	out	0x3f, r0	; 63
     f7c:	0f 90       	pop	r0
     f7e:	1f 90       	pop	r1
     f80:	18 95       	reti

00000f82 <__vector_18>:

ISR(TCC0_CCB_vect) {
	sampleCurrentChannel();
}

ISR(TCC0_CCC_vect) {
     f82:	1f 92       	push	r1
     f84:	0f 92       	push	r0
     f86:	0f b6       	in	r0, 0x3f	; 63
     f88:	0f 92       	push	r0
     f8a:	0b b6       	in	r0, 0x3b	; 59
     f8c:	0f 92       	push	r0
     f8e:	11 24       	eor	r1, r1
     f90:	2f 93       	push	r18
     f92:	3f 93       	push	r19
     f94:	4f 93       	push	r20
     f96:	5f 93       	push	r21
     f98:	6f 93       	push	r22
     f9a:	7f 93       	push	r23
     f9c:	8f 93       	push	r24
     f9e:	9f 93       	push	r25
     fa0:	af 93       	push	r26
     fa2:	bf 93       	push	r27
     fa4:	ef 93       	push	r30
     fa6:	ff 93       	push	r31
	sampleCurrentChannel();
     fa8:	0e 94 9c 06 	call	0xd38	; 0xd38 <sampleCurrentChannel>
}
     fac:	ff 91       	pop	r31
     fae:	ef 91       	pop	r30
     fb0:	bf 91       	pop	r27
     fb2:	af 91       	pop	r26
     fb4:	9f 91       	pop	r25
     fb6:	8f 91       	pop	r24
     fb8:	7f 91       	pop	r23
     fba:	6f 91       	pop	r22
     fbc:	5f 91       	pop	r21
     fbe:	4f 91       	pop	r20
     fc0:	3f 91       	pop	r19
     fc2:	2f 91       	pop	r18
     fc4:	0f 90       	pop	r0
     fc6:	0b be       	out	0x3b, r0	; 59
     fc8:	0f 90       	pop	r0
     fca:	0f be       	out	0x3f, r0	; 63
     fcc:	0f 90       	pop	r0
     fce:	1f 90       	pop	r1
     fd0:	18 95       	reti

00000fd2 <__vector_17>:

ISR(TCC0_CCA_vect) {
	sampleCurrentChannel();
}

ISR(TCC0_CCB_vect) {
     fd2:	1f 92       	push	r1
     fd4:	0f 92       	push	r0
     fd6:	0f b6       	in	r0, 0x3f	; 63
     fd8:	0f 92       	push	r0
     fda:	0b b6       	in	r0, 0x3b	; 59
     fdc:	0f 92       	push	r0
     fde:	11 24       	eor	r1, r1
     fe0:	2f 93       	push	r18
     fe2:	3f 93       	push	r19
     fe4:	4f 93       	push	r20
     fe6:	5f 93       	push	r21
     fe8:	6f 93       	push	r22
     fea:	7f 93       	push	r23
     fec:	8f 93       	push	r24
     fee:	9f 93       	push	r25
     ff0:	af 93       	push	r26
     ff2:	bf 93       	push	r27
     ff4:	ef 93       	push	r30
     ff6:	ff 93       	push	r31
	sampleCurrentChannel();
     ff8:	0e 94 9c 06 	call	0xd38	; 0xd38 <sampleCurrentChannel>
}
     ffc:	ff 91       	pop	r31
     ffe:	ef 91       	pop	r30
    1000:	bf 91       	pop	r27
    1002:	af 91       	pop	r26
    1004:	9f 91       	pop	r25
    1006:	8f 91       	pop	r24
    1008:	7f 91       	pop	r23
    100a:	6f 91       	pop	r22
    100c:	5f 91       	pop	r21
    100e:	4f 91       	pop	r20
    1010:	3f 91       	pop	r19
    1012:	2f 91       	pop	r18
    1014:	0f 90       	pop	r0
    1016:	0b be       	out	0x3b, r0	; 59
    1018:	0f 90       	pop	r0
    101a:	0f be       	out	0x3f, r0	; 63
    101c:	0f 90       	pop	r0
    101e:	1f 90       	pop	r1
    1020:	18 95       	reti

00001022 <__vector_16>:
		nop();
	}
}


ISR(TCC0_CCA_vect) {
    1022:	1f 92       	push	r1
    1024:	0f 92       	push	r0
    1026:	0f b6       	in	r0, 0x3f	; 63
    1028:	0f 92       	push	r0
    102a:	0b b6       	in	r0, 0x3b	; 59
    102c:	0f 92       	push	r0
    102e:	11 24       	eor	r1, r1
    1030:	2f 93       	push	r18
    1032:	3f 93       	push	r19
    1034:	4f 93       	push	r20
    1036:	5f 93       	push	r21
    1038:	6f 93       	push	r22
    103a:	7f 93       	push	r23
    103c:	8f 93       	push	r24
    103e:	9f 93       	push	r25
    1040:	af 93       	push	r26
    1042:	bf 93       	push	r27
    1044:	ef 93       	push	r30
    1046:	ff 93       	push	r31
	sampleCurrentChannel();
    1048:	0e 94 9c 06 	call	0xd38	; 0xd38 <sampleCurrentChannel>
}
    104c:	ff 91       	pop	r31
    104e:	ef 91       	pop	r30
    1050:	bf 91       	pop	r27
    1052:	af 91       	pop	r26
    1054:	9f 91       	pop	r25
    1056:	8f 91       	pop	r24
    1058:	7f 91       	pop	r23
    105a:	6f 91       	pop	r22
    105c:	5f 91       	pop	r21
    105e:	4f 91       	pop	r20
    1060:	3f 91       	pop	r19
    1062:	2f 91       	pop	r18
    1064:	0f 90       	pop	r0
    1066:	0b be       	out	0x3b, r0	; 59
    1068:	0f 90       	pop	r0
    106a:	0f be       	out	0x3f, r0	; 63
    106c:	0f 90       	pop	r0
    106e:	1f 90       	pop	r1
    1070:	18 95       	reti

00001072 <writeSE2FRAM>:
	SPIBuffer[SPICount+2] = SPIC.DATA;
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

void writeSE2FRAM() {
    1072:	ff 92       	push	r15
    1074:	0f 93       	push	r16
    1076:	1f 93       	push	r17
    1078:	cf 93       	push	r28
    107a:	df 93       	push	r29
    107c:	cd b7       	in	r28, 0x3d	; 61
    107e:	de b7       	in	r29, 0x3e	; 62
    1080:	28 97       	sbiw	r28, 0x08	; 8
    1082:	cd bf       	out	0x3d, r28	; 61
    1084:	de bf       	out	0x3e, r29	; 62
	volatile int32_t sum = 0;
    1086:	19 82       	std	Y+1, r1	; 0x01
    1088:	1a 82       	std	Y+2, r1	; 0x02
    108a:	1b 82       	std	Y+3, r1	; 0x03
    108c:	1c 82       	std	Y+4, r1	; 0x04
	volatile int32_t currentSample;
	sampleCount++;
    108e:	80 91 54 50 	lds	r24, 0x5054
    1092:	90 91 55 50 	lds	r25, 0x5055
    1096:	01 96       	adiw	r24, 0x01	; 1
    1098:	80 93 54 50 	sts	0x5054, r24
    109c:	90 93 55 50 	sts	0x5055, r25
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    10a0:	80 ed       	ldi	r24, 0xD0	; 208
    10a2:	80 93 c0 08 	sts	0x08C0, r24
    10a6:	20 e0       	ldi	r18, 0x00	; 0
    10a8:	30 e0       	ldi	r19, 0x00	; 0
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
    10aa:	07 e4       	ldi	r16, 0x47	; 71
    10ac:	10 e5       	ldi	r17, 0x50	; 80
    10ae:	ff 24       	eor	r15, r15
    10b0:	fa 94       	dec	r15
    10b2:	c9 01       	movw	r24, r18
    10b4:	f8 01       	movw	r30, r16
    10b6:	e2 0f       	add	r30, r18
    10b8:	f3 1f       	adc	r31, r19
    10ba:	40 81       	ld	r20, Z
    10bc:	44 23       	and	r20, r20
    10be:	14 f4       	brge	.+4      	; 0x10c4 <writeSE2FRAM+0x52>
    10c0:	f8 86       	std	Y+8, r15	; 0x08
    10c2:	01 c0       	rjmp	.+2      	; 0x10c6 <writeSE2FRAM+0x54>
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
    10c4:	18 86       	std	Y+8, r1	; 0x08
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
    10c6:	80 0f       	add	r24, r16
    10c8:	91 1f       	adc	r25, r17
    10ca:	fc 01       	movw	r30, r24
    10cc:	80 81       	ld	r24, Z
    10ce:	8f 83       	std	Y+7, r24	; 0x07
	SPIBuffer[SPICount+2] = SPIC.DATA;
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

void writeSE2FRAM() {
    10d0:	f9 01       	movw	r30, r18
    10d2:	31 96       	adiw	r30, 0x01	; 1
	
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
    10d4:	e0 0f       	add	r30, r16
    10d6:	f1 1f       	adc	r31, r17
    10d8:	80 81       	ld	r24, Z
    10da:	8e 83       	std	Y+6, r24	; 0x06
	SPIBuffer[SPICount+2] = SPIC.DATA;
	PORTF.OUTSET = PIN1_bm; // pull ADC_CS up to end data read
	SPICount +=3;
}

void writeSE2FRAM() {
    10dc:	f9 01       	movw	r30, r18
    10de:	32 96       	adiw	r30, 0x02	; 2
	for(uint8_t i = 0; i < 12; i+=3) {
		if(SPIBuffer[i] & BIT7_bm) *(((uint8_t*)&currentSample) + 3) = 0xFF; // sign extension if negative
		else *(((uint8_t*)&currentSample) + 3) = 0x00;
		*(((uint8_t*)&currentSample) + 2) = SPIBuffer[i];
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
    10e0:	e0 0f       	add	r30, r16
    10e2:	f1 1f       	adc	r31, r17
    10e4:	80 81       	ld	r24, Z
    10e6:	8d 83       	std	Y+5, r24	; 0x05
		sum += currentSample;
    10e8:	49 81       	ldd	r20, Y+1	; 0x01
    10ea:	5a 81       	ldd	r21, Y+2	; 0x02
    10ec:	6b 81       	ldd	r22, Y+3	; 0x03
    10ee:	7c 81       	ldd	r23, Y+4	; 0x04
    10f0:	8d 81       	ldd	r24, Y+5	; 0x05
    10f2:	9e 81       	ldd	r25, Y+6	; 0x06
    10f4:	af 81       	ldd	r26, Y+7	; 0x07
    10f6:	b8 85       	ldd	r27, Y+8	; 0x08
    10f8:	84 0f       	add	r24, r20
    10fa:	95 1f       	adc	r25, r21
    10fc:	a6 1f       	adc	r26, r22
    10fe:	b7 1f       	adc	r27, r23
    1100:	89 83       	std	Y+1, r24	; 0x01
    1102:	9a 83       	std	Y+2, r25	; 0x02
    1104:	ab 83       	std	Y+3, r26	; 0x03
    1106:	bc 83       	std	Y+4, r27	; 0x04
    1108:	2d 5f       	subi	r18, 0xFD	; 253
    110a:	3f 4f       	sbci	r19, 0xFF	; 255
	volatile int32_t currentSample;
	sampleCount++;
	
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	
	for(uint8_t i = 0; i < 12; i+=3) {
    110c:	2c 30       	cpi	r18, 0x0C	; 12
    110e:	31 05       	cpc	r19, r1
    1110:	81 f6       	brne	.-96     	; 0x10b2 <writeSE2FRAM+0x40>
		*(((uint8_t*)&currentSample) + 1) = SPIBuffer[i+1];
		*(((uint8_t*)&currentSample) + 0) = SPIBuffer[i+2];
		sum += currentSample;
	}
	
	sum = sum / 4;
    1112:	69 81       	ldd	r22, Y+1	; 0x01
    1114:	7a 81       	ldd	r23, Y+2	; 0x02
    1116:	8b 81       	ldd	r24, Y+3	; 0x03
    1118:	9c 81       	ldd	r25, Y+4	; 0x04
    111a:	24 e0       	ldi	r18, 0x04	; 4
    111c:	30 e0       	ldi	r19, 0x00	; 0
    111e:	40 e0       	ldi	r20, 0x00	; 0
    1120:	50 e0       	ldi	r21, 0x00	; 0
    1122:	0e 94 82 35 	call	0x6b04	; 0x6b04 <__divmodsi4>
    1126:	29 83       	std	Y+1, r18	; 0x01
    1128:	3a 83       	std	Y+2, r19	; 0x02
    112a:	4b 83       	std	Y+3, r20	; 0x03
    112c:	5c 83       	std	Y+4, r21	; 0x04
	SPIBuffer[2] = *(((uint8_t*)&sum)+0);
    112e:	29 81       	ldd	r18, Y+1	; 0x01
    1130:	89 e4       	ldi	r24, 0x49	; 73
    1132:	90 e5       	ldi	r25, 0x50	; 80
    1134:	20 93 49 50 	sts	0x5049, r18
	SPIBuffer[1] = *(((uint8_t*)&sum)+1);
    1138:	2a 81       	ldd	r18, Y+2	; 0x02
    113a:	fc 01       	movw	r30, r24
    113c:	31 97       	sbiw	r30, 0x01	; 1
    113e:	20 83       	st	Z, r18
	SPIBuffer[0] = *(((uint8_t*)&sum)+2);
    1140:	2b 81       	ldd	r18, Y+3	; 0x03
    1142:	02 97       	sbiw	r24, 0x02	; 2
    1144:	fc 01       	movw	r30, r24
    1146:	20 83       	st	Z, r18


	
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    1148:	80 e1       	ldi	r24, 0x10	; 16
    114a:	e0 e4       	ldi	r30, 0x40	; 64
    114c:	f6 e0       	ldi	r31, 0x06	; 6
    114e:	86 83       	std	Z+6, r24	; 0x06
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1150:	88 e0       	ldi	r24, 0x08	; 8
    1152:	e0 e2       	ldi	r30, 0x20	; 32
    1154:	f6 e0       	ldi	r31, 0x06	; 6
    1156:	86 83       	std	Z+6, r24	; 0x06
	nop();
    1158:	00 00       	nop
	SPIC.DATA = FR_WREN;
    115a:	86 e0       	ldi	r24, 0x06	; 6
    115c:	e0 ec       	ldi	r30, 0xC0	; 192
    115e:	f8 e0       	ldi	r31, 0x08	; 8
    1160:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    1162:	82 81       	ldd	r24, Z+2	; 0x02
    1164:	88 23       	and	r24, r24
    1166:	ec f7       	brge	.-6      	; 0x1162 <writeSE2FRAM+0xf0>
	SPIBuffer[12] = SPIC.DATA;
    1168:	e0 ec       	ldi	r30, 0xC0	; 192
    116a:	f8 e0       	ldi	r31, 0x08	; 8
    116c:	83 81       	ldd	r24, Z+3	; 0x03
    116e:	80 93 53 50 	sts	0x5053, r24
	PORTB.OUTSET = PIN3_bm;  // latch opcode
    1172:	a0 e2       	ldi	r26, 0x20	; 32
    1174:	b6 e0       	ldi	r27, 0x06	; 6
    1176:	88 e0       	ldi	r24, 0x08	; 8
    1178:	15 96       	adiw	r26, 0x05	; 5
    117a:	8c 93       	st	X, r24
    117c:	15 97       	sbiw	r26, 0x05	; 5
	nop(); // time for CS_FRAM to accept high signal
    117e:	00 00       	nop
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1180:	16 96       	adiw	r26, 0x06	; 6
    1182:	8c 93       	st	X, r24
    1184:	16 97       	sbiw	r26, 0x06	; 6
	nop();
    1186:	00 00       	nop
	SPIC.DATA = FR_WRITE;
    1188:	82 e0       	ldi	r24, 0x02	; 2
    118a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    118c:	82 81       	ldd	r24, Z+2	; 0x02
    118e:	88 23       	and	r24, r24
    1190:	ec f7       	brge	.-6      	; 0x118c <writeSE2FRAM+0x11a>
	SPIBuffer[12] = SPIC.DATA;
    1192:	e0 ec       	ldi	r30, 0xC0	; 192
    1194:	f8 e0       	ldi	r31, 0x08	; 8
    1196:	83 81       	ldd	r24, Z+3	; 0x03
    1198:	80 93 53 50 	sts	0x5053, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    119c:	80 91 3b 40 	lds	r24, 0x403B
    11a0:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    11a2:	82 81       	ldd	r24, Z+2	; 0x02
    11a4:	88 23       	and	r24, r24
    11a6:	ec f7       	brge	.-6      	; 0x11a2 <writeSE2FRAM+0x130>
	SPIBuffer[12] = SPIC.DATA;
    11a8:	e0 ec       	ldi	r30, 0xC0	; 192
    11aa:	f8 e0       	ldi	r31, 0x08	; 8
    11ac:	83 81       	ldd	r24, Z+3	; 0x03
    11ae:	80 93 53 50 	sts	0x5053, r24
	SPIC.DATA = *((uint8_t*)&FRAMAddress);
    11b2:	80 91 3a 40 	lds	r24, 0x403A
    11b6:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    11b8:	82 81       	ldd	r24, Z+2	; 0x02
    11ba:	88 23       	and	r24, r24
    11bc:	ec f7       	brge	.-6      	; 0x11b8 <writeSE2FRAM+0x146>
	SPIBuffer[12] = SPIC.DATA;
    11be:	e0 ec       	ldi	r30, 0xC0	; 192
    11c0:	f8 e0       	ldi	r31, 0x08	; 8
    11c2:	83 81       	ldd	r24, Z+3	; 0x03
    11c4:	80 93 53 50 	sts	0x5053, r24
	SPIC.DATA = SPIBuffer[0];
    11c8:	80 91 47 50 	lds	r24, 0x5047
    11cc:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    11ce:	82 81       	ldd	r24, Z+2	; 0x02
    11d0:	88 23       	and	r24, r24
    11d2:	ec f7       	brge	.-6      	; 0x11ce <writeSE2FRAM+0x15c>
	SPIBuffer[12] = SPIC.DATA;
    11d4:	e0 ec       	ldi	r30, 0xC0	; 192
    11d6:	f8 e0       	ldi	r31, 0x08	; 8
    11d8:	83 81       	ldd	r24, Z+3	; 0x03
    11da:	80 93 53 50 	sts	0x5053, r24
	SPIC.DATA = SPIBuffer[1];
    11de:	80 91 48 50 	lds	r24, 0x5048
    11e2:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    11e4:	82 81       	ldd	r24, Z+2	; 0x02
    11e6:	88 23       	and	r24, r24
    11e8:	ec f7       	brge	.-6      	; 0x11e4 <writeSE2FRAM+0x172>
	SPIBuffer[12] = SPIC.DATA;
    11ea:	e0 ec       	ldi	r30, 0xC0	; 192
    11ec:	f8 e0       	ldi	r31, 0x08	; 8
    11ee:	83 81       	ldd	r24, Z+3	; 0x03
    11f0:	80 93 53 50 	sts	0x5053, r24
	SPIC.DATA = SPIBuffer[2];
    11f4:	80 91 49 50 	lds	r24, 0x5049
    11f8:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    11fa:	82 81       	ldd	r24, Z+2	; 0x02
    11fc:	88 23       	and	r24, r24
    11fe:	ec f7       	brge	.-6      	; 0x11fa <writeSE2FRAM+0x188>
	SPIBuffer[12] = SPIC.DATA;
    1200:	a0 ec       	ldi	r26, 0xC0	; 192
    1202:	b8 e0       	ldi	r27, 0x08	; 8
    1204:	13 96       	adiw	r26, 0x03	; 3
    1206:	8c 91       	ld	r24, X
    1208:	13 97       	sbiw	r26, 0x03	; 3
    120a:	80 93 53 50 	sts	0x5053, r24
	
	PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    120e:	88 e0       	ldi	r24, 0x08	; 8
    1210:	e0 e2       	ldi	r30, 0x20	; 32
    1212:	f6 e0       	ldi	r31, 0x06	; 6
    1214:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    1216:	e0 e4       	ldi	r30, 0x40	; 64
    1218:	f6 e0       	ldi	r31, 0x06	; 6
    121a:	80 e1       	ldi	r24, 0x10	; 16
    121c:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    121e:	94 e5       	ldi	r25, 0x54	; 84
    1220:	9c 93       	st	X, r25
	PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    1222:	86 83       	std	Z+6, r24	; 0x06
	
	FRAMAddress +=3;
    1224:	80 91 3a 40 	lds	r24, 0x403A
    1228:	90 91 3b 40 	lds	r25, 0x403B
    122c:	03 96       	adiw	r24, 0x03	; 3
    122e:	80 93 3a 40 	sts	0x403A, r24
    1232:	90 93 3b 40 	sts	0x403B, r25
	checksumADC[0] += SPIBuffer[0];
    1236:	80 91 1f 21 	lds	r24, 0x211F
    123a:	e7 e4       	ldi	r30, 0x47	; 71
    123c:	f0 e5       	ldi	r31, 0x50	; 80
    123e:	90 81       	ld	r25, Z
    1240:	89 0f       	add	r24, r25
    1242:	80 93 1f 21 	sts	0x211F, r24
	checksumADC[1] += SPIBuffer[1];
    1246:	80 91 20 21 	lds	r24, 0x2120
    124a:	91 81       	ldd	r25, Z+1	; 0x01
    124c:	89 0f       	add	r24, r25
    124e:	80 93 20 21 	sts	0x2120, r24
	checksumADC[2] += SPIBuffer[2];
    1252:	80 91 21 21 	lds	r24, 0x2121
    1256:	92 81       	ldd	r25, Z+2	; 0x02
    1258:	89 0f       	add	r24, r25
    125a:	80 93 21 21 	sts	0x2121, r24
}
    125e:	28 96       	adiw	r28, 0x08	; 8
    1260:	cd bf       	out	0x3d, r28	; 61
    1262:	de bf       	out	0x3e, r29	; 62
    1264:	df 91       	pop	r29
    1266:	cf 91       	pop	r28
    1268:	1f 91       	pop	r17
    126a:	0f 91       	pop	r16
    126c:	ff 90       	pop	r15
    126e:	08 95       	ret

00001270 <__vector_77>:
ISR(TCD0_CCD_vect) {
	sampleCurrentChannel();
	SPICount = 0;
}

ISR(TCD0_OVF_vect) {
    1270:	1f 92       	push	r1
    1272:	0f 92       	push	r0
    1274:	0f b6       	in	r0, 0x3f	; 63
    1276:	0f 92       	push	r0
    1278:	0b b6       	in	r0, 0x3b	; 59
    127a:	0f 92       	push	r0
    127c:	11 24       	eor	r1, r1
    127e:	2f 93       	push	r18
    1280:	3f 93       	push	r19
    1282:	4f 93       	push	r20
    1284:	5f 93       	push	r21
    1286:	6f 93       	push	r22
    1288:	7f 93       	push	r23
    128a:	8f 93       	push	r24
    128c:	9f 93       	push	r25
    128e:	af 93       	push	r26
    1290:	bf 93       	push	r27
    1292:	ef 93       	push	r30
    1294:	ff 93       	push	r31
	writeSE2FRAM();
    1296:	0e 94 39 08 	call	0x1072	; 0x1072 <writeSE2FRAM>
}
    129a:	ff 91       	pop	r31
    129c:	ef 91       	pop	r30
    129e:	bf 91       	pop	r27
    12a0:	af 91       	pop	r26
    12a2:	9f 91       	pop	r25
    12a4:	8f 91       	pop	r24
    12a6:	7f 91       	pop	r23
    12a8:	6f 91       	pop	r22
    12aa:	5f 91       	pop	r21
    12ac:	4f 91       	pop	r20
    12ae:	3f 91       	pop	r19
    12b0:	2f 91       	pop	r18
    12b2:	0f 90       	pop	r0
    12b4:	0b be       	out	0x3b, r0	; 59
    12b6:	0f 90       	pop	r0
    12b8:	0f be       	out	0x3f, r0	; 63
    12ba:	0f 90       	pop	r0
    12bc:	1f 90       	pop	r1
    12be:	18 95       	reti

000012c0 <__vector_14>:
		PORTB.OUTSET = PIN1_bm;
	}
	
}

ISR(TCC0_OVF_vect) {
    12c0:	1f 92       	push	r1
    12c2:	0f 92       	push	r0
    12c4:	0f b6       	in	r0, 0x3f	; 63
    12c6:	0f 92       	push	r0
    12c8:	0b b6       	in	r0, 0x3b	; 59
    12ca:	0f 92       	push	r0
    12cc:	11 24       	eor	r1, r1
    12ce:	2f 93       	push	r18
    12d0:	3f 93       	push	r19
    12d2:	4f 93       	push	r20
    12d4:	5f 93       	push	r21
    12d6:	6f 93       	push	r22
    12d8:	7f 93       	push	r23
    12da:	8f 93       	push	r24
    12dc:	9f 93       	push	r25
    12de:	af 93       	push	r26
    12e0:	bf 93       	push	r27
    12e2:	ef 93       	push	r30
    12e4:	ff 93       	push	r31
	writeSE2FRAM();
    12e6:	0e 94 39 08 	call	0x1072	; 0x1072 <writeSE2FRAM>
}
    12ea:	ff 91       	pop	r31
    12ec:	ef 91       	pop	r30
    12ee:	bf 91       	pop	r27
    12f0:	af 91       	pop	r26
    12f2:	9f 91       	pop	r25
    12f4:	8f 91       	pop	r24
    12f6:	7f 91       	pop	r23
    12f8:	6f 91       	pop	r22
    12fa:	5f 91       	pop	r21
    12fc:	4f 91       	pop	r20
    12fe:	3f 91       	pop	r19
    1300:	2f 91       	pop	r18
    1302:	0f 90       	pop	r0
    1304:	0b be       	out	0x3b, r0	; 59
    1306:	0f 90       	pop	r0
    1308:	0f be       	out	0x3f, r0	; 63
    130a:	0f 90       	pop	r0
    130c:	1f 90       	pop	r1
    130e:	18 95       	reti

00001310 <calcChecksumFRAM>:
	checksumADC[1] += SPIBuffer[1];
	checksumADC[2] += SPIBuffer[2];
}


void calcChecksumFRAM() {
    1310:	2f 92       	push	r2
    1312:	3f 92       	push	r3
    1314:	4f 92       	push	r4
    1316:	5f 92       	push	r5
    1318:	6f 92       	push	r6
    131a:	7f 92       	push	r7
    131c:	8f 92       	push	r8
    131e:	9f 92       	push	r9
    1320:	af 92       	push	r10
    1322:	bf 92       	push	r11
    1324:	cf 92       	push	r12
    1326:	df 92       	push	r13
    1328:	ef 92       	push	r14
    132a:	ff 92       	push	r15
    132c:	0f 93       	push	r16
    132e:	1f 93       	push	r17
    1330:	cf 93       	push	r28
    1332:	df 93       	push	r29
    1334:	00 d0       	rcall	.+0      	; 0x1336 <calcChecksumFRAM+0x26>
    1336:	00 d0       	rcall	.+0      	; 0x1338 <calcChecksumFRAM+0x28>
    1338:	cd b7       	in	r28, 0x3d	; 61
    133a:	de b7       	in	r29, 0x3e	; 62
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
    133c:	e7 e7       	ldi	r30, 0x77	; 119
    133e:	f0 e5       	ldi	r31, 0x50	; 80
    1340:	10 92 77 50 	sts	0x5077, r1
    1344:	10 92 78 50 	sts	0x5078, r1
    1348:	10 92 79 50 	sts	0x5079, r1
    134c:	10 92 7a 50 	sts	0x507A, r1
    1350:	10 92 7b 50 	sts	0x507B, r1
    1354:	10 92 7c 50 	sts	0x507C, r1
    1358:	10 92 7d 50 	sts	0x507D, r1
    135c:	10 92 7e 50 	sts	0x507E, r1
    1360:	df 01       	movw	r26, r30
    1362:	18 97       	sbiw	r26, 0x08	; 8
    1364:	1c 92       	st	X, r1
    1366:	11 96       	adiw	r26, 0x01	; 1
    1368:	1c 92       	st	X, r1
    136a:	11 97       	sbiw	r26, 0x01	; 1
    136c:	12 96       	adiw	r26, 0x02	; 2
    136e:	1c 92       	st	X, r1
    1370:	12 97       	sbiw	r26, 0x02	; 2
    1372:	13 96       	adiw	r26, 0x03	; 3
    1374:	1c 92       	st	X, r1
    1376:	13 97       	sbiw	r26, 0x03	; 3
    1378:	14 96       	adiw	r26, 0x04	; 4
    137a:	1c 92       	st	X, r1
    137c:	14 97       	sbiw	r26, 0x04	; 4
    137e:	15 96       	adiw	r26, 0x05	; 5
    1380:	1c 92       	st	X, r1
    1382:	15 97       	sbiw	r26, 0x05	; 5
    1384:	16 96       	adiw	r26, 0x06	; 6
    1386:	1c 92       	st	X, r1
    1388:	16 97       	sbiw	r26, 0x06	; 6
    138a:	17 96       	adiw	r26, 0x07	; 7
    138c:	1c 92       	st	X, r1
    138e:	70 97       	sbiw	r30, 0x10	; 16
    1390:	10 82       	st	Z, r1
    1392:	11 82       	std	Z+1, r1	; 0x01
    1394:	12 82       	std	Z+2, r1	; 0x02
    1396:	13 82       	std	Z+3, r1	; 0x03
    1398:	14 82       	std	Z+4, r1	; 0x04
    139a:	15 82       	std	Z+5, r1	; 0x05
    139c:	16 82       	std	Z+6, r1	; 0x06
    139e:	17 82       	std	Z+7, r1	; 0x07
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
    13a0:	8e e1       	ldi	r24, 0x1E	; 30
    13a2:	91 e2       	ldi	r25, 0x21	; 33
    13a4:	10 92 1e 21 	sts	0x211E, r1
    13a8:	fc 01       	movw	r30, r24
    13aa:	31 97       	sbiw	r30, 0x01	; 1
    13ac:	10 82       	st	Z, r1
    13ae:	02 97       	sbiw	r24, 0x02	; 2
    13b0:	dc 01       	movw	r26, r24
    13b2:	1c 92       	st	X, r1
	FRAMAddress = FR_BASEADD;
    13b4:	10 92 3a 40 	sts	0x403A, r1
    13b8:	10 92 3b 40 	sts	0x403B, r1
    13bc:	e9 e0       	ldi	r30, 0x09	; 9
    13be:	f0 e0       	ldi	r31, 0x00	; 0
    13c0:	e9 83       	std	Y+1, r30	; 0x01
    13c2:	fa 83       	std	Y+2, r31	; 0x02
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    13c4:	0f 2e       	mov	r0, r31
    13c6:	f2 ec       	ldi	r31, 0xC2	; 194
    13c8:	8f 2e       	mov	r8, r31
    13ca:	f3 e2       	ldi	r31, 0x23	; 35
    13cc:	9f 2e       	mov	r9, r31
    13ce:	f0 2d       	mov	r31, r0
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    13d0:	44 24       	eor	r4, r4
    13d2:	4a 94       	dec	r4
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
			if(k%9 == 5) sumFRAM[1] += *temp64;
			if(k%9 == 8) sumFRAM[2] += *temp64;
    13d4:	07 e7       	ldi	r16, 0x77	; 119
    13d6:	10 e5       	ldi	r17, 0x50	; 80
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
			if(k%9 == 5) sumFRAM[1] += *temp64;
    13d8:	0f 2e       	mov	r0, r31
    13da:	ff e6       	ldi	r31, 0x6F	; 111
    13dc:	ef 2e       	mov	r14, r31
    13de:	f0 e5       	ldi	r31, 0x50	; 80
    13e0:	ff 2e       	mov	r15, r31
    13e2:	f0 2d       	mov	r31, r0
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    13e4:	0f 2e       	mov	r0, r31
    13e6:	f7 e6       	ldi	r31, 0x67	; 103
    13e8:	cf 2e       	mov	r12, r31
    13ea:	f0 e5       	ldi	r31, 0x50	; 80
    13ec:	df 2e       	mov	r13, r31
    13ee:	f0 2d       	mov	r31, r0
void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
    13f0:	81 e7       	ldi	r24, 0x71	; 113
    13f2:	9c e1       	ldi	r25, 0x1C	; 28
    13f4:	0e 94 90 1c 	call	0x3920	; 0x3920 <readFRAM>
		FRAMAddress += FR_READ_BUFFER_SIZE;
    13f8:	80 91 3a 40 	lds	r24, 0x403A
    13fc:	90 91 3b 40 	lds	r25, 0x403B
    1400:	8f 58       	subi	r24, 0x8F	; 143
    1402:	93 4e       	sbci	r25, 0xE3	; 227
    1404:	80 93 3a 40 	sts	0x403A, r24
    1408:	90 93 3b 40 	sts	0x403B, r25
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    140c:	20 e0       	ldi	r18, 0x00	; 0
    140e:	30 e0       	ldi	r19, 0x00	; 0
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    1410:	0f 2e       	mov	r0, r31
    1412:	f9 e0       	ldi	r31, 0x09	; 9
    1414:	2f 2e       	mov	r2, r31
    1416:	33 24       	eor	r3, r3
    1418:	f0 2d       	mov	r31, r0
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
			checksumFRAM[k%3] += FRAMReadBuffer[k];
    141a:	c9 01       	movw	r24, r18
    141c:	63 e0       	ldi	r22, 0x03	; 3
    141e:	70 e0       	ldi	r23, 0x00	; 0
    1420:	0e 94 39 35 	call	0x6a72	; 0x6a72 <__udivmodhi4>
    1424:	ac 01       	movw	r20, r24
    1426:	ac e1       	ldi	r26, 0x1C	; 28
    1428:	b1 e2       	ldi	r27, 0x21	; 33
    142a:	a8 0f       	add	r26, r24
    142c:	b9 1f       	adc	r27, r25
    142e:	8c 91       	ld	r24, X
    1430:	f4 01       	movw	r30, r8
    1432:	e2 0f       	add	r30, r18
    1434:	f3 1f       	adc	r31, r19
    1436:	90 81       	ld	r25, Z
    1438:	89 0f       	add	r24, r25
    143a:	8c 93       	st	X, r24
			
			// create 64 bits from 3 sample bytes
			if(k%3 == 0) {
    143c:	41 15       	cp	r20, r1
    143e:	51 05       	cpc	r21, r1
    1440:	49 f5       	brne	.+82     	; 0x1494 <calcChecksumFRAM+0x184>
				if(FRAMReadBuffer[k] & BIT7_bm) *temp64 = 0xFFFFFFFFFF000000; // sign extension if negative
    1442:	f4 01       	movw	r30, r8
    1444:	e2 0f       	add	r30, r18
    1446:	f3 1f       	adc	r31, r19
    1448:	80 81       	ld	r24, Z
    144a:	88 23       	and	r24, r24
    144c:	6c f4       	brge	.+26     	; 0x1468 <calcChecksumFRAM+0x158>
    144e:	e0 91 45 50 	lds	r30, 0x5045
    1452:	f0 91 46 50 	lds	r31, 0x5046
    1456:	10 82       	st	Z, r1
    1458:	11 82       	std	Z+1, r1	; 0x01
    145a:	12 82       	std	Z+2, r1	; 0x02
    145c:	43 82       	std	Z+3, r4	; 0x03
    145e:	44 82       	std	Z+4, r4	; 0x04
    1460:	45 82       	std	Z+5, r4	; 0x05
    1462:	46 82       	std	Z+6, r4	; 0x06
    1464:	47 82       	std	Z+7, r4	; 0x07
    1466:	0c c0       	rjmp	.+24     	; 0x1480 <calcChecksumFRAM+0x170>
				else *temp64 = 0x0000000000000000;
    1468:	e0 91 45 50 	lds	r30, 0x5045
    146c:	f0 91 46 50 	lds	r31, 0x5046
    1470:	10 82       	st	Z, r1
    1472:	11 82       	std	Z+1, r1	; 0x01
    1474:	12 82       	std	Z+2, r1	; 0x02
    1476:	13 82       	std	Z+3, r1	; 0x03
    1478:	14 82       	std	Z+4, r1	; 0x04
    147a:	15 82       	std	Z+5, r1	; 0x05
    147c:	16 82       	std	Z+6, r1	; 0x06
    147e:	17 82       	std	Z+7, r1	; 0x07
				*(((uint8_t*)temp64) + 2) = FRAMReadBuffer[k];
    1480:	f4 01       	movw	r30, r8
    1482:	e2 0f       	add	r30, r18
    1484:	f3 1f       	adc	r31, r19
    1486:	80 81       	ld	r24, Z
    1488:	e0 91 45 50 	lds	r30, 0x5045
    148c:	f0 91 46 50 	lds	r31, 0x5046
    1490:	82 83       	std	Z+2, r24	; 0x02
    1492:	18 c0       	rjmp	.+48     	; 0x14c4 <calcChecksumFRAM+0x1b4>
			} else if(k%3 == 1) {
    1494:	41 30       	cpi	r20, 0x01	; 1
    1496:	51 05       	cpc	r21, r1
    1498:	61 f4       	brne	.+24     	; 0x14b2 <calcChecksumFRAM+0x1a2>
				*(((uint8_t*)temp64) + 1) = FRAMReadBuffer[k];
    149a:	a0 91 45 50 	lds	r26, 0x5045
    149e:	b0 91 46 50 	lds	r27, 0x5046
    14a2:	f4 01       	movw	r30, r8
    14a4:	e2 0f       	add	r30, r18
    14a6:	f3 1f       	adc	r31, r19
    14a8:	80 81       	ld	r24, Z
    14aa:	11 96       	adiw	r26, 0x01	; 1
    14ac:	8c 93       	st	X, r24
    14ae:	11 97       	sbiw	r26, 0x01	; 1
    14b0:	09 c0       	rjmp	.+18     	; 0x14c4 <calcChecksumFRAM+0x1b4>
			} else {
				*(((uint8_t*)temp64) + 0) = FRAMReadBuffer[k];
    14b2:	a0 91 45 50 	lds	r26, 0x5045
    14b6:	b0 91 46 50 	lds	r27, 0x5046
    14ba:	f4 01       	movw	r30, r8
    14bc:	e2 0f       	add	r30, r18
    14be:	f3 1f       	adc	r31, r19
    14c0:	80 81       	ld	r24, Z
    14c2:	8c 93       	st	X, r24
			}
			
			if(k%9 == 2) sumFRAM[0] += *temp64;
    14c4:	c9 01       	movw	r24, r18
    14c6:	b1 01       	movw	r22, r2
    14c8:	0e 94 39 35 	call	0x6a72	; 0x6a72 <__udivmodhi4>
    14cc:	82 30       	cpi	r24, 0x02	; 2
    14ce:	91 05       	cpc	r25, r1
    14d0:	09 f0       	breq	.+2      	; 0x14d4 <calcChecksumFRAM+0x1c4>
    14d2:	74 c0       	rjmp	.+232    	; 0x15bc <calcChecksumFRAM+0x2ac>
    14d4:	f6 01       	movw	r30, r12
    14d6:	a0 81       	ld	r26, Z
    14d8:	71 81       	ldd	r23, Z+1	; 0x01
    14da:	62 81       	ldd	r22, Z+2	; 0x02
    14dc:	53 81       	ldd	r21, Z+3	; 0x03
    14de:	44 81       	ldd	r20, Z+4	; 0x04
    14e0:	95 81       	ldd	r25, Z+5	; 0x05
    14e2:	86 81       	ldd	r24, Z+6	; 0x06
    14e4:	f7 81       	ldd	r31, Z+7	; 0x07
    14e6:	fd 83       	std	Y+5, r31	; 0x05
    14e8:	e0 91 45 50 	lds	r30, 0x5045
    14ec:	f0 91 46 50 	lds	r31, 0x5046
    14f0:	50 80       	ld	r5, Z
    14f2:	b1 81       	ldd	r27, Z+1	; 0x01
    14f4:	bb 83       	std	Y+3, r27	; 0x03
    14f6:	b2 81       	ldd	r27, Z+2	; 0x02
    14f8:	b3 80       	ldd	r11, Z+3	; 0x03
    14fa:	a4 80       	ldd	r10, Z+4	; 0x04
    14fc:	75 80       	ldd	r7, Z+5	; 0x05
    14fe:	66 80       	ldd	r6, Z+6	; 0x06
    1500:	e7 81       	ldd	r30, Z+7	; 0x07
    1502:	5a 0e       	add	r5, r26
    1504:	5e 82       	std	Y+6, r5	; 0x06
    1506:	f1 e0       	ldi	r31, 0x01	; 1
    1508:	5a 16       	cp	r5, r26
    150a:	08 f0       	brcs	.+2      	; 0x150e <calcChecksumFRAM+0x1fe>
    150c:	f0 e0       	ldi	r31, 0x00	; 0
    150e:	5b 80       	ldd	r5, Y+3	; 0x03
    1510:	57 0e       	add	r5, r23
    1512:	5c 82       	std	Y+4, r5	; 0x04
    1514:	a1 e0       	ldi	r26, 0x01	; 1
    1516:	57 16       	cp	r5, r23
    1518:	08 f0       	brcs	.+2      	; 0x151c <calcChecksumFRAM+0x20c>
    151a:	a0 e0       	ldi	r26, 0x00	; 0
    151c:	7c 81       	ldd	r23, Y+4	; 0x04
    151e:	7f 0f       	add	r23, r31
    1520:	7b 83       	std	Y+3, r23	; 0x03
    1522:	71 e0       	ldi	r23, 0x01	; 1
    1524:	fb 81       	ldd	r31, Y+3	; 0x03
    1526:	5c 80       	ldd	r5, Y+4	; 0x04
    1528:	f5 15       	cp	r31, r5
    152a:	08 f0       	brcs	.+2      	; 0x152e <calcChecksumFRAM+0x21e>
    152c:	70 e0       	ldi	r23, 0x00	; 0
    152e:	a7 2b       	or	r26, r23
    1530:	b6 0f       	add	r27, r22
    1532:	71 e0       	ldi	r23, 0x01	; 1
    1534:	b6 17       	cp	r27, r22
    1536:	08 f0       	brcs	.+2      	; 0x153a <calcChecksumFRAM+0x22a>
    1538:	70 e0       	ldi	r23, 0x00	; 0
    153a:	ab 0f       	add	r26, r27
    153c:	61 e0       	ldi	r22, 0x01	; 1
    153e:	ab 17       	cp	r26, r27
    1540:	08 f0       	brcs	.+2      	; 0x1544 <calcChecksumFRAM+0x234>
    1542:	60 e0       	ldi	r22, 0x00	; 0
    1544:	76 2b       	or	r23, r22
    1546:	b5 0e       	add	r11, r21
    1548:	61 e0       	ldi	r22, 0x01	; 1
    154a:	b5 16       	cp	r11, r21
    154c:	08 f0       	brcs	.+2      	; 0x1550 <calcChecksumFRAM+0x240>
    154e:	60 e0       	ldi	r22, 0x00	; 0
    1550:	7b 0d       	add	r23, r11
    1552:	51 e0       	ldi	r21, 0x01	; 1
    1554:	7b 15       	cp	r23, r11
    1556:	08 f0       	brcs	.+2      	; 0x155a <calcChecksumFRAM+0x24a>
    1558:	50 e0       	ldi	r21, 0x00	; 0
    155a:	65 2b       	or	r22, r21
    155c:	a4 0e       	add	r10, r20
    155e:	51 e0       	ldi	r21, 0x01	; 1
    1560:	a4 16       	cp	r10, r20
    1562:	08 f0       	brcs	.+2      	; 0x1566 <calcChecksumFRAM+0x256>
    1564:	50 e0       	ldi	r21, 0x00	; 0
    1566:	6a 0d       	add	r22, r10
    1568:	41 e0       	ldi	r20, 0x01	; 1
    156a:	6a 15       	cp	r22, r10
    156c:	08 f0       	brcs	.+2      	; 0x1570 <calcChecksumFRAM+0x260>
    156e:	40 e0       	ldi	r20, 0x00	; 0
    1570:	54 2b       	or	r21, r20
    1572:	79 0e       	add	r7, r25
    1574:	41 e0       	ldi	r20, 0x01	; 1
    1576:	79 16       	cp	r7, r25
    1578:	08 f0       	brcs	.+2      	; 0x157c <calcChecksumFRAM+0x26c>
    157a:	40 e0       	ldi	r20, 0x00	; 0
    157c:	57 0d       	add	r21, r7
    157e:	91 e0       	ldi	r25, 0x01	; 1
    1580:	57 15       	cp	r21, r7
    1582:	08 f0       	brcs	.+2      	; 0x1586 <calcChecksumFRAM+0x276>
    1584:	90 e0       	ldi	r25, 0x00	; 0
    1586:	49 2b       	or	r20, r25
    1588:	68 0e       	add	r6, r24
    158a:	91 e0       	ldi	r25, 0x01	; 1
    158c:	68 16       	cp	r6, r24
    158e:	08 f0       	brcs	.+2      	; 0x1592 <calcChecksumFRAM+0x282>
    1590:	90 e0       	ldi	r25, 0x00	; 0
    1592:	46 0d       	add	r20, r6
    1594:	81 e0       	ldi	r24, 0x01	; 1
    1596:	46 15       	cp	r20, r6
    1598:	08 f0       	brcs	.+2      	; 0x159c <calcChecksumFRAM+0x28c>
    159a:	80 e0       	ldi	r24, 0x00	; 0
    159c:	98 2b       	or	r25, r24
    159e:	8d 81       	ldd	r24, Y+5	; 0x05
    15a0:	e8 0f       	add	r30, r24
    15a2:	9e 0f       	add	r25, r30
    15a4:	5e 80       	ldd	r5, Y+6	; 0x06
    15a6:	f6 01       	movw	r30, r12
    15a8:	50 82       	st	Z, r5
    15aa:	8b 81       	ldd	r24, Y+3	; 0x03
    15ac:	81 83       	std	Z+1, r24	; 0x01
    15ae:	a2 83       	std	Z+2, r26	; 0x02
    15b0:	73 83       	std	Z+3, r23	; 0x03
    15b2:	64 83       	std	Z+4, r22	; 0x04
    15b4:	55 83       	std	Z+5, r21	; 0x05
    15b6:	46 83       	std	Z+6, r20	; 0x06
    15b8:	97 83       	std	Z+7, r25	; 0x07
    15ba:	ef c0       	rjmp	.+478    	; 0x179a <calcChecksumFRAM+0x48a>
			if(k%9 == 5) sumFRAM[1] += *temp64;
    15bc:	85 30       	cpi	r24, 0x05	; 5
    15be:	91 05       	cpc	r25, r1
    15c0:	09 f0       	breq	.+2      	; 0x15c4 <calcChecksumFRAM+0x2b4>
    15c2:	74 c0       	rjmp	.+232    	; 0x16ac <calcChecksumFRAM+0x39c>
    15c4:	f7 01       	movw	r30, r14
    15c6:	a0 81       	ld	r26, Z
    15c8:	71 81       	ldd	r23, Z+1	; 0x01
    15ca:	62 81       	ldd	r22, Z+2	; 0x02
    15cc:	53 81       	ldd	r21, Z+3	; 0x03
    15ce:	44 81       	ldd	r20, Z+4	; 0x04
    15d0:	95 81       	ldd	r25, Z+5	; 0x05
    15d2:	86 81       	ldd	r24, Z+6	; 0x06
    15d4:	f7 81       	ldd	r31, Z+7	; 0x07
    15d6:	fd 83       	std	Y+5, r31	; 0x05
    15d8:	e0 91 45 50 	lds	r30, 0x5045
    15dc:	f0 91 46 50 	lds	r31, 0x5046
    15e0:	50 80       	ld	r5, Z
    15e2:	b1 81       	ldd	r27, Z+1	; 0x01
    15e4:	bb 83       	std	Y+3, r27	; 0x03
    15e6:	b2 81       	ldd	r27, Z+2	; 0x02
    15e8:	b3 80       	ldd	r11, Z+3	; 0x03
    15ea:	a4 80       	ldd	r10, Z+4	; 0x04
    15ec:	75 80       	ldd	r7, Z+5	; 0x05
    15ee:	66 80       	ldd	r6, Z+6	; 0x06
    15f0:	e7 81       	ldd	r30, Z+7	; 0x07
    15f2:	5a 0e       	add	r5, r26
    15f4:	5e 82       	std	Y+6, r5	; 0x06
    15f6:	f1 e0       	ldi	r31, 0x01	; 1
    15f8:	5a 16       	cp	r5, r26
    15fa:	08 f0       	brcs	.+2      	; 0x15fe <calcChecksumFRAM+0x2ee>
    15fc:	f0 e0       	ldi	r31, 0x00	; 0
    15fe:	5b 80       	ldd	r5, Y+3	; 0x03
    1600:	57 0e       	add	r5, r23
    1602:	5c 82       	std	Y+4, r5	; 0x04
    1604:	a1 e0       	ldi	r26, 0x01	; 1
    1606:	57 16       	cp	r5, r23
    1608:	08 f0       	brcs	.+2      	; 0x160c <calcChecksumFRAM+0x2fc>
    160a:	a0 e0       	ldi	r26, 0x00	; 0
    160c:	7c 81       	ldd	r23, Y+4	; 0x04
    160e:	7f 0f       	add	r23, r31
    1610:	7b 83       	std	Y+3, r23	; 0x03
    1612:	71 e0       	ldi	r23, 0x01	; 1
    1614:	fb 81       	ldd	r31, Y+3	; 0x03
    1616:	5c 80       	ldd	r5, Y+4	; 0x04
    1618:	f5 15       	cp	r31, r5
    161a:	08 f0       	brcs	.+2      	; 0x161e <calcChecksumFRAM+0x30e>
    161c:	70 e0       	ldi	r23, 0x00	; 0
    161e:	a7 2b       	or	r26, r23
    1620:	b6 0f       	add	r27, r22
    1622:	71 e0       	ldi	r23, 0x01	; 1
    1624:	b6 17       	cp	r27, r22
    1626:	08 f0       	brcs	.+2      	; 0x162a <calcChecksumFRAM+0x31a>
    1628:	70 e0       	ldi	r23, 0x00	; 0
    162a:	ab 0f       	add	r26, r27
    162c:	61 e0       	ldi	r22, 0x01	; 1
    162e:	ab 17       	cp	r26, r27
    1630:	08 f0       	brcs	.+2      	; 0x1634 <calcChecksumFRAM+0x324>
    1632:	60 e0       	ldi	r22, 0x00	; 0
    1634:	76 2b       	or	r23, r22
    1636:	b5 0e       	add	r11, r21
    1638:	61 e0       	ldi	r22, 0x01	; 1
    163a:	b5 16       	cp	r11, r21
    163c:	08 f0       	brcs	.+2      	; 0x1640 <calcChecksumFRAM+0x330>
    163e:	60 e0       	ldi	r22, 0x00	; 0
    1640:	7b 0d       	add	r23, r11
    1642:	51 e0       	ldi	r21, 0x01	; 1
    1644:	7b 15       	cp	r23, r11
    1646:	08 f0       	brcs	.+2      	; 0x164a <calcChecksumFRAM+0x33a>
    1648:	50 e0       	ldi	r21, 0x00	; 0
    164a:	65 2b       	or	r22, r21
    164c:	a4 0e       	add	r10, r20
    164e:	51 e0       	ldi	r21, 0x01	; 1
    1650:	a4 16       	cp	r10, r20
    1652:	08 f0       	brcs	.+2      	; 0x1656 <calcChecksumFRAM+0x346>
    1654:	50 e0       	ldi	r21, 0x00	; 0
    1656:	6a 0d       	add	r22, r10
    1658:	41 e0       	ldi	r20, 0x01	; 1
    165a:	6a 15       	cp	r22, r10
    165c:	08 f0       	brcs	.+2      	; 0x1660 <calcChecksumFRAM+0x350>
    165e:	40 e0       	ldi	r20, 0x00	; 0
    1660:	54 2b       	or	r21, r20
    1662:	79 0e       	add	r7, r25
    1664:	41 e0       	ldi	r20, 0x01	; 1
    1666:	79 16       	cp	r7, r25
    1668:	08 f0       	brcs	.+2      	; 0x166c <calcChecksumFRAM+0x35c>
    166a:	40 e0       	ldi	r20, 0x00	; 0
    166c:	57 0d       	add	r21, r7
    166e:	91 e0       	ldi	r25, 0x01	; 1
    1670:	57 15       	cp	r21, r7
    1672:	08 f0       	brcs	.+2      	; 0x1676 <calcChecksumFRAM+0x366>
    1674:	90 e0       	ldi	r25, 0x00	; 0
    1676:	49 2b       	or	r20, r25
    1678:	68 0e       	add	r6, r24
    167a:	91 e0       	ldi	r25, 0x01	; 1
    167c:	68 16       	cp	r6, r24
    167e:	08 f0       	brcs	.+2      	; 0x1682 <calcChecksumFRAM+0x372>
    1680:	90 e0       	ldi	r25, 0x00	; 0
    1682:	46 0d       	add	r20, r6
    1684:	81 e0       	ldi	r24, 0x01	; 1
    1686:	46 15       	cp	r20, r6
    1688:	08 f0       	brcs	.+2      	; 0x168c <calcChecksumFRAM+0x37c>
    168a:	80 e0       	ldi	r24, 0x00	; 0
    168c:	98 2b       	or	r25, r24
    168e:	8d 81       	ldd	r24, Y+5	; 0x05
    1690:	e8 0f       	add	r30, r24
    1692:	9e 0f       	add	r25, r30
    1694:	5e 80       	ldd	r5, Y+6	; 0x06
    1696:	f7 01       	movw	r30, r14
    1698:	50 82       	st	Z, r5
    169a:	8b 81       	ldd	r24, Y+3	; 0x03
    169c:	81 83       	std	Z+1, r24	; 0x01
    169e:	a2 83       	std	Z+2, r26	; 0x02
    16a0:	73 83       	std	Z+3, r23	; 0x03
    16a2:	64 83       	std	Z+4, r22	; 0x04
    16a4:	55 83       	std	Z+5, r21	; 0x05
    16a6:	46 83       	std	Z+6, r20	; 0x06
    16a8:	97 83       	std	Z+7, r25	; 0x07
    16aa:	77 c0       	rjmp	.+238    	; 0x179a <calcChecksumFRAM+0x48a>
			if(k%9 == 8) sumFRAM[2] += *temp64;
    16ac:	88 30       	cpi	r24, 0x08	; 8
    16ae:	91 05       	cpc	r25, r1
    16b0:	09 f0       	breq	.+2      	; 0x16b4 <calcChecksumFRAM+0x3a4>
    16b2:	73 c0       	rjmp	.+230    	; 0x179a <calcChecksumFRAM+0x48a>
    16b4:	f8 01       	movw	r30, r16
    16b6:	a0 81       	ld	r26, Z
    16b8:	71 81       	ldd	r23, Z+1	; 0x01
    16ba:	62 81       	ldd	r22, Z+2	; 0x02
    16bc:	53 81       	ldd	r21, Z+3	; 0x03
    16be:	44 81       	ldd	r20, Z+4	; 0x04
    16c0:	95 81       	ldd	r25, Z+5	; 0x05
    16c2:	86 81       	ldd	r24, Z+6	; 0x06
    16c4:	f7 81       	ldd	r31, Z+7	; 0x07
    16c6:	fd 83       	std	Y+5, r31	; 0x05
    16c8:	e0 91 45 50 	lds	r30, 0x5045
    16cc:	f0 91 46 50 	lds	r31, 0x5046
    16d0:	50 80       	ld	r5, Z
    16d2:	b1 81       	ldd	r27, Z+1	; 0x01
    16d4:	bb 83       	std	Y+3, r27	; 0x03
    16d6:	b2 81       	ldd	r27, Z+2	; 0x02
    16d8:	b3 80       	ldd	r11, Z+3	; 0x03
    16da:	a4 80       	ldd	r10, Z+4	; 0x04
    16dc:	75 80       	ldd	r7, Z+5	; 0x05
    16de:	66 80       	ldd	r6, Z+6	; 0x06
    16e0:	e7 81       	ldd	r30, Z+7	; 0x07
    16e2:	5a 0e       	add	r5, r26
    16e4:	5e 82       	std	Y+6, r5	; 0x06
    16e6:	f1 e0       	ldi	r31, 0x01	; 1
    16e8:	5a 16       	cp	r5, r26
    16ea:	08 f0       	brcs	.+2      	; 0x16ee <calcChecksumFRAM+0x3de>
    16ec:	f0 e0       	ldi	r31, 0x00	; 0
    16ee:	5b 80       	ldd	r5, Y+3	; 0x03
    16f0:	57 0e       	add	r5, r23
    16f2:	5c 82       	std	Y+4, r5	; 0x04
    16f4:	a1 e0       	ldi	r26, 0x01	; 1
    16f6:	57 16       	cp	r5, r23
    16f8:	08 f0       	brcs	.+2      	; 0x16fc <calcChecksumFRAM+0x3ec>
    16fa:	a0 e0       	ldi	r26, 0x00	; 0
    16fc:	7c 81       	ldd	r23, Y+4	; 0x04
    16fe:	7f 0f       	add	r23, r31
    1700:	7b 83       	std	Y+3, r23	; 0x03
    1702:	71 e0       	ldi	r23, 0x01	; 1
    1704:	fb 81       	ldd	r31, Y+3	; 0x03
    1706:	5c 80       	ldd	r5, Y+4	; 0x04
    1708:	f5 15       	cp	r31, r5
    170a:	08 f0       	brcs	.+2      	; 0x170e <calcChecksumFRAM+0x3fe>
    170c:	70 e0       	ldi	r23, 0x00	; 0
    170e:	a7 2b       	or	r26, r23
    1710:	b6 0f       	add	r27, r22
    1712:	71 e0       	ldi	r23, 0x01	; 1
    1714:	b6 17       	cp	r27, r22
    1716:	08 f0       	brcs	.+2      	; 0x171a <calcChecksumFRAM+0x40a>
    1718:	70 e0       	ldi	r23, 0x00	; 0
    171a:	ab 0f       	add	r26, r27
    171c:	61 e0       	ldi	r22, 0x01	; 1
    171e:	ab 17       	cp	r26, r27
    1720:	08 f0       	brcs	.+2      	; 0x1724 <calcChecksumFRAM+0x414>
    1722:	60 e0       	ldi	r22, 0x00	; 0
    1724:	76 2b       	or	r23, r22
    1726:	b5 0e       	add	r11, r21
    1728:	61 e0       	ldi	r22, 0x01	; 1
    172a:	b5 16       	cp	r11, r21
    172c:	08 f0       	brcs	.+2      	; 0x1730 <calcChecksumFRAM+0x420>
    172e:	60 e0       	ldi	r22, 0x00	; 0
    1730:	7b 0d       	add	r23, r11
    1732:	51 e0       	ldi	r21, 0x01	; 1
    1734:	7b 15       	cp	r23, r11
    1736:	08 f0       	brcs	.+2      	; 0x173a <calcChecksumFRAM+0x42a>
    1738:	50 e0       	ldi	r21, 0x00	; 0
    173a:	65 2b       	or	r22, r21
    173c:	a4 0e       	add	r10, r20
    173e:	51 e0       	ldi	r21, 0x01	; 1
    1740:	a4 16       	cp	r10, r20
    1742:	08 f0       	brcs	.+2      	; 0x1746 <calcChecksumFRAM+0x436>
    1744:	50 e0       	ldi	r21, 0x00	; 0
    1746:	6a 0d       	add	r22, r10
    1748:	41 e0       	ldi	r20, 0x01	; 1
    174a:	6a 15       	cp	r22, r10
    174c:	08 f0       	brcs	.+2      	; 0x1750 <calcChecksumFRAM+0x440>
    174e:	40 e0       	ldi	r20, 0x00	; 0
    1750:	54 2b       	or	r21, r20
    1752:	79 0e       	add	r7, r25
    1754:	41 e0       	ldi	r20, 0x01	; 1
    1756:	79 16       	cp	r7, r25
    1758:	08 f0       	brcs	.+2      	; 0x175c <calcChecksumFRAM+0x44c>
    175a:	40 e0       	ldi	r20, 0x00	; 0
    175c:	57 0d       	add	r21, r7
    175e:	91 e0       	ldi	r25, 0x01	; 1
    1760:	57 15       	cp	r21, r7
    1762:	08 f0       	brcs	.+2      	; 0x1766 <calcChecksumFRAM+0x456>
    1764:	90 e0       	ldi	r25, 0x00	; 0
    1766:	49 2b       	or	r20, r25
    1768:	68 0e       	add	r6, r24
    176a:	91 e0       	ldi	r25, 0x01	; 1
    176c:	68 16       	cp	r6, r24
    176e:	08 f0       	brcs	.+2      	; 0x1772 <calcChecksumFRAM+0x462>
    1770:	90 e0       	ldi	r25, 0x00	; 0
    1772:	46 0d       	add	r20, r6
    1774:	81 e0       	ldi	r24, 0x01	; 1
    1776:	46 15       	cp	r20, r6
    1778:	08 f0       	brcs	.+2      	; 0x177c <calcChecksumFRAM+0x46c>
    177a:	80 e0       	ldi	r24, 0x00	; 0
    177c:	98 2b       	or	r25, r24
    177e:	8d 81       	ldd	r24, Y+5	; 0x05
    1780:	e8 0f       	add	r30, r24
    1782:	9e 0f       	add	r25, r30
    1784:	5e 80       	ldd	r5, Y+6	; 0x06
    1786:	f8 01       	movw	r30, r16
    1788:	50 82       	st	Z, r5
    178a:	8b 81       	ldd	r24, Y+3	; 0x03
    178c:	81 83       	std	Z+1, r24	; 0x01
    178e:	a2 83       	std	Z+2, r26	; 0x02
    1790:	73 83       	std	Z+3, r23	; 0x03
    1792:	64 83       	std	Z+4, r22	; 0x04
    1794:	55 83       	std	Z+5, r21	; 0x05
    1796:	46 83       	std	Z+6, r20	; 0x06
    1798:	97 83       	std	Z+7, r25	; 0x07
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
		readFRAM(FR_READ_BUFFER_SIZE);
		FRAMAddress += FR_READ_BUFFER_SIZE;
		for(uint16_t k = 0; k < FR_READ_BUFFER_SIZE; k++) {
    179a:	2f 5f       	subi	r18, 0xFF	; 255
    179c:	3f 4f       	sbci	r19, 0xFF	; 255
    179e:	9c e1       	ldi	r25, 0x1C	; 28
    17a0:	21 37       	cpi	r18, 0x71	; 113
    17a2:	39 07       	cpc	r19, r25
    17a4:	09 f0       	breq	.+2      	; 0x17a8 <calcChecksumFRAM+0x498>
    17a6:	39 ce       	rjmp	.-910    	; 0x141a <calcChecksumFRAM+0x10a>
    17a8:	a9 81       	ldd	r26, Y+1	; 0x01
    17aa:	ba 81       	ldd	r27, Y+2	; 0x02
    17ac:	11 97       	sbiw	r26, 0x01	; 1
    17ae:	a9 83       	std	Y+1, r26	; 0x01
    17b0:	ba 83       	std	Y+2, r27	; 0x02

void calcChecksumFRAM() {
	sumFRAM[0] = sumFRAM[1] = sumFRAM[2] = 0;
	checksumFRAM[0] = checksumFRAM[1] = checksumFRAM[2] = 0;
	FRAMAddress = FR_BASEADD;
	for (uint16_t bufferNum = 0; bufferNum < FR_NUM_READ_BUFFERS; bufferNum++) {
    17b2:	10 97       	sbiw	r26, 0x00	; 0
    17b4:	09 f0       	breq	.+2      	; 0x17b8 <calcChecksumFRAM+0x4a8>
    17b6:	1c ce       	rjmp	.-968    	; 0x13f0 <calcChecksumFRAM+0xe0>
			
		}
		
	}
	
}
    17b8:	26 96       	adiw	r28, 0x06	; 6
    17ba:	cd bf       	out	0x3d, r28	; 61
    17bc:	de bf       	out	0x3e, r29	; 62
    17be:	df 91       	pop	r29
    17c0:	cf 91       	pop	r28
    17c2:	1f 91       	pop	r17
    17c4:	0f 91       	pop	r16
    17c6:	ff 90       	pop	r15
    17c8:	ef 90       	pop	r14
    17ca:	df 90       	pop	r13
    17cc:	cf 90       	pop	r12
    17ce:	bf 90       	pop	r11
    17d0:	af 90       	pop	r10
    17d2:	9f 90       	pop	r9
    17d4:	8f 90       	pop	r8
    17d6:	7f 90       	pop	r7
    17d8:	6f 90       	pop	r6
    17da:	5f 90       	pop	r5
    17dc:	4f 90       	pop	r4
    17de:	3f 90       	pop	r3
    17e0:	2f 90       	pop	r2
    17e2:	08 95       	ret

000017e4 <FRAMWriteKnowns>:


void FRAMWriteKnowns() {
    17e4:	2f 92       	push	r2
    17e6:	3f 92       	push	r3
    17e8:	4f 92       	push	r4
    17ea:	5f 92       	push	r5
    17ec:	6f 92       	push	r6
    17ee:	7f 92       	push	r7
    17f0:	8f 92       	push	r8
    17f2:	9f 92       	push	r9
    17f4:	af 92       	push	r10
    17f6:	bf 92       	push	r11
    17f8:	cf 92       	push	r12
    17fa:	df 92       	push	r13
    17fc:	ef 92       	push	r14
    17fe:	ff 92       	push	r15
    1800:	0f 93       	push	r16
    1802:	1f 93       	push	r17
    1804:	cf 93       	push	r28
    1806:	df 93       	push	r29
	FRAMAddress = FR_BASEADD;
    1808:	10 92 3a 40 	sts	0x403A, r1
    180c:	10 92 3b 40 	sts	0x403B, r1
	sampleCount = 0;
    1810:	10 92 54 50 	sts	0x5054, r1
    1814:	10 92 55 50 	sts	0x5055, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    1818:	81 e2       	ldi	r24, 0x21	; 33
    181a:	91 e2       	ldi	r25, 0x21	; 33
    181c:	10 92 21 21 	sts	0x2121, r1
    1820:	fc 01       	movw	r30, r24
    1822:	31 97       	sbiw	r30, 0x01	; 1
    1824:	10 82       	st	Z, r1
    1826:	02 97       	sbiw	r24, 0x02	; 2
    1828:	ec 01       	movw	r28, r24
    182a:	18 82       	st	Y, r1
	
	ADCPower(TRUE);
    182c:	81 e0       	ldi	r24, 0x01	; 1
    182e:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
	SPIInit(SPI_MODE_1_gc);
    1832:	84 e0       	ldi	r24, 0x04	; 4
    1834:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    1838:	80 ed       	ldi	r24, 0xD0	; 208
    183a:	80 93 c0 08 	sts	0x08C0, r24
	SPIBuffer[0] = 0x0D;
    183e:	8d e0       	ldi	r24, 0x0D	; 13
    1840:	80 93 47 50 	sts	0x5047, r24
	SPIBuffer[1] = 0xF3;
    1844:	83 ef       	ldi	r24, 0xF3	; 243
    1846:	80 93 48 50 	sts	0x5048, r24
	SPIBuffer[2] = 0x57;
    184a:	87 e5       	ldi	r24, 0x57	; 87
    184c:	80 93 49 50 	sts	0x5049, r24
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    1850:	80 91 54 50 	lds	r24, 0x5054
    1854:	90 91 55 50 	lds	r25, 0x5055
    1858:	d5 e5       	ldi	r29, 0x55	; 85
    185a:	83 35       	cpi	r24, 0x53	; 83
    185c:	9d 07       	cpc	r25, r29
    185e:	08 f0       	brcs	.+2      	; 0x1862 <FRAMWriteKnowns+0x7e>
    1860:	ac c0       	rjmp	.+344    	; 0x19ba <FRAMWriteKnowns+0x1d6>
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    1862:	00 e4       	ldi	r16, 0x40	; 64
    1864:	16 e0       	ldi	r17, 0x06	; 6
    1866:	30 e1       	ldi	r19, 0x10	; 16
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    1868:	28 e0       	ldi	r18, 0x08	; 8
		nop();
		SPIC.DATA = FR_WREN;
    186a:	e0 ec       	ldi	r30, 0xC0	; 192
    186c:	f8 e0       	ldi	r31, 0x08	; 8
    186e:	0f 2e       	mov	r0, r31
    1870:	f6 e0       	ldi	r31, 0x06	; 6
    1872:	9f 2e       	mov	r9, r31
    1874:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    1876:	a3 e5       	ldi	r26, 0x53	; 83
    1878:	b0 e5       	ldi	r27, 0x50	; 80
		PORTB.OUTSET = PIN3_bm;  // latch opcode
		nop(); // time for CS_FRAM to accept high signal
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
		nop();
		SPIC.DATA = FR_WRITE;
    187a:	88 24       	eor	r8, r8
    187c:	68 94       	set
    187e:	81 f8       	bld	r8, 1
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    1880:	0f 2e       	mov	r0, r31
    1882:	fa e3       	ldi	r31, 0x3A	; 58
    1884:	ef 2e       	mov	r14, r31
    1886:	f0 e4       	ldi	r31, 0x40	; 64
    1888:	ff 2e       	mov	r15, r31
    188a:	f0 2d       	mov	r31, r0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[0];
    188c:	bd 01       	movw	r22, r26
    188e:	6c 50       	subi	r22, 0x0C	; 12
    1890:	70 40       	sbci	r23, 0x00	; 0
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[1];
    1892:	0f 2e       	mov	r0, r31
    1894:	f5 ef       	ldi	r31, 0xF5	; 245
    1896:	6f 2e       	mov	r6, r31
    1898:	ff ef       	ldi	r31, 0xFF	; 255
    189a:	7f 2e       	mov	r7, r31
    189c:	f0 2d       	mov	r31, r0
    189e:	6a 0e       	add	r6, r26
    18a0:	7b 1e       	adc	r7, r27
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
		SPIC.DATA = SPIBuffer[2];
    18a2:	0f 2e       	mov	r0, r31
    18a4:	f6 ef       	ldi	r31, 0xF6	; 246
    18a6:	4f 2e       	mov	r4, r31
    18a8:	ff ef       	ldi	r31, 0xFF	; 255
    18aa:	5f 2e       	mov	r5, r31
    18ac:	f0 2d       	mov	r31, r0
    18ae:	4a 0e       	add	r4, r26
    18b0:	5b 1e       	adc	r5, r27
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
		
		FRAMAddress +=3;
		checksumADC[0] += SPIBuffer[0];
    18b2:	4f e1       	ldi	r20, 0x1F	; 31
    18b4:	51 e2       	ldi	r21, 0x21	; 33
		checksumADC[1] += SPIBuffer[1];
    18b6:	6a 01       	movw	r12, r20
    18b8:	08 94       	sec
    18ba:	c1 1c       	adc	r12, r1
    18bc:	d1 1c       	adc	r13, r1
    18be:	1b 01       	movw	r2, r22
    18c0:	08 94       	sec
    18c2:	21 1c       	adc	r2, r1
    18c4:	31 1c       	adc	r3, r1
		checksumADC[2] += SPIBuffer[2];
    18c6:	aa 24       	eor	r10, r10
    18c8:	bb 24       	eor	r11, r11
    18ca:	68 94       	set
    18cc:	a1 f8       	bld	r10, 1
    18ce:	a4 0e       	add	r10, r20
    18d0:	b5 1e       	adc	r11, r21
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
		PORTC.OUTCLR = PIN4_bm;  // enable SPI-SS
    18d2:	e8 01       	movw	r28, r16
    18d4:	3e 83       	std	Y+6, r19	; 0x06
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    18d6:	20 93 26 06 	sts	0x0626, r18
		nop();
    18da:	00 00       	nop
		SPIC.DATA = FR_WREN;
    18dc:	93 82       	std	Z+3, r9	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    18de:	82 81       	ldd	r24, Z+2	; 0x02
    18e0:	88 23       	and	r24, r24
    18e2:	ec f7       	brge	.-6      	; 0x18de <FRAMWriteKnowns+0xfa>
		SPIBuffer[12] = SPIC.DATA;
    18e4:	83 81       	ldd	r24, Z+3	; 0x03
    18e6:	8c 93       	st	X, r24
		PORTB.OUTSET = PIN3_bm;  // latch opcode
    18e8:	20 93 25 06 	sts	0x0625, r18
		nop(); // time for CS_FRAM to accept high signal
    18ec:	00 00       	nop
		PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    18ee:	20 93 26 06 	sts	0x0626, r18
		nop();
    18f2:	00 00       	nop
		SPIC.DATA = FR_WRITE;
    18f4:	83 82       	std	Z+3, r8	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    18f6:	82 81       	ldd	r24, Z+2	; 0x02
    18f8:	88 23       	and	r24, r24
    18fa:	ec f7       	brge	.-6      	; 0x18f6 <FRAMWriteKnowns+0x112>
		SPIBuffer[12] = SPIC.DATA;
    18fc:	83 81       	ldd	r24, Z+3	; 0x03
    18fe:	8c 93       	st	X, r24
		SPIC.DATA = *(((uint8_t*)&FRAMAddress)+1);
    1900:	e7 01       	movw	r28, r14
    1902:	89 81       	ldd	r24, Y+1	; 0x01
    1904:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1906:	82 81       	ldd	r24, Z+2	; 0x02
    1908:	88 23       	and	r24, r24
    190a:	ec f7       	brge	.-6      	; 0x1906 <FRAMWriteKnowns+0x122>
		SPIBuffer[12] = SPIC.DATA;
    190c:	83 81       	ldd	r24, Z+3	; 0x03
    190e:	8c 93       	st	X, r24
		SPIC.DATA = *((uint8_t*)&FRAMAddress);
    1910:	e7 01       	movw	r28, r14
    1912:	88 81       	ld	r24, Y
    1914:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1916:	82 81       	ldd	r24, Z+2	; 0x02
    1918:	88 23       	and	r24, r24
    191a:	ec f7       	brge	.-6      	; 0x1916 <FRAMWriteKnowns+0x132>
		SPIBuffer[12] = SPIC.DATA;
    191c:	83 81       	ldd	r24, Z+3	; 0x03
    191e:	8c 93       	st	X, r24
		SPIC.DATA = SPIBuffer[0];
    1920:	eb 01       	movw	r28, r22
    1922:	88 81       	ld	r24, Y
    1924:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1926:	82 81       	ldd	r24, Z+2	; 0x02
    1928:	88 23       	and	r24, r24
    192a:	ec f7       	brge	.-6      	; 0x1926 <FRAMWriteKnowns+0x142>
		SPIBuffer[12] = SPIC.DATA;
    192c:	83 81       	ldd	r24, Z+3	; 0x03
    192e:	8c 93       	st	X, r24
		SPIC.DATA = SPIBuffer[1];
    1930:	e3 01       	movw	r28, r6
    1932:	88 81       	ld	r24, Y
    1934:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1936:	82 81       	ldd	r24, Z+2	; 0x02
    1938:	88 23       	and	r24, r24
    193a:	ec f7       	brge	.-6      	; 0x1936 <FRAMWriteKnowns+0x152>
		SPIBuffer[12] = SPIC.DATA;
    193c:	83 81       	ldd	r24, Z+3	; 0x03
    193e:	8c 93       	st	X, r24
		SPIC.DATA = SPIBuffer[2];
    1940:	e2 01       	movw	r28, r4
    1942:	88 81       	ld	r24, Y
    1944:	83 83       	std	Z+3, r24	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm));
    1946:	82 81       	ldd	r24, Z+2	; 0x02
    1948:	88 23       	and	r24, r24
    194a:	ec f7       	brge	.-6      	; 0x1946 <FRAMWriteKnowns+0x162>
		SPIBuffer[12] = SPIC.DATA;
    194c:	83 81       	ldd	r24, Z+3	; 0x03
    194e:	8c 93       	st	X, r24
		
		PORTB.OUTSET = PIN3_bm;  // pull up CS_FRAM to write protect
    1950:	20 93 25 06 	sts	0x0625, r18
		PORTC.OUTSET = PIN4_bm;  // disable SPI-SS
    1954:	e8 01       	movw	r28, r16
    1956:	3d 83       	std	Y+5, r19	; 0x05
		
		FRAMAddress +=3;
    1958:	80 91 3a 40 	lds	r24, 0x403A
    195c:	90 91 3b 40 	lds	r25, 0x403B
    1960:	03 96       	adiw	r24, 0x03	; 3
    1962:	80 93 3a 40 	sts	0x403A, r24
    1966:	90 93 3b 40 	sts	0x403B, r25
		checksumADC[0] += SPIBuffer[0];
    196a:	ea 01       	movw	r28, r20
    196c:	88 81       	ld	r24, Y
    196e:	eb 01       	movw	r28, r22
    1970:	98 81       	ld	r25, Y
    1972:	89 0f       	add	r24, r25
    1974:	ea 01       	movw	r28, r20
    1976:	88 83       	st	Y, r24
		checksumADC[1] += SPIBuffer[1];
    1978:	e6 01       	movw	r28, r12
    197a:	88 81       	ld	r24, Y
    197c:	e1 01       	movw	r28, r2
    197e:	98 81       	ld	r25, Y
    1980:	89 0f       	add	r24, r25
    1982:	e6 01       	movw	r28, r12
    1984:	88 83       	st	Y, r24
		checksumADC[2] += SPIBuffer[2];
    1986:	e5 01       	movw	r28, r10
    1988:	88 81       	ld	r24, Y
    198a:	c9 e4       	ldi	r28, 0x49	; 73
    198c:	d0 e5       	ldi	r29, 0x50	; 80
    198e:	98 81       	ld	r25, Y
    1990:	89 0f       	add	r24, r25
    1992:	e5 01       	movw	r28, r10
    1994:	88 83       	st	Y, r24
		
		sampleCount++;
    1996:	80 91 54 50 	lds	r24, 0x5054
    199a:	90 91 55 50 	lds	r25, 0x5055
    199e:	01 96       	adiw	r24, 0x01	; 1
    19a0:	80 93 54 50 	sts	0x5054, r24
    19a4:	90 93 55 50 	sts	0x5055, r25
	SPIC.CTRL = FR_SPI_CONFIG_gc;
	SPIBuffer[0] = 0x0D;
	SPIBuffer[1] = 0xF3;
	SPIBuffer[2] = 0x57;
	
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES) {
    19a8:	80 91 54 50 	lds	r24, 0x5054
    19ac:	90 91 55 50 	lds	r25, 0x5055
    19b0:	d5 e5       	ldi	r29, 0x55	; 85
    19b2:	83 35       	cpi	r24, 0x53	; 83
    19b4:	9d 07       	cpc	r25, r29
    19b6:	08 f4       	brcc	.+2      	; 0x19ba <FRAMWriteKnowns+0x1d6>
    19b8:	8c cf       	rjmp	.-232    	; 0x18d2 <FRAMWriteKnowns+0xee>
		checksumADC[2] += SPIBuffer[2];
		
		sampleCount++;
	}
	
	SPIDisable();
    19ba:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>
	ADCPower(FALSE);
    19be:	80 e0       	ldi	r24, 0x00	; 0
    19c0:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
}
    19c4:	df 91       	pop	r29
    19c6:	cf 91       	pop	r28
    19c8:	1f 91       	pop	r17
    19ca:	0f 91       	pop	r16
    19cc:	ff 90       	pop	r15
    19ce:	ef 90       	pop	r14
    19d0:	df 90       	pop	r13
    19d2:	cf 90       	pop	r12
    19d4:	bf 90       	pop	r11
    19d6:	af 90       	pop	r10
    19d8:	9f 90       	pop	r9
    19da:	8f 90       	pop	r8
    19dc:	7f 90       	pop	r7
    19de:	6f 90       	pop	r6
    19e0:	5f 90       	pop	r5
    19e2:	4f 90       	pop	r4
    19e4:	3f 90       	pop	r3
    19e6:	2f 90       	pop	r2
    19e8:	08 95       	ret

000019ea <setADCInput>:

/*! \brief Sets input channel to AD7767 via the A0, A1, A2 control lines of ADG758
 */
void setADCInput(uint8_t channel) {
	// set bit A0 to LSB
	if(channel & BIT0_bm) {PORTA.OUTSET = PIN6_bm;}
    19ea:	80 ff       	sbrs	r24, 0
    19ec:	05 c0       	rjmp	.+10     	; 0x19f8 <setADCInput+0xe>
    19ee:	20 e4       	ldi	r18, 0x40	; 64
    19f0:	e0 e0       	ldi	r30, 0x00	; 0
    19f2:	f6 e0       	ldi	r31, 0x06	; 6
    19f4:	25 83       	std	Z+5, r18	; 0x05
    19f6:	04 c0       	rjmp	.+8      	; 0x1a00 <setADCInput+0x16>
	else {PORTA.OUTCLR = PIN6_bm;}
    19f8:	20 e4       	ldi	r18, 0x40	; 64
    19fa:	e0 e0       	ldi	r30, 0x00	; 0
    19fc:	f6 e0       	ldi	r31, 0x06	; 6
    19fe:	26 83       	std	Z+6, r18	; 0x06
	// set bit A1 to second bit
	if(channel & BIT1_bm) {PORTB.OUTSET = PIN1_bm;}
    1a00:	81 ff       	sbrs	r24, 1
    1a02:	05 c0       	rjmp	.+10     	; 0x1a0e <setADCInput+0x24>
    1a04:	22 e0       	ldi	r18, 0x02	; 2
    1a06:	e0 e2       	ldi	r30, 0x20	; 32
    1a08:	f6 e0       	ldi	r31, 0x06	; 6
    1a0a:	25 83       	std	Z+5, r18	; 0x05
    1a0c:	04 c0       	rjmp	.+8      	; 0x1a16 <setADCInput+0x2c>
	else {PORTB.OUTCLR = PIN1_bm;}
    1a0e:	22 e0       	ldi	r18, 0x02	; 2
    1a10:	e0 e2       	ldi	r30, 0x20	; 32
    1a12:	f6 e0       	ldi	r31, 0x06	; 6
    1a14:	26 83       	std	Z+6, r18	; 0x06
	// set bit A3 to third bit
	if(channel & BIT2_bm) {PORTB.OUTSET = PIN2_bm;}
    1a16:	82 ff       	sbrs	r24, 2
    1a18:	05 c0       	rjmp	.+10     	; 0x1a24 <setADCInput+0x3a>
    1a1a:	84 e0       	ldi	r24, 0x04	; 4
    1a1c:	e0 e2       	ldi	r30, 0x20	; 32
    1a1e:	f6 e0       	ldi	r31, 0x06	; 6
    1a20:	85 83       	std	Z+5, r24	; 0x05
    1a22:	08 95       	ret
	else {PORTB.OUTCLR = PIN2_bm;}
    1a24:	84 e0       	ldi	r24, 0x04	; 4
    1a26:	e0 e2       	ldi	r30, 0x20	; 32
    1a28:	f6 e0       	ldi	r31, 0x06	; 6
    1a2a:	86 83       	std	Z+6, r24	; 0x06
    1a2c:	08 95       	ret

00001a2e <CO_collectSeismic1Channel>:

ISR(TCC0_OVF_vect) {
	writeSE2FRAM();
}

void CO_collectSeismic1Channel(uint8_t channel, uint8_t filterConfig, uint8_t gain, uint8_t subsamplesPerSecond, uint8_t subsamplesPerSample, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB, uint16_t averagingPtC, uint16_t averagingPtD) {
    1a2e:	6f 92       	push	r6
    1a30:	7f 92       	push	r7
    1a32:	8f 92       	push	r8
    1a34:	9f 92       	push	r9
    1a36:	af 92       	push	r10
    1a38:	bf 92       	push	r11
    1a3a:	cf 92       	push	r12
    1a3c:	df 92       	push	r13
    1a3e:	ef 92       	push	r14
    1a40:	ff 92       	push	r15
    1a42:	0f 93       	push	r16
    1a44:	1f 93       	push	r17
    1a46:	cf 93       	push	r28
    1a48:	df 93       	push	r29
    1a4a:	cd b7       	in	r28, 0x3d	; 61
    1a4c:	de b7       	in	r29, 0x3e	; 62
    1a4e:	18 2f       	mov	r17, r24
    1a50:	76 2e       	mov	r7, r22
    1a52:	f4 2e       	mov	r15, r20
    1a54:	62 2e       	mov	r6, r18
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1a56:	81 e0       	ldi	r24, 0x01	; 1
    1a58:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
	
	// Set gains, filters, and input channel
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gain);
    1a5c:	81 2f       	mov	r24, r17
    1a5e:	6f 2d       	mov	r22, r15
    1a60:	0e 94 39 01 	call	0x272	; 0x272 <set_ampGain>
	set_filter(filterConfig);
    1a64:	87 2d       	mov	r24, r7
    1a66:	0e 94 72 01 	call	0x2e4	; 0x2e4 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    1a6a:	8e 2d       	mov	r24, r14
    1a6c:	0e 94 8c 06 	call	0xd18	; 0xd18 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    1a70:	84 e0       	ldi	r24, 0x04	; 4
    1a72:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1a76:	84 e5       	ldi	r24, 0x54	; 84
    1a78:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    1a7c:	81 e0       	ldi	r24, 0x01	; 1
    1a7e:	0e 94 9f 04 	call	0x93e	; 0x93e <enableADCMUX>
	setADCInput(channel);
    1a82:	81 2f       	mov	r24, r17
    1a84:	0e 94 f5 0c 	call	0x19ea	; 0x19ea <setADCInput>
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    1a88:	e0 ea       	ldi	r30, 0xA0	; 160
    1a8a:	f6 e0       	ldi	r31, 0x06	; 6
    1a8c:	82 e0       	ldi	r24, 0x02	; 2
    1a8e:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    1a90:	91 e0       	ldi	r25, 0x01	; 1
    1a92:	92 83       	std	Z+2, r25	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    1a94:	98 e7       	ldi	r25, 0x78	; 120
    1a96:	90 93 80 01 	sts	0x0180, r25

	// Configure counter for IO13(PF0) events
	TCD0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    1a9a:	e0 e0       	ldi	r30, 0x00	; 0
    1a9c:	f9 e0       	ldi	r31, 0x09	; 9
    1a9e:	90 ef       	ldi	r25, 0xF0	; 240
    1aa0:	91 83       	std	Z+1, r25	; 0x01
	TCD0.CCA = averagingPtA;
    1aa2:	c0 a6       	lds	r28, 0xb0
    1aa4:	d1 a6       	lds	r29, 0xb1
	TCD0.CCB = averagingPtB;
    1aa6:	a2 a6       	lds	r26, 0xb2
    1aa8:	b3 a6       	lds	r27, 0xb3
	TCD0.CCC = averagingPtC;
    1aaa:	84 a6       	lds	r24, 0xb4
    1aac:	95 a6       	lds	r25, 0xb5
	TCD0.CCD = averagingPtD;
    1aae:	2a 89       	ldd	r18, Y+18	; 0x12
    1ab0:	3b 89       	ldd	r19, Y+19	; 0x13
    1ab2:	26 a7       	lds	r18, 0x76
    1ab4:	37 a7       	lds	r19, 0x77
	TCD0.PER = subsamplesPerSample - 1;
    1ab6:	10 e0       	ldi	r17, 0x00	; 0
    1ab8:	01 50       	subi	r16, 0x01	; 1
    1aba:	10 40       	sbci	r17, 0x00	; 0
    1abc:	06 a3       	lds	r16, 0x56
    1abe:	17 a3       	lds	r17, 0x57
	TCD0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    1ac0:	86 83       	std	Z+6, r24	; 0x06
	TCD0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    1ac2:	8f ef       	ldi	r24, 0xFF	; 255
    1ac4:	87 83       	std	Z+7, r24	; 0x07
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    1ac6:	80 81       	ld	r24, Z
    1ac8:	80 7f       	andi	r24, 0xF0	; 240
    1aca:	88 60       	ori	r24, 0x08	; 8
    1acc:	80 83       	st	Z, r24

	FRAMAddress = FR_BASEADD;
    1ace:	10 92 3a 40 	sts	0x403A, r1
    1ad2:	10 92 3b 40 	sts	0x403B, r1
	sampleCount = 0;
    1ad6:	10 92 54 50 	sts	0x5054, r1
    1ada:	10 92 55 50 	sts	0x5055, r1
	SPICount = 0;
    1ade:	10 92 aa 50 	sts	0x50AA, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    1ae2:	81 e2       	ldi	r24, 0x21	; 33
    1ae4:	91 e2       	ldi	r25, 0x21	; 33
    1ae6:	10 92 21 21 	sts	0x2121, r1
    1aea:	fc 01       	movw	r30, r24
    1aec:	31 97       	sbiw	r30, 0x01	; 1
    1aee:	10 82       	st	Z, r1
    1af0:	02 97       	sbiw	r24, 0x02	; 2
    1af2:	fc 01       	movw	r30, r24
    1af4:	10 82       	st	Z, r1
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm;
    1af6:	e0 ea       	ldi	r30, 0xA0	; 160
    1af8:	f0 e0       	ldi	r31, 0x00	; 0
    1afa:	82 81       	ldd	r24, Z+2	; 0x02
    1afc:	86 60       	ori	r24, 0x06	; 6
    1afe:	82 83       	std	Z+2, r24	; 0x02
	sei();
    1b00:	78 94       	sei

	SPICS(TRUE);
    1b02:	81 e0       	ldi	r24, 0x01	; 1
    1b04:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    1b08:	80 e2       	ldi	r24, 0x20	; 32
    1b0a:	e0 e8       	ldi	r30, 0x80	; 128
    1b0c:	f6 e0       	ldi	r31, 0x06	; 6
    1b0e:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1b10:	e0 e4       	ldi	r30, 0x40	; 64
    1b12:	fa e0       	ldi	r31, 0x0A	; 10
    1b14:	83 e2       	ldi	r24, 0x23	; 35
    1b16:	81 83       	std	Z+1, r24	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    1b18:	80 e2       	ldi	r24, 0x20	; 32
    1b1a:	90 e0       	ldi	r25, 0x00	; 0
    1b1c:	06 2c       	mov	r0, r6
    1b1e:	02 c0       	rjmp	.+4      	; 0x1b24 <CO_collectSeismic1Channel+0xf6>
    1b20:	88 0f       	add	r24, r24
    1b22:	99 1f       	adc	r25, r25
    1b24:	0a 94       	dec	r0
    1b26:	e2 f7       	brpl	.-8      	; 0x1b20 <CO_collectSeismic1Channel+0xf2>
    1b28:	86 a3       	lds	r24, 0x56
    1b2a:	97 a3       	lds	r25, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    1b2c:	80 e1       	ldi	r24, 0x10	; 16
    1b2e:	90 e0       	ldi	r25, 0x00	; 0
    1b30:	9c 01       	movw	r18, r24
    1b32:	02 c0       	rjmp	.+4      	; 0x1b38 <CO_collectSeismic1Channel+0x10a>
    1b34:	22 0f       	add	r18, r18
    1b36:	33 1f       	adc	r19, r19
    1b38:	6a 94       	dec	r6
    1b3a:	e2 f7       	brpl	.-8      	; 0x1b34 <CO_collectSeismic1Channel+0x106>
    1b3c:	22 af       	sts	0x72, r18
    1b3e:	33 af       	sts	0x73, r19
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1b40:	80 81       	ld	r24, Z
    1b42:	80 7f       	andi	r24, 0xF0	; 240
    1b44:	81 60       	ori	r24, 0x01	; 1
    1b46:	80 83       	st	Z, r24
	
	// wait for ADC to collect samples
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES);
    1b48:	80 91 54 50 	lds	r24, 0x5054
    1b4c:	90 91 55 50 	lds	r25, 0x5055
    1b50:	35 e5       	ldi	r19, 0x55	; 85
    1b52:	83 35       	cpi	r24, 0x53	; 83
    1b54:	93 07       	cpc	r25, r19
    1b56:	c0 f3       	brcs	.-16     	; 0x1b48 <CO_collectSeismic1Channel+0x11a>

	// turn off timer and interrupts
	TCD0.CTRLA = ( TCD0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1b58:	e0 e0       	ldi	r30, 0x00	; 0
    1b5a:	f9 e0       	ldi	r31, 0x09	; 9
    1b5c:	80 81       	ld	r24, Z
    1b5e:	80 7f       	andi	r24, 0xF0	; 240
    1b60:	80 83       	st	Z, r24
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1b62:	e0 e4       	ldi	r30, 0x40	; 64
    1b64:	fa e0       	ldi	r31, 0x0A	; 10
    1b66:	80 81       	ld	r24, Z
    1b68:	80 7f       	andi	r24, 0xF0	; 240
    1b6a:	80 83       	st	Z, r24
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    1b6c:	e0 ea       	ldi	r30, 0xA0	; 160
    1b6e:	f0 e0       	ldi	r31, 0x00	; 0
    1b70:	82 81       	ldd	r24, Z+2	; 0x02
    1b72:	89 7f       	andi	r24, 0xF9	; 249
    1b74:	82 83       	std	Z+2, r24	; 0x02
	cli();
    1b76:	f8 94       	cli

	SPICS(FALSE);
    1b78:	80 e0       	ldi	r24, 0x00	; 0
    1b7a:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	SPIDisable();
    1b7e:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>
	enableADCMUX(FALSE);
    1b82:	80 e0       	ldi	r24, 0x00	; 0
    1b84:	0e 94 9f 04 	call	0x93e	; 0x93e <enableADCMUX>
	ADCPower(FALSE);
    1b88:	80 e0       	ldi	r24, 0x00	; 0
    1b8a:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
	
}
    1b8e:	df 91       	pop	r29
    1b90:	cf 91       	pop	r28
    1b92:	1f 91       	pop	r17
    1b94:	0f 91       	pop	r16
    1b96:	ff 90       	pop	r15
    1b98:	ef 90       	pop	r14
    1b9a:	df 90       	pop	r13
    1b9c:	cf 90       	pop	r12
    1b9e:	bf 90       	pop	r11
    1ba0:	af 90       	pop	r10
    1ba2:	9f 90       	pop	r9
    1ba4:	8f 90       	pop	r8
    1ba6:	7f 90       	pop	r7
    1ba8:	6f 90       	pop	r6
    1baa:	08 95       	ret

00001bac <CO_collectSeismic3Channel_continuous>:
	
}

void CO_collectSeismic3Channel_continuous(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD) {
    1bac:	cf 93       	push	r28
    1bae:	df 93       	push	r29
    1bb0:	cd b7       	in	r28, 0x3d	; 61
    1bb2:	de b7       	in	r29, 0x3e	; 62
    1bb4:	18 2f       	mov	r17, r24
    1bb6:	3b 01       	movw	r6, r22
    1bb8:	54 2e       	mov	r5, r20
    1bba:	42 2e       	mov	r4, r18
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1bbc:	81 e0       	ldi	r24, 0x01	; 1
    1bbe:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    1bc2:	85 e0       	ldi	r24, 0x05	; 5
    1bc4:	f3 01       	movw	r30, r6
    1bc6:	60 81       	ld	r22, Z
    1bc8:	0e 94 39 01 	call	0x272	; 0x272 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    1bcc:	86 e0       	ldi	r24, 0x06	; 6
    1bce:	f3 01       	movw	r30, r6
    1bd0:	61 81       	ldd	r22, Z+1	; 0x01
    1bd2:	0e 94 39 01 	call	0x272	; 0x272 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    1bd6:	87 e0       	ldi	r24, 0x07	; 7
    1bd8:	f3 01       	movw	r30, r6
    1bda:	62 81       	ldd	r22, Z+2	; 0x02
    1bdc:	0e 94 39 01 	call	0x272	; 0x272 <set_ampGain>
	set_filter(filterConfig);
    1be0:	81 2f       	mov	r24, r17
    1be2:	0e 94 72 01 	call	0x2e4	; 0x2e4 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    1be6:	80 2f       	mov	r24, r16
    1be8:	0e 94 8c 06 	call	0xd18	; 0xd18 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    1bec:	84 e0       	ldi	r24, 0x04	; 4
    1bee:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1bf2:	84 e5       	ldi	r24, 0x54	; 84
    1bf4:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    1bf8:	81 e0       	ldi	r24, 0x01	; 1
    1bfa:	0e 94 9f 04 	call	0x93e	; 0x93e <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    1bfe:	85 e0       	ldi	r24, 0x05	; 5
    1c00:	0e 94 f5 0c 	call	0x19ea	; 0x19ea <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    1c04:	e0 ea       	ldi	r30, 0xA0	; 160
    1c06:	f6 e0       	ldi	r31, 0x06	; 6
    1c08:	82 e0       	ldi	r24, 0x02	; 2
    1c0a:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    1c0c:	91 e0       	ldi	r25, 0x01	; 1
    1c0e:	92 83       	std	Z+2, r25	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    1c10:	98 e7       	ldi	r25, 0x78	; 120
    1c12:	90 93 80 01 	sts	0x0180, r25

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    1c16:	e0 e0       	ldi	r30, 0x00	; 0
    1c18:	f8 e0       	ldi	r31, 0x08	; 8
    1c1a:	90 ef       	ldi	r25, 0xF0	; 240
    1c1c:	91 83       	std	Z+1, r25	; 0x01
	TCC0.CCA = averagingPtA;
    1c1e:	e0 a6       	lds	r30, 0xb0
    1c20:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    1c22:	c2 a6       	lds	r28, 0xb2
    1c24:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    1c26:	a4 a6       	lds	r26, 0xb4
    1c28:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    1c2a:	86 a6       	lds	r24, 0xb6
    1c2c:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    1c2e:	24 2d       	mov	r18, r4
    1c30:	30 e0       	ldi	r19, 0x00	; 0
    1c32:	21 50       	subi	r18, 0x01	; 1
    1c34:	30 40       	sbci	r19, 0x00	; 0
    1c36:	26 a3       	lds	r18, 0x56
    1c38:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    1c3a:	86 83       	std	Z+6, r24	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    1c3c:	8f ef       	ldi	r24, 0xFF	; 255
    1c3e:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    1c40:	80 81       	ld	r24, Z
    1c42:	80 7f       	andi	r24, 0xF0	; 240
    1c44:	88 60       	ori	r24, 0x08	; 8
    1c46:	80 83       	st	Z, r24

	FRAMAddress = FR_BASEADD;
    1c48:	10 92 3a 40 	sts	0x403A, r1
    1c4c:	10 92 3b 40 	sts	0x403B, r1
	sampleCount = 0;
    1c50:	10 92 54 50 	sts	0x5054, r1
    1c54:	10 92 55 50 	sts	0x5055, r1
	SPICount = 0;
    1c58:	10 92 aa 50 	sts	0x50AA, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    1c5c:	81 e2       	ldi	r24, 0x21	; 33
    1c5e:	91 e2       	ldi	r25, 0x21	; 33
    1c60:	10 92 21 21 	sts	0x2121, r1
    1c64:	fc 01       	movw	r30, r24
    1c66:	31 97       	sbiw	r30, 0x01	; 1
    1c68:	10 82       	st	Z, r1
    1c6a:	02 97       	sbiw	r24, 0x02	; 2
    1c6c:	fc 01       	movw	r30, r24
    1c6e:	10 82       	st	Z, r1

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    1c70:	e0 ea       	ldi	r30, 0xA0	; 160
    1c72:	f0 e0       	ldi	r31, 0x00	; 0
    1c74:	82 81       	ldd	r24, Z+2	; 0x02
    1c76:	86 60       	ori	r24, 0x06	; 6
    1c78:	82 83       	std	Z+2, r24	; 0x02
	sei();
    1c7a:	78 94       	sei

	SPICS(TRUE);
    1c7c:	81 e0       	ldi	r24, 0x01	; 1
    1c7e:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    1c82:	80 e2       	ldi	r24, 0x20	; 32
    1c84:	e0 e8       	ldi	r30, 0x80	; 128
    1c86:	f6 e0       	ldi	r31, 0x06	; 6
    1c88:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1c8a:	e0 e4       	ldi	r30, 0x40	; 64
    1c8c:	fa e0       	ldi	r31, 0x0A	; 10
    1c8e:	83 e2       	ldi	r24, 0x23	; 35
    1c90:	81 83       	std	Z+1, r24	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    1c92:	80 e2       	ldi	r24, 0x20	; 32
    1c94:	90 e0       	ldi	r25, 0x00	; 0
    1c96:	05 2c       	mov	r0, r5
    1c98:	02 c0       	rjmp	.+4      	; 0x1c9e <CO_collectSeismic3Channel_continuous+0xf2>
    1c9a:	88 0f       	add	r24, r24
    1c9c:	99 1f       	adc	r25, r25
    1c9e:	0a 94       	dec	r0
    1ca0:	e2 f7       	brpl	.-8      	; 0x1c9a <CO_collectSeismic3Channel_continuous+0xee>
    1ca2:	86 a3       	lds	r24, 0x56
    1ca4:	97 a3       	lds	r25, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    1ca6:	80 e1       	ldi	r24, 0x10	; 16
    1ca8:	90 e0       	ldi	r25, 0x00	; 0
    1caa:	02 c0       	rjmp	.+4      	; 0x1cb0 <CO_collectSeismic3Channel_continuous+0x104>
    1cac:	88 0f       	add	r24, r24
    1cae:	99 1f       	adc	r25, r25
    1cb0:	5a 94       	dec	r5
    1cb2:	e2 f7       	brpl	.-8      	; 0x1cac <CO_collectSeismic3Channel_continuous+0x100>
    1cb4:	82 af       	sts	0x72, r24
    1cb6:	93 af       	sts	0x73, r25
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1cb8:	80 81       	ld	r24, Z
    1cba:	80 7f       	andi	r24, 0xF0	; 240
    1cbc:	81 60       	ori	r24, 0x01	; 1
    1cbe:	80 83       	st	Z, r24
	
	// collect samples from ADC continuously
	while(1){
		nop();
    1cc0:	00 00       	nop
    1cc2:	fe cf       	rjmp	.-4      	; 0x1cc0 <CO_collectSeismic3Channel_continuous+0x114>

00001cc4 <CO_collectSeismic3Channel>:
	}
}

void CO_collectSeismic3Channel(uint8_t filterConfig, uint8_t gain[], uint8_t subsamplesPerSecond,
uint8_t subsamplesPerChannel, uint8_t DCPassEnable, uint16_t averagingPtA, uint16_t averagingPtB,
uint16_t averagingPtC, uint16_t averagingPtD) {
    1cc4:	4f 92       	push	r4
    1cc6:	5f 92       	push	r5
    1cc8:	6f 92       	push	r6
    1cca:	7f 92       	push	r7
    1ccc:	8f 92       	push	r8
    1cce:	9f 92       	push	r9
    1cd0:	af 92       	push	r10
    1cd2:	bf 92       	push	r11
    1cd4:	cf 92       	push	r12
    1cd6:	df 92       	push	r13
    1cd8:	ef 92       	push	r14
    1cda:	ff 92       	push	r15
    1cdc:	0f 93       	push	r16
    1cde:	1f 93       	push	r17
    1ce0:	cf 93       	push	r28
    1ce2:	df 93       	push	r29
    1ce4:	cd b7       	in	r28, 0x3d	; 61
    1ce6:	de b7       	in	r29, 0x3e	; 62
    1ce8:	18 2f       	mov	r17, r24
    1cea:	3b 01       	movw	r6, r22
    1cec:	54 2e       	mov	r5, r20
    1cee:	42 2e       	mov	r4, r18
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1cf0:	81 e0       	ldi	r24, 0x01	; 1
    1cf2:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
	
	// Set gains, filters, and input channel
	set_ampGain(ADC_CH_6_gc, gain[0]);
    1cf6:	85 e0       	ldi	r24, 0x05	; 5
    1cf8:	f3 01       	movw	r30, r6
    1cfa:	60 81       	ld	r22, Z
    1cfc:	0e 94 39 01 	call	0x272	; 0x272 <set_ampGain>
	set_ampGain(ADC_CH_7_gc, gain[1]);
    1d00:	86 e0       	ldi	r24, 0x06	; 6
    1d02:	f3 01       	movw	r30, r6
    1d04:	61 81       	ldd	r22, Z+1	; 0x01
    1d06:	0e 94 39 01 	call	0x272	; 0x272 <set_ampGain>
	set_ampGain(ADC_CH_8_gc, gain[2]);
    1d0a:	87 e0       	ldi	r24, 0x07	; 7
    1d0c:	f3 01       	movw	r30, r6
    1d0e:	62 81       	ldd	r22, Z+2	; 0x02
    1d10:	0e 94 39 01 	call	0x272	; 0x272 <set_ampGain>
	set_filter(filterConfig);
    1d14:	81 2f       	mov	r24, r17
    1d16:	0e 94 72 01 	call	0x2e4	; 0x2e4 <set_filter>
	ACC_DCPassEnable(DCPassEnable);
    1d1a:	80 2f       	mov	r24, r16
    1d1c:	0e 94 8c 06 	call	0xd18	; 0xd18 <ACC_DCPassEnable>
	SPIInit(SPI_MODE_1_gc);
    1d20:	84 e0       	ldi	r24, 0x04	; 4
    1d22:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1d26:	84 e5       	ldi	r24, 0x54	; 84
    1d28:	80 93 c0 08 	sts	0x08C0, r24

	enableADCMUX(TRUE);
    1d2c:	81 e0       	ldi	r24, 0x01	; 1
    1d2e:	0e 94 9f 04 	call	0x93e	; 0x93e <enableADCMUX>
	setADCInput(ADC_CH_6_gc);
    1d32:	85 e0       	ldi	r24, 0x05	; 5
    1d34:	0e 94 f5 0c 	call	0x19ea	; 0x19ea <setADCInput>
	

	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc;
    1d38:	e0 ea       	ldi	r30, 0xA0	; 160
    1d3a:	f6 e0       	ldi	r31, 0x06	; 6
    1d3c:	82 e0       	ldi	r24, 0x02	; 2
    1d3e:	80 8b       	std	Z+16, r24	; 0x10
	PORTF.DIRCLR = PIN0_bm;
    1d40:	91 e0       	ldi	r25, 0x01	; 1
    1d42:	92 83       	std	Z+2, r25	; 0x02
	
	// Configure IO13(PF0) to drive event channel
	EVSYS.CH0MUX = EVSYS_CHMUX_PORTF_PIN0_gc;
    1d44:	98 e7       	ldi	r25, 0x78	; 120
    1d46:	90 93 80 01 	sts	0x0180, r25

	// Configure counter for IO13(PF0) events
	TCC0.CTRLB = TC0_CCAEN_bm | TC0_CCBEN_bm | TC0_CCCEN_bm | TC0_CCDEN_bm;
    1d4a:	e0 e0       	ldi	r30, 0x00	; 0
    1d4c:	f8 e0       	ldi	r31, 0x08	; 8
    1d4e:	90 ef       	ldi	r25, 0xF0	; 240
    1d50:	91 83       	std	Z+1, r25	; 0x01
	TCC0.CCA = averagingPtA;
    1d52:	e0 a6       	lds	r30, 0xb0
    1d54:	f1 a6       	lds	r31, 0xb1
	TCC0.CCB = averagingPtB;
    1d56:	c2 a6       	lds	r28, 0xb2
    1d58:	d3 a6       	lds	r29, 0xb3
	TCC0.CCC = averagingPtC;
    1d5a:	a4 a6       	lds	r26, 0xb4
    1d5c:	b5 a6       	lds	r27, 0xb5
	TCC0.CCD = averagingPtD;
    1d5e:	86 a6       	lds	r24, 0xb6
    1d60:	97 a6       	lds	r25, 0xb7
	TCC0.PER = subsamplesPerChannel - 1;
    1d62:	24 2d       	mov	r18, r4
    1d64:	30 e0       	ldi	r19, 0x00	; 0
    1d66:	21 50       	subi	r18, 0x01	; 1
    1d68:	30 40       	sbci	r19, 0x00	; 0
    1d6a:	26 a3       	lds	r18, 0x56
    1d6c:	37 a3       	lds	r19, 0x57
	TCC0.INTCTRLA =  TC_OVFINTLVL_MED_gc;
    1d6e:	86 83       	std	Z+6, r24	; 0x06
	TCC0.INTCTRLB = TC_CCAINTLVL_HI_gc | TC_CCBINTLVL_HI_gc | TC_CCCINTLVL_HI_gc | TC_CCDINTLVL_HI_gc;
    1d70:	8f ef       	ldi	r24, 0xFF	; 255
    1d72:	87 83       	std	Z+7, r24	; 0x07
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_EVCH0_gc;
    1d74:	80 81       	ld	r24, Z
    1d76:	80 7f       	andi	r24, 0xF0	; 240
    1d78:	88 60       	ori	r24, 0x08	; 8
    1d7a:	80 83       	st	Z, r24

	FRAMAddress = FR_BASEADD;
    1d7c:	10 92 3a 40 	sts	0x403A, r1
    1d80:	10 92 3b 40 	sts	0x403B, r1
	sampleCount = 0;
    1d84:	10 92 54 50 	sts	0x5054, r1
    1d88:	10 92 55 50 	sts	0x5055, r1
	SPICount = 0;
    1d8c:	10 92 aa 50 	sts	0x50AA, r1
	checksumADC[0] = checksumADC[1] = checksumADC[2] = 0;
    1d90:	81 e2       	ldi	r24, 0x21	; 33
    1d92:	91 e2       	ldi	r25, 0x21	; 33
    1d94:	10 92 21 21 	sts	0x2121, r1
    1d98:	fc 01       	movw	r30, r24
    1d9a:	31 97       	sbiw	r30, 0x01	; 1
    1d9c:	10 82       	st	Z, r1
    1d9e:	02 97       	sbiw	r24, 0x02	; 2
    1da0:	fc 01       	movw	r30, r24
    1da2:	10 82       	st	Z, r1

	// Enable interrupts.
	PMIC.CTRL |= (PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    1da4:	e0 ea       	ldi	r30, 0xA0	; 160
    1da6:	f0 e0       	ldi	r31, 0x00	; 0
    1da8:	82 81       	ldd	r24, Z+2	; 0x02
    1daa:	86 60       	ori	r24, 0x06	; 6
    1dac:	82 83       	std	Z+2, r24	; 0x02
	sei();
    1dae:	78 94       	sei

	SPICS(TRUE);
    1db0:	81 e0       	ldi	r24, 0x01	; 1
    1db2:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>

	// Configure clock signal for AD7767 MCLK
	PORTE.DIRSET = PIN5_bm;
    1db6:	80 e2       	ldi	r24, 0x20	; 32
    1db8:	e0 e8       	ldi	r30, 0x80	; 128
    1dba:	f6 e0       	ldi	r31, 0x06	; 6
    1dbc:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1dbe:	e0 e4       	ldi	r30, 0x40	; 64
    1dc0:	fa e0       	ldi	r31, 0x0A	; 10
    1dc2:	83 e2       	ldi	r24, 0x23	; 35
    1dc4:	81 83       	std	Z+1, r24	; 0x01
	// set period
	TCE1.PER = (0x20 << subsamplesPerSecond);
    1dc6:	80 e2       	ldi	r24, 0x20	; 32
    1dc8:	90 e0       	ldi	r25, 0x00	; 0
    1dca:	05 2c       	mov	r0, r5
    1dcc:	02 c0       	rjmp	.+4      	; 0x1dd2 <CO_collectSeismic3Channel+0x10e>
    1dce:	88 0f       	add	r24, r24
    1dd0:	99 1f       	adc	r25, r25
    1dd2:	0a 94       	dec	r0
    1dd4:	e2 f7       	brpl	.-8      	; 0x1dce <CO_collectSeismic3Channel+0x10a>
    1dd6:	86 a3       	lds	r24, 0x56
    1dd8:	97 a3       	lds	r25, 0x57
	TCE1.CCBBUF = (0x10 << subsamplesPerSecond);
    1dda:	80 e1       	ldi	r24, 0x10	; 16
    1ddc:	90 e0       	ldi	r25, 0x00	; 0
    1dde:	02 c0       	rjmp	.+4      	; 0x1de4 <CO_collectSeismic3Channel+0x120>
    1de0:	88 0f       	add	r24, r24
    1de2:	99 1f       	adc	r25, r25
    1de4:	5a 94       	dec	r5
    1de6:	e2 f7       	brpl	.-8      	; 0x1de0 <CO_collectSeismic3Channel+0x11c>
    1de8:	82 af       	sts	0x72, r24
    1dea:	93 af       	sts	0x73, r25
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1dec:	80 81       	ld	r24, Z
    1dee:	80 7f       	andi	r24, 0xF0	; 240
    1df0:	81 60       	ori	r24, 0x01	; 1
    1df2:	80 83       	st	Z, r24
	
	// wait for ADC to collect samples
	while(sampleCount < FR_TOTAL_NUM_SE_SAMPLES);
    1df4:	80 91 54 50 	lds	r24, 0x5054
    1df8:	90 91 55 50 	lds	r25, 0x5055
    1dfc:	f5 e5       	ldi	r31, 0x55	; 85
    1dfe:	83 35       	cpi	r24, 0x53	; 83
    1e00:	9f 07       	cpc	r25, r31
    1e02:	c0 f3       	brcs	.-16     	; 0x1df4 <CO_collectSeismic3Channel+0x130>

	// turn off timer and interrupts
	TCC0.CTRLA = ( TCC0.CTRLA & ~TC0_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1e04:	e0 e0       	ldi	r30, 0x00	; 0
    1e06:	f8 e0       	ldi	r31, 0x08	; 8
    1e08:	80 81       	ld	r24, Z
    1e0a:	80 7f       	andi	r24, 0xF0	; 240
    1e0c:	80 83       	st	Z, r24
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    1e0e:	e0 e4       	ldi	r30, 0x40	; 64
    1e10:	fa e0       	ldi	r31, 0x0A	; 10
    1e12:	80 81       	ld	r24, Z
    1e14:	80 7f       	andi	r24, 0xF0	; 240
    1e16:	80 83       	st	Z, r24
	PMIC.CTRL &= ~(PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm);
    1e18:	e0 ea       	ldi	r30, 0xA0	; 160
    1e1a:	f0 e0       	ldi	r31, 0x00	; 0
    1e1c:	82 81       	ldd	r24, Z+2	; 0x02
    1e1e:	89 7f       	andi	r24, 0xF9	; 249
    1e20:	82 83       	std	Z+2, r24	; 0x02
	cli();
    1e22:	f8 94       	cli

	SPICS(FALSE);
    1e24:	80 e0       	ldi	r24, 0x00	; 0
    1e26:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	SPIDisable();
    1e2a:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>
	enableADCMUX(FALSE);
    1e2e:	80 e0       	ldi	r24, 0x00	; 0
    1e30:	0e 94 9f 04 	call	0x93e	; 0x93e <enableADCMUX>
	ADCPower(FALSE);
    1e34:	80 e0       	ldi	r24, 0x00	; 0
    1e36:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
	
}
    1e3a:	df 91       	pop	r29
    1e3c:	cf 91       	pop	r28
    1e3e:	1f 91       	pop	r17
    1e40:	0f 91       	pop	r16
    1e42:	ff 90       	pop	r15
    1e44:	ef 90       	pop	r14
    1e46:	df 90       	pop	r13
    1e48:	cf 90       	pop	r12
    1e4a:	bf 90       	pop	r11
    1e4c:	af 90       	pop	r10
    1e4e:	9f 90       	pop	r9
    1e50:	8f 90       	pop	r8
    1e52:	7f 90       	pop	r7
    1e54:	6f 90       	pop	r6
    1e56:	5f 90       	pop	r5
    1e58:	4f 90       	pop	r4
    1e5a:	08 95       	ret

00001e5c <CO_collectADC_cont>:
	*maxV = (int32_t) -(max * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
	*minV = (int32_t) -(min * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);

}

void CO_collectADC_cont(uint8_t channel, uint8_t filterConfig, uint8_t gainExponent, uint8_t spsExponent) {
    1e5c:	0f 93       	push	r16
    1e5e:	1f 93       	push	r17
    1e60:	cf 93       	push	r28
    1e62:	df 93       	push	r29
    1e64:	d8 2f       	mov	r29, r24
    1e66:	16 2f       	mov	r17, r22
    1e68:	04 2f       	mov	r16, r20
    1e6a:	c2 2f       	mov	r28, r18

uint16_t period;

// Turn on power to ADC and PortEx
ADCPower(TRUE);
    1e6c:	81 e0       	ldi	r24, 0x01	; 1
    1e6e:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
//get data to write files to SD card
getBootSectorData();
    1e72:	0e 94 d9 1f 	call	0x3fb2	; 0x3fb2 <getBootSectorData>
// set gain, filters, and ADC input for appropriate VIN
set_ampGain(channel, gainExponent);
    1e76:	8d 2f       	mov	r24, r29
    1e78:	60 2f       	mov	r22, r16
    1e7a:	0e 94 39 01 	call	0x272	; 0x272 <set_ampGain>
set_filter(filterConfig);
    1e7e:	81 2f       	mov	r24, r17
    1e80:	0e 94 72 01 	call	0x2e4	; 0x2e4 <set_filter>

// if acc channel then enable DC Pass
// it is assumed that if not using high frequency acc specific function then
// DC Pass is wanted.
if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) ||
    1e84:	8d 2f       	mov	r24, r29
    1e86:	85 50       	subi	r24, 0x05	; 5
    1e88:	83 30       	cpi	r24, 0x03	; 3
    1e8a:	18 f4       	brcc	.+6      	; 0x1e92 <CO_collectADC_cont+0x36>
(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    1e8c:	81 e0       	ldi	r24, 0x01	; 1
    1e8e:	0e 94 8c 06 	call	0xd18	; 0xd18 <ACC_DCPassEnable>

enableADCMUX(TRUE);
    1e92:	81 e0       	ldi	r24, 0x01	; 1
    1e94:	0e 94 9f 04 	call	0x93e	; 0x93e <enableADCMUX>
setADCInput(channel);
    1e98:	8d 2f       	mov	r24, r29
    1e9a:	0e 94 f5 0c 	call	0x19ea	; 0x19ea <setADCInput>
SPIInit(SPI_MODE_1_gc);
    1e9e:	84 e0       	ldi	r24, 0x04	; 4
    1ea0:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1ea4:	84 e5       	ldi	r24, 0x54	; 84
    1ea6:	80 93 c0 08 	sts	0x08C0, r24

// Configure IO13 (PF0) to capture ADC DRDY signal
PORTF.DIRCLR = PIN0_bm;
    1eaa:	e0 ea       	ldi	r30, 0xA0	; 160
    1eac:	f6 e0       	ldi	r31, 0x06	; 6
    1eae:	81 e0       	ldi	r24, 0x01	; 1
    1eb0:	82 83       	std	Z+2, r24	; 0x02
PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    1eb2:	92 e0       	ldi	r25, 0x02	; 2
    1eb4:	90 8b       	std	Z+16, r25	; 0x10
//PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_PULLUP_gc;
PORTF.INT1MASK = PIN0_bm;
    1eb6:	83 87       	std	Z+11, r24	; 0x0b
PORTF.INTCTRL = PORT_INT1LVL_LO_gc;
    1eb8:	84 e0       	ldi	r24, 0x04	; 4
    1eba:	81 87       	std	Z+9, r24	; 0x09
//f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
//the TCE1 counter increments every pulse of the system clock and once it reaches a certain value it 
//toggles pin 5 (clock input to ADC). This effectively divides the system clock into a desired clock rate for 
//the ADC. 
// Set IO14 (PE5) to output
PORTE.DIRSET = PIN5_bm;
    1ebc:	80 e2       	ldi	r24, 0x20	; 32
    1ebe:	e0 e8       	ldi	r30, 0x80	; 128
    1ec0:	f6 e0       	ldi	r31, 0x06	; 6
    1ec2:	81 83       	std	Z+1, r24	; 0x01
// Set Waveform generator mode(single slope) and enable the CCx output to IO14 (PE5)
TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1ec4:	e0 e4       	ldi	r30, 0x40	; 64
    1ec6:	fa e0       	ldi	r31, 0x0A	; 10
    1ec8:	83 e2       	ldi	r24, 0x23	; 35
    1eca:	81 83       	std	Z+1, r24	; 0x01
// set period
period = (1 << (21 - spsExponent)) - 1;
    1ecc:	25 e1       	ldi	r18, 0x15	; 21
    1ece:	30 e0       	ldi	r19, 0x00	; 0
    1ed0:	2c 1b       	sub	r18, r28
    1ed2:	31 09       	sbc	r19, r1
    1ed4:	81 e0       	ldi	r24, 0x01	; 1
    1ed6:	90 e0       	ldi	r25, 0x00	; 0
    1ed8:	02 c0       	rjmp	.+4      	; 0x1ede <CO_collectADC_cont+0x82>
    1eda:	88 0f       	add	r24, r24
    1edc:	99 1f       	adc	r25, r25
    1ede:	2a 95       	dec	r18
    1ee0:	e2 f7       	brpl	.-8      	; 0x1eda <CO_collectADC_cont+0x7e>
    1ee2:	01 97       	sbiw	r24, 0x01	; 1
TCE1.PER = period;
    1ee4:	86 a3       	lds	r24, 0x56
    1ee6:	97 a3       	lds	r25, 0x57
TCE1.CCBBUF = period / 2;
    1ee8:	96 95       	lsr	r25
    1eea:	87 95       	ror	r24
    1eec:	82 af       	sts	0x72, r24
    1eee:	93 af       	sts	0x73, r25
// Set oscillator source and frequency and start
TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1ef0:	80 81       	ld	r24, Z
    1ef2:	80 7f       	andi	r24, 0xF0	; 240
    1ef4:	81 60       	ori	r24, 0x01	; 1
    1ef6:	80 83       	st	Z, r24

// Enable interrupts.
PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1ef8:	e0 ea       	ldi	r30, 0xA0	; 160
    1efa:	f0 e0       	ldi	r31, 0x00	; 0
    1efc:	82 81       	ldd	r24, Z+2	; 0x02
    1efe:	81 60       	ori	r24, 0x01	; 1
    1f00:	82 83       	std	Z+2, r24	; 0x02
sei();
    1f02:	78 94       	sei

sampleCount = 0;
    1f04:	10 92 54 50 	sts	0x5054, r1
    1f08:	10 92 55 50 	sts	0x5055, r1
TotalSampleCount = 0;
    1f0c:	10 92 80 50 	sts	0x5080, r1
    1f10:	10 92 81 50 	sts	0x5081, r1
discardCount = 0;
    1f14:	10 92 40 40 	sts	0x4040, r1
}
    1f18:	df 91       	pop	r29
    1f1a:	cf 91       	pop	r28
    1f1c:	1f 91       	pop	r17
    1f1e:	0f 91       	pop	r16
    1f20:	08 95       	ret

00001f22 <CO_collectADC>:
 *  filterConfig[4:6] Low Pass cutoff 000=>infinite, 001=>32kHz, 010=>6kHz, 100=>600Hz
 *	filterConfig[7] High Pass cutoff 0=>2Hz, 1=>0Hz 
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV, int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {
    1f22:	2f 92       	push	r2
    1f24:	3f 92       	push	r3
    1f26:	4f 92       	push	r4
    1f28:	5f 92       	push	r5
    1f2a:	6f 92       	push	r6
    1f2c:	7f 92       	push	r7
    1f2e:	8f 92       	push	r8
    1f30:	9f 92       	push	r9
    1f32:	af 92       	push	r10
    1f34:	bf 92       	push	r11
    1f36:	cf 92       	push	r12
    1f38:	df 92       	push	r13
    1f3a:	ef 92       	push	r14
    1f3c:	ff 92       	push	r15
    1f3e:	0f 93       	push	r16
    1f40:	1f 93       	push	r17
    1f42:	cf 93       	push	r28
    1f44:	df 93       	push	r29
    1f46:	cd b7       	in	r28, 0x3d	; 61
    1f48:	de b7       	in	r29, 0x3e	; 62
    1f4a:	62 97       	sbiw	r28, 0x12	; 18
    1f4c:	cd bf       	out	0x3d, r28	; 61
    1f4e:	de bf       	out	0x3e, r29	; 62
    1f50:	f8 2e       	mov	r15, r24
    1f52:	d6 2e       	mov	r13, r22
    1f54:	4b 87       	std	Y+11, r20	; 0x0b
    1f56:	5c 87       	std	Y+12, r21	; 0x0c
    1f58:	2d 87       	std	Y+13, r18	; 0x0d
    1f5a:	3e 87       	std	Y+14, r19	; 0x0e
    1f5c:	0f 87       	std	Y+15, r16	; 0x0f
    1f5e:	18 8b       	std	Y+16, r17	; 0x10
	int64_t min = ADC_MAX;
	int64_t max = -ADC_MAX;
	uint16_t period;
	
	// Turn on power to ADC and PortEx
	ADCPower(TRUE);
    1f60:	81 e0       	ldi	r24, 0x01	; 1
    1f62:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
	
	// set gain, filters, and ADC input for appropriate VIN
	set_ampGain(channel, gainExponent);
    1f66:	8f 2d       	mov	r24, r15
    1f68:	6e 2d       	mov	r22, r14
    1f6a:	0e 94 39 01 	call	0x272	; 0x272 <set_ampGain>
	set_filter(filterConfig);
    1f6e:	8d 2d       	mov	r24, r13
    1f70:	0e 94 72 01 	call	0x2e4	; 0x2e4 <set_filter>

	// if acc channel then enable DC Pass 
	// it is assumed that if not using high frequency acc specific function then 
	// DC Pass is wanted.
	if ((channel == ADC_CH_6_gc) ||	(channel == ADC_CH_7_gc) || 
    1f74:	8f 2d       	mov	r24, r15
    1f76:	85 50       	subi	r24, 0x05	; 5
    1f78:	83 30       	cpi	r24, 0x03	; 3
    1f7a:	18 f4       	brcc	.+6      	; 0x1f82 <CO_collectADC+0x60>
		(channel == ADC_CH_8_gc)) ACC_DCPassEnable(TRUE);
    1f7c:	81 e0       	ldi	r24, 0x01	; 1
    1f7e:	0e 94 8c 06 	call	0xd18	; 0xd18 <ACC_DCPassEnable>

	enableADCMUX(TRUE);
    1f82:	81 e0       	ldi	r24, 0x01	; 1
    1f84:	0e 94 9f 04 	call	0x93e	; 0x93e <enableADCMUX>
	setADCInput(channel);
    1f88:	8f 2d       	mov	r24, r15
    1f8a:	0e 94 f5 0c 	call	0x19ea	; 0x19ea <setADCInput>
	SPIInit(SPI_MODE_1_gc);
    1f8e:	84 e0       	ldi	r24, 0x04	; 4
    1f90:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
	SPIC.CTRL = ADC_SPI_CONFIG_gc;
    1f94:	84 e5       	ldi	r24, 0x54	; 84
    1f96:	80 93 c0 08 	sts	0x08C0, r24
	
	// Configure IO13 (PF0) to capture ADC DRDY signal
	PORTF.DIRCLR = PIN0_bm;
    1f9a:	e0 ea       	ldi	r30, 0xA0	; 160
    1f9c:	f6 e0       	ldi	r31, 0x06	; 6
    1f9e:	81 e0       	ldi	r24, 0x01	; 1
    1fa0:	82 83       	std	Z+2, r24	; 0x02
	PORTF.PIN0CTRL = PORT_ISC_FALLING_gc | PORT_OPC_TOTEM_gc;
    1fa2:	92 e0       	ldi	r25, 0x02	; 2
    1fa4:	90 8b       	std	Z+16, r25	; 0x10
	PORTF.INT0MASK = PIN0_bm;
    1fa6:	82 87       	std	Z+10, r24	; 0x0a
	PORTF.INTCTRL = PORT_INT0LVL_LO_gc;				
    1fa8:	81 87       	std	Z+9, r24	; 0x09

	// Configure clock for AD7767 MCLK for desired sample frequency
	// f_samples = f_MCLK / 16
	// f_MCLK = f_peripheral(2^25Hz) / (f_period + 1Hz)
	// Set IO14 (PE5) to output
	PORTE.DIRSET = PIN5_bm;
    1faa:	80 e2       	ldi	r24, 0x20	; 32
    1fac:	e0 e8       	ldi	r30, 0x80	; 128
    1fae:	f6 e0       	ldi	r31, 0x06	; 6
    1fb0:	81 83       	std	Z+1, r24	; 0x01
	// Set Waveform generator mode and enable the CCx output to IO14 (PE5)
	TCE1.CTRLB = TC_WGMODE_SS_gc | TC1_CCBEN_bm;
    1fb2:	e0 e4       	ldi	r30, 0x40	; 64
    1fb4:	fa e0       	ldi	r31, 0x0A	; 10
    1fb6:	83 e2       	ldi	r24, 0x23	; 35
    1fb8:	81 83       	std	Z+1, r24	; 0x01
	// set period
	period = (1 << (21 - spsExponent)) - 1;
    1fba:	85 e1       	ldi	r24, 0x15	; 21
    1fbc:	90 e0       	ldi	r25, 0x00	; 0
    1fbe:	9c 01       	movw	r18, r24
    1fc0:	2c 19       	sub	r18, r12
    1fc2:	31 09       	sbc	r19, r1
    1fc4:	81 e0       	ldi	r24, 0x01	; 1
    1fc6:	90 e0       	ldi	r25, 0x00	; 0
    1fc8:	02 c0       	rjmp	.+4      	; 0x1fce <CO_collectADC+0xac>
    1fca:	88 0f       	add	r24, r24
    1fcc:	99 1f       	adc	r25, r25
    1fce:	2a 95       	dec	r18
    1fd0:	e2 f7       	brpl	.-8      	; 0x1fca <CO_collectADC+0xa8>
    1fd2:	01 97       	sbiw	r24, 0x01	; 1
	TCE1.PER = period;
    1fd4:	86 a3       	lds	r24, 0x56
    1fd6:	97 a3       	lds	r25, 0x57
	TCE1.CCBBUF = period / 2;
    1fd8:	96 95       	lsr	r25
    1fda:	87 95       	ror	r24
    1fdc:	82 af       	sts	0x72, r24
    1fde:	93 af       	sts	0x73, r25
	// Set oscillator source and frequency and start
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_DIV1_gc;
    1fe0:	80 81       	ld	r24, Z
    1fe2:	80 7f       	andi	r24, 0xF0	; 240
    1fe4:	81 60       	ori	r24, 0x01	; 1
    1fe6:	80 83       	st	Z, r24
	
	// Enable interrupts.
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1fe8:	e0 ea       	ldi	r30, 0xA0	; 160
    1fea:	f0 e0       	ldi	r31, 0x00	; 0
    1fec:	82 81       	ldd	r24, Z+2	; 0x02
    1fee:	81 60       	ori	r24, 0x01	; 1
    1ff0:	82 83       	std	Z+2, r24	; 0x02
	sei();
    1ff2:	78 94       	sei

	sampleCount = 0;
    1ff4:	10 92 54 50 	sts	0x5054, r1
    1ff8:	10 92 55 50 	sts	0x5055, r1
	discardCount = 0;
    1ffc:	10 92 40 40 	sts	0x4040, r1
	
	// wait for ADC to collect samples
	while(sampleCount < NUM_SAMPLES);
    2000:	80 91 54 50 	lds	r24, 0x5054
    2004:	90 91 55 50 	lds	r25, 0x5055
    2008:	24 e0       	ldi	r18, 0x04	; 4
    200a:	80 30       	cpi	r24, 0x00	; 0
    200c:	92 07       	cpc	r25, r18
    200e:	c0 f3       	brcs	.-16     	; 0x2000 <CO_collectADC+0xde>

	// turn off timer and interupts
	TCE1.CTRLA = ( TCE1.CTRLA & ~TC1_CLKSEL_gm ) | TC_CLKSEL_OFF_gc;
    2010:	e0 e4       	ldi	r30, 0x40	; 64
    2012:	fa e0       	ldi	r31, 0x0A	; 10
    2014:	80 81       	ld	r24, Z
    2016:	80 7f       	andi	r24, 0xF0	; 240
    2018:	80 83       	st	Z, r24
	PMIC.CTRL &= ~PMIC_LOLVLEN_bm;	
    201a:	e0 ea       	ldi	r30, 0xA0	; 160
    201c:	f0 e0       	ldi	r31, 0x00	; 0
    201e:	82 81       	ldd	r24, Z+2	; 0x02
    2020:	8e 7f       	andi	r24, 0xFE	; 254
    2022:	82 83       	std	Z+2, r24	; 0x02
	cli();
    2024:	f8 94       	cli

	SPIDisable();	
    2026:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>
	enableADCMUX(FALSE);
    202a:	80 e0       	ldi	r24, 0x00	; 0
    202c:	0e 94 9f 04 	call	0x93e	; 0x93e <enableADCMUX>
	ADCPower(FALSE);
    2030:	80 e0       	ldi	r24, 0x00	; 0
    2032:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>

	// collect average, max and min of SP samples
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
    2036:	10 92 54 50 	sts	0x5054, r1
    203a:	10 92 55 50 	sts	0x5055, r1
    203e:	80 91 54 50 	lds	r24, 0x5054
    2042:	90 91 55 50 	lds	r25, 0x5055
    2046:	54 e0       	ldi	r21, 0x04	; 4
    2048:	80 30       	cpi	r24, 0x00	; 0
    204a:	95 07       	cpc	r25, r21
    204c:	08 f0       	brcs	.+2      	; 0x2050 <CO_collectADC+0x12e>
    204e:	55 c1       	rjmp	.+682    	; 0x22fa <CO_collectADC+0x3d8>
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV, int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {

	int64_t sum = 0;
	int64_t average;
	int64_t min = ADC_MAX;
	int64_t max = -ADC_MAX;
    2050:	61 e0       	ldi	r22, 0x01	; 1
    2052:	6a 87       	std	Y+10, r22	; 0x0a
    2054:	1f 82       	std	Y+7, r1	; 0x07
    2056:	80 e8       	ldi	r24, 0x80	; 128
    2058:	88 87       	std	Y+8, r24	; 0x08
    205a:	9f ef       	ldi	r25, 0xFF	; 255
    205c:	9c 83       	std	Y+4, r25	; 0x04
    205e:	ef ef       	ldi	r30, 0xFF	; 255
    2060:	ea 83       	std	Y+2, r30	; 0x02
    2062:	33 24       	eor	r3, r3
    2064:	3a 94       	dec	r3
    2066:	55 24       	eor	r5, r5
    2068:	5a 94       	dec	r5
    206a:	77 24       	eor	r7, r7
    206c:	7a 94       	dec	r7
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV, int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {

	int64_t sum = 0;
	int64_t average;
	int64_t min = ADC_MAX;
    206e:	ff ef       	ldi	r31, 0xFF	; 255
    2070:	f9 87       	std	Y+9, r31	; 0x09
    2072:	2f ef       	ldi	r18, 0xFF	; 255
    2074:	2d 83       	std	Y+5, r18	; 0x05
    2076:	5f e7       	ldi	r21, 0x7F	; 127
    2078:	5e 83       	std	Y+6, r21	; 0x06
    207a:	1b 82       	std	Y+3, r1	; 0x03
    207c:	19 82       	std	Y+1, r1	; 0x01
    207e:	22 24       	eor	r2, r2
    2080:	44 24       	eor	r4, r4
    2082:	66 24       	eor	r6, r6
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV, int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {

	int64_t sum = 0;
    2084:	e0 e0       	ldi	r30, 0x00	; 0
    2086:	30 e0       	ldi	r19, 0x00	; 0
    2088:	40 e0       	ldi	r20, 0x00	; 0
    208a:	10 e0       	ldi	r17, 0x00	; 0
    208c:	00 e0       	ldi	r16, 0x00	; 0
    208e:	88 24       	eor	r8, r8
    2090:	ff 24       	eor	r15, r15
    2092:	99 24       	eor	r9, r9
	enableADCMUX(FALSE);
	ADCPower(FALSE);

	// collect average, max and min of SP samples
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
		sum += data24Bit[sampleCount];
    2094:	0f 2e       	mov	r0, r31
    2096:	f5 e4       	ldi	r31, 0x45	; 69
    2098:	af 2e       	mov	r10, r31
    209a:	f0 e4       	ldi	r31, 0x40	; 64
    209c:	bf 2e       	mov	r11, r31
    209e:	f0 2d       	mov	r31, r0
    20a0:	e9 8b       	std	Y+17, r30	; 0x11
    20a2:	4a 8b       	std	Y+18, r20	; 0x12
    20a4:	e0 91 54 50 	lds	r30, 0x5054
    20a8:	f0 91 55 50 	lds	r31, 0x5055
    20ac:	ee 0f       	add	r30, r30
    20ae:	ff 1f       	adc	r31, r31
    20b0:	ee 0f       	add	r30, r30
    20b2:	ff 1f       	adc	r31, r31
    20b4:	ea 0d       	add	r30, r10
    20b6:	fb 1d       	adc	r31, r11
    20b8:	40 81       	ld	r20, Z
    20ba:	51 81       	ldd	r21, Z+1	; 0x01
    20bc:	62 81       	ldd	r22, Z+2	; 0x02
    20be:	73 81       	ldd	r23, Z+3	; 0x03
    20c0:	c5 2e       	mov	r12, r21
    20c2:	d6 2e       	mov	r13, r22
    20c4:	e7 2e       	mov	r14, r23
    20c6:	db 01       	movw	r26, r22
    20c8:	ca 01       	movw	r24, r20
    20ca:	bb 0f       	add	r27, r27
    20cc:	88 0b       	sbc	r24, r24
    20ce:	98 2f       	mov	r25, r24
    20d0:	dc 01       	movw	r26, r24
    20d2:	f8 2f       	mov	r31, r24
    20d4:	e8 2f       	mov	r30, r24
    20d6:	28 2f       	mov	r18, r24
    20d8:	99 89       	ldd	r25, Y+17	; 0x11
    20da:	49 0f       	add	r20, r25
    20dc:	91 e0       	ldi	r25, 0x01	; 1
    20de:	59 89       	ldd	r21, Y+17	; 0x11
    20e0:	45 17       	cp	r20, r21
    20e2:	08 f0       	brcs	.+2      	; 0x20e6 <CO_collectADC+0x1c4>
    20e4:	90 e0       	ldi	r25, 0x00	; 0
    20e6:	c3 0e       	add	r12, r19
    20e8:	51 e0       	ldi	r21, 0x01	; 1
    20ea:	c3 16       	cp	r12, r19
    20ec:	08 f0       	brcs	.+2      	; 0x20f0 <CO_collectADC+0x1ce>
    20ee:	50 e0       	ldi	r21, 0x00	; 0
    20f0:	39 2f       	mov	r19, r25
    20f2:	3c 0d       	add	r19, r12
    20f4:	91 e0       	ldi	r25, 0x01	; 1
    20f6:	3c 15       	cp	r19, r12
    20f8:	08 f0       	brcs	.+2      	; 0x20fc <CO_collectADC+0x1da>
    20fa:	90 e0       	ldi	r25, 0x00	; 0
    20fc:	59 2b       	or	r21, r25
    20fe:	6a 89       	ldd	r22, Y+18	; 0x12
    2100:	d6 0e       	add	r13, r22
    2102:	91 e0       	ldi	r25, 0x01	; 1
    2104:	d6 16       	cp	r13, r22
    2106:	08 f0       	brcs	.+2      	; 0x210a <CO_collectADC+0x1e8>
    2108:	90 e0       	ldi	r25, 0x00	; 0
    210a:	75 2f       	mov	r23, r21
    210c:	7d 0d       	add	r23, r13
    210e:	51 e0       	ldi	r21, 0x01	; 1
    2110:	7d 15       	cp	r23, r13
    2112:	08 f0       	brcs	.+2      	; 0x2116 <CO_collectADC+0x1f4>
    2114:	50 e0       	ldi	r21, 0x00	; 0
    2116:	95 2b       	or	r25, r21
    2118:	e1 0e       	add	r14, r17
    211a:	51 e0       	ldi	r21, 0x01	; 1
    211c:	e1 16       	cp	r14, r17
    211e:	08 f0       	brcs	.+2      	; 0x2122 <CO_collectADC+0x200>
    2120:	50 e0       	ldi	r21, 0x00	; 0
    2122:	19 2f       	mov	r17, r25
    2124:	1e 0d       	add	r17, r14
    2126:	91 e0       	ldi	r25, 0x01	; 1
    2128:	1e 15       	cp	r17, r14
    212a:	08 f0       	brcs	.+2      	; 0x212e <CO_collectADC+0x20c>
    212c:	90 e0       	ldi	r25, 0x00	; 0
    212e:	59 2b       	or	r21, r25
    2130:	f0 0f       	add	r31, r16
    2132:	91 e0       	ldi	r25, 0x01	; 1
    2134:	f0 17       	cp	r31, r16
    2136:	08 f0       	brcs	.+2      	; 0x213a <CO_collectADC+0x218>
    2138:	90 e0       	ldi	r25, 0x00	; 0
    213a:	05 2f       	mov	r16, r21
    213c:	0f 0f       	add	r16, r31
    213e:	51 e0       	ldi	r21, 0x01	; 1
    2140:	0f 17       	cp	r16, r31
    2142:	08 f0       	brcs	.+2      	; 0x2146 <CO_collectADC+0x224>
    2144:	50 e0       	ldi	r21, 0x00	; 0
    2146:	95 2b       	or	r25, r21
    2148:	e8 0d       	add	r30, r8
    214a:	61 e0       	ldi	r22, 0x01	; 1
    214c:	e8 15       	cp	r30, r8
    214e:	08 f0       	brcs	.+2      	; 0x2152 <CO_collectADC+0x230>
    2150:	60 e0       	ldi	r22, 0x00	; 0
    2152:	89 2e       	mov	r8, r25
    2154:	8e 0e       	add	r8, r30
    2156:	91 e0       	ldi	r25, 0x01	; 1
    2158:	8e 16       	cp	r8, r30
    215a:	08 f0       	brcs	.+2      	; 0x215e <CO_collectADC+0x23c>
    215c:	90 e0       	ldi	r25, 0x00	; 0
    215e:	69 2b       	or	r22, r25
    2160:	2f 0d       	add	r18, r15
    2162:	51 e0       	ldi	r21, 0x01	; 1
    2164:	2f 15       	cp	r18, r15
    2166:	08 f0       	brcs	.+2      	; 0x216a <CO_collectADC+0x248>
    2168:	50 e0       	ldi	r21, 0x00	; 0
    216a:	f6 2e       	mov	r15, r22
    216c:	f2 0e       	add	r15, r18
    216e:	91 e0       	ldi	r25, 0x01	; 1
    2170:	f2 16       	cp	r15, r18
    2172:	08 f0       	brcs	.+2      	; 0x2176 <CO_collectADC+0x254>
    2174:	90 e0       	ldi	r25, 0x00	; 0
    2176:	59 2b       	or	r21, r25
    2178:	98 0e       	add	r9, r24
    217a:	49 8b       	std	Y+17, r20	; 0x11
    217c:	7a 8b       	std	Y+18, r23	; 0x12
    217e:	95 0e       	add	r9, r21
		if (max < data24Bit[sampleCount]) { max = data24Bit[sampleCount];}
    2180:	e0 91 54 50 	lds	r30, 0x5054
    2184:	f0 91 55 50 	lds	r31, 0x5055
    2188:	ee 0f       	add	r30, r30
    218a:	ff 1f       	adc	r31, r31
    218c:	ee 0f       	add	r30, r30
    218e:	ff 1f       	adc	r31, r31
    2190:	ea 0d       	add	r30, r10
    2192:	fb 1d       	adc	r31, r11
    2194:	80 81       	ld	r24, Z
    2196:	91 81       	ldd	r25, Z+1	; 0x01
    2198:	a2 81       	ldd	r26, Z+2	; 0x02
    219a:	b3 81       	ldd	r27, Z+3	; 0x03
    219c:	68 2f       	mov	r22, r24
    219e:	49 2f       	mov	r20, r25
    21a0:	5a 2f       	mov	r21, r26
    21a2:	2b 2f       	mov	r18, r27
    21a4:	bb 0f       	add	r27, r27
    21a6:	88 0b       	sbc	r24, r24
    21a8:	98 2f       	mov	r25, r24
    21aa:	dc 01       	movw	r26, r24
    21ac:	78 2f       	mov	r23, r24
    21ae:	78 16       	cp	r7, r24
    21b0:	0c f1       	brlt	.+66     	; 0x21f4 <CO_collectADC+0x2d2>
    21b2:	87 15       	cp	r24, r7
    21b4:	c9 f5       	brne	.+114    	; 0x2228 <CO_collectADC+0x306>
    21b6:	58 16       	cp	r5, r24
    21b8:	e8 f0       	brcs	.+58     	; 0x21f4 <CO_collectADC+0x2d2>
    21ba:	85 15       	cp	r24, r5
    21bc:	a9 f5       	brne	.+106    	; 0x2228 <CO_collectADC+0x306>
    21be:	38 16       	cp	r3, r24
    21c0:	c8 f0       	brcs	.+50     	; 0x21f4 <CO_collectADC+0x2d2>
    21c2:	83 15       	cp	r24, r3
    21c4:	89 f5       	brne	.+98     	; 0x2228 <CO_collectADC+0x306>
    21c6:	8a 81       	ldd	r24, Y+2	; 0x02
    21c8:	87 17       	cp	r24, r23
    21ca:	a0 f0       	brcs	.+40     	; 0x21f4 <CO_collectADC+0x2d2>
    21cc:	78 17       	cp	r23, r24
    21ce:	61 f5       	brne	.+88     	; 0x2228 <CO_collectADC+0x306>
    21d0:	9c 81       	ldd	r25, Y+4	; 0x04
    21d2:	92 17       	cp	r25, r18
    21d4:	78 f0       	brcs	.+30     	; 0x21f4 <CO_collectADC+0x2d2>
    21d6:	29 17       	cp	r18, r25
    21d8:	39 f5       	brne	.+78     	; 0x2228 <CO_collectADC+0x306>
    21da:	e8 85       	ldd	r30, Y+8	; 0x08
    21dc:	e5 17       	cp	r30, r21
    21de:	50 f0       	brcs	.+20     	; 0x21f4 <CO_collectADC+0x2d2>
    21e0:	5e 17       	cp	r21, r30
    21e2:	11 f5       	brne	.+68     	; 0x2228 <CO_collectADC+0x306>
    21e4:	ff 81       	ldd	r31, Y+7	; 0x07
    21e6:	f4 17       	cp	r31, r20
    21e8:	28 f0       	brcs	.+10     	; 0x21f4 <CO_collectADC+0x2d2>
    21ea:	4f 17       	cp	r20, r31
    21ec:	e9 f4       	brne	.+58     	; 0x2228 <CO_collectADC+0x306>
    21ee:	2a 85       	ldd	r18, Y+10	; 0x0a
    21f0:	26 17       	cp	r18, r22
    21f2:	d0 f4       	brcc	.+52     	; 0x2228 <CO_collectADC+0x306>
    21f4:	e0 91 54 50 	lds	r30, 0x5054
    21f8:	f0 91 55 50 	lds	r31, 0x5055
    21fc:	ee 0f       	add	r30, r30
    21fe:	ff 1f       	adc	r31, r31
    2200:	ee 0f       	add	r30, r30
    2202:	ff 1f       	adc	r31, r31
    2204:	ea 0d       	add	r30, r10
    2206:	fb 1d       	adc	r31, r11
    2208:	80 81       	ld	r24, Z
    220a:	91 81       	ldd	r25, Z+1	; 0x01
    220c:	a2 81       	ldd	r26, Z+2	; 0x02
    220e:	b3 81       	ldd	r27, Z+3	; 0x03
    2210:	8a 87       	std	Y+10, r24	; 0x0a
    2212:	9f 83       	std	Y+7, r25	; 0x07
    2214:	a8 87       	std	Y+8, r26	; 0x08
    2216:	bc 83       	std	Y+4, r27	; 0x04
    2218:	bb 0f       	add	r27, r27
    221a:	88 0b       	sbc	r24, r24
    221c:	98 2f       	mov	r25, r24
    221e:	dc 01       	movw	r26, r24
    2220:	8a 83       	std	Y+2, r24	; 0x02
    2222:	38 2e       	mov	r3, r24
    2224:	58 2e       	mov	r5, r24
    2226:	78 2e       	mov	r7, r24
		if (min > data24Bit[sampleCount]) { min = data24Bit[sampleCount];}
    2228:	e0 91 54 50 	lds	r30, 0x5054
    222c:	f0 91 55 50 	lds	r31, 0x5055
    2230:	ee 0f       	add	r30, r30
    2232:	ff 1f       	adc	r31, r31
    2234:	ee 0f       	add	r30, r30
    2236:	ff 1f       	adc	r31, r31
    2238:	ea 0d       	add	r30, r10
    223a:	fb 1d       	adc	r31, r11
    223c:	80 81       	ld	r24, Z
    223e:	91 81       	ldd	r25, Z+1	; 0x01
    2240:	a2 81       	ldd	r26, Z+2	; 0x02
    2242:	b3 81       	ldd	r27, Z+3	; 0x03
    2244:	68 2f       	mov	r22, r24
    2246:	49 2f       	mov	r20, r25
    2248:	5a 2f       	mov	r21, r26
    224a:	2b 2f       	mov	r18, r27
    224c:	bb 0f       	add	r27, r27
    224e:	88 0b       	sbc	r24, r24
    2250:	98 2f       	mov	r25, r24
    2252:	dc 01       	movw	r26, r24
    2254:	78 2f       	mov	r23, r24
    2256:	86 15       	cp	r24, r6
    2258:	0c f1       	brlt	.+66     	; 0x229c <CO_collectADC+0x37a>
    225a:	68 16       	cp	r6, r24
    225c:	c9 f5       	brne	.+114    	; 0x22d0 <CO_collectADC+0x3ae>
    225e:	84 15       	cp	r24, r4
    2260:	e8 f0       	brcs	.+58     	; 0x229c <CO_collectADC+0x37a>
    2262:	48 16       	cp	r4, r24
    2264:	a9 f5       	brne	.+106    	; 0x22d0 <CO_collectADC+0x3ae>
    2266:	82 15       	cp	r24, r2
    2268:	c8 f0       	brcs	.+50     	; 0x229c <CO_collectADC+0x37a>
    226a:	28 16       	cp	r2, r24
    226c:	89 f5       	brne	.+98     	; 0x22d0 <CO_collectADC+0x3ae>
    226e:	89 81       	ldd	r24, Y+1	; 0x01
    2270:	78 17       	cp	r23, r24
    2272:	a0 f0       	brcs	.+40     	; 0x229c <CO_collectADC+0x37a>
    2274:	87 17       	cp	r24, r23
    2276:	61 f5       	brne	.+88     	; 0x22d0 <CO_collectADC+0x3ae>
    2278:	9b 81       	ldd	r25, Y+3	; 0x03
    227a:	29 17       	cp	r18, r25
    227c:	78 f0       	brcs	.+30     	; 0x229c <CO_collectADC+0x37a>
    227e:	92 17       	cp	r25, r18
    2280:	39 f5       	brne	.+78     	; 0x22d0 <CO_collectADC+0x3ae>
    2282:	ee 81       	ldd	r30, Y+6	; 0x06
    2284:	5e 17       	cp	r21, r30
    2286:	50 f0       	brcs	.+20     	; 0x229c <CO_collectADC+0x37a>
    2288:	e5 17       	cp	r30, r21
    228a:	11 f5       	brne	.+68     	; 0x22d0 <CO_collectADC+0x3ae>
    228c:	fd 81       	ldd	r31, Y+5	; 0x05
    228e:	4f 17       	cp	r20, r31
    2290:	28 f0       	brcs	.+10     	; 0x229c <CO_collectADC+0x37a>
    2292:	f4 17       	cp	r31, r20
    2294:	e9 f4       	brne	.+58     	; 0x22d0 <CO_collectADC+0x3ae>
    2296:	29 85       	ldd	r18, Y+9	; 0x09
    2298:	62 17       	cp	r22, r18
    229a:	d0 f4       	brcc	.+52     	; 0x22d0 <CO_collectADC+0x3ae>
    229c:	e0 91 54 50 	lds	r30, 0x5054
    22a0:	f0 91 55 50 	lds	r31, 0x5055
    22a4:	ee 0f       	add	r30, r30
    22a6:	ff 1f       	adc	r31, r31
    22a8:	ee 0f       	add	r30, r30
    22aa:	ff 1f       	adc	r31, r31
    22ac:	ea 0d       	add	r30, r10
    22ae:	fb 1d       	adc	r31, r11
    22b0:	80 81       	ld	r24, Z
    22b2:	91 81       	ldd	r25, Z+1	; 0x01
    22b4:	a2 81       	ldd	r26, Z+2	; 0x02
    22b6:	b3 81       	ldd	r27, Z+3	; 0x03
    22b8:	89 87       	std	Y+9, r24	; 0x09
    22ba:	9d 83       	std	Y+5, r25	; 0x05
    22bc:	ae 83       	std	Y+6, r26	; 0x06
    22be:	bb 83       	std	Y+3, r27	; 0x03
    22c0:	bb 0f       	add	r27, r27
    22c2:	88 0b       	sbc	r24, r24
    22c4:	98 2f       	mov	r25, r24
    22c6:	dc 01       	movw	r26, r24
    22c8:	89 83       	std	Y+1, r24	; 0x01
    22ca:	28 2e       	mov	r2, r24
    22cc:	48 2e       	mov	r4, r24
    22ce:	68 2e       	mov	r6, r24
	SPIDisable();	
	enableADCMUX(FALSE);
	ADCPower(FALSE);

	// collect average, max and min of SP samples
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
    22d0:	80 91 54 50 	lds	r24, 0x5054
    22d4:	90 91 55 50 	lds	r25, 0x5055
    22d8:	01 96       	adiw	r24, 0x01	; 1
    22da:	80 93 54 50 	sts	0x5054, r24
    22de:	90 93 55 50 	sts	0x5055, r25
    22e2:	80 91 54 50 	lds	r24, 0x5054
    22e6:	90 91 55 50 	lds	r25, 0x5055
    22ea:	54 e0       	ldi	r21, 0x04	; 4
    22ec:	80 30       	cpi	r24, 0x00	; 0
    22ee:	95 07       	cpc	r25, r21
    22f0:	08 f4       	brcc	.+2      	; 0x22f4 <CO_collectADC+0x3d2>
    22f2:	d8 ce       	rjmp	.-592    	; 0x20a4 <CO_collectADC+0x182>
    22f4:	e9 89       	ldd	r30, Y+17	; 0x11
    22f6:	4a 89       	ldd	r20, Y+18	; 0x12
    22f8:	22 c0       	rjmp	.+68     	; 0x233e <CO_collectADC+0x41c>
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV, int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {

	int64_t sum = 0;
	int64_t average;
	int64_t min = ADC_MAX;
	int64_t max = -ADC_MAX;
    22fa:	61 e0       	ldi	r22, 0x01	; 1
    22fc:	6a 87       	std	Y+10, r22	; 0x0a
    22fe:	1f 82       	std	Y+7, r1	; 0x07
    2300:	80 e8       	ldi	r24, 0x80	; 128
    2302:	88 87       	std	Y+8, r24	; 0x08
    2304:	9f ef       	ldi	r25, 0xFF	; 255
    2306:	9c 83       	std	Y+4, r25	; 0x04
    2308:	ef ef       	ldi	r30, 0xFF	; 255
    230a:	ea 83       	std	Y+2, r30	; 0x02
    230c:	33 24       	eor	r3, r3
    230e:	3a 94       	dec	r3
    2310:	55 24       	eor	r5, r5
    2312:	5a 94       	dec	r5
    2314:	77 24       	eor	r7, r7
    2316:	7a 94       	dec	r7
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV, int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {

	int64_t sum = 0;
	int64_t average;
	int64_t min = ADC_MAX;
    2318:	ff ef       	ldi	r31, 0xFF	; 255
    231a:	f9 87       	std	Y+9, r31	; 0x09
    231c:	2f ef       	ldi	r18, 0xFF	; 255
    231e:	2d 83       	std	Y+5, r18	; 0x05
    2320:	5f e7       	ldi	r21, 0x7F	; 127
    2322:	5e 83       	std	Y+6, r21	; 0x06
    2324:	1b 82       	std	Y+3, r1	; 0x03
    2326:	19 82       	std	Y+1, r1	; 0x01
    2328:	22 24       	eor	r2, r2
    232a:	44 24       	eor	r4, r4
    232c:	66 24       	eor	r6, r6
 *  \param gainExponent		Sets gain to 2^gainExponent[0:2].
 *  \param spsExponent Sets samples per second = 2^spsExponent
*/
void CO_collectADC(uint8_t channel, uint8_t filterConfig, int32_t *avgV, int32_t *minV, int32_t *maxV, uint8_t gainExponent, uint8_t spsExponent) {

	int64_t sum = 0;
    232e:	e0 e0       	ldi	r30, 0x00	; 0
    2330:	30 e0       	ldi	r19, 0x00	; 0
    2332:	40 e0       	ldi	r20, 0x00	; 0
    2334:	10 e0       	ldi	r17, 0x00	; 0
    2336:	00 e0       	ldi	r16, 0x00	; 0
    2338:	88 24       	eor	r8, r8
    233a:	ff 24       	eor	r15, r15
    233c:	99 24       	eor	r9, r9
	for (sampleCount = 0; sampleCount < NUM_SAMPLES; sampleCount++) {
		sum += data24Bit[sampleCount];
		if (max < data24Bit[sampleCount]) { max = data24Bit[sampleCount];}
		if (min > data24Bit[sampleCount]) { min = data24Bit[sampleCount];}
	}
	average = sum / NUM_SAMPLES;
    233e:	2e 2f       	mov	r18, r30
    2340:	51 2f       	mov	r21, r17
    2342:	60 2f       	mov	r22, r16
    2344:	78 2d       	mov	r23, r8
    2346:	8f 2d       	mov	r24, r15
    2348:	99 2d       	mov	r25, r9
    234a:	99 20       	and	r9, r9
    234c:	0c f0       	brlt	.+2      	; 0x2350 <CO_collectADC+0x42e>
    234e:	42 c0       	rjmp	.+132    	; 0x23d4 <CO_collectADC+0x4b2>
    2350:	ae 2f       	mov	r26, r30
    2352:	a1 50       	subi	r26, 0x01	; 1
    2354:	f1 e0       	ldi	r31, 0x01	; 1
    2356:	ae 17       	cp	r26, r30
    2358:	08 f0       	brcs	.+2      	; 0x235c <CO_collectADC+0x43a>
    235a:	f0 e0       	ldi	r31, 0x00	; 0
    235c:	e3 2f       	mov	r30, r19
    235e:	ed 5f       	subi	r30, 0xFD	; 253
    2360:	21 e0       	ldi	r18, 0x01	; 1
    2362:	e3 17       	cp	r30, r19
    2364:	08 f0       	brcs	.+2      	; 0x2368 <CO_collectADC+0x446>
    2366:	20 e0       	ldi	r18, 0x00	; 0
    2368:	fe 0f       	add	r31, r30
    236a:	31 e0       	ldi	r19, 0x01	; 1
    236c:	fe 17       	cp	r31, r30
    236e:	08 f0       	brcs	.+2      	; 0x2372 <CO_collectADC+0x450>
    2370:	30 e0       	ldi	r19, 0x00	; 0
    2372:	23 2b       	or	r18, r19
    2374:	30 e0       	ldi	r19, 0x00	; 0
    2376:	b2 2f       	mov	r27, r18
    2378:	b4 0f       	add	r27, r20
    237a:	21 e0       	ldi	r18, 0x01	; 1
    237c:	b4 17       	cp	r27, r20
    237e:	08 f0       	brcs	.+2      	; 0x2382 <CO_collectADC+0x460>
    2380:	20 e0       	ldi	r18, 0x00	; 0
    2382:	32 2b       	or	r19, r18
    2384:	20 e0       	ldi	r18, 0x00	; 0
    2386:	13 2f       	mov	r17, r19
    2388:	15 0f       	add	r17, r21
    238a:	31 e0       	ldi	r19, 0x01	; 1
    238c:	15 17       	cp	r17, r21
    238e:	08 f0       	brcs	.+2      	; 0x2392 <CO_collectADC+0x470>
    2390:	30 e0       	ldi	r19, 0x00	; 0
    2392:	23 2b       	or	r18, r19
    2394:	30 e0       	ldi	r19, 0x00	; 0
    2396:	02 2f       	mov	r16, r18
    2398:	06 0f       	add	r16, r22
    239a:	21 e0       	ldi	r18, 0x01	; 1
    239c:	06 17       	cp	r16, r22
    239e:	08 f0       	brcs	.+2      	; 0x23a2 <CO_collectADC+0x480>
    23a0:	20 e0       	ldi	r18, 0x00	; 0
    23a2:	32 2b       	or	r19, r18
    23a4:	20 e0       	ldi	r18, 0x00	; 0
    23a6:	83 2e       	mov	r8, r19
    23a8:	87 0e       	add	r8, r23
    23aa:	31 e0       	ldi	r19, 0x01	; 1
    23ac:	87 16       	cp	r8, r23
    23ae:	08 f0       	brcs	.+2      	; 0x23b2 <CO_collectADC+0x490>
    23b0:	30 e0       	ldi	r19, 0x00	; 0
    23b2:	23 2b       	or	r18, r19
    23b4:	f8 2e       	mov	r15, r24
    23b6:	e0 e0       	ldi	r30, 0x00	; 0
    23b8:	82 2f       	mov	r24, r18
    23ba:	8f 0d       	add	r24, r15
    23bc:	21 e0       	ldi	r18, 0x01	; 1
    23be:	8f 15       	cp	r24, r15
    23c0:	08 f0       	brcs	.+2      	; 0x23c4 <CO_collectADC+0x4a2>
    23c2:	20 e0       	ldi	r18, 0x00	; 0
    23c4:	e2 2b       	or	r30, r18
    23c6:	2a 2f       	mov	r18, r26
    23c8:	3f 2f       	mov	r19, r31
    23ca:	4b 2f       	mov	r20, r27
    23cc:	51 2f       	mov	r21, r17
    23ce:	60 2f       	mov	r22, r16
    23d0:	78 2d       	mov	r23, r8
    23d2:	9e 0f       	add	r25, r30
    23d4:	0a e0       	ldi	r16, 0x0A	; 10
    23d6:	0e 94 f6 2c 	call	0x59ec	; 0x59ec <__ashrdi3>

	//convert to uV
	*avgV = (int32_t) -(average * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    23da:	0f 2e       	mov	r0, r31
    23dc:	f0 ea       	ldi	r31, 0xA0	; 160
    23de:	af 2e       	mov	r10, r31
    23e0:	f0 2d       	mov	r31, r0
    23e2:	0f 2e       	mov	r0, r31
    23e4:	f5 e2       	ldi	r31, 0x25	; 37
    23e6:	bf 2e       	mov	r11, r31
    23e8:	f0 2d       	mov	r31, r0
    23ea:	0f 2e       	mov	r0, r31
    23ec:	f6 e2       	ldi	r31, 0x26	; 38
    23ee:	cf 2e       	mov	r12, r31
    23f0:	f0 2d       	mov	r31, r0
    23f2:	dd 24       	eor	r13, r13
    23f4:	ee 24       	eor	r14, r14
    23f6:	ff 24       	eor	r15, r15
    23f8:	00 e0       	ldi	r16, 0x00	; 0
    23fa:	10 e0       	ldi	r17, 0x00	; 0
    23fc:	0e 94 af 2b 	call	0x575e	; 0x575e <__muldi3>
    2400:	aa 24       	eor	r10, r10
    2402:	aa 94       	dec	r10
    2404:	bb 24       	eor	r11, r11
    2406:	ba 94       	dec	r11
    2408:	0f 2e       	mov	r0, r31
    240a:	ff e7       	ldi	r31, 0x7F	; 127
    240c:	cf 2e       	mov	r12, r31
    240e:	f0 2d       	mov	r31, r0
    2410:	0e 94 5e 2d 	call	0x5abc	; 0x5abc <__divdi3>
    2414:	01 e0       	ldi	r16, 0x01	; 1
    2416:	0e 94 82 2c 	call	0x5904	; 0x5904 <__ashldi3>
    241a:	0f 2e       	mov	r0, r31
    241c:	f3 e0       	ldi	r31, 0x03	; 3
    241e:	af 2e       	mov	r10, r31
    2420:	f0 2d       	mov	r31, r0
    2422:	bb 24       	eor	r11, r11
    2424:	cc 24       	eor	r12, r12
    2426:	00 e0       	ldi	r16, 0x00	; 0
    2428:	0e 94 5e 2d 	call	0x5abc	; 0x5abc <__divdi3>
    242c:	82 2e       	mov	r8, r18
    242e:	93 2e       	mov	r9, r19
    2430:	a4 2e       	mov	r10, r20
    2432:	b5 2e       	mov	r11, r21
    2434:	b0 94       	com	r11
    2436:	a0 94       	com	r10
    2438:	90 94       	com	r9
    243a:	80 94       	com	r8
    243c:	81 1c       	adc	r8, r1
    243e:	91 1c       	adc	r9, r1
    2440:	a1 1c       	adc	r10, r1
    2442:	b1 1c       	adc	r11, r1
    2444:	eb 85       	ldd	r30, Y+11	; 0x0b
    2446:	fc 85       	ldd	r31, Y+12	; 0x0c
    2448:	80 82       	st	Z, r8
    244a:	91 82       	std	Z+1, r9	; 0x01
    244c:	a2 82       	std	Z+2, r10	; 0x02
    244e:	b3 82       	std	Z+3, r11	; 0x03
	*maxV = (int32_t) -(max * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    2450:	2a 85       	ldd	r18, Y+10	; 0x0a
    2452:	3f 81       	ldd	r19, Y+7	; 0x07
    2454:	48 85       	ldd	r20, Y+8	; 0x08
    2456:	5c 81       	ldd	r21, Y+4	; 0x04
    2458:	6a 81       	ldd	r22, Y+2	; 0x02
    245a:	73 2d       	mov	r23, r3
    245c:	85 2d       	mov	r24, r5
    245e:	97 2d       	mov	r25, r7
    2460:	0f 2e       	mov	r0, r31
    2462:	f0 ea       	ldi	r31, 0xA0	; 160
    2464:	af 2e       	mov	r10, r31
    2466:	f0 2d       	mov	r31, r0
    2468:	0f 2e       	mov	r0, r31
    246a:	f5 e2       	ldi	r31, 0x25	; 37
    246c:	bf 2e       	mov	r11, r31
    246e:	f0 2d       	mov	r31, r0
    2470:	0f 2e       	mov	r0, r31
    2472:	f6 e2       	ldi	r31, 0x26	; 38
    2474:	cf 2e       	mov	r12, r31
    2476:	f0 2d       	mov	r31, r0
    2478:	dd 24       	eor	r13, r13
    247a:	ee 24       	eor	r14, r14
    247c:	ff 24       	eor	r15, r15
    247e:	0e 94 af 2b 	call	0x575e	; 0x575e <__muldi3>
    2482:	aa 24       	eor	r10, r10
    2484:	aa 94       	dec	r10
    2486:	bb 24       	eor	r11, r11
    2488:	ba 94       	dec	r11
    248a:	0f 2e       	mov	r0, r31
    248c:	ff e7       	ldi	r31, 0x7F	; 127
    248e:	cf 2e       	mov	r12, r31
    2490:	f0 2d       	mov	r31, r0
    2492:	0e 94 5e 2d 	call	0x5abc	; 0x5abc <__divdi3>
    2496:	01 e0       	ldi	r16, 0x01	; 1
    2498:	0e 94 82 2c 	call	0x5904	; 0x5904 <__ashldi3>
    249c:	0f 2e       	mov	r0, r31
    249e:	f3 e0       	ldi	r31, 0x03	; 3
    24a0:	af 2e       	mov	r10, r31
    24a2:	f0 2d       	mov	r31, r0
    24a4:	bb 24       	eor	r11, r11
    24a6:	cc 24       	eor	r12, r12
    24a8:	00 e0       	ldi	r16, 0x00	; 0
    24aa:	0e 94 5e 2d 	call	0x5abc	; 0x5abc <__divdi3>
    24ae:	82 2e       	mov	r8, r18
    24b0:	93 2e       	mov	r9, r19
    24b2:	a4 2e       	mov	r10, r20
    24b4:	b5 2e       	mov	r11, r21
    24b6:	b0 94       	com	r11
    24b8:	a0 94       	com	r10
    24ba:	90 94       	com	r9
    24bc:	80 94       	com	r8
    24be:	81 1c       	adc	r8, r1
    24c0:	91 1c       	adc	r9, r1
    24c2:	a1 1c       	adc	r10, r1
    24c4:	b1 1c       	adc	r11, r1
    24c6:	ef 85       	ldd	r30, Y+15	; 0x0f
    24c8:	f8 89       	ldd	r31, Y+16	; 0x10
    24ca:	80 82       	st	Z, r8
    24cc:	91 82       	std	Z+1, r9	; 0x01
    24ce:	a2 82       	std	Z+2, r10	; 0x02
    24d0:	b3 82       	std	Z+3, r11	; 0x03
	*minV = (int32_t) -(min * ADC_VREF / ADC_MAX * ADC_DRIVER_GAIN_DENOMINATOR / ADC_DRIVER_GAIN_NUMERATOR);
    24d2:	29 85       	ldd	r18, Y+9	; 0x09
    24d4:	3d 81       	ldd	r19, Y+5	; 0x05
    24d6:	4e 81       	ldd	r20, Y+6	; 0x06
    24d8:	5b 81       	ldd	r21, Y+3	; 0x03
    24da:	69 81       	ldd	r22, Y+1	; 0x01
    24dc:	72 2d       	mov	r23, r2
    24de:	84 2d       	mov	r24, r4
    24e0:	96 2d       	mov	r25, r6
    24e2:	0f 2e       	mov	r0, r31
    24e4:	f0 ea       	ldi	r31, 0xA0	; 160
    24e6:	af 2e       	mov	r10, r31
    24e8:	f0 2d       	mov	r31, r0
    24ea:	0f 2e       	mov	r0, r31
    24ec:	f5 e2       	ldi	r31, 0x25	; 37
    24ee:	bf 2e       	mov	r11, r31
    24f0:	f0 2d       	mov	r31, r0
    24f2:	0f 2e       	mov	r0, r31
    24f4:	f6 e2       	ldi	r31, 0x26	; 38
    24f6:	cf 2e       	mov	r12, r31
    24f8:	f0 2d       	mov	r31, r0
    24fa:	dd 24       	eor	r13, r13
    24fc:	ee 24       	eor	r14, r14
    24fe:	ff 24       	eor	r15, r15
    2500:	0e 94 af 2b 	call	0x575e	; 0x575e <__muldi3>
    2504:	aa 24       	eor	r10, r10
    2506:	aa 94       	dec	r10
    2508:	bb 24       	eor	r11, r11
    250a:	ba 94       	dec	r11
    250c:	0f 2e       	mov	r0, r31
    250e:	ff e7       	ldi	r31, 0x7F	; 127
    2510:	cf 2e       	mov	r12, r31
    2512:	f0 2d       	mov	r31, r0
    2514:	0e 94 5e 2d 	call	0x5abc	; 0x5abc <__divdi3>
    2518:	01 e0       	ldi	r16, 0x01	; 1
    251a:	0e 94 82 2c 	call	0x5904	; 0x5904 <__ashldi3>
    251e:	0f 2e       	mov	r0, r31
    2520:	f3 e0       	ldi	r31, 0x03	; 3
    2522:	af 2e       	mov	r10, r31
    2524:	f0 2d       	mov	r31, r0
    2526:	bb 24       	eor	r11, r11
    2528:	cc 24       	eor	r12, r12
    252a:	00 e0       	ldi	r16, 0x00	; 0
    252c:	0e 94 5e 2d 	call	0x5abc	; 0x5abc <__divdi3>
    2530:	82 2e       	mov	r8, r18
    2532:	93 2e       	mov	r9, r19
    2534:	a4 2e       	mov	r10, r20
    2536:	b5 2e       	mov	r11, r21
    2538:	b0 94       	com	r11
    253a:	a0 94       	com	r10
    253c:	90 94       	com	r9
    253e:	80 94       	com	r8
    2540:	81 1c       	adc	r8, r1
    2542:	91 1c       	adc	r9, r1
    2544:	a1 1c       	adc	r10, r1
    2546:	b1 1c       	adc	r11, r1
    2548:	ed 85       	ldd	r30, Y+13	; 0x0d
    254a:	fe 85       	ldd	r31, Y+14	; 0x0e
    254c:	80 82       	st	Z, r8
    254e:	91 82       	std	Z+1, r9	; 0x01
    2550:	a2 82       	std	Z+2, r10	; 0x02
    2552:	b3 82       	std	Z+3, r11	; 0x03

}
    2554:	62 96       	adiw	r28, 0x12	; 18
    2556:	cd bf       	out	0x3d, r28	; 61
    2558:	de bf       	out	0x3e, r29	; 62
    255a:	df 91       	pop	r29
    255c:	cf 91       	pop	r28
    255e:	1f 91       	pop	r17
    2560:	0f 91       	pop	r16
    2562:	ff 90       	pop	r15
    2564:	ef 90       	pop	r14
    2566:	df 90       	pop	r13
    2568:	cf 90       	pop	r12
    256a:	bf 90       	pop	r11
    256c:	af 90       	pop	r10
    256e:	9f 90       	pop	r9
    2570:	8f 90       	pop	r8
    2572:	7f 90       	pop	r7
    2574:	6f 90       	pop	r6
    2576:	5f 90       	pop	r5
    2578:	4f 90       	pop	r4
    257a:	3f 90       	pop	r3
    257c:	2f 90       	pop	r2
    257e:	08 95       	ret

00002580 <ADC_ResultCh_GetWord_Unsigned>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  offset  Unsigned offset value to subtract.
 *  \return  The unsigned Conversion result with the offset substracted.
 */
uint16_t ADC_ResultCh_GetWord_Unsigned(ADC_CH_t * adc_ch, uint8_t offset)
{
    2580:	fc 01       	movw	r30, r24
  	uint16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2582:	81 e0       	ldi	r24, 0x01	; 1
    2584:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - offset;
    2586:	84 81       	ldd	r24, Z+4	; 0x04
    2588:	95 81       	ldd	r25, Z+5	; 0x05
    258a:	86 1b       	sub	r24, r22
    258c:	91 09       	sbc	r25, r1

	return answer;
}
    258e:	08 95       	ret

00002590 <ADC_ResultCh_GetWord_Signed>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \param  signedOffset  Offset value to subtract.
 *  \return  The signed Conversion result with the offset substracted.
 */
int16_t ADC_ResultCh_GetWord_Signed(ADC_CH_t * adc_ch, int8_t signedOffset)
{
    2590:	fc 01       	movw	r30, r24
  	int16_t answer;

	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    2592:	81 e0       	ldi	r24, 0x01	; 1
    2594:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	answer = adc_ch->RES - signedOffset;
    2596:	84 81       	ldd	r24, Z+4	; 0x04
    2598:	95 81       	ldd	r25, Z+5	; 0x05
    259a:	77 27       	eor	r23, r23
    259c:	67 fd       	sbrc	r22, 7
    259e:	70 95       	com	r23
    25a0:	86 1b       	sub	r24, r22
    25a2:	97 0b       	sbc	r25, r23

	return answer;
}
    25a4:	08 95       	ret

000025a6 <ADC_ResultCh_GetWord>:
 *
 *  \param  adc_ch  Pointer to ADC channel register section.
 *  \return  Signed conversion result.
 */
uint16_t ADC_ResultCh_GetWord(ADC_CH_t * adc_ch)
{
    25a6:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    25a8:	81 e0       	ldi	r24, 0x01	; 1
    25aa:	83 83       	std	Z+3, r24	; 0x03

	/* Return result register contents*/
	return adc_ch->RES;;
    25ac:	84 81       	ldd	r24, Z+4	; 0x04
    25ae:	95 81       	ldd	r25, Z+5	; 0x05
}
    25b0:	08 95       	ret

000025b2 <ADC_ResultCh_GetLowByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  Low byte of conversion result.
 */
uint8_t ADC_ResultCh_GetLowByte(ADC_CH_t * adc_ch)
{
    25b2:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    25b4:	81 e0       	ldi	r24, 0x01	; 1
    25b6:	83 83       	std	Z+3, r24	; 0x03
	/* Return result register contents*/
	return adc_ch->RESL;
    25b8:	84 81       	ldd	r24, Z+4	; 0x04
}
    25ba:	08 95       	ret

000025bc <ADC_ResultCh_GetHighByte>:
 *  \param  adc_ch  Pointer to ADC channel register section.
 *
 *  \return  High byte of conversion result.
 */
uint8_t ADC_ResultCh_GetHighByte(ADC_CH_t * adc_ch)
{
    25bc:	fc 01       	movw	r30, r24
	/* Clear interrupt flag.*/
	adc_ch->INTFLAGS = ADC_CH_CHIF_bm;
    25be:	81 e0       	ldi	r24, 0x01	; 1
    25c0:	83 83       	std	Z+3, r24	; 0x03

	/* Return low byte result register contents.*/
	return adc_ch->RESH;
    25c2:	85 81       	ldd	r24, Z+5	; 0x05
}
    25c4:	08 95       	ret

000025c6 <ADC_Wait_8MHz>:
 *        than 8 MHz use the ADC_wait_32MHz function.
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_8MHz(ADC_t * adc)
{
    25c6:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    25c8:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
    25ca:	14 82       	std	Z+4, r1	; 0x04
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    25cc:	9a e2       	ldi	r25, 0x2A	; 42
    25ce:	9a 95       	dec	r25
    25d0:	f1 f7       	brne	.-4      	; 0x25ce <ADC_Wait_8MHz+0x8>
    25d2:	00 c0       	rjmp	.+0      	; 0x25d4 <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    25d4:	84 83       	std	Z+4, r24	; 0x04
}
    25d6:	08 95       	ret

000025d8 <ADC_Wait_32MHz>:
 *        device goes into sleep (not Idle sleep mode).
 *
 *  \param  adc Pointer to ADC module register section.
 */
void ADC_Wait_32MHz(ADC_t * adc)
{
    25d8:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
    25da:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV8_gc;
    25dc:	91 e0       	ldi	r25, 0x01	; 1
    25de:	94 83       	std	Z+4, r25	; 0x04
    25e0:	95 e5       	ldi	r25, 0x55	; 85
    25e2:	9a 95       	dec	r25
    25e4:	f1 f7       	brne	.-4      	; 0x25e2 <ADC_Wait_32MHz+0xa>
    25e6:	00 00       	nop

	/* wait 8*COMMON_MODE_CYCLES for common mode to settle*/
	delay_us(8*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
    25e8:	84 83       	std	Z+4, r24	; 0x04
}
    25ea:	08 95       	ret

000025ec <ADC_Offset_Get_Unsigned>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    25ec:	ef 92       	push	r14
    25ee:	ff 92       	push	r15
    25f0:	0f 93       	push	r16
    25f2:	1f 93       	push	r17
    25f4:	cf 93       	push	r28
    25f6:	df 93       	push	r29
    25f8:	eb 01       	movw	r28, r22
    if (oversampling)
    25fa:	44 23       	and	r20, r20
    25fc:	c9 f0       	breq	.+50     	; 0x2630 <ADC_Offset_Get_Unsigned+0x44>
    25fe:	04 e0       	ldi	r16, 0x04	; 4
    2600:	10 e0       	ldi	r17, 0x00	; 0
    2602:	ee 24       	eor	r14, r14
    2604:	ff 24       	eor	r15, r15
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    2606:	88 81       	ld	r24, Y
    2608:	80 68       	ori	r24, 0x80	; 128
    260a:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    260c:	8b 81       	ldd	r24, Y+3	; 0x03
    260e:	80 ff       	sbrs	r24, 0
    2610:	fd cf       	rjmp	.-6      	; 0x260c <ADC_Offset_Get_Unsigned+0x20>
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
    2612:	ce 01       	movw	r24, r28
    2614:	60 e0       	ldi	r22, 0x00	; 0
    2616:	0e 94 c0 12 	call	0x2580	; 0x2580 <ADC_ResultCh_GetWord_Unsigned>
    261a:	e8 0e       	add	r14, r24
    261c:	f9 1e       	adc	r15, r25
    261e:	01 50       	subi	r16, 0x01	; 1
    2620:	10 40       	sbci	r17, 0x00	; 0
uint8_t ADC_Offset_Get_Unsigned(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      uint16_t offset=0;
      for (int i=0; i<4; i++)
    2622:	89 f7       	brne	.-30     	; 0x2606 <ADC_Offset_Get_Unsigned+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Unsigned(ch, 0x00);
      }
      return ((uint8_t)(offset>>2));
    2624:	c7 01       	movw	r24, r14
    2626:	96 95       	lsr	r25
    2628:	87 95       	ror	r24
    262a:	96 95       	lsr	r25
    262c:	87 95       	ror	r24
    262e:	09 c0       	rjmp	.+18     	; 0x2642 <ADC_Offset_Get_Unsigned+0x56>
    else
    {        
      uint8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    2630:	88 81       	ld	r24, Y
    2632:	80 68       	ori	r24, 0x80	; 128
    2634:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    2636:	8b 81       	ldd	r24, Y+3	; 0x03
    2638:	80 ff       	sbrs	r24, 0
    263a:	fd cf       	rjmp	.-6      	; 0x2636 <ADC_Offset_Get_Unsigned+0x4a>
      offset = (uint8_t)ADC_ResultCh_GetWord(ch);
    263c:	ce 01       	movw	r24, r28
    263e:	0e 94 d3 12 	call	0x25a6	; 0x25a6 <ADC_ResultCh_GetWord>
      
      return offset;
    }
}
    2642:	df 91       	pop	r29
    2644:	cf 91       	pop	r28
    2646:	1f 91       	pop	r17
    2648:	0f 91       	pop	r16
    264a:	ff 90       	pop	r15
    264c:	ef 90       	pop	r14
    264e:	08 95       	ret

00002650 <ADC_Offset_Get_Signed>:
 *  \param oversampling false for one measurement. true for averaging several measurements.
 *
 *  \return Offset on the selected ADC
 */
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    2650:	ef 92       	push	r14
    2652:	ff 92       	push	r15
    2654:	0f 93       	push	r16
    2656:	1f 93       	push	r17
    2658:	cf 93       	push	r28
    265a:	df 93       	push	r29
    265c:	eb 01       	movw	r28, r22
    if (oversampling)
    265e:	44 23       	and	r20, r20
    2660:	e1 f0       	breq	.+56     	; 0x269a <ADC_Offset_Get_Signed+0x4a>
    2662:	04 e0       	ldi	r16, 0x04	; 4
    2664:	10 e0       	ldi	r17, 0x00	; 0
    2666:	ee 24       	eor	r14, r14
    2668:	ff 24       	eor	r15, r15
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
      {
        /* Do one conversion to find offset. */
        ADC_Ch_Conversion_Start(ch);
    266a:	88 81       	ld	r24, Y
    266c:	80 68       	ori	r24, 0x80	; 128
    266e:	88 83       	st	Y, r24
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
    2670:	8b 81       	ldd	r24, Y+3	; 0x03
    2672:	80 ff       	sbrs	r24, 0
    2674:	fd cf       	rjmp	.-6      	; 0x2670 <ADC_Offset_Get_Signed+0x20>
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
    2676:	ce 01       	movw	r24, r28
    2678:	60 e0       	ldi	r22, 0x00	; 0
    267a:	0e 94 c8 12 	call	0x2590	; 0x2590 <ADC_ResultCh_GetWord_Signed>
    267e:	e8 0e       	add	r14, r24
    2680:	f9 1e       	adc	r15, r25
    2682:	01 50       	subi	r16, 0x01	; 1
    2684:	10 40       	sbci	r17, 0x00	; 0
int8_t ADC_Offset_Get_Signed(ADC_t * adc, ADC_CH_t *ch, bool oversampling)
{
    if (oversampling)
    {
      int16_t offset=0;
      for (int i=0; i<4; i++)
    2686:	89 f7       	brne	.-30     	; 0x266a <ADC_Offset_Get_Signed+0x1a>
    
        do{
        }while(!ADC_Ch_Conversion_Complete(ch));
        offset += ADC_ResultCh_GetWord_Signed(ch, 0x00);
      }
      return ((int8_t)(offset/4));
    2688:	c7 01       	movw	r24, r14
    268a:	99 23       	and	r25, r25
    268c:	0c f4       	brge	.+2      	; 0x2690 <ADC_Offset_Get_Signed+0x40>
    268e:	03 96       	adiw	r24, 0x03	; 3
    2690:	95 95       	asr	r25
    2692:	87 95       	ror	r24
    2694:	95 95       	asr	r25
    2696:	87 95       	ror	r24
    2698:	0a c0       	rjmp	.+20     	; 0x26ae <ADC_Offset_Get_Signed+0x5e>
    else
    {        
      int8_t offset=0;
      
      /* Do one conversion to find offset. */
      ADC_Ch_Conversion_Start(ch);
    269a:	88 81       	ld	r24, Y
    269c:	80 68       	ori	r24, 0x80	; 128
    269e:	88 83       	st	Y, r24
  
      do{
      }while(!ADC_Ch_Conversion_Complete(ch));
    26a0:	8b 81       	ldd	r24, Y+3	; 0x03
    26a2:	80 ff       	sbrs	r24, 0
    26a4:	fd cf       	rjmp	.-6      	; 0x26a0 <ADC_Offset_Get_Signed+0x50>
      offset = (uint8_t)ADC_ResultCh_GetWord_Signed(ch, 0x00);
    26a6:	ce 01       	movw	r24, r28
    26a8:	60 e0       	ldi	r22, 0x00	; 0
    26aa:	0e 94 c8 12 	call	0x2590	; 0x2590 <ADC_ResultCh_GetWord_Signed>
      
      return offset;
    }
}
    26ae:	df 91       	pop	r29
    26b0:	cf 91       	pop	r28
    26b2:	1f 91       	pop	r17
    26b4:	0f 91       	pop	r16
    26b6:	ff 90       	pop	r15
    26b8:	ef 90       	pop	r14
    26ba:	08 95       	ret

000026bc <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
    26bc:	aa ec       	ldi	r26, 0xCA	; 202
    26be:	b1 e0       	ldi	r27, 0x01	; 1
    26c0:	92 e0       	ldi	r25, 0x02	; 2
    26c2:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
    26c4:	e8 2f       	mov	r30, r24
    26c6:	f0 e0       	ldi	r31, 0x00	; 0
    26c8:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
    26ca:	1c 92       	st	X, r1

	return result;
}
    26cc:	08 95       	ret

000026ce <ADC_CalibrationValues_Load>:
 *  register. The calibration data reduces the non-linearity error in the adc.
 *
 *  \param  adc          Pointer to ADC module register section.
 */
void ADC_CalibrationValues_Load(ADC_t * adc)
{
    26ce:	cf 93       	push	r28
    26d0:	df 93       	push	r29
    26d2:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
    26d4:	82 e0       	ldi	r24, 0x02	; 2
    26d6:	c0 30       	cpi	r28, 0x00	; 0
    26d8:	d8 07       	cpc	r29, r24
    26da:	59 f4       	brne	.+22     	; 0x26f2 <ADC_CalibrationValues_Load+0x24>
		 /* Get ADCACAL0 from production signature . */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL0_offset );
    26dc:	80 e2       	ldi	r24, 0x20	; 32
    26de:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SP_ReadCalibrationByte>
    26e2:	c0 e0       	ldi	r28, 0x00	; 0
    26e4:	d2 e0       	ldi	r29, 0x02	; 2
    26e6:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCACAL1_offset );
    26e8:	81 e2       	ldi	r24, 0x21	; 33
    26ea:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SP_ReadCalibrationByte>
    26ee:	8d 87       	std	Y+13, r24	; 0x0d
    26f0:	08 c0       	rjmp	.+16     	; 0x2702 <ADC_CalibrationValues_Load+0x34>
	}else {
		/* Get ADCBCAL0 from production signature  */
		adc->CALL = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL0_offset );
    26f2:	84 e2       	ldi	r24, 0x24	; 36
    26f4:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SP_ReadCalibrationByte>
    26f8:	8c 87       	std	Y+12, r24	; 0x0c
		adc->CALH = SP_ReadCalibrationByte( PROD_SIGNATURES_START + ADCBCAL1_offset );
    26fa:	85 e2       	ldi	r24, 0x25	; 37
    26fc:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SP_ReadCalibrationByte>
    2700:	8d 87       	std	Y+13, r24	; 0x0d
	}
}
    2702:	df 91       	pop	r29
    2704:	cf 91       	pop	r28
    2706:	08 95       	ret

00002708 <chb_init>:

*/
/**************************************************************************/
void chb_init()
{
    memset(&pcb, 0, sizeof(pcb_t));
    2708:	84 e1       	ldi	r24, 0x14	; 20
    270a:	e2 e2       	ldi	r30, 0x22	; 34
    270c:	f1 e2       	ldi	r31, 0x21	; 33
    270e:	df 01       	movw	r26, r30
    2710:	1d 92       	st	X+, r1
    2712:	8a 95       	dec	r24
    2714:	e9 f7       	brne	.-6      	; 0x2710 <chb_init+0x8>
    pcb.src_addr = chb_get_short_addr();
    2716:	0e 94 f4 14 	call	0x29e8	; 0x29e8 <chb_get_short_addr>
    271a:	80 93 22 21 	sts	0x2122, r24
    271e:	90 93 23 21 	sts	0x2123, r25
    chb_drvr_init();
    2722:	0e 94 31 17 	call	0x2e62	; 0x2e62 <chb_drvr_init>
}
    2726:	08 95       	ret

00002728 <chb_get_pcb>:
*/
/**************************************************************************/
pcb_t *chb_get_pcb()
{
    return &pcb;
}
    2728:	82 e2       	ldi	r24, 0x22	; 34
    272a:	91 e2       	ldi	r25, 0x21	; 33
    272c:	08 95       	ret

0000272e <chb_write>:
/*!

*/
/**************************************************************************/
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    272e:	2f 92       	push	r2
    2730:	3f 92       	push	r3
    2732:	4f 92       	push	r4
    2734:	5f 92       	push	r5
    2736:	6f 92       	push	r6
    2738:	7f 92       	push	r7
    273a:	8f 92       	push	r8
    273c:	9f 92       	push	r9
    273e:	af 92       	push	r10
    2740:	bf 92       	push	r11
    2742:	cf 92       	push	r12
    2744:	df 92       	push	r13
    2746:	ef 92       	push	r14
    2748:	ff 92       	push	r15
    274a:	0f 93       	push	r16
    274c:	1f 93       	push	r17
    274e:	cf 93       	push	r28
    2750:	df 93       	push	r29
    2752:	cd b7       	in	r28, 0x3d	; 61
    2754:	de b7       	in	r29, 0x3e	; 62
    2756:	2e 97       	sbiw	r28, 0x0e	; 14
    2758:	cd bf       	out	0x3d, r28	; 61
    275a:	de bf       	out	0x3e, r29	; 62
    275c:	8b 87       	std	Y+11, r24	; 0x0b
    275e:	9c 87       	std	Y+12, r25	; 0x0c
    2760:	6d 87       	std	Y+13, r22	; 0x0d
    2762:	7e 87       	std	Y+14, r23	; 0x0e
    2764:	49 01       	movw	r8, r18
    2766:	5a 01       	movw	r10, r20
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    2768:	21 15       	cp	r18, r1
    276a:	31 05       	cpc	r19, r1
    276c:	41 05       	cpc	r20, r1
    276e:	51 05       	cpc	r21, r1
    2770:	09 f4       	brne	.+2      	; 0x2774 <chb_write+0x46>
    2772:	85 c0       	rjmp	.+266    	; 0x287e <chb_write+0x150>
U8 chb_write(U16 addr, U8 *data, U32 len)
{
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    2774:	ee 24       	eor	r14, r14
             case CHB_NO_ACK:
                 pcb.txd_noack++;
                 break;
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    2776:	0f 2e       	mov	r0, r31
    2778:	fd e2       	ldi	r31, 0x2D	; 45
    277a:	6f 2e       	mov	r6, r31
    277c:	f1 e2       	ldi	r31, 0x21	; 33
    277e:	7f 2e       	mov	r7, r31
    2780:	f0 2d       	mov	r31, r0
             switch (status)
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    2782:	0f 2e       	mov	r0, r31
    2784:	f9 e2       	ldi	r31, 0x29	; 41
    2786:	4f 2e       	mov	r4, r31
    2788:	f1 e2       	ldi	r31, 0x21	; 33
    278a:	5f 2e       	mov	r5, r31
    278c:	f0 2d       	mov	r31, r0
                 break;
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    278e:	0f 2e       	mov	r0, r31
    2790:	fb e2       	ldi	r31, 0x2B	; 43
    2792:	2f 2e       	mov	r2, r31
    2794:	f1 e2       	ldi	r31, 0x21	; 33
    2796:	3f 2e       	mov	r3, r31
    2798:	f0 2d       	mov	r31, r0
	frm_offset = 0;
    while (len > 0)
    {
        // calculate which frame len to use. if greater than max payload, split
        // up operation.
        frm_len = (len > CHB_MAX_PAYLOAD) ? CHB_MAX_PAYLOAD : len;
    279a:	f8 2c       	mov	r15, r8
    279c:	25 e6       	ldi	r18, 0x65	; 101
    279e:	82 16       	cp	r8, r18
    27a0:	91 04       	cpc	r9, r1
    27a2:	a1 04       	cpc	r10, r1
    27a4:	b1 04       	cpc	r11, r1
    27a6:	20 f0       	brcs	.+8      	; 0x27b0 <chb_write+0x82>
    27a8:	0f 2e       	mov	r0, r31
    27aa:	f4 e6       	ldi	r31, 0x64	; 100
    27ac:	ff 2e       	mov	r15, r31
    27ae:	f0 2d       	mov	r31, r0
{
    U8 *hdr_ptr = hdr;

    // calc frame size and put in 0 position of array
    // frame size = hdr sz + payload len + fcs len
    *hdr_ptr++ = CHB_HDR_SZ + len + CHB_FCS_LEN;
    27b0:	8f 2d       	mov	r24, r15
    27b2:	85 5f       	subi	r24, 0xF5	; 245
    27b4:	89 83       	std	Y+1, r24	; 0x01

    // use default fcf byte 0 val but test for ack request. we won't request
    // ack if broadcast. all other cases we will.
    *hdr_ptr++ = CHB_FCF_BYTE_0 | ((addr != 0xFFFF) << CHB_ACK_REQ_POS);
    27b6:	8b 85       	ldd	r24, Y+11	; 0x0b
    27b8:	9c 85       	ldd	r25, Y+12	; 0x0c
    27ba:	ef ef       	ldi	r30, 0xFF	; 255
    27bc:	8f 3f       	cpi	r24, 0xFF	; 255
    27be:	9e 07       	cpc	r25, r30
    27c0:	11 f0       	breq	.+4      	; 0x27c6 <chb_write+0x98>
    27c2:	81 e6       	ldi	r24, 0x61	; 97
    27c4:	01 c0       	rjmp	.+2      	; 0x27c8 <chb_write+0x9a>
    27c6:	81 e4       	ldi	r24, 0x41	; 65
    27c8:	8a 83       	std	Y+2, r24	; 0x02
    *hdr_ptr++ = CHB_FCF_BYTE_1;
    27ca:	88 e9       	ldi	r24, 0x98	; 152
    27cc:	8b 83       	std	Y+3, r24	; 0x03

    *hdr_ptr++ = pcb.seq++;
    27ce:	e4 e2       	ldi	r30, 0x24	; 36
    27d0:	f1 e2       	ldi	r31, 0x21	; 33
    27d2:	80 81       	ld	r24, Z
    27d4:	8c 83       	std	Y+4, r24	; 0x04
    27d6:	8f 5f       	subi	r24, 0xFF	; 255
    27d8:	80 83       	st	Z, r24

    // fill out dest pan ID, dest addr, src addr
    *(U16 *)hdr_ptr = CHB_PAN_ID;
    27da:	84 e3       	ldi	r24, 0x34	; 52
    27dc:	92 e1       	ldi	r25, 0x12	; 18
    27de:	8d 83       	std	Y+5, r24	; 0x05
    27e0:	9e 83       	std	Y+6, r25	; 0x06
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = addr;
    27e2:	8b 85       	ldd	r24, Y+11	; 0x0b
    27e4:	9c 85       	ldd	r25, Y+12	; 0x0c
    27e6:	8f 83       	std	Y+7, r24	; 0x07
    27e8:	98 87       	std	Y+8, r25	; 0x08
    hdr_ptr += sizeof(U16);
    *(U16 *)hdr_ptr = pcb.src_addr;
    27ea:	32 97       	sbiw	r30, 0x02	; 2
    27ec:	80 81       	ld	r24, Z
    27ee:	91 81       	ldd	r25, Z+1	; 0x01
    27f0:	89 87       	std	Y+9, r24	; 0x09
    27f2:	9a 87       	std	Y+10, r25	; 0x0a

        // gen frame header
        hdr_len = chb_gen_hdr(hdr, addr, frm_len);

        // send data to chip
		rtry = 0;
    27f4:	00 e0       	ldi	r16, 0x00	; 0
    27f6:	10 e0       	ldi	r17, 0x00	; 0
		do{
        status = chb_tx(hdr, data+frm_offset, frm_len);			
    27f8:	cd 84       	ldd	r12, Y+13	; 0x0d
    27fa:	de 84       	ldd	r13, Y+14	; 0x0e
    27fc:	ce 0c       	add	r12, r14
    27fe:	d1 1c       	adc	r13, r1
    2800:	ce 01       	movw	r24, r28
    2802:	01 96       	adiw	r24, 0x01	; 1
    2804:	b6 01       	movw	r22, r12
    2806:	4f 2d       	mov	r20, r15
    2808:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <chb_tx>
    280c:	28 2f       	mov	r18, r24

             switch (status)
    280e:	83 30       	cpi	r24, 0x03	; 3
    2810:	b9 f0       	breq	.+46     	; 0x2840 <chb_write+0x112>
    2812:	84 30       	cpi	r24, 0x04	; 4
    2814:	18 f4       	brcc	.+6      	; 0x281c <chb_write+0xee>
    2816:	81 30       	cpi	r24, 0x01	; 1
    2818:	c9 f4       	brne	.+50     	; 0x284c <chb_write+0x11e>
    281a:	04 c0       	rjmp	.+8      	; 0x2824 <chb_write+0xf6>
    281c:	85 30       	cpi	r24, 0x05	; 5
    281e:	49 f0       	breq	.+18     	; 0x2832 <chb_write+0x104>
    2820:	80 34       	cpi	r24, 0x40	; 64
    2822:	a1 f4       	brne	.+40     	; 0x284c <chb_write+0x11e>
             {
             case RADIO_SUCCESS:
                  //fall through
             case CHB_SUCCESS_DATA_PENDING:
                 pcb.txd_success++;
    2824:	f2 01       	movw	r30, r4
    2826:	80 81       	ld	r24, Z
    2828:	91 81       	ldd	r25, Z+1	; 0x01
    282a:	01 96       	adiw	r24, 0x01	; 1
    282c:	80 83       	st	Z, r24
    282e:	91 83       	std	Z+1, r25	; 0x01
                 break;
    2830:	0d c0       	rjmp	.+26     	; 0x284c <chb_write+0x11e>
 
             case CHB_NO_ACK:
                 pcb.txd_noack++;
    2832:	f1 01       	movw	r30, r2
    2834:	80 81       	ld	r24, Z
    2836:	91 81       	ldd	r25, Z+1	; 0x01
    2838:	01 96       	adiw	r24, 0x01	; 1
    283a:	80 83       	st	Z, r24
    283c:	91 83       	std	Z+1, r25	; 0x01
                 break;
    283e:	06 c0       	rjmp	.+12     	; 0x284c <chb_write+0x11e>
 
             case CHB_CHANNEL_ACCESS_FAILURE:
                 pcb.txd_channel_fail++;
    2840:	f3 01       	movw	r30, r6
    2842:	80 81       	ld	r24, Z
    2844:	91 81       	ldd	r25, Z+1	; 0x01
    2846:	01 96       	adiw	r24, 0x01	; 1
    2848:	80 83       	st	Z, r24
    284a:	91 83       	std	Z+1, r25	; 0x01
                 break;
 
             default:
                 break;
             }
			if(rtry>=0) _delay_us(100);		//if not successfully sent the first time, wait some time and try again
    284c:	11 23       	and	r17, r17
    284e:	24 f0       	brlt	.+8      	; 0x2858 <chb_write+0x12a>
    2850:	f1 e2       	ldi	r31, 0x21	; 33
    2852:	fa 95       	dec	r31
    2854:	f1 f7       	brne	.-4      	; 0x2852 <chb_write+0x124>
    2856:	00 00       	nop
			if(rtry==20) return status;;		//after 20 tries give up on sending the message
    2858:	04 31       	cpi	r16, 0x14	; 20
    285a:	11 05       	cpc	r17, r1
    285c:	89 f0       	breq	.+34     	; 0x2880 <chb_write+0x152>
			rtry++;	
    285e:	0f 5f       	subi	r16, 0xFF	; 255
    2860:	1f 4f       	sbci	r17, 0xFF	; 255
		} while(status != CHB_SUCCESS);			
    2862:	22 23       	and	r18, r18
    2864:	69 f6       	brne	.-102    	; 0x2800 <chb_write+0xd2>
        // adjust len and restart
		frm_offset += frm_len;
    2866:	ef 0c       	add	r14, r15
        len = len - frm_len;
    2868:	8f 18       	sub	r8, r15
    286a:	91 08       	sbc	r9, r1
    286c:	a1 08       	sbc	r10, r1
    286e:	b1 08       	sbc	r11, r1
{
    U8 status, frm_len, frm_offset, hdr_len, hdr[CHB_HDR_SZ + 1];
    int rtry;
	
	frm_offset = 0;
    while (len > 0)
    2870:	81 14       	cp	r8, r1
    2872:	91 04       	cpc	r9, r1
    2874:	a1 04       	cpc	r10, r1
    2876:	b1 04       	cpc	r11, r1
    2878:	09 f0       	breq	.+2      	; 0x287c <chb_write+0x14e>
    287a:	8f cf       	rjmp	.-226    	; 0x279a <chb_write+0x6c>
    287c:	01 c0       	rjmp	.+2      	; 0x2880 <chb_write+0x152>
        // adjust len and restart
		frm_offset += frm_len;
        len = len - frm_len;
		//_delay_ms(1000);				//wait a little before sending next message
    }
    return CHB_SUCCESS;
    287e:	20 e0       	ldi	r18, 0x00	; 0
}
    2880:	82 2f       	mov	r24, r18
    2882:	2e 96       	adiw	r28, 0x0e	; 14
    2884:	cd bf       	out	0x3d, r28	; 61
    2886:	de bf       	out	0x3e, r29	; 62
    2888:	df 91       	pop	r29
    288a:	cf 91       	pop	r28
    288c:	1f 91       	pop	r17
    288e:	0f 91       	pop	r16
    2890:	ff 90       	pop	r15
    2892:	ef 90       	pop	r14
    2894:	df 90       	pop	r13
    2896:	cf 90       	pop	r12
    2898:	bf 90       	pop	r11
    289a:	af 90       	pop	r10
    289c:	9f 90       	pop	r9
    289e:	8f 90       	pop	r8
    28a0:	7f 90       	pop	r7
    28a2:	6f 90       	pop	r6
    28a4:	5f 90       	pop	r5
    28a6:	4f 90       	pop	r4
    28a8:	3f 90       	pop	r3
    28aa:	2f 90       	pop	r2
    28ac:	08 95       	ret

000028ae <chb_read>:
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
{
    28ae:	df 92       	push	r13
    28b0:	ef 92       	push	r14
    28b2:	ff 92       	push	r15
    28b4:	0f 93       	push	r16
    28b6:	1f 93       	push	r17
    28b8:	cf 93       	push	r28
    28ba:	df 93       	push	r29
    28bc:	7c 01       	movw	r14, r24

    data_ptr = rx->data;

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    28be:	0e 94 d2 14 	call	0x29a4	; 0x29a4 <chb_buf_read>
    28c2:	d8 2e       	mov	r13, r24
    28c4:	88 23       	and	r24, r24
    28c6:	0c f4       	brge	.+2      	; 0x28ca <chb_read+0x1c>
    28c8:	46 c0       	rjmp	.+140    	; 0x2956 <chb_read+0xa8>
    {
        return 0;
    }
    *data_ptr++ = len;
    28ca:	f7 01       	movw	r30, r14
    28cc:	85 83       	std	Z+5, r24	; 0x05

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    28ce:	88 23       	and	r24, r24
    28d0:	71 f0       	breq	.+28     	; 0x28ee <chb_read+0x40>
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    }
    *data_ptr++ = len;
    28d2:	e7 01       	movw	r28, r14
    28d4:	26 96       	adiw	r28, 0x06	; 6
 
    The read function will automatically populate the addresses and the data with
    the frm payload. It will then return the len of the payload.
*/
/**************************************************************************/
U8 chb_read(chb_rx_data_t *rx)
    28d6:	87 01       	movw	r16, r14
    28d8:	09 5f       	subi	r16, 0xF9	; 249
    28da:	1f 4f       	sbci	r17, 0xFF	; 255
    28dc:	81 50       	subi	r24, 0x01	; 1
    28de:	08 0f       	add	r16, r24
    28e0:	11 1d       	adc	r17, r1
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    {
        *data_ptr++ = chb_buf_read();
    28e2:	0e 94 d2 14 	call	0x29a4	; 0x29a4 <chb_buf_read>
    28e6:	89 93       	st	Y+, r24
        return 0;
    }
    *data_ptr++ = len;

    // load the rest of the data into buffer
    for (i=0; i<len; i++)
    28e8:	c0 17       	cp	r28, r16
    28ea:	d1 07       	cpc	r29, r17
    28ec:	d1 f7       	brne	.-12     	; 0x28e2 <chb_read+0x34>
    // we'll use it as temp storage to parse the frame. then move the frame
    // down so that only the payload will be in the buffer.

    // extract the sequence number
    data_ptr = rx->data + 3;    // location of sequence number
    seq = *data_ptr;
    28ee:	f7 01       	movw	r30, r14
    28f0:	c0 85       	ldd	r28, Z+8	; 0x08

    // parse the buffer and extract the dest and src addresses
    data_ptr = rx->data + 6;                // location of dest addr
    rx->dest_addr = *(U16 *)data_ptr;
    28f2:	83 85       	ldd	r24, Z+11	; 0x0b
    28f4:	94 85       	ldd	r25, Z+12	; 0x0c
    28f6:	83 83       	std	Z+3, r24	; 0x03
    28f8:	94 83       	std	Z+4, r25	; 0x04
    data_ptr += sizeof(U16);
    rx->src_addr = *(U16 *)data_ptr;
    28fa:	85 85       	ldd	r24, Z+13	; 0x0d
    28fc:	96 85       	ldd	r25, Z+14	; 0x0e
    28fe:	81 83       	std	Z+1, r24	; 0x01
    2900:	92 83       	std	Z+2, r25	; 0x02
    data_ptr += sizeof(U16);

    // if the data in the rx buf is 0, then clear the rx_flag. otherwise, keep it raised
    if (!chb_buf_get_len())
    2902:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <chb_buf_get_len>
    2906:	88 23       	and	r24, r24
    2908:	11 f4       	brne	.+4      	; 0x290e <chb_read+0x60>
    {
        pcb.data_rcv = false;
    290a:	10 92 25 21 	sts	0x2125, r1
#else
    // duplicate frame check (dupe check). we want to remove frames that have been already been received since they 
    // are just retries. 
    // note: this dupe check only removes duplicate frames from the previous transfer. if another frame from a different
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    290e:	80 91 0f 20 	lds	r24, 0x200F
    2912:	c8 17       	cp	r28, r24
    2914:	51 f4       	brne	.+20     	; 0x292a <chb_read+0x7c>
    2916:	f7 01       	movw	r30, r14
    2918:	21 81       	ldd	r18, Z+1	; 0x01
    291a:	32 81       	ldd	r19, Z+2	; 0x02
    291c:	80 91 10 20 	lds	r24, 0x2010
    2920:	90 91 11 20 	lds	r25, 0x2011
    2924:	28 17       	cp	r18, r24
    2926:	39 07       	cpc	r19, r25
    2928:	c1 f0       	breq	.+48     	; 0x295a <chb_read+0xac>
        // it properly. discard.
        return 0;
    }
    else
    {
        prev_seq = seq;
    292a:	c0 93 0f 20 	sts	0x200F, r28
        prev_src_addr = rx->src_addr;
    292e:	f7 01       	movw	r30, r14
    2930:	81 81       	ldd	r24, Z+1	; 0x01
    2932:	92 81       	ldd	r25, Z+2	; 0x02
    2934:	80 93 10 20 	sts	0x2010, r24
    2938:	90 93 11 20 	sts	0x2011, r25
    }

    // move the payload down to the beginning of the data buffer
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    293c:	b7 01       	movw	r22, r14
    293e:	61 5f       	subi	r22, 0xF1	; 241
    2940:	7f 4f       	sbci	r23, 0xFF	; 255
    2942:	4d 2d       	mov	r20, r13
    2944:	50 e0       	ldi	r21, 0x00	; 0
    2946:	49 50       	subi	r20, 0x09	; 9
    2948:	50 40       	sbci	r21, 0x00	; 0
    294a:	c7 01       	movw	r24, r14
    294c:	0e 94 d5 35 	call	0x6baa	; 0x6baa <memmove>
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
    2950:	8d 2d       	mov	r24, r13
    2952:	8b 50       	subi	r24, 0x0B	; 11
    2954:	03 c0       	rjmp	.+6      	; 0x295c <chb_read+0xae>

    // first byte is always len. check it to make sure 
    // we have a valid len byte.
    if ((len = chb_buf_read()) > CHB_MAX_FRAME_LENGTH)
    {
        return 0;
    2956:	80 e0       	ldi	r24, 0x00	; 0
    2958:	01 c0       	rjmp	.+2      	; 0x295c <chb_read+0xae>
    // node comes in between the dupes, then the dupe will show up as a received frame.
    if ((seq == prev_seq) && (rx->src_addr == prev_src_addr))
    {
        // this is a duplicate frame from a retry. the remote node thinks we didn't receive 
        // it properly. discard.
        return 0;
    295a:	80 e0       	ldi	r24, 0x00	; 0
    //memmove(rx->data, data_ptr, len - CHB_HDR_SZ);
	memmove(rx, data_ptr, len - CHB_HDR_SZ);
    // finally, return the len of the payload
    return len - CHB_HDR_SZ - CHB_FCS_LEN;
#endif
}
    295c:	df 91       	pop	r29
    295e:	cf 91       	pop	r28
    2960:	1f 91       	pop	r17
    2962:	0f 91       	pop	r16
    2964:	ff 90       	pop	r15
    2966:	ef 90       	pop	r14
    2968:	df 90       	pop	r13
    296a:	08 95       	ret

0000296c <chb_buf_init>:

*/
/**************************************************************************/
void chb_buf_init()
{
    rd_ptr = 0;
    296c:	10 92 36 21 	sts	0x2136, r1
    wr_ptr = 0;
    2970:	10 92 37 21 	sts	0x2137, r1
    len = 0;
    2974:	10 92 38 21 	sts	0x2138, r1
}
    2978:	08 95       	ret

0000297a <chb_buf_write>:

*/
/**************************************************************************/
void chb_buf_write(U8 data)
{
    chb_buf[wr_ptr] = data;
    297a:	20 91 37 21 	lds	r18, 0x2137
    297e:	30 e0       	ldi	r19, 0x00	; 0
    2980:	f9 01       	movw	r30, r18
    2982:	e7 5c       	subi	r30, 0xC7	; 199
    2984:	fe 4d       	sbci	r31, 0xDE	; 222
    2986:	80 83       	st	Z, r24
    wr_ptr = (wr_ptr + 1) % CHB_BUF_SZ;
    2988:	c9 01       	movw	r24, r18
    298a:	01 96       	adiw	r24, 0x01	; 1
    298c:	60 e8       	ldi	r22, 0x80	; 128
    298e:	70 e0       	ldi	r23, 0x00	; 0
    2990:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <__divmodhi4>
    2994:	80 93 37 21 	sts	0x2137, r24
    len++;
    2998:	80 91 38 21 	lds	r24, 0x2138
    299c:	8f 5f       	subi	r24, 0xFF	; 255
    299e:	80 93 38 21 	sts	0x2138, r24
}
    29a2:	08 95       	ret

000029a4 <chb_buf_read>:
/**************************************************************************/
U8 chb_buf_read()
{
    U8 data;

    data = chb_buf[rd_ptr];
    29a4:	20 91 36 21 	lds	r18, 0x2136
    29a8:	30 e0       	ldi	r19, 0x00	; 0
    29aa:	f9 01       	movw	r30, r18
    29ac:	e7 5c       	subi	r30, 0xC7	; 199
    29ae:	fe 4d       	sbci	r31, 0xDE	; 222
    29b0:	40 81       	ld	r20, Z
    rd_ptr = (rd_ptr + 1) % CHB_BUF_SZ;
    29b2:	2f 5f       	subi	r18, 0xFF	; 255
    29b4:	3f 4f       	sbci	r19, 0xFF	; 255
    29b6:	c9 01       	movw	r24, r18
    29b8:	60 e8       	ldi	r22, 0x80	; 128
    29ba:	70 e0       	ldi	r23, 0x00	; 0
    29bc:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <__divmodhi4>
    29c0:	80 93 36 21 	sts	0x2136, r24
    len--;
    29c4:	80 91 38 21 	lds	r24, 0x2138
    29c8:	81 50       	subi	r24, 0x01	; 1
    29ca:	80 93 38 21 	sts	0x2138, r24
    return data;
}
    29ce:	84 2f       	mov	r24, r20
    29d0:	08 95       	ret

000029d2 <chb_buf_get_len>:
*/
/**************************************************************************/
U8 chb_buf_get_len()
{
    return len;
}
    29d2:	80 91 38 21 	lds	r24, 0x2138
    29d6:	08 95       	ret

000029d8 <chb_get_ieee_addr>:
/*!

*/
/**************************************************************************/
void chb_get_ieee_addr(U8 *addr)
{
    29d8:	bc 01       	movw	r22, r24
    chb_eeprom_read(CHB_EEPROM_IEEE_ADDR, addr, 8);
    29da:	80 e0       	ldi	r24, 0x00	; 0
    29dc:	90 e0       	ldi	r25, 0x00	; 0
    29de:	48 e0       	ldi	r20, 0x08	; 8
    29e0:	50 e0       	ldi	r21, 0x00	; 0
    29e2:	0e 94 70 19 	call	0x32e0	; 0x32e0 <chb_eeprom_read>
}
    29e6:	08 95       	ret

000029e8 <chb_get_short_addr>:
/*!

*/
/**************************************************************************/
U16 chb_get_short_addr()
{
    29e8:	cf 93       	push	r28
    29ea:	df 93       	push	r29
    29ec:	0f 92       	push	r0
    29ee:	0f 92       	push	r0
    29f0:	cd b7       	in	r28, 0x3d	; 61
    29f2:	de b7       	in	r29, 0x3e	; 62
    U8 addr[2];

    chb_eeprom_read(CHB_EEPROM_SHORT_ADDR, addr, 2);
    29f4:	89 e0       	ldi	r24, 0x09	; 9
    29f6:	90 e0       	ldi	r25, 0x00	; 0
    29f8:	be 01       	movw	r22, r28
    29fa:	6f 5f       	subi	r22, 0xFF	; 255
    29fc:	7f 4f       	sbci	r23, 0xFF	; 255
    29fe:	42 e0       	ldi	r20, 0x02	; 2
    2a00:	50 e0       	ldi	r21, 0x00	; 0
    2a02:	0e 94 70 19 	call	0x32e0	; 0x32e0 <chb_eeprom_read>
    return *(U16 *)addr;
}
    2a06:	89 81       	ldd	r24, Y+1	; 0x01
    2a08:	9a 81       	ldd	r25, Y+2	; 0x02
    2a0a:	0f 90       	pop	r0
    2a0c:	0f 90       	pop	r0
    2a0e:	df 91       	pop	r29
    2a10:	cf 91       	pop	r28
    2a12:	08 95       	ret

00002a14 <RadioCS>:
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
}

//select radio SPI on port D with cs
void RadioCS(uint8_t status){
	if (status) PORTD.OUTCLR = PIN4_bm;
    2a14:	88 23       	and	r24, r24
    2a16:	29 f0       	breq	.+10     	; 0x2a22 <RadioCS+0xe>
    2a18:	80 e1       	ldi	r24, 0x10	; 16
    2a1a:	e0 e6       	ldi	r30, 0x60	; 96
    2a1c:	f6 e0       	ldi	r31, 0x06	; 6
    2a1e:	86 83       	std	Z+6, r24	; 0x06
    2a20:	08 95       	ret
	else {
		PORTD.OUTSET = PIN4_bm;
    2a22:	80 e1       	ldi	r24, 0x10	; 16
    2a24:	e0 e6       	ldi	r30, 0x60	; 96
    2a26:	f6 e0       	ldi	r31, 0x06	; 6
    2a28:	85 83       	std	Z+5, r24	; 0x05
    2a2a:	08 95       	ret

00002a2c <chb_frame_write>:
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
{
    2a2c:	df 92       	push	r13
    2a2e:	ef 92       	push	r14
    2a30:	ff 92       	push	r15
    2a32:	0f 93       	push	r16
    2a34:	1f 93       	push	r17
    2a36:	cf 93       	push	r28
    2a38:	df 93       	push	r29
    2a3a:	8c 01       	movw	r16, r24
    2a3c:	c6 2f       	mov	r28, r22
    2a3e:	7a 01       	movw	r14, r20
    2a40:	d2 2e       	mov	r13, r18
    U8 i, dummy;

    // dont allow transmission longer than max frame size
    if ((hdr_len + data_len) > 127)
    2a42:	82 2f       	mov	r24, r18
    2a44:	90 e0       	ldi	r25, 0x00	; 0
    2a46:	86 0f       	add	r24, r22
    2a48:	91 1d       	adc	r25, r1
    2a4a:	80 38       	cpi	r24, 0x80	; 128
    2a4c:	91 05       	cpc	r25, r1
    2a4e:	8c f5       	brge	.+98     	; 0x2ab2 <chb_frame_write+0x86>
    {
        return;
    }

    // initiate spi transaction
    CHB_ENTER_CRIT();
    2a50:	8f b7       	in	r24, 0x3f	; 63
    2a52:	80 93 39 40 	sts	0x4039, r24
    2a56:	f8 94       	cli
    RadioCS(TRUE); 
    2a58:	81 e0       	ldi	r24, 0x01	; 1
    2a5a:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <RadioCS>

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);
    2a5e:	80 e6       	ldi	r24, 0x60	; 96
    2a60:	0e 94 bb 19 	call	0x3376	; 0x3376 <SPID_write>

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    2a64:	cc 23       	and	r28, r28
    2a66:	79 f0       	breq	.+30     	; 0x2a86 <chb_frame_write+0x5a>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    2a68:	c8 01       	movw	r24, r16
    2a6a:	01 96       	adiw	r24, 0x01	; 1
    2a6c:	c1 50       	subi	r28, 0x01	; 1
    2a6e:	9c 01       	movw	r18, r24
    2a70:	2c 0f       	add	r18, r28
    2a72:	31 1d       	adc	r19, r1
    2a74:	e9 01       	movw	r28, r18
    dummy = SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    {
        dummy = SPID_write(*hdr++);
    2a76:	f8 01       	movw	r30, r16
    2a78:	81 91       	ld	r24, Z+
    2a7a:	8f 01       	movw	r16, r30
    2a7c:	0e 94 bb 19 	call	0x3376	; 0x3376 <SPID_write>

    // send fifo write command
    dummy = SPID_write(CHB_SPI_CMD_FW);

    // write hdr contents to fifo
    for (i=0; i<hdr_len; i++)
    2a80:	0c 17       	cp	r16, r28
    2a82:	1d 07       	cpc	r17, r29
    2a84:	c1 f7       	brne	.-16     	; 0x2a76 <chb_frame_write+0x4a>
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    2a86:	dd 20       	and	r13, r13
    2a88:	69 f0       	breq	.+26     	; 0x2aa4 <chb_frame_write+0x78>
/**************************************************************************/
/*!

*/
/**************************************************************************/
void chb_frame_write(U8 *hdr, U8 hdr_len, U8 *data, U8 data_len)
    2a8a:	e7 01       	movw	r28, r14
    2a8c:	21 96       	adiw	r28, 0x01	; 1
    2a8e:	da 94       	dec	r13
    2a90:	cd 0d       	add	r28, r13
    2a92:	d1 1d       	adc	r29, r1
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    {
        dummy = SPID_write(*data++);
    2a94:	f7 01       	movw	r30, r14
    2a96:	81 91       	ld	r24, Z+
    2a98:	7f 01       	movw	r14, r30
    2a9a:	0e 94 bb 19 	call	0x3376	; 0x3376 <SPID_write>
    {
        dummy = SPID_write(*hdr++);
    }

    // write data contents to fifo
    for (i=0; i<data_len; i++)
    2a9e:	ec 16       	cp	r14, r28
    2aa0:	fd 06       	cpc	r15, r29
    2aa2:	c1 f7       	brne	.-16     	; 0x2a94 <chb_frame_write+0x68>
    {
        dummy = SPID_write(*data++);
    }

    // terminate spi transaction
    RadioCS(FALSE); 
    2aa4:	80 e0       	ldi	r24, 0x00	; 0
    2aa6:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <RadioCS>
    CHB_LEAVE_CRIT();
    2aaa:	80 91 39 40 	lds	r24, 0x4039
    2aae:	8f bf       	out	0x3f, r24	; 63
    2ab0:	78 94       	sei
}
    2ab2:	df 91       	pop	r29
    2ab4:	cf 91       	pop	r28
    2ab6:	1f 91       	pop	r17
    2ab8:	0f 91       	pop	r16
    2aba:	ff 90       	pop	r15
    2abc:	ef 90       	pop	r14
    2abe:	df 90       	pop	r13
    2ac0:	08 95       	ret

00002ac2 <chb_reg_write>:
/*!

*/
/**************************************************************************/
void chb_reg_write(U8 addr, U8 val)
{
    2ac2:	cf 93       	push	r28
    2ac4:	df 93       	push	r29
    2ac6:	d8 2f       	mov	r29, r24
    2ac8:	c6 2f       	mov	r28, r22
    U8 dummy; 

    /* Add the Register Write command to the address. */
    addr |= 0xC0;

    CHB_ENTER_CRIT();
    2aca:	8f b7       	in	r24, 0x3f	; 63
    2acc:	80 93 39 40 	sts	0x4039, r24
    2ad0:	f8 94       	cli
    RadioCS(TRUE);
    2ad2:	81 e0       	ldi	r24, 0x01	; 1
    2ad4:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <RadioCS>

    /*Send Register address and write register content.*/
    dummy = SPID_write(addr);
    2ad8:	8d 2f       	mov	r24, r29
    2ada:	80 6c       	ori	r24, 0xC0	; 192
    2adc:	0e 94 bb 19 	call	0x3376	; 0x3376 <SPID_write>
    dummy = SPID_write(val);
    2ae0:	8c 2f       	mov	r24, r28
    2ae2:	0e 94 bb 19 	call	0x3376	; 0x3376 <SPID_write>

    RadioCS(FALSE);
    2ae6:	80 e0       	ldi	r24, 0x00	; 0
    2ae8:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <RadioCS>
    CHB_LEAVE_CRIT();
    2aec:	80 91 39 40 	lds	r24, 0x4039
    2af0:	8f bf       	out	0x3f, r24	; 63
    2af2:	78 94       	sei
}
    2af4:	df 91       	pop	r29
    2af6:	cf 91       	pop	r28
    2af8:	08 95       	ret

00002afa <chb_set_pwr>:
/*!
    Set the power level
*/
/**************************************************************************/
void chb_set_pwr(U8 val)
{
    2afa:	68 2f       	mov	r22, r24
    chb_reg_write(PHY_TX_PWR, val);
    2afc:	85 e0       	ldi	r24, 0x05	; 5
    2afe:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <chb_reg_write>
}
    2b02:	08 95       	ret

00002b04 <chb_reg_write64>:
/*!

*/
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    2b04:	0f 93       	push	r16
    2b06:	1f 93       	push	r17
    2b08:	cf 93       	push	r28
    2b0a:	df 93       	push	r29
    2b0c:	08 2f       	mov	r16, r24
    U8 i;

    for (i=0; i<8; i++)
    2b0e:	c6 2f       	mov	r28, r22
    2b10:	d7 2f       	mov	r29, r23
    2b12:	10 e0       	ldi	r17, 0x00	; 0
    {
        chb_reg_write(addr + i, *(val + i));
    2b14:	69 91       	ld	r22, Y+
    2b16:	81 2f       	mov	r24, r17
    2b18:	80 0f       	add	r24, r16
    2b1a:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <chb_reg_write>
/**************************************************************************/
void chb_reg_write64(U8 addr, U8 *val)
{
    U8 i;

    for (i=0; i<8; i++)
    2b1e:	1f 5f       	subi	r17, 0xFF	; 255
    2b20:	18 30       	cpi	r17, 0x08	; 8
    2b22:	c1 f7       	brne	.-16     	; 0x2b14 <chb_reg_write64+0x10>
    {
        chb_reg_write(addr + i, *(val + i));
    }
}
    2b24:	df 91       	pop	r29
    2b26:	cf 91       	pop	r28
    2b28:	1f 91       	pop	r17
    2b2a:	0f 91       	pop	r16
    2b2c:	08 95       	ret

00002b2e <chb_set_ieee_addr>:
/*! 
 
*/
/**************************************************************************/
void chb_set_ieee_addr(U8 *addr)
{
    2b2e:	cf 93       	push	r28
    2b30:	df 93       	push	r29
    2b32:	ec 01       	movw	r28, r24
    chb_eeprom_write(CHB_EEPROM_IEEE_ADDR, addr, 8); 
    2b34:	80 e0       	ldi	r24, 0x00	; 0
    2b36:	90 e0       	ldi	r25, 0x00	; 0
    2b38:	be 01       	movw	r22, r28
    2b3a:	48 e0       	ldi	r20, 0x08	; 8
    2b3c:	50 e0       	ldi	r21, 0x00	; 0
    2b3e:	0e 94 0d 19 	call	0x321a	; 0x321a <chb_eeprom_write>
    chb_reg_write64(IEEE_ADDR_0, addr); 
    2b42:	84 e2       	ldi	r24, 0x24	; 36
    2b44:	be 01       	movw	r22, r28
    2b46:	0e 94 82 15 	call	0x2b04	; 0x2b04 <chb_reg_write64>
}
    2b4a:	df 91       	pop	r29
    2b4c:	cf 91       	pop	r28
    2b4e:	08 95       	ret

00002b50 <chb_reg_write16>:
/*!

*/
/**************************************************************************/
void chb_reg_write16(U8 addr, U16 val)
{
    2b50:	cf 93       	push	r28
    2b52:	df 93       	push	r29
    2b54:	c8 2f       	mov	r28, r24
    2b56:	d7 2f       	mov	r29, r23
    U8 i;

    for (i=0; i<2; i++)
    {
        chb_reg_write(addr + i, val >> (8 * i));
    2b58:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <chb_reg_write>
    2b5c:	8c 2f       	mov	r24, r28
    2b5e:	8f 5f       	subi	r24, 0xFF	; 255
    2b60:	6d 2f       	mov	r22, r29
    2b62:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <chb_reg_write>
    }
}
    2b66:	df 91       	pop	r29
    2b68:	cf 91       	pop	r28
    2b6a:	08 95       	ret

00002b6c <chb_set_short_addr>:
/*!

*/
/**************************************************************************/
void chb_set_short_addr(U16 addr)
{
    2b6c:	0f 93       	push	r16
    2b6e:	1f 93       	push	r17
    2b70:	cf 93       	push	r28
    2b72:	df 93       	push	r29
    2b74:	0f 92       	push	r0
    2b76:	0f 92       	push	r0
    2b78:	cd b7       	in	r28, 0x3d	; 61
    2b7a:	de b7       	in	r29, 0x3e	; 62
    2b7c:	89 83       	std	Y+1, r24	; 0x01
    2b7e:	9a 83       	std	Y+2, r25	; 0x02
    U8 *addr_ptr = (U8 *)&addr;
    pcb_t *pcb = chb_get_pcb();
    2b80:	0e 94 94 13 	call	0x2728	; 0x2728 <chb_get_pcb>
    2b84:	8c 01       	movw	r16, r24

    chb_eeprom_write(CHB_EEPROM_SHORT_ADDR, addr_ptr, 2);
    2b86:	89 e0       	ldi	r24, 0x09	; 9
    2b88:	90 e0       	ldi	r25, 0x00	; 0
    2b8a:	be 01       	movw	r22, r28
    2b8c:	6f 5f       	subi	r22, 0xFF	; 255
    2b8e:	7f 4f       	sbci	r23, 0xFF	; 255
    2b90:	42 e0       	ldi	r20, 0x02	; 2
    2b92:	50 e0       	ldi	r21, 0x00	; 0
    2b94:	0e 94 0d 19 	call	0x321a	; 0x321a <chb_eeprom_write>
    chb_reg_write16(SHORT_ADDR_0, addr);
    2b98:	69 81       	ldd	r22, Y+1	; 0x01
    2b9a:	7a 81       	ldd	r23, Y+2	; 0x02
    2b9c:	80 e2       	ldi	r24, 0x20	; 32
    2b9e:	0e 94 a8 15 	call	0x2b50	; 0x2b50 <chb_reg_write16>
    pcb->src_addr = addr;
    2ba2:	89 81       	ldd	r24, Y+1	; 0x01
    2ba4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ba6:	f8 01       	movw	r30, r16
    2ba8:	80 83       	st	Z, r24
    2baa:	91 83       	std	Z+1, r25	; 0x01
}
    2bac:	0f 90       	pop	r0
    2bae:	0f 90       	pop	r0
    2bb0:	df 91       	pop	r29
    2bb2:	cf 91       	pop	r28
    2bb4:	1f 91       	pop	r17
    2bb6:	0f 91       	pop	r16
    2bb8:	08 95       	ret

00002bba <chb_reg_read>:
/*!

*/
/**************************************************************************/
U8 chb_reg_read(U8 addr)
{
    2bba:	cf 93       	push	r28
    2bbc:	c8 2f       	mov	r28, r24
    U8 val = 0;

    /* Add the register read command to the register address. */
    addr |= 0x80;

    CHB_ENTER_CRIT();
    2bbe:	8f b7       	in	r24, 0x3f	; 63
    2bc0:	80 93 39 40 	sts	0x4039, r24
    2bc4:	f8 94       	cli
    RadioCS(TRUE);
    2bc6:	81 e0       	ldi	r24, 0x01	; 1
    2bc8:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <RadioCS>

    /*Send Register address and read register content.*/
    val = SPID_write(addr);
    2bcc:	8c 2f       	mov	r24, r28
    2bce:	80 68       	ori	r24, 0x80	; 128
    2bd0:	0e 94 bb 19 	call	0x3376	; 0x3376 <SPID_write>
    val = SPID_write(val);
    2bd4:	0e 94 bb 19 	call	0x3376	; 0x3376 <SPID_write>
    2bd8:	c8 2f       	mov	r28, r24

    RadioCS(FALSE);
    2bda:	80 e0       	ldi	r24, 0x00	; 0
    2bdc:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <RadioCS>
    CHB_LEAVE_CRIT();
    2be0:	80 91 39 40 	lds	r24, 0x4039
    2be4:	8f bf       	out	0x3f, r24	; 63
    2be6:	78 94       	sei

    return val;
}
    2be8:	8c 2f       	mov	r24, r28
    2bea:	cf 91       	pop	r28
    2bec:	08 95       	ret

00002bee <chb_get_state>:

*/
/**************************************************************************/
static U8 chb_get_state()
{
    return chb_reg_read(TRX_STATUS) & 0x1f;
    2bee:	81 e0       	ldi	r24, 0x01	; 1
    2bf0:	0e 94 dd 15 	call	0x2bba	; 0x2bba <chb_reg_read>
}
    2bf4:	8f 71       	andi	r24, 0x1F	; 31
    2bf6:	08 95       	ret

00002bf8 <chb_reg_read_mod_write>:
/*!

*/
/**************************************************************************/
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    2bf8:	1f 93       	push	r17
    2bfa:	cf 93       	push	r28
    2bfc:	df 93       	push	r29
    2bfe:	c8 2f       	mov	r28, r24
    2c00:	16 2f       	mov	r17, r22
    2c02:	d4 2f       	mov	r29, r20
    U8 tmp;

    tmp = chb_reg_read(addr);
    2c04:	0e 94 dd 15 	call	0x2bba	; 0x2bba <chb_reg_read>
    val &= mask;                // mask off stray bits from val
    tmp &= ~mask;               // mask off bits in reg val
    2c08:	6d 2f       	mov	r22, r29
    2c0a:	60 95       	com	r22
    2c0c:	68 23       	and	r22, r24
void chb_reg_read_mod_write(U8 addr, U8 val, U8 mask)
{
    U8 tmp;

    tmp = chb_reg_read(addr);
    val &= mask;                // mask off stray bits from val
    2c0e:	d1 23       	and	r29, r17
    tmp &= ~mask;               // mask off bits in reg val
    tmp |= val;                 // copy val into reg val
    2c10:	6d 2b       	or	r22, r29
    chb_reg_write(addr, tmp);   // write back to reg
    2c12:	8c 2f       	mov	r24, r28
    2c14:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <chb_reg_write>
}
    2c18:	df 91       	pop	r29
    2c1a:	cf 91       	pop	r28
    2c1c:	1f 91       	pop	r17
    2c1e:	08 95       	ret

00002c20 <chb_set_state>:
    for certain operations. Check the datasheet for more details on the state 
    machine and manipulations.
*/
/**************************************************************************/
U8 chb_set_state(U8 state)
{
    2c20:	cf 93       	push	r28
    2c22:	df 93       	push	r29
    2c24:	d8 2f       	mov	r29, r24
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    2c26:	80 91 64 06 	lds	r24, 0x0664
    2c2a:	81 fd       	sbrc	r24, 1
    2c2c:	40 c0       	rjmp	.+128    	; 0x2cae <chb_set_state+0x8e>
    {
        return RADIO_WRONG_STATE;
    }

    // if we're in a transition state, wait for the state to become stable
    curr_state = chb_get_state();
    2c2e:	0e 94 f7 15 	call	0x2bee	; 0x2bee <chb_get_state>
    2c32:	c8 2f       	mov	r28, r24
    if ((curr_state == CHB_BUSY_TX_ARET) || (curr_state == CHB_BUSY_RX_AACK) || (curr_state == CHB_BUSY_RX) || (curr_state == CHB_BUSY_TX))
    2c34:	81 51       	subi	r24, 0x11	; 17
    2c36:	82 30       	cpi	r24, 0x02	; 2
    2c38:	20 f0       	brcs	.+8      	; 0x2c42 <chb_set_state+0x22>
    2c3a:	c1 30       	cpi	r28, 0x01	; 1
    2c3c:	11 f0       	breq	.+4      	; 0x2c42 <chb_set_state+0x22>
    2c3e:	c2 30       	cpi	r28, 0x02	; 2
    2c40:	21 f4       	brne	.+8      	; 0x2c4a <chb_set_state+0x2a>
    {
        while (chb_get_state() == curr_state);
    2c42:	0e 94 f7 15 	call	0x2bee	; 0x2bee <chb_get_state>
    2c46:	8c 17       	cp	r24, r28
    2c48:	e1 f3       	breq	.-8      	; 0x2c42 <chb_set_state+0x22>
    }

    // At this point it is clear that the requested new_state is:
    // TRX_OFF, RX_ON, PLL_ON, RX_AACK_ON or TX_ARET_ON.
    // we need to handle some special cases before we transition to the new state
    switch (state)
    2c4a:	d6 31       	cpi	r29, 0x16	; 22
    2c4c:	c9 f0       	breq	.+50     	; 0x2c80 <chb_set_state+0x60>
    2c4e:	d9 31       	cpi	r29, 0x19	; 25
    2c50:	71 f0       	breq	.+28     	; 0x2c6e <chb_set_state+0x4e>
    2c52:	d8 30       	cpi	r29, 0x08	; 8
    2c54:	e9 f4       	brne	.+58     	; 0x2c90 <chb_set_state+0x70>
    {
    case CHB_TRX_OFF:
        /* Go to TRX_OFF from any state. */
        CHB_SLPTR_DISABLE();
    2c56:	e4 e6       	ldi	r30, 0x64	; 100
    2c58:	f6 e0       	ldi	r31, 0x06	; 6
    2c5a:	80 81       	ld	r24, Z
    2c5c:	8d 7f       	andi	r24, 0xFD	; 253
    2c5e:	80 83       	st	Z, r24
        chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1f);
    2c60:	82 e0       	ldi	r24, 0x02	; 2
    2c62:	63 e0       	ldi	r22, 0x03	; 3
    2c64:	4f e1       	ldi	r20, 0x1F	; 31
    2c66:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>
    2c6a:	00 00       	nop
    2c6c:	11 c0       	rjmp	.+34     	; 0x2c90 <chb_set_state+0x70>
        _delay_us(TIME_ALL_STATES_TRX_OFF);
        break;

    case CHB_TX_ARET_ON:
        if (curr_state == CHB_RX_AACK_ON)
    2c6e:	c6 31       	cpi	r28, 0x16	; 22
    2c70:	79 f4       	brne	.+30     	; 0x2c90 <chb_set_state+0x70>
        {
            /* First do intermediate state transition to PLL_ON, then to TX_ARET_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    2c72:	82 e0       	ldi	r24, 0x02	; 2
    2c74:	69 e0       	ldi	r22, 0x09	; 9
    2c76:	4f e1       	ldi	r20, 0x1F	; 31
    2c78:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>
    2c7c:	00 00       	nop
    2c7e:	08 c0       	rjmp	.+16     	; 0x2c90 <chb_set_state+0x70>
            _delay_us(TIME_RX_ON_PLL_ON);
        }
        break;

    case CHB_RX_AACK_ON:
        if (curr_state == CHB_TX_ARET_ON)
    2c80:	c9 31       	cpi	r28, 0x19	; 25
    2c82:	31 f4       	brne	.+12     	; 0x2c90 <chb_set_state+0x70>
        {
            /* First do intermediate state transition to RX_ON, then to RX_AACK_ON. */
            chb_reg_read_mod_write(TRX_STATE, CMD_PLL_ON, 0x1f);
    2c84:	82 e0       	ldi	r24, 0x02	; 2
    2c86:	69 e0       	ldi	r22, 0x09	; 9
    2c88:	4f e1       	ldi	r20, 0x1F	; 31
    2c8a:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>
    2c8e:	00 00       	nop
        }
        break;
    }

    /* Now we're okay to transition to any new state. */
    chb_reg_read_mod_write(TRX_STATE, state, 0x1f);
    2c90:	82 e0       	ldi	r24, 0x02	; 2
    2c92:	6d 2f       	mov	r22, r29
    2c94:	4f e1       	ldi	r20, 0x1F	; 31
    2c96:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>
    2c9a:	84 e2       	ldi	r24, 0x24	; 36
    2c9c:	8a 95       	dec	r24
    2c9e:	f1 f7       	brne	.-4      	; 0x2c9c <chb_set_state+0x7c>
    2ca0:	00 c0       	rjmp	.+0      	; 0x2ca2 <chb_set_state+0x82>

    /* When the PLL is active most states can be reached in 1us. However, from */
    /* TRX_OFF the PLL needs time to activate. */
    _delay_us(TIME_TRX_OFF_PLL_ON);

    if (chb_get_state() == state)
    2ca2:	0e 94 f7 15 	call	0x2bee	; 0x2bee <chb_get_state>
    2ca6:	8d 17       	cp	r24, r29
    2ca8:	21 f4       	brne	.+8      	; 0x2cb2 <chb_set_state+0x92>
    {
        return RADIO_SUCCESS;
    2caa:	80 e4       	ldi	r24, 0x40	; 64
    2cac:	03 c0       	rjmp	.+6      	; 0x2cb4 <chb_set_state+0x94>
    U8 curr_state;

    // if we're sleeping then don't allow transition
    if (CHB_SLPTR_PORT & _BV(CHB_SLPTR_PIN))
    {
        return RADIO_WRONG_STATE;
    2cae:	84 e4       	ldi	r24, 0x44	; 68
    2cb0:	01 c0       	rjmp	.+2      	; 0x2cb4 <chb_set_state+0x94>

    if (chb_get_state() == state)
    {
        return RADIO_SUCCESS;
    }
    return RADIO_TIMED_OUT;
    2cb2:	83 e4       	ldi	r24, 0x43	; 67
}
    2cb4:	df 91       	pop	r29
    2cb6:	cf 91       	pop	r28
    2cb8:	08 95       	ret

00002cba <chb_sleep>:
    Enable or disable the radio's sleep mode.
*/
/**************************************************************************/
void chb_sleep(U8 enb)
{
    if (enb)
    2cba:	88 23       	and	r24, r24
    2cbc:	49 f0       	breq	.+18     	; 0x2cd0 <chb_sleep+0x16>
    {
        // first we need to go to TRX OFF state
        chb_set_state(CHB_TRX_OFF);
    2cbe:	88 e0       	ldi	r24, 0x08	; 8
    2cc0:	0e 94 10 16 	call	0x2c20	; 0x2c20 <chb_set_state>

        // set the SLPTR pin
        CHB_SLPTR_PORT |= _BV(CHB_SLPTR_PIN);
    2cc4:	e4 e6       	ldi	r30, 0x64	; 100
    2cc6:	f6 e0       	ldi	r31, 0x06	; 6
    2cc8:	80 81       	ld	r24, Z
    2cca:	82 60       	ori	r24, 0x02	; 2
    2ccc:	80 83       	st	Z, r24
    2cce:	08 95       	ret
    }
    else
    {
        // make sure the SLPTR pin is low first
        CHB_SLPTR_PORT &= ~(_BV(CHB_SLPTR_PIN));
    2cd0:	e4 e6       	ldi	r30, 0x64	; 100
    2cd2:	f6 e0       	ldi	r31, 0x06	; 6
    2cd4:	80 81       	ld	r24, Z
    2cd6:	8d 7f       	andi	r24, 0xFD	; 253
    2cd8:	80 83       	st	Z, r24
    2cda:	80 e5       	ldi	r24, 0x50	; 80
    2cdc:	8a 95       	dec	r24
    2cde:	f1 f7       	brne	.-4      	; 0x2cdc <chb_sleep+0x22>

        // we need to allow some time for the PLL to lock
        _delay_us(TIME_SLEEP_TO_TRX_OFF);

        // Turn the transceiver back on
        chb_set_state(RX_STATE);
    2ce0:	86 e1       	ldi	r24, 0x16	; 22
    2ce2:	0e 94 10 16 	call	0x2c20	; 0x2c20 <chb_set_state>
    2ce6:	08 95       	ret

00002ce8 <chb_tx>:
    Load the data into the fifo, initiate a transmission attempt,
    and return the status of the transmission attempt.
*/
/**************************************************************************/
U8 chb_tx(U8 *hdr, U8 *data, U8 len)
{
    2ce8:	cf 92       	push	r12
    2cea:	df 92       	push	r13
    2cec:	ef 92       	push	r14
    2cee:	ff 92       	push	r15
    2cf0:	0f 93       	push	r16
    2cf2:	1f 93       	push	r17
    2cf4:	cf 93       	push	r28
    2cf6:	df 93       	push	r29
    2cf8:	7c 01       	movw	r14, r24
    2cfa:	6b 01       	movw	r12, r22
    2cfc:	04 2f       	mov	r16, r20
    U8 state = chb_get_state();
    2cfe:	0e 94 f7 15 	call	0x2bee	; 0x2bee <chb_get_state>
    2d02:	18 2f       	mov	r17, r24
    pcb_t *pcb = chb_get_pcb();
    2d04:	0e 94 94 13 	call	0x2728	; 0x2728 <chb_get_pcb>
    2d08:	ec 01       	movw	r28, r24

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    2d0a:	12 30       	cpi	r17, 0x02	; 2
    2d0c:	f1 f0       	breq	.+60     	; 0x2d4a <chb_tx+0x62>
    2d0e:	12 31       	cpi	r17, 0x12	; 18
    2d10:	f1 f0       	breq	.+60     	; 0x2d4e <chb_tx+0x66>
    {
        return RADIO_WRONG_STATE;
    }

    // TODO: check why we need to transition to the off state before we go to tx_aret_on
    chb_set_state(CHB_TRX_OFF);
    2d12:	88 e0       	ldi	r24, 0x08	; 8
    2d14:	0e 94 10 16 	call	0x2c20	; 0x2c20 <chb_set_state>
    chb_set_state(CHB_TX_ARET_ON);
    2d18:	89 e1       	ldi	r24, 0x19	; 25
    2d1a:	0e 94 10 16 	call	0x2c20	; 0x2c20 <chb_set_state>

    // TODO: try and start the frame transmission by writing TX_START command instead of toggling
    // sleep pin...i just feel like it's kind of weird...

    // write frame to buffer. first write header into buffer (add 1 for len byte), then data. 
    chb_frame_write(hdr, CHB_HDR_SZ + 1, data, len);
    2d1e:	c7 01       	movw	r24, r14
    2d20:	6a e0       	ldi	r22, 0x0A	; 10
    2d22:	a6 01       	movw	r20, r12
    2d24:	20 2f       	mov	r18, r16
    2d26:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <chb_frame_write>

    //Do frame transmission. 
    chb_reg_read_mod_write(TRX_STATE, CMD_TX_START, 0x1F);
    2d2a:	82 e0       	ldi	r24, 0x02	; 2
    2d2c:	62 e0       	ldi	r22, 0x02	; 2
    2d2e:	4f e1       	ldi	r20, 0x1F	; 31
    2d30:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>

    // wait for the transmission to end, signalled by the TRX END flag
    while (!pcb->tx_end);
    2d34:	8c 81       	ldd	r24, Y+4	; 0x04
    2d36:	88 23       	and	r24, r24
    2d38:	e9 f3       	breq	.-6      	; 0x2d34 <chb_tx+0x4c>
    pcb->tx_end = false;
    2d3a:	1c 82       	std	Y+4, r1	; 0x04

*/
/**************************************************************************/
static U8 chb_get_status()
{
    return chb_reg_read(TRX_STATE) >> CHB_TRAC_STATUS_POS;
    2d3c:	82 e0       	ldi	r24, 0x02	; 2
    2d3e:	0e 94 dd 15 	call	0x2bba	; 0x2bba <chb_reg_read>
    2d42:	82 95       	swap	r24
    2d44:	86 95       	lsr	r24
    2d46:	87 70       	andi	r24, 0x07	; 7
    // wait for the transmission to end, signalled by the TRX END flag
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
    2d48:	03 c0       	rjmp	.+6      	; 0x2d50 <chb_tx+0x68>
    U8 state = chb_get_state();
    pcb_t *pcb = chb_get_pcb();

    if ((state == CHB_BUSY_TX) || (state == CHB_BUSY_TX_ARET))
    {
        return RADIO_WRONG_STATE;
    2d4a:	84 e4       	ldi	r24, 0x44	; 68
    2d4c:	01 c0       	rjmp	.+2      	; 0x2d50 <chb_tx+0x68>
    2d4e:	84 e4       	ldi	r24, 0x44	; 68
    while (!pcb->tx_end);
    pcb->tx_end = false;

    // check the status of the transmission
    return chb_get_status();
}
    2d50:	df 91       	pop	r29
    2d52:	cf 91       	pop	r28
    2d54:	1f 91       	pop	r17
    2d56:	0f 91       	pop	r16
    2d58:	ff 90       	pop	r15
    2d5a:	ef 90       	pop	r14
    2d5c:	df 90       	pop	r13
    2d5e:	cf 90       	pop	r12
    2d60:	08 95       	ret

00002d62 <chb_set_mode>:
    Set the channel mode, BPSK, OQPSK, etc...
*/
/**************************************************************************/
void chb_set_mode(U8 mode)
{
    switch (mode)
    2d62:	81 30       	cpi	r24, 0x01	; 1
    2d64:	91 f0       	breq	.+36     	; 0x2d8a <chb_set_mode+0x28>
    2d66:	81 30       	cpi	r24, 0x01	; 1
    2d68:	28 f0       	brcs	.+10     	; 0x2d74 <chb_set_mode+0x12>
    2d6a:	82 30       	cpi	r24, 0x02	; 2
    2d6c:	c9 f0       	breq	.+50     	; 0x2da0 <chb_set_mode+0x3e>
    2d6e:	83 30       	cpi	r24, 0x03	; 3
    2d70:	61 f5       	brne	.+88     	; 0x2dca <chb_set_mode+0x68>
    2d72:	21 c0       	rjmp	.+66     	; 0x2db6 <chb_set_mode+0x54>
    {
    case OQPSK_868MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x08, 0x3f);                 // 802.15.4-2006, channel page 2, channel 0 (868 MHz, Europe)
    2d74:	8c e0       	ldi	r24, 0x0C	; 12
    2d76:	68 e0       	ldi	r22, 0x08	; 8
    2d78:	4f e3       	ldi	r20, 0x3F	; 63
    2d7a:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    2d7e:	86 e1       	ldi	r24, 0x16	; 22
    2d80:	62 e0       	ldi	r22, 0x02	; 2
    2d82:	43 e0       	ldi	r20, 0x03	; 3
    2d84:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>
        break;
    2d88:	08 95       	ret
    case OQPSK_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);                 // 802.15.4-2006, channel page 2, channels 1-10 (915 MHz, US)
    2d8a:	8c e0       	ldi	r24, 0x0C	; 12
    2d8c:	6c e0       	ldi	r22, 0x0C	; 12
    2d8e:	4f e3       	ldi	r20, 0x3F	; 63
    2d90:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    2d94:	86 e1       	ldi	r24, 0x16	; 22
    2d96:	62 e0       	ldi	r22, 0x02	; 2
    2d98:	43 e0       	ldi	r20, 0x03	; 3
    2d9a:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>
        break;
    2d9e:	08 95       	ret
    case OQPSK_780MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x1c, 0x3f);                 // 802.15.4-2006, channel page 5, channel 0-3 (780 MHz, China)
    2da0:	8c e0       	ldi	r24, 0x0C	; 12
    2da2:	6c e1       	ldi	r22, 0x1C	; 28
    2da4:	4f e3       	ldi	r20, 0x3F	; 63
    2da6:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_OQPSK_TX_OFFSET, 0x3);    // this is according to table 7-16 in at86rf212 datasheet
    2daa:	86 e1       	ldi	r24, 0x16	; 22
    2dac:	62 e0       	ldi	r22, 0x02	; 2
    2dae:	43 e0       	ldi	r20, 0x03	; 3
    2db0:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>
        break;
    2db4:	08 95       	ret
    case BPSK40_915MHZ:
        chb_reg_read_mod_write(TRX_CTRL_2, 0x00, 0x3f);                 // 802.15.4-2006, BPSK, 40 kbps
    2db6:	8c e0       	ldi	r24, 0x0C	; 12
    2db8:	60 e0       	ldi	r22, 0x00	; 0
    2dba:	4f e3       	ldi	r20, 0x3F	; 63
    2dbc:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>
        chb_reg_read_mod_write(RF_CTRL_0, CHB_BPSK_TX_OFFSET, 0x3);     // this is according to table 7-16 in at86rf212 datasheet
    2dc0:	86 e1       	ldi	r24, 0x16	; 22
    2dc2:	63 e0       	ldi	r22, 0x03	; 3
    2dc4:	43 e0       	ldi	r20, 0x03	; 3
    2dc6:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>
    2dca:	08 95       	ret

00002dcc <chb_set_channel>:
/*!

*/
/**************************************************************************/
U8 chb_set_channel(U8 channel)
{
    2dcc:	cf 93       	push	r28
    2dce:	c8 2f       	mov	r28, r24
    //    {
    //        chb_reg_read_mod_write(TRX_CTRL_2, 0x0c, 0x3f);
    //    }
    //}
        
    chb_reg_read_mod_write(PHY_CC_CCA, channel, 0x1f); 
    2dd0:	88 e0       	ldi	r24, 0x08	; 8
    2dd2:	6c 2f       	mov	r22, r28
    2dd4:	4f e1       	ldi	r20, 0x1F	; 31
    2dd6:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>
#endif

    // add a delay to allow the PLL to lock if in active mode.
    state = chb_get_state();
    2dda:	0e 94 f7 15 	call	0x2bee	; 0x2bee <chb_get_state>
    if ((state == CHB_RX_ON) || (state == CHB_PLL_ON))
    2dde:	86 30       	cpi	r24, 0x06	; 6
    2de0:	11 f0       	breq	.+4      	; 0x2de6 <chb_set_channel+0x1a>
    2de2:	89 30       	cpi	r24, 0x09	; 9
    2de4:	21 f4       	brne	.+8      	; 0x2dee <chb_set_channel+0x22>
    2de6:	84 e2       	ldi	r24, 0x24	; 36
    2de8:	8a 95       	dec	r24
    2dea:	f1 f7       	brne	.-4      	; 0x2de8 <chb_set_channel+0x1c>
    2dec:	00 c0       	rjmp	.+0      	; 0x2dee <chb_set_channel+0x22>
    {
        _delay_us(TIME_PLL_LOCK_TIME);
    }

    return ((chb_reg_read(PHY_CC_CCA) & 0x1f) == channel) ? RADIO_SUCCESS : RADIO_TIMED_OUT;
    2dee:	88 e0       	ldi	r24, 0x08	; 8
    2df0:	0e 94 dd 15 	call	0x2bba	; 0x2bba <chb_reg_read>
    2df4:	90 e0       	ldi	r25, 0x00	; 0
    2df6:	8f 71       	andi	r24, 0x1F	; 31
    2df8:	90 70       	andi	r25, 0x00	; 0
    2dfa:	6c 2f       	mov	r22, r28
    2dfc:	70 e0       	ldi	r23, 0x00	; 0
    2dfe:	86 17       	cp	r24, r22
    2e00:	97 07       	cpc	r25, r23
    2e02:	11 f4       	brne	.+4      	; 0x2e08 <chb_set_channel+0x3c>
    2e04:	80 e4       	ldi	r24, 0x40	; 64
    2e06:	01 c0       	rjmp	.+2      	; 0x2e0a <chb_set_channel+0x3e>
    2e08:	83 e4       	ldi	r24, 0x43	; 67
}
    2e0a:	cf 91       	pop	r28
    2e0c:	08 95       	ret

00002e0e <chb_reg_read16>:
/*! 
 
*/
/**************************************************************************/
U16 chb_reg_read16(U8 addr)
{
    2e0e:	cf 93       	push	r28
    2e10:	c8 2f       	mov	r28, r24
    U8 i;
    U16 val = 0;

    for (i=0; i<2; i++)
    {
        addr |= chb_reg_read(addr + i) << (8 * i);
    2e12:	0e 94 dd 15 	call	0x2bba	; 0x2bba <chb_reg_read>
    2e16:	8c 2b       	or	r24, r28
    2e18:	8f 5f       	subi	r24, 0xFF	; 255
    2e1a:	0e 94 dd 15 	call	0x2bba	; 0x2bba <chb_reg_read>
    }
    return val;
}
    2e1e:	80 e0       	ldi	r24, 0x00	; 0
    2e20:	90 e0       	ldi	r25, 0x00	; 0
    2e22:	cf 91       	pop	r28
    2e24:	08 95       	ret

00002e26 <chb_reset>:

*/
/**************************************************************************/
void chb_reset()
{
    CHB_RST_DISABLE();
    2e26:	e4 e6       	ldi	r30, 0x64	; 100
    2e28:	f6 e0       	ldi	r31, 0x06	; 6
    2e2a:	80 81       	ld	r24, Z
    2e2c:	81 60       	ori	r24, 0x01	; 1
    2e2e:	80 83       	st	Z, r24
    CHB_SLPTR_DISABLE();
    2e30:	80 81       	ld	r24, Z
    2e32:	8d 7f       	andi	r24, 0xFD	; 253
    2e34:	80 83       	st	Z, r24
    2e36:	8e e7       	ldi	r24, 0x7E	; 126
    2e38:	8a 95       	dec	r24
    2e3a:	f1 f7       	brne	.-4      	; 0x2e38 <chb_reset+0x12>
    2e3c:	00 c0       	rjmp	.+0      	; 0x2e3e <chb_reset+0x18>

    // wait a bit while transceiver wakes up
    _delay_us(TIME_P_ON_TO_CLKM_AVAIL);

    // reset the device
    CHB_RST_ENABLE();
    2e3e:	80 81       	ld	r24, Z
    2e40:	8e 7f       	andi	r24, 0xFE	; 254
    2e42:	80 83       	st	Z, r24
    2e44:	00 00       	nop
    _delay_us(TIME_RST_PULSE_WIDTH);
    CHB_RST_DISABLE();
    2e46:	80 81       	ld	r24, Z
    2e48:	81 60       	ori	r24, 0x01	; 1
    2e4a:	80 83       	st	Z, r24
    while (1)
    {
        // if you're stuck in this loop, that means that you're not reading
        // the version and part number register correctly. possible that version number
        // changes. if so, update version num in header file
        if ((chb_reg_read(VERSION_NUM) == CHB_AT86RF212_VER_NUM) && (chb_reg_read(PART_NUM) == CHB_AT86RF212_PART_NUM)) 
    2e4c:	8d e1       	ldi	r24, 0x1D	; 29
    2e4e:	0e 94 dd 15 	call	0x2bba	; 0x2bba <chb_reg_read>
    2e52:	81 30       	cpi	r24, 0x01	; 1
    2e54:	d9 f7       	brne	.-10     	; 0x2e4c <chb_reset+0x26>
    2e56:	8c e1       	ldi	r24, 0x1C	; 28
    2e58:	0e 94 dd 15 	call	0x2bba	; 0x2bba <chb_reg_read>
    2e5c:	87 30       	cpi	r24, 0x07	; 7
    2e5e:	b1 f7       	brne	.-20     	; 0x2e4c <chb_reset+0x26>
            break;
        }
    }
	

}
    2e60:	08 95       	ret

00002e62 <chb_drvr_init>:
/*!

*/
/**************************************************************************/
void chb_drvr_init()
{
    2e62:	0f 93       	push	r16
    2e64:	1f 93       	push	r17
    2e66:	cf 93       	push	r28
    2e68:	df 93       	push	r29
    2e6a:	cd b7       	in	r28, 0x3d	; 61
    2e6c:	de b7       	in	r29, 0x3e	; 62
    2e6e:	ea 97       	sbiw	r28, 0x3a	; 58
    2e70:	cd bf       	out	0x3d, r28	; 61
    2e72:	de bf       	out	0x3e, r29	; 62
    // config SPI for at86rf230 access
    chb_spi_init();
    2e74:	0e 94 a8 19 	call	0x3350	; 0x3350 <chb_spi_init>
	//SPIDInit(SPI_MODE0_bm);
	//RadioCS(FALSE);
    // configure IOs
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    2e78:	e0 e6       	ldi	r30, 0x60	; 96
    2e7a:	f6 e0       	ldi	r31, 0x06	; 6
    2e7c:	80 81       	ld	r24, Z
    2e7e:	82 60       	ori	r24, 0x02	; 2
    2e80:	80 83       	st	Z, r24
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));
    2e82:	80 81       	ld	r24, Z
    2e84:	81 60       	ori	r24, 0x01	; 1
    2e86:	80 83       	st	Z, r24
static void chb_radio_init()
{
    U8 ieee_addr[8];

    // reset chip
    chb_reset();
    2e88:	0e 94 13 17 	call	0x2e26	; 0x2e26 <chb_reset>

    // disable intps while we config the radio
    chb_reg_write(IRQ_MASK, 0);
    2e8c:	8e e0       	ldi	r24, 0x0E	; 14
    2e8e:	60 e0       	ldi	r22, 0x00	; 0
    2e90:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <chb_reg_write>

    // force transceiver off while we configure the intps
    chb_reg_read_mod_write(TRX_STATE, CMD_FORCE_TRX_OFF, 0x1F);
    2e94:	82 e0       	ldi	r24, 0x02	; 2
    2e96:	63 e0       	ldi	r22, 0x03	; 3
    2e98:	4f e1       	ldi	r20, 0x1F	; 31
    2e9a:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>

    // make sure the transceiver is in the off state before proceeding
    while ((chb_reg_read(TRX_STATUS) & 0x1f) != CHB_TRX_OFF);
    2e9e:	81 e0       	ldi	r24, 0x01	; 1
    2ea0:	0e 94 dd 15 	call	0x2bba	; 0x2bba <chb_reg_read>
    2ea4:	8f 71       	andi	r24, 0x1F	; 31
    2ea6:	88 30       	cpi	r24, 0x08	; 8
    2ea8:	d1 f7       	brne	.-12     	; 0x2e9e <chb_drvr_init+0x3c>
    //chb_ret_write(CSMA_SEED0, CHB_CSMA_SEED0);     
    //chb_reg_read_mod_write(PHY_CC_CCA, CHB_CCA_MODE << CHB_CCA_MODE_POS,0x3 << CHB_CCA_MODE_POS);
    //chb_reg_write(CCA_THRES, CHB_CCA_ED_THRES);

    // set frame version that we'll accept
    chb_reg_read_mod_write(CSMA_SEED_1, CHB_FRM_VER << CHB_FVN_POS, 3 << CHB_FVN_POS);
    2eaa:	8e e2       	ldi	r24, 0x2E	; 46
    2eac:	60 e4       	ldi	r22, 0x40	; 64
    2eae:	40 ec       	ldi	r20, 0xC0	; 192
    2eb0:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>

    // set interrupt mask
    // re-enable intps while we config the radio
    chb_reg_write(IRQ_MASK, (1<<IRQ_RX_START) | (1<<IRQ_TRX_END));
    2eb4:	8e e0       	ldi	r24, 0x0E	; 14
    2eb6:	6c e0       	ldi	r22, 0x0C	; 12
    2eb8:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <chb_reg_write>

    #if (CHB_PROMISCUOUS == 0)
    // set autocrc mode
    chb_reg_read_mod_write(TRX_CTRL_1, 1 << CHB_AUTO_CRC_POS, 1 << CHB_AUTO_CRC_POS);
    2ebc:	84 e0       	ldi	r24, 0x04	; 4
    2ebe:	60 e2       	ldi	r22, 0x20	; 32
    2ec0:	40 e2       	ldi	r20, 0x20	; 32
    2ec2:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <chb_reg_read_mod_write>
    #endif

    // set up default phy modulation and data rate - OQPSK, 250 kbps, 915 MHz
    chb_set_mode(CHB_INIT_MODE);
    2ec6:	81 e0       	ldi	r24, 0x01	; 1
    2ec8:	0e 94 b1 16 	call	0x2d62	; 0x2d62 <chb_set_mode>

    chb_set_channel(CHB_CHANNEL);
    2ecc:	81 e0       	ldi	r24, 0x01	; 1
    2ece:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <chb_set_channel>

    // set fsm state
    // put trx in rx auto ack mode
    chb_set_state(RX_STATE);
    2ed2:	86 e1       	ldi	r24, 0x16	; 22
    2ed4:	0e 94 10 16 	call	0x2c20	; 0x2c20 <chb_set_state>

    // set pan ID
    chb_reg_write16(PAN_ID_0, CHB_PAN_ID);
    2ed8:	82 e2       	ldi	r24, 0x22	; 34
    2eda:	64 e3       	ldi	r22, 0x34	; 52
    2edc:	72 e1       	ldi	r23, 0x12	; 18
    2ede:	0e 94 a8 15 	call	0x2b50	; 0x2b50 <chb_reg_write16>

    // set short addr
    // NOTE: Possibly get this from EEPROM
    chb_reg_write16(SHORT_ADDR_0, chb_get_short_addr());
    2ee2:	0e 94 f4 14 	call	0x29e8	; 0x29e8 <chb_get_short_addr>
    2ee6:	bc 01       	movw	r22, r24
    2ee8:	80 e2       	ldi	r24, 0x20	; 32
    2eea:	0e 94 a8 15 	call	0x2b50	; 0x2b50 <chb_reg_write16>

    // set long addr
    // NOTE: Possibly get this from EEPROM
    chb_get_ieee_addr(ieee_addr);
    2eee:	ce 01       	movw	r24, r28
    2ef0:	01 96       	adiw	r24, 0x01	; 1
    2ef2:	0e 94 ec 14 	call	0x29d8	; 0x29d8 <chb_get_ieee_addr>
    chb_reg_write64(IEEE_ADDR_0, ieee_addr);
    2ef6:	84 e2       	ldi	r24, 0x24	; 36
    2ef8:	be 01       	movw	r22, r28
    2efa:	6f 5f       	subi	r22, 0xFF	; 255
    2efc:	7f 4f       	sbci	r23, 0xFF	; 255
    2efe:	0e 94 82 15 	call	0x2b04	; 0x2b04 <chb_reg_write64>
    // set power to 0 dBm if CC1190 is being used. 
    chb_set_pwr(0x24);   
#endif

    // enable mcu intp pin
    CFG_CHB_INTP_RISE_EDGE();
    2f02:	e2 e7       	ldi	r30, 0x72	; 114
    2f04:	f6 e0       	ldi	r31, 0x06	; 6
    2f06:	80 81       	ld	r24, Z
    2f08:	81 60       	ori	r24, 0x01	; 1
    2f0a:	80 83       	st	Z, r24
    2f0c:	e9 e6       	ldi	r30, 0x69	; 105
    2f0e:	f6 e0       	ldi	r31, 0x06	; 6
    2f10:	80 81       	ld	r24, Z
    2f12:	82 60       	ori	r24, 0x02	; 2
    2f14:	80 83       	st	Z, r24
    2f16:	ea e6       	ldi	r30, 0x6A	; 106
    2f18:	f6 e0       	ldi	r31, 0x06	; 6
    2f1a:	80 81       	ld	r24, Z
    2f1c:	84 60       	ori	r24, 0x04	; 4
    2f1e:	80 83       	st	Z, r24
	PMIC.CTRL = 0x07;	//enable interrupts on MCU
    2f20:	87 e0       	ldi	r24, 0x07	; 7
    2f22:	e0 ea       	ldi	r30, 0xA0	; 160
    2f24:	f0 e0       	ldi	r31, 0x00	; 0
    2f26:	82 83       	std	Z+2, r24	; 0x02

    if (chb_get_state() != RX_STATE)
    2f28:	0e 94 f7 15 	call	0x2bee	; 0x2bee <chb_get_state>
    2f2c:	86 31       	cpi	r24, 0x16	; 22
    2f2e:	91 f0       	breq	.+36     	; 0x2f54 <chb_drvr_init+0xf2>
    {
        // ERROR occurred initializing the radio. Print out error message.
        char buf[50];

        // grab the error message from flash & print it out
        strcpy_P(buf, chb_err_init);
    2f30:	8e 01       	movw	r16, r28
    2f32:	07 5f       	subi	r16, 0xF7	; 247
    2f34:	1f 4f       	sbci	r17, 0xFF	; 255
    2f36:	c8 01       	movw	r24, r16
    2f38:	68 ee       	ldi	r22, 0xE8	; 232
    2f3a:	71 e0       	ldi	r23, 0x01	; 1
    2f3c:	0e 94 ce 35 	call	0x6b9c	; 0x6b9c <strcpy_P>
        printf(buf);
    2f40:	0f 92       	push	r0
    2f42:	0f 92       	push	r0
    2f44:	ed b7       	in	r30, 0x3d	; 61
    2f46:	fe b7       	in	r31, 0x3e	; 62
    2f48:	01 83       	std	Z+1, r16	; 0x01
    2f4a:	12 83       	std	Z+2, r17	; 0x02
    2f4c:	0e 94 e7 35 	call	0x6bce	; 0x6bce <printf>
    2f50:	0f 90       	pop	r0
    2f52:	0f 90       	pop	r0
    }
	StartOfFreeSpace = 0; //set location in FRAM Buffer at which to start storing radio messages to the start of the buffer
    2f54:	10 92 a6 50 	sts	0x50A6, r1
    2f58:	10 92 a7 50 	sts	0x50A7, r1
    2f5c:	10 92 a8 50 	sts	0x50A8, r1
    2f60:	10 92 a9 50 	sts	0x50A9, r1
    CHB_SLPTR_DDIR |= (_BV(CHB_SLPTR_PIN));
    CHB_RST_DDIR |= (_BV(CHB_RST_PIN));

    // config radio
    chb_radio_init();
}
    2f64:	ea 96       	adiw	r28, 0x3a	; 58
    2f66:	cd bf       	out	0x3d, r28	; 61
    2f68:	de bf       	out	0x3e, r29	; 62
    2f6a:	df 91       	pop	r29
    2f6c:	cf 91       	pop	r28
    2f6e:	1f 91       	pop	r17
    2f70:	0f 91       	pop	r16
    2f72:	08 95       	ret

00002f74 <__vector_64>:
/*!

*/
/**************************************************************************/
ISR(CHB_RADIO_IRQ)
{
    2f74:	1f 92       	push	r1
    2f76:	0f 92       	push	r0
    2f78:	0f b6       	in	r0, 0x3f	; 63
    2f7a:	0f 92       	push	r0
    2f7c:	0b b6       	in	r0, 0x3b	; 59
    2f7e:	0f 92       	push	r0
    2f80:	11 24       	eor	r1, r1
    2f82:	6f 92       	push	r6
    2f84:	7f 92       	push	r7
    2f86:	8f 92       	push	r8
    2f88:	9f 92       	push	r9
    2f8a:	af 92       	push	r10
    2f8c:	bf 92       	push	r11
    2f8e:	df 92       	push	r13
    2f90:	ef 92       	push	r14
    2f92:	ff 92       	push	r15
    2f94:	0f 93       	push	r16
    2f96:	1f 93       	push	r17
    2f98:	2f 93       	push	r18
    2f9a:	3f 93       	push	r19
    2f9c:	4f 93       	push	r20
    2f9e:	5f 93       	push	r21
    2fa0:	6f 93       	push	r22
    2fa2:	7f 93       	push	r23
    2fa4:	8f 93       	push	r24
    2fa6:	9f 93       	push	r25
    2fa8:	af 93       	push	r26
    2faa:	bf 93       	push	r27
    2fac:	ef 93       	push	r30
    2fae:	ff 93       	push	r31
    2fb0:	cf 93       	push	r28
    2fb2:	df 93       	push	r29
    2fb4:	cd b7       	in	r28, 0x3d	; 61
    2fb6:	de b7       	in	r29, 0x3e	; 62
    2fb8:	e2 97       	sbiw	r28, 0x32	; 50
    2fba:	cd bf       	out	0x3d, r28	; 61
    2fbc:	de bf       	out	0x3e, r29	; 62
    U8 dummy, state, intp_src = 0;
    pcb_t *pcb = chb_get_pcb();
    2fbe:	0e 94 94 13 	call	0x2728	; 0x2728 <chb_get_pcb>
    2fc2:	7c 01       	movw	r14, r24

    CHB_ENTER_CRIT();
    2fc4:	8f b7       	in	r24, 0x3f	; 63
    2fc6:	80 93 39 40 	sts	0x4039, r24
    2fca:	f8 94       	cli

    /*Read Interrupt source.*/
    RadioCS(TRUE);   
    2fcc:	81 e0       	ldi	r24, 0x01	; 1
    2fce:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <RadioCS>

    /*Send Register address and read register content.*/
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    2fd2:	8f e8       	ldi	r24, 0x8F	; 143
    2fd4:	0e 94 bb 19 	call	0x3376	; 0x3376 <SPID_write>
    intp_src = SPID_write(0);
    2fd8:	80 e0       	ldi	r24, 0x00	; 0
    2fda:	0e 94 bb 19 	call	0x3376	; 0x3376 <SPID_write>
    2fde:	18 2f       	mov	r17, r24

    RadioCS(FALSE);
    2fe0:	80 e0       	ldi	r24, 0x00	; 0
    2fe2:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <RadioCS>

    while (intp_src)
    2fe6:	11 23       	and	r17, r17
    2fe8:	09 f4       	brne	.+2      	; 0x2fec <__vector_64+0x78>
    2fea:	ed c0       	rjmp	.+474    	; 0x31c6 <__vector_64+0x252>

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    2fec:	aa 24       	eor	r10, r10
    2fee:	bb 24       	eor	r11, r11
    2ff0:	68 94       	set
    2ff2:	a7 f8       	bld	r10, 7

            // Increment the overflow stat
            pcb->overflow++;

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    2ff4:	0f 2e       	mov	r0, r31
    2ff6:	f8 e0       	ldi	r31, 0x08	; 8
    2ff8:	8f 2e       	mov	r8, r31
    2ffa:	f2 e0       	ldi	r31, 0x02	; 2
    2ffc:	9f 2e       	mov	r9, r31
    2ffe:	f0 2d       	mov	r31, r0
    RadioCS(FALSE);

    while (intp_src)
    {
        /*Handle the incomming interrupt. Prioritized.*/
        if ((intp_src & CHB_IRQ_RX_START_MASK))
    3000:	12 ff       	sbrs	r17, 2
    3002:	02 c0       	rjmp	.+4      	; 0x3008 <__vector_64+0x94>
        {
            intp_src &= ~CHB_IRQ_RX_START_MASK;
    3004:	1b 7f       	andi	r17, 0xFB	; 251
    3006:	dc c0       	rjmp	.+440    	; 0x31c0 <__vector_64+0x24c>
        }
        else if (intp_src & CHB_IRQ_TRX_END_MASK)
    3008:	13 ff       	sbrs	r17, 3
    300a:	c1 c0       	rjmp	.+386    	; 0x318e <__vector_64+0x21a>
        {
            state = chb_get_state();
    300c:	0e 94 f7 15 	call	0x2bee	; 0x2bee <chb_get_state>

            if ((state == CHB_RX_ON) || (state == CHB_RX_AACK_ON) || (state == CHB_BUSY_RX_AACK)){
    3010:	86 30       	cpi	r24, 0x06	; 6
    3012:	29 f0       	breq	.+10     	; 0x301e <__vector_64+0xaa>
    3014:	86 31       	cpi	r24, 0x16	; 22
    3016:	19 f0       	breq	.+6      	; 0x301e <__vector_64+0xaa>
    3018:	81 31       	cpi	r24, 0x11	; 17
    301a:	09 f0       	breq	.+2      	; 0x301e <__vector_64+0xaa>
    301c:	ae c0       	rjmp	.+348    	; 0x317a <__vector_64+0x206>
				//go to TRX_OFF state to avoid data corruption due to reception of another message
				chb_set_state(CHB_TRX_OFF);
    301e:	88 e0       	ldi	r24, 0x08	; 8
    3020:	0e 94 10 16 	call	0x2c20	; 0x2c20 <chb_set_state>
                // get the ed measurement
                pcb->ed = chb_reg_read(PHY_ED_LEVEL);
    3024:	87 e0       	ldi	r24, 0x07	; 7
    3026:	0e 94 dd 15 	call	0x2bba	; 0x2bba <chb_reg_read>
    302a:	f7 01       	movw	r30, r14
    302c:	82 8b       	std	Z+18, r24	; 0x12

                // get the crc
                pcb->crc = (chb_reg_read(PHY_RSSI) & (1<<7)) ? 1 : 0;
    302e:	86 e0       	ldi	r24, 0x06	; 6
    3030:	0e 94 dd 15 	call	0x2bba	; 0x2bba <chb_reg_read>
    3034:	88 1f       	adc	r24, r24
    3036:	88 27       	eor	r24, r24
    3038:	88 1f       	adc	r24, r24
    303a:	f7 01       	movw	r30, r14
    303c:	83 8b       	std	Z+19, r24	; 0x13

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
    303e:	88 23       	and	r24, r24
    3040:	09 f4       	brne	.+2      	; 0x3044 <__vector_64+0xd0>
    3042:	9e c0       	rjmp	.+316    	; 0x3180 <__vector_64+0x20c>
/**************************************************************************/
static void chb_frame_read()
{
    U8 i, len, data;

    CHB_ENTER_CRIT();
    3044:	8f b7       	in	r24, 0x3f	; 63
    3046:	80 93 39 40 	sts	0x4039, r24
    304a:	f8 94       	cli
    RadioCS(TRUE);
    304c:	81 e0       	ldi	r24, 0x01	; 1
    304e:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <RadioCS>

    /*Send frame read command and read the length.*/
    SPID_write(CHB_SPI_CMD_FR);
    3052:	80 e2       	ldi	r24, 0x20	; 32
    3054:	0e 94 bb 19 	call	0x3376	; 0x3376 <SPID_write>
    len = SPID_write(0);
    3058:	80 e0       	ldi	r24, 0x00	; 0
    305a:	0e 94 bb 19 	call	0x3376	; 0x3376 <SPID_write>
    305e:	d8 2e       	mov	r13, r24

    /*Check for correct frame length.*/
    if ((len >= CHB_MIN_FRAME_LENGTH) && (len <= CHB_MAX_FRAME_LENGTH))
    3060:	83 50       	subi	r24, 0x03	; 3
    3062:	8d 37       	cpi	r24, 0x7D	; 125
    3064:	f0 f5       	brcc	.+124    	; 0x30e2 <__vector_64+0x16e>
    {
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
    3066:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <chb_buf_get_len>
    306a:	2d 2d       	mov	r18, r13
    306c:	30 e0       	ldi	r19, 0x00	; 0
    306e:	a5 01       	movw	r20, r10
    3070:	48 1b       	sub	r20, r24
    3072:	51 09       	sbc	r21, r1
    3074:	24 17       	cp	r18, r20
    3076:	35 07       	cpc	r19, r21
    3078:	7c f4       	brge	.+30     	; 0x3098 <__vector_64+0x124>
        {
            chb_buf_write(len);
    307a:	8d 2d       	mov	r24, r13
    307c:	0e 94 bd 14 	call	0x297a	; 0x297a <chb_buf_write>
            
            for (i=0; i<len; i++)
    3080:	dd 20       	and	r13, r13
    3082:	79 f1       	breq	.+94     	; 0x30e2 <__vector_64+0x16e>
    3084:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    3086:	80 e0       	ldi	r24, 0x00	; 0
    3088:	0e 94 bb 19 	call	0x3376	; 0x3376 <SPID_write>
                chb_buf_write(data);
    308c:	0e 94 bd 14 	call	0x297a	; 0x297a <chb_buf_write>
        // check to see if there is room to write the frame in the buffer. if not, then drop it
        if (len < (CHB_BUF_SZ - chb_buf_get_len()))
        {
            chb_buf_write(len);
            
            for (i=0; i<len; i++)
    3090:	0f 5f       	subi	r16, 0xFF	; 255
    3092:	0d 15       	cp	r16, r13
    3094:	c1 f7       	brne	.-16     	; 0x3086 <__vector_64+0x112>
    3096:	25 c0       	rjmp	.+74     	; 0x30e2 <__vector_64+0x16e>
            }
        }
        else
        {
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
    3098:	0e 94 94 13 	call	0x2728	; 0x2728 <chb_get_pcb>
    309c:	3c 01       	movw	r6, r24
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    309e:	dd 20       	and	r13, r13
    30a0:	39 f0       	breq	.+14     	; 0x30b0 <__vector_64+0x13c>
    30a2:	00 e0       	ldi	r16, 0x00	; 0
            {
                data = SPID_write(0);
    30a4:	80 e0       	ldi	r24, 0x00	; 0
    30a6:	0e 94 bb 19 	call	0x3376	; 0x3376 <SPID_write>
            // we've overflowed the buffer. toss the data and do some housekeeping
            pcb_t *pcb = chb_get_pcb();
            char buf[50];

            // read out the data and throw it away
            for (i=0; i<len; i++)
    30aa:	0f 5f       	subi	r16, 0xFF	; 255
    30ac:	0d 15       	cp	r16, r13
    30ae:	d1 f7       	brne	.-12     	; 0x30a4 <__vector_64+0x130>
            {
                data = SPID_write(0);
            }

            // Increment the overflow stat
            pcb->overflow++;
    30b0:	f3 01       	movw	r30, r6
    30b2:	85 85       	ldd	r24, Z+13	; 0x0d
    30b4:	96 85       	ldd	r25, Z+14	; 0x0e
    30b6:	01 96       	adiw	r24, 0x01	; 1
    30b8:	85 87       	std	Z+13, r24	; 0x0d
    30ba:	96 87       	std	Z+14, r25	; 0x0e

            // grab the message from flash & print it out
            strcpy_P(buf, chb_err_overflow);
    30bc:	ce 01       	movw	r24, r28
    30be:	01 96       	adiw	r24, 0x01	; 1
    30c0:	b4 01       	movw	r22, r8
    30c2:	0e 94 ce 35 	call	0x6b9c	; 0x6b9c <strcpy_P>
            printf(buf);
    30c6:	0f 92       	push	r0
    30c8:	0f 92       	push	r0
    30ca:	41 e0       	ldi	r20, 0x01	; 1
    30cc:	50 e0       	ldi	r21, 0x00	; 0
    30ce:	4c 0f       	add	r20, r28
    30d0:	5d 1f       	adc	r21, r29
    30d2:	ed b7       	in	r30, 0x3d	; 61
    30d4:	fe b7       	in	r31, 0x3e	; 62
    30d6:	41 83       	std	Z+1, r20	; 0x01
    30d8:	52 83       	std	Z+2, r21	; 0x02
    30da:	0e 94 e7 35 	call	0x6bce	; 0x6bce <printf>
    30de:	0f 90       	pop	r0
    30e0:	0f 90       	pop	r0
        }
    }

    RadioCS(FALSE);
    30e2:	80 e0       	ldi	r24, 0x00	; 0
    30e4:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <RadioCS>
    CHB_LEAVE_CRIT();
    30e8:	80 91 39 40 	lds	r24, 0x4039
    30ec:	8f bf       	out	0x3f, r24	; 63
    30ee:	78 94       	sei

                // if the crc is not valid, then do not read the frame and set the rx flag
                if (pcb->crc){
                    // get the data
                    chb_frame_read();
                    pcb->rcvd_xfers++;
    30f0:	f7 01       	movw	r30, r14
    30f2:	85 81       	ldd	r24, Z+5	; 0x05
    30f4:	96 81       	ldd	r25, Z+6	; 0x06
    30f6:	01 96       	adiw	r24, 0x01	; 1
    30f8:	85 83       	std	Z+5, r24	; 0x05
    30fa:	96 83       	std	Z+6, r25	; 0x06
                    pcb->data_rcv = true;
    30fc:	81 e0       	ldi	r24, 0x01	; 1
    30fe:	83 83       	std	Z+3, r24	; 0x03
					StartOfFreeSpace += chb_read(FRAMReadBuffer+StartOfFreeSpace);	//read the data into the FRAM buffer right away --vlad
    3100:	80 91 a6 50 	lds	r24, 0x50A6
    3104:	90 91 a7 50 	lds	r25, 0x50A7
    3108:	a0 91 a8 50 	lds	r26, 0x50A8
    310c:	b0 91 a9 50 	lds	r27, 0x50A9
    3110:	8e 53       	subi	r24, 0x3E	; 62
    3112:	9c 4d       	sbci	r25, 0xDC	; 220
    3114:	0e 94 57 14 	call	0x28ae	; 0x28ae <chb_read>
    3118:	40 91 a6 50 	lds	r20, 0x50A6
    311c:	50 91 a7 50 	lds	r21, 0x50A7
    3120:	60 91 a8 50 	lds	r22, 0x50A8
    3124:	70 91 a9 50 	lds	r23, 0x50A9
    3128:	48 0f       	add	r20, r24
    312a:	51 1d       	adc	r21, r1
    312c:	61 1d       	adc	r22, r1
    312e:	71 1d       	adc	r23, r1
    3130:	40 93 a6 50 	sts	0x50A6, r20
    3134:	50 93 a7 50 	sts	0x50A7, r21
    3138:	60 93 a8 50 	sts	0x50A8, r22
    313c:	70 93 a9 50 	sts	0x50A9, r23
					if(StartOfFreeSpace+128 >= FR_READ_BUFFER_SIZE) StartOfFreeSpace = 0;	//wrap around to the start of the buffer (making circular buffer). This should be avoided as data in the buffer will be overwritten (i.e. lost).			
    3140:	80 91 a6 50 	lds	r24, 0x50A6
    3144:	90 91 a7 50 	lds	r25, 0x50A7
    3148:	a0 91 a8 50 	lds	r26, 0x50A8
    314c:	b0 91 a9 50 	lds	r27, 0x50A9
    3150:	80 58       	subi	r24, 0x80	; 128
    3152:	9f 4f       	sbci	r25, 0xFF	; 255
    3154:	af 4f       	sbci	r26, 0xFF	; 255
    3156:	bf 4f       	sbci	r27, 0xFF	; 255
    3158:	81 37       	cpi	r24, 0x71	; 113
    315a:	fc e1       	ldi	r31, 0x1C	; 28
    315c:	9f 07       	cpc	r25, r31
    315e:	f0 e0       	ldi	r31, 0x00	; 0
    3160:	af 07       	cpc	r26, r31
    3162:	f0 e0       	ldi	r31, 0x00	; 0
    3164:	bf 07       	cpc	r27, r31
    3166:	60 f0       	brcs	.+24     	; 0x3180 <__vector_64+0x20c>
    3168:	10 92 a6 50 	sts	0x50A6, r1
    316c:	10 92 a7 50 	sts	0x50A7, r1
    3170:	10 92 a8 50 	sts	0x50A8, r1
    3174:	10 92 a9 50 	sts	0x50A9, r1
    3178:	03 c0       	rjmp	.+6      	; 0x3180 <__vector_64+0x20c>
                }
            }
            else{
                pcb->tx_end = true;
    317a:	81 e0       	ldi	r24, 0x01	; 1
    317c:	f7 01       	movw	r30, r14
    317e:	84 83       	std	Z+4, r24	; 0x04
            }
            intp_src &= ~CHB_IRQ_TRX_END_MASK;
    3180:	17 7f       	andi	r17, 0xF7	; 247
			//go to receive state
            while (chb_set_state(RX_STATE) != RADIO_SUCCESS);
    3182:	86 e1       	ldi	r24, 0x16	; 22
    3184:	0e 94 10 16 	call	0x2c20	; 0x2c20 <chb_set_state>
    3188:	80 34       	cpi	r24, 0x40	; 64
    318a:	d9 f7       	brne	.-10     	; 0x3182 <__vector_64+0x20e>
    318c:	19 c0       	rjmp	.+50     	; 0x31c0 <__vector_64+0x24c>
        }
        else if (intp_src & CHB_IRQ_TRX_UR_MASK)
    318e:	16 ff       	sbrs	r17, 6
    3190:	08 c0       	rjmp	.+16     	; 0x31a2 <__vector_64+0x22e>
        {
            intp_src &= ~CHB_IRQ_TRX_UR_MASK;
    3192:	1f 7b       	andi	r17, 0xBF	; 191
            pcb->underrun++;
    3194:	f7 01       	movw	r30, r14
    3196:	87 85       	ldd	r24, Z+15	; 0x0f
    3198:	90 89       	ldd	r25, Z+16	; 0x10
    319a:	01 96       	adiw	r24, 0x01	; 1
    319c:	87 87       	std	Z+15, r24	; 0x0f
    319e:	90 8b       	std	Z+16, r25	; 0x10
    31a0:	0f c0       	rjmp	.+30     	; 0x31c0 <__vector_64+0x24c>
        }
        else if (intp_src & CHB_IRQ_PLL_UNLOCK_MASK)
    31a2:	11 ff       	sbrs	r17, 1
    31a4:	02 c0       	rjmp	.+4      	; 0x31aa <__vector_64+0x236>
        {
            intp_src &= ~CHB_IRQ_PLL_UNLOCK_MASK;
    31a6:	1d 7f       	andi	r17, 0xFD	; 253
    31a8:	0b c0       	rjmp	.+22     	; 0x31c0 <__vector_64+0x24c>
        }
        else if (intp_src & CHB_IRQ_PLL_LOCK_MASK)
    31aa:	10 ff       	sbrs	r17, 0
    31ac:	02 c0       	rjmp	.+4      	; 0x31b2 <__vector_64+0x23e>
        {
            intp_src &= ~CHB_IRQ_PLL_LOCK_MASK;
    31ae:	1e 7f       	andi	r17, 0xFE	; 254
    31b0:	07 c0       	rjmp	.+14     	; 0x31c0 <__vector_64+0x24c>
        }
        else if (intp_src & CHB_IRQ_BAT_LOW_MASK)
    31b2:	11 23       	and	r17, r17
    31b4:	2c f4       	brge	.+10     	; 0x31c0 <__vector_64+0x24c>
        {
            intp_src &= ~CHB_IRQ_BAT_LOW_MASK;
    31b6:	1f 77       	andi	r17, 0x7F	; 127
            pcb->battlow++;
    31b8:	f7 01       	movw	r30, r14
    31ba:	81 89       	ldd	r24, Z+17	; 0x11
    31bc:	8f 5f       	subi	r24, 0xFF	; 255
    31be:	81 8b       	std	Z+17, r24	; 0x11
    dummy = SPID_write(IRQ_STATUS | CHB_SPI_CMD_RR);
    intp_src = SPID_write(0);

    RadioCS(FALSE);

    while (intp_src)
    31c0:	11 23       	and	r17, r17
    31c2:	09 f0       	breq	.+2      	; 0x31c6 <__vector_64+0x252>
    31c4:	1d cf       	rjmp	.-454    	; 0x3000 <__vector_64+0x8c>
        }
        else
        {
        }
    }
    CHB_LEAVE_CRIT();
    31c6:	80 91 39 40 	lds	r24, 0x4039
    31ca:	8f bf       	out	0x3f, r24	; 63
    31cc:	78 94       	sei
	chb_reg_read(IRQ_STATUS);		//clear any interrupts that might have been seen when handling this interrupt
    31ce:	8f e0       	ldi	r24, 0x0F	; 15
    31d0:	0e 94 dd 15 	call	0x2bba	; 0x2bba <chb_reg_read>
}
    31d4:	e2 96       	adiw	r28, 0x32	; 50
    31d6:	cd bf       	out	0x3d, r28	; 61
    31d8:	de bf       	out	0x3e, r29	; 62
    31da:	df 91       	pop	r29
    31dc:	cf 91       	pop	r28
    31de:	ff 91       	pop	r31
    31e0:	ef 91       	pop	r30
    31e2:	bf 91       	pop	r27
    31e4:	af 91       	pop	r26
    31e6:	9f 91       	pop	r25
    31e8:	8f 91       	pop	r24
    31ea:	7f 91       	pop	r23
    31ec:	6f 91       	pop	r22
    31ee:	5f 91       	pop	r21
    31f0:	4f 91       	pop	r20
    31f2:	3f 91       	pop	r19
    31f4:	2f 91       	pop	r18
    31f6:	1f 91       	pop	r17
    31f8:	0f 91       	pop	r16
    31fa:	ff 90       	pop	r15
    31fc:	ef 90       	pop	r14
    31fe:	df 90       	pop	r13
    3200:	bf 90       	pop	r11
    3202:	af 90       	pop	r10
    3204:	9f 90       	pop	r9
    3206:	8f 90       	pop	r8
    3208:	7f 90       	pop	r7
    320a:	6f 90       	pop	r6
    320c:	0f 90       	pop	r0
    320e:	0b be       	out	0x3b, r0	; 59
    3210:	0f 90       	pop	r0
    3212:	0f be       	out	0x3f, r0	; 63
    3214:	0f 90       	pop	r0
    3216:	1f 90       	pop	r1
    3218:	18 95       	reti

0000321a <chb_eeprom_write>:
/*!

*/
/**************************************************************************/
void chb_eeprom_write(U16 addr, U8 *buf, U16 size)
{
    321a:	0f 93       	push	r16
    321c:	1f 93       	push	r17
    321e:	cf 93       	push	r28
    3220:	df 93       	push	r29
    3222:	8c 01       	movw	r16, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    3224:	e0 ec       	ldi	r30, 0xC0	; 192
    3226:	f1 e0       	ldi	r31, 0x01	; 1
    3228:	84 85       	ldd	r24, Z+12	; 0x0c
    322a:	87 7f       	andi	r24, 0xF7	; 247
    322c:	84 87       	std	Z+12, r24	; 0x0c

    // Write bytes
    for(U8 i=0; i<size; i++)
    322e:	41 15       	cp	r20, r1
    3230:	51 05       	cpc	r21, r1
    3232:	09 f4       	brne	.+2      	; 0x3236 <chb_eeprom_write+0x1c>
    3234:	50 c0       	rjmp	.+160    	; 0x32d6 <chb_eeprom_write+0xbc>
    3236:	e0 e0       	ldi	r30, 0x00	; 0
    3238:	f0 e0       	ldi	r31, 0x00	; 0
    323a:	20 e0       	ldi	r18, 0x00	; 0
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    323c:	a0 ec       	ldi	r26, 0xC0	; 192
    323e:	b1 e0       	ldi	r27, 0x01	; 1

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3240:	d6 e3       	ldi	r29, 0x36	; 54
        NVM_EXEC();
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3242:	c3 e3       	ldi	r28, 0x33	; 51

    // load the data to write
    NVM.DATA0 = value;

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    3244:	35 e3       	ldi	r19, 0x35	; 53
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    {
        chb_eep_write_byte(addr+i, buf[i]);
    3246:	cf 01       	movw	r24, r30
    3248:	80 0f       	add	r24, r16
    324a:	91 1f       	adc	r25, r17
    324c:	e6 0f       	add	r30, r22
    324e:	f7 1f       	adc	r31, r23
    3250:	f0 81       	ld	r31, Z
/**************************************************************************/
static void chb_eep_write_byte( U16 addr, U8 value )
{
    // flush the eeprom buffers
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    3252:	1f 96       	adiw	r26, 0x0f	; 15
    3254:	ec 91       	ld	r30, X
    3256:	1f 97       	sbiw	r26, 0x0f	; 15
    3258:	ee 23       	and	r30, r30
    325a:	dc f3       	brlt	.-10     	; 0x3252 <chb_eeprom_write+0x38>

    /* Flush EEPROM page buffer if necessary. */
    if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    325c:	1f 96       	adiw	r26, 0x0f	; 15
    325e:	ec 91       	ld	r30, X
    3260:	1f 97       	sbiw	r26, 0x0f	; 15
    3262:	e1 ff       	sbrs	r30, 1
    3264:	11 c0       	rjmp	.+34     	; 0x3288 <chb_eeprom_write+0x6e>
        NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    3266:	1a 96       	adiw	r26, 0x0a	; 10
    3268:	dc 93       	st	X, r29
    326a:	1a 97       	sbiw	r26, 0x0a	; 10
        NVM_EXEC();
    326c:	ef 93       	push	r30
    326e:	ff 93       	push	r31
    3270:	0f 93       	push	r16
    3272:	2f 93       	push	r18
    3274:	eb ec       	ldi	r30, 0xCB	; 203
    3276:	f1 e0       	ldi	r31, 0x01	; 1
    3278:	08 ed       	ldi	r16, 0xD8	; 216
    327a:	21 e0       	ldi	r18, 0x01	; 1
    327c:	04 bf       	out	0x34, r16	; 52
    327e:	20 83       	st	Z, r18
    3280:	2f 91       	pop	r18
    3282:	0f 91       	pop	r16
    3284:	ff 91       	pop	r31
    3286:	ef 91       	pop	r30
    }

    // tell the non-volatile regs that we're going to load the eeprom addr
    NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    3288:	1a 96       	adiw	r26, 0x0a	; 10
    328a:	cc 93       	st	X, r28
    328c:	1a 97       	sbiw	r26, 0x0a	; 10

    // load the address
    NVM.ADDR0 = addr & 0xFF;
    328e:	8c 93       	st	X, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3290:	89 2f       	mov	r24, r25
    3292:	8f 71       	andi	r24, 0x1F	; 31
    3294:	11 96       	adiw	r26, 0x01	; 1
    3296:	8c 93       	st	X, r24
    3298:	11 97       	sbiw	r26, 0x01	; 1
    NVM.ADDR2 = 0x00;
    329a:	12 96       	adiw	r26, 0x02	; 2
    329c:	1c 92       	st	X, r1
    329e:	12 97       	sbiw	r26, 0x02	; 2

    // load the data to write
    NVM.DATA0 = value;
    32a0:	14 96       	adiw	r26, 0x04	; 4
    32a2:	fc 93       	st	X, r31
    32a4:	14 97       	sbiw	r26, 0x04	; 4

    // execute the eeprom write command
    NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    32a6:	1a 96       	adiw	r26, 0x0a	; 10
    32a8:	3c 93       	st	X, r19
    32aa:	1a 97       	sbiw	r26, 0x0a	; 10
    NVM_EXEC();
    32ac:	ef 93       	push	r30
    32ae:	ff 93       	push	r31
    32b0:	0f 93       	push	r16
    32b2:	2f 93       	push	r18
    32b4:	eb ec       	ldi	r30, 0xCB	; 203
    32b6:	f1 e0       	ldi	r31, 0x01	; 1
    32b8:	08 ed       	ldi	r16, 0xD8	; 216
    32ba:	21 e0       	ldi	r18, 0x01	; 1
    32bc:	04 bf       	out	0x34, r16	; 52
    32be:	20 83       	st	Z, r18
    32c0:	2f 91       	pop	r18
    32c2:	0f 91       	pop	r16
    32c4:	ff 91       	pop	r31
    32c6:	ef 91       	pop	r30
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    // Write bytes
    for(U8 i=0; i<size; i++)
    32c8:	2f 5f       	subi	r18, 0xFF	; 255
    32ca:	e2 2f       	mov	r30, r18
    32cc:	f0 e0       	ldi	r31, 0x00	; 0
    32ce:	e4 17       	cp	r30, r20
    32d0:	f5 07       	cpc	r31, r21
    32d2:	08 f4       	brcc	.+2      	; 0x32d6 <chb_eeprom_write+0xbc>
    32d4:	b8 cf       	rjmp	.-144    	; 0x3246 <chb_eeprom_write+0x2c>
    {
        chb_eep_write_byte(addr+i, buf[i]);
    }
}
    32d6:	df 91       	pop	r29
    32d8:	cf 91       	pop	r28
    32da:	1f 91       	pop	r17
    32dc:	0f 91       	pop	r16
    32de:	08 95       	ret

000032e0 <chb_eeprom_read>:
/*!

*/
/**************************************************************************/
void chb_eeprom_read(U16 addr, U8 *buf, U16 size)
{
    32e0:	1f 93       	push	r17
    32e2:	cf 93       	push	r28
    32e4:	df 93       	push	r29
    32e6:	9c 01       	movw	r18, r24
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;
    32e8:	e0 ec       	ldi	r30, 0xC0	; 192
    32ea:	f1 e0       	ldi	r31, 0x01	; 1
    32ec:	84 85       	ldd	r24, Z+12	; 0x0c
    32ee:	87 7f       	andi	r24, 0xF7	; 247
    32f0:	84 87       	std	Z+12, r24	; 0x0c

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    32f2:	41 15       	cp	r20, r1
    32f4:	51 05       	cpc	r21, r1
    32f6:	41 f1       	breq	.+80     	; 0x3348 <chb_eeprom_read+0x68>
    32f8:	80 e0       	ldi	r24, 0x00	; 0
    32fa:	90 e0       	ldi	r25, 0x00	; 0
    32fc:	c0 e0       	ldi	r28, 0x00	; 0
    NVM.ADDR0 = addr & 0xFF;
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    NVM.ADDR2 = 0x00;

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    32fe:	d6 e0       	ldi	r29, 0x06	; 6
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    3300:	db 01       	movw	r26, r22
    3302:	a8 0f       	add	r26, r24
    3304:	b9 1f       	adc	r27, r25
    3306:	82 0f       	add	r24, r18
    3308:	93 1f       	adc	r25, r19
*/
/**************************************************************************/
static U8 chb_eep_read_byte(U16 addr)
{
    /* Wait until NVM is not busy. */
    while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    330a:	17 85       	ldd	r17, Z+15	; 0x0f
    330c:	11 23       	and	r17, r17
    330e:	ec f3       	brlt	.-6      	; 0x330a <chb_eeprom_read+0x2a>

    /* Set address to read from. */
    NVM.ADDR0 = addr & 0xFF;
    3310:	80 83       	st	Z, r24
    NVM.ADDR1 = (addr >> 8) & 0x1F;
    3312:	89 2f       	mov	r24, r25
    3314:	8f 71       	andi	r24, 0x1F	; 31
    3316:	81 83       	std	Z+1, r24	; 0x01
    NVM.ADDR2 = 0x00;
    3318:	12 82       	std	Z+2, r1	; 0x02

    /* Issue EEPROM Read command. */
    NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    331a:	d2 87       	std	Z+10, r29	; 0x0a
    NVM_EXEC();
    331c:	ef 93       	push	r30
    331e:	ff 93       	push	r31
    3320:	0f 93       	push	r16
    3322:	2f 93       	push	r18
    3324:	eb ec       	ldi	r30, 0xCB	; 203
    3326:	f1 e0       	ldi	r31, 0x01	; 1
    3328:	08 ed       	ldi	r16, 0xD8	; 216
    332a:	21 e0       	ldi	r18, 0x01	; 1
    332c:	04 bf       	out	0x34, r16	; 52
    332e:	20 83       	st	Z, r18
    3330:	2f 91       	pop	r18
    3332:	0f 91       	pop	r16
    3334:	ff 91       	pop	r31
    3336:	ef 91       	pop	r30

    return NVM.DATA0;
    3338:	84 81       	ldd	r24, Z+4	; 0x04
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    {
        buf[i] = chb_eep_read_byte(addr+i);
    333a:	8c 93       	st	X, r24
{
    // disable memory mapping
    NVM.CTRLB &= ~NVM_EEMAPEN_bm;

    /* Write bytes.*/
    for(U8 i=0; i<size; i++)
    333c:	cf 5f       	subi	r28, 0xFF	; 255
    333e:	8c 2f       	mov	r24, r28
    3340:	90 e0       	ldi	r25, 0x00	; 0
    3342:	84 17       	cp	r24, r20
    3344:	95 07       	cpc	r25, r21
    3346:	e0 f2       	brcs	.-72     	; 0x3300 <chb_eeprom_read+0x20>
    {
        buf[i] = chb_eep_read_byte(addr+i);
    }
}
    3348:	df 91       	pop	r29
    334a:	cf 91       	pop	r28
    334c:	1f 91       	pop	r17
    334e:	08 95       	ret

00003350 <chb_spi_init>:

void chb_spi_init()
{
    // configure the SPI slave_select, spi clk, and mosi pins as output. the miso pin
    // is cleared since its an input.
    CHB_SPI_DDIR |= (1<<CHB_SSPIN) | (1<<CHB_MOSI) | (1<<CHB_SCK);
    3350:	e0 e6       	ldi	r30, 0x60	; 96
    3352:	f6 e0       	ldi	r31, 0x06	; 6
    3354:	80 81       	ld	r24, Z
    3356:	80 6b       	ori	r24, 0xB0	; 176
    3358:	80 83       	st	Z, r24
    CHB_SPI_PORT |= (1<<CHB_SSPIN);
    335a:	e4 e6       	ldi	r30, 0x64	; 100
    335c:	f6 e0       	ldi	r31, 0x06	; 6
    335e:	80 81       	ld	r24, Z
    3360:	80 61       	ori	r24, 0x10	; 16
    3362:	80 83       	st	Z, r24

    // set to master mode
    // set the clock freq to fck/16
    CHB_CTRL |= (1<<SPI_MASTER_bp) | (1<<SPI_ENABLE_bp) | (1<<SPI_PRESCALER_gp);
    3364:	a0 ec       	ldi	r26, 0xC0	; 192
    3366:	b9 e0       	ldi	r27, 0x09	; 9
    3368:	8c 91       	ld	r24, X
    336a:	81 65       	ori	r24, 0x51	; 81
    336c:	8c 93       	st	X, r24

    // set the slave select to idle
    CHB_SPI_DISABLE();
    336e:	80 81       	ld	r24, Z
    3370:	80 61       	ori	r24, 0x10	; 16
    3372:	80 83       	st	Z, r24
}
    3374:	08 95       	ret

00003376 <SPID_write>:
    data is read byte val.
*/
/**************************************************************************/
uint8_t SPID_write(uint8_t byteToSend){
	uint8_t data;
	SPID.DATA = byteToSend;
    3376:	e0 ec       	ldi	r30, 0xC0	; 192
    3378:	f9 e0       	ldi	r31, 0x09	; 9
    337a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPID.STATUS & SPI_IF_bm)); //wait for byte to be sent
    337c:	82 81       	ldd	r24, Z+2	; 0x02
    337e:	88 23       	and	r24, r24
    3380:	ec f7       	brge	.-6      	; 0x337c <SPID_write+0x6>
	data = SPID.DATA; //read SPI data register to reset status flag
    3382:	e0 ec       	ldi	r30, 0xC0	; 192
    3384:	f9 e0       	ldi	r31, 0x09	; 9
    3386:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
    3388:	08 95       	ret

0000338a <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    338a:	0f 93       	push	r16
    338c:	cf 93       	push	r28
    338e:	df 93       	push	r29
    3390:	0f 92       	push	r0
    3392:	cd b7       	in	r28, 0x3d	; 61
    3394:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
    3396:	2f b7       	in	r18, 0x3f	; 63
    3398:	29 83       	std	Y+1, r18	; 0x01
    339a:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
    339c:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
    339e:	fc 01       	movw	r30, r24
    33a0:	08 ed       	ldi	r16, 0xD8	; 216
    33a2:	04 bf       	out	0x34, r16	; 52
    33a4:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
    33a6:	89 81       	ldd	r24, Y+1	; 0x01
    33a8:	8f bf       	out	0x3f, r24	; 63
#endif
}
    33aa:	0f 90       	pop	r0
    33ac:	df 91       	pop	r29
    33ae:	cf 91       	pop	r28
    33b0:	0f 91       	pop	r16
    33b2:	08 95       	ret

000033b4 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
    33b4:	66 23       	and	r22, r22
    33b6:	11 f0       	breq	.+4      	; 0x33bc <CLKSYS_XOSC_Config+0x8>
    33b8:	90 e2       	ldi	r25, 0x20	; 32
    33ba:	01 c0       	rjmp	.+2      	; 0x33be <CLKSYS_XOSC_Config+0xa>
    33bc:	90 e0       	ldi	r25, 0x00	; 0
    33be:	84 2b       	or	r24, r20
    33c0:	89 2b       	or	r24, r25
    33c2:	e0 e5       	ldi	r30, 0x50	; 80
    33c4:	f0 e0       	ldi	r31, 0x00	; 0
    33c6:	82 83       	std	Z+2, r24	; 0x02
	               ( lowPower32kHz ? OSC_X32KLPM_bm : 0 ) |
	               xoscModeSelection;
}
    33c8:	08 95       	ret

000033ca <CLKSYS_PLL_Config>:
 *  \param  factor      PLL multiplication factor, must be
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
    33ca:	6f 71       	andi	r22, 0x1F	; 31
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
    33cc:	86 2b       	or	r24, r22
    33ce:	e0 e5       	ldi	r30, 0x50	; 80
    33d0:	f0 e0       	ldi	r31, 0x00	; 0
    33d2:	85 83       	std	Z+5, r24	; 0x05
}
    33d4:	08 95       	ret

000033d6 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
    33d6:	e0 e5       	ldi	r30, 0x50	; 80
    33d8:	f0 e0       	ldi	r31, 0x00	; 0
    33da:	90 81       	ld	r25, Z
    33dc:	28 2f       	mov	r18, r24
    33de:	20 95       	com	r18
    33e0:	92 23       	and	r25, r18
    33e2:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
    33e4:	90 81       	ld	r25, Z
	return clkEnabled;
}
    33e6:	89 23       	and	r24, r25
    33e8:	08 95       	ret

000033ea <CLKSYS_Prescalers_Config>:
 *                      of (1,1), (1,2), (4,1) or (2,2).
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
    33ea:	68 2b       	or	r22, r24
	CCPWrite( &CLK.PSCTRL, PSconfig );
    33ec:	81 e4       	ldi	r24, 0x41	; 65
    33ee:	90 e0       	ldi	r25, 0x00	; 0
    33f0:	0e 94 c5 19 	call	0x338a	; 0x338a <CCPWrite>
}
    33f4:	08 95       	ret

000033f6 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
    33f6:	1f 93       	push	r17
    33f8:	cf 93       	push	r28
    33fa:	df 93       	push	r29
    33fc:	18 2f       	mov	r17, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
    33fe:	c0 e4       	ldi	r28, 0x40	; 64
    3400:	d0 e0       	ldi	r29, 0x00	; 0
    3402:	68 81       	ld	r22, Y
    3404:	68 7f       	andi	r22, 0xF8	; 248
    3406:	68 2b       	or	r22, r24
	CCPWrite( &CLK.CTRL, clkCtrl );
    3408:	80 e4       	ldi	r24, 0x40	; 64
    340a:	90 e0       	ldi	r25, 0x00	; 0
    340c:	0e 94 c5 19 	call	0x338a	; 0x338a <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
    3410:	88 81       	ld	r24, Y
	return clkCtrl;
}
    3412:	81 23       	and	r24, r17
    3414:	df 91       	pop	r29
    3416:	cf 91       	pop	r28
    3418:	1f 91       	pop	r17
    341a:	08 95       	ret

0000341c <CLKSYS_RTC_ClockSource_Enable>:
 *
 *  \param  clockSource  Clock source to use for the RTC.
 */
void CLKSYS_RTC_ClockSource_Enable( CLK_RTCSRC_t clockSource )
{
	CLK.RTCCTRL = ( CLK.RTCCTRL & ~CLK_RTCSRC_gm ) |
    341c:	e0 e4       	ldi	r30, 0x40	; 64
    341e:	f0 e0       	ldi	r31, 0x00	; 0
    3420:	93 81       	ldd	r25, Z+3	; 0x03
    3422:	91 7f       	andi	r25, 0xF1	; 241
    3424:	91 60       	ori	r25, 0x01	; 1
    3426:	89 2b       	or	r24, r25
    3428:	83 83       	std	Z+3, r24	; 0x03
	              clockSource |
	              CLK_RTCEN_bm;
}
    342a:	08 95       	ret

0000342c <CLKSYS_AutoCalibration_Enable>:
 *                       OSC_RC32MCREF_bm.
 *  \param  extReference True if external crystal should be used as reference.
 */
void CLKSYS_AutoCalibration_Enable( uint8_t clkSource, bool extReference )
{
	OSC.DFLLCTRL = ( OSC.DFLLCTRL & ~clkSource ) |
    342c:	e0 e5       	ldi	r30, 0x50	; 80
    342e:	f0 e0       	ldi	r31, 0x00	; 0
    3430:	26 81       	ldd	r18, Z+6	; 0x06
    3432:	98 2f       	mov	r25, r24
    3434:	38 2f       	mov	r19, r24
    3436:	30 95       	com	r19
    3438:	23 23       	and	r18, r19
    343a:	66 23       	and	r22, r22
    343c:	09 f4       	brne	.+2      	; 0x3440 <CLKSYS_AutoCalibration_Enable+0x14>
    343e:	90 e0       	ldi	r25, 0x00	; 0
    3440:	92 2b       	or	r25, r18
    3442:	e0 e5       	ldi	r30, 0x50	; 80
    3444:	f0 e0       	ldi	r31, 0x00	; 0
    3446:	96 83       	std	Z+6, r25	; 0x06
	               ( extReference ? clkSource : 0 );
	if (clkSource == OSC_RC2MCREF_bm) {
    3448:	81 30       	cpi	r24, 0x01	; 1
    344a:	31 f4       	brne	.+12     	; 0x3458 <CLKSYS_AutoCalibration_Enable+0x2c>
		DFLLRC2M.CTRL |= DFLL_ENABLE_bm;
    344c:	e8 e6       	ldi	r30, 0x68	; 104
    344e:	f0 e0       	ldi	r31, 0x00	; 0
    3450:	80 81       	ld	r24, Z
    3452:	81 60       	ori	r24, 0x01	; 1
    3454:	80 83       	st	Z, r24
    3456:	08 95       	ret
	} else if (clkSource == OSC_RC32MCREF_bm) {
    3458:	82 30       	cpi	r24, 0x02	; 2
    345a:	29 f4       	brne	.+10     	; 0x3466 <CLKSYS_AutoCalibration_Enable+0x3a>
		DFLLRC32M.CTRL |= DFLL_ENABLE_bm;
    345c:	e0 e6       	ldi	r30, 0x60	; 96
    345e:	f0 e0       	ldi	r31, 0x00	; 0
    3460:	80 81       	ld	r24, Z
    3462:	81 60       	ori	r24, 0x01	; 1
    3464:	80 83       	st	Z, r24
    3466:	08 95       	ret

00003468 <CLKSYS_XOSC_FailureDetection_Enable>:
 *  any interrupt priorities and settings. Therefore, make sure that a handler
 *  is implemented for the XOSCF NMI when you enable it.
 */
void CLKSYS_XOSC_FailureDetection_Enable( void )
{
	CCPWrite( &OSC.XOSCFAIL, ( OSC_XOSCFDIF_bm | OSC_XOSCFDEN_bm ) );
    3468:	83 e5       	ldi	r24, 0x53	; 83
    346a:	90 e0       	ldi	r25, 0x00	; 0
    346c:	63 e0       	ldi	r22, 0x03	; 3
    346e:	0e 94 c5 19 	call	0x338a	; 0x338a <CCPWrite>
}
    3472:	08 95       	ret

00003474 <CLKSYS_Configuration_Lock>:
 *  External Oscillator Failure Detections (XOSCFD) feature detects a failure
 *  and switches to internal 2MHz RC oscillator.
 */
void CLKSYS_Configuration_Lock( void )
{
	CCPWrite( &CLK.LOCK, CLK_LOCK_bm );
    3474:	82 e4       	ldi	r24, 0x42	; 66
    3476:	90 e0       	ldi	r25, 0x00	; 0
    3478:	61 e0       	ldi	r22, 0x01	; 1
    347a:	0e 94 c5 19 	call	0x338a	; 0x338a <CCPWrite>
}
    347e:	08 95       	ret

00003480 <setXOSC_32MHz>:
//  - SFLX02-A03 does contain the crystal
// The high frequency crystal is required to clock the ADC without jitter

void setXOSC_32MHz() {
	// configure the crystal to match the chip 
	CLKSYS_XOSC_Config( OSC_FRQRANGE_12TO16_gc,
    3480:	80 ec       	ldi	r24, 0xC0	; 192
    3482:	60 e0       	ldi	r22, 0x00	; 0
    3484:	4b e0       	ldi	r20, 0x0B	; 11
    3486:	0e 94 da 19 	call	0x33b4	; 0x33b4 <CLKSYS_XOSC_Config>
		                    false,
		                    OSC_XOSCSEL_XTAL_16KCLK_gc );
	CLKSYS_Enable(OSC_XOSCEN_bm);
    348a:	e0 e5       	ldi	r30, 0x50	; 80
    348c:	f0 e0       	ldi	r31, 0x00	; 0
    348e:	80 81       	ld	r24, Z
    3490:	88 60       	ori	r24, 0x08	; 8
    3492:	80 83       	st	Z, r24
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    3494:	81 81       	ldd	r24, Z+1	; 0x01
    3496:	83 ff       	sbrs	r24, 3
    3498:	fd cf       	rjmp	.-6      	; 0x3494 <setXOSC_32MHz+0x14>
	// configure PLL to use the crystal and turn on
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 2);
    349a:	80 ec       	ldi	r24, 0xC0	; 192
    349c:	62 e0       	ldi	r22, 0x02	; 2
    349e:	0e 94 e5 19 	call	0x33ca	; 0x33ca <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    34a2:	e0 e5       	ldi	r30, 0x50	; 80
    34a4:	f0 e0       	ldi	r31, 0x00	; 0
    34a6:	80 81       	ld	r24, Z
    34a8:	80 61       	ori	r24, 0x10	; 16
    34aa:	80 83       	st	Z, r24
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    34ac:	81 81       	ldd	r24, Z+1	; 0x01
    34ae:	84 ff       	sbrs	r24, 4
    34b0:	fd cf       	rjmp	.-6      	; 0x34ac <setXOSC_32MHz+0x2c>
	// set as system clock and disable unused RC oscillator
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    34b2:	84 e0       	ldi	r24, 0x04	; 4
    34b4:	0e 94 fb 19 	call	0x33f6	; 0x33f6 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    34b8:	81 e0       	ldi	r24, 0x01	; 1
    34ba:	0e 94 eb 19 	call	0x33d6	; 0x33d6 <CLKSYS_Disable>
}
    34be:	08 95       	ret

000034c0 <set_16MHz>:

// produces consistent but inaccurate clock period.
void set_16MHz() {
	// select 32MHz Oscillator and prescale by 1/2
	CLKSYS_Enable(OSC_RC32MEN_bm);
    34c0:	e0 e5       	ldi	r30, 0x50	; 80
    34c2:	f0 e0       	ldi	r31, 0x00	; 0
    34c4:	80 81       	ld	r24, Z
    34c6:	82 60       	ori	r24, 0x02	; 2
    34c8:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_2_gc );
    34ca:	80 e0       	ldi	r24, 0x00	; 0
    34cc:	61 e0       	ldi	r22, 0x01	; 1
    34ce:	0e 94 f5 19 	call	0x33ea	; 0x33ea <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    34d2:	e0 e5       	ldi	r30, 0x50	; 80
    34d4:	f0 e0       	ldi	r31, 0x00	; 0
    34d6:	81 81       	ldd	r24, Z+1	; 0x01
    34d8:	81 ff       	sbrs	r24, 1
    34da:	fd cf       	rjmp	.-6      	; 0x34d6 <set_16MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    34dc:	81 e0       	ldi	r24, 0x01	; 1
    34de:	0e 94 fb 19 	call	0x33f6	; 0x33f6 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    34e2:	81 e0       	ldi	r24, 0x01	; 1
    34e4:	0e 94 eb 19 	call	0x33d6	; 0x33d6 <CLKSYS_Disable>
	
}
    34e8:	08 95       	ret

000034ea <set_32MHz>:


// produces consistent but inaccurate clock period.
void set_32MHz() {
	// select 32MHz Oscillator and prescale by 1
	CLKSYS_Enable(OSC_RC32MEN_bm);
    34ea:	e0 e5       	ldi	r30, 0x50	; 80
    34ec:	f0 e0       	ldi	r31, 0x00	; 0
    34ee:	80 81       	ld	r24, Z
    34f0:	82 60       	ori	r24, 0x02	; 2
    34f2:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    34f4:	80 e0       	ldi	r24, 0x00	; 0
    34f6:	60 e0       	ldi	r22, 0x00	; 0
    34f8:	0e 94 f5 19 	call	0x33ea	; 0x33ea <CLKSYS_Prescalers_Config>
	// wait for signal to stabilize
	do {} while (CLKSYS_IsReady(OSC_RC32MRDY_bm) == 0);
    34fc:	e0 e5       	ldi	r30, 0x50	; 80
    34fe:	f0 e0       	ldi	r31, 0x00	; 0
    3500:	81 81       	ldd	r24, Z+1	; 0x01
    3502:	81 ff       	sbrs	r24, 1
    3504:	fd cf       	rjmp	.-6      	; 0x3500 <set_32MHz+0x16>
	
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC32M_gc );
    3506:	81 e0       	ldi	r24, 0x01	; 1
    3508:	0e 94 fb 19 	call	0x33f6	; 0x33f6 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC2MEN_bm );
    350c:	81 e0       	ldi	r24, 0x01	; 1
    350e:	0e 94 eb 19 	call	0x33d6	; 0x33d6 <CLKSYS_Disable>
	
}
    3512:	08 95       	ret

00003514 <portExCS>:


void portExCS(uint8_t write) {
	if (write) PORTA.OUTCLR = PIN3_bm;
    3514:	88 23       	and	r24, r24
    3516:	29 f0       	breq	.+10     	; 0x3522 <portExCS+0xe>
    3518:	88 e0       	ldi	r24, 0x08	; 8
    351a:	e0 e0       	ldi	r30, 0x00	; 0
    351c:	f6 e0       	ldi	r31, 0x06	; 6
    351e:	86 83       	std	Z+6, r24	; 0x06
    3520:	04 c0       	rjmp	.+8      	; 0x352a <portExCS+0x16>
	else {
		PORTA.OUTSET = PIN3_bm;
    3522:	88 e0       	ldi	r24, 0x08	; 8
    3524:	e0 e0       	ldi	r30, 0x00	; 0
    3526:	f6 e0       	ldi	r31, 0x06	; 6
    3528:	85 83       	std	Z+5, r24	; 0x05
    352a:	8a e6       	ldi	r24, 0x6A	; 106
    352c:	8a 95       	dec	r24
    352e:	f1 f7       	brne	.-4      	; 0x352c <portExCS+0x18>
    3530:	00 c0       	rjmp	.+0      	; 0x3532 <portExCS+0x1e>
	}
	_delay_us(10);
}
    3532:	08 95       	ret

00003534 <Ext1Power>:
}
*/


void Ext1Power(uint8_t on) {
	if (on) {
    3534:	88 23       	and	r24, r24
    3536:	79 f0       	breq	.+30     	; 0x3556 <Ext1Power+0x22>
		PORTF.DIRSET = PIN5_bm;
    3538:	e0 ea       	ldi	r30, 0xA0	; 160
    353a:	f6 e0       	ldi	r31, 0x06	; 6
    353c:	80 e2       	ldi	r24, 0x20	; 32
    353e:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN5_bm;
    3540:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3542:	8f ef       	ldi	r24, 0xFF	; 255
    3544:	93 ec       	ldi	r25, 0xC3	; 195
    3546:	a9 e0       	ldi	r26, 0x09	; 9
    3548:	81 50       	subi	r24, 0x01	; 1
    354a:	90 40       	sbci	r25, 0x00	; 0
    354c:	a0 40       	sbci	r26, 0x00	; 0
    354e:	e1 f7       	brne	.-8      	; 0x3548 <Ext1Power+0x14>
    3550:	00 c0       	rjmp	.+0      	; 0x3552 <Ext1Power+0x1e>
    3552:	00 00       	nop
    3554:	08 95       	ret
		//PortEx_DIRSET(PIN3_bm, PS_BANKB);
		//PortEx_OUTSET(PIN3_bm, PS_BANKB);  //write protect SDHC
		_delay_ms(100);
		
	} else {
		PORTF.OUTCLR = PIN5_bm;
    3556:	e0 ea       	ldi	r30, 0xA0	; 160
    3558:	f6 e0       	ldi	r31, 0x06	; 6
    355a:	80 e2       	ldi	r24, 0x20	; 32
    355c:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN5_bm;
    355e:	82 83       	std	Z+2, r24	; 0x02
    3560:	08 95       	ret

00003562 <Ext2Power>:
		//PortEx_OUTCLR(PIN3_bm, PS_BANKB);  //no need to write protect SDHC
	}
}

void Ext2Power(uint8_t on) {
	if (on) {
    3562:	88 23       	and	r24, r24
    3564:	79 f0       	breq	.+30     	; 0x3584 <Ext2Power+0x22>
		PORTF.DIRSET = PIN6_bm;
    3566:	e0 ea       	ldi	r30, 0xA0	; 160
    3568:	f6 e0       	ldi	r31, 0x06	; 6
    356a:	80 e4       	ldi	r24, 0x40	; 64
    356c:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN6_bm;
    356e:	85 83       	std	Z+5, r24	; 0x05
    3570:	8f ef       	ldi	r24, 0xFF	; 255
    3572:	93 ec       	ldi	r25, 0xC3	; 195
    3574:	a9 e0       	ldi	r26, 0x09	; 9
    3576:	81 50       	subi	r24, 0x01	; 1
    3578:	90 40       	sbci	r25, 0x00	; 0
    357a:	a0 40       	sbci	r26, 0x00	; 0
    357c:	e1 f7       	brne	.-8      	; 0x3576 <Ext2Power+0x14>
    357e:	00 c0       	rjmp	.+0      	; 0x3580 <Ext2Power+0x1e>
    3580:	00 00       	nop
    3582:	08 95       	ret
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN6_bm;
    3584:	e0 ea       	ldi	r30, 0xA0	; 160
    3586:	f6 e0       	ldi	r31, 0x06	; 6
    3588:	80 e4       	ldi	r24, 0x40	; 64
    358a:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN6_bm;
    358c:	82 83       	std	Z+2, r24	; 0x02
    358e:	08 95       	ret

00003590 <HVPower>:
	}
}

void HVPower(uint8_t on) {
	if (on) {
    3590:	88 23       	and	r24, r24
    3592:	79 f0       	breq	.+30     	; 0x35b2 <HVPower+0x22>
		PORTF.DIRSET = PIN7_bm;
    3594:	e0 ea       	ldi	r30, 0xA0	; 160
    3596:	f6 e0       	ldi	r31, 0x06	; 6
    3598:	80 e8       	ldi	r24, 0x80	; 128
    359a:	81 83       	std	Z+1, r24	; 0x01
		PORTF.OUTSET = PIN7_bm;
    359c:	85 83       	std	Z+5, r24	; 0x05
    359e:	8f ef       	ldi	r24, 0xFF	; 255
    35a0:	93 ec       	ldi	r25, 0xC3	; 195
    35a2:	a9 e0       	ldi	r26, 0x09	; 9
    35a4:	81 50       	subi	r24, 0x01	; 1
    35a6:	90 40       	sbci	r25, 0x00	; 0
    35a8:	a0 40       	sbci	r26, 0x00	; 0
    35aa:	e1 f7       	brne	.-8      	; 0x35a4 <HVPower+0x14>
    35ac:	00 c0       	rjmp	.+0      	; 0x35ae <HVPower+0x1e>
    35ae:	00 00       	nop
    35b0:	05 c0       	rjmp	.+10     	; 0x35bc <HVPower+0x2c>
		_delay_ms(100);
	} else {
		PORTF.OUTCLR = PIN7_bm;
    35b2:	e0 ea       	ldi	r30, 0xA0	; 160
    35b4:	f6 e0       	ldi	r31, 0x06	; 6
    35b6:	80 e8       	ldi	r24, 0x80	; 128
    35b8:	86 83       	std	Z+6, r24	; 0x06
		PORTF.DIRCLR = PIN7_bm;
    35ba:	82 83       	std	Z+2, r24	; 0x02
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    35bc:	af e3       	ldi	r26, 0x3F	; 63
    35be:	bf e1       	ldi	r27, 0x1F	; 31
    35c0:	11 97       	sbiw	r26, 0x01	; 1
    35c2:	f1 f7       	brne	.-4      	; 0x35c0 <HVPower+0x30>
    35c4:	00 c0       	rjmp	.+0      	; 0x35c6 <HVPower+0x36>
    35c6:	00 00       	nop
	}
	_delay_us(1000);
}
    35c8:	08 95       	ret

000035ca <lowerMuxCS>:


void lowerMuxCS(uint8_t write) {
	// take IO15(PE4) low to enable write
	if (write) PORTE.OUTCLR = PIN4_bm;
    35ca:	88 23       	and	r24, r24
    35cc:	29 f0       	breq	.+10     	; 0x35d8 <lowerMuxCS+0xe>
    35ce:	80 e1       	ldi	r24, 0x10	; 16
    35d0:	e0 e8       	ldi	r30, 0x80	; 128
    35d2:	f6 e0       	ldi	r31, 0x06	; 6
    35d4:	86 83       	std	Z+6, r24	; 0x06
    35d6:	08 95       	ret
	else PORTE.OUTSET = PIN4_bm;
    35d8:	80 e1       	ldi	r24, 0x10	; 16
    35da:	e0 e8       	ldi	r30, 0x80	; 128
    35dc:	f6 e0       	ldi	r31, 0x06	; 6
    35de:	85 83       	std	Z+5, r24	; 0x05
    35e0:	08 95       	ret

000035e2 <upperMuxCS>:
}
void upperMuxCS(uint8_t write) {
	// take IO16(PC
	if (write) PORTC.OUTCLR = PIN1_bm;
    35e2:	88 23       	and	r24, r24
    35e4:	29 f0       	breq	.+10     	; 0x35f0 <upperMuxCS+0xe>
    35e6:	82 e0       	ldi	r24, 0x02	; 2
    35e8:	e0 e4       	ldi	r30, 0x40	; 64
    35ea:	f6 e0       	ldi	r31, 0x06	; 6
    35ec:	86 83       	std	Z+6, r24	; 0x06
    35ee:	08 95       	ret
	else PORTC.OUTSET = PIN1_bm;
    35f0:	82 e0       	ldi	r24, 0x02	; 2
    35f2:	e0 e4       	ldi	r30, 0x40	; 64
    35f4:	f6 e0       	ldi	r31, 0x06	; 6
    35f6:	85 83       	std	Z+5, r24	; 0x05
    35f8:	08 95       	ret

000035fa <SPIInit>:
}

void SPIInit(uint8_t mode) {
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    35fa:	e0 e4       	ldi	r30, 0x40	; 64
    35fc:	f6 e0       	ldi	r31, 0x06	; 6
    35fe:	90 e1       	ldi	r25, 0x10	; 16
    3600:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    3602:	28 e3       	ldi	r18, 0x38	; 56
    3604:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    3606:	95 83       	std	Z+5, r25	; 0x05

	// init SPI
	SPIC.CTRL =	SPI_PRESCALER |  // set clock speed
    3608:	81 65       	ori	r24, 0x51	; 81
    360a:	a0 ec       	ldi	r26, 0xC0	; 192
    360c:	b8 e0       	ldi	r27, 0x08	; 8
    360e:	8c 93       	st	X, r24
	            0x00 |  // set data order msb first
	            SPI_MASTER_bm | // set SPI master
	            mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    3610:	11 96       	adiw	r26, 0x01	; 1
    3612:	1c 92       	st	X, r1
    3614:	11 97       	sbiw	r26, 0x01	; 1

 	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    3616:	80 ea       	ldi	r24, 0xA0	; 160
    3618:	81 83       	std	Z+1, r24	; 0x01

	
}
    361a:	08 95       	ret

0000361c <SPIInit2>:
//use this if using a prescalar
void SPIInit2(uint8_t mode, uint8_t prescalar) {
	// init SPI SS pin
	PORTC.DIRSET = PIN4_bm;
    361c:	e0 e4       	ldi	r30, 0x40	; 64
    361e:	f6 e0       	ldi	r31, 0x06	; 6
    3620:	90 e1       	ldi	r25, 0x10	; 16
    3622:	91 83       	std	Z+1, r25	; 0x01
	PORTC.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;
    3624:	28 e3       	ldi	r18, 0x38	; 56
    3626:	24 8b       	std	Z+20, r18	; 0x14
	PORTC.OUTSET = PIN4_bm;
    3628:	95 83       	std	Z+5, r25	; 0x05
	

	// init SPI
	SPIC.CTRL =	prescalar |  // set clock speed
    362a:	80 65       	ori	r24, 0x50	; 80
    362c:	68 2b       	or	r22, r24
    362e:	a0 ec       	ldi	r26, 0xC0	; 192
    3630:	b8 e0       	ldi	r27, 0x08	; 8
    3632:	6c 93       	st	X, r22
	0x00 |  // set data order msb first
	SPI_MASTER_bm | // set SPI master
	mode; // set SPI mode

	// disable SPI Interrupts
	SPIC.INTCTRL = SPI_INTLVL_OFF_gc;
    3634:	11 96       	adiw	r26, 0x01	; 1
    3636:	1c 92       	st	X, r1
    3638:	11 97       	sbiw	r26, 0x01	; 1

	// set SPI-MOSI and SPI-SCK as output
	PORTC.DIRSET  = PIN5_bm | PIN7_bm;
    363a:	80 ea       	ldi	r24, 0xA0	; 160
    363c:	81 83       	std	Z+1, r24	; 0x01
}
    363e:	08 95       	ret

00003640 <SPICS>:

void SPICS(uint8_t enable) {
	if (enable) PORTC.OUTCLR = PIN4_bm;
    3640:	88 23       	and	r24, r24
    3642:	29 f0       	breq	.+10     	; 0x364e <SPICS+0xe>
    3644:	80 e1       	ldi	r24, 0x10	; 16
    3646:	e0 e4       	ldi	r30, 0x40	; 64
    3648:	f6 e0       	ldi	r31, 0x06	; 6
    364a:	86 83       	std	Z+6, r24	; 0x06
    364c:	08 95       	ret
	else {
		PORTC.OUTSET = PIN4_bm;
    364e:	80 e1       	ldi	r24, 0x10	; 16
    3650:	e0 e4       	ldi	r30, 0x40	; 64
    3652:	f6 e0       	ldi	r31, 0x06	; 6
    3654:	85 83       	std	Z+5, r24	; 0x05
    3656:	08 95       	ret

00003658 <SPIDisable>:
	}	
}

void SPIDisable() {
	PORTC.OUTSET = PIN4_bm;
    3658:	e0 e4       	ldi	r30, 0x40	; 64
    365a:	f6 e0       	ldi	r31, 0x06	; 6
    365c:	80 e1       	ldi	r24, 0x10	; 16
    365e:	85 83       	std	Z+5, r24	; 0x05
	SPIC.CTRL = 0x00;
    3660:	10 92 c0 08 	sts	0x08C0, r1
	PORTC.OUTCLR = PIN4_bm;
    3664:	86 83       	std	Z+6, r24	; 0x06
	PORTC.DIRCLR = PIN4_bm | PIN5_bm | PIN7_bm;
    3666:	80 eb       	ldi	r24, 0xB0	; 176
    3668:	82 83       	std	Z+2, r24	; 0x02

}
    366a:	08 95       	ret

0000366c <PortEx_OUTCLR>:
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    366c:	cf 93       	push	r28
    366e:	df 93       	push	r29
    3670:	c8 2f       	mov	r28, r24
    3672:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
    3674:	80 e0       	ldi	r24, 0x00	; 0
    3676:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
	SPICS(TRUE);
    367a:	81 e0       	ldi	r24, 0x01	; 1
    367c:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	portExCS(TRUE);
    3680:	81 e0       	ldi	r24, 0x01	; 1
    3682:	0e 94 8a 1a 	call	0x3514	; 0x3514 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
    3686:	dd 23       	and	r29, r29
    3688:	89 f0       	breq	.+34     	; 0x36ac <PortEx_OUTCLR+0x40>
    368a:	80 91 b9 23 	lds	r24, 0x23B9
    368e:	c0 95       	com	r28
    3690:	c8 23       	and	r28, r24
    3692:	c0 93 b9 23 	sts	0x23B9, r28
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
	
	SPIBuffer[0] = PS_WRITE;
    3696:	80 e4       	ldi	r24, 0x40	; 64
    3698:	80 93 47 50 	sts	0x5047, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
    369c:	84 e1       	ldi	r24, 0x14	; 20
    369e:	80 93 48 50 	sts	0x5048, r24
		SPIBuffer[2] = bankA_OUT;
    36a2:	80 91 b9 23 	lds	r24, 0x23B9
    36a6:	80 93 49 50 	sts	0x5049, r24
    36aa:	10 c0       	rjmp	.+32     	; 0x36cc <PortEx_OUTCLR+0x60>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (bankA_OUT & ~pins);
	else bankB_OUT = (uint8_t) (bankB_OUT & ~pins);
    36ac:	80 91 5e 50 	lds	r24, 0x505E
    36b0:	c0 95       	com	r28
    36b2:	c8 23       	and	r28, r24
    36b4:	c0 93 5e 50 	sts	0x505E, r28
	
	SPIBuffer[0] = PS_WRITE;
    36b8:	80 e4       	ldi	r24, 0x40	; 64
    36ba:	80 93 47 50 	sts	0x5047, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
    36be:	85 e1       	ldi	r24, 0x15	; 21
    36c0:	80 93 48 50 	sts	0x5048, r24
		SPIBuffer[2] = bankB_OUT; 
    36c4:	80 91 5e 50 	lds	r24, 0x505E
    36c8:	80 93 49 50 	sts	0x5049, r24
	portExCS(FALSE);
	SPIDisable();
}


void PortEx_OUTCLR(uint8_t pins, uint8_t bank) {
    36cc:	80 e0       	ldi	r24, 0x00	; 0
    36ce:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    36d0:	27 e4       	ldi	r18, 0x47	; 71
    36d2:	30 e5       	ldi	r19, 0x50	; 80
    36d4:	a0 ec       	ldi	r26, 0xC0	; 192
    36d6:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    36d8:	c3 e5       	ldi	r28, 0x53	; 83
    36da:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    36dc:	f9 01       	movw	r30, r18
    36de:	e8 0f       	add	r30, r24
    36e0:	f9 1f       	adc	r31, r25
    36e2:	40 81       	ld	r20, Z
    36e4:	13 96       	adiw	r26, 0x03	; 3
    36e6:	4c 93       	st	X, r20
    36e8:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    36ea:	12 96       	adiw	r26, 0x02	; 2
    36ec:	4c 91       	ld	r20, X
    36ee:	12 97       	sbiw	r26, 0x02	; 2
    36f0:	44 23       	and	r20, r20
    36f2:	dc f7       	brge	.-10     	; 0x36ea <PortEx_OUTCLR+0x7e>
		SPIBuffer[12] = SPIC.DATA;
    36f4:	13 96       	adiw	r26, 0x03	; 3
    36f6:	4c 91       	ld	r20, X
    36f8:	13 97       	sbiw	r26, 0x03	; 3
    36fa:	48 83       	st	Y, r20
    36fc:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    36fe:	83 30       	cpi	r24, 0x03	; 3
    3700:	91 05       	cpc	r25, r1
    3702:	61 f7       	brne	.-40     	; 0x36dc <PortEx_OUTCLR+0x70>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    3704:	80 e0       	ldi	r24, 0x00	; 0
    3706:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	portExCS(FALSE);
    370a:	80 e0       	ldi	r24, 0x00	; 0
    370c:	0e 94 8a 1a 	call	0x3514	; 0x3514 <portExCS>
	SPIDisable();
    3710:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>
}
    3714:	df 91       	pop	r29
    3716:	cf 91       	pop	r28
    3718:	08 95       	ret

0000371a <PortEx_OUTSET>:
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    371a:	cf 93       	push	r28
    371c:	df 93       	push	r29
    371e:	c8 2f       	mov	r28, r24
    3720:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
    3722:	80 e0       	ldi	r24, 0x00	; 0
    3724:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
	SPICS(TRUE);
    3728:	81 e0       	ldi	r24, 0x01	; 1
    372a:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	portExCS(TRUE);
    372e:	81 e0       	ldi	r24, 0x01	; 1
    3730:	0e 94 8a 1a 	call	0x3514	; 0x3514 <portExCS>
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
    3734:	dd 23       	and	r29, r29
    3736:	81 f0       	breq	.+32     	; 0x3758 <PortEx_OUTSET+0x3e>
    3738:	80 91 b9 23 	lds	r24, 0x23B9
    373c:	c8 2b       	or	r28, r24
    373e:	c0 93 b9 23 	sts	0x23B9, r28
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
	
	SPIBuffer[0] = PS_WRITE;
    3742:	80 e4       	ldi	r24, 0x40	; 64
    3744:	80 93 47 50 	sts	0x5047, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
    3748:	84 e1       	ldi	r24, 0x14	; 20
    374a:	80 93 48 50 	sts	0x5048, r24
		SPIBuffer[2] = bankA_OUT;
    374e:	80 91 b9 23 	lds	r24, 0x23B9
    3752:	80 93 49 50 	sts	0x5049, r24
    3756:	0f c0       	rjmp	.+30     	; 0x3776 <PortEx_OUTSET+0x5c>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_OUT = (uint8_t) (pins | bankA_OUT);
	else bankB_OUT = (uint8_t) (pins | bankB_OUT);
    3758:	80 91 5e 50 	lds	r24, 0x505E
    375c:	c8 2b       	or	r28, r24
    375e:	c0 93 5e 50 	sts	0x505E, r28
	
	SPIBuffer[0] = PS_WRITE;
    3762:	80 e4       	ldi	r24, 0x40	; 64
    3764:	80 93 47 50 	sts	0x5047, r24
	if(bank) {
		SPIBuffer[1]=PS_OLATA;
		SPIBuffer[2] = bankA_OUT;
	} else {
		SPIBuffer[1]=PS_OLATB;
    3768:	85 e1       	ldi	r24, 0x15	; 21
    376a:	80 93 48 50 	sts	0x5048, r24
		SPIBuffer[2] = bankB_OUT; 
    376e:	80 91 5e 50 	lds	r24, 0x505E
    3772:	80 93 49 50 	sts	0x5049, r24
	SPICS(FALSE);
	portExCS(FALSE);
	SPIDisable();
}

void PortEx_OUTSET(uint8_t pins, uint8_t bank) {
    3776:	80 e0       	ldi	r24, 0x00	; 0
    3778:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    377a:	27 e4       	ldi	r18, 0x47	; 71
    377c:	30 e5       	ldi	r19, 0x50	; 80
    377e:	a0 ec       	ldi	r26, 0xC0	; 192
    3780:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    3782:	c3 e5       	ldi	r28, 0x53	; 83
    3784:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3786:	f9 01       	movw	r30, r18
    3788:	e8 0f       	add	r30, r24
    378a:	f9 1f       	adc	r31, r25
    378c:	40 81       	ld	r20, Z
    378e:	13 96       	adiw	r26, 0x03	; 3
    3790:	4c 93       	st	X, r20
    3792:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3794:	12 96       	adiw	r26, 0x02	; 2
    3796:	4c 91       	ld	r20, X
    3798:	12 97       	sbiw	r26, 0x02	; 2
    379a:	44 23       	and	r20, r20
    379c:	dc f7       	brge	.-10     	; 0x3794 <PortEx_OUTSET+0x7a>
		SPIBuffer[12] = SPIC.DATA;
    379e:	13 96       	adiw	r26, 0x03	; 3
    37a0:	4c 91       	ld	r20, X
    37a2:	13 97       	sbiw	r26, 0x03	; 3
    37a4:	48 83       	st	Y, r20
    37a6:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_OLATB;
		SPIBuffer[2] = bankB_OUT; 
	}

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    37a8:	83 30       	cpi	r24, 0x03	; 3
    37aa:	91 05       	cpc	r25, r1
    37ac:	61 f7       	brne	.-40     	; 0x3786 <PortEx_OUTSET+0x6c>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    37ae:	80 e0       	ldi	r24, 0x00	; 0
    37b0:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	portExCS(FALSE);
    37b4:	80 e0       	ldi	r24, 0x00	; 0
    37b6:	0e 94 8a 1a 	call	0x3514	; 0x3514 <portExCS>
	SPIDisable();
    37ba:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>
}
    37be:	df 91       	pop	r29
    37c0:	cf 91       	pop	r28
    37c2:	08 95       	ret

000037c4 <PortEx_DIRCLR>:
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    37c4:	cf 93       	push	r28
    37c6:	df 93       	push	r29
    37c8:	c8 2f       	mov	r28, r24
    37ca:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
    37cc:	80 e0       	ldi	r24, 0x00	; 0
    37ce:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
	SPICS(TRUE);
    37d2:	81 e0       	ldi	r24, 0x01	; 1
    37d4:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	portExCS(TRUE);
    37d8:	81 e0       	ldi	r24, 0x01	; 1
    37da:	0e 94 8a 1a 	call	0x3514	; 0x3514 <portExCS>
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
    37de:	dd 23       	and	r29, r29
    37e0:	89 f0       	breq	.+34     	; 0x3804 <PortEx_DIRCLR+0x40>
    37e2:	80 91 56 50 	lds	r24, 0x5056
    37e6:	80 95       	com	r24
    37e8:	c8 23       	and	r28, r24
    37ea:	c0 93 56 50 	sts	0x5056, r28
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
    37ee:	80 e4       	ldi	r24, 0x40	; 64
    37f0:	80 93 47 50 	sts	0x5047, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
    37f4:	10 92 48 50 	sts	0x5048, r1
		SPIBuffer[2] = ~bankA_DIR; 
    37f8:	80 91 56 50 	lds	r24, 0x5056
    37fc:	80 95       	com	r24
    37fe:	80 93 49 50 	sts	0x5049, r24
    3802:	11 c0       	rjmp	.+34     	; 0x3826 <PortEx_DIRCLR+0x62>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);
	
	if(bank) bankA_DIR = (uint8_t) (pins & ~bankA_DIR);
	else bankB_DIR = (uint8_t) (pins & ~bankB_DIR);
    3804:	80 91 b0 50 	lds	r24, 0x50B0
    3808:	80 95       	com	r24
    380a:	c8 23       	and	r28, r24
    380c:	c0 93 b0 50 	sts	0x50B0, r28
	
	SPIBuffer[0] = PS_WRITE;
    3810:	80 e4       	ldi	r24, 0x40	; 64
    3812:	80 93 47 50 	sts	0x5047, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
    3816:	81 e0       	ldi	r24, 0x01	; 1
    3818:	80 93 48 50 	sts	0x5048, r24
		SPIBuffer[2] = ~bankB_DIR;
    381c:	80 91 b0 50 	lds	r24, 0x50B0
    3820:	80 95       	com	r24
    3822:	80 93 49 50 	sts	0x5049, r24
}

// 1 in bitmap sets the selected pins to input
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRCLR(uint8_t pins, uint8_t bank) {
    3826:	80 e0       	ldi	r24, 0x00	; 0
    3828:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    382a:	27 e4       	ldi	r18, 0x47	; 71
    382c:	30 e5       	ldi	r19, 0x50	; 80
    382e:	a0 ec       	ldi	r26, 0xC0	; 192
    3830:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
    3832:	c3 e5       	ldi	r28, 0x53	; 83
    3834:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    3836:	f9 01       	movw	r30, r18
    3838:	e8 0f       	add	r30, r24
    383a:	f9 1f       	adc	r31, r25
    383c:	40 81       	ld	r20, Z
    383e:	13 96       	adiw	r26, 0x03	; 3
    3840:	4c 93       	st	X, r20
    3842:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    3844:	12 96       	adiw	r26, 0x02	; 2
    3846:	4c 91       	ld	r20, X
    3848:	12 97       	sbiw	r26, 0x02	; 2
    384a:	44 23       	and	r20, r20
    384c:	dc f7       	brge	.-10     	; 0x3844 <PortEx_DIRCLR+0x80>
		SPIBuffer[12] = SPIC.DATA;
    384e:	13 96       	adiw	r26, 0x03	; 3
    3850:	4c 91       	ld	r20, X
    3852:	13 97       	sbiw	r26, 0x03	; 3
    3854:	48 83       	st	Y, r20
    3856:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3858:	83 30       	cpi	r24, 0x03	; 3
    385a:	91 05       	cpc	r25, r1
    385c:	61 f7       	brne	.-40     	; 0x3836 <PortEx_DIRCLR+0x72>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));
		SPIBuffer[12] = SPIC.DATA;
	}

	SPICS(FALSE);
    385e:	80 e0       	ldi	r24, 0x00	; 0
    3860:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	portExCS(FALSE);
    3864:	80 e0       	ldi	r24, 0x00	; 0
    3866:	0e 94 8a 1a 	call	0x3514	; 0x3514 <portExCS>
	SPIDisable();
    386a:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>
}
    386e:	df 91       	pop	r29
    3870:	cf 91       	pop	r28
    3872:	08 95       	ret

00003874 <PortEx_DIRSET>:
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    3874:	cf 93       	push	r28
    3876:	df 93       	push	r29
    3878:	c8 2f       	mov	r28, r24
    387a:	d6 2f       	mov	r29, r22
	SPIInit(PS_SPI_MODE);
    387c:	80 e0       	ldi	r24, 0x00	; 0
    387e:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
	SPICS(TRUE);
    3882:	81 e0       	ldi	r24, 0x01	; 1
    3884:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	portExCS(TRUE);
    3888:	81 e0       	ldi	r24, 0x01	; 1
    388a:	0e 94 8a 1a 	call	0x3514	; 0x3514 <portExCS>

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
    388e:	dd 23       	and	r29, r29
    3890:	81 f0       	breq	.+32     	; 0x38b2 <PortEx_DIRSET+0x3e>
    3892:	80 91 56 50 	lds	r24, 0x5056
    3896:	c8 2b       	or	r28, r24
    3898:	c0 93 56 50 	sts	0x5056, r28
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
	
	SPIBuffer[0] = PS_WRITE;
    389c:	80 e4       	ldi	r24, 0x40	; 64
    389e:	80 93 47 50 	sts	0x5047, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
    38a2:	10 92 48 50 	sts	0x5048, r1
		SPIBuffer[2] = ~bankA_DIR; 
    38a6:	80 91 56 50 	lds	r24, 0x5056
    38aa:	80 95       	com	r24
    38ac:	80 93 49 50 	sts	0x5049, r24
    38b0:	10 c0       	rjmp	.+32     	; 0x38d2 <PortEx_DIRSET+0x5e>
	SPIInit(PS_SPI_MODE);
	SPICS(TRUE);
	portExCS(TRUE);

	if(bank) bankA_DIR = (uint8_t) (pins | bankA_DIR);
	else bankB_DIR = (uint8_t) (pins | bankB_DIR);
    38b2:	80 91 b0 50 	lds	r24, 0x50B0
    38b6:	c8 2b       	or	r28, r24
    38b8:	c0 93 b0 50 	sts	0x50B0, r28
	
	SPIBuffer[0] = PS_WRITE;
    38bc:	80 e4       	ldi	r24, 0x40	; 64
    38be:	80 93 47 50 	sts	0x5047, r24
	if(bank) {
		SPIBuffer[1]=PS_IODIRA;
		SPIBuffer[2] = ~bankA_DIR; 
	} else {
		SPIBuffer[1]=PS_IODIRB;
    38c2:	81 e0       	ldi	r24, 0x01	; 1
    38c4:	80 93 48 50 	sts	0x5048, r24
		SPIBuffer[2] = ~bankB_DIR;
    38c8:	80 91 b0 50 	lds	r24, 0x50B0
    38cc:	80 95       	com	r24
    38ce:	80 93 49 50 	sts	0x5049, r24
}

// 1 in bitmap sets the selected pins to output
// Port Expander must be powered on (VDC-2)
// all other pins are unaffected
void PortEx_DIRSET(uint8_t pins, uint8_t bank) {
    38d2:	80 e0       	ldi	r24, 0x00	; 0
    38d4:	90 e0       	ldi	r25, 0x00	; 0
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    38d6:	27 e4       	ldi	r18, 0x47	; 71
    38d8:	30 e5       	ldi	r19, 0x50	; 80
    38da:	a0 ec       	ldi	r26, 0xC0	; 192
    38dc:	b8 e0       	ldi	r27, 0x08	; 8
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    38de:	c3 e5       	ldi	r28, 0x53	; 83
    38e0:	d0 e5       	ldi	r29, 0x50	; 80
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
		SPIC.DATA = SPIBuffer[bufIndex];
    38e2:	f9 01       	movw	r30, r18
    38e4:	e8 0f       	add	r30, r24
    38e6:	f9 1f       	adc	r31, r25
    38e8:	40 81       	ld	r20, Z
    38ea:	13 96       	adiw	r26, 0x03	; 3
    38ec:	4c 93       	st	X, r20
    38ee:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
    38f0:	12 96       	adiw	r26, 0x02	; 2
    38f2:	4c 91       	ld	r20, X
    38f4:	12 97       	sbiw	r26, 0x02	; 2
    38f6:	44 23       	and	r20, r20
    38f8:	dc f7       	brge	.-10     	; 0x38f0 <PortEx_DIRSET+0x7c>
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
    38fa:	13 96       	adiw	r26, 0x03	; 3
    38fc:	4c 91       	ld	r20, X
    38fe:	13 97       	sbiw	r26, 0x03	; 3
    3900:	48 83       	st	Y, r20
    3902:	01 96       	adiw	r24, 0x01	; 1
	} else {
		SPIBuffer[1]=PS_IODIRB;
		SPIBuffer[2] = ~bankB_DIR;
	}	

	for(uint8_t bufIndex = 0; bufIndex < 3; bufIndex++) {
    3904:	83 30       	cpi	r24, 0x03	; 3
    3906:	91 05       	cpc	r25, r1
    3908:	61 f7       	brne	.-40     	; 0x38e2 <PortEx_DIRSET+0x6e>
		SPIC.DATA = SPIBuffer[bufIndex];
		while(!(SPIC.STATUS & SPI_IF_bm));	//wait for the byte to be sent
		SPIBuffer[12] = SPIC.DATA;			//read the data register to clear status flag
	}

	portExCS(FALSE);
    390a:	80 e0       	ldi	r24, 0x00	; 0
    390c:	0e 94 8a 1a 	call	0x3514	; 0x3514 <portExCS>
	SPICS(FALSE);
    3910:	80 e0       	ldi	r24, 0x00	; 0
    3912:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	SPIDisable();
    3916:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>


}
    391a:	df 91       	pop	r29
    391c:	cf 91       	pop	r28
    391e:	08 95       	ret

00003920 <readFRAM>:

}

// Read from FRAM
// FRAM power (VDC-2) must be on with CS_FRAM pulled high to write protect
void readFRAM (uint16_t numBytes) {
    3920:	0f 93       	push	r16
    3922:	1f 93       	push	r17
    3924:	cf 93       	push	r28
    3926:	df 93       	push	r29
    3928:	ec 01       	movw	r28, r24
	SPIInit(SPI_MODE_0_gc);
    392a:	80 e0       	ldi	r24, 0x00	; 0
    392c:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
	SPIC.CTRL = FR_SPI_CONFIG_gc;
    3930:	00 ec       	ldi	r16, 0xC0	; 192
    3932:	18 e0       	ldi	r17, 0x08	; 8
    3934:	80 ed       	ldi	r24, 0xD0	; 208
    3936:	f8 01       	movw	r30, r16
    3938:	80 83       	st	Z, r24
	SPICS(TRUE);
    393a:	81 e0       	ldi	r24, 0x01	; 1
    393c:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	PORTB.OUTCLR = PIN3_bm;  // pull down CS_FRAM to write enable
    3940:	88 e0       	ldi	r24, 0x08	; 8
    3942:	e0 e2       	ldi	r30, 0x20	; 32
    3944:	f6 e0       	ldi	r31, 0x06	; 6
    3946:	86 83       	std	Z+6, r24	; 0x06
	nop();
    3948:	00 00       	nop
								
	SPIC.DATA = FR_READ;
    394a:	83 e0       	ldi	r24, 0x03	; 3
    394c:	f8 01       	movw	r30, r16
    394e:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3950:	82 81       	ldd	r24, Z+2	; 0x02
    3952:	88 23       	and	r24, r24
    3954:	ec f7       	brge	.-6      	; 0x3950 <readFRAM+0x30>
	SPIBuffer[12] = SPIC.DATA;
    3956:	e0 ec       	ldi	r30, 0xC0	; 192
    3958:	f8 e0       	ldi	r31, 0x08	; 8
    395a:	83 81       	ldd	r24, Z+3	; 0x03
    395c:	80 93 53 50 	sts	0x5053, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 1);;
    3960:	80 91 3b 40 	lds	r24, 0x403B
    3964:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    3966:	82 81       	ldd	r24, Z+2	; 0x02
    3968:	88 23       	and	r24, r24
    396a:	ec f7       	brge	.-6      	; 0x3966 <readFRAM+0x46>
	SPIBuffer[12] = SPIC.DATA;
    396c:	e0 ec       	ldi	r30, 0xC0	; 192
    396e:	f8 e0       	ldi	r31, 0x08	; 8
    3970:	83 81       	ldd	r24, Z+3	; 0x03
    3972:	80 93 53 50 	sts	0x5053, r24
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
    3976:	80 91 3a 40 	lds	r24, 0x403A
    397a:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm));
    397c:	82 81       	ldd	r24, Z+2	; 0x02
    397e:	88 23       	and	r24, r24
    3980:	ec f7       	brge	.-6      	; 0x397c <readFRAM+0x5c>
	SPIBuffer[12] = SPIC.DATA;
    3982:	e0 ec       	ldi	r30, 0xC0	; 192
    3984:	f8 e0       	ldi	r31, 0x08	; 8
    3986:	83 81       	ldd	r24, Z+3	; 0x03
    3988:	80 93 53 50 	sts	0x5053, r24
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    398c:	20 97       	sbiw	r28, 0x00	; 0
    398e:	d1 f0       	breq	.+52     	; 0x39c4 <readFRAM+0xa4>
    3990:	80 e0       	ldi	r24, 0x00	; 0
    3992:	90 e0       	ldi	r25, 0x00	; 0
		SPIC.DATA = 0xAA;
    3994:	a0 ec       	ldi	r26, 0xC0	; 192
    3996:	b8 e0       	ldi	r27, 0x08	; 8
    3998:	5a ea       	ldi	r21, 0xAA	; 170
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
    399a:	22 ec       	ldi	r18, 0xC2	; 194
    399c:	33 e2       	ldi	r19, 0x23	; 35
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
		SPIC.DATA = 0xAA;
    399e:	13 96       	adiw	r26, 0x03	; 3
    39a0:	5c 93       	st	X, r21
    39a2:	13 97       	sbiw	r26, 0x03	; 3
		while(!(SPIC.STATUS & SPI_IF_bm));
    39a4:	12 96       	adiw	r26, 0x02	; 2
    39a6:	4c 91       	ld	r20, X
    39a8:	12 97       	sbiw	r26, 0x02	; 2
    39aa:	44 23       	and	r20, r20
    39ac:	dc f7       	brge	.-10     	; 0x39a4 <readFRAM+0x84>
		FRAMReadBuffer[i] = SPIC.DATA;
    39ae:	13 96       	adiw	r26, 0x03	; 3
    39b0:	4c 91       	ld	r20, X
    39b2:	13 97       	sbiw	r26, 0x03	; 3
    39b4:	f9 01       	movw	r30, r18
    39b6:	e8 0f       	add	r30, r24
    39b8:	f9 1f       	adc	r31, r25
    39ba:	40 83       	st	Z, r20
	SPIBuffer[12] = SPIC.DATA;
	SPIC.DATA = *(((uint8_t*)&FRAMAddress) + 0);;
	while(!(SPIC.STATUS & SPI_IF_bm));
	SPIBuffer[12] = SPIC.DATA;
	
	for(uint16_t i = 0; i < numBytes; i++) { 
    39bc:	01 96       	adiw	r24, 0x01	; 1
    39be:	8c 17       	cp	r24, r28
    39c0:	9d 07       	cpc	r25, r29
    39c2:	69 f7       	brne	.-38     	; 0x399e <readFRAM+0x7e>
		SPIC.DATA = 0xAA;
		while(!(SPIC.STATUS & SPI_IF_bm));
		FRAMReadBuffer[i] = SPIC.DATA;
	}

	PORTB.OUTSET = PIN3_bm;  // CS_FRAM write protect
    39c4:	88 e0       	ldi	r24, 0x08	; 8
    39c6:	e0 e2       	ldi	r30, 0x20	; 32
    39c8:	f6 e0       	ldi	r31, 0x06	; 6
    39ca:	85 83       	std	Z+5, r24	; 0x05
	SPICS(FALSE);
    39cc:	80 e0       	ldi	r24, 0x00	; 0
    39ce:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	SPIDisable();
    39d2:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>

}
    39d6:	df 91       	pop	r29
    39d8:	cf 91       	pop	r28
    39da:	1f 91       	pop	r17
    39dc:	0f 91       	pop	r16
    39de:	08 95       	ret

000039e0 <FRAMTest3Channel>:

void FRAMTest3Channel(void) {
    39e0:	8f 92       	push	r8
    39e2:	9f 92       	push	r9
    39e4:	af 92       	push	r10
    39e6:	bf 92       	push	r11
    39e8:	cf 92       	push	r12
    39ea:	df 92       	push	r13
    39ec:	ef 92       	push	r14
    39ee:	ff 92       	push	r15
    39f0:	0f 93       	push	r16
    39f2:	cf 93       	push	r28
    39f4:	df 93       	push	r29
    39f6:	00 d0       	rcall	.+0      	; 0x39f8 <FRAMTest3Channel+0x18>
    39f8:	cd b7       	in	r28, 0x3d	; 61
    39fa:	de b7       	in	r29, 0x3e	; 62
	uint8_t gains[3] = { GAIN_1_gc, GAIN_1_gc, GAIN_1_gc };
    39fc:	19 82       	std	Y+1, r1	; 0x01
    39fe:	1a 82       	std	Y+2, r1	; 0x02
    3a00:	1b 82       	std	Y+3, r1	; 0x03
			
	CO_collectSeismic3Channel(FILTER_CH_2AND6_bm | FILTER_CH_3AND7_bm |
    3a02:	8e ec       	ldi	r24, 0xCE	; 206
    3a04:	be 01       	movw	r22, r28
    3a06:	6f 5f       	subi	r22, 0xFF	; 255
    3a08:	7f 4f       	sbci	r23, 0xFF	; 255
    3a0a:	40 e0       	ldi	r20, 0x00	; 0
    3a0c:	25 e1       	ldi	r18, 0x15	; 21
    3a0e:	01 e0       	ldi	r16, 0x01	; 1
    3a10:	0f 2e       	mov	r0, r31
    3a12:	fd e0       	ldi	r31, 0x0D	; 13
    3a14:	ef 2e       	mov	r14, r31
    3a16:	ff 24       	eor	r15, r15
    3a18:	f0 2d       	mov	r31, r0
    3a1a:	0f 2e       	mov	r0, r31
    3a1c:	fe e0       	ldi	r31, 0x0E	; 14
    3a1e:	cf 2e       	mov	r12, r31
    3a20:	dd 24       	eor	r13, r13
    3a22:	f0 2d       	mov	r31, r0
    3a24:	0f 2e       	mov	r0, r31
    3a26:	ff e0       	ldi	r31, 0x0F	; 15
    3a28:	af 2e       	mov	r10, r31
    3a2a:	bb 24       	eor	r11, r11
    3a2c:	f0 2d       	mov	r31, r0
    3a2e:	88 24       	eor	r8, r8
    3a30:	99 24       	eor	r9, r9
    3a32:	68 94       	set
    3a34:	84 f8       	bld	r8, 4
    3a36:	0e 94 62 0e 	call	0x1cc4	; 0x1cc4 <CO_collectSeismic3Channel>
		FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
		gains, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    3a3a:	81 e0       	ldi	r24, 0x01	; 1
    3a3c:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
    3a40:	8f ec       	ldi	r24, 0xCF	; 207
    3a42:	97 e0       	ldi	r25, 0x07	; 7
    3a44:	01 97       	sbiw	r24, 0x01	; 1
    3a46:	f1 f7       	brne	.-4      	; 0x3a44 <FRAMTest3Channel+0x64>
    3a48:	00 c0       	rjmp	.+0      	; 0x3a4a <FRAMTest3Channel+0x6a>
    3a4a:	00 00       	nop
	_delay_us(250);
	
	calcChecksumFRAM();
    3a4c:	0e 94 88 09 	call	0x1310	; 0x1310 <calcChecksumFRAM>

	ADCPower(FALSE);
    3a50:	80 e0       	ldi	r24, 0x00	; 0
    3a52:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
	
}
    3a56:	23 96       	adiw	r28, 0x03	; 3
    3a58:	cd bf       	out	0x3d, r28	; 61
    3a5a:	de bf       	out	0x3e, r29	; 62
    3a5c:	df 91       	pop	r29
    3a5e:	cf 91       	pop	r28
    3a60:	0f 91       	pop	r16
    3a62:	ff 90       	pop	r15
    3a64:	ef 90       	pop	r14
    3a66:	df 90       	pop	r13
    3a68:	cf 90       	pop	r12
    3a6a:	bf 90       	pop	r11
    3a6c:	af 90       	pop	r10
    3a6e:	9f 90       	pop	r9
    3a70:	8f 90       	pop	r8
    3a72:	08 95       	ret

00003a74 <FRAMTest1Channel>:

void FRAMTest1Channel(void) {
    3a74:	8f 92       	push	r8
    3a76:	9f 92       	push	r9
    3a78:	af 92       	push	r10
    3a7a:	bf 92       	push	r11
    3a7c:	cf 92       	push	r12
    3a7e:	df 92       	push	r13
    3a80:	ef 92       	push	r14
    3a82:	0f 93       	push	r16

	CO_collectSeismic1Channel(ADC_CH_8_gc, FILTER_CH_4AND8_bm | FILTER_HP_0_bm | FILTER_LP_600_gc,
    3a84:	0f 92       	push	r0
    3a86:	0f 92       	push	r0
    3a88:	80 e1       	ldi	r24, 0x10	; 16
    3a8a:	90 e0       	ldi	r25, 0x00	; 0
    3a8c:	ed b7       	in	r30, 0x3d	; 61
    3a8e:	fe b7       	in	r31, 0x3e	; 62
    3a90:	81 83       	std	Z+1, r24	; 0x01
    3a92:	92 83       	std	Z+2, r25	; 0x02
    3a94:	87 e0       	ldi	r24, 0x07	; 7
    3a96:	68 ec       	ldi	r22, 0xC8	; 200
    3a98:	40 e0       	ldi	r20, 0x00	; 0
    3a9a:	20 e0       	ldi	r18, 0x00	; 0
    3a9c:	05 e1       	ldi	r16, 0x15	; 21
    3a9e:	ee 24       	eor	r14, r14
    3aa0:	e3 94       	inc	r14
    3aa2:	0f 2e       	mov	r0, r31
    3aa4:	fd e0       	ldi	r31, 0x0D	; 13
    3aa6:	cf 2e       	mov	r12, r31
    3aa8:	dd 24       	eor	r13, r13
    3aaa:	f0 2d       	mov	r31, r0
    3aac:	0f 2e       	mov	r0, r31
    3aae:	fe e0       	ldi	r31, 0x0E	; 14
    3ab0:	af 2e       	mov	r10, r31
    3ab2:	bb 24       	eor	r11, r11
    3ab4:	f0 2d       	mov	r31, r0
    3ab6:	0f 2e       	mov	r0, r31
    3ab8:	ff e0       	ldi	r31, 0x0F	; 15
    3aba:	8f 2e       	mov	r8, r31
    3abc:	99 24       	eor	r9, r9
    3abe:	f0 2d       	mov	r31, r0
    3ac0:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <CO_collectSeismic1Channel>
	GAIN_1_gc, SSPS_SE_64K_gc, 21, TRUE, 13, 14, 15, 16);
	ADCPower(TRUE);
    3ac4:	0f 90       	pop	r0
    3ac6:	0f 90       	pop	r0
    3ac8:	81 e0       	ldi	r24, 0x01	; 1
    3aca:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
    3ace:	8f ec       	ldi	r24, 0xCF	; 207
    3ad0:	97 e0       	ldi	r25, 0x07	; 7
    3ad2:	01 97       	sbiw	r24, 0x01	; 1
    3ad4:	f1 f7       	brne	.-4      	; 0x3ad2 <FRAMTest1Channel+0x5e>
    3ad6:	00 c0       	rjmp	.+0      	; 0x3ad8 <FRAMTest1Channel+0x64>
    3ad8:	00 00       	nop
	_delay_us(250);
	
	calcChecksumFRAM();
    3ada:	0e 94 88 09 	call	0x1310	; 0x1310 <calcChecksumFRAM>

	ADCPower(FALSE);
    3ade:	80 e0       	ldi	r24, 0x00	; 0
    3ae0:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>

}
    3ae4:	0f 91       	pop	r16
    3ae6:	ef 90       	pop	r14
    3ae8:	df 90       	pop	r13
    3aea:	cf 90       	pop	r12
    3aec:	bf 90       	pop	r11
    3aee:	af 90       	pop	r10
    3af0:	9f 90       	pop	r9
    3af2:	8f 90       	pop	r8
    3af4:	08 95       	ret

00003af6 <FRAMWriteKnownsCheck>:


void FRAMWriteKnownsCheck() {
	FRAMWriteKnowns();
    3af6:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <FRAMWriteKnowns>
	ADCPower(TRUE);
    3afa:	81 e0       	ldi	r24, 0x01	; 1
    3afc:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
    3b00:	8f ec       	ldi	r24, 0xCF	; 207
    3b02:	97 e0       	ldi	r25, 0x07	; 7
    3b04:	01 97       	sbiw	r24, 0x01	; 1
    3b06:	f1 f7       	brne	.-4      	; 0x3b04 <FRAMWriteKnownsCheck+0xe>
    3b08:	00 c0       	rjmp	.+0      	; 0x3b0a <FRAMWriteKnownsCheck+0x14>
    3b0a:	00 00       	nop

	_delay_us(250);
	calcChecksumFRAM();
    3b0c:	0e 94 88 09 	call	0x1310	; 0x1310 <calcChecksumFRAM>

	ADCPower(FALSE);
    3b10:	80 e0       	ldi	r24, 0x00	; 0
    3b12:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>

}
    3b16:	08 95       	ret

00003b18 <checkMote>:

//random function for testing stuff	
void checkMote(){
	ADCPower(TRUE);
    3b18:	81 e0       	ldi	r24, 0x01	; 1
    3b1a:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
	Ext1Power(TRUE);
    3b1e:	81 e0       	ldi	r24, 0x01	; 1
    3b20:	0e 94 9a 1a 	call	0x3534	; 0x3534 <Ext1Power>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3b24:	8f ef       	ldi	r24, 0xFF	; 255
    3b26:	93 ec       	ldi	r25, 0xC3	; 195
    3b28:	a9 e0       	ldi	r26, 0x09	; 9
    3b2a:	81 50       	subi	r24, 0x01	; 1
    3b2c:	90 40       	sbci	r25, 0x00	; 0
    3b2e:	a0 40       	sbci	r26, 0x00	; 0
    3b30:	e1 f7       	brne	.-8      	; 0x3b2a <checkMote+0x12>
    3b32:	00 c0       	rjmp	.+0      	; 0x3b34 <checkMote+0x1c>
    3b34:	00 00       	nop
	_delay_ms(100);
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    3b36:	88 e0       	ldi	r24, 0x08	; 8
    3b38:	60 e0       	ldi	r22, 0x00	; 0
    3b3a:	0e 94 3a 1c 	call	0x3874	; 0x3874 <PortEx_DIRSET>
	while(1){
		PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    3b3e:	88 e0       	ldi	r24, 0x08	; 8
    3b40:	60 e0       	ldi	r22, 0x00	; 0
    3b42:	0e 94 8d 1b 	call	0x371a	; 0x371a <PortEx_OUTSET>
    3b46:	8a ea       	ldi	r24, 0xAA	; 170
    3b48:	96 ee       	ldi	r25, 0xE6	; 230
    3b4a:	a6 e9       	ldi	r26, 0x96	; 150
    3b4c:	b1 e0       	ldi	r27, 0x01	; 1
    3b4e:	81 50       	subi	r24, 0x01	; 1
    3b50:	90 40       	sbci	r25, 0x00	; 0
    3b52:	a0 40       	sbci	r26, 0x00	; 0
    3b54:	b0 40       	sbci	r27, 0x00	; 0
    3b56:	d9 f7       	brne	.-10     	; 0x3b4e <checkMote+0x36>
    3b58:	00 00       	nop
		_delay_ms(5000);
		PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    3b5a:	88 e0       	ldi	r24, 0x08	; 8
    3b5c:	60 e0       	ldi	r22, 0x00	; 0
    3b5e:	0e 94 36 1b 	call	0x366c	; 0x366c <PortEx_OUTCLR>
    3b62:	8a ea       	ldi	r24, 0xAA	; 170
    3b64:	96 ee       	ldi	r25, 0xE6	; 230
    3b66:	a6 e9       	ldi	r26, 0x96	; 150
    3b68:	b1 e0       	ldi	r27, 0x01	; 1
    3b6a:	81 50       	subi	r24, 0x01	; 1
    3b6c:	90 40       	sbci	r25, 0x00	; 0
    3b6e:	a0 40       	sbci	r26, 0x00	; 0
    3b70:	b0 40       	sbci	r27, 0x00	; 0
    3b72:	d9 f7       	brne	.-10     	; 0x3b6a <checkMote+0x52>
    3b74:	00 00       	nop
    3b76:	e3 cf       	rjmp	.-58     	; 0x3b3e <checkMote+0x26>

00003b78 <SD_write_and_read_knowns>:
		_delay_ms(5000);
	}
}

//command to check reading and writing to sd card
void SD_write_and_read_knowns(){
    3b78:	0f 93       	push	r16
    3b7a:	1f 93       	push	r17
    3b7c:	cf 93       	push	r28
    3b7e:	df 93       	push	r29
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    3b80:	80 e0       	ldi	r24, 0x00	; 0
    3b82:	90 e0       	ldi	r25, 0x00	; 0
    3b84:	22 ec       	ldi	r18, 0xC2	; 194
    3b86:	33 e2       	ldi	r19, 0x23	; 35
    3b88:	f9 01       	movw	r30, r18
    3b8a:	e8 0f       	add	r30, r24
    3b8c:	f9 1f       	adc	r31, r25
    3b8e:	80 83       	st	Z, r24
    3b90:	01 96       	adiw	r24, 0x01	; 1
    3b92:	88 31       	cpi	r24, 0x18	; 24
    3b94:	91 05       	cpc	r25, r1
    3b96:	c1 f7       	brne	.-16     	; 0x3b88 <SD_write_and_read_knowns+0x10>
	SD_write_block(20,FRAMReadBuffer,24);	//write those values to the card
    3b98:	64 e1       	ldi	r22, 0x14	; 20
    3b9a:	70 e0       	ldi	r23, 0x00	; 0
    3b9c:	80 e0       	ldi	r24, 0x00	; 0
    3b9e:	90 e0       	ldi	r25, 0x00	; 0
    3ba0:	42 ec       	ldi	r20, 0xC2	; 194
    3ba2:	53 e2       	ldi	r21, 0x23	; 35
    3ba4:	28 e1       	ldi	r18, 0x18	; 24
    3ba6:	30 e0       	ldi	r19, 0x00	; 0
    3ba8:	0e 94 36 28 	call	0x506c	; 0x506c <SD_write_block>
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    3bac:	80 e0       	ldi	r24, 0x00	; 0
    3bae:	90 e0       	ldi	r25, 0x00	; 0
    3bb0:	22 ec       	ldi	r18, 0xC2	; 194
    3bb2:	33 e2       	ldi	r19, 0x23	; 35
    3bb4:	f9 01       	movw	r30, r18
    3bb6:	e8 0f       	add	r30, r24
    3bb8:	f9 1f       	adc	r31, r25
    3bba:	10 82       	st	Z, r1
    3bbc:	01 96       	adiw	r24, 0x01	; 1
    3bbe:	88 31       	cpi	r24, 0x18	; 24
    3bc0:	91 05       	cpc	r25, r1
    3bc2:	c1 f7       	brne	.-16     	; 0x3bb4 <SD_write_and_read_knowns+0x3c>
	SD_read_block(20,FRAMReadBuffer);	//read into the FRAM buffer from the SD card
    3bc4:	64 e1       	ldi	r22, 0x14	; 20
    3bc6:	70 e0       	ldi	r23, 0x00	; 0
    3bc8:	80 e0       	ldi	r24, 0x00	; 0
    3bca:	90 e0       	ldi	r25, 0x00	; 0
    3bcc:	42 ec       	ldi	r20, 0xC2	; 194
    3bce:	53 e2       	ldi	r21, 0x23	; 35
    3bd0:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <SD_read_block>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = i%100;	//write 1250 values to the FRAM buffer	
    3bd4:	20 e0       	ldi	r18, 0x00	; 0
    3bd6:	30 e0       	ldi	r19, 0x00	; 0
    3bd8:	c4 e6       	ldi	r28, 0x64	; 100
    3bda:	d0 e0       	ldi	r29, 0x00	; 0
    3bdc:	02 ec       	ldi	r16, 0xC2	; 194
    3bde:	13 e2       	ldi	r17, 0x23	; 35
    3be0:	c9 01       	movw	r24, r18
    3be2:	be 01       	movw	r22, r28
    3be4:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <__divmodhi4>
    3be8:	f8 01       	movw	r30, r16
    3bea:	e2 0f       	add	r30, r18
    3bec:	f3 1f       	adc	r31, r19
    3bee:	80 83       	st	Z, r24
    3bf0:	2f 5f       	subi	r18, 0xFF	; 255
    3bf2:	3f 4f       	sbci	r19, 0xFF	; 255
    3bf4:	44 e0       	ldi	r20, 0x04	; 4
    3bf6:	22 3e       	cpi	r18, 0xE2	; 226
    3bf8:	34 07       	cpc	r19, r20
    3bfa:	91 f7       	brne	.-28     	; 0x3be0 <SD_write_and_read_knowns+0x68>
	SD_write_multiple_blocks(80,FRAMReadBuffer,1250);	//write those values to sd card
    3bfc:	60 e5       	ldi	r22, 0x50	; 80
    3bfe:	70 e0       	ldi	r23, 0x00	; 0
    3c00:	80 e0       	ldi	r24, 0x00	; 0
    3c02:	90 e0       	ldi	r25, 0x00	; 0
    3c04:	42 ec       	ldi	r20, 0xC2	; 194
    3c06:	53 e2       	ldi	r21, 0x23	; 35
    3c08:	22 ee       	ldi	r18, 0xE2	; 226
    3c0a:	34 e0       	ldi	r19, 0x04	; 4
    3c0c:	0e 94 52 29 	call	0x52a4	; 0x52a4 <SD_write_multiple_blocks>
	for(int i=0;i<1250;i++) FRAMReadBuffer[i] = 0;	//clear FRAM buffer
    3c10:	80 e0       	ldi	r24, 0x00	; 0
    3c12:	90 e0       	ldi	r25, 0x00	; 0
    3c14:	22 ec       	ldi	r18, 0xC2	; 194
    3c16:	33 e2       	ldi	r19, 0x23	; 35
    3c18:	f9 01       	movw	r30, r18
    3c1a:	e8 0f       	add	r30, r24
    3c1c:	f9 1f       	adc	r31, r25
    3c1e:	10 82       	st	Z, r1
    3c20:	01 96       	adiw	r24, 0x01	; 1
    3c22:	44 e0       	ldi	r20, 0x04	; 4
    3c24:	82 3e       	cpi	r24, 0xE2	; 226
    3c26:	94 07       	cpc	r25, r20
    3c28:	b9 f7       	brne	.-18     	; 0x3c18 <SD_write_and_read_knowns+0xa0>
	SD_read_multiple_blocks(80,FRAMReadBuffer,3);	//read in 3 blocks of data from the memory card
    3c2a:	60 e5       	ldi	r22, 0x50	; 80
    3c2c:	70 e0       	ldi	r23, 0x00	; 0
    3c2e:	80 e0       	ldi	r24, 0x00	; 0
    3c30:	90 e0       	ldi	r25, 0x00	; 0
    3c32:	42 ec       	ldi	r20, 0xC2	; 194
    3c34:	53 e2       	ldi	r21, 0x23	; 35
    3c36:	23 e0       	ldi	r18, 0x03	; 3
    3c38:	30 e0       	ldi	r19, 0x00	; 0
    3c3a:	0e 94 ac 2a 	call	0x5558	; 0x5558 <SD_read_multiple_blocks>
}
    3c3e:	df 91       	pop	r29
    3c40:	cf 91       	pop	r28
    3c42:	1f 91       	pop	r17
    3c44:	0f 91       	pop	r16
    3c46:	08 95       	ret

00003c48 <SD_write_and_read_knowns_FAT>:
//check writing and reading to file on sd card
void SD_write_and_read_knowns_FAT(){
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = i;	//write 24 values to the FRAM buffer
    3c48:	80 e0       	ldi	r24, 0x00	; 0
    3c4a:	90 e0       	ldi	r25, 0x00	; 0
    3c4c:	22 ec       	ldi	r18, 0xC2	; 194
    3c4e:	33 e2       	ldi	r19, 0x23	; 35
    3c50:	f9 01       	movw	r30, r18
    3c52:	e8 0f       	add	r30, r24
    3c54:	f9 1f       	adc	r31, r25
    3c56:	80 83       	st	Z, r24
    3c58:	01 96       	adiw	r24, 0x01	; 1
    3c5a:	88 31       	cpi	r24, 0x18	; 24
    3c5c:	91 05       	cpc	r25, r1
    3c5e:	c1 f7       	brne	.-16     	; 0x3c50 <SD_write_and_read_knowns_FAT+0x8>
	error = writeFile("testing");
    3c60:	82 e1       	ldi	r24, 0x12	; 18
    3c62:	90 e2       	ldi	r25, 0x20	; 32
    3c64:	0e 94 8a 24 	call	0x4914	; 0x4914 <writeFile>
    3c68:	80 93 7f 50 	sts	0x507F, r24
	for (int i=0;i<24;i++) FRAMReadBuffer[i] = 0;	//clear the FRAM buffer
    3c6c:	80 e0       	ldi	r24, 0x00	; 0
    3c6e:	90 e0       	ldi	r25, 0x00	; 0
    3c70:	22 ec       	ldi	r18, 0xC2	; 194
    3c72:	33 e2       	ldi	r19, 0x23	; 35
    3c74:	f9 01       	movw	r30, r18
    3c76:	e8 0f       	add	r30, r24
    3c78:	f9 1f       	adc	r31, r25
    3c7a:	10 82       	st	Z, r1
    3c7c:	01 96       	adiw	r24, 0x01	; 1
    3c7e:	88 31       	cpi	r24, 0x18	; 24
    3c80:	91 05       	cpc	r25, r1
    3c82:	c1 f7       	brne	.-16     	; 0x3c74 <SD_write_and_read_knowns_FAT+0x2c>
	error = readFile(READ,"testing");		//read the data into the buffer from file
    3c84:	80 e0       	ldi	r24, 0x00	; 0
    3c86:	62 e1       	ldi	r22, 0x12	; 18
    3c88:	70 e2       	ldi	r23, 0x20	; 32
    3c8a:	0e 94 0c 24 	call	0x4818	; 0x4818 <readFile>
    3c8e:	80 93 7f 50 	sts	0x507F, r24
}
    3c92:	08 95       	ret

00003c94 <chibi_test_radio>:
}
*/
//function for testing radio transmission
void chibi_test_radio(){
		
	chb_init();
    3c94:	0e 94 84 13 	call	0x2708	; 0x2708 <chb_init>
	chb_set_short_addr(0x0002);
    3c98:	82 e0       	ldi	r24, 0x02	; 2
    3c9a:	90 e0       	ldi	r25, 0x00	; 0
    3c9c:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <chb_set_short_addr>
	while(1) nop();								//comment this line if testing transmission
    3ca0:	00 00       	nop
    3ca2:	fe cf       	rjmp	.-4      	; 0x3ca0 <chibi_test_radio+0xc>

00003ca4 <TestCard>:
	for (int i=0;i<10;i++) FRAMReadBuffer[i] = 0;
	chb_read(FRAMReadBuffer);
	*/
}
//another testing function for sd card
void TestCard(){
    3ca4:	ef 92       	push	r14
    3ca6:	ff 92       	push	r15
    3ca8:	0f 93       	push	r16
    3caa:	1f 93       	push	r17
    3cac:	cf 93       	push	r28
    3cae:	df 93       	push	r29
	SD_init();
    3cb0:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <SD_init>
	getBootSectorData();
    3cb4:	0e 94 d9 1f 	call	0x3fb2	; 0x3fb2 <getBootSectorData>
	for (int i=0;i<512;i++) FRAMReadBuffer[i] = i%121;
    3cb8:	20 e0       	ldi	r18, 0x00	; 0
    3cba:	30 e0       	ldi	r19, 0x00	; 0
    3cbc:	c9 e7       	ldi	r28, 0x79	; 121
    3cbe:	d0 e0       	ldi	r29, 0x00	; 0
    3cc0:	02 ec       	ldi	r16, 0xC2	; 194
    3cc2:	13 e2       	ldi	r17, 0x23	; 35
    3cc4:	c9 01       	movw	r24, r18
    3cc6:	be 01       	movw	r22, r28
    3cc8:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <__divmodhi4>
    3ccc:	f8 01       	movw	r30, r16
    3cce:	e2 0f       	add	r30, r18
    3cd0:	f3 1f       	adc	r31, r19
    3cd2:	80 83       	st	Z, r24
    3cd4:	2f 5f       	subi	r18, 0xFF	; 255
    3cd6:	3f 4f       	sbci	r19, 0xFF	; 255
    3cd8:	82 e0       	ldi	r24, 0x02	; 2
    3cda:	20 30       	cpi	r18, 0x00	; 0
    3cdc:	38 07       	cpc	r19, r24
    3cde:	91 f7       	brne	.-28     	; 0x3cc4 <TestCard+0x20>
    3ce0:	c0 e0       	ldi	r28, 0x00	; 0
for (int i=0;i<55;i++) {FRAMReadBuffer[0] = i; writeFile("testing");}
    3ce2:	02 ec       	ldi	r16, 0xC2	; 194
    3ce4:	13 e2       	ldi	r17, 0x23	; 35
    3ce6:	0f 2e       	mov	r0, r31
    3ce8:	f2 e1       	ldi	r31, 0x12	; 18
    3cea:	ef 2e       	mov	r14, r31
    3cec:	f0 e2       	ldi	r31, 0x20	; 32
    3cee:	ff 2e       	mov	r15, r31
    3cf0:	f0 2d       	mov	r31, r0
    3cf2:	f8 01       	movw	r30, r16
    3cf4:	c0 83       	st	Z, r28
    3cf6:	c7 01       	movw	r24, r14
    3cf8:	0e 94 8a 24 	call	0x4914	; 0x4914 <writeFile>
    3cfc:	cf 5f       	subi	r28, 0xFF	; 255
    3cfe:	c7 33       	cpi	r28, 0x37	; 55
    3d00:	c1 f7       	brne	.-16     	; 0x3cf2 <TestCard+0x4e>
    3d02:	df 91       	pop	r29
    3d04:	cf 91       	pop	r28
    3d06:	1f 91       	pop	r17
    3d08:	0f 91       	pop	r16
    3d0a:	ff 90       	pop	r15
    3d0c:	ef 90       	pop	r14
    3d0e:	08 95       	ret

00003d10 <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    3d10:	cf 92       	push	r12
    3d12:	df 92       	push	r13
    3d14:	ef 92       	push	r14
    3d16:	ff 92       	push	r15
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    3d18:	20 91 57 50 	lds	r18, 0x5057
    3d1c:	30 91 58 50 	lds	r19, 0x5058
    3d20:	c0 90 be 23 	lds	r12, 0x23BE
    3d24:	d0 90 bf 23 	lds	r13, 0x23BF
    3d28:	e0 90 c0 23 	lds	r14, 0x23C0
    3d2c:	f0 90 c1 23 	lds	r15, 0x23C1
    3d30:	62 50       	subi	r22, 0x02	; 2
    3d32:	70 40       	sbci	r23, 0x00	; 0
    3d34:	80 40       	sbci	r24, 0x00	; 0
    3d36:	90 40       	sbci	r25, 0x00	; 0
    3d38:	40 e0       	ldi	r20, 0x00	; 0
    3d3a:	50 e0       	ldi	r21, 0x00	; 0
    3d3c:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    3d40:	dc 01       	movw	r26, r24
    3d42:	cb 01       	movw	r24, r22
    3d44:	c8 0e       	add	r12, r24
    3d46:	d9 1e       	adc	r13, r25
    3d48:	ea 1e       	adc	r14, r26
    3d4a:	fb 1e       	adc	r15, r27
}
    3d4c:	6c 2d       	mov	r22, r12
    3d4e:	7d 2d       	mov	r23, r13
    3d50:	8e 2d       	mov	r24, r14
    3d52:	9f 2d       	mov	r25, r15
    3d54:	ff 90       	pop	r15
    3d56:	ef 90       	pop	r14
    3d58:	df 90       	pop	r13
    3d5a:	cf 90       	pop	r12
    3d5c:	08 95       	ret

00003d5e <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    3d5e:	2f 92       	push	r2
    3d60:	3f 92       	push	r3
    3d62:	4f 92       	push	r4
    3d64:	5f 92       	push	r5
    3d66:	7f 92       	push	r7
    3d68:	8f 92       	push	r8
    3d6a:	9f 92       	push	r9
    3d6c:	af 92       	push	r10
    3d6e:	bf 92       	push	r11
    3d70:	cf 92       	push	r12
    3d72:	df 92       	push	r13
    3d74:	ef 92       	push	r14
    3d76:	ff 92       	push	r15
    3d78:	0f 93       	push	r16
    3d7a:	1f 93       	push	r17
    3d7c:	cf 93       	push	r28
    3d7e:	df 93       	push	r29
    3d80:	dc 01       	movw	r26, r24
    3d82:	cb 01       	movw	r24, r22
    3d84:	74 2e       	mov	r7, r20
    3d86:	18 01       	movw	r2, r16
    3d88:	29 01       	movw	r4, r18
unsigned long *FATEntryValue;
unsigned long FATEntrySector;
unsigned char retry = 0;

//get sector number of the cluster entry in the FAT
FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    3d8a:	c0 90 5f 50 	lds	r12, 0x505F
    3d8e:	d0 90 60 50 	lds	r13, 0x5060
    3d92:	4c 01       	movw	r8, r24
    3d94:	5d 01       	movw	r10, r26
    3d96:	88 0c       	add	r8, r8
    3d98:	99 1c       	adc	r9, r9
    3d9a:	aa 1c       	adc	r10, r10
    3d9c:	bb 1c       	adc	r11, r11
    3d9e:	88 0c       	add	r8, r8
    3da0:	99 1c       	adc	r9, r9
    3da2:	aa 1c       	adc	r10, r10
    3da4:	bb 1c       	adc	r11, r11
    3da6:	20 91 37 40 	lds	r18, 0x4037
    3daa:	30 91 38 40 	lds	r19, 0x4038
    3dae:	ee 24       	eor	r14, r14
    3db0:	ff 24       	eor	r15, r15
    3db2:	80 91 59 50 	lds	r24, 0x5059
    3db6:	90 91 5a 50 	lds	r25, 0x505A
    3dba:	a0 91 5b 50 	lds	r26, 0x505B
    3dbe:	b0 91 5c 50 	lds	r27, 0x505C
    3dc2:	c8 0e       	add	r12, r24
    3dc4:	d9 1e       	adc	r13, r25
    3dc6:	ea 1e       	adc	r14, r26
    3dc8:	fb 1e       	adc	r15, r27
    3dca:	40 e0       	ldi	r20, 0x00	; 0
    3dcc:	50 e0       	ldi	r21, 0x00	; 0
    3dce:	c5 01       	movw	r24, r10
    3dd0:	b4 01       	movw	r22, r8
    3dd2:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    3dd6:	c2 0e       	add	r12, r18
    3dd8:	d3 1e       	adc	r13, r19
    3dda:	e4 1e       	adc	r14, r20
    3ddc:	f5 1e       	adc	r15, r21

//get the offset address in that sector number
FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    3dde:	20 91 37 40 	lds	r18, 0x4037
    3de2:	30 91 38 40 	lds	r19, 0x4038
    3de6:	40 e0       	ldi	r20, 0x00	; 0
    3de8:	50 e0       	ldi	r21, 0x00	; 0
    3dea:	c5 01       	movw	r24, r10
    3dec:	b4 01       	movw	r22, r8
    3dee:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    3df2:	dc 01       	movw	r26, r24
    3df4:	cb 01       	movw	r24, r22
    3df6:	ec 01       	movw	r28, r24

//read the sector into a buffer
SD_read_block(FATEntrySector,SDBuffer);
    3df8:	c7 01       	movw	r24, r14
    3dfa:	b6 01       	movw	r22, r12
    3dfc:	49 eb       	ldi	r20, 0xB9	; 185
    3dfe:	51 e2       	ldi	r21, 0x21	; 33
    3e00:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <SD_read_block>

//get the cluster address from the buffer
FATEntryValue = (unsigned long *) &SDBuffer[FATEntryOffset];
    3e04:	c7 54       	subi	r28, 0x47	; 71
    3e06:	de 4d       	sbci	r29, 0xDE	; 222

if(get_set == GET)
    3e08:	77 20       	and	r7, r7
    3e0a:	31 f4       	brne	.+12     	; 0x3e18 <getSetNextCluster+0xba>
  return ((*FATEntryValue) & 0x0fffffff);
    3e0c:	08 81       	ld	r16, Y
    3e0e:	19 81       	ldd	r17, Y+1	; 0x01
    3e10:	2a 81       	ldd	r18, Y+2	; 0x02
    3e12:	3b 81       	ldd	r19, Y+3	; 0x03
    3e14:	3f 70       	andi	r19, 0x0F	; 15
    3e16:	0f c0       	rjmp	.+30     	; 0x3e36 <getSetNextCluster+0xd8>


*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    3e18:	28 82       	st	Y, r2
    3e1a:	39 82       	std	Y+1, r3	; 0x01
    3e1c:	4a 82       	std	Y+2, r4	; 0x02
    3e1e:	5b 82       	std	Y+3, r5	; 0x03

SD_write_block(FATEntrySector,SDBuffer,512);
    3e20:	c7 01       	movw	r24, r14
    3e22:	b6 01       	movw	r22, r12
    3e24:	49 eb       	ldi	r20, 0xB9	; 185
    3e26:	51 e2       	ldi	r21, 0x21	; 33
    3e28:	20 e0       	ldi	r18, 0x00	; 0
    3e2a:	32 e0       	ldi	r19, 0x02	; 2
    3e2c:	0e 94 36 28 	call	0x506c	; 0x506c <SD_write_block>

return (0);
    3e30:	00 e0       	ldi	r16, 0x00	; 0
    3e32:	10 e0       	ldi	r17, 0x00	; 0
    3e34:	98 01       	movw	r18, r16
}
    3e36:	60 2f       	mov	r22, r16
    3e38:	71 2f       	mov	r23, r17
    3e3a:	82 2f       	mov	r24, r18
    3e3c:	93 2f       	mov	r25, r19
    3e3e:	df 91       	pop	r29
    3e40:	cf 91       	pop	r28
    3e42:	1f 91       	pop	r17
    3e44:	0f 91       	pop	r16
    3e46:	ff 90       	pop	r15
    3e48:	ef 90       	pop	r14
    3e4a:	df 90       	pop	r13
    3e4c:	cf 90       	pop	r12
    3e4e:	bf 90       	pop	r11
    3e50:	af 90       	pop	r10
    3e52:	9f 90       	pop	r9
    3e54:	8f 90       	pop	r8
    3e56:	7f 90       	pop	r7
    3e58:	5f 90       	pop	r5
    3e5a:	4f 90       	pop	r4
    3e5c:	3f 90       	pop	r3
    3e5e:	2f 90       	pop	r2
    3e60:	08 95       	ret

00003e62 <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    3e62:	cf 92       	push	r12
    3e64:	df 92       	push	r13
    3e66:	ef 92       	push	r14
    3e68:	ff 92       	push	r15
    3e6a:	0f 93       	push	r16
    3e6c:	1f 93       	push	r17
    3e6e:	cf 93       	push	r28
    3e70:	c8 2f       	mov	r28, r24
    3e72:	06 2f       	mov	r16, r22
    3e74:	69 01       	movw	r12, r18
    3e76:	7a 01       	movw	r14, r20
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);
    3e78:	80 91 59 50 	lds	r24, 0x5059
    3e7c:	90 91 5a 50 	lds	r25, 0x505A
    3e80:	a0 91 5b 50 	lds	r26, 0x505B
    3e84:	b0 91 5c 50 	lds	r27, 0x505C
    3e88:	bc 01       	movw	r22, r24
    3e8a:	cd 01       	movw	r24, r26
    3e8c:	6f 5f       	subi	r22, 0xFF	; 255
    3e8e:	7f 4f       	sbci	r23, 0xFF	; 255
    3e90:	8f 4f       	sbci	r24, 0xFF	; 255
    3e92:	9f 4f       	sbci	r25, 0xFF	; 255
    3e94:	49 eb       	ldi	r20, 0xB9	; 185
    3e96:	51 e2       	ldi	r21, 0x21	; 33
    3e98:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <SD_read_block>

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    3e9c:	80 91 b9 21 	lds	r24, 0x21B9
    3ea0:	90 91 ba 21 	lds	r25, 0x21BA
    3ea4:	a0 91 bb 21 	lds	r26, 0x21BB
    3ea8:	b0 91 bc 21 	lds	r27, 0x21BC
    3eac:	82 35       	cpi	r24, 0x52	; 82
    3eae:	22 e5       	ldi	r18, 0x52	; 82
    3eb0:	92 07       	cpc	r25, r18
    3eb2:	21 e6       	ldi	r18, 0x61	; 97
    3eb4:	a2 07       	cpc	r26, r18
    3eb6:	21 e4       	ldi	r18, 0x41	; 65
    3eb8:	b2 07       	cpc	r27, r18
    3eba:	09 f0       	breq	.+2      	; 0x3ebe <getSetFreeCluster+0x5c>
    3ebc:	63 c0       	rjmp	.+198    	; 0x3f84 <getSetFreeCluster+0x122>
    3ebe:	80 91 9d 23 	lds	r24, 0x239D
    3ec2:	90 91 9e 23 	lds	r25, 0x239E
    3ec6:	a0 91 9f 23 	lds	r26, 0x239F
    3eca:	b0 91 a0 23 	lds	r27, 0x23A0
    3ece:	82 37       	cpi	r24, 0x72	; 114
    3ed0:	22 e7       	ldi	r18, 0x72	; 114
    3ed2:	92 07       	cpc	r25, r18
    3ed4:	21 e4       	ldi	r18, 0x41	; 65
    3ed6:	a2 07       	cpc	r26, r18
    3ed8:	21 e6       	ldi	r18, 0x61	; 97
    3eda:	b2 07       	cpc	r27, r18
    3edc:	09 f0       	breq	.+2      	; 0x3ee0 <getSetFreeCluster+0x7e>
    3ede:	56 c0       	rjmp	.+172    	; 0x3f8c <getSetFreeCluster+0x12a>
    3ee0:	80 91 b5 23 	lds	r24, 0x23B5
    3ee4:	90 91 b6 23 	lds	r25, 0x23B6
    3ee8:	a0 91 b7 23 	lds	r26, 0x23B7
    3eec:	b0 91 b8 23 	lds	r27, 0x23B8
    3ef0:	80 30       	cpi	r24, 0x00	; 0
    3ef2:	20 e0       	ldi	r18, 0x00	; 0
    3ef4:	92 07       	cpc	r25, r18
    3ef6:	25 e5       	ldi	r18, 0x55	; 85
    3ef8:	a2 07       	cpc	r26, r18
    3efa:	2a ea       	ldi	r18, 0xAA	; 170
    3efc:	b2 07       	cpc	r27, r18
    3efe:	09 f0       	breq	.+2      	; 0x3f02 <getSetFreeCluster+0xa0>
    3f00:	49 c0       	rjmp	.+146    	; 0x3f94 <getSetFreeCluster+0x132>
  return 0xffffffff;

 if(get_set == GET)
    3f02:	00 23       	and	r16, r16
    3f04:	a1 f4       	brne	.+40     	; 0x3f2e <getSetFreeCluster+0xcc>
 {
   if(totOrNext == TOTAL_FREE)
    3f06:	c1 30       	cpi	r28, 0x01	; 1
    3f08:	49 f4       	brne	.+18     	; 0x3f1c <getSetFreeCluster+0xba>
      return(FS->freeClusterCount);
    3f0a:	00 91 a1 23 	lds	r16, 0x23A1
    3f0e:	10 91 a2 23 	lds	r17, 0x23A2
    3f12:	20 91 a3 23 	lds	r18, 0x23A3
    3f16:	30 91 a4 23 	lds	r19, 0x23A4
    3f1a:	3f c0       	rjmp	.+126    	; 0x3f9a <getSetFreeCluster+0x138>
   else // when totOrNext = NEXT_FREE
      return(FS->nextFreeCluster);
    3f1c:	00 91 a5 23 	lds	r16, 0x23A5
    3f20:	10 91 a6 23 	lds	r17, 0x23A6
    3f24:	20 91 a7 23 	lds	r18, 0x23A7
    3f28:	30 91 a8 23 	lds	r19, 0x23A8
    3f2c:	36 c0       	rjmp	.+108    	; 0x3f9a <getSetFreeCluster+0x138>
 }
 else
 {
   if(totOrNext == TOTAL_FREE)
    3f2e:	c1 30       	cpi	r28, 0x01	; 1
    3f30:	49 f4       	brne	.+18     	; 0x3f44 <getSetFreeCluster+0xe2>
      FS->freeClusterCount = FSEntry;
    3f32:	c0 92 a1 23 	sts	0x23A1, r12
    3f36:	d0 92 a2 23 	sts	0x23A2, r13
    3f3a:	e0 92 a3 23 	sts	0x23A3, r14
    3f3e:	f0 92 a4 23 	sts	0x23A4, r15
    3f42:	08 c0       	rjmp	.+16     	; 0x3f54 <getSetFreeCluster+0xf2>
   else // when totOrNext = NEXT_FREE
	  FS->nextFreeCluster = FSEntry;
    3f44:	c0 92 a5 23 	sts	0x23A5, r12
    3f48:	d0 92 a6 23 	sts	0x23A6, r13
    3f4c:	e0 92 a7 23 	sts	0x23A7, r14
    3f50:	f0 92 a8 23 	sts	0x23A8, r15
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
    3f54:	80 91 59 50 	lds	r24, 0x5059
    3f58:	90 91 5a 50 	lds	r25, 0x505A
    3f5c:	a0 91 5b 50 	lds	r26, 0x505B
    3f60:	b0 91 5c 50 	lds	r27, 0x505C
    3f64:	bc 01       	movw	r22, r24
    3f66:	cd 01       	movw	r24, r26
    3f68:	6f 5f       	subi	r22, 0xFF	; 255
    3f6a:	7f 4f       	sbci	r23, 0xFF	; 255
    3f6c:	8f 4f       	sbci	r24, 0xFF	; 255
    3f6e:	9f 4f       	sbci	r25, 0xFF	; 255
    3f70:	49 eb       	ldi	r20, 0xB9	; 185
    3f72:	51 e2       	ldi	r21, 0x21	; 33
    3f74:	20 e0       	ldi	r18, 0x00	; 0
    3f76:	32 e0       	ldi	r19, 0x02	; 2
    3f78:	0e 94 36 28 	call	0x506c	; 0x506c <SD_write_block>
 }
 return 0xffffffff;
    3f7c:	0f ef       	ldi	r16, 0xFF	; 255
    3f7e:	1f ef       	ldi	r17, 0xFF	; 255
    3f80:	98 01       	movw	r18, r16
    3f82:	0b c0       	rjmp	.+22     	; 0x3f9a <getSetFreeCluster+0x138>
struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &SDBuffer;

SD_read_block(unusedSectors + 1,SDBuffer);

if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
  return 0xffffffff;
    3f84:	0f ef       	ldi	r16, 0xFF	; 255
    3f86:	1f ef       	ldi	r17, 0xFF	; 255
    3f88:	98 01       	movw	r18, r16
    3f8a:	07 c0       	rjmp	.+14     	; 0x3f9a <getSetFreeCluster+0x138>
    3f8c:	0f ef       	ldi	r16, 0xFF	; 255
    3f8e:	1f ef       	ldi	r17, 0xFF	; 255
    3f90:	98 01       	movw	r18, r16
    3f92:	03 c0       	rjmp	.+6      	; 0x3f9a <getSetFreeCluster+0x138>
    3f94:	0f ef       	ldi	r16, 0xFF	; 255
    3f96:	1f ef       	ldi	r17, 0xFF	; 255
    3f98:	98 01       	movw	r18, r16
	  FS->nextFreeCluster = FSEntry;
 
   SD_write_block(unusedSectors + 1,SDBuffer,512);	//update FSinfo
 }
 return 0xffffffff;
}
    3f9a:	60 2f       	mov	r22, r16
    3f9c:	71 2f       	mov	r23, r17
    3f9e:	82 2f       	mov	r24, r18
    3fa0:	93 2f       	mov	r25, r19
    3fa2:	cf 91       	pop	r28
    3fa4:	1f 91       	pop	r17
    3fa6:	0f 91       	pop	r16
    3fa8:	ff 90       	pop	r15
    3faa:	ef 90       	pop	r14
    3fac:	df 90       	pop	r13
    3fae:	cf 90       	pop	r12
    3fb0:	08 95       	ret

00003fb2 <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    3fb2:	ef 92       	push	r14
    3fb4:	ff 92       	push	r15
    3fb6:	0f 93       	push	r16
    3fb8:	1f 93       	push	r17
    3fba:	cf 93       	push	r28
    3fbc:	df 93       	push	r29
struct BS_Structure *bpb; //mapping the buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    3fbe:	10 92 59 50 	sts	0x5059, r1
    3fc2:	10 92 5a 50 	sts	0x505A, r1
    3fc6:	10 92 5b 50 	sts	0x505B, r1
    3fca:	10 92 5c 50 	sts	0x505C, r1

SD_read_block(0,SDBuffer);
    3fce:	60 e0       	ldi	r22, 0x00	; 0
    3fd0:	70 e0       	ldi	r23, 0x00	; 0
    3fd2:	cb 01       	movw	r24, r22
    3fd4:	49 eb       	ldi	r20, 0xB9	; 185
    3fd6:	51 e2       	ldi	r21, 0x21	; 33
    3fd8:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <SD_read_block>
bpb = (struct BS_Structure *)SDBuffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    3fdc:	80 91 b9 21 	lds	r24, 0x21B9
    3fe0:	89 3e       	cpi	r24, 0xE9	; 233
    3fe2:	31 f1       	breq	.+76     	; 0x4030 <getBootSectorData+0x7e>
    3fe4:	8b 3e       	cpi	r24, 0xEB	; 235
    3fe6:	21 f1       	breq	.+72     	; 0x4030 <getBootSectorData+0x7e>
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    3fe8:	80 91 b7 23 	lds	r24, 0x23B7
    3fec:	90 91 b8 23 	lds	r25, 0x23B8
    3ff0:	2a ea       	ldi	r18, 0xAA	; 170
    3ff2:	85 35       	cpi	r24, 0x55	; 85
    3ff4:	92 07       	cpc	r25, r18
    3ff6:	09 f0       	breq	.+2      	; 0x3ffa <getBootSectorData+0x48>
    3ff8:	b7 c0       	rjmp	.+366    	; 0x4168 <getBootSectorData+0x1b6>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    3ffa:	60 91 7f 23 	lds	r22, 0x237F
    3ffe:	70 91 80 23 	lds	r23, 0x2380
    4002:	80 91 81 23 	lds	r24, 0x2381
    4006:	90 91 82 23 	lds	r25, 0x2382
    400a:	60 93 59 50 	sts	0x5059, r22
    400e:	70 93 5a 50 	sts	0x505A, r23
    4012:	80 93 5b 50 	sts	0x505B, r24
    4016:	90 93 5c 50 	sts	0x505C, r25
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
    401a:	49 eb       	ldi	r20, 0xB9	; 185
    401c:	51 e2       	ldi	r21, 0x21	; 33
    401e:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <SD_read_block>
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    4022:	80 91 b9 21 	lds	r24, 0x21B9
    4026:	89 3e       	cpi	r24, 0xE9	; 233
    4028:	19 f0       	breq	.+6      	; 0x4030 <getBootSectorData+0x7e>
    402a:	8b 3e       	cpi	r24, 0xEB	; 235
    402c:	09 f0       	breq	.+2      	; 0x4030 <getBootSectorData+0x7e>
    402e:	9e c0       	rjmp	.+316    	; 0x416c <getBootSectorData+0x1ba>
}

bytesPerSector = bpb->bytesPerSector;
    4030:	80 91 c4 21 	lds	r24, 0x21C4
    4034:	90 91 c5 21 	lds	r25, 0x21C5
    4038:	80 93 37 40 	sts	0x4037, r24
    403c:	90 93 38 40 	sts	0x4038, r25
sectorPerCluster = bpb->sectorPerCluster;
    4040:	80 91 c6 21 	lds	r24, 0x21C6
    4044:	90 e0       	ldi	r25, 0x00	; 0
    4046:	80 93 57 50 	sts	0x5057, r24
    404a:	90 93 58 50 	sts	0x5058, r25
reservedSectorCount = bpb->reservedSectorCount;
    404e:	e0 90 c7 21 	lds	r14, 0x21C7
    4052:	f0 90 c8 21 	lds	r15, 0x21C8
    4056:	e0 92 5f 50 	sts	0x505F, r14
    405a:	f0 92 60 50 	sts	0x5060, r15
rootCluster = bpb->rootCluster;
    405e:	80 91 e5 21 	lds	r24, 0x21E5
    4062:	90 91 e6 21 	lds	r25, 0x21E6
    4066:	a0 91 e7 21 	lds	r26, 0x21E7
    406a:	b0 91 e8 21 	lds	r27, 0x21E8
    406e:	80 93 41 40 	sts	0x4041, r24
    4072:	90 93 42 40 	sts	0x4042, r25
    4076:	a0 93 43 40 	sts	0x4043, r26
    407a:	b0 93 44 40 	sts	0x4044, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    407e:	c0 91 5f 50 	lds	r28, 0x505F
    4082:	d0 91 60 50 	lds	r29, 0x5060
    4086:	60 91 c9 21 	lds	r22, 0x21C9
    408a:	70 e0       	ldi	r23, 0x00	; 0
    408c:	80 e0       	ldi	r24, 0x00	; 0
    408e:	90 e0       	ldi	r25, 0x00	; 0
    4090:	20 91 dd 21 	lds	r18, 0x21DD
    4094:	30 91 de 21 	lds	r19, 0x21DE
    4098:	40 91 df 21 	lds	r20, 0x21DF
    409c:	50 91 e0 21 	lds	r21, 0x21E0
    40a0:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    40a4:	8b 01       	movw	r16, r22
    40a6:	9c 01       	movw	r18, r24
    40a8:	ae 01       	movw	r20, r28
    40aa:	60 e0       	ldi	r22, 0x00	; 0
    40ac:	70 e0       	ldi	r23, 0x00	; 0
    40ae:	80 91 d5 21 	lds	r24, 0x21D5
    40b2:	90 91 d6 21 	lds	r25, 0x21D6
    40b6:	a0 91 d7 21 	lds	r26, 0x21D7
    40ba:	b0 91 d8 21 	lds	r27, 0x21D8
    40be:	84 0f       	add	r24, r20
    40c0:	95 1f       	adc	r25, r21
    40c2:	a6 1f       	adc	r26, r22
    40c4:	b7 1f       	adc	r27, r23
    40c6:	80 0f       	add	r24, r16
    40c8:	91 1f       	adc	r25, r17
    40ca:	a2 1f       	adc	r26, r18
    40cc:	b3 1f       	adc	r27, r19
    40ce:	80 93 be 23 	sts	0x23BE, r24
    40d2:	90 93 bf 23 	sts	0x23BF, r25
    40d6:	a0 93 c0 23 	sts	0x23C0, r26
    40da:	b0 93 c1 23 	sts	0x23C1, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    40de:	e0 91 57 50 	lds	r30, 0x5057
    40e2:	f0 91 58 50 	lds	r31, 0x5058
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    40e6:	c7 01       	movw	r24, r14
    40e8:	a0 e0       	ldi	r26, 0x00	; 0
    40ea:	b0 e0       	ldi	r27, 0x00	; 0
    40ec:	40 91 d9 21 	lds	r20, 0x21D9
    40f0:	50 91 da 21 	lds	r21, 0x21DA
    40f4:	60 91 db 21 	lds	r22, 0x21DB
    40f8:	70 91 dc 21 	lds	r23, 0x21DC
    40fc:	48 1b       	sub	r20, r24
    40fe:	59 0b       	sbc	r21, r25
    4100:	6a 0b       	sbc	r22, r26
    4102:	7b 0b       	sbc	r23, r27
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    4104:	cb 01       	movw	r24, r22
    4106:	ba 01       	movw	r22, r20
    4108:	60 1b       	sub	r22, r16
    410a:	71 0b       	sbc	r23, r17
    410c:	82 0b       	sbc	r24, r18
    410e:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    4110:	9f 01       	movw	r18, r30
    4112:	40 e0       	ldi	r20, 0x00	; 0
    4114:	50 e0       	ldi	r21, 0x00	; 0
    4116:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    411a:	20 93 3c 40 	sts	0x403C, r18
    411e:	30 93 3d 40 	sts	0x403D, r19
    4122:	40 93 3e 40 	sts	0x403E, r20
    4126:	50 93 3f 40 	sts	0x403F, r21


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    412a:	81 e0       	ldi	r24, 0x01	; 1
    412c:	60 e0       	ldi	r22, 0x00	; 0
    412e:	20 e0       	ldi	r18, 0x00	; 0
    4130:	30 e0       	ldi	r19, 0x00	; 0
    4132:	a9 01       	movw	r20, r18
    4134:	0e 94 31 1f 	call	0x3e62	; 0x3e62 <getSetFreeCluster>
    4138:	ab 01       	movw	r20, r22
    413a:	bc 01       	movw	r22, r24
    413c:	80 91 3c 40 	lds	r24, 0x403C
    4140:	90 91 3d 40 	lds	r25, 0x403D
    4144:	a0 91 3e 40 	lds	r26, 0x403E
    4148:	b0 91 3f 40 	lds	r27, 0x403F
    414c:	84 17       	cp	r24, r20
    414e:	95 07       	cpc	r25, r21
    4150:	a6 07       	cpc	r26, r22
    4152:	b7 07       	cpc	r27, r23
    4154:	20 f4       	brcc	.+8      	; 0x415e <getBootSectorData+0x1ac>
     freeClusterCountUpdated = 0;
    4156:	10 92 ab 50 	sts	0x50AB, r1
else
	 freeClusterCountUpdated = 1;
return 0;
    415a:	80 e0       	ldi	r24, 0x00	; 0
    415c:	08 c0       	rjmp	.+16     	; 0x416e <getBootSectorData+0x1bc>


if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
    415e:	81 e0       	ldi	r24, 0x01	; 1
    4160:	80 93 ab 50 	sts	0x50AB, r24
return 0;
    4164:	80 e0       	ldi	r24, 0x00	; 0
    4166:	03 c0       	rjmp	.+6      	; 0x416e <getBootSectorData+0x1bc>

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
{
  mbr = (struct MBRinfo_Structure *) SDBuffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    4168:	81 e0       	ldi	r24, 0x01	; 1
    416a:	01 c0       	rjmp	.+2      	; 0x416e <getBootSectorData+0x1bc>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_read_block(partition->firstSector,SDBuffer);//read the bpb sector
  bpb = (struct BS_Structure *)SDBuffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    416c:	81 e0       	ldi	r24, 0x01	; 1
if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
     freeClusterCountUpdated = 0;
else
	 freeClusterCountUpdated = 1;
return 0;
}
    416e:	df 91       	pop	r29
    4170:	cf 91       	pop	r28
    4172:	1f 91       	pop	r17
    4174:	0f 91       	pop	r16
    4176:	ff 90       	pop	r15
    4178:	ef 90       	pop	r14
    417a:	08 95       	ret

0000417c <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    417c:	cf 93       	push	r28
    417e:	df 93       	push	r29
    4180:	cd b7       	in	r28, 0x3d	; 61
    4182:	de b7       	in	r29, 0x3e	; 62
    4184:	2b 97       	sbiw	r28, 0x0b	; 11
    4186:	cd bf       	out	0x3d, r28	; 61
    4188:	de bf       	out	0x3e, r29	; 62
    418a:	9c 01       	movw	r18, r24
bool NoExtension = FALSE;
unsigned char fileNameFAT[11];
unsigned char j, k;

for(j=0; j<12; j++)
if(fileName[j] == '.') break;
    418c:	fc 01       	movw	r30, r24
    418e:	80 81       	ld	r24, Z
    4190:	8e 32       	cpi	r24, 0x2E	; 46
    4192:	89 f0       	breq	.+34     	; 0x41b6 <convertFileName+0x3a>
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4194:	31 96       	adiw	r30, 0x01	; 1
{
bool NoExtension = FALSE;
unsigned char fileNameFAT[11];
unsigned char j, k;

for(j=0; j<12; j++)
    4196:	41 e0       	ldi	r20, 0x01	; 1
if(fileName[j] == '.') break;
    4198:	81 91       	ld	r24, Z+
    419a:	8e 32       	cpi	r24, 0x2E	; 46
    419c:	21 f0       	breq	.+8      	; 0x41a6 <convertFileName+0x2a>
{
bool NoExtension = FALSE;
unsigned char fileNameFAT[11];
unsigned char j, k;

for(j=0; j<12; j++)
    419e:	4f 5f       	subi	r20, 0xFF	; 255
    41a0:	4c 30       	cpi	r20, 0x0C	; 12
    41a2:	d1 f7       	brne	.-12     	; 0x4198 <convertFileName+0x1c>
    41a4:	05 c0       	rjmp	.+10     	; 0x41b0 <convertFileName+0x34>
if(fileName[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
    41a6:	84 2f       	mov	r24, r20
    41a8:	89 50       	subi	r24, 0x09	; 9
    41aa:	83 30       	cpi	r24, 0x03	; 3
    41ac:	08 f4       	brcc	.+2      	; 0x41b0 <convertFileName+0x34>
    41ae:	62 c0       	rjmp	.+196    	; 0x4274 <convertFileName+0xf8>
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    41b0:	44 23       	and	r20, r20
    41b2:	29 f4       	brne	.+10     	; 0x41be <convertFileName+0x42>
    41b4:	01 c0       	rjmp	.+2      	; 0x41b8 <convertFileName+0x3c>
{
bool NoExtension = FALSE;
unsigned char fileNameFAT[11];
unsigned char j, k;

for(j=0; j<12; j++)
    41b6:	40 e0       	ldi	r20, 0x00	; 0
    41b8:	84 2f       	mov	r24, r20

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = fileName[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';
    41ba:	90 e2       	ldi	r25, 0x20	; 32
    41bc:	14 c0       	rjmp	.+40     	; 0x41e6 <convertFileName+0x6a>

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    41be:	d9 01       	movw	r26, r18
    41c0:	fe 01       	movw	r30, r28
    41c2:	31 96       	adiw	r30, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    41c4:	84 2f       	mov	r24, r20
    41c6:	81 50       	subi	r24, 0x01	; 1
    41c8:	62 e0       	ldi	r22, 0x02	; 2
    41ca:	70 e0       	ldi	r23, 0x00	; 0
    41cc:	6c 0f       	add	r22, r28
    41ce:	7d 1f       	adc	r23, r29
    41d0:	68 0f       	add	r22, r24
    41d2:	71 1d       	adc	r23, r1
    41d4:	cb 01       	movw	r24, r22
if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = fileName[k];
    41d6:	5d 91       	ld	r21, X+
    41d8:	51 93       	st	Z+, r21

if(j>8 && j<12) {//Invalid fileName
	return 1;}
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
    41da:	e8 17       	cp	r30, r24
    41dc:	f9 07       	cpc	r31, r25
    41de:	d9 f7       	brne	.-10     	; 0x41d6 <convertFileName+0x5a>
  fileNameFAT[k] = fileName[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    41e0:	48 30       	cpi	r20, 0x08	; 8
    41e2:	50 f3       	brcs	.-44     	; 0x41b8 <convertFileName+0x3c>
    41e4:	0a c0       	rjmp	.+20     	; 0x41fa <convertFileName+0x7e>
  fileNameFAT[k] = ' ';
    41e6:	e1 e0       	ldi	r30, 0x01	; 1
    41e8:	f0 e0       	ldi	r31, 0x00	; 0
    41ea:	ec 0f       	add	r30, r28
    41ec:	fd 1f       	adc	r31, r29
    41ee:	e8 0f       	add	r30, r24
    41f0:	f1 1d       	adc	r31, r1
    41f2:	90 83       	st	Z, r25
else if (j==12) NoExtension=TRUE;	

for(k=0; k<j; k++) //setting file name
  fileNameFAT[k] = fileName[k];

for(k=j; k<=7; k++) //filling file name trail with blanks
    41f4:	8f 5f       	subi	r24, 0xFF	; 255
    41f6:	88 30       	cpi	r24, 0x08	; 8
    41f8:	b0 f3       	brcs	.-20     	; 0x41e6 <convertFileName+0x6a>
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
    41fa:	4c 30       	cpi	r20, 0x0C	; 12
    41fc:	09 f0       	breq	.+2      	; 0x4200 <convertFileName+0x84>
    41fe:	4f 5f       	subi	r20, 0xFF	; 255
{
bool NoExtension = FALSE;
unsigned char fileNameFAT[11];
unsigned char j, k;

for(j=0; j<12; j++)
    4200:	88 e0       	ldi	r24, 0x08	; 8
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(fileName[j] != 0)
    4202:	f9 01       	movw	r30, r18
    4204:	e4 0f       	add	r30, r20
    4206:	f1 1d       	adc	r31, r1
    4208:	90 81       	ld	r25, Z
    420a:	99 23       	and	r25, r25
    420c:	19 f4       	brne	.+6      	; 0x4214 <convertFileName+0x98>
    fileNameFAT[k] = fileName[j++];
  else //filling extension trail with blanks
    while(k<11)
    420e:	8b 30       	cpi	r24, 0x0B	; 11
    4210:	50 f0       	brcs	.+20     	; 0x4226 <convertFileName+0xaa>
    4212:	15 c0       	rjmp	.+42     	; 0x423e <convertFileName+0xc2>

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
{
  if(fileName[j] != 0)
    fileNameFAT[k] = fileName[j++];
    4214:	e1 e0       	ldi	r30, 0x01	; 1
    4216:	f0 e0       	ldi	r31, 0x00	; 0
    4218:	ec 0f       	add	r30, r28
    421a:	fd 1f       	adc	r31, r29
    421c:	e8 0f       	add	r30, r24
    421e:	f1 1d       	adc	r31, r1
    4220:	90 83       	st	Z, r25
    4222:	4f 5f       	subi	r20, 0xFF	; 255
    4224:	0c c0       	rjmp	.+24     	; 0x423e <convertFileName+0xc2>
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
    4226:	90 e2       	ldi	r25, 0x20	; 32
    4228:	e1 e0       	ldi	r30, 0x01	; 1
    422a:	f0 e0       	ldi	r31, 0x00	; 0
    422c:	ec 0f       	add	r30, r28
    422e:	fd 1f       	adc	r31, r29
    4230:	e8 0f       	add	r30, r24
    4232:	f1 1d       	adc	r31, r1
    4234:	90 83       	st	Z, r25
    4236:	8f 5f       	subi	r24, 0xFF	; 255
for(k=8; k<11; k++) //setting file extension
{
  if(fileName[j] != 0)
    fileNameFAT[k] = fileName[j++];
  else //filling extension trail with blanks
    while(k<11)
    4238:	8b 30       	cpi	r24, 0x0B	; 11
    423a:	b1 f7       	brne	.-20     	; 0x4228 <convertFileName+0xac>
    423c:	03 c0       	rjmp	.+6      	; 0x4244 <convertFileName+0xc8>

for(k=j; k<=7; k++) //filling file name trail with blanks
  fileNameFAT[k] = ' ';

if(!NoExtension) j++;
for(k=8; k<11; k++) //setting file extension
    423e:	8f 5f       	subi	r24, 0xFF	; 255
    4240:	8b 30       	cpi	r24, 0x0B	; 11
    4242:	f8 f2       	brcs	.-66     	; 0x4202 <convertFileName+0x86>
    4244:	fe 01       	movw	r30, r28
    4246:	31 96       	adiw	r30, 0x01	; 1
//***************************************************************************
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
    4248:	ce 01       	movw	r24, r28
    424a:	0c 96       	adiw	r24, 0x0c	; 12
    424c:	df 01       	movw	r26, r30
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    424e:	4c 91       	ld	r20, X
    4250:	54 2f       	mov	r21, r20
    4252:	51 56       	subi	r21, 0x61	; 97
    4254:	5a 31       	cpi	r21, 0x1A	; 26
    4256:	10 f4       	brcc	.+4      	; 0x425c <convertFileName+0xe0>
    fileNameFAT[j] -= 0x20;
    4258:	40 52       	subi	r20, 0x20	; 32
    425a:	4c 93       	st	X, r20
    425c:	11 96       	adiw	r26, 0x01	; 1
  else //filling extension trail with blanks
    while(k<11)
      fileNameFAT[k++] = ' ';
}

for(j=0; j<11; j++) //converting small letters to caps
    425e:	a8 17       	cp	r26, r24
    4260:	b9 07       	cpc	r27, r25
    4262:	a9 f7       	brne	.-22     	; 0x424e <convertFileName+0xd2>
    4264:	d9 01       	movw	r26, r18
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
  fileName[j] = fileNameFAT[j];
    4266:	21 91       	ld	r18, Z+
    4268:	2d 93       	st	X+, r18

for(j=0; j<11; j++) //converting small letters to caps
  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    fileNameFAT[j] -= 0x20;

for(j=0; j<11; j++)
    426a:	e8 17       	cp	r30, r24
    426c:	f9 07       	cpc	r31, r25
    426e:	d9 f7       	brne	.-10     	; 0x4266 <convertFileName+0xea>
  fileName[j] = fileNameFAT[j];

return 0;
    4270:	80 e0       	ldi	r24, 0x00	; 0
    4272:	01 c0       	rjmp	.+2      	; 0x4276 <convertFileName+0xfa>

for(j=0; j<12; j++)
if(fileName[j] == '.') break;

if(j>8 && j<12) {//Invalid fileName
	return 1;}
    4274:	81 e0       	ldi	r24, 0x01	; 1

for(j=0; j<11; j++)
  fileName[j] = fileNameFAT[j];

return 0;
}
    4276:	2b 96       	adiw	r28, 0x0b	; 11
    4278:	cd bf       	out	0x3d, r28	; 61
    427a:	de bf       	out	0x3e, r29	; 62
    427c:	df 91       	pop	r29
    427e:	cf 91       	pop	r28
    4280:	08 95       	ret

00004282 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    4282:	4f 92       	push	r4
    4284:	5f 92       	push	r5
    4286:	6f 92       	push	r6
    4288:	7f 92       	push	r7
    428a:	8f 92       	push	r8
    428c:	9f 92       	push	r9
    428e:	af 92       	push	r10
    4290:	bf 92       	push	r11
    4292:	cf 92       	push	r12
    4294:	df 92       	push	r13
    4296:	ef 92       	push	r14
    4298:	ff 92       	push	r15
    429a:	cf 93       	push	r28
    429c:	df 93       	push	r29
    429e:	2b 01       	movw	r4, r22
    42a0:	3c 01       	movw	r6, r24
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    42a2:	20 e8       	ldi	r18, 0x80	; 128
    42a4:	3f ef       	ldi	r19, 0xFF	; 255
    42a6:	4f ef       	ldi	r20, 0xFF	; 255
    42a8:	5f ef       	ldi	r21, 0xFF	; 255
    42aa:	42 22       	and	r4, r18
    42ac:	53 22       	and	r5, r19
    42ae:	64 22       	and	r6, r20
    42b0:	75 22       	and	r7, r21
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    42b2:	80 91 3c 40 	lds	r24, 0x403C
    42b6:	90 91 3d 40 	lds	r25, 0x403D
    42ba:	a0 91 3e 40 	lds	r26, 0x403E
    42be:	b0 91 3f 40 	lds	r27, 0x403F
    42c2:	48 16       	cp	r4, r24
    42c4:	59 06       	cpc	r5, r25
    42c6:	6a 06       	cpc	r6, r26
    42c8:	7b 06       	cpc	r7, r27
    42ca:	08 f0       	brcs	.+2      	; 0x42ce <searchNextFreeCluster+0x4c>
    42cc:	77 c0       	rjmp	.+238    	; 0x43bc <searchNextFreeCluster+0x13a>
    42ce:	53 01       	movw	r10, r6
    42d0:	42 01       	movw	r8, r4
    42d2:	88 0c       	add	r8, r8
    42d4:	99 1c       	adc	r9, r9
    42d6:	aa 1c       	adc	r10, r10
    42d8:	bb 1c       	adc	r11, r11
    42da:	88 0c       	add	r8, r8
    42dc:	99 1c       	adc	r9, r9
    42de:	aa 1c       	adc	r10, r10
    42e0:	bb 1c       	adc	r11, r11
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
    42e2:	c9 eb       	ldi	r28, 0xB9	; 185
    42e4:	d1 e2       	ldi	r29, 0x21	; 33
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    42e6:	c0 90 5f 50 	lds	r12, 0x505F
    42ea:	d0 90 60 50 	lds	r13, 0x5060
    42ee:	20 91 37 40 	lds	r18, 0x4037
    42f2:	30 91 38 40 	lds	r19, 0x4038
    42f6:	ee 24       	eor	r14, r14
    42f8:	ff 24       	eor	r15, r15
    42fa:	80 91 59 50 	lds	r24, 0x5059
    42fe:	90 91 5a 50 	lds	r25, 0x505A
    4302:	a0 91 5b 50 	lds	r26, 0x505B
    4306:	b0 91 5c 50 	lds	r27, 0x505C
    430a:	c8 0e       	add	r12, r24
    430c:	d9 1e       	adc	r13, r25
    430e:	ea 1e       	adc	r14, r26
    4310:	fb 1e       	adc	r15, r27
    4312:	40 e0       	ldi	r20, 0x00	; 0
    4314:	50 e0       	ldi	r21, 0x00	; 0
    4316:	c5 01       	movw	r24, r10
    4318:	b4 01       	movw	r22, r8
    431a:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    431e:	c7 01       	movw	r24, r14
    4320:	b6 01       	movw	r22, r12
    4322:	62 0f       	add	r22, r18
    4324:	73 1f       	adc	r23, r19
    4326:	84 1f       	adc	r24, r20
    4328:	95 1f       	adc	r25, r21
      SD_read_block(sector,SDBuffer);
    432a:	ae 01       	movw	r20, r28
    432c:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <SD_read_block>
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    4330:	88 81       	ld	r24, Y
    4332:	99 81       	ldd	r25, Y+1	; 0x01
    4334:	aa 81       	ldd	r26, Y+2	; 0x02
    4336:	bb 81       	ldd	r27, Y+3	; 0x03
    4338:	bf 70       	andi	r27, 0x0F	; 15
    433a:	00 97       	sbiw	r24, 0x00	; 0
    433c:	a1 05       	cpc	r26, r1
    433e:	b1 05       	cpc	r27, r1
    4340:	99 f0       	breq	.+38     	; 0x4368 <searchNextFreeCluster+0xe6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4342:	21 e0       	ldi	r18, 0x01	; 1
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
    4344:	e2 2f       	mov	r30, r18
    4346:	f0 e0       	ldi	r31, 0x00	; 0
    4348:	ee 0f       	add	r30, r30
    434a:	ff 1f       	adc	r31, r31
    434c:	ee 0f       	add	r30, r30
    434e:	ff 1f       	adc	r31, r31
    4350:	e7 54       	subi	r30, 0x47	; 71
    4352:	fe 4d       	sbci	r31, 0xDE	; 222
         if(((*value) & 0x0fffffff) == 0)
    4354:	80 81       	ld	r24, Z
    4356:	91 81       	ldd	r25, Z+1	; 0x01
    4358:	a2 81       	ldd	r26, Z+2	; 0x02
    435a:	b3 81       	ldd	r27, Z+3	; 0x03
    435c:	bf 70       	andi	r27, 0x0F	; 15
    435e:	00 97       	sbiw	r24, 0x00	; 0
    4360:	a1 05       	cpc	r26, r1
    4362:	b1 05       	cpc	r27, r1
    4364:	39 f4       	brne	.+14     	; 0x4374 <searchNextFreeCluster+0xf2>
    4366:	01 c0       	rjmp	.+2      	; 0x436a <searchNextFreeCluster+0xe8>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4368:	20 e0       	ldi	r18, 0x00	; 0
      {
       	 value = (unsigned long *) &SDBuffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
    436a:	42 0e       	add	r4, r18
    436c:	51 1c       	adc	r5, r1
    436e:	61 1c       	adc	r6, r1
    4370:	71 1c       	adc	r7, r1
    4372:	27 c0       	rjmp	.+78     	; 0x43c2 <searchNextFreeCluster+0x140>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_read_block(sector,SDBuffer);
      for(i=0; i<128; i++)
    4374:	2f 5f       	subi	r18, 0xFF	; 255
    4376:	32 f7       	brpl	.-52     	; 0x4344 <searchNextFreeCluster+0xc2>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    4378:	80 e8       	ldi	r24, 0x80	; 128
    437a:	90 e0       	ldi	r25, 0x00	; 0
    437c:	a0 e0       	ldi	r26, 0x00	; 0
    437e:	b0 e0       	ldi	r27, 0x00	; 0
    4380:	48 0e       	add	r4, r24
    4382:	59 1e       	adc	r5, r25
    4384:	6a 1e       	adc	r6, r26
    4386:	7b 1e       	adc	r7, r27
    4388:	80 91 3c 40 	lds	r24, 0x403C
    438c:	90 91 3d 40 	lds	r25, 0x403D
    4390:	a0 91 3e 40 	lds	r26, 0x403E
    4394:	b0 91 3f 40 	lds	r27, 0x403F
    4398:	20 e0       	ldi	r18, 0x00	; 0
    439a:	32 e0       	ldi	r19, 0x02	; 2
    439c:	40 e0       	ldi	r20, 0x00	; 0
    439e:	50 e0       	ldi	r21, 0x00	; 0
    43a0:	82 0e       	add	r8, r18
    43a2:	93 1e       	adc	r9, r19
    43a4:	a4 1e       	adc	r10, r20
    43a6:	b5 1e       	adc	r11, r21
    43a8:	48 16       	cp	r4, r24
    43aa:	59 06       	cpc	r5, r25
    43ac:	6a 06       	cpc	r6, r26
    43ae:	7b 06       	cpc	r7, r27
    43b0:	08 f4       	brcc	.+2      	; 0x43b4 <searchNextFreeCluster+0x132>
    43b2:	99 cf       	rjmp	.-206    	; 0x42e6 <searchNextFreeCluster+0x64>
         if(((*value) & 0x0fffffff) == 0)
            return(cluster+i);
      }  
    } 

 return 0;
    43b4:	44 24       	eor	r4, r4
    43b6:	55 24       	eor	r5, r5
    43b8:	32 01       	movw	r6, r4
    43ba:	03 c0       	rjmp	.+6      	; 0x43c2 <searchNextFreeCluster+0x140>
    43bc:	44 24       	eor	r4, r4
    43be:	55 24       	eor	r5, r5
    43c0:	32 01       	movw	r6, r4
}
    43c2:	64 2d       	mov	r22, r4
    43c4:	75 2d       	mov	r23, r5
    43c6:	86 2d       	mov	r24, r6
    43c8:	97 2d       	mov	r25, r7
    43ca:	df 91       	pop	r29
    43cc:	cf 91       	pop	r28
    43ce:	ff 90       	pop	r15
    43d0:	ef 90       	pop	r14
    43d2:	df 90       	pop	r13
    43d4:	cf 90       	pop	r12
    43d6:	bf 90       	pop	r11
    43d8:	af 90       	pop	r10
    43da:	9f 90       	pop	r9
    43dc:	8f 90       	pop	r8
    43de:	7f 90       	pop	r7
    43e0:	6f 90       	pop	r6
    43e2:	5f 90       	pop	r5
    43e4:	4f 90       	pop	r4
    43e6:	08 95       	ret

000043e8 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    43e8:	cf 92       	push	r12
    43ea:	df 92       	push	r13
    43ec:	ef 92       	push	r14
    43ee:	ff 92       	push	r15
    43f0:	cf 93       	push	r28
    43f2:	c8 2f       	mov	r28, r24
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    43f4:	db 01       	movw	r26, r22
    43f6:	ca 01       	movw	r24, r20
    43f8:	91 70       	andi	r25, 0x01	; 1
    43fa:	a0 70       	andi	r26, 0x00	; 0
    43fc:	b0 70       	andi	r27, 0x00	; 0
    43fe:	00 97       	sbiw	r24, 0x00	; 0
    4400:	a1 05       	cpc	r26, r1
    4402:	b1 05       	cpc	r27, r1
    4404:	51 f4       	brne	.+20     	; 0x441a <freeMemoryUpdate+0x32>
    4406:	03 2e       	mov	r0, r19
    4408:	39 e0       	ldi	r19, 0x09	; 9
    440a:	76 95       	lsr	r23
    440c:	67 95       	ror	r22
    440e:	57 95       	ror	r21
    4410:	47 95       	ror	r20
    4412:	3a 95       	dec	r19
    4414:	d1 f7       	brne	.-12     	; 0x440a <freeMemoryUpdate+0x22>
    4416:	30 2d       	mov	r19, r0
    4418:	0d c0       	rjmp	.+26     	; 0x4434 <freeMemoryUpdate+0x4c>
  else size = (size / 512) +1;
    441a:	03 2e       	mov	r0, r19
    441c:	39 e0       	ldi	r19, 0x09	; 9
    441e:	76 95       	lsr	r23
    4420:	67 95       	ror	r22
    4422:	57 95       	ror	r21
    4424:	47 95       	ror	r20
    4426:	3a 95       	dec	r19
    4428:	d1 f7       	brne	.-12     	; 0x441e <freeMemoryUpdate+0x36>
    442a:	30 2d       	mov	r19, r0
    442c:	4f 5f       	subi	r20, 0xFF	; 255
    442e:	5f 4f       	sbci	r21, 0xFF	; 255
    4430:	6f 4f       	sbci	r22, 0xFF	; 255
    4432:	7f 4f       	sbci	r23, 0xFF	; 255
  if((size % 8) == 0) size = size / 8;
    4434:	db 01       	movw	r26, r22
    4436:	ca 01       	movw	r24, r20
    4438:	87 70       	andi	r24, 0x07	; 7
    443a:	90 70       	andi	r25, 0x00	; 0
    443c:	a0 70       	andi	r26, 0x00	; 0
    443e:	b0 70       	andi	r27, 0x00	; 0
    4440:	00 97       	sbiw	r24, 0x00	; 0
    4442:	a1 05       	cpc	r26, r1
    4444:	b1 05       	cpc	r27, r1
    4446:	59 f4       	brne	.+22     	; 0x445e <freeMemoryUpdate+0x76>
    4448:	6a 01       	movw	r12, r20
    444a:	7b 01       	movw	r14, r22
    444c:	68 94       	set
    444e:	12 f8       	bld	r1, 2
    4450:	f6 94       	lsr	r15
    4452:	e7 94       	ror	r14
    4454:	d7 94       	ror	r13
    4456:	c7 94       	ror	r12
    4458:	16 94       	lsr	r1
    445a:	d1 f7       	brne	.-12     	; 0x4450 <freeMemoryUpdate+0x68>
    445c:	0f c0       	rjmp	.+30     	; 0x447c <freeMemoryUpdate+0x94>
  else size = (size / 8) +1;
    445e:	6a 01       	movw	r12, r20
    4460:	7b 01       	movw	r14, r22
    4462:	68 94       	set
    4464:	12 f8       	bld	r1, 2
    4466:	f6 94       	lsr	r15
    4468:	e7 94       	ror	r14
    446a:	d7 94       	ror	r13
    446c:	c7 94       	ror	r12
    446e:	16 94       	lsr	r1
    4470:	d1 f7       	brne	.-12     	; 0x4466 <freeMemoryUpdate+0x7e>
    4472:	08 94       	sec
    4474:	c1 1c       	adc	r12, r1
    4476:	d1 1c       	adc	r13, r1
    4478:	e1 1c       	adc	r14, r1
    447a:	f1 1c       	adc	r15, r1

  if(freeClusterCountUpdated)
    447c:	80 91 ab 50 	lds	r24, 0x50AB
    4480:	88 23       	and	r24, r24
    4482:	d1 f0       	breq	.+52     	; 0x44b8 <freeMemoryUpdate+0xd0>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    4484:	81 e0       	ldi	r24, 0x01	; 1
    4486:	60 e0       	ldi	r22, 0x00	; 0
    4488:	20 e0       	ldi	r18, 0x00	; 0
    448a:	30 e0       	ldi	r19, 0x00	; 0
    448c:	a9 01       	movw	r20, r18
    448e:	0e 94 31 1f 	call	0x3e62	; 0x3e62 <getSetFreeCluster>
	if(flag == ADD)
    4492:	cc 23       	and	r28, r28
    4494:	39 f4       	brne	.+14     	; 0x44a4 <freeMemoryUpdate+0xbc>
  	   freeClusters = freeClusters + size;
    4496:	9b 01       	movw	r18, r22
    4498:	ac 01       	movw	r20, r24
    449a:	2c 0d       	add	r18, r12
    449c:	3d 1d       	adc	r19, r13
    449e:	4e 1d       	adc	r20, r14
    44a0:	5f 1d       	adc	r21, r15
    44a2:	06 c0       	rjmp	.+12     	; 0x44b0 <freeMemoryUpdate+0xc8>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    44a4:	9b 01       	movw	r18, r22
    44a6:	ac 01       	movw	r20, r24
    44a8:	2c 19       	sub	r18, r12
    44aa:	3d 09       	sbc	r19, r13
    44ac:	4e 09       	sbc	r20, r14
    44ae:	5f 09       	sbc	r21, r15
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    44b0:	81 e0       	ldi	r24, 0x01	; 1
    44b2:	61 e0       	ldi	r22, 0x01	; 1
    44b4:	0e 94 31 1f 	call	0x3e62	; 0x3e62 <getSetFreeCluster>
  }
}
    44b8:	cf 91       	pop	r28
    44ba:	ff 90       	pop	r15
    44bc:	ef 90       	pop	r14
    44be:	df 90       	pop	r13
    44c0:	cf 90       	pop	r12
    44c2:	08 95       	ret

000044c4 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    44c4:	2f 92       	push	r2
    44c6:	3f 92       	push	r3
    44c8:	4f 92       	push	r4
    44ca:	5f 92       	push	r5
    44cc:	6f 92       	push	r6
    44ce:	7f 92       	push	r7
    44d0:	8f 92       	push	r8
    44d2:	9f 92       	push	r9
    44d4:	af 92       	push	r10
    44d6:	bf 92       	push	r11
    44d8:	cf 92       	push	r12
    44da:	df 92       	push	r13
    44dc:	ef 92       	push	r14
    44de:	ff 92       	push	r15
    44e0:	0f 93       	push	r16
    44e2:	1f 93       	push	r17
    44e4:	cf 93       	push	r28
    44e6:	df 93       	push	r29
    44e8:	cd b7       	in	r28, 0x3d	; 61
    44ea:	de b7       	in	r29, 0x3e	; 62
    44ec:	2c 97       	sbiw	r28, 0x0c	; 12
    44ee:	cd bf       	out	0x3d, r28	; 61
    44f0:	de bf       	out	0x3e, r29	; 62
    44f2:	88 2e       	mov	r8, r24
    44f4:	7b 01       	movw	r14, r22
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    44f6:	80 91 41 40 	lds	r24, 0x4041
    44fa:	90 91 42 40 	lds	r25, 0x4042
    44fe:	a0 91 43 40 	lds	r26, 0x4043
    4502:	b0 91 44 40 	lds	r27, 0x4044
    4506:	89 87       	std	Y+9, r24	; 0x09
    4508:	9a 87       	std	Y+10, r25	; 0x0a
    450a:	ab 87       	std	Y+11, r26	; 0x0b
    450c:	bc 87       	std	Y+12, r27	; 0x0c
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    450e:	0f 2e       	mov	r0, r31
    4510:	f9 eb       	ldi	r31, 0xB9	; 185
    4512:	2f 2e       	mov	r2, r31
    4514:	f1 e2       	ldi	r31, 0x21	; 33
    4516:	3f 2e       	mov	r3, r31
    4518:	f0 2d       	mov	r31, r0
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    451a:	c8 2c       	mov	r12, r8
    451c:	ca 94       	dec	r12
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    451e:	d2 2c       	mov	r13, r2
    4520:	93 2c       	mov	r9, r3
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    4522:	5b 01       	movw	r10, r22
    4524:	08 94       	sec
    4526:	a1 1c       	adc	r10, r1
    4528:	b1 1c       	adc	r11, r1

cluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (cluster);
    452a:	69 85       	ldd	r22, Y+9	; 0x09
    452c:	7a 85       	ldd	r23, Y+10	; 0x0a
    452e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4530:	9c 85       	ldd	r25, Y+12	; 0x0c
    4532:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <getFirstSector>
    4536:	6d 83       	std	Y+5, r22	; 0x05
    4538:	7e 83       	std	Y+6, r23	; 0x06
    453a:	8f 83       	std	Y+7, r24	; 0x07
    453c:	98 87       	std	Y+8, r25	; 0x08

   for(sector = 0; sector < sectorPerCluster; sector++)
    453e:	80 91 57 50 	lds	r24, 0x5057
    4542:	90 91 58 50 	lds	r25, 0x5058
    4546:	00 97       	sbiw	r24, 0x00	; 0
    4548:	09 f4       	brne	.+2      	; 0x454c <findFiles+0x88>
    454a:	13 c1       	rjmp	.+550    	; 0x4772 <findFiles+0x2ae>
    454c:	44 24       	eor	r4, r4
    454e:	55 24       	eor	r5, r5
    4550:	32 01       	movw	r6, r4
    4552:	1c 2d       	mov	r17, r12
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4554:	8d 81       	ldd	r24, Y+5	; 0x05
    4556:	9e 81       	ldd	r25, Y+6	; 0x06
    4558:	af 81       	ldd	r26, Y+7	; 0x07
    455a:	b8 85       	ldd	r27, Y+8	; 0x08
    455c:	84 0d       	add	r24, r4
    455e:	95 1d       	adc	r25, r5
    4560:	a6 1d       	adc	r26, r6
    4562:	b7 1d       	adc	r27, r7
    4564:	89 83       	std	Y+1, r24	; 0x01
    4566:	9a 83       	std	Y+2, r25	; 0x02
    4568:	ab 83       	std	Y+3, r26	; 0x03
    456a:	bc 83       	std	Y+4, r27	; 0x04
    456c:	bc 01       	movw	r22, r24
    456e:	cd 01       	movw	r24, r26
    4570:	4d 2d       	mov	r20, r13
    4572:	59 2d       	mov	r21, r9
    4574:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <SD_read_block>
	

     for(i=0; i<bytesPerSector; i+=32)
    4578:	80 91 37 40 	lds	r24, 0x4037
    457c:	90 91 38 40 	lds	r25, 0x4038
    4580:	00 97       	sbiw	r24, 0x00	; 0
    4582:	09 f4       	brne	.+2      	; 0x4586 <findFiles+0xc2>
    4584:	e4 c0       	rjmp	.+456    	; 0x474e <findFiles+0x28a>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    4586:	d1 01       	movw	r26, r2
    4588:	8c 91       	ld	r24, X
    458a:	88 23       	and	r24, r24
    458c:	09 f4       	brne	.+2      	; 0x4590 <findFiles+0xcc>
    458e:	10 c1       	rjmp	.+544    	; 0x47b0 <findFiles+0x2ec>
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4590:	4d 2d       	mov	r20, r13
    4592:	59 2d       	mov	r21, r9
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    4594:	20 e0       	ldi	r18, 0x00	; 0
    4596:	30 e0       	ldi	r19, 0x00	; 0
    4598:	08 c0       	rjmp	.+16     	; 0x45aa <findFiles+0xe6>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    459a:	a9 01       	movw	r20, r18
    459c:	47 54       	subi	r20, 0x47	; 71
    459e:	5e 4d       	sbci	r21, 0xDE	; 222

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    45a0:	fa 01       	movw	r30, r20
    45a2:	80 81       	ld	r24, Z
    45a4:	88 23       	and	r24, r24
    45a6:	09 f4       	brne	.+2      	; 0x45aa <findFiles+0xe6>
    45a8:	06 c1       	rjmp	.+524    	; 0x47b6 <findFiles+0x2f2>
		{
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    45aa:	85 3e       	cpi	r24, 0xE5	; 229
    45ac:	09 f4       	brne	.+2      	; 0x45b0 <findFiles+0xec>
    45ae:	c5 c0       	rjmp	.+394    	; 0x473a <findFiles+0x276>
    45b0:	da 01       	movw	r26, r20
    45b2:	1b 96       	adiw	r26, 0x0b	; 11
    45b4:	8c 91       	ld	r24, X
    45b6:	1b 97       	sbiw	r26, 0x0b	; 11
    45b8:	8f 30       	cpi	r24, 0x0F	; 15
    45ba:	09 f4       	brne	.+2      	; 0x45be <findFiles+0xfa>
    45bc:	be c0       	rjmp	.+380    	; 0x473a <findFiles+0x276>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    45be:	12 30       	cpi	r17, 0x02	; 2
    45c0:	08 f0       	brcs	.+2      	; 0x45c4 <findFiles+0x100>
    45c2:	fc c0       	rjmp	.+504    	; 0x47bc <findFiles+0x2f8>
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    45c4:	9c 91       	ld	r25, X
    45c6:	f7 01       	movw	r30, r14
    45c8:	80 81       	ld	r24, Z
    45ca:	98 17       	cp	r25, r24
    45cc:	09 f0       	breq	.+2      	; 0x45d0 <findFiles+0x10c>
    45ce:	b5 c0       	rjmp	.+362    	; 0x473a <findFiles+0x276>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
    45d0:	fa 01       	movw	r30, r20
    45d2:	31 96       	adiw	r30, 0x01	; 1
    45d4:	d5 01       	movw	r26, r10
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    45d6:	81 e0       	ldi	r24, 0x01	; 1
    45d8:	ba 01       	movw	r22, r20
            if(dir->name[j] != fileName[j]) break;
    45da:	41 91       	ld	r20, Z+
    45dc:	9d 91       	ld	r25, X+
    45de:	49 17       	cp	r20, r25
    45e0:	31 f4       	brne	.+12     	; 0x45ee <findFiles+0x12a>
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    45e2:	8f 5f       	subi	r24, 0xFF	; 255
    45e4:	8b 30       	cpi	r24, 0x0B	; 11
    45e6:	c9 f7       	brne	.-14     	; 0x45da <findFiles+0x116>
    45e8:	8b 01       	movw	r16, r22
    45ea:	6b 01       	movw	r12, r22
    45ec:	05 c0       	rjmp	.+10     	; 0x45f8 <findFiles+0x134>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    45ee:	8b 30       	cpi	r24, 0x0B	; 11
    45f0:	09 f0       	breq	.+2      	; 0x45f4 <findFiles+0x130>
    45f2:	a3 c0       	rjmp	.+326    	; 0x473a <findFiles+0x276>
    45f4:	8b 01       	movw	r16, r22
    45f6:	6b 01       	movw	r12, r22
			{
			  if(flag == GET_FILE)
    45f8:	f1 e0       	ldi	r31, 0x01	; 1
    45fa:	8f 16       	cp	r8, r31
    45fc:	09 f0       	breq	.+2      	; 0x4600 <findFiles+0x13c>
    45fe:	41 c0       	rjmp	.+130    	; 0x4682 <findFiles+0x1be>
              {
			    appendFileSector = firstSector + sector;
    4600:	89 81       	ldd	r24, Y+1	; 0x01
    4602:	9a 81       	ldd	r25, Y+2	; 0x02
    4604:	ab 81       	ldd	r26, Y+3	; 0x03
    4606:	bc 81       	ldd	r27, Y+4	; 0x04
    4608:	80 93 ac 50 	sts	0x50AC, r24
    460c:	90 93 ad 50 	sts	0x50AD, r25
    4610:	a0 93 ae 50 	sts	0x50AE, r26
    4614:	b0 93 af 50 	sts	0x50AF, r27
				appendFileLocation = i;
    4618:	c9 01       	movw	r24, r18
    461a:	a0 e0       	ldi	r26, 0x00	; 0
    461c:	b0 e0       	ldi	r27, 0x00	; 0
    461e:	80 93 ba 23 	sts	0x23BA, r24
    4622:	90 93 bb 23 	sts	0x23BB, r25
    4626:	a0 93 bc 23 	sts	0x23BC, r26
    462a:	b0 93 bd 23 	sts	0x23BD, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    462e:	d6 01       	movw	r26, r12
    4630:	54 96       	adiw	r26, 0x14	; 20
    4632:	4d 91       	ld	r20, X+
    4634:	5c 91       	ld	r21, X
    4636:	55 97       	sbiw	r26, 0x15	; 21
    4638:	60 e0       	ldi	r22, 0x00	; 0
    463a:	70 e0       	ldi	r23, 0x00	; 0
    463c:	ba 01       	movw	r22, r20
    463e:	55 27       	eor	r21, r21
    4640:	44 27       	eor	r20, r20
    4642:	5a 96       	adiw	r26, 0x1a	; 26
    4644:	8d 91       	ld	r24, X+
    4646:	9c 91       	ld	r25, X
    4648:	5b 97       	sbiw	r26, 0x1b	; 27
    464a:	a0 e0       	ldi	r26, 0x00	; 0
    464c:	b0 e0       	ldi	r27, 0x00	; 0
    464e:	84 2b       	or	r24, r20
    4650:	95 2b       	or	r25, r21
    4652:	a6 2b       	or	r26, r22
    4654:	b7 2b       	or	r27, r23
    4656:	80 93 63 50 	sts	0x5063, r24
    465a:	90 93 64 50 	sts	0x5064, r25
    465e:	a0 93 65 50 	sts	0x5065, r26
    4662:	b0 93 66 50 	sts	0x5066, r27
				fileSize = dir->fileSize;
    4666:	f6 01       	movw	r30, r12
    4668:	84 8d       	ldd	r24, Z+28	; 0x1c
    466a:	95 8d       	ldd	r25, Z+29	; 0x1d
    466c:	a6 8d       	ldd	r26, Z+30	; 0x1e
    466e:	b7 8d       	ldd	r27, Z+31	; 0x1f
    4670:	80 93 33 40 	sts	0x4033, r24
    4674:	90 93 34 40 	sts	0x4034, r25
    4678:	a0 93 35 40 	sts	0x4035, r26
    467c:	b0 93 36 40 	sts	0x4036, r27
			    return (dir);
    4680:	a5 c0       	rjmp	.+330    	; 0x47cc <findFiles+0x308>
			  }	
			  else    //when flag = DELETE
			  {
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4682:	d6 01       	movw	r26, r12
    4684:	54 96       	adiw	r26, 0x14	; 20
    4686:	8d 91       	ld	r24, X+
    4688:	9c 91       	ld	r25, X
    468a:	55 97       	sbiw	r26, 0x15	; 21
    468c:	a0 e0       	ldi	r26, 0x00	; 0
    468e:	b0 e0       	ldi	r27, 0x00	; 0
    4690:	3c 01       	movw	r6, r24
    4692:	55 24       	eor	r5, r5
    4694:	44 24       	eor	r4, r4
    4696:	f6 01       	movw	r30, r12
    4698:	82 8d       	ldd	r24, Z+26	; 0x1a
    469a:	93 8d       	ldd	r25, Z+27	; 0x1b
    469c:	a0 e0       	ldi	r26, 0x00	; 0
    469e:	b0 e0       	ldi	r27, 0x00	; 0
    46a0:	48 2a       	or	r4, r24
    46a2:	59 2a       	or	r5, r25
    46a4:	6a 2a       	or	r6, r26
    46a6:	7b 2a       	or	r7, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    46a8:	85 ee       	ldi	r24, 0xE5	; 229
    46aa:	80 83       	st	Z, r24
				 SD_write_block (firstSector+sector,SDBuffer,512);
    46ac:	69 81       	ldd	r22, Y+1	; 0x01
    46ae:	7a 81       	ldd	r23, Y+2	; 0x02
    46b0:	8b 81       	ldd	r24, Y+3	; 0x03
    46b2:	9c 81       	ldd	r25, Y+4	; 0x04
    46b4:	49 eb       	ldi	r20, 0xB9	; 185
    46b6:	51 e2       	ldi	r21, 0x21	; 33
    46b8:	20 e0       	ldi	r18, 0x00	; 0
    46ba:	32 e0       	ldi	r19, 0x02	; 2
    46bc:	0e 94 36 28 	call	0x506c	; 0x506c <SD_write_block>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    46c0:	d6 01       	movw	r26, r12
    46c2:	5c 96       	adiw	r26, 0x1c	; 28
    46c4:	4d 91       	ld	r20, X+
    46c6:	5d 91       	ld	r21, X+
    46c8:	6d 91       	ld	r22, X+
    46ca:	7c 91       	ld	r23, X
    46cc:	5f 97       	sbiw	r26, 0x1f	; 31
    46ce:	80 e0       	ldi	r24, 0x00	; 0
    46d0:	0e 94 f4 21 	call	0x43e8	; 0x43e8 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    46d4:	82 e0       	ldi	r24, 0x02	; 2
    46d6:	60 e0       	ldi	r22, 0x00	; 0
    46d8:	20 e0       	ldi	r18, 0x00	; 0
    46da:	30 e0       	ldi	r19, 0x00	; 0
    46dc:	a9 01       	movw	r20, r18
    46de:	0e 94 31 1f 	call	0x3e62	; 0x3e62 <getSetFreeCluster>
    46e2:	dc 01       	movw	r26, r24
    46e4:	cb 01       	movw	r24, r22
				 if(firstCluster < cluster)
    46e6:	48 16       	cp	r4, r24
    46e8:	59 06       	cpc	r5, r25
    46ea:	6a 06       	cpc	r6, r26
    46ec:	7b 06       	cpc	r7, r27
    46ee:	30 f4       	brcc	.+12     	; 0x46fc <findFiles+0x238>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    46f0:	82 e0       	ldi	r24, 0x02	; 2
    46f2:	61 e0       	ldi	r22, 0x01	; 1
    46f4:	a3 01       	movw	r20, r6
    46f6:	92 01       	movw	r18, r4
    46f8:	0e 94 31 1f 	call	0x3e62	; 0x3e62 <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    46fc:	c3 01       	movw	r24, r6
    46fe:	b2 01       	movw	r22, r4
    4700:	40 e0       	ldi	r20, 0x00	; 0
    4702:	00 e0       	ldi	r16, 0x00	; 0
    4704:	10 e0       	ldi	r17, 0x00	; 0
    4706:	98 01       	movw	r18, r16
    4708:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <getSetNextCluster>
    470c:	6b 01       	movw	r12, r22
    470e:	7c 01       	movw	r14, r24
					getSetNextCluster (firstCluster, SET, 0);
    4710:	c3 01       	movw	r24, r6
    4712:	b2 01       	movw	r22, r4
    4714:	41 e0       	ldi	r20, 0x01	; 1
    4716:	00 e0       	ldi	r16, 0x00	; 0
    4718:	10 e0       	ldi	r17, 0x00	; 0
    471a:	98 01       	movw	r18, r16
    471c:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <getSetNextCluster>
					if(nextCluster > 0x0ffffff6) 
    4720:	b7 ef       	ldi	r27, 0xF7	; 247
    4722:	cb 16       	cp	r12, r27
    4724:	bf ef       	ldi	r27, 0xFF	; 255
    4726:	db 06       	cpc	r13, r27
    4728:	bf ef       	ldi	r27, 0xFF	; 255
    472a:	eb 06       	cpc	r14, r27
    472c:	bf e0       	ldi	r27, 0x0F	; 15
    472e:	fb 06       	cpc	r15, r27
    4730:	08 f0       	brcs	.+2      	; 0x4734 <findFiles+0x270>
    4732:	47 c0       	rjmp	.+142    	; 0x47c2 <findFiles+0x2fe>
					   {//file deleted
						   return 0;}
					firstCluster = nextCluster;
    4734:	26 01       	movw	r4, r12
    4736:	37 01       	movw	r6, r14
    4738:	e1 cf       	rjmp	.-62     	; 0x46fc <findFiles+0x238>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(i=0; i<bytesPerSector; i+=32)
    473a:	20 5e       	subi	r18, 0xE0	; 224
    473c:	3f 4f       	sbci	r19, 0xFF	; 255
    473e:	80 91 37 40 	lds	r24, 0x4037
    4742:	90 91 38 40 	lds	r25, 0x4038
    4746:	28 17       	cp	r18, r24
    4748:	39 07       	cpc	r19, r25
    474a:	08 f4       	brcc	.+2      	; 0x474e <findFiles+0x28a>
    474c:	26 cf       	rjmp	.-436    	; 0x459a <findFiles+0xd6>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    474e:	08 94       	sec
    4750:	41 1c       	adc	r4, r1
    4752:	51 1c       	adc	r5, r1
    4754:	61 1c       	adc	r6, r1
    4756:	71 1c       	adc	r7, r1
    4758:	80 91 57 50 	lds	r24, 0x5057
    475c:	90 91 58 50 	lds	r25, 0x5058
    4760:	a0 e0       	ldi	r26, 0x00	; 0
    4762:	b0 e0       	ldi	r27, 0x00	; 0
    4764:	48 16       	cp	r4, r24
    4766:	59 06       	cpc	r5, r25
    4768:	6a 06       	cpc	r6, r26
    476a:	7b 06       	cpc	r7, r27
    476c:	08 f4       	brcc	.+2      	; 0x4770 <findFiles+0x2ac>
    476e:	f2 ce       	rjmp	.-540    	; 0x4554 <findFiles+0x90>
    4770:	c1 2e       	mov	r12, r17
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    4772:	69 85       	ldd	r22, Y+9	; 0x09
    4774:	7a 85       	ldd	r23, Y+10	; 0x0a
    4776:	8b 85       	ldd	r24, Y+11	; 0x0b
    4778:	9c 85       	ldd	r25, Y+12	; 0x0c
    477a:	40 e0       	ldi	r20, 0x00	; 0
    477c:	00 e0       	ldi	r16, 0x00	; 0
    477e:	10 e0       	ldi	r17, 0x00	; 0
    4780:	98 01       	movw	r18, r16
    4782:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <getSetNextCluster>
    4786:	69 87       	std	Y+9, r22	; 0x09
    4788:	7a 87       	std	Y+10, r23	; 0x0a
    478a:	8b 87       	std	Y+11, r24	; 0x0b
    478c:	9c 87       	std	Y+12, r25	; 0x0c

   if(cluster > 0x0ffffff6)
    478e:	67 3f       	cpi	r22, 0xF7	; 247
    4790:	ef ef       	ldi	r30, 0xFF	; 255
    4792:	7e 07       	cpc	r23, r30
    4794:	ef ef       	ldi	r30, 0xFF	; 255
    4796:	8e 07       	cpc	r24, r30
    4798:	ef e0       	ldi	r30, 0x0F	; 15
    479a:	9e 07       	cpc	r25, r30
    479c:	a8 f4       	brcc	.+42     	; 0x47c8 <findFiles+0x304>
   	 return 0;
   if(cluster == 0) 
    479e:	61 15       	cp	r22, r1
    47a0:	71 05       	cpc	r23, r1
    47a2:	81 05       	cpc	r24, r1
    47a4:	91 05       	cpc	r25, r1
    47a6:	09 f0       	breq	.+2      	; 0x47aa <findFiles+0x2e6>
    47a8:	c0 ce       	rjmp	.-640    	; 0x452a <findFiles+0x66>
   {//error in getting cluster
	   return 0;}
    47aa:	00 e0       	ldi	r16, 0x00	; 0
    47ac:	10 e0       	ldi	r17, 0x00	; 0
    47ae:	0e c0       	rjmp	.+28     	; 0x47cc <findFiles+0x308>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
		{
		  return 0;   
    47b0:	00 e0       	ldi	r16, 0x00	; 0
    47b2:	10 e0       	ldi	r17, 0x00	; 0
    47b4:	0b c0       	rjmp	.+22     	; 0x47cc <findFiles+0x308>
    47b6:	00 e0       	ldi	r16, 0x00	; 0
    47b8:	10 e0       	ldi	r17, 0x00	; 0
    47ba:	08 c0       	rjmp	.+16     	; 0x47cc <findFiles+0x308>
			  }
            }
          }
          else  //invalid flag
		  {
			  return 0;
    47bc:	00 e0       	ldi	r16, 0x00	; 0
    47be:	10 e0       	ldi	r17, 0x00	; 0
    47c0:	05 c0       	rjmp	.+10     	; 0x47cc <findFiles+0x308>
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
					getSetNextCluster (firstCluster, SET, 0);
					if(nextCluster > 0x0ffffff6) 
					   {//file deleted
						   return 0;}
    47c2:	00 e0       	ldi	r16, 0x00	; 0
    47c4:	10 e0       	ldi	r17, 0x00	; 0
    47c6:	02 c0       	rjmp	.+4      	; 0x47cc <findFiles+0x308>
   }

   cluster = (getSetNextCluster (cluster, GET, 0));

   if(cluster > 0x0ffffff6)
   	 return 0;
    47c8:	00 e0       	ldi	r16, 0x00	; 0
    47ca:	10 e0       	ldi	r17, 0x00	; 0
   if(cluster == 0) 
   {//error in getting cluster
	   return 0;}
 }
return 0;
}
    47cc:	80 2f       	mov	r24, r16
    47ce:	91 2f       	mov	r25, r17
    47d0:	2c 96       	adiw	r28, 0x0c	; 12
    47d2:	cd bf       	out	0x3d, r28	; 61
    47d4:	de bf       	out	0x3e, r29	; 62
    47d6:	df 91       	pop	r29
    47d8:	cf 91       	pop	r28
    47da:	1f 91       	pop	r17
    47dc:	0f 91       	pop	r16
    47de:	ff 90       	pop	r15
    47e0:	ef 90       	pop	r14
    47e2:	df 90       	pop	r13
    47e4:	cf 90       	pop	r12
    47e6:	bf 90       	pop	r11
    47e8:	af 90       	pop	r10
    47ea:	9f 90       	pop	r9
    47ec:	8f 90       	pop	r8
    47ee:	7f 90       	pop	r7
    47f0:	6f 90       	pop	r6
    47f2:	5f 90       	pop	r5
    47f4:	4f 90       	pop	r4
    47f6:	3f 90       	pop	r3
    47f8:	2f 90       	pop	r2
    47fa:	08 95       	ret

000047fc <deleteFile>:
//Function: to delete a specified file from the root directory
//Arguments: pointer to the file name
//return: none
//********************************************************************
void deleteFile (unsigned char *fileName)
{
    47fc:	cf 93       	push	r28
    47fe:	df 93       	push	r29
    4800:	ec 01       	movw	r28, r24
  unsigned char error;

  error = convertFileName (fileName);
    4802:	0e 94 be 20 	call	0x417c	; 0x417c <convertFileName>
  if(error) return;
    4806:	88 23       	and	r24, r24
    4808:	21 f4       	brne	.+8      	; 0x4812 <deleteFile+0x16>

  findFiles (DELETE, fileName);
    480a:	82 e0       	ldi	r24, 0x02	; 2
    480c:	be 01       	movw	r22, r28
    480e:	0e 94 62 22 	call	0x44c4	; 0x44c4 <findFiles>
}
    4812:	df 91       	pop	r29
    4814:	cf 91       	pop	r28
    4816:	08 95       	ret

00004818 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY; or if flag=READ and file does not exist
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    4818:	4f 92       	push	r4
    481a:	5f 92       	push	r5
    481c:	6f 92       	push	r6
    481e:	7f 92       	push	r7
    4820:	af 92       	push	r10
    4822:	bf 92       	push	r11
    4824:	cf 92       	push	r12
    4826:	df 92       	push	r13
    4828:	ef 92       	push	r14
    482a:	ff 92       	push	r15
    482c:	0f 93       	push	r16
    482e:	1f 93       	push	r17
    4830:	cf 93       	push	r28
    4832:	df 93       	push	r29
    4834:	18 2f       	mov	r17, r24
    4836:	eb 01       	movw	r28, r22
struct dir_Structure *dir;
unsigned long cluster, byteCounter = 0, fileSize, firstSector;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
    4838:	cb 01       	movw	r24, r22
    483a:	0e 94 be 20 	call	0x417c	; 0x417c <convertFileName>
if(error) return 2;
    483e:	88 23       	and	r24, r24
    4840:	09 f0       	breq	.+2      	; 0x4844 <readFile+0x2c>
    4842:	56 c0       	rjmp	.+172    	; 0x48f0 <readFile+0xd8>

dir = findFiles (GET_FILE, fileName); //get the file location
    4844:	81 e0       	ldi	r24, 0x01	; 1
    4846:	be 01       	movw	r22, r28
    4848:	0e 94 62 22 	call	0x44c4	; 0x44c4 <findFiles>
    484c:	fc 01       	movw	r30, r24
if(dir == 0) 
    484e:	00 97       	sbiw	r24, 0x00	; 0
    4850:	31 f4       	brne	.+12     	; 0x485e <readFile+0x46>
struct dir_Structure *dir;
unsigned long cluster, byteCounter = 0, fileSize, firstSector;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    4852:	81 e0       	ldi	r24, 0x01	; 1
    4854:	11 23       	and	r17, r17
    4856:	09 f4       	brne	.+2      	; 0x485a <readFile+0x42>
    4858:	4e c0       	rjmp	.+156    	; 0x48f6 <readFile+0xde>
    485a:	80 e0       	ldi	r24, 0x00	; 0
    485c:	4c c0       	rjmp	.+152    	; 0x48f6 <readFile+0xde>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    485e:	11 30       	cpi	r17, 0x01	; 1
    4860:	09 f4       	brne	.+2      	; 0x4864 <readFile+0x4c>
    4862:	48 c0       	rjmp	.+144    	; 0x48f4 <readFile+0xdc>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    4864:	44 88       	ldd	r4, Z+20	; 0x14
    4866:	55 88       	ldd	r5, Z+21	; 0x15
    4868:	66 24       	eor	r6, r6
    486a:	77 24       	eor	r7, r7
    486c:	32 01       	movw	r6, r4
    486e:	55 24       	eor	r5, r5
    4870:	44 24       	eor	r4, r4
    4872:	82 8d       	ldd	r24, Z+26	; 0x1a
    4874:	93 8d       	ldd	r25, Z+27	; 0x1b
    4876:	a0 e0       	ldi	r26, 0x00	; 0
    4878:	b0 e0       	ldi	r27, 0x00	; 0
    487a:	48 2a       	or	r4, r24
    487c:	59 2a       	or	r5, r25
    487e:	6a 2a       	or	r6, r26
    4880:	7b 2a       	or	r7, r27
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    4882:	0f 2e       	mov	r0, r31
    4884:	f2 ec       	ldi	r31, 0xC2	; 194
    4886:	af 2e       	mov	r10, r31
    4888:	f3 e2       	ldi	r31, 0x23	; 35
    488a:	bf 2e       	mov	r11, r31
    488c:	f0 2d       	mov	r31, r0
fileSize = dir->fileSize;


while(1)
{
  firstSector = getFirstSector (cluster);
    488e:	c3 01       	movw	r24, r6
    4890:	b2 01       	movw	r22, r4
    4892:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <getFirstSector>
    4896:	6b 01       	movw	r12, r22
    4898:	7c 01       	movw	r14, r24

  for(j=0; j<sectorPerCluster; j++)
    489a:	80 91 57 50 	lds	r24, 0x5057
    489e:	90 91 58 50 	lds	r25, 0x5058
    48a2:	00 97       	sbiw	r24, 0x00	; 0
    48a4:	a1 f0       	breq	.+40     	; 0x48ce <readFile+0xb6>
    48a6:	c0 e0       	ldi	r28, 0x00	; 0
  {
    SD_read_block(firstSector + j,FRAMReadBuffer);
    48a8:	c7 01       	movw	r24, r14
    48aa:	b6 01       	movw	r22, r12
    48ac:	6c 0f       	add	r22, r28
    48ae:	71 1d       	adc	r23, r1
    48b0:	81 1d       	adc	r24, r1
    48b2:	91 1d       	adc	r25, r1
    48b4:	a5 01       	movw	r20, r10
    48b6:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <SD_read_block>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    48ba:	cf 5f       	subi	r28, 0xFF	; 255
    48bc:	80 91 57 50 	lds	r24, 0x5057
    48c0:	90 91 58 50 	lds	r25, 0x5058
    48c4:	2c 2f       	mov	r18, r28
    48c6:	30 e0       	ldi	r19, 0x00	; 0
    48c8:	28 17       	cp	r18, r24
    48ca:	39 07       	cpc	r19, r25
    48cc:	68 f3       	brcs	.-38     	; 0x48a8 <readFile+0x90>
      transmitByte(buffer[k]);
      if ((byteCounter++) >= fileSize ) return 0;
    }
	*/
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    48ce:	c3 01       	movw	r24, r6
    48d0:	b2 01       	movw	r22, r4
    48d2:	40 e0       	ldi	r20, 0x00	; 0
    48d4:	00 e0       	ldi	r16, 0x00	; 0
    48d6:	10 e0       	ldi	r17, 0x00	; 0
    48d8:	98 01       	movw	r18, r16
    48da:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <getSetNextCluster>
    48de:	2b 01       	movw	r4, r22
    48e0:	3c 01       	movw	r6, r24
  if(cluster == 0) {//Error in getting cluster
    48e2:	61 15       	cp	r22, r1
    48e4:	71 05       	cpc	r23, r1
    48e6:	81 05       	cpc	r24, r1
    48e8:	91 05       	cpc	r25, r1
    48ea:	89 f6       	brne	.-94     	; 0x488e <readFile+0x76>
	  return 0;}
    48ec:	80 e0       	ldi	r24, 0x00	; 0
    48ee:	03 c0       	rjmp	.+6      	; 0x48f6 <readFile+0xde>
struct dir_Structure *dir;
unsigned long cluster, byteCounter = 0, fileSize, firstSector;
unsigned char j, error;

error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
    48f0:	82 e0       	ldi	r24, 0x02	; 2
    48f2:	01 c0       	rjmp	.+2      	; 0x48f6 <readFile+0xde>
{
  if(flag == READ) return (1);
  else return (0);
}

if(flag == VERIFY) return (1);	//specified file name is already existing
    48f4:	81 e0       	ldi	r24, 0x01	; 1
  cluster = getSetNextCluster (cluster, GET, 0);
  if(cluster == 0) {//Error in getting cluster
	  return 0;}
}
return 0;
}
    48f6:	df 91       	pop	r29
    48f8:	cf 91       	pop	r28
    48fa:	1f 91       	pop	r17
    48fc:	0f 91       	pop	r16
    48fe:	ff 90       	pop	r15
    4900:	ef 90       	pop	r14
    4902:	df 90       	pop	r13
    4904:	cf 90       	pop	r12
    4906:	bf 90       	pop	r11
    4908:	af 90       	pop	r10
    490a:	7f 90       	pop	r7
    490c:	6f 90       	pop	r6
    490e:	5f 90       	pop	r5
    4910:	4f 90       	pop	r4
    4912:	08 95       	ret

00004914 <writeFile>:
//Function: to create a file in FAT32 format in the root directory if given 
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName){
    4914:	2f 92       	push	r2
    4916:	3f 92       	push	r3
    4918:	4f 92       	push	r4
    491a:	5f 92       	push	r5
    491c:	6f 92       	push	r6
    491e:	7f 92       	push	r7
    4920:	8f 92       	push	r8
    4922:	9f 92       	push	r9
    4924:	af 92       	push	r10
    4926:	bf 92       	push	r11
    4928:	cf 92       	push	r12
    492a:	df 92       	push	r13
    492c:	ef 92       	push	r14
    492e:	ff 92       	push	r15
    4930:	0f 93       	push	r16
    4932:	1f 93       	push	r17
    4934:	cf 93       	push	r28
    4936:	df 93       	push	r29
    4938:	cd b7       	in	r28, 0x3d	; 61
    493a:	de b7       	in	r29, 0x3e	; 62
    493c:	29 97       	sbiw	r28, 0x09	; 9
    493e:	cd bf       	out	0x3d, r28	; 61
    4940:	de bf       	out	0x3e, r29	; 62
    4942:	89 83       	std	Y+1, r24	; 0x01
    4944:	9a 83       	std	Y+2, r25	; 0x02
if(strlen(fileName) > 15) return 1;
for(int i=0; i < strlen(fileName); i++){
	Filename[i] = fileName[i];
}
*/
j = readFile (VERIFY, fileName);
    4946:	81 e0       	ldi	r24, 0x01	; 1
    4948:	69 81       	ldd	r22, Y+1	; 0x01
    494a:	79 2f       	mov	r23, r25
    494c:	0e 94 0c 24 	call	0x4818	; 0x4818 <readFile>

if(j == 1) 
    4950:	81 30       	cpi	r24, 0x01	; 1
    4952:	09 f0       	breq	.+2      	; 0x4956 <writeFile+0x42>
    4954:	6f c0       	rjmp	.+222    	; 0x4a34 <writeFile+0x120>
{
  //File already exists, appending data
  appendFile = 1;
  //set cluster to write to as the first cluster of the file
  cluster = appendStartCluster;
    4956:	80 90 63 50 	lds	r8, 0x5063
    495a:	90 90 64 50 	lds	r9, 0x5064
    495e:	a0 90 65 50 	lds	r10, 0x5065
    4962:	b0 90 66 50 	lds	r11, 0x5066
  clusterCount=0;
    4966:	cc 24       	eor	r12, r12
    4968:	dd 24       	eor	r13, r13
    496a:	76 01       	movw	r14, r12
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    496c:	c5 01       	movw	r24, r10
    496e:	b4 01       	movw	r22, r8
    4970:	40 e0       	ldi	r20, 0x00	; 0
    4972:	00 e0       	ldi	r16, 0x00	; 0
    4974:	10 e0       	ldi	r17, 0x00	; 0
    4976:	98 01       	movw	r18, r16
    4978:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <getSetNextCluster>
    497c:	dc 01       	movw	r26, r24
    497e:	cb 01       	movw	r24, r22
    if(nextCluster == EOF) break;
    4980:	8f 3f       	cpi	r24, 0xFF	; 255
    4982:	0f ef       	ldi	r16, 0xFF	; 255
    4984:	90 07       	cpc	r25, r16
    4986:	0f ef       	ldi	r16, 0xFF	; 255
    4988:	a0 07       	cpc	r26, r16
    498a:	0f e0       	ldi	r16, 0x0F	; 15
    498c:	b0 07       	cpc	r27, r16
    498e:	41 f0       	breq	.+16     	; 0x49a0 <writeFile+0x8c>
	cluster = nextCluster;
	clusterCount++;
    4990:	08 94       	sec
    4992:	c1 1c       	adc	r12, r1
    4994:	d1 1c       	adc	r13, r1
    4996:	e1 1c       	adc	r14, r1
    4998:	f1 1c       	adc	r15, r1
  //iterate through the clusters in the file until the last incomplete cluster is found and set that to cluster
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    if(nextCluster == EOF) break;
	cluster = nextCluster;
    499a:	4c 01       	movw	r8, r24
    499c:	5d 01       	movw	r10, r26
	clusterCount++;
  }
    499e:	e6 cf       	rjmp	.-52     	; 0x496c <writeFile+0x58>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    49a0:	20 91 57 50 	lds	r18, 0x5057
    49a4:	30 91 58 50 	lds	r19, 0x5058
    49a8:	80 91 37 40 	lds	r24, 0x4037
    49ac:	90 91 38 40 	lds	r25, 0x4038
    49b0:	60 90 37 40 	lds	r6, 0x4037
    49b4:	70 90 38 40 	lds	r7, 0x4038
    49b8:	bc 01       	movw	r22, r24
    49ba:	80 e0       	ldi	r24, 0x00	; 0
    49bc:	90 e0       	ldi	r25, 0x00	; 0
    49be:	40 e0       	ldi	r20, 0x00	; 0
    49c0:	50 e0       	ldi	r21, 0x00	; 0
    49c2:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    49c6:	a7 01       	movw	r20, r14
    49c8:	96 01       	movw	r18, r12
    49ca:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    49ce:	dc 01       	movw	r26, r24
    49d0:	cb 01       	movw	r24, r22
    49d2:	40 91 33 40 	lds	r20, 0x4033
    49d6:	50 91 34 40 	lds	r21, 0x4034
    49da:	60 91 35 40 	lds	r22, 0x4035
    49de:	70 91 36 40 	lds	r23, 0x4036
    49e2:	8a 01       	movw	r16, r20
    49e4:	9b 01       	movw	r18, r22
    49e6:	08 1b       	sub	r16, r24
    49e8:	19 0b       	sbc	r17, r25
    49ea:	2a 0b       	sbc	r18, r26
    49ec:	3b 0b       	sbc	r19, r27
    49ee:	c9 01       	movw	r24, r18
    49f0:	b8 01       	movw	r22, r16
    49f2:	93 01       	movw	r18, r6
    49f4:	40 e0       	ldi	r20, 0x00	; 0
    49f6:	50 e0       	ldi	r21, 0x00	; 0
    49f8:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    49fc:	02 2f       	mov	r16, r18
}

//start writing data here
if(start){
      start = 0;
	  startBlock = getFirstSector (cluster) + sector;
    49fe:	68 2d       	mov	r22, r8
    4a00:	79 2d       	mov	r23, r9
    4a02:	8a 2d       	mov	r24, r10
    4a04:	9b 2d       	mov	r25, r11
    4a06:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <getFirstSector>
    4a0a:	ab 01       	movw	r20, r22
    4a0c:	bc 01       	movw	r22, r24
    4a0e:	80 2f       	mov	r24, r16
    4a10:	90 e0       	ldi	r25, 0x00	; 0
    4a12:	6c 01       	movw	r12, r24
    4a14:	c4 0e       	add	r12, r20
    4a16:	d5 1e       	adc	r13, r21
	  SD_read_block (startBlock,SDBuffer);
    4a18:	b6 01       	movw	r22, r12
    4a1a:	80 e0       	ldi	r24, 0x00	; 0
    4a1c:	90 e0       	ldi	r25, 0x00	; 0
    4a1e:	49 eb       	ldi	r20, 0xB9	; 185
    4a20:	51 e2       	ldi	r21, 0x21	; 33
    4a22:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <SD_read_block>
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName){
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
unsigned int firstClusterHigh=0, firstClusterLow=0, startBlock=0;  //value 0 is assigned just to avoid warning in compilation
    4a26:	44 24       	eor	r4, r4
    4a28:	55 24       	eor	r5, r5
    4a2a:	22 24       	eor	r2, r2
    4a2c:	33 24       	eor	r3, r3
	cluster = nextCluster;
	clusterCount++;
  }
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
    4a2e:	66 24       	eor	r6, r6
    4a30:	63 94       	inc	r6
    4a32:	43 c0       	rjmp	.+134    	; 0x4aba <writeFile+0x1a6>
}
else if(j == 2) 
    4a34:	82 30       	cpi	r24, 0x02	; 2
    4a36:	09 f4       	brne	.+2      	; 0x4a3a <writeFile+0x126>
    4a38:	af c1       	rjmp	.+862    	; 0x4d98 <writeFile+0x484>

else
{
 //Creating File

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    4a3a:	82 e0       	ldi	r24, 0x02	; 2
    4a3c:	60 e0       	ldi	r22, 0x00	; 0
    4a3e:	20 e0       	ldi	r18, 0x00	; 0
    4a40:	30 e0       	ldi	r19, 0x00	; 0
    4a42:	a9 01       	movw	r20, r18
    4a44:	0e 94 31 1f 	call	0x3e62	; 0x3e62 <getSetFreeCluster>
  if(cluster > totalClusters)
    4a48:	00 91 3c 40 	lds	r16, 0x403C
    4a4c:	10 91 3d 40 	lds	r17, 0x403D
    4a50:	20 91 3e 40 	lds	r18, 0x403E
    4a54:	30 91 3f 40 	lds	r19, 0x403F
    4a58:	06 17       	cp	r16, r22
    4a5a:	17 07       	cpc	r17, r23
    4a5c:	28 07       	cpc	r18, r24
    4a5e:	39 07       	cpc	r19, r25
    4a60:	40 f4       	brcc	.+16     	; 0x4a72 <writeFile+0x15e>
     cluster = rootCluster;
    4a62:	60 91 41 40 	lds	r22, 0x4041
    4a66:	70 91 42 40 	lds	r23, 0x4042
    4a6a:	80 91 43 40 	lds	r24, 0x4043
    4a6e:	90 91 44 40 	lds	r25, 0x4044

  cluster = searchNextFreeCluster(cluster);
    4a72:	0e 94 41 21 	call	0x4282	; 0x4282 <searchNextFreeCluster>
    4a76:	4b 01       	movw	r8, r22
    4a78:	5c 01       	movw	r10, r24
   if(cluster == 0)
    4a7a:	61 15       	cp	r22, r1
    4a7c:	71 05       	cpc	r23, r1
    4a7e:	81 05       	cpc	r24, r1
    4a80:	91 05       	cpc	r25, r1
    4a82:	09 f4       	brne	.+2      	; 0x4a86 <writeFile+0x172>
    4a84:	8b c1       	rjmp	.+790    	; 0x4d9c <writeFile+0x488>
   {
	   // No free cluster!
	  return 2;
   }
  getSetNextCluster(cluster, SET, EOF);   //set last cluster of the file, marked EOF
    4a86:	41 e0       	ldi	r20, 0x01	; 1
    4a88:	0f ef       	ldi	r16, 0xFF	; 255
    4a8a:	1f ef       	ldi	r17, 0xFF	; 255
    4a8c:	2f ef       	ldi	r18, 0xFF	; 255
    4a8e:	3f e0       	ldi	r19, 0x0F	; 15
    4a90:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    4a94:	15 01       	movw	r2, r10
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    4a96:	24 01       	movw	r4, r8
  fileSize = 0;
    4a98:	10 92 33 40 	sts	0x4033, r1
    4a9c:	10 92 34 40 	sts	0x4034, r1
    4aa0:	10 92 35 40 	sts	0x4035, r1
    4aa4:	10 92 36 40 	sts	0x4036, r1
	  startBlock = getFirstSector (cluster) + sector;
	  SD_read_block (startBlock,SDBuffer);
	  j = sector;
   }
   else{
      startBlock = getFirstSector (cluster);
    4aa8:	c5 01       	movw	r24, r10
    4aaa:	b4 01       	movw	r22, r8
    4aac:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <getFirstSector>
    4ab0:	dc 01       	movw	r26, r24
    4ab2:	cb 01       	movw	r24, r22
    4ab4:	6c 01       	movw	r12, r24
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName){
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4ab6:	66 24       	eor	r6, r6
	  SD_read_block (startBlock,SDBuffer);
	  j = sector;
   }
   else{
      startBlock = getFirstSector (cluster);
	  j=0;
    4ab8:	00 e0       	ldi	r16, 0x00	; 0
   }
//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes   
fileSize += 512;
    4aba:	80 91 33 40 	lds	r24, 0x4033
    4abe:	90 91 34 40 	lds	r25, 0x4034
    4ac2:	a0 91 35 40 	lds	r26, 0x4035
    4ac6:	b0 91 36 40 	lds	r27, 0x4036
    4aca:	80 50       	subi	r24, 0x00	; 0
    4acc:	9e 4f       	sbci	r25, 0xFE	; 254
    4ace:	af 4f       	sbci	r26, 0xFF	; 255
    4ad0:	bf 4f       	sbci	r27, 0xFF	; 255
    4ad2:	80 93 33 40 	sts	0x4033, r24
    4ad6:	90 93 34 40 	sts	0x4034, r25
    4ada:	a0 93 35 40 	sts	0x4035, r26
    4ade:	b0 93 36 40 	sts	0x4036, r27
SD_write_block (startBlock,FRAMReadBuffer,512);
    4ae2:	b6 01       	movw	r22, r12
    4ae4:	80 e0       	ldi	r24, 0x00	; 0
    4ae6:	90 e0       	ldi	r25, 0x00	; 0
    4ae8:	42 ec       	ldi	r20, 0xC2	; 194
    4aea:	53 e2       	ldi	r21, 0x23	; 35
    4aec:	20 e0       	ldi	r18, 0x00	; 0
    4aee:	32 e0       	ldi	r19, 0x02	; 2
    4af0:	0e 94 36 28 	call	0x506c	; 0x506c <SD_write_block>
j++;
//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
if(j == sectorPerCluster) {
    4af4:	20 91 57 50 	lds	r18, 0x5057
    4af8:	30 91 58 50 	lds	r19, 0x5058
	  j=0;
   }
//write 1 sector (512 bytes) to the cluster and increase file size by 512 bytes   
fileSize += 512;
SD_write_block (startBlock,FRAMReadBuffer,512);
j++;
    4afc:	0f 5f       	subi	r16, 0xFF	; 255
//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
if(j == sectorPerCluster) {
    4afe:	80 2f       	mov	r24, r16
    4b00:	90 e0       	ldi	r25, 0x00	; 0
    4b02:	82 17       	cp	r24, r18
    4b04:	93 07       	cpc	r25, r19
    4b06:	f1 f4       	brne	.+60     	; 0x4b44 <writeFile+0x230>
	j = 0; 
 
	prevCluster = cluster;
	cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    4b08:	c5 01       	movw	r24, r10
    4b0a:	b4 01       	movw	r22, r8
    4b0c:	0e 94 41 21 	call	0x4282	; 0x4282 <searchNextFreeCluster>
    4b10:	6b 01       	movw	r12, r22
    4b12:	7c 01       	movw	r14, r24
	if(cluster == 0){
    4b14:	61 15       	cp	r22, r1
    4b16:	71 05       	cpc	r23, r1
    4b18:	81 05       	cpc	r24, r1
    4b1a:	91 05       	cpc	r25, r1
    4b1c:	09 f4       	brne	.+2      	; 0x4b20 <writeFile+0x20c>
    4b1e:	40 c1       	rjmp	.+640    	; 0x4da0 <writeFile+0x48c>
      //No free cluster!
	  return 2;
   }
	getSetNextCluster(prevCluster, SET, cluster);
    4b20:	c5 01       	movw	r24, r10
    4b22:	b4 01       	movw	r22, r8
    4b24:	41 e0       	ldi	r20, 0x01	; 1
    4b26:	97 01       	movw	r18, r14
    4b28:	86 01       	movw	r16, r12
    4b2a:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <getSetNextCluster>
	getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    4b2e:	c7 01       	movw	r24, r14
    4b30:	b6 01       	movw	r22, r12
    4b32:	41 e0       	ldi	r20, 0x01	; 1
    4b34:	0f ef       	ldi	r16, 0xFF	; 255
    4b36:	1f ef       	ldi	r17, 0xFF	; 255
    4b38:	2f ef       	ldi	r18, 0xFF	; 255
    4b3a:	3f e0       	ldi	r19, 0x0F	; 15
    4b3c:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <getSetNextCluster>
//if the cluster is filled up, find the next free cluster and set it as the current cluster of the file, also link another free cluster to the file and mark it as the end of file cluster
if(j == sectorPerCluster) {
	j = 0; 
 
	prevCluster = cluster;
	cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    4b40:	46 01       	movw	r8, r12
    4b42:	57 01       	movw	r10, r14
	getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
}
//otherwise increment the sector offset 
else startBlock++;       

getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    4b44:	82 e0       	ldi	r24, 0x02	; 2
    4b46:	61 e0       	ldi	r22, 0x01	; 1
    4b48:	a5 01       	movw	r20, r10
    4b4a:	94 01       	movw	r18, r8
    4b4c:	0e 94 31 1f 	call	0x3e62	; 0x3e62 <getSetFreeCluster>

if(appendFile)  //executes this loop if file is to be appended (updates file information and reduce count of free memory)
    4b50:	66 20       	and	r6, r6
    4b52:	09 f4       	brne	.+2      	; 0x4b56 <writeFile+0x242>
    4b54:	3f c0       	rjmp	.+126    	; 0x4bd4 <writeFile+0x2c0>
{
  SD_read_block (appendFileSector,SDBuffer);    
    4b56:	60 91 ac 50 	lds	r22, 0x50AC
    4b5a:	70 91 ad 50 	lds	r23, 0x50AD
    4b5e:	80 91 ae 50 	lds	r24, 0x50AE
    4b62:	90 91 af 50 	lds	r25, 0x50AF
    4b66:	09 eb       	ldi	r16, 0xB9	; 185
    4b68:	11 e2       	ldi	r17, 0x21	; 33
    4b6a:	a8 01       	movw	r20, r16
    4b6c:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <SD_read_block>
  dir = (struct dir_Structure *) &SDBuffer[appendFileLocation]; 
    4b70:	e0 91 ba 23 	lds	r30, 0x23BA
    4b74:	f0 91 bb 23 	lds	r31, 0x23BB
    4b78:	e0 0f       	add	r30, r16
    4b7a:	f1 1f       	adc	r31, r17

  dir->lastAccessDate = 0;   //date of last access ignored
    4b7c:	12 8a       	std	Z+18, r1	; 0x12
    4b7e:	13 8a       	std	Z+19, r1	; 0x13
  //dir->writeTime = timeFAT;  //setting new time of last write, obtained from RTC
  //dir->writeDate = dateFAT;  //setting new date of last write, obtained from RTC
  extraMemory = fileSize - dir->fileSize;
    4b80:	80 91 33 40 	lds	r24, 0x4033
    4b84:	90 91 34 40 	lds	r25, 0x4034
    4b88:	a0 91 35 40 	lds	r26, 0x4035
    4b8c:	b0 91 36 40 	lds	r27, 0x4036
    4b90:	44 8d       	ldd	r20, Z+28	; 0x1c
    4b92:	55 8d       	ldd	r21, Z+29	; 0x1d
    4b94:	66 8d       	ldd	r22, Z+30	; 0x1e
    4b96:	77 8d       	ldd	r23, Z+31	; 0x1f
    4b98:	6c 01       	movw	r12, r24
    4b9a:	7d 01       	movw	r14, r26
    4b9c:	c4 1a       	sub	r12, r20
    4b9e:	d5 0a       	sbc	r13, r21
    4ba0:	e6 0a       	sbc	r14, r22
    4ba2:	f7 0a       	sbc	r15, r23
  dir->fileSize = fileSize;
    4ba4:	84 8f       	std	Z+28, r24	; 0x1c
    4ba6:	95 8f       	std	Z+29, r25	; 0x1d
    4ba8:	a6 8f       	std	Z+30, r26	; 0x1e
    4baa:	b7 8f       	std	Z+31, r27	; 0x1f
  SD_write_block (appendFileSector,SDBuffer,512);
    4bac:	60 91 ac 50 	lds	r22, 0x50AC
    4bb0:	70 91 ad 50 	lds	r23, 0x50AD
    4bb4:	80 91 ae 50 	lds	r24, 0x50AE
    4bb8:	90 91 af 50 	lds	r25, 0x50AF
    4bbc:	a8 01       	movw	r20, r16
    4bbe:	20 e0       	ldi	r18, 0x00	; 0
    4bc0:	32 e0       	ldi	r19, 0x02	; 2
    4bc2:	0e 94 36 28 	call	0x506c	; 0x506c <SD_write_block>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    4bc6:	81 e0       	ldi	r24, 0x01	; 1
    4bc8:	b7 01       	movw	r22, r14
    4bca:	a6 01       	movw	r20, r12
    4bcc:	0e 94 f4 21 	call	0x43e8	; 0x43e8 <freeMemoryUpdate>

 //File appended!
  return 0;
    4bd0:	80 e0       	ldi	r24, 0x00	; 0
    4bd2:	ed c0       	rjmp	.+474    	; 0x4dae <writeFile+0x49a>
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    4bd4:	80 91 41 40 	lds	r24, 0x4041
    4bd8:	90 91 42 40 	lds	r25, 0x4042
    4bdc:	a0 91 43 40 	lds	r26, 0x4043
    4be0:	b0 91 44 40 	lds	r27, 0x4044
    4be4:	8e 83       	std	Y+6, r24	; 0x06
    4be6:	9f 83       	std	Y+7, r25	; 0x07
    4be8:	a8 87       	std	Y+8, r26	; 0x08
    4bea:	b9 87       	std	Y+9, r27	; 0x09
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: 1 - invalid filename, 2 - no free cluster, 3 - end of cluster chain, 4 - error in getting cluster
//************************************************************************************
unsigned char writeFile (unsigned char* fileName){
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sector=0;
    4bec:	bb 24       	eor	r11, r11

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = fileName[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    4bee:	88 24       	eor	r8, r8
    4bf0:	68 94       	set
    4bf2:	85 f8       	bld	r8, 5
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4bf4:	0f 2e       	mov	r0, r31
    4bf6:	f9 eb       	ldi	r31, 0xB9	; 185
    4bf8:	6f 2e       	mov	r6, r31
    4bfa:	f1 e2       	ldi	r31, 0x21	; 33
    4bfc:	7f 2e       	mov	r7, r31
    4bfe:	f0 2d       	mov	r31, r0
    4c00:	99 80       	ldd	r9, Y+1	; 0x01
    4c02:	aa 80       	ldd	r10, Y+2	; 0x02
    4c04:	04 c0       	rjmp	.+8      	; 0x4c0e <writeFile+0x2fa>
   }
   if(cluster == 0) {//Error in getting cluster 
	   return 4;
	}
   
   prevCluster = cluster;
    4c06:	ce 82       	std	Y+6, r12	; 0x06
    4c08:	df 82       	std	Y+7, r13	; 0x07
    4c0a:	e8 86       	std	Y+8, r14	; 0x08
    4c0c:	f9 86       	std	Y+9, r15	; 0x09

prevCluster = rootCluster; //root cluster

while(1)
{
   firstSector = getFirstSector (prevCluster);
    4c0e:	6e 81       	ldd	r22, Y+6	; 0x06
    4c10:	7f 81       	ldd	r23, Y+7	; 0x07
    4c12:	88 85       	ldd	r24, Y+8	; 0x08
    4c14:	99 85       	ldd	r25, Y+9	; 0x09
    4c16:	0e 94 88 1e 	call	0x3d10	; 0x3d10 <getFirstSector>
    4c1a:	6a 83       	std	Y+2, r22	; 0x02
    4c1c:	7b 83       	std	Y+3, r23	; 0x03
    4c1e:	8c 83       	std	Y+4, r24	; 0x04
    4c20:	9d 83       	std	Y+5, r25	; 0x05

   for(sector = 0; sector < sectorPerCluster; sector++)
    4c22:	80 91 57 50 	lds	r24, 0x5057
    4c26:	90 91 58 50 	lds	r25, 0x5058
    4c2a:	00 97       	sbiw	r24, 0x00	; 0
    4c2c:	09 f4       	brne	.+2      	; 0x4c30 <writeFile+0x31c>
    4c2e:	76 c0       	rjmp	.+236    	; 0x4d1c <writeFile+0x408>
    4c30:	19 82       	std	Y+1, r1	; 0x01
   {
     SD_read_block (firstSector + sector,SDBuffer);
    4c32:	ca 80       	ldd	r12, Y+2	; 0x02
    4c34:	db 80       	ldd	r13, Y+3	; 0x03
    4c36:	ec 80       	ldd	r14, Y+4	; 0x04
    4c38:	fd 80       	ldd	r15, Y+5	; 0x05
    4c3a:	09 81       	ldd	r16, Y+1	; 0x01
    4c3c:	c0 0e       	add	r12, r16
    4c3e:	d1 1c       	adc	r13, r1
    4c40:	e1 1c       	adc	r14, r1
    4c42:	f1 1c       	adc	r15, r1
    4c44:	c7 01       	movw	r24, r14
    4c46:	b6 01       	movw	r22, r12
    4c48:	a3 01       	movw	r20, r6
    4c4a:	0e 94 eb 28 	call	0x51d6	; 0x51d6 <SD_read_block>
	

     for(int i=0; i<bytesPerSector; i+=32)
    4c4e:	80 91 37 40 	lds	r24, 0x4037
    4c52:	90 91 38 40 	lds	r25, 0x4038
    4c56:	00 97       	sbiw	r24, 0x00	; 0
    4c58:	09 f4       	brne	.+2      	; 0x4c5c <writeFile+0x348>
    4c5a:	53 c0       	rjmp	.+166    	; 0x4d02 <writeFile+0x3ee>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4c5c:	a3 01       	movw	r20, r6
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    4c5e:	bb 20       	and	r11, r11
    4c60:	09 f0       	breq	.+2      	; 0x4c64 <writeFile+0x350>
    4c62:	a0 c0       	rjmp	.+320    	; 0x4da4 <writeFile+0x490>
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    4c64:	00 e0       	ldi	r16, 0x00	; 0
    4c66:	10 e0       	ldi	r17, 0x00	; 0
    4c68:	2b 2d       	mov	r18, r11
    4c6a:	06 c0       	rjmp	.+12     	; 0x4c78 <writeFile+0x364>
     {
	    dir = (struct dir_Structure *) &SDBuffer[i];
    4c6c:	a8 01       	movw	r20, r16
    4c6e:	47 54       	subi	r20, 0x47	; 71
    4c70:	5e 4d       	sbci	r21, 0xDE	; 222
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    4c72:	22 23       	and	r18, r18
    4c74:	09 f0       	breq	.+2      	; 0x4c78 <writeFile+0x364>
    4c76:	98 c0       	rjmp	.+304    	; 0x4da8 <writeFile+0x494>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4c78:	da 01       	movw	r26, r20
    4c7a:	8c 91       	ld	r24, X
    4c7c:	88 23       	and	r24, r24
    4c7e:	29 f4       	brne	.+10     	; 0x4c8a <writeFile+0x376>
    4c80:	e9 2d       	mov	r30, r9
    4c82:	fa 2d       	mov	r31, r10
    4c84:	da 01       	movw	r26, r20
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    4c86:	80 e0       	ldi	r24, 0x00	; 0
    4c88:	03 c0       	rjmp	.+6      	; 0x4c90 <writeFile+0x37c>
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    4c8a:	85 3e       	cpi	r24, 0xE5	; 229
    4c8c:	79 f5       	brne	.+94     	; 0x4cec <writeFile+0x3d8>
    4c8e:	f8 cf       	rjmp	.-16     	; 0x4c80 <writeFile+0x36c>
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = fileName[j];
    4c90:	91 91       	ld	r25, Z+
    4c92:	9d 93       	st	X+, r25
           return 0;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    4c94:	8f 5f       	subi	r24, 0xFF	; 255
    4c96:	8b 30       	cpi	r24, 0x0B	; 11
    4c98:	d9 f7       	brne	.-10     	; 0x4c90 <writeFile+0x37c>
  			dir->name[j] = fileName[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    4c9a:	fa 01       	movw	r30, r20
    4c9c:	83 86       	std	Z+11, r8	; 0x0b
		  dir->NTreserved = 0;			//always set to 0
    4c9e:	14 86       	std	Z+12, r1	; 0x0c
		  dir->timeTenth = 0;			//always set to 0
    4ca0:	15 86       	std	Z+13, r1	; 0x0d
		  //dir->createTime = timeFAT; 	//setting time of file creation, obtained from RTC
		  //dir->createDate = dateFAT; 	//setting date of file creation, obtained from RTC
		  dir->lastAccessDate = 0;   	//date of last access ignored
    4ca2:	12 8a       	std	Z+18, r1	; 0x12
    4ca4:	13 8a       	std	Z+19, r1	; 0x13
		  //dir->writeTime = timeFAT;  	//setting new time of last write, obtained from RTC
		  //dir->writeDate = dateFAT;  	//setting new date of last write, obtained from RTC
		  dir->firstClusterHI = firstClusterHigh;
    4ca6:	24 8a       	std	Z+20, r2	; 0x14
    4ca8:	35 8a       	std	Z+21, r3	; 0x15
		  dir->firstClusterLO = firstClusterLow;
    4caa:	42 8e       	std	Z+26, r4	; 0x1a
    4cac:	53 8e       	std	Z+27, r5	; 0x1b
		  dir->fileSize = fileSize;
    4cae:	80 91 33 40 	lds	r24, 0x4033
    4cb2:	90 91 34 40 	lds	r25, 0x4034
    4cb6:	a0 91 35 40 	lds	r26, 0x4035
    4cba:	b0 91 36 40 	lds	r27, 0x4036
    4cbe:	84 8f       	std	Z+28, r24	; 0x1c
    4cc0:	95 8f       	std	Z+29, r25	; 0x1d
    4cc2:	a6 8f       	std	Z+30, r26	; 0x1e
    4cc4:	b7 8f       	std	Z+31, r27	; 0x1f

		  SD_write_block (firstSector + sector,SDBuffer,512);
    4cc6:	c7 01       	movw	r24, r14
    4cc8:	b6 01       	movw	r22, r12
    4cca:	a3 01       	movw	r20, r6
    4ccc:	20 e0       	ldi	r18, 0x00	; 0
    4cce:	32 e0       	ldi	r19, 0x02	; 2
    4cd0:	0e 94 36 28 	call	0x506c	; 0x506c <SD_write_block>
		  fileCreatedFlag = 1;

		  //File Created!

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    4cd4:	40 91 33 40 	lds	r20, 0x4033
    4cd8:	50 91 34 40 	lds	r21, 0x4034
    4cdc:	60 91 35 40 	lds	r22, 0x4035
    4ce0:	70 91 36 40 	lds	r23, 0x4036
    4ce4:	81 e0       	ldi	r24, 0x01	; 1
    4ce6:	0e 94 f4 21 	call	0x43e8	; 0x43e8 <freeMemoryUpdate>
		  dir->firstClusterHI = firstClusterHigh;
		  dir->firstClusterLO = firstClusterLow;
		  dir->fileSize = fileSize;

		  SD_write_block (firstSector + sector,SDBuffer,512);
		  fileCreatedFlag = 1;
    4cea:	21 e0       	ldi	r18, 0x01	; 1
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_read_block (firstSector + sector,SDBuffer);
	

     for(int i=0; i<bytesPerSector; i+=32)
    4cec:	00 5e       	subi	r16, 0xE0	; 224
    4cee:	1f 4f       	sbci	r17, 0xFF	; 255
    4cf0:	80 91 37 40 	lds	r24, 0x4037
    4cf4:	90 91 38 40 	lds	r25, 0x4038
    4cf8:	08 17       	cp	r16, r24
    4cfa:	19 07       	cpc	r17, r25
    4cfc:	08 f4       	brcc	.+2      	; 0x4d00 <writeFile+0x3ec>
    4cfe:	b6 cf       	rjmp	.-148    	; 0x4c6c <writeFile+0x358>
    4d00:	b2 2e       	mov	r11, r18

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    4d02:	09 81       	ldd	r16, Y+1	; 0x01
    4d04:	0f 5f       	subi	r16, 0xFF	; 255
    4d06:	09 83       	std	Y+1, r16	; 0x01
    4d08:	20 91 57 50 	lds	r18, 0x5057
    4d0c:	30 91 58 50 	lds	r19, 0x5058
    4d10:	80 2f       	mov	r24, r16
    4d12:	90 e0       	ldi	r25, 0x00	; 0
    4d14:	82 17       	cp	r24, r18
    4d16:	93 07       	cpc	r25, r19
    4d18:	08 f4       	brcc	.+2      	; 0x4d1c <writeFile+0x408>
    4d1a:	8b cf       	rjmp	.-234    	; 0x4c32 <writeFile+0x31e>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    4d1c:	6e 81       	ldd	r22, Y+6	; 0x06
    4d1e:	7f 81       	ldd	r23, Y+7	; 0x07
    4d20:	88 85       	ldd	r24, Y+8	; 0x08
    4d22:	99 85       	ldd	r25, Y+9	; 0x09
    4d24:	40 e0       	ldi	r20, 0x00	; 0
    4d26:	00 e0       	ldi	r16, 0x00	; 0
    4d28:	10 e0       	ldi	r17, 0x00	; 0
    4d2a:	98 01       	movw	r18, r16
    4d2c:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <getSetNextCluster>
    4d30:	6b 01       	movw	r12, r22
    4d32:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    4d34:	67 3f       	cpi	r22, 0xF7	; 247
    4d36:	1f ef       	ldi	r17, 0xFF	; 255
    4d38:	71 07       	cpc	r23, r17
    4d3a:	1f ef       	ldi	r17, 0xFF	; 255
    4d3c:	81 07       	cpc	r24, r17
    4d3e:	1f e0       	ldi	r17, 0x0F	; 15
    4d40:	91 07       	cpc	r25, r17
    4d42:	10 f1       	brcs	.+68     	; 0x4d88 <writeFile+0x474>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    4d44:	6f 3f       	cpi	r22, 0xFF	; 255
    4d46:	2f ef       	ldi	r18, 0xFF	; 255
    4d48:	72 07       	cpc	r23, r18
    4d4a:	2f ef       	ldi	r18, 0xFF	; 255
    4d4c:	82 07       	cpc	r24, r18
    4d4e:	2f e0       	ldi	r18, 0x0F	; 15
    4d50:	92 07       	cpc	r25, r18
    4d52:	61 f5       	brne	.+88     	; 0x4dac <writeFile+0x498>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    4d54:	6e 81       	ldd	r22, Y+6	; 0x06
    4d56:	7f 81       	ldd	r23, Y+7	; 0x07
    4d58:	88 85       	ldd	r24, Y+8	; 0x08
    4d5a:	99 85       	ldd	r25, Y+9	; 0x09
    4d5c:	0e 94 41 21 	call	0x4282	; 0x4282 <searchNextFreeCluster>
    4d60:	6b 01       	movw	r12, r22
    4d62:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    4d64:	6e 81       	ldd	r22, Y+6	; 0x06
    4d66:	7f 81       	ldd	r23, Y+7	; 0x07
    4d68:	88 85       	ldd	r24, Y+8	; 0x08
    4d6a:	99 85       	ldd	r25, Y+9	; 0x09
    4d6c:	41 e0       	ldi	r20, 0x01	; 1
    4d6e:	97 01       	movw	r18, r14
    4d70:	86 01       	movw	r16, r12
    4d72:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    4d76:	c7 01       	movw	r24, r14
    4d78:	b6 01       	movw	r22, r12
    4d7a:	41 e0       	ldi	r20, 0x01	; 1
    4d7c:	0f ef       	ldi	r16, 0xFF	; 255
    4d7e:	1f ef       	ldi	r17, 0xFF	; 255
    4d80:	2f ef       	ldi	r18, 0xFF	; 255
    4d82:	3f e0       	ldi	r19, 0x0F	; 15
    4d84:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <getSetNextCluster>
      {	
	    //End of Cluster Chain 
	    return 3;
      }
   }
   if(cluster == 0) {//Error in getting cluster 
    4d88:	c1 14       	cp	r12, r1
    4d8a:	d1 04       	cpc	r13, r1
    4d8c:	e1 04       	cpc	r14, r1
    4d8e:	f1 04       	cpc	r15, r1
    4d90:	09 f0       	breq	.+2      	; 0x4d94 <writeFile+0x480>
    4d92:	39 cf       	rjmp	.-398    	; 0x4c06 <writeFile+0x2f2>
	   return 4;
    4d94:	84 e0       	ldi	r24, 0x04	; 4
    4d96:	0b c0       	rjmp	.+22     	; 0x4dae <writeFile+0x49a>
  //using the size of the file and how many clusters it occupies, deduce the sector offset within the last incomplete cluster
  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
  start = 1;
}
else if(j == 2) 
   return 1; //invalid file name
    4d98:	81 e0       	ldi	r24, 0x01	; 1
    4d9a:	09 c0       	rjmp	.+18     	; 0x4dae <writeFile+0x49a>

  cluster = searchNextFreeCluster(cluster);
   if(cluster == 0)
   {
	   // No free cluster!
	  return 2;
    4d9c:	82 e0       	ldi	r24, 0x02	; 2
    4d9e:	07 c0       	rjmp	.+14     	; 0x4dae <writeFile+0x49a>
 
	prevCluster = cluster;
	cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
	if(cluster == 0){
      //No free cluster!
	  return 2;
    4da0:	82 e0       	ldi	r24, 0x02	; 2
    4da2:	05 c0       	rjmp	.+10     	; 0x4dae <writeFile+0x49a>
		//if file info successfully updated, return from function
		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
		 { 					  //indicating end of the directory file list
		   //dir->name[0] = EMPTY;
		   //SD_writeSingleBlock (firstSector + sector);
           return 0;
    4da4:	80 e0       	ldi	r24, 0x00	; 0
    4da6:	03 c0       	rjmp	.+6      	; 0x4dae <writeFile+0x49a>
    4da8:	80 e0       	ldi	r24, 0x00	; 0
    4daa:	01 c0       	rjmp	.+2      	; 0x4dae <writeFile+0x49a>
      } 

      else
      {	
	    //End of Cluster Chain 
	    return 3;
    4dac:	83 e0       	ldi	r24, 0x03	; 3
   
   prevCluster = cluster;
 }
 
 return 0;
}
    4dae:	29 96       	adiw	r28, 0x09	; 9
    4db0:	cd bf       	out	0x3d, r28	; 61
    4db2:	de bf       	out	0x3e, r29	; 62
    4db4:	df 91       	pop	r29
    4db6:	cf 91       	pop	r28
    4db8:	1f 91       	pop	r17
    4dba:	0f 91       	pop	r16
    4dbc:	ff 90       	pop	r15
    4dbe:	ef 90       	pop	r14
    4dc0:	df 90       	pop	r13
    4dc2:	cf 90       	pop	r12
    4dc4:	bf 90       	pop	r11
    4dc6:	af 90       	pop	r10
    4dc8:	9f 90       	pop	r9
    4dca:	8f 90       	pop	r8
    4dcc:	7f 90       	pop	r7
    4dce:	6f 90       	pop	r6
    4dd0:	5f 90       	pop	r5
    4dd2:	4f 90       	pop	r4
    4dd4:	3f 90       	pop	r3
    4dd6:	2f 90       	pop	r2
    4dd8:	08 95       	ret

00004dda <SPI_write>:
}	

//the following command writes/reads a byte via spi
uint8_t SPI_write(uint8_t byteToSend){
	uint8_t data;
	SPIC.DATA = byteToSend;
    4dda:	e0 ec       	ldi	r30, 0xC0	; 192
    4ddc:	f8 e0       	ldi	r31, 0x08	; 8
    4dde:	83 83       	std	Z+3, r24	; 0x03
	while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    4de0:	82 81       	ldd	r24, Z+2	; 0x02
    4de2:	88 23       	and	r24, r24
    4de4:	ec f7       	brge	.-6      	; 0x4de0 <SPI_write+0x6>
	data = SPIC.DATA; //read SPI data register to reset status flag
    4de6:	e0 ec       	ldi	r30, 0xC0	; 192
    4de8:	f8 e0       	ldi	r31, 0x08	; 8
    4dea:	83 81       	ldd	r24, Z+3	; 0x03
	return data;
}
    4dec:	08 95       	ret

00004dee <SD_command>:
//the following command writes a command to the sd card and returns a response (if any) or 0xFF if no response
uint8_t SD_command(uint8_t cmd, uint32_t arg, uint8_t crc, int read) {
    4dee:	8f 92       	push	r8
    4df0:	9f 92       	push	r9
    4df2:	af 92       	push	r10
    4df4:	bf 92       	push	r11
    4df6:	cf 92       	push	r12
    4df8:	df 92       	push	r13
    4dfa:	ef 92       	push	r14
    4dfc:	ff 92       	push	r15
    4dfe:	0f 93       	push	r16
    4e00:	1f 93       	push	r17
    4e02:	cf 93       	push	r28
    4e04:	df 93       	push	r29
    4e06:	84 2e       	mov	r8, r20
    4e08:	a5 2e       	mov	r10, r21
    4e0a:	c6 2e       	mov	r12, r22
    4e0c:	c7 2f       	mov	r28, r23
    4e0e:	d2 2f       	mov	r29, r18
    4e10:	78 01       	movw	r14, r16
	
	SPI_write(SDHC_COMMAND_START | cmd);
    4e12:	80 64       	ori	r24, 0x40	; 64
    4e14:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
	SPI_write(arg>>24 & LSBYTE_MASK);
    4e18:	8c 2f       	mov	r24, r28
    4e1a:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
	SPI_write(arg>>16 & LSBYTE_MASK);
    4e1e:	8c 2d       	mov	r24, r12
    4e20:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
	SPI_write(arg>>8 & LSBYTE_MASK);
    4e24:	8a 2d       	mov	r24, r10
    4e26:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
	SPI_write(arg & LSBYTE_MASK);
    4e2a:	88 2d       	mov	r24, r8
    4e2c:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
	SPI_write(crc);
    4e30:	8d 2f       	mov	r24, r29
    4e32:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
	
	for(int i=0; i<read; i++){
    4e36:	10 16       	cp	r1, r16
    4e38:	11 06       	cpc	r1, r17
    4e3a:	64 f5       	brge	.+88     	; 0x4e94 <SD_command+0xa6>
    4e3c:	00 e0       	ldi	r16, 0x00	; 0
    4e3e:	10 e0       	ldi	r17, 0x00	; 0
		Buffer[i%13] = SPI_write(SDHC_DUMMY_BYTE);
    4e40:	0f 2e       	mov	r0, r31
    4e42:	fd e0       	ldi	r31, 0x0D	; 13
    4e44:	cf 2e       	mov	r12, r31
    4e46:	dd 24       	eor	r13, r13
    4e48:	f0 2d       	mov	r31, r0
    4e4a:	0f 2e       	mov	r0, r31
    4e4c:	fa e8       	ldi	r31, 0x8A	; 138
    4e4e:	af 2e       	mov	r10, r31
    4e50:	f0 e5       	ldi	r31, 0x50	; 80
    4e52:	bf 2e       	mov	r11, r31
    4e54:	f0 2d       	mov	r31, r0
    4e56:	c8 01       	movw	r24, r16
    4e58:	b6 01       	movw	r22, r12
    4e5a:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <__divmodhi4>
    4e5e:	ec 01       	movw	r28, r24
    4e60:	8f ef       	ldi	r24, 0xFF	; 255
    4e62:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    4e66:	f5 01       	movw	r30, r10
    4e68:	ec 0f       	add	r30, r28
    4e6a:	fd 1f       	adc	r31, r29
    4e6c:	80 83       	st	Z, r24
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
    4e6e:	80 81       	ld	r24, Z
    4e70:	8f 3f       	cpi	r24, 0xFF	; 255
    4e72:	49 f0       	breq	.+18     	; 0x4e86 <SD_command+0x98>
			Buffer[1] = Buffer[i%13];
    4e74:	fe 01       	movw	r30, r28
    4e76:	e6 57       	subi	r30, 0x76	; 118
    4e78:	ff 4a       	sbci	r31, 0xAF	; 175
    4e7a:	80 81       	ld	r24, Z
    4e7c:	80 93 8b 50 	sts	0x508B, r24
			return Buffer[1];
    4e80:	80 91 8b 50 	lds	r24, 0x508B
    4e84:	08 c0       	rjmp	.+16     	; 0x4e96 <SD_command+0xa8>
	SPI_write(arg>>16 & LSBYTE_MASK);
	SPI_write(arg>>8 & LSBYTE_MASK);
	SPI_write(arg & LSBYTE_MASK);
	SPI_write(crc);
	
	for(int i=0; i<read; i++){
    4e86:	0f 5f       	subi	r16, 0xFF	; 255
    4e88:	1f 4f       	sbci	r17, 0xFF	; 255
    4e8a:	0e 15       	cp	r16, r14
    4e8c:	1f 05       	cpc	r17, r15
    4e8e:	19 f7       	brne	.-58     	; 0x4e56 <SD_command+0x68>
		if (Buffer[i%13] != SDHC_DUMMY_BYTE){
			Buffer[1] = Buffer[i%13];
			return Buffer[1];
		}
	}
	return SDHC_DUMMY_BYTE;
    4e90:	8f ef       	ldi	r24, 0xFF	; 255
    4e92:	01 c0       	rjmp	.+2      	; 0x4e96 <SD_command+0xa8>
    4e94:	8f ef       	ldi	r24, 0xFF	; 255
}
    4e96:	df 91       	pop	r29
    4e98:	cf 91       	pop	r28
    4e9a:	1f 91       	pop	r17
    4e9c:	0f 91       	pop	r16
    4e9e:	ff 90       	pop	r15
    4ea0:	ef 90       	pop	r14
    4ea2:	df 90       	pop	r13
    4ea4:	cf 90       	pop	r12
    4ea6:	bf 90       	pop	r11
    4ea8:	af 90       	pop	r10
    4eaa:	9f 90       	pop	r9
    4eac:	8f 90       	pop	r8
    4eae:	08 95       	ret

00004eb0 <SD_init>:
# include "E-000001-000009_firmware_rev_1_0.h"

//the following function turns on power to the sd card and port expander and initializes the sdhc card in spi mode
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
    4eb0:	ff 92       	push	r15
    4eb2:	0f 93       	push	r16
    4eb4:	1f 93       	push	r17
    4eb6:	cf 93       	push	r28
    4eb8:	df 93       	push	r29
	ADCPower(TRUE);				//power up portEX
    4eba:	81 e0       	ldi	r24, 0x01	; 1
    4ebc:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
	Ext1Power(TRUE);			//power up SD card
    4ec0:	81 e0       	ldi	r24, 0x01	; 1
    4ec2:	0e 94 9a 1a 	call	0x3534	; 0x3534 <Ext1Power>
    4ec6:	8f ef       	ldi	r24, 0xFF	; 255
    4ec8:	93 ec       	ldi	r25, 0xC3	; 195
    4eca:	a9 e0       	ldi	r26, 0x09	; 9
    4ecc:	81 50       	subi	r24, 0x01	; 1
    4ece:	90 40       	sbci	r25, 0x00	; 0
    4ed0:	a0 40       	sbci	r26, 0x00	; 0
    4ed2:	e1 f7       	brne	.-8      	; 0x4ecc <SD_init+0x1c>
    4ed4:	00 c0       	rjmp	.+0      	; 0x4ed6 <SD_init+0x26>
    4ed6:	00 00       	nop
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;

	
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //SD card CS	
    4ed8:	88 e0       	ldi	r24, 0x08	; 8
    4eda:	60 e0       	ldi	r22, 0x00	; 0
    4edc:	0e 94 3a 1c 	call	0x3874	; 0x3874 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    4ee0:	88 e0       	ldi	r24, 0x08	; 8
    4ee2:	60 e0       	ldi	r22, 0x00	; 0
    4ee4:	0e 94 8d 1b 	call	0x371a	; 0x371a <PortEx_OUTSET>

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    4ee8:	80 e0       	ldi	r24, 0x00	; 0
    4eea:	90 e0       	ldi	r25, 0x00	; 0
    4eec:	63 e0       	ldi	r22, 0x03	; 3
    4eee:	70 e0       	ldi	r23, 0x00	; 0
    4ef0:	0e 94 0e 1b 	call	0x361c	; 0x361c <SPIInit2>
	SPICS(TRUE);
    4ef4:	81 e0       	ldi	r24, 0x01	; 1
    4ef6:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
    4efa:	8a e0       	ldi	r24, 0x0A	; 10
    4efc:	90 e0       	ldi	r25, 0x00	; 0
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
		SPIC.DATA=SDHC_DUMMY_BYTE;
    4efe:	e0 ec       	ldi	r30, 0xC0	; 192
    4f00:	f8 e0       	ldi	r31, 0x08	; 8
    4f02:	3f ef       	ldi	r19, 0xFF	; 255
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    4f04:	a6 e9       	ldi	r26, 0x96	; 150
    4f06:	b0 e5       	ldi	r27, 0x50	; 80

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
		SPIC.DATA=SDHC_DUMMY_BYTE;
    4f08:	33 83       	std	Z+3, r19	; 0x03
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
    4f0a:	22 81       	ldd	r18, Z+2	; 0x02
    4f0c:	22 23       	and	r18, r18
    4f0e:	ec f7       	brge	.-6      	; 0x4f0a <SD_init+0x5a>
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
    4f10:	23 81       	ldd	r18, Z+3	; 0x03
    4f12:	2c 93       	st	X, r18
    4f14:	01 97       	sbiw	r24, 0x01	; 1
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high

	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	
	for(int i=0; i<10; i++){		// idle for 10 bytes / 80 clocks
    4f16:	c1 f7       	brne	.-16     	; 0x4f08 <SD_init+0x58>
		SPIC.DATA=SDHC_DUMMY_BYTE;
		while(!(SPIC.STATUS & SPI_IF_bm)); //wait for byte to be sent
		Buffer[12] = SPIC.DATA; //read SPI data register to reset status flag
	}
	
	SPICS(FALSE);
    4f18:	80 e0       	ldi	r24, 0x00	; 0
    4f1a:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	SPIDisable();
    4f1e:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>
	

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    4f22:	88 e0       	ldi	r24, 0x08	; 8
    4f24:	60 e0       	ldi	r22, 0x00	; 0
    4f26:	0e 94 36 1b 	call	0x366c	; 0x366c <PortEx_OUTCLR>
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
    4f2a:	80 e0       	ldi	r24, 0x00	; 0
    4f2c:	90 e0       	ldi	r25, 0x00	; 0
    4f2e:	63 e0       	ldi	r22, 0x03	; 3
    4f30:	70 e0       	ldi	r23, 0x00	; 0
    4f32:	0e 94 0e 1b 	call	0x361c	; 0x361c <SPIInit2>
	SPICS(TRUE);
    4f36:	81 e0       	ldi	r24, 0x01	; 1
    4f38:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    4f3c:	cb e0       	ldi	r28, 0x0B	; 11
    4f3e:	d0 e0       	ldi	r29, 0x00	; 0
    4f40:	02 c0       	rjmp	.+4      	; 0x4f46 <SD_init+0x96>
    4f42:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {												//try command 10 times before timing out
    4f44:	69 f0       	breq	.+26     	; 0x4f60 <SD_init+0xb0>

	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
    4f46:	80 e0       	ldi	r24, 0x00	; 0
    4f48:	40 e0       	ldi	r20, 0x00	; 0
    4f4a:	50 e0       	ldi	r21, 0x00	; 0
    4f4c:	ba 01       	movw	r22, r20
    4f4e:	25 e9       	ldi	r18, 0x95	; 149
    4f50:	08 e0       	ldi	r16, 0x08	; 8
    4f52:	10 e0       	ldi	r17, 0x00	; 0
    4f54:	0e 94 f7 26 	call	0x4dee	; 0x4dee <SD_command>
    4f58:	81 30       	cpi	r24, 0x01	; 1
    4f5a:	99 f7       	brne	.-26     	; 0x4f42 <SD_init+0x92>
//returns 0 if successful or 1 if not
uint8_t SD_init(void){
	ADCPower(TRUE);				//power up portEX
	Ext1Power(TRUE);			//power up SD card
	_delay_ms(100);				//wait for bootup
	uint8_t errorCode = 0;
    4f5c:	ff 24       	eor	r15, r15
    4f5e:	02 c0       	rjmp	.+4      	; 0x4f64 <SD_init+0xb4>
	SPIInit2(SPI_MODE_0_gc,SPI_LOWEST_CLOCKRATE_PRESCALAR);
	SPICS(TRUE);
	for(int i=0;SD_command(SDHC_CMD_RESET,SDHC_NO_ARGUMENTS,SDHC_CMD_RESET_CRC,8) != SDHC_IDLE_STATE; i++){		//send command 0 to put card in idle state and read 8 next bytes sent back or until response read
		if (i >= 10) {												//try command 10 times before timing out
			//there was no response to the first command
			errorCode = 1;
    4f60:	ff 24       	eor	r15, r15
    4f62:	f3 94       	inc	r15
    4f64:	8f ef       	ldi	r24, 0xFF	; 255
    4f66:	93 ec       	ldi	r25, 0xC3	; 195
    4f68:	a9 e0       	ldi	r26, 0x09	; 9
    4f6a:	81 50       	subi	r24, 0x01	; 1
    4f6c:	90 40       	sbci	r25, 0x00	; 0
    4f6e:	a0 40       	sbci	r26, 0x00	; 0
    4f70:	e1 f7       	brne	.-8      	; 0x4f6a <SD_init+0xba>
    4f72:	00 c0       	rjmp	.+0      	; 0x4f74 <SD_init+0xc4>
    4f74:	00 00       	nop
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    4f76:	cb e0       	ldi	r28, 0x0B	; 11
    4f78:	d0 e0       	ldi	r29, 0x00	; 0
    4f7a:	02 c0       	rjmp	.+4      	; 0x4f80 <SD_init+0xd0>
    4f7c:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    4f7e:	69 f0       	breq	.+26     	; 0x4f9a <SD_init+0xea>
			break;
		}
	}
	_delay_ms(100);	
	
	for(int i=0;SD_command(SDHC_CHECK_VOLTAGE_CMD,SDHC_CHECK_VOLTAGE_ARGUMENT,SDHC_CHECK_VOLTAGE_CRC,8) != SDHC_IDLE_STATE; i++){		//check voltage range (used to indicate to sd card that we know it is an sdhc card)
    4f80:	88 e0       	ldi	r24, 0x08	; 8
    4f82:	4a ea       	ldi	r20, 0xAA	; 170
    4f84:	51 e0       	ldi	r21, 0x01	; 1
    4f86:	60 e0       	ldi	r22, 0x00	; 0
    4f88:	70 e0       	ldi	r23, 0x00	; 0
    4f8a:	27 e8       	ldi	r18, 0x87	; 135
    4f8c:	08 e0       	ldi	r16, 0x08	; 8
    4f8e:	10 e0       	ldi	r17, 0x00	; 0
    4f90:	0e 94 f7 26 	call	0x4dee	; 0x4dee <SD_command>
    4f94:	81 30       	cpi	r24, 0x01	; 1
    4f96:	91 f7       	brne	.-28     	; 0x4f7c <SD_init+0xcc>
    4f98:	02 c0       	rjmp	.+4      	; 0x4f9e <SD_init+0xee>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    4f9a:	ff 24       	eor	r15, r15
    4f9c:	f3 94       	inc	r15
    4f9e:	c2 e0       	ldi	r28, 0x02	; 2
    4fa0:	d0 e0       	ldi	r29, 0x00	; 0
			break;
		}			
	}		
	for(int i=0;i<4;i++){
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
    4fa2:	0a e8       	ldi	r16, 0x8A	; 138
    4fa4:	10 e5       	ldi	r17, 0x50	; 80
    4fa6:	8f ef       	ldi	r24, 0xFF	; 255
    4fa8:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    4fac:	f8 01       	movw	r30, r16
    4fae:	ec 0f       	add	r30, r28
    4fb0:	fd 1f       	adc	r31, r29
    4fb2:	80 83       	st	Z, r24
    4fb4:	21 96       	adiw	r28, 0x01	; 1
			//there was no response to the command
			errorCode = 1;
			break;
		}			
	}		
	for(int i=0;i<4;i++){
    4fb6:	c6 30       	cpi	r28, 0x06	; 6
    4fb8:	d1 05       	cpc	r29, r1
    4fba:	a9 f7       	brne	.-22     	; 0x4fa6 <SD_init+0xf6>
		Buffer[i+2] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if((Buffer[4] != 0x01) || (Buffer[5] != 0xAA)){			//check that the response is the same as the argument sent in
    4fbc:	80 91 8e 50 	lds	r24, 0x508E
    4fc0:	81 30       	cpi	r24, 0x01	; 1
    4fc2:	29 f4       	brne	.+10     	; 0x4fce <SD_init+0x11e>
    4fc4:	80 91 8f 50 	lds	r24, 0x508F
    4fc8:	8a 3a       	cpi	r24, 0xAA	; 170
    4fca:	21 f4       	brne	.+8      	; 0x4fd4 <SD_init+0x124>
    4fcc:	05 c0       	rjmp	.+10     	; 0x4fd8 <SD_init+0x128>
		//broken card or voltage out of operating range bounds
		errorCode = 1;
    4fce:	ff 24       	eor	r15, r15
    4fd0:	f3 94       	inc	r15
    4fd2:	02 c0       	rjmp	.+4      	; 0x4fd8 <SD_init+0x128>
    4fd4:	ff 24       	eor	r15, r15
    4fd6:	f3 94       	inc	r15
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
    4fd8:	cb e8       	ldi	r28, 0x8B	; 139
    4fda:	d0 e5       	ldi	r29, 0x50	; 80
		//broken card or voltage out of operating range bounds
		errorCode = 1;
	}
	//send second initialization command
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
    4fdc:	87 e3       	ldi	r24, 0x37	; 55
    4fde:	40 e0       	ldi	r20, 0x00	; 0
    4fe0:	50 e0       	ldi	r21, 0x00	; 0
    4fe2:	ba 01       	movw	r22, r20
    4fe4:	2f ef       	ldi	r18, 0xFF	; 255
    4fe6:	08 e0       	ldi	r16, 0x08	; 8
    4fe8:	10 e0       	ldi	r17, 0x00	; 0
    4fea:	0e 94 f7 26 	call	0x4dee	; 0x4dee <SD_command>
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
    4fee:	81 e0       	ldi	r24, 0x01	; 1
    4ff0:	40 e0       	ldi	r20, 0x00	; 0
    4ff2:	50 e0       	ldi	r21, 0x00	; 0
    4ff4:	60 e0       	ldi	r22, 0x00	; 0
    4ff6:	70 e4       	ldi	r23, 0x40	; 64
    4ff8:	2f ef       	ldi	r18, 0xFF	; 255
    4ffa:	0e 94 f7 26 	call	0x4dee	; 0x4dee <SD_command>
	} while(Buffer[1]!= 0x00);
    4ffe:	88 81       	ld	r24, Y
    5000:	88 23       	and	r24, r24
    5002:	61 f7       	brne	.-40     	; 0x4fdc <SD_init+0x12c>
    5004:	cb e0       	ldi	r28, 0x0B	; 11
    5006:	d0 e0       	ldi	r29, 0x00	; 0
    5008:	02 c0       	rjmp	.+4      	; 0x500e <SD_init+0x15e>
    500a:	21 97       	sbiw	r28, 0x01	; 1
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
		if (i >= 10) {
    500c:	61 f0       	breq	.+24     	; 0x5026 <SD_init+0x176>
	do{
		SD_command(SDHC_ADV_COMMAND,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//next command will be advanced
		SD_command(SDHC_INITIALIZATION_CMD,SDHC_INITIALIZATION_CMD_ARGUMENT,SDHC_DUMMY_BYTE,8);	//initialize the SDHC card in SPI mode
	} while(Buffer[1]!= 0x00);
	
	for(int i=0;SD_command(SDHC_CMD_READ_OCR,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//check OCR register
    500e:	8a e3       	ldi	r24, 0x3A	; 58
    5010:	40 e0       	ldi	r20, 0x00	; 0
    5012:	50 e0       	ldi	r21, 0x00	; 0
    5014:	ba 01       	movw	r22, r20
    5016:	2f ef       	ldi	r18, 0xFF	; 255
    5018:	08 e0       	ldi	r16, 0x08	; 8
    501a:	10 e0       	ldi	r17, 0x00	; 0
    501c:	0e 94 f7 26 	call	0x4dee	; 0x4dee <SD_command>
    5020:	88 23       	and	r24, r24
    5022:	99 f7       	brne	.-26     	; 0x500a <SD_init+0x15a>
    5024:	02 c0       	rjmp	.+4      	; 0x502a <SD_init+0x17a>
		if (i >= 10) {
			//there was no response to the command
			errorCode = 1;
    5026:	ff 24       	eor	r15, r15
    5028:	f3 94       	inc	r15
			break;
		}
	}		
	for (int i=0;i<4;i++){
    502a:	c0 e0       	ldi	r28, 0x00	; 0
    502c:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
    502e:	0a e8       	ldi	r16, 0x8A	; 138
    5030:	10 e5       	ldi	r17, 0x50	; 80
    5032:	8f ef       	ldi	r24, 0xFF	; 255
    5034:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    5038:	f8 01       	movw	r30, r16
    503a:	ec 0f       	add	r30, r28
    503c:	fd 1f       	adc	r31, r29
    503e:	80 83       	st	Z, r24
			//there was no response to the command
			errorCode = 1;
			break;
		}
	}		
	for (int i=0;i<4;i++){
    5040:	21 96       	adiw	r28, 0x01	; 1
    5042:	c4 30       	cpi	r28, 0x04	; 4
    5044:	d1 05       	cpc	r29, r1
    5046:	a9 f7       	brne	.-22     	; 0x5032 <SD_init+0x182>
		Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);
	}
	if (Buffer[0] & 0x40){
    5048:	80 91 8a 50 	lds	r24, 0x508A
		//the card is addressed in 512 byte sectors
	}
	SPICS(FALSE);
    504c:	80 e0       	ldi	r24, 0x00	; 0
    504e:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	SPIDisable();
    5052:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5056:	88 e0       	ldi	r24, 0x08	; 8
    5058:	60 e0       	ldi	r22, 0x00	; 0
    505a:	0e 94 8d 1b 	call	0x371a	; 0x371a <PortEx_OUTSET>
	return errorCode;	
}	
    505e:	8f 2d       	mov	r24, r15
    5060:	df 91       	pop	r29
    5062:	cf 91       	pop	r28
    5064:	1f 91       	pop	r17
    5066:	0f 91       	pop	r16
    5068:	ff 90       	pop	r15
    506a:	08 95       	ret

0000506c <SD_write_block>:
	}
	return SDHC_DUMMY_BYTE;
}

//the following command writes one sector to the sdhc card
void SD_write_block(uint32_t sector,uint8_t* data, int lengthOfData){
    506c:	6f 92       	push	r6
    506e:	7f 92       	push	r7
    5070:	8f 92       	push	r8
    5072:	9f 92       	push	r9
    5074:	af 92       	push	r10
    5076:	bf 92       	push	r11
    5078:	cf 92       	push	r12
    507a:	df 92       	push	r13
    507c:	ef 92       	push	r14
    507e:	ff 92       	push	r15
    5080:	0f 93       	push	r16
    5082:	1f 93       	push	r17
    5084:	cf 93       	push	r28
    5086:	df 93       	push	r29
    5088:	4b 01       	movw	r8, r22
    508a:	5c 01       	movw	r10, r24
    508c:	74 2e       	mov	r7, r20
    508e:	65 2e       	mov	r6, r21
    5090:	69 01       	movw	r12, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5092:	88 e0       	ldi	r24, 0x08	; 8
    5094:	60 e0       	ldi	r22, 0x00	; 0
    5096:	0e 94 36 1b 	call	0x366c	; 0x366c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    509a:	80 e0       	ldi	r24, 0x00	; 0
    509c:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
	SPICS(TRUE);
    50a0:	81 e0       	ldi	r24, 0x01	; 1
    50a2:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
    50a6:	80 e0       	ldi	r24, 0x00	; 0
    50a8:	92 e0       	ldi	r25, 0x02	; 2
    50aa:	7c 01       	movw	r14, r24
    50ac:	ec 18       	sub	r14, r12
    50ae:	fd 08       	sbc	r15, r13
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    50b0:	80 e0       	ldi	r24, 0x00	; 0
    50b2:	e8 16       	cp	r14, r24
    50b4:	82 e0       	ldi	r24, 0x02	; 2
    50b6:	f8 06       	cpc	r15, r24
    50b8:	11 f4       	brne	.+4      	; 0x50be <SD_write_block+0x52>
    50ba:	ee 24       	eor	r14, r14
    50bc:	ff 24       	eor	r15, r15
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    50be:	cb e0       	ldi	r28, 0x0B	; 11
    50c0:	d0 e0       	ldi	r29, 0x00	; 0
    50c2:	03 c0       	rjmp	.+6      	; 0x50ca <SD_write_block+0x5e>
    50c4:	21 97       	sbiw	r28, 0x01	; 1
	if (i >= 10) {
    50c6:	09 f4       	brne	.+2      	; 0x50ca <SD_write_block+0x5e>
    50c8:	ff cf       	rjmp	.-2      	; 0x50c8 <SD_write_block+0x5c>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	for(int i=0;SD_command(SDHC_CMD_WRITE_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++){		//write to specified sector
    50ca:	88 e1       	ldi	r24, 0x18	; 24
    50cc:	b5 01       	movw	r22, r10
    50ce:	a4 01       	movw	r20, r8
    50d0:	2f ef       	ldi	r18, 0xFF	; 255
    50d2:	08 e0       	ldi	r16, 0x08	; 8
    50d4:	10 e0       	ldi	r17, 0x00	; 0
    50d6:	0e 94 f7 26 	call	0x4dee	; 0x4dee <SD_command>
    50da:	88 23       	and	r24, r24
    50dc:	99 f7       	brne	.-26     	; 0x50c4 <SD_write_block+0x58>
	if (i >= 10) {
		//there was no response to the command
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
    50de:	8f ef       	ldi	r24, 0xFF	; 255
    50e0:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    50e4:	80 93 8a 50 	sts	0x508A, r24
SPI_write(SDHC_DATA_TOKEN);	//send data token
    50e8:	8e ef       	ldi	r24, 0xFE	; 254
    50ea:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    50ee:	1c 14       	cp	r1, r12
    50f0:	1d 04       	cpc	r1, r13
    50f2:	bc f4       	brge	.+46     	; 0x5122 <SD_write_block+0xb6>
    50f4:	87 2c       	mov	r8, r7
    50f6:	96 2c       	mov	r9, r6
    50f8:	00 e0       	ldi	r16, 0x00	; 0
    50fa:	10 e0       	ldi	r17, 0x00	; 0
Buffer[i%13] = SPI_write(data[i]);
    50fc:	c8 01       	movw	r24, r16
    50fe:	6d e0       	ldi	r22, 0x0D	; 13
    5100:	70 e0       	ldi	r23, 0x00	; 0
    5102:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <__divmodhi4>
    5106:	ec 01       	movw	r28, r24
    5108:	f4 01       	movw	r30, r8
    510a:	81 91       	ld	r24, Z+
    510c:	4f 01       	movw	r8, r30
    510e:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    5112:	c6 57       	subi	r28, 0x76	; 118
    5114:	df 4a       	sbci	r29, 0xAF	; 175
    5116:	88 83       	st	Y, r24
		while(1);
	}
}
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
    5118:	0f 5f       	subi	r16, 0xFF	; 255
    511a:	1f 4f       	sbci	r17, 0xFF	; 255
    511c:	0c 15       	cp	r16, r12
    511e:	1d 05       	cpc	r17, r13
    5120:	69 f7       	brne	.-38     	; 0x50fc <SD_write_block+0x90>
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5122:	1e 14       	cp	r1, r14
    5124:	1f 04       	cpc	r1, r15
    5126:	ec f4       	brge	.+58     	; 0x5162 <SD_write_block+0xf6>
    5128:	00 e0       	ldi	r16, 0x00	; 0
    512a:	10 e0       	ldi	r17, 0x00	; 0
	Buffer[i%13] = SPI_write(FILLER_BYTE);
    512c:	0f 2e       	mov	r0, r31
    512e:	fd e0       	ldi	r31, 0x0D	; 13
    5130:	cf 2e       	mov	r12, r31
    5132:	dd 24       	eor	r13, r13
    5134:	f0 2d       	mov	r31, r0
    5136:	0f 2e       	mov	r0, r31
    5138:	fa e8       	ldi	r31, 0x8A	; 138
    513a:	8f 2e       	mov	r8, r31
    513c:	f0 e5       	ldi	r31, 0x50	; 80
    513e:	9f 2e       	mov	r9, r31
    5140:	f0 2d       	mov	r31, r0
    5142:	c8 01       	movw	r24, r16
    5144:	b6 01       	movw	r22, r12
    5146:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <__divmodhi4>
    514a:	ec 01       	movw	r28, r24
    514c:	80 e0       	ldi	r24, 0x00	; 0
    514e:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    5152:	c8 0d       	add	r28, r8
    5154:	d9 1d       	adc	r29, r9
    5156:	88 83       	st	Y, r24
Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 1 dummy byte as spacer
SPI_write(SDHC_DATA_TOKEN);	//send data token
for (int i=0;i<lengthOfData;i++){	//write the data segment 1 byte at a time
Buffer[i%13] = SPI_write(data[i]);
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
    5158:	0f 5f       	subi	r16, 0xFF	; 255
    515a:	1f 4f       	sbci	r17, 0xFF	; 255
    515c:	0e 15       	cp	r16, r14
    515e:	1f 05       	cpc	r17, r15
    5160:	81 f7       	brne	.-32     	; 0x5142 <SD_write_block+0xd6>
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
    5162:	8f ef       	ldi	r24, 0xFF	; 255
    5164:	80 93 8a 50 	sts	0x508A, r24
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    5168:	c0 e0       	ldi	r28, 0x00	; 0
    516a:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
    516c:	0a e8       	ldi	r16, 0x8A	; 138
    516e:	10 e5       	ldi	r17, 0x50	; 80
    5170:	8f ef       	ldi	r24, 0xFF	; 255
    5172:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    5176:	f8 01       	movw	r30, r16
    5178:	80 83       	st	Z, r24
	}
	for (int i=0;i<fillerBytes;i++){	//fill the rest of the sector with filler bytes
	Buffer[i%13] = SPI_write(FILLER_BYTE);
	} 
	Buffer[0] = SDHC_DUMMY_BYTE;
	for(int i=0; (i<2) || (Buffer[0] == SDHC_DUMMY_BYTE);i++){
    517a:	21 96       	adiw	r28, 0x01	; 1
    517c:	c2 30       	cpi	r28, 0x02	; 2
    517e:	d1 05       	cpc	r29, r1
    5180:	bc f3       	brlt	.-18     	; 0x5170 <SD_write_block+0x104>
    5182:	80 81       	ld	r24, Z
    5184:	8f 3f       	cpi	r24, 0xFF	; 255
    5186:	a1 f3       	breq	.-24     	; 0x5170 <SD_write_block+0x104>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//send 2 CRC dummy bytes and keep reading bytes until a response is seen 	
	}
	if ((Buffer[0] & SDHC_RESPONSE_STATUS_MASK) == 0x02){
    5188:	80 91 8a 50 	lds	r24, 0x508A
		//data was written successfully
	}
	while(Buffer[0] != SDHC_DUMMY_BYTE) Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to finish internal processes
    518c:	80 91 8a 50 	lds	r24, 0x508A
    5190:	8f 3f       	cpi	r24, 0xFF	; 255
    5192:	49 f0       	breq	.+18     	; 0x51a6 <SD_write_block+0x13a>
    5194:	ca e8       	ldi	r28, 0x8A	; 138
    5196:	d0 e5       	ldi	r29, 0x50	; 80
    5198:	8f ef       	ldi	r24, 0xFF	; 255
    519a:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    519e:	88 83       	st	Y, r24
    51a0:	88 81       	ld	r24, Y
    51a2:	8f 3f       	cpi	r24, 0xFF	; 255
    51a4:	c9 f7       	brne	.-14     	; 0x5198 <SD_write_block+0x12c>
	SPICS(FALSE);
    51a6:	80 e0       	ldi	r24, 0x00	; 0
    51a8:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	SPIDisable();
    51ac:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high	
    51b0:	88 e0       	ldi	r24, 0x08	; 8
    51b2:	60 e0       	ldi	r22, 0x00	; 0
    51b4:	0e 94 8d 1b 	call	0x371a	; 0x371a <PortEx_OUTSET>
}
    51b8:	df 91       	pop	r29
    51ba:	cf 91       	pop	r28
    51bc:	1f 91       	pop	r17
    51be:	0f 91       	pop	r16
    51c0:	ff 90       	pop	r15
    51c2:	ef 90       	pop	r14
    51c4:	df 90       	pop	r13
    51c6:	cf 90       	pop	r12
    51c8:	bf 90       	pop	r11
    51ca:	af 90       	pop	r10
    51cc:	9f 90       	pop	r9
    51ce:	8f 90       	pop	r8
    51d0:	7f 90       	pop	r7
    51d2:	6f 90       	pop	r6
    51d4:	08 95       	ret

000051d6 <SD_read_block>:

//the following command reads one sector from the sdhc card
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
    51d6:	af 92       	push	r10
    51d8:	bf 92       	push	r11
    51da:	cf 92       	push	r12
    51dc:	df 92       	push	r13
    51de:	ef 92       	push	r14
    51e0:	ff 92       	push	r15
    51e2:	0f 93       	push	r16
    51e4:	1f 93       	push	r17
    51e6:	cf 93       	push	r28
    51e8:	df 93       	push	r29
    51ea:	6b 01       	movw	r12, r22
    51ec:	7c 01       	movw	r14, r24
    51ee:	b4 2e       	mov	r11, r20
    51f0:	a5 2e       	mov	r10, r21
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    51f2:	88 e0       	ldi	r24, 0x08	; 8
    51f4:	60 e0       	ldi	r22, 0x00	; 0
    51f6:	0e 94 36 1b 	call	0x366c	; 0x366c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    51fa:	80 e0       	ldi	r24, 0x00	; 0
    51fc:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
	SPICS(TRUE);
    5200:	81 e0       	ldi	r24, 0x01	; 1
    5202:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5206:	cb e0       	ldi	r28, 0x0B	; 11
    5208:	d0 e0       	ldi	r29, 0x00	; 0
    520a:	03 c0       	rjmp	.+6      	; 0x5212 <SD_read_block+0x3c>
    520c:	21 97       	sbiw	r28, 0x01	; 1
		if (i >= 10) {
    520e:	09 f4       	brne	.+2      	; 0x5212 <SD_read_block+0x3c>
    5210:	ff cf       	rjmp	.-2      	; 0x5210 <SD_read_block+0x3a>
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5212:	81 e1       	ldi	r24, 0x11	; 17
    5214:	b7 01       	movw	r22, r14
    5216:	a6 01       	movw	r20, r12
    5218:	2f ef       	ldi	r18, 0xFF	; 255
    521a:	08 e0       	ldi	r16, 0x08	; 8
    521c:	10 e0       	ldi	r17, 0x00	; 0
    521e:	0e 94 f7 26 	call	0x4dee	; 0x4dee <SD_command>
    5222:	88 23       	and	r24, r24
    5224:	99 f7       	brne	.-26     	; 0x520c <SD_read_block+0x36>
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    5226:	80 91 8a 50 	lds	r24, 0x508A
    522a:	8e 3f       	cpi	r24, 0xFE	; 254
    522c:	49 f0       	breq	.+18     	; 0x5240 <SD_read_block+0x6a>
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
    522e:	ca e8       	ldi	r28, 0x8A	; 138
    5230:	d0 e5       	ldi	r29, 0x50	; 80
    5232:	8f ef       	ldi	r24, 0xFF	; 255
    5234:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    5238:	88 83       	st	Y, r24
		if (i >= 10) {
			//there was no response to the command
			while(1);
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
    523a:	88 81       	ld	r24, Y
    523c:	8e 3f       	cpi	r24, 0xFE	; 254
    523e:	c9 f7       	brne	.-14     	; 0x5232 <SD_read_block+0x5c>
    5240:	0b 2d       	mov	r16, r11
    5242:	1a 2d       	mov	r17, r10
void SD_read_block(uint32_t sector,uint8_t* arrayOf512Bytes){
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	
	for(int i=0;SD_command(SDHC_CMD_READ_SINGLE_BLOCK,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS; i++) {	//send command to read data
    5244:	c0 e0       	ldi	r28, 0x00	; 0
    5246:	d0 e0       	ldi	r29, 0x00	; 0
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5248:	8f ef       	ldi	r24, 0xFF	; 255
    524a:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    524e:	f8 01       	movw	r30, r16
    5250:	81 93       	st	Z+, r24
    5252:	8f 01       	movw	r16, r30
		}
	}		
	while(Buffer[0] != SDHC_DATA_TOKEN){
		Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5254:	21 96       	adiw	r28, 0x01	; 1
    5256:	f2 e0       	ldi	r31, 0x02	; 2
    5258:	c0 30       	cpi	r28, 0x00	; 0
    525a:	df 07       	cpc	r29, r31
    525c:	a9 f7       	brne	.-22     	; 0x5248 <SD_read_block+0x72>
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
    525e:	10 92 96 50 	sts	0x5096, r1
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    5262:	80 91 96 50 	lds	r24, 0x5096
    5266:	8f 3f       	cpi	r24, 0xFF	; 255
    5268:	49 f0       	breq	.+18     	; 0x527c <SD_read_block+0xa6>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
    526a:	c6 e9       	ldi	r28, 0x96	; 150
    526c:	d0 e5       	ldi	r29, 0x50	; 80
    526e:	8f ef       	ldi	r24, 0xFF	; 255
    5270:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    5274:	88 83       	st	Y, r24
	}		
	for (int i=0;i<SDHC_SECTOR_SIZE;i++){
		arrayOf512Bytes[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
	}
	Buffer[12] = FILLER_BYTE;
	while (Buffer[12] != SDHC_DUMMY_BYTE){
    5276:	88 81       	ld	r24, Y
    5278:	8f 3f       	cpi	r24, 0xFF	; 255
    527a:	c9 f7       	brne	.-14     	; 0x526e <SD_read_block+0x98>
		Buffer[12] = SPI_write(SDHC_DUMMY_BYTE);	
	}

	SPICS(FALSE);
    527c:	80 e0       	ldi	r24, 0x00	; 0
    527e:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	SPIDisable();
    5282:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5286:	88 e0       	ldi	r24, 0x08	; 8
    5288:	60 e0       	ldi	r22, 0x00	; 0
    528a:	0e 94 8d 1b 	call	0x371a	; 0x371a <PortEx_OUTSET>
}
    528e:	df 91       	pop	r29
    5290:	cf 91       	pop	r28
    5292:	1f 91       	pop	r17
    5294:	0f 91       	pop	r16
    5296:	ff 90       	pop	r15
    5298:	ef 90       	pop	r14
    529a:	df 90       	pop	r13
    529c:	cf 90       	pop	r12
    529e:	bf 90       	pop	r11
    52a0:	af 90       	pop	r10
    52a2:	08 95       	ret

000052a4 <SD_write_multiple_blocks>:

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    52a4:	2f 92       	push	r2
    52a6:	3f 92       	push	r3
    52a8:	4f 92       	push	r4
    52aa:	5f 92       	push	r5
    52ac:	6f 92       	push	r6
    52ae:	7f 92       	push	r7
    52b0:	8f 92       	push	r8
    52b2:	9f 92       	push	r9
    52b4:	af 92       	push	r10
    52b6:	bf 92       	push	r11
    52b8:	cf 92       	push	r12
    52ba:	df 92       	push	r13
    52bc:	ef 92       	push	r14
    52be:	ff 92       	push	r15
    52c0:	0f 93       	push	r16
    52c2:	1f 93       	push	r17
    52c4:	cf 93       	push	r28
    52c6:	df 93       	push	r29
    52c8:	cd b7       	in	r28, 0x3d	; 61
    52ca:	de b7       	in	r29, 0x3e	; 62
    52cc:	2a 97       	sbiw	r28, 0x0a	; 10
    52ce:	cd bf       	out	0x3d, r28	; 61
    52d0:	de bf       	out	0x3e, r29	; 62
    52d2:	6b 01       	movw	r12, r22
    52d4:	7c 01       	movw	r14, r24
    52d6:	4f 83       	std	Y+7, r20	; 0x07
    52d8:	58 87       	std	Y+8, r21	; 0x08
    52da:	89 01       	movw	r16, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    52dc:	88 e0       	ldi	r24, 0x08	; 8
    52de:	60 e0       	ldi	r22, 0x00	; 0
    52e0:	0e 94 36 1b 	call	0x366c	; 0x366c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    52e4:	80 e0       	ldi	r24, 0x00	; 0
    52e6:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
	SPICS(TRUE);
    52ea:	81 e0       	ldi	r24, 0x01	; 1
    52ec:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
    52f0:	c8 01       	movw	r24, r16
    52f2:	11 23       	and	r17, r17
    52f4:	14 f4       	brge	.+4      	; 0x52fa <SD_write_multiple_blocks+0x56>
    52f6:	81 50       	subi	r24, 0x01	; 1
    52f8:	9e 4f       	sbci	r25, 0xFE	; 254
    52fa:	9c 01       	movw	r18, r24
    52fc:	23 2f       	mov	r18, r19
    52fe:	33 0f       	add	r19, r19
    5300:	33 0b       	sbc	r19, r19
    5302:	25 95       	asr	r18
    5304:	2b 83       	std	Y+3, r18	; 0x03
    5306:	3c 83       	std	Y+4, r19	; 0x04
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
    5308:	20 e0       	ldi	r18, 0x00	; 0
    530a:	32 e0       	ldi	r19, 0x02	; 2
    530c:	c8 01       	movw	r24, r16
    530e:	b9 01       	movw	r22, r18
    5310:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <__divmodhi4>
    5314:	29 01       	movw	r4, r18
    5316:	48 1a       	sub	r4, r24
    5318:	59 0a       	sbc	r5, r25
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    531a:	30 e0       	ldi	r19, 0x00	; 0
    531c:	43 16       	cp	r4, r19
    531e:	32 e0       	ldi	r19, 0x02	; 2
    5320:	53 06       	cpc	r5, r19
    5322:	31 f0       	breq	.+12     	; 0x5330 <SD_write_multiple_blocks+0x8c>
	else numSectors++;
    5324:	8b 81       	ldd	r24, Y+3	; 0x03
    5326:	9c 81       	ldd	r25, Y+4	; 0x04
    5328:	01 96       	adiw	r24, 0x01	; 1
    532a:	8b 83       	std	Y+3, r24	; 0x03
    532c:	9c 83       	std	Y+4, r25	; 0x04
    532e:	02 c0       	rjmp	.+4      	; 0x5334 <SD_write_multiple_blocks+0x90>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
    5330:	44 24       	eor	r4, r4
    5332:	55 24       	eor	r5, r5
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
    5334:	89 e1       	ldi	r24, 0x19	; 25
    5336:	b7 01       	movw	r22, r14
    5338:	a6 01       	movw	r20, r12
    533a:	2f ef       	ldi	r18, 0xFF	; 255
    533c:	08 e0       	ldi	r16, 0x08	; 8
    533e:	10 e0       	ldi	r17, 0x00	; 0
    5340:	0e 94 f7 26 	call	0x4dee	; 0x4dee <SD_command>
    5344:	88 23       	and	r24, r24
    5346:	b1 f7       	brne	.-20     	; 0x5334 <SD_write_multiple_blocks+0x90>
	for (int j=0;j<numSectors;j++){
    5348:	eb 81       	ldd	r30, Y+3	; 0x03
    534a:	fc 81       	ldd	r31, Y+4	; 0x04
    534c:	1e 16       	cp	r1, r30
    534e:	1f 06       	cpc	r1, r31
    5350:	0c f0       	brlt	.+2      	; 0x5354 <SD_write_multiple_blocks+0xb0>
    5352:	ac c0       	rjmp	.+344    	; 0x54ac <SD_write_multiple_blocks+0x208>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5354:	31 97       	sbiw	r30, 0x01	; 1
    5356:	ed 83       	std	Y+5, r30	; 0x05
    5358:	fe 83       	std	Y+6, r31	; 0x06
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    535a:	9f 01       	movw	r18, r30
    535c:	32 2f       	mov	r19, r18
    535e:	22 27       	eor	r18, r18
    5360:	33 0f       	add	r19, r19
    5362:	8f 81       	ldd	r24, Y+7	; 0x07
    5364:	98 85       	ldd	r25, Y+8	; 0x08
    5366:	89 83       	std	Y+1, r24	; 0x01
    5368:	9a 83       	std	Y+2, r25	; 0x02
    536a:	66 24       	eor	r6, r6
    536c:	77 24       	eor	r7, r7
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    536e:	0f 2e       	mov	r0, r31
    5370:	fb e8       	ldi	r31, 0x8B	; 139
    5372:	8f 2e       	mov	r8, r31
    5374:	f0 e5       	ldi	r31, 0x50	; 80
    5376:	9f 2e       	mov	r9, r31
    5378:	f0 2d       	mov	r31, r0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    537a:	0f 2e       	mov	r0, r31
    537c:	fc e0       	ldi	r31, 0x0C	; 12
    537e:	cf 2e       	mov	r12, r31
    5380:	dd 24       	eor	r13, r13
    5382:	f0 2d       	mov	r31, r0
    5384:	0f 2e       	mov	r0, r31
    5386:	fa e8       	ldi	r31, 0x8A	; 138
    5388:	af 2e       	mov	r10, r31
    538a:	f0 e5       	ldi	r31, 0x50	; 80
    538c:	bf 2e       	mov	r11, r31
    538e:	f0 2d       	mov	r31, r0
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    5390:	80 e0       	ldi	r24, 0x00	; 0
    5392:	92 e0       	ldi	r25, 0x02	; 2
    5394:	1c 01       	movw	r2, r24
    5396:	24 18       	sub	r2, r4
    5398:	35 08       	sbc	r3, r5
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    539a:	ef 81       	ldd	r30, Y+7	; 0x07
    539c:	f8 85       	ldd	r31, Y+8	; 0x08
    539e:	e2 0f       	add	r30, r18
    53a0:	f3 1f       	adc	r31, r19
    53a2:	ef 83       	std	Y+7, r30	; 0x07
    53a4:	f8 87       	std	Y+8, r31	; 0x08
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
    53a6:	8f ef       	ldi	r24, 0xFF	; 255
    53a8:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    53ac:	f4 01       	movw	r30, r8
    53ae:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
    53b0:	8c ef       	ldi	r24, 0xFC	; 252
    53b2:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    53b6:	f4 01       	movw	r30, r8
    53b8:	80 83       	st	Z, r24
		if(j == (numSectors-1)){
    53ba:	2d 81       	ldd	r18, Y+5	; 0x05
    53bc:	3e 81       	ldd	r19, Y+6	; 0x06
    53be:	26 15       	cp	r18, r6
    53c0:	37 05       	cpc	r19, r7
    53c2:	09 f0       	breq	.+2      	; 0x53c6 <SD_write_multiple_blocks+0x122>
    53c4:	41 c0       	rjmp	.+130    	; 0x5448 <SD_write_multiple_blocks+0x1a4>
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    53c6:	12 14       	cp	r1, r2
    53c8:	13 04       	cpc	r1, r3
    53ca:	cc f4       	brge	.+50     	; 0x53fe <SD_write_multiple_blocks+0x15a>
	SPIDisable();
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
}

//the following command writes multiple blocks/sectors to the sd card starting at a specified sector (in the sd card)
void SD_write_multiple_blocks(uint32_t sector,uint8_t* data,int lengthOfData){
    53cc:	ef 80       	ldd	r14, Y+7	; 0x07
    53ce:	f8 84       	ldd	r15, Y+8	; 0x08
    53d0:	00 e0       	ldi	r16, 0x00	; 0
    53d2:	10 e0       	ldi	r17, 0x00	; 0
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    53d4:	c8 01       	movw	r24, r16
    53d6:	b6 01       	movw	r22, r12
    53d8:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <__divmodhi4>
    53dc:	89 87       	std	Y+9, r24	; 0x09
    53de:	9a 87       	std	Y+10, r25	; 0x0a
    53e0:	f7 01       	movw	r30, r14
    53e2:	81 91       	ld	r24, Z+
    53e4:	7f 01       	movw	r14, r30
    53e6:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    53ea:	e9 85       	ldd	r30, Y+9	; 0x09
    53ec:	fa 85       	ldd	r31, Y+10	; 0x0a
    53ee:	ea 0d       	add	r30, r10
    53f0:	fb 1d       	adc	r31, r11
    53f2:	80 83       	st	Z, r24
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
    53f4:	0f 5f       	subi	r16, 0xFF	; 255
    53f6:	1f 4f       	sbci	r17, 0xFF	; 255
    53f8:	02 15       	cp	r16, r2
    53fa:	13 05       	cpc	r17, r3
    53fc:	59 f7       	brne	.-42     	; 0x53d4 <SD_write_multiple_blocks+0x130>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    53fe:	14 14       	cp	r1, r4
    5400:	15 04       	cpc	r1, r5
    5402:	9c f4       	brge	.+38     	; 0x542a <SD_write_multiple_blocks+0x186>
    5404:	00 e0       	ldi	r16, 0x00	; 0
    5406:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
    5408:	c8 01       	movw	r24, r16
    540a:	b6 01       	movw	r22, r12
    540c:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <__divmodhi4>
    5410:	7c 01       	movw	r14, r24
    5412:	80 e0       	ldi	r24, 0x00	; 0
    5414:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    5418:	f5 01       	movw	r30, r10
    541a:	ee 0d       	add	r30, r14
    541c:	ff 1d       	adc	r31, r15
    541e:	80 83       	st	Z, r24
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
			for (int i=0;i<(SDHC_SECTOR_SIZE-fillerBytes);i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
			for (int i=0;i<fillerBytes;i++){
    5420:	0f 5f       	subi	r16, 0xFF	; 255
    5422:	1f 4f       	sbci	r17, 0xFF	; 255
    5424:	04 15       	cp	r16, r4
    5426:	15 05       	cpc	r17, r5
    5428:	79 f7       	brne	.-34     	; 0x5408 <SD_write_multiple_blocks+0x164>
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
    542a:	8f ef       	ldi	r24, 0xFF	; 255
    542c:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    5430:	f4 01       	movw	r30, r8
    5432:	80 83       	st	Z, r24
    5434:	8f ef       	ldi	r24, 0xFF	; 255
    5436:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    543a:	f4 01       	movw	r30, r8
    543c:	80 83       	st	Z, r24
		Buffer[1] = FILLER_BYTE;
    543e:	10 82       	st	Z, r1
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    5440:	80 81       	ld	r24, Z
    5442:	8f 3f       	cpi	r24, 0xFF	; 255
    5444:	e1 f4       	brne	.+56     	; 0x547e <SD_write_multiple_blocks+0x1da>
    5446:	23 c0       	rjmp	.+70     	; 0x548e <SD_write_multiple_blocks+0x1ea>
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    5448:	e9 80       	ldd	r14, Y+1	; 0x01
    544a:	fa 80       	ldd	r15, Y+2	; 0x02
    544c:	00 e0       	ldi	r16, 0x00	; 0
    544e:	10 e0       	ldi	r17, 0x00	; 0
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
    5450:	c8 01       	movw	r24, r16
    5452:	b6 01       	movw	r22, r12
    5454:	0e 94 4d 35 	call	0x6a9a	; 0x6a9a <__divmodhi4>
    5458:	89 87       	std	Y+9, r24	; 0x09
    545a:	9a 87       	std	Y+10, r25	; 0x0a
    545c:	f7 01       	movw	r30, r14
    545e:	81 91       	ld	r24, Z+
    5460:	7f 01       	movw	r14, r30
    5462:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    5466:	e9 85       	ldd	r30, Y+9	; 0x09
    5468:	fa 85       	ldd	r31, Y+10	; 0x0a
    546a:	ea 0d       	add	r30, r10
    546c:	fb 1d       	adc	r31, r11
    546e:	80 83       	st	Z, r24
			for (int i=0;i<fillerBytes;i++){
				Buffer[i%12] = SPI_write(FILLER_BYTE);
			}
		}
		else{
			for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5470:	0f 5f       	subi	r16, 0xFF	; 255
    5472:	1f 4f       	sbci	r17, 0xFF	; 255
    5474:	f2 e0       	ldi	r31, 0x02	; 2
    5476:	00 30       	cpi	r16, 0x00	; 0
    5478:	1f 07       	cpc	r17, r31
    547a:	51 f7       	brne	.-44     	; 0x5450 <SD_write_multiple_blocks+0x1ac>
    547c:	d6 cf       	rjmp	.-84     	; 0x542a <SD_write_multiple_blocks+0x186>
				Buffer[i%12] = SPI_write(data[(i+(j*SDHC_SECTOR_SIZE))]);
			}
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
    547e:	8f ef       	ldi	r24, 0xFF	; 255
    5480:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    5484:	f4 01       	movw	r30, r8
    5486:	80 83       	st	Z, r24
    5488:	80 81       	ld	r24, Z
    548a:	8f 3f       	cpi	r24, 0xFF	; 255
    548c:	c1 f7       	brne	.-16     	; 0x547e <SD_write_multiple_blocks+0x1da>
	int numSectors = lengthOfData/SDHC_SECTOR_SIZE;
	int fillerBytes = SDHC_SECTOR_SIZE - lengthOfData%SDHC_SECTOR_SIZE;
	if (fillerBytes==SDHC_SECTOR_SIZE) fillerBytes = 0;
	else numSectors++;
	while(SD_command(SDHC_CMD_WRITE_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//write starting at specified sector
	for (int j=0;j<numSectors;j++){
    548e:	08 94       	sec
    5490:	61 1c       	adc	r6, r1
    5492:	71 1c       	adc	r7, r1
    5494:	29 81       	ldd	r18, Y+1	; 0x01
    5496:	3a 81       	ldd	r19, Y+2	; 0x02
    5498:	20 50       	subi	r18, 0x00	; 0
    549a:	3e 4f       	sbci	r19, 0xFE	; 254
    549c:	29 83       	std	Y+1, r18	; 0x01
    549e:	3a 83       	std	Y+2, r19	; 0x02
    54a0:	8b 81       	ldd	r24, Y+3	; 0x03
    54a2:	9c 81       	ldd	r25, Y+4	; 0x04
    54a4:	68 16       	cp	r6, r24
    54a6:	79 06       	cpc	r7, r25
    54a8:	09 f0       	breq	.+2      	; 0x54ac <SD_write_multiple_blocks+0x208>
    54aa:	7d cf       	rjmp	.-262    	; 0x53a6 <SD_write_multiple_blocks+0x102>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//send dummy byte
		Buffer[1] = SPI_write(SDHC_MULT_WRITE_DATA_TOKEN);	//send data token
		if(j == (numSectors-1)){
    54ac:	ee 24       	eor	r14, r14
    54ae:	ff 24       	eor	r15, r15
    54b0:	68 94       	set
    54b2:	e2 f8       	bld	r14, 2
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    54b4:	0b e8       	ldi	r16, 0x8B	; 139
    54b6:	10 e5       	ldi	r17, 0x50	; 80
    54b8:	8f ef       	ldi	r24, 0xFF	; 255
    54ba:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    54be:	f8 01       	movw	r30, r16
    54c0:	80 83       	st	Z, r24
    54c2:	08 94       	sec
    54c4:	e1 08       	sbc	r14, r1
    54c6:	f1 08       	sbc	r15, r1
		}
		for (int i=0;i<2;i++) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write 2 CRC token
		Buffer[1] = FILLER_BYTE;
		while(Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for card to store the data it received
	}
	for(int i=0;i<4;i++){
    54c8:	e1 14       	cp	r14, r1
    54ca:	f1 04       	cpc	r15, r1
    54cc:	a9 f7       	brne	.-22     	; 0x54b8 <SD_write_multiple_blocks+0x214>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
    54ce:	8d ef       	ldi	r24, 0xFD	; 253
    54d0:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    54d4:	80 93 8b 50 	sts	0x508B, r24
    54d8:	ee 24       	eor	r14, r14
    54da:	ff 24       	eor	r15, r15
    54dc:	68 94       	set
    54de:	e2 f8       	bld	r14, 2
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
    54e0:	0b e8       	ldi	r16, 0x8B	; 139
    54e2:	10 e5       	ldi	r17, 0x50	; 80
    54e4:	8f ef       	ldi	r24, 0xFF	; 255
    54e6:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    54ea:	f8 01       	movw	r30, r16
    54ec:	80 83       	st	Z, r24
    54ee:	08 94       	sec
    54f0:	e1 08       	sbc	r14, r1
    54f2:	f1 08       	sbc	r15, r1
	}
	for(int i=0;i<4;i++){
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = SPI_write(SDHC_MULT_WRITE_STOP_TOKEN);	//write stop token
	for(int i=0;i<4;i++){
    54f4:	e1 14       	cp	r14, r1
    54f6:	f1 04       	cpc	r15, r1
    54f8:	a9 f7       	brne	.-22     	; 0x54e4 <SD_write_multiple_blocks+0x240>
		Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//write dummy byte
	}
	Buffer[1] = FILLER_BYTE;
    54fa:	10 92 8b 50 	sts	0x508B, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    54fe:	80 91 8b 50 	lds	r24, 0x508B
    5502:	8f 3f       	cpi	r24, 0xFF	; 255
    5504:	51 f0       	breq	.+20     	; 0x551a <SD_write_multiple_blocks+0x276>
    5506:	0b e8       	ldi	r16, 0x8B	; 139
    5508:	10 e5       	ldi	r17, 0x50	; 80
    550a:	8f ef       	ldi	r24, 0xFF	; 255
    550c:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    5510:	f8 01       	movw	r30, r16
    5512:	80 83       	st	Z, r24
    5514:	80 81       	ld	r24, Z
    5516:	8f 3f       	cpi	r24, 0xFF	; 255
    5518:	c1 f7       	brne	.-16     	; 0x550a <SD_write_multiple_blocks+0x266>
	SPICS(FALSE);
    551a:	80 e0       	ldi	r24, 0x00	; 0
    551c:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	SPIDisable();
    5520:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5524:	88 e0       	ldi	r24, 0x08	; 8
    5526:	60 e0       	ldi	r22, 0x00	; 0
    5528:	0e 94 8d 1b 	call	0x371a	; 0x371a <PortEx_OUTSET>
}
    552c:	2a 96       	adiw	r28, 0x0a	; 10
    552e:	cd bf       	out	0x3d, r28	; 61
    5530:	de bf       	out	0x3e, r29	; 62
    5532:	df 91       	pop	r29
    5534:	cf 91       	pop	r28
    5536:	1f 91       	pop	r17
    5538:	0f 91       	pop	r16
    553a:	ff 90       	pop	r15
    553c:	ef 90       	pop	r14
    553e:	df 90       	pop	r13
    5540:	cf 90       	pop	r12
    5542:	bf 90       	pop	r11
    5544:	af 90       	pop	r10
    5546:	9f 90       	pop	r9
    5548:	8f 90       	pop	r8
    554a:	7f 90       	pop	r7
    554c:	6f 90       	pop	r6
    554e:	5f 90       	pop	r5
    5550:	4f 90       	pop	r4
    5552:	3f 90       	pop	r3
    5554:	2f 90       	pop	r2
    5556:	08 95       	ret

00005558 <SD_read_multiple_blocks>:
//the following command reads multiple blocks from the sd card starting at the specified block/sector
void SD_read_multiple_blocks(uint32_t sector,uint8_t* data,int numOfBlocks){
    5558:	2f 92       	push	r2
    555a:	3f 92       	push	r3
    555c:	4f 92       	push	r4
    555e:	5f 92       	push	r5
    5560:	6f 92       	push	r6
    5562:	7f 92       	push	r7
    5564:	8f 92       	push	r8
    5566:	9f 92       	push	r9
    5568:	af 92       	push	r10
    556a:	bf 92       	push	r11
    556c:	cf 92       	push	r12
    556e:	df 92       	push	r13
    5570:	ef 92       	push	r14
    5572:	ff 92       	push	r15
    5574:	0f 93       	push	r16
    5576:	1f 93       	push	r17
    5578:	cf 93       	push	r28
    557a:	df 93       	push	r29
    557c:	6b 01       	movw	r12, r22
    557e:	7c 01       	movw	r14, r24
    5580:	c4 2f       	mov	r28, r20
    5582:	85 2e       	mov	r8, r21
    5584:	39 01       	movw	r6, r18
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
    5586:	88 e0       	ldi	r24, 0x08	; 8
    5588:	60 e0       	ldi	r22, 0x00	; 0
    558a:	0e 94 36 1b 	call	0x366c	; 0x366c <PortEx_OUTCLR>
	SPIInit(SPI_MODE_0_gc);
    558e:	80 e0       	ldi	r24, 0x00	; 0
    5590:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
	SPICS(TRUE);
    5594:	81 e0       	ldi	r24, 0x01	; 1
    5596:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
    559a:	82 e1       	ldi	r24, 0x12	; 18
    559c:	b7 01       	movw	r22, r14
    559e:	a6 01       	movw	r20, r12
    55a0:	2f ef       	ldi	r18, 0xFF	; 255
    55a2:	08 e0       	ldi	r16, 0x08	; 8
    55a4:	10 e0       	ldi	r17, 0x00	; 0
    55a6:	0e 94 f7 26 	call	0x4dee	; 0x4dee <SD_command>
    55aa:	88 23       	and	r24, r24
    55ac:	b1 f7       	brne	.-20     	; 0x559a <SD_read_multiple_blocks+0x42>
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    55ae:	16 14       	cp	r1, r6
    55b0:	17 04       	cpc	r1, r7
    55b2:	0c f0       	brlt	.+2      	; 0x55b6 <SD_read_multiple_blocks+0x5e>
    55b4:	46 c0       	rjmp	.+140    	; 0x5642 <SD_read_multiple_blocks+0xea>
    55b6:	ac 2e       	mov	r10, r28
    55b8:	b8 2c       	mov	r11, r8
    55ba:	88 24       	eor	r8, r8
    55bc:	99 24       	eor	r9, r9
		Buffer[1]=SDHC_DUMMY_BYTE;
    55be:	0f 2e       	mov	r0, r31
    55c0:	fb e8       	ldi	r31, 0x8B	; 139
    55c2:	cf 2e       	mov	r12, r31
    55c4:	f0 e5       	ldi	r31, 0x50	; 80
    55c6:	df 2e       	mov	r13, r31
    55c8:	f0 2d       	mov	r31, r0
    55ca:	ff 24       	eor	r15, r15
    55cc:	fa 94       	dec	r15
    55ce:	ef 2c       	mov	r14, r15
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    55d0:	0f 2e       	mov	r0, r31
    55d2:	fa e8       	ldi	r31, 0x8A	; 138
    55d4:	4f 2e       	mov	r4, r31
    55d6:	f0 e5       	ldi	r31, 0x50	; 80
    55d8:	5f 2e       	mov	r5, r31
    55da:	f0 2d       	mov	r31, r0
    55dc:	12 01       	movw	r2, r4
    55de:	08 94       	sec
    55e0:	21 1c       	adc	r2, r1
    55e2:	31 1c       	adc	r3, r1
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
    55e4:	f6 01       	movw	r30, r12
    55e6:	e0 82       	st	Z, r14
		while(Buffer[1] != SDHC_DATA_TOKEN){
    55e8:	80 81       	ld	r24, Z
    55ea:	8e 3f       	cpi	r24, 0xFE	; 254
    55ec:	41 f0       	breq	.+16     	; 0x55fe <SD_read_multiple_blocks+0xa6>
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
    55ee:	8f 2d       	mov	r24, r15
    55f0:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    55f4:	f6 01       	movw	r30, r12
    55f6:	80 83       	st	Z, r24
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
    55f8:	80 81       	ld	r24, Z
    55fa:	8e 3f       	cpi	r24, 0xFE	; 254
    55fc:	c1 f7       	brne	.-16     	; 0x55ee <SD_read_multiple_blocks+0x96>
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    55fe:	85 01       	movw	r16, r10
    5600:	c0 e0       	ldi	r28, 0x00	; 0
    5602:	d0 e0       	ldi	r29, 0x00	; 0
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
    5604:	8f 2d       	mov	r24, r15
    5606:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    560a:	f8 01       	movw	r30, r16
    560c:	81 93       	st	Z+, r24
    560e:	8f 01       	movw	r16, r30
	for (int j=0;j<numOfBlocks;j++){
		Buffer[1]=SDHC_DUMMY_BYTE;
		while(Buffer[1] != SDHC_DATA_TOKEN){
			Buffer[1] = SPI_write(SDHC_DUMMY_BYTE);	//wait for start of data token
		}
		for (int i=0;i<SDHC_SECTOR_SIZE;i++){
    5610:	21 96       	adiw	r28, 0x01	; 1
    5612:	f2 e0       	ldi	r31, 0x02	; 2
    5614:	c0 30       	cpi	r28, 0x00	; 0
    5616:	df 07       	cpc	r29, r31
    5618:	a9 f7       	brne	.-22     	; 0x5604 <SD_read_multiple_blocks+0xac>
			data[(i+(j*SDHC_SECTOR_SIZE))] = SPI_write(SDHC_DUMMY_BYTE);	//read in the data
		}
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
    561a:	8f 2d       	mov	r24, r15
    561c:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    5620:	f2 01       	movw	r30, r4
    5622:	80 83       	st	Z, r24
    5624:	8f 2d       	mov	r24, r15
    5626:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    562a:	f1 01       	movw	r30, r2
    562c:	80 83       	st	Z, r24
	PortEx_OUTCLR(BIT3_bm, PS_BANKB);	//pull SD cs low
	SPIInit(SPI_MODE_0_gc);
	SPICS(TRUE);
	while(SD_command(SDHC_CMD_READ_MULTIPLE_BLOCKS,sector,SDHC_DUMMY_BYTE,8) != SDHC_CMD_SUCCESS);	//send command to read data
	//do the following for however many sectors to be read in
	for (int j=0;j<numOfBlocks;j++){
    562e:	08 94       	sec
    5630:	81 1c       	adc	r8, r1
    5632:	91 1c       	adc	r9, r1
    5634:	80 e0       	ldi	r24, 0x00	; 0
    5636:	92 e0       	ldi	r25, 0x02	; 2
    5638:	a8 0e       	add	r10, r24
    563a:	b9 1e       	adc	r11, r25
    563c:	86 14       	cp	r8, r6
    563e:	97 04       	cpc	r9, r7
    5640:	89 f6       	brne	.-94     	; 0x55e4 <SD_read_multiple_blocks+0x8c>
		
		for (int i=0;i<2;i++){
			Buffer[i] = SPI_write(SDHC_DUMMY_BYTE);	//read in the 2 CRC bytes
		}
	}
	SD_command(SDHC_CMD_STOP_TRANSMISSION,SDHC_NO_ARGUMENTS,SDHC_DUMMY_BYTE,8);	//send command to stop reading data
    5642:	8c e0       	ldi	r24, 0x0C	; 12
    5644:	40 e0       	ldi	r20, 0x00	; 0
    5646:	50 e0       	ldi	r21, 0x00	; 0
    5648:	ba 01       	movw	r22, r20
    564a:	2f ef       	ldi	r18, 0xFF	; 255
    564c:	08 e0       	ldi	r16, 0x08	; 8
    564e:	10 e0       	ldi	r17, 0x00	; 0
    5650:	0e 94 f7 26 	call	0x4dee	; 0x4dee <SD_command>
	Buffer[0] = SPI_write(SDHC_DUMMY_BYTE);	//read the stuff byte
    5654:	8f ef       	ldi	r24, 0xFF	; 255
    5656:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    565a:	80 93 8a 50 	sts	0x508A, r24
	Buffer[1] = FILLER_BYTE;
    565e:	10 92 8b 50 	sts	0x508B, r1
	while (Buffer[1] != SDHC_DUMMY_BYTE) Buffer[1] = SPI_write(SDHC_DUMMY_BYTE); //wait for card to finish internal processes
    5662:	80 91 8b 50 	lds	r24, 0x508B
    5666:	8f 3f       	cpi	r24, 0xFF	; 255
    5668:	49 f0       	breq	.+18     	; 0x567c <SD_read_multiple_blocks+0x124>
    566a:	cb e8       	ldi	r28, 0x8B	; 139
    566c:	d0 e5       	ldi	r29, 0x50	; 80
    566e:	8f ef       	ldi	r24, 0xFF	; 255
    5670:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
    5674:	88 83       	st	Y, r24
    5676:	88 81       	ld	r24, Y
    5678:	8f 3f       	cpi	r24, 0xFF	; 255
    567a:	c9 f7       	brne	.-14     	; 0x566e <SD_read_multiple_blocks+0x116>
	SPICS(FALSE);
    567c:	80 e0       	ldi	r24, 0x00	; 0
    567e:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	SPIDisable();
    5682:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);	//pull SD cs high
    5686:	88 e0       	ldi	r24, 0x08	; 8
    5688:	60 e0       	ldi	r22, 0x00	; 0
    568a:	0e 94 8d 1b 	call	0x371a	; 0x371a <PortEx_OUTSET>
}
    568e:	df 91       	pop	r29
    5690:	cf 91       	pop	r28
    5692:	1f 91       	pop	r17
    5694:	0f 91       	pop	r16
    5696:	ff 90       	pop	r15
    5698:	ef 90       	pop	r14
    569a:	df 90       	pop	r13
    569c:	cf 90       	pop	r12
    569e:	bf 90       	pop	r11
    56a0:	af 90       	pop	r10
    56a2:	9f 90       	pop	r9
    56a4:	8f 90       	pop	r8
    56a6:	7f 90       	pop	r7
    56a8:	6f 90       	pop	r6
    56aa:	5f 90       	pop	r5
    56ac:	4f 90       	pop	r4
    56ae:	3f 90       	pop	r3
    56b0:	2f 90       	pop	r2
    56b2:	08 95       	ret

000056b4 <SD_disable>:
//this function deselects the sd card and turns off power to the port expander and the sd card
void SD_disable(){
	PortEx_DIRSET(BIT3_bm, PS_BANKB);  //pull SD card CS high
    56b4:	88 e0       	ldi	r24, 0x08	; 8
    56b6:	60 e0       	ldi	r22, 0x00	; 0
    56b8:	0e 94 3a 1c 	call	0x3874	; 0x3874 <PortEx_DIRSET>
	PortEx_OUTSET(BIT3_bm, PS_BANKB);
    56bc:	88 e0       	ldi	r24, 0x08	; 8
    56be:	60 e0       	ldi	r22, 0x00	; 0
    56c0:	0e 94 8d 1b 	call	0x371a	; 0x371a <PortEx_OUTSET>
	SPIInit(SPI_MODE_0_gc);
    56c4:	80 e0       	ldi	r24, 0x00	; 0
    56c6:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <SPIInit>
	SPICS(TRUE);
    56ca:	81 e0       	ldi	r24, 0x01	; 1
    56cc:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	SPI_write(SDHC_DUMMY_BYTE);	//must write a byte to spi when cd card cs is high to have sd card release MISO line
    56d0:	8f ef       	ldi	r24, 0xFF	; 255
    56d2:	0e 94 ed 26 	call	0x4dda	; 0x4dda <SPI_write>
	SPICS(FALSE);	//stop spi
    56d6:	80 e0       	ldi	r24, 0x00	; 0
    56d8:	0e 94 20 1b 	call	0x3640	; 0x3640 <SPICS>
	SPIDisable();
    56dc:	0e 94 2c 1b 	call	0x3658	; 0x3658 <SPIDisable>
	
	ADCPower(FALSE);		//turn off portEX power
    56e0:	80 e0       	ldi	r24, 0x00	; 0
    56e2:	0e 94 d5 01 	call	0x3aa	; 0x3aa <ADCPower>
	Ext1Power(FALSE);			//power down SD card
    56e6:	80 e0       	ldi	r24, 0x00	; 0
    56e8:	0e 94 9a 1a 	call	0x3534	; 0x3534 <Ext1Power>
}
    56ec:	08 95       	ret

000056ee <storeFilename>:

void storeFilename(char* str){
    56ee:	cf 93       	push	r28
    56f0:	df 93       	push	r29
	int i=0;
	for (;i<strlen(str) && i<15 ;i++) FileName[i] = str[i];
    56f2:	c8 2f       	mov	r28, r24
    56f4:	d9 2f       	mov	r29, r25
	ADCPower(FALSE);		//turn off portEX power
	Ext1Power(FALSE);			//power down SD card
}

void storeFilename(char* str){
	int i=0;
    56f6:	20 e0       	ldi	r18, 0x00	; 0
    56f8:	30 e0       	ldi	r19, 0x00	; 0
	for (;i<strlen(str) && i<15 ;i++) FileName[i] = str[i];
    56fa:	47 e9       	ldi	r20, 0x97	; 151
    56fc:	50 e5       	ldi	r21, 0x50	; 80
    56fe:	07 c0       	rjmp	.+14     	; 0x570e <storeFilename+0x20>
    5700:	69 91       	ld	r22, Y+
    5702:	fa 01       	movw	r30, r20
    5704:	e2 0f       	add	r30, r18
    5706:	f3 1f       	adc	r31, r19
    5708:	60 83       	st	Z, r22
    570a:	2f 5f       	subi	r18, 0xFF	; 255
    570c:	3f 4f       	sbci	r19, 0xFF	; 255
    570e:	a8 2f       	mov	r26, r24
    5710:	b9 2f       	mov	r27, r25
    5712:	fd 01       	movw	r30, r26
    5714:	01 90       	ld	r0, Z+
    5716:	00 20       	and	r0, r0
    5718:	e9 f7       	brne	.-6      	; 0x5714 <storeFilename+0x26>
    571a:	31 97       	sbiw	r30, 0x01	; 1
    571c:	ea 1b       	sub	r30, r26
    571e:	fb 0b       	sbc	r31, r27
    5720:	2e 17       	cp	r18, r30
    5722:	3f 07       	cpc	r19, r31
    5724:	20 f0       	brcs	.+8      	; 0x572e <storeFilename+0x40>
	for (;i<15;i++)	FileName[i] = " ";
    5726:	2f 30       	cpi	r18, 0x0F	; 15
    5728:	31 05       	cpc	r19, r1
    572a:	2c f0       	brlt	.+10     	; 0x5736 <storeFilename+0x48>
    572c:	11 c0       	rjmp	.+34     	; 0x5750 <storeFilename+0x62>
	Ext1Power(FALSE);			//power down SD card
}

void storeFilename(char* str){
	int i=0;
	for (;i<strlen(str) && i<15 ;i++) FileName[i] = str[i];
    572e:	2f 30       	cpi	r18, 0x0F	; 15
    5730:	31 05       	cpc	r19, r1
    5732:	31 f7       	brne	.-52     	; 0x5700 <storeFilename+0x12>
    5734:	0d c0       	rjmp	.+26     	; 0x5750 <storeFilename+0x62>
	for (;i<15;i++)	FileName[i] = " ";
    5736:	4a e1       	ldi	r20, 0x1A	; 26
    5738:	50 e2       	ldi	r21, 0x20	; 32
    573a:	87 e9       	ldi	r24, 0x97	; 151
    573c:	90 e5       	ldi	r25, 0x50	; 80
    573e:	fc 01       	movw	r30, r24
    5740:	e2 0f       	add	r30, r18
    5742:	f3 1f       	adc	r31, r19
    5744:	40 83       	st	Z, r20
    5746:	2f 5f       	subi	r18, 0xFF	; 255
    5748:	3f 4f       	sbci	r19, 0xFF	; 255
    574a:	2f 30       	cpi	r18, 0x0F	; 15
    574c:	31 05       	cpc	r19, r1
    574e:	b9 f7       	brne	.-18     	; 0x573e <storeFilename+0x50>
    5750:	df 91       	pop	r29
    5752:	cf 91       	pop	r28
    5754:	08 95       	ret

00005756 <main>:

volatile int numOfSamples;

int main(void) {
	
	TestCard();
    5756:	0e 94 52 1e 	call	0x3ca4	; 0x3ca4 <TestCard>
	_delay_ms(1000);
	numOfSamples++;
	//sei();
	*/
	while(1){
		nop();
    575a:	00 00       	nop
    575c:	fe cf       	rjmp	.-4      	; 0x575a <main+0x4>

0000575e <__muldi3>:
    575e:	a0 e3       	ldi	r26, 0x30	; 48
    5760:	b0 e0       	ldi	r27, 0x00	; 0
    5762:	e5 eb       	ldi	r30, 0xB5	; 181
    5764:	fb e2       	ldi	r31, 0x2B	; 43
    5766:	0c 94 9f 35 	jmp	0x6b3e	; 0x6b3e <__prologue_saves__+0x4>
    576a:	29 8f       	std	Y+25, r18	; 0x19
    576c:	3a 8f       	std	Y+26, r19	; 0x1a
    576e:	4b 8f       	std	Y+27, r20	; 0x1b
    5770:	5c 8f       	std	Y+28, r21	; 0x1c
    5772:	6d 8f       	std	Y+29, r22	; 0x1d
    5774:	7e 8f       	std	Y+30, r23	; 0x1e
    5776:	8f 8f       	std	Y+31, r24	; 0x1f
    5778:	98 a3       	lds	r25, 0x58
    577a:	a9 8a       	std	Y+17, r10	; 0x11
    577c:	ba 8a       	std	Y+18, r11	; 0x12
    577e:	cb 8a       	std	Y+19, r12	; 0x13
    5780:	dc 8a       	std	Y+20, r13	; 0x14
    5782:	ed 8a       	std	Y+21, r14	; 0x15
    5784:	fe 8a       	std	Y+22, r15	; 0x16
    5786:	0f 8b       	std	Y+23, r16	; 0x17
    5788:	18 8f       	std	Y+24, r17	; 0x18
    578a:	09 8d       	ldd	r16, Y+25	; 0x19
    578c:	1a 8d       	ldd	r17, Y+26	; 0x1a
    578e:	2b 8d       	ldd	r18, Y+27	; 0x1b
    5790:	3c 8d       	ldd	r19, Y+28	; 0x1c
    5792:	09 a3       	lds	r16, 0x59
    5794:	1a a3       	lds	r17, 0x5a
    5796:	2b a3       	lds	r18, 0x5b
    5798:	3c a3       	lds	r19, 0x5c
    579a:	68 01       	movw	r12, r16
    579c:	79 01       	movw	r14, r18
    579e:	8f ef       	ldi	r24, 0xFF	; 255
    57a0:	9f ef       	ldi	r25, 0xFF	; 255
    57a2:	a0 e0       	ldi	r26, 0x00	; 0
    57a4:	b0 e0       	ldi	r27, 0x00	; 0
    57a6:	c8 22       	and	r12, r24
    57a8:	d9 22       	and	r13, r25
    57aa:	ea 22       	and	r14, r26
    57ac:	fb 22       	and	r15, r27
    57ae:	89 01       	movw	r16, r18
    57b0:	22 27       	eor	r18, r18
    57b2:	33 27       	eor	r19, r19
    57b4:	09 a7       	lds	r16, 0x79
    57b6:	1a a7       	lds	r17, 0x7a
    57b8:	2b a7       	lds	r18, 0x7b
    57ba:	3c a7       	lds	r19, 0x7c
    57bc:	09 89       	ldd	r16, Y+17	; 0x11
    57be:	1a 89       	ldd	r17, Y+18	; 0x12
    57c0:	2b 89       	ldd	r18, Y+19	; 0x13
    57c2:	3c 89       	ldd	r19, Y+20	; 0x14
    57c4:	0d a3       	lds	r16, 0x5d
    57c6:	1e a3       	lds	r17, 0x5e
    57c8:	2f a3       	lds	r18, 0x5f
    57ca:	38 a7       	lds	r19, 0x78
    57cc:	48 01       	movw	r8, r16
    57ce:	59 01       	movw	r10, r18
    57d0:	88 22       	and	r8, r24
    57d2:	99 22       	and	r9, r25
    57d4:	aa 22       	and	r10, r26
    57d6:	bb 22       	and	r11, r27
    57d8:	29 01       	movw	r4, r18
    57da:	66 24       	eor	r6, r6
    57dc:	77 24       	eor	r7, r7
    57de:	c5 01       	movw	r24, r10
    57e0:	b4 01       	movw	r22, r8
    57e2:	a7 01       	movw	r20, r14
    57e4:	96 01       	movw	r18, r12
    57e6:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    57ea:	6d a7       	lds	r22, 0x7d
    57ec:	7e a7       	lds	r23, 0x7e
    57ee:	8f a7       	lds	r24, 0x7f
    57f0:	98 ab       	sts	0x58, r25
    57f2:	c3 01       	movw	r24, r6
    57f4:	b2 01       	movw	r22, r4
    57f6:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    57fa:	6b 01       	movw	r12, r22
    57fc:	7c 01       	movw	r14, r24
    57fe:	c5 01       	movw	r24, r10
    5800:	b4 01       	movw	r22, r8
    5802:	29 a5       	lds	r18, 0x69
    5804:	3a a5       	lds	r19, 0x6a
    5806:	4b a5       	lds	r20, 0x6b
    5808:	5c a5       	lds	r21, 0x6c
    580a:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    580e:	4b 01       	movw	r8, r22
    5810:	5c 01       	movw	r10, r24
    5812:	c3 01       	movw	r24, r6
    5814:	b2 01       	movw	r22, r4
    5816:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    581a:	ab 01       	movw	r20, r22
    581c:	bc 01       	movw	r22, r24
    581e:	c8 0c       	add	r12, r8
    5820:	d9 1c       	adc	r13, r9
    5822:	ea 1c       	adc	r14, r10
    5824:	fb 1c       	adc	r15, r11
    5826:	0d a5       	lds	r16, 0x6d
    5828:	1e a5       	lds	r17, 0x6e
    582a:	2f a5       	lds	r18, 0x6f
    582c:	38 a9       	sts	0x48, r19
    582e:	c9 01       	movw	r24, r18
    5830:	aa 27       	eor	r26, r26
    5832:	bb 27       	eor	r27, r27
    5834:	c8 0e       	add	r12, r24
    5836:	d9 1e       	adc	r13, r25
    5838:	ea 1e       	adc	r14, r26
    583a:	fb 1e       	adc	r15, r27
    583c:	c8 14       	cp	r12, r8
    583e:	d9 04       	cpc	r13, r9
    5840:	ea 04       	cpc	r14, r10
    5842:	fb 04       	cpc	r15, r11
    5844:	20 f4       	brcc	.+8      	; 0x584e <__muldi3+0xf0>
    5846:	40 50       	subi	r20, 0x00	; 0
    5848:	50 40       	sbci	r21, 0x00	; 0
    584a:	6f 4f       	sbci	r22, 0xFF	; 255
    584c:	7f 4f       	sbci	r23, 0xFF	; 255
    584e:	c7 01       	movw	r24, r14
    5850:	aa 27       	eor	r26, r26
    5852:	bb 27       	eor	r27, r27
    5854:	84 0f       	add	r24, r20
    5856:	95 1f       	adc	r25, r21
    5858:	a6 1f       	adc	r26, r22
    585a:	b7 1f       	adc	r27, r23
    585c:	8d 83       	std	Y+5, r24	; 0x05
    585e:	9e 83       	std	Y+6, r25	; 0x06
    5860:	af 83       	std	Y+7, r26	; 0x07
    5862:	b8 87       	std	Y+8, r27	; 0x08
    5864:	76 01       	movw	r14, r12
    5866:	dd 24       	eor	r13, r13
    5868:	cc 24       	eor	r12, r12
    586a:	4d a5       	lds	r20, 0x6d
    586c:	5e a5       	lds	r21, 0x6e
    586e:	6f a5       	lds	r22, 0x6f
    5870:	78 a9       	sts	0x48, r23
    5872:	60 70       	andi	r22, 0x00	; 0
    5874:	70 70       	andi	r23, 0x00	; 0
    5876:	c4 0e       	add	r12, r20
    5878:	d5 1e       	adc	r13, r21
    587a:	e6 1e       	adc	r14, r22
    587c:	f7 1e       	adc	r15, r23
    587e:	c9 82       	std	Y+1, r12	; 0x01
    5880:	da 82       	std	Y+2, r13	; 0x02
    5882:	eb 82       	std	Y+3, r14	; 0x03
    5884:	fc 82       	std	Y+4, r15	; 0x04
    5886:	1c 2d       	mov	r17, r12
    5888:	0a 81       	ldd	r16, Y+2	; 0x02
    588a:	8b 80       	ldd	r8, Y+3	; 0x03
    588c:	4c 80       	ldd	r4, Y+4	; 0x04
    588e:	8d 87       	std	Y+13, r24	; 0x0d
    5890:	8e 81       	ldd	r24, Y+6	; 0x06
    5892:	8e 87       	std	Y+14, r24	; 0x0e
    5894:	8f 81       	ldd	r24, Y+7	; 0x07
    5896:	8f 87       	std	Y+15, r24	; 0x0f
    5898:	88 85       	ldd	r24, Y+8	; 0x08
    589a:	88 8b       	std	Y+16, r24	; 0x10
    589c:	2d 89       	ldd	r18, Y+21	; 0x15
    589e:	3e 89       	ldd	r19, Y+22	; 0x16
    58a0:	4f 89       	ldd	r20, Y+23	; 0x17
    58a2:	58 8d       	ldd	r21, Y+24	; 0x18
    58a4:	69 a1       	lds	r22, 0x49
    58a6:	7a a1       	lds	r23, 0x4a
    58a8:	8b a1       	lds	r24, 0x4b
    58aa:	9c a1       	lds	r25, 0x4c
    58ac:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    58b0:	6b 01       	movw	r12, r22
    58b2:	7c 01       	movw	r14, r24
    58b4:	2d 8d       	ldd	r18, Y+29	; 0x1d
    58b6:	3e 8d       	ldd	r19, Y+30	; 0x1e
    58b8:	4f 8d       	ldd	r20, Y+31	; 0x1f
    58ba:	58 a1       	lds	r21, 0x48
    58bc:	6d a1       	lds	r22, 0x4d
    58be:	7e a1       	lds	r23, 0x4e
    58c0:	8f a1       	lds	r24, 0x4f
    58c2:	98 a5       	lds	r25, 0x68
    58c4:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    58c8:	dc 01       	movw	r26, r24
    58ca:	cb 01       	movw	r24, r22
    58cc:	c8 0e       	add	r12, r24
    58ce:	d9 1e       	adc	r13, r25
    58d0:	ea 1e       	adc	r14, r26
    58d2:	fb 1e       	adc	r15, r27
    58d4:	8d 85       	ldd	r24, Y+13	; 0x0d
    58d6:	9e 85       	ldd	r25, Y+14	; 0x0e
    58d8:	af 85       	ldd	r26, Y+15	; 0x0f
    58da:	b8 89       	ldd	r27, Y+16	; 0x10
    58dc:	8c 0d       	add	r24, r12
    58de:	9d 1d       	adc	r25, r13
    58e0:	ae 1d       	adc	r26, r14
    58e2:	bf 1d       	adc	r27, r15
    58e4:	8d 87       	std	Y+13, r24	; 0x0d
    58e6:	9e 87       	std	Y+14, r25	; 0x0e
    58e8:	af 87       	std	Y+15, r26	; 0x0f
    58ea:	b8 8b       	std	Y+16, r27	; 0x10
    58ec:	68 2f       	mov	r22, r24
    58ee:	7e 85       	ldd	r23, Y+14	; 0x0e
    58f0:	21 2f       	mov	r18, r17
    58f2:	30 2f       	mov	r19, r16
    58f4:	48 2d       	mov	r20, r8
    58f6:	54 2d       	mov	r21, r4
    58f8:	8f 85       	ldd	r24, Y+15	; 0x0f
    58fa:	98 89       	ldd	r25, Y+16	; 0x10
    58fc:	e0 96       	adiw	r28, 0x30	; 48
    58fe:	e0 e1       	ldi	r30, 0x10	; 16
    5900:	0c 94 b8 35 	jmp	0x6b70	; 0x6b70 <__epilogue_restores__+0x4>

00005904 <__ashldi3>:
    5904:	cf 92       	push	r12
    5906:	df 92       	push	r13
    5908:	ef 92       	push	r14
    590a:	ff 92       	push	r15
    590c:	0f 93       	push	r16
    590e:	cf 93       	push	r28
    5910:	df 93       	push	r29
    5912:	cd b7       	in	r28, 0x3d	; 61
    5914:	de b7       	in	r29, 0x3e	; 62
    5916:	60 97       	sbiw	r28, 0x10	; 16
    5918:	cd bf       	out	0x3d, r28	; 61
    591a:	de bf       	out	0x3e, r29	; 62
    591c:	00 23       	and	r16, r16
    591e:	09 f4       	brne	.+2      	; 0x5922 <__ashldi3+0x1e>
    5920:	5a c0       	rjmp	.+180    	; 0x59d6 <__ashldi3+0xd2>
    5922:	29 87       	std	Y+9, r18	; 0x09
    5924:	3a 87       	std	Y+10, r19	; 0x0a
    5926:	4b 87       	std	Y+11, r20	; 0x0b
    5928:	5c 87       	std	Y+12, r21	; 0x0c
    592a:	6d 87       	std	Y+13, r22	; 0x0d
    592c:	7e 87       	std	Y+14, r23	; 0x0e
    592e:	8f 87       	std	Y+15, r24	; 0x0f
    5930:	98 8b       	std	Y+16, r25	; 0x10
    5932:	80 e2       	ldi	r24, 0x20	; 32
    5934:	80 1b       	sub	r24, r16
    5936:	49 85       	ldd	r20, Y+9	; 0x09
    5938:	5a 85       	ldd	r21, Y+10	; 0x0a
    593a:	6b 85       	ldd	r22, Y+11	; 0x0b
    593c:	7c 85       	ldd	r23, Y+12	; 0x0c
    593e:	18 16       	cp	r1, r24
    5940:	b4 f0       	brlt	.+44     	; 0x596e <__ashldi3+0x6a>
    5942:	19 82       	std	Y+1, r1	; 0x01
    5944:	1a 82       	std	Y+2, r1	; 0x02
    5946:	1b 82       	std	Y+3, r1	; 0x03
    5948:	1c 82       	std	Y+4, r1	; 0x04
    594a:	99 27       	eor	r25, r25
    594c:	87 fd       	sbrc	r24, 7
    594e:	90 95       	com	r25
    5950:	90 95       	com	r25
    5952:	81 95       	neg	r24
    5954:	9f 4f       	sbci	r25, 0xFF	; 255
    5956:	04 c0       	rjmp	.+8      	; 0x5960 <__ashldi3+0x5c>
    5958:	44 0f       	add	r20, r20
    595a:	55 1f       	adc	r21, r21
    595c:	66 1f       	adc	r22, r22
    595e:	77 1f       	adc	r23, r23
    5960:	8a 95       	dec	r24
    5962:	d2 f7       	brpl	.-12     	; 0x5958 <__ashldi3+0x54>
    5964:	4d 83       	std	Y+5, r20	; 0x05
    5966:	5e 83       	std	Y+6, r21	; 0x06
    5968:	6f 83       	std	Y+7, r22	; 0x07
    596a:	78 87       	std	Y+8, r23	; 0x08
    596c:	2c c0       	rjmp	.+88     	; 0x59c6 <__ashldi3+0xc2>
    596e:	6a 01       	movw	r12, r20
    5970:	7b 01       	movw	r14, r22
    5972:	00 2e       	mov	r0, r16
    5974:	04 c0       	rjmp	.+8      	; 0x597e <__ashldi3+0x7a>
    5976:	cc 0c       	add	r12, r12
    5978:	dd 1c       	adc	r13, r13
    597a:	ee 1c       	adc	r14, r14
    597c:	ff 1c       	adc	r15, r15
    597e:	0a 94       	dec	r0
    5980:	d2 f7       	brpl	.-12     	; 0x5976 <__ashldi3+0x72>
    5982:	c9 82       	std	Y+1, r12	; 0x01
    5984:	da 82       	std	Y+2, r13	; 0x02
    5986:	eb 82       	std	Y+3, r14	; 0x03
    5988:	fc 82       	std	Y+4, r15	; 0x04
    598a:	6a 01       	movw	r12, r20
    598c:	7b 01       	movw	r14, r22
    598e:	04 c0       	rjmp	.+8      	; 0x5998 <__ashldi3+0x94>
    5990:	f6 94       	lsr	r15
    5992:	e7 94       	ror	r14
    5994:	d7 94       	ror	r13
    5996:	c7 94       	ror	r12
    5998:	8a 95       	dec	r24
    599a:	d2 f7       	brpl	.-12     	; 0x5990 <__ashldi3+0x8c>
    599c:	d7 01       	movw	r26, r14
    599e:	c6 01       	movw	r24, r12
    59a0:	4d 85       	ldd	r20, Y+13	; 0x0d
    59a2:	5e 85       	ldd	r21, Y+14	; 0x0e
    59a4:	6f 85       	ldd	r22, Y+15	; 0x0f
    59a6:	78 89       	ldd	r23, Y+16	; 0x10
    59a8:	04 c0       	rjmp	.+8      	; 0x59b2 <__ashldi3+0xae>
    59aa:	44 0f       	add	r20, r20
    59ac:	55 1f       	adc	r21, r21
    59ae:	66 1f       	adc	r22, r22
    59b0:	77 1f       	adc	r23, r23
    59b2:	0a 95       	dec	r16
    59b4:	d2 f7       	brpl	.-12     	; 0x59aa <__ashldi3+0xa6>
    59b6:	84 2b       	or	r24, r20
    59b8:	95 2b       	or	r25, r21
    59ba:	a6 2b       	or	r26, r22
    59bc:	b7 2b       	or	r27, r23
    59be:	8d 83       	std	Y+5, r24	; 0x05
    59c0:	9e 83       	std	Y+6, r25	; 0x06
    59c2:	af 83       	std	Y+7, r26	; 0x07
    59c4:	b8 87       	std	Y+8, r27	; 0x08
    59c6:	29 81       	ldd	r18, Y+1	; 0x01
    59c8:	3a 81       	ldd	r19, Y+2	; 0x02
    59ca:	4b 81       	ldd	r20, Y+3	; 0x03
    59cc:	5c 81       	ldd	r21, Y+4	; 0x04
    59ce:	6d 81       	ldd	r22, Y+5	; 0x05
    59d0:	7e 81       	ldd	r23, Y+6	; 0x06
    59d2:	8f 81       	ldd	r24, Y+7	; 0x07
    59d4:	98 85       	ldd	r25, Y+8	; 0x08
    59d6:	60 96       	adiw	r28, 0x10	; 16
    59d8:	cd bf       	out	0x3d, r28	; 61
    59da:	de bf       	out	0x3e, r29	; 62
    59dc:	df 91       	pop	r29
    59de:	cf 91       	pop	r28
    59e0:	0f 91       	pop	r16
    59e2:	ff 90       	pop	r15
    59e4:	ef 90       	pop	r14
    59e6:	df 90       	pop	r13
    59e8:	cf 90       	pop	r12
    59ea:	08 95       	ret

000059ec <__ashrdi3>:
    59ec:	0f 93       	push	r16
    59ee:	cf 93       	push	r28
    59f0:	df 93       	push	r29
    59f2:	cd b7       	in	r28, 0x3d	; 61
    59f4:	de b7       	in	r29, 0x3e	; 62
    59f6:	60 97       	sbiw	r28, 0x10	; 16
    59f8:	cd bf       	out	0x3d, r28	; 61
    59fa:	de bf       	out	0x3e, r29	; 62
    59fc:	00 23       	and	r16, r16
    59fe:	09 f4       	brne	.+2      	; 0x5a02 <__ashrdi3+0x16>
    5a00:	56 c0       	rjmp	.+172    	; 0x5aae <__ashrdi3+0xc2>
    5a02:	29 87       	std	Y+9, r18	; 0x09
    5a04:	3a 87       	std	Y+10, r19	; 0x0a
    5a06:	4b 87       	std	Y+11, r20	; 0x0b
    5a08:	5c 87       	std	Y+12, r21	; 0x0c
    5a0a:	6d 87       	std	Y+13, r22	; 0x0d
    5a0c:	7e 87       	std	Y+14, r23	; 0x0e
    5a0e:	8f 87       	std	Y+15, r24	; 0x0f
    5a10:	98 8b       	std	Y+16, r25	; 0x10
    5a12:	20 e2       	ldi	r18, 0x20	; 32
    5a14:	20 1b       	sub	r18, r16
    5a16:	8d 85       	ldd	r24, Y+13	; 0x0d
    5a18:	9e 85       	ldd	r25, Y+14	; 0x0e
    5a1a:	af 85       	ldd	r26, Y+15	; 0x0f
    5a1c:	b8 89       	ldd	r27, Y+16	; 0x10
    5a1e:	ac 01       	movw	r20, r24
    5a20:	bd 01       	movw	r22, r26
    5a22:	12 16       	cp	r1, r18
    5a24:	b4 f0       	brlt	.+44     	; 0x5a52 <__ashrdi3+0x66>
    5a26:	77 0f       	add	r23, r23
    5a28:	44 0b       	sbc	r20, r20
    5a2a:	54 2f       	mov	r21, r20
    5a2c:	ba 01       	movw	r22, r20
    5a2e:	4d 83       	std	Y+5, r20	; 0x05
    5a30:	5e 83       	std	Y+6, r21	; 0x06
    5a32:	6f 83       	std	Y+7, r22	; 0x07
    5a34:	78 87       	std	Y+8, r23	; 0x08
    5a36:	33 27       	eor	r19, r19
    5a38:	27 fd       	sbrc	r18, 7
    5a3a:	30 95       	com	r19
    5a3c:	30 95       	com	r19
    5a3e:	21 95       	neg	r18
    5a40:	3f 4f       	sbci	r19, 0xFF	; 255
    5a42:	04 c0       	rjmp	.+8      	; 0x5a4c <__ashrdi3+0x60>
    5a44:	b5 95       	asr	r27
    5a46:	a7 95       	ror	r26
    5a48:	97 95       	ror	r25
    5a4a:	87 95       	ror	r24
    5a4c:	2a 95       	dec	r18
    5a4e:	d2 f7       	brpl	.-12     	; 0x5a44 <__ashrdi3+0x58>
    5a50:	22 c0       	rjmp	.+68     	; 0x5a96 <__ashrdi3+0xaa>
    5a52:	00 2e       	mov	r0, r16
    5a54:	04 c0       	rjmp	.+8      	; 0x5a5e <__ashrdi3+0x72>
    5a56:	75 95       	asr	r23
    5a58:	67 95       	ror	r22
    5a5a:	57 95       	ror	r21
    5a5c:	47 95       	ror	r20
    5a5e:	0a 94       	dec	r0
    5a60:	d2 f7       	brpl	.-12     	; 0x5a56 <__ashrdi3+0x6a>
    5a62:	4d 83       	std	Y+5, r20	; 0x05
    5a64:	5e 83       	std	Y+6, r21	; 0x06
    5a66:	6f 83       	std	Y+7, r22	; 0x07
    5a68:	78 87       	std	Y+8, r23	; 0x08
    5a6a:	04 c0       	rjmp	.+8      	; 0x5a74 <__ashrdi3+0x88>
    5a6c:	88 0f       	add	r24, r24
    5a6e:	99 1f       	adc	r25, r25
    5a70:	aa 1f       	adc	r26, r26
    5a72:	bb 1f       	adc	r27, r27
    5a74:	2a 95       	dec	r18
    5a76:	d2 f7       	brpl	.-12     	; 0x5a6c <__ashrdi3+0x80>
    5a78:	49 85       	ldd	r20, Y+9	; 0x09
    5a7a:	5a 85       	ldd	r21, Y+10	; 0x0a
    5a7c:	6b 85       	ldd	r22, Y+11	; 0x0b
    5a7e:	7c 85       	ldd	r23, Y+12	; 0x0c
    5a80:	04 c0       	rjmp	.+8      	; 0x5a8a <__ashrdi3+0x9e>
    5a82:	76 95       	lsr	r23
    5a84:	67 95       	ror	r22
    5a86:	57 95       	ror	r21
    5a88:	47 95       	ror	r20
    5a8a:	0a 95       	dec	r16
    5a8c:	d2 f7       	brpl	.-12     	; 0x5a82 <__ashrdi3+0x96>
    5a8e:	84 2b       	or	r24, r20
    5a90:	95 2b       	or	r25, r21
    5a92:	a6 2b       	or	r26, r22
    5a94:	b7 2b       	or	r27, r23
    5a96:	89 83       	std	Y+1, r24	; 0x01
    5a98:	9a 83       	std	Y+2, r25	; 0x02
    5a9a:	ab 83       	std	Y+3, r26	; 0x03
    5a9c:	bc 83       	std	Y+4, r27	; 0x04
    5a9e:	29 81       	ldd	r18, Y+1	; 0x01
    5aa0:	3a 81       	ldd	r19, Y+2	; 0x02
    5aa2:	4b 81       	ldd	r20, Y+3	; 0x03
    5aa4:	5c 81       	ldd	r21, Y+4	; 0x04
    5aa6:	6d 81       	ldd	r22, Y+5	; 0x05
    5aa8:	7e 81       	ldd	r23, Y+6	; 0x06
    5aaa:	8f 81       	ldd	r24, Y+7	; 0x07
    5aac:	98 85       	ldd	r25, Y+8	; 0x08
    5aae:	60 96       	adiw	r28, 0x10	; 16
    5ab0:	cd bf       	out	0x3d, r28	; 61
    5ab2:	de bf       	out	0x3e, r29	; 62
    5ab4:	df 91       	pop	r29
    5ab6:	cf 91       	pop	r28
    5ab8:	0f 91       	pop	r16
    5aba:	08 95       	ret

00005abc <__divdi3>:
    5abc:	a8 e4       	ldi	r26, 0x48	; 72
    5abe:	b0 e0       	ldi	r27, 0x00	; 0
    5ac0:	e4 e6       	ldi	r30, 0x64	; 100
    5ac2:	fd e2       	ldi	r31, 0x2D	; 45
    5ac4:	0c 94 9e 35 	jmp	0x6b3c	; 0x6b3c <__prologue_saves__+0x2>
    5ac8:	f5 01       	movw	r30, r10
    5aca:	29 a3       	lds	r18, 0x59
    5acc:	3a a3       	lds	r19, 0x5a
    5ace:	4b a3       	lds	r20, 0x5b
    5ad0:	5c a3       	lds	r21, 0x5c
    5ad2:	6d a3       	lds	r22, 0x5d
    5ad4:	7e a3       	lds	r23, 0x5e
    5ad6:	8f a3       	lds	r24, 0x5f
    5ad8:	98 a7       	lds	r25, 0x78
    5ada:	a9 8e       	std	Y+25, r10	; 0x19
    5adc:	fa 8f       	std	Y+26, r31	; 0x1a
    5ade:	cb 8e       	std	Y+27, r12	; 0x1b
    5ae0:	dc 8e       	std	Y+28, r13	; 0x1c
    5ae2:	ed 8e       	std	Y+29, r14	; 0x1d
    5ae4:	fe 8e       	std	Y+30, r15	; 0x1e
    5ae6:	0f 8f       	std	Y+31, r16	; 0x1f
    5ae8:	18 a3       	lds	r17, 0x58
    5aea:	8d a0       	lds	r24, 0x8d
    5aec:	9e a0       	lds	r25, 0x8e
    5aee:	af a0       	lds	r26, 0x8f
    5af0:	b8 a4       	lds	r27, 0xa8
    5af2:	b7 fe       	sbrs	r11, 7
    5af4:	67 c0       	rjmp	.+206    	; 0x5bc4 <__divdi3+0x108>
    5af6:	21 95       	neg	r18
    5af8:	b1 e0       	ldi	r27, 0x01	; 1
    5afa:	12 16       	cp	r1, r18
    5afc:	08 f0       	brcs	.+2      	; 0x5b00 <__divdi3+0x44>
    5afe:	b0 e0       	ldi	r27, 0x00	; 0
    5b00:	31 95       	neg	r19
    5b02:	a1 e0       	ldi	r26, 0x01	; 1
    5b04:	13 16       	cp	r1, r19
    5b06:	08 f0       	brcs	.+2      	; 0x5b0a <__divdi3+0x4e>
    5b08:	a0 e0       	ldi	r26, 0x00	; 0
    5b0a:	b3 2e       	mov	r11, r19
    5b0c:	bb 1a       	sub	r11, r27
    5b0e:	bb 2d       	mov	r27, r11
    5b10:	88 24       	eor	r8, r8
    5b12:	83 94       	inc	r8
    5b14:	3b 15       	cp	r19, r11
    5b16:	08 f0       	brcs	.+2      	; 0x5b1a <__divdi3+0x5e>
    5b18:	88 24       	eor	r8, r8
    5b1a:	a8 29       	or	r26, r8
    5b1c:	41 95       	neg	r20
    5b1e:	31 e0       	ldi	r19, 0x01	; 1
    5b20:	14 16       	cp	r1, r20
    5b22:	08 f0       	brcs	.+2      	; 0x5b26 <__divdi3+0x6a>
    5b24:	30 e0       	ldi	r19, 0x00	; 0
    5b26:	b4 2e       	mov	r11, r20
    5b28:	ba 1a       	sub	r11, r26
    5b2a:	ab 2d       	mov	r26, r11
    5b2c:	88 24       	eor	r8, r8
    5b2e:	83 94       	inc	r8
    5b30:	4b 15       	cp	r20, r11
    5b32:	08 f0       	brcs	.+2      	; 0x5b36 <__divdi3+0x7a>
    5b34:	88 24       	eor	r8, r8
    5b36:	38 29       	or	r19, r8
    5b38:	51 95       	neg	r21
    5b3a:	41 e0       	ldi	r20, 0x01	; 1
    5b3c:	15 16       	cp	r1, r21
    5b3e:	08 f0       	brcs	.+2      	; 0x5b42 <__divdi3+0x86>
    5b40:	40 e0       	ldi	r20, 0x00	; 0
    5b42:	45 2e       	mov	r4, r21
    5b44:	43 1a       	sub	r4, r19
    5b46:	31 e0       	ldi	r19, 0x01	; 1
    5b48:	54 15       	cp	r21, r4
    5b4a:	08 f0       	brcs	.+2      	; 0x5b4e <__divdi3+0x92>
    5b4c:	30 e0       	ldi	r19, 0x00	; 0
    5b4e:	43 2b       	or	r20, r19
    5b50:	61 95       	neg	r22
    5b52:	31 e0       	ldi	r19, 0x01	; 1
    5b54:	16 16       	cp	r1, r22
    5b56:	08 f0       	brcs	.+2      	; 0x5b5a <__divdi3+0x9e>
    5b58:	30 e0       	ldi	r19, 0x00	; 0
    5b5a:	86 2e       	mov	r8, r22
    5b5c:	84 1a       	sub	r8, r20
    5b5e:	41 e0       	ldi	r20, 0x01	; 1
    5b60:	68 15       	cp	r22, r8
    5b62:	08 f0       	brcs	.+2      	; 0x5b66 <__divdi3+0xaa>
    5b64:	40 e0       	ldi	r20, 0x00	; 0
    5b66:	34 2b       	or	r19, r20
    5b68:	71 95       	neg	r23
    5b6a:	41 e0       	ldi	r20, 0x01	; 1
    5b6c:	17 16       	cp	r1, r23
    5b6e:	08 f0       	brcs	.+2      	; 0x5b72 <__divdi3+0xb6>
    5b70:	40 e0       	ldi	r20, 0x00	; 0
    5b72:	57 2f       	mov	r21, r23
    5b74:	53 1b       	sub	r21, r19
    5b76:	31 e0       	ldi	r19, 0x01	; 1
    5b78:	75 17       	cp	r23, r21
    5b7a:	08 f0       	brcs	.+2      	; 0x5b7e <__divdi3+0xc2>
    5b7c:	30 e0       	ldi	r19, 0x00	; 0
    5b7e:	43 2b       	or	r20, r19
    5b80:	81 95       	neg	r24
    5b82:	31 e0       	ldi	r19, 0x01	; 1
    5b84:	18 16       	cp	r1, r24
    5b86:	08 f0       	brcs	.+2      	; 0x5b8a <__divdi3+0xce>
    5b88:	30 e0       	ldi	r19, 0x00	; 0
    5b8a:	68 2f       	mov	r22, r24
    5b8c:	64 1b       	sub	r22, r20
    5b8e:	46 2f       	mov	r20, r22
    5b90:	61 e0       	ldi	r22, 0x01	; 1
    5b92:	84 17       	cp	r24, r20
    5b94:	08 f0       	brcs	.+2      	; 0x5b98 <__divdi3+0xdc>
    5b96:	60 e0       	ldi	r22, 0x00	; 0
    5b98:	36 2b       	or	r19, r22
    5b9a:	91 95       	neg	r25
    5b9c:	93 1b       	sub	r25, r19
    5b9e:	29 a3       	lds	r18, 0x59
    5ba0:	ba a3       	lds	r27, 0x5a
    5ba2:	ab a3       	lds	r26, 0x5b
    5ba4:	4c a2       	lds	r20, 0x9c
    5ba6:	8d a2       	lds	r24, 0x9d
    5ba8:	5e a3       	lds	r21, 0x5e
    5baa:	4f a3       	lds	r20, 0x5f
    5bac:	98 a7       	lds	r25, 0x78
    5bae:	8f ef       	ldi	r24, 0xFF	; 255
    5bb0:	9f ef       	ldi	r25, 0xFF	; 255
    5bb2:	af ef       	ldi	r26, 0xFF	; 255
    5bb4:	bf ef       	ldi	r27, 0xFF	; 255
    5bb6:	25 96       	adiw	r28, 0x05	; 5
    5bb8:	8c af       	sts	0x7c, r24
    5bba:	9d af       	sts	0x7d, r25
    5bbc:	ae af       	sts	0x7e, r26
    5bbe:	bf af       	sts	0x7f, r27
    5bc0:	25 97       	sbiw	r28, 0x05	; 5
    5bc2:	06 c0       	rjmp	.+12     	; 0x5bd0 <__divdi3+0x114>
    5bc4:	25 96       	adiw	r28, 0x05	; 5
    5bc6:	1c ae       	sts	0xbc, r17
    5bc8:	1d ae       	sts	0xbd, r17
    5bca:	1e ae       	sts	0xbe, r17
    5bcc:	1f ae       	sts	0xbf, r17
    5bce:	25 97       	sbiw	r28, 0x05	; 5
    5bd0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    5bd2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    5bd4:	af 8d       	ldd	r26, Y+31	; 0x1f
    5bd6:	b8 a1       	lds	r27, 0x48
    5bd8:	b7 ff       	sbrs	r27, 7
    5bda:	68 c0       	rjmp	.+208    	; 0x5cac <__divdi3+0x1f0>
    5bdc:	25 96       	adiw	r28, 0x05	; 5
    5bde:	2c ad       	sts	0x6c, r18
    5be0:	3d ad       	sts	0x6d, r19
    5be2:	4e ad       	sts	0x6e, r20
    5be4:	5f ad       	sts	0x6f, r21
    5be6:	25 97       	sbiw	r28, 0x05	; 5
    5be8:	20 95       	com	r18
    5bea:	30 95       	com	r19
    5bec:	40 95       	com	r20
    5bee:	50 95       	com	r21
    5bf0:	25 96       	adiw	r28, 0x05	; 5
    5bf2:	2c af       	sts	0x7c, r18
    5bf4:	3d af       	sts	0x7d, r19
    5bf6:	4e af       	sts	0x7e, r20
    5bf8:	5f af       	sts	0x7f, r21
    5bfa:	25 97       	sbiw	r28, 0x05	; 5
    5bfc:	e1 95       	neg	r30
    5bfe:	81 e0       	ldi	r24, 0x01	; 1
    5c00:	1e 16       	cp	r1, r30
    5c02:	08 f0       	brcs	.+2      	; 0x5c06 <__divdi3+0x14a>
    5c04:	80 e0       	ldi	r24, 0x00	; 0
    5c06:	f1 95       	neg	r31
    5c08:	91 e0       	ldi	r25, 0x01	; 1
    5c0a:	1f 16       	cp	r1, r31
    5c0c:	08 f0       	brcs	.+2      	; 0x5c10 <__divdi3+0x154>
    5c0e:	90 e0       	ldi	r25, 0x00	; 0
    5c10:	4f 2f       	mov	r20, r31
    5c12:	48 1b       	sub	r20, r24
    5c14:	81 e0       	ldi	r24, 0x01	; 1
    5c16:	f4 17       	cp	r31, r20
    5c18:	08 f0       	brcs	.+2      	; 0x5c1c <__divdi3+0x160>
    5c1a:	80 e0       	ldi	r24, 0x00	; 0
    5c1c:	98 2b       	or	r25, r24
    5c1e:	c1 94       	neg	r12
    5c20:	81 e0       	ldi	r24, 0x01	; 1
    5c22:	1c 14       	cp	r1, r12
    5c24:	08 f0       	brcs	.+2      	; 0x5c28 <__divdi3+0x16c>
    5c26:	80 e0       	ldi	r24, 0x00	; 0
    5c28:	6c 2d       	mov	r22, r12
    5c2a:	69 1b       	sub	r22, r25
    5c2c:	91 e0       	ldi	r25, 0x01	; 1
    5c2e:	c6 16       	cp	r12, r22
    5c30:	08 f0       	brcs	.+2      	; 0x5c34 <__divdi3+0x178>
    5c32:	90 e0       	ldi	r25, 0x00	; 0
    5c34:	89 2b       	or	r24, r25
    5c36:	d1 94       	neg	r13
    5c38:	91 e0       	ldi	r25, 0x01	; 1
    5c3a:	1d 14       	cp	r1, r13
    5c3c:	08 f0       	brcs	.+2      	; 0x5c40 <__divdi3+0x184>
    5c3e:	90 e0       	ldi	r25, 0x00	; 0
    5c40:	5d 2d       	mov	r21, r13
    5c42:	58 1b       	sub	r21, r24
    5c44:	81 e0       	ldi	r24, 0x01	; 1
    5c46:	d5 16       	cp	r13, r21
    5c48:	08 f0       	brcs	.+2      	; 0x5c4c <__divdi3+0x190>
    5c4a:	80 e0       	ldi	r24, 0x00	; 0
    5c4c:	98 2b       	or	r25, r24
    5c4e:	e1 94       	neg	r14
    5c50:	81 e0       	ldi	r24, 0x01	; 1
    5c52:	1e 14       	cp	r1, r14
    5c54:	08 f0       	brcs	.+2      	; 0x5c58 <__divdi3+0x19c>
    5c56:	80 e0       	ldi	r24, 0x00	; 0
    5c58:	3e 2d       	mov	r19, r14
    5c5a:	39 1b       	sub	r19, r25
    5c5c:	91 e0       	ldi	r25, 0x01	; 1
    5c5e:	e3 16       	cp	r14, r19
    5c60:	08 f0       	brcs	.+2      	; 0x5c64 <__divdi3+0x1a8>
    5c62:	90 e0       	ldi	r25, 0x00	; 0
    5c64:	89 2b       	or	r24, r25
    5c66:	f1 94       	neg	r15
    5c68:	91 e0       	ldi	r25, 0x01	; 1
    5c6a:	1f 14       	cp	r1, r15
    5c6c:	08 f0       	brcs	.+2      	; 0x5c70 <__divdi3+0x1b4>
    5c6e:	90 e0       	ldi	r25, 0x00	; 0
    5c70:	2f 2d       	mov	r18, r15
    5c72:	28 1b       	sub	r18, r24
    5c74:	81 e0       	ldi	r24, 0x01	; 1
    5c76:	f2 16       	cp	r15, r18
    5c78:	08 f0       	brcs	.+2      	; 0x5c7c <__divdi3+0x1c0>
    5c7a:	80 e0       	ldi	r24, 0x00	; 0
    5c7c:	98 2b       	or	r25, r24
    5c7e:	01 95       	neg	r16
    5c80:	81 e0       	ldi	r24, 0x01	; 1
    5c82:	10 16       	cp	r1, r16
    5c84:	08 f0       	brcs	.+2      	; 0x5c88 <__divdi3+0x1cc>
    5c86:	80 e0       	ldi	r24, 0x00	; 0
    5c88:	70 2f       	mov	r23, r16
    5c8a:	79 1b       	sub	r23, r25
    5c8c:	97 2f       	mov	r25, r23
    5c8e:	71 e0       	ldi	r23, 0x01	; 1
    5c90:	09 17       	cp	r16, r25
    5c92:	08 f0       	brcs	.+2      	; 0x5c96 <__divdi3+0x1da>
    5c94:	70 e0       	ldi	r23, 0x00	; 0
    5c96:	87 2b       	or	r24, r23
    5c98:	11 95       	neg	r17
    5c9a:	18 1b       	sub	r17, r24
    5c9c:	e9 8f       	std	Y+25, r30	; 0x19
    5c9e:	4a 8f       	std	Y+26, r20	; 0x1a
    5ca0:	6b 8f       	std	Y+27, r22	; 0x1b
    5ca2:	5c 8f       	std	Y+28, r21	; 0x1c
    5ca4:	3d 8f       	std	Y+29, r19	; 0x1d
    5ca6:	2e 8f       	std	Y+30, r18	; 0x1e
    5ca8:	9f 8f       	std	Y+31, r25	; 0x1f
    5caa:	18 a3       	lds	r17, 0x58
    5cac:	79 8d       	ldd	r23, Y+25	; 0x19
    5cae:	6a 8d       	ldd	r22, Y+26	; 0x1a
    5cb0:	5b 8d       	ldd	r21, Y+27	; 0x1b
    5cb2:	4c 8d       	ldd	r20, Y+28	; 0x1c
    5cb4:	3d 8d       	ldd	r19, Y+29	; 0x1d
    5cb6:	2e 8d       	ldd	r18, Y+30	; 0x1e
    5cb8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    5cba:	88 a1       	lds	r24, 0x48
    5cbc:	e9 a1       	lds	r30, 0x49
    5cbe:	e9 8b       	std	Y+17, r30	; 0x11
    5cc0:	ea a1       	lds	r30, 0x4a
    5cc2:	ea 8b       	std	Y+18, r30	; 0x12
    5cc4:	eb a1       	lds	r30, 0x4b
    5cc6:	eb 8b       	std	Y+19, r30	; 0x13
    5cc8:	ec a1       	lds	r30, 0x4c
    5cca:	ec 8b       	std	Y+20, r30	; 0x14
    5ccc:	ed a1       	lds	r30, 0x4d
    5cce:	ed 8b       	std	Y+21, r30	; 0x15
    5cd0:	ee a1       	lds	r30, 0x4e
    5cd2:	ee 8b       	std	Y+22, r30	; 0x16
    5cd4:	ef a1       	lds	r30, 0x4f
    5cd6:	ef 8b       	std	Y+23, r30	; 0x17
    5cd8:	e8 a5       	lds	r30, 0x68
    5cda:	e8 8f       	std	Y+24, r30	; 0x18
    5cdc:	79 87       	std	Y+9, r23	; 0x09
    5cde:	6a 87       	std	Y+10, r22	; 0x0a
    5ce0:	5b 87       	std	Y+11, r21	; 0x0b
    5ce2:	4c 87       	std	Y+12, r20	; 0x0c
    5ce4:	3d 87       	std	Y+13, r19	; 0x0d
    5ce6:	2e 87       	std	Y+14, r18	; 0x0e
    5ce8:	9f 87       	std	Y+15, r25	; 0x0f
    5cea:	88 8b       	std	Y+16, r24	; 0x10
    5cec:	89 84       	ldd	r8, Y+9	; 0x09
    5cee:	9a 84       	ldd	r9, Y+10	; 0x0a
    5cf0:	ab 84       	ldd	r10, Y+11	; 0x0b
    5cf2:	bc 84       	ldd	r11, Y+12	; 0x0c
    5cf4:	8d 85       	ldd	r24, Y+13	; 0x0d
    5cf6:	9e 85       	ldd	r25, Y+14	; 0x0e
    5cf8:	af 85       	ldd	r26, Y+15	; 0x0f
    5cfa:	b8 89       	ldd	r27, Y+16	; 0x10
    5cfc:	e9 88       	ldd	r14, Y+17	; 0x11
    5cfe:	fa 88       	ldd	r15, Y+18	; 0x12
    5d00:	0b 89       	ldd	r16, Y+19	; 0x13
    5d02:	1c 89       	ldd	r17, Y+20	; 0x14
    5d04:	ed aa       	sts	0x9d, r30
    5d06:	fe aa       	sts	0x9e, r31
    5d08:	0f ab       	sts	0x5f, r16
    5d0a:	18 af       	sts	0x78, r17
    5d0c:	cd 88       	ldd	r12, Y+21	; 0x15
    5d0e:	de 88       	ldd	r13, Y+22	; 0x16
    5d10:	ef 88       	ldd	r14, Y+23	; 0x17
    5d12:	f8 8c       	ldd	r15, Y+24	; 0x18
    5d14:	00 97       	sbiw	r24, 0x00	; 0
    5d16:	a1 05       	cpc	r26, r1
    5d18:	b1 05       	cpc	r27, r1
    5d1a:	09 f0       	breq	.+2      	; 0x5d1e <__divdi3+0x262>
    5d1c:	bd c3       	rjmp	.+1914   	; 0x6498 <__stack+0x499>
    5d1e:	c8 14       	cp	r12, r8
    5d20:	d9 04       	cpc	r13, r9
    5d22:	ea 04       	cpc	r14, r10
    5d24:	fb 04       	cpc	r15, r11
    5d26:	08 f0       	brcs	.+2      	; 0x5d2a <__divdi3+0x26e>
    5d28:	4d c1       	rjmp	.+666    	; 0x5fc4 <__divdi3+0x508>
    5d2a:	00 e0       	ldi	r16, 0x00	; 0
    5d2c:	80 16       	cp	r8, r16
    5d2e:	00 e0       	ldi	r16, 0x00	; 0
    5d30:	90 06       	cpc	r9, r16
    5d32:	01 e0       	ldi	r16, 0x01	; 1
    5d34:	a0 06       	cpc	r10, r16
    5d36:	00 e0       	ldi	r16, 0x00	; 0
    5d38:	b0 06       	cpc	r11, r16
    5d3a:	58 f4       	brcc	.+22     	; 0x5d52 <__divdi3+0x296>
    5d3c:	1f ef       	ldi	r17, 0xFF	; 255
    5d3e:	81 16       	cp	r8, r17
    5d40:	91 04       	cpc	r9, r1
    5d42:	a1 04       	cpc	r10, r1
    5d44:	b1 04       	cpc	r11, r1
    5d46:	09 f0       	breq	.+2      	; 0x5d4a <__divdi3+0x28e>
    5d48:	90 f4       	brcc	.+36     	; 0x5d6e <__divdi3+0x2b2>
    5d4a:	80 e0       	ldi	r24, 0x00	; 0
    5d4c:	90 e0       	ldi	r25, 0x00	; 0
    5d4e:	dc 01       	movw	r26, r24
    5d50:	17 c0       	rjmp	.+46     	; 0x5d80 <__divdi3+0x2c4>
    5d52:	20 e0       	ldi	r18, 0x00	; 0
    5d54:	82 16       	cp	r8, r18
    5d56:	20 e0       	ldi	r18, 0x00	; 0
    5d58:	92 06       	cpc	r9, r18
    5d5a:	20 e0       	ldi	r18, 0x00	; 0
    5d5c:	a2 06       	cpc	r10, r18
    5d5e:	21 e0       	ldi	r18, 0x01	; 1
    5d60:	b2 06       	cpc	r11, r18
    5d62:	50 f4       	brcc	.+20     	; 0x5d78 <__divdi3+0x2bc>
    5d64:	80 e1       	ldi	r24, 0x10	; 16
    5d66:	90 e0       	ldi	r25, 0x00	; 0
    5d68:	a0 e0       	ldi	r26, 0x00	; 0
    5d6a:	b0 e0       	ldi	r27, 0x00	; 0
    5d6c:	09 c0       	rjmp	.+18     	; 0x5d80 <__divdi3+0x2c4>
    5d6e:	88 e0       	ldi	r24, 0x08	; 8
    5d70:	90 e0       	ldi	r25, 0x00	; 0
    5d72:	a0 e0       	ldi	r26, 0x00	; 0
    5d74:	b0 e0       	ldi	r27, 0x00	; 0
    5d76:	04 c0       	rjmp	.+8      	; 0x5d80 <__divdi3+0x2c4>
    5d78:	88 e1       	ldi	r24, 0x18	; 24
    5d7a:	90 e0       	ldi	r25, 0x00	; 0
    5d7c:	a0 e0       	ldi	r26, 0x00	; 0
    5d7e:	b0 e0       	ldi	r27, 0x00	; 0
    5d80:	b5 01       	movw	r22, r10
    5d82:	a4 01       	movw	r20, r8
    5d84:	08 2e       	mov	r0, r24
    5d86:	04 c0       	rjmp	.+8      	; 0x5d90 <__divdi3+0x2d4>
    5d88:	76 95       	lsr	r23
    5d8a:	67 95       	ror	r22
    5d8c:	57 95       	ror	r21
    5d8e:	47 95       	ror	r20
    5d90:	0a 94       	dec	r0
    5d92:	d2 f7       	brpl	.-12     	; 0x5d88 <__divdi3+0x2cc>
    5d94:	fa 01       	movw	r30, r20
    5d96:	e4 5e       	subi	r30, 0xE4	; 228
    5d98:	ff 4d       	sbci	r31, 0xDF	; 223
    5d9a:	20 81       	ld	r18, Z
    5d9c:	40 e2       	ldi	r20, 0x20	; 32
    5d9e:	50 e0       	ldi	r21, 0x00	; 0
    5da0:	60 e0       	ldi	r22, 0x00	; 0
    5da2:	70 e0       	ldi	r23, 0x00	; 0
    5da4:	48 1b       	sub	r20, r24
    5da6:	59 0b       	sbc	r21, r25
    5da8:	6a 0b       	sbc	r22, r26
    5daa:	7b 0b       	sbc	r23, r27
    5dac:	42 1b       	sub	r20, r18
    5dae:	51 09       	sbc	r21, r1
    5db0:	61 09       	sbc	r22, r1
    5db2:	71 09       	sbc	r23, r1
    5db4:	41 15       	cp	r20, r1
    5db6:	51 05       	cpc	r21, r1
    5db8:	61 05       	cpc	r22, r1
    5dba:	71 05       	cpc	r23, r1
    5dbc:	a1 f1       	breq	.+104    	; 0x5e26 <__divdi3+0x36a>
    5dbe:	04 2e       	mov	r0, r20
    5dc0:	04 c0       	rjmp	.+8      	; 0x5dca <__divdi3+0x30e>
    5dc2:	88 0c       	add	r8, r8
    5dc4:	99 1c       	adc	r9, r9
    5dc6:	aa 1c       	adc	r10, r10
    5dc8:	bb 1c       	adc	r11, r11
    5dca:	0a 94       	dec	r0
    5dcc:	d2 f7       	brpl	.-12     	; 0x5dc2 <__divdi3+0x306>
    5dce:	97 01       	movw	r18, r14
    5dd0:	86 01       	movw	r16, r12
    5dd2:	04 2e       	mov	r0, r20
    5dd4:	04 c0       	rjmp	.+8      	; 0x5dde <__divdi3+0x322>
    5dd6:	00 0f       	add	r16, r16
    5dd8:	11 1f       	adc	r17, r17
    5dda:	22 1f       	adc	r18, r18
    5ddc:	33 1f       	adc	r19, r19
    5dde:	0a 94       	dec	r0
    5de0:	d2 f7       	brpl	.-12     	; 0x5dd6 <__divdi3+0x31a>
    5de2:	80 e2       	ldi	r24, 0x20	; 32
    5de4:	90 e0       	ldi	r25, 0x00	; 0
    5de6:	84 1b       	sub	r24, r20
    5de8:	95 0b       	sbc	r25, r21
    5dea:	cd a8       	sts	0x8d, r28
    5dec:	de a8       	sts	0x8e, r29
    5dee:	ef a8       	sts	0x8f, r30
    5df0:	f8 ac       	sts	0xa8, r31
    5df2:	04 c0       	rjmp	.+8      	; 0x5dfc <__divdi3+0x340>
    5df4:	f6 94       	lsr	r15
    5df6:	e7 94       	ror	r14
    5df8:	d7 94       	ror	r13
    5dfa:	c7 94       	ror	r12
    5dfc:	8a 95       	dec	r24
    5dfe:	d2 f7       	brpl	.-12     	; 0x5df4 <__divdi3+0x338>
    5e00:	c0 2a       	or	r12, r16
    5e02:	d1 2a       	or	r13, r17
    5e04:	e2 2a       	or	r14, r18
    5e06:	f3 2a       	or	r15, r19
    5e08:	0d a9       	sts	0x4d, r16
    5e0a:	1e a9       	sts	0x4e, r17
    5e0c:	2f a9       	sts	0x4f, r18
    5e0e:	38 ad       	sts	0x68, r19
    5e10:	04 c0       	rjmp	.+8      	; 0x5e1a <__divdi3+0x35e>
    5e12:	00 0f       	add	r16, r16
    5e14:	11 1f       	adc	r17, r17
    5e16:	22 1f       	adc	r18, r18
    5e18:	33 1f       	adc	r19, r19
    5e1a:	4a 95       	dec	r20
    5e1c:	d2 f7       	brpl	.-12     	; 0x5e12 <__divdi3+0x356>
    5e1e:	0d ab       	sts	0x5d, r16
    5e20:	1e ab       	sts	0x5e, r17
    5e22:	2f ab       	sts	0x5f, r18
    5e24:	38 af       	sts	0x78, r19
    5e26:	25 01       	movw	r4, r10
    5e28:	66 24       	eor	r6, r6
    5e2a:	77 24       	eor	r7, r7
    5e2c:	95 01       	movw	r18, r10
    5e2e:	84 01       	movw	r16, r8
    5e30:	20 70       	andi	r18, 0x00	; 0
    5e32:	30 70       	andi	r19, 0x00	; 0
    5e34:	09 ab       	sts	0x59, r16
    5e36:	1a ab       	sts	0x5a, r17
    5e38:	2b ab       	sts	0x5b, r18
    5e3a:	3c ab       	sts	0x5c, r19
    5e3c:	c7 01       	movw	r24, r14
    5e3e:	b6 01       	movw	r22, r12
    5e40:	a3 01       	movw	r20, r6
    5e42:	92 01       	movw	r18, r4
    5e44:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    5e48:	2d a7       	lds	r18, 0x7d
    5e4a:	3e a7       	lds	r19, 0x7e
    5e4c:	4f a7       	lds	r20, 0x7f
    5e4e:	58 ab       	sts	0x58, r21
    5e50:	69 a7       	lds	r22, 0x79
    5e52:	7a a7       	lds	r23, 0x7a
    5e54:	8b a7       	lds	r24, 0x7b
    5e56:	9c a7       	lds	r25, 0x7c
    5e58:	c7 01       	movw	r24, r14
    5e5a:	b6 01       	movw	r22, r12
    5e5c:	a3 01       	movw	r20, r6
    5e5e:	92 01       	movw	r18, r4
    5e60:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    5e64:	ca 01       	movw	r24, r20
    5e66:	b9 01       	movw	r22, r18
    5e68:	29 a9       	sts	0x49, r18
    5e6a:	3a a9       	sts	0x4a, r19
    5e6c:	4b a9       	sts	0x4b, r20
    5e6e:	5c a9       	sts	0x4c, r21
    5e70:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    5e74:	ab 01       	movw	r20, r22
    5e76:	bc 01       	movw	r22, r24
    5e78:	09 a5       	lds	r16, 0x69
    5e7a:	1a a5       	lds	r17, 0x6a
    5e7c:	2b a5       	lds	r18, 0x6b
    5e7e:	3c a5       	lds	r19, 0x6c
    5e80:	78 01       	movw	r14, r16
    5e82:	dd 24       	eor	r13, r13
    5e84:	cc 24       	eor	r12, r12
    5e86:	0d a9       	sts	0x4d, r16
    5e88:	1e a9       	sts	0x4e, r17
    5e8a:	2f a9       	sts	0x4f, r18
    5e8c:	38 ad       	sts	0x68, r19
    5e8e:	c9 01       	movw	r24, r18
    5e90:	aa 27       	eor	r26, r26
    5e92:	bb 27       	eor	r27, r27
    5e94:	c8 2a       	or	r12, r24
    5e96:	d9 2a       	or	r13, r25
    5e98:	ea 2a       	or	r14, r26
    5e9a:	fb 2a       	or	r15, r27
    5e9c:	0d a5       	lds	r16, 0x6d
    5e9e:	1e a5       	lds	r17, 0x6e
    5ea0:	2f a5       	lds	r18, 0x6f
    5ea2:	38 a9       	sts	0x48, r19
    5ea4:	c4 16       	cp	r12, r20
    5ea6:	d5 06       	cpc	r13, r21
    5ea8:	e6 06       	cpc	r14, r22
    5eaa:	f7 06       	cpc	r15, r23
    5eac:	38 f5       	brcc	.+78     	; 0x5efc <__divdi3+0x440>
    5eae:	01 50       	subi	r16, 0x01	; 1
    5eb0:	10 40       	sbci	r17, 0x00	; 0
    5eb2:	20 40       	sbci	r18, 0x00	; 0
    5eb4:	30 40       	sbci	r19, 0x00	; 0
    5eb6:	09 a7       	lds	r16, 0x79
    5eb8:	1a a7       	lds	r17, 0x7a
    5eba:	2b a7       	lds	r18, 0x7b
    5ebc:	3c a7       	lds	r19, 0x7c
    5ebe:	c8 0c       	add	r12, r8
    5ec0:	d9 1c       	adc	r13, r9
    5ec2:	ea 1c       	adc	r14, r10
    5ec4:	fb 1c       	adc	r15, r11
    5ec6:	c8 14       	cp	r12, r8
    5ec8:	d9 04       	cpc	r13, r9
    5eca:	ea 04       	cpc	r14, r10
    5ecc:	fb 04       	cpc	r15, r11
    5ece:	d0 f0       	brcs	.+52     	; 0x5f04 <__divdi3+0x448>
    5ed0:	c4 16       	cp	r12, r20
    5ed2:	d5 06       	cpc	r13, r21
    5ed4:	e6 06       	cpc	r14, r22
    5ed6:	f7 06       	cpc	r15, r23
    5ed8:	a8 f4       	brcc	.+42     	; 0x5f04 <__divdi3+0x448>
    5eda:	0d a5       	lds	r16, 0x6d
    5edc:	1e a5       	lds	r17, 0x6e
    5ede:	2f a5       	lds	r18, 0x6f
    5ee0:	38 a9       	sts	0x48, r19
    5ee2:	02 50       	subi	r16, 0x02	; 2
    5ee4:	10 40       	sbci	r17, 0x00	; 0
    5ee6:	20 40       	sbci	r18, 0x00	; 0
    5ee8:	30 40       	sbci	r19, 0x00	; 0
    5eea:	09 a7       	lds	r16, 0x79
    5eec:	1a a7       	lds	r17, 0x7a
    5eee:	2b a7       	lds	r18, 0x7b
    5ef0:	3c a7       	lds	r19, 0x7c
    5ef2:	c8 0c       	add	r12, r8
    5ef4:	d9 1c       	adc	r13, r9
    5ef6:	ea 1c       	adc	r14, r10
    5ef8:	fb 1c       	adc	r15, r11
    5efa:	04 c0       	rjmp	.+8      	; 0x5f04 <__divdi3+0x448>
    5efc:	09 a7       	lds	r16, 0x79
    5efe:	1a a7       	lds	r17, 0x7a
    5f00:	2b a7       	lds	r18, 0x7b
    5f02:	3c a7       	lds	r19, 0x7c
    5f04:	c4 1a       	sub	r12, r20
    5f06:	d5 0a       	sbc	r13, r21
    5f08:	e6 0a       	sbc	r14, r22
    5f0a:	f7 0a       	sbc	r15, r23
    5f0c:	c7 01       	movw	r24, r14
    5f0e:	b6 01       	movw	r22, r12
    5f10:	a3 01       	movw	r20, r6
    5f12:	92 01       	movw	r18, r4
    5f14:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    5f18:	2d a7       	lds	r18, 0x7d
    5f1a:	3e a7       	lds	r19, 0x7e
    5f1c:	4f a7       	lds	r20, 0x7f
    5f1e:	58 ab       	sts	0x58, r21
    5f20:	69 af       	sts	0x79, r22
    5f22:	7a af       	sts	0x7a, r23
    5f24:	8b af       	sts	0x7b, r24
    5f26:	9c af       	sts	0x7c, r25
    5f28:	c7 01       	movw	r24, r14
    5f2a:	b6 01       	movw	r22, r12
    5f2c:	a3 01       	movw	r20, r6
    5f2e:	92 01       	movw	r18, r4
    5f30:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    5f34:	ca 01       	movw	r24, r20
    5f36:	b9 01       	movw	r22, r18
    5f38:	29 a9       	sts	0x49, r18
    5f3a:	3a a9       	sts	0x4a, r19
    5f3c:	4b a9       	sts	0x4b, r20
    5f3e:	5c a9       	sts	0x4c, r21
    5f40:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    5f44:	6b 01       	movw	r12, r22
    5f46:	7c 01       	movw	r14, r24
    5f48:	49 ad       	sts	0x69, r20
    5f4a:	5a ad       	sts	0x6a, r21
    5f4c:	6b ad       	sts	0x6b, r22
    5f4e:	7c ad       	sts	0x6c, r23
    5f50:	9a 01       	movw	r18, r20
    5f52:	11 27       	eor	r17, r17
    5f54:	00 27       	eor	r16, r16
    5f56:	4d a9       	sts	0x4d, r20
    5f58:	5e a9       	sts	0x4e, r21
    5f5a:	6f a9       	sts	0x4f, r22
    5f5c:	78 ad       	sts	0x68, r23
    5f5e:	60 70       	andi	r22, 0x00	; 0
    5f60:	70 70       	andi	r23, 0x00	; 0
    5f62:	04 2b       	or	r16, r20
    5f64:	15 2b       	or	r17, r21
    5f66:	26 2b       	or	r18, r22
    5f68:	37 2b       	or	r19, r23
    5f6a:	8d a5       	lds	r24, 0x6d
    5f6c:	9e a5       	lds	r25, 0x6e
    5f6e:	af a5       	lds	r26, 0x6f
    5f70:	b8 a9       	sts	0x48, r27
    5f72:	0c 15       	cp	r16, r12
    5f74:	1d 05       	cpc	r17, r13
    5f76:	2e 05       	cpc	r18, r14
    5f78:	3f 05       	cpc	r19, r15
    5f7a:	c0 f4       	brcc	.+48     	; 0x5fac <__divdi3+0x4f0>
    5f7c:	01 97       	sbiw	r24, 0x01	; 1
    5f7e:	a1 09       	sbc	r26, r1
    5f80:	b1 09       	sbc	r27, r1
    5f82:	08 0d       	add	r16, r8
    5f84:	19 1d       	adc	r17, r9
    5f86:	2a 1d       	adc	r18, r10
    5f88:	3b 1d       	adc	r19, r11
    5f8a:	08 15       	cp	r16, r8
    5f8c:	19 05       	cpc	r17, r9
    5f8e:	2a 05       	cpc	r18, r10
    5f90:	3b 05       	cpc	r19, r11
    5f92:	60 f0       	brcs	.+24     	; 0x5fac <__divdi3+0x4f0>
    5f94:	0c 15       	cp	r16, r12
    5f96:	1d 05       	cpc	r17, r13
    5f98:	2e 05       	cpc	r18, r14
    5f9a:	3f 05       	cpc	r19, r15
    5f9c:	38 f4       	brcc	.+14     	; 0x5fac <__divdi3+0x4f0>
    5f9e:	8d a5       	lds	r24, 0x6d
    5fa0:	9e a5       	lds	r25, 0x6e
    5fa2:	af a5       	lds	r26, 0x6f
    5fa4:	b8 a9       	sts	0x48, r27
    5fa6:	02 97       	sbiw	r24, 0x02	; 2
    5fa8:	a1 09       	sbc	r26, r1
    5faa:	b1 09       	sbc	r27, r1
    5fac:	09 a5       	lds	r16, 0x69
    5fae:	1a a5       	lds	r17, 0x6a
    5fb0:	2b a5       	lds	r18, 0x6b
    5fb2:	3c a5       	lds	r19, 0x6c
    5fb4:	78 01       	movw	r14, r16
    5fb6:	dd 24       	eor	r13, r13
    5fb8:	cc 24       	eor	r12, r12
    5fba:	c8 2a       	or	r12, r24
    5fbc:	d9 2a       	or	r13, r25
    5fbe:	ea 2a       	or	r14, r26
    5fc0:	fb 2a       	or	r15, r27
    5fc2:	b7 c4       	rjmp	.+2414   	; 0x6932 <__stack+0x933>
    5fc4:	81 14       	cp	r8, r1
    5fc6:	91 04       	cpc	r9, r1
    5fc8:	a1 04       	cpc	r10, r1
    5fca:	b1 04       	cpc	r11, r1
    5fcc:	51 f4       	brne	.+20     	; 0x5fe2 <__divdi3+0x526>
    5fce:	61 e0       	ldi	r22, 0x01	; 1
    5fd0:	70 e0       	ldi	r23, 0x00	; 0
    5fd2:	80 e0       	ldi	r24, 0x00	; 0
    5fd4:	90 e0       	ldi	r25, 0x00	; 0
    5fd6:	a5 01       	movw	r20, r10
    5fd8:	94 01       	movw	r18, r8
    5fda:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    5fde:	49 01       	movw	r8, r18
    5fe0:	5a 01       	movw	r10, r20
    5fe2:	10 e0       	ldi	r17, 0x00	; 0
    5fe4:	81 16       	cp	r8, r17
    5fe6:	10 e0       	ldi	r17, 0x00	; 0
    5fe8:	91 06       	cpc	r9, r17
    5fea:	11 e0       	ldi	r17, 0x01	; 1
    5fec:	a1 06       	cpc	r10, r17
    5fee:	10 e0       	ldi	r17, 0x00	; 0
    5ff0:	b1 06       	cpc	r11, r17
    5ff2:	58 f4       	brcc	.+22     	; 0x600a <__stack+0xb>
    5ff4:	2f ef       	ldi	r18, 0xFF	; 255
    5ff6:	82 16       	cp	r8, r18
    5ff8:	91 04       	cpc	r9, r1
    5ffa:	a1 04       	cpc	r10, r1
    5ffc:	b1 04       	cpc	r11, r1
    5ffe:	09 f0       	breq	.+2      	; 0x6002 <__stack+0x3>
    6000:	90 f4       	brcc	.+36     	; 0x6026 <__stack+0x27>
    6002:	80 e0       	ldi	r24, 0x00	; 0
    6004:	90 e0       	ldi	r25, 0x00	; 0
    6006:	dc 01       	movw	r26, r24
    6008:	17 c0       	rjmp	.+46     	; 0x6038 <__stack+0x39>
    600a:	30 e0       	ldi	r19, 0x00	; 0
    600c:	83 16       	cp	r8, r19
    600e:	30 e0       	ldi	r19, 0x00	; 0
    6010:	93 06       	cpc	r9, r19
    6012:	30 e0       	ldi	r19, 0x00	; 0
    6014:	a3 06       	cpc	r10, r19
    6016:	31 e0       	ldi	r19, 0x01	; 1
    6018:	b3 06       	cpc	r11, r19
    601a:	50 f4       	brcc	.+20     	; 0x6030 <__stack+0x31>
    601c:	80 e1       	ldi	r24, 0x10	; 16
    601e:	90 e0       	ldi	r25, 0x00	; 0
    6020:	a0 e0       	ldi	r26, 0x00	; 0
    6022:	b0 e0       	ldi	r27, 0x00	; 0
    6024:	09 c0       	rjmp	.+18     	; 0x6038 <__stack+0x39>
    6026:	88 e0       	ldi	r24, 0x08	; 8
    6028:	90 e0       	ldi	r25, 0x00	; 0
    602a:	a0 e0       	ldi	r26, 0x00	; 0
    602c:	b0 e0       	ldi	r27, 0x00	; 0
    602e:	04 c0       	rjmp	.+8      	; 0x6038 <__stack+0x39>
    6030:	88 e1       	ldi	r24, 0x18	; 24
    6032:	90 e0       	ldi	r25, 0x00	; 0
    6034:	a0 e0       	ldi	r26, 0x00	; 0
    6036:	b0 e0       	ldi	r27, 0x00	; 0
    6038:	b5 01       	movw	r22, r10
    603a:	a4 01       	movw	r20, r8
    603c:	08 2e       	mov	r0, r24
    603e:	04 c0       	rjmp	.+8      	; 0x6048 <__stack+0x49>
    6040:	76 95       	lsr	r23
    6042:	67 95       	ror	r22
    6044:	57 95       	ror	r21
    6046:	47 95       	ror	r20
    6048:	0a 94       	dec	r0
    604a:	d2 f7       	brpl	.-12     	; 0x6040 <__stack+0x41>
    604c:	fa 01       	movw	r30, r20
    604e:	e4 5e       	subi	r30, 0xE4	; 228
    6050:	ff 4d       	sbci	r31, 0xDF	; 223
    6052:	20 81       	ld	r18, Z
    6054:	ac 01       	movw	r20, r24
    6056:	bd 01       	movw	r22, r26
    6058:	42 0f       	add	r20, r18
    605a:	51 1d       	adc	r21, r1
    605c:	61 1d       	adc	r22, r1
    605e:	71 1d       	adc	r23, r1
    6060:	80 e2       	ldi	r24, 0x20	; 32
    6062:	90 e0       	ldi	r25, 0x00	; 0
    6064:	a0 e0       	ldi	r26, 0x00	; 0
    6066:	b0 e0       	ldi	r27, 0x00	; 0
    6068:	84 1b       	sub	r24, r20
    606a:	95 0b       	sbc	r25, r21
    606c:	a6 0b       	sbc	r26, r22
    606e:	b7 0b       	sbc	r27, r23
    6070:	51 f4       	brne	.+20     	; 0x6086 <__stack+0x87>
    6072:	c8 18       	sub	r12, r8
    6074:	d9 08       	sbc	r13, r9
    6076:	ea 08       	sbc	r14, r10
    6078:	fb 08       	sbc	r15, r11
    607a:	f1 e0       	ldi	r31, 0x01	; 1
    607c:	4f 2e       	mov	r4, r31
    607e:	51 2c       	mov	r5, r1
    6080:	61 2c       	mov	r6, r1
    6082:	71 2c       	mov	r7, r1
    6084:	28 c1       	rjmp	.+592    	; 0x62d6 <__stack+0x2d7>
    6086:	08 2e       	mov	r0, r24
    6088:	04 c0       	rjmp	.+8      	; 0x6092 <__stack+0x93>
    608a:	88 0c       	add	r8, r8
    608c:	99 1c       	adc	r9, r9
    608e:	aa 1c       	adc	r10, r10
    6090:	bb 1c       	adc	r11, r11
    6092:	0a 94       	dec	r0
    6094:	d2 f7       	brpl	.-12     	; 0x608a <__stack+0x8b>
    6096:	97 01       	movw	r18, r14
    6098:	86 01       	movw	r16, r12
    609a:	04 2e       	mov	r0, r20
    609c:	04 c0       	rjmp	.+8      	; 0x60a6 <__stack+0xa7>
    609e:	36 95       	lsr	r19
    60a0:	27 95       	ror	r18
    60a2:	17 95       	ror	r17
    60a4:	07 95       	ror	r16
    60a6:	0a 94       	dec	r0
    60a8:	d2 f7       	brpl	.-12     	; 0x609e <__stack+0x9f>
    60aa:	09 ab       	sts	0x59, r16
    60ac:	1a ab       	sts	0x5a, r17
    60ae:	2b ab       	sts	0x5b, r18
    60b0:	3c ab       	sts	0x5c, r19
    60b2:	97 01       	movw	r18, r14
    60b4:	86 01       	movw	r16, r12
    60b6:	08 2e       	mov	r0, r24
    60b8:	04 c0       	rjmp	.+8      	; 0x60c2 <__stack+0xc3>
    60ba:	00 0f       	add	r16, r16
    60bc:	11 1f       	adc	r17, r17
    60be:	22 1f       	adc	r18, r18
    60c0:	33 1f       	adc	r19, r19
    60c2:	0a 94       	dec	r0
    60c4:	d2 f7       	brpl	.-12     	; 0x60ba <__stack+0xbb>
    60c6:	0d a7       	lds	r16, 0x7d
    60c8:	1e a7       	lds	r17, 0x7e
    60ca:	2f a7       	lds	r18, 0x7f
    60cc:	38 ab       	sts	0x58, r19
    60ce:	ed a8       	sts	0x8d, r30
    60d0:	fe a8       	sts	0x8e, r31
    60d2:	0f a9       	sts	0x4f, r16
    60d4:	18 ad       	sts	0x68, r17
    60d6:	04 c0       	rjmp	.+8      	; 0x60e0 <__stack+0xe1>
    60d8:	16 95       	lsr	r17
    60da:	07 95       	ror	r16
    60dc:	f7 94       	ror	r15
    60de:	e7 94       	ror	r14
    60e0:	4a 95       	dec	r20
    60e2:	d2 f7       	brpl	.-12     	; 0x60d8 <__stack+0xd9>
    60e4:	b8 01       	movw	r22, r16
    60e6:	a7 01       	movw	r20, r14
    60e8:	0d a5       	lds	r16, 0x6d
    60ea:	1e a5       	lds	r17, 0x6e
    60ec:	2f a5       	lds	r18, 0x6f
    60ee:	38 a9       	sts	0x48, r19
    60f0:	04 2b       	or	r16, r20
    60f2:	15 2b       	or	r17, r21
    60f4:	26 2b       	or	r18, r22
    60f6:	37 2b       	or	r19, r23
    60f8:	0d a7       	lds	r16, 0x7d
    60fa:	1e a7       	lds	r17, 0x7e
    60fc:	2f a7       	lds	r18, 0x7f
    60fe:	38 ab       	sts	0x58, r19
    6100:	ed a8       	sts	0x8d, r30
    6102:	fe a8       	sts	0x8e, r31
    6104:	0f a9       	sts	0x4f, r16
    6106:	18 ad       	sts	0x68, r17
    6108:	04 c0       	rjmp	.+8      	; 0x6112 <__stack+0x113>
    610a:	ee 0c       	add	r14, r14
    610c:	ff 1c       	adc	r15, r15
    610e:	00 1f       	adc	r16, r16
    6110:	11 1f       	adc	r17, r17
    6112:	8a 95       	dec	r24
    6114:	d2 f7       	brpl	.-12     	; 0x610a <__stack+0x10b>
    6116:	ed aa       	sts	0x9d, r30
    6118:	fe aa       	sts	0x9e, r31
    611a:	0f ab       	sts	0x5f, r16
    611c:	18 af       	sts	0x78, r17
    611e:	25 01       	movw	r4, r10
    6120:	66 24       	eor	r6, r6
    6122:	77 24       	eor	r7, r7
    6124:	95 01       	movw	r18, r10
    6126:	84 01       	movw	r16, r8
    6128:	20 70       	andi	r18, 0x00	; 0
    612a:	30 70       	andi	r19, 0x00	; 0
    612c:	09 af       	sts	0x79, r16
    612e:	1a af       	sts	0x7a, r17
    6130:	2b af       	sts	0x7b, r18
    6132:	3c af       	sts	0x7c, r19
    6134:	69 a9       	sts	0x49, r22
    6136:	7a a9       	sts	0x4a, r23
    6138:	8b a9       	sts	0x4b, r24
    613a:	9c a9       	sts	0x4c, r25
    613c:	a3 01       	movw	r20, r6
    613e:	92 01       	movw	r18, r4
    6140:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    6144:	29 a7       	lds	r18, 0x79
    6146:	3a a7       	lds	r19, 0x7a
    6148:	4b a7       	lds	r20, 0x7b
    614a:	5c a7       	lds	r21, 0x7c
    614c:	6b 01       	movw	r12, r22
    614e:	7c 01       	movw	r14, r24
    6150:	69 a9       	sts	0x49, r22
    6152:	7a a9       	sts	0x4a, r23
    6154:	8b a9       	sts	0x4b, r24
    6156:	9c a9       	sts	0x4c, r25
    6158:	a3 01       	movw	r20, r6
    615a:	92 01       	movw	r18, r4
    615c:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    6160:	ca 01       	movw	r24, r20
    6162:	b9 01       	movw	r22, r18
    6164:	29 ad       	sts	0x69, r18
    6166:	3a ad       	sts	0x6a, r19
    6168:	4b ad       	sts	0x6b, r20
    616a:	5c ad       	sts	0x6c, r21
    616c:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    6170:	ab 01       	movw	r20, r22
    6172:	bc 01       	movw	r22, r24
    6174:	76 01       	movw	r14, r12
    6176:	dd 24       	eor	r13, r13
    6178:	cc 24       	eor	r12, r12
    617a:	0d a5       	lds	r16, 0x6d
    617c:	1e a5       	lds	r17, 0x6e
    617e:	2f a5       	lds	r18, 0x6f
    6180:	38 a9       	sts	0x48, r19
    6182:	c9 01       	movw	r24, r18
    6184:	aa 27       	eor	r26, r26
    6186:	bb 27       	eor	r27, r27
    6188:	c8 2a       	or	r12, r24
    618a:	d9 2a       	or	r13, r25
    618c:	ea 2a       	or	r14, r26
    618e:	fb 2a       	or	r15, r27
    6190:	09 a5       	lds	r16, 0x69
    6192:	1a a5       	lds	r17, 0x6a
    6194:	2b a5       	lds	r18, 0x6b
    6196:	3c a5       	lds	r19, 0x6c
    6198:	c4 16       	cp	r12, r20
    619a:	d5 06       	cpc	r13, r21
    619c:	e6 06       	cpc	r14, r22
    619e:	f7 06       	cpc	r15, r23
    61a0:	38 f5       	brcc	.+78     	; 0x61f0 <__stack+0x1f1>
    61a2:	01 50       	subi	r16, 0x01	; 1
    61a4:	10 40       	sbci	r17, 0x00	; 0
    61a6:	20 40       	sbci	r18, 0x00	; 0
    61a8:	30 40       	sbci	r19, 0x00	; 0
    61aa:	09 ab       	sts	0x59, r16
    61ac:	1a ab       	sts	0x5a, r17
    61ae:	2b ab       	sts	0x5b, r18
    61b0:	3c ab       	sts	0x5c, r19
    61b2:	c8 0c       	add	r12, r8
    61b4:	d9 1c       	adc	r13, r9
    61b6:	ea 1c       	adc	r14, r10
    61b8:	fb 1c       	adc	r15, r11
    61ba:	c8 14       	cp	r12, r8
    61bc:	d9 04       	cpc	r13, r9
    61be:	ea 04       	cpc	r14, r10
    61c0:	fb 04       	cpc	r15, r11
    61c2:	d0 f0       	brcs	.+52     	; 0x61f8 <__stack+0x1f9>
    61c4:	c4 16       	cp	r12, r20
    61c6:	d5 06       	cpc	r13, r21
    61c8:	e6 06       	cpc	r14, r22
    61ca:	f7 06       	cpc	r15, r23
    61cc:	a8 f4       	brcc	.+42     	; 0x61f8 <__stack+0x1f9>
    61ce:	09 a5       	lds	r16, 0x69
    61d0:	1a a5       	lds	r17, 0x6a
    61d2:	2b a5       	lds	r18, 0x6b
    61d4:	3c a5       	lds	r19, 0x6c
    61d6:	02 50       	subi	r16, 0x02	; 2
    61d8:	10 40       	sbci	r17, 0x00	; 0
    61da:	20 40       	sbci	r18, 0x00	; 0
    61dc:	30 40       	sbci	r19, 0x00	; 0
    61de:	09 ab       	sts	0x59, r16
    61e0:	1a ab       	sts	0x5a, r17
    61e2:	2b ab       	sts	0x5b, r18
    61e4:	3c ab       	sts	0x5c, r19
    61e6:	c8 0c       	add	r12, r8
    61e8:	d9 1c       	adc	r13, r9
    61ea:	ea 1c       	adc	r14, r10
    61ec:	fb 1c       	adc	r15, r11
    61ee:	04 c0       	rjmp	.+8      	; 0x61f8 <__stack+0x1f9>
    61f0:	09 ab       	sts	0x59, r16
    61f2:	1a ab       	sts	0x5a, r17
    61f4:	2b ab       	sts	0x5b, r18
    61f6:	3c ab       	sts	0x5c, r19
    61f8:	c4 1a       	sub	r12, r20
    61fa:	d5 0a       	sbc	r13, r21
    61fc:	e6 0a       	sbc	r14, r22
    61fe:	f7 0a       	sbc	r15, r23
    6200:	c7 01       	movw	r24, r14
    6202:	b6 01       	movw	r22, r12
    6204:	a3 01       	movw	r20, r6
    6206:	92 01       	movw	r18, r4
    6208:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    620c:	29 a7       	lds	r18, 0x79
    620e:	3a a7       	lds	r19, 0x7a
    6210:	4b a7       	lds	r20, 0x7b
    6212:	5c a7       	lds	r21, 0x7c
    6214:	21 96       	adiw	r28, 0x01	; 1
    6216:	6c af       	sts	0x7c, r22
    6218:	7d af       	sts	0x7d, r23
    621a:	8e af       	sts	0x7e, r24
    621c:	9f af       	sts	0x7f, r25
    621e:	21 97       	sbiw	r28, 0x01	; 1
    6220:	c7 01       	movw	r24, r14
    6222:	b6 01       	movw	r22, r12
    6224:	a3 01       	movw	r20, r6
    6226:	92 01       	movw	r18, r4
    6228:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    622c:	ca 01       	movw	r24, r20
    622e:	b9 01       	movw	r22, r18
    6230:	29 ad       	sts	0x69, r18
    6232:	3a ad       	sts	0x6a, r19
    6234:	4b ad       	sts	0x6b, r20
    6236:	5c ad       	sts	0x6c, r21
    6238:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    623c:	8b 01       	movw	r16, r22
    623e:	9c 01       	movw	r18, r24
    6240:	21 96       	adiw	r28, 0x01	; 1
    6242:	4c ad       	sts	0x6c, r20
    6244:	5d ad       	sts	0x6d, r21
    6246:	6e ad       	sts	0x6e, r22
    6248:	7f ad       	sts	0x6f, r23
    624a:	21 97       	sbiw	r28, 0x01	; 1
    624c:	da 01       	movw	r26, r20
    624e:	99 27       	eor	r25, r25
    6250:	88 27       	eor	r24, r24
    6252:	4d a5       	lds	r20, 0x6d
    6254:	5e a5       	lds	r21, 0x6e
    6256:	6f a5       	lds	r22, 0x6f
    6258:	78 a9       	sts	0x48, r23
    625a:	60 70       	andi	r22, 0x00	; 0
    625c:	70 70       	andi	r23, 0x00	; 0
    625e:	84 2b       	or	r24, r20
    6260:	95 2b       	or	r25, r21
    6262:	a6 2b       	or	r26, r22
    6264:	b7 2b       	or	r27, r23
    6266:	49 a5       	lds	r20, 0x69
    6268:	5a a5       	lds	r21, 0x6a
    626a:	6b a5       	lds	r22, 0x6b
    626c:	7c a5       	lds	r23, 0x6c
    626e:	80 17       	cp	r24, r16
    6270:	91 07       	cpc	r25, r17
    6272:	a2 07       	cpc	r26, r18
    6274:	b3 07       	cpc	r27, r19
    6276:	f0 f4       	brcc	.+60     	; 0x62b4 <__stack+0x2b5>
    6278:	41 50       	subi	r20, 0x01	; 1
    627a:	50 40       	sbci	r21, 0x00	; 0
    627c:	60 40       	sbci	r22, 0x00	; 0
    627e:	70 40       	sbci	r23, 0x00	; 0
    6280:	88 0d       	add	r24, r8
    6282:	99 1d       	adc	r25, r9
    6284:	aa 1d       	adc	r26, r10
    6286:	bb 1d       	adc	r27, r11
    6288:	88 15       	cp	r24, r8
    628a:	99 05       	cpc	r25, r9
    628c:	aa 05       	cpc	r26, r10
    628e:	bb 05       	cpc	r27, r11
    6290:	88 f0       	brcs	.+34     	; 0x62b4 <__stack+0x2b5>
    6292:	80 17       	cp	r24, r16
    6294:	91 07       	cpc	r25, r17
    6296:	a2 07       	cpc	r26, r18
    6298:	b3 07       	cpc	r27, r19
    629a:	60 f4       	brcc	.+24     	; 0x62b4 <__stack+0x2b5>
    629c:	49 a5       	lds	r20, 0x69
    629e:	5a a5       	lds	r21, 0x6a
    62a0:	6b a5       	lds	r22, 0x6b
    62a2:	7c a5       	lds	r23, 0x6c
    62a4:	42 50       	subi	r20, 0x02	; 2
    62a6:	50 40       	sbci	r21, 0x00	; 0
    62a8:	60 40       	sbci	r22, 0x00	; 0
    62aa:	70 40       	sbci	r23, 0x00	; 0
    62ac:	88 0d       	add	r24, r8
    62ae:	99 1d       	adc	r25, r9
    62b0:	aa 1d       	adc	r26, r10
    62b2:	bb 1d       	adc	r27, r11
    62b4:	6c 01       	movw	r12, r24
    62b6:	7d 01       	movw	r14, r26
    62b8:	c0 1a       	sub	r12, r16
    62ba:	d1 0a       	sbc	r13, r17
    62bc:	e2 0a       	sbc	r14, r18
    62be:	f3 0a       	sbc	r15, r19
    62c0:	09 a9       	sts	0x49, r16
    62c2:	1a a9       	sts	0x4a, r17
    62c4:	2b a9       	sts	0x4b, r18
    62c6:	3c a9       	sts	0x4c, r19
    62c8:	38 01       	movw	r6, r16
    62ca:	55 24       	eor	r5, r5
    62cc:	44 24       	eor	r4, r4
    62ce:	44 2a       	or	r4, r20
    62d0:	55 2a       	or	r5, r21
    62d2:	66 2a       	or	r6, r22
    62d4:	77 2a       	or	r7, r23
    62d6:	85 01       	movw	r16, r10
    62d8:	22 27       	eor	r18, r18
    62da:	33 27       	eor	r19, r19
    62dc:	0d a7       	lds	r16, 0x7d
    62de:	1e a7       	lds	r17, 0x7e
    62e0:	2f a7       	lds	r18, 0x7f
    62e2:	38 ab       	sts	0x58, r19
    62e4:	95 01       	movw	r18, r10
    62e6:	84 01       	movw	r16, r8
    62e8:	20 70       	andi	r18, 0x00	; 0
    62ea:	30 70       	andi	r19, 0x00	; 0
    62ec:	09 af       	sts	0x79, r16
    62ee:	1a af       	sts	0x7a, r17
    62f0:	2b af       	sts	0x7b, r18
    62f2:	3c af       	sts	0x7c, r19
    62f4:	c7 01       	movw	r24, r14
    62f6:	b6 01       	movw	r22, r12
    62f8:	2d a5       	lds	r18, 0x6d
    62fa:	3e a5       	lds	r19, 0x6e
    62fc:	4f a5       	lds	r20, 0x6f
    62fe:	58 a9       	sts	0x48, r21
    6300:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    6304:	29 a7       	lds	r18, 0x79
    6306:	3a a7       	lds	r19, 0x7a
    6308:	4b a7       	lds	r20, 0x7b
    630a:	5c a7       	lds	r21, 0x7c
    630c:	69 ab       	sts	0x59, r22
    630e:	7a ab       	sts	0x5a, r23
    6310:	8b ab       	sts	0x5b, r24
    6312:	9c ab       	sts	0x5c, r25
    6314:	c7 01       	movw	r24, r14
    6316:	b6 01       	movw	r22, r12
    6318:	2d a5       	lds	r18, 0x6d
    631a:	3e a5       	lds	r19, 0x6e
    631c:	4f a5       	lds	r20, 0x6f
    631e:	58 a9       	sts	0x48, r21
    6320:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    6324:	ca 01       	movw	r24, r20
    6326:	b9 01       	movw	r22, r18
    6328:	29 ad       	sts	0x69, r18
    632a:	3a ad       	sts	0x6a, r19
    632c:	4b ad       	sts	0x6b, r20
    632e:	5c ad       	sts	0x6c, r21
    6330:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    6334:	ab 01       	movw	r20, r22
    6336:	bc 01       	movw	r22, r24
    6338:	09 a9       	sts	0x49, r16
    633a:	1a a9       	sts	0x4a, r17
    633c:	2b a9       	sts	0x4b, r18
    633e:	3c a9       	sts	0x4c, r19
    6340:	78 01       	movw	r14, r16
    6342:	dd 24       	eor	r13, r13
    6344:	cc 24       	eor	r12, r12
    6346:	0d a9       	sts	0x4d, r16
    6348:	1e a9       	sts	0x4e, r17
    634a:	2f a9       	sts	0x4f, r18
    634c:	38 ad       	sts	0x68, r19
    634e:	c9 01       	movw	r24, r18
    6350:	aa 27       	eor	r26, r26
    6352:	bb 27       	eor	r27, r27
    6354:	c8 2a       	or	r12, r24
    6356:	d9 2a       	or	r13, r25
    6358:	ea 2a       	or	r14, r26
    635a:	fb 2a       	or	r15, r27
    635c:	09 a5       	lds	r16, 0x69
    635e:	1a a5       	lds	r17, 0x6a
    6360:	2b a5       	lds	r18, 0x6b
    6362:	3c a5       	lds	r19, 0x6c
    6364:	c4 16       	cp	r12, r20
    6366:	d5 06       	cpc	r13, r21
    6368:	e6 06       	cpc	r14, r22
    636a:	f7 06       	cpc	r15, r23
    636c:	38 f5       	brcc	.+78     	; 0x63bc <__stack+0x3bd>
    636e:	01 50       	subi	r16, 0x01	; 1
    6370:	10 40       	sbci	r17, 0x00	; 0
    6372:	20 40       	sbci	r18, 0x00	; 0
    6374:	30 40       	sbci	r19, 0x00	; 0
    6376:	09 ab       	sts	0x59, r16
    6378:	1a ab       	sts	0x5a, r17
    637a:	2b ab       	sts	0x5b, r18
    637c:	3c ab       	sts	0x5c, r19
    637e:	c8 0c       	add	r12, r8
    6380:	d9 1c       	adc	r13, r9
    6382:	ea 1c       	adc	r14, r10
    6384:	fb 1c       	adc	r15, r11
    6386:	c8 14       	cp	r12, r8
    6388:	d9 04       	cpc	r13, r9
    638a:	ea 04       	cpc	r14, r10
    638c:	fb 04       	cpc	r15, r11
    638e:	d0 f0       	brcs	.+52     	; 0x63c4 <__stack+0x3c5>
    6390:	c4 16       	cp	r12, r20
    6392:	d5 06       	cpc	r13, r21
    6394:	e6 06       	cpc	r14, r22
    6396:	f7 06       	cpc	r15, r23
    6398:	a8 f4       	brcc	.+42     	; 0x63c4 <__stack+0x3c5>
    639a:	09 a5       	lds	r16, 0x69
    639c:	1a a5       	lds	r17, 0x6a
    639e:	2b a5       	lds	r18, 0x6b
    63a0:	3c a5       	lds	r19, 0x6c
    63a2:	02 50       	subi	r16, 0x02	; 2
    63a4:	10 40       	sbci	r17, 0x00	; 0
    63a6:	20 40       	sbci	r18, 0x00	; 0
    63a8:	30 40       	sbci	r19, 0x00	; 0
    63aa:	09 ab       	sts	0x59, r16
    63ac:	1a ab       	sts	0x5a, r17
    63ae:	2b ab       	sts	0x5b, r18
    63b0:	3c ab       	sts	0x5c, r19
    63b2:	c8 0c       	add	r12, r8
    63b4:	d9 1c       	adc	r13, r9
    63b6:	ea 1c       	adc	r14, r10
    63b8:	fb 1c       	adc	r15, r11
    63ba:	04 c0       	rjmp	.+8      	; 0x63c4 <__stack+0x3c5>
    63bc:	09 ab       	sts	0x59, r16
    63be:	1a ab       	sts	0x5a, r17
    63c0:	2b ab       	sts	0x5b, r18
    63c2:	3c ab       	sts	0x5c, r19
    63c4:	c4 1a       	sub	r12, r20
    63c6:	d5 0a       	sbc	r13, r21
    63c8:	e6 0a       	sbc	r14, r22
    63ca:	f7 0a       	sbc	r15, r23
    63cc:	c7 01       	movw	r24, r14
    63ce:	b6 01       	movw	r22, r12
    63d0:	2d a5       	lds	r18, 0x6d
    63d2:	3e a5       	lds	r19, 0x6e
    63d4:	4f a5       	lds	r20, 0x6f
    63d6:	58 a9       	sts	0x48, r21
    63d8:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    63dc:	29 a7       	lds	r18, 0x79
    63de:	3a a7       	lds	r19, 0x7a
    63e0:	4b a7       	lds	r20, 0x7b
    63e2:	5c a7       	lds	r21, 0x7c
    63e4:	21 96       	adiw	r28, 0x01	; 1
    63e6:	6c af       	sts	0x7c, r22
    63e8:	7d af       	sts	0x7d, r23
    63ea:	8e af       	sts	0x7e, r24
    63ec:	9f af       	sts	0x7f, r25
    63ee:	21 97       	sbiw	r28, 0x01	; 1
    63f0:	c7 01       	movw	r24, r14
    63f2:	b6 01       	movw	r22, r12
    63f4:	2d a5       	lds	r18, 0x6d
    63f6:	3e a5       	lds	r19, 0x6e
    63f8:	4f a5       	lds	r20, 0x6f
    63fa:	58 a9       	sts	0x48, r21
    63fc:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    6400:	ca 01       	movw	r24, r20
    6402:	b9 01       	movw	r22, r18
    6404:	29 ad       	sts	0x69, r18
    6406:	3a ad       	sts	0x6a, r19
    6408:	4b ad       	sts	0x6b, r20
    640a:	5c ad       	sts	0x6c, r21
    640c:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    6410:	8b 01       	movw	r16, r22
    6412:	9c 01       	movw	r18, r24
    6414:	21 96       	adiw	r28, 0x01	; 1
    6416:	4c ad       	sts	0x6c, r20
    6418:	5d ad       	sts	0x6d, r21
    641a:	6e ad       	sts	0x6e, r22
    641c:	7f ad       	sts	0x6f, r23
    641e:	21 97       	sbiw	r28, 0x01	; 1
    6420:	da 01       	movw	r26, r20
    6422:	99 27       	eor	r25, r25
    6424:	88 27       	eor	r24, r24
    6426:	4d a9       	sts	0x4d, r20
    6428:	5e a9       	sts	0x4e, r21
    642a:	6f a9       	sts	0x4f, r22
    642c:	78 ad       	sts	0x68, r23
    642e:	60 70       	andi	r22, 0x00	; 0
    6430:	70 70       	andi	r23, 0x00	; 0
    6432:	84 2b       	or	r24, r20
    6434:	95 2b       	or	r25, r21
    6436:	a6 2b       	or	r26, r22
    6438:	b7 2b       	or	r27, r23
    643a:	49 a5       	lds	r20, 0x69
    643c:	5a a5       	lds	r21, 0x6a
    643e:	6b a5       	lds	r22, 0x6b
    6440:	7c a5       	lds	r23, 0x6c
    6442:	80 17       	cp	r24, r16
    6444:	91 07       	cpc	r25, r17
    6446:	a2 07       	cpc	r26, r18
    6448:	b3 07       	cpc	r27, r19
    644a:	d0 f4       	brcc	.+52     	; 0x6480 <__stack+0x481>
    644c:	41 50       	subi	r20, 0x01	; 1
    644e:	50 40       	sbci	r21, 0x00	; 0
    6450:	60 40       	sbci	r22, 0x00	; 0
    6452:	70 40       	sbci	r23, 0x00	; 0
    6454:	88 0d       	add	r24, r8
    6456:	99 1d       	adc	r25, r9
    6458:	aa 1d       	adc	r26, r10
    645a:	bb 1d       	adc	r27, r11
    645c:	88 15       	cp	r24, r8
    645e:	99 05       	cpc	r25, r9
    6460:	aa 05       	cpc	r26, r10
    6462:	bb 05       	cpc	r27, r11
    6464:	68 f0       	brcs	.+26     	; 0x6480 <__stack+0x481>
    6466:	80 17       	cp	r24, r16
    6468:	91 07       	cpc	r25, r17
    646a:	a2 07       	cpc	r26, r18
    646c:	b3 07       	cpc	r27, r19
    646e:	40 f4       	brcc	.+16     	; 0x6480 <__stack+0x481>
    6470:	49 a5       	lds	r20, 0x69
    6472:	5a a5       	lds	r21, 0x6a
    6474:	6b a5       	lds	r22, 0x6b
    6476:	7c a5       	lds	r23, 0x6c
    6478:	42 50       	subi	r20, 0x02	; 2
    647a:	50 40       	sbci	r21, 0x00	; 0
    647c:	60 40       	sbci	r22, 0x00	; 0
    647e:	70 40       	sbci	r23, 0x00	; 0
    6480:	09 a9       	sts	0x49, r16
    6482:	1a a9       	sts	0x4a, r17
    6484:	2b a9       	sts	0x4b, r18
    6486:	3c a9       	sts	0x4c, r19
    6488:	78 01       	movw	r14, r16
    648a:	dd 24       	eor	r13, r13
    648c:	cc 24       	eor	r12, r12
    648e:	c4 2a       	or	r12, r20
    6490:	d5 2a       	or	r13, r21
    6492:	e6 2a       	or	r14, r22
    6494:	f7 2a       	or	r15, r23
    6496:	50 c2       	rjmp	.+1184   	; 0x6938 <__stack+0x939>
    6498:	c8 16       	cp	r12, r24
    649a:	d9 06       	cpc	r13, r25
    649c:	ea 06       	cpc	r14, r26
    649e:	fb 06       	cpc	r15, r27
    64a0:	08 f4       	brcc	.+2      	; 0x64a4 <__stack+0x4a5>
    64a2:	37 c2       	rjmp	.+1134   	; 0x6912 <__stack+0x913>
    64a4:	80 30       	cpi	r24, 0x00	; 0
    64a6:	10 e0       	ldi	r17, 0x00	; 0
    64a8:	91 07       	cpc	r25, r17
    64aa:	11 e0       	ldi	r17, 0x01	; 1
    64ac:	a1 07       	cpc	r26, r17
    64ae:	10 e0       	ldi	r17, 0x00	; 0
    64b0:	b1 07       	cpc	r27, r17
    64b2:	50 f4       	brcc	.+20     	; 0x64c8 <__stack+0x4c9>
    64b4:	8f 3f       	cpi	r24, 0xFF	; 255
    64b6:	91 05       	cpc	r25, r1
    64b8:	a1 05       	cpc	r26, r1
    64ba:	b1 05       	cpc	r27, r1
    64bc:	09 f0       	breq	.+2      	; 0x64c0 <__stack+0x4c1>
    64be:	88 f4       	brcc	.+34     	; 0x64e2 <__stack+0x4e3>
    64c0:	00 e0       	ldi	r16, 0x00	; 0
    64c2:	10 e0       	ldi	r17, 0x00	; 0
    64c4:	98 01       	movw	r18, r16
    64c6:	16 c0       	rjmp	.+44     	; 0x64f4 <__stack+0x4f5>
    64c8:	80 30       	cpi	r24, 0x00	; 0
    64ca:	20 e0       	ldi	r18, 0x00	; 0
    64cc:	92 07       	cpc	r25, r18
    64ce:	20 e0       	ldi	r18, 0x00	; 0
    64d0:	a2 07       	cpc	r26, r18
    64d2:	21 e0       	ldi	r18, 0x01	; 1
    64d4:	b2 07       	cpc	r27, r18
    64d6:	50 f4       	brcc	.+20     	; 0x64ec <__stack+0x4ed>
    64d8:	00 e1       	ldi	r16, 0x10	; 16
    64da:	10 e0       	ldi	r17, 0x00	; 0
    64dc:	20 e0       	ldi	r18, 0x00	; 0
    64de:	30 e0       	ldi	r19, 0x00	; 0
    64e0:	09 c0       	rjmp	.+18     	; 0x64f4 <__stack+0x4f5>
    64e2:	08 e0       	ldi	r16, 0x08	; 8
    64e4:	10 e0       	ldi	r17, 0x00	; 0
    64e6:	20 e0       	ldi	r18, 0x00	; 0
    64e8:	30 e0       	ldi	r19, 0x00	; 0
    64ea:	04 c0       	rjmp	.+8      	; 0x64f4 <__stack+0x4f5>
    64ec:	08 e1       	ldi	r16, 0x18	; 24
    64ee:	10 e0       	ldi	r17, 0x00	; 0
    64f0:	20 e0       	ldi	r18, 0x00	; 0
    64f2:	30 e0       	ldi	r19, 0x00	; 0
    64f4:	ac 01       	movw	r20, r24
    64f6:	bd 01       	movw	r22, r26
    64f8:	00 2e       	mov	r0, r16
    64fa:	04 c0       	rjmp	.+8      	; 0x6504 <__stack+0x505>
    64fc:	76 95       	lsr	r23
    64fe:	67 95       	ror	r22
    6500:	57 95       	ror	r21
    6502:	47 95       	ror	r20
    6504:	0a 94       	dec	r0
    6506:	d2 f7       	brpl	.-12     	; 0x64fc <__stack+0x4fd>
    6508:	fa 01       	movw	r30, r20
    650a:	e4 5e       	subi	r30, 0xE4	; 228
    650c:	ff 4d       	sbci	r31, 0xDF	; 223
    650e:	40 81       	ld	r20, Z
    6510:	04 0f       	add	r16, r20
    6512:	11 1d       	adc	r17, r1
    6514:	21 1d       	adc	r18, r1
    6516:	31 1d       	adc	r19, r1
    6518:	40 e2       	ldi	r20, 0x20	; 32
    651a:	50 e0       	ldi	r21, 0x00	; 0
    651c:	60 e0       	ldi	r22, 0x00	; 0
    651e:	70 e0       	ldi	r23, 0x00	; 0
    6520:	40 1b       	sub	r20, r16
    6522:	51 0b       	sbc	r21, r17
    6524:	62 0b       	sbc	r22, r18
    6526:	73 0b       	sbc	r23, r19
    6528:	a1 f4       	brne	.+40     	; 0x6552 <__stack+0x553>
    652a:	8c 15       	cp	r24, r12
    652c:	9d 05       	cpc	r25, r13
    652e:	ae 05       	cpc	r26, r14
    6530:	bf 05       	cpc	r27, r15
    6532:	08 f4       	brcc	.+2      	; 0x6536 <__stack+0x537>
    6534:	f5 c1       	rjmp	.+1002   	; 0x6920 <__stack+0x921>
    6536:	ed a8       	sts	0x8d, r30
    6538:	fe a8       	sts	0x8e, r31
    653a:	0f a9       	sts	0x4f, r16
    653c:	18 ad       	sts	0x68, r17
    653e:	44 24       	eor	r4, r4
    6540:	55 24       	eor	r5, r5
    6542:	32 01       	movw	r6, r4
    6544:	e8 14       	cp	r14, r8
    6546:	f9 04       	cpc	r15, r9
    6548:	0a 05       	cpc	r16, r10
    654a:	1b 05       	cpc	r17, r11
    654c:	08 f0       	brcs	.+2      	; 0x6550 <__stack+0x551>
    654e:	eb c1       	rjmp	.+982    	; 0x6926 <__stack+0x927>
    6550:	e3 c1       	rjmp	.+966    	; 0x6918 <__stack+0x919>
    6552:	34 2e       	mov	r3, r20
    6554:	2c 01       	movw	r4, r24
    6556:	3d 01       	movw	r6, r26
    6558:	04 c0       	rjmp	.+8      	; 0x6562 <__stack+0x563>
    655a:	44 0c       	add	r4, r4
    655c:	55 1c       	adc	r5, r5
    655e:	66 1c       	adc	r6, r6
    6560:	77 1c       	adc	r7, r7
    6562:	4a 95       	dec	r20
    6564:	d2 f7       	brpl	.-12     	; 0x655a <__stack+0x55b>
    6566:	d5 01       	movw	r26, r10
    6568:	c4 01       	movw	r24, r8
    656a:	00 2e       	mov	r0, r16
    656c:	04 c0       	rjmp	.+8      	; 0x6576 <__stack+0x577>
    656e:	b6 95       	lsr	r27
    6570:	a7 95       	ror	r26
    6572:	97 95       	ror	r25
    6574:	87 95       	ror	r24
    6576:	0a 94       	dec	r0
    6578:	d2 f7       	brpl	.-12     	; 0x656e <__stack+0x56f>
    657a:	48 2a       	or	r4, r24
    657c:	59 2a       	or	r5, r25
    657e:	6a 2a       	or	r6, r26
    6580:	7b 2a       	or	r7, r27
    6582:	a5 01       	movw	r20, r10
    6584:	94 01       	movw	r18, r8
    6586:	03 2c       	mov	r0, r3
    6588:	04 c0       	rjmp	.+8      	; 0x6592 <__stack+0x593>
    658a:	22 0f       	add	r18, r18
    658c:	33 1f       	adc	r19, r19
    658e:	44 1f       	adc	r20, r20
    6590:	55 1f       	adc	r21, r21
    6592:	0a 94       	dec	r0
    6594:	d2 f7       	brpl	.-12     	; 0x658a <__stack+0x58b>
    6596:	29 af       	sts	0x79, r18
    6598:	3a af       	sts	0x7a, r19
    659a:	4b af       	sts	0x7b, r20
    659c:	5c af       	sts	0x7c, r21
    659e:	b7 01       	movw	r22, r14
    65a0:	a6 01       	movw	r20, r12
    65a2:	00 2e       	mov	r0, r16
    65a4:	04 c0       	rjmp	.+8      	; 0x65ae <__stack+0x5af>
    65a6:	76 95       	lsr	r23
    65a8:	67 95       	ror	r22
    65aa:	57 95       	ror	r21
    65ac:	47 95       	ror	r20
    65ae:	0a 94       	dec	r0
    65b0:	d2 f7       	brpl	.-12     	; 0x65a6 <__stack+0x5a7>
    65b2:	49 ab       	sts	0x59, r20
    65b4:	5a ab       	sts	0x5a, r21
    65b6:	6b ab       	sts	0x5b, r22
    65b8:	7c ab       	sts	0x5c, r23
    65ba:	c7 01       	movw	r24, r14
    65bc:	b6 01       	movw	r22, r12
    65be:	03 2c       	mov	r0, r3
    65c0:	04 c0       	rjmp	.+8      	; 0x65ca <__stack+0x5cb>
    65c2:	66 0f       	add	r22, r22
    65c4:	77 1f       	adc	r23, r23
    65c6:	88 1f       	adc	r24, r24
    65c8:	99 1f       	adc	r25, r25
    65ca:	0a 94       	dec	r0
    65cc:	d2 f7       	brpl	.-12     	; 0x65c2 <__stack+0x5c3>
    65ce:	6d a7       	lds	r22, 0x7d
    65d0:	7e a7       	lds	r23, 0x7e
    65d2:	8f a7       	lds	r24, 0x7f
    65d4:	98 ab       	sts	0x58, r25
    65d6:	8d a9       	sts	0x4d, r24
    65d8:	9e a9       	sts	0x4e, r25
    65da:	af a9       	sts	0x4f, r26
    65dc:	b8 ad       	sts	0x68, r27
    65de:	04 c0       	rjmp	.+8      	; 0x65e8 <__stack+0x5e9>
    65e0:	b6 95       	lsr	r27
    65e2:	a7 95       	ror	r26
    65e4:	97 95       	ror	r25
    65e6:	87 95       	ror	r24
    65e8:	0a 95       	dec	r16
    65ea:	d2 f7       	brpl	.-12     	; 0x65e0 <__stack+0x5e1>
    65ec:	4d a5       	lds	r20, 0x6d
    65ee:	5e a5       	lds	r21, 0x6e
    65f0:	6f a5       	lds	r22, 0x6f
    65f2:	78 a9       	sts	0x48, r23
    65f4:	48 2b       	or	r20, r24
    65f6:	59 2b       	or	r21, r25
    65f8:	6a 2b       	or	r22, r26
    65fa:	7b 2b       	or	r23, r27
    65fc:	4d a7       	lds	r20, 0x7d
    65fe:	5e a7       	lds	r21, 0x7e
    6600:	6f a7       	lds	r22, 0x7f
    6602:	78 ab       	sts	0x58, r23
    6604:	43 01       	movw	r8, r6
    6606:	aa 24       	eor	r10, r10
    6608:	bb 24       	eor	r11, r11
    660a:	93 01       	movw	r18, r6
    660c:	82 01       	movw	r16, r4
    660e:	20 70       	andi	r18, 0x00	; 0
    6610:	30 70       	andi	r19, 0x00	; 0
    6612:	21 96       	adiw	r28, 0x01	; 1
    6614:	0c af       	sts	0x7c, r16
    6616:	1d af       	sts	0x7d, r17
    6618:	2e af       	sts	0x7e, r18
    661a:	3f af       	sts	0x7f, r19
    661c:	21 97       	sbiw	r28, 0x01	; 1
    661e:	69 a9       	sts	0x49, r22
    6620:	7a a9       	sts	0x4a, r23
    6622:	8b a9       	sts	0x4b, r24
    6624:	9c a9       	sts	0x4c, r25
    6626:	a5 01       	movw	r20, r10
    6628:	94 01       	movw	r18, r8
    662a:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    662e:	29 a7       	lds	r18, 0x79
    6630:	3a a7       	lds	r19, 0x7a
    6632:	4b a7       	lds	r20, 0x7b
    6634:	5c a7       	lds	r21, 0x7c
    6636:	6b 01       	movw	r12, r22
    6638:	7c 01       	movw	r14, r24
    663a:	69 a9       	sts	0x49, r22
    663c:	7a a9       	sts	0x4a, r23
    663e:	8b a9       	sts	0x4b, r24
    6640:	9c a9       	sts	0x4c, r25
    6642:	a5 01       	movw	r20, r10
    6644:	94 01       	movw	r18, r8
    6646:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    664a:	ca 01       	movw	r24, r20
    664c:	b9 01       	movw	r22, r18
    664e:	21 96       	adiw	r28, 0x01	; 1
    6650:	2c ad       	sts	0x6c, r18
    6652:	3d ad       	sts	0x6d, r19
    6654:	4e ad       	sts	0x6e, r20
    6656:	5f ad       	sts	0x6f, r21
    6658:	21 97       	sbiw	r28, 0x01	; 1
    665a:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    665e:	dc 01       	movw	r26, r24
    6660:	cb 01       	movw	r24, r22
    6662:	76 01       	movw	r14, r12
    6664:	dd 24       	eor	r13, r13
    6666:	cc 24       	eor	r12, r12
    6668:	0d a5       	lds	r16, 0x6d
    666a:	1e a5       	lds	r17, 0x6e
    666c:	2f a5       	lds	r18, 0x6f
    666e:	38 a9       	sts	0x48, r19
    6670:	a9 01       	movw	r20, r18
    6672:	66 27       	eor	r22, r22
    6674:	77 27       	eor	r23, r23
    6676:	c4 2a       	or	r12, r20
    6678:	d5 2a       	or	r13, r21
    667a:	e6 2a       	or	r14, r22
    667c:	f7 2a       	or	r15, r23
    667e:	09 a5       	lds	r16, 0x69
    6680:	1a a5       	lds	r17, 0x6a
    6682:	2b a5       	lds	r18, 0x6b
    6684:	3c a5       	lds	r19, 0x6c
    6686:	c8 16       	cp	r12, r24
    6688:	d9 06       	cpc	r13, r25
    668a:	ea 06       	cpc	r14, r26
    668c:	fb 06       	cpc	r15, r27
    668e:	38 f5       	brcc	.+78     	; 0x66de <__stack+0x6df>
    6690:	01 50       	subi	r16, 0x01	; 1
    6692:	10 40       	sbci	r17, 0x00	; 0
    6694:	20 40       	sbci	r18, 0x00	; 0
    6696:	30 40       	sbci	r19, 0x00	; 0
    6698:	09 ab       	sts	0x59, r16
    669a:	1a ab       	sts	0x5a, r17
    669c:	2b ab       	sts	0x5b, r18
    669e:	3c ab       	sts	0x5c, r19
    66a0:	c4 0c       	add	r12, r4
    66a2:	d5 1c       	adc	r13, r5
    66a4:	e6 1c       	adc	r14, r6
    66a6:	f7 1c       	adc	r15, r7
    66a8:	c4 14       	cp	r12, r4
    66aa:	d5 04       	cpc	r13, r5
    66ac:	e6 04       	cpc	r14, r6
    66ae:	f7 04       	cpc	r15, r7
    66b0:	d0 f0       	brcs	.+52     	; 0x66e6 <__stack+0x6e7>
    66b2:	c8 16       	cp	r12, r24
    66b4:	d9 06       	cpc	r13, r25
    66b6:	ea 06       	cpc	r14, r26
    66b8:	fb 06       	cpc	r15, r27
    66ba:	a8 f4       	brcc	.+42     	; 0x66e6 <__stack+0x6e7>
    66bc:	09 a5       	lds	r16, 0x69
    66be:	1a a5       	lds	r17, 0x6a
    66c0:	2b a5       	lds	r18, 0x6b
    66c2:	3c a5       	lds	r19, 0x6c
    66c4:	02 50       	subi	r16, 0x02	; 2
    66c6:	10 40       	sbci	r17, 0x00	; 0
    66c8:	20 40       	sbci	r18, 0x00	; 0
    66ca:	30 40       	sbci	r19, 0x00	; 0
    66cc:	09 ab       	sts	0x59, r16
    66ce:	1a ab       	sts	0x5a, r17
    66d0:	2b ab       	sts	0x5b, r18
    66d2:	3c ab       	sts	0x5c, r19
    66d4:	c4 0c       	add	r12, r4
    66d6:	d5 1c       	adc	r13, r5
    66d8:	e6 1c       	adc	r14, r6
    66da:	f7 1c       	adc	r15, r7
    66dc:	04 c0       	rjmp	.+8      	; 0x66e6 <__stack+0x6e7>
    66de:	09 ab       	sts	0x59, r16
    66e0:	1a ab       	sts	0x5a, r17
    66e2:	2b ab       	sts	0x5b, r18
    66e4:	3c ab       	sts	0x5c, r19
    66e6:	c8 1a       	sub	r12, r24
    66e8:	d9 0a       	sbc	r13, r25
    66ea:	ea 0a       	sbc	r14, r26
    66ec:	fb 0a       	sbc	r15, r27
    66ee:	c7 01       	movw	r24, r14
    66f0:	b6 01       	movw	r22, r12
    66f2:	a5 01       	movw	r20, r10
    66f4:	94 01       	movw	r18, r8
    66f6:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    66fa:	29 a7       	lds	r18, 0x79
    66fc:	3a a7       	lds	r19, 0x7a
    66fe:	4b a7       	lds	r20, 0x7b
    6700:	5c a7       	lds	r21, 0x7c
    6702:	29 96       	adiw	r28, 0x09	; 9
    6704:	6c af       	sts	0x7c, r22
    6706:	7d af       	sts	0x7d, r23
    6708:	8e af       	sts	0x7e, r24
    670a:	9f af       	sts	0x7f, r25
    670c:	29 97       	sbiw	r28, 0x09	; 9
    670e:	c7 01       	movw	r24, r14
    6710:	b6 01       	movw	r22, r12
    6712:	a5 01       	movw	r20, r10
    6714:	94 01       	movw	r18, r8
    6716:	0e 94 60 35 	call	0x6ac0	; 0x6ac0 <__udivmodsi4>
    671a:	ca 01       	movw	r24, r20
    671c:	b9 01       	movw	r22, r18
    671e:	21 96       	adiw	r28, 0x01	; 1
    6720:	2c ad       	sts	0x6c, r18
    6722:	3d ad       	sts	0x6d, r19
    6724:	4e ad       	sts	0x6e, r20
    6726:	5f ad       	sts	0x6f, r21
    6728:	21 97       	sbiw	r28, 0x01	; 1
    672a:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    672e:	4b 01       	movw	r8, r22
    6730:	5c 01       	movw	r10, r24
    6732:	29 96       	adiw	r28, 0x09	; 9
    6734:	4c ad       	sts	0x6c, r20
    6736:	5d ad       	sts	0x6d, r21
    6738:	6e ad       	sts	0x6e, r22
    673a:	7f ad       	sts	0x6f, r23
    673c:	29 97       	sbiw	r28, 0x09	; 9
    673e:	9a 01       	movw	r18, r20
    6740:	11 27       	eor	r17, r17
    6742:	00 27       	eor	r16, r16
    6744:	8d a5       	lds	r24, 0x6d
    6746:	9e a5       	lds	r25, 0x6e
    6748:	af a5       	lds	r26, 0x6f
    674a:	b8 a9       	sts	0x48, r27
    674c:	a0 70       	andi	r26, 0x00	; 0
    674e:	b0 70       	andi	r27, 0x00	; 0
    6750:	08 2b       	or	r16, r24
    6752:	19 2b       	or	r17, r25
    6754:	2a 2b       	or	r18, r26
    6756:	3b 2b       	or	r19, r27
    6758:	89 a5       	lds	r24, 0x69
    675a:	9a a5       	lds	r25, 0x6a
    675c:	ab a5       	lds	r26, 0x6b
    675e:	bc a5       	lds	r27, 0x6c
    6760:	08 15       	cp	r16, r8
    6762:	19 05       	cpc	r17, r9
    6764:	2a 05       	cpc	r18, r10
    6766:	3b 05       	cpc	r19, r11
    6768:	e0 f4       	brcc	.+56     	; 0x67a2 <__stack+0x7a3>
    676a:	01 97       	sbiw	r24, 0x01	; 1
    676c:	a1 09       	sbc	r26, r1
    676e:	b1 09       	sbc	r27, r1
    6770:	04 0d       	add	r16, r4
    6772:	15 1d       	adc	r17, r5
    6774:	26 1d       	adc	r18, r6
    6776:	37 1d       	adc	r19, r7
    6778:	04 15       	cp	r16, r4
    677a:	15 05       	cpc	r17, r5
    677c:	26 05       	cpc	r18, r6
    677e:	37 05       	cpc	r19, r7
    6780:	80 f0       	brcs	.+32     	; 0x67a2 <__stack+0x7a3>
    6782:	08 15       	cp	r16, r8
    6784:	19 05       	cpc	r17, r9
    6786:	2a 05       	cpc	r18, r10
    6788:	3b 05       	cpc	r19, r11
    678a:	58 f4       	brcc	.+22     	; 0x67a2 <__stack+0x7a3>
    678c:	89 a5       	lds	r24, 0x69
    678e:	9a a5       	lds	r25, 0x6a
    6790:	ab a5       	lds	r26, 0x6b
    6792:	bc a5       	lds	r27, 0x6c
    6794:	02 97       	sbiw	r24, 0x02	; 2
    6796:	a1 09       	sbc	r26, r1
    6798:	b1 09       	sbc	r27, r1
    679a:	04 0d       	add	r16, r4
    679c:	15 1d       	adc	r17, r5
    679e:	26 1d       	adc	r18, r6
    67a0:	37 1d       	adc	r19, r7
    67a2:	b9 01       	movw	r22, r18
    67a4:	a8 01       	movw	r20, r16
    67a6:	48 19       	sub	r20, r8
    67a8:	59 09       	sbc	r21, r9
    67aa:	6a 09       	sbc	r22, r10
    67ac:	7b 09       	sbc	r23, r11
    67ae:	4d a7       	lds	r20, 0x7d
    67b0:	5e a7       	lds	r21, 0x7e
    67b2:	6f a7       	lds	r22, 0x7f
    67b4:	78 ab       	sts	0x58, r23
    67b6:	09 a9       	sts	0x49, r16
    67b8:	1a a9       	sts	0x4a, r17
    67ba:	2b a9       	sts	0x4b, r18
    67bc:	3c a9       	sts	0x4c, r19
    67be:	78 01       	movw	r14, r16
    67c0:	dd 24       	eor	r13, r13
    67c2:	cc 24       	eor	r12, r12
    67c4:	c8 2a       	or	r12, r24
    67c6:	d9 2a       	or	r13, r25
    67c8:	ea 2a       	or	r14, r26
    67ca:	fb 2a       	or	r15, r27
    67cc:	ff ef       	ldi	r31, 0xFF	; 255
    67ce:	8f 2e       	mov	r8, r31
    67d0:	ff ef       	ldi	r31, 0xFF	; 255
    67d2:	9f 2e       	mov	r9, r31
    67d4:	a1 2c       	mov	r10, r1
    67d6:	b1 2c       	mov	r11, r1
    67d8:	8c 20       	and	r8, r12
    67da:	9d 20       	and	r9, r13
    67dc:	ae 20       	and	r10, r14
    67de:	bf 20       	and	r11, r15
    67e0:	87 01       	movw	r16, r14
    67e2:	22 27       	eor	r18, r18
    67e4:	33 27       	eor	r19, r19
    67e6:	09 a7       	lds	r16, 0x79
    67e8:	1a a7       	lds	r17, 0x7a
    67ea:	2b a7       	lds	r18, 0x7b
    67ec:	3c a7       	lds	r19, 0x7c
    67ee:	49 ac       	sts	0xa9, r20
    67f0:	5a ac       	sts	0xaa, r21
    67f2:	6b ac       	sts	0xab, r22
    67f4:	7c ac       	sts	0xac, r23
    67f6:	2f ef       	ldi	r18, 0xFF	; 255
    67f8:	3f ef       	ldi	r19, 0xFF	; 255
    67fa:	40 e0       	ldi	r20, 0x00	; 0
    67fc:	50 e0       	ldi	r21, 0x00	; 0
    67fe:	42 22       	and	r4, r18
    6800:	53 22       	and	r5, r19
    6802:	64 22       	and	r6, r20
    6804:	75 22       	and	r7, r21
    6806:	29 ad       	sts	0x69, r18
    6808:	3a ad       	sts	0x6a, r19
    680a:	4b ad       	sts	0x6b, r20
    680c:	5c ad       	sts	0x6c, r21
    680e:	8a 01       	movw	r16, r20
    6810:	22 27       	eor	r18, r18
    6812:	33 27       	eor	r19, r19
    6814:	09 ab       	sts	0x59, r16
    6816:	1a ab       	sts	0x5a, r17
    6818:	2b ab       	sts	0x5b, r18
    681a:	3c ab       	sts	0x5c, r19
    681c:	c5 01       	movw	r24, r10
    681e:	b4 01       	movw	r22, r8
    6820:	a3 01       	movw	r20, r6
    6822:	92 01       	movw	r18, r4
    6824:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    6828:	69 af       	sts	0x79, r22
    682a:	7a af       	sts	0x7a, r23
    682c:	8b af       	sts	0x7b, r24
    682e:	9c af       	sts	0x7c, r25
    6830:	c5 01       	movw	r24, r10
    6832:	b4 01       	movw	r22, r8
    6834:	29 a9       	sts	0x49, r18
    6836:	3a a9       	sts	0x4a, r19
    6838:	4b a9       	sts	0x4b, r20
    683a:	5c a9       	sts	0x4c, r21
    683c:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    6840:	4b 01       	movw	r8, r22
    6842:	5c 01       	movw	r10, r24
    6844:	69 a5       	lds	r22, 0x69
    6846:	7a a5       	lds	r23, 0x6a
    6848:	8b a5       	lds	r24, 0x6b
    684a:	9c a5       	lds	r25, 0x6c
    684c:	a3 01       	movw	r20, r6
    684e:	92 01       	movw	r18, r4
    6850:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    6854:	2b 01       	movw	r4, r22
    6856:	3c 01       	movw	r6, r24
    6858:	69 a5       	lds	r22, 0x69
    685a:	7a a5       	lds	r23, 0x6a
    685c:	8b a5       	lds	r24, 0x6b
    685e:	9c a5       	lds	r25, 0x6c
    6860:	29 a9       	sts	0x49, r18
    6862:	3a a9       	sts	0x4a, r19
    6864:	4b a9       	sts	0x4b, r20
    6866:	5c a9       	sts	0x4c, r21
    6868:	0e 94 1a 35 	call	0x6a34	; 0x6a34 <__mulsi3>
    686c:	ab 01       	movw	r20, r22
    686e:	bc 01       	movw	r22, r24
    6870:	84 0c       	add	r8, r4
    6872:	95 1c       	adc	r9, r5
    6874:	a6 1c       	adc	r10, r6
    6876:	b7 1c       	adc	r11, r7
    6878:	09 ad       	sts	0x69, r16
    687a:	1a ad       	sts	0x6a, r17
    687c:	2b ad       	sts	0x6b, r18
    687e:	3c ad       	sts	0x6c, r19
    6880:	c9 01       	movw	r24, r18
    6882:	aa 27       	eor	r26, r26
    6884:	bb 27       	eor	r27, r27
    6886:	88 0e       	add	r8, r24
    6888:	99 1e       	adc	r9, r25
    688a:	aa 1e       	adc	r10, r26
    688c:	bb 1e       	adc	r11, r27
    688e:	84 14       	cp	r8, r4
    6890:	95 04       	cpc	r9, r5
    6892:	a6 04       	cpc	r10, r6
    6894:	b7 04       	cpc	r11, r7
    6896:	20 f4       	brcc	.+8      	; 0x68a0 <__stack+0x8a1>
    6898:	40 50       	subi	r20, 0x00	; 0
    689a:	50 40       	sbci	r21, 0x00	; 0
    689c:	6f 4f       	sbci	r22, 0xFF	; 255
    689e:	7f 4f       	sbci	r23, 0xFF	; 255
    68a0:	c5 01       	movw	r24, r10
    68a2:	aa 27       	eor	r26, r26
    68a4:	bb 27       	eor	r27, r27
    68a6:	84 0f       	add	r24, r20
    68a8:	95 1f       	adc	r25, r21
    68aa:	a6 1f       	adc	r26, r22
    68ac:	b7 1f       	adc	r27, r23
    68ae:	0d a5       	lds	r16, 0x6d
    68b0:	1e a5       	lds	r17, 0x6e
    68b2:	2f a5       	lds	r18, 0x6f
    68b4:	38 a9       	sts	0x48, r19
    68b6:	08 17       	cp	r16, r24
    68b8:	19 07       	cpc	r17, r25
    68ba:	2a 07       	cpc	r18, r26
    68bc:	3b 07       	cpc	r19, r27
    68be:	18 f1       	brcs	.+70     	; 0x6906 <__stack+0x907>
    68c0:	80 17       	cp	r24, r16
    68c2:	91 07       	cpc	r25, r17
    68c4:	a2 07       	cpc	r26, r18
    68c6:	b3 07       	cpc	r27, r19
    68c8:	a1 f5       	brne	.+104    	; 0x6932 <__stack+0x933>
    68ca:	54 01       	movw	r10, r8
    68cc:	99 24       	eor	r9, r9
    68ce:	88 24       	eor	r8, r8
    68d0:	89 ad       	sts	0x69, r24
    68d2:	9a ad       	sts	0x6a, r25
    68d4:	ab ad       	sts	0x6b, r26
    68d6:	bc ad       	sts	0x6c, r27
    68d8:	a0 70       	andi	r26, 0x00	; 0
    68da:	b0 70       	andi	r27, 0x00	; 0
    68dc:	88 0e       	add	r8, r24
    68de:	99 1e       	adc	r9, r25
    68e0:	aa 1e       	adc	r10, r26
    68e2:	bb 1e       	adc	r11, r27
    68e4:	4d a9       	sts	0x4d, r20
    68e6:	5e a9       	sts	0x4e, r21
    68e8:	6f a9       	sts	0x4f, r22
    68ea:	78 ad       	sts	0x68, r23
    68ec:	03 2c       	mov	r0, r3
    68ee:	04 c0       	rjmp	.+8      	; 0x68f8 <__stack+0x8f9>
    68f0:	44 0f       	add	r20, r20
    68f2:	55 1f       	adc	r21, r21
    68f4:	66 1f       	adc	r22, r22
    68f6:	77 1f       	adc	r23, r23
    68f8:	0a 94       	dec	r0
    68fa:	d2 f7       	brpl	.-12     	; 0x68f0 <__stack+0x8f1>
    68fc:	48 15       	cp	r20, r8
    68fe:	59 05       	cpc	r21, r9
    6900:	6a 05       	cpc	r22, r10
    6902:	7b 05       	cpc	r23, r11
    6904:	b0 f4       	brcc	.+44     	; 0x6932 <__stack+0x933>
    6906:	08 94       	sec
    6908:	c1 08       	sbc	r12, r1
    690a:	d1 08       	sbc	r13, r1
    690c:	e1 08       	sbc	r14, r1
    690e:	f1 08       	sbc	r15, r1
    6910:	10 c0       	rjmp	.+32     	; 0x6932 <__stack+0x933>
    6912:	44 24       	eor	r4, r4
    6914:	55 24       	eor	r5, r5
    6916:	32 01       	movw	r6, r4
    6918:	cc 24       	eor	r12, r12
    691a:	dd 24       	eor	r13, r13
    691c:	76 01       	movw	r14, r12
    691e:	0c c0       	rjmp	.+24     	; 0x6938 <__stack+0x939>
    6920:	44 24       	eor	r4, r4
    6922:	55 24       	eor	r5, r5
    6924:	32 01       	movw	r6, r4
    6926:	81 e0       	ldi	r24, 0x01	; 1
    6928:	c8 2e       	mov	r12, r24
    692a:	d1 2c       	mov	r13, r1
    692c:	e1 2c       	mov	r14, r1
    692e:	f1 2c       	mov	r15, r1
    6930:	03 c0       	rjmp	.+6      	; 0x6938 <__stack+0x939>
    6932:	44 24       	eor	r4, r4
    6934:	55 24       	eor	r5, r5
    6936:	32 01       	movw	r6, r4
    6938:	fe 01       	movw	r30, r28
    693a:	31 96       	adiw	r30, 0x01	; 1
    693c:	88 e0       	ldi	r24, 0x08	; 8
    693e:	df 01       	movw	r26, r30
    6940:	1d 92       	st	X+, r1
    6942:	8a 95       	dec	r24
    6944:	e9 f7       	brne	.-6      	; 0x6940 <__stack+0x941>
    6946:	c9 82       	std	Y+1, r12	; 0x01
    6948:	da 82       	std	Y+2, r13	; 0x02
    694a:	eb 82       	std	Y+3, r14	; 0x03
    694c:	fc 82       	std	Y+4, r15	; 0x04
    694e:	4d 82       	std	Y+5, r4	; 0x05
    6950:	5e 82       	std	Y+6, r5	; 0x06
    6952:	6f 82       	std	Y+7, r6	; 0x07
    6954:	78 86       	std	Y+8, r7	; 0x08
    6956:	2c 2d       	mov	r18, r12
    6958:	3a 81       	ldd	r19, Y+2	; 0x02
    695a:	4b 81       	ldd	r20, Y+3	; 0x03
    695c:	5c 81       	ldd	r21, Y+4	; 0x04
    695e:	64 2d       	mov	r22, r4
    6960:	7e 81       	ldd	r23, Y+6	; 0x06
    6962:	8f 81       	ldd	r24, Y+7	; 0x07
    6964:	98 85       	ldd	r25, Y+8	; 0x08
    6966:	25 96       	adiw	r28, 0x05	; 5
    6968:	ec ac       	sts	0xac, r30
    696a:	fd ac       	sts	0xad, r31
    696c:	0e ad       	sts	0x6e, r16
    696e:	1f ad       	sts	0x6f, r17
    6970:	25 97       	sbiw	r28, 0x05	; 5
    6972:	e1 14       	cp	r14, r1
    6974:	f1 04       	cpc	r15, r1
    6976:	01 05       	cpc	r16, r1
    6978:	11 05       	cpc	r17, r1
    697a:	09 f4       	brne	.+2      	; 0x697e <__stack+0x97f>
    697c:	56 c0       	rjmp	.+172    	; 0x6a2a <__stack+0xa2b>
    697e:	21 95       	neg	r18
    6980:	e1 e0       	ldi	r30, 0x01	; 1
    6982:	12 16       	cp	r1, r18
    6984:	08 f0       	brcs	.+2      	; 0x6988 <__stack+0x989>
    6986:	e0 e0       	ldi	r30, 0x00	; 0
    6988:	31 95       	neg	r19
    698a:	f1 e0       	ldi	r31, 0x01	; 1
    698c:	13 16       	cp	r1, r19
    698e:	08 f0       	brcs	.+2      	; 0x6992 <__stack+0x993>
    6990:	f0 e0       	ldi	r31, 0x00	; 0
    6992:	03 2f       	mov	r16, r19
    6994:	0e 1b       	sub	r16, r30
    6996:	e1 e0       	ldi	r30, 0x01	; 1
    6998:	30 17       	cp	r19, r16
    699a:	08 f0       	brcs	.+2      	; 0x699e <__stack+0x99f>
    699c:	e0 e0       	ldi	r30, 0x00	; 0
    699e:	fe 2b       	or	r31, r30
    69a0:	41 95       	neg	r20
    69a2:	e1 e0       	ldi	r30, 0x01	; 1
    69a4:	14 16       	cp	r1, r20
    69a6:	08 f0       	brcs	.+2      	; 0x69aa <__stack+0x9ab>
    69a8:	e0 e0       	ldi	r30, 0x00	; 0
    69aa:	14 2f       	mov	r17, r20
    69ac:	1f 1b       	sub	r17, r31
    69ae:	31 e0       	ldi	r19, 0x01	; 1
    69b0:	41 17       	cp	r20, r17
    69b2:	08 f0       	brcs	.+2      	; 0x69b6 <__stack+0x9b7>
    69b4:	30 e0       	ldi	r19, 0x00	; 0
    69b6:	e3 2b       	or	r30, r19
    69b8:	51 95       	neg	r21
    69ba:	f1 e0       	ldi	r31, 0x01	; 1
    69bc:	15 16       	cp	r1, r21
    69be:	08 f0       	brcs	.+2      	; 0x69c2 <__stack+0x9c3>
    69c0:	f0 e0       	ldi	r31, 0x00	; 0
    69c2:	b5 2f       	mov	r27, r21
    69c4:	be 1b       	sub	r27, r30
    69c6:	31 e0       	ldi	r19, 0x01	; 1
    69c8:	5b 17       	cp	r21, r27
    69ca:	08 f0       	brcs	.+2      	; 0x69ce <__stack+0x9cf>
    69cc:	30 e0       	ldi	r19, 0x00	; 0
    69ce:	f3 2b       	or	r31, r19
    69d0:	61 95       	neg	r22
    69d2:	e1 e0       	ldi	r30, 0x01	; 1
    69d4:	16 16       	cp	r1, r22
    69d6:	08 f0       	brcs	.+2      	; 0x69da <__stack+0x9db>
    69d8:	e0 e0       	ldi	r30, 0x00	; 0
    69da:	46 2e       	mov	r4, r22
    69dc:	4f 1a       	sub	r4, r31
    69de:	31 e0       	ldi	r19, 0x01	; 1
    69e0:	64 15       	cp	r22, r4
    69e2:	08 f0       	brcs	.+2      	; 0x69e6 <__stack+0x9e7>
    69e4:	30 e0       	ldi	r19, 0x00	; 0
    69e6:	e3 2b       	or	r30, r19
    69e8:	71 95       	neg	r23
    69ea:	f1 e0       	ldi	r31, 0x01	; 1
    69ec:	17 16       	cp	r1, r23
    69ee:	08 f0       	brcs	.+2      	; 0x69f2 <__stack+0x9f3>
    69f0:	f0 e0       	ldi	r31, 0x00	; 0
    69f2:	a7 2f       	mov	r26, r23
    69f4:	ae 1b       	sub	r26, r30
    69f6:	31 e0       	ldi	r19, 0x01	; 1
    69f8:	7a 17       	cp	r23, r26
    69fa:	08 f0       	brcs	.+2      	; 0x69fe <__stack+0x9ff>
    69fc:	30 e0       	ldi	r19, 0x00	; 0
    69fe:	f3 2b       	or	r31, r19
    6a00:	81 95       	neg	r24
    6a02:	e1 e0       	ldi	r30, 0x01	; 1
    6a04:	18 16       	cp	r1, r24
    6a06:	08 f0       	brcs	.+2      	; 0x6a0a <__stack+0xa0b>
    6a08:	e0 e0       	ldi	r30, 0x00	; 0
    6a0a:	f8 2e       	mov	r15, r24
    6a0c:	ff 1a       	sub	r15, r31
    6a0e:	ff 2d       	mov	r31, r15
    6a10:	31 e0       	ldi	r19, 0x01	; 1
    6a12:	8f 15       	cp	r24, r15
    6a14:	08 f0       	brcs	.+2      	; 0x6a18 <__stack+0xa19>
    6a16:	30 e0       	ldi	r19, 0x00	; 0
    6a18:	e3 2b       	or	r30, r19
    6a1a:	91 95       	neg	r25
    6a1c:	30 2f       	mov	r19, r16
    6a1e:	41 2f       	mov	r20, r17
    6a20:	5b 2f       	mov	r21, r27
    6a22:	64 2d       	mov	r22, r4
    6a24:	7a 2f       	mov	r23, r26
    6a26:	8f 2f       	mov	r24, r31
    6a28:	9e 1b       	sub	r25, r30
    6a2a:	c8 5b       	subi	r28, 0xB8	; 184
    6a2c:	df 4f       	sbci	r29, 0xFF	; 255
    6a2e:	e1 e1       	ldi	r30, 0x11	; 17
    6a30:	0c 94 b7 35 	jmp	0x6b6e	; 0x6b6e <__epilogue_restores__+0x2>

00006a34 <__mulsi3>:
    6a34:	62 9f       	mul	r22, r18
    6a36:	d0 01       	movw	r26, r0
    6a38:	73 9f       	mul	r23, r19
    6a3a:	f0 01       	movw	r30, r0
    6a3c:	82 9f       	mul	r24, r18
    6a3e:	e0 0d       	add	r30, r0
    6a40:	f1 1d       	adc	r31, r1
    6a42:	64 9f       	mul	r22, r20
    6a44:	e0 0d       	add	r30, r0
    6a46:	f1 1d       	adc	r31, r1
    6a48:	92 9f       	mul	r25, r18
    6a4a:	f0 0d       	add	r31, r0
    6a4c:	83 9f       	mul	r24, r19
    6a4e:	f0 0d       	add	r31, r0
    6a50:	74 9f       	mul	r23, r20
    6a52:	f0 0d       	add	r31, r0
    6a54:	65 9f       	mul	r22, r21
    6a56:	f0 0d       	add	r31, r0
    6a58:	99 27       	eor	r25, r25
    6a5a:	72 9f       	mul	r23, r18
    6a5c:	b0 0d       	add	r27, r0
    6a5e:	e1 1d       	adc	r30, r1
    6a60:	f9 1f       	adc	r31, r25
    6a62:	63 9f       	mul	r22, r19
    6a64:	b0 0d       	add	r27, r0
    6a66:	e1 1d       	adc	r30, r1
    6a68:	f9 1f       	adc	r31, r25
    6a6a:	bd 01       	movw	r22, r26
    6a6c:	cf 01       	movw	r24, r30
    6a6e:	11 24       	eor	r1, r1
    6a70:	08 95       	ret

00006a72 <__udivmodhi4>:
    6a72:	aa 1b       	sub	r26, r26
    6a74:	bb 1b       	sub	r27, r27
    6a76:	51 e1       	ldi	r21, 0x11	; 17
    6a78:	07 c0       	rjmp	.+14     	; 0x6a88 <__udivmodhi4_ep>

00006a7a <__udivmodhi4_loop>:
    6a7a:	aa 1f       	adc	r26, r26
    6a7c:	bb 1f       	adc	r27, r27
    6a7e:	a6 17       	cp	r26, r22
    6a80:	b7 07       	cpc	r27, r23
    6a82:	10 f0       	brcs	.+4      	; 0x6a88 <__udivmodhi4_ep>
    6a84:	a6 1b       	sub	r26, r22
    6a86:	b7 0b       	sbc	r27, r23

00006a88 <__udivmodhi4_ep>:
    6a88:	88 1f       	adc	r24, r24
    6a8a:	99 1f       	adc	r25, r25
    6a8c:	5a 95       	dec	r21
    6a8e:	a9 f7       	brne	.-22     	; 0x6a7a <__udivmodhi4_loop>
    6a90:	80 95       	com	r24
    6a92:	90 95       	com	r25
    6a94:	bc 01       	movw	r22, r24
    6a96:	cd 01       	movw	r24, r26
    6a98:	08 95       	ret

00006a9a <__divmodhi4>:
    6a9a:	97 fb       	bst	r25, 7
    6a9c:	09 2e       	mov	r0, r25
    6a9e:	07 26       	eor	r0, r23
    6aa0:	0a d0       	rcall	.+20     	; 0x6ab6 <__divmodhi4_neg1>
    6aa2:	77 fd       	sbrc	r23, 7
    6aa4:	04 d0       	rcall	.+8      	; 0x6aae <__divmodhi4_neg2>
    6aa6:	e5 df       	rcall	.-54     	; 0x6a72 <__udivmodhi4>
    6aa8:	06 d0       	rcall	.+12     	; 0x6ab6 <__divmodhi4_neg1>
    6aaa:	00 20       	and	r0, r0
    6aac:	1a f4       	brpl	.+6      	; 0x6ab4 <__divmodhi4_exit>

00006aae <__divmodhi4_neg2>:
    6aae:	70 95       	com	r23
    6ab0:	61 95       	neg	r22
    6ab2:	7f 4f       	sbci	r23, 0xFF	; 255

00006ab4 <__divmodhi4_exit>:
    6ab4:	08 95       	ret

00006ab6 <__divmodhi4_neg1>:
    6ab6:	f6 f7       	brtc	.-4      	; 0x6ab4 <__divmodhi4_exit>
    6ab8:	90 95       	com	r25
    6aba:	81 95       	neg	r24
    6abc:	9f 4f       	sbci	r25, 0xFF	; 255
    6abe:	08 95       	ret

00006ac0 <__udivmodsi4>:
    6ac0:	a1 e2       	ldi	r26, 0x21	; 33
    6ac2:	1a 2e       	mov	r1, r26
    6ac4:	aa 1b       	sub	r26, r26
    6ac6:	bb 1b       	sub	r27, r27
    6ac8:	fd 01       	movw	r30, r26
    6aca:	0d c0       	rjmp	.+26     	; 0x6ae6 <__udivmodsi4_ep>

00006acc <__udivmodsi4_loop>:
    6acc:	aa 1f       	adc	r26, r26
    6ace:	bb 1f       	adc	r27, r27
    6ad0:	ee 1f       	adc	r30, r30
    6ad2:	ff 1f       	adc	r31, r31
    6ad4:	a2 17       	cp	r26, r18
    6ad6:	b3 07       	cpc	r27, r19
    6ad8:	e4 07       	cpc	r30, r20
    6ada:	f5 07       	cpc	r31, r21
    6adc:	20 f0       	brcs	.+8      	; 0x6ae6 <__udivmodsi4_ep>
    6ade:	a2 1b       	sub	r26, r18
    6ae0:	b3 0b       	sbc	r27, r19
    6ae2:	e4 0b       	sbc	r30, r20
    6ae4:	f5 0b       	sbc	r31, r21

00006ae6 <__udivmodsi4_ep>:
    6ae6:	66 1f       	adc	r22, r22
    6ae8:	77 1f       	adc	r23, r23
    6aea:	88 1f       	adc	r24, r24
    6aec:	99 1f       	adc	r25, r25
    6aee:	1a 94       	dec	r1
    6af0:	69 f7       	brne	.-38     	; 0x6acc <__udivmodsi4_loop>
    6af2:	60 95       	com	r22
    6af4:	70 95       	com	r23
    6af6:	80 95       	com	r24
    6af8:	90 95       	com	r25
    6afa:	9b 01       	movw	r18, r22
    6afc:	ac 01       	movw	r20, r24
    6afe:	bd 01       	movw	r22, r26
    6b00:	cf 01       	movw	r24, r30
    6b02:	08 95       	ret

00006b04 <__divmodsi4>:
    6b04:	97 fb       	bst	r25, 7
    6b06:	09 2e       	mov	r0, r25
    6b08:	05 26       	eor	r0, r21
    6b0a:	0e d0       	rcall	.+28     	; 0x6b28 <__divmodsi4_neg1>
    6b0c:	57 fd       	sbrc	r21, 7
    6b0e:	04 d0       	rcall	.+8      	; 0x6b18 <__divmodsi4_neg2>
    6b10:	d7 df       	rcall	.-82     	; 0x6ac0 <__udivmodsi4>
    6b12:	0a d0       	rcall	.+20     	; 0x6b28 <__divmodsi4_neg1>
    6b14:	00 1c       	adc	r0, r0
    6b16:	38 f4       	brcc	.+14     	; 0x6b26 <__divmodsi4_exit>

00006b18 <__divmodsi4_neg2>:
    6b18:	50 95       	com	r21
    6b1a:	40 95       	com	r20
    6b1c:	30 95       	com	r19
    6b1e:	21 95       	neg	r18
    6b20:	3f 4f       	sbci	r19, 0xFF	; 255
    6b22:	4f 4f       	sbci	r20, 0xFF	; 255
    6b24:	5f 4f       	sbci	r21, 0xFF	; 255

00006b26 <__divmodsi4_exit>:
    6b26:	08 95       	ret

00006b28 <__divmodsi4_neg1>:
    6b28:	f6 f7       	brtc	.-4      	; 0x6b26 <__divmodsi4_exit>
    6b2a:	90 95       	com	r25
    6b2c:	80 95       	com	r24
    6b2e:	70 95       	com	r23
    6b30:	61 95       	neg	r22
    6b32:	7f 4f       	sbci	r23, 0xFF	; 255
    6b34:	8f 4f       	sbci	r24, 0xFF	; 255
    6b36:	9f 4f       	sbci	r25, 0xFF	; 255
    6b38:	08 95       	ret

00006b3a <__prologue_saves__>:
    6b3a:	2f 92       	push	r2
    6b3c:	3f 92       	push	r3
    6b3e:	4f 92       	push	r4
    6b40:	5f 92       	push	r5
    6b42:	6f 92       	push	r6
    6b44:	7f 92       	push	r7
    6b46:	8f 92       	push	r8
    6b48:	9f 92       	push	r9
    6b4a:	af 92       	push	r10
    6b4c:	bf 92       	push	r11
    6b4e:	cf 92       	push	r12
    6b50:	df 92       	push	r13
    6b52:	ef 92       	push	r14
    6b54:	ff 92       	push	r15
    6b56:	0f 93       	push	r16
    6b58:	1f 93       	push	r17
    6b5a:	cf 93       	push	r28
    6b5c:	df 93       	push	r29
    6b5e:	cd b7       	in	r28, 0x3d	; 61
    6b60:	de b7       	in	r29, 0x3e	; 62
    6b62:	ca 1b       	sub	r28, r26
    6b64:	db 0b       	sbc	r29, r27
    6b66:	cd bf       	out	0x3d, r28	; 61
    6b68:	de bf       	out	0x3e, r29	; 62
    6b6a:	19 94       	eijmp

00006b6c <__epilogue_restores__>:
    6b6c:	2a 88       	ldd	r2, Y+18	; 0x12
    6b6e:	39 88       	ldd	r3, Y+17	; 0x11
    6b70:	48 88       	ldd	r4, Y+16	; 0x10
    6b72:	5f 84       	ldd	r5, Y+15	; 0x0f
    6b74:	6e 84       	ldd	r6, Y+14	; 0x0e
    6b76:	7d 84       	ldd	r7, Y+13	; 0x0d
    6b78:	8c 84       	ldd	r8, Y+12	; 0x0c
    6b7a:	9b 84       	ldd	r9, Y+11	; 0x0b
    6b7c:	aa 84       	ldd	r10, Y+10	; 0x0a
    6b7e:	b9 84       	ldd	r11, Y+9	; 0x09
    6b80:	c8 84       	ldd	r12, Y+8	; 0x08
    6b82:	df 80       	ldd	r13, Y+7	; 0x07
    6b84:	ee 80       	ldd	r14, Y+6	; 0x06
    6b86:	fd 80       	ldd	r15, Y+5	; 0x05
    6b88:	0c 81       	ldd	r16, Y+4	; 0x04
    6b8a:	1b 81       	ldd	r17, Y+3	; 0x03
    6b8c:	aa 81       	ldd	r26, Y+2	; 0x02
    6b8e:	b9 81       	ldd	r27, Y+1	; 0x01
    6b90:	ce 0f       	add	r28, r30
    6b92:	d1 1d       	adc	r29, r1
    6b94:	cd bf       	out	0x3d, r28	; 61
    6b96:	de bf       	out	0x3e, r29	; 62
    6b98:	ed 01       	movw	r28, r26
    6b9a:	08 95       	ret

00006b9c <strcpy_P>:
    6b9c:	fb 01       	movw	r30, r22
    6b9e:	dc 01       	movw	r26, r24
    6ba0:	05 90       	lpm	r0, Z+
    6ba2:	0d 92       	st	X+, r0
    6ba4:	00 20       	and	r0, r0
    6ba6:	e1 f7       	brne	.-8      	; 0x6ba0 <strcpy_P+0x4>
    6ba8:	08 95       	ret

00006baa <memmove>:
    6baa:	68 17       	cp	r22, r24
    6bac:	79 07       	cpc	r23, r25
    6bae:	68 f4       	brcc	.+26     	; 0x6bca <memmove+0x20>
    6bb0:	fb 01       	movw	r30, r22
    6bb2:	dc 01       	movw	r26, r24
    6bb4:	e4 0f       	add	r30, r20
    6bb6:	f5 1f       	adc	r31, r21
    6bb8:	a4 0f       	add	r26, r20
    6bba:	b5 1f       	adc	r27, r21
    6bbc:	02 c0       	rjmp	.+4      	; 0x6bc2 <memmove+0x18>
    6bbe:	02 90       	ld	r0, -Z
    6bc0:	0e 92       	st	-X, r0
    6bc2:	41 50       	subi	r20, 0x01	; 1
    6bc4:	50 40       	sbci	r21, 0x00	; 0
    6bc6:	d8 f7       	brcc	.-10     	; 0x6bbe <memmove+0x14>
    6bc8:	08 95       	ret
    6bca:	0c 94 05 38 	jmp	0x700a	; 0x700a <memcpy>

00006bce <printf>:
    6bce:	cf 93       	push	r28
    6bd0:	df 93       	push	r29
    6bd2:	cd b7       	in	r28, 0x3d	; 61
    6bd4:	de b7       	in	r29, 0x3e	; 62
    6bd6:	fe 01       	movw	r30, r28
    6bd8:	36 96       	adiw	r30, 0x06	; 6
    6bda:	61 91       	ld	r22, Z+
    6bdc:	71 91       	ld	r23, Z+
    6bde:	80 91 b5 50 	lds	r24, 0x50B5
    6be2:	90 91 b6 50 	lds	r25, 0x50B6
    6be6:	af 01       	movw	r20, r30
    6be8:	0e 94 f9 35 	call	0x6bf2	; 0x6bf2 <vfprintf>
    6bec:	df 91       	pop	r29
    6bee:	cf 91       	pop	r28
    6bf0:	08 95       	ret

00006bf2 <vfprintf>:
    6bf2:	2f 92       	push	r2
    6bf4:	3f 92       	push	r3
    6bf6:	4f 92       	push	r4
    6bf8:	5f 92       	push	r5
    6bfa:	6f 92       	push	r6
    6bfc:	7f 92       	push	r7
    6bfe:	8f 92       	push	r8
    6c00:	9f 92       	push	r9
    6c02:	af 92       	push	r10
    6c04:	bf 92       	push	r11
    6c06:	cf 92       	push	r12
    6c08:	df 92       	push	r13
    6c0a:	ef 92       	push	r14
    6c0c:	ff 92       	push	r15
    6c0e:	0f 93       	push	r16
    6c10:	1f 93       	push	r17
    6c12:	cf 93       	push	r28
    6c14:	df 93       	push	r29
    6c16:	cd b7       	in	r28, 0x3d	; 61
    6c18:	de b7       	in	r29, 0x3e	; 62
    6c1a:	2d 97       	sbiw	r28, 0x0d	; 13
    6c1c:	cd bf       	out	0x3d, r28	; 61
    6c1e:	de bf       	out	0x3e, r29	; 62
    6c20:	3c 01       	movw	r6, r24
    6c22:	6c 87       	std	Y+12, r22	; 0x0c
    6c24:	7d 87       	std	Y+13, r23	; 0x0d
    6c26:	5a 01       	movw	r10, r20
    6c28:	fc 01       	movw	r30, r24
    6c2a:	16 82       	std	Z+6, r1	; 0x06
    6c2c:	17 82       	std	Z+7, r1	; 0x07
    6c2e:	83 81       	ldd	r24, Z+3	; 0x03
    6c30:	81 ff       	sbrs	r24, 1
    6c32:	c8 c1       	rjmp	.+912    	; 0x6fc4 <vfprintf+0x3d2>
    6c34:	2e 01       	movw	r4, r28
    6c36:	08 94       	sec
    6c38:	41 1c       	adc	r4, r1
    6c3a:	51 1c       	adc	r5, r1
    6c3c:	f3 01       	movw	r30, r6
    6c3e:	93 81       	ldd	r25, Z+3	; 0x03
    6c40:	ec 85       	ldd	r30, Y+12	; 0x0c
    6c42:	fd 85       	ldd	r31, Y+13	; 0x0d
    6c44:	93 fd       	sbrc	r25, 3
    6c46:	85 91       	lpm	r24, Z+
    6c48:	93 ff       	sbrs	r25, 3
    6c4a:	81 91       	ld	r24, Z+
    6c4c:	ec 87       	std	Y+12, r30	; 0x0c
    6c4e:	fd 87       	std	Y+13, r31	; 0x0d
    6c50:	88 23       	and	r24, r24
    6c52:	09 f4       	brne	.+2      	; 0x6c56 <vfprintf+0x64>
    6c54:	b3 c1       	rjmp	.+870    	; 0x6fbc <vfprintf+0x3ca>
    6c56:	85 32       	cpi	r24, 0x25	; 37
    6c58:	41 f4       	brne	.+16     	; 0x6c6a <vfprintf+0x78>
    6c5a:	93 fd       	sbrc	r25, 3
    6c5c:	85 91       	lpm	r24, Z+
    6c5e:	93 ff       	sbrs	r25, 3
    6c60:	81 91       	ld	r24, Z+
    6c62:	ec 87       	std	Y+12, r30	; 0x0c
    6c64:	fd 87       	std	Y+13, r31	; 0x0d
    6c66:	85 32       	cpi	r24, 0x25	; 37
    6c68:	29 f4       	brne	.+10     	; 0x6c74 <vfprintf+0x82>
    6c6a:	90 e0       	ldi	r25, 0x00	; 0
    6c6c:	b3 01       	movw	r22, r6
    6c6e:	0e 94 19 38 	call	0x7032	; 0x7032 <fputc>
    6c72:	e4 cf       	rjmp	.-56     	; 0x6c3c <vfprintf+0x4a>
    6c74:	ff 24       	eor	r15, r15
    6c76:	ee 24       	eor	r14, r14
    6c78:	10 e0       	ldi	r17, 0x00	; 0
    6c7a:	10 32       	cpi	r17, 0x20	; 32
    6c7c:	b0 f4       	brcc	.+44     	; 0x6caa <vfprintf+0xb8>
    6c7e:	8b 32       	cpi	r24, 0x2B	; 43
    6c80:	69 f0       	breq	.+26     	; 0x6c9c <vfprintf+0xaa>
    6c82:	8c 32       	cpi	r24, 0x2C	; 44
    6c84:	28 f4       	brcc	.+10     	; 0x6c90 <vfprintf+0x9e>
    6c86:	80 32       	cpi	r24, 0x20	; 32
    6c88:	51 f0       	breq	.+20     	; 0x6c9e <vfprintf+0xac>
    6c8a:	83 32       	cpi	r24, 0x23	; 35
    6c8c:	71 f4       	brne	.+28     	; 0x6caa <vfprintf+0xb8>
    6c8e:	0b c0       	rjmp	.+22     	; 0x6ca6 <vfprintf+0xb4>
    6c90:	8d 32       	cpi	r24, 0x2D	; 45
    6c92:	39 f0       	breq	.+14     	; 0x6ca2 <vfprintf+0xb0>
    6c94:	80 33       	cpi	r24, 0x30	; 48
    6c96:	49 f4       	brne	.+18     	; 0x6caa <vfprintf+0xb8>
    6c98:	11 60       	ori	r17, 0x01	; 1
    6c9a:	2c c0       	rjmp	.+88     	; 0x6cf4 <vfprintf+0x102>
    6c9c:	12 60       	ori	r17, 0x02	; 2
    6c9e:	14 60       	ori	r17, 0x04	; 4
    6ca0:	29 c0       	rjmp	.+82     	; 0x6cf4 <vfprintf+0x102>
    6ca2:	18 60       	ori	r17, 0x08	; 8
    6ca4:	27 c0       	rjmp	.+78     	; 0x6cf4 <vfprintf+0x102>
    6ca6:	10 61       	ori	r17, 0x10	; 16
    6ca8:	25 c0       	rjmp	.+74     	; 0x6cf4 <vfprintf+0x102>
    6caa:	17 fd       	sbrc	r17, 7
    6cac:	2e c0       	rjmp	.+92     	; 0x6d0a <vfprintf+0x118>
    6cae:	28 2f       	mov	r18, r24
    6cb0:	20 53       	subi	r18, 0x30	; 48
    6cb2:	2a 30       	cpi	r18, 0x0A	; 10
    6cb4:	98 f4       	brcc	.+38     	; 0x6cdc <vfprintf+0xea>
    6cb6:	16 ff       	sbrs	r17, 6
    6cb8:	08 c0       	rjmp	.+16     	; 0x6cca <vfprintf+0xd8>
    6cba:	8f 2d       	mov	r24, r15
    6cbc:	88 0f       	add	r24, r24
    6cbe:	f8 2e       	mov	r15, r24
    6cc0:	ff 0c       	add	r15, r15
    6cc2:	ff 0c       	add	r15, r15
    6cc4:	f8 0e       	add	r15, r24
    6cc6:	f2 0e       	add	r15, r18
    6cc8:	15 c0       	rjmp	.+42     	; 0x6cf4 <vfprintf+0x102>
    6cca:	8e 2d       	mov	r24, r14
    6ccc:	88 0f       	add	r24, r24
    6cce:	e8 2e       	mov	r14, r24
    6cd0:	ee 0c       	add	r14, r14
    6cd2:	ee 0c       	add	r14, r14
    6cd4:	e8 0e       	add	r14, r24
    6cd6:	e2 0e       	add	r14, r18
    6cd8:	10 62       	ori	r17, 0x20	; 32
    6cda:	0c c0       	rjmp	.+24     	; 0x6cf4 <vfprintf+0x102>
    6cdc:	8e 32       	cpi	r24, 0x2E	; 46
    6cde:	21 f4       	brne	.+8      	; 0x6ce8 <vfprintf+0xf6>
    6ce0:	16 fd       	sbrc	r17, 6
    6ce2:	6c c1       	rjmp	.+728    	; 0x6fbc <vfprintf+0x3ca>
    6ce4:	10 64       	ori	r17, 0x40	; 64
    6ce6:	06 c0       	rjmp	.+12     	; 0x6cf4 <vfprintf+0x102>
    6ce8:	8c 36       	cpi	r24, 0x6C	; 108
    6cea:	11 f4       	brne	.+4      	; 0x6cf0 <vfprintf+0xfe>
    6cec:	10 68       	ori	r17, 0x80	; 128
    6cee:	02 c0       	rjmp	.+4      	; 0x6cf4 <vfprintf+0x102>
    6cf0:	88 36       	cpi	r24, 0x68	; 104
    6cf2:	59 f4       	brne	.+22     	; 0x6d0a <vfprintf+0x118>
    6cf4:	ec 85       	ldd	r30, Y+12	; 0x0c
    6cf6:	fd 85       	ldd	r31, Y+13	; 0x0d
    6cf8:	93 fd       	sbrc	r25, 3
    6cfa:	85 91       	lpm	r24, Z+
    6cfc:	93 ff       	sbrs	r25, 3
    6cfe:	81 91       	ld	r24, Z+
    6d00:	ec 87       	std	Y+12, r30	; 0x0c
    6d02:	fd 87       	std	Y+13, r31	; 0x0d
    6d04:	88 23       	and	r24, r24
    6d06:	09 f0       	breq	.+2      	; 0x6d0a <vfprintf+0x118>
    6d08:	b8 cf       	rjmp	.-144    	; 0x6c7a <vfprintf+0x88>
    6d0a:	98 2f       	mov	r25, r24
    6d0c:	95 54       	subi	r25, 0x45	; 69
    6d0e:	93 30       	cpi	r25, 0x03	; 3
    6d10:	18 f0       	brcs	.+6      	; 0x6d18 <vfprintf+0x126>
    6d12:	90 52       	subi	r25, 0x20	; 32
    6d14:	93 30       	cpi	r25, 0x03	; 3
    6d16:	38 f4       	brcc	.+14     	; 0x6d26 <vfprintf+0x134>
    6d18:	24 e0       	ldi	r18, 0x04	; 4
    6d1a:	30 e0       	ldi	r19, 0x00	; 0
    6d1c:	a2 0e       	add	r10, r18
    6d1e:	b3 1e       	adc	r11, r19
    6d20:	3f e3       	ldi	r19, 0x3F	; 63
    6d22:	39 83       	std	Y+1, r19	; 0x01
    6d24:	0f c0       	rjmp	.+30     	; 0x6d44 <vfprintf+0x152>
    6d26:	83 36       	cpi	r24, 0x63	; 99
    6d28:	31 f0       	breq	.+12     	; 0x6d36 <vfprintf+0x144>
    6d2a:	83 37       	cpi	r24, 0x73	; 115
    6d2c:	81 f0       	breq	.+32     	; 0x6d4e <vfprintf+0x15c>
    6d2e:	83 35       	cpi	r24, 0x53	; 83
    6d30:	09 f0       	breq	.+2      	; 0x6d34 <vfprintf+0x142>
    6d32:	5a c0       	rjmp	.+180    	; 0x6de8 <vfprintf+0x1f6>
    6d34:	22 c0       	rjmp	.+68     	; 0x6d7a <vfprintf+0x188>
    6d36:	f5 01       	movw	r30, r10
    6d38:	80 81       	ld	r24, Z
    6d3a:	89 83       	std	Y+1, r24	; 0x01
    6d3c:	22 e0       	ldi	r18, 0x02	; 2
    6d3e:	30 e0       	ldi	r19, 0x00	; 0
    6d40:	a2 0e       	add	r10, r18
    6d42:	b3 1e       	adc	r11, r19
    6d44:	21 e0       	ldi	r18, 0x01	; 1
    6d46:	c2 2e       	mov	r12, r18
    6d48:	d1 2c       	mov	r13, r1
    6d4a:	42 01       	movw	r8, r4
    6d4c:	14 c0       	rjmp	.+40     	; 0x6d76 <vfprintf+0x184>
    6d4e:	92 e0       	ldi	r25, 0x02	; 2
    6d50:	29 2e       	mov	r2, r25
    6d52:	31 2c       	mov	r3, r1
    6d54:	2a 0c       	add	r2, r10
    6d56:	3b 1c       	adc	r3, r11
    6d58:	f5 01       	movw	r30, r10
    6d5a:	80 80       	ld	r8, Z
    6d5c:	91 80       	ldd	r9, Z+1	; 0x01
    6d5e:	16 ff       	sbrs	r17, 6
    6d60:	03 c0       	rjmp	.+6      	; 0x6d68 <vfprintf+0x176>
    6d62:	6f 2d       	mov	r22, r15
    6d64:	70 e0       	ldi	r23, 0x00	; 0
    6d66:	02 c0       	rjmp	.+4      	; 0x6d6c <vfprintf+0x17a>
    6d68:	6f ef       	ldi	r22, 0xFF	; 255
    6d6a:	7f ef       	ldi	r23, 0xFF	; 255
    6d6c:	c4 01       	movw	r24, r8
    6d6e:	0e 94 0e 38 	call	0x701c	; 0x701c <strnlen>
    6d72:	6c 01       	movw	r12, r24
    6d74:	51 01       	movw	r10, r2
    6d76:	1f 77       	andi	r17, 0x7F	; 127
    6d78:	15 c0       	rjmp	.+42     	; 0x6da4 <vfprintf+0x1b2>
    6d7a:	82 e0       	ldi	r24, 0x02	; 2
    6d7c:	28 2e       	mov	r2, r24
    6d7e:	31 2c       	mov	r3, r1
    6d80:	2a 0c       	add	r2, r10
    6d82:	3b 1c       	adc	r3, r11
    6d84:	f5 01       	movw	r30, r10
    6d86:	80 80       	ld	r8, Z
    6d88:	91 80       	ldd	r9, Z+1	; 0x01
    6d8a:	16 ff       	sbrs	r17, 6
    6d8c:	03 c0       	rjmp	.+6      	; 0x6d94 <vfprintf+0x1a2>
    6d8e:	6f 2d       	mov	r22, r15
    6d90:	70 e0       	ldi	r23, 0x00	; 0
    6d92:	02 c0       	rjmp	.+4      	; 0x6d98 <vfprintf+0x1a6>
    6d94:	6f ef       	ldi	r22, 0xFF	; 255
    6d96:	7f ef       	ldi	r23, 0xFF	; 255
    6d98:	c4 01       	movw	r24, r8
    6d9a:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <strnlen_P>
    6d9e:	6c 01       	movw	r12, r24
    6da0:	10 68       	ori	r17, 0x80	; 128
    6da2:	51 01       	movw	r10, r2
    6da4:	13 fd       	sbrc	r17, 3
    6da6:	1c c0       	rjmp	.+56     	; 0x6de0 <vfprintf+0x1ee>
    6da8:	06 c0       	rjmp	.+12     	; 0x6db6 <vfprintf+0x1c4>
    6daa:	80 e2       	ldi	r24, 0x20	; 32
    6dac:	90 e0       	ldi	r25, 0x00	; 0
    6dae:	b3 01       	movw	r22, r6
    6db0:	0e 94 19 38 	call	0x7032	; 0x7032 <fputc>
    6db4:	ea 94       	dec	r14
    6db6:	8e 2d       	mov	r24, r14
    6db8:	90 e0       	ldi	r25, 0x00	; 0
    6dba:	c8 16       	cp	r12, r24
    6dbc:	d9 06       	cpc	r13, r25
    6dbe:	a8 f3       	brcs	.-22     	; 0x6daa <vfprintf+0x1b8>
    6dc0:	0f c0       	rjmp	.+30     	; 0x6de0 <vfprintf+0x1ee>
    6dc2:	f4 01       	movw	r30, r8
    6dc4:	17 fd       	sbrc	r17, 7
    6dc6:	85 91       	lpm	r24, Z+
    6dc8:	17 ff       	sbrs	r17, 7
    6dca:	81 91       	ld	r24, Z+
    6dcc:	4f 01       	movw	r8, r30
    6dce:	90 e0       	ldi	r25, 0x00	; 0
    6dd0:	b3 01       	movw	r22, r6
    6dd2:	0e 94 19 38 	call	0x7032	; 0x7032 <fputc>
    6dd6:	e1 10       	cpse	r14, r1
    6dd8:	ea 94       	dec	r14
    6dda:	08 94       	sec
    6ddc:	c1 08       	sbc	r12, r1
    6dde:	d1 08       	sbc	r13, r1
    6de0:	c1 14       	cp	r12, r1
    6de2:	d1 04       	cpc	r13, r1
    6de4:	71 f7       	brne	.-36     	; 0x6dc2 <vfprintf+0x1d0>
    6de6:	e7 c0       	rjmp	.+462    	; 0x6fb6 <vfprintf+0x3c4>
    6de8:	84 36       	cpi	r24, 0x64	; 100
    6dea:	11 f0       	breq	.+4      	; 0x6df0 <vfprintf+0x1fe>
    6dec:	89 36       	cpi	r24, 0x69	; 105
    6dee:	51 f5       	brne	.+84     	; 0x6e44 <vfprintf+0x252>
    6df0:	f5 01       	movw	r30, r10
    6df2:	17 ff       	sbrs	r17, 7
    6df4:	07 c0       	rjmp	.+14     	; 0x6e04 <vfprintf+0x212>
    6df6:	80 81       	ld	r24, Z
    6df8:	91 81       	ldd	r25, Z+1	; 0x01
    6dfa:	a2 81       	ldd	r26, Z+2	; 0x02
    6dfc:	b3 81       	ldd	r27, Z+3	; 0x03
    6dfe:	24 e0       	ldi	r18, 0x04	; 4
    6e00:	30 e0       	ldi	r19, 0x00	; 0
    6e02:	08 c0       	rjmp	.+16     	; 0x6e14 <vfprintf+0x222>
    6e04:	80 81       	ld	r24, Z
    6e06:	91 81       	ldd	r25, Z+1	; 0x01
    6e08:	aa 27       	eor	r26, r26
    6e0a:	97 fd       	sbrc	r25, 7
    6e0c:	a0 95       	com	r26
    6e0e:	ba 2f       	mov	r27, r26
    6e10:	22 e0       	ldi	r18, 0x02	; 2
    6e12:	30 e0       	ldi	r19, 0x00	; 0
    6e14:	a2 0e       	add	r10, r18
    6e16:	b3 1e       	adc	r11, r19
    6e18:	01 2f       	mov	r16, r17
    6e1a:	0f 76       	andi	r16, 0x6F	; 111
    6e1c:	b7 ff       	sbrs	r27, 7
    6e1e:	08 c0       	rjmp	.+16     	; 0x6e30 <vfprintf+0x23e>
    6e20:	b0 95       	com	r27
    6e22:	a0 95       	com	r26
    6e24:	90 95       	com	r25
    6e26:	81 95       	neg	r24
    6e28:	9f 4f       	sbci	r25, 0xFF	; 255
    6e2a:	af 4f       	sbci	r26, 0xFF	; 255
    6e2c:	bf 4f       	sbci	r27, 0xFF	; 255
    6e2e:	00 68       	ori	r16, 0x80	; 128
    6e30:	bc 01       	movw	r22, r24
    6e32:	cd 01       	movw	r24, r26
    6e34:	a2 01       	movw	r20, r4
    6e36:	2a e0       	ldi	r18, 0x0A	; 10
    6e38:	30 e0       	ldi	r19, 0x00	; 0
    6e3a:	0e 94 45 38 	call	0x708a	; 0x708a <__ultoa_invert>
    6e3e:	d8 2e       	mov	r13, r24
    6e40:	d4 18       	sub	r13, r4
    6e42:	3f c0       	rjmp	.+126    	; 0x6ec2 <vfprintf+0x2d0>
    6e44:	85 37       	cpi	r24, 0x75	; 117
    6e46:	21 f4       	brne	.+8      	; 0x6e50 <vfprintf+0x25e>
    6e48:	1f 7e       	andi	r17, 0xEF	; 239
    6e4a:	2a e0       	ldi	r18, 0x0A	; 10
    6e4c:	30 e0       	ldi	r19, 0x00	; 0
    6e4e:	20 c0       	rjmp	.+64     	; 0x6e90 <vfprintf+0x29e>
    6e50:	19 7f       	andi	r17, 0xF9	; 249
    6e52:	8f 36       	cpi	r24, 0x6F	; 111
    6e54:	a9 f0       	breq	.+42     	; 0x6e80 <vfprintf+0x28e>
    6e56:	80 37       	cpi	r24, 0x70	; 112
    6e58:	20 f4       	brcc	.+8      	; 0x6e62 <vfprintf+0x270>
    6e5a:	88 35       	cpi	r24, 0x58	; 88
    6e5c:	09 f0       	breq	.+2      	; 0x6e60 <vfprintf+0x26e>
    6e5e:	ae c0       	rjmp	.+348    	; 0x6fbc <vfprintf+0x3ca>
    6e60:	0b c0       	rjmp	.+22     	; 0x6e78 <vfprintf+0x286>
    6e62:	80 37       	cpi	r24, 0x70	; 112
    6e64:	21 f0       	breq	.+8      	; 0x6e6e <vfprintf+0x27c>
    6e66:	88 37       	cpi	r24, 0x78	; 120
    6e68:	09 f0       	breq	.+2      	; 0x6e6c <vfprintf+0x27a>
    6e6a:	a8 c0       	rjmp	.+336    	; 0x6fbc <vfprintf+0x3ca>
    6e6c:	01 c0       	rjmp	.+2      	; 0x6e70 <vfprintf+0x27e>
    6e6e:	10 61       	ori	r17, 0x10	; 16
    6e70:	14 ff       	sbrs	r17, 4
    6e72:	09 c0       	rjmp	.+18     	; 0x6e86 <vfprintf+0x294>
    6e74:	14 60       	ori	r17, 0x04	; 4
    6e76:	07 c0       	rjmp	.+14     	; 0x6e86 <vfprintf+0x294>
    6e78:	14 ff       	sbrs	r17, 4
    6e7a:	08 c0       	rjmp	.+16     	; 0x6e8c <vfprintf+0x29a>
    6e7c:	16 60       	ori	r17, 0x06	; 6
    6e7e:	06 c0       	rjmp	.+12     	; 0x6e8c <vfprintf+0x29a>
    6e80:	28 e0       	ldi	r18, 0x08	; 8
    6e82:	30 e0       	ldi	r19, 0x00	; 0
    6e84:	05 c0       	rjmp	.+10     	; 0x6e90 <vfprintf+0x29e>
    6e86:	20 e1       	ldi	r18, 0x10	; 16
    6e88:	30 e0       	ldi	r19, 0x00	; 0
    6e8a:	02 c0       	rjmp	.+4      	; 0x6e90 <vfprintf+0x29e>
    6e8c:	20 e1       	ldi	r18, 0x10	; 16
    6e8e:	32 e0       	ldi	r19, 0x02	; 2
    6e90:	f5 01       	movw	r30, r10
    6e92:	17 ff       	sbrs	r17, 7
    6e94:	07 c0       	rjmp	.+14     	; 0x6ea4 <vfprintf+0x2b2>
    6e96:	60 81       	ld	r22, Z
    6e98:	71 81       	ldd	r23, Z+1	; 0x01
    6e9a:	82 81       	ldd	r24, Z+2	; 0x02
    6e9c:	93 81       	ldd	r25, Z+3	; 0x03
    6e9e:	44 e0       	ldi	r20, 0x04	; 4
    6ea0:	50 e0       	ldi	r21, 0x00	; 0
    6ea2:	06 c0       	rjmp	.+12     	; 0x6eb0 <vfprintf+0x2be>
    6ea4:	60 81       	ld	r22, Z
    6ea6:	71 81       	ldd	r23, Z+1	; 0x01
    6ea8:	80 e0       	ldi	r24, 0x00	; 0
    6eaa:	90 e0       	ldi	r25, 0x00	; 0
    6eac:	42 e0       	ldi	r20, 0x02	; 2
    6eae:	50 e0       	ldi	r21, 0x00	; 0
    6eb0:	a4 0e       	add	r10, r20
    6eb2:	b5 1e       	adc	r11, r21
    6eb4:	a2 01       	movw	r20, r4
    6eb6:	0e 94 45 38 	call	0x708a	; 0x708a <__ultoa_invert>
    6eba:	d8 2e       	mov	r13, r24
    6ebc:	d4 18       	sub	r13, r4
    6ebe:	01 2f       	mov	r16, r17
    6ec0:	0f 77       	andi	r16, 0x7F	; 127
    6ec2:	06 ff       	sbrs	r16, 6
    6ec4:	09 c0       	rjmp	.+18     	; 0x6ed8 <vfprintf+0x2e6>
    6ec6:	0e 7f       	andi	r16, 0xFE	; 254
    6ec8:	df 14       	cp	r13, r15
    6eca:	30 f4       	brcc	.+12     	; 0x6ed8 <vfprintf+0x2e6>
    6ecc:	04 ff       	sbrs	r16, 4
    6ece:	06 c0       	rjmp	.+12     	; 0x6edc <vfprintf+0x2ea>
    6ed0:	02 fd       	sbrc	r16, 2
    6ed2:	04 c0       	rjmp	.+8      	; 0x6edc <vfprintf+0x2ea>
    6ed4:	0f 7e       	andi	r16, 0xEF	; 239
    6ed6:	02 c0       	rjmp	.+4      	; 0x6edc <vfprintf+0x2ea>
    6ed8:	1d 2d       	mov	r17, r13
    6eda:	01 c0       	rjmp	.+2      	; 0x6ede <vfprintf+0x2ec>
    6edc:	1f 2d       	mov	r17, r15
    6ede:	80 2f       	mov	r24, r16
    6ee0:	90 e0       	ldi	r25, 0x00	; 0
    6ee2:	04 ff       	sbrs	r16, 4
    6ee4:	0c c0       	rjmp	.+24     	; 0x6efe <vfprintf+0x30c>
    6ee6:	fe 01       	movw	r30, r28
    6ee8:	ed 0d       	add	r30, r13
    6eea:	f1 1d       	adc	r31, r1
    6eec:	20 81       	ld	r18, Z
    6eee:	20 33       	cpi	r18, 0x30	; 48
    6ef0:	11 f4       	brne	.+4      	; 0x6ef6 <vfprintf+0x304>
    6ef2:	09 7e       	andi	r16, 0xE9	; 233
    6ef4:	09 c0       	rjmp	.+18     	; 0x6f08 <vfprintf+0x316>
    6ef6:	02 ff       	sbrs	r16, 2
    6ef8:	06 c0       	rjmp	.+12     	; 0x6f06 <vfprintf+0x314>
    6efa:	1e 5f       	subi	r17, 0xFE	; 254
    6efc:	05 c0       	rjmp	.+10     	; 0x6f08 <vfprintf+0x316>
    6efe:	86 78       	andi	r24, 0x86	; 134
    6f00:	90 70       	andi	r25, 0x00	; 0
    6f02:	00 97       	sbiw	r24, 0x00	; 0
    6f04:	09 f0       	breq	.+2      	; 0x6f08 <vfprintf+0x316>
    6f06:	1f 5f       	subi	r17, 0xFF	; 255
    6f08:	80 2e       	mov	r8, r16
    6f0a:	99 24       	eor	r9, r9
    6f0c:	03 fd       	sbrc	r16, 3
    6f0e:	12 c0       	rjmp	.+36     	; 0x6f34 <vfprintf+0x342>
    6f10:	00 ff       	sbrs	r16, 0
    6f12:	0d c0       	rjmp	.+26     	; 0x6f2e <vfprintf+0x33c>
    6f14:	fd 2c       	mov	r15, r13
    6f16:	1e 15       	cp	r17, r14
    6f18:	50 f4       	brcc	.+20     	; 0x6f2e <vfprintf+0x33c>
    6f1a:	fe 0c       	add	r15, r14
    6f1c:	f1 1a       	sub	r15, r17
    6f1e:	1e 2d       	mov	r17, r14
    6f20:	06 c0       	rjmp	.+12     	; 0x6f2e <vfprintf+0x33c>
    6f22:	80 e2       	ldi	r24, 0x20	; 32
    6f24:	90 e0       	ldi	r25, 0x00	; 0
    6f26:	b3 01       	movw	r22, r6
    6f28:	0e 94 19 38 	call	0x7032	; 0x7032 <fputc>
    6f2c:	1f 5f       	subi	r17, 0xFF	; 255
    6f2e:	1e 15       	cp	r17, r14
    6f30:	c0 f3       	brcs	.-16     	; 0x6f22 <vfprintf+0x330>
    6f32:	04 c0       	rjmp	.+8      	; 0x6f3c <vfprintf+0x34a>
    6f34:	1e 15       	cp	r17, r14
    6f36:	10 f4       	brcc	.+4      	; 0x6f3c <vfprintf+0x34a>
    6f38:	e1 1a       	sub	r14, r17
    6f3a:	01 c0       	rjmp	.+2      	; 0x6f3e <vfprintf+0x34c>
    6f3c:	ee 24       	eor	r14, r14
    6f3e:	84 fe       	sbrs	r8, 4
    6f40:	0f c0       	rjmp	.+30     	; 0x6f60 <vfprintf+0x36e>
    6f42:	80 e3       	ldi	r24, 0x30	; 48
    6f44:	90 e0       	ldi	r25, 0x00	; 0
    6f46:	b3 01       	movw	r22, r6
    6f48:	0e 94 19 38 	call	0x7032	; 0x7032 <fputc>
    6f4c:	82 fe       	sbrs	r8, 2
    6f4e:	1f c0       	rjmp	.+62     	; 0x6f8e <vfprintf+0x39c>
    6f50:	81 fe       	sbrs	r8, 1
    6f52:	03 c0       	rjmp	.+6      	; 0x6f5a <vfprintf+0x368>
    6f54:	88 e5       	ldi	r24, 0x58	; 88
    6f56:	90 e0       	ldi	r25, 0x00	; 0
    6f58:	10 c0       	rjmp	.+32     	; 0x6f7a <vfprintf+0x388>
    6f5a:	88 e7       	ldi	r24, 0x78	; 120
    6f5c:	90 e0       	ldi	r25, 0x00	; 0
    6f5e:	0d c0       	rjmp	.+26     	; 0x6f7a <vfprintf+0x388>
    6f60:	c4 01       	movw	r24, r8
    6f62:	86 78       	andi	r24, 0x86	; 134
    6f64:	90 70       	andi	r25, 0x00	; 0
    6f66:	00 97       	sbiw	r24, 0x00	; 0
    6f68:	91 f0       	breq	.+36     	; 0x6f8e <vfprintf+0x39c>
    6f6a:	81 fc       	sbrc	r8, 1
    6f6c:	02 c0       	rjmp	.+4      	; 0x6f72 <vfprintf+0x380>
    6f6e:	80 e2       	ldi	r24, 0x20	; 32
    6f70:	01 c0       	rjmp	.+2      	; 0x6f74 <vfprintf+0x382>
    6f72:	8b e2       	ldi	r24, 0x2B	; 43
    6f74:	07 fd       	sbrc	r16, 7
    6f76:	8d e2       	ldi	r24, 0x2D	; 45
    6f78:	90 e0       	ldi	r25, 0x00	; 0
    6f7a:	b3 01       	movw	r22, r6
    6f7c:	0e 94 19 38 	call	0x7032	; 0x7032 <fputc>
    6f80:	06 c0       	rjmp	.+12     	; 0x6f8e <vfprintf+0x39c>
    6f82:	80 e3       	ldi	r24, 0x30	; 48
    6f84:	90 e0       	ldi	r25, 0x00	; 0
    6f86:	b3 01       	movw	r22, r6
    6f88:	0e 94 19 38 	call	0x7032	; 0x7032 <fputc>
    6f8c:	fa 94       	dec	r15
    6f8e:	df 14       	cp	r13, r15
    6f90:	c0 f3       	brcs	.-16     	; 0x6f82 <vfprintf+0x390>
    6f92:	da 94       	dec	r13
    6f94:	f2 01       	movw	r30, r4
    6f96:	ed 0d       	add	r30, r13
    6f98:	f1 1d       	adc	r31, r1
    6f9a:	80 81       	ld	r24, Z
    6f9c:	90 e0       	ldi	r25, 0x00	; 0
    6f9e:	b3 01       	movw	r22, r6
    6fa0:	0e 94 19 38 	call	0x7032	; 0x7032 <fputc>
    6fa4:	dd 20       	and	r13, r13
    6fa6:	a9 f7       	brne	.-22     	; 0x6f92 <vfprintf+0x3a0>
    6fa8:	06 c0       	rjmp	.+12     	; 0x6fb6 <vfprintf+0x3c4>
    6faa:	80 e2       	ldi	r24, 0x20	; 32
    6fac:	90 e0       	ldi	r25, 0x00	; 0
    6fae:	b3 01       	movw	r22, r6
    6fb0:	0e 94 19 38 	call	0x7032	; 0x7032 <fputc>
    6fb4:	ea 94       	dec	r14
    6fb6:	ee 20       	and	r14, r14
    6fb8:	c1 f7       	brne	.-16     	; 0x6faa <vfprintf+0x3b8>
    6fba:	40 ce       	rjmp	.-896    	; 0x6c3c <vfprintf+0x4a>
    6fbc:	f3 01       	movw	r30, r6
    6fbe:	86 81       	ldd	r24, Z+6	; 0x06
    6fc0:	97 81       	ldd	r25, Z+7	; 0x07
    6fc2:	02 c0       	rjmp	.+4      	; 0x6fc8 <vfprintf+0x3d6>
    6fc4:	8f ef       	ldi	r24, 0xFF	; 255
    6fc6:	9f ef       	ldi	r25, 0xFF	; 255
    6fc8:	2d 96       	adiw	r28, 0x0d	; 13
    6fca:	cd bf       	out	0x3d, r28	; 61
    6fcc:	de bf       	out	0x3e, r29	; 62
    6fce:	df 91       	pop	r29
    6fd0:	cf 91       	pop	r28
    6fd2:	1f 91       	pop	r17
    6fd4:	0f 91       	pop	r16
    6fd6:	ff 90       	pop	r15
    6fd8:	ef 90       	pop	r14
    6fda:	df 90       	pop	r13
    6fdc:	cf 90       	pop	r12
    6fde:	bf 90       	pop	r11
    6fe0:	af 90       	pop	r10
    6fe2:	9f 90       	pop	r9
    6fe4:	8f 90       	pop	r8
    6fe6:	7f 90       	pop	r7
    6fe8:	6f 90       	pop	r6
    6fea:	5f 90       	pop	r5
    6fec:	4f 90       	pop	r4
    6fee:	3f 90       	pop	r3
    6ff0:	2f 90       	pop	r2
    6ff2:	08 95       	ret

00006ff4 <strnlen_P>:
    6ff4:	fc 01       	movw	r30, r24
    6ff6:	05 90       	lpm	r0, Z+
    6ff8:	61 50       	subi	r22, 0x01	; 1
    6ffa:	70 40       	sbci	r23, 0x00	; 0
    6ffc:	01 10       	cpse	r0, r1
    6ffe:	d8 f7       	brcc	.-10     	; 0x6ff6 <strnlen_P+0x2>
    7000:	80 95       	com	r24
    7002:	90 95       	com	r25
    7004:	8e 0f       	add	r24, r30
    7006:	9f 1f       	adc	r25, r31
    7008:	08 95       	ret

0000700a <memcpy>:
    700a:	fb 01       	movw	r30, r22
    700c:	dc 01       	movw	r26, r24
    700e:	02 c0       	rjmp	.+4      	; 0x7014 <memcpy+0xa>
    7010:	01 90       	ld	r0, Z+
    7012:	0d 92       	st	X+, r0
    7014:	41 50       	subi	r20, 0x01	; 1
    7016:	50 40       	sbci	r21, 0x00	; 0
    7018:	d8 f7       	brcc	.-10     	; 0x7010 <memcpy+0x6>
    701a:	08 95       	ret

0000701c <strnlen>:
    701c:	fc 01       	movw	r30, r24
    701e:	61 50       	subi	r22, 0x01	; 1
    7020:	70 40       	sbci	r23, 0x00	; 0
    7022:	01 90       	ld	r0, Z+
    7024:	01 10       	cpse	r0, r1
    7026:	d8 f7       	brcc	.-10     	; 0x701e <strnlen+0x2>
    7028:	80 95       	com	r24
    702a:	90 95       	com	r25
    702c:	8e 0f       	add	r24, r30
    702e:	9f 1f       	adc	r25, r31
    7030:	08 95       	ret

00007032 <fputc>:
    7032:	0f 93       	push	r16
    7034:	1f 93       	push	r17
    7036:	cf 93       	push	r28
    7038:	df 93       	push	r29
    703a:	8c 01       	movw	r16, r24
    703c:	eb 01       	movw	r28, r22
    703e:	8b 81       	ldd	r24, Y+3	; 0x03
    7040:	81 ff       	sbrs	r24, 1
    7042:	1b c0       	rjmp	.+54     	; 0x707a <fputc+0x48>
    7044:	82 ff       	sbrs	r24, 2
    7046:	0d c0       	rjmp	.+26     	; 0x7062 <fputc+0x30>
    7048:	2e 81       	ldd	r18, Y+6	; 0x06
    704a:	3f 81       	ldd	r19, Y+7	; 0x07
    704c:	8c 81       	ldd	r24, Y+4	; 0x04
    704e:	9d 81       	ldd	r25, Y+5	; 0x05
    7050:	28 17       	cp	r18, r24
    7052:	39 07       	cpc	r19, r25
    7054:	64 f4       	brge	.+24     	; 0x706e <fputc+0x3c>
    7056:	e8 81       	ld	r30, Y
    7058:	f9 81       	ldd	r31, Y+1	; 0x01
    705a:	01 93       	st	Z+, r16
    705c:	e8 83       	st	Y, r30
    705e:	f9 83       	std	Y+1, r31	; 0x01
    7060:	06 c0       	rjmp	.+12     	; 0x706e <fputc+0x3c>
    7062:	e8 85       	ldd	r30, Y+8	; 0x08
    7064:	f9 85       	ldd	r31, Y+9	; 0x09
    7066:	80 2f       	mov	r24, r16
    7068:	19 95       	eicall
    706a:	00 97       	sbiw	r24, 0x00	; 0
    706c:	31 f4       	brne	.+12     	; 0x707a <fputc+0x48>
    706e:	8e 81       	ldd	r24, Y+6	; 0x06
    7070:	9f 81       	ldd	r25, Y+7	; 0x07
    7072:	01 96       	adiw	r24, 0x01	; 1
    7074:	8e 83       	std	Y+6, r24	; 0x06
    7076:	9f 83       	std	Y+7, r25	; 0x07
    7078:	02 c0       	rjmp	.+4      	; 0x707e <fputc+0x4c>
    707a:	0f ef       	ldi	r16, 0xFF	; 255
    707c:	1f ef       	ldi	r17, 0xFF	; 255
    707e:	c8 01       	movw	r24, r16
    7080:	df 91       	pop	r29
    7082:	cf 91       	pop	r28
    7084:	1f 91       	pop	r17
    7086:	0f 91       	pop	r16
    7088:	08 95       	ret

0000708a <__ultoa_invert>:
    708a:	fa 01       	movw	r30, r20
    708c:	aa 27       	eor	r26, r26
    708e:	28 30       	cpi	r18, 0x08	; 8
    7090:	51 f1       	breq	.+84     	; 0x70e6 <__ultoa_invert+0x5c>
    7092:	20 31       	cpi	r18, 0x10	; 16
    7094:	81 f1       	breq	.+96     	; 0x70f6 <__ultoa_invert+0x6c>
    7096:	e8 94       	clt
    7098:	6f 93       	push	r22
    709a:	6e 7f       	andi	r22, 0xFE	; 254
    709c:	6e 5f       	subi	r22, 0xFE	; 254
    709e:	7f 4f       	sbci	r23, 0xFF	; 255
    70a0:	8f 4f       	sbci	r24, 0xFF	; 255
    70a2:	9f 4f       	sbci	r25, 0xFF	; 255
    70a4:	af 4f       	sbci	r26, 0xFF	; 255
    70a6:	b1 e0       	ldi	r27, 0x01	; 1
    70a8:	3e d0       	rcall	.+124    	; 0x7126 <__ultoa_invert+0x9c>
    70aa:	b4 e0       	ldi	r27, 0x04	; 4
    70ac:	3c d0       	rcall	.+120    	; 0x7126 <__ultoa_invert+0x9c>
    70ae:	67 0f       	add	r22, r23
    70b0:	78 1f       	adc	r23, r24
    70b2:	89 1f       	adc	r24, r25
    70b4:	9a 1f       	adc	r25, r26
    70b6:	a1 1d       	adc	r26, r1
    70b8:	68 0f       	add	r22, r24
    70ba:	79 1f       	adc	r23, r25
    70bc:	8a 1f       	adc	r24, r26
    70be:	91 1d       	adc	r25, r1
    70c0:	a1 1d       	adc	r26, r1
    70c2:	6a 0f       	add	r22, r26
    70c4:	71 1d       	adc	r23, r1
    70c6:	81 1d       	adc	r24, r1
    70c8:	91 1d       	adc	r25, r1
    70ca:	a1 1d       	adc	r26, r1
    70cc:	20 d0       	rcall	.+64     	; 0x710e <__ultoa_invert+0x84>
    70ce:	09 f4       	brne	.+2      	; 0x70d2 <__ultoa_invert+0x48>
    70d0:	68 94       	set
    70d2:	3f 91       	pop	r19
    70d4:	2a e0       	ldi	r18, 0x0A	; 10
    70d6:	26 9f       	mul	r18, r22
    70d8:	11 24       	eor	r1, r1
    70da:	30 19       	sub	r19, r0
    70dc:	30 5d       	subi	r19, 0xD0	; 208
    70de:	31 93       	st	Z+, r19
    70e0:	de f6       	brtc	.-74     	; 0x7098 <__ultoa_invert+0xe>
    70e2:	cf 01       	movw	r24, r30
    70e4:	08 95       	ret
    70e6:	46 2f       	mov	r20, r22
    70e8:	47 70       	andi	r20, 0x07	; 7
    70ea:	40 5d       	subi	r20, 0xD0	; 208
    70ec:	41 93       	st	Z+, r20
    70ee:	b3 e0       	ldi	r27, 0x03	; 3
    70f0:	0f d0       	rcall	.+30     	; 0x7110 <__ultoa_invert+0x86>
    70f2:	c9 f7       	brne	.-14     	; 0x70e6 <__ultoa_invert+0x5c>
    70f4:	f6 cf       	rjmp	.-20     	; 0x70e2 <__ultoa_invert+0x58>
    70f6:	46 2f       	mov	r20, r22
    70f8:	4f 70       	andi	r20, 0x0F	; 15
    70fa:	40 5d       	subi	r20, 0xD0	; 208
    70fc:	4a 33       	cpi	r20, 0x3A	; 58
    70fe:	18 f0       	brcs	.+6      	; 0x7106 <__ultoa_invert+0x7c>
    7100:	49 5d       	subi	r20, 0xD9	; 217
    7102:	31 fd       	sbrc	r19, 1
    7104:	40 52       	subi	r20, 0x20	; 32
    7106:	41 93       	st	Z+, r20
    7108:	02 d0       	rcall	.+4      	; 0x710e <__ultoa_invert+0x84>
    710a:	a9 f7       	brne	.-22     	; 0x70f6 <__ultoa_invert+0x6c>
    710c:	ea cf       	rjmp	.-44     	; 0x70e2 <__ultoa_invert+0x58>
    710e:	b4 e0       	ldi	r27, 0x04	; 4
    7110:	a6 95       	lsr	r26
    7112:	97 95       	ror	r25
    7114:	87 95       	ror	r24
    7116:	77 95       	ror	r23
    7118:	67 95       	ror	r22
    711a:	ba 95       	dec	r27
    711c:	c9 f7       	brne	.-14     	; 0x7110 <__ultoa_invert+0x86>
    711e:	00 97       	sbiw	r24, 0x00	; 0
    7120:	61 05       	cpc	r22, r1
    7122:	71 05       	cpc	r23, r1
    7124:	08 95       	ret
    7126:	9b 01       	movw	r18, r22
    7128:	ac 01       	movw	r20, r24
    712a:	0a 2e       	mov	r0, r26
    712c:	06 94       	lsr	r0
    712e:	57 95       	ror	r21
    7130:	47 95       	ror	r20
    7132:	37 95       	ror	r19
    7134:	27 95       	ror	r18
    7136:	ba 95       	dec	r27
    7138:	c9 f7       	brne	.-14     	; 0x712c <__ultoa_invert+0xa2>
    713a:	62 0f       	add	r22, r18
    713c:	73 1f       	adc	r23, r19
    713e:	84 1f       	adc	r24, r20
    7140:	95 1f       	adc	r25, r21
    7142:	a0 1d       	adc	r26, r0
    7144:	08 95       	ret

00007146 <_exit>:
    7146:	f8 94       	cli

00007148 <__stop_program>:
    7148:	ff cf       	rjmp	.-2      	; 0x7148 <__stop_program>
